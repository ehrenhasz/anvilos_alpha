{
  "module_name": "wlan.c",
  "hash_id": "fb18c6ea221368721578e7161225720df11e1808c1437335f953a50c2c2844d1",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/src/wlan.c",
  "human_readable_source": " \n\n\n\n \n \n \n#include \"simplelink.h\"\n#include \"protocol.h\"\n#include \"driver.h\"\n\n \n \n \n#define MAX_SSID_LEN           (32)\n#define MAX_KEY_LEN            (63)\n#define MAX_USER_LEN           (32)\n#define MAX_ANON_USER_LEN      (32)\n#define MAX_SMART_CONFIG_KEY   (16)\n\n\n \ntypedef struct \n{\n    _WlanConnectEapCommand_t    Args;\n    _i8                        Strings[MAX_SSID_LEN + MAX_KEY_LEN + MAX_USER_LEN + MAX_ANON_USER_LEN];\n}_WlanConnectCmd_t;\n\ntypedef union\n{\n    _WlanConnectCmd_t   Cmd;\n    _BasicResponse_t\tRsp;\n}_SlWlanConnectMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_WlanConnect)\n_i16 sl_WlanConnect(const _i8*  pName,const _i16 NameLen,const _u8 *pMacAddr,const SlSecParams_t* pSecParams ,const SlSecParamsExt_t* pSecExtParams)\n{\n    _SlWlanConnectMsg_u    Msg;\n    _SlCmdCtrl_t           CmdCtrl;\n\n    sl_Memset (&Msg, 0, sizeof(Msg));\n\n    CmdCtrl.TxDescLen = 0; \n    CmdCtrl.RxDescLen = sizeof(_BasicResponse_t);\n\n     \n    VERIFY_PROTOCOL(NameLen <= MAX_SSID_LEN);\n     \n    if( NULL == pName )\n    {\n       return SL_INVALPARAM;\n    }\n     \n    Msg.Cmd.Args.Common.SsidLen = (_u8)NameLen;\n\n     \n     \n    if (NULL != pSecExtParams)\n    {\n         \n        CmdCtrl.Opcode = SL_OPCODE_WLAN_WLANCONNECTEAPCOMMAND;\n        CmdCtrl.TxDescLen += sizeof(_WlanConnectEapCommand_t);\n         \n        sl_Memcpy(EAP_SSID_STRING(&Msg), pName, NameLen);\n        CmdCtrl.TxDescLen += NameLen;\n         \n        if ((NULL != pSecParams) && (pSecParams->KeyLen > 0))\n        {\n             \n            Msg.Cmd.Args.Common.SecType = pSecParams->Type;\n             \n            if (pSecParams->KeyLen > MAX_KEY_LEN)\n            {\n                return SL_INVALPARAM;\n            }\n             \n            Msg.Cmd.Args.Common.PasswordLen = pSecParams->KeyLen;\n            ARG_CHECK_PTR(pSecParams->Key);\n             \n            sl_Memcpy(EAP_PASSWORD_STRING(&Msg), pSecParams->Key, pSecParams->KeyLen);\n            CmdCtrl.TxDescLen += pSecParams->KeyLen;\n        }\n        else\n        {\n            Msg.Cmd.Args.Common.PasswordLen = 0;\n        }\n\n        ARG_CHECK_PTR(pSecExtParams);\n         \n        Msg.Cmd.Args.EapBitmask = pSecExtParams->EapMethod;\n         \n        Msg.Cmd.Args.CertIndex = pSecExtParams->CertIndex;\n         \n        if (pSecExtParams->UserLen > MAX_USER_LEN)\n        {\n            return SL_INVALPARAM;\n        }\n        Msg.Cmd.Args.UserLen = pSecExtParams->UserLen;\n         \n        if(pSecExtParams->UserLen > 0)\n        {\n            sl_Memcpy(EAP_USER_STRING(&Msg), pSecExtParams->User, pSecExtParams->UserLen);\n            CmdCtrl.TxDescLen += pSecExtParams->UserLen;\n        }\n         \n        if (pSecExtParams->AnonUserLen > MAX_ANON_USER_LEN)\n        {\n            return SL_INVALPARAM;\n        }\n        Msg.Cmd.Args.AnonUserLen = pSecExtParams->AnonUserLen;\n         \n        if(pSecExtParams->AnonUserLen > 0)\n        {\n            sl_Memcpy(EAP_ANON_USER_STRING(&Msg), pSecExtParams->AnonUser, pSecExtParams->AnonUserLen);\n            CmdCtrl.TxDescLen += pSecExtParams->AnonUserLen;\n        }\n\n    }\n\n     \n    else\n    {\n         \n        CmdCtrl.Opcode = SL_OPCODE_WLAN_WLANCONNECTCOMMAND;\n        CmdCtrl.TxDescLen += sizeof(_WlanConnectCommon_t);\n         \n        sl_Memcpy(SSID_STRING(&Msg), pName, NameLen);\t\n        CmdCtrl.TxDescLen += NameLen;\n         \n        if( NULL != pSecParams )\n        {\n             \n            Msg.Cmd.Args.Common.SecType = pSecParams->Type;\n             \n            if (pSecParams->KeyLen > MAX_KEY_LEN)\n            {\n                return SL_INVALPARAM;\n            }\n             \n            Msg.Cmd.Args.Common.PasswordLen = pSecParams->KeyLen;\n            CmdCtrl.TxDescLen += pSecParams->KeyLen;\n             \n            if( NULL != pSecParams->Key )\n            {\n                sl_Memcpy(PASSWORD_STRING(&Msg), pSecParams->Key, pSecParams->KeyLen);\n            }\n        }\n         \n        else\n        {\n            Msg.Cmd.Args.Common.PasswordLen = 0;\n            Msg.Cmd.Args.Common.SecType = SL_SEC_TYPE_OPEN;\n        }\t\n    }\n     \n    if(NULL != pMacAddr)\n    {\n        sl_Memcpy(Msg.Cmd.Args.Common.Bssid, pMacAddr, sizeof(Msg.Cmd.Args.Common.Bssid));\n    }\n    else\n    {\n        _SlDrvMemZero(Msg.Cmd.Args.Common.Bssid, sizeof(Msg.Cmd.Args.Common.Bssid));\n    }\n\n\n    VERIFY_RET_OK ( _SlDrvCmdOp(&CmdCtrl, &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_WlanDisconnect)\n_i16 sl_WlanDisconnect(void)\n{\n    return _SlDrvBasicCmd(SL_OPCODE_WLAN_WLANDISCONNECTCOMMAND);\n}\n#endif\n\n \n \n \ntypedef union\n{\n    _WlanPoliciySetGet_t    Cmd;\n    _BasicResponse_t\t    Rsp;\n}_SlPolicyMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_WlanPolicySet)\n\nconst _SlCmdCtrl_t _SlPolicySetCmdCtrl =\n{\n    SL_OPCODE_WLAN_POLICYSETCOMMAND,\n    sizeof(_WlanPoliciySetGet_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i16 sl_WlanPolicySet(const _u8 Type , const _u8 Policy, _u8 *pVal,const _u8 ValLen)\n{\n    _SlPolicyMsg_u         Msg;\n    _SlCmdExt_t            CmdExt;\n\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = ValLen;\n    CmdExt.pTxPayload = (_u8 *)pVal;\n\n\n    Msg.Cmd.PolicyType        = Type;\n    Msg.Cmd.PolicyOption      = Policy;\n    Msg.Cmd.PolicyOptionLen   = ValLen;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlPolicySetCmdCtrl, &Msg, &CmdExt));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n\n \n \n \ntypedef union\n{\n    _WlanPoliciySetGet_t\t    Cmd;\n    _WlanPoliciySetGet_t\t    Rsp;\n}_SlPolicyGetMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_WlanPolicyGet)\n\nconst _SlCmdCtrl_t _SlPolicyGetCmdCtrl =\n{\n    SL_OPCODE_WLAN_POLICYGETCOMMAND,\n    sizeof(_WlanPoliciySetGet_t),\n    sizeof(_WlanPoliciySetGet_t)\n};\n\n_i16 sl_WlanPolicyGet(const _u8 Type ,_u8 Policy,_u8 *pVal,_u8 *pValLen)\n{\n    _SlPolicyGetMsg_u      Msg;\n    _SlCmdExt_t            CmdExt;\n\n    if (*pValLen == 0)\n    {\n        return SL_EZEROLEN;\n    }\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = *pValLen;\n    CmdExt.pRxPayload = pVal;\n\n    Msg.Cmd.PolicyType = Type;\n    Msg.Cmd.PolicyOption = Policy;\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlPolicyGetCmdCtrl, &Msg, &CmdExt));\n\n\n    if (CmdExt.RxPayloadLen < CmdExt.ActualRxPayloadLen) \n    {\n        *pValLen = Msg.Rsp.PolicyOptionLen;\n        return SL_ESMALLBUF;\n    }\n    else\n    {\n         \n        *pValLen = (_u8)CmdExt.ActualRxPayloadLen;\n        if( 0 == CmdExt.ActualRxPayloadLen )\n        {\n            *pValLen = 1;\n            pVal[0] = Msg.Rsp.PolicyOption;\n        }\n    }\n    return (_i16)SL_OS_RET_CODE_OK;\n}\n#endif\n\n\n \n \n \ntypedef struct\n{\n    _WlanAddGetEapProfile_t\tArgs;\n    _i8                    Strings[MAX_SSID_LEN + MAX_KEY_LEN + MAX_USER_LEN + MAX_ANON_USER_LEN];\n}_SlProfileParams_t;\n\ntypedef union\n{\n    _SlProfileParams_t\t    Cmd;\n    _BasicResponse_t\t    Rsp;\n}_SlProfileAddMsg_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_WlanProfileAdd)\n_i16 sl_WlanProfileAdd(const _i8*  pName,const  _i16 NameLen,const  _u8 *pMacAddr,const  SlSecParams_t* pSecParams ,const SlSecParamsExt_t* pSecExtParams,const _u32  Priority,const _u32  Options)\n{\n    _SlProfileAddMsg_u      Msg;\n    _SlCmdCtrl_t           CmdCtrl = {0};\n    CmdCtrl.TxDescLen = 0; \n    CmdCtrl.RxDescLen = sizeof(_BasicResponse_t);\n\n     \n    Msg.Cmd.Args.Common.Priority = (_u8)Priority; \n     \n    if( NULL == pName )\n    {\n       return SL_INVALPARAM;\n    }\n     \n    VERIFY_PROTOCOL(NameLen <= MAX_SSID_LEN);\n     \n    Msg.Cmd.Args.Common.SsidLen = (_u8)NameLen;\n\n\n     \n    if  (NULL != pSecExtParams)\n    {\n         \n        CmdCtrl.Opcode = SL_OPCODE_WLAN_EAP_PROFILEADDCOMMAND;\n        CmdCtrl.TxDescLen += sizeof(_WlanAddGetEapProfile_t);\n\n         \n        sl_Memcpy(EAP_PROFILE_SSID_STRING(&Msg), pName, NameLen);\t\n        CmdCtrl.TxDescLen += NameLen;\n\n         \n        if ((NULL != pSecParams) && (pSecParams->KeyLen > 0))\n        {\n             \n            Msg.Cmd.Args.Common.SecType = pSecParams->Type;\n\n            if( SL_SEC_TYPE_WEP == Msg.Cmd.Args.Common.SecType )\n            {\n                Msg.Cmd.Args.Common.WepKeyId = 0;\n            }\n\n             \n            if (pSecParams->KeyLen > MAX_KEY_LEN)\n            {\n                return SL_INVALPARAM;\n            }\n            VERIFY_PROTOCOL(pSecParams->KeyLen <= MAX_KEY_LEN);\n             \n            Msg.Cmd.Args.Common.PasswordLen = pSecParams->KeyLen;\t\n            CmdCtrl.TxDescLen += pSecParams->KeyLen;\n            ARG_CHECK_PTR(pSecParams->Key);\n             \n            sl_Memcpy(EAP_PROFILE_PASSWORD_STRING(&Msg), pSecParams->Key, pSecParams->KeyLen);\n        }\n        else\n        {\n            Msg.Cmd.Args.Common.PasswordLen = 0;\n        }\n\n        ARG_CHECK_PTR(pSecExtParams);\n         \n        Msg.Cmd.Args.EapBitmask = pSecExtParams->EapMethod;\n         \n        Msg.Cmd.Args.CertIndex = pSecExtParams->CertIndex;\n         \n        if (pSecExtParams->UserLen > MAX_USER_LEN)\n        {\n            return SL_INVALPARAM;\n        }\n        Msg.Cmd.Args.UserLen = pSecExtParams->UserLen;\n         \n        if(pSecExtParams->UserLen > 0)\n        {\n            sl_Memcpy(EAP_PROFILE_USER_STRING(&Msg), pSecExtParams->User, pSecExtParams->UserLen);\n            CmdCtrl.TxDescLen += pSecExtParams->UserLen;\n        }\n\n         \n        if (pSecExtParams->AnonUserLen > MAX_ANON_USER_LEN)\n        {\n            return SL_INVALPARAM;\n        }\n        Msg.Cmd.Args.AnonUserLen = pSecExtParams->AnonUserLen;\n\n         \n        if(pSecExtParams->AnonUserLen > 0)\n        {\n            sl_Memcpy(EAP_PROFILE_ANON_USER_STRING(&Msg), pSecExtParams->AnonUser, pSecExtParams->AnonUserLen);\n            CmdCtrl.TxDescLen += pSecExtParams->AnonUserLen;\n        }\n\n    }\n     \n    else\n    {\n         \n        CmdCtrl.Opcode = SL_OPCODE_WLAN_PROFILEADDCOMMAND;\n         \n        CmdCtrl.TxDescLen += sizeof(_WlanAddGetProfile_t);\n\n        if (NULL != pName)\n        {\n             \n            sl_Memcpy(PROFILE_SSID_STRING(&Msg), pName, NameLen);\n            CmdCtrl.TxDescLen += NameLen;\n        }\n\n         \n        if( NULL != pSecParams )\n        {\n             \n            Msg.Cmd.Args.Common.SecType = pSecParams->Type;\n\n            if( SL_SEC_TYPE_WEP == Msg.Cmd.Args.Common.SecType )\n            {\n                Msg.Cmd.Args.Common.WepKeyId = 0;\n            }\n\n             \n            if (pSecParams->KeyLen > MAX_KEY_LEN)\n            {\n                return SL_INVALPARAM;\n            }\n             \n            Msg.Cmd.Args.Common.PasswordLen = pSecParams->KeyLen;\n            CmdCtrl.TxDescLen += pSecParams->KeyLen;\n             \n            if( NULL != pSecParams->Key )\n            {\n                sl_Memcpy(PROFILE_PASSWORD_STRING(&Msg), pSecParams->Key, pSecParams->KeyLen);\n            }\n        }\n        else\n        {\n            Msg.Cmd.Args.Common.SecType = SL_SEC_TYPE_OPEN;\n            Msg.Cmd.Args.Common.PasswordLen = 0;\n        }\n\n    }\n\n\n     \n    if(NULL != pMacAddr)\n    {\n        sl_Memcpy(Msg.Cmd.Args.Common.Bssid, pMacAddr, sizeof(Msg.Cmd.Args.Common.Bssid));\n    }\n    else\n    {\n\t\t_SlDrvMemZero(Msg.Cmd.Args.Common.Bssid, sizeof(Msg.Cmd.Args.Common.Bssid));\n    }\n\n    VERIFY_RET_OK(_SlDrvCmdOp(&CmdCtrl, &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n \n \n \ntypedef union\n{\n    _WlanProfileDelGetCommand_t Cmd;\n    _SlProfileParams_t\t        Rsp;\n}_SlProfileGetMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_WlanProfileGet)\n\nconst _SlCmdCtrl_t _SlProfileGetCmdCtrl =\n{\n    SL_OPCODE_WLAN_PROFILEGETCOMMAND,\n    sizeof(_WlanProfileDelGetCommand_t),\n    sizeof(_SlProfileParams_t)\n};\n\n_i16 sl_WlanProfileGet(const _i16 Index,_i8*  pName, _i16 *pNameLen, _u8 *pMacAddr, SlSecParams_t* pSecParams, SlGetSecParamsExt_t* pEntParams, _u32 *pPriority)\n{\n    _SlProfileGetMsg_u      Msg;\n    Msg.Cmd.index = (_u8)Index;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlProfileGetCmdCtrl, &Msg, NULL));\n\n    pSecParams->Type = Msg.Rsp.Args.Common.SecType;\n     \n    pSecParams->KeyLen = Msg.Rsp.Args.Common.PasswordLen;\n    if (NULL != pEntParams)\n    {\n        pEntParams->UserLen = Msg.Rsp.Args.UserLen;\n         \n        if (pEntParams->UserLen > 0)\n        {\t \n            sl_Memcpy(pEntParams->User, EAP_PROFILE_USER_STRING(&Msg), pEntParams->UserLen);\n        }\n        pEntParams->AnonUserLen = Msg.Rsp.Args.AnonUserLen;\n         \n        if (pEntParams->AnonUserLen > 0)\n        {\n            sl_Memcpy(pEntParams->AnonUser, EAP_PROFILE_ANON_USER_STRING(&Msg), pEntParams->AnonUserLen);\n        }\n    }\n\n    *pNameLen  = Msg.Rsp.Args.Common.SsidLen;      \n    *pPriority = Msg.Rsp.Args.Common.Priority;       \n\n    sl_Memcpy(pMacAddr, Msg.Rsp.Args.Common.Bssid, sizeof(Msg.Rsp.Args.Common.Bssid));\n\n    sl_Memcpy(pName, EAP_PROFILE_SSID_STRING(&Msg), *pNameLen);\n\n    return (_i16)Msg.Rsp.Args.Common.SecType;\n\n}\n#endif\n \n \n \ntypedef union\n{\n    _WlanProfileDelGetCommand_t\t    Cmd;\n    _BasicResponse_t\t            Rsp;\n}_SlProfileDelMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_WlanProfileDel)\n\nconst _SlCmdCtrl_t _SlProfileDelCmdCtrl =\n{\n    SL_OPCODE_WLAN_PROFILEDELCOMMAND,\n    sizeof(_WlanProfileDelGetCommand_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i16 sl_WlanProfileDel(const _i16 Index)\n{\n    _SlProfileDelMsg_u Msg;\n\n    Msg.Cmd.index = (_u8)Index;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlProfileDelCmdCtrl, &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n\n \n \n \ntypedef union\n{\n    _WlanGetNetworkListCommand_t    Cmd;\n    _WlanGetNetworkListResponse_t   Rsp;\n}_SlWlanGetNetworkListMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_WlanGetNetworkList)\n\nconst _SlCmdCtrl_t _SlWlanGetNetworkListCtrl =\n{\n    SL_OPCODE_WLAN_SCANRESULTSGETCOMMAND,\n    sizeof(_WlanGetNetworkListCommand_t),\n    sizeof(_WlanGetNetworkListResponse_t)\n};\n\n_i16 sl_WlanGetNetworkList(const _u8 Index,const _u8 Count, Sl_WlanNetworkEntry_t *pEntries)\n{\n    _i16 retVal = 0;\n    _SlWlanGetNetworkListMsg_u Msg;\n    _SlCmdExt_t    CmdExt;\n\n    if (Count == 0)\n    {\n        return SL_EZEROLEN;\n    }\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = sizeof(Sl_WlanNetworkEntry_t)*(Count);\n    CmdExt.pRxPayload = (_u8 *)pEntries; \n\n    Msg.Cmd.index = Index;\n    Msg.Cmd.count = Count;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlWlanGetNetworkListCtrl, &Msg, &CmdExt));\n    retVal = Msg.Rsp.status;\n\n    return (_i16)retVal;\n}\n#endif\n\n\n\n\n\n \n \n \n\n \ntypedef union\n{\n    _WlanRxFilterAddCommand_t\t          Cmd;\n    _WlanRxFilterAddCommandReponse_t      Rsp;\n}_SlrxFilterAddMsg_u;\n\n\n \ntypedef union _SlRxFilterSetMsg_u\n{\n    _WlanRxFilterSetCommand_t\t            Cmd;\n    _WlanRxFilterSetCommandReponse_t        Rsp;\n}_SlRxFilterSetMsg_u;\n\n\n \ntypedef union _SlRxFilterGetMsg_u\n{\n    _WlanRxFilterGetCommand_t\t            Cmd;\n    _WlanRxFilterGetCommandReponse_t        Rsp;\n}_SlRxFilterGetMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_WlanRxFilterAdd)\n\nconst _SlCmdCtrl_t _SlRxFilterAddtCmdCtrl =\n{\n    SL_OPCODE_WLAN_WLANRXFILTERADDCOMMAND,\n    sizeof(_WlanRxFilterAddCommand_t),\n    sizeof(_WlanRxFilterAddCommandReponse_t)\n};\n\n\n \nSlrxFilterID_t sl_WlanRxFilterAdd(\tSlrxFilterRuleType_t \t\t\t\tRuleType,\n    SlrxFilterFlags_t \t\t\t\t\tFilterFlags,\n    const SlrxFilterRule_t* const \t\tRule,\n    const SlrxFilterTrigger_t* const \tTrigger,\n    const SlrxFilterAction_t* const \tAction,\n    SlrxFilterID_t*                     pFilterId)\n{\n\n\n    _SlrxFilterAddMsg_u Msg;\n    Msg.Cmd.RuleType = RuleType;\n     \n    Msg.Cmd.FilterId = 0;\n    Msg.Cmd.FilterFlags = FilterFlags;\n    sl_Memcpy( &(Msg.Cmd.Rule), Rule, sizeof(SlrxFilterRule_t) );\n    sl_Memcpy( &(Msg.Cmd.Trigger), Trigger, sizeof(SlrxFilterTrigger_t) );\n    sl_Memcpy( &(Msg.Cmd.Action), Action, sizeof(SlrxFilterAction_t) );\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlRxFilterAddtCmdCtrl, &Msg, NULL) );\n    *pFilterId = Msg.Rsp.FilterId;\n    return (_i16)Msg.Rsp.Status;\n\n}\n#endif\n\n\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_WlanRxFilterSet)\n\nconst _SlCmdCtrl_t _SlRxFilterSetCmdCtrl =\n{\n    SL_OPCODE_WLAN_WLANRXFILTERSETCOMMAND,\n    sizeof(_WlanRxFilterSetCommand_t),\n    sizeof(_WlanRxFilterSetCommandReponse_t)\n};\n\n_i16 sl_WlanRxFilterSet(const SLrxFilterOperation_t RxFilterOperation,\n    const _u8*  const pInputBuffer,\n    _u16 InputbufferLength)\n{\n    _SlRxFilterSetMsg_u   Msg;\n    _SlCmdExt_t           CmdExt;\n\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = InputbufferLength;\n    CmdExt.pTxPayload   = (_u8 *)pInputBuffer;\n\n    Msg.Cmd.RxFilterOperation = RxFilterOperation;\n    Msg.Cmd.InputBufferLength = InputbufferLength;\n\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlRxFilterSetCmdCtrl, &Msg, &CmdExt) );\n\n\n    return (_i16)Msg.Rsp.Status;\n}\n#endif\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_WlanRxFilterGet)\n\nconst _SlCmdCtrl_t _SlRxFilterGetCmdCtrl =\n{\n    SL_OPCODE_WLAN_WLANRXFILTERGETCOMMAND,\n    sizeof(_WlanRxFilterGetCommand_t),\n    sizeof(_WlanRxFilterGetCommandReponse_t)\n};\n\n\n_i16 sl_WlanRxFilterGet(const SLrxFilterOperation_t RxFilterOperation,\n    _u8*  pOutputBuffer,\n    _u16 OutputbufferLength)\n{\n    _SlRxFilterGetMsg_u   Msg;\n    _SlCmdExt_t           CmdExt;\n\n    if (OutputbufferLength == 0)\n    {\n        return SL_EZEROLEN;\n    }\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = OutputbufferLength;\n    CmdExt.pRxPayload   = (_u8 *)pOutputBuffer;\n\n    Msg.Cmd.RxFilterOperation = RxFilterOperation;\n    Msg.Cmd.OutputBufferLength = OutputbufferLength;\n\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlRxFilterGetCmdCtrl, &Msg, &CmdExt) );\n\n    if (CmdExt.RxPayloadLen < CmdExt.ActualRxPayloadLen) \n    {\n        return SL_ESMALLBUF;\n    }\n\n    return (_i16)Msg.Rsp.Status;\n}\n#endif\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_WlanRxStatStart)\n_i16 sl_WlanRxStatStart(void)\n{\n    return _SlDrvBasicCmd(SL_OPCODE_WLAN_STARTRXSTATCOMMAND);\n}\n#endif\n\n#if _SL_INCLUDE_FUNC(sl_WlanRxStatStop)\n_i16 sl_WlanRxStatStop(void)\n{\n    return _SlDrvBasicCmd(SL_OPCODE_WLAN_STOPRXSTATCOMMAND);\n}\n#endif\n\n#if _SL_INCLUDE_FUNC(sl_WlanRxStatGet)\n_i16 sl_WlanRxStatGet(SlGetRxStatResponse_t *pRxStat,const _u32 Flags)\n{\n    _SlCmdCtrl_t            CmdCtrl = {SL_OPCODE_WLAN_GETRXSTATCOMMAND, 0, sizeof(SlGetRxStatResponse_t)};\n    \n    _SlDrvMemZero(pRxStat, sizeof(SlGetRxStatResponse_t));\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&CmdCtrl, pRxStat, NULL)); \n\n    return 0;\n}\n#endif\n\n\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_WlanSmartConfigStop)\n_i16 sl_WlanSmartConfigStop(void)\n{\n    return _SlDrvBasicCmd(SL_OPCODE_WLAN_SMART_CONFIG_STOP_COMMAND);\n}\n#endif\n\n\n \n \n \n\n\ntypedef struct\n{\n    _WlanSmartConfigStartCommand_t\tArgs;\n    _i8                            Strings[3 * MAX_SMART_CONFIG_KEY];  \n}_SlSmartConfigStart_t;\n\ntypedef union\n{\n    _SlSmartConfigStart_t\t    Cmd;\n    _BasicResponse_t\t        Rsp;\n}_SlSmartConfigStartMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_WlanSmartConfigStart)\n\nconst _SlCmdCtrl_t _SlSmartConfigStartCmdCtrl =\n{\n    SL_OPCODE_WLAN_SMART_CONFIG_START_COMMAND,\n    sizeof(_SlSmartConfigStart_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i16 sl_WlanSmartConfigStart( const _u32    groupIdBitmask,\n    const _u8    cipher,\n    const _u8    publicKeyLen,\n    const _u8    group1KeyLen,\n    const _u8    group2KeyLen,\n    const _u8*    pPublicKey,\n    const _u8*    pGroup1Key,\n    const _u8*    pGroup2Key)\n{\n    _SlSmartConfigStartMsg_u      Msg;\n\n    Msg.Cmd.Args.groupIdBitmask = (_u8)groupIdBitmask;\n    Msg.Cmd.Args.cipher         = (_u8)cipher;\n    Msg.Cmd.Args.publicKeyLen   = (_u8)publicKeyLen;\n    Msg.Cmd.Args.group1KeyLen   = (_u8)group1KeyLen;\n    Msg.Cmd.Args.group2KeyLen   = (_u8)group2KeyLen;\n\n     \n    sl_Memcpy(SMART_CONFIG_START_PUBLIC_KEY_STRING(&Msg), pPublicKey, publicKeyLen);\n    sl_Memcpy(SMART_CONFIG_START_GROUP1_KEY_STRING(&Msg), pGroup1Key, group1KeyLen);\n    sl_Memcpy(SMART_CONFIG_START_GROUP2_KEY_STRING(&Msg), pGroup2Key, group2KeyLen);\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlSmartConfigStartCmdCtrl , &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n\n\n}\n#endif\n\n\n \n \n \ntypedef union\n{\n    _WlanSetMode_t\t\t    Cmd;\n    _BasicResponse_t\t    Rsp;\n}_SlwlanSetModeMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_WlanSetMode)\n\nconst _SlCmdCtrl_t _SlWlanSetModeCmdCtrl =\n{\n    SL_OPCODE_WLAN_SET_MODE,\n    sizeof(_WlanSetMode_t),\n    sizeof(_BasicResponse_t)\n};\n\n \n_i16 sl_WlanSetMode(const _u8    mode)\n{\n    _SlwlanSetModeMsg_u      Msg;\n\n    Msg.Cmd.mode  = mode;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlWlanSetModeCmdCtrl , &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n\n\n\n \n \n \ntypedef union\n{\n    _WlanCfgSetGet_t\t    Cmd;\n    _BasicResponse_t\t    Rsp;\n}_SlWlanCfgSetMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_WlanSet)\n\nconst _SlCmdCtrl_t _SlWlanCfgSetCmdCtrl =\n{\n    SL_OPCODE_WLAN_CFG_SET,\n    sizeof(_WlanCfgSetGet_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i16 sl_WlanSet(const _u16 ConfigId ,const _u16 ConfigOpt,const _u16 ConfigLen,const  _u8 *pValues)\n{\n    _SlWlanCfgSetMsg_u         Msg;\n    _SlCmdExt_t                CmdExt;\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = (ConfigLen+3) & (~3);\n    CmdExt.pTxPayload = (_u8 *)pValues;\n\n    Msg.Cmd.ConfigId    = ConfigId;\n    Msg.Cmd.ConfigLen   = ConfigLen;\n    Msg.Cmd.ConfigOpt   = ConfigOpt;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlWlanCfgSetCmdCtrl, &Msg, &CmdExt));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n\n \n \n \ntypedef union\n{\n    _WlanCfgSetGet_t\t    Cmd;\n    _WlanCfgSetGet_t\t    Rsp;\n}_SlWlanCfgMsgGet_u;\n\n#if _SL_INCLUDE_FUNC(sl_WlanGet)\n\nconst _SlCmdCtrl_t _SlWlanCfgGetCmdCtrl =\n{\n    SL_OPCODE_WLAN_CFG_GET,\n    sizeof(_WlanCfgSetGet_t),\n    sizeof(_WlanCfgSetGet_t)\n};\n\n_i16 sl_WlanGet(const _u16 ConfigId, _u16 *pConfigOpt,_u16 *pConfigLen, _u8 *pValues)\n{\n    _SlWlanCfgMsgGet_u        Msg;\n    _SlCmdExt_t               CmdExt;\n\n    if (*pConfigLen == 0)\n    {\n        return SL_EZEROLEN;\n    }\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = *pConfigLen;\n    CmdExt.pRxPayload = (_u8 *)pValues;\n\n    Msg.Cmd.ConfigId    = ConfigId;\n    if( pConfigOpt )\n    {\n        Msg.Cmd.ConfigOpt   = (_u16)*pConfigOpt;\n    }\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlWlanCfgGetCmdCtrl, &Msg, &CmdExt));\n\n    if( pConfigOpt )\n    {\n        *pConfigOpt = (_u8)Msg.Rsp.ConfigOpt;\n    }\n    if (CmdExt.RxPayloadLen < CmdExt.ActualRxPayloadLen) \n    {\n        *pConfigLen = (_u8)CmdExt.RxPayloadLen;\n        return SL_ESMALLBUF;\n    }\n    else\n    {\n        *pConfigLen = (_u8)CmdExt.ActualRxPayloadLen;\n    }\n\n\n    return (_i16)Msg.Rsp.Status;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}