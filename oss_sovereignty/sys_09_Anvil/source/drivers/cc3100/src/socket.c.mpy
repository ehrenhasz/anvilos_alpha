{
  "module_name": "socket.c",
  "hash_id": "5a286d01a8e75cc9537be51e086e0edc8f7280486b5e2fb8f2ae1501150d0844",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/src/socket.c",
  "human_readable_source": " \n    \n\n\n\n \n \n \n#include \"simplelink.h\"\n#include \"protocol.h\"\n#include \"driver.h\"\n\n\nvoid   _sl_BuildAddress(const SlSockAddr_t *addr, _SocketAddrCommand_u    *pCmd);\nvoid   _sl_HandleAsync_Connect(void *pVoidBuf);\n\n#ifndef SL_TINY_EXT\nvoid   _sl_ParseAddress(_SocketAddrResponse_u *pRsp, SlSockAddr_t *addr, SlSocklen_t *addrlen);\nvoid   _sl_HandleAsync_Accept(void *pVoidBuf);\nvoid   _sl_HandleAsync_Select(void *pVoidBuf);\n#endif\n_u16   _sl_TruncatePayloadByProtocol(const _i16 pSd, const _u16 length);  \n\n \n \n \n\n\n     \n     \n     \n#define SL_SOCKET_PAYLOAD_BASE (1350)\n\nconst _u8 _SlPayloadByProtocolLUT[16] = \n{\n    (1472 - SL_SOCKET_PAYLOAD_BASE),  \n    (1460 - SL_SOCKET_PAYLOAD_BASE),  \n    (1452 - SL_SOCKET_PAYLOAD_BASE),  \n    (1440 - SL_SOCKET_PAYLOAD_BASE),  \n    (1386 - SL_SOCKET_PAYLOAD_BASE),  \n    (1386 - SL_SOCKET_PAYLOAD_BASE),  \n    (1396 - SL_SOCKET_PAYLOAD_BASE),  \n    (1396 - SL_SOCKET_PAYLOAD_BASE),  \n    (1476 - SL_SOCKET_PAYLOAD_BASE),  \n    (1514 - SL_SOCKET_PAYLOAD_BASE),  \n    (1480 - SL_SOCKET_PAYLOAD_BASE),  \n    (1480 - SL_SOCKET_PAYLOAD_BASE),  \n    (1440 - SL_SOCKET_PAYLOAD_BASE),  \n    (1440 - SL_SOCKET_PAYLOAD_BASE),  \n    (1440 - SL_SOCKET_PAYLOAD_BASE),  \n    (1440 - SL_SOCKET_PAYLOAD_BASE)   \n};\n\n\n\n \n \n \nvoid _sl_BuildAddress(const SlSockAddr_t *addr, _SocketAddrCommand_u    *pCmd)\n{\n\n     \n    pCmd->IpV4.FamilyAndFlags = (addr->sa_family << 4) & 0xF0;\n    pCmd->IpV4.port = ((SlSockAddrIn_t *)addr)->sin_port;\n\n    if(SL_AF_INET == addr->sa_family)\n    {\n        pCmd->IpV4.address  = ((SlSockAddrIn_t *)addr)->sin_addr.s_addr;\n    }\n    else if (SL_AF_INET6_EUI_48 == addr->sa_family )\n    {\n        sl_Memcpy( pCmd->IpV6EUI48.address,((SlSockAddrIn6_t *)addr)->sin6_addr._S6_un._S6_u8, 6);\n    }\n#ifdef SL_SUPPORT_IPV6\n    else\n    {\n        sl_Memcpy(pCmd->IpV6.address, ((sockaddr_in6 *)addr)->sin6_addr._S6_un._S6_u32, 16 );\n    }\n#endif\n}\n\n\n \n_u16 _sl_TruncatePayloadByProtocol(const _i16 sd, const _u16 length)\n{\n   unsigned int maxLength;\n\n\n   maxLength = SL_SOCKET_PAYLOAD_BASE + _SlPayloadByProtocolLUT[((sd & SL_SOCKET_PAYLOAD_TYPE_MASK) >> 4)];\n\n\n\n   if( length > maxLength )\n   {\n      return maxLength;\n   }\n   else\n   {\n      return length;\n   }\n}\n\n \n \n \n\n#ifndef SL_TINY_EXT\nvoid _sl_ParseAddress(_SocketAddrResponse_u    *pRsp, SlSockAddr_t *addr, SlSocklen_t *addrlen)\n{\n     \n     \n     \n    addr->sa_family                 = pRsp->IpV4.family;\n    ((SlSockAddrIn_t *)addr)->sin_port = pRsp->IpV4.port;\n\n    *addrlen = (SL_AF_INET == addr->sa_family) ? sizeof(SlSockAddrIn_t) : sizeof(SlSockAddrIn6_t);\n\n    if(SL_AF_INET == addr->sa_family)\n    {\n        ((SlSockAddrIn_t *)addr)->sin_addr.s_addr  = pRsp->IpV4.address;\n    }\n    else if (SL_AF_INET6_EUI_48 == addr->sa_family )\n    {\n        sl_Memcpy(((SlSockAddrIn6_t *)addr)->sin6_addr._S6_un._S6_u8, pRsp->IpV6EUI48.address, 6);\n    }\n#ifdef SL_SUPPORT_IPV6\n    else\n    {\n        sl_Memcpy(((sockaddr_in6 *)addr)->sin6_addr._S6_un._S6_u32, pRsp->IpV6.address, 16);\n    }\n#endif\n}\n\n#endif\n\n \n \n \ntypedef union\n{\n    _u32                Dummy;\n\t_SocketCommand_t \tCmd;\n\t_SocketResponse_t\tRsp;\n}_SlSockSocketMsg_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_Socket)\n\nconst _SlCmdCtrl_t _SlSockSocketCmdCtrl =\n{\n    SL_OPCODE_SOCKET_SOCKET,\n    sizeof(_SocketCommand_t),\n    sizeof(_SocketResponse_t)\n};\n\n_i16 sl_Socket(_i16 Domain, _i16 Type, _i16 Protocol)\n{\n    _SlSockSocketMsg_u  Msg;\n\n    Msg.Cmd.Domain\t    = (_u8)Domain;\n    Msg.Cmd.Type     \t= (_u8)Type;\n    Msg.Cmd.Protocol \t= (_u8)Protocol;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlSockSocketCmdCtrl, &Msg, NULL));\n\n    if( Msg.Rsp.statusOrLen < 0 )\n\t{\n\t\treturn( Msg.Rsp.statusOrLen );\n\t}\n\telse\n\t{\n    return (_i16)((_u8)Msg.Rsp.sd);\n}\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_CloseCommand_t\t    Cmd;\n\t_SocketResponse_t\tRsp;\n}_SlSockCloseMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_Close)\n\nconst _SlCmdCtrl_t _SlSockCloseCmdCtrl =\n{\n\tSL_OPCODE_SOCKET_CLOSE,\n    sizeof(_CloseCommand_t),\n    sizeof(_SocketResponse_t)\n};\n\n_i16 sl_Close(_i16 sd)\n{\n\t_SlSockCloseMsg_u   Msg;\n\n    Msg.Cmd.sd = (_u8)sd;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlSockCloseCmdCtrl, &Msg, NULL));\n\n    return Msg.Rsp.statusOrLen;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_SocketAddrCommand_u    Cmd;\n\t_SocketResponse_t\t    Rsp;\n}_SlSockBindMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_Bind)\n_i16 sl_Bind(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen)\n{\n\t_SlSockBindMsg_u    Msg;\n    _SlCmdCtrl_t         CmdCtrl = {0, 0, sizeof(_SocketResponse_t)};\n\n    switch(addr->sa_family)\n    {\n        case SL_AF_INET :\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_BIND;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv4Command_t);\n            break;\n#ifndef SL_TINY_EXT            \n        case SL_AF_INET6_EUI_48:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_BIND_V6;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv6EUI48Command_t);\n        \tbreak;\n\n#ifdef SL_SUPPORT_IPV6\n        case AF_INET6:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_BIND_V6;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv6Command_t);\n            break;\n#endif\n#endif\n\n\n        case SL_AF_RF   :\n        default:\n            return SL_RET_CODE_INVALID_INPUT;\n    }\n\n    Msg.Cmd.IpV4.lenOrPadding = 0;\n    Msg.Cmd.IpV4.sd = (_u8)sd;\n\n    _sl_BuildAddress(addr, &Msg.Cmd);\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&CmdCtrl, &Msg, NULL));\n\n    return Msg.Rsp.statusOrLen;\n}\n#endif\n\n \n \n \ntypedef union\n{\n    _SocketAddrCommand_u    Cmd;\n     \n}_SlSendtoMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_SendTo)\n_i16 sl_SendTo(_i16 sd, const void *pBuf, _i16 Len, _i16 flags, const SlSockAddr_t *to, SlSocklen_t tolen)\n{\n    _SlSendtoMsg_u   Msg;\n    _SlCmdCtrl_t     CmdCtrl = {0, 0, 0};\n    _SlCmdExt_t      CmdExt;\n    _u16           ChunkLen;\n    _i16              RetVal;\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = (_u16)Len;\n    CmdExt.pTxPayload = (_u8 *)pBuf;\n\n    switch(to->sa_family)\n    {\n        case SL_AF_INET:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_SENDTO;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv4Command_t);\n            break;\n#ifndef SL_TINY_EXT            \n        case SL_AF_INET6_EUI_48:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_BIND_V6;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv6EUI48Command_t);\n        \tbreak;        \n#ifdef SL_SUPPORT_IPV6\n        case AF_INET6:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_SENDTO_V6;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv6Command_t);\n            break;\n#endif\n#endif\n        case SL_AF_RF:\n        default:\n            return SL_RET_CODE_INVALID_INPUT;\n    }\n\n    ChunkLen = _sl_TruncatePayloadByProtocol(sd,Len);\n    Msg.Cmd.IpV4.lenOrPadding = ChunkLen;\n    CmdExt.TxPayloadLen = ChunkLen;\n\n    Msg.Cmd.IpV4.sd = (_u8)sd;\n\n    _sl_BuildAddress(to, &Msg.Cmd);\n\n    Msg.Cmd.IpV4.FamilyAndFlags |= flags & 0x0F;\n\n    do\n    {\n        RetVal = _SlDrvDataWriteOp((_SlSd_t)sd, &CmdCtrl, &Msg, &CmdExt);\n\n        if(SL_OS_RET_CODE_OK == RetVal)\n        {\n            CmdExt.pTxPayload += ChunkLen;\n            ChunkLen = (_u16)((_u8 *)pBuf + Len - CmdExt.pTxPayload);\n            ChunkLen = _sl_TruncatePayloadByProtocol(sd,ChunkLen);\n            CmdExt.TxPayloadLen = ChunkLen;\n            Msg.Cmd.IpV4.lenOrPadding = ChunkLen;\n        }\n        else\n        {\n            return RetVal;\n        }\n    }while(ChunkLen > 0);\n\n    return (_i16)Len;\n}\n#endif\n\n \n \n \ntypedef union\n{\n    _sendRecvCommand_t\t    Cmd;\n    _SocketAddrResponse_u\tRsp;\n}_SlRecvfromMsg_u;\n\nconst _SlCmdCtrl_t _SlRecvfomCmdCtrl =\n{\n\tSL_OPCODE_SOCKET_RECVFROM,\n    sizeof(_sendRecvCommand_t),\n    sizeof(_SocketAddrResponse_u)\n};\n\n\n\n#if _SL_INCLUDE_FUNC(sl_RecvFrom)\n_i16 sl_RecvFrom(_i16 sd, void *buf, _i16 Len, _i16 flags, SlSockAddr_t *from, SlSocklen_t *fromlen)\n{\n    _SlRecvfromMsg_u    Msg;\n    _SlCmdExt_t         CmdExt;\n    _i16                 RetVal;\n\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = Len;\n    CmdExt.pRxPayload = (_u8 *)buf;\n\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.StatusOrLen = Len;\n     \n    CmdExt.RxPayloadLen = Msg.Cmd.StatusOrLen;\n\n\n    Msg.Cmd.FamilyAndFlags = flags & 0x0F;\n\n\n    if(sizeof(SlSockAddrIn_t) == *fromlen)\n    {\n        Msg.Cmd.FamilyAndFlags |= (SL_AF_INET << 4);\n    }\n    else if (sizeof(SlSockAddrIn6_t) == *fromlen)\n    {\n        Msg.Cmd.FamilyAndFlags |= (SL_AF_INET6 << 4);\n    }\n    else\n    {\n        return SL_RET_CODE_INVALID_INPUT;\n    }\n\n    RetVal = _SlDrvDataReadOp((_SlSd_t)sd, (_SlCmdCtrl_t *)&_SlRecvfomCmdCtrl, &Msg, &CmdExt);\n    if( RetVal != SL_OS_RET_CODE_OK )\n    {\n\treturn RetVal;\n    }\n\n    RetVal = Msg.Rsp.IpV4.statusOrLen;\n\n    if(RetVal >= 0)\n    {\n        VERIFY_PROTOCOL(sd == Msg.Rsp.IpV4.sd);\n#if 0\n        _sl_ParseAddress(&Msg.Rsp, from, fromlen);\n#else\n        from->sa_family = Msg.Rsp.IpV4.family;\n        if(SL_AF_INET == from->sa_family)\n        {\n            ((SlSockAddrIn_t *)from)->sin_port = Msg.Rsp.IpV4.port;\n            ((SlSockAddrIn_t *)from)->sin_addr.s_addr = Msg.Rsp.IpV4.address;\n            *fromlen = sizeof(SlSockAddrIn_t);\n        }\n        else if (SL_AF_INET6_EUI_48 == from->sa_family )\n         {\n            ((SlSockAddrIn6_t *)from)->sin6_port  = Msg.Rsp.IpV6EUI48.port;\n            sl_Memcpy(((SlSockAddrIn6_t *)from)->sin6_addr._S6_un._S6_u8, Msg.Rsp.IpV6EUI48.address, 6);\n         }\n#ifdef SL_SUPPORT_IPV6\n        else if(AF_INET6 == from->sa_family)\n        {\n            VERIFY_PROTOCOL(*fromlen >= sizeof(sockaddr_in6));\n\n            ((sockaddr_in6 *)from)->sin6_port = Msg.Rsp.IpV6.port;\n            sl_Memcpy(((sockaddr_in6 *)from)->sin6_addr._S6_un._S6_u32, Msg.Rsp.IpV6.address, 16);\n            *fromlen = sizeof(sockaddr_in6);\n        }\n#endif\n#endif\n    }\n\n    return (_i16)RetVal;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_SocketAddrCommand_u    Cmd;\n\t_SocketResponse_t\t    Rsp;\n}_SlSockConnectMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_Connect)\n_i16 sl_Connect(_i16 sd, const SlSockAddr_t *addr, _i16 addrlen)\n{\n      _SlSockConnectMsg_u  Msg;\n      _SlReturnVal_t       RetVal;\n      _SlCmdCtrl_t         CmdCtrl = {0, 0, sizeof(_SocketResponse_t)};\n      _SocketResponse_t    AsyncRsp;\n      _u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n\n\n    switch(addr->sa_family)\n    {\n        case SL_AF_INET :\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_CONNECT;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv4Command_t);\n             \n            break;\n        case  SL_AF_INET6_EUI_48:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_CONNECT_V6;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv6EUI48Command_t);\n        \tbreak;\n#ifdef SL_SUPPORT_IPV6\n        case AF_INET6:\n            CmdCtrl.Opcode = SL_OPCODE_SOCKET_CONNECT_V6;\n            CmdCtrl.TxDescLen = sizeof(_SocketAddrIPv6Command_t);\n            break;\n#endif\n        case SL_AF_RF:\n        default:\n            return SL_RET_CODE_INVALID_INPUT;\n    }\n\n    Msg.Cmd.IpV4.lenOrPadding = 0;\n    Msg.Cmd.IpV4.sd = (_u8)sd;\n\n    _sl_BuildAddress(addr, &Msg.Cmd);\n\n\n    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&AsyncRsp, CONNECT_ID, sd  & BSD_SOCKET_ID_MASK);\n\n    if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n    {\n        return SL_POOL_IS_EMPTY;\n    }\n\n     \n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&CmdCtrl, &Msg, NULL));\n    VERIFY_PROTOCOL(Msg.Rsp.sd == sd)\n\n\tRetVal = Msg.Rsp.statusOrLen;\n\n    if(SL_RET_CODE_OK == RetVal)\n    {\n\t\t \n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n        \n        VERIFY_PROTOCOL(AsyncRsp.sd == sd);\n\n        RetVal = AsyncRsp.statusOrLen;\n    }\n\n\n\n    _SlDrvReleasePoolObj(ObjIdx);\n    return RetVal;\n}\n\n#endif\n\n\n \n \n \nvoid _sl_HandleAsync_Connect(void *pVoidBuf)\n{\n    _SocketResponse_t          *pMsgArgs   = (_SocketResponse_t *)_SL_RESP_ARGS_START(pVoidBuf);\n\n    _SlDrvProtectionObjLockWaitForever();\n\n    VERIFY_PROTOCOL((pMsgArgs->sd & BSD_SOCKET_ID_MASK) <= SL_MAX_SOCKETS);\n    VERIFY_SOCKET_CB(NULL != g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs);\n    \n\n    ((_SocketResponse_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->sd = pMsgArgs->sd;\n    ((_SocketResponse_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->statusOrLen = pMsgArgs->statusOrLen;\n\n\n    _SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n    _SlDrvProtectionObjUnLock();\n    return;\n}\n\n \n \n \ntypedef union\n{\n\t_sendRecvCommand_t    Cmd;\n     \n}_SlSendMsg_u;\n\nconst _SlCmdCtrl_t _SlSendCmdCtrl =\n{\n    SL_OPCODE_SOCKET_SEND,\n    sizeof(_sendRecvCommand_t),\n    0\n};\n\n#if _SL_INCLUDE_FUNC(sl_Send)\n_i16 sl_Send(_i16 sd, const void *pBuf, _i16 Len, _i16 flags)\n{\n    _SlSendMsg_u   Msg;\n    _SlCmdExt_t    CmdExt;\n    _u16         ChunkLen;\n    _i16            RetVal;\n\t_u32         tempVal;\n\t_u8  runSingleChunk = FALSE; \n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = Len;\n    CmdExt.pTxPayload = (_u8 *)pBuf;\n    \n     \n    if ((sd & SL_SOCKET_PAYLOAD_TYPE_MASK) == SL_SOCKET_PAYLOAD_TYPE_RAW_TRANCEIVER)\n    {\n\t\ttempVal = flags;\n        CmdExt.pRxPayload = (_u8 *)&tempVal;\n\t\tCmdExt.RxPayloadLen = -4;  \n\t\trunSingleChunk = TRUE;\n    }\n    else\n    {\n        CmdExt.pRxPayload = NULL;\n    }\n\n    ChunkLen = _sl_TruncatePayloadByProtocol(sd,Len);\n    CmdExt.TxPayloadLen = ChunkLen;\n    Msg.Cmd.StatusOrLen = ChunkLen;\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.FamilyAndFlags |= flags & 0x0F;\n\n    do\n    {\n        RetVal = _SlDrvDataWriteOp((_u8)sd, (_SlCmdCtrl_t *)&_SlSendCmdCtrl, &Msg, &CmdExt);\n        if(SL_OS_RET_CODE_OK == RetVal)\n        {\n            CmdExt.pTxPayload += ChunkLen;\n            ChunkLen = (_u8 *)pBuf + Len - CmdExt.pTxPayload;\n            ChunkLen = _sl_TruncatePayloadByProtocol(sd,ChunkLen);\n            CmdExt.TxPayloadLen = ChunkLen;\n            Msg.Cmd.StatusOrLen = ChunkLen;\n        }\n        else\n        {\n            return RetVal;\n        }\n    }while((ChunkLen > 0) && (runSingleChunk==FALSE));\n    \n    return (_i16)Len;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_ListenCommand_t    Cmd;\n    _BasicResponse_t    Rsp;\n}_SlListenMsg_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_Listen)\n\nconst _SlCmdCtrl_t _SlListenCmdCtrl =\n{\n    SL_OPCODE_SOCKET_LISTEN,\n    sizeof(_ListenCommand_t),\n    sizeof(_BasicResponse_t),\n};\n\n_i16 sl_Listen(_i16 sd, _i16 backlog)\n{\n    _SlListenMsg_u  Msg;\n\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.backlog = (_u8)backlog;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlListenCmdCtrl, &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_AcceptCommand_t    Cmd;\n\t_SocketResponse_t   Rsp;\n}_SlSockAcceptMsg_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_Accept)\n\nconst _SlCmdCtrl_t _SlAcceptCmdCtrl =\n{\n    SL_OPCODE_SOCKET_ACCEPT,\n    sizeof(_AcceptCommand_t),\n    sizeof(_BasicResponse_t),\n};\n\n_i16 sl_Accept(_i16 sd, SlSockAddr_t *addr, SlSocklen_t *addrlen)\n{\n\t_SlSockAcceptMsg_u      Msg;\n    _SlReturnVal_t          RetVal;\n    _SocketAddrResponse_u   AsyncRsp;\n\n\t_u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n\n\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.family = (sizeof(SlSockAddrIn_t) == *addrlen) ? SL_AF_INET : SL_AF_INET6;\n\n\n    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&AsyncRsp, ACCEPT_ID, sd  & BSD_SOCKET_ID_MASK );\n\n    if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n    {\n        return SL_POOL_IS_EMPTY;\n    }\n    \n\t \n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlAcceptCmdCtrl, &Msg, NULL));\n    VERIFY_PROTOCOL(Msg.Rsp.sd == sd);\n\n    RetVal = Msg.Rsp.statusOrLen;\n\n    if(SL_OS_RET_CODE_OK == RetVal)\n    {\n         \n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n        \n        VERIFY_PROTOCOL(AsyncRsp.IpV4.sd == sd);\n\n        RetVal = AsyncRsp.IpV4.statusOrLen;\n        if( (NULL != addr) && (NULL != addrlen) )  \n        {\n#if 0  \n            _sl_ParseAddress(&AsyncRsp, addr, addrlen);\n#else\n    \t   addr->sa_family = AsyncRsp.IpV4.family;\n\n    \t    if(SL_AF_INET == addr->sa_family)\n    \t    {\n              if( *addrlen == sizeof( SlSockAddrIn_t ) )\n              {\n                ((SlSockAddrIn_t *)addr)->sin_port         = AsyncRsp.IpV4.port;\n                ((SlSockAddrIn_t *)addr)->sin_addr.s_addr  = AsyncRsp.IpV4.address;\n              }\n              else\n              {\n                *addrlen = 0;\n              }\n    \t    }\n    \t    else if (SL_AF_INET6_EUI_48 == addr->sa_family )\n    \t    {\n                if( *addrlen == sizeof( SlSockAddrIn6_t ) )\n              {\n                ((SlSockAddrIn6_t *)addr)->sin6_port                   = AsyncRsp.IpV6EUI48.port    ;\n                 \n                sl_Memcpy(((SlSockAddrIn6_t *)addr)->sin6_addr._S6_un._S6_u8, AsyncRsp.IpV6EUI48.address, 6);\n              }\n              else\n              {\n                *addrlen = 0;\n              }\n    \t    }\n#ifdef SL_SUPPORT_IPV6\n    \t    else\n    \t    {\n              if( *addrlen == sizeof( sockaddr_in6 ) )\n              {\n    \t        ((sockaddr_in6 *)addr)->sin6_port                   = AsyncRsp.IpV6.port    ;\n    \t        sl_Memcpy(((sockaddr_in6 *)addr)->sin6_addr._S6_un._S6_u32, AsyncRsp.IpV6.address, 16);\n              }\n              else\n              {\n                *addrlen = 0;\n              }\n    \t    }\n#endif\n#endif\t\t\t\n        }\n    }\n\n    _SlDrvReleasePoolObj(ObjIdx);\n    return (_i16)RetVal;\n}\n#endif\n\n\n \n \n \n_u32 sl_Htonl( _u32 val )\n{\n  _u32 i = 1; \n  _i8 *p = (_i8 *)&i;  \n  if (p[0] == 1)  \n  {\n    p[0] = ((_i8* )&val)[3];\n    p[1] = ((_i8* )&val)[2];\n    p[2] = ((_i8* )&val)[1];\n    p[3] = ((_i8* )&val)[0];\n    return i;\n  }\n  else  \n  {\n    return val; \n  }\n}\n\n \n \n \n_u16 sl_Htons( _u16 val )\n{\n  _i16 i = 1; \n  _i8 *p = (_i8 *)&i;  \n  if (p[0] == 1)  \n  {\n    p[0] = ((_i8* )&val)[1];\n    p[1] = ((_i8* )&val)[0];\n    return i;\n  }\n  else  \n  {\n    return val; \n  }\n}\n\n \n \n \n#ifndef SL_TINY_EXT\nvoid _sl_HandleAsync_Accept(void *pVoidBuf)\n{\n    _SocketAddrResponse_u      *pMsgArgs   = (_SocketAddrResponse_u *)_SL_RESP_ARGS_START(pVoidBuf);\n\n    _SlDrvProtectionObjLockWaitForever();\n\n    VERIFY_PROTOCOL(( pMsgArgs->IpV4.sd & BSD_SOCKET_ID_MASK) <= SL_MAX_SOCKETS);\n    VERIFY_SOCKET_CB(NULL != g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs);\n\n\tsl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs,sizeof(_SocketAddrResponse_u));\n\t_SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n\n    _SlDrvProtectionObjUnLock();\n    return;\n}\n\n \n \n \nvoid _sl_HandleAsync_Select(void *pVoidBuf)\n{\n    _SelectAsyncResponse_t     *pMsgArgs   = (_SelectAsyncResponse_t *)_SL_RESP_ARGS_START(pVoidBuf);\n\n    _SlDrvProtectionObjLockWaitForever();    \n\n    VERIFY_SOCKET_CB(NULL != g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs);\n\n    sl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs, sizeof(_SelectAsyncResponse_t));\n\n    _SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n    _SlDrvProtectionObjUnLock();\n\n    return;\n}\n\n#endif\n\n \n \n \ntypedef union\n{\n\t_sendRecvCommand_t  Cmd;\n\t_SocketResponse_t   Rsp;    \n}_SlRecvMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_Recv)\n\nconst _SlCmdCtrl_t _SlRecvCmdCtrl =\n{\n    SL_OPCODE_SOCKET_RECV,\n    sizeof(_sendRecvCommand_t),\n    sizeof(_SocketResponse_t)\n};\n\n\n_i16 sl_Recv(_i16 sd, void *pBuf, _i16 Len, _i16 flags)\n{\n    _SlRecvMsg_u    Msg;\n    _SlCmdExt_t     CmdExt;\n    _SlReturnVal_t status;\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = Len;\n    CmdExt.pRxPayload = (_u8 *)pBuf;\n\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.StatusOrLen = Len;\n\n     \n    CmdExt.RxPayloadLen = Msg.Cmd.StatusOrLen;\n\n    Msg.Cmd.FamilyAndFlags = flags & 0x0F;\n\n    status = _SlDrvDataReadOp((_SlSd_t)sd, (_SlCmdCtrl_t *)&_SlRecvCmdCtrl, &Msg, &CmdExt);\n    if( status != SL_OS_RET_CODE_OK )\n    {\n\treturn status;\n    }\n     \n     \n     \n    return (_i16)Msg.Rsp.statusOrLen;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_setSockOptCommand_t    Cmd;\n\t_SocketResponse_t       Rsp;    \n}_SlSetSockOptMsg_u;\n\nconst _SlCmdCtrl_t _SlSetSockOptCmdCtrl =\n{\n    SL_OPCODE_SOCKET_SETSOCKOPT,\n    sizeof(_setSockOptCommand_t),\n    sizeof(_SocketResponse_t)\n};\n\n#if _SL_INCLUDE_FUNC(sl_SetSockOpt)\n_i16 sl_SetSockOpt(_i16 sd, _i16 level, _i16 optname, const void *optval, SlSocklen_t optlen)\n{\n    _SlSetSockOptMsg_u    Msg;\n    _SlCmdExt_t           CmdExt;\n\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = optlen;\n    CmdExt.pTxPayload = (_u8 *)optval;\n\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.level = (_u8)level;\n    Msg.Cmd.optionLen = (_u8)optlen;\n    Msg.Cmd.optionName = (_u8)optname;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlSetSockOptCmdCtrl, &Msg, &CmdExt));\n\n    return (_i16)Msg.Rsp.statusOrLen;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_getSockOptCommand_t    Cmd;\n\t_getSockOptResponse_t   Rsp;    \n}_SlGetSockOptMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_GetSockOpt)\n\nconst _SlCmdCtrl_t _SlGetSockOptCmdCtrl =\n{\n    SL_OPCODE_SOCKET_GETSOCKOPT,\n    sizeof(_getSockOptCommand_t),\n    sizeof(_getSockOptResponse_t)\n};\n\n_i16 sl_GetSockOpt(_i16 sd, _i16 level, _i16 optname, void *optval, SlSocklen_t *optlen)\n{\n    _SlGetSockOptMsg_u    Msg;\n    _SlCmdExt_t           CmdExt;\n\n\tif (*optlen == 0)\n\t{\n\t\treturn SL_EZEROLEN;\n\t}\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = *optlen;\n    CmdExt.pRxPayload = optval;\n\n    Msg.Cmd.sd = (_u8)sd;\n    Msg.Cmd.level = (_u8)level;\n    Msg.Cmd.optionLen = (_u8)(*optlen);\n    Msg.Cmd.optionName = (_u8)optname;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlGetSockOptCmdCtrl, &Msg, &CmdExt));\n\n\tif (CmdExt.RxPayloadLen < CmdExt.ActualRxPayloadLen) \n\t{\n\t    *optlen = Msg.Rsp.optionLen;\n\t   return SL_ESMALLBUF;\n\t}\n\telse\n\t{\n\t\t*optlen = (_u8)CmdExt.ActualRxPayloadLen;\n\t}\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_SelectCommand_t   Cmd;\n\t_BasicResponse_t   Rsp;    \n}_SlSelectMsg_u;\n\n\n\n#ifndef SL_TINY_EXT\n#if _SL_INCLUDE_FUNC(sl_Select)\n\nconst _SlCmdCtrl_t _SlSelectCmdCtrl =\n{\n    SL_OPCODE_SOCKET_SELECT,\n    sizeof(_SelectCommand_t),\n    sizeof(_BasicResponse_t)\n};\n\n\n_i16 sl_Select(_i16 nfds, SlFdSet_t *readsds, SlFdSet_t *writesds, SlFdSet_t *exceptsds, struct SlTimeval_t *timeout)\n{\n    _SlSelectMsg_u          Msg;\n    _SelectAsyncResponse_t  AsyncRsp;\n\t_u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n\n    Msg.Cmd.nfds          = (_u8)nfds;\n    Msg.Cmd.readFdsCount  = 0;\n    Msg.Cmd.writeFdsCount = 0;\n    \n    Msg.Cmd.readFds = 0;\n    Msg.Cmd.writeFds = 0; \n\n    \n    if( readsds )\n    {\n       Msg.Cmd.readFds       = (_u16)readsds->fd_array[0];  \n    }\n    if( writesds )\n    {\n       Msg.Cmd.writeFds      = (_u16)writesds->fd_array[0]; \n    }\n\tif( NULL == timeout )\n\t{\n\t\tMsg.Cmd.tv_sec = 0xffff;\n\t\tMsg.Cmd.tv_usec = 0xffff;\n\t}\n\telse\n\t{\n\t\tif( 0xffff <= timeout->tv_sec )\t\n\t\t{\n\t\t\tMsg.Cmd.tv_sec = 0xffff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMsg.Cmd.tv_sec = (_u16)timeout->tv_sec;\n\t\t}\n\t\ttimeout->tv_usec = timeout->tv_usec >> 10;   \n\t\tif( 0xffff <= timeout->tv_usec )\t\n\t\t{\n\t\t\tMsg.Cmd.tv_usec = 0xffff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMsg.Cmd.tv_usec = (_u16)timeout->tv_usec;\n\t\t}\n\t}\n\n\t \n    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&AsyncRsp, SELECT_ID, SL_MAX_SOCKETS);\n\n    if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n    {\n        return SL_POOL_IS_EMPTY;\n    }\n\n    \n\t \n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlSelectCmdCtrl, &Msg, NULL));\n\n    if(SL_OS_RET_CODE_OK == (_i16)Msg.Rsp.status)\n    {\n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n        \n        Msg.Rsp.status = AsyncRsp.status;\n\n        if(  ((_i16)Msg.Rsp.status) >= 0 )\n        {\n            if( readsds )\n            {\n               readsds->fd_array[0]  = AsyncRsp.readFds;\n            }\n            if( writesds )\n            {\n               writesds->fd_array[0] = AsyncRsp.writeFds;      \n            }\n        }\n    }\n\n    _SlDrvReleasePoolObj(ObjIdx);\n    return (_i16)Msg.Rsp.status;\n}\n\n \n \n \n \nvoid SL_FD_SET(_i16 fd, SlFdSet_t *fdset)\n{\n   fdset->fd_array[0] |=  (1<< (fd & BSD_SOCKET_ID_MASK));\n}\n \n \n \nvoid SL_FD_CLR(_i16 fd, SlFdSet_t *fdset)\n{\n  fdset->fd_array[0] &=  ~(1<< (fd & BSD_SOCKET_ID_MASK));\n}\n \n \n \n_i16  SL_FD_ISSET(_i16 fd, SlFdSet_t *fdset)\n{\n  if( fdset->fd_array[0] & (1<< (fd & BSD_SOCKET_ID_MASK)) )\n  {\n    return 1;\n  }\n  return 0;\n}\n \n \n   \nvoid SL_FD_ZERO(SlFdSet_t *fdset)\n{\n  fdset->fd_array[0] = 0;\n}\n\n#endif\n#endif\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}