{
  "module_name": "device.c",
  "hash_id": "921f747d23199e7b7689b20108a303e7c313f2c115dad29c77b4be0d160fbece",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/src/device.c",
  "human_readable_source": " \n\n\n\n \n \n \n#include \"simplelink.h\"\n#include \"protocol.h\"\n#include \"flowcont.h\"\n#include \"driver.h\"\n\n\n \n \n \n\nconst _i8 StartResponseLUT[8] = \n{\n    ROLE_UNKNOWN_ERR,\n    ROLE_STA,\n    ROLE_STA_ERR,\n    ROLE_AP,\n    ROLE_AP_ERR,\n    ROLE_P2P,\n    ROLE_P2P_ERR,\n    ROLE_UNKNOWN_ERR    \n};\n\n\n\n_i16 _sl_GetStartResponseConvert(_u32 Status)\n{\n    return (_i16)StartResponseLUT[Status & 0x7];\n}\n\n \n \n \n\n\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_Task)\nvoid sl_Task(void)\n{\n#ifdef _SlTaskEntry\n    _SlTaskEntry();\n#endif\n}\n#endif\n\n \n \n \n#if _SL_INCLUDE_FUNC(sl_Start)\n_i16 sl_Start(const void* pIfHdl, _i8*  pDevName, const P_INIT_CALLBACK pInitCallBack)\n{\n    _i16 ObjIdx = MAX_CONCURRENT_ACTIONS;\n    InitComplete_t  AsyncRsp;\n\n     \n    sl_DeviceEnablePreamble();\n\n     \n    _SlDrvDriverCBInit();\n\n     \n    if (NULL == pIfHdl)\n    {\n        g_pCB->FD = sl_IfOpen((void *)pDevName, 0);\n    }\n    else\n    {\n        g_pCB->FD = (_SlFd_t)pIfHdl;\n    }\n    \n    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8 *)&AsyncRsp, START_STOP_ID, SL_MAX_SOCKETS);\n\n    if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n    {\n        return SL_POOL_IS_EMPTY;\n    }\n\n    if( g_pCB->FD >= (_SlFd_t)0)\n    {\n        sl_DeviceDisable();\n\n        sl_IfRegIntHdlr((SL_P_EVENT_HANDLER)_SlDrvRxIrqHandler, NULL);\n\n        g_pCB->pInitCallback = pInitCallBack;\n        sl_DeviceEnable();\n        \n        if (NULL == pInitCallBack)\n        {\n            _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n\n             \n            _SlDrvReleasePoolObj(g_pCB->FunctionParams.AsyncExt.ActionIndex);\n\t         return _sl_GetStartResponseConvert(AsyncRsp.Status);\n        }\n        else\n        {\n            return SL_RET_CODE_OK;\n        }\n    }\n    return SL_BAD_INTERFACE;\n}\n#endif\n\n \nvoid _sl_HandleAsync_InitComplete(void *pVoidBuf)\n{\n    InitComplete_t     *pMsgArgs   = (InitComplete_t *)_SL_RESP_ARGS_START(pVoidBuf);\n\n    _SlDrvProtectionObjLockWaitForever();\n\n    if(g_pCB->pInitCallback)\n    {\n        g_pCB->pInitCallback(_sl_GetStartResponseConvert(pMsgArgs->Status));\n    }\n    else\n    {\n        sl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs, sizeof(InitComplete_t));\n        _SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n    }\n    \n   _SlDrvProtectionObjUnLock();\n   \n    if(g_pCB->pInitCallback)\n    {\n        _SlDrvReleasePoolObj(g_pCB->FunctionParams.AsyncExt.ActionIndex);\n    }\n\n}\n\n \nvoid _sl_HandleAsync_Stop(void *pVoidBuf)\n{\n    _BasicResponse_t     *pMsgArgs   = (_BasicResponse_t *)_SL_RESP_ARGS_START(pVoidBuf);\n\n    VERIFY_SOCKET_CB(NULL != g_pCB->StopCB.pAsyncRsp);\n\n    _SlDrvProtectionObjLockWaitForever();\n\n    sl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs, sizeof(_BasicResponse_t));\n\n    _SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n    _SlDrvProtectionObjUnLock();\n    \n    return;\n}\n\n\n \ntypedef union\n{\n    _DevStopCommand_t  Cmd;\n    _BasicResponse_t   Rsp;    \n}_SlStopMsg_u;\n\nconst _SlCmdCtrl_t _SlStopCmdCtrl =\n{\n    SL_OPCODE_DEVICE_STOP_COMMAND,\n    sizeof(_DevStopCommand_t),\n    sizeof(_BasicResponse_t)\n};\n\n#if _SL_INCLUDE_FUNC(sl_Stop)\n_i16 sl_Stop(const _u16 timeout)\n{\n    _i16 RetVal=0;\n    _SlStopMsg_u      Msg;\n    _BasicResponse_t  AsyncRsp;\n    _i8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n     \n    if( 0 == timeout ) \n    {\n        sl_IfRegIntHdlr(NULL, NULL);\n        sl_DeviceDisable();\n        RetVal = sl_IfClose(g_pCB->FD);\n\n    }\n    else\n    {\n         \n        Msg.Cmd.Timeout = timeout;\n\n      ObjIdx = _SlDrvProtectAsyncRespSetting((_u8 *)&AsyncRsp, START_STOP_ID, SL_MAX_SOCKETS);\n      if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n      {\n          return SL_POOL_IS_EMPTY;\n      }\n\n      VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlStopCmdCtrl, &Msg, NULL));\n\n      if(SL_OS_RET_CODE_OK == (_i16)Msg.Rsp.status)\n      {\n         _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n         Msg.Rsp.status = AsyncRsp.status;\n         RetVal = Msg.Rsp.status;\n      }\n\n      _SlDrvReleasePoolObj(ObjIdx);\n      sl_IfRegIntHdlr(NULL, NULL);\n      sl_DeviceDisable();\n      sl_IfClose(g_pCB->FD);\n    }\n    _SlDrvDriverCBDeinit();\n\n    return RetVal;\n}\n#endif\n\n\n \ntypedef union\n{\n    _DevMaskEventSetCommand_t\t    Cmd;\n    _BasicResponse_t\t            Rsp;\n}_SlEventMaskSetMsg_u;\n\n\n\n\n#if _SL_INCLUDE_FUNC(sl_EventMaskSet)\n\nconst _SlCmdCtrl_t _SlEventMaskSetCmdCtrl =\n{\n    SL_OPCODE_DEVICE_EVENTMASKSET,\n    sizeof(_DevMaskEventSetCommand_t),\n    sizeof(_BasicResponse_t)\n};\n\n\n_i16 sl_EventMaskSet(const _u8 EventClass ,const _u32 Mask)\n{\n    _SlEventMaskSetMsg_u Msg;\n\n    Msg.Cmd.group = EventClass;\n    Msg.Cmd.mask = Mask;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlEventMaskSetCmdCtrl, &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n \ntypedef union\n{\n    _DevMaskEventGetCommand_t\t    Cmd;\n    _DevMaskEventGetResponse_t      Rsp;\n}_SlEventMaskGetMsg_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_EventMaskGet)\n\nconst _SlCmdCtrl_t _SlEventMaskGetCmdCtrl =\n{\n    SL_OPCODE_DEVICE_EVENTMASKGET,\n    sizeof(_DevMaskEventGetCommand_t),\n    sizeof(_DevMaskEventGetResponse_t)\n};\n\n\n_i16 sl_EventMaskGet(const _u8 EventClass,_u32 *pMask)\n{\n    _SlEventMaskGetMsg_u Msg;\n\n    Msg.Cmd.group = EventClass;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlEventMaskGetCmdCtrl, &Msg, NULL));\n\n    *pMask = Msg.Rsp.mask;\n    return SL_RET_CODE_OK;\n}\n#endif\n\n\n\n \n\ntypedef union\n{\n    _DeviceSetGet_t\t    Cmd;\n    _DeviceSetGet_t\t    Rsp;\n}_SlDeviceMsgGet_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_DevGet)\n\nconst _SlCmdCtrl_t _SlDeviceGetCmdCtrl =\n{\n    SL_OPCODE_DEVICE_DEVICEGET,\n    sizeof(_DeviceSetGet_t),\n    sizeof(_DeviceSetGet_t)\n};\n\n_i32 sl_DevGet(const _u8 DeviceGetId,_u8 *pOption,_u8 *pConfigLen, _u8 *pValues)\n{\n    _SlDeviceMsgGet_u         Msg;\n    _SlCmdExt_t               CmdExt;\n\n    if (*pConfigLen == 0)\n    {\n        return SL_EZEROLEN;\n    }\n\n    if( pOption )\n    {\n\n      _SlDrvResetCmdExt(&CmdExt);\n        CmdExt.RxPayloadLen = *pConfigLen;\n        CmdExt.pRxPayload = (_u8 *)pValues;\n\n        Msg.Cmd.DeviceSetId = DeviceGetId;\n\n        Msg.Cmd.Option   = (_u16)*pOption;\n\n        VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlDeviceGetCmdCtrl, &Msg, &CmdExt));\n\n        if( pOption )\n        {\n            *pOption = (_u8)Msg.Rsp.Option;\n        }\n\n        if (CmdExt.RxPayloadLen < CmdExt.ActualRxPayloadLen) \n        {\n            *pConfigLen = (_u8)CmdExt.RxPayloadLen;\n            return SL_ESMALLBUF;\n        }\n        else\n        {\n            *pConfigLen = (_u8)CmdExt.ActualRxPayloadLen;\n        }\n\n        return (_i16)Msg.Rsp.Status;\n    }\n    else\n    {\n        return -1;\n    }\n}\n#endif\n\n \ntypedef union\n{\n    _DeviceSetGet_t    Cmd;\n    _BasicResponse_t   Rsp;\n}_SlDeviceMsgSet_u;\n\n\n\n#if _SL_INCLUDE_FUNC(sl_DevSet)\n\nconst _SlCmdCtrl_t _SlDeviceSetCmdCtrl =\n{\n    SL_OPCODE_DEVICE_DEVICESET,\n    sizeof(_DeviceSetGet_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i32 sl_DevSet(const _u8 DeviceSetId ,const _u8 Option,const _u8 ConfigLen,const _u8 *pValues)\n{\n    _SlDeviceMsgSet_u         Msg;\n    _SlCmdExt_t               CmdExt;\n\n\n    _SlDrvResetCmdExt(&CmdExt);\n\n    CmdExt.TxPayloadLen = (ConfigLen+3) & (~3);\n    CmdExt.pTxPayload = (_u8 *)pValues;\n\n    Msg.Cmd.DeviceSetId    = DeviceSetId;\n    Msg.Cmd.ConfigLen   = ConfigLen;\n    Msg.Cmd.Option   = Option;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlDeviceSetCmdCtrl, &Msg, &CmdExt));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n\n \nvoid _SlDrvDeviceEventHandler(void* pArgs)\n{\n    _SlResponseHeader_t      *pHdr       = (_SlResponseHeader_t *)pArgs;\n\n    switch(pHdr->GenHeader.Opcode)\n    {\n    case SL_OPCODE_DEVICE_INITCOMPLETE:\n        _sl_HandleAsync_InitComplete(pHdr);\n        break;\n    case SL_OPCODE_DEVICE_STOP_ASYNC_RESPONSE:\n        _sl_HandleAsync_Stop(pHdr);\n        break;\n\n\n\t\tcase SL_OPCODE_DEVICE_ABORT:\n\t\t\t{\n#if defined (sl_GeneralEvtHdlr) || defined(EXT_LIB_REGISTERED_GENERAL_EVENTS)\n\t\t\t\tSlDeviceEvent_t      devHandler;\n\t\t\t\tdevHandler.Event = SL_DEVICE_ABORT_ERROR_EVENT;\t\n\t\t\t\tdevHandler.EventData.deviceReport.AbortType = *((_u32*)pArgs + 2);\n\t\t\t\tdevHandler.EventData.deviceReport.AbortData = *((_u32*)pArgs + 3);\n\t\t\t\t_SlDrvHandleGeneralEvents(&devHandler);\n#endif\t\t\n\t\t\t}\n        break;\n\n    case  SL_OPCODE_DEVICE_DEVICEASYNCFATALERROR:\n#if defined (sl_GeneralEvtHdlr) || defined(EXT_LIB_REGISTERED_GENERAL_EVENTS)\n        {\n            _BasicResponse_t     *pMsgArgs   = (_BasicResponse_t *)_SL_RESP_ARGS_START(pHdr);\n            SlDeviceEvent_t      devHandler;\n            devHandler.Event = SL_DEVICE_FATAL_ERROR_EVENT;\n            devHandler.EventData.deviceEvent.status = pMsgArgs->status & 0xFF;\n            devHandler.EventData.deviceEvent.sender = (SlErrorSender_e)((pMsgArgs->status >> 8) & 0xFF);\n            _SlDrvHandleGeneralEvents(&devHandler);\n        }\n#endif\n        break;\n    default:\n        SL_ERROR_TRACE2(MSG_306, \"ASSERT: _SlDrvDeviceEventHandler : invalid opcode = 0x%x = %1\", pHdr->GenHeader.Opcode, pHdr->GenHeader.Opcode);\n    }\n}\n\n\n \n#ifdef SL_IF_TYPE_UART\ntypedef union\n{\n    _DevUartSetModeCommand_t\t  Cmd;\n    _DevUartSetModeResponse_t     Rsp;\n}_SlUartSetModeMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_UartSetMode)\n\n\nconst _SlCmdCtrl_t _SlUartSetModeCmdCtrl =\n{\n    SL_OPCODE_DEVICE_SETUARTMODECOMMAND,\n    sizeof(_DevUartSetModeCommand_t),\n    sizeof(_DevUartSetModeResponse_t)\n};\n\n_i16 sl_UartSetMode(const SlUartIfParams_t* pUartParams)\n{\n    _SlUartSetModeMsg_u Msg;\n    _u32 magicCode = 0xFFFFFFFF;\n\n    Msg.Cmd.BaudRate = pUartParams->BaudRate;\n    Msg.Cmd.FlowControlEnable = pUartParams->FlowControlEnable;\n\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlUartSetModeCmdCtrl, &Msg, NULL));\n\n     \n    if (SL_RET_CODE_OK == Msg.Rsp.status)\n    {\n        sl_IfMaskIntHdlr();\n\n         \n        sl_IfClose(g_pCB->FD);\n\n         \n        sl_IfOpen((void * )pUartParams, UART_IF_OPEN_FLAG_RE_OPEN);\n\n        sl_IfUnMaskIntHdlr();\n\n         \n        sl_IfWrite(g_pCB->FD, (_u8* )&magicCode, 4);\n\n        magicCode = UART_SET_MODE_MAGIC_CODE;\n        sl_IfWrite(g_pCB->FD, (_u8* )&magicCode, 4);\n\n         \n        magicCode = 0;\n\n         \n        sl_IfRead(g_pCB->FD, (_u8* )&magicCode, 4);\n\n         \n        if (UART_SET_MODE_MAGIC_CODE != magicCode)\n        {\n            _SL_ASSERT(0);\n        }\n    }\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n#endif\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}