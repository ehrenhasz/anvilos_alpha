{
  "module_name": "fs.c",
  "hash_id": "113397aadf41961539261a3b4940a2c361579e98cd46e868eaf3a5678b4d075d",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/src/fs.c",
  "human_readable_source": " \n\n\n\n \n \n \n#include \"simplelink.h\"\n#include \"protocol.h\"\n#include \"driver.h\"\n\n \n \n \n#define sl_min(a,b) (((a) < (b)) ? (a) : (b))\n#define MAX_NVMEM_CHUNK_SIZE  1460\n\n \n \n \n\n \n \n \n_u16 _sl_Strlen(const _u8 *buffer)\n{\n    _u16 len = 0;\n    if( buffer != NULL )\n    {\n      while(*buffer++) len++;\n    }\n    return len;\n}\n\n \n \n \n_u32 _sl_GetCreateFsMode(_u32 maxSizeInBytes,_u32 accessFlags)\n{\n   _u32 granIdx = 0;\n   _u32 granNum = 0;\n   _u32 granTable[_FS_MAX_MODE_SIZE_GRAN] = {256,1024,4096,16384,65536}; \n   for(granIdx= _FS_MODE_SIZE_GRAN_256B ;granIdx< _FS_MAX_MODE_SIZE_GRAN;granIdx++) \n   {                                                       \n       if( granTable[granIdx]*255 >= maxSizeInBytes ) \n            break;                                                      \n   }                                                                 \n   granNum = maxSizeInBytes/granTable[granIdx];\n   if( maxSizeInBytes % granTable[granIdx] != 0 )\n         granNum++;\n\n   return _FS_MODE(_FS_MODE_OPEN_WRITE_CREATE_IF_NOT_EXIST,  granIdx, granNum, accessFlags);\n}\n\n \n \n \n\n \n  \n \ntypedef union\n{\n\t_FsOpenCommand_t\t    Cmd;\n\t_FsOpenResponse_t\t    Rsp;\n}_SlFsOpenMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_FsOpen)\n\nconst _SlCmdCtrl_t _SlFsOpenCmdCtrl =\n{\n    SL_OPCODE_NVMEM_FILEOPEN,\n    sizeof(_FsOpenCommand_t),\n    sizeof(_FsOpenResponse_t)\n};\n\n_i32 sl_FsOpen(const _u8 *pFileName,const _u32 AccessModeAndMaxSize, _u32 *pToken,_i32 *pFileHandle)\n{\n    _SlReturnVal_t        RetVal;\n    _SlFsOpenMsg_u        Msg;\n    _SlCmdExt_t           CmdExt;\n\n    CmdExt.TxPayloadLen = (_sl_Strlen(pFileName)+4) & (~3);  \n    CmdExt.RxPayloadLen = 0;\n    CmdExt.pTxPayload = (_u8*)pFileName;\n    CmdExt.pRxPayload = NULL;\n\n    Msg.Cmd.Mode          =  AccessModeAndMaxSize; \n\n\tif(pToken != NULL)\n\t{\n       Msg.Cmd.Token         = *pToken;\n\t}\n    else\n\t{\n       Msg.Cmd.Token         = 0;\n\t}\n\n    RetVal = _SlDrvCmdOp((_SlCmdCtrl_t *)&_SlFsOpenCmdCtrl, &Msg, &CmdExt);\n    *pFileHandle = Msg.Rsp.FileHandle;\n\tif (pToken != NULL)\n\t{\n        *pToken =      Msg.Rsp.Token;\n\t}\n       \n\t \n\tif( *pFileHandle < 0 )\n\t{\n\t   return *pFileHandle;\n\t}\n    return (_i32)RetVal;\n}\n#endif\n\n \n  \n \ntypedef union\n{\n\t_FsCloseCommand_t\t    Cmd;\n\t_BasicResponse_t\t    Rsp;\n}_SlFsCloseMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_FsClose)\n\nconst _SlCmdCtrl_t _SlFsCloseCmdCtrl =\n{\n    SL_OPCODE_NVMEM_FILECLOSE,\n    sizeof(_FsCloseCommand_t),\n    sizeof(_FsCloseResponse_t)\n};\n\n_i16 sl_FsClose(const _i32 FileHdl, const _u8*  pCeritificateFileName,const _u8*  pSignature ,const _u32 SignatureLen)\n{\n    _SlFsCloseMsg_u Msg = {{0, 0}};\n    _SlCmdExt_t         ExtCtrl;\n    \n    Msg.Cmd.FileHandle             = FileHdl;\n    if( pCeritificateFileName != NULL )\n    {\n        Msg.Cmd.CertificFileNameLength = (_sl_Strlen(pCeritificateFileName)+4) & (~3);  \n    }\n    Msg.Cmd.SignatureLen           = SignatureLen;\n    \n    ExtCtrl.TxPayloadLen = ((SignatureLen+3) & (~3));  \n    ExtCtrl.pTxPayload   = (_u8*)pSignature;\n    ExtCtrl.RxPayloadLen = (_i16)Msg.Cmd.CertificFileNameLength;\n    ExtCtrl.pRxPayload   = (_u8*)pCeritificateFileName;  \n    \n    if(ExtCtrl.pRxPayload != NULL &&  ExtCtrl.RxPayloadLen != 0)\n    {\n       ExtCtrl.RxPayloadLen = ExtCtrl.RxPayloadLen * (-1);\n    }\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlFsCloseCmdCtrl, &Msg, &ExtCtrl));\n\n    return (_i16)((_i16)Msg.Rsp.status);\n}\n#endif\n\n\n \n  \n \ntypedef union\n{\n\t_FsReadCommand_t\t    Cmd;\n\t_FsReadResponse_t\t    Rsp;\n}_SlFsReadMsg_u;\n\n#if _SL_INCLUDE_FUNC(sl_FsRead)\n\n\nconst _SlCmdCtrl_t _SlFsReadCmdCtrl =\n{\n    SL_OPCODE_NVMEM_FILEREADCOMMAND,\n    sizeof(_FsReadCommand_t),\n    sizeof(_FsReadResponse_t)\n}; \n\n_i32 sl_FsRead(const _i32 FileHdl,_u32 Offset, _u8*  pData,_u32 Len)\n{\n    _SlFsReadMsg_u      Msg;\n    _SlCmdExt_t         ExtCtrl;\n    _u16      ChunkLen;\n    _SlReturnVal_t      RetVal =0;\n    _i32                RetCount = 0;\n\n    ExtCtrl.TxPayloadLen = 0;\n    ExtCtrl.pTxPayload   = NULL;\n\n    ChunkLen = (_u16)sl_min(MAX_NVMEM_CHUNK_SIZE,Len);\n    ExtCtrl.RxPayloadLen = ChunkLen;\n    ExtCtrl.pRxPayload   = (_u8 *)(pData);\n    Msg.Cmd.Offset       = Offset;\n    Msg.Cmd.Len          = ChunkLen;\n    Msg.Cmd.FileHandle   = FileHdl;\n    do\n    {\n        RetVal = _SlDrvCmdOp((_SlCmdCtrl_t *)&_SlFsReadCmdCtrl, &Msg, &ExtCtrl);\n        if(SL_OS_RET_CODE_OK == RetVal)\n        {\n            if( Msg.Rsp.status < 0)\n            {\n                if( RetCount > 0)\n                {\n                   return RetCount;\n                }\n                else\n                {\n                   return Msg.Rsp.status;\n                }\n            }\n            RetCount += (_i32)Msg.Rsp.status;\n            Len -= ChunkLen;\n            Offset += ChunkLen;\n            Msg.Cmd.Offset      = Offset;\n            ExtCtrl.pRxPayload   += ChunkLen;\n            ChunkLen = (_u16)sl_min(MAX_NVMEM_CHUNK_SIZE,Len);\n            ExtCtrl.RxPayloadLen  = ChunkLen;\n            Msg.Cmd.Len           = ChunkLen;\n            Msg.Cmd.FileHandle  = FileHdl;\n        }\n        else\n        {\n            return RetVal;\n        }\n    }while(ChunkLen > 0);\n\n    return (_i32)RetCount;\n}\n#endif\n\n \n  \n \ntypedef union\n{\n\t_FsWriteCommand_t\t    Cmd;\n\t_FsWriteResponse_t\t    Rsp;\n}_SlFsWriteMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_FsWrite)\n\nconst _SlCmdCtrl_t _SlFsWriteCmdCtrl =\n{\n    SL_OPCODE_NVMEM_FILEWRITECOMMAND,\n    sizeof(_FsWriteCommand_t),\n    sizeof(_FsWriteResponse_t)\n};\n\n_i32 sl_FsWrite(const _i32 FileHdl,_u32 Offset, _u8*  pData,_u32 Len)\n{\n    _SlFsWriteMsg_u     Msg;\n    _SlCmdExt_t         ExtCtrl;\n    _u16      ChunkLen;\n    _SlReturnVal_t      RetVal;\n    _i32                RetCount = 0;\n\n    ExtCtrl.RxPayloadLen = 0;\n    ExtCtrl.pRxPayload   = NULL;\n\n    ChunkLen = (_u16)sl_min(MAX_NVMEM_CHUNK_SIZE,Len);\n    ExtCtrl.TxPayloadLen = ChunkLen;\n    ExtCtrl.pTxPayload   = (_u8 *)(pData);\n    Msg.Cmd.Offset      = Offset;\n    Msg.Cmd.Len          = ChunkLen;\n    Msg.Cmd.FileHandle  = FileHdl;\n\n    do\n    {\n    \n        RetVal = _SlDrvCmdOp((_SlCmdCtrl_t *)&_SlFsWriteCmdCtrl, &Msg, &ExtCtrl);\n        if(SL_OS_RET_CODE_OK == RetVal)\n        {\n            if( Msg.Rsp.status < 0)\n            {\n                if( RetCount > 0)\n                {\n                   return RetCount;\n                }\n                else\n                {\n                   return Msg.Rsp.status;\n                }\n            }\n\n            RetCount += (_i32)Msg.Rsp.status;\n            Len -= ChunkLen;\n            Offset += ChunkLen;\n            Msg.Cmd.Offset        = Offset;\n            ExtCtrl.pTxPayload   += ChunkLen;\n            ChunkLen = (_u16)sl_min(MAX_NVMEM_CHUNK_SIZE,Len);\n            ExtCtrl.TxPayloadLen  = ChunkLen;\n            Msg.Cmd.Len           = ChunkLen;\n            Msg.Cmd.FileHandle  = FileHdl;\n        }\n        else\n        {\n            return RetVal;\n        }\n    }while(ChunkLen > 0);\n\n    return (_i32)RetCount;\n}\n#endif\n\n \n  \n \ntypedef union\n{\n\t_FsGetInfoCommand_t\t    Cmd;\n\t_FsGetInfoResponse_t    Rsp;\n}_SlFsGetInfoMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_FsGetInfo)\n\n\nconst _SlCmdCtrl_t _SlFsGetInfoCmdCtrl =\n{\n    SL_OPCODE_NVMEM_FILEGETINFOCOMMAND,\n    sizeof(_FsGetInfoCommand_t),\n    sizeof(_FsGetInfoResponse_t)\n};\n\n_i16 sl_FsGetInfo(const _u8 *pFileName,const _u32 Token,SlFsFileInfo_t* pFsFileInfo)\n{\n    _SlFsGetInfoMsg_u    Msg;\n    _SlCmdExt_t          CmdExt;\n\n    CmdExt.TxPayloadLen = (_sl_Strlen(pFileName)+4) & (~3);  \n    CmdExt.RxPayloadLen = 0;\n    CmdExt.pTxPayload   = (_u8*)pFileName;\n    CmdExt.pRxPayload   = NULL;\n    Msg.Cmd.Token       = Token;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlFsGetInfoCmdCtrl, &Msg, &CmdExt));\n\n    pFsFileInfo->flags        = Msg.Rsp.flags;\n    pFsFileInfo->FileLen      = Msg.Rsp.FileLen;\n    pFsFileInfo->AllocatedLen = Msg.Rsp.AllocatedLen;\n    pFsFileInfo->Token[0]     = Msg.Rsp.Token[0];\n    pFsFileInfo->Token[1]     = Msg.Rsp.Token[1];\n    pFsFileInfo->Token[2]     = Msg.Rsp.Token[2];\n    pFsFileInfo->Token[3]     = Msg.Rsp.Token[3];\n    return  (_i16)((_i16)Msg.Rsp.Status);\n}\n#endif\n\n \n  \n \ntypedef union\n{\n\t_FsDeleteCommand_t   \t    Cmd;\n\t_FsDeleteResponse_t\t        Rsp;\n}_SlFsDeleteMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_FsDel)\n\nconst _SlCmdCtrl_t _SlFsDeleteCmdCtrl =\n{\n    SL_OPCODE_NVMEM_FILEDELCOMMAND,\n    sizeof(_FsDeleteCommand_t),\n    sizeof(_FsDeleteResponse_t)\n};\n\n_i16 sl_FsDel(const _u8 *pFileName,const _u32 Token)\n{\n    _SlFsDeleteMsg_u Msg;\n    _SlCmdExt_t          CmdExt;\n\n    CmdExt.TxPayloadLen = (_sl_Strlen(pFileName)+4) & (~3);  \n    CmdExt.RxPayloadLen = 0;\n    CmdExt.pTxPayload   = (_u8*)pFileName;\n    CmdExt.pRxPayload   = NULL;\n    Msg.Cmd.Token       = Token;\n\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlFsDeleteCmdCtrl, &Msg, &CmdExt));\n\n    return  (_i16)((_i16)Msg.Rsp.status);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}