{
  "module_name": "driver.c",
  "hash_id": "79a2ce33ddaf529722cec97a223f57fbf8e86e7004062f9ab01c8d1e78d9019c",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/src/driver.c",
  "human_readable_source": " \n\n \n \n \n#include \"simplelink.h\"\n#include \"protocol.h\"\n#include \"driver.h\"\n#include \"flowcont.h\"\n\n \n \n \n\n#define          _SL_PENDING_RX_MSG(pDriverCB)   (RxIrqCnt != (pDriverCB)->RxDoneCnt)\n\n \n#define N2H_SYNC_PATTERN_SEQ_NUM_BITS            ((_u32)0x00000003)  \n#define N2H_SYNC_PATTERN_SEQ_NUM_EXISTS          ((_u32)0x00000004)  \n#define N2H_SYNC_PATTERN_MASK                    ((_u32)0xFFFFFFF8)  \n#define N2H_SYNC_SPI_BUGS_MASK                   ((_u32)0x7FFF7F7F)  \n#define BUF_SYNC_SPIM(pBuf)                      ((*(_u32 *)(pBuf)) & N2H_SYNC_SPI_BUGS_MASK)\n\n_u8             _SlDrvProtectAsyncRespSetting(_u8 *pAsyncRsp, _u8 ActionID, _u8 SocketID);\n#define N2H_SYNC_SPIM                            (N2H_SYNC_PATTERN    & N2H_SYNC_SPI_BUGS_MASK)\n#define N2H_SYNC_SPIM_WITH_SEQ(TxSeqNum)         ((N2H_SYNC_SPIM & N2H_SYNC_PATTERN_MASK) | N2H_SYNC_PATTERN_SEQ_NUM_EXISTS | ((TxSeqNum) & (N2H_SYNC_PATTERN_SEQ_NUM_BITS)))\n#define MATCH_WOUT_SEQ_NUM(pBuf)                 ( BUF_SYNC_SPIM(pBuf) ==  N2H_SYNC_SPIM )\n#define MATCH_WITH_SEQ_NUM(pBuf, TxSeqNum)       ( BUF_SYNC_SPIM(pBuf) == (N2H_SYNC_SPIM_WITH_SEQ(TxSeqNum)) )\n#define N2H_SYNC_PATTERN_MATCH(pBuf, TxSeqNum) \\\n    ( \\\n    (  (*((_u32 *)pBuf) & N2H_SYNC_PATTERN_SEQ_NUM_EXISTS) && ( MATCH_WITH_SEQ_NUM(pBuf, TxSeqNum) ) )\t|| \\\n    ( !(*((_u32 *)pBuf) & N2H_SYNC_PATTERN_SEQ_NUM_EXISTS) && ( MATCH_WOUT_SEQ_NUM(pBuf          ) ) )\t   \\\n    )\n\n#define OPCODE(_ptr)          (((_SlResponseHeader_t *)(_ptr))->GenHeader.Opcode)         \n#define RSP_PAYLOAD_LEN(_ptr) (((_SlResponseHeader_t *)(_ptr))->GenHeader.Len - _SL_RESP_SPEC_HDR_SIZE)         \n#define SD(_ptr)              (((_SocketAddrResponse_u *)(_ptr))->IpV4.sd)\n \n#define ACT_DATA_SIZE(_ptr)   (((_SocketAddrResponse_u *)(_ptr))->IpV4.statusOrLen)\n\n\n\n\n \n#if defined (EXT_LIB_REGISTERED_GENERAL_EVENTS)\n\ntypedef _SlEventPropogationStatus_e (*general_callback) (SlDeviceEvent_t *);\n\nstatic const general_callback  general_callbacks[] =\n{\n#ifdef SlExtLib1GeneralEventHandler\n\tSlExtLib1GeneralEventHandler,\n#endif\n\n#ifdef SlExtLib2GeneralEventHandler\n\tSlExtLib2GeneralEventHandler,\n#endif\n\n#ifdef SlExtLib3GeneralEventHandler\n\tSlExtLib3GeneralEventHandler,\n#endif\n\n#ifdef SlExtLib4GeneralEventHandler\n\tSlExtLib4GeneralEventHandler,\n#endif\n\n#ifdef SlExtLib5GeneralEventHandler\n\tSlExtLib5GeneralEventHandler,\n#endif\n};\n\n#undef _SlDrvHandleGeneralEvents\n\n \nvoid _SlDrvHandleGeneralEvents(SlDeviceEvent_t *slGeneralEvent)\n{\n    _u8 i;\n\n     \n    for ( i = 0 ; i < sizeof(general_callbacks)/sizeof(general_callbacks[0]) ; i++ )\n    {\n        if (EVENT_PROPAGATION_BLOCK == general_callbacks[i](slGeneralEvent) )\n\t\t{\n        \t \n            return;\n\t\t}\n    }\n\n \n#ifdef sl_GeneralEvtHdlr\n    sl_GeneralEvtHdlr(slGeneralEvent);\n#endif\n\n}\n#endif\n\n\n\n \n\n#if defined (EXT_LIB_REGISTERED_WLAN_EVENTS)\n\ntypedef _SlEventPropogationStatus_e (*wlan_callback) (SlWlanEvent_t *);\n\nstatic wlan_callback  wlan_callbacks[] =\n{\n#ifdef SlExtLib1WlanEventHandler\n\t\tSlExtLib1WlanEventHandler,\n#endif\n\n#ifdef SlExtLib2WlanEventHandler\n\t\tSlExtLib2WlanEventHandler,\n#endif\n\n#ifdef SlExtLib3WlanEventHandler\n\t\tSlExtLib3WlanEventHandler,\n#endif\n\n#ifdef SlExtLib4WlanEventHandler\n\t\tSlExtLib4WlanEventHandler,\n#endif\n\n#ifdef SlExtLib5WlanEventHandler\n\t\tSlExtLib5WlanEventHandler,\n#endif\n};\n\n#undef _SlDrvHandleWlanEvents\n\n \nvoid _SlDrvHandleWlanEvents(SlWlanEvent_t *slWlanEvent)\n{\n    _u8 i;\n\n     \n    for ( i = 0 ; i < sizeof(wlan_callbacks)/sizeof(wlan_callbacks[0]) ; i++ )\n    {\n        if ( EVENT_PROPAGATION_BLOCK == wlan_callbacks[i](slWlanEvent) )\n\t\t{\n        \t \n            return;\n\t\t}\n    }\n\n \n#ifdef sl_WlanEvtHdlr\n    sl_WlanEvtHdlr(slWlanEvent);\n#endif\n\n}\n#endif\n\n\n \n#if defined (EXT_LIB_REGISTERED_NETAPP_EVENTS)\n\ntypedef _SlEventPropogationStatus_e (*netApp_callback) (SlNetAppEvent_t *);\n\nstatic const netApp_callback  netApp_callbacks[] =\n{\n#ifdef SlExtLib1NetAppEventHandler\n\t SlExtLib1NetAppEventHandler,\n#endif\n\n#ifdef SlExtLib2NetAppEventHandler\n\t SlExtLib2NetAppEventHandler,\n#endif\n\n#ifdef SlExtLib3NetAppEventHandler\n\t SlExtLib3NetAppEventHandler,\n#endif\n\n#ifdef SlExtLib4NetAppEventHandler\n\t SlExtLib4NetAppEventHandler,\n#endif\n\n#ifdef SlExtLib5NetAppEventHandler\n\t SlExtLib5NetAppEventHandler,\n#endif\n};\n\n#undef _SlDrvHandleNetAppEvents\n\n \nvoid _SlDrvHandleNetAppEvents(SlNetAppEvent_t *slNetAppEvent)\n{\n    _u8 i;\n\n     \n    for ( i = 0 ; i < sizeof(netApp_callbacks)/sizeof(netApp_callbacks[0]) ; i++ )\n    {\n        if (EVENT_PROPAGATION_BLOCK == netApp_callbacks[i](slNetAppEvent) )\n\t\t{\n        \t \n            return;\n\t\t}\n    }\n\n \n#ifdef sl_NetAppEvtHdlr\n    sl_NetAppEvtHdlr(slNetAppEvent);\n#endif\n\n}\n#endif\n\n\n \n#if defined (EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)\n\ntypedef _SlEventPropogationStatus_e (*httpServer_callback) (SlHttpServerEvent_t*, SlHttpServerResponse_t*);\n\nstatic const httpServer_callback  httpServer_callbacks[] =\n{\n#ifdef SlExtLib1HttpServerEventHandler\n\t\tSlExtLib1HttpServerEventHandler,\n#endif\n\n#ifdef SlExtLib2HttpServerEventHandler\n\t\tSlExtLib2HttpServerEventHandler,\n#endif\n\n#ifdef SlExtLib3HttpServerEventHandler\n\t\tSlExtLib3HttpServerEventHandler,\n#endif\n\n#ifdef SlExtLib4HttpServerEventHandler\n\t\tSlExtLib4HttpServerEventHandler,\n#endif\n\n#ifdef SlExtLib5HttpServerEventHandler\n\t  SlExtLib5HttpServerEventHandler,\n#endif\n};\n\n#undef _SlDrvHandleHttpServerEvents\n\n \nvoid _SlDrvHandleHttpServerEvents(SlHttpServerEvent_t *slHttpServerEvent, SlHttpServerResponse_t *slHttpServerResponse)\n{\n    _u8 i;\n\n     \n    for ( i = 0 ; i < sizeof(httpServer_callbacks)/sizeof(httpServer_callbacks[0]) ; i++ )\n    {\n        if ( EVENT_PROPAGATION_BLOCK == httpServer_callbacks[i](slHttpServerEvent, slHttpServerResponse) )\n\t\t{\n        \t \n            return;\n\t\t}\n    }\n\n \n#ifdef sl_HttpServerCallback\n    sl_HttpServerCallback(slHttpServerEvent, slHttpServerResponse);\n#endif\n\n}\n#endif\n\n\n \n#if defined (EXT_LIB_REGISTERED_SOCK_EVENTS)\n\ntypedef _SlEventPropogationStatus_e (*sock_callback) (SlSockEvent_t *);\n\nstatic const sock_callback  sock_callbacks[] =\n{\n#ifdef SlExtLib1SockEventHandler\n\t\tSlExtLib1SockEventHandler,\n#endif\n\n#ifdef SlExtLib2SockEventHandler\n\t\tSlExtLib2SockEventHandler,\n#endif\n\n#ifdef SlExtLib3SockEventHandler\n\t\tSlExtLib3SockEventHandler,\n#endif\n\n#ifdef SlExtLib4SockEventHandler\n\t\tSlExtLib4SockEventHandler,\n#endif\n\n#ifdef SlExtLib5SockEventHandler\n\t\tSlExtLib5SockEventHandler,\n#endif\n};\n\n \nvoid _SlDrvHandleSockEvents(SlSockEvent_t *slSockEvent)\n{\n    _u8 i;\n\n     \n    for ( i = 0 ; i < sizeof(sock_callbacks)/sizeof(sock_callbacks[0]) ; i++ )\n    {\n        if ( EVENT_PROPAGATION_BLOCK == sock_callbacks[i](slSockEvent) )\n\t\t{\n        \t \n            return;\n\t\t}\n    }\n\n \n#ifdef sl_SockEvtHdlr\n    sl_SockEvtHdlr(slSockEvent);\n#endif\n\n}\n\n#endif\n\n\n#if (SL_MEMORY_MGMT != SL_MEMORY_MGMT_DYNAMIC)\ntypedef struct\n{\n    _u32 Align;\n    _SlDriverCb_t DriverCB;\n    _u8 AsyncRespBuf[SL_ASYNC_MAX_MSG_LEN];\n}_SlStatMem_t;\n\n_SlStatMem_t g_StatMem;\n#endif\n\n_u8 _SlDrvProtectAsyncRespSetting(_u8 *pAsyncRsp, _u8 ActionID, _u8 SocketID)\n{\n    _u8 ObjIdx;\n\n\n     \n    ObjIdx = _SlDrvWaitForPoolObj(ActionID, SocketID);\n\n    if (MAX_CONCURRENT_ACTIONS != ObjIdx)\n    {\n        _SlDrvProtectionObjLockWaitForever();\n        g_pCB->ObjPool[ObjIdx].pRespArgs = pAsyncRsp;\n        _SlDrvProtectionObjUnLock();\n    }\n\n    return ObjIdx;\n}\n\n\n \n \n \nconst _SlSyncPattern_t g_H2NSyncPattern = H2N_SYNC_PATTERN;\nconst _SlSyncPattern_t g_H2NCnysPattern = H2N_CNYS_PATTERN;\n_volatile _u8           RxIrqCnt;\n\n#ifndef SL_TINY_EXT\nconst _SlActionLookup_t _SlActionLookupTable[] = \n{\n    {ACCEPT_ID, SL_OPCODE_SOCKET_ACCEPTASYNCRESPONSE, (_SlSpawnEntryFunc_t)_sl_HandleAsync_Accept},\n    {CONNECT_ID, SL_OPCODE_SOCKET_CONNECTASYNCRESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_Connect},\n    {SELECT_ID, SL_OPCODE_SOCKET_SELECTASYNCRESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_Select},\n    {GETHOSYBYNAME_ID, SL_OPCODE_NETAPP_DNSGETHOSTBYNAMEASYNCRESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_DnsGetHostByName},\n    {GETHOSYBYSERVICE_ID, SL_OPCODE_NETAPP_MDNSGETHOSTBYSERVICEASYNCRESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_DnsGetHostByService}, \n    {PING_ID, SL_OPCODE_NETAPP_PINGREPORTREQUESTRESPONSE, (_SlSpawnEntryFunc_t)_sl_HandleAsync_PingResponse},\n    {START_STOP_ID, SL_OPCODE_DEVICE_STOP_ASYNC_RESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_Stop}\n};\n#else\nconst _SlActionLookup_t _SlActionLookupTable[] = \n{\n    {CONNECT_ID, SL_OPCODE_SOCKET_CONNECTASYNCRESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_Connect},\n    {GETHOSYBYNAME_ID, SL_OPCODE_NETAPP_DNSGETHOSTBYNAMEASYNCRESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_DnsGetHostByName},  \n    {START_STOP_ID, SL_OPCODE_DEVICE_STOP_ASYNC_RESPONSE,(_SlSpawnEntryFunc_t)_sl_HandleAsync_Stop}\n};\n#endif\n\n\n\ntypedef struct\n{\n    _u16 opcode;\n    _u8  event;\n} OpcodeKeyVal_t;\n\n \nconst OpcodeKeyVal_t OpcodeTranslateTable[] = \n{\n{SL_OPCODE_WLAN_SMART_CONFIG_START_ASYNC_RESPONSE, SL_WLAN_SMART_CONFIG_COMPLETE_EVENT},\n{SL_OPCODE_WLAN_SMART_CONFIG_STOP_ASYNC_RESPONSE,SL_WLAN_SMART_CONFIG_STOP_EVENT},\n{SL_OPCODE_WLAN_STA_CONNECTED, SL_WLAN_STA_CONNECTED_EVENT},\n{SL_OPCODE_WLAN_STA_DISCONNECTED,SL_WLAN_STA_DISCONNECTED_EVENT},\n{SL_OPCODE_WLAN_P2P_DEV_FOUND,SL_WLAN_P2P_DEV_FOUND_EVENT},    \n{SL_OPCODE_WLAN_P2P_NEG_REQ_RECEIVED, SL_WLAN_P2P_NEG_REQ_RECEIVED_EVENT},\n{SL_OPCODE_WLAN_CONNECTION_FAILED, SL_WLAN_CONNECTION_FAILED_EVENT},\n{SL_OPCODE_WLAN_WLANASYNCCONNECTEDRESPONSE, SL_WLAN_CONNECT_EVENT},\n{SL_OPCODE_WLAN_WLANASYNCDISCONNECTEDRESPONSE, SL_WLAN_DISCONNECT_EVENT},\n{SL_OPCODE_NETAPP_IPACQUIRED, SL_NETAPP_IPV4_IPACQUIRED_EVENT},\n{SL_OPCODE_NETAPP_IPACQUIRED_V6, SL_NETAPP_IPV6_IPACQUIRED_EVENT},\n{SL_OPCODE_NETAPP_IP_LEASED, SL_NETAPP_IP_LEASED_EVENT},\n{SL_OPCODE_NETAPP_IP_RELEASED, SL_NETAPP_IP_RELEASED_EVENT},\n{SL_OPCODE_SOCKET_TXFAILEDASYNCRESPONSE, SL_SOCKET_TX_FAILED_EVENT},\n{SL_OPCODE_SOCKET_SOCKETASYNCEVENT, SL_SOCKET_ASYNC_EVENT}\n};\n\n\n\n_SlDriverCb_t* g_pCB = NULL;\nP_SL_DEV_PING_CALLBACK  pPingCallBackFunc = NULL;\n_u8 gFirstCmdMode = 0;\n\n \n \n \n_SlReturnVal_t   _SlDrvMsgRead(void);\n_SlReturnVal_t   _SlDrvMsgWrite(_SlCmdCtrl_t  *pCmdCtrl,_SlCmdExt_t  *pCmdExt, _u8 *pTxRxDescBuff);\n_SlReturnVal_t   _SlDrvMsgReadCmdCtx(void);\n_SlReturnVal_t   _SlDrvMsgReadSpawnCtx(void *pValue);\nvoid             _SlDrvClassifyRxMsg(_SlOpcode_t Opcode );\n_SlReturnVal_t   _SlDrvRxHdrRead(_u8 *pBuf, _u8 *pAlignSize);\nvoid             _SlDrvShiftDWord(_u8 *pBuf);\nvoid             _SlDrvDriverCBInit(void);\nvoid             _SlAsyncEventGenericHandler(void);\n_u8\t\t\t     _SlDrvWaitForPoolObj(_u8 ActionID, _u8 SocketID);\nvoid\t\t\t _SlDrvReleasePoolObj(_u8 pObj);\nvoid\t\t\t _SlRemoveFromList(_u8* ListIndex, _u8 ItemIndex);\n_SlReturnVal_t\t _SlFindAndSetActiveObj(_SlOpcode_t  Opcode, _u8 Sd);\n\n\n \n \n \n\n\n \n\nvoid _SlDrvDriverCBInit(void)\n{\n    _u8          Idx =0;\n\n#if (SL_MEMORY_MGMT == SL_MEMORY_MGMT_DYNAMIC)\n    g_pCB = sl_Malloc(sizeof(_SlDriverCb_t));\n#else\n    g_pCB = &(g_StatMem.DriverCB);\n#endif\n    MALLOC_OK_CHECK(g_pCB);\n\n    \n    _SlDrvMemZero(g_pCB, sizeof(_SlDriverCb_t));\n    RxIrqCnt = 0;\n    OSI_RET_OK_CHECK( sl_SyncObjCreate(&g_pCB->CmdSyncObj, \"CmdSyncObj\") );\n    sl_SyncObjClear(&g_pCB->CmdSyncObj);\n\n    OSI_RET_OK_CHECK( sl_LockObjCreate(&g_pCB->GlobalLockObj, \"GlobalLockObj\") );\n    OSI_RET_OK_CHECK( sl_LockObjCreate(&g_pCB->ProtectionLockObj, \"ProtectionLockObj\") );\n\n     \n    _SlDrvMemZero(&g_pCB->ObjPool[0], MAX_CONCURRENT_ACTIONS*sizeof(_SlPoolObj_t));\n\n     \n    g_pCB->FreePoolIdx = 0;\n\n    for (Idx = 0 ; Idx < MAX_CONCURRENT_ACTIONS ; Idx++)\n    {\n        g_pCB->ObjPool[Idx].NextIndex = Idx + 1;\n        g_pCB->ObjPool[Idx].AdditionalData = SL_MAX_SOCKETS;\n\n        OSI_RET_OK_CHECK( sl_SyncObjCreate(&g_pCB->ObjPool[Idx].SyncObj, \"SyncObj\"));\n        sl_SyncObjClear(&g_pCB->ObjPool[Idx].SyncObj);\n    }\n\n     g_pCB->ActivePoolIdx = MAX_CONCURRENT_ACTIONS;\n     g_pCB->PendingPoolIdx = MAX_CONCURRENT_ACTIONS;\n\n     \n    g_pCB->FlowContCB.TxPoolCnt = FLOW_CONT_MIN;\n    OSI_RET_OK_CHECK(sl_LockObjCreate(&g_pCB->FlowContCB.TxLockObj, \"TxLockObj\"));\n    OSI_RET_OK_CHECK(sl_SyncObjCreate(&g_pCB->FlowContCB.TxSyncObj, \"TxSyncObj\"));\n    \n    gFirstCmdMode = 0;  \n\n}\n\n \nvoid _SlDrvDriverCBDeinit()\n{\n    _u8  Idx =0;\n\n     \n    g_pCB->FlowContCB.TxPoolCnt = 0;\n    OSI_RET_OK_CHECK(sl_LockObjDelete(&g_pCB->FlowContCB.TxLockObj));\n    OSI_RET_OK_CHECK(sl_SyncObjDelete(&g_pCB->FlowContCB.TxSyncObj));\n    \n    OSI_RET_OK_CHECK( sl_SyncObjDelete(&g_pCB->CmdSyncObj) );\n    OSI_RET_OK_CHECK( sl_LockObjDelete(&g_pCB->GlobalLockObj) );\n    OSI_RET_OK_CHECK( sl_LockObjDelete(&g_pCB->ProtectionLockObj) );\n        \n #ifndef SL_TINY_EXT\n    for (Idx = 0; Idx < MAX_CONCURRENT_ACTIONS; Idx++)\n #endif\n    {\n\tOSI_RET_OK_CHECK( sl_SyncObjDelete(&g_pCB->ObjPool[Idx].SyncObj) );   \n    }\n\n    g_pCB->FreePoolIdx = 0;\n    g_pCB->PendingPoolIdx = MAX_CONCURRENT_ACTIONS;\n    g_pCB->ActivePoolIdx = MAX_CONCURRENT_ACTIONS;\n\n#if (SL_MEMORY_MGMT == SL_MEMORY_MGMT_DYNAMIC)\n    sl_Free(g_pCB);\n#else\n    g_pCB = NULL;\n#endif\n\n\n    g_pCB = NULL;\n}\n\n \nvoid _SlDrvRxIrqHandler(void *pValue)\n{\n    sl_IfMaskIntHdlr();\n\n    RxIrqCnt++;\n\n    if (TRUE == g_pCB->IsCmdRespWaited)\n    {\n        OSI_RET_OK_CHECK( sl_SyncObjSignalFromIRQ(&g_pCB->CmdSyncObj) );\n    }\n    else\n    {\n        sl_Spawn((_SlSpawnEntryFunc_t)_SlDrvMsgReadSpawnCtx, NULL, 0);\n    }\n}\n\n \n_SlReturnVal_t _SlDrvCmdOp(\n    _SlCmdCtrl_t  *pCmdCtrl ,\n    void          *pTxRxDescBuff ,\n    _SlCmdExt_t   *pCmdExt)\n{\n    _SlReturnVal_t RetVal;\n\n    \n    _SlDrvObjLockWaitForever(&g_pCB->GlobalLockObj);\n    \n    g_pCB->IsCmdRespWaited = TRUE;\n\n    SL_TRACE0(DBG_MSG, MSG_312, \"_SlDrvCmdOp: call _SlDrvMsgWrite\");\n\n\n     \n    RetVal = _SlDrvMsgWrite(pCmdCtrl, pCmdExt, pTxRxDescBuff);\n\n    if(SL_OS_RET_CODE_OK == RetVal)\n    {\n\n#ifndef SL_IF_TYPE_UART    \n         \n        if( 0 == gFirstCmdMode )\n        {\n            volatile _u32 CountVal = 0;\n            gFirstCmdMode = 1;\n            CountVal = CPU_FREQ_IN_MHZ*USEC_DELAY;\n            while( CountVal-- );\n        }   \n#endif \n         \n        RetVal = _SlDrvMsgReadCmdCtx();  \n        SL_TRACE0(DBG_MSG, MSG_314, \"_SlDrvCmdOp: exited _SlDrvMsgReadCmdCtx\");\n    }\n    else\n    {\n        _SlDrvObjUnLock(&g_pCB->GlobalLockObj);\n    }\n    \n    return RetVal;\n}\n\n\n\n \n_SlReturnVal_t _SlDrvDataReadOp(\n    _SlSd_t             Sd,\n    _SlCmdCtrl_t        *pCmdCtrl ,\n    void                *pTxRxDescBuff ,\n    _SlCmdExt_t         *pCmdExt)\n{\n    _SlReturnVal_t RetVal;\n    _u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n    _SlArgsData_t pArgsData;\n\n     \n    VERIFY_PROTOCOL(NULL != pCmdExt->pRxPayload);\n\n     \n     \n    VERIFY_PROTOCOL(0 != pCmdExt->RxPayloadLen);\n\n     \n    if((Sd & BSD_SOCKET_ID_MASK) >= SL_MAX_SOCKETS)\n    {\n        return SL_EBADF;\n    }\n\n     \n    ObjIdx = (_u8)_SlDrvWaitForPoolObj(RECV_ID, Sd & BSD_SOCKET_ID_MASK);\n\n    if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n    {\n        return SL_POOL_IS_EMPTY;\n    }\n\n    _SlDrvProtectionObjLockWaitForever();\n\n    pArgsData.pData = pCmdExt->pRxPayload;\n    pArgsData.pArgs =  (_u8 *)pTxRxDescBuff;\n    g_pCB->ObjPool[ObjIdx].pRespArgs =  (_u8 *)&pArgsData;\n\n    _SlDrvProtectionObjUnLock();\n\n\n     \n    _SlDrvObjLockWaitForever(&g_pCB->FlowContCB.TxLockObj);\n\n\n     \n     \n     \n    sl_SyncObjClear(&g_pCB->FlowContCB.TxSyncObj);\n\n    if(g_pCB->FlowContCB.TxPoolCnt <= FLOW_CONT_MIN)\n    {\n\n         \n        _SlDrvSyncObjWaitForever(&g_pCB->FlowContCB.TxSyncObj);\n       \n    }\n\n    _SlDrvObjLockWaitForever(&g_pCB->GlobalLockObj);\n    \n\n    VERIFY_PROTOCOL(g_pCB->FlowContCB.TxPoolCnt > FLOW_CONT_MIN);\n    g_pCB->FlowContCB.TxPoolCnt--;\n\n    _SlDrvObjUnLock(&g_pCB->FlowContCB.TxLockObj);\n\n     \n    RetVal =  _SlDrvMsgWrite(pCmdCtrl, pCmdExt, (_u8 *)pTxRxDescBuff);\n\n    _SlDrvObjUnLock(&g_pCB->GlobalLockObj);\n    \n\n    if(SL_OS_RET_CODE_OK == RetVal)\n    {\n         \n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n    }\n\n    _SlDrvReleasePoolObj(ObjIdx);\n    return RetVal;\n}\n\n \n \n \n_SlReturnVal_t _SlDrvDataWriteOp(\n    _SlSd_t             Sd,\n    _SlCmdCtrl_t  *pCmdCtrl ,\n    void                *pTxRxDescBuff ,\n    _SlCmdExt_t         *pCmdExt)\n{\n    _SlReturnVal_t  RetVal = SL_EAGAIN;  \n    while( 1 )\n    {\n         \n    _SlDrvObjLockWaitForever(&g_pCB->FlowContCB.TxLockObj);\n\n         \n         \n         \n        sl_SyncObjClear(&g_pCB->FlowContCB.TxSyncObj);\n\n         \n        if(g_pCB->SocketTXFailure & (1<<(Sd & BSD_SOCKET_ID_MASK)))\n        {\n\t\t_SlDrvObjUnLock(&g_pCB->FlowContCB.TxLockObj);\n            return SL_SOC_ERROR;\n        }\n        if(g_pCB->FlowContCB.TxPoolCnt <= FLOW_CONT_MIN + 1)\n        {\n             \n             \n            if( g_pCB->SocketNonBlocking & (1<< (Sd & BSD_SOCKET_ID_MASK)))\n            {\n            _SlDrvObjUnLock(&g_pCB->FlowContCB.TxLockObj);\n                return RetVal;\n            }\n             \n             \n        _SlDrvSyncObjWaitForever(&g_pCB->FlowContCB.TxSyncObj);\n        }\n        if(g_pCB->FlowContCB.TxPoolCnt > FLOW_CONT_MIN + 1 )\n        {\n            break;\n        }\n        else\n        {\n\t\t\t_SlDrvObjUnLock(&g_pCB->FlowContCB.TxLockObj);\n        }\n    }\n\n    _SlDrvObjLockWaitForever(&g_pCB->GlobalLockObj);\n    \n\n    VERIFY_PROTOCOL(g_pCB->FlowContCB.TxPoolCnt > FLOW_CONT_MIN + 1 );\n    g_pCB->FlowContCB.TxPoolCnt--;\n\n    _SlDrvObjUnLock(&g_pCB->FlowContCB.TxLockObj);\n    \n     \n    RetVal =  _SlDrvMsgWrite(pCmdCtrl, pCmdExt, pTxRxDescBuff);\n\n    _SlDrvObjUnLock(&g_pCB->GlobalLockObj);\n\n    return RetVal;\n}\n\n \n \n \n_SlReturnVal_t _SlDrvMsgWrite(_SlCmdCtrl_t  *pCmdCtrl,_SlCmdExt_t  *pCmdExt, _u8 *pTxRxDescBuff)\n{\n    _u8 sendRxPayload = FALSE;\n    VERIFY_PROTOCOL(NULL != pCmdCtrl);\n\n    g_pCB->FunctionParams.pCmdCtrl = pCmdCtrl;\n    g_pCB->FunctionParams.pTxRxDescBuff = pTxRxDescBuff;\n    g_pCB->FunctionParams.pCmdExt = pCmdExt;\n    \n    g_pCB->TempProtocolHeader.Opcode   = pCmdCtrl->Opcode;\n    g_pCB->TempProtocolHeader.Len   = _SL_PROTOCOL_CALC_LEN(pCmdCtrl, pCmdExt);\n\n    if (pCmdExt && pCmdExt->RxPayloadLen < 0 && pCmdExt->TxPayloadLen)\n    {\n        pCmdExt->RxPayloadLen = pCmdExt->RxPayloadLen * (-1);  \n        sendRxPayload = TRUE;\n        g_pCB->TempProtocolHeader.Len = g_pCB->TempProtocolHeader.Len + pCmdExt->RxPayloadLen;\n    }\n\n#ifdef SL_START_WRITE_STAT\n    sl_IfStartWriteSequence(g_pCB->FD);\n#endif\n\n#ifdef SL_IF_TYPE_UART\n     \n    NWP_IF_WRITE_CHECK(g_pCB->FD, (_u8 *)&g_H2NSyncPattern.Long, 2*SYNC_PATTERN_LEN);\n#else\n     \n    NWP_IF_WRITE_CHECK(g_pCB->FD, (_u8 *)&g_H2NSyncPattern.Short, SYNC_PATTERN_LEN);\n#endif\n\n     \n    NWP_IF_WRITE_CHECK(g_pCB->FD, (_u8 *)&g_pCB->TempProtocolHeader, _SL_CMD_HDR_SIZE);\n\n     \n    if (pTxRxDescBuff && pCmdCtrl->TxDescLen > 0)\n    {\n    \tNWP_IF_WRITE_CHECK(g_pCB->FD, pTxRxDescBuff, \n                           _SL_PROTOCOL_ALIGN_SIZE(pCmdCtrl->TxDescLen));\n    }\n\n     \n     \n     \n    if (sendRxPayload == TRUE )\n    {\n     \tNWP_IF_WRITE_CHECK(g_pCB->FD, pCmdExt->pRxPayload, \n                           _SL_PROTOCOL_ALIGN_SIZE(pCmdExt->RxPayloadLen));\n    }\n\n     \n    if (pCmdExt && pCmdExt->TxPayloadLen > 0)\n    {\n         \n         \n        VERIFY_PROTOCOL(_SL_IS_PROTOCOL_ALIGNED_SIZE(pCmdCtrl->TxDescLen));\n\n    \tNWP_IF_WRITE_CHECK(g_pCB->FD, pCmdExt->pTxPayload, \n                           _SL_PROTOCOL_ALIGN_SIZE(pCmdExt->TxPayloadLen));\n    }\n\n\n    _SL_DBG_CNT_INC(MsgCnt.Write);\n\n#ifdef SL_START_WRITE_STAT\n    sl_IfEndWriteSequence(g_pCB->FD);\n#endif\n\n    return SL_OS_RET_CODE_OK;\n}\n\n \n \n \n_SlReturnVal_t _SlDrvMsgRead(void)\n{\n     \n    union\n    {      \n      _u8             TempBuf[_SL_RESP_HDR_SIZE];\n      _u32            DummyBuf[2];\n    } uBuf;\n    _u8               TailBuffer[4];\n    _u16              LengthToCopy;\n    _u16              AlignedLengthRecv;\n    _u8               AlignSize;\n    _u8               *pAsyncBuf = NULL;\n    _u16              OpCode;\n    _u16              RespPayloadLen;\n    _u8               sd = SL_MAX_SOCKETS;\n    _SlRxMsgClass_e   RxMsgClass;\n    \n\n     \n    g_pCB->FunctionParams.AsyncExt.pAsyncBuf      = NULL;\n    g_pCB->FunctionParams.AsyncExt.AsyncEvtHandler= NULL;\n\n    \n    VERIFY_RET_OK(_SlDrvRxHdrRead((_u8*)(uBuf.TempBuf), &AlignSize));\n\n    OpCode = OPCODE(uBuf.TempBuf);\n    RespPayloadLen = RSP_PAYLOAD_LEN(uBuf.TempBuf);\n\n\n     \n    if(SL_OPCODE_DEVICE_INITCOMPLETE != OpCode)\n    {\n        g_pCB->FlowContCB.TxPoolCnt = ((_SlResponseHeader_t *)uBuf.TempBuf)->TxPoolCnt;\n        g_pCB->SocketNonBlocking = ((_SlResponseHeader_t *)uBuf.TempBuf)->SocketNonBlocking;\n        g_pCB->SocketTXFailure = ((_SlResponseHeader_t *)uBuf.TempBuf)->SocketTXFailure;\n\n        if(g_pCB->FlowContCB.TxPoolCnt > FLOW_CONT_MIN)\n        {\n            _SlDrvSyncObjSignal(&g_pCB->FlowContCB.TxSyncObj);\n        }\n    }\n\n     \n    _SlDrvClassifyRxMsg(OpCode);\n    \n    RxMsgClass = g_pCB->FunctionParams.AsyncExt.RxMsgClass;\n\n\n    switch(RxMsgClass)\n    {\n    case ASYNC_EVT_CLASS:\n\n            VERIFY_PROTOCOL(NULL == pAsyncBuf);\n\n#if (SL_MEMORY_MGMT == SL_MEMORY_MGMT_DYNAMIC)\n        g_pCB->FunctionParams.AsyncExt.pAsyncBuf = sl_Malloc(SL_ASYNC_MAX_MSG_LEN);\n#else\n        g_pCB->FunctionParams.AsyncExt.pAsyncBuf = g_StatMem.AsyncRespBuf;\n#endif\n             \n            pAsyncBuf = g_pCB->FunctionParams.AsyncExt.pAsyncBuf;\n\n             \n            _SlDrvMemZero(pAsyncBuf, SL_ASYNC_MAX_MSG_LEN);\n            \n            MALLOC_OK_CHECK(pAsyncBuf);\n\n            sl_Memcpy(pAsyncBuf, uBuf.TempBuf, _SL_RESP_HDR_SIZE);\n\t\t\tif (_SL_PROTOCOL_ALIGN_SIZE(RespPayloadLen) <= SL_ASYNC_MAX_PAYLOAD_LEN)\n\t\t\t{\n\t\t\t\tAlignedLengthRecv = _SL_PROTOCOL_ALIGN_SIZE(RespPayloadLen);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAlignedLengthRecv = _SL_PROTOCOL_ALIGN_SIZE(SL_ASYNC_MAX_PAYLOAD_LEN);\n\t\t\t}\n            if (RespPayloadLen > 0)\n            {\n                NWP_IF_READ_CHECK(g_pCB->FD,\n                                  pAsyncBuf + _SL_RESP_HDR_SIZE,\n                                  AlignedLengthRecv);\n        }\n         \n\t\t\tif ((_SL_PROTOCOL_ALIGN_SIZE(RespPayloadLen) > SL_ASYNC_MAX_PAYLOAD_LEN))\n        {\n\t\t\t\tAlignedLengthRecv = _SL_PROTOCOL_ALIGN_SIZE(RespPayloadLen) - SL_ASYNC_MAX_PAYLOAD_LEN;\n            while (AlignedLengthRecv > 0)\n            {\n                NWP_IF_READ_CHECK(g_pCB->FD,TailBuffer,4);\n                AlignedLengthRecv = AlignedLengthRecv - 4;\n            }\n        }\n            \n            _SlDrvProtectionObjLockWaitForever();\n          \n\t\t\tif (\n#ifndef SL_TINY_EXT               \n                (SL_OPCODE_SOCKET_ACCEPTASYNCRESPONSE == OpCode) || \n                (SL_OPCODE_SOCKET_ACCEPTASYNCRESPONSE_V6 == OpCode) || \n#endif                \n                (SL_OPCODE_SOCKET_CONNECTASYNCRESPONSE == OpCode)\n               )\n\t\t\t{\n\t\t\t\t \n\t\t\t\tsd = ((((_SocketResponse_t *)(pAsyncBuf + _SL_RESP_HDR_SIZE))->sd) & BSD_SOCKET_ID_MASK);\n\t\t\t}\n\t\t\t_SlFindAndSetActiveObj(OpCode, sd);\n\n            _SlDrvProtectionObjUnLock();\n\n            break;\n    case RECV_RESP_CLASS:\n        {\n            _u8   ExpArgSize;  \n\n                switch(OpCode)\n            {\n            case SL_OPCODE_SOCKET_RECVFROMASYNCRESPONSE:\n                ExpArgSize = RECVFROM_IPV4_ARGS_SIZE;\n                break;\n#ifndef SL_TINY_EXT                        \n            case SL_OPCODE_SOCKET_RECVFROMASYNCRESPONSE_V6:\n                ExpArgSize = RECVFROM_IPV6_ARGS_SIZE;\n                break;\n#endif                        \n            default:\n                 \n                ExpArgSize = RECV_ARGS_SIZE;\n            }              \n\n             \n             \n            NWP_IF_READ_CHECK(g_pCB->FD, &uBuf.TempBuf[4], RECV_ARGS_SIZE);\n\n             \n            VERIFY_PROTOCOL((SD(&uBuf.TempBuf[4])& BSD_SOCKET_ID_MASK) < SL_MAX_SOCKETS);\n\n                 _SlDrvProtectionObjLockWaitForever();\n\n             \n\t\t\t\tVERIFY_RET_OK(_SlFindAndSetActiveObj(OpCode,SD(&uBuf.TempBuf[4]) & BSD_SOCKET_ID_MASK));\n\n             \n            VERIFY_SOCKET_CB(NULL !=  ((_SlArgsData_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pData))->pArgs);\t\n\n            sl_Memcpy( ((_SlArgsData_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->pArgs, &uBuf.TempBuf[4], RECV_ARGS_SIZE);\n\n            if(ExpArgSize > RECV_ARGS_SIZE)\n            {\n                NWP_IF_READ_CHECK(g_pCB->FD,\n                    ((_SlArgsData_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->pArgs + RECV_ARGS_SIZE,\n                    ExpArgSize - RECV_ARGS_SIZE);\n            }\n\n             \n             \n             \n            if(ACT_DATA_SIZE(&uBuf.TempBuf[4]) > 0)\n            {       \n                VERIFY_SOCKET_CB(NULL != ((_SlArgsData_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->pData);\n\n                 \n                 \n                 \n                 \n                LengthToCopy = ACT_DATA_SIZE(&uBuf.TempBuf[4]) & (3);\n                AlignedLengthRecv = ACT_DATA_SIZE(&uBuf.TempBuf[4]) & (~3);\n                if( AlignedLengthRecv >= 4)\n                {\n                    NWP_IF_READ_CHECK(g_pCB->FD,((_SlArgsData_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->pData,AlignedLengthRecv );                      \n                }\n                 \n                if( LengthToCopy > 0) \n                {\n                    NWP_IF_READ_CHECK(g_pCB->FD,TailBuffer,4);\n                     \n                    sl_Memcpy(((_SlArgsData_t *)(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs))->pData + AlignedLengthRecv,TailBuffer,LengthToCopy);                    \n                }                  \n            }\n                 _SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n                 _SlDrvProtectionObjUnLock();\n        }\n        break;\n\n    case CMD_RESP_CLASS:\n\n         \n         \n         \n         \n         \n         \n        NWP_IF_READ_CHECK(g_pCB->FD,\n            g_pCB->FunctionParams.pTxRxDescBuff,\n            _SL_PROTOCOL_ALIGN_SIZE(g_pCB->FunctionParams.pCmdCtrl->RxDescLen));\n\n        if((NULL != g_pCB->FunctionParams.pCmdExt) && (0 != g_pCB->FunctionParams.pCmdExt->RxPayloadLen))\n        {\n             \n            _i16    ActDataSize = RSP_PAYLOAD_LEN(uBuf.TempBuf) - g_pCB->FunctionParams.pCmdCtrl->RxDescLen;\n\n            g_pCB->FunctionParams.pCmdExt->ActualRxPayloadLen = ActDataSize;\n\n             \n            if(ActDataSize <= 0)\n            {\n                g_pCB->FunctionParams.pCmdExt->RxPayloadLen = 0;\n            }\n            else\n            {\n                 \n                if (ActDataSize > g_pCB->FunctionParams.pCmdExt->RxPayloadLen)\n                {\n                    LengthToCopy = g_pCB->FunctionParams.pCmdExt->RxPayloadLen & (3);\n                    AlignedLengthRecv = g_pCB->FunctionParams.pCmdExt->RxPayloadLen & (~3);\n                }\n                else\n                {\n                    LengthToCopy = ActDataSize & (3);\n                    AlignedLengthRecv = ActDataSize & (~3);\n                }\n                 \n                 \n                 \n                 \n\n                if( AlignedLengthRecv >= 4)\n                {\n                    NWP_IF_READ_CHECK(g_pCB->FD,\n                        g_pCB->FunctionParams.pCmdExt->pRxPayload,\n                        AlignedLengthRecv );\n\n                }\n                 \n                if( LengthToCopy > 0) \n                {\n                    NWP_IF_READ_CHECK(g_pCB->FD,TailBuffer,4);\n                     \n                    sl_Memcpy(g_pCB->FunctionParams.pCmdExt->pRxPayload + AlignedLengthRecv,\n                        TailBuffer,\n                        LengthToCopy);\n                    ActDataSize = ActDataSize-4;\n                }\n                 \n                if (ActDataSize > g_pCB->FunctionParams.pCmdExt->RxPayloadLen)\n                {\n                     \n                    AlignedLengthRecv = ActDataSize - (g_pCB->FunctionParams.pCmdExt->RxPayloadLen & (~3));\n                    while( AlignedLengthRecv > 0)\n                    {\n                        NWP_IF_READ_CHECK(g_pCB->FD,TailBuffer, 4 );\n                        AlignedLengthRecv = AlignedLengthRecv - 4;\n                    }\n                }\n            }\n        }\n        break;\n\n    default:\n         \n        break;\n    }\n\n    if(AlignSize > 0)\n    {\n        NWP_IF_READ_CHECK(g_pCB->FD, uBuf.TempBuf, AlignSize);\n    }\n\n    _SL_DBG_CNT_INC(MsgCnt.Read);\n\n     \n    sl_IfUnMaskIntHdlr();\n\n    return SL_OS_RET_CODE_OK;\n}\n\n\n \n \n \nvoid _SlAsyncEventGenericHandler(void)\n{\n    _u32 SlAsyncEvent = 0;\n    _u8  OpcodeFound = FALSE; \n    _u8  i;\n    \n    _u32* pEventLocation  = NULL;  \n    _SlResponseHeader_t  *pHdr       = (_SlResponseHeader_t *)g_pCB->FunctionParams.AsyncExt.pAsyncBuf;\n\n\n     \n    if (g_pCB->FunctionParams.AsyncExt.AsyncEvtHandler == NULL)\n        return;\n\n     \n    for (i=0; i< (sizeof(OpcodeTranslateTable) / sizeof(OpcodeKeyVal_t)); i++)\n    {\n        if (OpcodeTranslateTable[i].opcode == pHdr->GenHeader.Opcode)\n        {\n            SlAsyncEvent = OpcodeTranslateTable[i].event;\n            OpcodeFound = TRUE;\n            break;\n        }\n    }\n\n     \n    if (OpcodeFound == FALSE)\n    {\n         \n        g_pCB->FunctionParams.AsyncExt.AsyncEvtHandler(g_pCB->FunctionParams.AsyncExt.pAsyncBuf);\n    }\n    else\n    {\n        \n       pEventLocation = (_u32*)(g_pCB->FunctionParams.AsyncExt.pAsyncBuf + sizeof (_SlResponseHeader_t) - sizeof(SlAsyncEvent) );\n\n        \n       *pEventLocation = SlAsyncEvent;\n\n        \n       g_pCB->FunctionParams.AsyncExt.AsyncEvtHandler(pEventLocation);\n    }\n\n     \n}\n\n\n \n \n \n_SlReturnVal_t _SlDrvMsgReadCmdCtx(void)\n{\n\n     \n     \n     \n     \n     \n     \n    while (TRUE == g_pCB->IsCmdRespWaited)\n    {\n        if(_SL_PENDING_RX_MSG(g_pCB))\n        {\n            VERIFY_RET_OK(_SlDrvMsgRead());\n            g_pCB->RxDoneCnt++;\n\n            if (CMD_RESP_CLASS == g_pCB->FunctionParams.AsyncExt.RxMsgClass)\n            {\n                g_pCB->IsCmdRespWaited = FALSE;\n\n                 \n                 \n                sl_SyncObjClear(&g_pCB->CmdSyncObj);\n            }\n            else if (ASYNC_EVT_CLASS == g_pCB->FunctionParams.AsyncExt.RxMsgClass)\n            {\n                 \n                 \n                 \n                 \n                 \n                 \n                _SlAsyncEventGenericHandler();\n                \n                \n#if (SL_MEMORY_MGMT == SL_MEMORY_MGMT_DYNAMIC)\n                sl_Free(g_pCB->FunctionParams.AsyncExt.pAsyncBuf);\n#else\n                g_pCB->FunctionParams.AsyncExt.pAsyncBuf = NULL;\n#endif\n            }\n        }\n        else\n        {\n             \n             _SlDrvSyncObjWaitForever(&g_pCB->CmdSyncObj);\n        }\n    }\n\n     \n     \n     \n     \n     \n\n    _SlDrvObjUnLock(&g_pCB->GlobalLockObj);\n    \n    if(_SL_PENDING_RX_MSG(g_pCB))\n    {\n        sl_Spawn((_SlSpawnEntryFunc_t)_SlDrvMsgReadSpawnCtx, NULL, 0);\n    }\n\n    return SL_OS_RET_CODE_OK;\n}\n\n \n \n \n_SlReturnVal_t _SlDrvMsgReadSpawnCtx(void *pValue)\n{\n#ifdef SL_POLLING_MODE_USED\n    _i16 retCode = OSI_OK;\n     \n    do\n    {\n        retCode = sl_LockObjLock(&g_pCB->GlobalLockObj, 0);\n        if ( OSI_OK != retCode )\n        {\n            if (TRUE == g_pCB->IsCmdRespWaited)\n            {\n                _SlDrvSyncObjSignal(&g_pCB->CmdSyncObj);\n                return SL_RET_CODE_OK;\n            }\n        }\n\n    }\n    while (OSI_OK != retCode);\n\n#else\n    _SlDrvObjLockWaitForever(&g_pCB->GlobalLockObj);\n#endif\n\n\n     \n     \n    if(FALSE == (_SL_PENDING_RX_MSG(g_pCB)))\n    {\n        _SlDrvObjUnLock(&g_pCB->GlobalLockObj);\n        \n        return SL_RET_CODE_OK;\n    }\n\n    VERIFY_RET_OK(_SlDrvMsgRead());\n\n    g_pCB->RxDoneCnt++;\n\n    switch(g_pCB->FunctionParams.AsyncExt.RxMsgClass)\n    {\n    case ASYNC_EVT_CLASS:\n         \n         \n        VERIFY_PROTOCOL(NULL != g_pCB->FunctionParams.AsyncExt.pAsyncBuf);\n   \n        _SlAsyncEventGenericHandler();        \n        \n#if (SL_MEMORY_MGMT == SL_MEMORY_MGMT_DYNAMIC)\n        sl_Free(g_pCB->FunctionParams.AsyncExt.pAsyncBuf);\n#else\n        g_pCB->FunctionParams.AsyncExt.pAsyncBuf = NULL;\n#endif\n        break;\n    case DUMMY_MSG_CLASS:\n    case RECV_RESP_CLASS:\n         \n        break;\n    case CMD_RESP_CLASS:\n         \n         \n    default:\n        VERIFY_PROTOCOL(0);\n    }\n\n    _SlDrvObjUnLock(&g_pCB->GlobalLockObj);\n\n    return(SL_RET_CODE_OK);\n}\n\n\n\n \n\n \nconst _SlSpawnEntryFunc_t RxMsgClassLUT[] = {\n    (_SlSpawnEntryFunc_t)_SlDrvDeviceEventHandler,  \n#if defined(sl_WlanEvtHdlr) || defined(EXT_LIB_REGISTERED_WLAN_EVENTS)\n    (_SlSpawnEntryFunc_t)_SlDrvHandleWlanEvents,            \n#else\n    NULL,\n#endif\n#if defined (sl_SockEvtHdlr) || defined(EXT_LIB_REGISTERED_SOCK_EVENTS)\n    (_SlSpawnEntryFunc_t)_SlDrvHandleSockEvents,    \n#else\n    NULL,\n#endif\n\n#if defined(sl_NetAppEvtHdlr) || defined(EXT_LIB_REGISTERED_NETAPP_EVENTS)\n    (_SlSpawnEntryFunc_t)_SlDrvHandleNetAppEvents,  \n#else\n    NULL,  \n#endif\n    NULL,                                           \n    NULL,                                           \n    NULL,\n    NULL\n};\n\n\n \n \n \nvoid _SlDrvClassifyRxMsg(\n    _SlOpcode_t         Opcode)\n{\n    _SlSpawnEntryFunc_t AsyncEvtHandler = NULL;\n    _SlRxMsgClass_e     RxMsgClass  = CMD_RESP_CLASS;\n    _u8               Silo;\n    \n\n\tif (0 == (SL_OPCODE_SYNC & Opcode))\n\t{    \n        \n\t\tif (SL_OPCODE_DEVICE_DEVICEASYNCDUMMY == Opcode)\n\t\t{ \n\t\t    RxMsgClass = DUMMY_MSG_CLASS;\n\t\t}\n\t\telse if ( (SL_OPCODE_SOCKET_RECVASYNCRESPONSE == Opcode) || (SL_OPCODE_SOCKET_RECVFROMASYNCRESPONSE == Opcode) \n#ifndef SL_TINY_EXT                      \n                    || (SL_OPCODE_SOCKET_RECVFROMASYNCRESPONSE_V6 == Opcode) \n#endif                    \n                 ) \n\t\t{\n\t\t\tRxMsgClass = RECV_RESP_CLASS;\n\t\t}\n\t\telse\n\t\t{\n             \n            RxMsgClass = ASYNC_EVT_CLASS;\n        \n\t\t     \n\t\t    Silo = ((Opcode >> SL_OPCODE_SILO_OFFSET) & 0x7);\n\n            VERIFY_PROTOCOL(Silo < (sizeof(RxMsgClassLUT)/sizeof(_SlSpawnEntryFunc_t)));\n\n             \n            AsyncEvtHandler = RxMsgClassLUT[Silo];\n            \n            if ((SL_OPCODE_NETAPP_HTTPGETTOKENVALUE == Opcode) || (SL_OPCODE_NETAPP_HTTPPOSTTOKENVALUE == Opcode))\n            {\n                AsyncEvtHandler = _SlDrvNetAppEventHandler;\n            }\n#ifndef SL_TINY_EXT            \n            else if (SL_OPCODE_NETAPP_PINGREPORTREQUESTRESPONSE == Opcode)\n            {\n                AsyncEvtHandler = (_SlSpawnEntryFunc_t)_sl_HandleAsync_PingResponse;\n            }\n#endif\n\t\t}\n\t}\n\n    g_pCB->FunctionParams.AsyncExt.RxMsgClass = RxMsgClass; \n    g_pCB->FunctionParams.AsyncExt.AsyncEvtHandler = AsyncEvtHandler;\n    \t \n}\n\n\n \n \n \n_SlReturnVal_t   _SlDrvRxHdrRead(_u8 *pBuf, _u8 *pAlignSize)\n{\n     _u32       SyncCnt  = 0;\n    _u8        ShiftIdx;  \n\n#ifndef SL_IF_TYPE_UART\n     \n    NWP_IF_WRITE_CHECK(g_pCB->FD, (_u8 *)&g_H2NCnysPattern.Short, SYNC_PATTERN_LEN);\n#endif\n\n     \n    NWP_IF_READ_CHECK(g_pCB->FD, &pBuf[0], 4);\n    _SL_DBG_SYNC_LOG(SyncCnt,pBuf);\n\n     \n    while ( ! N2H_SYNC_PATTERN_MATCH(pBuf, g_pCB->TxSeqNum) )\n    {\n         \n        VERIFY_PROTOCOL(SyncCnt < SL_SYNC_SCAN_THRESHOLD);\n\n         \n        if(0 == (SyncCnt % (_u32)SYNC_PATTERN_LEN))\n        {\n            NWP_IF_READ_CHECK(g_pCB->FD, &pBuf[4], 4);\n            _SL_DBG_SYNC_LOG(SyncCnt,pBuf);\n        }\n\n         \n        for(ShiftIdx = 0; ShiftIdx< 7; ShiftIdx++)\n        {\n            pBuf[ShiftIdx] = pBuf[ShiftIdx+1];\n        }             \n        pBuf[7] = 0;\n\n        SyncCnt++;\n    }\n\n     \n    SyncCnt %= SYNC_PATTERN_LEN;\n\n    if(SyncCnt > 0)\n    {\n        *(_u32 *)&pBuf[0] = *(_u32 *)&pBuf[4];\n        NWP_IF_READ_CHECK(g_pCB->FD, &pBuf[SYNC_PATTERN_LEN - SyncCnt], (_u16)SyncCnt);\n    }\n    else\n    {\n        NWP_IF_READ_CHECK(g_pCB->FD, &pBuf[0], 4);\n    }\n\n     \n    while ( N2H_SYNC_PATTERN_MATCH(pBuf, g_pCB->TxSeqNum) )\n    {\n        _SL_DBG_CNT_INC(Work.DoubleSyncPattern);\n        NWP_IF_READ_CHECK(g_pCB->FD, &pBuf[0], SYNC_PATTERN_LEN);\n    }\n    g_pCB->TxSeqNum++;\n\n     \n    NWP_IF_READ_CHECK(g_pCB->FD, &pBuf[SYNC_PATTERN_LEN], _SL_RESP_SPEC_HDR_SIZE);\n\n     \n     \n    *pAlignSize = (_u8)((SyncCnt > 0) ? (SYNC_PATTERN_LEN - SyncCnt) : 0);\n\n    return SL_RET_CODE_OK;\n}\n\n \n \n \ntypedef union\n{\n    _BasicResponse_t\tRsp;\n}_SlBasicCmdMsg_u;\n\n\n#ifndef SL_TINY_EXT\n_i16 _SlDrvBasicCmd(_SlOpcode_t Opcode)\n{\n    _SlBasicCmdMsg_u       Msg = {{0, 0}};\n    _SlCmdCtrl_t           CmdCtrl;\n\n    CmdCtrl.Opcode = Opcode;\n    CmdCtrl.TxDescLen = 0;\n    CmdCtrl.RxDescLen = sizeof(_BasicResponse_t);\n\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&CmdCtrl, &Msg, NULL));\n\n    return (_i16)Msg.Rsp.status;\n}\n\n \n_SlReturnVal_t _SlDrvCmdSend(\n    _SlCmdCtrl_t  *pCmdCtrl ,\n    void          *pTxRxDescBuff ,\n    _SlCmdExt_t   *pCmdExt)\n{\n    _SlReturnVal_t RetVal;\n    _u8            IsCmdRespWaitedOriginalVal;\n\n    _SlFunctionParams_t originalFuncParms;\n\n     \n    IsCmdRespWaitedOriginalVal = g_pCB->IsCmdRespWaited;\n\n     \n    sl_Memcpy(&originalFuncParms,  &g_pCB->FunctionParams, sizeof(_SlFunctionParams_t));\n\n    g_pCB->IsCmdRespWaited = FALSE;\n  \n    SL_TRACE0(DBG_MSG, MSG_312, \"_SlDrvCmdSend: call _SlDrvMsgWrite\");\n\n     \n    RetVal = _SlDrvMsgWrite(pCmdCtrl, pCmdExt, pTxRxDescBuff);\n\n     \n    g_pCB->IsCmdRespWaited = IsCmdRespWaitedOriginalVal;\n\n     \n    sl_Memcpy(&g_pCB->FunctionParams, &originalFuncParms, sizeof(_SlFunctionParams_t));\n\n    return RetVal;\n\n\n}\n#endif\n\n \n \n \n_u8 _SlDrvWaitForPoolObj(_u8 ActionID, _u8 SocketID)\n{\n    _u8 CurrObjIndex = MAX_CONCURRENT_ACTIONS;\n\n     \n            _SlDrvProtectionObjLockWaitForever();\n    if (MAX_CONCURRENT_ACTIONS > g_pCB->FreePoolIdx)\n    {\n         \n        CurrObjIndex = g_pCB->FreePoolIdx;\n         \n#ifndef SL_TINY_EXT\n        if (MAX_CONCURRENT_ACTIONS > g_pCB->ObjPool[CurrObjIndex].NextIndex)\n        {\n            g_pCB->FreePoolIdx = g_pCB->ObjPool[CurrObjIndex].NextIndex;\n        }\n        else\n#endif           \n        {\n             \n            g_pCB->FreePoolIdx = MAX_CONCURRENT_ACTIONS;\n        }\n    }\n    else\n    {\n\t\t_SlDrvProtectionObjUnLock();\n        return CurrObjIndex;\n    }\n    g_pCB->ObjPool[CurrObjIndex].ActionID = (_u8)ActionID;\n    if (SL_MAX_SOCKETS > SocketID)\n    {\n        g_pCB->ObjPool[CurrObjIndex].AdditionalData = SocketID;\n    }\n#ifndef SL_TINY_EXT\n     \n\twhile ( ( (SL_MAX_SOCKETS > SocketID) && (g_pCB->ActiveActionsBitmap & (1<<SocketID)) ) || \n            ( (g_pCB->ActiveActionsBitmap & (1<<ActionID)) && (SL_MAX_SOCKETS == SocketID) ) )\n    {\n         \n        g_pCB->ObjPool[CurrObjIndex].NextIndex = g_pCB->PendingPoolIdx;\n        g_pCB->PendingPoolIdx = CurrObjIndex;\n\t\t_SlDrvProtectionObjUnLock();\n        \n         \n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[CurrObjIndex].SyncObj);\n        \n         \n        _SlDrvProtectionObjLockWaitForever();\n    }\n#endif\n     \n    if (SL_MAX_SOCKETS > SocketID)\n    {\n        g_pCB->ActiveActionsBitmap |= (1<<SocketID);\n    }\n    else\n    {\n        g_pCB->ActiveActionsBitmap |= (1<<ActionID);\n    }\n     \n    g_pCB->ObjPool[CurrObjIndex].NextIndex = g_pCB->ActivePoolIdx;\n    g_pCB->ActivePoolIdx = CurrObjIndex;\t\n     \n\t_SlDrvProtectionObjUnLock();\n    return CurrObjIndex;\n}\n\n \n \n \nvoid _SlDrvReleasePoolObj(_u8 ObjIdx)\n{\n#ifndef SL_TINY_EXT        \n    _u8 PendingIndex;\n#endif\n\n     _SlDrvProtectionObjLockWaitForever();\n\n       \n#ifndef SL_TINY_EXT\n     \n\tPendingIndex = g_pCB->PendingPoolIdx;\n        \n\twhile(MAX_CONCURRENT_ACTIONS > PendingIndex)\n\t{\n\t\t \n\t\tif ( (g_pCB->ObjPool[PendingIndex].ActionID == g_pCB->ObjPool[ObjIdx].ActionID) && \n\t\t\t( (SL_MAX_SOCKETS == (g_pCB->ObjPool[PendingIndex].AdditionalData & BSD_SOCKET_ID_MASK)) || \n\t\t\t((SL_MAX_SOCKETS > (g_pCB->ObjPool[ObjIdx].AdditionalData & BSD_SOCKET_ID_MASK)) && ( (g_pCB->ObjPool[PendingIndex].AdditionalData & BSD_SOCKET_ID_MASK) == (g_pCB->ObjPool[ObjIdx].AdditionalData & BSD_SOCKET_ID_MASK) ))) )\n\t\t{\n\t\t\t \n\t\t\t_SlRemoveFromList(&g_pCB->PendingPoolIdx, PendingIndex);\n\t\t\t _SlDrvSyncObjSignal(&g_pCB->ObjPool[PendingIndex].SyncObj);\n\t\t\t break;\n\t\t}\n\t\tPendingIndex = g_pCB->ObjPool[PendingIndex].NextIndex;\n\t}\n#endif\n\n\t\tif (SL_MAX_SOCKETS > (g_pCB->ObjPool[ObjIdx].AdditionalData & BSD_SOCKET_ID_MASK))\n\t\t{\n\t\t \n\t\t\tg_pCB->ActiveActionsBitmap &= ~(1<<(g_pCB->ObjPool[ObjIdx].AdditionalData & BSD_SOCKET_ID_MASK));\n\t\t}\n\t\telse\n\t\t{\n\t\t \n\t\t\tg_pCB->ActiveActionsBitmap &= ~(1<<g_pCB->ObjPool[ObjIdx].ActionID);\n\t\t}\t\n\n     \n    g_pCB->ObjPool[ObjIdx].pRespArgs = NULL;\n    g_pCB->ObjPool[ObjIdx].ActionID = 0;\n    g_pCB->ObjPool[ObjIdx].AdditionalData = SL_MAX_SOCKETS;\n\n     \n    _SlRemoveFromList(&g_pCB->ActivePoolIdx, ObjIdx);\n     \n    g_pCB->ObjPool[ObjIdx].NextIndex = g_pCB->FreePoolIdx;\n    g_pCB->FreePoolIdx = ObjIdx;\n\t_SlDrvProtectionObjUnLock();\n}\n\n\n \n \n \nvoid _SlRemoveFromList(_u8 *ListIndex, _u8 ItemIndex)\n{\n#ifndef SL_TINY_EXT  \n\t_u8 Idx;\n#endif        \n        \n    if (MAX_CONCURRENT_ACTIONS == g_pCB->ObjPool[*ListIndex].NextIndex)\n    {\n        *ListIndex = MAX_CONCURRENT_ACTIONS;\n    }\n     \n#ifndef SL_TINY_EXT\n\t \n\telse if (*ListIndex == ItemIndex)\n\t{\n\t\t*ListIndex = g_pCB->ObjPool[ItemIndex].NextIndex;\n\t}\n\telse\n\t{\n              Idx = *ListIndex;\n      \n              while(MAX_CONCURRENT_ACTIONS > Idx)\n              {\n                   \n                  if (g_pCB->ObjPool[Idx].NextIndex == ItemIndex)\n                  {\n                          g_pCB->ObjPool[Idx].NextIndex = g_pCB->ObjPool[ItemIndex].NextIndex;\n                          break;\n                  }\n\n                  Idx = g_pCB->ObjPool[Idx].NextIndex;\n              }\n\t}\n#endif    \n}\n\n\n \n \n \n_SlReturnVal_t _SlFindAndSetActiveObj(_SlOpcode_t  Opcode, _u8 Sd)\n{\n    _u8 ActiveIndex;\n\n    ActiveIndex = g_pCB->ActivePoolIdx;\n     \n#ifndef SL_TINY_EXT    \n\t\twhile (MAX_CONCURRENT_ACTIONS > ActiveIndex)\n#else\n         \n        if (MAX_CONCURRENT_ACTIONS > ActiveIndex)\n#endif\n    {\n         \n        if (g_pCB->ObjPool[ActiveIndex].AdditionalData & SL_NETAPP_FAMILY_MASK)\n        {\n            Opcode &= ~SL_OPCODE_IPV6;\n        }\n\n        if ((g_pCB->ObjPool[ActiveIndex].ActionID == RECV_ID) && (Sd == g_pCB->ObjPool[ActiveIndex].AdditionalData) && \n\t\t\t\t\t\t( (SL_OPCODE_SOCKET_RECVASYNCRESPONSE == Opcode) || (SL_OPCODE_SOCKET_RECVFROMASYNCRESPONSE == Opcode)\n#ifndef SL_TINY_EXT\n                        || (SL_OPCODE_SOCKET_RECVFROMASYNCRESPONSE_V6 == Opcode) \n#endif\n                          ) \n\n               )\n        {\n            g_pCB->FunctionParams.AsyncExt.ActionIndex = ActiveIndex;\n            return SL_RET_CODE_OK;\n        }\n         \n        if ( (_SlActionLookupTable[ g_pCB->ObjPool[ActiveIndex].ActionID - MAX_SOCKET_ENUM_IDX].ActionAsyncOpcode == Opcode) && \n            ( ((Sd == (g_pCB->ObjPool[ActiveIndex].AdditionalData & BSD_SOCKET_ID_MASK) ) && (SL_MAX_SOCKETS > Sd)) || (SL_MAX_SOCKETS == (g_pCB->ObjPool[ActiveIndex].AdditionalData & BSD_SOCKET_ID_MASK)) ) )\n        {\n             \n            g_pCB->FunctionParams.AsyncExt.AsyncEvtHandler = _SlActionLookupTable[ g_pCB->ObjPool[ActiveIndex].ActionID - MAX_SOCKET_ENUM_IDX].AsyncEventHandler;\n            g_pCB->FunctionParams.AsyncExt.ActionIndex = ActiveIndex;\n            return SL_RET_CODE_OK;\n        }\n        ActiveIndex = g_pCB->ObjPool[ActiveIndex].NextIndex;\n    }\n\n    return SL_RET_CODE_SELF_ERROR;\n\n \n\n}\n\n\n \n\nvoid  _SlDrvSyncObjWaitForever(_SlSyncObj_t *pSyncObj)\n{\n    OSI_RET_OK_CHECK(sl_SyncObjWait(pSyncObj, SL_OS_WAIT_FOREVER));\n}\n\nvoid  _SlDrvSyncObjSignal(_SlSyncObj_t *pSyncObj)\n{\n    OSI_RET_OK_CHECK(sl_SyncObjSignal(pSyncObj));\n}\n\nvoid _SlDrvObjLockWaitForever(_SlLockObj_t *pLockObj)\n{\n    OSI_RET_OK_CHECK(sl_LockObjLock(pLockObj, SL_OS_WAIT_FOREVER));\n}\n\nvoid _SlDrvProtectionObjLockWaitForever()\n{\n    OSI_RET_OK_CHECK(sl_LockObjLock(&g_pCB->ProtectionLockObj, SL_OS_WAIT_FOREVER));\n\n}\n\nvoid _SlDrvObjUnLock(_SlLockObj_t *pLockObj)\n{\n    OSI_RET_OK_CHECK(sl_LockObjUnlock(pLockObj));\n\n}\n\nvoid _SlDrvProtectionObjUnLock()\n{\n    OSI_RET_OK_CHECK(sl_LockObjUnlock(&g_pCB->ProtectionLockObj));\n}\n\n\nvoid _SlDrvMemZero(void* Addr, _u16 size)\n{\n    sl_Memset(Addr, 0, size);\n}\n\n\nvoid _SlDrvResetCmdExt(_SlCmdExt_t* pCmdExt)\n{\n    _SlDrvMemZero(pCmdExt, sizeof (_SlCmdExt_t));\n}\n\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}