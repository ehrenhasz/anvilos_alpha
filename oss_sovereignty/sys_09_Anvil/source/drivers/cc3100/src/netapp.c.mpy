{
  "module_name": "netapp.c",
  "hash_id": "dc203e3ca50db632f974e3416a294c25e0b76c4b44c4c018cd55241af3595485",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/src/netapp.c",
  "human_readable_source": " \n    \n\n\n \n \n \n#include \"simplelink.h\"\n#include \"protocol.h\"\n#include \"driver.h\"\n\n \n \n \n#define NETAPP_MDNS_OPTIONS_ADD_SERVICE_BIT\t\t\t\t\t ((_u32)0x1 << 31)\n\n#ifdef SL_TINY\n#define NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH         63\n#else\n#define NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH         255\n#endif\n\n\n \n \n \nvoid _sl_HandleAsync_DnsGetHostByName(void *pVoidBuf);\n\n#ifndef SL_TINY_EXT\nvoid _sl_HandleAsync_DnsGetHostByService(void *pVoidBuf);\nvoid _sl_HandleAsync_PingResponse(void *pVoidBuf);\n#endif\n\nvoid CopyPingResultsToReport(_PingReportResponse_t *pResults,SlPingReport_t *pReport);\n_i16 sl_NetAppMDNSRegisterUnregisterService(const _i8* \t\tpServiceName, \n\t\t\t\t\t\t\t\t\t\t\tconst _u8   ServiceNameLen,\n\t\t\t\t\t\t\t\t\t\t\tconst _i8* \t\tpText,\n\t\t\t\t\t\t\t\t\t\t\tconst _u8   TextLen,\n\t\t\t\t\t\t\t\t\t\t\tconst _u16  Port,\n\t\t\t\t\t\t\t\t\t\t\tconst _u32    TTL,\n\t\t\t\t\t\t\t\t\t\t\tconst _u32    Options);\n\n#if defined(sl_HttpServerCallback) || defined(EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)\n_u16 _sl_NetAppSendTokenValue(slHttpServerData_t * Token);\n#endif\ntypedef union\n{\n\t_NetAppStartStopCommand_t       Cmd;\n\t_NetAppStartStopResponse_t   Rsp;\n}_SlNetAppStartStopMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppStart)\n\nconst _SlCmdCtrl_t _SlNetAppStartCtrl =\n{\n    SL_OPCODE_NETAPP_START_COMMAND,\n    sizeof(_NetAppStartStopCommand_t),\n    sizeof(_NetAppStartStopResponse_t)\n};\n\n_i16 sl_NetAppStart(const _u32 AppBitMap)\n{\n    _SlNetAppStartStopMsg_u Msg;\n    Msg.Cmd.appId = AppBitMap;\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlNetAppStartCtrl, &Msg, NULL));\n\n    return Msg.Rsp.status;\n}\n#endif\n\n \n#if _SL_INCLUDE_FUNC(sl_NetAppStop)\n\n\nconst _SlCmdCtrl_t _SlNetAppStopCtrl =\n{\n    SL_OPCODE_NETAPP_STOP_COMMAND,\n    sizeof(_NetAppStartStopCommand_t),\n    sizeof(_NetAppStartStopResponse_t)\n};\n\n\n\n_i16 sl_NetAppStop(const _u32 AppBitMap)\n{\n    _SlNetAppStartStopMsg_u Msg;\n    Msg.Cmd.appId = AppBitMap;\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlNetAppStopCtrl, &Msg, NULL));\n\n    return Msg.Rsp.status;\n}\n#endif\n\n\n \n \n \ntypedef struct\n{\n    _u8  IndexOffest;\n    _u8  MaxServiceCount;\n    _u8  Flags;\n    _i8  Padding;\n}NetappGetServiceListCMD_t;\n\ntypedef union\n{\n\t NetappGetServiceListCMD_t      Cmd;\n\t_BasicResponse_t                Rsp;\n}_SlNetappGetServiceListMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppGetServiceList)\n\nconst _SlCmdCtrl_t _SlGetServiceListeCtrl =\n{\n    SL_OPCODE_NETAPP_NETAPP_MDNS_LOOKUP_SERVICE,\n    sizeof(NetappGetServiceListCMD_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i16 sl_NetAppGetServiceList(const _u8  IndexOffest,\n\t\t\t\t\t\t     const _u8  MaxServiceCount,\n\t\t\t\t\t\t\t const _u8  Flags,\n\t\t\t\t\t\t           _i8  *pBuffer,\n\t\t\t\t\t\t\t const _u32  RxBufferLength\n\t\t\t\t\t\t\t)\n{\n\n    _i32 \t\t\t\t\t retVal= 0;\n    _SlNetappGetServiceListMsg_u Msg;\n    _SlCmdExt_t                  CmdExt;\n\t_u16               ServiceSize = 0;\n\t_u16               BufferSize = 0;\n\n\t \n    switch(Flags)\n    {\n        case SL_NET_APP_FULL_SERVICE_WITH_TEXT_IPV4_TYPE:\n            ServiceSize =  sizeof(SlNetAppGetFullServiceWithTextIpv4List_t);\n            break;\n\n        case SL_NET_APP_FULL_SERVICE_IPV4_TYPE:\n            ServiceSize =  sizeof(SlNetAppGetFullServiceIpv4List_t);\n            break;\n\n        case SL_NET_APP_SHORT_SERVICE_IPV4_TYPE:\n            ServiceSize =  sizeof(SlNetAppGetShortServiceIpv4List_t);\n            break;\n\n        default:\n\t\t\tServiceSize =  sizeof(_BasicResponse_t);\n\t\t\tbreak;\n    }\n\n\n\n\tBufferSize =  MaxServiceCount * ServiceSize;\n\n\t \n\tif(RxBufferLength <= BufferSize)\n\t{\n\t\treturn SL_ERROR_NETAPP_RX_BUFFER_LENGTH_ERROR;\n\t}\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = BufferSize;\n    CmdExt.pRxPayload = (_u8 *)pBuffer; \n\n    Msg.Cmd.IndexOffest\t\t= IndexOffest;\n    Msg.Cmd.MaxServiceCount = MaxServiceCount;\n    Msg.Cmd.Flags\t\t\t= Flags;\n    Msg.Cmd.Padding\t\t\t= 0;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlGetServiceListeCtrl, &Msg, &CmdExt));\n    retVal = Msg.Rsp.status;\n\n    return (_i16)retVal;\n}\n\n#endif\n\n \n \n \n \n\n\ntypedef struct\n{\n    _u8   ServiceNameLen;\n    _u8   TextLen;\n    _u16  Port;\n    _u32   TTL;\n    _u32   Options;\n}NetappMdnsSetService_t;\n\ntypedef union\n{\n\t NetappMdnsSetService_t         Cmd;\n\t_BasicResponse_t                Rsp;\n}_SlNetappMdnsRegisterServiceMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppMDNSRegisterUnregisterService)\n\nconst _SlCmdCtrl_t _SlRegisterServiceCtrl =\n{\n    SL_OPCODE_NETAPP_MDNSREGISTERSERVICE,\n    sizeof(NetappMdnsSetService_t),\n    sizeof(_BasicResponse_t)\n};\n\n \n_i16 sl_NetAppMDNSRegisterUnregisterService(\tconst _i8* \t\tpServiceName, \n\t\t\t\t\t\t\t\t\t\t\tconst _u8   ServiceNameLen,\n\t\t\t\t\t\t\t\t\t\t\tconst _i8* \t\tpText,\n\t\t\t\t\t\t\t\t\t\t\tconst _u8   TextLen,\n\t\t\t\t\t\t\t\t\t\t\tconst _u16  Port,\n\t\t\t\t\t\t\t\t\t\t\tconst _u32   TTL,\n\t\t\t\t\t\t\t\t\t\t\tconst _u32   Options)\n\n{\n    _SlNetappMdnsRegisterServiceMsg_u\t\t\tMsg;\n    _SlCmdExt_t\t\t\t\t\t\t\t\t\tCmdExt ;\n _i8 \t\t\t\t\t\t\t\t\tServiceNameAndTextBuffer[NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH];\n _i8 \t\t\t\t\t\t\t\t\t*TextPtr;\n\n\t \n\n\t \n\n\tMsg.Cmd.ServiceNameLen\t= ServiceNameLen;\n\tMsg.Cmd.Options\t\t\t= Options;\n\tMsg.Cmd.Port\t\t\t= Port;\n\tMsg.Cmd.TextLen\t\t\t= TextLen;\n\tMsg.Cmd.TTL\t\t\t\t= TTL;\n\n\t \n\tif(TextLen + ServiceNameLen > (NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH - 1 ))  \n\t{\n\t\treturn -1;\n\t}\n\n    _SlDrvMemZero(ServiceNameAndTextBuffer, NETAPP_MDNS_MAX_SERVICE_NAME_AND_TEXT_LENGTH);\n\n\t\n\t \n\tsl_Memcpy(ServiceNameAndTextBuffer,\n\t\t      pServiceName,   \n\t\t\t  ServiceNameLen);\n\n\tif(TextLen > 0 )\n\t{\n\t\t\n\t\tTextPtr = &ServiceNameAndTextBuffer[ServiceNameLen];\n\t\t \n\t\tsl_Memcpy(TextPtr,\n\t\t\t\t  pText,   \n\t\t\t\t  TextLen);\n\n  \n\t}\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.TxPayloadLen = (TextLen + ServiceNameLen);\n    CmdExt.pTxPayload   = (_u8 *)ServiceNameAndTextBuffer;\n\n\t\n\tVERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlRegisterServiceCtrl, &Msg, &CmdExt));\n\n\treturn (_i16)Msg.Rsp.status;\n\n\t\n}\n#endif\n\n \n#if _SL_INCLUDE_FUNC(sl_NetAppMDNSRegisterService)\n\n_i16 sl_NetAppMDNSRegisterService(\tconst _i8* \t\tpServiceName, \n\t\t\t\t\t\t\t\t\tconst _u8   ServiceNameLen,\n\t\t\t\t\t\t\t\t\tconst _i8* \t\tpText,\n\t\t\t\t\t\t\t\t\tconst _u8   TextLen,\n\t\t\t\t\t\t\t\t\tconst _u16  Port,\n\t\t\t\t\t\t\t\t\tconst _u32    TTL,\n\t\t\t\t\t\t\t\t\t     _u32    Options)\n\n{\n\n\t \n\n\t \n\tOptions |=  NETAPP_MDNS_OPTIONS_ADD_SERVICE_BIT;\n\n    return  sl_NetAppMDNSRegisterUnregisterService(\tpServiceName, \n\t\t\t\t\t\t\t\t\t\t\t        ServiceNameLen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpText,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTextLen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tPort,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTTL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOptions);\n\n\t\n}\n#endif\n \n\n\n\n \n#if _SL_INCLUDE_FUNC(sl_NetAppMDNSUnRegisterService)\n\n_i16 sl_NetAppMDNSUnRegisterService(\tconst _i8* \t\tpServiceName, \n\t\t\t\t\t\t\t\t\tconst _u8   ServiceNameLen)\n\n\n{\n    _u32    Options = 0;\n\n\t \n\n\t \n\t\n\tOptions &=  (~NETAPP_MDNS_OPTIONS_ADD_SERVICE_BIT);\n\n    return  sl_NetAppMDNSRegisterUnregisterService(\tpServiceName, \n\t\t\t\t\t\t\t\t\t\t\t        ServiceNameLen,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tOptions);\n\n\t\n}\n#endif\n \n\n\n\n \n \n \n \n\ntypedef struct \n{\n\t _u8   ServiceLen;\n\t _u8   AddrLen;\n\t _u16  Padding;\n}_GetHostByServiceCommand_t;\n\n\n\n \ntypedef struct \n{\n\t_u16   Status;\n\t_u16   TextLen;\n\t_u32    Port;\n\t_u32    Address;\n}_GetHostByServiceIPv4AsyncResponse_t;\n\n\ntypedef struct \n{\n\t_u16   Status;\n\t_u16   TextLen;\n\t_u32    Port;\n\t_u32    Address[4];\n}_GetHostByServiceIPv6AsyncResponse_t;\n\n\ntypedef union\n{\n    _GetHostByServiceIPv4AsyncResponse_t IpV4;\n    _GetHostByServiceIPv6AsyncResponse_t IpV6;\n}_GetHostByServiceAsyncResponseAttribute_u;\n\n \ntypedef struct\n{\n    _i16           Status;\n\t_u32   *out_pAddr;\n\t_u32   *out_pPort;\n\t_u16   *inout_TextLen;  \n _i8            *out_pText;\n}_GetHostByServiceAsyncResponse_t;\n\n\ntypedef union\n{\n\t_GetHostByServiceCommand_t      Cmd;\n\t_BasicResponse_t                Rsp;\n}_SlGetHostByServiceMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppDnsGetHostByService)\n\nconst _SlCmdCtrl_t _SlGetHostByServiceCtrl =\n{\n    SL_OPCODE_NETAPP_MDNSGETHOSTBYSERVICE,\n    sizeof(_GetHostByServiceCommand_t),\n    sizeof(_BasicResponse_t)\n};\n\n \n\n_i32 sl_NetAppDnsGetHostByService(_i8 \t\t*pServiceName,\t \n\t\t\t\t\t\t\t\t  const _u8  ServiceLen,\n\t\t\t\t\t\t\t\t  const _u8  Family,\t\t\t \n\t\t\t\t\t\t\t\t  _u32  pAddr[], \n\t\t\t\t\t\t\t\t  _u32  *pPort,\n\t\t\t\t\t\t\t\t  _u16 *pTextLen,  \n\t\t\t\t\t\t\t\t  _i8          *pText\n\t\t\t\t\t\t         )\n{\n    _SlGetHostByServiceMsg_u         Msg;\n    _SlCmdExt_t                      CmdExt ;\n    _GetHostByServiceAsyncResponse_t AsyncRsp;\n\t_u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n\n \n\t \n\n\tMsg.Cmd.ServiceLen = ServiceLen;\n\tMsg.Cmd.AddrLen    = Family;\n\n\t \n\n    _SlDrvResetCmdExt(&CmdExt);\n\tCmdExt.TxPayloadLen = ServiceLen;\n    CmdExt.pTxPayload   = (_u8 *)pServiceName;\n\n\t \n\tAsyncRsp.out_pText     = pText;\n\tAsyncRsp.inout_TextLen = (_u16* )pTextLen;\n\tAsyncRsp.out_pPort     = pPort;\n\tAsyncRsp.out_pAddr     = (_u32 *)pAddr;\n\n\n    ObjIdx = _SlDrvProtectAsyncRespSetting((_u8*)&AsyncRsp, GETHOSYBYSERVICE_ID, SL_MAX_SOCKETS);\n\n    if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n    {\n        return SL_POOL_IS_EMPTY;\n    }\n\n    \n\tif (SL_AF_INET6 == Family)  \n\t{\n\t\tg_pCB->ObjPool[ObjIdx].AdditionalData |= SL_NETAPP_FAMILY_MASK;\n\t}\n     \n\tVERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlGetHostByServiceCtrl, &Msg, &CmdExt));\n\n \n\t \n     \n\tif(SL_RET_CODE_OK == Msg.Rsp.status)\n    {        \n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n        \n\t\t \n\t\t\n\t\tMsg.Rsp.status = AsyncRsp.Status;\n    }\n\n    _SlDrvReleasePoolObj(ObjIdx);\n    return Msg.Rsp.status;\n}\n#endif\n\n \n\n \n#ifndef SL_TINY_EXT\nvoid _sl_HandleAsync_DnsGetHostByService(void *pVoidBuf)\n{\n\n\t_GetHostByServiceAsyncResponse_t* Res;\n\t_u16 \t\t\t\t  TextLen;\n\t_u16 \t\t\t\t  UserTextLen;\n\n\n\t \n    \n\t \n\t_GetHostByServiceIPv4AsyncResponse_t   *pMsgArgs   = (_GetHostByServiceIPv4AsyncResponse_t *)_SL_RESP_ARGS_START(pVoidBuf);\n\n    VERIFY_SOCKET_CB(NULL != g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs);\n\n\t \n\tif(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].AdditionalData & SL_NETAPP_FAMILY_MASK)\n\t{\n\t\treturn;\n\t}\n\t \n\telse\n\t{\n     \n\tTextLen = pMsgArgs->TextLen;\n\t\n\t \n\t\tRes = (_GetHostByServiceAsyncResponse_t*)g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs;\n\n\n\n\t \n\tRes->out_pAddr[0]\t= pMsgArgs->Address;\n\tRes->out_pPort[0]\t= pMsgArgs->Port;\n\tRes->Status\t\t\t= pMsgArgs->Status;\n\t\n\t \n\tUserTextLen\t\t\t= Res->inout_TextLen[0];\n    \n\t \n\tUserTextLen = (TextLen <= UserTextLen) ? TextLen : UserTextLen;\n\tRes->inout_TextLen[0] = UserTextLen ;\n\n     \n\t\n\n\tsl_Memcpy(Res->out_pText          ,\n\t\t     (_i8 *)(& pMsgArgs[1])  ,    \n\t\t\t UserTextLen              );\n\n\n     \n\n\t\t_SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n\t\treturn;\n\t}\n}\n\n \n \n \nvoid _sl_HandleAsync_DnsGetHostByAddr(void *pVoidBuf)\n{\n    SL_TRACE0(DBG_MSG, MSG_303, \"STUB: _sl_HandleAsync_DnsGetHostByAddr not implemented yet!\");\n    return;\n}\n#endif\n\n \n \n \ntypedef union\n{\n    _GetHostByNameIPv4AsyncResponse_t IpV4;\n    _GetHostByNameIPv6AsyncResponse_t IpV6;\n}_GetHostByNameAsyncResponse_u;\n\ntypedef union\n{\n\t_GetHostByNameCommand_t         Cmd;\n\t_BasicResponse_t                Rsp;\n}_SlGetHostByNameMsg_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppDnsGetHostByName)\nconst _SlCmdCtrl_t _SlGetHostByNameCtrl =\n{\n    SL_OPCODE_NETAPP_DNSGETHOSTBYNAME,\n    sizeof(_GetHostByNameCommand_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i16 sl_NetAppDnsGetHostByName(_i8 * hostname,const  _u16 usNameLen, _u32*  out_ip_addr,const _u8 family)\n{\n    _SlGetHostByNameMsg_u           Msg;\n    _SlCmdExt_t                     ExtCtrl;\n    _GetHostByNameAsyncResponse_u   AsyncRsp;\n\t_u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n\n\n    _SlDrvResetCmdExt(&ExtCtrl);\n    ExtCtrl.TxPayloadLen = usNameLen;\n    ExtCtrl.pTxPayload = (_u8 *)hostname;\n\n    Msg.Cmd.Len = usNameLen;\n    Msg.Cmd.family = family;\n\n\t \n\tObjIdx = (_u8)_SlDrvWaitForPoolObj(GETHOSYBYNAME_ID,SL_MAX_SOCKETS);\n\tif (MAX_CONCURRENT_ACTIONS == ObjIdx)\n\t{\n\t\treturn SL_POOL_IS_EMPTY;\n\t}\n\n    _SlDrvProtectionObjLockWaitForever();\n\n\tg_pCB->ObjPool[ObjIdx].pRespArgs =  (_u8 *)&AsyncRsp;\n\t \n\tif (SL_AF_INET6 == family)\n\t{\n\t\tg_pCB->ObjPool[ObjIdx].AdditionalData |= SL_NETAPP_FAMILY_MASK;\n\t}\n\t\n    _SlDrvProtectionObjUnLock();\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlGetHostByNameCtrl, &Msg, &ExtCtrl));\n\n    if(SL_RET_CODE_OK == Msg.Rsp.status)\n    {\n        _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n        \n        Msg.Rsp.status = AsyncRsp.IpV4.status;\n\n        if(SL_OS_RET_CODE_OK == (_i16)Msg.Rsp.status)\n        {\n            sl_Memcpy((_i8 *)out_ip_addr,\n                      (_i8 *)&AsyncRsp.IpV4.ip0, \n                      (SL_AF_INET == family) ? SL_IPV4_ADDRESS_SIZE : SL_IPV6_ADDRESS_SIZE);\n        }\n    }\n    _SlDrvReleasePoolObj(ObjIdx);\n    return Msg.Rsp.status;\n}\n#endif\n\n\n \n \n \nvoid _sl_HandleAsync_DnsGetHostByName(void *pVoidBuf)\n{\n    _GetHostByNameIPv4AsyncResponse_t     *pMsgArgs   = (_GetHostByNameIPv4AsyncResponse_t *)_SL_RESP_ARGS_START(pVoidBuf);\n\n   _SlDrvProtectionObjLockWaitForever();\n\n    VERIFY_SOCKET_CB(NULL != g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs);\n\n\t \n\tif(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].AdditionalData & SL_NETAPP_FAMILY_MASK)\n\t{\n\t\tsl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs, sizeof(_GetHostByNameIPv6AsyncResponse_t));\n\t}\n\t \n\telse\n\t{\n\t\tsl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs, sizeof(_GetHostByNameIPv4AsyncResponse_t));\n\t}\n\t_SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n    _SlDrvProtectionObjUnLock();\n    return;\n}\n\n\n#ifndef SL_TINY_EXT\nvoid CopyPingResultsToReport(_PingReportResponse_t *pResults,SlPingReport_t *pReport)\n{\n    pReport->PacketsSent     = pResults->numSendsPings;\n    pReport->PacketsReceived = pResults->numSuccsessPings;\n    pReport->MinRoundTime    = pResults->rttMin;\n    pReport->MaxRoundTime    = pResults->rttMax;\n    pReport->AvgRoundTime    = pResults->rttAvg;\n    pReport->TestTime        = pResults->testTime;\n}\n\n \n \n \nvoid _sl_HandleAsync_PingResponse(void *pVoidBuf)\n{\n    _PingReportResponse_t     *pMsgArgs   = (_PingReportResponse_t *)_SL_RESP_ARGS_START(pVoidBuf);\n    SlPingReport_t            pingReport;\n    \n    if(pPingCallBackFunc)\n    {\n        CopyPingResultsToReport(pMsgArgs,&pingReport);\n        pPingCallBackFunc(&pingReport);\n    }\n    else\n    {\n       \n        _SlDrvProtectionObjLockWaitForever();\n        \n        VERIFY_SOCKET_CB(NULL != g_pCB->PingCB.PingAsync.pAsyncRsp);\n\n\t\tif (NULL != g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs)\n\t\t{\n\t\t   sl_Memcpy(g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].pRespArgs, pMsgArgs, sizeof(_PingReportResponse_t));\n\t\t   _SlDrvSyncObjSignal(&g_pCB->ObjPool[g_pCB->FunctionParams.AsyncExt.ActionIndex].SyncObj);\n\t\t}\n       _SlDrvProtectionObjUnLock();\n    }\n    return;\n}\n#endif\n\n \n \n \ntypedef union\n{\n\t_PingStartCommand_t   Cmd;\n\t_PingReportResponse_t  Rsp;\n}_SlPingStartMsg_u;\n\n\ntypedef enum\n{\n  CMD_PING_TEST_RUNNING = 0,\n  CMD_PING_TEST_STOPPED\n}_SlPingStatus_e;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppPingStart)\n_i16 sl_NetAppPingStart(const SlPingStartCommand_t* pPingParams,const _u8 family,SlPingReport_t *pReport,const P_SL_DEV_PING_CALLBACK pPingCallback)\n{\n    _SlCmdCtrl_t                CmdCtrl = {0, sizeof(_PingStartCommand_t), sizeof(_BasicResponse_t)};\n    _SlPingStartMsg_u           Msg;\n    _PingReportResponse_t       PingRsp;\n    _u8 ObjIdx = MAX_CONCURRENT_ACTIONS;\n\n    if( 0 == pPingParams->Ip ) \n    { \n       return _SlDrvBasicCmd(SL_OPCODE_NETAPP_PINGSTOP); \n    }\n\n    if(SL_AF_INET == family)\n    {\n        CmdCtrl.Opcode = SL_OPCODE_NETAPP_PINGSTART;\n        sl_Memcpy(&Msg.Cmd.ip0, &pPingParams->Ip, SL_IPV4_ADDRESS_SIZE);\n    }\n    else\n    {\n        CmdCtrl.Opcode = SL_OPCODE_NETAPP_PINGSTART_V6;\n        sl_Memcpy(&Msg.Cmd.ip0, &pPingParams->Ip, SL_IPV6_ADDRESS_SIZE);\n    }\n\n    Msg.Cmd.pingIntervalTime        = pPingParams->PingIntervalTime;\n    Msg.Cmd.PingSize                = pPingParams->PingSize;\n    Msg.Cmd.pingRequestTimeout      = pPingParams->PingRequestTimeout;\n    Msg.Cmd.totalNumberOfAttempts   = pPingParams->TotalNumberOfAttempts;\n    Msg.Cmd.flags                   = pPingParams->Flags;\n\n    \n    if( pPingCallback )\n    {\t\n       pPingCallBackFunc = pPingCallback;\n    }\n    else\n    {\n        \n\t   ObjIdx = (_u8)_SlDrvWaitForPoolObj(PING_ID,SL_MAX_SOCKETS);\n\t   if (MAX_CONCURRENT_ACTIONS == ObjIdx)\n\t   {\n\t\t  return SL_POOL_IS_EMPTY;\n\t   }\n       OSI_RET_OK_CHECK(sl_LockObjLock(&g_pCB->ProtectionLockObj, SL_OS_WAIT_FOREVER));\n         \n       g_pCB->ObjPool[ObjIdx].pRespArgs = (_u8 *)&PingRsp;\n       pPingCallBackFunc = NULL;\n       OSI_RET_OK_CHECK(sl_LockObjUnlock(&g_pCB->ProtectionLockObj));\n    }\n\n    \n    VERIFY_RET_OK(_SlDrvCmdOp(&CmdCtrl, &Msg, NULL));\n\t \n    if(CMD_PING_TEST_RUNNING == (_i16)Msg.Rsp.status || CMD_PING_TEST_STOPPED == (_i16)Msg.Rsp.status )\n    {\n         \n        if( NULL == pPingCallback )\n        {\n            _SlDrvSyncObjWaitForever(&g_pCB->ObjPool[ObjIdx].SyncObj);\n\n            if( SL_OS_RET_CODE_OK == (_i16)PingRsp.status )\n            {\n                CopyPingResultsToReport(&PingRsp,pReport);\n            }\n            _SlDrvReleasePoolObj(ObjIdx);\n        }\n    }\n    else\n    {    \n        if( NULL == pPingCallback ) \n        {\t\n            _SlDrvReleasePoolObj(ObjIdx);\n        }\n    }\n\n    return Msg.Rsp.status;\n}\n#endif\n\n \n \n \ntypedef union\n{\n    _NetAppSetGet_t    Cmd;\n    _BasicResponse_t   Rsp;\n}_SlNetAppMsgSet_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppSet)\n\nconst _SlCmdCtrl_t _SlNetAppSetCmdCtrl =\n{\n    SL_OPCODE_NETAPP_NETAPPSET,\n    sizeof(_NetAppSetGet_t),\n    sizeof(_BasicResponse_t)\n};\n\n_i32 sl_NetAppSet(const _u8 AppId ,const _u8 Option,const _u8 OptionLen,const  _u8 *pOptionValue)\n{\n    _SlNetAppMsgSet_u         Msg;\n    _SlCmdExt_t               CmdExt;\n\n\n    _SlDrvResetCmdExt(&CmdExt);\n\tCmdExt.TxPayloadLen = (OptionLen+3) & (~3);\n    CmdExt.pTxPayload = (_u8 *)pOptionValue;\n\n\n    Msg.Cmd.AppId    = AppId;\n    Msg.Cmd.ConfigLen   = OptionLen;\n\tMsg.Cmd.ConfigOpt   = Option;\n\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlNetAppSetCmdCtrl, &Msg, &CmdExt));\n\n    return (_i16)Msg.Rsp.status;\n}\n#endif\n\n \n \n \ntypedef union\n{\n    sl_NetAppHttpServerSendToken_t    Cmd;\n    _BasicResponse_t   Rsp;\n}_SlNetAppMsgSendTokenValue_u;\n\n\n\n#if defined(sl_HttpServerCallback) || defined(EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)\nconst _SlCmdCtrl_t _SlNetAppSendTokenValueCmdCtrl =\n{\n    SL_OPCODE_NETAPP_HTTPSENDTOKENVALUE,\n    sizeof(sl_NetAppHttpServerSendToken_t),\n    sizeof(_BasicResponse_t)\n};\n\n_u16 _sl_NetAppSendTokenValue(slHttpServerData_t * Token_value)\n{\n\t_SlNetAppMsgSendTokenValue_u    Msg;\n    _SlCmdExt_t\t\t\t\t\t\tCmdExt;\n\n\tCmdExt.TxPayloadLen = (Token_value->value_len+3) & (~3);\n    CmdExt.RxPayloadLen = 0;\n\tCmdExt.pTxPayload = (_u8 *) Token_value->token_value;\n    CmdExt.pRxPayload = NULL;\n\n\tMsg.Cmd.token_value_len = Token_value->value_len;\n\tMsg.Cmd.token_name_len = Token_value->name_len;\n\tsl_Memcpy(&Msg.Cmd.token_name[0], Token_value->token_name, Token_value->name_len);\n\t\n\n\tVERIFY_RET_OK(_SlDrvCmdSend((_SlCmdCtrl_t *)&_SlNetAppSendTokenValueCmdCtrl, &Msg, &CmdExt));\n\n\treturn Msg.Rsp.status;\n}\n#endif\n\n\n \n \n \ntypedef union\n{\n\t_NetAppSetGet_t\t    Cmd;\n\t_NetAppSetGet_t\t    Rsp;\n}_SlNetAppMsgGet_u;\n\n\n#if _SL_INCLUDE_FUNC(sl_NetAppGet)\nconst _SlCmdCtrl_t _SlNetAppGetCmdCtrl =\n{\n    SL_OPCODE_NETAPP_NETAPPGET,\n    sizeof(_NetAppSetGet_t),\n    sizeof(_NetAppSetGet_t)\n};\n\n_i32 sl_NetAppGet(const _u8 AppId,const  _u8 Option,_u8 *pOptionLen, _u8 *pOptionValue)\n{\n    _SlNetAppMsgGet_u         Msg;\n    _SlCmdExt_t               CmdExt;\n\n       if (*pOptionLen == 0)\n       {\n              return SL_EZEROLEN;\n       }\n\n    _SlDrvResetCmdExt(&CmdExt);\n    CmdExt.RxPayloadLen = *pOptionLen;\n    CmdExt.pRxPayload = (_u8 *)pOptionValue;\n\n    Msg.Cmd.AppId    = AppId;\n    Msg.Cmd.ConfigOpt   = Option;\n    VERIFY_RET_OK(_SlDrvCmdOp((_SlCmdCtrl_t *)&_SlNetAppGetCmdCtrl, &Msg, &CmdExt));\n    \n\n       if (CmdExt.RxPayloadLen < CmdExt.ActualRxPayloadLen) \n       {\n              *pOptionLen = (_u8)CmdExt.RxPayloadLen;\n              return SL_ESMALLBUF;\n       }\n       else\n       {\n              *pOptionLen = (_u8)CmdExt.ActualRxPayloadLen;\n       }\n  \n    return (_i16)Msg.Rsp.Status;\n}\n#endif\n\n\n \n \n \nvoid _SlDrvNetAppEventHandler(void* pArgs)\n{\n    _SlResponseHeader_t     *pHdr       = (_SlResponseHeader_t *)pArgs;\n#if defined(sl_HttpServerCallback) || defined(EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)\n    SlHttpServerEvent_t\t\thttpServerEvent;\n    SlHttpServerResponse_t\thttpServerResponse;\n#endif\n    \n    switch(pHdr->GenHeader.Opcode)\n    {\n        case SL_OPCODE_NETAPP_DNSGETHOSTBYNAMEASYNCRESPONSE:\n        case SL_OPCODE_NETAPP_DNSGETHOSTBYNAMEASYNCRESPONSE_V6:\n            _sl_HandleAsync_DnsGetHostByName(pArgs);\n            break;\n#ifndef SL_TINY_EXT            \n        case SL_OPCODE_NETAPP_MDNSGETHOSTBYSERVICEASYNCRESPONSE:\n        case SL_OPCODE_NETAPP_MDNSGETHOSTBYSERVICEASYNCRESPONSE_V6:\n            _sl_HandleAsync_DnsGetHostByService(pArgs);\n            break;\n        case SL_OPCODE_NETAPP_PINGREPORTREQUESTRESPONSE:\n            _sl_HandleAsync_PingResponse(pArgs);\n            break;\n#endif\n\n#if defined(sl_HttpServerCallback) || defined(EXT_LIB_REGISTERED_HTTP_SERVER_EVENTS)\n\t\tcase SL_OPCODE_NETAPP_HTTPGETTOKENVALUE:\n\t\t{              \n\t\t\t_u8 *pTokenName;\n\t\t\tslHttpServerData_t Token_value;\n\t\t\tsl_NetAppHttpServerGetToken_t *httpGetToken = (sl_NetAppHttpServerGetToken_t *)_SL_RESP_ARGS_START(pHdr);\n                        pTokenName = (_u8 *)((sl_NetAppHttpServerGetToken_t *)httpGetToken + 1);\n\n\t\t\thttpServerResponse.Response = SL_NETAPP_HTTPSETTOKENVALUE;\n\t\t\thttpServerResponse.ResponseData.token_value.len = MAX_TOKEN_VALUE_LEN;\n\n             \n\t\t\thttpServerResponse.ResponseData.token_value.data = (_u8 *)_SL_RESP_ARGS_START(pHdr) + MAX_TOKEN_NAME_LEN;\n\n            httpServerEvent.Event = SL_NETAPP_HTTPGETTOKENVALUE_EVENT;\n\t\t\thttpServerEvent.EventData.httpTokenName.len = httpGetToken->token_name_len;\n\t\t\thttpServerEvent.EventData.httpTokenName.data = pTokenName;\n\n\t\t\tToken_value.token_name =  pTokenName;\n\n            _SlDrvHandleHttpServerEvents (&httpServerEvent, &httpServerResponse);\t\t\t\n\n\t\t\tToken_value.value_len = httpServerResponse.ResponseData.token_value.len;\n\t\t\tToken_value.name_len = httpServerEvent.EventData.httpTokenName.len;\n\t\t\tToken_value.token_value = httpServerResponse.ResponseData.token_value.data;\n\t\t\t    \n\n\t\t\t_sl_NetAppSendTokenValue(&Token_value);\n\t\t}\n\t\tbreak;\n\n\t\tcase SL_OPCODE_NETAPP_HTTPPOSTTOKENVALUE:\n\t\t{\n\t\t\t_u8 *pPostParams;\n\n\t\t\tsl_NetAppHttpServerPostToken_t *httpPostTokenArgs = (sl_NetAppHttpServerPostToken_t *)_SL_RESP_ARGS_START(pHdr);\n\t\t\tpPostParams = (_u8 *)((sl_NetAppHttpServerPostToken_t *)httpPostTokenArgs + 1);\n\n\t\t\thttpServerEvent.Event = SL_NETAPP_HTTPPOSTTOKENVALUE_EVENT;\n\n\t\t\thttpServerEvent.EventData.httpPostData.action.len = httpPostTokenArgs->post_action_len;\n\t\t\thttpServerEvent.EventData.httpPostData.action.data = pPostParams;\n\t\t\tpPostParams+=httpPostTokenArgs->post_action_len;\n\n\t\t\thttpServerEvent.EventData.httpPostData.token_name.len = httpPostTokenArgs->token_name_len;\n\t\t\thttpServerEvent.EventData.httpPostData.token_name.data = pPostParams;\n\t\t\tpPostParams+=httpPostTokenArgs->token_name_len;\n\n\t\t\thttpServerEvent.EventData.httpPostData.token_value.len = httpPostTokenArgs->token_value_len;\n\t\t\thttpServerEvent.EventData.httpPostData.token_value.data = pPostParams;\n\n\t\t\thttpServerResponse.Response = SL_NETAPP_RESPONSE_NONE;\n\n            _SlDrvHandleHttpServerEvents (&httpServerEvent, &httpServerResponse);\n\t\t\t\n\t\t}\n\t\tbreak;\n#endif\n\n        \n        default:\n            SL_ERROR_TRACE2(MSG_305, \"ASSERT: _SlDrvNetAppEventHandler : invalid opcode = 0x%x = %1\", pHdr->GenHeader.Opcode, pHdr->GenHeader.Opcode);\n            VERIFY_PROTOCOL(0);\n    }\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}