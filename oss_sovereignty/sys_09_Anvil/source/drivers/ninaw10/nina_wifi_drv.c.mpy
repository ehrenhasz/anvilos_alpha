{
  "module_name": "nina_wifi_drv.c",
  "hash_id": "7d6ddb041590ae85abb5f7c4815012528fa6110f140e950f3e136d2b4b40d8a6",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/ninaw10/nina_wifi_drv.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_PY_NETWORK_NINAW10\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"nina_bsp.h\"\n#include \"nina_wifi_drv.h\"\n\n#define SPI_ACK                 (1)\n#define SPI_ERR                 (0xFF)\n\n#define NO_SOCKET_AVAIL         (255)\n\n#define CMD_START               (0xE0)\n#define CMD_END                 (0xEE)\n#define CMD_ERROR               (0xEF)\n#define CMD_REPLY               (1 << 7)\n\n#define ARG_8BITS               (1)\n#define ARG_16BITS              (2)\n\n#define ARG_STR(x)              {strlen(x), (const void *)x}\n#define ARG_BYTE(x)             {1, (uint8_t  [1]) {x}}\n#define ARG_SHORT(x)            {2, (uint16_t [1]) {x}}\n#define ARG_WORD(x)             {4, (uint32_t [1]) {x}}\n\n#define NINA_ARGS(...)          (nina_args_t []) {__VA_ARGS__}\n#define NINA_VALS(...)          (nina_vals_t []) {__VA_ARGS__}\n\n#define NINA_SSELECT_TIMEOUT    (1000)\n#define NINA_CONNECT_TIMEOUT    (10000)\n\n#if NINA_DEBUG\n#define debug_printf(...) mp_printf(&mp_plat_print, __VA_ARGS__)\n#else\n#define debug_printf(...)\n#endif\n\n#ifndef __REVSH\n#define __REVSH(x) ((((uint16_t)x) << 8) | (((uint16_t)x) >> 8))\n#endif\n\ntypedef struct {\n    uint16_t size;\n    const void *data;\n} nina_args_t;\n\ntypedef struct {\n    uint16_t *size;\n    void *data;\n} nina_vals_t;\n\ntypedef enum {\n    \n    NINA_CMD_CONNECT_OPEN           = 0x10,\n    NINA_CMD_CONNECT_WEP            = 0x11,\n    NINA_CMD_CONNECT_WPA            = 0x12,\n    NINA_CMD_GET_SSID               = 0x23,\n    NINA_CMD_GET_BSSID              = 0x24,\n    NINA_CMD_GET_RSSI               = 0x25,\n    NINA_CMD_GET_ENCRYPT            = 0x26,\n\n    \n    NINA_CMD_START_AP_OPEN          = 0x18,\n    NINA_CMD_START_AP_WEP           = 0x19,\n\n    \n    NINA_CMD_AP_START_SCAN          = 0x36,\n    NINA_CMD_AP_SCAN_RESULT         = 0x27,\n    NINA_CMD_AP_GET_RSSI            = 0x32,\n    NINA_CMD_AP_GET_ENCRYPT         = 0x33,\n    NINA_CMD_AP_GET_BSSID           = 0x3C,\n    NINA_CMD_AP_GET_CHANNEL         = 0x3D,\n\n    \n    NINA_CMD_DISCONNECT             = 0x30,\n    NINA_CMD_CONN_STATUS            = 0x20,\n    NINA_CMD_CONN_REASON            = 0x1F,\n\n    \n    NINA_CMD_SET_IF_CONFIG          = 0x14,\n    NINA_CMD_GET_IF_CONFIG          = 0x21,\n    NINA_CMD_SET_DNS_CONFIG         = 0x15,\n\n    \n    NINA_CMD_SET_HOSTNAME           = 0x16,\n    NINA_CMD_HOST_BY_NAME           = 0x34,\n    NINA_CMD_GET_HOST_BY_NAME       = 0x35,\n\n    \n    NINA_CMD_SET_POWER              = 0x17,\n    NINA_CMD_PING                   = 0x3E,\n    NINA_CMD_GET_TIME               = 0x3B,\n    NINA_CMD_GET_FW_VERSION         = 0x37,\n    NINA_CMD_DEBUG_MODE             = 0x1A,\n    NINA_CMD_TEMP_SENSOR            = 0x1B,\n    NINA_CMD_GET_MAC_ADDR           = 0x22,\n\n    \n    NINA_CMD_SOCKET_REMOTE_ADDR     = 0x3A,\n\n    NINA_CMD_SOCKET_SOCKET          = 0x70,\n    NINA_CMD_SOCKET_CLOSE           = 0x71,\n    NINA_CMD_SOCKET_ERRNO           = 0x72,\n    NINA_CMD_SOCKET_BIND            = 0x73,\n    NINA_CMD_SOCKET_LISTEN          = 0x74,\n    NINA_CMD_SOCKET_ACCEPT          = 0x75,\n    NINA_CMD_SOCKET_CONNECT         = 0x76,\n    NINA_CMD_SOCKET_SEND            = 0x77,\n    NINA_CMD_SOCKET_RECV            = 0x78,\n    NINA_CMD_SOCKET_SENDTO          = 0x79,\n    NINA_CMD_SOCKET_RECVFROM        = 0x7A,\n    NINA_CMD_SOCKET_IOCTL           = 0x7B,\n    NINA_CMD_SOCKET_POLL            = 0x7C,\n    NINA_CMD_SOCKET_SETSOCKOPT      = 0x7D,\n    NINA_CMD_SOCKET_GETSOCKOPT      = 0x7E,\n    NINA_CMD_SOCKET_GETPEERNAME     = 0x7F,\n\n    \n    NINA_CMD_UDP_SEND               = 0x46,\n    NINA_CMD_UDP_RECV               = 0x45,\n    NINA_CMD_UDP_ACK                = 0x39,\n\n    \n    NINA_CMD_SET_PIN_MODE           = 0x50,\n    NINA_CMD_SET_DIGITAL_WRITE      = 0x51,\n    NINA_CMD_GET_DIGITAL_READ       = 0x53,\n    NINA_CMD_SET_ANALOG_WRITE       = 0x52,\n    NINA_CMD_GET_ANALOG_READ        = 0x54,\n\n    \n    NINA_CMD_CMD_WRITE_FILE         = 0x60,\n    NINA_CMD_CMD_READ_FILE          = 0x61,\n    NINA_CMD_CMD_DELETE_FILE        = 0x62,\n    NINA_CMD_CMD_EXISTS_FILE        = 0x63,\n    NINA_CMD_CMD_DOWNLOAD_FILE      = 0x64,\n\n    \n    NINA_CMD_CMD_APPLY_OTA          = 0x65,\n    NINA_CMD_CMD_RENAME_FILE        = 0x66,\n    NINA_CMD_CMD_DOWNLOAD_OTA       = 0x67,\n} nina_cmd_t;\n\ntypedef enum  {\n    SOCKET_STATE_CLOSED = 0,\n    SOCKET_STATE_LISTEN,\n    SOCKET_STATE_SYN_SENT,\n    SOCKET_STATE_SYN_RCVD,\n    SOCKET_STATE_ESTABLISHED,\n    SOCKET_STATE_FIN_WAIT_1,\n    SOCKET_STATE_FIN_WAIT_2,\n    SOCKET_STATE_CLOSE_WAIT,\n    SOCKET_STATE_CLOSING,\n    SOCKET_STATE_LAST_ACK,\n    SOCKET_STATE_TIME_WAIT\n} nina_sock_state_t;\n\nstatic uint8_t nina_bsp_spi_read_byte(void) {\n    uint8_t byte = 0;\n    nina_bsp_spi_transfer(NULL, &byte, 1);\n    return byte;\n}\n\nstatic int nina_send_command(uint32_t cmd, uint32_t nargs, uint32_t width, nina_args_t *args) {\n    int ret = -1;\n    uint32_t length = 4; \n\n    debug_printf(\"nina_send_command (cmd 0x%x nargs %d width %d): \", cmd, nargs, width);\n\n    nina_bsp_spi_slave_deselect();\n    if (nina_bsp_spi_slave_select(NINA_SSELECT_TIMEOUT) != 0) {\n        goto error_out;\n    }\n\n    \n    uint8_t cmdbuf_hdr[3] = {CMD_START, cmd, nargs};\n    if (nina_bsp_spi_transfer(cmdbuf_hdr, NULL, sizeof(cmdbuf_hdr)) != 0) {\n        goto error_out;\n    }\n\n    \n    for (uint32_t i = 0; i < nargs; i++) {\n        \n        uint16_t size = (width == ARG_8BITS) ? args[i].size : __REVSH(args[i].size);\n\n        \n        if (nina_bsp_spi_transfer((uint8_t *)&size, NULL, width) != 0) {\n            goto error_out;\n        }\n\n        \n        if (nina_bsp_spi_transfer(args[i].data, NULL, args[i].size) != 0) {\n            goto error_out;\n        }\n        length += args[i].size + width;\n    }\n\n    \n    uint8_t cmdbuf_end[4] = {CMD_END, 0xFF, 0xFF, 0xFF};\n    if (nina_bsp_spi_transfer(cmdbuf_end, NULL, 1 + (length % 4)) != 0) {\n        goto error_out;\n    }\n\n    \n    ret = 0;\n\nerror_out:\n    debug_printf(\"\\n\");\n    nina_bsp_spi_slave_deselect();\n    return ret;\n}\n\nstatic int nina_read_response(uint32_t cmd, uint32_t nvals, uint32_t width, nina_vals_t *vals) {\n    int ret = -1;\n    uint32_t length = 3; \n    uint8_t header[3] = {0, 0, 0};\n\n    debug_printf(\"nina_read_response(cmd 0x%x nvals %d width %d): \", cmd, nvals, width);\n\n    \n    nina_bsp_spi_slave_deselect();\n    if (nina_bsp_spi_slave_select(0) != 0) {\n        goto error_out;\n    }\n\n    if (nina_bsp_spi_transfer(NULL, header, sizeof(header)) != 0\n        || header[1] != (cmd | CMD_REPLY)) {\n        \n        uint8_t header_padding = nina_bsp_spi_read_byte();\n        (void)header_padding;\n        debug_printf(\"nina_read_response() hdr 0x%x 0x%x 0x%x 0x%x\\n\",\n            header[0], header[1], header[2], header_padding);\n        goto error_out;\n    }\n\n    \n    \n    if (nvals > header[2]) {\n        nvals = header[2];\n    }\n\n    \n    for (uint32_t i = 0; i < nvals; i++) {\n        \n        uint16_t bytes = nina_bsp_spi_read_byte();\n        if (width == ARG_16BITS) {\n            bytes = (bytes << 8) | nina_bsp_spi_read_byte();\n        }\n\n        \n        if (*(vals[i].size) < bytes) {\n            goto error_out;\n        }\n\n        \n        if (nina_bsp_spi_transfer(NULL, vals[i].data, bytes) != 0) {\n            goto error_out;\n        }\n\n        \n        *(vals[i].size) = bytes;\n        length += bytes + width;\n    }\n\n    \n    uint8_t rspbuf_end[4];\n    if (nina_bsp_spi_transfer(NULL, rspbuf_end, ((length + 1) % 4) + 1) != 0 || rspbuf_end[0] != CMD_END) {\n        goto error_out;\n    }\n\n    \n    ret = 0;\n\nerror_out:\n    debug_printf(\"\\n\");\n    nina_bsp_spi_slave_deselect();\n    return ret;\n}\n\nstatic int nina_send_command_read_ack(uint32_t cmd, uint32_t nargs, uint32_t width, nina_args_t *args) {\n    uint16_t size = 1;\n    uint8_t rval = SPI_ERR;\n    nina_bsp_atomic_enter();\n    if (nina_send_command(cmd, nargs, width, args) != 0 ||\n        nina_read_response(cmd, 1, ARG_8BITS, NINA_VALS({&size, &rval})) != 0) {\n        rval = -1;\n    }\n    nina_bsp_atomic_exit();\n    return rval;\n}\n\nstatic int nina_send_command_read_vals(uint32_t cmd, uint32_t nargs,\n    uint32_t argsw, nina_args_t *args, uint32_t nvals, uint32_t valsw, nina_vals_t *vals) {\n    int ret = 0;\n    nina_bsp_atomic_enter();\n    if (nina_send_command(cmd, nargs, argsw, args) != 0 ||\n        nina_read_response(cmd, nvals, valsw, vals) != 0) {\n        ret = -1;\n    }\n    nina_bsp_atomic_exit();\n    return ret;\n}\n\nstatic void nina_fix_mac_addr(uint8_t *mac) {\n    for (int i = 0; i < 3; i++) {\n        uint8_t b = mac[i];\n        mac[i] = mac[5 - i];\n        mac[5 - i] = b;\n    }\n}\n\nint nina_init(void) {\n    \n    nina_bsp_init();\n    return 0;\n}\n\nint nina_deinit(void) {\n    return nina_bsp_deinit();\n}\n\nint nina_connection_status(void) {\n    return nina_send_command_read_ack(NINA_CMD_CONN_STATUS, 0, ARG_8BITS, NULL);\n}\n\nint nina_connection_reason(void) {\n    return nina_send_command_read_ack(NINA_CMD_CONN_REASON, 0, ARG_8BITS, NULL);\n}\n\nint nina_connect(const char *ssid, uint8_t security, const char *key, uint16_t channel) {\n    if (key == NULL && security != NINA_SEC_OPEN) {\n        return -1;\n    }\n\n    switch (security) {\n        case NINA_SEC_OPEN:\n            if (nina_send_command_read_ack(NINA_CMD_CONNECT_OPEN,\n                1, ARG_8BITS, NINA_ARGS(ARG_STR(ssid))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        case NINA_SEC_WEP:\n            if (nina_send_command_read_ack(NINA_CMD_CONNECT_WEP,\n                2, ARG_8BITS, NINA_ARGS(ARG_STR(ssid), ARG_STR(key))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        case NINA_SEC_WPA_PSK:\n            if (nina_send_command_read_ack(NINA_CMD_CONNECT_WPA,\n                3, ARG_8BITS, NINA_ARGS(ARG_STR(ssid), ARG_BYTE(0), ARG_STR(key))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        default:\n            return -1;\n    }\n\n    return 0;\n}\n\nint nina_start_ap(const char *ssid, uint8_t security, const char *key, uint16_t channel) {\n    uint8_t status = NINA_STATUS_AP_FAILED;\n\n    if ((key == NULL && security != NINA_SEC_OPEN) ||\n        (security != NINA_SEC_OPEN && security != NINA_SEC_WEP)) {\n        return -1;\n    }\n\n    switch (security) {\n        case NINA_SEC_OPEN:\n            if (nina_send_command_read_ack(NINA_CMD_START_AP_OPEN,\n                2, ARG_8BITS, NINA_ARGS(ARG_STR(ssid), ARG_BYTE(channel))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        case NINA_SEC_WEP:\n            if (nina_send_command_read_ack(NINA_CMD_START_AP_WEP,\n                3, ARG_8BITS, NINA_ARGS(ARG_STR(ssid), ARG_STR(key), ARG_BYTE(channel))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        default:\n            return -1;\n    }\n\n    for (mp_uint_t start = mp_hal_ticks_ms(); ; mp_hal_delay_ms(10)) {\n        status = nina_connection_status();\n        if ((status != NINA_STATUS_IDLE) && (status != NINA_STATUS_NO_SSID_AVAIL)) {\n            break;\n        }\n\n        if ((mp_hal_ticks_ms() - start) >= NINA_CONNECT_TIMEOUT) {\n            break;\n        }\n    }\n\n    return (status == NINA_STATUS_AP_LISTENING) ? 0 : -1;\n}\n\nint nina_disconnect(void) {\n    if (nina_send_command_read_ack(NINA_CMD_DISCONNECT,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF))) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_isconnected(void) {\n    return nina_connection_status() == NINA_STATUS_CONNECTED;\n}\n\nint nina_connected_sta(uint32_t *sta_ip) {\n    return -1;\n}\n\nint nina_ifconfig(nina_ifconfig_t *ifconfig, bool set) {\n    uint16_t ip_len = NINA_IPV4_ADDR_LEN;\n    uint16_t sub_len = NINA_IPV4_ADDR_LEN;\n    uint16_t gw_len = NINA_IPV4_ADDR_LEN;\n    uint16_t dns_len = NINA_IPV4_ADDR_LEN;\n\n    if (set) {\n        if (nina_send_command_read_ack(NINA_CMD_SET_IF_CONFIG,\n            4, ARG_8BITS,\n            NINA_ARGS(\n                ARG_BYTE(3),         \n                {ip_len,  ifconfig->ip_addr},\n                {gw_len,  ifconfig->gateway_addr},\n                {sub_len, ifconfig->subnet_addr})) != 0) {\n            return -1;\n        }\n\n        uint8_t dns2[4] = {8, 8, 8, 8};\n        if (nina_send_command_read_ack(NINA_CMD_SET_DNS_CONFIG,\n            3, ARG_8BITS,\n            NINA_ARGS(\n                ARG_BYTE(1),         \n                {dns_len, ifconfig->dns_addr},\n                {dns_len, dns2})) != SPI_ACK) {\n            return -1;\n        }\n\n    } else {\n        if (nina_send_command_read_vals(NINA_CMD_GET_IF_CONFIG,\n            1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF)),\n            3, ARG_8BITS,\n            NINA_VALS(\n                {&ip_len,  ifconfig->ip_addr},\n                {&sub_len, ifconfig->subnet_addr},\n                {&gw_len,  ifconfig->gateway_addr})) != 0) {\n            return -1;\n        }\n        \n        memcpy(ifconfig->dns_addr, ifconfig->gateway_addr, NINA_IPV4_ADDR_LEN);\n    }\n    return 0;\n}\n\nint nina_netinfo(nina_netinfo_t *netinfo) {\n    uint16_t rssi_len = 4;\n    uint16_t sec_len = 1;\n    uint16_t ssid_len = NINA_MAX_SSID_LEN;\n    uint16_t bssid_len = NINA_MAC_ADDR_LEN;\n\n    if (nina_send_command_read_vals(NINA_CMD_GET_RSSI,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF)),\n        1, ARG_8BITS, NINA_VALS({&rssi_len, &netinfo->rssi})) != 0) {\n        return -1;\n    }\n\n    if (nina_send_command_read_vals(NINA_CMD_GET_ENCRYPT,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF)),\n        1, ARG_8BITS, NINA_VALS({&sec_len, &netinfo->security})) != 0) {\n        return -1;\n    }\n\n    if (nina_send_command_read_vals(NINA_CMD_GET_SSID,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF)),\n        1, ARG_8BITS, NINA_VALS({&ssid_len, &netinfo->ssid})) != 0) {\n        return -1;\n    }\n\n    \n    netinfo->ssid[MIN((NINA_MAX_SSID_LEN - 1), ssid_len)] = 0;\n\n    if (nina_send_command_read_vals(NINA_CMD_GET_BSSID,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF)),\n        1, ARG_8BITS, NINA_VALS({&bssid_len, &netinfo->bssid})) != 0) {\n        return -1;\n    }\n\n    \n    nina_fix_mac_addr(netinfo->bssid);\n\n    return 0;\n}\n\nint nina_scan(nina_scan_callback_t scan_callback, void *arg, uint32_t timeout) {\n    uint16_t sizes[NINA_MAX_NETWORK_LIST];\n    char ssids[NINA_MAX_NETWORK_LIST][NINA_MAX_SSID_LEN];\n    nina_vals_t vals[NINA_MAX_NETWORK_LIST];\n\n    \n    for (int i = 0; i < NINA_MAX_NETWORK_LIST; i++) {\n        sizes[i] = NINA_MAX_SSID_LEN - 1;\n        memset(ssids[i], 0, NINA_MAX_SSID_LEN);\n        vals[i].size = &sizes[i];\n        vals[i].data = ssids[i];\n    }\n\n    if (nina_send_command_read_ack(NINA_CMD_AP_START_SCAN,\n        0, ARG_8BITS, NULL) != SPI_ACK) {\n        return -1;\n    }\n\n    for (mp_uint_t start = mp_hal_ticks_ms(); ;) {\n        if (nina_send_command_read_vals(NINA_CMD_AP_SCAN_RESULT,\n            0, ARG_8BITS, NULL,\n            NINA_MAX_NETWORK_LIST, ARG_8BITS, vals) != 0) {\n            return -1;\n        }\n\n        if (ssids[0][0] != 0) {\n            \n            break;\n        }\n\n        if (timeout && (mp_hal_ticks_ms() - start) >= timeout) {\n            \n            return -MP_ETIMEDOUT;\n        }\n\n        mp_hal_delay_ms(100);\n    }\n\n    for (int i = 0; i < NINA_MAX_NETWORK_LIST; i++) {\n        uint16_t rssi_len = 4;\n        uint16_t sec_len = 1;\n        uint16_t chan_len = 1;\n        uint16_t bssid_len = NINA_MAC_ADDR_LEN;\n        nina_scan_result_t scan_result;\n\n        if (ssids[i][0] == 0) {\n            break;\n        }\n\n        \n        strncpy(scan_result.ssid, ssids[i], NINA_MAX_SSID_LEN);\n\n        \n        if (nina_send_command_read_vals(NINA_CMD_AP_GET_RSSI,\n            1, ARG_8BITS, NINA_ARGS(ARG_BYTE(i)),\n            1, ARG_8BITS, NINA_VALS({&rssi_len, &scan_result.rssi})) != 0) {\n            return -1;\n        }\n\n        \n        if (nina_send_command_read_vals(NINA_CMD_AP_GET_ENCRYPT,\n            1, ARG_8BITS, NINA_ARGS(ARG_BYTE(i)),\n            1, ARG_8BITS, NINA_VALS({&sec_len, &scan_result.security})) != 0) {\n            return -1;\n        }\n\n        \n        if (nina_send_command_read_vals(NINA_CMD_AP_GET_CHANNEL,\n            1, ARG_8BITS, NINA_ARGS(ARG_BYTE(i)),\n            1, ARG_8BITS, NINA_VALS({&chan_len, &scan_result.channel})) != 0) {\n            return -1;\n        }\n\n        \n        if (nina_send_command_read_vals(NINA_CMD_AP_GET_BSSID,\n            1, ARG_8BITS, NINA_ARGS(ARG_BYTE(i)),\n            1, ARG_8BITS, NINA_VALS({&bssid_len, scan_result.bssid})) != 0) {\n            return -1;\n        }\n\n        \n        nina_fix_mac_addr(scan_result.bssid);\n\n        scan_callback(&scan_result, arg);\n    }\n\n    return 0;\n}\n\nint nina_get_rssi(void) {\n    uint16_t size = 4;\n    int32_t rssi = 0;\n    if (nina_send_command_read_vals(NINA_CMD_GET_RSSI,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(0xFF)),\n        1, ARG_8BITS, NINA_VALS({&size, &rssi})) != 0) {\n        return -1;\n    }\n\n    return rssi;\n}\n\nint nina_fw_version(uint8_t *fw_ver) {\n    uint16_t size = NINA_FW_VER_LEN;\n    if (nina_send_command_read_vals(NINA_CMD_GET_FW_VERSION,\n        0, ARG_8BITS, NULL,\n        1, ARG_8BITS, NINA_VALS({&size, fw_ver})) != 0) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_set_hostname(const char *hostname) {\n    if (nina_send_command_read_ack(NINA_CMD_SET_HOSTNAME,\n        1, ARG_8BITS, NINA_ARGS(ARG_STR(hostname))) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_gethostbyname(const char *name, uint8_t *out_ip) {\n    uint16_t size = 4;\n\n    if (nina_send_command_read_ack(NINA_CMD_HOST_BY_NAME,\n        1, ARG_8BITS, NINA_ARGS(ARG_STR(name))) != SPI_ACK) {\n        return -1;\n    }\n\n    if (nina_send_command_read_vals(NINA_CMD_GET_HOST_BY_NAME,\n        0, ARG_8BITS, NULL,\n        1, ARG_8BITS, NINA_VALS({&size, out_ip})) != 0) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_ioctl(uint32_t cmd, size_t len, uint8_t *buf, uint32_t iface) {\n    switch (cmd) {\n        case NINA_CMD_SET_PIN_MODE:\n            if (len != 2 || nina_send_command_read_ack(NINA_CMD_SET_PIN_MODE,\n                2, ARG_8BITS, NINA_ARGS(ARG_BYTE(buf[0]), ARG_BYTE(buf[1]))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        case NINA_CMD_SET_DIGITAL_WRITE:\n            if (len != 2 || nina_send_command_read_ack(NINA_CMD_SET_DIGITAL_WRITE,\n                2, ARG_8BITS, NINA_ARGS(ARG_BYTE(buf[0]), ARG_BYTE(buf[1]))) != SPI_ACK) {\n                return -1;\n            }\n            break;\n        case NINA_CMD_GET_DIGITAL_READ:\n            if (len != 1 || nina_send_command_read_vals(NINA_CMD_GET_DIGITAL_READ,\n                1, ARG_8BITS, NINA_ARGS(ARG_BYTE(buf[0])),\n                1, ARG_8BITS, NINA_VALS({(uint16_t *)&len, buf})) != 0) {\n                return -1;\n            }\n            break;\n        case NINA_CMD_GET_ANALOG_READ: {\n            if (len != 2 || nina_send_command_read_vals(NINA_CMD_GET_ANALOG_READ,\n                1, ARG_8BITS, NINA_ARGS(ARG_BYTE(buf[0])),\n                1, ARG_8BITS, NINA_VALS({(uint16_t *)&len, buf})) != 0) {\n                return -1;\n            }\n            break;\n        }\n        default:\n            return 0;\n    }\n    return 0;\n}\n\nint nina_socket_socket(uint8_t type, uint8_t proto) {\n    uint16_t size = 1;\n    uint8_t sock = 0;\n\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_SOCKET,\n        2, ARG_8BITS, NINA_ARGS(ARG_BYTE(type), ARG_BYTE(proto)),\n        1, ARG_8BITS, NINA_VALS({&size, &sock})) != 0) {\n        return -1;\n    }\n    return (sock == NO_SOCKET_AVAIL) ? -1 : sock;\n}\n\nint nina_socket_close(int fd) {\n    if (nina_send_command_read_ack(NINA_CMD_SOCKET_CLOSE,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd))) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_errno(int *_errno) {\n    uint16_t size = 1;\n    *_errno = 0;\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_ERRNO,\n        0, ARG_8BITS, NULL,\n        1, ARG_8BITS, NINA_VALS({&size, _errno})) != 0) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_bind(int fd, uint8_t *ip, uint16_t port) {\n    if (nina_send_command_read_ack(NINA_CMD_SOCKET_BIND,\n        2, ARG_8BITS,\n        NINA_ARGS(\n            ARG_BYTE(fd),\n            ARG_SHORT(__REVSH(port)))) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_listen(int fd, uint32_t backlog) {\n    if (nina_send_command_read_ack(NINA_CMD_SOCKET_LISTEN,\n        2, ARG_8BITS,\n        NINA_ARGS(\n            ARG_BYTE(fd),\n            ARG_BYTE(backlog))) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_accept(int fd, uint8_t *ip, uint16_t *port, int *fd_out) {\n    uint16_t fd_len = 1;\n    uint16_t port_len = 2;\n    uint16_t ip_len = NINA_IPV4_ADDR_LEN;\n    *fd_out = 0;\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_ACCEPT,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd)),\n        3, ARG_8BITS, NINA_VALS({&fd_len, fd_out}, {&ip_len, ip}, {&port_len, port})) != 0) {\n        return -1;\n    }\n    return (*fd_out == NO_SOCKET_AVAIL) ? -1 : 0;\n}\n\nint nina_socket_connect(int fd, uint8_t *ip, uint16_t port) {\n    if (nina_send_command_read_ack(NINA_CMD_SOCKET_CONNECT,\n        3, ARG_8BITS,\n        NINA_ARGS(\n            ARG_BYTE(fd),\n            ARG_WORD((*(uint32_t *)ip)),\n            ARG_SHORT(__REVSH(port)))) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_send(int fd, const uint8_t *buf, uint32_t len) {\n    uint16_t size = 2;\n    uint16_t bytes = 0;\n\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_SEND,\n        2, ARG_16BITS, NINA_ARGS(ARG_BYTE(fd), {len, buf}),\n        1, ARG_8BITS, NINA_VALS({&size, &bytes})) != 0) {\n        return -1;\n    }\n\n    \n    bytes = __REVSH(bytes);\n\n    if (bytes == 0) {\n        int _errno = 0;\n        if (nina_socket_errno(&_errno) != 0 || _errno != 0) {\n            return -1;\n        }\n    }\n\n    return bytes;\n}\n\nint nina_socket_recv(int fd, uint8_t *buf, uint32_t len) {\n    uint16_t bytes = len;\n\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_RECV,\n        2, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd), ARG_SHORT(bytes)),\n        1, ARG_16BITS, NINA_VALS({&bytes, buf})) != 0) {\n        return -1;\n    }\n\n    if (bytes == 0) {\n        int _errno = 0;\n        if (nina_socket_errno(&_errno) != 0 || _errno != 0) {\n            return -1;\n        }\n    }\n\n    return bytes;\n}\n\n\nint nina_socket_sendto(int fd, const uint8_t *buf, uint32_t len, uint8_t *ip, uint16_t port) {\n    uint16_t size = 2;\n    uint16_t bytes = 0;\n\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_SENDTO,\n        4, ARG_16BITS, NINA_ARGS(ARG_BYTE(fd), ARG_WORD((*(uint32_t *)ip)), ARG_SHORT(__REVSH(port)), {len, buf}),\n        1, ARG_8BITS, NINA_VALS({&size, &bytes})) != 0) {\n        return -1;\n    }\n\n    \n    bytes = __REVSH(bytes);\n\n    if (bytes == 0) {\n        int _errno = 0;\n        if (nina_socket_errno(&_errno) != 0 || _errno != 0) {\n            return -1;\n        }\n    }\n\n    return bytes;\n}\n\n\nint nina_socket_recvfrom(int fd, uint8_t *buf, uint32_t len, uint8_t *ip, uint16_t *port) {\n    uint16_t bytes = len;\n    uint16_t port_len = 2;\n    uint16_t ip_len = NINA_IPV4_ADDR_LEN;\n\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_RECVFROM,\n        2, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd), ARG_SHORT(bytes)),\n        3, ARG_16BITS, NINA_VALS({&ip_len, ip}, {&port_len, port}, {&bytes, buf})) != 0) {\n        return -1;\n    }\n\n    if (bytes == 0) {\n        int _errno = 0;\n        if (nina_socket_errno(&_errno) != 0 || _errno != 0) {\n            return -1;\n        }\n    }\n    return bytes;\n}\n\nint nina_socket_ioctl(int fd, uint32_t cmd, void *argval, uint32_t arglen) {\n    uint16_t len = arglen;\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_IOCTL,\n        3, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd), ARG_WORD(cmd), {len, argval}),\n        1, ARG_8BITS, NINA_VALS({&len, argval})) != 0 || arglen == 0) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_poll(int fd, uint8_t *flags) {\n    uint16_t flags_len = 1;\n    if (nina_send_command_read_vals(NINA_CMD_SOCKET_POLL,\n        1, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd)),\n        1, ARG_8BITS, NINA_VALS({&flags_len, flags})) != 0) {\n        return -1;\n    }\n    if (*flags & 0x80) {\n        \n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_setsockopt(int fd, uint32_t level, uint32_t optname, const void *optval, uint16_t optlen) {\n    if (nina_send_command_read_ack(\n        NINA_CMD_SOCKET_SETSOCKOPT,\n        3, ARG_8BITS,\n        NINA_ARGS(ARG_BYTE(fd), ARG_WORD(optname), {optlen, optval})) != SPI_ACK) {\n        return -1;\n    }\n    return 0;\n}\n\nint nina_socket_getsockopt(int fd, uint32_t level, uint32_t optname, void *optval, uint16_t optlen) {\n    if (nina_send_command_read_vals(\n        NINA_CMD_SOCKET_GETSOCKOPT,\n        3, ARG_8BITS, NINA_ARGS(ARG_BYTE(fd), ARG_WORD(optname), ARG_BYTE(optlen)),\n        1, ARG_8BITS, NINA_VALS({&optlen, optval})) != 0 || optlen == 0) {\n        return -1;\n    }\n    return 0;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}