{
  "module_name": "nina_wifi_bsp.c",
  "hash_id": "69acfd22c5fd74f6b804fee285c355320508674972e5c6720a65f722e425652d",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/ninaw10/nina_wifi_bsp.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK_NINAW10\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"extmod/modmachine.h\"\n\n#include \"nina_bsp.h\"\n#include \"nina_wifi_drv.h\"\n\n#if NINA_DEBUG\n#define debug_printf(...) mp_printf(&mp_plat_print, __VA_ARGS__)\n#else\n#define debug_printf(...)\n#endif\n\nint nina_bsp_init(void) {\n    mp_hal_pin_output(MICROPY_HW_NINA_GPIO1);\n    mp_hal_pin_input(MICROPY_HW_NINA_ACK);\n    mp_hal_pin_output(MICROPY_HW_NINA_RESET);\n    mp_hal_pin_output(MICROPY_HW_NINA_GPIO0);\n\n    \n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO1, 1);\n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO0, 1);\n\n    mp_hal_pin_write(MICROPY_HW_NINA_RESET, 0);\n    mp_hal_delay_ms(100);\n\n    mp_hal_pin_write(MICROPY_HW_NINA_RESET, 1);\n    mp_hal_delay_ms(750);\n\n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO0, 0);\n    mp_hal_pin_input(MICROPY_HW_NINA_GPIO0);\n\n    \n    mp_obj_t args[] = {\n        MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIFI_SPI_ID),\n        MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIFI_SPI_BAUDRATE),\n    };\n\n    MP_STATE_PORT(mp_wifi_spi) = MP_OBJ_TYPE_GET_SLOT(&machine_spi_type, make_new)((mp_obj_t)&machine_spi_type, 2, 0, args);\n    return 0;\n}\n\nint nina_bsp_deinit(void) {\n    mp_hal_pin_output(MICROPY_HW_NINA_GPIO1);\n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO1, 1);\n\n    mp_hal_pin_output(MICROPY_HW_NINA_RESET);\n    mp_hal_pin_write(MICROPY_HW_NINA_RESET, 0);\n    mp_hal_delay_ms(100);\n\n    mp_hal_pin_output(MICROPY_HW_NINA_GPIO0);\n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO0, 1);\n    return 0;\n}\n\nint nina_bsp_atomic_enter(void) {\n    #if MICROPY_ENABLE_SCHEDULER\n    mp_sched_lock();\n    #endif\n    return 0;\n}\n\nint nina_bsp_atomic_exit(void) {\n    #if MICROPY_ENABLE_SCHEDULER\n    mp_sched_unlock();\n    #endif\n    return 0;\n}\n\nint nina_bsp_read_irq(void) {\n    return mp_hal_pin_read(MICROPY_HW_NINA_GPIO0);\n}\n\nint nina_bsp_spi_slave_select(uint32_t timeout) {\n    \n    for (mp_uint_t start = mp_hal_ticks_ms(); mp_hal_pin_read(MICROPY_HW_NINA_ACK) == 1; mp_hal_delay_ms(1)) {\n        if (timeout && ((mp_hal_ticks_ms() - start) >= timeout)) {\n            return -1;\n        }\n    }\n\n    \n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO1, 0);\n\n    \n    for (mp_uint_t start = mp_hal_ticks_ms(); mp_hal_pin_read(MICROPY_HW_NINA_ACK) == 0; mp_hal_delay_ms(1)) {\n        if ((mp_hal_ticks_ms() - start) >= 100) {\n            mp_hal_pin_write(MICROPY_HW_NINA_GPIO1, 1);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nint nina_bsp_spi_slave_deselect(void) {\n    mp_hal_pin_write(MICROPY_HW_NINA_GPIO1, 1);\n    return 0;\n}\n\nint nina_bsp_spi_transfer(const uint8_t *tx_buf, uint8_t *rx_buf, uint32_t size) {\n    mp_obj_t mp_wifi_spi = MP_STATE_PORT(mp_wifi_spi);\n    ((mp_machine_spi_p_t *)MP_OBJ_TYPE_GET_SLOT(&machine_spi_type, protocol))->transfer(mp_wifi_spi, size, tx_buf, rx_buf);\n    #if NINA_DEBUG\n    for (int i = 0; i < size; i++) {\n        if (tx_buf) {\n            debug_printf(\"0x%x \", tx_buf[i]);\n        } else {\n            debug_printf(\"0x%x \", rx_buf[i]);\n        }\n    }\n    #endif\n    return 0;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}