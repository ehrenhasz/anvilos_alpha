{
  "module_name": "machine_pin_nina.c",
  "hash_id": "00b3f02f17132bc88f4db5332c3c80eca146fe2fd4720fa9ab6658e925875632",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/ninaw10/machine_pin_nina.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/mphal.h\"\n\n#if defined(MICROPY_PY_NETWORK_NINAW10) && defined(MICROPY_HW_PIN_EXT_COUNT)\n\n#include \"modmachine.h\"\n#include \"machine_pin.h\"\n#include \"nina_wifi_drv.h\"\n\n#define NINA_GPIO_INPUT         (0x00)\n#define NINA_GPIO_OUTPUT        (0x01)\n#define NINA_GPIO_INPUT_PULLUP  (0x02)\n\n#define NINA_GPIO_MODE          (0x50)\n#define NINA_GPIO_READ          (0x53)\n#define NINA_GPIO_READ_ANALOG   (0x54)\n#define NINA_GPIO_WRITE         (0x51)\n#define NINA_GPIO_IS_INPUT_ONLY(p)  ((p >= 3 && p <= 6))\n#define NINA_GPIO_IS_ADC_CHANNEL(p) ((p >= 3 && p <= 6))\n\n\n\nstatic uint8_t pin_map[MICROPY_HW_PIN_EXT_COUNT] = {\n    27, \n    25, \n    26, \n    34, \n    39, \n    36, \n    35, \n};\n\n\n\nstatic uint8_t adc_map[MICROPY_HW_PIN_EXT_COUNT] = {\n    -1, \n    -1, \n    -1, \n    6, \n    3, \n    0, \n    7, \n};\n\nvoid machine_pin_ext_init(void) {\n    nina_init();\n}\n\nbool machine_pin_ext_is_adc_channel(const machine_pin_obj_t *self) {\n    return NINA_GPIO_IS_ADC_CHANNEL(self->id);\n}\n\nuint32_t machine_pin_ext_to_adc_channel(const machine_pin_obj_t *self) {\n    return adc_map[self->id];\n}\n\nvoid machine_pin_ext_set(machine_pin_obj_t *self, bool value) {\n    if (self->id >= 0 && self->id < MICROPY_HW_PIN_EXT_COUNT) {\n        uint8_t buf[] = {pin_map[self->id], value};\n        nina_ioctl(NINA_GPIO_WRITE, sizeof(buf), buf, 0);\n    }\n}\n\nbool machine_pin_ext_get(machine_pin_obj_t *self) {\n    bool value = false;\n    if (self->id >= 0 && self->id < MICROPY_HW_PIN_EXT_COUNT) {\n        uint8_t buf[] = {pin_map[self->id]};\n        nina_ioctl(NINA_GPIO_READ, sizeof(buf), buf, 0);\n        value = buf[0];\n    }\n    return value;\n}\n\nuint16_t machine_pin_ext_read_u16(uint32_t channel) {\n    uint16_t buf = channel;\n    nina_ioctl(NINA_GPIO_READ_ANALOG, sizeof(buf), (uint8_t *)&buf, 0);\n    return buf;\n}\n\nvoid machine_pin_ext_config(machine_pin_obj_t *self, int mode, int value) {\n    if (mode == MACHINE_PIN_MODE_IN || mode == MACHINE_PIN_MODE_ANALOG) {\n        mode = NINA_GPIO_INPUT;\n        self->is_output = false;\n    } else if (mode == MACHINE_PIN_MODE_OUT) {\n        mode = NINA_GPIO_OUTPUT;\n        self->is_output = true;\n    } else {\n        mp_raise_ValueError(\"only Pin.OUT and Pin.IN are supported for this pin\");\n    }\n    if (self->id >= 0 && self->id < MICROPY_HW_PIN_EXT_COUNT) {\n        uint8_t buf[] = {pin_map[self->id], mode};\n        if (mode == NINA_GPIO_OUTPUT) {\n            if (NINA_GPIO_IS_INPUT_ONLY(self->id)) {\n                mp_raise_ValueError(\"only Pin.IN is supported for this pin\");\n            }\n            machine_pin_ext_set(self, value);\n        }\n        nina_ioctl(NINA_GPIO_MODE, sizeof(buf), buf, 0);\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}