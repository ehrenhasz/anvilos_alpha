{
  "module_name": "spiflash.c",
  "hash_id": "8154dcd300a824020c4f6b7458116ae6c3dec4b3d8e34c3a1b8f4196321496e2",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/memory/spiflash.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n#include \"drivers/memory/spiflash.h\"\n\n#define QSPI_QE_MASK (0x02)\n#define USE_WR_DELAY (1)\n\n#define CMD_WRSR        (0x01)\n#define CMD_WRITE       (0x02)\n#define CMD_READ        (0x03)\n#define CMD_RDSR        (0x05)\n#define CMD_WREN        (0x06)\n#define CMD_SEC_ERASE   (0x20)\n#define CMD_RDCR        (0x35)\n#define CMD_RD_DEVID    (0x9f)\n#define CMD_CHIP_ERASE  (0xc7)\n#define CMD_C4READ      (0xeb)\n\n\n#define CMD_WRITE_32    (0x12)\n#define CMD_READ_32     (0x13)\n#define CMD_SEC_ERASE_32 (0x21)\n#define CMD_C4READ_32   (0xec)\n\n#define WAIT_SR_TIMEOUT (1000000)\n\n#define PAGE_SIZE (256) \n#define SECTOR_SIZE MP_SPIFLASH_ERASE_BLOCK_SIZE\n\nstatic void mp_spiflash_acquire_bus(mp_spiflash_t *self) {\n    const mp_spiflash_config_t *c = self->config;\n    if (c->bus_kind == MP_SPIFLASH_BUS_QSPI) {\n        c->bus.u_qspi.proto->ioctl(c->bus.u_qspi.data, MP_QSPI_IOCTL_BUS_ACQUIRE);\n    }\n}\n\nstatic void mp_spiflash_release_bus(mp_spiflash_t *self) {\n    const mp_spiflash_config_t *c = self->config;\n    if (c->bus_kind == MP_SPIFLASH_BUS_QSPI) {\n        c->bus.u_qspi.proto->ioctl(c->bus.u_qspi.data, MP_QSPI_IOCTL_BUS_RELEASE);\n    }\n}\n\nstatic int mp_spiflash_write_cmd_data(mp_spiflash_t *self, uint8_t cmd, size_t len, uint32_t data) {\n    int ret = 0;\n    const mp_spiflash_config_t *c = self->config;\n    if (c->bus_kind == MP_SPIFLASH_BUS_SPI) {\n        \n        mp_hal_pin_write(c->bus.u_spi.cs, 0);\n        c->bus.u_spi.proto->transfer(c->bus.u_spi.data, 1, &cmd, NULL);\n        mp_hal_pin_write(c->bus.u_spi.cs, 1);\n    } else {\n        ret = c->bus.u_qspi.proto->write_cmd_data(c->bus.u_qspi.data, cmd, len, data);\n    }\n    return ret;\n}\n\nstatic int mp_spiflash_transfer_cmd_addr_data(mp_spiflash_t *self, uint8_t cmd, uint32_t addr, size_t len, const uint8_t *src, uint8_t *dest) {\n    int ret = 0;\n    const mp_spiflash_config_t *c = self->config;\n    if (c->bus_kind == MP_SPIFLASH_BUS_SPI) {\n        uint8_t buf[5] = {cmd, 0};\n        uint8_t buff_len = 1 + mp_spi_set_addr_buff(&buf[1], addr);\n        mp_hal_pin_write(c->bus.u_spi.cs, 0);\n        c->bus.u_spi.proto->transfer(c->bus.u_spi.data, buff_len, buf, NULL);\n        if (len && (src != NULL)) {\n            c->bus.u_spi.proto->transfer(c->bus.u_spi.data, len, src, NULL);\n        } else if (len && (dest != NULL)) {\n            c->bus.u_spi.proto->transfer(c->bus.u_spi.data, len, dest, dest);\n        }\n\n        mp_hal_pin_write(c->bus.u_spi.cs, 1);\n    } else {\n        if (dest != NULL) {\n            ret = c->bus.u_qspi.proto->read_cmd_qaddr_qdata(c->bus.u_qspi.data, cmd, addr, len, dest);\n        } else {\n            ret = c->bus.u_qspi.proto->write_cmd_addr_data(c->bus.u_qspi.data, cmd, addr, len, src);\n        }\n    }\n    return ret;\n}\n\nstatic int mp_spiflash_read_cmd(mp_spiflash_t *self, uint8_t cmd, size_t len, uint32_t *dest) {\n    const mp_spiflash_config_t *c = self->config;\n    if (c->bus_kind == MP_SPIFLASH_BUS_SPI) {\n        mp_hal_pin_write(c->bus.u_spi.cs, 0);\n        c->bus.u_spi.proto->transfer(c->bus.u_spi.data, 1, &cmd, NULL);\n        c->bus.u_spi.proto->transfer(c->bus.u_spi.data, len, (void*)dest, (void*)dest);\n        mp_hal_pin_write(c->bus.u_spi.cs, 1);\n        return 0;\n    } else {\n        return c->bus.u_qspi.proto->read_cmd(c->bus.u_qspi.data, cmd, len, dest);\n    }\n}\n\nstatic int mp_spiflash_read_data(mp_spiflash_t *self, uint32_t addr, size_t len, uint8_t *dest) {\n    const mp_spiflash_config_t *c = self->config;\n    uint8_t cmd;\n    if (c->bus_kind == MP_SPIFLASH_BUS_SPI) {\n        cmd = MICROPY_HW_SPI_ADDR_IS_32BIT(addr) ? CMD_READ_32 : CMD_READ;\n    } else {\n        cmd = MICROPY_HW_SPI_ADDR_IS_32BIT(addr) ? CMD_C4READ_32 : CMD_C4READ;\n    }\n    return mp_spiflash_transfer_cmd_addr_data(self, cmd, addr, len, NULL, dest);\n}\n\nstatic int mp_spiflash_write_cmd(mp_spiflash_t *self, uint8_t cmd) {\n    return mp_spiflash_write_cmd_data(self, cmd, 0, 0);\n}\n\nstatic int mp_spiflash_wait_sr(mp_spiflash_t *self, uint8_t mask, uint8_t val, uint32_t timeout) {\n    do {\n        uint32_t sr;\n        int ret = mp_spiflash_read_cmd(self, CMD_RDSR, 1, &sr);\n        if (ret != 0) {\n            return ret;\n        }\n        if ((sr & mask) == val) {\n            return 0; \n        }\n    } while (timeout--);\n\n    return -MP_ETIMEDOUT;\n}\n\nstatic int mp_spiflash_wait_wel1(mp_spiflash_t *self) {\n    return mp_spiflash_wait_sr(self, 2, 2, WAIT_SR_TIMEOUT);\n}\n\nstatic int mp_spiflash_wait_wip0(mp_spiflash_t *self) {\n    return mp_spiflash_wait_sr(self, 1, 0, WAIT_SR_TIMEOUT);\n}\n\nstatic inline void mp_spiflash_deepsleep_internal(mp_spiflash_t *self, int value) {\n    mp_spiflash_write_cmd(self, value ? 0xb9 : 0xab); \n}\n\nvoid mp_spiflash_init(mp_spiflash_t *self) {\n    self->flags = 0;\n\n    if (self->config->bus_kind == MP_SPIFLASH_BUS_SPI) {\n        mp_hal_pin_write(self->config->bus.u_spi.cs, 1);\n        mp_hal_pin_output(self->config->bus.u_spi.cs);\n        self->config->bus.u_spi.proto->ioctl(self->config->bus.u_spi.data, MP_SPI_IOCTL_INIT);\n    } else {\n        self->config->bus.u_qspi.proto->ioctl(self->config->bus.u_qspi.data, MP_QSPI_IOCTL_INIT);\n    }\n\n    mp_spiflash_acquire_bus(self);\n\n    \n    mp_spiflash_deepsleep_internal(self, 0);\n\n    #if defined(CHECK_DEVID)\n    \n    uint32_t devid;\n    int ret = mp_spiflash_read_cmd(self, CMD_RD_DEVID, 3, &devid);\n    if (ret != 0 || devid != CHECK_DEVID) {\n        mp_spiflash_release_bus(self);\n        return;\n    }\n    #endif\n\n    if (self->config->bus_kind == MP_SPIFLASH_BUS_QSPI) {\n        \n        uint32_t sr = 0, cr = 0;\n        int ret = mp_spiflash_read_cmd(self, CMD_RDSR, 1, &sr);\n        if (ret == 0) {\n            ret = mp_spiflash_read_cmd(self, CMD_RDCR, 1, &cr);\n        }\n        uint32_t data = (sr & 0xff) | (cr & 0xff) << 8;\n        if (ret == 0 && !(data & (QSPI_QE_MASK << 8))) {\n            data |= QSPI_QE_MASK << 8;\n            mp_spiflash_write_cmd(self, CMD_WREN);\n            mp_spiflash_write_cmd_data(self, CMD_WRSR, 2, data);\n            mp_spiflash_wait_wip0(self);\n        }\n    }\n\n    mp_spiflash_release_bus(self);\n}\n\nvoid mp_spiflash_deepsleep(mp_spiflash_t *self, int value) {\n    if (value) {\n        mp_spiflash_acquire_bus(self);\n    }\n    mp_spiflash_deepsleep_internal(self, value);\n    if (!value) {\n        mp_spiflash_release_bus(self);\n    }\n}\n\nstatic int mp_spiflash_erase_block_internal(mp_spiflash_t *self, uint32_t addr) {\n    int ret = 0;\n    \n    ret = mp_spiflash_write_cmd(self, CMD_WREN);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    ret = mp_spiflash_wait_wel1(self);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    uint8_t cmd = MICROPY_HW_SPI_ADDR_IS_32BIT(addr) ? CMD_SEC_ERASE_32 : CMD_SEC_ERASE;\n    ret = mp_spiflash_transfer_cmd_addr_data(self, cmd, addr, 0, NULL, NULL);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    return mp_spiflash_wait_wip0(self);\n}\n\nstatic int mp_spiflash_write_page(mp_spiflash_t *self, uint32_t addr, size_t len, const uint8_t *src) {\n    int ret = 0;\n    \n    ret = mp_spiflash_write_cmd(self, CMD_WREN);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    ret = mp_spiflash_wait_wel1(self);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    uint8_t cmd = MICROPY_HW_SPI_ADDR_IS_32BIT(addr) ? CMD_WRITE_32 : CMD_WRITE;\n    ret = mp_spiflash_transfer_cmd_addr_data(self, cmd, addr, len, src, NULL);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    return mp_spiflash_wait_wip0(self);\n}\n\n \n\n\nint mp_spiflash_erase_block(mp_spiflash_t *self, uint32_t addr) {\n    mp_spiflash_acquire_bus(self);\n    int ret = mp_spiflash_erase_block_internal(self, addr);\n    mp_spiflash_release_bus(self);\n    return ret;\n}\n\nint mp_spiflash_read(mp_spiflash_t *self, uint32_t addr, size_t len, uint8_t *dest) {\n    if (len == 0) {\n        return 0;\n    }\n    mp_spiflash_acquire_bus(self);\n    int ret = mp_spiflash_read_data(self, addr, len, dest);\n    mp_spiflash_release_bus(self);\n    return ret;\n}\n\nint mp_spiflash_write(mp_spiflash_t *self, uint32_t addr, size_t len, const uint8_t *src) {\n    mp_spiflash_acquire_bus(self);\n    int ret = 0;\n    uint32_t offset = addr & (PAGE_SIZE - 1);\n    while (len) {\n        size_t rest = PAGE_SIZE - offset;\n        if (rest > len) {\n            rest = len;\n        }\n        ret = mp_spiflash_write_page(self, addr, rest, src);\n        if (ret != 0) {\n            break;\n        }\n        len -= rest;\n        addr += rest;\n        src += rest;\n        offset = 0;\n    }\n    mp_spiflash_release_bus(self);\n    return ret;\n}\n\n \n\n\n#if MICROPY_HW_SPIFLASH_ENABLE_CACHE\n\nint mp_spiflash_cached_read(mp_spiflash_t *self, uint32_t addr, size_t len, uint8_t *dest) {\n    if (len == 0) {\n        return 0;\n    }\n    mp_spiflash_acquire_bus(self);\n    mp_spiflash_cache_t *cache = self->config->cache;\n    if (cache->user == self && cache->block != 0xffffffff) {\n        uint32_t bis = addr / SECTOR_SIZE;\n        uint32_t bie = (addr + len - 1) / SECTOR_SIZE;\n        if (bis <= cache->block && cache->block <= bie) {\n            \n            size_t rest = 0;\n            if (bis < cache->block) {\n                \n                rest = cache->block * SECTOR_SIZE - addr;\n                int ret = mp_spiflash_read_data(self, addr, rest, dest);\n                if (ret != 0) {\n                    mp_spiflash_release_bus(self);\n                    return ret;\n                }\n                len -= rest;\n                dest += rest;\n                addr += rest;\n            }\n            uint32_t offset = addr & (SECTOR_SIZE - 1);\n            rest = SECTOR_SIZE - offset;\n            if (rest > len) {\n                rest = len;\n            }\n            memcpy(dest, &cache->buf[offset], rest);\n            len -= rest;\n            if (len == 0) {\n                mp_spiflash_release_bus(self);\n                return 0;\n            }\n            dest += rest;\n            addr += rest;\n        }\n    }\n    \n    int ret = mp_spiflash_read_data(self, addr, len, dest);\n    mp_spiflash_release_bus(self);\n    return ret;\n}\n\nstatic int mp_spiflash_cache_flush_internal(mp_spiflash_t *self) {\n    #if USE_WR_DELAY\n    if (!(self->flags & 1)) {\n        return 0;\n    }\n\n    self->flags &= ~1;\n\n    mp_spiflash_cache_t *cache = self->config->cache;\n\n    \n    int ret = mp_spiflash_erase_block_internal(self, cache->block * SECTOR_SIZE);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    for (int i = 0; i < 16; i += 1) {\n        uint32_t addr = cache->block * SECTOR_SIZE + i * PAGE_SIZE;\n        int ret = mp_spiflash_write_page(self, addr, PAGE_SIZE, cache->buf + i * PAGE_SIZE);\n        if (ret != 0) {\n            return ret;\n        }\n    }\n    #endif\n    return 0;\n}\n\nint mp_spiflash_cache_flush(mp_spiflash_t *self) {\n    mp_spiflash_acquire_bus(self);\n    int ret = mp_spiflash_cache_flush_internal(self);\n    mp_spiflash_release_bus(self);\n    return ret;\n}\n\nstatic int mp_spiflash_cached_write_part(mp_spiflash_t *self, uint32_t addr, size_t len, const uint8_t *src) {\n    \n    uint32_t offset = addr & 0xfff;\n    uint32_t sec = addr >> 12;\n    addr = sec << 12;\n\n    \n    if (offset + len > SECTOR_SIZE) {\n        printf(\"mp_spiflash_cached_write_part: len is too large\\n\");\n        return -MP_EIO;\n    }\n\n    mp_spiflash_cache_t *cache = self->config->cache;\n\n    \n    if (cache->user != self) {\n        if (cache->user != NULL) {\n            mp_spiflash_cache_flush(cache->user);\n        }\n        cache->user = self;\n        cache->block = 0xffffffff;\n    }\n\n    if (cache->block != sec) {\n        \n        #if USE_WR_DELAY\n        if (cache->block != 0xffffffff) {\n            int ret = mp_spiflash_cache_flush_internal(self);\n            if (ret != 0) {\n                return ret;\n            }\n        }\n        #endif\n        int ret = mp_spiflash_read_data(self, addr, SECTOR_SIZE, cache->buf);\n        if (ret != 0) {\n            return ret;\n        }\n    }\n\n    #if USE_WR_DELAY\n\n    cache->block = sec;\n    \n    memcpy(cache->buf + offset, src, len);\n    \n    self->flags |= 1;\n\n    #else\n\n    uint32_t dirty = 0;\n    for (size_t i = 0; i < len; ++i) {\n        if (cache->buf[offset + i] != src[i]) {\n            if (cache->buf[offset + i] != 0xff) {\n                \n                int ret = mp_spiflash_erase_block_internal(self, addr);\n                if (ret != 0) {\n                    return ret;\n                }\n                dirty = 0xffff;\n                break;\n            } else {\n                dirty |= (1 << ((offset + i) >> 8));\n            }\n        }\n    }\n\n    cache->block = sec;\n    \n    memcpy(cache->buf + offset, src, len);\n\n    \n    for (size_t i = 0; i < 16; ++i) {\n        if (dirty & (1 << i)) {\n            int ret = mp_spiflash_write_page(self, addr + i * PAGE_SIZE, PAGE_SIZE, cache->buf + i * PAGE_SIZE);\n            if (ret != 0) {\n                return ret;\n            }\n        }\n    }\n\n    #endif\n\n    return 0; \n}\n\nint mp_spiflash_cached_write(mp_spiflash_t *self, uint32_t addr, size_t len, const uint8_t *src) {\n    uint32_t bis = addr / SECTOR_SIZE;\n    uint32_t bie = (addr + len - 1) / SECTOR_SIZE;\n\n    mp_spiflash_acquire_bus(self);\n\n    mp_spiflash_cache_t *cache = self->config->cache;\n    if (cache->user == self && bis <= cache->block && bie >= cache->block) {\n        \n        uint32_t pre;\n        uint32_t offset;\n        if (cache->block * SECTOR_SIZE >= addr) {\n            pre = cache->block * SECTOR_SIZE - addr;\n            offset = 0;\n        } else {\n            pre = 0;\n            offset = addr - cache->block * SECTOR_SIZE;\n        }\n\n        \n        uint32_t len_in_buf = len - pre;\n        len = 0;\n        if (len_in_buf > SECTOR_SIZE - offset) {\n            len = len_in_buf - (SECTOR_SIZE - offset);\n            len_in_buf = SECTOR_SIZE - offset;\n        }\n        memcpy(&cache->buf[offset], &src[pre], len_in_buf);\n        self->flags |= 1; \n\n        \n        while (pre) {\n            int rest = pre & (SECTOR_SIZE - 1);\n            if (rest == 0) {\n                rest = SECTOR_SIZE;\n            }\n            int ret = mp_spiflash_cached_write_part(self, addr, rest, src);\n            if (ret != 0) {\n                mp_spiflash_release_bus(self);\n                return ret;\n            }\n            src += rest;\n            addr += rest;\n            pre -= rest;\n        }\n        src += len_in_buf;\n        addr += len_in_buf;\n\n        \n    }\n\n    uint32_t offset = addr & (SECTOR_SIZE - 1);\n    while (len) {\n        int rest = SECTOR_SIZE - offset;\n        if (rest > len) {\n            rest = len;\n        }\n        int ret = mp_spiflash_cached_write_part(self, addr, rest, src);\n        if (ret != 0) {\n            mp_spiflash_release_bus(self);\n            return ret;\n        }\n        len -= rest;\n        addr += rest;\n        src += rest;\n        offset = 0;\n    }\n\n    mp_spiflash_release_bus(self);\n    return 0;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}