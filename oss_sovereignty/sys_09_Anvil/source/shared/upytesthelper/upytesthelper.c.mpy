{
  "module_name": "upytesthelper.c",
  "hash_id": "bfb1718afac2e3ba9fe1f53e603651987d8d341353d3161ba82a2a88f720455b",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/upytesthelper/upytesthelper.c",
  "human_readable_source": " \n#include <string.h>\n\n#include \"py/mphal.h\"\n#include \"py/gc.h\"\n#include \"py/runtime.h\"\n#include \"py/compile.h\"\n#include \"upytesthelper.h\"\n\n#if !MICROPY_PY_SYS_PATH\n#error \"upytesthelper requires MICROPY_PY_SYS_PATH=1\"\n#endif\n\n#if !MICROPY_PY_SYS_ARGV\n#error \"upytesthelper requires MICROPY_PY_SYS_ARGV=1\"\n#endif\n\nstatic const char *test_exp_output;\nstatic int test_exp_output_len, test_rem_output_len;\nstatic int test_failed;\nstatic void *heap_start, *heap_end;\n\nvoid upytest_set_heap(void *start, void *end) {\n    heap_start = start;\n    heap_end = end;\n}\n\nvoid upytest_set_expected_output(const char *output, unsigned len) {\n    test_exp_output = output;\n    test_exp_output_len = test_rem_output_len = len;\n    test_failed = false;\n}\n\nbool upytest_is_failed(void) {\n    if (test_failed) {\n        return true;\n    }\n    #if 0\n    if (test_rem_output_len != 0) {\n        printf(\"remaining len: %d\\n\", test_rem_output_len);\n    }\n    #endif\n    return test_rem_output_len != 0;\n}\n\n\n\n\n\n\nvoid upytest_output(const char *str, mp_uint_t len) {\n    if (!test_failed) {\n        if (len > test_rem_output_len) {\n            test_failed = true;\n        } else {\n            test_failed = memcmp(test_exp_output, str, len);\n            #if 0\n            if (test_failed) {\n                printf(\"failed after char %u, within %d chars, res: %d\\n\",\n                    test_exp_output_len - test_rem_output_len, (int)len, test_failed);\n                for (int i = 0; i < len; i++) {\n                    if (str[i] != test_exp_output[i]) {\n                        printf(\"%d %02x %02x\\n\", i, str[i], test_exp_output[i]);\n                    }\n                }\n            }\n            #endif\n            test_exp_output += len;\n            test_rem_output_len -= len;\n        }\n    }\n    mp_hal_stdout_tx_strn_cooked(str, len);\n}\n\nvoid upytest_execute_test(const char *src) {\n    \n    \n    gc_init(heap_start, heap_end);\n    mp_init();\n    mp_sys_path = mp_obj_new_list(0, NULL);\n    #if MICROPY_MODULE_FROZEN\n    mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR__dot_frozen));\n    #endif\n    mp_obj_list_init(mp_sys_argv, 0);\n\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, strlen(src), 0);\n        qstr source_name = lex->source_name;\n        mp_parse_tree_t parse_tree = mp_parse(lex, MP_PARSE_FILE_INPUT);\n        mp_obj_t module_fun = mp_compile(&parse_tree, source_name, false);\n        mp_call_function_0(module_fun);\n        nlr_pop();\n    } else {\n        mp_obj_t exc = (mp_obj_t)nlr.ret_val;\n        if (mp_obj_is_subclass_fast(mp_obj_get_type(exc), &mp_type_SystemExit)) {\n            \n            \n            \n            tinytest_set_test_skipped_();\n            goto end;\n        }\n        mp_obj_print_exception(&mp_plat_print, exc);\n        tt_abort_msg(\"Uncaught exception\\n\");\n    }\n\n    if (upytest_is_failed()) {\n        tinytest_set_test_failed_();\n    }\n\nend:\n    mp_deinit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}