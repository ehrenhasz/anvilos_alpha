{
  "module_name": "mp_usbd_runtime.c",
  "hash_id": "dcb33a55c9d165003ceccb58613161d08acd635564f90d4819c5c474aca51677",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/tinyusb/mp_usbd_runtime.c",
  "human_readable_source": " \n#include <stdlib.h>\n\n#include \"mp_usbd.h\"\n#include \"py/mpconfig.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n#include \"py/obj.h\"\n#include \"py/objarray.h\"\n#include \"py/objstr.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_HW_ENABLE_USB_RUNTIME_DEVICE\n\n#ifndef NO_QSTR\n#include \"tusb.h\" \n#include \"device/dcd.h\"\n#include \"device/usbd.h\"\n#include \"device/usbd_pvt.h\"\n#endif\n\nstatic bool in_usbd_task; \n\n\n\nstatic void mp_usbd_disconnect(mp_obj_usb_device_t *usbd);\nstatic void mp_usbd_task_inner(void);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic void usbd_pend_exception(mp_obj_t exception) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    assert(usbd != NULL);\n    if (usbd->num_pend_excs < MP_USBD_MAX_PEND_EXCS) {\n        usbd->pend_excs[usbd->num_pend_excs] = exception;\n    }\n    usbd->num_pend_excs++;\n}\n\n\n\n\nstatic mp_obj_t usbd_callback_function_n(mp_obj_t fun, size_t n_args, const mp_obj_t *args) {\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_obj_t ret = mp_call_function_n_kw(fun, n_args, 0, args);\n        nlr_pop();\n        return ret;\n    } else {\n        usbd_pend_exception(MP_OBJ_FROM_PTR(nlr.ret_val));\n        return MP_OBJ_NULL;\n    }\n}\n\n\nstatic void *usbd_get_buffer_in_cb(mp_obj_t obj, mp_uint_t flags) {\n    mp_buffer_info_t buf_info;\n    if (obj == mp_const_none) {\n        \n        return NULL;\n    } else if (mp_get_buffer(obj, &buf_info, flags)) {\n        return buf_info.buf;\n    } else {\n        mp_obj_t exc = mp_obj_new_exception_msg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"object with buffer protocol required\"));\n        usbd_pend_exception(exc);\n        return NULL;\n    }\n}\n\nconst uint8_t *tud_descriptor_device_cb(void) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    const void *result = NULL;\n    if (usbd) {\n        result = usbd_get_buffer_in_cb(usbd->desc_dev, MP_BUFFER_READ);\n    }\n    return result ? result : &mp_usbd_builtin_desc_dev;\n}\n\nconst uint8_t *tud_descriptor_configuration_cb(uint8_t index) {\n    (void)index;\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    const void *result = NULL;\n    if (usbd) {\n        result = usbd_get_buffer_in_cb(usbd->desc_cfg, MP_BUFFER_READ);\n    }\n    return result ? result : &mp_usbd_builtin_desc_cfg;\n}\n\nconst char *mp_usbd_runtime_string_cb(uint8_t index) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    nlr_buf_t nlr;\n\n    if (usbd == NULL || usbd->desc_strs == mp_const_none) {\n        return NULL;\n    }\n\n    if (nlr_push(&nlr) == 0) {\n        mp_obj_t res = mp_obj_subscr(usbd->desc_strs, mp_obj_new_int(index), MP_OBJ_SENTINEL);\n        nlr_pop();\n        if (res != mp_const_none) {\n            return usbd_get_buffer_in_cb(res, MP_BUFFER_READ);\n        }\n    } else {\n        mp_obj_t exception = MP_OBJ_FROM_PTR(nlr.ret_val);\n        if (!(mp_obj_is_type(exception, &mp_type_KeyError) || mp_obj_is_type(exception, &mp_type_IndexError))) {\n            \n            \n            usbd_pend_exception(exception);\n        }\n    }\n\n    return NULL;\n}\n\nbool tud_vendor_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request_t const *request) {\n    return false; \n}\n\n\n\nstatic void runtime_dev_init(void) {\n}\n\nstatic void runtime_dev_reset(uint8_t rhport) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    if (!usbd) {\n        return;\n    }\n\n    for (int epnum = 0; epnum < CFG_TUD_ENDPPOINT_MAX; epnum++) {\n        for (int dir = 0; dir < 2; dir++) {\n            usbd->xfer_data[epnum][dir] = mp_const_none;\n        }\n    }\n\n    if (mp_obj_is_callable(usbd->reset_cb)) {\n        usbd_callback_function_n(usbd->reset_cb, 0, NULL);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic uint8_t _runtime_dev_count_itfs(tusb_desc_interface_t const *itf_desc) {\n    const tusb_desc_configuration_t *cfg_desc = (const void *)tud_descriptor_configuration_cb(0);\n    const uint8_t *p_desc = (const void *)cfg_desc;\n    const uint8_t *p_end = p_desc + cfg_desc->wTotalLength;\n    assert(p_desc <= itf_desc && itf_desc < p_end);\n    while (p_desc != (const void *)itf_desc && p_desc < p_end) {\n        const uint8_t *next = tu_desc_next(p_desc);\n\n        if (tu_desc_type(p_desc) == TUSB_DESC_INTERFACE_ASSOCIATION\n            && next == (const void *)itf_desc) {\n            const tusb_desc_interface_assoc_t *desc_iad = (const void *)p_desc;\n            return desc_iad->bInterfaceCount;\n        }\n        p_desc = next;\n    }\n    return 1; \n}\n\n\n\n\n\n\n\n\n\nstatic uint16_t _runtime_dev_claim_itfs(tusb_desc_interface_t const *itf_desc, uint8_t assoc_itf_count, uint16_t max_len) {\n    const uint8_t *p_desc = (const void *)itf_desc;\n    const uint8_t *p_end = p_desc + max_len;\n    while (p_desc < p_end) {\n        if (tu_desc_type(p_desc) == TUSB_DESC_INTERFACE) {\n            if (assoc_itf_count > 0) {\n                \n                assoc_itf_count--;\n            } else {\n                \n                break;\n            }\n        } else if (tu_desc_type(p_desc) == TUSB_DESC_ENDPOINT) {\n            \n            if (tu_desc_type(p_desc) == TUSB_DESC_ENDPOINT) {\n                bool r = usbd_edpt_open(USBD_RHPORT, (const void *)p_desc);\n                if (!r) {\n                    mp_obj_t exc = mp_obj_new_exception_arg1(&mp_type_OSError, MP_OBJ_NEW_SMALL_INT(MP_ENODEV));\n                    usbd_pend_exception(exc);\n                    break;\n                }\n            }\n        }\n        p_desc = tu_desc_next(p_desc);\n    }\n    return p_desc - (const uint8_t *)itf_desc;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic uint16_t runtime_dev_open(uint8_t rhport, tusb_desc_interface_t const *itf_desc, uint16_t max_len) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n\n    \n    if (!usbd) {\n        return 0;\n    }\n\n    \n    if (mp_usb_device_builtin_enabled(usbd) && itf_desc->bInterfaceNumber < USBD_ITF_BUILTIN_MAX) {\n        return 0;\n    }\n\n    \n    uint8_t assoc_itf_count = _runtime_dev_count_itfs(itf_desc);\n    uint16_t claim_len = _runtime_dev_claim_itfs(itf_desc, assoc_itf_count, max_len);\n\n    \n\n    if (mp_obj_is_callable(usbd->open_itf_cb)) {\n        \n        usbd->control_data->items = (void *)itf_desc;\n        usbd->control_data->len = claim_len;\n        mp_obj_t args[] = { MP_OBJ_FROM_PTR(usbd->control_data) };\n        usbd_callback_function_n(usbd->open_itf_cb, 1, args);\n        usbd->control_data->len = 0;\n        usbd->control_data->items = NULL;\n    }\n\n    return claim_len;\n}\n\nstatic bool runtime_dev_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request_t const *request) {\n    mp_obj_t cb_res = mp_const_false;\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    tusb_dir_t dir = request->bmRequestType_bit.direction;\n    mp_buffer_info_t buf_info;\n    bool result;\n\n    if (!usbd) {\n        return false;\n    }\n\n    if (mp_obj_is_callable(usbd->control_xfer_cb)) {\n        usbd->control_data->items = (void *)request;\n        usbd->control_data->len = sizeof(tusb_control_request_t);\n        mp_obj_t args[] = {\n            mp_obj_new_int(stage),\n            MP_OBJ_FROM_PTR(usbd->control_data),\n        };\n        cb_res = usbd_callback_function_n(usbd->control_xfer_cb, MP_ARRAY_SIZE(args), args);\n        usbd->control_data->items = NULL;\n        usbd->control_data->len = 0;\n\n        if (cb_res == MP_OBJ_NULL) {\n            \n            cb_res = mp_const_false;\n        }\n    }\n\n    \n    if (mp_get_buffer(cb_res, &buf_info, dir == TUSB_DIR_IN ? MP_BUFFER_READ : MP_BUFFER_RW)) {\n        result = tud_control_xfer(USBD_RHPORT,\n            request,\n            buf_info.buf,\n            buf_info.len);\n\n        if (result) {\n            \n            usbd->xfer_data[0][dir] = cb_res;\n        }\n    } else {\n        \n        result = mp_obj_is_true(cb_res);\n\n        if (stage == CONTROL_STAGE_SETUP && result) {\n            \n            \n            tud_control_status(rhport, request);\n        } else if (stage == CONTROL_STAGE_ACK) {\n            \n            usbd->xfer_data[0][dir] = mp_const_none;\n        }\n    }\n\n    return result;\n}\n\nstatic bool runtime_dev_xfer_cb(uint8_t rhport, uint8_t ep_addr, xfer_result_t result, uint32_t xferred_bytes) {\n    mp_obj_t ep = mp_obj_new_int(ep_addr);\n    mp_obj_t cb_res = mp_const_false;\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    if (!usbd) {\n        return false;\n    }\n\n    if (mp_obj_is_callable(usbd->xfer_cb)) {\n        mp_obj_t args[] = {\n            ep,\n            MP_OBJ_NEW_SMALL_INT(result),\n            MP_OBJ_NEW_SMALL_INT(xferred_bytes),\n        };\n        cb_res = usbd_callback_function_n(usbd->xfer_cb, MP_ARRAY_SIZE(args), args);\n    }\n\n    \n    usbd->xfer_data[tu_edpt_number(ep_addr)][tu_edpt_dir(ep_addr)] = mp_const_none;\n\n    return cb_res != MP_OBJ_NULL && mp_obj_is_true(cb_res);\n}\n\nstatic usbd_class_driver_t const _runtime_dev_driver =\n{\n    #if CFG_TUSB_DEBUG >= 2\n    .name = \"runtime_dev\",\n    #endif\n    .init = runtime_dev_init,\n    .reset = runtime_dev_reset,\n    .open = runtime_dev_open,\n    .control_xfer_cb = runtime_dev_control_xfer_cb,\n    .xfer_cb = runtime_dev_xfer_cb,\n    .sof = NULL\n};\n\nusbd_class_driver_t const *usbd_app_driver_get_cb(uint8_t *driver_count) {\n    *driver_count = 1;\n    return &_runtime_dev_driver;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mp_usbd_init(void) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    bool need_usb;\n\n    if (usbd == NULL) {\n        \n        #if CFG_TUD_CDC || CFG_TUD_MSC\n        \n        need_usb = true;\n        #else\n        \n        need_usb = false;\n        #endif\n    } else {\n        \n        need_usb = usbd->active;\n    }\n\n    if (need_usb) {\n        tusb_init(); \n        tud_connect(); \n    }\n}\n\n\n\n\n\n\nvoid mp_usbd_deinit(void) {\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n    MP_STATE_VM(usbd) = MP_OBJ_NULL;\n    if (usbd && usbd->active) {\n        \n        mp_usbd_disconnect(usbd);\n    }\n}\n\n\n\nstatic void mp_usbd_disconnect(mp_obj_usb_device_t *usbd) {\n    if (!tusb_inited()) {\n        return; \n    }\n\n    if (usbd) {\n        \n        \n        \n        \n        for (int epnum = 0; epnum < CFG_TUD_ENDPPOINT_MAX; epnum++) {\n            for (int dir = 0; dir < 2; dir++) {\n                if (usbd->xfer_data[epnum][dir] != mp_const_none) {\n                    usbd_edpt_stall(USBD_RHPORT, tu_edpt_addr(epnum, dir));\n                    usbd->xfer_data[epnum][dir] = mp_const_none;\n                }\n            }\n        }\n    }\n\n    #if MICROPY_HW_USB_CDC\n    \n    tud_cdc_write_clear();\n    \n    usbd_edpt_stall(USBD_RHPORT, USBD_CDC_EP_IN);\n    #endif\n\n    bool was_connected = tud_connected();\n    tud_disconnect();\n    if (was_connected) {\n        \n        \n        \n        mp_hal_delay_ms(50);\n    }\n}\n\n\nvoid mp_usbd_task_callback(mp_sched_node_t *node) {\n    if (tud_inited() && !in_usbd_task) {\n        mp_usbd_task_inner();\n    }\n    \n    \n    \n    \n    \n}\n\n\n\nvoid mp_usbd_task(void) {\n    if (in_usbd_task) {\n        \n        \n        \n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"TinyUSB callback can't recurse\"));\n    }\n\n    mp_usbd_task_inner();\n}\n\nstatic void mp_usbd_task_inner(void) {\n    in_usbd_task = true;\n\n    tud_task_ext(0, false);\n\n    mp_obj_usb_device_t *usbd = MP_OBJ_TO_PTR(MP_STATE_VM(usbd));\n\n    \n    if (usbd && usbd->trigger) {\n        if (usbd->active) {\n            if (tud_connected()) {\n                \n                \n                \n                \n                mp_usbd_disconnect(usbd);\n            }\n            tud_connect();\n        } else {\n            mp_usbd_disconnect(usbd);\n        }\n        usbd->trigger = false;\n    }\n\n    in_usbd_task = false;\n\n    if (usbd) {\n        \n        \n\n        \n        \n        mp_uint_t num_pend_excs = usbd->num_pend_excs;\n        mp_obj_t pend_excs[MP_USBD_MAX_PEND_EXCS];\n        for (mp_uint_t i = 0; i < MIN(MP_USBD_MAX_PEND_EXCS, num_pend_excs); i++) {\n            pend_excs[i] = usbd->pend_excs[i];\n            usbd->pend_excs[i] = mp_const_none;\n        }\n        usbd->num_pend_excs = 0;\n\n        \n        for (mp_uint_t i = 0; i < MIN(MP_USBD_MAX_PEND_EXCS, num_pend_excs); i++) {\n            mp_obj_print_exception(&mp_plat_print, pend_excs[i]);\n        }\n        if (num_pend_excs > MP_USBD_MAX_PEND_EXCS) {\n            mp_printf(&mp_plat_print, \"%u additional exceptions in USB callbacks\\n\",\n                num_pend_excs - MP_USBD_MAX_PEND_EXCS);\n        }\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}