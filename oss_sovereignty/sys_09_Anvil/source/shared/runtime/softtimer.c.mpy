{
  "module_name": "softtimer.c",
  "hash_id": "703b0e8cec3e74a0c902b0495f338c1ac0a3de10f3bd6dafca8287c1bdaf5447",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/runtime/softtimer.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include \"py/gc.h\"\n#include \"py/mphal.h\"\n#include \"py/runtime.h\"\n#include \"softtimer.h\"\n\n#ifdef MICROPY_SOFT_TIMER_TICKS_MS\n\nextern __IO uint32_t MICROPY_SOFT_TIMER_TICKS_MS;\n\nvolatile uint32_t soft_timer_next;\n\nstatic inline uint32_t soft_timer_get_ms(void) {\n    return MICROPY_SOFT_TIMER_TICKS_MS;\n}\n\nstatic void soft_timer_schedule_at_ms(uint32_t ticks_ms) {\n    uint32_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    uint32_t uw_tick = MICROPY_SOFT_TIMER_TICKS_MS;\n    if (soft_timer_ticks_diff(ticks_ms, uw_tick) <= 0) {\n        soft_timer_next = uw_tick + 1;\n    } else {\n        soft_timer_next = ticks_ms;\n    }\n    MICROPY_END_ATOMIC_SECTION(atomic_state);\n}\n\n#endif\n\n\n\n\nstatic soft_timer_entry_t *soft_timer_heap;\n\nstatic int soft_timer_lt(mp_pairheap_t *n1, mp_pairheap_t *n2) {\n    soft_timer_entry_t *e1 = (soft_timer_entry_t *)n1;\n    soft_timer_entry_t *e2 = (soft_timer_entry_t *)n2;\n    return soft_timer_ticks_diff(e1->expiry_ms, e2->expiry_ms) < 0;\n}\n\nvoid soft_timer_deinit(void) {\n    \n    MICROPY_PY_PENDSV_ENTER;\n    soft_timer_entry_t *heap_from = soft_timer_heap;\n    soft_timer_entry_t *heap_to = (soft_timer_entry_t *)mp_pairheap_new(soft_timer_lt);\n    while (heap_from != NULL) {\n        soft_timer_entry_t *entry = (soft_timer_entry_t *)mp_pairheap_peek(soft_timer_lt, &heap_from->pairheap);\n        heap_from = (soft_timer_entry_t *)mp_pairheap_pop(soft_timer_lt, &heap_from->pairheap);\n        if (!(entry->flags & SOFT_TIMER_FLAG_GC_ALLOCATED)) {\n            heap_to = (soft_timer_entry_t *)mp_pairheap_push(soft_timer_lt, &heap_to->pairheap, &entry->pairheap);\n        }\n    }\n    soft_timer_heap = heap_to;\n    MICROPY_PY_PENDSV_EXIT;\n}\n\n\nvoid soft_timer_handler(void) {\n    uint32_t ticks_ms = soft_timer_get_ms();\n    soft_timer_entry_t *heap = soft_timer_heap;\n    while (heap != NULL && soft_timer_ticks_diff(heap->expiry_ms, ticks_ms) <= 0) {\n        soft_timer_entry_t *entry = heap;\n        heap = (soft_timer_entry_t *)mp_pairheap_pop(soft_timer_lt, &heap->pairheap);\n        if (entry->flags & SOFT_TIMER_FLAG_PY_CALLBACK) {\n            mp_sched_schedule(entry->py_callback, MP_OBJ_FROM_PTR(entry));\n        } else {\n            entry->c_callback(entry);\n        }\n        if (entry->mode == SOFT_TIMER_MODE_PERIODIC) {\n            entry->expiry_ms += entry->delta_ms;\n            heap = (soft_timer_entry_t *)mp_pairheap_push(soft_timer_lt, &heap->pairheap, &entry->pairheap);\n        }\n    }\n    soft_timer_heap = heap;\n\n    \n    if (heap != NULL) {\n        soft_timer_schedule_at_ms(heap->expiry_ms);\n    }\n}\n\nvoid soft_timer_gc_mark_all(void) {\n    \n    \n    MICROPY_PY_PENDSV_ENTER;\n    soft_timer_entry_t *heap_from = soft_timer_heap;\n    soft_timer_entry_t *heap_to = (soft_timer_entry_t *)mp_pairheap_new(soft_timer_lt);\n    while (heap_from != NULL) {\n        soft_timer_entry_t *entry = (soft_timer_entry_t *)mp_pairheap_peek(soft_timer_lt, &heap_from->pairheap);\n        heap_from = (soft_timer_entry_t *)mp_pairheap_pop(soft_timer_lt, &heap_from->pairheap);\n        if (entry->flags & SOFT_TIMER_FLAG_GC_ALLOCATED) {\n            gc_collect_root((void **)&entry, 1);\n        }\n        heap_to = (soft_timer_entry_t *)mp_pairheap_push(soft_timer_lt, &heap_to->pairheap, &entry->pairheap);\n    }\n    soft_timer_heap = heap_to;\n    MICROPY_PY_PENDSV_EXIT;\n}\n\nvoid soft_timer_static_init(soft_timer_entry_t *entry, uint16_t mode, uint32_t delta_ms, void (*cb)(soft_timer_entry_t *)) {\n    mp_pairheap_init_node(soft_timer_lt, &entry->pairheap);\n    entry->flags = 0;\n    entry->mode = mode;\n    entry->delta_ms = delta_ms;\n    entry->c_callback = cb;\n}\n\nvoid soft_timer_insert(soft_timer_entry_t *entry, uint32_t initial_delta_ms) {\n    mp_pairheap_init_node(soft_timer_lt, &entry->pairheap);\n    entry->expiry_ms = soft_timer_get_ms() + initial_delta_ms;\n    MICROPY_PY_PENDSV_ENTER;\n    soft_timer_heap = (soft_timer_entry_t *)mp_pairheap_push(soft_timer_lt, &soft_timer_heap->pairheap, &entry->pairheap);\n    if (entry == soft_timer_heap) {\n        \n        soft_timer_schedule_at_ms(entry->expiry_ms);\n    }\n    MICROPY_PY_PENDSV_EXIT;\n}\n\nvoid soft_timer_remove(soft_timer_entry_t *entry) {\n    MICROPY_PY_PENDSV_ENTER;\n    soft_timer_heap = (soft_timer_entry_t *)mp_pairheap_delete(soft_timer_lt, &soft_timer_heap->pairheap, &entry->pairheap);\n    MICROPY_PY_PENDSV_EXIT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}