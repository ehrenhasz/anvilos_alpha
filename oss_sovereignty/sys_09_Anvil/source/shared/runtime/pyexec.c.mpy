{
  "module_name": "pyexec.c",
  "hash_id": "e38821ccc24fe592949bab7524f221bea647ad2b5213cdbc6d7e97a83f234d2a",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/runtime/pyexec.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/compile.h\"\n#include \"py/runtime.h\"\n#include \"py/repl.h\"\n#include \"py/gc.h\"\n#include \"py/frozenmod.h\"\n#include \"py/mphal.h\"\n#if MICROPY_HW_ENABLE_USB\n#include \"irq.h\"\n#include \"usb.h\"\n#endif\n#include \"shared/readline/readline.h\"\n#include \"shared/runtime/pyexec.h\"\n#include \"genhdr/mpversion.h\"\n\npyexec_mode_kind_t pyexec_mode_kind = PYEXEC_MODE_FRIENDLY_REPL;\nint pyexec_system_exit = 0;\n\n#if MICROPY_REPL_INFO\nstatic bool repl_display_debugging_info = 0;\n#endif\n\n#define EXEC_FLAG_PRINT_EOF             (1 << 0)\n#define EXEC_FLAG_ALLOW_DEBUGGING       (1 << 1)\n#define EXEC_FLAG_IS_REPL               (1 << 2)\n#define EXEC_FLAG_SOURCE_IS_RAW_CODE    (1 << 3)\n#define EXEC_FLAG_SOURCE_IS_VSTR        (1 << 4)\n#define EXEC_FLAG_SOURCE_IS_FILENAME    (1 << 5)\n#define EXEC_FLAG_SOURCE_IS_READER      (1 << 6)\n#define EXEC_FLAG_NO_INTERRUPT          (1 << 7)\n\n\n\n\n\n\nstatic int parse_compile_execute(const void *source, mp_parse_input_kind_t input_kind, mp_uint_t exec_flags) {\n    int ret = 0;\n    #if MICROPY_REPL_INFO\n    uint32_t start = 0;\n    #endif\n\n    #ifdef MICROPY_BOARD_BEFORE_PYTHON_EXEC\n    MICROPY_BOARD_BEFORE_PYTHON_EXEC(input_kind, exec_flags);\n    #endif\n\n    \n    pyexec_system_exit = 0;\n\n    nlr_buf_t nlr;\n    nlr.ret_val = NULL;\n    if (nlr_push(&nlr) == 0) {\n        mp_obj_t module_fun;\n        #if MICROPY_MODULE_FROZEN_MPY\n        if (exec_flags & EXEC_FLAG_SOURCE_IS_RAW_CODE) {\n            \n            const mp_frozen_module_t *frozen = source;\n            mp_module_context_t *ctx = m_new_obj(mp_module_context_t);\n            ctx->module.globals = mp_globals_get();\n            ctx->constants = frozen->constants;\n            module_fun = mp_make_function_from_proto_fun(frozen->proto_fun, ctx, NULL);\n        } else\n        #endif\n        {\n            #if MICROPY_ENABLE_COMPILER\n            mp_lexer_t *lex;\n            if (exec_flags & EXEC_FLAG_SOURCE_IS_VSTR) {\n                const vstr_t *vstr = source;\n                lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, vstr->buf, vstr->len, 0);\n            } else if (exec_flags & EXEC_FLAG_SOURCE_IS_READER) {\n                lex = mp_lexer_new(MP_QSTR__lt_stdin_gt_, *(mp_reader_t *)source);\n            } else if (exec_flags & EXEC_FLAG_SOURCE_IS_FILENAME) {\n                lex = mp_lexer_new_from_file(qstr_from_str(source));\n            } else {\n                lex = (mp_lexer_t *)source;\n            }\n            \n            qstr source_name = lex->source_name;\n            mp_parse_tree_t parse_tree = mp_parse(lex, input_kind);\n            module_fun = mp_compile(&parse_tree, source_name, exec_flags & EXEC_FLAG_IS_REPL);\n            #else\n            mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"script compilation not supported\"));\n            #endif\n        }\n\n        \n        if (!(exec_flags & EXEC_FLAG_NO_INTERRUPT)) {\n            mp_hal_set_interrupt_char(CHAR_CTRL_C);\n        }\n        #if MICROPY_REPL_INFO\n        start = mp_hal_ticks_ms();\n        #endif\n        mp_call_function_0(module_fun);\n        mp_hal_set_interrupt_char(-1); \n        mp_handle_pending(true); \n        nlr_pop();\n        ret = 1;\n        if (exec_flags & EXEC_FLAG_PRINT_EOF) {\n            mp_hal_stdout_tx_strn(\"\\x04\", 1);\n        }\n    } else {\n        \n        mp_hal_set_interrupt_char(-1); \n        mp_handle_pending(false); \n\n        if (exec_flags & EXEC_FLAG_SOURCE_IS_READER) {\n            const mp_reader_t *reader = source;\n            reader->close(reader->data);\n        }\n\n        \n        if (exec_flags & EXEC_FLAG_PRINT_EOF) {\n            mp_hal_stdout_tx_strn(\"\\x04\", 1);\n        }\n\n        \n        if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t *)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_SystemExit))) {\n            \n            ret = pyexec_system_exit;\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n            ret = 0;\n        }\n    }\n\n    #if MICROPY_REPL_INFO\n    \n    if ((exec_flags & EXEC_FLAG_ALLOW_DEBUGGING) && repl_display_debugging_info) {\n        mp_uint_t ticks = mp_hal_ticks_ms() - start; \n        mp_printf(&mp_plat_print, \"took \" UINT_FMT \" ms\\n\", ticks);\n        \n        {\n            size_t n_pool, n_qstr, n_str_data_bytes, n_total_bytes;\n            qstr_pool_info(&n_pool, &n_qstr, &n_str_data_bytes, &n_total_bytes);\n            mp_printf(&mp_plat_print, \"qstr:\\n  n_pool=%u\\n  n_qstr=%u\\n  \"\n                \"n_str_data_bytes=%u\\n  n_total_bytes=%u\\n\",\n                (unsigned)n_pool, (unsigned)n_qstr, (unsigned)n_str_data_bytes, (unsigned)n_total_bytes);\n        }\n\n        #if MICROPY_ENABLE_GC\n        \n        gc_collect();\n        gc_dump_info(&mp_plat_print);\n        #endif\n    }\n    #endif\n\n    if (exec_flags & EXEC_FLAG_PRINT_EOF) {\n        mp_hal_stdout_tx_strn(\"\\x04\", 1);\n    }\n\n    #ifdef MICROPY_BOARD_AFTER_PYTHON_EXEC\n    MICROPY_BOARD_AFTER_PYTHON_EXEC(input_kind, exec_flags, nlr.ret_val, &ret);\n    #endif\n\n    return ret;\n}\n\n#if MICROPY_ENABLE_COMPILER\n\n\n\n\n#ifndef MICROPY_REPL_STDIN_BUFFER_MAX\n#define MICROPY_REPL_STDIN_BUFFER_MAX (256)\n#endif\n\ntypedef struct _mp_reader_stdin_t {\n    bool eof;\n    uint16_t window_max;\n    uint16_t window_remain;\n} mp_reader_stdin_t;\n\nstatic mp_uint_t mp_reader_stdin_readbyte(void *data) {\n    mp_reader_stdin_t *reader = (mp_reader_stdin_t *)data;\n\n    if (reader->eof) {\n        return MP_READER_EOF;\n    }\n\n    int c = mp_hal_stdin_rx_chr();\n\n    if (c == CHAR_CTRL_C || c == CHAR_CTRL_D) {\n        reader->eof = true;\n        mp_hal_stdout_tx_strn(\"\\x04\", 1); \n        if (c == CHAR_CTRL_C) {\n            #if MICROPY_KBD_EXCEPTION\n            MP_STATE_VM(mp_kbd_exception).traceback_data = NULL;\n            nlr_raise(MP_OBJ_FROM_PTR(&MP_STATE_VM(mp_kbd_exception)));\n            #else\n            mp_raise_type(&mp_type_KeyboardInterrupt);\n            #endif\n        } else {\n            return MP_READER_EOF;\n        }\n    }\n\n    if (--reader->window_remain == 0) {\n        mp_hal_stdout_tx_strn(\"\\x01\", 1); \n        reader->window_remain = reader->window_max;\n    }\n\n    return c;\n}\n\nstatic void mp_reader_stdin_close(void *data) {\n    mp_reader_stdin_t *reader = (mp_reader_stdin_t *)data;\n    if (!reader->eof) {\n        reader->eof = true;\n        mp_hal_stdout_tx_strn(\"\\x04\", 1); \n        for (;;) {\n            int c = mp_hal_stdin_rx_chr();\n            if (c == CHAR_CTRL_C || c == CHAR_CTRL_D) {\n                break;\n            }\n        }\n    }\n}\n\nstatic void mp_reader_new_stdin(mp_reader_t *reader, mp_reader_stdin_t *reader_stdin, uint16_t buf_max) {\n    \n    \n    \n    size_t window = buf_max / 2;\n    char reply[3] = { window & 0xff, window >> 8, 0x01 };\n    mp_hal_stdout_tx_strn(reply, sizeof(reply));\n\n    reader_stdin->eof = false;\n    reader_stdin->window_max = window;\n    reader_stdin->window_remain = window;\n    reader->data = reader_stdin;\n    reader->readbyte = mp_reader_stdin_readbyte;\n    reader->close = mp_reader_stdin_close;\n}\n\nstatic int do_reader_stdin(int c) {\n    if (c != 'A') {\n        \n        mp_hal_stdout_tx_strn(\"R\\x00\", 2);\n        return 0;\n    }\n\n    \n    mp_hal_stdout_tx_strn(\"R\\x01\", 2);\n\n    mp_reader_t reader;\n    mp_reader_stdin_t reader_stdin;\n    mp_reader_new_stdin(&reader, &reader_stdin, MICROPY_REPL_STDIN_BUFFER_MAX);\n    int exec_flags = EXEC_FLAG_PRINT_EOF | EXEC_FLAG_SOURCE_IS_READER;\n    return parse_compile_execute(&reader, MP_PARSE_FILE_INPUT, exec_flags);\n}\n\n#if MICROPY_REPL_EVENT_DRIVEN\n\ntypedef struct _repl_t {\n    \n    \n    \n    \n    \n    bool cont_line;\n    bool paste_mode;\n} repl_t;\n\nrepl_t repl;\n\nstatic int pyexec_raw_repl_process_char(int c);\nstatic int pyexec_friendly_repl_process_char(int c);\n\nvoid pyexec_event_repl_init(void) {\n    MP_STATE_VM(repl_line) = vstr_new(32);\n    repl.cont_line = false;\n    repl.paste_mode = false;\n    \n    readline_init(MP_STATE_VM(repl_line), \"\");\n    if (pyexec_mode_kind == PYEXEC_MODE_RAW_REPL) {\n        pyexec_raw_repl_process_char(CHAR_CTRL_A);\n    } else {\n        pyexec_friendly_repl_process_char(CHAR_CTRL_B);\n    }\n}\n\nstatic int pyexec_raw_repl_process_char(int c) {\n    if (c == CHAR_CTRL_A) {\n        \n        if (vstr_len(MP_STATE_VM(repl_line)) == 2 && vstr_str(MP_STATE_VM(repl_line))[0] == CHAR_CTRL_E) {\n            int ret = do_reader_stdin(vstr_str(MP_STATE_VM(repl_line))[1]);\n            if (ret & PYEXEC_FORCED_EXIT) {\n                return ret;\n            }\n            goto reset;\n        }\n        mp_hal_stdout_tx_str(\"raw REPL; CTRL-B to exit\\r\\n\");\n        goto reset;\n    } else if (c == CHAR_CTRL_B) {\n        \n        pyexec_mode_kind = PYEXEC_MODE_FRIENDLY_REPL;\n        vstr_reset(MP_STATE_VM(repl_line));\n        repl.cont_line = false;\n        repl.paste_mode = false;\n        pyexec_friendly_repl_process_char(CHAR_CTRL_B);\n        return 0;\n    } else if (c == CHAR_CTRL_C) {\n        \n        vstr_reset(MP_STATE_VM(repl_line));\n        return 0;\n    } else if (c == CHAR_CTRL_D) {\n        \n    } else {\n        \n        vstr_add_byte(MP_STATE_VM(repl_line), c);\n        return 0;\n    }\n\n    \n    mp_hal_stdout_tx_str(\"OK\");\n\n    if (MP_STATE_VM(repl_line)->len == 0) {\n        \n        mp_hal_stdout_tx_str(\"\\r\\n\");\n        vstr_clear(MP_STATE_VM(repl_line));\n        return PYEXEC_FORCED_EXIT;\n    }\n\n    int ret = parse_compile_execute(MP_STATE_VM(repl_line), MP_PARSE_FILE_INPUT, EXEC_FLAG_PRINT_EOF | EXEC_FLAG_SOURCE_IS_VSTR);\n    if (ret & PYEXEC_FORCED_EXIT) {\n        return ret;\n    }\n\nreset:\n    vstr_reset(MP_STATE_VM(repl_line));\n    mp_hal_stdout_tx_str(\">\");\n\n    return 0;\n}\n\nstatic int pyexec_friendly_repl_process_char(int c) {\n    if (repl.paste_mode) {\n        if (c == CHAR_CTRL_C) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            goto input_restart;\n        } else if (c == CHAR_CTRL_D) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            int ret = parse_compile_execute(MP_STATE_VM(repl_line), MP_PARSE_FILE_INPUT, EXEC_FLAG_ALLOW_DEBUGGING | EXEC_FLAG_IS_REPL | EXEC_FLAG_SOURCE_IS_VSTR);\n            if (ret & PYEXEC_FORCED_EXIT) {\n                return ret;\n            }\n            goto input_restart;\n        } else {\n            \n            vstr_add_byte(MP_STATE_VM(repl_line), c);\n            if (c == '\\r') {\n                mp_hal_stdout_tx_str(\"\\r\\n=== \");\n            } else {\n                char buf[1] = {c};\n                mp_hal_stdout_tx_strn(buf, 1);\n            }\n            return 0;\n        }\n    }\n\n    int ret = readline_process_char(c);\n\n    if (!repl.cont_line) {\n\n        if (ret == CHAR_CTRL_A) {\n            \n            pyexec_mode_kind = PYEXEC_MODE_RAW_REPL;\n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            pyexec_raw_repl_process_char(CHAR_CTRL_A);\n            return 0;\n        } else if (ret == CHAR_CTRL_B) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            mp_hal_stdout_tx_str(MICROPY_BANNER_NAME_AND_VERSION);\n            mp_hal_stdout_tx_str(\"; \" MICROPY_BANNER_MACHINE);\n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            #if MICROPY_PY_BUILTINS_HELP\n            mp_hal_stdout_tx_str(\"Type \\\"help()\\\" for more information.\\r\\n\");\n            #endif\n            goto input_restart;\n        } else if (ret == CHAR_CTRL_C) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            goto input_restart;\n        } else if (ret == CHAR_CTRL_D) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            vstr_clear(MP_STATE_VM(repl_line));\n            return PYEXEC_FORCED_EXIT;\n        } else if (ret == CHAR_CTRL_E) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\npaste mode; Ctrl-C to cancel, Ctrl-D to finish\\r\\n=== \");\n            vstr_reset(MP_STATE_VM(repl_line));\n            repl.paste_mode = true;\n            return 0;\n        }\n\n        if (ret < 0) {\n            return 0;\n        }\n\n        if (!mp_repl_continue_with_input(vstr_null_terminated_str(MP_STATE_VM(repl_line)))) {\n            goto exec;\n        }\n\n        vstr_add_byte(MP_STATE_VM(repl_line), '\\n');\n        repl.cont_line = true;\n        readline_note_newline(mp_repl_get_ps2());\n        return 0;\n\n    } else {\n\n        if (ret == CHAR_CTRL_C) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            repl.cont_line = false;\n            goto input_restart;\n        } else if (ret == CHAR_CTRL_D) {\n            \n            goto exec;\n        }\n\n        if (ret < 0) {\n            return 0;\n        }\n\n        if (mp_repl_continue_with_input(vstr_null_terminated_str(MP_STATE_VM(repl_line)))) {\n            vstr_add_byte(MP_STATE_VM(repl_line), '\\n');\n            readline_note_newline(mp_repl_get_ps2());\n            return 0;\n        }\n\n    exec:;\n        int ret = parse_compile_execute(MP_STATE_VM(repl_line), MP_PARSE_SINGLE_INPUT, EXEC_FLAG_ALLOW_DEBUGGING | EXEC_FLAG_IS_REPL | EXEC_FLAG_SOURCE_IS_VSTR);\n        if (ret & PYEXEC_FORCED_EXIT) {\n            return ret;\n        }\n\n    input_restart:\n        vstr_reset(MP_STATE_VM(repl_line));\n        repl.cont_line = false;\n        repl.paste_mode = false;\n        readline_init(MP_STATE_VM(repl_line), mp_repl_get_ps1());\n        return 0;\n    }\n}\n\nuint8_t pyexec_repl_active;\nint pyexec_event_repl_process_char(int c) {\n    pyexec_repl_active = 1;\n    int res;\n    if (pyexec_mode_kind == PYEXEC_MODE_RAW_REPL) {\n        res = pyexec_raw_repl_process_char(c);\n    } else {\n        res = pyexec_friendly_repl_process_char(c);\n    }\n    pyexec_repl_active = 0;\n    return res;\n}\n\nMP_REGISTER_ROOT_POINTER(vstr_t * repl_line);\n\n#else \n\nint pyexec_raw_repl(void) {\n    vstr_t line;\n    vstr_init(&line, 32);\n\nraw_repl_reset:\n    mp_hal_stdout_tx_str(\"raw REPL; CTRL-B to exit\\r\\n\");\n\n    for (;;) {\n        vstr_reset(&line);\n        mp_hal_stdout_tx_str(\">\");\n        for (;;) {\n            int c = mp_hal_stdin_rx_chr();\n            if (c == CHAR_CTRL_A) {\n                \n                if (vstr_len(&line) == 2 && vstr_str(&line)[0] == CHAR_CTRL_E) {\n                    int ret = do_reader_stdin(vstr_str(&line)[1]);\n                    if (ret & PYEXEC_FORCED_EXIT) {\n                        return ret;\n                    }\n                    vstr_reset(&line);\n                    mp_hal_stdout_tx_str(\">\");\n                    continue;\n                }\n                goto raw_repl_reset;\n            } else if (c == CHAR_CTRL_B) {\n                \n                mp_hal_stdout_tx_str(\"\\r\\n\");\n                vstr_clear(&line);\n                pyexec_mode_kind = PYEXEC_MODE_FRIENDLY_REPL;\n                return 0;\n            } else if (c == CHAR_CTRL_C) {\n                \n                vstr_reset(&line);\n            } else if (c == CHAR_CTRL_D) {\n                \n                break;\n            } else {\n                \n                vstr_add_byte(&line, c);\n            }\n        }\n\n        \n        mp_hal_stdout_tx_str(\"OK\");\n\n        if (line.len == 0) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            vstr_clear(&line);\n            return PYEXEC_FORCED_EXIT;\n        }\n\n        int ret = parse_compile_execute(&line, MP_PARSE_FILE_INPUT, EXEC_FLAG_PRINT_EOF | EXEC_FLAG_SOURCE_IS_VSTR);\n        if (ret & PYEXEC_FORCED_EXIT) {\n            return ret;\n        }\n    }\n}\n\nint pyexec_friendly_repl(void) {\n    vstr_t line;\n    vstr_init(&line, 32);\n\nfriendly_repl_reset:\n    mp_hal_stdout_tx_str(MICROPY_BANNER_NAME_AND_VERSION);\n    mp_hal_stdout_tx_str(\"; \" MICROPY_BANNER_MACHINE);\n    mp_hal_stdout_tx_str(\"\\r\\n\");\n    #if MICROPY_PY_BUILTINS_HELP\n    mp_hal_stdout_tx_str(\"Type \\\"help()\\\" for more information.\\r\\n\");\n    #endif\n\n    \n     \n\n    for (;;) {\n    input_restart:\n\n        #if MICROPY_HW_ENABLE_USB\n        if (usb_vcp_is_enabled()) {\n            \n            \n            \n            \n            if (query_irq() == IRQ_STATE_DISABLED) {\n                enable_irq(IRQ_STATE_ENABLED);\n                mp_hal_stdout_tx_str(\"MPY: enabling IRQs\\r\\n\");\n            }\n        }\n        #endif\n\n        \n        \n        if (MP_STATE_THREAD(gc_lock_depth) != 0) {\n            MP_STATE_THREAD(gc_lock_depth) = 0;\n        }\n\n        vstr_reset(&line);\n        int ret = readline(&line, mp_repl_get_ps1());\n        mp_parse_input_kind_t parse_input_kind = MP_PARSE_SINGLE_INPUT;\n\n        if (ret == CHAR_CTRL_A) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            vstr_clear(&line);\n            pyexec_mode_kind = PYEXEC_MODE_RAW_REPL;\n            return 0;\n        } else if (ret == CHAR_CTRL_B) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            goto friendly_repl_reset;\n        } else if (ret == CHAR_CTRL_C) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            continue;\n        } else if (ret == CHAR_CTRL_D) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            vstr_clear(&line);\n            return PYEXEC_FORCED_EXIT;\n        } else if (ret == CHAR_CTRL_E) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\npaste mode; Ctrl-C to cancel, Ctrl-D to finish\\r\\n=== \");\n            vstr_reset(&line);\n            for (;;) {\n                char c = mp_hal_stdin_rx_chr();\n                if (c == CHAR_CTRL_C) {\n                    \n                    mp_hal_stdout_tx_str(\"\\r\\n\");\n                    goto input_restart;\n                } else if (c == CHAR_CTRL_D) {\n                    \n                    mp_hal_stdout_tx_str(\"\\r\\n\");\n                    break;\n                } else {\n                    \n                    vstr_add_byte(&line, c);\n                    if (c == '\\r') {\n                        mp_hal_stdout_tx_str(\"\\r\\n=== \");\n                    } else {\n                        mp_hal_stdout_tx_strn(&c, 1);\n                    }\n                }\n            }\n            parse_input_kind = MP_PARSE_FILE_INPUT;\n        } else if (vstr_len(&line) == 0) {\n            continue;\n        } else {\n            \n            while (mp_repl_continue_with_input(vstr_null_terminated_str(&line))) {\n                vstr_add_byte(&line, '\\n');\n                ret = readline(&line, mp_repl_get_ps2());\n                if (ret == CHAR_CTRL_C) {\n                    \n                    mp_hal_stdout_tx_str(\"\\r\\n\");\n                    goto input_restart;\n                } else if (ret == CHAR_CTRL_D) {\n                    \n                    break;\n                }\n            }\n        }\n\n        ret = parse_compile_execute(&line, parse_input_kind, EXEC_FLAG_ALLOW_DEBUGGING | EXEC_FLAG_IS_REPL | EXEC_FLAG_SOURCE_IS_VSTR);\n        if (ret & PYEXEC_FORCED_EXIT) {\n            return ret;\n        }\n    }\n}\n\n#endif \n#endif \n\nint pyexec_file(const char *filename) {\n    return parse_compile_execute(filename, MP_PARSE_FILE_INPUT, EXEC_FLAG_SOURCE_IS_FILENAME);\n}\n\nint pyexec_file_if_exists(const char *filename) {\n    #if MICROPY_MODULE_FROZEN\n    if (mp_find_frozen_module(filename, NULL, NULL) == MP_IMPORT_STAT_FILE) {\n        return pyexec_frozen_module(filename, true);\n    }\n    #endif\n    if (mp_import_stat(filename) != MP_IMPORT_STAT_FILE) {\n        return 1; \n    }\n    return pyexec_file(filename);\n}\n\n#if MICROPY_MODULE_FROZEN\nint pyexec_frozen_module(const char *name, bool allow_keyboard_interrupt) {\n    void *frozen_data;\n    int frozen_type;\n    mp_find_frozen_module(name, &frozen_type, &frozen_data);\n    mp_uint_t exec_flags = allow_keyboard_interrupt ? 0 : EXEC_FLAG_NO_INTERRUPT;\n\n    switch (frozen_type) {\n        #if MICROPY_MODULE_FROZEN_STR\n        case MP_FROZEN_STR:\n            return parse_compile_execute(frozen_data, MP_PARSE_FILE_INPUT, exec_flags);\n        #endif\n\n        #if MICROPY_MODULE_FROZEN_MPY\n        case MP_FROZEN_MPY:\n            return parse_compile_execute(frozen_data, MP_PARSE_FILE_INPUT, exec_flags |\n                EXEC_FLAG_SOURCE_IS_RAW_CODE);\n        #endif\n\n        default:\n            mp_printf(MICROPY_ERROR_PRINTER, \"could not find module '%s'\\n\", name);\n            return false;\n    }\n}\n#endif\n\n#if MICROPY_REPL_INFO\nmp_obj_t pyb_set_repl_info(mp_obj_t o_value) {\n    repl_display_debugging_info = mp_obj_get_int(o_value);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(pyb_set_repl_info_obj, pyb_set_repl_info);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}