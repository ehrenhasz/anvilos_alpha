{
  "module_name": "mpirq.c",
  "hash_id": "baf79c5e11f6c9f52159fd6630d4208a31cbe53340ee17f60c29520813247c9a",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/runtime/mpirq.c",
  "human_readable_source": " \n\n#include <stdio.h>\n\n#include \"py/runtime.h\"\n#include \"py/gc.h\"\n#include \"shared/runtime/mpirq.h\"\n\n#if MICROPY_ENABLE_SCHEDULER\n\n \n\nconst mp_arg_t mp_irq_init_args[] = {\n    { MP_QSTR_handler, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n    { MP_QSTR_trigger, MP_ARG_INT, {.u_int = 0} },\n    { MP_QSTR_hard, MP_ARG_BOOL, {.u_bool = false} },\n};\n\n \n\n \n\nmp_irq_obj_t *mp_irq_new(const mp_irq_methods_t *methods, mp_obj_t parent) {\n    mp_irq_obj_t *self = m_new0(mp_irq_obj_t, 1);\n    mp_irq_init(self, methods, parent);\n    return self;\n}\n\nvoid mp_irq_init(mp_irq_obj_t *self, const mp_irq_methods_t *methods, mp_obj_t parent) {\n    self->base.type = &mp_irq_type;\n    self->methods = (mp_irq_methods_t *)methods;\n    self->parent = parent;\n    self->handler = mp_const_none;\n    self->ishard = false;\n}\n\nvoid mp_irq_handler(mp_irq_obj_t *self) {\n    if (self->handler != mp_const_none) {\n        if (self->ishard) {\n            \n            \n            \n            mp_sched_lock();\n            gc_lock();\n            nlr_buf_t nlr;\n            if (nlr_push(&nlr) == 0) {\n                mp_call_function_1(self->handler, self->parent);\n                nlr_pop();\n            } else {\n                \n                self->methods->trigger(self->parent, 0);\n                self->handler = mp_const_none;\n                mp_printf(MICROPY_ERROR_PRINTER, \"Uncaught exception in IRQ callback handler\\n\");\n                mp_obj_print_exception(MICROPY_ERROR_PRINTER, MP_OBJ_FROM_PTR(nlr.ret_val));\n            }\n            gc_unlock();\n            mp_sched_unlock();\n        } else {\n            \n            mp_sched_schedule(self->handler, self->parent);\n        }\n    }\n}\n\n \n\n\nstatic mp_obj_t mp_irq_flags(mp_obj_t self_in) {\n    mp_irq_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_int(self->methods->info(self->parent, MP_IRQ_INFO_FLAGS));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_irq_flags_obj, mp_irq_flags);\n\nstatic mp_obj_t mp_irq_trigger(size_t n_args, const mp_obj_t *args) {\n    mp_irq_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_obj_t ret_obj = mp_obj_new_int(self->methods->info(self->parent, MP_IRQ_INFO_TRIGGERS));\n    if (n_args == 2) {\n        \n        self->methods->trigger(self->parent, mp_obj_get_int(args[1]));\n    }\n    return ret_obj;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_irq_trigger_obj, 1, 2, mp_irq_trigger);\n\nstatic mp_obj_t mp_irq_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 0, false);\n    mp_irq_handler(MP_OBJ_TO_PTR(self_in));\n    return mp_const_none;\n}\n\nstatic const mp_rom_map_elem_t mp_irq_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_flags),               MP_ROM_PTR(&mp_irq_flags_obj) },\n    { MP_ROM_QSTR(MP_QSTR_trigger),             MP_ROM_PTR(&mp_irq_trigger_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(mp_irq_locals_dict, mp_irq_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_irq_type,\n    MP_QSTR_irq,\n    MP_TYPE_FLAG_NONE,\n    call, mp_irq_call,\n    locals_dict, &mp_irq_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}