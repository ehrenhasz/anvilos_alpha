{
  "module_name": "sys_stdio_mphal.c",
  "hash_id": "796a52a94b539a26bb31681ebd877998bec9c6718daa48a43e0da9778c9c129c",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/runtime/sys_stdio_mphal.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/obj.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n\n\n\n\n \n\n\n#define STDIO_FD_IN  (0)\n#define STDIO_FD_OUT (1)\n#define STDIO_FD_ERR (2)\n\ntypedef struct _sys_stdio_obj_t {\n    mp_obj_base_t base;\n    int fd;\n} sys_stdio_obj_t;\n\n#if MICROPY_PY_SYS_STDIO_BUFFER\nstatic const sys_stdio_obj_t stdio_buffer_obj;\n#endif\n\nstatic void stdio_obj_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    sys_stdio_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<io.FileIO %d>\", self->fd);\n}\n\nstatic mp_uint_t stdio_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    sys_stdio_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->fd == STDIO_FD_IN) {\n        for (uint i = 0; i < size; i++) {\n            int c = mp_hal_stdin_rx_chr();\n            if (c == '\\r') {\n                c = '\\n';\n            }\n            ((byte *)buf)[i] = c;\n        }\n        return size;\n    } else {\n        *errcode = MP_EPERM;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic mp_uint_t stdio_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    sys_stdio_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->fd == STDIO_FD_OUT || self->fd == STDIO_FD_ERR) {\n        mp_hal_stdout_tx_strn_cooked(buf, size);\n        return size;\n    } else {\n        *errcode = MP_EPERM;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic mp_uint_t stdio_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    (void)self_in;\n    if (request == MP_STREAM_POLL) {\n        return mp_hal_stdio_poll(arg);\n    } else if (request == MP_STREAM_CLOSE) {\n        return 0;\n    } else {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic const mp_rom_map_elem_t stdio_locals_dict_table[] = {\n    #if MICROPY_PY_SYS_STDIO_BUFFER\n    { MP_ROM_QSTR(MP_QSTR_buffer), MP_ROM_PTR(&stdio_buffer_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj)},\n    { MP_ROM_QSTR(MP_QSTR_readlines), MP_ROM_PTR(&mp_stream_unbuffered_readlines_obj)},\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_identity_obj) },\n    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&mp_identity_obj) },\n    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&mp_stream___exit___obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(stdio_locals_dict, stdio_locals_dict_table);\n\nstatic const mp_stream_p_t stdio_obj_stream_p = {\n    .read = stdio_read,\n    .write = stdio_write,\n    .ioctl = stdio_ioctl,\n    .is_text = true,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    stdio_obj_type,\n    MP_QSTR_FileIO,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    print, stdio_obj_print,\n    protocol, &stdio_obj_stream_p,\n    locals_dict, &stdio_locals_dict\n    );\n\nconst sys_stdio_obj_t mp_sys_stdin_obj = {{&stdio_obj_type}, .fd = STDIO_FD_IN};\nconst sys_stdio_obj_t mp_sys_stdout_obj = {{&stdio_obj_type}, .fd = STDIO_FD_OUT};\nconst sys_stdio_obj_t mp_sys_stderr_obj = {{&stdio_obj_type}, .fd = STDIO_FD_ERR};\n\n#if MICROPY_PY_SYS_STDIO_BUFFER\nstatic mp_uint_t stdio_buffer_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    for (uint i = 0; i < size; i++) {\n        ((byte *)buf)[i] = mp_hal_stdin_rx_chr();\n    }\n    return size;\n}\n\nstatic mp_uint_t stdio_buffer_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    return mp_hal_stdout_tx_strn(buf, size);\n}\n\nstatic const mp_stream_p_t stdio_buffer_obj_stream_p = {\n    .read = stdio_buffer_read,\n    .write = stdio_buffer_write,\n    .ioctl = stdio_ioctl,\n    .is_text = false,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    stdio_buffer_obj_type,\n    MP_QSTR_FileIO,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    print, stdio_obj_print,\n    protocol, &stdio_buffer_obj_stream_p,\n    locals_dict, &stdio_locals_dict\n    );\n\nstatic const sys_stdio_obj_t stdio_buffer_obj = {{&stdio_buffer_obj_type}, .fd = 0}; \n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}