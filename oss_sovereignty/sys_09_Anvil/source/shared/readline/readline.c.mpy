{
  "module_name": "readline.c",
  "hash_id": "3922df177697f092cf110f3dfce4eeef3f568007a47922443e63a3a34691461e",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/readline/readline.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/mpstate.h\"\n#include \"py/repl.h\"\n#include \"py/mphal.h\"\n#include \"shared/readline/readline.h\"\n\n#if 0 \n#define DEBUG_PRINT (1)\n#define DEBUG_printf printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\n\n#define AUTO_INDENT_ENABLED (0x01)\n#define AUTO_INDENT_JUST_ADDED (0x02)\n\nenum { ESEQ_NONE, ESEQ_ESC, ESEQ_ESC_BRACKET, ESEQ_ESC_BRACKET_DIGIT, ESEQ_ESC_O };\n\n#ifdef _MSC_VER\n\n#pragma warning(disable : 4090)\n#endif\n\nvoid readline_init0(void) {\n    memset(MP_STATE_PORT(readline_hist), 0, MICROPY_READLINE_HISTORY_SIZE * sizeof(const char*));\n}\n\nstatic char *str_dup_maybe(const char *str) {\n    uint32_t len = strlen(str);\n    char *s2 = m_new_maybe(char, len + 1);\n    if (s2 == NULL) {\n        return NULL;\n    }\n    memcpy(s2, str, len + 1);\n    return s2;\n}\n\n\n#ifndef MICROPY_HAL_HAS_VT100\n#define MICROPY_HAL_HAS_VT100 (1)\n#endif\n\n\n#if MICROPY_HAL_HAS_VT100\nstatic void mp_hal_move_cursor_back(uint pos) {\n    if (pos <= 4) {\n        \n        mp_hal_stdout_tx_strn(\"\\b\\b\\b\\b\", pos);\n    } else {\n        char vt100_command[6];\n        \n        int n = snprintf(&vt100_command[0], sizeof(vt100_command), \"\\x1b[%u\", pos);\n        if (n > 0) {\n            assert((unsigned)n < sizeof(vt100_command));\n            vt100_command[n] = 'D'; \n            mp_hal_stdout_tx_strn(vt100_command, n + 1);\n        }\n    }\n}\n\nstatic void mp_hal_erase_line_from_cursor(uint n_chars_to_erase) {\n    (void)n_chars_to_erase;\n    mp_hal_stdout_tx_strn(\"\\x1b[K\", 3);\n}\n#endif\n\ntypedef struct _readline_t {\n    vstr_t *line;\n    size_t orig_line_len;\n    int escape_seq;\n    int hist_cur;\n    size_t cursor_pos;\n    char escape_seq_buf[1];\n    #if MICROPY_REPL_AUTO_INDENT\n    uint8_t auto_indent_state;\n    #endif\n    const char *prompt;\n} readline_t;\n\nstatic readline_t rl;\n\n#if MICROPY_REPL_EMACS_WORDS_MOVE\nstatic size_t cursor_count_word(int forward) {\n    const char *line_buf = vstr_str(rl.line);\n    size_t pos = rl.cursor_pos;\n    bool in_word = false;\n\n    for (;;) {\n        \n        if (!forward && pos == 0) {\n            break;\n        }\n        \n        else if (forward && pos == vstr_len(rl.line)) {\n            break;\n        }\n\n        if (unichar_isalnum(line_buf[pos + (forward - 1)])) {\n            in_word = true;\n        } else if (in_word) {\n            break;\n        }\n\n        pos += forward ? forward : -1;\n    }\n\n    return forward ? pos - rl.cursor_pos : rl.cursor_pos - pos;\n}\n#endif\n\nint readline_process_char(int c) {\n    size_t last_line_len = rl.line->len;\n    int redraw_step_back = 0;\n    bool redraw_from_cursor = false;\n    int redraw_step_forward = 0;\n    if (rl.escape_seq == ESEQ_NONE) {\n        if (CHAR_CTRL_A <= c && c <= CHAR_CTRL_E && vstr_len(rl.line) == rl.orig_line_len) {\n            \n            return c;\n        } else if (c == CHAR_CTRL_A) {\n            \n            goto home_key;\n        #if MICROPY_REPL_EMACS_KEYS\n        } else if (c == CHAR_CTRL_B) {\n            \n            goto left_arrow_key;\n        #endif\n        } else if (c == CHAR_CTRL_C) {\n            \n            return c;\n        #if MICROPY_REPL_EMACS_KEYS\n        } else if (c == CHAR_CTRL_D) {\n            \n            goto delete_key;\n        #endif\n        } else if (c == CHAR_CTRL_E) {\n            \n            goto end_key;\n        #if MICROPY_REPL_EMACS_KEYS\n        } else if (c == CHAR_CTRL_F) {\n            \n            goto right_arrow_key;\n        } else if (c == CHAR_CTRL_K) {\n            \n            vstr_cut_tail_bytes(rl.line, last_line_len - rl.cursor_pos);\n            \n            redraw_from_cursor = true;\n        } else if (c == CHAR_CTRL_N) {\n            \n            goto down_arrow_key;\n        } else if (c == CHAR_CTRL_P) {\n            \n            goto up_arrow_key;\n        } else if (c == CHAR_CTRL_U) {\n            \n            vstr_cut_out_bytes(rl.line, rl.orig_line_len, rl.cursor_pos - rl.orig_line_len);\n            \n            redraw_step_back = rl.cursor_pos - rl.orig_line_len;\n            redraw_from_cursor = true;\n        #endif\n        #if MICROPY_REPL_EMACS_EXTRA_WORDS_MOVE\n        } else if (c == CHAR_CTRL_W) {\n            goto backward_kill_word;\n        #endif\n        } else if (c == '\\r') {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            readline_push_history(vstr_null_terminated_str(rl.line) + rl.orig_line_len);\n            return 0;\n        } else if (c == 27) {\n            \n            rl.escape_seq = ESEQ_ESC;\n        } else if (c == 8 || c == 127) {\n            \n            if (rl.cursor_pos > rl.orig_line_len) {\n                \n                #if MICROPY_REPL_AUTO_INDENT\n                int nspace = 0;\n                for (size_t i = rl.orig_line_len; i < rl.cursor_pos; i++) {\n                    if (rl.line->buf[i] != ' ') {\n                        nspace = 0;\n                        break;\n                    }\n                    nspace += 1;\n                }\n                if (nspace < 4) {\n                    nspace = 1;\n                } else {\n                    nspace = 4;\n                }\n                #else\n                int nspace = 1;\n                #endif\n\n                \n                vstr_cut_out_bytes(rl.line, rl.cursor_pos - nspace, nspace);\n                \n                redraw_step_back = nspace;\n                redraw_from_cursor = true;\n            }\n        #if MICROPY_REPL_AUTO_INDENT\n        } else if ((rl.auto_indent_state & AUTO_INDENT_JUST_ADDED) && (c == 9 || c == ' ')) {\n            \n            \n            \n            rl.auto_indent_state = 0;\n            if (c == ' ') {\n                redraw_step_back = 3;\n                vstr_cut_tail_bytes(rl.line, 3);\n            }\n        #endif\n        #if MICROPY_HELPER_REPL\n        } else if (c == 9) {\n            \n            const char *compl_str;\n            size_t compl_len;\n            if (vstr_len(rl.line) != 0 && unichar_isspace(vstr_str(rl.line)[rl.cursor_pos - 1])) {\n                \n                \n                \n                \n                \n                \n                compl_str = \"    \";\n                compl_len = 4;\n            } else {\n                \n                const char *cur_line_buf = vstr_str(rl.line) + rl.orig_line_len;\n                size_t cur_line_len = rl.cursor_pos - rl.orig_line_len;\n                compl_len = mp_repl_autocomplete(cur_line_buf, cur_line_len, &mp_plat_print, &compl_str);\n            }\n            if (compl_len == 0) {\n                \n            } else if (compl_len == (size_t)(-1)) {\n                \n                mp_hal_stdout_tx_str(rl.prompt);\n                mp_hal_stdout_tx_strn(rl.line->buf + rl.orig_line_len, rl.cursor_pos - rl.orig_line_len);\n                redraw_from_cursor = true;\n            } else {\n                \n                for (size_t i = 0; i < compl_len; ++i) {\n                    vstr_ins_byte(rl.line, rl.cursor_pos + i, *compl_str++);\n                }\n                \n                redraw_from_cursor = true;\n                redraw_step_forward = compl_len;\n            }\n        #endif\n        } else if (32 <= c && c <= 126) {\n            \n            vstr_ins_char(rl.line, rl.cursor_pos, c);\n            \n            redraw_from_cursor = true;\n            redraw_step_forward = 1;\n        }\n    } else if (rl.escape_seq == ESEQ_ESC) {\n        switch (c) {\n            case '[':\n                rl.escape_seq = ESEQ_ESC_BRACKET;\n                break;\n            case 'O':\n                rl.escape_seq = ESEQ_ESC_O;\n                break;\n            #if MICROPY_REPL_EMACS_WORDS_MOVE\n            case 'b':\n#if MICROPY_REPL_EMACS_EXTRA_WORDS_MOVE\nbackward_word:\n#endif\n                redraw_step_back = cursor_count_word(0);\n                rl.escape_seq = ESEQ_NONE;\n                break;\n            case 'f':\n#if MICROPY_REPL_EMACS_EXTRA_WORDS_MOVE\nforward_word:\n#endif\n                redraw_step_forward = cursor_count_word(1);\n                rl.escape_seq = ESEQ_NONE;\n                break;\n            case 'd':\n                vstr_cut_out_bytes(rl.line, rl.cursor_pos, cursor_count_word(1));\n                redraw_from_cursor = true;\n                rl.escape_seq = ESEQ_NONE;\n                break;\n            case 127:\n#if MICROPY_REPL_EMACS_EXTRA_WORDS_MOVE\nbackward_kill_word:\n#endif\n                redraw_step_back = cursor_count_word(0);\n                vstr_cut_out_bytes(rl.line, rl.cursor_pos - redraw_step_back, redraw_step_back);\n                redraw_from_cursor = true;\n                rl.escape_seq = ESEQ_NONE;\n                break;\n            #endif\n            default:\n                DEBUG_printf(\"(ESC %d)\", c);\n                rl.escape_seq = ESEQ_NONE;\n                break;\n        }\n    } else if (rl.escape_seq == ESEQ_ESC_BRACKET) {\n        if ('0' <= c && c <= '9') {\n            rl.escape_seq = ESEQ_ESC_BRACKET_DIGIT;\n            rl.escape_seq_buf[0] = c;\n        } else {\n            rl.escape_seq = ESEQ_NONE;\n            if (c == 'A') {\n#if MICROPY_REPL_EMACS_KEYS\nup_arrow_key:\n#endif\n                \n                if (rl.hist_cur + 1 < MICROPY_READLINE_HISTORY_SIZE && MP_STATE_PORT(readline_hist)[rl.hist_cur + 1] != NULL) {\n                    \n                    rl.hist_cur += 1;\n                    \n                    rl.line->len = rl.orig_line_len;\n                    vstr_add_str(rl.line, MP_STATE_PORT(readline_hist)[rl.hist_cur]);\n                    \n                    redraw_step_back = rl.cursor_pos - rl.orig_line_len;\n                    redraw_from_cursor = true;\n                    redraw_step_forward = rl.line->len - rl.orig_line_len;\n                }\n            } else if (c == 'B') {\n#if MICROPY_REPL_EMACS_KEYS\ndown_arrow_key:\n#endif\n                \n                if (rl.hist_cur >= 0) {\n                    \n                    rl.hist_cur -= 1;\n                    \n                    vstr_cut_tail_bytes(rl.line, rl.line->len - rl.orig_line_len);\n                    if (rl.hist_cur >= 0) {\n                        vstr_add_str(rl.line, MP_STATE_PORT(readline_hist)[rl.hist_cur]);\n                    }\n                    \n                    redraw_step_back = rl.cursor_pos - rl.orig_line_len;\n                    redraw_from_cursor = true;\n                    redraw_step_forward = rl.line->len - rl.orig_line_len;\n                }\n            } else if (c == 'C') {\n#if MICROPY_REPL_EMACS_KEYS\nright_arrow_key:\n#endif\n                \n                if (rl.cursor_pos < rl.line->len) {\n                    redraw_step_forward = 1;\n                }\n            } else if (c == 'D') {\n#if MICROPY_REPL_EMACS_KEYS\nleft_arrow_key:\n#endif\n                \n                if (rl.cursor_pos > rl.orig_line_len) {\n                    redraw_step_back = 1;\n                }\n            } else if (c == 'H') {\n                \n                goto home_key;\n            } else if (c == 'F') {\n                \n                goto end_key;\n            } else {\n                DEBUG_printf(\"(ESC [ %d)\", c);\n            }\n        }\n    } else if (rl.escape_seq == ESEQ_ESC_BRACKET_DIGIT) {\n        if (c == '~') {\n            if (rl.escape_seq_buf[0] == '1' || rl.escape_seq_buf[0] == '7') {\nhome_key:\n                redraw_step_back = rl.cursor_pos - rl.orig_line_len;\n            } else if (rl.escape_seq_buf[0] == '4' || rl.escape_seq_buf[0] == '8') {\nend_key:\n                redraw_step_forward = rl.line->len - rl.cursor_pos;\n            } else if (rl.escape_seq_buf[0] == '3') {\n                \n#if MICROPY_REPL_EMACS_KEYS\ndelete_key:\n#endif\n                if (rl.cursor_pos < rl.line->len) {\n                    vstr_cut_out_bytes(rl.line, rl.cursor_pos, 1);\n                    redraw_from_cursor = true;\n                }\n            } else {\n                DEBUG_printf(\"(ESC [ %c %d)\", rl.escape_seq_buf[0], c);\n            }\n        #if MICROPY_REPL_EMACS_EXTRA_WORDS_MOVE\n        } else if (c == ';' && rl.escape_seq_buf[0] == '1') {\n            \n            \n            \n            \n            \n            \n            rl.escape_seq = ESEQ_ESC_BRACKET;\n            \n            goto redraw;\n        } else if (rl.escape_seq_buf[0] == '5' && c == 'C') {\n            \n            goto forward_word;\n        } else if (rl.escape_seq_buf[0] == '5' && c == 'D') {\n            \n            goto backward_word;\n        #endif\n        } else {\n            DEBUG_printf(\"(ESC [ %c %d)\", rl.escape_seq_buf[0], c);\n        }\n        rl.escape_seq = ESEQ_NONE;\n    } else if (rl.escape_seq == ESEQ_ESC_O) {\n        switch (c) {\n            case 'H':\n                goto home_key;\n            case 'F':\n                goto end_key;\n            default:\n                DEBUG_printf(\"(ESC O %d)\", c);\n                rl.escape_seq = ESEQ_NONE;\n        }\n    } else {\n        rl.escape_seq = ESEQ_NONE;\n    }\n\n#if MICROPY_REPL_EMACS_EXTRA_WORDS_MOVE\nredraw:\n#endif\n\n    \n    if (redraw_step_back > 0) {\n        mp_hal_move_cursor_back(redraw_step_back);\n        rl.cursor_pos -= redraw_step_back;\n    }\n    if (redraw_from_cursor) {\n        if (rl.line->len < last_line_len) {\n            \n            mp_hal_erase_line_from_cursor(last_line_len - rl.cursor_pos);\n        }\n        \n        mp_hal_stdout_tx_strn(rl.line->buf + rl.cursor_pos, rl.line->len - rl.cursor_pos);\n        \n        mp_hal_move_cursor_back(rl.line->len - (rl.cursor_pos + redraw_step_forward));\n        rl.cursor_pos += redraw_step_forward;\n    } else if (redraw_step_forward > 0) {\n        \n        mp_hal_stdout_tx_strn(rl.line->buf + rl.cursor_pos, redraw_step_forward);\n        rl.cursor_pos += redraw_step_forward;\n    }\n\n    #if MICROPY_REPL_AUTO_INDENT\n    rl.auto_indent_state &= ~AUTO_INDENT_JUST_ADDED;\n    #endif\n\n    return -1;\n}\n\n#if MICROPY_REPL_AUTO_INDENT\nstatic void readline_auto_indent(void) {\n    if (!(rl.auto_indent_state & AUTO_INDENT_ENABLED)) {\n        return;\n    }\n    vstr_t *line = rl.line;\n    if (line->len > 1 && line->buf[line->len - 1] == '\\n') {\n        int i;\n        for (i = line->len - 1; i > 0; i--) {\n            if (line->buf[i - 1] == '\\n') {\n                break;\n            }\n        }\n        size_t j;\n        for (j = i; j < line->len; j++) {\n            if (line->buf[j] != ' ') {\n                break;\n            }\n        }\n        \n        if (i > 0 && j + 1 == line->len) {\n            \n            for (size_t k = i - 1; k > 0; --k) {\n                if (line->buf[k - 1] == '\\n') {\n                    \n                    return;\n                } else if (line->buf[k - 1] != ' ') {\n                    \n                    break;\n                }\n            }\n        }\n        int n = (j - i) / 4;\n        if (line->buf[line->len - 2] == ':') {\n            n += 1;\n        }\n        while (n-- > 0) {\n            vstr_add_strn(line, \"    \", 4);\n            mp_hal_stdout_tx_strn(\"    \", 4);\n            rl.cursor_pos += 4;\n            rl.auto_indent_state |= AUTO_INDENT_JUST_ADDED;\n        }\n    }\n}\n#endif\n\nvoid readline_note_newline(const char *prompt) {\n    rl.orig_line_len = rl.line->len;\n    rl.cursor_pos = rl.orig_line_len;\n    rl.prompt = prompt;\n    mp_hal_stdout_tx_str(prompt);\n    #if MICROPY_REPL_AUTO_INDENT\n    readline_auto_indent();\n    #endif\n}\n\nvoid readline_init(vstr_t *line, const char *prompt) {\n    rl.line = line;\n    rl.orig_line_len = line->len;\n    rl.escape_seq = ESEQ_NONE;\n    rl.escape_seq_buf[0] = 0;\n    rl.hist_cur = -1;\n    rl.cursor_pos = rl.orig_line_len;\n    rl.prompt = prompt;\n    mp_hal_stdout_tx_str(prompt);\n    #if MICROPY_REPL_AUTO_INDENT\n    if (vstr_len(line) == 0) {\n        \n        rl.auto_indent_state = AUTO_INDENT_ENABLED;\n    }\n    readline_auto_indent();\n    #endif\n}\n\nint readline(vstr_t *line, const char *prompt) {\n    readline_init(line, prompt);\n    for (;;) {\n        int c = mp_hal_stdin_rx_chr();\n        int r = readline_process_char(c);\n        if (r >= 0) {\n            return r;\n        }\n    }\n}\n\nvoid readline_push_history(const char *line) {\n    if (line[0] != '\\0'\n        && (MP_STATE_PORT(readline_hist)[0] == NULL\n            || strcmp(MP_STATE_PORT(readline_hist)[0], line) != 0)) {\n        \n        \n        char *most_recent_hist = str_dup_maybe(line);\n        if (most_recent_hist != NULL) {\n            for (int i = MICROPY_READLINE_HISTORY_SIZE - 1; i > 0; i--) {\n                MP_STATE_PORT(readline_hist)[i] = MP_STATE_PORT(readline_hist)[i - 1];\n            }\n            MP_STATE_PORT(readline_hist)[0] = most_recent_hist;\n        }\n    }\n}\n\nMP_REGISTER_ROOT_POINTER(const char *readline_hist[MICROPY_READLINE_HISTORY_SIZE]);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}