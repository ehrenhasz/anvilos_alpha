{
  "module_name": "trace.c",
  "hash_id": "ea0de7c9049f247a0856c9a1a15651022826a7d098902397d924c51734226504",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/netutils/trace.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n#include \"shared/netutils/netutils.h\"\n\nstatic uint32_t get_be16(const uint8_t *buf) {\n    return buf[0] << 8 | buf[1];\n}\n\nstatic uint32_t get_be32(const uint8_t *buf) {\n    return buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];\n}\n\nstatic void dump_hex_bytes(const mp_print_t *print, size_t len, const uint8_t *buf) {\n    for (size_t i = 0; i < len; ++i) {\n        mp_printf(print, \" %02x\", buf[i]);\n    }\n}\n\nstatic const char *ethertype_str(uint16_t type) {\n    \n    switch (type) {\n        case 0x0800:\n            return \"IPv4\";\n        case 0x0806:\n            return \"ARP\";\n        case 0x86dd:\n            return \"IPv6\";\n        default:\n            return NULL;\n    }\n}\n\nvoid netutils_ethernet_trace(const mp_print_t *print, size_t len, const uint8_t *buf, unsigned int flags) {\n    mp_printf(print, \"[% 8d] ETH%cX len=%u\", mp_hal_ticks_ms(), flags & NETUTILS_TRACE_IS_TX ? 'T' : 'R', len);\n    mp_printf(print, \" dst=%02x:%02x:%02x:%02x:%02x:%02x\", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);\n    mp_printf(print, \" src=%02x:%02x:%02x:%02x:%02x:%02x\", buf[6], buf[7], buf[8], buf[9], buf[10], buf[11]);\n\n    const char *ethertype = ethertype_str(buf[12] << 8 | buf[13]);\n    if (ethertype) {\n        mp_printf(print, \" type=%s\", ethertype);\n    } else {\n        mp_printf(print, \" type=0x%04x\", buf[12] << 8 | buf[13]);\n    }\n    if (len > 14) {\n        len -= 14;\n        buf += 14;\n        if (buf[-2] == 0x08 && buf[-1] == 0x00 && buf[0] == 0x45) {\n            \n            len = get_be16(buf + 2);\n            mp_printf(print, \" srcip=%u.%u.%u.%u dstip=%u.%u.%u.%u\",\n                buf[12], buf[13], buf[14], buf[15],\n                buf[16], buf[17], buf[18], buf[19]);\n            uint8_t prot = buf[9];\n            buf += 20;\n            len -= 20;\n            if (prot == 6) {\n                \n                uint16_t srcport = get_be16(buf);\n                uint16_t dstport = get_be16(buf + 2);\n                uint32_t seqnum = get_be32(buf + 4);\n                uint32_t acknum = get_be32(buf + 8);\n                uint16_t dataoff_flags = get_be16(buf + 12);\n                uint16_t winsz = get_be16(buf + 14);\n                mp_printf(print, \" TCP srcport=%u dstport=%u seqnum=%u acknum=%u dataoff=%u flags=%x winsz=%u\",\n                    srcport, dstport, (unsigned)seqnum, (unsigned)acknum, dataoff_flags >> 12, dataoff_flags & 0x1ff, winsz);\n                buf += 20;\n                len -= 20;\n                if (dataoff_flags >> 12 > 5) {\n                    mp_printf(print, \" opts=\");\n                    size_t opts_len = ((dataoff_flags >> 12) - 5) * 4;\n                    dump_hex_bytes(print, opts_len, buf);\n                    buf += opts_len;\n                    len -= opts_len;\n                }\n            } else if (prot == 17) {\n                \n                uint16_t srcport = get_be16(buf);\n                uint16_t dstport = get_be16(buf + 2);\n                mp_printf(print, \" UDP srcport=%u dstport=%u\", srcport, dstport);\n                len = get_be16(buf + 4);\n                buf += 8;\n                if ((srcport == 67 && dstport == 68) || (srcport == 68 && dstport == 67)) {\n                    \n                    if (srcport == 67) {\n                        mp_printf(print, \" DHCPS\");\n                    } else {\n                        mp_printf(print, \" DHCPC\");\n                    }\n                    dump_hex_bytes(print, 12 + 16 + 16 + 64, buf);\n                    size_t n = 12 + 16 + 16 + 64 + 128;\n                    len -= n;\n                    buf += n;\n                    mp_printf(print, \" opts:\");\n                    switch (buf[6]) {\n                        case 1:\n                            mp_printf(print, \" DISCOVER\");\n                            break;\n                        case 2:\n                            mp_printf(print, \" OFFER\");\n                            break;\n                        case 3:\n                            mp_printf(print, \" REQUEST\");\n                            break;\n                        case 4:\n                            mp_printf(print, \" DECLINE\");\n                            break;\n                        case 5:\n                            mp_printf(print, \" ACK\");\n                            break;\n                        case 6:\n                            mp_printf(print, \" NACK\");\n                            break;\n                        case 7:\n                            mp_printf(print, \" RELEASE\");\n                            break;\n                        case 8:\n                            mp_printf(print, \" INFORM\");\n                            break;\n                    }\n                }\n            } else {\n                \n                mp_printf(print, \" prot=%u\", prot);\n            }\n        } else if (buf[-2] == 0x86 && buf[-1] == 0xdd && (buf[0] >> 4) == 6) {\n            \n            uint32_t h = get_be32(buf);\n            uint16_t l = get_be16(buf + 4);\n            mp_printf(print, \" tclass=%u flow=%u len=%u nexthdr=%u hoplimit=%u\", (unsigned)((h >> 20) & 0xff), (unsigned)(h & 0xfffff), l, buf[6], buf[7]);\n            mp_printf(print, \" srcip=\");\n            dump_hex_bytes(print, 16, buf + 8);\n            mp_printf(print, \" dstip=\");\n            dump_hex_bytes(print, 16, buf + 24);\n            buf += 40;\n            len -= 40;\n        }\n        if (flags & NETUTILS_TRACE_PAYLOAD) {\n            mp_printf(print, \" data=\");\n            dump_hex_bytes(print, len, buf);\n        }\n    }\n    if (flags & NETUTILS_TRACE_NEWLINE) {\n        mp_printf(print, \"\\n\");\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}