{
  "module_name": "dhcpserver.c",
  "hash_id": "b89b6cbb178647995b76ba2f2bf4a101dcabbe70d7c2392e0cc2cd2cf1f8fa08",
  "original_prompt": "Ingested from sys_09_Anvil/source/shared/netutils/dhcpserver.c",
  "human_readable_source": " \n\n\n\n\n\n#include <stdio.h>\n#include <string.h>\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_LWIP\n\n#include \"shared/netutils/dhcpserver.h\"\n#include \"lwip/udp.h\"\n\n#define DHCPDISCOVER    (1)\n#define DHCPOFFER       (2)\n#define DHCPREQUEST     (3)\n#define DHCPDECLINE     (4)\n#define DHCPACK         (5)\n#define DHCPNACK        (6)\n#define DHCPRELEASE     (7)\n#define DHCPINFORM      (8)\n\n#define DHCP_OPT_PAD                (0)\n#define DHCP_OPT_SUBNET_MASK        (1)\n#define DHCP_OPT_ROUTER             (3)\n#define DHCP_OPT_DNS                (6)\n#define DHCP_OPT_HOST_NAME          (12)\n#define DHCP_OPT_REQUESTED_IP       (50)\n#define DHCP_OPT_IP_LEASE_TIME      (51)\n#define DHCP_OPT_MSG_TYPE           (53)\n#define DHCP_OPT_SERVER_ID          (54)\n#define DHCP_OPT_PARAM_REQUEST_LIST (55)\n#define DHCP_OPT_MAX_MSG_SIZE       (57)\n#define DHCP_OPT_VENDOR_CLASS_ID    (60)\n#define DHCP_OPT_CLIENT_ID          (61)\n#define DHCP_OPT_END                (255)\n\n#define PORT_DHCP_SERVER (67)\n#define PORT_DHCP_CLIENT (68)\n\n#define DEFAULT_DNS MAKE_IP4(192, 168, 4, 1)\n#define DEFAULT_LEASE_TIME_S (24 * 60 * 60) \n\n#define MAC_LEN (6)\n#define MAKE_IP4(a, b, c, d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))\n\ntypedef struct {\n    uint8_t op; \n    uint8_t htype; \n    uint8_t hlen; \n    uint8_t hops;\n    uint32_t xid; \n    uint16_t secs; \n    uint16_t flags;\n    uint8_t ciaddr[4]; \n    uint8_t yiaddr[4]; \n    uint8_t siaddr[4]; \n    uint8_t giaddr[4]; \n    uint8_t chaddr[16]; \n    uint8_t sname[64]; \n    uint8_t file[128]; \n    uint8_t options[312]; \n} dhcp_msg_t;\n\nstatic int dhcp_socket_new_dgram(struct udp_pcb **udp, void *cb_data, udp_recv_fn cb_udp_recv) {\n    \n    \n\n    *udp = udp_new();\n    if (*udp == NULL) {\n        return -MP_ENOMEM;\n    }\n\n    \n    udp_recv(*udp, cb_udp_recv, (void *)cb_data);\n\n    return 0; \n}\n\nstatic void dhcp_socket_free(struct udp_pcb **udp) {\n    if (*udp != NULL) {\n        udp_remove(*udp);\n        *udp = NULL;\n    }\n}\n\nstatic int dhcp_socket_bind(struct udp_pcb **udp, uint32_t ip, uint16_t port) {\n    ip_addr_t addr;\n    IP_ADDR4(&addr, ip >> 24 & 0xff, ip >> 16 & 0xff, ip >> 8 & 0xff, ip & 0xff);\n    \n    return udp_bind(*udp, &addr, port);\n}\n\nstatic int dhcp_socket_sendto(struct udp_pcb **udp, struct netif *netif, const void *buf, size_t len, uint32_t ip, uint16_t port) {\n    if (len > 0xffff) {\n        len = 0xffff;\n    }\n\n    struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);\n    if (p == NULL) {\n        return -MP_ENOMEM;\n    }\n\n    memcpy(p->payload, buf, len);\n\n    ip_addr_t dest;\n    IP_ADDR4(&dest, ip >> 24 & 0xff, ip >> 16 & 0xff, ip >> 8 & 0xff, ip & 0xff);\n    err_t err;\n    if (netif != NULL) {\n        err = udp_sendto_if(*udp, p, &dest, port, netif);\n    } else {\n        err = udp_sendto(*udp, p, &dest, port);\n    }\n\n    pbuf_free(p);\n\n    if (err != ERR_OK) {\n        return err;\n    }\n\n    return len;\n}\n\nstatic uint8_t *opt_find(uint8_t *opt, uint8_t cmd) {\n    for (int i = 0; i < 308 && opt[i] != DHCP_OPT_END;) {\n        if (opt[i] == cmd) {\n            return &opt[i];\n        }\n        i += 2 + opt[i + 1];\n    }\n    return NULL;\n}\n\nstatic void opt_write_n(uint8_t **opt, uint8_t cmd, size_t n, const void *data) {\n    uint8_t *o = *opt;\n    *o++ = cmd;\n    *o++ = n;\n    memcpy(o, data, n);\n    *opt = o + n;\n}\n\nstatic void opt_write_u8(uint8_t **opt, uint8_t cmd, uint8_t val) {\n    uint8_t *o = *opt;\n    *o++ = cmd;\n    *o++ = 1;\n    *o++ = val;\n    *opt = o;\n}\n\nstatic void opt_write_u32(uint8_t **opt, uint8_t cmd, uint32_t val) {\n    uint8_t *o = *opt;\n    *o++ = cmd;\n    *o++ = 4;\n    *o++ = val >> 24;\n    *o++ = val >> 16;\n    *o++ = val >> 8;\n    *o++ = val;\n    *opt = o;\n}\n\nstatic void dhcp_server_process(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *src_addr, u16_t src_port) {\n    dhcp_server_t *d = arg;\n    (void)upcb;\n    (void)src_addr;\n    (void)src_port;\n\n    \n    dhcp_msg_t dhcp_msg;\n\n    #define DHCP_MIN_SIZE (240 + 3)\n    if (p->tot_len < DHCP_MIN_SIZE) {\n        goto ignore_request;\n    }\n\n    size_t len = pbuf_copy_partial(p, &dhcp_msg, sizeof(dhcp_msg), 0);\n    if (len < DHCP_MIN_SIZE) {\n        goto ignore_request;\n    }\n\n    dhcp_msg.op = DHCPOFFER;\n    memcpy(&dhcp_msg.yiaddr, &ip_2_ip4(&d->ip)->addr, 4);\n\n    uint8_t *opt = (uint8_t *)&dhcp_msg.options;\n    opt += 4; \n\n    switch (opt[2]) {\n        case DHCPDISCOVER: {\n            int yi = DHCPS_MAX_IP;\n            for (int i = 0; i < DHCPS_MAX_IP; ++i) {\n                if (memcmp(d->lease[i].mac, dhcp_msg.chaddr, MAC_LEN) == 0) {\n                    \n                    yi = i;\n                    break;\n                }\n                if (yi == DHCPS_MAX_IP) {\n                    \n                    if (memcmp(d->lease[i].mac, \"\\x00\\x00\\x00\\x00\\x00\\x00\", MAC_LEN) == 0) {\n                        \n                        yi = i;\n                    }\n                    uint32_t expiry = d->lease[i].expiry << 16 | 0xffff;\n                    if ((int32_t)(expiry - mp_hal_ticks_ms()) < 0) {\n                        \n                        memset(d->lease[i].mac, 0, MAC_LEN);\n                        yi = i;\n                    }\n                }\n            }\n            if (yi == DHCPS_MAX_IP) {\n                \n                goto ignore_request;\n            }\n            dhcp_msg.yiaddr[3] = DHCPS_BASE_IP + yi;\n            opt_write_u8(&opt, DHCP_OPT_MSG_TYPE, DHCPOFFER);\n            break;\n        }\n\n        case DHCPREQUEST: {\n            uint8_t *o = opt_find(opt, DHCP_OPT_REQUESTED_IP);\n            if (o == NULL) {\n                \n                goto ignore_request;\n            }\n            if (memcmp(o + 2, &ip_2_ip4(&d->ip)->addr, 3) != 0) {\n                \n                goto ignore_request;\n            }\n            uint8_t yi = o[5] - DHCPS_BASE_IP;\n            if (yi >= DHCPS_MAX_IP) {\n                \n                goto ignore_request;\n            }\n            if (memcmp(d->lease[yi].mac, dhcp_msg.chaddr, MAC_LEN) == 0) {\n                \n            } else if (memcmp(d->lease[yi].mac, \"\\x00\\x00\\x00\\x00\\x00\\x00\", MAC_LEN) == 0) {\n                \n                memcpy(d->lease[yi].mac, dhcp_msg.chaddr, MAC_LEN);\n            } else {\n                \n                \n                goto ignore_request;\n            }\n            d->lease[yi].expiry = (mp_hal_ticks_ms() + DEFAULT_LEASE_TIME_S * 1000) >> 16;\n            dhcp_msg.yiaddr[3] = DHCPS_BASE_IP + yi;\n            opt_write_u8(&opt, DHCP_OPT_MSG_TYPE, DHCPACK);\n            printf(\"DHCPS: client connected: MAC=%02x:%02x:%02x:%02x:%02x:%02x IP=%u.%u.%u.%u\\n\",\n                dhcp_msg.chaddr[0], dhcp_msg.chaddr[1], dhcp_msg.chaddr[2], dhcp_msg.chaddr[3], dhcp_msg.chaddr[4], dhcp_msg.chaddr[5],\n                dhcp_msg.yiaddr[0], dhcp_msg.yiaddr[1], dhcp_msg.yiaddr[2], dhcp_msg.yiaddr[3]);\n            break;\n        }\n\n        default:\n            goto ignore_request;\n    }\n\n    opt_write_n(&opt, DHCP_OPT_SERVER_ID, 4, &ip_2_ip4(&d->ip)->addr);\n    opt_write_n(&opt, DHCP_OPT_SUBNET_MASK, 4, &ip_2_ip4(&d->nm)->addr);\n    opt_write_n(&opt, DHCP_OPT_ROUTER, 4, &ip_2_ip4(&d->ip)->addr); \n    opt_write_u32(&opt, DHCP_OPT_DNS, DEFAULT_DNS); \n    opt_write_u32(&opt, DHCP_OPT_IP_LEASE_TIME, DEFAULT_LEASE_TIME_S);\n    *opt++ = DHCP_OPT_END;\n    struct netif *netif = ip_current_input_netif();\n    dhcp_socket_sendto(&d->udp, netif, &dhcp_msg, opt - (uint8_t *)&dhcp_msg, 0xffffffff, PORT_DHCP_CLIENT);\n\nignore_request:\n    pbuf_free(p);\n}\n\nvoid dhcp_server_init(dhcp_server_t *d, ip_addr_t *ip, ip_addr_t *nm) {\n    ip_addr_copy(d->ip, *ip);\n    ip_addr_copy(d->nm, *nm);\n    memset(d->lease, 0, sizeof(d->lease));\n    if (dhcp_socket_new_dgram(&d->udp, d, dhcp_server_process) != 0) {\n        return;\n    }\n    dhcp_socket_bind(&d->udp, 0, PORT_DHCP_SERVER);\n}\n\nvoid dhcp_server_deinit(dhcp_server_t *d) {\n    dhcp_socket_free(&d->udp);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}