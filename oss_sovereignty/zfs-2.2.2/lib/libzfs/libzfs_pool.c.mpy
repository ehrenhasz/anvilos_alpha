{
  "module_name": "libzfs_pool.c",
  "hash_id": "376dd8c5c155eec959c98fe7eb019250eae0e8704a9ee0b784c6073c83ac13ab",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_pool.c",
  "human_readable_source": " \n\n \n\n#include <errno.h>\n#include <libintl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <zone.h>\n#include <sys/stat.h>\n#include <sys/efi_partition.h>\n#include <sys/systeminfo.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_sysfs.h>\n#include <sys/vdev_disk.h>\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <libzutil.h>\n#include <fcntl.h>\n\n#include \"zfs_namecheck.h\"\n#include \"zfs_prop.h\"\n#include \"libzfs_impl.h\"\n#include \"zfs_comutil.h\"\n#include \"zfeature_common.h\"\n\nstatic boolean_t zpool_vdev_is_interior(const char *name);\n\ntypedef struct prop_flags {\n\tunsigned int create:1;\t \n\tunsigned int import:1;\t \n\tunsigned int vdevprop:1;  \n} prop_flags_t;\n\n \n\nstatic int\nzpool_get_all_props(zpool_handle_t *zhp)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\n\tzcmd_alloc_dst_nvlist(hdl, &zc, 0);\n\n\twhile (zfs_ioctl(hdl, ZFS_IOC_POOL_GET_PROPS, &zc) != 0) {\n\t\tif (errno == ENOMEM)\n\t\t\tzcmd_expand_dst_nvlist(hdl, &zc);\n\t\telse {\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (zcmd_read_dst_nvlist(hdl, &zc, &zhp->zpool_props) != 0) {\n\t\tzcmd_free_nvlists(&zc);\n\t\treturn (-1);\n\t}\n\n\tzcmd_free_nvlists(&zc);\n\n\treturn (0);\n}\n\nint\nzpool_props_refresh(zpool_handle_t *zhp)\n{\n\tnvlist_t *old_props;\n\n\told_props = zhp->zpool_props;\n\n\tif (zpool_get_all_props(zhp) != 0)\n\t\treturn (-1);\n\n\tnvlist_free(old_props);\n\treturn (0);\n}\n\nstatic const char *\nzpool_get_prop_string(zpool_handle_t *zhp, zpool_prop_t prop,\n    zprop_source_t *src)\n{\n\tnvlist_t *nv, *nvl;\n\tconst char *value;\n\tzprop_source_t source;\n\n\tnvl = zhp->zpool_props;\n\tif (nvlist_lookup_nvlist(nvl, zpool_prop_to_name(prop), &nv) == 0) {\n\t\tsource = fnvlist_lookup_uint64(nv, ZPROP_SOURCE);\n\t\tvalue = fnvlist_lookup_string(nv, ZPROP_VALUE);\n\t} else {\n\t\tsource = ZPROP_SRC_DEFAULT;\n\t\tif ((value = zpool_prop_default_string(prop)) == NULL)\n\t\t\tvalue = \"-\";\n\t}\n\n\tif (src)\n\t\t*src = source;\n\n\treturn (value);\n}\n\nuint64_t\nzpool_get_prop_int(zpool_handle_t *zhp, zpool_prop_t prop, zprop_source_t *src)\n{\n\tnvlist_t *nv, *nvl;\n\tuint64_t value;\n\tzprop_source_t source;\n\n\tif (zhp->zpool_props == NULL && zpool_get_all_props(zhp)) {\n\t\t \n\t\tif ((prop == ZPOOL_PROP_GUID) &&\n\t\t    (nvlist_lookup_nvlist(zhp->zpool_config,\n\t\t    ZPOOL_CONFIG_VDEV_TREE, &nv) == 0) &&\n\t\t    (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &value)\n\t\t    == 0)) {\n\t\t\treturn (value);\n\t\t}\n\t\treturn (zpool_prop_default_numeric(prop));\n\t}\n\n\tnvl = zhp->zpool_props;\n\tif (nvlist_lookup_nvlist(nvl, zpool_prop_to_name(prop), &nv) == 0) {\n\t\tsource = fnvlist_lookup_uint64(nv, ZPROP_SOURCE);\n\t\tvalue = fnvlist_lookup_uint64(nv, ZPROP_VALUE);\n\t} else {\n\t\tsource = ZPROP_SRC_DEFAULT;\n\t\tvalue = zpool_prop_default_numeric(prop);\n\t}\n\n\tif (src)\n\t\t*src = source;\n\n\treturn (value);\n}\n\n \nconst char *\nzpool_state_to_name(vdev_state_t state, vdev_aux_t aux)\n{\n\tswitch (state) {\n\tcase VDEV_STATE_CLOSED:\n\tcase VDEV_STATE_OFFLINE:\n\t\treturn (gettext(\"OFFLINE\"));\n\tcase VDEV_STATE_REMOVED:\n\t\treturn (gettext(\"REMOVED\"));\n\tcase VDEV_STATE_CANT_OPEN:\n\t\tif (aux == VDEV_AUX_CORRUPT_DATA || aux == VDEV_AUX_BAD_LOG)\n\t\t\treturn (gettext(\"FAULTED\"));\n\t\telse if (aux == VDEV_AUX_SPLIT_POOL)\n\t\t\treturn (gettext(\"SPLIT\"));\n\t\telse\n\t\t\treturn (gettext(\"UNAVAIL\"));\n\tcase VDEV_STATE_FAULTED:\n\t\treturn (gettext(\"FAULTED\"));\n\tcase VDEV_STATE_DEGRADED:\n\t\treturn (gettext(\"DEGRADED\"));\n\tcase VDEV_STATE_HEALTHY:\n\t\treturn (gettext(\"ONLINE\"));\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (gettext(\"UNKNOWN\"));\n}\n\n \nconst char *\nzpool_pool_state_to_name(pool_state_t state)\n{\n\tswitch (state) {\n\tdefault:\n\t\tbreak;\n\tcase POOL_STATE_ACTIVE:\n\t\treturn (gettext(\"ACTIVE\"));\n\tcase POOL_STATE_EXPORTED:\n\t\treturn (gettext(\"EXPORTED\"));\n\tcase POOL_STATE_DESTROYED:\n\t\treturn (gettext(\"DESTROYED\"));\n\tcase POOL_STATE_SPARE:\n\t\treturn (gettext(\"SPARE\"));\n\tcase POOL_STATE_L2CACHE:\n\t\treturn (gettext(\"L2CACHE\"));\n\tcase POOL_STATE_UNINITIALIZED:\n\t\treturn (gettext(\"UNINITIALIZED\"));\n\tcase POOL_STATE_UNAVAIL:\n\t\treturn (gettext(\"UNAVAIL\"));\n\tcase POOL_STATE_POTENTIALLY_ACTIVE:\n\t\treturn (gettext(\"POTENTIALLY_ACTIVE\"));\n\t}\n\n\treturn (gettext(\"UNKNOWN\"));\n}\n\n \nconst char *\nzpool_get_state_str(zpool_handle_t *zhp)\n{\n\tzpool_errata_t errata;\n\tzpool_status_t status;\n\tconst char *str;\n\n\tstatus = zpool_get_status(zhp, NULL, &errata);\n\n\tif (zpool_get_state(zhp) == POOL_STATE_UNAVAIL) {\n\t\tstr = gettext(\"FAULTED\");\n\t} else if (status == ZPOOL_STATUS_IO_FAILURE_WAIT ||\n\t    status == ZPOOL_STATUS_IO_FAILURE_CONTINUE ||\n\t    status == ZPOOL_STATUS_IO_FAILURE_MMP) {\n\t\tstr = gettext(\"SUSPENDED\");\n\t} else {\n\t\tnvlist_t *nvroot = fnvlist_lookup_nvlist(\n\t\t    zpool_get_config(zhp, NULL), ZPOOL_CONFIG_VDEV_TREE);\n\t\tuint_t vsc;\n\t\tvdev_stat_t *vs = (vdev_stat_t *)fnvlist_lookup_uint64_array(\n\t\t    nvroot, ZPOOL_CONFIG_VDEV_STATS, &vsc);\n\t\tstr = zpool_state_to_name(vs->vs_state, vs->vs_aux);\n\t}\n\treturn (str);\n}\n\n \nint\nzpool_get_prop(zpool_handle_t *zhp, zpool_prop_t prop, char *buf,\n    size_t len, zprop_source_t *srctype, boolean_t literal)\n{\n\tuint64_t intval;\n\tconst char *strval;\n\tzprop_source_t src = ZPROP_SRC_NONE;\n\n\tif (zpool_get_state(zhp) == POOL_STATE_UNAVAIL) {\n\t\tswitch (prop) {\n\t\tcase ZPOOL_PROP_NAME:\n\t\t\t(void) strlcpy(buf, zpool_get_name(zhp), len);\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_HEALTH:\n\t\t\t(void) strlcpy(buf, zpool_get_state_str(zhp), len);\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_GUID:\n\t\t\tintval = zpool_get_prop_int(zhp, prop, &src);\n\t\t\t(void) snprintf(buf, len, \"%llu\", (u_longlong_t)intval);\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_ALTROOT:\n\t\tcase ZPOOL_PROP_CACHEFILE:\n\t\tcase ZPOOL_PROP_COMMENT:\n\t\tcase ZPOOL_PROP_COMPATIBILITY:\n\t\t\tif (zhp->zpool_props != NULL ||\n\t\t\t    zpool_get_all_props(zhp) == 0) {\n\t\t\t\t(void) strlcpy(buf,\n\t\t\t\t    zpool_get_prop_string(zhp, prop, &src),\n\t\t\t\t    len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzfs_fallthrough;\n\t\tdefault:\n\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (srctype != NULL)\n\t\t\t*srctype = src;\n\t\treturn (0);\n\t}\n\n\tif (zhp->zpool_props == NULL && zpool_get_all_props(zhp) &&\n\t    prop != ZPOOL_PROP_NAME)\n\t\treturn (-1);\n\n\tswitch (zpool_prop_get_type(prop)) {\n\tcase PROP_TYPE_STRING:\n\t\t(void) strlcpy(buf, zpool_get_prop_string(zhp, prop, &src),\n\t\t    len);\n\t\tbreak;\n\n\tcase PROP_TYPE_NUMBER:\n\t\tintval = zpool_get_prop_int(zhp, prop, &src);\n\n\t\tswitch (prop) {\n\t\tcase ZPOOL_PROP_SIZE:\n\t\tcase ZPOOL_PROP_ALLOCATED:\n\t\tcase ZPOOL_PROP_FREE:\n\t\tcase ZPOOL_PROP_FREEING:\n\t\tcase ZPOOL_PROP_LEAKED:\n\t\tcase ZPOOL_PROP_ASHIFT:\n\t\tcase ZPOOL_PROP_MAXBLOCKSIZE:\n\t\tcase ZPOOL_PROP_MAXDNODESIZE:\n\t\tcase ZPOOL_PROP_BCLONESAVED:\n\t\tcase ZPOOL_PROP_BCLONEUSED:\n\t\t\tif (literal)\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\telse\n\t\t\t\t(void) zfs_nicenum(intval, buf, len);\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_EXPANDSZ:\n\t\tcase ZPOOL_PROP_CHECKPOINT:\n\t\t\tif (intval == 0) {\n\t\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\t} else if (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) zfs_nicebytes(intval, buf, len);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_CAPACITY:\n\t\t\tif (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) snprintf(buf, len, \"%llu%%\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_FRAGMENTATION:\n\t\t\tif (intval == UINT64_MAX) {\n\t\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\t} else if (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) snprintf(buf, len, \"%llu%%\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_BCLONERATIO:\n\t\tcase ZPOOL_PROP_DEDUPRATIO:\n\t\t\tif (literal)\n\t\t\t\t(void) snprintf(buf, len, \"%llu.%02llu\",\n\t\t\t\t    (u_longlong_t)(intval / 100),\n\t\t\t\t    (u_longlong_t)(intval % 100));\n\t\t\telse\n\t\t\t\t(void) snprintf(buf, len, \"%llu.%02llux\",\n\t\t\t\t    (u_longlong_t)(intval / 100),\n\t\t\t\t    (u_longlong_t)(intval % 100));\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_HEALTH:\n\t\t\t(void) strlcpy(buf, zpool_get_state_str(zhp), len);\n\t\t\tbreak;\n\t\tcase ZPOOL_PROP_VERSION:\n\t\t\tif (intval >= SPA_VERSION_FEATURES) {\n\t\t\t\t(void) snprintf(buf, len, \"-\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzfs_fallthrough;\n\t\tdefault:\n\t\t\t(void) snprintf(buf, len, \"%llu\", (u_longlong_t)intval);\n\t\t}\n\t\tbreak;\n\n\tcase PROP_TYPE_INDEX:\n\t\tintval = zpool_get_prop_int(zhp, prop, &src);\n\t\tif (zpool_prop_index_to_string(prop, intval, &strval)\n\t\t    != 0)\n\t\t\treturn (-1);\n\t\t(void) strlcpy(buf, strval, len);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\n\tif (srctype)\n\t\t*srctype = src;\n\n\treturn (0);\n}\n\n \nint\nzpool_get_userprop(zpool_handle_t *zhp, const char *propname, char *buf,\n    size_t len, zprop_source_t *srctype)\n{\n\tnvlist_t *nv, *nvl;\n\tuint64_t ival;\n\tconst char *value;\n\tzprop_source_t source = ZPROP_SRC_LOCAL;\n\n\tnvl = zhp->zpool_props;\n\tif (nvlist_lookup_nvlist(nvl, propname, &nv) == 0) {\n\t\tif (nvlist_lookup_uint64(nv, ZPROP_SOURCE, &ival) == 0)\n\t\t\tsource = ival;\n\t\tverify(nvlist_lookup_string(nv, ZPROP_VALUE, &value) == 0);\n\t} else {\n\t\tsource = ZPROP_SRC_DEFAULT;\n\t\tvalue = \"-\";\n\t}\n\n\tif (srctype)\n\t\t*srctype = source;\n\n\t(void) strlcpy(buf, value, len);\n\n\treturn (0);\n}\n\n \nstatic boolean_t\nbootfs_name_valid(const char *pool, const char *bootfs)\n{\n\tint len = strlen(pool);\n\tif (bootfs[0] == '\\0')\n\t\treturn (B_TRUE);\n\n\tif (!zfs_name_valid(bootfs, ZFS_TYPE_FILESYSTEM|ZFS_TYPE_SNAPSHOT))\n\t\treturn (B_FALSE);\n\n\tif (strncmp(pool, bootfs, len) == 0 &&\n\t    (bootfs[len] == '/' || bootfs[len] == '\\0'))\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\n \nstatic nvlist_t *\nzpool_valid_proplist(libzfs_handle_t *hdl, const char *poolname,\n    nvlist_t *props, uint64_t version, prop_flags_t flags, char *errbuf)\n{\n\tnvpair_t *elem;\n\tnvlist_t *retprops;\n\tzpool_prop_t prop;\n\tconst char *strval;\n\tuint64_t intval;\n\tconst char *slash, *check;\n\tstruct stat64 statbuf;\n\tzpool_handle_t *zhp;\n\tchar report[1024];\n\n\tif (nvlist_alloc(&retprops, NV_UNIQUE_NAME, 0) != 0) {\n\t\t(void) no_memory(hdl);\n\t\treturn (NULL);\n\t}\n\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(props, elem)) != NULL) {\n\t\tconst char *propname = nvpair_name(elem);\n\n\t\tif (flags.vdevprop && zpool_prop_vdev(propname)) {\n\t\t\tvdev_prop_t vprop = vdev_name_to_prop(propname);\n\n\t\t\tif (vdev_prop_readonly(vprop)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"'%s' \"\n\t\t\t\t    \"is readonly\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_PROPREADONLY,\n\t\t\t\t    errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (zprop_parse_value(hdl, elem, vprop, ZFS_TYPE_VDEV,\n\t\t\t    retprops, &strval, &intval, errbuf) != 0)\n\t\t\t\tgoto error;\n\n\t\t\tcontinue;\n\t\t} else if (flags.vdevprop && vdev_prop_user(propname)) {\n\t\t\tif (nvlist_add_nvpair(retprops, elem) != 0) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (flags.vdevprop) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid property: '%s'\"), propname);\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tprop = zpool_name_to_prop(propname);\n\t\tif (prop == ZPOOL_PROP_INVAL && zpool_prop_feature(propname)) {\n\t\t\tint err;\n\t\t\tchar *fname = strchr(propname, '@') + 1;\n\n\t\t\terr = zfeature_lookup_name(fname, NULL);\n\t\t\tif (err != 0) {\n\t\t\t\tASSERT3U(err, ==, ENOENT);\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"feature '%s' unsupported by kernel\"),\n\t\t\t\t    fname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (nvpair_type(elem) != DATA_TYPE_STRING) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' must be a string\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t(void) nvpair_value_string(elem, &strval);\n\t\t\tif (strcmp(strval, ZFS_FEATURE_ENABLED) != 0 &&\n\t\t\t    strcmp(strval, ZFS_FEATURE_DISABLED) != 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' can only be set to \"\n\t\t\t\t    \"'enabled' or 'disabled'\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (!flags.create &&\n\t\t\t    strcmp(strval, ZFS_FEATURE_DISABLED) == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' can only be set to \"\n\t\t\t\t    \"'disabled' at creation time\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (nvlist_add_uint64(retprops, propname, 0) != 0) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (prop == ZPOOL_PROP_INVAL &&\n\t\t    zfs_prop_user(propname)) {\n\t\t\t \n\t\t\tif (nvpair_type(elem) != DATA_TYPE_STRING) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' must be a string\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (strlen(nvpair_name(elem)) >= ZAP_MAXNAMELEN) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property name '%s' is too long\"),\n\t\t\t\t    propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t(void) nvpair_value_string(elem, &strval);\n\n\t\t\tif (strlen(strval) >= ZFS_MAXPROPLEN) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property value '%s' is too long\"),\n\t\t\t\t    strval);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (nvlist_add_string(retprops, propname,\n\t\t\t    strval) != 0) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (prop == ZPOOL_PROP_INVAL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid property '%s'\"), propname);\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (zpool_prop_readonly(prop)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"'%s' \"\n\t\t\t    \"is readonly\"), propname);\n\t\t\t(void) zfs_error(hdl, EZFS_PROPREADONLY, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!flags.create && zpool_prop_setonce(prop)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property '%s' can only be set at \"\n\t\t\t    \"creation time\"), propname);\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (zprop_parse_value(hdl, elem, prop, ZFS_TYPE_POOL, retprops,\n\t\t    &strval, &intval, errbuf) != 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tswitch (prop) {\n\t\tcase ZPOOL_PROP_VERSION:\n\t\t\tif (intval < version ||\n\t\t\t    !SPA_VERSION_IS_SUPPORTED(intval)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' number %llu is invalid.\"),\n\t\t\t\t    propname, (unsigned long long)intval);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_ASHIFT:\n\t\t\tif (intval != 0 &&\n\t\t\t    (intval < ASHIFT_MIN || intval > ASHIFT_MAX)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' number %llu is invalid, \"\n\t\t\t\t    \"only values between %\" PRId32 \" and %\"\n\t\t\t\t    PRId32 \" are allowed.\"),\n\t\t\t\t    propname, (unsigned long long)intval,\n\t\t\t\t    ASHIFT_MIN, ASHIFT_MAX);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_BOOTFS:\n\t\t\tif (flags.create || flags.import) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' cannot be set at creation \"\n\t\t\t\t    \"or import time\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (version < SPA_VERSION_BOOTFS) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"pool must be upgraded to support \"\n\t\t\t\t    \"'%s' property\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!bootfs_name_valid(poolname, strval)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"'%s' \"\n\t\t\t\t    \"is an invalid name\"), strval);\n\t\t\t\t(void) zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif ((zhp = zpool_open_canfail(hdl, poolname)) == NULL) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"could not open pool '%s'\"), poolname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_OPENFAILED, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tzpool_close(zhp);\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_ALTROOT:\n\t\t\tif (!flags.create && !flags.import) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' can only be set during pool \"\n\t\t\t\t    \"creation or import\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (strval[0] != '/') {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"bad alternate root '%s'\"), strval);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPATH, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_CACHEFILE:\n\t\t\tif (strval[0] == '\\0')\n\t\t\t\tbreak;\n\n\t\t\tif (strcmp(strval, \"none\") == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (strval[0] != '/') {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' must be empty, an \"\n\t\t\t\t    \"absolute path, or 'none'\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPATH, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tslash = strrchr(strval, '/');\n\n\t\t\tif (slash[1] == '\\0' || strcmp(slash, \"/.\") == 0 ||\n\t\t\t    strcmp(slash, \"/..\") == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' is not a valid file\"), strval);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPATH, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t*(char *)slash = '\\0';\n\n\t\t\tif (strval[0] != '\\0' &&\n\t\t\t    (stat64(strval, &statbuf) != 0 ||\n\t\t\t    !S_ISDIR(statbuf.st_mode))) {\n\t\t\t\t*(char *)slash = '/';\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' is not a valid directory\"),\n\t\t\t\t    strval);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPATH, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t*(char *)slash = '/';\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_COMPATIBILITY:\n\t\t\tswitch (zpool_load_compat(strval, NULL, report, 1024)) {\n\t\t\tcase ZPOOL_COMPATIBILITY_OK:\n\t\t\tcase ZPOOL_COMPATIBILITY_WARNTOKEN:\n\t\t\t\tbreak;\n\t\t\tcase ZPOOL_COMPATIBILITY_BADFILE:\n\t\t\tcase ZPOOL_COMPATIBILITY_BADTOKEN:\n\t\t\tcase ZPOOL_COMPATIBILITY_NOFILES:\n\t\t\t\tzfs_error_aux(hdl, \"%s\", report);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZPOOL_PROP_COMMENT:\n\t\t\tfor (check = strval; *check != '\\0'; check++) {\n\t\t\t\tif (!isprint(*check)) {\n\t\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"comment may only have printable \"\n\t\t\t\t\t    \"characters\"));\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strlen(strval) > ZPROP_MAX_COMMENT) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"comment must not exceed %d characters\"),\n\t\t\t\t    ZPROP_MAX_COMMENT);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ZPOOL_PROP_READONLY:\n\t\t\tif (!flags.import) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' can only be set at \"\n\t\t\t\t    \"import time\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ZPOOL_PROP_MULTIHOST:\n\t\t\tif (get_system_hostid() == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"requires a non-zero system hostid\"));\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ZPOOL_PROP_DEDUPDITTO:\n\t\t\tprintf(\"Note: property '%s' no longer has \"\n\t\t\t    \"any effect\\n\", propname);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (retprops);\nerror:\n\tnvlist_free(retprops);\n\treturn (NULL);\n}\n\n \nint\nzpool_set_prop(zpool_handle_t *zhp, const char *propname, const char *propval)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint ret = -1;\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *nvl = NULL;\n\tnvlist_t *realprops;\n\tuint64_t version;\n\tprop_flags_t flags = { 0 };\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot set property for '%s'\"),\n\t    zhp->zpool_name);\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (no_memory(zhp->zpool_hdl));\n\n\tif (nvlist_add_string(nvl, propname, propval) != 0) {\n\t\tnvlist_free(nvl);\n\t\treturn (no_memory(zhp->zpool_hdl));\n\t}\n\n\tversion = zpool_get_prop_int(zhp, ZPOOL_PROP_VERSION, NULL);\n\tif ((realprops = zpool_valid_proplist(zhp->zpool_hdl,\n\t    zhp->zpool_name, nvl, version, flags, errbuf)) == NULL) {\n\t\tnvlist_free(nvl);\n\t\treturn (-1);\n\t}\n\n\tnvlist_free(nvl);\n\tnvl = realprops;\n\n\t \n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\n\tzcmd_write_src_nvlist(zhp->zpool_hdl, &zc, nvl);\n\n\tret = zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_POOL_SET_PROPS, &zc);\n\n\tzcmd_free_nvlists(&zc);\n\tnvlist_free(nvl);\n\n\tif (ret)\n\t\t(void) zpool_standard_error(zhp->zpool_hdl, errno, errbuf);\n\telse\n\t\t(void) zpool_props_refresh(zhp);\n\n\treturn (ret);\n}\n\nint\nzpool_expand_proplist(zpool_handle_t *zhp, zprop_list_t **plp,\n    zfs_type_t type, boolean_t literal)\n{\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tzprop_list_t *entry;\n\tchar buf[ZFS_MAXPROPLEN];\n\tnvlist_t *features = NULL;\n\tnvpair_t *nvp;\n\tzprop_list_t **last;\n\tboolean_t firstexpand = (NULL == *plp);\n\tint i;\n\n\tif (zprop_expand_list(hdl, plp, type) != 0)\n\t\treturn (-1);\n\n\tif (type == ZFS_TYPE_VDEV)\n\t\treturn (0);\n\n\tlast = plp;\n\twhile (*last != NULL)\n\t\tlast = &(*last)->pl_next;\n\n\tif ((*plp)->pl_all)\n\t\tfeatures = zpool_get_features(zhp);\n\n\tif ((*plp)->pl_all && firstexpand) {\n\t\t \n\t\tif (zhp->zpool_props == NULL && zpool_props_refresh(zhp))\n\t\t\treturn (-1);\n\n\t\tnvp = NULL;\n\t\twhile ((nvp = nvlist_next_nvpair(zhp->zpool_props, nvp)) !=\n\t\t    NULL) {\n\t\t\tconst char *propname = nvpair_name(nvp);\n\n\t\t\tif (!zfs_prop_user(propname))\n\t\t\t\tcontinue;\n\n\t\t\tentry = zfs_alloc(hdl, sizeof (zprop_list_t));\n\t\t\tentry->pl_prop = ZPROP_USERPROP;\n\t\t\tentry->pl_user_prop = zfs_strdup(hdl, propname);\n\t\t\tentry->pl_width = strlen(entry->pl_user_prop);\n\t\t\tentry->pl_all = B_TRUE;\n\n\t\t\t*last = entry;\n\t\t\tlast = &entry->pl_next;\n\t\t}\n\n\t\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\t\tentry = zfs_alloc(hdl, sizeof (zprop_list_t));\n\t\t\tentry->pl_prop = ZPROP_USERPROP;\n\t\t\tentry->pl_user_prop = zfs_asprintf(hdl, \"feature@%s\",\n\t\t\t    spa_feature_table[i].fi_uname);\n\t\t\tentry->pl_width = strlen(entry->pl_user_prop);\n\t\t\tentry->pl_all = B_TRUE;\n\n\t\t\t*last = entry;\n\t\t\tlast = &entry->pl_next;\n\t\t}\n\t}\n\n\t \n\tfor (nvp = nvlist_next_nvpair(features, NULL);\n\t    nvp != NULL; nvp = nvlist_next_nvpair(features, nvp)) {\n\t\tchar *propname;\n\t\tboolean_t found;\n\n\t\tif (zfeature_is_supported(nvpair_name(nvp)))\n\t\t\tcontinue;\n\n\t\tpropname = zfs_asprintf(hdl, \"unsupported@%s\",\n\t\t    nvpair_name(nvp));\n\n\t\t \n\t\tfound = B_FALSE;\n\t\tentry = *plp;\n\t\twhile (entry != NULL) {\n\t\t\tif (entry->pl_user_prop != NULL &&\n\t\t\t    strcmp(propname, entry->pl_user_prop) == 0) {\n\t\t\t\tfound = B_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = entry->pl_next;\n\t\t}\n\t\tif (found) {\n\t\t\tfree(propname);\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry = zfs_alloc(hdl, sizeof (zprop_list_t));\n\t\tentry->pl_prop = ZPROP_USERPROP;\n\t\tentry->pl_user_prop = propname;\n\t\tentry->pl_width = strlen(entry->pl_user_prop);\n\t\tentry->pl_all = B_TRUE;\n\n\t\t*last = entry;\n\t\tlast = &entry->pl_next;\n\t}\n\n\tfor (entry = *plp; entry != NULL; entry = entry->pl_next) {\n\t\tif (entry->pl_fixed && !literal)\n\t\t\tcontinue;\n\n\t\tif (entry->pl_prop != ZPROP_USERPROP &&\n\t\t    zpool_get_prop(zhp, entry->pl_prop, buf, sizeof (buf),\n\t\t    NULL, literal) == 0) {\n\t\t\tif (strlen(buf) > entry->pl_width)\n\t\t\t\tentry->pl_width = strlen(buf);\n\t\t} else if (entry->pl_prop == ZPROP_INVAL &&\n\t\t    zfs_prop_user(entry->pl_user_prop) &&\n\t\t    zpool_get_userprop(zhp, entry->pl_user_prop, buf,\n\t\t    sizeof (buf), NULL) == 0) {\n\t\t\tif (strlen(buf) > entry->pl_width)\n\t\t\t\tentry->pl_width = strlen(buf);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nint\nvdev_expand_proplist(zpool_handle_t *zhp, const char *vdevname,\n    zprop_list_t **plp)\n{\n\tzprop_list_t *entry;\n\tchar buf[ZFS_MAXPROPLEN];\n\tconst char *strval = NULL;\n\tint err = 0;\n\tnvpair_t *elem = NULL;\n\tnvlist_t *vprops = NULL;\n\tnvlist_t *propval = NULL;\n\tconst char *propname;\n\tvdev_prop_t prop;\n\tzprop_list_t **last;\n\n\tfor (entry = *plp; entry != NULL; entry = entry->pl_next) {\n\t\tif (entry->pl_fixed)\n\t\t\tcontinue;\n\n\t\tif (zpool_get_vdev_prop(zhp, vdevname, entry->pl_prop,\n\t\t    entry->pl_user_prop, buf, sizeof (buf), NULL,\n\t\t    B_FALSE) == 0) {\n\t\t\tif (strlen(buf) > entry->pl_width)\n\t\t\t\tentry->pl_width = strlen(buf);\n\t\t}\n\t\tif (entry->pl_prop == VDEV_PROP_NAME &&\n\t\t    strlen(vdevname) > entry->pl_width)\n\t\t\tentry->pl_width = strlen(vdevname);\n\t}\n\n\t \n\tlast = plp;\n\tif (*last != NULL && (*last)->pl_all == B_TRUE) {\n\t\twhile (*last != NULL)\n\t\t\tlast = &(*last)->pl_next;\n\n\t\terr = zpool_get_all_vdev_props(zhp, vdevname, &vprops);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\twhile ((elem = nvlist_next_nvpair(vprops, elem)) != NULL) {\n\t\t\tpropname = nvpair_name(elem);\n\n\t\t\t \n\t\t\tif ((prop = vdev_name_to_prop(propname)) !=\n\t\t\t    VDEV_PROP_USERPROP)\n\t\t\t\tcontinue;\n\n\t\t\tif (nvpair_value_nvlist(elem, &propval) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tstrval = fnvlist_lookup_string(propval, ZPROP_VALUE);\n\n\t\t\tentry = zfs_alloc(zhp->zpool_hdl,\n\t\t\t    sizeof (zprop_list_t));\n\t\t\tentry->pl_prop = prop;\n\t\t\tentry->pl_user_prop = zfs_strdup(zhp->zpool_hdl,\n\t\t\t    propname);\n\t\t\tentry->pl_width = strlen(strval);\n\t\t\tentry->pl_all = B_TRUE;\n\t\t\t*last = entry;\n\t\t\tlast = &entry->pl_next;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_prop_get_feature(zpool_handle_t *zhp, const char *propname, char *buf,\n    size_t len)\n{\n\tuint64_t refcount;\n\tboolean_t found = B_FALSE;\n\tnvlist_t *features = zpool_get_features(zhp);\n\tboolean_t supported;\n\tconst char *feature = strchr(propname, '@') + 1;\n\n\tsupported = zpool_prop_feature(propname);\n\tASSERT(supported || zpool_prop_unsupported(propname));\n\n\t \n\tif (supported) {\n\t\tint ret;\n\t\tspa_feature_t fid;\n\n\t\tret = zfeature_lookup_name(feature, &fid);\n\t\tif (ret != 0) {\n\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\treturn (ENOTSUP);\n\t\t}\n\t\tfeature = spa_feature_table[fid].fi_guid;\n\t}\n\n\tif (nvlist_lookup_uint64(features, feature, &refcount) == 0)\n\t\tfound = B_TRUE;\n\n\tif (supported) {\n\t\tif (!found) {\n\t\t\t(void) strlcpy(buf, ZFS_FEATURE_DISABLED, len);\n\t\t} else  {\n\t\t\tif (refcount == 0)\n\t\t\t\t(void) strlcpy(buf, ZFS_FEATURE_ENABLED, len);\n\t\t\telse\n\t\t\t\t(void) strlcpy(buf, ZFS_FEATURE_ACTIVE, len);\n\t\t}\n\t} else {\n\t\tif (found) {\n\t\t\tif (refcount == 0) {\n\t\t\t\t(void) strcpy(buf, ZFS_UNSUPPORTED_INACTIVE);\n\t\t\t} else {\n\t\t\t\t(void) strcpy(buf, ZFS_UNSUPPORTED_READONLY);\n\t\t\t}\n\t\t} else {\n\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\treturn (ENOTSUP);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nboolean_t\nzpool_name_valid(libzfs_handle_t *hdl, boolean_t isopen, const char *pool)\n{\n\tnamecheck_err_t why;\n\tchar what;\n\tint ret;\n\n\tret = pool_namecheck(pool, &why, &what);\n\n\t \n\tif (ret == 0 && !isopen &&\n\t    (strncmp(pool, \"mirror\", 6) == 0 ||\n\t    strncmp(pool, \"raidz\", 5) == 0 ||\n\t    strncmp(pool, \"draid\", 5) == 0 ||\n\t    strncmp(pool, \"spare\", 5) == 0 ||\n\t    strcmp(pool, \"log\") == 0)) {\n\t\tif (hdl != NULL)\n\t\t\tzfs_error_aux(hdl,\n\t\t\t    dgettext(TEXT_DOMAIN, \"name is reserved\"));\n\t\treturn (B_FALSE);\n\t}\n\n\n\tif (ret != 0) {\n\t\tif (hdl != NULL) {\n\t\t\tswitch (why) {\n\t\t\tcase NAME_ERR_TOOLONG:\n\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"name is too long\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_INVALCHAR:\n\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"invalid character \"\n\t\t\t\t    \"'%c' in pool name\"), what);\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_NOLETTER:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"name must begin with a letter\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_RESERVED:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"name is reserved\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_DISKLIKE:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"pool name is reserved\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_LEADING_SLASH:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"leading slash in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_EMPTY_COMPONENT:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"empty component in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_TRAILING_SLASH:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"trailing slash in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_MULTIPLE_DELIMITERS:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"multiple '@' and/or '#' delimiters in \"\n\t\t\t\t    \"name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_NO_AT:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"permission set is missing '@'\"));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"(%d) not defined\"), why);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (B_FALSE);\n\t}\n\n\treturn (B_TRUE);\n}\n\n \nzpool_handle_t *\nzpool_open_canfail(libzfs_handle_t *hdl, const char *pool)\n{\n\tzpool_handle_t *zhp;\n\tboolean_t missing;\n\n\t \n\tif (!zpool_name_valid(hdl, B_TRUE, pool)) {\n\t\t(void) zfs_error_fmt(hdl, EZFS_INVALIDNAME,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot open '%s'\"),\n\t\t    pool);\n\t\treturn (NULL);\n\t}\n\n\tzhp = zfs_alloc(hdl, sizeof (zpool_handle_t));\n\n\tzhp->zpool_hdl = hdl;\n\t(void) strlcpy(zhp->zpool_name, pool, sizeof (zhp->zpool_name));\n\n\tif (zpool_refresh_stats(zhp, &missing) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (NULL);\n\t}\n\n\tif (missing) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"no such pool\"));\n\t\t(void) zfs_error_fmt(hdl, EZFS_NOENT,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot open '%s'\"), pool);\n\t\tzpool_close(zhp);\n\t\treturn (NULL);\n\t}\n\n\treturn (zhp);\n}\n\n \nint\nzpool_open_silent(libzfs_handle_t *hdl, const char *pool, zpool_handle_t **ret)\n{\n\tzpool_handle_t *zhp;\n\tboolean_t missing;\n\n\tzhp = zfs_alloc(hdl, sizeof (zpool_handle_t));\n\n\tzhp->zpool_hdl = hdl;\n\t(void) strlcpy(zhp->zpool_name, pool, sizeof (zhp->zpool_name));\n\n\tif (zpool_refresh_stats(zhp, &missing) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (-1);\n\t}\n\n\tif (missing) {\n\t\tzpool_close(zhp);\n\t\t*ret = NULL;\n\t\treturn (0);\n\t}\n\n\t*ret = zhp;\n\treturn (0);\n}\n\n \nzpool_handle_t *\nzpool_open(libzfs_handle_t *hdl, const char *pool)\n{\n\tzpool_handle_t *zhp;\n\n\tif ((zhp = zpool_open_canfail(hdl, pool)) == NULL)\n\t\treturn (NULL);\n\n\tif (zhp->zpool_state == POOL_STATE_UNAVAIL) {\n\t\t(void) zfs_error_fmt(hdl, EZFS_POOLUNAVAIL,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot open '%s'\"), zhp->zpool_name);\n\t\tzpool_close(zhp);\n\t\treturn (NULL);\n\t}\n\n\treturn (zhp);\n}\n\n \nvoid\nzpool_close(zpool_handle_t *zhp)\n{\n\tnvlist_free(zhp->zpool_config);\n\tnvlist_free(zhp->zpool_old_config);\n\tnvlist_free(zhp->zpool_props);\n\tfree(zhp);\n}\n\n \nconst char *\nzpool_get_name(zpool_handle_t *zhp)\n{\n\treturn (zhp->zpool_name);\n}\n\n\n \nint\nzpool_get_state(zpool_handle_t *zhp)\n{\n\treturn (zhp->zpool_state);\n}\n\n \nstatic boolean_t\nzpool_has_special_vdev(nvlist_t *nvroot)\n{\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) == 0) {\n\t\tfor (uint_t c = 0; c < children; c++) {\n\t\t\tconst char *bias;\n\n\t\t\tif (nvlist_lookup_string(child[c],\n\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, &bias) == 0 &&\n\t\t\t    strcmp(bias, VDEV_ALLOC_BIAS_SPECIAL) == 0) {\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic boolean_t\nzpool_has_draid_vdev(nvlist_t *nvroot)\n{\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (uint_t c = 0; c < children; c++) {\n\t\t\tconst char *type;\n\n\t\t\tif (nvlist_lookup_string(child[c],\n\t\t\t    ZPOOL_CONFIG_TYPE, &type) == 0 &&\n\t\t\t    strcmp(type, VDEV_TYPE_DRAID) == 0) {\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic char *\nzpool_draid_name(char *name, int len, uint64_t data, uint64_t parity,\n    uint64_t spares, uint64_t children)\n{\n\tsnprintf(name, len, \"%s%llu:%llud:%lluc:%llus\",\n\t    VDEV_TYPE_DRAID, (u_longlong_t)parity, (u_longlong_t)data,\n\t    (u_longlong_t)children, (u_longlong_t)spares);\n\n\treturn (name);\n}\n\n \nboolean_t\nzpool_is_draid_spare(const char *name)\n{\n\tuint64_t spare_id, parity, vdev_id;\n\n\tif (sscanf(name, VDEV_TYPE_DRAID \"%llu-%llu-%llu\",\n\t    (u_longlong_t *)&parity, (u_longlong_t *)&vdev_id,\n\t    (u_longlong_t *)&spare_id) == 3) {\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nint\nzpool_create(libzfs_handle_t *hdl, const char *pool, nvlist_t *nvroot,\n    nvlist_t *props, nvlist_t *fsprops)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tnvlist_t *zc_fsprops = NULL;\n\tnvlist_t *zc_props = NULL;\n\tnvlist_t *hidden_args = NULL;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeylen = 0;\n\tchar errbuf[ERRBUFLEN];\n\tint ret = -1;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot create '%s'\"), pool);\n\n\tif (!zpool_name_valid(hdl, B_FALSE, pool))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\tzcmd_write_conf_nvlist(hdl, &zc, nvroot);\n\n\tif (props) {\n\t\tprop_flags_t flags = { .create = B_TRUE, .import = B_FALSE };\n\n\t\tif ((zc_props = zpool_valid_proplist(hdl, pool, props,\n\t\t    SPA_VERSION_1, flags, errbuf)) == NULL) {\n\t\t\tgoto create_failed;\n\t\t}\n\t}\n\n\tif (fsprops) {\n\t\tuint64_t zoned;\n\t\tconst char *zonestr;\n\n\t\tzoned = ((nvlist_lookup_string(fsprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_ZONED), &zonestr) == 0) &&\n\t\t    strcmp(zonestr, \"on\") == 0);\n\n\t\tif ((zc_fsprops = zfs_valid_proplist(hdl, ZFS_TYPE_FILESYSTEM,\n\t\t    fsprops, zoned, NULL, NULL, B_TRUE, errbuf)) == NULL) {\n\t\t\tgoto create_failed;\n\t\t}\n\n\t\tif (nvlist_exists(zc_fsprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_SPECIAL_SMALL_BLOCKS)) &&\n\t\t    !zpool_has_special_vdev(nvroot)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"%s property requires a special vdev\"),\n\t\t\t    zfs_prop_to_name(ZFS_PROP_SPECIAL_SMALL_BLOCKS));\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto create_failed;\n\t\t}\n\n\t\tif (!zc_props &&\n\t\t    (nvlist_alloc(&zc_props, NV_UNIQUE_NAME, 0) != 0)) {\n\t\t\tgoto create_failed;\n\t\t}\n\t\tif (zfs_crypto_create(hdl, NULL, zc_fsprops, props, B_TRUE,\n\t\t    &wkeydata, &wkeylen) != 0) {\n\t\t\tzfs_error(hdl, EZFS_CRYPTOFAILED, errbuf);\n\t\t\tgoto create_failed;\n\t\t}\n\t\tif (nvlist_add_nvlist(zc_props,\n\t\t    ZPOOL_ROOTFS_PROPS, zc_fsprops) != 0) {\n\t\t\tgoto create_failed;\n\t\t}\n\t\tif (wkeydata != NULL) {\n\t\t\tif (nvlist_alloc(&hidden_args, NV_UNIQUE_NAME, 0) != 0)\n\t\t\t\tgoto create_failed;\n\n\t\t\tif (nvlist_add_uint8_array(hidden_args, \"wkeydata\",\n\t\t\t    wkeydata, wkeylen) != 0)\n\t\t\t\tgoto create_failed;\n\n\t\t\tif (nvlist_add_nvlist(zc_props, ZPOOL_HIDDEN_ARGS,\n\t\t\t    hidden_args) != 0)\n\t\t\t\tgoto create_failed;\n\t\t}\n\t}\n\n\tif (zc_props)\n\t\tzcmd_write_src_nvlist(hdl, &zc, zc_props);\n\n\t(void) strlcpy(zc.zc_name, pool, sizeof (zc.zc_name));\n\n\tif ((ret = zfs_ioctl(hdl, ZFS_IOC_POOL_CREATE, &zc)) != 0) {\n\n\t\tzcmd_free_nvlists(&zc);\n\t\tnvlist_free(zc_props);\n\t\tnvlist_free(zc_fsprops);\n\t\tnvlist_free(hidden_args);\n\t\tif (wkeydata != NULL)\n\t\t\tfree(wkeydata);\n\n\t\tswitch (errno) {\n\t\tcase EBUSY:\n\t\t\t \n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"one or more vdevs refer to the same device, or \"\n\t\t\t    \"one of\\nthe devices is part of an active md or \"\n\t\t\t    \"lvm device\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADDEV, errbuf));\n\n\t\tcase ERANGE:\n\t\t\t \n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"record size invalid\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\n\t\tcase EOVERFLOW:\n\t\t\t \n\t\t\t{\n\t\t\t\tchar buf[64];\n\n\t\t\t\tzfs_nicebytes(SPA_MINDEVSIZE, buf,\n\t\t\t\t    sizeof (buf));\n\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"one or more devices is less than the \"\n\t\t\t\t    \"minimum size (%s)\"), buf);\n\t\t\t}\n\t\t\treturn (zfs_error(hdl, EZFS_BADDEV, errbuf));\n\n\t\tcase ENOSPC:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"one or more devices is out of space\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADDEV, errbuf));\n\n\t\tcase EINVAL:\n\t\t\tif (zpool_has_draid_vdev(nvroot) &&\n\t\t\t    zfeature_lookup_name(\"draid\", NULL) != 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"dRAID vdevs are unsupported by the \"\n\t\t\t\t    \"kernel\"));\n\t\t\t\treturn (zfs_error(hdl, EZFS_BADDEV, errbuf));\n\t\t\t} else {\n\t\t\t\treturn (zpool_standard_error(hdl, errno,\n\t\t\t\t    errbuf));\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn (zpool_standard_error(hdl, errno, errbuf));\n\t\t}\n\t}\n\ncreate_failed:\n\tzcmd_free_nvlists(&zc);\n\tnvlist_free(zc_props);\n\tnvlist_free(zc_fsprops);\n\tnvlist_free(hidden_args);\n\tif (wkeydata != NULL)\n\t\tfree(wkeydata);\n\treturn (ret);\n}\n\n \nint\nzpool_destroy(zpool_handle_t *zhp, const char *log_str)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzfs_handle_t *zfp = NULL;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tchar errbuf[ERRBUFLEN];\n\n\tif (zhp->zpool_state == POOL_STATE_ACTIVE &&\n\t    (zfp = zfs_open(hdl, zhp->zpool_name, ZFS_TYPE_FILESYSTEM)) == NULL)\n\t\treturn (-1);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_history = (uint64_t)(uintptr_t)log_str;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_POOL_DESTROY, &zc) != 0) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot destroy '%s'\"), zhp->zpool_name);\n\n\t\tif (errno == EROFS) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"one or more devices is read only\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\t} else {\n\t\t\t(void) zpool_standard_error(hdl, errno, errbuf);\n\t\t}\n\n\t\tif (zfp)\n\t\t\tzfs_close(zfp);\n\t\treturn (-1);\n\t}\n\n\tif (zfp) {\n\t\tremove_mountpoint(zfp);\n\t\tzfs_close(zfp);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_checkpoint(zpool_handle_t *zhp)\n{\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tchar errbuf[ERRBUFLEN];\n\tint error;\n\n\terror = lzc_pool_checkpoint(zhp->zpool_name);\n\tif (error != 0) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot checkpoint '%s'\"), zhp->zpool_name);\n\t\t(void) zpool_standard_error(hdl, error, errbuf);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_discard_checkpoint(zpool_handle_t *zhp)\n{\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tchar errbuf[ERRBUFLEN];\n\tint error;\n\n\terror = lzc_pool_checkpoint_discard(zhp->zpool_name);\n\tif (error != 0) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot discard checkpoint in '%s'\"), zhp->zpool_name);\n\t\t(void) zpool_standard_error(hdl, error, errbuf);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_add(zpool_handle_t *zhp, nvlist_t *nvroot)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint ret;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t **spares, **l2cache;\n\tuint_t nspares, nl2cache;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot add to '%s'\"), zhp->zpool_name);\n\n\tif (zpool_get_prop_int(zhp, ZPOOL_PROP_VERSION, NULL) <\n\t    SPA_VERSION_SPARES &&\n\t    nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t    &spares, &nspares) == 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"pool must be \"\n\t\t    \"upgraded to add hot spares\"));\n\t\treturn (zfs_error(hdl, EZFS_BADVERSION, errbuf));\n\t}\n\n\tif (zpool_get_prop_int(zhp, ZPOOL_PROP_VERSION, NULL) <\n\t    SPA_VERSION_L2CACHE &&\n\t    nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_L2CACHE,\n\t    &l2cache, &nl2cache) == 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"pool must be \"\n\t\t    \"upgraded to add cache devices\"));\n\t\treturn (zfs_error(hdl, EZFS_BADVERSION, errbuf));\n\t}\n\n\tzcmd_write_conf_nvlist(hdl, &zc, nvroot);\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_ADD, &zc) != 0) {\n\t\tswitch (errno) {\n\t\tcase EBUSY:\n\t\t\t \n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"one or more vdevs refer to the same device\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\t\tbreak;\n\n\t\tcase EINVAL:\n\n\t\t\tif (zpool_has_draid_vdev(nvroot) &&\n\t\t\t    zfeature_lookup_name(\"draid\", NULL) != 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"dRAID vdevs are unsupported by the \"\n\t\t\t\t    \"kernel\"));\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"invalid config; a pool with removing/\"\n\t\t\t\t    \"removed vdevs does not support adding \"\n\t\t\t\t    \"raidz or dRAID vdevs\"));\n\t\t\t}\n\n\t\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\t\tbreak;\n\n\t\tcase EOVERFLOW:\n\t\t\t \n\t\t\t{\n\t\t\t\tchar buf[64];\n\n\t\t\t\tzfs_nicebytes(SPA_MINDEVSIZE, buf,\n\t\t\t\t    sizeof (buf));\n\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"device is less than the minimum \"\n\t\t\t\t    \"size (%s)\"), buf);\n\t\t\t}\n\t\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\t\tbreak;\n\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded to add these vdevs\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) zpool_standard_error(hdl, errno, errbuf);\n\t\t}\n\n\t\tret = -1;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tzcmd_free_nvlists(&zc);\n\n\treturn (ret);\n}\n\n \nstatic int\nzpool_export_common(zpool_handle_t *zhp, boolean_t force, boolean_t hardforce,\n    const char *log_str)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_cookie = force;\n\tzc.zc_guid = hardforce;\n\tzc.zc_history = (uint64_t)(uintptr_t)log_str;\n\n\tif (zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_POOL_EXPORT, &zc) != 0) {\n\t\tswitch (errno) {\n\t\tcase EXDEV:\n\t\t\tzfs_error_aux(zhp->zpool_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"use '-f' to override the following errors:\\n\"\n\t\t\t    \"'%s' has an active shared spare which could be\"\n\t\t\t    \" used by other pools once '%s' is exported.\"),\n\t\t\t    zhp->zpool_name, zhp->zpool_name);\n\t\t\treturn (zfs_error_fmt(zhp->zpool_hdl, EZFS_ACTIVE_SPARE,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot export '%s'\"),\n\t\t\t    zhp->zpool_name));\n\t\tdefault:\n\t\t\treturn (zpool_standard_error_fmt(zhp->zpool_hdl, errno,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot export '%s'\"),\n\t\t\t    zhp->zpool_name));\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nint\nzpool_export(zpool_handle_t *zhp, boolean_t force, const char *log_str)\n{\n\treturn (zpool_export_common(zhp, force, B_FALSE, log_str));\n}\n\nint\nzpool_export_force(zpool_handle_t *zhp, const char *log_str)\n{\n\treturn (zpool_export_common(zhp, B_TRUE, B_TRUE, log_str));\n}\n\nstatic void\nzpool_rewind_exclaim(libzfs_handle_t *hdl, const char *name, boolean_t dryrun,\n    nvlist_t *config)\n{\n\tnvlist_t *nv = NULL;\n\tuint64_t rewindto;\n\tint64_t loss = -1;\n\tstruct tm t;\n\tchar timestr[128];\n\n\tif (!hdl->libzfs_printerr || config == NULL)\n\t\treturn;\n\n\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_LOAD_INFO, &nv) != 0 ||\n\t    nvlist_lookup_nvlist(nv, ZPOOL_CONFIG_REWIND_INFO, &nv) != 0) {\n\t\treturn;\n\t}\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_LOAD_TIME, &rewindto) != 0)\n\t\treturn;\n\t(void) nvlist_lookup_int64(nv, ZPOOL_CONFIG_REWIND_TIME, &loss);\n\n\tif (localtime_r((time_t *)&rewindto, &t) != NULL &&\n\t    strftime(timestr, 128, \"%c\", &t) != 0) {\n\t\tif (dryrun) {\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"Would be able to return %s \"\n\t\t\t    \"to its state as of %s.\\n\"),\n\t\t\t    name, timestr);\n\t\t} else {\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"Pool %s returned to its state as of %s.\\n\"),\n\t\t\t    name, timestr);\n\t\t}\n\t\tif (loss > 120) {\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"%s approximately %lld \"),\n\t\t\t    dryrun ? \"Would discard\" : \"Discarded\",\n\t\t\t    ((longlong_t)loss + 30) / 60);\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"minutes of transactions.\\n\"));\n\t\t} else if (loss > 0) {\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"%s approximately %lld \"),\n\t\t\t    dryrun ? \"Would discard\" : \"Discarded\",\n\t\t\t    (longlong_t)loss);\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"seconds of transactions.\\n\"));\n\t\t}\n\t}\n}\n\nvoid\nzpool_explain_recover(libzfs_handle_t *hdl, const char *name, int reason,\n    nvlist_t *config)\n{\n\tnvlist_t *nv = NULL;\n\tint64_t loss = -1;\n\tuint64_t edata = UINT64_MAX;\n\tuint64_t rewindto;\n\tstruct tm t;\n\tchar timestr[128];\n\n\tif (!hdl->libzfs_printerr)\n\t\treturn;\n\n\tif (reason >= 0)\n\t\t(void) printf(dgettext(TEXT_DOMAIN, \"action: \"));\n\telse\n\t\t(void) printf(dgettext(TEXT_DOMAIN, \"\\t\"));\n\n\t \n\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_LOAD_INFO, &nv) != 0 ||\n\t    nvlist_lookup_nvlist(nv, ZPOOL_CONFIG_REWIND_INFO, &nv) != 0 ||\n\t    nvlist_lookup_uint64(nv, ZPOOL_CONFIG_LOAD_TIME, &rewindto) != 0)\n\t\tgoto no_info;\n\n\t(void) nvlist_lookup_int64(nv, ZPOOL_CONFIG_REWIND_TIME, &loss);\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_LOAD_DATA_ERRORS,\n\t    &edata);\n\n\t(void) printf(dgettext(TEXT_DOMAIN,\n\t    \"Recovery is possible, but will result in some data loss.\\n\"));\n\n\tif (localtime_r((time_t *)&rewindto, &t) != NULL &&\n\t    strftime(timestr, 128, \"%c\", &t) != 0) {\n\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t    \"\\tReturning the pool to its state as of %s\\n\"\n\t\t    \"\\tshould correct the problem.  \"),\n\t\t    timestr);\n\t} else {\n\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t    \"\\tReverting the pool to an earlier state \"\n\t\t    \"should correct the problem.\\n\\t\"));\n\t}\n\n\tif (loss > 120) {\n\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t    \"Approximately %lld minutes of data\\n\"\n\t\t    \"\\tmust be discarded, irreversibly.  \"),\n\t\t    ((longlong_t)loss + 30) / 60);\n\t} else if (loss > 0) {\n\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t    \"Approximately %lld seconds of data\\n\"\n\t\t    \"\\tmust be discarded, irreversibly.  \"),\n\t\t    (longlong_t)loss);\n\t}\n\tif (edata != 0 && edata != UINT64_MAX) {\n\t\tif (edata == 1) {\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"After rewind, at least\\n\"\n\t\t\t    \"\\tone persistent user-data error will remain.  \"));\n\t\t} else {\n\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t    \"After rewind, several\\n\"\n\t\t\t    \"\\tpersistent user-data errors will remain.  \"));\n\t\t}\n\t}\n\t(void) printf(dgettext(TEXT_DOMAIN,\n\t    \"Recovery can be attempted\\n\\tby executing 'zpool %s -F %s'.  \"),\n\t    reason >= 0 ? \"clear\" : \"import\", name);\n\n\t(void) printf(dgettext(TEXT_DOMAIN,\n\t    \"A scrub of the pool\\n\"\n\t    \"\\tis strongly recommended after recovery.\\n\"));\n\treturn;\n\nno_info:\n\t(void) printf(dgettext(TEXT_DOMAIN,\n\t    \"Destroy and re-create the pool from\\n\\ta backup source.\\n\"));\n}\n\n \nint\nzpool_import(libzfs_handle_t *hdl, nvlist_t *config, const char *newname,\n    char *altroot)\n{\n\tnvlist_t *props = NULL;\n\tint ret;\n\n\tif (altroot != NULL) {\n\t\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0) {\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_NOMEM,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot import '%s'\"),\n\t\t\t    newname));\n\t\t}\n\n\t\tif (nvlist_add_string(props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_ALTROOT), altroot) != 0 ||\n\t\t    nvlist_add_string(props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_CACHEFILE), \"none\") != 0) {\n\t\t\tnvlist_free(props);\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_NOMEM,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot import '%s'\"),\n\t\t\t    newname));\n\t\t}\n\t}\n\n\tret = zpool_import_props(hdl, config, newname, props,\n\t    ZFS_IMPORT_NORMAL);\n\tnvlist_free(props);\n\treturn (ret);\n}\n\nstatic void\nprint_vdev_tree(libzfs_handle_t *hdl, const char *name, nvlist_t *nv,\n    int indent)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tchar *vname;\n\tuint64_t is_log = 0;\n\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_IS_LOG,\n\t    &is_log);\n\n\tif (name != NULL)\n\t\t(void) printf(\"\\t%*s%s%s\\n\", indent, \"\", name,\n\t\t    is_log ? \" [log]\" : \"\");\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\treturn;\n\n\tfor (c = 0; c < children; c++) {\n\t\tvname = zpool_vdev_name(hdl, NULL, child[c], VDEV_NAME_TYPE_ID);\n\t\tprint_vdev_tree(hdl, vname, child[c], indent + 2);\n\t\tfree(vname);\n\t}\n}\n\nvoid\nzpool_print_unsup_feat(nvlist_t *config)\n{\n\tnvlist_t *nvinfo, *unsup_feat;\n\n\tnvinfo = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_LOAD_INFO);\n\tunsup_feat = fnvlist_lookup_nvlist(nvinfo, ZPOOL_CONFIG_UNSUP_FEAT);\n\n\tfor (nvpair_t *nvp = nvlist_next_nvpair(unsup_feat, NULL);\n\t    nvp != NULL; nvp = nvlist_next_nvpair(unsup_feat, nvp)) {\n\t\tconst char *desc = fnvpair_value_string(nvp);\n\t\tif (strlen(desc) > 0)\n\t\t\t(void) printf(\"\\t%s (%s)\\n\", nvpair_name(nvp), desc);\n\t\telse\n\t\t\t(void) printf(\"\\t%s\\n\", nvpair_name(nvp));\n\t}\n}\n\n \nint\nzpool_import_props(libzfs_handle_t *hdl, nvlist_t *config, const char *newname,\n    nvlist_t *props, int flags)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzpool_load_policy_t policy;\n\tnvlist_t *nv = NULL;\n\tnvlist_t *nvinfo = NULL;\n\tnvlist_t *missing = NULL;\n\tconst char *thename;\n\tconst char *origname;\n\tint ret;\n\tint error = 0;\n\tchar errbuf[ERRBUFLEN];\n\n\torigname = fnvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME);\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot import pool '%s'\"), origname);\n\n\tif (newname != NULL) {\n\t\tif (!zpool_name_valid(hdl, B_FALSE, newname))\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_INVALIDNAME,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot import '%s'\"),\n\t\t\t    newname));\n\t\tthename = newname;\n\t} else {\n\t\tthename = origname;\n\t}\n\n\tif (props != NULL) {\n\t\tuint64_t version;\n\t\tprop_flags_t flags = { .create = B_FALSE, .import = B_TRUE };\n\n\t\tversion = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION);\n\n\t\tif ((props = zpool_valid_proplist(hdl, origname,\n\t\t    props, version, flags, errbuf)) == NULL)\n\t\t\treturn (-1);\n\t\tzcmd_write_src_nvlist(hdl, &zc, props);\n\t\tnvlist_free(props);\n\t}\n\n\t(void) strlcpy(zc.zc_name, thename, sizeof (zc.zc_name));\n\n\tzc.zc_guid = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID);\n\n\tzcmd_write_conf_nvlist(hdl, &zc, config);\n\tzcmd_alloc_dst_nvlist(hdl, &zc, zc.zc_nvlist_conf_size * 2);\n\n\tzc.zc_cookie = flags;\n\twhile ((ret = zfs_ioctl(hdl, ZFS_IOC_POOL_IMPORT, &zc)) != 0 &&\n\t    errno == ENOMEM)\n\t\tzcmd_expand_dst_nvlist(hdl, &zc);\n\tif (ret != 0)\n\t\terror = errno;\n\n\t(void) zcmd_read_dst_nvlist(hdl, &zc, &nv);\n\n\tzcmd_free_nvlists(&zc);\n\n\tzpool_get_load_policy(config, &policy);\n\n\tif (error) {\n\t\tchar desc[1024];\n\t\tchar aux[256];\n\n\t\t \n\t\tif (policy.zlp_rewind & ZPOOL_TRY_REWIND) {\n\t\t\tzpool_rewind_exclaim(hdl, newname ? origname : thename,\n\t\t\t    B_TRUE, nv);\n\t\t\tnvlist_free(nv);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (newname == NULL)\n\t\t\t(void) snprintf(desc, sizeof (desc),\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot import '%s'\"),\n\t\t\t    thename);\n\t\telse\n\t\t\t(void) snprintf(desc, sizeof (desc),\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot import '%s' as '%s'\"),\n\t\t\t    origname, thename);\n\n\t\tswitch (error) {\n\t\tcase ENOTSUP:\n\t\t\tif (nv != NULL && nvlist_lookup_nvlist(nv,\n\t\t\t    ZPOOL_CONFIG_LOAD_INFO, &nvinfo) == 0 &&\n\t\t\t    nvlist_exists(nvinfo, ZPOOL_CONFIG_UNSUP_FEAT)) {\n\t\t\t\t(void) printf(dgettext(TEXT_DOMAIN, \"This \"\n\t\t\t\t    \"pool uses the following feature(s) not \"\n\t\t\t\t    \"supported by this system:\\n\"));\n\t\t\t\tzpool_print_unsup_feat(nv);\n\t\t\t\tif (nvlist_exists(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_CAN_RDONLY)) {\n\t\t\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"All unsupported features are only \"\n\t\t\t\t\t    \"required for writing to the pool.\"\n\t\t\t\t\t    \"\\nThe pool can be imported using \"\n\t\t\t\t\t    \"'-o readonly=on'.\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, desc);\n\t\t\tbreak;\n\n\t\tcase EREMOTEIO:\n\t\t\tif (nv != NULL && nvlist_lookup_nvlist(nv,\n\t\t\t    ZPOOL_CONFIG_LOAD_INFO, &nvinfo) == 0) {\n\t\t\t\tconst char *hostname = \"<unknown>\";\n\t\t\t\tuint64_t hostid = 0;\n\t\t\t\tmmp_state_t mmp_state;\n\n\t\t\t\tmmp_state = fnvlist_lookup_uint64(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_STATE);\n\n\t\t\t\tif (nvlist_exists(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTNAME))\n\t\t\t\t\thostname = fnvlist_lookup_string(nvinfo,\n\t\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTNAME);\n\n\t\t\t\tif (nvlist_exists(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTID))\n\t\t\t\t\thostid = fnvlist_lookup_uint64(nvinfo,\n\t\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTID);\n\n\t\t\t\tif (mmp_state == MMP_STATE_ACTIVE) {\n\t\t\t\t\t(void) snprintf(aux, sizeof (aux),\n\t\t\t\t\t    dgettext(TEXT_DOMAIN, \"pool is imp\"\n\t\t\t\t\t    \"orted on host '%s' (hostid=%lx).\\n\"\n\t\t\t\t\t    \"Export the pool on the other \"\n\t\t\t\t\t    \"system, then run 'zpool import'.\"),\n\t\t\t\t\t    hostname, (unsigned long) hostid);\n\t\t\t\t} else if (mmp_state == MMP_STATE_NO_HOSTID) {\n\t\t\t\t\t(void) snprintf(aux, sizeof (aux),\n\t\t\t\t\t    dgettext(TEXT_DOMAIN, \"pool has \"\n\t\t\t\t\t    \"the multihost property on and \"\n\t\t\t\t\t    \"the\\nsystem's hostid is not set. \"\n\t\t\t\t\t    \"Set a unique system hostid with \"\n\t\t\t\t\t    \"the zgenhostid(8) command.\\n\"));\n\t\t\t\t}\n\n\t\t\t\t(void) zfs_error_aux(hdl, \"%s\", aux);\n\t\t\t}\n\t\t\t(void) zfs_error(hdl, EZFS_ACTIVE_POOL, desc);\n\t\t\tbreak;\n\n\t\tcase EINVAL:\n\t\t\t(void) zfs_error(hdl, EZFS_INVALCONFIG, desc);\n\t\t\tbreak;\n\n\t\tcase EROFS:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"one or more devices is read only\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADDEV, desc);\n\t\t\tbreak;\n\n\t\tcase ENXIO:\n\t\t\tif (nv && nvlist_lookup_nvlist(nv,\n\t\t\t    ZPOOL_CONFIG_LOAD_INFO, &nvinfo) == 0 &&\n\t\t\t    nvlist_lookup_nvlist(nvinfo,\n\t\t\t    ZPOOL_CONFIG_MISSING_DEVICES, &missing) == 0) {\n\t\t\t\t(void) printf(dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"The devices below are missing or \"\n\t\t\t\t    \"corrupted, use '-m' to import the pool \"\n\t\t\t\t    \"anyway:\\n\"));\n\t\t\t\tprint_vdev_tree(hdl, NULL, missing, 2);\n\t\t\t\t(void) printf(\"\\n\");\n\t\t\t}\n\t\t\t(void) zpool_standard_error(hdl, error, desc);\n\t\t\tbreak;\n\n\t\tcase EEXIST:\n\t\t\t(void) zpool_standard_error(hdl, error, desc);\n\t\t\tbreak;\n\n\t\tcase EBUSY:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"one or more devices are already in use\\n\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADDEV, desc);\n\t\t\tbreak;\n\t\tcase ENAMETOOLONG:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"new name of at least one dataset is longer than \"\n\t\t\t    \"the maximum allowable length\"));\n\t\t\t(void) zfs_error(hdl, EZFS_NAMETOOLONG, desc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zpool_standard_error(hdl, error, desc);\n\t\t\tzpool_explain_recover(hdl,\n\t\t\t    newname ? origname : thename, -error, nv);\n\t\t\tbreak;\n\t\t}\n\n\t\tnvlist_free(nv);\n\t\tret = -1;\n\t} else {\n\t\tzpool_handle_t *zhp;\n\n\t\t \n\t\tif (zpool_open_silent(hdl, thename, &zhp) != 0)\n\t\t\tret = -1;\n\t\telse if (zhp != NULL)\n\t\t\tzpool_close(zhp);\n\t\tif (policy.zlp_rewind &\n\t\t    (ZPOOL_DO_REWIND | ZPOOL_TRY_REWIND)) {\n\t\t\tzpool_rewind_exclaim(hdl, newname ? origname : thename,\n\t\t\t    ((policy.zlp_rewind & ZPOOL_TRY_REWIND) != 0), nv);\n\t\t}\n\t\tnvlist_free(nv);\n\t}\n\n\treturn (ret);\n}\n\n \nstatic int\nzpool_translate_vdev_guids(zpool_handle_t *zhp, nvlist_t *vds,\n    nvlist_t *vdev_guids, nvlist_t *guids_to_paths, nvlist_t **vd_errlist)\n{\n\tnvlist_t *errlist = NULL;\n\tint error = 0;\n\n\tfor (nvpair_t *elem = nvlist_next_nvpair(vds, NULL); elem != NULL;\n\t    elem = nvlist_next_nvpair(vds, elem)) {\n\t\tboolean_t spare, cache;\n\n\t\tconst char *vd_path = nvpair_name(elem);\n\t\tnvlist_t *tgt = zpool_find_vdev(zhp, vd_path, &spare, &cache,\n\t\t    NULL);\n\n\t\tif ((tgt == NULL) || cache || spare) {\n\t\t\tif (errlist == NULL) {\n\t\t\t\terrlist = fnvlist_alloc();\n\t\t\t\terror = EINVAL;\n\t\t\t}\n\n\t\t\tuint64_t err = (tgt == NULL) ? EZFS_NODEVICE :\n\t\t\t    (spare ? EZFS_ISSPARE : EZFS_ISL2CACHE);\n\t\t\tfnvlist_add_int64(errlist, vd_path, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint64_t guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\t\tfnvlist_add_uint64(vdev_guids, vd_path, guid);\n\n\t\tchar msg[MAXNAMELEN];\n\t\t(void) snprintf(msg, sizeof (msg), \"%llu\", (u_longlong_t)guid);\n\t\tfnvlist_add_string(guids_to_paths, msg, vd_path);\n\t}\n\n\tif (error != 0) {\n\t\tverify(errlist != NULL);\n\t\tif (vd_errlist != NULL)\n\t\t\t*vd_errlist = errlist;\n\t\telse\n\t\t\tfnvlist_free(errlist);\n\t}\n\n\treturn (error);\n}\n\nstatic int\nxlate_init_err(int err)\n{\n\tswitch (err) {\n\tcase ENODEV:\n\t\treturn (EZFS_NODEVICE);\n\tcase EINVAL:\n\tcase EROFS:\n\t\treturn (EZFS_BADDEV);\n\tcase EBUSY:\n\t\treturn (EZFS_INITIALIZING);\n\tcase ESRCH:\n\t\treturn (EZFS_NO_INITIALIZE);\n\t}\n\treturn (err);\n}\n\n \nstatic int\nzpool_initialize_impl(zpool_handle_t *zhp, pool_initialize_func_t cmd_type,\n    nvlist_t *vds, boolean_t wait)\n{\n\tint err;\n\n\tnvlist_t *vdev_guids = fnvlist_alloc();\n\tnvlist_t *guids_to_paths = fnvlist_alloc();\n\tnvlist_t *vd_errlist = NULL;\n\tnvlist_t *errlist;\n\tnvpair_t *elem;\n\n\terr = zpool_translate_vdev_guids(zhp, vds, vdev_guids,\n\t    guids_to_paths, &vd_errlist);\n\n\tif (err != 0) {\n\t\tverify(vd_errlist != NULL);\n\t\tgoto list_errors;\n\t}\n\n\terr = lzc_initialize(zhp->zpool_name, cmd_type,\n\t    vdev_guids, &errlist);\n\n\tif (err != 0) {\n\t\tif (errlist != NULL && nvlist_lookup_nvlist(errlist,\n\t\t    ZPOOL_INITIALIZE_VDEVS, &vd_errlist) == 0) {\n\t\t\tgoto list_errors;\n\t\t}\n\n\t\tif (err == EINVAL && cmd_type == POOL_INITIALIZE_UNINIT) {\n\t\t\tzfs_error_aux(zhp->zpool_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"uninitialize is not supported by kernel\"));\n\t\t}\n\n\t\t(void) zpool_standard_error(zhp->zpool_hdl, err,\n\t\t    dgettext(TEXT_DOMAIN, \"operation failed\"));\n\t\tgoto out;\n\t}\n\n\tif (wait) {\n\t\tfor (elem = nvlist_next_nvpair(vdev_guids, NULL); elem != NULL;\n\t\t    elem = nvlist_next_nvpair(vdev_guids, elem)) {\n\n\t\t\tuint64_t guid = fnvpair_value_uint64(elem);\n\n\t\t\terr = lzc_wait_tag(zhp->zpool_name,\n\t\t\t    ZPOOL_WAIT_INITIALIZE, guid, NULL);\n\t\t\tif (err != 0) {\n\t\t\t\t(void) zpool_standard_error_fmt(zhp->zpool_hdl,\n\t\t\t\t    err, dgettext(TEXT_DOMAIN, \"error \"\n\t\t\t\t    \"waiting for '%s' to initialize\"),\n\t\t\t\t    nvpair_name(elem));\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tgoto out;\n\nlist_errors:\n\tfor (elem = nvlist_next_nvpair(vd_errlist, NULL); elem != NULL;\n\t    elem = nvlist_next_nvpair(vd_errlist, elem)) {\n\t\tint64_t vd_error = xlate_init_err(fnvpair_value_int64(elem));\n\t\tconst char *path;\n\n\t\tif (nvlist_lookup_string(guids_to_paths, nvpair_name(elem),\n\t\t    &path) != 0)\n\t\t\tpath = nvpair_name(elem);\n\n\t\t(void) zfs_error_fmt(zhp->zpool_hdl, vd_error,\n\t\t    \"cannot initialize '%s'\", path);\n\t}\n\nout:\n\tfnvlist_free(vdev_guids);\n\tfnvlist_free(guids_to_paths);\n\n\tif (vd_errlist != NULL)\n\t\tfnvlist_free(vd_errlist);\n\n\treturn (err == 0 ? 0 : -1);\n}\n\nint\nzpool_initialize(zpool_handle_t *zhp, pool_initialize_func_t cmd_type,\n    nvlist_t *vds)\n{\n\treturn (zpool_initialize_impl(zhp, cmd_type, vds, B_FALSE));\n}\n\nint\nzpool_initialize_wait(zpool_handle_t *zhp, pool_initialize_func_t cmd_type,\n    nvlist_t *vds)\n{\n\treturn (zpool_initialize_impl(zhp, cmd_type, vds, B_TRUE));\n}\n\nstatic int\nxlate_trim_err(int err)\n{\n\tswitch (err) {\n\tcase ENODEV:\n\t\treturn (EZFS_NODEVICE);\n\tcase EINVAL:\n\tcase EROFS:\n\t\treturn (EZFS_BADDEV);\n\tcase EBUSY:\n\t\treturn (EZFS_TRIMMING);\n\tcase ESRCH:\n\t\treturn (EZFS_NO_TRIM);\n\tcase EOPNOTSUPP:\n\t\treturn (EZFS_TRIM_NOTSUP);\n\t}\n\treturn (err);\n}\n\nstatic int\nzpool_trim_wait(zpool_handle_t *zhp, nvlist_t *vdev_guids)\n{\n\tint err;\n\tnvpair_t *elem;\n\n\tfor (elem = nvlist_next_nvpair(vdev_guids, NULL); elem != NULL;\n\t    elem = nvlist_next_nvpair(vdev_guids, elem)) {\n\n\t\tuint64_t guid = fnvpair_value_uint64(elem);\n\n\t\terr = lzc_wait_tag(zhp->zpool_name,\n\t\t    ZPOOL_WAIT_TRIM, guid, NULL);\n\t\tif (err != 0) {\n\t\t\t(void) zpool_standard_error_fmt(zhp->zpool_hdl,\n\t\t\t    err, dgettext(TEXT_DOMAIN, \"error \"\n\t\t\t    \"waiting to trim '%s'\"), nvpair_name(elem));\n\n\t\t\treturn (err);\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nstatic boolean_t\ncheck_trim_errs(zpool_handle_t *zhp, trimflags_t *trim_flags,\n    nvlist_t *guids_to_paths, nvlist_t *vds, nvlist_t *errlist)\n{\n\tnvpair_t *elem;\n\tboolean_t reported_errs = B_FALSE;\n\tint num_vds = 0;\n\tint num_suppressed_errs = 0;\n\n\tfor (elem = nvlist_next_nvpair(vds, NULL);\n\t    elem != NULL; elem = nvlist_next_nvpair(vds, elem)) {\n\t\tnum_vds++;\n\t}\n\n\tfor (elem = nvlist_next_nvpair(errlist, NULL);\n\t    elem != NULL; elem = nvlist_next_nvpair(errlist, elem)) {\n\t\tint64_t vd_error = xlate_trim_err(fnvpair_value_int64(elem));\n\t\tconst char *path;\n\n\t\t \n\t\tif (vd_error == EZFS_TRIM_NOTSUP &&\n\t\t    trim_flags->fullpool &&\n\t\t    !trim_flags->secure) {\n\t\t\tnum_suppressed_errs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\treported_errs = B_TRUE;\n\t\tif (nvlist_lookup_string(guids_to_paths, nvpair_name(elem),\n\t\t    &path) != 0)\n\t\t\tpath = nvpair_name(elem);\n\n\t\t(void) zfs_error_fmt(zhp->zpool_hdl, vd_error,\n\t\t    \"cannot trim '%s'\", path);\n\t}\n\n\tif (num_suppressed_errs == num_vds) {\n\t\t(void) zfs_error_aux(zhp->zpool_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"no devices in pool support trim operations\"));\n\t\t(void) (zfs_error(zhp->zpool_hdl, EZFS_TRIM_NOTSUP,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot trim\")));\n\t\treported_errs = B_TRUE;\n\t}\n\n\treturn (reported_errs);\n}\n\n \nint\nzpool_trim(zpool_handle_t *zhp, pool_trim_func_t cmd_type, nvlist_t *vds,\n    trimflags_t *trim_flags)\n{\n\tint err;\n\tint retval = 0;\n\n\tnvlist_t *vdev_guids = fnvlist_alloc();\n\tnvlist_t *guids_to_paths = fnvlist_alloc();\n\tnvlist_t *errlist = NULL;\n\n\terr = zpool_translate_vdev_guids(zhp, vds, vdev_guids,\n\t    guids_to_paths, &errlist);\n\tif (err != 0) {\n\t\tcheck_trim_errs(zhp, trim_flags, guids_to_paths, vds, errlist);\n\t\tretval = -1;\n\t\tgoto out;\n\t}\n\n\terr = lzc_trim(zhp->zpool_name, cmd_type, trim_flags->rate,\n\t    trim_flags->secure, vdev_guids, &errlist);\n\tif (err != 0) {\n\t\tnvlist_t *vd_errlist;\n\t\tif (errlist != NULL && nvlist_lookup_nvlist(errlist,\n\t\t    ZPOOL_TRIM_VDEVS, &vd_errlist) == 0) {\n\t\t\tif (check_trim_errs(zhp, trim_flags, guids_to_paths,\n\t\t\t    vds, vd_errlist)) {\n\t\t\t\tretval = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tchar errbuf[ERRBUFLEN];\n\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN, \"operation failed\"));\n\t\t\tzpool_standard_error(zhp->zpool_hdl, err, errbuf);\n\t\t\tretval = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\n\tif (trim_flags->wait)\n\t\tretval = zpool_trim_wait(zhp, vdev_guids);\n\nout:\n\tif (errlist != NULL)\n\t\tfnvlist_free(errlist);\n\tfnvlist_free(vdev_guids);\n\tfnvlist_free(guids_to_paths);\n\treturn (retval);\n}\n\n \nint\nzpool_scan(zpool_handle_t *zhp, pool_scan_func_t func, pool_scrub_cmd_t cmd)\n{\n\tchar errbuf[ERRBUFLEN];\n\tint err;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\tnvlist_t *args = fnvlist_alloc();\n\tfnvlist_add_uint64(args, \"scan_type\", (uint64_t)func);\n\tfnvlist_add_uint64(args, \"scan_command\", (uint64_t)cmd);\n\n\terr = lzc_scrub(ZFS_IOC_POOL_SCRUB, zhp->zpool_name, args, NULL);\n\tfnvlist_free(args);\n\n\tif (err == 0) {\n\t\treturn (0);\n\t} else if (err == ZFS_ERR_IOC_CMD_UNAVAIL) {\n\t\tzfs_cmd_t zc = {\"\\0\"};\n\t\t(void) strlcpy(zc.zc_name, zhp->zpool_name,\n\t\t    sizeof (zc.zc_name));\n\t\tzc.zc_cookie = func;\n\t\tzc.zc_flags = cmd;\n\n\t\tif (zfs_ioctl(hdl, ZFS_IOC_POOL_SCAN, &zc) == 0)\n\t\t\treturn (0);\n\t}\n\n\t \n\tif (err == ECANCELED && (func == POOL_SCAN_SCRUB ||\n\t    func == POOL_SCAN_ERRORSCRUB) && cmd == POOL_SCRUB_NORMAL)\n\t\treturn (0);\n\t \n\tif (err == ENOENT && func != POOL_SCAN_NONE && cmd ==\n\t    POOL_SCRUB_PAUSE) {\n\t\treturn (0);\n\t}\n\n\tASSERT3U(func, >=, POOL_SCAN_NONE);\n\tASSERT3U(func, <, POOL_SCAN_FUNCS);\n\n\tif (func == POOL_SCAN_SCRUB || func == POOL_SCAN_ERRORSCRUB) {\n\t\tif (cmd == POOL_SCRUB_PAUSE) {\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot pause scrubbing %s\"),\n\t\t\t    zhp->zpool_name);\n\t\t} else {\n\t\t\tassert(cmd == POOL_SCRUB_NORMAL);\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot scrub %s\"),\n\t\t\t    zhp->zpool_name);\n\t\t}\n\t} else if (func == POOL_SCAN_RESILVER) {\n\t\tassert(cmd == POOL_SCRUB_NORMAL);\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot restart resilver on %s\"), zhp->zpool_name);\n\t} else if (func == POOL_SCAN_NONE) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot cancel scrubbing %s\"), zhp->zpool_name);\n\t} else {\n\t\tassert(!\"unexpected result\");\n\t}\n\n\t \n\tif (err == EBUSY) {\n\t\tnvlist_t *nvroot;\n\t\tpool_scan_stat_t *ps = NULL;\n\t\tuint_t psc;\n\n\t\tnvroot = fnvlist_lookup_nvlist(zhp->zpool_config,\n\t\t    ZPOOL_CONFIG_VDEV_TREE);\n\t\t(void) nvlist_lookup_uint64_array(nvroot,\n\t\t    ZPOOL_CONFIG_SCAN_STATS, (uint64_t **)&ps, &psc);\n\t\tif (ps && ps->pss_func == POOL_SCAN_SCRUB &&\n\t\t    ps->pss_state == DSS_SCANNING) {\n\t\t\tif (ps->pss_pass_scrub_pause == 0) {\n\t\t\t\t \n\t\t\t\tassert(cmd == POOL_SCRUB_NORMAL);\n\t\t\t\treturn (zfs_error(hdl, EZFS_SCRUBBING,\n\t\t\t\t    errbuf));\n\t\t\t} else {\n\t\t\t\tif (func == POOL_SCAN_ERRORSCRUB) {\n\t\t\t\t\t \n\t\t\t\t\tASSERT3U(cmd, ==, POOL_SCRUB_NORMAL);\n\t\t\t\t\treturn (zfs_error(hdl,\n\t\t\t\t\t    EZFS_SCRUB_PAUSED_TO_CANCEL,\n\t\t\t\t\t    errbuf));\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tASSERT3U(func, ==, POOL_SCAN_SCRUB);\n\t\t\t\t\tASSERT3U(cmd, ==, POOL_SCRUB_PAUSE);\n\t\t\t\t\treturn (zfs_error(hdl,\n\t\t\t\t\t    EZFS_SCRUB_PAUSED, errbuf));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ps &&\n\t\t    ps->pss_error_scrub_func == POOL_SCAN_ERRORSCRUB &&\n\t\t    ps->pss_error_scrub_state == DSS_ERRORSCRUBBING) {\n\t\t\tif (ps->pss_pass_error_scrub_pause == 0) {\n\t\t\t\t \n\t\t\t\tASSERT3U(cmd, ==, POOL_SCRUB_NORMAL);\n\t\t\t\treturn (zfs_error(hdl, EZFS_ERRORSCRUBBING,\n\t\t\t\t    errbuf));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tASSERT3U(func, ==, POOL_SCAN_ERRORSCRUB);\n\t\t\t\tASSERT3U(cmd, ==, POOL_SCRUB_PAUSE);\n\t\t\t\treturn (zfs_error(hdl, EZFS_ERRORSCRUB_PAUSED,\n\t\t\t\t    errbuf));\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\treturn (zfs_error(hdl, EZFS_RESILVERING, errbuf));\n\t\t}\n\t} else if (err == ENOENT) {\n\t\treturn (zfs_error(hdl, EZFS_NO_SCRUB, errbuf));\n\t} else if (err == ENOTSUP && func == POOL_SCAN_RESILVER) {\n\t\treturn (zfs_error(hdl, EZFS_NO_RESILVER_DEFER, errbuf));\n\t} else {\n\t\treturn (zpool_standard_error(hdl, err, errbuf));\n\t}\n}\n\n \nstatic nvlist_t *\nvdev_to_nvlist_iter(nvlist_t *nv, nvlist_t *search, boolean_t *avail_spare,\n    boolean_t *l2cache, boolean_t *log)\n{\n\tuint_t c, children;\n\tnvlist_t **child;\n\tnvlist_t *ret;\n\tuint64_t is_log;\n\tconst char *srchkey;\n\tnvpair_t *pair = nvlist_next_nvpair(search, NULL);\n\n\t \n\tif (search == NULL || pair == NULL)\n\t\treturn (NULL);\n\n\t \n\tsrchkey = nvpair_name(pair);\n\n\tswitch (nvpair_type(pair)) {\n\tcase DATA_TYPE_UINT64:\n\t\tif (strcmp(srchkey, ZPOOL_CONFIG_GUID) == 0) {\n\t\t\tuint64_t srchval = fnvpair_value_uint64(pair);\n\t\t\tuint64_t theguid = fnvlist_lookup_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_GUID);\n\t\t\tif (theguid == srchval)\n\t\t\t\treturn (nv);\n\t\t}\n\t\tbreak;\n\n\tcase DATA_TYPE_STRING: {\n\t\tconst char *srchval, *val;\n\n\t\tsrchval = fnvpair_value_string(pair);\n\t\tif (nvlist_lookup_string(nv, srchkey, &val) != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (strcmp(srchkey, ZPOOL_CONFIG_PATH) == 0) {\n\t\t\tuint64_t wholedisk = 0;\n\n\t\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_WHOLE_DISK,\n\t\t\t    &wholedisk);\n\t\t\tif (zfs_strcmp_pathname(srchval, val, wholedisk) == 0)\n\t\t\t\treturn (nv);\n\n\t\t} else if (strcmp(srchkey, ZPOOL_CONFIG_TYPE) == 0) {\n\t\t\tchar *type, *idx, *end, *p;\n\t\t\tuint64_t id, vdev_id;\n\n\t\t\t \n\t\t\tif ((type = strdup(srchval)) == NULL)\n\t\t\t\treturn (NULL);\n\n\t\t\tif ((p = strrchr(type, '-')) == NULL) {\n\t\t\t\tfree(type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx = p + 1;\n\t\t\t*p = '\\0';\n\n\t\t\t \n\t\t\tif (strncmp(val, type, strlen(val)) != 0) {\n\t\t\t\tfree(type);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tverify(zpool_vdev_is_interior(type));\n\n\t\t\tid = fnvlist_lookup_uint64(nv, ZPOOL_CONFIG_ID);\n\t\t\terrno = 0;\n\t\t\tvdev_id = strtoull(idx, &end, 10);\n\n\t\t\t \n\t\t\tint rzlen = strlen(VDEV_TYPE_RAIDZ);\n\t\t\tassert(rzlen == strlen(VDEV_TYPE_DRAID));\n\t\t\tint typlen = strlen(type);\n\t\t\tif ((strncmp(type, VDEV_TYPE_RAIDZ, rzlen) == 0 ||\n\t\t\t    strncmp(type, VDEV_TYPE_DRAID, rzlen) == 0) &&\n\t\t\t    typlen != rzlen) {\n\t\t\t\tuint64_t vdev_parity;\n\t\t\t\tint parity = *(type + rzlen) - '0';\n\n\t\t\t\tif (parity <= 0 || parity > 3 ||\n\t\t\t\t    (typlen - rzlen) != 1) {\n\t\t\t\t\t \n\t\t\t\t\tfree(type);\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tvdev_parity = fnvlist_lookup_uint64(nv,\n\t\t\t\t    ZPOOL_CONFIG_NPARITY);\n\t\t\t\tif ((int)vdev_parity != parity) {\n\t\t\t\t\tfree(type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(type);\n\t\t\tif (errno != 0)\n\t\t\t\treturn (NULL);\n\n\t\t\t \n\t\t\tif (vdev_id == id)\n\t\t\t\treturn (nv);\n\t\t}\n\n\t\t \n\t\tif (strcmp(srchval, val) == 0)\n\t\t\treturn (nv);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\treturn (NULL);\n\n\tfor (c = 0; c < children; c++) {\n\t\tif ((ret = vdev_to_nvlist_iter(child[c], search,\n\t\t    avail_spare, l2cache, NULL)) != NULL) {\n\t\t\t \n\t\t\tif (log != NULL &&\n\t\t\t    nvlist_lookup_uint64(child[c],\n\t\t\t    ZPOOL_CONFIG_IS_LOG, &is_log) == 0 &&\n\t\t\t    is_log) {\n\t\t\t\t*log = B_TRUE;\n\t\t\t}\n\t\t\treturn (ret);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif ((ret = vdev_to_nvlist_iter(child[c], search,\n\t\t\t    avail_spare, l2cache, NULL)) != NULL) {\n\t\t\t\t*avail_spare = B_TRUE;\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif ((ret = vdev_to_nvlist_iter(child[c], search,\n\t\t\t    avail_spare, l2cache, NULL)) != NULL) {\n\t\t\t\t*l2cache = B_TRUE;\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\n \nnvlist_t *\nzpool_find_vdev_by_physpath(zpool_handle_t *zhp, const char *ppath,\n    boolean_t *avail_spare, boolean_t *l2cache, boolean_t *log)\n{\n\tnvlist_t *search, *nvroot, *ret;\n\tuint64_t guid;\n\tchar *end;\n\n\tsearch = fnvlist_alloc();\n\n\tguid = strtoull(ppath, &end, 0);\n\tif (guid != 0 && *end == '\\0') {\n\t\tfnvlist_add_uint64(search, ZPOOL_CONFIG_GUID, guid);\n\t} else {\n\t\tfnvlist_add_string(search, ZPOOL_CONFIG_PHYS_PATH, ppath);\n\t}\n\n\tnvroot = fnvlist_lookup_nvlist(zhp->zpool_config,\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\n\t*avail_spare = B_FALSE;\n\t*l2cache = B_FALSE;\n\tif (log != NULL)\n\t\t*log = B_FALSE;\n\tret = vdev_to_nvlist_iter(nvroot, search, avail_spare, l2cache, log);\n\tfnvlist_free(search);\n\n\treturn (ret);\n}\n\n \nstatic boolean_t\nzpool_vdev_is_interior(const char *name)\n{\n\tif (strncmp(name, VDEV_TYPE_RAIDZ, strlen(VDEV_TYPE_RAIDZ)) == 0 ||\n\t    strncmp(name, VDEV_TYPE_SPARE, strlen(VDEV_TYPE_SPARE)) == 0 ||\n\t    strncmp(name,\n\t    VDEV_TYPE_REPLACING, strlen(VDEV_TYPE_REPLACING)) == 0 ||\n\t    strncmp(name, VDEV_TYPE_ROOT, strlen(VDEV_TYPE_ROOT)) == 0 ||\n\t    strncmp(name, VDEV_TYPE_MIRROR, strlen(VDEV_TYPE_MIRROR)) == 0)\n\t\treturn (B_TRUE);\n\n\tif (strncmp(name, VDEV_TYPE_DRAID, strlen(VDEV_TYPE_DRAID)) == 0 &&\n\t    !zpool_is_draid_spare(name))\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\nnvlist_t *\nzpool_find_vdev(zpool_handle_t *zhp, const char *path, boolean_t *avail_spare,\n    boolean_t *l2cache, boolean_t *log)\n{\n\tchar *end;\n\tnvlist_t *nvroot, *search, *ret;\n\tuint64_t guid;\n\n\tsearch = fnvlist_alloc();\n\n\tguid = strtoull(path, &end, 0);\n\tif (guid != 0 && *end == '\\0') {\n\t\tfnvlist_add_uint64(search, ZPOOL_CONFIG_GUID, guid);\n\t} else if (zpool_vdev_is_interior(path)) {\n\t\tfnvlist_add_string(search, ZPOOL_CONFIG_TYPE, path);\n\t} else {\n\t\tfnvlist_add_string(search, ZPOOL_CONFIG_PATH, path);\n\t}\n\n\tnvroot = fnvlist_lookup_nvlist(zhp->zpool_config,\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\n\t*avail_spare = B_FALSE;\n\t*l2cache = B_FALSE;\n\tif (log != NULL)\n\t\t*log = B_FALSE;\n\tret = vdev_to_nvlist_iter(nvroot, search, avail_spare, l2cache, log);\n\tfnvlist_free(search);\n\n\treturn (ret);\n}\n\n \nstatic uint64_t\nzpool_vdev_path_to_guid_impl(zpool_handle_t *zhp, const char *path,\n    boolean_t *is_spare, boolean_t *is_l2cache, boolean_t *is_log)\n{\n\tboolean_t spare = B_FALSE, l2cache = B_FALSE, log = B_FALSE;\n\tnvlist_t *tgt;\n\n\tif ((tgt = zpool_find_vdev(zhp, path, &spare, &l2cache,\n\t    &log)) == NULL)\n\t\treturn (0);\n\n\tif (is_spare != NULL)\n\t\t*is_spare = spare;\n\tif (is_l2cache != NULL)\n\t\t*is_l2cache = l2cache;\n\tif (is_log != NULL)\n\t\t*is_log = log;\n\n\treturn (fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID));\n}\n\n \nuint64_t\nzpool_vdev_path_to_guid(zpool_handle_t *zhp, const char *path)\n{\n\treturn (zpool_vdev_path_to_guid_impl(zhp, path, NULL, NULL, NULL));\n}\n\n \nint\nzpool_vdev_online(zpool_handle_t *zhp, const char *path, int flags,\n    vdev_state_t *newstate)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache, islog;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\tif (flags & ZFS_ONLINE_EXPAND) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot expand %s\"), path);\n\t} else {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot online %s\"), path);\n\t}\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare, &l2cache,\n\t    &islog)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\n\tif (!(flags & ZFS_ONLINE_SPARE) && avail_spare)\n\t\treturn (zfs_error(hdl, EZFS_ISSPARE, errbuf));\n\n#ifndef __FreeBSD__\n\tconst char *pathname;\n\tif ((flags & ZFS_ONLINE_EXPAND ||\n\t    zpool_get_prop_int(zhp, ZPOOL_PROP_AUTOEXPAND, NULL)) &&\n\t    nvlist_lookup_string(tgt, ZPOOL_CONFIG_PATH, &pathname) == 0) {\n\t\tuint64_t wholedisk = 0;\n\n\t\t(void) nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_WHOLE_DISK,\n\t\t    &wholedisk);\n\n\t\t \n\t\tif (l2cache) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot expand cache devices\"));\n\t\t\treturn (zfs_error(hdl, EZFS_VDEVNOTSUP, errbuf));\n\t\t}\n\n\t\tif (wholedisk) {\n\t\t\tconst char *fullpath = path;\n\t\t\tchar buf[MAXPATHLEN];\n\t\t\tint error;\n\n\t\t\tif (path[0] != '/') {\n\t\t\t\terror = zfs_resolve_shortname(path, buf,\n\t\t\t\t    sizeof (buf));\n\t\t\t\tif (error != 0)\n\t\t\t\t\treturn (zfs_error(hdl, EZFS_NODEVICE,\n\t\t\t\t\t    errbuf));\n\n\t\t\t\tfullpath = buf;\n\t\t\t}\n\n\t\t\terror = zpool_relabel_disk(hdl, fullpath, errbuf);\n\t\t\tif (error != 0)\n\t\t\t\treturn (error);\n\t\t}\n\t}\n#endif\n\n\tzc.zc_cookie = VDEV_STATE_ONLINE;\n\tzc.zc_obj = flags;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) != 0) {\n\t\tif (errno == EINVAL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"was split \"\n\t\t\t    \"from this pool into a new one.  Use '%s' \"\n\t\t\t    \"instead\"), \"zpool detach\");\n\t\t\treturn (zfs_error(hdl, EZFS_POSTSPLIT_ONLINE, errbuf));\n\t\t}\n\t\treturn (zpool_standard_error(hdl, errno, errbuf));\n\t}\n\n\t*newstate = zc.zc_cookie;\n\treturn (0);\n}\n\n \nint\nzpool_vdev_offline(zpool_handle_t *zhp, const char *path, boolean_t istmp)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot offline %s\"), path);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare, &l2cache,\n\t    NULL)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\n\tif (avail_spare)\n\t\treturn (zfs_error(hdl, EZFS_ISSPARE, errbuf));\n\n\tzc.zc_cookie = VDEV_STATE_OFFLINE;\n\tzc.zc_obj = istmp ? ZFS_OFFLINE_TEMPORARY : 0;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)\n\t\treturn (0);\n\n\tswitch (errno) {\n\tcase EBUSY:\n\n\t\t \n\t\treturn (zfs_error(hdl, EZFS_NOREPLICAS, errbuf));\n\n\tcase EEXIST:\n\t\t \n\t\treturn (zfs_error(hdl, EZFS_UNPLAYED_LOGS, errbuf));\n\n\tdefault:\n\t\treturn (zpool_standard_error(hdl, errno, errbuf));\n\t}\n}\n\n \nint\nzpool_vdev_remove_wanted(zpool_handle_t *zhp, const char *path)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot remove %s\"), path);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare, &l2cache,\n\t    NULL)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\n\tzc.zc_cookie = VDEV_STATE_REMOVED;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)\n\t\treturn (0);\n\n\treturn (zpool_standard_error(hdl, errno, errbuf));\n}\n\n \nint\nzpool_vdev_fault(zpool_handle_t *zhp, uint64_t guid, vdev_aux_t aux)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot fault %llu\"), (u_longlong_t)guid);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_guid = guid;\n\tzc.zc_cookie = VDEV_STATE_FAULTED;\n\tzc.zc_obj = aux;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)\n\t\treturn (0);\n\n\tswitch (errno) {\n\tcase EBUSY:\n\n\t\t \n\t\treturn (zfs_error(hdl, EZFS_NOREPLICAS, errbuf));\n\n\tdefault:\n\t\treturn (zpool_standard_error(hdl, errno, errbuf));\n\t}\n\n}\n\n \nint\nzpool_vdev_degrade(zpool_handle_t *zhp, uint64_t guid, vdev_aux_t aux)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot degrade %llu\"), (u_longlong_t)guid);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_guid = guid;\n\tzc.zc_cookie = VDEV_STATE_DEGRADED;\n\tzc.zc_obj = aux;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)\n\t\treturn (0);\n\n\treturn (zpool_standard_error(hdl, errno, errbuf));\n}\n\n \nstatic boolean_t\nis_replacing_spare(nvlist_t *search, nvlist_t *tgt, int which)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\n\tif (nvlist_lookup_nvlist_array(search, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) == 0) {\n\t\tconst char *type = fnvlist_lookup_string(search,\n\t\t    ZPOOL_CONFIG_TYPE);\n\t\tif ((strcmp(type, VDEV_TYPE_SPARE) == 0 ||\n\t\t    strcmp(type, VDEV_TYPE_DRAID_SPARE) == 0) &&\n\t\t    children == 2 && child[which] == tgt)\n\t\t\treturn (B_TRUE);\n\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (is_replacing_spare(child[c], tgt, which))\n\t\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nint\nzpool_vdev_attach(zpool_handle_t *zhp, const char *old_disk,\n    const char *new_disk, nvlist_t *nvroot, int replacing, boolean_t rebuild)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tint ret;\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache, islog;\n\tuint64_t val;\n\tchar *newname;\n\tnvlist_t **child;\n\tuint_t children;\n\tnvlist_t *config_root;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\tif (replacing)\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot replace %s with %s\"), old_disk, new_disk);\n\telse\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot attach %s to %s\"), new_disk, old_disk);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif ((tgt = zpool_find_vdev(zhp, old_disk, &avail_spare, &l2cache,\n\t    &islog)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tif (avail_spare)\n\t\treturn (zfs_error(hdl, EZFS_ISSPARE, errbuf));\n\n\tif (l2cache)\n\t\treturn (zfs_error(hdl, EZFS_ISL2CACHE, errbuf));\n\n\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\tzc.zc_cookie = replacing;\n\tzc.zc_simple = rebuild;\n\n\tif (rebuild &&\n\t    zfeature_lookup_guid(\"org.openzfs:device_rebuild\", NULL) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"the loaded zfs module doesn't support device rebuilds\"));\n\t\treturn (zfs_error(hdl, EZFS_POOL_NOTSUP, errbuf));\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0 || children != 1) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"new device must be a single disk\"));\n\t\treturn (zfs_error(hdl, EZFS_INVALCONFIG, errbuf));\n\t}\n\n\tconfig_root = fnvlist_lookup_nvlist(zpool_get_config(zhp, NULL),\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\n\tif ((newname = zpool_vdev_name(NULL, NULL, child[0], 0)) == NULL)\n\t\treturn (-1);\n\n\t \n\tif (replacing &&\n\t    nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_IS_SPARE, &val) == 0 &&\n\t    (zpool_find_vdev(zhp, newname, &avail_spare, &l2cache,\n\t    NULL) == NULL || !avail_spare) &&\n\t    is_replacing_spare(config_root, tgt, 1)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"can only be replaced by another hot spare\"));\n\t\tfree(newname);\n\t\treturn (zfs_error(hdl, EZFS_BADTARGET, errbuf));\n\t}\n\n\tfree(newname);\n\n\tzcmd_write_conf_nvlist(hdl, &zc, nvroot);\n\n\tret = zfs_ioctl(hdl, ZFS_IOC_VDEV_ATTACH, &zc);\n\n\tzcmd_free_nvlists(&zc);\n\n\tif (ret == 0)\n\t\treturn (0);\n\n\tswitch (errno) {\n\tcase ENOTSUP:\n\t\t \n\t\tif (replacing) {\n\t\t\tuint64_t version = zpool_get_prop_int(zhp,\n\t\t\t    ZPOOL_PROP_VERSION, NULL);\n\n\t\t\tif (islog) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"cannot replace a log with a spare\"));\n\t\t\t} else if (rebuild) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"only mirror and dRAID vdevs support \"\n\t\t\t\t    \"sequential reconstruction\"));\n\t\t\t} else if (zpool_is_draid_spare(new_disk)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"dRAID spares can only replace child \"\n\t\t\t\t    \"devices in their parent's dRAID vdev\"));\n\t\t\t} else if (version >= SPA_VERSION_MULTI_REPLACE) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"already in replacing/spare config; wait \"\n\t\t\t\t    \"for completion or use 'zpool detach'\"));\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"cannot replace a replacing device\"));\n\t\t\t}\n\t\t} else {\n\t\t\tchar status[64] = {0};\n\t\t\tzpool_prop_get_feature(zhp,\n\t\t\t    \"feature@device_rebuild\", status, 63);\n\t\t\tif (rebuild &&\n\t\t\t    strncmp(status, ZFS_FEATURE_DISABLED, 64) == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"device_rebuild feature must be enabled \"\n\t\t\t\t    \"in order to use sequential \"\n\t\t\t\t    \"reconstruction\"));\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"can only attach to mirrors and top-level \"\n\t\t\t\t    \"disks\"));\n\t\t\t}\n\t\t}\n\t\t(void) zfs_error(hdl, EZFS_BADTARGET, errbuf);\n\t\tbreak;\n\n\tcase EINVAL:\n\t\t \n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"new device must be a single disk\"));\n\t\t(void) zfs_error(hdl, EZFS_INVALCONFIG, errbuf);\n\t\tbreak;\n\n\tcase EBUSY:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"%s is busy, \"\n\t\t    \"or device removal is in progress\"),\n\t\t    new_disk);\n\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\tbreak;\n\n\tcase EOVERFLOW:\n\t\t \n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"device is too small\"));\n\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\tbreak;\n\n\tcase EDOM:\n\t\t \n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"new device has a different optimal sector size; use the \"\n\t\t    \"option '-o ashift=N' to override the optimal size\"));\n\t\t(void) zfs_error(hdl, EZFS_BADDEV, errbuf);\n\t\tbreak;\n\n\tcase ENAMETOOLONG:\n\t\t \n\t\t(void) zfs_error(hdl, EZFS_DEVOVERFLOW, errbuf);\n\t\tbreak;\n\n\tdefault:\n\t\t(void) zpool_standard_error(hdl, errno, errbuf);\n\t}\n\n\treturn (-1);\n}\n\n \nint\nzpool_vdev_detach(zpool_handle_t *zhp, const char *path)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot detach %s\"), path);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare, &l2cache,\n\t    NULL)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tif (avail_spare)\n\t\treturn (zfs_error(hdl, EZFS_ISSPARE, errbuf));\n\n\tif (l2cache)\n\t\treturn (zfs_error(hdl, EZFS_ISL2CACHE, errbuf));\n\n\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_DETACH, &zc) == 0)\n\t\treturn (0);\n\n\tswitch (errno) {\n\n\tcase ENOTSUP:\n\t\t \n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"only \"\n\t\t    \"applicable to mirror and replacing vdevs\"));\n\t\t(void) zfs_error(hdl, EZFS_BADTARGET, errbuf);\n\t\tbreak;\n\n\tcase EBUSY:\n\t\t \n\t\t(void) zfs_error(hdl, EZFS_NOREPLICAS, errbuf);\n\t\tbreak;\n\n\tdefault:\n\t\t(void) zpool_standard_error(hdl, errno, errbuf);\n\t}\n\n\treturn (-1);\n}\n\n \nstatic int\nfind_vdev_entry(zpool_handle_t *zhp, nvlist_t **mchild, uint_t mchildren,\n    nvlist_t **schild, uint_t schildren)\n{\n\tuint_t mc;\n\n\tfor (mc = 0; mc < mchildren; mc++) {\n\t\tuint_t sc;\n\t\tchar *mpath = zpool_vdev_name(zhp->zpool_hdl, zhp,\n\t\t    mchild[mc], 0);\n\n\t\tfor (sc = 0; sc < schildren; sc++) {\n\t\t\tchar *spath = zpool_vdev_name(zhp->zpool_hdl, zhp,\n\t\t\t    schild[sc], 0);\n\t\t\tboolean_t result = (strcmp(mpath, spath) == 0);\n\n\t\t\tfree(spath);\n\t\t\tif (result) {\n\t\t\t\tfree(mpath);\n\t\t\t\treturn (mc);\n\t\t\t}\n\t\t}\n\n\t\tfree(mpath);\n\t}\n\n\treturn (-1);\n}\n\n \nint\nzpool_vdev_split(zpool_handle_t *zhp, char *newname, nvlist_t **newroot,\n    nvlist_t *props, splitflags_t flags)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tconst char *bias;\n\tnvlist_t *tree, *config, **child, **newchild, *newconfig = NULL;\n\tnvlist_t **varray = NULL, *zc_props = NULL;\n\tuint_t c, children, newchildren, lastlog = 0, vcount, found = 0;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tuint64_t vers, readonly = B_FALSE;\n\tboolean_t freelist = B_FALSE, memory_err = B_TRUE;\n\tint retval = 0;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"Unable to split %s\"), zhp->zpool_name);\n\n\tif (!zpool_name_valid(hdl, B_FALSE, newname))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\tif ((config = zpool_get_config(zhp, NULL)) == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"Internal error: unable to \"\n\t\t    \"retrieve pool configuration\\n\"));\n\t\treturn (-1);\n\t}\n\n\ttree = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE);\n\tvers = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION);\n\n\tif (props) {\n\t\tprop_flags_t flags = { .create = B_FALSE, .import = B_TRUE };\n\t\tif ((zc_props = zpool_valid_proplist(hdl, zhp->zpool_name,\n\t\t    props, vers, flags, errbuf)) == NULL)\n\t\t\treturn (-1);\n\t\t(void) nvlist_lookup_uint64(zc_props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_READONLY), &readonly);\n\t\tif (readonly) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property %s can only be set at import time\"),\n\t\t\t    zpool_prop_to_name(ZPOOL_PROP_READONLY));\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_nvlist_array(tree, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Source pool is missing vdev tree\"));\n\t\tnvlist_free(zc_props);\n\t\treturn (-1);\n\t}\n\n\tvarray = zfs_alloc(hdl, children * sizeof (nvlist_t *));\n\tvcount = 0;\n\n\tif (*newroot == NULL ||\n\t    nvlist_lookup_nvlist_array(*newroot, ZPOOL_CONFIG_CHILDREN,\n\t    &newchild, &newchildren) != 0)\n\t\tnewchildren = 0;\n\n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t is_log = B_FALSE, is_hole = B_FALSE;\n\t\tboolean_t is_special = B_FALSE, is_dedup = B_FALSE;\n\t\tconst char *type;\n\t\tnvlist_t **mchild, *vdev;\n\t\tuint_t mchildren;\n\t\tint entry;\n\n\t\t \n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &is_log);\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_HOLE,\n\t\t    &is_hole);\n\t\tif (is_log || is_hole) {\n\t\t\t \n\t\t\tif (nvlist_alloc(&vdev, NV_UNIQUE_NAME, 0) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (nvlist_add_string(vdev, ZPOOL_CONFIG_TYPE,\n\t\t\t    VDEV_TYPE_HOLE) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (nvlist_add_uint64(vdev, ZPOOL_CONFIG_IS_HOLE,\n\t\t\t    1) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (lastlog == 0)\n\t\t\t\tlastlog = vcount;\n\t\t\tvarray[vcount++] = vdev;\n\t\t\tcontinue;\n\t\t}\n\t\tlastlog = 0;\n\t\ttype = fnvlist_lookup_string(child[c], ZPOOL_CONFIG_TYPE);\n\n\t\tif (strcmp(type, VDEV_TYPE_INDIRECT) == 0) {\n\t\t\tvdev = child[c];\n\t\t\tif (nvlist_dup(vdev, &varray[vcount++], 0) != 0)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t} else if (strcmp(type, VDEV_TYPE_MIRROR) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Source pool must be composed only of mirrors\\n\"));\n\t\t\tretval = zfs_error(hdl, EZFS_INVALCONFIG, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (nvlist_lookup_string(child[c],\n\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, &bias) == 0) {\n\t\t\tif (strcmp(bias, VDEV_ALLOC_BIAS_SPECIAL) == 0)\n\t\t\t\tis_special = B_TRUE;\n\t\t\telse if (strcmp(bias, VDEV_ALLOC_BIAS_DEDUP) == 0)\n\t\t\t\tis_dedup = B_TRUE;\n\t\t}\n\t\tverify(nvlist_lookup_nvlist_array(child[c],\n\t\t    ZPOOL_CONFIG_CHILDREN, &mchild, &mchildren) == 0);\n\n\t\t \n\t\tif (newchildren > 0 &&\n\t\t    (entry = find_vdev_entry(zhp, mchild, mchildren,\n\t\t    newchild, newchildren)) >= 0) {\n\t\t\t \n\t\t\tvdev = mchild[entry];\n\t\t\t++found;\n\t\t} else {\n\t\t\t \n\t\t\tvdev = mchild[mchildren - 1];\n\t\t}\n\n\t\tif (nvlist_dup(vdev, &varray[vcount++], 0) != 0)\n\t\t\tgoto out;\n\n\t\tif (flags.dryrun != 0) {\n\t\t\tif (is_dedup == B_TRUE) {\n\t\t\t\tif (nvlist_add_string(varray[vcount - 1],\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t    VDEV_ALLOC_BIAS_DEDUP) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else if (is_special == B_TRUE) {\n\t\t\t\tif (nvlist_add_string(varray[vcount - 1],\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t    VDEV_ALLOC_BIAS_SPECIAL) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (found != newchildren) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"Device list must \"\n\t\t    \"include at most one disk from each mirror\"));\n\t\tretval = zfs_error(hdl, EZFS_INVALCONFIG, errbuf);\n\t\tgoto out;\n\t}\n\n\t \n\tif (*newroot == NULL) {\n\t\tif (nvlist_alloc(newroot, NV_UNIQUE_NAME, 0) != 0)\n\t\t\tgoto out;\n\t\tfreelist = B_TRUE;\n\t\tif (nvlist_add_string(*newroot, ZPOOL_CONFIG_TYPE,\n\t\t    VDEV_TYPE_ROOT) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tverify(nvlist_remove_all(*newroot, ZPOOL_CONFIG_CHILDREN) == 0);\n\t}\n\n\t \n\tif (nvlist_add_nvlist_array(*newroot, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)varray, lastlog == 0 ? vcount : lastlog) != 0)\n\t\tgoto out;\n\n\t \n\tif (flags.dryrun) {\n\t\tmemory_err = B_FALSE;\n\t\tfreelist = B_FALSE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (nvlist_alloc(&newconfig, NV_UNIQUE_NAME, 0) != 0)\n\t\tgoto out;\n\n\tif (nvlist_add_nvlist(newconfig,\n\t    ZPOOL_CONFIG_VDEV_TREE, *newroot) != 0 ||\n\t    nvlist_add_string(newconfig,\n\t    ZPOOL_CONFIG_POOL_NAME, newname) != 0 ||\n\t    nvlist_add_uint64(newconfig, ZPOOL_CONFIG_VERSION, vers) != 0)\n\t\tgoto out;\n\n\t \n\tif (!flags.import)\n\t\tzc.zc_cookie = ZPOOL_EXPORT_AFTER_SPLIT;\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\t(void) strlcpy(zc.zc_string, newname, sizeof (zc.zc_string));\n\tzcmd_write_conf_nvlist(hdl, &zc, newconfig);\n\tif (zc_props != NULL)\n\t\tzcmd_write_src_nvlist(hdl, &zc, zc_props);\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_SPLIT, &zc) != 0) {\n\t\tretval = zpool_standard_error(hdl, errno, errbuf);\n\t\tgoto out;\n\t}\n\n\tfreelist = B_FALSE;\n\tmemory_err = B_FALSE;\n\nout:\n\tif (varray != NULL) {\n\t\tint v;\n\n\t\tfor (v = 0; v < vcount; v++)\n\t\t\tnvlist_free(varray[v]);\n\t\tfree(varray);\n\t}\n\tzcmd_free_nvlists(&zc);\n\tnvlist_free(zc_props);\n\tnvlist_free(newconfig);\n\tif (freelist) {\n\t\tnvlist_free(*newroot);\n\t\t*newroot = NULL;\n\t}\n\n\tif (retval != 0)\n\t\treturn (retval);\n\n\tif (memory_err)\n\t\treturn (no_memory(hdl));\n\n\treturn (0);\n}\n\n \nint\nzpool_vdev_remove(zpool_handle_t *zhp, const char *path)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache, islog;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tuint64_t version;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot remove %s\"), path);\n\n\tif (zpool_is_draid_spare(path)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dRAID spares cannot be removed\"));\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\t}\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare, &l2cache,\n\t    &islog)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tversion = zpool_get_prop_int(zhp, ZPOOL_PROP_VERSION, NULL);\n\tif (islog && version < SPA_VERSION_HOLES) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"pool must be upgraded to support log removal\"));\n\t\treturn (zfs_error(hdl, EZFS_BADVERSION, errbuf));\n\t}\n\n\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_REMOVE, &zc) == 0)\n\t\treturn (0);\n\n\tswitch (errno) {\n\n\tcase EALREADY:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"removal for this vdev is already in progress.\"));\n\t\t(void) zfs_error(hdl, EZFS_BUSY, errbuf);\n\t\tbreak;\n\n\tcase EINVAL:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid config; all top-level vdevs must \"\n\t\t    \"have the same sector size and not be raidz.\"));\n\t\t(void) zfs_error(hdl, EZFS_INVALCONFIG, errbuf);\n\t\tbreak;\n\n\tcase EBUSY:\n\t\tif (islog) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Mount encrypted datasets to replay logs.\"));\n\t\t} else {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Pool busy; removal may already be in progress\"));\n\t\t}\n\t\t(void) zfs_error(hdl, EZFS_BUSY, errbuf);\n\t\tbreak;\n\n\tcase EACCES:\n\t\tif (islog) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Mount encrypted datasets to replay logs.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BUSY, errbuf);\n\t\t} else {\n\t\t\t(void) zpool_standard_error(hdl, errno, errbuf);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t(void) zpool_standard_error(hdl, errno, errbuf);\n\t}\n\treturn (-1);\n}\n\nint\nzpool_vdev_remove_cancel(zpool_handle_t *zhp)\n{\n\tzfs_cmd_t zc = {{0}};\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot cancel removal\"));\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_cookie = 1;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_VDEV_REMOVE, &zc) == 0)\n\t\treturn (0);\n\n\treturn (zpool_standard_error(hdl, errno, errbuf));\n}\n\nint\nzpool_vdev_indirect_size(zpool_handle_t *zhp, const char *path,\n    uint64_t *sizep)\n{\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache, islog;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot determine indirect size of %s\"),\n\t    path);\n\n\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare, &l2cache,\n\t    &islog)) == NULL)\n\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\tif (avail_spare || l2cache || islog) {\n\t\t*sizep = 0;\n\t\treturn (0);\n\t}\n\n\tif (nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_INDIRECT_SIZE, sizep) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"indirect size not available\"));\n\t\treturn (zfs_error(hdl, EINVAL, errbuf));\n\t}\n\treturn (0);\n}\n\n \nint\nzpool_clear(zpool_handle_t *zhp, const char *path, nvlist_t *rewindnvl)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *tgt;\n\tzpool_load_policy_t policy;\n\tboolean_t avail_spare, l2cache;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tnvlist_t *nvi = NULL;\n\tint error;\n\n\tif (path)\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot clear errors for %s\"),\n\t\t    path);\n\telse\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot clear errors for %s\"),\n\t\t    zhp->zpool_name);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif (path) {\n\t\tif ((tgt = zpool_find_vdev(zhp, path, &avail_spare,\n\t\t    &l2cache, NULL)) == NULL)\n\t\t\treturn (zfs_error(hdl, EZFS_NODEVICE, errbuf));\n\n\t\t \n\t\tif (avail_spare)\n\t\t\treturn (zfs_error(hdl, EZFS_ISSPARE, errbuf));\n\n\t\tzc.zc_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\t}\n\n\tzpool_get_load_policy(rewindnvl, &policy);\n\tzc.zc_cookie = policy.zlp_rewind;\n\n\tzcmd_alloc_dst_nvlist(hdl, &zc, zhp->zpool_config_size * 2);\n\tzcmd_write_src_nvlist(hdl, &zc, rewindnvl);\n\n\twhile ((error = zfs_ioctl(hdl, ZFS_IOC_CLEAR, &zc)) != 0 &&\n\t    errno == ENOMEM)\n\t\tzcmd_expand_dst_nvlist(hdl, &zc);\n\n\tif (!error || ((policy.zlp_rewind & ZPOOL_TRY_REWIND) &&\n\t    errno != EPERM && errno != EACCES)) {\n\t\tif (policy.zlp_rewind &\n\t\t    (ZPOOL_DO_REWIND | ZPOOL_TRY_REWIND)) {\n\t\t\t(void) zcmd_read_dst_nvlist(hdl, &zc, &nvi);\n\t\t\tzpool_rewind_exclaim(hdl, zc.zc_name,\n\t\t\t    ((policy.zlp_rewind & ZPOOL_TRY_REWIND) != 0),\n\t\t\t    nvi);\n\t\t\tnvlist_free(nvi);\n\t\t}\n\t\tzcmd_free_nvlists(&zc);\n\t\treturn (0);\n\t}\n\n\tzcmd_free_nvlists(&zc);\n\treturn (zpool_standard_error(hdl, errno, errbuf));\n}\n\n \nint\nzpool_vdev_clear(zpool_handle_t *zhp, uint64_t guid)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot clear errors for %llx\"),\n\t    (u_longlong_t)guid);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_guid = guid;\n\tzc.zc_cookie = ZPOOL_NO_REWIND;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_CLEAR, &zc) == 0)\n\t\treturn (0);\n\n\treturn (zpool_standard_error(hdl, errno, errbuf));\n}\n\n \nint\nzpool_reguid(zpool_handle_t *zhp)\n{\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot reguid '%s'\"), zhp->zpool_name);\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tif (zfs_ioctl(hdl, ZFS_IOC_POOL_REGUID, &zc) == 0)\n\t\treturn (0);\n\n\treturn (zpool_standard_error(hdl, errno, errbuf));\n}\n\n \nint\nzpool_reopen_one(zpool_handle_t *zhp, void *data)\n{\n\tlibzfs_handle_t *hdl = zpool_get_handle(zhp);\n\tconst char *pool_name = zpool_get_name(zhp);\n\tboolean_t *scrub_restart = data;\n\tint error;\n\n\terror = lzc_reopen(pool_name, *scrub_restart);\n\tif (error) {\n\t\treturn (zpool_standard_error_fmt(hdl, error,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot reopen '%s'\"), pool_name));\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_sync_one(zpool_handle_t *zhp, void *data)\n{\n\tint ret;\n\tlibzfs_handle_t *hdl = zpool_get_handle(zhp);\n\tconst char *pool_name = zpool_get_name(zhp);\n\tboolean_t *force = data;\n\tnvlist_t *innvl = fnvlist_alloc();\n\n\tfnvlist_add_boolean_value(innvl, \"force\", *force);\n\tif ((ret = lzc_sync(pool_name, innvl, NULL)) != 0) {\n\t\tnvlist_free(innvl);\n\t\treturn (zpool_standard_error_fmt(hdl, ret,\n\t\t    dgettext(TEXT_DOMAIN, \"sync '%s' failed\"), pool_name));\n\t}\n\tnvlist_free(innvl);\n\n\treturn (0);\n}\n\n#define\tPATH_BUF_LEN\t64\n\n \nchar *\nzpool_vdev_name(libzfs_handle_t *hdl, zpool_handle_t *zhp, nvlist_t *nv,\n    int name_flags)\n{\n\tconst char *type, *tpath;\n\tconst char *path;\n\tuint64_t value;\n\tchar buf[PATH_BUF_LEN];\n\tchar tmpbuf[PATH_BUF_LEN * 2];\n\n\t \n\ttype = fnvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE);\n\tif (zhp != NULL && strcmp(type, \"root\") == 0)\n\t\treturn (zfs_strdup(hdl, zpool_get_name(zhp)));\n\n\tif (libzfs_envvar_is_set(\"ZPOOL_VDEV_NAME_PATH\"))\n\t\tname_flags |= VDEV_NAME_PATH;\n\tif (libzfs_envvar_is_set(\"ZPOOL_VDEV_NAME_GUID\"))\n\t\tname_flags |= VDEV_NAME_GUID;\n\tif (libzfs_envvar_is_set(\"ZPOOL_VDEV_NAME_FOLLOW_LINKS\"))\n\t\tname_flags |= VDEV_NAME_FOLLOW_LINKS;\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NOT_PRESENT, &value) == 0 ||\n\t    name_flags & VDEV_NAME_GUID) {\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &value);\n\t\t(void) snprintf(buf, sizeof (buf), \"%llu\", (u_longlong_t)value);\n\t\tpath = buf;\n\t} else if (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &tpath) == 0) {\n\t\tpath = tpath;\n\n\t\tif (name_flags & VDEV_NAME_FOLLOW_LINKS) {\n\t\t\tchar *rp = realpath(path, NULL);\n\t\t\tif (rp) {\n\t\t\t\tstrlcpy(buf, rp, sizeof (buf));\n\t\t\t\tpath = buf;\n\t\t\t\tfree(rp);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((strcmp(type, VDEV_TYPE_DISK) == 0) &&\n\t\t    !(name_flags & VDEV_NAME_PATH)) {\n\t\t\tpath = zfs_strip_path(path);\n\t\t}\n\n\t\t \n\t\tif (strcmp(type, VDEV_TYPE_DRAID_SPARE) != 0 &&\n\t\t    nvlist_lookup_uint64(nv, ZPOOL_CONFIG_WHOLE_DISK, &value)\n\t\t    == 0 && value && !(name_flags & VDEV_NAME_PATH)) {\n\t\t\treturn (zfs_strip_partition(path));\n\t\t}\n\t} else {\n\t\tpath = type;\n\n\t\t \n\t\tif (strcmp(path, VDEV_TYPE_RAIDZ) == 0) {\n\t\t\tvalue = fnvlist_lookup_uint64(nv, ZPOOL_CONFIG_NPARITY);\n\t\t\t(void) snprintf(buf, sizeof (buf), \"%s%llu\", path,\n\t\t\t    (u_longlong_t)value);\n\t\t\tpath = buf;\n\t\t}\n\n\t\t \n\t\tif (strcmp(path, VDEV_TYPE_DRAID) == 0) {\n\t\t\tuint64_t ndata, nparity, nspares;\n\t\t\tnvlist_t **child;\n\t\t\tuint_t children;\n\n\t\t\tverify(nvlist_lookup_nvlist_array(nv,\n\t\t\t    ZPOOL_CONFIG_CHILDREN, &child, &children) == 0);\n\t\t\tnparity = fnvlist_lookup_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_NPARITY);\n\t\t\tndata = fnvlist_lookup_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_DRAID_NDATA);\n\t\t\tnspares = fnvlist_lookup_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_DRAID_NSPARES);\n\n\t\t\tpath = zpool_draid_name(buf, sizeof (buf), ndata,\n\t\t\t    nparity, nspares, children);\n\t\t}\n\n\t\t \n\t\tif (name_flags & VDEV_NAME_TYPE_ID) {\n\t\t\tuint64_t id = fnvlist_lookup_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_ID);\n\t\t\t(void) snprintf(tmpbuf, sizeof (tmpbuf), \"%s-%llu\",\n\t\t\t    path, (u_longlong_t)id);\n\t\t\tpath = tmpbuf;\n\t\t}\n\t}\n\n\treturn (zfs_strdup(hdl, path));\n}\n\nstatic int\nzbookmark_mem_compare(const void *a, const void *b)\n{\n\treturn (memcmp(a, b, sizeof (zbookmark_phys_t)));\n}\n\n \nint\nzpool_get_errlog(zpool_handle_t *zhp, nvlist_t **nverrlistp)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tzbookmark_phys_t *buf;\n\tuint64_t buflen = 10000;  \n\n\tif (fnvlist_lookup_uint64(zhp->zpool_config,\n\t    ZPOOL_CONFIG_ERRCOUNT) == 0)\n\t\treturn (0);\n\n\t \n\t(void) strcpy(zc.zc_name, zhp->zpool_name);\n\tfor (;;) {\n\t\tbuf = zfs_alloc(zhp->zpool_hdl,\n\t\t    buflen * sizeof (zbookmark_phys_t));\n\t\tzc.zc_nvlist_dst = (uintptr_t)buf;\n\t\tzc.zc_nvlist_dst_size = buflen;\n\t\tif (zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_ERROR_LOG,\n\t\t    &zc) != 0) {\n\t\t\tfree(buf);\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tbuflen *= 2;\n\t\t\t} else {\n\t\t\t\treturn (zpool_standard_error_fmt(hdl, errno,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"errors: List of \"\n\t\t\t\t    \"errors unavailable\")));\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tzbookmark_phys_t *zb = buf + zc.zc_nvlist_dst_size;\n\tuint64_t zblen = buflen - zc.zc_nvlist_dst_size;\n\n\tqsort(zb, zblen, sizeof (zbookmark_phys_t), zbookmark_mem_compare);\n\n\tverify(nvlist_alloc(nverrlistp, 0, KM_SLEEP) == 0);\n\n\t \n\tfor (uint64_t i = 0; i < zblen; i++) {\n\t\tnvlist_t *nv;\n\n\t\t \n\t\tif (i > 0 && zb[i-1].zb_objset == zb[i].zb_objset &&\n\t\t    zb[i-1].zb_object == zb[i].zb_object)\n\t\t\tcontinue;\n\n\t\tif (nvlist_alloc(&nv, NV_UNIQUE_NAME, KM_SLEEP) != 0)\n\t\t\tgoto nomem;\n\t\tif (nvlist_add_uint64(nv, ZPOOL_ERR_DATASET,\n\t\t    zb[i].zb_objset) != 0) {\n\t\t\tnvlist_free(nv);\n\t\t\tgoto nomem;\n\t\t}\n\t\tif (nvlist_add_uint64(nv, ZPOOL_ERR_OBJECT,\n\t\t    zb[i].zb_object) != 0) {\n\t\t\tnvlist_free(nv);\n\t\t\tgoto nomem;\n\t\t}\n\t\tif (nvlist_add_nvlist(*nverrlistp, \"ejk\", nv) != 0) {\n\t\t\tnvlist_free(nv);\n\t\t\tgoto nomem;\n\t\t}\n\t\tnvlist_free(nv);\n\t}\n\n\tfree(buf);\n\treturn (0);\n\nnomem:\n\tfree(buf);\n\treturn (no_memory(zhp->zpool_hdl));\n}\n\n \nint\nzpool_upgrade(zpool_handle_t *zhp, uint64_t new_version)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) strcpy(zc.zc_name, zhp->zpool_name);\n\tzc.zc_cookie = new_version;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_POOL_UPGRADE, &zc) != 0)\n\t\treturn (zpool_standard_error_fmt(hdl, errno,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot upgrade '%s'\"),\n\t\t    zhp->zpool_name));\n\treturn (0);\n}\n\nvoid\nzfs_save_arguments(int argc, char **argv, char *string, int len)\n{\n\tint i;\n\n\t(void) strlcpy(string, zfs_basename(argv[0]), len);\n\tfor (i = 1; i < argc; i++) {\n\t\t(void) strlcat(string, \" \", len);\n\t\t(void) strlcat(string, argv[i], len);\n\t}\n}\n\nint\nzpool_log_history(libzfs_handle_t *hdl, const char *message)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tnvlist_t *args;\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_string(args, \"message\", message);\n\tzcmd_write_src_nvlist(hdl, &zc, args);\n\tint err = zfs_ioctl(hdl, ZFS_IOC_LOG_HISTORY, &zc);\n\tnvlist_free(args);\n\tzcmd_free_nvlists(&zc);\n\treturn (err);\n}\n\n \nstatic int\nget_history(zpool_handle_t *zhp, char *buf, uint64_t *off, uint64_t *len)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\n\tzc.zc_history = (uint64_t)(uintptr_t)buf;\n\tzc.zc_history_len = *len;\n\tzc.zc_history_offset = *off;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_POOL_GET_HISTORY, &zc) != 0) {\n\t\tswitch (errno) {\n\t\tcase EPERM:\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_PERM,\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot show history for pool '%s'\"),\n\t\t\t    zhp->zpool_name));\n\t\tcase ENOENT:\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_NOHISTORY,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get history for pool \"\n\t\t\t    \"'%s'\"), zhp->zpool_name));\n\t\tcase ENOTSUP:\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_BADVERSION,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get history for pool \"\n\t\t\t    \"'%s', pool must be upgraded\"), zhp->zpool_name));\n\t\tdefault:\n\t\t\treturn (zpool_standard_error_fmt(hdl, errno,\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot get history for '%s'\"), zhp->zpool_name));\n\t\t}\n\t}\n\n\t*len = zc.zc_history_len;\n\t*off = zc.zc_history_offset;\n\n\treturn (0);\n}\n\n \nint\nzpool_get_history(zpool_handle_t *zhp, nvlist_t **nvhisp, uint64_t *off,\n    boolean_t *eof)\n{\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tchar *buf;\n\tint buflen = 128 * 1024;\n\tnvlist_t **records = NULL;\n\tuint_t numrecords = 0;\n\tint err = 0, i;\n\tuint64_t start = *off;\n\n\tbuf = zfs_alloc(hdl, buflen);\n\n\t \n\twhile (*off - start < 1024 * 1024) {\n\t\tuint64_t bytes_read = buflen;\n\t\tuint64_t leftover;\n\n\t\tif ((err = get_history(zhp, buf, off, &bytes_read)) != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!bytes_read) {\n\t\t\t*eof = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((err = zpool_history_unpack(buf, bytes_read,\n\t\t    &leftover, &records, &numrecords)) != 0) {\n\t\t\tzpool_standard_error_fmt(hdl, err,\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot get history for '%s'\"), zhp->zpool_name);\n\t\t\tbreak;\n\t\t}\n\t\t*off -= leftover;\n\t\tif (leftover == bytes_read) {\n\t\t\t \n\t\t\tbuflen *= 2;\n\t\t\tfree(buf);\n\t\t\tbuf = zfs_alloc(hdl, buflen);\n\t\t}\n\t}\n\n\tfree(buf);\n\n\tif (!err) {\n\t\t*nvhisp = fnvlist_alloc();\n\t\tfnvlist_add_nvlist_array(*nvhisp, ZPOOL_HIST_RECORD,\n\t\t    (const nvlist_t **)records, numrecords);\n\t}\n\tfor (i = 0; i < numrecords; i++)\n\t\tnvlist_free(records[i]);\n\tfree(records);\n\n\treturn (err);\n}\n\n \nint\nzpool_events_next(libzfs_handle_t *hdl, nvlist_t **nvp,\n    int *dropped, unsigned flags, int zevent_fd)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint error = 0;\n\n\t*nvp = NULL;\n\t*dropped = 0;\n\tzc.zc_cleanup_fd = zevent_fd;\n\n\tif (flags & ZEVENT_NONBLOCK)\n\t\tzc.zc_guid = ZEVENT_NONBLOCK;\n\n\tzcmd_alloc_dst_nvlist(hdl, &zc, ZEVENT_SIZE);\n\nretry:\n\tif (zfs_ioctl(hdl, ZFS_IOC_EVENTS_NEXT, &zc) != 0) {\n\t\tswitch (errno) {\n\t\tcase ESHUTDOWN:\n\t\t\terror = zfs_error_fmt(hdl, EZFS_POOLUNAVAIL,\n\t\t\t    dgettext(TEXT_DOMAIN, \"zfs shutdown\"));\n\t\t\tgoto out;\n\t\tcase ENOENT:\n\t\t\t \n\t\t\tif (!(flags & ZEVENT_NONBLOCK))\n\t\t\t\terror = zpool_standard_error_fmt(hdl, errno,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get event\"));\n\n\t\t\tgoto out;\n\t\tcase ENOMEM:\n\t\t\tzcmd_expand_dst_nvlist(hdl, &zc);\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\terror = zpool_standard_error_fmt(hdl, errno,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get event\"));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = zcmd_read_dst_nvlist(hdl, &zc, nvp);\n\tif (error != 0)\n\t\tgoto out;\n\n\t*dropped = (int)zc.zc_cookie;\nout:\n\tzcmd_free_nvlists(&zc);\n\n\treturn (error);\n}\n\n \nint\nzpool_events_clear(libzfs_handle_t *hdl, int *count)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_EVENTS_CLEAR, &zc) != 0)\n\t\treturn (zpool_standard_error(hdl, errno,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot clear events\")));\n\n\tif (count != NULL)\n\t\t*count = (int)zc.zc_cookie;  \n\n\treturn (0);\n}\n\n \nint\nzpool_events_seek(libzfs_handle_t *hdl, uint64_t eid, int zevent_fd)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint error = 0;\n\n\tzc.zc_guid = eid;\n\tzc.zc_cleanup_fd = zevent_fd;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_EVENTS_SEEK, &zc) != 0) {\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\terror = zfs_error_fmt(hdl, EZFS_NOENT,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get event\"));\n\t\t\tbreak;\n\n\t\tcase ENOMEM:\n\t\t\terror = zfs_error_fmt(hdl, EZFS_NOMEM,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get event\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terror = zpool_standard_error_fmt(hdl, errno,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot get event\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (error);\n}\n\nstatic void\nzpool_obj_to_path_impl(zpool_handle_t *zhp, uint64_t dsobj, uint64_t obj,\n    char *pathname, size_t len, boolean_t always_unmounted)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tboolean_t mounted = B_FALSE;\n\tchar *mntpnt = NULL;\n\tchar dsname[ZFS_MAX_DATASET_NAME_LEN];\n\n\tif (dsobj == 0) {\n\t\t \n\t\t(void) snprintf(pathname, len, \"<metadata>:<0x%llx>\",\n\t\t    (longlong_t)obj);\n\t\treturn;\n\t}\n\n\t \n\t(void) strlcpy(zc.zc_name, zhp->zpool_name, sizeof (zc.zc_name));\n\tzc.zc_obj = dsobj;\n\tif (zfs_ioctl(zhp->zpool_hdl,\n\t    ZFS_IOC_DSOBJ_TO_DSNAME, &zc) != 0) {\n\t\t \n\t\t(void) snprintf(pathname, len, \"<0x%llx>:<0x%llx>\",\n\t\t    (longlong_t)dsobj, (longlong_t)obj);\n\t\treturn;\n\t}\n\t(void) strlcpy(dsname, zc.zc_value, sizeof (dsname));\n\n\t \n\tmounted = !always_unmounted && is_mounted(zhp->zpool_hdl, dsname,\n\t    &mntpnt);\n\n\t \n\t(void) strlcpy(zc.zc_name, dsname, sizeof (zc.zc_name));\n\tzc.zc_obj = obj;\n\tif (zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_OBJ_TO_PATH,\n\t    &zc) == 0) {\n\t\tif (mounted) {\n\t\t\t(void) snprintf(pathname, len, \"%s%s\", mntpnt,\n\t\t\t    zc.zc_value);\n\t\t} else {\n\t\t\t(void) snprintf(pathname, len, \"%s:%s\",\n\t\t\t    dsname, zc.zc_value);\n\t\t}\n\t} else {\n\t\t(void) snprintf(pathname, len, \"%s:<0x%llx>\", dsname,\n\t\t    (longlong_t)obj);\n\t}\n\tfree(mntpnt);\n}\n\nvoid\nzpool_obj_to_path(zpool_handle_t *zhp, uint64_t dsobj, uint64_t obj,\n    char *pathname, size_t len)\n{\n\tzpool_obj_to_path_impl(zhp, dsobj, obj, pathname, len, B_FALSE);\n}\n\nvoid\nzpool_obj_to_path_ds(zpool_handle_t *zhp, uint64_t dsobj, uint64_t obj,\n    char *pathname, size_t len)\n{\n\tzpool_obj_to_path_impl(zhp, dsobj, obj, pathname, len, B_TRUE);\n}\n \nint\nzpool_wait(zpool_handle_t *zhp, zpool_wait_activity_t activity)\n{\n\tboolean_t missing;\n\n\tint error = zpool_wait_status(zhp, activity, &missing, NULL);\n\n\tif (missing) {\n\t\t(void) zpool_standard_error_fmt(zhp->zpool_hdl, ENOENT,\n\t\t    dgettext(TEXT_DOMAIN, \"error waiting in pool '%s'\"),\n\t\t    zhp->zpool_name);\n\t\treturn (ENOENT);\n\t} else {\n\t\treturn (error);\n\t}\n}\n\n \nint\nzpool_wait_status(zpool_handle_t *zhp, zpool_wait_activity_t activity,\n    boolean_t *missing, boolean_t *waited)\n{\n\tint error = lzc_wait(zhp->zpool_name, activity, waited);\n\t*missing = (error == ENOENT);\n\tif (*missing)\n\t\treturn (0);\n\n\tif (error != 0) {\n\t\t(void) zpool_standard_error_fmt(zhp->zpool_hdl, error,\n\t\t    dgettext(TEXT_DOMAIN, \"error waiting in pool '%s'\"),\n\t\t    zhp->zpool_name);\n\t}\n\n\treturn (error);\n}\n\nint\nzpool_set_bootenv(zpool_handle_t *zhp, const nvlist_t *envmap)\n{\n\tint error = lzc_set_bootenv(zhp->zpool_name, envmap);\n\tif (error != 0) {\n\t\t(void) zpool_standard_error_fmt(zhp->zpool_hdl, error,\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"error setting bootenv in pool '%s'\"), zhp->zpool_name);\n\t}\n\n\treturn (error);\n}\n\nint\nzpool_get_bootenv(zpool_handle_t *zhp, nvlist_t **nvlp)\n{\n\tnvlist_t *nvl;\n\tint error;\n\n\tnvl = NULL;\n\terror = lzc_get_bootenv(zhp->zpool_name, &nvl);\n\tif (error != 0) {\n\t\t(void) zpool_standard_error_fmt(zhp->zpool_hdl, error,\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"error getting bootenv in pool '%s'\"), zhp->zpool_name);\n\t} else {\n\t\t*nvlp = nvl;\n\t}\n\n\treturn (error);\n}\n\n \nzpool_compat_status_t\nzpool_load_compat(const char *compat, boolean_t *features, char *report,\n    size_t rlen)\n{\n\tint sdirfd, ddirfd, featfd;\n\tstruct stat fs;\n\tchar *fc;\n\tchar *ps, *ls, *ws;\n\tchar *file, *line, *word;\n\n\tchar l_compat[ZFS_MAXPROPLEN];\n\n\tboolean_t ret_nofiles = B_TRUE;\n\tboolean_t ret_badfile = B_FALSE;\n\tboolean_t ret_badtoken = B_FALSE;\n\tboolean_t ret_warntoken = B_FALSE;\n\n\t \n\tif (compat == NULL || compat[0] == '\\0' ||\n\t    strcmp(compat, ZPOOL_COMPAT_OFF) == 0) {\n\t\tif (features != NULL)\n\t\t\tfor (uint_t i = 0; i < SPA_FEATURES; i++)\n\t\t\t\tfeatures[i] = B_TRUE;\n\t\tif (report != NULL)\n\t\t\tstrlcpy(report, gettext(\"all features enabled\"), rlen);\n\t\treturn (ZPOOL_COMPATIBILITY_OK);\n\t}\n\n\t \n\tif (strcmp(compat, ZPOOL_COMPAT_LEGACY) == 0) {\n\t\tif (features != NULL)\n\t\t\tfor (uint_t i = 0; i < SPA_FEATURES; i++)\n\t\t\t\tfeatures[i] = B_FALSE;\n\t\tif (report != NULL)\n\t\t\tstrlcpy(report, gettext(\"all features disabled\"), rlen);\n\t\treturn (ZPOOL_COMPATIBILITY_OK);\n\t}\n\n\t \n\tif (features != NULL)\n\t\tfor (uint_t i = 0; i < SPA_FEATURES; i++)\n\t\t\tfeatures[i] = B_TRUE;\n\n\tchar err_badfile[ZFS_MAXPROPLEN] = \"\";\n\tchar err_badtoken[ZFS_MAXPROPLEN] = \"\";\n\n\t \n\n \n#if defined(O_PATH)\n#define\tZC_DIR_FLAGS (O_DIRECTORY | O_CLOEXEC | O_PATH)\n#else\n#define\tZC_DIR_FLAGS (O_DIRECTORY | O_CLOEXEC | O_RDONLY)\n#endif\n\n\tsdirfd = open(ZPOOL_SYSCONF_COMPAT_D, ZC_DIR_FLAGS);\n\tddirfd = open(ZPOOL_DATA_COMPAT_D, ZC_DIR_FLAGS);\n\n\t(void) strlcpy(l_compat, compat, ZFS_MAXPROPLEN);\n\n\tfor (file = strtok_r(l_compat, \",\", &ps);\n\t    file != NULL;\n\t    file = strtok_r(NULL, \",\", &ps)) {\n\n\t\tboolean_t l_features[SPA_FEATURES];\n\n\t\tenum { Z_SYSCONF, Z_DATA } source;\n\n\t\t \n\t\tsource = Z_SYSCONF;\n\t\tif ((featfd = openat(sdirfd, file, O_RDONLY | O_CLOEXEC)) < 0) {\n\t\t\tfeatfd = openat(ddirfd, file, O_RDONLY | O_CLOEXEC);\n\t\t\tsource = Z_DATA;\n\t\t}\n\n\t\t \n\t\tif (featfd < 0 ||\n\t\t    fstat(featfd, &fs) < 0 ||\n\t\t    fs.st_size < 1 ||\n\t\t    fs.st_size > ZPOOL_COMPAT_MAXSIZE) {\n\t\t\t(void) close(featfd);\n\t\t\tstrlcat(err_badfile, file, ZFS_MAXPROPLEN);\n\t\t\tstrlcat(err_badfile, \" \", ZFS_MAXPROPLEN);\n\t\t\tret_badfile = B_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n \n#if defined(MAP_POPULATE)\n#define\tZC_MMAP_FLAGS (MAP_PRIVATE | MAP_POPULATE)\n#elif defined(MAP_PREFAULT_READ)\n#define\tZC_MMAP_FLAGS (MAP_PRIVATE | MAP_PREFAULT_READ)\n#else\n#define\tZC_MMAP_FLAGS (MAP_PRIVATE)\n#endif\n\n\t\t \n\t\tfc = (char *)mmap(NULL, fs.st_size, PROT_READ | PROT_WRITE,\n\t\t    ZC_MMAP_FLAGS, featfd, 0);\n\t\t(void) close(featfd);\n\n\t\t \n\t\tif (fc == MAP_FAILED || fc[fs.st_size - 1] != '\\n') {\n\t\t\t(void) munmap((void *) fc, fs.st_size);\n\t\t\tstrlcat(err_badfile, file, ZFS_MAXPROPLEN);\n\t\t\tstrlcat(err_badfile, \" \", ZFS_MAXPROPLEN);\n\t\t\tret_badfile = B_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret_nofiles = B_FALSE;\n\n\t\tfor (uint_t i = 0; i < SPA_FEATURES; i++)\n\t\t\tl_features[i] = B_FALSE;\n\n\t\t \n\t\tfc[fs.st_size - 1] = '\\0';\n\n\t\tfor (line = strtok_r(fc, \"\\n\", &ls);\n\t\t    line != NULL;\n\t\t    line = strtok_r(NULL, \"\\n\", &ls)) {\n\t\t\t \n\t\t\tchar *r = strchr(line, '#');\n\t\t\tif (r != NULL)\n\t\t\t\t*r = '\\0';\n\n\t\t\tfor (word = strtok_r(line, \", \\t\", &ws);\n\t\t\t    word != NULL;\n\t\t\t    word = strtok_r(NULL, \", \\t\", &ws)) {\n\t\t\t\t \n\t\t\t\tuint_t f;\n\t\t\t\tfor (f = 0; f < SPA_FEATURES; f++) {\n\t\t\t\t\tzfeature_info_t *fi =\n\t\t\t\t\t    &spa_feature_table[f];\n\t\t\t\t\tif (strcmp(word, fi->fi_uname) == 0) {\n\t\t\t\t\t\tl_features[f] = B_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f < SPA_FEATURES)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (strlen(word) > 32)\n\t\t\t\t\tword[32] = '\\0';\n\t\t\t\tfor (char *c = word; *c != '\\0'; c++)\n\t\t\t\t\tif (!isprint(*c))\n\t\t\t\t\t\t*c = '?';\n\n\t\t\t\tstrlcat(err_badtoken, word, ZFS_MAXPROPLEN);\n\t\t\t\tstrlcat(err_badtoken, \" \", ZFS_MAXPROPLEN);\n\t\t\t\tif (source == Z_SYSCONF)\n\t\t\t\t\tret_badtoken = B_TRUE;\n\t\t\t\telse\n\t\t\t\t\tret_warntoken = B_TRUE;\n\t\t\t}\n\t\t}\n\t\t(void) munmap((void *) fc, fs.st_size);\n\n\t\tif (features != NULL)\n\t\t\tfor (uint_t i = 0; i < SPA_FEATURES; i++)\n\t\t\t\tfeatures[i] &= l_features[i];\n\t}\n\t(void) close(sdirfd);\n\t(void) close(ddirfd);\n\n\t \n\tif (ret_badfile) {\n\t\tif (report != NULL)\n\t\t\tsnprintf(report, rlen, gettext(\"could not read/\"\n\t\t\t    \"parse feature file(s): %s\"), err_badfile);\n\t\treturn (ZPOOL_COMPATIBILITY_BADFILE);\n\t}\n\tif (ret_nofiles) {\n\t\tif (report != NULL)\n\t\t\tstrlcpy(report,\n\t\t\t    gettext(\"no valid compatibility files specified\"),\n\t\t\t    rlen);\n\t\treturn (ZPOOL_COMPATIBILITY_NOFILES);\n\t}\n\tif (ret_badtoken) {\n\t\tif (report != NULL)\n\t\t\tsnprintf(report, rlen, gettext(\"invalid feature \"\n\t\t\t    \"name(s) in local compatibility files: %s\"),\n\t\t\t    err_badtoken);\n\t\treturn (ZPOOL_COMPATIBILITY_BADTOKEN);\n\t}\n\tif (ret_warntoken) {\n\t\tif (report != NULL)\n\t\t\tsnprintf(report, rlen, gettext(\"unrecognized feature \"\n\t\t\t    \"name(s) in distribution compatibility files: %s\"),\n\t\t\t    err_badtoken);\n\t\treturn (ZPOOL_COMPATIBILITY_WARNTOKEN);\n\t}\n\tif (report != NULL)\n\t\tstrlcpy(report, gettext(\"compatibility set ok\"), rlen);\n\treturn (ZPOOL_COMPATIBILITY_OK);\n}\n\nstatic int\nzpool_vdev_guid(zpool_handle_t *zhp, const char *vdevname, uint64_t *vdev_guid)\n{\n\tnvlist_t *tgt;\n\tboolean_t avail_spare, l2cache;\n\n\tverify(zhp != NULL);\n\tif (zpool_get_state(zhp) == POOL_STATE_UNAVAIL) {\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"pool is in an unavailable state\"));\n\t\treturn (zfs_error(zhp->zpool_hdl, EZFS_POOLUNAVAIL, errbuf));\n\t}\n\n\tif ((tgt = zpool_find_vdev(zhp, vdevname, &avail_spare, &l2cache,\n\t    NULL)) == NULL) {\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"can not find %s in %s\"),\n\t\t    vdevname, zhp->zpool_name);\n\t\treturn (zfs_error(zhp->zpool_hdl, EZFS_NODEVICE, errbuf));\n\t}\n\n\t*vdev_guid = fnvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID);\n\treturn (0);\n}\n\n \nint\nzpool_get_vdev_prop_value(nvlist_t *nvprop, vdev_prop_t prop, char *prop_name,\n    char *buf, size_t len, zprop_source_t *srctype, boolean_t literal)\n{\n\tnvlist_t *nv;\n\tconst char *strval;\n\tuint64_t intval;\n\tzprop_source_t src = ZPROP_SRC_NONE;\n\n\tif (prop == VDEV_PROP_USERPROP) {\n\t\t \n\t\tassert(prop_name != NULL);\n\t\tif (nvlist_lookup_nvlist(nvprop, prop_name, &nv) == 0) {\n\t\t\tsrc = fnvlist_lookup_uint64(nv, ZPROP_SOURCE);\n\t\t\tstrval = fnvlist_lookup_string(nv, ZPROP_VALUE);\n\t\t} else {\n\t\t\t \n\t\t\treturn (-1);\n\t\t}\n\t\t(void) strlcpy(buf, strval, len);\n\t\tif (srctype)\n\t\t\t*srctype = src;\n\t\treturn (0);\n\t}\n\n\tif (prop_name == NULL)\n\t\tprop_name = (char *)vdev_prop_to_name(prop);\n\n\tswitch (vdev_prop_get_type(prop)) {\n\tcase PROP_TYPE_STRING:\n\t\tif (nvlist_lookup_nvlist(nvprop, prop_name, &nv) == 0) {\n\t\t\tsrc = fnvlist_lookup_uint64(nv, ZPROP_SOURCE);\n\t\t\tstrval = fnvlist_lookup_string(nv, ZPROP_VALUE);\n\t\t} else {\n\t\t\tsrc = ZPROP_SRC_DEFAULT;\n\t\t\tif ((strval = vdev_prop_default_string(prop)) == NULL)\n\t\t\t\tstrval = \"-\";\n\t\t}\n\t\t(void) strlcpy(buf, strval, len);\n\t\tbreak;\n\n\tcase PROP_TYPE_NUMBER:\n\t\tif (nvlist_lookup_nvlist(nvprop, prop_name, &nv) == 0) {\n\t\t\tsrc = fnvlist_lookup_uint64(nv, ZPROP_SOURCE);\n\t\t\tintval = fnvlist_lookup_uint64(nv, ZPROP_VALUE);\n\t\t} else {\n\t\t\tsrc = ZPROP_SRC_DEFAULT;\n\t\t\tintval = vdev_prop_default_numeric(prop);\n\t\t}\n\n\t\tswitch (prop) {\n\t\tcase VDEV_PROP_ASIZE:\n\t\tcase VDEV_PROP_PSIZE:\n\t\tcase VDEV_PROP_SIZE:\n\t\tcase VDEV_PROP_BOOTSIZE:\n\t\tcase VDEV_PROP_ALLOCATED:\n\t\tcase VDEV_PROP_FREE:\n\t\tcase VDEV_PROP_READ_ERRORS:\n\t\tcase VDEV_PROP_WRITE_ERRORS:\n\t\tcase VDEV_PROP_CHECKSUM_ERRORS:\n\t\tcase VDEV_PROP_INITIALIZE_ERRORS:\n\t\tcase VDEV_PROP_OPS_NULL:\n\t\tcase VDEV_PROP_OPS_READ:\n\t\tcase VDEV_PROP_OPS_WRITE:\n\t\tcase VDEV_PROP_OPS_FREE:\n\t\tcase VDEV_PROP_OPS_CLAIM:\n\t\tcase VDEV_PROP_OPS_TRIM:\n\t\tcase VDEV_PROP_BYTES_NULL:\n\t\tcase VDEV_PROP_BYTES_READ:\n\t\tcase VDEV_PROP_BYTES_WRITE:\n\t\tcase VDEV_PROP_BYTES_FREE:\n\t\tcase VDEV_PROP_BYTES_CLAIM:\n\t\tcase VDEV_PROP_BYTES_TRIM:\n\t\t\tif (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) zfs_nicenum(intval, buf, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VDEV_PROP_EXPANDSZ:\n\t\t\tif (intval == 0) {\n\t\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\t} else if (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) zfs_nicenum(intval, buf, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VDEV_PROP_CAPACITY:\n\t\t\tif (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) snprintf(buf, len, \"%llu%%\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VDEV_PROP_CHECKSUM_N:\n\t\tcase VDEV_PROP_CHECKSUM_T:\n\t\tcase VDEV_PROP_IO_N:\n\t\tcase VDEV_PROP_IO_T:\n\t\t\tif (intval == UINT64_MAX) {\n\t\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\t} else {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VDEV_PROP_FRAGMENTATION:\n\t\t\tif (intval == UINT64_MAX) {\n\t\t\t\t(void) strlcpy(buf, \"-\", len);\n\t\t\t} else {\n\t\t\t\t(void) snprintf(buf, len, \"%llu%%\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VDEV_PROP_STATE:\n\t\t\tif (literal) {\n\t\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t\t    (u_longlong_t)intval);\n\t\t\t} else {\n\t\t\t\t(void) strlcpy(buf, zpool_state_to_name(intval,\n\t\t\t\t    VDEV_AUX_NONE), len);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) snprintf(buf, len, \"%llu\",\n\t\t\t    (u_longlong_t)intval);\n\t\t}\n\t\tbreak;\n\n\tcase PROP_TYPE_INDEX:\n\t\tif (nvlist_lookup_nvlist(nvprop, prop_name, &nv) == 0) {\n\t\t\tsrc = fnvlist_lookup_uint64(nv, ZPROP_SOURCE);\n\t\t\tintval = fnvlist_lookup_uint64(nv, ZPROP_VALUE);\n\t\t} else {\n\t\t\tsrc = ZPROP_SRC_DEFAULT;\n\t\t\tintval = vdev_prop_default_numeric(prop);\n\t\t}\n\t\tif (vdev_prop_index_to_string(prop, intval,\n\t\t    (const char **)&strval) != 0)\n\t\t\treturn (-1);\n\t\t(void) strlcpy(buf, strval, len);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\n\tif (srctype)\n\t\t*srctype = src;\n\n\treturn (0);\n}\n\n \nint\nzpool_get_vdev_prop(zpool_handle_t *zhp, const char *vdevname, vdev_prop_t prop,\n    char *prop_name, char *buf, size_t len, zprop_source_t *srctype,\n    boolean_t literal)\n{\n\tnvlist_t *reqnvl, *reqprops;\n\tnvlist_t *retprops = NULL;\n\tuint64_t vdev_guid = 0;\n\tint ret;\n\n\tif ((ret = zpool_vdev_guid(zhp, vdevname, &vdev_guid)) != 0)\n\t\treturn (ret);\n\n\tif (nvlist_alloc(&reqnvl, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (no_memory(zhp->zpool_hdl));\n\tif (nvlist_alloc(&reqprops, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (no_memory(zhp->zpool_hdl));\n\n\tfnvlist_add_uint64(reqnvl, ZPOOL_VDEV_PROPS_GET_VDEV, vdev_guid);\n\n\tif (prop != VDEV_PROP_USERPROP) {\n\t\t \n\t\tif (prop_name != NULL)\n\t\t\tprop = vdev_name_to_prop(prop_name);\n\t\telse\n\t\t\tprop_name = (char *)vdev_prop_to_name(prop);\n\t\tassert(prop < VDEV_NUM_PROPS);\n\t}\n\n\tassert(prop_name != NULL);\n\tif (nvlist_add_uint64(reqprops, prop_name, prop) != 0) {\n\t\tnvlist_free(reqnvl);\n\t\tnvlist_free(reqprops);\n\t\treturn (no_memory(zhp->zpool_hdl));\n\t}\n\n\tfnvlist_add_nvlist(reqnvl, ZPOOL_VDEV_PROPS_GET_PROPS, reqprops);\n\n\tret = lzc_get_vdev_prop(zhp->zpool_name, reqnvl, &retprops);\n\n\tif (ret == 0) {\n\t\tret = zpool_get_vdev_prop_value(retprops, prop, prop_name, buf,\n\t\t    len, srctype, literal);\n\t} else {\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot get vdev property %s from\"\n\t\t    \" %s in %s\"), prop_name, vdevname, zhp->zpool_name);\n\t\t(void) zpool_standard_error(zhp->zpool_hdl, ret, errbuf);\n\t}\n\n\tnvlist_free(reqnvl);\n\tnvlist_free(reqprops);\n\tnvlist_free(retprops);\n\n\treturn (ret);\n}\n\n \nint\nzpool_get_all_vdev_props(zpool_handle_t *zhp, const char *vdevname,\n    nvlist_t **outnvl)\n{\n\tnvlist_t *nvl = NULL;\n\tuint64_t vdev_guid = 0;\n\tint ret;\n\n\tif ((ret = zpool_vdev_guid(zhp, vdevname, &vdev_guid)) != 0)\n\t\treturn (ret);\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (no_memory(zhp->zpool_hdl));\n\n\tfnvlist_add_uint64(nvl, ZPOOL_VDEV_PROPS_GET_VDEV, vdev_guid);\n\n\tret = lzc_get_vdev_prop(zhp->zpool_name, nvl, outnvl);\n\n\tnvlist_free(nvl);\n\n\tif (ret) {\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot get vdev properties for\"\n\t\t    \" %s in %s\"), vdevname, zhp->zpool_name);\n\t\t(void) zpool_standard_error(zhp->zpool_hdl, errno, errbuf);\n\t}\n\n\treturn (ret);\n}\n\n \nint\nzpool_set_vdev_prop(zpool_handle_t *zhp, const char *vdevname,\n    const char *propname, const char *propval)\n{\n\tint ret;\n\tnvlist_t *nvl = NULL;\n\tnvlist_t *outnvl = NULL;\n\tnvlist_t *props;\n\tnvlist_t *realprops;\n\tprop_flags_t flags = { 0 };\n\tuint64_t version;\n\tuint64_t vdev_guid;\n\n\tif ((ret = zpool_vdev_guid(zhp, vdevname, &vdev_guid)) != 0)\n\t\treturn (ret);\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (no_memory(zhp->zpool_hdl));\n\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (no_memory(zhp->zpool_hdl));\n\n\tfnvlist_add_uint64(nvl, ZPOOL_VDEV_PROPS_SET_VDEV, vdev_guid);\n\n\tif (nvlist_add_string(props, propname, propval) != 0) {\n\t\tnvlist_free(props);\n\t\treturn (no_memory(zhp->zpool_hdl));\n\t}\n\n\tchar errbuf[ERRBUFLEN];\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot set property %s for %s on %s\"),\n\t    propname, vdevname, zhp->zpool_name);\n\n\tflags.vdevprop = 1;\n\tversion = zpool_get_prop_int(zhp, ZPOOL_PROP_VERSION, NULL);\n\tif ((realprops = zpool_valid_proplist(zhp->zpool_hdl,\n\t    zhp->zpool_name, props, version, flags, errbuf)) == NULL) {\n\t\tnvlist_free(props);\n\t\tnvlist_free(nvl);\n\t\treturn (-1);\n\t}\n\n\tnvlist_free(props);\n\tprops = realprops;\n\n\tfnvlist_add_nvlist(nvl, ZPOOL_VDEV_PROPS_SET_PROPS, props);\n\n\tret = lzc_set_vdev_prop(zhp->zpool_name, nvl, &outnvl);\n\n\tnvlist_free(props);\n\tnvlist_free(nvl);\n\tnvlist_free(outnvl);\n\n\tif (ret)\n\t\t(void) zpool_standard_error(zhp->zpool_hdl, errno, errbuf);\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}