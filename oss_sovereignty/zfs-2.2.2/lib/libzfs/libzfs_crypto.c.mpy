{
  "module_name": "libzfs_crypto.c",
  "hash_id": "ad7b7ca8ddc0c1d8ddce56a5dda289b33069124a7de06ab0c2567982b304f41b",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_crypto.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/fs/zfs.h>\n#include <sys/dsl_crypt.h>\n#include <libintl.h>\n#include <termios.h>\n#include <signal.h>\n#include <errno.h>\n#include <openssl/evp.h>\n#if LIBFETCH_DYNAMIC\n#include <dlfcn.h>\n#endif\n#if LIBFETCH_IS_FETCH\n#include <sys/param.h>\n#include <stdio.h>\n#include <fetch.h>\n#elif LIBFETCH_IS_LIBCURL\n#include <curl/curl.h>\n#endif\n#include <libzfs.h>\n#include \"libzfs_impl.h\"\n#include \"zfeature_common.h\"\n\n \n\n#define\tMIN_PASSPHRASE_LEN 8\n#define\tMAX_PASSPHRASE_LEN 512\n#define\tMAX_KEY_PROMPT_ATTEMPTS 3\n\nstatic int caught_interrupt;\n\nstatic int get_key_material_file(libzfs_handle_t *, const char *, const char *,\n    zfs_keyformat_t, boolean_t, uint8_t **, size_t *);\nstatic int get_key_material_https(libzfs_handle_t *, const char *, const char *,\n    zfs_keyformat_t, boolean_t, uint8_t **, size_t *);\n\nstatic zfs_uri_handler_t uri_handlers[] = {\n\t{ \"file\", get_key_material_file },\n\t{ \"https\", get_key_material_https },\n\t{ \"http\", get_key_material_https },\n\t{ NULL, NULL }\n};\n\nstatic int\npkcs11_get_urandom(uint8_t *buf, size_t bytes)\n{\n\tint rand;\n\tssize_t bytes_read = 0;\n\n\trand = open(\"/dev/urandom\", O_RDONLY | O_CLOEXEC);\n\n\tif (rand < 0)\n\t\treturn (rand);\n\n\twhile (bytes_read < bytes) {\n\t\tssize_t rc = read(rand, buf + bytes_read, bytes - bytes_read);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tbytes_read += rc;\n\t}\n\n\t(void) close(rand);\n\n\treturn (bytes_read);\n}\n\nstatic int\nzfs_prop_parse_keylocation(libzfs_handle_t *restrict hdl, const char *str,\n    zfs_keylocation_t *restrict locp, char **restrict schemep)\n{\n\t*locp = ZFS_KEYLOCATION_NONE;\n\t*schemep = NULL;\n\n\tif (strcmp(\"prompt\", str) == 0) {\n\t\t*locp = ZFS_KEYLOCATION_PROMPT;\n\t\treturn (0);\n\t}\n\n\tregmatch_t pmatch[2];\n\n\tif (regexec(&hdl->libzfs_urire, str, ARRAY_SIZE(pmatch),\n\t    pmatch, 0) == 0) {\n\t\tsize_t scheme_len;\n\n\t\tif (pmatch[1].rm_so == -1) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Invalid URI\"));\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\tscheme_len = pmatch[1].rm_eo - pmatch[1].rm_so;\n\n\t\t*schemep = calloc(1, scheme_len + 1);\n\t\tif (*schemep == NULL) {\n\t\t\tint ret = errno;\n\n\t\t\terrno = 0;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Invalid URI\"));\n\t\t\treturn (ret);\n\t\t}\n\n\t\t(void) memcpy(*schemep, str + pmatch[1].rm_so, scheme_len);\n\t\t*locp = ZFS_KEYLOCATION_URI;\n\t\treturn (0);\n\t}\n\n\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"Invalid keylocation\"));\n\treturn (EINVAL);\n}\n\nstatic int\nhex_key_to_raw(char *hex, int hexlen, uint8_t *out)\n{\n\tint ret, i;\n\tunsigned int c;\n\n\tfor (i = 0; i < hexlen; i += 2) {\n\t\tif (!isxdigit(hex[i]) || !isxdigit(hex[i + 1])) {\n\t\t\tret = EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = sscanf(&hex[i], \"%02x\", &c);\n\t\tif (ret != 1) {\n\t\t\tret = EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tout[i / 2] = c;\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\n\nstatic void\ncatch_signal(int sig)\n{\n\tcaught_interrupt = sig;\n}\n\nstatic const char *\nget_format_prompt_string(zfs_keyformat_t format)\n{\n\tswitch (format) {\n\tcase ZFS_KEYFORMAT_RAW:\n\t\treturn (\"raw key\");\n\tcase ZFS_KEYFORMAT_HEX:\n\t\treturn (\"hex key\");\n\tcase ZFS_KEYFORMAT_PASSPHRASE:\n\t\treturn (\"passphrase\");\n\tdefault:\n\t\t \n\t\treturn (NULL);\n\t}\n}\n\n \nstatic int\nvalidate_key(libzfs_handle_t *hdl, zfs_keyformat_t keyformat,\n    const char *key, size_t keylen, boolean_t do_verify)\n{\n\tswitch (keyformat) {\n\tcase ZFS_KEYFORMAT_RAW:\n\t\t \n\t\tif (keylen < WRAPPING_KEY_LEN) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Raw key too short (expected %u).\"),\n\t\t\t    WRAPPING_KEY_LEN);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\tif (keylen > WRAPPING_KEY_LEN) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Raw key too long (expected %u).\"),\n\t\t\t    WRAPPING_KEY_LEN);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tbreak;\n\tcase ZFS_KEYFORMAT_HEX:\n\t\t \n\t\tif (keylen < WRAPPING_KEY_LEN * 2) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Hex key too short (expected %u).\"),\n\t\t\t    WRAPPING_KEY_LEN * 2);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\tif (keylen > WRAPPING_KEY_LEN * 2) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Hex key too long (expected %u).\"),\n\t\t\t    WRAPPING_KEY_LEN * 2);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\t \n\t\tfor (size_t i = 0; i < WRAPPING_KEY_LEN * 2; i++) {\n\t\t\tif (!isxdigit(key[i])) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"Invalid hex character detected.\"));\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ZFS_KEYFORMAT_PASSPHRASE:\n\t\t \n\t\tif (!do_verify)\n\t\t\tbreak;\n\t\tif (keylen > MAX_PASSPHRASE_LEN) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Passphrase too long (max %u).\"),\n\t\t\t    MAX_PASSPHRASE_LEN);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\tif (keylen < MIN_PASSPHRASE_LEN) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Passphrase too short (min %u).\"),\n\t\t\t    MIN_PASSPHRASE_LEN);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nlibzfs_getpassphrase(zfs_keyformat_t keyformat, boolean_t is_reenter,\n    boolean_t new_key, const char *fsname,\n    char **restrict res, size_t *restrict reslen)\n{\n\tFILE *f = stdin;\n\tsize_t buflen = 0;\n\tssize_t bytes;\n\tint ret = 0;\n\tstruct termios old_term, new_term;\n\tstruct sigaction act, osigint, osigtstp;\n\n\t*res = NULL;\n\t*reslen = 0;\n\n\t \n\tcaught_interrupt = 0;\n\tact.sa_flags = 0;\n\t(void) sigemptyset(&act.sa_mask);\n\tact.sa_handler = catch_signal;\n\n\t(void) sigaction(SIGINT, &act, &osigint);\n\tact.sa_handler = SIG_IGN;\n\t(void) sigaction(SIGTSTP, &act, &osigtstp);\n\n\t(void) printf(\"%s %s%s\",\n\t    is_reenter ? \"Re-enter\" : \"Enter\",\n\t    new_key ? \"new \" : \"\",\n\t    get_format_prompt_string(keyformat));\n\tif (fsname != NULL)\n\t\t(void) printf(\" for '%s'\", fsname);\n\t(void) fputc(':', stdout);\n\t(void) fflush(stdout);\n\n\t \n\t(void) tcgetattr(fileno(f), &old_term);\n\n\tnew_term = old_term;\n\tnew_term.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);\n\n\tret = tcsetattr(fileno(f), TCSAFLUSH, &new_term);\n\tif (ret != 0) {\n\t\tret = errno;\n\t\terrno = 0;\n\t\tgoto out;\n\t}\n\n\tbytes = getline(res, &buflen, f);\n\tif (bytes < 0) {\n\t\tret = errno;\n\t\terrno = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (bytes > 0 && (*res)[bytes - 1] == '\\n') {\n\t\t(*res)[bytes - 1] = '\\0';\n\t\tbytes--;\n\t}\n\n\t*reslen = bytes;\n\nout:\n\t \n\t(void) tcsetattr(fileno(f), TCSAFLUSH, &old_term);\n\t(void) sigaction(SIGINT, &osigint, NULL);\n\t(void) sigaction(SIGTSTP, &osigtstp, NULL);\n\n\t \n\tif (caught_interrupt != 0)\n\t\t(void) kill(getpid(), caught_interrupt);\n\n\t \n\t(void) printf(\"\\n\");\n\n\treturn (ret);\n}\n\nstatic int\nget_key_interactive(libzfs_handle_t *restrict hdl, const char *fsname,\n    zfs_keyformat_t keyformat, boolean_t confirm_key, boolean_t newkey,\n    uint8_t **restrict outbuf, size_t *restrict len_out)\n{\n\tchar *buf = NULL, *buf2 = NULL;\n\tsize_t buflen = 0, buf2len = 0;\n\tint ret = 0;\n\n\tASSERT(isatty(fileno(stdin)));\n\n\t \n\tif (keyformat == ZFS_KEYFORMAT_RAW) {\n\t\tret = EINVAL;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Cannot enter raw keys on the terminal\"));\n\t\tgoto out;\n\t}\n\n\t \n\tif ((ret = libzfs_getpassphrase(keyformat, B_FALSE, newkey, fsname,\n\t    &buf, &buflen)) != 0) {\n\t\tfree(buf);\n\t\tbuf = NULL;\n\t\tbuflen = 0;\n\t\tgoto out;\n\t}\n\n\tif (!confirm_key)\n\t\tgoto out;\n\n\tif ((ret = validate_key(hdl, keyformat, buf, buflen, confirm_key)) !=\n\t    0) {\n\t\tfree(buf);\n\t\treturn (ret);\n\t}\n\n\tret = libzfs_getpassphrase(keyformat, B_TRUE, newkey, fsname, &buf2,\n\t    &buf2len);\n\tif (ret != 0) {\n\t\tfree(buf);\n\t\tfree(buf2);\n\t\tbuf = buf2 = NULL;\n\t\tbuflen = buf2len = 0;\n\t\tgoto out;\n\t}\n\n\tif (buflen != buf2len || strcmp(buf, buf2) != 0) {\n\t\tfree(buf);\n\t\tbuf = NULL;\n\t\tbuflen = 0;\n\n\t\tret = EINVAL;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Provided keys do not match.\"));\n\t}\n\n\tfree(buf2);\n\nout:\n\t*outbuf = (uint8_t *)buf;\n\t*len_out = buflen;\n\treturn (ret);\n}\n\nstatic int\nget_key_material_raw(FILE *fd, zfs_keyformat_t keyformat,\n    uint8_t **buf, size_t *len_out)\n{\n\tint ret = 0;\n\tsize_t buflen = 0;\n\n\t*len_out = 0;\n\n\t \n\tif (keyformat != ZFS_KEYFORMAT_RAW) {\n\t\tssize_t bytes;\n\n\t\tbytes = getline((char **)buf, &buflen, fd);\n\t\tif (bytes < 0) {\n\t\t\tret = errno;\n\t\t\terrno = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (bytes > 0 && (*buf)[bytes - 1] == '\\n') {\n\t\t\t(*buf)[bytes - 1] = '\\0';\n\t\t\tbytes--;\n\t\t}\n\n\t\t*len_out = bytes;\n\t} else {\n\t\tsize_t n;\n\n\t\t \n\t\t*buf = malloc((WRAPPING_KEY_LEN + 1) * sizeof (uint8_t));\n\t\tif (*buf == NULL) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tn = fread(*buf, 1, WRAPPING_KEY_LEN + 1, fd);\n\t\tif (n == 0 || ferror(fd)) {\n\t\t\t \n\t\t\tfree(*buf);\n\t\t\t*buf = NULL;\n\t\t\tret = errno;\n\t\t\terrno = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*len_out = n;\n\t}\nout:\n\treturn (ret);\n}\n\nstatic int\nget_key_material_file(libzfs_handle_t *hdl, const char *uri,\n    const char *fsname, zfs_keyformat_t keyformat, boolean_t newkey,\n    uint8_t **restrict buf, size_t *restrict len_out)\n{\n\t(void) fsname, (void) newkey;\n\tFILE *f = NULL;\n\tint ret = 0;\n\n\tif (strlen(uri) < 7)\n\t\treturn (EINVAL);\n\n\tif ((f = fopen(uri + 7, \"re\")) == NULL) {\n\t\tret = errno;\n\t\terrno = 0;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Failed to open key material file: %s\"), strerror(ret));\n\t\treturn (ret);\n\t}\n\n\tret = get_key_material_raw(f, keyformat, buf, len_out);\n\n\t(void) fclose(f);\n\n\treturn (ret);\n}\n\nstatic int\nget_key_material_https(libzfs_handle_t *hdl, const char *uri,\n    const char *fsname, zfs_keyformat_t keyformat, boolean_t newkey,\n    uint8_t **restrict buf, size_t *restrict len_out)\n{\n\t(void) fsname, (void) newkey;\n\tint ret = 0;\n\tFILE *key = NULL;\n\tboolean_t is_http = strncmp(uri, \"http:\", strlen(\"http:\")) == 0;\n\n\tif (strlen(uri) < (is_http ? 7 : 8)) {\n\t\tret = EINVAL;\n\t\tgoto end;\n\t}\n\n#if LIBFETCH_DYNAMIC\n#define\tLOAD_FUNCTION(func) \\\n\t__typeof__(func) *func = dlsym(hdl->libfetch, #func);\n\n\tif (hdl->libfetch == NULL)\n\t\thdl->libfetch = dlopen(LIBFETCH_SONAME, RTLD_LAZY);\n\n\tif (hdl->libfetch == NULL) {\n\t\thdl->libfetch = (void *)-1;\n\t\tchar *err = dlerror();\n\t\tif (err)\n\t\t\thdl->libfetch_load_error = strdup(err);\n\t}\n\n\tif (hdl->libfetch == (void *)-1) {\n\t\tret = ENOSYS;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Couldn't load %s: %s\"),\n\t\t    LIBFETCH_SONAME, hdl->libfetch_load_error ?: \"(?)\");\n\t\tgoto end;\n\t}\n\n\tboolean_t ok;\n#if LIBFETCH_IS_FETCH\n\tLOAD_FUNCTION(fetchGetURL);\n\tchar *fetchLastErrString = dlsym(hdl->libfetch, \"fetchLastErrString\");\n\n\tok = fetchGetURL && fetchLastErrString;\n#elif LIBFETCH_IS_LIBCURL\n\tLOAD_FUNCTION(curl_easy_init);\n\tLOAD_FUNCTION(curl_easy_setopt);\n\tLOAD_FUNCTION(curl_easy_perform);\n\tLOAD_FUNCTION(curl_easy_cleanup);\n\tLOAD_FUNCTION(curl_easy_strerror);\n\tLOAD_FUNCTION(curl_easy_getinfo);\n\n\tok = curl_easy_init && curl_easy_setopt && curl_easy_perform &&\n\t    curl_easy_cleanup && curl_easy_strerror && curl_easy_getinfo;\n#endif\n\tif (!ok) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"keylocation=%s back-end %s missing symbols.\"),\n\t\t    is_http ? \"http://\" : \"https://\", LIBFETCH_SONAME);\n\t\tret = ENOSYS;\n\t\tgoto end;\n\t}\n#endif\n\n#if LIBFETCH_IS_FETCH\n\tkey = fetchGetURL(uri, \"\");\n\tif (key == NULL) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Couldn't GET %s: %s\"),\n\t\t    uri, fetchLastErrString);\n\t\tret = ENETDOWN;\n\t}\n#elif LIBFETCH_IS_LIBCURL\n\tCURL *curl = curl_easy_init();\n\tif (curl == NULL) {\n\t\tret = ENOTSUP;\n\t\tgoto end;\n\t}\n\n\tint kfd = -1;\n#ifdef O_TMPFILE\n\tkfd = open(getenv(\"TMPDIR\") ?: \"/tmp\",\n\t    O_RDWR | O_TMPFILE | O_EXCL | O_CLOEXEC, 0600);\n\tif (kfd != -1)\n\t\tgoto kfdok;\n#endif\n\n\tchar *path;\n\tif (asprintf(&path,\n\t    \"%s/libzfs-XXXXXXXX.https\", getenv(\"TMPDIR\") ?: \"/tmp\") == -1) {\n\t\tret = ENOMEM;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"%s\"),\n\t\t    strerror(ret));\n\t\tgoto end;\n\t}\n\n\tkfd = mkostemps(path, strlen(\".https\"), O_CLOEXEC);\n\tif (kfd == -1) {\n\t\tret = errno;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Couldn't create temporary file %s: %s\"),\n\t\t    path, strerror(ret));\n\t\tfree(path);\n\t\tgoto end;\n\t}\n\t(void) unlink(path);\n\tfree(path);\n\nkfdok:\n\tif ((key = fdopen(kfd, \"r+\")) == NULL) {\n\t\tret = errno;\n\t\t(void) close(kfd);\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Couldn't reopen temporary file: %s\"), strerror(ret));\n\t\tgoto end;\n\t}\n\n\tchar errbuf[CURL_ERROR_SIZE] = \"\";\n\tchar *cainfo = getenv(\"SSL_CA_CERT_FILE\");  \n\tchar *capath = getenv(\"SSL_CA_CERT_PATH\");  \n\tchar *clcert = getenv(\"SSL_CLIENT_CERT_FILE\");  \n\tchar *clkey  = getenv(\"SSL_CLIENT_KEY_FILE\");  \n\t(void) curl_easy_setopt(curl, CURLOPT_URL, uri);\n\t(void) curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\t(void) curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 30000L);\n\t(void) curl_easy_setopt(curl, CURLOPT_WRITEDATA, key);\n\t(void) curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);\n\tif (cainfo != NULL)\n\t\t(void) curl_easy_setopt(curl, CURLOPT_CAINFO, cainfo);\n\tif (capath != NULL)\n\t\t(void) curl_easy_setopt(curl, CURLOPT_CAPATH, capath);\n\tif (clcert != NULL)\n\t\t(void) curl_easy_setopt(curl, CURLOPT_SSLCERT, clcert);\n\tif (clkey != NULL)\n\t\t(void) curl_easy_setopt(curl, CURLOPT_SSLKEY, clkey);\n\n\tCURLcode res = curl_easy_perform(curl);\n\n\tif (res != CURLE_OK) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Failed to connect to %s: %s\"),\n\t\t    uri, strlen(errbuf) ? errbuf : curl_easy_strerror(res));\n\t\tret = ENETDOWN;\n\t} else {\n\t\tlong resp = 200;\n\t\t(void) curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &resp);\n\n\t\tif (resp < 200 || resp >= 300) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Couldn't GET %s: %ld\"),\n\t\t\t    uri, resp);\n\t\t\tret = ENOENT;\n\t\t} else\n\t\t\trewind(key);\n\t}\n\n\tcurl_easy_cleanup(curl);\n#else\n\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t    \"No keylocation=%s back-end.\"), is_http ? \"http://\" : \"https://\");\n\tret = ENOSYS;\n#endif\n\nend:\n\tif (ret == 0)\n\t\tret = get_key_material_raw(key, keyformat, buf, len_out);\n\n\tif (key != NULL)\n\t\tfclose(key);\n\n\treturn (ret);\n}\n\n \nstatic int\nget_key_material(libzfs_handle_t *hdl, boolean_t do_verify, boolean_t newkey,\n    zfs_keyformat_t keyformat, const char *keylocation, const char *fsname,\n    uint8_t **km_out, size_t *kmlen_out, boolean_t *can_retry_out)\n{\n\tint ret;\n\tzfs_keylocation_t keyloc = ZFS_KEYLOCATION_NONE;\n\tuint8_t *km = NULL;\n\tsize_t kmlen = 0;\n\tchar *uri_scheme = NULL;\n\tzfs_uri_handler_t *handler = NULL;\n\tboolean_t can_retry = B_FALSE;\n\n\t \n\tret = zfs_prop_parse_keylocation(hdl, keylocation, &keyloc,\n\t    &uri_scheme);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tswitch (keyloc) {\n\tcase ZFS_KEYLOCATION_PROMPT:\n\t\tif (isatty(fileno(stdin))) {\n\t\t\tcan_retry = keyformat != ZFS_KEYFORMAT_RAW;\n\t\t\tret = get_key_interactive(hdl, fsname, keyformat,\n\t\t\t    do_verify, newkey, &km, &kmlen);\n\t\t} else {\n\t\t\t \n\t\t\tret = get_key_material_raw(stdin, keyformat, &km,\n\t\t\t    &kmlen);\n\t\t}\n\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tbreak;\n\tcase ZFS_KEYLOCATION_URI:\n\t\tret = ENOTSUP;\n\n\t\tfor (handler = uri_handlers; handler->zuh_scheme != NULL;\n\t\t    handler++) {\n\t\t\tif (strcmp(handler->zuh_scheme, uri_scheme) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif ((ret = handler->zuh_handler(hdl, keylocation,\n\t\t\t    fsname, keyformat, newkey, &km, &kmlen)) != 0)\n\t\t\t\tgoto error;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == ENOTSUP) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"URI scheme is not supported\"));\n\t\t\tgoto error;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tret = EINVAL;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Invalid keylocation.\"));\n\t\tgoto error;\n\t}\n\n\tif ((ret = validate_key(hdl, keyformat, (const char *)km, kmlen,\n\t    do_verify)) != 0)\n\t\tgoto error;\n\n\t*km_out = km;\n\t*kmlen_out = kmlen;\n\tif (can_retry_out != NULL)\n\t\t*can_retry_out = can_retry;\n\n\tfree(uri_scheme);\n\treturn (0);\n\nerror:\n\tfree(km);\n\n\t*km_out = NULL;\n\t*kmlen_out = 0;\n\n\tif (can_retry_out != NULL)\n\t\t*can_retry_out = can_retry;\n\n\tfree(uri_scheme);\n\treturn (ret);\n}\n\nstatic int\nderive_key(libzfs_handle_t *hdl, zfs_keyformat_t format, uint64_t iters,\n    uint8_t *key_material, uint64_t salt,\n    uint8_t **key_out)\n{\n\tint ret;\n\tuint8_t *key;\n\n\t*key_out = NULL;\n\n\tkey = zfs_alloc(hdl, WRAPPING_KEY_LEN);\n\n\tswitch (format) {\n\tcase ZFS_KEYFORMAT_RAW:\n\t\tmemcpy(key, key_material, WRAPPING_KEY_LEN);\n\t\tbreak;\n\tcase ZFS_KEYFORMAT_HEX:\n\t\tret = hex_key_to_raw((char *)key_material,\n\t\t    WRAPPING_KEY_LEN * 2, key);\n\t\tif (ret != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Invalid hex key provided.\"));\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ZFS_KEYFORMAT_PASSPHRASE:\n\t\tsalt = LE_64(salt);\n\n\t\tret = PKCS5_PBKDF2_HMAC_SHA1((char *)key_material,\n\t\t    strlen((char *)key_material), ((uint8_t *)&salt),\n\t\t    sizeof (uint64_t), iters, WRAPPING_KEY_LEN, key);\n\t\tif (ret != 1) {\n\t\t\tret = EIO;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to generate key from passphrase.\"));\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t*key_out = key;\n\treturn (0);\n\nerror:\n\tfree(key);\n\n\t*key_out = NULL;\n\treturn (ret);\n}\n\nstatic boolean_t\nencryption_feature_is_enabled(zpool_handle_t *zph)\n{\n\tnvlist_t *features;\n\tuint64_t feat_refcount;\n\n\t \n\tif (zpool_get_prop_int(zph, ZPOOL_PROP_VERSION, NULL)\n\t    < SPA_VERSION_FEATURES)\n\t\treturn (B_FALSE);\n\n\t \n\tfeatures = zpool_get_features(zph);\n\tif (!features || nvlist_lookup_uint64(features,\n\t    spa_feature_table[SPA_FEATURE_ENCRYPTION].fi_guid,\n\t    &feat_refcount) != 0)\n\t\treturn (B_FALSE);\n\n\treturn (B_TRUE);\n}\n\nstatic int\npopulate_create_encryption_params_nvlists(libzfs_handle_t *hdl,\n    zfs_handle_t *zhp, boolean_t newkey, zfs_keyformat_t keyformat,\n    const char *keylocation, nvlist_t *props, uint8_t **wkeydata,\n    uint_t *wkeylen)\n{\n\tint ret;\n\tuint64_t iters = 0, salt = 0;\n\tuint8_t *key_material = NULL;\n\tsize_t key_material_len = 0;\n\tuint8_t *key_data = NULL;\n\tconst char *fsname = (zhp) ? zfs_get_name(zhp) : NULL;\n\n\t \n\tret = get_key_material(hdl, B_TRUE, newkey, keyformat, keylocation,\n\t    fsname, &key_material, &key_material_len, NULL);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tif (keyformat == ZFS_KEYFORMAT_PASSPHRASE) {\n\t\t \n\t\tret = pkcs11_get_urandom((uint8_t *)&salt, sizeof (uint64_t));\n\t\tif (ret != sizeof (uint64_t)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to generate salt.\"));\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = nvlist_add_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), salt);\n\t\tif (ret != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to add salt to properties.\"));\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tret = nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), &iters);\n\t\tif (ret == ENOENT) {\n\t\t\titers = DEFAULT_PBKDF2_ITERATIONS;\n\t\t\tret = nvlist_add_uint64(props,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), iters);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\t\t} else if (ret != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to get pbkdf2 iterations.\"));\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\t \n\t\tret = nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), &iters);\n\t\tif (ret == 0) {\n\t\t\tret = EINVAL;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Cannot specify pbkdf2iters with a non-passphrase \"\n\t\t\t    \"keyformat.\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tret = derive_key(hdl, keyformat, iters, key_material, salt, &key_data);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tfree(key_material);\n\n\t*wkeydata = key_data;\n\t*wkeylen = WRAPPING_KEY_LEN;\n\treturn (0);\n\nerror:\n\tif (key_material != NULL)\n\t\tfree(key_material);\n\tif (key_data != NULL)\n\t\tfree(key_data);\n\n\t*wkeydata = NULL;\n\t*wkeylen = 0;\n\treturn (ret);\n}\n\nstatic boolean_t\nproplist_has_encryption_props(nvlist_t *props)\n{\n\tint ret;\n\tuint64_t intval;\n\tconst char *strval;\n\n\tret = nvlist_lookup_uint64(props,\n\t    zfs_prop_to_name(ZFS_PROP_ENCRYPTION), &intval);\n\tif (ret == 0 && intval != ZIO_CRYPT_OFF)\n\t\treturn (B_TRUE);\n\n\tret = nvlist_lookup_string(props,\n\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), &strval);\n\tif (ret == 0 && strcmp(strval, \"none\") != 0)\n\t\treturn (B_TRUE);\n\n\tret = nvlist_lookup_uint64(props,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), &intval);\n\tif (ret == 0)\n\t\treturn (B_TRUE);\n\n\tret = nvlist_lookup_uint64(props,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), &intval);\n\tif (ret == 0)\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\nint\nzfs_crypto_get_encryption_root(zfs_handle_t *zhp, boolean_t *is_encroot,\n    char *buf)\n{\n\tint ret;\n\tchar prop_encroot[MAXNAMELEN];\n\n\t \n\tif (zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) == ZIO_CRYPT_OFF) {\n\t\t*is_encroot = B_FALSE;\n\t\tif (buf != NULL)\n\t\t\tbuf[0] = '\\0';\n\t\treturn (0);\n\t}\n\n\tret = zfs_prop_get(zhp, ZFS_PROP_ENCRYPTION_ROOT, prop_encroot,\n\t    sizeof (prop_encroot), NULL, NULL, 0, B_TRUE);\n\tif (ret != 0) {\n\t\t*is_encroot = B_FALSE;\n\t\tif (buf != NULL)\n\t\t\tbuf[0] = '\\0';\n\t\treturn (ret);\n\t}\n\n\t*is_encroot = strcmp(prop_encroot, zfs_get_name(zhp)) == 0;\n\tif (buf != NULL)\n\t\tstrcpy(buf, prop_encroot);\n\n\treturn (0);\n}\n\nint\nzfs_crypto_create(libzfs_handle_t *hdl, char *parent_name, nvlist_t *props,\n    nvlist_t *pool_props, boolean_t stdin_available, uint8_t **wkeydata_out,\n    uint_t *wkeylen_out)\n{\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\tuint64_t crypt = ZIO_CRYPT_INHERIT, pcrypt = ZIO_CRYPT_INHERIT;\n\tuint64_t keyformat = ZFS_KEYFORMAT_NONE;\n\tconst char *keylocation = NULL;\n\tzfs_handle_t *pzhp = NULL;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeylen = 0;\n\tboolean_t local_crypt = B_TRUE;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"Encryption create error\"));\n\n\t \n\tret = nvlist_lookup_uint64(props,\n\t    zfs_prop_to_name(ZFS_PROP_ENCRYPTION), &crypt);\n\tif (ret != 0)\n\t\tlocal_crypt = B_FALSE;\n\n\t \n\t(void) nvlist_lookup_uint64(props,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), &keyformat);\n\t(void) nvlist_lookup_string(props,\n\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), &keylocation);\n\n\tif (parent_name != NULL) {\n\t\t \n\t\tpzhp = make_dataset_handle(hdl, parent_name);\n\t\tif (pzhp == NULL) {\n\t\t\tret = ENOENT;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to lookup parent.\"));\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tpcrypt = zfs_prop_get_int(pzhp, ZFS_PROP_ENCRYPTION);\n\n\t\t \n\t\tif (!encryption_feature_is_enabled(pzhp->zpool_hdl)) {\n\t\t\tif (proplist_has_encryption_props(props)) {\n\t\t\t\tret = EINVAL;\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"Encryption feature not enabled.\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!nvlist_exists(pool_props, \"feature@encryption\")) {\n\t\t\tif (proplist_has_encryption_props(props)) {\n\t\t\t\tret = EINVAL;\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"Encryption feature not enabled.\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpcrypt = ZIO_CRYPT_OFF;\n\t}\n\n\t \n\tif (!local_crypt)\n\t\tcrypt = pcrypt;\n\n\t \n\tif (crypt == ZIO_CRYPT_OFF) {\n\t\tif (proplist_has_encryption_props(props)) {\n\t\t\tret = EINVAL;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Encryption must be turned on to set encryption \"\n\t\t\t    \"properties.\"));\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (pcrypt == ZIO_CRYPT_OFF && keylocation == NULL &&\n\t    keyformat == ZFS_KEYFORMAT_NONE) {\n\t\tret = EINVAL;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Keyformat required for new encryption root.\"));\n\t\tgoto out;\n\t}\n\n\t \n\tif (keylocation != NULL && keyformat == ZFS_KEYFORMAT_NONE) {\n\t\tret = EINVAL;\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Keyformat required for new encryption root.\"));\n\t\tgoto out;\n\t}\n\n\t \n\tif (keyformat != ZFS_KEYFORMAT_NONE && keylocation == NULL) {\n\t\tkeylocation = (char *)\"prompt\";\n\t\tret = nvlist_add_string(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), keylocation);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (keylocation != NULL) {\n\t\t \n\t\tif (!stdin_available && strcmp(keylocation, \"prompt\") == 0) {\n\t\t\tret = EINVAL;\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"Cannot use \"\n\t\t\t    \"'prompt' keylocation because stdin is in use.\"));\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = populate_create_encryption_params_nvlists(hdl, NULL,\n\t\t    B_TRUE, keyformat, keylocation, props, &wkeydata,\n\t\t    &wkeylen);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t}\n\n\tif (pzhp != NULL)\n\t\tzfs_close(pzhp);\n\n\t*wkeydata_out = wkeydata;\n\t*wkeylen_out = wkeylen;\n\treturn (0);\n\nout:\n\tif (pzhp != NULL)\n\t\tzfs_close(pzhp);\n\tif (wkeydata != NULL)\n\t\tfree(wkeydata);\n\n\t*wkeydata_out = NULL;\n\t*wkeylen_out = 0;\n\treturn (ret);\n}\n\nint\nzfs_crypto_clone_check(libzfs_handle_t *hdl, zfs_handle_t *origin_zhp,\n    char *parent_name, nvlist_t *props)\n{\n\t(void) origin_zhp, (void) parent_name;\n\tchar errbuf[ERRBUFLEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"Encryption clone error\"));\n\n\t \n\tif (nvlist_exists(props, zfs_prop_to_name(ZFS_PROP_KEYFORMAT)) ||\n\t    nvlist_exists(props, zfs_prop_to_name(ZFS_PROP_KEYLOCATION)) ||\n\t    nvlist_exists(props, zfs_prop_to_name(ZFS_PROP_ENCRYPTION)) ||\n\t    nvlist_exists(props, zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS))) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Encryption properties must inherit from origin dataset.\"));\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}\n\ntypedef struct loadkeys_cbdata {\n\tuint64_t cb_numfailed;\n\tuint64_t cb_numattempted;\n} loadkey_cbdata_t;\n\nstatic int\nload_keys_cb(zfs_handle_t *zhp, void *arg)\n{\n\tint ret;\n\tboolean_t is_encroot;\n\tloadkey_cbdata_t *cb = arg;\n\tuint64_t keystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\n\t \n\tret = zfs_crypto_get_encryption_root(zhp, &is_encroot, NULL);\n\tif (ret != 0 || !is_encroot)\n\t\tgoto out;\n\n\t \n\tif (keystatus == ZFS_KEYSTATUS_AVAILABLE)\n\t\tgoto out;\n\n\t \n\tcb->cb_numattempted++;\n\n\tret = zfs_crypto_load_key(zhp, B_FALSE, NULL);\n\tif (ret)\n\t\tcb->cb_numfailed++;\n\nout:\n\t(void) zfs_iter_filesystems_v2(zhp, 0, load_keys_cb, cb);\n\tzfs_close(zhp);\n\n\t \n\treturn (0);\n}\n\n \nint\nzfs_crypto_attempt_load_keys(libzfs_handle_t *hdl, const char *fsname)\n{\n\tint ret;\n\tzfs_handle_t *zhp = NULL;\n\tloadkey_cbdata_t cb = { 0 };\n\n\tzhp = zfs_open(hdl, fsname, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\tif (zhp == NULL) {\n\t\tret = ENOENT;\n\t\tgoto error;\n\t}\n\n\tret = load_keys_cb(zfs_handle_dup(zhp), &cb);\n\tif (ret)\n\t\tgoto error;\n\n\t(void) printf(gettext(\"%llu / %llu keys successfully loaded\\n\"),\n\t    (u_longlong_t)(cb.cb_numattempted - cb.cb_numfailed),\n\t    (u_longlong_t)cb.cb_numattempted);\n\n\tif (cb.cb_numfailed != 0) {\n\t\tret = -1;\n\t\tgoto error;\n\t}\n\n\tzfs_close(zhp);\n\treturn (0);\n\nerror:\n\tif (zhp != NULL)\n\t\tzfs_close(zhp);\n\treturn (ret);\n}\n\nint\nzfs_crypto_load_key(zfs_handle_t *zhp, boolean_t noop,\n    const char *alt_keylocation)\n{\n\tint ret, attempts = 0;\n\tchar errbuf[ERRBUFLEN];\n\tuint64_t keystatus, iters = 0, salt = 0;\n\tuint64_t keyformat = ZFS_KEYFORMAT_NONE;\n\tchar prop_keylocation[MAXNAMELEN];\n\tchar prop_encroot[MAXNAMELEN];\n\tconst char *keylocation = NULL;\n\tuint8_t *key_material = NULL, *key_data = NULL;\n\tsize_t key_material_len;\n\tboolean_t is_encroot, can_retry = B_FALSE, correctible = B_FALSE;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"Key load error\"));\n\n\t \n\tif (!encryption_feature_is_enabled(zhp->zpool_hdl)) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Encryption feature not enabled.\"));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tkeyformat = zfs_prop_get_int(zhp, ZFS_PROP_KEYFORMAT);\n\tif (keyformat == ZFS_KEYFORMAT_NONE) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"'%s' is not encrypted.\"), zfs_get_name(zhp));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = zfs_crypto_get_encryption_root(zhp, &is_encroot, prop_encroot);\n\tif (ret != 0) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Failed to get encryption root for '%s'.\"),\n\t\t    zfs_get_name(zhp));\n\t\tgoto error;\n\t} else if (!is_encroot) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Keys must be loaded for encryption root of '%s' (%s).\"),\n\t\t    zfs_get_name(zhp), prop_encroot);\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (alt_keylocation != NULL) {\n\t\tkeylocation = alt_keylocation;\n\t} else {\n\t\tret = zfs_prop_get(zhp, ZFS_PROP_KEYLOCATION, prop_keylocation,\n\t\t    sizeof (prop_keylocation), NULL, NULL, 0, B_TRUE);\n\t\tif (ret != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to get keylocation for '%s'.\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\tgoto error;\n\t\t}\n\n\t\tkeylocation = prop_keylocation;\n\t}\n\n\t \n\tif (!noop) {\n\t\tkeystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\t\tif (keystatus == ZFS_KEYSTATUS_AVAILABLE) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Key already loaded for '%s'.\"), zfs_get_name(zhp));\n\t\t\tret = EEXIST;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (keyformat == ZFS_KEYFORMAT_PASSPHRASE) {\n\t\tsalt = zfs_prop_get_int(zhp, ZFS_PROP_PBKDF2_SALT);\n\t\titers = zfs_prop_get_int(zhp, ZFS_PROP_PBKDF2_ITERS);\n\t}\n\ntry_again:\n\t \n\tcorrectible = B_TRUE;\n\n\t \n\tret = get_key_material(zhp->zfs_hdl, B_FALSE, B_FALSE, keyformat,\n\t    keylocation, zfs_get_name(zhp), &key_material, &key_material_len,\n\t    &can_retry);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = derive_key(zhp->zfs_hdl, keyformat, iters, key_material, salt,\n\t    &key_data);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tcorrectible = B_FALSE;\n\n\t \n\tret = lzc_load_key(zhp->zfs_name, noop, key_data, WRAPPING_KEY_LEN);\n\tif (ret != 0) {\n\t\tswitch (ret) {\n\t\tcase EPERM:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Permission denied.\"));\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Invalid parameters provided for dataset %s.\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\tbreak;\n\t\tcase EEXIST:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Key already loaded for '%s'.\"), zfs_get_name(zhp));\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' is busy.\"), zfs_get_name(zhp));\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tcorrectible = B_TRUE;\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Incorrect key provided for '%s'.\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\tbreak;\n\t\tcase ZFS_ERR_CRYPTO_NOTSUP:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' uses an unsupported encryption suite.\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\tbreak;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tfree(key_material);\n\tfree(key_data);\n\n\treturn (0);\n\nerror:\n\tzfs_error(zhp->zfs_hdl, EZFS_CRYPTOFAILED, errbuf);\n\tif (key_material != NULL) {\n\t\tfree(key_material);\n\t\tkey_material = NULL;\n\t}\n\tif (key_data != NULL) {\n\t\tfree(key_data);\n\t\tkey_data = NULL;\n\t}\n\n\t \n\tattempts++;\n\tif (can_retry && correctible && attempts < MAX_KEY_PROMPT_ATTEMPTS)\n\t\tgoto try_again;\n\n\treturn (ret);\n}\n\nint\nzfs_crypto_unload_key(zfs_handle_t *zhp)\n{\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\tchar prop_encroot[MAXNAMELEN];\n\tuint64_t keystatus, keyformat;\n\tboolean_t is_encroot;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"Key unload error\"));\n\n\t \n\tif (!encryption_feature_is_enabled(zhp->zpool_hdl)) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Encryption feature not enabled.\"));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tkeyformat = zfs_prop_get_int(zhp, ZFS_PROP_KEYFORMAT);\n\tif (keyformat == ZFS_KEYFORMAT_NONE) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"'%s' is not encrypted.\"), zfs_get_name(zhp));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = zfs_crypto_get_encryption_root(zhp, &is_encroot, prop_encroot);\n\tif (ret != 0) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Failed to get encryption root for '%s'.\"),\n\t\t    zfs_get_name(zhp));\n\t\tgoto error;\n\t} else if (!is_encroot) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Keys must be unloaded for encryption root of '%s' (%s).\"),\n\t\t    zfs_get_name(zhp), prop_encroot);\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tkeystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\tif (keystatus == ZFS_KEYSTATUS_UNAVAILABLE) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Key already unloaded for '%s'.\"), zfs_get_name(zhp));\n\t\tret = EACCES;\n\t\tgoto error;\n\t}\n\n\t \n\tret = lzc_unload_key(zhp->zfs_name);\n\n\tif (ret != 0) {\n\t\tswitch (ret) {\n\t\tcase EPERM:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Permission denied.\"));\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Key already unloaded for '%s'.\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' is busy.\"), zfs_get_name(zhp));\n\t\t\tbreak;\n\t\t}\n\t\tzfs_error(zhp->zfs_hdl, EZFS_CRYPTOFAILED, errbuf);\n\t}\n\n\treturn (ret);\n\nerror:\n\tzfs_error(zhp->zfs_hdl, EZFS_CRYPTOFAILED, errbuf);\n\treturn (ret);\n}\n\nstatic int\nzfs_crypto_verify_rewrap_nvlist(zfs_handle_t *zhp, nvlist_t *props,\n    nvlist_t **props_out, char *errbuf)\n{\n\tint ret;\n\tnvpair_t *elem = NULL;\n\tzfs_prop_t prop;\n\tnvlist_t *new_props = NULL;\n\n\tnew_props = fnvlist_alloc();\n\n\t \n\twhile ((elem = nvlist_next_nvpair(props, elem)) != NULL) {\n\t\tconst char *propname = nvpair_name(elem);\n\t\tprop = zfs_name_to_prop(propname);\n\n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_PBKDF2_ITERS:\n\t\tcase ZFS_PROP_KEYFORMAT:\n\t\tcase ZFS_PROP_KEYLOCATION:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EINVAL;\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Only keyformat, keylocation and pbkdf2iters may \"\n\t\t\t    \"be set with this command.\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tnew_props = zfs_valid_proplist(zhp->zfs_hdl, zhp->zfs_type, props,\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ZONED), NULL, zhp->zpool_hdl,\n\t    B_TRUE, errbuf);\n\tif (new_props == NULL) {\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t*props_out = new_props;\n\treturn (0);\n\nerror:\n\tnvlist_free(new_props);\n\t*props_out = NULL;\n\treturn (ret);\n}\n\nint\nzfs_crypto_rewrap(zfs_handle_t *zhp, nvlist_t *raw_props, boolean_t inheritkey)\n{\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\tboolean_t is_encroot;\n\tnvlist_t *props = NULL;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeylen = 0;\n\tdcp_cmd_t cmd = (inheritkey) ? DCP_CMD_INHERIT : DCP_CMD_NEW_KEY;\n\tuint64_t crypt, pcrypt, keystatus, pkeystatus;\n\tuint64_t keyformat = ZFS_KEYFORMAT_NONE;\n\tzfs_handle_t *pzhp = NULL;\n\tconst char *keylocation = NULL;\n\tchar origin_name[MAXNAMELEN];\n\tchar prop_keylocation[MAXNAMELEN];\n\tchar parent_name[ZFS_MAX_DATASET_NAME_LEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"Key change error\"));\n\n\t \n\tif (!encryption_feature_is_enabled(zhp->zpool_hdl)) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Encryption feature not enabled.\"));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tcrypt = zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION);\n\tif (crypt == ZIO_CRYPT_OFF) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Dataset not encrypted.\"));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = zfs_crypto_get_encryption_root(zhp, &is_encroot, NULL);\n\tif (ret != 0) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Failed to get encryption root for '%s'.\"),\n\t\t    zfs_get_name(zhp));\n\t\tgoto error;\n\t}\n\n\t \n\tret = zfs_prop_get(zhp, ZFS_PROP_ORIGIN, origin_name,\n\t    sizeof (origin_name), NULL, NULL, 0, B_TRUE);\n\tif (ret == 0 && strcmp(origin_name, \"\") != 0) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Keys cannot be changed on clones.\"));\n\t\tret = EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (!inheritkey) {\n\t\t \n\t\tret = zfs_crypto_verify_rewrap_nvlist(zhp, raw_props, &props,\n\t\t    errbuf);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\t \n\t\t(void) nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), &keyformat);\n\t\t(void) nvlist_lookup_string(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), &keylocation);\n\n\t\tif (is_encroot) {\n\t\t\t \n\t\t\tif (keyformat == ZFS_KEYFORMAT_NONE) {\n\t\t\t\tkeyformat = zfs_prop_get_int(zhp,\n\t\t\t\t    ZFS_PROP_KEYFORMAT);\n\t\t\t\tret = nvlist_add_uint64(props,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT),\n\t\t\t\t    keyformat);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tzfs_error_aux(zhp->zfs_hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN, \"Failed to \"\n\t\t\t\t\t    \"get existing keyformat \"\n\t\t\t\t\t    \"property.\"));\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (keylocation == NULL) {\n\t\t\t\tret = zfs_prop_get(zhp, ZFS_PROP_KEYLOCATION,\n\t\t\t\t    prop_keylocation, sizeof (prop_keylocation),\n\t\t\t\t    NULL, NULL, 0, B_TRUE);\n\t\t\t\tif (ret != 0) {\n\t\t\t\t\tzfs_error_aux(zhp->zfs_hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN, \"Failed to \"\n\t\t\t\t\t    \"get existing keylocation \"\n\t\t\t\t\t    \"property.\"));\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\tkeylocation = prop_keylocation;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (keyformat == ZFS_KEYFORMAT_NONE) {\n\t\t\t\tret = EINVAL;\n\t\t\t\tzfs_error_aux(zhp->zfs_hdl,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"Keyformat required \"\n\t\t\t\t    \"for new encryption root.\"));\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (keylocation == NULL) {\n\t\t\t\tkeylocation = \"prompt\";\n\t\t\t\tret = nvlist_add_string(props,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t\t\t\t    keylocation);\n\t\t\t\tif (ret != 0)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = populate_create_encryption_params_nvlists(zhp->zfs_hdl,\n\t\t    zhp, B_TRUE, keyformat, keylocation, props, &wkeydata,\n\t\t    &wkeylen);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t} else {\n\t\t \n\t\tif (!is_encroot) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Key inheritting can only be performed on \"\n\t\t\t    \"encryption roots.\"));\n\t\t\tret = EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tret = zfs_parent_name(zhp, parent_name, sizeof (parent_name));\n\t\tif (ret != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Root dataset cannot inherit key.\"));\n\t\t\tret = EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tpzhp = make_dataset_handle(zhp->zfs_hdl, parent_name);\n\t\tif (pzhp == NULL) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Failed to lookup parent.\"));\n\t\t\tret = ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tpcrypt = zfs_prop_get_int(pzhp, ZFS_PROP_ENCRYPTION);\n\t\tif (pcrypt == ZIO_CRYPT_OFF) {\n\t\t\tzfs_error_aux(pzhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Parent must be encrypted.\"));\n\t\t\tret = EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tpkeystatus = zfs_prop_get_int(pzhp, ZFS_PROP_KEYSTATUS);\n\t\tif (pkeystatus == ZFS_KEYSTATUS_UNAVAILABLE) {\n\t\t\tzfs_error_aux(pzhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Parent key must be loaded.\"));\n\t\t\tret = EACCES;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tkeystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\tif (keystatus == ZFS_KEYSTATUS_UNAVAILABLE) {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"Key must be loaded.\"));\n\t\tret = EACCES;\n\t\tgoto error;\n\t}\n\n\t \n\tret = lzc_change_key(zhp->zfs_name, cmd, props, wkeydata, wkeylen);\n\tif (ret != 0) {\n\t\tswitch (ret) {\n\t\tcase EPERM:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Permission denied.\"));\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Invalid properties for key change.\"));\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Key is not currently loaded.\"));\n\t\t\tbreak;\n\t\t}\n\t\tzfs_error(zhp->zfs_hdl, EZFS_CRYPTOFAILED, errbuf);\n\t}\n\n\tif (pzhp != NULL)\n\t\tzfs_close(pzhp);\n\tif (props != NULL)\n\t\tnvlist_free(props);\n\tif (wkeydata != NULL)\n\t\tfree(wkeydata);\n\n\treturn (ret);\n\nerror:\n\tif (pzhp != NULL)\n\t\tzfs_close(pzhp);\n\tif (props != NULL)\n\t\tnvlist_free(props);\n\tif (wkeydata != NULL)\n\t\tfree(wkeydata);\n\n\tzfs_error(zhp->zfs_hdl, EZFS_CRYPTOFAILED, errbuf);\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}