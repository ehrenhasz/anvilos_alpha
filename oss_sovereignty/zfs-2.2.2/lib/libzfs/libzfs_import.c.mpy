{
  "module_name": "libzfs_import.c",
  "hash_id": "bb19b587ea943faefe1771395c1e543ff8db612019966ee4b183f5355d57065e",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_import.c",
  "human_readable_source": " \n \n\n#include <errno.h>\n#include <libintl.h>\n#include <libgen.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/vdev_impl.h>\n#include <libzfs.h>\n#include \"libzfs_impl.h\"\n#include <libzutil.h>\n#include <sys/arc_impl.h>\n\n \nstatic int\npool_active(libzfs_handle_t *hdl, const char *name, uint64_t guid,\n    boolean_t *isactive)\n{\n\tzpool_handle_t *zhp;\n\n\tif (zpool_open_silent(hdl, name, &zhp) != 0)\n\t\treturn (-1);\n\n\tif (zhp == NULL) {\n\t\t*isactive = B_FALSE;\n\t\treturn (0);\n\t}\n\n\tuint64_t theguid = fnvlist_lookup_uint64(zhp->zpool_config,\n\t    ZPOOL_CONFIG_POOL_GUID);\n\n\tzpool_close(zhp);\n\n\t*isactive = (theguid == guid);\n\treturn (0);\n}\n\nstatic nvlist_t *\nrefresh_config(libzfs_handle_t *hdl, nvlist_t *config)\n{\n\tnvlist_t *nvl;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint err, dstbuf_size;\n\n\tzcmd_write_conf_nvlist(hdl, &zc, config);\n\n\tdstbuf_size = MAX(CONFIG_BUF_MINSIZE, zc.zc_nvlist_conf_size * 32);\n\n\tzcmd_alloc_dst_nvlist(hdl, &zc, dstbuf_size);\n\n\twhile ((err = zfs_ioctl(hdl, ZFS_IOC_POOL_TRYIMPORT,\n\t    &zc)) != 0 && errno == ENOMEM)\n\t\tzcmd_expand_dst_nvlist(hdl, &zc);\n\n\tif (err) {\n\t\tzcmd_free_nvlists(&zc);\n\t\treturn (NULL);\n\t}\n\n\tif (zcmd_read_dst_nvlist(hdl, &zc, &nvl) != 0) {\n\t\tzcmd_free_nvlists(&zc);\n\t\treturn (NULL);\n\t}\n\n\tzcmd_free_nvlists(&zc);\n\treturn (nvl);\n}\n\nstatic nvlist_t *\nrefresh_config_libzfs(void *handle, nvlist_t *tryconfig)\n{\n\treturn (refresh_config((libzfs_handle_t *)handle, tryconfig));\n}\n\nstatic int\npool_active_libzfs(void *handle, const char *name, uint64_t guid,\n    boolean_t *isactive)\n{\n\treturn (pool_active((libzfs_handle_t *)handle, name, guid, isactive));\n}\n\nconst pool_config_ops_t libzfs_config_ops = {\n\t.pco_refresh_config = refresh_config_libzfs,\n\t.pco_pool_active = pool_active_libzfs,\n};\n\n \nstatic uint64_t\nlabel_offset(uint64_t size, int l)\n{\n\tASSERT(P2PHASE_TYPED(size, sizeof (vdev_label_t), uint64_t) == 0);\n\treturn (l * sizeof (vdev_label_t) + (l < VDEV_LABELS / 2 ?\n\t    0 : size - VDEV_LABELS * sizeof (vdev_label_t)));\n}\n\n \nint\nzpool_clear_label(int fd)\n{\n\tstruct stat64 statbuf;\n\tint l;\n\tvdev_label_t *label;\n\tuint64_t size;\n\tboolean_t labels_cleared = B_FALSE, clear_l2arc_header = B_FALSE,\n\t    header_cleared = B_FALSE;\n\n\tif (fstat64_blk(fd, &statbuf) == -1)\n\t\treturn (0);\n\n\tsize = P2ALIGN_TYPED(statbuf.st_size, sizeof (vdev_label_t), uint64_t);\n\n\tif ((label = calloc(1, sizeof (vdev_label_t))) == NULL)\n\t\treturn (-1);\n\n\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\tuint64_t state, guid, l2cache;\n\t\tnvlist_t *config;\n\n\t\tif (pread64(fd, label, sizeof (vdev_label_t),\n\t\t    label_offset(size, l)) != sizeof (vdev_label_t)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nvlist_unpack(label->vl_vdev_phys.vp_nvlist,\n\t\t    sizeof (label->vl_vdev_phys.vp_nvlist), &config, 0) != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_GUID,\n\t\t    &guid) != 0 || guid == 0) {\n\t\t\tnvlist_free(config);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE,\n\t\t    &state) != 0 || state > POOL_STATE_L2CACHE) {\n\t\t\tnvlist_free(config);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!clear_l2arc_header) {\n\t\t\tif (nvlist_lookup_uint64(config,\n\t\t\t    ZPOOL_CONFIG_POOL_STATE, &l2cache) == 0 &&\n\t\t\t    l2cache == POOL_STATE_L2CACHE) {\n\t\t\t\tclear_l2arc_header = B_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tnvlist_free(config);\n\n\t\t \n\t\tmemset(label, 0, sizeof (vdev_label_t));\n\t\tsize_t label_size = sizeof (vdev_label_t) - (2 * VDEV_PAD_SIZE);\n\n\t\tif (pwrite64(fd, label, label_size, label_offset(size, l) +\n\t\t    (2 * VDEV_PAD_SIZE)) == label_size)\n\t\t\tlabels_cleared = B_TRUE;\n\t}\n\n\tif (clear_l2arc_header) {\n\t\t_Static_assert(sizeof (*label) >= sizeof (l2arc_dev_hdr_phys_t),\n\t\t    \"label < l2arc_dev_hdr_phys_t\");\n\t\tmemset(label, 0, sizeof (l2arc_dev_hdr_phys_t));\n\t\tif (pwrite64(fd, label, sizeof (l2arc_dev_hdr_phys_t),\n\t\t    VDEV_LABEL_START_SIZE) == sizeof (l2arc_dev_hdr_phys_t))\n\t\t\theader_cleared = B_TRUE;\n\t}\n\n\tfree(label);\n\n\tif (!labels_cleared || (clear_l2arc_header && !header_cleared))\n\t\treturn (-1);\n\n\treturn (0);\n}\n\nstatic boolean_t\nfind_guid(nvlist_t *nv, uint64_t guid)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\n\tif (fnvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID) == guid)\n\t\treturn (B_TRUE);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (find_guid(child[c], guid))\n\t\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\ntypedef struct aux_cbdata {\n\tconst char\t*cb_type;\n\tuint64_t\tcb_guid;\n\tzpool_handle_t\t*cb_zhp;\n} aux_cbdata_t;\n\nstatic int\nfind_aux(zpool_handle_t *zhp, void *data)\n{\n\taux_cbdata_t *cbp = data;\n\tnvlist_t **list;\n\tuint_t count;\n\n\tnvlist_t *nvroot = fnvlist_lookup_nvlist(zhp->zpool_config,\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\n\tif (nvlist_lookup_nvlist_array(nvroot, cbp->cb_type,\n\t    &list, &count) == 0) {\n\t\tfor (uint_t i = 0; i < count; i++) {\n\t\t\tuint64_t guid = fnvlist_lookup_uint64(list[i],\n\t\t\t    ZPOOL_CONFIG_GUID);\n\t\t\tif (guid == cbp->cb_guid) {\n\t\t\t\tcbp->cb_zhp = zhp;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\treturn (0);\n}\n\n \nint\nzpool_in_use(libzfs_handle_t *hdl, int fd, pool_state_t *state, char **namestr,\n    boolean_t *inuse)\n{\n\tnvlist_t *config;\n\tconst char *name = NULL;\n\tboolean_t ret;\n\tuint64_t guid = 0, vdev_guid;\n\tzpool_handle_t *zhp;\n\tnvlist_t *pool_config;\n\tuint64_t stateval, isspare;\n\taux_cbdata_t cb = { 0 };\n\tboolean_t isactive;\n\n\t*inuse = B_FALSE;\n\n\tif (zpool_read_label(fd, &config, NULL) != 0) {\n\t\t(void) no_memory(hdl);\n\t\treturn (-1);\n\t}\n\n\tif (config == NULL)\n\t\treturn (0);\n\n\tstateval = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE);\n\tvdev_guid = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_GUID);\n\n\tif (stateval != POOL_STATE_SPARE && stateval != POOL_STATE_L2CACHE) {\n\t\tname = fnvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME);\n\t\tguid = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID);\n\t}\n\n\tswitch (stateval) {\n\tcase POOL_STATE_EXPORTED:\n\t\t \n\t\tif (pool_active(hdl, name, guid, &isactive) == 0 && isactive &&\n\t\t    (zhp = zpool_open_canfail(hdl, name)) != NULL) {\n\t\t\tif (zpool_get_prop_int(zhp, ZPOOL_PROP_READONLY, NULL))\n\t\t\t\tstateval = POOL_STATE_ACTIVE;\n\n\t\t\t \n\t\t\tzpool_close(zhp);\n\t\t}\n\n\t\tret = B_TRUE;\n\t\tbreak;\n\n\tcase POOL_STATE_ACTIVE:\n\t\t \n\t\tif (pool_active(hdl, name, guid, &isactive) != 0) {\n\t\t\tnvlist_free(config);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (isactive) {\n\t\t\t \n\t\t\tif ((zhp = zpool_open_canfail(hdl, name)) != NULL &&\n\t\t\t    (pool_config = zpool_get_config(zhp, NULL))\n\t\t\t    != NULL) {\n\t\t\t\tnvlist_t *nvroot = fnvlist_lookup_nvlist(\n\t\t\t\t    pool_config, ZPOOL_CONFIG_VDEV_TREE);\n\t\t\t\tret = find_guid(nvroot, vdev_guid);\n\t\t\t} else {\n\t\t\t\tret = B_FALSE;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ret && nvlist_lookup_uint64(config,\n\t\t\t    ZPOOL_CONFIG_IS_SPARE, &isspare) == 0 && isspare)\n\t\t\t\tstateval = POOL_STATE_SPARE;\n\n\t\t\tif (zhp != NULL)\n\t\t\t\tzpool_close(zhp);\n\t\t} else {\n\t\t\tstateval = POOL_STATE_POTENTIALLY_ACTIVE;\n\t\t\tret = B_TRUE;\n\t\t}\n\t\tbreak;\n\n\tcase POOL_STATE_SPARE:\n\t\t \n\t\tcb.cb_zhp = NULL;\n\t\tcb.cb_guid = vdev_guid;\n\t\tcb.cb_type = ZPOOL_CONFIG_SPARES;\n\t\tif (zpool_iter(hdl, find_aux, &cb) == 1) {\n\t\t\tname = (char *)zpool_get_name(cb.cb_zhp);\n\t\t\tret = B_TRUE;\n\t\t} else {\n\t\t\tret = B_FALSE;\n\t\t}\n\t\tbreak;\n\n\tcase POOL_STATE_L2CACHE:\n\n\t\t \n\t\tcb.cb_zhp = NULL;\n\t\tcb.cb_guid = vdev_guid;\n\t\tcb.cb_type = ZPOOL_CONFIG_L2CACHE;\n\t\tif (zpool_iter(hdl, find_aux, &cb) == 1) {\n\t\t\tname = (char *)zpool_get_name(cb.cb_zhp);\n\t\t\tret = B_TRUE;\n\t\t} else {\n\t\t\tret = B_FALSE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = B_FALSE;\n\t}\n\n\n\tif (ret) {\n\t\t*namestr = zfs_strdup(hdl, name);\n\t\t*state = (pool_state_t)stateval;\n\t}\n\n\tif (cb.cb_zhp)\n\t\tzpool_close(cb.cb_zhp);\n\n\tnvlist_free(config);\n\t*inuse = ret;\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}