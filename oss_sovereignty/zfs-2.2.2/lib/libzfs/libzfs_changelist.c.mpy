{
  "module_name": "libzfs_changelist.c",
  "hash_id": "24fc178a75e573191bc1b349afdd24a569ac303bccb37a1d8ae7aefc8baaab8d",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_changelist.c",
  "human_readable_source": " \n\n \n\n#include <libintl.h>\n#include <libuutil.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <zone.h>\n\n#include <libzfs.h>\n\n#include \"libzfs_impl.h\"\n\n \ntypedef struct prop_changenode {\n\tzfs_handle_t\t\t*cn_handle;\n\tint\t\t\tcn_shared;\n\tint\t\t\tcn_mounted;\n\tint\t\t\tcn_zoned;\n\tboolean_t\t\tcn_needpost;\t \n\tuu_avl_node_t\t\tcn_treenode;\n} prop_changenode_t;\n\nstruct prop_changelist {\n\tzfs_prop_t\t\tcl_prop;\n\tzfs_prop_t\t\tcl_realprop;\n\tzfs_prop_t\t\tcl_shareprop;   \n\tuu_avl_pool_t\t\t*cl_pool;\n\tuu_avl_t\t\t*cl_tree;\n\tboolean_t\t\tcl_waslegacy;\n\tboolean_t\t\tcl_allchildren;\n\tboolean_t\t\tcl_alldependents;\n\tint\t\t\tcl_mflags;\t \n\tint\t\t\tcl_gflags;\t \n\tboolean_t\t\tcl_haszonedchild;\n};\n\n \nint\nchangelist_prefix(prop_changelist_t *clp)\n{\n\tprop_changenode_t *cn;\n\tuu_avl_walk_t *walk;\n\tint ret = 0;\n\tconst enum sa_protocol smb[] = {SA_PROTOCOL_SMB, SA_NO_PROTOCOL};\n\tboolean_t commit_smb_shares = B_FALSE;\n\n\tif (clp->cl_prop != ZFS_PROP_MOUNTPOINT &&\n\t    clp->cl_prop != ZFS_PROP_SHARESMB)\n\t\treturn (0);\n\n\t \n\tif (clp->cl_gflags & CL_GATHER_DONT_UNMOUNT)\n\t\treturn (0);\n\n\tif ((walk = uu_avl_walk_start(clp->cl_tree, UU_WALK_ROBUST)) == NULL)\n\t\treturn (-1);\n\n\twhile ((cn = uu_avl_walk_next(walk)) != NULL) {\n\n\t\t \n\t\tif (ret == -1) {\n\t\t\tcn->cn_needpost = B_FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (getzoneid() == GLOBAL_ZONEID && cn->cn_zoned)\n\t\t\tcontinue;\n\n\t\tif (!ZFS_IS_VOLUME(cn->cn_handle)) {\n\t\t\t \n\t\t\tswitch (clp->cl_prop) {\n\t\t\tcase ZFS_PROP_MOUNTPOINT:\n\t\t\t\tif (zfs_unmount(cn->cn_handle, NULL,\n\t\t\t\t    clp->cl_mflags) != 0) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tcn->cn_needpost = B_FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ZFS_PROP_SHARESMB:\n\t\t\t\t(void) zfs_unshare(cn->cn_handle, NULL,\n\t\t\t\t    smb);\n\t\t\t\tcommit_smb_shares = B_TRUE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (commit_smb_shares)\n\t\tzfs_commit_shares(smb);\n\tuu_avl_walk_end(walk);\n\n\tif (ret == -1)\n\t\t(void) changelist_postfix(clp);\n\n\treturn (ret);\n}\n\n \nint\nchangelist_postfix(prop_changelist_t *clp)\n{\n\tprop_changenode_t *cn;\n\tuu_avl_walk_t *walk;\n\tchar shareopts[ZFS_MAXPROPLEN];\n\tboolean_t commit_smb_shares = B_FALSE;\n\tboolean_t commit_nfs_shares = B_FALSE;\n\n\t \n\tif (clp->cl_gflags & CL_GATHER_DONT_UNMOUNT)\n\t\treturn (0);\n\n\t \n\tif ((cn = uu_avl_last(clp->cl_tree)) == NULL)\n\t\treturn (0);\n\n\tif (clp->cl_prop == ZFS_PROP_MOUNTPOINT &&\n\t    !(clp->cl_gflags & CL_GATHER_DONT_UNMOUNT))\n\t\tremove_mountpoint(cn->cn_handle);\n\n\t \n\tif ((walk = uu_avl_walk_start(clp->cl_tree,\n\t    UU_WALK_REVERSE | UU_WALK_ROBUST)) == NULL)\n\t\treturn (-1);\n\n\twhile ((cn = uu_avl_walk_next(walk)) != NULL) {\n\n\t\tboolean_t sharenfs;\n\t\tboolean_t sharesmb;\n\t\tboolean_t mounted;\n\t\tboolean_t needs_key;\n\n\t\t \n\t\tif (getzoneid() == GLOBAL_ZONEID && cn->cn_zoned)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!cn->cn_needpost)\n\t\t\tcontinue;\n\t\tcn->cn_needpost = B_FALSE;\n\n\t\tzfs_refresh_properties(cn->cn_handle);\n\n\t\tif (ZFS_IS_VOLUME(cn->cn_handle))\n\t\t\tcontinue;\n\n\t\t \n\t\tsharenfs = ((zfs_prop_get(cn->cn_handle, ZFS_PROP_SHARENFS,\n\t\t    shareopts, sizeof (shareopts), NULL, NULL, 0,\n\t\t    B_FALSE) == 0) && (strcmp(shareopts, \"off\") != 0));\n\n\t\tsharesmb = ((zfs_prop_get(cn->cn_handle, ZFS_PROP_SHARESMB,\n\t\t    shareopts, sizeof (shareopts), NULL, NULL, 0,\n\t\t    B_FALSE) == 0) && (strcmp(shareopts, \"off\") != 0));\n\n\t\tneeds_key = (zfs_prop_get_int(cn->cn_handle,\n\t\t    ZFS_PROP_KEYSTATUS) == ZFS_KEYSTATUS_UNAVAILABLE);\n\n\t\tmounted = zfs_is_mounted(cn->cn_handle, NULL);\n\n\t\tif (!mounted && !needs_key && (cn->cn_mounted ||\n\t\t    (((clp->cl_prop == ZFS_PROP_MOUNTPOINT &&\n\t\t    clp->cl_prop == clp->cl_realprop) ||\n\t\t    sharenfs || sharesmb || clp->cl_waslegacy) &&\n\t\t    (zfs_prop_get_int(cn->cn_handle,\n\t\t    ZFS_PROP_CANMOUNT) == ZFS_CANMOUNT_ON)))) {\n\n\t\t\tif (zfs_mount(cn->cn_handle, NULL, 0) == 0)\n\t\t\t\tmounted = TRUE;\n\t\t}\n\n\t\t \n\t\tconst enum sa_protocol nfs[] =\n\t\t    {SA_PROTOCOL_NFS, SA_NO_PROTOCOL};\n\t\tif (sharenfs && mounted) {\n\t\t\tzfs_share(cn->cn_handle, nfs);\n\t\t\tcommit_nfs_shares = B_TRUE;\n\t\t} else if (cn->cn_shared || clp->cl_waslegacy) {\n\t\t\tzfs_unshare(cn->cn_handle, NULL, nfs);\n\t\t\tcommit_nfs_shares = B_TRUE;\n\t\t}\n\t\tconst enum sa_protocol smb[] =\n\t\t    {SA_PROTOCOL_SMB, SA_NO_PROTOCOL};\n\t\tif (sharesmb && mounted) {\n\t\t\tzfs_share(cn->cn_handle, smb);\n\t\t\tcommit_smb_shares = B_TRUE;\n\t\t} else if (cn->cn_shared || clp->cl_waslegacy) {\n\t\t\tzfs_unshare(cn->cn_handle, NULL, smb);\n\t\t\tcommit_smb_shares = B_TRUE;\n\t\t}\n\t}\n\n\tenum sa_protocol proto[SA_PROTOCOL_COUNT + 1], *p = proto;\n\tif (commit_nfs_shares)\n\t\t*p++ = SA_PROTOCOL_NFS;\n\tif (commit_smb_shares)\n\t\t*p++ = SA_PROTOCOL_SMB;\n\t*p++ = SA_NO_PROTOCOL;\n\tzfs_commit_shares(proto);\n\tuu_avl_walk_end(walk);\n\n\treturn (0);\n}\n\n \nstatic boolean_t\nisa_child_of(const char *dataset, const char *parent)\n{\n\tint len;\n\n\tlen = strlen(parent);\n\n\tif (strncmp(dataset, parent, len) == 0 &&\n\t    (dataset[len] == '@' || dataset[len] == '/' ||\n\t    dataset[len] == '\\0'))\n\t\treturn (B_TRUE);\n\telse\n\t\treturn (B_FALSE);\n\n}\n\n \nvoid\nchangelist_rename(prop_changelist_t *clp, const char *src, const char *dst)\n{\n\tprop_changenode_t *cn;\n\tuu_avl_walk_t *walk;\n\tchar newname[ZFS_MAX_DATASET_NAME_LEN];\n\n\tif ((walk = uu_avl_walk_start(clp->cl_tree, UU_WALK_ROBUST)) == NULL)\n\t\treturn;\n\n\twhile ((cn = uu_avl_walk_next(walk)) != NULL) {\n\t\t \n\t\tif (!isa_child_of(cn->cn_handle->zfs_name, src))\n\t\t\tcontinue;\n\n\t\t \n\t\tremove_mountpoint(cn->cn_handle);\n\n\t\t(void) strlcpy(newname, dst, sizeof (newname));\n\t\t(void) strlcat(newname, cn->cn_handle->zfs_name + strlen(src),\n\t\t    sizeof (newname));\n\n\t\t(void) strlcpy(cn->cn_handle->zfs_name, newname,\n\t\t    sizeof (cn->cn_handle->zfs_name));\n\t}\n\n\tuu_avl_walk_end(walk);\n}\n\n \nint\nchangelist_unshare(prop_changelist_t *clp, const enum sa_protocol *proto)\n{\n\tprop_changenode_t *cn;\n\tuu_avl_walk_t *walk;\n\tint ret = 0;\n\n\tif (clp->cl_prop != ZFS_PROP_SHARENFS &&\n\t    clp->cl_prop != ZFS_PROP_SHARESMB)\n\t\treturn (0);\n\n\tif ((walk = uu_avl_walk_start(clp->cl_tree, UU_WALK_ROBUST)) == NULL)\n\t\treturn (-1);\n\n\twhile ((cn = uu_avl_walk_next(walk)) != NULL) {\n\t\tif (zfs_unshare(cn->cn_handle, NULL, proto) != 0)\n\t\t\tret = -1;\n\t}\n\n\tfor (const enum sa_protocol *p = proto; *p != SA_NO_PROTOCOL; ++p)\n\t\tsa_commit_shares(*p);\n\tuu_avl_walk_end(walk);\n\n\treturn (ret);\n}\n\n \nint\nchangelist_haszonedchild(prop_changelist_t *clp)\n{\n\treturn (clp->cl_haszonedchild);\n}\n\n \nvoid\nchangelist_remove(prop_changelist_t *clp, const char *name)\n{\n\tprop_changenode_t *cn;\n\tuu_avl_walk_t *walk;\n\n\tif ((walk = uu_avl_walk_start(clp->cl_tree, UU_WALK_ROBUST)) == NULL)\n\t\treturn;\n\n\twhile ((cn = uu_avl_walk_next(walk)) != NULL) {\n\t\tif (strcmp(cn->cn_handle->zfs_name, name) == 0) {\n\t\t\tuu_avl_remove(clp->cl_tree, cn);\n\t\t\tzfs_close(cn->cn_handle);\n\t\t\tfree(cn);\n\t\t\tuu_avl_walk_end(walk);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tuu_avl_walk_end(walk);\n}\n\n \nvoid\nchangelist_free(prop_changelist_t *clp)\n{\n\tprop_changenode_t *cn;\n\n\tif (clp->cl_tree) {\n\t\tuu_avl_walk_t *walk;\n\n\t\tif ((walk = uu_avl_walk_start(clp->cl_tree,\n\t\t    UU_WALK_ROBUST)) == NULL)\n\t\t\treturn;\n\n\t\twhile ((cn = uu_avl_walk_next(walk)) != NULL) {\n\t\t\tuu_avl_remove(clp->cl_tree, cn);\n\t\t\tzfs_close(cn->cn_handle);\n\t\t\tfree(cn);\n\t\t}\n\n\t\tuu_avl_walk_end(walk);\n\t\tuu_avl_destroy(clp->cl_tree);\n\t}\n\tif (clp->cl_pool)\n\t\tuu_avl_pool_destroy(clp->cl_pool);\n\n\tfree(clp);\n}\n\n \nstatic int\nchangelist_add_mounted(zfs_handle_t *zhp, void *data)\n{\n\tprop_changelist_t *clp = data;\n\tprop_changenode_t *cn;\n\tuu_avl_index_t idx;\n\n\tASSERT3U(clp->cl_prop, ==, ZFS_PROP_MOUNTPOINT);\n\n\tcn = zfs_alloc(zfs_get_handle(zhp), sizeof (prop_changenode_t));\n\tcn->cn_handle = zhp;\n\tcn->cn_mounted = zfs_is_mounted(zhp, NULL);\n\tASSERT3U(cn->cn_mounted, ==, B_TRUE);\n\tcn->cn_shared = zfs_is_shared(zhp, NULL, NULL);\n\tcn->cn_zoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\tcn->cn_needpost = B_TRUE;\n\n\t \n\tif (getzoneid() == GLOBAL_ZONEID && cn->cn_zoned)\n\t\tclp->cl_haszonedchild = B_TRUE;\n\n\tuu_avl_node_init(cn, &cn->cn_treenode, clp->cl_pool);\n\n\tif (uu_avl_find(clp->cl_tree, cn, NULL, &idx) == NULL) {\n\t\tuu_avl_insert(clp->cl_tree, cn, idx);\n\t} else {\n\t\tfree(cn);\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nchange_one(zfs_handle_t *zhp, void *data)\n{\n\tprop_changelist_t *clp = data;\n\tchar property[ZFS_MAXPROPLEN];\n\tchar where[64];\n\tprop_changenode_t *cn = NULL;\n\tzprop_source_t sourcetype = ZPROP_SRC_NONE;\n\tzprop_source_t share_sourcetype = ZPROP_SRC_NONE;\n\tint ret = 0;\n\n\t \n\n\tif (!(ZFS_IS_VOLUME(zhp) && clp->cl_realprop == ZFS_PROP_NAME) &&\n\t    zfs_prop_get(zhp, clp->cl_prop, property,\n\t    sizeof (property), &sourcetype, where, sizeof (where),\n\t    B_FALSE) != 0) {\n\t\tgoto out;\n\t}\n\n\t \n\tif (clp->cl_shareprop != ZPROP_INVAL &&\n\t    zfs_prop_get(zhp, clp->cl_shareprop, property,\n\t    sizeof (property), &share_sourcetype, where, sizeof (where),\n\t    B_FALSE) != 0) {\n\t\tgoto out;\n\t}\n\n\tif (clp->cl_alldependents || clp->cl_allchildren ||\n\t    sourcetype == ZPROP_SRC_DEFAULT ||\n\t    sourcetype == ZPROP_SRC_INHERITED ||\n\t    (clp->cl_shareprop != ZPROP_INVAL &&\n\t    (share_sourcetype == ZPROP_SRC_DEFAULT ||\n\t    share_sourcetype == ZPROP_SRC_INHERITED))) {\n\t\tcn = zfs_alloc(zfs_get_handle(zhp), sizeof (prop_changenode_t));\n\t\tcn->cn_handle = zhp;\n\t\tcn->cn_mounted = (clp->cl_gflags & CL_GATHER_MOUNT_ALWAYS) ||\n\t\t    zfs_is_mounted(zhp, NULL);\n\t\tcn->cn_shared = zfs_is_shared(zhp, NULL, NULL);\n\t\tcn->cn_zoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\t\tcn->cn_needpost = B_TRUE;\n\n\t\t \n\t\tif (getzoneid() == GLOBAL_ZONEID && cn->cn_zoned)\n\t\t\tclp->cl_haszonedchild = B_TRUE;\n\n\t\tuu_avl_node_init(cn, &cn->cn_treenode, clp->cl_pool);\n\n\t\tuu_avl_index_t idx;\n\n\t\tif (uu_avl_find(clp->cl_tree, cn, NULL, &idx) == NULL) {\n\t\t\tuu_avl_insert(clp->cl_tree, cn, idx);\n\t\t} else {\n\t\t\tfree(cn);\n\t\t\tcn = NULL;\n\t\t}\n\n\t\tif (!clp->cl_alldependents)\n\t\t\tret = zfs_iter_children_v2(zhp, 0, change_one, data);\n\n\t\t \n\t\tif (cn != NULL)\n\t\t\treturn (ret);\n\t}\n\nout:\n\tzfs_close(zhp);\n\treturn (ret);\n}\n\nstatic int\ncompare_props(const void *a, const void *b, zfs_prop_t prop)\n{\n\tconst prop_changenode_t *ca = a;\n\tconst prop_changenode_t *cb = b;\n\n\tchar propa[MAXPATHLEN];\n\tchar propb[MAXPATHLEN];\n\n\tboolean_t haspropa, haspropb;\n\n\thaspropa = (zfs_prop_get(ca->cn_handle, prop, propa, sizeof (propa),\n\t    NULL, NULL, 0, B_FALSE) == 0);\n\thaspropb = (zfs_prop_get(cb->cn_handle, prop, propb, sizeof (propb),\n\t    NULL, NULL, 0, B_FALSE) == 0);\n\n\tif (!haspropa && haspropb)\n\t\treturn (-1);\n\telse if (haspropa && !haspropb)\n\t\treturn (1);\n\telse if (!haspropa && !haspropb)\n\t\treturn (0);\n\telse\n\t\treturn (strcmp(propb, propa));\n}\n\nstatic int\ncompare_mountpoints(const void *a, const void *b, void *unused)\n{\n\t \n\t(void) unused;\n\treturn (compare_props(a, b, ZFS_PROP_MOUNTPOINT));\n}\n\nstatic int\ncompare_dataset_names(const void *a, const void *b, void *unused)\n{\n\t(void) unused;\n\treturn (compare_props(a, b, ZFS_PROP_NAME));\n}\n\n \nprop_changelist_t *\nchangelist_gather(zfs_handle_t *zhp, zfs_prop_t prop, int gather_flags,\n    int mnt_flags)\n{\n\tprop_changelist_t *clp;\n\tprop_changenode_t *cn;\n\tzfs_handle_t *temp;\n\tchar property[ZFS_MAXPROPLEN];\n\tboolean_t legacy = B_FALSE;\n\n\tclp = zfs_alloc(zhp->zfs_hdl, sizeof (prop_changelist_t));\n\n\t \n\tif (prop == ZFS_PROP_NAME || prop == ZFS_PROP_ZONED ||\n\t    prop == ZFS_PROP_MOUNTPOINT || prop == ZFS_PROP_SHARENFS ||\n\t    prop == ZFS_PROP_SHARESMB) {\n\n\t\tif (zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT,\n\t\t    property, sizeof (property),\n\t\t    NULL, NULL, 0, B_FALSE) == 0 &&\n\t\t    (strcmp(property, \"legacy\") == 0 ||\n\t\t    strcmp(property, \"none\") == 0)) {\n\t\t\tlegacy = B_TRUE;\n\t\t}\n\t}\n\n\tclp->cl_pool = uu_avl_pool_create(\"changelist_pool\",\n\t    sizeof (prop_changenode_t),\n\t    offsetof(prop_changenode_t, cn_treenode),\n\t    legacy ? compare_dataset_names : compare_mountpoints, 0);\n\tif (clp->cl_pool == NULL) {\n\t\tassert(uu_error() == UU_ERROR_NO_MEMORY);\n\t\t(void) zfs_error(zhp->zfs_hdl, EZFS_NOMEM, \"internal error\");\n\t\tchangelist_free(clp);\n\t\treturn (NULL);\n\t}\n\n\tclp->cl_tree = uu_avl_create(clp->cl_pool, NULL, UU_DEFAULT);\n\tclp->cl_gflags = gather_flags;\n\tclp->cl_mflags = mnt_flags;\n\n\tif (clp->cl_tree == NULL) {\n\t\tassert(uu_error() == UU_ERROR_NO_MEMORY);\n\t\t(void) zfs_error(zhp->zfs_hdl, EZFS_NOMEM, \"internal error\");\n\t\tchangelist_free(clp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (prop == ZFS_PROP_NAME) {\n\t\tclp->cl_prop = ZFS_PROP_MOUNTPOINT;\n\t\tclp->cl_alldependents = B_TRUE;\n\t} else if (prop == ZFS_PROP_ZONED) {\n\t\tclp->cl_prop = ZFS_PROP_MOUNTPOINT;\n\t\tclp->cl_allchildren = B_TRUE;\n\t} else if (prop == ZFS_PROP_CANMOUNT) {\n\t\tclp->cl_prop = ZFS_PROP_MOUNTPOINT;\n\t} else if (prop == ZFS_PROP_VOLSIZE) {\n\t\tclp->cl_prop = ZFS_PROP_MOUNTPOINT;\n\t} else {\n\t\tclp->cl_prop = prop;\n\t}\n\tclp->cl_realprop = prop;\n\n\tif (clp->cl_prop != ZFS_PROP_MOUNTPOINT &&\n\t    clp->cl_prop != ZFS_PROP_SHARENFS &&\n\t    clp->cl_prop != ZFS_PROP_SHARESMB)\n\t\treturn (clp);\n\n\t \n\tif (clp->cl_prop == ZFS_PROP_SHARENFS)\n\t\tclp->cl_shareprop = ZFS_PROP_SHARESMB;\n\telse if (clp->cl_prop == ZFS_PROP_SHARESMB)\n\t\tclp->cl_shareprop = ZFS_PROP_SHARENFS;\n\n\tif (clp->cl_prop == ZFS_PROP_MOUNTPOINT &&\n\t    (clp->cl_gflags & CL_GATHER_ITER_MOUNTED)) {\n\t\t \n\t\tif (zfs_iter_mounted(zhp, changelist_add_mounted, clp) != 0) {\n\t\t\tchangelist_free(clp);\n\t\t\treturn (NULL);\n\t\t}\n\t} else if (clp->cl_alldependents) {\n\t\tif (zfs_iter_dependents_v2(zhp, 0, B_TRUE, change_one,\n\t\t    clp) != 0) {\n\t\t\tchangelist_free(clp);\n\t\t\treturn (NULL);\n\t\t}\n\t} else if (zfs_iter_children_v2(zhp, 0, change_one, clp) != 0) {\n\t\tchangelist_free(clp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif ((temp = zfs_open(zhp->zfs_hdl, zfs_get_name(zhp),\n\t    ZFS_TYPE_DATASET)) == NULL) {\n\t\tchangelist_free(clp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tcn = zfs_alloc(zhp->zfs_hdl, sizeof (prop_changenode_t));\n\tcn->cn_handle = temp;\n\tcn->cn_mounted = (clp->cl_gflags & CL_GATHER_MOUNT_ALWAYS) ||\n\t    zfs_is_mounted(temp, NULL);\n\tcn->cn_shared = zfs_is_shared(temp, NULL, NULL);\n\tcn->cn_zoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\tcn->cn_needpost = B_TRUE;\n\n\tuu_avl_node_init(cn, &cn->cn_treenode, clp->cl_pool);\n\tuu_avl_index_t idx;\n\tif (uu_avl_find(clp->cl_tree, cn, NULL, &idx) == NULL) {\n\t\tuu_avl_insert(clp->cl_tree, cn, idx);\n\t} else {\n\t\tfree(cn);\n\t\tzfs_close(temp);\n\t}\n\n\t \n\tif ((clp->cl_prop == ZFS_PROP_MOUNTPOINT) && legacy) {\n\t\t \n\t\tif (zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) !=\n\t\t    ZFS_CANMOUNT_NOAUTO)\n\t\t\tclp->cl_waslegacy = B_TRUE;\n\t}\n\n\treturn (clp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}