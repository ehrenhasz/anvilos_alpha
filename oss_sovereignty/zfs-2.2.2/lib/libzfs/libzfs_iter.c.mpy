{
  "module_name": "libzfs_iter.c",
  "hash_id": "3b3f92404d02098afa415698673b16ba08ef7ed2e2e33dea206999711e00682d",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_iter.c",
  "human_readable_source": " \n\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <libintl.h>\n#include <libzfs.h>\n#include <libzutil.h>\n#include <sys/mntent.h>\n\n#include \"libzfs_impl.h\"\n\nstatic int\nzfs_iter_clones(zfs_handle_t *zhp, int flags __maybe_unused, zfs_iter_f func,\n    void *data)\n{\n\tnvlist_t *nvl = zfs_get_clones_nvl(zhp);\n\tnvpair_t *pair;\n\n\tif (nvl == NULL)\n\t\treturn (0);\n\n\tfor (pair = nvlist_next_nvpair(nvl, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(nvl, pair)) {\n\t\tzfs_handle_t *clone = zfs_open(zhp->zfs_hdl, nvpair_name(pair),\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\tif (clone != NULL) {\n\t\t\tint err = func(clone, data);\n\t\t\tif (err != 0)\n\t\t\t\treturn (err);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_do_list_ioctl(zfs_handle_t *zhp, int arg, zfs_cmd_t *zc)\n{\n\tint rc;\n\tuint64_t\torig_cookie;\n\n\torig_cookie = zc->zc_cookie;\ntop:\n\t(void) strlcpy(zc->zc_name, zhp->zfs_name, sizeof (zc->zc_name));\n\tzc->zc_objset_stats.dds_creation_txg = 0;\n\trc = zfs_ioctl(zhp->zfs_hdl, arg, zc);\n\n\tif (rc == -1) {\n\t\tswitch (errno) {\n\t\tcase ENOMEM:\n\t\t\t \n\t\t\tzcmd_expand_dst_nvlist(zhp->zfs_hdl, zc);\n\t\t\tzc->zc_cookie = orig_cookie;\n\t\t\tgoto top;\n\t\t \n\t\tcase ESRCH:\n\t\tcase ENOENT:\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = zfs_standard_error(zhp->zfs_hdl, errno,\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot iterate filesystems\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (rc);\n}\n\n \nint\nzfs_iter_filesystems(zfs_handle_t *zhp, zfs_iter_f func, void *data)\n{\n\treturn (zfs_iter_filesystems_v2(zhp, 0, func, data));\n}\n\nint\nzfs_iter_filesystems_v2(zfs_handle_t *zhp, int flags, zfs_iter_f func,\n    void *data)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzfs_handle_t *nzhp;\n\tint ret;\n\n\tif (zhp->zfs_type != ZFS_TYPE_FILESYSTEM)\n\t\treturn (0);\n\n\tzcmd_alloc_dst_nvlist(zhp->zfs_hdl, &zc, 0);\n\n\tif ((flags & ZFS_ITER_SIMPLE) == ZFS_ITER_SIMPLE)\n\t\tzc.zc_simple = B_TRUE;\n\n\twhile ((ret = zfs_do_list_ioctl(zhp, ZFS_IOC_DATASET_LIST_NEXT,\n\t    &zc)) == 0) {\n\t\tif (zc.zc_simple)\n\t\t\tnzhp = make_dataset_simple_handle_zc(zhp, &zc);\n\t\telse\n\t\t\tnzhp = make_dataset_handle_zc(zhp->zfs_hdl, &zc);\n\t\t \n\t\tif (nzhp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = func(nzhp, data)) != 0) {\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t\treturn (ret);\n\t\t}\n\t}\n\tzcmd_free_nvlists(&zc);\n\treturn ((ret < 0) ? ret : 0);\n}\n\n \nint\nzfs_iter_snapshots(zfs_handle_t *zhp, boolean_t simple, zfs_iter_f func,\n    void *data, uint64_t min_txg, uint64_t max_txg)\n{\n\treturn (zfs_iter_snapshots_v2(zhp, simple ? ZFS_ITER_SIMPLE : 0, func,\n\t    data, min_txg, max_txg));\n}\n\nint\nzfs_iter_snapshots_v2(zfs_handle_t *zhp, int flags, zfs_iter_f func,\n    void *data, uint64_t min_txg, uint64_t max_txg)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzfs_handle_t *nzhp;\n\tint ret;\n\tnvlist_t *range_nvl = NULL;\n\n\tif (zhp->zfs_type == ZFS_TYPE_SNAPSHOT ||\n\t    zhp->zfs_type == ZFS_TYPE_BOOKMARK)\n\t\treturn (0);\n\n\tzc.zc_simple = (flags & ZFS_ITER_SIMPLE) != 0;\n\n\tzcmd_alloc_dst_nvlist(zhp->zfs_hdl, &zc, 0);\n\n\tif (min_txg != 0) {\n\t\trange_nvl = fnvlist_alloc();\n\t\tfnvlist_add_uint64(range_nvl, SNAP_ITER_MIN_TXG, min_txg);\n\t}\n\tif (max_txg != 0) {\n\t\tif (range_nvl == NULL)\n\t\t\trange_nvl = fnvlist_alloc();\n\t\tfnvlist_add_uint64(range_nvl, SNAP_ITER_MAX_TXG, max_txg);\n\t}\n\n\tif (range_nvl != NULL)\n\t\tzcmd_write_src_nvlist(zhp->zfs_hdl, &zc, range_nvl);\n\n\twhile ((ret = zfs_do_list_ioctl(zhp, ZFS_IOC_SNAPSHOT_LIST_NEXT,\n\t    &zc)) == 0) {\n\n\t\tif (zc.zc_simple)\n\t\t\tnzhp = make_dataset_simple_handle_zc(zhp, &zc);\n\t\telse\n\t\t\tnzhp = make_dataset_handle_zc(zhp->zfs_hdl, &zc);\n\t\tif (nzhp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = func(nzhp, data)) != 0) {\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t\tfnvlist_free(range_nvl);\n\t\t\treturn (ret);\n\t\t}\n\t}\n\tzcmd_free_nvlists(&zc);\n\tfnvlist_free(range_nvl);\n\treturn ((ret < 0) ? ret : 0);\n}\n\n \nint\nzfs_iter_bookmarks(zfs_handle_t *zhp, zfs_iter_f func, void *data)\n{\n\treturn (zfs_iter_bookmarks_v2(zhp, 0, func, data));\n}\n\nint\nzfs_iter_bookmarks_v2(zfs_handle_t *zhp, int flags __maybe_unused,\n    zfs_iter_f func, void *data)\n{\n\tzfs_handle_t *nzhp;\n\tnvlist_t *props = NULL;\n\tnvlist_t *bmarks = NULL;\n\tint err;\n\tnvpair_t *pair;\n\n\tif ((zfs_get_type(zhp) & (ZFS_TYPE_SNAPSHOT | ZFS_TYPE_BOOKMARK)) != 0)\n\t\treturn (0);\n\n\t \n\tprops = fnvlist_alloc();\n\tfor (zfs_prop_t p = 0; p < ZFS_NUM_PROPS; p++) {\n\t\tif (zfs_prop_valid_for_type(p, ZFS_TYPE_BOOKMARK, B_FALSE)) {\n\t\t\tfnvlist_add_boolean(props, zfs_prop_to_name(p));\n\t\t}\n\t}\n\tfnvlist_add_boolean(props, \"redact_complete\");\n\n\tif ((err = lzc_get_bookmarks(zhp->zfs_name, props, &bmarks)) != 0)\n\t\tgoto out;\n\n\tfor (pair = nvlist_next_nvpair(bmarks, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(bmarks, pair)) {\n\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\tconst char *bmark_name;\n\t\tnvlist_t *bmark_props;\n\n\t\tbmark_name = nvpair_name(pair);\n\t\tbmark_props = fnvpair_value_nvlist(pair);\n\n\t\tif (snprintf(name, sizeof (name), \"%s#%s\", zhp->zfs_name,\n\t\t    bmark_name) >= sizeof (name)) {\n\t\t\terr = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnzhp = make_bookmark_handle(zhp, name, bmark_props);\n\t\tif (nzhp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((err = func(nzhp, data)) != 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfnvlist_free(props);\n\tfnvlist_free(bmarks);\n\n\treturn (err);\n}\n\n \ntypedef struct zfs_node {\n\tzfs_handle_t\t*zn_handle;\n\tavl_node_t\tzn_avlnode;\n} zfs_node_t;\n\nstatic int\nzfs_sort_snaps(zfs_handle_t *zhp, void *data)\n{\n\tavl_tree_t *avl = data;\n\tzfs_node_t *node;\n\tzfs_node_t search;\n\n\tsearch.zn_handle = zhp;\n\tnode = avl_find(avl, &search, NULL);\n\tif (node) {\n\t\t \n\t\tzfs_close(node->zn_handle);\n\t\tavl_remove(avl, node);\n\t\tfree(node);\n\t}\n\n\tnode = zfs_alloc(zhp->zfs_hdl, sizeof (zfs_node_t));\n\tnode->zn_handle = zhp;\n\tavl_add(avl, node);\n\n\treturn (0);\n}\n\nstatic int\nzfs_snapshot_compare(const void *larg, const void *rarg)\n{\n\tzfs_handle_t *l = ((zfs_node_t *)larg)->zn_handle;\n\tzfs_handle_t *r = ((zfs_node_t *)rarg)->zn_handle;\n\tuint64_t lcreate, rcreate;\n\n\t \n\tlcreate = zfs_prop_get_int(l, ZFS_PROP_CREATETXG);\n\trcreate = zfs_prop_get_int(r, ZFS_PROP_CREATETXG);\n\n\treturn (TREE_CMP(lcreate, rcreate));\n}\n\nint\nzfs_iter_snapshots_sorted(zfs_handle_t *zhp, zfs_iter_f callback,\n    void *data, uint64_t min_txg, uint64_t max_txg)\n{\n\treturn (zfs_iter_snapshots_sorted_v2(zhp, 0, callback, data,\n\t    min_txg, max_txg));\n}\n\nint\nzfs_iter_snapshots_sorted_v2(zfs_handle_t *zhp, int flags, zfs_iter_f callback,\n    void *data, uint64_t min_txg, uint64_t max_txg)\n{\n\tint ret = 0;\n\tzfs_node_t *node;\n\tavl_tree_t avl;\n\tvoid *cookie = NULL;\n\n\tavl_create(&avl, zfs_snapshot_compare,\n\t    sizeof (zfs_node_t), offsetof(zfs_node_t, zn_avlnode));\n\n\tret = zfs_iter_snapshots_v2(zhp, flags, zfs_sort_snaps, &avl, min_txg,\n\t    max_txg);\n\n\tfor (node = avl_first(&avl); node != NULL; node = AVL_NEXT(&avl, node))\n\t\tret |= callback(node->zn_handle, data);\n\n\twhile ((node = avl_destroy_nodes(&avl, &cookie)) != NULL)\n\t\tfree(node);\n\n\tavl_destroy(&avl);\n\n\treturn (ret);\n}\n\ntypedef struct {\n\tchar *ssa_first;\n\tchar *ssa_last;\n\tboolean_t ssa_seenfirst;\n\tboolean_t ssa_seenlast;\n\tzfs_iter_f ssa_func;\n\tvoid *ssa_arg;\n} snapspec_arg_t;\n\nstatic int\nsnapspec_cb(zfs_handle_t *zhp, void *arg)\n{\n\tsnapspec_arg_t *ssa = arg;\n\tconst char *shortsnapname;\n\tint err = 0;\n\n\tif (ssa->ssa_seenlast)\n\t\treturn (0);\n\n\tshortsnapname = strchr(zfs_get_name(zhp), '@') + 1;\n\tif (!ssa->ssa_seenfirst && strcmp(shortsnapname, ssa->ssa_first) == 0)\n\t\tssa->ssa_seenfirst = B_TRUE;\n\tif (strcmp(shortsnapname, ssa->ssa_last) == 0)\n\t\tssa->ssa_seenlast = B_TRUE;\n\n\tif (ssa->ssa_seenfirst) {\n\t\terr = ssa->ssa_func(zhp, ssa->ssa_arg);\n\t} else {\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (err);\n}\n\n \nint\nzfs_iter_snapspec(zfs_handle_t *fs_zhp, const char *spec_orig,\n    zfs_iter_f func, void *arg)\n{\n\treturn (zfs_iter_snapspec_v2(fs_zhp, 0, spec_orig, func, arg));\n}\n\nint\nzfs_iter_snapspec_v2(zfs_handle_t *fs_zhp, int flags, const char *spec_orig,\n    zfs_iter_f func, void *arg)\n{\n\tchar *buf, *comma_separated, *cp;\n\tint err = 0;\n\tint ret = 0;\n\n\tbuf = zfs_strdup(fs_zhp->zfs_hdl, spec_orig);\n\tcp = buf;\n\n\twhile ((comma_separated = strsep(&cp, \",\")) != NULL) {\n\t\tchar *pct = strchr(comma_separated, '%');\n\t\tif (pct != NULL) {\n\t\t\tsnapspec_arg_t ssa = { 0 };\n\t\t\tssa.ssa_func = func;\n\t\t\tssa.ssa_arg = arg;\n\n\t\t\tif (pct == comma_separated)\n\t\t\t\tssa.ssa_seenfirst = B_TRUE;\n\t\t\telse\n\t\t\t\tssa.ssa_first = comma_separated;\n\t\t\t*pct = '\\0';\n\t\t\tssa.ssa_last = pct + 1;\n\n\t\t\t \n\t\t\tif (ssa.ssa_last[0] != '\\0') {\n\t\t\t\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t\t(void) snprintf(snapname, sizeof (snapname),\n\t\t\t\t    \"%s@%s\", zfs_get_name(fs_zhp),\n\t\t\t\t    ssa.ssa_last);\n\t\t\t\tif (!zfs_dataset_exists(fs_zhp->zfs_hdl,\n\t\t\t\t    snapname, ZFS_TYPE_SNAPSHOT)) {\n\t\t\t\t\tret = ENOENT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = zfs_iter_snapshots_sorted_v2(fs_zhp, flags,\n\t\t\t    snapspec_cb, &ssa, 0, 0);\n\t\t\tif (ret == 0)\n\t\t\t\tret = err;\n\t\t\tif (ret == 0 && (!ssa.ssa_seenfirst ||\n\t\t\t    (ssa.ssa_last[0] != '\\0' && !ssa.ssa_seenlast))) {\n\t\t\t\tret = ENOENT;\n\t\t\t}\n\t\t} else {\n\t\t\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\tzfs_handle_t *snap_zhp;\n\t\t\t(void) snprintf(snapname, sizeof (snapname), \"%s@%s\",\n\t\t\t    zfs_get_name(fs_zhp), comma_separated);\n\t\t\tsnap_zhp = make_dataset_handle(fs_zhp->zfs_hdl,\n\t\t\t    snapname);\n\t\t\tif (snap_zhp == NULL) {\n\t\t\t\tret = ENOENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = func(snap_zhp, arg);\n\t\t\tif (ret == 0)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\tfree(buf);\n\treturn (ret);\n}\n\n \nint\nzfs_iter_children(zfs_handle_t *zhp, zfs_iter_f func, void *data)\n{\n\treturn (zfs_iter_children_v2(zhp, 0, func, data));\n}\n\nint\nzfs_iter_children_v2(zfs_handle_t *zhp, int flags, zfs_iter_f func, void *data)\n{\n\tint ret;\n\n\tif ((ret = zfs_iter_snapshots_v2(zhp, flags, func, data, 0, 0)) != 0)\n\t\treturn (ret);\n\n\treturn (zfs_iter_filesystems_v2(zhp, flags, func, data));\n}\n\n\ntypedef struct iter_stack_frame {\n\tstruct iter_stack_frame *next;\n\tzfs_handle_t *zhp;\n} iter_stack_frame_t;\n\ntypedef struct iter_dependents_arg {\n\tboolean_t first;\n\tint flags;\n\tboolean_t allowrecursion;\n\titer_stack_frame_t *stack;\n\tzfs_iter_f func;\n\tvoid *data;\n} iter_dependents_arg_t;\n\nstatic int\niter_dependents_cb(zfs_handle_t *zhp, void *arg)\n{\n\titer_dependents_arg_t *ida = arg;\n\tint err = 0;\n\tboolean_t first = ida->first;\n\tida->first = B_FALSE;\n\n\tif (zhp->zfs_type == ZFS_TYPE_SNAPSHOT) {\n\t\terr = zfs_iter_clones(zhp, ida->flags, iter_dependents_cb, ida);\n\t} else if (zhp->zfs_type != ZFS_TYPE_BOOKMARK) {\n\t\titer_stack_frame_t isf;\n\t\titer_stack_frame_t *f;\n\n\t\t \n\t\tfor (f = ida->stack; f != NULL; f = f->next) {\n\t\t\tif (f->zhp->zfs_dmustats.dds_guid ==\n\t\t\t    zhp->zfs_dmustats.dds_guid) {\n\t\t\t\tif (ida->allowrecursion) {\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\treturn (0);\n\t\t\t\t} else {\n\t\t\t\t\tzfs_error_aux(zhp->zfs_hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"recursive dependency at '%s'\"),\n\t\t\t\t\t    zfs_get_name(zhp));\n\t\t\t\t\terr = zfs_error(zhp->zfs_hdl,\n\t\t\t\t\t    EZFS_RECURSIVE,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"cannot determine dependent \"\n\t\t\t\t\t    \"datasets\"));\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\treturn (err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tisf.zhp = zhp;\n\t\tisf.next = ida->stack;\n\t\tida->stack = &isf;\n\t\terr = zfs_iter_filesystems_v2(zhp, ida->flags,\n\t\t    iter_dependents_cb, ida);\n\t\tif (err == 0)\n\t\t\terr = zfs_iter_snapshots_v2(zhp, ida->flags,\n\t\t\t    iter_dependents_cb, ida, 0, 0);\n\t\tida->stack = isf.next;\n\t}\n\n\tif (!first && err == 0)\n\t\terr = ida->func(zhp, ida->data);\n\telse\n\t\tzfs_close(zhp);\n\n\treturn (err);\n}\n\nint\nzfs_iter_dependents(zfs_handle_t *zhp, boolean_t allowrecursion,\n    zfs_iter_f func, void *data)\n{\n\treturn (zfs_iter_dependents_v2(zhp, 0, allowrecursion, func, data));\n}\n\nint\nzfs_iter_dependents_v2(zfs_handle_t *zhp, int flags, boolean_t allowrecursion,\n    zfs_iter_f func, void *data)\n{\n\titer_dependents_arg_t ida;\n\tida.flags = flags;\n\tida.allowrecursion = allowrecursion;\n\tida.stack = NULL;\n\tida.func = func;\n\tida.data = data;\n\tida.first = B_TRUE;\n\treturn (iter_dependents_cb(zfs_handle_dup(zhp), &ida));\n}\n\n \nint\nzfs_iter_mounted(zfs_handle_t *zhp, zfs_iter_f func, void *data)\n{\n\tchar mnt_prop[ZFS_MAXPROPLEN];\n\tstruct mnttab entry;\n\tzfs_handle_t *mtab_zhp;\n\tsize_t namelen = strlen(zhp->zfs_name);\n\tFILE *mnttab;\n\tint err = 0;\n\n\tif ((mnttab = fopen(MNTTAB, \"re\")) == NULL)\n\t\treturn (ENOENT);\n\n\twhile (err == 0 && getmntent(mnttab, &entry) == 0) {\n\t\t \n\t\tif (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (strncmp(entry.mnt_special, zhp->zfs_name, namelen) != 0 ||\n\t\t    entry.mnt_special[namelen] != '/')\n\t\t\tcontinue;\n\n\t\t \n\t\tif (strchr(entry.mnt_special, '@') != NULL)\n\t\t\tcontinue;\n\n\t\tif ((mtab_zhp = zfs_open(zhp->zfs_hdl, entry.mnt_special,\n\t\t    ZFS_TYPE_FILESYSTEM)) == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tverify(zfs_prop_get(mtab_zhp, ZFS_PROP_MOUNTPOINT, mnt_prop,\n\t\t    sizeof (mnt_prop), NULL, NULL, 0, B_FALSE) == 0);\n\t\tif (strcmp(mnt_prop, \"legacy\") == 0) {\n\t\t\tzfs_close(mtab_zhp);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = func(mtab_zhp, data);\n\t}\n\n\tfclose(mnttab);\n\n\treturn (err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}