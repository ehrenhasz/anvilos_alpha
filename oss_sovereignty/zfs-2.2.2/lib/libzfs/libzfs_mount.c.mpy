{
  "module_name": "libzfs_mount.c",
  "hash_id": "31bbba6aa8c76459df92a5372ee62d041542109a64a358b45ab618abbf2c953c",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_mount.c",
  "human_readable_source": " \n\n \n\n \n\n#include <dirent.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <libintl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <zone.h>\n#include <sys/mntent.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <sys/dsl_crypt.h>\n\n#include <libzfs.h>\n\n#include \"libzfs_impl.h\"\n#include <thread_pool.h>\n\n#include <libshare.h>\n#include <sys/systeminfo.h>\n#define\tMAXISALEN\t257\t \n\nstatic int mount_tp_nthr = 512;\t \n\nstatic void zfs_mount_task(void *);\n\nstatic const proto_table_t proto_table[SA_PROTOCOL_COUNT] = {\n\t[SA_PROTOCOL_NFS] =\n\t    {ZFS_PROP_SHARENFS, EZFS_SHARENFSFAILED, EZFS_UNSHARENFSFAILED},\n\t[SA_PROTOCOL_SMB] =\n\t    {ZFS_PROP_SHARESMB, EZFS_SHARESMBFAILED, EZFS_UNSHARESMBFAILED},\n};\n\nstatic const enum sa_protocol share_all_proto[SA_PROTOCOL_COUNT + 1] = {\n\tSA_PROTOCOL_NFS,\n\tSA_PROTOCOL_SMB,\n\tSA_NO_PROTOCOL\n};\n\n\n\nstatic boolean_t\ndir_is_empty_stat(const char *dirname)\n{\n\tstruct stat st;\n\n\t \n\tif (stat(dirname, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\treturn (B_TRUE);\n\t}\n\n\t \n\tif (st.st_size > 2) {\n\t\treturn (B_FALSE);\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic boolean_t\ndir_is_empty_readdir(const char *dirname)\n{\n\tDIR *dirp;\n\tstruct dirent64 *dp;\n\tint dirfd;\n\n\tif ((dirfd = openat(AT_FDCWD, dirname,\n\t    O_RDONLY | O_NDELAY | O_LARGEFILE | O_CLOEXEC, 0)) < 0) {\n\t\treturn (B_TRUE);\n\t}\n\n\tif ((dirp = fdopendir(dirfd)) == NULL) {\n\t\t(void) close(dirfd);\n\t\treturn (B_TRUE);\n\t}\n\n\twhile ((dp = readdir64(dirp)) != NULL) {\n\n\t\tif (strcmp(dp->d_name, \".\") == 0 ||\n\t\t    strcmp(dp->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t(void) closedir(dirp);\n\t\treturn (B_FALSE);\n\t}\n\n\t(void) closedir(dirp);\n\treturn (B_TRUE);\n}\n\n \nstatic boolean_t\ndir_is_empty(const char *dirname)\n{\n\tstruct statfs64 st;\n\n\t \n\tif ((statfs64(dirname, &st) != 0) ||\n\t    (st.f_type != ZFS_SUPER_MAGIC)) {\n\t\treturn (dir_is_empty_readdir(dirname));\n\t}\n\n\t \n\treturn (dir_is_empty_stat(dirname));\n}\n\n \nboolean_t\nis_mounted(libzfs_handle_t *zfs_hdl, const char *special, char **where)\n{\n\tstruct mnttab entry;\n\n\tif (libzfs_mnttab_find(zfs_hdl, special, &entry) != 0)\n\t\treturn (B_FALSE);\n\n\tif (where != NULL)\n\t\t*where = zfs_strdup(zfs_hdl, entry.mnt_mountp);\n\n\treturn (B_TRUE);\n}\n\nboolean_t\nzfs_is_mounted(zfs_handle_t *zhp, char **where)\n{\n\treturn (is_mounted(zhp->zfs_hdl, zfs_get_name(zhp), where));\n}\n\n \nstatic boolean_t\nzfs_is_mountable_internal(zfs_handle_t *zhp)\n{\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_ZONED) &&\n\t    getzoneid() == GLOBAL_ZONEID)\n\t\treturn (B_FALSE);\n\n\treturn (B_TRUE);\n}\n\n \nstatic boolean_t\nzfs_is_mountable(zfs_handle_t *zhp, char *buf, size_t buflen,\n    zprop_source_t *source, int flags)\n{\n\tchar sourceloc[MAXNAMELEN];\n\tzprop_source_t sourcetype;\n\n\tif (!zfs_prop_valid_for_type(ZFS_PROP_MOUNTPOINT, zhp->zfs_type,\n\t    B_FALSE))\n\t\treturn (B_FALSE);\n\n\tverify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, buf, buflen,\n\t    &sourcetype, sourceloc, sizeof (sourceloc), B_FALSE) == 0);\n\n\tif (strcmp(buf, ZFS_MOUNTPOINT_NONE) == 0 ||\n\t    strcmp(buf, ZFS_MOUNTPOINT_LEGACY) == 0)\n\t\treturn (B_FALSE);\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) == ZFS_CANMOUNT_OFF)\n\t\treturn (B_FALSE);\n\n\tif (!zfs_is_mountable_internal(zhp))\n\t\treturn (B_FALSE);\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_REDACTED) && !(flags & MS_FORCE))\n\t\treturn (B_FALSE);\n\n\tif (source)\n\t\t*source = sourcetype;\n\n\treturn (B_TRUE);\n}\n\n \n\nstatic int\nzfs_add_option(zfs_handle_t *zhp, char *options, int len,\n    zfs_prop_t prop, const char *on, const char *off)\n{\n\tconst char *source;\n\tuint64_t value;\n\n\t \n\tif ((strstr(options, on) != NULL) || (strstr(options, off) != NULL))\n\t\treturn (0);\n\n\t \n\tvalue = getprop_uint64(zhp, prop, &source);\n\n\t(void) strlcat(options, \",\", len);\n\t(void) strlcat(options, value ? on : off, len);\n\n\treturn (0);\n}\n\nstatic int\nzfs_add_options(zfs_handle_t *zhp, char *options, int len)\n{\n\tint error = 0;\n\n\terror = zfs_add_option(zhp, options, len,\n\t    ZFS_PROP_ATIME, MNTOPT_ATIME, MNTOPT_NOATIME);\n\t \n\tif (strstr(options, MNTOPT_NOATIME) == NULL) {\n\t\terror = zfs_add_option(zhp, options, len,\n\t\t    ZFS_PROP_RELATIME, MNTOPT_RELATIME, MNTOPT_STRICTATIME);\n\t}\n\terror = error ? error : zfs_add_option(zhp, options, len,\n\t    ZFS_PROP_DEVICES, MNTOPT_DEVICES, MNTOPT_NODEVICES);\n\terror = error ? error : zfs_add_option(zhp, options, len,\n\t    ZFS_PROP_EXEC, MNTOPT_EXEC, MNTOPT_NOEXEC);\n\terror = error ? error : zfs_add_option(zhp, options, len,\n\t    ZFS_PROP_READONLY, MNTOPT_RO, MNTOPT_RW);\n\terror = error ? error : zfs_add_option(zhp, options, len,\n\t    ZFS_PROP_SETUID, MNTOPT_SETUID, MNTOPT_NOSETUID);\n\terror = error ? error : zfs_add_option(zhp, options, len,\n\t    ZFS_PROP_NBMAND, MNTOPT_NBMAND, MNTOPT_NONBMAND);\n\n\treturn (error);\n}\n\nint\nzfs_mount(zfs_handle_t *zhp, const char *options, int flags)\n{\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\n\tif (!zfs_is_mountable(zhp, mountpoint, sizeof (mountpoint), NULL,\n\t    flags))\n\t\treturn (0);\n\n\treturn (zfs_mount_at(zhp, options, flags, mountpoint));\n}\n\n \nint\nzfs_mount_at(zfs_handle_t *zhp, const char *options, int flags,\n    const char *mountpoint)\n{\n\tstruct stat buf;\n\tchar mntopts[MNT_LINE_MAX];\n\tchar overlay[ZFS_MAXPROPLEN];\n\tchar prop_encroot[MAXNAMELEN];\n\tboolean_t is_encroot;\n\tzfs_handle_t *encroot_hp = zhp;\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tuint64_t keystatus;\n\tint remount = 0, rc;\n\n\tif (options == NULL) {\n\t\t(void) strlcpy(mntopts, MNTOPT_DEFAULTS, sizeof (mntopts));\n\t} else {\n\t\t(void) strlcpy(mntopts, options, sizeof (mntopts));\n\t}\n\n\tif (strstr(mntopts, MNTOPT_REMOUNT) != NULL)\n\t\tremount = 1;\n\n\t \n\tif (!zfs_is_mountable_internal(zhp))\n\t\treturn (0);\n\n\t \n\tif (zpool_get_prop_int(zhp->zpool_hdl, ZPOOL_PROP_READONLY, NULL))\n\t\t(void) strlcat(mntopts, \",\" MNTOPT_RO, sizeof (mntopts));\n\n\t \n\trc = zfs_add_options(zhp, mntopts, sizeof (mntopts));\n\tif (rc) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"default options unavailable\"));\n\t\treturn (zfs_error_fmt(hdl, EZFS_MOUNTFAILED,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot mount '%s'\"),\n\t\t    mountpoint));\n\t}\n\n\t \n\tif (zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) != ZIO_CRYPT_OFF) {\n\t\tzfs_refresh_properties(zhp);\n\t\tkeystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\n\t\t \n\t\tif (keystatus == ZFS_KEYSTATUS_UNAVAILABLE) {\n\t\t\tif (flags & MS_CRYPT) {\n\t\t\t\trc = zfs_crypto_get_encryption_root(zhp,\n\t\t\t\t    &is_encroot, prop_encroot);\n\t\t\t\tif (rc) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"Failed to get encryption root for \"\n\t\t\t\t\t    \"'%s'.\"), zfs_get_name(zhp));\n\t\t\t\t\treturn (rc);\n\t\t\t\t}\n\n\t\t\t\tif (!is_encroot) {\n\t\t\t\t\tencroot_hp = zfs_open(hdl, prop_encroot,\n\t\t\t\t\t    ZFS_TYPE_DATASET);\n\t\t\t\t\tif (encroot_hp == NULL)\n\t\t\t\t\t\treturn (hdl->libzfs_error);\n\t\t\t\t}\n\n\t\t\t\trc = zfs_crypto_load_key(encroot_hp,\n\t\t\t\t    B_FALSE, NULL);\n\n\t\t\t\tif (!is_encroot)\n\t\t\t\t\tzfs_close(encroot_hp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn (rc);\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"encryption key not loaded\"));\n\t\t\t\treturn (zfs_error_fmt(hdl, EZFS_MOUNTFAILED,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"cannot mount '%s'\"),\n\t\t\t\t    mountpoint));\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tstrlcat(mntopts, \",\" MNTOPT_ZFSUTIL, sizeof (mntopts));\n\n\t \n\tif (lstat(mountpoint, &buf) != 0) {\n\t\tif (mkdirp(mountpoint, 0755) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"failed to create mountpoint: %s\"),\n\t\t\t    strerror(errno));\n\t\t\treturn (zfs_error_fmt(hdl, EZFS_MOUNTFAILED,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot mount '%s'\"),\n\t\t\t    mountpoint));\n\t\t}\n\t}\n\n\t \n\tif (!(flags & MS_OVERLAY)) {\n\t\tif (zfs_prop_get(zhp, ZFS_PROP_OVERLAY, overlay,\n\t\t    sizeof (overlay), NULL, NULL, 0, B_FALSE) == 0) {\n\t\t\tif (strcmp(overlay, \"on\") == 0) {\n\t\t\t\tflags |= MS_OVERLAY;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((flags & MS_OVERLAY) == 0 && !remount &&\n\t    !dir_is_empty(mountpoint)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"directory is not empty\"));\n\t\treturn (zfs_error_fmt(hdl, EZFS_MOUNTFAILED,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot mount '%s'\"), mountpoint));\n\t}\n\n\t \n\trc = do_mount(zhp, mountpoint, mntopts, flags);\n\tif (rc) {\n\t\t \n\t\tif (rc == EBUSY) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"mountpoint or dataset is busy\"));\n\t\t} else if (rc == EPERM) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Insufficient privileges\"));\n\t\t} else if (rc == ENOTSUP) {\n\t\t\tint spa_version;\n\n\t\t\tVERIFY(zfs_spa_version(zhp, &spa_version) == 0);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Can't mount a version %llu \"\n\t\t\t    \"file system on a version %d pool. Pool must be\"\n\t\t\t    \" upgraded to mount this file system.\"),\n\t\t\t    (u_longlong_t)zfs_prop_get_int(zhp,\n\t\t\t    ZFS_PROP_VERSION), spa_version);\n\t\t} else {\n\t\t\tzfs_error_aux(hdl, \"%s\", strerror(rc));\n\t\t}\n\t\treturn (zfs_error_fmt(hdl, EZFS_MOUNTFAILED,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot mount '%s'\"),\n\t\t    zhp->zfs_name));\n\t}\n\n\t \n\tif (remount)\n\t\tlibzfs_mnttab_remove(hdl, zhp->zfs_name);\n\n\t \n\tlibzfs_mnttab_add(hdl, zfs_get_name(zhp), mountpoint, mntopts);\n\treturn (0);\n}\n\n \nstatic int\nunmount_one(zfs_handle_t *zhp, const char *mountpoint, int flags)\n{\n\tint error;\n\n\terror = do_unmount(zhp, mountpoint, flags);\n\tif (error != 0) {\n\t\tint libzfs_err;\n\n\t\tswitch (error) {\n\t\tcase EBUSY:\n\t\t\tlibzfs_err = EZFS_BUSY;\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\tlibzfs_err = EZFS_IO;\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tlibzfs_err = EZFS_NOENT;\n\t\t\tbreak;\n\t\tcase ENOMEM:\n\t\t\tlibzfs_err = EZFS_NOMEM;\n\t\t\tbreak;\n\t\tcase EPERM:\n\t\t\tlibzfs_err = EZFS_PERM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlibzfs_err = EZFS_UMOUNTFAILED;\n\t\t}\n\t\tif (zhp) {\n\t\t\treturn (zfs_error_fmt(zhp->zfs_hdl, libzfs_err,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot unmount '%s'\"),\n\t\t\t    mountpoint));\n\t\t} else {\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_unmount(zfs_handle_t *zhp, const char *mountpoint, int flags)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tstruct mnttab entry;\n\tchar *mntpt = NULL;\n\tboolean_t encroot, unmounted = B_FALSE;\n\n\t \n\tif (mountpoint != NULL || ((zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) &&\n\t    libzfs_mnttab_find(hdl, zhp->zfs_name, &entry) == 0)) {\n\t\t \n\t\tif (mountpoint == NULL)\n\t\t\tmntpt = zfs_strdup(hdl, entry.mnt_mountp);\n\t\telse\n\t\t\tmntpt = zfs_strdup(hdl, mountpoint);\n\n\t\t \n\t\tif (zfs_unshare(zhp, mntpt, share_all_proto) != 0) {\n\t\t\tfree(mntpt);\n\t\t\treturn (-1);\n\t\t}\n\t\tzfs_commit_shares(NULL);\n\n\t\tif (unmount_one(zhp, mntpt, flags) != 0) {\n\t\t\tfree(mntpt);\n\t\t\t(void) zfs_share(zhp, NULL);\n\t\t\tzfs_commit_shares(NULL);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tlibzfs_mnttab_remove(hdl, zhp->zfs_name);\n\t\tfree(mntpt);\n\t\tunmounted = B_TRUE;\n\t}\n\n\t \n\tif ((flags & MS_CRYPT) != 0 &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) != ZIO_CRYPT_OFF) {\n\t\tzfs_refresh_properties(zhp);\n\n\t\tif (zfs_crypto_get_encryption_root(zhp, &encroot, NULL) != 0 &&\n\t\t    unmounted) {\n\t\t\t(void) zfs_mount(zhp, NULL, 0);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (encroot && zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS) ==\n\t\t    ZFS_KEYSTATUS_AVAILABLE &&\n\t\t    zfs_crypto_unload_key(zhp) != 0) {\n\t\t\t(void) zfs_mount(zhp, NULL, 0);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tzpool_disable_volume_os(zhp->zfs_name);\n\n\treturn (0);\n}\n\n \nint\nzfs_unmountall(zfs_handle_t *zhp, int flags)\n{\n\tprop_changelist_t *clp;\n\tint ret;\n\n\tclp = changelist_gather(zhp, ZFS_PROP_MOUNTPOINT,\n\t    CL_GATHER_ITER_MOUNTED, flags);\n\tif (clp == NULL)\n\t\treturn (-1);\n\n\tret = changelist_prefix(clp);\n\tchangelist_free(clp);\n\n\treturn (ret);\n}\n\n \nstatic int\nunshare_one(libzfs_handle_t *hdl, const char *name, const char *mountpoint,\n    enum sa_protocol proto)\n{\n\tint err = sa_disable_share(mountpoint, proto);\n\tif (err != SA_OK)\n\t\treturn (zfs_error_fmt(hdl, proto_table[proto].p_unshare_err,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot unshare '%s': %s\"),\n\t\t    name, sa_errorstr(err)));\n\n\treturn (0);\n}\n\n \nint\nzfs_share(zfs_handle_t *zhp, const enum sa_protocol *proto)\n{\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\tchar shareopts[ZFS_MAXPROPLEN];\n\tchar sourcestr[ZFS_MAXPROPLEN];\n\tconst enum sa_protocol *curr_proto;\n\tzprop_source_t sourcetype;\n\tint err = 0;\n\n\tif (proto == NULL)\n\t\tproto = share_all_proto;\n\n\tif (!zfs_is_mountable(zhp, mountpoint, sizeof (mountpoint), NULL, 0))\n\t\treturn (0);\n\n\tfor (curr_proto = proto; *curr_proto != SA_NO_PROTOCOL; curr_proto++) {\n\t\t \n\t\tif (zfs_prop_get(zhp, proto_table[*curr_proto].p_prop,\n\t\t    shareopts, sizeof (shareopts), &sourcetype, sourcestr,\n\t\t    ZFS_MAXPROPLEN, B_FALSE) != 0 ||\n\t\t    strcmp(shareopts, \"off\") == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (zfs_prop_get_int(zhp, ZFS_PROP_ZONED))\n\t\t\tcontinue;\n\n\t\terr = sa_enable_share(zfs_get_name(zhp), mountpoint, shareopts,\n\t\t    *curr_proto);\n\t\tif (err != SA_OK) {\n\t\t\treturn (zfs_error_fmt(zhp->zfs_hdl,\n\t\t\t    proto_table[*curr_proto].p_share_err,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot share '%s: %s'\"),\n\t\t\t    zfs_get_name(zhp), sa_errorstr(err)));\n\t\t}\n\n\t}\n\treturn (0);\n}\n\n \nboolean_t\nzfs_is_shared(zfs_handle_t *zhp, char **where,\n    const enum sa_protocol *proto)\n{\n\tchar *mountpoint;\n\tif (proto == NULL)\n\t\tproto = share_all_proto;\n\n\tif (ZFS_IS_VOLUME(zhp))\n\t\treturn (B_FALSE);\n\n\tif (!zfs_is_mounted(zhp, &mountpoint))\n\t\treturn (B_FALSE);\n\n\tfor (const enum sa_protocol *p = proto; *p != SA_NO_PROTOCOL; ++p)\n\t\tif (sa_is_shared(mountpoint, *p)) {\n\t\t\tif (where != NULL)\n\t\t\t\t*where = mountpoint;\n\t\t\telse\n\t\t\t\tfree(mountpoint);\n\t\t\treturn (B_TRUE);\n\t\t}\n\n\tfree(mountpoint);\n\treturn (B_FALSE);\n}\n\nvoid\nzfs_commit_shares(const enum sa_protocol *proto)\n{\n\tif (proto == NULL)\n\t\tproto = share_all_proto;\n\n\tfor (const enum sa_protocol *p = proto; *p != SA_NO_PROTOCOL; ++p)\n\t\tsa_commit_shares(*p);\n}\n\nvoid\nzfs_truncate_shares(const enum sa_protocol *proto)\n{\n\tif (proto == NULL)\n\t\tproto = share_all_proto;\n\n\tfor (const enum sa_protocol *p = proto; *p != SA_NO_PROTOCOL; ++p)\n\t\tsa_truncate_shares(*p);\n}\n\n \nint\nzfs_unshare(zfs_handle_t *zhp, const char *mountpoint,\n    const enum sa_protocol *proto)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tstruct mnttab entry;\n\n\tif (proto == NULL)\n\t\tproto = share_all_proto;\n\n\tif (mountpoint != NULL || ((zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) &&\n\t    libzfs_mnttab_find(hdl, zfs_get_name(zhp), &entry) == 0)) {\n\n\t\t \n\t\tconst char *mntpt = mountpoint ?: entry.mnt_mountp;\n\n\t\tfor (const enum sa_protocol *curr_proto = proto;\n\t\t    *curr_proto != SA_NO_PROTOCOL; curr_proto++)\n\t\t\tif (sa_is_shared(mntpt, *curr_proto) &&\n\t\t\t    unshare_one(hdl, zhp->zfs_name,\n\t\t\t    mntpt, *curr_proto) != 0)\n\t\t\t\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_unshareall(zfs_handle_t *zhp, const enum sa_protocol *proto)\n{\n\tprop_changelist_t *clp;\n\tint ret;\n\n\tif (proto == NULL)\n\t\tproto = share_all_proto;\n\n\tclp = changelist_gather(zhp, ZFS_PROP_SHARENFS, 0, 0);\n\tif (clp == NULL)\n\t\treturn (-1);\n\n\tret = changelist_unshare(clp, proto);\n\tchangelist_free(clp);\n\n\treturn (ret);\n}\n\n \nvoid\nremove_mountpoint(zfs_handle_t *zhp)\n{\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\tzprop_source_t source;\n\n\tif (!zfs_is_mountable(zhp, mountpoint, sizeof (mountpoint),\n\t    &source, 0))\n\t\treturn;\n\n\tif (source == ZPROP_SRC_DEFAULT ||\n\t    source == ZPROP_SRC_INHERITED) {\n\t\t \n\t\t(void) rmdir(mountpoint);\n\t}\n}\n\n \nvoid\nlibzfs_add_handle(get_all_cb_t *cbp, zfs_handle_t *zhp)\n{\n\tif (cbp->cb_alloc == cbp->cb_used) {\n\t\tsize_t newsz;\n\t\tzfs_handle_t **newhandles;\n\n\t\tnewsz = cbp->cb_alloc != 0 ? cbp->cb_alloc * 2 : 64;\n\t\tnewhandles = zfs_realloc(zhp->zfs_hdl,\n\t\t    cbp->cb_handles, cbp->cb_alloc * sizeof (zfs_handle_t *),\n\t\t    newsz * sizeof (zfs_handle_t *));\n\t\tcbp->cb_handles = newhandles;\n\t\tcbp->cb_alloc = newsz;\n\t}\n\tcbp->cb_handles[cbp->cb_used++] = zhp;\n}\n\n \nstatic int\nzfs_iter_cb(zfs_handle_t *zhp, void *data)\n{\n\tget_all_cb_t *cbp = data;\n\n\tif (!(zfs_get_type(zhp) & ZFS_TYPE_FILESYSTEM)) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) == ZFS_CANMOUNT_NOAUTO) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS) ==\n\t    ZFS_KEYSTATUS_UNAVAILABLE) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\t \n\tif (zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) &&\n\t    zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN,\n\t    NULL, 0, NULL, NULL, 0, B_TRUE) == 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tlibzfs_add_handle(cbp, zhp);\n\tif (zfs_iter_filesystems_v2(zhp, 0, zfs_iter_cb, cbp) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nmountpoint_cmp(const void *arga, const void *argb)\n{\n\tzfs_handle_t *const *zap = arga;\n\tzfs_handle_t *za = *zap;\n\tzfs_handle_t *const *zbp = argb;\n\tzfs_handle_t *zb = *zbp;\n\tchar mounta[MAXPATHLEN];\n\tchar mountb[MAXPATHLEN];\n\tconst char *a = mounta;\n\tconst char *b = mountb;\n\tboolean_t gota, gotb;\n\tuint64_t zoneda, zonedb;\n\n\tzoneda = zfs_prop_get_int(za, ZFS_PROP_ZONED);\n\tzonedb = zfs_prop_get_int(zb, ZFS_PROP_ZONED);\n\tif (zoneda && !zonedb)\n\t\treturn (1);\n\tif (!zoneda && zonedb)\n\t\treturn (-1);\n\n\tgota = (zfs_get_type(za) == ZFS_TYPE_FILESYSTEM);\n\tif (gota) {\n\t\tverify(zfs_prop_get(za, ZFS_PROP_MOUNTPOINT, mounta,\n\t\t    sizeof (mounta), NULL, NULL, 0, B_FALSE) == 0);\n\t}\n\tgotb = (zfs_get_type(zb) == ZFS_TYPE_FILESYSTEM);\n\tif (gotb) {\n\t\tverify(zfs_prop_get(zb, ZFS_PROP_MOUNTPOINT, mountb,\n\t\t    sizeof (mountb), NULL, NULL, 0, B_FALSE) == 0);\n\t}\n\n\tif (gota && gotb) {\n\t\twhile (*a != '\\0' && (*a == *b)) {\n\t\t\ta++;\n\t\t\tb++;\n\t\t}\n\t\tif (*a == *b)\n\t\t\treturn (0);\n\t\tif (*a == '\\0')\n\t\t\treturn (-1);\n\t\tif (*b == '\\0')\n\t\t\treturn (1);\n\t\tif (*a == '/')\n\t\t\treturn (-1);\n\t\tif (*b == '/')\n\t\t\treturn (1);\n\t\treturn (*a < *b ? -1 : *a > *b);\n\t}\n\n\tif (gota)\n\t\treturn (-1);\n\tif (gotb)\n\t\treturn (1);\n\n\t \n\treturn (strcmp(zfs_get_name(za), zfs_get_name(zb)));\n}\n\n \nstatic boolean_t\nlibzfs_path_contains(const char *path1, const char *path2)\n{\n\treturn (strcmp(path1, path2) == 0 || strcmp(path1, \"/\") == 0 ||\n\t    (strstr(path2, path1) == path2 && path2[strlen(path1)] == '/'));\n}\n\n \nstatic int\nnon_descendant_idx(zfs_handle_t **handles, size_t num_handles, int idx)\n{\n\tchar parent[ZFS_MAXPROPLEN];\n\tchar child[ZFS_MAXPROPLEN];\n\tint i;\n\n\tverify(zfs_prop_get(handles[idx], ZFS_PROP_MOUNTPOINT, parent,\n\t    sizeof (parent), NULL, NULL, 0, B_FALSE) == 0);\n\n\tfor (i = idx + 1; i < num_handles; i++) {\n\t\tverify(zfs_prop_get(handles[i], ZFS_PROP_MOUNTPOINT, child,\n\t\t    sizeof (child), NULL, NULL, 0, B_FALSE) == 0);\n\t\tif (!libzfs_path_contains(parent, child))\n\t\t\tbreak;\n\t}\n\treturn (i);\n}\n\ntypedef struct mnt_param {\n\tlibzfs_handle_t\t*mnt_hdl;\n\ttpool_t\t\t*mnt_tp;\n\tzfs_handle_t\t**mnt_zhps;  \n\tsize_t\t\tmnt_num_handles;\n\tint\t\tmnt_idx;\t \n\tzfs_iter_f\tmnt_func;\n\tvoid\t\t*mnt_data;\n} mnt_param_t;\n\n \nstatic void\nzfs_dispatch_mount(libzfs_handle_t *hdl, zfs_handle_t **handles,\n    size_t num_handles, int idx, zfs_iter_f func, void *data, tpool_t *tp)\n{\n\tmnt_param_t *mnt_param = zfs_alloc(hdl, sizeof (mnt_param_t));\n\n\tmnt_param->mnt_hdl = hdl;\n\tmnt_param->mnt_tp = tp;\n\tmnt_param->mnt_zhps = handles;\n\tmnt_param->mnt_num_handles = num_handles;\n\tmnt_param->mnt_idx = idx;\n\tmnt_param->mnt_func = func;\n\tmnt_param->mnt_data = data;\n\n\t(void) tpool_dispatch(tp, zfs_mount_task, (void*)mnt_param);\n}\n\n \ntypedef struct mount_state {\n\t \n\tint\t\tms_mntstatus;\n\tint\t\tms_mntflags;\n\tconst char\t*ms_mntopts;\n} mount_state_t;\n\nstatic int\nzfs_mount_one(zfs_handle_t *zhp, void *arg)\n{\n\tmount_state_t *ms = arg;\n\tint ret = 0;\n\n\t \n\tif (zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS) ==\n\t    ZFS_KEYSTATUS_UNAVAILABLE)\n\t\treturn (0);\n\n\tif (zfs_mount(zhp, ms->ms_mntopts, ms->ms_mntflags) != 0)\n\t\tret = ms->ms_mntstatus = -1;\n\treturn (ret);\n}\n\nstatic int\nzfs_share_one(zfs_handle_t *zhp, void *arg)\n{\n\tmount_state_t *ms = arg;\n\tint ret = 0;\n\n\tif (zfs_share(zhp, NULL) != 0)\n\t\tret = ms->ms_mntstatus = -1;\n\treturn (ret);\n}\n\n \nstatic void\nzfs_mount_task(void *arg)\n{\n\tmnt_param_t *mp = arg;\n\tint idx = mp->mnt_idx;\n\tzfs_handle_t **handles = mp->mnt_zhps;\n\tsize_t num_handles = mp->mnt_num_handles;\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\n\tverify(zfs_prop_get(handles[idx], ZFS_PROP_MOUNTPOINT, mountpoint,\n\t    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) == 0);\n\n\tif (mp->mnt_func(handles[idx], mp->mnt_data) != 0)\n\t\tgoto out;\n\n\t \n\tfor (int i = idx + 1; i < num_handles;\n\t    i = non_descendant_idx(handles, num_handles, i)) {\n\t\tchar child[ZFS_MAXPROPLEN];\n\t\tverify(zfs_prop_get(handles[i], ZFS_PROP_MOUNTPOINT,\n\t\t    child, sizeof (child), NULL, NULL, 0, B_FALSE) == 0);\n\n\t\tif (!libzfs_path_contains(mountpoint, child))\n\t\t\tbreak;  \n\t\tzfs_dispatch_mount(mp->mnt_hdl, handles, num_handles, i,\n\t\t    mp->mnt_func, mp->mnt_data, mp->mnt_tp);\n\t}\n\nout:\n\tfree(mp);\n}\n\n \nvoid\nzfs_foreach_mountpoint(libzfs_handle_t *hdl, zfs_handle_t **handles,\n    size_t num_handles, zfs_iter_f func, void *data, boolean_t parallel)\n{\n\tzoneid_t zoneid = getzoneid();\n\n\t \n\tboolean_t serial_mount = !parallel ||\n\t    (getenv(\"ZFS_SERIAL_MOUNT\") != NULL);\n\n\t \n\tqsort(handles, num_handles, sizeof (zfs_handle_t *), mountpoint_cmp);\n\n\tif (serial_mount) {\n\t\tfor (int i = 0; i < num_handles; i++) {\n\t\t\tfunc(handles[i], data);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\ttpool_t *tp = tpool_create(1, mount_tp_nthr, 0, NULL);\n\n\t \n\tfor (int i = 0; i < num_handles;\n\t    i = non_descendant_idx(handles, num_handles, i)) {\n\t\t \n\t\tif (zoneid == GLOBAL_ZONEID &&\n\t\t    zfs_prop_get_int(handles[i], ZFS_PROP_ZONED))\n\t\t\tbreak;\n\t\tzfs_dispatch_mount(hdl, handles, num_handles, i, func, data,\n\t\t    tp);\n\t}\n\n\ttpool_wait(tp);\t \n\ttpool_destroy(tp);\n}\n\n \nint\nzpool_enable_datasets(zpool_handle_t *zhp, const char *mntopts, int flags)\n{\n\tget_all_cb_t cb = { 0 };\n\tmount_state_t ms = { 0 };\n\tzfs_handle_t *zfsp;\n\tint ret = 0;\n\n\tif ((zfsp = zfs_open(zhp->zpool_hdl, zhp->zpool_name,\n\t    ZFS_TYPE_DATASET)) == NULL)\n\t\tgoto out;\n\n\t \n\tlibzfs_add_handle(&cb, zfsp);\n\tif (zfs_iter_filesystems_v2(zfsp, 0, zfs_iter_cb, &cb) != 0)\n\t\tgoto out;\n\n\t \n\tms.ms_mntopts = mntopts;\n\tms.ms_mntflags = flags;\n\tzfs_foreach_mountpoint(zhp->zpool_hdl, cb.cb_handles, cb.cb_used,\n\t    zfs_mount_one, &ms, B_TRUE);\n\tif (ms.ms_mntstatus != 0)\n\t\tret = EZFS_MOUNTFAILED;\n\n\t \n\tms.ms_mntstatus = 0;\n\tzfs_foreach_mountpoint(zhp->zpool_hdl, cb.cb_handles, cb.cb_used,\n\t    zfs_share_one, &ms, B_FALSE);\n\tif (ms.ms_mntstatus != 0)\n\t\tret = EZFS_SHAREFAILED;\n\telse\n\t\tzfs_commit_shares(NULL);\n\nout:\n\tfor (int i = 0; i < cb.cb_used; i++)\n\t\tzfs_close(cb.cb_handles[i]);\n\tfree(cb.cb_handles);\n\n\treturn (ret);\n}\n\nstruct sets_s {\n\tchar *mountpoint;\n\tzfs_handle_t *dataset;\n};\n\nstatic int\nmountpoint_compare(const void *a, const void *b)\n{\n\tconst struct sets_s *mounta = (struct sets_s *)a;\n\tconst struct sets_s *mountb = (struct sets_s *)b;\n\n\treturn (strcmp(mountb->mountpoint, mounta->mountpoint));\n}\n\n \nint\nzpool_disable_datasets(zpool_handle_t *zhp, boolean_t force)\n{\n\tint used, alloc;\n\tFILE *mnttab;\n\tstruct mnttab entry;\n\tsize_t namelen;\n\tstruct sets_s *sets = NULL;\n\tlibzfs_handle_t *hdl = zhp->zpool_hdl;\n\tint i;\n\tint ret = -1;\n\tint flags = (force ? MS_FORCE : 0);\n\n\tnamelen = strlen(zhp->zpool_name);\n\n\tif ((mnttab = fopen(MNTTAB, \"re\")) == NULL)\n\t\treturn (ENOENT);\n\n\tused = alloc = 0;\n\twhile (getmntent(mnttab, &entry) == 0) {\n\t\t \n\t\tif (entry.mnt_fstype == NULL ||\n\t\t    strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (entry.mnt_mountp == NULL ||\n\t\t    strncmp(entry.mnt_special, zhp->zpool_name, namelen) != 0 ||\n\t\t    (entry.mnt_special[namelen] != '/' &&\n\t\t    entry.mnt_special[namelen] != '\\0'))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (used == alloc) {\n\t\t\tif (alloc == 0) {\n\t\t\t\tsets = zfs_alloc(hdl,\n\t\t\t\t    8 * sizeof (struct sets_s));\n\t\t\t\talloc = 8;\n\t\t\t} else {\n\t\t\t\tsets = zfs_realloc(hdl, sets,\n\t\t\t\t    alloc * sizeof (struct sets_s),\n\t\t\t\t    alloc * 2 * sizeof (struct sets_s));\n\n\t\t\t\talloc *= 2;\n\t\t\t}\n\t\t}\n\n\t\tsets[used].mountpoint = zfs_strdup(hdl, entry.mnt_mountp);\n\n\t\t \n\t\tsets[used].dataset = make_dataset_handle(hdl,\n\t\t    entry.mnt_special);\n\n\t\tused++;\n\t}\n\n\t \n\tif (used != 0)\n\t\tqsort(sets, used, sizeof (struct sets_s), mountpoint_compare);\n\n\t \n\tfor (i = 0; i < used; i++) {\n\t\tfor (enum sa_protocol p = 0; p < SA_PROTOCOL_COUNT; ++p) {\n\t\t\tif (sa_is_shared(sets[i].mountpoint, p) &&\n\t\t\t    unshare_one(hdl, sets[i].mountpoint,\n\t\t\t    sets[i].mountpoint, p) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tzfs_commit_shares(NULL);\n\n\t \n\tfor (i = 0; i < used; i++) {\n\t\tif (unmount_one(sets[i].dataset, sets[i].mountpoint,\n\t\t    flags) != 0)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < used; i++) {\n\t\tif (sets[i].dataset)\n\t\t\tremove_mountpoint(sets[i].dataset);\n\t}\n\n\tzpool_disable_datasets_os(zhp, force);\n\n\tret = 0;\nout:\n\t(void) fclose(mnttab);\n\tfor (i = 0; i < used; i++) {\n\t\tif (sets[i].dataset)\n\t\t\tzfs_close(sets[i].dataset);\n\t\tfree(sets[i].mountpoint);\n\t}\n\tfree(sets);\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}