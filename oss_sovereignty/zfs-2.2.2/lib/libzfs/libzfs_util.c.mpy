{
  "module_name": "libzfs_util.c",
  "hash_id": "0f987c7815a19e759b2355f4ae275c454d383e7a7a9fd71f48bde1743ba0baa7",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_util.c",
  "human_readable_source": " \n\n \n\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <libintl.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <unistd.h>\n#include <math.h>\n#if LIBFETCH_DYNAMIC\n#include <dlfcn.h>\n#endif\n#include <sys/stat.h>\n#include <sys/mnttab.h>\n#include <sys/mntent.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <libzfs.h>\n#include <libzfs_core.h>\n\n#include \"libzfs_impl.h\"\n#include \"zfs_prop.h\"\n#include \"zfeature_common.h\"\n#include <zfs_fletcher.h>\n#include <libzutil.h>\n\n \n#define\tURI_REGEX\t\"^\\\\([A-Za-z][A-Za-z0-9+.\\\\-]*\\\\):\"\n\nint\nlibzfs_errno(libzfs_handle_t *hdl)\n{\n\treturn (hdl->libzfs_error);\n}\n\nconst char *\nlibzfs_error_action(libzfs_handle_t *hdl)\n{\n\treturn (hdl->libzfs_action);\n}\n\nconst char *\nlibzfs_error_description(libzfs_handle_t *hdl)\n{\n\tif (hdl->libzfs_desc[0] != '\\0')\n\t\treturn (hdl->libzfs_desc);\n\n\tswitch (hdl->libzfs_error) {\n\tcase EZFS_NOMEM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"out of memory\"));\n\tcase EZFS_BADPROP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid property value\"));\n\tcase EZFS_PROPREADONLY:\n\t\treturn (dgettext(TEXT_DOMAIN, \"read-only property\"));\n\tcase EZFS_PROPTYPE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"property doesn't apply to \"\n\t\t    \"datasets of this type\"));\n\tcase EZFS_PROPNONINHERIT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"property cannot be inherited\"));\n\tcase EZFS_PROPSPACE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid quota or reservation\"));\n\tcase EZFS_BADTYPE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation not applicable to \"\n\t\t    \"datasets of this type\"));\n\tcase EZFS_BUSY:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool or dataset is busy\"));\n\tcase EZFS_EXISTS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool or dataset exists\"));\n\tcase EZFS_NOENT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"no such pool or dataset\"));\n\tcase EZFS_BADSTREAM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid backup stream\"));\n\tcase EZFS_DSREADONLY:\n\t\treturn (dgettext(TEXT_DOMAIN, \"dataset is read-only\"));\n\tcase EZFS_VOLTOOBIG:\n\t\treturn (dgettext(TEXT_DOMAIN, \"volume size exceeds limit for \"\n\t\t    \"this system\"));\n\tcase EZFS_INVALIDNAME:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid name\"));\n\tcase EZFS_BADRESTORE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"unable to restore to \"\n\t\t    \"destination\"));\n\tcase EZFS_BADBACKUP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"backup failed\"));\n\tcase EZFS_BADTARGET:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid target vdev\"));\n\tcase EZFS_NODEVICE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"no such device in pool\"));\n\tcase EZFS_BADDEV:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid device\"));\n\tcase EZFS_NOREPLICAS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"no valid replicas\"));\n\tcase EZFS_RESILVERING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently resilvering\"));\n\tcase EZFS_BADVERSION:\n\t\treturn (dgettext(TEXT_DOMAIN, \"unsupported version or \"\n\t\t    \"feature\"));\n\tcase EZFS_POOLUNAVAIL:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool is unavailable\"));\n\tcase EZFS_DEVOVERFLOW:\n\t\treturn (dgettext(TEXT_DOMAIN, \"too many devices in one vdev\"));\n\tcase EZFS_BADPATH:\n\t\treturn (dgettext(TEXT_DOMAIN, \"must be an absolute path\"));\n\tcase EZFS_CROSSTARGET:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation crosses datasets or \"\n\t\t    \"pools\"));\n\tcase EZFS_ZONED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"dataset in use by local zone\"));\n\tcase EZFS_MOUNTFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"mount failed\"));\n\tcase EZFS_UMOUNTFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"unmount failed\"));\n\tcase EZFS_UNSHARENFSFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"NFS share removal failed\"));\n\tcase EZFS_SHARENFSFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"NFS share creation failed\"));\n\tcase EZFS_UNSHARESMBFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"SMB share removal failed\"));\n\tcase EZFS_SHARESMBFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"SMB share creation failed\"));\n\tcase EZFS_PERM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"permission denied\"));\n\tcase EZFS_NOSPC:\n\t\treturn (dgettext(TEXT_DOMAIN, \"out of space\"));\n\tcase EZFS_FAULT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"bad address\"));\n\tcase EZFS_IO:\n\t\treturn (dgettext(TEXT_DOMAIN, \"I/O error\"));\n\tcase EZFS_INTR:\n\t\treturn (dgettext(TEXT_DOMAIN, \"signal received\"));\n\tcase EZFS_CKSUM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"insufficient replicas\"));\n\tcase EZFS_ISSPARE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"device is reserved as a hot \"\n\t\t    \"spare\"));\n\tcase EZFS_INVALCONFIG:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid vdev configuration\"));\n\tcase EZFS_RECURSIVE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"recursive dataset dependency\"));\n\tcase EZFS_NOHISTORY:\n\t\treturn (dgettext(TEXT_DOMAIN, \"no history available\"));\n\tcase EZFS_POOLPROPS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"failed to retrieve \"\n\t\t    \"pool properties\"));\n\tcase EZFS_POOL_NOTSUP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation not supported \"\n\t\t    \"on this type of pool\"));\n\tcase EZFS_POOL_INVALARG:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid argument for \"\n\t\t    \"this pool operation\"));\n\tcase EZFS_NAMETOOLONG:\n\t\treturn (dgettext(TEXT_DOMAIN, \"dataset name is too long\"));\n\tcase EZFS_OPENFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"open failed\"));\n\tcase EZFS_NOCAP:\n\t\treturn (dgettext(TEXT_DOMAIN,\n\t\t    \"disk capacity information could not be retrieved\"));\n\tcase EZFS_LABELFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"write of label failed\"));\n\tcase EZFS_BADWHO:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid user/group\"));\n\tcase EZFS_BADPERM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid permission\"));\n\tcase EZFS_BADPERMSET:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid permission set name\"));\n\tcase EZFS_NODELEGATION:\n\t\treturn (dgettext(TEXT_DOMAIN, \"delegated administration is \"\n\t\t    \"disabled on pool\"));\n\tcase EZFS_BADCACHE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid or missing cache file\"));\n\tcase EZFS_ISL2CACHE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"device is in use as a cache\"));\n\tcase EZFS_VDEVNOTSUP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"vdev specification is not \"\n\t\t    \"supported\"));\n\tcase EZFS_NOTSUP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation not supported \"\n\t\t    \"on this dataset\"));\n\tcase EZFS_IOC_NOTSUPPORTED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation not supported by \"\n\t\t    \"zfs kernel module\"));\n\tcase EZFS_ACTIVE_SPARE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool has active shared spare \"\n\t\t    \"device\"));\n\tcase EZFS_UNPLAYED_LOGS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"log device has unplayed intent \"\n\t\t    \"logs\"));\n\tcase EZFS_REFTAG_RELE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"no such tag on this dataset\"));\n\tcase EZFS_REFTAG_HOLD:\n\t\treturn (dgettext(TEXT_DOMAIN, \"tag already exists on this \"\n\t\t    \"dataset\"));\n\tcase EZFS_TAGTOOLONG:\n\t\treturn (dgettext(TEXT_DOMAIN, \"tag too long\"));\n\tcase EZFS_PIPEFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pipe create failed\"));\n\tcase EZFS_THREADCREATEFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"thread create failed\"));\n\tcase EZFS_POSTSPLIT_ONLINE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"disk was split from this pool \"\n\t\t    \"into a new one\"));\n\tcase EZFS_SCRUB_PAUSED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"scrub is paused; \"\n\t\t    \"use 'zpool scrub' to resume scrub\"));\n\tcase EZFS_SCRUB_PAUSED_TO_CANCEL:\n\t\treturn (dgettext(TEXT_DOMAIN, \"scrub is paused; \"\n\t\t    \"use 'zpool scrub' to resume or 'zpool scrub -s' to \"\n\t\t    \"cancel scrub\"));\n\tcase EZFS_SCRUBBING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently scrubbing; \"\n\t\t    \"use 'zpool scrub -s' to cancel scrub\"));\n\tcase EZFS_ERRORSCRUBBING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently error scrubbing; \"\n\t\t    \"use 'zpool scrub -s' to cancel error scrub\"));\n\tcase EZFS_ERRORSCRUB_PAUSED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"error scrub is paused; \"\n\t\t    \"use 'zpool scrub -e' to resume error scrub\"));\n\tcase EZFS_NO_SCRUB:\n\t\treturn (dgettext(TEXT_DOMAIN, \"there is no active scrub\"));\n\tcase EZFS_DIFF:\n\t\treturn (dgettext(TEXT_DOMAIN, \"unable to generate diffs\"));\n\tcase EZFS_DIFFDATA:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid diff data\"));\n\tcase EZFS_POOLREADONLY:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool is read-only\"));\n\tcase EZFS_NO_PENDING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation is not \"\n\t\t    \"in progress\"));\n\tcase EZFS_CHECKPOINT_EXISTS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"checkpoint exists\"));\n\tcase EZFS_DISCARDING_CHECKPOINT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently discarding \"\n\t\t    \"checkpoint\"));\n\tcase EZFS_NO_CHECKPOINT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"checkpoint does not exist\"));\n\tcase EZFS_DEVRM_IN_PROGRESS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"device removal in progress\"));\n\tcase EZFS_VDEV_TOO_BIG:\n\t\treturn (dgettext(TEXT_DOMAIN, \"device exceeds supported size\"));\n\tcase EZFS_ACTIVE_POOL:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool is imported on a \"\n\t\t    \"different host\"));\n\tcase EZFS_CRYPTOFAILED:\n\t\treturn (dgettext(TEXT_DOMAIN, \"encryption failure\"));\n\tcase EZFS_TOOMANY:\n\t\treturn (dgettext(TEXT_DOMAIN, \"argument list too long\"));\n\tcase EZFS_INITIALIZING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently initializing\"));\n\tcase EZFS_NO_INITIALIZE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"there is no active \"\n\t\t    \"initialization\"));\n\tcase EZFS_WRONG_PARENT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid parent dataset\"));\n\tcase EZFS_TRIMMING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently trimming\"));\n\tcase EZFS_NO_TRIM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"there is no active trim\"));\n\tcase EZFS_TRIM_NOTSUP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"trim operations are not \"\n\t\t    \"supported by this device\"));\n\tcase EZFS_NO_RESILVER_DEFER:\n\t\treturn (dgettext(TEXT_DOMAIN, \"this action requires the \"\n\t\t    \"resilver_defer feature\"));\n\tcase EZFS_EXPORT_IN_PROGRESS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool export in progress\"));\n\tcase EZFS_REBUILDING:\n\t\treturn (dgettext(TEXT_DOMAIN, \"currently sequentially \"\n\t\t    \"resilvering\"));\n\tcase EZFS_VDEV_NOTSUP:\n\t\treturn (dgettext(TEXT_DOMAIN, \"operation not supported \"\n\t\t    \"on this type of vdev\"));\n\tcase EZFS_NOT_USER_NAMESPACE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"the provided file \"\n\t\t    \"was not a user namespace file\"));\n\tcase EZFS_RESUME_EXISTS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Resuming recv on existing \"\n\t\t    \"dataset without force\"));\n\tcase EZFS_UNKNOWN:\n\t\treturn (dgettext(TEXT_DOMAIN, \"unknown error\"));\n\tdefault:\n\t\tassert(hdl->libzfs_error == 0);\n\t\treturn (dgettext(TEXT_DOMAIN, \"no error\"));\n\t}\n}\n\nvoid\nzfs_error_aux(libzfs_handle_t *hdl, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\t(void) vsnprintf(hdl->libzfs_desc, sizeof (hdl->libzfs_desc),\n\t    fmt, ap);\n\thdl->libzfs_desc_active = 1;\n\n\tva_end(ap);\n}\n\nstatic void\nzfs_verror(libzfs_handle_t *hdl, int error, const char *fmt, va_list ap)\n{\n\t(void) vsnprintf(hdl->libzfs_action, sizeof (hdl->libzfs_action),\n\t    fmt, ap);\n\thdl->libzfs_error = error;\n\n\tif (hdl->libzfs_desc_active)\n\t\thdl->libzfs_desc_active = 0;\n\telse\n\t\thdl->libzfs_desc[0] = '\\0';\n\n\tif (hdl->libzfs_printerr) {\n\t\tif (error == EZFS_UNKNOWN) {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN, \"internal \"\n\t\t\t    \"error: %s: %s\\n\"), hdl->libzfs_action,\n\t\t\t    libzfs_error_description(hdl));\n\t\t\tabort();\n\t\t}\n\n\t\t(void) fprintf(stderr, \"%s: %s\\n\", hdl->libzfs_action,\n\t\t    libzfs_error_description(hdl));\n\t\tif (error == EZFS_NOMEM)\n\t\t\texit(1);\n\t}\n}\n\nint\nzfs_error(libzfs_handle_t *hdl, int error, const char *msg)\n{\n\treturn (zfs_error_fmt(hdl, error, \"%s\", msg));\n}\n\nint\nzfs_error_fmt(libzfs_handle_t *hdl, int error, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\tzfs_verror(hdl, error, fmt, ap);\n\n\tva_end(ap);\n\n\treturn (-1);\n}\n\nstatic int\nzfs_common_error(libzfs_handle_t *hdl, int error, const char *fmt,\n    va_list ap)\n{\n\tswitch (error) {\n\tcase EPERM:\n\tcase EACCES:\n\t\tzfs_verror(hdl, EZFS_PERM, fmt, ap);\n\t\treturn (-1);\n\n\tcase ECANCELED:\n\t\tzfs_verror(hdl, EZFS_NODELEGATION, fmt, ap);\n\t\treturn (-1);\n\n\tcase EIO:\n\t\tzfs_verror(hdl, EZFS_IO, fmt, ap);\n\t\treturn (-1);\n\n\tcase EFAULT:\n\t\tzfs_verror(hdl, EZFS_FAULT, fmt, ap);\n\t\treturn (-1);\n\n\tcase EINTR:\n\t\tzfs_verror(hdl, EZFS_INTR, fmt, ap);\n\t\treturn (-1);\n\n\tcase ECKSUM:\n\t\tzfs_verror(hdl, EZFS_CKSUM, fmt, ap);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nint\nzfs_standard_error(libzfs_handle_t *hdl, int error, const char *msg)\n{\n\treturn (zfs_standard_error_fmt(hdl, error, \"%s\", msg));\n}\n\nint\nzfs_standard_error_fmt(libzfs_handle_t *hdl, int error, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\tif (zfs_common_error(hdl, error, fmt, ap) != 0) {\n\t\tva_end(ap);\n\t\treturn (-1);\n\t}\n\n\tswitch (error) {\n\tcase ENXIO:\n\tcase ENODEV:\n\tcase EPIPE:\n\t\tzfs_verror(hdl, EZFS_IO, fmt, ap);\n\t\tbreak;\n\n\tcase ENOENT:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dataset does not exist\"));\n\t\tzfs_verror(hdl, EZFS_NOENT, fmt, ap);\n\t\tbreak;\n\n\tcase ENOSPC:\n\tcase EDQUOT:\n\t\tzfs_verror(hdl, EZFS_NOSPC, fmt, ap);\n\t\tbreak;\n\n\tcase EEXIST:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dataset already exists\"));\n\t\tzfs_verror(hdl, EZFS_EXISTS, fmt, ap);\n\t\tbreak;\n\n\tcase EBUSY:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dataset is busy\"));\n\t\tzfs_verror(hdl, EZFS_BUSY, fmt, ap);\n\t\tbreak;\n\tcase EROFS:\n\t\tzfs_verror(hdl, EZFS_POOLREADONLY, fmt, ap);\n\t\tbreak;\n\tcase ENAMETOOLONG:\n\t\tzfs_verror(hdl, EZFS_NAMETOOLONG, fmt, ap);\n\t\tbreak;\n\tcase ENOTSUP:\n\t\tzfs_verror(hdl, EZFS_BADVERSION, fmt, ap);\n\t\tbreak;\n\tcase EAGAIN:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"pool I/O is currently suspended\"));\n\t\tzfs_verror(hdl, EZFS_POOLUNAVAIL, fmt, ap);\n\t\tbreak;\n\tcase EREMOTEIO:\n\t\tzfs_verror(hdl, EZFS_ACTIVE_POOL, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_UNKNOWN_SEND_STREAM_FEATURE:\n\tcase ZFS_ERR_IOC_CMD_UNAVAIL:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"the loaded zfs \"\n\t\t    \"module does not support this operation. A reboot may \"\n\t\t    \"be required to enable this operation.\"));\n\t\tzfs_verror(hdl, EZFS_IOC_NOTSUPPORTED, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_IOC_ARG_UNAVAIL:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"the loaded zfs \"\n\t\t    \"module does not support an option for this operation. \"\n\t\t    \"A reboot may be required to enable this option.\"));\n\t\tzfs_verror(hdl, EZFS_IOC_NOTSUPPORTED, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_IOC_ARG_REQUIRED:\n\tcase ZFS_ERR_IOC_ARG_BADTYPE:\n\t\tzfs_verror(hdl, EZFS_IOC_NOTSUPPORTED, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_WRONG_PARENT:\n\t\tzfs_verror(hdl, EZFS_WRONG_PARENT, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_BADPROP:\n\t\tzfs_verror(hdl, EZFS_BADPROP, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_NOT_USER_NAMESPACE:\n\t\tzfs_verror(hdl, EZFS_NOT_USER_NAMESPACE, fmt, ap);\n\t\tbreak;\n\tdefault:\n\t\tzfs_error_aux(hdl, \"%s\", strerror(error));\n\t\tzfs_verror(hdl, EZFS_UNKNOWN, fmt, ap);\n\t\tbreak;\n\t}\n\n\tva_end(ap);\n\treturn (-1);\n}\n\nvoid\nzfs_setprop_error(libzfs_handle_t *hdl, zfs_prop_t prop, int err,\n    char *errbuf)\n{\n\tswitch (err) {\n\n\tcase ENOSPC:\n\t\t \n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_QUOTA:\n\t\tcase ZFS_PROP_REFQUOTA:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"size is less than current used or \"\n\t\t\t    \"reserved space\"));\n\t\t\t(void) zfs_error(hdl, EZFS_PROPSPACE, errbuf);\n\t\t\tbreak;\n\n\t\tcase ZFS_PROP_RESERVATION:\n\t\tcase ZFS_PROP_REFRESERVATION:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"size is greater than available space\"));\n\t\t\t(void) zfs_error(hdl, EZFS_PROPSPACE, errbuf);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl, err, errbuf);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EBUSY:\n\t\t(void) zfs_standard_error(hdl, EBUSY, errbuf);\n\t\tbreak;\n\n\tcase EROFS:\n\t\t(void) zfs_error(hdl, EZFS_DSREADONLY, errbuf);\n\t\tbreak;\n\n\tcase E2BIG:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"property value too long\"));\n\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\tbreak;\n\n\tcase ENOTSUP:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"pool and or dataset must be upgraded to set this \"\n\t\t    \"property or value\"));\n\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\tbreak;\n\n\tcase ERANGE:\n\t\tif (prop == ZFS_PROP_COMPRESSION ||\n\t\t    prop == ZFS_PROP_DNODESIZE ||\n\t\t    prop == ZFS_PROP_RECORDSIZE) {\n\t\t\t(void) zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property setting is not allowed on \"\n\t\t\t    \"bootable datasets\"));\n\t\t\t(void) zfs_error(hdl, EZFS_NOTSUP, errbuf);\n\t\t} else if (prop == ZFS_PROP_CHECKSUM ||\n\t\t    prop == ZFS_PROP_DEDUP) {\n\t\t\t(void) zfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property setting is not allowed on \"\n\t\t\t    \"root pools\"));\n\t\t\t(void) zfs_error(hdl, EZFS_NOTSUP, errbuf);\n\t\t} else {\n\t\t\t(void) zfs_standard_error(hdl, err, errbuf);\n\t\t}\n\t\tbreak;\n\n\tcase EINVAL:\n\t\tif (prop == ZPROP_INVAL) {\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t} else {\n\t\t\t(void) zfs_standard_error(hdl, err, errbuf);\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_ERR_BADPROP:\n\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\tbreak;\n\n\tcase EACCES:\n\t\tif (prop == ZFS_PROP_KEYLOCATION) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"keylocation may only be set on encryption roots\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t} else {\n\t\t\t(void) zfs_standard_error(hdl, err, errbuf);\n\t\t}\n\t\tbreak;\n\n\tcase EOVERFLOW:\n\t\t \n#ifdef _ILP32\n\t\tif (prop == ZFS_PROP_VOLSIZE) {\n\t\t\t(void) zfs_error(hdl, EZFS_VOLTOOBIG, errbuf);\n\t\t\tbreak;\n\t\t}\n\t\tzfs_fallthrough;\n#endif\n\tdefault:\n\t\t(void) zfs_standard_error(hdl, err, errbuf);\n\t}\n}\n\nint\nzpool_standard_error(libzfs_handle_t *hdl, int error, const char *msg)\n{\n\treturn (zpool_standard_error_fmt(hdl, error, \"%s\", msg));\n}\n\nint\nzpool_standard_error_fmt(libzfs_handle_t *hdl, int error, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\tif (zfs_common_error(hdl, error, fmt, ap) != 0) {\n\t\tva_end(ap);\n\t\treturn (-1);\n\t}\n\n\tswitch (error) {\n\tcase ENODEV:\n\t\tzfs_verror(hdl, EZFS_NODEVICE, fmt, ap);\n\t\tbreak;\n\n\tcase ENOENT:\n\t\tzfs_error_aux(hdl,\n\t\t    dgettext(TEXT_DOMAIN, \"no such pool or dataset\"));\n\t\tzfs_verror(hdl, EZFS_NOENT, fmt, ap);\n\t\tbreak;\n\n\tcase EEXIST:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"pool already exists\"));\n\t\tzfs_verror(hdl, EZFS_EXISTS, fmt, ap);\n\t\tbreak;\n\n\tcase EBUSY:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"pool is busy\"));\n\t\tzfs_verror(hdl, EZFS_BUSY, fmt, ap);\n\t\tbreak;\n\n\t \n\tcase ENOTACTIVE:\n\t\tzfs_verror(hdl, EZFS_NO_PENDING, fmt, ap);\n\t\tbreak;\n\n\tcase ENXIO:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"one or more devices is currently unavailable\"));\n\t\tzfs_verror(hdl, EZFS_BADDEV, fmt, ap);\n\t\tbreak;\n\n\tcase ENAMETOOLONG:\n\t\tzfs_verror(hdl, EZFS_DEVOVERFLOW, fmt, ap);\n\t\tbreak;\n\n\tcase ENOTSUP:\n\t\tzfs_verror(hdl, EZFS_POOL_NOTSUP, fmt, ap);\n\t\tbreak;\n\n\tcase EINVAL:\n\t\tzfs_verror(hdl, EZFS_POOL_INVALARG, fmt, ap);\n\t\tbreak;\n\n\tcase ENOSPC:\n\tcase EDQUOT:\n\t\tzfs_verror(hdl, EZFS_NOSPC, fmt, ap);\n\t\tbreak;\n\n\tcase EAGAIN:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"pool I/O is currently suspended\"));\n\t\tzfs_verror(hdl, EZFS_POOLUNAVAIL, fmt, ap);\n\t\tbreak;\n\n\tcase EROFS:\n\t\tzfs_verror(hdl, EZFS_POOLREADONLY, fmt, ap);\n\t\tbreak;\n\tcase EDOM:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"block size out of range or does not match\"));\n\t\tzfs_verror(hdl, EZFS_BADPROP, fmt, ap);\n\t\tbreak;\n\tcase EREMOTEIO:\n\t\tzfs_verror(hdl, EZFS_ACTIVE_POOL, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_CHECKPOINT_EXISTS:\n\t\tzfs_verror(hdl, EZFS_CHECKPOINT_EXISTS, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_DISCARDING_CHECKPOINT:\n\t\tzfs_verror(hdl, EZFS_DISCARDING_CHECKPOINT, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_NO_CHECKPOINT:\n\t\tzfs_verror(hdl, EZFS_NO_CHECKPOINT, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_DEVRM_IN_PROGRESS:\n\t\tzfs_verror(hdl, EZFS_DEVRM_IN_PROGRESS, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_VDEV_TOO_BIG:\n\t\tzfs_verror(hdl, EZFS_VDEV_TOO_BIG, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_EXPORT_IN_PROGRESS:\n\t\tzfs_verror(hdl, EZFS_EXPORT_IN_PROGRESS, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_RESILVER_IN_PROGRESS:\n\t\tzfs_verror(hdl, EZFS_RESILVERING, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_REBUILD_IN_PROGRESS:\n\t\tzfs_verror(hdl, EZFS_REBUILDING, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_BADPROP:\n\t\tzfs_verror(hdl, EZFS_BADPROP, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_VDEV_NOTSUP:\n\t\tzfs_verror(hdl, EZFS_VDEV_NOTSUP, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_IOC_CMD_UNAVAIL:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"the loaded zfs \"\n\t\t    \"module does not support this operation. A reboot may \"\n\t\t    \"be required to enable this operation.\"));\n\t\tzfs_verror(hdl, EZFS_IOC_NOTSUPPORTED, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_IOC_ARG_UNAVAIL:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"the loaded zfs \"\n\t\t    \"module does not support an option for this operation. \"\n\t\t    \"A reboot may be required to enable this option.\"));\n\t\tzfs_verror(hdl, EZFS_IOC_NOTSUPPORTED, fmt, ap);\n\t\tbreak;\n\tcase ZFS_ERR_IOC_ARG_REQUIRED:\n\tcase ZFS_ERR_IOC_ARG_BADTYPE:\n\t\tzfs_verror(hdl, EZFS_IOC_NOTSUPPORTED, fmt, ap);\n\t\tbreak;\n\tdefault:\n\t\tzfs_error_aux(hdl, \"%s\", strerror(error));\n\t\tzfs_verror(hdl, EZFS_UNKNOWN, fmt, ap);\n\t}\n\n\tva_end(ap);\n\treturn (-1);\n}\n\n \nint\nno_memory(libzfs_handle_t *hdl)\n{\n\treturn (zfs_error(hdl, EZFS_NOMEM, \"internal error\"));\n}\n\n \nvoid *\nzfs_alloc(libzfs_handle_t *hdl, size_t size)\n{\n\tvoid *data;\n\n\tif ((data = calloc(1, size)) == NULL)\n\t\t(void) no_memory(hdl);\n\n\treturn (data);\n}\n\n \nchar *\nzfs_asprintf(libzfs_handle_t *hdl, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *ret;\n\tint err;\n\n\tva_start(ap, fmt);\n\n\terr = vasprintf(&ret, fmt, ap);\n\n\tva_end(ap);\n\n\tif (err < 0) {\n\t\t(void) no_memory(hdl);\n\t\tret = NULL;\n\t}\n\n\treturn (ret);\n}\n\n \nvoid *\nzfs_realloc(libzfs_handle_t *hdl, void *ptr, size_t oldsize, size_t newsize)\n{\n\tvoid *ret;\n\n\tif ((ret = realloc(ptr, newsize)) == NULL) {\n\t\t(void) no_memory(hdl);\n\t\treturn (NULL);\n\t}\n\n\tmemset((char *)ret + oldsize, 0, newsize - oldsize);\n\treturn (ret);\n}\n\n \nchar *\nzfs_strdup(libzfs_handle_t *hdl, const char *str)\n{\n\tchar *ret;\n\n\tif ((ret = strdup(str)) == NULL)\n\t\t(void) no_memory(hdl);\n\n\treturn (ret);\n}\n\nvoid\nlibzfs_print_on_error(libzfs_handle_t *hdl, boolean_t printerr)\n{\n\thdl->libzfs_printerr = printerr;\n}\n\n \nstatic int\nlibzfs_read_stdout_from_fd(int fd, char **lines[])\n{\n\n\tFILE *fp;\n\tint lines_cnt = 0;\n\tsize_t len = 0;\n\tchar *line = NULL;\n\tchar **tmp_lines = NULL, **tmp;\n\n\tfp = fdopen(fd, \"r\");\n\tif (fp == NULL) {\n\t\tclose(fd);\n\t\treturn (0);\n\t}\n\twhile (getline(&line, &len, fp) != -1) {\n\t\ttmp = realloc(tmp_lines, sizeof (*tmp_lines) * (lines_cnt + 1));\n\t\tif (tmp == NULL) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\ttmp_lines = tmp;\n\n\t\t \n\t\tif (line[strlen(line) - 1] == '\\n')\n\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\ttmp_lines[lines_cnt] = strdup(line);\n\t\tif (tmp_lines[lines_cnt] == NULL)\n\t\t\tbreak;\n\t\t++lines_cnt;\n\t}\n\tfree(line);\n\tfclose(fp);\n\t*lines = tmp_lines;\n\treturn (lines_cnt);\n}\n\nstatic int\nlibzfs_run_process_impl(const char *path, char *argv[], char *env[], int flags,\n    char **lines[], int *lines_cnt)\n{\n\tpid_t pid;\n\tint error, devnull_fd;\n\tint link[2];\n\n\t \n\tif (lines != NULL && pipe2(link, O_NONBLOCK | O_CLOEXEC) == -1)\n\t\treturn (-EPIPE);\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\t \n\t\tdevnull_fd = open(\"/dev/null\", O_WRONLY | O_CLOEXEC);\n\n\t\tif (devnull_fd < 0)\n\t\t\t_exit(-1);\n\n\t\tif (!(flags & STDOUT_VERBOSE) && (lines == NULL))\n\t\t\t(void) dup2(devnull_fd, STDOUT_FILENO);\n\t\telse if (lines != NULL) {\n\t\t\t \n\t\t\tdup2(link[1], STDOUT_FILENO);\n\t\t}\n\n\t\tif (!(flags & STDERR_VERBOSE))\n\t\t\t(void) dup2(devnull_fd, STDERR_FILENO);\n\n\t\tif (flags & NO_DEFAULT_PATH) {\n\t\t\tif (env == NULL)\n\t\t\t\texecv(path, argv);\n\t\t\telse\n\t\t\t\texecve(path, argv, env);\n\t\t} else {\n\t\t\tif (env == NULL)\n\t\t\t\texecvp(path, argv);\n\t\t\telse\n\t\t\t\texecvpe(path, argv, env);\n\t\t}\n\n\t\t_exit(-1);\n\t} else if (pid > 0) {\n\t\t \n\t\tint status;\n\n\t\twhile ((error = waitpid(pid, &status, 0)) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t\tif (error < 0 || !WIFEXITED(status))\n\t\t\treturn (-1);\n\n\t\tif (lines != NULL) {\n\t\t\tclose(link[1]);\n\t\t\t*lines_cnt = libzfs_read_stdout_from_fd(link[0], lines);\n\t\t}\n\t\treturn (WEXITSTATUS(status));\n\t}\n\n\treturn (-1);\n}\n\nint\nlibzfs_run_process(const char *path, char *argv[], int flags)\n{\n\treturn (libzfs_run_process_impl(path, argv, NULL, flags, NULL, NULL));\n}\n\n \nint\nlibzfs_run_process_get_stdout(const char *path, char *argv[], char *env[],\n    char **lines[], int *lines_cnt)\n{\n\treturn (libzfs_run_process_impl(path, argv, env, 0, lines, lines_cnt));\n}\n\n \nint\nlibzfs_run_process_get_stdout_nopath(const char *path, char *argv[],\n    char *env[], char **lines[], int *lines_cnt)\n{\n\treturn (libzfs_run_process_impl(path, argv, env, NO_DEFAULT_PATH,\n\t    lines, lines_cnt));\n}\n\n \nvoid\nlibzfs_free_str_array(char **strs, int count)\n{\n\twhile (--count >= 0)\n\t\tfree(strs[count]);\n\n\tfree(strs);\n}\n\n \nboolean_t\nlibzfs_envvar_is_set(const char *envvar)\n{\n\tchar *env = getenv(envvar);\n\treturn (env && (strtoul(env, NULL, 0) > 0 ||\n\t    (!strncasecmp(env, \"YES\", 3) && strnlen(env, 4) == 3) ||\n\t    (!strncasecmp(env, \"ON\", 2) && strnlen(env, 3) == 2)));\n}\n\nlibzfs_handle_t *\nlibzfs_init(void)\n{\n\tlibzfs_handle_t *hdl;\n\tint error;\n\tchar *env;\n\n\tif ((error = libzfs_load_module()) != 0) {\n\t\terrno = error;\n\t\treturn (NULL);\n\t}\n\n\tif ((hdl = calloc(1, sizeof (libzfs_handle_t))) == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tif (regcomp(&hdl->libzfs_urire, URI_REGEX, 0) != 0) {\n\t\tfree(hdl);\n\t\treturn (NULL);\n\t}\n\n\tif ((hdl->libzfs_fd = open(ZFS_DEV, O_RDWR|O_EXCL|O_CLOEXEC)) < 0) {\n\t\tfree(hdl);\n\t\treturn (NULL);\n\t}\n\n\tif (libzfs_core_init() != 0) {\n\t\t(void) close(hdl->libzfs_fd);\n\t\tfree(hdl);\n\t\treturn (NULL);\n\t}\n\n\tzfs_prop_init();\n\tzpool_prop_init();\n\tzpool_feature_init();\n\tvdev_prop_init();\n\tlibzfs_mnttab_init(hdl);\n\tfletcher_4_init();\n\n\tif (getenv(\"ZFS_PROP_DEBUG\") != NULL) {\n\t\thdl->libzfs_prop_debug = B_TRUE;\n\t}\n\tif ((env = getenv(\"ZFS_SENDRECV_MAX_NVLIST\")) != NULL) {\n\t\tif ((error = zfs_nicestrtonum(hdl, env,\n\t\t    &hdl->libzfs_max_nvlist))) {\n\t\t\terrno = error;\n\t\t\t(void) close(hdl->libzfs_fd);\n\t\t\tfree(hdl);\n\t\t\treturn (NULL);\n\t\t}\n\t} else {\n\t\thdl->libzfs_max_nvlist = (SPA_MAXBLOCKSIZE * 4);\n\t}\n\n\t \n\tif (libzfs_envvar_is_set(\"ZFS_SYSFS_PROP_SUPPORT_TEST\")) {\n\t\tzprop_desc_t *proptbl;\n\n\t\tproptbl = zpool_prop_get_table();\n\t\tproptbl[ZPOOL_PROP_COMMENT].pd_zfs_mod_supported = B_FALSE;\n\n\t\tproptbl = zfs_prop_get_table();\n\t\tproptbl[ZFS_PROP_DNODESIZE].pd_zfs_mod_supported = B_FALSE;\n\n\t\tzfeature_info_t *ftbl = spa_feature_table;\n\t\tftbl[SPA_FEATURE_LARGE_BLOCKS].fi_zfs_mod_supported = B_FALSE;\n\t}\n\n\treturn (hdl);\n}\n\nvoid\nlibzfs_fini(libzfs_handle_t *hdl)\n{\n\t(void) close(hdl->libzfs_fd);\n\tzpool_free_handles(hdl);\n\tnamespace_clear(hdl);\n\tlibzfs_mnttab_fini(hdl);\n\tlibzfs_core_fini();\n\tregfree(&hdl->libzfs_urire);\n\tfletcher_4_fini();\n#if LIBFETCH_DYNAMIC\n\tif (hdl->libfetch != (void *)-1 && hdl->libfetch != NULL)\n\t\t(void) dlclose(hdl->libfetch);\n\tfree(hdl->libfetch_load_error);\n#endif\n\tfree(hdl);\n}\n\nlibzfs_handle_t *\nzpool_get_handle(zpool_handle_t *zhp)\n{\n\treturn (zhp->zpool_hdl);\n}\n\nlibzfs_handle_t *\nzfs_get_handle(zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_hdl);\n}\n\nzpool_handle_t *\nzfs_get_pool_handle(const zfs_handle_t *zhp)\n{\n\treturn (zhp->zpool_hdl);\n}\n\n \nzfs_handle_t *\nzfs_path_to_zhandle(libzfs_handle_t *hdl, const char *path, zfs_type_t argtype)\n{\n\tstruct stat64 statbuf;\n\tstruct extmnttab entry;\n\n\tif (path[0] != '/' && strncmp(path, \"./\", strlen(\"./\")) != 0) {\n\t\t \n\t\treturn (zfs_open(hdl, path, argtype));\n\t}\n\n\tif (getextmntent(path, &entry, &statbuf) != 0)\n\t\treturn (NULL);\n\n\tif (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0) {\n\t\t(void) fprintf(stderr, gettext(\"'%s': not a ZFS filesystem\\n\"),\n\t\t    path);\n\t\treturn (NULL);\n\t}\n\n\treturn (zfs_open(hdl, entry.mnt_special, ZFS_TYPE_FILESYSTEM));\n}\n\n \nvoid\nzcmd_alloc_dst_nvlist(libzfs_handle_t *hdl, zfs_cmd_t *zc, size_t len)\n{\n\tif (len == 0)\n\t\tlen = 256 * 1024;\n\tzc->zc_nvlist_dst_size = len;\n\tzc->zc_nvlist_dst =\n\t    (uint64_t)(uintptr_t)zfs_alloc(hdl, zc->zc_nvlist_dst_size);\n}\n\n \nvoid\nzcmd_expand_dst_nvlist(libzfs_handle_t *hdl, zfs_cmd_t *zc)\n{\n\tfree((void *)(uintptr_t)zc->zc_nvlist_dst);\n\tzc->zc_nvlist_dst =\n\t    (uint64_t)(uintptr_t)zfs_alloc(hdl, zc->zc_nvlist_dst_size);\n}\n\n \nvoid\nzcmd_free_nvlists(zfs_cmd_t *zc)\n{\n\tfree((void *)(uintptr_t)zc->zc_nvlist_conf);\n\tfree((void *)(uintptr_t)zc->zc_nvlist_src);\n\tfree((void *)(uintptr_t)zc->zc_nvlist_dst);\n\tzc->zc_nvlist_conf = 0;\n\tzc->zc_nvlist_src = 0;\n\tzc->zc_nvlist_dst = 0;\n}\n\nstatic void\nzcmd_write_nvlist_com(libzfs_handle_t *hdl, uint64_t *outnv, uint64_t *outlen,\n    nvlist_t *nvl)\n{\n\tchar *packed;\n\n\tsize_t len = fnvlist_size(nvl);\n\tpacked = zfs_alloc(hdl, len);\n\n\tverify(nvlist_pack(nvl, &packed, &len, NV_ENCODE_NATIVE, 0) == 0);\n\n\t*outnv = (uint64_t)(uintptr_t)packed;\n\t*outlen = len;\n}\n\nvoid\nzcmd_write_conf_nvlist(libzfs_handle_t *hdl, zfs_cmd_t *zc, nvlist_t *nvl)\n{\n\tzcmd_write_nvlist_com(hdl, &zc->zc_nvlist_conf,\n\t    &zc->zc_nvlist_conf_size, nvl);\n}\n\nvoid\nzcmd_write_src_nvlist(libzfs_handle_t *hdl, zfs_cmd_t *zc, nvlist_t *nvl)\n{\n\tzcmd_write_nvlist_com(hdl, &zc->zc_nvlist_src,\n\t    &zc->zc_nvlist_src_size, nvl);\n}\n\n \nint\nzcmd_read_dst_nvlist(libzfs_handle_t *hdl, zfs_cmd_t *zc, nvlist_t **nvlp)\n{\n\tif (nvlist_unpack((void *)(uintptr_t)zc->zc_nvlist_dst,\n\t    zc->zc_nvlist_dst_size, nvlp, 0) != 0)\n\t\treturn (no_memory(hdl));\n\n\treturn (0);\n}\n\n \n\nstatic void\nzprop_print_headers(zprop_get_cbdata_t *cbp, zfs_type_t type)\n{\n\tzprop_list_t *pl;\n\tint i;\n\tchar *title;\n\tsize_t len;\n\n\tcbp->cb_first = B_FALSE;\n\tif (cbp->cb_scripted)\n\t\treturn;\n\n\t \n\tcbp->cb_colwidths[GET_COL_NAME] = strlen(dgettext(TEXT_DOMAIN, \"NAME\"));\n\tcbp->cb_colwidths[GET_COL_PROPERTY] = strlen(dgettext(TEXT_DOMAIN,\n\t    \"PROPERTY\"));\n\tcbp->cb_colwidths[GET_COL_VALUE] = strlen(dgettext(TEXT_DOMAIN,\n\t    \"VALUE\"));\n\tcbp->cb_colwidths[GET_COL_RECVD] = strlen(dgettext(TEXT_DOMAIN,\n\t    \"RECEIVED\"));\n\tcbp->cb_colwidths[GET_COL_SOURCE] = strlen(dgettext(TEXT_DOMAIN,\n\t    \"SOURCE\"));\n\n\t \n\tassert(cbp->cb_proplist->pl_prop ==\n\t    ((type == ZFS_TYPE_POOL) ? ZPOOL_PROP_NAME :\n\t    ((type == ZFS_TYPE_VDEV) ? VDEV_PROP_NAME : ZFS_PROP_NAME)));\n\n\t \n\tfor (pl = cbp->cb_proplist; pl != NULL; pl = pl->pl_next) {\n\t\t \n\t\tif (pl->pl_prop != ZPROP_USERPROP) {\n\t\t\tconst char *propname = (type == ZFS_TYPE_POOL) ?\n\t\t\t    zpool_prop_to_name(pl->pl_prop) :\n\t\t\t    ((type == ZFS_TYPE_VDEV) ?\n\t\t\t    vdev_prop_to_name(pl->pl_prop) :\n\t\t\t    zfs_prop_to_name(pl->pl_prop));\n\n\t\t\tassert(propname != NULL);\n\t\t\tlen = strlen(propname);\n\t\t\tif (len > cbp->cb_colwidths[GET_COL_PROPERTY])\n\t\t\t\tcbp->cb_colwidths[GET_COL_PROPERTY] = len;\n\t\t} else {\n\t\t\tassert(pl->pl_user_prop != NULL);\n\t\t\tlen = strlen(pl->pl_user_prop);\n\t\t\tif (len > cbp->cb_colwidths[GET_COL_PROPERTY])\n\t\t\t\tcbp->cb_colwidths[GET_COL_PROPERTY] = len;\n\t\t}\n\n\t\t \n\t\tif (pl != cbp->cb_proplist &&\n\t\t    pl->pl_width > cbp->cb_colwidths[GET_COL_VALUE])\n\t\t\tcbp->cb_colwidths[GET_COL_VALUE] = pl->pl_width;\n\n\t\t \n\t\tif (pl != cbp->cb_proplist &&\n\t\t    pl->pl_recvd_width > cbp->cb_colwidths[GET_COL_RECVD])\n\t\t\tcbp->cb_colwidths[GET_COL_RECVD] = pl->pl_recvd_width;\n\n\t\t \n\t\tif (pl->pl_prop == ((type == ZFS_TYPE_POOL) ? ZPOOL_PROP_NAME :\n\t\t    ((type == ZFS_TYPE_VDEV) ? VDEV_PROP_NAME :\n\t\t    ZFS_PROP_NAME)) && pl->pl_width >\n\t\t    cbp->cb_colwidths[GET_COL_NAME]) {\n\t\t\tcbp->cb_colwidths[GET_COL_NAME] = pl->pl_width;\n\t\t\tcbp->cb_colwidths[GET_COL_SOURCE] = pl->pl_width +\n\t\t\t    strlen(dgettext(TEXT_DOMAIN, \"inherited from\"));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ZFS_GET_NCOLS; i++) {\n\t\tswitch (cbp->cb_columns[i]) {\n\t\tcase GET_COL_NAME:\n\t\t\ttitle = dgettext(TEXT_DOMAIN, \"NAME\");\n\t\t\tbreak;\n\t\tcase GET_COL_PROPERTY:\n\t\t\ttitle = dgettext(TEXT_DOMAIN, \"PROPERTY\");\n\t\t\tbreak;\n\t\tcase GET_COL_VALUE:\n\t\t\ttitle = dgettext(TEXT_DOMAIN, \"VALUE\");\n\t\t\tbreak;\n\t\tcase GET_COL_RECVD:\n\t\t\ttitle = dgettext(TEXT_DOMAIN, \"RECEIVED\");\n\t\t\tbreak;\n\t\tcase GET_COL_SOURCE:\n\t\t\ttitle = dgettext(TEXT_DOMAIN, \"SOURCE\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttitle = NULL;\n\t\t}\n\n\t\tif (title != NULL) {\n\t\t\tif (i == (ZFS_GET_NCOLS - 1) ||\n\t\t\t    cbp->cb_columns[i + 1] == GET_COL_NONE)\n\t\t\t\t(void) printf(\"%s\", title);\n\t\t\telse\n\t\t\t\t(void) printf(\"%-*s  \",\n\t\t\t\t    cbp->cb_colwidths[cbp->cb_columns[i]],\n\t\t\t\t    title);\n\t\t}\n\t}\n\t(void) printf(\"\\n\");\n}\n\n \nvoid\nzprop_print_one_property(const char *name, zprop_get_cbdata_t *cbp,\n    const char *propname, const char *value, zprop_source_t sourcetype,\n    const char *source, const char *recvd_value)\n{\n\tint i;\n\tconst char *str = NULL;\n\tchar buf[128];\n\n\t \n\tif ((sourcetype & cbp->cb_sources) == 0)\n\t\treturn;\n\n\tif (cbp->cb_first)\n\t\tzprop_print_headers(cbp, cbp->cb_type);\n\n\tfor (i = 0; i < ZFS_GET_NCOLS; i++) {\n\t\tswitch (cbp->cb_columns[i]) {\n\t\tcase GET_COL_NAME:\n\t\t\tstr = name;\n\t\t\tbreak;\n\n\t\tcase GET_COL_PROPERTY:\n\t\t\tstr = propname;\n\t\t\tbreak;\n\n\t\tcase GET_COL_VALUE:\n\t\t\tstr = value;\n\t\t\tbreak;\n\n\t\tcase GET_COL_SOURCE:\n\t\t\tswitch (sourcetype) {\n\t\t\tcase ZPROP_SRC_NONE:\n\t\t\t\tstr = \"-\";\n\t\t\t\tbreak;\n\n\t\t\tcase ZPROP_SRC_DEFAULT:\n\t\t\t\tstr = \"default\";\n\t\t\t\tbreak;\n\n\t\t\tcase ZPROP_SRC_LOCAL:\n\t\t\t\tstr = \"local\";\n\t\t\t\tbreak;\n\n\t\t\tcase ZPROP_SRC_TEMPORARY:\n\t\t\t\tstr = \"temporary\";\n\t\t\t\tbreak;\n\n\t\t\tcase ZPROP_SRC_INHERITED:\n\t\t\t\t(void) snprintf(buf, sizeof (buf),\n\t\t\t\t    \"inherited from %s\", source);\n\t\t\t\tstr = buf;\n\t\t\t\tbreak;\n\t\t\tcase ZPROP_SRC_RECEIVED:\n\t\t\t\tstr = \"received\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstr = NULL;\n\t\t\t\tassert(!\"unhandled zprop_source_t\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GET_COL_RECVD:\n\t\t\tstr = (recvd_value == NULL ? \"-\" : recvd_value);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == (ZFS_GET_NCOLS - 1) ||\n\t\t    cbp->cb_columns[i + 1] == GET_COL_NONE)\n\t\t\t(void) printf(\"%s\", str);\n\t\telse if (cbp->cb_scripted)\n\t\t\t(void) printf(\"%s\\t\", str);\n\t\telse\n\t\t\t(void) printf(\"%-*s  \",\n\t\t\t    cbp->cb_colwidths[cbp->cb_columns[i]],\n\t\t\t    str);\n\t}\n\n\t(void) printf(\"\\n\");\n}\n\n \nstatic int\nstr2shift(libzfs_handle_t *hdl, const char *buf)\n{\n\tconst char *ends = \"BKMGTPEZ\";\n\tint i;\n\n\tif (buf[0] == '\\0')\n\t\treturn (0);\n\tfor (i = 0; i < strlen(ends); i++) {\n\t\tif (toupper(buf[0]) == ends[i])\n\t\t\tbreak;\n\t}\n\tif (i == strlen(ends)) {\n\t\tif (hdl)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid numeric suffix '%s'\"), buf);\n\t\treturn (-1);\n\t}\n\n\t \n\tif (buf[1] == '\\0' ||\n\t    (toupper(buf[0]) != 'B' &&\n\t    ((toupper(buf[1]) == 'B' && buf[2] == '\\0') ||\n\t    (toupper(buf[1]) == 'I' && toupper(buf[2]) == 'B' &&\n\t    buf[3] == '\\0'))))\n\t\treturn (10 * i);\n\n\tif (hdl)\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid numeric suffix '%s'\"), buf);\n\treturn (-1);\n}\n\n \nint\nzfs_nicestrtonum(libzfs_handle_t *hdl, const char *value, uint64_t *num)\n{\n\tchar *end;\n\tint shift;\n\n\t*num = 0;\n\n\t \n\tif ((value[0] < '0' || value[0] > '9') && value[0] != '.') {\n\t\tif (hdl)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"bad numeric value '%s'\"), value);\n\t\treturn (-1);\n\t}\n\n\t \n\terrno = 0;\n\t*num = strtoull(value, &end, 10);\n\n\t \n\tif (errno == ERANGE) {\n\t\tif (hdl)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"numeric value is too large\"));\n\t\treturn (-1);\n\t}\n\n\t \n\tif (*end == '.') {\n\t\tdouble fval = strtod(value, &end);\n\n\t\tif ((shift = str2shift(hdl, end)) == -1)\n\t\t\treturn (-1);\n\n\t\tfval *= pow(2, shift);\n\n\t\t \n\t\tif (fval >= (double)UINT64_MAX) {\n\t\t\tif (hdl)\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"numeric value is too large\"));\n\t\t\treturn (-1);\n\t\t}\n\n\t\t*num = (uint64_t)fval;\n\t} else {\n\t\tif ((shift = str2shift(hdl, end)) == -1)\n\t\t\treturn (-1);\n\n\t\t \n\t\tif (shift >= 64 || (*num << shift) >> shift != *num) {\n\t\t\tif (hdl)\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"numeric value is too large\"));\n\t\t\treturn (-1);\n\t\t}\n\n\t\t*num <<= shift;\n\t}\n\n\treturn (0);\n}\n\n \nint\nzprop_parse_value(libzfs_handle_t *hdl, nvpair_t *elem, int prop,\n    zfs_type_t type, nvlist_t *ret, const char **svalp, uint64_t *ivalp,\n    const char *errbuf)\n{\n\tdata_type_t datatype = nvpair_type(elem);\n\tzprop_type_t proptype;\n\tconst char *propname;\n\tconst char *value;\n\tboolean_t isnone = B_FALSE;\n\tboolean_t isauto = B_FALSE;\n\tint err = 0;\n\n\tif (type == ZFS_TYPE_POOL) {\n\t\tproptype = zpool_prop_get_type(prop);\n\t\tpropname = zpool_prop_to_name(prop);\n\t} else if (type == ZFS_TYPE_VDEV) {\n\t\tproptype = vdev_prop_get_type(prop);\n\t\tpropname = vdev_prop_to_name(prop);\n\t} else {\n\t\tproptype = zfs_prop_get_type(prop);\n\t\tpropname = zfs_prop_to_name(prop);\n\t}\n\n\t \n\t*svalp = NULL;\n\t*ivalp = 0;\n\n\tswitch (proptype) {\n\tcase PROP_TYPE_STRING:\n\t\tif (datatype != DATA_TYPE_STRING) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' must be a string\"), nvpair_name(elem));\n\t\t\tgoto error;\n\t\t}\n\t\terr = nvpair_value_string(elem, svalp);\n\t\tif (err != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' is invalid\"), nvpair_name(elem));\n\t\t\tgoto error;\n\t\t}\n\t\tif (strlen(*svalp) >= ZFS_MAXPROPLEN) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' is too long\"), nvpair_name(elem));\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tcase PROP_TYPE_NUMBER:\n\t\tif (datatype == DATA_TYPE_STRING) {\n\t\t\t(void) nvpair_value_string(elem, &value);\n\t\t\tif (strcmp(value, \"none\") == 0) {\n\t\t\t\tisnone = B_TRUE;\n\t\t\t} else if (strcmp(value, \"auto\") == 0) {\n\t\t\t\tisauto = B_TRUE;\n\t\t\t} else if (zfs_nicestrtonum(hdl, value, ivalp) != 0) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else if (datatype == DATA_TYPE_UINT64) {\n\t\t\t(void) nvpair_value_uint64(elem, ivalp);\n\t\t} else {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' must be a number\"), nvpair_name(elem));\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif ((type & ZFS_TYPE_DATASET) && *ivalp == 0 && !isnone &&\n\t\t    (prop == ZFS_PROP_QUOTA || prop == ZFS_PROP_REFQUOTA)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"use 'none' to disable quota/refquota\"));\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif ((type & ZFS_TYPE_DATASET) && isnone &&\n\t\t    (prop == ZFS_PROP_FILESYSTEM_LIMIT ||\n\t\t    prop == ZFS_PROP_SNAPSHOT_LIMIT)) {\n\t\t\t*ivalp = UINT64_MAX;\n\t\t}\n\n\t\t \n\t\tif ((type & ZFS_TYPE_VDEV) && isnone &&\n\t\t    (prop == VDEV_PROP_CHECKSUM_N ||\n\t\t    prop == VDEV_PROP_CHECKSUM_T ||\n\t\t    prop == VDEV_PROP_IO_N ||\n\t\t    prop == VDEV_PROP_IO_T)) {\n\t\t\t*ivalp = UINT64_MAX;\n\t\t}\n\n\t\t \n\t\tif (isauto) {\n\t\t\tswitch (prop) {\n\t\t\tcase ZFS_PROP_REFRESERVATION:\n\t\t\t\tif ((type & ZFS_TYPE_VOLUME) == 0) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s=auto' only allowed on \"\n\t\t\t\t\t    \"volumes\"), nvpair_name(elem));\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\t*ivalp = UINT64_MAX;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'auto' is invalid value for '%s'\"),\n\t\t\t\t    nvpair_name(elem));\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase PROP_TYPE_INDEX:\n\t\tif (datatype != DATA_TYPE_STRING) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' must be a string\"), nvpair_name(elem));\n\t\t\tgoto error;\n\t\t}\n\n\t\t(void) nvpair_value_string(elem, &value);\n\n\t\tif (zprop_string_to_index(prop, value, ivalp, type) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' must be one of '%s'\"), propname,\n\t\t\t    zprop_values(prop, type));\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\n\t \n\tif (*svalp != NULL) {\n\t\tif (nvlist_add_string(ret, propname, *svalp) != 0) {\n\t\t\t(void) no_memory(hdl);\n\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\tif (nvlist_add_uint64(ret, propname, *ivalp) != 0) {\n\t\t\t(void) no_memory(hdl);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\nerror:\n\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\treturn (-1);\n}\n\nstatic int\naddlist(libzfs_handle_t *hdl, const char *propname, zprop_list_t **listp,\n    zfs_type_t type)\n{\n\tint prop = zprop_name_to_prop(propname, type);\n\tif (prop != ZPROP_INVAL && !zprop_valid_for_type(prop, type, B_FALSE))\n\t\tprop = ZPROP_INVAL;\n\n\t \n\tif (prop == ZPROP_USERPROP && ((type == ZFS_TYPE_POOL &&\n\t    !zfs_prop_user(propname) &&\n\t    !zpool_prop_feature(propname) &&\n\t    !zpool_prop_unsupported(propname)) ||\n\t    ((type == ZFS_TYPE_DATASET) && !zfs_prop_user(propname) &&\n\t    !zfs_prop_userquota(propname) && !zfs_prop_written(propname)) ||\n\t    ((type == ZFS_TYPE_VDEV) && !vdev_prop_user(propname)))) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid property '%s'\"), propname);\n\t\treturn (zfs_error(hdl, EZFS_BADPROP,\n\t\t    dgettext(TEXT_DOMAIN, \"bad property list\")));\n\t}\n\n\tzprop_list_t *entry = zfs_alloc(hdl, sizeof (*entry));\n\n\tentry->pl_prop = prop;\n\tif (prop == ZPROP_USERPROP) {\n\t\tentry->pl_user_prop = zfs_strdup(hdl, propname);\n\t\tentry->pl_width = strlen(propname);\n\t} else {\n\t\tentry->pl_width = zprop_width(prop, &entry->pl_fixed,\n\t\t    type);\n\t}\n\n\t*listp = entry;\n\n\treturn (0);\n}\n\n \nint\nzprop_get_list(libzfs_handle_t *hdl, char *props, zprop_list_t **listp,\n    zfs_type_t type)\n{\n\t*listp = NULL;\n\n\t \n\tif (strcmp(props, \"all\") == 0)\n\t\treturn (0);\n\n\t \n\tif (props[0] == '\\0') {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"no properties specified\"));\n\t\treturn (zfs_error(hdl, EZFS_BADPROP, dgettext(TEXT_DOMAIN,\n\t\t    \"bad property list\")));\n\t}\n\n\tfor (char *p; (p = strsep(&props, \",\")); )\n\t\tif (strcmp(p, \"space\") == 0) {\n\t\t\tstatic const char *const spaceprops[] = {\n\t\t\t\t\"name\", \"avail\", \"used\", \"usedbysnapshots\",\n\t\t\t\t\"usedbydataset\", \"usedbyrefreservation\",\n\t\t\t\t\"usedbychildren\"\n\t\t\t};\n\n\t\t\tfor (int i = 0; i < ARRAY_SIZE(spaceprops); i++) {\n\t\t\t\tif (addlist(hdl, spaceprops[i], listp, type))\n\t\t\t\t\treturn (-1);\n\t\t\t\tlistp = &(*listp)->pl_next;\n\t\t\t}\n\t\t} else {\n\t\t\tif (addlist(hdl, p, listp, type))\n\t\t\t\treturn (-1);\n\t\t\tlistp = &(*listp)->pl_next;\n\t\t}\n\n\treturn (0);\n}\n\nvoid\nzprop_free_list(zprop_list_t *pl)\n{\n\tzprop_list_t *next;\n\n\twhile (pl != NULL) {\n\t\tnext = pl->pl_next;\n\t\tfree(pl->pl_user_prop);\n\t\tfree(pl);\n\t\tpl = next;\n\t}\n}\n\ntypedef struct expand_data {\n\tzprop_list_t\t**last;\n\tlibzfs_handle_t\t*hdl;\n\tzfs_type_t type;\n} expand_data_t;\n\nstatic int\nzprop_expand_list_cb(int prop, void *cb)\n{\n\tzprop_list_t *entry;\n\texpand_data_t *edp = cb;\n\n\tentry = zfs_alloc(edp->hdl, sizeof (zprop_list_t));\n\n\tentry->pl_prop = prop;\n\tentry->pl_width = zprop_width(prop, &entry->pl_fixed, edp->type);\n\tentry->pl_all = B_TRUE;\n\n\t*(edp->last) = entry;\n\tedp->last = &entry->pl_next;\n\n\treturn (ZPROP_CONT);\n}\n\nint\nzprop_expand_list(libzfs_handle_t *hdl, zprop_list_t **plp, zfs_type_t type)\n{\n\tzprop_list_t *entry;\n\tzprop_list_t **last;\n\texpand_data_t exp;\n\n\tif (*plp == NULL) {\n\t\t \n\t\tlast = plp;\n\n\t\texp.last = last;\n\t\texp.hdl = hdl;\n\t\texp.type = type;\n\n\t\tif (zprop_iter_common(zprop_expand_list_cb, &exp, B_FALSE,\n\t\t    B_FALSE, type) == ZPROP_INVAL)\n\t\t\treturn (-1);\n\n\t\t \n\t\tentry = zfs_alloc(hdl, sizeof (zprop_list_t));\n\t\tentry->pl_prop = ((type == ZFS_TYPE_POOL) ?  ZPOOL_PROP_NAME :\n\t\t    ((type == ZFS_TYPE_VDEV) ? VDEV_PROP_NAME : ZFS_PROP_NAME));\n\t\tentry->pl_width = zprop_width(entry->pl_prop,\n\t\t    &entry->pl_fixed, type);\n\t\tentry->pl_all = B_TRUE;\n\t\tentry->pl_next = *plp;\n\t\t*plp = entry;\n\t}\n\treturn (0);\n}\n\nint\nzprop_iter(zprop_func func, void *cb, boolean_t show_all, boolean_t ordered,\n    zfs_type_t type)\n{\n\treturn (zprop_iter_common(func, cb, show_all, ordered, type));\n}\n\nconst char *\nzfs_version_userland(void)\n{\n\treturn (ZFS_META_ALIAS);\n}\n\n \nint\nzfs_version_print(void)\n{\n\t(void) puts(ZFS_META_ALIAS);\n\n\tchar *kver = zfs_version_kernel();\n\tif (kver == NULL) {\n\t\tfprintf(stderr, \"zfs_version_kernel() failed: %s\\n\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\n\t(void) printf(\"zfs-kmod-%s\\n\", kver);\n\tfree(kver);\n\treturn (0);\n}\n\n \nint\nuse_color(void)\n{\n\tstatic int use_color = -1;\n\tchar *term;\n\n\t \n\tif (use_color != -1) {\n\t\t \n\t\treturn (use_color);\n\t}\n\n\tterm = getenv(\"TERM\");\n\t \n\tif (libzfs_envvar_is_set(\"ZFS_COLOR\") &&\n\t    !libzfs_envvar_is_set(\"NO_COLOR\") &&\n\t    isatty(STDOUT_FILENO) && term && strcmp(\"dumb\", term) != 0 &&\n\t    strcmp(\"unknown\", term) != 0) {\n\t\t \n\t\tuse_color = 1;\n\t} else {\n\t\tuse_color = 0;\n\t}\n\n\treturn (use_color);\n}\n\n \nvoid\ncolor_start(const char *color)\n{\n\tif (color && use_color()) {\n\t\tfputs(color, stdout);\n\t\tfflush(stdout);\n\t}\n}\n\nvoid\ncolor_end(void)\n{\n\tif (use_color()) {\n\t\tfputs(ANSI_RESET, stdout);\n\t\tfflush(stdout);\n\t}\n\n}\n\n \nint\nprintf_color(const char *color, const char *format, ...)\n{\n\tva_list aptr;\n\tint rc;\n\n\tif (color)\n\t\tcolor_start(color);\n\n\tva_start(aptr, format);\n\trc = vprintf(format, aptr);\n\tva_end(aptr);\n\n\tif (color)\n\t\tcolor_end();\n\n\treturn (rc);\n}\n\n \n#define\tZPOOL_VDEV_SCRIPT_ENV_COUNT 7\n\n \nchar **\nzpool_vdev_script_alloc_env(const char *pool_name,\n    const char *vdev_path, const char *vdev_upath,\n    const char *vdev_enc_sysfs_path, const char *opt_key, const char *opt_val)\n{\n\tchar **env = NULL;\n\tint rc;\n\n\tenv = calloc(ZPOOL_VDEV_SCRIPT_ENV_COUNT, sizeof (*env));\n\tif (!env)\n\t\treturn (NULL);\n\n\tenv[0] = strdup(\"PATH=/bin:/sbin:/usr/bin:/usr/sbin\");\n\tif (!env[0])\n\t\tgoto error;\n\n\t \n\trc = asprintf(&env[1], \"POOL_NAME=%s\", pool_name ? pool_name : \"\");\n\tif (rc == -1) {\n\t\tenv[1] = NULL;\n\t\tgoto error;\n\t}\n\n\trc = asprintf(&env[2], \"VDEV_PATH=%s\", vdev_path ? vdev_path : \"\");\n\tif (rc == -1) {\n\t\tenv[2] = NULL;\n\t\tgoto error;\n\t}\n\n\trc = asprintf(&env[3], \"VDEV_UPATH=%s\", vdev_upath ? vdev_upath : \"\");\n\tif (rc == -1) {\n\t\tenv[3] = NULL;\n\t\tgoto error;\n\t}\n\n\trc = asprintf(&env[4], \"VDEV_ENC_SYSFS_PATH=%s\",\n\t    vdev_enc_sysfs_path ?  vdev_enc_sysfs_path : \"\");\n\tif (rc == -1) {\n\t\tenv[4] = NULL;\n\t\tgoto error;\n\t}\n\n\tif (opt_key != NULL) {\n\t\trc = asprintf(&env[5], \"%s=%s\", opt_key,\n\t\t    opt_val ? opt_val : \"\");\n\t\tif (rc == -1) {\n\t\t\tenv[5] = NULL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn (env);\n\nerror:\n\tfor (int i = 0; i < ZPOOL_VDEV_SCRIPT_ENV_COUNT; i++)\n\t\tfree(env[i]);\n\n\tfree(env);\n\n\treturn (NULL);\n}\n\n \nvoid\nzpool_vdev_script_free_env(char **env)\n{\n\tfor (int i = 0; i < ZPOOL_VDEV_SCRIPT_ENV_COUNT; i++)\n\t\tfree(env[i]);\n\n\tfree(env);\n}\n\n \nint\nzpool_prepare_disk(zpool_handle_t *zhp, nvlist_t *vdev_nv,\n    const char *prepare_str, char **lines[], int *lines_cnt)\n{\n\tconst char *script_path = ZFSEXECDIR \"/zfs_prepare_disk\";\n\tconst char *pool_name;\n\tint rc = 0;\n\n\t \n\tchar *argv[2] = {(char *)script_path};\n\tchar **env = NULL;\n\tconst char *path = NULL, *enc_sysfs_path = NULL;\n\tchar *upath;\n\t*lines_cnt = 0;\n\n\tif (access(script_path, X_OK) != 0) {\n\t\t \n\t\treturn (0);\n\t}\n\n\t(void) nvlist_lookup_string(vdev_nv, ZPOOL_CONFIG_PATH, &path);\n\t(void) nvlist_lookup_string(vdev_nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH,\n\t    &enc_sysfs_path);\n\n\tupath = zfs_get_underlying_path(path);\n\tpool_name = zhp ? zpool_get_name(zhp) : NULL;\n\n\tenv = zpool_vdev_script_alloc_env(pool_name, path, upath,\n\t    enc_sysfs_path, \"VDEV_PREPARE\", prepare_str);\n\n\tfree(upath);\n\n\tif (env == NULL) {\n\t\treturn (ENOMEM);\n\t}\n\n\trc = libzfs_run_process_get_stdout(script_path, argv, env, lines,\n\t    lines_cnt);\n\n\tzpool_vdev_script_free_env(env);\n\n\treturn (rc);\n}\n\n \nint\nzpool_prepare_and_label_disk(libzfs_handle_t *hdl, zpool_handle_t *zhp,\n    const char *name, nvlist_t *vdev_nv, const char *prepare_str,\n    char **lines[], int *lines_cnt)\n{\n\tint rc;\n\tchar vdev_path[MAXPATHLEN];\n\t(void) snprintf(vdev_path, sizeof (vdev_path), \"%s/%s\", DISK_ROOT,\n\t    name);\n\n\t \n\trc = zpool_prepare_disk(zhp, vdev_nv, prepare_str, lines, lines_cnt);\n\tif (rc != 0)\n\t\treturn (rc);\n\n\trc = zpool_label_disk(hdl, zhp, name);\n\treturn (rc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}