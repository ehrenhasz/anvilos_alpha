{
  "module_name": "libzfs_status.c",
  "hash_id": "a5303da02ef469427c10487f9baa679591e79fceb6414dbbbe79d3ed093fbe5d",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_status.c",
  "human_readable_source": " \n\n \n\n \n\n#include <libzfs.h>\n#include <libzutil.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/systeminfo.h>\n#include \"libzfs_impl.h\"\n#include \"zfeature_common.h\"\n\n \nstatic const char *const zfs_msgid_table[] = {\n\t\"ZFS-8000-14\",  \n\t\"ZFS-8000-2Q\",  \n\t\"ZFS-8000-3C\",  \n\t\"ZFS-8000-4J\",  \n\t\"ZFS-8000-5E\",  \n\t\"ZFS-8000-6X\",  \n\t\"ZFS-8000-72\",  \n\t\"ZFS-8000-8A\",  \n\t\"ZFS-8000-9P\",  \n\t\"ZFS-8000-A5\",  \n\t\"ZFS-8000-EY\",  \n\t\"ZFS-8000-EY\",  \n\t\"ZFS-8000-EY\",  \n\t\"ZFS-8000-HC\",  \n\t\"ZFS-8000-JQ\",  \n\t\"ZFS-8000-MM\",  \n\t\"ZFS-8000-K4\",  \n\t\"ZFS-8000-ER\",  \n\t \n};\n\n#define\tNMSGID\t(sizeof (zfs_msgid_table) / sizeof (zfs_msgid_table[0]))\n\nstatic int\nvdev_missing(vdev_stat_t *vs, uint_t vsc)\n{\n\t(void) vsc;\n\treturn (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_OPEN_FAILED);\n}\n\nstatic int\nvdev_faulted(vdev_stat_t *vs, uint_t vsc)\n{\n\t(void) vsc;\n\treturn (vs->vs_state == VDEV_STATE_FAULTED);\n}\n\nstatic int\nvdev_errors(vdev_stat_t *vs, uint_t vsc)\n{\n\t(void) vsc;\n\treturn (vs->vs_state == VDEV_STATE_DEGRADED ||\n\t    vs->vs_read_errors != 0 || vs->vs_write_errors != 0 ||\n\t    vs->vs_checksum_errors != 0);\n}\n\nstatic int\nvdev_broken(vdev_stat_t *vs, uint_t vsc)\n{\n\t(void) vsc;\n\treturn (vs->vs_state == VDEV_STATE_CANT_OPEN);\n}\n\nstatic int\nvdev_offlined(vdev_stat_t *vs, uint_t vsc)\n{\n\t(void) vsc;\n\treturn (vs->vs_state == VDEV_STATE_OFFLINE);\n}\n\nstatic int\nvdev_removed(vdev_stat_t *vs, uint_t vsc)\n{\n\t(void) vsc;\n\treturn (vs->vs_state == VDEV_STATE_REMOVED);\n}\n\nstatic int\nvdev_non_native_ashift(vdev_stat_t *vs, uint_t vsc)\n{\n\tif (getenv(\"ZPOOL_STATUS_NON_NATIVE_ASHIFT_IGNORE\") != NULL)\n\t\treturn (0);\n\n\treturn (VDEV_STAT_VALID(vs_physical_ashift, vsc) &&\n\t    vs->vs_configured_ashift < vs->vs_physical_ashift);\n}\n\n \nstatic boolean_t\nfind_vdev_problem(nvlist_t *vdev, int (*func)(vdev_stat_t *, uint_t),\n    boolean_t ignore_replacing)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\n\t \n\tif (ignore_replacing == B_TRUE) {\n\t\tconst char *type = fnvlist_lookup_string(vdev,\n\t\t    ZPOOL_CONFIG_TYPE);\n\t\tif (strcmp(type, VDEV_TYPE_REPLACING) == 0)\n\t\t\treturn (B_FALSE);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(vdev, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (find_vdev_problem(child[c], func, ignore_replacing))\n\t\t\t\treturn (B_TRUE);\n\t} else {\n\t\tuint_t vsc;\n\t\tvdev_stat_t *vs = (vdev_stat_t *)fnvlist_lookup_uint64_array(\n\t\t    vdev, ZPOOL_CONFIG_VDEV_STATS, &vsc);\n\t\tif (func(vs, vsc) != 0)\n\t\t\treturn (B_TRUE);\n\t}\n\n\t \n\tif (nvlist_lookup_nvlist_array(vdev, ZPOOL_CONFIG_L2CACHE, &child,\n\t    &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (find_vdev_problem(child[c], func, ignore_replacing))\n\t\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic zpool_status_t\ncheck_status(nvlist_t *config, boolean_t isimport,\n    zpool_errata_t *erratap, const char *compat)\n{\n\tpool_scan_stat_t *ps = NULL;\n\tuint_t vsc, psc;\n\tuint64_t suspended;\n\tuint64_t hostid = 0;\n\tuint64_t errata = 0;\n\tunsigned long system_hostid = get_system_hostid();\n\n\tuint64_t version = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION);\n\tnvlist_t *nvroot = fnvlist_lookup_nvlist(config,\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\tvdev_stat_t *vs = (vdev_stat_t *)fnvlist_lookup_uint64_array(nvroot,\n\t    ZPOOL_CONFIG_VDEV_STATS, &vsc);\n\tuint64_t stateval = fnvlist_lookup_uint64(config,\n\t    ZPOOL_CONFIG_POOL_STATE);\n\n\t \n\t(void) nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_SCAN_STATS,\n\t    (uint64_t **)&ps, &psc);\n\tif (ps != NULL && ps->pss_func == POOL_SCAN_RESILVER &&\n\t    ps->pss_state == DSS_SCANNING)\n\t\treturn (ZPOOL_STATUS_RESILVERING);\n\n\t \n\tvdev_rebuild_stat_t *vrs = NULL;\n\tnvlist_t **child;\n\tuint_t c, i, children;\n\tuint64_t rebuild_end_time = 0;\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif ((nvlist_lookup_uint64_array(child[c],\n\t\t\t    ZPOOL_CONFIG_REBUILD_STATS,\n\t\t\t    (uint64_t **)&vrs, &i) == 0) && (vrs != NULL)) {\n\t\t\t\tuint64_t state = vrs->vrs_state;\n\n\t\t\t\tif (state == VDEV_REBUILD_ACTIVE) {\n\t\t\t\t\treturn (ZPOOL_STATUS_REBUILDING);\n\t\t\t\t} else if (state == VDEV_REBUILD_COMPLETE &&\n\t\t\t\t    vrs->vrs_end_time > rebuild_end_time) {\n\t\t\t\t\trebuild_end_time = vrs->vrs_end_time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (rebuild_end_time > 0) {\n\t\t\tif (ps != NULL) {\n\t\t\t\tif ((ps->pss_state == DSS_FINISHED &&\n\t\t\t\t    ps->pss_func == POOL_SCAN_SCRUB &&\n\t\t\t\t    rebuild_end_time > ps->pss_end_time) ||\n\t\t\t\t    ps->pss_state == DSS_NONE)\n\t\t\t\t\treturn (ZPOOL_STATUS_REBUILD_SCRUB);\n\t\t\t} else {\n\t\t\t\treturn (ZPOOL_STATUS_REBUILD_SCRUB);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_ACTIVE) {\n\t\tmmp_state_t mmp_state;\n\t\tnvlist_t *nvinfo;\n\n\t\tnvinfo = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_LOAD_INFO);\n\t\tmmp_state = fnvlist_lookup_uint64(nvinfo,\n\t\t    ZPOOL_CONFIG_MMP_STATE);\n\n\t\tif (mmp_state == MMP_STATE_ACTIVE)\n\t\t\treturn (ZPOOL_STATUS_HOSTID_ACTIVE);\n\t\telse if (mmp_state == MMP_STATE_NO_HOSTID)\n\t\t\treturn (ZPOOL_STATUS_HOSTID_REQUIRED);\n\t\telse\n\t\t\treturn (ZPOOL_STATUS_HOSTID_MISMATCH);\n\t}\n\n\t \n\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_HOSTID, &hostid);\n\tif (hostid != 0 && (unsigned long)hostid != system_hostid &&\n\t    stateval == POOL_STATE_ACTIVE)\n\t\treturn (ZPOOL_STATUS_HOSTID_MISMATCH);\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_VERSION_NEWER)\n\t\treturn (ZPOOL_STATUS_VERSION_NEWER);\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_UNSUP_FEAT) {\n\t\tnvlist_t *nvinfo = fnvlist_lookup_nvlist(config,\n\t\t    ZPOOL_CONFIG_LOAD_INFO);\n\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_CAN_RDONLY))\n\t\t\treturn (ZPOOL_STATUS_UNSUP_FEAT_WRITE);\n\t\treturn (ZPOOL_STATUS_UNSUP_FEAT_READ);\n\t}\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_BAD_GUID_SUM)\n\t\treturn (ZPOOL_STATUS_BAD_GUID_SUM);\n\n\t \n\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_SUSPENDED,\n\t    &suspended) == 0) {\n\t\tuint64_t reason;\n\n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_SUSPENDED_REASON,\n\t\t    &reason) == 0 && reason == ZIO_SUSPEND_MMP)\n\t\t\treturn (ZPOOL_STATUS_IO_FAILURE_MMP);\n\n\t\tif (suspended == ZIO_FAILURE_MODE_CONTINUE)\n\t\t\treturn (ZPOOL_STATUS_IO_FAILURE_CONTINUE);\n\t\treturn (ZPOOL_STATUS_IO_FAILURE_WAIT);\n\t}\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_BAD_LOG) {\n\t\treturn (ZPOOL_STATUS_BAD_LOG);\n\t}\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    find_vdev_problem(nvroot, vdev_faulted, B_TRUE))\n\t\treturn (ZPOOL_STATUS_FAULTED_DEV_NR);\n\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    find_vdev_problem(nvroot, vdev_missing, B_TRUE))\n\t\treturn (ZPOOL_STATUS_MISSING_DEV_NR);\n\n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    find_vdev_problem(nvroot, vdev_broken, B_TRUE))\n\t\treturn (ZPOOL_STATUS_CORRUPT_LABEL_NR);\n\n\t \n\tif (vs->vs_state == VDEV_STATE_CANT_OPEN &&\n\t    vs->vs_aux == VDEV_AUX_CORRUPT_DATA)\n\t\treturn (ZPOOL_STATUS_CORRUPT_POOL);\n\n\t \n\tif (!isimport) {\n\t\tuint64_t nerr;\n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_ERRCOUNT,\n\t\t    &nerr) == 0 && nerr != 0)\n\t\t\treturn (ZPOOL_STATUS_CORRUPT_DATA);\n\t}\n\n\t \n\tif (find_vdev_problem(nvroot, vdev_faulted, B_TRUE))\n\t\treturn (ZPOOL_STATUS_FAULTED_DEV_R);\n\tif (find_vdev_problem(nvroot, vdev_missing, B_TRUE))\n\t\treturn (ZPOOL_STATUS_MISSING_DEV_R);\n\tif (find_vdev_problem(nvroot, vdev_broken, B_TRUE))\n\t\treturn (ZPOOL_STATUS_CORRUPT_LABEL_R);\n\n\t \n\tif (!isimport && find_vdev_problem(nvroot, vdev_errors, B_TRUE))\n\t\treturn (ZPOOL_STATUS_FAILING_DEV);\n\n\t \n\tif (find_vdev_problem(nvroot, vdev_offlined, B_TRUE))\n\t\treturn (ZPOOL_STATUS_OFFLINE_DEV);\n\n\t \n\tif (find_vdev_problem(nvroot, vdev_removed, B_TRUE))\n\t\treturn (ZPOOL_STATUS_REMOVED_DEV);\n\n\t \n\tif (find_vdev_problem(nvroot, vdev_non_native_ashift, B_FALSE))\n\t\treturn (ZPOOL_STATUS_NON_NATIVE_ASHIFT);\n\n\t \n\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_ERRATA, &errata);\n\tif (errata) {\n\t\t*erratap = errata;\n\t\treturn (ZPOOL_STATUS_ERRATA);\n\t}\n\n\t \n\tif (SPA_VERSION_IS_SUPPORTED(version) && version != SPA_VERSION) {\n\t\t \n\t\tif (compat != NULL && strcmp(compat, ZPOOL_COMPAT_LEGACY) == 0)\n\t\t\treturn (ZPOOL_STATUS_OK);\n\t\telse\n\t\t\treturn (ZPOOL_STATUS_VERSION_OLDER);\n\t}\n\n\t \n\tif (version >= SPA_VERSION_FEATURES) {\n\t\tint i;\n\t\tnvlist_t *feat;\n\n\t\tif (isimport) {\n\t\t\tfeat = fnvlist_lookup_nvlist(config,\n\t\t\t    ZPOOL_CONFIG_LOAD_INFO);\n\t\t\tif (nvlist_exists(feat, ZPOOL_CONFIG_ENABLED_FEAT))\n\t\t\t\tfeat = fnvlist_lookup_nvlist(feat,\n\t\t\t\t    ZPOOL_CONFIG_ENABLED_FEAT);\n\t\t} else {\n\t\t\tfeat = fnvlist_lookup_nvlist(config,\n\t\t\t    ZPOOL_CONFIG_FEATURE_STATS);\n\t\t}\n\n\t\t \n\t\tboolean_t c_features[SPA_FEATURES];\n\n\t\tswitch (zpool_load_compat(compat, c_features, NULL, 0)) {\n\t\tcase ZPOOL_COMPATIBILITY_OK:\n\t\tcase ZPOOL_COMPATIBILITY_WARNTOKEN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (ZPOOL_STATUS_COMPATIBILITY_ERR);\n\t\t}\n\t\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\t\tzfeature_info_t *fi = &spa_feature_table[i];\n\t\t\tif (!fi->fi_zfs_mod_supported)\n\t\t\t\tcontinue;\n\t\t\tif (c_features[i] && !nvlist_exists(feat, fi->fi_guid))\n\t\t\t\treturn (ZPOOL_STATUS_FEAT_DISABLED);\n\t\t\tif (!c_features[i] && nvlist_exists(feat, fi->fi_guid))\n\t\t\t\treturn (ZPOOL_STATUS_INCOMPATIBLE_FEAT);\n\t\t}\n\t}\n\n\treturn (ZPOOL_STATUS_OK);\n}\n\nzpool_status_t\nzpool_get_status(zpool_handle_t *zhp, const char **msgid,\n    zpool_errata_t *errata)\n{\n\t \n\tchar compatibility[ZFS_MAXPROPLEN];\n\tif (zpool_get_prop(zhp, ZPOOL_PROP_COMPATIBILITY, compatibility,\n\t    ZFS_MAXPROPLEN, NULL, B_FALSE) != 0)\n\t\tcompatibility[0] = '\\0';\n\n\tzpool_status_t ret = check_status(zhp->zpool_config, B_FALSE, errata,\n\t    compatibility);\n\n\tif (msgid != NULL) {\n\t\tif (ret >= NMSGID)\n\t\t\t*msgid = NULL;\n\t\telse\n\t\t\t*msgid = zfs_msgid_table[ret];\n\t}\n\treturn (ret);\n}\n\nzpool_status_t\nzpool_import_status(nvlist_t *config, const char **msgid,\n    zpool_errata_t *errata)\n{\n\tzpool_status_t ret = check_status(config, B_TRUE, errata, NULL);\n\n\tif (ret >= NMSGID)\n\t\t*msgid = NULL;\n\telse\n\t\t*msgid = zfs_msgid_table[ret];\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}