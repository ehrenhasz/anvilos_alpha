{
  "module_name": "libzfs_diff.c",
  "hash_id": "7ab2281313e0ddd096d06f2ee15ebc097aa28e2f488d1c14ae92e67a4a996af6",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_diff.c",
  "human_readable_source": " \n\n \n\n \n#include <ctype.h>\n#include <errno.h>\n#include <libintl.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <sys/zfs_ioctl.h>\n#include <libzfs.h>\n#include <libzutil.h>\n#include \"libzfs_impl.h\"\n\n#define\tZDIFF_SNAPDIR\t\t\"/.zfs/snapshot/\"\n#define\tZDIFF_PREFIX\t\t\"zfs-diff-%d\"\n\n#define\tZDIFF_ADDED\t'+'\n#define\tZDIFF_MODIFIED\t\"M\"\n#define\tZDIFF_REMOVED\t'-'\n#define\tZDIFF_RENAMED\t\"R\"\n\n#define\tZDIFF_ADDED_COLOR    ANSI_GREEN\n#define\tZDIFF_MODIFIED_COLOR ANSI_YELLOW\n#define\tZDIFF_REMOVED_COLOR  ANSI_RED\n#define\tZDIFF_RENAMED_COLOR  ANSI_BOLD_BLUE\n\n \nstatic int\nget_stats_for_obj(differ_info_t *di, const char *dsname, uint64_t obj,\n    char *pn, int maxlen, zfs_stat_t *sb)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint error;\n\n\t(void) strlcpy(zc.zc_name, dsname, sizeof (zc.zc_name));\n\tzc.zc_obj = obj;\n\n\terrno = 0;\n\terror = zfs_ioctl(di->zhp->zfs_hdl, ZFS_IOC_OBJ_TO_STATS, &zc);\n\tdi->zerr = errno;\n\n\t \n\t(void) memcpy(sb, &zc.zc_stat, sizeof (zfs_stat_t));\n\tif (error == 0) {\n\t\tASSERT(di->zerr == 0);\n\t\t(void) strlcpy(pn, zc.zc_value, maxlen);\n\t\treturn (0);\n\t}\n\n\tif (di->zerr == ESTALE) {\n\t\t(void) snprintf(pn, maxlen, \"(on_delete_queue)\");\n\t\treturn (0);\n\t} else if (di->zerr == EPERM) {\n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"The sys_config privilege or diff delegated permission \"\n\t\t    \"is needed\\nto discover path names\"));\n\t\treturn (-1);\n\t} else if (di->zerr == EACCES) {\n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"Key must be loaded to discover path names\"));\n\t\treturn (-1);\n\t} else {\n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"Unable to determine path or stats for \"\n\t\t    \"object %lld in %s\"), (longlong_t)obj, dsname);\n\t\treturn (-1);\n\t}\n}\n\n \nstatic void\nstream_bytes(FILE *fp, const char *string)\n{\n\tchar c;\n\n\twhile ((c = *string++) != '\\0') {\n\t\tif (c > ' ' && c != '\\\\' && c < '\\177') {\n\t\t\t(void) fputc(c, fp);\n\t\t} else {\n\t\t\t(void) fprintf(fp, \"\\\\%04hho\", (uint8_t)c);\n\t\t}\n\t}\n}\n\n \nstatic const char *\ntype_to_color(char type)\n{\n\tif (type == '+')\n\t\treturn (ZDIFF_ADDED_COLOR);\n\telse if (type == '-')\n\t\treturn (ZDIFF_REMOVED_COLOR);\n\telse if (type == 'M')\n\t\treturn (ZDIFF_MODIFIED_COLOR);\n\telse if (type == 'R')\n\t\treturn (ZDIFF_RENAMED_COLOR);\n\telse\n\t\treturn (NULL);\n}\n\n\nstatic char\nget_what(mode_t what)\n{\n\tswitch (what & S_IFMT) {\n\tcase S_IFBLK:\n\t\treturn ('B');\n\tcase S_IFCHR:\n\t\treturn ('C');\n\tcase S_IFDIR:\n\t\treturn ('/');\n#ifdef S_IFDOOR\n\tcase S_IFDOOR:\n\t\treturn ('>');\n#endif\n\tcase S_IFIFO:\n\t\treturn ('|');\n\tcase S_IFLNK:\n\t\treturn ('@');\n#ifdef S_IFPORT\n\tcase S_IFPORT:\n\t\treturn ('P');\n#endif\n\tcase S_IFSOCK:\n\t\treturn ('=');\n\tcase S_IFREG:\n\t\treturn ('F');\n\tdefault:\n\t\treturn ('?');\n\t}\n}\n\nstatic void\nprint_cmn(FILE *fp, differ_info_t *di, const char *file)\n{\n\tif (!di->no_mangle) {\n\t\tstream_bytes(fp, di->dsmnt);\n\t\tstream_bytes(fp, file);\n\t} else {\n\t\t(void) fputs(di->dsmnt, fp);\n\t\t(void) fputs(file, fp);\n\t}\n}\n\nstatic void\nprint_rename(FILE *fp, differ_info_t *di, const char *old, const char *new,\n    zfs_stat_t *isb)\n{\n\tif (isatty(fileno(fp)))\n\t\tcolor_start(ZDIFF_RENAMED_COLOR);\n\tif (di->timestamped)\n\t\t(void) fprintf(fp, \"%10lld.%09lld\\t\",\n\t\t    (longlong_t)isb->zs_ctime[0],\n\t\t    (longlong_t)isb->zs_ctime[1]);\n\t(void) fputs(ZDIFF_RENAMED \"\\t\", fp);\n\tif (di->classify)\n\t\t(void) fprintf(fp, \"%c\\t\", get_what(isb->zs_mode));\n\tprint_cmn(fp, di, old);\n\t(void) fputs(di->scripted ? \"\\t\" : \" -> \", fp);\n\tprint_cmn(fp, di, new);\n\t(void) fputc('\\n', fp);\n\n\tif (isatty(fileno(fp)))\n\t\tcolor_end();\n}\n\nstatic void\nprint_link_change(FILE *fp, differ_info_t *di, int delta, const char *file,\n    zfs_stat_t *isb)\n{\n\tif (isatty(fileno(fp)))\n\t\tcolor_start(ZDIFF_MODIFIED_COLOR);\n\n\tif (di->timestamped)\n\t\t(void) fprintf(fp, \"%10lld.%09lld\\t\",\n\t\t    (longlong_t)isb->zs_ctime[0],\n\t\t    (longlong_t)isb->zs_ctime[1]);\n\t(void) fputs(ZDIFF_MODIFIED \"\\t\", fp);\n\tif (di->classify)\n\t\t(void) fprintf(fp, \"%c\\t\", get_what(isb->zs_mode));\n\tprint_cmn(fp, di, file);\n\t(void) fprintf(fp, \"\\t(%+d)\\n\", delta);\n\tif (isatty(fileno(fp)))\n\t\tcolor_end();\n}\n\nstatic void\nprint_file(FILE *fp, differ_info_t *di, char type, const char *file,\n    zfs_stat_t *isb)\n{\n\tif (isatty(fileno(fp)))\n\t\tcolor_start(type_to_color(type));\n\n\tif (di->timestamped)\n\t\t(void) fprintf(fp, \"%10lld.%09lld\\t\",\n\t\t    (longlong_t)isb->zs_ctime[0],\n\t\t    (longlong_t)isb->zs_ctime[1]);\n\t(void) fprintf(fp, \"%c\\t\", type);\n\tif (di->classify)\n\t\t(void) fprintf(fp, \"%c\\t\", get_what(isb->zs_mode));\n\tprint_cmn(fp, di, file);\n\t(void) fputc('\\n', fp);\n\n\tif (isatty(fileno(fp)))\n\t\tcolor_end();\n}\n\nstatic int\nwrite_inuse_diffs_one(FILE *fp, differ_info_t *di, uint64_t dobj)\n{\n\tstruct zfs_stat fsb, tsb;\n\tmode_t fmode, tmode;\n\tchar fobjname[MAXPATHLEN], tobjname[MAXPATHLEN];\n\tboolean_t already_logged = B_FALSE;\n\tint fobjerr, tobjerr;\n\tint change;\n\n\tif (dobj == di->shares)\n\t\treturn (0);\n\n\t \n\n\tfobjerr = get_stats_for_obj(di, di->fromsnap, dobj, fobjname,\n\t    MAXPATHLEN, &fsb);\n\tif (fobjerr && di->zerr != ENOTSUP && di->zerr != ENOENT) {\n\t\tzfs_error_aux(di->zhp->zfs_hdl, \"%s\", strerror(di->zerr));\n\t\tzfs_error(di->zhp->zfs_hdl, di->zerr, di->errbuf);\n\t\t \n\t\talready_logged = B_TRUE;\n\t}\n\n\ttobjerr = get_stats_for_obj(di, di->tosnap, dobj, tobjname,\n\t    MAXPATHLEN, &tsb);\n\n\tif (tobjerr && di->zerr != ENOTSUP && di->zerr != ENOENT) {\n\t\tif (!already_logged) {\n\t\t\tzfs_error_aux(di->zhp->zfs_hdl,\n\t\t\t    \"%s\", strerror(di->zerr));\n\t\t\tzfs_error(di->zhp->zfs_hdl, di->zerr, di->errbuf);\n\t\t}\n\t}\n\t \n\tif (fobjerr && tobjerr) {\n\t\tdi->zerr = 0;\n\t\treturn (0);\n\t}\n\n\tdi->zerr = 0;  \n\tfmode = fsb.zs_mode & S_IFMT;\n\ttmode = tsb.zs_mode & S_IFMT;\n\tif (fmode == S_IFDIR || tmode == S_IFDIR || fsb.zs_links == 0 ||\n\t    tsb.zs_links == 0)\n\t\tchange = 0;\n\telse\n\t\tchange = tsb.zs_links - fsb.zs_links;\n\n\tif (fobjerr) {\n\t\tif (change) {\n\t\t\tprint_link_change(fp, di, change, tobjname, &tsb);\n\t\t\treturn (0);\n\t\t}\n\t\tprint_file(fp, di, ZDIFF_ADDED, tobjname, &tsb);\n\t\treturn (0);\n\t} else if (tobjerr) {\n\t\tif (change) {\n\t\t\tprint_link_change(fp, di, change, fobjname, &fsb);\n\t\t\treturn (0);\n\t\t}\n\t\tprint_file(fp, di, ZDIFF_REMOVED, fobjname, &fsb);\n\t\treturn (0);\n\t}\n\n\tif (fmode != tmode && fsb.zs_gen == tsb.zs_gen)\n\t\ttsb.zs_gen++;\t \n\n\t \n\tif (fsb.zs_gen == tsb.zs_gen) {\n\t\t \n\t\tif (fsb.zs_ctime[0] == tsb.zs_ctime[0] &&\n\t\t    fsb.zs_ctime[1] == tsb.zs_ctime[1])\n\t\t\treturn (0);\n\t\tif (change) {\n\t\t\tprint_link_change(fp, di, change,\n\t\t\t    change > 0 ? fobjname : tobjname, &tsb);\n\t\t} else if (strcmp(fobjname, tobjname) == 0) {\n\t\t\tprint_file(fp, di, *ZDIFF_MODIFIED, fobjname, &tsb);\n\t\t} else {\n\t\t\tprint_rename(fp, di, fobjname, tobjname, &tsb);\n\t\t}\n\t\treturn (0);\n\t} else {\n\t\t \n\t\tprint_file(fp, di, ZDIFF_REMOVED, fobjname, &fsb);\n\t\tprint_file(fp, di, ZDIFF_ADDED, tobjname, &tsb);\n\t\treturn (0);\n\t}\n}\n\nstatic int\nwrite_inuse_diffs(FILE *fp, differ_info_t *di, dmu_diff_record_t *dr)\n{\n\tuint64_t o;\n\tint err;\n\n\tfor (o = dr->ddr_first; o <= dr->ddr_last; o++) {\n\t\tif ((err = write_inuse_diffs_one(fp, di, o)) != 0)\n\t\t\treturn (err);\n\t}\n\treturn (0);\n}\n\nstatic int\ndescribe_free(FILE *fp, differ_info_t *di, uint64_t object, char *namebuf,\n    int maxlen)\n{\n\tstruct zfs_stat sb;\n\n\t(void) get_stats_for_obj(di, di->fromsnap, object, namebuf,\n\t    maxlen, &sb);\n\n\t \n\tif (di->zerr == ESTALE || di->zerr == ENOENT) {\n\t\tdi->zerr = 0;\n\t\treturn (0);\n\t}\n\n\tprint_file(fp, di, ZDIFF_REMOVED, namebuf, &sb);\n\treturn (0);\n}\n\nstatic int\nwrite_free_diffs(FILE *fp, differ_info_t *di, dmu_diff_record_t *dr)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *lhdl = di->zhp->zfs_hdl;\n\tchar fobjname[MAXPATHLEN];\n\n\t(void) strlcpy(zc.zc_name, di->fromsnap, sizeof (zc.zc_name));\n\tzc.zc_obj = dr->ddr_first - 1;\n\n\tASSERT(di->zerr == 0);\n\n\twhile (zc.zc_obj < dr->ddr_last) {\n\t\tint err;\n\n\t\terr = zfs_ioctl(lhdl, ZFS_IOC_NEXT_OBJ, &zc);\n\t\tif (err == 0) {\n\t\t\tif (zc.zc_obj == di->shares) {\n\t\t\t\tzc.zc_obj++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (zc.zc_obj > dr->ddr_last) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(void) describe_free(fp, di, zc.zc_obj, fobjname,\n\t\t\t    MAXPATHLEN);\n\t\t} else if (errno == ESRCH) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"next allocated object (> %lld) find failure\"),\n\t\t\t    (longlong_t)zc.zc_obj);\n\t\t\tdi->zerr = errno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (di->zerr)\n\t\treturn (-1);\n\treturn (0);\n}\n\nstatic void *\ndiffer(void *arg)\n{\n\tdiffer_info_t *di = arg;\n\tdmu_diff_record_t dr;\n\tFILE *ofp;\n\tint err = 0;\n\n\tif ((ofp = fdopen(di->outputfd, \"w\")) == NULL) {\n\t\tdi->zerr = errno;\n\t\tstrlcpy(di->errbuf, strerror(errno), sizeof (di->errbuf));\n\t\t(void) close(di->datafd);\n\t\treturn ((void *)-1);\n\t}\n\n\tfor (;;) {\n\t\tchar *cp = (char *)&dr;\n\t\tint len = sizeof (dr);\n\t\tint rv;\n\n\t\tdo {\n\t\t\trv = read(di->datafd, cp, len);\n\t\t\tcp += rv;\n\t\t\tlen -= rv;\n\t\t} while (len > 0 && rv > 0);\n\n\t\tif (rv < 0 || (rv == 0 && len != sizeof (dr))) {\n\t\t\tdi->zerr = EPIPE;\n\t\t\tbreak;\n\t\t} else if (rv == 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (dr.ddr_type) {\n\t\tcase DDR_FREE:\n\t\t\terr = write_free_diffs(ofp, di, &dr);\n\t\t\tbreak;\n\t\tcase DDR_INUSE:\n\t\t\terr = write_inuse_diffs(ofp, di, &dr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdi->zerr = EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err || di->zerr)\n\t\t\tbreak;\n\t}\n\n\t(void) fclose(ofp);\n\t(void) close(di->datafd);\n\tif (err)\n\t\treturn ((void *)-1);\n\tif (di->zerr) {\n\t\tASSERT(di->zerr == EPIPE);\n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"Internal error: bad data from diff IOCTL\"));\n\t\treturn ((void *)-1);\n\t}\n\treturn ((void *)0);\n}\n\nstatic int\nmake_temp_snapshot(differ_info_t *di)\n{\n\tlibzfs_handle_t *hdl = di->zhp->zfs_hdl;\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\t(void) snprintf(zc.zc_value, sizeof (zc.zc_value),\n\t    ZDIFF_PREFIX, getpid());\n\t(void) strlcpy(zc.zc_name, di->ds, sizeof (zc.zc_name));\n\tzc.zc_cleanup_fd = di->cleanupfd;\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_TMP_SNAPSHOT, &zc) != 0) {\n\t\tint err = errno;\n\t\tif (err == EPERM) {\n\t\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN, \"The diff delegated \"\n\t\t\t    \"permission is needed in order\\nto create a \"\n\t\t\t    \"just-in-time snapshot for diffing\\n\"));\n\t\t\treturn (zfs_error(hdl, EZFS_DIFF, di->errbuf));\n\t\t} else {\n\t\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN, \"Cannot create just-in-time \"\n\t\t\t    \"snapshot of '%s'\"), zc.zc_name);\n\t\t\treturn (zfs_standard_error(hdl, err, di->errbuf));\n\t\t}\n\t}\n\n\tdi->tmpsnap = zfs_strdup(hdl, zc.zc_value);\n\tdi->tosnap = zfs_asprintf(hdl, \"%s@%s\", di->ds, di->tmpsnap);\n\treturn (0);\n}\n\nstatic void\nteardown_differ_info(differ_info_t *di)\n{\n\tfree(di->ds);\n\tfree(di->dsmnt);\n\tfree(di->fromsnap);\n\tfree(di->frommnt);\n\tfree(di->tosnap);\n\tfree(di->tmpsnap);\n\tfree(di->tomnt);\n\t(void) close(di->cleanupfd);\n}\n\nstatic int\nget_snapshot_names(differ_info_t *di, const char *fromsnap,\n    const char *tosnap)\n{\n\tlibzfs_handle_t *hdl = di->zhp->zfs_hdl;\n\tchar *atptrf = NULL;\n\tchar *atptrt = NULL;\n\tint fdslen, fsnlen;\n\tint tdslen, tsnlen;\n\n\t \n\tif (tosnap == NULL) {\n\t\t \n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"Badly formed snapshot name %s\"), fromsnap);\n\n\t\tif (!zfs_validate_name(hdl, fromsnap, ZFS_TYPE_SNAPSHOT,\n\t\t    B_FALSE)) {\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME,\n\t\t\t    di->errbuf));\n\t\t}\n\n\t\tatptrf = strchr(fromsnap, '@');\n\t\tASSERT(atptrf != NULL);\n\t\tfdslen = atptrf - fromsnap;\n\n\t\tdi->fromsnap = zfs_strdup(hdl, fromsnap);\n\t\tdi->ds = zfs_strdup(hdl, fromsnap);\n\t\tdi->ds[fdslen] = '\\0';\n\n\t\t \n\t\treturn (make_temp_snapshot(di));\n\t}\n\n\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t    dgettext(TEXT_DOMAIN,\n\t    \"Unable to determine which snapshots to compare\"));\n\n\tatptrf = strchr(fromsnap, '@');\n\tatptrt = strchr(tosnap, '@');\n\tfdslen = atptrf ? atptrf - fromsnap : strlen(fromsnap);\n\ttdslen = atptrt ? atptrt - tosnap : strlen(tosnap);\n\tfsnlen = strlen(fromsnap) - fdslen;\t \n\ttsnlen = strlen(tosnap) - tdslen;\t \n\n\tif (fsnlen <= 1 || tsnlen == 1 || (fdslen == 0 && tdslen == 0)) {\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, di->errbuf));\n\t} else if ((fdslen > 0 && tdslen > 0) &&\n\t    ((tdslen != fdslen || strncmp(fromsnap, tosnap, fdslen) != 0))) {\n\t\t \n\t\tchar origin[ZFS_MAX_DATASET_NAME_LEN];\n\t\tzprop_source_t src;\n\t\tzfs_handle_t *zhp;\n\n\t\tdi->ds = zfs_alloc(di->zhp->zfs_hdl, tdslen + 1);\n\t\t(void) strlcpy(di->ds, tosnap, tdslen + 1);\n\n\t\tzhp = zfs_open(hdl, di->ds, ZFS_TYPE_FILESYSTEM);\n\t\twhile (zhp != NULL) {\n\t\t\tif (zfs_prop_get(zhp, ZFS_PROP_ORIGIN, origin,\n\t\t\t    sizeof (origin), &src, NULL, 0, B_FALSE) != 0) {\n\t\t\t\t(void) zfs_close(zhp);\n\t\t\t\tzhp = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strncmp(origin, fromsnap, fsnlen) == 0)\n\t\t\t\tbreak;\n\n\t\t\t(void) zfs_close(zhp);\n\t\t\tzhp = zfs_open(hdl, origin, ZFS_TYPE_FILESYSTEM);\n\t\t}\n\n\t\tif (zhp == NULL) {\n\t\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"Not an earlier snapshot from the same fs\"));\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, di->errbuf));\n\t\t} else {\n\t\t\t(void) zfs_close(zhp);\n\t\t}\n\n\t\tdi->isclone = B_TRUE;\n\t\tdi->fromsnap = zfs_strdup(hdl, fromsnap);\n\t\tif (tsnlen)\n\t\t\tdi->tosnap = zfs_strdup(hdl, tosnap);\n\t\telse\n\t\t\treturn (make_temp_snapshot(di));\n\t} else {\n\t\tint dslen = fdslen ? fdslen : tdslen;\n\n\t\tdi->ds = zfs_alloc(hdl, dslen + 1);\n\t\t(void) strlcpy(di->ds, fdslen ? fromsnap : tosnap, dslen + 1);\n\n\t\tdi->fromsnap = zfs_asprintf(hdl, \"%s%s\", di->ds, atptrf);\n\t\tif (tsnlen) {\n\t\t\tdi->tosnap = zfs_asprintf(hdl, \"%s%s\", di->ds, atptrt);\n\t\t} else {\n\t\t\treturn (make_temp_snapshot(di));\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nget_mountpoint(differ_info_t *di, char *dsnm, char **mntpt)\n{\n\tboolean_t mounted;\n\n\tmounted = is_mounted(di->zhp->zfs_hdl, dsnm, mntpt);\n\tif (mounted == B_FALSE) {\n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"Cannot diff an unmounted snapshot\"));\n\t\treturn (zfs_error(di->zhp->zfs_hdl, EZFS_BADTYPE, di->errbuf));\n\t}\n\n\t \n\tif (**mntpt == '/' && *(*mntpt + 1) == '\\0')\n\t\t**mntpt = '\\0';\n\treturn (0);\n}\n\nstatic int\nget_mountpoints(differ_info_t *di)\n{\n\tchar *strptr;\n\tchar *frommntpt;\n\n\t \n\tif (get_mountpoint(di, di->ds, &di->dsmnt) != 0)\n\t\treturn (-1);\n\n\tstrptr = strchr(di->tosnap, '@');\n\tASSERT3P(strptr, !=, NULL);\n\tdi->tomnt = zfs_asprintf(di->zhp->zfs_hdl, \"%s%s%s\", di->dsmnt,\n\t    ZDIFF_SNAPDIR, ++strptr);\n\n\tstrptr = strchr(di->fromsnap, '@');\n\tASSERT3P(strptr, !=, NULL);\n\n\tfrommntpt = di->dsmnt;\n\tif (di->isclone) {\n\t\tchar *mntpt;\n\t\tint err;\n\n\t\t*strptr = '\\0';\n\t\terr = get_mountpoint(di, di->fromsnap, &mntpt);\n\t\t*strptr = '@';\n\t\tif (err != 0)\n\t\t\treturn (-1);\n\t\tfrommntpt = mntpt;\n\t}\n\n\tdi->frommnt = zfs_asprintf(di->zhp->zfs_hdl, \"%s%s%s\", frommntpt,\n\t    ZDIFF_SNAPDIR, ++strptr);\n\n\tif (di->isclone)\n\t\tfree(frommntpt);\n\n\treturn (0);\n}\n\nstatic int\nsetup_differ_info(zfs_handle_t *zhp, const char *fromsnap,\n    const char *tosnap, differ_info_t *di)\n{\n\tdi->zhp = zhp;\n\n\tdi->cleanupfd = open(ZFS_DEV, O_RDWR | O_CLOEXEC);\n\tVERIFY(di->cleanupfd >= 0);\n\n\tif (get_snapshot_names(di, fromsnap, tosnap) != 0)\n\t\treturn (-1);\n\n\tif (get_mountpoints(di) != 0)\n\t\treturn (-1);\n\n\tif (find_shares_object(di) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\nint\nzfs_show_diffs(zfs_handle_t *zhp, int outfd, const char *fromsnap,\n    const char *tosnap, int flags)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[ERRBUFLEN];\n\tdiffer_info_t di = { 0 };\n\tpthread_t tid;\n\tint pipefd[2];\n\tint iocerr;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"zfs diff failed\"));\n\n\tif (setup_differ_info(zhp, fromsnap, tosnap, &di)) {\n\t\tteardown_differ_info(&di);\n\t\treturn (-1);\n\t}\n\n\tif (pipe2(pipefd, O_CLOEXEC)) {\n\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(errno));\n\t\tteardown_differ_info(&di);\n\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_PIPEFAILED, errbuf));\n\t}\n\n\tdi.scripted = (flags & ZFS_DIFF_PARSEABLE);\n\tdi.classify = (flags & ZFS_DIFF_CLASSIFY);\n\tdi.timestamped = (flags & ZFS_DIFF_TIMESTAMP);\n\tdi.no_mangle = (flags & ZFS_DIFF_NO_MANGLE);\n\n\tdi.outputfd = outfd;\n\tdi.datafd = pipefd[0];\n\n\tif (pthread_create(&tid, NULL, differ, &di)) {\n\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(errno));\n\t\t(void) close(pipefd[0]);\n\t\t(void) close(pipefd[1]);\n\t\tteardown_differ_info(&di);\n\t\treturn (zfs_error(zhp->zfs_hdl,\n\t\t    EZFS_THREADCREATEFAILED, errbuf));\n\t}\n\n\t \n\t(void) strlcpy(zc.zc_value, di.fromsnap, strlen(di.fromsnap) + 1);\n\t(void) strlcpy(zc.zc_name, di.tosnap, strlen(di.tosnap) + 1);\n\tzc.zc_cookie = pipefd[1];\n\n\tiocerr = zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_DIFF, &zc);\n\tif (iocerr != 0) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"Unable to obtain diffs\"));\n\t\tif (errno == EPERM) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"\\n   The sys_mount privilege or diff delegated \"\n\t\t\t    \"permission is needed\\n   to execute the \"\n\t\t\t    \"diff ioctl\"));\n\t\t} else if (errno == EXDEV) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"\\n   Not an earlier snapshot from the same fs\"));\n\t\t} else if (errno != EPIPE || di.zerr == 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(errno));\n\t\t}\n\t\t(void) close(pipefd[1]);\n\t\t(void) pthread_cancel(tid);\n\t\t(void) pthread_join(tid, NULL);\n\t\tteardown_differ_info(&di);\n\t\tif (di.zerr != 0 && di.zerr != EPIPE) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(di.zerr));\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_DIFF, di.errbuf));\n\t\t} else {\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_DIFFDATA, errbuf));\n\t\t}\n\t}\n\n\t(void) close(pipefd[1]);\n\t(void) pthread_join(tid, NULL);\n\n\tif (di.zerr != 0) {\n\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(di.zerr));\n\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_DIFF, di.errbuf));\n\t}\n\tteardown_differ_info(&di);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}