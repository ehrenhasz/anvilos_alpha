{
  "module_name": "libzfs_util_os.c",
  "hash_id": "29bbe0aecb361ba42472110b461ada0d8709fa195cff051193b2c9a6363e8655",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/os/linux/libzfs_util_os.c",
  "human_readable_source": " \n\n \n\n#include <alloca.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libintl.h>\n#include <math.h>\n#include <poll.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <sys/inotify.h>\n#include <sys/mntent.h>\n#include <sys/mnttab.h>\n#include <sys/stat.h>\n#include <sys/timerfd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <libzfs.h>\n#include <libzfs_core.h>\n\n#include \"../../libzfs_impl.h\"\n#include \"zfs_prop.h\"\n#include <libzutil.h>\n#include <sys/zfs_sysfs.h>\n\n#define\tZDIFF_SHARESDIR\t\t\"/.zfs/shares/\"\n\nint\nzfs_ioctl(libzfs_handle_t *hdl, int request, zfs_cmd_t *zc)\n{\n\treturn (ioctl(hdl->libzfs_fd, request, zc));\n}\n\nconst char *\nlibzfs_error_init(int error)\n{\n\tswitch (error) {\n\tcase ENXIO:\n\t\treturn (dgettext(TEXT_DOMAIN, \"The ZFS modules are not \"\n\t\t    \"loaded.\\nTry running 'modprobe zfs' as root \"\n\t\t    \"to load them.\"));\n\tcase ENOENT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"/dev/zfs and /proc/self/mounts \"\n\t\t    \"are required.\\nTry running 'udevadm trigger' and 'mount \"\n\t\t    \"-t proc proc /proc' as root.\"));\n\tcase ENOEXEC:\n\t\treturn (dgettext(TEXT_DOMAIN, \"The ZFS modules cannot be \"\n\t\t    \"auto-loaded.\\nTry running 'modprobe zfs' as \"\n\t\t    \"root to manually load them.\"));\n\tcase EACCES:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Permission denied the \"\n\t\t    \"ZFS utilities must be run as root.\"));\n\tdefault:\n\t\treturn (dgettext(TEXT_DOMAIN, \"Failed to initialize the \"\n\t\t    \"libzfs library.\"));\n\t}\n}\n\n \nint\nlibzfs_load_module(void)\n{\n\tif (access(ZFS_DEV, F_OK) == 0)\n\t\treturn (0);\n\n\tif (access(ZFS_SYSFS_DIR, F_OK) != 0) {\n\t\tchar *argv[] = {(char *)\"modprobe\", (char *)\"zfs\", NULL};\n\t\tif (libzfs_run_process(\"modprobe\", argv, 0))\n\t\t\treturn (ENOEXEC);\n\n\t\tif (access(ZFS_SYSFS_DIR, F_OK) != 0)\n\t\t\treturn (ENXIO);\n\t}\n\n\tconst char *timeout_str = getenv(\"ZFS_MODULE_TIMEOUT\");\n\tint seconds = 10;\n\tif (timeout_str)\n\t\tseconds = MIN(strtol(timeout_str, NULL, 0), 600);\n\tstruct itimerspec timeout = {.it_value.tv_sec = MAX(seconds, 0)};\n\n\tint ino = inotify_init1(IN_CLOEXEC);\n\tif (ino == -1)\n\t\treturn (ENOENT);\n\tinotify_add_watch(ino, ZFS_DEVDIR, IN_CREATE);\n\n\tif (access(ZFS_DEV, F_OK) == 0) {\n\t\tclose(ino);\n\t\treturn (0);\n\t} else if (seconds == 0) {\n\t\tclose(ino);\n\t\treturn (ENOENT);\n\t}\n\n\tsize_t evsz = sizeof (struct inotify_event) + NAME_MAX + 1;\n\tstruct inotify_event *ev = alloca(evsz);\n\n\tint tout = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);\n\tif (tout == -1) {\n\t\tclose(ino);\n\t\treturn (ENOENT);\n\t}\n\ttimerfd_settime(tout, 0, &timeout, NULL);\n\n\tint ret = ENOENT;\n\tstruct pollfd pfds[] = {\n\t\t{.fd = ino, .events = POLLIN},\n\t\t{.fd = tout, .events = POLLIN},\n\t};\n\twhile (poll(pfds, ARRAY_SIZE(pfds), -1) != -1) {\n\t\tif (pfds[0].revents & POLLIN) {\n\t\t\tverify(read(ino, ev, evsz) >\n\t\t\t    sizeof (struct inotify_event));\n\t\t\tif (strncmp(ev->name, &ZFS_DEV[sizeof (ZFS_DEVDIR)],\n\t\t\t    ev->len) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pfds[1].revents & POLLIN)\n\t\t\tbreak;\n\t}\n\tclose(tout);\n\tclose(ino);\n\treturn (ret);\n}\n\nint\nfind_shares_object(differ_info_t *di)\n{\n\tchar fullpath[MAXPATHLEN];\n\tstruct stat64 sb = { 0 };\n\n\t(void) strlcpy(fullpath, di->dsmnt, MAXPATHLEN);\n\t(void) strlcat(fullpath, ZDIFF_SHARESDIR, MAXPATHLEN);\n\n\tif (stat64(fullpath, &sb) != 0) {\n\t\t(void) snprintf(di->errbuf, sizeof (di->errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"Cannot stat %s\"), fullpath);\n\t\treturn (zfs_error(di->zhp->zfs_hdl, EZFS_DIFF, di->errbuf));\n\t}\n\n\tdi->shares = (uint64_t)sb.st_ino;\n\treturn (0);\n}\n\nint\nzfs_destroy_snaps_nvl_os(libzfs_handle_t *hdl, nvlist_t *snaps)\n{\n\t(void) hdl, (void) snaps;\n\treturn (0);\n}\n\n \nchar *\nzfs_version_kernel(void)\n{\n\tFILE *f = fopen(ZFS_SYSFS_DIR \"/version\", \"re\");\n\tif (f == NULL)\n\t\treturn (NULL);\n\n\tchar *ret = NULL;\n\tsize_t l;\n\tssize_t read;\n\tif ((read = getline(&ret, &l, f)) == -1) {\n\t\tint err = errno;\n\t\tfclose(f);\n\t\terrno = err;\n\t\treturn (NULL);\n\t}\n\n\tfclose(f);\n\tif (ret[read - 1] == '\\n')\n\t\tret[read - 1] = '\\0';\n\treturn (ret);\n}\n\n \nint\nzfs_userns(zfs_handle_t *zhp, const char *nspath, int attach)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar errbuf[1024];\n\tunsigned long cmd;\n\tint ret;\n\n\tif (attach) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot add '%s' to namespace\"),\n\t\t    zhp->zfs_name);\n\t} else {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot remove '%s' from namespace\"),\n\t\t    zhp->zfs_name);\n\t}\n\n\tswitch (zhp->zfs_type) {\n\tcase ZFS_TYPE_VOLUME:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"volumes can not be namespaced\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_SNAPSHOT:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"snapshots can not be namespaced\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_BOOKMARK:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"bookmarks can not be namespaced\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_VDEV:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"vdevs can not be namespaced\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_INVALID:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid zfs_type_t: ZFS_TYPE_INVALID\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_POOL:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"pools can not be namespaced\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_FILESYSTEM:\n\t\tbreak;\n\t}\n\tassert(zhp->zfs_type == ZFS_TYPE_FILESYSTEM);\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\tzc.zc_objset_type = DMU_OST_ZFS;\n\tzc.zc_cleanup_fd = open(nspath, O_RDONLY);\n\tif (zc.zc_cleanup_fd < 0) {\n\t\treturn (zfs_error(hdl, EZFS_NOT_USER_NAMESPACE, errbuf));\n\t}\n\n\tcmd = attach ? ZFS_IOC_USERNS_ATTACH : ZFS_IOC_USERNS_DETACH;\n\tif ((ret = zfs_ioctl(hdl, cmd, &zc)) != 0)\n\t\tzfs_standard_error(hdl, errno, errbuf);\n\n\t(void) close(zc.zc_cleanup_fd);\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}