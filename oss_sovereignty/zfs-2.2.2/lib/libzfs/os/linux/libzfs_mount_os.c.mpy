{
  "module_name": "libzfs_mount_os.c",
  "hash_id": "a43770644929812f5b15d4af213c87599cd085ddc43a23e42026cfd263acef56",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/os/linux/libzfs_mount_os.c",
  "human_readable_source": " \n\n \n\n#include <dirent.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <libintl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <zone.h>\n#include <sys/mntent.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <sys/dsl_crypt.h>\n#include <libzfs.h>\n\n#include \"../../libzfs_impl.h\"\n#include <thread_pool.h>\n\n#define\tZS_COMMENT\t0x00000000\t \n#define\tZS_ZFSUTIL\t0x00000001\t \n\ntypedef struct option_map {\n\tconst char *name;\n\tunsigned long mntmask;\n\tunsigned long zfsmask;\n} option_map_t;\n\nstatic const option_map_t option_map[] = {\n\t \n\t{ MNTOPT_NOAUTO,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_DEFAULTS,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_NODEVICES,\tMS_NODEV,\tZS_COMMENT\t},\n\t{ MNTOPT_DEVICES,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_DIRSYNC,\tMS_DIRSYNC,\tZS_COMMENT\t},\n\t{ MNTOPT_NOEXEC,\tMS_NOEXEC,\tZS_COMMENT\t},\n\t{ MNTOPT_EXEC,\t\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_GROUP,\t\tMS_GROUP,\tZS_COMMENT\t},\n\t{ MNTOPT_NETDEV,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_NOFAIL,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_NOSUID,\tMS_NOSUID,\tZS_COMMENT\t},\n\t{ MNTOPT_SUID,\t\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_OWNER,\t\tMS_OWNER,\tZS_COMMENT\t},\n\t{ MNTOPT_REMOUNT,\tMS_REMOUNT,\tZS_COMMENT\t},\n\t{ MNTOPT_RO,\t\tMS_RDONLY,\tZS_COMMENT\t},\n\t{ MNTOPT_RW,\t\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_SYNC,\t\tMS_SYNCHRONOUS,\tZS_COMMENT\t},\n\t{ MNTOPT_USER,\t\tMS_USERS,\tZS_COMMENT\t},\n\t{ MNTOPT_USERS,\t\tMS_USERS,\tZS_COMMENT\t},\n\t \n\t{ MNTOPT_ACL,\t\tMS_POSIXACL,\tZS_COMMENT\t},\n\t{ MNTOPT_NOACL,\t\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_POSIXACL,\tMS_POSIXACL,\tZS_COMMENT\t},\n\t \n\t{ MNTOPT_CASESENSITIVE,\t\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_CASEINSENSITIVE,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_CASEMIXED,\t\tMS_COMMENT,\tZS_COMMENT\t},\n#ifdef MS_NOATIME\n\t{ MNTOPT_NOATIME,\tMS_NOATIME,\tZS_COMMENT\t},\n\t{ MNTOPT_ATIME,\t\tMS_COMMENT,\tZS_COMMENT\t},\n#endif\n#ifdef MS_NODIRATIME\n\t{ MNTOPT_NODIRATIME,\tMS_NODIRATIME,\tZS_COMMENT\t},\n\t{ MNTOPT_DIRATIME,\tMS_COMMENT,\tZS_COMMENT\t},\n#endif\n#ifdef MS_RELATIME\n\t{ MNTOPT_RELATIME,\tMS_RELATIME,\tZS_COMMENT\t},\n\t{ MNTOPT_NORELATIME,\tMS_COMMENT,\tZS_COMMENT\t},\n#endif\n#ifdef MS_STRICTATIME\n\t{ MNTOPT_STRICTATIME,\tMS_STRICTATIME,\tZS_COMMENT\t},\n\t{ MNTOPT_NOSTRICTATIME,\tMS_COMMENT,\tZS_COMMENT\t},\n#endif\n#ifdef MS_LAZYTIME\n\t{ MNTOPT_LAZYTIME,\tMS_LAZYTIME,\tZS_COMMENT\t},\n#endif\n\t{ MNTOPT_CONTEXT,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_FSCONTEXT,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_DEFCONTEXT,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_ROOTCONTEXT,\tMS_COMMENT,\tZS_COMMENT\t},\n#ifdef MS_I_VERSION\n\t{ MNTOPT_IVERSION,\tMS_I_VERSION,\tZS_COMMENT\t},\n#endif\n#ifdef MS_MANDLOCK\n\t{ MNTOPT_NBMAND,\tMS_MANDLOCK,\tZS_COMMENT\t},\n\t{ MNTOPT_NONBMAND,\tMS_COMMENT,\tZS_COMMENT\t},\n#endif\n\t \n\t{ MNTOPT_BIND,\t\tMS_BIND,\tZS_COMMENT\t},\n#ifdef MS_REC\n\t{ MNTOPT_RBIND,\t\tMS_BIND|MS_REC,\tZS_COMMENT\t},\n#endif\n\t{ MNTOPT_COMMENT,\tMS_COMMENT,\tZS_COMMENT\t},\n#ifdef MS_NOSUB\n\t{ MNTOPT_NOSUB,\t\tMS_NOSUB,\tZS_COMMENT\t},\n#endif\n#ifdef MS_SILENT\n\t{ MNTOPT_QUIET,\t\tMS_SILENT,\tZS_COMMENT\t},\n#endif\n\t \n\t{ MNTOPT_XATTR,\t\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_NOXATTR,\tMS_COMMENT,\tZS_COMMENT\t},\n\t{ MNTOPT_ZFSUTIL,\tMS_COMMENT,\tZS_ZFSUTIL\t},\n\t{ NULL,\t\t\t0,\t\t0\t\t} };\n\n \nstatic int\nparse_option(char *mntopt, unsigned long *mntflags,\n    unsigned long *zfsflags, int sloppy)\n{\n\tconst option_map_t *opt;\n\tchar *ptr, *name, *value = NULL;\n\tint error = 0;\n\n\tname = strdup(mntopt);\n\tif (name == NULL)\n\t\treturn (ENOMEM);\n\n\tfor (ptr = name; ptr && *ptr; ptr++) {\n\t\tif (*ptr == '=') {\n\t\t\t*ptr = '\\0';\n\t\t\tvalue = ptr+1;\n\t\t\tVERIFY3P(value, !=, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (opt = option_map; opt->name != NULL; opt++) {\n\t\tif (strncmp(name, opt->name, strlen(name)) == 0) {\n\t\t\t*mntflags |= opt->mntmask;\n\t\t\t*zfsflags |= opt->zfsmask;\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!sloppy)\n\t\terror = ENOENT;\nout:\n\t \n\tfree(name);\n\treturn (error);\n}\n\n \nint\nzfs_parse_mount_options(const char *mntopts, unsigned long *mntflags,\n    unsigned long *zfsflags, int sloppy, char *badopt, char *mtabopt)\n{\n\tint error = 0, quote = 0, flag = 0, count = 0;\n\tchar *ptr, *opt, *opts;\n\n\topts = strdup(mntopts);\n\tif (opts == NULL)\n\t\treturn (ENOMEM);\n\n\t*mntflags = 0;\n\topt = NULL;\n\n\t \n\tfor (ptr = opts; ptr && !flag; ptr++) {\n\t\tif (opt == NULL)\n\t\t\topt = ptr;\n\n\t\tif (*ptr == '\"')\n\t\t\tquote = !quote;\n\n\t\tif (quote)\n\t\t\tcontinue;\n\n\t\tif (*ptr == '\\0')\n\t\t\tflag = 1;\n\n\t\tif ((*ptr == ',') || (*ptr == '\\0')) {\n\t\t\t*ptr = '\\0';\n\n\t\t\terror = parse_option(opt, mntflags, zfsflags, sloppy);\n\t\t\tif (error) {\n\t\t\t\tstrcpy(badopt, opt);\n\t\t\t\tgoto out;\n\n\t\t\t}\n\n\t\t\tif (!(*mntflags & MS_REMOUNT) &&\n\t\t\t    !(*zfsflags & ZS_ZFSUTIL) &&\n\t\t\t    mtabopt != NULL) {\n\t\t\t\tif (count > 0)\n\t\t\t\t\tstrlcat(mtabopt, \",\", MNT_LINE_MAX);\n\n\t\t\t\tstrlcat(mtabopt, opt, MNT_LINE_MAX);\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\topt = NULL;\n\t\t}\n\t}\n\nout:\n\tfree(opts);\n\treturn (error);\n}\n\nstatic void\nappend_mntopt(const char *name, const char *val, char *mntopts,\n    char *mtabopt, boolean_t quote)\n{\n\tchar tmp[MNT_LINE_MAX];\n\n\tsnprintf(tmp, MNT_LINE_MAX, quote ? \",%s=\\\"%s\\\"\" : \",%s=%s\", name, val);\n\n\tif (mntopts)\n\t\tstrlcat(mntopts, tmp, MNT_LINE_MAX);\n\n\tif (mtabopt)\n\t\tstrlcat(mtabopt, tmp, MNT_LINE_MAX);\n}\n\nstatic void\nzfs_selinux_setcontext(zfs_handle_t *zhp, zfs_prop_t zpt, const char *name,\n    char *mntopts, char *mtabopt)\n{\n\tchar context[ZFS_MAXPROPLEN];\n\n\tif (zfs_prop_get(zhp, zpt, context, sizeof (context),\n\t    NULL, NULL, 0, B_FALSE) == 0) {\n\t\tif (strcmp(context, \"none\") != 0)\n\t\t\tappend_mntopt(name, context, mntopts, mtabopt, B_TRUE);\n\t}\n}\n\nvoid\nzfs_adjust_mount_options(zfs_handle_t *zhp, const char *mntpoint,\n    char *mntopts, char *mtabopt)\n{\n\tchar prop[ZFS_MAXPROPLEN];\n\n\t \n\tif (zfs_prop_get(zhp, ZFS_PROP_SELINUX_CONTEXT, prop, sizeof (prop),\n\t    NULL, NULL, 0, B_FALSE) == 0) {\n\t\tif (strcmp(prop, \"none\") == 0) {\n\t\t\tzfs_selinux_setcontext(zhp, ZFS_PROP_SELINUX_FSCONTEXT,\n\t\t\t    MNTOPT_FSCONTEXT, mntopts, mtabopt);\n\t\t\tzfs_selinux_setcontext(zhp, ZFS_PROP_SELINUX_DEFCONTEXT,\n\t\t\t    MNTOPT_DEFCONTEXT, mntopts, mtabopt);\n\t\t\tzfs_selinux_setcontext(zhp,\n\t\t\t    ZFS_PROP_SELINUX_ROOTCONTEXT, MNTOPT_ROOTCONTEXT,\n\t\t\t    mntopts, mtabopt);\n\t\t} else {\n\t\t\tappend_mntopt(MNTOPT_CONTEXT, prop,\n\t\t\t    mntopts, mtabopt, B_TRUE);\n\t\t}\n\t}\n\n\t \n\tappend_mntopt(MNTOPT_MNTPOINT, mntpoint, mntopts, NULL, B_FALSE);\n}\n\n \nint\ndo_mount(zfs_handle_t *zhp, const char *mntpt, const char *opts, int flags)\n{\n\tconst char *src = zfs_get_name(zhp);\n\tint error = 0;\n\n\tif (!libzfs_envvar_is_set(\"ZFS_MOUNT_HELPER\")) {\n\t\tchar badopt[MNT_LINE_MAX] = {0};\n\t\tunsigned long mntflags = flags, zfsflags = 0;\n\t\tchar myopts[MNT_LINE_MAX] = {0};\n\n\t\tif (zfs_parse_mount_options(opts, &mntflags,\n\t\t    &zfsflags, 0, badopt, NULL)) {\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tstrlcat(myopts, opts, MNT_LINE_MAX);\n\t\tzfs_adjust_mount_options(zhp, mntpt, myopts, NULL);\n\t\tif (mount(src, mntpt, MNTTYPE_ZFS, mntflags, myopts)) {\n\t\t\treturn (errno);\n\t\t}\n\t} else {\n\t\tchar *argv[9] = {\n\t\t    (char *)\"/bin/mount\",\n\t\t    (char *)\"--no-canonicalize\",\n\t\t    (char *)\"-t\", (char *)MNTTYPE_ZFS,\n\t\t    (char *)\"-o\", (char *)opts,\n\t\t    (char *)src,\n\t\t    (char *)mntpt,\n\t\t    (char *)NULL };\n\n\t\t \n\t\terror = libzfs_run_process(argv[0], argv,\n\t\t    STDOUT_VERBOSE|STDERR_VERBOSE);\n\t\tif (error) {\n\t\t\tif (error & MOUNT_FILEIO) {\n\t\t\t\terror = EIO;\n\t\t\t} else if (error & MOUNT_USER) {\n\t\t\t\terror = EINTR;\n\t\t\t} else if (error & MOUNT_SOFTWARE) {\n\t\t\t\terror = EPIPE;\n\t\t\t} else if (error & MOUNT_BUSY) {\n\t\t\t\terror = EBUSY;\n\t\t\t} else if (error & MOUNT_SYSERR) {\n\t\t\t\terror = EAGAIN;\n\t\t\t} else if (error & MOUNT_USAGE) {\n\t\t\t\terror = EINVAL;\n\t\t\t} else\n\t\t\t\terror = ENXIO;  \n\t\t}\n\t}\n\n\treturn (error);\n}\n\nint\ndo_unmount(zfs_handle_t *zhp, const char *mntpt, int flags)\n{\n\t(void) zhp;\n\n\tif (!libzfs_envvar_is_set(\"ZFS_MOUNT_HELPER\")) {\n\t\tint rv = umount2(mntpt, flags);\n\n\t\treturn (rv < 0 ? errno : 0);\n\t}\n\n\tchar *argv[7] = {\n\t    (char *)\"/bin/umount\",\n\t    (char *)\"-t\", (char *)MNTTYPE_ZFS,\n\t    NULL, NULL, NULL, NULL };\n\tint rc, count = 3;\n\n\tif (flags & MS_FORCE)\n\t\targv[count++] = (char *)\"-f\";\n\n\tif (flags & MS_DETACH)\n\t\targv[count++] = (char *)\"-l\";\n\n\targv[count] = (char *)mntpt;\n\trc = libzfs_run_process(argv[0], argv, STDOUT_VERBOSE|STDERR_VERBOSE);\n\n\treturn (rc ? EINVAL : 0);\n}\n\nint\nzfs_mount_delegation_check(void)\n{\n\treturn ((geteuid() != 0) ? EACCES : 0);\n}\n\n \nvoid\nzpool_disable_datasets_os(zpool_handle_t *zhp, boolean_t force)\n{\n\t(void) zhp, (void) force;\n}\n\n \nvoid\nzpool_disable_volume_os(const char *name)\n{\n\t(void) name;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}