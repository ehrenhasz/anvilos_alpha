{
  "module_name": "libzfs_compat.c",
  "hash_id": "e388971668374e4e2ce99d10c5b098aa1af0f8fcda4e44dc8948eb0fba7d9e11",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/os/freebsd/libzfs_compat.c",
  "human_readable_source": " \n\n \n#include \"../../libzfs_impl.h\"\n#include <libzfs.h>\n#include <libzutil.h>\n#include <sys/sysctl.h>\n#include <libintl.h>\n#include <sys/linker.h>\n#include <sys/module.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n\n#ifdef IN_BASE\n#define\tZFS_KMOD\t\"zfs\"\n#else\n#define\tZFS_KMOD\t\"openzfs\"\n#endif\n\n\nstatic int\nexecvPe(const char *name, const char *path, char * const *argv,\n    char * const *envp)\n{\n\tconst char **memp;\n\tsize_t cnt, lp, ln;\n\tint eacces, save_errno;\n\tchar buf[MAXPATHLEN];\n\tconst char *bp, *np, *op, *p;\n\tstruct stat sb;\n\n\teacces = 0;\n\n\t \n\tif (strchr(name, '/')) {\n\t\tbp = name;\n\t\top = NULL;\n\t\tgoto retry;\n\t}\n\tbp = buf;\n\n\t \n\tif (*name == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (-1);\n\t}\n\n\top = path;\n\tln = strlen(name);\n\twhile (op != NULL) {\n\t\tnp = strchrnul(op, ':');\n\n\t\t \n\t\tif (np == op) {\n\t\t\t \n\t\t\tp = \".\";\n\t\t\tlp = 1;\n\t\t} else {\n\t\t\t \n\t\t\tp = op;\n\t\t\tlp = np - op;\n\t\t}\n\n\t\t \n\t\tif (*np == '\\0')\n\t\t\top = NULL;\n\t\telse\n\t\t\top = np + 1;\n\n\t\t \n\t\tif (lp + ln + 2 > sizeof (buf)) {\n\t\t\t(void) write(STDERR_FILENO, \"execvP: \", 8);\n\t\t\t(void) write(STDERR_FILENO, p, lp);\n\t\t\t(void) write(STDERR_FILENO, \": path too long\\n\",\n\t\t\t    16);\n\t\t\tcontinue;\n\t\t}\n\t\tmemcpy(buf, p, lp);\n\t\tbuf[lp] = '/';\n\t\tmemcpy(buf + lp + 1, name, ln);\n\t\tbuf[lp + ln + 1] = '\\0';\n\nretry:\t\t(void) execve(bp, argv, envp);\n\t\tswitch (errno) {\n\t\tcase E2BIG:\n\t\t\tgoto done;\n\t\tcase ELOOP:\n\t\tcase ENAMETOOLONG:\n\t\tcase ENOENT:\n\t\t\tbreak;\n\t\tcase ENOEXEC:\n\t\t\tfor (cnt = 0; argv[cnt]; ++cnt)\n\t\t\t\t;\n\n\t\t\t \n\t\t\tmemp = alloca(MAX(3, cnt + 2) * sizeof (char *));\n\t\t\tif (memp == NULL) {\n\t\t\t\t \n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (cnt > 0) {\n\t\t\t\tmemp[0] = argv[0];\n\t\t\t\tmemp[1] = bp;\n\t\t\t\tmemcpy(memp + 2, argv + 1,\n\t\t\t\t    cnt * sizeof (char *));\n\t\t\t} else {\n\t\t\t\tmemp[0] = \"sh\";\n\t\t\t\tmemp[1] = bp;\n\t\t\t\tmemp[2] = NULL;\n\t\t\t}\n\t\t\t(void) execve(_PATH_BSHELL,\n\t\t\t    __DECONST(char **, memp), envp);\n\t\t\tgoto done;\n\t\tcase ENOMEM:\n\t\t\tgoto done;\n\t\tcase ENOTDIR:\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\t \n\t\t\tgoto done;\n\t\tdefault:\n\t\t\t \n\t\t\tsave_errno = errno;\n\t\t\tif (stat(bp, &sb) != 0)\n\t\t\t\tbreak;\n\t\t\tif (save_errno == EACCES) {\n\t\t\t\teacces = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terrno = save_errno;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (eacces)\n\t\terrno = EACCES;\n\telse\n\t\terrno = ENOENT;\ndone:\n\treturn (-1);\n}\n\nint\nexecvpe(const char *name, char * const argv[], char * const envp[])\n{\n\tconst char *path;\n\n\t \n\tif ((path = getenv(\"PATH\")) == NULL)\n\t\tpath = _PATH_DEFPATH;\n\n\treturn (execvPe(name, path, argv, envp));\n}\n\nstatic __thread char errbuf[ERRBUFLEN];\n\nconst char *\nlibzfs_error_init(int error)\n{\n\tchar *msg = errbuf;\n\tsize_t msglen = sizeof (errbuf);\n\n\tif (modfind(\"zfs\") < 0) {\n\t\tsize_t len = snprintf(msg, msglen, dgettext(TEXT_DOMAIN,\n\t\t    \"Failed to load %s module: \"), ZFS_KMOD);\n\t\tif (len >= msglen)\n\t\t\tlen = msglen - 1;\n\t\tmsg += len;\n\t\tmsglen -= len;\n\t}\n\n\t(void) snprintf(msg, msglen, \"%s\", strerror(error));\n\n\treturn (errbuf);\n}\n\nint\nzfs_ioctl(libzfs_handle_t *hdl, int request, zfs_cmd_t *zc)\n{\n\treturn (lzc_ioctl_fd(hdl->libzfs_fd, request, zc));\n}\n\n \nint\nlibzfs_load_module(void)\n{\n\t \n\tif (modfind(\"zfs\") < 0) {\n\t\t \n\t\tif (kldload(ZFS_KMOD) < 0 && errno != EEXIST) {\n\t\t\treturn (errno);\n\t\t}\n\t}\n\treturn (0);\n}\n\nint\nzpool_relabel_disk(libzfs_handle_t *hdl, const char *path, const char *msg)\n{\n\t(void) hdl, (void) path, (void) msg;\n\treturn (0);\n}\n\nint\nzpool_label_disk(libzfs_handle_t *hdl, zpool_handle_t *zhp, const char *name)\n{\n\t(void) hdl, (void) zhp, (void) name;\n\treturn (0);\n}\n\nint\nfind_shares_object(differ_info_t *di)\n{\n\t(void) di;\n\treturn (0);\n}\n\nint\nzfs_destroy_snaps_nvl_os(libzfs_handle_t *hdl, nvlist_t *snaps)\n{\n\t(void) hdl, (void) snaps;\n\treturn (0);\n}\n\n \nint\nzfs_jail(zfs_handle_t *zhp, int jailid, int attach)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tunsigned long cmd;\n\tint ret;\n\n\tif (attach) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot jail '%s'\"), zhp->zfs_name);\n\t} else {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot unjail '%s'\"), zhp->zfs_name);\n\t}\n\n\tswitch (zhp->zfs_type) {\n\tcase ZFS_TYPE_VOLUME:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"volumes can not be jailed\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_SNAPSHOT:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"snapshots can not be jailed\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_BOOKMARK:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"bookmarks can not be jailed\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_VDEV:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"vdevs can not be jailed\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_INVALID:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid zfs_type_t: ZFS_TYPE_INVALID\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\tcase ZFS_TYPE_POOL:\n\tcase ZFS_TYPE_FILESYSTEM:\n\t\t \n\t\t;\n\t}\n\tassert(zhp->zfs_type == ZFS_TYPE_FILESYSTEM);\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\tzc.zc_objset_type = DMU_OST_ZFS;\n\tzc.zc_zoneid = jailid;\n\n\tcmd = attach ? ZFS_IOC_JAIL : ZFS_IOC_UNJAIL;\n\tif ((ret = zfs_ioctl(hdl, cmd, &zc)) != 0)\n\t\tzfs_standard_error(hdl, errno, errbuf);\n\n\treturn (ret);\n}\n\n \nint\nzpool_nextboot(libzfs_handle_t *hdl, uint64_t pool_guid, uint64_t dev_guid,\n    const char *command)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tnvlist_t *args;\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_uint64(args, ZPOOL_CONFIG_POOL_GUID, pool_guid);\n\tfnvlist_add_uint64(args, ZPOOL_CONFIG_GUID, dev_guid);\n\tfnvlist_add_string(args, \"command\", command);\n\tzcmd_write_src_nvlist(hdl, &zc, args);\n\tint error = zfs_ioctl(hdl, ZFS_IOC_NEXTBOOT, &zc);\n\tzcmd_free_nvlists(&zc);\n\tnvlist_free(args);\n\treturn (error);\n}\n\n \nchar *\nzfs_version_kernel(void)\n{\n\tsize_t l;\n\tif (sysctlbyname(\"vfs.zfs.version.module\",\n\t    NULL, &l, NULL, 0) == -1)\n\t\treturn (NULL);\n\tchar *version = malloc(l);\n\tif (version == NULL)\n\t\treturn (NULL);\n\tif (sysctlbyname(\"vfs.zfs.version.module\",\n\t    version, &l, NULL, 0) == -1) {\n\t\tfree(version);\n\t\treturn (NULL);\n\t}\n\treturn (version);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}