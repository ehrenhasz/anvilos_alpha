{
  "module_name": "libzfs_dataset.c",
  "hash_id": "8439a1be7e1bc0d25677f83ed6cd877aed9cbf9ddff008d5fd59730df7304525",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_dataset.c",
  "human_readable_source": " \n\n \n\n#include <ctype.h>\n#include <errno.h>\n#include <libintl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <strings.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <zone.h>\n#include <fcntl.h>\n#include <sys/mntent.h>\n#include <sys/mount.h>\n#include <pwd.h>\n#include <grp.h>\n#ifdef HAVE_IDMAP\n#include <idmap.h>\n#include <aclutils.h>\n#include <directory.h>\n#endif  \n\n#include <sys/dnode.h>\n#include <sys/spa.h>\n#include <sys/zap.h>\n#include <sys/dsl_crypt.h>\n#include <libzfs.h>\n#include <libzutil.h>\n\n#include \"zfs_namecheck.h\"\n#include \"zfs_prop.h\"\n#include \"libzfs_impl.h\"\n#include \"zfs_deleg.h\"\n\nstatic int userquota_propname_decode(const char *propname, boolean_t zoned,\n    zfs_userquota_prop_t *typep, char *domain, int domainlen, uint64_t *ridp);\n\n \nconst char *\nzfs_type_to_name(zfs_type_t type)\n{\n\tswitch (type) {\n\tcase ZFS_TYPE_FILESYSTEM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"filesystem\"));\n\tcase ZFS_TYPE_SNAPSHOT:\n\t\treturn (dgettext(TEXT_DOMAIN, \"snapshot\"));\n\tcase ZFS_TYPE_VOLUME:\n\t\treturn (dgettext(TEXT_DOMAIN, \"volume\"));\n\tcase ZFS_TYPE_POOL:\n\t\treturn (dgettext(TEXT_DOMAIN, \"pool\"));\n\tcase ZFS_TYPE_BOOKMARK:\n\t\treturn (dgettext(TEXT_DOMAIN, \"bookmark\"));\n\tdefault:\n\t\tassert(!\"unhandled zfs_type_t\");\n\t}\n\n\treturn (NULL);\n}\n\n \nint\nzfs_validate_name(libzfs_handle_t *hdl, const char *path, int type,\n    boolean_t modifying)\n{\n\tnamecheck_err_t why;\n\tchar what;\n\n\tif (!(type & ZFS_TYPE_SNAPSHOT) && strchr(path, '@') != NULL) {\n\t\tif (hdl != NULL)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"snapshot delimiter '@' is not expected here\"));\n\t\treturn (0);\n\t}\n\n\tif (type == ZFS_TYPE_SNAPSHOT && strchr(path, '@') == NULL) {\n\t\tif (hdl != NULL)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"missing '@' delimiter in snapshot name\"));\n\t\treturn (0);\n\t}\n\n\tif (!(type & ZFS_TYPE_BOOKMARK) && strchr(path, '#') != NULL) {\n\t\tif (hdl != NULL)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"bookmark delimiter '#' is not expected here\"));\n\t\treturn (0);\n\t}\n\n\tif (type == ZFS_TYPE_BOOKMARK && strchr(path, '#') == NULL) {\n\t\tif (hdl != NULL)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"missing '#' delimiter in bookmark name\"));\n\t\treturn (0);\n\t}\n\n\tif (modifying && strchr(path, '%') != NULL) {\n\t\tif (hdl != NULL)\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid character %c in name\"), '%');\n\t\treturn (0);\n\t}\n\n\tif (entity_namecheck(path, &why, &what) != 0) {\n\t\tif (hdl != NULL) {\n\t\t\tswitch (why) {\n\t\t\tcase NAME_ERR_TOOLONG:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"name is too long\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_LEADING_SLASH:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"leading slash in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_EMPTY_COMPONENT:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"empty component or misplaced '@'\"\n\t\t\t\t    \" or '#' delimiter in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_TRAILING_SLASH:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"trailing slash in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_INVALCHAR:\n\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"invalid character \"\n\t\t\t\t    \"'%c' in name\"), what);\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_MULTIPLE_DELIMITERS:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"multiple '@' and/or '#' delimiters in \"\n\t\t\t\t    \"name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_NOLETTER:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"pool doesn't begin with a letter\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_RESERVED:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"name is reserved\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_DISKLIKE:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"reserved disk name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_SELF_REF:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"self reference, '.' is found in name\"));\n\t\t\t\tbreak;\n\n\t\t\tcase NAME_ERR_PARENT_REF:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"parent reference, '..' is found in name\"));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"(%d) not defined\"), why);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (0);\n\t}\n\n\treturn (-1);\n}\n\nint\nzfs_name_valid(const char *name, zfs_type_t type)\n{\n\tif (type == ZFS_TYPE_POOL)\n\t\treturn (zpool_name_valid(NULL, B_FALSE, name));\n\treturn (zfs_validate_name(NULL, name, type, B_FALSE));\n}\n\n \nstatic nvlist_t *\nprocess_user_props(zfs_handle_t *zhp, nvlist_t *props)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvpair_t *elem;\n\tnvlist_t *nvl;\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0) {\n\t\t(void) no_memory(hdl);\n\t\treturn (NULL);\n\t}\n\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(props, elem)) != NULL) {\n\t\tif (!zfs_prop_user(nvpair_name(elem)))\n\t\t\tcontinue;\n\n\t\tnvlist_t *propval = fnvpair_value_nvlist(elem);\n\t\tif (nvlist_add_nvlist(nvl, nvpair_name(elem), propval) != 0) {\n\t\t\tnvlist_free(nvl);\n\t\t\t(void) no_memory(hdl);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\treturn (nvl);\n}\n\nstatic zpool_handle_t *\nzpool_add_handle(zfs_handle_t *zhp, const char *pool_name)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tzpool_handle_t *zph;\n\n\tif ((zph = zpool_open_canfail(hdl, pool_name)) != NULL) {\n\t\tif (hdl->libzfs_pool_handles != NULL)\n\t\t\tzph->zpool_next = hdl->libzfs_pool_handles;\n\t\thdl->libzfs_pool_handles = zph;\n\t}\n\treturn (zph);\n}\n\nstatic zpool_handle_t *\nzpool_find_handle(zfs_handle_t *zhp, const char *pool_name, int len)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tzpool_handle_t *zph = hdl->libzfs_pool_handles;\n\n\twhile ((zph != NULL) &&\n\t    (strncmp(pool_name, zpool_get_name(zph), len) != 0))\n\t\tzph = zph->zpool_next;\n\treturn (zph);\n}\n\n \nstatic zpool_handle_t *\nzpool_handle(zfs_handle_t *zhp)\n{\n\tchar *pool_name;\n\tint len;\n\tzpool_handle_t *zph;\n\n\tlen = strcspn(zhp->zfs_name, \"/@#\") + 1;\n\tpool_name = zfs_alloc(zhp->zfs_hdl, len);\n\t(void) strlcpy(pool_name, zhp->zfs_name, len);\n\n\tzph = zpool_find_handle(zhp, pool_name, len);\n\tif (zph == NULL)\n\t\tzph = zpool_add_handle(zhp, pool_name);\n\n\tfree(pool_name);\n\treturn (zph);\n}\n\nvoid\nzpool_free_handles(libzfs_handle_t *hdl)\n{\n\tzpool_handle_t *next, *zph = hdl->libzfs_pool_handles;\n\n\twhile (zph != NULL) {\n\t\tnext = zph->zpool_next;\n\t\tzpool_close(zph);\n\t\tzph = next;\n\t}\n\thdl->libzfs_pool_handles = NULL;\n}\n\n \nstatic int\nget_stats_ioctl(zfs_handle_t *zhp, zfs_cmd_t *zc)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\n\t(void) strlcpy(zc->zc_name, zhp->zfs_name, sizeof (zc->zc_name));\n\n\twhile (zfs_ioctl(hdl, ZFS_IOC_OBJSET_STATS, zc) != 0) {\n\t\tif (errno == ENOMEM)\n\t\t\tzcmd_expand_dst_nvlist(hdl, zc);\n\t\telse\n\t\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nget_recvd_props_ioctl(zfs_handle_t *zhp)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvlist_t *recvdprops;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint err;\n\n\tzcmd_alloc_dst_nvlist(hdl, &zc, 0);\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\twhile (zfs_ioctl(hdl, ZFS_IOC_OBJSET_RECVD_PROPS, &zc) != 0) {\n\t\tif (errno == ENOMEM)\n\t\t\tzcmd_expand_dst_nvlist(hdl, &zc);\n\t\telse {\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\terr = zcmd_read_dst_nvlist(zhp->zfs_hdl, &zc, &recvdprops);\n\tzcmd_free_nvlists(&zc);\n\tif (err != 0)\n\t\treturn (-1);\n\n\tnvlist_free(zhp->zfs_recvd_props);\n\tzhp->zfs_recvd_props = recvdprops;\n\n\treturn (0);\n}\n\nstatic int\nput_stats_zhdl(zfs_handle_t *zhp, zfs_cmd_t *zc)\n{\n\tnvlist_t *allprops, *userprops;\n\n\tzhp->zfs_dmustats = zc->zc_objset_stats;  \n\n\tif (zcmd_read_dst_nvlist(zhp->zfs_hdl, zc, &allprops) != 0) {\n\t\treturn (-1);\n\t}\n\n\t \n\tif ((userprops = process_user_props(zhp, allprops)) == NULL) {\n\t\tnvlist_free(allprops);\n\t\treturn (-1);\n\t}\n\n\tnvlist_free(zhp->zfs_props);\n\tnvlist_free(zhp->zfs_user_props);\n\n\tzhp->zfs_props = allprops;\n\tzhp->zfs_user_props = userprops;\n\n\treturn (0);\n}\n\nstatic int\nget_stats(zfs_handle_t *zhp)\n{\n\tint rc = 0;\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tzcmd_alloc_dst_nvlist(zhp->zfs_hdl, &zc, 0);\n\n\tif (get_stats_ioctl(zhp, &zc) != 0)\n\t\trc = -1;\n\telse if (put_stats_zhdl(zhp, &zc) != 0)\n\t\trc = -1;\n\tzcmd_free_nvlists(&zc);\n\treturn (rc);\n}\n\n \nvoid\nzfs_refresh_properties(zfs_handle_t *zhp)\n{\n\t(void) get_stats(zhp);\n}\n\n \nstatic int\nmake_dataset_handle_common(zfs_handle_t *zhp, zfs_cmd_t *zc)\n{\n\tif (put_stats_zhdl(zhp, zc) != 0)\n\t\treturn (-1);\n\n\t \n\tif (zhp->zfs_dmustats.dds_type == DMU_OST_ZVOL) {\n\t\tzhp->zfs_head_type = ZFS_TYPE_VOLUME;\n\t} else if (zhp->zfs_dmustats.dds_type == DMU_OST_ZFS) {\n\t\tzhp->zfs_head_type = ZFS_TYPE_FILESYSTEM;\n\t} else if (zhp->zfs_dmustats.dds_type == DMU_OST_OTHER) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t} else if (zhp->zfs_dmustats.dds_inconsistent) {\n\t\terrno = EBUSY;\n\t\treturn (-1);\n\t} else {\n\t\tabort();\n\t}\n\n\tif (zhp->zfs_dmustats.dds_is_snapshot)\n\t\tzhp->zfs_type = ZFS_TYPE_SNAPSHOT;\n\telse if (zhp->zfs_dmustats.dds_type == DMU_OST_ZVOL)\n\t\tzhp->zfs_type = ZFS_TYPE_VOLUME;\n\telse if (zhp->zfs_dmustats.dds_type == DMU_OST_ZFS)\n\t\tzhp->zfs_type = ZFS_TYPE_FILESYSTEM;\n\telse\n\t\tabort();\t \n\n\tif ((zhp->zpool_hdl = zpool_handle(zhp)) == NULL)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\nzfs_handle_t *\nmake_dataset_handle(libzfs_handle_t *hdl, const char *path)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tzfs_handle_t *zhp = calloc(1, sizeof (zfs_handle_t));\n\n\tif (zhp == NULL)\n\t\treturn (NULL);\n\n\tzhp->zfs_hdl = hdl;\n\t(void) strlcpy(zhp->zfs_name, path, sizeof (zhp->zfs_name));\n\tzcmd_alloc_dst_nvlist(hdl, &zc, 0);\n\n\tif (get_stats_ioctl(zhp, &zc) == -1) {\n\t\tzcmd_free_nvlists(&zc);\n\t\tfree(zhp);\n\t\treturn (NULL);\n\t}\n\tif (make_dataset_handle_common(zhp, &zc) == -1) {\n\t\tfree(zhp);\n\t\tzhp = NULL;\n\t}\n\tzcmd_free_nvlists(&zc);\n\treturn (zhp);\n}\n\nzfs_handle_t *\nmake_dataset_handle_zc(libzfs_handle_t *hdl, zfs_cmd_t *zc)\n{\n\tzfs_handle_t *zhp = calloc(1, sizeof (zfs_handle_t));\n\n\tif (zhp == NULL)\n\t\treturn (NULL);\n\n\tzhp->zfs_hdl = hdl;\n\t(void) strlcpy(zhp->zfs_name, zc->zc_name, sizeof (zhp->zfs_name));\n\tif (make_dataset_handle_common(zhp, zc) == -1) {\n\t\tfree(zhp);\n\t\treturn (NULL);\n\t}\n\treturn (zhp);\n}\n\nzfs_handle_t *\nmake_dataset_simple_handle_zc(zfs_handle_t *pzhp, zfs_cmd_t *zc)\n{\n\tzfs_handle_t *zhp = calloc(1, sizeof (zfs_handle_t));\n\n\tif (zhp == NULL)\n\t\treturn (NULL);\n\n\tzhp->zfs_hdl = pzhp->zfs_hdl;\n\t(void) strlcpy(zhp->zfs_name, zc->zc_name, sizeof (zhp->zfs_name));\n\tzhp->zfs_head_type = pzhp->zfs_type;\n\tzhp->zfs_type = ZFS_TYPE_SNAPSHOT;\n\tzhp->zpool_hdl = zpool_handle(zhp);\n\n\tif (zc->zc_objset_stats.dds_creation_txg != 0) {\n\t\t \n\t\tzhp->zfs_dmustats = zc->zc_objset_stats;\n\t} else {\n\t\tif (get_stats_ioctl(zhp, zc) == -1) {\n\t\t\tzcmd_free_nvlists(zc);\n\t\t\tfree(zhp);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (make_dataset_handle_common(zhp, zc) == -1) {\n\t\t\tzcmd_free_nvlists(zc);\n\t\t\tfree(zhp);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\tif (zhp->zfs_dmustats.dds_is_snapshot ||\n\t    strchr(zc->zc_name, '@') != NULL)\n\t\tzhp->zfs_type = ZFS_TYPE_SNAPSHOT;\n\telse if (zhp->zfs_dmustats.dds_type == DMU_OST_ZVOL)\n\t\tzhp->zfs_type = ZFS_TYPE_VOLUME;\n\telse if (zhp->zfs_dmustats.dds_type == DMU_OST_ZFS)\n\t\tzhp->zfs_type = ZFS_TYPE_FILESYSTEM;\n\n\treturn (zhp);\n}\n\nzfs_handle_t *\nzfs_handle_dup(zfs_handle_t *zhp_orig)\n{\n\tzfs_handle_t *zhp = calloc(1, sizeof (zfs_handle_t));\n\n\tif (zhp == NULL)\n\t\treturn (NULL);\n\n\tzhp->zfs_hdl = zhp_orig->zfs_hdl;\n\tzhp->zpool_hdl = zhp_orig->zpool_hdl;\n\t(void) strlcpy(zhp->zfs_name, zhp_orig->zfs_name,\n\t    sizeof (zhp->zfs_name));\n\tzhp->zfs_type = zhp_orig->zfs_type;\n\tzhp->zfs_head_type = zhp_orig->zfs_head_type;\n\tzhp->zfs_dmustats = zhp_orig->zfs_dmustats;\n\tif (zhp_orig->zfs_props != NULL) {\n\t\tif (nvlist_dup(zhp_orig->zfs_props, &zhp->zfs_props, 0) != 0) {\n\t\t\t(void) no_memory(zhp->zfs_hdl);\n\t\t\tzfs_close(zhp);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif (zhp_orig->zfs_user_props != NULL) {\n\t\tif (nvlist_dup(zhp_orig->zfs_user_props,\n\t\t    &zhp->zfs_user_props, 0) != 0) {\n\t\t\t(void) no_memory(zhp->zfs_hdl);\n\t\t\tzfs_close(zhp);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif (zhp_orig->zfs_recvd_props != NULL) {\n\t\tif (nvlist_dup(zhp_orig->zfs_recvd_props,\n\t\t    &zhp->zfs_recvd_props, 0)) {\n\t\t\t(void) no_memory(zhp->zfs_hdl);\n\t\t\tzfs_close(zhp);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tzhp->zfs_mntcheck = zhp_orig->zfs_mntcheck;\n\tif (zhp_orig->zfs_mntopts != NULL) {\n\t\tzhp->zfs_mntopts = zfs_strdup(zhp_orig->zfs_hdl,\n\t\t    zhp_orig->zfs_mntopts);\n\t}\n\tzhp->zfs_props_table = zhp_orig->zfs_props_table;\n\treturn (zhp);\n}\n\nboolean_t\nzfs_bookmark_exists(const char *path)\n{\n\tnvlist_t *bmarks;\n\tnvlist_t *props;\n\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *bmark_name;\n\tchar *pound;\n\tint err;\n\tboolean_t rv;\n\n\t(void) strlcpy(fsname, path, sizeof (fsname));\n\tpound = strchr(fsname, '#');\n\tif (pound == NULL)\n\t\treturn (B_FALSE);\n\n\t*pound = '\\0';\n\tbmark_name = pound + 1;\n\tprops = fnvlist_alloc();\n\terr = lzc_get_bookmarks(fsname, props, &bmarks);\n\tnvlist_free(props);\n\tif (err != 0) {\n\t\tnvlist_free(bmarks);\n\t\treturn (B_FALSE);\n\t}\n\n\trv = nvlist_exists(bmarks, bmark_name);\n\tnvlist_free(bmarks);\n\treturn (rv);\n}\n\nzfs_handle_t *\nmake_bookmark_handle(zfs_handle_t *parent, const char *path,\n    nvlist_t *bmark_props)\n{\n\tzfs_handle_t *zhp = calloc(1, sizeof (zfs_handle_t));\n\n\tif (zhp == NULL)\n\t\treturn (NULL);\n\n\t \n\tzhp->zfs_hdl = parent->zfs_hdl;\n\t(void) strlcpy(zhp->zfs_name, path, sizeof (zhp->zfs_name));\n\n\t \n\tif (nvlist_dup(bmark_props, &zhp->zfs_props, 0) != 0) {\n\t\tfree(zhp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tzhp->zfs_head_type = parent->zfs_head_type;\n\tzhp->zfs_type = ZFS_TYPE_BOOKMARK;\n\n\tif ((zhp->zpool_hdl = zpool_handle(zhp)) == NULL) {\n\t\tnvlist_free(zhp->zfs_props);\n\t\tfree(zhp);\n\t\treturn (NULL);\n\t}\n\n\treturn (zhp);\n}\n\nstruct zfs_open_bookmarks_cb_data {\n\tconst char *path;\n\tzfs_handle_t *zhp;\n};\n\nstatic int\nzfs_open_bookmarks_cb(zfs_handle_t *zhp, void *data)\n{\n\tstruct zfs_open_bookmarks_cb_data *dp = data;\n\n\t \n\tif (strcmp(dp->path, zfs_get_name(zhp)) == 0) {\n\t\t \n\t\tdp->zhp = zhp;\n\t\treturn (EEXIST);\n\t}\n\n\t \n\tzfs_close(zhp);\n\treturn (0);\n}\n\n \nzfs_handle_t *\nzfs_open(libzfs_handle_t *hdl, const char *path, int types)\n{\n\tzfs_handle_t *zhp;\n\tchar errbuf[ERRBUFLEN];\n\tchar *bookp;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot open '%s'\"), path);\n\n\t \n\tif (!zfs_validate_name(hdl, path, types, B_FALSE)) {\n\t\t(void) zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\n\t \n\tbookp = strchr(path, '#');\n\tif (bookp == NULL) {\n\t\t \n\t\terrno = 0;\n\t\tif ((zhp = make_dataset_handle(hdl, path)) == NULL) {\n\t\t\t(void) zfs_standard_error(hdl, errno, errbuf);\n\t\t\treturn (NULL);\n\t\t}\n\t} else {\n\t\tchar dsname[ZFS_MAX_DATASET_NAME_LEN];\n\t\tzfs_handle_t *pzhp;\n\t\tstruct zfs_open_bookmarks_cb_data cb_data = {path, NULL};\n\n\t\t \n\t\tassert(bookp - path < sizeof (dsname));\n\t\t(void) strlcpy(dsname, path,\n\t\t    MIN(sizeof (dsname), bookp - path + 1));\n\n\t\t \n\t\terrno = 0;\n\t\tif ((pzhp = make_dataset_handle(hdl, dsname)) == NULL) {\n\t\t\t(void) zfs_standard_error(hdl, errno, errbuf);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t \n\t\terrno = 0;\n\t\tif ((zfs_iter_bookmarks_v2(pzhp, 0, zfs_open_bookmarks_cb,\n\t\t    &cb_data) == 0) && (cb_data.zhp == NULL)) {\n\t\t\t(void) zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tzfs_close(pzhp);\n\t\t\terrno = ENOENT;\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (cb_data.zhp == NULL) {\n\t\t\t(void) zfs_standard_error(hdl, errno, errbuf);\n\t\t\tzfs_close(pzhp);\n\t\t\treturn (NULL);\n\t\t}\n\t\tzhp = cb_data.zhp;\n\n\t\t \n\t\tzfs_close(pzhp);\n\t}\n\n\tif (!(types & zhp->zfs_type)) {\n\t\t(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\tzfs_close(zhp);\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\n\treturn (zhp);\n}\n\n \nvoid\nzfs_close(zfs_handle_t *zhp)\n{\n\tif (zhp->zfs_mntopts)\n\t\tfree(zhp->zfs_mntopts);\n\tnvlist_free(zhp->zfs_props);\n\tnvlist_free(zhp->zfs_user_props);\n\tnvlist_free(zhp->zfs_recvd_props);\n\tfree(zhp);\n}\n\ntypedef struct mnttab_node {\n\tstruct mnttab mtn_mt;\n\tavl_node_t mtn_node;\n} mnttab_node_t;\n\nstatic int\nlibzfs_mnttab_cache_compare(const void *arg1, const void *arg2)\n{\n\tconst mnttab_node_t *mtn1 = (const mnttab_node_t *)arg1;\n\tconst mnttab_node_t *mtn2 = (const mnttab_node_t *)arg2;\n\tint rv;\n\n\trv = strcmp(mtn1->mtn_mt.mnt_special, mtn2->mtn_mt.mnt_special);\n\n\treturn (TREE_ISIGN(rv));\n}\n\nvoid\nlibzfs_mnttab_init(libzfs_handle_t *hdl)\n{\n\tpthread_mutex_init(&hdl->libzfs_mnttab_cache_lock, NULL);\n\tassert(avl_numnodes(&hdl->libzfs_mnttab_cache) == 0);\n\tavl_create(&hdl->libzfs_mnttab_cache, libzfs_mnttab_cache_compare,\n\t    sizeof (mnttab_node_t), offsetof(mnttab_node_t, mtn_node));\n}\n\nstatic int\nlibzfs_mnttab_update(libzfs_handle_t *hdl)\n{\n\tFILE *mnttab;\n\tstruct mnttab entry;\n\n\tif ((mnttab = fopen(MNTTAB, \"re\")) == NULL)\n\t\treturn (ENOENT);\n\n\twhile (getmntent(mnttab, &entry) == 0) {\n\t\tmnttab_node_t *mtn;\n\t\tavl_index_t where;\n\n\t\tif (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0)\n\t\t\tcontinue;\n\n\t\tmtn = zfs_alloc(hdl, sizeof (mnttab_node_t));\n\t\tmtn->mtn_mt.mnt_special = zfs_strdup(hdl, entry.mnt_special);\n\t\tmtn->mtn_mt.mnt_mountp = zfs_strdup(hdl, entry.mnt_mountp);\n\t\tmtn->mtn_mt.mnt_fstype = zfs_strdup(hdl, entry.mnt_fstype);\n\t\tmtn->mtn_mt.mnt_mntopts = zfs_strdup(hdl, entry.mnt_mntopts);\n\n\t\t \n\t\tif (avl_find(&hdl->libzfs_mnttab_cache, mtn, &where) != NULL) {\n\t\t\tfree(mtn->mtn_mt.mnt_special);\n\t\t\tfree(mtn->mtn_mt.mnt_mountp);\n\t\t\tfree(mtn->mtn_mt.mnt_fstype);\n\t\t\tfree(mtn->mtn_mt.mnt_mntopts);\n\t\t\tfree(mtn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tavl_add(&hdl->libzfs_mnttab_cache, mtn);\n\t}\n\n\t(void) fclose(mnttab);\n\treturn (0);\n}\n\nvoid\nlibzfs_mnttab_fini(libzfs_handle_t *hdl)\n{\n\tvoid *cookie = NULL;\n\tmnttab_node_t *mtn;\n\n\twhile ((mtn = avl_destroy_nodes(&hdl->libzfs_mnttab_cache, &cookie))\n\t    != NULL) {\n\t\tfree(mtn->mtn_mt.mnt_special);\n\t\tfree(mtn->mtn_mt.mnt_mountp);\n\t\tfree(mtn->mtn_mt.mnt_fstype);\n\t\tfree(mtn->mtn_mt.mnt_mntopts);\n\t\tfree(mtn);\n\t}\n\tavl_destroy(&hdl->libzfs_mnttab_cache);\n\t(void) pthread_mutex_destroy(&hdl->libzfs_mnttab_cache_lock);\n}\n\nvoid\nlibzfs_mnttab_cache(libzfs_handle_t *hdl, boolean_t enable)\n{\n\thdl->libzfs_mnttab_enable = enable;\n}\n\nint\nlibzfs_mnttab_find(libzfs_handle_t *hdl, const char *fsname,\n    struct mnttab *entry)\n{\n\tFILE *mnttab;\n\tmnttab_node_t find;\n\tmnttab_node_t *mtn;\n\tint ret = ENOENT;\n\n\tif (!hdl->libzfs_mnttab_enable) {\n\t\tstruct mnttab srch = { 0 };\n\n\t\tif (avl_numnodes(&hdl->libzfs_mnttab_cache))\n\t\t\tlibzfs_mnttab_fini(hdl);\n\n\t\tif ((mnttab = fopen(MNTTAB, \"re\")) == NULL)\n\t\t\treturn (ENOENT);\n\n\t\tsrch.mnt_special = (char *)fsname;\n\t\tsrch.mnt_fstype = (char *)MNTTYPE_ZFS;\n\t\tret = getmntany(mnttab, entry, &srch) ? ENOENT : 0;\n\t\t(void) fclose(mnttab);\n\t\treturn (ret);\n\t}\n\n\tpthread_mutex_lock(&hdl->libzfs_mnttab_cache_lock);\n\tif (avl_numnodes(&hdl->libzfs_mnttab_cache) == 0) {\n\t\tint error;\n\n\t\tif ((error = libzfs_mnttab_update(hdl)) != 0) {\n\t\t\tpthread_mutex_unlock(&hdl->libzfs_mnttab_cache_lock);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tfind.mtn_mt.mnt_special = (char *)fsname;\n\tmtn = avl_find(&hdl->libzfs_mnttab_cache, &find, NULL);\n\tif (mtn) {\n\t\t*entry = mtn->mtn_mt;\n\t\tret = 0;\n\t}\n\tpthread_mutex_unlock(&hdl->libzfs_mnttab_cache_lock);\n\treturn (ret);\n}\n\nvoid\nlibzfs_mnttab_add(libzfs_handle_t *hdl, const char *special,\n    const char *mountp, const char *mntopts)\n{\n\tmnttab_node_t *mtn;\n\n\tpthread_mutex_lock(&hdl->libzfs_mnttab_cache_lock);\n\tif (avl_numnodes(&hdl->libzfs_mnttab_cache) != 0) {\n\t\tmtn = zfs_alloc(hdl, sizeof (mnttab_node_t));\n\t\tmtn->mtn_mt.mnt_special = zfs_strdup(hdl, special);\n\t\tmtn->mtn_mt.mnt_mountp = zfs_strdup(hdl, mountp);\n\t\tmtn->mtn_mt.mnt_fstype = zfs_strdup(hdl, MNTTYPE_ZFS);\n\t\tmtn->mtn_mt.mnt_mntopts = zfs_strdup(hdl, mntopts);\n\t\t \n\t\tif (avl_find(&hdl->libzfs_mnttab_cache, mtn, NULL) != NULL) {\n\t\t\tfree(mtn->mtn_mt.mnt_special);\n\t\t\tfree(mtn->mtn_mt.mnt_mountp);\n\t\t\tfree(mtn->mtn_mt.mnt_fstype);\n\t\t\tfree(mtn->mtn_mt.mnt_mntopts);\n\t\t\tfree(mtn);\n\t\t} else {\n\t\t\tavl_add(&hdl->libzfs_mnttab_cache, mtn);\n\t\t}\n\t}\n\tpthread_mutex_unlock(&hdl->libzfs_mnttab_cache_lock);\n}\n\nvoid\nlibzfs_mnttab_remove(libzfs_handle_t *hdl, const char *fsname)\n{\n\tmnttab_node_t find;\n\tmnttab_node_t *ret;\n\n\tpthread_mutex_lock(&hdl->libzfs_mnttab_cache_lock);\n\tfind.mtn_mt.mnt_special = (char *)fsname;\n\tif ((ret = avl_find(&hdl->libzfs_mnttab_cache, (void *)&find, NULL))\n\t    != NULL) {\n\t\tavl_remove(&hdl->libzfs_mnttab_cache, ret);\n\t\tfree(ret->mtn_mt.mnt_special);\n\t\tfree(ret->mtn_mt.mnt_mountp);\n\t\tfree(ret->mtn_mt.mnt_fstype);\n\t\tfree(ret->mtn_mt.mnt_mntopts);\n\t\tfree(ret);\n\t}\n\tpthread_mutex_unlock(&hdl->libzfs_mnttab_cache_lock);\n}\n\nint\nzfs_spa_version(zfs_handle_t *zhp, int *spa_version)\n{\n\tzpool_handle_t *zpool_handle = zhp->zpool_hdl;\n\n\tif (zpool_handle == NULL)\n\t\treturn (-1);\n\n\t*spa_version = zpool_get_prop_int(zpool_handle,\n\t    ZPOOL_PROP_VERSION, NULL);\n\treturn (0);\n}\n\n \nstatic int\nzfs_which_resv_prop(zfs_handle_t *zhp, zfs_prop_t *resv_prop)\n{\n\tint spa_version;\n\n\tif (zfs_spa_version(zhp, &spa_version) < 0)\n\t\treturn (-1);\n\n\tif (spa_version >= SPA_VERSION_REFRESERVATION)\n\t\t*resv_prop = ZFS_PROP_REFRESERVATION;\n\telse\n\t\t*resv_prop = ZFS_PROP_RESERVATION;\n\n\treturn (0);\n}\n\n \nnvlist_t *\nzfs_valid_proplist(libzfs_handle_t *hdl, zfs_type_t type, nvlist_t *nvl,\n    uint64_t zoned, zfs_handle_t *zhp, zpool_handle_t *zpool_hdl,\n    boolean_t key_params_ok, const char *errbuf)\n{\n\tnvpair_t *elem;\n\tuint64_t intval;\n\tconst char *strval;\n\tzfs_prop_t prop;\n\tnvlist_t *ret;\n\tint chosen_normal = -1;\n\tint chosen_utf = -1;\n\tint set_maxbs = 0;\n\n\tif (nvlist_alloc(&ret, NV_UNIQUE_NAME, 0) != 0) {\n\t\t(void) no_memory(hdl);\n\t\treturn (NULL);\n\t}\n\n\t \n\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(nvl, elem)) != NULL) {\n\t\tconst char *propname = nvpair_name(elem);\n\n\t\tprop = zfs_name_to_prop(propname);\n\t\tif (prop == ZPROP_USERPROP && zfs_prop_user(propname)) {\n\t\t\t \n\t\t\tif (nvpair_type(elem) != DATA_TYPE_STRING) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' must be a string\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (strlen(nvpair_name(elem)) >= ZAP_MAXNAMELEN) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property name '%s' is too long\"),\n\t\t\t\t    propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t(void) nvpair_value_string(elem, &strval);\n\t\t\tif (nvlist_add_string(ret, propname, strval) != 0) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (type == ZFS_TYPE_SNAPSHOT) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"this property can not be modified for snapshots\"));\n\t\t\t(void) zfs_error(hdl, EZFS_PROPTYPE, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (prop == ZPROP_USERPROP && zfs_prop_userquota(propname)) {\n\t\t\tzfs_userquota_prop_t uqtype;\n\t\t\tchar *newpropname = NULL;\n\t\t\tchar domain[128];\n\t\t\tuint64_t rid;\n\t\t\tuint64_t valary[3];\n\t\t\tint rc;\n\n\t\t\tif (userquota_propname_decode(propname, zoned,\n\t\t\t    &uqtype, domain, sizeof (domain), &rid) != 0) {\n\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' has an invalid user/group name\"),\n\t\t\t\t    propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (uqtype != ZFS_PROP_USERQUOTA &&\n\t\t\t    uqtype != ZFS_PROP_GROUPQUOTA &&\n\t\t\t    uqtype != ZFS_PROP_USEROBJQUOTA &&\n\t\t\t    uqtype != ZFS_PROP_GROUPOBJQUOTA &&\n\t\t\t    uqtype != ZFS_PROP_PROJECTQUOTA &&\n\t\t\t    uqtype != ZFS_PROP_PROJECTOBJQUOTA) {\n\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t    dgettext(TEXT_DOMAIN, \"'%s' is readonly\"),\n\t\t\t\t    propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_PROPREADONLY,\n\t\t\t\t    errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (nvpair_type(elem) == DATA_TYPE_STRING) {\n\t\t\t\t(void) nvpair_value_string(elem, &strval);\n\t\t\t\tif (strcmp(strval, \"none\") == 0) {\n\t\t\t\t\tintval = 0;\n\t\t\t\t} else if (zfs_nicestrtonum(hdl,\n\t\t\t\t    strval, &intval) != 0) {\n\t\t\t\t\t(void) zfs_error(hdl,\n\t\t\t\t\t    EZFS_BADPROP, errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t} else if (nvpair_type(elem) ==\n\t\t\t    DATA_TYPE_UINT64) {\n\t\t\t\t(void) nvpair_value_uint64(elem, &intval);\n\t\t\t\tif (intval == 0) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"use 'none' to disable \"\n\t\t\t\t\t    \"{user|group|project}quota\"));\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' must be a number\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\trc = asprintf(&newpropname, \"%s%llx-%s\",\n\t\t\t    zfs_userquota_prop_prefixes[uqtype],\n\t\t\t    (longlong_t)rid, domain);\n\t\t\tif (rc == -1 || newpropname == NULL) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tvalary[0] = uqtype;\n\t\t\tvalary[1] = rid;\n\t\t\tvalary[2] = intval;\n\t\t\tif (nvlist_add_uint64_array(ret, newpropname,\n\t\t\t    valary, 3) != 0) {\n\t\t\t\tfree(newpropname);\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfree(newpropname);\n\t\t\tcontinue;\n\t\t} else if (prop == ZPROP_USERPROP &&\n\t\t    zfs_prop_written(propname)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' is readonly\"),\n\t\t\t    propname);\n\t\t\t(void) zfs_error(hdl, EZFS_PROPREADONLY, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (prop == ZPROP_INVAL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid property '%s'\"), propname);\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!zfs_prop_valid_for_type(prop, type, B_FALSE)) {\n\t\t\tzfs_error_aux(hdl,\n\t\t\t    dgettext(TEXT_DOMAIN, \"'%s' does not \"\n\t\t\t    \"apply to datasets of this type\"), propname);\n\t\t\t(void) zfs_error(hdl, EZFS_PROPTYPE, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (zfs_prop_readonly(prop) &&\n\t\t    !(zfs_prop_setonce(prop) && zhp == NULL) &&\n\t\t    !(zfs_prop_encryption_key_param(prop) && key_params_ok)) {\n\t\t\tzfs_error_aux(hdl,\n\t\t\t    dgettext(TEXT_DOMAIN, \"'%s' is readonly\"),\n\t\t\t    propname);\n\t\t\t(void) zfs_error(hdl, EZFS_PROPREADONLY, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (zprop_parse_value(hdl, elem, prop, type, ret,\n\t\t    &strval, &intval, errbuf) != 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_VERSION:\n\t\t{\n\t\t\tint version;\n\n\t\t\tif (zhp == NULL)\n\t\t\t\tbreak;\n\t\t\tversion = zfs_prop_get_int(zhp, ZFS_PROP_VERSION);\n\t\t\tif (intval < version) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"Can not downgrade; already at version %u\"),\n\t\t\t\t    version);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ZFS_PROP_VOLBLOCKSIZE:\n\t\tcase ZFS_PROP_RECORDSIZE:\n\t\t{\n\t\t\tint maxbs = SPA_MAXBLOCKSIZE;\n\t\t\tchar buf[64];\n\n\t\t\tif (zpool_hdl != NULL) {\n\t\t\t\tmaxbs = zpool_get_prop_int(zpool_hdl,\n\t\t\t\t    ZPOOL_PROP_MAXBLOCKSIZE, NULL);\n\t\t\t}\n\t\t\t \n\t\t\tif (intval < SPA_MINBLOCKSIZE ||\n\t\t\t    intval > maxbs || !ISP2(intval)) {\n\t\t\t\tzfs_nicebytes(maxbs, buf, sizeof (buf));\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' must be power of 2 from 512B \"\n\t\t\t\t    \"to %s\"), propname, buf);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tif (zpool_hdl == NULL && prop == ZFS_PROP_RECORDSIZE) {\n\t\t\t\tset_maxbs = intval;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ZFS_PROP_SPECIAL_SMALL_BLOCKS:\n\t\t{\n\t\t\tint maxbs =\n\t\t\t    set_maxbs == 0 ? SPA_OLD_MAXBLOCKSIZE : set_maxbs;\n\t\t\tchar buf[64];\n\n\t\t\tif (zpool_hdl != NULL) {\n\t\t\t\tchar state[64] = \"\";\n\n\t\t\t\tmaxbs = zpool_get_prop_int(zpool_hdl,\n\t\t\t\t    ZPOOL_PROP_MAXBLOCKSIZE, NULL);\n\n\t\t\t\t \n\t\t\t\tif (zpool_prop_get_feature(zpool_hdl,\n\t\t\t\t    \"feature@allocation_classes\", state,\n\t\t\t\t    sizeof (state)) != 0 ||\n\t\t\t\t    strcmp(state, ZFS_FEATURE_ACTIVE) != 0) {\n\t\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t\t    \"%s: property requires a special \"\n\t\t\t\t\t    \"device in the pool\\n\"), propname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (intval != 0 &&\n\t\t\t    (intval < SPA_MINBLOCKSIZE ||\n\t\t\t    intval > maxbs || !ISP2(intval))) {\n\t\t\t\tzfs_nicebytes(maxbs, buf, sizeof (buf));\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"invalid '%s=%llu' property: must be zero \"\n\t\t\t\t    \"or a power of 2 from 512B to %s\"),\n\t\t\t\t    propname, (unsigned long long)intval, buf);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ZFS_PROP_MLSLABEL:\n\t\t{\n#ifdef HAVE_MLSLABEL\n\t\t\t \n\n\t\t\tm_label_t *new_sl;\n\t\t\tchar *hex = NULL;\t \n\n\t\t\t \n\t\t\tif (strcasecmp(strval, ZFS_MLSLABEL_DEFAULT) == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (((new_sl = m_label_alloc(MAC_LABEL)) == NULL) ||\n\t\t\t    (str_to_label(strval, &new_sl, MAC_LABEL,\n\t\t\t    L_NO_CORRECTION, NULL) == -1)) {\n\t\t\t\tgoto badlabel;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (label_to_str(new_sl, &hex, M_INTERNAL,\n\t\t\t    DEF_NAMES) != 0) {\n\t\t\t\tif (hex)\n\t\t\t\t\tfree(hex);\n\t\t\t\tgoto badlabel;\n\t\t\t}\n\t\t\tm_label_free(new_sl);\n\n\t\t\t \n\t\t\tif (strcmp(strval, hex) == 0) {\n\t\t\t\tfree(hex);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\t(void) nvlist_remove(ret, zfs_prop_to_name(prop),\n\t\t\t    DATA_TYPE_STRING);\n\t\t\tfnvlist_add_string(ret, zfs_prop_to_name(prop), hex);\n\t\t\tfree(hex);\n\n\t\t\tbreak;\n\nbadlabel:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid mlslabel '%s'\"), strval);\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tm_label_free(new_sl);\t \n\t\t\tgoto error;\n#else\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"mlslabels are unsupported\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n#endif  \n\t\t}\n\n\t\tcase ZFS_PROP_MOUNTPOINT:\n\t\t{\n\t\t\tnamecheck_err_t why;\n\n\t\t\tif (strcmp(strval, ZFS_MOUNTPOINT_NONE) == 0 ||\n\t\t\t    strcmp(strval, ZFS_MOUNTPOINT_LEGACY) == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (mountpoint_namecheck(strval, &why)) {\n\t\t\t\tswitch (why) {\n\t\t\t\tcase NAME_ERR_LEADING_SLASH:\n\t\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s' must be an absolute path, \"\n\t\t\t\t\t    \"'none', or 'legacy'\"), propname);\n\t\t\t\t\tbreak;\n\t\t\t\tcase NAME_ERR_TOOLONG:\n\t\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"component of '%s' is too long\"),\n\t\t\t\t\t    propname);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tzfs_error_aux(hdl,\n\t\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"(%d) not defined\"),\n\t\t\t\t\t    why);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tzfs_fallthrough;\n\t\t}\n\n\t\tcase ZFS_PROP_SHARESMB:\n\t\tcase ZFS_PROP_SHARENFS:\n\t\t\t \n\t\t\tif (zoned) {\n\t\t\t\tif (getzoneid() == GLOBAL_ZONEID) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s' cannot be set on \"\n\t\t\t\t\t    \"dataset in a non-global zone\"),\n\t\t\t\t\t    propname);\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_ZONED,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (prop == ZFS_PROP_SHARENFS ||\n\t\t\t\t    prop == ZFS_PROP_SHARESMB) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s' cannot be set in \"\n\t\t\t\t\t    \"a non-global zone\"), propname);\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_ZONED,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t} else if (getzoneid() != GLOBAL_ZONEID) {\n\t\t\t\t \n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' cannot be set while dataset \"\n\t\t\t\t    \"'zoned' property is set\"), propname);\n\t\t\t\t(void) zfs_error(hdl, EZFS_ZONED, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((prop == ZFS_PROP_SHARENFS ||\n\t\t\t    prop == ZFS_PROP_SHARESMB) &&\n\t\t\t    strcmp(strval, \"on\") != 0 &&\n\t\t\t    strcmp(strval, \"off\") != 0) {\n\t\t\t\tenum sa_protocol proto;\n\n\t\t\t\tif (prop == ZFS_PROP_SHARESMB)\n\t\t\t\t\tproto = SA_PROTOCOL_SMB;\n\t\t\t\telse\n\t\t\t\t\tproto = SA_PROTOCOL_NFS;\n\n\t\t\t\tif (sa_validate_shareopts(strval, proto) !=\n\t\t\t\t    SA_OK) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s' cannot be set to invalid \"\n\t\t\t\t\t    \"options\"), propname);\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ZFS_PROP_KEYLOCATION:\n\t\t\tif (!zfs_prop_valid_keylocation(strval, B_FALSE)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"invalid keylocation\"));\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (zhp != NULL) {\n\t\t\t\tuint64_t crypt =\n\t\t\t\t    zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION);\n\n\t\t\t\tif (crypt == ZIO_CRYPT_OFF &&\n\t\t\t\t    strcmp(strval, \"none\") != 0) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"keylocation must be 'none' \"\n\t\t\t\t\t    \"for unencrypted datasets\"));\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t} else if (crypt != ZIO_CRYPT_OFF &&\n\t\t\t\t    strcmp(strval, \"none\") == 0) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"keylocation must not be 'none' \"\n\t\t\t\t\t    \"for encrypted datasets\"));\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZFS_PROP_PBKDF2_ITERS:\n\t\t\tif (intval < MIN_PBKDF2_ITERATIONS) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"minimum pbkdf2 iterations is %u\"),\n\t\t\t\t    MIN_PBKDF2_ITERATIONS);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ZFS_PROP_UTF8ONLY:\n\t\t\tchosen_utf = (int)intval;\n\t\t\tbreak;\n\n\t\tcase ZFS_PROP_NORMALIZE:\n\t\t\tchosen_normal = (int)intval;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (type == ZFS_TYPE_VOLUME && zhp != NULL) {\n\t\t\tuint64_t blocksize = zfs_prop_get_int(zhp,\n\t\t\t    ZFS_PROP_VOLBLOCKSIZE);\n\t\t\tchar buf[64];\n\n\t\t\tswitch (prop) {\n\t\t\tcase ZFS_PROP_VOLSIZE:\n\t\t\t\tif (intval % blocksize != 0) {\n\t\t\t\t\tzfs_nicebytes(blocksize, buf,\n\t\t\t\t\t    sizeof (buf));\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s' must be a multiple of \"\n\t\t\t\t\t    \"volume block size (%s)\"),\n\t\t\t\t\t    propname, buf);\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\tif (intval == 0) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"'%s' cannot be zero\"),\n\t\t\t\t\t    propname);\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (zhp != NULL) {\n\t\t\tint64_t crypt = zfs_prop_get_int(zhp,\n\t\t\t    ZFS_PROP_ENCRYPTION);\n\n\t\t\tswitch (prop) {\n\t\t\tcase ZFS_PROP_COPIES:\n\t\t\t\tif (crypt != ZIO_CRYPT_OFF && intval > 2) {\n\t\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t\t    \"encrypted datasets cannot have \"\n\t\t\t\t\t    \"3 copies\"));\n\t\t\t\t\t(void) zfs_error(hdl, EZFS_BADPROP,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (chosen_normal > 0 && chosen_utf < 0) {\n\t\tif (nvlist_add_uint64(ret,\n\t\t    zfs_prop_to_name(ZFS_PROP_UTF8ONLY), 1) != 0) {\n\t\t\t(void) no_memory(hdl);\n\t\t\tgoto error;\n\t\t}\n\t} else if (chosen_normal > 0 && chosen_utf == 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"'%s' must be set 'on' if normalization chosen\"),\n\t\t    zfs_prop_to_name(ZFS_PROP_UTF8ONLY));\n\t\t(void) zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\tgoto error;\n\t} else if (chosen_normal < 0 && chosen_utf == 0) {\n\t\tif (nvlist_add_uint64(ret,\n\t\t    zfs_prop_to_name(ZFS_PROP_NORMALIZE), 0) != 0) {\n\t\t\t(void) no_memory(hdl);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn (ret);\n\nerror:\n\tnvlist_free(ret);\n\treturn (NULL);\n}\n\nstatic int\nzfs_add_synthetic_resv(zfs_handle_t *zhp, nvlist_t *nvl)\n{\n\tuint64_t old_volsize;\n\tuint64_t new_volsize;\n\tuint64_t old_reservation;\n\tuint64_t new_reservation;\n\tzfs_prop_t resv_prop;\n\tnvlist_t *props;\n\tzpool_handle_t *zph = zpool_handle(zhp);\n\n\t \n\told_volsize = zfs_prop_get_int(zhp, ZFS_PROP_VOLSIZE);\n\tif (zfs_which_resv_prop(zhp, &resv_prop) < 0)\n\t\treturn (-1);\n\told_reservation = zfs_prop_get_int(zhp, resv_prop);\n\n\tprops = fnvlist_alloc();\n\tfnvlist_add_uint64(props, zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),\n\t    zfs_prop_get_int(zhp, ZFS_PROP_VOLBLOCKSIZE));\n\n\tif ((zvol_volsize_to_reservation(zph, old_volsize, props) !=\n\t    old_reservation) || nvlist_exists(nvl,\n\t    zfs_prop_to_name(resv_prop))) {\n\t\tfnvlist_free(props);\n\t\treturn (0);\n\t}\n\tif (nvlist_lookup_uint64(nvl, zfs_prop_to_name(ZFS_PROP_VOLSIZE),\n\t    &new_volsize) != 0) {\n\t\tfnvlist_free(props);\n\t\treturn (-1);\n\t}\n\tnew_reservation = zvol_volsize_to_reservation(zph, new_volsize, props);\n\tfnvlist_free(props);\n\n\tif (nvlist_add_uint64(nvl, zfs_prop_to_name(resv_prop),\n\t    new_reservation) != 0) {\n\t\t(void) no_memory(zhp->zfs_hdl);\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\n \nstatic int\nzfs_fix_auto_resv(zfs_handle_t *zhp, nvlist_t *nvl)\n{\n\tuint64_t volsize;\n\tuint64_t resvsize;\n\tzfs_prop_t prop;\n\tnvlist_t *props;\n\n\tif (!ZFS_IS_VOLUME(zhp)) {\n\t\treturn (0);\n\t}\n\n\tif (zfs_which_resv_prop(zhp, &prop) != 0) {\n\t\treturn (-1);\n\t}\n\n\tif (prop != ZFS_PROP_REFRESERVATION) {\n\t\treturn (0);\n\t}\n\n\tif (nvlist_lookup_uint64(nvl, zfs_prop_to_name(prop), &resvsize) != 0) {\n\t\t \n\t\treturn (0);\n\t}\n\tif (resvsize != UINT64_MAX) {\n\t\t \n\t\treturn (0);\n\t}\n\n\tprops = fnvlist_alloc();\n\n\tfnvlist_add_uint64(props, zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),\n\t    zfs_prop_get_int(zhp, ZFS_PROP_VOLBLOCKSIZE));\n\n\tif (nvlist_lookup_uint64(nvl, zfs_prop_to_name(ZFS_PROP_VOLSIZE),\n\t    &volsize) != 0) {\n\t\tvolsize = zfs_prop_get_int(zhp, ZFS_PROP_VOLSIZE);\n\t}\n\n\tresvsize = zvol_volsize_to_reservation(zpool_handle(zhp), volsize,\n\t    props);\n\tfnvlist_free(props);\n\n\t(void) nvlist_remove_all(nvl, zfs_prop_to_name(prop));\n\tif (nvlist_add_uint64(nvl, zfs_prop_to_name(prop), resvsize) != 0) {\n\t\t(void) no_memory(zhp->zfs_hdl);\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\nstatic boolean_t\nzfs_is_namespace_prop(zfs_prop_t prop)\n{\n\tswitch (prop) {\n\n\tcase ZFS_PROP_ATIME:\n\tcase ZFS_PROP_RELATIME:\n\tcase ZFS_PROP_DEVICES:\n\tcase ZFS_PROP_EXEC:\n\tcase ZFS_PROP_SETUID:\n\tcase ZFS_PROP_READONLY:\n\tcase ZFS_PROP_XATTR:\n\tcase ZFS_PROP_NBMAND:\n\t\treturn (B_TRUE);\n\n\tdefault:\n\t\treturn (B_FALSE);\n\t}\n}\n\n \nint\nzfs_prop_set(zfs_handle_t *zhp, const char *propname, const char *propval)\n{\n\tint ret = -1;\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvlist_t *nvl = NULL;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot set property for '%s'\"),\n\t    zhp->zfs_name);\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0 ||\n\t    nvlist_add_string(nvl, propname, propval) != 0) {\n\t\t(void) no_memory(hdl);\n\t\tgoto error;\n\t}\n\n\tret = zfs_prop_set_list(zhp, nvl);\n\nerror:\n\tnvlist_free(nvl);\n\treturn (ret);\n}\n\n \nint\nzfs_prop_set_list(zfs_handle_t *zhp, nvlist_t *props)\n{\n\treturn (zfs_prop_set_list_flags(zhp, props, 0));\n}\n\n \nint\nzfs_prop_set_list_flags(zfs_handle_t *zhp, nvlist_t *props, int flags)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint ret = -1;\n\tprop_changelist_t **cls = NULL;\n\tint cl_idx;\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvlist_t *nvl;\n\tint nvl_len = 0;\n\tint added_resv = 0;\n\tzfs_prop_t prop;\n\tboolean_t nsprop = B_FALSE;\n\tnvpair_t *elem;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot set property for '%s'\"),\n\t    zhp->zfs_name);\n\n\tif ((nvl = zfs_valid_proplist(hdl, zhp->zfs_type, props,\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ZONED), zhp, zhp->zpool_hdl,\n\t    B_FALSE, errbuf)) == NULL)\n\t\tgoto error;\n\n\t \n\tfor (elem = nvlist_next_nvpair(nvl, NULL);\n\t    elem != NULL;\n\t    elem = nvlist_next_nvpair(nvl, elem)) {\n\t\tif (zfs_name_to_prop(nvpair_name(elem)) == ZFS_PROP_VOLSIZE &&\n\t\t    (added_resv = zfs_add_synthetic_resv(zhp, nvl)) == -1) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (added_resv != 1 &&\n\t    (added_resv = zfs_fix_auto_resv(zhp, nvl)) == -1) {\n\t\tgoto error;\n\t}\n\n\t \n\tfor (elem = nvlist_next_nvpair(nvl, NULL);\n\t    elem != NULL;\n\t    elem = nvlist_next_nvpair(nvl, elem))\n\t\tnvl_len++;\n\tif ((cls = calloc(nvl_len, sizeof (prop_changelist_t *))) == NULL)\n\t\tgoto error;\n\n\tcl_idx = 0;\n\tfor (elem = nvlist_next_nvpair(nvl, NULL);\n\t    elem != NULL;\n\t    elem = nvlist_next_nvpair(nvl, elem)) {\n\n\t\tprop = zfs_name_to_prop(nvpair_name(elem));\n\t\tnsprop |= zfs_is_namespace_prop(prop);\n\n\t\tassert(cl_idx < nvl_len);\n\t\t \n\t\tif (prop != ZFS_PROP_CANMOUNT ||\n\t\t    (fnvpair_value_uint64(elem) == ZFS_CANMOUNT_OFF &&\n\t\t    zfs_is_mounted(zhp, NULL))) {\n\t\t\tcls[cl_idx] = changelist_gather(zhp, prop,\n\t\t\t    ((flags & ZFS_SET_NOMOUNT) ?\n\t\t\t    CL_GATHER_DONT_UNMOUNT : 0), 0);\n\t\t\tif (cls[cl_idx] == NULL)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tif (prop == ZFS_PROP_MOUNTPOINT &&\n\t\t    changelist_haszonedchild(cls[cl_idx])) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"child dataset with inherited mountpoint is used \"\n\t\t\t    \"in a non-global zone\"));\n\t\t\tret = zfs_error(hdl, EZFS_ZONED, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (cls[cl_idx] != NULL &&\n\t\t    (ret = changelist_prefix(cls[cl_idx])) != 0)\n\t\t\tgoto error;\n\n\t\tcl_idx++;\n\t}\n\tassert(cl_idx == nvl_len);\n\n\t \n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\tzcmd_write_src_nvlist(hdl, &zc, nvl);\n\tzcmd_alloc_dst_nvlist(hdl, &zc, 0);\n\n\tret = zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc);\n\n\tif (ret != 0) {\n\t\tif (zc.zc_nvlist_dst_filled == B_FALSE) {\n\t\t\t(void) zfs_standard_error(hdl, errno, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tnvlist_t *errorprops = NULL;\n\t\tif (zcmd_read_dst_nvlist(hdl, &zc, &errorprops) != 0)\n\t\t\tgoto error;\n\t\tfor (nvpair_t *elem = nvlist_next_nvpair(errorprops, NULL);\n\t\t    elem != NULL;\n\t\t    elem = nvlist_next_nvpair(errorprops, elem)) {\n\t\t\tprop = zfs_name_to_prop(nvpair_name(elem));\n\t\t\tzfs_setprop_error(hdl, prop, errno, errbuf);\n\t\t}\n\t\tnvlist_free(errorprops);\n\n\t\tif (added_resv && errno == ENOSPC) {\n\t\t\t \n\t\t\tuint64_t old_volsize = zfs_prop_get_int(zhp,\n\t\t\t    ZFS_PROP_VOLSIZE);\n\t\t\tnvlist_free(nvl);\n\t\t\tnvl = NULL;\n\t\t\tzcmd_free_nvlists(&zc);\n\n\t\t\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\t\t\tgoto error;\n\t\t\tif (nvlist_add_uint64(nvl,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE),\n\t\t\t    old_volsize) != 0)\n\t\t\t\tgoto error;\n\t\t\tzcmd_write_src_nvlist(hdl, &zc, nvl);\n\t\t\t(void) zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc);\n\t\t}\n\t} else {\n\t\tfor (cl_idx = 0; cl_idx < nvl_len; cl_idx++) {\n\t\t\tif (cls[cl_idx] != NULL) {\n\t\t\t\tint clp_err = changelist_postfix(cls[cl_idx]);\n\t\t\t\tif (clp_err != 0)\n\t\t\t\t\tret = clp_err;\n\t\t\t}\n\t\t}\n\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\t(void) get_stats(zhp);\n\n\t\t\t \n\t\t\tif (nsprop && zfs_is_mounted(zhp, NULL))\n\t\t\t\tret = zfs_mount(zhp, MNTOPT_REMOUNT, 0);\n\t\t}\n\t}\n\nerror:\n\tnvlist_free(nvl);\n\tzcmd_free_nvlists(&zc);\n\tif (cls != NULL) {\n\t\tfor (cl_idx = 0; cl_idx < nvl_len; cl_idx++) {\n\t\t\tif (cls[cl_idx] != NULL)\n\t\t\t\tchangelist_free(cls[cl_idx]);\n\t\t}\n\t\tfree(cls);\n\t}\n\treturn (ret);\n}\n\n \nint\nzfs_prop_inherit(zfs_handle_t *zhp, const char *propname, boolean_t received)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint ret;\n\tprop_changelist_t *cl;\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar errbuf[ERRBUFLEN];\n\tzfs_prop_t prop;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot inherit %s for '%s'\"), propname, zhp->zfs_name);\n\n\tzc.zc_cookie = received;\n\tif ((prop = zfs_name_to_prop(propname)) == ZPROP_USERPROP) {\n\t\t \n\t\tif (!zfs_prop_user(propname)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid property\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t\t}\n\n\t\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\t\t(void) strlcpy(zc.zc_value, propname, sizeof (zc.zc_value));\n\n\t\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_INHERIT_PROP, &zc) != 0)\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\n\t\t(void) get_stats(zhp);\n\t\treturn (0);\n\t}\n\n\t \n\tif (zfs_prop_readonly(prop))\n\t\treturn (zfs_error(hdl, EZFS_PROPREADONLY, errbuf));\n\n\tif (!zfs_prop_inheritable(prop) && !received)\n\t\treturn (zfs_error(hdl, EZFS_PROPNONINHERIT, errbuf));\n\n\t \n\tif (!zfs_prop_valid_for_type(prop, zhp->zfs_type, B_FALSE))\n\t\treturn (zfs_error(hdl, EZFS_PROPTYPE, errbuf));\n\n\t \n\tpropname = zfs_prop_to_name(prop);\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\t(void) strlcpy(zc.zc_value, propname, sizeof (zc.zc_value));\n\n\tif (prop == ZFS_PROP_MOUNTPOINT && getzoneid() == GLOBAL_ZONEID &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ZONED)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dataset is used in a non-global zone\"));\n\t\treturn (zfs_error(hdl, EZFS_ZONED, errbuf));\n\t}\n\n\t \n\tif ((cl = changelist_gather(zhp, prop, 0, 0)) == NULL)\n\t\treturn (-1);\n\n\tif (prop == ZFS_PROP_MOUNTPOINT && changelist_haszonedchild(cl)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"child dataset with inherited mountpoint is used \"\n\t\t    \"in a non-global zone\"));\n\t\tret = zfs_error(hdl, EZFS_ZONED, errbuf);\n\t\tgoto error;\n\t}\n\n\tif ((ret = changelist_prefix(cl)) != 0)\n\t\tgoto error;\n\n\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_INHERIT_PROP, &zc) != 0) {\n\t\tchangelist_free(cl);\n\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t} else {\n\n\t\tif ((ret = changelist_postfix(cl)) != 0)\n\t\t\tgoto error;\n\n\t\t \n\t\t(void) get_stats(zhp);\n\n\t\t \n\t\tif (zfs_is_namespace_prop(prop) &&\n\t\t    zfs_is_mounted(zhp, NULL))\n\t\t\tret = zfs_mount(zhp, MNTOPT_REMOUNT, 0);\n\t}\n\nerror:\n\tchangelist_free(cl);\n\treturn (ret);\n}\n\n \nuint64_t\ngetprop_uint64(zfs_handle_t *zhp, zfs_prop_t prop, const char **source)\n{\n\tnvlist_t *nv;\n\tuint64_t value;\n\n\t*source = NULL;\n\tif (nvlist_lookup_nvlist(zhp->zfs_props,\n\t    zfs_prop_to_name(prop), &nv) == 0) {\n\t\tvalue = fnvlist_lookup_uint64(nv, ZPROP_VALUE);\n\t\t(void) nvlist_lookup_string(nv, ZPROP_SOURCE, source);\n\t} else {\n\t\tverify(!zhp->zfs_props_table ||\n\t\t    zhp->zfs_props_table[prop] == B_TRUE);\n\t\tvalue = zfs_prop_default_numeric(prop);\n\t\t*source = \"\";\n\t}\n\n\treturn (value);\n}\n\nstatic const char *\ngetprop_string(zfs_handle_t *zhp, zfs_prop_t prop, const char **source)\n{\n\tnvlist_t *nv;\n\tconst char *value;\n\n\t*source = NULL;\n\tif (nvlist_lookup_nvlist(zhp->zfs_props,\n\t    zfs_prop_to_name(prop), &nv) == 0) {\n\t\tvalue = fnvlist_lookup_string(nv, ZPROP_VALUE);\n\t\t(void) nvlist_lookup_string(nv, ZPROP_SOURCE, source);\n\t} else {\n\t\tverify(!zhp->zfs_props_table ||\n\t\t    zhp->zfs_props_table[prop] == B_TRUE);\n\t\tvalue = zfs_prop_default_string(prop);\n\t\t*source = \"\";\n\t}\n\n\treturn (value);\n}\n\nstatic boolean_t\nzfs_is_recvd_props_mode(zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_props != NULL &&\n\t    zhp->zfs_props == zhp->zfs_recvd_props);\n}\n\nstatic void\nzfs_set_recvd_props_mode(zfs_handle_t *zhp, uintptr_t *cookie)\n{\n\t*cookie = (uintptr_t)zhp->zfs_props;\n\tzhp->zfs_props = zhp->zfs_recvd_props;\n}\n\nstatic void\nzfs_unset_recvd_props_mode(zfs_handle_t *zhp, uintptr_t *cookie)\n{\n\tzhp->zfs_props = (nvlist_t *)*cookie;\n\t*cookie = 0;\n}\n\n \nstatic int\nget_numeric_property(zfs_handle_t *zhp, zfs_prop_t prop, zprop_source_t *src,\n    const char **source, uint64_t *val)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tnvlist_t *zplprops = NULL;\n\tstruct mnttab mnt;\n\tconst char *mntopt_on = NULL;\n\tconst char *mntopt_off = NULL;\n\tboolean_t received = zfs_is_recvd_props_mode(zhp);\n\n\t*source = NULL;\n\n\t \n\tif (zhp->zfs_type == ZFS_TYPE_SNAPSHOT &&\n\t    !zfs_prop_valid_for_type(prop, zhp->zfs_head_type, B_TRUE)) {\n\t\t*val = zfs_prop_default_numeric(prop);\n\t\treturn (-1);\n\t}\n\n\tswitch (prop) {\n\tcase ZFS_PROP_ATIME:\n\t\tmntopt_on = MNTOPT_ATIME;\n\t\tmntopt_off = MNTOPT_NOATIME;\n\t\tbreak;\n\n\tcase ZFS_PROP_RELATIME:\n\t\tmntopt_on = MNTOPT_RELATIME;\n\t\tmntopt_off = MNTOPT_NORELATIME;\n\t\tbreak;\n\n\tcase ZFS_PROP_DEVICES:\n\t\tmntopt_on = MNTOPT_DEVICES;\n\t\tmntopt_off = MNTOPT_NODEVICES;\n\t\tbreak;\n\n\tcase ZFS_PROP_EXEC:\n\t\tmntopt_on = MNTOPT_EXEC;\n\t\tmntopt_off = MNTOPT_NOEXEC;\n\t\tbreak;\n\n\tcase ZFS_PROP_READONLY:\n\t\tmntopt_on = MNTOPT_RO;\n\t\tmntopt_off = MNTOPT_RW;\n\t\tbreak;\n\n\tcase ZFS_PROP_SETUID:\n\t\tmntopt_on = MNTOPT_SETUID;\n\t\tmntopt_off = MNTOPT_NOSETUID;\n\t\tbreak;\n\n\tcase ZFS_PROP_XATTR:\n\t\tmntopt_on = MNTOPT_XATTR;\n\t\tmntopt_off = MNTOPT_NOXATTR;\n\t\tbreak;\n\n\tcase ZFS_PROP_NBMAND:\n\t\tmntopt_on = MNTOPT_NBMAND;\n\t\tmntopt_off = MNTOPT_NONBMAND;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!zhp->zfs_mntcheck &&\n\t    (mntopt_on != NULL || prop == ZFS_PROP_MOUNTED)) {\n\t\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\t\tstruct mnttab entry;\n\n\t\tif (libzfs_mnttab_find(hdl, zhp->zfs_name, &entry) == 0)\n\t\t\tzhp->zfs_mntopts = zfs_strdup(hdl,\n\t\t\t    entry.mnt_mntopts);\n\n\t\tzhp->zfs_mntcheck = B_TRUE;\n\t}\n\n\tif (zhp->zfs_mntopts == NULL)\n\t\tmnt.mnt_mntopts = (char *)\"\";\n\telse\n\t\tmnt.mnt_mntopts = zhp->zfs_mntopts;\n\n\tswitch (prop) {\n\tcase ZFS_PROP_ATIME:\n\tcase ZFS_PROP_RELATIME:\n\tcase ZFS_PROP_DEVICES:\n\tcase ZFS_PROP_EXEC:\n\tcase ZFS_PROP_READONLY:\n\tcase ZFS_PROP_SETUID:\n#ifndef __FreeBSD__\n\tcase ZFS_PROP_XATTR:\n#endif\n\tcase ZFS_PROP_NBMAND:\n\t\t*val = getprop_uint64(zhp, prop, source);\n\n\t\tif (received)\n\t\t\tbreak;\n\n\t\tif (hasmntopt(&mnt, mntopt_on) && !*val) {\n\t\t\t*val = B_TRUE;\n\t\t\tif (src)\n\t\t\t\t*src = ZPROP_SRC_TEMPORARY;\n\t\t} else if (hasmntopt(&mnt, mntopt_off) && *val) {\n\t\t\t*val = B_FALSE;\n\t\t\tif (src)\n\t\t\t\t*src = ZPROP_SRC_TEMPORARY;\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_CANMOUNT:\n\tcase ZFS_PROP_VOLSIZE:\n\tcase ZFS_PROP_QUOTA:\n\tcase ZFS_PROP_REFQUOTA:\n\tcase ZFS_PROP_RESERVATION:\n\tcase ZFS_PROP_REFRESERVATION:\n\tcase ZFS_PROP_FILESYSTEM_LIMIT:\n\tcase ZFS_PROP_SNAPSHOT_LIMIT:\n\tcase ZFS_PROP_FILESYSTEM_COUNT:\n\tcase ZFS_PROP_SNAPSHOT_COUNT:\n\t\t*val = getprop_uint64(zhp, prop, source);\n\n\t\tif (*source == NULL) {\n\t\t\t \n\t\t\t*source = zhp->zfs_name;\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_MOUNTED:\n\t\t*val = (zhp->zfs_mntopts != NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_NUMCLONES:\n\t\t*val = zhp->zfs_dmustats.dds_num_clones;\n\t\tbreak;\n\n\tcase ZFS_PROP_VERSION:\n\tcase ZFS_PROP_NORMALIZE:\n\tcase ZFS_PROP_UTF8ONLY:\n\tcase ZFS_PROP_CASE:\n\t\tzcmd_alloc_dst_nvlist(zhp->zfs_hdl, &zc, 0);\n\n\t\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\t\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_OBJSET_ZPLPROPS, &zc)) {\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t\tif (prop == ZFS_PROP_VERSION &&\n\t\t\t    zhp->zfs_type == ZFS_TYPE_VOLUME)\n\t\t\t\t*val = zfs_prop_default_numeric(prop);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (zcmd_read_dst_nvlist(zhp->zfs_hdl, &zc, &zplprops) != 0 ||\n\t\t    nvlist_lookup_uint64(zplprops, zfs_prop_to_name(prop),\n\t\t    val) != 0) {\n\t\t\tzcmd_free_nvlists(&zc);\n\t\t\treturn (-1);\n\t\t}\n\t\tnvlist_free(zplprops);\n\t\tzcmd_free_nvlists(&zc);\n\t\tbreak;\n\n\tcase ZFS_PROP_INCONSISTENT:\n\t\t*val = zhp->zfs_dmustats.dds_inconsistent;\n\t\tbreak;\n\n\tcase ZFS_PROP_REDACTED:\n\t\t*val = zhp->zfs_dmustats.dds_redacted;\n\t\tbreak;\n\n\tcase ZFS_PROP_GUID:\n\t\tif (zhp->zfs_dmustats.dds_guid != 0)\n\t\t\t*val = zhp->zfs_dmustats.dds_guid;\n\t\telse\n\t\t\t*val = getprop_uint64(zhp, prop, source);\n\t\tbreak;\n\n\tcase ZFS_PROP_CREATETXG:\n\t\t \n\t\tif (((zhp->zfs_type == ZFS_TYPE_FILESYSTEM) ||\n\t\t    (zhp->zfs_type == ZFS_TYPE_SNAPSHOT) ||\n\t\t    (zhp->zfs_type == ZFS_TYPE_VOLUME)) &&\n\t\t    (zhp->zfs_dmustats.dds_creation_txg != 0)) {\n\t\t\t*val = zhp->zfs_dmustats.dds_creation_txg;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t*val = getprop_uint64(zhp, prop, source);\n\t\t}\n\t\tzfs_fallthrough;\n\tdefault:\n\t\tswitch (zfs_prop_get_type(prop)) {\n\t\tcase PROP_TYPE_NUMBER:\n\t\tcase PROP_TYPE_INDEX:\n\t\t\t*val = getprop_uint64(zhp, prop, source);\n\t\t\t \n\t\t\tif (zfs_prop_readonly(prop) &&\n\t\t\t    !zfs_prop_setonce(prop) &&\n\t\t\t    *source != NULL && (*source)[0] == '\\0') {\n\t\t\t\t*source = NULL;\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PROP_TYPE_STRING:\n\t\tdefault:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot get non-numeric property\"));\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_BADPROP,\n\t\t\t    dgettext(TEXT_DOMAIN, \"internal error\")));\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nget_source(zfs_handle_t *zhp, zprop_source_t *srctype, const char *source,\n    char *statbuf, size_t statlen)\n{\n\tif (statbuf == NULL ||\n\t    srctype == NULL || *srctype == ZPROP_SRC_TEMPORARY) {\n\t\treturn;\n\t}\n\n\tif (source == NULL) {\n\t\t*srctype = ZPROP_SRC_NONE;\n\t} else if (source[0] == '\\0') {\n\t\t*srctype = ZPROP_SRC_DEFAULT;\n\t} else if (strstr(source, ZPROP_SOURCE_VAL_RECVD) != NULL) {\n\t\t*srctype = ZPROP_SRC_RECEIVED;\n\t} else {\n\t\tif (strcmp(source, zhp->zfs_name) == 0) {\n\t\t\t*srctype = ZPROP_SRC_LOCAL;\n\t\t} else {\n\t\t\t(void) strlcpy(statbuf, source, statlen);\n\t\t\t*srctype = ZPROP_SRC_INHERITED;\n\t\t}\n\t}\n\n}\n\nint\nzfs_prop_get_recvd(zfs_handle_t *zhp, const char *propname, char *propbuf,\n    size_t proplen, boolean_t literal)\n{\n\tzfs_prop_t prop;\n\tint err = 0;\n\n\tif (zhp->zfs_recvd_props == NULL)\n\t\tif (get_recvd_props_ioctl(zhp) != 0)\n\t\t\treturn (-1);\n\n\tprop = zfs_name_to_prop(propname);\n\n\tif (prop != ZPROP_USERPROP) {\n\t\tuintptr_t cookie;\n\t\tif (!nvlist_exists(zhp->zfs_recvd_props, propname))\n\t\t\treturn (-1);\n\t\tzfs_set_recvd_props_mode(zhp, &cookie);\n\t\terr = zfs_prop_get(zhp, prop, propbuf, proplen,\n\t\t    NULL, NULL, 0, literal);\n\t\tzfs_unset_recvd_props_mode(zhp, &cookie);\n\t} else {\n\t\tnvlist_t *propval;\n\t\tconst char *recvdval;\n\t\tif (nvlist_lookup_nvlist(zhp->zfs_recvd_props,\n\t\t    propname, &propval) != 0)\n\t\t\treturn (-1);\n\t\trecvdval = fnvlist_lookup_string(propval, ZPROP_VALUE);\n\t\t(void) strlcpy(propbuf, recvdval, proplen);\n\t}\n\n\treturn (err == 0 ? 0 : -1);\n}\n\nstatic int\nget_clones_string(zfs_handle_t *zhp, char *propbuf, size_t proplen)\n{\n\tnvlist_t *value;\n\tnvpair_t *pair;\n\n\tvalue = zfs_get_clones_nvl(zhp);\n\tif (value == NULL || nvlist_empty(value))\n\t\treturn (-1);\n\n\tpropbuf[0] = '\\0';\n\tfor (pair = nvlist_next_nvpair(value, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(value, pair)) {\n\t\tif (propbuf[0] != '\\0')\n\t\t\t(void) strlcat(propbuf, \",\", proplen);\n\t\t(void) strlcat(propbuf, nvpair_name(pair), proplen);\n\t}\n\n\treturn (0);\n}\n\nstruct get_clones_arg {\n\tuint64_t numclones;\n\tnvlist_t *value;\n\tconst char *origin;\n\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n};\n\nstatic int\nget_clones_cb(zfs_handle_t *zhp, void *arg)\n{\n\tstruct get_clones_arg *gca = arg;\n\n\tif (gca->numclones == 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get(zhp, ZFS_PROP_ORIGIN, gca->buf, sizeof (gca->buf),\n\t    NULL, NULL, 0, B_TRUE) != 0)\n\t\tgoto out;\n\tif (strcmp(gca->buf, gca->origin) == 0) {\n\t\tfnvlist_add_boolean(gca->value, zfs_get_name(zhp));\n\t\tgca->numclones--;\n\t}\n\nout:\n\t(void) zfs_iter_children_v2(zhp, 0, get_clones_cb, gca);\n\tzfs_close(zhp);\n\treturn (0);\n}\n\nnvlist_t *\nzfs_get_clones_nvl(zfs_handle_t *zhp)\n{\n\tnvlist_t *nv, *value;\n\n\tif (nvlist_lookup_nvlist(zhp->zfs_props,\n\t    zfs_prop_to_name(ZFS_PROP_CLONES), &nv) != 0) {\n\t\tstruct get_clones_arg gca;\n\n\t\t \n\t\tif (zhp->zfs_type != ZFS_TYPE_SNAPSHOT)\n\t\t\treturn (NULL);\n\t\tif (nvlist_alloc(&nv, NV_UNIQUE_NAME, 0) != 0)\n\t\t\treturn (NULL);\n\t\tif (nvlist_alloc(&value, NV_UNIQUE_NAME, 0) != 0) {\n\t\t\tnvlist_free(nv);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tgca.numclones = zfs_prop_get_int(zhp, ZFS_PROP_NUMCLONES);\n\t\tgca.value = value;\n\t\tgca.origin = zhp->zfs_name;\n\n\t\tif (gca.numclones != 0) {\n\t\t\tzfs_handle_t *root;\n\t\t\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\tchar *cp = pool;\n\n\t\t\t \n\t\t\t(void) strlcpy(pool, zhp->zfs_name, sizeof (pool));\n\t\t\t(void) strsep(&cp, \"/@\");\n\t\t\troot = zfs_open(zhp->zfs_hdl, pool,\n\t\t\t    ZFS_TYPE_FILESYSTEM);\n\t\t\tif (root == NULL) {\n\t\t\t\tnvlist_free(nv);\n\t\t\t\tnvlist_free(value);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t\t\t(void) get_clones_cb(root, &gca);\n\t\t}\n\n\t\tif (gca.numclones != 0 ||\n\t\t    nvlist_add_nvlist(nv, ZPROP_VALUE, value) != 0 ||\n\t\t    nvlist_add_nvlist(zhp->zfs_props,\n\t\t    zfs_prop_to_name(ZFS_PROP_CLONES), nv) != 0) {\n\t\t\tnvlist_free(nv);\n\t\t\tnvlist_free(value);\n\t\t\treturn (NULL);\n\t\t}\n\t\tnvlist_free(nv);\n\t\tnvlist_free(value);\n\t\tnv = fnvlist_lookup_nvlist(zhp->zfs_props,\n\t\t    zfs_prop_to_name(ZFS_PROP_CLONES));\n\t}\n\n\treturn (fnvlist_lookup_nvlist(nv, ZPROP_VALUE));\n}\n\nstatic int\nget_rsnaps_string(zfs_handle_t *zhp, char *propbuf, size_t proplen)\n{\n\tnvlist_t *value;\n\tuint64_t *snaps;\n\tuint_t nsnaps;\n\n\tif (nvlist_lookup_nvlist(zhp->zfs_props,\n\t    zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS), &value) != 0)\n\t\treturn (-1);\n\tif (nvlist_lookup_uint64_array(value, ZPROP_VALUE, &snaps,\n\t    &nsnaps) != 0)\n\t\treturn (-1);\n\tif (nsnaps == 0) {\n\t\t \n\t\t(void) snprintf(propbuf, proplen, \"none\");\n\t\treturn (0);\n\t}\n\tpropbuf[0] = '\\0';\n\tfor (int i = 0; i < nsnaps; i++) {\n\t\tchar buf[128];\n\t\tif (propbuf[0] != '\\0')\n\t\t\t(void) strlcat(propbuf, \",\", proplen);\n\t\t(void) snprintf(buf, sizeof (buf), \"%llu\",\n\t\t    (u_longlong_t)snaps[i]);\n\t\t(void) strlcat(propbuf, buf, proplen);\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nzcp_check(zfs_handle_t *zhp, zfs_prop_t prop, uint64_t intval,\n    const char *strval)\n{\n\tif (!zhp->zfs_hdl->libzfs_prop_debug)\n\t\treturn;\n\tint error;\n\tchar *poolname = zhp->zpool_hdl->zpool_name;\n\tconst char *prop_name = zfs_prop_to_name(prop);\n\tconst char *program =\n\t    \"args = ...\\n\"\n\t    \"ds = args['dataset']\\n\"\n\t    \"prop = args['property']\\n\"\n\t    \"value, setpoint = zfs.get_prop(ds, prop)\\n\"\n\t    \"return {value=value, setpoint=setpoint}\\n\";\n\tnvlist_t *outnvl;\n\tnvlist_t *retnvl;\n\tnvlist_t *argnvl = fnvlist_alloc();\n\n\tfnvlist_add_string(argnvl, \"dataset\", zhp->zfs_name);\n\tfnvlist_add_string(argnvl, \"property\", zfs_prop_to_name(prop));\n\n\terror = lzc_channel_program_nosync(poolname, program,\n\t    10 * 1000 * 1000, 10 * 1024 * 1024, argnvl, &outnvl);\n\n\tif (error == 0) {\n\t\tretnvl = fnvlist_lookup_nvlist(outnvl, \"return\");\n\t\tif (zfs_prop_get_type(prop) == PROP_TYPE_NUMBER) {\n\t\t\tint64_t ans;\n\t\t\terror = nvlist_lookup_int64(retnvl, \"value\", &ans);\n\t\t\tif (error != 0) {\n\t\t\t\t(void) fprintf(stderr, \"%s: zcp check error: \"\n\t\t\t\t    \"%u\\n\", prop_name, error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ans != intval) {\n\t\t\t\t(void) fprintf(stderr, \"%s: zfs found %llu, \"\n\t\t\t\t    \"but zcp found %llu\\n\", prop_name,\n\t\t\t\t    (u_longlong_t)intval, (u_longlong_t)ans);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *str_ans;\n\t\t\terror = nvlist_lookup_string(retnvl, \"value\", &str_ans);\n\t\t\tif (error != 0) {\n\t\t\t\t(void) fprintf(stderr, \"%s: zcp check error: \"\n\t\t\t\t    \"%u\\n\", prop_name, error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (strcmp(strval, str_ans) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"%s: zfs found '%s', but zcp found '%s'\\n\",\n\t\t\t\t    prop_name, strval, str_ans);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t(void) fprintf(stderr, \"%s: zcp check failed, channel program \"\n\t\t    \"error: %u\\n\", prop_name, error);\n\t}\n\tnvlist_free(argnvl);\n\tnvlist_free(outnvl);\n}\n\n \nint\nzfs_prop_get(zfs_handle_t *zhp, zfs_prop_t prop, char *propbuf, size_t proplen,\n    zprop_source_t *src, char *statbuf, size_t statlen, boolean_t literal)\n{\n\tconst char *source = NULL;\n\tuint64_t val;\n\tconst char *str;\n\tconst char *strval;\n\tboolean_t received = zfs_is_recvd_props_mode(zhp);\n\n\t \n\tif (!zfs_prop_valid_for_type(prop, zhp->zfs_type, B_FALSE))\n\t\treturn (-1);\n\n\tif (received && zfs_prop_readonly(prop))\n\t\treturn (-1);\n\n\tif (src)\n\t\t*src = ZPROP_SRC_NONE;\n\n\tswitch (prop) {\n\tcase ZFS_PROP_CREATION:\n\t\t \n\t\t{\n\t\t\tval = getprop_uint64(zhp, prop, &source);\n\t\t\ttime_t time = (time_t)val;\n\t\t\tstruct tm t;\n\n\t\t\tif (literal ||\n\t\t\t    localtime_r(&time, &t) == NULL ||\n\t\t\t    strftime(propbuf, proplen, \"%a %b %e %k:%M %Y\",\n\t\t\t    &t) == 0)\n\t\t\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t\t\t    (u_longlong_t)val);\n\t\t}\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_MOUNTPOINT:\n\t\t \n\n\t\tstr = getprop_string(zhp, prop, &source);\n\n\t\tif (str[0] == '/') {\n\t\t\tchar buf[MAXPATHLEN];\n\t\t\tchar *root = buf;\n\t\t\tconst char *relpath;\n\n\t\t\t \n\t\t\tif (strcmp(source, ZPROP_SOURCE_VAL_RECVD) == 0) {\n\t\t\t\trelpath = \"\";\n\t\t\t} else {\n\t\t\t\trelpath = zhp->zfs_name + strlen(source);\n\t\t\t\tif (relpath[0] == '/')\n\t\t\t\t\trelpath++;\n\t\t\t}\n\n\t\t\tif ((zpool_get_prop(zhp->zpool_hdl,\n\t\t\t    ZPOOL_PROP_ALTROOT, buf, MAXPATHLEN, NULL,\n\t\t\t    B_FALSE)) || (strcmp(root, \"-\") == 0))\n\t\t\t\troot[0] = '\\0';\n\t\t\t \n\t\t\tif (strcmp(root, \"/\") == 0)\n\t\t\t\troot++;\n\n\t\t\t \n\t\t\tif (str[1] == '\\0' && (root[0] != '\\0' ||\n\t\t\t    relpath[0] != '\\0'))\n\t\t\t\tstr++;\n\n\t\t\tif (relpath[0] == '\\0')\n\t\t\t\t(void) snprintf(propbuf, proplen, \"%s%s\",\n\t\t\t\t    root, str);\n\t\t\telse\n\t\t\t\t(void) snprintf(propbuf, proplen, \"%s%s%s%s\",\n\t\t\t\t    root, str, relpath[0] == '@' ? \"\" : \"/\",\n\t\t\t\t    relpath);\n\t\t} else {\n\t\t\t \n\t\t\t(void) strlcpy(propbuf, str, proplen);\n\t\t}\n\t\tzcp_check(zhp, prop, 0, propbuf);\n\t\tbreak;\n\n\tcase ZFS_PROP_ORIGIN:\n\t\tif (*zhp->zfs_dmustats.dds_origin != '\\0') {\n\t\t\tstr = (char *)&zhp->zfs_dmustats.dds_origin;\n\t\t} else {\n\t\t\tstr = getprop_string(zhp, prop, &source);\n\t\t}\n\t\tif (str == NULL || *str == '\\0')\n\t\t\tstr = zfs_prop_default_string(prop);\n\t\tif (str == NULL)\n\t\t\treturn (-1);\n\t\t(void) strlcpy(propbuf, str, proplen);\n\t\tzcp_check(zhp, prop, 0, str);\n\t\tbreak;\n\n\tcase ZFS_PROP_REDACT_SNAPS:\n\t\tif (get_rsnaps_string(zhp, propbuf, proplen) != 0)\n\t\t\treturn (-1);\n\t\tbreak;\n\n\tcase ZFS_PROP_CLONES:\n\t\tif (get_clones_string(zhp, propbuf, proplen) != 0)\n\t\t\treturn (-1);\n\t\tbreak;\n\n\tcase ZFS_PROP_QUOTA:\n\tcase ZFS_PROP_REFQUOTA:\n\tcase ZFS_PROP_RESERVATION:\n\tcase ZFS_PROP_REFRESERVATION:\n\n\t\tif (get_numeric_property(zhp, prop, src, &source, &val) != 0)\n\t\t\treturn (-1);\n\t\t \n\t\tif (val == 0) {\n\t\t\tif (literal)\n\t\t\t\t(void) strlcpy(propbuf, \"0\", proplen);\n\t\t\telse\n\t\t\t\t(void) strlcpy(propbuf, \"none\", proplen);\n\t\t} else {\n\t\t\tif (literal)\n\t\t\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t\t\t    (u_longlong_t)val);\n\t\t\telse\n\t\t\t\tzfs_nicebytes(val, propbuf, proplen);\n\t\t}\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_FILESYSTEM_LIMIT:\n\tcase ZFS_PROP_SNAPSHOT_LIMIT:\n\tcase ZFS_PROP_FILESYSTEM_COUNT:\n\tcase ZFS_PROP_SNAPSHOT_COUNT:\n\n\t\tif (get_numeric_property(zhp, prop, src, &source, &val) != 0)\n\t\t\treturn (-1);\n\n\t\t \n\t\tif (val == UINT64_MAX) {\n\t\t\t(void) strlcpy(propbuf, \"none\", proplen);\n\t\t} else if (literal) {\n\t\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t\t    (u_longlong_t)val);\n\t\t} else {\n\t\t\tzfs_nicenum(val, propbuf, proplen);\n\t\t}\n\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_REFRATIO:\n\tcase ZFS_PROP_COMPRESSRATIO:\n\t\tif (get_numeric_property(zhp, prop, src, &source, &val) != 0)\n\t\t\treturn (-1);\n\t\tif (literal)\n\t\t\t(void) snprintf(propbuf, proplen, \"%llu.%02llu\",\n\t\t\t    (u_longlong_t)(val / 100),\n\t\t\t    (u_longlong_t)(val % 100));\n\t\telse\n\t\t\t(void) snprintf(propbuf, proplen, \"%llu.%02llux\",\n\t\t\t    (u_longlong_t)(val / 100),\n\t\t\t    (u_longlong_t)(val % 100));\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_TYPE:\n\t\tswitch (zhp->zfs_type) {\n\t\tcase ZFS_TYPE_FILESYSTEM:\n\t\t\tstr = \"filesystem\";\n\t\t\tbreak;\n\t\tcase ZFS_TYPE_VOLUME:\n\t\t\tstr = \"volume\";\n\t\t\tbreak;\n\t\tcase ZFS_TYPE_SNAPSHOT:\n\t\t\tstr = \"snapshot\";\n\t\t\tbreak;\n\t\tcase ZFS_TYPE_BOOKMARK:\n\t\t\tstr = \"bookmark\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t\t(void) snprintf(propbuf, proplen, \"%s\", str);\n\t\tzcp_check(zhp, prop, 0, propbuf);\n\t\tbreak;\n\n\tcase ZFS_PROP_MOUNTED:\n\t\t \n\t\tif (get_numeric_property(zhp, ZFS_PROP_MOUNTED,\n\t\t    src, &source, &val) != 0)\n\t\t\treturn (-1);\n\t\tif (val)\n\t\t\t(void) strlcpy(propbuf, \"yes\", proplen);\n\t\telse\n\t\t\t(void) strlcpy(propbuf, \"no\", proplen);\n\t\tbreak;\n\n\tcase ZFS_PROP_NAME:\n\t\t \n\t\t(void) strlcpy(propbuf, zhp->zfs_name, proplen);\n\t\tzcp_check(zhp, prop, 0, propbuf);\n\t\tbreak;\n\n\tcase ZFS_PROP_MLSLABEL:\n\t\t{\n#ifdef HAVE_MLSLABEL\n\t\t\tm_label_t *new_sl = NULL;\n\t\t\tchar *ascii = NULL;\t \n\n\t\t\t(void) strlcpy(propbuf,\n\t\t\t    getprop_string(zhp, prop, &source), proplen);\n\n\t\t\tif (literal || (strcasecmp(propbuf,\n\t\t\t    ZFS_MLSLABEL_DEFAULT) == 0))\n\t\t\t\tbreak;\n\n\t\t\t \n\n\t\t\tif (str_to_label(propbuf, &new_sl, MAC_LABEL,\n\t\t\t    L_NO_CORRECTION, NULL) == -1) {\n\t\t\t\tm_label_free(new_sl);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (label_to_str(new_sl, &ascii, M_LABEL,\n\t\t\t    DEF_NAMES) != 0) {\n\t\t\t\tif (ascii)\n\t\t\t\t\tfree(ascii);\n\t\t\t\tm_label_free(new_sl);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_label_free(new_sl);\n\n\t\t\t(void) strlcpy(propbuf, ascii, proplen);\n\t\t\tfree(ascii);\n#else\n\t\t\t(void) strlcpy(propbuf,\n\t\t\t    getprop_string(zhp, prop, &source), proplen);\n#endif  \n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_GUID:\n\tcase ZFS_PROP_KEY_GUID:\n\tcase ZFS_PROP_IVSET_GUID:\n\tcase ZFS_PROP_CREATETXG:\n\tcase ZFS_PROP_OBJSETID:\n\tcase ZFS_PROP_PBKDF2_ITERS:\n\t\t \n\t\tif (get_numeric_property(zhp, prop, src, &source, &val) != 0)\n\t\t\treturn (-1);\n\t\t(void) snprintf(propbuf, proplen, \"%llu\", (u_longlong_t)val);\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_REFERENCED:\n\tcase ZFS_PROP_AVAILABLE:\n\tcase ZFS_PROP_USED:\n\tcase ZFS_PROP_USEDSNAP:\n\tcase ZFS_PROP_USEDDS:\n\tcase ZFS_PROP_USEDREFRESERV:\n\tcase ZFS_PROP_USEDCHILD:\n\t\tif (get_numeric_property(zhp, prop, src, &source, &val) != 0)\n\t\t\treturn (-1);\n\t\tif (literal) {\n\t\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t\t    (u_longlong_t)val);\n\t\t} else {\n\t\t\tzfs_nicebytes(val, propbuf, proplen);\n\t\t}\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tcase ZFS_PROP_SNAPSHOTS_CHANGED:\n\t\t{\n\t\t\tif ((get_numeric_property(zhp, prop, src, &source,\n\t\t\t    &val) != 0) || val == 0) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\ttime_t time = (time_t)val;\n\t\t\tstruct tm t;\n\n\t\t\tif (literal ||\n\t\t\t    localtime_r(&time, &t) == NULL ||\n\t\t\t    strftime(propbuf, proplen, \"%a %b %e %k:%M:%S %Y\",\n\t\t\t    &t) == 0)\n\t\t\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t\t\t    (u_longlong_t)val);\n\t\t}\n\t\tzcp_check(zhp, prop, val, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tswitch (zfs_prop_get_type(prop)) {\n\t\tcase PROP_TYPE_NUMBER:\n\t\t\tif (get_numeric_property(zhp, prop, src,\n\t\t\t    &source, &val) != 0) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (literal) {\n\t\t\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t\t\t    (u_longlong_t)val);\n\t\t\t} else {\n\t\t\t\tzfs_nicenum(val, propbuf, proplen);\n\t\t\t}\n\t\t\tzcp_check(zhp, prop, val, NULL);\n\t\t\tbreak;\n\n\t\tcase PROP_TYPE_STRING:\n\t\t\tstr = getprop_string(zhp, prop, &source);\n\t\t\tif (str == NULL)\n\t\t\t\treturn (-1);\n\n\t\t\t(void) strlcpy(propbuf, str, proplen);\n\t\t\tzcp_check(zhp, prop, 0, str);\n\t\t\tbreak;\n\n\t\tcase PROP_TYPE_INDEX:\n\t\t\tif (get_numeric_property(zhp, prop, src,\n\t\t\t    &source, &val) != 0)\n\t\t\t\treturn (-1);\n\t\t\tif (zfs_prop_index_to_string(prop, val, &strval) != 0)\n\t\t\t\treturn (-1);\n\n\t\t\t(void) strlcpy(propbuf, strval, proplen);\n\t\t\tzcp_check(zhp, prop, 0, strval);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t}\n\n\tget_source(zhp, src, source, statbuf, statlen);\n\n\treturn (0);\n}\n\n \nuint64_t\nzfs_prop_get_int(zfs_handle_t *zhp, zfs_prop_t prop)\n{\n\tconst char *source;\n\tuint64_t val = 0;\n\n\t(void) get_numeric_property(zhp, prop, NULL, &source, &val);\n\n\treturn (val);\n}\n\nstatic int\nzfs_prop_set_int(zfs_handle_t *zhp, zfs_prop_t prop, uint64_t val)\n{\n\tchar buf[64];\n\n\t(void) snprintf(buf, sizeof (buf), \"%llu\", (longlong_t)val);\n\treturn (zfs_prop_set(zhp, zfs_prop_to_name(prop), buf));\n}\n\n \nint\nzfs_prop_get_numeric(zfs_handle_t *zhp, zfs_prop_t prop, uint64_t *value,\n    zprop_source_t *src, char *statbuf, size_t statlen)\n{\n\tconst char *source;\n\n\t \n\tif (!zfs_prop_valid_for_type(prop, zhp->zfs_type, B_FALSE)) {\n\t\treturn (zfs_error_fmt(zhp->zfs_hdl, EZFS_PROPTYPE,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot get property '%s'\"),\n\t\t    zfs_prop_to_name(prop)));\n\t}\n\n\tif (src)\n\t\t*src = ZPROP_SRC_NONE;\n\n\tif (get_numeric_property(zhp, prop, src, &source, value) != 0)\n\t\treturn (-1);\n\n\tget_source(zhp, src, source, statbuf, statlen);\n\n\treturn (0);\n}\n\n#ifdef HAVE_IDMAP\nstatic int\nidmap_id_to_numeric_domain_rid(uid_t id, boolean_t isuser,\n    char **domainp, idmap_rid_t *ridp)\n{\n\tidmap_get_handle_t *get_hdl = NULL;\n\tidmap_stat status;\n\tint err = EINVAL;\n\n\tif (idmap_get_create(&get_hdl) != IDMAP_SUCCESS)\n\t\tgoto out;\n\n\tif (isuser) {\n\t\terr = idmap_get_sidbyuid(get_hdl, id,\n\t\t    IDMAP_REQ_FLG_USE_CACHE, domainp, ridp, &status);\n\t} else {\n\t\terr = idmap_get_sidbygid(get_hdl, id,\n\t\t    IDMAP_REQ_FLG_USE_CACHE, domainp, ridp, &status);\n\t}\n\tif (err == IDMAP_SUCCESS &&\n\t    idmap_get_mappings(get_hdl) == IDMAP_SUCCESS &&\n\t    status == IDMAP_SUCCESS)\n\t\terr = 0;\n\telse\n\t\terr = EINVAL;\nout:\n\tif (get_hdl)\n\t\tidmap_get_destroy(get_hdl);\n\treturn (err);\n}\n#endif  \n\n \nstatic int\nuserquota_propname_decode(const char *propname, boolean_t zoned,\n    zfs_userquota_prop_t *typep, char *domain, int domainlen, uint64_t *ridp)\n{\n\tzfs_userquota_prop_t type;\n\tchar *cp;\n\tboolean_t isuser;\n\tboolean_t isgroup;\n\tboolean_t isproject;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\n\tdomain[0] = '\\0';\n\n\t \n\tfor (type = 0; type < ZFS_NUM_USERQUOTA_PROPS; type++) {\n\t\tif (strncmp(propname, zfs_userquota_prop_prefixes[type],\n\t\t    strlen(zfs_userquota_prop_prefixes[type])) == 0)\n\t\t\tbreak;\n\t}\n\tif (type == ZFS_NUM_USERQUOTA_PROPS)\n\t\treturn (EINVAL);\n\t*typep = type;\n\n\tisuser = (type == ZFS_PROP_USERQUOTA || type == ZFS_PROP_USERUSED ||\n\t    type == ZFS_PROP_USEROBJQUOTA ||\n\t    type == ZFS_PROP_USEROBJUSED);\n\tisgroup = (type == ZFS_PROP_GROUPQUOTA || type == ZFS_PROP_GROUPUSED ||\n\t    type == ZFS_PROP_GROUPOBJQUOTA ||\n\t    type == ZFS_PROP_GROUPOBJUSED);\n\tisproject = (type == ZFS_PROP_PROJECTQUOTA ||\n\t    type == ZFS_PROP_PROJECTUSED || type == ZFS_PROP_PROJECTOBJQUOTA ||\n\t    type == ZFS_PROP_PROJECTOBJUSED);\n\n\tcp = strchr(propname, '@') + 1;\n\n\tif (isuser && (pw = getpwnam(cp)) != NULL) {\n\t\tif (zoned && getzoneid() == GLOBAL_ZONEID)\n\t\t\treturn (ENOENT);\n\t\t*ridp = pw->pw_uid;\n\t} else if (isgroup && (gr = getgrnam(cp)) != NULL) {\n\t\tif (zoned && getzoneid() == GLOBAL_ZONEID)\n\t\t\treturn (ENOENT);\n\t\t*ridp = gr->gr_gid;\n\t} else if (!isproject && strchr(cp, '@')) {\n#ifdef HAVE_IDMAP\n\t\t \n\t\tdirectory_error_t e;\n\t\tchar *numericsid = NULL;\n\t\tchar *end;\n\n\t\tif (zoned && getzoneid() == GLOBAL_ZONEID)\n\t\t\treturn (ENOENT);\n\t\tif (isuser) {\n\t\t\te = directory_sid_from_user_name(NULL,\n\t\t\t    cp, &numericsid);\n\t\t} else {\n\t\t\te = directory_sid_from_group_name(NULL,\n\t\t\t    cp, &numericsid);\n\t\t}\n\t\tif (e != NULL) {\n\t\t\tdirectory_error_free(e);\n\t\t\treturn (ENOENT);\n\t\t}\n\t\tif (numericsid == NULL)\n\t\t\treturn (ENOENT);\n\t\tcp = numericsid;\n\t\t(void) strlcpy(domain, cp, domainlen);\n\t\tcp = strrchr(domain, '-');\n\t\t*cp = '\\0';\n\t\tcp++;\n\n\t\terrno = 0;\n\t\t*ridp = strtoull(cp, &end, 10);\n\t\tfree(numericsid);\n\n\t\tif (errno != 0 || *end != '\\0')\n\t\t\treturn (EINVAL);\n#else\n\t\t(void) domainlen;\n\t\treturn (ENOSYS);\n#endif  \n\t} else {\n\t\t \n\t\tuid_t id;\n\t\tchar *end;\n\t\tid = strtoul(cp, &end, 10);\n\t\tif (*end != '\\0')\n\t\t\treturn (EINVAL);\n\t\tif (id > MAXUID && !isproject) {\n#ifdef HAVE_IDMAP\n\t\t\t \n\t\t\tidmap_rid_t rid;\n\t\t\tchar *mapdomain;\n\n\t\t\tif (idmap_id_to_numeric_domain_rid(id, isuser,\n\t\t\t    &mapdomain, &rid) != 0)\n\t\t\t\treturn (ENOENT);\n\t\t\t(void) strlcpy(domain, mapdomain, domainlen);\n\t\t\t*ridp = rid;\n#else\n\t\t\treturn (ENOSYS);\n#endif  \n\t\t} else {\n\t\t\t*ridp = id;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzfs_prop_get_userquota_common(zfs_handle_t *zhp, const char *propname,\n    uint64_t *propvalue, zfs_userquota_prop_t *typep)\n{\n\tint err;\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\terr = userquota_propname_decode(propname,\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ZONED),\n\t    typep, zc.zc_value, sizeof (zc.zc_value), &zc.zc_guid);\n\tzc.zc_objset_type = *typep;\n\tif (err)\n\t\treturn (err);\n\n\terr = zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_USERSPACE_ONE, &zc);\n\tif (err)\n\t\treturn (err);\n\n\t*propvalue = zc.zc_cookie;\n\treturn (0);\n}\n\nint\nzfs_prop_get_userquota_int(zfs_handle_t *zhp, const char *propname,\n    uint64_t *propvalue)\n{\n\tzfs_userquota_prop_t type;\n\n\treturn (zfs_prop_get_userquota_common(zhp, propname, propvalue,\n\t    &type));\n}\n\nint\nzfs_prop_get_userquota(zfs_handle_t *zhp, const char *propname,\n    char *propbuf, int proplen, boolean_t literal)\n{\n\tint err;\n\tuint64_t propvalue;\n\tzfs_userquota_prop_t type;\n\n\terr = zfs_prop_get_userquota_common(zhp, propname, &propvalue,\n\t    &type);\n\n\tif (err)\n\t\treturn (err);\n\n\tif (literal) {\n\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t    (u_longlong_t)propvalue);\n\t} else if (propvalue == 0 &&\n\t    (type == ZFS_PROP_USERQUOTA || type == ZFS_PROP_GROUPQUOTA ||\n\t    type == ZFS_PROP_USEROBJQUOTA || type == ZFS_PROP_GROUPOBJQUOTA ||\n\t    type == ZFS_PROP_PROJECTQUOTA ||\n\t    type == ZFS_PROP_PROJECTOBJQUOTA)) {\n\t\t(void) strlcpy(propbuf, \"none\", proplen);\n\t} else if (type == ZFS_PROP_USERQUOTA || type == ZFS_PROP_GROUPQUOTA ||\n\t    type == ZFS_PROP_USERUSED || type == ZFS_PROP_GROUPUSED ||\n\t    type == ZFS_PROP_PROJECTUSED || type == ZFS_PROP_PROJECTQUOTA) {\n\t\tzfs_nicebytes(propvalue, propbuf, proplen);\n\t} else {\n\t\tzfs_nicenum(propvalue, propbuf, proplen);\n\t}\n\treturn (0);\n}\n\n \nint\nzfs_prop_get_written_int(zfs_handle_t *zhp, const char *propname,\n    uint64_t *propvalue)\n{\n\tint err;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tconst char *snapname;\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\tassert(zfs_prop_written(propname));\n\tsnapname = propname + strlen(\"written@\");\n\tif (strchr(snapname, '@') != NULL || strchr(snapname, '#') != NULL) {\n\t\t \n\t\t(void) strlcpy(zc.zc_value, snapname, sizeof (zc.zc_value));\n\t} else {\n\t\t \n\t\tchar *cp;\n\n\t\t(void) strlcpy(zc.zc_value, zhp->zfs_name,\n\t\t    sizeof (zc.zc_value));\n\t\tcp = strchr(zc.zc_value, '@');\n\t\tif (cp != NULL)\n\t\t\t*cp = '\\0';\n\t\t(void) strlcat(zc.zc_value, snapname - 1, sizeof (zc.zc_value));\n\t}\n\n\terr = zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_SPACE_WRITTEN, &zc);\n\tif (err)\n\t\treturn (err);\n\n\t*propvalue = zc.zc_cookie;\n\treturn (0);\n}\n\nint\nzfs_prop_get_written(zfs_handle_t *zhp, const char *propname,\n    char *propbuf, int proplen, boolean_t literal)\n{\n\tint err;\n\tuint64_t propvalue;\n\n\terr = zfs_prop_get_written_int(zhp, propname, &propvalue);\n\n\tif (err)\n\t\treturn (err);\n\n\tif (literal) {\n\t\t(void) snprintf(propbuf, proplen, \"%llu\",\n\t\t    (u_longlong_t)propvalue);\n\t} else {\n\t\tzfs_nicebytes(propvalue, propbuf, proplen);\n\t}\n\n\treturn (0);\n}\n\n \nconst char *\nzfs_get_name(const zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_name);\n}\n\n \nconst char *\nzfs_get_pool_name(const zfs_handle_t *zhp)\n{\n\treturn (zhp->zpool_hdl->zpool_name);\n}\n\n \nzfs_type_t\nzfs_get_type(const zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_type);\n}\n\n \nzfs_type_t\nzfs_get_underlying_type(const zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_head_type);\n}\n\n \nstatic boolean_t\nis_descendant(const char *ds1, const char *ds2)\n{\n\tsize_t d1len = strlen(ds1);\n\n\t \n\tif (strlen(ds2) < d1len)\n\t\treturn (B_FALSE);\n\n\t \n\treturn (ds2[d1len] == '/' && (strncmp(ds1, ds2, d1len) == 0));\n}\n\n \nstatic int\nparent_name(const char *path, char *buf, size_t buflen)\n{\n\tchar *slashp;\n\n\t(void) strlcpy(buf, path, buflen);\n\n\tif ((slashp = strrchr(buf, '/')) == NULL)\n\t\treturn (-1);\n\t*slashp = '\\0';\n\n\treturn (0);\n}\n\nint\nzfs_parent_name(zfs_handle_t *zhp, char *buf, size_t buflen)\n{\n\treturn (parent_name(zfs_get_name(zhp), buf, buflen));\n}\n\n \nstatic int\ncheck_parents(libzfs_handle_t *hdl, const char *path, uint64_t *zoned,\n    boolean_t accept_ancestor, int *prefixlen)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar parent[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *slash;\n\tzfs_handle_t *zhp;\n\tchar errbuf[ERRBUFLEN];\n\tuint64_t is_zoned;\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot create '%s'\"), path);\n\n\t \n\tif (parent_name(path, parent, sizeof (parent)) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"missing dataset name\"));\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t}\n\n\t \n\tif ((slash = strchr(parent, '/')) == NULL)\n\t\tslash = parent + strlen(parent);\n\t(void) strlcpy(zc.zc_name, parent,\n\t    MIN(sizeof (zc.zc_name), slash - parent + 1));\n\tif (zfs_ioctl(hdl, ZFS_IOC_OBJSET_STATS, &zc) != 0 &&\n\t    errno == ENOENT) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"no such pool '%s'\"), zc.zc_name);\n\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\t}\n\n\t \n\twhile ((zhp = make_dataset_handle(hdl, parent)) == NULL) {\n\t\tif (errno == ENOENT && accept_ancestor) {\n\t\t\t \n\t\t\tif (parent_name(parent, parent, sizeof (parent)) != 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"no such pool '%s'\"), zc.zc_name);\n\t\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\t\t\t}\n\t\t} else if (errno == ENOENT) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"parent does not exist\"));\n\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\t\t} else\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t}\n\n\tis_zoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\tif (zoned != NULL)\n\t\t*zoned = is_zoned;\n\n\t \n\tif (getzoneid() != GLOBAL_ZONEID && !is_zoned) {\n\t\t(void) zfs_standard_error(hdl, EPERM, errbuf);\n\t\tzfs_close(zhp);\n\t\treturn (-1);\n\t}\n\n\t \n\tif (zfs_get_type(zhp) != ZFS_TYPE_FILESYSTEM) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"parent is not a filesystem\"));\n\t\t(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\tzfs_close(zhp);\n\t\treturn (-1);\n\t}\n\n\tzfs_close(zhp);\n\tif (prefixlen != NULL)\n\t\t*prefixlen = strlen(parent);\n\treturn (0);\n}\n\n \nboolean_t\nzfs_dataset_exists(libzfs_handle_t *hdl, const char *path, zfs_type_t types)\n{\n\tzfs_handle_t *zhp;\n\n\tif (!zfs_validate_name(hdl, path, types, B_FALSE))\n\t\treturn (B_FALSE);\n\n\t \n\tif ((zhp = make_dataset_handle(hdl, path)) != NULL) {\n\t\tint ds_type = zhp->zfs_type;\n\n\t\tzfs_close(zhp);\n\t\tif (types & ds_type)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nint\ncreate_parents(libzfs_handle_t *hdl, char *target, int prefixlen)\n{\n\tzfs_handle_t *h;\n\tchar *cp;\n\tconst char *opname;\n\n\t \n\tcp = target + prefixlen;\n\tif (*cp != '/') {\n\t\tassert(strchr(cp, '/') == NULL);\n\t\th = zfs_open(hdl, target, ZFS_TYPE_FILESYSTEM);\n\t} else {\n\t\t*cp = '\\0';\n\t\th = zfs_open(hdl, target, ZFS_TYPE_FILESYSTEM);\n\t\t*cp = '/';\n\t}\n\tif (h == NULL)\n\t\treturn (-1);\n\tzfs_close(h);\n\n\t \n\tfor (cp = target + prefixlen + 1;\n\t    (cp = strchr(cp, '/')) != NULL; *cp = '/', cp++) {\n\n\t\t*cp = '\\0';\n\n\t\th = make_dataset_handle(hdl, target);\n\t\tif (h) {\n\t\t\t \n\t\t\tzfs_close(h);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (zfs_create(hdl, target, ZFS_TYPE_FILESYSTEM,\n\t\t    NULL) != 0) {\n\t\t\topname = dgettext(TEXT_DOMAIN, \"create\");\n\t\t\tgoto ancestorerr;\n\t\t}\n\n\t\th = zfs_open(hdl, target, ZFS_TYPE_FILESYSTEM);\n\t\tif (h == NULL) {\n\t\t\topname = dgettext(TEXT_DOMAIN, \"open\");\n\t\t\tgoto ancestorerr;\n\t\t}\n\n\t\tif (zfs_mount(h, NULL, 0) != 0) {\n\t\t\topname = dgettext(TEXT_DOMAIN, \"mount\");\n\t\t\tgoto ancestorerr;\n\t\t}\n\n\t\tif (zfs_share(h, NULL) != 0) {\n\t\t\topname = dgettext(TEXT_DOMAIN, \"share\");\n\t\t\tgoto ancestorerr;\n\t\t}\n\n\t\tzfs_close(h);\n\t}\n\tzfs_commit_shares(NULL);\n\n\treturn (0);\n\nancestorerr:\n\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t    \"failed to %s ancestor '%s'\"), opname, target);\n\treturn (-1);\n}\n\n \nint\nzfs_create_ancestors(libzfs_handle_t *hdl, const char *path)\n{\n\tint prefix;\n\tchar *path_copy;\n\tchar errbuf[ERRBUFLEN];\n\tint rc = 0;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot create '%s'\"), path);\n\n\t \n\tif (dataset_nestcheck(path) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"maximum name nesting depth exceeded\"));\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t}\n\n\tif (check_parents(hdl, path, NULL, B_TRUE, &prefix) != 0)\n\t\treturn (-1);\n\n\tif ((path_copy = strdup(path)) != NULL) {\n\t\trc = create_parents(hdl, path_copy, prefix);\n\t\tfree(path_copy);\n\t}\n\tif (path_copy == NULL || rc != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n \nint\nzfs_create(libzfs_handle_t *hdl, const char *path, zfs_type_t type,\n    nvlist_t *props)\n{\n\tint ret;\n\tuint64_t size = 0;\n\tuint64_t blocksize = zfs_prop_default_numeric(ZFS_PROP_VOLBLOCKSIZE);\n\tuint64_t zoned;\n\tenum lzc_dataset_type ost;\n\tzpool_handle_t *zpool_handle;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeylen = 0;\n\tchar errbuf[ERRBUFLEN];\n\tchar parent[ZFS_MAX_DATASET_NAME_LEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot create '%s'\"), path);\n\n\t \n\tif (!zfs_validate_name(hdl, path, type, B_TRUE))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\tif (dataset_nestcheck(path) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"maximum name nesting depth exceeded\"));\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t}\n\n\t \n\tif (check_parents(hdl, path, &zoned, B_FALSE, NULL) != 0)\n\t\treturn (-1);\n\n\t \n\tif (zfs_dataset_exists(hdl, path, ZFS_TYPE_DATASET)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dataset already exists\"));\n\t\treturn (zfs_error(hdl, EZFS_EXISTS, errbuf));\n\t}\n\n\tif (type == ZFS_TYPE_VOLUME)\n\t\tost = LZC_DATSET_TYPE_ZVOL;\n\telse\n\t\tost = LZC_DATSET_TYPE_ZFS;\n\n\t \n\tchar pool_path[ZFS_MAX_DATASET_NAME_LEN];\n\t(void) strlcpy(pool_path, path, sizeof (pool_path));\n\n\t \n\tchar *p = strchr(pool_path, '/');\n\tif (p != NULL)\n\t\t*p = '\\0';\n\n\tif ((zpool_handle = zpool_open(hdl, pool_path)) == NULL)\n\t\treturn (-1);\n\n\tif (props && (props = zfs_valid_proplist(hdl, type, props,\n\t    zoned, NULL, zpool_handle, B_TRUE, errbuf)) == 0) {\n\t\tzpool_close(zpool_handle);\n\t\treturn (-1);\n\t}\n\tzpool_close(zpool_handle);\n\n\tif (type == ZFS_TYPE_VOLUME) {\n\t\t \n\t\tif (props == NULL || nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE), &size) != 0) {\n\t\t\tnvlist_free(props);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"missing volume size\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t\t}\n\n\t\tif ((ret = nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),\n\t\t    &blocksize)) != 0) {\n\t\t\tif (ret == ENOENT) {\n\t\t\t\tblocksize = zfs_prop_default_numeric(\n\t\t\t\t    ZFS_PROP_VOLBLOCKSIZE);\n\t\t\t} else {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"missing volume block size\"));\n\t\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t\t\t}\n\t\t}\n\n\t\tif (size == 0) {\n\t\t\tnvlist_free(props);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"volume size cannot be zero\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t\t}\n\n\t\tif (size % blocksize != 0) {\n\t\t\tnvlist_free(props);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"volume size must be a multiple of volume block \"\n\t\t\t    \"size\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t\t}\n\t}\n\n\t(void) parent_name(path, parent, sizeof (parent));\n\tif (zfs_crypto_create(hdl, parent, props, NULL, B_TRUE,\n\t    &wkeydata, &wkeylen) != 0) {\n\t\tnvlist_free(props);\n\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\t}\n\n\t \n\tret = lzc_create(path, ost, props, wkeydata, wkeylen);\n\tnvlist_free(props);\n\tif (wkeydata != NULL)\n\t\tfree(wkeydata);\n\n\t \n\tif (ret != 0) {\n\t\tswitch (errno) {\n\t\tcase ENOENT:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"no such parent '%s'\"), parent);\n\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded to set this \"\n\t\t\t    \"property or value\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADVERSION, errbuf));\n\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"encryption root's key is not loaded \"\n\t\t\t    \"or provided\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\n\t\tcase ERANGE:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid property value(s) specified\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n#ifdef _ILP32\n\t\tcase EOVERFLOW:\n\t\t\t \n\t\t\tif (type == ZFS_TYPE_VOLUME)\n\t\t\t\treturn (zfs_error(hdl, EZFS_VOLTOOBIG,\n\t\t\t\t    errbuf));\n\t\t\tzfs_fallthrough;\n#endif\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_destroy(zfs_handle_t *zhp, boolean_t defer)\n{\n\tint error;\n\n\tif (zhp->zfs_type != ZFS_TYPE_SNAPSHOT && defer)\n\t\treturn (EINVAL);\n\n\tif (zhp->zfs_type == ZFS_TYPE_BOOKMARK) {\n\t\tnvlist_t *nv = fnvlist_alloc();\n\t\tfnvlist_add_boolean(nv, zhp->zfs_name);\n\t\terror = lzc_destroy_bookmarks(nv, NULL);\n\t\tfnvlist_free(nv);\n\t\tif (error != 0) {\n\t\t\treturn (zfs_standard_error_fmt(zhp->zfs_hdl, error,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot destroy '%s'\"),\n\t\t\t    zhp->zfs_name));\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (zhp->zfs_type == ZFS_TYPE_SNAPSHOT) {\n\t\tnvlist_t *nv = fnvlist_alloc();\n\t\tfnvlist_add_boolean(nv, zhp->zfs_name);\n\t\terror = lzc_destroy_snaps(nv, defer, NULL);\n\t\tfnvlist_free(nv);\n\t} else {\n\t\terror = lzc_destroy(zhp->zfs_name);\n\t}\n\n\tif (error != 0 && error != ENOENT) {\n\t\treturn (zfs_standard_error_fmt(zhp->zfs_hdl, errno,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot destroy '%s'\"),\n\t\t    zhp->zfs_name));\n\t}\n\n\tremove_mountpoint(zhp);\n\n\treturn (0);\n}\n\nstruct destroydata {\n\tnvlist_t *nvl;\n\tconst char *snapname;\n};\n\nstatic int\nzfs_check_snap_cb(zfs_handle_t *zhp, void *arg)\n{\n\tstruct destroydata *dd = arg;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tint rv = 0;\n\n\tif (snprintf(name, sizeof (name), \"%s@%s\", zhp->zfs_name,\n\t    dd->snapname) >= sizeof (name))\n\t\treturn (EINVAL);\n\n\tif (lzc_exists(name))\n\t\tfnvlist_add_boolean(dd->nvl, name);\n\n\trv = zfs_iter_filesystems_v2(zhp, 0, zfs_check_snap_cb, dd);\n\tzfs_close(zhp);\n\treturn (rv);\n}\n\n \nint\nzfs_destroy_snaps(zfs_handle_t *zhp, char *snapname, boolean_t defer)\n{\n\tint ret;\n\tstruct destroydata dd = { 0 };\n\n\tdd.snapname = snapname;\n\tdd.nvl = fnvlist_alloc();\n\t(void) zfs_check_snap_cb(zfs_handle_dup(zhp), &dd);\n\n\tif (nvlist_empty(dd.nvl)) {\n\t\tret = zfs_standard_error_fmt(zhp->zfs_hdl, ENOENT,\n\t\t    dgettext(TEXT_DOMAIN, \"cannot destroy '%s@%s'\"),\n\t\t    zhp->zfs_name, snapname);\n\t} else {\n\t\tret = zfs_destroy_snaps_nvl(zhp->zfs_hdl, dd.nvl, defer);\n\t}\n\tfnvlist_free(dd.nvl);\n\treturn (ret);\n}\n\n \nint\nzfs_destroy_snaps_nvl(libzfs_handle_t *hdl, nvlist_t *snaps, boolean_t defer)\n{\n\tnvlist_t *errlist = NULL;\n\tnvpair_t *pair;\n\n\tint ret = zfs_destroy_snaps_nvl_os(hdl, snaps);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tret = lzc_destroy_snaps(snaps, defer, &errlist);\n\n\tif (ret == 0) {\n\t\tnvlist_free(errlist);\n\t\treturn (0);\n\t}\n\n\tif (nvlist_empty(errlist)) {\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot destroy snapshots\"));\n\n\t\tret = zfs_standard_error(hdl, ret, errbuf);\n\t}\n\tfor (pair = nvlist_next_nvpair(errlist, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(errlist, pair)) {\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot destroy snapshot %s\"),\n\t\t    nvpair_name(pair));\n\n\t\tswitch (fnvpair_value_int32(pair)) {\n\t\tcase EEXIST:\n\t\t\tzfs_error_aux(hdl,\n\t\t\t    dgettext(TEXT_DOMAIN, \"snapshot is cloned\"));\n\t\t\tret = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = zfs_standard_error(hdl, errno, errbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvlist_free(errlist);\n\treturn (ret);\n}\n\n \nint\nzfs_clone(zfs_handle_t *zhp, const char *target, nvlist_t *props)\n{\n\tchar parent[ZFS_MAX_DATASET_NAME_LEN];\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tuint64_t zoned;\n\n\tassert(zhp->zfs_type == ZFS_TYPE_SNAPSHOT);\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot create '%s'\"), target);\n\n\t \n\tif (!zfs_validate_name(hdl, target, ZFS_TYPE_FILESYSTEM, B_TRUE))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\t \n\tif (check_parents(hdl, target, &zoned, B_FALSE, NULL) != 0)\n\t\treturn (-1);\n\n\t(void) parent_name(target, parent, sizeof (parent));\n\n\t \n\n\tif (props) {\n\t\tzfs_type_t type = ZFS_TYPE_FILESYSTEM;\n\n\t\tif (ZFS_IS_VOLUME(zhp))\n\t\t\ttype = ZFS_TYPE_VOLUME;\n\t\tif ((props = zfs_valid_proplist(hdl, type, props, zoned,\n\t\t    zhp, zhp->zpool_hdl, B_TRUE, errbuf)) == NULL)\n\t\t\treturn (-1);\n\t\tif (zfs_fix_auto_resv(zhp, props) == -1) {\n\t\t\tnvlist_free(props);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (zfs_crypto_clone_check(hdl, zhp, parent, props) != 0) {\n\t\tnvlist_free(props);\n\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\t}\n\n\tret = lzc_clone(target, zhp->zfs_name, props);\n\tnvlist_free(props);\n\n\tif (ret != 0) {\n\t\tswitch (errno) {\n\n\t\tcase ENOENT:\n\t\t\t \n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"no such parent '%s'\"), parent);\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_NOENT, errbuf));\n\n\t\tcase EXDEV:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"source and target pools differ\"));\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_CROSSTARGET,\n\t\t\t    errbuf));\n\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(zhp->zfs_hdl, errno,\n\t\t\t    errbuf));\n\t\t}\n\t}\n\n\treturn (ret);\n}\n\n \nint\nzfs_promote(zfs_handle_t *zhp)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot promote '%s'\"), zhp->zfs_name);\n\n\tif (zhp->zfs_type == ZFS_TYPE_SNAPSHOT) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"snapshots can not be promoted\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\t}\n\n\tif (zhp->zfs_dmustats.dds_origin[0] == '\\0') {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"not a cloned filesystem\"));\n\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\t}\n\n\tif (!zfs_validate_name(hdl, zhp->zfs_name, zhp->zfs_type, B_TRUE))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\tret = lzc_promote(zhp->zfs_name, snapname, sizeof (snapname));\n\n\tif (ret != 0) {\n\t\tswitch (ret) {\n\t\tcase EACCES:\n\t\t\t \n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot promote dataset outside its \"\n\t\t\t    \"encryption root\"));\n\t\t\treturn (zfs_error(hdl, EZFS_EXISTS, errbuf));\n\n\t\tcase EEXIST:\n\t\t\t \n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"conflicting snapshot '%s' from parent '%s'\"),\n\t\t\t    snapname, zhp->zfs_dmustats.dds_origin);\n\t\t\treturn (zfs_error(hdl, EZFS_EXISTS, errbuf));\n\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(hdl, ret, errbuf));\n\t\t}\n\t}\n\treturn (ret);\n}\n\ntypedef struct snapdata {\n\tnvlist_t *sd_nvl;\n\tconst char *sd_snapname;\n} snapdata_t;\n\nstatic int\nzfs_snapshot_cb(zfs_handle_t *zhp, void *arg)\n{\n\tsnapdata_t *sd = arg;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tint rv = 0;\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) == 0) {\n\t\tif (snprintf(name, sizeof (name), \"%s@%s\", zfs_get_name(zhp),\n\t\t    sd->sd_snapname) >= sizeof (name))\n\t\t\treturn (EINVAL);\n\n\t\tfnvlist_add_boolean(sd->sd_nvl, name);\n\n\t\trv = zfs_iter_filesystems_v2(zhp, 0, zfs_snapshot_cb, sd);\n\t}\n\tzfs_close(zhp);\n\n\treturn (rv);\n}\n\n \nint\nzfs_snapshot_nvl(libzfs_handle_t *hdl, nvlist_t *snaps, nvlist_t *props)\n{\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\tnvpair_t *elem;\n\tnvlist_t *errors;\n\tzpool_handle_t *zpool_hdl;\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot create snapshots \"));\n\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(snaps, elem)) != NULL) {\n\t\tconst char *snapname = nvpair_name(elem);\n\n\t\t \n\t\tif (!zfs_validate_name(hdl, snapname, ZFS_TYPE_SNAPSHOT,\n\t\t    B_TRUE)) {\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot create snapshot '%s'\"), snapname);\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t\t}\n\t}\n\n\t \n\telem = nvlist_next_nvpair(snaps, NULL);\n\tif (elem == NULL)\n\t\treturn (-1);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/@\")] = '\\0';\n\tzpool_hdl = zpool_open(hdl, pool);\n\tif (zpool_hdl == NULL)\n\t\treturn (-1);\n\n\tif (props != NULL &&\n\t    (props = zfs_valid_proplist(hdl, ZFS_TYPE_SNAPSHOT,\n\t    props, B_FALSE, NULL, zpool_hdl, B_FALSE, errbuf)) == NULL) {\n\t\tzpool_close(zpool_hdl);\n\t\treturn (-1);\n\t}\n\tzpool_close(zpool_hdl);\n\n\tret = lzc_snapshot(snaps, props, &errors);\n\n\tif (ret != 0) {\n\t\tboolean_t printed = B_FALSE;\n\t\tfor (elem = nvlist_next_nvpair(errors, NULL);\n\t\t    elem != NULL;\n\t\t    elem = nvlist_next_nvpair(errors, elem)) {\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot create snapshot '%s'\"), nvpair_name(elem));\n\t\t\t(void) zfs_standard_error(hdl,\n\t\t\t    fnvpair_value_int32(elem), errbuf);\n\t\t\tprinted = B_TRUE;\n\t\t}\n\t\tif (!printed) {\n\t\t\tswitch (ret) {\n\t\t\tcase EXDEV:\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"multiple snapshots of same \"\n\t\t\t\t    \"fs not allowed\"));\n\t\t\t\t(void) zfs_error(hdl, EZFS_EXISTS, errbuf);\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(void) zfs_standard_error(hdl, ret, errbuf);\n\t\t\t}\n\t\t}\n\t}\n\n\tnvlist_free(props);\n\tnvlist_free(errors);\n\treturn (ret);\n}\n\nint\nzfs_snapshot(libzfs_handle_t *hdl, const char *path, boolean_t recursive,\n    nvlist_t *props)\n{\n\tint ret;\n\tsnapdata_t sd = { 0 };\n\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *cp;\n\tzfs_handle_t *zhp;\n\tchar errbuf[ERRBUFLEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot snapshot %s\"), path);\n\n\tif (!zfs_validate_name(hdl, path, ZFS_TYPE_SNAPSHOT, B_TRUE))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\t(void) strlcpy(fsname, path, sizeof (fsname));\n\tcp = strchr(fsname, '@');\n\t*cp = '\\0';\n\tsd.sd_snapname = cp + 1;\n\n\tif ((zhp = zfs_open(hdl, fsname, ZFS_TYPE_FILESYSTEM |\n\t    ZFS_TYPE_VOLUME)) == NULL) {\n\t\treturn (-1);\n\t}\n\n\tsd.sd_nvl = fnvlist_alloc();\n\tif (recursive) {\n\t\t(void) zfs_snapshot_cb(zfs_handle_dup(zhp), &sd);\n\t} else {\n\t\tfnvlist_add_boolean(sd.sd_nvl, path);\n\t}\n\n\tret = zfs_snapshot_nvl(hdl, sd.sd_nvl, props);\n\tfnvlist_free(sd.sd_nvl);\n\tzfs_close(zhp);\n\treturn (ret);\n}\n\n \ntypedef struct rollback_data {\n\tconst char\t*cb_target;\t\t \n\tuint64_t\tcb_create;\t\t \n\tboolean_t\tcb_error;\n\tboolean_t\tcb_force;\n} rollback_data_t;\n\nstatic int\nrollback_destroy_dependent(zfs_handle_t *zhp, void *data)\n{\n\trollback_data_t *cbp = data;\n\tprop_changelist_t *clp;\n\n\t \n\tclp = changelist_gather(zhp, ZFS_PROP_NAME, 0,\n\t    cbp->cb_force ? MS_FORCE: 0);\n\tif (clp == NULL || changelist_prefix(clp) != 0) {\n\t\tcbp->cb_error = B_TRUE;\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\tif (zfs_destroy(zhp, B_FALSE) != 0)\n\t\tcbp->cb_error = B_TRUE;\n\telse\n\t\tchangelist_remove(clp, zhp->zfs_name);\n\t(void) changelist_postfix(clp);\n\tchangelist_free(clp);\n\n\tzfs_close(zhp);\n\treturn (0);\n}\n\nstatic int\nrollback_destroy(zfs_handle_t *zhp, void *data)\n{\n\trollback_data_t *cbp = data;\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_CREATETXG) > cbp->cb_create) {\n\t\tcbp->cb_error |= zfs_iter_dependents_v2(zhp, 0, B_FALSE,\n\t\t    rollback_destroy_dependent, cbp);\n\n\t\tcbp->cb_error |= zfs_destroy(zhp, B_FALSE);\n\t}\n\n\tzfs_close(zhp);\n\treturn (0);\n}\n\n \nint\nzfs_rollback(zfs_handle_t *zhp, zfs_handle_t *snap, boolean_t force)\n{\n\trollback_data_t cb = { 0 };\n\tint err;\n\tboolean_t restore_resv = 0;\n\tuint64_t old_volsize = 0, new_volsize;\n\tzfs_prop_t resv_prop = { 0 };\n\tuint64_t min_txg = 0;\n\n\tassert(zhp->zfs_type == ZFS_TYPE_FILESYSTEM ||\n\t    zhp->zfs_type == ZFS_TYPE_VOLUME);\n\n\t \n\tcb.cb_force = force;\n\tcb.cb_target = snap->zfs_name;\n\tcb.cb_create = zfs_prop_get_int(snap, ZFS_PROP_CREATETXG);\n\n\tif (cb.cb_create > 0)\n\t\tmin_txg = cb.cb_create;\n\n\t(void) zfs_iter_snapshots_v2(zhp, 0, rollback_destroy, &cb,\n\t    min_txg, 0);\n\n\t(void) zfs_iter_bookmarks_v2(zhp, 0, rollback_destroy, &cb);\n\n\tif (cb.cb_error)\n\t\treturn (-1);\n\n\t \n\n\tif (zhp->zfs_type == ZFS_TYPE_VOLUME) {\n\t\tif (zfs_which_resv_prop(zhp, &resv_prop) < 0)\n\t\t\treturn (-1);\n\t\told_volsize = zfs_prop_get_int(zhp, ZFS_PROP_VOLSIZE);\n\t\trestore_resv =\n\t\t    (old_volsize == zfs_prop_get_int(zhp, resv_prop));\n\t}\n\n\t \n\terr = lzc_rollback_to(zhp->zfs_name, snap->zfs_name);\n\tif (err != 0) {\n\t\tchar errbuf[ERRBUFLEN];\n\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot rollback '%s'\"),\n\t\t    zhp->zfs_name);\n\t\tswitch (err) {\n\t\tcase EEXIST:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"there is a snapshot or bookmark more recent \"\n\t\t\t    \"than '%s'\"), snap->zfs_name);\n\t\t\t(void) zfs_error(zhp->zfs_hdl, EZFS_EXISTS, errbuf);\n\t\t\tbreak;\n\t\tcase ESRCH:\n\t\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"'%s' is not found among snapshots of '%s'\"),\n\t\t\t    snap->zfs_name, zhp->zfs_name);\n\t\t\t(void) zfs_error(zhp->zfs_hdl, EZFS_NOENT, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\t(void) zfs_error(zhp->zfs_hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(zhp->zfs_hdl, err, errbuf);\n\t\t}\n\t\treturn (err);\n\t}\n\n\t \n\tif ((zhp->zfs_type == ZFS_TYPE_VOLUME) &&\n\t    (zhp = make_dataset_handle(zhp->zfs_hdl, zhp->zfs_name))) {\n\t\tif (restore_resv) {\n\t\t\tnew_volsize = zfs_prop_get_int(zhp, ZFS_PROP_VOLSIZE);\n\t\t\tif (old_volsize != new_volsize)\n\t\t\t\terr = zfs_prop_set_int(zhp, resv_prop,\n\t\t\t\t    new_volsize);\n\t\t}\n\t\tzfs_close(zhp);\n\t}\n\treturn (err);\n}\n\n \nint\nzfs_rename(zfs_handle_t *zhp, const char *target, renameflags_t flags)\n{\n\tint ret = 0;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tchar *delim;\n\tprop_changelist_t *cl = NULL;\n\tchar parent[ZFS_MAX_DATASET_NAME_LEN];\n\tchar property[ZFS_MAXPROPLEN];\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar errbuf[ERRBUFLEN];\n\n\t \n\tif (strcmp(zhp->zfs_name, target) == 0)\n\t\treturn (0);\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot rename to '%s'\"), target);\n\n\t \n\tif (!zfs_validate_name(hdl, zhp->zfs_name, zhp->zfs_type, B_TRUE))\n\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\t \n\tif (zhp->zfs_type == ZFS_TYPE_SNAPSHOT) {\n\t\tif ((strchr(target, '@') == NULL) ||\n\t\t    *target == '@') {\n\t\t\t \n\t\t\t(void) strlcpy(parent, zhp->zfs_name,\n\t\t\t    sizeof (parent));\n\t\t\tdelim = strchr(parent, '@');\n\t\t\tif (strchr(target, '@') == NULL)\n\t\t\t\t*(++delim) = '\\0';\n\t\t\telse\n\t\t\t\t*delim = '\\0';\n\t\t\t(void) strlcat(parent, target, sizeof (parent));\n\t\t\ttarget = parent;\n\t\t} else {\n\t\t\t \n\t\t\tdelim = strchr(target, '@');\n\t\t\tif (strncmp(zhp->zfs_name, target, delim - target)\n\t\t\t    != 0 || zhp->zfs_name[delim - target] != '@') {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"snapshots must be part of same \"\n\t\t\t\t    \"dataset\"));\n\t\t\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET,\n\t\t\t\t    errbuf));\n\t\t\t}\n\t\t}\n\n\t\tif (!zfs_validate_name(hdl, target, zhp->zfs_type, B_TRUE))\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t} else {\n\t\tif (flags.recursive) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"recursive rename must be a snapshot\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\t\t}\n\n\t\tif (!zfs_validate_name(hdl, target, zhp->zfs_type, B_TRUE))\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\n\t\t \n\t\tif (check_parents(hdl, target, NULL, B_FALSE, NULL) != 0)\n\t\t\treturn (-1);\n\n\t\t \n\t\tverify((delim = strchr(target, '/')) != NULL);\n\t\tif (strncmp(zhp->zfs_name, target, delim - target) != 0 ||\n\t\t    zhp->zfs_name[delim - target] != '/') {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"datasets must be within same pool\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));\n\t\t}\n\n\t\t \n\t\tif (is_descendant(zhp->zfs_name, target)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"New dataset name cannot be a descendant of \"\n\t\t\t    \"current dataset name\"));\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t\t}\n\t}\n\n\t(void) snprintf(errbuf, sizeof (errbuf),\n\t    dgettext(TEXT_DOMAIN, \"cannot rename '%s'\"), zhp->zfs_name);\n\n\tif (getzoneid() == GLOBAL_ZONEID &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ZONED)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"dataset is used in a non-global zone\"));\n\t\treturn (zfs_error(hdl, EZFS_ZONED, errbuf));\n\t}\n\n\t \n\tif (zhp->zfs_type == ZFS_TYPE_FILESYSTEM &&\n\t    !flags.recursive && !flags.nounmount &&\n\t    zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, property,\n\t    sizeof (property), NULL, NULL, 0, B_FALSE) == 0 &&\n\t    (strcmp(property, \"legacy\") == 0 ||\n\t    strcmp(property, \"none\") == 0)) {\n\t\tflags.nounmount = B_TRUE;\n\t}\n\tif (flags.recursive) {\n\t\tchar *parentname = zfs_strdup(zhp->zfs_hdl, zhp->zfs_name);\n\t\tdelim = strchr(parentname, '@');\n\t\t*delim = '\\0';\n\t\tzfs_handle_t *zhrp = zfs_open(zhp->zfs_hdl, parentname,\n\t\t    ZFS_TYPE_DATASET);\n\t\tfree(parentname);\n\t\tif (zhrp == NULL) {\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\t\tzfs_close(zhrp);\n\t} else if (zhp->zfs_type != ZFS_TYPE_SNAPSHOT) {\n\t\tif ((cl = changelist_gather(zhp, ZFS_PROP_NAME,\n\t\t    flags.nounmount ? CL_GATHER_DONT_UNMOUNT :\n\t\t    CL_GATHER_ITER_MOUNTED,\n\t\t    flags.forceunmount ? MS_FORCE : 0)) == NULL)\n\t\t\treturn (-1);\n\n\t\tif (changelist_haszonedchild(cl)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"child dataset with inherited mountpoint is used \"\n\t\t\t    \"in a non-global zone\"));\n\t\t\t(void) zfs_error(hdl, EZFS_ZONED, errbuf);\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif ((ret = changelist_prefix(cl)) != 0)\n\t\t\tgoto error;\n\t}\n\n\tif (ZFS_IS_VOLUME(zhp))\n\t\tzc.zc_objset_type = DMU_OST_ZVOL;\n\telse\n\t\tzc.zc_objset_type = DMU_OST_ZFS;\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\t(void) strlcpy(zc.zc_value, target, sizeof (zc.zc_value));\n\n\tzc.zc_cookie = !!flags.recursive;\n\tzc.zc_cookie |= (!!flags.nounmount) << 1;\n\n\tif ((ret = zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_RENAME, &zc)) != 0) {\n\t\t \n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot rename '%s'\"), zc.zc_name);\n\n\t\tif (flags.recursive && errno == EEXIST) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"a child dataset already has a snapshot \"\n\t\t\t    \"with the new name\"));\n\t\t\t(void) zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t} else if (errno == EACCES) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot move encrypted child outside of \"\n\t\t\t    \"its encryption root\"));\n\t\t\t(void) zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf);\n\t\t} else {\n\t\t\t(void) zfs_standard_error(zhp->zfs_hdl, errno, errbuf);\n\t\t}\n\n\t\t \n\t\tif (cl != NULL)\n\t\t\t(void) changelist_postfix(cl);\n\t} else {\n\t\tif (cl != NULL) {\n\t\t\tchangelist_rename(cl, zfs_get_name(zhp), target);\n\t\t\tret = changelist_postfix(cl);\n\t\t}\n\t}\n\nerror:\n\tif (cl != NULL) {\n\t\tchangelist_free(cl);\n\t}\n\treturn (ret);\n}\n\nnvlist_t *\nzfs_get_all_props(zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_props);\n}\n\nnvlist_t *\nzfs_get_recvd_props(zfs_handle_t *zhp)\n{\n\tif (zhp->zfs_recvd_props == NULL)\n\t\tif (get_recvd_props_ioctl(zhp) != 0)\n\t\t\treturn (NULL);\n\treturn (zhp->zfs_recvd_props);\n}\n\nnvlist_t *\nzfs_get_user_props(zfs_handle_t *zhp)\n{\n\treturn (zhp->zfs_user_props);\n}\n\n \nint\nzfs_expand_proplist(zfs_handle_t *zhp, zprop_list_t **plp, boolean_t received,\n    boolean_t literal)\n{\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tzprop_list_t *entry;\n\tzprop_list_t **last, **start;\n\tnvlist_t *userprops, *propval;\n\tnvpair_t *elem;\n\tconst char *strval;\n\tchar buf[ZFS_MAXPROPLEN];\n\n\tif (zprop_expand_list(hdl, plp, ZFS_TYPE_DATASET) != 0)\n\t\treturn (-1);\n\n\tuserprops = zfs_get_user_props(zhp);\n\n\tentry = *plp;\n\tif (entry->pl_all && nvlist_next_nvpair(userprops, NULL) != NULL) {\n\t\t \n\t\tstart = plp;\n\t\twhile (*start != NULL) {\n\t\t\tif ((*start)->pl_prop == ZPROP_USERPROP)\n\t\t\t\tbreak;\n\t\t\tstart = &(*start)->pl_next;\n\t\t}\n\n\t\telem = NULL;\n\t\twhile ((elem = nvlist_next_nvpair(userprops, elem)) != NULL) {\n\t\t\t \n\t\t\tfor (last = start; *last != NULL;\n\t\t\t    last = &(*last)->pl_next) {\n\t\t\t\tif (strcmp((*last)->pl_user_prop,\n\t\t\t\t    nvpair_name(elem)) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*last == NULL) {\n\t\t\t\tentry = zfs_alloc(hdl, sizeof (zprop_list_t));\n\t\t\t\tentry->pl_user_prop =\n\t\t\t\t    zfs_strdup(hdl, nvpair_name(elem));\n\t\t\t\tentry->pl_prop = ZPROP_USERPROP;\n\t\t\t\tentry->pl_width = strlen(nvpair_name(elem));\n\t\t\t\tentry->pl_all = B_TRUE;\n\t\t\t\t*last = entry;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (entry = *plp; entry != NULL; entry = entry->pl_next) {\n\t\tif (entry->pl_fixed && !literal)\n\t\t\tcontinue;\n\n\t\tif (entry->pl_prop != ZPROP_USERPROP) {\n\t\t\tif (zfs_prop_get(zhp, entry->pl_prop,\n\t\t\t    buf, sizeof (buf), NULL, NULL, 0, literal) == 0) {\n\t\t\t\tif (strlen(buf) > entry->pl_width)\n\t\t\t\t\tentry->pl_width = strlen(buf);\n\t\t\t}\n\t\t\tif (received && zfs_prop_get_recvd(zhp,\n\t\t\t    zfs_prop_to_name(entry->pl_prop),\n\t\t\t    buf, sizeof (buf), literal) == 0)\n\t\t\t\tif (strlen(buf) > entry->pl_recvd_width)\n\t\t\t\t\tentry->pl_recvd_width = strlen(buf);\n\t\t} else {\n\t\t\tif (nvlist_lookup_nvlist(userprops, entry->pl_user_prop,\n\t\t\t    &propval) == 0) {\n\t\t\t\tstrval = fnvlist_lookup_string(propval,\n\t\t\t\t    ZPROP_VALUE);\n\t\t\t\tif (strlen(strval) > entry->pl_width)\n\t\t\t\t\tentry->pl_width = strlen(strval);\n\t\t\t}\n\t\t\tif (received && zfs_prop_get_recvd(zhp,\n\t\t\t    entry->pl_user_prop,\n\t\t\t    buf, sizeof (buf), literal) == 0)\n\t\t\t\tif (strlen(buf) > entry->pl_recvd_width)\n\t\t\t\t\tentry->pl_recvd_width = strlen(buf);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nvoid\nzfs_prune_proplist(zfs_handle_t *zhp, uint8_t *props)\n{\n\tnvpair_t *curr;\n\tnvpair_t *next;\n\n\t \n\tzhp->zfs_props_table = props;\n\n\tcurr = nvlist_next_nvpair(zhp->zfs_props, NULL);\n\n\twhile (curr) {\n\t\tzfs_prop_t zfs_prop = zfs_name_to_prop(nvpair_name(curr));\n\t\tnext = nvlist_next_nvpair(zhp->zfs_props, curr);\n\n\t\t \n\t\tif (zfs_prop != ZPROP_USERPROP && props[zfs_prop] == B_FALSE)\n\t\t\t(void) nvlist_remove(zhp->zfs_props,\n\t\t\t    nvpair_name(curr), nvpair_type(curr));\n\t\tcurr = next;\n\t}\n}\n\nstatic int\nzfs_smb_acl_mgmt(libzfs_handle_t *hdl, char *dataset, char *path,\n    zfs_smb_acl_op_t cmd, char *resource1, char *resource2)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tnvlist_t *nvlist = NULL;\n\tint error;\n\n\t(void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name));\n\t(void) strlcpy(zc.zc_value, path, sizeof (zc.zc_value));\n\tzc.zc_cookie = (uint64_t)cmd;\n\n\tif (cmd == ZFS_SMB_ACL_RENAME) {\n\t\tif (nvlist_alloc(&nvlist, NV_UNIQUE_NAME, 0) != 0) {\n\t\t\t(void) no_memory(hdl);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase ZFS_SMB_ACL_ADD:\n\tcase ZFS_SMB_ACL_REMOVE:\n\t\t(void) strlcpy(zc.zc_string, resource1, sizeof (zc.zc_string));\n\t\tbreak;\n\tcase ZFS_SMB_ACL_RENAME:\n\t\tif (nvlist_add_string(nvlist, ZFS_SMB_ACL_SRC,\n\t\t    resource1) != 0) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif (nvlist_add_string(nvlist, ZFS_SMB_ACL_TARGET,\n\t\t    resource2) != 0) {\n\t\t\t\t(void) no_memory(hdl);\n\t\t\t\treturn (-1);\n\t\t}\n\t\tzcmd_write_src_nvlist(hdl, &zc, nvlist);\n\t\tbreak;\n\tcase ZFS_SMB_ACL_PURGE:\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\terror = ioctl(hdl->libzfs_fd, ZFS_IOC_SMB_ACL, &zc);\n\tnvlist_free(nvlist);\n\treturn (error);\n}\n\nint\nzfs_smb_acl_add(libzfs_handle_t *hdl, char *dataset,\n    char *path, char *resource)\n{\n\treturn (zfs_smb_acl_mgmt(hdl, dataset, path, ZFS_SMB_ACL_ADD,\n\t    resource, NULL));\n}\n\nint\nzfs_smb_acl_remove(libzfs_handle_t *hdl, char *dataset,\n    char *path, char *resource)\n{\n\treturn (zfs_smb_acl_mgmt(hdl, dataset, path, ZFS_SMB_ACL_REMOVE,\n\t    resource, NULL));\n}\n\nint\nzfs_smb_acl_purge(libzfs_handle_t *hdl, char *dataset, char *path)\n{\n\treturn (zfs_smb_acl_mgmt(hdl, dataset, path, ZFS_SMB_ACL_PURGE,\n\t    NULL, NULL));\n}\n\nint\nzfs_smb_acl_rename(libzfs_handle_t *hdl, char *dataset, char *path,\n    char *oldname, char *newname)\n{\n\treturn (zfs_smb_acl_mgmt(hdl, dataset, path, ZFS_SMB_ACL_RENAME,\n\t    oldname, newname));\n}\n\nint\nzfs_userspace(zfs_handle_t *zhp, zfs_userquota_prop_t type,\n    zfs_userspace_cb_t func, void *arg)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzfs_useracct_t buf[100];\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tint ret;\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\tzc.zc_objset_type = type;\n\tzc.zc_nvlist_dst = (uintptr_t)buf;\n\n\tfor (;;) {\n\t\tzfs_useracct_t *zua = buf;\n\n\t\tzc.zc_nvlist_dst_size = sizeof (buf);\n\t\tif (zfs_ioctl(hdl, ZFS_IOC_USERSPACE_MANY, &zc) != 0) {\n\t\t\tif ((errno == ENOTSUP &&\n\t\t\t    (type == ZFS_PROP_USEROBJUSED ||\n\t\t\t    type == ZFS_PROP_GROUPOBJUSED ||\n\t\t\t    type == ZFS_PROP_USEROBJQUOTA ||\n\t\t\t    type == ZFS_PROP_GROUPOBJQUOTA ||\n\t\t\t    type == ZFS_PROP_PROJECTOBJUSED ||\n\t\t\t    type == ZFS_PROP_PROJECTOBJQUOTA ||\n\t\t\t    type == ZFS_PROP_PROJECTUSED ||\n\t\t\t    type == ZFS_PROP_PROJECTQUOTA)))\n\t\t\t\tbreak;\n\n\t\t\treturn (zfs_standard_error_fmt(hdl, errno,\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot get used/quota for %s\"), zc.zc_name));\n\t\t}\n\t\tif (zc.zc_nvlist_dst_size == 0)\n\t\t\tbreak;\n\n\t\twhile (zc.zc_nvlist_dst_size > 0) {\n\t\t\tif ((ret = func(arg, zua->zu_domain, zua->zu_rid,\n\t\t\t    zua->zu_space)) != 0)\n\t\t\t\treturn (ret);\n\t\t\tzua++;\n\t\t\tzc.zc_nvlist_dst_size -= sizeof (zfs_useracct_t);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstruct holdarg {\n\tnvlist_t *nvl;\n\tconst char *snapname;\n\tconst char *tag;\n\tboolean_t recursive;\n\tint error;\n};\n\nstatic int\nzfs_hold_one(zfs_handle_t *zhp, void *arg)\n{\n\tstruct holdarg *ha = arg;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tint rv = 0;\n\n\tif (snprintf(name, sizeof (name), \"%s@%s\", zhp->zfs_name,\n\t    ha->snapname) >= sizeof (name))\n\t\treturn (EINVAL);\n\n\tif (lzc_exists(name))\n\t\tfnvlist_add_string(ha->nvl, name, ha->tag);\n\n\tif (ha->recursive)\n\t\trv = zfs_iter_filesystems_v2(zhp, 0, zfs_hold_one, ha);\n\tzfs_close(zhp);\n\treturn (rv);\n}\n\nint\nzfs_hold(zfs_handle_t *zhp, const char *snapname, const char *tag,\n    boolean_t recursive, int cleanup_fd)\n{\n\tint ret;\n\tstruct holdarg ha;\n\n\tha.nvl = fnvlist_alloc();\n\tha.snapname = snapname;\n\tha.tag = tag;\n\tha.recursive = recursive;\n\t(void) zfs_hold_one(zfs_handle_dup(zhp), &ha);\n\n\tif (nvlist_empty(ha.nvl)) {\n\t\tchar errbuf[ERRBUFLEN];\n\n\t\tfnvlist_free(ha.nvl);\n\t\tret = ENOENT;\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"cannot hold snapshot '%s@%s'\"),\n\t\t    zhp->zfs_name, snapname);\n\t\t(void) zfs_standard_error(zhp->zfs_hdl, ret, errbuf);\n\t\treturn (ret);\n\t}\n\n\tret = zfs_hold_nvl(zhp, cleanup_fd, ha.nvl);\n\tfnvlist_free(ha.nvl);\n\n\treturn (ret);\n}\n\nint\nzfs_hold_nvl(zfs_handle_t *zhp, int cleanup_fd, nvlist_t *holds)\n{\n\tint ret;\n\tnvlist_t *errors;\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar errbuf[ERRBUFLEN];\n\tnvpair_t *elem;\n\n\terrors = NULL;\n\tret = lzc_hold(holds, cleanup_fd, &errors);\n\n\tif (ret == 0) {\n\t\t \n\t\tfnvlist_free(errors);\n\t\treturn (0);\n\t}\n\n\tif (nvlist_empty(errors)) {\n\t\t \n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot hold\"));\n\t\tswitch (ret) {\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\t(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl, ret, errbuf);\n\t\t}\n\t}\n\n\tfor (elem = nvlist_next_nvpair(errors, NULL);\n\t    elem != NULL;\n\t    elem = nvlist_next_nvpair(errors, elem)) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"cannot hold snapshot '%s'\"), nvpair_name(elem));\n\t\tswitch (fnvpair_value_int32(elem)) {\n\t\tcase E2BIG:\n\t\t\t \n\t\t\t(void) zfs_error(hdl, EZFS_TAGTOOLONG, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\t(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tcase EEXIST:\n\t\t\t(void) zfs_error(hdl, EZFS_REFTAG_HOLD, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl,\n\t\t\t    fnvpair_value_int32(elem), errbuf);\n\t\t}\n\t}\n\n\tfnvlist_free(errors);\n\treturn (ret);\n}\n\nstatic int\nzfs_release_one(zfs_handle_t *zhp, void *arg)\n{\n\tstruct holdarg *ha = arg;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tint rv = 0;\n\tnvlist_t *existing_holds;\n\n\tif (snprintf(name, sizeof (name), \"%s@%s\", zhp->zfs_name,\n\t    ha->snapname) >= sizeof (name)) {\n\t\tha->error = EINVAL;\n\t\trv = EINVAL;\n\t}\n\n\tif (lzc_get_holds(name, &existing_holds) != 0) {\n\t\tha->error = ENOENT;\n\t} else if (!nvlist_exists(existing_holds, ha->tag)) {\n\t\tha->error = ESRCH;\n\t} else {\n\t\tnvlist_t *torelease = fnvlist_alloc();\n\t\tfnvlist_add_boolean(torelease, ha->tag);\n\t\tfnvlist_add_nvlist(ha->nvl, name, torelease);\n\t\tfnvlist_free(torelease);\n\t}\n\n\tif (ha->recursive)\n\t\trv = zfs_iter_filesystems_v2(zhp, 0, zfs_release_one, ha);\n\tzfs_close(zhp);\n\treturn (rv);\n}\n\nint\nzfs_release(zfs_handle_t *zhp, const char *snapname, const char *tag,\n    boolean_t recursive)\n{\n\tint ret;\n\tstruct holdarg ha;\n\tnvlist_t *errors = NULL;\n\tnvpair_t *elem;\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar errbuf[ERRBUFLEN];\n\n\tha.nvl = fnvlist_alloc();\n\tha.snapname = snapname;\n\tha.tag = tag;\n\tha.recursive = recursive;\n\tha.error = 0;\n\t(void) zfs_release_one(zfs_handle_dup(zhp), &ha);\n\n\tif (nvlist_empty(ha.nvl)) {\n\t\tfnvlist_free(ha.nvl);\n\t\tret = ha.error;\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"cannot release hold from snapshot '%s@%s'\"),\n\t\t    zhp->zfs_name, snapname);\n\t\tif (ret == ESRCH) {\n\t\t\t(void) zfs_error(hdl, EZFS_REFTAG_RELE, errbuf);\n\t\t} else {\n\t\t\t(void) zfs_standard_error(hdl, ret, errbuf);\n\t\t}\n\t\treturn (ret);\n\t}\n\n\tret = lzc_release(ha.nvl, &errors);\n\tfnvlist_free(ha.nvl);\n\n\tif (ret == 0) {\n\t\t \n\t\tfnvlist_free(errors);\n\t\treturn (0);\n\t}\n\n\tif (nvlist_empty(errors)) {\n\t\t \n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot release\"));\n\t\tswitch (errno) {\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl, errno, errbuf);\n\t\t}\n\t}\n\n\tfor (elem = nvlist_next_nvpair(errors, NULL);\n\t    elem != NULL;\n\t    elem = nvlist_next_nvpair(errors, elem)) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"cannot release hold from snapshot '%s'\"),\n\t\t    nvpair_name(elem));\n\t\tswitch (fnvpair_value_int32(elem)) {\n\t\tcase ESRCH:\n\t\t\t(void) zfs_error(hdl, EZFS_REFTAG_RELE, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\t(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl,\n\t\t\t    fnvpair_value_int32(elem), errbuf);\n\t\t}\n\t}\n\n\tfnvlist_free(errors);\n\treturn (ret);\n}\n\nint\nzfs_get_fsacl(zfs_handle_t *zhp, nvlist_t **nvl)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tint nvsz = 2048;\n\tvoid *nvbuf;\n\tint err = 0;\n\tchar errbuf[ERRBUFLEN];\n\n\tassert(zhp->zfs_type == ZFS_TYPE_VOLUME ||\n\t    zhp->zfs_type == ZFS_TYPE_FILESYSTEM);\n\ntryagain:\n\n\tnvbuf = malloc(nvsz);\n\tif (nvbuf == NULL) {\n\t\terr = (zfs_error(hdl, EZFS_NOMEM, strerror(errno)));\n\t\tgoto out;\n\t}\n\n\tzc.zc_nvlist_dst_size = nvsz;\n\tzc.zc_nvlist_dst = (uintptr_t)nvbuf;\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_GET_FSACL, &zc) != 0) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot get permissions on '%s'\"),\n\t\t    zc.zc_name);\n\t\tswitch (errno) {\n\t\tcase ENOMEM:\n\t\t\tfree(nvbuf);\n\t\t\tnvsz = zc.zc_nvlist_dst_size;\n\t\t\tgoto tryagain;\n\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\terr = zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = zfs_standard_error(hdl, errno, errbuf);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tint rc = nvlist_unpack(nvbuf, zc.zc_nvlist_dst_size, nvl, 0);\n\t\tif (rc) {\n\t\t\terr = zfs_standard_error_fmt(hdl, rc, dgettext(\n\t\t\t    TEXT_DOMAIN, \"cannot get permissions on '%s'\"),\n\t\t\t    zc.zc_name);\n\t\t}\n\t}\n\n\tfree(nvbuf);\nout:\n\treturn (err);\n}\n\nint\nzfs_set_fsacl(zfs_handle_t *zhp, boolean_t un, nvlist_t *nvl)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar *nvbuf;\n\tchar errbuf[ERRBUFLEN];\n\tsize_t nvsz;\n\tint err;\n\n\tassert(zhp->zfs_type == ZFS_TYPE_VOLUME ||\n\t    zhp->zfs_type == ZFS_TYPE_FILESYSTEM);\n\n\terr = nvlist_size(nvl, &nvsz, NV_ENCODE_NATIVE);\n\tassert(err == 0);\n\n\tnvbuf = malloc(nvsz);\n\n\terr = nvlist_pack(nvl, &nvbuf, &nvsz, NV_ENCODE_NATIVE, 0);\n\tassert(err == 0);\n\n\tzc.zc_nvlist_src_size = nvsz;\n\tzc.zc_nvlist_src = (uintptr_t)nvbuf;\n\tzc.zc_perm_action = un;\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\n\tif (zfs_ioctl(hdl, ZFS_IOC_SET_FSACL, &zc) != 0) {\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot set permissions on '%s'\"),\n\t\t    zc.zc_name);\n\t\tswitch (errno) {\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\terr = zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = zfs_standard_error(hdl, errno, errbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(nvbuf);\n\n\treturn (err);\n}\n\nint\nzfs_get_holds(zfs_handle_t *zhp, nvlist_t **nvl)\n{\n\tint err;\n\tchar errbuf[ERRBUFLEN];\n\n\terr = lzc_get_holds(zhp->zfs_name, nvl);\n\n\tif (err != 0) {\n\t\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN, \"cannot get holds for '%s'\"),\n\t\t    zhp->zfs_name);\n\t\tswitch (err) {\n\t\tcase ENOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"pool must be upgraded\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\terr = zfs_error(hdl, EZFS_BADTYPE, errbuf);\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = zfs_standard_error(hdl, errno, errbuf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (err);\n}\n\n \n\n \nstatic uint64_t\nvdev_raidz_asize(uint64_t ndisks, uint64_t nparity, uint64_t ashift,\n    uint64_t blksize)\n{\n\tuint64_t asize, ndata;\n\n\tASSERT3U(ndisks, >, nparity);\n\tndata = ndisks - nparity;\n\tasize = ((blksize - 1) >> ashift) + 1;\n\tasize += nparity * ((asize + ndata - 1) / ndata);\n\tasize = roundup(asize, nparity + 1) << ashift;\n\n\treturn (asize);\n}\n\n \nstatic uint64_t\nvdev_draid_asize(uint64_t ndisks, uint64_t nparity, uint64_t ashift,\n    uint64_t blksize)\n{\n\tASSERT3U(ndisks, >, nparity);\n\tuint64_t ndata = ndisks - nparity;\n\tuint64_t rows = ((blksize - 1) / (ndata << ashift)) + 1;\n\tuint64_t asize = (rows * ndisks) << ashift;\n\n\treturn (asize);\n}\n\n \nstatic uint64_t\nvolsize_from_vdevs(zpool_handle_t *zhp, uint64_t nblocks, uint64_t blksize)\n{\n\tnvlist_t *config, *tree, **vdevs;\n\tuint_t nvdevs;\n\tuint64_t ret = 0;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE, &tree) != 0 ||\n\t    nvlist_lookup_nvlist_array(tree, ZPOOL_CONFIG_CHILDREN,\n\t    &vdevs, &nvdevs) != 0) {\n\t\treturn (nblocks * blksize);\n\t}\n\n\tfor (int v = 0; v < nvdevs; v++) {\n\t\tconst char *type;\n\t\tuint64_t nparity, ashift, asize, tsize;\n\t\tuint64_t volsize;\n\n\t\tif (nvlist_lookup_string(vdevs[v], ZPOOL_CONFIG_TYPE,\n\t\t    &type) != 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(type, VDEV_TYPE_RAIDZ) != 0 &&\n\t\t    strcmp(type, VDEV_TYPE_DRAID) != 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(vdevs[v],\n\t\t    ZPOOL_CONFIG_NPARITY, &nparity) != 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(vdevs[v],\n\t\t    ZPOOL_CONFIG_ASHIFT, &ashift) != 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(type, VDEV_TYPE_RAIDZ) == 0) {\n\t\t\tnvlist_t **disks;\n\t\t\tuint_t ndisks;\n\n\t\t\tif (nvlist_lookup_nvlist_array(vdevs[v],\n\t\t\t    ZPOOL_CONFIG_CHILDREN, &disks, &ndisks) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttsize = vdev_raidz_asize(ndisks, nparity, ashift,\n\t\t\t    SPA_OLD_MAXBLOCKSIZE);\n\n\t\t\t \n\t\t\tasize = vdev_raidz_asize(ndisks, nparity, ashift,\n\t\t\t    blksize);\n\t\t} else {\n\t\t\tuint64_t ndata;\n\n\t\t\tif (nvlist_lookup_uint64(vdevs[v],\n\t\t\t    ZPOOL_CONFIG_DRAID_NDATA, &ndata) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttsize = vdev_draid_asize(ndata + nparity, nparity,\n\t\t\t    ashift, SPA_OLD_MAXBLOCKSIZE);\n\n\t\t\t \n\t\t\tasize = vdev_draid_asize(ndata + nparity, nparity,\n\t\t\t    ashift, blksize);\n\t\t}\n\n\t\t \n\t\tvolsize = nblocks * asize * SPA_OLD_MAXBLOCKSIZE / tsize;\n\t\tif (volsize > ret) {\n\t\t\tret = volsize;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\tret = nblocks * blksize;\n\t}\n\n\treturn (ret);\n}\n\n \nuint64_t\nzvol_volsize_to_reservation(zpool_handle_t *zph, uint64_t volsize,\n    nvlist_t *props)\n{\n\tuint64_t numdb;\n\tuint64_t nblocks, volblocksize;\n\tint ncopies;\n\tconst char *strval;\n\n\tif (nvlist_lookup_string(props,\n\t    zfs_prop_to_name(ZFS_PROP_COPIES), &strval) == 0)\n\t\tncopies = atoi(strval);\n\telse\n\t\tncopies = 1;\n\tif (nvlist_lookup_uint64(props,\n\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),\n\t    &volblocksize) != 0)\n\t\tvolblocksize = ZVOL_DEFAULT_BLOCKSIZE;\n\n\tnblocks = volsize / volblocksize;\n\t \n\tvolsize = volsize_from_vdevs(zph, nblocks, volblocksize);\n\n\t \n\tnumdb = 7;\n\t \n\twhile (nblocks > 1) {\n\t\tnblocks += DNODES_PER_LEVEL - 1;\n\t\tnblocks /= DNODES_PER_LEVEL;\n\t\tnumdb += nblocks;\n\t}\n\tnumdb *= MIN(SPA_DVAS_PER_BP, ncopies + 1);\n\tvolsize *= ncopies;\n\t \n\tnumdb *= 1ULL << DN_MAX_INDBLKSHIFT;\n\tvolsize += numdb;\n\treturn (volsize);\n}\n\n \nint\nzfs_wait_status(zfs_handle_t *zhp, zfs_wait_activity_t activity,\n    boolean_t *missing, boolean_t *waited)\n{\n\tint error = lzc_wait_fs(zhp->zfs_name, activity, waited);\n\t*missing = (error == ENOENT);\n\tif (*missing)\n\t\treturn (0);\n\n\tif (error != 0) {\n\t\t(void) zfs_standard_error_fmt(zhp->zfs_hdl, error,\n\t\t    dgettext(TEXT_DOMAIN, \"error waiting in fs '%s'\"),\n\t\t    zhp->zfs_name);\n\t}\n\n\treturn (error);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}