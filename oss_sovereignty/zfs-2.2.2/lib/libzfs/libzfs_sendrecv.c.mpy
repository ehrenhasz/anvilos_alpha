{
  "module_name": "libzfs_sendrecv.c",
  "hash_id": "24d8571614bb4cec6cd1f81ea6c36e98cbbf934509b6f2f23acab953d24a99e0",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs/libzfs_sendrecv.c",
  "human_readable_source": " \n\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <libintl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <fcntl.h>\n#include <sys/mount.h>\n#include <sys/mntent.h>\n#include <sys/mnttab.h>\n#include <sys/avl.h>\n#include <sys/debug.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <umem.h>\n#include <time.h>\n\n#include <libzfs.h>\n#include <libzfs_core.h>\n#include <libzutil.h>\n\n#include \"zfs_namecheck.h\"\n#include \"zfs_prop.h\"\n#include \"zfs_fletcher.h\"\n#include \"libzfs_impl.h\"\n#include <cityhash.h>\n#include <zlib.h>\n#include <sys/zio_checksum.h>\n#include <sys/dsl_crypt.h>\n#include <sys/ddt.h>\n#include <sys/socket.h>\n#include <sys/sha2.h>\n\nstatic int zfs_receive_impl(libzfs_handle_t *, const char *, const char *,\n    recvflags_t *, int, const char *, nvlist_t *, avl_tree_t *, char **,\n    const char *, nvlist_t *);\nstatic int guid_to_name_redact_snaps(libzfs_handle_t *hdl, const char *parent,\n    uint64_t guid, boolean_t bookmark_ok, uint64_t *redact_snap_guids,\n    uint64_t num_redact_snaps, char *name);\nstatic int guid_to_name(libzfs_handle_t *, const char *,\n    uint64_t, boolean_t, char *);\n\ntypedef struct progress_arg {\n\tzfs_handle_t *pa_zhp;\n\tint pa_fd;\n\tboolean_t pa_parsable;\n\tboolean_t pa_estimate;\n\tint pa_verbosity;\n\tboolean_t pa_astitle;\n\tboolean_t pa_progress;\n\tuint64_t pa_size;\n} progress_arg_t;\n\nstatic int\ndump_record(dmu_replay_record_t *drr, void *payload, size_t payload_len,\n    zio_cksum_t *zc, int outfd)\n{\n\tASSERT3U(offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum),\n\t    ==, sizeof (dmu_replay_record_t) - sizeof (zio_cksum_t));\n\tfletcher_4_incremental_native(drr,\n\t    offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum), zc);\n\tif (drr->drr_type != DRR_BEGIN) {\n\t\tASSERT(ZIO_CHECKSUM_IS_ZERO(&drr->drr_u.\n\t\t    drr_checksum.drr_checksum));\n\t\tdrr->drr_u.drr_checksum.drr_checksum = *zc;\n\t}\n\tfletcher_4_incremental_native(&drr->drr_u.drr_checksum.drr_checksum,\n\t    sizeof (zio_cksum_t), zc);\n\tif (write(outfd, drr, sizeof (*drr)) == -1)\n\t\treturn (errno);\n\tif (payload_len != 0) {\n\t\tfletcher_4_incremental_native(payload, payload_len, zc);\n\t\tif (write(outfd, payload, payload_len) == -1)\n\t\t\treturn (errno);\n\t}\n\treturn (0);\n}\n\n \ntypedef struct fsavl_node {\n\tavl_node_t fn_node;\n\tnvlist_t *fn_nvfs;\n\tconst char *fn_snapname;\n\tuint64_t fn_guid;\n} fsavl_node_t;\n\nstatic int\nfsavl_compare(const void *arg1, const void *arg2)\n{\n\tconst fsavl_node_t *fn1 = (const fsavl_node_t *)arg1;\n\tconst fsavl_node_t *fn2 = (const fsavl_node_t *)arg2;\n\n\treturn (TREE_CMP(fn1->fn_guid, fn2->fn_guid));\n}\n\n \nstatic nvlist_t *\nfsavl_find(avl_tree_t *avl, uint64_t snapguid, const char **snapname)\n{\n\tfsavl_node_t fn_find;\n\tfsavl_node_t *fn;\n\n\tfn_find.fn_guid = snapguid;\n\n\tfn = avl_find(avl, &fn_find, NULL);\n\tif (fn) {\n\t\tif (snapname)\n\t\t\t*snapname = fn->fn_snapname;\n\t\treturn (fn->fn_nvfs);\n\t}\n\treturn (NULL);\n}\n\nstatic void\nfsavl_destroy(avl_tree_t *avl)\n{\n\tfsavl_node_t *fn;\n\tvoid *cookie;\n\n\tif (avl == NULL)\n\t\treturn;\n\n\tcookie = NULL;\n\twhile ((fn = avl_destroy_nodes(avl, &cookie)) != NULL)\n\t\tfree(fn);\n\tavl_destroy(avl);\n\tfree(avl);\n}\n\n \nstatic avl_tree_t *\nfsavl_create(nvlist_t *fss)\n{\n\tavl_tree_t *fsavl;\n\tnvpair_t *fselem = NULL;\n\n\tif ((fsavl = malloc(sizeof (avl_tree_t))) == NULL)\n\t\treturn (NULL);\n\n\tavl_create(fsavl, fsavl_compare, sizeof (fsavl_node_t),\n\t    offsetof(fsavl_node_t, fn_node));\n\n\twhile ((fselem = nvlist_next_nvpair(fss, fselem)) != NULL) {\n\t\tnvlist_t *nvfs, *snaps;\n\t\tnvpair_t *snapelem = NULL;\n\n\t\tnvfs = fnvpair_value_nvlist(fselem);\n\t\tsnaps = fnvlist_lookup_nvlist(nvfs, \"snaps\");\n\n\t\twhile ((snapelem =\n\t\t    nvlist_next_nvpair(snaps, snapelem)) != NULL) {\n\t\t\tfsavl_node_t *fn;\n\n\t\t\tif ((fn = malloc(sizeof (fsavl_node_t))) == NULL) {\n\t\t\t\tfsavl_destroy(fsavl);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfn->fn_nvfs = nvfs;\n\t\t\tfn->fn_snapname = nvpair_name(snapelem);\n\t\t\tfn->fn_guid = fnvpair_value_uint64(snapelem);\n\n\t\t\t \n\t\t\tavl_index_t where = 0;\n\t\t\tif (avl_find(fsavl, fn, &where) == NULL)\n\t\t\t\tavl_insert(fsavl, fn, where);\n\t\t\telse\n\t\t\t\tfree(fn);\n\t\t}\n\t}\n\n\treturn (fsavl);\n}\n\n \ntypedef struct send_data {\n\t \n\n\tuint64_t parent_fromsnap_guid;\n\tuint64_t fromsnap_txg;\n\tuint64_t tosnap_txg;\n\n\t \n\tnvlist_t *parent_snaps;\n\tnvlist_t *fss;\n\tnvlist_t *snapprops;\n\tnvlist_t *snapholds;\t \n\n\t \n\tconst char *fsname;\n\tconst char *fromsnap;\n\tconst char *tosnap;\n\tboolean_t recursive;\n\tboolean_t raw;\n\tboolean_t doall;\n\tboolean_t replicate;\n\tboolean_t skipmissing;\n\tboolean_t verbose;\n\tboolean_t backup;\n\tboolean_t seenfrom;\n\tboolean_t seento;\n\tboolean_t holds;\t \n\tboolean_t props;\n\n\t \n} send_data_t;\n\nstatic void\nsend_iterate_prop(zfs_handle_t *zhp, boolean_t received_only, nvlist_t *nv);\n\n \nstatic int\nsend_iterate_snap(zfs_handle_t *zhp, void *arg)\n{\n\tsend_data_t *sd = arg;\n\tuint64_t guid = zhp->zfs_dmustats.dds_guid;\n\tuint64_t txg = zhp->zfs_dmustats.dds_creation_txg;\n\tboolean_t isfromsnap, istosnap, istosnapwithnofrom;\n\tchar *snapname;\n\tconst char *from = sd->fromsnap;\n\tconst char *to = sd->tosnap;\n\n\tsnapname = strrchr(zhp->zfs_name, '@');\n\tassert(snapname != NULL);\n\t++snapname;\n\n\tisfromsnap = (from != NULL && strcmp(from, snapname) == 0);\n\tistosnap = (to != NULL && strcmp(to, snapname) == 0);\n\tistosnapwithnofrom = (istosnap && from == NULL);\n\n\tif (sd->tosnap_txg != 0 && txg > sd->tosnap_txg) {\n\t\tif (sd->verbose) {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"skipping snapshot %s because it was created \"\n\t\t\t    \"after the destination snapshot (%s)\\n\"),\n\t\t\t    zhp->zfs_name, to);\n\t\t}\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tfnvlist_add_uint64(sd->parent_snaps, snapname, guid);\n\n\t \n\tif (isfromsnap || (sd->parent_fromsnap_guid == 0 && istosnap))\n\t\tsd->parent_fromsnap_guid = guid;\n\n\tif (!sd->recursive) {\n\t\t \n\t\tif (sd->doall && from == NULL && !sd->seenfrom)\n\t\t\tsd->seenfrom = B_TRUE;\n\n\t\tif (!sd->seenfrom && isfromsnap) {\n\t\t\tsd->seenfrom = B_TRUE;\n\t\t\tzfs_close(zhp);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif ((sd->seento || !sd->seenfrom) && !istosnapwithnofrom) {\n\t\t\tzfs_close(zhp);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif (istosnap)\n\t\t\tsd->seento = B_TRUE;\n\t}\n\n\tnvlist_t *nv = fnvlist_alloc();\n\tsend_iterate_prop(zhp, sd->backup, nv);\n\tfnvlist_add_nvlist(sd->snapprops, snapname, nv);\n\tfnvlist_free(nv);\n\n\tif (sd->holds) {\n\t\tnvlist_t *holds;\n\t\tif (lzc_get_holds(zhp->zfs_name, &holds) == 0) {\n\t\t\tfnvlist_add_nvlist(sd->snapholds, snapname, holds);\n\t\t\tfnvlist_free(holds);\n\t\t}\n\t}\n\n\tzfs_close(zhp);\n\treturn (0);\n}\n\n \nstatic void\nsend_iterate_prop(zfs_handle_t *zhp, boolean_t received_only, nvlist_t *nv)\n{\n\tnvlist_t *props;\n\n\tif (received_only)\n\t\tprops = zfs_get_recvd_props(zhp);\n\telse\n\t\tprops = zhp->zfs_props;\n\n\tnvpair_t *elem = NULL;\n\twhile ((elem = nvlist_next_nvpair(props, elem)) != NULL) {\n\t\tconst char *propname = nvpair_name(elem);\n\t\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\n\t\tif (!zfs_prop_user(propname)) {\n\t\t\t \n\t\t\tif (prop == ZPROP_INVAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (zfs_prop_readonly(prop))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tnvlist_t *propnv = fnvpair_value_nvlist(elem);\n\n\t\tboolean_t isspacelimit = (prop == ZFS_PROP_QUOTA ||\n\t\t    prop == ZFS_PROP_RESERVATION ||\n\t\t    prop == ZFS_PROP_REFQUOTA ||\n\t\t    prop == ZFS_PROP_REFRESERVATION);\n\t\tif (isspacelimit && zhp->zfs_type == ZFS_TYPE_SNAPSHOT)\n\t\t\tcontinue;\n\n\t\tconst char *source;\n\t\tif (nvlist_lookup_string(propnv, ZPROP_SOURCE, &source) == 0) {\n\t\t\tif (strcmp(source, zhp->zfs_name) != 0 &&\n\t\t\t    strcmp(source, ZPROP_SOURCE_VAL_RECVD) != 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (!isspacelimit)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (zfs_prop_user(propname) ||\n\t\t    zfs_prop_get_type(prop) == PROP_TYPE_STRING) {\n\t\t\tconst char *value;\n\t\t\tvalue = fnvlist_lookup_string(propnv, ZPROP_VALUE);\n\t\t\tfnvlist_add_string(nv, propname, value);\n\t\t} else {\n\t\t\tuint64_t value;\n\t\t\tvalue = fnvlist_lookup_uint64(propnv, ZPROP_VALUE);\n\t\t\tfnvlist_add_uint64(nv, propname, value);\n\t\t}\n\t}\n}\n\n \nstatic uint64_t\nget_snap_guid(libzfs_handle_t *hdl, const char *fs, const char *snap)\n{\n\tchar name[MAXPATHLEN + 1];\n\tuint64_t guid = 0;\n\n\tif (fs == NULL || fs[0] == '\\0' || snap == NULL || snap[0] == '\\0')\n\t\treturn (guid);\n\n\t(void) snprintf(name, sizeof (name), \"%s@%s\", fs, snap);\n\tzfs_handle_t *zhp = zfs_open(hdl, name, ZFS_TYPE_SNAPSHOT);\n\tif (zhp != NULL) {\n\t\tguid = zfs_prop_get_int(zhp, ZFS_PROP_GUID);\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (guid);\n}\n\n \nstatic uint64_t\nget_snap_txg(libzfs_handle_t *hdl, const char *fs, const char *snap)\n{\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t txg = 0;\n\n\tif (fs == NULL || fs[0] == '\\0' || snap == NULL || snap[0] == '\\0')\n\t\treturn (txg);\n\n\t(void) snprintf(name, sizeof (name), \"%s@%s\", fs, snap);\n\tif (zfs_dataset_exists(hdl, name, ZFS_TYPE_SNAPSHOT)) {\n\t\tzfs_handle_t *zhp = zfs_open(hdl, name, ZFS_TYPE_SNAPSHOT);\n\t\tif (zhp != NULL) {\n\t\t\ttxg = zfs_prop_get_int(zhp, ZFS_PROP_CREATETXG);\n\t\t\tzfs_close(zhp);\n\t\t}\n\t}\n\n\treturn (txg);\n}\n\n \nstatic int\nsend_iterate_fs(zfs_handle_t *zhp, void *arg)\n{\n\tsend_data_t *sd = arg;\n\tnvlist_t *nvfs = NULL, *nv = NULL;\n\tint rv = 0;\n\tuint64_t min_txg = 0, max_txg = 0;\n\tuint64_t txg = zhp->zfs_dmustats.dds_creation_txg;\n\tuint64_t guid = zhp->zfs_dmustats.dds_guid;\n\tuint64_t fromsnap_txg, tosnap_txg;\n\tchar guidstring[64];\n\n\t \n\tuint64_t parent_fromsnap_guid_save = sd->parent_fromsnap_guid;\n\tuint64_t fromsnap_txg_save = sd->fromsnap_txg;\n\tuint64_t tosnap_txg_save = sd->tosnap_txg;\n\n\tfromsnap_txg = get_snap_txg(zhp->zfs_hdl, zhp->zfs_name, sd->fromsnap);\n\tif (fromsnap_txg != 0)\n\t\tsd->fromsnap_txg = fromsnap_txg;\n\n\ttosnap_txg = get_snap_txg(zhp->zfs_hdl, zhp->zfs_name, sd->tosnap);\n\tif (tosnap_txg != 0)\n\t\tsd->tosnap_txg = tosnap_txg;\n\n\t \n\tif (sd->tosnap != NULL && tosnap_txg == 0) {\n\t\tif (sd->tosnap_txg != 0 && txg > sd->tosnap_txg) {\n\t\t\tif (sd->verbose) {\n\t\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"skipping dataset %s: snapshot %s does \"\n\t\t\t\t    \"not exist\\n\"), zhp->zfs_name, sd->tosnap);\n\t\t\t}\n\t\t} else if (sd->skipmissing) {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"WARNING: skipping dataset %s and its children:\"\n\t\t\t    \" snapshot %s does not exist\\n\"),\n\t\t\t    zhp->zfs_name, sd->tosnap);\n\t\t} else {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot send %s@%s%s: snapshot %s@%s does not \"\n\t\t\t    \"exist\\n\"), sd->fsname, sd->tosnap, sd->recursive ?\n\t\t\t    dgettext(TEXT_DOMAIN, \" recursively\") : \"\",\n\t\t\t    zhp->zfs_name, sd->tosnap);\n\t\t\trv = EZFS_NOENT;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tnvfs = fnvlist_alloc();\n\tfnvlist_add_string(nvfs, \"name\", zhp->zfs_name);\n\tfnvlist_add_uint64(nvfs, \"parentfromsnap\", sd->parent_fromsnap_guid);\n\n\tif (zhp->zfs_dmustats.dds_origin[0] != '\\0') {\n\t\tzfs_handle_t *origin = zfs_open(zhp->zfs_hdl,\n\t\t    zhp->zfs_dmustats.dds_origin, ZFS_TYPE_SNAPSHOT);\n\t\tif (origin == NULL) {\n\t\t\trv = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tfnvlist_add_uint64(nvfs, \"origin\",\n\t\t    origin->zfs_dmustats.dds_guid);\n\t\tzfs_close(origin);\n\t}\n\n\t \n\tif (sd->props || sd->backup || sd->recursive) {\n\t\tnv = fnvlist_alloc();\n\t\tsend_iterate_prop(zhp, sd->backup, nv);\n\t\tfnvlist_add_nvlist(nvfs, \"props\", nv);\n\t}\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) != ZIO_CRYPT_OFF) {\n\t\tboolean_t encroot;\n\n\t\t \n\t\tif (zfs_crypto_get_encryption_root(zhp, &encroot, NULL) != 0) {\n\t\t\trv = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (encroot)\n\t\t\tfnvlist_add_boolean(nvfs, \"is_encroot\");\n\n\t\t \n\t\tif (!sd->raw) {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot send %s@%s: encrypted dataset %s may not \"\n\t\t\t    \"be sent with properties without the raw flag\\n\"),\n\t\t\t    sd->fsname, sd->tosnap, zhp->zfs_name);\n\t\t\trv = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\t \n\tsd->parent_fromsnap_guid = 0;\n\tsd->parent_snaps = fnvlist_alloc();\n\tsd->snapprops = fnvlist_alloc();\n\tif (sd->holds)\n\t\tsd->snapholds = fnvlist_alloc();\n\tif (sd->doall || sd->replicate || sd->tosnap == NULL) {\n\t\tif (!sd->replicate && fromsnap_txg != 0)\n\t\t\tmin_txg = fromsnap_txg;\n\t\tif (!sd->replicate && tosnap_txg != 0)\n\t\t\tmax_txg = tosnap_txg;\n\t\t(void) zfs_iter_snapshots_sorted_v2(zhp, 0, send_iterate_snap,\n\t\t    sd, min_txg, max_txg);\n\t} else {\n\t\tchar snapname[MAXPATHLEN] = { 0 };\n\t\tzfs_handle_t *snap;\n\n\t\t(void) snprintf(snapname, sizeof (snapname), \"%s@%s\",\n\t\t    zhp->zfs_name, sd->tosnap);\n\t\tif (sd->fromsnap != NULL)\n\t\t\tsd->seenfrom = B_TRUE;\n\t\tsnap = zfs_open(zhp->zfs_hdl, snapname, ZFS_TYPE_SNAPSHOT);\n\t\tif (snap != NULL)\n\t\t\t(void) send_iterate_snap(snap, sd);\n\t}\n\n\tfnvlist_add_nvlist(nvfs, \"snaps\", sd->parent_snaps);\n\tfnvlist_free(sd->parent_snaps);\n\tfnvlist_add_nvlist(nvfs, \"snapprops\", sd->snapprops);\n\tfnvlist_free(sd->snapprops);\n\tif (sd->holds) {\n\t\tfnvlist_add_nvlist(nvfs, \"snapholds\", sd->snapholds);\n\t\tfnvlist_free(sd->snapholds);\n\t}\n\n\t \n\tif ((fnvlist_size(nvfs) + fnvlist_size(sd->fss)) >\n\t    zhp->zfs_hdl->libzfs_max_nvlist) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t    \"warning: cannot send %s@%s: the size of the list of \"\n\t\t    \"snapshots and properties is too large to be received \"\n\t\t    \"successfully.\\n\"\n\t\t    \"Select a smaller number of snapshots to send.\\n\"),\n\t\t    zhp->zfs_name, sd->tosnap);\n\t\trv = EZFS_NOSPC;\n\t\tgoto out;\n\t}\n\t \n\t(void) snprintf(guidstring, sizeof (guidstring),\n\t    \"0x%llx\", (longlong_t)guid);\n\tfnvlist_add_nvlist(sd->fss, guidstring, nvfs);\n\n\t \n\tif (sd->recursive)\n\t\trv = zfs_iter_filesystems_v2(zhp, 0, send_iterate_fs, sd);\n\nout:\n\t \n\tsd->parent_fromsnap_guid = parent_fromsnap_guid_save;\n\tsd->fromsnap_txg = fromsnap_txg_save;\n\tsd->tosnap_txg = tosnap_txg_save;\n\n\tfnvlist_free(nv);\n\tfnvlist_free(nvfs);\n\n\tzfs_close(zhp);\n\treturn (rv);\n}\n\nstatic int\ngather_nvlist(libzfs_handle_t *hdl, const char *fsname, const char *fromsnap,\n    const char *tosnap, boolean_t recursive, boolean_t raw, boolean_t doall,\n    boolean_t replicate, boolean_t skipmissing, boolean_t verbose,\n    boolean_t backup, boolean_t holds, boolean_t props, nvlist_t **nvlp,\n    avl_tree_t **avlp)\n{\n\tzfs_handle_t *zhp;\n\tsend_data_t sd = { 0 };\n\tint error;\n\n\tzhp = zfs_open(hdl, fsname, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\tif (zhp == NULL)\n\t\treturn (EZFS_BADTYPE);\n\n\tsd.fss = fnvlist_alloc();\n\tsd.fsname = fsname;\n\tsd.fromsnap = fromsnap;\n\tsd.tosnap = tosnap;\n\tsd.recursive = recursive;\n\tsd.raw = raw;\n\tsd.doall = doall;\n\tsd.replicate = replicate;\n\tsd.skipmissing = skipmissing;\n\tsd.verbose = verbose;\n\tsd.backup = backup;\n\tsd.holds = holds;\n\tsd.props = props;\n\n\tif ((error = send_iterate_fs(zhp, &sd)) != 0) {\n\t\tfnvlist_free(sd.fss);\n\t\tif (avlp != NULL)\n\t\t\t*avlp = NULL;\n\t\t*nvlp = NULL;\n\t\treturn (error);\n\t}\n\n\tif (avlp != NULL && (*avlp = fsavl_create(sd.fss)) == NULL) {\n\t\tfnvlist_free(sd.fss);\n\t\t*nvlp = NULL;\n\t\treturn (EZFS_NOMEM);\n\t}\n\n\t*nvlp = sd.fss;\n\treturn (0);\n}\n\n \ntypedef struct send_dump_data {\n\t \n\tconst char *fromsnap;\n\tconst char *tosnap;\n\tchar prevsnap[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t prevsnap_obj;\n\tboolean_t seenfrom, seento, replicate, doall, fromorigin;\n\tboolean_t dryrun, parsable, progress, embed_data, std_out;\n\tboolean_t large_block, compress, raw, holds;\n\tboolean_t progressastitle;\n\tint outfd;\n\tboolean_t err;\n\tnvlist_t *fss;\n\tnvlist_t *snapholds;\n\tavl_tree_t *fsavl;\n\tsnapfilter_cb_t *filter_cb;\n\tvoid *filter_cb_arg;\n\tnvlist_t *debugnv;\n\tchar holdtag[ZFS_MAX_DATASET_NAME_LEN];\n\tint cleanup_fd;\n\tint verbosity;\n\tuint64_t size;\n} send_dump_data_t;\n\nstatic int\nzfs_send_space(zfs_handle_t *zhp, const char *snapname, const char *from,\n    enum lzc_send_flags flags, uint64_t *spacep)\n{\n\tassert(snapname != NULL);\n\n\tint error = lzc_send_space(snapname, from, flags, spacep);\n\tif (error == 0)\n\t\treturn (0);\n\n\tchar errbuf[ERRBUFLEN];\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"warning: cannot estimate space for '%s'\"), snapname);\n\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tswitch (error) {\n\tcase EXDEV:\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"not an earlier snapshot from the same fs\"));\n\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));\n\n\tcase ENOENT:\n\t\tif (zfs_dataset_exists(hdl, snapname,\n\t\t    ZFS_TYPE_SNAPSHOT)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"incremental source (%s) does not exist\"),\n\t\t\t    snapname);\n\t\t}\n\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\n\tcase EDQUOT:\n\tcase EFBIG:\n\tcase EIO:\n\tcase ENOLINK:\n\tcase ENOSPC:\n\tcase ENOSTR:\n\tcase ENXIO:\n\tcase EPIPE:\n\tcase ERANGE:\n\tcase EFAULT:\n\tcase EROFS:\n\tcase EINVAL:\n\t\tzfs_error_aux(hdl, \"%s\", strerror(error));\n\t\treturn (zfs_error(hdl, EZFS_BADBACKUP, errbuf));\n\n\tdefault:\n\t\treturn (zfs_standard_error(hdl, error, errbuf));\n\t}\n}\n\n \nstatic int\ndump_ioctl(zfs_handle_t *zhp, const char *fromsnap, uint64_t fromsnap_obj,\n    boolean_t fromorigin, int outfd, enum lzc_send_flags flags,\n    nvlist_t *debugnv)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvlist_t *thisdbg;\n\n\tassert(zhp->zfs_type == ZFS_TYPE_SNAPSHOT);\n\tassert(fromsnap_obj == 0 || !fromorigin);\n\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\tzc.zc_cookie = outfd;\n\tzc.zc_obj = fromorigin;\n\tzc.zc_sendobj = zfs_prop_get_int(zhp, ZFS_PROP_OBJSETID);\n\tzc.zc_fromobj = fromsnap_obj;\n\tzc.zc_flags = flags;\n\n\tif (debugnv != NULL) {\n\t\tthisdbg = fnvlist_alloc();\n\t\tif (fromsnap != NULL && fromsnap[0] != '\\0')\n\t\t\tfnvlist_add_string(thisdbg, \"fromsnap\", fromsnap);\n\t}\n\n\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_SEND, &zc) != 0) {\n\t\tchar errbuf[ERRBUFLEN];\n\t\tint error = errno;\n\n\t\t(void) snprintf(errbuf, sizeof (errbuf), \"%s '%s'\",\n\t\t    dgettext(TEXT_DOMAIN, \"warning: cannot send\"),\n\t\t    zhp->zfs_name);\n\n\t\tif (debugnv != NULL) {\n\t\t\tfnvlist_add_uint64(thisdbg, \"error\", error);\n\t\t\tfnvlist_add_nvlist(debugnv, zhp->zfs_name, thisdbg);\n\t\t\tfnvlist_free(thisdbg);\n\t\t}\n\n\t\tswitch (error) {\n\t\tcase EXDEV:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"not an earlier snapshot from the same fs\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));\n\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"source key must be loaded\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\n\t\tcase ENOENT:\n\t\t\tif (zfs_dataset_exists(hdl, zc.zc_name,\n\t\t\t    ZFS_TYPE_SNAPSHOT)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"incremental source (@%s) does not exist\"),\n\t\t\t\t    zc.zc_value);\n\t\t\t}\n\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\n\t\tcase EDQUOT:\n\t\tcase EFBIG:\n\t\tcase EIO:\n\t\tcase ENOLINK:\n\t\tcase ENOSPC:\n\t\tcase ENOSTR:\n\t\tcase ENXIO:\n\t\tcase EPIPE:\n\t\tcase ERANGE:\n\t\tcase EFAULT:\n\t\tcase EROFS:\n\t\tcase EINVAL:\n\t\t\tzfs_error_aux(hdl, \"%s\", strerror(errno));\n\t\t\treturn (zfs_error(hdl, EZFS_BADBACKUP, errbuf));\n\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t\t}\n\t}\n\n\tif (debugnv != NULL) {\n\t\tfnvlist_add_nvlist(debugnv, zhp->zfs_name, thisdbg);\n\t\tfnvlist_free(thisdbg);\n\t}\n\n\treturn (0);\n}\n\nstatic void\ngather_holds(zfs_handle_t *zhp, send_dump_data_t *sdd)\n{\n\tassert(zhp->zfs_type == ZFS_TYPE_SNAPSHOT);\n\n\t \n\tif (sdd->snapholds == NULL)\n\t\treturn;\n\n\tfnvlist_add_string(sdd->snapholds, zhp->zfs_name, sdd->holdtag);\n}\n\nint\nzfs_send_progress(zfs_handle_t *zhp, int fd, uint64_t *bytes_written,\n    uint64_t *blocks_visited)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tif (bytes_written != NULL)\n\t\t*bytes_written = 0;\n\tif (blocks_visited != NULL)\n\t\t*blocks_visited = 0;\n\t(void) strlcpy(zc.zc_name, zhp->zfs_name, sizeof (zc.zc_name));\n\tzc.zc_cookie = fd;\n\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_SEND_PROGRESS, &zc) != 0)\n\t\treturn (errno);\n\tif (bytes_written != NULL)\n\t\t*bytes_written = zc.zc_cookie;\n\tif (blocks_visited != NULL)\n\t\t*blocks_visited = zc.zc_objset_type;\n\treturn (0);\n}\n\nstatic volatile boolean_t send_progress_thread_signal_duetotimer;\nstatic void\nsend_progress_thread_act(int sig, siginfo_t *info, void *ucontext)\n{\n\t(void) sig, (void) ucontext;\n\tsend_progress_thread_signal_duetotimer = info->si_code == SI_TIMER;\n}\n\nstruct timer_desirability {\n\ttimer_t timer;\n\tboolean_t desired;\n};\nstatic void\ntimer_delete_cleanup(void *timer)\n{\n\tstruct timer_desirability *td = timer;\n\tif (td->desired)\n\t\ttimer_delete(td->timer);\n}\n\n#ifdef SIGINFO\n#define\tSEND_PROGRESS_THREAD_PARENT_BLOCK_SIGINFO sigaddset(&new, SIGINFO)\n#else\n#define\tSEND_PROGRESS_THREAD_PARENT_BLOCK_SIGINFO\n#endif\n#define\tSEND_PROGRESS_THREAD_PARENT_BLOCK(old) { \\\n\tsigset_t new; \\\n\tsigemptyset(&new); \\\n\tsigaddset(&new, SIGUSR1); \\\n\tSEND_PROGRESS_THREAD_PARENT_BLOCK_SIGINFO; \\\n\tpthread_sigmask(SIG_BLOCK, &new, old); \\\n}\n\nstatic void *\nsend_progress_thread(void *arg)\n{\n\tprogress_arg_t *pa = arg;\n\tzfs_handle_t *zhp = pa->pa_zhp;\n\tuint64_t bytes;\n\tuint64_t blocks;\n\tuint64_t total = pa->pa_size / 100;\n\tchar buf[16];\n\ttime_t t;\n\tstruct tm tm;\n\tint err;\n\n\tconst struct sigaction signal_action =\n\t    {.sa_sigaction = send_progress_thread_act, .sa_flags = SA_SIGINFO};\n\tstruct sigevent timer_cfg =\n\t    {.sigev_notify = SIGEV_SIGNAL, .sigev_signo = SIGUSR1};\n\tconst struct itimerspec timer_time =\n\t    {.it_value = {.tv_sec = 1}, .it_interval = {.tv_sec = 1}};\n\tstruct timer_desirability timer = {};\n\n\tsigaction(SIGUSR1, &signal_action, NULL);\n#ifdef SIGINFO\n\tsigaction(SIGINFO, &signal_action, NULL);\n#endif\n\n\tif ((timer.desired = pa->pa_progress || pa->pa_astitle)) {\n\t\tif (timer_create(CLOCK_MONOTONIC, &timer_cfg, &timer.timer))\n\t\t\treturn ((void *)(uintptr_t)errno);\n\t\t(void) timer_settime(timer.timer, 0, &timer_time, NULL);\n\t}\n\tpthread_cleanup_push(timer_delete_cleanup, &timer);\n\n\tif (!pa->pa_parsable && pa->pa_progress) {\n\t\t(void) fprintf(stderr,\n\t\t    \"TIME       %s   %sSNAPSHOT %s\\n\",\n\t\t    pa->pa_estimate ? \"BYTES\" : \" SENT\",\n\t\t    pa->pa_verbosity >= 2 ? \"   BLOCKS    \" : \"\",\n\t\t    zhp->zfs_name);\n\t}\n\n\t \n\tfor (;;) {\n\t\tpause();\n\t\tif ((err = zfs_send_progress(zhp, pa->pa_fd, &bytes,\n\t\t    &blocks)) != 0) {\n\t\t\tif (err == EINTR || err == ENOENT)\n\t\t\t\terr = 0;\n\t\t\tpthread_exit(((void *)(uintptr_t)err));\n\t\t}\n\n\t\t(void) time(&t);\n\t\tlocaltime_r(&t, &tm);\n\n\t\tif (pa->pa_astitle) {\n\t\t\tchar buf_bytes[16];\n\t\t\tchar buf_size[16];\n\t\t\tint pct;\n\t\t\tzfs_nicenum(bytes, buf_bytes, sizeof (buf_bytes));\n\t\t\tzfs_nicenum(pa->pa_size, buf_size, sizeof (buf_size));\n\t\t\tpct = (total > 0) ? bytes / total : 100;\n\t\t\tzfs_setproctitle(\"sending %s (%d%%: %s/%s)\",\n\t\t\t    zhp->zfs_name, MIN(pct, 100), buf_bytes, buf_size);\n\t\t}\n\n\t\tif (pa->pa_verbosity >= 2 && pa->pa_parsable) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"%02d:%02d:%02d\\t%llu\\t%llu\\t%s\\n\",\n\t\t\t    tm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\t\t    (u_longlong_t)bytes, (u_longlong_t)blocks,\n\t\t\t    zhp->zfs_name);\n\t\t} else if (pa->pa_verbosity >= 2) {\n\t\t\tzfs_nicenum(bytes, buf, sizeof (buf));\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"%02d:%02d:%02d   %5s    %8llu    %s\\n\",\n\t\t\t    tm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\t\t    buf, (u_longlong_t)blocks, zhp->zfs_name);\n\t\t} else if (pa->pa_parsable) {\n\t\t\t(void) fprintf(stderr, \"%02d:%02d:%02d\\t%llu\\t%s\\n\",\n\t\t\t    tm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\t\t    (u_longlong_t)bytes, zhp->zfs_name);\n\t\t} else if (pa->pa_progress ||\n\t\t    !send_progress_thread_signal_duetotimer) {\n\t\t\tzfs_nicebytes(bytes, buf, sizeof (buf));\n\t\t\t(void) fprintf(stderr, \"%02d:%02d:%02d   %5s   %s\\n\",\n\t\t\t    tm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\t\t    buf, zhp->zfs_name);\n\t\t}\n\t}\n\tpthread_cleanup_pop(B_TRUE);\n}\n\nstatic boolean_t\nsend_progress_thread_exit(\n    libzfs_handle_t *hdl, pthread_t ptid, sigset_t *oldmask)\n{\n\tvoid *status = NULL;\n\t(void) pthread_cancel(ptid);\n\t(void) pthread_join(ptid, &status);\n\tpthread_sigmask(SIG_SETMASK, oldmask, NULL);\n\tint error = (int)(uintptr_t)status;\n\tif (error != 0 && status != PTHREAD_CANCELED)\n\t\treturn (zfs_standard_error(hdl, error,\n\t\t    dgettext(TEXT_DOMAIN, \"progress thread exited nonzero\")));\n\telse\n\t\treturn (B_FALSE);\n}\n\nstatic void\nsend_print_verbose(FILE *fout, const char *tosnap, const char *fromsnap,\n    uint64_t size, boolean_t parsable)\n{\n\tif (parsable) {\n\t\tif (fromsnap != NULL) {\n\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t    \"incremental\\t%s\\t%s\"), fromsnap, tosnap);\n\t\t} else {\n \n#if defined(__GNUC__) && !defined(__clang__) && \\\n\tdefined(ZFS_UBSAN_ENABLED) && defined(HAVE_FORMAT_OVERFLOW)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-overflow\"\n#endif\n\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t    \"full\\t%s\"), tosnap);\n#if defined(__GNUC__) && !defined(__clang__) && \\\n\tdefined(ZFS_UBSAN_ENABLED) && defined(HAVE_FORMAT_OVERFLOW)\n#pragma GCC diagnostic pop\n#endif\n\t\t}\n\t\t(void) fprintf(fout, \"\\t%llu\", (longlong_t)size);\n\t} else {\n\t\tif (fromsnap != NULL) {\n\t\t\tif (strchr(fromsnap, '@') == NULL &&\n\t\t\t    strchr(fromsnap, '#') == NULL) {\n\t\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"send from @%s to %s\"), fromsnap, tosnap);\n\t\t\t} else {\n\t\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"send from %s to %s\"), fromsnap, tosnap);\n\t\t\t}\n\t\t} else {\n\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t    \"full send of %s\"), tosnap);\n\t\t}\n\t\tif (size != 0) {\n\t\t\tchar buf[16];\n\t\t\tzfs_nicebytes(size, buf, sizeof (buf));\n \n#if defined(__GNUC__) && !defined(__clang__) && \\\n\tdefined(ZFS_UBSAN_ENABLED) && defined(HAVE_FORMAT_OVERFLOW)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-overflow\"\n#endif\n\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t    \" estimated size is %s\"), buf);\n#if defined(__GNUC__) && !defined(__clang__) && \\\n\tdefined(ZFS_UBSAN_ENABLED) && defined(HAVE_FORMAT_OVERFLOW)\n#pragma GCC diagnostic pop\n#endif\n\t\t}\n\t}\n\t(void) fprintf(fout, \"\\n\");\n}\n\n \nstatic int\ndump_snapshot(zfs_handle_t *zhp, void *arg)\n{\n\tsend_dump_data_t *sdd = arg;\n\tprogress_arg_t pa = { 0 };\n\tpthread_t tid;\n\tchar *thissnap;\n\tenum lzc_send_flags flags = 0;\n\tint err;\n\tboolean_t isfromsnap, istosnap, fromorigin;\n\tboolean_t exclude = B_FALSE;\n\tFILE *fout = sdd->std_out ? stdout : stderr;\n\n\terr = 0;\n\tthissnap = strchr(zhp->zfs_name, '@') + 1;\n\tisfromsnap = (sdd->fromsnap != NULL &&\n\t    strcmp(sdd->fromsnap, thissnap) == 0);\n\n\tif (!sdd->seenfrom && isfromsnap) {\n\t\tgather_holds(zhp, sdd);\n\t\tsdd->seenfrom = B_TRUE;\n\t\t(void) strlcpy(sdd->prevsnap, thissnap, sizeof (sdd->prevsnap));\n\t\tsdd->prevsnap_obj = zfs_prop_get_int(zhp, ZFS_PROP_OBJSETID);\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (sdd->seento || !sdd->seenfrom) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tistosnap = (strcmp(sdd->tosnap, thissnap) == 0);\n\tif (istosnap)\n\t\tsdd->seento = B_TRUE;\n\n\tif (sdd->large_block)\n\t\tflags |= LZC_SEND_FLAG_LARGE_BLOCK;\n\tif (sdd->embed_data)\n\t\tflags |= LZC_SEND_FLAG_EMBED_DATA;\n\tif (sdd->compress)\n\t\tflags |= LZC_SEND_FLAG_COMPRESS;\n\tif (sdd->raw)\n\t\tflags |= LZC_SEND_FLAG_RAW;\n\n\tif (!sdd->doall && !isfromsnap && !istosnap) {\n\t\tif (sdd->replicate) {\n\t\t\tconst char *snapname;\n\t\t\tnvlist_t *snapprops;\n\t\t\t \n\t\t\tnvlist_t *nvfs = fsavl_find(sdd->fsavl,\n\t\t\t    zhp->zfs_dmustats.dds_guid, &snapname);\n\n\t\t\tif (nvfs != NULL) {\n\t\t\t\tsnapprops = fnvlist_lookup_nvlist(nvfs,\n\t\t\t\t    \"snapprops\");\n\t\t\t\tsnapprops = fnvlist_lookup_nvlist(snapprops,\n\t\t\t\t    thissnap);\n\t\t\t\texclude = !nvlist_exists(snapprops,\n\t\t\t\t    \"is_clone_origin\");\n\t\t\t}\n\t\t} else {\n\t\t\texclude = B_TRUE;\n\t\t}\n\t}\n\n\t \n\tif (exclude || (sdd->filter_cb != NULL &&\n\t    sdd->filter_cb(zhp, sdd->filter_cb_arg) == B_FALSE)) {\n\t\t \n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tgather_holds(zhp, sdd);\n\tfromorigin = sdd->prevsnap[0] == '\\0' &&\n\t    (sdd->fromorigin || sdd->replicate);\n\n\tif (sdd->verbosity != 0) {\n\t\tuint64_t size = 0;\n\t\tchar fromds[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\tif (sdd->prevsnap[0] != '\\0') {\n\t\t\t(void) strlcpy(fromds, zhp->zfs_name, sizeof (fromds));\n\t\t\t*(strchr(fromds, '@') + 1) = '\\0';\n\t\t\t(void) strlcat(fromds, sdd->prevsnap, sizeof (fromds));\n\t\t}\n\t\tif (zfs_send_space(zhp, zhp->zfs_name,\n\t\t    sdd->prevsnap[0] ? fromds : NULL, flags, &size) == 0) {\n\t\t\tsend_print_verbose(fout, zhp->zfs_name,\n\t\t\t    sdd->prevsnap[0] ? sdd->prevsnap : NULL,\n\t\t\t    size, sdd->parsable);\n\t\t\tsdd->size += size;\n\t\t}\n\t}\n\n\tif (!sdd->dryrun) {\n\t\t \n\t\tsigset_t oldmask;\n\t\t{\n\t\t\tpa.pa_zhp = zhp;\n\t\t\tpa.pa_fd = sdd->outfd;\n\t\t\tpa.pa_parsable = sdd->parsable;\n\t\t\tpa.pa_estimate = B_FALSE;\n\t\t\tpa.pa_verbosity = sdd->verbosity;\n\t\t\tpa.pa_size = sdd->size;\n\t\t\tpa.pa_astitle = sdd->progressastitle;\n\t\t\tpa.pa_progress = sdd->progress;\n\n\t\t\tif ((err = pthread_create(&tid, NULL,\n\t\t\t    send_progress_thread, &pa)) != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t\tSEND_PROGRESS_THREAD_PARENT_BLOCK(&oldmask);\n\t\t}\n\n\t\terr = dump_ioctl(zhp, sdd->prevsnap, sdd->prevsnap_obj,\n\t\t    fromorigin, sdd->outfd, flags, sdd->debugnv);\n\n\t\tif (send_progress_thread_exit(zhp->zfs_hdl, tid, &oldmask))\n\t\t\treturn (-1);\n\t}\n\n\t(void) strlcpy(sdd->prevsnap, thissnap, sizeof (sdd->prevsnap));\n\tsdd->prevsnap_obj = zfs_prop_get_int(zhp, ZFS_PROP_OBJSETID);\n\tzfs_close(zhp);\n\treturn (err);\n}\n\n \nstatic int\ndump_filesystem(zfs_handle_t *zhp, send_dump_data_t *sdd)\n{\n\tint rv = 0;\n\tboolean_t missingfrom = B_FALSE;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tuint64_t min_txg = 0, max_txg = 0;\n\n\t \n\t(void) snprintf(zc.zc_name, sizeof (zc.zc_name), \"%s@%s\",\n\t    zhp->zfs_name, sdd->tosnap);\n\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_OBJSET_STATS, &zc) != 0) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t    \"WARNING: could not send %s@%s: does not exist\\n\"),\n\t\t    zhp->zfs_name, sdd->tosnap);\n\t\tsdd->err = B_TRUE;\n\t\treturn (0);\n\t}\n\n\t \n\tif (sdd->replicate && sdd->fromsnap) {\n\t\t \n\t\t(void) snprintf(zc.zc_name, sizeof (zc.zc_name), \"%s@%s\",\n\t\t    zhp->zfs_name, sdd->fromsnap);\n\t\tif (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_OBJSET_STATS, &zc) != 0)\n\t\t\tmissingfrom = B_TRUE;\n\t}\n\n\tsdd->seenfrom = sdd->seento = B_FALSE;\n\tsdd->prevsnap[0] = '\\0';\n\tsdd->prevsnap_obj = 0;\n\tif (sdd->fromsnap == NULL || missingfrom)\n\t\tsdd->seenfrom = B_TRUE;\n\n\t \n\tif (sdd->doall || sdd->replicate || sdd->tosnap == NULL) {\n\t\tif (!sdd->replicate) {\n\t\t\tif (sdd->fromsnap != NULL) {\n\t\t\t\tmin_txg = get_snap_txg(zhp->zfs_hdl,\n\t\t\t\t    zhp->zfs_name, sdd->fromsnap);\n\t\t\t}\n\t\t\tif (sdd->tosnap != NULL) {\n\t\t\t\tmax_txg = get_snap_txg(zhp->zfs_hdl,\n\t\t\t\t    zhp->zfs_name, sdd->tosnap);\n\t\t\t}\n\t\t}\n\t\trv = zfs_iter_snapshots_sorted_v2(zhp, 0, dump_snapshot, sdd,\n\t\t    min_txg, max_txg);\n\t} else {\n\t\tchar snapname[MAXPATHLEN] = { 0 };\n\t\tzfs_handle_t *snap;\n\n\t\t \n\t\tif (!sdd->seenfrom) {\n\t\t\t(void) snprintf(snapname, sizeof (snapname),\n\t\t\t    \"%s@%s\", zhp->zfs_name, sdd->fromsnap);\n\t\t\tsnap = zfs_open(zhp->zfs_hdl, snapname,\n\t\t\t    ZFS_TYPE_SNAPSHOT);\n\t\t\tif (snap != NULL)\n\t\t\t\trv = dump_snapshot(snap, sdd);\n\t\t\telse\n\t\t\t\trv = errno;\n\t\t}\n\n\t\t \n\t\tif (rv == 0) {\n\t\t\t(void) snprintf(snapname, sizeof (snapname),\n\t\t\t    \"%s@%s\", zhp->zfs_name, sdd->tosnap);\n\t\t\tsnap = zfs_open(zhp->zfs_hdl, snapname,\n\t\t\t    ZFS_TYPE_SNAPSHOT);\n\t\t\tif (snap != NULL)\n\t\t\t\trv = dump_snapshot(snap, sdd);\n\t\t\telse\n\t\t\t\trv = errno;\n\t\t}\n\t}\n\n\tif (!sdd->seenfrom) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t    \"WARNING: could not send %s@%s:\\n\"\n\t\t    \"incremental source (%s@%s) does not exist\\n\"),\n\t\t    zhp->zfs_name, sdd->tosnap,\n\t\t    zhp->zfs_name, sdd->fromsnap);\n\t\tsdd->err = B_TRUE;\n\t} else if (!sdd->seento) {\n\t\tif (sdd->fromsnap) {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"WARNING: could not send %s@%s:\\n\"\n\t\t\t    \"incremental source (%s@%s) \"\n\t\t\t    \"is not earlier than it\\n\"),\n\t\t\t    zhp->zfs_name, sdd->tosnap,\n\t\t\t    zhp->zfs_name, sdd->fromsnap);\n\t\t} else {\n\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t    \"WARNING: \"\n\t\t\t    \"could not send %s@%s: does not exist\\n\"),\n\t\t\t    zhp->zfs_name, sdd->tosnap);\n\t\t}\n\t\tsdd->err = B_TRUE;\n\t}\n\n\treturn (rv);\n}\n\n \nstatic int\ndump_filesystems(zfs_handle_t *rzhp, send_dump_data_t *sdd)\n{\n\tnvpair_t *fspair;\n\tboolean_t needagain, progress;\n\n\tif (!sdd->replicate)\n\t\treturn (dump_filesystem(rzhp, sdd));\n\n\t \n\tfor (fspair = nvlist_next_nvpair(sdd->fss, NULL); fspair;\n\t    fspair = nvlist_next_nvpair(sdd->fss, fspair)) {\n\t\tnvlist_t *nvfs;\n\t\tuint64_t origin_guid = 0;\n\n\t\tnvfs = fnvpair_value_nvlist(fspair);\n\t\t(void) nvlist_lookup_uint64(nvfs, \"origin\", &origin_guid);\n\t\tif (origin_guid != 0) {\n\t\t\tconst char *snapname;\n\t\t\tnvlist_t *origin_nv = fsavl_find(sdd->fsavl,\n\t\t\t    origin_guid, &snapname);\n\t\t\tif (origin_nv != NULL) {\n\t\t\t\tnvlist_t *snapprops;\n\t\t\t\tsnapprops = fnvlist_lookup_nvlist(origin_nv,\n\t\t\t\t    \"snapprops\");\n\t\t\t\tsnapprops = fnvlist_lookup_nvlist(snapprops,\n\t\t\t\t    snapname);\n\t\t\t\tfnvlist_add_boolean(snapprops,\n\t\t\t\t    \"is_clone_origin\");\n\t\t\t}\n\t\t}\n\t}\nagain:\n\tneedagain = progress = B_FALSE;\n\tfor (fspair = nvlist_next_nvpair(sdd->fss, NULL); fspair;\n\t    fspair = nvlist_next_nvpair(sdd->fss, fspair)) {\n\t\tnvlist_t *fslist, *parent_nv;\n\t\tconst char *fsname;\n\t\tzfs_handle_t *zhp;\n\t\tint err;\n\t\tuint64_t origin_guid = 0;\n\t\tuint64_t parent_guid = 0;\n\n\t\tfslist = fnvpair_value_nvlist(fspair);\n\t\tif (nvlist_lookup_boolean(fslist, \"sent\") == 0)\n\t\t\tcontinue;\n\n\t\tfsname = fnvlist_lookup_string(fslist, \"name\");\n\t\t(void) nvlist_lookup_uint64(fslist, \"origin\", &origin_guid);\n\t\t(void) nvlist_lookup_uint64(fslist, \"parentfromsnap\",\n\t\t    &parent_guid);\n\n\t\tif (parent_guid != 0) {\n\t\t\tparent_nv = fsavl_find(sdd->fsavl, parent_guid, NULL);\n\t\t\tif (!nvlist_exists(parent_nv, \"sent\")) {\n\t\t\t\t \n\t\t\t\tneedagain = B_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (origin_guid != 0) {\n\t\t\tnvlist_t *origin_nv = fsavl_find(sdd->fsavl,\n\t\t\t    origin_guid, NULL);\n\t\t\tif (origin_nv != NULL &&\n\t\t\t    !nvlist_exists(origin_nv, \"sent\")) {\n\t\t\t\t \n\t\t\t\tneedagain = B_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tzhp = zfs_open(rzhp->zfs_hdl, fsname, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL)\n\t\t\treturn (-1);\n\t\terr = dump_filesystem(zhp, sdd);\n\t\tfnvlist_add_boolean(fslist, \"sent\");\n\t\tprogress = B_TRUE;\n\t\tzfs_close(zhp);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\tif (needagain) {\n\t\tassert(progress);\n\t\tgoto again;\n\t}\n\n\t \n\tfor (fspair = nvlist_next_nvpair(sdd->fss, NULL); fspair;\n\t    fspair = nvlist_next_nvpair(sdd->fss, fspair)) {\n\t\tnvlist_t *fslist;\n\n\t\tfslist = fnvpair_value_nvlist(fspair);\n\t\t(void) nvlist_remove_all(fslist, \"sent\");\n\t}\n\n\treturn (0);\n}\n\nnvlist_t *\nzfs_send_resume_token_to_nvlist(libzfs_handle_t *hdl, const char *token)\n{\n\tunsigned int version;\n\tint nread, i;\n\tunsigned long long checksum, packed_len;\n\n\t \n\tnread = sscanf(token, \"%u-%llx-%llx-\",\n\t    &version, &checksum, &packed_len);\n\tif (nread != 3) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token is corrupt (invalid format)\"));\n\t\treturn (NULL);\n\t}\n\n\tif (version != ZFS_SEND_RESUME_TOKEN_VERSION) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token is corrupt (invalid version %u)\"),\n\t\t    version);\n\t\treturn (NULL);\n\t}\n\n\t \n\ttoken = strrchr(token, '-') + 1;\n\tint len = strlen(token) / 2;\n\tunsigned char *compressed = zfs_alloc(hdl, len);\n\tfor (i = 0; i < len; i++) {\n\t\tnread = sscanf(token + i * 2, \"%2hhx\", compressed + i);\n\t\tif (nread != 1) {\n\t\t\tfree(compressed);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"resume token is corrupt \"\n\t\t\t    \"(payload is not hex-encoded)\"));\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t \n\tzio_cksum_t cksum;\n\tfletcher_4_native_varsize(compressed, len, &cksum);\n\tif (cksum.zc_word[0] != checksum) {\n\t\tfree(compressed);\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token is corrupt (incorrect checksum)\"));\n\t\treturn (NULL);\n\t}\n\n\t \n\tvoid *packed = zfs_alloc(hdl, packed_len);\n\tuLongf packed_len_long = packed_len;\n\tif (uncompress(packed, &packed_len_long, compressed, len) != Z_OK ||\n\t    packed_len_long != packed_len) {\n\t\tfree(packed);\n\t\tfree(compressed);\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token is corrupt (decompression failed)\"));\n\t\treturn (NULL);\n\t}\n\n\t \n\tnvlist_t *nv;\n\tint error = nvlist_unpack(packed, packed_len, &nv, KM_SLEEP);\n\tfree(packed);\n\tfree(compressed);\n\tif (error != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token is corrupt (nvlist_unpack failed)\"));\n\t\treturn (NULL);\n\t}\n\treturn (nv);\n}\n\nstatic enum lzc_send_flags\nlzc_flags_from_sendflags(const sendflags_t *flags)\n{\n\tenum lzc_send_flags lzc_flags = 0;\n\n\tif (flags->largeblock)\n\t\tlzc_flags |= LZC_SEND_FLAG_LARGE_BLOCK;\n\tif (flags->embed_data)\n\t\tlzc_flags |= LZC_SEND_FLAG_EMBED_DATA;\n\tif (flags->compress)\n\t\tlzc_flags |= LZC_SEND_FLAG_COMPRESS;\n\tif (flags->raw)\n\t\tlzc_flags |= LZC_SEND_FLAG_RAW;\n\tif (flags->saved)\n\t\tlzc_flags |= LZC_SEND_FLAG_SAVED;\n\n\treturn (lzc_flags);\n}\n\nstatic int\nestimate_size(zfs_handle_t *zhp, const char *from, int fd, sendflags_t *flags,\n    uint64_t resumeobj, uint64_t resumeoff, uint64_t bytes,\n    const char *redactbook, char *errbuf, uint64_t *sizep)\n{\n\tuint64_t size;\n\tFILE *fout = flags->dryrun ? stdout : stderr;\n\tprogress_arg_t pa = { 0 };\n\tint err = 0;\n\tpthread_t ptid;\n\tsigset_t oldmask;\n\n\t{\n\t\tpa.pa_zhp = zhp;\n\t\tpa.pa_fd = fd;\n\t\tpa.pa_parsable = flags->parsable;\n\t\tpa.pa_estimate = B_TRUE;\n\t\tpa.pa_verbosity = flags->verbosity;\n\n\t\terr = pthread_create(&ptid, NULL,\n\t\t    send_progress_thread, &pa);\n\t\tif (err != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(errno));\n\t\t\treturn (zfs_error(zhp->zfs_hdl,\n\t\t\t    EZFS_THREADCREATEFAILED, errbuf));\n\t\t}\n\t\tSEND_PROGRESS_THREAD_PARENT_BLOCK(&oldmask);\n\t}\n\n\terr = lzc_send_space_resume_redacted(zhp->zfs_name, from,\n\t    lzc_flags_from_sendflags(flags), resumeobj, resumeoff, bytes,\n\t    redactbook, fd, &size);\n\t*sizep = size;\n\n\tif (send_progress_thread_exit(zhp->zfs_hdl, ptid, &oldmask))\n\t\treturn (-1);\n\n\tif (!flags->progress && !flags->parsable)\n\t\treturn (err);\n\n\tif (err != 0) {\n\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(err));\n\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_BADBACKUP,\n\t\t    errbuf));\n\t}\n\tsend_print_verbose(fout, zhp->zfs_name, from, size,\n\t    flags->parsable);\n\n\tif (flags->parsable) {\n\t\t(void) fprintf(fout, \"size\\t%llu\\n\", (longlong_t)size);\n\t} else {\n\t\tchar buf[16];\n\t\tzfs_nicenum(size, buf, sizeof (buf));\n\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t    \"total estimated size is %s\\n\"), buf);\n\t}\n\treturn (0);\n}\n\nstatic boolean_t\nredact_snaps_contains(const uint64_t *snaps, uint64_t num_snaps, uint64_t guid)\n{\n\tfor (int i = 0; i < num_snaps; i++) {\n\t\tif (snaps[i] == guid)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\nstatic boolean_t\nredact_snaps_equal(const uint64_t *snaps1, uint64_t num_snaps1,\n    const uint64_t *snaps2, uint64_t num_snaps2)\n{\n\tif (num_snaps1 != num_snaps2)\n\t\treturn (B_FALSE);\n\tfor (int i = 0; i < num_snaps1; i++) {\n\t\tif (!redact_snaps_contains(snaps2, num_snaps2, snaps1[i]))\n\t\t\treturn (B_FALSE);\n\t}\n\treturn (B_TRUE);\n}\n\nstatic int\nget_bookmarks(const char *path, nvlist_t **bmarksp)\n{\n\tnvlist_t *props = fnvlist_alloc();\n\tint error;\n\n\tfnvlist_add_boolean(props, \"redact_complete\");\n\tfnvlist_add_boolean(props, zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS));\n\terror = lzc_get_bookmarks(path, props, bmarksp);\n\tfnvlist_free(props);\n\treturn (error);\n}\n\nstatic nvpair_t *\nfind_redact_pair(nvlist_t *bmarks, const uint64_t *redact_snap_guids,\n    int num_redact_snaps)\n{\n\tnvpair_t *pair;\n\n\tfor (pair = nvlist_next_nvpair(bmarks, NULL); pair;\n\t    pair = nvlist_next_nvpair(bmarks, pair)) {\n\n\t\tnvlist_t *bmark = fnvpair_value_nvlist(pair);\n\t\tnvlist_t *vallist = fnvlist_lookup_nvlist(bmark,\n\t\t    zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS));\n\t\tuint_t len = 0;\n\t\tuint64_t *bmarksnaps = fnvlist_lookup_uint64_array(vallist,\n\t\t    ZPROP_VALUE, &len);\n\t\tif (redact_snaps_equal(redact_snap_guids,\n\t\t    num_redact_snaps, bmarksnaps, len)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (pair);\n}\n\nstatic boolean_t\nget_redact_complete(nvpair_t *pair)\n{\n\tnvlist_t *bmark = fnvpair_value_nvlist(pair);\n\tnvlist_t *vallist = fnvlist_lookup_nvlist(bmark, \"redact_complete\");\n\tboolean_t complete = fnvlist_lookup_boolean_value(vallist,\n\t    ZPROP_VALUE);\n\n\treturn (complete);\n}\n\n \nstatic int\nfind_redact_book(libzfs_handle_t *hdl, const char *path,\n    const uint64_t *redact_snap_guids, int num_redact_snaps,\n    char **bookname)\n{\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *bmarks;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot resume send\"));\n\n\tint error = get_bookmarks(path, &bmarks);\n\tif (error != 0) {\n\t\tif (error == ESRCH) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"nonexistent redaction bookmark provided\"));\n\t\t} else if (error == ENOENT) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"dataset to be sent no longer exists\"));\n\t\t} else {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"unknown error: %s\"), strerror(error));\n\t\t}\n\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t}\n\tnvpair_t *pair = find_redact_pair(bmarks, redact_snap_guids,\n\t    num_redact_snaps);\n\tif (pair == NULL)  {\n\t\tfnvlist_free(bmarks);\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"no appropriate redaction bookmark exists\"));\n\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t}\n\tboolean_t complete = get_redact_complete(pair);\n\tif (!complete) {\n\t\tfnvlist_free(bmarks);\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"incomplete redaction bookmark provided\"));\n\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\t}\n\t*bookname = strndup(nvpair_name(pair), ZFS_MAX_DATASET_NAME_LEN);\n\tASSERT3P(*bookname, !=, NULL);\n\tfnvlist_free(bmarks);\n\treturn (0);\n}\n\nstatic enum lzc_send_flags\nlzc_flags_from_resume_nvl(nvlist_t *resume_nvl)\n{\n\tenum lzc_send_flags lzc_flags = 0;\n\n\tif (nvlist_exists(resume_nvl, \"largeblockok\"))\n\t\tlzc_flags |= LZC_SEND_FLAG_LARGE_BLOCK;\n\tif (nvlist_exists(resume_nvl, \"embedok\"))\n\t\tlzc_flags |= LZC_SEND_FLAG_EMBED_DATA;\n\tif (nvlist_exists(resume_nvl, \"compressok\"))\n\t\tlzc_flags |= LZC_SEND_FLAG_COMPRESS;\n\tif (nvlist_exists(resume_nvl, \"rawok\"))\n\t\tlzc_flags |= LZC_SEND_FLAG_RAW;\n\tif (nvlist_exists(resume_nvl, \"savedok\"))\n\t\tlzc_flags |= LZC_SEND_FLAG_SAVED;\n\n\treturn (lzc_flags);\n}\n\nstatic int\nzfs_send_resume_impl_cb_impl(libzfs_handle_t *hdl, sendflags_t *flags,\n    int outfd, nvlist_t *resume_nvl)\n{\n\tchar errbuf[ERRBUFLEN];\n\tconst char *toname;\n\tconst char *fromname = NULL;\n\tuint64_t resumeobj, resumeoff, toguid, fromguid, bytes;\n\tzfs_handle_t *zhp;\n\tint error = 0;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tFILE *fout = (flags->verbosity > 0 && flags->dryrun) ? stdout : stderr;\n\tuint64_t *redact_snap_guids = NULL;\n\tint num_redact_snaps = 0;\n\tchar *redact_book = NULL;\n\tuint64_t size = 0;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot resume send\"));\n\n\tif (flags->verbosity != 0) {\n\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token contents:\\n\"));\n\t\tnvlist_print(fout, resume_nvl);\n\t}\n\n\tif (nvlist_lookup_string(resume_nvl, \"toname\", &toname) != 0 ||\n\t    nvlist_lookup_uint64(resume_nvl, \"object\", &resumeobj) != 0 ||\n\t    nvlist_lookup_uint64(resume_nvl, \"offset\", &resumeoff) != 0 ||\n\t    nvlist_lookup_uint64(resume_nvl, \"bytes\", &bytes) != 0 ||\n\t    nvlist_lookup_uint64(resume_nvl, \"toguid\", &toguid) != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"resume token is corrupt\"));\n\t\treturn (zfs_error(hdl, EZFS_FAULT, errbuf));\n\t}\n\tfromguid = 0;\n\t(void) nvlist_lookup_uint64(resume_nvl, \"fromguid\", &fromguid);\n\n\tif (flags->saved) {\n\t\t(void) strlcpy(name, toname, sizeof (name));\n\t} else {\n\t\terror = guid_to_name(hdl, toname, toguid, B_FALSE, name);\n\t\tif (error != 0) {\n\t\t\tif (zfs_dataset_exists(hdl, toname, ZFS_TYPE_DATASET)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' is no longer the same snapshot \"\n\t\t\t\t    \"used in the initial send\"), toname);\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"'%s' used in the initial send no \"\n\t\t\t\t    \"longer exists\"), toname);\n\t\t\t}\n\t\t\treturn (zfs_error(hdl, EZFS_BADPATH, errbuf));\n\t\t}\n\t}\n\n\tzhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);\n\tif (zhp == NULL) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"unable to access '%s'\"), name);\n\t\treturn (zfs_error(hdl, EZFS_BADPATH, errbuf));\n\t}\n\n\tif (nvlist_lookup_uint64_array(resume_nvl, \"book_redact_snaps\",\n\t    &redact_snap_guids, (uint_t *)&num_redact_snaps) != 0) {\n\t\tnum_redact_snaps = -1;\n\t}\n\n\tif (fromguid != 0) {\n\t\tif (guid_to_name_redact_snaps(hdl, toname, fromguid, B_TRUE,\n\t\t    redact_snap_guids, num_redact_snaps, name) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"incremental source %#llx no longer exists\"),\n\t\t\t    (longlong_t)fromguid);\n\t\t\treturn (zfs_error(hdl, EZFS_BADPATH, errbuf));\n\t\t}\n\t\tfromname = name;\n\t}\n\n\tredact_snap_guids = NULL;\n\n\tif (nvlist_lookup_uint64_array(resume_nvl,\n\t    zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS), &redact_snap_guids,\n\t    (uint_t *)&num_redact_snaps) == 0) {\n\t\tchar path[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\t(void) strlcpy(path, toname, sizeof (path));\n\t\tchar *at = strchr(path, '@');\n\t\tASSERT3P(at, !=, NULL);\n\n\t\t*at = '\\0';\n\n\t\tif ((error = find_redact_book(hdl, path, redact_snap_guids,\n\t\t    num_redact_snaps, &redact_book)) != 0) {\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tenum lzc_send_flags lzc_flags = lzc_flags_from_sendflags(flags) |\n\t    lzc_flags_from_resume_nvl(resume_nvl);\n\n\tif (flags->verbosity != 0 || flags->progressastitle) {\n\t\t \n\t\tsendflags_t tmpflags = *flags;\n\t\tif (lzc_flags & LZC_SEND_FLAG_LARGE_BLOCK)\n\t\t\ttmpflags.largeblock = B_TRUE;\n\t\tif (lzc_flags & LZC_SEND_FLAG_COMPRESS)\n\t\t\ttmpflags.compress = B_TRUE;\n\t\tif (lzc_flags & LZC_SEND_FLAG_EMBED_DATA)\n\t\t\ttmpflags.embed_data = B_TRUE;\n\t\tif (lzc_flags & LZC_SEND_FLAG_RAW)\n\t\t\ttmpflags.raw = B_TRUE;\n\t\tif (lzc_flags & LZC_SEND_FLAG_SAVED)\n\t\t\ttmpflags.saved = B_TRUE;\n\t\terror = estimate_size(zhp, fromname, outfd, &tmpflags,\n\t\t    resumeobj, resumeoff, bytes, redact_book, errbuf, &size);\n\t}\n\n\tif (!flags->dryrun) {\n\t\tprogress_arg_t pa = { 0 };\n\t\tpthread_t tid;\n\t\tsigset_t oldmask;\n\t\t \n\t\t{\n\t\t\tpa.pa_zhp = zhp;\n\t\t\tpa.pa_fd = outfd;\n\t\t\tpa.pa_parsable = flags->parsable;\n\t\t\tpa.pa_estimate = B_FALSE;\n\t\t\tpa.pa_verbosity = flags->verbosity;\n\t\t\tpa.pa_size = size;\n\t\t\tpa.pa_astitle = flags->progressastitle;\n\t\t\tpa.pa_progress = flags->progress;\n\n\t\t\terror = pthread_create(&tid, NULL,\n\t\t\t    send_progress_thread, &pa);\n\t\t\tif (error != 0) {\n\t\t\t\tif (redact_book != NULL)\n\t\t\t\t\tfree(redact_book);\n\t\t\t\tzfs_close(zhp);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tSEND_PROGRESS_THREAD_PARENT_BLOCK(&oldmask);\n\t\t}\n\n\t\terror = lzc_send_resume_redacted(zhp->zfs_name, fromname, outfd,\n\t\t    lzc_flags, resumeobj, resumeoff, redact_book);\n\t\tif (redact_book != NULL)\n\t\t\tfree(redact_book);\n\n\t\tif (send_progress_thread_exit(hdl, tid, &oldmask)) {\n\t\t\tzfs_close(zhp);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tchar errbuf[ERRBUFLEN];\n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"warning: cannot send '%s'\"), zhp->zfs_name);\n\n\t\tzfs_close(zhp);\n\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\treturn (0);\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"source key must be loaded\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\t\tcase ESRCH:\n\t\t\tif (lzc_exists(zhp->zfs_name)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"incremental source could not be found\"));\n\t\t\t}\n\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\n\t\tcase EXDEV:\n\t\tcase ENOENT:\n\t\tcase EDQUOT:\n\t\tcase EFBIG:\n\t\tcase EIO:\n\t\tcase ENOLINK:\n\t\tcase ENOSPC:\n\t\tcase ENOSTR:\n\t\tcase ENXIO:\n\t\tcase EPIPE:\n\t\tcase ERANGE:\n\t\tcase EFAULT:\n\t\tcase EROFS:\n\t\t\tzfs_error_aux(hdl, \"%s\", strerror(errno));\n\t\t\treturn (zfs_error(hdl, EZFS_BADBACKUP, errbuf));\n\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t\t}\n\t} else {\n\t\tif (redact_book != NULL)\n\t\t\tfree(redact_book);\n\t}\n\n\tzfs_close(zhp);\n\n\treturn (error);\n}\n\nstruct zfs_send_resume_impl {\n\tlibzfs_handle_t *hdl;\n\tsendflags_t *flags;\n\tnvlist_t *resume_nvl;\n};\n\nstatic int\nzfs_send_resume_impl_cb(int outfd, void *arg)\n{\n\tstruct zfs_send_resume_impl *zsri = arg;\n\treturn (zfs_send_resume_impl_cb_impl(zsri->hdl, zsri->flags, outfd,\n\t    zsri->resume_nvl));\n}\n\nstatic int\nzfs_send_resume_impl(libzfs_handle_t *hdl, sendflags_t *flags, int outfd,\n    nvlist_t *resume_nvl)\n{\n\tstruct zfs_send_resume_impl zsri = {\n\t\t.hdl = hdl,\n\t\t.flags = flags,\n\t\t.resume_nvl = resume_nvl,\n\t};\n\treturn (lzc_send_wrapper(zfs_send_resume_impl_cb, outfd, &zsri));\n}\n\nint\nzfs_send_resume(libzfs_handle_t *hdl, sendflags_t *flags, int outfd,\n    const char *resume_token)\n{\n\tint ret;\n\tchar errbuf[ERRBUFLEN];\n\tnvlist_t *resume_nvl;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot resume send\"));\n\n\tresume_nvl = zfs_send_resume_token_to_nvlist(hdl, resume_token);\n\tif (resume_nvl == NULL) {\n\t\t \n\t\treturn (zfs_error(hdl, EZFS_FAULT, errbuf));\n\t}\n\n\tret = zfs_send_resume_impl(hdl, flags, outfd, resume_nvl);\n\tfnvlist_free(resume_nvl);\n\n\treturn (ret);\n}\n\nint\nzfs_send_saved(zfs_handle_t *zhp, sendflags_t *flags, int outfd,\n    const char *resume_token)\n{\n\tint ret;\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tnvlist_t *saved_nvl = NULL, *resume_nvl = NULL;\n\tuint64_t saved_guid = 0, resume_guid = 0;\n\tuint64_t obj = 0, off = 0, bytes = 0;\n\tchar token_buf[ZFS_MAXPROPLEN];\n\tchar errbuf[ERRBUFLEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"saved send failed\"));\n\n\tret = zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN,\n\t    token_buf, sizeof (token_buf), NULL, NULL, 0, B_TRUE);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tsaved_nvl = zfs_send_resume_token_to_nvlist(hdl, token_buf);\n\tif (saved_nvl == NULL) {\n\t\t \n\t\tret = zfs_error(hdl, EZFS_FAULT, errbuf);\n\t\tgoto out;\n\t}\n\n\t \n\tif (resume_token != NULL) {\n\t\tresume_nvl = zfs_send_resume_token_to_nvlist(hdl,\n\t\t    resume_token);\n\t\tif (resume_nvl == NULL) {\n\t\t\tret = zfs_error(hdl, EZFS_FAULT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (nvlist_lookup_uint64(resume_nvl, \"object\", &obj) != 0 ||\n\t\t    nvlist_lookup_uint64(resume_nvl, \"offset\", &off) != 0 ||\n\t\t    nvlist_lookup_uint64(resume_nvl, \"bytes\", &bytes) != 0 ||\n\t\t    nvlist_lookup_uint64(resume_nvl, \"toguid\",\n\t\t    &resume_guid) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"provided resume token is corrupt\"));\n\t\t\tret = zfs_error(hdl, EZFS_FAULT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (nvlist_lookup_uint64(saved_nvl, \"toguid\",\n\t\t    &saved_guid)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"dataset's resume token is corrupt\"));\n\t\t\tret = zfs_error(hdl, EZFS_FAULT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (resume_guid != saved_guid) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"provided resume token does not match dataset\"));\n\t\t\tret = zfs_error(hdl, EZFS_BADBACKUP, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t(void) nvlist_remove_all(saved_nvl, \"object\");\n\tfnvlist_add_uint64(saved_nvl, \"object\", obj);\n\n\t(void) nvlist_remove_all(saved_nvl, \"offset\");\n\tfnvlist_add_uint64(saved_nvl, \"offset\", off);\n\n\t(void) nvlist_remove_all(saved_nvl, \"bytes\");\n\tfnvlist_add_uint64(saved_nvl, \"bytes\", bytes);\n\n\t(void) nvlist_remove_all(saved_nvl, \"toname\");\n\tfnvlist_add_string(saved_nvl, \"toname\", zhp->zfs_name);\n\n\tret = zfs_send_resume_impl(hdl, flags, outfd, saved_nvl);\n\nout:\n\tfnvlist_free(saved_nvl);\n\tfnvlist_free(resume_nvl);\n\treturn (ret);\n}\n\n \nstatic int\nsend_conclusion_record(int fd, zio_cksum_t *zc)\n{\n\tdmu_replay_record_t drr = { 0 };\n\tdrr.drr_type = DRR_END;\n\tif (zc != NULL)\n\t\tdrr.drr_u.drr_end.drr_checksum = *zc;\n\tif (write(fd, &drr, sizeof (drr)) == -1) {\n\t\treturn (errno);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nsend_prelim_records(zfs_handle_t *zhp, const char *from, int fd,\n    boolean_t gather_props, boolean_t recursive, boolean_t verbose,\n    boolean_t dryrun, boolean_t raw, boolean_t replicate, boolean_t skipmissing,\n    boolean_t backup, boolean_t holds, boolean_t props, boolean_t doall,\n    nvlist_t **fssp, avl_tree_t **fsavlp)\n{\n\tint err = 0;\n\tchar *packbuf = NULL;\n\tsize_t buflen = 0;\n\tzio_cksum_t zc = { {0} };\n\tint featureflags = 0;\n\t \n\tchar tofs[ZFS_MAX_DATASET_NAME_LEN];\n\t \n\tconst char *tosnap = \"\";\n\n\tchar errbuf[ERRBUFLEN];\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"warning: cannot send '%s'\"), zhp->zfs_name);\n\tif (zhp->zfs_type == ZFS_TYPE_FILESYSTEM && zfs_prop_get_int(zhp,\n\t    ZFS_PROP_VERSION) >= ZPL_VERSION_SA) {\n\t\tfeatureflags |= DMU_BACKUP_FEATURE_SA_SPILL;\n\t}\n\n\tif (holds)\n\t\tfeatureflags |= DMU_BACKUP_FEATURE_HOLDS;\n\n\t(void) strlcpy(tofs, zhp->zfs_name, ZFS_MAX_DATASET_NAME_LEN);\n\tchar *at = strchr(tofs, '@');\n\tif (at != NULL) {\n\t\t*at = '\\0';\n\t\ttosnap = at + 1;\n\t}\n\n\tif (gather_props) {\n\t\tnvlist_t *hdrnv = fnvlist_alloc();\n\t\tnvlist_t *fss = NULL;\n\n\t\tif (from != NULL)\n\t\t\tfnvlist_add_string(hdrnv, \"fromsnap\", from);\n\t\tfnvlist_add_string(hdrnv, \"tosnap\", tosnap);\n\t\tif (!recursive)\n\t\t\tfnvlist_add_boolean(hdrnv, \"not_recursive\");\n\n\t\tif (raw) {\n\t\t\tfnvlist_add_boolean(hdrnv, \"raw\");\n\t\t}\n\n\t\tif (gather_nvlist(zhp->zfs_hdl, tofs,\n\t\t    from, tosnap, recursive, raw, doall, replicate, skipmissing,\n\t\t    verbose, backup, holds, props, &fss, fsavlp) != 0) {\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_BADBACKUP,\n\t\t\t    errbuf));\n\t\t}\n\t\t \n\t\tif ((fnvlist_size(fss) + fnvlist_size(hdrnv)) >\n\t\t    zhp->zfs_hdl->libzfs_max_nvlist) {\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN, \"warning: cannot send '%s': \"\n\t\t\t    \"the size of the list of snapshots and properties \"\n\t\t\t    \"is too large to be received successfully.\\n\"\n\t\t\t    \"Select a smaller number of snapshots to send.\\n\"),\n\t\t\t    zhp->zfs_name);\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_NOSPC,\n\t\t\t    errbuf));\n\t\t}\n\t\tfnvlist_add_nvlist(hdrnv, \"fss\", fss);\n\t\tVERIFY0(nvlist_pack(hdrnv, &packbuf, &buflen, NV_ENCODE_XDR,\n\t\t    0));\n\t\tif (fssp != NULL) {\n\t\t\t*fssp = fss;\n\t\t} else {\n\t\t\tfnvlist_free(fss);\n\t\t}\n\t\tfnvlist_free(hdrnv);\n\t}\n\n\tif (!dryrun) {\n\t\tdmu_replay_record_t drr = { 0 };\n\t\t \n\t\tdrr.drr_type = DRR_BEGIN;\n\t\tdrr.drr_u.drr_begin.drr_magic = DMU_BACKUP_MAGIC;\n\t\tDMU_SET_STREAM_HDRTYPE(drr.drr_u.drr_begin.\n\t\t    drr_versioninfo, DMU_COMPOUNDSTREAM);\n\t\tDMU_SET_FEATUREFLAGS(drr.drr_u.drr_begin.\n\t\t    drr_versioninfo, featureflags);\n\t\tif (snprintf(drr.drr_u.drr_begin.drr_toname,\n\t\t    sizeof (drr.drr_u.drr_begin.drr_toname), \"%s@%s\", tofs,\n\t\t    tosnap) >= sizeof (drr.drr_u.drr_begin.drr_toname)) {\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_BADBACKUP,\n\t\t\t    errbuf));\n\t\t}\n\t\tdrr.drr_payloadlen = buflen;\n\n\t\terr = dump_record(&drr, packbuf, buflen, &zc, fd);\n\t\tfree(packbuf);\n\t\tif (err != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(err));\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_BADBACKUP,\n\t\t\t    errbuf));\n\t\t}\n\t\terr = send_conclusion_record(fd, &zc);\n\t\tif (err != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(err));\n\t\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_BADBACKUP,\n\t\t\t    errbuf));\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nstatic int\nzfs_send_cb_impl(zfs_handle_t *zhp, const char *fromsnap, const char *tosnap,\n    sendflags_t *flags, int outfd, snapfilter_cb_t filter_func,\n    void *cb_arg, nvlist_t **debugnvp)\n{\n\tchar errbuf[ERRBUFLEN];\n\tsend_dump_data_t sdd = { 0 };\n\tint err = 0;\n\tnvlist_t *fss = NULL;\n\tavl_tree_t *fsavl = NULL;\n\tstatic uint64_t holdseq;\n\tint spa_version;\n\tFILE *fout;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot send '%s'\"), zhp->zfs_name);\n\n\tif (fromsnap && fromsnap[0] == '\\0') {\n\t\tzfs_error_aux(zhp->zfs_hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"zero-length incremental source\"));\n\t\treturn (zfs_error(zhp->zfs_hdl, EZFS_NOENT, errbuf));\n\t}\n\n\tif (fromsnap) {\n\t\tchar full_fromsnap_name[ZFS_MAX_DATASET_NAME_LEN];\n\t\tif (snprintf(full_fromsnap_name, sizeof (full_fromsnap_name),\n\t\t    \"%s@%s\", zhp->zfs_name, fromsnap) >=\n\t\t    sizeof (full_fromsnap_name)) {\n\t\t\terr = EINVAL;\n\t\t\tgoto stderr_out;\n\t\t}\n\t\tzfs_handle_t *fromsnapn = zfs_open(zhp->zfs_hdl,\n\t\t    full_fromsnap_name, ZFS_TYPE_SNAPSHOT);\n\t\tif (fromsnapn == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto err_out;\n\t\t}\n\t\tzfs_close(fromsnapn);\n\t}\n\n\tif (flags->replicate || flags->doall || flags->props ||\n\t    flags->holds || flags->backup) {\n\t\tchar full_tosnap_name[ZFS_MAX_DATASET_NAME_LEN];\n\t\tif (snprintf(full_tosnap_name, sizeof (full_tosnap_name),\n\t\t    \"%s@%s\", zhp->zfs_name, tosnap) >=\n\t\t    sizeof (full_tosnap_name)) {\n\t\t\terr = EINVAL;\n\t\t\tgoto stderr_out;\n\t\t}\n\t\tzfs_handle_t *tosnap = zfs_open(zhp->zfs_hdl,\n\t\t    full_tosnap_name, ZFS_TYPE_SNAPSHOT);\n\t\tif (tosnap == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = send_prelim_records(tosnap, fromsnap, outfd,\n\t\t    flags->replicate || flags->props || flags->holds,\n\t\t    flags->replicate, flags->verbosity > 0, flags->dryrun,\n\t\t    flags->raw, flags->replicate, flags->skipmissing,\n\t\t    flags->backup, flags->holds, flags->props, flags->doall,\n\t\t    &fss, &fsavl);\n\t\tzfs_close(tosnap);\n\t\tif (err != 0)\n\t\t\tgoto err_out;\n\t}\n\n\t \n\tsdd.fromsnap = fromsnap;\n\tsdd.tosnap = tosnap;\n\tsdd.outfd = outfd;\n\tsdd.replicate = flags->replicate;\n\tsdd.doall = flags->doall;\n\tsdd.fromorigin = flags->fromorigin;\n\tsdd.fss = fss;\n\tsdd.fsavl = fsavl;\n\tsdd.verbosity = flags->verbosity;\n\tsdd.parsable = flags->parsable;\n\tsdd.progress = flags->progress;\n\tsdd.progressastitle = flags->progressastitle;\n\tsdd.dryrun = flags->dryrun;\n\tsdd.large_block = flags->largeblock;\n\tsdd.embed_data = flags->embed_data;\n\tsdd.compress = flags->compress;\n\tsdd.raw = flags->raw;\n\tsdd.holds = flags->holds;\n\tsdd.filter_cb = filter_func;\n\tsdd.filter_cb_arg = cb_arg;\n\tif (debugnvp)\n\t\tsdd.debugnv = *debugnvp;\n\tif (sdd.verbosity != 0 && sdd.dryrun)\n\t\tsdd.std_out = B_TRUE;\n\tfout = sdd.std_out ? stdout : stderr;\n\n\t \n\tif (!flags->dryrun && !zpool_get_prop_int(zfs_get_pool_handle(zhp),\n\t    ZPOOL_PROP_READONLY, NULL) &&\n\t    zfs_spa_version(zhp, &spa_version) == 0 &&\n\t    spa_version >= SPA_VERSION_USERREFS &&\n\t    (flags->doall || flags->replicate)) {\n\t\t++holdseq;\n\t\t(void) snprintf(sdd.holdtag, sizeof (sdd.holdtag),\n\t\t    \".send-%d-%llu\", getpid(), (u_longlong_t)holdseq);\n\t\tsdd.cleanup_fd = open(ZFS_DEV, O_RDWR | O_CLOEXEC);\n\t\tif (sdd.cleanup_fd < 0) {\n\t\t\terr = errno;\n\t\t\tgoto stderr_out;\n\t\t}\n\t\tsdd.snapholds = fnvlist_alloc();\n\t} else {\n\t\tsdd.cleanup_fd = -1;\n\t\tsdd.snapholds = NULL;\n\t}\n\n\tif (flags->verbosity != 0 || sdd.snapholds != NULL) {\n\t\t \n\t\tsdd.dryrun = B_TRUE;\n\t\terr = dump_filesystems(zhp, &sdd);\n\n\t\tif (err != 0)\n\t\t\tgoto stderr_out;\n\n\t\tif (flags->verbosity != 0) {\n\t\t\tif (flags->parsable) {\n\t\t\t\t(void) fprintf(fout, \"size\\t%llu\\n\",\n\t\t\t\t    (longlong_t)sdd.size);\n\t\t\t} else {\n\t\t\t\tchar buf[16];\n\t\t\t\tzfs_nicebytes(sdd.size, buf, sizeof (buf));\n\t\t\t\t(void) fprintf(fout, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"total estimated size is %s\\n\"), buf);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!sdd.seento) {\n\t\t\terr = ENOENT;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tif (flags->dryrun)\n\t\t\tgoto err_out;\n\n\t\tif (sdd.snapholds != NULL) {\n\t\t\terr = zfs_hold_nvl(zhp, sdd.cleanup_fd, sdd.snapholds);\n\t\t\tif (err != 0)\n\t\t\t\tgoto stderr_out;\n\n\t\t\tfnvlist_free(sdd.snapholds);\n\t\t\tsdd.snapholds = NULL;\n\t\t}\n\n\t\tsdd.dryrun = B_FALSE;\n\t\tsdd.verbosity = 0;\n\t}\n\n\terr = dump_filesystems(zhp, &sdd);\n\tfsavl_destroy(fsavl);\n\tfnvlist_free(fss);\n\n\t \n\tif (err == 0 && !sdd.seento)\n\t\terr = ENOENT;\n\n\tif (sdd.cleanup_fd != -1) {\n\t\tVERIFY(0 == close(sdd.cleanup_fd));\n\t\tsdd.cleanup_fd = -1;\n\t}\n\n\tif (!flags->dryrun && (flags->replicate || flags->doall ||\n\t    flags->props || flags->backup || flags->holds)) {\n\t\t \n\t\tint err2 = send_conclusion_record(outfd, NULL);\n\t\tif (err2 != 0)\n\t\t\treturn (zfs_standard_error(zhp->zfs_hdl, err2, errbuf));\n\t}\n\n\treturn (err || sdd.err);\n\nstderr_out:\n\terr = zfs_standard_error(zhp->zfs_hdl, err, errbuf);\nerr_out:\n\tfsavl_destroy(fsavl);\n\tfnvlist_free(fss);\n\tfnvlist_free(sdd.snapholds);\n\n\tif (sdd.cleanup_fd != -1)\n\t\tVERIFY(0 == close(sdd.cleanup_fd));\n\treturn (err);\n}\n\nstruct zfs_send {\n\tzfs_handle_t *zhp;\n\tconst char *fromsnap;\n\tconst char *tosnap;\n\tsendflags_t *flags;\n\tsnapfilter_cb_t *filter_func;\n\tvoid *cb_arg;\n\tnvlist_t **debugnvp;\n};\n\nstatic int\nzfs_send_cb(int outfd, void *arg)\n{\n\tstruct zfs_send *zs = arg;\n\treturn (zfs_send_cb_impl(zs->zhp, zs->fromsnap, zs->tosnap, zs->flags,\n\t    outfd, zs->filter_func, zs->cb_arg, zs->debugnvp));\n}\n\nint\nzfs_send(zfs_handle_t *zhp, const char *fromsnap, const char *tosnap,\n    sendflags_t *flags, int outfd, snapfilter_cb_t filter_func,\n    void *cb_arg, nvlist_t **debugnvp)\n{\n\tstruct zfs_send arg = {\n\t\t.zhp = zhp,\n\t\t.fromsnap = fromsnap,\n\t\t.tosnap = tosnap,\n\t\t.flags = flags,\n\t\t.filter_func = filter_func,\n\t\t.cb_arg = cb_arg,\n\t\t.debugnvp = debugnvp,\n\t};\n\treturn (lzc_send_wrapper(zfs_send_cb, outfd, &arg));\n}\n\n\nstatic zfs_handle_t *\nname_to_dir_handle(libzfs_handle_t *hdl, const char *snapname)\n{\n\tchar dirname[ZFS_MAX_DATASET_NAME_LEN];\n\t(void) strlcpy(dirname, snapname, ZFS_MAX_DATASET_NAME_LEN);\n\tchar *c = strchr(dirname, '@');\n\tif (c != NULL)\n\t\t*c = '\\0';\n\treturn (zfs_open(hdl, dirname, ZFS_TYPE_DATASET));\n}\n\n \nstatic boolean_t\nsnapshot_is_before(zfs_handle_t *earlier, zfs_handle_t *later)\n{\n\tboolean_t ret;\n\tuint64_t later_txg =\n\t    (later->zfs_type == ZFS_TYPE_FILESYSTEM ||\n\t    later->zfs_type == ZFS_TYPE_VOLUME ?\n\t    UINT64_MAX : zfs_prop_get_int(later, ZFS_PROP_CREATETXG));\n\tuint64_t earlier_txg = zfs_prop_get_int(earlier, ZFS_PROP_CREATETXG);\n\n\tif (earlier_txg >= later_txg)\n\t\treturn (B_FALSE);\n\n\tzfs_handle_t *earlier_dir = name_to_dir_handle(earlier->zfs_hdl,\n\t    earlier->zfs_name);\n\tzfs_handle_t *later_dir = name_to_dir_handle(later->zfs_hdl,\n\t    later->zfs_name);\n\n\tif (strcmp(earlier_dir->zfs_name, later_dir->zfs_name) == 0) {\n\t\tzfs_close(earlier_dir);\n\t\tzfs_close(later_dir);\n\t\treturn (B_TRUE);\n\t}\n\n\tchar clonename[ZFS_MAX_DATASET_NAME_LEN];\n\tif (zfs_prop_get(later_dir, ZFS_PROP_ORIGIN, clonename,\n\t    ZFS_MAX_DATASET_NAME_LEN, NULL, NULL, 0, B_TRUE) != 0) {\n\t\tzfs_close(earlier_dir);\n\t\tzfs_close(later_dir);\n\t\treturn (B_FALSE);\n\t}\n\n\tzfs_handle_t *origin = zfs_open(earlier->zfs_hdl, clonename,\n\t    ZFS_TYPE_DATASET);\n\tuint64_t origin_txg = zfs_prop_get_int(origin, ZFS_PROP_CREATETXG);\n\n\t \n\tif (origin_txg == earlier_txg &&\n\t    strcmp(origin->zfs_name, earlier->zfs_name) == 0) {\n\t\tzfs_close(earlier_dir);\n\t\tzfs_close(later_dir);\n\t\tzfs_close(origin);\n\t\treturn (B_TRUE);\n\t}\n\tzfs_close(earlier_dir);\n\tzfs_close(later_dir);\n\n\tret = snapshot_is_before(earlier, origin);\n\tzfs_close(origin);\n\treturn (ret);\n}\n\n \nstatic int\nzfs_send_one_cb_impl(zfs_handle_t *zhp, const char *from, int fd,\n    sendflags_t *flags, const char *redactbook)\n{\n\tint err;\n\tlibzfs_handle_t *hdl = zhp->zfs_hdl;\n\tchar *name = zhp->zfs_name;\n\tpthread_t ptid;\n\tprogress_arg_t pa = { 0 };\n\tuint64_t size = 0;\n\n\tchar errbuf[ERRBUFLEN];\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"warning: cannot send '%s'\"), name);\n\n\tif (from != NULL && strchr(from, '@')) {\n\t\tzfs_handle_t *from_zhp = zfs_open(hdl, from,\n\t\t    ZFS_TYPE_DATASET);\n\t\tif (from_zhp == NULL)\n\t\t\treturn (-1);\n\t\tif (!snapshot_is_before(from_zhp, zhp)) {\n\t\t\tzfs_close(from_zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"not an earlier snapshot from the same fs\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));\n\t\t}\n\t\tzfs_close(from_zhp);\n\t}\n\n\tif (redactbook != NULL) {\n\t\tchar bookname[ZFS_MAX_DATASET_NAME_LEN];\n\t\tnvlist_t *redact_snaps;\n\t\tzfs_handle_t *book_zhp;\n\t\tchar *at, *pound;\n\t\tint dsnamelen;\n\n\t\tpound = strchr(redactbook, '#');\n\t\tif (pound != NULL)\n\t\t\tredactbook = pound + 1;\n\t\tat = strchr(name, '@');\n\t\tif (at == NULL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot do a redacted send to a filesystem\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\t\t}\n\t\tdsnamelen = at - name;\n\t\tif (snprintf(bookname, sizeof (bookname), \"%.*s#%s\",\n\t\t    dsnamelen, name, redactbook)\n\t\t    >= sizeof (bookname)) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid bookmark name\"));\n\t\t\treturn (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));\n\t\t}\n\t\tbook_zhp = zfs_open(hdl, bookname, ZFS_TYPE_BOOKMARK);\n\t\tif (book_zhp == NULL)\n\t\t\treturn (-1);\n\t\tif (nvlist_lookup_nvlist(book_zhp->zfs_props,\n\t\t    zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS),\n\t\t    &redact_snaps) != 0 || redact_snaps == NULL) {\n\t\t\tzfs_close(book_zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"not a redaction bookmark\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BADTYPE, errbuf));\n\t\t}\n\t\tzfs_close(book_zhp);\n\t}\n\n\t \n\tif (flags->props || flags->holds || flags->backup) {\n\t\t \n\t\terr = send_prelim_records(zhp, NULL, fd, B_TRUE, B_FALSE,\n\t\t    flags->verbosity > 0, flags->dryrun, flags->raw,\n\t\t    flags->replicate, B_FALSE, flags->backup, flags->holds,\n\t\t    flags->props, flags->doall, NULL, NULL);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\t \n\tif (flags->verbosity != 0 || flags->progressastitle) {\n\t\terr = estimate_size(zhp, from, fd, flags, 0, 0, 0, redactbook,\n\t\t    errbuf, &size);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\tif (flags->dryrun)\n\t\treturn (0);\n\n\t \n\tsigset_t oldmask;\n\t{\n\t\tpa.pa_zhp = zhp;\n\t\tpa.pa_fd = fd;\n\t\tpa.pa_parsable = flags->parsable;\n\t\tpa.pa_estimate = B_FALSE;\n\t\tpa.pa_verbosity = flags->verbosity;\n\t\tpa.pa_size = size;\n\t\tpa.pa_astitle = flags->progressastitle;\n\t\tpa.pa_progress = flags->progress;\n\n\t\terr = pthread_create(&ptid, NULL,\n\t\t    send_progress_thread, &pa);\n\t\tif (err != 0) {\n\t\t\tzfs_error_aux(zhp->zfs_hdl, \"%s\", strerror(errno));\n\t\t\treturn (zfs_error(zhp->zfs_hdl,\n\t\t\t    EZFS_THREADCREATEFAILED, errbuf));\n\t\t}\n\t\tSEND_PROGRESS_THREAD_PARENT_BLOCK(&oldmask);\n\t}\n\n\terr = lzc_send_redacted(name, from, fd,\n\t    lzc_flags_from_sendflags(flags), redactbook);\n\n\tif (send_progress_thread_exit(hdl, ptid, &oldmask))\n\t\t\treturn (-1);\n\n\tif (err == 0 && (flags->props || flags->holds || flags->backup)) {\n\t\t \n\t\terr = send_conclusion_record(fd, NULL);\n\t\tif (err != 0)\n\t\t\treturn (zfs_standard_error(hdl, err, errbuf));\n\t}\n\tif (err != 0) {\n\t\tswitch (errno) {\n\t\tcase EXDEV:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"not an earlier snapshot from the same fs\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));\n\n\t\tcase ENOENT:\n\t\tcase ESRCH:\n\t\t\tif (lzc_exists(name)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"incremental source (%s) does not exist\"),\n\t\t\t\t    from);\n\t\t\t}\n\t\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\n\t\tcase EACCES:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"dataset key must be loaded\"));\n\t\t\treturn (zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf));\n\n\t\tcase EBUSY:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"target is busy; if a filesystem, \"\n\t\t\t    \"it must not be mounted\"));\n\t\t\treturn (zfs_error(hdl, EZFS_BUSY, errbuf));\n\n\t\tcase EDQUOT:\n\t\tcase EFAULT:\n\t\tcase EFBIG:\n\t\tcase EINVAL:\n\t\tcase EIO:\n\t\tcase ENOLINK:\n\t\tcase ENOSPC:\n\t\tcase ENOSTR:\n\t\tcase ENXIO:\n\t\tcase EPIPE:\n\t\tcase ERANGE:\n\t\tcase EROFS:\n\t\t\tzfs_error_aux(hdl, \"%s\", strerror(errno));\n\t\t\treturn (zfs_error(hdl, EZFS_BADBACKUP, errbuf));\n\n\t\tdefault:\n\t\t\treturn (zfs_standard_error(hdl, errno, errbuf));\n\t\t}\n\t}\n\treturn (err != 0);\n}\n\nstruct zfs_send_one {\n\tzfs_handle_t *zhp;\n\tconst char *from;\n\tsendflags_t *flags;\n\tconst char *redactbook;\n};\n\nstatic int\nzfs_send_one_cb(int fd, void *arg)\n{\n\tstruct zfs_send_one *zso = arg;\n\treturn (zfs_send_one_cb_impl(zso->zhp, zso->from, fd, zso->flags,\n\t    zso->redactbook));\n}\n\nint\nzfs_send_one(zfs_handle_t *zhp, const char *from, int fd, sendflags_t *flags,\n    const char *redactbook)\n{\n\tstruct zfs_send_one zso = {\n\t\t.zhp = zhp,\n\t\t.from = from,\n\t\t.flags = flags,\n\t\t.redactbook = redactbook,\n\t};\n\treturn (lzc_send_wrapper(zfs_send_one_cb, fd, &zso));\n}\n\n \n\nstatic int\nrecv_read(libzfs_handle_t *hdl, int fd, void *buf, int ilen,\n    boolean_t byteswap, zio_cksum_t *zc)\n{\n\tchar *cp = buf;\n\tint rv;\n\tint len = ilen;\n\n\tdo {\n\t\trv = read(fd, cp, len);\n\t\tcp += rv;\n\t\tlen -= rv;\n\t} while (rv > 0);\n\n\tif (rv < 0 || len != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"failed to read from stream\"));\n\t\treturn (zfs_error(hdl, EZFS_BADSTREAM, dgettext(TEXT_DOMAIN,\n\t\t    \"cannot receive\")));\n\t}\n\n\tif (zc) {\n\t\tif (byteswap)\n\t\t\tfletcher_4_incremental_byteswap(buf, ilen, zc);\n\t\telse\n\t\t\tfletcher_4_incremental_native(buf, ilen, zc);\n\t}\n\treturn (0);\n}\n\nstatic int\nrecv_read_nvlist(libzfs_handle_t *hdl, int fd, int len, nvlist_t **nvp,\n    boolean_t byteswap, zio_cksum_t *zc)\n{\n\tchar *buf;\n\tint err;\n\n\tbuf = zfs_alloc(hdl, len);\n\n\tif (len > hdl->libzfs_max_nvlist) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"nvlist too large\"));\n\t\tfree(buf);\n\t\treturn (ENOMEM);\n\t}\n\n\terr = recv_read(hdl, fd, buf, len, byteswap, zc);\n\tif (err != 0) {\n\t\tfree(buf);\n\t\treturn (err);\n\t}\n\n\terr = nvlist_unpack(buf, len, nvp, 0);\n\tfree(buf);\n\tif (err != 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t    \"stream (malformed nvlist)\"));\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}\n\n \nstatic zfs_handle_t *\nrecv_open_grand_origin(zfs_handle_t *zhp)\n{\n\tchar origin[ZFS_MAX_DATASET_NAME_LEN];\n\tzprop_source_t src;\n\tzfs_handle_t *ozhp = zfs_handle_dup(zhp);\n\n\twhile (ozhp != NULL) {\n\t\tif (zfs_prop_get(ozhp, ZFS_PROP_ORIGIN, origin,\n\t\t    sizeof (origin), &src, NULL, 0, B_FALSE) != 0)\n\t\t\tbreak;\n\n\t\t(void) zfs_close(ozhp);\n\t\tozhp = zfs_open(zhp->zfs_hdl, origin, ZFS_TYPE_FILESYSTEM);\n\t}\n\n\treturn (ozhp);\n}\n\nstatic int\nrecv_rename_impl(zfs_handle_t *zhp, const char *name, const char *newname)\n{\n\tint err;\n\tzfs_handle_t *ozhp = NULL;\n\n\t \n\terr = lzc_rename(name, newname);\n\tif (err == EACCES) {\n\t\tozhp = recv_open_grand_origin(zhp);\n\t\tif (ozhp == NULL) {\n\t\t\terr = ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = lzc_change_key(ozhp->zfs_name, DCP_CMD_FORCE_NEW_KEY,\n\t\t    NULL, NULL, 0);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\terr = lzc_rename(name, newname);\n\t}\n\nout:\n\tif (ozhp != NULL)\n\t\tzfs_close(ozhp);\n\treturn (err);\n}\n\nstatic int\nrecv_rename(libzfs_handle_t *hdl, const char *name, const char *tryname,\n    int baselen, char *newname, recvflags_t *flags)\n{\n\tstatic int seq;\n\tint err;\n\tprop_changelist_t *clp = NULL;\n\tzfs_handle_t *zhp = NULL;\n\n\tzhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);\n\tif (zhp == NULL) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\tclp = changelist_gather(zhp, ZFS_PROP_NAME, 0,\n\t    flags->force ? MS_FORCE : 0);\n\tif (clp == NULL) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\terr = changelist_prefix(clp);\n\tif (err)\n\t\tgoto out;\n\n\tif (tryname) {\n\t\t(void) strlcpy(newname, tryname, ZFS_MAX_DATASET_NAME_LEN);\n\t\tif (flags->verbose) {\n\t\t\t(void) printf(\"attempting rename %s to %s\\n\",\n\t\t\t    name, newname);\n\t\t}\n\t\terr = recv_rename_impl(zhp, name, newname);\n\t\tif (err == 0)\n\t\t\tchangelist_rename(clp, name, tryname);\n\t} else {\n\t\terr = ENOENT;\n\t}\n\n\tif (err != 0 && strncmp(name + baselen, \"recv-\", 5) != 0) {\n\t\tseq++;\n\n\t\t(void) snprintf(newname, ZFS_MAX_DATASET_NAME_LEN,\n\t\t    \"%.*srecv-%u-%u\", baselen, name, getpid(), seq);\n\n\t\tif (flags->verbose) {\n\t\t\t(void) printf(\"failed - trying rename %s to %s\\n\",\n\t\t\t    name, newname);\n\t\t}\n\t\terr = recv_rename_impl(zhp, name, newname);\n\t\tif (err == 0)\n\t\t\tchangelist_rename(clp, name, newname);\n\t\tif (err && flags->verbose) {\n\t\t\t(void) printf(\"failed (%u) - \"\n\t\t\t    \"will try again on next pass\\n\", errno);\n\t\t}\n\t\terr = EAGAIN;\n\t} else if (flags->verbose) {\n\t\tif (err == 0)\n\t\t\t(void) printf(\"success\\n\");\n\t\telse\n\t\t\t(void) printf(\"failed (%u)\\n\", errno);\n\t}\n\n\t(void) changelist_postfix(clp);\n\nout:\n\tif (clp != NULL)\n\t\tchangelist_free(clp);\n\tif (zhp != NULL)\n\t\tzfs_close(zhp);\n\n\treturn (err);\n}\n\nstatic int\nrecv_promote(libzfs_handle_t *hdl, const char *fsname,\n    const char *origin_fsname, recvflags_t *flags)\n{\n\tint err;\n\tzfs_cmd_t zc = {\"\\0\"};\n\tzfs_handle_t *zhp = NULL, *ozhp = NULL;\n\n\tif (flags->verbose)\n\t\t(void) printf(\"promoting %s\\n\", fsname);\n\n\t(void) strlcpy(zc.zc_value, origin_fsname, sizeof (zc.zc_value));\n\t(void) strlcpy(zc.zc_name, fsname, sizeof (zc.zc_name));\n\n\t \n\terr = zfs_ioctl(hdl, ZFS_IOC_PROMOTE, &zc);\n\tif (err == EACCES) {\n\t\tzhp = zfs_open(hdl, fsname, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tozhp = recv_open_grand_origin(zhp);\n\t\tif (ozhp == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = lzc_change_key(ozhp->zfs_name, DCP_CMD_FORCE_NEW_KEY,\n\t\t    NULL, NULL, 0);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\terr = zfs_ioctl(hdl, ZFS_IOC_PROMOTE, &zc);\n\t}\n\nout:\n\tif (zhp != NULL)\n\t\tzfs_close(zhp);\n\tif (ozhp != NULL)\n\t\tzfs_close(ozhp);\n\n\treturn (err);\n}\n\nstatic int\nrecv_destroy(libzfs_handle_t *hdl, const char *name, int baselen,\n    char *newname, recvflags_t *flags)\n{\n\tint err = 0;\n\tprop_changelist_t *clp;\n\tzfs_handle_t *zhp;\n\tboolean_t defer = B_FALSE;\n\tint spa_version;\n\n\tzhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);\n\tif (zhp == NULL)\n\t\treturn (-1);\n\tzfs_type_t type = zfs_get_type(zhp);\n\tif (type == ZFS_TYPE_SNAPSHOT &&\n\t    zfs_spa_version(zhp, &spa_version) == 0 &&\n\t    spa_version >= SPA_VERSION_USERREFS)\n\t\tdefer = B_TRUE;\n\tclp = changelist_gather(zhp, ZFS_PROP_NAME, 0,\n\t    flags->force ? MS_FORCE : 0);\n\tzfs_close(zhp);\n\tif (clp == NULL)\n\t\treturn (-1);\n\n\terr = changelist_prefix(clp);\n\tif (err)\n\t\treturn (err);\n\n\tif (flags->verbose)\n\t\t(void) printf(\"attempting destroy %s\\n\", name);\n\tif (type == ZFS_TYPE_SNAPSHOT) {\n\t\tnvlist_t *nv = fnvlist_alloc();\n\t\tfnvlist_add_boolean(nv, name);\n\t\terr = lzc_destroy_snaps(nv, defer, NULL);\n\t\tfnvlist_free(nv);\n\t} else {\n\t\terr = lzc_destroy(name);\n\t}\n\tif (err == 0) {\n\t\tif (flags->verbose)\n\t\t\t(void) printf(\"success\\n\");\n\t\tchangelist_remove(clp, name);\n\t}\n\n\t(void) changelist_postfix(clp);\n\tchangelist_free(clp);\n\n\t \n\tif (err != 0 || (defer && zfs_dataset_exists(hdl, name,\n\t    ZFS_TYPE_SNAPSHOT))) {\n\t\terr = recv_rename(hdl, name, NULL, baselen, newname, flags);\n\t}\n\n\treturn (err);\n}\n\ntypedef struct guid_to_name_data {\n\tuint64_t guid;\n\tboolean_t bookmark_ok;\n\tchar *name;\n\tchar *skip;\n\tuint64_t *redact_snap_guids;\n\tuint64_t num_redact_snaps;\n} guid_to_name_data_t;\n\nstatic boolean_t\nredact_snaps_match(zfs_handle_t *zhp, guid_to_name_data_t *gtnd)\n{\n\tuint64_t *bmark_snaps;\n\tuint_t bmark_num_snaps;\n\tnvlist_t *nvl;\n\tif (zhp->zfs_type != ZFS_TYPE_BOOKMARK)\n\t\treturn (B_FALSE);\n\n\tnvl = fnvlist_lookup_nvlist(zhp->zfs_props,\n\t    zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS));\n\tbmark_snaps = fnvlist_lookup_uint64_array(nvl, ZPROP_VALUE,\n\t    &bmark_num_snaps);\n\tif (bmark_num_snaps != gtnd->num_redact_snaps)\n\t\treturn (B_FALSE);\n\tint i = 0;\n\tfor (; i < bmark_num_snaps; i++) {\n\t\tint j = 0;\n\t\tfor (; j < bmark_num_snaps; j++) {\n\t\t\tif (bmark_snaps[i] == gtnd->redact_snap_guids[j])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == bmark_num_snaps)\n\t\t\tbreak;\n\t}\n\treturn (i == bmark_num_snaps);\n}\n\nstatic int\nguid_to_name_cb(zfs_handle_t *zhp, void *arg)\n{\n\tguid_to_name_data_t *gtnd = arg;\n\tconst char *slash;\n\tint err;\n\n\tif (gtnd->skip != NULL &&\n\t    (slash = strrchr(zhp->zfs_name, '/')) != NULL &&\n\t    strcmp(slash + 1, gtnd->skip) == 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_GUID) == gtnd->guid &&\n\t    (gtnd->num_redact_snaps == -1 || redact_snaps_match(zhp, gtnd))) {\n\t\t(void) strcpy(gtnd->name, zhp->zfs_name);\n\t\tzfs_close(zhp);\n\t\treturn (EEXIST);\n\t}\n\n\terr = zfs_iter_children_v2(zhp, 0, guid_to_name_cb, gtnd);\n\tif (err != EEXIST && gtnd->bookmark_ok)\n\t\terr = zfs_iter_bookmarks_v2(zhp, 0, guid_to_name_cb, gtnd);\n\tzfs_close(zhp);\n\treturn (err);\n}\n\n \nstatic int\nguid_to_name_redact_snaps(libzfs_handle_t *hdl, const char *parent,\n    uint64_t guid, boolean_t bookmark_ok, uint64_t *redact_snap_guids,\n    uint64_t num_redact_snaps, char *name)\n{\n\tchar pname[ZFS_MAX_DATASET_NAME_LEN];\n\tguid_to_name_data_t gtnd;\n\n\tgtnd.guid = guid;\n\tgtnd.bookmark_ok = bookmark_ok;\n\tgtnd.name = name;\n\tgtnd.skip = NULL;\n\tgtnd.redact_snap_guids = redact_snap_guids;\n\tgtnd.num_redact_snaps = num_redact_snaps;\n\n\t \n\t(void) strlcpy(pname, parent, sizeof (pname));\n\tchar *cp = strrchr(pname, '@');\n\tif (cp == NULL)\n\t\tcp = strchr(pname, '\\0');\n\tfor (; cp != NULL; cp = strrchr(pname, '/')) {\n\t\t \n\t\t*cp = '\\0';\n\t\tzfs_handle_t *zhp = make_dataset_handle(hdl, pname);\n\n\t\tif (zhp == NULL)\n\t\t\tcontinue;\n\t\tint err = guid_to_name_cb(zfs_handle_dup(zhp), &gtnd);\n\t\tif (err != EEXIST)\n\t\t\terr = zfs_iter_children_v2(zhp, 0, guid_to_name_cb,\n\t\t\t    &gtnd);\n\t\tif (err != EEXIST && bookmark_ok)\n\t\t\terr = zfs_iter_bookmarks_v2(zhp, 0, guid_to_name_cb,\n\t\t\t    &gtnd);\n\t\tzfs_close(zhp);\n\t\tif (err == EEXIST)\n\t\t\treturn (0);\n\n\t\t \n\t\tgtnd.skip = strrchr(pname, '/') + 1;\n\t}\n\n\treturn (ENOENT);\n}\n\nstatic int\nguid_to_name(libzfs_handle_t *hdl, const char *parent, uint64_t guid,\n    boolean_t bookmark_ok, char *name)\n{\n\treturn (guid_to_name_redact_snaps(hdl, parent, guid, bookmark_ok, NULL,\n\t    -1, name));\n}\n\n \nstatic int\ncreated_before(libzfs_handle_t *hdl, avl_tree_t *avl,\n    uint64_t guid1, uint64_t guid2)\n{\n\tnvlist_t *nvfs;\n\tconst char *fsname = NULL, *snapname = NULL;\n\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\tint rv;\n\tzfs_handle_t *guid1hdl, *guid2hdl;\n\tuint64_t create1, create2;\n\n\tif (guid2 == 0)\n\t\treturn (0);\n\tif (guid1 == 0)\n\t\treturn (1);\n\n\tnvfs = fsavl_find(avl, guid1, &snapname);\n\tfsname = fnvlist_lookup_string(nvfs, \"name\");\n\t(void) snprintf(buf, sizeof (buf), \"%s@%s\", fsname, snapname);\n\tguid1hdl = zfs_open(hdl, buf, ZFS_TYPE_SNAPSHOT);\n\tif (guid1hdl == NULL)\n\t\treturn (-1);\n\n\tnvfs = fsavl_find(avl, guid2, &snapname);\n\tfsname = fnvlist_lookup_string(nvfs, \"name\");\n\t(void) snprintf(buf, sizeof (buf), \"%s@%s\", fsname, snapname);\n\tguid2hdl = zfs_open(hdl, buf, ZFS_TYPE_SNAPSHOT);\n\tif (guid2hdl == NULL) {\n\t\tzfs_close(guid1hdl);\n\t\treturn (-1);\n\t}\n\n\tcreate1 = zfs_prop_get_int(guid1hdl, ZFS_PROP_CREATETXG);\n\tcreate2 = zfs_prop_get_int(guid2hdl, ZFS_PROP_CREATETXG);\n\n\tif (create1 < create2)\n\t\trv = -1;\n\telse if (create1 > create2)\n\t\trv = +1;\n\telse\n\t\trv = 0;\n\n\tzfs_close(guid1hdl);\n\tzfs_close(guid2hdl);\n\n\treturn (rv);\n}\n\n \nstatic int\nrecv_fix_encryption_hierarchy(libzfs_handle_t *hdl, const char *top_zfs,\n    nvlist_t *stream_nv)\n{\n\tint err;\n\tnvpair_t *fselem = NULL;\n\tnvlist_t *stream_fss;\n\n\tstream_fss = fnvlist_lookup_nvlist(stream_nv, \"fss\");\n\n\twhile ((fselem = nvlist_next_nvpair(stream_fss, fselem)) != NULL) {\n\t\tzfs_handle_t *zhp = NULL;\n\t\tuint64_t crypt;\n\t\tnvlist_t *snaps, *props, *stream_nvfs = NULL;\n\t\tnvpair_t *snapel = NULL;\n\t\tboolean_t is_encroot, is_clone, stream_encroot;\n\t\tchar *cp;\n\t\tconst char *stream_keylocation = NULL;\n\t\tchar keylocation[MAXNAMELEN];\n\t\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\tkeylocation[0] = '\\0';\n\t\tstream_nvfs = fnvpair_value_nvlist(fselem);\n\t\tsnaps = fnvlist_lookup_nvlist(stream_nvfs, \"snaps\");\n\t\tprops = fnvlist_lookup_nvlist(stream_nvfs, \"props\");\n\t\tstream_encroot = nvlist_exists(stream_nvfs, \"is_encroot\");\n\n\t\t \n\t\terr = ENOENT;\n\t\twhile ((snapel = nvlist_next_nvpair(snaps, snapel)) != NULL) {\n\t\t\tuint64_t guid;\n\n\t\t\tguid = fnvpair_value_uint64(snapel);\n\t\t\terr = guid_to_name(hdl, top_zfs, guid, B_FALSE,\n\t\t\t    fsname);\n\t\t\tif (err == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (err != 0)\n\t\t\tcontinue;\n\n\t\tcp = strchr(fsname, '@');\n\t\tif (cp != NULL)\n\t\t\t*cp = '\\0';\n\n\t\tzhp = zfs_open(hdl, fsname, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\terr = ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\tcrypt = zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION);\n\t\tis_clone = zhp->zfs_dmustats.dds_origin[0] != '\\0';\n\t\t(void) zfs_crypto_get_encryption_root(zhp, &is_encroot, NULL);\n\n\t\t \n\t\tif (crypt == ZIO_CRYPT_OFF) {\n\t\t\tzfs_close(zhp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (stream_encroot) {\n\t\t\tif (!is_clone && !is_encroot) {\n\t\t\t\terr = lzc_change_key(fsname,\n\t\t\t\t    DCP_CMD_FORCE_NEW_KEY, NULL, NULL, 0);\n\t\t\t\tif (err != 0) {\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstream_keylocation = fnvlist_lookup_string(props,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION));\n\n\t\t\t \n\t\t\tzfs_refresh_properties(zhp);\n\t\t\terr = zfs_prop_get(zhp, ZFS_PROP_KEYLOCATION,\n\t\t\t    keylocation, sizeof (keylocation), NULL, NULL,\n\t\t\t    0, B_TRUE);\n\t\t\tif (err != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (strcmp(keylocation, stream_keylocation) != 0) {\n\t\t\t\terr = zfs_prop_set(zhp,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t\t\t\t    stream_keylocation);\n\t\t\t\tif (err != 0) {\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!stream_encroot && is_encroot &&\n\t\t    strcmp(top_zfs, fsname) != 0) {\n\t\t\terr = lzc_change_key(fsname, DCP_CMD_FORCE_INHERIT,\n\t\t\t    NULL, NULL, 0);\n\t\t\tif (err != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (err);\n}\n\nstatic int\nrecv_incremental_replication(libzfs_handle_t *hdl, const char *tofs,\n    recvflags_t *flags, nvlist_t *stream_nv, avl_tree_t *stream_avl,\n    nvlist_t *renamed)\n{\n\tnvlist_t *local_nv, *deleted = NULL;\n\tavl_tree_t *local_avl;\n\tnvpair_t *fselem, *nextfselem;\n\tconst char *fromsnap;\n\tchar newname[ZFS_MAX_DATASET_NAME_LEN];\n\tchar guidname[32];\n\tint error;\n\tboolean_t needagain, progress, recursive;\n\tconst char *s1, *s2;\n\n\tfromsnap = fnvlist_lookup_string(stream_nv, \"fromsnap\");\n\n\trecursive = (nvlist_lookup_boolean(stream_nv, \"not_recursive\") ==\n\t    ENOENT);\n\n\tif (flags->dryrun)\n\t\treturn (0);\n\nagain:\n\tneedagain = progress = B_FALSE;\n\n\tdeleted = fnvlist_alloc();\n\n\tif ((error = gather_nvlist(hdl, tofs, fromsnap, NULL,\n\t    recursive, B_TRUE, B_FALSE, recursive, B_FALSE, B_FALSE, B_FALSE,\n\t    B_FALSE, B_TRUE, &local_nv, &local_avl)) != 0)\n\t\treturn (error);\n\n\t \n\tfor (fselem = nvlist_next_nvpair(local_nv, NULL);\n\t    fselem; fselem = nextfselem) {\n\t\tnvlist_t *nvfs, *snaps;\n\t\tnvlist_t *stream_nvfs = NULL;\n\t\tnvpair_t *snapelem, *nextsnapelem;\n\t\tuint64_t fromguid = 0;\n\t\tuint64_t originguid = 0;\n\t\tuint64_t stream_originguid = 0;\n\t\tuint64_t parent_fromsnap_guid, stream_parent_fromsnap_guid;\n\t\tconst char *fsname, *stream_fsname;\n\n\t\tnextfselem = nvlist_next_nvpair(local_nv, fselem);\n\n\t\tnvfs = fnvpair_value_nvlist(fselem);\n\t\tsnaps = fnvlist_lookup_nvlist(nvfs, \"snaps\");\n\t\tfsname = fnvlist_lookup_string(nvfs, \"name\");\n\t\tparent_fromsnap_guid = fnvlist_lookup_uint64(nvfs,\n\t\t    \"parentfromsnap\");\n\t\t(void) nvlist_lookup_uint64(nvfs, \"origin\", &originguid);\n\n\t\t \n\t\tfor (snapelem = nvlist_next_nvpair(snaps, NULL);\n\t\t    snapelem; snapelem = nvlist_next_nvpair(snaps, snapelem)) {\n\t\t\tuint64_t thisguid;\n\n\t\t\tthisguid = fnvpair_value_uint64(snapelem);\n\t\t\tstream_nvfs = fsavl_find(stream_avl, thisguid, NULL);\n\n\t\t\tif (stream_nvfs != NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t(void) nvlist_lookup_uint64(stream_nvfs, \"origin\",\n\t\t    &stream_originguid);\n\t\tif (stream_nvfs && originguid != stream_originguid) {\n\t\t\tswitch (created_before(hdl, local_avl,\n\t\t\t    stream_originguid, originguid)) {\n\t\t\tcase 1: {\n\t\t\t\t \n\t\t\t\tnvlist_t *origin_nvfs;\n\t\t\t\tconst char *origin_fsname;\n\n\t\t\t\torigin_nvfs = fsavl_find(local_avl, originguid,\n\t\t\t\t    NULL);\n\t\t\t\torigin_fsname = fnvlist_lookup_string(\n\t\t\t\t    origin_nvfs, \"name\");\n\t\t\t\terror = recv_promote(hdl, fsname, origin_fsname,\n\t\t\t\t    flags);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tprogress = B_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tfsavl_destroy(local_avl);\n\t\t\t\tfnvlist_free(local_nv);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t \n\t\t\tneedagain = B_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (snapelem = nvlist_next_nvpair(snaps, NULL);\n\t\t    snapelem; snapelem = nextsnapelem) {\n\t\t\tuint64_t thisguid;\n\t\t\tconst char *stream_snapname;\n\t\t\tnvlist_t *found, *props;\n\n\t\t\tnextsnapelem = nvlist_next_nvpair(snaps, snapelem);\n\n\t\t\tthisguid = fnvpair_value_uint64(snapelem);\n\t\t\tfound = fsavl_find(stream_avl, thisguid,\n\t\t\t    &stream_snapname);\n\n\t\t\t \n\t\t\tif (found == NULL) {\n\t\t\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\t\t\tif (!flags->force)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t(void) snprintf(name, sizeof (name), \"%s@%s\",\n\t\t\t\t    fsname, nvpair_name(snapelem));\n\n\t\t\t\terror = recv_destroy(hdl, name,\n\t\t\t\t    strlen(fsname)+1, newname, flags);\n\t\t\t\tif (error)\n\t\t\t\t\tneedagain = B_TRUE;\n\t\t\t\telse\n\t\t\t\t\tprogress = B_TRUE;\n\t\t\t\tsprintf(guidname, \"%llu\",\n\t\t\t\t    (u_longlong_t)thisguid);\n\t\t\t\tnvlist_add_boolean(deleted, guidname);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstream_nvfs = found;\n\n\t\t\tif (0 == nvlist_lookup_nvlist(stream_nvfs, \"snapprops\",\n\t\t\t    &props) && 0 == nvlist_lookup_nvlist(props,\n\t\t\t    stream_snapname, &props)) {\n\t\t\t\tzfs_cmd_t zc = {\"\\0\"};\n\n\t\t\t\tzc.zc_cookie = B_TRUE;  \n\t\t\t\t(void) snprintf(zc.zc_name, sizeof (zc.zc_name),\n\t\t\t\t    \"%s@%s\", fsname, nvpair_name(snapelem));\n\t\t\t\tzcmd_write_src_nvlist(hdl, &zc, props);\n\t\t\t\t(void) zfs_ioctl(hdl,\n\t\t\t\t    ZFS_IOC_SET_PROP, &zc);\n\t\t\t\tzcmd_free_nvlists(&zc);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (strcmp(nvpair_name(snapelem),\n\t\t\t    stream_snapname) != 0) {\n\t\t\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t\tchar tryname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\t\t\t(void) snprintf(name, sizeof (name), \"%s@%s\",\n\t\t\t\t    fsname, nvpair_name(snapelem));\n\t\t\t\t(void) snprintf(tryname, sizeof (name), \"%s@%s\",\n\t\t\t\t    fsname, stream_snapname);\n\n\t\t\t\terror = recv_rename(hdl, name, tryname,\n\t\t\t\t    strlen(fsname)+1, newname, flags);\n\t\t\t\tif (error)\n\t\t\t\t\tneedagain = B_TRUE;\n\t\t\t\telse\n\t\t\t\t\tprogress = B_TRUE;\n\t\t\t}\n\n\t\t\tif (strcmp(stream_snapname, fromsnap) == 0)\n\t\t\t\tfromguid = thisguid;\n\t\t}\n\n\t\t \n\t\tif (stream_nvfs == NULL) {\n\t\t\tif (!flags->force)\n\t\t\t\tcontinue;\n\n\t\t\terror = recv_destroy(hdl, fsname, strlen(tofs)+1,\n\t\t\t    newname, flags);\n\t\t\tif (error)\n\t\t\t\tneedagain = B_TRUE;\n\t\t\telse\n\t\t\t\tprogress = B_TRUE;\n\t\t\tsprintf(guidname, \"%llu\",\n\t\t\t    (u_longlong_t)parent_fromsnap_guid);\n\t\t\tnvlist_add_boolean(deleted, guidname);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fromguid == 0) {\n\t\t\tif (flags->verbose) {\n\t\t\t\t(void) printf(\"local fs %s does not have \"\n\t\t\t\t    \"fromsnap (%s in stream); must have \"\n\t\t\t\t    \"been deleted locally; ignoring\\n\",\n\t\t\t\t    fsname, fromsnap);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tstream_fsname = fnvlist_lookup_string(stream_nvfs, \"name\");\n\t\tstream_parent_fromsnap_guid = fnvlist_lookup_uint64(\n\t\t    stream_nvfs, \"parentfromsnap\");\n\n\t\ts1 = strrchr(fsname, '/');\n\t\ts2 = strrchr(stream_fsname, '/');\n\n\t\t \n\t\tif (stream_parent_fromsnap_guid != 0 &&\n\t\t    parent_fromsnap_guid != 0 &&\n\t\t    stream_parent_fromsnap_guid != parent_fromsnap_guid) {\n\t\t\tsprintf(guidname, \"%llu\",\n\t\t\t    (u_longlong_t)parent_fromsnap_guid);\n\t\t\tif (nvlist_exists(deleted, guidname)) {\n\t\t\t\tprogress = B_TRUE;\n\t\t\t\tneedagain = B_TRUE;\n\t\t\t\tgoto doagain;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((stream_parent_fromsnap_guid != 0 &&\n\t\t    parent_fromsnap_guid != 0 &&\n\t\t    stream_parent_fromsnap_guid != parent_fromsnap_guid) ||\n\t\t    ((flags->isprefix || strcmp(tofs, fsname) != 0) &&\n\t\t    (s1 != NULL) && (s2 != NULL) && strcmp(s1, s2) != 0)) {\n\t\t\tnvlist_t *parent;\n\t\t\tchar tryname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\t\tparent = fsavl_find(local_avl,\n\t\t\t    stream_parent_fromsnap_guid, NULL);\n\t\t\t \n\t\t\tif (parent != NULL) {\n\t\t\t\tconst char *pname;\n\n\t\t\t\tpname = fnvlist_lookup_string(parent, \"name\");\n\t\t\t\t(void) snprintf(tryname, sizeof (tryname),\n\t\t\t\t    \"%s%s\", pname, strrchr(stream_fsname, '/'));\n\t\t\t} else {\n\t\t\t\ttryname[0] = '\\0';\n\t\t\t\tif (flags->verbose) {\n\t\t\t\t\t(void) printf(\"local fs %s new parent \"\n\t\t\t\t\t    \"not found\\n\", fsname);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewname[0] = '\\0';\n\n\t\t\terror = recv_rename(hdl, fsname, tryname,\n\t\t\t    strlen(tofs)+1, newname, flags);\n\n\t\t\tif (renamed != NULL && newname[0] != '\\0') {\n\t\t\t\tfnvlist_add_boolean(renamed, newname);\n\t\t\t}\n\n\t\t\tif (error)\n\t\t\t\tneedagain = B_TRUE;\n\t\t\telse\n\t\t\t\tprogress = B_TRUE;\n\t\t}\n\t}\n\ndoagain:\n\tfsavl_destroy(local_avl);\n\tfnvlist_free(local_nv);\n\tfnvlist_free(deleted);\n\n\tif (needagain && progress) {\n\t\t \n\t\tif (flags->verbose)\n\t\t\t(void) printf(\"another pass:\\n\");\n\t\tgoto again;\n\t}\n\n\treturn (needagain || error != 0);\n}\n\nstatic int\nzfs_receive_package(libzfs_handle_t *hdl, int fd, const char *destname,\n    recvflags_t *flags, dmu_replay_record_t *drr, zio_cksum_t *zc,\n    char **top_zfs, nvlist_t *cmdprops)\n{\n\tnvlist_t *stream_nv = NULL;\n\tavl_tree_t *stream_avl = NULL;\n\tconst char *fromsnap = NULL;\n\tconst char *sendsnap = NULL;\n\tchar *cp;\n\tchar tofs[ZFS_MAX_DATASET_NAME_LEN];\n\tchar sendfs[ZFS_MAX_DATASET_NAME_LEN];\n\tchar errbuf[ERRBUFLEN];\n\tdmu_replay_record_t drre;\n\tint error;\n\tboolean_t anyerr = B_FALSE;\n\tboolean_t softerr = B_FALSE;\n\tboolean_t recursive, raw;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot receive\"));\n\n\tassert(drr->drr_type == DRR_BEGIN);\n\tassert(drr->drr_u.drr_begin.drr_magic == DMU_BACKUP_MAGIC);\n\tassert(DMU_GET_STREAM_HDRTYPE(drr->drr_u.drr_begin.drr_versioninfo) ==\n\t    DMU_COMPOUNDSTREAM);\n\n\t \n\tif (drr->drr_payloadlen != 0) {\n\t\terror = recv_read_nvlist(hdl, fd, drr->drr_payloadlen,\n\t\t    &stream_nv, flags->byteswap, zc);\n\t\tif (error) {\n\t\t\terror = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trecursive = (nvlist_lookup_boolean(stream_nv, \"not_recursive\") ==\n\t    ENOENT);\n\traw = (nvlist_lookup_boolean(stream_nv, \"raw\") == 0);\n\n\tif (recursive && strchr(destname, '@')) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"cannot specify snapshot name for multi-snapshot stream\"));\n\t\terror = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\tgoto out;\n\t}\n\n\t \n\tif (0 != (error = recv_read(hdl, fd, &drre, sizeof (drre),\n\t    flags->byteswap, NULL)))\n\t\tgoto out;\n\tif (flags->byteswap) {\n\t\tdrre.drr_type = BSWAP_32(drre.drr_type);\n\t\tdrre.drr_u.drr_end.drr_checksum.zc_word[0] =\n\t\t    BSWAP_64(drre.drr_u.drr_end.drr_checksum.zc_word[0]);\n\t\tdrre.drr_u.drr_end.drr_checksum.zc_word[1] =\n\t\t    BSWAP_64(drre.drr_u.drr_end.drr_checksum.zc_word[1]);\n\t\tdrre.drr_u.drr_end.drr_checksum.zc_word[2] =\n\t\t    BSWAP_64(drre.drr_u.drr_end.drr_checksum.zc_word[2]);\n\t\tdrre.drr_u.drr_end.drr_checksum.zc_word[3] =\n\t\t    BSWAP_64(drre.drr_u.drr_end.drr_checksum.zc_word[3]);\n\t}\n\tif (drre.drr_type != DRR_END) {\n\t\terror = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\tgoto out;\n\t}\n\tif (!ZIO_CHECKSUM_EQUAL(drre.drr_u.drr_end.drr_checksum, *zc)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"incorrect header checksum\"));\n\t\terror = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\tgoto out;\n\t}\n\n\t(void) nvlist_lookup_string(stream_nv, \"fromsnap\", &fromsnap);\n\n\tif (drr->drr_payloadlen != 0) {\n\t\tnvlist_t *stream_fss;\n\n\t\tstream_fss = fnvlist_lookup_nvlist(stream_nv, \"fss\");\n\t\tif ((stream_avl = fsavl_create(stream_fss)) == NULL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"couldn't allocate avl tree\"));\n\t\t\terror = zfs_error(hdl, EZFS_NOMEM, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fromsnap != NULL && recursive) {\n\t\t\tnvlist_t *renamed = NULL;\n\t\t\tnvpair_t *pair = NULL;\n\n\t\t\t(void) strlcpy(tofs, destname, sizeof (tofs));\n\t\t\tif (flags->isprefix) {\n\t\t\t\tstruct drr_begin *drrb = &drr->drr_u.drr_begin;\n\t\t\t\tint i;\n\n\t\t\t\tif (flags->istail) {\n\t\t\t\t\tcp = strrchr(drrb->drr_toname, '/');\n\t\t\t\t\tif (cp == NULL) {\n\t\t\t\t\t\t(void) strlcat(tofs, \"/\",\n\t\t\t\t\t\t    sizeof (tofs));\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = (cp - drrb->drr_toname);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti = strcspn(drrb->drr_toname, \"/@\");\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t(void) strlcat(tofs, &drrb->drr_toname[i],\n\t\t\t\t    sizeof (tofs));\n\t\t\t\t*strchr(tofs, '@') = '\\0';\n\t\t\t}\n\n\t\t\tif (!flags->dryrun && !flags->nomount) {\n\t\t\t\trenamed = fnvlist_alloc();\n\t\t\t}\n\n\t\t\tsofterr = recv_incremental_replication(hdl, tofs, flags,\n\t\t\t    stream_nv, stream_avl, renamed);\n\n\t\t\t \n\t\t\twhile ((pair = nvlist_next_nvpair(renamed,\n\t\t\t    pair)) != NULL) {\n\t\t\t\tzfs_handle_t *zhp;\n\t\t\t\tprop_changelist_t *clp = NULL;\n\n\t\t\t\tzhp = zfs_open(hdl, nvpair_name(pair),\n\t\t\t\t    ZFS_TYPE_FILESYSTEM);\n\t\t\t\tif (zhp != NULL) {\n\t\t\t\t\tclp = changelist_gather(zhp,\n\t\t\t\t\t    ZFS_PROP_MOUNTPOINT, 0,\n\t\t\t\t\t    flags->forceunmount ? MS_FORCE : 0);\n\t\t\t\t\tzfs_close(zhp);\n\t\t\t\t\tif (clp != NULL) {\n\t\t\t\t\t\tsofterr |=\n\t\t\t\t\t\t    changelist_prefix(clp);\n\t\t\t\t\t\tchangelist_free(clp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfnvlist_free(renamed);\n\t\t}\n\t}\n\n\t \n\t(void) strlcpy(sendfs, drr->drr_u.drr_begin.drr_toname,\n\t    sizeof (sendfs));\n\tif ((cp = strchr(sendfs, '@')) != NULL) {\n\t\t*cp = '\\0';\n\t\t \n\t\tsendsnap = (cp + 1);\n\t}\n\n\t \n\tdo {\n\t\t \n\t\terror = zfs_receive_impl(hdl, destname, NULL, flags, fd,\n\t\t    sendfs, stream_nv, stream_avl, top_zfs, sendsnap, cmdprops);\n\t\tif (error == ENODATA) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t\tanyerr |= error;\n\t} while (error == 0);\n\n\tif (drr->drr_payloadlen != 0 && recursive && fromsnap != NULL) {\n\t\t \n\t\tsofterr = recv_incremental_replication(hdl, tofs, flags,\n\t\t    stream_nv, stream_avl, NULL);\n\t}\n\n\tif (raw && softerr == 0 && *top_zfs != NULL) {\n\t\tsofterr = recv_fix_encryption_hierarchy(hdl, *top_zfs,\n\t\t    stream_nv);\n\t}\n\nout:\n\tfsavl_destroy(stream_avl);\n\tfnvlist_free(stream_nv);\n\tif (softerr)\n\t\terror = -2;\n\tif (anyerr)\n\t\terror = -1;\n\treturn (error);\n}\n\nstatic void\ntrunc_prop_errs(int truncated)\n{\n\tASSERT(truncated != 0);\n\n\tif (truncated == 1)\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t    \"1 more property could not be set\\n\"));\n\telse\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t    \"%d more properties could not be set\\n\"), truncated);\n}\n\nstatic int\nrecv_skip(libzfs_handle_t *hdl, int fd, boolean_t byteswap)\n{\n\tdmu_replay_record_t *drr;\n\tvoid *buf = zfs_alloc(hdl, SPA_MAXBLOCKSIZE);\n\tuint64_t payload_size;\n\tchar errbuf[ERRBUFLEN];\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot receive\"));\n\n\t \n\tdrr = buf;\n\n\twhile (recv_read(hdl, fd, drr, sizeof (dmu_replay_record_t),\n\t    byteswap, NULL) == 0) {\n\t\tif (byteswap)\n\t\t\tdrr->drr_type = BSWAP_32(drr->drr_type);\n\n\t\tswitch (drr->drr_type) {\n\t\tcase DRR_BEGIN:\n\t\t\tif (drr->drr_payloadlen != 0) {\n\t\t\t\t(void) recv_read(hdl, fd, buf,\n\t\t\t\t    drr->drr_payloadlen, B_FALSE, NULL);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DRR_END:\n\t\t\tfree(buf);\n\t\t\treturn (0);\n\n\t\tcase DRR_OBJECT:\n\t\t\tif (byteswap) {\n\t\t\t\tdrr->drr_u.drr_object.drr_bonuslen =\n\t\t\t\t    BSWAP_32(drr->drr_u.drr_object.\n\t\t\t\t    drr_bonuslen);\n\t\t\t\tdrr->drr_u.drr_object.drr_raw_bonuslen =\n\t\t\t\t    BSWAP_32(drr->drr_u.drr_object.\n\t\t\t\t    drr_raw_bonuslen);\n\t\t\t}\n\n\t\t\tpayload_size =\n\t\t\t    DRR_OBJECT_PAYLOAD_SIZE(&drr->drr_u.drr_object);\n\t\t\t(void) recv_read(hdl, fd, buf, payload_size,\n\t\t\t    B_FALSE, NULL);\n\t\t\tbreak;\n\n\t\tcase DRR_WRITE:\n\t\t\tif (byteswap) {\n\t\t\t\tdrr->drr_u.drr_write.drr_logical_size =\n\t\t\t\t    BSWAP_64(\n\t\t\t\t    drr->drr_u.drr_write.drr_logical_size);\n\t\t\t\tdrr->drr_u.drr_write.drr_compressed_size =\n\t\t\t\t    BSWAP_64(\n\t\t\t\t    drr->drr_u.drr_write.drr_compressed_size);\n\t\t\t}\n\t\t\tpayload_size =\n\t\t\t    DRR_WRITE_PAYLOAD_SIZE(&drr->drr_u.drr_write);\n\t\t\tassert(payload_size <= SPA_MAXBLOCKSIZE);\n\t\t\t(void) recv_read(hdl, fd, buf,\n\t\t\t    payload_size, B_FALSE, NULL);\n\t\t\tbreak;\n\t\tcase DRR_SPILL:\n\t\t\tif (byteswap) {\n\t\t\t\tdrr->drr_u.drr_spill.drr_length =\n\t\t\t\t    BSWAP_64(drr->drr_u.drr_spill.drr_length);\n\t\t\t\tdrr->drr_u.drr_spill.drr_compressed_size =\n\t\t\t\t    BSWAP_64(drr->drr_u.drr_spill.\n\t\t\t\t    drr_compressed_size);\n\t\t\t}\n\n\t\t\tpayload_size =\n\t\t\t    DRR_SPILL_PAYLOAD_SIZE(&drr->drr_u.drr_spill);\n\t\t\t(void) recv_read(hdl, fd, buf, payload_size,\n\t\t\t    B_FALSE, NULL);\n\t\t\tbreak;\n\t\tcase DRR_WRITE_EMBEDDED:\n\t\t\tif (byteswap) {\n\t\t\t\tdrr->drr_u.drr_write_embedded.drr_psize =\n\t\t\t\t    BSWAP_32(drr->drr_u.drr_write_embedded.\n\t\t\t\t    drr_psize);\n\t\t\t}\n\t\t\t(void) recv_read(hdl, fd, buf,\n\t\t\t    P2ROUNDUP(drr->drr_u.drr_write_embedded.drr_psize,\n\t\t\t    8), B_FALSE, NULL);\n\t\t\tbreak;\n\t\tcase DRR_OBJECT_RANGE:\n\t\tcase DRR_WRITE_BYREF:\n\t\tcase DRR_FREEOBJECTS:\n\t\tcase DRR_FREE:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"invalid record type\"));\n\t\t\tfree(buf);\n\t\t\treturn (zfs_error(hdl, EZFS_BADSTREAM, errbuf));\n\t\t}\n\t}\n\n\tfree(buf);\n\treturn (-1);\n}\n\nstatic void\nrecv_ecksum_set_aux(libzfs_handle_t *hdl, const char *target_snap,\n    boolean_t resumable, boolean_t checksum)\n{\n\tchar target_fs[ZFS_MAX_DATASET_NAME_LEN];\n\n\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, (checksum ?\n\t    \"checksum mismatch\" : \"incomplete stream\")));\n\n\tif (!resumable)\n\t\treturn;\n\t(void) strlcpy(target_fs, target_snap, sizeof (target_fs));\n\t*strchr(target_fs, '@') = '\\0';\n\tzfs_handle_t *zhp = zfs_open(hdl, target_fs,\n\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\tif (zhp == NULL)\n\t\treturn;\n\n\tchar token_buf[ZFS_MAXPROPLEN];\n\tint error = zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN,\n\t    token_buf, sizeof (token_buf),\n\t    NULL, NULL, 0, B_TRUE);\n\tif (error == 0) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"checksum mismatch or incomplete stream.\\n\"\n\t\t    \"Partially received snapshot is saved.\\n\"\n\t\t    \"A resuming stream can be generated on the sending \"\n\t\t    \"system by running:\\n\"\n\t\t    \"    zfs send -t %s\"),\n\t\t    token_buf);\n\t}\n\tzfs_close(zhp);\n}\n\n \nstatic int\nzfs_setup_cmdline_props(libzfs_handle_t *hdl, zfs_type_t type,\n    char *fsname, boolean_t zoned, boolean_t recursive, boolean_t newfs,\n    boolean_t raw, boolean_t toplevel, nvlist_t *recvprops, nvlist_t *cmdprops,\n    nvlist_t *origprops, nvlist_t **oxprops, uint8_t **wkeydata_out,\n    uint_t *wkeylen_out, const char *errbuf)\n{\n\tnvpair_t *nvp;\n\tnvlist_t *oprops, *voprops;\n\tzfs_handle_t *zhp = NULL;\n\tzpool_handle_t *zpool_hdl = NULL;\n\tchar *cp;\n\tint ret = 0;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\n\tif (nvlist_empty(cmdprops))\n\t\treturn (0);  \n\n\t*oxprops = fnvlist_alloc();\n\toprops = fnvlist_alloc();\n\n\tstrlcpy(namebuf, fsname, ZFS_MAX_DATASET_NAME_LEN);\n\n\t \n\tif (zfs_dataset_exists(hdl, namebuf, ZFS_TYPE_DATASET)) {\n\t\tzhp = zfs_open(hdl, namebuf, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tcp = strchr(namebuf, '/');\n\tif (cp != NULL)\n\t\t*cp = '\\0';\n\tzpool_hdl = zpool_open(hdl, namebuf);\n\tif (zpool_hdl == NULL) {\n\t\tret = -1;\n\t\tgoto error;\n\t}\n\n\t \n\tif (cp != NULL)\n\t\t*cp = '/';\n\n\t \n\tnvp = NULL;\n\twhile ((nvp = nvlist_next_nvpair(cmdprops, nvp)) != NULL) {\n\t\tconst char *name = nvpair_name(nvp);\n\t\tzfs_prop_t prop = zfs_name_to_prop(name);\n\n\t\t \n\t\tconst char *newname = name;\n\t\tif (prop >= ZFS_PROP_TYPE)\n\t\t\tnewname = zfs_prop_to_name(prop);\n\n\t\t \n\t\tif (prop == ZFS_PROP_ORIGIN)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((zfs_prop_encryption_key_param(prop) ||\n\t\t    prop == ZFS_PROP_ENCRYPTION) && raw) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"encryption property '%s' cannot \"\n\t\t\t    \"be set or excluded for raw streams.\"), name);\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif ((zfs_prop_encryption_key_param(prop) || prop ==\n\t\t    ZFS_PROP_ENCRYPTION) && !newfs && recursive && !raw) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((zfs_prop_encryption_key_param(prop) ||\n\t\t    prop == ZFS_PROP_ENCRYPTION) && !newfs &&\n\t\t    nvpair_type(nvp) != DATA_TYPE_BOOLEAN) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"encryption property '%s' cannot \"\n\t\t\t    \"be set for incremental streams.\"), name);\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tswitch (nvpair_type(nvp)) {\n\t\tcase DATA_TYPE_BOOLEAN:  \n\t\t\t \n\t\t\tif (!zfs_prop_valid_for_type(prop, type, B_FALSE) &&\n\t\t\t    !zfs_prop_user(name)) {\n\t\t\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"Warning: %s: property '%s' does not \"\n\t\t\t\t    \"apply to datasets of this type\\n\"),\n\t\t\t\t    fsname, name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (nvlist_exists(origprops, newname)) {\n\t\t\t\tnvlist_t *attrs;\n\t\t\t\tconst char *source = NULL;\n\n\t\t\t\tattrs = fnvlist_lookup_nvlist(origprops,\n\t\t\t\t    newname);\n\t\t\t\tif (nvlist_lookup_string(attrs,\n\t\t\t\t    ZPROP_SOURCE, &source) == 0 &&\n\t\t\t\t    strcmp(source, ZPROP_SOURCE_VAL_RECVD) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (!zfs_prop_user(name) &&  \n\t\t\t    !zfs_prop_inheritable(prop) &&\n\t\t\t    nvlist_exists(recvprops, newname))\n\t\t\t\tfnvlist_remove(recvprops, newname);\n\t\t\telse\n\t\t\t\tfnvlist_add_boolean(*oxprops, newname);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_STRING:  \n\t\t\t \n\t\t\tif (!zfs_prop_valid_for_type(prop, type, B_FALSE) &&\n\t\t\t    !zfs_prop_user(name)) {\n\t\t\t\tif (recursive)\n\t\t\t\t\tcontinue;\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"property '%s' does not apply to datasets \"\n\t\t\t\t    \"of this type\"), name);\n\t\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfnvlist_add_string(oprops, newname,\n\t\t\t    fnvpair_value_string(nvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"property '%s' must be a string or boolean\"), name);\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (toplevel) {\n\t\t \n\t\tif ((voprops = zfs_valid_proplist(hdl, ZFS_TYPE_DATASET,\n\t\t    oprops, zoned, zhp, zpool_hdl, B_FALSE, errbuf)) == NULL) {\n\t\t\tret = zfs_error(hdl, EZFS_BADPROP, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tcp = strrchr(namebuf, '/');\n\t\tif (cp != NULL)\n\t\t\t*cp = '\\0';\n\n\t\tif (!raw && !(!newfs && recursive) &&\n\t\t    zfs_crypto_create(hdl, namebuf, voprops, NULL,\n\t\t    B_FALSE, wkeydata_out, wkeylen_out) != 0) {\n\t\t\tfnvlist_free(voprops);\n\t\t\tret = zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tfnvlist_merge(*oxprops, voprops);\n\t\tfnvlist_free(voprops);\n\t} else {\n\t\t \n\t\tnvp = NULL;\n\t\twhile ((nvp = nvlist_next_nvpair(oprops, nvp)) != NULL) {\n\t\t\tconst char *name = nvpair_name(nvp);\n\t\t\tfnvlist_add_boolean(*oxprops, name);\n\t\t}\n\t}\n\nerror:\n\tif (zhp != NULL)\n\t\tzfs_close(zhp);\n\tif (zpool_hdl != NULL)\n\t\tzpool_close(zpool_hdl);\n\tfnvlist_free(oprops);\n\treturn (ret);\n}\n\n \nstatic int\nzfs_receive_one(libzfs_handle_t *hdl, int infd, const char *tosnap,\n    const char *originsnap, recvflags_t *flags, dmu_replay_record_t *drr,\n    dmu_replay_record_t *drr_noswap, const char *sendfs, nvlist_t *stream_nv,\n    avl_tree_t *stream_avl, char **top_zfs,\n    const char *finalsnap, nvlist_t *cmdprops)\n{\n\tstruct timespec begin_time;\n\tint ioctl_err, ioctl_errno, err;\n\tchar *cp;\n\tstruct drr_begin *drrb = &drr->drr_u.drr_begin;\n\tchar errbuf[ERRBUFLEN];\n\tconst char *chopprefix;\n\tboolean_t newfs = B_FALSE;\n\tboolean_t stream_wantsnewfs, stream_resumingnewfs;\n\tboolean_t newprops = B_FALSE;\n\tuint64_t read_bytes = 0;\n\tuint64_t errflags = 0;\n\tuint64_t parent_snapguid = 0;\n\tprop_changelist_t *clp = NULL;\n\tnvlist_t *snapprops_nvlist = NULL;\n\tnvlist_t *snapholds_nvlist = NULL;\n\tzprop_errflags_t prop_errflags;\n\tnvlist_t *prop_errors = NULL;\n\tboolean_t recursive;\n\tconst char *snapname = NULL;\n\tchar destsnap[MAXPATHLEN * 2];\n\tchar origin[MAXNAMELEN] = {0};\n\tchar name[MAXPATHLEN];\n\tchar tmp_keylocation[MAXNAMELEN] = {0};\n\tnvlist_t *rcvprops = NULL;  \n\tnvlist_t *oxprops = NULL;  \n\tnvlist_t *origprops = NULL;  \n\tzfs_type_t type = ZFS_TYPE_INVALID;\n\tboolean_t toplevel = B_FALSE;\n\tboolean_t zoned = B_FALSE;\n\tboolean_t hastoken = B_FALSE;\n\tboolean_t redacted;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeylen = 0;\n\n#ifndef CLOCK_MONOTONIC_RAW\n#define\tCLOCK_MONOTONIC_RAW CLOCK_MONOTONIC\n#endif\n\tclock_gettime(CLOCK_MONOTONIC_RAW, &begin_time);\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot receive\"));\n\n\trecursive = (nvlist_lookup_boolean(stream_nv, \"not_recursive\") ==\n\t    ENOENT);\n\n\t \n\tboolean_t holds = flags->holds && !flags->skipholds;\n\n\tif (stream_avl != NULL) {\n\t\tconst char *keylocation = NULL;\n\t\tnvlist_t *lookup = NULL;\n\t\tnvlist_t *fs = fsavl_find(stream_avl, drrb->drr_toguid,\n\t\t    &snapname);\n\n\t\t(void) nvlist_lookup_uint64(fs, \"parentfromsnap\",\n\t\t    &parent_snapguid);\n\t\terr = nvlist_lookup_nvlist(fs, \"props\", &rcvprops);\n\t\tif (err) {\n\t\t\trcvprops = fnvlist_alloc();\n\t\t\tnewprops = B_TRUE;\n\t\t}\n\n\t\t \n\t\terr = nvlist_lookup_string(rcvprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), &keylocation);\n\t\tif (err == 0) {\n\t\t\tstrlcpy(tmp_keylocation, keylocation, MAXNAMELEN);\n\t\t\t(void) nvlist_remove_all(rcvprops,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION));\n\t\t}\n\n\t\tif (flags->canmountoff) {\n\t\t\tfnvlist_add_uint64(rcvprops,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_CANMOUNT), 0);\n\t\t} else if (newprops) {\t \n\t\t\tfnvlist_free(rcvprops);\n\t\t\trcvprops = NULL;\n\t\t\tnewprops = B_FALSE;\n\t\t}\n\t\tif (0 == nvlist_lookup_nvlist(fs, \"snapprops\", &lookup)) {\n\t\t\tsnapprops_nvlist = fnvlist_lookup_nvlist(lookup,\n\t\t\t    snapname);\n\t\t}\n\t\tif (holds) {\n\t\t\tif (0 == nvlist_lookup_nvlist(fs, \"snapholds\",\n\t\t\t    &lookup)) {\n\t\t\t\tsnapholds_nvlist = fnvlist_lookup_nvlist(\n\t\t\t\t    lookup, snapname);\n\t\t\t}\n\t\t}\n\t}\n\n\tcp = NULL;\n\n\t \n\tif (flags->istail) {\n\t\t \n\t\tif (strchr(tosnap, '@')) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t\t    \"argument - snapshot not allowed with -e\"));\n\t\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tchopprefix = strrchr(sendfs, '/');\n\n\t\tif (chopprefix == NULL) {\n\t\t\t \n\t\t\tint len = strlen(drrb->drr_toname);\n\t\t\tcp = umem_alloc(len + 2, UMEM_NOFAIL);\n\t\t\tcp[0] = '/';\n\t\t\t(void) strcpy(&cp[1], drrb->drr_toname);\n\t\t\tchopprefix = cp;\n\t\t} else {\n\t\t\tchopprefix = drrb->drr_toname + (chopprefix - sendfs);\n\t\t}\n\t} else if (flags->isprefix) {\n\t\t \n\t\tif (strchr(tosnap, '@')) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t\t    \"argument - snapshot not allowed with -d\"));\n\t\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tchopprefix = strchr(drrb->drr_toname, '/');\n\t\tif (chopprefix == NULL)\n\t\t\tchopprefix = strchr(drrb->drr_toname, '@');\n\t} else if (strchr(tosnap, '@') == NULL) {\n\t\t \n\t\tchopprefix = drrb->drr_toname + strlen(sendfs);\n\t} else {\n\t\t \n\t\tif (recursive) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot specify snapshot name for multi-snapshot \"\n\t\t\t    \"stream\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tchopprefix = drrb->drr_toname + strlen(drrb->drr_toname);\n\t}\n\n\tASSERT(strstr(drrb->drr_toname, sendfs) == drrb->drr_toname);\n\tASSERT(chopprefix > drrb->drr_toname || strchr(sendfs, '/') == NULL);\n\tASSERT(chopprefix <= drrb->drr_toname + strlen(drrb->drr_toname) ||\n\t    strchr(sendfs, '/') == NULL);\n\tASSERT(chopprefix[0] == '/' || chopprefix[0] == '@' ||\n\t    chopprefix[0] == '\\0');\n\n\t \n\t(void) strlcpy(destsnap, tosnap, sizeof (destsnap));\n\t(void) strlcat(destsnap, chopprefix, sizeof (destsnap));\n\tif (cp != NULL)\n\t\tumem_free(cp, strlen(cp) + 1);\n\tif (!zfs_name_valid(destsnap, ZFS_TYPE_SNAPSHOT)) {\n\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\tgoto out;\n\t}\n\n\t \n\tif (originsnap) {\n\t\t(void) strlcpy(origin, originsnap, sizeof (origin));\n\t\tif (flags->verbose)\n\t\t\t(void) printf(\"using provided clone origin %s\\n\",\n\t\t\t    origin);\n\t} else if (drrb->drr_flags & DRR_FLAG_CLONE) {\n\t\tif (guid_to_name(hdl, destsnap,\n\t\t    drrb->drr_fromguid, B_FALSE, origin) != 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"local origin for clone %s does not exist\"),\n\t\t\t    destsnap);\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (flags->verbose)\n\t\t\t(void) printf(\"found clone origin %s\\n\", origin);\n\t}\n\n\tif ((DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_DEDUP)) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"ERROR: \\\"zfs receive\\\" no longer supports \"\n\t\t    \"deduplicated send streams.  Use\\n\"\n\t\t    \"the \\\"zstream redup\\\" command to convert this stream \"\n\t\t    \"to a regular,\\n\"\n\t\t    \"non-deduplicated stream.\\n\"));\n\t\terr = zfs_error(hdl, EZFS_NOTSUP, errbuf);\n\t\tgoto out;\n\t}\n\n\tboolean_t resuming = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_RESUMING;\n\tboolean_t raw = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_RAW;\n\tboolean_t embedded = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_EMBED_DATA;\n\tstream_wantsnewfs = (drrb->drr_fromguid == 0 ||\n\t    (drrb->drr_flags & DRR_FLAG_CLONE) || originsnap) && !resuming;\n\tstream_resumingnewfs = (drrb->drr_fromguid == 0 ||\n\t    (drrb->drr_flags & DRR_FLAG_CLONE) || originsnap) && resuming;\n\n\tif (stream_wantsnewfs) {\n\t\t \n\t\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t\t    \"cannot receive new filesystem stream\"));\n\n\t\t(void) strlcpy(name, destsnap, sizeof (name));\n\t\tcp = strrchr(name, '/');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tif (cp &&\n\t\t    !zfs_dataset_exists(hdl, name, ZFS_TYPE_DATASET)) {\n\t\t\tchar suffix[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t(void) strlcpy(suffix, strrchr(destsnap, '/'),\n\t\t\t    sizeof (suffix));\n\t\t\tif (guid_to_name(hdl, name, parent_snapguid,\n\t\t\t    B_FALSE, destsnap) == 0) {\n\t\t\t\t*strchr(destsnap, '@') = '\\0';\n\t\t\t\t(void) strlcat(destsnap, suffix,\n\t\t\t\t    sizeof (destsnap));\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (resuming) {\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot receive resume stream\"));\n\t\t} else {\n\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot receive incremental stream\"));\n\t\t}\n\n\t\t(void) strlcpy(name, destsnap, sizeof (name));\n\t\t*strchr(name, '@') = '\\0';\n\n\t\t \n\t\tif ((flags->isprefix || (*(chopprefix = drrb->drr_toname +\n\t\t    strlen(sendfs)) != '\\0' && *chopprefix != '@')) &&\n\t\t    !zfs_dataset_exists(hdl, name, ZFS_TYPE_DATASET)) {\n\t\t\tchar snap[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t(void) strlcpy(snap, strchr(destsnap, '@'),\n\t\t\t    sizeof (snap));\n\t\t\tif (guid_to_name(hdl, name, drrb->drr_fromguid,\n\t\t\t    B_FALSE, destsnap) == 0) {\n\t\t\t\t*strchr(destsnap, '@') = '\\0';\n\t\t\t\t(void) strlcat(destsnap, snap,\n\t\t\t\t    sizeof (destsnap));\n\t\t\t}\n\t\t}\n\t}\n\n\t(void) strlcpy(name, destsnap, sizeof (name));\n\t*strchr(name, '@') = '\\0';\n\n\tredacted = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo) &\n\t    DMU_BACKUP_FEATURE_REDACTED;\n\n\tif (flags->heal) {\n\t\tif (flags->isprefix || flags->istail || flags->force ||\n\t\t    flags->canmountoff || flags->resumable || flags->nomount ||\n\t\t    flags->skipholds) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"corrective recv can not be used when combined with\"\n\t\t\t    \" this flag\"));\n\t\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tuint64_t guid =\n\t\t    get_snap_guid(hdl, name, strchr(destsnap, '@') + 1);\n\t\tif (guid == 0) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"corrective recv must specify an existing snapshot\"\n\t\t\t    \" to heal\"));\n\t\t\terr = zfs_error(hdl, EZFS_INVALIDNAME, errbuf);\n\t\t\tgoto out;\n\t\t} else if (guid != drrb->drr_toguid) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"local snapshot doesn't match the snapshot\"\n\t\t\t    \" in the provided stream\"));\n\t\t\terr = zfs_error(hdl, EZFS_WRONG_PARENT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t} else if (zfs_dataset_exists(hdl, name, ZFS_TYPE_DATASET)) {\n\t\tzfs_cmd_t zc = {\"\\0\"};\n\t\tzfs_handle_t *zhp = NULL;\n\t\tboolean_t encrypted;\n\n\t\t(void) strcpy(zc.zc_name, name);\n\n\t\t \n\t\tif (stream_wantsnewfs) {\n\t\t\tboolean_t is_volume = drrb->drr_type == DMU_OST_ZVOL;\n\t\t\tif (!flags->force) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination '%s' exists\\n\"\n\t\t\t\t    \"must specify -F to overwrite it\"), name);\n\t\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (zfs_ioctl(hdl, ZFS_IOC_SNAPSHOT_LIST_NEXT,\n\t\t\t    &zc) == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination has snapshots (eg. %s)\\n\"\n\t\t\t\t    \"must destroy them to overwrite it\"),\n\t\t\t\t    zc.zc_name);\n\t\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_volume && strrchr(name, '/') == NULL) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination %s is the root dataset\\n\"\n\t\t\t\t    \"cannot overwrite with a ZVOL\"),\n\t\t\t\t    name);\n\t\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_volume &&\n\t\t\t    zfs_ioctl(hdl, ZFS_IOC_DATASET_LIST_NEXT,\n\t\t\t    &zc) == 0) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination has children (eg. %s)\\n\"\n\t\t\t\t    \"cannot overwrite with a ZVOL\"),\n\t\t\t\t    zc.zc_name);\n\t\t\t\terr = zfs_error(hdl, EZFS_WRONG_PARENT, errbuf);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif ((zhp = zfs_open(hdl, name,\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME)) == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (stream_resumingnewfs &&\n\t\t    !zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) &&\n\t\t    !flags->force) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Resuming recv on existing destination '%s'\\n\"\n\t\t\t    \"must specify -F to overwrite it\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_RESUME_EXISTS, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (stream_wantsnewfs &&\n\t\t    zhp->zfs_dmustats.dds_origin[0]) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination '%s' is a clone\\n\"\n\t\t\t    \"must destroy it to overwrite it\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_EXISTS, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tencrypted = zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) !=\n\t\t    ZIO_CRYPT_OFF;\n\t\tif (!stream_wantsnewfs && !encrypted && raw) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"cannot perform raw receive on top of \"\n\t\t\t    \"existing unencrypted dataset\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (stream_wantsnewfs && flags->force &&\n\t\t    ((raw && !encrypted) || encrypted)) {\n\t\t\tzfs_close(zhp);\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"zfs receive -F cannot be used to destroy an \"\n\t\t\t    \"encrypted filesystem or overwrite an \"\n\t\t\t    \"unencrypted one with an encrypted one\"));\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!flags->dryrun && zhp->zfs_type == ZFS_TYPE_FILESYSTEM &&\n\t\t    (stream_wantsnewfs || stream_resumingnewfs)) {\n\t\t\t \n\t\t\tclp = changelist_gather(zhp, ZFS_PROP_NAME, 0,\n\t\t\t    flags->forceunmount ? MS_FORCE : 0);\n\t\t\tif (clp == NULL) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (changelist_prefix(clp) != 0) {\n\t\t\t\tchangelist_free(clp);\n\t\t\t\tzfs_close(zhp);\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (resuming && zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT))\n\t\t\tnewfs = B_TRUE;\n\n\t\t \n\t\tzoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\n\t\t \n\t\tif (zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN, NULL, 0,\n\t\t    NULL, NULL, 0, B_TRUE) == 0)\n\t\t\thastoken = B_TRUE;\n\n\t\t \n\t\torigprops = fnvlist_alloc();\n\t\tfnvlist_merge(origprops, zhp->zfs_props);\n\t\tfnvlist_merge(origprops, zhp->zfs_user_props);\n\n\t\tzfs_close(zhp);\n\t} else {\n\t\tzfs_handle_t *zhp;\n\n\t\t \n\t\tcp = strrchr(name, '/');\n\n\t\tif (!stream_wantsnewfs || cp == NULL) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination '%s' does not exist\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_NOENT, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\t*cp = '\\0';\n\n\t\tif (flags->isprefix && !flags->istail && !flags->dryrun &&\n\t\t    create_parents(hdl, destsnap, strlen(tosnap)) != 0) {\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tzhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\terr = zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tif (zfs_get_type(zhp) != ZFS_TYPE_FILESYSTEM) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"parent '%s' is not a filesystem\"), name);\n\t\t\terr = zfs_error(hdl, EZFS_WRONG_PARENT, errbuf);\n\t\t\tzfs_close(zhp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tzfs_close(zhp);\n\n\t\tnewfs = B_TRUE;\n\t\t*cp = '/';\n\t}\n\n\tif (flags->verbose) {\n\t\t(void) printf(\"%s %s%s stream of %s into %s\\n\",\n\t\t    flags->dryrun ? \"would receive\" : \"receiving\",\n\t\t    flags->heal ? \" corrective\" : \"\",\n\t\t    drrb->drr_fromguid ? \"incremental\" : \"full\",\n\t\t    drrb->drr_toname, destsnap);\n\t\t(void) fflush(stdout);\n\t}\n\n\t \n\tif (top_zfs != NULL &&\n\t    (*top_zfs == NULL || strcmp(*top_zfs, name) == 0)) {\n\t\ttoplevel = B_TRUE;\n\t\tif (*top_zfs == NULL)\n\t\t\t*top_zfs = zfs_strdup(hdl, name);\n\t}\n\n\tif (drrb->drr_type == DMU_OST_ZVOL) {\n\t\ttype = ZFS_TYPE_VOLUME;\n\t} else if (drrb->drr_type == DMU_OST_ZFS) {\n\t\ttype = ZFS_TYPE_FILESYSTEM;\n\t} else {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid record type: 0x%d\"), drrb->drr_type);\n\t\terr = zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\tgoto out;\n\t}\n\tif ((err = zfs_setup_cmdline_props(hdl, type, name, zoned, recursive,\n\t    stream_wantsnewfs, raw, toplevel, rcvprops, cmdprops, origprops,\n\t    &oxprops, &wkeydata, &wkeylen, errbuf)) != 0)\n\t\tgoto out;\n\n\t \n\tif (stream_wantsnewfs && !raw && rcvprops != NULL &&\n\t    !nvlist_exists(cmdprops, zfs_prop_to_name(ZFS_PROP_ENCRYPTION))) {\n\t\tif (oxprops == NULL)\n\t\t\toxprops = fnvlist_alloc();\n\t\tfnvlist_add_uint64(oxprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_ENCRYPTION), ZIO_CRYPT_OFF);\n\t}\n\n\tif (flags->dryrun) {\n\t\tvoid *buf = zfs_alloc(hdl, SPA_MAXBLOCKSIZE);\n\n\t\t \n\t\terr = recv_read(hdl, infd, buf, drr->drr_payloadlen,\n\t\t    flags->byteswap, NULL);\n\t\tfree(buf);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\terr = recv_skip(hdl, infd, flags->byteswap);\n\t\tgoto out;\n\t}\n\n\tif (flags->heal) {\n\t\terr = ioctl_err = lzc_receive_with_heal(destsnap, rcvprops,\n\t\t    oxprops, wkeydata, wkeylen, origin, flags->force,\n\t\t    flags->heal, flags->resumable, raw, infd, drr_noswap, -1,\n\t\t    &read_bytes, &errflags, NULL, &prop_errors);\n\t} else {\n\t\terr = ioctl_err = lzc_receive_with_cmdprops(destsnap, rcvprops,\n\t\t    oxprops, wkeydata, wkeylen, origin, flags->force,\n\t\t    flags->resumable, raw, infd, drr_noswap, -1, &read_bytes,\n\t\t    &errflags, NULL, &prop_errors);\n\t}\n\tioctl_errno = ioctl_err;\n\tprop_errflags = errflags;\n\n\tif (err == 0) {\n\t\tnvpair_t *prop_err = NULL;\n\n\t\twhile ((prop_err = nvlist_next_nvpair(prop_errors,\n\t\t    prop_err)) != NULL) {\n\t\t\tchar tbuf[1024];\n\t\t\tzfs_prop_t prop;\n\t\t\tint intval;\n\n\t\t\tprop = zfs_name_to_prop(nvpair_name(prop_err));\n\t\t\t(void) nvpair_value_int32(prop_err, &intval);\n\t\t\tif (strcmp(nvpair_name(prop_err),\n\t\t\t    ZPROP_N_MORE_ERRORS) == 0) {\n\t\t\t\ttrunc_prop_errs(intval);\n\t\t\t\tbreak;\n\t\t\t} else if (snapname == NULL || finalsnap == NULL ||\n\t\t\t    strcmp(finalsnap, snapname) == 0 ||\n\t\t\t    strcmp(nvpair_name(prop_err),\n\t\t\t    zfs_prop_to_name(ZFS_PROP_REFQUOTA)) != 0) {\n\t\t\t\t \n\t\t\t\t(void) snprintf(tbuf, sizeof (tbuf),\n\t\t\t\t    dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"cannot receive %s property on %s\"),\n\t\t\t\t    nvpair_name(prop_err), name);\n\t\t\t\tzfs_setprop_error(hdl, prop, intval, tbuf);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err == 0 && snapprops_nvlist) {\n\t\tzfs_cmd_t zc = {\"\\0\"};\n\n\t\t(void) strlcpy(zc.zc_name, destsnap, sizeof (zc.zc_name));\n\t\tzc.zc_cookie = B_TRUE;  \n\t\tzcmd_write_src_nvlist(hdl, &zc, snapprops_nvlist);\n\t\t(void) zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc);\n\t\tzcmd_free_nvlists(&zc);\n\t}\n\tif (err == 0 && snapholds_nvlist) {\n\t\tnvpair_t *pair;\n\t\tnvlist_t *holds, *errors = NULL;\n\t\tint cleanup_fd = -1;\n\n\t\tVERIFY(0 == nvlist_alloc(&holds, 0, KM_SLEEP));\n\t\tfor (pair = nvlist_next_nvpair(snapholds_nvlist, NULL);\n\t\t    pair != NULL;\n\t\t    pair = nvlist_next_nvpair(snapholds_nvlist, pair)) {\n\t\t\tfnvlist_add_string(holds, destsnap, nvpair_name(pair));\n\t\t}\n\t\t(void) lzc_hold(holds, cleanup_fd, &errors);\n\t\tfnvlist_free(snapholds_nvlist);\n\t\tfnvlist_free(holds);\n\t}\n\n\tif (err && (ioctl_errno == ENOENT || ioctl_errno == EEXIST)) {\n\t\t \n\t\tavl_tree_t *local_avl;\n\t\tnvlist_t *local_nv, *fs;\n\t\tcp = strchr(destsnap, '@');\n\n\t\t \n\t\t*cp = '\\0';\n\t\tif (gather_nvlist(hdl, destsnap, NULL, NULL, B_FALSE, B_TRUE,\n\t\t    B_FALSE, B_FALSE, B_FALSE, B_FALSE, B_FALSE, B_FALSE,\n\t\t    B_TRUE, &local_nv, &local_avl) == 0) {\n\t\t\t*cp = '@';\n\t\t\tfs = fsavl_find(local_avl, drrb->drr_toguid, NULL);\n\t\t\tfsavl_destroy(local_avl);\n\t\t\tfnvlist_free(local_nv);\n\n\t\t\tif (fs != NULL) {\n\t\t\t\tif (flags->verbose) {\n\t\t\t\t\t(void) printf(\"snap %s already exists; \"\n\t\t\t\t\t    \"ignoring\\n\", destsnap);\n\t\t\t\t}\n\t\t\t\terr = ioctl_err = recv_skip(hdl, infd,\n\t\t\t\t    flags->byteswap);\n\t\t\t}\n\t\t}\n\t\t*cp = '@';\n\t}\n\n\tif (ioctl_err != 0) {\n\t\tswitch (ioctl_errno) {\n\t\tcase ENODEV:\n\t\t\tcp = strchr(destsnap, '@');\n\t\t\t*cp = '\\0';\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"most recent snapshot of %s does not\\n\"\n\t\t\t    \"match incremental source\"), destsnap);\n\t\t\t(void) zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\t*cp = '@';\n\t\t\tbreak;\n\t\tcase ETXTBSY:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination %s has been modified\\n\"\n\t\t\t    \"since most recent snapshot\"), name);\n\t\t\t(void) zfs_error(hdl, EZFS_BADRESTORE, errbuf);\n\t\t\tbreak;\n\t\tcase EACCES:\n\t\t\tif (flags->heal) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"key must be loaded to do a non-raw \"\n\t\t\t\t    \"corrective recv on an encrypted \"\n\t\t\t\t    \"dataset.\"));\n\t\t\t} else if (raw && stream_wantsnewfs) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"failed to create encryption key\"));\n\t\t\t} else if (raw && !stream_wantsnewfs) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"encryption key does not match \"\n\t\t\t\t    \"existing key\"));\n\t\t\t} else {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"inherited key must be loaded\"));\n\t\t\t}\n\t\t\t(void) zfs_error(hdl, EZFS_CRYPTOFAILED, errbuf);\n\t\t\tbreak;\n\t\tcase EEXIST:\n\t\t\tcp = strchr(destsnap, '@');\n\t\t\tif (newfs) {\n\t\t\t\t \n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination already exists\"));\n\t\t\t(void) zfs_error_fmt(hdl, EZFS_EXISTS,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot restore to %s\"),\n\t\t\t    destsnap);\n\t\t\t*cp = '@';\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\tif (embedded && !raw) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"incompatible embedded data stream \"\n\t\t\t\t    \"feature with encrypted receive.\"));\n\t\t\t} else if (flags->resumable) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"kernel modules must be upgraded to \"\n\t\t\t\t    \"receive this stream.\"));\n\t\t\t}\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ECKSUM:\n\t\tcase ZFS_ERR_STREAM_TRUNCATED:\n\t\t\tif (flags->heal)\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"corrective receive was not able to \"\n\t\t\t\t    \"reconstruct the data needed for \"\n\t\t\t\t    \"healing.\"));\n\t\t\telse\n\t\t\t\trecv_ecksum_set_aux(hdl, destsnap,\n\t\t\t\t    flags->resumable, ioctl_err == ECKSUM);\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_STREAM_LARGE_BLOCK_MISMATCH:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"incremental send stream requires -L \"\n\t\t\t    \"(--large-block), to match previous receive.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ENOTSUP:\n\t\t\tif (flags->heal)\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"stream is not compatible with the \"\n\t\t\t\t    \"data in the pool.\"));\n\t\t\telse\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"pool must be upgraded to receive this \"\n\t\t\t\t    \"stream.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_CRYPTO_NOTSUP:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"stream uses crypto parameters not compatible with \"\n\t\t\t    \"this pool\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase EDQUOT:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"destination %s space quota exceeded.\"), name);\n\t\t\t(void) zfs_error(hdl, EZFS_NOSPC, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_FROM_IVSET_GUID_MISSING:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"IV set guid missing. See errata %u at \"\n\t\t\t    \"https://openzfs.github.io/openzfs-docs/msg/\"\n\t\t\t    \"ZFS-8000-ER.\"),\n\t\t\t    ZPOOL_ERRATA_ZOL_8308_ENCRYPTION);\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_FROM_IVSET_GUID_MISMATCH:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"IV set guid mismatch. See the 'zfs receive' \"\n\t\t\t    \"man page section\\n discussing the limitations \"\n\t\t\t    \"of raw encrypted send streams.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_SPILL_BLOCK_FLAG_MISSING:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Spill block flag missing for raw send.\\n\"\n\t\t\t    \"The zfs software on the sending system must \"\n\t\t\t    \"be updated.\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase ZFS_ERR_RESUME_EXISTS:\n\t\t\tcp = strchr(destsnap, '@');\n\t\t\tif (newfs) {\n\t\t\t\t \n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"Resuming recv on existing dataset without force\"));\n\t\t\t(void) zfs_error_fmt(hdl, EZFS_RESUME_EXISTS,\n\t\t\t    dgettext(TEXT_DOMAIN, \"cannot resume recv %s\"),\n\t\t\t    destsnap);\n\t\t\t*cp = '@';\n\t\t\tbreak;\n\t\tcase E2BIG:\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"zfs receive required kernel memory allocation \"\n\t\t\t    \"larger than the system can support. Please file \"\n\t\t\t    \"an issue at the OpenZFS issue tracker:\\n\"\n\t\t\t    \"https://github.com/openzfs/zfs/issues/new\"));\n\t\t\t(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (hastoken) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"destination %s contains \"\n\t\t\t\t    \"partially-complete state from \"\n\t\t\t\t    \"\\\"zfs receive -s\\\".\"), name);\n\t\t\t\t(void) zfs_error(hdl, EZFS_BUSY, errbuf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzfs_fallthrough;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(hdl, ioctl_errno, errbuf);\n\t\t}\n\t}\n\n\t \n\tif (clp) {\n\t\tif (!flags->nomount)\n\t\t\terr |= changelist_postfix(clp);\n\t\tchangelist_free(clp);\n\t}\n\n\tif ((newfs || stream_avl) && type == ZFS_TYPE_FILESYSTEM && !redacted)\n\t\tflags->domount = B_TRUE;\n\n\tif (prop_errflags & ZPROP_ERR_NOCLEAR) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN, \"Warning: \"\n\t\t    \"failed to clear unreceived properties on %s\"), name);\n\t\t(void) fprintf(stderr, \"\\n\");\n\t}\n\tif (prop_errflags & ZPROP_ERR_NORESTORE) {\n\t\t(void) fprintf(stderr, dgettext(TEXT_DOMAIN, \"Warning: \"\n\t\t    \"failed to restore original properties on %s\"), name);\n\t\t(void) fprintf(stderr, \"\\n\");\n\t}\n\n\tif (err || ioctl_err) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tif (flags->verbose) {\n\t\tchar buf1[64];\n\t\tchar buf2[64];\n\t\tuint64_t bytes = read_bytes;\n\t\tstruct timespec delta;\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &delta);\n\t\tif (begin_time.tv_nsec > delta.tv_nsec) {\n\t\t\tdelta.tv_nsec =\n\t\t\t    1000000000 + delta.tv_nsec - begin_time.tv_nsec;\n\t\t\tdelta.tv_sec -= 1;\n\t\t} else\n\t\t\tdelta.tv_nsec -= begin_time.tv_nsec;\n\t\tdelta.tv_sec -= begin_time.tv_sec;\n\t\tif (delta.tv_sec == 0 && delta.tv_nsec == 0)\n\t\t\tdelta.tv_nsec = 1;\n\t\tdouble delta_f = delta.tv_sec + (delta.tv_nsec / 1e9);\n\t\tzfs_nicebytes(bytes, buf1, sizeof (buf1));\n\t\tzfs_nicebytes(bytes / delta_f, buf2, sizeof (buf2));\n\n\t\t(void) printf(\"received %s stream in %.2f seconds (%s/sec)\\n\",\n\t\t    buf1, delta_f, buf2);\n\t}\n\n\terr = 0;\nout:\n\tif (prop_errors != NULL)\n\t\tfnvlist_free(prop_errors);\n\n\tif (tmp_keylocation[0] != '\\0') {\n\t\tfnvlist_add_string(rcvprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), tmp_keylocation);\n\t}\n\n\tif (newprops)\n\t\tfnvlist_free(rcvprops);\n\n\tfnvlist_free(oxprops);\n\tfnvlist_free(origprops);\n\n\treturn (err);\n}\n\n \nstatic boolean_t\nzfs_receive_checkprops(libzfs_handle_t *hdl, nvlist_t *props,\n    const char *errbuf)\n{\n\tnvpair_t *nvp = NULL;\n\tzfs_prop_t prop;\n\tconst char *name;\n\n\twhile ((nvp = nvlist_next_nvpair(props, nvp)) != NULL) {\n\t\tname = nvpair_name(nvp);\n\t\tprop = zfs_name_to_prop(name);\n\n\t\tif (prop == ZPROP_USERPROP) {\n\t\t\tif (!zfs_prop_user(name)) {\n\t\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t\t    \"%s: invalid property '%s'\"), errbuf, name);\n\t\t\t\treturn (B_FALSE);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (prop == ZFS_PROP_ORIGIN)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (prop == ZFS_PROP_ENCRYPTION ||\n\t\t    zfs_prop_encryption_key_param(prop))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (zfs_prop_readonly(prop) || prop == ZFS_PROP_VERSION ||\n\t\t    prop == ZFS_PROP_VOLSIZE) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"%s: invalid property '%s'\"), errbuf, name);\n\t\t\treturn (B_FALSE);\n\t\t}\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic int\nzfs_receive_impl(libzfs_handle_t *hdl, const char *tosnap,\n    const char *originsnap, recvflags_t *flags, int infd, const char *sendfs,\n    nvlist_t *stream_nv, avl_tree_t *stream_avl, char **top_zfs,\n    const char *finalsnap, nvlist_t *cmdprops)\n{\n\tint err;\n\tdmu_replay_record_t drr, drr_noswap;\n\tstruct drr_begin *drrb = &drr.drr_u.drr_begin;\n\tchar errbuf[ERRBUFLEN];\n\tzio_cksum_t zcksum = { { 0 } };\n\tuint64_t featureflags;\n\tint hdrtype;\n\n\t(void) snprintf(errbuf, sizeof (errbuf), dgettext(TEXT_DOMAIN,\n\t    \"cannot receive\"));\n\n\t \n\tif (!zfs_receive_checkprops(hdl, cmdprops, errbuf))\n\t\treturn (zfs_error(hdl, EZFS_BADPROP, errbuf));\n\n\tif (flags->isprefix &&\n\t    !zfs_dataset_exists(hdl, tosnap, ZFS_TYPE_DATASET)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"specified fs \"\n\t\t    \"(%s) does not exist\"), tosnap);\n\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\t}\n\tif (originsnap &&\n\t    !zfs_dataset_exists(hdl, originsnap, ZFS_TYPE_DATASET)) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"specified origin fs \"\n\t\t    \"(%s) does not exist\"), originsnap);\n\t\treturn (zfs_error(hdl, EZFS_NOENT, errbuf));\n\t}\n\n\t \n\tif (0 != (err = recv_read(hdl, infd, &drr, sizeof (drr), B_FALSE,\n\t    &zcksum)))\n\t\treturn (err);\n\n\tif (drr.drr_type == DRR_END || drr.drr_type == BSWAP_32(DRR_END)) {\n\t\t \n\t\treturn (ENODATA);\n\t}\n\n\t \n\tdrr_noswap = drr;\n\n\tflags->byteswap = B_FALSE;\n\tif (drrb->drr_magic == BSWAP_64(DMU_BACKUP_MAGIC)) {\n\t\t \n\t\tmemset(&zcksum, 0, sizeof (zio_cksum_t));\n\t\tfletcher_4_incremental_byteswap(&drr, sizeof (drr), &zcksum);\n\t\tflags->byteswap = B_TRUE;\n\n\t\tdrr.drr_type = BSWAP_32(drr.drr_type);\n\t\tdrr.drr_payloadlen = BSWAP_32(drr.drr_payloadlen);\n\t\tdrrb->drr_magic = BSWAP_64(drrb->drr_magic);\n\t\tdrrb->drr_versioninfo = BSWAP_64(drrb->drr_versioninfo);\n\t\tdrrb->drr_creation_time = BSWAP_64(drrb->drr_creation_time);\n\t\tdrrb->drr_type = BSWAP_32(drrb->drr_type);\n\t\tdrrb->drr_flags = BSWAP_32(drrb->drr_flags);\n\t\tdrrb->drr_toguid = BSWAP_64(drrb->drr_toguid);\n\t\tdrrb->drr_fromguid = BSWAP_64(drrb->drr_fromguid);\n\t}\n\n\tif (drrb->drr_magic != DMU_BACKUP_MAGIC || drr.drr_type != DRR_BEGIN) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t    \"stream (bad magic number)\"));\n\t\treturn (zfs_error(hdl, EZFS_BADSTREAM, errbuf));\n\t}\n\n\tfeatureflags = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo);\n\thdrtype = DMU_GET_STREAM_HDRTYPE(drrb->drr_versioninfo);\n\n\tif (!DMU_STREAM_SUPPORTED(featureflags) ||\n\t    (hdrtype != DMU_SUBSTREAM && hdrtype != DMU_COMPOUNDSTREAM)) {\n\t\t \n\t\tif (featureflags & DMU_BACKUP_FEATURE_DEDUP) {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"stream has deprecated feature: dedup, try \"\n\t\t\t    \"'zstream redup [send in a file] | zfs recv \"\n\t\t\t    \"[...]'\"));\n\t\t} else {\n\t\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN,\n\t\t\t    \"stream has unsupported feature, feature flags = \"\n\t\t\t    \"%llx (unknown flags = %llx)\"),\n\t\t\t    (u_longlong_t)featureflags,\n\t\t\t    (u_longlong_t)((featureflags) &\n\t\t\t    ~DMU_BACKUP_FEATURE_MASK));\n\t\t}\n\t\treturn (zfs_error(hdl, EZFS_BADSTREAM, errbuf));\n\t}\n\n\t \n\tif (featureflags & DMU_BACKUP_FEATURE_HOLDS)\n\t\tflags->holds = B_TRUE;\n\n\tif (strchr(drrb->drr_toname, '@') == NULL) {\n\t\tzfs_error_aux(hdl, dgettext(TEXT_DOMAIN, \"invalid \"\n\t\t    \"stream (bad snapshot name)\"));\n\t\treturn (zfs_error(hdl, EZFS_BADSTREAM, errbuf));\n\t}\n\n\tif (DMU_GET_STREAM_HDRTYPE(drrb->drr_versioninfo) == DMU_SUBSTREAM) {\n\t\tchar nonpackage_sendfs[ZFS_MAX_DATASET_NAME_LEN];\n\t\tif (sendfs == NULL) {\n\t\t\t \n\t\t\tchar *cp;\n\t\t\t(void) strlcpy(nonpackage_sendfs,\n\t\t\t    drr.drr_u.drr_begin.drr_toname,\n\t\t\t    sizeof (nonpackage_sendfs));\n\t\t\tif ((cp = strchr(nonpackage_sendfs, '@')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tsendfs = nonpackage_sendfs;\n\t\t\tVERIFY(finalsnap == NULL);\n\t\t}\n\t\treturn (zfs_receive_one(hdl, infd, tosnap, originsnap, flags,\n\t\t    &drr, &drr_noswap, sendfs, stream_nv, stream_avl, top_zfs,\n\t\t    finalsnap, cmdprops));\n\t} else {\n\t\tassert(DMU_GET_STREAM_HDRTYPE(drrb->drr_versioninfo) ==\n\t\t    DMU_COMPOUNDSTREAM);\n\t\treturn (zfs_receive_package(hdl, infd, tosnap, flags, &drr,\n\t\t    &zcksum, top_zfs, cmdprops));\n\t}\n}\n\n \nint\nzfs_receive(libzfs_handle_t *hdl, const char *tosnap, nvlist_t *props,\n    recvflags_t *flags, int infd, avl_tree_t *stream_avl)\n{\n\tchar *top_zfs = NULL;\n\tint err;\n\tstruct stat sb;\n\tconst char *originsnap = NULL;\n\n\t \n\tif (fstat(infd, &sb) == -1) {\n\t\tperror(\"fstat\");\n\t\treturn (-2);\n\t}\n\n\tif (props) {\n\t\terr = nvlist_lookup_string(props, \"origin\", &originsnap);\n\t\tif (err && err != ENOENT)\n\t\t\treturn (err);\n\t}\n\n\terr = zfs_receive_impl(hdl, tosnap, originsnap, flags, infd, NULL, NULL,\n\t    stream_avl, &top_zfs, NULL, props);\n\n\tif (err == 0 && !flags->nomount && flags->domount && top_zfs) {\n\t\tzfs_handle_t *zhp = NULL;\n\t\tprop_changelist_t *clp = NULL;\n\n\t\tzhp = zfs_open(hdl, top_zfs,\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\tif (zhp == NULL) {\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (zhp->zfs_type == ZFS_TYPE_VOLUME) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tclp = changelist_gather(zhp, ZFS_PROP_MOUNTPOINT,\n\t\t\t    CL_GATHER_MOUNT_ALWAYS,\n\t\t\t    flags->forceunmount ? MS_FORCE : 0);\n\t\t\tzfs_close(zhp);\n\t\t\tif (clp == NULL) {\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\terr = changelist_postfix(clp);\n\t\t\tchangelist_free(clp);\n\t\t\tif (err != 0)\n\t\t\t\terr = -1;\n\t\t}\n\t}\n\nout:\n\tif (top_zfs)\n\t\tfree(top_zfs);\n\n\treturn (err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}