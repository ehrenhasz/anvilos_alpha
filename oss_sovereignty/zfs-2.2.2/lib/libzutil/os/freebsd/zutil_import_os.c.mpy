{
  "module_name": "zutil_import_os.c",
  "hash_id": "d9fd6e19962040ae90abd8d5fd8e47528efe15a168a8d12f27005336963b5e49",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzutil/os/freebsd/zutil_import_os.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/types.h>\n#include <sys/disk.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/sysctl.h>\n\n#include <aio.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <libintl.h>\n#include <libgen.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\n#include <sys/efi_partition.h>\n#include <thread_pool.h>\n#include <libgeom.h>\n\n#include <sys/vdev_impl.h>\n\n#include <libzutil.h>\n\n#include \"zutil_import.h\"\n\n \nvoid\nupdate_vdev_config_dev_strs(nvlist_t *nv)\n{\n\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_DEVID);\n\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_PHYS_PATH);\n}\n\n \nstatic const char * const excluded_devs[] = {\n\t\"nfslock\",\n\t\"sequencer\",\n\t\"zfs\",\n};\n#define\tEXCLUDED_DIR\t\t\"/dev/\"\n#define\tEXCLUDED_DIR_LEN\t5\n\nvoid\nzpool_open_func(void *arg)\n{\n\trdsk_node_t *rn = arg;\n\tstruct stat64 statbuf;\n\tnvlist_t *config;\n\tsize_t i;\n\tint num_labels;\n\tint fd;\n\toff_t mediasize = 0;\n\n\t \n\tif (strncmp(rn->rn_name, EXCLUDED_DIR, EXCLUDED_DIR_LEN) == 0) {\n\t\tchar *name = rn->rn_name + EXCLUDED_DIR_LEN;\n\t\tfor (i = 0; i < nitems(excluded_devs); ++i) {\n\t\t\tconst char *excluded_name = excluded_devs[i];\n\t\t\tsize_t len = strlen(excluded_name);\n\t\t\tif (strncmp(name, excluded_name, len) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((fd = open(rn->rn_name, O_RDONLY|O_NONBLOCK|O_CLOEXEC)) < 0)\n\t\treturn;\n\n\t \n\tif (fstat64(fd, &statbuf) != 0)\n\t\tgoto out;\n\t \n\tif (S_ISREG(statbuf.st_mode)) {\n\t\t \n\t\tif (statbuf.st_size < SPA_MINDEVSIZE) {\n\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISCHR(statbuf.st_mode) || S_ISBLK(statbuf.st_mode)) {\n\t\t \n\t\tif (ioctl(fd, DIOCGMEDIASIZE, &mediasize) != 0 ||\n\t\t    mediasize < SPA_MINDEVSIZE) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (zpool_read_label(fd, &config, &num_labels) != 0)\n\t\tgoto out;\n\tif (num_labels == 0) {\n\t\tnvlist_free(config);\n\t\tgoto out;\n\t}\n\n\trn->rn_config = config;\n\trn->rn_num_labels = num_labels;\n\n\t \nout:\n\t(void) close(fd);\n}\n\nstatic const char * const\nzpool_default_import_path[] = {\n\t\"/dev\"\n};\n\nconst char * const *\nzpool_default_search_paths(size_t *count)\n{\n\t*count = nitems(zpool_default_import_path);\n\treturn (zpool_default_import_path);\n}\n\nint\nzpool_find_import_blkid(libpc_handle_t *hdl, pthread_mutex_t *lock,\n    avl_tree_t **slice_cache)\n{\n\tconst char *oid = \"vfs.zfs.vol.recursive\";\n\tchar *end, path[MAXPATHLEN];\n\trdsk_node_t *slice;\n\tstruct gmesh mesh;\n\tstruct gclass *mp;\n\tstruct ggeom *gp;\n\tstruct gprovider *pp;\n\tavl_index_t where;\n\tint error, value;\n\tsize_t pathleft, size = sizeof (value);\n\tboolean_t skip_zvols = B_FALSE;\n\n\tend = stpcpy(path, \"/dev/\");\n\tpathleft = &path[sizeof (path)] - end;\n\n\terror = geom_gettree(&mesh);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (sysctlbyname(oid, &value, &size, NULL, 0) == 0 && value == 0)\n\t\tskip_zvols = B_TRUE;\n\n\t*slice_cache = zutil_alloc(hdl, sizeof (avl_tree_t));\n\tavl_create(*slice_cache, slice_cache_compare, sizeof (rdsk_node_t),\n\t    offsetof(rdsk_node_t, rn_node));\n\n\tLIST_FOREACH(mp, &mesh.lg_class, lg_class) {\n\t\tif (skip_zvols && strcmp(mp->lg_name, \"ZFS::ZVOL\") == 0)\n\t\t\tcontinue;\n\t\tLIST_FOREACH(gp, &mp->lg_geom, lg_geom) {\n\t\t\tLIST_FOREACH(pp, &gp->lg_provider, lg_provider) {\n\t\t\t\tstrlcpy(end, pp->lg_name, pathleft);\n\t\t\t\tslice = zutil_alloc(hdl, sizeof (rdsk_node_t));\n\t\t\t\tslice->rn_name = zutil_strdup(hdl, path);\n\t\t\t\tslice->rn_vdev_guid = 0;\n\t\t\t\tslice->rn_lock = lock;\n\t\t\t\tslice->rn_avl = *slice_cache;\n\t\t\t\tslice->rn_hdl = hdl;\n\t\t\t\tslice->rn_labelpaths = B_FALSE;\n\t\t\t\tslice->rn_order = IMPORT_ORDER_DEFAULT;\n\n\t\t\t\tpthread_mutex_lock(lock);\n\t\t\t\tif (avl_find(*slice_cache, slice, &where)) {\n\t\t\t\t\tfree(slice->rn_name);\n\t\t\t\t\tfree(slice);\n\t\t\t\t} else {\n\t\t\t\t\tavl_insert(*slice_cache, slice, where);\n\t\t\t\t}\n\t\t\t\tpthread_mutex_unlock(lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tgeom_deletetree(&mesh);\n\n\treturn (0);\n}\n\nint\nzfs_dev_flush(int fd)\n{\n\t(void) fd;\n\treturn (0);\n}\n\nvoid\nupdate_vdevs_config_dev_sysfs_path(nvlist_t *config)\n{\n\t(void) config;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}