{
  "module_name": "zutil_import_os.c",
  "hash_id": "032d13a021c8e46703a5920b6c0c6e8b590e4d097d6393a6ef89334328a20ce3",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzutil/os/linux/zutil_import_os.c",
  "human_readable_source": " \n \n\n \n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <libintl.h>\n#include <libgen.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/dktp/fdisk.h>\n#include <sys/vdev_impl.h>\n#include <sys/fs/zfs.h>\n\n#include <thread_pool.h>\n#include <libzutil.h>\n#include <libnvpair.h>\n#include <libzfs.h>\n\n#include \"zutil_import.h\"\n\n#ifdef HAVE_LIBUDEV\n#include <libudev.h>\n#include <sched.h>\n#endif\n#include <blkid/blkid.h>\n\n#define\tDEV_BYID_PATH\t\"/dev/disk/by-id/\"\n\n \nstatic boolean_t\nshould_skip_dev(const char *dev)\n{\n\treturn ((strcmp(dev, \"watchdog\") == 0) ||\n\t    (strncmp(dev, \"watchdog\", 8) == 0 && isdigit(dev[8])) ||\n\t    (strcmp(dev, \"hpet\") == 0));\n}\n\nint\nzfs_dev_flush(int fd)\n{\n\treturn (ioctl(fd, BLKFLSBUF));\n}\n\nvoid\nzpool_open_func(void *arg)\n{\n\trdsk_node_t *rn = arg;\n\tlibpc_handle_t *hdl = rn->rn_hdl;\n\tstruct stat64 statbuf;\n\tnvlist_t *config;\n\tuint64_t vdev_guid = 0;\n\tint error;\n\tint num_labels = 0;\n\tint fd;\n\n\tif (should_skip_dev(zfs_basename(rn->rn_name)))\n\t\treturn;\n\n\t \n\tif (stat64(rn->rn_name, &statbuf) != 0 ||\n\t    (!S_ISREG(statbuf.st_mode) && !S_ISBLK(statbuf.st_mode)) ||\n\t    (S_ISREG(statbuf.st_mode) && statbuf.st_size < SPA_MINDEVSIZE))\n\t\treturn;\n\n\t \n\tfd = open(rn->rn_name, O_RDONLY | O_DIRECT | O_CLOEXEC);\n\tif ((fd < 0) && (errno == EINVAL))\n\t\tfd = open(rn->rn_name, O_RDONLY | O_CLOEXEC);\n\tif ((fd < 0) && (errno == EACCES))\n\t\thdl->lpc_open_access_error = B_TRUE;\n\tif (fd < 0)\n\t\treturn;\n\n\terror = zpool_read_label(fd, &config, &num_labels);\n\tif (error != 0) {\n\t\t(void) close(fd);\n\t\treturn;\n\t}\n\n\tif (num_labels == 0) {\n\t\t(void) close(fd);\n\t\tnvlist_free(config);\n\t\treturn;\n\t}\n\n\t \n\terror = nvlist_lookup_uint64(config, ZPOOL_CONFIG_GUID, &vdev_guid);\n\tif (error || (rn->rn_vdev_guid && rn->rn_vdev_guid != vdev_guid)) {\n\t\t(void) close(fd);\n\t\tnvlist_free(config);\n\t\treturn;\n\t}\n\n\t(void) close(fd);\n\n\trn->rn_config = config;\n\trn->rn_num_labels = num_labels;\n\n\t \n\tif (rn->rn_labelpaths) {\n\t\tconst char *path = NULL;\n\t\tconst char *devid = NULL;\n\t\tconst char *env = NULL;\n\t\trdsk_node_t *slice;\n\t\tavl_index_t where;\n\t\tint timeout;\n\t\tint error;\n\n\t\tif (label_paths(rn->rn_hdl, rn->rn_config, &path, &devid))\n\t\t\treturn;\n\n\t\tenv = getenv(\"ZPOOL_IMPORT_UDEV_TIMEOUT_MS\");\n\t\tif ((env == NULL) || sscanf(env, \"%d\", &timeout) != 1 ||\n\t\t    timeout < 0) {\n\t\t\ttimeout = DISK_LABEL_WAIT;\n\t\t}\n\n\t\t \n\t\tzpool_label_disk_wait(rn->rn_name, timeout);\n\n\t\tif (path != NULL) {\n\t\t\tslice = zutil_alloc(hdl, sizeof (rdsk_node_t));\n\t\t\tslice->rn_name = zutil_strdup(hdl, path);\n\t\t\tslice->rn_vdev_guid = vdev_guid;\n\t\t\tslice->rn_avl = rn->rn_avl;\n\t\t\tslice->rn_hdl = hdl;\n\t\t\tslice->rn_order = IMPORT_ORDER_PREFERRED_1;\n\t\t\tslice->rn_labelpaths = B_FALSE;\n\t\t\tpthread_mutex_lock(rn->rn_lock);\n\t\t\tif (avl_find(rn->rn_avl, slice, &where)) {\n\t\t\tpthread_mutex_unlock(rn->rn_lock);\n\t\t\t\tfree(slice->rn_name);\n\t\t\t\tfree(slice);\n\t\t\t} else {\n\t\t\t\tavl_insert(rn->rn_avl, slice, where);\n\t\t\t\tpthread_mutex_unlock(rn->rn_lock);\n\t\t\t\tzpool_open_func(slice);\n\t\t\t}\n\t\t}\n\n\t\tif (devid != NULL) {\n\t\t\tslice = zutil_alloc(hdl, sizeof (rdsk_node_t));\n\t\t\terror = asprintf(&slice->rn_name, \"%s%s\",\n\t\t\t    DEV_BYID_PATH, devid);\n\t\t\tif (error == -1) {\n\t\t\t\tfree(slice);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tslice->rn_vdev_guid = vdev_guid;\n\t\t\tslice->rn_avl = rn->rn_avl;\n\t\t\tslice->rn_hdl = hdl;\n\t\t\tslice->rn_order = IMPORT_ORDER_PREFERRED_2;\n\t\t\tslice->rn_labelpaths = B_FALSE;\n\t\t\tpthread_mutex_lock(rn->rn_lock);\n\t\t\tif (avl_find(rn->rn_avl, slice, &where)) {\n\t\t\t\tpthread_mutex_unlock(rn->rn_lock);\n\t\t\t\tfree(slice->rn_name);\n\t\t\t\tfree(slice);\n\t\t\t} else {\n\t\t\t\tavl_insert(rn->rn_avl, slice, where);\n\t\t\t\tpthread_mutex_unlock(rn->rn_lock);\n\t\t\t\tzpool_open_func(slice);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const char * const\nzpool_default_import_path[] = {\n\t\"/dev/disk/by-vdev\",\t \n\t\"/dev/mapper\",\t\t \n\t\"/dev/disk/by-partlabel\",  \n\t\"/dev/disk/by-partuuid\",  \n\t\"/dev/disk/by-label\",\t \n\t\"/dev/disk/by-uuid\",\t \n\t\"/dev/disk/by-id\",\t \n\t\"/dev/disk/by-path\",\t \n\t\"/dev\"\t\t\t \n};\n\nconst char * const *\nzpool_default_search_paths(size_t *count)\n{\n\t*count = ARRAY_SIZE(zpool_default_import_path);\n\treturn (zpool_default_import_path);\n}\n\n \nstatic int\nzfs_path_order(const char *name, int *order)\n{\n\tconst char *env = getenv(\"ZPOOL_IMPORT_PATH\");\n\n\tif (env) {\n\t\tfor (int i = 0; ; ++i) {\n\t\t\tenv += strspn(env, \":\");\n\t\t\tsize_t dirlen = strcspn(env, \":\");\n\t\t\tif (dirlen) {\n\t\t\t\tif (strncmp(name, env, dirlen) == 0) {\n\t\t\t\t\t*order = i;\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\n\t\t\t\tenv += dirlen;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i < ARRAY_SIZE(zpool_default_import_path);\n\t\t    ++i) {\n\t\t\tif (strncmp(name, zpool_default_import_path[i],\n\t\t\t    strlen(zpool_default_import_path[i])) == 0) {\n\t\t\t\t*order = i;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (ENOENT);\n}\n\n \nint\nzpool_find_import_blkid(libpc_handle_t *hdl, pthread_mutex_t *lock,\n    avl_tree_t **slice_cache)\n{\n\trdsk_node_t *slice;\n\tblkid_cache cache;\n\tblkid_dev_iterate iter;\n\tblkid_dev dev;\n\tavl_index_t where;\n\tint error;\n\n\t*slice_cache = NULL;\n\n\terror = blkid_get_cache(&cache, NULL);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = blkid_probe_all_new(cache);\n\tif (error != 0) {\n\t\tblkid_put_cache(cache);\n\t\treturn (error);\n\t}\n\n\titer = blkid_dev_iterate_begin(cache);\n\tif (iter == NULL) {\n\t\tblkid_put_cache(cache);\n\t\treturn (EINVAL);\n\t}\n\n\t \n\terror = blkid_dev_set_search(iter,\n\t    (char *)\"TYPE\", (char *)\"zfs_member\");\n\tif (error != 0) {\n\t\tblkid_dev_iterate_end(iter);\n\t\tblkid_put_cache(cache);\n\t\treturn (error);\n\t}\n\n\t*slice_cache = zutil_alloc(hdl, sizeof (avl_tree_t));\n\tavl_create(*slice_cache, slice_cache_compare, sizeof (rdsk_node_t),\n\t    offsetof(rdsk_node_t, rn_node));\n\n\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\tslice = zutil_alloc(hdl, sizeof (rdsk_node_t));\n\t\tslice->rn_name = zutil_strdup(hdl, blkid_dev_devname(dev));\n\t\tslice->rn_vdev_guid = 0;\n\t\tslice->rn_lock = lock;\n\t\tslice->rn_avl = *slice_cache;\n\t\tslice->rn_hdl = hdl;\n\t\tslice->rn_labelpaths = B_TRUE;\n\n\t\terror = zfs_path_order(slice->rn_name, &slice->rn_order);\n\t\tif (error == 0)\n\t\t\tslice->rn_order += IMPORT_ORDER_SCAN_OFFSET;\n\t\telse\n\t\t\tslice->rn_order = IMPORT_ORDER_DEFAULT;\n\n\t\tpthread_mutex_lock(lock);\n\t\tif (avl_find(*slice_cache, slice, &where)) {\n\t\t\tfree(slice->rn_name);\n\t\t\tfree(slice);\n\t\t} else {\n\t\t\tavl_insert(*slice_cache, slice, where);\n\t\t}\n\t\tpthread_mutex_unlock(lock);\n\t}\n\n\tblkid_dev_iterate_end(iter);\n\tblkid_put_cache(cache);\n\n\treturn (0);\n}\n\n \n\ntypedef struct vdev_dev_strs {\n\tchar\tvds_devid[128];\n\tchar\tvds_devphys[128];\n} vdev_dev_strs_t;\n\n#ifdef HAVE_LIBUDEV\n\n \nint\nzfs_device_get_devid(struct udev_device *dev, char *bufptr, size_t buflen)\n{\n\tstruct udev_list_entry *entry;\n\tconst char *bus;\n\tchar devbyid[MAXPATHLEN];\n\n\t \n\tbus = udev_device_get_property_value(dev, \"ID_BUS\");\n\n\tif (bus == NULL) {\n\t\tconst char *dm_uuid;\n\n\t\t \n\t\tdm_uuid = udev_device_get_property_value(dev, \"DM_UUID\");\n\t\tif (dm_uuid != NULL) {\n\t\t\t(void) snprintf(bufptr, buflen, \"dm-uuid-%s\", dm_uuid);\n\t\t\treturn (0);\n\t\t}\n\n\t\t \n\t\tentry = udev_device_get_devlinks_list_entry(dev);\n\t\twhile (entry != NULL) {\n\t\t\tconst char *name;\n\n\t\t\tname = udev_list_entry_get_name(entry);\n\t\t\tif (strncmp(name, ZVOL_ROOT, strlen(ZVOL_ROOT)) == 0) {\n\t\t\t\t(void) strlcpy(bufptr, name, buflen);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tentry = udev_list_entry_get_next(entry);\n\t\t}\n\n\t\t \n\t\tstruct udev_device *parent;\n\n\t\tparent = udev_device_get_parent_with_subsystem_devtype(dev,\n\t\t    \"nvme\", NULL);\n\t\tif (parent != NULL)\n\t\t\tbus = \"nvme\";\t \n\t\telse\n\t\t\treturn (ENODATA);\n\t}\n\n\t \n\t(void) snprintf(devbyid, sizeof (devbyid), \"%s%s-\", DEV_BYID_PATH, bus);\n\tentry = udev_device_get_devlinks_list_entry(dev);\n\twhile (entry != NULL) {\n\t\tconst char *name;\n\n\t\tname = udev_list_entry_get_name(entry);\n\t\tif (strncmp(name, devbyid, strlen(devbyid)) == 0) {\n\t\t\tname += strlen(DEV_BYID_PATH);\n\t\t\t(void) strlcpy(bufptr, name, buflen);\n\t\t\treturn (0);\n\t\t}\n\t\tentry = udev_list_entry_get_next(entry);\n\t}\n\n\treturn (ENODATA);\n}\n\n \nint\nzfs_device_get_physical(struct udev_device *dev, char *bufptr, size_t buflen)\n{\n\tconst char *physpath = NULL;\n\tstruct udev_list_entry *entry;\n\n\t \n\tphyspath = udev_device_get_property_value(dev, \"ID_PATH\");\n\tif (physpath != NULL && strlen(physpath) > 0) {\n\t\t(void) strlcpy(bufptr, physpath, buflen);\n\t\treturn (0);\n\t}\n\n\t \n\tphyspath = udev_device_get_property_value(dev, \"ID_VDEV\");\n\tif (physpath != NULL && strlen(physpath) > 0) {\n\t\t(void) strlcpy(bufptr, physpath, buflen);\n\t\treturn (0);\n\t}\n\n\t \n\tentry = udev_device_get_devlinks_list_entry(dev);\n\twhile (entry != NULL) {\n\t\tphyspath = udev_list_entry_get_name(entry);\n\t\tif (strncmp(physpath, ZVOL_ROOT, strlen(ZVOL_ROOT)) == 0) {\n\t\t\t(void) strlcpy(bufptr, physpath, buflen);\n\t\t\treturn (0);\n\t\t}\n\t\tentry = udev_list_entry_get_next(entry);\n\t}\n\n\t \n\tentry = udev_device_get_devlinks_list_entry(dev);\n\twhile (entry != NULL) {\n\t\tphyspath = udev_list_entry_get_name(entry);\n\t\tif (strncmp(physpath, \"/dev/disk/by-uuid\", 17) == 0) {\n\t\t\t(void) strlcpy(bufptr, physpath, buflen);\n\t\t\treturn (0);\n\t\t}\n\t\tentry = udev_list_entry_get_next(entry);\n\t}\n\n\treturn (ENODATA);\n}\n\n \nstatic boolean_t\nudev_mpath_whole_disk(struct udev_device *dev)\n{\n\tconst char *devname, *type, *uuid;\n\n\tdevname = udev_device_get_property_value(dev, \"DEVNAME\");\n\ttype = udev_device_get_property_value(dev, \"ID_PART_TABLE_TYPE\");\n\tuuid = udev_device_get_property_value(dev, \"DM_UUID\");\n\n\tif ((devname != NULL && strncmp(devname, \"/dev/dm-\", 8) == 0) &&\n\t    ((type == NULL) || (strcmp(type, \"gpt\") != 0)) &&\n\t    (uuid != NULL)) {\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic int\nudev_device_is_ready(struct udev_device *dev)\n{\n#ifdef HAVE_LIBUDEV_UDEV_DEVICE_GET_IS_INITIALIZED\n\treturn (udev_device_get_is_initialized(dev));\n#else\n\t \n\treturn (udev_device_get_property_value(dev, \"DEVLINKS\") != NULL);\n#endif\n}\n\n#else\n\nint\nzfs_device_get_devid(struct udev_device *dev, char *bufptr, size_t buflen)\n{\n\t(void) dev, (void) bufptr, (void) buflen;\n\treturn (ENODATA);\n}\n\nint\nzfs_device_get_physical(struct udev_device *dev, char *bufptr, size_t buflen)\n{\n\t(void) dev, (void) bufptr, (void) buflen;\n\treturn (ENODATA);\n}\n\n#endif  \n\n \nint\nzpool_label_disk_wait(const char *path, int timeout_ms)\n{\n#ifdef HAVE_LIBUDEV\n\tstruct udev *udev;\n\tstruct udev_device *dev = NULL;\n\tchar nodepath[MAXPATHLEN];\n\tchar *sysname = NULL;\n\tint ret = ENODEV;\n\tint settle_ms = 50;\n\tlong sleep_ms = 10;\n\thrtime_t start, settle;\n\n\tif ((udev = udev_new()) == NULL)\n\t\treturn (ENXIO);\n\n\tstart = gethrtime();\n\tsettle = 0;\n\n\tdo {\n\t\tif (sysname == NULL) {\n\t\t\tif (realpath(path, nodepath) != NULL) {\n\t\t\t\tsysname = strrchr(nodepath, '/') + 1;\n\t\t\t} else {\n\t\t\t\t(void) usleep(sleep_ms * MILLISEC);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tdev = udev_device_new_from_subsystem_sysname(udev,\n\t\t    \"block\", sysname);\n\t\tif ((dev != NULL) && udev_device_is_ready(dev)) {\n\t\t\tstruct udev_list_entry *links, *link = NULL;\n\n\t\t\tret = 0;\n\t\t\tlinks = udev_device_get_devlinks_list_entry(dev);\n\n\t\t\tudev_list_entry_foreach(link, links) {\n\t\t\t\tstruct stat64 statbuf;\n\t\t\t\tconst char *name;\n\n\t\t\t\tname = udev_list_entry_get_name(link);\n\t\t\t\terrno = 0;\n\t\t\t\tif (stat64(name, &statbuf) == 0 && errno == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsettle = 0;\n\t\t\t\tret = ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret == 0) {\n\t\t\t\tif (settle == 0) {\n\t\t\t\t\tsettle = gethrtime();\n\t\t\t\t} else if (NSEC2MSEC(gethrtime() - settle) >=\n\t\t\t\t    settle_ms) {\n\t\t\t\t\tudev_device_unref(dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tudev_device_unref(dev);\n\t\t(void) usleep(sleep_ms * MILLISEC);\n\n\t} while (NSEC2MSEC(gethrtime() - start) < timeout_ms);\n\n\tudev_unref(udev);\n\n\treturn (ret);\n#else\n\tint settle_ms = 50;\n\tlong sleep_ms = 10;\n\thrtime_t start, settle;\n\tstruct stat64 statbuf;\n\n\tstart = gethrtime();\n\tsettle = 0;\n\n\tdo {\n\t\terrno = 0;\n\t\tif ((stat64(path, &statbuf) == 0) && (errno == 0)) {\n\t\t\tif (settle == 0)\n\t\t\t\tsettle = gethrtime();\n\t\t\telse if (NSEC2MSEC(gethrtime() - settle) >= settle_ms)\n\t\t\t\treturn (0);\n\t\t} else if (errno != ENOENT) {\n\t\t\treturn (errno);\n\t\t}\n\n\t\tusleep(sleep_ms * MILLISEC);\n\t} while (NSEC2MSEC(gethrtime() - start) < timeout_ms);\n\n\treturn (ENODEV);\n#endif  \n}\n\n \nstatic int\nencode_device_strings(const char *path, vdev_dev_strs_t *ds,\n    boolean_t wholedisk)\n{\n#ifdef HAVE_LIBUDEV\n\tstruct udev *udev;\n\tstruct udev_device *dev = NULL;\n\tchar nodepath[MAXPATHLEN];\n\tchar *sysname;\n\tint ret = ENODEV;\n\thrtime_t start;\n\n\tif ((udev = udev_new()) == NULL)\n\t\treturn (ENXIO);\n\n\t \n\tif (realpath(path, nodepath) == NULL)\n\t\tgoto no_dev;\n\n\tsysname = strrchr(nodepath, '/') + 1;\n\n\t \n\tstart = gethrtime();\n\tdo {\n\t\tdev = udev_device_new_from_subsystem_sysname(udev, \"block\",\n\t\t    sysname);\n\t\tif (dev == NULL)\n\t\t\tgoto no_dev;\n\t\tif (udev_device_is_ready(dev))\n\t\t\tbreak;   \n\n\t\tudev_device_unref(dev);\n\t\tdev = NULL;\n\n\t\tif (NSEC2MSEC(gethrtime() - start) < 10)\n\t\t\t(void) sched_yield();\t \n\t\telse\n\t\t\t(void) usleep(10 * MILLISEC);\n\n\t} while (NSEC2MSEC(gethrtime() - start) < (3 * MILLISEC));\n\n\tif (dev == NULL)\n\t\tgoto no_dev;\n\n\t \n\tif (!wholedisk && !udev_mpath_whole_disk(dev))\n\t\tgoto no_dev;\n\n\tret = zfs_device_get_devid(dev, ds->vds_devid, sizeof (ds->vds_devid));\n\tif (ret != 0)\n\t\tgoto no_dev_ref;\n\n\t \n\tif (zfs_device_get_physical(dev, ds->vds_devphys,\n\t    sizeof (ds->vds_devphys)) != 0) {\n\t\tds->vds_devphys[0] = '\\0';  \n\t}\n\nno_dev_ref:\n\tudev_device_unref(dev);\nno_dev:\n\tudev_unref(udev);\n\n\treturn (ret);\n#else\n\t(void) path;\n\t(void) ds;\n\t(void) wholedisk;\n\treturn (ENOENT);\n#endif\n}\n\n \nstatic void\nupdate_vdev_config_dev_sysfs_path(nvlist_t *nv, const char *path)\n{\n\tchar *upath, *spath;\n\n\t \n\tupath = zfs_get_underlying_path(path);\n\tspath = zfs_get_enclosure_sysfs_path(upath);\n\n\tif (spath) {\n\t\tnvlist_add_string(nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH, spath);\n\t} else {\n\t\tnvlist_remove_all(nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH);\n\t}\n\n\tfree(upath);\n\tfree(spath);\n}\n\n \nstatic int\nsysfs_path_pool_vdev_iter_f(void *hdl_data, nvlist_t *nv, void *data)\n{\n\t(void) hdl_data, (void) data;\n\n\tconst char *path = NULL;\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) != 0)\n\t\treturn (1);\n\n\t \n\tupdate_vdev_config_dev_sysfs_path(nv, path);\n\treturn (0);\n}\n\n \nvoid\nupdate_vdevs_config_dev_sysfs_path(nvlist_t *config)\n{\n\tnvlist_t *nvroot = NULL;\n\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\tfor_each_vdev_in_nvlist(nvroot, sysfs_path_pool_vdev_iter_f, NULL);\n}\n\n \nvoid\nupdate_vdev_config_dev_strs(nvlist_t *nv)\n{\n\tvdev_dev_strs_t vds;\n\tconst char *env, *type, *path;\n\tuint64_t wholedisk = 0;\n\n\t \n\tenv = getenv(\"ZFS_VDEV_DEVID_OPT_OUT\");\n\tif (env && (strtoul(env, NULL, 0) > 0 ||\n\t    !strncasecmp(env, \"YES\", 3) || !strncasecmp(env, \"ON\", 2))) {\n\t\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_DEVID);\n\t\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_PHYS_PATH);\n\t\treturn;\n\t}\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) != 0 ||\n\t    strcmp(type, VDEV_TYPE_DISK) != 0) {\n\t\treturn;\n\t}\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) != 0)\n\t\treturn;\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_WHOLE_DISK, &wholedisk);\n\n\t \n\tif (encode_device_strings(path, &vds, (boolean_t)wholedisk) == 0) {\n\t\t(void) nvlist_add_string(nv, ZPOOL_CONFIG_DEVID, vds.vds_devid);\n\t\tif (vds.vds_devphys[0] != '\\0') {\n\t\t\t(void) nvlist_add_string(nv, ZPOOL_CONFIG_PHYS_PATH,\n\t\t\t    vds.vds_devphys);\n\t\t}\n\t\tupdate_vdev_config_dev_sysfs_path(nv, path);\n\t} else {\n\t\t \n\t\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_DEVID);\n\t\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_PHYS_PATH);\n\t\t(void) nvlist_remove_all(nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}