{
  "module_name": "zutil_device_path_os.c",
  "hash_id": "8e802bc278a134d3e7c580afc5d0d153fa92f35f85d61712c423f6be9de77db0",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzutil/os/linux/zutil_device_path_os.c",
  "human_readable_source": " \n\n \n\n#include <ctype.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/efi_partition.h>\n\n#ifdef HAVE_LIBUDEV\n#include <libudev.h>\n#endif\n\n#include <libzutil.h>\n\n \nint\nzfs_append_partition(char *path, size_t max_len)\n{\n\tint len = strlen(path);\n\n\tif ((strncmp(path, UDISK_ROOT, strlen(UDISK_ROOT)) == 0) ||\n\t    (strncmp(path, ZVOL_ROOT, strlen(ZVOL_ROOT)) == 0)) {\n\t\tif (len + 6 >= max_len)\n\t\t\treturn (-1);\n\n\t\t(void) strcat(path, \"-part1\");\n\t\tlen += 6;\n\t} else {\n\t\tif (len + 2 >= max_len)\n\t\t\treturn (-1);\n\n\t\tif (isdigit(path[len-1])) {\n\t\t\t(void) strcat(path, \"p1\");\n\t\t\tlen += 2;\n\t\t} else {\n\t\t\t(void) strcat(path, \"1\");\n\t\t\tlen += 1;\n\t\t}\n\t}\n\n\treturn (len);\n}\n\n \nchar *\nzfs_strip_partition(const char *path)\n{\n\tchar *tmp = strdup(path);\n\tchar *part = NULL, *d = NULL;\n\tif (!tmp)\n\t\treturn (NULL);\n\n\tif ((part = strstr(tmp, \"-part\")) && part != tmp) {\n\t\td = part + 5;\n\t} else if ((part = strrchr(tmp, 'p')) &&\n\t    part > tmp + 1 && isdigit(*(part-1))) {\n\t\td = part + 1;\n\t} else if ((tmp[0] == 'h' || tmp[0] == 's' || tmp[0] == 'v') &&\n\t    tmp[1] == 'd') {\n\t\tfor (d = &tmp[2]; isalpha(*d); part = ++d) { }\n\t} else if (strncmp(\"xvd\", tmp, 3) == 0) {\n\t\tfor (d = &tmp[3]; isalpha(*d); part = ++d) { }\n\t}\n\tif (part && d && *d != '\\0') {\n\t\tfor (; isdigit(*d); d++) { }\n\t\tif (*d == '\\0')\n\t\t\t*part = '\\0';\n\t}\n\n\treturn (tmp);\n}\n\n \nstatic char *\nzfs_strip_partition_path(const char *path)\n{\n\tchar *newpath = strdup(path);\n\tchar *sd_offset;\n\tchar *new_sd;\n\n\tif (!newpath)\n\t\treturn (NULL);\n\n\t \n\tsd_offset = strrchr(newpath, '/') + 1;\n\n\t \n\tnew_sd = zfs_strip_partition(sd_offset);\n\tif (!new_sd) {\n\t\tfree(newpath);\n\t\treturn (NULL);\n\t}\n\n\t \n\tstrlcpy(sd_offset, new_sd, strlen(sd_offset) + 1);\n\n\t \n\tfree(new_sd);\n\n\treturn (newpath);\n}\n\n \nconst char *\nzfs_strip_path(const char *path)\n{\n\tsize_t spath_count;\n\tconst char *const *spaths = zpool_default_search_paths(&spath_count);\n\n\tfor (size_t i = 0; i < spath_count; ++i)\n\t\tif (strncmp(path, spaths[i], strlen(spaths[i])) == 0 &&\n\t\t    path[strlen(spaths[i])] == '/')\n\t\t\treturn (path + strlen(spaths[i]) + 1);\n\n\treturn (path);\n}\n\n \nstatic char *\nzfs_read_sysfs_file(char *filepath)\n{\n\tchar buf[4096];\t \n\tchar *str = NULL;\n\n\tFILE *fp = fopen(filepath, \"r\");\n\tif (fp == NULL) {\n\t\treturn (NULL);\n\t}\n\tif (fgets(buf, sizeof (buf), fp) == buf) {\n\t\t \n\n\t\t \n\t\tsize_t len = strlen(buf);\n\t\tif (buf[len - 1] == '\\n') {\n\t\t\tbuf[len - 1] = '\\0';\n\t\t}\n\t\tstr = strdup(buf);\n\t}\n\n\tfclose(fp);\n\n\treturn (str);\n}\n\n \nstatic char *\nzfs_get_pci_slots_sys_path(const char *dev_name)\n{\n\tDIR *dp = NULL;\n\tstruct dirent *ep;\n\tchar *address1 = NULL;\n\tchar *address2 = NULL;\n\tchar *path = NULL;\n\tchar buf[MAXPATHLEN];\n\tchar *tmp;\n\n\t \n\ttmp = strrchr(dev_name, '/');\n\tif (tmp != NULL)\n\t\tdev_name = tmp + 1;     \n\n\tif (strncmp(\"nvme\", dev_name, 4) != 0)\n\t\treturn (NULL);\n\n\t(void) snprintf(buf, sizeof (buf), \"/sys/block/%s/device/address\",\n\t    dev_name);\n\n\taddress1 = zfs_read_sysfs_file(buf);\n\tif (!address1)\n\t\treturn (NULL);\n\n\t \n\ttmp = strrchr(address1, '.');\n\tif (tmp != NULL)\n\t\t*tmp = '\\0';\n\n\tdp = opendir(\"/sys/bus/pci/slots/\");\n\tif (dp == NULL) {\n\t\tfree(address1);\n\t\treturn (NULL);\n\t}\n\n\t \n\twhile ((ep = readdir(dp))) {\n\t\t \n\t\tif (!zfs_isnumber(ep->d_name))\n\t\t\tcontinue;\n\n\t\t(void) snprintf(buf, sizeof (buf),\n\t\t    \"/sys/bus/pci/slots/%s/address\", ep->d_name);\n\n\t\taddress2 = zfs_read_sysfs_file(buf);\n\t\tif (!address2)\n\t\t\tcontinue;\n\n\t\tif (strcmp(address1, address2) == 0) {\n\t\t\t \n\t\t\tfree(address2);\n\t\t\tif (asprintf(&path, \"/sys/bus/pci/slots/%s\",\n\t\t\t    ep->d_name) == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfree(address2);\n\t}\n\n\tclosedir(dp);\n\tfree(address1);\n\n\treturn (path);\n}\n\n \nchar *\nzfs_get_enclosure_sysfs_path(const char *dev_name)\n{\n\tDIR *dp = NULL;\n\tstruct dirent *ep;\n\tchar buf[MAXPATHLEN];\n\tchar *tmp1 = NULL;\n\tchar *tmp2 = NULL;\n\tchar *tmp3 = NULL;\n\tchar *path = NULL;\n\tsize_t size;\n\tint tmpsize;\n\n\tif (dev_name == NULL)\n\t\treturn (NULL);\n\n\t \n\ttmp1 = strrchr(dev_name, '/');\n\tif (tmp1 != NULL)\n\t\tdev_name = tmp1 + 1;     \n\n\ttmpsize = asprintf(&tmp1, \"/sys/block/%s/device\", dev_name);\n\tif (tmpsize == -1 || tmp1 == NULL) {\n\t\ttmp1 = NULL;\n\t\tgoto end;\n\t}\n\n\tdp = opendir(tmp1);\n\tif (dp == NULL)\n\t\tgoto end;\n\n\t \n\twhile ((ep = readdir(dp))) {\n\t\t \n\t\tif (strstr(ep->d_name, \"enclosure_device\") == NULL)\n\t\t\tcontinue;\n\n\t\tif (tmp2 != NULL)\n\t\t\tfree(tmp2);\n\t\tif (asprintf(&tmp2, \"%s/%s\", tmp1, ep->d_name) == -1) {\n\t\t\ttmp2 = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsize = readlink(tmp2, buf, sizeof (buf));\n\n\t\t \n\t\tif (size == -1 || size >= sizeof (buf))\n\t\t\tbreak;\n\n\t\t \n\t\tbuf[size] = '\\0';\n\n\t\t \n\t\ttmp3 = strstr(buf, \"enclosure\");\n\t\tif (tmp3 == NULL)\n\t\t\tbreak;\n\n\t\tif (path != NULL)\n\t\t\tfree(path);\n\t\tif (asprintf(&path, \"/sys/class/%s\", tmp3) == -1) {\n\t\t\t \n\t\t\tpath = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nend:\n\tfree(tmp2);\n\tfree(tmp1);\n\n\tif (dp != NULL)\n\t\tclosedir(dp);\n\n\tif (!path) {\n\t\t \n\t\tpath = zfs_get_pci_slots_sys_path(dev_name);\n\t}\n\n\treturn (path);\n}\n\n \nstatic char *\ndm_get_underlying_path(const char *dm_name)\n{\n\tDIR *dp = NULL;\n\tstruct dirent *ep;\n\tchar *realp;\n\tchar *tmp = NULL;\n\tchar *path = NULL;\n\tchar *dev_str;\n\tchar *first_path = NULL;\n\tchar *enclosure_path;\n\n\tif (dm_name == NULL)\n\t\treturn (NULL);\n\n\t \n\trealp = realpath(dm_name, NULL);\n\tif (realp == NULL)\n\t\treturn (NULL);\n\n\t \n\ttmp = strrchr(realp, '/');\n\tif (tmp != NULL)\n\t\tdev_str = tmp + 1;     \n\telse\n\t\tdev_str = tmp;\n\n\tif (asprintf(&tmp, \"/sys/block/%s/slaves/\", dev_str) == -1) {\n\t\ttmp = NULL;\n\t\tgoto end;\n\t}\n\n\tdp = opendir(tmp);\n\tif (dp == NULL)\n\t\tgoto end;\n\n\t \n\twhile ((ep = readdir(dp))) {\n\t\tif (ep->d_type != DT_DIR) {\t \n\t\t\tif (!first_path)\n\t\t\t\tfirst_path = strdup(ep->d_name);\n\n\t\t\tenclosure_path =\n\t\t\t    zfs_get_enclosure_sysfs_path(ep->d_name);\n\n\t\t\tif (!enclosure_path)\n\t\t\t\tcontinue;\n\n\t\t\tif (asprintf(&path, \"/dev/%s\", ep->d_name) == -1)\n\t\t\t\tpath = NULL;\n\t\t\tfree(enclosure_path);\n\t\t\tbreak;\n\t\t}\n\t}\n\nend:\n\tif (dp != NULL)\n\t\tclosedir(dp);\n\tfree(tmp);\n\tfree(realp);\n\n\tif (!path && first_path) {\n\t\t \n\t\tif (asprintf(&path, \"/dev/%s\", first_path) == -1)\n\t\t\tpath = NULL;\n\t}\n\n\tfree(first_path);\n\treturn (path);\n}\n\n \nboolean_t\nzfs_dev_is_dm(const char *dev_name)\n{\n\n\tchar *tmp;\n\ttmp = dm_get_underlying_path(dev_name);\n\tif (tmp == NULL)\n\t\treturn (B_FALSE);\n\n\tfree(tmp);\n\treturn (B_TRUE);\n}\n\n \nboolean_t\nzfs_dev_is_whole_disk(const char *dev_name)\n{\n\tstruct dk_gpt *label = NULL;\n\tint fd;\n\n\tif ((fd = open(dev_name, O_RDONLY | O_DIRECT | O_CLOEXEC)) < 0)\n\t\treturn (B_FALSE);\n\n\tif (efi_alloc_and_init(fd, EFI_NUMPAR, &label) != 0) {\n\t\t(void) close(fd);\n\t\treturn (B_FALSE);\n\t}\n\n\tefi_free(label);\n\t(void) close(fd);\n\n\treturn (B_TRUE);\n}\n\n \nchar *\nzfs_get_underlying_path(const char *dev_name)\n{\n\tchar *name = NULL;\n\tchar *tmp;\n\n\tif (dev_name == NULL)\n\t\treturn (NULL);\n\n\ttmp = dm_get_underlying_path(dev_name);\n\n\t \n\tif (tmp == NULL)\n\t\ttmp = realpath(dev_name, NULL);\n\n\tif (tmp != NULL) {\n\t\tname = zfs_strip_partition_path(tmp);\n\t\tfree(tmp);\n\t}\n\n\treturn (name);\n}\n\n\n#ifdef HAVE_LIBUDEV\n\n \nstatic boolean_t\nis_mpath_udev_sane(struct udev_device *dev)\n{\n\tconst char *devname, *type, *uuid, *label;\n\n\tdevname = udev_device_get_property_value(dev, \"DEVNAME\");\n\ttype = udev_device_get_property_value(dev, \"ID_PART_TABLE_TYPE\");\n\tuuid = udev_device_get_property_value(dev, \"DM_UUID\");\n\tlabel = udev_device_get_property_value(dev, \"ID_FS_LABEL\");\n\n\tif ((devname != NULL && strncmp(devname, \"/dev/dm-\", 8) == 0) &&\n\t    ((type == NULL) || (strcmp(type, \"gpt\") != 0)) &&\n\t    ((uuid != NULL) && (strncmp(uuid, \"mpath-\", 6) == 0)) &&\n\t    (label == NULL)) {\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nboolean_t\nis_mpath_whole_disk(const char *path)\n{\n\tstruct udev *udev;\n\tstruct udev_device *dev = NULL;\n\tchar nodepath[MAXPATHLEN];\n\tchar *sysname;\n\n\tif (realpath(path, nodepath) == NULL)\n\t\treturn (B_FALSE);\n\tsysname = strrchr(nodepath, '/') + 1;\n\tif (strncmp(sysname, \"dm-\", 3) != 0)\n\t\treturn (B_FALSE);\n\tif ((udev = udev_new()) == NULL)\n\t\treturn (B_FALSE);\n\tif ((dev = udev_device_new_from_subsystem_sysname(udev, \"block\",\n\t    sysname)) == NULL) {\n\t\tudev_device_unref(dev);\n\t\treturn (B_FALSE);\n\t}\n\n\t \n\tboolean_t is_sane = is_mpath_udev_sane(dev);\n\tudev_device_unref(dev);\n\n\treturn (is_sane);\n}\n\n#else  \n\nboolean_t\nis_mpath_whole_disk(const char *path)\n{\n\t(void) path;\n\treturn (B_FALSE);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}