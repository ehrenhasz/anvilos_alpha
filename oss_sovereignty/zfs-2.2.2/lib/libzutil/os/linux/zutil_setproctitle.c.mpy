{
  "module_name": "zutil_setproctitle.c",
  "hash_id": "91a7674056578234582703187a5b106165e1984acecd436bca0fd38e79662e24",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzutil/os/linux/zutil_setproctitle.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <err.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/param.h>\n#include <libzutil.h>\n\nstatic struct {\n\t \n\tconst char *arg0;\n\n\t \n\tchar *base, *end;\n\n\t \n\tchar *nul;\n\n\tboolean_t warned;\n\tboolean_t reset;\n\tint error;\n} SPT;\n\n#define\tLIBBSD_IS_PATHNAME_SEPARATOR(c) ((c) == '/')\n#define\tSPT_MAXTITLE 255\n\nextern const char *__progname;\n\nstatic const char *\ngetprogname(void)\n{\n\treturn (__progname);\n}\n\nstatic void\nsetprogname(const char *progname)\n{\n\tsize_t i;\n\n\tfor (i = strlen(progname); i > 0; i--) {\n\t\tif (LIBBSD_IS_PATHNAME_SEPARATOR(progname[i - 1])) {\n\t\t\t__progname = progname + i;\n\t\t\treturn;\n\t\t}\n\t}\n\t__progname = progname;\n}\n\n\nstatic inline size_t\nspt_min(size_t a, size_t b)\n{\n\treturn ((a < b) ? a : b);\n}\n\n \nstatic int\nspt_clearenv(void)\n{\n\tchar **tmp;\n\n\ttmp = malloc(sizeof (*tmp));\n\tif (tmp == NULL)\n\t\treturn (errno);\n\n\ttmp[0] = NULL;\n\tenviron = tmp;\n\n\treturn (0);\n}\n\nstatic int\nspt_copyenv(int envc, char *envp[])\n{\n\tchar **envcopy;\n\tchar *eq;\n\tint envsize;\n\tint i, error;\n\n\tif (environ != envp)\n\t\treturn (0);\n\n\t \n\tenvsize = (envc + 1) * sizeof (char *);\n\tenvcopy = malloc(envsize);\n\tif (envcopy == NULL)\n\t\treturn (errno);\n\tmemcpy(envcopy, envp, envsize);\n\n\terror = spt_clearenv();\n\tif (error) {\n\t\tenviron = envp;\n\t\tfree(envcopy);\n\t\treturn (error);\n\t}\n\n\tfor (i = 0; envcopy[i]; i++) {\n\t\teq = strchr(envcopy[i], '=');\n\t\tif (eq == NULL)\n\t\t\tcontinue;\n\n\t\t*eq = '\\0';\n\t\tif (setenv(envcopy[i], eq + 1, 1) < 0)\n\t\t\terror = errno;\n\t\t*eq = '=';\n\n\t\tif (error) {\n\t\t\tenviron = envp;\n\t\t\tfree(envcopy);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t \n\tfree(envcopy);\n\n\treturn (0);\n}\n\nstatic int\nspt_copyargs(int argc, char *argv[])\n{\n\tchar *tmp;\n\tint i;\n\n\tfor (i = 1; i < argc || (i >= argc && argv[i]); i++) {\n\t\tif (argv[i] == NULL)\n\t\t\tcontinue;\n\n\t\ttmp = strdup(argv[i]);\n\t\tif (tmp == NULL)\n\t\t\treturn (errno);\n\n\t\targv[i] = tmp;\n\t}\n\n\treturn (0);\n}\n\nvoid\nzfs_setproctitle_init(int argc, char *argv[], char *envp[])\n{\n\tchar *base, *end, *nul, *tmp;\n\tint i, envc, error;\n\n\t \n\tif (argc < 0)\n\t\treturn;\n\n\tbase = argv[0];\n\tif (base == NULL)\n\t\treturn;\n\n\tnul = base + strlen(base);\n\tend = nul + 1;\n\n\tfor (i = 0; i < argc || (i >= argc && argv[i]); i++) {\n\t\tif (argv[i] == NULL || argv[i] != end)\n\t\t\tcontinue;\n\n\t\tend = argv[i] + strlen(argv[i]) + 1;\n\t}\n\n\tfor (i = 0; envp[i]; i++) {\n\t\tif (envp[i] != end)\n\t\t\tcontinue;\n\n\t\tend = envp[i] + strlen(envp[i]) + 1;\n\t}\n\tenvc = i;\n\n\tSPT.arg0 = strdup(argv[0]);\n\tif (SPT.arg0 == NULL) {\n\t\tSPT.error = errno;\n\t\treturn;\n\t}\n\n\ttmp = strdup(getprogname());\n\tif (tmp == NULL) {\n\t\tSPT.error = errno;\n\t\treturn;\n\t}\n\tsetprogname(tmp);\n\n\terror = spt_copyenv(envc, envp);\n\tif (error) {\n\t\tSPT.error = error;\n\t\treturn;\n\t}\n\n\terror = spt_copyargs(argc, argv);\n\tif (error) {\n\t\tSPT.error = error;\n\t\treturn;\n\t}\n\n\tSPT.nul  = nul;\n\tSPT.base = base;\n\tSPT.end  = end;\n}\n\nvoid\nzfs_setproctitle(const char *fmt, ...)\n{\n\t \n\tchar buf[SPT_MAXTITLE + 1];\n\tva_list ap;\n\tchar *nul;\n\tint len;\n\tif (SPT.base == NULL) {\n\t\tif (!SPT.warned) {\n\t\t\twarnx(\"setproctitle not initialized, please\"\n\t\t\t    \"call zfs_setproctitle_init()\");\n\t\t\tSPT.warned = B_TRUE;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fmt) {\n\t\tif (fmt[0] == '-') {\n\t\t\t \n\t\t\tfmt++;\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\t \n\t\t\tsnprintf(buf, sizeof (buf), \"%s: \", getprogname());\n\t\t\tlen = strlen(buf);\n\t\t}\n\n\t\tva_start(ap, fmt);\n\t\tlen += vsnprintf(buf + len, sizeof (buf) - len, fmt, ap);\n\t\tva_end(ap);\n\t} else {\n\t\tlen = snprintf(buf, sizeof (buf), \"%s\", SPT.arg0);\n\t}\n\n\tif (len <= 0) {\n\t\tSPT.error = errno;\n\t\treturn;\n\t}\n\n\tif (!SPT.reset) {\n\t\tmemset(SPT.base, 0, SPT.end - SPT.base);\n\t\tSPT.reset = B_TRUE;\n\t} else {\n\t\tmemset(SPT.base, 0, spt_min(sizeof (buf), SPT.end - SPT.base));\n\t}\n\n\tlen = spt_min(len, spt_min(sizeof (buf), SPT.end - SPT.base) - 1);\n\tmemcpy(SPT.base, buf, len);\n\tnul = SPT.base + len;\n\n\tif (nul < SPT.nul) {\n\t\t*SPT.nul = '.';\n\t} else if (nul == SPT.nul && nul + 1 < SPT.end) {\n\t\t*SPT.nul = ' ';\n\t\t*++nul = '\\0';\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}