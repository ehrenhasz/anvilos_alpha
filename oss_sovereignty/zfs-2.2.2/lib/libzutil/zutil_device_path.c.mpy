{
  "module_name": "zutil_device_path.c",
  "hash_id": "3a16a4bc3829b04a0f209ebbc3032c858bd3fca78bcddeb106694fbbb6b961a3",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzutil/zutil_device_path.c",
  "human_readable_source": " \n\n \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <libzutil.h>\n\n \nconst char *\nzfs_basename(const char *path)\n{\n\tconst char *bn = strrchr(path, '/');\n\treturn (bn ? bn + 1 : path);\n}\n\n \nssize_t\nzfs_dirnamelen(const char *path)\n{\n\tconst char *end = strrchr(path, '/');\n\treturn (end ? end - path : -1);\n}\n\n \nint\nzfs_resolve_shortname(const char *name, char *path, size_t len)\n{\n\tconst char *env = getenv(\"ZPOOL_IMPORT_PATH\");\n\n\tif (env) {\n\t\tfor (;;) {\n\t\t\tenv += strspn(env, \":\");\n\t\t\tsize_t dirlen = strcspn(env, \":\");\n\t\t\tif (dirlen) {\n\t\t\t\t(void) snprintf(path, len, \"%.*s/%s\",\n\t\t\t\t    (int)dirlen, env, name);\n\t\t\t\tif (access(path, F_OK) == 0)\n\t\t\t\t\treturn (0);\n\n\t\t\t\tenv += dirlen;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsize_t count;\n\t\tconst char *const *zpool_default_import_path =\n\t\t    zpool_default_search_paths(&count);\n\n\t\tfor (size_t i = 0; i < count; ++i) {\n\t\t\t(void) snprintf(path, len, \"%s/%s\",\n\t\t\t    zpool_default_import_path[i], name);\n\t\t\tif (access(path, F_OK) == 0)\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (errno = ENOENT);\n}\n\n \nstatic int\nzfs_strcmp_shortname(const char *name, const char *cmp_name, int wholedisk)\n{\n\tint path_len, cmp_len, i = 0, error = ENOENT;\n\tchar *dir, *env, *envdup = NULL, *tmp = NULL;\n\tchar path_name[MAXPATHLEN];\n\tconst char *const *zpool_default_import_path = NULL;\n\tsize_t count;\n\n\tcmp_len = strlen(cmp_name);\n\tenv = getenv(\"ZPOOL_IMPORT_PATH\");\n\n\tif (env) {\n\t\tenvdup = strdup(env);\n\t\tdir = strtok_r(envdup, \":\", &tmp);\n\t} else {\n\t\tzpool_default_import_path = zpool_default_search_paths(&count);\n\t\tdir = (char *)zpool_default_import_path[i];\n\t}\n\n\twhile (dir) {\n\t\t \n\t\tif (env) {\n\t\t\twhile (dir[strlen(dir)-1] == '/')\n\t\t\t\tdir[strlen(dir)-1] = '\\0';\n\t\t}\n\n\t\tpath_len = snprintf(path_name, MAXPATHLEN, \"%s/%s\", dir, name);\n\t\tif (wholedisk)\n\t\t\tpath_len = zfs_append_partition(path_name, MAXPATHLEN);\n\n\t\tif ((path_len == cmp_len) && strcmp(path_name, cmp_name) == 0) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (env) {\n\t\t\tdir = strtok_r(NULL, \":\", &tmp);\n\t\t} else if (++i < count) {\n\t\t\tdir = (char *)zpool_default_import_path[i];\n\t\t} else {\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\tif (env)\n\t\tfree(envdup);\n\n\treturn (error);\n}\n\n \nint\nzfs_strcmp_pathname(const char *name, const char *cmp, int wholedisk)\n{\n\tint path_len, cmp_len;\n\tchar path_name[MAXPATHLEN];\n\tchar cmp_name[MAXPATHLEN];\n\tchar *dir, *tmp = NULL;\n\n\t \n\tcmp_name[0] = '\\0';\n\t(void) strlcpy(path_name, cmp, sizeof (path_name));\n\tfor (dir = strtok_r(path_name, \"/\", &tmp);\n\t    dir != NULL;\n\t    dir = strtok_r(NULL, \"/\", &tmp)) {\n\t\tstrlcat(cmp_name, \"/\", sizeof (cmp_name));\n\t\tstrlcat(cmp_name, dir, sizeof (cmp_name));\n\t}\n\n\tif (name[0] != '/')\n\t\treturn (zfs_strcmp_shortname(name, cmp_name, wholedisk));\n\n\t(void) strlcpy(path_name, name, MAXPATHLEN);\n\tpath_len = strlen(path_name);\n\tcmp_len = strlen(cmp_name);\n\n\tif (wholedisk) {\n\t\tpath_len = zfs_append_partition(path_name, MAXPATHLEN);\n\t\tif (path_len == -1)\n\t\t\treturn (ENOMEM);\n\t}\n\n\tif ((path_len != cmp_len) || strcmp(path_name, cmp_name))\n\t\treturn (ENOENT);\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}