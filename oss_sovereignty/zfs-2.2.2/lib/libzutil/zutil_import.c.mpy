{
  "module_name": "zutil_import.c",
  "hash_id": "13c6c0795059ec13128824767f50275bf7817dd846d3bfd28504fe1433b1ee15",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzutil/zutil_import.c",
  "human_readable_source": " \n \n\n \n\n#ifdef HAVE_AIO_H\n#include <aio.h>\n#endif\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <libintl.h>\n#include <libgen.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/dktp/fdisk.h>\n#include <sys/vdev_impl.h>\n#include <sys/fs/zfs.h>\n\n#include <thread_pool.h>\n#include <libzutil.h>\n#include <libnvpair.h>\n\n#include \"zutil_import.h\"\n\nconst char *\nlibpc_error_description(libpc_handle_t *hdl)\n{\n\tif (hdl->lpc_desc[0] != '\\0')\n\t\treturn (hdl->lpc_desc);\n\n\tswitch (hdl->lpc_error) {\n\tcase LPC_BADCACHE:\n\t\treturn (dgettext(TEXT_DOMAIN, \"invalid or missing cache file\"));\n\tcase LPC_BADPATH:\n\t\treturn (dgettext(TEXT_DOMAIN, \"must be an absolute path\"));\n\tcase LPC_NOMEM:\n\t\treturn (dgettext(TEXT_DOMAIN, \"out of memory\"));\n\tcase LPC_EACCESS:\n\t\treturn (dgettext(TEXT_DOMAIN, \"some devices require root \"\n\t\t    \"privileges\"));\n\tcase LPC_UNKNOWN:\n\t\treturn (dgettext(TEXT_DOMAIN, \"unknown error\"));\n\tdefault:\n\t\tassert(hdl->lpc_error == 0);\n\t\treturn (dgettext(TEXT_DOMAIN, \"no error\"));\n\t}\n}\n\nstatic __attribute__((format(printf, 2, 3))) void\nzutil_error_aux(libpc_handle_t *hdl, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\t(void) vsnprintf(hdl->lpc_desc, sizeof (hdl->lpc_desc), fmt, ap);\n\thdl->lpc_desc_active = B_TRUE;\n\n\tva_end(ap);\n}\n\nstatic void\nzutil_verror(libpc_handle_t *hdl, lpc_error_t error, const char *fmt,\n    va_list ap)\n{\n\tchar action[1024];\n\n\t(void) vsnprintf(action, sizeof (action), fmt, ap);\n\thdl->lpc_error = error;\n\n\tif (hdl->lpc_desc_active)\n\t\thdl->lpc_desc_active = B_FALSE;\n\telse\n\t\thdl->lpc_desc[0] = '\\0';\n\n\tif (hdl->lpc_printerr)\n\t\t(void) fprintf(stderr, \"%s: %s\\n\", action,\n\t\t    libpc_error_description(hdl));\n}\n\nstatic __attribute__((format(printf, 3, 4))) int\nzutil_error_fmt(libpc_handle_t *hdl, lpc_error_t error,\n    const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\n\tzutil_verror(hdl, error, fmt, ap);\n\n\tva_end(ap);\n\n\treturn (-1);\n}\n\nstatic int\nzutil_error(libpc_handle_t *hdl, lpc_error_t error, const char *msg)\n{\n\treturn (zutil_error_fmt(hdl, error, \"%s\", msg));\n}\n\nstatic int\nzutil_no_memory(libpc_handle_t *hdl)\n{\n\tzutil_error(hdl, LPC_NOMEM, \"internal error\");\n\texit(1);\n}\n\nvoid *\nzutil_alloc(libpc_handle_t *hdl, size_t size)\n{\n\tvoid *data;\n\n\tif ((data = calloc(1, size)) == NULL)\n\t\t(void) zutil_no_memory(hdl);\n\n\treturn (data);\n}\n\nchar *\nzutil_strdup(libpc_handle_t *hdl, const char *str)\n{\n\tchar *ret;\n\n\tif ((ret = strdup(str)) == NULL)\n\t\t(void) zutil_no_memory(hdl);\n\n\treturn (ret);\n}\n\nstatic char *\nzutil_strndup(libpc_handle_t *hdl, const char *str, size_t n)\n{\n\tchar *ret;\n\n\tif ((ret = strndup(str, n)) == NULL)\n\t\t(void) zutil_no_memory(hdl);\n\n\treturn (ret);\n}\n\n \ntypedef struct config_entry {\n\tuint64_t\t\tce_txg;\n\tnvlist_t\t\t*ce_config;\n\tstruct config_entry\t*ce_next;\n} config_entry_t;\n\ntypedef struct vdev_entry {\n\tuint64_t\t\tve_guid;\n\tconfig_entry_t\t\t*ve_configs;\n\tstruct vdev_entry\t*ve_next;\n} vdev_entry_t;\n\ntypedef struct pool_entry {\n\tuint64_t\t\tpe_guid;\n\tvdev_entry_t\t\t*pe_vdevs;\n\tstruct pool_entry\t*pe_next;\n} pool_entry_t;\n\ntypedef struct name_entry {\n\tchar\t\t\t*ne_name;\n\tuint64_t\t\tne_guid;\n\tuint64_t\t\tne_order;\n\tuint64_t\t\tne_num_labels;\n\tstruct name_entry\t*ne_next;\n} name_entry_t;\n\ntypedef struct pool_list {\n\tpool_entry_t\t\t*pools;\n\tname_entry_t\t\t*names;\n} pool_list_t;\n\n \nstatic int\nfix_paths(libpc_handle_t *hdl, nvlist_t *nv, name_entry_t *names)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tuint64_t guid;\n\tname_entry_t *ne, *best;\n\tconst char *path;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (fix_paths(hdl, child[c], names) != 0)\n\t\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\t \n\tverify(nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) == 0);\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) != 0)\n\t\tpath = NULL;\n\n\tbest = NULL;\n\tfor (ne = names; ne != NULL; ne = ne->ne_next) {\n\t\tif (ne->ne_guid == guid) {\n\t\t\tif (path == NULL) {\n\t\t\t\tbest = ne;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((strlen(path) == strlen(ne->ne_name)) &&\n\t\t\t    strncmp(path, ne->ne_name, strlen(path)) == 0) {\n\t\t\t\tbest = ne;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (best == NULL) {\n\t\t\t\tbest = ne;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ne->ne_num_labels > best->ne_num_labels) {\n\t\t\t\tbest = ne;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ne->ne_num_labels == best->ne_num_labels &&\n\t\t\t    ne->ne_order < best->ne_order) {\n\t\t\t\tbest = ne;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best == NULL)\n\t\treturn (0);\n\n\tif (nvlist_add_string(nv, ZPOOL_CONFIG_PATH, best->ne_name) != 0)\n\t\treturn (-1);\n\n\tupdate_vdev_config_dev_strs(nv);\n\n\treturn (0);\n}\n\n \nstatic int\nadd_config(libpc_handle_t *hdl, pool_list_t *pl, const char *path,\n    int order, int num_labels, nvlist_t *config)\n{\n\tuint64_t pool_guid, vdev_guid, top_guid, txg, state;\n\tpool_entry_t *pe;\n\tvdev_entry_t *ve;\n\tconfig_entry_t *ce;\n\tname_entry_t *ne;\n\n\t \n\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE,\n\t    &state) == 0 &&\n\t    (state == POOL_STATE_SPARE || state == POOL_STATE_L2CACHE) &&\n\t    nvlist_lookup_uint64(config, ZPOOL_CONFIG_GUID, &vdev_guid) == 0) {\n\t\tif ((ne = zutil_alloc(hdl, sizeof (name_entry_t))) == NULL)\n\t\t\treturn (-1);\n\n\t\tif ((ne->ne_name = zutil_strdup(hdl, path)) == NULL) {\n\t\t\tfree(ne);\n\t\t\treturn (-1);\n\t\t}\n\t\tne->ne_guid = vdev_guid;\n\t\tne->ne_order = order;\n\t\tne->ne_num_labels = num_labels;\n\t\tne->ne_next = pl->names;\n\t\tpl->names = ne;\n\n\t\treturn (0);\n\t}\n\n\t \n\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t    &pool_guid) != 0 ||\n\t    nvlist_lookup_uint64(config, ZPOOL_CONFIG_GUID,\n\t    &vdev_guid) != 0 ||\n\t    nvlist_lookup_uint64(config, ZPOOL_CONFIG_TOP_GUID,\n\t    &top_guid) != 0 ||\n\t    nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_TXG,\n\t    &txg) != 0 || txg == 0) {\n\t\treturn (0);\n\t}\n\n\t \n\tfor (pe = pl->pools; pe != NULL; pe = pe->pe_next) {\n\t\tif (pe->pe_guid == pool_guid)\n\t\t\tbreak;\n\t}\n\n\tif (pe == NULL) {\n\t\tif ((pe = zutil_alloc(hdl, sizeof (pool_entry_t))) == NULL) {\n\t\t\treturn (-1);\n\t\t}\n\t\tpe->pe_guid = pool_guid;\n\t\tpe->pe_next = pl->pools;\n\t\tpl->pools = pe;\n\t}\n\n\t \n\tfor (ve = pe->pe_vdevs; ve != NULL; ve = ve->ve_next) {\n\t\tif (ve->ve_guid == top_guid)\n\t\t\tbreak;\n\t}\n\n\tif (ve == NULL) {\n\t\tif ((ve = zutil_alloc(hdl, sizeof (vdev_entry_t))) == NULL) {\n\t\t\treturn (-1);\n\t\t}\n\t\tve->ve_guid = top_guid;\n\t\tve->ve_next = pe->pe_vdevs;\n\t\tpe->pe_vdevs = ve;\n\t}\n\n\t \n\tfor (ce = ve->ve_configs; ce != NULL; ce = ce->ce_next) {\n\t\tif (ce->ce_txg == txg)\n\t\t\tbreak;\n\t}\n\n\tif (ce == NULL) {\n\t\tif ((ce = zutil_alloc(hdl, sizeof (config_entry_t))) == NULL) {\n\t\t\treturn (-1);\n\t\t}\n\t\tce->ce_txg = txg;\n\t\tce->ce_config = fnvlist_dup(config);\n\t\tce->ce_next = ve->ve_configs;\n\t\tve->ve_configs = ce;\n\t}\n\n\t \n\tif ((ne = zutil_alloc(hdl, sizeof (name_entry_t))) == NULL)\n\t\treturn (-1);\n\n\tif ((ne->ne_name = zutil_strdup(hdl, path)) == NULL) {\n\t\tfree(ne);\n\t\treturn (-1);\n\t}\n\n\tne->ne_guid = vdev_guid;\n\tne->ne_order = order;\n\tne->ne_num_labels = num_labels;\n\tne->ne_next = pl->names;\n\tpl->names = ne;\n\n\treturn (0);\n}\n\nstatic int\nzutil_pool_active(libpc_handle_t *hdl, const char *name, uint64_t guid,\n    boolean_t *isactive)\n{\n\tASSERT(hdl->lpc_ops->pco_pool_active != NULL);\n\n\tint error = hdl->lpc_ops->pco_pool_active(hdl->lpc_lib_handle, name,\n\t    guid, isactive);\n\n\treturn (error);\n}\n\nstatic nvlist_t *\nzutil_refresh_config(libpc_handle_t *hdl, nvlist_t *tryconfig)\n{\n\tASSERT(hdl->lpc_ops->pco_refresh_config != NULL);\n\n\treturn (hdl->lpc_ops->pco_refresh_config(hdl->lpc_lib_handle,\n\t    tryconfig));\n}\n\n \nstatic boolean_t\nvdev_is_hole(uint64_t *hole_array, uint_t holes, uint_t id)\n{\n\tint c;\n\n\tfor (c = 0; c < holes; c++) {\n\n\t\t \n\t\tif (hole_array[c] == id)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic nvlist_t *\nget_configs(libpc_handle_t *hdl, pool_list_t *pl, boolean_t active_ok,\n    nvlist_t *policy)\n{\n\tpool_entry_t *pe;\n\tvdev_entry_t *ve;\n\tconfig_entry_t *ce;\n\tnvlist_t *ret = NULL, *config = NULL, *tmp = NULL, *nvtop, *nvroot;\n\tnvlist_t **spares, **l2cache;\n\tuint_t i, nspares, nl2cache;\n\tboolean_t config_seen;\n\tuint64_t best_txg;\n\tconst char *name, *hostname = NULL;\n\tuint64_t guid;\n\tuint_t children = 0;\n\tnvlist_t **child = NULL;\n\tuint64_t *hole_array, max_id;\n\tuint_t c;\n\tboolean_t isactive;\n\tnvlist_t *nvl;\n\tboolean_t valid_top_config = B_FALSE;\n\n\tif (nvlist_alloc(&ret, 0, 0) != 0)\n\t\tgoto nomem;\n\n\tfor (pe = pl->pools; pe != NULL; pe = pe->pe_next) {\n\t\tuint64_t id, max_txg = 0, hostid = 0;\n\t\tuint_t holes = 0;\n\n\t\tif (nvlist_alloc(&config, NV_UNIQUE_NAME, 0) != 0)\n\t\t\tgoto nomem;\n\t\tconfig_seen = B_FALSE;\n\n\t\t \n\t\tfor (ve = pe->pe_vdevs; ve != NULL; ve = ve->ve_next) {\n\n\t\t\t \n\t\t\tbest_txg = 0;\n\t\t\tfor (ce = ve->ve_configs; ce != NULL;\n\t\t\t    ce = ce->ce_next) {\n\n\t\t\t\tif (ce->ce_txg > best_txg) {\n\t\t\t\t\ttmp = ce->ce_config;\n\t\t\t\t\tbest_txg = ce->ce_txg;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (best_txg > max_txg) {\n\t\t\t\t(void) nvlist_remove(config,\n\t\t\t\t    ZPOOL_CONFIG_VDEV_CHILDREN,\n\t\t\t\t    DATA_TYPE_UINT64);\n\t\t\t\t(void) nvlist_remove(config,\n\t\t\t\t    ZPOOL_CONFIG_HOLE_ARRAY,\n\t\t\t\t    DATA_TYPE_UINT64_ARRAY);\n\n\t\t\t\tmax_txg = best_txg;\n\t\t\t\thole_array = NULL;\n\t\t\t\tholes = 0;\n\t\t\t\tmax_id = 0;\n\t\t\t\tvalid_top_config = B_FALSE;\n\n\t\t\t\tif (nvlist_lookup_uint64(tmp,\n\t\t\t\t    ZPOOL_CONFIG_VDEV_CHILDREN, &max_id) == 0) {\n\t\t\t\t\tverify(nvlist_add_uint64(config,\n\t\t\t\t\t    ZPOOL_CONFIG_VDEV_CHILDREN,\n\t\t\t\t\t    max_id) == 0);\n\t\t\t\t\tvalid_top_config = B_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (nvlist_lookup_uint64_array(tmp,\n\t\t\t\t    ZPOOL_CONFIG_HOLE_ARRAY, &hole_array,\n\t\t\t\t    &holes) == 0) {\n\t\t\t\t\tverify(nvlist_add_uint64_array(config,\n\t\t\t\t\t    ZPOOL_CONFIG_HOLE_ARRAY,\n\t\t\t\t\t    hole_array, holes) == 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!config_seen) {\n\t\t\t\t \n\t\t\t\tuint64_t state, version;\n\t\t\t\tconst char *comment = NULL;\n\t\t\t\tconst char *compatibility = NULL;\n\n\t\t\t\tversion = fnvlist_lookup_uint64(tmp,\n\t\t\t\t    ZPOOL_CONFIG_VERSION);\n\t\t\t\tfnvlist_add_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_VERSION, version);\n\t\t\t\tguid = fnvlist_lookup_uint64(tmp,\n\t\t\t\t    ZPOOL_CONFIG_POOL_GUID);\n\t\t\t\tfnvlist_add_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_GUID, guid);\n\t\t\t\tname = fnvlist_lookup_string(tmp,\n\t\t\t\t    ZPOOL_CONFIG_POOL_NAME);\n\t\t\t\tfnvlist_add_string(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_NAME, name);\n\n\t\t\t\tif (nvlist_lookup_string(tmp,\n\t\t\t\t    ZPOOL_CONFIG_COMMENT, &comment) == 0)\n\t\t\t\t\tfnvlist_add_string(config,\n\t\t\t\t\t    ZPOOL_CONFIG_COMMENT, comment);\n\n\t\t\t\tif (nvlist_lookup_string(tmp,\n\t\t\t\t    ZPOOL_CONFIG_COMPATIBILITY,\n\t\t\t\t    &compatibility) == 0)\n\t\t\t\t\tfnvlist_add_string(config,\n\t\t\t\t\t    ZPOOL_CONFIG_COMPATIBILITY,\n\t\t\t\t\t    compatibility);\n\n\t\t\t\tstate = fnvlist_lookup_uint64(tmp,\n\t\t\t\t    ZPOOL_CONFIG_POOL_STATE);\n\t\t\t\tfnvlist_add_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_STATE, state);\n\n\t\t\t\thostid = 0;\n\t\t\t\tif (nvlist_lookup_uint64(tmp,\n\t\t\t\t    ZPOOL_CONFIG_HOSTID, &hostid) == 0) {\n\t\t\t\t\tfnvlist_add_uint64(config,\n\t\t\t\t\t    ZPOOL_CONFIG_HOSTID, hostid);\n\t\t\t\t\thostname = fnvlist_lookup_string(tmp,\n\t\t\t\t\t    ZPOOL_CONFIG_HOSTNAME);\n\t\t\t\t\tfnvlist_add_string(config,\n\t\t\t\t\t    ZPOOL_CONFIG_HOSTNAME, hostname);\n\t\t\t\t}\n\n\t\t\t\tconfig_seen = B_TRUE;\n\t\t\t}\n\n\t\t\t \n\t\t\tverify(nvlist_lookup_nvlist(tmp,\n\t\t\t    ZPOOL_CONFIG_VDEV_TREE, &nvtop) == 0);\n\t\t\tverify(nvlist_lookup_uint64(nvtop, ZPOOL_CONFIG_ID,\n\t\t\t    &id) == 0);\n\n\t\t\tif (id >= children) {\n\t\t\t\tnvlist_t **newchild;\n\n\t\t\t\tnewchild = zutil_alloc(hdl, (id + 1) *\n\t\t\t\t    sizeof (nvlist_t *));\n\t\t\t\tif (newchild == NULL)\n\t\t\t\t\tgoto nomem;\n\n\t\t\t\tfor (c = 0; c < children; c++)\n\t\t\t\t\tnewchild[c] = child[c];\n\n\t\t\t\tfree(child);\n\t\t\t\tchild = newchild;\n\t\t\t\tchildren = id + 1;\n\t\t\t}\n\t\t\tif (nvlist_dup(nvtop, &child[id], 0) != 0)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\n\t\t \n\t\tif (valid_top_config) {\n\t\t\tif (max_id < children) {\n\t\t\t\tfor (c = max_id; c < children; c++)\n\t\t\t\t\tnvlist_free(child[c]);\n\t\t\t\tchildren = max_id;\n\t\t\t} else if (max_id > children) {\n\t\t\t\tnvlist_t **newchild;\n\n\t\t\t\tnewchild = zutil_alloc(hdl, (max_id) *\n\t\t\t\t    sizeof (nvlist_t *));\n\t\t\t\tif (newchild == NULL)\n\t\t\t\t\tgoto nomem;\n\n\t\t\t\tfor (c = 0; c < children; c++)\n\t\t\t\t\tnewchild[c] = child[c];\n\n\t\t\t\tfree(child);\n\t\t\t\tchild = newchild;\n\t\t\t\tchildren = max_id;\n\t\t\t}\n\t\t}\n\n\t\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t\t    &guid) == 0);\n\n\t\t \n\t\tif (holes > 0) {\n\t\t\tASSERT(valid_top_config);\n\n\t\t\tfor (c = 0; c < children; c++) {\n\t\t\t\tnvlist_t *holey;\n\n\t\t\t\tif (child[c] != NULL ||\n\t\t\t\t    !vdev_is_hole(hole_array, holes, c))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (nvlist_alloc(&holey, NV_UNIQUE_NAME,\n\t\t\t\t    0) != 0)\n\t\t\t\t\tgoto nomem;\n\n\t\t\t\t \n\t\t\t\tif (nvlist_add_string(holey,\n\t\t\t\t    ZPOOL_CONFIG_TYPE,\n\t\t\t\t    VDEV_TYPE_HOLE) != 0 ||\n\t\t\t\t    nvlist_add_uint64(holey,\n\t\t\t\t    ZPOOL_CONFIG_ID, c) != 0 ||\n\t\t\t\t    nvlist_add_uint64(holey,\n\t\t\t\t    ZPOOL_CONFIG_GUID, 0ULL) != 0) {\n\t\t\t\t\tnvlist_free(holey);\n\t\t\t\t\tgoto nomem;\n\t\t\t\t}\n\t\t\t\tchild[c] = holey;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif (child[c] == NULL) {\n\t\t\t\tnvlist_t *missing;\n\t\t\t\tif (nvlist_alloc(&missing, NV_UNIQUE_NAME,\n\t\t\t\t    0) != 0)\n\t\t\t\t\tgoto nomem;\n\t\t\t\tif (nvlist_add_string(missing,\n\t\t\t\t    ZPOOL_CONFIG_TYPE,\n\t\t\t\t    VDEV_TYPE_MISSING) != 0 ||\n\t\t\t\t    nvlist_add_uint64(missing,\n\t\t\t\t    ZPOOL_CONFIG_ID, c) != 0 ||\n\t\t\t\t    nvlist_add_uint64(missing,\n\t\t\t\t    ZPOOL_CONFIG_GUID, 0ULL) != 0) {\n\t\t\t\t\tnvlist_free(missing);\n\t\t\t\t\tgoto nomem;\n\t\t\t\t}\n\t\t\t\tchild[c] = missing;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (nvlist_alloc(&nvroot, NV_UNIQUE_NAME, 0) != 0)\n\t\t\tgoto nomem;\n\t\tif (nvlist_add_string(nvroot, ZPOOL_CONFIG_TYPE,\n\t\t    VDEV_TYPE_ROOT) != 0 ||\n\t\t    nvlist_add_uint64(nvroot, ZPOOL_CONFIG_ID, 0ULL) != 0 ||\n\t\t    nvlist_add_uint64(nvroot, ZPOOL_CONFIG_GUID, guid) != 0 ||\n\t\t    nvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t\t    (const nvlist_t **)child, children) != 0) {\n\t\t\tnvlist_free(nvroot);\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tfor (c = 0; c < children; c++)\n\t\t\tnvlist_free(child[c]);\n\t\tfree(child);\n\t\tchildren = 0;\n\t\tchild = NULL;\n\n\t\t \n\t\tif (fix_paths(hdl, nvroot, pl->names) != 0) {\n\t\t\tnvlist_free(nvroot);\n\t\t\tgoto nomem;\n\t\t}\n\n\t\t \n\t\tif (nvlist_add_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    nvroot) != 0) {\n\t\t\tnvlist_free(nvroot);\n\t\t\tgoto nomem;\n\t\t}\n\t\tnvlist_free(nvroot);\n\n\t\t \n\t\tif (active_ok)\n\t\t\tgoto add_pool;\n\n\t\t \n\t\tverify(nvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME,\n\t\t    &name) == 0);\n\t\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t\t    &guid) == 0);\n\n\t\tif (zutil_pool_active(hdl, name, guid, &isactive) != 0)\n\t\t\tgoto error;\n\n\t\tif (isactive) {\n\t\t\tnvlist_free(config);\n\t\t\tconfig = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (policy != NULL) {\n\t\t\tif (nvlist_add_nvlist(config, ZPOOL_LOAD_POLICY,\n\t\t\t    policy) != 0)\n\t\t\t\tgoto nomem;\n\t\t}\n\n\t\tif ((nvl = zutil_refresh_config(hdl, config)) == NULL) {\n\t\t\tnvlist_free(config);\n\t\t\tconfig = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnvlist_free(config);\n\t\tconfig = nvl;\n\n\t\t \n\t\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &nvroot) == 0);\n\t\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t\t    &spares, &nspares) == 0) {\n\t\t\tfor (i = 0; i < nspares; i++) {\n\t\t\t\tif (fix_paths(hdl, spares[i], pl->names) != 0)\n\t\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_L2CACHE,\n\t\t    &l2cache, &nl2cache) == 0) {\n\t\t\tfor (i = 0; i < nl2cache; i++) {\n\t\t\t\tif (fix_paths(hdl, l2cache[i], pl->names) != 0)\n\t\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t(void) nvlist_remove(config, ZPOOL_CONFIG_HOSTID,\n\t\t    DATA_TYPE_UINT64);\n\t\t(void) nvlist_remove(config, ZPOOL_CONFIG_HOSTNAME,\n\t\t    DATA_TYPE_STRING);\n\t\tif (hostid != 0) {\n\t\t\tverify(nvlist_add_uint64(config, ZPOOL_CONFIG_HOSTID,\n\t\t\t    hostid) == 0);\n\t\t\tverify(nvlist_add_string(config, ZPOOL_CONFIG_HOSTNAME,\n\t\t\t    hostname) == 0);\n\t\t}\n\nadd_pool:\n\t\t \n\t\tverify(nvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME,\n\t\t    &name) == 0);\n\n\t\tif (nvlist_add_nvlist(ret, name, config) != 0)\n\t\t\tgoto nomem;\n\n\t\tnvlist_free(config);\n\t\tconfig = NULL;\n\t}\n\n\treturn (ret);\n\nnomem:\n\t(void) zutil_no_memory(hdl);\nerror:\n\tnvlist_free(config);\n\tnvlist_free(ret);\n\tfor (c = 0; c < children; c++)\n\t\tnvlist_free(child[c]);\n\tfree(child);\n\n\treturn (NULL);\n}\n\n \nstatic uint64_t\nlabel_offset(uint64_t size, int l)\n{\n\tASSERT(P2PHASE_TYPED(size, sizeof (vdev_label_t), uint64_t) == 0);\n\treturn (l * sizeof (vdev_label_t) + (l < VDEV_LABELS / 2 ?\n\t    0 : size - VDEV_LABELS * sizeof (vdev_label_t)));\n}\n\n \nstatic int\nzpool_read_label_slow(int fd, nvlist_t **config, int *num_labels)\n{\n\tstruct stat64 statbuf;\n\tint l, count = 0;\n\tvdev_phys_t *label;\n\tnvlist_t *expected_config = NULL;\n\tuint64_t expected_guid = 0, size;\n\n\t*config = NULL;\n\n\tif (fstat64_blk(fd, &statbuf) == -1)\n\t\treturn (0);\n\tsize = P2ALIGN_TYPED(statbuf.st_size, sizeof (vdev_label_t), uint64_t);\n\n\tlabel = (vdev_phys_t *)umem_alloc_aligned(sizeof (*label), PAGESIZE,\n\t    UMEM_DEFAULT);\n\tif (label == NULL)\n\t\treturn (-1);\n\n\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\tuint64_t state, guid, txg;\n\t\toff_t offset = label_offset(size, l) + VDEV_SKIP_SIZE;\n\n\t\tif (pread64(fd, label, sizeof (vdev_phys_t),\n\t\t    offset) != sizeof (vdev_phys_t))\n\t\t\tcontinue;\n\n\t\tif (nvlist_unpack(label->vp_nvlist,\n\t\t    sizeof (label->vp_nvlist), config, 0) != 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(*config, ZPOOL_CONFIG_GUID,\n\t\t    &guid) != 0 || guid == 0) {\n\t\t\tnvlist_free(*config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nvlist_lookup_uint64(*config, ZPOOL_CONFIG_POOL_STATE,\n\t\t    &state) != 0 || state > POOL_STATE_L2CACHE) {\n\t\t\tnvlist_free(*config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state != POOL_STATE_SPARE && state != POOL_STATE_L2CACHE &&\n\t\t    (nvlist_lookup_uint64(*config, ZPOOL_CONFIG_POOL_TXG,\n\t\t    &txg) != 0 || txg == 0)) {\n\t\t\tnvlist_free(*config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (expected_guid) {\n\t\t\tif (expected_guid == guid)\n\t\t\t\tcount++;\n\n\t\t\tnvlist_free(*config);\n\t\t} else {\n\t\t\texpected_config = *config;\n\t\t\texpected_guid = guid;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (num_labels != NULL)\n\t\t*num_labels = count;\n\n\tumem_free_aligned(label, sizeof (*label));\n\t*config = expected_config;\n\n\treturn (0);\n}\n\n \nint\nzpool_read_label(int fd, nvlist_t **config, int *num_labels)\n{\n#ifndef HAVE_AIO_H\n\treturn (zpool_read_label_slow(fd, config, num_labels));\n#else\n\tstruct stat64 statbuf;\n\tstruct aiocb aiocbs[VDEV_LABELS];\n\tstruct aiocb *aiocbps[VDEV_LABELS];\n\tvdev_phys_t *labels;\n\tnvlist_t *expected_config = NULL;\n\tuint64_t expected_guid = 0, size;\n\tint error, l, count = 0;\n\n\t*config = NULL;\n\n\tif (fstat64_blk(fd, &statbuf) == -1)\n\t\treturn (0);\n\tsize = P2ALIGN_TYPED(statbuf.st_size, sizeof (vdev_label_t), uint64_t);\n\n\tlabels = (vdev_phys_t *)umem_alloc_aligned(\n\t    VDEV_LABELS * sizeof (*labels), PAGESIZE, UMEM_DEFAULT);\n\tif (labels == NULL)\n\t\treturn (-1);\n\n\tmemset(aiocbs, 0, sizeof (aiocbs));\n\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\toff_t offset = label_offset(size, l) + VDEV_SKIP_SIZE;\n\n\t\taiocbs[l].aio_fildes = fd;\n\t\taiocbs[l].aio_offset = offset;\n\t\taiocbs[l].aio_buf = &labels[l];\n\t\taiocbs[l].aio_nbytes = sizeof (vdev_phys_t);\n\t\taiocbs[l].aio_lio_opcode = LIO_READ;\n\t\taiocbps[l] = &aiocbs[l];\n\t}\n\n\tif (lio_listio(LIO_WAIT, aiocbps, VDEV_LABELS, NULL) != 0) {\n\t\tint saved_errno = errno;\n\t\tboolean_t do_slow = B_FALSE;\n\t\terror = -1;\n\n\t\tif (errno == EAGAIN || errno == EINTR || errno == EIO) {\n\t\t\t \n\t\t\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\t\t\terrno = 0;\n\t\t\t\tswitch (aio_error(&aiocbs[l])) {\n\t\t\t\tcase EINVAL:\n\t\t\t\t\tbreak;\n\t\t\t\tcase EINPROGRESS:\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tASSERT(B_FALSE);\n\t\t\t\t\tzfs_fallthrough;\n\t\t\t\tcase EOPNOTSUPP:\n\t\t\t\tcase ENOSYS:\n\t\t\t\t\tdo_slow = B_TRUE;\n\t\t\t\t\tzfs_fallthrough;\n\t\t\t\tcase 0:\n\t\t\t\tdefault:\n\t\t\t\t\t(void) aio_return(&aiocbs[l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (do_slow) {\n\t\t\t \n\t\t\terror = zpool_read_label_slow(fd, config, num_labels);\n\t\t\tsaved_errno = errno;\n\t\t}\n\t\tumem_free_aligned(labels, VDEV_LABELS * sizeof (*labels));\n\t\terrno = saved_errno;\n\t\treturn (error);\n\t}\n\n\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\tuint64_t state, guid, txg;\n\n\t\tif (aio_return(&aiocbs[l]) != sizeof (vdev_phys_t))\n\t\t\tcontinue;\n\n\t\tif (nvlist_unpack(labels[l].vp_nvlist,\n\t\t    sizeof (labels[l].vp_nvlist), config, 0) != 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(*config, ZPOOL_CONFIG_GUID,\n\t\t    &guid) != 0 || guid == 0) {\n\t\t\tnvlist_free(*config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nvlist_lookup_uint64(*config, ZPOOL_CONFIG_POOL_STATE,\n\t\t    &state) != 0 || state > POOL_STATE_L2CACHE) {\n\t\t\tnvlist_free(*config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state != POOL_STATE_SPARE && state != POOL_STATE_L2CACHE &&\n\t\t    (nvlist_lookup_uint64(*config, ZPOOL_CONFIG_POOL_TXG,\n\t\t    &txg) != 0 || txg == 0)) {\n\t\t\tnvlist_free(*config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (expected_guid) {\n\t\t\tif (expected_guid == guid)\n\t\t\t\tcount++;\n\n\t\t\tnvlist_free(*config);\n\t\t} else {\n\t\t\texpected_config = *config;\n\t\t\texpected_guid = guid;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (num_labels != NULL)\n\t\t*num_labels = count;\n\n\tumem_free_aligned(labels, VDEV_LABELS * sizeof (*labels));\n\t*config = expected_config;\n\n\treturn (0);\n#endif\n}\n\n \nint\nslice_cache_compare(const void *arg1, const void *arg2)\n{\n\tconst char  *nm1 = ((rdsk_node_t *)arg1)->rn_name;\n\tconst char  *nm2 = ((rdsk_node_t *)arg2)->rn_name;\n\tuint64_t guid1 = ((rdsk_node_t *)arg1)->rn_vdev_guid;\n\tuint64_t guid2 = ((rdsk_node_t *)arg2)->rn_vdev_guid;\n\tint rv;\n\n\trv = TREE_ISIGN(strcmp(nm1, nm2));\n\tif (rv)\n\t\treturn (rv);\n\n\treturn (TREE_CMP(guid1, guid2));\n}\n\nstatic int\nlabel_paths_impl(libpc_handle_t *hdl, nvlist_t *nvroot, uint64_t pool_guid,\n    uint64_t vdev_guid, const char **path, const char **devid)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tuint64_t guid;\n\tconst char *val;\n\tint error;\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\terror  = label_paths_impl(hdl, child[c],\n\t\t\t    pool_guid, vdev_guid, path, devid);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (nvroot == NULL)\n\t\treturn (0);\n\n\terror = nvlist_lookup_uint64(nvroot, ZPOOL_CONFIG_GUID, &guid);\n\tif ((error != 0) || (guid != vdev_guid))\n\t\treturn (0);\n\n\terror = nvlist_lookup_string(nvroot, ZPOOL_CONFIG_PATH, &val);\n\tif (error == 0)\n\t\t*path = val;\n\n\terror = nvlist_lookup_string(nvroot, ZPOOL_CONFIG_DEVID, &val);\n\tif (error == 0)\n\t\t*devid = val;\n\n\treturn (0);\n}\n\n \nint\nlabel_paths(libpc_handle_t *hdl, nvlist_t *label, const char **path,\n    const char **devid)\n{\n\tnvlist_t *nvroot;\n\tuint64_t pool_guid;\n\tuint64_t vdev_guid;\n\n\t*path = NULL;\n\t*devid = NULL;\n\n\tif (nvlist_lookup_nvlist(label, ZPOOL_CONFIG_VDEV_TREE, &nvroot) ||\n\t    nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_GUID, &pool_guid) ||\n\t    nvlist_lookup_uint64(label, ZPOOL_CONFIG_GUID, &vdev_guid))\n\t\treturn (ENOENT);\n\n\treturn (label_paths_impl(hdl, nvroot, pool_guid, vdev_guid, path,\n\t    devid));\n}\n\nstatic void\nzpool_find_import_scan_add_slice(libpc_handle_t *hdl, pthread_mutex_t *lock,\n    avl_tree_t *cache, const char *path, const char *name, int order)\n{\n\tavl_index_t where;\n\trdsk_node_t *slice;\n\n\tslice = zutil_alloc(hdl, sizeof (rdsk_node_t));\n\tif (asprintf(&slice->rn_name, \"%s/%s\", path, name) == -1) {\n\t\tfree(slice);\n\t\treturn;\n\t}\n\tslice->rn_vdev_guid = 0;\n\tslice->rn_lock = lock;\n\tslice->rn_avl = cache;\n\tslice->rn_hdl = hdl;\n\tslice->rn_order = order + IMPORT_ORDER_SCAN_OFFSET;\n\tslice->rn_labelpaths = B_FALSE;\n\n\tpthread_mutex_lock(lock);\n\tif (avl_find(cache, slice, &where)) {\n\t\tfree(slice->rn_name);\n\t\tfree(slice);\n\t} else {\n\t\tavl_insert(cache, slice, where);\n\t}\n\tpthread_mutex_unlock(lock);\n}\n\nstatic int\nzpool_find_import_scan_dir(libpc_handle_t *hdl, pthread_mutex_t *lock,\n    avl_tree_t *cache, const char *dir, int order)\n{\n\tint error;\n\tchar path[MAXPATHLEN];\n\tstruct dirent64 *dp;\n\tDIR *dirp;\n\n\tif (realpath(dir, path) == NULL) {\n\t\terror = errno;\n\t\tif (error == ENOENT)\n\t\t\treturn (0);\n\n\t\tzutil_error_aux(hdl, \"%s\", strerror(error));\n\t\t(void) zutil_error_fmt(hdl, LPC_BADPATH, dgettext(TEXT_DOMAIN,\n\t\t    \"cannot resolve path '%s'\"), dir);\n\t\treturn (error);\n\t}\n\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\terror = errno;\n\t\tzutil_error_aux(hdl, \"%s\", strerror(error));\n\t\t(void) zutil_error_fmt(hdl, LPC_BADPATH, dgettext(TEXT_DOMAIN,\n\t\t    \"cannot open '%s'\"), path);\n\t\treturn (error);\n\t}\n\n\twhile ((dp = readdir64(dirp)) != NULL) {\n\t\tconst char *name = dp->d_name;\n\t\tif (strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tswitch (dp->d_type) {\n\t\tcase DT_UNKNOWN:\n\t\tcase DT_BLK:\n\t\tcase DT_LNK:\n#ifdef __FreeBSD__\n\t\tcase DT_CHR:\n#endif\n\t\tcase DT_REG:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tzpool_find_import_scan_add_slice(hdl, lock, cache, path, name,\n\t\t    order);\n\t}\n\n\t(void) closedir(dirp);\n\treturn (0);\n}\n\nstatic int\nzpool_find_import_scan_path(libpc_handle_t *hdl, pthread_mutex_t *lock,\n    avl_tree_t *cache, const char *dir, int order)\n{\n\tint error = 0;\n\tchar path[MAXPATHLEN];\n\tchar *d = NULL;\n\tssize_t dl;\n\tconst char *dpath, *name;\n\n\t \n\tname = zfs_basename(dir);\n\tif ((dl = zfs_dirnamelen(dir)) == -1)\n\t\tdpath = \".\";\n\telse\n\t\tdpath = d = zutil_strndup(hdl, dir, dl);\n\n\tif (realpath(dpath, path) == NULL) {\n\t\terror = errno;\n\t\tif (error == ENOENT) {\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tzutil_error_aux(hdl, \"%s\", strerror(error));\n\t\t(void) zutil_error_fmt(hdl, LPC_BADPATH, dgettext(TEXT_DOMAIN,\n\t\t    \"cannot resolve path '%s'\"), dir);\n\t\tgoto out;\n\t}\n\n\tzpool_find_import_scan_add_slice(hdl, lock, cache, path, name, order);\n\nout:\n\tfree(d);\n\treturn (error);\n}\n\n \nstatic int\nzpool_find_import_scan(libpc_handle_t *hdl, pthread_mutex_t *lock,\n    avl_tree_t **slice_cache, const char * const *dir, size_t dirs)\n{\n\tavl_tree_t *cache;\n\trdsk_node_t *slice;\n\tvoid *cookie;\n\tint i, error;\n\n\t*slice_cache = NULL;\n\tcache = zutil_alloc(hdl, sizeof (avl_tree_t));\n\tavl_create(cache, slice_cache_compare, sizeof (rdsk_node_t),\n\t    offsetof(rdsk_node_t, rn_node));\n\n\tfor (i = 0; i < dirs; i++) {\n\t\tstruct stat sbuf;\n\n\t\tif (stat(dir[i], &sbuf) != 0) {\n\t\t\terror = errno;\n\t\t\tif (error == ENOENT)\n\t\t\t\tcontinue;\n\n\t\t\tzutil_error_aux(hdl, \"%s\", strerror(error));\n\t\t\t(void) zutil_error_fmt(hdl, LPC_BADPATH, dgettext(\n\t\t\t    TEXT_DOMAIN, \"cannot resolve path '%s'\"), dir[i]);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (S_ISDIR(sbuf.st_mode)) {\n\t\t\tif ((error = zpool_find_import_scan_dir(hdl, lock,\n\t\t\t    cache, dir[i], i)) != 0)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tif ((error = zpool_find_import_scan_path(hdl, lock,\n\t\t\t    cache, dir[i], i)) != 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\t*slice_cache = cache;\n\treturn (0);\n\nerror:\n\tcookie = NULL;\n\twhile ((slice = avl_destroy_nodes(cache, &cookie)) != NULL) {\n\t\tfree(slice->rn_name);\n\t\tfree(slice);\n\t}\n\tfree(cache);\n\n\treturn (error);\n}\n\n \nstatic nvlist_t *\nzpool_find_import_impl(libpc_handle_t *hdl, importargs_t *iarg,\n    pthread_mutex_t *lock, avl_tree_t *cache)\n{\n\t(void) lock;\n\tnvlist_t *ret = NULL;\n\tpool_list_t pools = { 0 };\n\tpool_entry_t *pe, *penext;\n\tvdev_entry_t *ve, *venext;\n\tconfig_entry_t *ce, *cenext;\n\tname_entry_t *ne, *nenext;\n\trdsk_node_t *slice;\n\tvoid *cookie;\n\ttpool_t *t;\n\n\tverify(iarg->poolname == NULL || iarg->guid == 0);\n\n\t \n\tt = tpool_create(1, 2 * sysconf(_SC_NPROCESSORS_ONLN), 0, NULL);\n\tfor (slice = avl_first(cache); slice;\n\t    (slice = avl_walk(cache, slice, AVL_AFTER)))\n\t\t(void) tpool_dispatch(t, zpool_open_func, slice);\n\n\ttpool_wait(t);\n\ttpool_destroy(t);\n\n\t \n\tcookie = NULL;\n\twhile ((slice = avl_destroy_nodes(cache, &cookie)) != NULL) {\n\t\tif (slice->rn_config != NULL) {\n\t\t\tnvlist_t *config = slice->rn_config;\n\t\t\tboolean_t matched = B_TRUE;\n\t\t\tboolean_t aux = B_FALSE;\n\t\t\tint fd;\n\n\t\t\t \n\t\t\tif (iarg->poolname != NULL || iarg->guid != 0) {\n\t\t\t\tuint64_t state;\n\t\t\t\taux = nvlist_lookup_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_STATE, &state) == 0 &&\n\t\t\t\t    (state == POOL_STATE_SPARE ||\n\t\t\t\t    state == POOL_STATE_L2CACHE);\n\t\t\t}\n\n\t\t\tif (iarg->poolname != NULL && !aux) {\n\t\t\t\tconst char *pname;\n\n\t\t\t\tmatched = nvlist_lookup_string(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_NAME, &pname) == 0 &&\n\t\t\t\t    strcmp(iarg->poolname, pname) == 0;\n\t\t\t} else if (iarg->guid != 0 && !aux) {\n\t\t\t\tuint64_t this_guid;\n\n\t\t\t\tmatched = nvlist_lookup_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_GUID, &this_guid) == 0 &&\n\t\t\t\t    iarg->guid == this_guid;\n\t\t\t}\n\t\t\tif (matched) {\n\t\t\t\t \n\t\t\t\tfd = open(slice->rn_name,\n\t\t\t\t    O_RDONLY | O_EXCL | O_CLOEXEC);\n\t\t\t\tif (fd >= 0 || iarg->can_be_active) {\n\t\t\t\t\tif (fd >= 0)\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\tadd_config(hdl, &pools,\n\t\t\t\t\t    slice->rn_name, slice->rn_order,\n\t\t\t\t\t    slice->rn_num_labels, config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnvlist_free(config);\n\t\t}\n\t\tfree(slice->rn_name);\n\t\tfree(slice);\n\t}\n\tavl_destroy(cache);\n\tfree(cache);\n\n\tret = get_configs(hdl, &pools, iarg->can_be_active, iarg->policy);\n\n\tfor (pe = pools.pools; pe != NULL; pe = penext) {\n\t\tpenext = pe->pe_next;\n\t\tfor (ve = pe->pe_vdevs; ve != NULL; ve = venext) {\n\t\t\tvenext = ve->ve_next;\n\t\t\tfor (ce = ve->ve_configs; ce != NULL; ce = cenext) {\n\t\t\t\tcenext = ce->ce_next;\n\t\t\t\tnvlist_free(ce->ce_config);\n\t\t\t\tfree(ce);\n\t\t\t}\n\t\t\tfree(ve);\n\t\t}\n\t\tfree(pe);\n\t}\n\n\tfor (ne = pools.names; ne != NULL; ne = nenext) {\n\t\tnenext = ne->ne_next;\n\t\tfree(ne->ne_name);\n\t\tfree(ne);\n\t}\n\n\treturn (ret);\n}\n\n \nstatic int\ndiscover_cached_paths(libpc_handle_t *hdl, nvlist_t *nv,\n    avl_tree_t *cache, pthread_mutex_t *lock)\n{\n\tconst char *path = NULL;\n\tssize_t dl;\n\tuint_t children;\n\tnvlist_t **child;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (int c = 0; c < children; c++) {\n\t\t\tdiscover_cached_paths(hdl, child[c], cache, lock);\n\t\t}\n\t}\n\n\t \n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) == 0) {\n\t\tint ret;\n\t\tchar c = '\\0';\n\t\tif ((dl = zfs_dirnamelen(path)) == -1) {\n\t\t\tpath = \".\";\n\t\t} else {\n\t\t\tc = path[dl];\n\t\t\t((char *)path)[dl] = '\\0';\n\n\t\t}\n\t\tret = zpool_find_import_scan_dir(hdl, lock, cache,\n\t\t    path, 0);\n\t\tif (c != '\\0')\n\t\t\t((char *)path)[dl] = c;\n\n\t\treturn (ret);\n\t}\n\treturn (0);\n}\n\n \nstatic nvlist_t *\nzpool_find_import_cached(libpc_handle_t *hdl, importargs_t *iarg)\n{\n\tchar *buf;\n\tint fd;\n\tstruct stat64 statbuf;\n\tnvlist_t *raw, *src, *dst;\n\tnvlist_t *pools;\n\tnvpair_t *elem;\n\tconst char *name;\n\tuint64_t this_guid;\n\tboolean_t active;\n\n\tverify(iarg->poolname == NULL || iarg->guid == 0);\n\n\tif ((fd = open(iarg->cachefile, O_RDONLY | O_CLOEXEC)) < 0) {\n\t\tzutil_error_aux(hdl, \"%s\", strerror(errno));\n\t\t(void) zutil_error(hdl, LPC_BADCACHE, dgettext(TEXT_DOMAIN,\n\t\t    \"failed to open cache file\"));\n\t\treturn (NULL);\n\t}\n\n\tif (fstat64(fd, &statbuf) != 0) {\n\t\tzutil_error_aux(hdl, \"%s\", strerror(errno));\n\t\t(void) close(fd);\n\t\t(void) zutil_error(hdl, LPC_BADCACHE, dgettext(TEXT_DOMAIN,\n\t\t    \"failed to get size of cache file\"));\n\t\treturn (NULL);\n\t}\n\n\tif ((buf = zutil_alloc(hdl, statbuf.st_size)) == NULL) {\n\t\t(void) close(fd);\n\t\treturn (NULL);\n\t}\n\n\tif (read(fd, buf, statbuf.st_size) != statbuf.st_size) {\n\t\t(void) close(fd);\n\t\tfree(buf);\n\t\t(void) zutil_error(hdl, LPC_BADCACHE, dgettext(TEXT_DOMAIN,\n\t\t    \"failed to read cache file contents\"));\n\t\treturn (NULL);\n\t}\n\n\t(void) close(fd);\n\n\tif (nvlist_unpack(buf, statbuf.st_size, &raw, 0) != 0) {\n\t\tfree(buf);\n\t\t(void) zutil_error(hdl, LPC_BADCACHE, dgettext(TEXT_DOMAIN,\n\t\t    \"invalid or corrupt cache file contents\"));\n\t\treturn (NULL);\n\t}\n\n\tfree(buf);\n\n\t \n\tif (nvlist_alloc(&pools, 0, 0) != 0) {\n\t\t(void) zutil_no_memory(hdl);\n\t\tnvlist_free(raw);\n\t\treturn (NULL);\n\t}\n\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(raw, elem)) != NULL) {\n\t\tsrc = fnvpair_value_nvlist(elem);\n\n\t\tname = fnvlist_lookup_string(src, ZPOOL_CONFIG_POOL_NAME);\n\t\tif (iarg->poolname != NULL && strcmp(iarg->poolname, name) != 0)\n\t\t\tcontinue;\n\n\t\tthis_guid = fnvlist_lookup_uint64(src, ZPOOL_CONFIG_POOL_GUID);\n\t\tif (iarg->guid != 0 && iarg->guid != this_guid)\n\t\t\tcontinue;\n\n\t\tif (zutil_pool_active(hdl, name, this_guid, &active) != 0) {\n\t\t\tnvlist_free(raw);\n\t\t\tnvlist_free(pools);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tif (active)\n\t\t\tcontinue;\n\n\t\tif (iarg->scan) {\n\t\t\tuint64_t saved_guid = iarg->guid;\n\t\t\tconst char *saved_poolname = iarg->poolname;\n\t\t\tpthread_mutex_t lock;\n\n\t\t\t \n\t\t\tavl_tree_t *cache = zutil_alloc(hdl,\n\t\t\t    sizeof (avl_tree_t));\n\t\t\tavl_create(cache, slice_cache_compare,\n\t\t\t    sizeof (rdsk_node_t),\n\t\t\t    offsetof(rdsk_node_t, rn_node));\n\t\t\tnvlist_t *nvroot = fnvlist_lookup_nvlist(src,\n\t\t\t    ZPOOL_CONFIG_VDEV_TREE);\n\n\t\t\t \n\t\t\tiarg->guid = this_guid;\n\t\t\tiarg->poolname = NULL;\n\n\t\t\t \n\t\t\tpthread_mutex_init(&lock, NULL);\n\t\t\tdiscover_cached_paths(hdl, nvroot, cache, &lock);\n\t\t\tnvlist_t *nv = zpool_find_import_impl(hdl, iarg,\n\t\t\t    &lock, cache);\n\t\t\tpthread_mutex_destroy(&lock);\n\n\t\t\t \n\t\t\tnvpair_t *pair = nvlist_next_nvpair(nv, NULL);\n\t\t\tif (pair == NULL)\n\t\t\t\tcontinue;\n\t\t\tfnvlist_add_nvlist(pools, nvpair_name(pair),\n\t\t\t    fnvpair_value_nvlist(pair));\n\n\t\t\tVERIFY3P(nvlist_next_nvpair(nv, pair), ==, NULL);\n\n\t\t\tiarg->guid = saved_guid;\n\t\t\tiarg->poolname = saved_poolname;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nvlist_add_string(src, ZPOOL_CONFIG_CACHEFILE,\n\t\t    iarg->cachefile) != 0) {\n\t\t\t(void) zutil_no_memory(hdl);\n\t\t\tnvlist_free(raw);\n\t\t\tnvlist_free(pools);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tupdate_vdevs_config_dev_sysfs_path(src);\n\n\t\tif ((dst = zutil_refresh_config(hdl, src)) == NULL) {\n\t\t\tnvlist_free(raw);\n\t\t\tnvlist_free(pools);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tif (nvlist_add_nvlist(pools, nvpair_name(elem), dst) != 0) {\n\t\t\t(void) zutil_no_memory(hdl);\n\t\t\tnvlist_free(dst);\n\t\t\tnvlist_free(raw);\n\t\t\tnvlist_free(pools);\n\t\t\treturn (NULL);\n\t\t}\n\t\tnvlist_free(dst);\n\t}\n\tnvlist_free(raw);\n\treturn (pools);\n}\n\nstatic nvlist_t *\nzpool_find_import(libpc_handle_t *hdl, importargs_t *iarg)\n{\n\tpthread_mutex_t lock;\n\tavl_tree_t *cache;\n\tnvlist_t *pools = NULL;\n\n\tverify(iarg->poolname == NULL || iarg->guid == 0);\n\tpthread_mutex_init(&lock, NULL);\n\n\t \n\tif (iarg->scan || iarg->paths != 0) {\n\t\tsize_t dirs = iarg->paths;\n\t\tconst char * const *dir = (const char * const *)iarg->path;\n\n\t\tif (dirs == 0)\n\t\t\tdir = zpool_default_search_paths(&dirs);\n\n\t\tif (zpool_find_import_scan(hdl, &lock, &cache,\n\t\t    dir, dirs) != 0) {\n\t\t\tpthread_mutex_destroy(&lock);\n\t\t\treturn (NULL);\n\t\t}\n\t} else {\n\t\tif (zpool_find_import_blkid(hdl, &lock, &cache) != 0) {\n\t\t\tpthread_mutex_destroy(&lock);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\tpools = zpool_find_import_impl(hdl, iarg, &lock, cache);\n\tpthread_mutex_destroy(&lock);\n\treturn (pools);\n}\n\n\nnvlist_t *\nzpool_search_import(libpc_handle_t *hdl, importargs_t *import)\n{\n\tnvlist_t *pools = NULL;\n\n\tverify(import->poolname == NULL || import->guid == 0);\n\n\tif (import->cachefile != NULL)\n\t\tpools = zpool_find_import_cached(hdl, import);\n\telse\n\t\tpools = zpool_find_import(hdl, import);\n\n\tif ((pools == NULL || nvlist_empty(pools)) &&\n\t    hdl->lpc_open_access_error && geteuid() != 0) {\n\t\t(void) zutil_error(hdl, LPC_EACCESS, dgettext(TEXT_DOMAIN,\n\t\t    \"no pools found\"));\n\t}\n\n\treturn (pools);\n}\n\nstatic boolean_t\npool_match(nvlist_t *cfg, const char *tgt)\n{\n\tuint64_t v, guid = strtoull(tgt, NULL, 0);\n\tconst char *s;\n\n\tif (guid != 0) {\n\t\tif (nvlist_lookup_uint64(cfg, ZPOOL_CONFIG_POOL_GUID, &v) == 0)\n\t\t\treturn (v == guid);\n\t} else {\n\t\tif (nvlist_lookup_string(cfg, ZPOOL_CONFIG_POOL_NAME, &s) == 0)\n\t\t\treturn (strcmp(s, tgt) == 0);\n\t}\n\treturn (B_FALSE);\n}\n\nint\nzpool_find_config(libpc_handle_t *hdl, const char *target, nvlist_t **configp,\n    importargs_t *args)\n{\n\tnvlist_t *pools;\n\tnvlist_t *match = NULL;\n\tnvlist_t *config = NULL;\n\tchar *sepp = NULL;\n\tint count = 0;\n\tchar *targetdup = strdup(target);\n\n\tif (targetdup == NULL)\n\t\treturn (ENOMEM);\n\n\t*configp = NULL;\n\n\tif ((sepp = strpbrk(targetdup, \"/@\")) != NULL)\n\t\t*sepp = '\\0';\n\n\tpools = zpool_search_import(hdl, args);\n\n\tif (pools != NULL) {\n\t\tnvpair_t *elem = NULL;\n\t\twhile ((elem = nvlist_next_nvpair(pools, elem)) != NULL) {\n\t\t\tVERIFY0(nvpair_value_nvlist(elem, &config));\n\t\t\tif (pool_match(config, targetdup)) {\n\t\t\t\tcount++;\n\t\t\t\tif (match != NULL) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tmatch = fnvlist_dup(config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfnvlist_free(pools);\n\t}\n\n\tif (count == 0) {\n\t\tfree(targetdup);\n\t\treturn (ENOENT);\n\t}\n\n\tif (count > 1) {\n\t\tfree(targetdup);\n\t\tfnvlist_free(match);\n\t\treturn (EINVAL);\n\t}\n\n\t*configp = match;\n\tfree(targetdup);\n\n\treturn (0);\n}\n\n \nint\nfor_each_vdev_cb(void *zhp, nvlist_t *nv, pool_vdev_iter_f func,\n    void *data)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tint ret = 0;\n\tint i;\n\tconst char *type;\n\n\tconst char *list[] = {\n\t    ZPOOL_CONFIG_SPARES,\n\t    ZPOOL_CONFIG_L2CACHE,\n\t    ZPOOL_CONFIG_CHILDREN\n\t};\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) != 0)\n\t\treturn (ret);\n\n\t \n\tif (strcmp(type, VDEV_TYPE_INDIRECT) != 0) {\n\t\tret |= func(zhp, nv, data);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(list); i++) {\n\t\tif (nvlist_lookup_nvlist_array(nv, list[i], &child,\n\t\t    &children) == 0) {\n\t\t\tfor (c = 0; c < children; c++) {\n\t\t\t\tuint64_t ishole = 0;\n\n\t\t\t\t(void) nvlist_lookup_uint64(child[c],\n\t\t\t\t    ZPOOL_CONFIG_IS_HOLE, &ishole);\n\n\t\t\t\tif (ishole)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret |= for_each_vdev_cb(zhp, child[c],\n\t\t\t\t    func, data);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (ret);\n}\n\n \nint\nfor_each_vdev_in_nvlist(nvlist_t *nvroot, pool_vdev_iter_f func, void *data)\n{\n\treturn (for_each_vdev_cb(NULL, nvroot, func, data));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}