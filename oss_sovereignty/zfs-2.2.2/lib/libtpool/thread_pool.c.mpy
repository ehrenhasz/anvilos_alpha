{
  "module_name": "thread_pool.c",
  "hash_id": "81f95c908a808c91fd59c1afda2eb4b2ca79d60fe3cc49db29d9951788afb27d",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libtpool/thread_pool.c",
  "human_readable_source": " \n\n \n\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n#include <assert.h>\n#include <limits.h>\n#include \"thread_pool_impl.h\"\n\nstatic pthread_mutex_t thread_pool_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic tpool_t *thread_pools = NULL;\n\nstatic void\ndelete_pool(tpool_t *tpool)\n{\n\ttpool_job_t *job;\n\n\tASSERT(tpool->tp_current == 0 && tpool->tp_active == NULL);\n\n\t \n\t(void) pthread_mutex_lock(&thread_pool_lock);\n\tif (thread_pools == tpool)\n\t\tthread_pools = tpool->tp_forw;\n\tif (thread_pools == tpool)\n\t\tthread_pools = NULL;\n\telse {\n\t\ttpool->tp_back->tp_forw = tpool->tp_forw;\n\t\ttpool->tp_forw->tp_back = tpool->tp_back;\n\t}\n\tpthread_mutex_unlock(&thread_pool_lock);\n\n\t \n\tfor (job = tpool->tp_head; job != NULL; job = tpool->tp_head) {\n\t\ttpool->tp_head = job->tpj_next;\n\t\tfree(job);\n\t}\n\t(void) pthread_attr_destroy(&tpool->tp_attr);\n\tfree(tpool);\n}\n\n \nstatic void\nworker_cleanup(void *arg)\n{\n\ttpool_t *tpool = (tpool_t *)arg;\n\n\tif (--tpool->tp_current == 0 &&\n\t    (tpool->tp_flags & (TP_DESTROY | TP_ABANDON))) {\n\t\tif (tpool->tp_flags & TP_ABANDON) {\n\t\t\tpthread_mutex_unlock(&tpool->tp_mutex);\n\t\t\tdelete_pool(tpool);\n\t\t\treturn;\n\t\t}\n\t\tif (tpool->tp_flags & TP_DESTROY)\n\t\t\t(void) pthread_cond_broadcast(&tpool->tp_busycv);\n\t}\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n}\n\nstatic void\nnotify_waiters(tpool_t *tpool)\n{\n\tif (tpool->tp_head == NULL && tpool->tp_active == NULL) {\n\t\ttpool->tp_flags &= ~TP_WAIT;\n\t\t(void) pthread_cond_broadcast(&tpool->tp_waitcv);\n\t}\n}\n\n \nstatic void\njob_cleanup(void *arg)\n{\n\ttpool_t *tpool = (tpool_t *)arg;\n\n\tpthread_t my_tid = pthread_self();\n\ttpool_active_t *activep;\n\ttpool_active_t **activepp;\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tfor (activepp = &tpool->tp_active; ; activepp = &activep->tpa_next) {\n\t\tactivep = *activepp;\n\t\tif (activep->tpa_tid == my_tid) {\n\t\t\t*activepp = activep->tpa_next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (tpool->tp_flags & TP_WAIT)\n\t\tnotify_waiters(tpool);\n}\n\nstatic void *\ntpool_worker(void *arg)\n{\n\ttpool_t *tpool = (tpool_t *)arg;\n\tint elapsed;\n\ttpool_job_t *job;\n\tvoid (*func)(void *);\n\ttpool_active_t active;\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tpthread_cleanup_push(worker_cleanup, tpool);\n\n\t \n\tactive.tpa_tid = pthread_self();\n\tfor (;;) {\n\t\telapsed = 0;\n\t\ttpool->tp_idle++;\n\t\tif (tpool->tp_flags & TP_WAIT)\n\t\t\tnotify_waiters(tpool);\n\t\twhile ((tpool->tp_head == NULL ||\n\t\t    (tpool->tp_flags & TP_SUSPEND)) &&\n\t\t    !(tpool->tp_flags & (TP_DESTROY | TP_ABANDON))) {\n\t\t\tif (tpool->tp_current <= tpool->tp_minimum ||\n\t\t\t    tpool->tp_linger == 0) {\n\t\t\t\t(void) pthread_cond_wait(&tpool->tp_workcv,\n\t\t\t\t    &tpool->tp_mutex);\n\t\t\t} else {\n\t\t\t\tstruct timespec ts;\n\n\t\t\t\tclock_gettime(CLOCK_REALTIME, &ts);\n\t\t\t\tts.tv_sec += tpool->tp_linger;\n\n\t\t\t\tif (pthread_cond_timedwait(&tpool->tp_workcv,\n\t\t\t\t    &tpool->tp_mutex, &ts) != 0) {\n\t\t\t\t\telapsed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttpool->tp_idle--;\n\t\tif (tpool->tp_flags & TP_DESTROY)\n\t\t\tbreak;\n\t\tif (tpool->tp_flags & TP_ABANDON) {\n\t\t\t \n\t\t\tif (tpool->tp_flags & TP_SUSPEND) {\n\t\t\t\ttpool->tp_flags &= ~TP_SUSPEND;\n\t\t\t\t(void) pthread_cond_broadcast(\n\t\t\t\t    &tpool->tp_workcv);\n\t\t\t}\n\t\t\tif (tpool->tp_head == NULL)\n\t\t\t\tbreak;\n\t\t}\n\t\tif ((job = tpool->tp_head) != NULL &&\n\t\t    !(tpool->tp_flags & TP_SUSPEND)) {\n\t\t\telapsed = 0;\n\t\t\tfunc = job->tpj_func;\n\t\t\targ = job->tpj_arg;\n\t\t\ttpool->tp_head = job->tpj_next;\n\t\t\tif (job == tpool->tp_tail)\n\t\t\t\ttpool->tp_tail = NULL;\n\t\t\ttpool->tp_njobs--;\n\t\t\tactive.tpa_next = tpool->tp_active;\n\t\t\ttpool->tp_active = &active;\n\t\t\tpthread_mutex_unlock(&tpool->tp_mutex);\n\t\t\tpthread_cleanup_push(job_cleanup, tpool);\n\t\t\tfree(job);\n\n\t\t\tsigset_t maskset;\n\t\t\t(void) pthread_sigmask(SIG_SETMASK, NULL, &maskset);\n\n\t\t\t \n\t\t\tfunc(arg);\n\t\t\t \n\t\t\t(void) pthread_sigmask(SIG_SETMASK, &maskset, NULL);\n\t\t\t(void) pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,\n\t\t\t    NULL);\n\t\t\t(void) pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,\n\t\t\t    NULL);\n\t\t\tpthread_cleanup_pop(1);\n\t\t}\n\t\tif (elapsed && tpool->tp_current > tpool->tp_minimum) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tpthread_cleanup_pop(1);\n\treturn (arg);\n}\n\n \nstatic int\ncreate_worker(tpool_t *tpool)\n{\n\tpthread_t thread;\n\tsigset_t oset;\n\tint error;\n\n\t(void) pthread_sigmask(SIG_SETMASK, NULL, &oset);\n\terror = pthread_create(&thread, &tpool->tp_attr, tpool_worker, tpool);\n\t(void) pthread_sigmask(SIG_SETMASK, &oset, NULL);\n\treturn (error);\n}\n\n\n \nstatic int\npthread_attr_clone(pthread_attr_t *attr, const pthread_attr_t *old_attr)\n{\n\tint error;\n\n\terror = pthread_attr_init(attr);\n\tif (error || (old_attr == NULL))\n\t\treturn (error);\n\n#ifdef __GLIBC__\n\tcpu_set_t cpuset;\n\tsize_t cpusetsize = sizeof (cpuset);\n\terror = pthread_attr_getaffinity_np(old_attr, cpusetsize, &cpuset);\n\tif (error == 0)\n\t\terror = pthread_attr_setaffinity_np(attr, cpusetsize, &cpuset);\n\tif (error)\n\t\tgoto error;\n#endif  \n\n\tint detachstate;\n\terror = pthread_attr_getdetachstate(old_attr, &detachstate);\n\tif (error == 0)\n\t\terror = pthread_attr_setdetachstate(attr, detachstate);\n\tif (error)\n\t\tgoto error;\n\n\tsize_t guardsize;\n\terror = pthread_attr_getguardsize(old_attr, &guardsize);\n\tif (error == 0)\n\t\terror = pthread_attr_setguardsize(attr, guardsize);\n\tif (error)\n\t\tgoto error;\n\n\tint inheritsched;\n\terror = pthread_attr_getinheritsched(old_attr, &inheritsched);\n\tif (error == 0)\n\t\terror = pthread_attr_setinheritsched(attr, inheritsched);\n\tif (error)\n\t\tgoto error;\n\n\tstruct sched_param param;\n\terror = pthread_attr_getschedparam(old_attr, &param);\n\tif (error == 0)\n\t\terror = pthread_attr_setschedparam(attr, &param);\n\tif (error)\n\t\tgoto error;\n\n\tint policy;\n\terror = pthread_attr_getschedpolicy(old_attr, &policy);\n\tif (error == 0)\n\t\terror = pthread_attr_setschedpolicy(attr, policy);\n\tif (error)\n\t\tgoto error;\n\n\tint scope;\n\terror = pthread_attr_getscope(old_attr, &scope);\n\tif (error == 0)\n\t\terror = pthread_attr_setscope(attr, scope);\n\tif (error)\n\t\tgoto error;\n\n\tvoid *stackaddr;\n\tsize_t stacksize;\n\terror = pthread_attr_getstack(old_attr, &stackaddr, &stacksize);\n\tif (error == 0)\n\t\terror = pthread_attr_setstack(attr, stackaddr, stacksize);\n\tif (error)\n\t\tgoto error;\n\n\treturn (0);\nerror:\n\tpthread_attr_destroy(attr);\n\treturn (error);\n}\n\ntpool_t\t*\ntpool_create(uint_t min_threads, uint_t max_threads, uint_t linger,\n    pthread_attr_t *attr)\n{\n\ttpool_t\t*tpool;\n\tvoid *stackaddr;\n\tsize_t stacksize;\n\tsize_t minstack;\n\tint error;\n\n\tif (min_threads > max_threads || max_threads < 1) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\tif (attr != NULL) {\n\t\tif (pthread_attr_getstack(attr, &stackaddr, &stacksize) != 0) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t\t \n\t\tminstack = PTHREAD_STACK_MIN;\n\t\tif (stackaddr != NULL) {\n\t\t\tif (stacksize < minstack || max_threads != 1) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t} else if (stacksize != 0 && stacksize < minstack) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\ttpool = calloc(1, sizeof (*tpool));\n\tif (tpool == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn (NULL);\n\t}\n\t(void) pthread_mutex_init(&tpool->tp_mutex, NULL);\n\t(void) pthread_cond_init(&tpool->tp_busycv, NULL);\n\t(void) pthread_cond_init(&tpool->tp_workcv, NULL);\n\t(void) pthread_cond_init(&tpool->tp_waitcv, NULL);\n\ttpool->tp_minimum = min_threads;\n\ttpool->tp_maximum = max_threads;\n\ttpool->tp_linger = linger;\n\n\t \n\terror = pthread_attr_clone(&tpool->tp_attr, attr);\n\tif (error) {\n\t\tfree(tpool);\n\t\terrno = error;\n\t\treturn (NULL);\n\t}\n\n\t \n\t(void) pthread_attr_setdetachstate(&tpool->tp_attr,\n\t    PTHREAD_CREATE_DETACHED);\n\n\t \n\tpthread_mutex_lock(&thread_pool_lock);\n\tif (thread_pools == NULL) {\n\t\ttpool->tp_forw = tpool;\n\t\ttpool->tp_back = tpool;\n\t\tthread_pools = tpool;\n\t} else {\n\t\tthread_pools->tp_back->tp_forw = tpool;\n\t\ttpool->tp_forw = thread_pools;\n\t\ttpool->tp_back = thread_pools->tp_back;\n\t\tthread_pools->tp_back = tpool;\n\t}\n\tpthread_mutex_unlock(&thread_pool_lock);\n\n\treturn (tpool);\n}\n\n \nint\ntpool_dispatch(tpool_t *tpool, void (*func)(void *), void *arg)\n{\n\ttpool_job_t *job;\n\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tif ((job = calloc(1, sizeof (*job))) == NULL)\n\t\treturn (-1);\n\tjob->tpj_next = NULL;\n\tjob->tpj_func = func;\n\tjob->tpj_arg = arg;\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\n\tif (tpool->tp_head == NULL)\n\t\ttpool->tp_head = job;\n\telse\n\t\ttpool->tp_tail->tpj_next = job;\n\ttpool->tp_tail = job;\n\ttpool->tp_njobs++;\n\n\tif (!(tpool->tp_flags & TP_SUSPEND)) {\n\t\tif (tpool->tp_idle > 0)\n\t\t\t(void) pthread_cond_signal(&tpool->tp_workcv);\n\t\telse if (tpool->tp_current < tpool->tp_maximum &&\n\t\t    create_worker(tpool) == 0)\n\t\t\ttpool->tp_current++;\n\t}\n\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n\treturn (0);\n}\n\nstatic void\ntpool_cleanup(void *arg)\n{\n\ttpool_t *tpool = (tpool_t *)arg;\n\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n}\n\n \nvoid\ntpool_destroy(tpool_t *tpool)\n{\n\ttpool_active_t *activep;\n\n\tASSERT(!tpool_member(tpool));\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tpthread_cleanup_push(tpool_cleanup, tpool);\n\n\t \n\ttpool->tp_flags |= TP_DESTROY;\n\ttpool->tp_flags &= ~TP_SUSPEND;\n\t(void) pthread_cond_broadcast(&tpool->tp_workcv);\n\n\t \n\tfor (activep = tpool->tp_active; activep; activep = activep->tpa_next)\n\t\t(void) pthread_cancel(activep->tpa_tid);\n\n\t \n\twhile (tpool->tp_active != NULL) {\n\t\ttpool->tp_flags |= TP_WAIT;\n\t\t(void) pthread_cond_wait(&tpool->tp_waitcv, &tpool->tp_mutex);\n\t}\n\n\t \n\twhile (tpool->tp_current != 0)\n\t\t(void) pthread_cond_wait(&tpool->tp_busycv, &tpool->tp_mutex);\n\n\tpthread_cleanup_pop(1);\t \n\tdelete_pool(tpool);\n}\n\n \nvoid\ntpool_abandon(tpool_t *tpool)\n{\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tif (tpool->tp_current == 0) {\n\t\t \n\t\tpthread_mutex_unlock(&tpool->tp_mutex);\n\t\tdelete_pool(tpool);\n\t} else {\n\t\t \n\t\ttpool->tp_flags |= TP_ABANDON;\n\t\ttpool->tp_flags &= ~TP_SUSPEND;\n\t\t(void) pthread_cond_broadcast(&tpool->tp_workcv);\n\t\tpthread_mutex_unlock(&tpool->tp_mutex);\n\t}\n}\n\n \nvoid\ntpool_wait(tpool_t *tpool)\n{\n\tASSERT(!tpool_member(tpool));\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tpthread_cleanup_push(tpool_cleanup, tpool);\n\twhile (tpool->tp_head != NULL || tpool->tp_active != NULL) {\n\t\ttpool->tp_flags |= TP_WAIT;\n\t\t(void) pthread_cond_wait(&tpool->tp_waitcv, &tpool->tp_mutex);\n\t\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\t}\n\tpthread_cleanup_pop(1);\t \n}\n\nvoid\ntpool_suspend(tpool_t *tpool)\n{\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\ttpool->tp_flags |= TP_SUSPEND;\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n}\n\nint\ntpool_suspended(tpool_t *tpool)\n{\n\tint suspended;\n\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tsuspended = (tpool->tp_flags & TP_SUSPEND) != 0;\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n\n\treturn (suspended);\n}\n\nvoid\ntpool_resume(tpool_t *tpool)\n{\n\tint excess;\n\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tif (!(tpool->tp_flags & TP_SUSPEND)) {\n\t\tpthread_mutex_unlock(&tpool->tp_mutex);\n\t\treturn;\n\t}\n\ttpool->tp_flags &= ~TP_SUSPEND;\n\t(void) pthread_cond_broadcast(&tpool->tp_workcv);\n\texcess = tpool->tp_njobs - tpool->tp_idle;\n\twhile (excess-- > 0 && tpool->tp_current < tpool->tp_maximum) {\n\t\tif (create_worker(tpool) != 0)\n\t\t\tbreak;\t\t \n\t\ttpool->tp_current++;\n\t}\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n}\n\nint\ntpool_member(tpool_t *tpool)\n{\n\tpthread_t my_tid = pthread_self();\n\ttpool_active_t *activep;\n\n\tASSERT(!(tpool->tp_flags & (TP_DESTROY | TP_ABANDON)));\n\n\tpthread_mutex_lock(&tpool->tp_mutex);\n\tfor (activep = tpool->tp_active; activep; activep = activep->tpa_next) {\n\t\tif (activep->tpa_tid == my_tid) {\n\t\t\tpthread_mutex_unlock(&tpool->tp_mutex);\n\t\t\treturn (1);\n\t\t}\n\t}\n\tpthread_mutex_unlock(&tpool->tp_mutex);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}