{
  "module_name": "util.c",
  "hash_id": "026f86efebb28f8ca65a460e31d695361117341446838d000cc0c76ffacb9719",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzpool/util.c",
  "human_readable_source": " \n \n\n#include <assert.h>\n#include <sys/zfs_context.h>\n#include <sys/avl.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/spa.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_refcount.h>\n#include <sys/zfs_ioctl.h>\n#include <dlfcn.h>\n#include <libzutil.h>\n\n \n\nstatic void\nshow_vdev_stats(const char *desc, const char *ctype, nvlist_t *nv, int indent)\n{\n\tvdev_stat_t *vs;\n\tvdev_stat_t *v0 = { 0 };\n\tuint64_t sec;\n\tuint64_t is_log = 0;\n\tnvlist_t **child;\n\tuint_t c, children;\n\tchar used[6], avail[6];\n\tchar rops[6], wops[6], rbytes[6], wbytes[6], rerr[6], werr[6], cerr[6];\n\n\tv0 = umem_zalloc(sizeof (*v0), UMEM_NOFAIL);\n\n\tif (indent == 0 && desc != NULL) {\n\t\t(void) printf(\"                           \"\n\t\t    \" capacity   operations   bandwidth  ---- errors ----\\n\");\n\t\t(void) printf(\"description                \"\n\t\t    \"used avail  read write  read write  read write cksum\\n\");\n\t}\n\n\tif (desc != NULL) {\n\t\tconst char *suffix = \"\";\n\t\tconst char *bias = NULL;\n\t\tchar bias_suffix[32];\n\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_IS_LOG, &is_log);\n\t\t(void) nvlist_lookup_string(nv, ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t    &bias);\n\t\tif (nvlist_lookup_uint64_array(nv, ZPOOL_CONFIG_VDEV_STATS,\n\t\t    (uint64_t **)&vs, &c) != 0)\n\t\t\tvs = v0;\n\n\t\tif (bias != NULL) {\n\t\t\t(void) snprintf(bias_suffix, sizeof (bias_suffix),\n\t\t\t    \" (%s)\", bias);\n\t\t\tsuffix = bias_suffix;\n\t\t} else if (is_log) {\n\t\t\tsuffix = \" (log)\";\n\t\t}\n\n\t\tsec = MAX(1, vs->vs_timestamp / NANOSEC);\n\n\t\tnicenum(vs->vs_alloc, used, sizeof (used));\n\t\tnicenum(vs->vs_space - vs->vs_alloc, avail, sizeof (avail));\n\t\tnicenum(vs->vs_ops[ZIO_TYPE_READ] / sec, rops, sizeof (rops));\n\t\tnicenum(vs->vs_ops[ZIO_TYPE_WRITE] / sec, wops, sizeof (wops));\n\t\tnicenum(vs->vs_bytes[ZIO_TYPE_READ] / sec, rbytes,\n\t\t    sizeof (rbytes));\n\t\tnicenum(vs->vs_bytes[ZIO_TYPE_WRITE] / sec, wbytes,\n\t\t    sizeof (wbytes));\n\t\tnicenum(vs->vs_read_errors, rerr, sizeof (rerr));\n\t\tnicenum(vs->vs_write_errors, werr, sizeof (werr));\n\t\tnicenum(vs->vs_checksum_errors, cerr, sizeof (cerr));\n\n\t\t(void) printf(\"%*s%s%*s%*s%*s %5s %5s %5s %5s %5s %5s %5s\\n\",\n\t\t    indent, \"\",\n\t\t    desc,\n\t\t    (int)(indent+strlen(desc)-25-(vs->vs_space ? 0 : 12)),\n\t\t    suffix,\n\t\t    vs->vs_space ? 6 : 0, vs->vs_space ? used : \"\",\n\t\t    vs->vs_space ? 6 : 0, vs->vs_space ? avail : \"\",\n\t\t    rops, wops, rbytes, wbytes, rerr, werr, cerr);\n\t}\n\tumem_free(v0, sizeof (*v0));\n\n\tif (nvlist_lookup_nvlist_array(nv, ctype, &child, &children) != 0)\n\t\treturn;\n\n\tfor (c = 0; c < children; c++) {\n\t\tnvlist_t *cnv = child[c];\n\t\tconst char *cname = NULL;\n\t\tchar *tname;\n\t\tuint64_t np;\n\t\tint len;\n\t\tif (nvlist_lookup_string(cnv, ZPOOL_CONFIG_PATH, &cname) &&\n\t\t    nvlist_lookup_string(cnv, ZPOOL_CONFIG_TYPE, &cname))\n\t\t\tcname = \"<unknown>\";\n\t\tlen = strlen(cname) + 2;\n\t\ttname = umem_zalloc(len, UMEM_NOFAIL);\n\t\t(void) strlcpy(tname, cname, len);\n\t\tif (nvlist_lookup_uint64(cnv, ZPOOL_CONFIG_NPARITY, &np) == 0)\n\t\t\ttname[strlen(tname)] = '0' + np;\n\t\tshow_vdev_stats(tname, ctype, cnv, indent + 2);\n\t\tumem_free(tname, len);\n\t}\n}\n\nvoid\nshow_pool_stats(spa_t *spa)\n{\n\tnvlist_t *config, *nvroot;\n\tconst char *name;\n\n\tVERIFY(spa_get_stats(spa_name(spa), &config, NULL, 0) == 0);\n\n\tVERIFY(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\tVERIFY(nvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME,\n\t    &name) == 0);\n\n\tshow_vdev_stats(name, ZPOOL_CONFIG_CHILDREN, nvroot, 0);\n\tshow_vdev_stats(NULL, ZPOOL_CONFIG_L2CACHE, nvroot, 0);\n\tshow_vdev_stats(NULL, ZPOOL_CONFIG_SPARES, nvroot, 0);\n\n\tnvlist_free(config);\n}\n\n \nstatic int\nset_global_var_parse_kv(const char *arg, char **k_out, u_longlong_t *v_out)\n{\n\tint err;\n\tVERIFY(arg);\n\tchar *d = strdup(arg);\n\n\tchar *save = NULL;\n\tchar *k = strtok_r(d, \"=\", &save);\n\tchar *v_str = strtok_r(NULL, \"=\", &save);\n\tchar *follow = strtok_r(NULL, \"=\", &save);\n\tif (k == NULL || v_str == NULL || follow != NULL) {\n\t\terr = EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tu_longlong_t val = strtoull(v_str, NULL, 0);\n\tif (val > UINT32_MAX) {\n\t\tfprintf(stderr, \"Value for global variable '%s' must \"\n\t\t    \"be a 32-bit unsigned integer, got '%s'\\n\", k, v_str);\n\t\terr = EOVERFLOW;\n\t\tgoto err_free;\n\t}\n\n\t*k_out = strdup(k);\n\t*v_out = val;\n\tfree(d);\n\treturn (0);\n\nerr_free:\n\tfree(d);\n\n\treturn (err);\n}\n\n \nint\nset_global_var(char const *arg)\n{\n\tvoid *zpoolhdl;\n\tchar *varname;\n\tu_longlong_t val;\n\tint ret;\n\n#ifndef _ZFS_LITTLE_ENDIAN\n\t \n\tfprintf(stderr, \"Setting global variables is only supported on \"\n\t    \"little-endian systems\\n\");\n\tret = ENOTSUP;\n\tgoto out_ret;\n#endif\n\n\tif ((ret = set_global_var_parse_kv(arg, &varname, &val)) != 0) {\n\t\tgoto out_ret;\n\t}\n\n\tzpoolhdl = dlopen(\"libzpool.so\", RTLD_LAZY);\n\tif (zpoolhdl != NULL) {\n\t\tuint32_t *var;\n\t\tvar = dlsym(zpoolhdl, varname);\n\t\tif (var == NULL) {\n\t\t\tfprintf(stderr, \"Global variable '%s' does not exist \"\n\t\t\t    \"in libzpool.so\\n\", varname);\n\t\t\tret = EINVAL;\n\t\t\tgoto out_dlclose;\n\t\t}\n\t\t*var = (uint32_t)val;\n\n\t} else {\n\t\tfprintf(stderr, \"Failed to open libzpool.so to set global \"\n\t\t    \"variable\\n\");\n\t\tret = EIO;\n\t\tgoto out_free;\n\t}\n\n\tret = 0;\n\nout_dlclose:\n\tdlclose(zpoolhdl);\nout_free:\n\tfree(varname);\nout_ret:\n\treturn (ret);\n}\n\nstatic nvlist_t *\nrefresh_config(void *unused, nvlist_t *tryconfig)\n{\n\t(void) unused;\n\treturn (spa_tryimport(tryconfig));\n}\n\n#if defined(__FreeBSD__)\n\n#include <sys/param.h>\n#include <sys/sysctl.h>\n#include <os/freebsd/zfs/sys/zfs_ioctl_compat.h>\n\nstatic int\npool_active(void *unused, const char *name, uint64_t guid, boolean_t *isactive)\n{\n\t(void) unused, (void) guid;\n\tzfs_iocparm_t zp;\n\tzfs_cmd_t *zc = NULL;\n#ifdef ZFS_LEGACY_SUPPORT\n\tzfs_cmd_legacy_t *zcl = NULL;\n#endif\n\tunsigned long request;\n\tint ret;\n\n\tint fd = open(ZFS_DEV, O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn (-1);\n\n\t \n\tint ver = ZFS_IOCVER_NONE;\n\tsize_t ver_size = sizeof (ver);\n\n\tsysctlbyname(\"vfs.zfs.version.ioctl\", &ver, &ver_size, NULL, 0);\n\n\tswitch (ver) {\n\tcase ZFS_IOCVER_OZFS:\n\t\tzc = umem_zalloc(sizeof (zfs_cmd_t), UMEM_NOFAIL);\n\n\t\t(void) strlcpy(zc->zc_name, name, sizeof (zc->zc_name));\n\t\tzp.zfs_cmd = (uint64_t)(uintptr_t)zc;\n\t\tzp.zfs_cmd_size = sizeof (zfs_cmd_t);\n\t\tzp.zfs_ioctl_version = ZFS_IOCVER_OZFS;\n\n\t\trequest = _IOWR('Z', ZFS_IOC_POOL_STATS, zfs_iocparm_t);\n\t\tret = ioctl(fd, request, &zp);\n\n\t\tfree((void *)(uintptr_t)zc->zc_nvlist_dst);\n\t\tumem_free(zc, sizeof (zfs_cmd_t));\n\n\t\tbreak;\n#ifdef ZFS_LEGACY_SUPPORT\n\tcase ZFS_IOCVER_LEGACY:\n\t\tzcl = umem_zalloc(sizeof (zfs_cmd_legacy_t), UMEM_NOFAIL);\n\n\t\t(void) strlcpy(zcl->zc_name, name, sizeof (zcl->zc_name));\n\t\tzp.zfs_cmd = (uint64_t)(uintptr_t)zcl;\n\t\tzp.zfs_cmd_size = sizeof (zfs_cmd_legacy_t);\n\t\tzp.zfs_ioctl_version = ZFS_IOCVER_LEGACY;\n\n\t\trequest = _IOWR('Z', ZFS_IOC_POOL_STATS, zfs_iocparm_t);\n\t\tret = ioctl(fd, request, &zp);\n\n\t\tfree((void *)(uintptr_t)zcl->zc_nvlist_dst);\n\t\tumem_free(zcl, sizeof (zfs_cmd_legacy_t));\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfprintf(stderr, \"unrecognized zfs ioctl version %d\", ver);\n\t\texit(1);\n\t}\n\n\t(void) close(fd);\n\n\t*isactive = (ret == 0);\n\n\treturn (0);\n}\n#else\nstatic int\npool_active(void *unused, const char *name, uint64_t guid,\n    boolean_t *isactive)\n{\n\t(void) unused, (void) guid;\n\tint fd = open(ZFS_DEV, O_RDWR | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn (-1);\n\n\t \n\tzfs_cmd_t *zcp = umem_zalloc(sizeof (zfs_cmd_t), UMEM_NOFAIL);\n\t(void) strlcpy(zcp->zc_name, name, sizeof (zcp->zc_name));\n\n\tint ret = ioctl(fd, ZFS_IOC_POOL_STATS, zcp);\n\n\tfree((void *)(uintptr_t)zcp->zc_nvlist_dst);\n\tumem_free(zcp, sizeof (zfs_cmd_t));\n\n\t(void) close(fd);\n\n\t*isactive = (ret == 0);\n\n\treturn (0);\n}\n#endif\n\npool_config_ops_t libzpool_config_ops = {\n\t.pco_refresh_config = refresh_config,\n\t.pco_pool_active = pool_active,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}