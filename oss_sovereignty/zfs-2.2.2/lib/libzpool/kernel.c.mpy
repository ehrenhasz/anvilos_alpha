{
  "module_name": "kernel.c",
  "hash_id": "4f3f9fcbbef634d7c56d907637a6971b06e5f42588f968cbca63fb4e20280f15",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzpool/kernel.c",
  "human_readable_source": " \n \n\n#include <assert.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <poll.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <libzutil.h>\n#include <sys/crypto/icp.h>\n#include <sys/processor.h>\n#include <sys/rrwlock.h>\n#include <sys/spa.h>\n#include <sys/stat.h>\n#include <sys/systeminfo.h>\n#include <sys/time.h>\n#include <sys/utsname.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_onexit.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zstd/zstd.h>\n#include <sys/zvol.h>\n#include <zfs_fletcher.h>\n#include <zlib.h>\n\n \n\nuint64_t physmem;\nuint32_t hostid;\nstruct utsname hw_utsname;\n\n \nchar *vn_dumpdir = NULL;\n\n \nstruct proc p0;\n\n \n#define\tTS_STACK_MIN\tMAX(PTHREAD_STACK_MIN, 32768)\n#define\tTS_STACK_MAX\t(256 * 1024)\n\nstruct zk_thread_wrapper {\n\tvoid (*func)(void *);\n\tvoid *arg;\n};\n\nstatic void *\nzk_thread_wrapper(void *arg)\n{\n\tstruct zk_thread_wrapper ztw;\n\tmemcpy(&ztw, arg, sizeof (ztw));\n\tfree(arg);\n\tztw.func(ztw.arg);\n\treturn (NULL);\n}\n\nkthread_t *\nzk_thread_create(void (*func)(void *), void *arg, size_t stksize, int state)\n{\n\tpthread_attr_t attr;\n\tpthread_t tid;\n\tchar *stkstr;\n\tstruct zk_thread_wrapper *ztw;\n\tint detachstate = PTHREAD_CREATE_DETACHED;\n\n\tVERIFY0(pthread_attr_init(&attr));\n\n\tif (state & TS_JOINABLE)\n\t\tdetachstate = PTHREAD_CREATE_JOINABLE;\n\n\tVERIFY0(pthread_attr_setdetachstate(&attr, detachstate));\n\n\t \n\tif (stksize == 0) {\n\t\tstkstr = getenv(\"ZFS_STACK_SIZE\");\n\n\t\tif (stkstr == NULL)\n\t\t\tstksize = TS_STACK_MAX;\n\t\telse\n\t\t\tstksize = MAX(atoi(stkstr), TS_STACK_MIN);\n\t}\n\n\tVERIFY3S(stksize, >, 0);\n\tstksize = P2ROUNDUP(MAX(stksize, TS_STACK_MIN), PAGESIZE);\n\n\t \n\tVERIFY0(pthread_attr_setstacksize(&attr, stksize));\n\tVERIFY0(pthread_attr_setguardsize(&attr, PAGESIZE));\n\n\tVERIFY(ztw = malloc(sizeof (*ztw)));\n\tztw->func = func;\n\tztw->arg = arg;\n\tVERIFY0(pthread_create(&tid, &attr, zk_thread_wrapper, ztw));\n\tVERIFY0(pthread_attr_destroy(&attr));\n\n\treturn ((void *)(uintptr_t)tid);\n}\n\n \nkstat_t *\nkstat_create(const char *module, int instance, const char *name,\n    const char *class, uchar_t type, ulong_t ndata, uchar_t ks_flag)\n{\n\t(void) module, (void) instance, (void) name, (void) class, (void) type,\n\t    (void) ndata, (void) ks_flag;\n\treturn (NULL);\n}\n\nvoid\nkstat_install(kstat_t *ksp)\n{\n\t(void) ksp;\n}\n\nvoid\nkstat_delete(kstat_t *ksp)\n{\n\t(void) ksp;\n}\n\nvoid\nkstat_set_raw_ops(kstat_t *ksp,\n    int (*headers)(char *buf, size_t size),\n    int (*data)(char *buf, size_t size, void *data),\n    void *(*addr)(kstat_t *ksp, loff_t index))\n{\n\t(void) ksp, (void) headers, (void) data, (void) addr;\n}\n\n \n\nvoid\nmutex_init(kmutex_t *mp, char *name, int type, void *cookie)\n{\n\t(void) name, (void) type, (void) cookie;\n\tVERIFY0(pthread_mutex_init(&mp->m_lock, NULL));\n\tmemset(&mp->m_owner, 0, sizeof (pthread_t));\n}\n\nvoid\nmutex_destroy(kmutex_t *mp)\n{\n\tVERIFY0(pthread_mutex_destroy(&mp->m_lock));\n}\n\nvoid\nmutex_enter(kmutex_t *mp)\n{\n\tVERIFY0(pthread_mutex_lock(&mp->m_lock));\n\tmp->m_owner = pthread_self();\n}\n\nint\nmutex_enter_check_return(kmutex_t *mp)\n{\n\tint error = pthread_mutex_lock(&mp->m_lock);\n\tif (error == 0)\n\t\tmp->m_owner = pthread_self();\n\treturn (error);\n}\n\nint\nmutex_tryenter(kmutex_t *mp)\n{\n\tint error = pthread_mutex_trylock(&mp->m_lock);\n\tif (error == 0) {\n\t\tmp->m_owner = pthread_self();\n\t\treturn (1);\n\t} else {\n\t\tVERIFY3S(error, ==, EBUSY);\n\t\treturn (0);\n\t}\n}\n\nvoid\nmutex_exit(kmutex_t *mp)\n{\n\tmemset(&mp->m_owner, 0, sizeof (pthread_t));\n\tVERIFY0(pthread_mutex_unlock(&mp->m_lock));\n}\n\n \n\nvoid\nrw_init(krwlock_t *rwlp, char *name, int type, void *arg)\n{\n\t(void) name, (void) type, (void) arg;\n\tVERIFY0(pthread_rwlock_init(&rwlp->rw_lock, NULL));\n\trwlp->rw_readers = 0;\n\trwlp->rw_owner = 0;\n}\n\nvoid\nrw_destroy(krwlock_t *rwlp)\n{\n\tVERIFY0(pthread_rwlock_destroy(&rwlp->rw_lock));\n}\n\nvoid\nrw_enter(krwlock_t *rwlp, krw_t rw)\n{\n\tif (rw == RW_READER) {\n\t\tVERIFY0(pthread_rwlock_rdlock(&rwlp->rw_lock));\n\t\tatomic_inc_uint(&rwlp->rw_readers);\n\t} else {\n\t\tVERIFY0(pthread_rwlock_wrlock(&rwlp->rw_lock));\n\t\trwlp->rw_owner = pthread_self();\n\t}\n}\n\nvoid\nrw_exit(krwlock_t *rwlp)\n{\n\tif (RW_READ_HELD(rwlp))\n\t\tatomic_dec_uint(&rwlp->rw_readers);\n\telse\n\t\trwlp->rw_owner = 0;\n\n\tVERIFY0(pthread_rwlock_unlock(&rwlp->rw_lock));\n}\n\nint\nrw_tryenter(krwlock_t *rwlp, krw_t rw)\n{\n\tint error;\n\n\tif (rw == RW_READER)\n\t\terror = pthread_rwlock_tryrdlock(&rwlp->rw_lock);\n\telse\n\t\terror = pthread_rwlock_trywrlock(&rwlp->rw_lock);\n\n\tif (error == 0) {\n\t\tif (rw == RW_READER)\n\t\t\tatomic_inc_uint(&rwlp->rw_readers);\n\t\telse\n\t\t\trwlp->rw_owner = pthread_self();\n\n\t\treturn (1);\n\t}\n\n\tVERIFY3S(error, ==, EBUSY);\n\n\treturn (0);\n}\n\nuint32_t\nzone_get_hostid(void *zonep)\n{\n\t \n\t(void) zonep;\n\treturn (hostid);\n}\n\nint\nrw_tryupgrade(krwlock_t *rwlp)\n{\n\t(void) rwlp;\n\treturn (0);\n}\n\n \n\nvoid\ncv_init(kcondvar_t *cv, char *name, int type, void *arg)\n{\n\t(void) name, (void) type, (void) arg;\n\tVERIFY0(pthread_cond_init(cv, NULL));\n}\n\nvoid\ncv_destroy(kcondvar_t *cv)\n{\n\tVERIFY0(pthread_cond_destroy(cv));\n}\n\nvoid\ncv_wait(kcondvar_t *cv, kmutex_t *mp)\n{\n\tmemset(&mp->m_owner, 0, sizeof (pthread_t));\n\tVERIFY0(pthread_cond_wait(cv, &mp->m_lock));\n\tmp->m_owner = pthread_self();\n}\n\nint\ncv_wait_sig(kcondvar_t *cv, kmutex_t *mp)\n{\n\tcv_wait(cv, mp);\n\treturn (1);\n}\n\nint\ncv_timedwait(kcondvar_t *cv, kmutex_t *mp, clock_t abstime)\n{\n\tint error;\n\tstruct timeval tv;\n\tstruct timespec ts;\n\tclock_t delta;\n\n\tdelta = abstime - ddi_get_lbolt();\n\tif (delta <= 0)\n\t\treturn (-1);\n\n\tVERIFY(gettimeofday(&tv, NULL) == 0);\n\n\tts.tv_sec = tv.tv_sec + delta / hz;\n\tts.tv_nsec = tv.tv_usec * NSEC_PER_USEC + (delta % hz) * (NANOSEC / hz);\n\tif (ts.tv_nsec >= NANOSEC) {\n\t\tts.tv_sec++;\n\t\tts.tv_nsec -= NANOSEC;\n\t}\n\n\tmemset(&mp->m_owner, 0, sizeof (pthread_t));\n\terror = pthread_cond_timedwait(cv, &mp->m_lock, &ts);\n\tmp->m_owner = pthread_self();\n\n\tif (error == ETIMEDOUT)\n\t\treturn (-1);\n\n\tVERIFY0(error);\n\n\treturn (1);\n}\n\nint\ncv_timedwait_hires(kcondvar_t *cv, kmutex_t *mp, hrtime_t tim, hrtime_t res,\n    int flag)\n{\n\t(void) res;\n\tint error;\n\tstruct timeval tv;\n\tstruct timespec ts;\n\thrtime_t delta;\n\n\tASSERT(flag == 0 || flag == CALLOUT_FLAG_ABSOLUTE);\n\n\tdelta = tim;\n\tif (flag & CALLOUT_FLAG_ABSOLUTE)\n\t\tdelta -= gethrtime();\n\n\tif (delta <= 0)\n\t\treturn (-1);\n\n\tVERIFY0(gettimeofday(&tv, NULL));\n\n\tts.tv_sec = tv.tv_sec + delta / NANOSEC;\n\tts.tv_nsec = tv.tv_usec * NSEC_PER_USEC + (delta % NANOSEC);\n\tif (ts.tv_nsec >= NANOSEC) {\n\t\tts.tv_sec++;\n\t\tts.tv_nsec -= NANOSEC;\n\t}\n\n\tmemset(&mp->m_owner, 0, sizeof (pthread_t));\n\terror = pthread_cond_timedwait(cv, &mp->m_lock, &ts);\n\tmp->m_owner = pthread_self();\n\n\tif (error == ETIMEDOUT)\n\t\treturn (-1);\n\n\tVERIFY0(error);\n\n\treturn (1);\n}\n\nvoid\ncv_signal(kcondvar_t *cv)\n{\n\tVERIFY0(pthread_cond_signal(cv));\n}\n\nvoid\ncv_broadcast(kcondvar_t *cv)\n{\n\tVERIFY0(pthread_cond_broadcast(cv));\n}\n\n \n\nvoid\nseq_printf(struct seq_file *m, const char *fmt, ...)\n{\n\t(void) m, (void) fmt;\n}\n\nvoid\nprocfs_list_install(const char *module,\n    const char *submodule,\n    const char *name,\n    mode_t mode,\n    procfs_list_t *procfs_list,\n    int (*show)(struct seq_file *f, void *p),\n    int (*show_header)(struct seq_file *f),\n    int (*clear)(procfs_list_t *procfs_list),\n    size_t procfs_list_node_off)\n{\n\t(void) module, (void) submodule, (void) name, (void) mode, (void) show,\n\t    (void) show_header, (void) clear;\n\tmutex_init(&procfs_list->pl_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&procfs_list->pl_list,\n\t    procfs_list_node_off + sizeof (procfs_list_node_t),\n\t    procfs_list_node_off + offsetof(procfs_list_node_t, pln_link));\n\tprocfs_list->pl_next_id = 1;\n\tprocfs_list->pl_node_offset = procfs_list_node_off;\n}\n\nvoid\nprocfs_list_uninstall(procfs_list_t *procfs_list)\n{\n\t(void) procfs_list;\n}\n\nvoid\nprocfs_list_destroy(procfs_list_t *procfs_list)\n{\n\tASSERT(list_is_empty(&procfs_list->pl_list));\n\tlist_destroy(&procfs_list->pl_list);\n\tmutex_destroy(&procfs_list->pl_lock);\n}\n\n#define\tNODE_ID(procfs_list, obj) \\\n\t\t(((procfs_list_node_t *)(((char *)obj) + \\\n\t\t(procfs_list)->pl_node_offset))->pln_id)\n\nvoid\nprocfs_list_add(procfs_list_t *procfs_list, void *p)\n{\n\tASSERT(MUTEX_HELD(&procfs_list->pl_lock));\n\tNODE_ID(procfs_list, p) = procfs_list->pl_next_id++;\n\tlist_insert_tail(&procfs_list->pl_list, p);\n}\n\n \n\n \n\nstatic char *dprintf_string;\nstatic int dprintf_print_all;\n\nint\ndprintf_find_string(const char *string)\n{\n\tchar *tmp_str = dprintf_string;\n\tint len = strlen(string);\n\n\t \n\n\twhile (tmp_str != NULL) {\n\t\tif (strncmp(tmp_str, string, len) == 0 &&\n\t\t    (tmp_str[len] == ',' || tmp_str[len] == '\\0'))\n\t\t\treturn (1);\n\t\ttmp_str = strchr(tmp_str, ',');\n\t\tif (tmp_str != NULL)\n\t\t\ttmp_str++;  \n\t}\n\treturn (0);\n}\n\nvoid\ndprintf_setup(int *argc, char **argv)\n{\n\tint i, j;\n\n\t \n\n\tfor (i = 1; i < *argc; i++) {\n\t\tint len = strlen(\"debug=\");\n\t\t \n\t\tif (strncmp(\"debug=\", argv[i], len) == 0) {\n\t\t\tdprintf_string = argv[i] + len;\n\t\t\t \n\t\t\tfor (j = i; j < *argc; j++)\n\t\t\t\targv[j] = argv[j+1];\n\t\t\targv[j] = NULL;\n\t\t\t(*argc)--;\n\t\t}\n\t}\n\n\tif (dprintf_string == NULL) {\n\t\t \n\t\tdprintf_string = getenv(\"ZFS_DEBUG\");\n\t}\n\n\t \n\tif (dprintf_find_string(\"on\"))\n\t\tdprintf_print_all = 1;\n\n\tif (dprintf_string != NULL)\n\t\tzfs_flags |= ZFS_DEBUG_DPRINTF;\n}\n\n \nvoid\n__dprintf(boolean_t dprint, const char *file, const char *func,\n    int line, const char *fmt, ...)\n{\n\t \n\tconst char *newfile = zfs_basename(file);\n\n\tva_list adx;\n\tif (dprint) {\n\t\t \n\n\t\tif (!dprintf_print_all &&\n\t\t    !dprintf_find_string(newfile) &&\n\t\t    !dprintf_find_string(func))\n\t\t\treturn;\n\n\t\t \n\t\tflockfile(stdout);\n\t\tif (dprintf_find_string(\"pid\"))\n\t\t\t(void) printf(\"%d \", getpid());\n\t\tif (dprintf_find_string(\"tid\"))\n\t\t\t(void) printf(\"%ju \",\n\t\t\t    (uintmax_t)(uintptr_t)pthread_self());\n\t\tif (dprintf_find_string(\"cpu\"))\n\t\t\t(void) printf(\"%u \", getcpuid());\n\t\tif (dprintf_find_string(\"time\"))\n\t\t\t(void) printf(\"%llu \", gethrtime());\n\t\tif (dprintf_find_string(\"long\"))\n\t\t\t(void) printf(\"%s, line %d: \", newfile, line);\n\t\t(void) printf(\"dprintf: %s: \", func);\n\t\tva_start(adx, fmt);\n\t\t(void) vprintf(fmt, adx);\n\t\tva_end(adx);\n\t\tfunlockfile(stdout);\n\t} else {\n\t\t \n\t\tsize_t size;\n\t\tchar *buf;\n\t\tint i;\n\n\t\tsize = 1024;\n\t\tbuf = umem_alloc(size, UMEM_NOFAIL);\n\t\ti = snprintf(buf, size, \"%s:%d:%s(): \", newfile, line, func);\n\n\t\tif (i < size) {\n\t\t\tva_start(adx, fmt);\n\t\t\t(void) vsnprintf(buf + i, size - i, fmt, adx);\n\t\t\tva_end(adx);\n\t\t}\n\n\t\t__zfs_dbgmsg(buf);\n\n\t\tumem_free(buf, size);\n\t}\n}\n\n \nstatic char ce_prefix[CE_IGNORE][10] = { \"\", \"NOTICE: \", \"WARNING: \", \"\" };\nstatic char ce_suffix[CE_IGNORE][2] = { \"\", \"\\n\", \"\\n\", \"\" };\n\n__attribute__((noreturn)) void\nvpanic(const char *fmt, va_list adx)\n{\n\t(void) fprintf(stderr, \"error: \");\n\t(void) vfprintf(stderr, fmt, adx);\n\t(void) fprintf(stderr, \"\\n\");\n\n\tabort();\t \n}\n\n__attribute__((noreturn)) void\npanic(const char *fmt, ...)\n{\n\tva_list adx;\n\n\tva_start(adx, fmt);\n\tvpanic(fmt, adx);\n\tva_end(adx);\n}\n\nvoid\nvcmn_err(int ce, const char *fmt, va_list adx)\n{\n\tif (ce == CE_PANIC)\n\t\tvpanic(fmt, adx);\n\tif (ce != CE_NOTE) {\t \n\t\t(void) fprintf(stderr, \"%s\", ce_prefix[ce]);\n\t\t(void) vfprintf(stderr, fmt, adx);\n\t\t(void) fprintf(stderr, \"%s\", ce_suffix[ce]);\n\t}\n}\n\nvoid\ncmn_err(int ce, const char *fmt, ...)\n{\n\tva_list adx;\n\n\tva_start(adx, fmt);\n\tvcmn_err(ce, fmt, adx);\n\tva_end(adx);\n}\n\n \n\nvoid\ndelay(clock_t ticks)\n{\n\t(void) poll(0, 0, ticks * (1000 / hz));\n}\n\n \nint\nhighbit64(uint64_t i)\n{\n\tif (i == 0)\n\treturn (0);\n\n\treturn (NBBY * sizeof (uint64_t) - __builtin_clzll(i));\n}\n\n \nint\nlowbit64(uint64_t i)\n{\n\tif (i == 0)\n\t\treturn (0);\n\n\treturn (__builtin_ffsll(i));\n}\n\nconst char *random_path = \"/dev/random\";\nconst char *urandom_path = \"/dev/urandom\";\nstatic int random_fd = -1, urandom_fd = -1;\n\nvoid\nrandom_init(void)\n{\n\tVERIFY((random_fd = open(random_path, O_RDONLY | O_CLOEXEC)) != -1);\n\tVERIFY((urandom_fd = open(urandom_path, O_RDONLY | O_CLOEXEC)) != -1);\n}\n\nvoid\nrandom_fini(void)\n{\n\tclose(random_fd);\n\tclose(urandom_fd);\n\n\trandom_fd = -1;\n\turandom_fd = -1;\n}\n\nstatic int\nrandom_get_bytes_common(uint8_t *ptr, size_t len, int fd)\n{\n\tsize_t resid = len;\n\tssize_t bytes;\n\n\tASSERT(fd != -1);\n\n\twhile (resid != 0) {\n\t\tbytes = read(fd, ptr, resid);\n\t\tASSERT3S(bytes, >=, 0);\n\t\tptr += bytes;\n\t\tresid -= bytes;\n\t}\n\n\treturn (0);\n}\n\nint\nrandom_get_bytes(uint8_t *ptr, size_t len)\n{\n\treturn (random_get_bytes_common(ptr, len, random_fd));\n}\n\nint\nrandom_get_pseudo_bytes(uint8_t *ptr, size_t len)\n{\n\treturn (random_get_bytes_common(ptr, len, urandom_fd));\n}\n\nint\nddi_strtoull(const char *str, char **nptr, int base, u_longlong_t *result)\n{\n\terrno = 0;\n\t*result = strtoull(str, nptr, base);\n\tif (*result == 0)\n\t\treturn (errno);\n\treturn (0);\n}\n\nutsname_t *\nutsname(void)\n{\n\treturn (&hw_utsname);\n}\n\n \nstatic int\numem_out_of_memory(void)\n{\n\tchar errmsg[] = \"out of memory -- generating core dump\\n\";\n\n\t(void) fprintf(stderr, \"%s\", errmsg);\n\tabort();\n\treturn (0);\n}\n\nvoid\nkernel_init(int mode)\n{\n\textern uint_t rrw_tsd_key;\n\n\tumem_nofail_callback(umem_out_of_memory);\n\n\tphysmem = sysconf(_SC_PHYS_PAGES);\n\n\tdprintf(\"physmem = %llu pages (%.2f GB)\\n\", (u_longlong_t)physmem,\n\t    (double)physmem * sysconf(_SC_PAGE_SIZE) / (1ULL << 30));\n\n\thostid = (mode & SPA_MODE_WRITE) ? get_system_hostid() : 0;\n\n\trandom_init();\n\n\tVERIFY0(uname(&hw_utsname));\n\n\tsystem_taskq_init();\n\ticp_init();\n\n\tzstd_init();\n\n\tspa_init((spa_mode_t)mode);\n\n\tfletcher_4_init();\n\n\ttsd_create(&rrw_tsd_key, rrw_tsd_destroy);\n}\n\nvoid\nkernel_fini(void)\n{\n\tfletcher_4_fini();\n\tspa_fini();\n\n\tzstd_fini();\n\n\ticp_fini();\n\tsystem_taskq_fini();\n\n\trandom_fini();\n}\n\nuid_t\ncrgetuid(cred_t *cr)\n{\n\t(void) cr;\n\treturn (0);\n}\n\nuid_t\ncrgetruid(cred_t *cr)\n{\n\t(void) cr;\n\treturn (0);\n}\n\ngid_t\ncrgetgid(cred_t *cr)\n{\n\t(void) cr;\n\treturn (0);\n}\n\nint\ncrgetngroups(cred_t *cr)\n{\n\t(void) cr;\n\treturn (0);\n}\n\ngid_t *\ncrgetgroups(cred_t *cr)\n{\n\t(void) cr;\n\treturn (NULL);\n}\n\nint\nzfs_secpolicy_snapshot_perms(const char *name, cred_t *cr)\n{\n\t(void) name, (void) cr;\n\treturn (0);\n}\n\nint\nzfs_secpolicy_rename_perms(const char *from, const char *to, cred_t *cr)\n{\n\t(void) from, (void) to, (void) cr;\n\treturn (0);\n}\n\nint\nzfs_secpolicy_destroy_perms(const char *name, cred_t *cr)\n{\n\t(void) name, (void) cr;\n\treturn (0);\n}\n\nint\nsecpolicy_zfs(const cred_t *cr)\n{\n\t(void) cr;\n\treturn (0);\n}\n\nint\nsecpolicy_zfs_proc(const cred_t *cr, proc_t *proc)\n{\n\t(void) cr, (void) proc;\n\treturn (0);\n}\n\nksiddomain_t *\nksid_lookupdomain(const char *dom)\n{\n\tksiddomain_t *kd;\n\n\tkd = umem_zalloc(sizeof (ksiddomain_t), UMEM_NOFAIL);\n\tkd->kd_name = spa_strdup(dom);\n\treturn (kd);\n}\n\nvoid\nksiddomain_rele(ksiddomain_t *ksid)\n{\n\tspa_strfree(ksid->kd_name);\n\tumem_free(ksid, sizeof (ksiddomain_t));\n}\n\nchar *\nkmem_vasprintf(const char *fmt, va_list adx)\n{\n\tchar *buf = NULL;\n\tva_list adx_copy;\n\n\tva_copy(adx_copy, adx);\n\tVERIFY(vasprintf(&buf, fmt, adx_copy) != -1);\n\tva_end(adx_copy);\n\n\treturn (buf);\n}\n\nchar *\nkmem_asprintf(const char *fmt, ...)\n{\n\tchar *buf = NULL;\n\tva_list adx;\n\n\tva_start(adx, fmt);\n\tVERIFY(vasprintf(&buf, fmt, adx) != -1);\n\tva_end(adx);\n\n\treturn (buf);\n}\n\n \nint\nkmem_scnprintf(char *restrict str, size_t size, const char *restrict fmt, ...)\n{\n\tint n;\n\tva_list ap;\n\n\t \n\tif (size == 0)\n\t\treturn (0);\n\n\tva_start(ap, fmt);\n\tn = vsnprintf(str, size, fmt, ap);\n\tva_end(ap);\n\n\tif (n >= size)\n\t\tn = size - 1;\n\n\treturn (n);\n}\n\nzfs_file_t *\nzfs_onexit_fd_hold(int fd, minor_t *minorp)\n{\n\t(void) fd;\n\t*minorp = 0;\n\treturn (NULL);\n}\n\nvoid\nzfs_onexit_fd_rele(zfs_file_t *fp)\n{\n\t(void) fp;\n}\n\nint\nzfs_onexit_add_cb(minor_t minor, void (*func)(void *), void *data,\n    uintptr_t *action_handle)\n{\n\t(void) minor, (void) func, (void) data, (void) action_handle;\n\treturn (0);\n}\n\nfstrans_cookie_t\nspl_fstrans_mark(void)\n{\n\treturn ((fstrans_cookie_t)0);\n}\n\nvoid\nspl_fstrans_unmark(fstrans_cookie_t cookie)\n{\n\t(void) cookie;\n}\n\nint\n__spl_pf_fstrans_check(void)\n{\n\treturn (0);\n}\n\nint\nkmem_cache_reap_active(void)\n{\n\treturn (0);\n}\n\nvoid\nzvol_create_minor(const char *name)\n{\n\t(void) name;\n}\n\nvoid\nzvol_create_minors_recursive(const char *name)\n{\n\t(void) name;\n}\n\nvoid\nzvol_remove_minors(spa_t *spa, const char *name, boolean_t async)\n{\n\t(void) spa, (void) name, (void) async;\n}\n\nvoid\nzvol_rename_minors(spa_t *spa, const char *oldname, const char *newname,\n    boolean_t async)\n{\n\t(void) spa, (void) oldname, (void) newname, (void) async;\n}\n\n \nint\nzfs_file_open(const char *path, int flags, int mode, zfs_file_t **fpp)\n{\n\tint fd = -1;\n\tint dump_fd = -1;\n\tint err;\n\tint old_umask = 0;\n\tzfs_file_t *fp;\n\tstruct stat64 st;\n\n\tif (!(flags & O_CREAT) && stat64(path, &st) == -1)\n\t\treturn (errno);\n\n\tif (!(flags & O_CREAT) && S_ISBLK(st.st_mode))\n\t\tflags |= O_DIRECT;\n\n\tif (flags & O_CREAT)\n\t\told_umask = umask(0);\n\n\tfd = open64(path, flags, mode);\n\tif (fd == -1)\n\t\treturn (errno);\n\n\tif (flags & O_CREAT)\n\t\t(void) umask(old_umask);\n\n\tif (vn_dumpdir != NULL) {\n\t\tchar *dumppath = umem_zalloc(MAXPATHLEN, UMEM_NOFAIL);\n\t\tconst char *inpath = zfs_basename(path);\n\n\t\t(void) snprintf(dumppath, MAXPATHLEN,\n\t\t    \"%s/%s\", vn_dumpdir, inpath);\n\t\tdump_fd = open64(dumppath, O_CREAT | O_WRONLY, 0666);\n\t\tumem_free(dumppath, MAXPATHLEN);\n\t\tif (dump_fd == -1) {\n\t\t\terr = errno;\n\t\t\tclose(fd);\n\t\t\treturn (err);\n\t\t}\n\t} else {\n\t\tdump_fd = -1;\n\t}\n\n\t(void) fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\tfp = umem_zalloc(sizeof (zfs_file_t), UMEM_NOFAIL);\n\tfp->f_fd = fd;\n\tfp->f_dump_fd = dump_fd;\n\t*fpp = fp;\n\n\treturn (0);\n}\n\nvoid\nzfs_file_close(zfs_file_t *fp)\n{\n\tclose(fp->f_fd);\n\tif (fp->f_dump_fd != -1)\n\t\tclose(fp->f_dump_fd);\n\n\tumem_free(fp, sizeof (zfs_file_t));\n}\n\n \nint\nzfs_file_write(zfs_file_t *fp, const void *buf, size_t count, ssize_t *resid)\n{\n\tssize_t rc;\n\n\trc = write(fp->f_fd, buf, count);\n\tif (rc < 0)\n\t\treturn (errno);\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_pwrite(zfs_file_t *fp, const void *buf,\n    size_t count, loff_t pos, ssize_t *resid)\n{\n\tssize_t rc, split, done;\n\tint sectors;\n\n\t \n\tsectors = count >> SPA_MINBLOCKSHIFT;\n\tsplit = (sectors > 0 ? rand() % sectors : 0) << SPA_MINBLOCKSHIFT;\n\trc = pwrite64(fp->f_fd, buf, split, pos);\n\tif (rc != -1) {\n\t\tdone = rc;\n\t\trc = pwrite64(fp->f_fd, (char *)buf + split,\n\t\t    count - split, pos + split);\n\t}\n#ifdef __linux__\n\tif (rc == -1 && errno == EINVAL) {\n\t\t \n\t\tabort();\n\t}\n#endif\n\n\tif (rc < 0)\n\t\treturn (errno);\n\n\tdone += rc;\n\n\tif (resid) {\n\t\t*resid = count - done;\n\t} else if (done != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_read(zfs_file_t *fp, void *buf, size_t count, ssize_t *resid)\n{\n\tint rc;\n\n\trc = read(fp->f_fd, buf, count);\n\tif (rc < 0)\n\t\treturn (errno);\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_pread(zfs_file_t *fp, void *buf, size_t count, loff_t off,\n    ssize_t *resid)\n{\n\tssize_t rc;\n\n\trc = pread64(fp->f_fd, buf, count, off);\n\tif (rc < 0) {\n#ifdef __linux__\n\t\t \n\t\tif (errno == EINVAL)\n\t\t\tabort();\n#endif\n\t\treturn (errno);\n\t}\n\n\tif (fp->f_dump_fd != -1) {\n\t\tint status;\n\n\t\tstatus = pwrite64(fp->f_dump_fd, buf, rc, off);\n\t\tASSERT(status != -1);\n\t}\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_seek(zfs_file_t *fp, loff_t *offp, int whence)\n{\n\tloff_t rc;\n\n\trc = lseek(fp->f_fd, *offp, whence);\n\tif (rc < 0)\n\t\treturn (errno);\n\n\t*offp = rc;\n\n\treturn (0);\n}\n\n \nint\nzfs_file_getattr(zfs_file_t *fp, zfs_file_attr_t *zfattr)\n{\n\tstruct stat64 st;\n\n\tif (fstat64_blk(fp->f_fd, &st) == -1)\n\t\treturn (errno);\n\n\tzfattr->zfa_size = st.st_size;\n\tzfattr->zfa_mode = st.st_mode;\n\n\treturn (0);\n}\n\n \nint\nzfs_file_fsync(zfs_file_t *fp, int flags)\n{\n\t(void) flags;\n\n\tif (fsync(fp->f_fd) < 0)\n\t\treturn (errno);\n\n\treturn (0);\n}\n\n \nint\nzfs_file_fallocate(zfs_file_t *fp, int mode, loff_t offset, loff_t len)\n{\n#ifdef __linux__\n\treturn (fallocate(fp->f_fd, mode, offset, len));\n#else\n\t(void) fp, (void) mode, (void) offset, (void) len;\n\treturn (EOPNOTSUPP);\n#endif\n}\n\n \nloff_t\nzfs_file_off(zfs_file_t *fp)\n{\n\treturn (lseek(fp->f_fd, SEEK_CUR, 0));\n}\n\n \nint\nzfs_file_unlink(const char *path)\n{\n\treturn (remove(path));\n}\n\n \nzfs_file_t *\nzfs_file_get(int fd)\n{\n\t(void) fd;\n\tabort();\n\treturn (NULL);\n}\n \nvoid\nzfs_file_put(zfs_file_t *fp)\n{\n\tabort();\n\t(void) fp;\n}\n\nvoid\nzfsvfs_update_fromname(const char *oldname, const char *newname)\n{\n\t(void) oldname, (void) newname;\n}\n\nvoid\nspa_import_os(spa_t *spa)\n{\n\t(void) spa;\n}\n\nvoid\nspa_export_os(spa_t *spa)\n{\n\t(void) spa;\n}\n\nvoid\nspa_activate_os(spa_t *spa)\n{\n\t(void) spa;\n}\n\nvoid\nspa_deactivate_os(spa_t *spa)\n{\n\t(void) spa;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}