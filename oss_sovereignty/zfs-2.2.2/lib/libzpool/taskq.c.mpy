{
  "module_name": "taskq.c",
  "hash_id": "375428efb5f50e1e426f210ee23ca099d0cd8426e50a5bd7a7aa8307fec84b65",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzpool/taskq.c",
  "human_readable_source": " \n \n \n\n#include <sys/zfs_context.h>\n\nint taskq_now;\ntaskq_t *system_taskq;\ntaskq_t *system_delay_taskq;\n\nstatic pthread_key_t taskq_tsd;\n\n#define\tTASKQ_ACTIVE\t0x00010000\n\nstatic taskq_ent_t *\ntask_alloc(taskq_t *tq, int tqflags)\n{\n\ttaskq_ent_t *t;\n\tint rv;\n\nagain:\tif ((t = tq->tq_freelist) != NULL && tq->tq_nalloc >= tq->tq_minalloc) {\n\t\tASSERT(!(t->tqent_flags & TQENT_FLAG_PREALLOC));\n\t\ttq->tq_freelist = t->tqent_next;\n\t} else {\n\t\tif (tq->tq_nalloc >= tq->tq_maxalloc) {\n\t\t\tif (!(tqflags & KM_SLEEP))\n\t\t\t\treturn (NULL);\n\n\t\t\t \n\t\t\ttq->tq_maxalloc_wait++;\n\t\t\trv = cv_timedwait(&tq->tq_maxalloc_cv,\n\t\t\t    &tq->tq_lock, ddi_get_lbolt() + hz);\n\t\t\ttq->tq_maxalloc_wait--;\n\t\t\tif (rv > 0)\n\t\t\t\tgoto again;\t\t \n\t\t}\n\t\tmutex_exit(&tq->tq_lock);\n\n\t\tt = kmem_alloc(sizeof (taskq_ent_t), tqflags);\n\n\t\tmutex_enter(&tq->tq_lock);\n\t\tif (t != NULL) {\n\t\t\t \n\t\t\tt->tqent_flags = 0;\n\t\t\ttq->tq_nalloc++;\n\t\t}\n\t}\n\treturn (t);\n}\n\nstatic void\ntask_free(taskq_t *tq, taskq_ent_t *t)\n{\n\tif (tq->tq_nalloc <= tq->tq_minalloc) {\n\t\tt->tqent_next = tq->tq_freelist;\n\t\ttq->tq_freelist = t;\n\t} else {\n\t\ttq->tq_nalloc--;\n\t\tmutex_exit(&tq->tq_lock);\n\t\tkmem_free(t, sizeof (taskq_ent_t));\n\t\tmutex_enter(&tq->tq_lock);\n\t}\n\n\tif (tq->tq_maxalloc_wait)\n\t\tcv_signal(&tq->tq_maxalloc_cv);\n}\n\ntaskqid_t\ntaskq_dispatch(taskq_t *tq, task_func_t func, void *arg, uint_t tqflags)\n{\n\ttaskq_ent_t *t;\n\n\tif (taskq_now) {\n\t\tfunc(arg);\n\t\treturn (1);\n\t}\n\n\tmutex_enter(&tq->tq_lock);\n\tASSERT(tq->tq_flags & TASKQ_ACTIVE);\n\tif ((t = task_alloc(tq, tqflags)) == NULL) {\n\t\tmutex_exit(&tq->tq_lock);\n\t\treturn (0);\n\t}\n\tif (tqflags & TQ_FRONT) {\n\t\tt->tqent_next = tq->tq_task.tqent_next;\n\t\tt->tqent_prev = &tq->tq_task;\n\t} else {\n\t\tt->tqent_next = &tq->tq_task;\n\t\tt->tqent_prev = tq->tq_task.tqent_prev;\n\t}\n\tt->tqent_next->tqent_prev = t;\n\tt->tqent_prev->tqent_next = t;\n\tt->tqent_func = func;\n\tt->tqent_arg = arg;\n\tt->tqent_flags = 0;\n\tcv_signal(&tq->tq_dispatch_cv);\n\tmutex_exit(&tq->tq_lock);\n\treturn (1);\n}\n\ntaskqid_t\ntaskq_dispatch_delay(taskq_t *tq, task_func_t func, void *arg, uint_t tqflags,\n    clock_t expire_time)\n{\n\t(void) tq, (void) func, (void) arg, (void) tqflags, (void) expire_time;\n\treturn (0);\n}\n\nint\ntaskq_empty_ent(taskq_ent_t *t)\n{\n\treturn (t->tqent_next == NULL);\n}\n\nvoid\ntaskq_init_ent(taskq_ent_t *t)\n{\n\tt->tqent_next = NULL;\n\tt->tqent_prev = NULL;\n\tt->tqent_func = NULL;\n\tt->tqent_arg = NULL;\n\tt->tqent_flags = 0;\n}\n\nvoid\ntaskq_dispatch_ent(taskq_t *tq, task_func_t func, void *arg, uint_t flags,\n    taskq_ent_t *t)\n{\n\tASSERT(func != NULL);\n\n\t \n\tt->tqent_flags |= TQENT_FLAG_PREALLOC;\n\t \n\tmutex_enter(&tq->tq_lock);\n\n\tif (flags & TQ_FRONT) {\n\t\tt->tqent_next = tq->tq_task.tqent_next;\n\t\tt->tqent_prev = &tq->tq_task;\n\t} else {\n\t\tt->tqent_next = &tq->tq_task;\n\t\tt->tqent_prev = tq->tq_task.tqent_prev;\n\t}\n\tt->tqent_next->tqent_prev = t;\n\tt->tqent_prev->tqent_next = t;\n\tt->tqent_func = func;\n\tt->tqent_arg = arg;\n\tcv_signal(&tq->tq_dispatch_cv);\n\tmutex_exit(&tq->tq_lock);\n}\n\nvoid\ntaskq_wait(taskq_t *tq)\n{\n\tmutex_enter(&tq->tq_lock);\n\twhile (tq->tq_task.tqent_next != &tq->tq_task || tq->tq_active != 0)\n\t\tcv_wait(&tq->tq_wait_cv, &tq->tq_lock);\n\tmutex_exit(&tq->tq_lock);\n}\n\nvoid\ntaskq_wait_id(taskq_t *tq, taskqid_t id)\n{\n\t(void) id;\n\ttaskq_wait(tq);\n}\n\nvoid\ntaskq_wait_outstanding(taskq_t *tq, taskqid_t id)\n{\n\t(void) id;\n\ttaskq_wait(tq);\n}\n\nstatic __attribute__((noreturn)) void\ntaskq_thread(void *arg)\n{\n\ttaskq_t *tq = arg;\n\ttaskq_ent_t *t;\n\tboolean_t prealloc;\n\n\tVERIFY0(pthread_setspecific(taskq_tsd, tq));\n\n\tmutex_enter(&tq->tq_lock);\n\twhile (tq->tq_flags & TASKQ_ACTIVE) {\n\t\tif ((t = tq->tq_task.tqent_next) == &tq->tq_task) {\n\t\t\tif (--tq->tq_active == 0)\n\t\t\t\tcv_broadcast(&tq->tq_wait_cv);\n\t\t\tcv_wait(&tq->tq_dispatch_cv, &tq->tq_lock);\n\t\t\ttq->tq_active++;\n\t\t\tcontinue;\n\t\t}\n\t\tt->tqent_prev->tqent_next = t->tqent_next;\n\t\tt->tqent_next->tqent_prev = t->tqent_prev;\n\t\tt->tqent_next = NULL;\n\t\tt->tqent_prev = NULL;\n\t\tprealloc = t->tqent_flags & TQENT_FLAG_PREALLOC;\n\t\tmutex_exit(&tq->tq_lock);\n\n\t\trw_enter(&tq->tq_threadlock, RW_READER);\n\t\tt->tqent_func(t->tqent_arg);\n\t\trw_exit(&tq->tq_threadlock);\n\n\t\tmutex_enter(&tq->tq_lock);\n\t\tif (!prealloc)\n\t\t\ttask_free(tq, t);\n\t}\n\ttq->tq_nthreads--;\n\tcv_broadcast(&tq->tq_wait_cv);\n\tmutex_exit(&tq->tq_lock);\n\tthread_exit();\n}\n\ntaskq_t *\ntaskq_create(const char *name, int nthreads, pri_t pri,\n    int minalloc, int maxalloc, uint_t flags)\n{\n\t(void) pri;\n\ttaskq_t *tq = kmem_zalloc(sizeof (taskq_t), KM_SLEEP);\n\tint t;\n\n\tif (flags & TASKQ_THREADS_CPU_PCT) {\n\t\tint pct;\n\t\tASSERT3S(nthreads, >=, 0);\n\t\tASSERT3S(nthreads, <=, 100);\n\t\tpct = MIN(nthreads, 100);\n\t\tpct = MAX(pct, 0);\n\n\t\tnthreads = (sysconf(_SC_NPROCESSORS_ONLN) * pct) / 100;\n\t\tnthreads = MAX(nthreads, 1);\t \n\t} else {\n\t\tASSERT3S(nthreads, >=, 1);\n\t}\n\n\trw_init(&tq->tq_threadlock, NULL, RW_DEFAULT, NULL);\n\tmutex_init(&tq->tq_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&tq->tq_dispatch_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&tq->tq_wait_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&tq->tq_maxalloc_cv, NULL, CV_DEFAULT, NULL);\n\t(void) strlcpy(tq->tq_name, name, sizeof (tq->tq_name));\n\ttq->tq_flags = flags | TASKQ_ACTIVE;\n\ttq->tq_active = nthreads;\n\ttq->tq_nthreads = nthreads;\n\ttq->tq_minalloc = minalloc;\n\ttq->tq_maxalloc = maxalloc;\n\ttq->tq_task.tqent_next = &tq->tq_task;\n\ttq->tq_task.tqent_prev = &tq->tq_task;\n\ttq->tq_threadlist = kmem_alloc(nthreads * sizeof (kthread_t *),\n\t    KM_SLEEP);\n\n\tif (flags & TASKQ_PREPOPULATE) {\n\t\tmutex_enter(&tq->tq_lock);\n\t\twhile (minalloc-- > 0)\n\t\t\ttask_free(tq, task_alloc(tq, KM_SLEEP));\n\t\tmutex_exit(&tq->tq_lock);\n\t}\n\n\tfor (t = 0; t < nthreads; t++)\n\t\tVERIFY((tq->tq_threadlist[t] = thread_create(NULL, 0,\n\t\t    taskq_thread, tq, 0, &p0, TS_RUN, pri)) != NULL);\n\n\treturn (tq);\n}\n\nvoid\ntaskq_destroy(taskq_t *tq)\n{\n\tint nthreads = tq->tq_nthreads;\n\n\ttaskq_wait(tq);\n\n\tmutex_enter(&tq->tq_lock);\n\n\ttq->tq_flags &= ~TASKQ_ACTIVE;\n\tcv_broadcast(&tq->tq_dispatch_cv);\n\n\twhile (tq->tq_nthreads != 0)\n\t\tcv_wait(&tq->tq_wait_cv, &tq->tq_lock);\n\n\ttq->tq_minalloc = 0;\n\twhile (tq->tq_nalloc != 0) {\n\t\tASSERT(tq->tq_freelist != NULL);\n\t\ttaskq_ent_t *tqent_nexttq = tq->tq_freelist->tqent_next;\n\t\ttask_free(tq, tq->tq_freelist);\n\t\ttq->tq_freelist = tqent_nexttq;\n\t}\n\n\tmutex_exit(&tq->tq_lock);\n\n\tkmem_free(tq->tq_threadlist, nthreads * sizeof (kthread_t *));\n\n\trw_destroy(&tq->tq_threadlock);\n\tmutex_destroy(&tq->tq_lock);\n\tcv_destroy(&tq->tq_dispatch_cv);\n\tcv_destroy(&tq->tq_wait_cv);\n\tcv_destroy(&tq->tq_maxalloc_cv);\n\n\tkmem_free(tq, sizeof (taskq_t));\n}\n\nint\ntaskq_member(taskq_t *tq, kthread_t *t)\n{\n\tint i;\n\n\tif (taskq_now)\n\t\treturn (1);\n\n\tfor (i = 0; i < tq->tq_nthreads; i++)\n\t\tif (tq->tq_threadlist[i] == t)\n\t\t\treturn (1);\n\n\treturn (0);\n}\n\ntaskq_t *\ntaskq_of_curthread(void)\n{\n\treturn (pthread_getspecific(taskq_tsd));\n}\n\nint\ntaskq_cancel_id(taskq_t *tq, taskqid_t id)\n{\n\t(void) tq, (void) id;\n\treturn (ENOENT);\n}\n\nvoid\nsystem_taskq_init(void)\n{\n\tVERIFY0(pthread_key_create(&taskq_tsd, NULL));\n\tsystem_taskq = taskq_create(\"system_taskq\", 64, maxclsyspri, 4, 512,\n\t    TASKQ_DYNAMIC | TASKQ_PREPOPULATE);\n\tsystem_delay_taskq = taskq_create(\"delay_taskq\", 4, maxclsyspri, 4,\n\t    512, TASKQ_DYNAMIC | TASKQ_PREPOPULATE);\n}\n\nvoid\nsystem_taskq_fini(void)\n{\n\ttaskq_destroy(system_taskq);\n\tsystem_taskq = NULL;  \n\ttaskq_destroy(system_delay_taskq);\n\tsystem_delay_taskq = NULL;\n\tVERIFY0(pthread_key_delete(taskq_tsd));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}