{
  "module_name": "mnttab.c",
  "hash_id": "caeb7967f7be34948c54d917ebe3745b5621cffc8d478deff9bb53ab924f5b93",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libspl/os/freebsd/mnttab.c",
  "human_readable_source": " \n\n \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/mntent.h>\n#include <sys/mnttab.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char *\nmntopt(char **p)\n{\n\tchar *cp = *p;\n\tchar *retstr;\n\n\twhile (*cp && isspace(*cp))\n\t\tcp++;\n\n\tretstr = cp;\n\twhile (*cp && *cp != ',')\n\t\tcp++;\n\n\tif (*cp) {\n\t\t*cp = '\\0';\n\t\tcp++;\n\t}\n\n\t*p = cp;\n\treturn (retstr);\n}\n\nchar *\nhasmntopt(struct mnttab *mnt, const char *opt)\n{\n\tchar tmpopts[MNT_LINE_MAX];\n\tchar *f, *opts = tmpopts;\n\n\tif (mnt->mnt_mntopts == NULL)\n\t\treturn (NULL);\n\t(void) strlcpy(opts, mnt->mnt_mntopts, MNT_LINE_MAX);\n\tf = mntopt(&opts);\n\tfor (; *f; f = mntopt(&opts)) {\n\t\tif (strncmp(opt, f, strlen(opt)) == 0)\n\t\t\treturn (f - tmpopts + mnt->mnt_mntopts);\n\t}\n\treturn (NULL);\n}\n\nstatic void\noptadd(char *mntopts, size_t size, const char *opt)\n{\n\n\tif (mntopts[0] != '\\0')\n\t\tstrlcat(mntopts, \",\", size);\n\tstrlcat(mntopts, opt, size);\n}\n\nstatic __thread char gfstypename[MFSNAMELEN];\nstatic __thread char gmntfromname[MNAMELEN];\nstatic __thread char gmntonname[MNAMELEN];\nstatic __thread char gmntopts[MNTMAXSTR];\n\nvoid\nstatfs2mnttab(struct statfs *sfs, struct mnttab *mp)\n{\n\tlong flags;\n\n\tstrlcpy(gfstypename, sfs->f_fstypename, sizeof (gfstypename));\n\tmp->mnt_fstype = gfstypename;\n\n\tstrlcpy(gmntfromname, sfs->f_mntfromname, sizeof (gmntfromname));\n\tmp->mnt_special = gmntfromname;\n\n\tstrlcpy(gmntonname, sfs->f_mntonname, sizeof (gmntonname));\n\tmp->mnt_mountp = gmntonname;\n\n\tflags = sfs->f_flags;\n\tgmntopts[0] = '\\0';\n#define\tOPTADD(opt)\toptadd(gmntopts, sizeof (gmntopts), (opt))\n\tif (flags & MNT_RDONLY)\n\t\tOPTADD(MNTOPT_RO);\n\telse\n\t\tOPTADD(MNTOPT_RW);\n\tif (flags & MNT_NOSUID)\n\t\tOPTADD(MNTOPT_NOSETUID);\n\telse\n\t\tOPTADD(MNTOPT_SETUID);\n\tif (flags & MNT_UPDATE)\n\t\tOPTADD(MNTOPT_REMOUNT);\n\tif (flags & MNT_NOATIME)\n\t\tOPTADD(MNTOPT_NOATIME);\n\telse\n\t\tOPTADD(MNTOPT_ATIME);\n\tOPTADD(MNTOPT_NOXATTR);\n\tif (flags & MNT_NOEXEC)\n\t\tOPTADD(MNTOPT_NOEXEC);\n\telse\n\t\tOPTADD(MNTOPT_EXEC);\n#undef\tOPTADD\n\tmp->mnt_mntopts = gmntopts;\n}\n\nstatic pthread_rwlock_t gsfs_lock = PTHREAD_RWLOCK_INITIALIZER;\nstatic struct statfs *gsfs = NULL;\nstatic int allfs = 0;\n\nstatic int\nstatfs_init(void)\n{\n\tstruct statfs *sfs;\n\tint error;\n\n\t(void) pthread_rwlock_wrlock(&gsfs_lock);\n\n\tif (gsfs != NULL) {\n\t\tfree(gsfs);\n\t\tgsfs = NULL;\n\t}\n\tallfs = getfsstat(NULL, 0, MNT_NOWAIT);\n\tif (allfs == -1)\n\t\tgoto fail;\n\tgsfs = malloc(sizeof (gsfs[0]) * allfs * 2);\n\tif (gsfs == NULL)\n\t\tgoto fail;\n\tallfs = getfsstat(gsfs, (long)(sizeof (gsfs[0]) * allfs * 2),\n\t    MNT_NOWAIT);\n\tif (allfs == -1)\n\t\tgoto fail;\n\tsfs = realloc(gsfs, allfs * sizeof (gsfs[0]));\n\tif (sfs != NULL)\n\t\tgsfs = sfs;\n\t(void) pthread_rwlock_unlock(&gsfs_lock);\n\treturn (0);\nfail:\n\terror = errno;\n\tif (gsfs != NULL)\n\t\tfree(gsfs);\n\tgsfs = NULL;\n\tallfs = 0;\n\t(void) pthread_rwlock_unlock(&gsfs_lock);\n\treturn (error);\n}\n\nint\ngetmntany(FILE *fd __unused, struct mnttab *mgetp, struct mnttab *mrefp)\n{\n\tint i, error;\n\n\terror = statfs_init();\n\tif (error != 0)\n\t\treturn (error);\n\n\t(void) pthread_rwlock_rdlock(&gsfs_lock);\n\n\tfor (i = 0; i < allfs; i++) {\n\t\tif (mrefp->mnt_special != NULL &&\n\t\t    strcmp(mrefp->mnt_special, gsfs[i].f_mntfromname) != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mrefp->mnt_mountp != NULL &&\n\t\t    strcmp(mrefp->mnt_mountp, gsfs[i].f_mntonname) != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mrefp->mnt_fstype != NULL &&\n\t\t    strcmp(mrefp->mnt_fstype, gsfs[i].f_fstypename) != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tstatfs2mnttab(&gsfs[i], mgetp);\n\t\t(void) pthread_rwlock_unlock(&gsfs_lock);\n\t\treturn (0);\n\t}\n\t(void) pthread_rwlock_unlock(&gsfs_lock);\n\treturn (-1);\n}\n\nint\ngetmntent(FILE *fp, struct mnttab *mp)\n{\n\tint error, nfs;\n\n\tnfs = (int)lseek(fileno(fp), 0, SEEK_CUR);\n\tif (nfs == -1)\n\t\treturn (errno);\n\t \n\tif (nfs == 0 || gsfs == NULL) {\n\t\terror = statfs_init();\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\t(void) pthread_rwlock_rdlock(&gsfs_lock);\n\tif (nfs >= allfs) {\n\t\t(void) pthread_rwlock_unlock(&gsfs_lock);\n\t\treturn (-1);\n\t}\n\tstatfs2mnttab(&gsfs[nfs], mp);\n\t(void) pthread_rwlock_unlock(&gsfs_lock);\n\tif (lseek(fileno(fp), 1, SEEK_CUR) == -1)\n\t\treturn (errno);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}