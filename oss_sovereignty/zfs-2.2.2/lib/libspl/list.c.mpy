{
  "module_name": "list.c",
  "hash_id": "91d2162fe7c0cc947663604579be1b3ea0f4bf3d2b5712be2613daccda88310b",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libspl/list.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/list.h>\n#include <sys/list_impl.h>\n#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <sys/debug.h>\n\n#define\tlist_d2l(a, obj) ((list_node_t *)(((char *)obj) + (a)->list_offset))\n#define\tlist_object(a, node) ((void *)(((char *)node) - (a)->list_offset))\n#define\tlist_empty(a) ((a)->list_head.next == &(a)->list_head)\n\n#define\tlist_insert_after_node(list, node, object) {\t\\\n\tlist_node_t *lnew = list_d2l(list, object);\t\\\n\tlnew->prev = (node);\t\t\t\\\n\tlnew->next = (node)->next;\t\t\\\n\t(node)->next->prev = lnew;\t\t\\\n\t(node)->next = lnew;\t\t\t\\\n}\n\n#define\tlist_insert_before_node(list, node, object) {\t\\\n\tlist_node_t *lnew = list_d2l(list, object);\t\\\n\tlnew->next = (node);\t\t\t\\\n\tlnew->prev = (node)->prev;\t\t\\\n\t(node)->prev->next = lnew;\t\t\\\n\t(node)->prev = lnew;\t\t\t\\\n}\n\n#define\tlist_remove_node(node)\t\t\t\t\t\\\n\t(node)->prev->next = (node)->next;\t\\\n\t(node)->next->prev = (node)->prev;\t\\\n\t(node)->next = (node)->prev = NULL\n\nvoid\nlist_create(list_t *list, size_t size, size_t offset)\n{\n\tASSERT(list);\n\tASSERT(size > 0);\n\tASSERT(size >= offset + sizeof (list_node_t));\n\n\tlist->list_size = size;\n\tlist->list_offset = offset;\n\tlist->list_head.next = list->list_head.prev = &list->list_head;\n}\n\nvoid\nlist_destroy(list_t *list)\n{\n\tlist_node_t *node = &list->list_head;\n\n\tASSERT(list);\n\tASSERT(list->list_head.next == node);\n\tASSERT(list->list_head.prev == node);\n\n\tnode->next = node->prev = NULL;\n}\n\nvoid\nlist_insert_after(list_t *list, void *object, void *nobject)\n{\n\tif (object == NULL) {\n\t\tlist_insert_head(list, nobject);\n\t} else {\n\t\tlist_node_t *lold = list_d2l(list, object);\n\t\tlist_insert_after_node(list, lold, nobject);\n\t}\n}\n\nvoid\nlist_insert_before(list_t *list, void *object, void *nobject)\n{\n\tif (object == NULL) {\n\t\tlist_insert_tail(list, nobject);\n\t} else {\n\t\tlist_node_t *lold = list_d2l(list, object);\n\t\tlist_insert_before_node(list, lold, nobject);\n\t}\n}\n\nvoid\nlist_insert_head(list_t *list, void *object)\n{\n\tlist_node_t *lold = &list->list_head;\n\tlist_insert_after_node(list, lold, object);\n}\n\nvoid\nlist_insert_tail(list_t *list, void *object)\n{\n\tlist_node_t *lold = &list->list_head;\n\tlist_insert_before_node(list, lold, object);\n}\n\nvoid\nlist_remove(list_t *list, void *object)\n{\n\tlist_node_t *lold = list_d2l(list, object);\n\tASSERT(!list_empty(list));\n\tASSERT(lold->next != NULL);\n\tlist_remove_node(lold);\n}\n\nvoid *\nlist_remove_head(list_t *list)\n{\n\tlist_node_t *head = list->list_head.next;\n\tif (head == &list->list_head)\n\t\treturn (NULL);\n\tlist_remove_node(head);\n\treturn (list_object(list, head));\n}\n\nvoid *\nlist_remove_tail(list_t *list)\n{\n\tlist_node_t *tail = list->list_head.prev;\n\tif (tail == &list->list_head)\n\t\treturn (NULL);\n\tlist_remove_node(tail);\n\treturn (list_object(list, tail));\n}\n\nvoid *\nlist_head(list_t *list)\n{\n\tif (list_empty(list))\n\t\treturn (NULL);\n\treturn (list_object(list, list->list_head.next));\n}\n\nvoid *\nlist_tail(list_t *list)\n{\n\tif (list_empty(list))\n\t\treturn (NULL);\n\treturn (list_object(list, list->list_head.prev));\n}\n\nvoid *\nlist_next(list_t *list, void *object)\n{\n\tlist_node_t *node = list_d2l(list, object);\n\n\tif (node->next != &list->list_head)\n\t\treturn (list_object(list, node->next));\n\n\treturn (NULL);\n}\n\nvoid *\nlist_prev(list_t *list, void *object)\n{\n\tlist_node_t *node = list_d2l(list, object);\n\n\tif (node->prev != &list->list_head)\n\t\treturn (list_object(list, node->prev));\n\n\treturn (NULL);\n}\n\n \nvoid\nlist_move_tail(list_t *dst, list_t *src)\n{\n\tlist_node_t *dstnode = &dst->list_head;\n\tlist_node_t *srcnode = &src->list_head;\n\n\tASSERT(dst->list_size == src->list_size);\n\tASSERT(dst->list_offset == src->list_offset);\n\n\tif (list_empty(src))\n\t\treturn;\n\n\tdstnode->prev->next = srcnode->next;\n\tsrcnode->next->prev = dstnode->prev;\n\tdstnode->prev = srcnode->prev;\n\tsrcnode->prev->next = dstnode;\n\n\t \n\tsrcnode->next = srcnode->prev = srcnode;\n}\n\nvoid\nlist_link_replace(list_node_t *lold, list_node_t *lnew)\n{\n\tASSERT(list_link_active(lold));\n\tASSERT(!list_link_active(lnew));\n\n\tlnew->next = lold->next;\n\tlnew->prev = lold->prev;\n\tlold->prev->next = lnew;\n\tlold->next->prev = lnew;\n\tlold->next = lold->prev = NULL;\n}\n\nvoid\nlist_link_init(list_node_t *ln)\n{\n\tln->next = NULL;\n\tln->prev = NULL;\n}\n\nint\nlist_link_active(list_node_t *ln)\n{\n\tEQUIV(ln->next == NULL, ln->prev == NULL);\n\treturn (ln->next != NULL);\n}\n\nint\nlist_is_empty(list_t *list)\n{\n\treturn (list_empty(list));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}