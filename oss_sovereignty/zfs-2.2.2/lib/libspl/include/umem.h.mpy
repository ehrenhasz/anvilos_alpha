{
  "module_name": "umem.h",
  "hash_id": "966cf46cc54fd5964dc74b8bfdd52640c4f7afc894f72ec9df3f9e573986e832",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libspl/include/umem.h",
  "human_readable_source": " \n \n\n#ifndef _LIBSPL_UMEM_H\n#define\t_LIBSPL_UMEM_H\n\n \n#include <sys/debug.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void vmem_t;\n\n \n#define\tUMEM_DEFAULT\t\t0x0000   \n#define\tUMEM_NOFAIL\t\t0x0100   \n\n \n#define\tUMC_NODEBUG\t\t0x00020000\n\n#define\tUMEM_CACHE_NAMELEN\t31\n\ntypedef int umem_nofail_callback_t(void);\ntypedef int umem_constructor_t(void *, void *, int);\ntypedef void umem_destructor_t(void *, void *);\ntypedef void umem_reclaim_t(void *);\n\ntypedef struct umem_cache {\n\tchar\t\t\tcache_name[UMEM_CACHE_NAMELEN + 1];\n\tsize_t\t\t\tcache_bufsize;\n\tsize_t\t\t\tcache_align;\n\tumem_constructor_t\t*cache_constructor;\n\tumem_destructor_t\t*cache_destructor;\n\tumem_reclaim_t\t\t*cache_reclaim;\n\tvoid\t\t\t*cache_private;\n\tvoid\t\t\t*cache_arena;\n\tint\t\t\tcache_cflags;\n} umem_cache_t;\n\n \nconst char *_umem_debug_init(void);\nconst char *_umem_options_init(void);\nconst char *_umem_logging_init(void);\n\n__attribute__((malloc, alloc_size(1)))\nstatic inline void *\numem_alloc(size_t size, int flags)\n{\n\tvoid *ptr = NULL;\n\n\tdo {\n\t\tptr = malloc(size);\n\t} while (ptr == NULL && (flags & UMEM_NOFAIL));\n\n\treturn (ptr);\n}\n\n__attribute__((malloc, alloc_size(1)))\nstatic inline void *\numem_alloc_aligned(size_t size, size_t align, int flags)\n{\n\tvoid *ptr = NULL;\n\tint rc = EINVAL;\n\n\tdo {\n\t\trc = posix_memalign(&ptr, align, size);\n\t} while (rc == ENOMEM && (flags & UMEM_NOFAIL));\n\n\tif (rc == EINVAL) {\n\t\tfprintf(stderr, \"%s: invalid memory alignment (%zd)\\n\",\n\t\t    __func__, align);\n\t\tif (flags & UMEM_NOFAIL)\n\t\t\tabort();\n\t\treturn (NULL);\n\t}\n\n\treturn (ptr);\n}\n\n__attribute__((malloc, alloc_size(1)))\nstatic inline void *\numem_zalloc(size_t size, int flags)\n{\n\tvoid *ptr = NULL;\n\n\tptr = umem_alloc(size, flags);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\n\treturn (ptr);\n}\n\nstatic inline void\numem_free(const void *ptr, size_t size __maybe_unused)\n{\n\tfree((void *)ptr);\n}\n\n \nstatic inline void\numem_free_aligned(void *ptr, size_t size __maybe_unused)\n{\n#ifndef _WIN32\n\tfree((void *)ptr);\n#else\n\t_aligned_free(ptr);\n#endif\n}\n\nstatic inline void\numem_nofail_callback(umem_nofail_callback_t *cb __maybe_unused)\n{}\n\nstatic inline umem_cache_t *\numem_cache_create(\n    const char *name, size_t bufsize, size_t align,\n    umem_constructor_t *constructor,\n    umem_destructor_t *destructor,\n    umem_reclaim_t *reclaim,\n    void *priv, void *vmp, int cflags)\n{\n\tumem_cache_t *cp;\n\n\tcp = (umem_cache_t *)umem_alloc(sizeof (umem_cache_t), UMEM_DEFAULT);\n\tif (cp) {\n\t\tstrlcpy(cp->cache_name, name, UMEM_CACHE_NAMELEN);\n\t\tcp->cache_bufsize = bufsize;\n\t\tcp->cache_align = align;\n\t\tcp->cache_constructor = constructor;\n\t\tcp->cache_destructor = destructor;\n\t\tcp->cache_reclaim = reclaim;\n\t\tcp->cache_private = priv;\n\t\tcp->cache_arena = vmp;\n\t\tcp->cache_cflags = cflags;\n\t}\n\n\treturn (cp);\n}\n\nstatic inline void\numem_cache_destroy(umem_cache_t *cp)\n{\n\tumem_free(cp, sizeof (umem_cache_t));\n}\n\n__attribute__((malloc))\nstatic inline void *\numem_cache_alloc(umem_cache_t *cp, int flags)\n{\n\tvoid *ptr = NULL;\n\n\tif (cp->cache_align != 0)\n\t\tptr = umem_alloc_aligned(\n\t\t    cp->cache_bufsize, cp->cache_align, flags);\n\telse\n\t\tptr = umem_alloc(cp->cache_bufsize, flags);\n\n\tif (ptr && cp->cache_constructor)\n\t\tcp->cache_constructor(ptr, cp->cache_private, UMEM_DEFAULT);\n\n\treturn (ptr);\n}\n\nstatic inline void\numem_cache_free(umem_cache_t *cp, void *ptr)\n{\n\tif (cp->cache_destructor)\n\t\tcp->cache_destructor(ptr, cp->cache_private);\n\n\tif (cp->cache_align != 0)\n\t\tumem_free_aligned(ptr, cp->cache_bufsize);\n\telse\n\t\tumem_free(ptr, cp->cache_bufsize);\n}\n\nstatic inline void\numem_cache_reap_now(umem_cache_t *cp __maybe_unused)\n{\n}\n\n#ifdef  __cplusplus\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}