{
  "module_name": "simd.h",
  "hash_id": "f601b1650dbfc5bcdfea664d74ab2591edeb166f7d92e24f030d1564498f4a28",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libspl/include/sys/simd.h",
  "human_readable_source": " \n \n\n#ifndef _LIBSPL_SYS_SIMD_H\n#define\t_LIBSPL_SYS_SIMD_H\n\n#include <sys/isa_defs.h>\n#include <sys/types.h>\n\n \n#if defined(__arm__) || defined(__aarch64__) || defined(__powerpc__)\n#if defined(__FreeBSD__)\n#define\tAT_HWCAP\t25\n#define\tAT_HWCAP2\t26\nextern int elf_aux_info(int aux, void *buf, int buflen);\nstatic inline unsigned long getauxval(unsigned long key)\n{\n\tunsigned long val = 0UL;\n\n\tif (elf_aux_info((int)key, &val, sizeof (val)) != 0)\n\t\treturn (0UL);\n\n\treturn (val);\n}\n#elif defined(__linux__)\n#define\tAT_HWCAP\t16\n#define\tAT_HWCAP2\t26\nextern unsigned long getauxval(unsigned long type);\n#endif  \n#endif  \n\n#if defined(__x86)\n#include <cpuid.h>\n\n#define\tkfpu_allowed()\t\t1\n#define\tkfpu_begin()\t\tdo {} while (0)\n#define\tkfpu_end()\t\tdo {} while (0)\n#define\tkfpu_init()\t\t0\n#define\tkfpu_fini()\t\t((void) 0)\n\n \ntypedef enum cpuid_regs {\n\tEAX = 0,\n\tEBX,\n\tECX,\n\tEDX,\n\tCPUID_REG_CNT = 4\n} cpuid_regs_t;\n\n \ntypedef enum cpuid_inst_sets {\n\tSSE = 0,\n\tSSE2,\n\tSSE3,\n\tSSSE3,\n\tSSE4_1,\n\tSSE4_2,\n\tOSXSAVE,\n\tAVX,\n\tAVX2,\n\tBMI1,\n\tBMI2,\n\tAVX512F,\n\tAVX512CD,\n\tAVX512DQ,\n\tAVX512BW,\n\tAVX512IFMA,\n\tAVX512VBMI,\n\tAVX512PF,\n\tAVX512ER,\n\tAVX512VL,\n\tAES,\n\tPCLMULQDQ,\n\tMOVBE,\n\tSHA_NI\n} cpuid_inst_sets_t;\n\n \ntypedef struct cpuid_feature_desc {\n\tuint32_t leaf;\t\t \n\tuint32_t subleaf;\t \n\tuint32_t flag;\t\t \n\tcpuid_regs_t reg;\t \n} cpuid_feature_desc_t;\n\n#define\t_AVX512F_BIT\t\t(1U << 16)\n#define\t_AVX512CD_BIT\t\t(_AVX512F_BIT | (1U << 28))\n#define\t_AVX512DQ_BIT\t\t(_AVX512F_BIT | (1U << 17))\n#define\t_AVX512BW_BIT\t\t(_AVX512F_BIT | (1U << 30))\n#define\t_AVX512IFMA_BIT\t\t(_AVX512F_BIT | (1U << 21))\n#define\t_AVX512VBMI_BIT\t\t(1U << 1)  \n#define\t_AVX512PF_BIT\t\t(_AVX512F_BIT | (1U << 26))\n#define\t_AVX512ER_BIT\t\t(_AVX512F_BIT | (1U << 27))\n#define\t_AVX512VL_BIT\t\t(1U << 31)  \n#define\t_AES_BIT\t\t(1U << 25)\n#define\t_PCLMULQDQ_BIT\t\t(1U << 1)\n#define\t_MOVBE_BIT\t\t(1U << 22)\n#define\t_SHA_NI_BIT\t\t(1U << 29)\n\n \nstatic const cpuid_feature_desc_t cpuid_features[] = {\n\t[SSE]\t\t= {1U, 0U,\t1U << 25,\tEDX\t},\n\t[SSE2]\t\t= {1U, 0U,\t1U << 26,\tEDX\t},\n\t[SSE3]\t\t= {1U, 0U,\t1U << 0,\tECX\t},\n\t[SSSE3]\t\t= {1U, 0U,\t1U << 9,\tECX\t},\n\t[SSE4_1]\t= {1U, 0U,\t1U << 19,\tECX\t},\n\t[SSE4_2]\t= {1U, 0U,\t1U << 20,\tECX\t},\n\t[OSXSAVE]\t= {1U, 0U,\t1U << 27,\tECX\t},\n\t[AVX]\t\t= {1U, 0U,\t1U << 28,\tECX\t},\n\t[AVX2]\t\t= {7U, 0U,\t1U << 5,\tEBX\t},\n\t[BMI1]\t\t= {7U, 0U,\t1U << 3,\tEBX\t},\n\t[BMI2]\t\t= {7U, 0U,\t1U << 8,\tEBX\t},\n\t[AVX512F]\t= {7U, 0U, _AVX512F_BIT,\tEBX\t},\n\t[AVX512CD]\t= {7U, 0U, _AVX512CD_BIT,\tEBX\t},\n\t[AVX512DQ]\t= {7U, 0U, _AVX512DQ_BIT,\tEBX\t},\n\t[AVX512BW]\t= {7U, 0U, _AVX512BW_BIT,\tEBX\t},\n\t[AVX512IFMA]\t= {7U, 0U, _AVX512IFMA_BIT,\tEBX\t},\n\t[AVX512VBMI]\t= {7U, 0U, _AVX512VBMI_BIT,\tECX\t},\n\t[AVX512PF]\t= {7U, 0U, _AVX512PF_BIT,\tEBX\t},\n\t[AVX512ER]\t= {7U, 0U, _AVX512ER_BIT,\tEBX\t},\n\t[AVX512VL]\t= {7U, 0U, _AVX512ER_BIT,\tEBX\t},\n\t[AES]\t\t= {1U, 0U, _AES_BIT,\t\tECX\t},\n\t[PCLMULQDQ]\t= {1U, 0U, _PCLMULQDQ_BIT,\tECX\t},\n\t[MOVBE]\t\t= {1U, 0U, _MOVBE_BIT,\t\tECX\t},\n\t[SHA_NI]\t= {7U, 0U, _SHA_NI_BIT,\t\tEBX\t},\n};\n\n \nstatic inline uint64_t\nxgetbv(uint32_t index)\n{\n\tuint32_t eax, edx;\n\t \n\t__asm__ __volatile__(\".byte 0x0f; .byte 0x01; .byte 0xd0\"\n\t    : \"=a\" (eax), \"=d\" (edx)\n\t    : \"c\" (index));\n\n\treturn ((((uint64_t)edx)<<32) | (uint64_t)eax);\n}\n\n \nstatic inline boolean_t\n__cpuid_check_feature(const cpuid_feature_desc_t *desc)\n{\n\tuint32_t r[CPUID_REG_CNT];\n\n\tif (__get_cpuid_max(0, NULL) >= desc->leaf) {\n\t\t \n\t\t__cpuid_count(desc->leaf, desc->subleaf,\n\t\t    r[EAX], r[EBX], r[ECX], r[EDX]);\n\t\treturn ((r[desc->reg] & desc->flag) == desc->flag);\n\t}\n\treturn (B_FALSE);\n}\n\n#define\tCPUID_FEATURE_CHECK(name, id)\t\t\t\t\\\nstatic inline boolean_t\t\t\t\t\t\t\\\n__cpuid_has_ ## name(void)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn (__cpuid_check_feature(&cpuid_features[id]));\t\\\n}\n\n \nCPUID_FEATURE_CHECK(sse, SSE);\nCPUID_FEATURE_CHECK(sse2, SSE2);\nCPUID_FEATURE_CHECK(sse3, SSE3);\nCPUID_FEATURE_CHECK(ssse3, SSSE3);\nCPUID_FEATURE_CHECK(sse4_1, SSE4_1);\nCPUID_FEATURE_CHECK(sse4_2, SSE4_2);\nCPUID_FEATURE_CHECK(avx, AVX);\nCPUID_FEATURE_CHECK(avx2, AVX2);\nCPUID_FEATURE_CHECK(osxsave, OSXSAVE);\nCPUID_FEATURE_CHECK(bmi1, BMI1);\nCPUID_FEATURE_CHECK(bmi2, BMI2);\nCPUID_FEATURE_CHECK(avx512f, AVX512F);\nCPUID_FEATURE_CHECK(avx512cd, AVX512CD);\nCPUID_FEATURE_CHECK(avx512dq, AVX512DQ);\nCPUID_FEATURE_CHECK(avx512bw, AVX512BW);\nCPUID_FEATURE_CHECK(avx512ifma, AVX512IFMA);\nCPUID_FEATURE_CHECK(avx512vbmi, AVX512VBMI);\nCPUID_FEATURE_CHECK(avx512pf, AVX512PF);\nCPUID_FEATURE_CHECK(avx512er, AVX512ER);\nCPUID_FEATURE_CHECK(avx512vl, AVX512VL);\nCPUID_FEATURE_CHECK(aes, AES);\nCPUID_FEATURE_CHECK(pclmulqdq, PCLMULQDQ);\nCPUID_FEATURE_CHECK(movbe, MOVBE);\nCPUID_FEATURE_CHECK(shani, SHA_NI);\n\n \nstatic inline boolean_t\n__simd_state_enabled(const uint64_t state)\n{\n\tboolean_t has_osxsave;\n\tuint64_t xcr0;\n\n\thas_osxsave = __cpuid_has_osxsave();\n\tif (!has_osxsave)\n\t\treturn (B_FALSE);\n\n\txcr0 = xgetbv(0);\n\treturn ((xcr0 & state) == state);\n}\n\n#define\t_XSTATE_SSE_AVX\t\t(0x2 | 0x4)\n#define\t_XSTATE_AVX512\t\t(0xE0 | _XSTATE_SSE_AVX)\n\n#define\t__ymm_enabled()\t\t__simd_state_enabled(_XSTATE_SSE_AVX)\n#define\t__zmm_enabled()\t\t__simd_state_enabled(_XSTATE_AVX512)\n\n \nstatic inline boolean_t\nzfs_sse_available(void)\n{\n\treturn (__cpuid_has_sse());\n}\n\n \nstatic inline boolean_t\nzfs_sse2_available(void)\n{\n\treturn (__cpuid_has_sse2());\n}\n\n \nstatic inline boolean_t\nzfs_sse3_available(void)\n{\n\treturn (__cpuid_has_sse3());\n}\n\n \nstatic inline boolean_t\nzfs_ssse3_available(void)\n{\n\treturn (__cpuid_has_ssse3());\n}\n\n \nstatic inline boolean_t\nzfs_sse4_1_available(void)\n{\n\treturn (__cpuid_has_sse4_1());\n}\n\n \nstatic inline boolean_t\nzfs_sse4_2_available(void)\n{\n\treturn (__cpuid_has_sse4_2());\n}\n\n \nstatic inline boolean_t\nzfs_avx_available(void)\n{\n\treturn (__cpuid_has_avx() && __ymm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx2_available(void)\n{\n\treturn (__cpuid_has_avx2() && __ymm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_bmi1_available(void)\n{\n\treturn (__cpuid_has_bmi1());\n}\n\n \nstatic inline boolean_t\nzfs_bmi2_available(void)\n{\n\treturn (__cpuid_has_bmi2());\n}\n\n \nstatic inline boolean_t\nzfs_aes_available(void)\n{\n\treturn (__cpuid_has_aes());\n}\n\n \nstatic inline boolean_t\nzfs_pclmulqdq_available(void)\n{\n\treturn (__cpuid_has_pclmulqdq());\n}\n\n \nstatic inline boolean_t\nzfs_movbe_available(void)\n{\n\treturn (__cpuid_has_movbe());\n}\n\n \nstatic inline boolean_t\nzfs_shani_available(void)\n{\n\treturn (__cpuid_has_shani());\n}\n\n \n\n \nstatic inline boolean_t\nzfs_avx512f_available(void)\n{\n\treturn (__cpuid_has_avx512f() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512cd_available(void)\n{\n\treturn (__cpuid_has_avx512cd() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512er_available(void)\n{\n\treturn (__cpuid_has_avx512er() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512pf_available(void)\n{\n\treturn (__cpuid_has_avx512pf() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512bw_available(void)\n{\n\treturn (__cpuid_has_avx512bw() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512dq_available(void)\n{\n\treturn (__cpuid_has_avx512dq() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512vl_available(void)\n{\n\treturn (__cpuid_has_avx512vl() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512ifma_available(void)\n{\n\treturn (__cpuid_has_avx512ifma() && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512vbmi_available(void)\n{\n\treturn (__cpuid_has_avx512f() && __cpuid_has_avx512vbmi() &&\n\t    __zmm_enabled());\n}\n\n#elif defined(__arm__)\n\n#define\tkfpu_allowed()\t\t1\n#define\tkfpu_initialize(tsk)\tdo {} while (0)\n#define\tkfpu_begin()\t\tdo {} while (0)\n#define\tkfpu_end()\t\tdo {} while (0)\n\n#define\tHWCAP_NEON\t\t0x00001000\n#define\tHWCAP2_SHA2\t\t0x00000008\n\n \nstatic inline boolean_t\nzfs_neon_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & HWCAP_NEON);\n}\n\n \nstatic inline boolean_t\nzfs_sha256_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & HWCAP2_SHA2);\n}\n\n#elif defined(__aarch64__)\n\n#define\tkfpu_allowed()\t\t1\n#define\tkfpu_initialize(tsk)\tdo {} while (0)\n#define\tkfpu_begin()\t\tdo {} while (0)\n#define\tkfpu_end()\t\tdo {} while (0)\n\n#define\tHWCAP_FP\t\t0x00000001\n#define\tHWCAP_SHA2\t\t0x00000040\n#define\tHWCAP_SHA512\t\t0x00200000\n\n \nstatic inline boolean_t\nzfs_neon_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & HWCAP_FP);\n}\n\n \nstatic inline boolean_t\nzfs_sha256_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & HWCAP_SHA2);\n}\n\n \nstatic inline boolean_t\nzfs_sha512_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & HWCAP_SHA512);\n}\n\n#elif defined(__powerpc__)\n\n#define\tkfpu_allowed()\t\t0\n#define\tkfpu_initialize(tsk)\tdo {} while (0)\n#define\tkfpu_begin()\t\tdo {} while (0)\n#define\tkfpu_end()\t\tdo {} while (0)\n\n#define\tPPC_FEATURE_HAS_ALTIVEC\t0x10000000\n#define\tPPC_FEATURE_HAS_VSX\t0x00000080\n#define\tPPC_FEATURE2_ARCH_2_07\t0x80000000\n\nstatic inline boolean_t\nzfs_altivec_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & PPC_FEATURE_HAS_ALTIVEC);\n}\n\nstatic inline boolean_t\nzfs_vsx_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\treturn (hwcap & PPC_FEATURE_HAS_VSX);\n}\n\nstatic inline boolean_t\nzfs_isa207_available(void)\n{\n\tunsigned long hwcap = getauxval(AT_HWCAP);\n\tunsigned long hwcap2 = getauxval(AT_HWCAP2);\n\treturn ((hwcap & PPC_FEATURE_HAS_VSX) &&\n\t    (hwcap2 & PPC_FEATURE2_ARCH_2_07));\n}\n\n#else\n\n#define\tkfpu_allowed()\t\t0\n#define\tkfpu_initialize(tsk)\tdo {} while (0)\n#define\tkfpu_begin()\t\tdo {} while (0)\n#define\tkfpu_end()\t\tdo {} while (0)\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}