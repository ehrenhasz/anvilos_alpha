{
  "module_name": "libzfs_core.c",
  "hash_id": "e65e9e0db6ae1235a7d9dcac4b39232098fb7929ab908cfb76cb86100ed793e1",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfs_core/libzfs_core.c",
  "human_readable_source": " \n\n \n\n \n\n#include <libzfs_core.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef ZFS_DEBUG\n#include <stdio.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <libzutil.h>\n#include <sys/nvpair.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/zfs_ioctl.h>\n#if __FreeBSD__\n#define\tBIG_PIPE_SIZE (64 * 1024)  \n#endif\n\nstatic int g_fd = -1;\nstatic pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic int g_refcount;\n\n#ifdef ZFS_DEBUG\nstatic zfs_ioc_t fail_ioc_cmd = ZFS_IOC_LAST;\nstatic zfs_errno_t fail_ioc_err;\n\nstatic void\nlibzfs_core_debug_ioc(void)\n{\n\t \n\tif (fail_ioc_cmd == ZFS_IOC_LAST) {\n\t\tchar *ioc_test = getenv(\"ZFS_IOC_TEST\");\n\t\tunsigned int ioc_num = 0, ioc_err = 0;\n\n\t\tif (ioc_test != NULL &&\n\t\t    sscanf(ioc_test, \"%i:%i\", &ioc_num, &ioc_err) == 2 &&\n\t\t    ioc_num < ZFS_IOC_LAST)  {\n\t\t\tfail_ioc_cmd = ioc_num;\n\t\t\tfail_ioc_err = ioc_err;\n\t\t}\n\t}\n}\n#endif\n\nint\nlibzfs_core_init(void)\n{\n\t(void) pthread_mutex_lock(&g_lock);\n\tif (g_refcount == 0) {\n\t\tg_fd = open(ZFS_DEV, O_RDWR|O_CLOEXEC);\n\t\tif (g_fd < 0) {\n\t\t\t(void) pthread_mutex_unlock(&g_lock);\n\t\t\treturn (errno);\n\t\t}\n\t}\n\tg_refcount++;\n\n#ifdef ZFS_DEBUG\n\tlibzfs_core_debug_ioc();\n#endif\n\t(void) pthread_mutex_unlock(&g_lock);\n\treturn (0);\n}\n\nvoid\nlibzfs_core_fini(void)\n{\n\t(void) pthread_mutex_lock(&g_lock);\n\tASSERT3S(g_refcount, >, 0);\n\n\tg_refcount--;\n\n\tif (g_refcount == 0 && g_fd != -1) {\n\t\t(void) close(g_fd);\n\t\tg_fd = -1;\n\t}\n\t(void) pthread_mutex_unlock(&g_lock);\n}\n\nstatic int\nlzc_ioctl(zfs_ioc_t ioc, const char *name,\n    nvlist_t *source, nvlist_t **resultp)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint error = 0;\n\tchar *packed = NULL;\n\tsize_t size = 0;\n\n\tASSERT3S(g_refcount, >, 0);\n\tVERIFY3S(g_fd, !=, -1);\n\n#ifdef ZFS_DEBUG\n\tif (ioc == fail_ioc_cmd)\n\t\treturn (fail_ioc_err);\n#endif\n\n\tif (name != NULL)\n\t\t(void) strlcpy(zc.zc_name, name, sizeof (zc.zc_name));\n\n\tif (source != NULL) {\n\t\tpacked = fnvlist_pack(source, &size);\n\t\tzc.zc_nvlist_src = (uint64_t)(uintptr_t)packed;\n\t\tzc.zc_nvlist_src_size = size;\n\t}\n\n\tif (resultp != NULL) {\n\t\t*resultp = NULL;\n\t\tif (ioc == ZFS_IOC_CHANNEL_PROGRAM) {\n\t\t\tzc.zc_nvlist_dst_size = fnvlist_lookup_uint64(source,\n\t\t\t    ZCP_ARG_MEMLIMIT);\n\t\t} else {\n\t\t\tzc.zc_nvlist_dst_size = MAX(size * 2, 128 * 1024);\n\t\t}\n\t\tzc.zc_nvlist_dst = (uint64_t)(uintptr_t)\n\t\t    malloc(zc.zc_nvlist_dst_size);\n\t\tif (zc.zc_nvlist_dst == (uint64_t)0) {\n\t\t\terror = ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (lzc_ioctl_fd(g_fd, ioc, &zc) != 0) {\n\t\t \n\t\tif (errno == ENOMEM && resultp != NULL &&\n\t\t    ioc != ZFS_IOC_CHANNEL_PROGRAM) {\n\t\t\tfree((void *)(uintptr_t)zc.zc_nvlist_dst);\n\t\t\tzc.zc_nvlist_dst_size *= 2;\n\t\t\tzc.zc_nvlist_dst = (uint64_t)(uintptr_t)\n\t\t\t    malloc(zc.zc_nvlist_dst_size);\n\t\t\tif (zc.zc_nvlist_dst == (uint64_t)0) {\n\t\t\t\terror = ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\terror = errno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (zc.zc_nvlist_dst_filled && resultp != NULL) {\n\t\t*resultp = fnvlist_unpack((void *)(uintptr_t)zc.zc_nvlist_dst,\n\t\t    zc.zc_nvlist_dst_size);\n\t}\n\nout:\n\tif (packed != NULL)\n\t\tfnvlist_pack_free(packed, size);\n\tfree((void *)(uintptr_t)zc.zc_nvlist_dst);\n\treturn (error);\n}\n\nint\nlzc_scrub(zfs_ioc_t ioc, const char *name,\n    nvlist_t *source, nvlist_t **resultp)\n{\n\treturn (lzc_ioctl(ioc, name, source, resultp));\n}\n\nint\nlzc_create(const char *fsname, enum lzc_dataset_type type, nvlist_t *props,\n    uint8_t *wkeydata, uint_t wkeylen)\n{\n\tint error;\n\tnvlist_t *hidden_args = NULL;\n\tnvlist_t *args = fnvlist_alloc();\n\n\tfnvlist_add_int32(args, \"type\", (dmu_objset_type_t)type);\n\tif (props != NULL)\n\t\tfnvlist_add_nvlist(args, \"props\", props);\n\n\tif (wkeydata != NULL) {\n\t\thidden_args = fnvlist_alloc();\n\t\tfnvlist_add_uint8_array(hidden_args, \"wkeydata\", wkeydata,\n\t\t    wkeylen);\n\t\tfnvlist_add_nvlist(args, ZPOOL_HIDDEN_ARGS, hidden_args);\n\t}\n\n\terror = lzc_ioctl(ZFS_IOC_CREATE, fsname, args, NULL);\n\tnvlist_free(hidden_args);\n\tnvlist_free(args);\n\treturn (error);\n}\n\nint\nlzc_clone(const char *fsname, const char *origin, nvlist_t *props)\n{\n\tint error;\n\tnvlist_t *hidden_args = NULL;\n\tnvlist_t *args = fnvlist_alloc();\n\n\tfnvlist_add_string(args, \"origin\", origin);\n\tif (props != NULL)\n\t\tfnvlist_add_nvlist(args, \"props\", props);\n\terror = lzc_ioctl(ZFS_IOC_CLONE, fsname, args, NULL);\n\tnvlist_free(hidden_args);\n\tnvlist_free(args);\n\treturn (error);\n}\n\nint\nlzc_promote(const char *fsname, char *snapnamebuf, int snapnamelen)\n{\n\t \n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tASSERT3S(g_refcount, >, 0);\n\tVERIFY3S(g_fd, !=, -1);\n\n\t(void) strlcpy(zc.zc_name, fsname, sizeof (zc.zc_name));\n\tif (lzc_ioctl_fd(g_fd, ZFS_IOC_PROMOTE, &zc) != 0) {\n\t\tint error = errno;\n\t\tif (error == EEXIST && snapnamebuf != NULL)\n\t\t\t(void) strlcpy(snapnamebuf, zc.zc_string, snapnamelen);\n\t\treturn (error);\n\t}\n\treturn (0);\n}\n\nint\nlzc_rename(const char *source, const char *target)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint error;\n\n\tASSERT3S(g_refcount, >, 0);\n\tVERIFY3S(g_fd, !=, -1);\n\t(void) strlcpy(zc.zc_name, source, sizeof (zc.zc_name));\n\t(void) strlcpy(zc.zc_value, target, sizeof (zc.zc_value));\n\terror = lzc_ioctl_fd(g_fd, ZFS_IOC_RENAME, &zc);\n\tif (error != 0)\n\t\terror = errno;\n\treturn (error);\n}\n\nint\nlzc_destroy(const char *fsname)\n{\n\tint error;\n\tnvlist_t *args = fnvlist_alloc();\n\terror = lzc_ioctl(ZFS_IOC_DESTROY, fsname, args, NULL);\n\tnvlist_free(args);\n\treturn (error);\n}\n\n \nint\nlzc_snapshot(nvlist_t *snaps, nvlist_t *props, nvlist_t **errlist)\n{\n\tnvpair_t *elem;\n\tnvlist_t *args;\n\tint error;\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\n\t*errlist = NULL;\n\n\t \n\telem = nvlist_next_nvpair(snaps, NULL);\n\tif (elem == NULL)\n\t\treturn (0);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/@\")] = '\\0';\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_nvlist(args, \"snaps\", snaps);\n\tif (props != NULL)\n\t\tfnvlist_add_nvlist(args, \"props\", props);\n\n\terror = lzc_ioctl(ZFS_IOC_SNAPSHOT, pool, args, errlist);\n\tnvlist_free(args);\n\n\treturn (error);\n}\n\n \nint\nlzc_destroy_snaps(nvlist_t *snaps, boolean_t defer, nvlist_t **errlist)\n{\n\tnvpair_t *elem;\n\tnvlist_t *args;\n\tint error;\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\n\t \n\telem = nvlist_next_nvpair(snaps, NULL);\n\tif (elem == NULL)\n\t\treturn (0);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/@\")] = '\\0';\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_nvlist(args, \"snaps\", snaps);\n\tif (defer)\n\t\tfnvlist_add_boolean(args, \"defer\");\n\n\terror = lzc_ioctl(ZFS_IOC_DESTROY_SNAPS, pool, args, errlist);\n\tnvlist_free(args);\n\n\treturn (error);\n}\n\nint\nlzc_snaprange_space(const char *firstsnap, const char *lastsnap,\n    uint64_t *usedp)\n{\n\tnvlist_t *args;\n\tnvlist_t *result;\n\tint err;\n\tchar fs[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *atp;\n\n\t \n\t(void) strlcpy(fs, firstsnap, sizeof (fs));\n\tatp = strchr(fs, '@');\n\tif (atp == NULL)\n\t\treturn (EINVAL);\n\t*atp = '\\0';\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_string(args, \"firstsnap\", firstsnap);\n\n\terr = lzc_ioctl(ZFS_IOC_SPACE_SNAPS, lastsnap, args, &result);\n\tnvlist_free(args);\n\tif (err == 0)\n\t\t*usedp = fnvlist_lookup_uint64(result, \"used\");\n\tfnvlist_free(result);\n\n\treturn (err);\n}\n\nboolean_t\nlzc_exists(const char *dataset)\n{\n\t \n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tASSERT3S(g_refcount, >, 0);\n\tVERIFY3S(g_fd, !=, -1);\n\n\t(void) strlcpy(zc.zc_name, dataset, sizeof (zc.zc_name));\n\treturn (lzc_ioctl_fd(g_fd, ZFS_IOC_OBJSET_STATS, &zc) == 0);\n}\n\n \nint\nlzc_sync(const char *pool_name, nvlist_t *innvl, nvlist_t **outnvl)\n{\n\t(void) outnvl;\n\treturn (lzc_ioctl(ZFS_IOC_POOL_SYNC, pool_name, innvl, NULL));\n}\n\n \nint\nlzc_hold(nvlist_t *holds, int cleanup_fd, nvlist_t **errlist)\n{\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\tnvlist_t *args;\n\tnvpair_t *elem;\n\tint error;\n\n\t \n\telem = nvlist_next_nvpair(holds, NULL);\n\tif (elem == NULL)\n\t\treturn (0);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/@\")] = '\\0';\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_nvlist(args, \"holds\", holds);\n\tif (cleanup_fd != -1)\n\t\tfnvlist_add_int32(args, \"cleanup_fd\", cleanup_fd);\n\n\terror = lzc_ioctl(ZFS_IOC_HOLD, pool, args, errlist);\n\tnvlist_free(args);\n\treturn (error);\n}\n\n \nint\nlzc_release(nvlist_t *holds, nvlist_t **errlist)\n{\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\tnvpair_t *elem;\n\n\t \n\telem = nvlist_next_nvpair(holds, NULL);\n\tif (elem == NULL)\n\t\treturn (0);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/@\")] = '\\0';\n\n\treturn (lzc_ioctl(ZFS_IOC_RELEASE, pool, holds, errlist));\n}\n\n \nint\nlzc_get_holds(const char *snapname, nvlist_t **holdsp)\n{\n\treturn (lzc_ioctl(ZFS_IOC_GET_HOLDS, snapname, NULL, holdsp));\n}\n\nstatic unsigned int\nmax_pipe_buffer(int infd)\n{\n#if __linux__\n\tstatic unsigned int max;\n\tif (max == 0) {\n\t\tmax = 1048576;  \n\n\t\tFILE *procf = fopen(\"/proc/sys/fs/pipe-max-size\", \"re\");\n\t\tif (procf != NULL) {\n\t\t\tif (fscanf(procf, \"%u\", &max) <= 0) {\n\t\t\t\t \n\t\t\t}\n\t\t\tfclose(procf);\n\t\t}\n\t}\n\n\tunsigned int cur = fcntl(infd, F_GETPIPE_SZ);\n\t \n\tif (getenv(\"ZFS_SET_PIPE_MAX\") == NULL)\n\t\treturn (cur);\n\tif (cur < max && fcntl(infd, F_SETPIPE_SZ, max) != -1)\n\t\tcur = max;\n\treturn (cur);\n#else\n\t \n\t(void) infd;\n\treturn (BIG_PIPE_SIZE);\n#endif\n}\n\n#if __linux__\nstruct send_worker_ctx {\n\tint from;\t \n\tint to;\t\t \n};\n\nstatic void *\nsend_worker(void *arg)\n{\n\tstruct send_worker_ctx *ctx = arg;\n\tunsigned int bufsiz = max_pipe_buffer(ctx->from);\n\tssize_t rd;\n\n\tfor (;;) {\n\t\trd = splice(ctx->from, NULL, ctx->to, NULL, bufsiz,\n\t\t    SPLICE_F_MOVE | SPLICE_F_MORE);\n\t\tif ((rd == -1 && errno != EINTR) || rd == 0)\n\t\t\tbreak;\n\t}\n\tint err = (rd == -1) ? errno : 0;\n\tclose(ctx->from);\n\treturn ((void *)(uintptr_t)err);\n}\n#endif\n\n \nint\nlzc_send_wrapper(int (*func)(int, void *), int orig_fd, void *data)\n{\n#if __linux__\n\tstruct stat sb;\n\tif (orig_fd != -1 && fstat(orig_fd, &sb) == -1)\n\t\treturn (errno);\n\tif (orig_fd == -1 || S_ISFIFO(sb.st_mode)) {\n\t\tif (orig_fd != -1)\n\t\t\t(void) max_pipe_buffer(orig_fd);\n\t\treturn (func(orig_fd, data));\n\t}\n\tif ((fcntl(orig_fd, F_GETFL) & O_ACCMODE) == O_RDONLY)\n\t\treturn (errno = EBADF);\n\n\tint rw[2];\n\tif (pipe2(rw, O_CLOEXEC) == -1)\n\t\treturn (errno);\n\n\tint err;\n\tpthread_t send_thread;\n\tstruct send_worker_ctx ctx = {.from = rw[0], .to = orig_fd};\n\tif ((err = pthread_create(&send_thread, NULL, send_worker, &ctx))\n\t    != 0) {\n\t\tclose(rw[0]);\n\t\tclose(rw[1]);\n\t\treturn (errno = err);\n\t}\n\n\terr = func(rw[1], data);\n\n\tvoid *send_err;\n\tclose(rw[1]);\n\tpthread_join(send_thread, &send_err);\n\tif (err == 0 && send_err != 0)\n\t\terrno = err = (uintptr_t)send_err;\n\n\treturn (err);\n#else\n\treturn (func(orig_fd, data));\n#endif\n}\n\n \nint\nlzc_send(const char *snapname, const char *from, int fd,\n    enum lzc_send_flags flags)\n{\n\treturn (lzc_send_resume_redacted(snapname, from, fd, flags, 0, 0,\n\t    NULL));\n}\n\nint\nlzc_send_redacted(const char *snapname, const char *from, int fd,\n    enum lzc_send_flags flags, const char *redactbook)\n{\n\treturn (lzc_send_resume_redacted(snapname, from, fd, flags, 0, 0,\n\t    redactbook));\n}\n\nint\nlzc_send_resume(const char *snapname, const char *from, int fd,\n    enum lzc_send_flags flags, uint64_t resumeobj, uint64_t resumeoff)\n{\n\treturn (lzc_send_resume_redacted(snapname, from, fd, flags, resumeobj,\n\t    resumeoff, NULL));\n}\n\n \nstatic int\nlzc_send_resume_redacted_cb_impl(const char *snapname, const char *from, int fd,\n    enum lzc_send_flags flags, uint64_t resumeobj, uint64_t resumeoff,\n    const char *redactbook)\n{\n\tnvlist_t *args;\n\tint err;\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_int32(args, \"fd\", fd);\n\tif (from != NULL)\n\t\tfnvlist_add_string(args, \"fromsnap\", from);\n\tif (flags & LZC_SEND_FLAG_LARGE_BLOCK)\n\t\tfnvlist_add_boolean(args, \"largeblockok\");\n\tif (flags & LZC_SEND_FLAG_EMBED_DATA)\n\t\tfnvlist_add_boolean(args, \"embedok\");\n\tif (flags & LZC_SEND_FLAG_COMPRESS)\n\t\tfnvlist_add_boolean(args, \"compressok\");\n\tif (flags & LZC_SEND_FLAG_RAW)\n\t\tfnvlist_add_boolean(args, \"rawok\");\n\tif (flags & LZC_SEND_FLAG_SAVED)\n\t\tfnvlist_add_boolean(args, \"savedok\");\n\tif (resumeobj != 0 || resumeoff != 0) {\n\t\tfnvlist_add_uint64(args, \"resume_object\", resumeobj);\n\t\tfnvlist_add_uint64(args, \"resume_offset\", resumeoff);\n\t}\n\tif (redactbook != NULL)\n\t\tfnvlist_add_string(args, \"redactbook\", redactbook);\n\n\terr = lzc_ioctl(ZFS_IOC_SEND_NEW, snapname, args, NULL);\n\tnvlist_free(args);\n\treturn (err);\n}\n\nstruct lzc_send_resume_redacted {\n\tconst char *snapname;\n\tconst char *from;\n\tenum lzc_send_flags flags;\n\tuint64_t resumeobj;\n\tuint64_t resumeoff;\n\tconst char *redactbook;\n};\n\nstatic int\nlzc_send_resume_redacted_cb(int fd, void *arg)\n{\n\tstruct lzc_send_resume_redacted *zsrr = arg;\n\treturn (lzc_send_resume_redacted_cb_impl(zsrr->snapname, zsrr->from,\n\t    fd, zsrr->flags, zsrr->resumeobj, zsrr->resumeoff,\n\t    zsrr->redactbook));\n}\n\nint\nlzc_send_resume_redacted(const char *snapname, const char *from, int fd,\n    enum lzc_send_flags flags, uint64_t resumeobj, uint64_t resumeoff,\n    const char *redactbook)\n{\n\tstruct lzc_send_resume_redacted zsrr = {\n\t\t.snapname = snapname,\n\t\t.from = from,\n\t\t.flags = flags,\n\t\t.resumeobj = resumeobj,\n\t\t.resumeoff = resumeoff,\n\t\t.redactbook = redactbook,\n\t};\n\treturn (lzc_send_wrapper(lzc_send_resume_redacted_cb, fd, &zsrr));\n}\n\n \nstatic int\nlzc_send_space_resume_redacted_cb_impl(const char *snapname, const char *from,\n    enum lzc_send_flags flags, uint64_t resumeobj, uint64_t resumeoff,\n    uint64_t resume_bytes, const char *redactbook, int fd, uint64_t *spacep)\n{\n\tnvlist_t *args;\n\tnvlist_t *result;\n\tint err;\n\n\targs = fnvlist_alloc();\n\tif (from != NULL)\n\t\tfnvlist_add_string(args, \"from\", from);\n\tif (flags & LZC_SEND_FLAG_LARGE_BLOCK)\n\t\tfnvlist_add_boolean(args, \"largeblockok\");\n\tif (flags & LZC_SEND_FLAG_EMBED_DATA)\n\t\tfnvlist_add_boolean(args, \"embedok\");\n\tif (flags & LZC_SEND_FLAG_COMPRESS)\n\t\tfnvlist_add_boolean(args, \"compressok\");\n\tif (flags & LZC_SEND_FLAG_RAW)\n\t\tfnvlist_add_boolean(args, \"rawok\");\n\tif (resumeobj != 0 || resumeoff != 0) {\n\t\tfnvlist_add_uint64(args, \"resume_object\", resumeobj);\n\t\tfnvlist_add_uint64(args, \"resume_offset\", resumeoff);\n\t\tfnvlist_add_uint64(args, \"bytes\", resume_bytes);\n\t}\n\tif (redactbook != NULL)\n\t\tfnvlist_add_string(args, \"redactbook\", redactbook);\n\tif (fd != -1)\n\t\tfnvlist_add_int32(args, \"fd\", fd);\n\n\terr = lzc_ioctl(ZFS_IOC_SEND_SPACE, snapname, args, &result);\n\tnvlist_free(args);\n\tif (err == 0)\n\t\t*spacep = fnvlist_lookup_uint64(result, \"space\");\n\tnvlist_free(result);\n\treturn (err);\n}\n\nstruct lzc_send_space_resume_redacted {\n\tconst char *snapname;\n\tconst char *from;\n\tenum lzc_send_flags flags;\n\tuint64_t resumeobj;\n\tuint64_t resumeoff;\n\tuint64_t resume_bytes;\n\tconst char *redactbook;\n\tuint64_t *spacep;\n};\n\nstatic int\nlzc_send_space_resume_redacted_cb(int fd, void *arg)\n{\n\tstruct lzc_send_space_resume_redacted *zssrr = arg;\n\treturn (lzc_send_space_resume_redacted_cb_impl(zssrr->snapname,\n\t    zssrr->from, zssrr->flags, zssrr->resumeobj, zssrr->resumeoff,\n\t    zssrr->resume_bytes, zssrr->redactbook, fd, zssrr->spacep));\n}\n\nint\nlzc_send_space_resume_redacted(const char *snapname, const char *from,\n    enum lzc_send_flags flags, uint64_t resumeobj, uint64_t resumeoff,\n    uint64_t resume_bytes, const char *redactbook, int fd, uint64_t *spacep)\n{\n\tstruct lzc_send_space_resume_redacted zssrr = {\n\t\t.snapname = snapname,\n\t\t.from = from,\n\t\t.flags = flags,\n\t\t.resumeobj = resumeobj,\n\t\t.resumeoff = resumeoff,\n\t\t.resume_bytes = resume_bytes,\n\t\t.redactbook = redactbook,\n\t\t.spacep = spacep,\n\t};\n\treturn (lzc_send_wrapper(lzc_send_space_resume_redacted_cb,\n\t    fd, &zssrr));\n}\n\nint\nlzc_send_space(const char *snapname, const char *from,\n    enum lzc_send_flags flags, uint64_t *spacep)\n{\n\treturn (lzc_send_space_resume_redacted(snapname, from, flags, 0, 0, 0,\n\t    NULL, -1, spacep));\n}\n\nstatic int\nrecv_read(int fd, void *buf, int ilen)\n{\n\tchar *cp = buf;\n\tint rv;\n\tint len = ilen;\n\n\tdo {\n\t\trv = read(fd, cp, len);\n\t\tcp += rv;\n\t\tlen -= rv;\n\t} while (rv > 0);\n\n\tif (rv < 0 || len != 0)\n\t\treturn (EIO);\n\n\treturn (0);\n}\n\n \nstatic int\nrecv_impl(const char *snapname, nvlist_t *recvdprops, nvlist_t *localprops,\n    uint8_t *wkeydata, uint_t wkeylen, const char *origin, boolean_t force,\n    boolean_t heal, boolean_t resumable, boolean_t raw, int input_fd,\n    const dmu_replay_record_t *begin_record, uint64_t *read_bytes,\n    uint64_t *errflags, nvlist_t **errors)\n{\n\tdmu_replay_record_t drr;\n\tchar fsname[MAXPATHLEN];\n\tchar *atp;\n\tint error;\n\tboolean_t payload = B_FALSE;\n\n\tASSERT3S(g_refcount, >, 0);\n\tVERIFY3S(g_fd, !=, -1);\n\n\t \n\t(void) strlcpy(fsname, snapname, sizeof (fsname));\n\tatp = strchr(fsname, '@');\n\tif (atp == NULL)\n\t\treturn (EINVAL);\n\t*atp = '\\0';\n\n\t \n\tif (!lzc_exists(fsname)) {\n\t\tchar *slashp = strrchr(fsname, '/');\n\t\tif (slashp == NULL)\n\t\t\treturn (ENOENT);\n\t\t*slashp = '\\0';\n\t}\n\n\t \n\tstruct stat sb;\n\tif (fstat(input_fd, &sb) == -1)\n\t\treturn (errno);\n\tif (S_ISFIFO(sb.st_mode))\n\t\t(void) max_pipe_buffer(input_fd);\n\n\t \n\tif (begin_record == NULL) {\n\t\terror = recv_read(input_fd, &drr, sizeof (drr));\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t} else {\n\t\tdrr = *begin_record;\n\t\tpayload = (begin_record->drr_payloadlen != 0);\n\t}\n\n\t \n\tif (resumable || heal || raw || wkeydata != NULL || payload) {\n\t\tnvlist_t *outnvl = NULL;\n\t\tnvlist_t *innvl = fnvlist_alloc();\n\n\t\tfnvlist_add_string(innvl, \"snapname\", snapname);\n\n\t\tif (recvdprops != NULL)\n\t\t\tfnvlist_add_nvlist(innvl, \"props\", recvdprops);\n\n\t\tif (localprops != NULL)\n\t\t\tfnvlist_add_nvlist(innvl, \"localprops\", localprops);\n\n\t\tif (wkeydata != NULL) {\n\t\t\t \n\t\t\tnvlist_t *hidden_args = fnvlist_alloc();\n\t\t\tfnvlist_add_uint8_array(hidden_args, \"wkeydata\",\n\t\t\t    wkeydata, wkeylen);\n\t\t\tfnvlist_add_nvlist(innvl, ZPOOL_HIDDEN_ARGS,\n\t\t\t    hidden_args);\n\t\t\tnvlist_free(hidden_args);\n\t\t}\n\n\t\tif (origin != NULL && strlen(origin))\n\t\t\tfnvlist_add_string(innvl, \"origin\", origin);\n\n\t\tfnvlist_add_byte_array(innvl, \"begin_record\",\n\t\t    (uchar_t *)&drr, sizeof (drr));\n\n\t\tfnvlist_add_int32(innvl, \"input_fd\", input_fd);\n\n\t\tif (force)\n\t\t\tfnvlist_add_boolean(innvl, \"force\");\n\n\t\tif (resumable)\n\t\t\tfnvlist_add_boolean(innvl, \"resumable\");\n\n\t\tif (heal)\n\t\t\tfnvlist_add_boolean(innvl, \"heal\");\n\n\t\terror = lzc_ioctl(ZFS_IOC_RECV_NEW, fsname, innvl, &outnvl);\n\n\t\tif (error == 0 && read_bytes != NULL)\n\t\t\terror = nvlist_lookup_uint64(outnvl, \"read_bytes\",\n\t\t\t    read_bytes);\n\n\t\tif (error == 0 && errflags != NULL)\n\t\t\terror = nvlist_lookup_uint64(outnvl, \"error_flags\",\n\t\t\t    errflags);\n\n\t\tif (error == 0 && errors != NULL) {\n\t\t\tnvlist_t *nvl;\n\t\t\terror = nvlist_lookup_nvlist(outnvl, \"errors\", &nvl);\n\t\t\tif (error == 0)\n\t\t\t\t*errors = fnvlist_dup(nvl);\n\t\t}\n\n\t\tfnvlist_free(innvl);\n\t\tfnvlist_free(outnvl);\n\t} else {\n\t\tzfs_cmd_t zc = {\"\\0\"};\n\t\tchar *rp_packed = NULL;\n\t\tchar *lp_packed = NULL;\n\t\tsize_t size;\n\n\t\tASSERT3S(g_refcount, >, 0);\n\n\t\t(void) strlcpy(zc.zc_name, fsname, sizeof (zc.zc_name));\n\t\t(void) strlcpy(zc.zc_value, snapname, sizeof (zc.zc_value));\n\n\t\tif (recvdprops != NULL) {\n\t\t\trp_packed = fnvlist_pack(recvdprops, &size);\n\t\t\tzc.zc_nvlist_src = (uint64_t)(uintptr_t)rp_packed;\n\t\t\tzc.zc_nvlist_src_size = size;\n\t\t}\n\n\t\tif (localprops != NULL) {\n\t\t\tlp_packed = fnvlist_pack(localprops, &size);\n\t\t\tzc.zc_nvlist_conf = (uint64_t)(uintptr_t)lp_packed;\n\t\t\tzc.zc_nvlist_conf_size = size;\n\t\t}\n\n\t\tif (origin != NULL)\n\t\t\t(void) strlcpy(zc.zc_string, origin,\n\t\t\t    sizeof (zc.zc_string));\n\n\t\tASSERT3S(drr.drr_type, ==, DRR_BEGIN);\n\t\tzc.zc_begin_record = drr.drr_u.drr_begin;\n\t\tzc.zc_guid = force;\n\t\tzc.zc_cookie = input_fd;\n\t\tzc.zc_cleanup_fd = -1;\n\t\tzc.zc_action_handle = 0;\n\n\t\tzc.zc_nvlist_dst_size = 128 * 1024;\n\t\tzc.zc_nvlist_dst = (uint64_t)(uintptr_t)\n\t\t    malloc(zc.zc_nvlist_dst_size);\n\n\t\terror = lzc_ioctl_fd(g_fd, ZFS_IOC_RECV, &zc);\n\t\tif (error != 0) {\n\t\t\terror = errno;\n\t\t} else {\n\t\t\tif (read_bytes != NULL)\n\t\t\t\t*read_bytes = zc.zc_cookie;\n\n\t\t\tif (errflags != NULL)\n\t\t\t\t*errflags = zc.zc_obj;\n\n\t\t\tif (errors != NULL)\n\t\t\t\tVERIFY0(nvlist_unpack(\n\t\t\t\t    (void *)(uintptr_t)zc.zc_nvlist_dst,\n\t\t\t\t    zc.zc_nvlist_dst_size, errors, KM_SLEEP));\n\t\t}\n\n\t\tif (rp_packed != NULL)\n\t\t\tfnvlist_pack_free(rp_packed, size);\n\t\tif (lp_packed != NULL)\n\t\t\tfnvlist_pack_free(lp_packed, size);\n\t\tfree((void *)(uintptr_t)zc.zc_nvlist_dst);\n\t}\n\n\treturn (error);\n}\n\n \nint\nlzc_receive(const char *snapname, nvlist_t *props, const char *origin,\n    boolean_t force, boolean_t raw, int fd)\n{\n\treturn (recv_impl(snapname, props, NULL, NULL, 0, origin, force,\n\t    B_FALSE, B_FALSE, raw, fd, NULL, NULL, NULL, NULL));\n}\n\n \nint\nlzc_receive_resumable(const char *snapname, nvlist_t *props, const char *origin,\n    boolean_t force, boolean_t raw, int fd)\n{\n\treturn (recv_impl(snapname, props, NULL, NULL, 0, origin, force,\n\t    B_FALSE, B_TRUE, raw, fd, NULL, NULL, NULL, NULL));\n}\n\n \nint\nlzc_receive_with_header(const char *snapname, nvlist_t *props,\n    const char *origin, boolean_t force, boolean_t resumable, boolean_t raw,\n    int fd, const dmu_replay_record_t *begin_record)\n{\n\tif (begin_record == NULL)\n\t\treturn (EINVAL);\n\n\treturn (recv_impl(snapname, props, NULL, NULL, 0, origin, force,\n\t    B_FALSE, resumable, raw, fd, begin_record, NULL, NULL, NULL));\n}\n\n \nint\nlzc_receive_one(const char *snapname, nvlist_t *props,\n    const char *origin, boolean_t force, boolean_t resumable, boolean_t raw,\n    int input_fd, const dmu_replay_record_t *begin_record, int cleanup_fd,\n    uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle,\n    nvlist_t **errors)\n{\n\t(void) action_handle, (void) cleanup_fd;\n\treturn (recv_impl(snapname, props, NULL, NULL, 0, origin, force,\n\t    B_FALSE, resumable, raw, input_fd, begin_record,\n\t    read_bytes, errflags, errors));\n}\n\n \nint\nlzc_receive_with_cmdprops(const char *snapname, nvlist_t *props,\n    nvlist_t *cmdprops, uint8_t *wkeydata, uint_t wkeylen, const char *origin,\n    boolean_t force, boolean_t resumable, boolean_t raw, int input_fd,\n    const dmu_replay_record_t *begin_record, int cleanup_fd,\n    uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle,\n    nvlist_t **errors)\n{\n\t(void) action_handle, (void) cleanup_fd;\n\treturn (recv_impl(snapname, props, cmdprops, wkeydata, wkeylen, origin,\n\t    force, B_FALSE, resumable, raw, input_fd, begin_record,\n\t    read_bytes, errflags, errors));\n}\n\n \nint lzc_receive_with_heal(const char *snapname, nvlist_t *props,\n    nvlist_t *cmdprops, uint8_t *wkeydata, uint_t wkeylen, const char *origin,\n    boolean_t force, boolean_t heal, boolean_t resumable, boolean_t raw,\n    int input_fd, const dmu_replay_record_t *begin_record, int cleanup_fd,\n    uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle,\n    nvlist_t **errors)\n{\n\t(void) action_handle, (void) cleanup_fd;\n\treturn (recv_impl(snapname, props, cmdprops, wkeydata, wkeylen, origin,\n\t    force, heal, resumable, raw, input_fd, begin_record,\n\t    read_bytes, errflags, errors));\n}\n\n \nint\nlzc_rollback(const char *fsname, char *snapnamebuf, int snapnamelen)\n{\n\tnvlist_t *args;\n\tnvlist_t *result;\n\tint err;\n\n\targs = fnvlist_alloc();\n\terr = lzc_ioctl(ZFS_IOC_ROLLBACK, fsname, args, &result);\n\tnvlist_free(args);\n\tif (err == 0 && snapnamebuf != NULL) {\n\t\tconst char *snapname = fnvlist_lookup_string(result, \"target\");\n\t\t(void) strlcpy(snapnamebuf, snapname, snapnamelen);\n\t}\n\tnvlist_free(result);\n\n\treturn (err);\n}\n\n \nint\nlzc_rollback_to(const char *fsname, const char *snapname)\n{\n\tnvlist_t *args;\n\tnvlist_t *result;\n\tint err;\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_string(args, \"target\", snapname);\n\terr = lzc_ioctl(ZFS_IOC_ROLLBACK, fsname, args, &result);\n\tnvlist_free(args);\n\tnvlist_free(result);\n\treturn (err);\n}\n\n \nint\nlzc_bookmark(nvlist_t *bookmarks, nvlist_t **errlist)\n{\n\tnvpair_t *elem;\n\tint error;\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\n\t \n\telem = nvlist_next_nvpair(bookmarks, NULL);\n\tif (elem == NULL)\n\t\treturn (0);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/#\")] = '\\0';\n\n\terror = lzc_ioctl(ZFS_IOC_BOOKMARK, pool, bookmarks, errlist);\n\n\treturn (error);\n}\n\n \nint\nlzc_get_bookmarks(const char *fsname, nvlist_t *props, nvlist_t **bmarks)\n{\n\treturn (lzc_ioctl(ZFS_IOC_GET_BOOKMARKS, fsname, props, bmarks));\n}\n\n \nint\nlzc_get_bookmark_props(const char *bookmark, nvlist_t **props)\n{\n\tint error;\n\n\tnvlist_t *innvl = fnvlist_alloc();\n\terror = lzc_ioctl(ZFS_IOC_GET_BOOKMARK_PROPS, bookmark, innvl, props);\n\tfnvlist_free(innvl);\n\n\treturn (error);\n}\n\n \nint\nlzc_destroy_bookmarks(nvlist_t *bmarks, nvlist_t **errlist)\n{\n\tnvpair_t *elem;\n\tint error;\n\tchar pool[ZFS_MAX_DATASET_NAME_LEN];\n\n\t \n\telem = nvlist_next_nvpair(bmarks, NULL);\n\tif (elem == NULL)\n\t\treturn (0);\n\t(void) strlcpy(pool, nvpair_name(elem), sizeof (pool));\n\tpool[strcspn(pool, \"/#\")] = '\\0';\n\n\terror = lzc_ioctl(ZFS_IOC_DESTROY_BOOKMARKS, pool, bmarks, errlist);\n\n\treturn (error);\n}\n\nstatic int\nlzc_channel_program_impl(const char *pool, const char *program, boolean_t sync,\n    uint64_t instrlimit, uint64_t memlimit, nvlist_t *argnvl, nvlist_t **outnvl)\n{\n\tint error;\n\tnvlist_t *args;\n\n\targs = fnvlist_alloc();\n\tfnvlist_add_string(args, ZCP_ARG_PROGRAM, program);\n\tfnvlist_add_nvlist(args, ZCP_ARG_ARGLIST, argnvl);\n\tfnvlist_add_boolean_value(args, ZCP_ARG_SYNC, sync);\n\tfnvlist_add_uint64(args, ZCP_ARG_INSTRLIMIT, instrlimit);\n\tfnvlist_add_uint64(args, ZCP_ARG_MEMLIMIT, memlimit);\n\terror = lzc_ioctl(ZFS_IOC_CHANNEL_PROGRAM, pool, args, outnvl);\n\tfnvlist_free(args);\n\n\treturn (error);\n}\n\n \nint\nlzc_channel_program(const char *pool, const char *program, uint64_t instrlimit,\n    uint64_t memlimit, nvlist_t *argnvl, nvlist_t **outnvl)\n{\n\treturn (lzc_channel_program_impl(pool, program, B_TRUE, instrlimit,\n\t    memlimit, argnvl, outnvl));\n}\n\n \nint\nlzc_pool_checkpoint(const char *pool)\n{\n\tint error;\n\n\tnvlist_t *result = NULL;\n\tnvlist_t *args = fnvlist_alloc();\n\n\terror = lzc_ioctl(ZFS_IOC_POOL_CHECKPOINT, pool, args, &result);\n\n\tfnvlist_free(args);\n\tfnvlist_free(result);\n\n\treturn (error);\n}\n\n \nint\nlzc_pool_checkpoint_discard(const char *pool)\n{\n\tint error;\n\n\tnvlist_t *result = NULL;\n\tnvlist_t *args = fnvlist_alloc();\n\n\terror = lzc_ioctl(ZFS_IOC_POOL_DISCARD_CHECKPOINT, pool, args, &result);\n\n\tfnvlist_free(args);\n\tfnvlist_free(result);\n\n\treturn (error);\n}\n\n \nint\nlzc_channel_program_nosync(const char *pool, const char *program,\n    uint64_t timeout, uint64_t memlimit, nvlist_t *argnvl, nvlist_t **outnvl)\n{\n\treturn (lzc_channel_program_impl(pool, program, B_FALSE, timeout,\n\t    memlimit, argnvl, outnvl));\n}\n\nint\nlzc_get_vdev_prop(const char *poolname, nvlist_t *innvl, nvlist_t **outnvl)\n{\n\treturn (lzc_ioctl(ZFS_IOC_VDEV_GET_PROPS, poolname, innvl, outnvl));\n}\n\nint\nlzc_set_vdev_prop(const char *poolname, nvlist_t *innvl, nvlist_t **outnvl)\n{\n\treturn (lzc_ioctl(ZFS_IOC_VDEV_SET_PROPS, poolname, innvl, outnvl));\n}\n\n \nint\nlzc_load_key(const char *fsname, boolean_t noop, uint8_t *wkeydata,\n    uint_t wkeylen)\n{\n\tint error;\n\tnvlist_t *ioc_args;\n\tnvlist_t *hidden_args;\n\n\tif (wkeydata == NULL)\n\t\treturn (EINVAL);\n\n\tioc_args = fnvlist_alloc();\n\thidden_args = fnvlist_alloc();\n\tfnvlist_add_uint8_array(hidden_args, \"wkeydata\", wkeydata, wkeylen);\n\tfnvlist_add_nvlist(ioc_args, ZPOOL_HIDDEN_ARGS, hidden_args);\n\tif (noop)\n\t\tfnvlist_add_boolean(ioc_args, \"noop\");\n\terror = lzc_ioctl(ZFS_IOC_LOAD_KEY, fsname, ioc_args, NULL);\n\tnvlist_free(hidden_args);\n\tnvlist_free(ioc_args);\n\n\treturn (error);\n}\n\nint\nlzc_unload_key(const char *fsname)\n{\n\treturn (lzc_ioctl(ZFS_IOC_UNLOAD_KEY, fsname, NULL, NULL));\n}\n\nint\nlzc_change_key(const char *fsname, uint64_t crypt_cmd, nvlist_t *props,\n    uint8_t *wkeydata, uint_t wkeylen)\n{\n\tint error;\n\tnvlist_t *ioc_args = fnvlist_alloc();\n\tnvlist_t *hidden_args = NULL;\n\n\tfnvlist_add_uint64(ioc_args, \"crypt_cmd\", crypt_cmd);\n\n\tif (wkeydata != NULL) {\n\t\thidden_args = fnvlist_alloc();\n\t\tfnvlist_add_uint8_array(hidden_args, \"wkeydata\", wkeydata,\n\t\t    wkeylen);\n\t\tfnvlist_add_nvlist(ioc_args, ZPOOL_HIDDEN_ARGS, hidden_args);\n\t}\n\n\tif (props != NULL)\n\t\tfnvlist_add_nvlist(ioc_args, \"props\", props);\n\n\terror = lzc_ioctl(ZFS_IOC_CHANGE_KEY, fsname, ioc_args, NULL);\n\tnvlist_free(hidden_args);\n\tnvlist_free(ioc_args);\n\n\treturn (error);\n}\n\nint\nlzc_reopen(const char *pool_name, boolean_t scrub_restart)\n{\n\tnvlist_t *args = fnvlist_alloc();\n\tint error;\n\n\tfnvlist_add_boolean_value(args, \"scrub_restart\", scrub_restart);\n\n\terror = lzc_ioctl(ZFS_IOC_POOL_REOPEN, pool_name, args, NULL);\n\tnvlist_free(args);\n\treturn (error);\n}\n\n \nint\nlzc_initialize(const char *poolname, pool_initialize_func_t cmd_type,\n    nvlist_t *vdevs, nvlist_t **errlist)\n{\n\tint error;\n\n\tnvlist_t *args = fnvlist_alloc();\n\tfnvlist_add_uint64(args, ZPOOL_INITIALIZE_COMMAND, (uint64_t)cmd_type);\n\tfnvlist_add_nvlist(args, ZPOOL_INITIALIZE_VDEVS, vdevs);\n\n\terror = lzc_ioctl(ZFS_IOC_POOL_INITIALIZE, poolname, args, errlist);\n\n\tfnvlist_free(args);\n\n\treturn (error);\n}\n\n \nint\nlzc_trim(const char *poolname, pool_trim_func_t cmd_type, uint64_t rate,\n    boolean_t secure, nvlist_t *vdevs, nvlist_t **errlist)\n{\n\tint error;\n\n\tnvlist_t *args = fnvlist_alloc();\n\tfnvlist_add_uint64(args, ZPOOL_TRIM_COMMAND, (uint64_t)cmd_type);\n\tfnvlist_add_nvlist(args, ZPOOL_TRIM_VDEVS, vdevs);\n\tfnvlist_add_uint64(args, ZPOOL_TRIM_RATE, rate);\n\tfnvlist_add_boolean_value(args, ZPOOL_TRIM_SECURE, secure);\n\n\terror = lzc_ioctl(ZFS_IOC_POOL_TRIM, poolname, args, errlist);\n\n\tfnvlist_free(args);\n\n\treturn (error);\n}\n\n \nint\nlzc_redact(const char *snapshot, const char *bookname, nvlist_t *snapnv)\n{\n\tnvlist_t *args = fnvlist_alloc();\n\tfnvlist_add_string(args, \"bookname\", bookname);\n\tfnvlist_add_nvlist(args, \"snapnv\", snapnv);\n\tint error = lzc_ioctl(ZFS_IOC_REDACT, snapshot, args, NULL);\n\tfnvlist_free(args);\n\treturn (error);\n}\n\nstatic int\nwait_common(const char *pool, zpool_wait_activity_t activity, boolean_t use_tag,\n    uint64_t tag, boolean_t *waited)\n{\n\tnvlist_t *args = fnvlist_alloc();\n\tnvlist_t *result = NULL;\n\n\tfnvlist_add_int32(args, ZPOOL_WAIT_ACTIVITY, activity);\n\tif (use_tag)\n\t\tfnvlist_add_uint64(args, ZPOOL_WAIT_TAG, tag);\n\n\tint error = lzc_ioctl(ZFS_IOC_WAIT, pool, args, &result);\n\n\tif (error == 0 && waited != NULL)\n\t\t*waited = fnvlist_lookup_boolean_value(result,\n\t\t    ZPOOL_WAIT_WAITED);\n\n\tfnvlist_free(args);\n\tfnvlist_free(result);\n\n\treturn (error);\n}\n\nint\nlzc_wait(const char *pool, zpool_wait_activity_t activity, boolean_t *waited)\n{\n\treturn (wait_common(pool, activity, B_FALSE, 0, waited));\n}\n\nint\nlzc_wait_tag(const char *pool, zpool_wait_activity_t activity, uint64_t tag,\n    boolean_t *waited)\n{\n\treturn (wait_common(pool, activity, B_TRUE, tag, waited));\n}\n\nint\nlzc_wait_fs(const char *fs, zfs_wait_activity_t activity, boolean_t *waited)\n{\n\tnvlist_t *args = fnvlist_alloc();\n\tnvlist_t *result = NULL;\n\n\tfnvlist_add_int32(args, ZFS_WAIT_ACTIVITY, activity);\n\n\tint error = lzc_ioctl(ZFS_IOC_WAIT_FS, fs, args, &result);\n\n\tif (error == 0 && waited != NULL)\n\t\t*waited = fnvlist_lookup_boolean_value(result,\n\t\t    ZFS_WAIT_WAITED);\n\n\tfnvlist_free(args);\n\tfnvlist_free(result);\n\n\treturn (error);\n}\n\n \nint\nlzc_set_bootenv(const char *pool, const nvlist_t *env)\n{\n\treturn (lzc_ioctl(ZFS_IOC_SET_BOOTENV, pool, (nvlist_t *)env, NULL));\n}\n\n \nint\nlzc_get_bootenv(const char *pool, nvlist_t **outnvl)\n{\n\treturn (lzc_ioctl(ZFS_IOC_GET_BOOTENV, pool, NULL, outnvl));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}