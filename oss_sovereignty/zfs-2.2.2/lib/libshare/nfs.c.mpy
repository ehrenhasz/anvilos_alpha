{
  "module_name": "nfs.c",
  "hash_id": "5f27ff2270e8b34d666031e044a32bf63baa7a963f95f5a414868ec319cb9803",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libshare/nfs.c",
  "human_readable_source": " \n\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <errno.h>\n#include <libshare.h>\n#include <unistd.h>\n#include \"nfs.h\"\n\n\n \nstatic int\nnfs_exports_lock(const char *name, int *nfs_lock_fd)\n{\n\tint err;\n\n\t*nfs_lock_fd = open(name, O_RDWR | O_CREAT | O_CLOEXEC, 0600);\n\tif (*nfs_lock_fd == -1) {\n\t\terr = errno;\n\t\tfprintf(stderr, \"failed to lock %s: %s\\n\", name, strerror(err));\n\t\treturn (err);\n\t}\n\n\twhile ((err = flock(*nfs_lock_fd, LOCK_EX)) != 0 && errno == EINTR)\n\t\t;\n\tif (err != 0) {\n\t\terr = errno;\n\t\tfprintf(stderr, \"failed to lock %s: %s\\n\", name, strerror(err));\n\t\t(void) close(*nfs_lock_fd);\n\t\t*nfs_lock_fd = -1;\n\t\treturn (err);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nnfs_exports_unlock(const char *name, int *nfs_lock_fd)\n{\n\tverify(*nfs_lock_fd > 0);\n\n\tif (flock(*nfs_lock_fd, LOCK_UN) != 0)\n\t\tfprintf(stderr, \"failed to unlock %s: %s\\n\",\n\t\t    name, strerror(errno));\n\n\t(void) close(*nfs_lock_fd);\n\t*nfs_lock_fd = -1;\n}\n\nstruct tmpfile {\n\t \n\tchar name[64];\n\tFILE *fp;\n};\n\nstatic boolean_t\nnfs_init_tmpfile(const char *prefix, const char *mdir, struct tmpfile *tmpf)\n{\n\tif (mdir != NULL &&\n\t    mkdir(mdir, 0755) < 0 &&\n\t    errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s: %s\\n\",\n\t\t\n\t\t    mdir, strerror(errno));\n\t\treturn (B_FALSE);\n\t}\n\n\tstrlcpy(tmpf->name, prefix, sizeof (tmpf->name));\n\tstrlcat(tmpf->name, \".XXXXXXXX\", sizeof (tmpf->name));\n\n\tint fd = mkostemp(tmpf->name, O_CLOEXEC);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Unable to create temporary file: %s\",\n\t\t    strerror(errno));\n\t\treturn (B_FALSE);\n\t}\n\n\ttmpf->fp = fdopen(fd, \"w+\");\n\tif (tmpf->fp == NULL) {\n\t\tfprintf(stderr, \"Unable to reopen temporary file: %s\",\n\t\t    strerror(errno));\n\t\tclose(fd);\n\t\treturn (B_FALSE);\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic void\nnfs_abort_tmpfile(struct tmpfile *tmpf)\n{\n\tunlink(tmpf->name);\n\tfclose(tmpf->fp);\n}\n\nstatic int\nnfs_fini_tmpfile(const char *exports, struct tmpfile *tmpf)\n{\n\tif (fflush(tmpf->fp) != 0) {\n\t\tfprintf(stderr, \"Failed to write to temporary file: %s\\n\",\n\t\t    strerror(errno));\n\t\tnfs_abort_tmpfile(tmpf);\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\tif (rename(tmpf->name, exports) == -1) {\n\t\tfprintf(stderr, \"Unable to rename %s -> %s: %s\\n\",\n\t\t    tmpf->name, exports, strerror(errno));\n\t\tnfs_abort_tmpfile(tmpf);\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\t(void) fchmod(fileno(tmpf->fp), 0644);\n\tfclose(tmpf->fp);\n\treturn (SA_OK);\n}\n\nint\nnfs_escape_mountpoint(const char *mp, char **out, boolean_t *need_free)\n{\n\tif (strpbrk(mp, \"\\t\\n\\v\\f\\r \\\\\") == NULL) {\n\t\t*out = (char *)mp;\n\t\t*need_free = B_FALSE;\n\t\treturn (SA_OK);\n\t} else {\n\t\tsize_t len = strlen(mp);\n\t\t*out = malloc(len * 4 + 1);\n\t\tif (!*out)\n\t\t\treturn (SA_NO_MEMORY);\n\t\t*need_free = B_TRUE;\n\n\t\tchar *oc = *out;\n\t\tfor (const char *c = mp; c < mp + len; ++c)\n\t\t\tif (memchr(\"\\t\\n\\v\\f\\r \\\\\", *c,\n\t\t\t    strlen(\"\\t\\n\\v\\f\\r \\\\\"))) {\n\t\t\t\tsprintf(oc, \"\\\\%03hho\", *c);\n\t\t\t\toc += 4;\n\t\t\t} else\n\t\t\t\t*oc++ = *c;\n\t\t*oc = '\\0';\n\t}\n\n\treturn (SA_OK);\n}\n\nstatic int\nnfs_process_exports(const char *exports, const char *mountpoint,\n    boolean_t (*cbk)(void *userdata, char *line, boolean_t found_mountpoint),\n    void *userdata)\n{\n\tint error = SA_OK;\n\tboolean_t cont = B_TRUE;\n\n\tFILE *oldfp = fopen(exports, \"re\");\n\tif (oldfp != NULL) {\n\t\tboolean_t need_mp_free;\n\t\tchar *mp;\n\t\tif ((error = nfs_escape_mountpoint(mountpoint,\n\t\t    &mp, &need_mp_free)) != SA_OK) {\n\t\t\t(void) fclose(oldfp);\n\t\t\treturn (error);\n\t\t}\n\n\t\tchar *buf = NULL, *sep;\n\t\tsize_t buflen = 0, mplen = strlen(mp);\n\n\t\twhile (cont && getline(&buf, &buflen, oldfp) != -1) {\n\t\t\tif (buf[0] == '\\n' || buf[0] == '#')\n\t\t\t\tcontinue;\n\n\t\t\tcont = cbk(userdata, buf,\n\t\t\t    (sep = strpbrk(buf, \"\\t \\n\")) != NULL &&\n\t\t\t    sep - buf == mplen &&\n\t\t\t    strncmp(buf, mp, mplen) == 0);\n\t\t}\n\t\tfree(buf);\n\t\tif (need_mp_free)\n\t\t\tfree(mp);\n\n\t\tif (ferror(oldfp) != 0)\n\t\t\terror = ferror(oldfp);\n\n\t\tif (fclose(oldfp) != 0) {\n\t\t\tfprintf(stderr, \"Unable to close file %s: %s\\n\",\n\t\t\t    exports, strerror(errno));\n\t\t\terror = error != SA_OK ? error : SA_SYSTEM_ERR;\n\t\t}\n\t}\n\n\treturn (error);\n}\n\nstatic boolean_t\nnfs_copy_entries_cb(void *userdata, char *line, boolean_t found_mountpoint)\n{\n\tFILE *newfp = userdata;\n\tif (!found_mountpoint)\n\t\tfputs(line, newfp);\n\treturn (B_TRUE);\n}\n\n \nstatic int\nnfs_copy_entries(FILE *newfp, const char *exports, const char *mountpoint)\n{\n\tfputs(FILE_HEADER, newfp);\n\n\tint error = nfs_process_exports(\n\t    exports, mountpoint, nfs_copy_entries_cb, newfp);\n\n\tif (error == SA_OK && ferror(newfp) != 0)\n\t\terror = ferror(newfp);\n\n\treturn (error);\n}\n\nint\nnfs_toggle_share(const char *lockfile, const char *exports,\n    const char *expdir, sa_share_impl_t impl_share,\n    int(*cbk)(sa_share_impl_t impl_share, FILE *tmpfile))\n{\n\tint error, nfs_lock_fd = -1;\n\tstruct tmpfile tmpf;\n\n\tif (!nfs_init_tmpfile(exports, expdir, &tmpf))\n\t\treturn (SA_SYSTEM_ERR);\n\n\terror = nfs_exports_lock(lockfile, &nfs_lock_fd);\n\tif (error != 0) {\n\t\tnfs_abort_tmpfile(&tmpf);\n\t\treturn (error);\n\t}\n\n\terror = nfs_copy_entries(tmpf.fp, exports, impl_share->sa_mountpoint);\n\tif (error != SA_OK)\n\t\tgoto fullerr;\n\n\terror = cbk(impl_share, tmpf.fp);\n\tif (error != SA_OK)\n\t\tgoto fullerr;\n\n\terror = nfs_fini_tmpfile(exports, &tmpf);\n\tnfs_exports_unlock(lockfile, &nfs_lock_fd);\n\treturn (error);\n\nfullerr:\n\tnfs_abort_tmpfile(&tmpf);\n\tnfs_exports_unlock(lockfile, &nfs_lock_fd);\n\treturn (error);\n}\n\nvoid\nnfs_reset_shares(const char *lockfile, const char *exports)\n{\n\tint nfs_lock_fd = -1;\n\n\tif (nfs_exports_lock(lockfile, &nfs_lock_fd) == 0) {\n\t\t(void) ! truncate(exports, 0);\n\t\tnfs_exports_unlock(lockfile, &nfs_lock_fd);\n\t}\n}\n\nstatic boolean_t\nnfs_is_shared_cb(void *userdata, char *line, boolean_t found_mountpoint)\n{\n\t(void) line;\n\n\tboolean_t *found = userdata;\n\t*found = found_mountpoint;\n\treturn (!found_mountpoint);\n}\n\nboolean_t\nnfs_is_shared_impl(const char *exports, sa_share_impl_t impl_share)\n{\n\tboolean_t found = B_FALSE;\n\tnfs_process_exports(exports, impl_share->sa_mountpoint,\n\t    nfs_is_shared_cb, &found);\n\treturn (found);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}