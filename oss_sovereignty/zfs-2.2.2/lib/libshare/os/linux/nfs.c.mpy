{
  "module_name": "nfs.c",
  "hash_id": "64b4e219f61aa86131aa22d9547a138c33841d201735e1644f6dc5997f0592d5",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libshare/os/linux/nfs.c",
  "human_readable_source": " \n\n \n\n#include <dirent.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <libzfs.h>\n#include <libshare.h>\n#include \"libshare_impl.h\"\n#include \"nfs.h\"\n\n#define\tZFS_EXPORTS_DIR\t\t\"/etc/exports.d\"\n#define\tZFS_EXPORTS_FILE\tZFS_EXPORTS_DIR\"/zfs.exports\"\n#define\tZFS_EXPORTS_LOCK\tZFS_EXPORTS_FILE\".lock\"\n\n\nstatic boolean_t nfs_available(void);\n\ntypedef int (*nfs_shareopt_callback_t)(const char *opt, const char *value,\n    void *cookie);\n\ntypedef int (*nfs_host_callback_t)(FILE *tmpfile, const char *sharepath,\n    const char *host, const char *security, const char *access, void *cookie);\n\n \nstatic int\nforeach_nfs_shareopt(const char *shareopts,\n    nfs_shareopt_callback_t callback, void *cookie)\n{\n\tchar *shareopts_dup, *opt, *cur, *value;\n\tint was_nul, error;\n\n\tif (shareopts == NULL)\n\t\treturn (SA_OK);\n\n\tif (strcmp(shareopts, \"on\") == 0)\n\t\tshareopts = \"rw,crossmnt\";\n\n\tshareopts_dup = strdup(shareopts);\n\n\n\tif (shareopts_dup == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\topt = shareopts_dup;\n\twas_nul = 0;\n\n\twhile (1) {\n\t\tcur = opt;\n\n\t\twhile (*cur != ',' && *cur != '\\0')\n\t\t\tcur++;\n\n\t\tif (*cur == '\\0')\n\t\t\twas_nul = 1;\n\n\t\t*cur = '\\0';\n\n\t\tif (cur > opt) {\n\t\t\tvalue = strchr(opt, '=');\n\n\t\t\tif (value != NULL) {\n\t\t\t\t*value = '\\0';\n\t\t\t\tvalue++;\n\t\t\t}\n\n\t\t\terror = callback(opt, value, cookie);\n\n\t\t\tif (error != SA_OK) {\n\t\t\t\tfree(shareopts_dup);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\topt = cur + 1;\n\n\t\tif (was_nul)\n\t\t\tbreak;\n\t}\n\n\tfree(shareopts_dup);\n\n\treturn (SA_OK);\n}\n\ntypedef struct nfs_host_cookie_s {\n\tnfs_host_callback_t callback;\n\tconst char *sharepath;\n\tvoid *cookie;\n\tFILE *tmpfile;\n\tconst char *security;\n} nfs_host_cookie_t;\n\n \nstatic int\nforeach_nfs_host_cb(const char *opt, const char *value, void *pcookie)\n{\n\tint error;\n\tconst char *access;\n\tchar *host_dup, *host, *next, *v6Literal;\n\tnfs_host_cookie_t *udata = (nfs_host_cookie_t *)pcookie;\n\tint cidr_len;\n\n#ifdef DEBUG\n\tfprintf(stderr, \"foreach_nfs_host_cb: key=%s, value=%s\\n\", opt, value);\n#endif\n\n\tif (strcmp(opt, \"sec\") == 0)\n\t\tudata->security = value;\n\n\tif (strcmp(opt, \"rw\") == 0 || strcmp(opt, \"ro\") == 0) {\n\t\tif (value == NULL)\n\t\t\tvalue = \"*\";\n\n\t\taccess = opt;\n\n\t\thost_dup = strdup(value);\n\n\t\tif (host_dup == NULL)\n\t\t\treturn (SA_NO_MEMORY);\n\n\t\thost = host_dup;\n\n\t\tdo {\n\t\t\tif (*host == '[') {\n\t\t\t\thost++;\n\t\t\t\tv6Literal = strchr(host, ']');\n\t\t\t\tif (v6Literal == NULL) {\n\t\t\t\t\tfree(host_dup);\n\t\t\t\t\treturn (SA_SYNTAX_ERR);\n\t\t\t\t}\n\t\t\t\tif (v6Literal[1] == '\\0') {\n\t\t\t\t\t*v6Literal = '\\0';\n\t\t\t\t\tnext = NULL;\n\t\t\t\t} else if (v6Literal[1] == '/') {\n\t\t\t\t\tnext = strchr(v6Literal + 2, ':');\n\t\t\t\t\tif (next == NULL) {\n\t\t\t\t\t\tcidr_len =\n\t\t\t\t\t\t    strlen(v6Literal + 1);\n\t\t\t\t\t\tmemmove(v6Literal,\n\t\t\t\t\t\t    v6Literal + 1,\n\t\t\t\t\t\t    cidr_len);\n\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcidr_len = next - v6Literal - 1;\n\t\t\t\t\t\tmemmove(v6Literal,\n\t\t\t\t\t\t    v6Literal + 1,\n\t\t\t\t\t\t    cidr_len);\n\t\t\t\t\t\tv6Literal[cidr_len] = '\\0';\n\t\t\t\t\t\tnext++;\n\t\t\t\t\t}\n\t\t\t\t} else if (v6Literal[1] == ':') {\n\t\t\t\t\t*v6Literal = '\\0';\n\t\t\t\t\tnext = v6Literal + 2;\n\t\t\t\t} else {\n\t\t\t\t\tfree(host_dup);\n\t\t\t\t\treturn (SA_SYNTAX_ERR);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = strchr(host, ':');\n\t\t\t\tif (next != NULL) {\n\t\t\t\t\t*next = '\\0';\n\t\t\t\t\tnext++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terror = udata->callback(udata->tmpfile,\n\t\t\t    udata->sharepath, host, udata->security,\n\t\t\t    access, udata->cookie);\n\n\t\t\tif (error != SA_OK) {\n\t\t\t\tfree(host_dup);\n\n\t\t\t\treturn (error);\n\t\t\t}\n\n\t\t\thost = next;\n\t\t} while (host != NULL);\n\n\t\tfree(host_dup);\n\t}\n\n\treturn (SA_OK);\n}\n\n \nstatic int\nforeach_nfs_host(sa_share_impl_t impl_share, FILE *tmpfile,\n    nfs_host_callback_t callback, void *cookie)\n{\n\tnfs_host_cookie_t udata;\n\n\tudata.callback = callback;\n\tudata.sharepath = impl_share->sa_mountpoint;\n\tudata.cookie = cookie;\n\tudata.tmpfile = tmpfile;\n\tudata.security = \"sys\";\n\n\treturn (foreach_nfs_shareopt(impl_share->sa_shareopts,\n\t    foreach_nfs_host_cb, &udata));\n}\n\n \nstatic const char *\nget_linux_hostspec(const char *solaris_hostspec)\n{\n\t \n\tif (solaris_hostspec[0] == '@') {\n\t\t \n\t\treturn (solaris_hostspec + 1);\n\t} else {\n\t\treturn (solaris_hostspec);\n\t}\n}\n\n \nstatic int\nadd_linux_shareopt(char **plinux_opts, const char *key, const char *value)\n{\n\tsize_t len = 0;\n\tchar *new_linux_opts;\n\n\tif (*plinux_opts != NULL)\n\t\tlen = strlen(*plinux_opts);\n\n\tnew_linux_opts = realloc(*plinux_opts, len + 1 + strlen(key) +\n\t    (value ? 1 + strlen(value) : 0) + 1);\n\n\tif (new_linux_opts == NULL)\n\t\treturn (SA_NO_MEMORY);\n\n\tnew_linux_opts[len] = '\\0';\n\n\tif (len > 0)\n\t\tstrcat(new_linux_opts, \",\");\n\n\tstrcat(new_linux_opts, key);\n\n\tif (value != NULL) {\n\t\tstrcat(new_linux_opts, \"=\");\n\t\tstrcat(new_linux_opts, value);\n\t}\n\n\t*plinux_opts = new_linux_opts;\n\n\treturn (SA_OK);\n}\n\nstatic int string_cmp(const void *lhs, const void *rhs) {\n\tconst char *const *l = lhs, *const *r = rhs;\n\treturn (strcmp(*l, *r));\n}\n\n \nstatic int\nget_linux_shareopts_cb(const char *key, const char *value, void *cookie)\n{\n\t \n\tstatic const char *const valid_keys[] = { \"all_squash\", \"anongid\",\n\t    \"anonuid\", \"async\", \"auth_nlm\", \"crossmnt\", \"fsid\", \"fsuid\", \"hide\",\n\t    \"insecure\", \"insecure_locks\", \"mountpoint\", \"mp\", \"no_acl\",\n\t    \"no_all_squash\", \"no_auth_nlm\", \"no_root_squash\",\n\t    \"no_subtree_check\", \"no_wdelay\", \"nohide\", \"refer\", \"replicas\",\n\t    \"root_squash\", \"secure\", \"secure_locks\", \"subtree_check\", \"sync\",\n\t    \"wdelay\" };\n\n\tchar **plinux_opts = (char **)cookie;\n\tchar *host, *val_dup, *literal, *next;\n\n\tif (strcmp(key, \"sec\") == 0)\n\t\treturn (SA_OK);\n\n\tif (strcmp(key, \"ro\") == 0 || strcmp(key, \"rw\") == 0) {\n\t\tif (value == NULL || strlen(value) == 0)\n\t\t\treturn (SA_OK);\n\t\tval_dup = strdup(value);\n\t\thost = val_dup;\n\t\tif (host == NULL)\n\t\t\treturn (SA_NO_MEMORY);\n\t\tdo {\n\t\t\tif (*host == '[') {\n\t\t\t\thost++;\n\t\t\t\tliteral = strchr(host, ']');\n\t\t\t\tif (literal == NULL) {\n\t\t\t\t\tfree(val_dup);\n\t\t\t\t\treturn (SA_SYNTAX_ERR);\n\t\t\t\t}\n\t\t\t\tif (literal[1] == '\\0')\n\t\t\t\t\tnext = NULL;\n\t\t\t\telse if (literal[1] == '/') {\n\t\t\t\t\tnext = strchr(literal + 2, ':');\n\t\t\t\t\tif (next != NULL)\n\t\t\t\t\t\t++next;\n\t\t\t\t} else if (literal[1] == ':')\n\t\t\t\t\tnext = literal + 2;\n\t\t\t\telse {\n\t\t\t\t\tfree(val_dup);\n\t\t\t\t\treturn (SA_SYNTAX_ERR);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = strchr(host, ':');\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t++next;\n\t\t\t}\n\t\t\thost = next;\n\t\t} while (host != NULL);\n\t\tfree(val_dup);\n\t\treturn (SA_OK);\n\t}\n\n\tif (strcmp(key, \"anon\") == 0)\n\t\tkey = \"anonuid\";\n\n\tif (strcmp(key, \"root_mapping\") == 0) {\n\t\t(void) add_linux_shareopt(plinux_opts, \"root_squash\", NULL);\n\t\tkey = \"anonuid\";\n\t}\n\n\tif (strcmp(key, \"nosub\") == 0)\n\t\tkey = \"subtree_check\";\n\n\tif (bsearch(&key, valid_keys, ARRAY_SIZE(valid_keys),\n\t    sizeof (*valid_keys), string_cmp) == NULL)\n\t\treturn (SA_SYNTAX_ERR);\n\n\t(void) add_linux_shareopt(plinux_opts, key, value);\n\n\treturn (SA_OK);\n}\n\n \nstatic int\nget_linux_shareopts(const char *shareopts, char **plinux_opts)\n{\n\tint error;\n\n\tassert(plinux_opts != NULL);\n\n\t*plinux_opts = NULL;\n\n\t \n\t(void) add_linux_shareopt(plinux_opts, \"no_subtree_check\", NULL);\n\n\t \n\t(void) add_linux_shareopt(plinux_opts, \"mountpoint\", NULL);\n\n\terror = foreach_nfs_shareopt(shareopts, get_linux_shareopts_cb,\n\t    plinux_opts);\n\n\tif (error != SA_OK) {\n\t\tfree(*plinux_opts);\n\t\t*plinux_opts = NULL;\n\t}\n\n\treturn (error);\n}\n\n \nstatic int\nnfs_add_entry(FILE *tmpfile, const char *sharepath,\n    const char *host, const char *security, const char *access_opts,\n    void *pcookie)\n{\n\tconst char *linux_opts = (const char *)pcookie;\n\n\tif (linux_opts == NULL)\n\t\tlinux_opts = \"\";\n\n\tboolean_t need_free;\n\tchar *mp;\n\tint rc = nfs_escape_mountpoint(sharepath, &mp, &need_free);\n\tif (rc != SA_OK)\n\t\treturn (rc);\n\tif (fprintf(tmpfile, \"%s %s(sec=%s,%s,%s)\\n\", mp,\n\t    get_linux_hostspec(host), security, access_opts,\n\t    linux_opts) < 0) {\n\t\tfprintf(stderr, \"failed to write to temporary file\\n\");\n\t\trc = SA_SYSTEM_ERR;\n\t}\n\n\tif (need_free)\n\t\tfree(mp);\n\treturn (rc);\n}\n\n \nstatic int\nnfs_enable_share_impl(sa_share_impl_t impl_share, FILE *tmpfile)\n{\n\tchar *linux_opts = NULL;\n\tint error = get_linux_shareopts(impl_share->sa_shareopts, &linux_opts);\n\tif (error != SA_OK)\n\t\treturn (error);\n\n\terror = foreach_nfs_host(impl_share, tmpfile, nfs_add_entry,\n\t    linux_opts);\n\tfree(linux_opts);\n\treturn (error);\n}\n\nstatic int\nnfs_enable_share(sa_share_impl_t impl_share)\n{\n\tif (!nfs_available())\n\t\treturn (SA_SYSTEM_ERR);\n\n\treturn (nfs_toggle_share(\n\t    ZFS_EXPORTS_LOCK, ZFS_EXPORTS_FILE, ZFS_EXPORTS_DIR, impl_share,\n\t    nfs_enable_share_impl));\n}\n\n \nstatic int\nnfs_disable_share_impl(sa_share_impl_t impl_share, FILE *tmpfile)\n{\n\t(void) impl_share, (void) tmpfile;\n\treturn (SA_OK);\n}\n\nstatic int\nnfs_disable_share(sa_share_impl_t impl_share)\n{\n\tif (!nfs_available())\n\t\treturn (SA_OK);\n\n\treturn (nfs_toggle_share(\n\t    ZFS_EXPORTS_LOCK, ZFS_EXPORTS_FILE, ZFS_EXPORTS_DIR, impl_share,\n\t    nfs_disable_share_impl));\n}\n\nstatic boolean_t\nnfs_is_shared(sa_share_impl_t impl_share)\n{\n\tif (!nfs_available())\n\t\treturn (SA_SYSTEM_ERR);\n\n\treturn (nfs_is_shared_impl(ZFS_EXPORTS_FILE, impl_share));\n}\n\n \nstatic int\nnfs_validate_shareopts(const char *shareopts)\n{\n\tchar *linux_opts = NULL;\n\n\tif (strlen(shareopts) == 0)\n\t\treturn (SA_SYNTAX_ERR);\n\n\tint error = get_linux_shareopts(shareopts, &linux_opts);\n\tif (error != SA_OK)\n\t\treturn (error);\n\n\tfree(linux_opts);\n\treturn (SA_OK);\n}\n\nstatic int\nnfs_commit_shares(void)\n{\n\tif (!nfs_available())\n\t\treturn (SA_SYSTEM_ERR);\n\n\tchar *argv[] = {\n\t    (char *)\"/usr/sbin/exportfs\",\n\t    (char *)\"-ra\",\n\t    NULL\n\t};\n\n\treturn (libzfs_run_process(argv[0], argv, 0));\n}\n\nstatic void\nnfs_truncate_shares(void)\n{\n\tnfs_reset_shares(ZFS_EXPORTS_LOCK, ZFS_EXPORTS_FILE);\n}\n\nconst sa_fstype_t libshare_nfs_type = {\n\t.enable_share = nfs_enable_share,\n\t.disable_share = nfs_disable_share,\n\t.is_shared = nfs_is_shared,\n\n\t.validate_shareopts = nfs_validate_shareopts,\n\t.commit_shares = nfs_commit_shares,\n\t.truncate_shares = nfs_truncate_shares,\n};\n\nstatic boolean_t\nnfs_available(void)\n{\n\tstatic int avail;\n\n\tif (!avail) {\n\t\tif (access(\"/usr/sbin/exportfs\", F_OK) != 0)\n\t\t\tavail = -1;\n\t\telse\n\t\t\tavail = 1;\n\t}\n\n\treturn (avail == 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}