{
  "module_name": "smb.c",
  "hash_id": "7e150900d379b62e6ec01cc746bf5c92a7df891ffee822cd18f0e9e650be0d23",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libshare/os/linux/smb.c",
  "human_readable_source": " \n\n \n\n#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libzfs.h>\n#include <libshare.h>\n#include \"libshare_impl.h\"\n#include \"smb.h\"\n\nstatic boolean_t smb_available(void);\n\nstatic smb_share_t *smb_shares;\nstatic int smb_disable_share(sa_share_impl_t impl_share);\nstatic boolean_t smb_is_share_active(sa_share_impl_t impl_share);\n\n \nstatic int\nsmb_retrieve_shares(void)\n{\n\tint rc = SA_OK;\n\tchar file_path[PATH_MAX], line[512], *token, *key, *value;\n\tchar *dup_value = NULL, *path = NULL, *comment = NULL, *name = NULL;\n\tchar *guest_ok = NULL;\n\tDIR *shares_dir;\n\tFILE *share_file_fp = NULL;\n\tstruct dirent *directory;\n\tstruct stat eStat;\n\tsmb_share_t *shares, *new_shares = NULL;\n\n\t \n\tshares_dir = opendir(SHARE_DIR);\n\tif (shares_dir == NULL)\n\t\treturn (SA_SYSTEM_ERR);\n\n\t \n\twhile ((directory = readdir(shares_dir))) {\n\t\tint fd;\n\n\t\tif (directory->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\tsnprintf(file_path, sizeof (file_path),\n\t\t    \"%s/%s\", SHARE_DIR, directory->d_name);\n\n\t\tif ((fd = open(file_path, O_RDONLY | O_CLOEXEC)) == -1) {\n\t\t\trc = SA_SYSTEM_ERR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fstat(fd, &eStat) == -1) {\n\t\t\tclose(fd);\n\t\t\trc = SA_SYSTEM_ERR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!S_ISREG(eStat.st_mode)) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((share_file_fp = fdopen(fd, \"r\")) == NULL) {\n\t\t\tclose(fd);\n\t\t\trc = SA_SYSTEM_ERR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname = strdup(directory->d_name);\n\t\tif (name == NULL) {\n\t\t\trc = SA_NO_MEMORY;\n\t\t\tgoto out;\n\t\t}\n\n\t\twhile (fgets(line, sizeof (line), share_file_fp)) {\n\t\t\tif (line[0] == '#')\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\twhile (line[strlen(line) - 1] == '\\r' ||\n\t\t\t    line[strlen(line) - 1] == '\\n')\n\t\t\t\tline[strlen(line) - 1] = '\\0';\n\n\t\t\t \n\t\t\ttoken = strchr(line, '=');\n\t\t\tif (token == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tkey = line;\n\t\t\tvalue = token + 1;\n\t\t\t*token = '\\0';\n\n\t\t\tdup_value = strdup(value);\n\t\t\tif (dup_value == NULL) {\n\t\t\t\trc = SA_NO_MEMORY;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (strcmp(key, \"path\") == 0) {\n\t\t\t\tfree(path);\n\t\t\t\tpath = dup_value;\n\t\t\t} else if (strcmp(key, \"comment\") == 0) {\n\t\t\t\tfree(comment);\n\t\t\t\tcomment = dup_value;\n\t\t\t} else if (strcmp(key, \"guest_ok\") == 0) {\n\t\t\t\tfree(guest_ok);\n\t\t\t\tguest_ok = dup_value;\n\t\t\t} else\n\t\t\t\tfree(dup_value);\n\n\t\t\tdup_value = NULL;\n\n\t\t\tif (path == NULL || comment == NULL || guest_ok == NULL)\n\t\t\t\tcontinue;  \n\t\t\telse {\n\t\t\t\tshares = (smb_share_t *)\n\t\t\t\t    malloc(sizeof (smb_share_t));\n\t\t\t\tif (shares == NULL) {\n\t\t\t\t\trc = SA_NO_MEMORY;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t(void) strlcpy(shares->name, name,\n\t\t\t\t    sizeof (shares->name));\n\n\t\t\t\t(void) strlcpy(shares->path, path,\n\t\t\t\t    sizeof (shares->path));\n\n\t\t\t\t(void) strlcpy(shares->comment, comment,\n\t\t\t\t    sizeof (shares->comment));\n\n\t\t\t\tshares->guest_ok = atoi(guest_ok);\n\n\t\t\t\tshares->next = new_shares;\n\t\t\t\tnew_shares = shares;\n\n\t\t\t\tfree(path);\n\t\t\t\tfree(comment);\n\t\t\t\tfree(guest_ok);\n\n\t\t\t\tpath = NULL;\n\t\t\t\tcomment = NULL;\n\t\t\t\tguest_ok = NULL;\n\t\t\t}\n\t\t}\n\nout:\n\t\tif (share_file_fp != NULL) {\n\t\t\tfclose(share_file_fp);\n\t\t\tshare_file_fp = NULL;\n\t\t}\n\n\t\tfree(name);\n\t\tfree(path);\n\t\tfree(comment);\n\t\tfree(guest_ok);\n\n\t\tname = NULL;\n\t\tpath = NULL;\n\t\tcomment = NULL;\n\t\tguest_ok = NULL;\n\t}\n\tclosedir(shares_dir);\n\n\tsmb_shares = new_shares;\n\n\treturn (rc);\n}\n\n \nstatic int\nsmb_enable_share_one(const char *sharename, const char *sharepath)\n{\n\tchar name[SMB_NAME_MAX], comment[SMB_COMMENT_MAX];\n\n\t \n\tstrlcpy(name, sharename, sizeof (name));\n\tfor (char *itr = name; *itr != '\\0'; ++itr)\n\t\tswitch (*itr) {\n\t\tcase '/':\n\t\tcase '-':\n\t\tcase ':':\n\t\tcase ' ':\n\t\t\t*itr = '_';\n\t\t}\n\n\t \n\tsnprintf(comment, sizeof (comment), \"Comment: %s\", sharepath);\n\n\tchar *argv[] = {\n\t\t(char *)NET_CMD_PATH,\n\t\t(char *)\"-S\",\n\t\t(char *)NET_CMD_ARG_HOST,\n\t\t(char *)\"usershare\",\n\t\t(char *)\"add\",\n\t\tname,\n\t\t(char *)sharepath,\n\t\tcomment,\n\t\t(char *)\"Everyone:F\",\n\t\tNULL,\n\t};\n\n\tif (libzfs_run_process(argv[0], argv, 0) != 0)\n\t\treturn (SA_SYSTEM_ERR);\n\n\t \n\t(void) smb_retrieve_shares();\n\n\treturn (SA_OK);\n}\n\n \nstatic int\nsmb_enable_share(sa_share_impl_t impl_share)\n{\n\tif (!smb_available())\n\t\treturn (SA_SYSTEM_ERR);\n\n\tif (smb_is_share_active(impl_share))\n\t\tsmb_disable_share(impl_share);\n\n\tif (impl_share->sa_shareopts == NULL)  \n\t\treturn (SA_SYSTEM_ERR);\n\n\tif (strcmp(impl_share->sa_shareopts, \"off\") == 0)\n\t\treturn (SA_OK);\n\n\t \n\treturn (smb_enable_share_one(impl_share->sa_zfsname,\n\t    impl_share->sa_mountpoint));\n}\n\n \nstatic int\nsmb_disable_share_one(const char *sharename)\n{\n\t \n\tchar *argv[] = {\n\t\t(char *)NET_CMD_PATH,\n\t\t(char *)\"-S\",\n\t\t(char *)NET_CMD_ARG_HOST,\n\t\t(char *)\"usershare\",\n\t\t(char *)\"delete\",\n\t\t(char *)sharename,\n\t\tNULL,\n\t};\n\n\tif (libzfs_run_process(argv[0], argv, 0) != 0)\n\t\treturn (SA_SYSTEM_ERR);\n\telse\n\t\treturn (SA_OK);\n}\n\n \nstatic int\nsmb_disable_share(sa_share_impl_t impl_share)\n{\n\tif (!smb_available()) {\n\t\t \n\t\treturn (SA_OK);\n\t}\n\n\tfor (const smb_share_t *i = smb_shares; i != NULL; i = i->next)\n\t\tif (strcmp(impl_share->sa_mountpoint, i->path) == 0)\n\t\t\treturn (smb_disable_share_one(i->name));\n\n\treturn (SA_OK);\n}\n\n \nstatic int\nsmb_validate_shareopts(const char *shareopts)\n{\n\t \n\tif ((strcmp(shareopts, \"off\") == 0) || (strcmp(shareopts, \"on\") == 0))\n\t\treturn (SA_OK);\n\n\treturn (SA_SYNTAX_ERR);\n}\n\n \nstatic boolean_t\nsmb_is_share_active(sa_share_impl_t impl_share)\n{\n\tif (!smb_available())\n\t\treturn (B_FALSE);\n\n\t \n\tsmb_retrieve_shares();\n\n\tfor (const smb_share_t *i = smb_shares; i != NULL; i = i->next)\n\t\tif (strcmp(impl_share->sa_mountpoint, i->path) == 0)\n\t\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\nstatic int\nsmb_update_shares(void)\n{\n\t \n\treturn (0);\n}\n\nconst sa_fstype_t libshare_smb_type = {\n\t.enable_share = smb_enable_share,\n\t.disable_share = smb_disable_share,\n\t.is_shared = smb_is_share_active,\n\n\t.validate_shareopts = smb_validate_shareopts,\n\t.commit_shares = smb_update_shares,\n};\n\n \nstatic boolean_t\nsmb_available(void)\n{\n\tstatic int avail;\n\n\tif (!avail) {\n\t\tstruct stat statbuf;\n\n\t\tif (access(NET_CMD_PATH, F_OK) != 0 ||\n\t\t    lstat(SHARE_DIR, &statbuf) != 0 ||\n\t\t    !S_ISDIR(statbuf.st_mode))\n\t\t\tavail = -1;\n\t\telse\n\t\t\tavail = 1;\n\t}\n\n\treturn (avail == 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}