{
  "module_name": "lzbe_pair.c",
  "hash_id": "e2f34c97b0ff856a183e94b1ac95323fee46fb8ed25d4043df46985bea5c569f",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libzfsbootenv/lzbe_pair.c",
  "human_readable_source": " \n \n\n#include <sys/types.h>\n#include <string.h>\n#include <libzfs.h>\n#include <libzfsbootenv.h>\n#include <sys/zfs_bootenv.h>\n#include <sys/vdev_impl.h>\n\n \nint\nlzbe_nvlist_get(const char *pool, const char *key, void **ptr)\n{\n\tlibzfs_handle_t *hdl;\n\tzpool_handle_t *zphdl;\n\tnvlist_t *nv;\n\tint rv = -1;\n\n\tif (pool == NULL || *pool == '\\0')\n\t\treturn (rv);\n\n\tif ((hdl = libzfs_init()) == NULL) {\n\t\treturn (rv);\n\t}\n\n\tzphdl = zpool_open(hdl, pool);\n\tif (zphdl == NULL) {\n\t\tlibzfs_fini(hdl);\n\t\treturn (rv);\n\t}\n\n\trv = zpool_get_bootenv(zphdl, &nv);\n\tif (rv == 0) {\n\t\tnvlist_t *nvl, *dup;\n\n\t\tif (key != NULL) {\n\t\t\trv = nvlist_lookup_nvlist(nv, key, &nvl);\n\t\t\tif (rv == 0) {\n\t\t\t\trv = nvlist_dup(nvl, &dup, 0);\n\t\t\t\tnvlist_free(nv);\n\t\t\t\tif (rv == 0)\n\t\t\t\t\tnv = dup;\n\t\t\t\telse\n\t\t\t\t\tnv = NULL;\n\t\t\t} else {\n\t\t\t\tnvlist_free(nv);\n\t\t\t\trv = nvlist_alloc(&nv, NV_UNIQUE_NAME, 0);\n\t\t\t}\n\t\t}\n\t\t*ptr = nv;\n\t}\n\n\tzpool_close(zphdl);\n\tlibzfs_fini(hdl);\n\treturn (rv);\n}\n\nint\nlzbe_nvlist_set(const char *pool, const char *key, void *ptr)\n{\n\tlibzfs_handle_t *hdl;\n\tzpool_handle_t *zphdl;\n\tnvlist_t *nv;\n\tuint64_t version;\n\tint rv = -1;\n\n\tif (pool == NULL || *pool == '\\0')\n\t\treturn (rv);\n\n\tif ((hdl = libzfs_init()) == NULL) {\n\t\treturn (rv);\n\t}\n\n\tzphdl = zpool_open(hdl, pool);\n\tif (zphdl == NULL) {\n\t\tlibzfs_fini(hdl);\n\t\treturn (rv);\n\t}\n\n\tif (key != NULL) {\n\t\trv = zpool_get_bootenv(zphdl, &nv);\n\t\tif (rv == 0) {\n\t\t\t \n\t\t\trv = nvlist_lookup_uint64(nv, BOOTENV_VERSION,\n\t\t\t    &version);\n\t\t\tif (rv != 0 || version != VB_NVLIST) {\n\t\t\t\t \n\t\t\t\tfnvlist_free(nv);\n\t\t\t\t \n\t\t\t\tnv = fnvlist_alloc();\n\t\t\t\tfnvlist_add_uint64(nv, BOOTENV_VERSION,\n\t\t\t\t    VB_NVLIST);\n\t\t\t}\n\t\t\trv = nvlist_add_nvlist(nv, key, ptr);\n\t\t\tif (rv == 0)\n\t\t\t\trv = zpool_set_bootenv(zphdl, nv);\n\t\t\tnvlist_free(nv);\n\t\t}\n\t} else {\n\t\trv = zpool_set_bootenv(zphdl, ptr);\n\t}\n\n\tzpool_close(zphdl);\n\tlibzfs_fini(hdl);\n\treturn (rv);\n}\n\n \nvoid\nlzbe_nvlist_free(void *ptr)\n{\n\tnvlist_free(ptr);\n}\n\nstatic const char *typenames[] = {\n\t\"DATA_TYPE_UNKNOWN\",\n\t\"DATA_TYPE_BOOLEAN\",\n\t\"DATA_TYPE_BYTE\",\n\t\"DATA_TYPE_INT16\",\n\t\"DATA_TYPE_UINT16\",\n\t\"DATA_TYPE_INT32\",\n\t\"DATA_TYPE_UINT32\",\n\t\"DATA_TYPE_INT64\",\n\t\"DATA_TYPE_UINT64\",\n\t\"DATA_TYPE_STRING\",\n\t\"DATA_TYPE_BYTE_ARRAY\",\n\t\"DATA_TYPE_INT16_ARRAY\",\n\t\"DATA_TYPE_UINT16_ARRAY\",\n\t\"DATA_TYPE_INT32_ARRAY\",\n\t\"DATA_TYPE_UINT32_ARRAY\",\n\t\"DATA_TYPE_INT64_ARRAY\",\n\t\"DATA_TYPE_UINT64_ARRAY\",\n\t\"DATA_TYPE_STRING_ARRAY\",\n\t\"DATA_TYPE_HRTIME\",\n\t\"DATA_TYPE_NVLIST\",\n\t\"DATA_TYPE_NVLIST_ARRAY\",\n\t\"DATA_TYPE_BOOLEAN_VALUE\",\n\t\"DATA_TYPE_INT8\",\n\t\"DATA_TYPE_UINT8\",\n\t\"DATA_TYPE_BOOLEAN_ARRAY\",\n\t\"DATA_TYPE_INT8_ARRAY\",\n\t\"DATA_TYPE_UINT8_ARRAY\"\n};\n\nstatic int\nnvpair_type_from_name(const char *name)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(typenames); i++) {\n\t\tif (strcmp(name, typenames[i]) == 0)\n\t\t\treturn (i);\n\t}\n\treturn (0);\n}\n\n \nint\nlzbe_add_pair(void *ptr, const char *key, const char *type, void *value,\n    size_t size)\n{\n\tnvlist_t *nv = ptr;\n\tdata_type_t dt;\n\tint rv = 0;\n\n\tif (ptr == NULL || key == NULL || value == NULL)\n\t\treturn (rv);\n\n\tif (type == NULL)\n\t\ttype = \"DATA_TYPE_STRING\";\n\tdt = nvpair_type_from_name(type);\n\tif (dt == DATA_TYPE_UNKNOWN)\n\t\treturn (EINVAL);\n\n\tswitch (dt) {\n\tcase DATA_TYPE_BYTE:\n\t\tif (size != sizeof (uint8_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_byte(nv, key, *(uint8_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT16:\n\t\tif (size != sizeof (int16_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_int16(nv, key, *(int16_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT16:\n\t\tif (size != sizeof (uint16_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_uint16(nv, key, *(uint16_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT32:\n\t\tif (size != sizeof (int32_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_int32(nv, key, *(int32_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT32:\n\t\tif (size != sizeof (uint32_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_uint32(nv, key, *(uint32_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT64:\n\t\tif (size != sizeof (int64_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_int64(nv, key, *(int64_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT64:\n\t\tif (size != sizeof (uint64_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_uint64(nv, key, *(uint64_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_STRING:\n\t\trv = nvlist_add_string(nv, key, value);\n\t\tbreak;\n\n\tcase DATA_TYPE_BYTE_ARRAY:\n\t\trv = nvlist_add_byte_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT16_ARRAY:\n\t\trv = nvlist_add_int16_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT16_ARRAY:\n\t\trv = nvlist_add_uint16_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT32_ARRAY:\n\t\trv = nvlist_add_int32_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT32_ARRAY:\n\t\trv = nvlist_add_uint32_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT64_ARRAY:\n\t\trv = nvlist_add_int64_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT64_ARRAY:\n\t\trv = nvlist_add_uint64_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_STRING_ARRAY:\n\t\trv = nvlist_add_string_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_NVLIST:\n\t\trv = nvlist_add_nvlist(nv, key, (nvlist_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\trv = nvlist_add_nvlist_array(nv, key, (const nvlist_t **)value,\n\t\t    size);\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\tif (size != sizeof (boolean_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_boolean_value(nv, key, *(boolean_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT8:\n\t\tif (size != sizeof (int8_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_int8(nv, key, *(int8_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT8:\n\t\tif (size != sizeof (uint8_t)) {\n\t\t\trv = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trv = nvlist_add_uint8(nv, key, *(uint8_t *)value);\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\t\trv = nvlist_add_boolean_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT8_ARRAY:\n\t\trv = nvlist_add_int8_array(nv, key, value, size);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT8_ARRAY:\n\t\trv = nvlist_add_uint8_array(nv, key, value, size);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (ENOTSUP);\n\t}\n\n\treturn (rv);\n}\n\nint\nlzbe_remove_pair(void *ptr, const char *key)\n{\n\n\treturn (nvlist_remove_all(ptr, key));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}