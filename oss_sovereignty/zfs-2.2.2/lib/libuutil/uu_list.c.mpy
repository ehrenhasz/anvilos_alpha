{
  "module_name": "uu_list.c",
  "hash_id": "053e81b04e14260ae0c3f4215582a52f6a501028160522ba74632aa8ad07cad1",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libuutil/uu_list.c",
  "human_readable_source": " \n \n\n\n\n#include \"libuutil_common.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/time.h>\n\n#define\tELEM_TO_NODE(lp, e) \\\n\t((uu_list_node_impl_t *)((uintptr_t)(e) + (lp)->ul_offset))\n\n#define\tNODE_TO_ELEM(lp, n) \\\n\t((void *)((uintptr_t)(n) - (lp)->ul_offset))\n\n \n#define\tINDEX_MAX\t\t(sizeof (uintptr_t) - 1)\n#define\tINDEX_NEXT(m)\t\t(((m) == INDEX_MAX)? 1 : ((m) + 1) & INDEX_MAX)\n\n#define\tINDEX_TO_NODE(i)\t((uu_list_node_impl_t *)((i) & ~INDEX_MAX))\n#define\tNODE_TO_INDEX(p, n)\t(((uintptr_t)(n) & ~INDEX_MAX) | (p)->ul_index)\n#define\tINDEX_VALID(p, i)\t(((i) & INDEX_MAX) == (p)->ul_index)\n#define\tINDEX_CHECK(i)\t\t(((i) & INDEX_MAX) != 0)\n\n#define\tPOOL_TO_MARKER(pp) ((void *)((uintptr_t)(pp) | 1))\n\nstatic uu_list_pool_t\tuu_null_lpool = { &uu_null_lpool, &uu_null_lpool };\nstatic pthread_mutex_t\tuu_lpool_list_lock = PTHREAD_MUTEX_INITIALIZER;\n\nuu_list_pool_t *\nuu_list_pool_create(const char *name, size_t objsize,\n    size_t nodeoffset, uu_compare_fn_t *compare_func, uint32_t flags)\n{\n\tuu_list_pool_t *pp, *next, *prev;\n\n\tif (name == NULL ||\n\t    uu_check_name(name, UU_NAME_DOMAIN) == -1 ||\n\t    nodeoffset + sizeof (uu_list_node_t) > objsize) {\n\t\tuu_set_error(UU_ERROR_INVALID_ARGUMENT);\n\t\treturn (NULL);\n\t}\n\n\tif (flags & ~UU_LIST_POOL_DEBUG) {\n\t\tuu_set_error(UU_ERROR_UNKNOWN_FLAG);\n\t\treturn (NULL);\n\t}\n\n\tpp = uu_zalloc(sizeof (uu_list_pool_t));\n\tif (pp == NULL) {\n\t\tuu_set_error(UU_ERROR_NO_MEMORY);\n\t\treturn (NULL);\n\t}\n\n\t(void) strlcpy(pp->ulp_name, name, sizeof (pp->ulp_name));\n\tpp->ulp_nodeoffset = nodeoffset;\n\tpp->ulp_objsize = objsize;\n\tpp->ulp_cmp = compare_func;\n\tif (flags & UU_LIST_POOL_DEBUG)\n\t\tpp->ulp_debug = 1;\n\tpp->ulp_last_index = 0;\n\n\t(void) pthread_mutex_init(&pp->ulp_lock, NULL);\n\n\tpp->ulp_null_list.ul_next = &pp->ulp_null_list;\n\tpp->ulp_null_list.ul_prev = &pp->ulp_null_list;\n\n\t(void) pthread_mutex_lock(&uu_lpool_list_lock);\n\tpp->ulp_next = next = &uu_null_lpool;\n\tpp->ulp_prev = prev = next->ulp_prev;\n\tnext->ulp_prev = pp;\n\tprev->ulp_next = pp;\n\t(void) pthread_mutex_unlock(&uu_lpool_list_lock);\n\n\treturn (pp);\n}\n\nvoid\nuu_list_pool_destroy(uu_list_pool_t *pp)\n{\n\tif (pp->ulp_debug) {\n\t\tif (pp->ulp_null_list.ul_next != &pp->ulp_null_list ||\n\t\t    pp->ulp_null_list.ul_prev != &pp->ulp_null_list) {\n\t\t\tuu_panic(\"uu_list_pool_destroy: Pool \\\"%.*s\\\" (%p) has \"\n\t\t\t    \"outstanding lists, or is corrupt.\\n\",\n\t\t\t    (int)sizeof (pp->ulp_name), pp->ulp_name,\n\t\t\t    (void *)pp);\n\t\t}\n\t}\n\t(void) pthread_mutex_lock(&uu_lpool_list_lock);\n\tpp->ulp_next->ulp_prev = pp->ulp_prev;\n\tpp->ulp_prev->ulp_next = pp->ulp_next;\n\t(void) pthread_mutex_unlock(&uu_lpool_list_lock);\n\tpp->ulp_prev = NULL;\n\tpp->ulp_next = NULL;\n\tuu_free(pp);\n}\n\nvoid\nuu_list_node_init(void *base, uu_list_node_t *np_arg, uu_list_pool_t *pp)\n{\n\tuu_list_node_impl_t *np = (uu_list_node_impl_t *)np_arg;\n\n\tif (pp->ulp_debug) {\n\t\tuintptr_t offset = (uintptr_t)np - (uintptr_t)base;\n\t\tif (offset + sizeof (*np) > pp->ulp_objsize) {\n\t\t\tuu_panic(\"uu_list_node_init(%p, %p, %p (\\\"%s\\\")): \"\n\t\t\t    \"offset %ld doesn't fit in object (size %ld)\\n\",\n\t\t\t    base, (void *)np, (void *)pp, pp->ulp_name,\n\t\t\t    (long)offset, (long)pp->ulp_objsize);\n\t\t}\n\t\tif (offset != pp->ulp_nodeoffset) {\n\t\t\tuu_panic(\"uu_list_node_init(%p, %p, %p (\\\"%s\\\")): \"\n\t\t\t    \"offset %ld doesn't match pool's offset (%ld)\\n\",\n\t\t\t    base, (void *)np, (void *)pp, pp->ulp_name,\n\t\t\t    (long)offset, (long)pp->ulp_objsize);\n\t\t}\n\t}\n\tnp->uln_next = POOL_TO_MARKER(pp);\n\tnp->uln_prev = NULL;\n}\n\nvoid\nuu_list_node_fini(void *base, uu_list_node_t *np_arg, uu_list_pool_t *pp)\n{\n\tuu_list_node_impl_t *np = (uu_list_node_impl_t *)np_arg;\n\n\tif (pp->ulp_debug) {\n\t\tif (np->uln_next == NULL &&\n\t\t    np->uln_prev == NULL) {\n\t\t\tuu_panic(\"uu_list_node_fini(%p, %p, %p (\\\"%s\\\")): \"\n\t\t\t    \"node already finied\\n\",\n\t\t\t    base, (void *)np_arg, (void *)pp, pp->ulp_name);\n\t\t}\n\t\tif (np->uln_next != POOL_TO_MARKER(pp) ||\n\t\t    np->uln_prev != NULL) {\n\t\t\tuu_panic(\"uu_list_node_fini(%p, %p, %p (\\\"%s\\\")): \"\n\t\t\t    \"node corrupt or on list\\n\",\n\t\t\t    base, (void *)np_arg, (void *)pp, pp->ulp_name);\n\t\t}\n\t}\n\tnp->uln_next = NULL;\n\tnp->uln_prev = NULL;\n}\n\nuu_list_t *\nuu_list_create(uu_list_pool_t *pp, void *parent, uint32_t flags)\n{\n\tuu_list_t *lp, *next, *prev;\n\n\tif (flags & ~(UU_LIST_DEBUG | UU_LIST_SORTED)) {\n\t\tuu_set_error(UU_ERROR_UNKNOWN_FLAG);\n\t\treturn (NULL);\n\t}\n\n\tif ((flags & UU_LIST_SORTED) && pp->ulp_cmp == NULL) {\n\t\tif (pp->ulp_debug)\n\t\t\tuu_panic(\"uu_list_create(%p, ...): requested \"\n\t\t\t    \"UU_LIST_SORTED, but pool has no comparison func\\n\",\n\t\t\t    (void *)pp);\n\t\tuu_set_error(UU_ERROR_NOT_SUPPORTED);\n\t\treturn (NULL);\n\t}\n\n\tlp = uu_zalloc(sizeof (*lp));\n\tif (lp == NULL) {\n\t\tuu_set_error(UU_ERROR_NO_MEMORY);\n\t\treturn (NULL);\n\t}\n\n\tlp->ul_pool = pp;\n\tlp->ul_parent = parent;\n\tlp->ul_offset = pp->ulp_nodeoffset;\n\tlp->ul_debug = pp->ulp_debug || (flags & UU_LIST_DEBUG);\n\tlp->ul_sorted = (flags & UU_LIST_SORTED);\n\tlp->ul_numnodes = 0;\n\tlp->ul_index = (pp->ulp_last_index = INDEX_NEXT(pp->ulp_last_index));\n\n\tlp->ul_null_node.uln_next = &lp->ul_null_node;\n\tlp->ul_null_node.uln_prev = &lp->ul_null_node;\n\n\tlp->ul_null_walk.ulw_next = &lp->ul_null_walk;\n\tlp->ul_null_walk.ulw_prev = &lp->ul_null_walk;\n\n\t(void) pthread_mutex_lock(&pp->ulp_lock);\n\tnext = &pp->ulp_null_list;\n\tprev = next->ul_prev;\n\tlp->ul_next = next;\n\tlp->ul_prev = prev;\n\tnext->ul_prev = lp;\n\tprev->ul_next = lp;\n\t(void) pthread_mutex_unlock(&pp->ulp_lock);\n\n\treturn (lp);\n}\n\nvoid\nuu_list_destroy(uu_list_t *lp)\n{\n\tuu_list_pool_t *pp = lp->ul_pool;\n\n\tif (lp->ul_debug) {\n\t\tif (lp->ul_null_node.uln_next != &lp->ul_null_node ||\n\t\t    lp->ul_null_node.uln_prev != &lp->ul_null_node) {\n\t\t\tuu_panic(\"uu_list_destroy(%p):  list not empty\\n\",\n\t\t\t    (void *)lp);\n\t\t}\n\t\tif (lp->ul_numnodes != 0) {\n\t\t\tuu_panic(\"uu_list_destroy(%p):  numnodes is nonzero, \"\n\t\t\t    \"but list is empty\\n\", (void *)lp);\n\t\t}\n\t\tif (lp->ul_null_walk.ulw_next != &lp->ul_null_walk ||\n\t\t    lp->ul_null_walk.ulw_prev != &lp->ul_null_walk) {\n\t\t\tuu_panic(\"uu_list_destroy(%p):  outstanding walkers\\n\",\n\t\t\t    (void *)lp);\n\t\t}\n\t}\n\n\t(void) pthread_mutex_lock(&pp->ulp_lock);\n\tlp->ul_next->ul_prev = lp->ul_prev;\n\tlp->ul_prev->ul_next = lp->ul_next;\n\t(void) pthread_mutex_unlock(&pp->ulp_lock);\n\tlp->ul_prev = NULL;\n\tlp->ul_next = NULL;\n\tlp->ul_pool = NULL;\n\tuu_free(lp);\n}\n\nstatic void\nlist_insert(uu_list_t *lp, uu_list_node_impl_t *np, uu_list_node_impl_t *prev,\n    uu_list_node_impl_t *next)\n{\n\tif (lp->ul_debug) {\n\t\tif (next->uln_prev != prev || prev->uln_next != next)\n\t\t\tuu_panic(\"insert(%p): internal error: %p and %p not \"\n\t\t\t    \"neighbors\\n\", (void *)lp, (void *)next,\n\t\t\t    (void *)prev);\n\n\t\tif (np->uln_next != POOL_TO_MARKER(lp->ul_pool) ||\n\t\t    np->uln_prev != NULL) {\n\t\t\tuu_panic(\"insert(%p): elem %p node %p corrupt, \"\n\t\t\t    \"not initialized, or already in a list.\\n\",\n\t\t\t    (void *)lp, NODE_TO_ELEM(lp, np), (void *)np);\n\t\t}\n\t\t \n\t\tlp->ul_index = INDEX_NEXT(lp->ul_index);\n\t}\n\tnp->uln_next = next;\n\tnp->uln_prev = prev;\n\tnext->uln_prev = np;\n\tprev->uln_next = np;\n\n\tlp->ul_numnodes++;\n}\n\nvoid\nuu_list_insert(uu_list_t *lp, void *elem, uu_list_index_t idx)\n{\n\tuu_list_node_impl_t *np;\n\n\tnp = INDEX_TO_NODE(idx);\n\tif (np == NULL)\n\t\tnp = &lp->ul_null_node;\n\n\tif (lp->ul_debug) {\n\t\tif (!INDEX_VALID(lp, idx))\n\t\t\tuu_panic(\"uu_list_insert(%p, %p, %p): %s\\n\",\n\t\t\t    (void *)lp, elem, (void *)idx,\n\t\t\t    INDEX_CHECK(idx)? \"outdated index\" :\n\t\t\t    \"invalid index\");\n\t\tif (np->uln_prev == NULL)\n\t\t\tuu_panic(\"uu_list_insert(%p, %p, %p): out-of-date \"\n\t\t\t    \"index\\n\", (void *)lp, elem, (void *)idx);\n\t}\n\n\tlist_insert(lp, ELEM_TO_NODE(lp, elem), np->uln_prev, np);\n}\n\nvoid *\nuu_list_find(uu_list_t *lp, void *elem, void *private, uu_list_index_t *out)\n{\n\tint sorted = lp->ul_sorted;\n\tuu_compare_fn_t *func = lp->ul_pool->ulp_cmp;\n\tuu_list_node_impl_t *np;\n\n\tif (func == NULL) {\n\t\tif (out != NULL)\n\t\t\t*out = 0;\n\t\tuu_set_error(UU_ERROR_NOT_SUPPORTED);\n\t\treturn (NULL);\n\t}\n\tfor (np = lp->ul_null_node.uln_next; np != &lp->ul_null_node;\n\t    np = np->uln_next) {\n\t\tvoid *ep = NODE_TO_ELEM(lp, np);\n\t\tint cmp = func(ep, elem, private);\n\t\tif (cmp == 0) {\n\t\t\tif (out != NULL)\n\t\t\t\t*out = NODE_TO_INDEX(lp, np);\n\t\t\treturn (ep);\n\t\t}\n\t\tif (sorted && cmp > 0) {\n\t\t\tif (out != NULL)\n\t\t\t\t*out = NODE_TO_INDEX(lp, np);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tif (out != NULL)\n\t\t*out = NODE_TO_INDEX(lp, 0);\n\treturn (NULL);\n}\n\nvoid *\nuu_list_nearest_next(uu_list_t *lp, uu_list_index_t idx)\n{\n\tuu_list_node_impl_t *np = INDEX_TO_NODE(idx);\n\n\tif (np == NULL)\n\t\tnp = &lp->ul_null_node;\n\n\tif (lp->ul_debug) {\n\t\tif (!INDEX_VALID(lp, idx))\n\t\t\tuu_panic(\"uu_list_nearest_next(%p, %p): %s\\n\",\n\t\t\t    (void *)lp, (void *)idx,\n\t\t\t    INDEX_CHECK(idx)? \"outdated index\" :\n\t\t\t    \"invalid index\");\n\t\tif (np->uln_prev == NULL)\n\t\t\tuu_panic(\"uu_list_nearest_next(%p, %p): out-of-date \"\n\t\t\t    \"index\\n\", (void *)lp, (void *)idx);\n\t}\n\n\tif (np == &lp->ul_null_node)\n\t\treturn (NULL);\n\telse\n\t\treturn (NODE_TO_ELEM(lp, np));\n}\n\nvoid *\nuu_list_nearest_prev(uu_list_t *lp, uu_list_index_t idx)\n{\n\tuu_list_node_impl_t *np = INDEX_TO_NODE(idx);\n\n\tif (np == NULL)\n\t\tnp = &lp->ul_null_node;\n\n\tif (lp->ul_debug) {\n\t\tif (!INDEX_VALID(lp, idx))\n\t\t\tuu_panic(\"uu_list_nearest_prev(%p, %p): %s\\n\",\n\t\t\t    (void *)lp, (void *)idx, INDEX_CHECK(idx)?\n\t\t\t    \"outdated index\" : \"invalid index\");\n\t\tif (np->uln_prev == NULL)\n\t\t\tuu_panic(\"uu_list_nearest_prev(%p, %p): out-of-date \"\n\t\t\t    \"index\\n\", (void *)lp, (void *)idx);\n\t}\n\n\tif ((np = np->uln_prev) == &lp->ul_null_node)\n\t\treturn (NULL);\n\telse\n\t\treturn (NODE_TO_ELEM(lp, np));\n}\n\nstatic void\nlist_walk_init(uu_list_walk_t *wp, uu_list_t *lp, uint32_t flags)\n{\n\tuu_list_walk_t *next, *prev;\n\n\tint robust = (flags & UU_WALK_ROBUST);\n\tint direction = (flags & UU_WALK_REVERSE)? -1 : 1;\n\n\t(void) memset(wp, 0, sizeof (*wp));\n\twp->ulw_list = lp;\n\twp->ulw_robust = robust;\n\twp->ulw_dir = direction;\n\tif (direction > 0)\n\t\twp->ulw_next_result = lp->ul_null_node.uln_next;\n\telse\n\t\twp->ulw_next_result = lp->ul_null_node.uln_prev;\n\n\tif (lp->ul_debug || robust) {\n\t\t \n\t\twp->ulw_next = next = &lp->ul_null_walk;\n\t\twp->ulw_prev = prev = next->ulw_prev;\n\t\tnext->ulw_prev = wp;\n\t\tprev->ulw_next = wp;\n\t}\n}\n\nstatic uu_list_node_impl_t *\nlist_walk_advance(uu_list_walk_t *wp, uu_list_t *lp)\n{\n\tuu_list_node_impl_t *np = wp->ulw_next_result;\n\tuu_list_node_impl_t *next;\n\n\tif (np == &lp->ul_null_node)\n\t\treturn (NULL);\n\n\tnext = (wp->ulw_dir > 0)? np->uln_next : np->uln_prev;\n\n\twp->ulw_next_result = next;\n\treturn (np);\n}\n\nstatic void\nlist_walk_fini(uu_list_walk_t *wp)\n{\n\t \n\tif (wp->ulw_next != NULL) {\n\t\twp->ulw_next->ulw_prev = wp->ulw_prev;\n\t\twp->ulw_prev->ulw_next = wp->ulw_next;\n\t\twp->ulw_next = NULL;\n\t\twp->ulw_prev = NULL;\n\t}\n\twp->ulw_list = NULL;\n\twp->ulw_next_result = NULL;\n}\n\nuu_list_walk_t *\nuu_list_walk_start(uu_list_t *lp, uint32_t flags)\n{\n\tuu_list_walk_t *wp;\n\n\tif (flags & ~(UU_WALK_ROBUST | UU_WALK_REVERSE)) {\n\t\tuu_set_error(UU_ERROR_UNKNOWN_FLAG);\n\t\treturn (NULL);\n\t}\n\n\twp = uu_zalloc(sizeof (*wp));\n\tif (wp == NULL) {\n\t\tuu_set_error(UU_ERROR_NO_MEMORY);\n\t\treturn (NULL);\n\t}\n\n\tlist_walk_init(wp, lp, flags);\n\treturn (wp);\n}\n\nvoid *\nuu_list_walk_next(uu_list_walk_t *wp)\n{\n\tuu_list_t *lp = wp->ulw_list;\n\tuu_list_node_impl_t *np = list_walk_advance(wp, lp);\n\n\tif (np == NULL)\n\t\treturn (NULL);\n\n\treturn (NODE_TO_ELEM(lp, np));\n}\n\nvoid\nuu_list_walk_end(uu_list_walk_t *wp)\n{\n\tlist_walk_fini(wp);\n\tuu_free(wp);\n}\n\nint\nuu_list_walk(uu_list_t *lp, uu_walk_fn_t *func, void *private, uint32_t flags)\n{\n\tuu_list_node_impl_t *np;\n\n\tint status = UU_WALK_NEXT;\n\n\tint robust = (flags & UU_WALK_ROBUST);\n\tint reverse = (flags & UU_WALK_REVERSE);\n\n\tif (flags & ~(UU_WALK_ROBUST | UU_WALK_REVERSE)) {\n\t\tuu_set_error(UU_ERROR_UNKNOWN_FLAG);\n\t\treturn (-1);\n\t}\n\n\tif (lp->ul_debug || robust) {\n\t\tuu_list_walk_t my_walk;\n\t\tvoid *e;\n\n\t\tlist_walk_init(&my_walk, lp, flags);\n\t\twhile (status == UU_WALK_NEXT &&\n\t\t    (e = uu_list_walk_next(&my_walk)) != NULL)\n\t\t\tstatus = (*func)(e, private);\n\t\tlist_walk_fini(&my_walk);\n\t} else {\n\t\tif (!reverse) {\n\t\t\tfor (np = lp->ul_null_node.uln_next;\n\t\t\t    status == UU_WALK_NEXT && np != &lp->ul_null_node;\n\t\t\t    np = np->uln_next) {\n\t\t\t\tstatus = (*func)(NODE_TO_ELEM(lp, np), private);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (np = lp->ul_null_node.uln_prev;\n\t\t\t    status == UU_WALK_NEXT && np != &lp->ul_null_node;\n\t\t\t    np = np->uln_prev) {\n\t\t\t\tstatus = (*func)(NODE_TO_ELEM(lp, np), private);\n\t\t\t}\n\t\t}\n\t}\n\tif (status >= 0)\n\t\treturn (0);\n\tuu_set_error(UU_ERROR_CALLBACK_FAILED);\n\treturn (-1);\n}\n\nvoid\nuu_list_remove(uu_list_t *lp, void *elem)\n{\n\tuu_list_node_impl_t *np = ELEM_TO_NODE(lp, elem);\n\tuu_list_walk_t *wp;\n\n\tif (lp->ul_debug) {\n\t\tif (np->uln_prev == NULL)\n\t\t\tuu_panic(\"uu_list_remove(%p, %p): elem not on list\\n\",\n\t\t\t    (void *)lp, elem);\n\t\t \n\t\tlp->ul_index = INDEX_NEXT(lp->ul_index);\n\t}\n\n\t \n\tfor (wp = lp->ul_null_walk.ulw_next; wp != &lp->ul_null_walk;\n\t    wp = wp->ulw_next) {\n\t\tif (wp->ulw_robust) {\n\t\t\tif (np == wp->ulw_next_result)\n\t\t\t\t(void) list_walk_advance(wp, lp);\n\t\t} else if (wp->ulw_next_result != NULL) {\n\t\t\tuu_panic(\"uu_list_remove(%p, %p): active non-robust \"\n\t\t\t    \"walker\\n\", (void *)lp, elem);\n\t\t}\n\t}\n\n\tnp->uln_next->uln_prev = np->uln_prev;\n\tnp->uln_prev->uln_next = np->uln_next;\n\n\tlp->ul_numnodes--;\n\n\tnp->uln_next = POOL_TO_MARKER(lp->ul_pool);\n\tnp->uln_prev = NULL;\n}\n\nvoid *\nuu_list_teardown(uu_list_t *lp, void **cookie)\n{\n\tvoid *ep;\n\n\t \n\tif (lp->ul_debug && *cookie != NULL)\n\t\tuu_panic(\"uu_list_teardown(%p, %p): unexpected cookie\\n\",\n\t\t    (void *)lp, (void *)cookie);\n\n\tep = uu_list_first(lp);\n\tif (ep)\n\t\tuu_list_remove(lp, ep);\n\treturn (ep);\n}\n\nint\nuu_list_insert_before(uu_list_t *lp, void *target, void *elem)\n{\n\tuu_list_node_impl_t *np = ELEM_TO_NODE(lp, target);\n\n\tif (target == NULL)\n\t\tnp = &lp->ul_null_node;\n\n\tif (lp->ul_debug) {\n\t\tif (np->uln_prev == NULL)\n\t\t\tuu_panic(\"uu_list_insert_before(%p, %p, %p): %p is \"\n\t\t\t    \"not currently on a list\\n\",\n\t\t\t    (void *)lp, target, elem, target);\n\t}\n\tif (lp->ul_sorted) {\n\t\tif (lp->ul_debug)\n\t\t\tuu_panic(\"uu_list_insert_before(%p, ...): list is \"\n\t\t\t    \"UU_LIST_SORTED\\n\", (void *)lp);\n\t\tuu_set_error(UU_ERROR_NOT_SUPPORTED);\n\t\treturn (-1);\n\t}\n\n\tlist_insert(lp, ELEM_TO_NODE(lp, elem), np->uln_prev, np);\n\treturn (0);\n}\n\nint\nuu_list_insert_after(uu_list_t *lp, void *target, void *elem)\n{\n\tuu_list_node_impl_t *np = ELEM_TO_NODE(lp, target);\n\n\tif (target == NULL)\n\t\tnp = &lp->ul_null_node;\n\n\tif (lp->ul_debug) {\n\t\tif (np->uln_prev == NULL)\n\t\t\tuu_panic(\"uu_list_insert_after(%p, %p, %p): %p is \"\n\t\t\t    \"not currently on a list\\n\",\n\t\t\t    (void *)lp, target, elem, target);\n\t}\n\tif (lp->ul_sorted) {\n\t\tif (lp->ul_debug)\n\t\t\tuu_panic(\"uu_list_insert_after(%p, ...): list is \"\n\t\t\t    \"UU_LIST_SORTED\\n\", (void *)lp);\n\t\tuu_set_error(UU_ERROR_NOT_SUPPORTED);\n\t\treturn (-1);\n\t}\n\n\tlist_insert(lp, ELEM_TO_NODE(lp, elem), np, np->uln_next);\n\treturn (0);\n}\n\nsize_t\nuu_list_numnodes(uu_list_t *lp)\n{\n\treturn (lp->ul_numnodes);\n}\n\nvoid *\nuu_list_first(uu_list_t *lp)\n{\n\tuu_list_node_impl_t *n = lp->ul_null_node.uln_next;\n\tif (n == &lp->ul_null_node)\n\t\treturn (NULL);\n\treturn (NODE_TO_ELEM(lp, n));\n}\n\nvoid *\nuu_list_last(uu_list_t *lp)\n{\n\tuu_list_node_impl_t *n = lp->ul_null_node.uln_prev;\n\tif (n == &lp->ul_null_node)\n\t\treturn (NULL);\n\treturn (NODE_TO_ELEM(lp, n));\n}\n\nvoid *\nuu_list_next(uu_list_t *lp, void *elem)\n{\n\tuu_list_node_impl_t *n = ELEM_TO_NODE(lp, elem);\n\n\tn = n->uln_next;\n\tif (n == &lp->ul_null_node)\n\t\treturn (NULL);\n\treturn (NODE_TO_ELEM(lp, n));\n}\n\nvoid *\nuu_list_prev(uu_list_t *lp, void *elem)\n{\n\tuu_list_node_impl_t *n = ELEM_TO_NODE(lp, elem);\n\n\tn = n->uln_prev;\n\tif (n == &lp->ul_null_node)\n\t\treturn (NULL);\n\treturn (NODE_TO_ELEM(lp, n));\n}\n\n \nvoid\nuu_list_lockup(void)\n{\n\tuu_list_pool_t *pp;\n\n\t(void) pthread_mutex_lock(&uu_lpool_list_lock);\n\tfor (pp = uu_null_lpool.ulp_next; pp != &uu_null_lpool;\n\t    pp = pp->ulp_next)\n\t\t(void) pthread_mutex_lock(&pp->ulp_lock);\n}\n\nvoid\nuu_list_release(void)\n{\n\tuu_list_pool_t *pp;\n\n\tfor (pp = uu_null_lpool.ulp_next; pp != &uu_null_lpool;\n\t    pp = pp->ulp_next)\n\t\t(void) pthread_mutex_unlock(&pp->ulp_lock);\n\t(void) pthread_mutex_unlock(&uu_lpool_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}