{
  "module_name": "uu_misc.c",
  "hash_id": "83080dc156eace9e9ede3f187f49ead4cc8e77f96015eb7a3b1668b3c42148fe",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libuutil/uu_misc.c",
  "human_readable_source": " \n\n \n\n#include \"libuutil_common.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <libintl.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/debug.h>\n#include <unistd.h>\n#include <ctype.h>\n\n#if !defined(TEXT_DOMAIN)\n#define\tTEXT_DOMAIN \"SYS_TEST\"\n#endif\n\n \n\n#if defined(PTHREAD_ONCE_KEY_NP)\nstatic pthread_key_t\tuu_error_key = PTHREAD_ONCE_KEY_NP;\n#else\t \nstatic pthread_key_t\tuu_error_key = 0;\nstatic pthread_mutex_t\tuu_key_lock = PTHREAD_MUTEX_INITIALIZER;\n#endif\t \n\nstatic int\t\tuu_error_key_setup = 0;\n\nstatic pthread_mutex_t\tuu_panic_lock = PTHREAD_MUTEX_INITIALIZER;\n \nstatic const char\t*uu_panic_format;\n \nstatic va_list\t\tuu_panic_args;\nstatic pthread_t\tuu_panic_thread;\n\nstatic uint32_t\t\t_uu_main_error;\nstatic __thread int\t_uu_main_thread = 0;\n\nvoid\nuu_set_error(uint_t code)\n{\n\tif (_uu_main_thread) {\n\t\t_uu_main_error = code;\n\t\treturn;\n\t}\n#if defined(PTHREAD_ONCE_KEY_NP)\n\tif (pthread_key_create_once_np(&uu_error_key, NULL) != 0)\n\t\tuu_error_key_setup = -1;\n\telse\n\t\tuu_error_key_setup = 1;\n#else\t \n\tif (uu_error_key_setup == 0) {\n\t\t(void) pthread_mutex_lock(&uu_key_lock);\n\t\tif (uu_error_key_setup == 0) {\n\t\t\tif (pthread_key_create(&uu_error_key, NULL) != 0)\n\t\t\t\tuu_error_key_setup = -1;\n\t\t\telse\n\t\t\t\tuu_error_key_setup = 1;\n\t\t}\n\t\t(void) pthread_mutex_unlock(&uu_key_lock);\n\t}\n#endif\t \n\tif (uu_error_key_setup > 0)\n\t\t(void) pthread_setspecific(uu_error_key,\n\t\t    (void *)(uintptr_t)code);\n}\n\nuint32_t\nuu_error(void)\n{\n\tif (_uu_main_thread)\n\t\treturn (_uu_main_error);\n\n\tif (uu_error_key_setup < 0)\t \n\t\treturn (UU_ERROR_UNKNOWN);\n\n\t \n\treturn ((uint32_t)(uintptr_t)pthread_getspecific(uu_error_key));\n}\n\nconst char *\nuu_strerror(uint32_t code)\n{\n\tconst char *str;\n\n\tswitch (code) {\n\tcase UU_ERROR_NONE:\n\t\tstr = dgettext(TEXT_DOMAIN, \"No error\");\n\t\tbreak;\n\n\tcase UU_ERROR_INVALID_ARGUMENT:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Invalid argument\");\n\t\tbreak;\n\n\tcase UU_ERROR_UNKNOWN_FLAG:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Unknown flag passed\");\n\t\tbreak;\n\n\tcase UU_ERROR_NO_MEMORY:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Out of memory\");\n\t\tbreak;\n\n\tcase UU_ERROR_CALLBACK_FAILED:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Callback-initiated failure\");\n\t\tbreak;\n\n\tcase UU_ERROR_NOT_SUPPORTED:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Operation not supported\");\n\t\tbreak;\n\n\tcase UU_ERROR_EMPTY:\n\t\tstr = dgettext(TEXT_DOMAIN, \"No value provided\");\n\t\tbreak;\n\n\tcase UU_ERROR_UNDERFLOW:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Value too small\");\n\t\tbreak;\n\n\tcase UU_ERROR_OVERFLOW:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Value too large\");\n\t\tbreak;\n\n\tcase UU_ERROR_INVALID_CHAR:\n\t\tstr = dgettext(TEXT_DOMAIN,\n\t\t    \"Value contains unexpected character\");\n\t\tbreak;\n\n\tcase UU_ERROR_INVALID_DIGIT:\n\t\tstr = dgettext(TEXT_DOMAIN,\n\t\t    \"Value contains digit not in base\");\n\t\tbreak;\n\n\tcase UU_ERROR_SYSTEM:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Underlying system error\");\n\t\tbreak;\n\n\tcase UU_ERROR_UNKNOWN:\n\t\tstr = dgettext(TEXT_DOMAIN, \"Error status not known\");\n\t\tbreak;\n\n\tdefault:\n\t\terrno = ESRCH;\n\t\tstr = NULL;\n\t\tbreak;\n\t}\n\treturn (str);\n}\n\nvoid\nuu_panic(const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\n\t(void) pthread_mutex_lock(&uu_panic_lock);\n\tif (uu_panic_thread == 0) {\n\t\tuu_panic_thread = pthread_self();\n\t\tuu_panic_format = format;\n\t\tva_copy(uu_panic_args, args);\n\t}\n\t(void) pthread_mutex_unlock(&uu_panic_lock);\n\n\t(void) vfprintf(stderr, format, args);\n\n\tva_end(args);\n\n\tif (uu_panic_thread == pthread_self())\n\t\tabort();\n\telse\n\t\tfor (;;)\n\t\t\t(void) pause();\n}\n\nstatic void\nuu_lockup(void)\n{\n\t(void) pthread_mutex_lock(&uu_panic_lock);\n#if !defined(PTHREAD_ONCE_KEY_NP)\n\t(void) pthread_mutex_lock(&uu_key_lock);\n#endif\n\tuu_avl_lockup();\n\tuu_list_lockup();\n}\n\nstatic void\nuu_release(void)\n{\n\t(void) pthread_mutex_unlock(&uu_panic_lock);\n#if !defined(PTHREAD_ONCE_KEY_NP)\n\t(void) pthread_mutex_unlock(&uu_key_lock);\n#endif\n\tuu_avl_release();\n\tuu_list_release();\n}\n\nstatic void\nuu_release_child(void)\n{\n\tuu_panic_format = NULL;\n\tuu_panic_thread = 0;\n\n\tuu_release();\n}\n\n#ifdef __GNUC__\nstatic void\nuu_init(void) __attribute__((constructor));\n#else\n#pragma init(uu_init)\n#endif\n\nstatic void\nuu_init(void)\n{\n\t_uu_main_thread = 1;\n\t(void) pthread_atfork(uu_lockup, uu_release, uu_release_child);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}