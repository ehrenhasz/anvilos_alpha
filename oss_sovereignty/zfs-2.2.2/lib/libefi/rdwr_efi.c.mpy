{
  "module_name": "rdwr_efi.c",
  "hash_id": "1120cd738a15d6afdcc408ce9c52b846499798f6e8a91cfc879c73f6dca0ad50",
  "original_prompt": "Ingested from zfs-2.2.2/lib/libefi/rdwr_efi.c",
  "human_readable_source": " \n\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <uuid/uuid.h>\n#include <zlib.h>\n#include <libintl.h>\n#include <sys/types.h>\n#include <sys/dkio.h>\n#include <sys/mhd.h>\n#include <sys/param.h>\n#include <sys/dktp/fdisk.h>\n#include <sys/efi_partition.h>\n#include <sys/byteorder.h>\n#include <sys/vdev_disk.h>\n#include <linux/fs.h>\n#include <linux/blkpg.h>\n\nstatic struct uuid_to_ptag {\n\tstruct uuid\tuuid;\n} conversion_array[] = {\n\t{ EFI_UNUSED },\n\t{ EFI_BOOT },\n\t{ EFI_ROOT },\n\t{ EFI_SWAP },\n\t{ EFI_USR },\n\t{ EFI_BACKUP },\n\t{ EFI_UNUSED },\t\t \n\t{ EFI_VAR },\n\t{ EFI_HOME },\n\t{ EFI_ALTSCTR },\n\t{ EFI_UNUSED },\t\t \n\t{ EFI_RESERVED },\n\t{ EFI_SYSTEM },\n\t{ EFI_LEGACY_MBR },\n\t{ EFI_SYMC_PUB },\n\t{ EFI_SYMC_CDS },\n\t{ EFI_MSFT_RESV },\n\t{ EFI_DELL_BASIC },\n\t{ EFI_DELL_RAID },\n\t{ EFI_DELL_SWAP },\n\t{ EFI_DELL_LVM },\n\t{ EFI_DELL_RESV },\n\t{ EFI_AAPL_HFS },\n\t{ EFI_AAPL_UFS },\n\t{ EFI_FREEBSD_BOOT },\n\t{ EFI_FREEBSD_SWAP },\n\t{ EFI_FREEBSD_UFS },\n\t{ EFI_FREEBSD_VINUM },\n\t{ EFI_FREEBSD_ZFS },\n\t{ EFI_BIOS_BOOT },\n\t{ EFI_INTC_RS },\n\t{ EFI_SNE_BOOT },\n\t{ EFI_LENOVO_BOOT },\n\t{ EFI_MSFT_LDMM },\n\t{ EFI_MSFT_LDMD },\n\t{ EFI_MSFT_RE },\n\t{ EFI_IBM_GPFS },\n\t{ EFI_MSFT_STORAGESPACES },\n\t{ EFI_HPQ_DATA },\n\t{ EFI_HPQ_SVC },\n\t{ EFI_RHT_DATA },\n\t{ EFI_RHT_HOME },\n\t{ EFI_RHT_SRV },\n\t{ EFI_RHT_DMCRYPT },\n\t{ EFI_RHT_LUKS },\n\t{ EFI_FREEBSD_DISKLABEL },\n\t{ EFI_AAPL_RAID },\n\t{ EFI_AAPL_RAIDOFFLINE },\n\t{ EFI_AAPL_BOOT },\n\t{ EFI_AAPL_LABEL },\n\t{ EFI_AAPL_TVRECOVERY },\n\t{ EFI_AAPL_CORESTORAGE },\n\t{ EFI_NETBSD_SWAP },\n\t{ EFI_NETBSD_FFS },\n\t{ EFI_NETBSD_LFS },\n\t{ EFI_NETBSD_RAID },\n\t{ EFI_NETBSD_CAT },\n\t{ EFI_NETBSD_CRYPT },\n\t{ EFI_GOOG_KERN },\n\t{ EFI_GOOG_ROOT },\n\t{ EFI_GOOG_RESV },\n\t{ EFI_HAIKU_BFS },\n\t{ EFI_MIDNIGHTBSD_BOOT },\n\t{ EFI_MIDNIGHTBSD_DATA },\n\t{ EFI_MIDNIGHTBSD_SWAP },\n\t{ EFI_MIDNIGHTBSD_UFS },\n\t{ EFI_MIDNIGHTBSD_VINUM },\n\t{ EFI_MIDNIGHTBSD_ZFS },\n\t{ EFI_CEPH_JOURNAL },\n\t{ EFI_CEPH_DMCRYPTJOURNAL },\n\t{ EFI_CEPH_OSD },\n\t{ EFI_CEPH_DMCRYPTOSD },\n\t{ EFI_CEPH_CREATE },\n\t{ EFI_CEPH_DMCRYPTCREATE },\n\t{ EFI_OPENBSD_DISKLABEL },\n\t{ EFI_BBRY_QNX },\n\t{ EFI_BELL_PLAN9 },\n\t{ EFI_VMW_KCORE },\n\t{ EFI_VMW_VMFS },\n\t{ EFI_VMW_RESV },\n\t{ EFI_RHT_ROOTX86 },\n\t{ EFI_RHT_ROOTAMD64 },\n\t{ EFI_RHT_ROOTARM },\n\t{ EFI_RHT_ROOTARM64 },\n\t{ EFI_ACRONIS_SECUREZONE },\n\t{ EFI_ONIE_BOOT },\n\t{ EFI_ONIE_CONFIG },\n\t{ EFI_IBM_PPRPBOOT },\n\t{ EFI_FREEDESKTOP_BOOT }\n};\n\nint efi_debug = 0;\n\nstatic int efi_read(int, struct dk_gpt *);\n\n \nstatic uint32_t\nefi_crc32(const unsigned char *buf, unsigned int size)\n{\n\tuint32_t crc = crc32(0, Z_NULL, 0);\n\n\tcrc = crc32(crc, buf, size);\n\n\treturn (crc);\n}\n\nstatic int\nread_disk_info(int fd, diskaddr_t *capacity, uint_t *lbsize)\n{\n\tint sector_size;\n\tunsigned long long capacity_size;\n\n\tif (ioctl(fd, BLKSSZGET, &sector_size) < 0)\n\t\treturn (-1);\n\n\tif (ioctl(fd, BLKGETSIZE64, &capacity_size) < 0)\n\t\treturn (-1);\n\n\t*lbsize = (uint_t)sector_size;\n\t*capacity = (diskaddr_t)(capacity_size / sector_size);\n\n\treturn (0);\n}\n\n \nstatic char *\nefi_get_devname(int fd)\n{\n\tchar path[32];\n\n\t \n\t(void) snprintf(path, sizeof (path), \"/proc/self/fd/%d\", fd);\n\treturn (realpath(path, NULL));\n}\n\nstatic int\nefi_get_info(int fd, struct dk_cinfo *dki_info)\n{\n\tchar *dev_path;\n\tint rval = 0;\n\n\tmemset(dki_info, 0, sizeof (*dki_info));\n\n\t \n\tdev_path = efi_get_devname(fd);\n\tif (dev_path == NULL)\n\t\tgoto error;\n\n\tif ((strncmp(dev_path, \"/dev/sd\", 7) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"sd\");\n\t\tdki_info->dki_ctype = DKC_SCSI_CCS;\n\t\trval = sscanf(dev_path, \"/dev/%[a-zA-Z]%hu\",\n\t\t    dki_info->dki_dname,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/hd\", 7) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"hd\");\n\t\tdki_info->dki_ctype = DKC_DIRECT;\n\t\trval = sscanf(dev_path, \"/dev/%[a-zA-Z]%hu\",\n\t\t    dki_info->dki_dname,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/md\", 7) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"pseudo\");\n\t\tdki_info->dki_ctype = DKC_MD;\n\t\tstrcpy(dki_info->dki_dname, \"md\");\n\t\trval = sscanf(dev_path, \"/dev/md%[0-9]p%hu\",\n\t\t    dki_info->dki_dname + 2,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/vd\", 7) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"vd\");\n\t\tdki_info->dki_ctype = DKC_MD;\n\t\trval = sscanf(dev_path, \"/dev/%[a-zA-Z]%hu\",\n\t\t    dki_info->dki_dname,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/xvd\", 8) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"xvd\");\n\t\tdki_info->dki_ctype = DKC_MD;\n\t\trval = sscanf(dev_path, \"/dev/%[a-zA-Z]%hu\",\n\t\t    dki_info->dki_dname,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/zd\", 7) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"zd\");\n\t\tdki_info->dki_ctype = DKC_MD;\n\t\tstrcpy(dki_info->dki_dname, \"zd\");\n\t\trval = sscanf(dev_path, \"/dev/zd%[0-9]p%hu\",\n\t\t    dki_info->dki_dname + 2,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/dm-\", 8) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"pseudo\");\n\t\tdki_info->dki_ctype = DKC_VBD;\n\t\tstrcpy(dki_info->dki_dname, \"dm-\");\n\t\trval = sscanf(dev_path, \"/dev/dm-%[0-9]p%hu\",\n\t\t    dki_info->dki_dname + 3,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/ram\", 8) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"pseudo\");\n\t\tdki_info->dki_ctype = DKC_PCMCIA_MEM;\n\t\tstrcpy(dki_info->dki_dname, \"ram\");\n\t\trval = sscanf(dev_path, \"/dev/ram%[0-9]p%hu\",\n\t\t    dki_info->dki_dname + 3,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/loop\", 9) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"pseudo\");\n\t\tdki_info->dki_ctype = DKC_VBD;\n\t\tstrcpy(dki_info->dki_dname, \"loop\");\n\t\trval = sscanf(dev_path, \"/dev/loop%[0-9]p%hu\",\n\t\t    dki_info->dki_dname + 4,\n\t\t    &dki_info->dki_partition);\n\t} else if ((strncmp(dev_path, \"/dev/nvme\", 9) == 0)) {\n\t\tstrcpy(dki_info->dki_cname, \"nvme\");\n\t\tdki_info->dki_ctype = DKC_SCSI_CCS;\n\t\tstrcpy(dki_info->dki_dname, \"nvme\");\n\t\t(void) sscanf(dev_path, \"/dev/nvme%[0-9]\",\n\t\t    dki_info->dki_dname + 4);\n\t\tsize_t controller_length = strlen(\n\t\t    dki_info->dki_dname);\n\t\tstrcpy(dki_info->dki_dname + controller_length,\n\t\t    \"n\");\n\t\trval = sscanf(dev_path,\n\t\t    \"/dev/nvme%*[0-9]n%[0-9]p%hu\",\n\t\t    dki_info->dki_dname + controller_length + 1,\n\t\t    &dki_info->dki_partition);\n\t} else {\n\t\tstrcpy(dki_info->dki_dname, \"unknown\");\n\t\tstrcpy(dki_info->dki_cname, \"unknown\");\n\t\tdki_info->dki_ctype = DKC_UNKNOWN;\n\t}\n\n\tswitch (rval) {\n\tcase 0:\n\t\terrno = EINVAL;\n\t\tgoto error;\n\tcase 1:\n\t\tdki_info->dki_partition = 0;\n\t}\n\n\tfree(dev_path);\n\n\treturn (0);\nerror:\n\tif (efi_debug)\n\t\t(void) fprintf(stderr, \"DKIOCINFO errno 0x%x\\n\", errno);\n\n\tswitch (errno) {\n\tcase EIO:\n\t\treturn (VT_EIO);\n\tcase EINVAL:\n\t\treturn (VT_EINVAL);\n\tdefault:\n\t\treturn (VT_ERROR);\n\t}\n}\n\n \n#define\tNBLOCKS(p, l)\t(1 + ((((p) * (int)sizeof (efi_gpe_t))  + \\\n\t\t\t\t((l) - 1)) / (l)))\n \n#define\tMAX_PARTS\t((4294967295UL - sizeof (struct dk_gpt)) / \\\n\t\t\t    sizeof (struct dk_part))\n\nint\nefi_alloc_and_init(int fd, uint32_t nparts, struct dk_gpt **vtoc)\n{\n\tdiskaddr_t\tcapacity = 0;\n\tuint_t\t\tlbsize = 0;\n\tuint_t\t\tnblocks;\n\tsize_t\t\tlength;\n\tstruct dk_gpt\t*vptr;\n\tstruct uuid\tuuid;\n\tstruct dk_cinfo\tdki_info;\n\n\tif (read_disk_info(fd, &capacity, &lbsize) != 0)\n\t\treturn (-1);\n\n\tif (efi_get_info(fd, &dki_info) != 0)\n\t\treturn (-1);\n\n\tif (dki_info.dki_partition != 0)\n\t\treturn (-1);\n\n\tif ((dki_info.dki_ctype == DKC_PCMCIA_MEM) ||\n\t    (dki_info.dki_ctype == DKC_VBD) ||\n\t    (dki_info.dki_ctype == DKC_UNKNOWN))\n\t\treturn (-1);\n\n\tnblocks = NBLOCKS(nparts, lbsize);\n\tif ((nblocks * lbsize) < EFI_MIN_ARRAY_SIZE + lbsize) {\n\t\t \n\t\tnblocks = EFI_MIN_ARRAY_SIZE / lbsize + 1;\n\t}\n\n\tif (nparts > MAX_PARTS) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t\"the maximum number of partitions supported is %lu\\n\",\n\t\t\t    MAX_PARTS);\n\t\t}\n\t\treturn (-1);\n\t}\n\n\tlength = sizeof (struct dk_gpt) +\n\t    sizeof (struct dk_part) * (nparts - 1);\n\n\tvptr = calloc(1, length);\n\tif (vptr == NULL)\n\t\treturn (-1);\n\n\t*vtoc = vptr;\n\n\tvptr->efi_version = EFI_VERSION_CURRENT;\n\tvptr->efi_lbasize = lbsize;\n\tvptr->efi_nparts = nparts;\n\t \n\tvptr->efi_first_u_lba = nblocks + 1;\n\tvptr->efi_last_lba = capacity - 1;\n\tvptr->efi_altern_lba = capacity -1;\n\tvptr->efi_last_u_lba = vptr->efi_last_lba - nblocks;\n\n\t(void) uuid_generate((uchar_t *)&uuid);\n\tUUID_LE_CONVERT(vptr->efi_disk_uguid, uuid);\n\treturn (0);\n}\n\n \nint\nefi_alloc_and_read(int fd, struct dk_gpt **vtoc)\n{\n\tint\t\t\trval;\n\tuint32_t\t\tnparts;\n\tint\t\t\tlength;\n\tstruct dk_gpt\t\t*vptr;\n\n\t \n\tnparts = EFI_MIN_ARRAY_SIZE / sizeof (efi_gpe_t);\n\tlength = (int) sizeof (struct dk_gpt) +\n\t    (int) sizeof (struct dk_part) * (nparts - 1);\n\tvptr = calloc(1, length);\n\n\tif (vptr == NULL)\n\t\treturn (VT_ERROR);\n\n\tvptr->efi_nparts = nparts;\n\trval = efi_read(fd, vptr);\n\n\tif ((rval == VT_EINVAL) && vptr->efi_nparts > nparts) {\n\t\tvoid *tmp;\n\t\tlength = (int) sizeof (struct dk_gpt) +\n\t\t    (int) sizeof (struct dk_part) * (vptr->efi_nparts - 1);\n\t\tif ((tmp = realloc(vptr, length)) == NULL) {\n\t\t\t \n\t\t\tfree(vptr);\n\t\t\t*vtoc = NULL;\n\t\t\treturn (VT_ERROR);\n\t\t} else {\n\t\t\tvptr = tmp;\n\t\t\trval = efi_read(fd, vptr);\n\t\t}\n\t}\n\n\tif (rval < 0) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"read of EFI table failed, rval=%d\\n\", rval);\n\t\t}\n\t\tfree(vptr);\n\t\t*vtoc = NULL;\n\t} else {\n\t\t*vtoc = vptr;\n\t}\n\n\treturn (rval);\n}\n\nstatic int\nefi_ioctl(int fd, int cmd, dk_efi_t *dk_ioc)\n{\n\tvoid *data = dk_ioc->dki_data;\n\tint error;\n\tdiskaddr_t capacity;\n\tuint_t lbsize;\n\n\t \n\tif (read_disk_info(fd, &capacity, &lbsize) == -1) {\n\t\tif (efi_debug)\n\t\t\tfprintf(stderr, \"unable to read disk info: %d\", errno);\n\n\t\terrno = EIO;\n\t\treturn (-1);\n\t}\n\n\tswitch (cmd) {\n\tcase DKIOCGETEFI:\n\t\tif (lbsize == 0) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCGETEFI assuming \"\n\t\t\t\t    \"LBA %d bytes\\n\", DEV_BSIZE);\n\n\t\t\tlbsize = DEV_BSIZE;\n\t\t}\n\n\t\terror = lseek(fd, dk_ioc->dki_lba * lbsize, SEEK_SET);\n\t\tif (error == -1) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCGETEFI lseek \"\n\t\t\t\t    \"error: %d\\n\", errno);\n\t\t\treturn (error);\n\t\t}\n\n\t\terror = read(fd, data, dk_ioc->dki_length);\n\t\tif (error == -1) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCGETEFI read \"\n\t\t\t\t    \"error: %d\\n\", errno);\n\t\t\treturn (error);\n\t\t}\n\n\t\tif (error != dk_ioc->dki_length) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCGETEFI short \"\n\t\t\t\t    \"read of %d bytes\\n\", error);\n\t\t\terrno = EIO;\n\t\t\treturn (-1);\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\n\tcase DKIOCSETEFI:\n\t\tif (lbsize == 0) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCSETEFI unknown \"\n\t\t\t\t    \"LBA size\\n\");\n\t\t\terrno = EIO;\n\t\t\treturn (-1);\n\t\t}\n\n\t\terror = lseek(fd, dk_ioc->dki_lba * lbsize, SEEK_SET);\n\t\tif (error == -1) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCSETEFI lseek \"\n\t\t\t\t    \"error: %d\\n\", errno);\n\t\t\treturn (error);\n\t\t}\n\n\t\terror = write(fd, data, dk_ioc->dki_length);\n\t\tif (error == -1) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCSETEFI write \"\n\t\t\t\t    \"error: %d\\n\", errno);\n\t\t\treturn (error);\n\t\t}\n\n\t\tif (error != dk_ioc->dki_length) {\n\t\t\tif (efi_debug)\n\t\t\t\t(void) fprintf(stderr, \"DKIOCSETEFI short \"\n\t\t\t\t    \"write of %d bytes\\n\", error);\n\t\t\terrno = EIO;\n\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\terror = fsync(fd);\n\t\tif (error == -1)\n\t\t\treturn (error);\n\n\t\t \n\t\tif (ioctl(fd, BLKFLSBUF, 0) == -1)\n\t\t\treturn (error);\n\n\t\terror = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (efi_debug)\n\t\t\t(void) fprintf(stderr, \"unsupported ioctl()\\n\");\n\n\t\terrno = EIO;\n\t\treturn (-1);\n\t}\n\n\treturn (error);\n}\n\nint\nefi_rescan(int fd)\n{\n\tint retry = 10;\n\n\t \n\twhile (ioctl(fd, BLKRRPART) != 0) {\n\t\tif ((--retry == 0) || (errno != EBUSY)) {\n\t\t\t(void) fprintf(stderr, \"the kernel failed to rescan \"\n\t\t\t    \"the partition table: %d\\n\", errno);\n\t\t\treturn (-1);\n\t\t}\n\t\tusleep(50000);\n\t}\n\n\treturn (0);\n}\n\nstatic int\ncheck_label(int fd, dk_efi_t *dk_ioc)\n{\n\tefi_gpt_t\t\t*efi;\n\tuint_t\t\t\tcrc;\n\n\tif (efi_ioctl(fd, DKIOCGETEFI, dk_ioc) == -1) {\n\t\tswitch (errno) {\n\t\tcase EIO:\n\t\t\treturn (VT_EIO);\n\t\tdefault:\n\t\t\treturn (VT_ERROR);\n\t\t}\n\t}\n\tefi = dk_ioc->dki_data;\n\tif (efi->efi_gpt_Signature != LE_64(EFI_SIGNATURE)) {\n\t\tif (efi_debug)\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Bad EFI signature: 0x%llx != 0x%llx\\n\",\n\t\t\t    (long long)efi->efi_gpt_Signature,\n\t\t\t    (long long)LE_64(EFI_SIGNATURE));\n\t\treturn (VT_EINVAL);\n\t}\n\n\t \n\tcrc = efi->efi_gpt_HeaderCRC32;\n\tefi->efi_gpt_HeaderCRC32 = 0;\n\tlen_t headerSize = (len_t)LE_32(efi->efi_gpt_HeaderSize);\n\n\tif (headerSize < EFI_MIN_LABEL_SIZE || headerSize > EFI_LABEL_SIZE) {\n\t\tif (efi_debug)\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Invalid EFI HeaderSize %llu.  Assuming %d.\\n\",\n\t\t\t    headerSize, EFI_MIN_LABEL_SIZE);\n\t}\n\n\tif ((headerSize > dk_ioc->dki_length) ||\n\t    crc != LE_32(efi_crc32((unsigned char *)efi, headerSize))) {\n\t\tif (efi_debug)\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Bad EFI CRC: 0x%x != 0x%x\\n\",\n\t\t\t    crc, LE_32(efi_crc32((unsigned char *)efi,\n\t\t\t    headerSize)));\n\t\treturn (VT_EINVAL);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nefi_read(int fd, struct dk_gpt *vtoc)\n{\n\tint\t\t\ti, j;\n\tint\t\t\tlabel_len;\n\tint\t\t\trval = 0;\n\tint\t\t\tmd_flag = 0;\n\tint\t\t\tvdc_flag = 0;\n\tdiskaddr_t\t\tcapacity = 0;\n\tuint_t\t\t\tlbsize = 0;\n\tstruct dk_minfo\t\tdisk_info;\n\tdk_efi_t\t\tdk_ioc;\n\tefi_gpt_t\t\t*efi;\n\tefi_gpe_t\t\t*efi_parts;\n\tstruct dk_cinfo\t\tdki_info;\n\tuint32_t\t\tuser_length;\n\tboolean_t\t\tlegacy_label = B_FALSE;\n\n\t \n\tif ((rval = efi_get_info(fd, &dki_info)) != 0)\n\t\treturn (rval);\n\n\tif ((strncmp(dki_info.dki_cname, \"pseudo\", 7) == 0) &&\n\t    (strncmp(dki_info.dki_dname, \"md\", 3) == 0)) {\n\t\tmd_flag++;\n\t} else if ((strncmp(dki_info.dki_cname, \"vdc\", 4) == 0) &&\n\t    (strncmp(dki_info.dki_dname, \"vdc\", 4) == 0)) {\n\t\t \n\t\tvdc_flag++;\n\t}\n\n\t \n\tif (read_disk_info(fd, &capacity, &lbsize) == -1) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"unable to read disk info: %d\",\n\t\t\t    errno);\n\t\t}\n\t\treturn (VT_EINVAL);\n\t}\n\n\tdisk_info.dki_lbsize = lbsize;\n\tdisk_info.dki_capacity = capacity;\n\n\tif (disk_info.dki_lbsize == 0) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"efi_read: assuming LBA 512 bytes\\n\");\n\t\t}\n\t\tdisk_info.dki_lbsize = DEV_BSIZE;\n\t}\n\t \n\tdk_ioc.dki_lba = 1;\n\tif (NBLOCKS(vtoc->efi_nparts, disk_info.dki_lbsize) < 34) {\n\t\tlabel_len = EFI_MIN_ARRAY_SIZE + disk_info.dki_lbsize;\n\t} else {\n\t\tlabel_len = vtoc->efi_nparts * (int) sizeof (efi_gpe_t) +\n\t\t    disk_info.dki_lbsize;\n\t\tif (label_len % disk_info.dki_lbsize) {\n\t\t\t \n\t\t\tlabel_len += disk_info.dki_lbsize;\n\t\t\tlabel_len &= ~(disk_info.dki_lbsize - 1);\n\t\t}\n\t}\n\n\tif (posix_memalign((void **)&dk_ioc.dki_data,\n\t    disk_info.dki_lbsize, label_len))\n\t\treturn (VT_ERROR);\n\n\tmemset(dk_ioc.dki_data, 0, label_len);\n\tdk_ioc.dki_length = disk_info.dki_lbsize;\n\tuser_length = vtoc->efi_nparts;\n\tefi = dk_ioc.dki_data;\n\tif (md_flag) {\n\t\tdk_ioc.dki_length = label_len;\n\t\tif (efi_ioctl(fd, DKIOCGETEFI, &dk_ioc) == -1) {\n\t\t\tswitch (errno) {\n\t\t\tcase EIO:\n\t\t\t\treturn (VT_EIO);\n\t\t\tdefault:\n\t\t\t\treturn (VT_ERROR);\n\t\t\t}\n\t\t}\n\t} else if ((rval = check_label(fd, &dk_ioc)) == VT_EINVAL) {\n\t\t \n\n\t\t \n\t\tdk_ioc.dki_lba = disk_info.dki_capacity - 2;\n\t\tdk_ioc.dki_length = disk_info.dki_lbsize;\n\t\trval = check_label(fd, &dk_ioc);\n\t\tif (rval == VT_EINVAL) {\n\t\t\t \n\t\t\tdk_ioc.dki_lba = disk_info.dki_capacity - 1;\n\t\t\tdk_ioc.dki_length = disk_info.dki_lbsize;\n\t\t\trval = check_label(fd, &dk_ioc);\n\t\t\tif (rval == 0) {\n\t\t\t\tlegacy_label = B_TRUE;\n\t\t\t\tif (efi_debug)\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    \"efi_read: primary label corrupt; \"\n\t\t\t\t\t    \"using EFI backup label located on\"\n\t\t\t\t\t    \" the last block\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif ((efi_debug) && (rval == 0))\n\t\t\t\t(void) fprintf(stderr, \"efi_read: primary label\"\n\t\t\t\t    \" corrupt; using legacy EFI backup label \"\n\t\t\t\t    \" located on the next to last block\\n\");\n\t\t}\n\n\t\tif (rval == 0) {\n\t\t\tdk_ioc.dki_lba = LE_64(efi->efi_gpt_PartitionEntryLBA);\n\t\t\tvtoc->efi_flags |= EFI_GPT_PRIMARY_CORRUPT;\n\t\t\tvtoc->efi_nparts =\n\t\t\t    LE_32(efi->efi_gpt_NumberOfPartitionEntries);\n\t\t\t \n\t\t\t \n\t\t\tdk_ioc.dki_data = (efi_gpt_t *)((char *)dk_ioc.dki_data\n\t\t\t    + disk_info.dki_lbsize);\n\t\t\tif (legacy_label)\n\t\t\t\tdk_ioc.dki_length = disk_info.dki_capacity - 1 -\n\t\t\t\t    dk_ioc.dki_lba;\n\t\t\telse\n\t\t\t\tdk_ioc.dki_length = disk_info.dki_capacity - 2 -\n\t\t\t\t    dk_ioc.dki_lba;\n\t\t\tdk_ioc.dki_length *= disk_info.dki_lbsize;\n\t\t\tif (dk_ioc.dki_length >\n\t\t\t    ((len_t)label_len - sizeof (*dk_ioc.dki_data))) {\n\t\t\t\trval = VT_EINVAL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trval = efi_ioctl(fd, DKIOCGETEFI, &dk_ioc);\n\t\t\t}\n\t\t}\n\n\t} else if (rval == 0) {\n\n\t\tdk_ioc.dki_lba = LE_64(efi->efi_gpt_PartitionEntryLBA);\n\t\t \n\t\tdk_ioc.dki_data = (efi_gpt_t *)((char *)dk_ioc.dki_data\n\t\t    + disk_info.dki_lbsize);\n\t\tdk_ioc.dki_length = label_len - disk_info.dki_lbsize;\n\t\trval = efi_ioctl(fd, DKIOCGETEFI, &dk_ioc);\n\n\t} else if (vdc_flag && rval == VT_ERROR && errno == EINVAL) {\n\t\t \n\t\tdk_ioc.dki_lba = 1;\n\t\tdk_ioc.dki_length = label_len;\n\t\trval = check_label(fd, &dk_ioc);\n\t}\n\n\tif (rval < 0) {\n\t\tfree(efi);\n\t\treturn (rval);\n\t}\n\n\t \n\tefi_parts = (efi_gpe_t *)(((char *)efi) + disk_info.dki_lbsize);\n\n\t \n\tvtoc->efi_version = LE_32(efi->efi_gpt_Revision);\n\tvtoc->efi_nparts = LE_32(efi->efi_gpt_NumberOfPartitionEntries);\n\tvtoc->efi_part_size = LE_32(efi->efi_gpt_SizeOfPartitionEntry);\n\tvtoc->efi_lbasize = disk_info.dki_lbsize;\n\tvtoc->efi_last_lba = disk_info.dki_capacity - 1;\n\tvtoc->efi_first_u_lba = LE_64(efi->efi_gpt_FirstUsableLBA);\n\tvtoc->efi_last_u_lba = LE_64(efi->efi_gpt_LastUsableLBA);\n\tvtoc->efi_altern_lba = LE_64(efi->efi_gpt_AlternateLBA);\n\tUUID_LE_CONVERT(vtoc->efi_disk_uguid, efi->efi_gpt_DiskGUID);\n\n\t \n\tif (user_length < vtoc->efi_nparts) {\n\t\treturn (VT_EINVAL);\n\t}\n\n\tfor (i = 0; i < vtoc->efi_nparts; i++) {\n\t\tUUID_LE_CONVERT(vtoc->efi_parts[i].p_guid,\n\t\t    efi_parts[i].efi_gpe_PartitionTypeGUID);\n\n\t\tfor (j = 0;\n\t\t    j < sizeof (conversion_array)\n\t\t    / sizeof (struct uuid_to_ptag); j++) {\n\n\t\t\tif (memcmp(&vtoc->efi_parts[i].p_guid,\n\t\t\t    &conversion_array[j].uuid,\n\t\t\t    sizeof (struct uuid)) == 0) {\n\t\t\t\tvtoc->efi_parts[i].p_tag = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (vtoc->efi_parts[i].p_tag == V_UNASSIGNED)\n\t\t\tcontinue;\n\t\tvtoc->efi_parts[i].p_flag =\n\t\t    LE_16(efi_parts[i].efi_gpe_Attributes.PartitionAttrs);\n\t\tvtoc->efi_parts[i].p_start =\n\t\t    LE_64(efi_parts[i].efi_gpe_StartingLBA);\n\t\tvtoc->efi_parts[i].p_size =\n\t\t    LE_64(efi_parts[i].efi_gpe_EndingLBA) -\n\t\t    vtoc->efi_parts[i].p_start + 1;\n\t\tfor (j = 0; j < EFI_PART_NAME_LEN; j++) {\n\t\t\tvtoc->efi_parts[i].p_name[j] =\n\t\t\t    (uchar_t)LE_16(\n\t\t\t    efi_parts[i].efi_gpe_PartitionName[j]);\n\t\t}\n\n\t\tUUID_LE_CONVERT(vtoc->efi_parts[i].p_uguid,\n\t\t    efi_parts[i].efi_gpe_UniquePartitionGUID);\n\t}\n\tfree(efi);\n\n\treturn (dki_info.dki_partition);\n}\n\n \nstatic int\nwrite_pmbr(int fd, struct dk_gpt *vtoc)\n{\n\tdk_efi_t\tdk_ioc;\n\tstruct mboot\tmb;\n\tuchar_t\t\t*cp;\n\tdiskaddr_t\tsize_in_lba;\n\tuchar_t\t\t*buf;\n\tint\t\tlen;\n\n\tlen = (vtoc->efi_lbasize == 0) ? sizeof (mb) : vtoc->efi_lbasize;\n\tif (posix_memalign((void **)&buf, len, len))\n\t\treturn (VT_ERROR);\n\n\t \n\tmemset(buf, 0, len);\n\tdk_ioc.dki_lba = 0;\n\tdk_ioc.dki_length = len;\n\t \n\tdk_ioc.dki_data = (efi_gpt_t *)buf;\n\tif (efi_ioctl(fd, DKIOCGETEFI, &dk_ioc) == -1) {\n\t\tmemset(&mb, 0, sizeof (mb));\n\t\tmb.signature = LE_16(MBB_MAGIC);\n\t} else {\n\t\t(void) memcpy(&mb, buf, sizeof (mb));\n\t\tif (mb.signature != LE_16(MBB_MAGIC)) {\n\t\t\tmemset(&mb, 0, sizeof (mb));\n\t\t\tmb.signature = LE_16(MBB_MAGIC);\n\t\t}\n\t}\n\n\tmemset(&mb.parts, 0, sizeof (mb.parts));\n\tcp = (uchar_t *)&mb.parts[0];\n\t \n\t*cp++ = 0;\n\t \n\t*cp++ = 0xff;\n\t*cp++ = 0xff;\n\t*cp++ = 0xff;\n\t \n\t*cp++ = EFI_PMBR;\n\t \n\t*cp++ = 0xff;\n\t*cp++ = 0xff;\n\t*cp++ = 0xff;\n\t \n\t*cp++ = 0x01;\n\t*cp++ = 0x00;\n\t*cp++ = 0x00;\n\t*cp++ = 0x00;\n\t \n\tsize_in_lba = vtoc->efi_last_lba;\n\tif (size_in_lba < 0xffffffff) {\n\t\t*cp++ = (size_in_lba & 0x000000ff);\n\t\t*cp++ = (size_in_lba & 0x0000ff00) >> 8;\n\t\t*cp++ = (size_in_lba & 0x00ff0000) >> 16;\n\t\t*cp++ = (size_in_lba & 0xff000000) >> 24;\n\t} else {\n\t\t*cp++ = 0xff;\n\t\t*cp++ = 0xff;\n\t\t*cp++ = 0xff;\n\t\t*cp++ = 0xff;\n\t}\n\n\t(void) memcpy(buf, &mb, sizeof (mb));\n\t \n\tdk_ioc.dki_data = (efi_gpt_t *)buf;\n\tdk_ioc.dki_lba = 0;\n\tdk_ioc.dki_length = len;\n\tif (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {\n\t\tfree(buf);\n\t\tswitch (errno) {\n\t\tcase EIO:\n\t\t\treturn (VT_EIO);\n\t\tcase EINVAL:\n\t\t\treturn (VT_EINVAL);\n\t\tdefault:\n\t\t\treturn (VT_ERROR);\n\t\t}\n\t}\n\tfree(buf);\n\treturn (0);\n}\n\n \nstatic int\ncheck_input(struct dk_gpt *vtoc)\n{\n\tint\t\t\tresv_part = -1;\n\tint\t\t\ti, j;\n\tdiskaddr_t\t\tistart, jstart, isize, jsize, endsect;\n\n\t \n\tfor (i = 0; i < vtoc->efi_nparts; i++) {\n\t\t \n\t\tif ((vtoc->efi_parts[i].p_tag == V_UNASSIGNED) &&\n\t\t    (vtoc->efi_parts[i].p_size != 0)) {\n\t\t\tif (efi_debug) {\n\t\t\t\t(void) fprintf(stderr, \"partition %d is \"\n\t\t\t\t    \"\\\"unassigned\\\" but has a size of %llu\",\n\t\t\t\t    i, vtoc->efi_parts[i].p_size);\n\t\t\t}\n\t\t\treturn (VT_EINVAL);\n\t\t}\n\t\tif (vtoc->efi_parts[i].p_tag == V_UNASSIGNED) {\n\t\t\tif (uuid_is_null((uchar_t *)&vtoc->efi_parts[i].p_guid))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tvtoc->efi_parts[i].p_tag = 0xff;\n\t\t}\n\t\tif (vtoc->efi_parts[i].p_tag == V_RESERVED) {\n\t\t\tif (resv_part != -1) {\n\t\t\t\tif (efi_debug) {\n\t\t\t\t\t(void) fprintf(stderr, \"found \"\n\t\t\t\t\t    \"duplicate reserved partition \"\n\t\t\t\t\t    \"at %d\\n\", i);\n\t\t\t\t}\n\t\t\t\treturn (VT_EINVAL);\n\t\t\t}\n\t\t\tresv_part = i;\n\t\t}\n\t\tif ((vtoc->efi_parts[i].p_start < vtoc->efi_first_u_lba) ||\n\t\t    (vtoc->efi_parts[i].p_start > vtoc->efi_last_u_lba)) {\n\t\t\tif (efi_debug) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"Partition %d starts at %llu.  \",\n\t\t\t\t    i,\n\t\t\t\t    vtoc->efi_parts[i].p_start);\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"It must be between %llu and %llu.\\n\",\n\t\t\t\t    vtoc->efi_first_u_lba,\n\t\t\t\t    vtoc->efi_last_u_lba);\n\t\t\t}\n\t\t\treturn (VT_EINVAL);\n\t\t}\n\t\tif ((vtoc->efi_parts[i].p_start +\n\t\t    vtoc->efi_parts[i].p_size <\n\t\t    vtoc->efi_first_u_lba) ||\n\t\t    (vtoc->efi_parts[i].p_start +\n\t\t    vtoc->efi_parts[i].p_size >\n\t\t    vtoc->efi_last_u_lba + 1)) {\n\t\t\tif (efi_debug) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"Partition %d ends at %llu.  \",\n\t\t\t\t    i,\n\t\t\t\t    vtoc->efi_parts[i].p_start +\n\t\t\t\t    vtoc->efi_parts[i].p_size);\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"It must be between %llu and %llu.\\n\",\n\t\t\t\t    vtoc->efi_first_u_lba,\n\t\t\t\t    vtoc->efi_last_u_lba);\n\t\t\t}\n\t\t\treturn (VT_EINVAL);\n\t\t}\n\n\t\tfor (j = 0; j < vtoc->efi_nparts; j++) {\n\t\t\tisize = vtoc->efi_parts[i].p_size;\n\t\t\tjsize = vtoc->efi_parts[j].p_size;\n\t\t\tistart = vtoc->efi_parts[i].p_start;\n\t\t\tjstart = vtoc->efi_parts[j].p_start;\n\t\t\tif ((i != j) && (isize != 0) && (jsize != 0)) {\n\t\t\t\tendsect = jstart + jsize -1;\n\t\t\t\tif ((jstart <= istart) &&\n\t\t\t\t    (istart <= endsect)) {\n\t\t\t\t\tif (efi_debug) {\n\t\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t\t    \"Partition %d overlaps \"\n\t\t\t\t\t\t    \"partition %d.\", i, j);\n\t\t\t\t\t}\n\t\t\t\t\treturn (VT_EINVAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif ((resv_part == -1) && efi_debug) {\n\t\t(void) fprintf(stderr,\n\t\t    \"no reserved partition found\\n\");\n\t}\n\treturn (0);\n}\n\nstatic int\ncall_blkpg_ioctl(int fd, int command, diskaddr_t start,\n    diskaddr_t size, uint_t pno)\n{\n\tstruct blkpg_ioctl_arg ioctl_arg;\n\tstruct blkpg_partition  linux_part;\n\tmemset(&linux_part, 0, sizeof (linux_part));\n\n\tchar *path = efi_get_devname(fd);\n\tif (path == NULL) {\n\t\t(void) fprintf(stderr, \"failed to retrieve device name\\n\");\n\t\treturn (VT_EINVAL);\n\t}\n\n\tlinux_part.start = start;\n\tlinux_part.length = size;\n\tlinux_part.pno = pno;\n\tsnprintf(linux_part.devname, BLKPG_DEVNAMELTH - 1, \"%s%u\", path, pno);\n\tlinux_part.devname[BLKPG_DEVNAMELTH - 1] = '\\0';\n\tfree(path);\n\n\tioctl_arg.op = command;\n\tioctl_arg.flags = 0;\n\tioctl_arg.datalen = sizeof (struct blkpg_partition);\n\tioctl_arg.data = &linux_part;\n\n\treturn (ioctl(fd, BLKPG, &ioctl_arg));\n}\n\n \nint\nefi_use_whole_disk(int fd)\n{\n\tstruct dk_gpt *efi_label = NULL;\n\tint rval;\n\tint i;\n\tuint_t resv_index = 0, data_index = 0;\n\tdiskaddr_t resv_start = 0, data_start = 0;\n\tdiskaddr_t data_size, limit, difference;\n\tboolean_t sync_needed = B_FALSE;\n\tuint_t nblocks;\n\n\trval = efi_alloc_and_read(fd, &efi_label);\n\tif (rval < 0) {\n\t\tif (efi_label != NULL)\n\t\t\tefi_free(efi_label);\n\t\treturn (rval);\n\t}\n\n\t \n\tfor (i = 0; i < efi_label->efi_nparts; i ++) {\n\t\tif (resv_start < efi_label->efi_parts[i].p_start) {\n\t\t\tresv_start = efi_label->efi_parts[i].p_start;\n\t\t\tresv_index = i;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < resv_index; i ++) {\n\t\tif (data_start < efi_label->efi_parts[i].p_start) {\n\t\t\tdata_start = efi_label->efi_parts[i].p_start;\n\t\t\tdata_index = i;\n\t\t}\n\t}\n\tdata_size = efi_label->efi_parts[data_index].p_size;\n\n\t \n\tnblocks = efi_label->efi_first_u_lba - 1;\n\n\t \n\tlimit = P2ALIGN(efi_label->efi_last_lba - nblocks - EFI_MIN_RESV_SIZE,\n\t    PARTITION_END_ALIGNMENT);\n\tif (data_start + data_size != limit || resv_start != limit)\n\t\tsync_needed = B_TRUE;\n\n\tif (efi_debug && sync_needed)\n\t\t(void) fprintf(stderr, \"efi_use_whole_disk: sync needed\\n\");\n\n\t \n\tif ((efi_label->efi_altern_lba == 1) || (efi_label->efi_altern_lba\n\t    >= efi_label->efi_last_lba && !sync_needed)) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"efi_use_whole_disk: requested space not found\\n\");\n\t\t}\n\t\tefi_free(efi_label);\n\t\treturn (VT_ENOSPC);\n\t}\n\n\t \n\tif ((efi_label->efi_parts[resv_index].p_size != EFI_MIN_RESV_SIZE) ||\n\t    (efi_label->efi_parts[resv_index].p_tag != V_RESERVED) ||\n\t    (resv_index != 8)) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"efi_use_whole_disk: wholedisk not available\\n\");\n\t\t}\n\t\tefi_free(efi_label);\n\t\treturn (VT_ENOSPC);\n\t}\n\n\tif (data_start + data_size != resv_start) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"efi_use_whole_disk: \"\n\t\t\t    \"data_start (%lli) + \"\n\t\t\t    \"data_size (%lli) != \"\n\t\t\t    \"resv_start (%lli)\\n\",\n\t\t\t    data_start, data_size, resv_start);\n\t\t}\n\n\t\treturn (VT_EINVAL);\n\t}\n\n\tif (limit < resv_start) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"efi_use_whole_disk: \"\n\t\t\t    \"limit (%lli) < resv_start (%lli)\\n\",\n\t\t\t    limit, resv_start);\n\t\t}\n\n\t\treturn (VT_EINVAL);\n\t}\n\n\tdifference = limit - resv_start;\n\n\tif (efi_debug)\n\t\t(void) fprintf(stderr,\n\t\t    \"efi_use_whole_disk: difference is %lli\\n\", difference);\n\n\t \n\tefi_label->efi_parts[data_index].p_size += difference;\n\tefi_label->efi_parts[resv_index].p_start += difference;\n\tefi_label->efi_last_u_lba = efi_label->efi_last_lba - nblocks;\n\n\t \n#ifdef BLKPG_RESIZE_PARTITION\n\t \n\trval = call_blkpg_ioctl(fd, BLKPG_DEL_PARTITION, 0, 0, resv_index + 1);\n\tif (rval != 0)\n\t\tgoto out;\n\n\t \n\trval = call_blkpg_ioctl(fd, BLKPG_RESIZE_PARTITION,\n\t    efi_label->efi_parts[data_index].p_start * efi_label->efi_lbasize,\n\t    efi_label->efi_parts[data_index].p_size * efi_label->efi_lbasize,\n\t    data_index + 1);\n\tif (rval != 0) {\n\t\t(void) fprintf(stderr, \"Unable to resize data \"\n\t\t    \"partition:  %d\\n\", rval);\n\t\t \n\t\tefi_label->efi_parts[resv_index].p_start -= difference;\n\t}\n\n\t \n\t(void) call_blkpg_ioctl(fd, BLKPG_ADD_PARTITION,\n\t    efi_label->efi_parts[resv_index].p_start * efi_label->efi_lbasize,\n\t    efi_label->efi_parts[resv_index].p_size * efi_label->efi_lbasize,\n\t    resv_index + 1);\n#endif\n\n\t \n\tif (rval == 0) {\n\t\trval = efi_write(fd, efi_label);\n\t\tif (rval < 0 && efi_debug) {\n\t\t\t(void) fprintf(stderr, \"efi_use_whole_disk:fail \"\n\t\t\t    \"to write label, rval=%d\\n\", rval);\n\t\t}\n\t}\n\nout:\n\tefi_free(efi_label);\n\treturn (rval);\n}\n\n \nint\nefi_write(int fd, struct dk_gpt *vtoc)\n{\n\tdk_efi_t\t\tdk_ioc;\n\tefi_gpt_t\t\t*efi;\n\tefi_gpe_t\t\t*efi_parts;\n\tint\t\t\ti, j;\n\tstruct dk_cinfo\t\tdki_info;\n\tint\t\t\trval;\n\tint\t\t\tmd_flag = 0;\n\tint\t\t\tnblocks;\n\tdiskaddr_t\t\tlba_backup_gpt_hdr;\n\n\tif ((rval = efi_get_info(fd, &dki_info)) != 0)\n\t\treturn (rval);\n\n\t \n\tif ((strncmp(dki_info.dki_cname, \"pseudo\", 7) == 0) &&\n\t    (strncmp(dki_info.dki_dname, \"md\", 3) == 0)) {\n\t\tmd_flag = 1;\n\t}\n\n\tif (check_input(vtoc)) {\n\t\t \n\t\tif (md_flag == 0) {\n\t\t\treturn (VT_EINVAL);\n\t\t}\n\t}\n\n\tdk_ioc.dki_lba = 1;\n\tif (NBLOCKS(vtoc->efi_nparts, vtoc->efi_lbasize) < 34) {\n\t\tdk_ioc.dki_length = EFI_MIN_ARRAY_SIZE + vtoc->efi_lbasize;\n\t} else {\n\t\tdk_ioc.dki_length = (len_t)NBLOCKS(vtoc->efi_nparts,\n\t\t    vtoc->efi_lbasize) *\n\t\t    vtoc->efi_lbasize;\n\t}\n\n\t \n\tnblocks = dk_ioc.dki_length / vtoc->efi_lbasize - 1;\n\n\t \n\tlba_backup_gpt_hdr = vtoc->efi_last_u_lba + 1 + nblocks;\n\tif (posix_memalign((void **)&dk_ioc.dki_data,\n\t    vtoc->efi_lbasize, dk_ioc.dki_length))\n\t\treturn (VT_ERROR);\n\n\tmemset(dk_ioc.dki_data, 0, dk_ioc.dki_length);\n\tefi = dk_ioc.dki_data;\n\n\t \n\tefi->efi_gpt_Signature = LE_64(EFI_SIGNATURE);\n\tefi->efi_gpt_Revision = LE_32(vtoc->efi_version);  \n\tefi->efi_gpt_HeaderSize = LE_32(sizeof (struct efi_gpt) - LEN_EFI_PAD);\n\tefi->efi_gpt_Reserved1 = 0;\n\tefi->efi_gpt_MyLBA = LE_64(1ULL);\n\tefi->efi_gpt_AlternateLBA = LE_64(lba_backup_gpt_hdr);\n\tefi->efi_gpt_FirstUsableLBA = LE_64(vtoc->efi_first_u_lba);\n\tefi->efi_gpt_LastUsableLBA = LE_64(vtoc->efi_last_u_lba);\n\tefi->efi_gpt_PartitionEntryLBA = LE_64(2ULL);\n\tefi->efi_gpt_NumberOfPartitionEntries = LE_32(vtoc->efi_nparts);\n\tefi->efi_gpt_SizeOfPartitionEntry = LE_32(sizeof (struct efi_gpe));\n\tUUID_LE_CONVERT(efi->efi_gpt_DiskGUID, vtoc->efi_disk_uguid);\n\n\t \n\tefi_parts = (efi_gpe_t *)((char *)dk_ioc.dki_data + vtoc->efi_lbasize);\n\n\tfor (i = 0; i < vtoc->efi_nparts; i++) {\n\t\tfor (j = 0;\n\t\t    j < sizeof (conversion_array) /\n\t\t    sizeof (struct uuid_to_ptag); j++) {\n\n\t\t\tif (vtoc->efi_parts[i].p_tag == j) {\n\t\t\t\tUUID_LE_CONVERT(\n\t\t\t\t    efi_parts[i].efi_gpe_PartitionTypeGUID,\n\t\t\t\t    conversion_array[j].uuid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == sizeof (conversion_array) /\n\t\t    sizeof (struct uuid_to_ptag)) {\n\t\t\t \n\t\t\tif (efi_debug) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"Unknown uuid for p_tag %d\\n\",\n\t\t\t\t    vtoc->efi_parts[i].p_tag);\n\t\t\t}\n\t\t\treturn (VT_EINVAL);\n\t\t}\n\n\t\t \n\t\tif (vtoc->efi_parts[i].p_tag == V_UNASSIGNED)\n\t\t\tcontinue;\n\n\t\tefi_parts[i].efi_gpe_StartingLBA =\n\t\t    LE_64(vtoc->efi_parts[i].p_start);\n\t\tefi_parts[i].efi_gpe_EndingLBA =\n\t\t    LE_64(vtoc->efi_parts[i].p_start +\n\t\t    vtoc->efi_parts[i].p_size - 1);\n\t\tefi_parts[i].efi_gpe_Attributes.PartitionAttrs =\n\t\t    LE_16(vtoc->efi_parts[i].p_flag);\n\t\tfor (j = 0; j < EFI_PART_NAME_LEN; j++) {\n\t\t\tefi_parts[i].efi_gpe_PartitionName[j] =\n\t\t\t    LE_16((ushort_t)vtoc->efi_parts[i].p_name[j]);\n\t\t}\n\t\tif ((vtoc->efi_parts[i].p_tag != V_UNASSIGNED) &&\n\t\t    uuid_is_null((uchar_t *)&vtoc->efi_parts[i].p_uguid)) {\n\t\t\t(void) uuid_generate((uchar_t *)\n\t\t\t    &vtoc->efi_parts[i].p_uguid);\n\t\t}\n\t\tmemcpy(&efi_parts[i].efi_gpe_UniquePartitionGUID,\n\t\t    &vtoc->efi_parts[i].p_uguid,\n\t\t    sizeof (uuid_t));\n\t}\n\tefi->efi_gpt_PartitionEntryArrayCRC32 =\n\t    LE_32(efi_crc32((unsigned char *)efi_parts,\n\t    vtoc->efi_nparts * (int)sizeof (struct efi_gpe)));\n\tefi->efi_gpt_HeaderCRC32 =\n\t    LE_32(efi_crc32((unsigned char *)efi,\n\t    LE_32(efi->efi_gpt_HeaderSize)));\n\n\tif (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {\n\t\tfree(dk_ioc.dki_data);\n\t\tswitch (errno) {\n\t\tcase EIO:\n\t\t\treturn (VT_EIO);\n\t\tcase EINVAL:\n\t\t\treturn (VT_EINVAL);\n\t\tdefault:\n\t\t\treturn (VT_ERROR);\n\t\t}\n\t}\n\t \n\tif (md_flag) {\n\t\tfree(dk_ioc.dki_data);\n\t\treturn (0);\n\t}\n\n\t \n\tdk_ioc.dki_lba = vtoc->efi_last_u_lba + 1;\n\tdk_ioc.dki_length -= vtoc->efi_lbasize;\n\t \n\tdk_ioc.dki_data = (efi_gpt_t *)((char *)dk_ioc.dki_data +\n\t    vtoc->efi_lbasize);\n\n\tif (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {\n\t\t \n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"write of backup partitions to block %llu \"\n\t\t\t    \"failed, errno %d\\n\",\n\t\t\t    vtoc->efi_last_u_lba + 1,\n\t\t\t    errno);\n\t\t}\n\t}\n\t \n\tdk_ioc.dki_lba = lba_backup_gpt_hdr;\n\tdk_ioc.dki_length = vtoc->efi_lbasize;\n\t \n\tdk_ioc.dki_data = (efi_gpt_t *)((char *)dk_ioc.dki_data -\n\t    vtoc->efi_lbasize);\n\tefi->efi_gpt_AlternateLBA = LE_64(1ULL);\n\tefi->efi_gpt_MyLBA = LE_64(lba_backup_gpt_hdr);\n\tefi->efi_gpt_PartitionEntryLBA = LE_64(vtoc->efi_last_u_lba + 1);\n\tefi->efi_gpt_HeaderCRC32 = 0;\n\tefi->efi_gpt_HeaderCRC32 =\n\t    LE_32(efi_crc32((unsigned char *)dk_ioc.dki_data,\n\t    LE_32(efi->efi_gpt_HeaderSize)));\n\n\tif (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {\n\t\tif (efi_debug) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"write of backup header to block %llu failed, \"\n\t\t\t    \"errno %d\\n\",\n\t\t\t    lba_backup_gpt_hdr,\n\t\t\t    errno);\n\t\t}\n\t}\n\t \n\t(void) write_pmbr(fd, vtoc);\n\tfree(dk_ioc.dki_data);\n\n\treturn (0);\n}\n\nvoid\nefi_free(struct dk_gpt *ptr)\n{\n\tfree(ptr);\n}\n\nvoid\nefi_err_check(struct dk_gpt *vtoc)\n{\n\tint\t\t\tresv_part = -1;\n\tint\t\t\ti, j;\n\tdiskaddr_t\t\tistart, jstart, isize, jsize, endsect;\n\tint\t\t\toverlap = 0;\n\n\t \n\tfor (i = 0; i < vtoc->efi_nparts; i++) {\n\t\t \n\t\tif ((vtoc->efi_parts[i].p_tag == V_UNASSIGNED) &&\n\t\t    (vtoc->efi_parts[i].p_size != 0)) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"partition %d is \\\"unassigned\\\" but has a size \"\n\t\t\t    \"of %llu\\n\", i, vtoc->efi_parts[i].p_size);\n\t\t}\n\t\tif (vtoc->efi_parts[i].p_tag == V_UNASSIGNED) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (vtoc->efi_parts[i].p_tag == V_RESERVED) {\n\t\t\tif (resv_part != -1) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"found duplicate reserved partition at \"\n\t\t\t\t    \"%d\\n\", i);\n\t\t\t}\n\t\t\tresv_part = i;\n\t\t\tif (vtoc->efi_parts[i].p_size != EFI_MIN_RESV_SIZE)\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"Warning: reserved partition size must \"\n\t\t\t\t    \"be %d sectors\\n\", EFI_MIN_RESV_SIZE);\n\t\t}\n\t\tif ((vtoc->efi_parts[i].p_start < vtoc->efi_first_u_lba) ||\n\t\t    (vtoc->efi_parts[i].p_start > vtoc->efi_last_u_lba)) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Partition %d starts at %llu\\n\",\n\t\t\t    i,\n\t\t\t    vtoc->efi_parts[i].p_start);\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"It must be between %llu and %llu.\\n\",\n\t\t\t    vtoc->efi_first_u_lba,\n\t\t\t    vtoc->efi_last_u_lba);\n\t\t}\n\t\tif ((vtoc->efi_parts[i].p_start +\n\t\t    vtoc->efi_parts[i].p_size <\n\t\t    vtoc->efi_first_u_lba) ||\n\t\t    (vtoc->efi_parts[i].p_start +\n\t\t    vtoc->efi_parts[i].p_size >\n\t\t    vtoc->efi_last_u_lba + 1)) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Partition %d ends at %llu\\n\",\n\t\t\t    i,\n\t\t\t    vtoc->efi_parts[i].p_start +\n\t\t\t    vtoc->efi_parts[i].p_size);\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"It must be between %llu and %llu.\\n\",\n\t\t\t    vtoc->efi_first_u_lba,\n\t\t\t    vtoc->efi_last_u_lba);\n\t\t}\n\n\t\tfor (j = 0; j < vtoc->efi_nparts; j++) {\n\t\t\tisize = vtoc->efi_parts[i].p_size;\n\t\t\tjsize = vtoc->efi_parts[j].p_size;\n\t\t\tistart = vtoc->efi_parts[i].p_start;\n\t\t\tjstart = vtoc->efi_parts[j].p_start;\n\t\t\tif ((i != j) && (isize != 0) && (jsize != 0)) {\n\t\t\t\tendsect = jstart + jsize -1;\n\t\t\t\tif ((jstart <= istart) &&\n\t\t\t\t    (istart <= endsect)) {\n\t\t\t\t\tif (!overlap) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    \"label error: EFI Labels do not \"\n\t\t\t\t\t    \"support overlapping partitions\\n\");\n\t\t\t\t\t}\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    \"Partition %d overlaps partition \"\n\t\t\t\t\t    \"%d.\\n\", i, j);\n\t\t\t\t\toverlap = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (resv_part == -1) {\n\t\t(void) fprintf(stderr,\n\t\t    \"no reserved partition found\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}