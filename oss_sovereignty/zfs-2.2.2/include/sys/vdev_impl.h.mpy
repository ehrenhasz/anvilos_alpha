{
  "module_name": "vdev_impl.h",
  "hash_id": "5297163cc3dc8e0e1f52f67278ee49911c46bc74e89c2ad183ec967cc7b35571",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/vdev_impl.h",
  "human_readable_source": " \n \n\n#ifndef _SYS_VDEV_IMPL_H\n#define\t_SYS_VDEV_IMPL_H\n\n#include <sys/avl.h>\n#include <sys/bpobj.h>\n#include <sys/dmu.h>\n#include <sys/metaslab.h>\n#include <sys/nvpair.h>\n#include <sys/space_map.h>\n#include <sys/vdev.h>\n#include <sys/dkio.h>\n#include <sys/uberblock_impl.h>\n#include <sys/vdev_indirect_mapping.h>\n#include <sys/vdev_indirect_births.h>\n#include <sys/vdev_rebuild.h>\n#include <sys/vdev_removal.h>\n#include <sys/zfs_ratelimit.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n\n \ntypedef struct vdev_queue vdev_queue_t;\nstruct abd;\n\nextern uint_t zfs_vdev_queue_depth_pct;\nextern uint_t zfs_vdev_def_queue_depth;\nextern uint_t zfs_vdev_async_write_max_active;\n\n \ntypedef int\tvdev_init_func_t(spa_t *spa, nvlist_t *nv, void **tsd);\ntypedef void\tvdev_kobj_post_evt_func_t(vdev_t *vd);\ntypedef void\tvdev_fini_func_t(vdev_t *vd);\ntypedef int\tvdev_open_func_t(vdev_t *vd, uint64_t *size, uint64_t *max_size,\n    uint64_t *ashift, uint64_t *pshift);\ntypedef void\tvdev_close_func_t(vdev_t *vd);\ntypedef uint64_t vdev_asize_func_t(vdev_t *vd, uint64_t psize);\ntypedef uint64_t vdev_min_asize_func_t(vdev_t *vd);\ntypedef uint64_t vdev_min_alloc_func_t(vdev_t *vd);\ntypedef void\tvdev_io_start_func_t(zio_t *zio);\ntypedef void\tvdev_io_done_func_t(zio_t *zio);\ntypedef void\tvdev_state_change_func_t(vdev_t *vd, int, int);\ntypedef boolean_t vdev_need_resilver_func_t(vdev_t *vd, const dva_t *dva,\n    size_t psize, uint64_t phys_birth);\ntypedef void\tvdev_hold_func_t(vdev_t *vd);\ntypedef void\tvdev_rele_func_t(vdev_t *vd);\n\ntypedef void\tvdev_remap_cb_t(uint64_t inner_offset, vdev_t *vd,\n    uint64_t offset, uint64_t size, void *arg);\ntypedef void\tvdev_remap_func_t(vdev_t *vd, uint64_t offset, uint64_t size,\n    vdev_remap_cb_t callback, void *arg);\n \ntypedef void vdev_xlation_func_t(vdev_t *cvd, const range_seg64_t *logical,\n    range_seg64_t *physical, range_seg64_t *remain);\ntypedef uint64_t vdev_rebuild_asize_func_t(vdev_t *vd, uint64_t start,\n    uint64_t size, uint64_t max_segment);\ntypedef void vdev_metaslab_init_func_t(vdev_t *vd, uint64_t *startp,\n    uint64_t *sizep);\ntypedef void vdev_config_generate_func_t(vdev_t *vd, nvlist_t *nv);\ntypedef uint64_t vdev_nparity_func_t(vdev_t *vd);\ntypedef uint64_t vdev_ndisks_func_t(vdev_t *vd);\n\ntypedef const struct vdev_ops {\n\tvdev_init_func_t\t\t*vdev_op_init;\n\tvdev_fini_func_t\t\t*vdev_op_fini;\n\tvdev_open_func_t\t\t*vdev_op_open;\n\tvdev_close_func_t\t\t*vdev_op_close;\n\tvdev_asize_func_t\t\t*vdev_op_asize;\n\tvdev_min_asize_func_t\t\t*vdev_op_min_asize;\n\tvdev_min_alloc_func_t\t\t*vdev_op_min_alloc;\n\tvdev_io_start_func_t\t\t*vdev_op_io_start;\n\tvdev_io_done_func_t\t\t*vdev_op_io_done;\n\tvdev_state_change_func_t\t*vdev_op_state_change;\n\tvdev_need_resilver_func_t\t*vdev_op_need_resilver;\n\tvdev_hold_func_t\t\t*vdev_op_hold;\n\tvdev_rele_func_t\t\t*vdev_op_rele;\n\tvdev_remap_func_t\t\t*vdev_op_remap;\n\tvdev_xlation_func_t\t\t*vdev_op_xlate;\n\tvdev_rebuild_asize_func_t\t*vdev_op_rebuild_asize;\n\tvdev_metaslab_init_func_t\t*vdev_op_metaslab_init;\n\tvdev_config_generate_func_t\t*vdev_op_config_generate;\n\tvdev_nparity_func_t\t\t*vdev_op_nparity;\n\tvdev_ndisks_func_t\t\t*vdev_op_ndisks;\n\tvdev_kobj_post_evt_func_t\t*vdev_op_kobj_evt_post;\n\tchar\t\t\t\tvdev_op_type[16];\n\tboolean_t\t\t\tvdev_op_leaf;\n} vdev_ops_t;\n\n \ntypedef union vdev_queue_class {\n\tstruct {\n\t\tulong_t \tvqc_list_numnodes;\n\t\tlist_t\t\tvqc_list;\n\t};\n\tavl_tree_t\tvqc_tree;\n} vdev_queue_class_t;\n\nstruct vdev_queue {\n\tvdev_t\t\t*vq_vdev;\n\tvdev_queue_class_t vq_class[ZIO_PRIORITY_NUM_QUEUEABLE];\n\tavl_tree_t\tvq_read_offset_tree;\n\tavl_tree_t\tvq_write_offset_tree;\n\tuint64_t\tvq_last_offset;\n\tzio_priority_t\tvq_last_prio;\t \n\tuint32_t\tvq_cqueued;\t \n\tuint32_t\tvq_cactive[ZIO_PRIORITY_NUM_QUEUEABLE];\n\tuint32_t\tvq_active;\t \n\tuint32_t\tvq_ia_active;\t \n\tuint32_t\tvq_nia_credit;\t \n\tlist_t\t\tvq_active_list;\t \n\thrtime_t\tvq_io_complete_ts;  \n\thrtime_t\tvq_io_delta_ts;\n\tzio_t\t\tvq_io_search;  \n\tkmutex_t\tvq_lock;\n};\n\ntypedef enum vdev_alloc_bias {\n\tVDEV_BIAS_NONE,\n\tVDEV_BIAS_LOG,\t\t \n\tVDEV_BIAS_SPECIAL,\t \n\tVDEV_BIAS_DEDUP\t\t \n} vdev_alloc_bias_t;\n\n\n \ntypedef struct vdev_indirect_config {\n\t \n\tuint64_t\tvic_mapping_object;\n\n\t \n\tuint64_t\tvic_births_object;\n\n\t \n\tuint64_t\tvic_prev_indirect_vdev;\n} vdev_indirect_config_t;\n\n \nstruct vdev {\n\t \n\tuint64_t\tvdev_id;\t \n\tuint64_t\tvdev_guid;\t \n\tuint64_t\tvdev_guid_sum;\t \n\tuint64_t\tvdev_orig_guid;\t \n\tuint64_t\tvdev_asize;\t \n\tuint64_t\tvdev_min_asize;\t \n\tuint64_t\tvdev_max_asize;\t \n\tuint64_t\tvdev_ashift;\t \n\n\t \n\tuint64_t\tvdev_logical_ashift;\n\t \n\tuint64_t\tvdev_physical_ashift;\n\tuint64_t\tvdev_state;\t \n\tuint64_t\tvdev_prevstate;\t \n\tvdev_ops_t\t*vdev_ops;\t \n\tspa_t\t\t*vdev_spa;\t \n\tvoid\t\t*vdev_tsd;\t \n\tvdev_t\t\t*vdev_top;\t \n\tvdev_t\t\t*vdev_parent;\t \n\tvdev_t\t\t**vdev_child;\t \n\tuint64_t\tvdev_children;\t \n\tvdev_stat_t\tvdev_stat;\t \n\tvdev_stat_ex_t\tvdev_stat_ex;\t \n\tboolean_t\tvdev_expanding;\t \n\tboolean_t\tvdev_reopening;\t \n\tboolean_t\tvdev_nonrot;\t \n\tint\t\tvdev_load_error;  \n\tint\t\tvdev_open_error;  \n\tint\t\tvdev_validate_error;  \n\tkthread_t\t*vdev_open_thread;  \n\tkthread_t\t*vdev_validate_thread;  \n\tuint64_t\tvdev_crtxg;\t \n\tuint64_t\tvdev_root_zap;\n\n\t \n\tuint64_t\tvdev_ms_array;\t \n\tuint64_t\tvdev_ms_shift;\t \n\tuint64_t\tvdev_ms_count;\t \n\tmetaslab_group_t *vdev_mg;\t \n\tmetaslab_group_t *vdev_log_mg;\t \n\tmetaslab_t\t**vdev_ms;\t \n\ttxg_list_t\tvdev_ms_list;\t \n\ttxg_list_t\tvdev_dtl_list;\t \n\ttxg_node_t\tvdev_txg_node;\t \n\tboolean_t\tvdev_remove_wanted;  \n\tboolean_t\tvdev_probe_wanted;  \n\tlist_node_t\tvdev_config_dirty_node;  \n\tlist_node_t\tvdev_state_dirty_node;  \n\tuint64_t\tvdev_deflate_ratio;  \n\tuint64_t\tvdev_islog;\t \n\tuint64_t\tvdev_noalloc;\t \n\tuint64_t\tvdev_removing;\t \n\tuint64_t\tvdev_failfast;\t \n\tboolean_t\tvdev_ishole;\t \n\tuint64_t\tvdev_top_zap;\n\tvdev_alloc_bias_t vdev_alloc_bias;  \n\n\t \n\tspace_map_t\t*vdev_checkpoint_sm;\t \n\n\t \n\tboolean_t\tvdev_initialize_exit_wanted;\n\tvdev_initializing_state_t\tvdev_initialize_state;\n\tlist_node_t\tvdev_initialize_node;\n\tkthread_t\t*vdev_initialize_thread;\n\t \n\tkmutex_t\tvdev_initialize_lock;\n\tkcondvar_t\tvdev_initialize_cv;\n\tuint64_t\tvdev_initialize_offset[TXG_SIZE];\n\tuint64_t\tvdev_initialize_last_offset;\n\trange_tree_t\t*vdev_initialize_tree;\t \n\tuint64_t\tvdev_initialize_bytes_est;\n\tuint64_t\tvdev_initialize_bytes_done;\n\tuint64_t\tvdev_initialize_action_time;\t \n\n\t \n\tboolean_t\tvdev_trim_exit_wanted;\n\tboolean_t\tvdev_autotrim_exit_wanted;\n\tvdev_trim_state_t\tvdev_trim_state;\n\tlist_node_t\tvdev_trim_node;\n\tkmutex_t\tvdev_autotrim_lock;\n\tkcondvar_t\tvdev_autotrim_cv;\n\tkcondvar_t\tvdev_autotrim_kick_cv;\n\tkthread_t\t*vdev_autotrim_thread;\n\t \n\tkmutex_t\tvdev_trim_lock;\n\tkcondvar_t\tvdev_trim_cv;\n\tkthread_t\t*vdev_trim_thread;\n\tuint64_t\tvdev_trim_offset[TXG_SIZE];\n\tuint64_t\tvdev_trim_last_offset;\n\tuint64_t\tvdev_trim_bytes_est;\n\tuint64_t\tvdev_trim_bytes_done;\n\tuint64_t\tvdev_trim_rate;\t\t \n\tuint64_t\tvdev_trim_partial;\t \n\tuint64_t\tvdev_trim_secure;\t \n\tuint64_t\tvdev_trim_action_time;\t \n\n\t \n\tboolean_t\tvdev_rebuilding;\n\tboolean_t\tvdev_rebuild_exit_wanted;\n\tboolean_t\tvdev_rebuild_cancel_wanted;\n\tboolean_t\tvdev_rebuild_reset_wanted;\n\tkmutex_t\tvdev_rebuild_lock;\n\tkcondvar_t\tvdev_rebuild_cv;\n\tkthread_t\t*vdev_rebuild_thread;\n\tvdev_rebuild_t\tvdev_rebuild_config;\n\n\t \n\tkmutex_t\tvdev_initialize_io_lock;\n\tkcondvar_t\tvdev_initialize_io_cv;\n\tuint64_t\tvdev_initialize_inflight;\n\tkmutex_t\tvdev_trim_io_lock;\n\tkcondvar_t\tvdev_trim_io_cv;\n\tuint64_t\tvdev_trim_inflight[3];\n\n\t \n\tvdev_indirect_config_t\tvdev_indirect_config;\n\n\t \n\tkrwlock_t vdev_indirect_rwlock;\n\tvdev_indirect_mapping_t *vdev_indirect_mapping;\n\tvdev_indirect_births_t *vdev_indirect_births;\n\n\t \n\tkmutex_t\tvdev_obsolete_lock;\n\trange_tree_t\t*vdev_obsolete_segments;\n\tspace_map_t\t*vdev_obsolete_sm;\n\n\t \n\tkmutex_t\t\t\tvdev_scan_io_queue_lock;\n\tstruct dsl_scan_io_queue\t*vdev_scan_io_queue;\n\n\t \n\trange_tree_t\t*vdev_dtl[DTL_TYPES];  \n\tspace_map_t\t*vdev_dtl_sm;\t \n\ttxg_node_t\tvdev_dtl_node;\t \n\tuint64_t\tvdev_dtl_object;  \n\tuint64_t\tvdev_psize;\t \n\tuint64_t\tvdev_wholedisk;\t \n\tuint64_t\tvdev_offline;\t \n\tuint64_t\tvdev_faulted;\t \n\tuint64_t\tvdev_degraded;\t \n\tuint64_t\tvdev_removed;\t \n\tuint64_t\tvdev_resilver_txg;  \n\tuint64_t\tvdev_rebuild_txg;  \n\tchar\t\t*vdev_path;\t \n\tchar\t\t*vdev_devid;\t \n\tchar\t\t*vdev_physpath;\t \n\tchar\t\t*vdev_enc_sysfs_path;\t \n\tchar\t\t*vdev_fru;\t \n\tuint64_t\tvdev_not_present;  \n\tuint64_t\tvdev_unspare;\t \n\tboolean_t\tvdev_nowritecache;  \n\tboolean_t\tvdev_has_trim;\t \n\tboolean_t\tvdev_has_securetrim;  \n\tboolean_t\tvdev_checkremove;  \n\tboolean_t\tvdev_forcefault;  \n\tboolean_t\tvdev_splitting;\t \n\tboolean_t\tvdev_delayed_close;  \n\tboolean_t\tvdev_tmpoffline;  \n\tboolean_t\tvdev_detached;\t \n\tboolean_t\tvdev_cant_read;\t \n\tboolean_t\tvdev_cant_write;  \n\tboolean_t\tvdev_isspare;\t \n\tboolean_t\tvdev_isl2cache;\t \n\tboolean_t\tvdev_copy_uberblocks;   \n\tboolean_t\tvdev_resilver_deferred;   \n\tboolean_t\tvdev_kobj_flag;  \n\tboolean_t\tvdev_attaching;  \n\tvdev_queue_t\tvdev_queue;\t \n\tspa_aux_vdev_t\t*vdev_aux;\t \n\tzio_t\t\t*vdev_probe_zio;  \n\tvdev_aux_t\tvdev_label_aux;\t \n\tuint64_t\tvdev_leaf_zap;\n\thrtime_t\tvdev_mmp_pending;  \n\tuint64_t\tvdev_mmp_kstat_id;\t \n\tuint64_t\tvdev_expansion_time;\t \n\tlist_node_t\tvdev_leaf_node;\t\t \n\n\t \n\tkmutex_t\tvdev_dtl_lock;\t \n\tkmutex_t\tvdev_stat_lock;\t \n\tkmutex_t\tvdev_probe_lock;  \n\n\t \n\tzfs_ratelimit_t vdev_delay_rl;\n\tzfs_ratelimit_t vdev_deadman_rl;\n\tzfs_ratelimit_t vdev_checksum_rl;\n\n\t \n\tuint64_t\tvdev_checksum_n;\n\tuint64_t\tvdev_checksum_t;\n\tuint64_t\tvdev_io_n;\n\tuint64_t\tvdev_io_t;\n};\n\n#define\tVDEV_PAD_SIZE\t\t(8 << 10)\n \n#define\tVDEV_SKIP_SIZE\t\tVDEV_PAD_SIZE * 2\n#define\tVDEV_PHYS_SIZE\t\t(112 << 10)\n#define\tVDEV_UBERBLOCK_RING\t(128 << 10)\n\n \n#define\tMMP_BLOCKS_PER_LABEL\t1\n\n \n#define\tMAX_UBERBLOCK_SHIFT (13)\n#define\tVDEV_UBERBLOCK_SHIFT(vd)\t\\\n\tMIN(MAX((vd)->vdev_top->vdev_ashift, UBERBLOCK_SHIFT), \\\n\t    MAX_UBERBLOCK_SHIFT)\n#define\tVDEV_UBERBLOCK_COUNT(vd)\t\\\n\t(VDEV_UBERBLOCK_RING >> VDEV_UBERBLOCK_SHIFT(vd))\n#define\tVDEV_UBERBLOCK_OFFSET(vd, n)\t\\\n\toffsetof(vdev_label_t, vl_uberblock[(n) << VDEV_UBERBLOCK_SHIFT(vd)])\n#define\tVDEV_UBERBLOCK_SIZE(vd)\t\t(1ULL << VDEV_UBERBLOCK_SHIFT(vd))\n\ntypedef struct vdev_phys {\n\tchar\t\tvp_nvlist[VDEV_PHYS_SIZE - sizeof (zio_eck_t)];\n\tzio_eck_t\tvp_zbt;\n} vdev_phys_t;\n\ntypedef enum vbe_vers {\n\t \n\tVB_RAW = 0,\n\n\t \n\tVB_NVLIST = 1\n} vbe_vers_t;\n\ntypedef struct vdev_boot_envblock {\n\tuint64_t\tvbe_version;\n\tchar\t\tvbe_bootenv[VDEV_PAD_SIZE - sizeof (uint64_t) -\n\t\t\tsizeof (zio_eck_t)];\n\tzio_eck_t\tvbe_zbt;\n} vdev_boot_envblock_t;\n_Static_assert(sizeof (vdev_boot_envblock_t) == VDEV_PAD_SIZE,\n\t\"vdev_boot_envblock_t wrong size\");\n\ntypedef struct vdev_label {\n\tchar\t\tvl_pad1[VDEV_PAD_SIZE];\t\t\t \n\tvdev_boot_envblock_t\tvl_be;\t\t\t\t \n\tvdev_phys_t\tvl_vdev_phys;\t\t\t\t \n\tchar\t\tvl_uberblock[VDEV_UBERBLOCK_RING];\t \n} vdev_label_t;\t\t\t\t\t\t \n\n \n#define\tVDD_METASLAB\t0x01\n#define\tVDD_DTL\t\t0x02\n\n \n#define\tVDEV_BOOT_OFFSET\t(2 * sizeof (vdev_label_t))\n \n#define\tVDEV_BOOT_SIZE\t\t(7ULL << 19)\t\t\t \n\n \n#define\tVDEV_LABEL_START_SIZE\t(2 * sizeof (vdev_label_t) + VDEV_BOOT_SIZE)\n#define\tVDEV_LABEL_END_SIZE\t(2 * sizeof (vdev_label_t))\n#define\tVDEV_LABELS\t\t4\n#define\tVDEV_BEST_LABEL\t\tVDEV_LABELS\n#define\tVDEV_OFFSET_IS_LABEL(vd, off)                           \\\n\t(((off) < VDEV_LABEL_START_SIZE) ||                     \\\n\t((off) >= ((vd)->vdev_psize - VDEV_LABEL_END_SIZE)))\n\n#define\tVDEV_ALLOC_LOAD\t\t0\n#define\tVDEV_ALLOC_ADD\t\t1\n#define\tVDEV_ALLOC_SPARE\t2\n#define\tVDEV_ALLOC_L2CACHE\t3\n#define\tVDEV_ALLOC_ROOTPOOL\t4\n#define\tVDEV_ALLOC_SPLIT\t5\n#define\tVDEV_ALLOC_ATTACH\t6\n\n \nextern vdev_t *vdev_alloc_common(spa_t *spa, uint_t id, uint64_t guid,\n    vdev_ops_t *ops);\nextern int vdev_alloc(spa_t *spa, vdev_t **vdp, nvlist_t *config,\n    vdev_t *parent, uint_t id, int alloctype);\nextern void vdev_free(vdev_t *vd);\n\n \nextern void vdev_add_child(vdev_t *pvd, vdev_t *cvd);\nextern void vdev_remove_child(vdev_t *pvd, vdev_t *cvd);\nextern void vdev_compact_children(vdev_t *pvd);\nextern vdev_t *vdev_add_parent(vdev_t *cvd, vdev_ops_t *ops);\nextern void vdev_remove_parent(vdev_t *cvd);\n\n \nextern boolean_t vdev_log_state_valid(vdev_t *vd);\nextern int vdev_load(vdev_t *vd);\nextern int vdev_dtl_load(vdev_t *vd);\nextern void vdev_sync(vdev_t *vd, uint64_t txg);\nextern void vdev_sync_done(vdev_t *vd, uint64_t txg);\nextern void vdev_dirty(vdev_t *vd, int flags, void *arg, uint64_t txg);\nextern void vdev_dirty_leaves(vdev_t *vd, int flags, uint64_t txg);\n\n \nextern vdev_ops_t vdev_root_ops;\nextern vdev_ops_t vdev_mirror_ops;\nextern vdev_ops_t vdev_replacing_ops;\nextern vdev_ops_t vdev_raidz_ops;\nextern vdev_ops_t vdev_draid_ops;\nextern vdev_ops_t vdev_draid_spare_ops;\nextern vdev_ops_t vdev_disk_ops;\nextern vdev_ops_t vdev_file_ops;\nextern vdev_ops_t vdev_missing_ops;\nextern vdev_ops_t vdev_hole_ops;\nextern vdev_ops_t vdev_spare_ops;\nextern vdev_ops_t vdev_indirect_ops;\n\n \nextern void vdev_default_xlate(vdev_t *vd, const range_seg64_t *logical_rs,\n    range_seg64_t *physical_rs, range_seg64_t *remain_rs);\nextern uint64_t vdev_default_asize(vdev_t *vd, uint64_t psize);\nextern uint64_t vdev_default_min_asize(vdev_t *vd);\nextern uint64_t vdev_get_min_asize(vdev_t *vd);\nextern void vdev_set_min_asize(vdev_t *vd);\nextern uint64_t vdev_get_min_alloc(vdev_t *vd);\nextern uint64_t vdev_get_nparity(vdev_t *vd);\nextern uint64_t vdev_get_ndisks(vdev_t *vd);\n\n \nextern int zfs_vdev_standard_sm_blksz;\n\n \nextern void vdev_indirect_sync_obsolete(vdev_t *vd, dmu_tx_t *tx);\nextern boolean_t vdev_indirect_should_condense(vdev_t *vd);\nextern void spa_condense_indirect_start_sync(vdev_t *vd, dmu_tx_t *tx);\nextern int vdev_obsolete_sm_object(vdev_t *vd, uint64_t *sm_obj);\nextern int vdev_obsolete_counts_are_precise(vdev_t *vd, boolean_t *are_precise);\n\n \nint vdev_checkpoint_sm_object(vdev_t *vd, uint64_t *sm_obj);\nvoid vdev_metaslab_group_create(vdev_t *vd);\nuint64_t vdev_best_ashift(uint64_t logical, uint64_t a, uint64_t b);\n\n \nextern uint_t zfs_vdev_min_auto_ashift;\nextern uint_t zfs_vdev_max_auto_ashift;\nint param_set_min_auto_ashift(ZFS_MODULE_PARAM_ARGS);\nint param_set_max_auto_ashift(ZFS_MODULE_PARAM_ARGS);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}