{
  "module_name": "sa_impl.h",
  "hash_id": "09b49979bc568dc6f6ff6f35b64873fd83b6eb9fbafd12345d39a471cfc2dbba",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/sa_impl.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_SA_IMPL_H\n#define\t_SYS_SA_IMPL_H\n\n#include <sys/dmu.h>\n#include <sys/zfs_refcount.h>\n#include <sys/list.h>\n\n \ntypedef struct sa_attr_table {\n\tsa_attr_type_t\tsa_attr;\n\tuint8_t sa_registered;\n\tuint16_t sa_length;\n\tsa_bswap_type_t sa_byteswap;\n\tchar *sa_name;\n} sa_attr_table_t;\n\n \n\n#define\tATTR_BSWAP(x)\tBF32_GET(x, 16, 8)\n#define\tATTR_LENGTH(x)\tBF32_GET(x, 24, 16)\n#define\tATTR_NUM(x)\tBF32_GET(x, 0, 16)\n#define\tATTR_ENCODE(x, attr, length, bswap) \\\n{ \\\n\tBF64_SET(x, 24, 16, length); \\\n\tBF64_SET(x, 16, 8, bswap); \\\n\tBF64_SET(x, 0, 16, attr); \\\n}\n\n#define\tTOC_OFF(x)\t\tBF32_GET(x, 0, 23)\n#define\tTOC_ATTR_PRESENT(x)\tBF32_GET(x, 31, 1)\n#define\tTOC_LEN_IDX(x)\t\tBF32_GET(x, 24, 4)\n#define\tTOC_ATTR_ENCODE(x, len_idx, offset) \\\n{ \\\n\tBF32_SET(x, 31, 1, 1); \\\n\tBF32_SET(x, 24, 7, len_idx); \\\n\tBF32_SET(x, 0, 24, offset); \\\n}\n\n#define\tSA_LAYOUTS\t\"LAYOUTS\"\n#define\tSA_REGISTRY\t\"REGISTRY\"\n\n \ntypedef struct sa_lot {\n\tavl_node_t lot_num_node;\n\tavl_node_t lot_hash_node;\n\tuint64_t lot_num;\n\tuint64_t lot_hash;\n\tsa_attr_type_t *lot_attrs;\t \n\tuint32_t lot_var_sizes;\t \n\tuint32_t lot_attr_count;\t \n\tlist_t \tlot_idx_tab;\t \n\tint\tlot_instance;\t \n} sa_lot_t;\n\n \ntypedef struct sa_idx_tab {\n\tlist_node_t\tsa_next;\n\tsa_lot_t\t*sa_layout;\n\tuint16_t\t*sa_variable_lengths;\n\tzfs_refcount_t\tsa_refcount;\n\tuint32_t\t*sa_idx_tab;\t \n} sa_idx_tab_t;\n\n \nstruct sa_os {\n\tkmutex_t \tsa_lock;\n\tboolean_t\tsa_need_attr_registration;\n\tboolean_t\tsa_force_spill;\n\tuint64_t\tsa_master_obj;\n\tuint64_t\tsa_reg_attr_obj;\n\tuint64_t\tsa_layout_attr_obj;\n\tint\t\tsa_num_attrs;\n\tsa_attr_table_t *sa_attr_table;\t  \n\tsa_update_cb_t\t*sa_update_cb;\n\tavl_tree_t\tsa_layout_num_tree;   \n\tavl_tree_t\tsa_layout_hash_tree;  \n\tint\t\tsa_user_table_sz;\n\tsa_attr_type_t\t*sa_user_table;  \n};\n\n \n\n#define\tSA_MAGIC\t0x2F505A   \ntypedef struct sa_hdr_phys {\n\tuint32_t sa_magic;\n\t \n\tuint16_t sa_layout_info;\n\tuint16_t sa_lengths[1];\t \n\t \n} sa_hdr_phys_t;\n\n#define\tSA_HDR_LAYOUT_NUM(hdr) BF32_GET(hdr->sa_layout_info, 0, 10)\n#define\tSA_HDR_SIZE(hdr) BF32_GET_SB(hdr->sa_layout_info, 10, 6, 3, 0)\n#define\tSA_HDR_LAYOUT_INFO_ENCODE(x, num, size) \\\n{ \\\n\tBF32_SET_SB(x, 10, 6, 3, 0, size); \\\n\tBF32_SET(x, 0, 10, num); \\\n}\n\ntypedef enum sa_buf_type {\n\tSA_BONUS = 1,\n\tSA_SPILL = 2\n} sa_buf_type_t;\n\ntypedef enum sa_data_op {\n\tSA_LOOKUP,\n\tSA_UPDATE,\n\tSA_ADD,\n\tSA_REPLACE,\n\tSA_REMOVE\n} sa_data_op_t;\n\n \n\nstruct sa_handle {\n\tdmu_buf_user_t\tsa_dbu;\n\tkmutex_t\tsa_lock;\n\tdmu_buf_t\t*sa_bonus;\n\tdmu_buf_t\t*sa_spill;\n\tobjset_t\t*sa_os;\n\tvoid\t\t*sa_userp;\n\tsa_idx_tab_t\t*sa_bonus_tab;\t  \n\tsa_idx_tab_t\t*sa_spill_tab;  \n};\n\n#define\tSA_GET_DB(hdl, type)\t\\\n\t(dmu_buf_impl_t *)((type == SA_BONUS) ? hdl->sa_bonus : hdl->sa_spill)\n\n#define\tSA_GET_HDR(hdl, type) \\\n\t((sa_hdr_phys_t *)((dmu_buf_impl_t *)(SA_GET_DB(hdl, \\\n\ttype))->db.db_data))\n\n#define\tSA_IDX_TAB_GET(hdl, type) \\\n\t(type == SA_BONUS ? hdl->sa_bonus_tab : hdl->sa_spill_tab)\n\n#define\tIS_SA_BONUSTYPE(a)\t\\\n\t((a == DMU_OT_SA) ? B_TRUE : B_FALSE)\n\n#define\tSA_BONUSTYPE_FROM_DB(db) \\\n\t(dmu_get_bonustype((dmu_buf_t *)db))\n\n#define\tSA_BLKPTR_SPACE\t(DN_OLD_MAX_BONUSLEN - sizeof (blkptr_t))\n\n#define\tSA_LAYOUT_NUM(x, type) \\\n\t((!IS_SA_BONUSTYPE(type) ? 0 : (((IS_SA_BONUSTYPE(type)) && \\\n\t((SA_HDR_LAYOUT_NUM(x)) == 0)) ? 1 : SA_HDR_LAYOUT_NUM(x))))\n\n\n#define\tSA_REGISTERED_LEN(sa, attr) sa->sa_attr_table[attr].sa_length\n\n#define\tSA_ATTR_LEN(sa, idx, attr, hdr) ((SA_REGISTERED_LEN(sa, attr) == 0) ?\\\n\thdr->sa_lengths[TOC_LEN_IDX(idx->sa_idx_tab[attr])] : \\\n\tSA_REGISTERED_LEN(sa, attr))\n\n#define\tSA_SET_HDR(hdr, num, size) \\\n\t{ \\\n\t\thdr->sa_magic = SA_MAGIC; \\\n\t\tSA_HDR_LAYOUT_INFO_ENCODE(hdr->sa_layout_info, num, size); \\\n\t}\n\n#define\tSA_ATTR_INFO(sa, idx, hdr, attr, bulk, type, hdl) \\\n\t{ \\\n\t\tbulk.sa_size = SA_ATTR_LEN(sa, idx, attr, hdr); \\\n\t\tbulk.sa_buftype = type; \\\n\t\tbulk.sa_addr = \\\n\t\t    (void *)((uintptr_t)TOC_OFF(idx->sa_idx_tab[attr]) + \\\n\t\t    (uintptr_t)hdr); \\\n}\n\n#define\tSA_HDR_SIZE_MATCH_LAYOUT(hdr, tb) \\\n\t(SA_HDR_SIZE(hdr) == (sizeof (sa_hdr_phys_t) + \\\n\t(tb->lot_var_sizes > 1 ? P2ROUNDUP((tb->lot_var_sizes - 1) * \\\n\tsizeof (uint16_t), 8) : 0)))\n\nint sa_add_impl(sa_handle_t *, sa_attr_type_t,\n    uint32_t, sa_data_locator_t, void *, dmu_tx_t *);\n\nvoid sa_register_update_callback_locked(objset_t *, sa_update_cb_t *);\nint sa_size_locked(sa_handle_t *, sa_attr_type_t, int *);\n\nvoid sa_default_locator(void **, uint32_t *, uint32_t, boolean_t, void *);\nint sa_attr_size(sa_os_t *, sa_idx_tab_t *, sa_attr_type_t,\n    uint16_t *, sa_hdr_phys_t *);\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}