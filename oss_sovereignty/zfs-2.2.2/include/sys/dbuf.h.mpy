{
  "module_name": "dbuf.h",
  "hash_id": "2870c39798ea28e1aa9bef849268289f59a21ce95b0c962e81e0d687b87d255b",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/dbuf.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_DBUF_H\n#define\t_SYS_DBUF_H\n\n#include <sys/dmu.h>\n#include <sys/spa.h>\n#include <sys/txg.h>\n#include <sys/zio.h>\n#include <sys/arc.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_refcount.h>\n#include <sys/zrlock.h>\n#include <sys/multilist.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#define\tIN_DMU_SYNC 2\n\n \n\n#define\tDB_RF_MUST_SUCCEED\t(1 << 0)\n#define\tDB_RF_CANFAIL\t\t(1 << 1)\n#define\tDB_RF_HAVESTRUCT\t(1 << 2)\n#define\tDB_RF_NOPREFETCH\t(1 << 3)\n#define\tDB_RF_NEVERWAIT\t\t(1 << 4)\n#define\tDB_RF_CACHED\t\t(1 << 5)\n#define\tDB_RF_NO_DECRYPT\t(1 << 6)\n#define\tDB_RF_PARTIAL_FIRST\t(1 << 7)\n#define\tDB_RF_PARTIAL_MORE\t(1 << 8)\n\n \ntypedef enum dbuf_states {\n\tDB_SEARCH = -1,\n\tDB_UNCACHED,\n\tDB_FILL,\n\tDB_NOFILL,\n\tDB_READ,\n\tDB_CACHED,\n\tDB_EVICTING\n} dbuf_states_t;\n\ntypedef enum dbuf_cached_state {\n\tDB_NO_CACHE = -1,\n\tDB_DBUF_CACHE,\n\tDB_DBUF_METADATA_CACHE,\n\tDB_CACHE_MAX\n} dbuf_cached_state_t;\n\nstruct dnode;\nstruct dmu_tx;\n\n \n\nstruct dmu_buf_impl;\n\ntypedef enum override_states {\n\tDR_NOT_OVERRIDDEN,\n\tDR_IN_DMU_SYNC,\n\tDR_OVERRIDDEN\n} override_states_t;\n\ntypedef enum db_lock_type {\n\tDLT_NONE,\n\tDLT_PARENT,\n\tDLT_OBJSET\n} db_lock_type_t;\n\ntypedef struct dbuf_dirty_record {\n\t \n\tlist_node_t dr_dirty_node;\n\n\t \n\tuint64_t dr_txg;\n\n\t \n\tzio_t *dr_zio;\n\n\t \n\tstruct dmu_buf_impl *dr_dbuf;\n\n\t \n\tlist_node_t dr_dbuf_node;\n\n\t \n\tdnode_t *dr_dnode;\n\n\t \n\tstruct dbuf_dirty_record *dr_parent;\n\n\t \n\tunsigned int dr_accounted;\n\n\t \n\tblkptr_t dr_bp_copy;\n\n\tunion dirty_types {\n\t\tstruct dirty_indirect {\n\n\t\t\t \n\t\t\tkmutex_t dr_mtx;\n\n\t\t\t \n\t\t\tlist_t dr_children;\n\t\t} di;\n\t\tstruct dirty_leaf {\n\n\t\t\t \n\t\t\tarc_buf_t *dr_data;\n\t\t\tblkptr_t dr_overridden_by;\n\t\t\toverride_states_t dr_override_state;\n\t\t\tuint8_t dr_copies;\n\t\t\tboolean_t dr_nopwrite;\n\t\t\tboolean_t dr_brtwrite;\n\t\t\tboolean_t dr_has_raw_params;\n\n\t\t\t \n\t\t\tboolean_t dr_byteorder;\n\t\t\tuint8_t\tdr_salt[ZIO_DATA_SALT_LEN];\n\t\t\tuint8_t\tdr_iv[ZIO_DATA_IV_LEN];\n\t\t\tuint8_t\tdr_mac[ZIO_DATA_MAC_LEN];\n\t\t} dl;\n\t\tstruct dirty_lightweight_leaf {\n\t\t\t \n\t\t\tuint64_t dr_blkid;\n\t\t\tabd_t *dr_abd;\n\t\t\tzio_prop_t dr_props;\n\t\t\tzio_flag_t dr_flags;\n\t\t} dll;\n\t} dt;\n} dbuf_dirty_record_t;\n\ntypedef struct dmu_buf_impl {\n\t \n\n\t \n\tdmu_buf_t db;\n\n\t \n\tstruct objset *db_objset;\n\n\t \n\tstruct dnode_handle *db_dnode_handle;\n\n\t \n\tstruct dmu_buf_impl *db_parent;\n\n\t \n\tstruct dmu_buf_impl *db_hash_next;\n\n\t \n\tavl_node_t db_link;\n\n\t \n\tuint64_t db_blkid;\n\n\t \n\tblkptr_t *db_blkptr;\n\n\t \n\tuint8_t db_level;\n\n\t \n\tkrwlock_t db_rwlock;\n\n\t \n\tarc_buf_t *db_buf;\n\n\t \n\tkmutex_t db_mtx;\n\n\t \n\tdbuf_states_t db_state;\n\n\t \n\tzfs_refcount_t db_holds;\n\n\tkcondvar_t db_changed;\n\tdbuf_dirty_record_t *db_data_pending;\n\n\t \n\tlist_t db_dirty_records;\n\n\t \n\tmultilist_node_t db_cache_link;\n\n\t \n\tdbuf_cached_state_t db_caching_status;\n\n\tuint64_t db_hash;\n\n\t \n\n\t \n\tdmu_buf_user_t *db_user;\n\n\t \n\tuint8_t db_user_immediate_evict;\n\n\t \n\tuint8_t db_freed_in_flight;\n\n\t \n\tuint8_t db_pending_evict;\n\n\tuint8_t db_dirtycnt;\n\n\t \n\tuint8_t db_partial_read;\n} dmu_buf_impl_t;\n\n#define\tDBUF_HASH_MUTEX(h, idx) \\\n\t(&(h)->hash_mutexes[(idx) & ((h)->hash_mutex_mask)])\n\ntypedef struct dbuf_hash_table {\n\tuint64_t hash_table_mask;\n\tuint64_t hash_mutex_mask;\n\tdmu_buf_impl_t **hash_table;\n\tkmutex_t *hash_mutexes;\n} dbuf_hash_table_t;\n\ntypedef void (*dbuf_prefetch_fn)(void *, uint64_t, uint64_t, boolean_t);\n\nuint64_t dbuf_whichblock(const struct dnode *di, const int64_t level,\n    const uint64_t offset);\n\nvoid dbuf_create_bonus(struct dnode *dn);\nint dbuf_spill_set_blksz(dmu_buf_t *db, uint64_t blksz, dmu_tx_t *tx);\n\nvoid dbuf_rm_spill(struct dnode *dn, dmu_tx_t *tx);\n\ndmu_buf_impl_t *dbuf_hold(struct dnode *dn, uint64_t blkid, const void *tag);\ndmu_buf_impl_t *dbuf_hold_level(struct dnode *dn, int level, uint64_t blkid,\n    const void *tag);\nint dbuf_hold_impl(struct dnode *dn, uint8_t level, uint64_t blkid,\n    boolean_t fail_sparse, boolean_t fail_uncached,\n    const void *tag, dmu_buf_impl_t **dbp);\n\nint dbuf_prefetch_impl(struct dnode *dn, int64_t level, uint64_t blkid,\n    zio_priority_t prio, arc_flags_t aflags, dbuf_prefetch_fn cb,\n    void *arg);\nint dbuf_prefetch(struct dnode *dn, int64_t level, uint64_t blkid,\n    zio_priority_t prio, arc_flags_t aflags);\n\nvoid dbuf_add_ref(dmu_buf_impl_t *db, const void *tag);\nboolean_t dbuf_try_add_ref(dmu_buf_t *db, objset_t *os, uint64_t obj,\n    uint64_t blkid, const void *tag);\nuint64_t dbuf_refcount(dmu_buf_impl_t *db);\n\nvoid dbuf_rele(dmu_buf_impl_t *db, const void *tag);\nvoid dbuf_rele_and_unlock(dmu_buf_impl_t *db, const void *tag,\n    boolean_t evicting);\n\ndmu_buf_impl_t *dbuf_find(struct objset *os, uint64_t object, uint8_t level,\n    uint64_t blkid, uint64_t *hash_out);\n\nint dbuf_read(dmu_buf_impl_t *db, zio_t *zio, uint32_t flags);\nvoid dmu_buf_will_clone(dmu_buf_t *db, dmu_tx_t *tx);\nvoid dmu_buf_will_not_fill(dmu_buf_t *db, dmu_tx_t *tx);\nvoid dmu_buf_will_fill(dmu_buf_t *db, dmu_tx_t *tx);\nvoid dmu_buf_fill_done(dmu_buf_t *db, dmu_tx_t *tx);\nvoid dbuf_assign_arcbuf(dmu_buf_impl_t *db, arc_buf_t *buf, dmu_tx_t *tx);\ndbuf_dirty_record_t *dbuf_dirty(dmu_buf_impl_t *db, dmu_tx_t *tx);\ndbuf_dirty_record_t *dbuf_dirty_lightweight(dnode_t *dn, uint64_t blkid,\n    dmu_tx_t *tx);\nboolean_t dbuf_undirty(dmu_buf_impl_t *db, dmu_tx_t *tx);\narc_buf_t *dbuf_loan_arcbuf(dmu_buf_impl_t *db);\nvoid dmu_buf_write_embedded(dmu_buf_t *dbuf, void *data,\n    bp_embedded_type_t etype, enum zio_compress comp,\n    int uncompressed_size, int compressed_size, int byteorder, dmu_tx_t *tx);\n\nint dmu_lightweight_write_by_dnode(dnode_t *dn, uint64_t offset, abd_t *abd,\n    const struct zio_prop *zp, zio_flag_t flags, dmu_tx_t *tx);\n\nvoid dmu_buf_redact(dmu_buf_t *dbuf, dmu_tx_t *tx);\nvoid dbuf_destroy(dmu_buf_impl_t *db);\n\nvoid dbuf_unoverride(dbuf_dirty_record_t *dr);\nvoid dbuf_sync_list(list_t *list, int level, dmu_tx_t *tx);\nvoid dbuf_release_bp(dmu_buf_impl_t *db);\ndb_lock_type_t dmu_buf_lock_parent(dmu_buf_impl_t *db, krw_t rw,\n    const void *tag);\nvoid dmu_buf_unlock_parent(dmu_buf_impl_t *db, db_lock_type_t type,\n    const void *tag);\n\nvoid dbuf_free_range(struct dnode *dn, uint64_t start, uint64_t end,\n    struct dmu_tx *);\n\nvoid dbuf_new_size(dmu_buf_impl_t *db, int size, dmu_tx_t *tx);\n\nvoid dbuf_stats_init(dbuf_hash_table_t *hash);\nvoid dbuf_stats_destroy(void);\n\nint dbuf_dnode_findbp(dnode_t *dn, uint64_t level, uint64_t blkid,\n    blkptr_t *bp, uint16_t *datablkszsec, uint8_t *indblkshift);\n\n#define\tDB_DNODE(_db)\t\t((_db)->db_dnode_handle->dnh_dnode)\n#define\tDB_DNODE_LOCK(_db)\t((_db)->db_dnode_handle->dnh_zrlock)\n#define\tDB_DNODE_ENTER(_db)\t(zrl_add(&DB_DNODE_LOCK(_db)))\n#define\tDB_DNODE_EXIT(_db)\t(zrl_remove(&DB_DNODE_LOCK(_db)))\n#define\tDB_DNODE_HELD(_db)\t(!zrl_is_zero(&DB_DNODE_LOCK(_db)))\n\nvoid dbuf_init(void);\nvoid dbuf_fini(void);\n\nboolean_t dbuf_is_metadata(dmu_buf_impl_t *db);\n\nstatic inline dbuf_dirty_record_t *\ndbuf_find_dirty_lte(dmu_buf_impl_t *db, uint64_t txg)\n{\n\tdbuf_dirty_record_t *dr;\n\n\tfor (dr = list_head(&db->db_dirty_records);\n\t    dr != NULL && dr->dr_txg > txg;\n\t    dr = list_next(&db->db_dirty_records, dr))\n\t\tcontinue;\n\treturn (dr);\n}\n\nstatic inline dbuf_dirty_record_t *\ndbuf_find_dirty_eq(dmu_buf_impl_t *db, uint64_t txg)\n{\n\tdbuf_dirty_record_t *dr;\n\n\tdr = dbuf_find_dirty_lte(db, txg);\n\tif (dr && dr->dr_txg == txg)\n\t\treturn (dr);\n\treturn (NULL);\n}\n\n#define\tDBUF_GET_BUFC_TYPE(_db)\t\\\n\t(dbuf_is_metadata(_db) ? ARC_BUFC_METADATA : ARC_BUFC_DATA)\n\n#define\tDBUF_IS_CACHEABLE(_db)\t\t\t\t\t\t\\\n\t((_db)->db_objset->os_primary_cache == ZFS_CACHE_ALL ||\t\t\\\n\t(dbuf_is_metadata(_db) &&\t\t\t\t\t\\\n\t((_db)->db_objset->os_primary_cache == ZFS_CACHE_METADATA)))\n\nboolean_t dbuf_is_l2cacheable(dmu_buf_impl_t *db);\n\n#ifdef ZFS_DEBUG\n\n \n#define\tdprintf_dbuf(dbuf, fmt, ...) do { \\\n\tif (zfs_flags & ZFS_DEBUG_DPRINTF) { \\\n\tchar __db_buf[32]; \\\n\tuint64_t __db_obj = (dbuf)->db.db_object; \\\n\tif (__db_obj == DMU_META_DNODE_OBJECT) \\\n\t\t(void) strlcpy(__db_buf, \"mdn\", sizeof (__db_buf));\t\\\n\telse \\\n\t\t(void) snprintf(__db_buf, sizeof (__db_buf), \"%lld\", \\\n\t\t    (u_longlong_t)__db_obj); \\\n\tdprintf_ds((dbuf)->db_objset->os_dsl_dataset, \\\n\t    \"obj=%s lvl=%u blkid=%lld \" fmt, \\\n\t    __db_buf, (dbuf)->db_level, \\\n\t    (u_longlong_t)(dbuf)->db_blkid, __VA_ARGS__); \\\n\t} \\\n} while (0)\n\n#define\tdprintf_dbuf_bp(db, bp, fmt, ...) do {\t\t\t\\\n\tif (zfs_flags & ZFS_DEBUG_DPRINTF) {\t\t\t\\\n\tchar *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);\t\\\n\tsnprintf_blkptr(__blkbuf, BP_SPRINTF_LEN, bp);\t\t\\\n\tdprintf_dbuf(db, fmt \" %s\\n\", __VA_ARGS__, __blkbuf);\t\\\n\tkmem_free(__blkbuf, BP_SPRINTF_LEN);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define\tDBUF_VERIFY(db)\tdbuf_verify(db)\n\n#else\n\n#define\tdprintf_dbuf(db, fmt, ...)\n#define\tdprintf_dbuf_bp(db, bp, fmt, ...)\n#define\tDBUF_VERIFY(db)\n\n#endif\n\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}