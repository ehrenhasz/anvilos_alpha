{
  "module_name": "vdev_raidz_impl.h",
  "hash_id": "4cb83e228c9a4105696ad15d991c06ed50701a1dad7b575832925eb3974ee8ff",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/vdev_raidz_impl.h",
  "human_readable_source": " \n \n\n#ifndef _VDEV_RAIDZ_H\n#define\t_VDEV_RAIDZ_H\n\n#include <sys/types.h>\n#include <sys/debug.h>\n#include <sys/kstat.h>\n#include <sys/abd.h>\n#include <sys/vdev_impl.h>\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#define\tCODE_P\t\t(0U)\n#define\tCODE_Q\t\t(1U)\n#define\tCODE_R\t\t(2U)\n\n#define\tPARITY_P\t(1U)\n#define\tPARITY_PQ\t(2U)\n#define\tPARITY_PQR\t(3U)\n\n#define\tTARGET_X\t(0U)\n#define\tTARGET_Y\t(1U)\n#define\tTARGET_Z\t(2U)\n\n \nenum raidz_math_gen_op {\n\tRAIDZ_GEN_P = 0,\n\tRAIDZ_GEN_PQ,\n\tRAIDZ_GEN_PQR,\n\tRAIDZ_GEN_NUM = 3\n};\n \nenum raidz_rec_op {\n\tRAIDZ_REC_P = 0,\n\tRAIDZ_REC_Q,\n\tRAIDZ_REC_R,\n\tRAIDZ_REC_PQ,\n\tRAIDZ_REC_PR,\n\tRAIDZ_REC_QR,\n\tRAIDZ_REC_PQR,\n\tRAIDZ_REC_NUM = 7\n};\n\nextern const char *const raidz_gen_name[RAIDZ_GEN_NUM];\nextern const char *const raidz_rec_name[RAIDZ_REC_NUM];\n\n \ntypedef void\t\t(*raidz_gen_f)(void *);\ntypedef int\t\t(*raidz_rec_f)(void *, const int *);\ntypedef boolean_t\t(*will_work_f)(void);\ntypedef void\t\t(*init_impl_f)(void);\ntypedef void\t\t(*fini_impl_f)(void);\n\n#define\tRAIDZ_IMPL_NAME_MAX\t(20)\n\ntypedef struct raidz_impl_ops {\n\tinit_impl_f init;\n\tfini_impl_f fini;\n\traidz_gen_f gen[RAIDZ_GEN_NUM];\t \n\traidz_rec_f rec[RAIDZ_REC_NUM];\t \n\twill_work_f is_supported;\t \n\tchar name[RAIDZ_IMPL_NAME_MAX];\t \n} raidz_impl_ops_t;\n\ntypedef struct raidz_col {\n\tuint64_t rc_devidx;\t\t \n\tuint64_t rc_offset;\t\t \n\tuint64_t rc_size;\t\t \n\tabd_t rc_abdstruct;\t\t \n\tabd_t *rc_abd;\t\t\t \n\tabd_t *rc_orig_data;\t\t \n\tint rc_error;\t\t\t \n\tuint8_t rc_tried;\t\t \n\tuint8_t rc_skipped;\t\t \n\tuint8_t rc_need_orig_restore;\t \n\tuint8_t rc_force_repair;\t \n\tuint8_t rc_allow_repair;\t \n} raidz_col_t;\n\ntypedef struct raidz_row {\n\tuint64_t rr_cols;\t\t \n\tuint64_t rr_scols;\t\t \n\tuint64_t rr_bigcols;\t\t \n\tuint64_t rr_missingdata;\t \n\tuint64_t rr_missingparity;\t \n\tuint64_t rr_firstdatacol;\t \n\tabd_t *rr_abd_empty;\t\t \n\tint rr_nempty;\t\t\t \n#ifdef ZFS_DEBUG\n\tuint64_t rr_offset;\t\t \n\tuint64_t rr_size;\t\t \n#endif\n\traidz_col_t rr_col[];\t\t \n} raidz_row_t;\n\ntypedef struct raidz_map {\n\tboolean_t rm_ecksuminjected;\t \n\tint rm_nrows;\t\t\t \n\tint rm_nskip;\t\t\t \n\tint rm_skipstart;\t\t \n\tconst raidz_impl_ops_t *rm_ops;\t \n\traidz_row_t *rm_row[];\t\t \n} raidz_map_t;\n\n\n#define\tRAIDZ_ORIGINAL_IMPL\t(INT_MAX)\n\nextern const raidz_impl_ops_t vdev_raidz_scalar_impl;\nextern boolean_t raidz_will_scalar_work(void);\n\n#if defined(__x86_64) && defined(HAVE_SSE2)\t \nextern const raidz_impl_ops_t vdev_raidz_sse2_impl;\n#endif\n#if defined(__x86_64) && defined(HAVE_SSSE3)\t \nextern const raidz_impl_ops_t vdev_raidz_ssse3_impl;\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX2)\t \nextern const raidz_impl_ops_t vdev_raidz_avx2_impl;\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX512F)\t \nextern const raidz_impl_ops_t vdev_raidz_avx512f_impl;\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX512BW)\t \nextern const raidz_impl_ops_t vdev_raidz_avx512bw_impl;\n#endif\n#if defined(__aarch64__)\nextern const raidz_impl_ops_t vdev_raidz_aarch64_neon_impl;\nextern const raidz_impl_ops_t vdev_raidz_aarch64_neonx2_impl;\n#endif\n#if defined(__powerpc__)\nextern const raidz_impl_ops_t vdev_raidz_powerpc_altivec_impl;\n#endif\n\n \n#define\traidz_parity(rm)\t((rm)->rm_row[0]->rr_firstdatacol)\n#define\traidz_ncols(rm)\t\t((rm)->rm_row[0]->rr_cols)\n#define\traidz_nbigcols(rm)\t((rm)->rm_bigcols)\n#define\traidz_col_p(rm, c)\t((rm)->rm_col + (c))\n#define\traidz_col_size(rm, c)\t((rm)->rm_col[c].rc_size)\n#define\traidz_big_size(rm)\t(raidz_col_size(rm, CODE_P))\n#define\traidz_short_size(rm)\t(raidz_col_size(rm, raidz_ncols(rm)-1))\n\n \n#define\t_RAIDZ_GEN_WRAP(code, impl)\t\t\t\t\t\\\nstatic void\t\t\t\t\t\t\t\t\\\nimpl ## _gen_ ## code(void *rrp)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\traidz_row_t *rr = (raidz_row_t *)rrp;\t\t\t\t\\\n\traidz_generate_## code ## _impl(rr);\t\t\t\t\\\n}\n\n \n#define\t_RAIDZ_REC_WRAP(code, impl)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nimpl ## _rec_ ## code(void *rrp, const int *tgtidx)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\traidz_row_t *rr = (raidz_row_t *)rrp;\t\t\t\t\\\n\treturn (raidz_reconstruct_## code ## _impl(rr, tgtidx));\t\\\n}\n\n \n#define\tDEFINE_GEN_METHODS(impl)\t\t\t\t\t\\\n\t_RAIDZ_GEN_WRAP(p, impl);\t\t\t\t\t\\\n\t_RAIDZ_GEN_WRAP(pq, impl);\t\t\t\t\t\\\n\t_RAIDZ_GEN_WRAP(pqr, impl)\n\n \n#define\tDEFINE_REC_METHODS(impl)\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(p, impl);\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(q, impl);\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(r, impl);\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(pq, impl);\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(pr, impl);\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(qr, impl);\t\t\t\t\t\\\n\t_RAIDZ_REC_WRAP(pqr, impl)\n\n#define\tRAIDZ_GEN_METHODS(impl)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t[RAIDZ_GEN_P] = & impl ## _gen_p,\t\t\t\t\\\n\t[RAIDZ_GEN_PQ] = & impl ## _gen_pq,\t\t\t\t\\\n\t[RAIDZ_GEN_PQR] = & impl ## _gen_pqr\t\t\t\t\\\n}\n\n#define\tRAIDZ_REC_METHODS(impl)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t[RAIDZ_REC_P] = & impl ## _rec_p,\t\t\t\t\\\n\t[RAIDZ_REC_Q] = & impl ## _rec_q,\t\t\t\t\\\n\t[RAIDZ_REC_R] = & impl ## _rec_r,\t\t\t\t\\\n\t[RAIDZ_REC_PQ] = & impl ## _rec_pq,\t\t\t\t\\\n\t[RAIDZ_REC_PR] = & impl ## _rec_pr,\t\t\t\t\\\n\t[RAIDZ_REC_QR] = & impl ## _rec_qr,\t\t\t\t\\\n\t[RAIDZ_REC_PQR] = & impl ## _rec_pqr\t\t\t\t\\\n}\n\n\ntypedef struct raidz_impl_kstat {\n\tuint64_t gen[RAIDZ_GEN_NUM];\t \n\tuint64_t rec[RAIDZ_REC_NUM];\t \n} raidz_impl_kstat_t;\n\n \ntypedef enum raidz_mul_info {\n\t \n\tMUL_Q_X\t\t= 0,\n\t \n\tMUL_R_X\t\t= 0,\n\t \n\tMUL_PQ_X\t= 0,\n\tMUL_PQ_Y\t= 1,\n\t \n\tMUL_PR_X\t= 0,\n\tMUL_PR_Y\t= 1,\n\t \n\tMUL_QR_XQ\t= 0,\n\tMUL_QR_X\t= 1,\n\tMUL_QR_YQ\t= 2,\n\tMUL_QR_Y\t= 3,\n\t \n\tMUL_PQR_XP\t= 0,\n\tMUL_PQR_XQ\t= 1,\n\tMUL_PQR_XR\t= 2,\n\tMUL_PQR_YU\t= 3,\n\tMUL_PQR_YP\t= 4,\n\tMUL_PQR_YQ\t= 5,\n\n\tMUL_CNT\t\t= 6\n} raidz_mul_info_t;\n\n \nextern const uint8_t vdev_raidz_pow2[256] __attribute__((aligned(256)));\n \nextern const uint8_t vdev_raidz_log2[256] __attribute__((aligned(256)));\n\n \nstatic inline uint8_t\nvdev_raidz_exp2(const uint8_t a, const unsigned exp)\n{\n\tif (a == 0)\n\t\treturn (0);\n\n\treturn (vdev_raidz_pow2[(exp + (unsigned)vdev_raidz_log2[a]) % 255]);\n}\n\n \ntypedef unsigned gf_t;\ntypedef unsigned gf_log_t;\n\nstatic inline gf_t\ngf_mul(const gf_t a, const gf_t b)\n{\n\tgf_log_t logsum;\n\n\tif (a == 0 || b == 0)\n\t\treturn (0);\n\n\tlogsum = (gf_log_t)vdev_raidz_log2[a] + (gf_log_t)vdev_raidz_log2[b];\n\n\treturn ((gf_t)vdev_raidz_pow2[logsum % 255]);\n}\n\nstatic inline gf_t\ngf_div(const gf_t  a, const gf_t b)\n{\n\tgf_log_t logsum;\n\n\tASSERT3U(b, >, 0);\n\tif (a == 0)\n\t\treturn (0);\n\n\tlogsum = (gf_log_t)255 + (gf_log_t)vdev_raidz_log2[a] -\n\t    (gf_log_t)vdev_raidz_log2[b];\n\n\treturn ((gf_t)vdev_raidz_pow2[logsum % 255]);\n}\n\nstatic inline gf_t\ngf_inv(const gf_t a)\n{\n\tgf_log_t logsum;\n\n\tASSERT3U(a, >, 0);\n\n\tlogsum = (gf_log_t)255 - (gf_log_t)vdev_raidz_log2[a];\n\n\treturn ((gf_t)vdev_raidz_pow2[logsum]);\n}\n\nstatic inline gf_t\ngf_exp2(gf_log_t exp)\n{\n\treturn (vdev_raidz_pow2[exp % 255]);\n}\n\nstatic inline gf_t\ngf_exp4(gf_log_t exp)\n{\n\tASSERT3U(exp, <=, 255);\n\treturn ((gf_t)vdev_raidz_pow2[(2 * exp) % 255]);\n}\n\n#ifdef  __cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}