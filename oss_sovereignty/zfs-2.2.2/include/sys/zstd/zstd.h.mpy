{
  "module_name": "zstd.h",
  "hash_id": "af4db3d9f69a6d35c11965fa4f48913544eb2e71aecf02404c48e9a6804312bb",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/zstd/zstd.h",
  "human_readable_source": " \n\n \n\n#ifndef\t_ZFS_ZSTD_H\n#define\t_ZFS_ZSTD_H\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \ntypedef struct zfs_zstd_header {\n\t \n\tuint32_t c_len;\n\n\t \n\tuint32_t raw_version_level;\n\tchar data[];\n} zfs_zstdhdr_t;\n\n \ntypedef struct zfs_zstd_meta {\n\tuint8_t level;\n\tuint32_t version;\n} zfs_zstdmeta_t;\n\n \n#define\tZSTDSTAT(stat)\t\t(zstd_stats.stat.value.ui64)\n#define\tZSTDSTAT_ZERO(stat)\t\\\n\tatomic_store_64(&zstd_stats.stat.value.ui64, 0)\n#define\tZSTDSTAT_ADD(stat, val) \\\n\tatomic_add_64(&zstd_stats.stat.value.ui64, (val))\n#define\tZSTDSTAT_SUB(stat, val) \\\n\tatomic_sub_64(&zstd_stats.stat.value.ui64, (val))\n#define\tZSTDSTAT_BUMP(stat)\tZSTDSTAT_ADD(stat, 1)\n\n \nint zstd_init(void);\nvoid zstd_fini(void);\n\nsize_t zfs_zstd_compress(void *s_start, void *d_start, size_t s_len,\n    size_t d_len, int level);\nsize_t zfs_zstd_compress_wrap(void *s_start, void *d_start, size_t s_len,\n    size_t d_len, int level);\nint zfs_zstd_get_level(void *s_start, size_t s_len, uint8_t *level);\nint zfs_zstd_decompress_level(void *s_start, void *d_start, size_t s_len,\n    size_t d_len, uint8_t *level);\nint zfs_zstd_decompress(void *s_start, void *d_start, size_t s_len,\n    size_t d_len, int n);\nvoid zfs_zstd_cache_reap_now(void);\n\n \n\nstatic inline void\nzfs_get_hdrmeta(const zfs_zstdhdr_t *blob, zfs_zstdmeta_t *res)\n{\n\tuint32_t raw = blob->raw_version_level;\n\tuint8_t findme = 0xff;\n\tint shift;\n\tfor (shift = 0; shift < 4; shift++) {\n\t\tfindme = BF32_GET(raw, 8*shift, 8);\n\t\tif (findme == 0)\n\t\t\tbreak;\n\t}\n\tswitch (shift) {\n\tcase 0:\n\t\tres->level = BF32_GET(raw, 24, 8);\n\t\tres->version = BSWAP_32(raw);\n\t\tres->version = BF32_GET(res->version, 8, 24);\n\t\tbreak;\n\tcase 1:\n\t\tres->level = BF32_GET(raw, 0, 8);\n\t\tres->version = BSWAP_32(raw);\n\t\tres->version = BF32_GET(res->version, 0, 24);\n\t\tbreak;\n\tcase 2:\n\t\tres->level = BF32_GET(raw, 24, 8);\n\t\tres->version = BF32_GET(raw, 0, 24);\n\t\tbreak;\n\tcase 3:\n\t\tres->level = BF32_GET(raw, 0, 8);\n\t\tres->version = BF32_GET(raw, 8, 24);\n\t\tbreak;\n\tdefault:\n\t\tres->level = 0;\n\t\tres->version = 0;\n\t\tbreak;\n\t}\n}\n\nstatic inline uint8_t\nzfs_get_hdrlevel(const zfs_zstdhdr_t *blob)\n{\n\tuint8_t level = 0;\n\tzfs_zstdmeta_t res;\n\tzfs_get_hdrmeta(blob, &res);\n\tlevel = res.level;\n\treturn (level);\n}\n\nstatic inline uint32_t\nzfs_get_hdrversion(const zfs_zstdhdr_t *blob)\n{\n\tuint32_t version = 0;\n\tzfs_zstdmeta_t res;\n\tzfs_get_hdrmeta(blob, &res);\n\tversion = res.version;\n\treturn (version);\n\n}\n\nstatic inline void\nzfs_set_hdrversion(zfs_zstdhdr_t *blob, uint32_t version)\n{\n\t \n\tBF32_SET(blob->raw_version_level, 0, 24, version);\n}\n\nstatic inline void\nzfs_set_hdrlevel(zfs_zstdhdr_t *blob, uint8_t level)\n{\n\t \n\tBF32_SET(blob->raw_version_level, 24, 8, level);\n}\n\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}