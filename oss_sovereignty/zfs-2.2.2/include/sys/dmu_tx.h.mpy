{
  "module_name": "dmu_tx.h",
  "hash_id": "81dd066a4db84f25bbc345eea7fe15d664a0556b616c84263249d336f510003c",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/dmu_tx.h",
  "human_readable_source": " \n \n \n\n#ifndef\t_SYS_DMU_TX_H\n#define\t_SYS_DMU_TX_H\n\n#include <sys/inttypes.h>\n#include <sys/dmu.h>\n#include <sys/txg.h>\n#include <sys/zfs_refcount.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\nstruct dmu_buf_impl;\nstruct dmu_tx_hold;\nstruct dnode_link;\nstruct dsl_pool;\nstruct dnode;\nstruct dsl_dir;\n\nstruct dmu_tx {\n\t \n\tlist_t tx_holds;  \n\tobjset_t *tx_objset;\n\tstruct dsl_dir *tx_dir;\n\tstruct dsl_pool *tx_pool;\n\tuint64_t tx_txg;\n\tuint64_t tx_lastsnap_txg;\n\tuint64_t tx_lasttried_txg;\n\ttxg_handle_t tx_txgh;\n\tvoid *tx_tempreserve_cookie;\n\tstruct dmu_tx_hold *tx_needassign_txh;\n\n\t \n\tlist_t tx_callbacks;\n\n\t \n\tboolean_t tx_anyobj;\n\n\t \n\tboolean_t tx_netfree;\n\n\t \n\thrtime_t tx_start;\n\n\t \n\tboolean_t tx_wait_dirty;\n\n\t \n\tboolean_t tx_dirty_delayed;\n\n\tint tx_err;\n};\n\nenum dmu_tx_hold_type {\n\tTHT_NEWOBJECT,\n\tTHT_WRITE,\n\tTHT_BONUS,\n\tTHT_FREE,\n\tTHT_ZAP,\n\tTHT_SPACE,\n\tTHT_SPILL,\n\tTHT_CLONE,\n\tTHT_APPEND,\n\tTHT_NUMTYPES\n};\n\ntypedef struct dmu_tx_hold {\n\tdmu_tx_t *txh_tx;\n\tlist_node_t txh_node;\n\tstruct dnode *txh_dnode;\n\tzfs_refcount_t txh_space_towrite;\n\tzfs_refcount_t txh_memory_tohold;\n\tenum dmu_tx_hold_type txh_type;\n\tuint64_t txh_arg1;\n\tuint64_t txh_arg2;\n} dmu_tx_hold_t;\n\ntypedef struct dmu_tx_callback {\n\tlist_node_t\t\tdcb_node;     \n\tdmu_tx_callback_func_t\t*dcb_func;    \n\tvoid\t\t\t*dcb_data;    \n} dmu_tx_callback_t;\n\n \ntypedef struct dmu_tx_stats {\n\tkstat_named_t dmu_tx_assigned;\n\tkstat_named_t dmu_tx_delay;\n\tkstat_named_t dmu_tx_error;\n\tkstat_named_t dmu_tx_suspended;\n\tkstat_named_t dmu_tx_group;\n\tkstat_named_t dmu_tx_memory_reserve;\n\tkstat_named_t dmu_tx_memory_reclaim;\n\tkstat_named_t dmu_tx_dirty_throttle;\n\tkstat_named_t dmu_tx_dirty_delay;\n\tkstat_named_t dmu_tx_dirty_over_max;\n\tkstat_named_t dmu_tx_dirty_frees_delay;\n\tkstat_named_t dmu_tx_wrlog_delay;\n\tkstat_named_t dmu_tx_quota;\n} dmu_tx_stats_t;\n\nextern dmu_tx_stats_t dmu_tx_stats;\n\n#define\tDMU_TX_STAT_INCR(stat, val) \\\n    atomic_add_64(&dmu_tx_stats.stat.value.ui64, (val));\n#define\tDMU_TX_STAT_BUMP(stat) \\\n    DMU_TX_STAT_INCR(stat, 1);\n\n \ndmu_tx_t *dmu_tx_create(objset_t *dd);\nint dmu_tx_assign(dmu_tx_t *tx, uint64_t txg_how);\nvoid dmu_tx_commit(dmu_tx_t *tx);\nvoid dmu_tx_abort(dmu_tx_t *tx);\nuint64_t dmu_tx_get_txg(dmu_tx_t *tx);\nstruct dsl_pool *dmu_tx_pool(dmu_tx_t *tx);\nvoid dmu_tx_wait(dmu_tx_t *tx);\n\n \nextern dmu_tx_t *dmu_tx_create_assigned(struct dsl_pool *dp, uint64_t txg);\n\n \ndmu_tx_t *dmu_tx_create_dd(dsl_dir_t *dd);\nint dmu_tx_is_syncing(dmu_tx_t *tx);\nint dmu_tx_private_ok(dmu_tx_t *tx);\nvoid dmu_tx_add_new_object(dmu_tx_t *tx, dnode_t *dn);\nvoid dmu_tx_dirty_buf(dmu_tx_t *tx, struct dmu_buf_impl *db);\nvoid dmu_tx_hold_space(dmu_tx_t *tx, uint64_t space);\n\n#ifdef ZFS_DEBUG\n#define\tDMU_TX_DIRTY_BUF(tx, db)\tdmu_tx_dirty_buf(tx, db)\n#else\n#define\tDMU_TX_DIRTY_BUF(tx, db)\n#endif\n\nvoid dmu_tx_init(void);\nvoid dmu_tx_fini(void);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}