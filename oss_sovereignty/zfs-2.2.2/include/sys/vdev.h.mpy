{
  "module_name": "vdev.h",
  "hash_id": "b4a6ba197b93e9210073dae59127cb94d03c94640ace5c8158dd576bf9b1f6f9",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/vdev.h",
  "human_readable_source": " \n\n \n\n#ifndef _SYS_VDEV_H\n#define\t_SYS_VDEV_H\n\n#include <sys/spa.h>\n#include <sys/zio.h>\n#include <sys/dmu.h>\n#include <sys/space_map.h>\n#include <sys/metaslab.h>\n#include <sys/fs/zfs.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum vdev_dtl_type {\n\tDTL_MISSING,\t \n\tDTL_PARTIAL,\t \n\tDTL_SCRUB,\t \n\tDTL_OUTAGE,\t \n\tDTL_TYPES\n} vdev_dtl_type_t;\n\nextern int zfs_nocacheflush;\n\ntypedef boolean_t vdev_open_children_func_t(vdev_t *vd);\n\nextern void vdev_dbgmsg(vdev_t *vd, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\nextern void vdev_dbgmsg_print_tree(vdev_t *, int);\nextern int vdev_open(vdev_t *);\nextern void vdev_open_children(vdev_t *);\nextern void vdev_open_children_subset(vdev_t *, vdev_open_children_func_t *);\nextern int vdev_validate(vdev_t *);\nextern int vdev_copy_path_strict(vdev_t *, vdev_t *);\nextern void vdev_copy_path_relaxed(vdev_t *, vdev_t *);\nextern void vdev_close(vdev_t *);\nextern int vdev_create(vdev_t *, uint64_t txg, boolean_t isreplace);\nextern void vdev_reopen(vdev_t *);\nextern int vdev_validate_aux(vdev_t *vd);\nextern zio_t *vdev_probe(vdev_t *vd, zio_t *pio);\nextern boolean_t vdev_is_concrete(vdev_t *vd);\nextern boolean_t vdev_is_bootable(vdev_t *vd);\nextern vdev_t *vdev_lookup_top(spa_t *spa, uint64_t vdev);\nextern vdev_t *vdev_lookup_by_guid(vdev_t *vd, uint64_t guid);\nextern int vdev_count_leaves(spa_t *spa);\nextern void vdev_dtl_dirty(vdev_t *vd, vdev_dtl_type_t d,\n    uint64_t txg, uint64_t size);\nextern boolean_t vdev_dtl_contains(vdev_t *vd, vdev_dtl_type_t d,\n    uint64_t txg, uint64_t size);\nextern boolean_t vdev_dtl_empty(vdev_t *vd, vdev_dtl_type_t d);\nextern boolean_t vdev_default_need_resilver(vdev_t *vd, const dva_t *dva,\n    size_t psize, uint64_t phys_birth);\nextern boolean_t vdev_dtl_need_resilver(vdev_t *vd, const dva_t *dva,\n    size_t psize, uint64_t phys_birth);\nextern void vdev_dtl_reassess(vdev_t *vd, uint64_t txg, uint64_t scrub_txg,\n    boolean_t scrub_done, boolean_t rebuild_done);\nextern boolean_t vdev_dtl_required(vdev_t *vd);\nextern boolean_t vdev_resilver_needed(vdev_t *vd,\n    uint64_t *minp, uint64_t *maxp);\nextern void vdev_destroy_unlink_zap(vdev_t *vd, uint64_t zapobj,\n    dmu_tx_t *tx);\nextern uint64_t vdev_create_link_zap(vdev_t *vd, dmu_tx_t *tx);\nextern void vdev_construct_zaps(vdev_t *vd, dmu_tx_t *tx);\nextern void vdev_destroy_spacemaps(vdev_t *vd, dmu_tx_t *tx);\nextern void vdev_indirect_mark_obsolete(vdev_t *vd, uint64_t offset,\n    uint64_t size);\nextern void spa_vdev_indirect_mark_obsolete(spa_t *spa, uint64_t vdev,\n    uint64_t offset, uint64_t size, dmu_tx_t *tx);\nextern boolean_t vdev_replace_in_progress(vdev_t *vdev);\n\nextern void vdev_hold(vdev_t *);\nextern void vdev_rele(vdev_t *);\n\nextern int vdev_metaslab_init(vdev_t *vd, uint64_t txg);\nextern void vdev_metaslab_fini(vdev_t *vd);\nextern void vdev_metaslab_set_size(vdev_t *);\nextern void vdev_expand(vdev_t *vd, uint64_t txg);\nextern void vdev_split(vdev_t *vd);\nextern void vdev_deadman(vdev_t *vd, const char *tag);\n\ntypedef void vdev_xlate_func_t(void *arg, range_seg64_t *physical_rs);\n\nextern boolean_t vdev_xlate_is_empty(range_seg64_t *rs);\nextern void vdev_xlate(vdev_t *vd, const range_seg64_t *logical_rs,\n    range_seg64_t *physical_rs, range_seg64_t *remain_rs);\nextern void vdev_xlate_walk(vdev_t *vd, const range_seg64_t *logical_rs,\n    vdev_xlate_func_t *func, void *arg);\n\nextern void vdev_get_stats_ex(vdev_t *vd, vdev_stat_t *vs, vdev_stat_ex_t *vsx);\n\nextern metaslab_group_t *vdev_get_mg(vdev_t *vd, metaslab_class_t *mc);\n\nextern void vdev_get_stats(vdev_t *vd, vdev_stat_t *vs);\nextern void vdev_clear_stats(vdev_t *vd);\nextern void vdev_stat_update(zio_t *zio, uint64_t psize);\nextern void vdev_scan_stat_init(vdev_t *vd);\nextern void vdev_propagate_state(vdev_t *vd);\nextern void vdev_set_state(vdev_t *vd, boolean_t isopen, vdev_state_t state,\n    vdev_aux_t aux);\nextern boolean_t vdev_children_are_offline(vdev_t *vd);\n\nextern void vdev_space_update(vdev_t *vd,\n    int64_t alloc_delta, int64_t defer_delta, int64_t space_delta);\n\nextern int64_t vdev_deflated_space(vdev_t *vd, int64_t space);\n\nextern uint64_t vdev_psize_to_asize(vdev_t *vd, uint64_t psize);\n\n \nstatic inline uint64_t\nvdev_gang_header_asize(vdev_t *vd)\n{\n\treturn (vdev_psize_to_asize(vd, SPA_GANGBLOCKSIZE));\n}\n\nextern int vdev_fault(spa_t *spa, uint64_t guid, vdev_aux_t aux);\nextern int vdev_degrade(spa_t *spa, uint64_t guid, vdev_aux_t aux);\nextern int vdev_online(spa_t *spa, uint64_t guid, uint64_t flags,\n    vdev_state_t *);\nextern int vdev_offline(spa_t *spa, uint64_t guid, uint64_t flags);\nextern int vdev_remove_wanted(spa_t *spa, uint64_t guid);\nextern void vdev_clear(spa_t *spa, vdev_t *vd);\n\nextern boolean_t vdev_is_dead(vdev_t *vd);\nextern boolean_t vdev_readable(vdev_t *vd);\nextern boolean_t vdev_writeable(vdev_t *vd);\nextern boolean_t vdev_allocatable(vdev_t *vd);\nextern boolean_t vdev_accessible(vdev_t *vd, zio_t *zio);\nextern boolean_t vdev_is_spacemap_addressable(vdev_t *vd);\n\nextern void vdev_queue_init(vdev_t *vd);\nextern void vdev_queue_fini(vdev_t *vd);\nextern zio_t *vdev_queue_io(zio_t *zio);\nextern void vdev_queue_io_done(zio_t *zio);\nextern void vdev_queue_change_io_priority(zio_t *zio, zio_priority_t priority);\n\nextern uint32_t vdev_queue_length(vdev_t *vd);\nextern uint64_t vdev_queue_last_offset(vdev_t *vd);\nextern uint64_t vdev_queue_class_length(vdev_t *vq, zio_priority_t p);\n\nextern void vdev_config_dirty(vdev_t *vd);\nextern void vdev_config_clean(vdev_t *vd);\nextern int vdev_config_sync(vdev_t **svd, int svdcount, uint64_t txg);\n\nextern void vdev_state_dirty(vdev_t *vd);\nextern void vdev_state_clean(vdev_t *vd);\n\nextern void vdev_defer_resilver(vdev_t *vd);\nextern boolean_t vdev_clear_resilver_deferred(vdev_t *vd, dmu_tx_t *tx);\n\ntypedef enum vdev_config_flag {\n\tVDEV_CONFIG_SPARE = 1 << 0,\n\tVDEV_CONFIG_L2CACHE = 1 << 1,\n\tVDEV_CONFIG_MOS = 1 << 2,\n\tVDEV_CONFIG_MISSING = 1 << 3\n} vdev_config_flag_t;\n\nextern void vdev_post_kobj_evt(vdev_t *vd);\nextern void vdev_clear_kobj_evt(vdev_t *vd);\nextern void vdev_top_config_generate(spa_t *spa, nvlist_t *config);\nextern nvlist_t *vdev_config_generate(spa_t *spa, vdev_t *vd,\n    boolean_t getstats, vdev_config_flag_t flags);\n\n \nstruct uberblock;\nextern uint64_t vdev_label_offset(uint64_t psize, int l, uint64_t offset);\nextern int vdev_label_number(uint64_t psise, uint64_t offset);\nextern nvlist_t *vdev_label_read_config(vdev_t *vd, uint64_t txg);\nextern void vdev_uberblock_load(vdev_t *, struct uberblock *, nvlist_t **);\nextern void vdev_config_generate_stats(vdev_t *vd, nvlist_t *nv);\nextern void vdev_label_write(zio_t *zio, vdev_t *vd, int l, abd_t *buf, uint64_t\n    offset, uint64_t size, zio_done_func_t *done, void *priv, int flags);\nextern int vdev_label_read_bootenv(vdev_t *, nvlist_t *);\nextern int vdev_label_write_bootenv(vdev_t *, nvlist_t *);\n\ntypedef enum {\n\tVDEV_LABEL_CREATE,\t \n\tVDEV_LABEL_REPLACE,\t \n\tVDEV_LABEL_SPARE,\t \n\tVDEV_LABEL_REMOVE,\t \n\tVDEV_LABEL_L2CACHE,\t \n\tVDEV_LABEL_SPLIT\t \n} vdev_labeltype_t;\n\nextern int vdev_label_init(vdev_t *vd, uint64_t txg, vdev_labeltype_t reason);\n\nextern int vdev_prop_set(vdev_t *vd, nvlist_t *innvl, nvlist_t *outnvl);\nextern int vdev_prop_get(vdev_t *vd, nvlist_t *nvprops, nvlist_t *outnvl);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}