{
  "module_name": "zap_impl.h",
  "hash_id": "2542655274d3a751da7e7c8e1c01d6aef87b7c991ebaf48643cb6da6bc303748",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/zap_impl.h",
  "human_readable_source": " \n\n \n\n#ifndef\t_SYS_ZAP_IMPL_H\n#define\t_SYS_ZAP_IMPL_H\n\n#include <sys/zap.h>\n#include <sys/zfs_context.h>\n#include <sys/avl.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\nextern int fzap_default_block_shift;\n\n#define\tZAP_MAGIC 0x2F52AB2ABULL\n\n#define\tFZAP_BLOCK_SHIFT(zap)\t((zap)->zap_f.zap_block_shift)\n\n#define\tMZAP_ENT_LEN\t\t64\n#define\tMZAP_NAME_LEN\t\t(MZAP_ENT_LEN - 8 - 4 - 2)\n#define\tMZAP_MAX_BLKSZ\t\tSPA_OLD_MAXBLOCKSIZE\n\n#define\tZAP_NEED_CD\t\t(-1U)\n\ntypedef struct mzap_ent_phys {\n\tuint64_t mze_value;\n\tuint32_t mze_cd;\n\tuint16_t mze_pad;\t \n\tchar mze_name[MZAP_NAME_LEN];\n} mzap_ent_phys_t;\n\ntypedef struct mzap_phys {\n\tuint64_t mz_block_type;\t \n\tuint64_t mz_salt;\n\tuint64_t mz_normflags;\n\tuint64_t mz_pad[5];\n\tmzap_ent_phys_t mz_chunk[1];\n\t \n} mzap_phys_t;\n\ntypedef struct mzap_ent {\n\tuint32_t mze_hash;\n\tuint16_t mze_cd;  \n\tuint16_t mze_chunkid;\n} mzap_ent_t;\n\n#define\tMZE_PHYS(zap, mze) \\\n\t(&zap_m_phys(zap)->mz_chunk[(mze)->mze_chunkid])\n\n \n\nstruct dmu_buf;\nstruct zap_leaf;\n\n#define\tZBT_LEAF\t\t((1ULL << 63) + 0)\n#define\tZBT_HEADER\t\t((1ULL << 63) + 1)\n#define\tZBT_MICRO\t\t((1ULL << 63) + 3)\n \n\n \n#define\tZAP_EMBEDDED_PTRTBL_SHIFT(zap) (FZAP_BLOCK_SHIFT(zap) - 3 - 1)\n\n \n#define\tZAP_EMBEDDED_PTRTBL_ENT(zap, idx) \\\n\t((uint64_t *)zap_f_phys(zap)) \\\n\t[(idx) + (1<<ZAP_EMBEDDED_PTRTBL_SHIFT(zap))]\n\n \ntypedef struct zap_phys {\n\tuint64_t zap_block_type;\t \n\tuint64_t zap_magic;\t\t \n\n\tstruct zap_table_phys {\n\t\tuint64_t zt_blk;\t \n\t\tuint64_t zt_numblks;\t \n\t\tuint64_t zt_shift;\t \n\t\tuint64_t zt_nextblk;\t \n\t\tuint64_t zt_blks_copied;  \n\t} zap_ptrtbl;\n\n\tuint64_t zap_freeblk;\t\t \n\tuint64_t zap_num_leafs;\t\t \n\tuint64_t zap_num_entries;\t \n\tuint64_t zap_salt;\t\t \n\tuint64_t zap_normflags;\t\t \n\tuint64_t zap_flags;\t\t \n\t \n} zap_phys_t;\n\ntypedef struct zap_table_phys zap_table_phys_t;\n\ntypedef struct zap {\n\tdmu_buf_user_t zap_dbu;\n\tobjset_t *zap_objset;\n\tuint64_t zap_object;\n\tstruct dmu_buf *zap_dbuf;\n\tkrwlock_t zap_rwlock;\n\tboolean_t zap_ismicro;\n\tint zap_normflags;\n\tuint64_t zap_salt;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tkmutex_t zap_num_entries_mtx;\n\t\t\tint zap_block_shift;\n\t\t} zap_fat;\n\t\tstruct {\n\t\t\tint16_t zap_num_entries;\n\t\t\tint16_t zap_num_chunks;\n\t\t\tint16_t zap_alloc_next;\n\t\t\tzfs_btree_t zap_tree;\n\t\t} zap_micro;\n\t} zap_u;\n} zap_t;\n\nstatic inline zap_phys_t *\nzap_f_phys(zap_t *zap)\n{\n\treturn (zap->zap_dbuf->db_data);\n}\n\nstatic inline mzap_phys_t *\nzap_m_phys(zap_t *zap)\n{\n\treturn (zap->zap_dbuf->db_data);\n}\n\ntypedef struct zap_name {\n\tzap_t *zn_zap;\n\tint zn_key_intlen;\n\tconst void *zn_key_orig;\n\tint zn_key_orig_numints;\n\tconst void *zn_key_norm;\n\tint zn_key_norm_numints;\n\tuint64_t zn_hash;\n\tmatchtype_t zn_matchtype;\n\tint zn_normflags;\n\tchar zn_normbuf[ZAP_MAXNAMELEN];\n} zap_name_t;\n\n#define\tzap_f\tzap_u.zap_fat\n#define\tzap_m\tzap_u.zap_micro\n\nboolean_t zap_match(zap_name_t *zn, const char *matchname);\nint zap_lockdir(objset_t *os, uint64_t obj, dmu_tx_t *tx,\n    krw_t lti, boolean_t fatreader, boolean_t adding, const void *tag,\n    zap_t **zapp);\nvoid zap_unlockdir(zap_t *zap, const void *tag);\nvoid zap_evict_sync(void *dbu);\nzap_name_t *zap_name_alloc_str(zap_t *zap, const char *key, matchtype_t mt);\nvoid zap_name_free(zap_name_t *zn);\nint zap_hashbits(zap_t *zap);\nuint32_t zap_maxcd(zap_t *zap);\nuint64_t zap_getflags(zap_t *zap);\n\n#define\tZAP_HASH_IDX(hash, n) (((n) == 0) ? 0 : ((hash) >> (64 - (n))))\n\nvoid fzap_byteswap(void *buf, size_t size);\nint fzap_count(zap_t *zap, uint64_t *count);\nint fzap_lookup(zap_name_t *zn,\n    uint64_t integer_size, uint64_t num_integers, void *buf,\n    char *realname, int rn_len, boolean_t *normalization_conflictp);\nvoid fzap_prefetch(zap_name_t *zn);\nint fzap_add(zap_name_t *zn, uint64_t integer_size, uint64_t num_integers,\n    const void *val, const void *tag, dmu_tx_t *tx);\nint fzap_update(zap_name_t *zn,\n    int integer_size, uint64_t num_integers, const void *val,\n    const void *tag, dmu_tx_t *tx);\nint fzap_length(zap_name_t *zn,\n    uint64_t *integer_size, uint64_t *num_integers);\nint fzap_remove(zap_name_t *zn, dmu_tx_t *tx);\nint fzap_cursor_retrieve(zap_t *zap, zap_cursor_t *zc, zap_attribute_t *za);\nvoid fzap_get_stats(zap_t *zap, zap_stats_t *zs);\nvoid zap_put_leaf(struct zap_leaf *l);\n\nint fzap_add_cd(zap_name_t *zn,\n    uint64_t integer_size, uint64_t num_integers,\n    const void *val, uint32_t cd, const void *tag, dmu_tx_t *tx);\nvoid fzap_upgrade(zap_t *zap, dmu_tx_t *tx, zap_flags_t flags);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}