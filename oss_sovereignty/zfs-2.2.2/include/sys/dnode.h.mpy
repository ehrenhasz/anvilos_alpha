{
  "module_name": "dnode.h",
  "hash_id": "c8d17b8e050ab22c877b8f9ee555465e92ccc6e7ba4a8f0ac4bc6b90ecfb0cb6",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/dnode.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_DNODE_H\n#define\t_SYS_DNODE_H\n\n#include <sys/zfs_context.h>\n#include <sys/avl.h>\n#include <sys/spa.h>\n#include <sys/txg.h>\n#include <sys/zio.h>\n#include <sys/zfs_refcount.h>\n#include <sys/dmu_zfetch.h>\n#include <sys/zrlock.h>\n#include <sys/multilist.h>\n#include <sys/wmsum.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n#define\tDNODE_MUST_BE_ALLOCATED\t1\n#define\tDNODE_MUST_BE_FREE\t2\n#define\tDNODE_DRY_RUN\t\t4\n\n \n#define\tDNODE_FIND_HOLE\t\t1\n#define\tDNODE_FIND_BACKWARDS\t2\n#define\tDNODE_FIND_HAVELOCK\t4\n\n \n#define\tDNODE_SHIFT\t\t9\t \n#define\tDN_MIN_INDBLKSHIFT\t12\t \n \n#define\tDN_MAX_INDBLKSHIFT\t17\t \n#define\tDNODE_BLOCK_SHIFT\t14\t \n#define\tDNODE_CORE_SIZE\t\t64\t \n#define\tDN_MAX_OBJECT_SHIFT\t48\t \n#define\tDN_MAX_OFFSET_SHIFT\t64\t \n\n \n#define\tDN_ID_CHKED_BONUS\t0x1\n#define\tDN_ID_CHKED_SPILL\t0x2\n#define\tDN_ID_OLD_EXIST\t\t0x4\n#define\tDN_ID_NEW_EXIST\t\t0x8\n\n \n#define\tDNODE_MIN_SIZE\t\t(1 << DNODE_SHIFT)\n#define\tDNODE_MAX_SIZE\t\t(1 << DNODE_BLOCK_SHIFT)\n#define\tDNODE_BLOCK_SIZE\t(1 << DNODE_BLOCK_SHIFT)\n#define\tDNODE_MIN_SLOTS\t\t(DNODE_MIN_SIZE >> DNODE_SHIFT)\n#define\tDNODE_MAX_SLOTS\t\t(DNODE_MAX_SIZE >> DNODE_SHIFT)\n#define\tDN_BONUS_SIZE(dnsize)\t((dnsize) - DNODE_CORE_SIZE - \\\n\t(1 << SPA_BLKPTRSHIFT))\n#define\tDN_SLOTS_TO_BONUSLEN(slots)\tDN_BONUS_SIZE((slots) << DNODE_SHIFT)\n#define\tDN_OLD_MAX_BONUSLEN\t(DN_BONUS_SIZE(DNODE_MIN_SIZE))\n#define\tDN_MAX_NBLKPTR\t((DNODE_MIN_SIZE - DNODE_CORE_SIZE) >> SPA_BLKPTRSHIFT)\n#define\tDN_MAX_OBJECT\t(1ULL << DN_MAX_OBJECT_SHIFT)\n#define\tDN_ZERO_BONUSLEN\t(DN_BONUS_SIZE(DNODE_MAX_SIZE) + 1)\n#define\tDN_KILL_SPILLBLK (1)\n\n#define\tDN_SLOT_UNINIT\t\t((void *)NULL)\t \n#define\tDN_SLOT_FREE\t\t((void *)1UL)\t \n#define\tDN_SLOT_ALLOCATED\t((void *)2UL)\t \n#define\tDN_SLOT_INTERIOR\t((void *)3UL)\t \n#define\tDN_SLOT_IS_PTR(dn)\t((void *)dn > DN_SLOT_INTERIOR)\n#define\tDN_SLOT_IS_VALID(dn)\t((void *)dn != NULL)\n\n#define\tDNODES_PER_BLOCK_SHIFT\t(DNODE_BLOCK_SHIFT - DNODE_SHIFT)\n#define\tDNODES_PER_BLOCK\t(1ULL << DNODES_PER_BLOCK_SHIFT)\n\n \n#define\tDNODES_PER_LEVEL_SHIFT\t(DN_MAX_INDBLKSHIFT - SPA_BLKPTRSHIFT)\n#define\tDNODES_PER_LEVEL\t(1ULL << DNODES_PER_LEVEL_SHIFT)\n\n#define\tDN_MAX_LEVELS\t(DIV_ROUND_UP(DN_MAX_OFFSET_SHIFT - SPA_MINBLOCKSHIFT, \\\n\tDN_MIN_INDBLKSHIFT - SPA_BLKPTRSHIFT) + 1)\n\n \n#define\tDN_BONUS(dnp)\t((void*)((dnp)->dn_bonus_flexible + \\\n\t(((dnp)->dn_nblkptr - 1) * sizeof (blkptr_t))))\n#define\tDN_MAX_BONUS_LEN(dnp) \\\n\t((dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) ? \\\n\t(uint8_t *)DN_SPILL_BLKPTR(dnp) - (uint8_t *)DN_BONUS(dnp) : \\\n\t(uint8_t *)(dnp + (dnp->dn_extra_slots + 1)) - (uint8_t *)DN_BONUS(dnp))\n\n#define\tDN_USED_BYTES(dnp) (((dnp)->dn_flags & DNODE_FLAG_USED_BYTES) ? \\\n\t(dnp)->dn_used : (dnp)->dn_used << SPA_MINBLOCKSHIFT)\n\n#define\tEPB(blkshift, typeshift)\t(1 << (blkshift - typeshift))\n\nstruct dmu_buf_impl;\nstruct objset;\nstruct zio;\n\nenum dnode_dirtycontext {\n\tDN_UNDIRTIED,\n\tDN_DIRTY_OPEN,\n\tDN_DIRTY_SYNC\n};\n\n \n#define\tDNODE_FLAG_USED_BYTES\t\t\t(1 << 0)\n#define\tDNODE_FLAG_USERUSED_ACCOUNTED\t\t(1 << 1)\n\n \n#define\tDNODE_FLAG_SPILL_BLKPTR\t\t\t(1 << 2)\n\n \n#define\tDNODE_FLAG_USEROBJUSED_ACCOUNTED\t(1 << 3)\n\n \n#define\tDNODE_CRYPT_PORTABLE_FLAGS_MASK\t\t(DNODE_FLAG_SPILL_BLKPTR)\n\n \n\ntypedef struct dnode_phys {\n\tuint8_t dn_type;\t\t \n\tuint8_t dn_indblkshift;\t\t \n\tuint8_t dn_nlevels;\t\t \n\tuint8_t dn_nblkptr;\t\t \n\tuint8_t dn_bonustype;\t\t \n\tuint8_t\tdn_checksum;\t\t \n\tuint8_t\tdn_compress;\t\t \n\tuint8_t dn_flags;\t\t \n\tuint16_t dn_datablkszsec;\t \n\tuint16_t dn_bonuslen;\t\t \n\tuint8_t dn_extra_slots;\t\t \n\tuint8_t dn_pad2[3];\n\n\t \n\tuint64_t dn_maxblkid;\t\t \n\tuint64_t dn_used;\t\t \n\n\t \n\tuint64_t dn_pad3[4];\n\n\t \n\tunion {\n\t\tblkptr_t dn_blkptr[1+DN_OLD_MAX_BONUSLEN/sizeof (blkptr_t)];\n\t\tstruct {\n\t\t\tblkptr_t __dn_ignore1;\n\t\t\tuint8_t dn_bonus[DN_OLD_MAX_BONUSLEN];\n\t\t};\n\t\tstruct {\n\t\t\tblkptr_t __dn_ignore2;\n\t\t\tuint8_t __dn_ignore3[DN_OLD_MAX_BONUSLEN -\n\t\t\t    sizeof (blkptr_t)];\n\t\t\tblkptr_t dn_spill;\n\t\t};\n\t\tstruct {\n\t\t\tblkptr_t __dn_ignore4;\n\t\t\tuint8_t dn_bonus_flexible[];\n\t\t};\n\t};\n} dnode_phys_t;\n\n#define\tDN_SPILL_BLKPTR(dnp)\t((blkptr_t *)((char *)(dnp) + \\\n\t(((dnp)->dn_extra_slots + 1) << DNODE_SHIFT) - (1 << SPA_BLKPTRSHIFT)))\n\nstruct dnode {\n\t \n\tkrwlock_t dn_struct_rwlock;\n\n\t \n\tlist_node_t dn_link;\n\n\t \n\tstruct objset *dn_objset;\n\tuint64_t dn_object;\n\tstruct dmu_buf_impl *dn_dbuf;\n\tstruct dnode_handle *dn_handle;\n\tdnode_phys_t *dn_phys;  \n\n\t \n\tdmu_object_type_t dn_type;\t \n\tuint16_t dn_bonuslen;\t\t \n\tuint8_t dn_bonustype;\t\t \n\tuint8_t dn_nblkptr;\t\t \n\tuint8_t dn_checksum;\t\t \n\tuint8_t dn_compress;\t\t \n\tuint8_t dn_nlevels;\n\tuint8_t dn_indblkshift;\n\tuint8_t dn_datablkshift;\t \n\tuint8_t dn_moved;\t\t \n\tuint16_t dn_datablkszsec;\t \n\tuint32_t dn_datablksz;\t\t \n\tuint64_t dn_maxblkid;\n\tuint8_t dn_next_type[TXG_SIZE];\n\tuint8_t dn_num_slots;\t\t \n\tuint8_t dn_next_nblkptr[TXG_SIZE];\n\tuint8_t dn_next_nlevels[TXG_SIZE];\n\tuint8_t dn_next_indblkshift[TXG_SIZE];\n\tuint8_t dn_next_bonustype[TXG_SIZE];\n\tuint8_t dn_rm_spillblk[TXG_SIZE];\t \n\tuint16_t dn_next_bonuslen[TXG_SIZE];\n\tuint32_t dn_next_blksz[TXG_SIZE];\t \n\tuint64_t dn_next_maxblkid[TXG_SIZE];\t \n\n\t \n\tuint32_t dn_dbufs_count;\t \n\n\t \n\tmultilist_node_t dn_dirty_link[TXG_SIZE];  \n\n\t \n\tkmutex_t dn_mtx;\n\tlist_t dn_dirty_records[TXG_SIZE];\n\tstruct range_tree *dn_free_ranges[TXG_SIZE];\n\tuint64_t dn_allocated_txg;\n\tuint64_t dn_free_txg;\n\tuint64_t dn_assigned_txg;\n\tuint64_t dn_dirty_txg;\t\t\t \n\tkcondvar_t dn_notxholds;\n\tkcondvar_t dn_nodnholds;\n\tenum dnode_dirtycontext dn_dirtyctx;\n\tconst void *dn_dirtyctx_firstset;\t \n\n\t \n\tzfs_refcount_t dn_tx_holds;\n\tzfs_refcount_t dn_holds;\n\n\tkmutex_t dn_dbufs_mtx;\n\t \n\tavl_tree_t dn_dbufs;\n\n\t \n\tstruct dmu_buf_impl *dn_bonus;\t \n\n\tboolean_t dn_have_spill;\t \n\n\t \n\tzio_t *dn_zio;\n\n\t \n\tuint64_t dn_oldused;\t \n\tuint64_t dn_oldflags;\t \n\tuint64_t dn_olduid, dn_oldgid, dn_oldprojid;\n\tuint64_t dn_newuid, dn_newgid, dn_newprojid;\n\tint dn_id_flags;\n\n\t \n\tstruct zfetch\tdn_zfetch;\n};\n\n \n#define\tDN_DBUFS_COUNT(dn)\t((dn)->dn_dbufs_count + \\\n    avl_numnodes(&(dn)->dn_dbufs))\n\n \n#define\tDMU_NEXT_MAXBLKID_SET\t\t(1ULL << 63)\n\n \ntypedef struct dnode_handle {\n\t \n\tzrlock_t dnh_zrlock;\n\tdnode_t *dnh_dnode;\n} dnode_handle_t;\n\ntypedef struct dnode_children {\n\tdmu_buf_user_t dnc_dbu;\t\t \n\tsize_t dnc_count;\t\t \n\tdnode_handle_t dnc_children[];\t \n} dnode_children_t;\n\ntypedef struct free_range {\n\tavl_node_t fr_node;\n\tuint64_t fr_blkid;\n\tuint64_t fr_nblks;\n} free_range_t;\n\nvoid dnode_special_open(struct objset *dd, dnode_phys_t *dnp,\n    uint64_t object, dnode_handle_t *dnh);\nvoid dnode_special_close(dnode_handle_t *dnh);\n\nvoid dnode_setbonuslen(dnode_t *dn, int newsize, dmu_tx_t *tx);\nvoid dnode_setbonus_type(dnode_t *dn, dmu_object_type_t, dmu_tx_t *tx);\nvoid dnode_rm_spill(dnode_t *dn, dmu_tx_t *tx);\n\nint dnode_hold(struct objset *dd, uint64_t object,\n    const void *ref, dnode_t **dnp);\nint dnode_hold_impl(struct objset *dd, uint64_t object, int flag, int dn_slots,\n    const void *ref, dnode_t **dnp);\nboolean_t dnode_add_ref(dnode_t *dn, const void *ref);\nvoid dnode_rele(dnode_t *dn, const void *ref);\nvoid dnode_rele_and_unlock(dnode_t *dn, const void *tag, boolean_t evicting);\nint dnode_try_claim(objset_t *os, uint64_t object, int slots);\nboolean_t dnode_is_dirty(dnode_t *dn);\nvoid dnode_setdirty(dnode_t *dn, dmu_tx_t *tx);\nvoid dnode_set_dirtyctx(dnode_t *dn, dmu_tx_t *tx, const void *tag);\nvoid dnode_sync(dnode_t *dn, dmu_tx_t *tx);\nvoid dnode_allocate(dnode_t *dn, dmu_object_type_t ot, int blocksize, int ibs,\n    dmu_object_type_t bonustype, int bonuslen, int dn_slots, dmu_tx_t *tx);\nvoid dnode_reallocate(dnode_t *dn, dmu_object_type_t ot, int blocksize,\n    dmu_object_type_t bonustype, int bonuslen, int dn_slots,\n    boolean_t keep_spill, dmu_tx_t *tx);\nvoid dnode_free(dnode_t *dn, dmu_tx_t *tx);\nvoid dnode_byteswap(dnode_phys_t *dnp);\nvoid dnode_buf_byteswap(void *buf, size_t size);\nvoid dnode_verify(dnode_t *dn);\nint dnode_set_nlevels(dnode_t *dn, int nlevels, dmu_tx_t *tx);\nint dnode_set_blksz(dnode_t *dn, uint64_t size, int ibs, dmu_tx_t *tx);\nvoid dnode_free_range(dnode_t *dn, uint64_t off, uint64_t len, dmu_tx_t *tx);\nvoid dnode_diduse_space(dnode_t *dn, int64_t space);\nvoid dnode_new_blkid(dnode_t *dn, uint64_t blkid, dmu_tx_t *tx,\n    boolean_t have_read, boolean_t force);\nuint64_t dnode_block_freed(dnode_t *dn, uint64_t blkid);\nvoid dnode_init(void);\nvoid dnode_fini(void);\nint dnode_next_offset(dnode_t *dn, int flags, uint64_t *off,\n    int minlvl, uint64_t blkfill, uint64_t txg);\nvoid dnode_evict_dbufs(dnode_t *dn);\nvoid dnode_evict_bonus(dnode_t *dn);\nvoid dnode_free_interior_slots(dnode_t *dn);\n\n#define\tDNODE_IS_DIRTY(_dn)\t\t\t\t\t\t\\\n\t((_dn)->dn_dirty_txg >= spa_syncing_txg((_dn)->dn_objset->os_spa))\n\n#define\tDNODE_LEVEL_IS_CACHEABLE(_dn, _level)\t\t\t\t\\\n\t((_dn)->dn_objset->os_primary_cache == ZFS_CACHE_ALL ||\t\t\\\n\t(((_level) > 0 || DMU_OT_IS_METADATA((_dn)->dn_type)) &&\t\\\n\t(_dn)->dn_objset->os_primary_cache == ZFS_CACHE_METADATA))\n\n \ntypedef struct dnode_stats {\n\t \n\tkstat_named_t dnode_hold_dbuf_hold;\n\t \n\tkstat_named_t dnode_hold_dbuf_read;\n\t \n\tkstat_named_t dnode_hold_alloc_hits;\n\t \n\tkstat_named_t dnode_hold_alloc_misses;\n\t \n\tkstat_named_t dnode_hold_alloc_interior;\n\t \n\tkstat_named_t dnode_hold_alloc_lock_retry;\n\t \n\tkstat_named_t dnode_hold_alloc_lock_misses;\n\t \n\tkstat_named_t dnode_hold_alloc_type_none;\n\t \n\tkstat_named_t dnode_hold_free_hits;\n\t \n\tkstat_named_t dnode_hold_free_misses;\n\t \n\tkstat_named_t dnode_hold_free_lock_misses;\n\t \n\tkstat_named_t dnode_hold_free_lock_retry;\n\t \n\tkstat_named_t dnode_hold_free_refcount;\n\t \n\tkstat_named_t dnode_hold_free_overflow;\n\t \n\tkstat_named_t dnode_free_interior_lock_retry;\n\t \n\tkstat_named_t dnode_allocate;\n\t \n\tkstat_named_t dnode_reallocate;\n\t \n\tkstat_named_t dnode_buf_evict;\n\t \n\tkstat_named_t dnode_alloc_next_chunk;\n\t \n\tkstat_named_t dnode_alloc_race;\n\t \n\tkstat_named_t dnode_alloc_next_block;\n\t \n\tkstat_named_t dnode_move_invalid;\n\tkstat_named_t dnode_move_recheck1;\n\tkstat_named_t dnode_move_recheck2;\n\tkstat_named_t dnode_move_special;\n\tkstat_named_t dnode_move_handle;\n\tkstat_named_t dnode_move_rwlock;\n\tkstat_named_t dnode_move_active;\n} dnode_stats_t;\n\ntypedef struct dnode_sums {\n\twmsum_t dnode_hold_dbuf_hold;\n\twmsum_t dnode_hold_dbuf_read;\n\twmsum_t dnode_hold_alloc_hits;\n\twmsum_t dnode_hold_alloc_misses;\n\twmsum_t dnode_hold_alloc_interior;\n\twmsum_t dnode_hold_alloc_lock_retry;\n\twmsum_t dnode_hold_alloc_lock_misses;\n\twmsum_t dnode_hold_alloc_type_none;\n\twmsum_t dnode_hold_free_hits;\n\twmsum_t dnode_hold_free_misses;\n\twmsum_t dnode_hold_free_lock_misses;\n\twmsum_t dnode_hold_free_lock_retry;\n\twmsum_t dnode_hold_free_refcount;\n\twmsum_t dnode_hold_free_overflow;\n\twmsum_t dnode_free_interior_lock_retry;\n\twmsum_t dnode_allocate;\n\twmsum_t dnode_reallocate;\n\twmsum_t dnode_buf_evict;\n\twmsum_t dnode_alloc_next_chunk;\n\twmsum_t dnode_alloc_race;\n\twmsum_t dnode_alloc_next_block;\n\twmsum_t dnode_move_invalid;\n\twmsum_t dnode_move_recheck1;\n\twmsum_t dnode_move_recheck2;\n\twmsum_t dnode_move_special;\n\twmsum_t dnode_move_handle;\n\twmsum_t dnode_move_rwlock;\n\twmsum_t dnode_move_active;\n} dnode_sums_t;\n\nextern dnode_stats_t dnode_stats;\nextern dnode_sums_t dnode_sums;\n\n#define\tDNODE_STAT_INCR(stat, val) \\\n    wmsum_add(&dnode_sums.stat, (val))\n#define\tDNODE_STAT_BUMP(stat) \\\n    DNODE_STAT_INCR(stat, 1);\n\n#ifdef ZFS_DEBUG\n\n#define\tdprintf_dnode(dn, fmt, ...) do { \\\n\tif (zfs_flags & ZFS_DEBUG_DPRINTF) { \\\n\tchar __db_buf[32]; \\\n\tuint64_t __db_obj = (dn)->dn_object; \\\n\tif (__db_obj == DMU_META_DNODE_OBJECT) \\\n\t\t(void) strlcpy(__db_buf, \"mdn\", sizeof (__db_buf));\t\\\n\telse \\\n\t\t(void) snprintf(__db_buf, sizeof (__db_buf), \"%lld\", \\\n\t\t    (u_longlong_t)__db_obj);\\\n\tdprintf_ds((dn)->dn_objset->os_dsl_dataset, \"obj=%s \" fmt, \\\n\t    __db_buf, __VA_ARGS__); \\\n\t} \\\n} while (0)\n\n#define\tDNODE_VERIFY(dn)\t\tdnode_verify(dn)\n#define\tFREE_VERIFY(db, start, end, tx)\tfree_verify(db, start, end, tx)\n\n#else\n\n#define\tdprintf_dnode(db, fmt, ...)\n#define\tDNODE_VERIFY(dn)\t\t((void) sizeof ((uintptr_t)(dn)))\n#define\tFREE_VERIFY(db, start, end, tx)\n\n#endif\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}