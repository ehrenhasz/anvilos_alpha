{
  "module_name": "arc.h",
  "hash_id": "fef30374b87e87db0775dc19bf13b43e2d5b8869d0a918da29c1aa912f3d13a3",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/arc.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_ARC_H\n#define\t_SYS_ARC_H\n\n#include <sys/zfs_context.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#include <sys/zio.h>\n#include <sys/dmu.h>\n#include <sys/spa.h>\n#include <sys/zfs_refcount.h>\n\n \n#define\tARC_EVICT_ALL\tUINT64_MAX\n\n \n#define\tMIN_ARC_MAX\tDMU_MAX_ACCESS\n\n#define\tHDR_SET_LSIZE(hdr, x) do { \\\n\tASSERT(IS_P2ALIGNED(x, 1U << SPA_MINBLOCKSHIFT)); \\\n\t(hdr)->b_lsize = ((x) >> SPA_MINBLOCKSHIFT); \\\n} while (0)\n\n#define\tHDR_SET_PSIZE(hdr, x) do { \\\n\tASSERT(IS_P2ALIGNED((x), 1U << SPA_MINBLOCKSHIFT)); \\\n\t(hdr)->b_psize = ((x) >> SPA_MINBLOCKSHIFT); \\\n} while (0)\n\n#define\tHDR_GET_LSIZE(hdr)\t((hdr)->b_lsize << SPA_MINBLOCKSHIFT)\n#define\tHDR_GET_PSIZE(hdr)\t((hdr)->b_psize << SPA_MINBLOCKSHIFT)\n\ntypedef struct arc_buf_hdr arc_buf_hdr_t;\ntypedef struct arc_buf arc_buf_t;\ntypedef struct arc_prune arc_prune_t;\n\n \ntypedef void arc_read_done_func_t(zio_t *zio, const zbookmark_phys_t *zb,\n    const blkptr_t *bp, arc_buf_t *buf, void *priv);\ntypedef void arc_write_done_func_t(zio_t *zio, arc_buf_t *buf, void *priv);\ntypedef void arc_prune_func_t(uint64_t bytes, void *priv);\n\n \nextern uint_t zfs_arc_average_blocksize;\nextern int l2arc_exclude_special;\n\n \narc_read_done_func_t arc_bcopy_func;\narc_read_done_func_t arc_getbuf_func;\n\n \nstruct arc_prune {\n\tarc_prune_func_t\t*p_pfunc;\n\tvoid\t\t\t*p_private;\n\tuint64_t\t\tp_adjust;\n\tlist_node_t\t\tp_node;\n\tzfs_refcount_t\t\tp_refcnt;\n};\n\ntypedef enum arc_strategy {\n\tARC_STRATEGY_META_ONLY\t\t= 0,  \n\tARC_STRATEGY_META_BALANCED\t= 1,  \n} arc_strategy_t;\n\ntypedef enum arc_flags\n{\n\t \n\tARC_FLAG_WAIT\t\t\t= 1 << 0,\t \n\tARC_FLAG_NOWAIT\t\t\t= 1 << 1,\t \n\tARC_FLAG_PREFETCH\t\t= 1 << 2,\t \n\tARC_FLAG_CACHED\t\t\t= 1 << 3,\t \n\tARC_FLAG_L2CACHE\t\t= 1 << 4,\t \n\tARC_FLAG_UNCACHED\t\t= 1 << 5,\t \n\tARC_FLAG_PRESCIENT_PREFETCH\t= 1 << 6,\t \n\n\t \n\tARC_FLAG_IN_HASH_TABLE\t\t= 1 << 7,\t \n\tARC_FLAG_IO_IN_PROGRESS\t\t= 1 << 8,\t \n\tARC_FLAG_IO_ERROR\t\t= 1 << 9,\t \n\tARC_FLAG_INDIRECT\t\t= 1 << 10,\t \n\t \n\tARC_FLAG_PRIO_ASYNC_READ\t= 1 << 11,\n\tARC_FLAG_L2_WRITING\t\t= 1 << 12,\t \n\tARC_FLAG_L2_EVICTED\t\t= 1 << 13,\t \n\tARC_FLAG_L2_WRITE_HEAD\t\t= 1 << 14,\t \n\t \n\tARC_FLAG_PROTECTED\t\t= 1 << 15,\n\t \n\tARC_FLAG_NOAUTH\t\t\t= 1 << 16,\n\t \n\tARC_FLAG_BUFC_METADATA\t\t= 1 << 17,\n\n\t \n\tARC_FLAG_HAS_L1HDR\t\t= 1 << 18,\n\tARC_FLAG_HAS_L2HDR\t\t= 1 << 19,\n\n\t \n\tARC_FLAG_COMPRESSED_ARC\t\t= 1 << 20,\n\tARC_FLAG_SHARED_DATA\t\t= 1 << 21,\n\n\t \n\tARC_FLAG_CACHED_ONLY\t\t= 1 << 22,\n\n\t \n\tARC_FLAG_NO_BUF\t\t\t= 1 << 23,\n\n\t \n\tARC_FLAG_COMPRESS_0\t\t= 1 << 24,\n\tARC_FLAG_COMPRESS_1\t\t= 1 << 25,\n\tARC_FLAG_COMPRESS_2\t\t= 1 << 26,\n\tARC_FLAG_COMPRESS_3\t\t= 1 << 27,\n\tARC_FLAG_COMPRESS_4\t\t= 1 << 28,\n\tARC_FLAG_COMPRESS_5\t\t= 1 << 29,\n\tARC_FLAG_COMPRESS_6\t\t= 1 << 30\n\n} arc_flags_t;\n\ntypedef enum arc_buf_flags {\n\tARC_BUF_FLAG_SHARED\t\t= 1 << 0,\n\tARC_BUF_FLAG_COMPRESSED\t\t= 1 << 1,\n\t \n\tARC_BUF_FLAG_ENCRYPTED\t\t= 1 << 2\n} arc_buf_flags_t;\n\nstruct arc_buf {\n\tarc_buf_hdr_t\t\t*b_hdr;\n\tarc_buf_t\t\t*b_next;\n\tvoid\t\t\t*b_data;\n\tarc_buf_flags_t\t\tb_flags;\n};\n\ntypedef enum arc_buf_contents {\n\tARC_BUFC_DATA,\t\t\t\t \n\tARC_BUFC_METADATA,\t\t\t \n\tARC_BUFC_NUMTYPES\n} arc_buf_contents_t;\n\n \ntypedef enum arc_space_type {\n\tARC_SPACE_DATA,\n\tARC_SPACE_META,\n\tARC_SPACE_HDRS,\n\tARC_SPACE_L2HDRS,\n\tARC_SPACE_DBUF,\n\tARC_SPACE_DNODE,\n\tARC_SPACE_BONUS,\n\tARC_SPACE_ABD_CHUNK_WASTE,\n\tARC_SPACE_NUMTYPES\n} arc_space_type_t;\n\ntypedef enum arc_state_type {\n\tARC_STATE_ANON,\n\tARC_STATE_MRU,\n\tARC_STATE_MRU_GHOST,\n\tARC_STATE_MFU,\n\tARC_STATE_MFU_GHOST,\n\tARC_STATE_L2C_ONLY,\n\tARC_STATE_UNCACHED,\n\tARC_STATE_NUMTYPES\n} arc_state_type_t;\n\ntypedef struct arc_buf_info {\n\tarc_state_type_t\tabi_state_type;\n\tarc_buf_contents_t\tabi_state_contents;\n\tuint32_t\t\tabi_flags;\n\tuint32_t\t\tabi_bufcnt;\n\tuint64_t\t\tabi_size;\n\tuint64_t\t\tabi_spa;\n\tuint64_t\t\tabi_access;\n\tuint32_t\t\tabi_mru_hits;\n\tuint32_t\t\tabi_mru_ghost_hits;\n\tuint32_t\t\tabi_mfu_hits;\n\tuint32_t\t\tabi_mfu_ghost_hits;\n\tuint32_t\t\tabi_l2arc_hits;\n\tuint32_t\t\tabi_holds;\n\tuint64_t\t\tabi_l2arc_dattr;\n\tuint64_t\t\tabi_l2arc_asize;\n\tenum zio_compress\tabi_l2arc_compress;\n} arc_buf_info_t;\n\nvoid arc_space_consume(uint64_t space, arc_space_type_t type);\nvoid arc_space_return(uint64_t space, arc_space_type_t type);\nboolean_t arc_is_metadata(arc_buf_t *buf);\nboolean_t arc_is_encrypted(arc_buf_t *buf);\nboolean_t arc_is_unauthenticated(arc_buf_t *buf);\nenum zio_compress arc_get_compression(arc_buf_t *buf);\nvoid arc_get_raw_params(arc_buf_t *buf, boolean_t *byteorder, uint8_t *salt,\n    uint8_t *iv, uint8_t *mac);\nint arc_untransform(arc_buf_t *buf, spa_t *spa, const zbookmark_phys_t *zb,\n    boolean_t in_place);\nvoid arc_convert_to_raw(arc_buf_t *buf, uint64_t dsobj, boolean_t byteorder,\n    dmu_object_type_t ot, const uint8_t *salt, const uint8_t *iv,\n    const uint8_t *mac);\narc_buf_t *arc_alloc_buf(spa_t *spa, const void *tag, arc_buf_contents_t type,\n    int32_t size);\narc_buf_t *arc_alloc_compressed_buf(spa_t *spa, const void *tag,\n    uint64_t psize, uint64_t lsize, enum zio_compress compression_type,\n    uint8_t complevel);\narc_buf_t *arc_alloc_raw_buf(spa_t *spa, const void *tag, uint64_t dsobj,\n    boolean_t byteorder, const uint8_t *salt, const uint8_t *iv,\n    const uint8_t *mac, dmu_object_type_t ot, uint64_t psize, uint64_t lsize,\n    enum zio_compress compression_type, uint8_t complevel);\nuint8_t arc_get_complevel(arc_buf_t *buf);\narc_buf_t *arc_loan_buf(spa_t *spa, boolean_t is_metadata, int size);\narc_buf_t *arc_loan_compressed_buf(spa_t *spa, uint64_t psize, uint64_t lsize,\n    enum zio_compress compression_type, uint8_t complevel);\narc_buf_t *arc_loan_raw_buf(spa_t *spa, uint64_t dsobj, boolean_t byteorder,\n    const uint8_t *salt, const uint8_t *iv, const uint8_t *mac,\n    dmu_object_type_t ot, uint64_t psize, uint64_t lsize,\n    enum zio_compress compression_type, uint8_t complevel);\nvoid arc_return_buf(arc_buf_t *buf, const void *tag);\nvoid arc_loan_inuse_buf(arc_buf_t *buf, const void *tag);\nvoid arc_buf_destroy(arc_buf_t *buf, const void *tag);\nvoid arc_buf_info(arc_buf_t *buf, arc_buf_info_t *abi, int state_index);\nuint64_t arc_buf_size(arc_buf_t *buf);\nuint64_t arc_buf_lsize(arc_buf_t *buf);\nvoid arc_buf_access(arc_buf_t *buf);\nvoid arc_release(arc_buf_t *buf, const void *tag);\nint arc_released(arc_buf_t *buf);\nvoid arc_buf_sigsegv(int sig, siginfo_t *si, void *unused);\nvoid arc_buf_freeze(arc_buf_t *buf);\nvoid arc_buf_thaw(arc_buf_t *buf);\n#ifdef ZFS_DEBUG\nint arc_referenced(arc_buf_t *buf);\n#else\n#define\tarc_referenced(buf) ((void) sizeof (buf), 0)\n#endif\n\nint arc_read(zio_t *pio, spa_t *spa, const blkptr_t *bp,\n    arc_read_done_func_t *done, void *priv, zio_priority_t priority,\n    int flags, arc_flags_t *arc_flags, const zbookmark_phys_t *zb);\nzio_t *arc_write(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp,\n    arc_buf_t *buf, boolean_t uncached, boolean_t l2arc, const zio_prop_t *zp,\n    arc_write_done_func_t *ready, arc_write_done_func_t *child_ready,\n    arc_write_done_func_t *done, void *priv, zio_priority_t priority,\n    int zio_flags, const zbookmark_phys_t *zb);\n\narc_prune_t *arc_add_prune_callback(arc_prune_func_t *func, void *priv);\nvoid arc_remove_prune_callback(arc_prune_t *p);\nvoid arc_freed(spa_t *spa, const blkptr_t *bp);\n\nvoid arc_flush(spa_t *spa, boolean_t retry);\nvoid arc_tempreserve_clear(uint64_t reserve);\nint arc_tempreserve_space(spa_t *spa, uint64_t reserve, uint64_t txg);\n\nuint64_t arc_all_memory(void);\nuint64_t arc_default_max(uint64_t min, uint64_t allmem);\nuint64_t arc_target_bytes(void);\nvoid arc_set_limits(uint64_t);\nvoid arc_init(void);\nvoid arc_fini(void);\n\n \n\nvoid l2arc_add_vdev(spa_t *spa, vdev_t *vd);\nvoid l2arc_remove_vdev(vdev_t *vd);\nboolean_t l2arc_vdev_present(vdev_t *vd);\nvoid l2arc_rebuild_vdev(vdev_t *vd, boolean_t reopen);\nboolean_t l2arc_range_check_overlap(uint64_t bottom, uint64_t top,\n    uint64_t check);\nvoid l2arc_init(void);\nvoid l2arc_fini(void);\nvoid l2arc_start(void);\nvoid l2arc_stop(void);\nvoid l2arc_spa_rebuild_start(spa_t *spa);\n\n#ifndef _KERNEL\nextern boolean_t arc_watch;\n#endif\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}