{
  "module_name": "dsl_crypt.h",
  "hash_id": "98cfb1598404431d0c25d75355b37fb81be18be8874edddafc70ae9858d0f3f9",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/dsl_crypt.h",
  "human_readable_source": " \n\n \n\n#ifndef\t_SYS_DSL_CRYPT_H\n#define\t_SYS_DSL_CRYPT_H\n\n#include <sys/dmu_tx.h>\n#include <sys/dmu.h>\n#include <sys/zio_crypt.h>\n#include <sys/spa.h>\n#include <sys/dsl_dataset.h>\n\n \n#define\tDSL_CRYPTO_KEY_CRYPTO_SUITE\t\"DSL_CRYPTO_SUITE\"\n#define\tDSL_CRYPTO_KEY_GUID\t\t\"DSL_CRYPTO_GUID\"\n#define\tDSL_CRYPTO_KEY_IV\t\t\"DSL_CRYPTO_IV\"\n#define\tDSL_CRYPTO_KEY_MAC\t\t\"DSL_CRYPTO_MAC\"\n#define\tDSL_CRYPTO_KEY_MASTER_KEY\t\"DSL_CRYPTO_MASTER_KEY_1\"\n#define\tDSL_CRYPTO_KEY_HMAC_KEY\t\t\"DSL_CRYPTO_HMAC_KEY_1\"\n#define\tDSL_CRYPTO_KEY_ROOT_DDOBJ\t\"DSL_CRYPTO_ROOT_DDOBJ\"\n#define\tDSL_CRYPTO_KEY_REFCOUNT\t\t\"DSL_CRYPTO_REFCOUNT\"\n#define\tDSL_CRYPTO_KEY_VERSION\t\t\"DSL_CRYPTO_VERSION\"\n\n \ntypedef struct dsl_wrapping_key {\n\t \n\tavl_node_t wk_avl_link;\n\n\t \n\tzfs_keyformat_t wk_keyformat;\n\n\t \n\tuint64_t wk_salt;\n\n\t \n\tuint64_t wk_iters;\n\n\t \n\tcrypto_key_t wk_key;\n\n\t \n\tzfs_refcount_t wk_refcnt;\n\n\t \n\tuint64_t wk_ddobj;\n} dsl_wrapping_key_t;\n\n \ntypedef enum dcp_cmd {\n\t \n\tDCP_CMD_NONE = 0,\t \n\tDCP_CMD_RAW_RECV,\t \n\n\t \n\tDCP_CMD_NEW_KEY,\t \n\tDCP_CMD_INHERIT,\t \n\tDCP_CMD_FORCE_NEW_KEY,\t \n\tDCP_CMD_FORCE_INHERIT,\t \n\n\tDCP_CMD_MAX\n} dcp_cmd_t;\n\n \ntypedef struct dsl_crypto_params {\n\t \n\tdcp_cmd_t cp_cmd;\n\n\t \n\tenum zio_encrypt cp_crypt;\n\n\t \n\tchar *cp_keylocation;\n\n\t \n\tdsl_wrapping_key_t *cp_wkey;\n} dsl_crypto_params_t;\n\n \ntypedef struct dsl_crypto_key {\n\t \n\tavl_node_t dck_avl_link;\n\n\t \n\tzfs_refcount_t dck_holds;\n\n\t \n\tzio_crypt_key_t dck_key;\n\n\t \n\tdsl_wrapping_key_t *dck_wkey;\n\n\t \n\tuint64_t dck_obj;\n} dsl_crypto_key_t;\n\n \ntypedef struct dsl_key_mapping {\n\t \n\tavl_node_t km_avl_link;\n\n\t \n\tzfs_refcount_t km_refcnt;\n\n\t \n\tuint64_t km_dsobj;\n\n\t \n\tdsl_crypto_key_t *km_key;\n} dsl_key_mapping_t;\n\n \ntypedef struct spa_keystore {\n\t \n\tkrwlock_t sk_dk_lock;\n\n\t \n\tavl_tree_t sk_dsl_keys;\n\n\t \n\tkrwlock_t sk_km_lock;\n\n\t \n\tavl_tree_t sk_key_mappings;\n\n\t \n\tkrwlock_t sk_wkeys_lock;\n\n\t \n\tavl_tree_t sk_wkeys;\n} spa_keystore_t;\n\nint dsl_crypto_params_create_nvlist(dcp_cmd_t cmd, nvlist_t *props,\n    nvlist_t *crypto_args, dsl_crypto_params_t **dcp_out);\nvoid dsl_crypto_params_free(dsl_crypto_params_t *dcp, boolean_t unload);\nvoid dsl_dataset_crypt_stats(struct dsl_dataset *ds, nvlist_t *nv);\nint dsl_crypto_can_set_keylocation(const char *dsname, const char *keylocation);\nboolean_t dsl_dir_incompatible_encryption_version(dsl_dir_t *dd);\n\nvoid spa_keystore_init(spa_keystore_t *sk);\nvoid spa_keystore_fini(spa_keystore_t *sk);\n\nvoid spa_keystore_dsl_key_rele(spa_t *spa, dsl_crypto_key_t *dck,\n    const void *tag);\nint spa_keystore_load_wkey_impl(spa_t *spa, dsl_wrapping_key_t *wkey);\nint spa_keystore_load_wkey(const char *dsname, dsl_crypto_params_t *dcp,\n    boolean_t noop);\nint spa_keystore_unload_wkey_impl(spa_t *spa, uint64_t ddobj);\nint spa_keystore_unload_wkey(const char *dsname);\n\nint spa_keystore_create_mapping(spa_t *spa, struct dsl_dataset *ds,\n    const void *tag, dsl_key_mapping_t **km_out);\nint spa_keystore_remove_mapping(spa_t *spa, uint64_t dsobj, const void *tag);\nvoid key_mapping_add_ref(dsl_key_mapping_t *km, const void *tag);\nvoid key_mapping_rele(spa_t *spa, dsl_key_mapping_t *km, const void *tag);\nint spa_keystore_lookup_key(spa_t *spa, uint64_t dsobj, const void *tag,\n    dsl_crypto_key_t **dck_out);\n\nint dsl_crypto_populate_key_nvlist(struct objset *os,\n    uint64_t from_ivset_guid, nvlist_t **nvl_out);\nint dsl_crypto_recv_raw_key_check(struct dsl_dataset *ds,\n    nvlist_t *nvl, dmu_tx_t *tx);\nvoid dsl_crypto_recv_raw_key_sync(struct dsl_dataset *ds,\n    nvlist_t *nvl, dmu_tx_t *tx);\nint dsl_crypto_recv_raw(const char *poolname, uint64_t dsobj, uint64_t fromobj,\n    dmu_objset_type_t ostype, nvlist_t *nvl, boolean_t do_key);\n\nint spa_keystore_change_key(const char *dsname, dsl_crypto_params_t *dcp);\nint dsl_dir_rename_crypt_check(dsl_dir_t *dd, dsl_dir_t *newparent);\nint dsl_dataset_promote_crypt_check(dsl_dir_t *target, dsl_dir_t *origin);\nvoid dsl_dataset_promote_crypt_sync(dsl_dir_t *target, dsl_dir_t *origin,\n    dmu_tx_t *tx);\nint dmu_objset_create_crypt_check(dsl_dir_t *parentdd,\n    dsl_crypto_params_t *dcp, boolean_t *will_encrypt);\nvoid dsl_dataset_create_crypt_sync(uint64_t dsobj, dsl_dir_t *dd,\n    struct dsl_dataset *origin, dsl_crypto_params_t *dcp, dmu_tx_t *tx);\nuint64_t dsl_crypto_key_create_sync(uint64_t crypt, dsl_wrapping_key_t *wkey,\n    dmu_tx_t *tx);\nuint64_t dsl_crypto_key_clone_sync(dsl_dir_t *origindd, dmu_tx_t *tx);\nvoid dsl_crypto_key_destroy_sync(uint64_t dckobj, dmu_tx_t *tx);\n\nint spa_crypt_get_salt(spa_t *spa, uint64_t dsobj, uint8_t *salt);\nint spa_do_crypt_mac_abd(boolean_t generate, spa_t *spa, uint64_t dsobj,\n    abd_t *abd, uint_t datalen, uint8_t *mac);\nint spa_do_crypt_objset_mac_abd(boolean_t generate, spa_t *spa, uint64_t dsobj,\n    abd_t *abd, uint_t datalen, boolean_t byteswap);\nint spa_do_crypt_abd(boolean_t encrypt, spa_t *spa, const zbookmark_phys_t *zb,\n    dmu_object_type_t ot, boolean_t dedup, boolean_t bswap, uint8_t *salt,\n    uint8_t *iv, uint8_t *mac, uint_t datalen, abd_t *pabd, abd_t *cabd,\n    boolean_t *no_crypt);\nzfs_keystatus_t dsl_dataset_get_keystatus(dsl_dir_t *dd);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}