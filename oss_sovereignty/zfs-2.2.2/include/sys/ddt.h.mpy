{
  "module_name": "ddt.h",
  "hash_id": "7fd23c1adfa1e1431ac771b983f73df4e573b5bf71c7744fbb78422c9344ebb3",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/ddt.h",
  "human_readable_source": " \n \n\n#ifndef _SYS_DDT_H\n#define\t_SYS_DDT_H\n\n#include <sys/sysmacros.h>\n#include <sys/types.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio.h>\n#include <sys/dmu.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\nstruct abd;\n\n \nenum ddt_type {\n\tDDT_TYPE_ZAP = 0,\n\tDDT_TYPES\n};\n\n \nenum ddt_class {\n\tDDT_CLASS_DITTO = 0,\n\tDDT_CLASS_DUPLICATE,\n\tDDT_CLASS_UNIQUE,\n\tDDT_CLASSES\n};\n\n#define\tDDT_TYPE_CURRENT\t\t0\n\n#define\tDDT_COMPRESS_BYTEORDER_MASK\t0x80\n#define\tDDT_COMPRESS_FUNCTION_MASK\t0x7f\n\n \ntypedef struct ddt_key {\n\tzio_cksum_t\tddk_cksum;\t \n\t \n\tuint64_t\tddk_prop;\n} ddt_key_t;\n\n#define\tDDK_GET_LSIZE(ddk)\t\\\n\tBF64_GET_SB((ddk)->ddk_prop, 0, 16, SPA_MINBLOCKSHIFT, 1)\n#define\tDDK_SET_LSIZE(ddk, x)\t\\\n\tBF64_SET_SB((ddk)->ddk_prop, 0, 16, SPA_MINBLOCKSHIFT, 1, x)\n\n#define\tDDK_GET_PSIZE(ddk)\t\\\n\tBF64_GET_SB((ddk)->ddk_prop, 16, 16, SPA_MINBLOCKSHIFT, 1)\n#define\tDDK_SET_PSIZE(ddk, x)\t\\\n\tBF64_SET_SB((ddk)->ddk_prop, 16, 16, SPA_MINBLOCKSHIFT, 1, x)\n\n#define\tDDK_GET_COMPRESS(ddk)\t\tBF64_GET((ddk)->ddk_prop, 32, 7)\n#define\tDDK_SET_COMPRESS(ddk, x)\tBF64_SET((ddk)->ddk_prop, 32, 7, x)\n\n#define\tDDK_GET_CRYPT(ddk)\t\tBF64_GET((ddk)->ddk_prop, 39, 1)\n#define\tDDK_SET_CRYPT(ddk, x)\tBF64_SET((ddk)->ddk_prop, 39, 1, x)\n\n#define\tDDT_KEY_WORDS\t(sizeof (ddt_key_t) / sizeof (uint64_t))\n\n#define\tDDE_GET_NDVAS(dde) (DDK_GET_CRYPT(&dde->dde_key) \\\n\t? SPA_DVAS_PER_BP - 1 : SPA_DVAS_PER_BP)\n\ntypedef struct ddt_phys {\n\tdva_t\t\tddp_dva[SPA_DVAS_PER_BP];\n\tuint64_t\tddp_refcnt;\n\tuint64_t\tddp_phys_birth;\n} ddt_phys_t;\n\n \nenum ddt_phys_type {\n\tDDT_PHYS_DITTO = 0,\n\tDDT_PHYS_SINGLE = 1,\n\tDDT_PHYS_DOUBLE = 2,\n\tDDT_PHYS_TRIPLE = 3,\n\tDDT_PHYS_TYPES\n};\n\n \nstruct ddt_entry {\n\tddt_key_t\tdde_key;\n\tddt_phys_t\tdde_phys[DDT_PHYS_TYPES];\n\tzio_t\t\t*dde_lead_zio[DDT_PHYS_TYPES];\n\tstruct abd\t*dde_repair_abd;\n\tenum ddt_type\tdde_type;\n\tenum ddt_class\tdde_class;\n\tuint8_t\t\tdde_loading;\n\tuint8_t\t\tdde_loaded;\n\tkcondvar_t\tdde_cv;\n\tavl_node_t\tdde_node;\n};\n\n \nstruct ddt {\n\tkmutex_t\tddt_lock;\n\tavl_tree_t\tddt_tree;\n\tavl_tree_t\tddt_repair_tree;\n\tenum zio_checksum ddt_checksum;\n\tspa_t\t\t*ddt_spa;\n\tobjset_t\t*ddt_os;\n\tuint64_t\tddt_stat_object;\n\tuint64_t\tddt_object[DDT_TYPES][DDT_CLASSES];\n\tddt_histogram_t\tddt_histogram[DDT_TYPES][DDT_CLASSES];\n\tddt_histogram_t\tddt_histogram_cache[DDT_TYPES][DDT_CLASSES];\n\tddt_object_t\tddt_object_stats[DDT_TYPES][DDT_CLASSES];\n\tavl_node_t\tddt_node;\n};\n\n \ntypedef struct ddt_bookmark {\n\tuint64_t\tddb_class;\n\tuint64_t\tddb_type;\n\tuint64_t\tddb_checksum;\n\tuint64_t\tddb_cursor;\n} ddt_bookmark_t;\n\n \ntypedef struct ddt_ops {\n\tchar ddt_op_name[32];\n\tint (*ddt_op_create)(objset_t *os, uint64_t *object, dmu_tx_t *tx,\n\t    boolean_t prehash);\n\tint (*ddt_op_destroy)(objset_t *os, uint64_t object, dmu_tx_t *tx);\n\tint (*ddt_op_lookup)(objset_t *os, uint64_t object, ddt_entry_t *dde);\n\tvoid (*ddt_op_prefetch)(objset_t *os, uint64_t object,\n\t    ddt_entry_t *dde);\n\tint (*ddt_op_update)(objset_t *os, uint64_t object, ddt_entry_t *dde,\n\t    dmu_tx_t *tx);\n\tint (*ddt_op_remove)(objset_t *os, uint64_t object, ddt_entry_t *dde,\n\t    dmu_tx_t *tx);\n\tint (*ddt_op_walk)(objset_t *os, uint64_t object, ddt_entry_t *dde,\n\t    uint64_t *walk);\n\tint (*ddt_op_count)(objset_t *os, uint64_t object, uint64_t *count);\n} ddt_ops_t;\n\n#define\tDDT_NAMELEN\t107\n\nextern void ddt_object_name(ddt_t *ddt, enum ddt_type type,\n    enum ddt_class clazz, char *name);\nextern int ddt_object_walk(ddt_t *ddt, enum ddt_type type,\n    enum ddt_class clazz, uint64_t *walk, ddt_entry_t *dde);\nextern int ddt_object_count(ddt_t *ddt, enum ddt_type type,\n    enum ddt_class clazz, uint64_t *count);\nextern int ddt_object_info(ddt_t *ddt, enum ddt_type type,\n    enum ddt_class clazz, dmu_object_info_t *);\nextern boolean_t ddt_object_exists(ddt_t *ddt, enum ddt_type type,\n    enum ddt_class clazz);\n\nextern void ddt_bp_fill(const ddt_phys_t *ddp, blkptr_t *bp,\n    uint64_t txg);\nextern void ddt_bp_create(enum zio_checksum checksum, const ddt_key_t *ddk,\n    const ddt_phys_t *ddp, blkptr_t *bp);\n\nextern void ddt_key_fill(ddt_key_t *ddk, const blkptr_t *bp);\n\nextern void ddt_phys_fill(ddt_phys_t *ddp, const blkptr_t *bp);\nextern void ddt_phys_clear(ddt_phys_t *ddp);\nextern void ddt_phys_addref(ddt_phys_t *ddp);\nextern void ddt_phys_decref(ddt_phys_t *ddp);\nextern void ddt_phys_free(ddt_t *ddt, ddt_key_t *ddk, ddt_phys_t *ddp,\n    uint64_t txg);\nextern ddt_phys_t *ddt_phys_select(const ddt_entry_t *dde, const blkptr_t *bp);\nextern uint64_t ddt_phys_total_refcnt(const ddt_entry_t *dde);\n\nextern void ddt_stat_add(ddt_stat_t *dst, const ddt_stat_t *src, uint64_t neg);\n\nextern void ddt_histogram_add(ddt_histogram_t *dst, const ddt_histogram_t *src);\nextern void ddt_histogram_stat(ddt_stat_t *dds, const ddt_histogram_t *ddh);\nextern boolean_t ddt_histogram_empty(const ddt_histogram_t *ddh);\nextern void ddt_get_dedup_object_stats(spa_t *spa, ddt_object_t *ddo);\nextern void ddt_get_dedup_histogram(spa_t *spa, ddt_histogram_t *ddh);\nextern void ddt_get_dedup_stats(spa_t *spa, ddt_stat_t *dds_total);\n\nextern uint64_t ddt_get_dedup_dspace(spa_t *spa);\nextern uint64_t ddt_get_pool_dedup_ratio(spa_t *spa);\n\nextern size_t ddt_compress(void *src, uchar_t *dst, size_t s_len, size_t d_len);\nextern void ddt_decompress(uchar_t *src, void *dst, size_t s_len, size_t d_len);\n\nextern ddt_t *ddt_select(spa_t *spa, const blkptr_t *bp);\nextern void ddt_enter(ddt_t *ddt);\nextern void ddt_exit(ddt_t *ddt);\nextern void ddt_init(void);\nextern void ddt_fini(void);\nextern ddt_entry_t *ddt_lookup(ddt_t *ddt, const blkptr_t *bp, boolean_t add);\nextern void ddt_prefetch(spa_t *spa, const blkptr_t *bp);\nextern void ddt_remove(ddt_t *ddt, ddt_entry_t *dde);\n\nextern boolean_t ddt_class_contains(spa_t *spa, enum ddt_class max_class,\n    const blkptr_t *bp);\n\nextern ddt_entry_t *ddt_repair_start(ddt_t *ddt, const blkptr_t *bp);\nextern void ddt_repair_done(ddt_t *ddt, ddt_entry_t *dde);\n\nextern int ddt_entry_compare(const void *x1, const void *x2);\n\nextern void ddt_create(spa_t *spa);\nextern int ddt_load(spa_t *spa);\nextern void ddt_unload(spa_t *spa);\nextern void ddt_sync(spa_t *spa, uint64_t txg);\nextern int ddt_walk(spa_t *spa, ddt_bookmark_t *ddb, ddt_entry_t *dde);\nextern int ddt_object_update(ddt_t *ddt, enum ddt_type type,\n    enum ddt_class clazz, ddt_entry_t *dde, dmu_tx_t *tx);\n\nextern boolean_t ddt_addref(spa_t *spa, const blkptr_t *bp);\n\nextern const ddt_ops_t ddt_zap_ops;\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}