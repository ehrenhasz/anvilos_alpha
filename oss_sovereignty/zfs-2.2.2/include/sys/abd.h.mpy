{
  "module_name": "abd.h",
  "hash_id": "1917ea6f19011ad31a9a2fa20b1acb6c40442640b4e0d15dd03d5060fae46779",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/abd.h",
  "human_readable_source": " \n \n\n#ifndef _ABD_H\n#define\t_ABD_H\n\n#include <sys/isa_defs.h>\n#include <sys/debug.h>\n#include <sys/zfs_refcount.h>\n#include <sys/uio.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum abd_flags {\n\tABD_FLAG_LINEAR\t\t= 1 << 0,  \n\tABD_FLAG_OWNER\t\t= 1 << 1,  \n\tABD_FLAG_META\t\t= 1 << 2,  \n\tABD_FLAG_MULTI_ZONE  \t= 1 << 3,  \n\tABD_FLAG_MULTI_CHUNK \t= 1 << 4,  \n\tABD_FLAG_LINEAR_PAGE \t= 1 << 5,  \n\tABD_FLAG_GANG\t\t= 1 << 6,  \n\tABD_FLAG_GANG_FREE\t= 1 << 7,  \n\tABD_FLAG_ZEROS\t\t= 1 << 8,  \n\tABD_FLAG_ALLOCD\t\t= 1 << 9,  \n} abd_flags_t;\n\ntypedef struct abd {\n\tabd_flags_t\tabd_flags;\n\tuint_t\t\tabd_size;\t \n\tlist_node_t\tabd_gang_link;\n#ifdef ZFS_DEBUG\n\tstruct abd\t*abd_parent;\n\tzfs_refcount_t\tabd_children;\n#endif\n\tkmutex_t\tabd_mtx;\n\tunion {\n\t\tstruct abd_scatter {\n\t\t\tuint_t\t\tabd_offset;\n#if defined(__FreeBSD__) && defined(_KERNEL)\n\t\t\tvoid    *abd_chunks[1];  \n#else\n\t\t\tuint_t\t\tabd_nents;\n\t\t\tstruct scatterlist *abd_sgl;\n#endif\n\t\t} abd_scatter;\n\t\tstruct abd_linear {\n\t\t\tvoid\t\t*abd_buf;\n\t\t\tstruct scatterlist *abd_sgl;  \n\t\t} abd_linear;\n\t\tstruct abd_gang {\n\t\t\tlist_t abd_gang_chain;\n\t\t} abd_gang;\n\t} abd_u;\n} abd_t;\n\ntypedef int abd_iter_func_t(void *buf, size_t len, void *priv);\ntypedef int abd_iter_func2_t(void *bufa, void *bufb, size_t len, void *priv);\n\nextern int zfs_abd_scatter_enabled;\n\n \n\n__attribute__((malloc))\nabd_t *abd_alloc(size_t, boolean_t);\n__attribute__((malloc))\nabd_t *abd_alloc_linear(size_t, boolean_t);\n__attribute__((malloc))\nabd_t *abd_alloc_gang(void);\n__attribute__((malloc))\nabd_t *abd_alloc_for_io(size_t, boolean_t);\n__attribute__((malloc))\nabd_t *abd_alloc_sametype(abd_t *, size_t);\nboolean_t abd_size_alloc_linear(size_t);\nvoid abd_gang_add(abd_t *, abd_t *, boolean_t);\nvoid abd_free(abd_t *);\nabd_t *abd_get_offset(abd_t *, size_t);\nabd_t *abd_get_offset_size(abd_t *, size_t, size_t);\nabd_t *abd_get_offset_struct(abd_t *, abd_t *, size_t, size_t);\nabd_t *abd_get_zeros(size_t);\nabd_t *abd_get_from_buf(void *, size_t);\nvoid abd_cache_reap_now(void);\n\n \n\nvoid *abd_to_buf(abd_t *);\nvoid *abd_borrow_buf(abd_t *, size_t);\nvoid *abd_borrow_buf_copy(abd_t *, size_t);\nvoid abd_return_buf(abd_t *, void *, size_t);\nvoid abd_return_buf_copy(abd_t *, void *, size_t);\nvoid abd_take_ownership_of_buf(abd_t *, boolean_t);\nvoid abd_release_ownership_of_buf(abd_t *);\n\n \n\nint abd_iterate_func(abd_t *, size_t, size_t, abd_iter_func_t *, void *);\nint abd_iterate_func2(abd_t *, abd_t *, size_t, size_t, size_t,\n    abd_iter_func2_t *, void *);\nvoid abd_copy_off(abd_t *, abd_t *, size_t, size_t, size_t);\nvoid abd_copy_from_buf_off(abd_t *, const void *, size_t, size_t);\nvoid abd_copy_to_buf_off(void *, abd_t *, size_t, size_t);\nint abd_cmp(abd_t *, abd_t *);\nint abd_cmp_buf_off(abd_t *, const void *, size_t, size_t);\nvoid abd_zero_off(abd_t *, size_t, size_t);\nvoid abd_verify(abd_t *);\n\nvoid abd_raidz_gen_iterate(abd_t **cabds, abd_t *dabd,\n\tssize_t csize, ssize_t dsize, const unsigned parity,\n\tvoid (*func_raidz_gen)(void **, const void *, size_t, size_t));\nvoid abd_raidz_rec_iterate(abd_t **cabds, abd_t **tabds,\n\tssize_t tsize, const unsigned parity,\n\tvoid (*func_raidz_rec)(void **t, const size_t tsize, void **c,\n\tconst unsigned *mul),\n\tconst unsigned *mul);\n\n \n\nstatic inline void\nabd_copy(abd_t *dabd, abd_t *sabd, size_t size)\n{\n\tabd_copy_off(dabd, sabd, 0, 0, size);\n}\n\nstatic inline void\nabd_copy_from_buf(abd_t *abd, const void *buf, size_t size)\n{\n\tabd_copy_from_buf_off(abd, buf, 0, size);\n}\n\nstatic inline void\nabd_copy_to_buf(void* buf, abd_t *abd, size_t size)\n{\n\tabd_copy_to_buf_off(buf, abd, 0, size);\n}\n\nstatic inline int\nabd_cmp_buf(abd_t *abd, const void *buf, size_t size)\n{\n\treturn (abd_cmp_buf_off(abd, buf, 0, size));\n}\n\nstatic inline void\nabd_zero(abd_t *abd, size_t size)\n{\n\tabd_zero_off(abd, 0, size);\n}\n\n \nstatic inline boolean_t\nabd_is_linear(abd_t *abd)\n{\n\treturn ((abd->abd_flags & ABD_FLAG_LINEAR) ? B_TRUE : B_FALSE);\n}\n\nstatic inline boolean_t\nabd_is_linear_page(abd_t *abd)\n{\n\treturn ((abd->abd_flags & ABD_FLAG_LINEAR_PAGE) ? B_TRUE : B_FALSE);\n}\n\nstatic inline boolean_t\nabd_is_gang(abd_t *abd)\n{\n\treturn ((abd->abd_flags & ABD_FLAG_GANG) ? B_TRUE : B_FALSE);\n}\n\nstatic inline uint_t\nabd_get_size(abd_t *abd)\n{\n\treturn (abd->abd_size);\n}\n\n \n\nvoid abd_init(void);\nvoid abd_fini(void);\n\n \n#if defined(__linux__) && defined(_KERNEL)\nunsigned int abd_bio_map_off(struct bio *, abd_t *, unsigned int, size_t);\nunsigned long abd_nr_pages_off(abd_t *, unsigned int, size_t);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}