{
  "module_name": "zap_leaf.h",
  "hash_id": "123ab5e37f4dc5df838495de016d5679299fbdfd9cc6e05e339acf6d2a8766f8",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/zap_leaf.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_ZAP_LEAF_H\n#define\t_SYS_ZAP_LEAF_H\n\n#include <sys/zap.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\nstruct zap;\nstruct zap_name;\nstruct zap_stats;\n\n#define\tZAP_LEAF_MAGIC 0x2AB1EAF\n\n \n#define\tZAP_LEAF_CHUNKSIZE 24\n\n \n#define\tZAP_LEAF_NUMCHUNKS_BS(bs) \\\n\t(((1<<(bs)) - 2*ZAP_LEAF_HASH_NUMENTRIES_BS(bs)) / \\\n\tZAP_LEAF_CHUNKSIZE - 2)\n\n#define\tZAP_LEAF_NUMCHUNKS(l) (ZAP_LEAF_NUMCHUNKS_BS(((l)->l_bs)))\n\n#define\tZAP_LEAF_NUMCHUNKS_DEF \\\n\t(ZAP_LEAF_NUMCHUNKS_BS(fzap_default_block_shift))\n\n \n#define\tZAP_LEAF_ARRAY_BYTES (ZAP_LEAF_CHUNKSIZE - 3)\n\n#define\tZAP_LEAF_ARRAY_NCHUNKS(bytes) \\\n\t(((bytes)+ZAP_LEAF_ARRAY_BYTES-1)/ZAP_LEAF_ARRAY_BYTES)\n\n \n#define\tZAP_LEAF_LOW_WATER (20)\n\n \n#define\tZAP_LEAF_HASH_SHIFT_BS(bs) ((bs) - 5)\n#define\tZAP_LEAF_HASH_NUMENTRIES_BS(bs) (1 << ZAP_LEAF_HASH_SHIFT_BS(bs))\n#define\tZAP_LEAF_HASH_SHIFT(l) (ZAP_LEAF_HASH_SHIFT_BS(((l)->l_bs)))\n#define\tZAP_LEAF_HASH_NUMENTRIES(l) (ZAP_LEAF_HASH_NUMENTRIES_BS(((l)->l_bs)))\n\n \n#define\tZAP_LEAF_CHUNK(l, idx) \\\n\t((zap_leaf_chunk_t *) \\\n\t(zap_leaf_phys(l)->l_hash + ZAP_LEAF_HASH_NUMENTRIES(l)))[idx]\n#define\tZAP_LEAF_ENTRY(l, idx) (&ZAP_LEAF_CHUNK(l, idx).l_entry)\n\ntypedef enum zap_chunk_type {\n\tZAP_CHUNK_FREE = 253,\n\tZAP_CHUNK_ENTRY = 252,\n\tZAP_CHUNK_ARRAY = 251,\n\tZAP_CHUNK_TYPE_MAX = 250\n} zap_chunk_type_t;\n\n#define\tZLF_ENTRIES_CDSORTED (1<<0)\n\n \ntypedef struct zap_leaf_phys {\n\tstruct zap_leaf_header {\n\t\t \n\t\tuint64_t lh_block_type;\t\t \n\t\tuint64_t lh_pad1;\n\t\tuint64_t lh_prefix;\t\t \n\t\tuint32_t lh_magic;\t\t \n\t\tuint16_t lh_nfree;\t\t \n\t\tuint16_t lh_nentries;\t\t \n\t\tuint16_t lh_prefix_len;\t\t \n\n\t\t \n\t\tuint16_t lh_freelist;\t\t \n\t\tuint8_t lh_flags;\t\t \n\t\tuint8_t lh_pad2[11];\n\t} l_hdr;  \n\n\t \n\n\tuint16_t l_hash[1];\n} zap_leaf_phys_t;\n\ntypedef union zap_leaf_chunk {\n\tstruct zap_leaf_entry {\n\t\tuint8_t le_type; \t\t \n\t\tuint8_t le_value_intlen;\t \n\t\tuint16_t le_next;\t\t \n\t\tuint16_t le_name_chunk;\t\t \n\t\tuint16_t le_name_numints;\t \n\t\tuint16_t le_value_chunk;\t \n\t\tuint16_t le_value_numints;\t \n\t\tuint32_t le_cd;\t\t\t \n\t\tuint64_t le_hash;\t\t \n\t} l_entry;\n\tstruct zap_leaf_array {\n\t\tuint8_t la_type;\t\t \n\t\tuint8_t la_array[ZAP_LEAF_ARRAY_BYTES];\n\t\tuint16_t la_next;\t\t \n\t} l_array;\n\tstruct zap_leaf_free {\n\t\tuint8_t lf_type;\t\t \n\t\tuint8_t lf_pad[ZAP_LEAF_ARRAY_BYTES];\n\t\tuint16_t lf_next;\t \n\t} l_free;\n} zap_leaf_chunk_t;\n\ntypedef struct zap_leaf {\n\tdmu_buf_user_t l_dbu;\n\tkrwlock_t l_rwlock;\n\tuint64_t l_blkid;\t\t \n\tint l_bs;\t\t\t \n\tdmu_buf_t *l_dbuf;\n} zap_leaf_t;\n\nstatic inline zap_leaf_phys_t *\nzap_leaf_phys(zap_leaf_t *l)\n{\n\treturn (l->l_dbuf->db_data);\n}\n\ntypedef struct zap_entry_handle {\n\t \n\tuint64_t zeh_num_integers;\n\tuint64_t zeh_hash;\n\tuint32_t zeh_cd;\n\tuint8_t zeh_integer_size;\n\n\t \n\tuint16_t zeh_fakechunk;\n\tuint16_t *zeh_chunkp;\n\tzap_leaf_t *zeh_leaf;\n} zap_entry_handle_t;\n\n \nextern int zap_leaf_lookup(zap_leaf_t *l,\n    struct zap_name *zn, zap_entry_handle_t *zeh);\n\n \nextern int zap_leaf_lookup_closest(zap_leaf_t *l,\n    uint64_t hash, uint32_t cd, zap_entry_handle_t *zeh);\n\n \nextern int zap_entry_read(const zap_entry_handle_t *zeh,\n    uint8_t integer_size, uint64_t num_integers, void *buf);\n\nextern int zap_entry_read_name(struct zap *zap, const zap_entry_handle_t *zeh,\n    uint16_t buflen, char *buf);\n\n \nextern int zap_entry_update(zap_entry_handle_t *zeh,\n    uint8_t integer_size, uint64_t num_integers, const void *buf);\n\n \nextern void zap_entry_remove(zap_entry_handle_t *zeh);\n\n \nextern int zap_entry_create(zap_leaf_t *l, struct zap_name *zn, uint32_t cd,\n    uint8_t integer_size, uint64_t num_integers, const void *buf,\n    zap_entry_handle_t *zeh);\n\n \nextern boolean_t zap_entry_normalization_conflict(zap_entry_handle_t *zeh,\n    struct zap_name *zn, const char *name, struct zap *zap);\n\n \n\nextern void zap_leaf_init(zap_leaf_t *l, boolean_t sort);\nextern void zap_leaf_byteswap(zap_leaf_phys_t *buf, int len);\nextern void zap_leaf_split(zap_leaf_t *l, zap_leaf_t *nl, boolean_t sort);\nextern void zap_leaf_stats(struct zap *zap, zap_leaf_t *l,\n    struct zap_stats *zs);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}