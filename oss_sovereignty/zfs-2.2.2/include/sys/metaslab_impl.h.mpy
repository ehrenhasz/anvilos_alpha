{
  "module_name": "metaslab_impl.h",
  "hash_id": "883c054a8a48d2e7f31bc48545e5398cd9de3d74c00ba771e0c15bbb67dd31ad",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/metaslab_impl.h",
  "human_readable_source": " \n \n\n \n\n#ifndef _SYS_METASLAB_IMPL_H\n#define\t_SYS_METASLAB_IMPL_H\n\n#include <sys/metaslab.h>\n#include <sys/space_map.h>\n#include <sys/range_tree.h>\n#include <sys/vdev.h>\n#include <sys/txg.h>\n#include <sys/avl.h>\n#include <sys/multilist.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \ntypedef struct metaslab_alloc_trace {\n\tlist_node_t\t\t\tmat_list_node;\n\tmetaslab_group_t\t\t*mat_mg;\n\tmetaslab_t\t\t\t*mat_msp;\n\tuint64_t\t\t\tmat_size;\n\tuint64_t\t\t\tmat_weight;\n\tuint32_t\t\t\tmat_dva_id;\n\tuint64_t\t\t\tmat_offset;\n\tint\t\t\t\t\tmat_allocator;\n} metaslab_alloc_trace_t;\n\n \ntypedef enum trace_alloc_type {\n\tTRACE_ALLOC_FAILURE\t= -1ULL,\n\tTRACE_TOO_SMALL\t\t= -2ULL,\n\tTRACE_FORCE_GANG\t= -3ULL,\n\tTRACE_NOT_ALLOCATABLE\t= -4ULL,\n\tTRACE_GROUP_FAILURE\t= -5ULL,\n\tTRACE_ENOSPC\t\t= -6ULL,\n\tTRACE_CONDENSING\t= -7ULL,\n\tTRACE_VDEV_ERROR\t= -8ULL,\n\tTRACE_DISABLED\t\t= -9ULL,\n} trace_alloc_type_t;\n\n#define\tMETASLAB_WEIGHT_PRIMARY\t\t(1ULL << 63)\n#define\tMETASLAB_WEIGHT_SECONDARY\t(1ULL << 62)\n#define\tMETASLAB_WEIGHT_CLAIM\t\t(1ULL << 61)\n#define\tMETASLAB_WEIGHT_TYPE\t\t(1ULL << 60)\n#define\tMETASLAB_ACTIVE_MASK\t\t\\\n\t(METASLAB_WEIGHT_PRIMARY | METASLAB_WEIGHT_SECONDARY | \\\n\tMETASLAB_WEIGHT_CLAIM)\n\n \n#define\tWEIGHT_GET_ACTIVE(weight)\t\tBF64_GET((weight), 61, 3)\n#define\tWEIGHT_SET_ACTIVE(weight, x)\t\tBF64_SET((weight), 61, 3, x)\n\n#define\tWEIGHT_IS_SPACEBASED(weight)\t\t\\\n\t((weight) == 0 || BF64_GET((weight), 60, 1))\n#define\tWEIGHT_SET_SPACEBASED(weight)\t\tBF64_SET((weight), 60, 1, 1)\n\n \n#define\tWEIGHT_GET_INDEX(weight)\t\tBF64_GET((weight), 54, 6)\n#define\tWEIGHT_SET_INDEX(weight, x)\t\tBF64_SET((weight), 54, 6, x)\n#define\tWEIGHT_GET_COUNT(weight)\t\tBF64_GET((weight), 0, 54)\n#define\tWEIGHT_SET_COUNT(weight, x)\t\tBF64_SET((weight), 0, 54, x)\n\n \ntypedef struct metaslab_class_allocator {\n\tmetaslab_group_t\t*mca_rotor;\n\tuint64_t\t\tmca_aliquot;\n\n\t \n\tuint64_t\t\tmca_alloc_max_slots;\n\tzfs_refcount_t\t\tmca_alloc_slots;\n} ____cacheline_aligned metaslab_class_allocator_t;\n\n \nstruct metaslab_class {\n\tkmutex_t\t\tmc_lock;\n\tspa_t\t\t\t*mc_spa;\n\tconst metaslab_ops_t\t\t*mc_ops;\n\n\t \n\tuint64_t\t\tmc_groups;\n\n\t \n\tboolean_t\t\tmc_alloc_throttle_enabled;\n\n\tuint64_t\t\tmc_alloc_groups;  \n\n\tuint64_t\t\tmc_alloc;\t \n\tuint64_t\t\tmc_deferred;\t \n\tuint64_t\t\tmc_space;\t \n\tuint64_t\t\tmc_dspace;\t \n\tuint64_t\t\tmc_histogram[RANGE_TREE_HISTOGRAM_SIZE];\n\n\t \n\tmultilist_t\t\tmc_metaslab_txg_list;\n\n\tmetaslab_class_allocator_t\tmc_allocator[];\n};\n\n \ntypedef struct metaslab_group_allocator {\n\tuint64_t\tmga_cur_max_alloc_queue_depth;\n\tzfs_refcount_t\tmga_alloc_queue_depth;\n\tmetaslab_t\t*mga_primary;\n\tmetaslab_t\t*mga_secondary;\n} metaslab_group_allocator_t;\n\n \nstruct metaslab_group {\n\tkmutex_t\t\tmg_lock;\n\tavl_tree_t\t\tmg_metaslab_tree;\n\tuint64_t\t\tmg_aliquot;\n\tboolean_t\t\tmg_allocatable;\t\t \n\tuint64_t\t\tmg_ms_ready;\n\n\t \n\tboolean_t\t\tmg_initialized;\n\n\tuint64_t\t\tmg_free_capacity;\t \n\tint64_t\t\t\tmg_bias;\n\tint64_t\t\t\tmg_activation_count;\n\tmetaslab_class_t\t*mg_class;\n\tvdev_t\t\t\t*mg_vd;\n\tmetaslab_group_t\t*mg_prev;\n\tmetaslab_group_t\t*mg_next;\n\n\t \n\tuint64_t\t\tmg_max_alloc_queue_depth;\n\n\t \n\tboolean_t\t\tmg_no_free_space;\n\n\tuint64_t\t\tmg_allocations;\n\tuint64_t\t\tmg_failed_allocations;\n\tuint64_t\t\tmg_fragmentation;\n\tuint64_t\t\tmg_histogram[RANGE_TREE_HISTOGRAM_SIZE];\n\n\tint\t\t\tmg_ms_disabled;\n\tboolean_t\t\tmg_disabled_updating;\n\tkmutex_t\t\tmg_ms_disabled_lock;\n\tkcondvar_t\t\tmg_ms_disabled_cv;\n\n\tint\t\t\tmg_allocators;\n\tmetaslab_group_allocator_t\tmg_allocator[];\n};\n\n \n#define\tMAX_LBAS\t64\n\n \nstruct metaslab {\n\t \n\tkmutex_t\tms_lock;\n\n\t \n\tkmutex_t\tms_sync_lock;\n\n\tkcondvar_t\tms_load_cv;\n\tspace_map_t\t*ms_sm;\n\tuint64_t\tms_id;\n\tuint64_t\tms_start;\n\tuint64_t\tms_size;\n\tuint64_t\tms_fragmentation;\n\n\trange_tree_t\t*ms_allocating[TXG_SIZE];\n\trange_tree_t\t*ms_allocatable;\n\tuint64_t\tms_allocated_this_txg;\n\tuint64_t\tms_allocating_total;\n\n\t \n\trange_tree_t\t*ms_freeing;\t \n\trange_tree_t\t*ms_freed;\t \n\trange_tree_t\t*ms_defer[TXG_DEFER_SIZE];\n\trange_tree_t\t*ms_checkpointing;  \n\n\t \n\trange_tree_t\t*ms_trim;\n\n\tboolean_t\tms_condensing;\t \n\tboolean_t\tms_condense_wanted;\n\n\t \n\tuint64_t\tms_disabled;\n\n\t \n\tboolean_t\tms_loaded;\n\tboolean_t\tms_loading;\n\tkcondvar_t\tms_flush_cv;\n\tboolean_t\tms_flushing;\n\n\t \n\tuint64_t\tms_synchist[SPACE_MAP_HISTOGRAM_SIZE];\n\tuint64_t\tms_deferhist[TXG_DEFER_SIZE][SPACE_MAP_HISTOGRAM_SIZE];\n\n\t \n\tuint64_t\tms_allocated_space;\n\tint64_t\t\tms_deferspace;\t \n\tuint64_t\tms_weight;\t \n\tuint64_t\tms_activation_weight;\t \n\n\t \n\tuint64_t\tms_selected_txg;\n\t \n\thrtime_t\tms_load_time;\t \n\thrtime_t\tms_unload_time;\t \n\thrtime_t\tms_selected_time;  \n\n\tuint64_t\tms_alloc_txg;\t \n\tuint64_t\tms_max_size;\t \n\n\t \n\tint\t\tms_allocator;\n\tboolean_t\tms_primary;  \n\n\t \n\tzfs_btree_t\t\tms_allocatable_by_size;\n\tzfs_btree_t\t\tms_unflushed_frees_by_size;\n\tuint64_t\tms_lbas[MAX_LBAS];\n\n\tmetaslab_group_t *ms_group;\t \n\tavl_node_t\tms_group_node;\t \n\ttxg_node_t\tms_txg_node;\t \n\tavl_node_t\tms_spa_txg_node;  \n\t \n\tmultilist_node_t\tms_class_txg_node;\n\n\t \n\trange_tree_t\t*ms_unflushed_allocs;\n\trange_tree_t\t*ms_unflushed_frees;\n\n\t \n\tuint64_t\tms_unflushed_txg;\n\tboolean_t\tms_unflushed_dirty;\n\n\t \n\tuint64_t\tms_synced_length;\n\n\tboolean_t\tms_new;\n};\n\ntypedef struct metaslab_unflushed_phys {\n\t \n\tuint64_t\tmsp_unflushed_txg;\n} metaslab_unflushed_phys_t;\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}