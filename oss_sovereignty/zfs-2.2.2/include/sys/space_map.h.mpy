{
  "module_name": "space_map.h",
  "hash_id": "952d4df9a916bfc80775c7a7079c7f8bbd61fbedfd4e38af10a7312d800b2bfe",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/space_map.h",
  "human_readable_source": " \n \n\n \n\n#ifndef _SYS_SPACE_MAP_H\n#define\t_SYS_SPACE_MAP_H\n\n#include <sys/avl.h>\n#include <sys/range_tree.h>\n#include <sys/dmu.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n#define\tSPACE_MAP_SIZE_V0\t(3 * sizeof (uint64_t))\n#define\tSPACE_MAP_HISTOGRAM_SIZE\t32\n\n \ntypedef struct space_map_phys {\n\t \n\tuint64_t\tsmp_object;\n\n\t \n\tuint64_t\tsmp_length;\n\n\t \n\tint64_t\t\tsmp_alloc;\n\n\t \n\tuint64_t\tsmp_pad[5];\n\n\t \n\tuint64_t\tsmp_histogram[SPACE_MAP_HISTOGRAM_SIZE];\n} space_map_phys_t;\n\n \ntypedef struct space_map {\n\tuint64_t\tsm_start;\t \n\tuint64_t\tsm_size;\t \n\tuint8_t\t\tsm_shift;\t \n\tobjset_t\t*sm_os;\t\t \n\tuint64_t\tsm_object;\t \n\tuint32_t\tsm_blksz;\t \n\tdmu_buf_t\t*sm_dbuf;\t \n\tspace_map_phys_t *sm_phys;\t \n} space_map_t;\n\n \n\ntypedef enum {\n\tSM_ALLOC,\n\tSM_FREE\n} maptype_t;\n\ntypedef struct space_map_entry {\n\tmaptype_t sme_type;\n\tuint32_t sme_vdev;\t \n\tuint64_t sme_offset;\t \n\tuint64_t sme_run;\t \n\n\t \n\tuint64_t sme_txg;\n\tuint64_t sme_sync_pass;\n} space_map_entry_t;\n\n#define\tSM_NO_VDEVID\t(1 << SPA_VDEVBITS)\n\n \n#define\tSM_DEBUG_PREFIX\t2\n#define\tSM_OFFSET_BITS\t47\n#define\tSM_RUN_BITS\t15\n\n \n#define\tSM2_PREFIX\t3\n#define\tSM2_OFFSET_BITS\t63\n#define\tSM2_RUN_BITS\t36\n\n#define\tSM_PREFIX_DECODE(x)\tBF64_DECODE(x, 62, 2)\n#define\tSM_PREFIX_ENCODE(x)\tBF64_ENCODE(x, 62, 2)\n\n#define\tSM_DEBUG_ACTION_DECODE(x)\tBF64_DECODE(x, 60, 2)\n#define\tSM_DEBUG_ACTION_ENCODE(x)\tBF64_ENCODE(x, 60, 2)\n#define\tSM_DEBUG_SYNCPASS_DECODE(x)\tBF64_DECODE(x, 50, 10)\n#define\tSM_DEBUG_SYNCPASS_ENCODE(x)\tBF64_ENCODE(x, 50, 10)\n#define\tSM_DEBUG_TXG_DECODE(x)\t\tBF64_DECODE(x, 0, 50)\n#define\tSM_DEBUG_TXG_ENCODE(x)\t\tBF64_ENCODE(x, 0, 50)\n\n#define\tSM_OFFSET_DECODE(x)\tBF64_DECODE(x, 16, SM_OFFSET_BITS)\n#define\tSM_OFFSET_ENCODE(x)\tBF64_ENCODE(x, 16, SM_OFFSET_BITS)\n#define\tSM_TYPE_DECODE(x)\tBF64_DECODE(x, 15, 1)\n#define\tSM_TYPE_ENCODE(x)\tBF64_ENCODE(x, 15, 1)\n#define\tSM_RUN_DECODE(x)\t(BF64_DECODE(x, 0, SM_RUN_BITS) + 1)\n#define\tSM_RUN_ENCODE(x)\tBF64_ENCODE((x) - 1, 0, SM_RUN_BITS)\n#define\tSM_RUN_MAX\t\tSM_RUN_DECODE(~0ULL)\n#define\tSM_OFFSET_MAX\t\tSM_OFFSET_DECODE(~0ULL)\n\n#define\tSM2_RUN_DECODE(x)\t(BF64_DECODE(x, SPA_VDEVBITS, SM2_RUN_BITS) + 1)\n#define\tSM2_RUN_ENCODE(x)\tBF64_ENCODE((x) - 1, SPA_VDEVBITS, SM2_RUN_BITS)\n#define\tSM2_VDEV_DECODE(x)\tBF64_DECODE(x, 0, SPA_VDEVBITS)\n#define\tSM2_VDEV_ENCODE(x)\tBF64_ENCODE(x, 0, SPA_VDEVBITS)\n#define\tSM2_TYPE_DECODE(x)\tBF64_DECODE(x, SM2_OFFSET_BITS, 1)\n#define\tSM2_TYPE_ENCODE(x)\tBF64_ENCODE(x, SM2_OFFSET_BITS, 1)\n#define\tSM2_OFFSET_DECODE(x)\tBF64_DECODE(x, 0, SM2_OFFSET_BITS)\n#define\tSM2_OFFSET_ENCODE(x)\tBF64_ENCODE(x, 0, SM2_OFFSET_BITS)\n#define\tSM2_RUN_MAX\t\tSM2_RUN_DECODE(~0ULL)\n#define\tSM2_OFFSET_MAX\t\tSM2_OFFSET_DECODE(~0ULL)\n\nboolean_t sm_entry_is_debug(uint64_t e);\nboolean_t sm_entry_is_single_word(uint64_t e);\nboolean_t sm_entry_is_double_word(uint64_t e);\n\ntypedef int (*sm_cb_t)(space_map_entry_t *sme, void *arg);\n\nint space_map_load(space_map_t *sm, range_tree_t *rt, maptype_t maptype);\nint space_map_load_length(space_map_t *sm, range_tree_t *rt, maptype_t maptype,\n    uint64_t length);\nint space_map_iterate(space_map_t *sm, uint64_t length,\n    sm_cb_t callback, void *arg);\nint space_map_incremental_destroy(space_map_t *sm, sm_cb_t callback, void *arg,\n    dmu_tx_t *tx);\n\nboolean_t space_map_histogram_verify(space_map_t *sm, range_tree_t *rt);\nvoid space_map_histogram_clear(space_map_t *sm);\nvoid space_map_histogram_add(space_map_t *sm, range_tree_t *rt,\n    dmu_tx_t *tx);\n\nuint64_t space_map_object(space_map_t *sm);\nint64_t space_map_allocated(space_map_t *sm);\nuint64_t space_map_length(space_map_t *sm);\nuint64_t space_map_entries(space_map_t *sm, range_tree_t *rt);\nuint64_t space_map_nblocks(space_map_t *sm);\n\nvoid space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,\n    uint64_t vdev_id, dmu_tx_t *tx);\nuint64_t space_map_estimate_optimal_size(space_map_t *sm, range_tree_t *rt,\n    uint64_t vdev_id);\nvoid space_map_truncate(space_map_t *sm, int blocksize, dmu_tx_t *tx);\nuint64_t space_map_alloc(objset_t *os, int blocksize, dmu_tx_t *tx);\nvoid space_map_free(space_map_t *sm, dmu_tx_t *tx);\nvoid space_map_free_obj(objset_t *os, uint64_t smobj, dmu_tx_t *tx);\n\nint space_map_open(space_map_t **smp, objset_t *os, uint64_t object,\n    uint64_t start, uint64_t size, uint8_t shift);\nvoid space_map_close(space_map_t *sm);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}