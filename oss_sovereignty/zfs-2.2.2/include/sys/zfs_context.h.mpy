{
  "module_name": "zfs_context.h",
  "hash_id": "59052d7d05a4477e79131a4d2163349fb6af5dbef5770e039e3aa6d5394f8f57",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/zfs_context.h",
  "human_readable_source": " \n \n\n#ifndef _SYS_ZFS_CONTEXT_H\n#define\t_SYS_ZFS_CONTEXT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n#if defined(__KERNEL__) || defined(_STANDALONE)\n#include <sys/types.h>\n#include <sys/atomic.h>\n#include <sys/sysmacros.h>\n#include <sys/vmsystm.h>\n#include <sys/condvar.h>\n#include <sys/cmn_err.h>\n#include <sys/kmem.h>\n#include <sys/kmem_cache.h>\n#include <sys/vmem.h>\n#include <sys/misc.h>\n#include <sys/taskq.h>\n#include <sys/param.h>\n#include <sys/disp.h>\n#include <sys/debug.h>\n#include <sys/random.h>\n#include <sys/string.h>\n#include <sys/byteorder.h>\n#include <sys/list.h>\n#include <sys/time.h>\n#include <sys/zone.h>\n#include <sys/kstat.h>\n#include <sys/zfs_debug.h>\n#include <sys/sysevent.h>\n#include <sys/sysevent/eventdefs.h>\n#include <sys/zfs_delay.h>\n#include <sys/sunddi.h>\n#include <sys/ctype.h>\n#include <sys/disp.h>\n#include <sys/trace.h>\n#include <sys/procfs_list.h>\n#include <sys/mod.h>\n#include <sys/uio_impl.h>\n#include <sys/zfs_context_os.h>\n#else  \n\n#define\t_SYS_MUTEX_H\n#define\t_SYS_RWLOCK_H\n#define\t_SYS_CONDVAR_H\n#define\t_SYS_VNODE_H\n#define\t_SYS_VFS_H\n#define\t_SYS_SUNDDI_H\n#define\t_SYS_CALLB_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <pthread.h>\n#include <setjmp.h>\n#include <assert.h>\n#include <umem.h>\n#include <limits.h>\n#include <atomic.h>\n#include <dirent.h>\n#include <time.h>\n#include <ctype.h>\n#include <signal.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/cred.h>\n#include <sys/sysmacros.h>\n#include <sys/resource.h>\n#include <sys/byteorder.h>\n#include <sys/list.h>\n#include <sys/mod.h>\n#include <sys/uio.h>\n#include <sys/zfs_debug.h>\n#include <sys/kstat.h>\n#include <sys/u8_textprep.h>\n#include <sys/sysevent.h>\n#include <sys/sysevent/eventdefs.h>\n#include <sys/sunddi.h>\n#include <sys/debug.h>\n#include <sys/utsname.h>\n#include <sys/trace_zfs.h>\n\n#include <sys/zfs_context_os.h>\n\n \n\n#define\tnoinline\t__attribute__((noinline))\n#define\tlikely(x)\t__builtin_expect((x), 1)\n#define\tunlikely(x)\t__builtin_expect((x), 0)\n\n \n\n \n\n#define\tCE_CONT\t\t0\t \n#define\tCE_NOTE\t\t1\t \n#define\tCE_WARN\t\t2\t \n#define\tCE_PANIC\t3\t \n#define\tCE_IGNORE\t4\t \n\n \n\nextern void dprintf_setup(int *argc, char **argv);\n\nextern void cmn_err(int, const char *, ...)\n    __attribute__((format(printf, 2, 3)));\nextern void vcmn_err(int, const char *, va_list)\n    __attribute__((format(printf, 2, 0)));\nextern void panic(const char *, ...)\n    __attribute__((format(printf, 1, 2), noreturn));\nextern void vpanic(const char *, va_list)\n    __attribute__((format(printf, 1, 0), noreturn));\n\n#define\tfm_panic\tpanic\n\n \n\n#ifdef DTRACE_PROBE\n#undef\tDTRACE_PROBE\n#endif\t \n#define\tDTRACE_PROBE(a)\n\n#ifdef DTRACE_PROBE1\n#undef\tDTRACE_PROBE1\n#endif\t \n#define\tDTRACE_PROBE1(a, b, c)\n\n#ifdef DTRACE_PROBE2\n#undef\tDTRACE_PROBE2\n#endif\t \n#define\tDTRACE_PROBE2(a, b, c, d, e)\n\n#ifdef DTRACE_PROBE3\n#undef\tDTRACE_PROBE3\n#endif\t \n#define\tDTRACE_PROBE3(a, b, c, d, e, f, g)\n\n#ifdef DTRACE_PROBE4\n#undef\tDTRACE_PROBE4\n#endif\t \n#define\tDTRACE_PROBE4(a, b, c, d, e, f, g, h, i)\n\n \ntypedef struct zfs_kernel_param {\n\tconst char *name;\t \n} zfs_kernel_param_t;\n\n#define\tZFS_MODULE_PARAM(scope_prefix, name_prefix, name, type, perm, desc)\n#define\tZFS_MODULE_PARAM_ARGS void\n#define\tZFS_MODULE_PARAM_CALL(scope_prefix, name_prefix, name, setfunc, \\\n\tgetfunc, perm, desc)\n\n \ntypedef pthread_t\tkthread_t;\n\n#define\tTS_RUN\t\t0x00000002\n#define\tTS_JOINABLE\t0x00000004\n\n#define\tcurthread\t((void *)(uintptr_t)pthread_self())\n#define\tgetcomm()\t\"unknown\"\n\n#define\tthread_create_named(name, stk, stksize, func, arg, len, \\\n    pp, state, pri)\t\\\n\tzk_thread_create(func, arg, stksize, state)\n#define\tthread_create(stk, stksize, func, arg, len, pp, state, pri)\t\\\n\tzk_thread_create(func, arg, stksize, state)\n#define\tthread_exit()\tpthread_exit(NULL)\n#define\tthread_join(t)\tpthread_join((pthread_t)(t), NULL)\n\n#define\tnewproc(f, a, cid, pri, ctp, pid)\t(ENOSYS)\n\n \ntypedef struct proc {\n\tuintptr_t\tthis_is_never_used_dont_dereference_it;\n} proc_t;\n\nextern struct proc p0;\n#define\tcurproc\t\t(&p0)\n\n#define\tPS_NONE\t\t-1\n\nextern kthread_t *zk_thread_create(void (*func)(void *), void *arg,\n    size_t stksize, int state);\n\n#define\tissig(why)\t(FALSE)\n#define\tISSIG(thr, why)\t(FALSE)\n\n#define\tKPREEMPT_SYNC\t\t(-1)\n\n#define\tkpreempt(x)\t\tsched_yield()\n#define\tkpreempt_disable()\t((void)0)\n#define\tkpreempt_enable()\t((void)0)\n\n \ntypedef struct kmutex {\n\tpthread_mutex_t\t\tm_lock;\n\tpthread_t\t\tm_owner;\n} kmutex_t;\n\n#define\tMUTEX_DEFAULT\t\t0\n#define\tMUTEX_NOLOCKDEP\t\tMUTEX_DEFAULT\n#define\tMUTEX_HELD(mp)\t\tpthread_equal((mp)->m_owner, pthread_self())\n#define\tMUTEX_NOT_HELD(mp)\t!MUTEX_HELD(mp)\n\nextern void mutex_init(kmutex_t *mp, char *name, int type, void *cookie);\nextern void mutex_destroy(kmutex_t *mp);\nextern void mutex_enter(kmutex_t *mp);\nextern int mutex_enter_check_return(kmutex_t *mp);\nextern void mutex_exit(kmutex_t *mp);\nextern int mutex_tryenter(kmutex_t *mp);\n\n#define\tNESTED_SINGLE 1\n#define\tmutex_enter_nested(mp, class) mutex_enter(mp)\n#define\tmutex_enter_interruptible(mp) mutex_enter_check_return(mp)\n \ntypedef struct krwlock {\n\tpthread_rwlock_t\trw_lock;\n\tpthread_t\t\trw_owner;\n\tuint_t\t\t\trw_readers;\n} krwlock_t;\n\ntypedef int krw_t;\n\n#define\tRW_READER\t\t0\n#define\tRW_WRITER\t\t1\n#define\tRW_DEFAULT\t\tRW_READER\n#define\tRW_NOLOCKDEP\t\tRW_READER\n\n#define\tRW_READ_HELD(rw)\t((rw)->rw_readers > 0)\n#define\tRW_WRITE_HELD(rw)\tpthread_equal((rw)->rw_owner, pthread_self())\n#define\tRW_LOCK_HELD(rw)\t(RW_READ_HELD(rw) || RW_WRITE_HELD(rw))\n\nextern void rw_init(krwlock_t *rwlp, char *name, int type, void *arg);\nextern void rw_destroy(krwlock_t *rwlp);\nextern void rw_enter(krwlock_t *rwlp, krw_t rw);\nextern int rw_tryenter(krwlock_t *rwlp, krw_t rw);\nextern int rw_tryupgrade(krwlock_t *rwlp);\nextern void rw_exit(krwlock_t *rwlp);\n#define\trw_downgrade(rwlp) do { } while (0)\n\n \nextern uid_t crgetuid(cred_t *cr);\nextern uid_t crgetruid(cred_t *cr);\nextern gid_t crgetgid(cred_t *cr);\nextern int crgetngroups(cred_t *cr);\nextern gid_t *crgetgroups(cred_t *cr);\n\n \ntypedef pthread_cond_t\t\tkcondvar_t;\n\n#define\tCV_DEFAULT\t\t0\n#define\tCALLOUT_FLAG_ABSOLUTE\t0x2\n\nextern void cv_init(kcondvar_t *cv, char *name, int type, void *arg);\nextern void cv_destroy(kcondvar_t *cv);\nextern void cv_wait(kcondvar_t *cv, kmutex_t *mp);\nextern int cv_wait_sig(kcondvar_t *cv, kmutex_t *mp);\nextern int cv_timedwait(kcondvar_t *cv, kmutex_t *mp, clock_t abstime);\nextern int cv_timedwait_hires(kcondvar_t *cvp, kmutex_t *mp, hrtime_t tim,\n    hrtime_t res, int flag);\nextern void cv_signal(kcondvar_t *cv);\nextern void cv_broadcast(kcondvar_t *cv);\n\n#define\tcv_timedwait_io(cv, mp, at)\t\tcv_timedwait(cv, mp, at)\n#define\tcv_timedwait_idle(cv, mp, at)\t\tcv_timedwait(cv, mp, at)\n#define\tcv_timedwait_sig(cv, mp, at)\t\tcv_timedwait(cv, mp, at)\n#define\tcv_wait_io(cv, mp)\t\t\tcv_wait(cv, mp)\n#define\tcv_wait_idle(cv, mp)\t\t\tcv_wait(cv, mp)\n#define\tcv_wait_io_sig(cv, mp)\t\t\tcv_wait_sig(cv, mp)\n#define\tcv_timedwait_sig_hires(cv, mp, t, r, f) \\\n\tcv_timedwait_hires(cv, mp, t, r, f)\n#define\tcv_timedwait_idle_hires(cv, mp, t, r, f) \\\n\tcv_timedwait_hires(cv, mp, t, r, f)\n\n \n#define\ttsd_get(k) pthread_getspecific(k)\n#define\ttsd_set(k, v) pthread_setspecific(k, v)\n#define\ttsd_create(kp, d) pthread_key_create((pthread_key_t *)kp, d)\n#define\ttsd_destroy(kp)  \n#ifdef __FreeBSD__\ntypedef off_t loff_t;\n#endif\n\n \nextern kstat_t *kstat_create(const char *, int,\n    const char *, const char *, uchar_t, ulong_t, uchar_t);\nextern void kstat_install(kstat_t *);\nextern void kstat_delete(kstat_t *);\nextern void kstat_set_raw_ops(kstat_t *ksp,\n    int (*headers)(char *buf, size_t size),\n    int (*data)(char *buf, size_t size, void *data),\n    void *(*addr)(kstat_t *ksp, loff_t index));\n\n \n\ntypedef struct procfs_list {\n\tvoid\t\t*pl_private;\n\tkmutex_t\tpl_lock;\n\tlist_t\t\tpl_list;\n\tuint64_t\tpl_next_id;\n\tsize_t\t\tpl_node_offset;\n} procfs_list_t;\n\n#ifndef __cplusplus\nstruct seq_file { };\nvoid seq_printf(struct seq_file *m, const char *fmt, ...);\n\ntypedef struct procfs_list_node {\n\tlist_node_t\tpln_link;\n\tuint64_t\tpln_id;\n} procfs_list_node_t;\n\nvoid procfs_list_install(const char *module,\n    const char *submodule,\n    const char *name,\n    mode_t mode,\n    procfs_list_t *procfs_list,\n    int (*show)(struct seq_file *f, void *p),\n    int (*show_header)(struct seq_file *f),\n    int (*clear)(procfs_list_t *procfs_list),\n    size_t procfs_list_node_off);\nvoid procfs_list_uninstall(procfs_list_t *procfs_list);\nvoid procfs_list_destroy(procfs_list_t *procfs_list);\nvoid procfs_list_add(procfs_list_t *procfs_list, void *p);\n#endif\n\n \n#define\tKM_SLEEP\t\tUMEM_NOFAIL\n#define\tKM_PUSHPAGE\t\tKM_SLEEP\n#define\tKM_NOSLEEP\t\tUMEM_DEFAULT\n#define\tKM_NORMALPRI\t\t0\t \n#define\tKMC_NODEBUG\t\tUMC_NODEBUG\n#define\tKMC_KVMEM\t\t0x0\n#define\tkmem_alloc(_s, _f)\tumem_alloc(_s, _f)\n#define\tkmem_zalloc(_s, _f)\tumem_zalloc(_s, _f)\n#define\tkmem_free(_b, _s)\tumem_free(_b, _s)\n#define\tvmem_alloc(_s, _f)\tkmem_alloc(_s, _f)\n#define\tvmem_zalloc(_s, _f)\tkmem_zalloc(_s, _f)\n#define\tvmem_free(_b, _s)\tkmem_free(_b, _s)\n#define\tkmem_cache_create(_a, _b, _c, _d, _e, _f, _g, _h, _i) \\\n\tumem_cache_create(_a, _b, _c, _d, _e, _f, _g, _h, _i)\n#define\tkmem_cache_destroy(_c)\tumem_cache_destroy(_c)\n#define\tkmem_cache_alloc(_c, _f) umem_cache_alloc(_c, _f)\n#define\tkmem_cache_free(_c, _b)\tumem_cache_free(_c, _b)\n#define\tkmem_debugging()\t0\n#define\tkmem_cache_reap_now(_c)\tumem_cache_reap_now(_c);\n#define\tkmem_cache_set_move(_c, _cb)\t \n#define\tPOINTER_INVALIDATE(_pp)\t\t \n#define\tPOINTER_IS_VALID(_p)\t0\n\ntypedef umem_cache_t kmem_cache_t;\n\ntypedef enum kmem_cbrc {\n\tKMEM_CBRC_YES,\n\tKMEM_CBRC_NO,\n\tKMEM_CBRC_LATER,\n\tKMEM_CBRC_DONT_NEED,\n\tKMEM_CBRC_DONT_KNOW\n} kmem_cbrc_t;\n\n \n\n#define\tTASKQ_NAMELEN\t31\n\ntypedef uintptr_t taskqid_t;\ntypedef void (task_func_t)(void *);\n\ntypedef struct taskq_ent {\n\tstruct taskq_ent\t*tqent_next;\n\tstruct taskq_ent\t*tqent_prev;\n\ttask_func_t\t\t*tqent_func;\n\tvoid\t\t\t*tqent_arg;\n\tuintptr_t\t\ttqent_flags;\n} taskq_ent_t;\n\ntypedef struct taskq {\n\tchar\t\ttq_name[TASKQ_NAMELEN + 1];\n\tkmutex_t\ttq_lock;\n\tkrwlock_t\ttq_threadlock;\n\tkcondvar_t\ttq_dispatch_cv;\n\tkcondvar_t\ttq_wait_cv;\n\tkthread_t\t**tq_threadlist;\n\tint\t\ttq_flags;\n\tint\t\ttq_active;\n\tint\t\ttq_nthreads;\n\tint\t\ttq_nalloc;\n\tint\t\ttq_minalloc;\n\tint\t\ttq_maxalloc;\n\tkcondvar_t\ttq_maxalloc_cv;\n\tint\t\ttq_maxalloc_wait;\n\ttaskq_ent_t\t*tq_freelist;\n\ttaskq_ent_t\ttq_task;\n} taskq_t;\n\n#define\tTQENT_FLAG_PREALLOC\t0x1\t \n\n#define\tTASKQ_PREPOPULATE\t0x0001\n#define\tTASKQ_CPR_SAFE\t\t0x0002\t \n#define\tTASKQ_DYNAMIC\t\t0x0004\t \n#define\tTASKQ_THREADS_CPU_PCT\t0x0008\t \n#define\tTASKQ_DC_BATCH\t\t0x0010\t \n\n#define\tTQ_SLEEP\tKM_SLEEP\t \n#define\tTQ_NOSLEEP\tKM_NOSLEEP\t \n#define\tTQ_NOQUEUE\t0x02\t\t \n#define\tTQ_FRONT\t0x08\t\t \n\n#define\tTASKQID_INVALID\t\t((taskqid_t)0)\n\nextern taskq_t *system_taskq;\nextern taskq_t *system_delay_taskq;\n\nextern taskq_t\t*taskq_create(const char *, int, pri_t, int, int, uint_t);\n#define\ttaskq_create_proc(a, b, c, d, e, p, f) \\\n\t    (taskq_create(a, b, c, d, e, f))\n#define\ttaskq_create_sysdc(a, b, d, e, p, dc, f) \\\n\t    ((void) sizeof (dc), taskq_create(a, b, maxclsyspri, d, e, f))\nextern taskqid_t taskq_dispatch(taskq_t *, task_func_t, void *, uint_t);\nextern taskqid_t taskq_dispatch_delay(taskq_t *, task_func_t, void *, uint_t,\n    clock_t);\nextern void\ttaskq_dispatch_ent(taskq_t *, task_func_t, void *, uint_t,\n    taskq_ent_t *);\nextern int\ttaskq_empty_ent(taskq_ent_t *);\nextern void\ttaskq_init_ent(taskq_ent_t *);\nextern void\ttaskq_destroy(taskq_t *);\nextern void\ttaskq_wait(taskq_t *);\nextern void\ttaskq_wait_id(taskq_t *, taskqid_t);\nextern void\ttaskq_wait_outstanding(taskq_t *, taskqid_t);\nextern int\ttaskq_member(taskq_t *, kthread_t *);\nextern taskq_t\t*taskq_of_curthread(void);\nextern int\ttaskq_cancel_id(taskq_t *, taskqid_t);\nextern void\tsystem_taskq_init(void);\nextern void\tsystem_taskq_fini(void);\n\n#define\tXVA_MAPSIZE\t3\n#define\tXVA_MAGIC\t0x78766174\n\nextern char *vn_dumpdir;\n#define\tAV_SCANSTAMP_SZ\t32\t\t \n\ntypedef struct xoptattr {\n\tinode_timespec_t xoa_createtime;\t \n\tuint8_t\t\txoa_archive;\n\tuint8_t\t\txoa_system;\n\tuint8_t\t\txoa_readonly;\n\tuint8_t\t\txoa_hidden;\n\tuint8_t\t\txoa_nounlink;\n\tuint8_t\t\txoa_immutable;\n\tuint8_t\t\txoa_appendonly;\n\tuint8_t\t\txoa_nodump;\n\tuint8_t\t\txoa_settable;\n\tuint8_t\t\txoa_opaque;\n\tuint8_t\t\txoa_av_quarantined;\n\tuint8_t\t\txoa_av_modified;\n\tuint8_t\t\txoa_av_scanstamp[AV_SCANSTAMP_SZ];\n\tuint8_t\t\txoa_reparse;\n\tuint8_t\t\txoa_offline;\n\tuint8_t\t\txoa_sparse;\n} xoptattr_t;\n\ntypedef struct vattr {\n\tuint_t\t\tva_mask;\t \n\tu_offset_t\tva_size;\t \n} vattr_t;\n\n\ntypedef struct xvattr {\n\tvattr_t\t\txva_vattr;\t \n\tuint32_t\txva_magic;\t \n\tuint32_t\txva_mapsize;\t \n\tuint32_t\t*xva_rtnattrmapp;\t \n\tuint32_t\txva_reqattrmap[XVA_MAPSIZE];\t \n\tuint32_t\txva_rtnattrmap[XVA_MAPSIZE];\t \n\txoptattr_t\txva_xoptattrs;\t \n} xvattr_t;\n\ntypedef struct vsecattr {\n\tuint_t\t\tvsa_mask;\t \n\tint\t\tvsa_aclcnt;\t \n\tvoid\t\t*vsa_aclentp;\t \n\tint\t\tvsa_dfaclcnt;\t \n\tvoid\t\t*vsa_dfaclentp;\t \n\tsize_t\t\tvsa_aclentsz;\t \n} vsecattr_t;\n\n#define\tAT_MODE\t\t0x00002\n#define\tAT_UID\t\t0x00004\n#define\tAT_GID\t\t0x00008\n#define\tAT_FSID\t\t0x00010\n#define\tAT_NODEID\t0x00020\n#define\tAT_NLINK\t0x00040\n#define\tAT_SIZE\t\t0x00080\n#define\tAT_ATIME\t0x00100\n#define\tAT_MTIME\t0x00200\n#define\tAT_CTIME\t0x00400\n#define\tAT_RDEV\t\t0x00800\n#define\tAT_BLKSIZE\t0x01000\n#define\tAT_NBLOCKS\t0x02000\n#define\tAT_SEQ\t\t0x08000\n#define\tAT_XVATTR\t0x10000\n\n#define\tCRCREAT\t\t0\n\n#define\tF_FREESP\t11\n#define\tFIGNORECASE\t0x80000  \n\n \n#define\tddi_get_lbolt()\t\t(gethrtime() >> 23)\n#define\tddi_get_lbolt64()\t(gethrtime() >> 23)\n#define\thz\t119\t \n\n#define\tddi_time_before(a, b)\t\t(a < b)\n#define\tddi_time_after(a, b)\t\tddi_time_before(b, a)\n#define\tddi_time_before_eq(a, b)\t(!ddi_time_after(a, b))\n#define\tddi_time_after_eq(a, b)\t\tddi_time_before_eq(b, a)\n\n#define\tddi_time_before64(a, b)\t\t(a < b)\n#define\tddi_time_after64(a, b)\t\tddi_time_before64(b, a)\n#define\tddi_time_before_eq64(a, b)\t(!ddi_time_after64(a, b))\n#define\tddi_time_after_eq64(a, b)\tddi_time_before_eq64(b, a)\n\nextern void delay(clock_t ticks);\n\n#define\tSEC_TO_TICK(sec)\t((sec) * hz)\n#define\tMSEC_TO_TICK(msec)\t(howmany((hrtime_t)(msec) * hz, MILLISEC))\n#define\tUSEC_TO_TICK(usec)\t(howmany((hrtime_t)(usec) * hz, MICROSEC))\n#define\tNSEC_TO_TICK(nsec)\t(howmany((hrtime_t)(nsec) * hz, NANOSEC))\n\n#define\tmax_ncpus\t64\n#define\tboot_ncpus\t(sysconf(_SC_NPROCESSORS_ONLN))\n\n \n#define\tminclsyspri\t19\n#define\tmaxclsyspri\t-20\n#define\tdefclsyspri\t0\n\n#define\tCPU_SEQID\t((uintptr_t)pthread_self() & (max_ncpus - 1))\n#define\tCPU_SEQID_UNSTABLE\tCPU_SEQID\n\n#define\tkcred\t\tNULL\n#define\tCRED()\t\tNULL\n\n#define\tptob(x)\t\t((x) * PAGESIZE)\n\n#define\tNN_DIVISOR_1000\t(1U << 0)\n#define\tNN_NUMBUF_SZ\t(6)\n\nextern uint64_t physmem;\nextern const char *random_path;\nextern const char *urandom_path;\n\nextern int highbit64(uint64_t i);\nextern int lowbit64(uint64_t i);\nextern int random_get_bytes(uint8_t *ptr, size_t len);\nextern int random_get_pseudo_bytes(uint8_t *ptr, size_t len);\n\nstatic __inline__ uint32_t\nrandom_in_range(uint32_t range)\n{\n\tuint32_t r;\n\n\tASSERT(range != 0);\n\n\tif (range == 1)\n\t\treturn (0);\n\n\t(void) random_get_pseudo_bytes((uint8_t *)&r, sizeof (r));\n\n\treturn (r % range);\n}\n\nextern void kernel_init(int mode);\nextern void kernel_fini(void);\nextern void random_init(void);\nextern void random_fini(void);\n\nstruct spa;\nextern void show_pool_stats(struct spa *);\nextern int set_global_var(char const *arg);\n\ntypedef struct callb_cpr {\n\tkmutex_t\t*cc_lockp;\n} callb_cpr_t;\n\n#define\tCALLB_CPR_INIT(cp, lockp, func, name)\t{\t\t\\\n\t(cp)->cc_lockp = lockp;\t\t\t\t\t\\\n}\n\n#define\tCALLB_CPR_SAFE_BEGIN(cp) {\t\t\t\t\\\n\tASSERT(MUTEX_HELD((cp)->cc_lockp));\t\t\t\\\n}\n\n#define\tCALLB_CPR_SAFE_END(cp, lockp) {\t\t\t\t\\\n\tASSERT(MUTEX_HELD((cp)->cc_lockp));\t\t\t\\\n}\n\n#define\tCALLB_CPR_EXIT(cp) {\t\t\t\t\t\\\n\tASSERT(MUTEX_HELD((cp)->cc_lockp));\t\t\t\\\n\tmutex_exit((cp)->cc_lockp);\t\t\t\t\\\n}\n\n#define\tzone_dataset_visible(x, y)\t(1)\n#define\tINGLOBALZONE(z)\t\t\t(1)\nextern uint32_t zone_get_hostid(void *zonep);\n\nextern char *kmem_vasprintf(const char *fmt, va_list adx);\nextern char *kmem_asprintf(const char *fmt, ...);\n#define\tkmem_strfree(str) kmem_free((str), strlen(str) + 1)\n#define\tkmem_strdup(s)  strdup(s)\n\n#ifndef __cplusplus\nextern int kmem_scnprintf(char *restrict str, size_t size,\n    const char *restrict fmt, ...);\n#endif\n\n \nextern int ddi_strtoull(const char *str, char **nptr, int base,\n    u_longlong_t *result);\n\ntypedef struct utsname\tutsname_t;\nextern utsname_t *utsname(void);\n\n \n\nstruct _buf {\n\tintptr_t\t_fd;\n};\n\nstruct bootstat {\n\tuint64_t st_size;\n};\n\ntypedef struct ace_object {\n\tuid_t\t\ta_who;\n\tuint32_t\ta_access_mask;\n\tuint16_t\ta_flags;\n\tuint16_t\ta_type;\n\tuint8_t\t\ta_obj_type[16];\n\tuint8_t\t\ta_inherit_obj_type[16];\n} ace_object_t;\n\n\n#define\tACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE\t0x05\n#define\tACE_ACCESS_DENIED_OBJECT_ACE_TYPE\t0x06\n#define\tACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE\t0x07\n#define\tACE_SYSTEM_ALARM_OBJECT_ACE_TYPE\t0x08\n\nextern int zfs_secpolicy_snapshot_perms(const char *name, cred_t *cr);\nextern int zfs_secpolicy_rename_perms(const char *from, const char *to,\n    cred_t *cr);\nextern int zfs_secpolicy_destroy_perms(const char *name, cred_t *cr);\nextern int secpolicy_zfs(const cred_t *cr);\nextern int secpolicy_zfs_proc(const cred_t *cr, proc_t *proc);\nextern zoneid_t getzoneid(void);\n\n \ntypedef struct ksiddomain {\n\tuint_t\tkd_ref;\n\tuint_t\tkd_len;\n\tchar\t*kd_name;\n} ksiddomain_t;\n\nksiddomain_t *ksid_lookupdomain(const char *);\nvoid ksiddomain_rele(ksiddomain_t *);\n\n#define\tDDI_SLEEP\tKM_SLEEP\n#define\tddi_log_sysevent(_a, _b, _c, _d, _e, _f, _g) \\\n\tsysevent_post_event(_c, _d, _b, \"libzpool\", _e, _f)\n\n#define\tzfs_sleep_until(wakeup)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\thrtime_t delta = wakeup - gethrtime();\t\t\t\\\n\t\tstruct timespec ts;\t\t\t\t\t\\\n\t\tts.tv_sec = delta / NANOSEC;\t\t\t\t\\\n\t\tts.tv_nsec = delta % NANOSEC;\t\t\t\t\\\n\t\t(void) nanosleep(&ts, NULL);\t\t\t\t\\\n\t} while (0)\n\ntypedef int fstrans_cookie_t;\n\nextern fstrans_cookie_t spl_fstrans_mark(void);\nextern void spl_fstrans_unmark(fstrans_cookie_t);\nextern int __spl_pf_fstrans_check(void);\nextern int kmem_cache_reap_active(void);\n\n\n \n#define\t__init\n#define\t__exit\n\n#endif   \n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}