{
  "module_name": "dmu.h",
  "hash_id": "7a72e7dc505baa9d604254ee28accf311ad6daca9fdd8b76ba63fdec1b9e4d8f",
  "original_prompt": "Ingested from zfs-2.2.2/include/sys/dmu.h",
  "human_readable_source": " \n \n\n \n\n#ifndef\t_SYS_DMU_H\n#define\t_SYS_DMU_H\n\n \n\n#include <sys/zfs_context.h>\n#include <sys/inttypes.h>\n#include <sys/cred.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio_compress.h>\n#include <sys/zio_priority.h>\n#include <sys/uio.h>\n#include <sys/zfs_file.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\nstruct page;\nstruct vnode;\nstruct spa;\nstruct zilog;\nstruct zio;\nstruct blkptr;\nstruct zap_cursor;\nstruct dsl_dataset;\nstruct dsl_pool;\nstruct dnode;\nstruct drr_begin;\nstruct drr_end;\nstruct zbookmark_phys;\nstruct spa;\nstruct nvlist;\nstruct arc_buf;\nstruct zio_prop;\nstruct sa_handle;\nstruct dsl_crypto_params;\nstruct locked_range;\n\ntypedef struct objset objset_t;\ntypedef struct dmu_tx dmu_tx_t;\ntypedef struct dsl_dir dsl_dir_t;\ntypedef struct dnode dnode_t;\n\ntypedef enum dmu_object_byteswap {\n\tDMU_BSWAP_UINT8,\n\tDMU_BSWAP_UINT16,\n\tDMU_BSWAP_UINT32,\n\tDMU_BSWAP_UINT64,\n\tDMU_BSWAP_ZAP,\n\tDMU_BSWAP_DNODE,\n\tDMU_BSWAP_OBJSET,\n\tDMU_BSWAP_ZNODE,\n\tDMU_BSWAP_OLDACL,\n\tDMU_BSWAP_ACL,\n\t \n\tDMU_BSWAP_NUMFUNCS\n} dmu_object_byteswap_t;\n\n#define\tDMU_OT_NEWTYPE 0x80\n#define\tDMU_OT_METADATA 0x40\n#define\tDMU_OT_ENCRYPTED 0x20\n#define\tDMU_OT_BYTESWAP_MASK 0x1f\n\n \n#define\tDMU_OT(byteswap, metadata, encrypted) \\\n\t(DMU_OT_NEWTYPE | \\\n\t((metadata) ? DMU_OT_METADATA : 0) | \\\n\t((encrypted) ? DMU_OT_ENCRYPTED : 0) | \\\n\t((byteswap) & DMU_OT_BYTESWAP_MASK))\n\n#define\tDMU_OT_IS_VALID(ot) (((ot) & DMU_OT_NEWTYPE) ? \\\n\t((ot) & DMU_OT_BYTESWAP_MASK) < DMU_BSWAP_NUMFUNCS : \\\n\t(ot) < DMU_OT_NUMTYPES)\n\n#define\tDMU_OT_IS_METADATA_CACHED(ot) (((ot) & DMU_OT_NEWTYPE) ? \\\n\tB_TRUE : dmu_ot[(ot)].ot_dbuf_metadata_cache)\n\n \n#ifndef ZFS_MDB\n#define\tDMU_OT_IS_METADATA_IMPL(ot) (dmu_ot[ot].ot_metadata)\n#define\tDMU_OT_IS_ENCRYPTED_IMPL(ot) (dmu_ot[ot].ot_encrypt)\n#define\tDMU_OT_BYTESWAP_IMPL(ot) (dmu_ot[ot].ot_byteswap)\n#endif\n\n#define\tDMU_OT_IS_METADATA(ot) (((ot) & DMU_OT_NEWTYPE) ? \\\n\t(((ot) & DMU_OT_METADATA) != 0) : \\\n\tDMU_OT_IS_METADATA_IMPL(ot))\n\n#define\tDMU_OT_IS_DDT(ot) \\\n\t((ot) == DMU_OT_DDT_ZAP)\n\n#define\tDMU_OT_IS_CRITICAL(ot) \\\n\t(DMU_OT_IS_METADATA(ot) && \\\n\t(ot) != DMU_OT_DNODE && \\\n\t(ot) != DMU_OT_DIRECTORY_CONTENTS && \\\n\t(ot) != DMU_OT_SA)\n\n \n#define\tDMU_OT_IS_FILE(ot) \\\n\t((ot) == DMU_OT_PLAIN_FILE_CONTENTS || (ot) == DMU_OT_UINT64_OTHER)\n\n#define\tDMU_OT_IS_ENCRYPTED(ot) (((ot) & DMU_OT_NEWTYPE) ? \\\n\t(((ot) & DMU_OT_ENCRYPTED) != 0) : \\\n\tDMU_OT_IS_ENCRYPTED_IMPL(ot))\n\n \n#define\tDMU_OT_HAS_FILL(ot) \\\n\t((ot) == DMU_OT_DNODE || (ot) == DMU_OT_OBJSET)\n\n#define\tDMU_OT_BYTESWAP(ot) (((ot) & DMU_OT_NEWTYPE) ? \\\n\t((ot) & DMU_OT_BYTESWAP_MASK) : \\\n\tDMU_OT_BYTESWAP_IMPL(ot))\n\ntypedef enum dmu_object_type {\n\tDMU_OT_NONE,\n\t \n\tDMU_OT_OBJECT_DIRECTORY,\t \n\tDMU_OT_OBJECT_ARRAY,\t\t \n\tDMU_OT_PACKED_NVLIST,\t\t \n\tDMU_OT_PACKED_NVLIST_SIZE,\t \n\tDMU_OT_BPOBJ,\t\t\t \n\tDMU_OT_BPOBJ_HDR,\t\t \n\t \n\tDMU_OT_SPACE_MAP_HEADER,\t \n\tDMU_OT_SPACE_MAP,\t\t \n\t \n\tDMU_OT_INTENT_LOG,\t\t \n\t \n\tDMU_OT_DNODE,\t\t\t \n\tDMU_OT_OBJSET,\t\t\t \n\t \n\tDMU_OT_DSL_DIR,\t\t\t \n\tDMU_OT_DSL_DIR_CHILD_MAP,\t \n\tDMU_OT_DSL_DS_SNAP_MAP,\t\t \n\tDMU_OT_DSL_PROPS,\t\t \n\tDMU_OT_DSL_DATASET,\t\t \n\t \n\tDMU_OT_ZNODE,\t\t\t \n\tDMU_OT_OLDACL,\t\t\t \n\tDMU_OT_PLAIN_FILE_CONTENTS,\t \n\tDMU_OT_DIRECTORY_CONTENTS,\t \n\tDMU_OT_MASTER_NODE,\t\t \n\tDMU_OT_UNLINKED_SET,\t\t \n\t \n\tDMU_OT_ZVOL,\t\t\t \n\tDMU_OT_ZVOL_PROP,\t\t \n\t \n\tDMU_OT_PLAIN_OTHER,\t\t \n\tDMU_OT_UINT64_OTHER,\t\t \n\tDMU_OT_ZAP_OTHER,\t\t \n\t \n\tDMU_OT_ERROR_LOG,\t\t \n\tDMU_OT_SPA_HISTORY,\t\t \n\tDMU_OT_SPA_HISTORY_OFFSETS,\t \n\tDMU_OT_POOL_PROPS,\t\t \n\tDMU_OT_DSL_PERMS,\t\t \n\tDMU_OT_ACL,\t\t\t \n\tDMU_OT_SYSACL,\t\t\t \n\tDMU_OT_FUID,\t\t\t \n\tDMU_OT_FUID_SIZE,\t\t \n\tDMU_OT_NEXT_CLONES,\t\t \n\tDMU_OT_SCAN_QUEUE,\t\t \n\tDMU_OT_USERGROUP_USED,\t\t \n\tDMU_OT_USERGROUP_QUOTA,\t\t \n\tDMU_OT_USERREFS,\t\t \n\tDMU_OT_DDT_ZAP,\t\t\t \n\tDMU_OT_DDT_STATS,\t\t \n\tDMU_OT_SA,\t\t\t \n\tDMU_OT_SA_MASTER_NODE,\t\t \n\tDMU_OT_SA_ATTR_REGISTRATION,\t \n\tDMU_OT_SA_ATTR_LAYOUTS,\t\t \n\tDMU_OT_SCAN_XLATE,\t\t \n\tDMU_OT_DEDUP,\t\t\t \n\tDMU_OT_DEADLIST,\t\t \n\tDMU_OT_DEADLIST_HDR,\t\t \n\tDMU_OT_DSL_CLONES,\t\t \n\tDMU_OT_BPOBJ_SUBOBJ,\t\t \n\t \n\tDMU_OT_NUMTYPES,\n\n\t \n\tDMU_OTN_UINT8_DATA = DMU_OT(DMU_BSWAP_UINT8, B_FALSE, B_FALSE),\n\tDMU_OTN_UINT8_METADATA = DMU_OT(DMU_BSWAP_UINT8, B_TRUE, B_FALSE),\n\tDMU_OTN_UINT16_DATA = DMU_OT(DMU_BSWAP_UINT16, B_FALSE, B_FALSE),\n\tDMU_OTN_UINT16_METADATA = DMU_OT(DMU_BSWAP_UINT16, B_TRUE, B_FALSE),\n\tDMU_OTN_UINT32_DATA = DMU_OT(DMU_BSWAP_UINT32, B_FALSE, B_FALSE),\n\tDMU_OTN_UINT32_METADATA = DMU_OT(DMU_BSWAP_UINT32, B_TRUE, B_FALSE),\n\tDMU_OTN_UINT64_DATA = DMU_OT(DMU_BSWAP_UINT64, B_FALSE, B_FALSE),\n\tDMU_OTN_UINT64_METADATA = DMU_OT(DMU_BSWAP_UINT64, B_TRUE, B_FALSE),\n\tDMU_OTN_ZAP_DATA = DMU_OT(DMU_BSWAP_ZAP, B_FALSE, B_FALSE),\n\tDMU_OTN_ZAP_METADATA = DMU_OT(DMU_BSWAP_ZAP, B_TRUE, B_FALSE),\n\n\tDMU_OTN_UINT8_ENC_DATA = DMU_OT(DMU_BSWAP_UINT8, B_FALSE, B_TRUE),\n\tDMU_OTN_UINT8_ENC_METADATA = DMU_OT(DMU_BSWAP_UINT8, B_TRUE, B_TRUE),\n\tDMU_OTN_UINT16_ENC_DATA = DMU_OT(DMU_BSWAP_UINT16, B_FALSE, B_TRUE),\n\tDMU_OTN_UINT16_ENC_METADATA = DMU_OT(DMU_BSWAP_UINT16, B_TRUE, B_TRUE),\n\tDMU_OTN_UINT32_ENC_DATA = DMU_OT(DMU_BSWAP_UINT32, B_FALSE, B_TRUE),\n\tDMU_OTN_UINT32_ENC_METADATA = DMU_OT(DMU_BSWAP_UINT32, B_TRUE, B_TRUE),\n\tDMU_OTN_UINT64_ENC_DATA = DMU_OT(DMU_BSWAP_UINT64, B_FALSE, B_TRUE),\n\tDMU_OTN_UINT64_ENC_METADATA = DMU_OT(DMU_BSWAP_UINT64, B_TRUE, B_TRUE),\n\tDMU_OTN_ZAP_ENC_DATA = DMU_OT(DMU_BSWAP_ZAP, B_FALSE, B_TRUE),\n\tDMU_OTN_ZAP_ENC_METADATA = DMU_OT(DMU_BSWAP_ZAP, B_TRUE, B_TRUE),\n} dmu_object_type_t;\n\n \n#define\tTXG_NOWAIT\t(0ULL)\n#define\tTXG_WAIT\t(1ULL<<0)\n#define\tTXG_NOTHROTTLE\t(1ULL<<1)\n\nvoid byteswap_uint64_array(void *buf, size_t size);\nvoid byteswap_uint32_array(void *buf, size_t size);\nvoid byteswap_uint16_array(void *buf, size_t size);\nvoid byteswap_uint8_array(void *buf, size_t size);\nvoid zap_byteswap(void *buf, size_t size);\nvoid zfs_oldacl_byteswap(void *buf, size_t size);\nvoid zfs_acl_byteswap(void *buf, size_t size);\nvoid zfs_znode_byteswap(void *buf, size_t size);\n\n#define\tDS_FIND_SNAPSHOTS\t(1<<0)\n#define\tDS_FIND_CHILDREN\t(1<<1)\n#define\tDS_FIND_SERIALIZE\t(1<<2)\n\n \n#define\tDMU_MAX_ACCESS (64 * 1024 * 1024)  \n#define\tDMU_MAX_DELETEBLKCNT (20480)  \n\n#define\tDMU_USERUSED_OBJECT\t(-1ULL)\n#define\tDMU_GROUPUSED_OBJECT\t(-2ULL)\n#define\tDMU_PROJECTUSED_OBJECT\t(-3ULL)\n\n \n#define\tDMU_OBJACCT_PREFIX\t\"obj-\"\n#define\tDMU_OBJACCT_PREFIX_LEN\t4\n\n \n#define\tDMU_BONUS_BLKID\t\t(-1ULL)\n#define\tDMU_SPILL_BLKID\t\t(-2ULL)\n\n \ntypedef void dmu_objset_create_sync_func_t(objset_t *os, void *arg,\n    cred_t *cr, dmu_tx_t *tx);\n\nint dmu_objset_hold(const char *name, const void *tag, objset_t **osp);\nint dmu_objset_own(const char *name, dmu_objset_type_t type,\n    boolean_t readonly, boolean_t key_required, const void *tag,\n    objset_t **osp);\nvoid dmu_objset_rele(objset_t *os, const void *tag);\nvoid dmu_objset_disown(objset_t *os, boolean_t key_required, const void *tag);\nint dmu_objset_open_ds(struct dsl_dataset *ds, objset_t **osp);\n\nvoid dmu_objset_evict_dbufs(objset_t *os);\nint dmu_objset_create(const char *name, dmu_objset_type_t type, uint64_t flags,\n    struct dsl_crypto_params *dcp, dmu_objset_create_sync_func_t func,\n    void *arg);\nint dmu_objset_clone(const char *name, const char *origin);\nint dsl_destroy_snapshots_nvl(struct nvlist *snaps, boolean_t defer,\n    struct nvlist *errlist);\nint dmu_objset_snapshot_one(const char *fsname, const char *snapname);\nint dmu_objset_find(const char *name, int func(const char *, void *), void *arg,\n    int flags);\nvoid dmu_objset_byteswap(void *buf, size_t size);\nint dsl_dataset_rename_snapshot(const char *fsname,\n    const char *oldsnapname, const char *newsnapname, boolean_t recursive);\n\ntypedef struct dmu_buf {\n\tuint64_t db_object;\t\t \n\tuint64_t db_offset;\t\t \n\tuint64_t db_size;\t\t \n\tvoid *db_data;\t\t\t \n} dmu_buf_t;\n\n \n#define\tDMU_POOL_DIRECTORY_OBJECT\t1\n#define\tDMU_POOL_CONFIG\t\t\t\"config\"\n#define\tDMU_POOL_FEATURES_FOR_WRITE\t\"features_for_write\"\n#define\tDMU_POOL_FEATURES_FOR_READ\t\"features_for_read\"\n#define\tDMU_POOL_FEATURE_DESCRIPTIONS\t\"feature_descriptions\"\n#define\tDMU_POOL_FEATURE_ENABLED_TXG\t\"feature_enabled_txg\"\n#define\tDMU_POOL_ROOT_DATASET\t\t\"root_dataset\"\n#define\tDMU_POOL_SYNC_BPOBJ\t\t\"sync_bplist\"\n#define\tDMU_POOL_ERRLOG_SCRUB\t\t\"errlog_scrub\"\n#define\tDMU_POOL_ERRLOG_LAST\t\t\"errlog_last\"\n#define\tDMU_POOL_SPARES\t\t\t\"spares\"\n#define\tDMU_POOL_DEFLATE\t\t\"deflate\"\n#define\tDMU_POOL_HISTORY\t\t\"history\"\n#define\tDMU_POOL_PROPS\t\t\t\"pool_props\"\n#define\tDMU_POOL_L2CACHE\t\t\"l2cache\"\n#define\tDMU_POOL_TMP_USERREFS\t\t\"tmp_userrefs\"\n#define\tDMU_POOL_DDT\t\t\t\"DDT-%s-%s-%s\"\n#define\tDMU_POOL_DDT_STATS\t\t\"DDT-statistics\"\n#define\tDMU_POOL_CREATION_VERSION\t\"creation_version\"\n#define\tDMU_POOL_SCAN\t\t\t\"scan\"\n#define\tDMU_POOL_ERRORSCRUB\t\t\"error_scrub\"\n#define\tDMU_POOL_FREE_BPOBJ\t\t\"free_bpobj\"\n#define\tDMU_POOL_BPTREE_OBJ\t\t\"bptree_obj\"\n#define\tDMU_POOL_EMPTY_BPOBJ\t\t\"empty_bpobj\"\n#define\tDMU_POOL_CHECKSUM_SALT\t\t\"org.illumos:checksum_salt\"\n#define\tDMU_POOL_VDEV_ZAP_MAP\t\t\"com.delphix:vdev_zap_map\"\n#define\tDMU_POOL_REMOVING\t\t\"com.delphix:removing\"\n#define\tDMU_POOL_OBSOLETE_BPOBJ\t\t\"com.delphix:obsolete_bpobj\"\n#define\tDMU_POOL_CONDENSING_INDIRECT\t\"com.delphix:condensing_indirect\"\n#define\tDMU_POOL_ZPOOL_CHECKPOINT\t\"com.delphix:zpool_checkpoint\"\n#define\tDMU_POOL_LOG_SPACEMAP_ZAP\t\"com.delphix:log_spacemap_zap\"\n#define\tDMU_POOL_DELETED_CLONES\t\t\"com.delphix:deleted_clones\"\n\n \nuint64_t dmu_object_alloc(objset_t *os, dmu_object_type_t ot,\n    int blocksize, dmu_object_type_t bonus_type, int bonus_len, dmu_tx_t *tx);\nuint64_t dmu_object_alloc_ibs(objset_t *os, dmu_object_type_t ot, int blocksize,\n    int indirect_blockshift,\n    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx);\nuint64_t dmu_object_alloc_dnsize(objset_t *os, dmu_object_type_t ot,\n    int blocksize, dmu_object_type_t bonus_type, int bonus_len,\n    int dnodesize, dmu_tx_t *tx);\nuint64_t dmu_object_alloc_hold(objset_t *os, dmu_object_type_t ot,\n    int blocksize, int indirect_blockshift, dmu_object_type_t bonustype,\n    int bonuslen, int dnodesize, dnode_t **allocated_dnode, const void *tag,\n    dmu_tx_t *tx);\nint dmu_object_claim(objset_t *os, uint64_t object, dmu_object_type_t ot,\n    int blocksize, dmu_object_type_t bonus_type, int bonus_len, dmu_tx_t *tx);\nint dmu_object_claim_dnsize(objset_t *os, uint64_t object, dmu_object_type_t ot,\n    int blocksize, dmu_object_type_t bonus_type, int bonus_len,\n    int dnodesize, dmu_tx_t *tx);\nint dmu_object_reclaim(objset_t *os, uint64_t object, dmu_object_type_t ot,\n    int blocksize, dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *txp);\nint dmu_object_reclaim_dnsize(objset_t *os, uint64_t object,\n    dmu_object_type_t ot, int blocksize, dmu_object_type_t bonustype,\n    int bonuslen, int dnodesize, boolean_t keep_spill, dmu_tx_t *tx);\nint dmu_object_rm_spill(objset_t *os, uint64_t object, dmu_tx_t *tx);\n\n \nint dmu_object_free(objset_t *os, uint64_t object, dmu_tx_t *tx);\n\n \nint dmu_object_next(objset_t *os, uint64_t *objectp,\n    boolean_t hole, uint64_t txg);\n\n \nint dmu_object_set_nlevels(objset_t *os, uint64_t object, int nlevels,\n    dmu_tx_t *tx);\n\n \nint dmu_object_set_blocksize(objset_t *os, uint64_t object, uint64_t size,\n    int ibs, dmu_tx_t *tx);\n\n \nint dmu_object_set_maxblkid(objset_t *os, uint64_t object, uint64_t maxblkid,\n    dmu_tx_t *tx);\n\n \nvoid dmu_object_set_checksum(objset_t *os, uint64_t object, uint8_t checksum,\n    dmu_tx_t *tx);\n\n \nvoid dmu_object_set_compress(objset_t *os, uint64_t object, uint8_t compress,\n    dmu_tx_t *tx);\n\nvoid dmu_write_embedded(objset_t *os, uint64_t object, uint64_t offset,\n    void *data, uint8_t etype, uint8_t comp, int uncompressed_size,\n    int compressed_size, int byteorder, dmu_tx_t *tx);\nvoid dmu_redact(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n    dmu_tx_t *tx);\n\n \n#define\tWP_NOFILL\t0x1\n#define\tWP_DMU_SYNC\t0x2\n#define\tWP_SPILL\t0x4\n\nvoid dmu_write_policy(objset_t *os, dnode_t *dn, int level, int wp,\n    struct zio_prop *zp);\n\n \nint dmu_bonus_hold(objset_t *os, uint64_t object, const void *tag,\n    dmu_buf_t **dbp);\nint dmu_bonus_hold_by_dnode(dnode_t *dn, const void *tag, dmu_buf_t **dbp,\n    uint32_t flags);\nint dmu_bonus_max(void);\nint dmu_set_bonus(dmu_buf_t *, int, dmu_tx_t *);\nint dmu_set_bonustype(dmu_buf_t *, dmu_object_type_t, dmu_tx_t *);\ndmu_object_type_t dmu_get_bonustype(dmu_buf_t *);\nint dmu_rm_spill(objset_t *, uint64_t, dmu_tx_t *);\n\n \n\nint dmu_spill_hold_by_bonus(dmu_buf_t *bonus, uint32_t flags, const void *tag,\n    dmu_buf_t **dbp);\nint dmu_spill_hold_by_dnode(dnode_t *dn, uint32_t flags,\n    const void *tag, dmu_buf_t **dbp);\nint dmu_spill_hold_existing(dmu_buf_t *bonus, const void *tag, dmu_buf_t **dbp);\n\n \nint dmu_buf_hold(objset_t *os, uint64_t object, uint64_t offset,\n    const void *tag, dmu_buf_t **, int flags);\nint dmu_buf_hold_array(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t length, int read, const void *tag, int *numbufsp,\n    dmu_buf_t ***dbpp);\nint dmu_buf_hold_noread(objset_t *os, uint64_t object, uint64_t offset,\n    const void *tag, dmu_buf_t **dbp);\nint dmu_buf_hold_by_dnode(dnode_t *dn, uint64_t offset,\n    const void *tag, dmu_buf_t **dbp, int flags);\nint dmu_buf_hold_array_by_dnode(dnode_t *dn, uint64_t offset,\n    uint64_t length, boolean_t read, const void *tag, int *numbufsp,\n    dmu_buf_t ***dbpp, uint32_t flags);\nint dmu_buf_hold_noread_by_dnode(dnode_t *dn, uint64_t offset, const void *tag,\n    dmu_buf_t **dbp);\n \nvoid dmu_buf_add_ref(dmu_buf_t *db, const void *tag);\n\n \nboolean_t dmu_buf_try_add_ref(dmu_buf_t *, objset_t *os, uint64_t object,\n    uint64_t blkid, const void *tag);\n\nvoid dmu_buf_rele(dmu_buf_t *db, const void *tag);\nuint64_t dmu_buf_refcount(dmu_buf_t *db);\nuint64_t dmu_buf_user_refcount(dmu_buf_t *db);\n\n \nint dmu_buf_hold_array_by_bonus(dmu_buf_t *db, uint64_t offset,\n    uint64_t length, boolean_t read, const void *tag,\n    int *numbufsp, dmu_buf_t ***dbpp);\nvoid dmu_buf_rele_array(dmu_buf_t **, int numbufs, const void *tag);\n\ntypedef void dmu_buf_evict_func_t(void *user_ptr);\n\n \ntypedef struct dmu_buf_user {\n\t \n\ttaskq_ent_t\tdbu_tqent;\n\n\t \n\tdmu_buf_evict_func_t *dbu_evict_func_sync;\n\tdmu_buf_evict_func_t *dbu_evict_func_async;\n#ifdef ZFS_DEBUG\n\t \n\tdmu_buf_t **dbu_clear_on_evict_dbufp;\n#endif\n} dmu_buf_user_t;\n\n \nstatic inline void\ndmu_buf_init_user(dmu_buf_user_t *dbu, dmu_buf_evict_func_t *evict_func_sync,\n    dmu_buf_evict_func_t *evict_func_async,\n    dmu_buf_t **clear_on_evict_dbufp __maybe_unused)\n{\n\tASSERT(dbu->dbu_evict_func_sync == NULL);\n\tASSERT(dbu->dbu_evict_func_async == NULL);\n\n\t \n\tIMPLY(evict_func_sync == NULL, evict_func_async != NULL);\n\tdbu->dbu_evict_func_sync = evict_func_sync;\n\tdbu->dbu_evict_func_async = evict_func_async;\n\ttaskq_init_ent(&dbu->dbu_tqent);\n#ifdef ZFS_DEBUG\n\tdbu->dbu_clear_on_evict_dbufp = clear_on_evict_dbufp;\n#endif\n}\n\n \nvoid *dmu_buf_set_user(dmu_buf_t *db, dmu_buf_user_t *user);\n\n \nvoid *dmu_buf_set_user_ie(dmu_buf_t *db, dmu_buf_user_t *user);\n\n \nvoid *dmu_buf_replace_user(dmu_buf_t *db,\n    dmu_buf_user_t *old_user, dmu_buf_user_t *new_user);\n\n \nvoid *dmu_buf_remove_user(dmu_buf_t *db, dmu_buf_user_t *user);\n\n \nvoid *dmu_buf_get_user(dmu_buf_t *db);\n\nobjset_t *dmu_buf_get_objset(dmu_buf_t *db);\ndnode_t *dmu_buf_dnode_enter(dmu_buf_t *db);\nvoid dmu_buf_dnode_exit(dmu_buf_t *db);\n\n \nvoid dmu_buf_user_evict_wait(void);\n\n \nstruct blkptr *dmu_buf_get_blkptr(dmu_buf_t *db);\n\n \nvoid dmu_buf_will_dirty(dmu_buf_t *db, dmu_tx_t *tx);\nboolean_t dmu_buf_is_dirty(dmu_buf_t *db, dmu_tx_t *tx);\nvoid dmu_buf_set_crypt_params(dmu_buf_t *db_fake, boolean_t byteorder,\n    const uint8_t *salt, const uint8_t *iv, const uint8_t *mac, dmu_tx_t *tx);\n\n \n\n#define\tDMU_NEW_OBJECT\t(-1ULL)\n#define\tDMU_OBJECT_END\t(-1ULL)\n\ndmu_tx_t *dmu_tx_create(objset_t *os);\nvoid dmu_tx_hold_write(dmu_tx_t *tx, uint64_t object, uint64_t off, int len);\nvoid dmu_tx_hold_write_by_dnode(dmu_tx_t *tx, dnode_t *dn, uint64_t off,\n    int len);\nvoid dmu_tx_hold_append(dmu_tx_t *tx, uint64_t object, uint64_t off, int len);\nvoid dmu_tx_hold_append_by_dnode(dmu_tx_t *tx, dnode_t *dn, uint64_t off,\n    int len);\nvoid dmu_tx_hold_clone_by_dnode(dmu_tx_t *tx, dnode_t *dn, uint64_t off,\n    int len);\nvoid dmu_tx_hold_free(dmu_tx_t *tx, uint64_t object, uint64_t off,\n    uint64_t len);\nvoid dmu_tx_hold_free_by_dnode(dmu_tx_t *tx, dnode_t *dn, uint64_t off,\n    uint64_t len);\nvoid dmu_tx_hold_zap(dmu_tx_t *tx, uint64_t object, int add, const char *name);\nvoid dmu_tx_hold_zap_by_dnode(dmu_tx_t *tx, dnode_t *dn, int add,\n    const char *name);\nvoid dmu_tx_hold_bonus(dmu_tx_t *tx, uint64_t object);\nvoid dmu_tx_hold_bonus_by_dnode(dmu_tx_t *tx, dnode_t *dn);\nvoid dmu_tx_hold_spill(dmu_tx_t *tx, uint64_t object);\nvoid dmu_tx_hold_sa(dmu_tx_t *tx, struct sa_handle *hdl, boolean_t may_grow);\nvoid dmu_tx_hold_sa_create(dmu_tx_t *tx, int total_size);\nvoid dmu_tx_abort(dmu_tx_t *tx);\nint dmu_tx_assign(dmu_tx_t *tx, uint64_t txg_how);\nvoid dmu_tx_wait(dmu_tx_t *tx);\nvoid dmu_tx_commit(dmu_tx_t *tx);\nvoid dmu_tx_mark_netfree(dmu_tx_t *tx);\n\n \ntypedef void dmu_tx_callback_func_t(void *dcb_data, int error);\n\nvoid dmu_tx_callback_register(dmu_tx_t *tx, dmu_tx_callback_func_t *dcb_func,\n    void *dcb_data);\nvoid dmu_tx_do_callbacks(list_t *cb_list, int error);\n\n \nint dmu_free_range(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t size, dmu_tx_t *tx);\nint dmu_free_long_range(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t size);\nint dmu_free_long_object(objset_t *os, uint64_t object);\n\n \n#define\tDMU_READ_PREFETCH\t0  \n#define\tDMU_READ_NO_PREFETCH\t1  \n#define\tDMU_READ_NO_DECRYPT\t2  \nint dmu_read(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n\tvoid *buf, uint32_t flags);\nint dmu_read_by_dnode(dnode_t *dn, uint64_t offset, uint64_t size, void *buf,\n    uint32_t flags);\nvoid dmu_write(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n\tconst void *buf, dmu_tx_t *tx);\nvoid dmu_write_by_dnode(dnode_t *dn, uint64_t offset, uint64_t size,\n    const void *buf, dmu_tx_t *tx);\nvoid dmu_prealloc(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n\tdmu_tx_t *tx);\n#ifdef _KERNEL\nint dmu_read_uio(objset_t *os, uint64_t object, zfs_uio_t *uio, uint64_t size);\nint dmu_read_uio_dbuf(dmu_buf_t *zdb, zfs_uio_t *uio, uint64_t size);\nint dmu_read_uio_dnode(dnode_t *dn, zfs_uio_t *uio, uint64_t size);\nint dmu_write_uio(objset_t *os, uint64_t object, zfs_uio_t *uio, uint64_t size,\n\tdmu_tx_t *tx);\nint dmu_write_uio_dbuf(dmu_buf_t *zdb, zfs_uio_t *uio, uint64_t size,\n\tdmu_tx_t *tx);\nint dmu_write_uio_dnode(dnode_t *dn, zfs_uio_t *uio, uint64_t size,\n\tdmu_tx_t *tx);\n#endif\nstruct arc_buf *dmu_request_arcbuf(dmu_buf_t *handle, int size);\nvoid dmu_return_arcbuf(struct arc_buf *buf);\nint dmu_assign_arcbuf_by_dnode(dnode_t *dn, uint64_t offset,\n    struct arc_buf *buf, dmu_tx_t *tx);\nint dmu_assign_arcbuf_by_dbuf(dmu_buf_t *handle, uint64_t offset,\n    struct arc_buf *buf, dmu_tx_t *tx);\n#define\tdmu_assign_arcbuf\tdmu_assign_arcbuf_by_dbuf\nextern uint_t zfs_max_recordsize;\n\n \nvoid dmu_prefetch(objset_t *os, uint64_t object, int64_t level, uint64_t offset,\n\tuint64_t len, enum zio_priority pri);\n\ntypedef struct dmu_object_info {\n\t \n\tuint32_t doi_data_block_size;\n\tuint32_t doi_metadata_block_size;\n\tdmu_object_type_t doi_type;\n\tdmu_object_type_t doi_bonus_type;\n\tuint64_t doi_bonus_size;\n\tuint8_t doi_indirection;\t\t \n\tuint8_t doi_checksum;\n\tuint8_t doi_compress;\n\tuint8_t doi_nblkptr;\n\tuint8_t doi_pad[4];\n\tuint64_t doi_dnodesize;\n\tuint64_t doi_physical_blocks_512;\t \n\tuint64_t doi_max_offset;\n\tuint64_t doi_fill_count;\t\t \n} dmu_object_info_t;\n\ntypedef void (*const arc_byteswap_func_t)(void *buf, size_t size);\n\ntypedef struct dmu_object_type_info {\n\tdmu_object_byteswap_t\tot_byteswap;\n\tboolean_t\t\tot_metadata;\n\tboolean_t\t\tot_dbuf_metadata_cache;\n\tboolean_t\t\tot_encrypt;\n\tconst char\t\t*ot_name;\n} dmu_object_type_info_t;\n\ntypedef const struct dmu_object_byteswap_info {\n\tarc_byteswap_func_t\t ob_func;\n\tconst char\t\t*ob_name;\n} dmu_object_byteswap_info_t;\n\nextern const dmu_object_type_info_t dmu_ot[DMU_OT_NUMTYPES];\nextern dmu_object_byteswap_info_t dmu_ot_byteswap[DMU_BSWAP_NUMFUNCS];\n\n \nint dmu_object_info(objset_t *os, uint64_t object, dmu_object_info_t *doi);\nvoid __dmu_object_info_from_dnode(struct dnode *dn, dmu_object_info_t *doi);\n \nvoid dmu_object_info_from_dnode(dnode_t *dn, dmu_object_info_t *doi);\n \nvoid dmu_object_info_from_db(dmu_buf_t *db, dmu_object_info_t *doi);\n \nvoid dmu_object_size_from_db(dmu_buf_t *db, uint32_t *blksize,\n    u_longlong_t *nblk512);\n\nvoid dmu_object_dnsize_from_db(dmu_buf_t *db, int *dnsize);\n\ntypedef struct dmu_objset_stats {\n\tuint64_t dds_num_clones;  \n\tuint64_t dds_creation_txg;\n\tuint64_t dds_guid;\n\tdmu_objset_type_t dds_type;\n\tuint8_t dds_is_snapshot;\n\tuint8_t dds_inconsistent;\n\tuint8_t dds_redacted;\n\tchar dds_origin[ZFS_MAX_DATASET_NAME_LEN];\n} dmu_objset_stats_t;\n\n \nvoid dmu_objset_fast_stat(objset_t *os, dmu_objset_stats_t *stat);\n\n \nvoid dmu_objset_stats(objset_t *os, struct nvlist *nv);\n\n \nvoid dmu_objset_space(objset_t *os, uint64_t *refdbytesp, uint64_t *availbytesp,\n    uint64_t *usedobjsp, uint64_t *availobjsp);\n\n \nuint64_t dmu_objset_fsid_guid(objset_t *os);\n\n \ninode_timespec_t dmu_objset_snap_cmtime(objset_t *os);\n\nint dmu_objset_is_snapshot(objset_t *os);\n\nextern struct spa *dmu_objset_spa(objset_t *os);\nextern struct zilog *dmu_objset_zil(objset_t *os);\nextern struct dsl_pool *dmu_objset_pool(objset_t *os);\nextern struct dsl_dataset *dmu_objset_ds(objset_t *os);\nextern void dmu_objset_name(objset_t *os, char *buf);\nextern dmu_objset_type_t dmu_objset_type(objset_t *os);\nextern uint64_t dmu_objset_id(objset_t *os);\nextern uint64_t dmu_objset_dnodesize(objset_t *os);\nextern zfs_sync_type_t dmu_objset_syncprop(objset_t *os);\nextern zfs_logbias_op_t dmu_objset_logbias(objset_t *os);\nextern int dmu_objset_blksize(objset_t *os);\nextern int dmu_snapshot_list_next(objset_t *os, int namelen, char *name,\n    uint64_t *id, uint64_t *offp, boolean_t *case_conflict);\nextern int dmu_snapshot_lookup(objset_t *os, const char *name, uint64_t *val);\nextern int dmu_snapshot_realname(objset_t *os, const char *name, char *real,\n    int maxlen, boolean_t *conflict);\nextern int dmu_dir_list_next(objset_t *os, int namelen, char *name,\n    uint64_t *idp, uint64_t *offp);\n\ntypedef struct zfs_file_info {\n\tuint64_t zfi_user;\n\tuint64_t zfi_group;\n\tuint64_t zfi_project;\n\tuint64_t zfi_generation;\n} zfs_file_info_t;\n\ntypedef int file_info_cb_t(dmu_object_type_t bonustype, const void *data,\n    struct zfs_file_info *zoi);\nextern void dmu_objset_register_type(dmu_objset_type_t ost,\n    file_info_cb_t *cb);\nextern void dmu_objset_set_user(objset_t *os, void *user_ptr);\nextern void *dmu_objset_get_user(objset_t *os);\n\n \nuint64_t dmu_tx_get_txg(dmu_tx_t *tx);\n\n \n\n \ntypedef struct zgd {\n\tstruct lwb\t*zgd_lwb;\n\tstruct blkptr\t*zgd_bp;\n\tdmu_buf_t\t*zgd_db;\n\tstruct zfs_locked_range *zgd_lr;\n\tvoid\t\t*zgd_private;\n} zgd_t;\n\ntypedef void dmu_sync_cb_t(zgd_t *arg, int error);\nint dmu_sync(struct zio *zio, uint64_t txg, dmu_sync_cb_t *done, zgd_t *zgd);\n\n \nint dmu_offset_next(objset_t *os, uint64_t object, boolean_t hole,\n    uint64_t *off);\n\nint dmu_read_l0_bps(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t length, struct blkptr *bps, size_t *nbpsp);\nint dmu_brt_clone(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t length, dmu_tx_t *tx, const struct blkptr *bps, size_t nbps);\n\n \nextern void dmu_init(void);\nextern void dmu_fini(void);\n\ntypedef void (*dmu_traverse_cb_t)(objset_t *os, void *arg, struct blkptr *bp,\n    uint64_t object, uint64_t offset, int len);\nvoid dmu_traverse_objset(objset_t *os, uint64_t txg_start,\n    dmu_traverse_cb_t cb, void *arg);\n\nint dmu_diff(const char *tosnap_name, const char *fromsnap_name,\n    zfs_file_t *fp, offset_t *offp);\n\n \n#define\tZFS_CRC64_POLY\t0xC96C5795D7870F42ULL\t \nextern uint64_t zfs_crc64_table[256];\n\nextern uint_t dmu_prefetch_max;\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}