{
  "module_name": "vfs_compat.h",
  "hash_id": "6008c7885b0f87917c2f288cb3416288d381a51afaa640c760214fb25a040ec5",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/linux/kernel/linux/vfs_compat.h",
  "human_readable_source": " \n\n \n\n#ifndef _ZFS_VFS_H\n#define\t_ZFS_VFS_H\n\n#include <sys/taskq.h>\n#include <sys/cred.h>\n#include <linux/backing-dev.h>\n#include <linux/compat.h>\n\n \n#if defined(HAVE_SUPER_SETUP_BDI_NAME)\nextern atomic_long_t zfs_bdi_seq;\n\nstatic inline int\nzpl_bdi_setup(struct super_block *sb, char *name)\n{\n\treturn super_setup_bdi_name(sb, \"%.28s-%ld\", name,\n\t    atomic_long_inc_return(&zfs_bdi_seq));\n}\nstatic inline void\nzpl_bdi_destroy(struct super_block *sb)\n{\n}\n#elif defined(HAVE_2ARGS_BDI_SETUP_AND_REGISTER)\nstatic inline int\nzpl_bdi_setup(struct super_block *sb, char *name)\n{\n\tstruct backing_dev_info *bdi;\n\tint error;\n\n\tbdi = kmem_zalloc(sizeof (struct backing_dev_info), KM_SLEEP);\n\terror = bdi_setup_and_register(bdi, name);\n\tif (error) {\n\t\tkmem_free(bdi, sizeof (struct backing_dev_info));\n\t\treturn (error);\n\t}\n\n\tsb->s_bdi = bdi;\n\n\treturn (0);\n}\nstatic inline void\nzpl_bdi_destroy(struct super_block *sb)\n{\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tbdi_destroy(bdi);\n\tkmem_free(bdi, sizeof (struct backing_dev_info));\n\tsb->s_bdi = NULL;\n}\n#elif defined(HAVE_3ARGS_BDI_SETUP_AND_REGISTER)\nstatic inline int\nzpl_bdi_setup(struct super_block *sb, char *name)\n{\n\tstruct backing_dev_info *bdi;\n\tint error;\n\n\tbdi = kmem_zalloc(sizeof (struct backing_dev_info), KM_SLEEP);\n\terror = bdi_setup_and_register(bdi, name, BDI_CAP_MAP_COPY);\n\tif (error) {\n\t\tkmem_free(sb->s_bdi, sizeof (struct backing_dev_info));\n\t\treturn (error);\n\t}\n\n\tsb->s_bdi = bdi;\n\n\treturn (0);\n}\nstatic inline void\nzpl_bdi_destroy(struct super_block *sb)\n{\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tbdi_destroy(bdi);\n\tkmem_free(bdi, sizeof (struct backing_dev_info));\n\tsb->s_bdi = NULL;\n}\n#else\n#error \"Unsupported kernel\"\n#endif\n\n \n#ifndef\tSB_RDONLY\n#define\tSB_RDONLY\tMS_RDONLY\n#endif\n\n#ifndef\tSB_SILENT\n#define\tSB_SILENT\tMS_SILENT\n#endif\n\n#ifndef\tSB_ACTIVE\n#define\tSB_ACTIVE\tMS_ACTIVE\n#endif\n\n#ifndef\tSB_POSIXACL\n#define\tSB_POSIXACL\tMS_POSIXACL\n#endif\n\n#ifndef\tSB_MANDLOCK\n#define\tSB_MANDLOCK\tMS_MANDLOCK\n#endif\n\n#ifndef\tSB_NOATIME\n#define\tSB_NOATIME\tMS_NOATIME\n#endif\n\n \n#if defined(HAVE_EVICT_INODE) && !defined(HAVE_CLEAR_INODE)\n#define\tclear_inode(ip)\t\tend_writeback(ip)\n#endif  \n\n#if defined(SEEK_HOLE) && defined(SEEK_DATA) && !defined(HAVE_LSEEK_EXECUTE)\nstatic inline loff_t\nlseek_execute(\n\tstruct file *filp,\n\tstruct inode *inode,\n\tloff_t offset,\n\tloff_t maxsize)\n{\n\tif (offset < 0 && !(filp->f_mode & FMODE_UNSIGNED_OFFSET))\n\t\treturn (-EINVAL);\n\n\tif (offset > maxsize)\n\t\treturn (-EINVAL);\n\n\tif (offset != filp->f_pos) {\n\t\tspin_lock(&filp->f_lock);\n\t\tfilp->f_pos = offset;\n\t\tfilp->f_version = 0;\n\t\tspin_unlock(&filp->f_lock);\n\t}\n\n\treturn (offset);\n}\n#endif  \n\n#if defined(CONFIG_FS_POSIX_ACL)\n \n\n#include <linux/posix_acl.h>\n\n#if defined(HAVE_POSIX_ACL_RELEASE) && !defined(HAVE_POSIX_ACL_RELEASE_GPL_ONLY)\n#define\tzpl_posix_acl_release(arg)\t\tposix_acl_release(arg)\n#else\nvoid zpl_posix_acl_release_impl(struct posix_acl *);\n\nstatic inline void\nzpl_posix_acl_release(struct posix_acl *acl)\n{\n\tif ((acl == NULL) || (acl == ACL_NOT_CACHED))\n\t\treturn;\n#ifdef HAVE_ACL_REFCOUNT\n\tif (refcount_dec_and_test(&acl->a_refcount))\n\t\tzpl_posix_acl_release_impl(acl);\n#else\n\tif (atomic_dec_and_test(&acl->a_refcount))\n\t\tzpl_posix_acl_release_impl(acl);\n#endif\n}\n#endif  \n\n#ifdef HAVE_SET_CACHED_ACL_USABLE\n#define\tzpl_set_cached_acl(ip, ty, n)\t\tset_cached_acl(ip, ty, n)\n#define\tzpl_forget_cached_acl(ip, ty)\t\tforget_cached_acl(ip, ty)\n#else\nstatic inline void\nzpl_set_cached_acl(struct inode *ip, int type, struct posix_acl *newer)\n{\n\tstruct posix_acl *older = NULL;\n\n\tspin_lock(&ip->i_lock);\n\n\tif ((newer != ACL_NOT_CACHED) && (newer != NULL))\n\t\tposix_acl_dup(newer);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tolder = ip->i_acl;\n\t\trcu_assign_pointer(ip->i_acl, newer);\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tolder = ip->i_default_acl;\n\t\trcu_assign_pointer(ip->i_default_acl, newer);\n\t\tbreak;\n\t}\n\n\tspin_unlock(&ip->i_lock);\n\n\tzpl_posix_acl_release(older);\n}\n\nstatic inline void\nzpl_forget_cached_acl(struct inode *ip, int type)\n{\n\tzpl_set_cached_acl(ip, type, (struct posix_acl *)ACL_NOT_CACHED);\n}\n#endif  \n\n \n#ifndef HAVE___POSIX_ACL_CHMOD\n#ifdef HAVE_POSIX_ACL_CHMOD\n#define\t__posix_acl_chmod(acl, gfp, mode)\tposix_acl_chmod(acl, gfp, mode)\n#define\t__posix_acl_create(acl, gfp, mode)\tposix_acl_create(acl, gfp, mode)\n#else\n#error \"Unsupported kernel\"\n#endif  \n#endif  \n\n \n#ifdef HAVE_POSIX_ACL_VALID_WITH_NS\n#define\tzpl_posix_acl_valid(ip, acl)  posix_acl_valid(ip->i_sb->s_user_ns, acl)\n#else\n#define\tzpl_posix_acl_valid(ip, acl)  posix_acl_valid(acl)\n#endif\n\n#endif  \n\n \n#ifndef HAVE_FILE_INODE\nstatic inline struct inode *file_inode(const struct file *f)\n{\n\treturn (f->f_dentry->d_inode);\n}\n#endif  \n\n \n#ifndef HAVE_FILE_DENTRY\nstatic inline struct dentry *file_dentry(const struct file *f)\n{\n\treturn (f->f_path.dentry);\n}\n#endif  \n\nstatic inline uid_t zfs_uid_read_impl(struct inode *ip)\n{\n\treturn (from_kuid(kcred->user_ns, ip->i_uid));\n}\n\nstatic inline uid_t zfs_uid_read(struct inode *ip)\n{\n\treturn (zfs_uid_read_impl(ip));\n}\n\nstatic inline gid_t zfs_gid_read_impl(struct inode *ip)\n{\n\treturn (from_kgid(kcred->user_ns, ip->i_gid));\n}\n\nstatic inline gid_t zfs_gid_read(struct inode *ip)\n{\n\treturn (zfs_gid_read_impl(ip));\n}\n\nstatic inline void zfs_uid_write(struct inode *ip, uid_t uid)\n{\n\tip->i_uid = make_kuid(kcred->user_ns, uid);\n}\n\nstatic inline void zfs_gid_write(struct inode *ip, gid_t gid)\n{\n\tip->i_gid = make_kgid(kcred->user_ns, gid);\n}\n\n \n#ifndef RENAME_NOREPLACE\n#define\tRENAME_NOREPLACE\t(1 << 0)  \n#endif\n#ifndef RENAME_EXCHANGE\n#define\tRENAME_EXCHANGE\t\t(1 << 1)  \n#endif\n#ifndef RENAME_WHITEOUT\n#define\tRENAME_WHITEOUT\t\t(1 << 2)  \n#endif\n\n \n#if !(defined(HAVE_SETATTR_PREPARE_NO_USERNS) || \\\n    defined(HAVE_SETATTR_PREPARE_USERNS) || \\\n    defined(HAVE_SETATTR_PREPARE_IDMAP))\nstatic inline int\nsetattr_prepare(struct dentry *dentry, struct iattr *ia)\n{\n\treturn (inode_change_ok(dentry->d_inode, ia));\n}\n#endif\n\n \n\n#ifndef STATX_BASIC_STATS\n#define\tSTATX_BASIC_STATS\t0\n#endif\n\n#ifndef AT_STATX_SYNC_AS_STAT\n#define\tAT_STATX_SYNC_AS_STAT\t0\n#endif\n\n \n\n#ifdef HAVE_VFSMOUNT_IOPS_GETATTR\n#define\tZPL_GETATTR_WRAPPER(func)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nfunc(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct path path = { .mnt = mnt, .dentry = dentry };\t\t\\\n\treturn func##_impl(&path, stat, STATX_BASIC_STATS,\t\t\\\n\t    AT_STATX_SYNC_AS_STAT);\t\t\t\t\t\\\n}\n#elif defined(HAVE_PATH_IOPS_GETATTR)\n#define\tZPL_GETATTR_WRAPPER(func)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nfunc(const struct path *path, struct kstat *stat, u32 request_mask,\t\\\n    unsigned int query_flags)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (func##_impl(path, stat, request_mask, query_flags));\t\\\n}\n#elif defined(HAVE_USERNS_IOPS_GETATTR)\n#define\tZPL_GETATTR_WRAPPER(func)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nfunc(struct user_namespace *user_ns, const struct path *path,\t\\\n    struct kstat *stat, u32 request_mask, unsigned int query_flags)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (func##_impl(user_ns, path, stat, request_mask, \\\n\t    query_flags));\t\\\n}\n#elif defined(HAVE_IDMAP_IOPS_GETATTR)\n#define\tZPL_GETATTR_WRAPPER(func)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nfunc(struct mnt_idmap *user_ns, const struct path *path,\t\\\n    struct kstat *stat, u32 request_mask, unsigned int query_flags)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (func##_impl(user_ns, path, stat, request_mask,\t\\\n\t    query_flags));\t\\\n}\n#else\n#error\n#endif\n\n \n#if !defined(HAVE_CURRENT_TIME)\nstatic inline struct timespec\ncurrent_time(struct inode *ip)\n{\n\treturn (timespec_trunc(current_kernel_time(), ip->i_sb->s_time_gran));\n}\n#endif\n\n \n#ifdef HAVE_INODE_SET_IVERSION\n#include <linux/iversion.h>\n#else\nstatic inline void\ninode_set_iversion(struct inode *ip, u64 val)\n{\n\tip->i_version = val;\n}\n#endif\n\n \nstatic inline int\nzpl_is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n#ifdef HAVE_IN_COMPAT_SYSCALL\n\treturn (in_compat_syscall());\n#else\n\treturn (is_compat_task());\n#endif\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}\n\n \n#ifdef HAVE_GENERIC_FILLATTR_IDMAP\n#define\tzpl_generic_fillattr(idmap, ip, sp)\t\\\n    generic_fillattr(idmap, ip, sp)\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP_REQMASK)\n#define\tzpl_generic_fillattr(idmap, rqm, ip, sp)\t\\\n    generic_fillattr(idmap, rqm, ip, sp)\n#elif defined(HAVE_GENERIC_FILLATTR_USERNS)\n#define\tzpl_generic_fillattr(user_ns, ip, sp)\t\\\n    generic_fillattr(user_ns, ip, sp)\n#else\n#define\tzpl_generic_fillattr(user_ns, ip, sp)\tgeneric_fillattr(ip, sp)\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}