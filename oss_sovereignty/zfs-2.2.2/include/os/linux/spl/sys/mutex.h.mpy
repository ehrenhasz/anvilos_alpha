{
  "module_name": "mutex.h",
  "hash_id": "f127201583bc2aa8355f8527e6b026c02d65a44e1edcde84e508030df07dd465",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/linux/spl/sys/mutex.h",
  "human_readable_source": " \n\n#ifndef _SPL_MUTEX_H\n#define\t_SPL_MUTEX_H\n\n#include <sys/types.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/lockdep.h>\n#include <linux/compiler_compat.h>\n\ntypedef enum {\n\tMUTEX_DEFAULT\t= 0,\n\tMUTEX_SPIN\t= 1,\n\tMUTEX_ADAPTIVE\t= 2,\n\tMUTEX_NOLOCKDEP\t= 3\n} kmutex_type_t;\n\ntypedef struct {\n\tstruct mutex\t\tm_mutex;\n\tspinlock_t\t\tm_lock;\t \n\tkthread_t\t\t*m_owner;\n#ifdef CONFIG_LOCKDEP\n\tkmutex_type_t\t\tm_type;\n#endif  \n} kmutex_t;\n\n#define\tMUTEX(mp)\t\t(&((mp)->m_mutex))\n\nstatic inline void\nspl_mutex_set_owner(kmutex_t *mp)\n{\n\tmp->m_owner = current;\n}\n\nstatic inline void\nspl_mutex_clear_owner(kmutex_t *mp)\n{\n\tmp->m_owner = NULL;\n}\n\n#define\tmutex_owner(mp)\t\t(READ_ONCE((mp)->m_owner))\n#define\tmutex_owned(mp)\t\t(mutex_owner(mp) == current)\n#define\tMUTEX_HELD(mp)\t\tmutex_owned(mp)\n#define\tMUTEX_NOT_HELD(mp)\t(!MUTEX_HELD(mp))\n\n#ifdef CONFIG_LOCKDEP\nstatic inline void\nspl_mutex_set_type(kmutex_t *mp, kmutex_type_t type)\n{\n\tmp->m_type = type;\n}\nstatic inline void\nspl_mutex_lockdep_off_maybe(kmutex_t *mp)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (mp && mp->m_type == MUTEX_NOLOCKDEP)\t\t\\\n\t\tlockdep_off();\t\t\t\t\t\\\n}\nstatic inline void\nspl_mutex_lockdep_on_maybe(kmutex_t *mp)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (mp && mp->m_type == MUTEX_NOLOCKDEP)\t\t\\\n\t\tlockdep_on();\t\t\t\t\t\\\n}\n#else   \n#define\tspl_mutex_set_type(mp, type)\n#define\tspl_mutex_lockdep_off_maybe(mp)\n#define\tspl_mutex_lockdep_on_maybe(mp)\n#endif  \n\n \n#undef mutex_init\n#define\tmutex_init(mp, name, type, ibc)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\\\n\tASSERT(type == MUTEX_DEFAULT || type == MUTEX_NOLOCKDEP); \\\n\t\t\t\t\t\t\t\t\\\n\t__mutex_init(MUTEX(mp), (name) ? (#name) : (#mp), &__key); \\\n\tspin_lock_init(&(mp)->m_lock);\t\t\t\t\\\n\tspl_mutex_clear_owner(mp);\t\t\t\t\\\n\tspl_mutex_set_type(mp, type);\t\t\t\t\\\n}\n\n#undef mutex_destroy\n#define\tmutex_destroy(mp)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tVERIFY3P(mutex_owner(mp), ==, NULL);\t\t\t\\\n}\n\n#define\tmutex_tryenter(mp)\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint _rc_;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tspl_mutex_lockdep_off_maybe(mp);\t\t\t\\\n\tif ((_rc_ = mutex_trylock(MUTEX(mp))) == 1)\t\t\\\n\t\tspl_mutex_set_owner(mp);\t\t\t\\\n\tspl_mutex_lockdep_on_maybe(mp);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t_rc_;\t\t\t\t\t\t\t\\\n})\n\n#define\tNESTED_SINGLE 1\n\n#define\tmutex_enter_nested(mp, subclass)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tASSERT3P(mutex_owner(mp), !=, current);\t\t\t\\\n\tspl_mutex_lockdep_off_maybe(mp);\t\t\t\\\n\tmutex_lock_nested(MUTEX(mp), (subclass));\t\t\\\n\tspl_mutex_lockdep_on_maybe(mp);\t\t\t\t\\\n\tspl_mutex_set_owner(mp);\t\t\t\t\\\n}\n\n#define\tmutex_enter_interruptible(mp)\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint _rc_;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tASSERT3P(mutex_owner(mp), !=, current);\t\t\t\\\n\tspl_mutex_lockdep_off_maybe(mp);\t\t\t\\\n\t_rc_ = mutex_lock_interruptible(MUTEX(mp));\t\t\\\n\tspl_mutex_lockdep_on_maybe(mp);\t\t\t\t\\\n\tif (!_rc_) {\t\t\t\t\t\t\\\n\t\tspl_mutex_set_owner(mp);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t_rc_;\t\t\t\t\t\t\t\\\n})\n\n#define\tmutex_enter(mp) mutex_enter_nested((mp), 0)\n\n \n#define\tmutex_exit(mp)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tASSERT3P(mutex_owner(mp), ==, current);\t\t\t\\\n\tspl_mutex_clear_owner(mp);\t\t\t\t\\\n\tspin_lock(&(mp)->m_lock);\t\t\t\t\\\n\tspl_mutex_lockdep_off_maybe(mp);\t\t\t\\\n\tmutex_unlock(MUTEX(mp));\t\t\t\t\\\n\tspl_mutex_lockdep_on_maybe(mp);\t\t\t\t\\\n\tspin_unlock(&(mp)->m_lock);\t\t\t\t\\\n\t \t\\\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}