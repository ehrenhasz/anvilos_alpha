{
  "module_name": "list.h",
  "hash_id": "d4701930d826fe7a14a8a233484ac39417b9daeed4beb30a174e8797a096fd81",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/linux/spl/sys/list.h",
  "human_readable_source": " \n\n#ifndef _SPL_LIST_H\n#define\t_SPL_LIST_H\n\n#include <sys/types.h>\n#include <sys/debug.h>\n#include <linux/list.h>\n\n \n\ntypedef struct list_head list_node_t;\n\ntypedef struct list {\n\tsize_t list_size;\n\tsize_t list_offset;\n\tlist_node_t list_head;\n} list_t;\n\n#define\tlist_d2l(a, obj) ((list_node_t *)(((char *)obj) + (a)->list_offset))\n#define\tlist_object(a, node) ((void *)(((char *)node) - (a)->list_offset))\n\nstatic inline int\nlist_is_empty(list_t *list)\n{\n\treturn (list_empty(&list->list_head));\n}\n\nstatic inline void\nlist_link_init(list_node_t *node)\n{\n\tnode->next = LIST_POISON1;\n\tnode->prev = LIST_POISON2;\n}\n\nstatic inline void\nlist_create(list_t *list, size_t size, size_t offset)\n{\n\tlist->list_size = size;\n\tlist->list_offset = offset;\n\tINIT_LIST_HEAD(&list->list_head);\n}\n\nstatic inline void\nlist_destroy(list_t *list)\n{\n\tlist_del(&list->list_head);\n}\n\nstatic inline void\nlist_insert_head(list_t *list, void *object)\n{\n\tlist_add(list_d2l(list, object), &list->list_head);\n}\n\nstatic inline void\nlist_insert_tail(list_t *list, void *object)\n{\n\tlist_add_tail(list_d2l(list, object), &list->list_head);\n}\n\nstatic inline void\nlist_insert_after(list_t *list, void *object, void *nobject)\n{\n\tif (object == NULL)\n\t\tlist_insert_head(list, nobject);\n\telse\n\t\tlist_add(list_d2l(list, nobject), list_d2l(list, object));\n}\n\nstatic inline void\nlist_insert_before(list_t *list, void *object, void *nobject)\n{\n\tif (object == NULL)\n\t\tlist_insert_tail(list, nobject);\n\telse\n\t\tlist_add_tail(list_d2l(list, nobject), list_d2l(list, object));\n}\n\nstatic inline void\nlist_remove(list_t *list, void *object)\n{\n\tlist_del(list_d2l(list, object));\n}\n\nstatic inline void *\nlist_remove_head(list_t *list)\n{\n\tlist_node_t *head = list->list_head.next;\n\tif (head == &list->list_head)\n\t\treturn (NULL);\n\n\tlist_del(head);\n\treturn (list_object(list, head));\n}\n\nstatic inline void *\nlist_remove_tail(list_t *list)\n{\n\tlist_node_t *tail = list->list_head.prev;\n\tif (tail == &list->list_head)\n\t\treturn (NULL);\n\n\tlist_del(tail);\n\treturn (list_object(list, tail));\n}\n\nstatic inline void *\nlist_head(list_t *list)\n{\n\tif (list_is_empty(list))\n\t\treturn (NULL);\n\n\treturn (list_object(list, list->list_head.next));\n}\n\nstatic inline void *\nlist_tail(list_t *list)\n{\n\tif (list_is_empty(list))\n\t\treturn (NULL);\n\n\treturn (list_object(list, list->list_head.prev));\n}\n\nstatic inline void *\nlist_next(list_t *list, void *object)\n{\n\tlist_node_t *node = list_d2l(list, object);\n\n\tif (node->next != &list->list_head)\n\t\treturn (list_object(list, node->next));\n\n\treturn (NULL);\n}\n\nstatic inline void *\nlist_prev(list_t *list, void *object)\n{\n\tlist_node_t *node = list_d2l(list, object);\n\n\tif (node->prev != &list->list_head)\n\t\treturn (list_object(list, node->prev));\n\n\treturn (NULL);\n}\n\nstatic inline int\nlist_link_active(list_node_t *node)\n{\n\tEQUIV(node->next == LIST_POISON1, node->prev == LIST_POISON2);\n\treturn (node->next != LIST_POISON1);\n}\n\nstatic inline void\nspl_list_move_tail(list_t *dst, list_t *src)\n{\n\tlist_splice_init(&src->list_head, dst->list_head.prev);\n}\n\n#define\tlist_move_tail(dst, src)\tspl_list_move_tail(dst, src)\n\nstatic inline void\nlist_link_replace(list_node_t *old_node, list_node_t *new_node)\n{\n\tnew_node->next = old_node->next;\n\tnew_node->prev = old_node->prev;\n\told_node->prev->next = new_node;\n\told_node->next->prev = new_node;\n\tlist_link_init(old_node);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}