{
  "module_name": "zfs_znode_impl.h",
  "hash_id": "56bcb4cbb93fbeb5b7acfaa149c1ffa3e61f5d904c0c49369045c9fdaf11d7cb",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/linux/zfs/sys/zfs_znode_impl.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_ZFS_ZNODE_IMPL_H\n#define\t_SYS_ZFS_ZNODE_IMPL_H\n\n#ifndef _KERNEL\n#error \"no user serviceable parts within\"\n#endif\n\n#include <sys/isa_defs.h>\n#include <sys/types32.h>\n#include <sys/list.h>\n#include <sys/dmu.h>\n#include <sys/sa.h>\n#include <sys/time.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/rrwlock.h>\n#include <sys/zfs_sa.h>\n#include <sys/zfs_stat.h>\n#include <sys/zfs_rlock.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#if defined(HAVE_FILEMAP_RANGE_HAS_PAGE)\n#define\tZNODE_OS_FIELDS\t\t\t\\\n\tinode_timespec_t z_btime;   \\\n\tstruct inode\tz_inode;\n#else\n#define\tZNODE_OS_FIELDS\t\t\t\\\n\tinode_timespec_t z_btime;   \\\n\tstruct inode\tz_inode;                                     \\\n\tboolean_t\tz_is_mapped;     \n#endif\n\n \n#define\tZTOI(znode)\t(&((znode)->z_inode))\n#define\tITOZ(inode)\t(container_of((inode), znode_t, z_inode))\n#define\tZTOZSB(znode)\t((zfsvfs_t *)(ZTOI(znode)->i_sb->s_fs_info))\n#define\tITOZSB(inode)\t((zfsvfs_t *)((inode)->i_sb->s_fs_info))\n\n#define\tZTOTYPE(zp)\t(ZTOI(zp)->i_mode)\n#define\tZTOGID(zp) (ZTOI(zp)->i_gid)\n#define\tZTOUID(zp) (ZTOI(zp)->i_uid)\n#define\tZTONLNK(zp) (ZTOI(zp)->i_nlink)\n\n#define\tZ_ISBLK(type) S_ISBLK(type)\n#define\tZ_ISCHR(type) S_ISCHR(type)\n#define\tZ_ISLNK(type) S_ISLNK(type)\n#define\tZ_ISDEV(type)\t(S_ISCHR(type) || S_ISBLK(type) || S_ISFIFO(type))\n#define\tZ_ISDIR(type)\tS_ISDIR(type)\n\n#if defined(HAVE_FILEMAP_RANGE_HAS_PAGE)\n#define\tzn_has_cached_data(zp, start, end) \\\n\tfilemap_range_has_page(ZTOI(zp)->i_mapping, start, end)\n#else\n#define\tzn_has_cached_data(zp, start, end) \\\n\t((zp)->z_is_mapped)\n#endif\n\n#define\tzn_flush_cached_data(zp, sync)\twrite_inode_now(ZTOI(zp), sync)\n#define\tzn_rlimit_fsize(size)\t\t(0)\n#define\tzn_rlimit_fsize_uio(zp, uio)\t(0)\n\n \n#define\tzhold(zp)\tVERIFY3P(igrab(ZTOI((zp))), !=, NULL)\n#define\tzrele(zp)\tiput(ZTOI((zp)))\n\n \nstatic inline int\nzfs_enter(zfsvfs_t *zfsvfs, const char *tag)\n{\n\tZFS_TEARDOWN_ENTER_READ(zfsvfs, tag);\n\tif (unlikely(zfsvfs->z_unmounted)) {\n\t\tZFS_TEARDOWN_EXIT_READ(zfsvfs, tag);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\treturn (0);\n}\n\n \nstatic inline void\nzfs_exit(zfsvfs_t *zfsvfs, const char *tag)\n{\n\tzfs_exit_fs(zfsvfs);\n\tZFS_TEARDOWN_EXIT_READ(zfsvfs, tag);\n}\n\nstatic inline int\nzpl_enter(zfsvfs_t *zfsvfs, const char *tag)\n{\n\treturn (-zfs_enter(zfsvfs, tag));\n}\n\nstatic inline void\nzpl_exit(zfsvfs_t *zfsvfs, const char *tag)\n{\n\tZFS_TEARDOWN_EXIT_READ(zfsvfs, tag);\n}\n\n \n#define\tzpl_verify_zp(zp)\t(-zfs_verify_zp(zp))\n#define\tzpl_enter_verify_zp(zfsvfs, zp, tag)\t\\\n\t(-zfs_enter_verify_zp(zfsvfs, zp, tag))\n\n \n#define\tZFS_OBJ_MTX_SZ\t\t64\n#define\tZFS_OBJ_MTX_MAX\t\t(1024 * 1024)\n#define\tZFS_OBJ_HASH(zfsvfs, obj)\t((obj) & ((zfsvfs->z_hold_size) - 1))\n\nextern unsigned int zfs_object_mutex_size;\n\n \n#define\tZFS_TIME_ENCODE(tp, stmp)\t\t\\\ndo {\t\t\t\t\t\t\\\n\t(stmp)[0] = (uint64_t)(tp)->tv_sec;\t\\\n\t(stmp)[1] = (uint64_t)(tp)->tv_nsec;\t\\\n} while (0)\n\n#if defined(HAVE_INODE_TIMESPEC64_TIMES)\n \n#define\tZFS_TIME_DECODE(tp, stmp)\t\t\\\ndo {\t\t\t\t\t\t\\\n\t(tp)->tv_sec = (time64_t)(stmp)[0];\t\\\n\t(tp)->tv_nsec = (long)(stmp)[1];\t\\\n} while (0)\n#else\n \n#define\tZFS_TIME_DECODE(tp, stmp)\t\t\\\ndo {\t\t\t\t\t\t\\\n\t(tp)->tv_sec = (time_t)(stmp)[0];\t\\\n\t(tp)->tv_nsec = (long)(stmp)[1];\t\\\n} while (0)\n#endif  \n\n#define\tZFS_ACCESSTIME_STAMP(zfsvfs, zp)\n\nstruct znode;\n\nextern int\tzfs_sync(struct super_block *, int, cred_t *);\nextern int\tzfs_inode_alloc(struct super_block *, struct inode **ip);\nextern void\tzfs_inode_destroy(struct inode *);\nextern void\tzfs_mark_inode_dirty(struct inode *);\nextern boolean_t zfs_relatime_need_update(const struct inode *);\n\n#if defined(HAVE_UIO_RW)\nextern caddr_t zfs_map_page(page_t *, enum seg_rw);\nextern void zfs_unmap_page(page_t *, caddr_t);\n#endif  \n\nextern zil_replay_func_t *const zfs_replay_vector[TX_MAX_TYPE];\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}