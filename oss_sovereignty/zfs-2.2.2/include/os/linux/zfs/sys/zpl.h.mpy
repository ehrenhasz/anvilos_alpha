{
  "module_name": "zpl.h",
  "hash_id": "6ba7d1aa2d0de83686b9ef7613f49f3a0d9284b50d837da696acc01d92ad4b53",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/linux/zfs/sys/zpl.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_ZPL_H\n#define\t_SYS_ZPL_H\n\n#include <sys/mntent.h>\n#include <sys/vfs.h>\n#include <linux/aio.h>\n#include <linux/dcache_compat.h>\n#include <linux/exportfs.h>\n#include <linux/falloc.h>\n#include <linux/parser.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs_compat.h>\n#include <linux/writeback.h>\n#include <linux/xattr_compat.h>\n\n \nextern void zpl_vap_init(vattr_t *vap, struct inode *dir,\n    umode_t mode, cred_t *cr, zidmap_t *mnt_ns);\n\nextern const struct inode_operations zpl_inode_operations;\n#ifdef HAVE_RENAME2_OPERATIONS_WRAPPER\nextern const struct inode_operations_wrapper zpl_dir_inode_operations;\n#else\nextern const struct inode_operations zpl_dir_inode_operations;\n#endif\nextern const struct inode_operations zpl_symlink_inode_operations;\nextern const struct inode_operations zpl_special_inode_operations;\n\n \nextern const struct address_space_operations zpl_address_space_operations;\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\nextern const struct file_operations_extend zpl_file_operations;\n#else\nextern const struct file_operations zpl_file_operations;\n#endif\nextern const struct file_operations zpl_dir_file_operations;\n\n \nextern void zpl_prune_sb(uint64_t nr_to_scan, void *arg);\n\nextern const struct super_operations zpl_super_operations;\nextern const struct export_operations zpl_export_operations;\nextern struct file_system_type zpl_fs_type;\n\n \nextern ssize_t zpl_xattr_list(struct dentry *dentry, char *buf, size_t size);\nextern int zpl_xattr_security_init(struct inode *ip, struct inode *dip,\n    const struct qstr *qstr);\n#if defined(CONFIG_FS_POSIX_ACL)\n#if defined(HAVE_SET_ACL)\n#if defined(HAVE_SET_ACL_IDMAP_DENTRY)\nextern int zpl_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,\n    struct posix_acl *acl, int type);\n#elif defined(HAVE_SET_ACL_USERNS)\nextern int zpl_set_acl(struct user_namespace *userns, struct inode *ip,\n    struct posix_acl *acl, int type);\n#elif defined(HAVE_SET_ACL_USERNS_DENTRY_ARG2)\nextern int zpl_set_acl(struct user_namespace *userns, struct dentry *dentry,\n    struct posix_acl *acl, int type);\n#else\nextern int zpl_set_acl(struct inode *ip, struct posix_acl *acl, int type);\n#endif  \n#endif  \n#if defined(HAVE_GET_ACL_RCU) || defined(HAVE_GET_INODE_ACL)\nextern struct posix_acl *zpl_get_acl(struct inode *ip, int type, bool rcu);\n#elif defined(HAVE_GET_ACL)\nextern struct posix_acl *zpl_get_acl(struct inode *ip, int type);\n#endif\nextern int zpl_init_acl(struct inode *ip, struct inode *dir);\nextern int zpl_chmod_acl(struct inode *ip);\n#else\nstatic inline int\nzpl_init_acl(struct inode *ip, struct inode *dir)\n{\n\treturn (0);\n}\n\nstatic inline int\nzpl_chmod_acl(struct inode *ip)\n{\n\treturn (0);\n}\n#endif  \n\nextern xattr_handler_t *zpl_xattr_handlers[];\n\n \nextern const struct file_operations zpl_fops_root;\nextern const struct inode_operations zpl_ops_root;\n\nextern const struct file_operations zpl_fops_snapdir;\nextern const struct inode_operations zpl_ops_snapdir;\n\nextern const struct file_operations zpl_fops_shares;\nextern const struct inode_operations zpl_ops_shares;\n\n#if defined(HAVE_VFS_ITERATE) || defined(HAVE_VFS_ITERATE_SHARED)\n\n#define\tZPL_DIR_CONTEXT_INIT(_dirent, _actor, _pos) {\t\\\n\t.actor = _actor,\t\t\t\t\\\n\t.pos = _pos,\t\t\t\t\t\\\n}\n\ntypedef struct dir_context zpl_dir_context_t;\n\n#define\tzpl_dir_emit\t\tdir_emit\n#define\tzpl_dir_emit_dot\tdir_emit_dot\n#define\tzpl_dir_emit_dotdot\tdir_emit_dotdot\n#define\tzpl_dir_emit_dots\tdir_emit_dots\n\n#else\n\ntypedef struct zpl_dir_context {\n\tvoid *dirent;\n\tconst filldir_t actor;\n\tloff_t pos;\n} zpl_dir_context_t;\n\n#define\tZPL_DIR_CONTEXT_INIT(_dirent, _actor, _pos) {\t\\\n\t.dirent = _dirent,\t\t\t\t\\\n\t.actor = _actor,\t\t\t\t\\\n\t.pos = _pos,\t\t\t\t\t\\\n}\n\nstatic inline bool\nzpl_dir_emit(zpl_dir_context_t *ctx, const char *name, int namelen,\n    uint64_t ino, unsigned type)\n{\n\treturn (!ctx->actor(ctx->dirent, name, namelen, ctx->pos, ino, type));\n}\n\nstatic inline bool\nzpl_dir_emit_dot(struct file *file, zpl_dir_context_t *ctx)\n{\n\treturn (ctx->actor(ctx->dirent, \".\", 1, ctx->pos,\n\t    file_inode(file)->i_ino, DT_DIR) == 0);\n}\n\nstatic inline bool\nzpl_dir_emit_dotdot(struct file *file, zpl_dir_context_t *ctx)\n{\n\treturn (ctx->actor(ctx->dirent, \"..\", 2, ctx->pos,\n\t    parent_ino(file_dentry(file)), DT_DIR) == 0);\n}\n\nstatic inline bool\nzpl_dir_emit_dots(struct file *file, zpl_dir_context_t *ctx)\n{\n\tif (ctx->pos == 0) {\n\t\tif (!zpl_dir_emit_dot(file, ctx))\n\t\t\treturn (false);\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!zpl_dir_emit_dotdot(file, ctx))\n\t\t\treturn (false);\n\t\tctx->pos = 2;\n\t}\n\treturn (true);\n}\n#endif  \n\n\n \n\n \nextern ssize_t zpl_copy_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, size_t len, unsigned int flags);\nextern loff_t zpl_remap_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, loff_t len, unsigned int flags);\nextern int zpl_clone_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, uint64_t len);\nextern int zpl_dedupe_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, uint64_t len);\n\n \ntypedef struct {\n\tint64_t\t\tfcr_src_fd;\n\tuint64_t\tfcr_src_offset;\n\tuint64_t\tfcr_src_length;\n\tuint64_t\tfcr_dest_offset;\n} zfs_ioc_compat_file_clone_range_t;\n\ntypedef struct {\n\tint64_t\t\tfdri_dest_fd;\n\tuint64_t\tfdri_dest_offset;\n\tuint64_t\tfdri_bytes_deduped;\n\tint32_t\t\tfdri_status;\n\tuint32_t\tfdri_reserved;\n} zfs_ioc_compat_dedupe_range_info_t;\n\ntypedef struct {\n\tuint64_t\tfdr_src_offset;\n\tuint64_t\tfdr_src_length;\n\tuint16_t\tfdr_dest_count;\n\tuint16_t\tfdr_reserved1;\n\tuint32_t\tfdr_reserved2;\n\tzfs_ioc_compat_dedupe_range_info_t\tfdr_info[];\n} zfs_ioc_compat_dedupe_range_t;\n\n#define\tZFS_IOC_COMPAT_FICLONE\t\t_IOW(0x94, 9, int)\n#define\tZFS_IOC_COMPAT_FICLONERANGE \\\n    _IOW(0x94, 13, zfs_ioc_compat_file_clone_range_t)\n#define\tZFS_IOC_COMPAT_FIDEDUPERANGE \\\n    _IOWR(0x94, 54, zfs_ioc_compat_dedupe_range_t)\n\nextern long zpl_ioctl_ficlone(struct file *filp, void *arg);\nextern long zpl_ioctl_ficlonerange(struct file *filp, void *arg);\nextern long zpl_ioctl_fideduperange(struct file *filp, void *arg);\n\n\n#if defined(HAVE_INODE_TIMESTAMP_TRUNCATE)\n#define\tzpl_inode_timestamp_truncate(ts, ip)\ttimestamp_truncate(ts, ip)\n#elif defined(HAVE_INODE_TIMESPEC64_TIMES)\n#define\tzpl_inode_timestamp_truncate(ts, ip)\t\\\n\ttimespec64_trunc(ts, (ip)->i_sb->s_time_gran)\n#else\n#define\tzpl_inode_timestamp_truncate(ts, ip)\t\\\n\ttimespec_trunc(ts, (ip)->i_sb->s_time_gran)\n#endif\n\n#if defined(HAVE_INODE_OWNER_OR_CAPABLE)\n#define\tzpl_inode_owner_or_capable(ns, ip)\tinode_owner_or_capable(ip)\n#elif defined(HAVE_INODE_OWNER_OR_CAPABLE_USERNS)\n#define\tzpl_inode_owner_or_capable(ns, ip)\tinode_owner_or_capable(ns, ip)\n#elif defined(HAVE_INODE_OWNER_OR_CAPABLE_IDMAP)\n#define\tzpl_inode_owner_or_capable(idmap, ip) inode_owner_or_capable(idmap, ip)\n#else\n#error \"Unsupported kernel\"\n#endif\n\n#if defined(HAVE_SETATTR_PREPARE_USERNS) || defined(HAVE_SETATTR_PREPARE_IDMAP)\n#define\tzpl_setattr_prepare(ns, dentry, ia)\tsetattr_prepare(ns, dentry, ia)\n#else\n \n#define\tzpl_setattr_prepare(ns, dentry, ia)\tsetattr_prepare(dentry, ia)\n#endif\n\n#ifdef HAVE_INODE_GET_CTIME\n#define\tzpl_inode_get_ctime(ip)\tinode_get_ctime(ip)\n#else\n#define\tzpl_inode_get_ctime(ip)\t(ip->i_ctime)\n#endif\n#ifdef HAVE_INODE_SET_CTIME_TO_TS\n#define\tzpl_inode_set_ctime_to_ts(ip, ts)\tinode_set_ctime_to_ts(ip, ts)\n#else\n#define\tzpl_inode_set_ctime_to_ts(ip, ts)\t(ip->i_ctime = ts)\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}