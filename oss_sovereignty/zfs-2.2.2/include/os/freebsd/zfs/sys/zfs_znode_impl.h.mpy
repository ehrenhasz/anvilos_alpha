{
  "module_name": "zfs_znode_impl.h",
  "hash_id": "d465a4b18fcafb5ed28224469689b319f283d40afc4cbd34844570d1244d6131",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/zfs/sys/zfs_znode_impl.h",
  "human_readable_source": " \n \n\n#ifndef\t_FREEBSD_ZFS_SYS_ZNODE_IMPL_H\n#define\t_FREEBSD_ZFS_SYS_ZNODE_IMPL_H\n\n#include <sys/list.h>\n#include <sys/dmu.h>\n#include <sys/sa.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/rrwlock.h>\n#include <sys/zfs_sa.h>\n#include <sys/zfs_stat.h>\n#include <sys/zfs_rlock.h>\n#include <sys/zfs_acl.h>\n#include <sys/zil.h>\n#include <sys/zfs_project.h>\n#include <vm/vm_object.h>\n#include <sys/uio.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n#define\tZNODE_OS_FIELDS                 \\\n\tstruct zfsvfs\t*z_zfsvfs;      \\\n\tvnode_t\t\t*z_vnode;       \\\n\tchar\t\t*z_cached_symlink;\t\\\n\tuint64_t\t\tz_uid;          \\\n\tuint64_t\t\tz_gid;          \\\n\tuint64_t\t\tz_gen;          \\\n\tuint64_t\t\tz_atime[2];     \\\n\tuint64_t\t\tz_links;\n\n#define\tZFS_LINK_MAX\tUINT64_MAX\n\n \nenum zfs_soft_state_type {\n\tZSST_ZVOL,\n\tZSST_CTLDEV\n};\n\ntypedef struct zfs_soft_state {\n\tenum zfs_soft_state_type zss_type;\n\tvoid *zss_data;\n} zfs_soft_state_t;\n\n \n\n \n#define\tZTOV(ZP)\t((ZP)->z_vnode)\n#define\tZTOI(ZP)\t((ZP)->z_vnode)\n#define\tVTOZ(VP)\t((struct znode *)(VP)->v_data)\n#define\tVTOZ_SMR(VP)\t((znode_t *)vn_load_v_data_smr(VP))\n#define\tITOZ(VP)\t((struct znode *)(VP)->v_data)\n#define\tzhold(zp)\tvhold(ZTOV((zp)))\n#define\tzrele(zp)\tvrele(ZTOV((zp)))\n\n#define\tZTOZSB(zp) ((zp)->z_zfsvfs)\n#define\tITOZSB(vp) (VTOZ(vp)->z_zfsvfs)\n#define\tZTOTYPE(zp)\t(ZTOV(zp)->v_type)\n#define\tZTOGID(zp) ((zp)->z_gid)\n#define\tZTOUID(zp) ((zp)->z_uid)\n#define\tZTONLNK(zp) ((zp)->z_links)\n#define\tZ_ISBLK(type) ((type) == VBLK)\n#define\tZ_ISCHR(type) ((type) == VCHR)\n#define\tZ_ISLNK(type) ((type) == VLNK)\n#define\tZ_ISDIR(type) ((type) == VDIR)\n\n#define\tzn_has_cached_data(zp, start, end) \\\n    vn_has_cached_data(ZTOV(zp))\n#define\tzn_flush_cached_data(zp, sync)\tvn_flush_cached_data(ZTOV(zp), sync)\n#define\tzn_rlimit_fsize(size)\t\tzfs_rlimit_fsize(size)\n#define\tzn_rlimit_fsize_uio(zp, uio) \\\n    vn_rlimit_fsize(ZTOV(zp), GET_UIO_STRUCT(uio), zfs_uio_td(uio))\n\n \nstatic inline int\nzfs_enter(zfsvfs_t *zfsvfs, const char *tag)\n{\n\tZFS_TEARDOWN_ENTER_READ(zfsvfs, tag);\n\tif (__predict_false((zfsvfs)->z_unmounted)) {\n\t\tZFS_TEARDOWN_EXIT_READ(zfsvfs, tag);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\treturn (0);\n}\n\n \nstatic inline void\nzfs_exit(zfsvfs_t *zfsvfs, const char *tag)\n{\n\tZFS_TEARDOWN_EXIT_READ(zfsvfs, tag);\n}\n\n \n#define\tZFS_OBJ_HASH(obj_num)\t((obj_num) & (ZFS_OBJ_MTX_SZ - 1))\n#define\tZFS_OBJ_MUTEX(zfsvfs, obj_num)\t\\\n\t(&(zfsvfs)->z_hold_mtx[ZFS_OBJ_HASH(obj_num)])\n#define\tZFS_OBJ_HOLD_ENTER(zfsvfs, obj_num) \\\n\tmutex_enter(ZFS_OBJ_MUTEX((zfsvfs), (obj_num)))\n#define\tZFS_OBJ_HOLD_TRYENTER(zfsvfs, obj_num) \\\n\tmutex_tryenter(ZFS_OBJ_MUTEX((zfsvfs), (obj_num)))\n#define\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num) \\\n\tmutex_exit(ZFS_OBJ_MUTEX((zfsvfs), (obj_num)))\n\n \n#define\tZFS_TIME_ENCODE(tp, stmp)\t\t\\\n{\t\t\t\t\t\t\\\n\t(stmp)[0] = (uint64_t)(tp)->tv_sec;\t\\\n\t(stmp)[1] = (uint64_t)(tp)->tv_nsec;\t\\\n}\n\n \n#define\tZFS_TIME_DECODE(tp, stmp)\t\t\\\n{\t\t\t\t\t\t\\\n\t(tp)->tv_sec = (time_t)(stmp)[0];\t\t\\\n\t(tp)->tv_nsec = (long)(stmp)[1];\t\t\\\n}\n#define\tZFS_ACCESSTIME_STAMP(zfsvfs, zp) \\\n\tif ((zfsvfs)->z_atime && !((zfsvfs)->z_vfs->vfs_flag & VFS_RDONLY)) \\\n\t\tzfs_tstamp_update_setup_ext(zp, ACCESSED, NULL, NULL, B_FALSE);\n\nextern void\tzfs_tstamp_update_setup_ext(struct znode *,\n    uint_t, uint64_t [2], uint64_t [2], boolean_t have_tx);\nextern void zfs_znode_free(struct znode *);\n\nextern zil_replay_func_t *const zfs_replay_vector[TX_MAX_TYPE];\n\nextern int zfs_znode_parent_and_name(struct znode *zp, struct znode **dzpp,\n    char *buf);\n\nextern int zfs_rlimit_fsize(off_t fsize);\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}