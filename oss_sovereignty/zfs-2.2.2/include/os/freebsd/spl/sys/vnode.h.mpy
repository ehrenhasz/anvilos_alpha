{
  "module_name": "vnode.h",
  "hash_id": "ef72076fb0ef2ded9ce6ebe687f576ebc1abc5c33b4d7179fcd32dddb31388e1",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/spl/sys/vnode.h",
  "human_readable_source": " \n\n#ifndef _OPENSOLARIS_SYS_VNODE_H_\n#define\t_OPENSOLARIS_SYS_VNODE_H_\n\nstruct vnode;\nstruct vattr;\nstruct xucred;\n\ntypedef struct flock\tflock64_t;\ntypedef\tstruct vnode\tvnode_t;\ntypedef\tstruct vattr\tvattr_t;\n#if __FreeBSD_version < 1400093\ntypedef enum vtype vtype_t;\n#else\n#define\tvtype_t __enum_uint8(vtype)\n#endif\n\n#include <sys/types.h>\n#include <sys/queue.h>\n#include_next <sys/sdt.h>\n#include <sys/namei.h>\nenum symfollow { NO_FOLLOW = NOFOLLOW };\n\n#define\tNOCRED\t((struct ucred *)0)\t \n#define\tF_FREESP\t11 \t \n\n#include <sys/proc.h>\n#include <sys/vnode_impl.h>\n#ifndef IN_BASE\n#include_next <sys/vnode.h>\n#endif\n#include <sys/ccompat.h>\n#include <sys/mount.h>\n#include <sys/cred.h>\n#include <sys/fcntl.h>\n#include <sys/refcount.h>\n#include <sys/file.h>\n#include <sys/filedesc.h>\n#include <sys/syscallsubr.h>\n#include <sys/vm.h>\n#include <vm/vm_object.h>\n\ntypedef\tstruct vop_vector\tvnodeops_t;\n#define\tVOP_FID\t\tVOP_VPTOFH\n#define\tvop_fid\t\tvop_vptofh\n#define\tvop_fid_args\tvop_vptofh_args\n#define\ta_fid\t\ta_fhp\n\n#define\trootvfs\t\t(rootvnode == NULL ? NULL : rootvnode->v_mount)\n\n#ifndef IN_BASE\nstatic __inline int\nvn_is_readonly(vnode_t *vp)\n{\n\treturn (vp->v_mount->mnt_flag & MNT_RDONLY);\n}\n#endif\n#define\tvn_vfswlock(vp)\t\t(0)\n#define\tvn_vfsunlock(vp)\tdo { } while (0)\n#define\tvn_ismntpt(vp)\t   \\\n\t((vp)->v_type == VDIR && (vp)->v_mountedhere != NULL)\n#define\tvn_mountedvfs(vp)\t((vp)->v_mountedhere)\n#define\tvn_has_cached_data(vp)\t\\\n\t((vp)->v_object != NULL && \\\n\t(vp)->v_object->resident_page_count > 0)\n\n#ifndef IN_BASE\nstatic __inline void\nvn_flush_cached_data(vnode_t *vp, boolean_t sync)\n{\n#if __FreeBSD_version > 1300054\n\tif (vm_object_mightbedirty(vp->v_object)) {\n#else\n\tif (vp->v_object->flags & OBJ_MIGHTBEDIRTY) {\n#endif\n\t\tint flags = sync ? OBJPC_SYNC : 0;\n\t\tvn_lock(vp, LK_SHARED | LK_RETRY);\n\t\tzfs_vmobject_wlock(vp->v_object);\n\t\tvm_object_page_clean(vp->v_object, 0, 0, flags);\n\t\tzfs_vmobject_wunlock(vp->v_object);\n\t\tVOP_UNLOCK1(vp);\n\t}\n}\n#endif\n\n#define\tvn_exists(vp)\t\tdo { } while (0)\n#define\tvn_invalid(vp)\t\tdo { } while (0)\n#define\tvn_free(vp)\t\tdo { } while (0)\n#define\tvn_matchops(vp, vops)\t((vp)->v_op == &(vops))\n\n#define\tVN_HOLD(v)\tvref(v)\n#define\tVN_RELE(v)\tvrele(v)\n#define\tVN_URELE(v)\tvput(v)\n\n#define\tvnevent_create(vp, ct)\t\t\tdo { } while (0)\n#define\tvnevent_link(vp, ct)\t\t\tdo { } while (0)\n#define\tvnevent_remove(vp, dvp, name, ct)\tdo { } while (0)\n#define\tvnevent_rmdir(vp, dvp, name, ct)\tdo { } while (0)\n#define\tvnevent_rename_src(vp, dvp, name, ct)\tdo { } while (0)\n#define\tvnevent_rename_dest(vp, dvp, name, ct)\tdo { } while (0)\n#define\tvnevent_rename_dest_dir(vp, ct)\t\tdo { } while (0)\n\n#define\tspecvp(vp, rdev, type, cr)\t(VN_HOLD(vp), (vp))\n#define\tMANDLOCK(vp, mode)\t(0)\n\n \n#define\tva_mask\t\tva_spare\n \n#define\tva_nodeid\tva_fileid\n \n#define\tva_nblocks\tva_bytes\n#define\tva_blksize\tva_blocksize\n\n#define\tMAXOFFSET_T\tOFF_MAX\n\n#define\tFIGNORECASE\t0x00\n\n \n\n#undef AT_UID\n#undef AT_GID\n\n#define\tAT_MODE\t\t0x00002\n#define\tAT_UID\t\t0x00004\n#define\tAT_GID\t\t0x00008\n#define\tAT_FSID\t\t0x00010\n#define\tAT_NODEID\t0x00020\n#define\tAT_NLINK\t0x00040\n#define\tAT_SIZE\t\t0x00080\n#define\tAT_ATIME\t0x00100\n#define\tAT_MTIME\t0x00200\n#define\tAT_CTIME\t0x00400\n#define\tAT_RDEV\t\t0x00800\n#define\tAT_BLKSIZE\t0x01000\n#define\tAT_NBLOCKS\t0x02000\n \t \n#define\tAT_SEQ\t\t0x08000\n \n#define\tAT_XVATTR\t0x10000\n\n#define\tAT_ALL\t\t(AT_MODE|AT_UID|AT_GID|AT_FSID|AT_NODEID|\\\n\t\t\tAT_NLINK|AT_SIZE|AT_ATIME|AT_MTIME|AT_CTIME|\\\n\t\t\tAT_RDEV|AT_BLKSIZE|AT_NBLOCKS|AT_SEQ)\n\n#define\tAT_STAT\t\t(AT_MODE|AT_UID|AT_GID|AT_FSID|AT_NODEID|AT_NLINK|\\\n\t\t\tAT_SIZE|AT_ATIME|AT_MTIME|AT_CTIME|AT_RDEV)\n\n#define\tAT_TIMES\t(AT_ATIME|AT_MTIME|AT_CTIME)\n\n#define\tAT_NOSET\t(AT_NLINK|AT_RDEV|AT_FSID|AT_NODEID|\\\n\t\t\tAT_BLKSIZE|AT_NBLOCKS|AT_SEQ)\n\n#ifndef IN_BASE\nstatic __inline void\nvattr_init_mask(vattr_t *vap)\n{\n\n\tvap->va_mask = 0;\n\n\tif (vap->va_uid != (uid_t)VNOVAL)\n\t\tvap->va_mask |= AT_UID;\n\tif (vap->va_gid != (gid_t)VNOVAL)\n\t\tvap->va_mask |= AT_GID;\n\tif (vap->va_size != (u_quad_t)VNOVAL)\n\t\tvap->va_mask |= AT_SIZE;\n\tif (vap->va_atime.tv_sec != VNOVAL)\n\t\tvap->va_mask |= AT_ATIME;\n\tif (vap->va_mtime.tv_sec != VNOVAL)\n\t\tvap->va_mask |= AT_MTIME;\n\tif (vap->va_mode != (uint16_t)VNOVAL)\n\t\tvap->va_mask |= AT_MODE;\n\tif (vap->va_flags != VNOVAL)\n\t\tvap->va_mask |= AT_XVATTR;\n}\n#endif\n\n#define\t\tRLIM64_INFINITY 0\n\n#include <sys/vfs.h>\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}