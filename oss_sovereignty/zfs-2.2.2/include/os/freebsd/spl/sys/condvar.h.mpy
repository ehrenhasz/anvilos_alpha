{
  "module_name": "condvar.h",
  "hash_id": "cc921a99ba7ec8cf412cd2b5ce5cd6d52f2e300e5fd56273e5935f741fb41675",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/spl/sys/condvar.h",
  "human_readable_source": " \n\n#ifndef _OPENSOLARIS_SYS_CONDVAR_H_\n#define\t_OPENSOLARIS_SYS_CONDVAR_H_\n\n#include <sys/param.h>\n#include <sys/systm.h>\n\n#include <sys/spl_condvar.h>\n#include <sys/mutex.h>\n#include <sys/time.h>\n#include <sys/errno.h>\n\n \n\nstatic __inline sbintime_t\nzfs_nstosbt(int64_t _ns)\n{\n\tsbintime_t sb = 0;\n\n#ifdef KASSERT\n\tKASSERT(_ns >= 0, (\"Negative values illegal for nstosbt: %jd\", _ns));\n#endif\n\tif (_ns >= SBT_1S) {\n\t\tsb = (_ns / 1000000000) * SBT_1S;\n\t\t_ns = _ns % 1000000000;\n\t}\n\t \n\tsb += ((_ns * 9223372037ull) + 0x7fffffff) >> 31;\n\treturn (sb);\n}\n\n\ntypedef struct cv\tkcondvar_t;\n#define\tCALLOUT_FLAG_ABSOLUTE C_ABSOLUTE\n\ntypedef enum {\n\tCV_DEFAULT,\n\tCV_DRIVER\n} kcv_type_t;\n\n#define\tzfs_cv_init(cv, name, type, arg)\tdo {\t\t\t\\\n\tconst char *_name;\t\t\t\t\t\t\\\n\tASSERT((type) == CV_DEFAULT);\t\t\t\t\t\\\n\tfor (_name = #cv; *_name != '\\0'; _name++) {\t\t\t\\\n\t\tif (*_name >= 'a' && *_name <= 'z')\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (*_name == '\\0')\t\t\t\t\t\t\\\n\t\t_name = #cv;\t\t\t\t\t\t\\\n\tcv_init((cv), _name);\t\t\t\t\t\t\\\n} while (0)\n#define\tcv_init(cv, name, type, arg)\tzfs_cv_init(cv, name, type, arg)\n\n\nstatic inline int\ncv_wait_sig(kcondvar_t *cvp, kmutex_t *mp)\n{\n\n\treturn (_cv_wait_sig(cvp, &(mp)->lock_object) == 0);\n}\n\nstatic inline int\ncv_timedwait(kcondvar_t *cvp, kmutex_t *mp, clock_t timo)\n{\n\tint rc;\n\n\ttimo -= ddi_get_lbolt();\n\tif (timo <= 0)\n\t\treturn (-1);\n\trc = _cv_timedwait_sbt((cvp), &(mp)->lock_object, \\\n\t    tick_sbt * (timo), 0, C_HARDCLOCK);\n\tif (rc == EWOULDBLOCK)\n\t\treturn (-1);\n\treturn (1);\n}\n\nstatic inline int\ncv_timedwait_sig(kcondvar_t *cvp, kmutex_t *mp, clock_t timo)\n{\n\tint rc;\n\n\ttimo -= ddi_get_lbolt();\n\tif (timo <= 0)\n\t\treturn (-1);\n\trc = _cv_timedwait_sig_sbt(cvp, &(mp)->lock_object, \\\n\t    tick_sbt * (timo), 0, C_HARDCLOCK);\n\tif (rc == EWOULDBLOCK)\n\t\treturn (-1);\n\tif (rc == EINTR || rc == ERESTART)\n\t\treturn (0);\n\n\treturn (1);\n}\n\n#define\tcv_timedwait_io\t\tcv_timedwait\n#define\tcv_timedwait_idle\tcv_timedwait\n#define\tcv_timedwait_sig_io\tcv_timedwait_sig\n#define\tcv_wait_io\t\tcv_wait\n#define\tcv_wait_io_sig\t\tcv_wait_sig\n#define\tcv_wait_idle\t\tcv_wait\n#define\tcv_timedwait_io_hires\tcv_timedwait_hires\n#define\tcv_timedwait_idle_hires cv_timedwait_hires\n\nstatic inline int\ncv_timedwait_hires(kcondvar_t *cvp, kmutex_t *mp, hrtime_t tim, hrtime_t res,\n    int flag)\n{\n\thrtime_t hrtime;\n\tint rc;\n\n\tASSERT(tim >= res);\n\n\thrtime = gethrtime();\n\tif (flag == 0)\n\t\ttim += hrtime;\n\n\tif (hrtime >= tim)\n\t\treturn (-1);\n\trc = cv_timedwait_sbt(cvp, mp, zfs_nstosbt(tim),\n\t    zfs_nstosbt(res), C_ABSOLUTE);\n\n\tif (rc == EWOULDBLOCK)\n\t\treturn (-1);\n\n\tKASSERT(rc == 0, (\"unexpected rc value %d\", rc));\n\treturn (1);\n}\n\nstatic inline int\ncv_timedwait_sig_hires(kcondvar_t *cvp, kmutex_t *mp, hrtime_t tim,\n    hrtime_t res, int flag)\n{\n\tsbintime_t sbt;\n\thrtime_t hrtime;\n\tint rc;\n\n\tASSERT(tim >= res);\n\n\thrtime = gethrtime();\n\tif (flag == 0)\n\t\ttim += hrtime;\n\n\tif (hrtime >= tim)\n\t\treturn (-1);\n\n\tsbt = zfs_nstosbt(tim);\n\trc = cv_timedwait_sig_sbt(cvp, mp, sbt, zfs_nstosbt(res), C_ABSOLUTE);\n\n\tswitch (rc) {\n\tcase EWOULDBLOCK:\n\t\treturn (-1);\n\tcase EINTR:\n\tcase ERESTART:\n\t\treturn (0);\n\tdefault:\n\t\tKASSERT(rc == 0, (\"unexpected rc value %d\", rc));\n\t\treturn (1);\n\t}\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}