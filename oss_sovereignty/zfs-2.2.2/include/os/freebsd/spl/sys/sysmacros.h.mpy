{
  "module_name": "sysmacros.h",
  "hash_id": "d9a84d8c24aa665deb5c720a5efaed450a5e51b645d5d0e1ffa90914baa8cdb5",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/spl/sys/sysmacros.h",
  "human_readable_source": " \n \n \n\n\n \n\n#ifndef _SYS_SYSMACROS_H\n#define\t_SYS_SYSMACROS_H\n\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/isa_defs.h>\n#include <sys/libkern.h>\n#include <sys/zone.h>\n#include <sys/condvar.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n \n#define\tdtob(DD)\t((DD) << DEV_BSHIFT)\n#define\tbtod(BB)\t(((BB) + DEV_BSIZE - 1) >> DEV_BSHIFT)\n#define\tbtodt(BB)\t((BB) >> DEV_BSHIFT)\n#define\tlbtod(BB)\t(((offset_t)(BB) + DEV_BSIZE - 1) >> DEV_BSHIFT)\n\n \n#ifndef MIN\n#define\tMIN(a, b)\t((a) < (b) ? (a) : (b))\n#endif\n#ifndef MAX\n#define\tMAX(a, b)\t((a) < (b) ? (b) : (a))\n#endif\n#ifndef ABS\n#define\tABS(a)\t\t((a) < 0 ? -(a) : (a))\n#endif\n#ifndef\tSIGNOF\n#define\tSIGNOF(a)\t((a) < 0 ? -1 : (a) > 0)\n#endif\n#ifndef\tARRAY_SIZE\n#define\tARRAY_SIZE(a) (sizeof (a) / sizeof (a[0]))\n#endif\n#ifndef\tDIV_ROUND_UP\n#define\tDIV_ROUND_UP(n, d)\t(((n) + (d) - 1) / (d))\n#endif\n\n#ifdef _STANDALONE\n#define\tboot_ncpus 1\n#else  \n#define\tboot_ncpus mp_ncpus\n#endif  \n#define\tkpreempt_disable() critical_enter()\n#define\tkpreempt_enable() critical_exit()\n#define\tCPU_SEQID curcpu\n#define\tCPU_SEQID_UNSTABLE curcpu\n#define\tis_system_labeled()\t\t0\n \nextern unsigned char byte_to_bcd[256];\nextern unsigned char bcd_to_byte[256];\n\n#define\tBYTE_TO_BCD(x)\tbyte_to_bcd[(x) & 0xff]\n#define\tBCD_TO_BYTE(x)\tbcd_to_byte[(x) & 0xff]\n\n \n\n#define\tO_BITSMAJOR\t7\t \n#define\tO_BITSMINOR\t8\t \n#define\tO_MAXMAJ\t0x7f\t \n#define\tO_MAXMIN\t0xff\t \n\n\n#define\tL_BITSMAJOR32\t14\t \n#define\tL_BITSMINOR32\t18\t \n#define\tL_MAXMAJ32\t0x3fff\t \n#define\tL_MAXMIN32\t0x3ffff\t \n\t\t\t\t \n\t\t\t\t \n\n#ifdef _LP64\n#define\tL_BITSMAJOR\t32\t \n#define\tL_BITSMINOR\t32\t \n#define\tL_MAXMAJ\t0xfffffffful\t \n#define\tL_MAXMIN\t0xfffffffful\t \n#else\n#define\tL_BITSMAJOR\tL_BITSMAJOR32\n#define\tL_BITSMINOR\tL_BITSMINOR32\n#define\tL_MAXMAJ\tL_MAXMAJ32\n#define\tL_MAXMIN\tL_MAXMIN32\n#endif\n\n \n#if (L_BITSMAJOR32 == L_BITSMAJOR) && (L_BITSMINOR32 == L_BITSMINOR)\n\n#define\tDEVCMPL(x)\t(x)\n#define\tDEVEXPL(x)\t(x)\n\n#else\n\n#define\tDEVCMPL(x)\t\\\n\t(dev32_t)((((x) >> L_BITSMINOR) > L_MAXMAJ32 || \\\n\t    ((x) & L_MAXMIN) > L_MAXMIN32) ? NODEV32 : \\\n\t    ((((x) >> L_BITSMINOR) << L_BITSMINOR32) | ((x) & L_MAXMIN32)))\n\n#define\tDEVEXPL(x)\t\\\n\t(((x) == NODEV32) ? NODEV : \\\n\tmakedevice(((x) >> L_BITSMINOR32) & L_MAXMAJ32, (x) & L_MAXMIN32))\n\n#endif  \n\n \n\n#define\tcmpdev(x) \\\n\t(o_dev_t)((((x) >> L_BITSMINOR) > O_MAXMAJ || \\\n\t    ((x) & L_MAXMIN) > O_MAXMIN) ? NODEV : \\\n\t    ((((x) >> L_BITSMINOR) << O_BITSMINOR) | ((x) & O_MAXMIN)))\n\n \n\n#define\texpdev(x) \\\n\t(dev_t)(((dev_t)(((x) >> O_BITSMINOR) & O_MAXMAJ) << L_BITSMINOR) | \\\n\t    ((x) & O_MAXMIN))\n\n \n#define\tIS_P2ALIGNED(v, a) ((((uintptr_t)(v)) & ((uintptr_t)(a) - 1)) == 0)\n\n \n#define\thowmany(x, y)\t(((x)+((y)-1))/(y))\n#define\troundup(x, y)\t((((x)+((y)-1))/(y))*(y))\n\n \n#define\tISP2(x)\t\t(((x) & ((x) - 1)) == 0)\n\n \n\n \n#define\tP2ALIGN(x, align)\t\t((x) & -(align))\n\n \n#define\tP2PHASE(x, align)\t\t((x) & ((align) - 1))\n\n \n#define\tP2NPHASE(x, align)\t\t(-(x) & ((align) - 1))\n\n \n#define\tP2ROUNDUP(x, align)\t\t(-(-(x) & -(align)))\n\n \n#define\tP2END(x, align)\t\t\t(-(~(x) & -(align)))\n\n \n#define\tP2PHASEUP(x, align, phase)\t((phase) - (((phase) - (x)) & -(align)))\n\n \n#define\tP2BOUNDARY(off, len, align) \\\n\t(((off) ^ ((off) + (len) - 1)) > (align) - 1)\n\n \n#define\tP2SAMEHIGHBIT(x, y)\t\t(((x) ^ (y)) < ((x) & (y)))\n\n \n#define\tP2ALIGN_TYPED(x, align, type)\t\\\n\t((type)(x) & -(type)(align))\n#define\tP2PHASE_TYPED(x, align, type)\t\\\n\t((type)(x) & ((type)(align) - 1))\n#define\tP2NPHASE_TYPED(x, align, type)\t\\\n\t(-(type)(x) & ((type)(align) - 1))\n#define\tP2ROUNDUP_TYPED(x, align, type)\t\\\n\t(-(-(type)(x) & -(type)(align)))\n#define\tP2END_TYPED(x, align, type)\t\\\n\t(-(~(type)(x) & -(type)(align)))\n#define\tP2PHASEUP_TYPED(x, align, phase, type)\t\\\n\t((type)(phase) - (((type)(phase) - (type)(x)) & -(type)(align)))\n#define\tP2CROSS_TYPED(x, y, align, type)\t\\\n\t(((type)(x) ^ (type)(y)) > (type)(align) - 1)\n#define\tP2SAMEHIGHBIT_TYPED(x, y, type) \\\n\t(((type)(x) ^ (type)(y)) < ((type)(x) & (type)(y)))\n\n \n#define\tINCR_COUNT(var, mutex) mutex_enter(mutex), (*(var))++, mutex_exit(mutex)\n#define\tDECR_COUNT(var, mutex) mutex_enter(mutex), (*(var))--, mutex_exit(mutex)\n\n#if !defined(_KMEMUSER) && !defined(offsetof)\n\n \n\n#define\toffsetof(type, field)\t__offsetof(type, field)\n#endif\n\n \nstatic __inline int\nhighbit(ulong_t i)\n{\n#if defined(HAVE_INLINE_FLSL)\n\treturn (flsl(i));\n#else\n\tint h = 1;\n\n\tif (i == 0)\n\t\treturn (0);\n#ifdef _LP64\n\tif (i & 0xffffffff00000000ul) {\n\t\th += 32; i >>= 32;\n\t}\n#endif\n\tif (i & 0xffff0000) {\n\t\th += 16; i >>= 16;\n\t}\n\tif (i & 0xff00) {\n\t\th += 8; i >>= 8;\n\t}\n\tif (i & 0xf0) {\n\t\th += 4; i >>= 4;\n\t}\n\tif (i & 0xc) {\n\t\th += 2; i >>= 2;\n\t}\n\tif (i & 0x2) {\n\t\th += 1;\n\t}\n\treturn (h);\n#endif\n}\n\n \nstatic __inline int\nhighbit64(uint64_t i)\n{\n#if defined(HAVE_INLINE_FLSLL)\n\treturn (flsll(i));\n#else\n\tint h = 1;\n\n\tif (i == 0)\n\t\treturn (0);\n\tif (i & 0xffffffff00000000ULL) {\n\t\th += 32; i >>= 32;\n\t}\n\tif (i & 0xffff0000) {\n\t\th += 16; i >>= 16;\n\t}\n\tif (i & 0xff00) {\n\t\th += 8; i >>= 8;\n\t}\n\tif (i & 0xf0) {\n\t\th += 4; i >>= 4;\n\t}\n\tif (i & 0xc) {\n\t\th += 2; i >>= 2;\n\t}\n\tif (i & 0x2) {\n\t\th += 1;\n\t}\n\treturn (h);\n#endif\n}\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}