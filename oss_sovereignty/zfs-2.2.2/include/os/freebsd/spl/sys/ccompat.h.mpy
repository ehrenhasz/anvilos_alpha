{
  "module_name": "ccompat.h",
  "hash_id": "a955df0bb6102fc75646baa08e9c2b44af9a043f57c56c7fa4a87a7df467b8f1",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/spl/sys/ccompat.h",
  "human_readable_source": " \n\n#ifndef\t_SYS_CCOMPAT_H\n#define\t_SYS_CCOMPAT_H\n\n#if  __FreeBSD_version < 1300051\n#define\tvm_page_valid(m) (m)->valid = VM_PAGE_BITS_ALL\n#define\tvm_page_do_sunbusy(m)\n#define\tvm_page_none_valid(m) ((m)->valid == 0)\n#else\n#define\tvm_page_do_sunbusy(m) vm_page_sunbusy(m)\n#endif\n\n#if  __FreeBSD_version < 1300074\n#define\tVOP_UNLOCK1(x)\tVOP_UNLOCK(x, 0)\n#else\n#define\tVOP_UNLOCK1(x)\tVOP_UNLOCK(x)\n#endif\n\n#if  __FreeBSD_version < 1300064\n#define\tVN_IS_DOOMED(vp)\t((vp)->v_iflag & VI_DOOMED)\n#endif\n\n#if  __FreeBSD_version < 1300068\n#define\tVFS_VOP_VECTOR_REGISTER(x)\n#endif\n\n#if  __FreeBSD_version >= 1300076\n#define\tgetnewvnode_reserve_()\tgetnewvnode_reserve()\n#else\n#define\tgetnewvnode_reserve_()\tgetnewvnode_reserve(1)\n#endif\n\n#if  __FreeBSD_version < 1300102\n#define\tASSERT_VOP_IN_SEQC(zp)\n#define\tMNTK_FPLOOKUP 0\n#define\tvn_seqc_write_begin(vp)\n#define\tvn_seqc_write_end(vp)\n\n#ifndef VFS_SMR_DECLARE\n#define\tVFS_SMR_DECLARE\n#endif\n#ifndef VFS_SMR_ZONE_SET\n#define\tVFS_SMR_ZONE_SET(zone)\n#endif\n#endif\n\nstruct hlist_node {\n\tstruct hlist_node *next, **pprev;\n};\n\nstruct hlist_head {\n\tstruct hlist_node *first;\n};\n\ntypedef struct {\n\tvolatile int counter;\n} atomic_t;\n\n#define\thlist_for_each(p, head)                                      \\\n\tfor (p = (head)->first; p; p = (p)->next)\n\n#define\thlist_entry(ptr, type, field)   container_of(ptr, type, field)\n\n#define\tcontainer_of(ptr, type, member)                         \\\n                                                    \\\n({                                                              \\\n\tconst __typeof(((type *)0)->member) *__p = (ptr);       \\\n\t(type *)((uintptr_t)__p - offsetof(type, member));      \\\n})\n\nstatic inline void\nhlist_add_head(struct hlist_node *n, struct hlist_head *h)\n{\n\tn->next = h->first;\n\tif (h->first != NULL)\n\t\th->first->pprev = &n->next;\n\tWRITE_ONCE(h->first, n);\n\tn->pprev = &h->first;\n}\n\nstatic inline void\nhlist_del(struct hlist_node *n)\n{\n\tWRITE_ONCE(*(n->pprev), n->next);\n\tif (n->next != NULL)\n\t\tn->next->pprev = n->pprev;\n}\n\t \n#define\tREAD_ONCE(x) ({\t\t\t\\\n\t__typeof(x) __var = ({\t\t\\\n\t\tbarrier();\t\t\\\n\t\tACCESS_ONCE(x);\t\t\\\n\t});\t\t\t\t\\\n\tbarrier();\t\t\t\\\n\t__var;\t\t\t\t\\\n})\n\n#define\tHLIST_HEAD_INIT { }\n#define\tHLIST_HEAD(name) struct hlist_head name = HLIST_HEAD_INIT\n#define\tINIT_HLIST_HEAD(head) (head)->first = NULL\n\n#define\tINIT_HLIST_NODE(node)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(node)->next = NULL;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(node)->pprev = NULL;\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n \nstatic inline int\natomic_read(const atomic_t *v)\n{\n\treturn (READ_ONCE(v->counter));\n}\n\nstatic inline int\natomic_inc(atomic_t *v)\n{\n\treturn (atomic_fetchadd_int(&v->counter, 1) + 1);\n}\n\nstatic inline int\natomic_dec(atomic_t *v)\n{\n\treturn (atomic_fetchadd_int(&v->counter, -1) - 1);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}