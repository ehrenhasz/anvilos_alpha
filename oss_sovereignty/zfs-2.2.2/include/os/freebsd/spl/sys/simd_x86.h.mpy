{
  "module_name": "simd_x86.h",
  "hash_id": "9358b939d01dca8841f429120e2f8d68a79e2dc84a80e43b1c99f8eb3f7272d4",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/spl/sys/simd_x86.h",
  "human_readable_source": " \n\n#include <sys/types.h>\n#include <sys/cdefs.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n\n#include <machine/pcb.h>\n#include <x86/x86_var.h>\n#include <x86/specialreg.h>\n\n#define\tkfpu_init()\t\t(0)\n#define\tkfpu_fini()\t\tdo {} while (0)\n#define\tkfpu_allowed()\t\t1\n#define\tkfpu_initialize(tsk)\tdo {} while (0)\n\n#define\tkfpu_begin() {\t\t\t\t\t\\\n\tif (__predict_false(!is_fpu_kern_thread(0)))\t\t\\\n\t\tfpu_kern_enter(curthread, NULL, FPU_KERN_NOCTX);\\\n}\n\n#ifndef PCB_FPUNOSAVE\n#define\tPCB_FPUNOSAVE\tPCB_NPXNOSAVE\n#endif\n\n#define\tkfpu_end()\t{\t\t\t\\\n\tif (__predict_false(curpcb->pcb_flags & PCB_FPUNOSAVE))\t\\\n\t\tfpu_kern_leave(curthread, NULL);\t\\\n}\n\n \nstatic inline uint64_t\nxgetbv(uint32_t index)\n{\n\tuint32_t eax, edx;\n\t \n\t__asm__ __volatile__(\".byte 0x0f; .byte 0x01; .byte 0xd0\"\n\t    : \"=a\" (eax), \"=d\" (edx)\n\t    : \"c\" (index));\n\n\treturn ((((uint64_t)edx)<<32) | (uint64_t)eax);\n}\n\n\n \nstatic inline boolean_t\n__simd_state_enabled(const uint64_t state)\n{\n\tboolean_t has_osxsave;\n\tuint64_t xcr0;\n\n\thas_osxsave = (cpu_feature2 & CPUID2_OSXSAVE) != 0;\n\n\tif (!has_osxsave)\n\t\treturn (B_FALSE);\n\n\txcr0 = xgetbv(0);\n\treturn ((xcr0 & state) == state);\n}\n\n#define\t_XSTATE_SSE_AVX\t\t(0x2 | 0x4)\n#define\t_XSTATE_AVX512\t\t(0xE0 | _XSTATE_SSE_AVX)\n\n#define\t__ymm_enabled() __simd_state_enabled(_XSTATE_SSE_AVX)\n#define\t__zmm_enabled() __simd_state_enabled(_XSTATE_AVX512)\n\n\n \nstatic inline boolean_t\nzfs_sse_available(void)\n{\n\treturn ((cpu_feature & CPUID_SSE) != 0);\n}\n\n \nstatic inline boolean_t\nzfs_sse2_available(void)\n{\n\treturn ((cpu_feature & CPUID_SSE2) != 0);\n}\n\n \nstatic inline boolean_t\nzfs_sse3_available(void)\n{\n\treturn ((cpu_feature2 & CPUID2_SSE3) != 0);\n}\n\n \nstatic inline boolean_t\nzfs_ssse3_available(void)\n{\n\treturn ((cpu_feature2 & CPUID2_SSSE3) != 0);\n}\n\n \nstatic inline boolean_t\nzfs_sse4_1_available(void)\n{\n\treturn ((cpu_feature2 & CPUID2_SSE41) != 0);\n}\n\n \nstatic inline boolean_t\nzfs_sse4_2_available(void)\n{\n\treturn ((cpu_feature2 & CPUID2_SSE42) != 0);\n}\n\n \nstatic inline boolean_t\nzfs_avx_available(void)\n{\n\tboolean_t has_avx;\n\n\thas_avx = (cpu_feature2 & CPUID2_AVX) != 0;\n\n\treturn (has_avx && __ymm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx2_available(void)\n{\n\tboolean_t has_avx2;\n\n\thas_avx2 = (cpu_stdext_feature & CPUID_STDEXT_AVX2) != 0;\n\n\treturn (has_avx2 && __ymm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_shani_available(void)\n{\n\tboolean_t has_shani;\n\n\thas_shani = (cpu_stdext_feature & CPUID_STDEXT_SHA) != 0;\n\n\treturn (has_shani && __ymm_enabled());\n}\n\n \n\n\n \nstatic inline boolean_t\nzfs_avx512f_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512cd_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_AVX512CD) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512er_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_AVX512CD) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512pf_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_AVX512PF) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512bw_available(void)\n{\n\tboolean_t has_avx512 = B_FALSE;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512BW) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512dq_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_AVX512DQ) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512vl_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_AVX512VL) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512ifma_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_AVX512IFMA) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n\n \nstatic inline boolean_t\nzfs_avx512vbmi_available(void)\n{\n\tboolean_t has_avx512;\n\n\thas_avx512 = (cpu_stdext_feature & CPUID_STDEXT_AVX512F) != 0 &&\n\t    (cpu_stdext_feature & CPUID_STDEXT_BMI1) != 0;\n\n\treturn (has_avx512 && __zmm_enabled());\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}