{
  "module_name": "callb.h",
  "hash_id": "163eba3faa4a778107d83d105cd5b5b2f43d275e20d2f09fc1bc67a388edbb4d",
  "original_prompt": "Ingested from zfs-2.2.2/include/os/freebsd/spl/sys/callb.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_CALLB_H\n#define\t_SYS_CALLB_H\n\n#include <sys/condvar.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n#define\tCB_CL_CPR_DAEMON\t0\n#define\tCB_CL_CPR_VM\t\t1\n#define\tCB_CL_CPR_CALLOUT\t2\n#define\tCB_CL_CPR_OBP\t\t3\n#define\tCB_CL_CPR_FB\t\t4\n#define\tCB_CL_PANIC\t\t5\n#define\tCB_CL_CPR_RPC\t\t6\n#define\tCB_CL_CPR_PROMPRINTF\t7\n#define\tCB_CL_UADMIN\t\t8\n#define\tCB_CL_CPR_PM\t\t9\n#define\tCB_CL_HALT\t\t10\n#define\tCB_CL_CPR_DMA\t\t11\n#define\tCB_CL_CPR_POST_USER\t12\n#define\tCB_CL_UADMIN_PRE_VFS    13\n#define\tCB_CL_MDBOOT\t\tCB_CL_UADMIN\n#define\tCB_CL_ENTER_DEBUGGER\t14\n#define\tCB_CL_CPR_POST_KERNEL\t15\n#define\tCB_CL_CPU_DEEP_IDLE\t16\n#define\tNCBCLASS\t\t17  \n\n \n\n \n#define\tCB_CODE_CPR_CHKPT\t0\n#define\tCB_CODE_CPR_RESUME\t1\n\ntypedef\tvoid *\t\tcallb_id_t;\n \ntypedef struct callb_cpr {\n\tkmutex_t\t*cc_lockp;\t \n\tchar\t\tcc_events;\t \n\tcallb_id_t\tcc_id;\t\t \n\tkcondvar_t\tcc_callb_cv;\t \n\tkcondvar_t\tcc_stop_cv;\t \n} callb_cpr_t;\n\n \n#define\tCALLB_CPR_START\t\t1\t \n#define\tCALLB_CPR_SAFE\t\t2\t \n#define\tCALLB_CPR_ALWAYS_SAFE\t4\t \n\n \n#define\tCALLB_MAX_RETRY\t\t3\t \n#define\tCALLB_THREAD_DELAY\t10\t \n#define\tCPR_KTHREAD_TIMEOUT_SEC\t90\t \n\t\t\t\t\t \n\t\t\t\t\t \n\n \n#define\tCALLB_CPR_INIT(cp, lockp, func, name)\t{\t\t\t\\\n\t\tstrlcpy(curthread->td_name, (name),\t\t\t\\\n\t\t    sizeof (curthread->td_name));\t\t\t\\\n\t\tmemset(cp, 0, sizeof (callb_cpr_t));\t\t\\\n\t\t(cp)->cc_lockp = lockp;\t\t\t\t\t\\\n\t\t(cp)->cc_id = callb_add(func, (void *)(cp),\t\t\\\n\t\t\tCB_CL_CPR_DAEMON, name);\t\t\t\\\n\t\tcv_init(&(cp)->cc_callb_cv, NULL, CV_DEFAULT, NULL);\t\\\n\t\tcv_init(&(cp)->cc_stop_cv, NULL, CV_DEFAULT, NULL);\t\\\n\t}\n\n#ifndef __lock_lint\n#define\tCALLB_CPR_ASSERT(cp)\tASSERT(MUTEX_HELD((cp)->cc_lockp));\n#else\n#define\tCALLB_CPR_ASSERT(cp)\n#endif\n \n#define\tCALLB_CPR_INIT_SAFE(t, name) {\t\t\t\t\t\\\n\t\t(void) callb_add_thread(callb_generic_cpr_safe,\t\t\\\n\t\t(void *) &callb_cprinfo_safe, CB_CL_CPR_DAEMON,\t\t\\\n\t\t    name, t);\t\t\t\t\t\t\\\n\t}\n \n#define\tCALLB_CPR_SAFE_BEGIN(cp) { \t\t\t\\\n\t\tCALLB_CPR_ASSERT(cp)\t\t\t\\\n\t\t(cp)->cc_events |= CALLB_CPR_SAFE;\t\\\n\t\tif ((cp)->cc_events & CALLB_CPR_START)\t\\\n\t\t\tcv_signal(&(cp)->cc_callb_cv);\t\\\n\t}\n#define\tCALLB_CPR_SAFE_END(cp, lockp) {\t\t\t\t\\\n\t\tCALLB_CPR_ASSERT(cp)\t\t\t\t\\\n\t\twhile ((cp)->cc_events & CALLB_CPR_START)\t\\\n\t\t\tcv_wait(&(cp)->cc_stop_cv, lockp);\t\\\n\t\t(cp)->cc_events &= ~CALLB_CPR_SAFE;\t\t\\\n\t}\n \n#define\tCALLB_CPR_EXIT(cp) {\t\t\t\t\\\n\t\tCALLB_CPR_ASSERT(cp)\t\t\t\\\n\t\t(cp)->cc_events |= CALLB_CPR_SAFE;\t\\\n\t\tif ((cp)->cc_events & CALLB_CPR_START)\t\\\n\t\t\tcv_signal(&(cp)->cc_callb_cv);\t\\\n\t\tmutex_exit((cp)->cc_lockp);\t\t\\\n\t\t(void) callb_delete((cp)->cc_id);\t\\\n\t\tcv_destroy(&(cp)->cc_callb_cv);\t\t\\\n\t\tcv_destroy(&(cp)->cc_stop_cv);\t\t\\\n\t}\n\nextern callb_cpr_t callb_cprinfo_safe;\nextern callb_id_t callb_add(boolean_t  (*)(void *, int), void *, int, char *);\nextern callb_id_t callb_add_thread(boolean_t (*)(void *, int),\n    void *, int, char *, kthread_id_t);\nextern int\tcallb_delete(callb_id_t);\nextern void\tcallb_execute(callb_id_t, int);\nextern void\t*callb_execute_class(int, int);\nextern boolean_t callb_generic_cpr(void *, int);\nextern boolean_t callb_generic_cpr_safe(void *, int);\nextern boolean_t callb_is_stopped(kthread_id_t, caddr_t *);\nextern void\tcallb_lock_table(void);\nextern void\tcallb_unlock_table(void);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}