{
  "module_name": "zfs-functions.in",
  "hash_id": "d01f8de3b8c6590c338cd18fb1bd41cb4ba6ce8b77204faa9217be98331915b3",
  "original_prompt": "Ingested from zfs-2.2.2/etc/zfs/zfs-functions.in",
  "human_readable_source": "# This is a script with common functions etc used by zfs-import, zfs-load-key,\n# zfs-mount, zfs-share and zfs-zed.\n#\n# It is _NOT_ to be called independently\n#\n# Released under the 2-clause BSD license.\n#\n# This script is based on debian/zfsutils.zfs.init from the\n# Debian GNU/kFreeBSD zfsutils 8.1-3 package, written by Aurelien Jarno.\n\nPATH=/sbin:/bin:/usr/bin:/usr/sbin\n\n# Source function library\nif [ -f /etc/rc.d/init.d/functions ]; then\n\t# RedHat and derivatives\n\t. /etc/rc.d/init.d/functions\nelif [ -L /etc/init.d/functions.sh ]; then\n\t# Gentoo\n\t. /etc/init.d/functions.sh\nelif [ -f /lib/lsb/init-functions ]; then\n\t# LSB, Debian, and derivatives\n\t. /lib/lsb/init-functions\nfi\n\n# Of course the functions we need are called differently\n# on different distributions - it would be way too easy\n# otherwise!!\nif type log_failure_msg > /dev/null 2>&1 ; then\n\t# LSB functions - fall through\n\tzfs_log_begin_msg() { log_begin_msg \"$1\"; }\n\tzfs_log_end_msg() { log_end_msg \"$1\"; }\n\tzfs_log_failure_msg() { log_failure_msg \"$1\"; }\n\tzfs_log_progress_msg() { log_progress_msg \"$1\"; }\nelif type success > /dev/null 2>&1 ; then\n\t# Fedora/RedHat functions\n\tzfs_set_ifs() {\n\t\t# For some reason, the init function library have a problem\n\t\t# with a changed IFS, so this function goes around that.\n\t\tlocal tIFS=\"$1\"\n\t\tif [ -n \"$tIFS\" ]\n\t\tthen\n\t\t\tTMP_IFS=\"$IFS\"\n\t\t\tIFS=\"$tIFS\"\n\t\tfi\n\t}\n\n\tzfs_log_begin_msg() { printf \"%s\" \"$1 \"; }\n\tzfs_log_end_msg() {\n\t\t# shellcheck disable=SC2154\n\t\tzfs_set_ifs \"$OLD_IFS\"\n\t\tif [ \"$1\" -eq 0 ]; then\n\t\t\tsuccess\n\t\telse\n\t\t\tfailure\n\t\tfi\n\t\techo\n\t\tzfs_set_ifs \"$TMP_IFS\"\n\t}\n\tzfs_log_failure_msg() {\n\t\tzfs_set_ifs \"$OLD_IFS\"\n\t\tfailure\n\t\techo\n\t\tzfs_set_ifs \"$TMP_IFS\"\n\t}\n\tzfs_log_progress_msg() { printf \"%s\" \"$\"\"$1\"; }\nelif type einfo > /dev/null 2>&1 ; then\n\t# Gentoo functions\n\tzfs_log_begin_msg() { ebegin \"$1\"; }\n\tzfs_log_end_msg() { eend \"$1\"; }\n\tzfs_log_failure_msg() { eend \"$1\"; }\n#\tzfs_log_progress_msg() { printf \"%s\" \"$1\"; }\n\tzfs_log_progress_msg() { :; }\nelse\n\t# Unknown - simple substitutes.\n\tzfs_log_begin_msg() { printf \"%s\" \"$1\"; }\n\tzfs_log_end_msg() {\n\t\tret=$1\n\t\tif [ \"$ret\" -ge 1 ]; then\n\t\t\techo \" failed!\"\n\t\telse\n\t\t\techo \" success\"\n\t\tfi\n\t\treturn \"$ret\"\n\t}\n\tzfs_log_failure_msg() { echo \"$1\"; }\n\tzfs_log_progress_msg() { printf \"%s\" \"$1\"; }\nfi\n\n# Paths to what we need\nZFS=\"@sbindir@/zfs\"\nZED=\"@sbindir@/zed\"\nZPOOL=\"@sbindir@/zpool\"\nZPOOL_CACHE=\"@sysconfdir@/zfs/zpool.cache\"\n\n# Sensible defaults\nZFS_LOAD_KEY='yes'\nZFS_UNLOAD_KEY='no'\nZFS_MOUNT='yes'\nZFS_UNMOUNT='yes'\nZFS_SHARE='yes'\nZFS_UNSHARE='yes'\n\n# Source zfs configuration, overriding the defaults\nif [ -f @initconfdir@/zfs ]; then\n\t. @initconfdir@/zfs\nfi\n\n# ----------------------------------------------------\n\nexport ZFS ZED ZPOOL ZPOOL_CACHE ZFS_LOAD_KEY ZFS_UNLOAD_KEY ZFS_MOUNT ZFS_UNMOUNT \\\n    ZFS_SHARE ZFS_UNSHARE\n\nzfs_action()\n{\n\tlocal MSG=\"$1\";\tshift\n\tlocal CMD=\"$*\"\n\tlocal ret\n\n\tzfs_log_begin_msg \"$MSG \"\n\t$CMD\n\tret=$?\n\tif [ \"$ret\" -eq 0 ]; then\n\t\tzfs_log_end_msg \"$ret\"\n\telse\n\t\tzfs_log_failure_msg \"$ret\"\n\tfi\n\n\treturn \"$ret\"\n}\n\n# Returns\n#   0 if daemon has been started\n#   1 if daemon was already running\n#   2 if daemon could not be started\n#   3 if unsupported\n#\nzfs_daemon_start()\n{\n\tlocal PIDFILE=\"$1\";\tshift\n\tlocal DAEMON_BIN=\"$1\";\tshift\n\n\tif type start-stop-daemon > /dev/null 2>&1 ; then\n\t\t# LSB functions\n\t\tstart-stop-daemon --start --quiet --pidfile \"$PIDFILE\" \\\n\t\t    --exec \"$DAEMON_BIN\" --test > /dev/null || return 1\n\n\t\t# shellcheck disable=SC2086\n\t\tstart-stop-daemon --start --quiet --exec \"$DAEMON_BIN\" -- \\\n\t\t    \"$@\" || return 2\n\n\t\t# On Debian, there's a 'sendsigs' script that will\n\t\t# kill basically everything quite early and zed is stopped\n\t\t# much later than that. We don't want zed to be among them,\n\t\t# so add the zed pid to list of pids to ignore.\n\t\tif [ -f \"$PIDFILE\" ] && [ -d /run/sendsigs.omit.d ]\n\t\tthen\n\t\t\tln -sf \"$PIDFILE\" /run/sendsigs.omit.d/zed\n\t\tfi\n\telif type daemon > /dev/null 2>&1 ; then\n\t\t# Fedora/RedHat functions\n\t\t# shellcheck disable=SC2086\n\t\tdaemon --pidfile \"$PIDFILE\" \"$DAEMON_BIN\" \"$@\"\n\t\treturn $?\n\telse\n\t\t# Unsupported\n\t\treturn 3\n\tfi\n\n\treturn 0\n}\n\n# Returns\n#   0 if daemon has been stopped\n#   1 if daemon was already stopped\n#   2 if daemon could not be stopped\n#   3 if unsupported\n#\nzfs_daemon_stop()\n{\n\tlocal PIDFILE=\"$1\"\n\tlocal DAEMON_BIN=\"$2\"\n\tlocal DAEMON_NAME=\"$3\"\n\n\tif type start-stop-daemon > /dev/null 2>&1 ; then\n\t\t# LSB functions\n\t\tstart-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 \\\n\t\t    --pidfile \"$PIDFILE\" --name \"$DAEMON_NAME\"\n\t\tret=\"$?\"\n\t\t[ \"$ret\" = 0 ] && rm -f \"$PIDFILE\"\n\n\t\treturn \"$ret\"\n\telif type killproc > /dev/null 2>&1 ; then\n\t\t# Fedora/RedHat functions\n\t\tkillproc -p \"$PIDFILE\" \"$DAEMON_NAME\"\n\t\tret=\"$?\"\n\t\t[ \"$ret\" = 0 ] && rm -f \"$PIDFILE\"\n\n\t\treturn \"$ret\"\n\telse\n\t\t# Unsupported\n\t\treturn 3\n\tfi\n\n\treturn 0\n}\n\n# Returns status\nzfs_daemon_status()\n{\n\tlocal PIDFILE=\"$1\"\n\tlocal DAEMON_BIN=\"$2\"\n\tlocal DAEMON_NAME=\"$3\"\n\n\tif type status_of_proc > /dev/null 2>&1 ; then\n\t\t# LSB functions\n\t\tstatus_of_proc \"$DAEMON_NAME\" \"$DAEMON_BIN\"\n\t\treturn $?\n\telif type status > /dev/null 2>&1 ; then\n\t\t# Fedora/RedHat functions\n\t\tstatus -p \"$PIDFILE\" \"$DAEMON_NAME\"\n\t\treturn $?\n\telse\n\t\t# Unsupported\n\t\treturn 3\n\tfi\n\n\treturn 0\n}\n\nzfs_daemon_reload()\n{\n\tlocal PIDFILE=\"$1\"\n\tlocal DAEMON_NAME=\"$2\"\n\n\tif type start-stop-daemon > /dev/null 2>&1 ; then\n\t\t# LSB functions\n\t\tstart-stop-daemon --stop --signal 1 --quiet \\\n\t\t    --pidfile \"$PIDFILE\" --name \"$DAEMON_NAME\"\n\t\treturn $?\n\telif type killproc > /dev/null 2>&1 ; then\n\t\t# Fedora/RedHat functions\n\t\tkillproc -p \"$PIDFILE\" \"$DAEMON_NAME\" -HUP\n\t\treturn $?\n\telse\n\t\t# Unsupported\n\t\treturn 3\n\tfi\n\n\treturn 0\n}\n\nzfs_installed()\n{\n\tif [ ! -x \"$ZPOOL\" ]; then\n\t\treturn 1\n\telse\n\t\t# Test if it works (will catch missing/broken libs etc)\n\t\t\"$ZPOOL\" -? > /dev/null 2>&1\n\t\treturn $?\n\tfi\n\n\tif [ ! -x \"$ZFS\" ]; then\n\t\treturn 2\n\telse\n\t\t# Test if it works (will catch missing/broken libs etc)\n\t\t\"$ZFS\" -? > /dev/null 2>&1\n\t\treturn $?\n\tfi\n\n\treturn 0\n}\n\n# Trigger udev and wait for it to settle.\nudev_trigger()\n{\n\tif [ -x /sbin/udevadm ]; then\n\t\t/sbin/udevadm trigger --action=change --subsystem-match=block\n\t\t/sbin/udevadm settle\n\telif [ -x /sbin/udevsettle ]; then\n\t\t/sbin/udevtrigger\n\t\t/sbin/udevsettle\n\tfi\n}\n\n# Do a lot of checks to make sure it's 'safe' to continue with the import.\nchecksystem()\n{\n\tif grep -qiE '(^|[^\\\\](\\\\\\\\)* )zfs=(off|no|0)( |$)' /proc/cmdline;\n\tthen\n\t\t# Called with zfs=(off|no|0) - bail because we don't\n\t\t# want anything import, mounted or shared.\n\t\t# HOWEVER, only do this if we're called at the boot up\n\t\t# (from init), not if we're running interactively (as in\n\t\t# from the shell - we know what we're doing).\n\t\t# shellcheck disable=SC2154\n\t\t[ -n \"$init\" ] && exit 3\n\tfi\n\n\t# Check if ZFS is installed.\n\tzfs_installed || return 5\n\n\t# Just make sure that /dev/zfs is created.\n\tudev_trigger\n\n\treturn 0\n}\n\nget_root_pool()\n{\n\t# shellcheck disable=SC2046\n\tset -- $(mount | grep ' on / ')\n\t[ \"$5\" = \"zfs\" ] && echo \"${1%%/*}\"\n}\n\n# Check if a variable is 'yes' (any case) or '1'\n# Returns TRUE if set.\ncheck_boolean()\n{\n\tlocal var=\"$1\"\n\n\techo \"$var\" | grep -Eiq \"^yes$|^on$|^true$|^1$\" && return 0 || return 1\n}\n\ncheck_module_loaded()\n{\n\tmodule=\"$1\"\n\n\t[ -r \"/sys/module/${module}/version\" ] && return 0 || return 1\n}\n\nload_module()\n{\n\tmodule=\"$1\"\n\n\t# Load the zfs module stack\n\tif ! check_module_loaded \"$module\"; then\n\t\tif ! /sbin/modprobe \"$module\"; then\n\t\t\treturn 5\n\t\tfi\n\tfi\n\treturn 0\n}\n\n# first parameter is a regular expression that filters mtab\nread_mtab()\n{\n\tlocal match=\"$1\"\n\tlocal fs mntpnt fstype opts rest\n\n\t# Unset all MTAB_* variables\n\t# shellcheck disable=SC2046\n\tunset $(env | sed -e '/^MTAB_/!d' -e 's,=.*,,')\n\n\twhile read -r fs mntpnt fstype opts rest; do\n\t\tif echo \"$fs $mntpnt $fstype $opts\" | grep -qE \"$match\"; then\n\t\t\t# * Fix problems (!?) in the mounts file. It will record\n\t\t\t#   'rpool 1' as 'rpool\\0401' instead of 'rpool\\00401'\n\t\t\t#   which seems to be the correct (at least as far as\n\t\t\t#   'printf' is concerned).\n\t\t\t# * We need to use the external echo, because the\n\t\t\t#   internal one would interpret the backslash code\n\t\t\t#   (incorrectly), giving us a \u0001 instead.\n\t\t\tmntpnt=$(/bin/echo \"$mntpnt\" | sed 's,\\\\0,\\\\00,g')\n\t\t\tfs=$(/bin/echo \"$fs\" | sed 's,\\\\0,\\\\00,')\n\n\t\t\t# Remove 'unwanted' characters.\n\t\t\tmntpnt=$(printf '%b' \"$mntpnt\" | tr -d '/. -')\n\t\t\tfs=$(printf '%b' \"$fs\")\n\n\t\t\t# Set the variable.\n\t\t\teval export \"MTAB_$mntpnt=\\\"$fs\\\"\"\n\t\tfi\n\tdone < /proc/self/mounts\n}\n\nin_mtab()\n{\n\tlocal mntpnt=\"$1\"\n\t# Remove 'unwanted' characters.\n\tmntpnt=$(printf '%b' \"$mntpnt\" | tr -d '/. -')\n\tlocal var\n\n\tvar=\"$(eval echo \"MTAB_$mntpnt\")\"\n\t[ \"$(eval echo \"$\"\"$var\")\" != \"\" ]\n\treturn \"$?\"\n}\n\n# first parameter is a regular expression that filters fstab\nread_fstab()\n{\n\tlocal match=\"$1\"\n\tlocal i var\n\n\t# Unset all FSTAB_* variables\n\t# shellcheck disable=SC2046\n\tunset $(env | sed -e '/^FSTAB_/!d' -e 's,=.*,,')\n\n\ti=0\n\twhile read -r fs mntpnt fstype opts; do\n\t\techo \"$fs\" | grep -qE '^#|^$' && continue\n\t\techo \"$mntpnt\" | grep -qE '^none|^swap' && continue\n\t\techo \"$fstype\" | grep -qE '^swap' && continue\n\n\t\tif echo \"$fs $mntpnt $fstype $opts\" | grep -qE \"$match\"; then\n\t\t\teval export \"FSTAB_dev_$i=$fs\"\n\t\t\tfs=$(printf '%b' \"$fs\" | tr '/' '_')\n\t\t\teval export \"FSTAB_$i=$mntpnt\"\n\n\t\t\ti=$((i + 1))\n\t\tfi\n\tdone < /etc/fstab\n}\n\nin_fstab()\n{\n\tlocal var\n\n\tvar=\"$(eval echo \"FSTAB_$1\")\"\n\t[ \"${var}\" != \"\" ]\n\treturn $?\n}\n\nis_mounted()\n{\n\tlocal mntpt=\"$1\"\n\tlocal mp\n\n\twhile read -r _ mp _; do\n\t\t[ \"$mp\" = \"$mntpt\" ] && return 0\n\tdone < /proc/self/mounts\n\n\treturn 1\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}