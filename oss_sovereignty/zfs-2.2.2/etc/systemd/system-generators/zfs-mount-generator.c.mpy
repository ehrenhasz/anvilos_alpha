{
  "module_name": "zfs-mount-generator.c",
  "hash_id": "9f331c19397a51054f450a2d8724920dfc3330e95f80f859c4f96368e859d0cf",
  "original_prompt": "Ingested from zfs-2.2.2/etc/systemd/system-generators/zfs-mount-generator.c",
  "human_readable_source": " \n\n\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <time.h>\n#include <regex.h>\n#include <search.h>\n#include <dirent.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <libzfs.h>\n\n \n#define\tFREE_STATICS false\n\n#define\tnitems(arr) (sizeof (arr) / sizeof (*arr))\n#define\tSTRCMP ((int(*)(const void *, const void *))&strcmp)\n\n\n#define\tPROGNAME \"zfs-mount-generator\"\n#define\tFSLIST SYSCONFDIR \"/zfs/zfs-list.cache\"\n#define\tZFS SBINDIR \"/zfs\"\n\n#define\tOUTPUT_HEADER \\\n\t\"# Automatically generated by \" PROGNAME \"\\n\" \\\n\t\"\\n\"\n\n \n#define\tURI_REGEX_S \"^\\\\([A-Za-z][A-Za-z0-9+.\\\\-]*\\\\):\\\\/\\\\/\\\\(.*\\\\)$\"\nstatic regex_t uri_regex;\n\nstatic const char *destdir = \"/tmp\";\nstatic int destdir_fd = -1;\n\nstatic void *known_pools = NULL;  \nstatic void *noauto_files = NULL;  \n\n\nstatic char *\nsystemd_escape(const char *input, const char *prepend, const char *append)\n{\n\tsize_t len = strlen(input);\n\tsize_t applen = strlen(append);\n\tsize_t prelen = strlen(prepend);\n\tchar *ret = malloc(4 * len + prelen + applen + 1);\n\tif (!ret) {\n\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t    \"out of memory to escape \\\"%s%s%s\\\"!\\n\",\n\t\t    getpid(), prepend, input, append);\n\t\treturn (NULL);\n\t}\n\n\tmemcpy(ret, prepend, prelen);\n\tchar *out = ret + prelen;\n\n\tconst char *cur = input;\n\tif (*cur == '.') {\n\t\tmemcpy(out, \"\\\\x2e\", 4);\n\t\tout += 4;\n\t\t++cur;\n\t}\n\tfor (; *cur; ++cur) {\n\t\tif (*cur == '/')\n\t\t\t*(out++) = '-';\n\t\telse if (strchr(\n\t\t    \"0123456789\"\n\t\t    \"abcdefghijklmnopqrstuvwxyz\"\n\t\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t    \":_.\", *cur))\n\t\t\t*(out++) = *cur;\n\t\telse {\n\t\t\tsprintf(out, \"\\\\x%02x\", (int)*cur);\n\t\t\tout += 4;\n\t\t}\n\t}\n\n\tmemcpy(out, append, applen + 1);\n\treturn (ret);\n}\n\nstatic void\nsimplify_path(char *path)\n{\n\tchar *out = path;\n\tfor (char *cur = path; *cur; ++cur) {\n\t\tif (*cur == '/') {\n\t\t\twhile (*(cur + 1) == '/')\n\t\t\t\t++cur;\n\t\t\t*(out++) = '/';\n\t\t} else\n\t\t\t*(out++) = *cur;\n\t}\n\n\t*(out++) = '\\0';\n}\n\nstatic bool\nstrendswith(const char *what, const char *suff)\n{\n\tsize_t what_l = strlen(what);\n\tsize_t suff_l = strlen(suff);\n\n\treturn ((what_l >= suff_l) &&\n\t    (strcmp(what + what_l - suff_l, suff) == 0));\n}\n\n \nstatic char *\nsystemd_escape_path(char *input, const char *prepend, const char *append)\n{\n\tif (strcmp(input, \"/\") == 0) {\n\t\tchar *ret;\n\t\tif (asprintf(&ret, \"%s-%s\", prepend, append) == -1) {\n\t\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t\t    \"out of memory to escape \\\"%s%s%s\\\"!\\n\",\n\t\t\t    getpid(), prepend, input, append);\n\t\t\tret = NULL;\n\t\t}\n\t\treturn (ret);\n\t} else {\n\t\t \n\t\tif (strstr(input, \"/./\") || strstr(input, \"/../\") ||\n\t\t    strendswith(input, \"/.\") || strendswith(input, \"/..\"))\n\t\t\treturn (NULL);\n\n\n\t\tif (input[0] == '/')\n\t\t\t++input;\n\n\t\tchar *back = &input[strlen(input) - 1];\n\t\tbool deslash = *back == '/';\n\t\tif (deslash)\n\t\t\t*back = '\\0';\n\n\t\tchar *ret = systemd_escape(input, prepend, append);\n\n\t\tif (deslash)\n\t\t\t*back = '/';\n\t\treturn (ret);\n\t}\n}\n\nstatic FILE *\nfopenat(int dirfd, const char *pathname, int flags,\n    const char *stream_mode, mode_t mode)\n{\n\tint fd = openat(dirfd, pathname, flags, mode);\n\tif (fd < 0)\n\t\treturn (NULL);\n\n\treturn (fdopen(fd, stream_mode));\n}\n\nstatic int\nline_worker(char *line, const char *cachefile)\n{\n\tint ret = 0;\n\tvoid *tofree_all[8];\n\tvoid **tofree = tofree_all;\n\n\tchar *toktmp;\n\t \n\tconst char *dataset                     = strtok_r(line, \"\\t\", &toktmp);\n\t      char *p_mountpoint                = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_canmount                  = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_atime                     = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_relatime                  = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_devices                   = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_exec                      = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_readonly                  = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_setuid                    = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_nbmand                    = strtok_r(NULL, \"\\t\", &toktmp);\n\tconst char *p_encroot                   = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\t      char *p_keyloc                    = strtok_r(NULL, \"\\t\", &toktmp) ?: strdupa(\"none\");\n\tconst char *p_systemd_requires          = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\tconst char *p_systemd_requiresmountsfor = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\tconst char *p_systemd_before            = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\tconst char *p_systemd_after             = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\t      char *p_systemd_wantedby          = strtok_r(NULL, \"\\t\", &toktmp) ?: strdupa(\"-\");\n\t      char *p_systemd_requiredby        = strtok_r(NULL, \"\\t\", &toktmp) ?: strdupa(\"-\");\n\tconst char *p_systemd_nofail            = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\tconst char *p_systemd_ignore            = strtok_r(NULL, \"\\t\", &toktmp) ?: \"-\";\n\t \n\n\tsize_t pool_len = strlen(dataset);\n\tif ((toktmp = strchr(dataset, '/')) != NULL)\n\t\tpool_len = toktmp - dataset;\n\tconst char *pool = *(tofree++) = strndup(dataset, pool_len);\n\n\tif (p_nbmand == NULL) {\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: not enough tokens!\\n\",\n\t\t    getpid(), dataset);\n\t\tgoto err;\n\t}\n\n\t \n\tconst char *after = \"zfs-import.target\";\n\tconst char *wants = \"zfs-import.target\";\n\tconst char *bindsto = NULL;\n\tchar *wantedby = NULL;\n\tchar *requiredby = NULL;\n\tbool noauto = false;\n\tbool wantedby_append = true;\n\n\t \n\tif (tfind(pool, &known_pools, STRCMP)) {\n\t\tafter = \"\";\n\t\twants = \"\";\n\t}\n\n\tif (strcmp(p_systemd_after, \"-\") == 0)\n\t\tp_systemd_after = NULL;\n\tif (strcmp(p_systemd_before, \"-\") == 0)\n\t\tp_systemd_before = NULL;\n\tif (strcmp(p_systemd_requires, \"-\") == 0)\n\t\tp_systemd_requires = NULL;\n\tif (strcmp(p_systemd_requiresmountsfor, \"-\") == 0)\n\t\tp_systemd_requiresmountsfor = NULL;\n\n\n\tif (strcmp(p_encroot, \"-\") != 0) {\n\t\tchar *keyloadunit = *(tofree++) =\n\t\t    systemd_escape(p_encroot, \"zfs-load-key@\", \".service\");\n\t\tif (keyloadunit == NULL)\n\t\t\tgoto err;\n\n\t\tif (strcmp(dataset, p_encroot) == 0) {\n\t\t\tconst char *keymountdep = NULL;\n\t\t\tbool is_prompt = false;\n\t\t\tbool need_network = false;\n\n\t\t\tregmatch_t uri_matches[3];\n\t\t\tif (regexec(&uri_regex, p_keyloc,\n\t\t\t    nitems(uri_matches), uri_matches, 0) == 0) {\n\t\t\t\tp_keyloc[uri_matches[1].rm_eo] = '\\0';\n\t\t\t\tp_keyloc[uri_matches[2].rm_eo] = '\\0';\n\t\t\t\tconst char *scheme =\n\t\t\t\t    &p_keyloc[uri_matches[1].rm_so];\n\t\t\t\tconst char *path =\n\t\t\t\t    &p_keyloc[uri_matches[2].rm_so];\n\n\t\t\t\tif (strcmp(scheme, \"https\") == 0 ||\n\t\t\t\t    strcmp(scheme, \"http\") == 0)\n\t\t\t\t\tneed_network = true;\n\t\t\t\telse\n\t\t\t\t\tkeymountdep = path;\n\t\t\t} else {\n\t\t\t\tif (strcmp(p_keyloc, \"prompt\") != 0)\n\t\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t\t    \"unknown non-URI keylocation=%s\\n\",\n\t\t\t\t\t    getpid(), dataset, p_keyloc);\n\n\t\t\t\tis_prompt = true;\n\t\t\t}\n\n\n\t\t\t \n\t\t\tFILE *keyloadunit_f = fopenat(destdir_fd, keyloadunit,\n\t\t\t    O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, \"w\",\n\t\t\t    0644);\n\t\t\tif (!keyloadunit_f) {\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t    \"couldn't open %s under %s: %s\\n\",\n\t\t\t\t    getpid(), dataset, keyloadunit, destdir,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tfprintf(keyloadunit_f,\n\t\t\t    OUTPUT_HEADER\n\t\t\t    \"[Unit]\\n\"\n\t\t\t    \"Description=Load ZFS key for %s\\n\"\n\t\t\t    \"SourcePath=\" FSLIST \"/%s\\n\"\n\t\t\t    \"Documentation=man:zfs-mount-generator(8)\\n\"\n\t\t\t    \"DefaultDependencies=no\\n\"\n\t\t\t    \"Wants=%s\\n\"\n\t\t\t    \"After=%s\\n\",\n\t\t\t    dataset, cachefile, wants, after);\n\n\t\t\tif (need_network)\n\t\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t    \"Wants=network-online.target\\n\"\n\t\t\t\t    \"After=network-online.target\\n\");\n\n\t\t\tif (p_systemd_requires)\n\t\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t    \"Requires=%s\\n\", p_systemd_requires);\n\n\t\t\tif (p_systemd_requiresmountsfor)\n\t\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t    \"RequiresMountsFor=%s\\n\",\n\t\t\t\t    p_systemd_requiresmountsfor);\n\t\t\tif (keymountdep)\n\t\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t    \"RequiresMountsFor='%s'\\n\", keymountdep);\n\n\t\t\t \n\t\t\tfprintf(keyloadunit_f,\n\t\t\t    \"\\n\"\n\t\t\t    \"[Service]\\n\"\n\t\t\t    \"Type=oneshot\\n\"\n\t\t\t    \"RemainAfterExit=yes\\n\"\n\t\t\t    \"# This avoids a dependency loop involving systemd-journald.socket if this\\n\"\n\t\t\t    \"# dataset is a parent of the root filesystem.\\n\"\n\t\t\t    \"StandardOutput=null\\n\"\n\t\t\t    \"StandardError=null\\n\"\n\t\t\t    \"ExecStart=/bin/sh -euc '\"\n\t\t\t        \"[ \\\"$$(\" ZFS \" get -H -o value keystatus \\\"%s\\\")\\\" = \\\"unavailable\\\" ] || exit 0;\",\n\t\t\t    dataset);\n\t\t\tif (is_prompt)\n\t\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t    \"for i in 1 2 3; do \"\n\t\t\t\t        \"systemd-ask-password --id=\\\"zfs:%s\\\" \\\"Enter passphrase for %s:\\\" |\"\n\t\t\t\t        \"\" ZFS \" load-key \\\"%s\\\" && exit 0;\"\n\t\t\t\t    \"done;\"\n\t\t\t\t    \"exit 1\",\n\t\t\t\t    dataset, dataset, dataset);\n\t\t\telse\n\t\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t    \"exec \" ZFS \" load-key \\\"%s\\\"\",\n\t\t\t\t    dataset);\n\n\t\t\tfprintf(keyloadunit_f,\n\t\t\t\t\"'\\n\"\n\t\t\t\t\"ExecStop=/bin/sh -euc '\"\n\t\t\t\t    \"[ \\\"$$(\" ZFS \" get -H -o value keystatus \\\"%s\\\")\\\" = \\\"available\\\" ] || exit 0;\"\n\t\t\t\t    \"exec \" ZFS \" unload-key \\\"%s\\\"\"\n\t\t\t\t\"'\\n\",\n\t\t\t\tdataset, dataset);\n\t\t\t \n\n\t\t\t(void) fclose(keyloadunit_f);\n\t\t}\n\n\t\t \n\t\tbindsto = keyloadunit;\n\t\tif (after[0] == '\\0')\n\t\t\tafter = keyloadunit;\n\t\telse if (asprintf(&toktmp, \"%s %s\", after, keyloadunit) != -1)\n\t\t\tafter = *(tofree++) = toktmp;\n\t\telse {\n\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t    \"out of memory to generate after=\\\"%s %s\\\"!\\n\",\n\t\t\t    getpid(), dataset, after, keyloadunit);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\n\t \n\tif (strcmp(p_systemd_ignore, \"-\") == 0 ||\n\t    strcmp(p_systemd_ignore, \"off\") == 0) {\n\t\t \n\t} else if (strcmp(p_systemd_ignore, \"on\") == 0)\n\t\tgoto end;\n\telse {\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t    \"invalid org.openzfs.systemd:ignore=%s\\n\",\n\t\t    getpid(), dataset, p_systemd_ignore);\n\t\tgoto err;\n\t}\n\n\t \n\tif (strcmp(p_canmount, \"on\") == 0) {\n\t\t \n\t} else if (strcmp(p_canmount, \"noauto\") == 0)\n\t\tnoauto = true;\n\telse if (strcmp(p_canmount, \"off\") == 0)\n\t\tgoto end;\n\telse {\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid canmount=%s\\n\",\n\t\t    getpid(), dataset, p_canmount);\n\t\tgoto err;\n\t}\n\n\t \n\tif (strcmp(p_mountpoint, \"legacy\") == 0 ||\n\t    strcmp(p_mountpoint, \"none\") == 0)\n\t\tgoto end;\n\telse if (p_mountpoint[0] != '/') {\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid mountpoint=%s\\n\",\n\t\t    getpid(), dataset, p_mountpoint);\n\t\tgoto err;\n\t}\n\n\t \n\tsimplify_path(p_mountpoint);\n\tconst char *mountfile = systemd_escape_path(p_mountpoint, \"\", \".mount\");\n\tif (mountfile == NULL) {\n\t\tfprintf(stderr,\n\t\t    PROGNAME \"[%d]: %s: abnormal simplified mountpoint: %s\\n\",\n\t\t    getpid(), dataset, p_mountpoint);\n\t\tgoto err;\n\t}\n\n\n\t \n\tchar opts[64] = \"\";\n\n\t \n\tif (strcmp(p_atime, \"on\") == 0) {\n\t\t \n\t\tif (strcmp(p_relatime, \"on\") == 0)\n\t\t\tstrcat(opts, \",atime,relatime\");\n\t\telse if (strcmp(p_relatime, \"off\") == 0)\n\t\t\tstrcat(opts, \",atime,strictatime\");\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t    PROGNAME \"[%d]: %s: invalid relatime=%s\\n\",\n\t\t\t    getpid(), dataset, p_relatime);\n\t} else if (strcmp(p_atime, \"off\") == 0) {\n\t\tstrcat(opts, \",noatime\");\n\t} else\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid atime=%s\\n\",\n\t\t    getpid(), dataset, p_atime);\n\n\t \n\tif (strcmp(p_devices, \"on\") == 0)\n\t\tstrcat(opts, \",dev\");\n\telse if (strcmp(p_devices, \"off\") == 0)\n\t\tstrcat(opts, \",nodev\");\n\telse\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid devices=%s\\n\",\n\t\t    getpid(), dataset, p_devices);\n\n\t \n\tif (strcmp(p_exec, \"on\") == 0)\n\t\tstrcat(opts, \",exec\");\n\telse if (strcmp(p_exec, \"off\") == 0)\n\t\tstrcat(opts, \",noexec\");\n\telse\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid exec=%s\\n\",\n\t\t    getpid(), dataset, p_exec);\n\n\t \n\tif (strcmp(p_readonly, \"on\") == 0)\n\t\tstrcat(opts, \",ro\");\n\telse if (strcmp(p_readonly, \"off\") == 0)\n\t\tstrcat(opts, \",rw\");\n\telse\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid readonly=%s\\n\",\n\t\t    getpid(), dataset, p_readonly);\n\n\t \n\tif (strcmp(p_setuid, \"on\") == 0)\n\t\tstrcat(opts, \",suid\");\n\telse if (strcmp(p_setuid, \"off\") == 0)\n\t\tstrcat(opts, \",nosuid\");\n\telse\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid setuid=%s\\n\",\n\t\t    getpid(), dataset, p_setuid);\n\n\t \n\tif (strcmp(p_nbmand, \"on\") == 0)\n\t\tstrcat(opts, \",mand\");\n\telse if (strcmp(p_nbmand, \"off\") == 0)\n\t\tstrcat(opts, \",nomand\");\n\telse\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: invalid nbmand=%s\\n\",\n\t\t    getpid(), dataset, p_setuid);\n\n\tif (strcmp(p_systemd_wantedby, \"-\") != 0) {\n\t\tnoauto = true;\n\n\t\tif (strcmp(p_systemd_wantedby, \"none\") != 0)\n\t\t\twantedby = p_systemd_wantedby;\n\t}\n\n\tif (strcmp(p_systemd_requiredby, \"-\") != 0) {\n\t\tnoauto = true;\n\n\t\tif (strcmp(p_systemd_requiredby, \"none\") != 0)\n\t\t\trequiredby = p_systemd_requiredby;\n\t}\n\n\t \n\tif (!noauto) {\n\t\tif (strcmp(p_systemd_nofail, \"off\") == 0)\n\t\t\trequiredby = strdupa(\"local-fs.target\");\n\t\telse {\n\t\t\twantedby = strdupa(\"local-fs.target\");\n\t\t\twantedby_append = strcmp(p_systemd_nofail, \"on\") != 0;\n\t\t}\n\t}\n\n\t \n\n\tstruct stat stbuf;\n\tbool already_exists = fstatat(destdir_fd, mountfile, &stbuf, 0) == 0;\n\tbool is_known = tfind(mountfile, &noauto_files, STRCMP) != NULL;\n\n\t*(tofree++) = (void *)mountfile;\n\tif (already_exists) {\n\t\tif (is_known) {\n\t\t\t \n\n\t\t\t \n\t\t\terrno = 0;\n\t\t\t(void) unlinkat(destdir_fd, mountfile, 0);\n\n\t\t\t \n\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t    \"removing duplicate noauto unit %s%s%s\\n\",\n\t\t\t    getpid(), dataset, mountfile,\n\t\t\t    errno ? \"\" : \" failed: \",\n\t\t\t    errno ? \"\" : strerror(errno));\n\t\t} else {\n\t\t\t \n\t\t\tif (strcmp(p_canmount, \"on\") == 0)\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t    \"%s already exists. Skipping.\\n\",\n\t\t\t\t    getpid(), dataset, mountfile);\n\t\t}\n\n\t\t \n\t\tgoto end;\n\t} else {\n\t\tif (is_known) {\n\t\t\t \n\t\t\tgoto end;\n\t\t} else if (strcmp(p_canmount, \"noauto\") == 0) {\n\t\t\tif (tsearch(mountfile, &noauto_files, STRCMP) == NULL)\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t    \"out of memory for noauto datasets! \"\n\t\t\t\t    \"Not tracking %s.\\n\",\n\t\t\t\t    getpid(), dataset, mountfile);\n\t\t\telse\n\t\t\t\t \n\t\t\t\t*(--tofree) = NULL;\n\t\t}\n\t}\n\n\n\tFILE *mountfile_f = fopenat(destdir_fd, mountfile,\n\t    O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, \"w\", 0644);\n\tif (!mountfile_f) {\n\t\tfprintf(stderr,\n\t\t    PROGNAME \"[%d]: %s: couldn't open %s under %s: %s\\n\",\n\t\t    getpid(), dataset, mountfile, destdir, strerror(errno));\n\t\tgoto err;\n\t}\n\n\tfprintf(mountfile_f,\n\t    OUTPUT_HEADER\n\t    \"[Unit]\\n\"\n\t    \"SourcePath=\" FSLIST \"/%s\\n\"\n\t    \"Documentation=man:zfs-mount-generator(8)\\n\"\n\t    \"\\n\"\n\t    \"Before=\",\n\t    cachefile);\n\n\tif (p_systemd_before)\n\t\tfprintf(mountfile_f, \"%s \", p_systemd_before);\n\tfprintf(mountfile_f, \"zfs-mount.service\");  \n\tif (requiredby)\n\t\tfprintf(mountfile_f, \" %s\", requiredby);\n\tif (wantedby && wantedby_append)\n\t\tfprintf(mountfile_f, \" %s\", wantedby);\n\n\tfprintf(mountfile_f,\n\t    \"\\n\"\n\t    \"After=\");\n\tif (p_systemd_after)\n\t\tfprintf(mountfile_f, \"%s \", p_systemd_after);\n\tfprintf(mountfile_f, \"%s\\n\", after);\n\n\tfprintf(mountfile_f, \"Wants=%s\\n\", wants);\n\n\tif (bindsto)\n\t\tfprintf(mountfile_f, \"BindsTo=%s\\n\", bindsto);\n\tif (p_systemd_requires)\n\t\tfprintf(mountfile_f, \"Requires=%s\\n\", p_systemd_requires);\n\tif (p_systemd_requiresmountsfor)\n\t\tfprintf(mountfile_f,\n\t\t    \"RequiresMountsFor=%s\\n\", p_systemd_requiresmountsfor);\n\n\tfprintf(mountfile_f,\n\t    \"\\n\"\n\t    \"[Mount]\\n\"\n\t    \"Where=%s\\n\"\n\t    \"What=%s\\n\"\n\t    \"Type=zfs\\n\"\n\t    \"Options=defaults%s,zfsutil\\n\",\n\t    p_mountpoint, dataset, opts);\n\n\t(void) fclose(mountfile_f);\n\n\tif (!requiredby && !wantedby)\n\t\tgoto end;\n\n\t \n\tchar *linktgt;\n\tif (asprintf(&linktgt, \"../%s\", mountfile) == -1) {\n\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t    \"out of memory for dependents of %s!\\n\",\n\t\t    getpid(), dataset, mountfile);\n\t\tgoto err;\n\t}\n\t*(tofree++) = linktgt;\n\n\tstruct dep {\n\t\tconst char *type;\n\t\tchar *list;\n\t} deps[] = {\n\t\t{\"wants\", wantedby},\n\t\t{\"requires\", requiredby},\n\t\t{}\n\t};\n\tfor (struct dep *dep = deps; dep->type; ++dep) {\n\t\tif (!dep->list)\n\t\t\tcontinue;\n\n\t\tfor (char *reqby = strtok_r(dep->list, \" \", &toktmp);\n\t\t    reqby;\n\t\t    reqby = strtok_r(NULL, \" \", &toktmp)) {\n\t\t\tchar *depdir;\n\t\t\tif (asprintf(\n\t\t\t    &depdir, \"%s.%s\", reqby, dep->type) == -1) {\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t    \"out of memory for dependent dir name \"\n\t\t\t\t    \"\\\"%s.%s\\\"!\\n\",\n\t\t\t\t    getpid(), dataset, reqby, dep->type);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t(void) mkdirat(destdir_fd, depdir, 0755);\n\t\t\tint depdir_fd = openat(destdir_fd, depdir,\n\t\t\t    O_PATH | O_DIRECTORY | O_CLOEXEC);\n\t\t\tif (depdir_fd < 0) {\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t    \"couldn't open %s under %s: %s\\n\",\n\t\t\t\t    getpid(), dataset, depdir, destdir,\n\t\t\t\t    strerror(errno));\n\t\t\t\tfree(depdir);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (symlinkat(linktgt, depdir_fd, mountfile) == -1)\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: %s: \"\n\t\t\t\t    \"couldn't symlink at \"\n\t\t\t\t    \"%s under %s under %s: %s\\n\",\n\t\t\t\t    getpid(), dataset, mountfile,\n\t\t\t\t    depdir, destdir, strerror(errno));\n\n\t\t\t(void) close(depdir_fd);\n\t\t\tfree(depdir);\n\t\t}\n\t}\n\nend:\n\tif (tofree >= tofree_all + nitems(tofree_all)) {\n\t\t \n\t\tfprintf(stderr,\n\t\t    PROGNAME \"[%d]: %s: need to free %zu > %zu!\\n\",\n\t\t    getpid(), dataset, tofree - tofree_all, nitems(tofree_all));\n\t\tret = tofree - tofree_all;\n\t}\n\n\twhile (tofree-- != tofree_all)\n\t\tfree(*tofree);\n\treturn (ret);\nerr:\n\tret = 1;\n\tgoto end;\n}\n\n\nstatic int\npool_enumerator(zpool_handle_t *pool, void *data __attribute__((unused)))\n{\n\tint ret = 0;\n\n\t \n\tchar *name = strdup(zpool_get_name(pool));\n\tif (!name || !tsearch(name, &known_pools, STRCMP)) {\n\t\tfree(name);\n\t\tret = ENOMEM;\n\t}\n\n\tzpool_close(pool);\n\treturn (ret);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tstruct timespec time_init = {};\n\tclock_gettime(CLOCK_MONOTONIC_RAW, &time_init);\n\n\t{\n\t\tint kmfd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);\n\t\tif (kmfd >= 0) {\n\t\t\t(void) dup2(kmfd, STDERR_FILENO);\n\t\t\t(void) close(kmfd);\n\n\t\t\tsetlinebuf(stderr);\n\t\t}\n\t}\n\n\tswitch (argc) {\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 2:\n\tcase 4:\n\t\tdestdir = argv[1];\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    PROGNAME \"[%d]: wrong argument count: %d\\n\",\n\t\t    getpid(), argc - 1);\n\t\t_exit(1);\n\t}\n\n\t{\n\t\tdestdir_fd = open(destdir, O_PATH | O_DIRECTORY | O_CLOEXEC);\n\t\tif (destdir_fd < 0) {\n\t\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t\t    \"can't open destination directory %s: %s\\n\",\n\t\t\t    getpid(), destdir, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t}\n\n\tDIR *fslist_dir = opendir(FSLIST);\n\tif (!fslist_dir) {\n\t\tif (errno != ENOENT)\n\t\t\tfprintf(stderr,\n\t\t\t    PROGNAME \"[%d]: couldn't open \" FSLIST \": %s\\n\",\n\t\t\t    getpid(), strerror(errno));\n\t\t_exit(0);\n\t}\n\n\t{\n\t\tlibzfs_handle_t *libzfs = libzfs_init();\n\t\tif (libzfs) {\n\t\t\tif (zpool_iter(libzfs, pool_enumerator, NULL) != 0)\n\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t\t\t    \"error listing pools, ignoring\\n\",\n\t\t\t\t    getpid());\n\t\t\tlibzfs_fini(libzfs);\n\t\t} else\n\t\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t\t    \"couldn't start libzfs, ignoring\\n\",\n\t\t\t    getpid());\n\t}\n\n\t{\n\t\tint regerr = regcomp(&uri_regex, URI_REGEX_S, 0);\n\t\tif (regerr != 0) {\n\t\t\tfprintf(stderr,\n\t\t\t    PROGNAME \"[%d]: invalid regex: %d\\n\",\n\t\t\t    getpid(), regerr);\n\t\t\t_exit(1);\n\t\t}\n\t}\n\n\tbool debug = false;\n\tchar *line = NULL;\n\tsize_t linelen = 0;\n\t{\n\t\tconst char *dbgenv = getenv(\"ZFS_DEBUG\");\n\t\tif (dbgenv)\n\t\t\tdebug = atoi(dbgenv);\n\t\telse {\n\t\t\tFILE *cmdline = fopen(\"/proc/cmdline\", \"re\");\n\t\t\tif (cmdline != NULL) {\n\t\t\t\tif (getline(&line, &linelen, cmdline) >= 0)\n\t\t\t\t\tdebug = strstr(line, \"debug\");\n\t\t\t\t(void) fclose(cmdline);\n\t\t\t}\n\t\t}\n\n\t\tif (debug && !isatty(STDOUT_FILENO))\n\t\t\tdup2(STDERR_FILENO, STDOUT_FILENO);\n\t}\n\n\tstruct timespec time_start = {};\n\tif (debug)\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &time_start);\n\n\tstruct line {\n\t\tchar *line;\n\t\tconst char *fname;\n\t\tstruct line *next;\n\t} *lines_canmount_not_on = NULL;\n\n\tint ret = 0;\n\tstruct dirent *cachent;\n\twhile ((cachent = readdir(fslist_dir)) != NULL) {\n\t\tif (strcmp(cachent->d_name, \".\") == 0 ||\n\t\t    strcmp(cachent->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tFILE *cachefile = fopenat(dirfd(fslist_dir), cachent->d_name,\n\t\t    O_RDONLY | O_CLOEXEC, \"r\", 0);\n\t\tif (!cachefile) {\n\t\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t\t    \"couldn't open %s under \" FSLIST \": %s\\n\",\n\t\t\t    getpid(), cachent->d_name, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst char *filename = FREE_STATICS ? \"(elided)\" : NULL;\n\n\t\tssize_t read;\n\t\twhile ((read = getline(&line, &linelen, cachefile)) >= 0) {\n\t\t\tline[read - 1] = '\\0';  \n\n\t\t\tchar *canmount = line;\n\t\t\tcanmount += strcspn(canmount, \"\\t\");\n\t\t\tcanmount += strspn(canmount, \"\\t\");\n\t\t\tcanmount += strcspn(canmount, \"\\t\");\n\t\t\tcanmount += strspn(canmount, \"\\t\");\n\t\t\tbool canmount_on = strncmp(canmount, \"on\", 2) == 0;\n\n\t\t\tif (canmount_on)\n\t\t\t\tret |= line_worker(line, cachent->d_name);\n\t\t\telse {\n\t\t\t\tif (filename == NULL)\n\t\t\t\t\tfilename =\n\t\t\t\t\t    strdup(cachent->d_name) ?: \"(?)\";\n\n\t\t\t\tstruct line *l = calloc(1, sizeof (*l));\n\t\t\t\tchar *nl = strdup(line);\n\t\t\t\tif (l == NULL || nl == NULL) {\n\t\t\t\t\tfprintf(stderr, PROGNAME \"[%d]: \"\n\t\t\t\t\t    \"out of memory for \\\"%s\\\" in %s\\n\",\n\t\t\t\t\t    getpid(), line, cachent->d_name);\n\t\t\t\t\tfree(l);\n\t\t\t\t\tfree(nl);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tl->line = nl;\n\t\t\t\tl->fname = filename;\n\t\t\t\tl->next = lines_canmount_not_on;\n\t\t\t\tlines_canmount_not_on = l;\n\t\t\t}\n\t\t}\n\n\t\tfclose(cachefile);\n\t}\n\tfree(line);\n\n\twhile (lines_canmount_not_on) {\n\t\tstruct line *l = lines_canmount_not_on;\n\t\tlines_canmount_not_on = l->next;\n\n\t\tret |= line_worker(l->line, l->fname);\n\t\tif (FREE_STATICS) {\n\t\t\tfree(l->line);\n\t\t\tfree(l);\n\t\t}\n\t}\n\n\tif (debug) {\n\t\tstruct timespec time_end = {};\n\t\tclock_gettime(CLOCK_MONOTONIC_RAW, &time_end);\n\n\t\tstruct rusage usage;\n\t\tgetrusage(RUSAGE_SELF, &usage);\n\t\tprintf(\n\t\t    \"\\n\"\n\t\t    PROGNAME \": \"\n\t\t    \"user=%llu.%06us, system=%llu.%06us, maxrss=%ldB\\n\",\n\t\t    (unsigned long long) usage.ru_utime.tv_sec,\n\t\t    (unsigned int) usage.ru_utime.tv_usec,\n\t\t    (unsigned long long) usage.ru_stime.tv_sec,\n\t\t    (unsigned int) usage.ru_stime.tv_usec,\n\t\t    usage.ru_maxrss * 1024);\n\n\t\tif (time_start.tv_nsec > time_end.tv_nsec) {\n\t\t\ttime_end.tv_nsec =\n\t\t\t    1000000000 + time_end.tv_nsec - time_start.tv_nsec;\n\t\t\ttime_end.tv_sec -= 1;\n\t\t} else\n\t\t\ttime_end.tv_nsec -= time_start.tv_nsec;\n\t\ttime_end.tv_sec -= time_start.tv_sec;\n\n\t\tif (time_init.tv_nsec > time_start.tv_nsec) {\n\t\t\ttime_start.tv_nsec =\n\t\t\t    1000000000 + time_start.tv_nsec - time_init.tv_nsec;\n\t\t\ttime_start.tv_sec -= 1;\n\t\t} else\n\t\t\ttime_start.tv_nsec -= time_init.tv_nsec;\n\t\ttime_start.tv_sec -= time_init.tv_sec;\n\n\t\ttime_init.tv_nsec = time_start.tv_nsec + time_end.tv_nsec;\n\t\ttime_init.tv_sec =\n\t\t    time_start.tv_sec + time_end.tv_sec +\n\t\t    time_init.tv_nsec / 1000000000;\n\t\ttime_init.tv_nsec %= 1000000000;\n\n\t\tprintf(PROGNAME \": \"\n\t\t    \"total=%llu.%09llus = \"\n\t\t    \"init=%llu.%09llus + real=%llu.%09llus\\n\",\n\t\t    (unsigned long long) time_init.tv_sec,\n\t\t    (unsigned long long) time_init.tv_nsec,\n\t\t    (unsigned long long) time_start.tv_sec,\n\t\t    (unsigned long long) time_start.tv_nsec,\n\t\t    (unsigned long long) time_end.tv_sec,\n\t\t    (unsigned long long) time_end.tv_nsec);\n\n\t\tfflush(stdout);\n\t}\n\n\tif (FREE_STATICS) {\n\t\tclosedir(fslist_dir);\n\t\ttdestroy(noauto_files, free);\n\t\ttdestroy(known_pools, free);\n\t\tregfree(&uri_regex);\n\t}\n\t_exit(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}