{
  "module_name": "vdev_id",
  "hash_id": "1ab419d3b1a21f07e705c8e4f1e19aa021dcdcce4be084b55948aebd023e53ea",
  "original_prompt": "Ingested from zfs-2.2.2/udev/vdev_id",
  "human_readable_source": "#!/bin/sh\n#\n# vdev_id: udev helper to generate user-friendly names for JBOD disks\n#\n# This script parses the file /etc/zfs/vdev_id.conf to map a\n# physical path in a storage topology to a channel name.  The\n# channel name is combined with a disk enclosure slot number to\n# create an alias that reflects the physical location of the drive.\n# This is particularly helpful when it comes to tasks like replacing\n# failed drives.  Slot numbers may also be re-mapped in case the\n# default numbering is unsatisfactory.  The drive aliases will be\n# created as symbolic links in /dev/disk/by-vdev.\n#\n# The currently supported topologies are sas_direct and sas_switch.\n# A multipath mode is supported in which dm-mpath devices are\n# handled by examining the first-listed running component disk.  In\n# multipath mode the configuration file should contain a channel\n# definition with the same name for each path to a given enclosure.\n#\n# The alias keyword provides a simple way to map already-existing\n# device symlinks to more convenient names.  It is suitable for\n# small, static configurations or for sites that have some automated\n# way to generate the mapping file.\n#\n#\n# Some example configuration files are given below.\n\n# #\n# # Example vdev_id.conf - sas_direct.\n# #\n#\n# multipath     no\n# topology      sas_direct\n# phys_per_port 4\n# slot          bay\n#\n# #       PCI_ID  HBA PORT  CHANNEL NAME\n# channel 85:00.0 1         A\n# channel 85:00.0 0         B\n# channel 86:00.0 1         C\n# channel 86:00.0 0         D\n#\n# # Custom mapping for Channel A\n#\n# #    Linux      Mapped\n# #    Slot       Slot      Channel\n# slot 1          7         A\n# slot 2          10        A\n# slot 3          3         A\n# slot 4          6         A\n#\n# # Default mapping for B, C, and D\n# slot 1          4\n# slot 2          2\n# slot 3          1\n# slot 4          3\n\n# #\n# # Example vdev_id.conf - sas_switch\n# #\n#\n# topology      sas_switch\n#\n# #       SWITCH PORT  CHANNEL NAME\n# channel 1            A\n# channel 2            B\n# channel 3            C\n# channel 4            D\n\n# #\n# # Example vdev_id.conf - multipath\n# #\n#\n# multipath yes\n#\n# #       PCI_ID  HBA PORT  CHANNEL NAME\n# channel 85:00.0 1         A\n# channel 85:00.0 0         B\n# channel 86:00.0 1         A\n# channel 86:00.0 0         B\n\n# #\n# # Example vdev_id.conf - multipath / multijbod-daisychaining\n# #\n#\n# multipath yes\n# multijbod yes\n#\n# #       PCI_ID  HBA PORT  CHANNEL NAME\n# channel 85:00.0 1         A\n# channel 85:00.0 0         B\n# channel 86:00.0 1         A\n# channel 86:00.0 0         B\n\n# #\n# # Example vdev_id.conf - multipath / mixed\n# #\n#\n# multipath yes\n# slot mix\n#\n# #       PCI_ID  HBA PORT  CHANNEL NAME\n# channel 85:00.0 3         A\n# channel 85:00.0 2         B\n# channel 86:00.0 3         A\n# channel 86:00.0 2         B\n# channel af:00.0 0         C\n# channel af:00.0 1         C\n\n# #\n# # Example vdev_id.conf - alias\n# #\n#\n# #     by-vdev\n# #     name     fully qualified or base name of device link\n# alias d1       /dev/disk/by-id/wwn-0x5000c5002de3b9ca\n# alias d2       wwn-0x5000c5002def789e\n\nPATH=/bin:/sbin:/usr/bin:/usr/sbin\nCONFIG=/etc/zfs/vdev_id.conf\nPHYS_PER_PORT=\nDEV=\nTOPOLOGY=\nBAY=\nENCL_ID=\"\"\nUNIQ_ENCL_ID=\"\"\n\nusage() {\n\tcat << EOF\nUsage: vdev_id [-h]\n       vdev_id <-d device> [-c config_file] [-p phys_per_port]\n               [-g sas_direct|sas_switch|scsi] [-m]\n\n  -c    specify name of an alternative config file [default=$CONFIG]\n  -d    specify basename of device (i.e. sda)\n  -e    Create enclose device symlinks only (/dev/by-enclosure)\n  -g    Storage network topology [default=\"$TOPOLOGY\"]\n  -m    Run in multipath mode\n  -j    Run in multijbod mode\n  -p    number of phy's per switch port [default=$PHYS_PER_PORT]\n  -h    show this summary\nEOF\n\texit 1\n\t# exit with error to avoid processing usage message by a udev rule\n}\n\nmap_slot() {\n\tLINUX_SLOT=$1\n\tCHANNEL=$2\n\n\tMAPPED_SLOT=$(awk -v linux_slot=\"$LINUX_SLOT\" -v channel=\"$CHANNEL\" \\\n\t\t\t'$1 == \"slot\" && $2 == linux_slot && \\\n\t\t\t($4 ~ \"^\"channel\"$\" || $4 ~ /^$/) { print $3; exit}' $CONFIG)\n\tif [ -z \"$MAPPED_SLOT\" ] ; then\n\t\tMAPPED_SLOT=$LINUX_SLOT\n\tfi\n\tprintf \"%d\" \"${MAPPED_SLOT}\"\n}\n\nmap_channel() {\n\tMAPPED_CHAN=\n\tPCI_ID=$1\n\tPORT=$2\n\n\tcase $TOPOLOGY in\n\t\t\"sas_switch\")\n\t\tMAPPED_CHAN=$(awk -v port=\"$PORT\" \\\n\t\t\t'$1 == \"channel\" && $2 == port \\\n\t\t\t{ print $3; exit }' $CONFIG)\n\t\t;;\n\t\t\"sas_direct\"|\"scsi\")\n\t\tMAPPED_CHAN=$(awk -v pciID=\"$PCI_ID\" -v port=\"$PORT\" \\\n\t\t\t'$1 == \"channel\" && $2 == pciID && $3 == port \\\n\t\t\t{print $4}' $CONFIG)\n\t\t;;\n\tesac\n\tprintf \"%s\" \"${MAPPED_CHAN}\"\n}\n\nget_encl_id() {\n\tset -- $(echo $1)\n\tcount=$#\n\n\ti=1\n\twhile [ $i -le $count ] ; do\n\t\td=$(eval echo '$'{$i})\n\t\tid=$(cat \"/sys/class/enclosure/${d}/id\")\n\t\tENCL_ID=\"${ENCL_ID} $id\"\n\t\ti=$((i + 1))\n\tdone\n}\n\nget_uniq_encl_id() {\n\tfor uuid in ${ENCL_ID}; do\n\t\tfound=0\n\n\t\tfor count in ${UNIQ_ENCL_ID}; do\n\t\t\tif [ $count = $uuid ]; then\n\t\t\t\tfound=1\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\n\t\tif [ $found -eq 0 ]; then\n\t\t\tUNIQ_ENCL_ID=\"${UNIQ_ENCL_ID} $uuid\"\n\t\tfi\n\tdone\n}\n\n# map_jbod explainer: The bsg driver knows the difference between a SAS\n# expander and fanout expander. Use hostX instance along with top-level\n# (whole enclosure) expander instances in /sys/class/enclosure and\n# matching a field in an array of expanders, using the index of the\n# matched array field as the enclosure instance, thereby making jbod IDs\n# dynamic. Avoids reliance on high overhead userspace commands like\n# multipath and lsscsi and instead uses existing sysfs data.  $HOSTCHAN\n# variable derived from devpath gymnastics in sas_handler() function.\nmap_jbod() {\n\tDEVEXP=$(ls -l \"/sys/block/$DEV/device/\" | grep enclos | awk -F/ '{print $(NF-1) }')\n\tDEV=$1\n\n\t# Use \"set --\" to create index values (Arrays)\n\tset -- $(ls -l /sys/class/enclosure | grep -v \"^total\" | awk '{print $9}')\n\t# Get count of total elements\n\tJBOD_COUNT=$#\n\tJBOD_ITEM=$*\n\n\t# Build JBODs (enclosure)  id from sys/class/enclosure/<dev>/id\n\tget_encl_id \"$JBOD_ITEM\"\n\t# Different expander instances for each paths.\n\t# Filter out and keep only unique id.\n\tget_uniq_encl_id\n\n\t# Identify final 'mapped jbod'\n\tj=0\n\tfor count in ${UNIQ_ENCL_ID}; do\n\t\ti=1\n\t\tj=$((j + 1))\n\t\twhile [ $i -le $JBOD_COUNT ] ; do\n\t\t\td=$(eval echo '$'{$i})\n\t\t\tid=$(cat \"/sys/class/enclosure/${d}/id\")\n\t\t\tif [ \"$d\" = \"$DEVEXP\" ] && [ $id = $count ] ; then\n\t\t\t\tMAPPED_JBOD=$j\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\ti=$((i + 1))\n\t\tdone\n\tdone\n\n\tprintf \"%d\" \"${MAPPED_JBOD}\"\n}\n\nsas_handler() {\n\tif [ -z \"$PHYS_PER_PORT\" ] ; then\n\t\tPHYS_PER_PORT=$(awk '$1 == \"phys_per_port\" \\\n\t\t\t{print $2; exit}' $CONFIG)\n\tfi\n\tPHYS_PER_PORT=${PHYS_PER_PORT:-4}\n\n\tif ! echo \"$PHYS_PER_PORT\" | grep -q -E '^[0-9]+$' ; then\n\t\techo \"Error: phys_per_port value $PHYS_PER_PORT is non-numeric\"\n\t\texit 1\n\tfi\n\n\tif [ -z \"$MULTIPATH_MODE\" ] ; then\n\t\tMULTIPATH_MODE=$(awk '$1 == \"multipath\" \\\n\t\t\t{print $2; exit}' $CONFIG)\n\tfi\n\n\tif [ -z \"$MULTIJBOD_MODE\" ] ; then\n\t\tMULTIJBOD_MODE=$(awk '$1 == \"multijbod\" \\\n\t\t\t{print $2; exit}' $CONFIG)\n\tfi\n\n\t# Use first running component device if we're handling a dm-mpath device\n\tif [ \"$MULTIPATH_MODE\" = \"yes\" ] ; then\n\t\t# If udev didn't tell us the UUID via DM_NAME, check /dev/mapper\n\t\tif [ -z \"$DM_NAME\" ] ; then\n\t\t\tDM_NAME=$(ls -l --full-time /dev/mapper |\n\t\t\t\tgrep \"$DEV\"$ | awk '{print $9}')\n\t\tfi\n\n\t\t# For raw disks udev exports DEVTYPE=partition when\n\t\t# handling partitions, and the rules can be written to\n\t\t# take advantage of this to append a -part suffix.  For\n\t\t# dm devices we get DEVTYPE=disk even for partitions so\n\t\t# we have to append the -part suffix directly in the\n\t\t# helper.\n\t\tif [ \"$DEVTYPE\" != \"partition\" ] ; then\n\t\t\t# Match p[number], remove the 'p' and prepend \"-part\"\n\t\t\tPART=$(echo \"$DM_NAME\" |\n\t\t\t\tawk 'match($0,/p[0-9]+$/) {print \"-part\"substr($0,RSTART+1,RLENGTH-1)}')\n\t\tfi\n\n\t\t# Strip off partition information.\n\t\tDM_NAME=$(echo \"$DM_NAME\" | sed 's/p[0-9][0-9]*$//')\n\t\tif [ -z \"$DM_NAME\" ] ; then\n\t\t\treturn\n\t\tfi\n\n\t\t# Utilize DM device name to gather subordinate block devices\n\t\t# using sysfs to avoid userspace utilities\n\n\t\t# If our DEVNAME is something like /dev/dm-177, then we may be\n\t\t# able to get our DMDEV from it.\n\t\tDMDEV=$(echo $DEVNAME | sed 's;/dev/;;g')\n\t\tif [ ! -e /sys/block/$DMDEV/slaves/* ] ; then\n\t\t\t# It's not there, try looking in /dev/mapper\n\t\t\tDMDEV=$(ls -l --full-time /dev/mapper | grep $DM_NAME |\n\t\t\tawk '{gsub(\"../\", \" \"); print $NF}')\n\t\tfi\n\n\t\t# Use sysfs pointers in /sys/block/dm-X/slaves because using\n\t\t# userspace tools creates lots of overhead and should be avoided\n\t\t# whenever possible. Use awk to isolate lowest instance of\n\t\t# sd device member in dm device group regardless of string\n\t\t# length.\n\t\tDEV=$(ls \"/sys/block/$DMDEV/slaves\" | awk '\n\t\t\t{ len=sprintf (\"%20s\",length($0)); gsub(/ /,0,str); a[NR]=len \"_\" $0; }\n\t\t\tEND {\n\t\t\t\tasort(a)\n\t\t\t\tprint substr(a[1],22)\n\t\t\t}')\n\n\t\tif [ -z \"$DEV\" ] ; then\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tif echo \"$DEV\" | grep -q ^/devices/ ; then\n\t\tsys_path=$DEV\n\telse\n\t\tsys_path=$(udevadm info -q path -p \"/sys/block/$DEV\" 2>/dev/null)\n\tfi\n\n\t# Use positional parameters as an ad-hoc array\n\tset -- $(echo \"$sys_path\" | tr / ' ')\n\tnum_dirs=$#\n\tscsi_host_dir=\"/sys\"\n\n\t# Get path up to /sys/.../hostX\n\ti=1\n\n\twhile [ $i -le \"$num_dirs\" ] ; do\n\t\td=$(eval echo '$'{$i})\n\t\tscsi_host_dir=\"$scsi_host_dir/$d\"\n\t\techo \"$d\" | grep -q -E '^host[0-9]+$' && break\n\t\ti=$((i + 1))\n\tdone\n\n\t# Lets grab the SAS host channel number and save it for JBOD sorting later\n\tHOSTCHAN=$(echo \"$d\" | awk -F/ '{ gsub(\"host\",\"\",$NF); print $NF}')\n\n\tif [ $i = \"$num_dirs\" ] ; then\n\t\treturn\n\tfi\n\n\tPCI_ID=$(eval echo '$'{$((i -1))} | awk -F: '{print $2\":\"$3}')\n\n\t# In sas_switch mode, the directory four levels beneath\n\t# /sys/.../hostX contains symlinks to phy devices that reveal\n\t# the switch port number.  In sas_direct mode, the phy links one\n\t# directory down reveal the HBA port.\n\tport_dir=$scsi_host_dir\n\n\tcase $TOPOLOGY in\n\t\t\"sas_switch\") j=$((i + 4)) ;;\n\t\t\"sas_direct\") j=$((i + 1)) ;;\n\tesac\n\n\ti=$((i + 1))\n\n\twhile [ $i -le $j ] ; do\n\t\tport_dir=\"$port_dir/$(eval echo '$'{$i})\"\n\t\ti=$((i + 1))\n\tdone\n\n\tPHY=$(ls -vd \"$port_dir\"/phy* 2>/dev/null | head -1 | awk -F: '{print $NF}')\n\tif [ -z \"$PHY\" ] ; then\n\t\tPHY=0\n\tfi\n\tPORT=$((PHY / PHYS_PER_PORT))\n\n\t# Look in /sys/.../sas_device/end_device-X for the bay_identifier\n\t# attribute.\n\tend_device_dir=$port_dir\n\n\twhile [ $i -lt \"$num_dirs\" ] ; do\n\t\td=$(eval echo '$'{$i})\n\t\tend_device_dir=\"$end_device_dir/$d\"\n\t\tif echo \"$d\" | grep -q '^end_device' ; then\n\t\t\tend_device_dir=\"$end_device_dir/sas_device/$d\"\n\t\t\tbreak\n\t\tfi\n\t\ti=$((i + 1))\n\tdone\n\n\t# Add 'mix' slot type for environments where dm-multipath devices\n\t# include end-devices connected via SAS expanders or direct connection\n\t# to SAS HBA. A mixed connectivity environment such as pool devices\n\t# contained in a SAS JBOD and spare drives or log devices directly\n\t# connected in a server backplane without expanders in the I/O path.\n\tSLOT=\n\n\tcase $BAY in\n\t\"bay\")\n\t\tSLOT=$(cat \"$end_device_dir/bay_identifier\" 2>/dev/null)\n\t\t;;\n\t\"mix\")\n\t\tif [ $(cat \"$end_device_dir/bay_identifier\" 2>/dev/null) ] ; then\n\t\t\tSLOT=$(cat \"$end_device_dir/bay_identifier\" 2>/dev/null)\n\t\telse\n\t\t\tSLOT=$(cat \"$end_device_dir/phy_identifier\" 2>/dev/null)\n\t\tfi\n\t\t;;\n\t\"phy\")\n\t\tSLOT=$(cat \"$end_device_dir/phy_identifier\" 2>/dev/null)\n\t\t;;\n\t\"port\")\n\t\td=$(eval echo '$'{$i})\n\t\tSLOT=$(echo \"$d\" | sed -e 's/^.*://')\n\t\t;;\n\t\"id\")\n\t\ti=$((i + 1))\n\t\td=$(eval echo '$'{$i})\n\t\tSLOT=$(echo \"$d\" | sed -e 's/^.*://')\n\t\t;;\n\t\"lun\")\n\t\ti=$((i + 2))\n\t\td=$(eval echo '$'{$i})\n\t\tSLOT=$(echo \"$d\" | sed -e 's/^.*://')\n\t\t;;\n\t\"ses\")\n\t\t# look for this SAS path in all SCSI Enclosure Services\n\t\t# (SES) enclosures\n\t\tsas_address=$(cat \"$end_device_dir/sas_address\" 2>/dev/null)\n\t\tenclosures=$(lsscsi -g | \\\n\t\t\tsed -n -e '/enclosu/s/^.* \\([^ ][^ ]*\\) *$/\\1/p')\n\t\tfor enclosure in $enclosures; do\n\t\t\tset -- $(sg_ses -p aes \"$enclosure\" | \\\n\t\t\t\tawk \"/device slot number:/{slot=\\$12} \\\n\t\t\t\t\t/SAS address: $sas_address/\\\n\t\t\t\t\t{print slot}\")\n\t\t\tSLOT=$1\n\t\t\tif [ -n \"$SLOT\" ] ; then\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\t\t;;\n\tesac\n\tif [ -z \"$SLOT\" ] ; then\n\t\treturn\n\tfi\n\n\tif [ \"$MULTIJBOD_MODE\" = \"yes\" ] ; then\n\t\tCHAN=$(map_channel \"$PCI_ID\" \"$PORT\")\n\t\tSLOT=$(map_slot \"$SLOT\" \"$CHAN\")\n\t\tJBOD=$(map_jbod \"$DEV\")\n\n\t\tif [ -z \"$CHAN\" ] ; then\n\t\t\treturn\n\t\tfi\n\t\techo \"${CHAN}\"-\"${JBOD}\"-\"${SLOT}${PART}\"\n\telse\n\t\tCHAN=$(map_channel \"$PCI_ID\" \"$PORT\")\n\t\tSLOT=$(map_slot \"$SLOT\" \"$CHAN\")\n\n\t\tif [ -z \"$CHAN\" ] ; then\n\t\t\treturn\n\t\tfi\n\t\techo \"${CHAN}${SLOT}${PART}\"\n\tfi\n}\n\nscsi_handler() {\n\tif [ -z \"$FIRST_BAY_NUMBER\" ] ; then\n\t\tFIRST_BAY_NUMBER=$(awk '$1 == \"first_bay_number\" \\\n\t\t\t{print $2; exit}' $CONFIG)\n\tfi\n\tFIRST_BAY_NUMBER=${FIRST_BAY_NUMBER:-0}\n\n\tif [ -z \"$PHYS_PER_PORT\" ] ; then\n\t\tPHYS_PER_PORT=$(awk '$1 == \"phys_per_port\" \\\n\t\t\t{print $2; exit}' $CONFIG)\n\tfi\n\tPHYS_PER_PORT=${PHYS_PER_PORT:-4}\n\n\tif ! echo \"$PHYS_PER_PORT\" | grep -q -E '^[0-9]+$' ; then\n\t\techo \"Error: phys_per_port value $PHYS_PER_PORT is non-numeric\"\n\t\texit 1\n\tfi\n\n\tif [ -z \"$MULTIPATH_MODE\" ] ; then\n\t\tMULTIPATH_MODE=$(awk '$1 == \"multipath\" \\\n\t\t\t{print $2; exit}' $CONFIG)\n\tfi\n\n\t# Use first running component device if we're handling a dm-mpath device\n\tif [ \"$MULTIPATH_MODE\" = \"yes\" ] ; then\n\t\t# If udev didn't tell us the UUID via DM_NAME, check /dev/mapper\n\t\tif [ -z \"$DM_NAME\" ] ; then\n\t\t\tDM_NAME=$(ls -l --full-time /dev/mapper |\n\t\t\t\tgrep \"$DEV\"$ | awk '{print $9}')\n\t\tfi\n\n\t\t# For raw disks udev exports DEVTYPE=partition when\n\t\t# handling partitions, and the rules can be written to\n\t\t# take advantage of this to append a -part suffix.  For\n\t\t# dm devices we get DEVTYPE=disk even for partitions so\n\t\t# we have to append the -part suffix directly in the\n\t\t# helper.\n\t\tif [ \"$DEVTYPE\" != \"partition\" ] ; then\n\t\t\t# Match p[number], remove the 'p' and prepend \"-part\"\n\t\t\tPART=$(echo \"$DM_NAME\" |\n\t\t\t    awk 'match($0,/p[0-9]+$/) {print \"-part\"substr($0,RSTART+1,RLENGTH-1)}')\n\t\tfi\n\n\t\t# Strip off partition information.\n\t\tDM_NAME=$(echo \"$DM_NAME\" | sed 's/p[0-9][0-9]*$//')\n\t\tif [ -z \"$DM_NAME\" ] ; then\n\t\t\treturn\n\t\tfi\n\n\t\t# Get the raw scsi device name from multipath -ll. Strip off\n\t\t# leading pipe symbols to make field numbering consistent.\n\t\tDEV=$(multipath -ll \"$DM_NAME\" |\n\t\t\tawk '/running/{gsub(\"^[|]\",\" \"); print $3 ; exit}')\n\t\tif [ -z \"$DEV\" ] ; then\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tif echo \"$DEV\" | grep -q ^/devices/ ; then\n\t\tsys_path=$DEV\n\telse\n\t\tsys_path=$(udevadm info -q path -p \"/sys/block/$DEV\" 2>/dev/null)\n\tfi\n\n\t# expect sys_path like this, for example:\n\t# /devices/pci0000:00/0000:00:0b.0/0000:09:00.0/0000:0a:05.0/0000:0c:00.0/host3/target3:1:0/3:1:0:21/block/sdv\n\n\t# Use positional parameters as an ad-hoc array\n\tset -- $(echo \"$sys_path\" | tr / ' ')\n\tnum_dirs=$#\n\tscsi_host_dir=\"/sys\"\n\n\t# Get path up to /sys/.../hostX\n\ti=1\n\n\twhile [ $i -le \"$num_dirs\" ] ; do\n\t\td=$(eval echo '$'{$i})\n\t\tscsi_host_dir=\"$scsi_host_dir/$d\"\n\n\t\techo \"$d\" | grep -q -E '^host[0-9]+$' && break\n\t\ti=$((i + 1))\n\tdone\n\n\tif [ $i = \"$num_dirs\" ] ; then\n\t\treturn\n\tfi\n\n\tPCI_ID=$(eval echo '$'{$((i -1))} | awk -F: '{print $2\":\"$3}')\n\n\t# In scsi mode, the directory two levels beneath\n\t# /sys/.../hostX reveals the port and slot.\n\tport_dir=$scsi_host_dir\n\tj=$((i + 2))\n\n\ti=$((i + 1))\n\twhile [ $i -le $j ] ; do\n\t\tport_dir=\"$port_dir/$(eval echo '$'{$i})\"\n\t\ti=$((i + 1))\n\tdone\n\n\tset -- $(echo \"$port_dir\" | sed -e 's/^.*:\\([^:]*\\):\\([^:]*\\)$/\\1 \\2/')\n\tPORT=$1\n\tSLOT=$(($2 + FIRST_BAY_NUMBER))\n\n\tif [ -z \"$SLOT\" ] ; then\n\t\treturn\n\tfi\n\n\tCHAN=$(map_channel \"$PCI_ID\" \"$PORT\")\n\tSLOT=$(map_slot \"$SLOT\" \"$CHAN\")\n\n\tif [ -z \"$CHAN\" ] ; then\n\t\treturn\n\tfi\n\techo \"${CHAN}${SLOT}${PART}\"\n}\n\n# Figure out the name for the enclosure symlink\nenclosure_handler () {\n\t# We get all the info we need from udev's DEVPATH variable:\n\t#\n\t# DEVPATH=/sys/devices/pci0000:00/0000:00:03.0/0000:05:00.0/host0/subsystem/devices/0:0:0:0/scsi_generic/sg0\n\n\t# Get the enclosure ID (\"0:0:0:0\")\n\tENC=\"${DEVPATH%/*}\"\n\tENC=\"${ENC%/*}\"\n\tENC=\"${ENC##*/}\"\n\tif [ ! -d \"/sys/class/enclosure/$ENC\" ] ; then\n\t\t# Not an enclosure, bail out\n\t\treturn\n\tfi\n\n\t# Get the long sysfs device path to our enclosure. Looks like:\n\t# /devices/pci0000:00/0000:00:03.0/0000:05:00.0/host0/port-0:0/ ... /enclosure/0:0:0:0\n\n\tENC_DEVICE=$(readlink \"/sys/class/enclosure/$ENC\")\n\n\t# Grab the full path to the hosts port dir:\n\t# /devices/pci0000:00/0000:00:03.0/0000:05:00.0/host0/port-0:0\n\tPORT_DIR=$(echo \"$ENC_DEVICE\" | grep -Eo '.+host[0-9]+/port-[0-9]+:[0-9]+')\n\n\t# Get the port number\n\tPORT_ID=$(echo \"$PORT_DIR\" | grep -Eo \"[0-9]+$\")\n\n\t# The PCI directory is two directories up from the port directory\n\t# /sys/devices/pci0000:00/0000:00:03.0/0000:05:00.0\n\tPCI_ID_LONG=\"$(readlink -m \"/sys/$PORT_DIR/../..\")\"\n\tPCI_ID_LONG=\"${PCI_ID_LONG##*/}\"\n\n\t# Strip down the PCI address from 0000:05:00.0 to 05:00.0\n\tPCI_ID=\"${PCI_ID_LONG#[0-9]*:}\"\n\n\t# Name our device according to vdev_id.conf (like \"L0\" or \"U1\").\n\tNAME=$(awk \"/channel/{if (\\$1 == \\\"channel\\\" && \\$2 == \\\"$PCI_ID\\\" && \\\n\t\t\\$3 == \\\"$PORT_ID\\\") {print \\$4\\$3}}\" $CONFIG)\n\n\techo \"${NAME}\"\n}\n\nalias_handler () {\n\t# Special handling is needed to correctly append a -part suffix\n\t# to partitions of device mapper devices.  The DEVTYPE attribute\n\t# is normally set to \"disk\" instead of \"partition\" in this case,\n\t# so the udev rules won't handle that for us as they do for\n\t# \"plain\" block devices.\n\t#\n\t# For example, we may have the following links for a device and its\n\t# partitions,\n\t#\n\t#  /dev/disk/by-id/dm-name-isw_dibgbfcije_ARRAY0   -> ../../dm-0\n\t#  /dev/disk/by-id/dm-name-isw_dibgbfcije_ARRAY0p1 -> ../../dm-1\n\t#  /dev/disk/by-id/dm-name-isw_dibgbfcije_ARRAY0p2 -> ../../dm-3\n\t#\n\t# and the following alias in vdev_id.conf.\n\t#\n\t#   alias A0 dm-name-isw_dibgbfcije_ARRAY0\n\t#\n\t# The desired outcome is for the following links to be created\n\t# without having explicitly defined aliases for the partitions.\n\t#\n\t#  /dev/disk/by-vdev/A0       -> ../../dm-0\n\t#  /dev/disk/by-vdev/A0-part1 -> ../../dm-1\n\t#  /dev/disk/by-vdev/A0-part2 -> ../../dm-3\n\t#\n\t# Warning: The following grep pattern will misidentify whole-disk\n\t#          devices whose names end with 'p' followed by a string of\n\t#          digits as partitions, causing alias creation to fail. This\n\t#          ambiguity seems unavoidable, so devices using this facility\n\t#          must not use such names.\n\tDM_PART=\n\tif echo \"$DM_NAME\" | grep -q -E 'p[0-9][0-9]*$' ; then\n\t\tif [ \"$DEVTYPE\" != \"partition\" ] ; then\n\t\t\t# Match p[number], remove the 'p' and prepend \"-part\"\n\t\t\tDM_PART=$(echo \"$DM_NAME\" |\n\t\t\t    awk 'match($0,/p[0-9]+$/) {print \"-part\"substr($0,RSTART+1,RLENGTH-1)}')\n\t\tfi\n\tfi\n\n\t# DEVLINKS attribute must have been populated by already-run udev rules.\n\tfor link in $DEVLINKS ; do\n\t\t# Remove partition information to match key of top-level device.\n\t\tif [ -n \"$DM_PART\" ] ; then\n\t\t\tlink=$(echo \"$link\" | sed 's/p[0-9][0-9]*$//')\n\t\tfi\n\t\t# Check both the fully qualified and the base name of link.\n\t\tfor l in $link ${link##*/} ; do\n\t\t\tif [ ! -z \"$l\" ]; then\n\t\t\t\talias=$(awk -v var=\"$l\" '($1 == \"alias\") && \\\n\t\t\t\t\t($3 == var) \\\n\t\t\t\t\t{ print $2; exit }' $CONFIG)\n\t\t\t\tif [ -n \"$alias\" ] ; then\n\t\t\t\t\techo \"${alias}${DM_PART}\"\n\t\t\t\t\treturn\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tdone\n}\n\n# main\nwhile getopts 'c:d:eg:jmp:h' OPTION; do\n\tcase ${OPTION} in\n\tc)\n\t\tCONFIG=${OPTARG}\n\t\t;;\n\td)\n\t\tDEV=${OPTARG}\n\t\t;;\n\te)\n\t# When udev sees a scsi_generic device, it calls this script with -e to\n\t# create the enclosure device symlinks only.  We also need\n\t# \"enclosure_symlinks yes\" set in vdev_id.config to actually create the\n\t# symlink.\n\tENCLOSURE_MODE=$(awk '{if ($1 == \"enclosure_symlinks\") \\\n\t\tprint $2}' \"$CONFIG\")\n\n\tif [ \"$ENCLOSURE_MODE\" != \"yes\" ] ; then\n\t\texit 0\n\tfi\n\t\t;;\n\tg)\n\t\tTOPOLOGY=$OPTARG\n\t\t;;\n\tp)\n\t\tPHYS_PER_PORT=${OPTARG}\n\t\t;;\n\tj)\n\t\tMULTIJBOD_MODE=yes\n\t\t;;\n\tm)\n\t\tMULTIPATH_MODE=yes\n\t\t;;\n\th)\n\t\tusage\n\t\t;;\n\tesac\ndone\n\nif [ ! -r \"$CONFIG\" ] ; then\n\techo \"Error: Config file \\\"$CONFIG\\\" not found\"\n\texit 1\nfi\n\nif [ -z \"$DEV\" ] && [ -z \"$ENCLOSURE_MODE\" ] ; then\n\techo \"Error: missing required option -d\"\n\texit 1\nfi\n\nif [ -z \"$TOPOLOGY\" ] ; then\n\tTOPOLOGY=$(awk '($1 == \"topology\") {print $2; exit}' \"$CONFIG\")\nfi\n\nif [ -z \"$BAY\" ] ; then\n\tBAY=$(awk '($1 == \"slot\") {print $2; exit}' \"$CONFIG\")\nfi\n\nTOPOLOGY=${TOPOLOGY:-sas_direct}\n\n# Should we create /dev/by-enclosure symlinks?\nif [ \"$ENCLOSURE_MODE\" = \"yes\" ] && [ \"$TOPOLOGY\" = \"sas_direct\" ] ; then\n\tID_ENCLOSURE=$(enclosure_handler)\n\tif [ -z \"$ID_ENCLOSURE\" ] ; then\n\t\texit 0\n\tfi\n\n\t# Just create the symlinks to the enclosure devices and then exit.\n\tENCLOSURE_PREFIX=$(awk '/enclosure_symlinks_prefix/{print $2}' \"$CONFIG\")\n\tif [ -z \"$ENCLOSURE_PREFIX\" ] ; then\n\t\tENCLOSURE_PREFIX=\"enc\"\n\tfi\n\techo \"ID_ENCLOSURE=$ID_ENCLOSURE\"\n\techo \"ID_ENCLOSURE_PATH=by-enclosure/$ENCLOSURE_PREFIX-$ID_ENCLOSURE\"\n\texit 0\nfi\n\n# First check if an alias was defined for this device.\nID_VDEV=$(alias_handler)\n\nif [ -z \"$ID_VDEV\" ] ; then\n\tBAY=${BAY:-bay}\n\tcase $TOPOLOGY in\n\t\tsas_direct|sas_switch)\n\t\t\tID_VDEV=$(sas_handler)\n\t\t\t;;\n\t\tscsi)\n\t\t\tID_VDEV=$(scsi_handler)\n\t\t\t;;\n\t\t*)\n\t\t\techo \"Error: unknown topology $TOPOLOGY\"\n\t\t\texit 1\n\t\t\t;;\n\tesac\nfi\n\nif [ -n \"$ID_VDEV\" ] ; then\n\techo \"ID_VDEV=${ID_VDEV}\"\n\techo \"ID_VDEV_PATH=disk/by-vdev/${ID_VDEV}\"\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}