{
  "module_name": "zfs_config.h.in",
  "hash_id": "d050d1d32a11c2f99e158eb26e59863bfd3241593effa754b0a53d07f2905e66",
  "original_prompt": "Ingested from zfs-2.2.2/zfs_config.h.in",
  "human_readable_source": "/* zfs_config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* Define to 1 if translation of program messages to the user's native\n   language is requested. */\n#undef ENABLE_NLS\n\n/* bio_end_io_t wants 1 arg */\n#undef HAVE_1ARG_BIO_END_IO_T\n\n/* lookup_bdev() wants 1 arg */\n#undef HAVE_1ARG_LOOKUP_BDEV\n\n/* submit_bio() wants 1 arg */\n#undef HAVE_1ARG_SUBMIT_BIO\n\n/* bdi_setup_and_register() wants 2 args */\n#undef HAVE_2ARGS_BDI_SETUP_AND_REGISTER\n\n/* vfs_getattr wants 2 args */\n#undef HAVE_2ARGS_VFS_GETATTR\n\n/* zlib_deflate_workspacesize() wants 2 args */\n#undef HAVE_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE\n\n/* bdi_setup_and_register() wants 3 args */\n#undef HAVE_3ARGS_BDI_SETUP_AND_REGISTER\n\n/* vfs_getattr wants 3 args */\n#undef HAVE_3ARGS_VFS_GETATTR\n\n/* vfs_getattr wants 4 args */\n#undef HAVE_4ARGS_VFS_GETATTR\n\n/* kernel has access_ok with 'type' parameter */\n#undef HAVE_ACCESS_OK_TYPE\n\n/* posix_acl has refcount_t */\n#undef HAVE_ACL_REFCOUNT\n\n/* add_disk() returns int */\n#undef HAVE_ADD_DISK_RET\n\n/* Define if host toolchain supports AES */\n#undef HAVE_AES\n\n/* Define if you have [rt] */\n#undef HAVE_AIO_H\n\n/* Define if host toolchain supports AVX */\n#undef HAVE_AVX\n\n/* Define if host toolchain supports AVX2 */\n#undef HAVE_AVX2\n\n/* Define if host toolchain supports AVX512BW */\n#undef HAVE_AVX512BW\n\n/* Define if host toolchain supports AVX512CD */\n#undef HAVE_AVX512CD\n\n/* Define if host toolchain supports AVX512DQ */\n#undef HAVE_AVX512DQ\n\n/* Define if host toolchain supports AVX512ER */\n#undef HAVE_AVX512ER\n\n/* Define if host toolchain supports AVX512F */\n#undef HAVE_AVX512F\n\n/* Define if host toolchain supports AVX512IFMA */\n#undef HAVE_AVX512IFMA\n\n/* Define if host toolchain supports AVX512PF */\n#undef HAVE_AVX512PF\n\n/* Define if host toolchain supports AVX512VBMI */\n#undef HAVE_AVX512VBMI\n\n/* Define if host toolchain supports AVX512VL */\n#undef HAVE_AVX512VL\n\n/* bdevname() is available */\n#undef HAVE_BDEVNAME\n\n/* bdev_check_media_change() exists */\n#undef HAVE_BDEV_CHECK_MEDIA_CHANGE\n\n/* bdev_*_io_acct() available */\n#undef HAVE_BDEV_IO_ACCT_63\n\n/* bdev_*_io_acct() available */\n#undef HAVE_BDEV_IO_ACCT_OLD\n\n/* bdev_kobj() exists */\n#undef HAVE_BDEV_KOBJ\n\n/* bdev_max_discard_sectors() is available */\n#undef HAVE_BDEV_MAX_DISCARD_SECTORS\n\n/* bdev_max_secure_erase_sectors() is available */\n#undef HAVE_BDEV_MAX_SECURE_ERASE_SECTORS\n\n/* block_device_operations->submit_bio() returns void */\n#undef HAVE_BDEV_SUBMIT_BIO_RETURNS_VOID\n\n/* bdev_whole() is available */\n#undef HAVE_BDEV_WHOLE\n\n/* bio_alloc() takes 4 arguments */\n#undef HAVE_BIO_ALLOC_4ARG\n\n/* bio->bi_bdev->bd_disk exists */\n#undef HAVE_BIO_BDEV_DISK\n\n/* bio->bi_opf is defined */\n#undef HAVE_BIO_BI_OPF\n\n/* bio->bi_status exists */\n#undef HAVE_BIO_BI_STATUS\n\n/* bio has bi_iter */\n#undef HAVE_BIO_BVEC_ITER\n\n/* bio_*_io_acct() available */\n#undef HAVE_BIO_IO_ACCT\n\n/* bio_max_segs() is implemented */\n#undef HAVE_BIO_MAX_SEGS\n\n/* bio_set_dev() is available */\n#undef HAVE_BIO_SET_DEV\n\n/* bio_set_dev() GPL-only */\n#undef HAVE_BIO_SET_DEV_GPL_ONLY\n\n/* bio_set_dev() is a macro */\n#undef HAVE_BIO_SET_DEV_MACRO\n\n/* bio_set_op_attrs is available */\n#undef HAVE_BIO_SET_OP_ATTRS\n\n/* blkdev_get_by_path() exists and takes 4 args */\n#undef HAVE_BLKDEV_GET_BY_PATH_4ARG\n\n/* blkdev_get_by_path() handles ERESTARTSYS */\n#undef HAVE_BLKDEV_GET_ERESTARTSYS\n\n/* blkdev_issue_discard() is available */\n#undef HAVE_BLKDEV_ISSUE_DISCARD\n\n/* blkdev_issue_secure_erase() is available */\n#undef HAVE_BLKDEV_ISSUE_SECURE_ERASE\n\n/* blkdev_put() accepts void* as arg 2 */\n#undef HAVE_BLKDEV_PUT_HOLDER\n\n/* blkdev_reread_part() exists */\n#undef HAVE_BLKDEV_REREAD_PART\n\n/* blkg_tryget() is available */\n#undef HAVE_BLKG_TRYGET\n\n/* blkg_tryget() GPL-only */\n#undef HAVE_BLKG_TRYGET_GPL_ONLY\n\n/* blk_alloc_disk() exists */\n#undef HAVE_BLK_ALLOC_DISK\n\n/* blk_alloc_queue() expects request function */\n#undef HAVE_BLK_ALLOC_QUEUE_REQUEST_FN\n\n/* blk_alloc_queue_rh() expects request function */\n#undef HAVE_BLK_ALLOC_QUEUE_REQUEST_FN_RH\n\n/* blk_cleanup_disk() exists */\n#undef HAVE_BLK_CLEANUP_DISK\n\n/* blk_mode_t is defined */\n#undef HAVE_BLK_MODE_T\n\n/* block multiqueue is available */\n#undef HAVE_BLK_MQ\n\n/* blk queue backing_dev_info is dynamic */\n#undef HAVE_BLK_QUEUE_BDI_DYNAMIC\n\n/* blk_queue_discard() is available */\n#undef HAVE_BLK_QUEUE_DISCARD\n\n/* blk_queue_flag_clear() exists */\n#undef HAVE_BLK_QUEUE_FLAG_CLEAR\n\n/* blk_queue_flag_set() exists */\n#undef HAVE_BLK_QUEUE_FLAG_SET\n\n/* blk_queue_flush() is available */\n#undef HAVE_BLK_QUEUE_FLUSH\n\n/* blk_queue_flush() is GPL-only */\n#undef HAVE_BLK_QUEUE_FLUSH_GPL_ONLY\n\n/* blk_queue_secdiscard() is available */\n#undef HAVE_BLK_QUEUE_SECDISCARD\n\n/* blk_queue_secure_erase() is available */\n#undef HAVE_BLK_QUEUE_SECURE_ERASE\n\n/* blk_queue_update_readahead() exists */\n#undef HAVE_BLK_QUEUE_UPDATE_READAHEAD\n\n/* blk_queue_write_cache() exists */\n#undef HAVE_BLK_QUEUE_WRITE_CACHE\n\n/* blk_queue_write_cache() is GPL-only */\n#undef HAVE_BLK_QUEUE_WRITE_CACHE_GPL_ONLY\n\n/* BLK_STS_RESV_CONFLICT is defined */\n#undef HAVE_BLK_STS_RESV_CONFLICT\n\n/* Define if release() in block_device_operations takes 1 arg */\n#undef HAVE_BLOCK_DEVICE_OPERATIONS_RELEASE_1ARG\n\n/* Define if revalidate_disk() in block_device_operations */\n#undef HAVE_BLOCK_DEVICE_OPERATIONS_REVALIDATE_DISK\n\n/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the\n   CoreFoundation framework. */\n#undef HAVE_CFLOCALECOPYCURRENT\n\n/* Define to 1 if you have the Mac OS X function\n   CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */\n#undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES\n\n/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in\n   the CoreFoundation framework. */\n#undef HAVE_CFPREFERENCESCOPYAPPVALUE\n\n/* check_disk_change() exists */\n#undef HAVE_CHECK_DISK_CHANGE\n\n/* clear_inode() is available */\n#undef HAVE_CLEAR_INODE\n\n/* dentry uses const struct dentry_operations */\n#undef HAVE_CONST_DENTRY_OPERATIONS\n\n/* copy_from_iter() is available */\n#undef HAVE_COPY_FROM_ITER\n\n/* copy_splice_read exists */\n#undef HAVE_COPY_SPLICE_READ\n\n/* copy_to_iter() is available */\n#undef HAVE_COPY_TO_ITER\n\n/* cpu_has_feature() is GPL-only */\n#undef HAVE_CPU_HAS_FEATURE_GPL_ONLY\n\n/* yes */\n#undef HAVE_CPU_HOTPLUG\n\n/* current_time() exists */\n#undef HAVE_CURRENT_TIME\n\n/* Define if the GNU dcgettext() function is already present or preinstalled.\n   */\n#undef HAVE_DCGETTEXT\n\n/* DECLARE_EVENT_CLASS() is available */\n#undef HAVE_DECLARE_EVENT_CLASS\n\n/* dentry aliases are in d_u member */\n#undef HAVE_DENTRY_D_U_ALIASES\n\n/* dequeue_signal() takes 4 arguments */\n#undef HAVE_DEQUEUE_SIGNAL_4ARG\n\n/* lookup_bdev() wants dev_t arg */\n#undef HAVE_DEVT_LOOKUP_BDEV\n\n/* sops->dirty_inode() wants flags */\n#undef HAVE_DIRTY_INODE_WITH_FLAGS\n\n/* disk_check_media_change() exists */\n#undef HAVE_DISK_CHECK_MEDIA_CHANGE\n\n/* disk_*_io_acct() available */\n#undef HAVE_DISK_IO_ACCT\n\n/* disk_update_readahead() exists */\n#undef HAVE_DISK_UPDATE_READAHEAD\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* d_make_root() is available */\n#undef HAVE_D_MAKE_ROOT\n\n/* d_prune_aliases() is available */\n#undef HAVE_D_PRUNE_ALIASES\n\n/* dops->d_revalidate() operation takes nameidata */\n#undef HAVE_D_REVALIDATE_NAMEIDATA\n\n/* eops->encode_fh() wants child and parent inodes */\n#undef HAVE_ENCODE_FH_WITH_INODE\n\n/* sops->evict_inode() exists */\n#undef HAVE_EVICT_INODE\n\n/* FALLOC_FL_ZERO_RANGE is defined */\n#undef HAVE_FALLOC_FL_ZERO_RANGE\n\n/* fault_in_iov_iter_readable() is available */\n#undef HAVE_FAULT_IN_IOV_ITER_READABLE\n\n/* filemap_range_has_page() is available */\n#undef HAVE_FILEMAP_RANGE_HAS_PAGE\n\n/* fops->aio_fsync() exists */\n#undef HAVE_FILE_AIO_FSYNC\n\n/* file_dentry() is available */\n#undef HAVE_FILE_DENTRY\n\n/* fops->fadvise() exists */\n#undef HAVE_FILE_FADVISE\n\n/* file_inode() is available */\n#undef HAVE_FILE_INODE\n\n/* flush_dcache_page() is GPL-only */\n#undef HAVE_FLUSH_DCACHE_PAGE_GPL_ONLY\n\n/* iops->follow_link() cookie */\n#undef HAVE_FOLLOW_LINK_COOKIE\n\n/* iops->follow_link() nameidata */\n#undef HAVE_FOLLOW_LINK_NAMEIDATA\n\n/* Define if compiler supports -Wformat-overflow */\n#undef HAVE_FORMAT_OVERFLOW\n\n/* fsync_bdev() is declared in include/blkdev.h */\n#undef HAVE_FSYNC_BDEV\n\n/* fops->fsync() with range */\n#undef HAVE_FSYNC_RANGE\n\n/* fops->fsync() without dentry */\n#undef HAVE_FSYNC_WITHOUT_DENTRY\n\n/* yes */\n#undef HAVE_GENERIC_FADVISE\n\n/* generic_fillattr requires struct mnt_idmap* */\n#undef HAVE_GENERIC_FILLATTR_IDMAP\n\n/* generic_fillattr requires struct mnt_idmap* and u32 request_mask */\n#undef HAVE_GENERIC_FILLATTR_IDMAP_REQMASK\n\n/* generic_fillattr requires struct user_namespace* */\n#undef HAVE_GENERIC_FILLATTR_USERNS\n\n/* generic_*_io_acct() 3 arg available */\n#undef HAVE_GENERIC_IO_ACCT_3ARG\n\n/* generic_*_io_acct() 4 arg available */\n#undef HAVE_GENERIC_IO_ACCT_4ARG\n\n/* generic_readlink is global */\n#undef HAVE_GENERIC_READLINK\n\n/* generic_setxattr() exists */\n#undef HAVE_GENERIC_SETXATTR\n\n/* generic_write_checks() takes kiocb */\n#undef HAVE_GENERIC_WRITE_CHECKS_KIOCB\n\n/* Define if the GNU gettext() function is already present or preinstalled. */\n#undef HAVE_GETTEXT\n\n/* iops->get_acl() exists */\n#undef HAVE_GET_ACL\n\n/* iops->get_acl() takes rcu */\n#undef HAVE_GET_ACL_RCU\n\n/* has iops->get_inode_acl() */\n#undef HAVE_GET_INODE_ACL\n\n/* iops->get_link() cookie */\n#undef HAVE_GET_LINK_COOKIE\n\n/* iops->get_link() delayed */\n#undef HAVE_GET_LINK_DELAYED\n\n/* group_info->gid exists */\n#undef HAVE_GROUP_INFO_GID\n\n/* has_capability() is available */\n#undef HAVE_HAS_CAPABILITY\n\n/* iattr->ia_vfsuid and iattr->ia_vfsgid exist */\n#undef HAVE_IATTR_VFSID\n\n/* Define if you have the iconv() function and it works. */\n#undef HAVE_ICONV\n\n/* iops->getattr() takes struct mnt_idmap* */\n#undef HAVE_IDMAP_IOPS_GETATTR\n\n/* iops->setattr() takes struct mnt_idmap* */\n#undef HAVE_IDMAP_IOPS_SETATTR\n\n/* APIs for idmapped mount are present */\n#undef HAVE_IDMAP_MNT_API\n\n/* Define if compiler supports -Wimplicit-fallthrough */\n#undef HAVE_IMPLICIT_FALLTHROUGH\n\n/* Define if compiler supports -Winfinite-recursion */\n#undef HAVE_INFINITE_RECURSION\n\n/* inode_get_ctime() exists in linux/fs.h */\n#undef HAVE_INODE_GET_CTIME\n\n/* yes */\n#undef HAVE_INODE_LOCK_SHARED\n\n/* inode_owner_or_capable() exists */\n#undef HAVE_INODE_OWNER_OR_CAPABLE\n\n/* inode_owner_or_capable() takes mnt_idmap */\n#undef HAVE_INODE_OWNER_OR_CAPABLE_IDMAP\n\n/* inode_owner_or_capable() takes user_ns */\n#undef HAVE_INODE_OWNER_OR_CAPABLE_USERNS\n\n/* inode_set_ctime_to_ts() exists in linux/fs.h */\n#undef HAVE_INODE_SET_CTIME_TO_TS\n\n/* inode_set_flags() exists */\n#undef HAVE_INODE_SET_FLAGS\n\n/* inode_set_iversion() exists */\n#undef HAVE_INODE_SET_IVERSION\n\n/* inode->i_*time's are timespec64 */\n#undef HAVE_INODE_TIMESPEC64_TIMES\n\n/* timestamp_truncate() exists */\n#undef HAVE_INODE_TIMESTAMP_TRUNCATE\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* in_compat_syscall() is available */\n#undef HAVE_IN_COMPAT_SYSCALL\n\n/* iops->create() takes struct mnt_idmap* */\n#undef HAVE_IOPS_CREATE_IDMAP\n\n/* iops->create() takes struct user_namespace* */\n#undef HAVE_IOPS_CREATE_USERNS\n\n/* iops->mkdir() takes struct mnt_idmap* */\n#undef HAVE_IOPS_MKDIR_IDMAP\n\n/* iops->mkdir() takes struct user_namespace* */\n#undef HAVE_IOPS_MKDIR_USERNS\n\n/* iops->mknod() takes struct mnt_idmap* */\n#undef HAVE_IOPS_MKNOD_IDMAP\n\n/* iops->mknod() takes struct user_namespace* */\n#undef HAVE_IOPS_MKNOD_USERNS\n\n/* iops->permission() takes struct mnt_idmap* */\n#undef HAVE_IOPS_PERMISSION_IDMAP\n\n/* iops->permission() takes struct user_namespace* */\n#undef HAVE_IOPS_PERMISSION_USERNS\n\n/* iops->rename() takes struct mnt_idmap* */\n#undef HAVE_IOPS_RENAME_IDMAP\n\n/* iops->rename() takes struct user_namespace* */\n#undef HAVE_IOPS_RENAME_USERNS\n\n/* iops->setattr() exists */\n#undef HAVE_IOPS_SETATTR\n\n/* iops->symlink() takes struct mnt_idmap* */\n#undef HAVE_IOPS_SYMLINK_IDMAP\n\n/* iops->symlink() takes struct user_namespace* */\n#undef HAVE_IOPS_SYMLINK_USERNS\n\n/* iov_iter_advance() is available */\n#undef HAVE_IOV_ITER_ADVANCE\n\n/* iov_iter_count() is available */\n#undef HAVE_IOV_ITER_COUNT\n\n/* iov_iter_fault_in_readable() is available */\n#undef HAVE_IOV_ITER_FAULT_IN_READABLE\n\n/* iov_iter_revert() is available */\n#undef HAVE_IOV_ITER_REVERT\n\n/* iov_iter_type() is available */\n#undef HAVE_IOV_ITER_TYPE\n\n/* iov_iter types are available */\n#undef HAVE_IOV_ITER_TYPES\n\n/* yes */\n#undef HAVE_IO_SCHEDULE_TIMEOUT\n\n/* Define to 1 if you have the `issetugid' function. */\n#undef HAVE_ISSETUGID\n\n/* iter_iov() is available */\n#undef HAVE_ITER_IOV\n\n/* kernel has kernel_fpu_* functions */\n#undef HAVE_KERNEL_FPU\n\n/* kernel has asm/fpu/api.h */\n#undef HAVE_KERNEL_FPU_API_HEADER\n\n/* kernel fpu internal */\n#undef HAVE_KERNEL_FPU_INTERNAL\n\n/* kernel has asm/fpu/internal.h */\n#undef HAVE_KERNEL_FPU_INTERNAL_HEADER\n\n/* uncached_acl_sentinel() exists */\n#undef HAVE_KERNEL_GET_ACL_HANDLE_CACHE\n\n/* Define if compiler supports -Winfinite-recursion */\n#undef HAVE_KERNEL_INFINITE_RECURSION\n\n/* kernel does stack verification */\n#undef HAVE_KERNEL_OBJTOOL\n\n/* kernel has linux/objtool.h */\n#undef HAVE_KERNEL_OBJTOOL_HEADER\n\n/* kernel_read() take loff_t pointer */\n#undef HAVE_KERNEL_READ_PPOS\n\n/* timer_list.function gets a timer_list */\n#undef HAVE_KERNEL_TIMER_FUNCTION_TIMER_LIST\n\n/* struct timer_list has a flags member */\n#undef HAVE_KERNEL_TIMER_LIST_FLAGS\n\n/* timer_setup() is available */\n#undef HAVE_KERNEL_TIMER_SETUP\n\n/* kernel_write() take loff_t pointer */\n#undef HAVE_KERNEL_WRITE_PPOS\n\n/* kmem_cache_create_usercopy() exists */\n#undef HAVE_KMEM_CACHE_CREATE_USERCOPY\n\n/* kstrtoul() exists */\n#undef HAVE_KSTRTOUL\n\n/* ktime_get_coarse_real_ts64() exists */\n#undef HAVE_KTIME_GET_COARSE_REAL_TS64\n\n/* ktime_get_raw_ts64() exists */\n#undef HAVE_KTIME_GET_RAW_TS64\n\n/* kvmalloc exists */\n#undef HAVE_KVMALLOC\n\n/* Define if you have [aio] */\n#undef HAVE_LIBAIO\n\n/* Define if you have [blkid] */\n#undef HAVE_LIBBLKID\n\n/* Define if you have [crypto] */\n#undef HAVE_LIBCRYPTO\n\n/* Define if you have [tirpc] */\n#undef HAVE_LIBTIRPC\n\n/* Define if you have [udev] */\n#undef HAVE_LIBUDEV\n\n/* Define if you have [uuid] */\n#undef HAVE_LIBUUID\n\n/* linux/blk-cgroup.h exists */\n#undef HAVE_LINUX_BLK_CGROUP_HEADER\n\n/* lseek_execute() is available */\n#undef HAVE_LSEEK_EXECUTE\n\n/* makedev() is declared in sys/mkdev.h */\n#undef HAVE_MAKEDEV_IN_MKDEV\n\n/* makedev() is declared in sys/sysmacros.h */\n#undef HAVE_MAKEDEV_IN_SYSMACROS\n\n/* Noting that make_request_fn() returns blk_qc_t */\n#undef HAVE_MAKE_REQUEST_FN_RET_QC\n\n/* Noting that make_request_fn() returns void */\n#undef HAVE_MAKE_REQUEST_FN_RET_VOID\n\n/* iops->mkdir() takes umode_t */\n#undef HAVE_MKDIR_UMODE_T\n\n/* Define to 1 if you have the `mlockall' function. */\n#undef HAVE_MLOCKALL\n\n/* lookup_bdev() wants mode arg */\n#undef HAVE_MODE_LOOKUP_BDEV\n\n/* Define if host toolchain supports MOVBE */\n#undef HAVE_MOVBE\n\n/* new_sync_read()/new_sync_write() are available */\n#undef HAVE_NEW_SYNC_READ\n\n/* folio_wait_bit() exists */\n#undef HAVE_PAGEMAP_FOLIO_WAIT_BIT\n\n/* part_to_dev() exists */\n#undef HAVE_PART_TO_DEV\n\n/* iops->getattr() takes a path */\n#undef HAVE_PATH_IOPS_GETATTR\n\n/* Define if host toolchain supports PCLMULQDQ */\n#undef HAVE_PCLMULQDQ\n\n/* percpu_counter_add_batch() is defined */\n#undef HAVE_PERCPU_COUNTER_ADD_BATCH\n\n/* percpu_counter_init() wants gfp_t */\n#undef HAVE_PERCPU_COUNTER_INIT_WITH_GFP\n\n/* posix_acl_chmod() exists */\n#undef HAVE_POSIX_ACL_CHMOD\n\n/* posix_acl_from_xattr() needs user_ns */\n#undef HAVE_POSIX_ACL_FROM_XATTR_USERNS\n\n/* posix_acl_release() is available */\n#undef HAVE_POSIX_ACL_RELEASE\n\n/* posix_acl_release() is GPL-only */\n#undef HAVE_POSIX_ACL_RELEASE_GPL_ONLY\n\n/* posix_acl_valid() wants user namespace */\n#undef HAVE_POSIX_ACL_VALID_WITH_NS\n\n/* proc_ops structure exists */\n#undef HAVE_PROC_OPS_STRUCT\n\n/* iops->put_link() cookie */\n#undef HAVE_PUT_LINK_COOKIE\n\n/* iops->put_link() delayed */\n#undef HAVE_PUT_LINK_DELAYED\n\n/* iops->put_link() nameidata */\n#undef HAVE_PUT_LINK_NAMEIDATA\n\n/* If available, contains the Python version number currently in use. */\n#undef HAVE_PYTHON\n\n/* qat is enabled and existed */\n#undef HAVE_QAT\n\n/* struct reclaim_state has reclaimed */\n#undef HAVE_RECLAIM_STATE_RECLAIMED\n\n/* register_shrinker is vararg */\n#undef HAVE_REGISTER_SHRINKER_VARARG\n\n/* register_sysctl_table exists */\n#undef HAVE_REGISTER_SYSCTL_TABLE\n\n/* iops->rename2() exists */\n#undef HAVE_RENAME2\n\n/* struct inode_operations_wrapper takes .rename2() */\n#undef HAVE_RENAME2_OPERATIONS_WRAPPER\n\n/* iops->rename() wants flags */\n#undef HAVE_RENAME_WANTS_FLAGS\n\n/* REQ_DISCARD is defined */\n#undef HAVE_REQ_DISCARD\n\n/* REQ_FLUSH is defined */\n#undef HAVE_REQ_FLUSH\n\n/* REQ_OP_DISCARD is defined */\n#undef HAVE_REQ_OP_DISCARD\n\n/* REQ_OP_FLUSH is defined */\n#undef HAVE_REQ_OP_FLUSH\n\n/* REQ_OP_SECURE_ERASE is defined */\n#undef HAVE_REQ_OP_SECURE_ERASE\n\n/* REQ_PREFLUSH is defined */\n#undef HAVE_REQ_PREFLUSH\n\n/* revalidate_disk() is available */\n#undef HAVE_REVALIDATE_DISK\n\n/* revalidate_disk_size() is available */\n#undef HAVE_REVALIDATE_DISK_SIZE\n\n/* struct rw_semaphore has member activity */\n#undef HAVE_RWSEM_ACTIVITY\n\n/* struct rw_semaphore has atomic_long_t member count */\n#undef HAVE_RWSEM_ATOMIC_LONG_COUNT\n\n/* linux/sched/signal.h exists */\n#undef HAVE_SCHED_SIGNAL_HEADER\n\n/* Define to 1 if you have the <security/pam_modules.h> header file. */\n#undef HAVE_SECURITY_PAM_MODULES_H\n\n/* setattr_prepare() accepts mnt_idmap */\n#undef HAVE_SETATTR_PREPARE_IDMAP\n\n/* setattr_prepare() is available, doesn't accept user_namespace */\n#undef HAVE_SETATTR_PREPARE_NO_USERNS\n\n/* setattr_prepare() accepts user_namespace */\n#undef HAVE_SETATTR_PREPARE_USERNS\n\n/* iops->set_acl() exists, takes 3 args */\n#undef HAVE_SET_ACL\n\n/* iops->set_acl() takes 4 args, arg1 is struct mnt_idmap * */\n#undef HAVE_SET_ACL_IDMAP_DENTRY\n\n/* iops->set_acl() takes 4 args */\n#undef HAVE_SET_ACL_USERNS\n\n/* iops->set_acl() takes 4 args, arg2 is struct dentry * */\n#undef HAVE_SET_ACL_USERNS_DENTRY_ARG2\n\n/* set_cached_acl() is usable */\n#undef HAVE_SET_CACHED_ACL_USABLE\n\n/* set_special_state() exists */\n#undef HAVE_SET_SPECIAL_STATE\n\n/* struct shrink_control exists */\n#undef HAVE_SHRINK_CONTROL_STRUCT\n\n/* kernel_siginfo_t exists */\n#undef HAVE_SIGINFO\n\n/* signal_stop() exists */\n#undef HAVE_SIGNAL_STOP\n\n/* new shrinker callback wants 2 args */\n#undef HAVE_SINGLE_SHRINKER_CALLBACK\n\n/* cs->count_objects exists */\n#undef HAVE_SPLIT_SHRINKER_CALLBACK\n\n/* Define if host toolchain supports SSE */\n#undef HAVE_SSE\n\n/* Define if host toolchain supports SSE2 */\n#undef HAVE_SSE2\n\n/* Define if host toolchain supports SSE3 */\n#undef HAVE_SSE3\n\n/* Define if host toolchain supports SSE4.1 */\n#undef HAVE_SSE4_1\n\n/* Define if host toolchain supports SSE4.2 */\n#undef HAVE_SSE4_2\n\n/* Define if host toolchain supports SSSE3 */\n#undef HAVE_SSSE3\n\n/* STACK_FRAME_NON_STANDARD is defined */\n#undef HAVE_STACK_FRAME_NON_STANDARD\n\n/* standalone <linux/stdarg.h> exists */\n#undef HAVE_STANDALONE_LINUX_STDARG\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdio.h> header file. */\n#undef HAVE_STDIO_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the `strlcat' function. */\n#undef HAVE_STRLCAT\n\n/* Define to 1 if you have the `strlcpy' function. */\n#undef HAVE_STRLCPY\n\n/* submit_bio is member of struct block_device_operations */\n#undef HAVE_SUBMIT_BIO_IN_BLOCK_DEVICE_OPERATIONS\n\n/* super_setup_bdi_name() exits */\n#undef HAVE_SUPER_SETUP_BDI_NAME\n\n/* super_block->s_user_ns exists */\n#undef HAVE_SUPER_USER_NS\n\n/* sync_blockdev() is declared in include/blkdev.h */\n#undef HAVE_SYNC_BLOCKDEV\n\n/* struct kobj_type has default_groups */\n#undef HAVE_SYSFS_DEFAULT_GROUPS\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* i_op->tmpfile() exists */\n#undef HAVE_TMPFILE\n\n/* i_op->tmpfile() uses old dentry signature */\n#undef HAVE_TMPFILE_DENTRY\n\n/* i_op->tmpfile() has mnt_idmap */\n#undef HAVE_TMPFILE_IDMAP\n\n/* i_op->tmpfile() has userns */\n#undef HAVE_TMPFILE_USERNS\n\n/* totalhigh_pages() exists */\n#undef HAVE_TOTALHIGH_PAGES\n\n/* kernel has totalram_pages() */\n#undef HAVE_TOTALRAM_PAGES_FUNC\n\n/* Define to 1 if you have the `udev_device_get_is_initialized' function. */\n#undef HAVE_UDEV_DEVICE_GET_IS_INITIALIZED\n\n/* kernel has __kernel_fpu_* functions */\n#undef HAVE_UNDERSCORE_KERNEL_FPU\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* iops->getattr() takes struct user_namespace* */\n#undef HAVE_USERNS_IOPS_GETATTR\n\n/* iops->setattr() takes struct user_namespace* */\n#undef HAVE_USERNS_IOPS_SETATTR\n\n/* user_namespace->ns.inum exists */\n#undef HAVE_USER_NS_COMMON_INUM\n\n/* iops->getattr() takes a vfsmount */\n#undef HAVE_VFSMOUNT_IOPS_GETATTR\n\n/* fops->clone_file_range() is available */\n#undef HAVE_VFS_CLONE_FILE_RANGE\n\n/* fops->copy_file_range() is available */\n#undef HAVE_VFS_COPY_FILE_RANGE\n\n/* fops->dedupe_file_range() is available */\n#undef HAVE_VFS_DEDUPE_FILE_RANGE\n\n/* aops->direct_IO() uses iovec */\n#undef HAVE_VFS_DIRECT_IO_IOVEC\n\n/* aops->direct_IO() uses iov_iter without rw */\n#undef HAVE_VFS_DIRECT_IO_ITER\n\n/* aops->direct_IO() uses iov_iter with offset */\n#undef HAVE_VFS_DIRECT_IO_ITER_OFFSET\n\n/* aops->direct_IO() uses iov_iter with rw and offset */\n#undef HAVE_VFS_DIRECT_IO_ITER_RW_OFFSET\n\n/* filemap_dirty_folio exists */\n#undef HAVE_VFS_FILEMAP_DIRTY_FOLIO\n\n/* file_operations_extend takes .copy_file_range() and .clone_file_range() */\n#undef HAVE_VFS_FILE_OPERATIONS_EXTEND\n\n/* generic_copy_file_range() is available */\n#undef HAVE_VFS_GENERIC_COPY_FILE_RANGE\n\n/* All required iov_iter interfaces are available */\n#undef HAVE_VFS_IOV_ITER\n\n/* fops->iterate() is available */\n#undef HAVE_VFS_ITERATE\n\n/* fops->iterate_shared() is available */\n#undef HAVE_VFS_ITERATE_SHARED\n\n/* fops->readdir() is available */\n#undef HAVE_VFS_READDIR\n\n/* address_space_operations->readpages exists */\n#undef HAVE_VFS_READPAGES\n\n/* read_folio exists */\n#undef HAVE_VFS_READ_FOLIO\n\n/* fops->remap_file_range() is available */\n#undef HAVE_VFS_REMAP_FILE_RANGE\n\n/* fops->read/write_iter() are available */\n#undef HAVE_VFS_RW_ITERATE\n\n/* __set_page_dirty_nobuffers exists */\n#undef HAVE_VFS_SET_PAGE_DIRTY_NOBUFFERS\n\n/* __vmalloc page flags exists */\n#undef HAVE_VMALLOC_PAGE_KERNEL\n\n/* yes */\n#undef HAVE_WAIT_ON_BIT_ACTION\n\n/* wait_queue_entry_t exists */\n#undef HAVE_WAIT_QUEUE_ENTRY_T\n\n/* wq_head->head and wq_entry->entry exist */\n#undef HAVE_WAIT_QUEUE_HEAD_ENTRY\n\n/* int (*writepage_t)() takes struct folio* */\n#undef HAVE_WRITEPAGE_T_FOLIO\n\n/* xattr_handler->get() wants dentry */\n#undef HAVE_XATTR_GET_DENTRY\n\n/* xattr_handler->get() wants both dentry and inode */\n#undef HAVE_XATTR_GET_DENTRY_INODE\n\n/* xattr_handler->get() wants dentry and inode and flags */\n#undef HAVE_XATTR_GET_DENTRY_INODE_FLAGS\n\n/* xattr_handler->get() wants xattr_handler */\n#undef HAVE_XATTR_GET_HANDLER\n\n/* xattr_handler has name */\n#undef HAVE_XATTR_HANDLER_NAME\n\n/* xattr_handler->list() wants dentry */\n#undef HAVE_XATTR_LIST_DENTRY\n\n/* xattr_handler->list() wants xattr_handler */\n#undef HAVE_XATTR_LIST_HANDLER\n\n/* xattr_handler->list() wants simple */\n#undef HAVE_XATTR_LIST_SIMPLE\n\n/* xattr_handler->set() wants dentry */\n#undef HAVE_XATTR_SET_DENTRY\n\n/* xattr_handler->set() wants both dentry and inode */\n#undef HAVE_XATTR_SET_DENTRY_INODE\n\n/* xattr_handler->set() wants xattr_handler */\n#undef HAVE_XATTR_SET_HANDLER\n\n/* xattr_handler->set() takes mnt_idmap */\n#undef HAVE_XATTR_SET_IDMAP\n\n/* xattr_handler->set() takes user_namespace */\n#undef HAVE_XATTR_SET_USERNS\n\n/* Define if host toolchain supports XSAVE */\n#undef HAVE_XSAVE\n\n/* Define if host toolchain supports XSAVEOPT */\n#undef HAVE_XSAVEOPT\n\n/* Define if host toolchain supports XSAVES */\n#undef HAVE_XSAVES\n\n/* ZERO_PAGE() is GPL-only */\n#undef HAVE_ZERO_PAGE_GPL_ONLY\n\n/* Define if you have [z] */\n#undef HAVE_ZLIB\n\n/* __posix_acl_chmod() exists */\n#undef HAVE___POSIX_ACL_CHMOD\n\n/* kernel exports FPU functions */\n#undef KERNEL_EXPORTS_X86_FPU\n\n/* whether the chosen libfetch is to be loaded at run-time */\n#undef LIBFETCH_DYNAMIC\n\n/* libfetch is fetch(3) */\n#undef LIBFETCH_IS_FETCH\n\n/* libfetch is libcurl */\n#undef LIBFETCH_IS_LIBCURL\n\n/* soname of chosen libfetch */\n#undef LIBFETCH_SONAME\n\n/* Define to the sub-directory where libtool stores uninstalled libraries. */\n#undef LT_OBJDIR\n\n/* make_request_fn() return type */\n#undef MAKE_REQUEST_FN_RET\n\n/* Name of package */\n#undef PACKAGE\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* struct shrink_control has nid */\n#undef SHRINK_CONTROL_HAS_NID\n\n/* using complete_and_exit() instead */\n#undef SPL_KTHREAD_COMPLETE_AND_EXIT\n\n/* Defined for legacy compatibility. */\n#undef SPL_META_ALIAS\n\n/* Defined for legacy compatibility. */\n#undef SPL_META_RELEASE\n\n/* Defined for legacy compatibility. */\n#undef SPL_META_VERSION\n\n/* pde_data() is PDE_DATA() */\n#undef SPL_PDE_DATA\n\n/* Define to 1 if all of the C90 standard headers exist (not just the ones\n   required in a freestanding environment). This macro is provided for\n   backward compatibility; new code need not use it. */\n#undef STDC_HEADERS\n\n/* True if ZFS is to be compiled for a FreeBSD system */\n#undef SYSTEM_FREEBSD\n\n/* True if ZFS is to be compiled for a Linux system */\n#undef SYSTEM_LINUX\n\n/* Version number of package */\n#undef VERSION\n\n/* zfs debugging enabled */\n#undef ZFS_DEBUG\n\n/* /dev/zfs minor */\n#undef ZFS_DEVICE_MINOR\n\n/* enum node_stat_item contains NR_FILE_PAGES */\n#undef ZFS_ENUM_NODE_STAT_ITEM_NR_FILE_PAGES\n\n/* enum node_stat_item contains NR_INACTIVE_ANON */\n#undef ZFS_ENUM_NODE_STAT_ITEM_NR_INACTIVE_ANON\n\n/* enum node_stat_item contains NR_INACTIVE_FILE */\n#undef ZFS_ENUM_NODE_STAT_ITEM_NR_INACTIVE_FILE\n\n/* enum zone_stat_item contains NR_FILE_PAGES */\n#undef ZFS_ENUM_ZONE_STAT_ITEM_NR_FILE_PAGES\n\n/* enum zone_stat_item contains NR_INACTIVE_ANON */\n#undef ZFS_ENUM_ZONE_STAT_ITEM_NR_INACTIVE_ANON\n\n/* enum zone_stat_item contains NR_INACTIVE_FILE */\n#undef ZFS_ENUM_ZONE_STAT_ITEM_NR_INACTIVE_FILE\n\n/* GENHD_FL_EXT_DEVT flag is not available */\n#undef ZFS_GENHD_FL_EXT_DEVT\n\n/* GENHD_FL_NO_PART_SCAN flag is available */\n#undef ZFS_GENHD_FL_NO_PART\n\n/* global_node_page_state() exists */\n#undef ZFS_GLOBAL_NODE_PAGE_STATE\n\n/* global_zone_page_state() exists */\n#undef ZFS_GLOBAL_ZONE_PAGE_STATE\n\n/* Define to 1 if GPL-only symbols can be used */\n#undef ZFS_IS_GPL_COMPATIBLE\n\n/* Define the project alias string. */\n#undef ZFS_META_ALIAS\n\n/* Define the project author. */\n#undef ZFS_META_AUTHOR\n\n/* Define the project release date. */\n#undef ZFS_META_DATA\n\n/* Define the maximum compatible kernel version. */\n#undef ZFS_META_KVER_MAX\n\n/* Define the minimum compatible kernel version. */\n#undef ZFS_META_KVER_MIN\n\n/* Define the project license. */\n#undef ZFS_META_LICENSE\n\n/* Define the libtool library 'age' version information. */\n#undef ZFS_META_LT_AGE\n\n/* Define the libtool library 'current' version information. */\n#undef ZFS_META_LT_CURRENT\n\n/* Define the libtool library 'revision' version information. */\n#undef ZFS_META_LT_REVISION\n\n/* Define the project name. */\n#undef ZFS_META_NAME\n\n/* Define the project release. */\n#undef ZFS_META_RELEASE\n\n/* Define the project version. */\n#undef ZFS_META_VERSION\n\n/* count is located in percpu_ref.data */\n#undef ZFS_PERCPU_REF_COUNT_IN_DATA\n\n\n#undef PACKAGE\n#undef PACKAGE_BUGREPORT\n#undef PACKAGE_NAME\n#undef PACKAGE_STRING\n#undef PACKAGE_TARNAME\n#undef PACKAGE_VERSION\n#undef STDC_HEADERS\n#undef VERSION\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}