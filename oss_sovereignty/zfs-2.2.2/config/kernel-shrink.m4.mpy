{
  "module_name": "kernel-shrink.m4",
  "hash_id": "2b5dce83f15b9e7b213714b404540fa8db46af63ba18cd5a0b8246e2b4df6aa5",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-shrink.m4",
  "human_readable_source": "dnl #\ndnl # 3.1 API change\ndnl # The super_block structure now stores a per-filesystem shrinker.\ndnl # This interface is preferable because it can be used to specifically\ndnl # target only the zfs filesystem for pruning.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_SUPER_BLOCK_S_SHRINK], [\n\tZFS_LINUX_TEST_SRC([super_block_s_shrink], [\n\t\t#include <linux/fs.h>\n\n\t\tint shrink(struct shrinker *s, struct shrink_control *sc)\n\t\t    { return 0; }\n\n\t\tstatic const struct super_block\n\t\t    sb __attribute__ ((unused)) = {\n\t\t\t.s_shrink.seeks = DEFAULT_SEEKS,\n\t\t\t.s_shrink.batch = 0,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SUPER_BLOCK_S_SHRINK], [\n\tAC_MSG_CHECKING([whether super_block has s_shrink])\n\tZFS_LINUX_TEST_RESULT([super_block_s_shrink], [\n\t\tAC_MSG_RESULT(yes)\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([sb->s_shrink()])\n\t])\n])\n\ndnl #\ndnl # 3.12 API change\ndnl # The nid member was added to struct shrink_control to support\ndnl # NUMA-aware shrinkers.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINK_CONTROL_HAS_NID], [\n\tZFS_LINUX_TEST_SRC([shrink_control_nid], [\n\t\t#include <linux/fs.h>\n\t],[\n\t\tstruct shrink_control sc __attribute__ ((unused));\n\t\tunsigned long scnidsize __attribute__ ((unused)) =\n\t\t    sizeof(sc.nid);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_HAS_NID], [\n\tAC_MSG_CHECKING([whether shrink_control has nid])\n\tZFS_LINUX_TEST_RESULT([shrink_control_nid], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(SHRINK_CONTROL_HAS_NID, 1,\n\t\t    [struct shrink_control has nid])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_REGISTER_SHRINKER_VARARG], [\n\tZFS_LINUX_TEST_SRC([register_shrinker_vararg], [\n\t\t#include <linux/mm.h>\n\t\tunsigned long shrinker_cb(struct shrinker *shrink,\n\t\t    struct shrink_control *sc) { return 0; }\n\t],[\n\t\tstruct shrinker cache_shrinker = {\n\t\t\t.count_objects = shrinker_cb,\n\t\t\t.scan_objects = shrinker_cb,\n\t\t\t.seeks = DEFAULT_SEEKS,\n\t\t};\n\t\tregister_shrinker(&cache_shrinker, \"vararg-reg-shrink-test\");\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINKER_CALLBACK], [\n\tZFS_LINUX_TEST_SRC([shrinker_cb_shrink_control], [\n\t\t#include <linux/mm.h>\n\t\tint shrinker_cb(struct shrinker *shrink,\n\t\t    struct shrink_control *sc) { return 0; }\n\t],[\n\t\tstruct shrinker cache_shrinker = {\n\t\t\t.shrink = shrinker_cb,\n\t\t\t.seeks = DEFAULT_SEEKS,\n\t\t};\n\t\tregister_shrinker(&cache_shrinker);\n\t])\n\n\tZFS_LINUX_TEST_SRC([shrinker_cb_shrink_control_split], [\n\t\t#include <linux/mm.h>\n\t\tunsigned long shrinker_cb(struct shrinker *shrink,\n\t\t    struct shrink_control *sc) { return 0; }\n\t],[\n\t\tstruct shrinker cache_shrinker = {\n\t\t\t.count_objects = shrinker_cb,\n\t\t\t.scan_objects = shrinker_cb,\n\t\t\t.seeks = DEFAULT_SEEKS,\n\t\t};\n\t\tregister_shrinker(&cache_shrinker);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SHRINKER_CALLBACK],[\n\tdnl #\n\tdnl # 6.0 API change\n\tdnl # register_shrinker() becomes a var-arg function that takes\n\tdnl # a printf-style format string as args > 0\n\tdnl #\n\tAC_MSG_CHECKING([whether new var-arg register_shrinker() exists])\n\tZFS_LINUX_TEST_RESULT([register_shrinker_vararg], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_REGISTER_SHRINKER_VARARG, 1,\n\t\t    [register_shrinker is vararg])\n\n\t\tdnl # We assume that the split shrinker callback exists if the\n\t\tdnl # vararg register_shrinker() exists, because the latter is\n\t\tdnl # a much more recent addition, and the macro test for the\n\t\tdnl # var-arg version only works if the callback is split\n\t\tAC_DEFINE(HAVE_SPLIT_SHRINKER_CALLBACK, 1,\n\t\t\t[cs->count_objects exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tdnl #\n\t\tdnl # 3.0 - 3.11 API change\n\t\tdnl # cs->shrink(struct shrinker *, struct shrink_control *sc)\n\t\tdnl #\n\t\tAC_MSG_CHECKING([whether new 2-argument shrinker exists])\n\t\tZFS_LINUX_TEST_RESULT([shrinker_cb_shrink_control], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SINGLE_SHRINKER_CALLBACK, 1,\n\t\t\t\t[new shrinker callback wants 2 args])\n\t\t],[\n\t\t\tAC_MSG_RESULT(no)\n\n\t\t\tdnl #\n\t\t\tdnl # 3.12 API change,\n\t\t\tdnl # cs->shrink() is logically split in to\n\t\t\tdnl # cs->count_objects() and cs->scan_objects()\n\t\t\tdnl #\n\t\t\tAC_MSG_CHECKING([if cs->count_objects callback exists])\n\t\t\tZFS_LINUX_TEST_RESULT(\n\t\t\t\t[shrinker_cb_shrink_control_split],[\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tAC_DEFINE(HAVE_SPLIT_SHRINKER_CALLBACK, 1,\n\t\t\t\t\t\t[cs->count_objects exists])\n\t\t\t],[\n\t\t\t\t\tZFS_LINUX_TEST_ERROR([shrinker])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 2.6.39 API change,\ndnl # Shrinker adjust to use common shrink_control structure.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINK_CONTROL_STRUCT], [\n\tZFS_LINUX_TEST_SRC([shrink_control_struct], [\n\t\t#include <linux/mm.h>\n\t],[\n\t\tstruct shrink_control sc __attribute__ ((unused));\n\n\t\tsc.nr_to_scan = 0;\n\t\tsc.gfp_mask = GFP_KERNEL;\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_STRUCT], [\n\tAC_MSG_CHECKING([whether struct shrink_control exists])\n\tZFS_LINUX_TEST_RESULT([shrink_control_struct], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SHRINK_CONTROL_STRUCT, 1,\n\t\t    [struct shrink_control exists])\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([shrink_control])\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINKER], [\n\tZFS_AC_KERNEL_SRC_SUPER_BLOCK_S_SHRINK\n\tZFS_AC_KERNEL_SRC_SHRINK_CONTROL_HAS_NID\n\tZFS_AC_KERNEL_SRC_SHRINKER_CALLBACK\n\tZFS_AC_KERNEL_SRC_SHRINK_CONTROL_STRUCT\n\tZFS_AC_KERNEL_SRC_REGISTER_SHRINKER_VARARG\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SHRINKER], [\n\tZFS_AC_KERNEL_SUPER_BLOCK_S_SHRINK\n\tZFS_AC_KERNEL_SHRINK_CONTROL_HAS_NID\n\tZFS_AC_KERNEL_SHRINKER_CALLBACK\n\tZFS_AC_KERNEL_SHRINK_CONTROL_STRUCT\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}