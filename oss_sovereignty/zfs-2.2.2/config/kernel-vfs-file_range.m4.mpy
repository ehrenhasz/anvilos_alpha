{
  "module_name": "kernel-vfs-file_range.m4",
  "hash_id": "b01c87630d8a8024fd96d0fd3148c68a608f1dcccd1660f8d1098efe6337570e",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-vfs-file_range.m4",
  "human_readable_source": "dnl #\ndnl # The *_file_range APIs have a long history:\ndnl #\ndnl # 2.6.29: BTRFS_IOC_CLONE and BTRFS_IOC_CLONE_RANGE ioctl introduced\ndnl # 3.12: BTRFS_IOC_FILE_EXTENT_SAME ioctl introduced\ndnl #\ndnl # 4.5: copy_file_range() syscall introduced, added to VFS\ndnl # 4.5: BTRFS_IOC_CLONE and BTRFS_IOC_CLONE_RANGE renamed to FICLONE ands\ndnl #      FICLONERANGE, added to VFS as clone_file_range()\ndnl # 4.5: BTRFS_IOC_FILE_EXTENT_SAME renamed to FIDEDUPERANGE, added to VFS\ndnl #      as dedupe_file_range()\ndnl #\ndnl # 4.20: VFS clone_file_range() and dedupe_file_range() replaced by\ndnl #       remap_file_range()\ndnl #\ndnl # 5.3: VFS copy_file_range() expected to do its own fallback,\ndnl #      generic_copy_file_range() added to support it\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_COPY_FILE_RANGE], [\n\tZFS_LINUX_TEST_SRC([vfs_copy_file_range], [\n\t\t#include <linux/fs.h>\n\n\t\tstatic ssize_t test_copy_file_range(struct file *src_file,\n\t\t    loff_t src_off, struct file *dst_file, loff_t dst_off,\n\t\t    size_t len, unsigned int flags) {\n\t\t\t(void) src_file; (void) src_off;\n\t\t\t(void) dst_file; (void) dst_off;\n\t\t\t(void) len; (void) flags;\n\t\t\treturn (0);\n\t\t}\n\n\t\tstatic const struct file_operations\n\t\t    fops __attribute__ ((unused)) = {\n\t\t\t.copy_file_range\t= test_copy_file_range,\n\t\t};\n\t],[])\n])\nAC_DEFUN([ZFS_AC_KERNEL_VFS_COPY_FILE_RANGE], [\n\tAC_MSG_CHECKING([whether fops->copy_file_range() is available])\n\tZFS_LINUX_TEST_RESULT([vfs_copy_file_range], [\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE(HAVE_VFS_COPY_FILE_RANGE, 1,\n\t\t    [fops->copy_file_range() is available])\n\t],[\n\t\tAC_MSG_RESULT([no])\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_GENERIC_COPY_FILE_RANGE], [\n\tZFS_LINUX_TEST_SRC([generic_copy_file_range], [\n\t\t#include <linux/fs.h>\n\t], [\n\t\tstruct file *src_file __attribute__ ((unused)) = NULL;\n\t\tloff_t src_off __attribute__ ((unused)) = 0;\n\t\tstruct file *dst_file __attribute__ ((unused)) = NULL;\n\t\tloff_t dst_off __attribute__ ((unused)) = 0;\n\t\tsize_t len __attribute__ ((unused)) = 0;\n\t\tunsigned int flags __attribute__ ((unused)) = 0;\n\t\tgeneric_copy_file_range(src_file, src_off, dst_file, dst_off,\n\t\t    len, flags);\n\t])\n])\nAC_DEFUN([ZFS_AC_KERNEL_VFS_GENERIC_COPY_FILE_RANGE], [\n\tAC_MSG_CHECKING([whether generic_copy_file_range() is available])\n\tZFS_LINUX_TEST_RESULT_SYMBOL([generic_copy_file_range],\n\t[generic_copy_file_range], [fs/read_write.c], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_VFS_GENERIC_COPY_FILE_RANGE, 1,\n\t\t    [generic_copy_file_range() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_CLONE_FILE_RANGE], [\n\tZFS_LINUX_TEST_SRC([vfs_clone_file_range], [\n\t\t#include <linux/fs.h>\n\n\t\tstatic int test_clone_file_range(struct file *src_file,\n\t\t    loff_t src_off, struct file *dst_file, loff_t dst_off,\n\t\t    u64 len) {\n\t\t\t(void) src_file; (void) src_off;\n\t\t\t(void) dst_file; (void) dst_off;\n\t\t\t(void) len;\n\t\t\treturn (0);\n\t\t}\n\n\t\tstatic const struct file_operations\n\t\t    fops __attribute__ ((unused)) = {\n\t\t\t.clone_file_range\t= test_clone_file_range,\n\t\t};\n\t],[])\n])\nAC_DEFUN([ZFS_AC_KERNEL_VFS_CLONE_FILE_RANGE], [\n\tAC_MSG_CHECKING([whether fops->clone_file_range() is available])\n\tZFS_LINUX_TEST_RESULT([vfs_clone_file_range], [\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE(HAVE_VFS_CLONE_FILE_RANGE, 1,\n\t\t    [fops->clone_file_range() is available])\n\t],[\n\t\tAC_MSG_RESULT([no])\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_DEDUPE_FILE_RANGE], [\n\tZFS_LINUX_TEST_SRC([vfs_dedupe_file_range], [\n\t\t#include <linux/fs.h>\n\n\t\tstatic int test_dedupe_file_range(struct file *src_file,\n\t\t    loff_t src_off, struct file *dst_file, loff_t dst_off,\n\t\t    u64 len) {\n\t\t\t(void) src_file; (void) src_off;\n\t\t\t(void) dst_file; (void) dst_off;\n\t\t\t(void) len;\n\t\t\treturn (0);\n\t\t}\n\n\t\tstatic const struct file_operations\n\t\t    fops __attribute__ ((unused)) = {\n                .dedupe_file_range\t= test_dedupe_file_range,\n\t\t};\n\t],[])\n])\nAC_DEFUN([ZFS_AC_KERNEL_VFS_DEDUPE_FILE_RANGE], [\n\tAC_MSG_CHECKING([whether fops->dedupe_file_range() is available])\n\tZFS_LINUX_TEST_RESULT([vfs_dedupe_file_range], [\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE(HAVE_VFS_DEDUPE_FILE_RANGE, 1,\n\t\t    [fops->dedupe_file_range() is available])\n\t],[\n\t\tAC_MSG_RESULT([no])\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_REMAP_FILE_RANGE], [\n\tZFS_LINUX_TEST_SRC([vfs_remap_file_range], [\n\t\t#include <linux/fs.h>\n\n\t\tstatic loff_t test_remap_file_range(struct file *src_file,\n\t\t    loff_t src_off, struct file *dst_file, loff_t dst_off,\n\t\t    loff_t len, unsigned int flags) {\n\t\t\t(void) src_file; (void) src_off;\n\t\t\t(void) dst_file; (void) dst_off;\n\t\t\t(void) len; (void) flags;\n\t\t\treturn (0);\n\t\t}\n\n\t\tstatic const struct file_operations\n\t\t    fops __attribute__ ((unused)) = {\n\t\t\t.remap_file_range\t= test_remap_file_range,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_VFS_REMAP_FILE_RANGE], [\n\tAC_MSG_CHECKING([whether fops->remap_file_range() is available])\n\tZFS_LINUX_TEST_RESULT([vfs_remap_file_range], [\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE(HAVE_VFS_REMAP_FILE_RANGE, 1,\n\t\t    [fops->remap_file_range() is available])\n\t],[\n\t\tAC_MSG_RESULT([no])\n\t])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}