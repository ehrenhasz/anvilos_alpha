{
  "module_name": "kernel-wait.m4",
  "hash_id": "f15032843234c2ef6a1568172025431e27134cc3ef86574904f04640adc840bc",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-wait.m4",
  "human_readable_source": "dnl #\ndnl # 4.13 API change\ndnl # Renamed struct wait_queue -> struct wait_queue_entry.\ndnl #\ndnl # N.B. The type check is performed before all other checks\ndnl # since ZFS_AC_KERNEL_SRC_WAIT_QUEUE_HEAD_ENTRY depends on\ndnl # HAVE_WAIT_QUEUE_ENTRY_T being set in confdefs.h.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_ENTRY_T], [\n\tAC_MSG_CHECKING([whether wait_queue_entry_t exists])\n\tZFS_LINUX_TRY_COMPILE([\n\t\t#include <linux/wait.h>\n\t],[\n\t\twait_queue_entry_t *entry __attribute__ ((unused));\n\t],[\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_WAIT_QUEUE_ENTRY_T, 1,\n\t\t    [wait_queue_entry_t exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 3.17 API change,\ndnl # wait_on_bit() no longer requires an action argument. The former\ndnl # \"wait_on_bit\" interface required an 'action' function to be provided\ndnl # which does the actual waiting. There were over 20 such functions in the\ndnl # kernel, many of them identical, though most cases can be satisfied by one\ndnl # of just two functions: one which uses io_schedule() and one which just\ndnl # uses schedule().  This API change was made to consolidate all of those\ndnl # redundant wait functions.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_WAIT_ON_BIT], [\n\tZFS_LINUX_TEST_SRC([wait_on_bit], [\n\t\t#include <linux/wait.h>\n\t],[\n\t\tint (*action)(void *) = NULL;\n\t\twait_on_bit(NULL, 0, action, 0);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_WAIT_ON_BIT], [\n\tAC_MSG_CHECKING([whether wait_on_bit() takes an action])\n\tZFS_LINUX_TEST_RESULT([wait_on_bit], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_WAIT_ON_BIT_ACTION, 1, [yes])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 4.13 API change\ndnl # Renamed wait_queue_head::task_list -> wait_queue_head::head\ndnl # Renamed wait_queue_entry::task_list -> wait_queue_entry::entry\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_WAIT_QUEUE_HEAD_ENTRY], [\n\tZFS_LINUX_TEST_SRC([wait_queue_head_entry], [\n\t\t#include <linux/wait.h>\n\n\t\t#ifdef HAVE_WAIT_QUEUE_ENTRY_T\n\t\ttypedef wait_queue_head_t\tspl_wait_queue_head_t;\n\t\ttypedef wait_queue_entry_t\tspl_wait_queue_entry_t;\n\t\t#else\n\t\ttypedef wait_queue_head_t\tspl_wait_queue_head_t;\n\t\ttypedef wait_queue_t\t\tspl_wait_queue_entry_t;\n\t\t#endif\n\t],[\n\t\tspl_wait_queue_head_t wq_head;\n\t\tspl_wait_queue_entry_t wq_entry;\n\t\tstruct list_head *head __attribute__ ((unused));\n\t\tstruct list_head *entry __attribute__ ((unused));\n\n\t\thead = &wq_head.head;\n\t\tentry = &wq_entry.entry;\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_ENTRY], [\n\tAC_MSG_CHECKING([whether wq_head->head and wq_entry->entry exist])\n\tZFS_LINUX_TEST_RESULT([wait_queue_head_entry], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_WAIT_QUEUE_HEAD_ENTRY, 1,\n\t\t    [wq_head->head and wq_entry->entry exist])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_WAIT], [\n\tZFS_AC_KERNEL_SRC_WAIT_ON_BIT\n\tZFS_AC_KERNEL_SRC_WAIT_QUEUE_HEAD_ENTRY\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_WAIT], [\n\tZFS_AC_KERNEL_WAIT_ON_BIT\n\tZFS_AC_KERNEL_WAIT_QUEUE_HEAD_ENTRY\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}