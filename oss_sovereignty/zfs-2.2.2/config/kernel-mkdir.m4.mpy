{
  "module_name": "kernel-mkdir.m4",
  "hash_id": "60b0f3f21621bd574655306c05f6756b9f102e438f16691f3bae27e824b40ea8",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-mkdir.m4",
  "human_readable_source": "dnl #\ndnl # Supported mkdir() interfaces checked newest to oldest.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_MKDIR], [\n\tdnl #\n\tdnl # 6.3 API change\n\tdnl # mkdir() takes struct mnt_idmap * as the first arg\n\tdnl #\n\tZFS_LINUX_TEST_SRC([mkdir_mnt_idmap], [\n\t\t#include <linux/fs.h>\n\n\t\tint mkdir(struct mnt_idmap *idmap,\n\t\t\tstruct inode *inode, struct dentry *dentry,\n\t\t\tumode_t umode) { return 0; }\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.mkdir = mkdir,\n\t\t};\n\t],[])\n\n\tdnl #\n\tdnl # 5.12 API change\n\tdnl # The struct user_namespace arg was added as the first argument to\n\tdnl # mkdir()\n\tdnl #\n\tZFS_LINUX_TEST_SRC([mkdir_user_namespace], [\n\t\t#include <linux/fs.h>\n\n\t\tint mkdir(struct user_namespace *userns,\n\t\t\tstruct inode *inode, struct dentry *dentry,\n\t\t    umode_t umode) { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.mkdir = mkdir,\n\t\t};\n\t],[])\n\n\tdnl #\n\tdnl # 3.3 API change\n\tdnl # The VFS .create, .mkdir and .mknod callbacks were updated to take a\n\tdnl # umode_t type rather than an int.  The expectation is that any backport\n\tdnl # would also change all three prototypes.  However, if it turns out that\n\tdnl # some distribution doesn't backport the whole thing this could be\n\tdnl # broken apart into three separate checks.\n\tdnl #\n\tZFS_LINUX_TEST_SRC([inode_operations_mkdir], [\n\t\t#include <linux/fs.h>\n\n\t\tint mkdir(struct inode *inode, struct dentry *dentry,\n\t\t    umode_t umode) { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.mkdir = mkdir,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_MKDIR], [\n\tdnl #\n\tdnl # 6.3 API change\n\tdnl # mkdir() takes struct mnt_idmap * as the first arg\n\tdnl #\n\tAC_MSG_CHECKING([whether iops->mkdir() takes struct mnt_idmap*])\n\tZFS_LINUX_TEST_RESULT([mkdir_mnt_idmap], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOPS_MKDIR_IDMAP, 1,\n\t\t    [iops->mkdir() takes struct mnt_idmap*])\n\t],[\n\t\tdnl #\n\t\tdnl # 5.12 API change\n\t\tdnl # The struct user_namespace arg was added as the first argument to\n\t\tdnl # mkdir() of the iops structure.\n\t\tdnl #\n\t\tAC_MSG_CHECKING([whether iops->mkdir() takes struct user_namespace*])\n\t\tZFS_LINUX_TEST_RESULT([mkdir_user_namespace], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_IOPS_MKDIR_USERNS, 1,\n\t\t\t    [iops->mkdir() takes struct user_namespace*])\n\t\t],[\n\t\t\tAC_MSG_RESULT(no)\n\n\t\t\tAC_MSG_CHECKING([whether iops->mkdir() takes umode_t])\n\t\t\tZFS_LINUX_TEST_RESULT([inode_operations_mkdir], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_MKDIR_UMODE_T, 1,\n\t\t\t\t    [iops->mkdir() takes umode_t])\n\t\t\t],[\n\t\t\t\tZFS_LINUX_TEST_ERROR([mkdir()])\n\t\t\t])\n\t\t])\n\t])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}