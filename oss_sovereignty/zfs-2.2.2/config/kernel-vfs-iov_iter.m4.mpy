{
  "module_name": "kernel-vfs-iov_iter.m4",
  "hash_id": "a911865072ff5f0953aae1c69f43f21fb2b99d16beb97510c8a945b970068450",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-vfs-iov_iter.m4",
  "human_readable_source": "dnl #\ndnl # Check for available iov_iter functionality.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_IOV_ITER], [\n\tZFS_LINUX_TEST_SRC([iov_iter_types], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tint type __attribute__ ((unused)) = ITER_KVEC;\n\t])\n\n\tZFS_LINUX_TEST_SRC([iov_iter_advance], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tsize_t advance = 512;\n\n\t\tiov_iter_advance(&iter, advance);\n\t])\n\n\tZFS_LINUX_TEST_SRC([iov_iter_revert], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tsize_t revert = 512;\n\n\t\tiov_iter_revert(&iter, revert);\n\t])\n\n\tZFS_LINUX_TEST_SRC([iov_iter_fault_in_readable], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tsize_t size = 512;\n\t\tint error __attribute__ ((unused));\n\n\t\terror = iov_iter_fault_in_readable(&iter, size);\n\t])\n\n\tZFS_LINUX_TEST_SRC([fault_in_iov_iter_readable], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tsize_t size = 512;\n\t\tint error __attribute__ ((unused));\n\n\t\terror = fault_in_iov_iter_readable(&iter, size);\n\t])\n\n\tZFS_LINUX_TEST_SRC([iov_iter_count], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tsize_t bytes __attribute__ ((unused));\n\n\t\tbytes = iov_iter_count(&iter);\n\t])\n\n\tZFS_LINUX_TEST_SRC([copy_to_iter], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tchar buf[512] = { 0 };\n\t\tsize_t size = 512;\n\t\tsize_t bytes __attribute__ ((unused));\n\n\t\tbytes = copy_to_iter((const void *)&buf, size, &iter);\n\t])\n\n\tZFS_LINUX_TEST_SRC([copy_from_iter], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\tchar buf[512] = { 0 };\n\t\tsize_t size = 512;\n\t\tsize_t bytes __attribute__ ((unused));\n\n\t\tbytes = copy_from_iter((void *)&buf, size, &iter);\n\t])\n\n\tZFS_LINUX_TEST_SRC([iov_iter_type], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\t__attribute__((unused)) enum iter_type i = iov_iter_type(&iter);\n\t])\n\n\tZFS_LINUX_TEST_SRC([iter_iov], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/uio.h>\n\t],[\n\t\tstruct iov_iter iter = { 0 };\n\t\t__attribute__((unused)) const struct iovec *iov = iter_iov(&iter);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_VFS_IOV_ITER], [\n\tenable_vfs_iov_iter=\"yes\"\n\n\tAC_MSG_CHECKING([whether iov_iter types are available])\n\tZFS_LINUX_TEST_RESULT([iov_iter_types], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOV_ITER_TYPES, 1,\n\t\t    [iov_iter types are available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tenable_vfs_iov_iter=\"no\"\n\t])\n\n\tAC_MSG_CHECKING([whether iov_iter_advance() is available])\n\tZFS_LINUX_TEST_RESULT([iov_iter_advance], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOV_ITER_ADVANCE, 1,\n\t\t    [iov_iter_advance() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tenable_vfs_iov_iter=\"no\"\n\t])\n\n\tAC_MSG_CHECKING([whether iov_iter_revert() is available])\n\tZFS_LINUX_TEST_RESULT([iov_iter_revert], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOV_ITER_REVERT, 1,\n\t\t    [iov_iter_revert() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tenable_vfs_iov_iter=\"no\"\n\t])\n\n\tAC_MSG_CHECKING([whether iov_iter_fault_in_readable() is available])\n\tZFS_LINUX_TEST_RESULT([iov_iter_fault_in_readable], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOV_ITER_FAULT_IN_READABLE, 1,\n\t\t    [iov_iter_fault_in_readable() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([whether fault_in_iov_iter_readable() is available])\n\t\tZFS_LINUX_TEST_RESULT([fault_in_iov_iter_readable], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_FAULT_IN_IOV_ITER_READABLE, 1,\n\t\t\t    [fault_in_iov_iter_readable() is available])\n\t\t],[\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tenable_vfs_iov_iter=\"no\"\n\t\t])\n\t])\n\n\tAC_MSG_CHECKING([whether iov_iter_count() is available])\n\tZFS_LINUX_TEST_RESULT([iov_iter_count], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOV_ITER_COUNT, 1,\n\t\t    [iov_iter_count() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tenable_vfs_iov_iter=\"no\"\n\t])\n\n\tAC_MSG_CHECKING([whether copy_to_iter() is available])\n\tZFS_LINUX_TEST_RESULT([copy_to_iter], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_COPY_TO_ITER, 1,\n\t\t    [copy_to_iter() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tenable_vfs_iov_iter=\"no\"\n\t])\n\n\tAC_MSG_CHECKING([whether copy_from_iter() is available])\n\tZFS_LINUX_TEST_RESULT([copy_from_iter], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_COPY_FROM_ITER, 1,\n\t\t    [copy_from_iter() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tenable_vfs_iov_iter=\"no\"\n\t])\n\n\tdnl #\n\tdnl # This checks for iov_iter_type() in linux/uio.h. It is not\n\tdnl # required, however, and the module will compiled without it\n\tdnl # using direct access of the member attribute\n\tdnl #\n\tAC_MSG_CHECKING([whether iov_iter_type() is available])\n\tZFS_LINUX_TEST_RESULT([iov_iter_type], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IOV_ITER_TYPE, 1,\n\t\t    [iov_iter_type() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl #\n\tdnl # As of the 4.9 kernel support is provided for iovecs, kvecs,\n\tdnl # bvecs and pipes in the iov_iter structure.  As long as the\n\tdnl # other support interfaces are all available the iov_iter can\n\tdnl # be correctly used in the uio structure.\n\tdnl #\n\tAS_IF([test \"x$enable_vfs_iov_iter\" = \"xyes\"], [\n\t\tAC_DEFINE(HAVE_VFS_IOV_ITER, 1,\n\t\t    [All required iov_iter interfaces are available])\n\t])\n\n\tdnl #\n\tdnl # Kernel 6.5 introduces the iter_iov() function that returns the\n\tdnl # __iov member of an iov_iter*. The iov member was renamed to this\n\tdnl # __iov member, and is intended to be accessed via the helper\n\tdnl # function now.\n\tdnl #\n\tAC_MSG_CHECKING([whether iter_iov() is available])\n\tZFS_LINUX_TEST_RESULT([iter_iov], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_ITER_IOV, 1,\n\t\t    [iter_iov() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}