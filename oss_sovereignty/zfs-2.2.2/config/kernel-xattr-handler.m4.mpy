{
  "module_name": "kernel-xattr-handler.m4",
  "hash_id": "1d99b7700f47539b4ade30be8c752adacf5f036faa44a705f04cac214f2e3afa",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-xattr-handler.m4",
  "human_readable_source": "dnl #\ndnl # 2.6.35 API change,\ndnl # The 'struct xattr_handler' was constified in the generic\ndnl # super_block structure.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_CONST_XATTR_HANDLER], [\n\tZFS_LINUX_TEST_SRC([const_xattr_handler], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/xattr.h>\n\n\t\tconst struct xattr_handler xattr_test_handler = {\n\t\t\t.prefix\t= \"test\",\n\t\t\t.get\t= NULL,\n\t\t\t.set\t= NULL,\n\t\t};\n\n\t\tconst struct xattr_handler *xattr_handlers[] = {\n\t\t\t&xattr_test_handler,\n\t\t};\n\n\t\tconst struct super_block sb __attribute__ ((unused)) = {\n\t\t\t.s_xattr = xattr_handlers,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_CONST_XATTR_HANDLER], [\n\tAC_MSG_CHECKING([whether super_block uses const struct xattr_handler])\n\tZFS_LINUX_TEST_RESULT([const_xattr_handler], [\n\t\tAC_MSG_RESULT([yes])\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([const xattr_handler])\n\t])\n])\n\ndnl #\ndnl # 4.5 API change,\ndnl # struct xattr_handler added new member \"name\".\ndnl # xattr_handler which matches to whole name rather than prefix should use\ndnl # \"name\" instead of \"prefix\", e.g. \"system.posix_acl_access\"\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_NAME], [\n\tZFS_LINUX_TEST_SRC([xattr_handler_name], [\n\t\t#include <linux/xattr.h>\n\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.name = XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_NAME], [\n\tAC_MSG_CHECKING([whether xattr_handler has name])\n\tZFS_LINUX_TEST_RESULT([xattr_handler_name], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_XATTR_HANDLER_NAME, 1,\n\t\t    [xattr_handler has name])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # Supported xattr handler get() interfaces checked newest to oldest.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_GET], [\n\tZFS_LINUX_TEST_SRC([xattr_handler_get_dentry_inode], [\n\t\t#include <linux/xattr.h>\n\n\t\tint get(const struct xattr_handler *handler,\n\t\t    struct dentry *dentry, struct inode *inode,\n\t\t    const char *name, void *buffer, size_t size) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.get = get,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_get_xattr_handler], [\n\t\t#include <linux/xattr.h>\n\n\t\tint get(const struct xattr_handler *handler,\n\t\t    struct dentry *dentry, const char *name,\n\t\t    void *buffer, size_t size) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.get = get,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_get_dentry], [\n\t\t#include <linux/xattr.h>\n\n\t\tint get(struct dentry *dentry, const char *name,\n\t\t    void *buffer, size_t size, int handler_flags)\n\t\t    { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.get = get,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_get_dentry_inode_flags], [\n\t\t#include <linux/xattr.h>\n\n\t\tint get(const struct xattr_handler *handler,\n\t\t    struct dentry *dentry, struct inode *inode,\n\t\t    const char *name, void *buffer,\n\t\t    size_t size, int flags) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.get = get,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_GET], [\n\tdnl #\n\tdnl # 4.7 API change,\n\tdnl # The xattr_handler->get() callback was changed to take both\n\tdnl # dentry and inode.\n\tdnl #\n\tAC_MSG_CHECKING([whether xattr_handler->get() wants dentry and inode])\n\tZFS_LINUX_TEST_RESULT([xattr_handler_get_dentry_inode], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_XATTR_GET_DENTRY_INODE, 1,\n\t\t    [xattr_handler->get() wants both dentry and inode])\n\t],[\n\t\tdnl #\n\t\tdnl # 4.4 API change,\n\t\tdnl # The xattr_handler->get() callback was changed to take a\n\t\tdnl # attr_handler, and handler_flags argument was removed and\n\t\tdnl # should be accessed by handler->flags.\n\t\tdnl #\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(\n\t\t    [whether xattr_handler->get() wants xattr_handler])\n\t\tZFS_LINUX_TEST_RESULT([xattr_handler_get_xattr_handler], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_XATTR_GET_HANDLER, 1,\n\t\t\t    [xattr_handler->get() wants xattr_handler])\n\t\t],[\n\t\t\tdnl #\n\t\t\tdnl # 2.6.33 API change,\n\t\t\tdnl # The xattr_handler->get() callback was changed\n\t\t\tdnl # to take a dentry instead of an inode, and a\n\t\t\tdnl # handler_flags argument was added.\n\t\t\tdnl #\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tAC_MSG_CHECKING(\n\t\t\t    [whether xattr_handler->get() wants dentry])\n\t\t\tZFS_LINUX_TEST_RESULT([xattr_handler_get_dentry], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_XATTR_GET_DENTRY, 1,\n\t\t\t\t    [xattr_handler->get() wants dentry])\n\t\t\t],[\n\t\t\t\tdnl #\n\t\t\t\tdnl # Android API change,\n\t\t\t\tdnl # The xattr_handler->get() callback was\n\t\t\t\tdnl # changed to take dentry, inode and flags.\n\t\t\t\tdnl #\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\tAC_MSG_CHECKING(\n\t\t\t\t    [whether xattr_handler->get() wants dentry and inode and flags])\n\t\t\t\tZFS_LINUX_TEST_RESULT([xattr_handler_get_dentry_inode_flags], [\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tAC_DEFINE(HAVE_XATTR_GET_DENTRY_INODE_FLAGS, 1,\n\t\t\t\t\t    [xattr_handler->get() wants dentry and inode and flags])\n\t\t\t\t],[\n\t\t\t\t\tZFS_LINUX_TEST_ERROR([xattr get()])\n\t\t\t\t])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # Supported xattr handler set() interfaces checked newest to oldest.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_SET], [\n\tZFS_LINUX_TEST_SRC([xattr_handler_set_mnt_idmap], [\n\t\t#include <linux/xattr.h>\n\n\t\tint set(const struct xattr_handler *handler,\n\t\t\tstruct mnt_idmap *idmap,\n\t\t\tstruct dentry *dentry, struct inode *inode,\n\t\t\tconst char *name, const void *buffer,\n\t\t\tsize_t size, int flags)\n\t\t\t{ return 0; }\n\t\tstatic const struct xattr_handler\n\t\t\txops __attribute__ ((unused)) = {\n\t\t\t.set = set,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_set_userns], [\n\t\t#include <linux/xattr.h>\n\n\t\tint set(const struct xattr_handler *handler,\n\t\t\tstruct user_namespace *mnt_userns,\n\t\t\tstruct dentry *dentry, struct inode *inode,\n\t\t\tconst char *name, const void *buffer,\n\t\t\tsize_t size, int flags)\n\t\t\t{ return 0; }\n\t\tstatic const struct xattr_handler\n\t\t\txops __attribute__ ((unused)) = {\n\t\t\t.set = set,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_set_dentry_inode], [\n\t\t#include <linux/xattr.h>\n\n\t\tint set(const struct xattr_handler *handler,\n\t\t    struct dentry *dentry, struct inode *inode,\n\t\t    const char *name, const void *buffer,\n\t\t    size_t size, int flags)\n\t\t    { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.set = set,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_set_xattr_handler], [\n\t\t#include <linux/xattr.h>\n\n\t\tint set(const struct xattr_handler *handler,\n\t\t    struct dentry *dentry, const char *name,\n\t\t    const void *buffer, size_t size, int flags)\n\t\t    { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.set = set,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_set_dentry], [\n\t\t#include <linux/xattr.h>\n\n\t\tint set(struct dentry *dentry, const char *name,\n\t\t    const void *buffer, size_t size, int flags,\n\t\t    int handler_flags) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.set = set,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_SET], [\n\tdnl #\n\tdnl # 5.12 API change,\n\tdnl # The xattr_handler->set() callback was changed to 8 arguments, and\n\tdnl # struct user_namespace* was inserted as arg #2\n\tdnl #\n\tdnl # 6.3 API change,\n\tdnl # The xattr_handler->set() callback 2nd arg is now struct mnt_idmap *\n\tdnl #\n\tAC_MSG_CHECKING([whether xattr_handler->set() wants dentry, inode, and mnt_idmap])\n\tZFS_LINUX_TEST_RESULT([xattr_handler_set_mnt_idmap], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_XATTR_SET_IDMAP, 1,\n\t\t    [xattr_handler->set() takes mnt_idmap])\n\t], [\n\t\tAC_MSG_CHECKING([whether xattr_handler->set() wants dentry, inode, and user_namespace])\n\t\tZFS_LINUX_TEST_RESULT([xattr_handler_set_userns], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_XATTR_SET_USERNS, 1,\n\t\t\t    [xattr_handler->set() takes user_namespace])\n\t\t],[\n\t\t\tdnl #\n\t\t\tdnl # 4.7 API change,\n\t\t\tdnl # The xattr_handler->set() callback was changed to take both\n\t\t\tdnl # dentry and inode.\n\t\t\tdnl #\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tAC_MSG_CHECKING([whether xattr_handler->set() wants dentry and inode])\n\t\t\tZFS_LINUX_TEST_RESULT([xattr_handler_set_dentry_inode], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_XATTR_SET_DENTRY_INODE, 1,\n\t\t\t\t    [xattr_handler->set() wants both dentry and inode])\n\t\t\t],[\n\t\t\t\tdnl #\n\t\t\t\tdnl # 4.4 API change,\n\t\t\t\tdnl # The xattr_handler->set() callback was changed to take a\n\t\t\t\tdnl # xattr_handler, and handler_flags argument was removed and\n\t\t\t\tdnl # should be accessed by handler->flags.\n\t\t\t\tdnl #\n\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\tAC_MSG_CHECKING(\n\t\t\t\t    [whether xattr_handler->set() wants xattr_handler])\n\t\t\t\tZFS_LINUX_TEST_RESULT([xattr_handler_set_xattr_handler], [\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tAC_DEFINE(HAVE_XATTR_SET_HANDLER, 1,\n\t\t\t\t\t    [xattr_handler->set() wants xattr_handler])\n\t\t\t\t],[\n\t\t\t\t\tdnl #\n\t\t\t\t\tdnl # 2.6.33 API change,\n\t\t\t\t\tdnl # The xattr_handler->set() callback was changed\n\t\t\t\t\tdnl # to take a dentry instead of an inode, and a\n\t\t\t\t\tdnl # handler_flags argument was added.\n\t\t\t\t\tdnl #\n\t\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\t\tAC_MSG_CHECKING(\n\t\t\t\t\t    [whether xattr_handler->set() wants dentry])\n\t\t\t\t\tZFS_LINUX_TEST_RESULT([xattr_handler_set_dentry], [\n\t\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\t\tAC_DEFINE(HAVE_XATTR_SET_DENTRY, 1,\n\t\t\t\t\t\t    [xattr_handler->set() wants dentry])\n\t\t\t\t\t],[\n\t\t\t\t\t\tZFS_LINUX_TEST_ERROR([xattr set()])\n\t\t\t\t\t])\n\t\t\t\t])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # Supported xattr handler list() interfaces checked newest to oldest.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_LIST], [\n\tZFS_LINUX_TEST_SRC([xattr_handler_list_simple], [\n\t\t#include <linux/xattr.h>\n\n\t\tbool list(struct dentry *dentry) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.list = list,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_list_xattr_handler], [\n\t\t#include <linux/xattr.h>\n\n\t\tsize_t list(const struct xattr_handler *handler,\n\t\t    struct dentry *dentry, char *list, size_t list_size,\n\t\t    const char *name, size_t name_len) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.list = list,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([xattr_handler_list_dentry], [\n\t\t#include <linux/xattr.h>\n\n\t\tsize_t list(struct dentry *dentry,\n\t\t    char *list, size_t list_size,\n\t\t    const char *name, size_t name_len,\n\t\t    int handler_flags) { return 0; }\n\t\tstatic const struct xattr_handler\n\t\t    xops __attribute__ ((unused)) = {\n\t\t\t.list = list,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_LIST], [\n\tdnl # 4.5 API change,\n\tdnl # The xattr_handler->list() callback was changed to take only a\n\tdnl # dentry and it only needs to return if it's accessible.\n\tAC_MSG_CHECKING([whether xattr_handler->list() wants simple])\n\tZFS_LINUX_TEST_RESULT([xattr_handler_list_simple], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_XATTR_LIST_SIMPLE, 1,\n\t\t    [xattr_handler->list() wants simple])\n\t],[\n\t\tdnl #\n\t\tdnl # 4.4 API change,\n\t\tdnl # The xattr_handler->list() callback was changed to take a\n\t\tdnl # xattr_handler, and handler_flags argument was removed\n\t\tdnl # and should be accessed by handler->flags.\n\t\tdnl #\n\t\tAC_MSG_RESULT(no)\n\t\tAC_MSG_CHECKING(\n\t\t    [whether xattr_handler->list() wants xattr_handler])\n\t\tZFS_LINUX_TEST_RESULT([xattr_handler_list_xattr_handler], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_XATTR_LIST_HANDLER, 1,\n\t\t\t    [xattr_handler->list() wants xattr_handler])\n\t\t],[\n\t\t\tdnl #\n\t\t\tdnl # 2.6.33 API change,\n\t\t\tdnl # The xattr_handler->list() callback was changed\n\t\t\tdnl # to take a dentry instead of an inode, and a\n\t\t\tdnl # handler_flags argument was added.\n\t\t\tdnl #\n\t\t\tAC_MSG_RESULT(no)\n\t\t\tAC_MSG_CHECKING(\n\t\t\t    [whether xattr_handler->list() wants dentry])\n\t\t\tZFS_LINUX_TEST_RESULT([xattr_handler_list_dentry], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_XATTR_LIST_DENTRY, 1,\n\t\t\t\t    [xattr_handler->list() wants dentry])\n\t\t\t],[\n\t\t\t\tZFS_LINUX_TEST_ERROR([xattr list()])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 3.7 API change,\ndnl # The posix_acl_{from,to}_xattr functions gained a new\ndnl # parameter: user_ns\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_FROM_XATTR_USERNS], [\n\tZFS_LINUX_TEST_SRC([posix_acl_from_xattr_userns], [\n\t\t#include <linux/cred.h>\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl_xattr.h>\n\t],[\n\t\tposix_acl_from_xattr(&init_user_ns, NULL, 0);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_FROM_XATTR_USERNS], [\n\tAC_MSG_CHECKING([whether posix_acl_from_xattr() needs user_ns])\n\tZFS_LINUX_TEST_RESULT([posix_acl_from_xattr_userns], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_POSIX_ACL_FROM_XATTR_USERNS, 1,\n\t\t    [posix_acl_from_xattr() needs user_ns])\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([posix_acl_from_xattr()])\n\t])\n])\n\ndnl #\ndnl # 4.9 API change,\ndnl # iops->{set,get,remove}xattr and generic_{set,get,remove}xattr are\ndnl # removed. xattr operations will directly go through sb->s_xattr.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_GENERIC_SETXATTR], [\n\tZFS_LINUX_TEST_SRC([have_generic_setxattr], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/xattr.h>\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.setxattr = generic_setxattr\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_GENERIC_SETXATTR], [\n\tAC_MSG_CHECKING([whether generic_setxattr() exists])\n\tZFS_LINUX_TEST_RESULT([have_generic_setxattr], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GENERIC_SETXATTR, 1,\n\t\t    [generic_setxattr() exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR], [\n\tZFS_AC_KERNEL_SRC_CONST_XATTR_HANDLER\n\tZFS_AC_KERNEL_SRC_XATTR_HANDLER_NAME\n\tZFS_AC_KERNEL_SRC_XATTR_HANDLER_GET\n\tZFS_AC_KERNEL_SRC_XATTR_HANDLER_SET\n\tZFS_AC_KERNEL_SRC_XATTR_HANDLER_LIST\n\tZFS_AC_KERNEL_SRC_POSIX_ACL_FROM_XATTR_USERNS\n\tZFS_AC_KERNEL_SRC_GENERIC_SETXATTR\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_XATTR], [\n\tZFS_AC_KERNEL_CONST_XATTR_HANDLER\n\tZFS_AC_KERNEL_XATTR_HANDLER_NAME\n\tZFS_AC_KERNEL_XATTR_HANDLER_GET\n\tZFS_AC_KERNEL_XATTR_HANDLER_SET\n\tZFS_AC_KERNEL_XATTR_HANDLER_LIST\n\tZFS_AC_KERNEL_POSIX_ACL_FROM_XATTR_USERNS\n\tZFS_AC_KERNEL_GENERIC_SETXATTR\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}