{
  "module_name": "kernel-blk-queue.m4",
  "hash_id": "e37f2c2f0fa0364990d8f373bf50bf6f933484296d929dcf0d6120ccf6301227",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-blk-queue.m4",
  "human_readable_source": "dnl #\ndnl # 2.6.39 API change,\ndnl # blk_start_plug() and blk_finish_plug()\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_PLUG], [\n\tZFS_LINUX_TEST_SRC([blk_plug], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct blk_plug plug __attribute__ ((unused));\n\n\t\tblk_start_plug(&plug);\n\t\tblk_finish_plug(&plug);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_PLUG], [\n\tAC_MSG_CHECKING([whether struct blk_plug is available])\n\tZFS_LINUX_TEST_RESULT([blk_plug], [\n\t\tAC_MSG_RESULT(yes)\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([blk_plug])\n\t])\n])\n\ndnl #\ndnl # 2.6.32 - 4.11: statically allocated bdi in request_queue\ndnl # 4.12: dynamically allocated bdi in request_queue\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_BDI], [\n\tZFS_LINUX_TEST_SRC([blk_queue_bdi], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue q;\n\t\tstruct backing_dev_info bdi;\n\t\tq.backing_dev_info = &bdi;\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_BDI], [\n\tAC_MSG_CHECKING([whether blk_queue bdi is dynamic])\n\tZFS_LINUX_TEST_RESULT([blk_queue_bdi], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_QUEUE_BDI_DYNAMIC, 1,\n\t\t    [blk queue backing_dev_info is dynamic])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 5.9: added blk_queue_update_readahead(),\ndnl # 5.15: renamed to disk_update_readahead()\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_UPDATE_READAHEAD], [\n\tZFS_LINUX_TEST_SRC([blk_queue_update_readahead], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue q;\n\t\tblk_queue_update_readahead(&q);\n\t])\n\n\tZFS_LINUX_TEST_SRC([disk_update_readahead], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct gendisk disk;\n\t\tdisk_update_readahead(&disk);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_UPDATE_READAHEAD], [\n\tAC_MSG_CHECKING([whether blk_queue_update_readahead() exists])\n\tZFS_LINUX_TEST_RESULT([blk_queue_update_readahead], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_QUEUE_UPDATE_READAHEAD, 1,\n\t\t    [blk_queue_update_readahead() exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([whether disk_update_readahead() exists])\n\t\tZFS_LINUX_TEST_RESULT([disk_update_readahead], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_DISK_UPDATE_READAHEAD, 1,\n\t\t\t    [disk_update_readahead() exists])\n\t\t],[\n\t\t\tAC_MSG_RESULT(no)\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 5.19: bdev_max_discard_sectors() available\ndnl # 2.6.32: blk_queue_discard() available\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_DISCARD], [\n\tZFS_LINUX_TEST_SRC([bdev_max_discard_sectors], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct block_device *bdev __attribute__ ((unused)) = NULL;\n\t\tunsigned int error __attribute__ ((unused));\n\n\t\terror = bdev_max_discard_sectors(bdev);\n\t])\n\n\tZFS_LINUX_TEST_SRC([blk_queue_discard], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue r;\n\t\tstruct request_queue *q = &r;\n\t\tint value __attribute__ ((unused));\n\t\tmemset(q, 0, sizeof(r));\n\t\tvalue = blk_queue_discard(q);\n\t],[-Wframe-larger-than=8192])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_DISCARD], [\n\tAC_MSG_CHECKING([whether bdev_max_discard_sectors() is available])\n\tZFS_LINUX_TEST_RESULT([bdev_max_discard_sectors], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BDEV_MAX_DISCARD_SECTORS, 1,\n\t\t    [bdev_max_discard_sectors() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([whether blk_queue_discard() is available])\n\t\tZFS_LINUX_TEST_RESULT([blk_queue_discard], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_BLK_QUEUE_DISCARD, 1,\n\t\t\t    [blk_queue_discard() is available])\n\t\t],[\n\t\t\tZFS_LINUX_TEST_ERROR([blk_queue_discard])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 5.19: bdev_max_secure_erase_sectors() available\ndnl # 4.8: blk_queue_secure_erase() available\ndnl # 2.6.36: blk_queue_secdiscard() available\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_SECURE_ERASE], [\n\tZFS_LINUX_TEST_SRC([bdev_max_secure_erase_sectors], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct block_device *bdev __attribute__ ((unused)) = NULL;\n\t\tunsigned int error __attribute__ ((unused));\n\n\t\terror = bdev_max_secure_erase_sectors(bdev);\n\t])\n\n\tZFS_LINUX_TEST_SRC([blk_queue_secure_erase], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue r;\n\t\tstruct request_queue *q = &r;\n\t\tint value __attribute__ ((unused));\n\t\tmemset(q, 0, sizeof(r));\n\t\tvalue = blk_queue_secure_erase(q);\n\t],[-Wframe-larger-than=8192])\n\n\tZFS_LINUX_TEST_SRC([blk_queue_secdiscard], [\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue r;\n\t\tstruct request_queue *q = &r;\n\t\tint value __attribute__ ((unused));\n\t\tmemset(q, 0, sizeof(r));\n\t\tvalue = blk_queue_secdiscard(q);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_SECURE_ERASE], [\n\tAC_MSG_CHECKING([whether bdev_max_secure_erase_sectors() is available])\n\tZFS_LINUX_TEST_RESULT([bdev_max_secure_erase_sectors], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BDEV_MAX_SECURE_ERASE_SECTORS, 1,\n\t\t    [bdev_max_secure_erase_sectors() is available])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([whether blk_queue_secure_erase() is available])\n\t\tZFS_LINUX_TEST_RESULT([blk_queue_secure_erase], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_BLK_QUEUE_SECURE_ERASE, 1,\n\t\t\t    [blk_queue_secure_erase() is available])\n\t\t],[\n\t\t\tAC_MSG_RESULT(no)\n\n\t\t\tAC_MSG_CHECKING([whether blk_queue_secdiscard() is available])\n\t\t\tZFS_LINUX_TEST_RESULT([blk_queue_secdiscard], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_BLK_QUEUE_SECDISCARD, 1,\n\t\t\t\t    [blk_queue_secdiscard() is available])\n\t\t\t],[\n\t\t\t\tZFS_LINUX_TEST_ERROR([blk_queue_secure_erase])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 4.16 API change,\ndnl # Introduction of blk_queue_flag_set and blk_queue_flag_clear\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_SET], [\n\tZFS_LINUX_TEST_SRC([blk_queue_flag_set], [\n\t\t#include <linux/kernel.h>\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue *q = NULL;\n\t\tblk_queue_flag_set(0, q);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAG_SET], [\n\tAC_MSG_CHECKING([whether blk_queue_flag_set() exists])\n\tZFS_LINUX_TEST_RESULT([blk_queue_flag_set], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_QUEUE_FLAG_SET, 1,\n\t\t    [blk_queue_flag_set() exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_CLEAR], [\n\tZFS_LINUX_TEST_SRC([blk_queue_flag_clear], [\n\t\t#include <linux/kernel.h>\n\t\t#include <linux/blkdev.h>\n\t],[\n\t\tstruct request_queue *q = NULL;\n\t\tblk_queue_flag_clear(0, q);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAG_CLEAR], [\n\tAC_MSG_CHECKING([whether blk_queue_flag_clear() exists])\n\tZFS_LINUX_TEST_RESULT([blk_queue_flag_clear], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_QUEUE_FLAG_CLEAR, 1,\n\t\t    [blk_queue_flag_clear() exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 2.6.36 API change,\ndnl # Added blk_queue_flush() interface, while the previous interface\ndnl # was available to all the new one is GPL-only.  Thus in addition to\ndnl # detecting if this function is available we determine if it is\ndnl # GPL-only.  If the GPL-only interface is there we implement our own\ndnl # compatibility function, otherwise we use the function.  The hope\ndnl # is that long term this function will be opened up.\ndnl #\ndnl # 4.7 API change,\ndnl # Replace blk_queue_flush with blk_queue_write_cache\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLUSH], [\n\tZFS_LINUX_TEST_SRC([blk_queue_flush], [\n\t\t#include <linux/blkdev.h>\n\t], [\n\t\tstruct request_queue *q __attribute__ ((unused)) = NULL;\n\t\t(void) blk_queue_flush(q, REQ_FLUSH);\n\t], [], [ZFS_META_LICENSE])\n\n\tZFS_LINUX_TEST_SRC([blk_queue_write_cache], [\n\t\t#include <linux/kernel.h>\n\t\t#include <linux/blkdev.h>\n\t], [\n\t\tstruct request_queue *q __attribute__ ((unused)) = NULL;\n\t\tblk_queue_write_cache(q, true, true);\n\t], [], [ZFS_META_LICENSE])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLUSH], [\n\tAC_MSG_CHECKING([whether blk_queue_flush() is available])\n\tZFS_LINUX_TEST_RESULT([blk_queue_flush], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_QUEUE_FLUSH, 1,\n\t\t    [blk_queue_flush() is available])\n\n\t\tAC_MSG_CHECKING([whether blk_queue_flush() is GPL-only])\n\t\tZFS_LINUX_TEST_RESULT([blk_queue_flush_license], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_BLK_QUEUE_FLUSH_GPL_ONLY, 1,\n\t\t\t    [blk_queue_flush() is GPL-only])\n\t\t])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n\n\tdnl #\n\tdnl # 4.7 API change\n\tdnl # Replace blk_queue_flush with blk_queue_write_cache\n\tdnl #\n\tAC_MSG_CHECKING([whether blk_queue_write_cache() exists])\n\tZFS_LINUX_TEST_RESULT([blk_queue_write_cache], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_QUEUE_WRITE_CACHE, 1,\n\t\t    [blk_queue_write_cache() exists])\n\n\t\tAC_MSG_CHECKING([whether blk_queue_write_cache() is GPL-only])\n\t\tZFS_LINUX_TEST_RESULT([blk_queue_write_cache_license], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_BLK_QUEUE_WRITE_CACHE_GPL_ONLY, 1,\n\t\t\t    [blk_queue_write_cache() is GPL-only])\n\t\t])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 2.6.34 API change\ndnl # blk_queue_max_hw_sectors() replaces blk_queue_max_sectors().\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_HW_SECTORS], [\n\tZFS_LINUX_TEST_SRC([blk_queue_max_hw_sectors], [\n\t\t#include <linux/blkdev.h>\n\t], [\n\t\tstruct request_queue *q __attribute__ ((unused)) = NULL;\n\t\t(void) blk_queue_max_hw_sectors(q, BLK_SAFE_MAX_SECTORS);\n\t], [])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_MAX_HW_SECTORS], [\n\tAC_MSG_CHECKING([whether blk_queue_max_hw_sectors() is available])\n\tZFS_LINUX_TEST_RESULT([blk_queue_max_hw_sectors], [\n\t\tAC_MSG_RESULT(yes)\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([blk_queue_max_hw_sectors])\n\t])\n])\n\ndnl #\ndnl # 2.6.34 API change\ndnl # blk_queue_max_segments() consolidates blk_queue_max_hw_segments()\ndnl # and blk_queue_max_phys_segments().\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_SEGMENTS], [\n\tZFS_LINUX_TEST_SRC([blk_queue_max_segments], [\n\t\t#include <linux/blkdev.h>\n\t], [\n\t\tstruct request_queue *q __attribute__ ((unused)) = NULL;\n\t\t(void) blk_queue_max_segments(q, BLK_MAX_SEGMENTS);\n\t], [])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_MAX_SEGMENTS], [\n\tAC_MSG_CHECKING([whether blk_queue_max_segments() is available])\n\tZFS_LINUX_TEST_RESULT([blk_queue_max_segments], [\n\t\tAC_MSG_RESULT(yes)\n\t], [\n\t\tZFS_LINUX_TEST_ERROR([blk_queue_max_segments])\n\t])\n])\n\ndnl #\ndnl # See if kernel supports block multi-queue and blk_status_t.\ndnl # blk_status_t represents the new status codes introduced in the 4.13\ndnl # kernel patch:\ndnl #\ndnl #  block: introduce new block status code type\ndnl #\ndnl # We do not currently support the \"old\" block multi-queue interfaces from\ndnl # prior kernels.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_MQ], [\n\tZFS_LINUX_TEST_SRC([blk_mq], [\n\t\t#include <linux/blk-mq.h>\n\t], [\n\t\tstruct blk_mq_tag_set tag_set __attribute__ ((unused)) = {0};\n\t\t(void) blk_mq_alloc_tag_set(&tag_set);\n\t\treturn BLK_STS_OK;\n\t], [])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_MQ], [\n\tAC_MSG_CHECKING([whether block multiqueue with blk_status_t is available])\n\tZFS_LINUX_TEST_RESULT([blk_mq], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_BLK_MQ, 1, [block multiqueue is available])\n\t], [\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE], [\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_PLUG\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_BDI\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_UPDATE_READAHEAD\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_DISCARD\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_SECURE_ERASE\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_SET\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_CLEAR\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_FLUSH\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_HW_SECTORS\n\tZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_SEGMENTS\n\tZFS_AC_KERNEL_SRC_BLK_MQ\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE], [\n\tZFS_AC_KERNEL_BLK_QUEUE_PLUG\n\tZFS_AC_KERNEL_BLK_QUEUE_BDI\n\tZFS_AC_KERNEL_BLK_QUEUE_UPDATE_READAHEAD\n\tZFS_AC_KERNEL_BLK_QUEUE_DISCARD\n\tZFS_AC_KERNEL_BLK_QUEUE_SECURE_ERASE\n\tZFS_AC_KERNEL_BLK_QUEUE_FLAG_SET\n\tZFS_AC_KERNEL_BLK_QUEUE_FLAG_CLEAR\n\tZFS_AC_KERNEL_BLK_QUEUE_FLUSH\n\tZFS_AC_KERNEL_BLK_QUEUE_MAX_HW_SECTORS\n\tZFS_AC_KERNEL_BLK_QUEUE_MAX_SEGMENTS\n\tZFS_AC_KERNEL_BLK_MQ\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}