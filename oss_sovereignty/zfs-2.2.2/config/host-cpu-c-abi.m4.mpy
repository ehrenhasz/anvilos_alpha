{
  "module_name": "host-cpu-c-abi.m4",
  "hash_id": "962e9087cfd689da0f98973f9856018b8b59b558c8a6da2b78b31e6f9abf9ef6",
  "original_prompt": "Ingested from zfs-2.2.2/config/host-cpu-c-abi.m4",
  "human_readable_source": "# host-cpu-c-abi.m4 serial 11\ndnl Copyright (C) 2002-2019 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible and Sam Steingold.\n\ndnl Sets the HOST_CPU variable to the canonical name of the CPU.\ndnl Sets the HOST_CPU_C_ABI variable to the canonical name of the CPU with its\ndnl C language ABI (application binary interface).\ndnl Also defines __${HOST_CPU}__ and __${HOST_CPU_C_ABI}__ as C macros in\ndnl config.h.\ndnl\ndnl This canonical name can be used to select a particular assembly language\ndnl source file that will interoperate with C code on the given host.\ndnl\ndnl For example:\ndnl * 'i386' and 'sparc' are different canonical names, because code for i386\ndnl   will not run on SPARC CPUs and vice versa. They have different\ndnl   instruction sets.\ndnl * 'sparc' and 'sparc64' are different canonical names, because code for\ndnl   'sparc' and code for 'sparc64' cannot be linked together: 'sparc' code\ndnl   contains 32-bit instructions, whereas 'sparc64' code contains 64-bit\ndnl   instructions. A process on a SPARC CPU can be in 32-bit mode or in 64-bit\ndnl   mode, but not both.\ndnl * 'mips' and 'mipsn32' are different canonical names, because they use\ndnl   different argument passing and return conventions for C functions, and\ndnl   although the instruction set of 'mips' is a large subset of the\ndnl   instruction set of 'mipsn32'.\ndnl * 'mipsn32' and 'mips64' are different canonical names, because they use\ndnl   different sizes for the C types like 'int' and 'void *', and although\ndnl   the instruction sets of 'mipsn32' and 'mips64' are the same.\ndnl * The same canonical name is used for different endiannesses. You can\ndnl   determine the endianness through preprocessor symbols:\ndnl   - 'arm': test __ARMEL__.\ndnl   - 'mips', 'mipsn32', 'mips64': test _MIPSEB vs. _MIPSEL.\ndnl   - 'powerpc64': test _BIG_ENDIAN vs. _LITTLE_ENDIAN.\ndnl * The same name 'i386' is used for CPUs of type i386, i486, i586\ndnl   (Pentium), AMD K7, Pentium II, Pentium IV, etc., because\ndnl   - Instructions that do not exist on all of these CPUs (cmpxchg,\ndnl     MMX, SSE, SSE2, 3DNow! etc.) are not frequently used. If your\ndnl     assembly language source files use such instructions, you will\ndnl     need to make the distinction.\ndnl   - Speed of execution of the common instruction set is reasonable across\ndnl     the entire family of CPUs. If you have assembly language source files\ndnl     that are optimized for particular CPU types (like GNU gmp has), you\ndnl     will need to make the distinction.\ndnl   See <https://en.wikipedia.org/wiki/X86_instruction_listings>.\nAC_DEFUN([gl_HOST_CPU_C_ABI],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_REQUIRE([gl_C_ASM])\n  AC_CACHE_CHECK([host CPU and C ABI], [gl_cv_host_cpu_c_abi],\n    [case \"$host_cpu\" in\n\nchangequote(,)dnl\n       i[4567]86 )\nchangequote([,])dnl\n         gl_cv_host_cpu_c_abi=i386\n         ;;\n\n       x86_64 )\n         # On x86_64 systems, the C compiler may be generating code in one of\n         # these ABIs:\n         # - 64-bit instruction set, 64-bit pointers, 64-bit 'long': x86_64.\n         # - 64-bit instruction set, 64-bit pointers, 32-bit 'long': x86_64\n         #   with native Windows (mingw, MSVC).\n         # - 64-bit instruction set, 32-bit pointers, 32-bit 'long': x86_64-x32.\n         # - 32-bit instruction set, 32-bit pointers, 32-bit 'long': i386.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if (defined __x86_64__ || defined __amd64__ \\\n                     || defined _M_X64 || defined _M_AMD64)\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [AC_COMPILE_IFELSE(\n              [AC_LANG_SOURCE(\n                 [[#if defined __ILP32__ || defined _ILP32\n                    int ok;\n                   #else\n                    error fail\n                   #endif\n                 ]])],\n              [gl_cv_host_cpu_c_abi=x86_64-x32],\n              [gl_cv_host_cpu_c_abi=x86_64])],\n           [gl_cv_host_cpu_c_abi=i386])\n         ;;\n\nchangequote(,)dnl\n       alphaev[4-8] | alphaev56 | alphapca5[67] | alphaev6[78] )\nchangequote([,])dnl\n         gl_cv_host_cpu_c_abi=alpha\n         ;;\n\n       arm* | aarch64 )\n         # Assume arm with EABI.\n         # On arm64 systems, the C compiler may be generating code in one of\n         # these ABIs:\n         # - aarch64 instruction set, 64-bit pointers, 64-bit 'long': arm64.\n         # - aarch64 instruction set, 32-bit pointers, 32-bit 'long': arm64-ilp32.\n         # - 32-bit instruction set, 32-bit pointers, 32-bit 'long': arm or armhf.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#ifdef __aarch64__\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [AC_COMPILE_IFELSE(\n              [AC_LANG_SOURCE(\n                [[#if defined __ILP32__ || defined _ILP32\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n              [gl_cv_host_cpu_c_abi=arm64-ilp32],\n              [gl_cv_host_cpu_c_abi=arm64])],\n           [# Don't distinguish little-endian and big-endian arm, since they\n            # don't require different machine code for simple operations and\n            # since the user can distinguish them through the preprocessor\n            # defines __ARMEL__ vs. __ARMEB__.\n            # But distinguish arm which passes floating-point arguments and\n            # return values in integer registers (r0, r1, ...) - this is\n            # gcc -mfloat-abi=soft or gcc -mfloat-abi=softfp - from arm which\n            # passes them in float registers (s0, s1, ...) and double registers\n            # (d0, d1, ...) - this is gcc -mfloat-abi=hard. GCC 4.6 or newer\n            # sets the preprocessor defines __ARM_PCS (for the first case) and\n            # __ARM_PCS_VFP (for the second case), but older GCC does not.\n            echo 'double ddd; void func (double dd) { ddd = dd; }' > conftest.c\n            # Look for a reference to the register d0 in the .s file.\n            AC_TRY_COMMAND(${CC-cc} $CFLAGS $CPPFLAGS $gl_c_asm_opt conftest.c) >/dev/null 2>&1\n            if LC_ALL=C grep 'd0,' conftest.$gl_asmext >/dev/null; then\n              gl_cv_host_cpu_c_abi=armhf\n            else\n              gl_cv_host_cpu_c_abi=arm\n            fi\n            rm -f conftest*\n           ])\n         ;;\n\n       hppa1.0 | hppa1.1 | hppa2.0* | hppa64 )\n         # On hppa, the C compiler may be generating 32-bit code or 64-bit\n         # code. In the latter case, it defines _LP64 and __LP64__.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#ifdef __LP64__\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [gl_cv_host_cpu_c_abi=hppa64],\n           [gl_cv_host_cpu_c_abi=hppa])\n         ;;\n\n       ia64* )\n         # On ia64 on HP-UX, the C compiler may be generating 64-bit code or\n         # 32-bit code. In the latter case, it defines _ILP32.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#ifdef _ILP32\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [gl_cv_host_cpu_c_abi=ia64-ilp32],\n           [gl_cv_host_cpu_c_abi=ia64])\n         ;;\n\n       mips* )\n         # We should also check for (_MIPS_SZPTR == 64), but gcc keeps this\n         # at 32.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if defined _MIPS_SZLONG && (_MIPS_SZLONG == 64)\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [gl_cv_host_cpu_c_abi=mips64],\n           [# In the n32 ABI, _ABIN32 is defined, _ABIO32 is not defined (but\n            # may later get defined by <sgidefs.h>), and _MIPS_SIM == _ABIN32.\n            # In the 32 ABI, _ABIO32 is defined, _ABIN32 is not defined (but\n            # may later get defined by <sgidefs.h>), and _MIPS_SIM == _ABIO32.\n            AC_COMPILE_IFELSE(\n              [AC_LANG_SOURCE(\n                 [[#if (_MIPS_SIM == _ABIN32)\n                    int ok;\n                   #else\n                    error fail\n                   #endif\n                 ]])],\n              [gl_cv_host_cpu_c_abi=mipsn32],\n              [gl_cv_host_cpu_c_abi=mips])])\n         ;;\n\n       powerpc* )\n         # Different ABIs are in use on AIX vs. Mac OS X vs. Linux,*BSD.\n         # No need to distinguish them here; the caller may distinguish\n         # them based on the OS.\n         # On powerpc64 systems, the C compiler may still be generating\n         # 32-bit code. And on powerpc-ibm-aix systems, the C compiler may\n         # be generating 64-bit code.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if defined __powerpc64__ || defined _ARCH_PPC64\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [# On powerpc64, there are two ABIs on Linux: The AIX compatible\n            # one and the ELFv2 one. The latter defines _CALL_ELF=2.\n            AC_COMPILE_IFELSE(\n              [AC_LANG_SOURCE(\n                 [[#if defined _CALL_ELF && _CALL_ELF == 2\n                    int ok;\n                   #else\n                    error fail\n                   #endif\n                 ]])],\n              [gl_cv_host_cpu_c_abi=powerpc64-elfv2],\n              [gl_cv_host_cpu_c_abi=powerpc64])\n           ],\n           [gl_cv_host_cpu_c_abi=powerpc])\n         ;;\n\n       rs6000 )\n         gl_cv_host_cpu_c_abi=powerpc\n         ;;\n\n       riscv32 | riscv64 )\n         # There are 2 architectures (with variants): rv32* and rv64*.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if __riscv_xlen == 64\n                  int ok;\n                #else\n                  error fail\n                #endif\n              ]])],\n           [cpu=riscv64],\n           [cpu=riscv32])\n         # There are 6 ABIs: ilp32, ilp32f, ilp32d, lp64, lp64f, lp64d.\n         # Size of 'long' and 'void *':\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if defined __LP64__\n                  int ok;\n                #else\n                  error fail\n                #endif\n              ]])],\n           [main_abi=lp64],\n           [main_abi=ilp32])\n         # Float ABIs:\n         # __riscv_float_abi_double:\n         #   'float' and 'double' are passed in floating-point registers.\n         # __riscv_float_abi_single:\n         #   'float' are passed in floating-point registers.\n         # __riscv_float_abi_soft:\n         #   No values are passed in floating-point registers.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if defined __riscv_float_abi_double\n                  int ok;\n                #else\n                  error fail\n                #endif\n              ]])],\n           [float_abi=d],\n           [AC_COMPILE_IFELSE(\n              [AC_LANG_SOURCE(\n                 [[#if defined __riscv_float_abi_single\n                     int ok;\n                   #else\n                     error fail\n                   #endif\n                 ]])],\n              [float_abi=f],\n              [float_abi=''])\n           ])\n         gl_cv_host_cpu_c_abi=\"${cpu}-${main_abi}${float_abi}\"\n         ;;\n\n       s390* )\n         # On s390x, the C compiler may be generating 64-bit (= s390x) code\n         # or 31-bit (= s390) code.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if defined __LP64__ || defined __s390x__\n                  int ok;\n                #else\n                  error fail\n                #endif\n              ]])],\n           [gl_cv_host_cpu_c_abi=s390x],\n           [gl_cv_host_cpu_c_abi=s390])\n         ;;\n\n       sparc | sparc64 )\n         # UltraSPARCs running Linux have `uname -m` = \"sparc64\", but the\n         # C compiler still generates 32-bit code.\n         AC_COMPILE_IFELSE(\n           [AC_LANG_SOURCE(\n              [[#if defined __sparcv9 || defined __arch64__\n                 int ok;\n                #else\n                 error fail\n                #endif\n              ]])],\n           [gl_cv_host_cpu_c_abi=sparc64],\n           [gl_cv_host_cpu_c_abi=sparc])\n         ;;\n\n       *)\n         gl_cv_host_cpu_c_abi=\"$host_cpu\"\n         ;;\n     esac\n    ])\n\n  dnl In most cases, $HOST_CPU and $HOST_CPU_C_ABI are the same.\n  HOST_CPU=`echo \"$gl_cv_host_cpu_c_abi\" | sed -e 's/-.*//'`\n  HOST_CPU_C_ABI=\"$gl_cv_host_cpu_c_abi\"\n  AC_SUBST([HOST_CPU])\n  AC_SUBST([HOST_CPU_C_ABI])\n\n  # This was\n  #   AC_DEFINE_UNQUOTED([__${HOST_CPU}__])\n  #   AC_DEFINE_UNQUOTED([__${HOST_CPU_C_ABI}__])\n  # earlier, but KAI C++ 3.2d doesn't like this.\n  sed -e 's/-/_/g' >> confdefs.h <<EOF\n#ifndef __${HOST_CPU}__\n#define __${HOST_CPU}__ 1\n#endif\n#ifndef __${HOST_CPU_C_ABI}__\n#define __${HOST_CPU_C_ABI}__ 1\n#endif\nEOF\n  AH_TOP([/* CPU and C ABI indicator */\n#ifndef __i386__\n#undef __i386__\n#endif\n#ifndef __x86_64_x32__\n#undef __x86_64_x32__\n#endif\n#ifndef __x86_64__\n#undef __x86_64__\n#endif\n#ifndef __alpha__\n#undef __alpha__\n#endif\n#ifndef __arm__\n#undef __arm__\n#endif\n#ifndef __armhf__\n#undef __armhf__\n#endif\n#ifndef __arm64_ilp32__\n#undef __arm64_ilp32__\n#endif\n#ifndef __arm64__\n#undef __arm64__\n#endif\n#ifndef __hppa__\n#undef __hppa__\n#endif\n#ifndef __hppa64__\n#undef __hppa64__\n#endif\n#ifndef __ia64_ilp32__\n#undef __ia64_ilp32__\n#endif\n#ifndef __ia64__\n#undef __ia64__\n#endif\n#ifndef __m68k__\n#undef __m68k__\n#endif\n#ifndef __mips__\n#undef __mips__\n#endif\n#ifndef __mipsn32__\n#undef __mipsn32__\n#endif\n#ifndef __mips64__\n#undef __mips64__\n#endif\n#ifndef __powerpc__\n#undef __powerpc__\n#endif\n#ifndef __powerpc64__\n#undef __powerpc64__\n#endif\n#ifndef __powerpc64_elfv2__\n#undef __powerpc64_elfv2__\n#endif\n#ifndef __riscv32__\n#undef __riscv32__\n#endif\n#ifndef __riscv64__\n#undef __riscv64__\n#endif\n#ifndef __riscv32_ilp32__\n#undef __riscv32_ilp32__\n#endif\n#ifndef __riscv32_ilp32f__\n#undef __riscv32_ilp32f__\n#endif\n#ifndef __riscv32_ilp32d__\n#undef __riscv32_ilp32d__\n#endif\n#ifndef __riscv64_ilp32__\n#undef __riscv64_ilp32__\n#endif\n#ifndef __riscv64_ilp32f__\n#undef __riscv64_ilp32f__\n#endif\n#ifndef __riscv64_ilp32d__\n#undef __riscv64_ilp32d__\n#endif\n#ifndef __riscv64_lp64__\n#undef __riscv64_lp64__\n#endif\n#ifndef __riscv64_lp64f__\n#undef __riscv64_lp64f__\n#endif\n#ifndef __riscv64_lp64d__\n#undef __riscv64_lp64d__\n#endif\n#ifndef __s390__\n#undef __s390__\n#endif\n#ifndef __s390x__\n#undef __s390x__\n#endif\n#ifndef __sh__\n#undef __sh__\n#endif\n#ifndef __sparc__\n#undef __sparc__\n#endif\n#ifndef __sparc64__\n#undef __sparc64__\n#endif\n])\n\n])\n\n\ndnl Sets the HOST_CPU_C_ABI_32BIT variable to 'yes' if the C language ABI\ndnl (application binary interface) is a 32-bit one, or to 'no' otherwise.\ndnl This is a simplified variant of gl_HOST_CPU_C_ABI.\nAC_DEFUN([gl_HOST_CPU_C_ABI_32BIT],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CACHE_CHECK([32-bit host C ABI], [gl_cv_host_cpu_c_abi_32bit],\n    [if test -n \"$gl_cv_host_cpu_c_abi\"; then\n       case \"$gl_cv_host_cpu_c_abi\" in\n         i386 | x86_64-x32 | arm | armhf | arm64-ilp32 | hppa | ia64-ilp32 | mips | mipsn32 | powerpc | riscv*-ilp32* | s390 | sparc)\n           gl_cv_host_cpu_c_abi_32bit=yes ;;\n         *)\n           gl_cv_host_cpu_c_abi_32bit=no ;;\n       esac\n     else\n       case \"$host_cpu\" in\n\nchangequote(,)dnl\n         i[4567]86 )\nchangequote([,])dnl\n           gl_cv_host_cpu_c_abi_32bit=yes\n           ;;\n\n         x86_64 )\n           # On x86_64 systems, the C compiler may be generating code in one of\n           # these ABIs:\n           # - 64-bit instruction set, 64-bit pointers, 64-bit 'long': x86_64.\n           # - 64-bit instruction set, 64-bit pointers, 32-bit 'long': x86_64\n           #   with native Windows (mingw, MSVC).\n           # - 64-bit instruction set, 32-bit pointers, 32-bit 'long': x86_64-x32.\n           # - 32-bit instruction set, 32-bit pointers, 32-bit 'long': i386.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if (defined __x86_64__ || defined __amd64__ \\\n                       || defined _M_X64 || defined _M_AMD64) \\\n                      && !(defined __ILP32__ || defined _ILP32)\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         arm* | aarch64 )\n           # Assume arm with EABI.\n           # On arm64 systems, the C compiler may be generating code in one of\n           # these ABIs:\n           # - aarch64 instruction set, 64-bit pointers, 64-bit 'long': arm64.\n           # - aarch64 instruction set, 32-bit pointers, 32-bit 'long': arm64-ilp32.\n           # - 32-bit instruction set, 32-bit pointers, 32-bit 'long': arm or armhf.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if defined __aarch64__ && !(defined __ILP32__ || defined _ILP32)\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         hppa1.0 | hppa1.1 | hppa2.0* | hppa64 )\n           # On hppa, the C compiler may be generating 32-bit code or 64-bit\n           # code. In the latter case, it defines _LP64 and __LP64__.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#ifdef __LP64__\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         ia64* )\n           # On ia64 on HP-UX, the C compiler may be generating 64-bit code or\n           # 32-bit code. In the latter case, it defines _ILP32.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#ifdef _ILP32\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=yes],\n             [gl_cv_host_cpu_c_abi_32bit=no])\n           ;;\n\n         mips* )\n           # We should also check for (_MIPS_SZPTR == 64), but gcc keeps this\n           # at 32.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if defined _MIPS_SZLONG && (_MIPS_SZLONG == 64)\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         powerpc* )\n           # Different ABIs are in use on AIX vs. Mac OS X vs. Linux,*BSD.\n           # No need to distinguish them here; the caller may distinguish\n           # them based on the OS.\n           # On powerpc64 systems, the C compiler may still be generating\n           # 32-bit code. And on powerpc-ibm-aix systems, the C compiler may\n           # be generating 64-bit code.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if defined __powerpc64__ || defined _ARCH_PPC64\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         rs6000 )\n           gl_cv_host_cpu_c_abi_32bit=yes\n           ;;\n\n         riscv32 | riscv64 )\n           # There are 6 ABIs: ilp32, ilp32f, ilp32d, lp64, lp64f, lp64d.\n           # Size of 'long' and 'void *':\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if defined __LP64__\n                    int ok;\n                  #else\n                    error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         s390* )\n           # On s390x, the C compiler may be generating 64-bit (= s390x) code\n           # or 31-bit (= s390) code.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if defined __LP64__ || defined __s390x__\n                    int ok;\n                  #else\n                    error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         sparc | sparc64 )\n           # UltraSPARCs running Linux have `uname -m` = \"sparc64\", but the\n           # C compiler still generates 32-bit code.\n           AC_COMPILE_IFELSE(\n             [AC_LANG_SOURCE(\n                [[#if defined __sparcv9 || defined __arch64__\n                   int ok;\n                  #else\n                   error fail\n                  #endif\n                ]])],\n             [gl_cv_host_cpu_c_abi_32bit=no],\n             [gl_cv_host_cpu_c_abi_32bit=yes])\n           ;;\n\n         *)\n           gl_cv_host_cpu_c_abi_32bit=no\n           ;;\n       esac\n     fi\n    ])\n\n  HOST_CPU_C_ABI_32BIT=\"$gl_cv_host_cpu_c_abi_32bit\"\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}