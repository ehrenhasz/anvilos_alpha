{
  "module_name": "kernel-inode-getattr.m4",
  "hash_id": "8550285ca60d773f57f3437e29d7529166c56b4777ea8cc33dd262dd62cdd8e3",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-inode-getattr.m4",
  "human_readable_source": "AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_GETATTR], [\n\tdnl #\n\tdnl # Linux 6.3 API\n\tdnl # The first arg of getattr I/O operations handler type\n\tdnl # is changed to struct mnt_idmap*\n\tdnl #\n\tZFS_LINUX_TEST_SRC([inode_operations_getattr_mnt_idmap], [\n\t\t#include <linux/fs.h>\n\n\t\tint test_getattr(\n\t\t    struct mnt_idmap *idmap,\n\t\t    const struct path *p, struct kstat *k,\n\t\t    u32 request_mask, unsigned int query_flags)\n\t\t    { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.getattr = test_getattr,\n\t\t};\n\t],[])\n\n\tdnl #\n\tdnl # Linux 5.12 API\n\tdnl # The getattr I/O operations handler type was extended to require\n\tdnl # a struct user_namespace* as its first arg, to support idmapped\n\tdnl # mounts.\n\tdnl #\n\tZFS_LINUX_TEST_SRC([inode_operations_getattr_userns], [\n\t\t#include <linux/fs.h>\n\n\t\tint test_getattr(\n\t\t\tstruct user_namespace *userns,\n\t\t    const struct path *p, struct kstat *k,\n\t\t    u32 request_mask, unsigned int query_flags)\n\t\t    { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.getattr = test_getattr,\n\t\t};\n\t],[])\n\n\tdnl #\n\tdnl # Linux 4.11 API\n\tdnl # See torvalds/linux@a528d35\n\tdnl #\n\tZFS_LINUX_TEST_SRC([inode_operations_getattr_path], [\n\t\t#include <linux/fs.h>\n\n\t\tint test_getattr(\n\t\t    const struct path *p, struct kstat *k,\n\t\t    u32 request_mask, unsigned int query_flags)\n\t\t    { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.getattr = test_getattr,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([inode_operations_getattr_vfsmount], [\n\t\t#include <linux/fs.h>\n\n\t\tint test_getattr(\n\t\t    struct vfsmount *mnt, struct dentry *d,\n\t\t    struct kstat *k)\n\t\t    { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.getattr = test_getattr,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_INODE_GETATTR], [\n\tdnl #\n\tdnl # Kernel 6.3 test\n\tdnl #\n\tAC_MSG_CHECKING([whether iops->getattr() takes mnt_idmap])\n\tZFS_LINUX_TEST_RESULT([inode_operations_getattr_mnt_idmap], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_IDMAP_IOPS_GETATTR, 1,\n\t\t    [iops->getattr() takes struct mnt_idmap*])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t\tdnl #\n\t\tdnl # Kernel 5.12 test\n\t\tdnl #\n\t\tAC_MSG_CHECKING([whether iops->getattr() takes user_namespace])\n\t\tZFS_LINUX_TEST_RESULT([inode_operations_getattr_userns], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_USERNS_IOPS_GETATTR, 1,\n\t\t\t    [iops->getattr() takes struct user_namespace*])\n\t\t],[\n\t\t\tAC_MSG_RESULT(no)\n\n\t\t\tdnl #\n\t\t\tdnl # Kernel 4.11 test\n\t\t\tdnl #\n\t\t\tAC_MSG_CHECKING([whether iops->getattr() takes a path])\n\t\t\tZFS_LINUX_TEST_RESULT([inode_operations_getattr_path], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_PATH_IOPS_GETATTR, 1,\n\t\t\t\t\t[iops->getattr() takes a path])\n\t\t\t],[\n\t\t\t\tAC_MSG_RESULT(no)\n\n\t\t\t\tdnl #\n\t\t\t\tdnl # Kernel < 4.11 test\n\t\t\t\tdnl #\n\t\t\t\tAC_MSG_CHECKING([whether iops->getattr() takes a vfsmount])\n\t\t\t\tZFS_LINUX_TEST_RESULT([inode_operations_getattr_vfsmount], [\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tAC_DEFINE(HAVE_VFSMOUNT_IOPS_GETATTR, 1,\n\t\t\t\t\t\t[iops->getattr() takes a vfsmount])\n\t\t\t\t],[\n\t\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\t])\n\t\t\t])\n\t\t])\n\t])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}