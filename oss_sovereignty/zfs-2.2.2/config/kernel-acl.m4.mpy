{
  "module_name": "kernel-acl.m4",
  "hash_id": "002b8252abb1fefd276278ff0cb843ca76136f15ba88c797a745f05d003f5285",
  "original_prompt": "Ingested from zfs-2.2.2/config/kernel-acl.m4",
  "human_readable_source": "dnl #\ndnl # Check if posix_acl_release can be used from a ZFS_META_LICENSED\ndnl # module.  The is_owner_or_cap macro was replaced by\ndnl # inode_owner_or_capable\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_RELEASE], [\n\tZFS_LINUX_TEST_SRC([posix_acl_release], [\n\t\t#include <linux/cred.h>\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl.h>\n\t], [\n\t\tstruct posix_acl *tmp = posix_acl_alloc(1, 0);\n\t\tposix_acl_release(tmp);\n\t], [], [ZFS_META_LICENSE])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_RELEASE], [\n\tAC_MSG_CHECKING([whether posix_acl_release() is available])\n\tZFS_LINUX_TEST_RESULT([posix_acl_release], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_POSIX_ACL_RELEASE, 1,\n\t\t    [posix_acl_release() is available])\n\n\t\tAC_MSG_CHECKING([whether posix_acl_release() is GPL-only])\n\t\tZFS_LINUX_TEST_RESULT([posix_acl_release_license], [\n\t\t\tAC_MSG_RESULT(no)\n\t\t],[\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_POSIX_ACL_RELEASE_GPL_ONLY, 1,\n\t\t\t    [posix_acl_release() is GPL-only])\n\t\t])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 3.14 API change,\ndnl # set_cached_acl() and forget_cached_acl() changed from inline to\ndnl # EXPORT_SYMBOL. In the former case, they may not be usable because of\ndnl # posix_acl_release. In the latter case, we can always use them.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_SET_CACHED_ACL_USABLE], [\n\tZFS_LINUX_TEST_SRC([set_cached_acl], [\n\t\t#include <linux/cred.h>\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl.h>\n\t], [\n\t\tstruct inode *ip = NULL;\n\t\tstruct posix_acl *acl = posix_acl_alloc(1, 0);\n\t\tset_cached_acl(ip, ACL_TYPE_ACCESS, acl);\n\t\tforget_cached_acl(ip, ACL_TYPE_ACCESS);\n\t], [], [ZFS_META_LICENSE])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SET_CACHED_ACL_USABLE], [\n\tAC_MSG_CHECKING([whether set_cached_acl() is usable])\n\tZFS_LINUX_TEST_RESULT([set_cached_acl_license], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SET_CACHED_ACL_USABLE, 1,\n\t\t    [set_cached_acl() is usable])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 3.1 API change,\ndnl # posix_acl_chmod() was added as the preferred interface.\ndnl #\ndnl # 3.14 API change,\ndnl # posix_acl_chmod() was changed to __posix_acl_chmod()\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_CHMOD], [\n\tZFS_LINUX_TEST_SRC([posix_acl_chmod], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl.h>\n\t],[\n\t\tposix_acl_chmod(NULL, 0, 0)\n\t])\n\n\tZFS_LINUX_TEST_SRC([__posix_acl_chmod], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl.h>\n\t],[\n\t\t__posix_acl_chmod(NULL, 0, 0)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_CHMOD], [\n\tAC_MSG_CHECKING([whether __posix_acl_chmod exists])\n\tZFS_LINUX_TEST_RESULT([__posix_acl_chmod], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE___POSIX_ACL_CHMOD, 1,\n\t\t    [__posix_acl_chmod() exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\n\t\tAC_MSG_CHECKING([whether posix_acl_chmod exists])\n\t\tZFS_LINUX_TEST_RESULT([posix_acl_chmod], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_POSIX_ACL_CHMOD, 1,\n\t\t\t    [posix_acl_chmod() exists])\n\t\t],[\n\t\t\tZFS_LINUX_TEST_ERROR([posix_acl_chmod()])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 3.1 API change,\ndnl # posix_acl_equiv_mode now wants an umode_t instead of a mode_t\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T], [\n\tZFS_LINUX_TEST_SRC([posix_acl_equiv_mode], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl.h>\n\t],[\n\t\tumode_t tmp;\n\t\tposix_acl_equiv_mode(NULL, &tmp);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T], [\n\tAC_MSG_CHECKING([whether posix_acl_equiv_mode() wants umode_t])\n\tZFS_LINUX_TEST_RESULT([posix_acl_equiv_mode], [\n\t\tAC_MSG_RESULT(yes)\n\t],[\n\t\tZFS_LINUX_TEST_ERROR([posix_acl_equiv_mode()])\n\t])\n])\n\ndnl #\ndnl # 4.8 API change,\ndnl # The function posix_acl_valid now must be passed a namespace.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_VALID_WITH_NS], [\n\tZFS_LINUX_TEST_SRC([posix_acl_valid_with_ns], [\n\t\t#include <linux/fs.h>\n\t\t#include <linux/posix_acl.h>\n\t],[\n\t\tstruct user_namespace *user_ns = NULL;\n\t\tconst struct posix_acl *acl = NULL;\n\t\tint error;\n\n\t\terror = posix_acl_valid(user_ns, acl);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_VALID_WITH_NS], [\n\tAC_MSG_CHECKING([whether posix_acl_valid() wants user namespace])\n\tZFS_LINUX_TEST_RESULT([posix_acl_valid_with_ns], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_POSIX_ACL_VALID_WITH_NS, 1,\n\t\t    [posix_acl_valid() wants user namespace])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 3.1 API change,\ndnl # Check if inode_operations contains the function get_acl\ndnl #\ndnl # 5.15 API change,\ndnl # Added the bool rcu argument to get_acl for rcu path walk.\ndnl #\ndnl # 6.2 API change,\ndnl # get_acl() was renamed to get_inode_acl()\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_GET_ACL], [\n\tZFS_LINUX_TEST_SRC([inode_operations_get_acl], [\n\t\t#include <linux/fs.h>\n\n\t\tstruct posix_acl *get_acl_fn(struct inode *inode, int type)\n\t\t    { return NULL; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.get_acl = get_acl_fn,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([inode_operations_get_acl_rcu], [\n\t\t#include <linux/fs.h>\n\n\t\tstruct posix_acl *get_acl_fn(struct inode *inode, int type,\n\t\t    bool rcu) { return NULL; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.get_acl = get_acl_fn,\n\t\t};\n\t],[])\n\n\tZFS_LINUX_TEST_SRC([inode_operations_get_inode_acl], [\n\t\t#include <linux/fs.h>\n\n\t\tstruct posix_acl *get_inode_acl_fn(struct inode *inode, int type,\n\t\t    bool rcu) { return NULL; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.get_inode_acl = get_inode_acl_fn,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_GET_ACL], [\n\tAC_MSG_CHECKING([whether iops->get_acl() exists])\n\tZFS_LINUX_TEST_RESULT([inode_operations_get_acl], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_GET_ACL, 1, [iops->get_acl() exists])\n\t],[\n\t\tZFS_LINUX_TEST_RESULT([inode_operations_get_acl_rcu], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_GET_ACL_RCU, 1, [iops->get_acl() takes rcu])\n\t\t],[\n\t\t\tZFS_LINUX_TEST_RESULT([inode_operations_get_inode_acl], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_GET_INODE_ACL, 1, [has iops->get_inode_acl()])\n\t\t\t],[\n\t\t\t\tZFS_LINUX_TEST_ERROR([iops->get_acl() or iops->get_inode_acl()])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 3.14 API change,\ndnl # Check if inode_operations contains the function set_acl\ndnl #\ndnl # 5.12 API change,\ndnl # set_acl() added a user_namespace* parameter first\ndnl #\ndnl # 6.2 API change,\ndnl # set_acl() second paramter changed to a struct dentry *\ndnl #\ndnl # 6.3 API change,\ndnl # set_acl() first parameter changed to struct mnt_idmap *\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_SET_ACL], [\n\tZFS_LINUX_TEST_SRC([inode_operations_set_acl_mnt_idmap_dentry], [\n\t\t#include <linux/fs.h>\n\n\t\tint set_acl_fn(struct mnt_idmap *idmap,\n\t\t    struct dentry *dent, struct posix_acl *acl,\n\t\t    int type) { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.set_acl = set_acl_fn,\n\t\t};\n\t],[])\n\tZFS_LINUX_TEST_SRC([inode_operations_set_acl_userns_dentry], [\n\t\t#include <linux/fs.h>\n\n\t\tint set_acl_fn(struct user_namespace *userns,\n\t\t    struct dentry *dent, struct posix_acl *acl,\n\t\t    int type) { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.set_acl = set_acl_fn,\n\t\t};\n\t],[])\n\tZFS_LINUX_TEST_SRC([inode_operations_set_acl_userns], [\n\t\t#include <linux/fs.h>\n\n\t\tint set_acl_fn(struct user_namespace *userns,\n\t\t    struct inode *inode, struct posix_acl *acl,\n\t\t    int type) { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.set_acl = set_acl_fn,\n\t\t};\n\t],[])\n\tZFS_LINUX_TEST_SRC([inode_operations_set_acl], [\n\t\t#include <linux/fs.h>\n\n\t\tint set_acl_fn(struct inode *inode, struct posix_acl *acl,\n\t\t    int type) { return 0; }\n\n\t\tstatic const struct inode_operations\n\t\t    iops __attribute__ ((unused)) = {\n\t\t\t.set_acl = set_acl_fn,\n\t\t};\n\t],[])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_SET_ACL], [\n\tAC_MSG_CHECKING([whether iops->set_acl() exists])\n\tZFS_LINUX_TEST_RESULT([inode_operations_set_acl_userns], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_SET_ACL, 1, [iops->set_acl() exists])\n\t\tAC_DEFINE(HAVE_SET_ACL_USERNS, 1, [iops->set_acl() takes 4 args])\n\t],[\n\t\tZFS_LINUX_TEST_RESULT([inode_operations_set_acl_mnt_idmap_dentry], [\n\t\t\tAC_MSG_RESULT(yes)\n\t\t\tAC_DEFINE(HAVE_SET_ACL, 1, [iops->set_acl() exists])\n\t\t\tAC_DEFINE(HAVE_SET_ACL_IDMAP_DENTRY, 1,\n\t\t\t    [iops->set_acl() takes 4 args, arg1 is struct mnt_idmap *])\n\t\t],[\n\t\t\tZFS_LINUX_TEST_RESULT([inode_operations_set_acl_userns_dentry], [\n\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\tAC_DEFINE(HAVE_SET_ACL, 1, [iops->set_acl() exists])\n\t\t\t\tAC_DEFINE(HAVE_SET_ACL_USERNS_DENTRY_ARG2, 1,\n\t\t\t\t    [iops->set_acl() takes 4 args, arg2 is struct dentry *])\n\t\t\t],[\n\t\t\t\tZFS_LINUX_TEST_RESULT([inode_operations_set_acl], [\n\t\t\t\t\tAC_MSG_RESULT(yes)\n\t\t\t\t\tAC_DEFINE(HAVE_SET_ACL, 1, [iops->set_acl() exists, takes 3 args])\n\t\t\t\t],[\n\t\t\t\t\tZFS_LINUX_REQUIRE_API([i_op->set_acl()], [3.14])\n\t\t\t\t])\n\t\t\t])\n\t\t])\n\t])\n])\n\ndnl #\ndnl # 4.7 API change,\ndnl # The kernel get_acl will now check cache before calling i_op->get_acl and\ndnl # do set_cached_acl after that, so i_op->get_acl don't need to do that\ndnl # anymore.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_GET_ACL_HANDLE_CACHE], [\n\tZFS_LINUX_TEST_SRC([get_acl_handle_cache], [\n\t\t#include <linux/fs.h>\n\t],[\n\t\tvoid *sentinel __attribute__ ((unused)) =\n\t\t    uncached_acl_sentinel(NULL);\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_GET_ACL_HANDLE_CACHE], [\n\tAC_MSG_CHECKING([whether uncached_acl_sentinel() exists])\n\tZFS_LINUX_TEST_RESULT([get_acl_handle_cache], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_KERNEL_GET_ACL_HANDLE_CACHE, 1,\n\t\t    [uncached_acl_sentinel() exists])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\ndnl #\ndnl # 4.16 kernel: check if struct posix_acl acl.a_refcount is a refcount_t.\ndnl # It's an atomic_t on older kernels.\ndnl #\nAC_DEFUN([ZFS_AC_KERNEL_SRC_ACL_HAS_REFCOUNT], [\n\tZFS_LINUX_TEST_SRC([acl_refcount], [\n\t\t#include <linux/backing-dev.h>\n\t\t#include <linux/refcount.h>\n\t\t#include <linux/posix_acl.h>\n\t],[\n\t\tstruct posix_acl acl;\n\t\trefcount_t *r __attribute__ ((unused)) = &acl.a_refcount;\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_ACL_HAS_REFCOUNT], [\n\tAC_MSG_CHECKING([whether posix_acl has refcount_t])\n\tZFS_LINUX_TEST_RESULT([acl_refcount], [\n\t\tAC_MSG_RESULT(yes)\n\t\tAC_DEFINE(HAVE_ACL_REFCOUNT, 1, [posix_acl has refcount_t])\n\t],[\n\t\tAC_MSG_RESULT(no)\n\t])\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_SRC_ACL], [\n\tZFS_AC_KERNEL_SRC_POSIX_ACL_RELEASE\n\tZFS_AC_KERNEL_SRC_SET_CACHED_ACL_USABLE\n\tZFS_AC_KERNEL_SRC_POSIX_ACL_CHMOD\n\tZFS_AC_KERNEL_SRC_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T\n\tZFS_AC_KERNEL_SRC_POSIX_ACL_VALID_WITH_NS\n\tZFS_AC_KERNEL_SRC_INODE_OPERATIONS_GET_ACL\n\tZFS_AC_KERNEL_SRC_INODE_OPERATIONS_SET_ACL\n\tZFS_AC_KERNEL_SRC_GET_ACL_HANDLE_CACHE\n\tZFS_AC_KERNEL_SRC_ACL_HAS_REFCOUNT\n])\n\nAC_DEFUN([ZFS_AC_KERNEL_ACL], [\n\tZFS_AC_KERNEL_POSIX_ACL_RELEASE\n\tZFS_AC_KERNEL_SET_CACHED_ACL_USABLE\n\tZFS_AC_KERNEL_POSIX_ACL_CHMOD\n\tZFS_AC_KERNEL_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T\n\tZFS_AC_KERNEL_POSIX_ACL_VALID_WITH_NS\n\tZFS_AC_KERNEL_INODE_OPERATIONS_GET_ACL\n\tZFS_AC_KERNEL_INODE_OPERATIONS_SET_ACL\n\tZFS_AC_KERNEL_GET_ACL_HANDLE_CACHE\n\tZFS_AC_KERNEL_ACL_HAS_REFCOUNT\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}