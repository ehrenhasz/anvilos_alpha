{
  "module_name": "raidz_test.c",
  "hash_id": "c23c3fe989282d405f9c6ff1e3c25e5f596ced100741a85c840403a74eaec89e",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/raidz_test/raidz_test.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/zio.h>\n#include <umem.h>\n#include <sys/vdev_raidz.h>\n#include <sys/vdev_raidz_impl.h>\n#include <assert.h>\n#include <stdio.h>\n#include \"raidz_test.h\"\n\nstatic int *rand_data;\nraidz_test_opts_t rto_opts;\n\nstatic char pid_s[16];\n\nstatic void sig_handler(int signo)\n{\n\tint old_errno = errno;\n\tstruct sigaction action;\n\t \n\taction.sa_handler = SIG_DFL;\n\tsigemptyset(&action.sa_mask);\n\taction.sa_flags = 0;\n\t(void) sigaction(signo, &action, NULL);\n\n\tif (rto_opts.rto_gdb) {\n\t\tpid_t pid = fork();\n\t\tif (pid == 0) {\n\t\t\texeclp(\"gdb\", \"gdb\", \"-ex\", \"set pagination 0\",\n\t\t\t    \"-p\", pid_s, NULL);\n\t\t\t_exit(-1);\n\t\t} else if (pid > 0)\n\t\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t\t;\n\t}\n\n\traise(signo);\n\terrno = old_errno;\n}\n\nstatic void print_opts(raidz_test_opts_t *opts, boolean_t force)\n{\n\tconst char *verbose;\n\tswitch (opts->rto_v) {\n\t\tcase D_ALL:\n\t\t\tverbose = \"no\";\n\t\t\tbreak;\n\t\tcase D_INFO:\n\t\t\tverbose = \"info\";\n\t\t\tbreak;\n\t\tcase D_DEBUG:\n\t\tdefault:\n\t\t\tverbose = \"debug\";\n\t\t\tbreak;\n\t}\n\n\tif (force || opts->rto_v >= D_INFO) {\n\t\t(void) fprintf(stdout, DBLSEP \"Running with options:\\n\"\n\t\t    \"  (-a) zio ashift                   : %zu\\n\"\n\t\t    \"  (-o) zio offset                   : 1 << %zu\\n\"\n\t\t    \"  (-e) expanded map                 : %s\\n\"\n\t\t    \"  (-r) reflow offset                : %llx\\n\"\n\t\t    \"  (-d) number of raidz data columns : %zu\\n\"\n\t\t    \"  (-s) size of DATA                 : 1 << %zu\\n\"\n\t\t    \"  (-S) sweep parameters             : %s \\n\"\n\t\t    \"  (-v) verbose                      : %s \\n\\n\",\n\t\t    opts->rto_ashift,\t\t\t\t \n\t\t    ilog2(opts->rto_offset),\t\t\t \n\t\t    opts->rto_expand ? \"yes\" : \"no\",\t\t \n\t\t    (u_longlong_t)opts->rto_expand_offset,\t \n\t\t    opts->rto_dcols,\t\t\t\t \n\t\t    ilog2(opts->rto_dsize),\t\t\t \n\t\t    opts->rto_sweep ? \"yes\" : \"no\",\t\t \n\t\t    verbose);\t\t\t\t\t \n\t}\n}\n\nstatic void usage(boolean_t requested)\n{\n\tconst raidz_test_opts_t *o = &rto_opts_defaults;\n\n\tFILE *fp = requested ? stdout : stderr;\n\n\t(void) fprintf(fp, \"Usage:\\n\"\n\t    \"\\t[-a zio ashift (default: %zu)]\\n\"\n\t    \"\\t[-o zio offset, exponent radix 2 (default: %zu)]\\n\"\n\t    \"\\t[-d number of raidz data columns (default: %zu)]\\n\"\n\t    \"\\t[-s zio size, exponent radix 2 (default: %zu)]\\n\"\n\t    \"\\t[-S parameter sweep (default: %s)]\\n\"\n\t    \"\\t[-t timeout for parameter sweep test]\\n\"\n\t    \"\\t[-B benchmark all raidz implementations]\\n\"\n\t    \"\\t[-e use expanded raidz map (default: %s)]\\n\"\n\t    \"\\t[-r expanded raidz map reflow offset (default: %llx)]\\n\"\n\t    \"\\t[-v increase verbosity (default: %d)]\\n\"\n\t    \"\\t[-h (print help)]\\n\"\n\t    \"\\t[-T test the test, see if failure would be detected]\\n\"\n\t    \"\\t[-D debug (attach gdb on SIGSEGV)]\\n\"\n\t    \"\",\n\t    o->rto_ashift,\t\t\t\t \n\t    ilog2(o->rto_offset),\t\t\t \n\t    o->rto_dcols,\t\t\t\t \n\t    ilog2(o->rto_dsize),\t\t\t \n\t    rto_opts.rto_sweep ? \"yes\" : \"no\",\t\t \n\t    rto_opts.rto_expand ? \"yes\" : \"no\",\t\t \n\t    (u_longlong_t)o->rto_expand_offset,\t\t \n\t    o->rto_v);\t\t\t\t\t \n\n\texit(requested ? 0 : 1);\n}\n\nstatic void process_options(int argc, char **argv)\n{\n\tsize_t value;\n\tint opt;\n\traidz_test_opts_t *o = &rto_opts;\n\n\tmemcpy(o, &rto_opts_defaults, sizeof (*o));\n\n\twhile ((opt = getopt(argc, argv, \"TDBSvha:er:o:d:s:t:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\tvalue = strtoull(optarg, NULL, 0);\n\t\t\to->rto_ashift = MIN(13, MAX(9, value));\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\to->rto_expand = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\to->rto_expand_offset = strtoull(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tvalue = strtoull(optarg, NULL, 0);\n\t\t\to->rto_offset = ((1ULL << MIN(12, value)) >> 9) << 9;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tvalue = strtoull(optarg, NULL, 0);\n\t\t\to->rto_dcols = MIN(255, MAX(1, value));\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tvalue = strtoull(optarg, NULL, 0);\n\t\t\to->rto_dsize = 1ULL <<  MIN(SPA_MAXBLOCKSHIFT,\n\t\t\t    MAX(SPA_MINBLOCKSHIFT, value));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tvalue = strtoull(optarg, NULL, 0);\n\t\t\to->rto_sweep_timeout = value;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\to->rto_v++;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\to->rto_sweep = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\to->rto_benchmark = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\to->rto_gdb = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\to->rto_sanity = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(B_TRUE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n#define\tDATA_COL(rr, i) ((rr)->rr_col[rr->rr_firstdatacol + (i)].rc_abd)\n#define\tDATA_COL_SIZE(rr, i) ((rr)->rr_col[rr->rr_firstdatacol + (i)].rc_size)\n\n#define\tCODE_COL(rr, i) ((rr)->rr_col[(i)].rc_abd)\n#define\tCODE_COL_SIZE(rr, i) ((rr)->rr_col[(i)].rc_size)\n\nstatic int\ncmp_code(raidz_test_opts_t *opts, const raidz_map_t *rm, const int parity)\n{\n\tint r, i, ret = 0;\n\n\tVERIFY(parity >= 1 && parity <= 3);\n\n\tfor (r = 0; r < rm->rm_nrows; r++) {\n\t\traidz_row_t * const rr = rm->rm_row[r];\n\t\traidz_row_t * const rrg = opts->rm_golden->rm_row[r];\n\t\tfor (i = 0; i < parity; i++) {\n\t\t\tif (CODE_COL_SIZE(rrg, i) == 0) {\n\t\t\t\tVERIFY0(CODE_COL_SIZE(rr, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (abd_cmp(CODE_COL(rr, i),\n\t\t\t    CODE_COL(rrg, i)) != 0) {\n\t\t\t\tret++;\n\t\t\t\tLOG_OPT(D_DEBUG, opts,\n\t\t\t\t    \"\\nParity block [%d] different!\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\treturn (ret);\n}\n\nstatic int\ncmp_data(raidz_test_opts_t *opts, raidz_map_t *rm)\n{\n\tint r, i, dcols, ret = 0;\n\n\tfor (r = 0; r < rm->rm_nrows; r++) {\n\t\traidz_row_t *rr = rm->rm_row[r];\n\t\traidz_row_t *rrg = opts->rm_golden->rm_row[r];\n\t\tdcols = opts->rm_golden->rm_row[0]->rr_cols -\n\t\t    raidz_parity(opts->rm_golden);\n\t\tfor (i = 0; i < dcols; i++) {\n\t\t\tif (DATA_COL_SIZE(rrg, i) == 0) {\n\t\t\t\tVERIFY0(DATA_COL_SIZE(rr, i));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (abd_cmp(DATA_COL(rrg, i),\n\t\t\t    DATA_COL(rr, i)) != 0) {\n\t\t\t\tret++;\n\n\t\t\t\tLOG_OPT(D_DEBUG, opts,\n\t\t\t\t    \"\\nData block [%d] different!\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\treturn (ret);\n}\n\nstatic int\ninit_rand(void *data, size_t size, void *private)\n{\n\t(void) private;\n\tmemcpy(data, rand_data, size);\n\treturn (0);\n}\n\nstatic void\ncorrupt_colums(raidz_map_t *rm, const int *tgts, const int cnt)\n{\n\tfor (int r = 0; r < rm->rm_nrows; r++) {\n\t\traidz_row_t *rr = rm->rm_row[r];\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\traidz_col_t *col = &rr->rr_col[tgts[i]];\n\t\t\tabd_iterate_func(col->rc_abd, 0, col->rc_size,\n\t\t\t    init_rand, NULL);\n\t\t}\n\t}\n}\n\nvoid\ninit_zio_abd(zio_t *zio)\n{\n\tabd_iterate_func(zio->io_abd, 0, zio->io_size, init_rand, NULL);\n}\n\nstatic void\nfini_raidz_map(zio_t **zio, raidz_map_t **rm)\n{\n\tvdev_raidz_map_free(*rm);\n\traidz_free((*zio)->io_abd, (*zio)->io_size);\n\tumem_free(*zio, sizeof (zio_t));\n\n\t*zio = NULL;\n\t*rm = NULL;\n}\n\nstatic int\ninit_raidz_golden_map(raidz_test_opts_t *opts, const int parity)\n{\n\tint err = 0;\n\tzio_t *zio_test;\n\traidz_map_t *rm_test;\n\tconst size_t total_ncols = opts->rto_dcols + parity;\n\n\tif (opts->rm_golden) {\n\t\tfini_raidz_map(&opts->zio_golden, &opts->rm_golden);\n\t}\n\n\topts->zio_golden = umem_zalloc(sizeof (zio_t), UMEM_NOFAIL);\n\tzio_test = umem_zalloc(sizeof (zio_t), UMEM_NOFAIL);\n\n\topts->zio_golden->io_offset = zio_test->io_offset = opts->rto_offset;\n\topts->zio_golden->io_size = zio_test->io_size = opts->rto_dsize;\n\n\topts->zio_golden->io_abd = raidz_alloc(opts->rto_dsize);\n\tzio_test->io_abd = raidz_alloc(opts->rto_dsize);\n\n\tinit_zio_abd(opts->zio_golden);\n\tinit_zio_abd(zio_test);\n\n\tVERIFY0(vdev_raidz_impl_set(\"original\"));\n\n\tif (opts->rto_expand) {\n\t\topts->rm_golden =\n\t\t    vdev_raidz_map_alloc_expanded(opts->zio_golden->io_abd,\n\t\t    opts->zio_golden->io_size, opts->zio_golden->io_offset,\n\t\t    opts->rto_ashift, total_ncols+1, total_ncols,\n\t\t    parity, opts->rto_expand_offset);\n\t\trm_test = vdev_raidz_map_alloc_expanded(zio_test->io_abd,\n\t\t    zio_test->io_size, zio_test->io_offset,\n\t\t    opts->rto_ashift, total_ncols+1, total_ncols,\n\t\t    parity, opts->rto_expand_offset);\n\t} else {\n\t\topts->rm_golden = vdev_raidz_map_alloc(opts->zio_golden,\n\t\t    opts->rto_ashift, total_ncols, parity);\n\t\trm_test = vdev_raidz_map_alloc(zio_test,\n\t\t    opts->rto_ashift, total_ncols, parity);\n\t}\n\n\tVERIFY(opts->zio_golden);\n\tVERIFY(opts->rm_golden);\n\n\tvdev_raidz_generate_parity(opts->rm_golden);\n\tvdev_raidz_generate_parity(rm_test);\n\n\t \n\terr |= cmp_data(opts, rm_test);\n\terr |= cmp_code(opts, rm_test, parity);\n\n\tif (err)\n\t\tERR(\"initializing the golden copy ... [FAIL]!\\n\");\n\n\t \n\tfini_raidz_map(&zio_test, &rm_test);\n\n\treturn (err);\n}\n\n \nraidz_map_t *\nvdev_raidz_map_alloc_expanded(abd_t *abd, uint64_t size, uint64_t offset,\n    uint64_t ashift, uint64_t physical_cols, uint64_t logical_cols,\n    uint64_t nparity, uint64_t reflow_offset)\n{\n\t \n\tuint64_t s = size >> ashift;\n\tuint64_t q, r, bc, devidx, asize = 0, tot;\n\n\t \n\tq = s / (logical_cols - nparity);\n\n\t \n\tr = s - q * (logical_cols - nparity);\n\n\t \n\tbc = (r == 0 ? 0 : r + nparity);\n\n\t \n\ttot = s + nparity * (q + (r == 0 ? 0 : 1));\n\n\t \n\tuint64_t rows = howmany(tot, logical_cols);\n\tint cols = MIN(tot, logical_cols);\n\n\traidz_map_t *rm = kmem_zalloc(offsetof(raidz_map_t, rm_row[rows]),\n\t    KM_SLEEP);\n\trm->rm_nrows = rows;\n\n\tfor (uint64_t row = 0; row < rows; row++) {\n\t\traidz_row_t *rr = kmem_alloc(offsetof(raidz_row_t,\n\t\t    rr_col[cols]), KM_SLEEP);\n\t\trm->rm_row[row] = rr;\n\n\t\t \n\t\tuint64_t b = (offset >> ashift) + row * logical_cols;\n\n\t\t \n\t\tint row_phys_cols = physical_cols;\n\t\tif (b + (logical_cols - nparity) > reflow_offset >> ashift)\n\t\t\trow_phys_cols--;\n\n\t\t \n\t\tuint64_t child_id = b % row_phys_cols;\n\t\t \n\t\tuint64_t child_offset = (b / row_phys_cols) << ashift;\n\n\t\t \n\t\trr->rr_cols = cols;\n\t\trr->rr_bigcols = bc;\n\t\trr->rr_missingdata = 0;\n\t\trr->rr_missingparity = 0;\n\t\trr->rr_firstdatacol = nparity;\n\t\trr->rr_abd_empty = NULL;\n\t\trr->rr_nempty = 0;\n\n\t\tfor (int c = 0; c < rr->rr_cols; c++, child_id++) {\n\t\t\tif (child_id >= row_phys_cols) {\n\t\t\t\tchild_id -= row_phys_cols;\n\t\t\t\tchild_offset += 1ULL << ashift;\n\t\t\t}\n\t\t\trr->rr_col[c].rc_devidx = child_id;\n\t\t\trr->rr_col[c].rc_offset = child_offset;\n\t\t\trr->rr_col[c].rc_orig_data = NULL;\n\t\t\trr->rr_col[c].rc_error = 0;\n\t\t\trr->rr_col[c].rc_tried = 0;\n\t\t\trr->rr_col[c].rc_skipped = 0;\n\t\t\trr->rr_col[c].rc_need_orig_restore = B_FALSE;\n\n\t\t\tuint64_t dc = c - rr->rr_firstdatacol;\n\t\t\tif (c < rr->rr_firstdatacol) {\n\t\t\t\trr->rr_col[c].rc_size = 1ULL << ashift;\n\t\t\t\trr->rr_col[c].rc_abd =\n\t\t\t\t    abd_alloc_linear(rr->rr_col[c].rc_size,\n\t\t\t\t    B_TRUE);\n\t\t\t} else if (row == rows - 1 && bc != 0 && c >= bc) {\n\t\t\t\t \n\t\t\t\trr->rr_col[c].rc_size = 0;\n\t\t\t\trr->rr_col[c].rc_abd = NULL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuint64_t off;\n\n\t\t\t\tif (c < bc || r == 0) {\n\t\t\t\t\toff = dc * rows + row;\n\t\t\t\t} else {\n\t\t\t\t\toff = r * rows +\n\t\t\t\t\t    (dc - r) * (rows - 1) + row;\n\t\t\t\t}\n\t\t\t\trr->rr_col[c].rc_size = 1ULL << ashift;\n\t\t\t\trr->rr_col[c].rc_abd = abd_get_offset_struct(\n\t\t\t\t    &rr->rr_col[c].rc_abdstruct,\n\t\t\t\t    abd, off << ashift, 1 << ashift);\n\t\t\t}\n\n\t\t\tasize += rr->rr_col[c].rc_size;\n\t\t}\n\t\t \n\t\tif (rr->rr_firstdatacol == 1 && rr->rr_cols > 1 &&\n\t\t    (offset & (1ULL << 20))) {\n\t\t\tASSERT(rr->rr_cols >= 2);\n\t\t\tASSERT(rr->rr_col[0].rc_size == rr->rr_col[1].rc_size);\n\t\t\tdevidx = rr->rr_col[0].rc_devidx;\n\t\t\tuint64_t o = rr->rr_col[0].rc_offset;\n\t\t\trr->rr_col[0].rc_devidx = rr->rr_col[1].rc_devidx;\n\t\t\trr->rr_col[0].rc_offset = rr->rr_col[1].rc_offset;\n\t\t\trr->rr_col[1].rc_devidx = devidx;\n\t\t\trr->rr_col[1].rc_offset = o;\n\t\t}\n\n\t}\n\tASSERT3U(asize, ==, tot << ashift);\n\n\t \n\trm->rm_ops = vdev_raidz_math_get_ops();\n\n\treturn (rm);\n}\n\nstatic raidz_map_t *\ninit_raidz_map(raidz_test_opts_t *opts, zio_t **zio, const int parity)\n{\n\traidz_map_t *rm = NULL;\n\tconst size_t alloc_dsize = opts->rto_dsize;\n\tconst size_t total_ncols = opts->rto_dcols + parity;\n\tconst int ccols[] = { 0, 1, 2 };\n\n\tVERIFY(zio);\n\tVERIFY(parity <= 3 && parity >= 1);\n\n\t*zio = umem_zalloc(sizeof (zio_t), UMEM_NOFAIL);\n\n\t(*zio)->io_offset = 0;\n\t(*zio)->io_size = alloc_dsize;\n\t(*zio)->io_abd = raidz_alloc(alloc_dsize);\n\tinit_zio_abd(*zio);\n\n\tif (opts->rto_expand) {\n\t\trm = vdev_raidz_map_alloc_expanded((*zio)->io_abd,\n\t\t    (*zio)->io_size, (*zio)->io_offset,\n\t\t    opts->rto_ashift, total_ncols+1, total_ncols,\n\t\t    parity, opts->rto_expand_offset);\n\t} else {\n\t\trm = vdev_raidz_map_alloc(*zio, opts->rto_ashift,\n\t\t    total_ncols, parity);\n\t}\n\tVERIFY(rm);\n\n\t \n\tcorrupt_colums(rm, ccols, parity);\n\n\treturn (rm);\n}\n\nstatic int\nrun_gen_check(raidz_test_opts_t *opts)\n{\n\tchar **impl_name;\n\tint fn, err = 0;\n\tzio_t *zio_test;\n\traidz_map_t *rm_test;\n\n\terr = init_raidz_golden_map(opts, PARITY_PQR);\n\tif (0 != err)\n\t\treturn (err);\n\n\tLOG(D_INFO, DBLSEP);\n\tLOG(D_INFO, \"Testing parity generation...\\n\");\n\n\tfor (impl_name = (char **)raidz_impl_names+1; *impl_name != NULL;\n\t    impl_name++) {\n\n\t\tLOG(D_INFO, SEP);\n\t\tLOG(D_INFO, \"\\tTesting [%s] implementation...\", *impl_name);\n\n\t\tif (0 != vdev_raidz_impl_set(*impl_name)) {\n\t\t\tLOG(D_INFO, \"[SKIP]\\n\");\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tLOG(D_INFO, \"[SUPPORTED]\\n\");\n\t\t}\n\n\t\tfor (fn = 0; fn < RAIDZ_GEN_NUM; fn++) {\n\n\t\t\t \n\t\t\tif (rto_opts.rto_should_stop)\n\t\t\t\treturn (err);\n\n\t\t\t \n\t\t\trm_test = init_raidz_map(opts, &zio_test, fn+1);\n\t\t\tVERIFY(rm_test);\n\n\t\t\tLOG(D_INFO, \"\\t\\tTesting method [%s] ...\",\n\t\t\t    raidz_gen_name[fn]);\n\n\t\t\tif (!opts->rto_sanity)\n\t\t\t\tvdev_raidz_generate_parity(rm_test);\n\n\t\t\tif (cmp_code(opts, rm_test, fn+1) != 0) {\n\t\t\t\tLOG(D_INFO, \"[FAIL]\\n\");\n\t\t\t\terr++;\n\t\t\t} else\n\t\t\t\tLOG(D_INFO, \"[PASS]\\n\");\n\n\t\t\tfini_raidz_map(&zio_test, &rm_test);\n\t\t}\n\t}\n\n\tfini_raidz_map(&opts->zio_golden, &opts->rm_golden);\n\n\treturn (err);\n}\n\nstatic int\nrun_rec_check_impl(raidz_test_opts_t *opts, raidz_map_t *rm, const int fn)\n{\n\tint x0, x1, x2;\n\tint tgtidx[3];\n\tint err = 0;\n\tstatic const int rec_tgts[7][3] = {\n\t\t{1, 2, 3},\t \n\t\t{0, 2, 3},\t \n\t\t{0, 1, 3},\t \n\t\t{2, 3, 4},\t \n\t\t{1, 3, 4},\t \n\t\t{0, 3, 4},\t \n\t\t{3, 4, 5}\t \n\t};\n\n\tmemcpy(tgtidx, rec_tgts[fn], sizeof (tgtidx));\n\n\tif (fn < RAIDZ_REC_PQ) {\n\t\t \n\t\tfor (x0 = 0; x0 < opts->rto_dcols; x0++) {\n\t\t\tif (x0 >= rm->rm_row[0]->rr_cols - raidz_parity(rm))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (rto_opts.rto_should_stop)\n\t\t\t\treturn (err);\n\n\t\t\tLOG(D_DEBUG, \"[%d] \", x0);\n\n\t\t\ttgtidx[2] = x0 + raidz_parity(rm);\n\n\t\t\tcorrupt_colums(rm, tgtidx+2, 1);\n\n\t\t\tif (!opts->rto_sanity)\n\t\t\t\tvdev_raidz_reconstruct(rm, tgtidx, 3);\n\n\t\t\tif (cmp_data(opts, rm) != 0) {\n\t\t\t\terr++;\n\t\t\t\tLOG(D_DEBUG, \"\\nREC D[%d]... [FAIL]\\n\", x0);\n\t\t\t}\n\t\t}\n\n\t} else if (fn < RAIDZ_REC_PQR) {\n\t\t \n\t\tfor (x0 = 0; x0 < opts->rto_dcols; x0++) {\n\t\t\tif (x0 >= rm->rm_row[0]->rr_cols - raidz_parity(rm))\n\t\t\t\tcontinue;\n\t\t\tfor (x1 = x0 + 1; x1 < opts->rto_dcols; x1++) {\n\t\t\t\tif (x1 >= rm->rm_row[0]->rr_cols -\n\t\t\t\t    raidz_parity(rm))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (rto_opts.rto_should_stop)\n\t\t\t\t\treturn (err);\n\n\t\t\t\tLOG(D_DEBUG, \"[%d %d] \", x0, x1);\n\n\t\t\t\ttgtidx[1] = x0 + raidz_parity(rm);\n\t\t\t\ttgtidx[2] = x1 + raidz_parity(rm);\n\n\t\t\t\tcorrupt_colums(rm, tgtidx+1, 2);\n\n\t\t\t\tif (!opts->rto_sanity)\n\t\t\t\t\tvdev_raidz_reconstruct(rm, tgtidx, 3);\n\n\t\t\t\tif (cmp_data(opts, rm) != 0) {\n\t\t\t\t\terr++;\n\t\t\t\t\tLOG(D_DEBUG, \"\\nREC D[%d %d]... \"\n\t\t\t\t\t    \"[FAIL]\\n\", x0, x1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfor (x0 = 0; x0 < opts->rto_dcols; x0++) {\n\t\t\tif (x0 >= rm->rm_row[0]->rr_cols - raidz_parity(rm))\n\t\t\t\tcontinue;\n\t\t\tfor (x1 = x0 + 1; x1 < opts->rto_dcols; x1++) {\n\t\t\t\tif (x1 >= rm->rm_row[0]->rr_cols -\n\t\t\t\t    raidz_parity(rm))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (x2 = x1 + 1; x2 < opts->rto_dcols; x2++) {\n\t\t\t\t\tif (x2 >= rm->rm_row[0]->rr_cols -\n\t\t\t\t\t    raidz_parity(rm))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t \n\t\t\t\t\tif (rto_opts.rto_should_stop)\n\t\t\t\t\t\treturn (err);\n\n\t\t\t\t\tLOG(D_DEBUG, \"[%d %d %d]\", x0, x1, x2);\n\n\t\t\t\t\ttgtidx[0] = x0 + raidz_parity(rm);\n\t\t\t\t\ttgtidx[1] = x1 + raidz_parity(rm);\n\t\t\t\t\ttgtidx[2] = x2 + raidz_parity(rm);\n\n\t\t\t\t\tcorrupt_colums(rm, tgtidx, 3);\n\n\t\t\t\t\tif (!opts->rto_sanity)\n\t\t\t\t\t\tvdev_raidz_reconstruct(rm,\n\t\t\t\t\t\t    tgtidx, 3);\n\n\t\t\t\t\tif (cmp_data(opts, rm) != 0) {\n\t\t\t\t\t\terr++;\n\t\t\t\t\t\tLOG(D_DEBUG,\n\t\t\t\t\t\t    \"\\nREC D[%d %d %d]... \"\n\t\t\t\t\t\t    \"[FAIL]\\n\", x0, x1, x2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (err);\n}\n\nstatic int\nrun_rec_check(raidz_test_opts_t *opts)\n{\n\tchar **impl_name;\n\tunsigned fn, err = 0;\n\tzio_t *zio_test;\n\traidz_map_t *rm_test;\n\n\terr = init_raidz_golden_map(opts, PARITY_PQR);\n\tif (0 != err)\n\t\treturn (err);\n\n\tLOG(D_INFO, DBLSEP);\n\tLOG(D_INFO, \"Testing data reconstruction...\\n\");\n\n\tfor (impl_name = (char **)raidz_impl_names+1; *impl_name != NULL;\n\t    impl_name++) {\n\n\t\tLOG(D_INFO, SEP);\n\t\tLOG(D_INFO, \"\\tTesting [%s] implementation...\", *impl_name);\n\n\t\tif (vdev_raidz_impl_set(*impl_name) != 0) {\n\t\t\tLOG(D_INFO, \"[SKIP]\\n\");\n\t\t\tcontinue;\n\t\t} else\n\t\t\tLOG(D_INFO, \"[SUPPORTED]\\n\");\n\n\n\t\t \n\t\trm_test = init_raidz_map(opts, &zio_test, PARITY_PQR);\n\t\t \n\t\tvdev_raidz_generate_parity(rm_test);\n\n\t\tfor (fn = 0; fn < RAIDZ_REC_NUM; fn++) {\n\n\t\t\tLOG(D_INFO, \"\\t\\tTesting method [%s] ...\",\n\t\t\t    raidz_rec_name[fn]);\n\n\t\t\tif (run_rec_check_impl(opts, rm_test, fn) != 0) {\n\t\t\t\tLOG(D_INFO, \"[FAIL]\\n\");\n\t\t\t\terr++;\n\n\t\t\t} else\n\t\t\t\tLOG(D_INFO, \"[PASS]\\n\");\n\n\t\t}\n\t\t \n\t\tfini_raidz_map(&zio_test, &rm_test);\n\t}\n\n\tfini_raidz_map(&opts->zio_golden, &opts->rm_golden);\n\n\treturn (err);\n}\n\nstatic int\nrun_test(raidz_test_opts_t *opts)\n{\n\tint err = 0;\n\n\tif (opts == NULL)\n\t\topts = &rto_opts;\n\n\tprint_opts(opts, B_FALSE);\n\n\terr |= run_gen_check(opts);\n\terr |= run_rec_check(opts);\n\n\treturn (err);\n}\n\n#define\tSWEEP_RUNNING\t0\n#define\tSWEEP_FINISHED\t1\n#define\tSWEEP_ERROR\t2\n#define\tSWEEP_TIMEOUT\t3\n\nstatic int sweep_state = 0;\nstatic raidz_test_opts_t failed_opts;\n\nstatic kmutex_t sem_mtx;\nstatic kcondvar_t sem_cv;\nstatic int max_free_slots;\nstatic int free_slots;\n\nstatic __attribute__((noreturn)) void\nsweep_thread(void *arg)\n{\n\tint err = 0;\n\traidz_test_opts_t *opts = (raidz_test_opts_t *)arg;\n\tVERIFY(opts != NULL);\n\n\terr = run_test(opts);\n\n\tif (rto_opts.rto_sanity) {\n\t\t \n\t\tif (rand() < (RAND_MAX/4))\n\t\t\terr = 1;\n\t}\n\n\tif (0 != err) {\n\t\tmutex_enter(&sem_mtx);\n\t\tmemcpy(&failed_opts, opts, sizeof (raidz_test_opts_t));\n\t\tsweep_state = SWEEP_ERROR;\n\t\tmutex_exit(&sem_mtx);\n\t}\n\n\tumem_free(opts, sizeof (raidz_test_opts_t));\n\n\t \n\tmutex_enter(&sem_mtx);\n\tfree_slots++;\n\tcv_signal(&sem_cv);\n\tmutex_exit(&sem_mtx);\n\n\tthread_exit();\n}\n\nstatic int\nrun_sweep(void)\n{\n\tstatic const size_t dcols_v[] = { 1, 2, 3, 4, 5, 6, 7, 8, 12, 15, 16 };\n\tstatic const size_t ashift_v[] = { 9, 12, 14 };\n\tstatic const size_t size_v[] = { 1 << 9, 21 * (1 << 9), 13 * (1 << 12),\n\t\t1 << 17, (1 << 20) - (1 << 12), SPA_MAXBLOCKSIZE };\n\n\t(void) setvbuf(stdout, NULL, _IONBF, 0);\n\n\tulong_t total_comb = ARRAY_SIZE(size_v) * ARRAY_SIZE(ashift_v) *\n\t    ARRAY_SIZE(dcols_v);\n\tulong_t tried_comb = 0;\n\thrtime_t time_diff, start_time = gethrtime();\n\traidz_test_opts_t *opts;\n\tint a, d, s;\n\n\tmax_free_slots = free_slots = MAX(2, boot_ncpus);\n\n\tmutex_init(&sem_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&sem_cv, NULL, CV_DEFAULT, NULL);\n\n\tfor (s = 0; s < ARRAY_SIZE(size_v); s++)\n\tfor (a = 0; a < ARRAY_SIZE(ashift_v); a++)\n\tfor (d = 0; d < ARRAY_SIZE(dcols_v); d++) {\n\n\t\tif (size_v[s] < (1 << ashift_v[a])) {\n\t\t\ttotal_comb--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (++tried_comb % 20 == 0)\n\t\t\tLOG(D_ALL, \"%lu/%lu... \", tried_comb, total_comb);\n\n\t\t \n\t\tmutex_enter(&sem_mtx);\n\t\twhile (cv_timedwait_sig(&sem_cv, &sem_mtx,\n\t\t    ddi_get_lbolt() + hz)) {\n\n\t\t\t \n\t\t\ttime_diff = (gethrtime() - start_time) / NANOSEC;\n\t\t\tif (rto_opts.rto_sweep_timeout > 0 &&\n\t\t\t    time_diff >= rto_opts.rto_sweep_timeout) {\n\t\t\t\tsweep_state = SWEEP_TIMEOUT;\n\t\t\t\trto_opts.rto_should_stop = B_TRUE;\n\t\t\t\tmutex_exit(&sem_mtx);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sweep_state != SWEEP_RUNNING) {\n\t\t\t\tmutex_exit(&sem_mtx);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (free_slots > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfree_slots--;\n\t\tmutex_exit(&sem_mtx);\n\n\t\topts = umem_zalloc(sizeof (raidz_test_opts_t), UMEM_NOFAIL);\n\t\topts->rto_ashift = ashift_v[a];\n\t\topts->rto_dcols = dcols_v[d];\n\t\topts->rto_offset = (1ULL << ashift_v[a]) * rand();\n\t\topts->rto_dsize = size_v[s];\n\t\topts->rto_expand = rto_opts.rto_expand;\n\t\topts->rto_expand_offset = rto_opts.rto_expand_offset;\n\t\topts->rto_v = 0;  \n\n\t\tVERIFY3P(thread_create(NULL, 0, sweep_thread, (void *) opts,\n\t\t    0, NULL, TS_RUN, defclsyspri), !=, NULL);\n\t}\n\nexit:\n\tLOG(D_ALL, \"\\nWaiting for test threads to finish...\\n\");\n\tmutex_enter(&sem_mtx);\n\tVERIFY(free_slots <= max_free_slots);\n\twhile (free_slots < max_free_slots) {\n\t\t(void) cv_wait(&sem_cv, &sem_mtx);\n\t}\n\tmutex_exit(&sem_mtx);\n\n\tif (sweep_state == SWEEP_ERROR) {\n\t\tERR(\"Sweep test failed! Failed option: \\n\");\n\t\tprint_opts(&failed_opts, B_TRUE);\n\t} else {\n\t\tif (sweep_state == SWEEP_TIMEOUT)\n\t\t\tLOG(D_ALL, \"Test timeout (%lus). Stopping...\\n\",\n\t\t\t    (ulong_t)rto_opts.rto_sweep_timeout);\n\n\t\tLOG(D_ALL, \"Sweep test succeeded on %lu raidz maps!\\n\",\n\t\t    (ulong_t)tried_comb);\n\t}\n\n\tmutex_destroy(&sem_mtx);\n\n\treturn (sweep_state == SWEEP_ERROR ? SWEEP_ERROR : 0);\n}\n\n\nint\nmain(int argc, char **argv)\n{\n\tsize_t i;\n\tstruct sigaction action;\n\tint err = 0;\n\n\t \n\t(void) sprintf(pid_s, \"%d\", getpid());\n\n\taction.sa_handler = sig_handler;\n\tsigemptyset(&action.sa_mask);\n\taction.sa_flags = 0;\n\n\tif (sigaction(SIGSEGV, &action, NULL) < 0) {\n\t\tERR(\"raidz_test: cannot catch SIGSEGV: %s.\\n\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t(void) setvbuf(stdout, NULL, _IOLBF, 0);\n\n\tdprintf_setup(&argc, argv);\n\n\tprocess_options(argc, argv);\n\n\tkernel_init(SPA_MODE_READ);\n\n\t \n\trand_data = (int *)umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\tsrand((unsigned)time(NULL) * getpid());\n\tfor (i = 0; i < SPA_MAXBLOCKSIZE / sizeof (int); i++)\n\t\trand_data[i] = rand();\n\n\tmprotect(rand_data, SPA_MAXBLOCKSIZE, PROT_READ);\n\n\tif (rto_opts.rto_benchmark) {\n\t\trun_raidz_benchmark();\n\t} else if (rto_opts.rto_sweep) {\n\t\terr = run_sweep();\n\t} else {\n\t\terr = run_test(NULL);\n\t}\n\n\tumem_free(rand_data, SPA_MAXBLOCKSIZE);\n\tkernel_fini();\n\n\treturn (err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}