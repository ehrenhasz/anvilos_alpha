{
  "module_name": "zstream_dump.c",
  "hash_id": "c95caa6c466c713dca7046ca4acc0ab01687e517fecaf60f0fbd34090d36d3b7",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zstream/zstream_dump.c",
  "human_readable_source": " \n\n \n\n \n\n#include <ctype.h>\n#include <libnvpair.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stddef.h>\n\n#include <sys/dmu.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zio.h>\n#include <zfs_fletcher.h>\n#include \"zstream.h\"\n\n \n#define\tBYTES_PER_LINE\t16\n \n#define\tDUMP_GROUPING\t4\n\nstatic uint64_t total_stream_len = 0;\nstatic FILE *send_stream = 0;\nstatic boolean_t do_byteswap = B_FALSE;\nstatic boolean_t do_cksum = B_TRUE;\n\nvoid *\nsafe_malloc(size_t size)\n{\n\tvoid *rv = malloc(size);\n\tif (rv == NULL) {\n\t\t(void) fprintf(stderr, \"ERROR; failed to allocate %zu bytes\\n\",\n\t\t    size);\n\t\tabort();\n\t}\n\treturn (rv);\n}\n\n \nstatic size_t\nssread(void *buf, size_t len, zio_cksum_t *cksum)\n{\n\tsize_t outlen;\n\n\tif ((outlen = fread(buf, len, 1, send_stream)) == 0)\n\t\treturn (0);\n\n\tif (do_cksum) {\n\t\tif (do_byteswap)\n\t\t\tfletcher_4_incremental_byteswap(buf, len, cksum);\n\t\telse\n\t\t\tfletcher_4_incremental_native(buf, len, cksum);\n\t}\n\ttotal_stream_len += len;\n\treturn (outlen);\n}\n\nstatic size_t\nread_hdr(dmu_replay_record_t *drr, zio_cksum_t *cksum)\n{\n\tASSERT3U(offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum),\n\t    ==, sizeof (dmu_replay_record_t) - sizeof (zio_cksum_t));\n\tsize_t r = ssread(drr, sizeof (*drr) - sizeof (zio_cksum_t), cksum);\n\tif (r == 0)\n\t\treturn (0);\n\tzio_cksum_t saved_cksum = *cksum;\n\tr = ssread(&drr->drr_u.drr_checksum.drr_checksum,\n\t    sizeof (zio_cksum_t), cksum);\n\tif (r == 0)\n\t\treturn (0);\n\tif (do_cksum &&\n\t    !ZIO_CHECKSUM_IS_ZERO(&drr->drr_u.drr_checksum.drr_checksum) &&\n\t    !ZIO_CHECKSUM_EQUAL(saved_cksum,\n\t    drr->drr_u.drr_checksum.drr_checksum)) {\n\t\tfprintf(stderr, \"invalid checksum\\n\");\n\t\t(void) printf(\"Incorrect checksum in record header.\\n\");\n\t\t(void) printf(\"Expected checksum = %llx/%llx/%llx/%llx\\n\",\n\t\t    (longlong_t)saved_cksum.zc_word[0],\n\t\t    (longlong_t)saved_cksum.zc_word[1],\n\t\t    (longlong_t)saved_cksum.zc_word[2],\n\t\t    (longlong_t)saved_cksum.zc_word[3]);\n\t\treturn (0);\n\t}\n\treturn (sizeof (*drr));\n}\n\n \nstatic void\nprint_ascii_block(char *subbuf, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < length; i++) {\n\t\tchar char_print = isprint(subbuf[i]) ? subbuf[i] : '.';\n\t\tif (i != 0 && i % DUMP_GROUPING == 0) {\n\t\t\t(void) printf(\" \");\n\t\t}\n\t\t(void) printf(\"%c\", char_print);\n\t}\n\t(void) printf(\"\\n\");\n}\n\n \nstatic void\nprint_block(char *buf, int length)\n{\n\tint i;\n\t \n\tint ascii_start = BYTES_PER_LINE * 3 +\n\t    BYTES_PER_LINE / DUMP_GROUPING + 2;\n\n\tfor (i = 0; i < length; i += BYTES_PER_LINE) {\n\t\tint j;\n\t\tint this_line_length = MIN(BYTES_PER_LINE, length - i);\n\t\tint print_offset = 0;\n\n\t\tfor (j = 0; j < this_line_length; j++) {\n\t\t\tint buf_offset = i + j;\n\n\t\t\t \n\t\t\tif (buf_offset % DUMP_GROUPING == 0) {\n\t\t\t\tprint_offset += printf(\" \");\n\t\t\t}\n\n\t\t\t \n\t\t\tunsigned char hex_print = buf[buf_offset];\n\t\t\tprint_offset += printf(\"%02x \", hex_print);\n\t\t}\n\n\t\t(void) printf(\"%*s\", ascii_start - print_offset, \" \");\n\n\t\tprint_ascii_block(buf + i, this_line_length);\n\t}\n}\n\n \nstatic void\nsprintf_bytes(char *str, uint8_t *buf, uint_t buf_len)\n{\n\tint i, n;\n\n\tfor (i = 0; i < buf_len; i++) {\n\t\tn = sprintf(str, \"%02x\", buf[i] & 0xff);\n\t\tstr += n;\n\t}\n\n\tstr[0] = '\\0';\n}\n\nint\nzstream_do_dump(int argc, char *argv[])\n{\n\tchar *buf = safe_malloc(SPA_MAXBLOCKSIZE);\n\tuint64_t drr_record_count[DRR_NUMTYPES] = { 0 };\n\tuint64_t total_payload_size = 0;\n\tuint64_t total_overhead_size = 0;\n\tuint64_t drr_byte_count[DRR_NUMTYPES] = { 0 };\n\tchar salt[ZIO_DATA_SALT_LEN * 2 + 1];\n\tchar iv[ZIO_DATA_IV_LEN * 2 + 1];\n\tchar mac[ZIO_DATA_MAC_LEN * 2 + 1];\n\tuint64_t total_records = 0;\n\tuint64_t payload_size;\n\tdmu_replay_record_t thedrr;\n\tdmu_replay_record_t *drr = &thedrr;\n\tstruct drr_begin *drrb = &thedrr.drr_u.drr_begin;\n\tstruct drr_end *drre = &thedrr.drr_u.drr_end;\n\tstruct drr_object *drro = &thedrr.drr_u.drr_object;\n\tstruct drr_freeobjects *drrfo = &thedrr.drr_u.drr_freeobjects;\n\tstruct drr_write *drrw = &thedrr.drr_u.drr_write;\n\tstruct drr_write_byref *drrwbr = &thedrr.drr_u.drr_write_byref;\n\tstruct drr_free *drrf = &thedrr.drr_u.drr_free;\n\tstruct drr_spill *drrs = &thedrr.drr_u.drr_spill;\n\tstruct drr_write_embedded *drrwe = &thedrr.drr_u.drr_write_embedded;\n\tstruct drr_object_range *drror = &thedrr.drr_u.drr_object_range;\n\tstruct drr_redact *drrr = &thedrr.drr_u.drr_redact;\n\tstruct drr_checksum *drrc = &thedrr.drr_u.drr_checksum;\n\tint c;\n\tboolean_t verbose = B_FALSE;\n\tboolean_t very_verbose = B_FALSE;\n\tboolean_t first = B_TRUE;\n\t \n\tboolean_t dump = B_FALSE;\n\tint err;\n\tzio_cksum_t zc = { { 0 } };\n\tzio_cksum_t pcksum = { { 0 } };\n\n\twhile ((c = getopt(argc, argv, \":vCd\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tdo_cksum = B_FALSE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (verbose)\n\t\t\t\tvery_verbose = B_TRUE;\n\t\t\tverbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdump = B_TRUE;\n\t\t\tverbose = B_TRUE;\n\t\t\tvery_verbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"missing argument for '%c' option\\n\", optopt);\n\t\t\tzstream_usage();\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, \"invalid option '%c'\\n\",\n\t\t\t    optopt);\n\t\t\tzstream_usage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (argc > optind) {\n\t\tconst char *filename = argv[optind];\n\t\tsend_stream = fopen(filename, \"r\");\n\t\tif (send_stream == NULL) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Error while opening file '%s': %s\\n\",\n\t\t\t    filename, strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tif (isatty(STDIN_FILENO)) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"Error: The send stream is a binary format \"\n\t\t\t    \"and can not be read from a\\n\"\n\t\t\t    \"terminal.  Standard input must be redirected, \"\n\t\t\t    \"or a file must be\\n\"\n\t\t\t    \"specified as a command-line argument.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tsend_stream = stdin;\n\t}\n\n\tfletcher_4_init();\n\twhile (read_hdr(drr, &zc)) {\n\t\tuint64_t featureflags = 0;\n\n\t\t \n\t\tif (first) {\n\t\t\tif (drrb->drr_magic == BSWAP_64(DMU_BACKUP_MAGIC)) {\n\t\t\t\tdo_byteswap = B_TRUE;\n\t\t\t\tif (do_cksum) {\n\t\t\t\t\tZIO_SET_CHECKSUM(&zc, 0, 0, 0, 0);\n\t\t\t\t\t \n\t\t\t\t\tfletcher_4_incremental_byteswap(drr,\n\t\t\t\t\t    sizeof (dmu_replay_record_t), &zc);\n\t\t\t\t}\n\t\t\t} else if (drrb->drr_magic != DMU_BACKUP_MAGIC) {\n\t\t\t\t(void) fprintf(stderr, \"Invalid stream \"\n\t\t\t\t    \"(bad magic number)\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfirst = B_FALSE;\n\t\t}\n\t\tif (do_byteswap) {\n\t\t\tdrr->drr_type = BSWAP_32(drr->drr_type);\n\t\t\tdrr->drr_payloadlen =\n\t\t\t    BSWAP_32(drr->drr_payloadlen);\n\t\t}\n\n\t\t \n\t\tif (drr->drr_type >= DRR_NUMTYPES) {\n\t\t\t(void) printf(\"INVALID record found: type 0x%x\\n\",\n\t\t\t    drr->drr_type);\n\t\t\t(void) printf(\"Aborting.\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tdrr_record_count[drr->drr_type]++;\n\t\ttotal_overhead_size += sizeof (*drr);\n\t\ttotal_records++;\n\t\tpayload_size = 0;\n\n\t\tswitch (drr->drr_type) {\n\t\tcase DRR_BEGIN:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrb->drr_magic = BSWAP_64(drrb->drr_magic);\n\t\t\t\tdrrb->drr_versioninfo =\n\t\t\t\t    BSWAP_64(drrb->drr_versioninfo);\n\t\t\t\tdrrb->drr_creation_time =\n\t\t\t\t    BSWAP_64(drrb->drr_creation_time);\n\t\t\t\tdrrb->drr_type = BSWAP_32(drrb->drr_type);\n\t\t\t\tdrrb->drr_flags = BSWAP_32(drrb->drr_flags);\n\t\t\t\tdrrb->drr_toguid = BSWAP_64(drrb->drr_toguid);\n\t\t\t\tdrrb->drr_fromguid =\n\t\t\t\t    BSWAP_64(drrb->drr_fromguid);\n\t\t\t}\n\n\t\t\t(void) printf(\"BEGIN record\\n\");\n\t\t\t(void) printf(\"\\thdrtype = %lld\\n\",\n\t\t\t    DMU_GET_STREAM_HDRTYPE(drrb->drr_versioninfo));\n\t\t\t(void) printf(\"\\tfeatures = %llx\\n\",\n\t\t\t    DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo));\n\t\t\t(void) printf(\"\\tmagic = %llx\\n\",\n\t\t\t    (u_longlong_t)drrb->drr_magic);\n\t\t\t(void) printf(\"\\tcreation_time = %llx\\n\",\n\t\t\t    (u_longlong_t)drrb->drr_creation_time);\n\t\t\t(void) printf(\"\\ttype = %u\\n\", drrb->drr_type);\n\t\t\t(void) printf(\"\\tflags = 0x%x\\n\", drrb->drr_flags);\n\t\t\t(void) printf(\"\\ttoguid = %llx\\n\",\n\t\t\t    (u_longlong_t)drrb->drr_toguid);\n\t\t\t(void) printf(\"\\tfromguid = %llx\\n\",\n\t\t\t    (u_longlong_t)drrb->drr_fromguid);\n\t\t\t(void) printf(\"\\ttoname = %s\\n\", drrb->drr_toname);\n\t\t\t(void) printf(\"\\tpayloadlen = %u\\n\",\n\t\t\t    drr->drr_payloadlen);\n\t\t\tif (verbose)\n\t\t\t\t(void) printf(\"\\n\");\n\n\t\t\tif (drr->drr_payloadlen != 0) {\n\t\t\t\tnvlist_t *nv;\n\t\t\t\tint sz = drr->drr_payloadlen;\n\n\t\t\t\tif (sz > SPA_MAXBLOCKSIZE) {\n\t\t\t\t\tfree(buf);\n\t\t\t\t\tbuf = safe_malloc(sz);\n\t\t\t\t}\n\t\t\t\t(void) ssread(buf, sz, &zc);\n\t\t\t\tif (ferror(send_stream))\n\t\t\t\t\tperror(\"fread\");\n\t\t\t\terr = nvlist_unpack(buf, sz, &nv, 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tperror(strerror(err));\n\t\t\t\t} else {\n\t\t\t\t\tnvlist_print(stdout, nv);\n\t\t\t\t\tnvlist_free(nv);\n\t\t\t\t}\n\t\t\t\tpayload_size = sz;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DRR_END:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrre->drr_checksum.zc_word[0] =\n\t\t\t\t    BSWAP_64(drre->drr_checksum.zc_word[0]);\n\t\t\t\tdrre->drr_checksum.zc_word[1] =\n\t\t\t\t    BSWAP_64(drre->drr_checksum.zc_word[1]);\n\t\t\t\tdrre->drr_checksum.zc_word[2] =\n\t\t\t\t    BSWAP_64(drre->drr_checksum.zc_word[2]);\n\t\t\t\tdrre->drr_checksum.zc_word[3] =\n\t\t\t\t    BSWAP_64(drre->drr_checksum.zc_word[3]);\n\t\t\t}\n\t\t\t \n\t\t\tif (do_cksum && !ZIO_CHECKSUM_EQUAL(drre->drr_checksum,\n\t\t\t    pcksum)) {\n\t\t\t\t(void) printf(\"Expected checksum differs from \"\n\t\t\t\t    \"checksum in stream.\\n\");\n\t\t\t\t(void) printf(\"Expected checksum = \"\n\t\t\t\t    \"%llx/%llx/%llx/%llx\\n\",\n\t\t\t\t    (long long unsigned int)pcksum.zc_word[0],\n\t\t\t\t    (long long unsigned int)pcksum.zc_word[1],\n\t\t\t\t    (long long unsigned int)pcksum.zc_word[2],\n\t\t\t\t    (long long unsigned int)pcksum.zc_word[3]);\n\t\t\t}\n\t\t\t(void) printf(\"END checksum = %llx/%llx/%llx/%llx\\n\",\n\t\t\t    (long long unsigned int)\n\t\t\t    drre->drr_checksum.zc_word[0],\n\t\t\t    (long long unsigned int)\n\t\t\t    drre->drr_checksum.zc_word[1],\n\t\t\t    (long long unsigned int)\n\t\t\t    drre->drr_checksum.zc_word[2],\n\t\t\t    (long long unsigned int)\n\t\t\t    drre->drr_checksum.zc_word[3]);\n\n\t\t\tZIO_SET_CHECKSUM(&zc, 0, 0, 0, 0);\n\t\t\tbreak;\n\n\t\tcase DRR_OBJECT:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrro->drr_object = BSWAP_64(drro->drr_object);\n\t\t\t\tdrro->drr_type = BSWAP_32(drro->drr_type);\n\t\t\t\tdrro->drr_bonustype =\n\t\t\t\t    BSWAP_32(drro->drr_bonustype);\n\t\t\t\tdrro->drr_blksz = BSWAP_32(drro->drr_blksz);\n\t\t\t\tdrro->drr_bonuslen =\n\t\t\t\t    BSWAP_32(drro->drr_bonuslen);\n\t\t\t\tdrro->drr_raw_bonuslen =\n\t\t\t\t    BSWAP_32(drro->drr_raw_bonuslen);\n\t\t\t\tdrro->drr_toguid = BSWAP_64(drro->drr_toguid);\n\t\t\t\tdrro->drr_maxblkid =\n\t\t\t\t    BSWAP_64(drro->drr_maxblkid);\n\t\t\t}\n\n\t\t\tfeatureflags =\n\t\t\t    DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo);\n\n\t\t\tif (featureflags & DMU_BACKUP_FEATURE_RAW &&\n\t\t\t    drro->drr_bonuslen > drro->drr_raw_bonuslen) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"Warning: Object %llu has bonuslen = \"\n\t\t\t\t    \"%u > raw_bonuslen = %u\\n\\n\",\n\t\t\t\t    (u_longlong_t)drro->drr_object,\n\t\t\t\t    drro->drr_bonuslen, drro->drr_raw_bonuslen);\n\t\t\t}\n\n\t\t\tpayload_size = DRR_OBJECT_PAYLOAD_SIZE(drro);\n\n\t\t\tif (verbose) {\n\t\t\t\t(void) printf(\"OBJECT object = %llu type = %u \"\n\t\t\t\t    \"bonustype = %u blksz = %u bonuslen = %u \"\n\t\t\t\t    \"dn_slots = %u raw_bonuslen = %u \"\n\t\t\t\t    \"flags = %u maxblkid = %llu \"\n\t\t\t\t    \"indblkshift = %u nlevels = %u \"\n\t\t\t\t    \"nblkptr = %u\\n\",\n\t\t\t\t    (u_longlong_t)drro->drr_object,\n\t\t\t\t    drro->drr_type,\n\t\t\t\t    drro->drr_bonustype,\n\t\t\t\t    drro->drr_blksz,\n\t\t\t\t    drro->drr_bonuslen,\n\t\t\t\t    drro->drr_dn_slots,\n\t\t\t\t    drro->drr_raw_bonuslen,\n\t\t\t\t    drro->drr_flags,\n\t\t\t\t    (u_longlong_t)drro->drr_maxblkid,\n\t\t\t\t    drro->drr_indblkshift,\n\t\t\t\t    drro->drr_nlevels,\n\t\t\t\t    drro->drr_nblkptr);\n\t\t\t}\n\t\t\tif (drro->drr_bonuslen > 0) {\n\t\t\t\t(void) ssread(buf, payload_size, &zc);\n\t\t\t\tif (dump)\n\t\t\t\t\tprint_block(buf, payload_size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DRR_FREEOBJECTS:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrfo->drr_firstobj =\n\t\t\t\t    BSWAP_64(drrfo->drr_firstobj);\n\t\t\t\tdrrfo->drr_numobjs =\n\t\t\t\t    BSWAP_64(drrfo->drr_numobjs);\n\t\t\t\tdrrfo->drr_toguid = BSWAP_64(drrfo->drr_toguid);\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\t(void) printf(\"FREEOBJECTS firstobj = %llu \"\n\t\t\t\t    \"numobjs = %llu\\n\",\n\t\t\t\t    (u_longlong_t)drrfo->drr_firstobj,\n\t\t\t\t    (u_longlong_t)drrfo->drr_numobjs);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DRR_WRITE:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrw->drr_object = BSWAP_64(drrw->drr_object);\n\t\t\t\tdrrw->drr_type = BSWAP_32(drrw->drr_type);\n\t\t\t\tdrrw->drr_offset = BSWAP_64(drrw->drr_offset);\n\t\t\t\tdrrw->drr_logical_size =\n\t\t\t\t    BSWAP_64(drrw->drr_logical_size);\n\t\t\t\tdrrw->drr_toguid = BSWAP_64(drrw->drr_toguid);\n\t\t\t\tdrrw->drr_key.ddk_prop =\n\t\t\t\t    BSWAP_64(drrw->drr_key.ddk_prop);\n\t\t\t\tdrrw->drr_compressed_size =\n\t\t\t\t    BSWAP_64(drrw->drr_compressed_size);\n\t\t\t}\n\n\t\t\tpayload_size = DRR_WRITE_PAYLOAD_SIZE(drrw);\n\n\t\t\t \n\t\t\tif (verbose) {\n\t\t\t\tsprintf_bytes(salt, drrw->drr_salt,\n\t\t\t\t    ZIO_DATA_SALT_LEN);\n\t\t\t\tsprintf_bytes(iv, drrw->drr_iv,\n\t\t\t\t    ZIO_DATA_IV_LEN);\n\t\t\t\tsprintf_bytes(mac, drrw->drr_mac,\n\t\t\t\t    ZIO_DATA_MAC_LEN);\n\n\t\t\t\t(void) printf(\"WRITE object = %llu type = %u \"\n\t\t\t\t    \"checksum type = %u compression type = %u \"\n\t\t\t\t    \"flags = %u offset = %llu \"\n\t\t\t\t    \"logical_size = %llu \"\n\t\t\t\t    \"compressed_size = %llu \"\n\t\t\t\t    \"payload_size = %llu props = %llx \"\n\t\t\t\t    \"salt = %s iv = %s mac = %s\\n\",\n\t\t\t\t    (u_longlong_t)drrw->drr_object,\n\t\t\t\t    drrw->drr_type,\n\t\t\t\t    drrw->drr_checksumtype,\n\t\t\t\t    drrw->drr_compressiontype,\n\t\t\t\t    drrw->drr_flags,\n\t\t\t\t    (u_longlong_t)drrw->drr_offset,\n\t\t\t\t    (u_longlong_t)drrw->drr_logical_size,\n\t\t\t\t    (u_longlong_t)drrw->drr_compressed_size,\n\t\t\t\t    (u_longlong_t)payload_size,\n\t\t\t\t    (u_longlong_t)drrw->drr_key.ddk_prop,\n\t\t\t\t    salt,\n\t\t\t\t    iv,\n\t\t\t\t    mac);\n\t\t\t}\n\n\t\t\t \n\t\t\t(void) ssread(buf, payload_size, &zc);\n\t\t\t \n\t\t\tif (dump) {\n\t\t\t\tprint_block(buf, payload_size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DRR_WRITE_BYREF:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrwbr->drr_object =\n\t\t\t\t    BSWAP_64(drrwbr->drr_object);\n\t\t\t\tdrrwbr->drr_offset =\n\t\t\t\t    BSWAP_64(drrwbr->drr_offset);\n\t\t\t\tdrrwbr->drr_length =\n\t\t\t\t    BSWAP_64(drrwbr->drr_length);\n\t\t\t\tdrrwbr->drr_toguid =\n\t\t\t\t    BSWAP_64(drrwbr->drr_toguid);\n\t\t\t\tdrrwbr->drr_refguid =\n\t\t\t\t    BSWAP_64(drrwbr->drr_refguid);\n\t\t\t\tdrrwbr->drr_refobject =\n\t\t\t\t    BSWAP_64(drrwbr->drr_refobject);\n\t\t\t\tdrrwbr->drr_refoffset =\n\t\t\t\t    BSWAP_64(drrwbr->drr_refoffset);\n\t\t\t\tdrrwbr->drr_key.ddk_prop =\n\t\t\t\t    BSWAP_64(drrwbr->drr_key.ddk_prop);\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\t(void) printf(\"WRITE_BYREF object = %llu \"\n\t\t\t\t    \"checksum type = %u props = %llx \"\n\t\t\t\t    \"offset = %llu length = %llu \"\n\t\t\t\t    \"toguid = %llx refguid = %llx \"\n\t\t\t\t    \"refobject = %llu refoffset = %llu\\n\",\n\t\t\t\t    (u_longlong_t)drrwbr->drr_object,\n\t\t\t\t    drrwbr->drr_checksumtype,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_key.ddk_prop,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_offset,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_length,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_toguid,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_refguid,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_refobject,\n\t\t\t\t    (u_longlong_t)drrwbr->drr_refoffset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DRR_FREE:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrf->drr_object = BSWAP_64(drrf->drr_object);\n\t\t\t\tdrrf->drr_offset = BSWAP_64(drrf->drr_offset);\n\t\t\t\tdrrf->drr_length = BSWAP_64(drrf->drr_length);\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\t(void) printf(\"FREE object = %llu \"\n\t\t\t\t    \"offset = %llu length = %lld\\n\",\n\t\t\t\t    (u_longlong_t)drrf->drr_object,\n\t\t\t\t    (u_longlong_t)drrf->drr_offset,\n\t\t\t\t    (longlong_t)drrf->drr_length);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRR_SPILL:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrs->drr_object = BSWAP_64(drrs->drr_object);\n\t\t\t\tdrrs->drr_length = BSWAP_64(drrs->drr_length);\n\t\t\t\tdrrs->drr_compressed_size =\n\t\t\t\t    BSWAP_64(drrs->drr_compressed_size);\n\t\t\t\tdrrs->drr_type = BSWAP_32(drrs->drr_type);\n\t\t\t}\n\n\t\t\tpayload_size = DRR_SPILL_PAYLOAD_SIZE(drrs);\n\n\t\t\tif (verbose) {\n\t\t\t\tsprintf_bytes(salt, drrs->drr_salt,\n\t\t\t\t    ZIO_DATA_SALT_LEN);\n\t\t\t\tsprintf_bytes(iv, drrs->drr_iv,\n\t\t\t\t    ZIO_DATA_IV_LEN);\n\t\t\t\tsprintf_bytes(mac, drrs->drr_mac,\n\t\t\t\t    ZIO_DATA_MAC_LEN);\n\n\t\t\t\t(void) printf(\"SPILL block for object = %llu \"\n\t\t\t\t    \"length = %llu flags = %u \"\n\t\t\t\t    \"compression type = %u \"\n\t\t\t\t    \"compressed_size = %llu \"\n\t\t\t\t    \"payload_size = %llu \"\n\t\t\t\t    \"salt = %s iv = %s mac = %s\\n\",\n\t\t\t\t    (u_longlong_t)drrs->drr_object,\n\t\t\t\t    (u_longlong_t)drrs->drr_length,\n\t\t\t\t    drrs->drr_flags,\n\t\t\t\t    drrs->drr_compressiontype,\n\t\t\t\t    (u_longlong_t)drrs->drr_compressed_size,\n\t\t\t\t    (u_longlong_t)payload_size,\n\t\t\t\t    salt,\n\t\t\t\t    iv,\n\t\t\t\t    mac);\n\t\t\t}\n\t\t\t(void) ssread(buf, payload_size, &zc);\n\t\t\tif (dump) {\n\t\t\t\tprint_block(buf, payload_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRR_WRITE_EMBEDDED:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrwe->drr_object =\n\t\t\t\t    BSWAP_64(drrwe->drr_object);\n\t\t\t\tdrrwe->drr_offset =\n\t\t\t\t    BSWAP_64(drrwe->drr_offset);\n\t\t\t\tdrrwe->drr_length =\n\t\t\t\t    BSWAP_64(drrwe->drr_length);\n\t\t\t\tdrrwe->drr_toguid =\n\t\t\t\t    BSWAP_64(drrwe->drr_toguid);\n\t\t\t\tdrrwe->drr_lsize =\n\t\t\t\t    BSWAP_32(drrwe->drr_lsize);\n\t\t\t\tdrrwe->drr_psize =\n\t\t\t\t    BSWAP_32(drrwe->drr_psize);\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\t(void) printf(\"WRITE_EMBEDDED object = %llu \"\n\t\t\t\t    \"offset = %llu length = %llu \"\n\t\t\t\t    \"toguid = %llx comp = %u etype = %u \"\n\t\t\t\t    \"lsize = %u psize = %u\\n\",\n\t\t\t\t    (u_longlong_t)drrwe->drr_object,\n\t\t\t\t    (u_longlong_t)drrwe->drr_offset,\n\t\t\t\t    (u_longlong_t)drrwe->drr_length,\n\t\t\t\t    (u_longlong_t)drrwe->drr_toguid,\n\t\t\t\t    drrwe->drr_compression,\n\t\t\t\t    drrwe->drr_etype,\n\t\t\t\t    drrwe->drr_lsize,\n\t\t\t\t    drrwe->drr_psize);\n\t\t\t}\n\t\t\t(void) ssread(buf,\n\t\t\t    P2ROUNDUP(drrwe->drr_psize, 8), &zc);\n\t\t\tif (dump) {\n\t\t\t\tprint_block(buf,\n\t\t\t\t    P2ROUNDUP(drrwe->drr_psize, 8));\n\t\t\t}\n\t\t\tpayload_size = P2ROUNDUP(drrwe->drr_psize, 8);\n\t\t\tbreak;\n\t\tcase DRR_OBJECT_RANGE:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrror->drr_firstobj =\n\t\t\t\t    BSWAP_64(drror->drr_firstobj);\n\t\t\t\tdrror->drr_numslots =\n\t\t\t\t    BSWAP_64(drror->drr_numslots);\n\t\t\t\tdrror->drr_toguid = BSWAP_64(drror->drr_toguid);\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\tsprintf_bytes(salt, drror->drr_salt,\n\t\t\t\t    ZIO_DATA_SALT_LEN);\n\t\t\t\tsprintf_bytes(iv, drror->drr_iv,\n\t\t\t\t    ZIO_DATA_IV_LEN);\n\t\t\t\tsprintf_bytes(mac, drror->drr_mac,\n\t\t\t\t    ZIO_DATA_MAC_LEN);\n\n\t\t\t\t(void) printf(\"OBJECT_RANGE firstobj = %llu \"\n\t\t\t\t    \"numslots = %llu flags = %u \"\n\t\t\t\t    \"salt = %s iv = %s mac = %s\\n\",\n\t\t\t\t    (u_longlong_t)drror->drr_firstobj,\n\t\t\t\t    (u_longlong_t)drror->drr_numslots,\n\t\t\t\t    drror->drr_flags,\n\t\t\t\t    salt,\n\t\t\t\t    iv,\n\t\t\t\t    mac);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRR_REDACT:\n\t\t\tif (do_byteswap) {\n\t\t\t\tdrrr->drr_object = BSWAP_64(drrr->drr_object);\n\t\t\t\tdrrr->drr_offset = BSWAP_64(drrr->drr_offset);\n\t\t\t\tdrrr->drr_length = BSWAP_64(drrr->drr_length);\n\t\t\t\tdrrr->drr_toguid = BSWAP_64(drrr->drr_toguid);\n\t\t\t}\n\t\t\tif (verbose) {\n\t\t\t\t(void) printf(\"REDACT object = %llu offset = \"\n\t\t\t\t    \"%llu length = %llu\\n\",\n\t\t\t\t    (u_longlong_t)drrr->drr_object,\n\t\t\t\t    (u_longlong_t)drrr->drr_offset,\n\t\t\t\t    (u_longlong_t)drrr->drr_length);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRR_NUMTYPES:\n\t\t\t \n\t\t\texit(1);\n\t\t}\n\t\tif (drr->drr_type != DRR_BEGIN && very_verbose) {\n\t\t\t(void) printf(\"    checksum = %llx/%llx/%llx/%llx\\n\",\n\t\t\t    (longlong_t)drrc->drr_checksum.zc_word[0],\n\t\t\t    (longlong_t)drrc->drr_checksum.zc_word[1],\n\t\t\t    (longlong_t)drrc->drr_checksum.zc_word[2],\n\t\t\t    (longlong_t)drrc->drr_checksum.zc_word[3]);\n\t\t}\n\t\tpcksum = zc;\n\t\tdrr_byte_count[drr->drr_type] += payload_size;\n\t\ttotal_payload_size += payload_size;\n\t}\n\tfree(buf);\n\tfletcher_4_fini();\n\n\t \n\n\t(void) printf(\"SUMMARY:\\n\");\n\t(void) printf(\"\\tTotal DRR_BEGIN records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_BEGIN],\n\t    (u_longlong_t)drr_byte_count[DRR_BEGIN]);\n\t(void) printf(\"\\tTotal DRR_END records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_END],\n\t    (u_longlong_t)drr_byte_count[DRR_END]);\n\t(void) printf(\"\\tTotal DRR_OBJECT records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_OBJECT],\n\t    (u_longlong_t)drr_byte_count[DRR_OBJECT]);\n\t(void) printf(\"\\tTotal DRR_FREEOBJECTS records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_FREEOBJECTS],\n\t    (u_longlong_t)drr_byte_count[DRR_FREEOBJECTS]);\n\t(void) printf(\"\\tTotal DRR_WRITE records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_WRITE],\n\t    (u_longlong_t)drr_byte_count[DRR_WRITE]);\n\t(void) printf(\"\\tTotal DRR_WRITE_BYREF records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_WRITE_BYREF],\n\t    (u_longlong_t)drr_byte_count[DRR_WRITE_BYREF]);\n\t(void) printf(\"\\tTotal DRR_WRITE_EMBEDDED records = %lld (%llu \"\n\t    \"bytes)\\n\", (u_longlong_t)drr_record_count[DRR_WRITE_EMBEDDED],\n\t    (u_longlong_t)drr_byte_count[DRR_WRITE_EMBEDDED]);\n\t(void) printf(\"\\tTotal DRR_FREE records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_FREE],\n\t    (u_longlong_t)drr_byte_count[DRR_FREE]);\n\t(void) printf(\"\\tTotal DRR_SPILL records = %lld (%llu bytes)\\n\",\n\t    (u_longlong_t)drr_record_count[DRR_SPILL],\n\t    (u_longlong_t)drr_byte_count[DRR_SPILL]);\n\t(void) printf(\"\\tTotal records = %lld\\n\",\n\t    (u_longlong_t)total_records);\n\t(void) printf(\"\\tTotal payload size = %lld (0x%llx)\\n\",\n\t    (u_longlong_t)total_payload_size, (u_longlong_t)total_payload_size);\n\t(void) printf(\"\\tTotal header overhead = %lld (0x%llx)\\n\",\n\t    (u_longlong_t)total_overhead_size,\n\t    (u_longlong_t)total_overhead_size);\n\t(void) printf(\"\\tTotal stream length = %lld (0x%llx)\\n\",\n\t    (u_longlong_t)total_stream_len, (u_longlong_t)total_stream_len);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}