{
  "module_name": "zstream_recompress.c",
  "hash_id": "787a8f7eea4087c371f1277f551ff6ab34d39c4a2ad8c80c3f4336d74933de44",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zstream/zstream_recompress.c",
  "human_readable_source": " \n\n \n\n \n\n#include <err.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zio_checksum.h>\n#include <sys/zstd/zstd.h>\n#include \"zfs_fletcher.h\"\n#include \"zstream.h\"\n\nstatic int\ndump_record(dmu_replay_record_t *drr, void *payload, int payload_len,\n    zio_cksum_t *zc, int outfd)\n{\n\tassert(offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum)\n\t    == sizeof (dmu_replay_record_t) - sizeof (zio_cksum_t));\n\tfletcher_4_incremental_native(drr,\n\t    offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum), zc);\n\tif (drr->drr_type != DRR_BEGIN) {\n\t\tassert(ZIO_CHECKSUM_IS_ZERO(&drr->drr_u.\n\t\t    drr_checksum.drr_checksum));\n\t\tdrr->drr_u.drr_checksum.drr_checksum = *zc;\n\t}\n\tfletcher_4_incremental_native(&drr->drr_u.drr_checksum.drr_checksum,\n\t    sizeof (zio_cksum_t), zc);\n\tif (write(outfd, drr, sizeof (*drr)) == -1)\n\t\treturn (errno);\n\tif (payload_len != 0) {\n\t\tfletcher_4_incremental_native(payload, payload_len, zc);\n\t\tif (write(outfd, payload, payload_len) == -1)\n\t\t\treturn (errno);\n\t}\n\treturn (0);\n}\n\nint\nzstream_do_recompress(int argc, char *argv[])\n{\n\tint bufsz = SPA_MAXBLOCKSIZE;\n\tchar *buf = safe_malloc(bufsz);\n\tdmu_replay_record_t thedrr;\n\tdmu_replay_record_t *drr = &thedrr;\n\tzio_cksum_t stream_cksum;\n\tint c;\n\tint level = -1;\n\n\twhile ((c = getopt(argc, argv, \"l:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tif (sscanf(optarg, \"%d\", &level) != 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"failed to parse level '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\tzstream_usage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, \"invalid option '%c'\\n\",\n\t\t\t    optopt);\n\t\t\tzstream_usage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc != 1)\n\t\tzstream_usage();\n\tint type = 0;\n\tzio_compress_info_t *cinfo = NULL;\n\tif (0 == strcmp(argv[0], \"off\")) {\n\t\ttype = ZIO_COMPRESS_OFF;\n\t\tcinfo = &zio_compress_table[type];\n\t} else if (0 == strcmp(argv[0], \"inherit\") ||\n\t    0 == strcmp(argv[0], \"empty\") ||\n\t    0 == strcmp(argv[0], \"on\")) {\n\t\t\n\t} else {\n\t\tfor (int i = 0; i < ZIO_COMPRESS_FUNCTIONS; i++) {\n\t\t\tif (0 == strcmp(zio_compress_table[i].ci_name,\n\t\t\t    argv[0])) {\n\t\t\t\tcinfo = &zio_compress_table[i];\n\t\t\t\ttype = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (cinfo == NULL) {\n\t\tfprintf(stderr, \"Invalid compression type %s.\\n\",\n\t\t    argv[0]);\n\t\texit(2);\n\t}\n\n\tif (cinfo->ci_compress == NULL) {\n\t\ttype = 0;\n\t\tcinfo = &zio_compress_table[0];\n\t}\n\n\tif (isatty(STDIN_FILENO)) {\n\t\t(void) fprintf(stderr,\n\t\t    \"Error: The send stream is a binary format \"\n\t\t    \"and can not be read from a\\n\"\n\t\t    \"terminal.  Standard input must be redirected.\\n\");\n\t\texit(1);\n\t}\n\n\tfletcher_4_init();\n\tzio_init();\n\tzstd_init();\n\tint begin = 0;\n\tboolean_t seen = B_FALSE;\n\twhile (sfread(drr, sizeof (*drr), stdin) != 0) {\n\t\tstruct drr_write *drrw;\n\t\tuint64_t payload_size = 0;\n\n\t\t \n\t\tif (drr->drr_type != DRR_BEGIN) {\n\t\t\tmemset(&drr->drr_u.drr_checksum.drr_checksum, 0,\n\t\t\t    sizeof (drr->drr_u.drr_checksum.drr_checksum));\n\t\t}\n\n\n\t\tswitch (drr->drr_type) {\n\t\tcase DRR_BEGIN:\n\t\t{\n\t\t\tZIO_SET_CHECKSUM(&stream_cksum, 0, 0, 0, 0);\n\t\t\tVERIFY0(begin++);\n\t\t\tseen = B_TRUE;\n\n\t\t\tuint32_t sz = drr->drr_payloadlen;\n\n\t\t\tVERIFY3U(sz, <=, 1U << 28);\n\n\t\t\tif (sz != 0) {\n\t\t\t\tif (sz > bufsz) {\n\t\t\t\t\tbuf = realloc(buf, sz);\n\t\t\t\t\tif (buf == NULL)\n\t\t\t\t\t\terr(1, \"realloc\");\n\t\t\t\t\tbufsz = sz;\n\t\t\t\t}\n\t\t\t\t(void) sfread(buf, sz, stdin);\n\t\t\t}\n\t\t\tpayload_size = sz;\n\t\t\tbreak;\n\t\t}\n\t\tcase DRR_END:\n\t\t{\n\t\t\tstruct drr_end *drre = &drr->drr_u.drr_end;\n\t\t\t \n\t\t\tVERIFY3B(seen, ==, B_TRUE);\n\t\t\tbegin--;\n\t\t\t \n\t\t\tif (!ZIO_CHECKSUM_IS_ZERO(&drre->drr_checksum))\n\t\t\t\tdrre->drr_checksum = stream_cksum;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_OBJECT:\n\t\t{\n\t\t\tstruct drr_object *drro = &drr->drr_u.drr_object;\n\t\t\tVERIFY3S(begin, ==, 1);\n\n\t\t\tif (drro->drr_bonuslen > 0) {\n\t\t\t\tpayload_size = DRR_OBJECT_PAYLOAD_SIZE(drro);\n\t\t\t\t(void) sfread(buf, payload_size, stdin);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_SPILL:\n\t\t{\n\t\t\tstruct drr_spill *drrs = &drr->drr_u.drr_spill;\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tpayload_size = DRR_SPILL_PAYLOAD_SIZE(drrs);\n\t\t\t(void) sfread(buf, payload_size, stdin);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE_BYREF:\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tfprintf(stderr,\n\t\t\t    \"Deduplicated streams are not supported\\n\");\n\t\t\texit(1);\n\t\t\tbreak;\n\n\t\tcase DRR_WRITE:\n\t\t{\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tdrrw = &thedrr.drr_u.drr_write;\n\t\t\tpayload_size = DRR_WRITE_PAYLOAD_SIZE(drrw);\n\t\t\t \n\t\t\tboolean_t encrypted = B_FALSE;\n\t\t\tfor (int i = 0; i < ZIO_DATA_SALT_LEN; i++) {\n\t\t\t\tif (drrw->drr_salt[i] != 0) {\n\t\t\t\t\tencrypted = B_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (encrypted) {\n\t\t\t\t(void) sfread(buf, payload_size, stdin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (drrw->drr_compressiontype >=\n\t\t\t    ZIO_COMPRESS_FUNCTIONS) {\n\t\t\t\tfprintf(stderr, \"Invalid compression type in \"\n\t\t\t\t    \"stream: %d\\n\", drrw->drr_compressiontype);\n\t\t\t\texit(3);\n\t\t\t}\n\t\t\tzio_compress_info_t *dinfo =\n\t\t\t    &zio_compress_table[drrw->drr_compressiontype];\n\n\t\t\t \n\t\t\tchar *cbuf, *dbuf;\n\t\t\tif (cinfo->ci_compress == NULL)\n\t\t\t\tdbuf = buf;\n\t\t\telse\n\t\t\t\tdbuf = safe_calloc(bufsz);\n\n\t\t\tif (dinfo->ci_decompress == NULL)\n\t\t\t\tcbuf = dbuf;\n\t\t\telse\n\t\t\t\tcbuf = safe_calloc(payload_size);\n\n\t\t\t \n\t\t\t(void) sfread(cbuf, payload_size, stdin);\n\t\t\tif (dinfo->ci_decompress != NULL) {\n\t\t\t\tif (0 != dinfo->ci_decompress(cbuf, dbuf,\n\t\t\t\t    payload_size, MIN(bufsz,\n\t\t\t\t    drrw->drr_logical_size), dinfo->ci_level)) {\n\t\t\t\t\twarnx(\"decompression type %d failed \"\n\t\t\t\t\t    \"for ino %llu offset %llu\",\n\t\t\t\t\t    type,\n\t\t\t\t\t    (u_longlong_t)drrw->drr_object,\n\t\t\t\t\t    (u_longlong_t)drrw->drr_offset);\n\t\t\t\t\texit(4);\n\t\t\t\t}\n\t\t\t\tpayload_size = drrw->drr_logical_size;\n\t\t\t\tfree(cbuf);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (cinfo->ci_compress != NULL) {\n\t\t\t\tpayload_size = P2ROUNDUP(cinfo->ci_compress(\n\t\t\t\t    dbuf, buf, drrw->drr_logical_size,\n\t\t\t\t    MIN(payload_size, bufsz), (level == -1 ?\n\t\t\t\t    cinfo->ci_level : level)),\n\t\t\t\t    SPA_MINBLOCKSIZE);\n\t\t\t\tif (payload_size != drrw->drr_logical_size) {\n\t\t\t\t\tdrrw->drr_compressiontype = type;\n\t\t\t\t\tdrrw->drr_compressed_size =\n\t\t\t\t\t    payload_size;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(buf, dbuf, payload_size);\n\t\t\t\t\tdrrw->drr_compressiontype = 0;\n\t\t\t\t\tdrrw->drr_compressed_size = 0;\n\t\t\t\t}\n\t\t\t\tfree(dbuf);\n\t\t\t} else {\n\t\t\t\tdrrw->drr_compressiontype = type;\n\t\t\t\tdrrw->drr_compressed_size = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE_EMBEDDED:\n\t\t{\n\t\t\tstruct drr_write_embedded *drrwe =\n\t\t\t    &drr->drr_u.drr_write_embedded;\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tpayload_size =\n\t\t\t    P2ROUNDUP((uint64_t)drrwe->drr_psize, 8);\n\t\t\t(void) sfread(buf, payload_size, stdin);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_FREEOBJECTS:\n\t\tcase DRR_FREE:\n\t\tcase DRR_OBJECT_RANGE:\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, \"INVALID record type 0x%x\\n\",\n\t\t\t    drr->drr_type);\n\t\t\t \n\t\t\tassert(B_FALSE);\n\t\t}\n\n\t\tif (feof(stdout)) {\n\t\t\tfprintf(stderr, \"Error: unexpected end-of-file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (ferror(stdout)) {\n\t\t\tfprintf(stderr, \"Error while reading file: %s\\n\",\n\t\t\t    strerror(errno));\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (drr->drr_type != DRR_BEGIN) {\n\t\t\tmemset(&drr->drr_u.drr_checksum.drr_checksum, 0,\n\t\t\t    sizeof (drr->drr_u.drr_checksum.drr_checksum));\n\t\t}\n\t\tif (dump_record(drr, buf, payload_size,\n\t\t    &stream_cksum, STDOUT_FILENO) != 0)\n\t\t\tbreak;\n\t\tif (drr->drr_type == DRR_END) {\n\t\t\t \n\t\t\tZIO_SET_CHECKSUM(&stream_cksum, 0, 0, 0, 0);\n\t\t}\n\t}\n\tfree(buf);\n\tfletcher_4_fini();\n\tzio_fini();\n\tzstd_fini();\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}