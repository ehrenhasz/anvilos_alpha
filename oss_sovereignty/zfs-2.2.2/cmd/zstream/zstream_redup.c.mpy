{
  "module_name": "zstream_redup.c",
  "hash_id": "77d9fcde3f1ec0a5091d95c420fd5f5633283df228358ad29791d4bf85b0193d",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zstream/zstream_redup.c",
  "human_readable_source": " \n\n \n\n#include <assert.h>\n#include <cityhash.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libzfs.h>\n#include <libzutil.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <umem.h>\n#include <unistd.h>\n#include <sys/debug.h>\n#include <sys/stat.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zio_checksum.h>\n#include \"zfs_fletcher.h\"\n#include \"zstream.h\"\n\n\n#define\tMAX_RDT_PHYSMEM_PERCENT\t\t20\n#define\tSMALLEST_POSSIBLE_MAX_RDT_MB\t\t128\n\ntypedef struct redup_entry {\n\tstruct redup_entry\t*rde_next;\n\tuint64_t rde_guid;\n\tuint64_t rde_object;\n\tuint64_t rde_offset;\n\tuint64_t rde_stream_offset;\n} redup_entry_t;\n\ntypedef struct redup_table {\n\tredup_entry_t\t**redup_hash_array;\n\tumem_cache_t\t*ddecache;\n\tuint64_t\tddt_count;\n\tint\t\tnumhashbits;\n} redup_table_t;\n\nint\nhighbit64(uint64_t i)\n{\n\tif (i == 0)\n\t\treturn (0);\n\n\treturn (NBBY * sizeof (uint64_t) - __builtin_clzll(i));\n}\n\nvoid *\nsafe_calloc(size_t n)\n{\n\tvoid *rv = calloc(1, n);\n\tif (rv == NULL) {\n\t\tfprintf(stderr,\n\t\t    \"Error: could not allocate %u bytes of memory\\n\",\n\t\t    (int)n);\n\t\texit(1);\n\t}\n\treturn (rv);\n}\n\n \nint\nsfread(void *buf, size_t size, FILE *fp)\n{\n\tint rv = fread(buf, size, 1, fp);\n\tif (rv == 0 && ferror(fp)) {\n\t\t(void) fprintf(stderr, \"Error while reading file: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\treturn (rv);\n}\n\n \nstatic void\nspread(int fd, void *buf, size_t count, off_t offset)\n{\n\tssize_t err = pread(fd, buf, count, offset);\n\tif (err == -1) {\n\t\t(void) fprintf(stderr,\n\t\t    \"Error while reading file: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t} else if (err != count) {\n\t\t(void) fprintf(stderr,\n\t\t    \"Error while reading file: short read\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic int\ndump_record(dmu_replay_record_t *drr, void *payload, int payload_len,\n    zio_cksum_t *zc, int outfd)\n{\n\tassert(offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum)\n\t    == sizeof (dmu_replay_record_t) - sizeof (zio_cksum_t));\n\tfletcher_4_incremental_native(drr,\n\t    offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum), zc);\n\tif (drr->drr_type != DRR_BEGIN) {\n\t\tassert(ZIO_CHECKSUM_IS_ZERO(&drr->drr_u.\n\t\t    drr_checksum.drr_checksum));\n\t\tdrr->drr_u.drr_checksum.drr_checksum = *zc;\n\t}\n\tfletcher_4_incremental_native(&drr->drr_u.drr_checksum.drr_checksum,\n\t    sizeof (zio_cksum_t), zc);\n\tif (write(outfd, drr, sizeof (*drr)) == -1)\n\t\treturn (errno);\n\tif (payload_len != 0) {\n\t\tfletcher_4_incremental_native(payload, payload_len, zc);\n\t\tif (write(outfd, payload, payload_len) == -1)\n\t\t\treturn (errno);\n\t}\n\treturn (0);\n}\n\nstatic void\nrdt_insert(redup_table_t *rdt,\n    uint64_t guid, uint64_t object, uint64_t offset, uint64_t stream_offset)\n{\n\tuint64_t ch = cityhash4(guid, object, offset, 0);\n\tuint64_t hashcode = BF64_GET(ch, 0, rdt->numhashbits);\n\tredup_entry_t **rdepp;\n\n\trdepp = &(rdt->redup_hash_array[hashcode]);\n\tredup_entry_t *rde = umem_cache_alloc(rdt->ddecache, UMEM_NOFAIL);\n\trde->rde_next = *rdepp;\n\trde->rde_guid = guid;\n\trde->rde_object = object;\n\trde->rde_offset = offset;\n\trde->rde_stream_offset = stream_offset;\n\t*rdepp = rde;\n\trdt->ddt_count++;\n}\n\nstatic void\nrdt_lookup(redup_table_t *rdt,\n    uint64_t guid, uint64_t object, uint64_t offset,\n    uint64_t *stream_offsetp)\n{\n\tuint64_t ch = cityhash4(guid, object, offset, 0);\n\tuint64_t hashcode = BF64_GET(ch, 0, rdt->numhashbits);\n\n\tfor (redup_entry_t *rde = rdt->redup_hash_array[hashcode];\n\t    rde != NULL; rde = rde->rde_next) {\n\t\tif (rde->rde_guid == guid &&\n\t\t    rde->rde_object == object &&\n\t\t    rde->rde_offset == offset) {\n\t\t\t*stream_offsetp = rde->rde_stream_offset;\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(!\"could not find expected redup table entry\");\n}\n\n \nstatic void\nzfs_redup_stream(int infd, int outfd, boolean_t verbose)\n{\n\tint bufsz = SPA_MAXBLOCKSIZE;\n\tdmu_replay_record_t thedrr = { 0 };\n\tdmu_replay_record_t *drr = &thedrr;\n\tredup_table_t rdt;\n\tzio_cksum_t stream_cksum;\n\tuint64_t numbuckets;\n\tuint64_t num_records = 0;\n\tuint64_t num_write_byref_records = 0;\n\n#ifdef _ILP32\n\tuint64_t max_rde_size = SMALLEST_POSSIBLE_MAX_RDT_MB << 20;\n#else\n\tuint64_t physmem = sysconf(_SC_PHYS_PAGES) * sysconf(_SC_PAGESIZE);\n\tuint64_t max_rde_size =\n\t    MAX((physmem * MAX_RDT_PHYSMEM_PERCENT) / 100,\n\t    SMALLEST_POSSIBLE_MAX_RDT_MB << 20);\n#endif\n\n\tnumbuckets = max_rde_size / (sizeof (redup_entry_t));\n\n\t \n\tif (!ISP2(numbuckets))\n\t\tnumbuckets = 1ULL << highbit64(numbuckets);\n\n\trdt.redup_hash_array =\n\t    safe_calloc(numbuckets * sizeof (redup_entry_t *));\n\trdt.ddecache = umem_cache_create(\"rde\", sizeof (redup_entry_t), 0,\n\t    NULL, NULL, NULL, NULL, NULL, 0);\n\trdt.numhashbits = highbit64(numbuckets) - 1;\n\trdt.ddt_count = 0;\n\n\tchar *buf = safe_calloc(bufsz);\n\tFILE *ofp = fdopen(infd, \"r\");\n\tlong offset = ftell(ofp);\n\tint begin = 0;\n\tboolean_t seen = B_FALSE;\n\twhile (sfread(drr, sizeof (*drr), ofp) != 0) {\n\t\tnum_records++;\n\n\t\t \n\t\tif (drr->drr_type != DRR_BEGIN) {\n\t\t\tmemset(&drr->drr_u.drr_checksum.drr_checksum, 0,\n\t\t\t    sizeof (drr->drr_u.drr_checksum.drr_checksum));\n\t\t}\n\n\t\tuint64_t payload_size = 0;\n\t\tswitch (drr->drr_type) {\n\t\tcase DRR_BEGIN:\n\t\t{\n\t\t\tstruct drr_begin *drrb = &drr->drr_u.drr_begin;\n\t\t\tint fflags;\n\t\t\tZIO_SET_CHECKSUM(&stream_cksum, 0, 0, 0, 0);\n\t\t\tVERIFY0(begin++);\n\t\t\tseen = B_TRUE;\n\n\t\t\tassert(drrb->drr_magic == DMU_BACKUP_MAGIC);\n\n\t\t\t \n\t\t\tfflags = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo);\n\t\t\tfflags &= ~(DMU_BACKUP_FEATURE_DEDUP |\n\t\t\t    DMU_BACKUP_FEATURE_DEDUPPROPS);\n\t\t\t \n\t\t\tDMU_SET_FEATUREFLAGS(drrb->drr_versioninfo, fflags);\n\n\t\t\tuint32_t sz = drr->drr_payloadlen;\n\n\t\t\tVERIFY3U(sz, <=, 1U << 28);\n\n\t\t\tif (sz != 0) {\n\t\t\t\tif (sz > bufsz) {\n\t\t\t\t\tfree(buf);\n\t\t\t\t\tbuf = safe_calloc(sz);\n\t\t\t\t\tbufsz = sz;\n\t\t\t\t}\n\t\t\t\t(void) sfread(buf, sz, ofp);\n\t\t\t}\n\t\t\tpayload_size = sz;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_END:\n\t\t{\n\t\t\tstruct drr_end *drre = &drr->drr_u.drr_end;\n\t\t\t \n\t\t\tVERIFY3B(seen, ==, B_TRUE);\n\t\t\tbegin--;\n\t\t\t \n\t\t\tif (!ZIO_CHECKSUM_IS_ZERO(&drre->drr_checksum))\n\t\t\t\tdrre->drr_checksum = stream_cksum;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_OBJECT:\n\t\t{\n\t\t\tstruct drr_object *drro = &drr->drr_u.drr_object;\n\t\t\tVERIFY3S(begin, ==, 1);\n\n\t\t\tif (drro->drr_bonuslen > 0) {\n\t\t\t\tpayload_size = DRR_OBJECT_PAYLOAD_SIZE(drro);\n\t\t\t\t(void) sfread(buf, payload_size, ofp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_SPILL:\n\t\t{\n\t\t\tstruct drr_spill *drrs = &drr->drr_u.drr_spill;\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tpayload_size = DRR_SPILL_PAYLOAD_SIZE(drrs);\n\t\t\t(void) sfread(buf, payload_size, ofp);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE_BYREF:\n\t\t{\n\t\t\tstruct drr_write_byref drrwb =\n\t\t\t    drr->drr_u.drr_write_byref;\n\t\t\tVERIFY3S(begin, ==, 1);\n\n\t\t\tnum_write_byref_records++;\n\n\t\t\t \n\t\t\tuint64_t stream_offset = 0;\n\t\t\trdt_lookup(&rdt, drrwb.drr_refguid,\n\t\t\t    drrwb.drr_refobject, drrwb.drr_refoffset,\n\t\t\t    &stream_offset);\n\n\t\t\tspread(infd, drr, sizeof (*drr), stream_offset);\n\n\t\t\tassert(drr->drr_type == DRR_WRITE);\n\t\t\tstruct drr_write *drrw = &drr->drr_u.drr_write;\n\t\t\tassert(drrw->drr_toguid == drrwb.drr_refguid);\n\t\t\tassert(drrw->drr_object == drrwb.drr_refobject);\n\t\t\tassert(drrw->drr_offset == drrwb.drr_refoffset);\n\n\t\t\tpayload_size = DRR_WRITE_PAYLOAD_SIZE(drrw);\n\t\t\tspread(infd, buf, payload_size,\n\t\t\t    stream_offset + sizeof (*drr));\n\n\t\t\tdrrw->drr_toguid = drrwb.drr_toguid;\n\t\t\tdrrw->drr_object = drrwb.drr_object;\n\t\t\tdrrw->drr_offset = drrwb.drr_offset;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE:\n\t\t{\n\t\t\tstruct drr_write *drrw = &drr->drr_u.drr_write;\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tpayload_size = DRR_WRITE_PAYLOAD_SIZE(drrw);\n\t\t\t(void) sfread(buf, payload_size, ofp);\n\n\t\t\trdt_insert(&rdt, drrw->drr_toguid,\n\t\t\t    drrw->drr_object, drrw->drr_offset, offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_WRITE_EMBEDDED:\n\t\t{\n\t\t\tstruct drr_write_embedded *drrwe =\n\t\t\t    &drr->drr_u.drr_write_embedded;\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tpayload_size =\n\t\t\t    P2ROUNDUP((uint64_t)drrwe->drr_psize, 8);\n\t\t\t(void) sfread(buf, payload_size, ofp);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DRR_FREEOBJECTS:\n\t\tcase DRR_FREE:\n\t\tcase DRR_OBJECT_RANGE:\n\t\t\tVERIFY3S(begin, ==, 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, \"INVALID record type 0x%x\\n\",\n\t\t\t    drr->drr_type);\n\t\t\t \n\t\t\tassert(B_FALSE);\n\t\t}\n\n\t\tif (feof(ofp)) {\n\t\t\tfprintf(stderr, \"Error: unexpected end-of-file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (ferror(ofp)) {\n\t\t\tfprintf(stderr, \"Error while reading file: %s\\n\",\n\t\t\t    strerror(errno));\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (drr->drr_type != DRR_BEGIN) {\n\t\t\tmemset(&drr->drr_u.drr_checksum.drr_checksum, 0,\n\t\t\t    sizeof (drr->drr_u.drr_checksum.drr_checksum));\n\t\t}\n\t\tif (dump_record(drr, buf, payload_size,\n\t\t    &stream_cksum, outfd) != 0)\n\t\t\tbreak;\n\t\tif (drr->drr_type == DRR_END) {\n\t\t\t \n\t\t\tZIO_SET_CHECKSUM(&stream_cksum, 0, 0, 0, 0);\n\t\t}\n\t\toffset = ftell(ofp);\n\t}\n\n\tif (verbose) {\n\t\tchar mem_str[16];\n\t\tzfs_nicenum(rdt.ddt_count * sizeof (redup_entry_t),\n\t\t    mem_str, sizeof (mem_str));\n\t\tfprintf(stderr, \"converted stream with %llu total records, \"\n\t\t    \"including %llu dedup records, using %sB memory.\\n\",\n\t\t    (long long)num_records,\n\t\t    (long long)num_write_byref_records,\n\t\t    mem_str);\n\t}\n\n\tumem_cache_destroy(rdt.ddecache);\n\tfree(rdt.redup_hash_array);\n\tfree(buf);\n\t(void) fclose(ofp);\n}\n\nint\nzstream_do_redup(int argc, char *argv[])\n{\n\tboolean_t verbose = B_FALSE;\n\tint c;\n\n\twhile ((c = getopt(argc, argv, \"v\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tverbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, \"invalid option '%c'\\n\",\n\t\t\t    optopt);\n\t\t\tzstream_usage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc != 1)\n\t\tzstream_usage();\n\n\tconst char *filename = argv[0];\n\n\tif (isatty(STDOUT_FILENO)) {\n\t\t(void) fprintf(stderr,\n\t\t    \"Error: Stream can not be written to a terminal.\\n\"\n\t\t    \"You must redirect standard output.\\n\");\n\t\treturn (1);\n\t}\n\n\tint fd = open(filename, O_RDONLY);\n\tif (fd == -1) {\n\t\t(void) fprintf(stderr,\n\t\t    \"Error while opening file '%s': %s\\n\",\n\t\t    filename, strerror(errno));\n\t\texit(1);\n\t}\n\n\tfletcher_4_init();\n\tzfs_redup_stream(fd, STDOUT_FILENO, verbose);\n\tfletcher_4_fini();\n\n\tclose(fd);\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}