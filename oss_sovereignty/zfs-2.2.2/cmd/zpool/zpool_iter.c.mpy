{
  "module_name": "zpool_iter.c",
  "hash_id": "6d7a3e33ec9b9ec594709517e9ed384aad03331801585821a5bb644478fbf88c",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool/zpool_iter.c",
  "human_readable_source": " \n \n\n \n\n#include <libintl.h>\n#include <libuutil.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <thread_pool.h>\n\n#include <libzfs.h>\n#include <libzutil.h>\n#include <sys/zfs_context.h>\n#include <sys/wait.h>\n\n#include \"zpool_util.h\"\n\n \n\ntypedef struct zpool_node {\n\tzpool_handle_t\t*zn_handle;\n\tuu_avl_node_t\tzn_avlnode;\n\tint\t\tzn_mark;\n} zpool_node_t;\n\nstruct zpool_list {\n\tboolean_t\tzl_findall;\n\tboolean_t\tzl_literal;\n\tuu_avl_t\t*zl_avl;\n\tuu_avl_pool_t\t*zl_pool;\n\tzprop_list_t\t**zl_proplist;\n\tzfs_type_t\tzl_type;\n};\n\nstatic int\nzpool_compare(const void *larg, const void *rarg, void *unused)\n{\n\t(void) unused;\n\tzpool_handle_t *l = ((zpool_node_t *)larg)->zn_handle;\n\tzpool_handle_t *r = ((zpool_node_t *)rarg)->zn_handle;\n\tconst char *lname = zpool_get_name(l);\n\tconst char *rname = zpool_get_name(r);\n\n\treturn (strcmp(lname, rname));\n}\n\n \nstatic int\nadd_pool(zpool_handle_t *zhp, void *data)\n{\n\tzpool_list_t *zlp = data;\n\tzpool_node_t *node = safe_malloc(sizeof (zpool_node_t));\n\tuu_avl_index_t idx;\n\n\tnode->zn_handle = zhp;\n\tuu_avl_node_init(node, &node->zn_avlnode, zlp->zl_pool);\n\tif (uu_avl_find(zlp->zl_avl, node, NULL, &idx) == NULL) {\n\t\tif (zlp->zl_proplist &&\n\t\t    zpool_expand_proplist(zhp, zlp->zl_proplist,\n\t\t    zlp->zl_type, zlp->zl_literal) != 0) {\n\t\t\tzpool_close(zhp);\n\t\t\tfree(node);\n\t\t\treturn (-1);\n\t\t}\n\t\tuu_avl_insert(zlp->zl_avl, node, idx);\n\t} else {\n\t\tzpool_close(zhp);\n\t\tfree(node);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n \nzpool_list_t *\npool_list_get(int argc, char **argv, zprop_list_t **proplist, zfs_type_t type,\n    boolean_t literal, int *err)\n{\n\tzpool_list_t *zlp;\n\n\tzlp = safe_malloc(sizeof (zpool_list_t));\n\n\tzlp->zl_pool = uu_avl_pool_create(\"zfs_pool\", sizeof (zpool_node_t),\n\t    offsetof(zpool_node_t, zn_avlnode), zpool_compare, UU_DEFAULT);\n\n\tif (zlp->zl_pool == NULL)\n\t\tzpool_no_memory();\n\n\tif ((zlp->zl_avl = uu_avl_create(zlp->zl_pool, NULL,\n\t    UU_DEFAULT)) == NULL)\n\t\tzpool_no_memory();\n\n\tzlp->zl_proplist = proplist;\n\tzlp->zl_type = type;\n\n\tzlp->zl_literal = literal;\n\n\tif (argc == 0) {\n\t\t(void) zpool_iter(g_zfs, add_pool, zlp);\n\t\tzlp->zl_findall = B_TRUE;\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tzpool_handle_t *zhp;\n\n\t\t\tif ((zhp = zpool_open_canfail(g_zfs, argv[i])) !=\n\t\t\t    NULL) {\n\t\t\t\tif (add_pool(zhp, zlp) != 0)\n\t\t\t\t\t*err = B_TRUE;\n\t\t\t} else {\n\t\t\t\t*err = B_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (zlp);\n}\n\n \nvoid\npool_list_update(zpool_list_t *zlp)\n{\n\tif (zlp->zl_findall)\n\t\t(void) zpool_iter(g_zfs, add_pool, zlp);\n}\n\n \nint\npool_list_iter(zpool_list_t *zlp, int unavail, zpool_iter_f func,\n    void *data)\n{\n\tzpool_node_t *node, *next_node;\n\tint ret = 0;\n\n\tfor (node = uu_avl_first(zlp->zl_avl); node != NULL; node = next_node) {\n\t\tnext_node = uu_avl_next(zlp->zl_avl, node);\n\t\tif (zpool_get_state(node->zn_handle) != POOL_STATE_UNAVAIL ||\n\t\t    unavail)\n\t\t\tret |= func(node->zn_handle, data);\n\t}\n\n\treturn (ret);\n}\n\n \nvoid\npool_list_remove(zpool_list_t *zlp, zpool_handle_t *zhp)\n{\n\tzpool_node_t search, *node;\n\n\tsearch.zn_handle = zhp;\n\tif ((node = uu_avl_find(zlp->zl_avl, &search, NULL, NULL)) != NULL) {\n\t\tuu_avl_remove(zlp->zl_avl, node);\n\t\tzpool_close(node->zn_handle);\n\t\tfree(node);\n\t}\n}\n\n \nvoid\npool_list_free(zpool_list_t *zlp)\n{\n\tuu_avl_walk_t *walk;\n\tzpool_node_t *node;\n\n\tif ((walk = uu_avl_walk_start(zlp->zl_avl, UU_WALK_ROBUST)) == NULL) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"internal error: out of memory\"));\n\t\texit(1);\n\t}\n\n\twhile ((node = uu_avl_walk_next(walk)) != NULL) {\n\t\tuu_avl_remove(zlp->zl_avl, node);\n\t\tzpool_close(node->zn_handle);\n\t\tfree(node);\n\t}\n\n\tuu_avl_walk_end(walk);\n\tuu_avl_destroy(zlp->zl_avl);\n\tuu_avl_pool_destroy(zlp->zl_pool);\n\n\tfree(zlp);\n}\n\n \nint\npool_list_count(zpool_list_t *zlp)\n{\n\treturn (uu_avl_numnodes(zlp->zl_avl));\n}\n\n \nint\nfor_each_pool(int argc, char **argv, boolean_t unavail,\n    zprop_list_t **proplist, zfs_type_t type, boolean_t literal,\n    zpool_iter_f func, void *data)\n{\n\tzpool_list_t *list;\n\tint ret = 0;\n\n\tif ((list = pool_list_get(argc, argv, proplist, type, literal,\n\t    &ret)) == NULL)\n\t\treturn (1);\n\n\tif (pool_list_iter(list, unavail, func, data) != 0)\n\t\tret = 1;\n\n\tpool_list_free(list);\n\n\treturn (ret);\n}\n\n \nint\nfor_each_vdev(zpool_handle_t *zhp, pool_vdev_iter_f func, void *data)\n{\n\tnvlist_t *config, *nvroot = NULL;\n\n\tif ((config = zpool_get_config(zhp, NULL)) != NULL) {\n\t\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &nvroot) == 0);\n\t}\n\treturn (for_each_vdev_cb((void *) zhp, nvroot, func, data));\n}\n\n \nstatic void\nprocess_unique_cmd_columns(vdev_cmd_data_list_t *vcdl)\n{\n\tchar **uniq_cols = NULL, **tmp = NULL;\n\tint *uniq_cols_width;\n\tvdev_cmd_data_t *data;\n\tint cnt = 0;\n\tint k;\n\n\t \n\tfor (int i = 0; i < vcdl->count; i++) {\n\t\tdata = &vcdl->data[i];\n\t\t \n\t\tfor (int j = 0; j < data->cols_cnt; j++) {\n\t\t\t \n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\tif (strcmp(data->cols[j], uniq_cols[k]) == 0)\n\t\t\t\t\tbreak;  \n\t\t\t}\n\t\t\tif (k == cnt) {\n\t\t\t\t \n\t\t\t\ttmp = realloc(uniq_cols, sizeof (*uniq_cols) *\n\t\t\t\t    (cnt + 1));\n\t\t\t\tif (tmp == NULL)\n\t\t\t\t\tbreak;  \n\t\t\t\tuniq_cols = tmp;\n\t\t\t\tuniq_cols[cnt] = data->cols[j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tuniq_cols_width = safe_malloc(sizeof (*uniq_cols_width) * cnt);\n\tfor (int i = 0; i < cnt; i++) {\n\t\t \n\t\tuniq_cols_width[i] = strlen(uniq_cols[i]);\n\t\t \n\t\tfor (int j = 0; j < vcdl->count; j++) {\n\t\t\t \n\t\t\tdata = &vcdl->data[j];\n\t\t\tfor (k = 0; k < data->cols_cnt; k++) {\n\t\t\t\t \n\t\t\t\tif (strcmp(data->cols[k], uniq_cols[i]) == 0) {\n\t\t\t\t\t \n\t\t\t\t\tuniq_cols_width[i] =\n\t\t\t\t\t    MAX(uniq_cols_width[i],\n\t\t\t\t\t    strlen(data->lines[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvcdl->uniq_cols = uniq_cols;\n\tvcdl->uniq_cols_cnt = cnt;\n\tvcdl->uniq_cols_width = uniq_cols_width;\n}\n\n\n \nstatic int\nvdev_process_cmd_output(vdev_cmd_data_t *data, char *line)\n{\n\tchar *col = NULL;\n\tchar *val = line;\n\tchar *equals;\n\tchar **tmp;\n\n\tif (line == NULL)\n\t\treturn (1);\n\n\tequals = strchr(line, '=');\n\tif (equals != NULL) {\n\t\t \n\t\t*equals = '\\0';\n\t\tcol = line;\n\t\tval = equals + 1;\n\t} else {\n\t\tval = line;\n\t}\n\n\t \n\tif (col != NULL) {\n\t\tfor (int i = 0; i < data->cols_cnt; i++) {\n\t\t\tif (strcmp(col, data->cols[i]) == 0)\n\t\t\t\treturn (0);  \n\t\t}\n\t}\n\n\tif (val != NULL) {\n\t\ttmp = realloc(data->lines,\n\t\t    (data->lines_cnt + 1) * sizeof (*data->lines));\n\t\tif (tmp == NULL)\n\t\t\treturn (1);\n\n\t\tdata->lines = tmp;\n\t\tdata->lines[data->lines_cnt] = strdup(val);\n\t\tdata->lines_cnt++;\n\t}\n\n\tif (col != NULL) {\n\t\ttmp = realloc(data->cols,\n\t\t    (data->cols_cnt + 1) * sizeof (*data->cols));\n\t\tif (tmp == NULL)\n\t\t\treturn (1);\n\n\t\tdata->cols = tmp;\n\t\tdata->cols[data->cols_cnt] = strdup(col);\n\t\tdata->cols_cnt++;\n\t}\n\n\tif (val != NULL && col == NULL)\n\t\treturn (1);\n\n\treturn (0);\n}\n\n \nstatic void\nvdev_run_cmd(vdev_cmd_data_t *data, char *cmd)\n{\n\tint rc;\n\tchar *argv[2] = {cmd};\n\tchar **env;\n\tchar **lines = NULL;\n\tint lines_cnt = 0;\n\tint i;\n\n\tenv = zpool_vdev_script_alloc_env(data->pool, data->path, data->upath,\n\t    data->vdev_enc_sysfs_path, NULL, NULL);\n\tif (env == NULL)\n\t\tgoto out;\n\n\t \n\trc = libzfs_run_process_get_stdout_nopath(cmd, argv, env, &lines,\n\t    &lines_cnt);\n\n\tzpool_vdev_script_free_env(env);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < lines_cnt; i++)\n\t\tif (vdev_process_cmd_output(data, lines[i]) != 0)\n\t\t\tbreak;\n\nout:\n\tif (lines != NULL)\n\t\tlibzfs_free_str_array(lines, lines_cnt);\n}\n\n \nchar *\nzpool_get_cmd_search_path(void)\n{\n\tconst char *env;\n\tchar *sp = NULL;\n\n\tenv = getenv(\"ZPOOL_SCRIPTS_PATH\");\n\tif (env != NULL)\n\t\treturn (strdup(env));\n\n\tenv = getenv(\"HOME\");\n\tif (env != NULL) {\n\t\tif (asprintf(&sp, \"%s/.zpool.d:%s\",\n\t\t    env, ZPOOL_SCRIPTS_DIR) != -1) {\n\t\t\treturn (sp);\n\t\t}\n\t}\n\n\tif (asprintf(&sp, \"%s\", ZPOOL_SCRIPTS_DIR) != -1)\n\t\treturn (sp);\n\n\treturn (NULL);\n}\n\n \nstatic void\nvdev_run_cmd_thread(void *cb_cmd_data)\n{\n\tvdev_cmd_data_t *data = cb_cmd_data;\n\tchar *cmd = NULL, *cmddup, *cmdrest;\n\n\tcmddup = strdup(data->cmd);\n\tif (cmddup == NULL)\n\t\treturn;\n\n\tcmdrest = cmddup;\n\twhile ((cmd = strtok_r(cmdrest, \",\", &cmdrest))) {\n\t\tchar *dir = NULL, *sp, *sprest;\n\t\tchar fullpath[MAXPATHLEN];\n\n\t\tif (strchr(cmd, '/') != NULL)\n\t\t\tcontinue;\n\n\t\tsp = zpool_get_cmd_search_path();\n\t\tif (sp == NULL)\n\t\t\tcontinue;\n\n\t\tsprest = sp;\n\t\twhile ((dir = strtok_r(sprest, \":\", &sprest))) {\n\t\t\tif (snprintf(fullpath, sizeof (fullpath),\n\t\t\t    \"%s/%s\", dir, cmd) == -1)\n\t\t\t\tcontinue;\n\n\t\t\tif (access(fullpath, X_OK) == 0) {\n\t\t\t\tvdev_run_cmd(data, fullpath);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(sp);\n\t}\n\tfree(cmddup);\n}\n\n \nstatic int\nfor_each_vdev_run_cb(void *zhp_data, nvlist_t *nv, void *cb_vcdl)\n{\n\tvdev_cmd_data_list_t *vcdl = cb_vcdl;\n\tvdev_cmd_data_t *data;\n\tconst char *path = NULL;\n\tchar *vname = NULL;\n\tconst char *vdev_enc_sysfs_path = NULL;\n\tint i, match = 0;\n\tzpool_handle_t *zhp = zhp_data;\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) != 0)\n\t\treturn (1);\n\n\tnvlist_lookup_string(nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH,\n\t    &vdev_enc_sysfs_path);\n\n\t \n\tfor (i = 0; i < vcdl->count; i++) {\n\t\tif ((strcmp(vcdl->data[i].path, path) == 0) &&\n\t\t    (strcmp(vcdl->data[i].pool, zpool_get_name(zhp)) == 0)) {\n\t\t\t \n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < vcdl->vdev_names_count; i++) {\n\t\tvname = zpool_vdev_name(g_zfs, zhp, nv, vcdl->cb_name_flags);\n\t\tif (strcmp(vcdl->vdev_names[i], vname) == 0) {\n\t\t\tfree(vname);\n\t\t\tmatch = 1;\n\t\t\tbreak;  \n\t\t}\n\t\tfree(vname);\n\t}\n\n\t \n\tif (!match && vcdl->vdev_names_count)\n\t\treturn (0);\n\n\t \n\tif (!(vcdl->data = realloc(vcdl->data,\n\t    sizeof (*vcdl->data) * (vcdl->count + 1))))\n\t\treturn (ENOMEM);\t \n\n\tdata = &vcdl->data[vcdl->count];\n\n\tdata->pool = strdup(zpool_get_name(zhp));\n\tdata->path = strdup(path);\n\tdata->upath = zfs_get_underlying_path(path);\n\tdata->cmd = vcdl->cmd;\n\tdata->lines = data->cols = NULL;\n\tdata->lines_cnt = data->cols_cnt = 0;\n\tif (vdev_enc_sysfs_path)\n\t\tdata->vdev_enc_sysfs_path = strdup(vdev_enc_sysfs_path);\n\telse\n\t\tdata->vdev_enc_sysfs_path = NULL;\n\n\tvcdl->count++;\n\n\treturn (0);\n}\n\n \nstatic int\nall_pools_for_each_vdev_gather_cb(zpool_handle_t *zhp, void *cb_vcdl)\n{\n\treturn (for_each_vdev(zhp, for_each_vdev_run_cb, cb_vcdl));\n}\n\n \nstatic void\nall_pools_for_each_vdev_run_vcdl(vdev_cmd_data_list_t *vcdl)\n{\n\ttpool_t *t;\n\n\tt = tpool_create(1, 5 * sysconf(_SC_NPROCESSORS_ONLN), 0, NULL);\n\tif (t == NULL)\n\t\treturn;\n\n\t \n\tfor (int i = 0; i < vcdl->count; i++) {\n\t\t(void) tpool_dispatch(t, vdev_run_cmd_thread,\n\t\t    (void *) &vcdl->data[i]);\n\t}\n\n\t \n\ttpool_wait(t);\n\ttpool_destroy(t);\n}\n\n \nvdev_cmd_data_list_t *\nall_pools_for_each_vdev_run(int argc, char **argv, char *cmd,\n    libzfs_handle_t *g_zfs, char **vdev_names, int vdev_names_count,\n    int cb_name_flags)\n{\n\tvdev_cmd_data_list_t *vcdl;\n\tvcdl = safe_malloc(sizeof (vdev_cmd_data_list_t));\n\tvcdl->cmd = cmd;\n\n\tvcdl->vdev_names = vdev_names;\n\tvcdl->vdev_names_count = vdev_names_count;\n\tvcdl->cb_name_flags = cb_name_flags;\n\tvcdl->g_zfs = g_zfs;\n\n\t \n\tfor_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, all_pools_for_each_vdev_gather_cb, vcdl);\n\n\t \n\tall_pools_for_each_vdev_run_vcdl(vcdl);\n\n\t \n\tprocess_unique_cmd_columns(vcdl);\n\n\treturn (vcdl);\n}\n\n \nvoid\nfree_vdev_cmd_data_list(vdev_cmd_data_list_t *vcdl)\n{\n\tfree(vcdl->uniq_cols);\n\tfree(vcdl->uniq_cols_width);\n\n\tfor (int i = 0; i < vcdl->count; i++) {\n\t\tfree(vcdl->data[i].path);\n\t\tfree(vcdl->data[i].pool);\n\t\tfree(vcdl->data[i].upath);\n\n\t\tfor (int j = 0; j < vcdl->data[i].lines_cnt; j++)\n\t\t\tfree(vcdl->data[i].lines[j]);\n\n\t\tfree(vcdl->data[i].lines);\n\n\t\tfor (int j = 0; j < vcdl->data[i].cols_cnt; j++)\n\t\t\tfree(vcdl->data[i].cols[j]);\n\n\t\tfree(vcdl->data[i].cols);\n\t\tfree(vcdl->data[i].vdev_enc_sysfs_path);\n\t}\n\tfree(vcdl->data);\n\tfree(vcdl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}