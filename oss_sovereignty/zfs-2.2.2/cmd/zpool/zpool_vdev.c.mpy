{
  "module_name": "zpool_vdev.c",
  "hash_id": "30835ea34dddb3ebda6a79fccb654d1bbb3477b9a919872567474dbb6868f673",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool/zpool_vdev.c",
  "human_readable_source": " \n\n \n\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libintl.h>\n#include <libnvpair.h>\n#include <libzutil.h>\n#include <limits.h>\n#include <sys/spa.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include \"zpool_util.h\"\n#include <sys/zfs_context.h>\n#include <sys/stat.h>\n\n \nboolean_t error_seen;\nboolean_t is_force;\n\nvoid\nvdev_error(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (!error_seen) {\n\t\t(void) fprintf(stderr, gettext(\"invalid vdev specification\\n\"));\n\t\tif (!is_force)\n\t\t\t(void) fprintf(stderr, gettext(\"use '-f' to override \"\n\t\t\t    \"the following errors:\\n\"));\n\t\telse\n\t\t\t(void) fprintf(stderr, gettext(\"the following errors \"\n\t\t\t    \"must be manually repaired:\\n\"));\n\t\terror_seen = B_TRUE;\n\t}\n\n\tva_start(ap, fmt);\n\t(void) vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n}\n\n \nint\ncheck_file_generic(const char *file, boolean_t force, boolean_t isspare)\n{\n\tchar  *name;\n\tint fd;\n\tint ret = 0;\n\tpool_state_t state;\n\tboolean_t inuse;\n\n\tif ((fd = open(file, O_RDONLY)) < 0)\n\t\treturn (0);\n\n\tif (zpool_in_use(g_zfs, fd, &state, &name, &inuse) == 0 && inuse) {\n\t\tconst char *desc;\n\n\t\tswitch (state) {\n\t\tcase POOL_STATE_ACTIVE:\n\t\t\tdesc = gettext(\"active\");\n\t\t\tbreak;\n\n\t\tcase POOL_STATE_EXPORTED:\n\t\t\tdesc = gettext(\"exported\");\n\t\t\tbreak;\n\n\t\tcase POOL_STATE_POTENTIALLY_ACTIVE:\n\t\t\tdesc = gettext(\"potentially active\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdesc = gettext(\"unknown\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (state == POOL_STATE_SPARE && isspare) {\n\t\t\tfree(name);\n\t\t\t(void) close(fd);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif (state == POOL_STATE_ACTIVE ||\n\t\t    state == POOL_STATE_SPARE || !force) {\n\t\t\tswitch (state) {\n\t\t\tcase POOL_STATE_SPARE:\n\t\t\t\tvdev_error(gettext(\"%s is reserved as a hot \"\n\t\t\t\t    \"spare for pool %s\\n\"), file, name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvdev_error(gettext(\"%s is part of %s pool \"\n\t\t\t\t    \"'%s'\\n\"), file, desc, name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = -1;\n\t\t}\n\n\t\tfree(name);\n\t}\n\n\t(void) close(fd);\n\treturn (ret);\n}\n\n \nstatic int\nis_shorthand_path(const char *arg, char *path, size_t path_size,\n    struct stat64 *statbuf, boolean_t *wholedisk)\n{\n\tint error;\n\n\terror = zfs_resolve_shortname(arg, path, path_size);\n\tif (error == 0) {\n\t\t*wholedisk = zfs_dev_is_whole_disk(path);\n\t\tif (*wholedisk || (stat64(path, statbuf) == 0))\n\t\t\treturn (0);\n\t}\n\n\tstrlcpy(path, arg, path_size);\n\tmemset(statbuf, 0, sizeof (*statbuf));\n\t*wholedisk = B_FALSE;\n\n\treturn (error);\n}\n\n \nstatic boolean_t\nis_spare(nvlist_t *config, const char *path)\n{\n\tint fd;\n\tpool_state_t state;\n\tchar *name = NULL;\n\tnvlist_t *label;\n\tuint64_t guid, spareguid;\n\tnvlist_t *nvroot;\n\tnvlist_t **spares;\n\tuint_t i, nspares;\n\tboolean_t inuse;\n\n\tif (zpool_is_draid_spare(path))\n\t\treturn (B_TRUE);\n\n\tif ((fd = open(path, O_RDONLY|O_DIRECT)) < 0)\n\t\treturn (B_FALSE);\n\n\tif (zpool_in_use(g_zfs, fd, &state, &name, &inuse) != 0 ||\n\t    !inuse ||\n\t    state != POOL_STATE_SPARE ||\n\t    zpool_read_label(fd, &label, NULL) != 0) {\n\t\tfree(name);\n\t\t(void) close(fd);\n\t\treturn (B_FALSE);\n\t}\n\tfree(name);\n\t(void) close(fd);\n\n\tif (config == NULL) {\n\t\tnvlist_free(label);\n\t\treturn (B_TRUE);\n\t}\n\n\tverify(nvlist_lookup_uint64(label, ZPOOL_CONFIG_GUID, &guid) == 0);\n\tnvlist_free(label);\n\n\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t    &spares, &nspares) == 0) {\n\t\tfor (i = 0; i < nspares; i++) {\n\t\t\tverify(nvlist_lookup_uint64(spares[i],\n\t\t\t    ZPOOL_CONFIG_GUID, &spareguid) == 0);\n\t\t\tif (spareguid == guid)\n\t\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic nvlist_t *\nmake_leaf_vdev(nvlist_t *props, const char *arg, boolean_t is_primary)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat64 statbuf;\n\tnvlist_t *vdev = NULL;\n\tconst char *type = NULL;\n\tboolean_t wholedisk = B_FALSE;\n\tuint64_t ashift = 0;\n\tint err;\n\n\t \n\tif (arg[0] == '/') {\n\t\t \n\t\tif (realpath(arg, path) == NULL) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"cannot resolve path '%s'\\n\"), arg);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\twholedisk = zfs_dev_is_whole_disk(path);\n\t\tif (!wholedisk && (stat64(path, &statbuf) != 0)) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"cannot open '%s': %s\\n\"),\n\t\t\t    path, strerror(errno));\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t \n\t\tstrlcpy(path, arg, sizeof (path));\n\t} else if (zpool_is_draid_spare(arg)) {\n\t\tif (!is_primary) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"cannot open '%s': dRAID spares can only \"\n\t\t\t    \"be used to replace primary vdevs\\n\"), arg);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\twholedisk = B_TRUE;\n\t\tstrlcpy(path, arg, sizeof (path));\n\t\ttype = VDEV_TYPE_DRAID_SPARE;\n\t} else {\n\t\terr = is_shorthand_path(arg, path, sizeof (path),\n\t\t    &statbuf, &wholedisk);\n\t\tif (err != 0) {\n\t\t\t \n\t\t\tif (err == ENOENT) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"cannot open '%s': no such \"\n\t\t\t\t    \"device in %s\\n\"), arg, DISK_ROOT);\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"must be a full path or \"\n\t\t\t\t    \"shorthand device name\\n\"));\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"cannot open '%s': %s\\n\"),\n\t\t\t\t    path, strerror(errno));\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type == NULL) {\n\t\t \n\t\tif (wholedisk || S_ISBLK(statbuf.st_mode)) {\n\t\t\ttype = VDEV_TYPE_DISK;\n\t\t} else if (S_ISREG(statbuf.st_mode)) {\n\t\t\ttype = VDEV_TYPE_FILE;\n\t\t} else {\n\t\t\tfprintf(stderr, gettext(\"cannot use '%s': must \"\n\t\t\t    \"be a block device or regular file\\n\"), path);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t \n\tverify(nvlist_alloc(&vdev, NV_UNIQUE_NAME, 0) == 0);\n\tverify(nvlist_add_string(vdev, ZPOOL_CONFIG_PATH, path) == 0);\n\tverify(nvlist_add_string(vdev, ZPOOL_CONFIG_TYPE, type) == 0);\n\n\tif (strcmp(type, VDEV_TYPE_DISK) == 0)\n\t\tverify(nvlist_add_uint64(vdev, ZPOOL_CONFIG_WHOLE_DISK,\n\t\t    (uint64_t)wholedisk) == 0);\n\n\t \n\tif (props != NULL) {\n\t\tconst char *value = NULL;\n\n\t\tif (nvlist_lookup_string(props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_ASHIFT), &value) == 0) {\n\t\t\tif (zfs_nicestrtonum(NULL, value, &ashift) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"ashift must be a number.\\n\"));\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tif (ashift != 0 &&\n\t\t\t    (ashift < ASHIFT_MIN || ashift > ASHIFT_MAX)) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid 'ashift=%\" PRIu64 \"' \"\n\t\t\t\t    \"property: only values between %\" PRId32 \" \"\n\t\t\t\t    \"and %\" PRId32 \" are allowed.\\n\"),\n\t\t\t\t    ashift, ASHIFT_MIN, ASHIFT_MAX);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ashift == 0) {\n\t\tint sector_size;\n\n\t\tif (check_sector_size_database(path, &sector_size) == B_TRUE)\n\t\t\tashift = highbit64(sector_size) - 1;\n\t}\n\n\tif (ashift > 0)\n\t\t(void) nvlist_add_uint64(vdev, ZPOOL_CONFIG_ASHIFT, ashift);\n\n\treturn (vdev);\n}\n\n \ntypedef struct replication_level {\n\tconst char *zprl_type;\n\tuint64_t zprl_children;\n\tuint64_t zprl_parity;\n} replication_level_t;\n\n#define\tZPOOL_FUZZ\t(16 * 1024 * 1024)\n\n \nstatic boolean_t\nis_raidz_mirror(replication_level_t *a, replication_level_t *b,\n    replication_level_t **raidz, replication_level_t **mirror)\n{\n\tif ((strcmp(a->zprl_type, \"raidz\") == 0 ||\n\t    strcmp(a->zprl_type, \"draid\") == 0) &&\n\t    strcmp(b->zprl_type, \"mirror\") == 0) {\n\t\t*raidz = a;\n\t\t*mirror = b;\n\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic boolean_t\nis_raidz_draid(replication_level_t *a, replication_level_t *b)\n{\n\tif ((strcmp(a->zprl_type, \"raidz\") == 0 ||\n\t    strcmp(a->zprl_type, \"draid\") == 0) &&\n\t    (strcmp(b->zprl_type, \"raidz\") == 0 ||\n\t    strcmp(b->zprl_type, \"draid\") == 0)) {\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic replication_level_t *\nget_replication(nvlist_t *nvroot, boolean_t fatal)\n{\n\tnvlist_t **top;\n\tuint_t t, toplevels;\n\tnvlist_t **child;\n\tuint_t c, children;\n\tnvlist_t *nv;\n\tconst char *type;\n\treplication_level_t lastrep = {0};\n\treplication_level_t rep;\n\treplication_level_t *ret;\n\treplication_level_t *raidz, *mirror;\n\tboolean_t dontreport;\n\n\tret = safe_malloc(sizeof (replication_level_t));\n\n\tverify(nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &top, &toplevels) == 0);\n\n\tfor (t = 0; t < toplevels; t++) {\n\t\tuint64_t is_log = B_FALSE;\n\n\t\tnv = top[t];\n\n\t\t \n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_IS_LOG, &is_log);\n\t\tif (is_log)\n\t\t\tcontinue;\n\n\t\t \n\t\tverify(nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) == 0);\n\t\tif (strcmp(type, VDEV_TYPE_HOLE) == 0 ||\n\t\t    strcmp(type, VDEV_TYPE_INDIRECT) == 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t\t    &child, &children) != 0) {\n\t\t\t \n\t\t\trep.zprl_type = type;\n\t\t\trep.zprl_children = 1;\n\t\t\trep.zprl_parity = 0;\n\t\t} else {\n\t\t\tint64_t vdev_size;\n\n\t\t\t \n\t\t\trep.zprl_type = type;\n\t\t\trep.zprl_children = 0;\n\n\t\t\tif (strcmp(type, VDEV_TYPE_RAIDZ) == 0 ||\n\t\t\t    strcmp(type, VDEV_TYPE_DRAID) == 0) {\n\t\t\t\tverify(nvlist_lookup_uint64(nv,\n\t\t\t\t    ZPOOL_CONFIG_NPARITY,\n\t\t\t\t    &rep.zprl_parity) == 0);\n\t\t\t\tassert(rep.zprl_parity != 0);\n\t\t\t} else {\n\t\t\t\trep.zprl_parity = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\ttype = NULL;\n\t\t\tdontreport = 0;\n\t\t\tvdev_size = -1LL;\n\t\t\tfor (c = 0; c < children; c++) {\n\t\t\t\tnvlist_t *cnv = child[c];\n\t\t\t\tconst char *path;\n\t\t\t\tstruct stat64 statbuf;\n\t\t\t\tint64_t size = -1LL;\n\t\t\t\tconst char *childtype;\n\t\t\t\tint fd, err;\n\n\t\t\t\trep.zprl_children++;\n\n\t\t\t\tverify(nvlist_lookup_string(cnv,\n\t\t\t\t    ZPOOL_CONFIG_TYPE, &childtype) == 0);\n\n\t\t\t\t \n\t\t\t\twhile (strcmp(childtype,\n\t\t\t\t    VDEV_TYPE_REPLACING) == 0 ||\n\t\t\t\t    strcmp(childtype, VDEV_TYPE_SPARE) == 0) {\n\t\t\t\t\tnvlist_t **rchild;\n\t\t\t\t\tuint_t rchildren;\n\n\t\t\t\t\tverify(nvlist_lookup_nvlist_array(cnv,\n\t\t\t\t\t    ZPOOL_CONFIG_CHILDREN, &rchild,\n\t\t\t\t\t    &rchildren) == 0);\n\t\t\t\t\tassert(rchildren == 2);\n\t\t\t\t\tcnv = rchild[0];\n\n\t\t\t\t\tverify(nvlist_lookup_string(cnv,\n\t\t\t\t\t    ZPOOL_CONFIG_TYPE,\n\t\t\t\t\t    &childtype) == 0);\n\t\t\t\t}\n\n\t\t\t\tverify(nvlist_lookup_string(cnv,\n\t\t\t\t    ZPOOL_CONFIG_PATH, &path) == 0);\n\n\t\t\t\t \n\t\t\t\tif (!dontreport && type != NULL &&\n\t\t\t\t    strcmp(type, childtype) != 0) {\n\t\t\t\t\tif (ret != NULL)\n\t\t\t\t\t\tfree(ret);\n\t\t\t\t\tret = NULL;\n\t\t\t\t\tif (fatal)\n\t\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t\t    \"mismatched replication \"\n\t\t\t\t\t\t    \"level: %s contains both \"\n\t\t\t\t\t\t    \"files and devices\\n\"),\n\t\t\t\t\t\t    rep.zprl_type);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tdontreport = B_TRUE;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif ((fd = open(path, O_RDONLY)) >= 0) {\n\t\t\t\t\terr = fstat64_blk(fd, &statbuf);\n\t\t\t\t\t(void) close(fd);\n\t\t\t\t} else {\n\t\t\t\t\terr = stat64(path, &statbuf);\n\t\t\t\t}\n\n\t\t\t\tif (err != 0 ||\n\t\t\t\t    statbuf.st_size == 0 ||\n\t\t\t\t    statbuf.st_size == MAXOFFSET_T)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsize = statbuf.st_size;\n\n\t\t\t\t \n\t\t\t\tif (!dontreport &&\n\t\t\t\t    (vdev_size != -1LL &&\n\t\t\t\t    (llabs(size - vdev_size) >\n\t\t\t\t    ZPOOL_FUZZ))) {\n\t\t\t\t\tif (ret != NULL)\n\t\t\t\t\t\tfree(ret);\n\t\t\t\t\tret = NULL;\n\t\t\t\t\tif (fatal)\n\t\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t\t    \"%s contains devices of \"\n\t\t\t\t\t\t    \"different sizes\\n\"),\n\t\t\t\t\t\t    rep.zprl_type);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tdontreport = B_TRUE;\n\t\t\t\t}\n\n\t\t\t\ttype = childtype;\n\t\t\t\tvdev_size = size;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (lastrep.zprl_type != NULL) {\n\t\t\tif (is_raidz_mirror(&lastrep, &rep, &raidz, &mirror) ||\n\t\t\t    is_raidz_mirror(&rep, &lastrep, &raidz, &mirror)) {\n\t\t\t\t \n\t\t\t\tif (raidz->zprl_parity !=\n\t\t\t\t    mirror->zprl_children - 1) {\n\t\t\t\t\tif (ret != NULL)\n\t\t\t\t\t\tfree(ret);\n\t\t\t\t\tret = NULL;\n\t\t\t\t\tif (fatal)\n\t\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t\t    \"mismatched replication \"\n\t\t\t\t\t\t    \"level: \"\n\t\t\t\t\t\t    \"%s and %s vdevs with \"\n\t\t\t\t\t\t    \"different redundancy, \"\n\t\t\t\t\t\t    \"%llu vs. %llu (%llu-way) \"\n\t\t\t\t\t\t    \"are present\\n\"),\n\t\t\t\t\t\t    raidz->zprl_type,\n\t\t\t\t\t\t    mirror->zprl_type,\n\t\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t\t    raidz->zprl_parity,\n\t\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t\t    mirror->zprl_children - 1,\n\t\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t\t    mirror->zprl_children);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t} else if (is_raidz_draid(&lastrep, &rep)) {\n\t\t\t\t \n\t\t\t\tif (lastrep.zprl_parity != rep.zprl_parity) {\n\t\t\t\t\tif (ret != NULL)\n\t\t\t\t\t\tfree(ret);\n\t\t\t\t\tret = NULL;\n\t\t\t\t\tif (fatal)\n\t\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t\t    \"mismatched replication \"\n\t\t\t\t\t\t    \"level: %s and %s vdevs \"\n\t\t\t\t\t\t    \"with different \"\n\t\t\t\t\t\t    \"redundancy, %llu vs. \"\n\t\t\t\t\t\t    \"%llu are present\\n\"),\n\t\t\t\t\t\t    lastrep.zprl_type,\n\t\t\t\t\t\t    rep.zprl_type,\n\t\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t\t    lastrep.zprl_parity,\n\t\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t\t    rep.zprl_parity);\n\t\t\t\t\telse\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t} else if (strcmp(lastrep.zprl_type, rep.zprl_type) !=\n\t\t\t    0) {\n\t\t\t\tif (ret != NULL)\n\t\t\t\t\tfree(ret);\n\t\t\t\tret = NULL;\n\t\t\t\tif (fatal)\n\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t    \"mismatched replication level: \"\n\t\t\t\t\t    \"both %s and %s vdevs are \"\n\t\t\t\t\t    \"present\\n\"),\n\t\t\t\t\t    lastrep.zprl_type, rep.zprl_type);\n\t\t\t\telse\n\t\t\t\t\treturn (NULL);\n\t\t\t} else if (lastrep.zprl_parity != rep.zprl_parity) {\n\t\t\t\tif (ret)\n\t\t\t\t\tfree(ret);\n\t\t\t\tret = NULL;\n\t\t\t\tif (fatal)\n\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t    \"mismatched replication level: \"\n\t\t\t\t\t    \"both %llu and %llu device parity \"\n\t\t\t\t\t    \"%s vdevs are present\\n\"),\n\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t    lastrep.zprl_parity,\n\t\t\t\t\t    (u_longlong_t)rep.zprl_parity,\n\t\t\t\t\t    rep.zprl_type);\n\t\t\t\telse\n\t\t\t\t\treturn (NULL);\n\t\t\t} else if (lastrep.zprl_children != rep.zprl_children) {\n\t\t\t\tif (ret)\n\t\t\t\t\tfree(ret);\n\t\t\t\tret = NULL;\n\t\t\t\tif (fatal)\n\t\t\t\t\tvdev_error(gettext(\n\t\t\t\t\t    \"mismatched replication level: \"\n\t\t\t\t\t    \"both %llu-way and %llu-way %s \"\n\t\t\t\t\t    \"vdevs are present\\n\"),\n\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t    lastrep.zprl_children,\n\t\t\t\t\t    (u_longlong_t)\n\t\t\t\t\t    rep.zprl_children,\n\t\t\t\t\t    rep.zprl_type);\n\t\t\t\telse\n\t\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t\tlastrep = rep;\n\t}\n\n\tif (ret != NULL)\n\t\t*ret = rep;\n\n\treturn (ret);\n}\n\n \nstatic int\ncheck_replication(nvlist_t *config, nvlist_t *newroot)\n{\n\tnvlist_t **child;\n\tuint_t\tchildren;\n\treplication_level_t *current = NULL, *new;\n\treplication_level_t *raidz, *mirror;\n\tint ret;\n\n\t \n\tif (config != NULL) {\n\t\tnvlist_t *nvroot;\n\n\t\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &nvroot) == 0);\n\t\tif ((current = get_replication(nvroot, B_FALSE)) == NULL)\n\t\t\treturn (0);\n\t}\n\t \n\tif ((nvlist_lookup_nvlist_array(newroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) || (children == 0)) {\n\t\tfree(current);\n\t\treturn (0);\n\t}\n\n\t \n\tif (num_logs(newroot) == children) {\n\t\tfree(current);\n\t\treturn (0);\n\t}\n\n\t \n\tif ((new = get_replication(newroot, B_TRUE)) == NULL) {\n\t\tfree(current);\n\t\treturn (-1);\n\t}\n\n\t \n\tret = 0;\n\tif (current != NULL) {\n\t\tif (is_raidz_mirror(current, new, &raidz, &mirror) ||\n\t\t    is_raidz_mirror(new, current, &raidz, &mirror)) {\n\t\t\tif (raidz->zprl_parity != mirror->zprl_children - 1) {\n\t\t\t\tvdev_error(gettext(\n\t\t\t\t    \"mismatched replication level: pool and \"\n\t\t\t\t    \"new vdev with different redundancy, %s \"\n\t\t\t\t    \"and %s vdevs, %llu vs. %llu (%llu-way)\\n\"),\n\t\t\t\t    raidz->zprl_type,\n\t\t\t\t    mirror->zprl_type,\n\t\t\t\t    (u_longlong_t)raidz->zprl_parity,\n\t\t\t\t    (u_longlong_t)mirror->zprl_children - 1,\n\t\t\t\t    (u_longlong_t)mirror->zprl_children);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else if (strcmp(current->zprl_type, new->zprl_type) != 0) {\n\t\t\tvdev_error(gettext(\n\t\t\t    \"mismatched replication level: pool uses %s \"\n\t\t\t    \"and new vdev is %s\\n\"),\n\t\t\t    current->zprl_type, new->zprl_type);\n\t\t\tret = -1;\n\t\t} else if (current->zprl_parity != new->zprl_parity) {\n\t\t\tvdev_error(gettext(\n\t\t\t    \"mismatched replication level: pool uses %llu \"\n\t\t\t    \"device parity and new vdev uses %llu\\n\"),\n\t\t\t    (u_longlong_t)current->zprl_parity,\n\t\t\t    (u_longlong_t)new->zprl_parity);\n\t\t\tret = -1;\n\t\t} else if (current->zprl_children != new->zprl_children) {\n\t\t\tvdev_error(gettext(\n\t\t\t    \"mismatched replication level: pool uses %llu-way \"\n\t\t\t    \"%s and new vdev uses %llu-way %s\\n\"),\n\t\t\t    (u_longlong_t)current->zprl_children,\n\t\t\t    current->zprl_type,\n\t\t\t    (u_longlong_t)new->zprl_children,\n\t\t\t    new->zprl_type);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tfree(new);\n\tif (current != NULL)\n\t\tfree(current);\n\n\treturn (ret);\n}\n\nstatic int\nzero_label(const char *path)\n{\n\tconst int size = 4096;\n\tchar buf[size];\n\tint err, fd;\n\n\tif ((fd = open(path, O_WRONLY|O_EXCL)) < 0) {\n\t\t(void) fprintf(stderr, gettext(\"cannot open '%s': %s\\n\"),\n\t\t    path, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tmemset(buf, 0, size);\n\terr = write(fd, buf, size);\n\t(void) fdatasync(fd);\n\t(void) close(fd);\n\n\tif (err == -1) {\n\t\t(void) fprintf(stderr, gettext(\"cannot zero first %d bytes \"\n\t\t    \"of '%s': %s\\n\"), size, path, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tif (err != size) {\n\t\t(void) fprintf(stderr, gettext(\"could only zero %d/%d bytes \"\n\t\t    \"of '%s'\\n\"), err, size, path);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nlines_to_stderr(char *lines[], int lines_cnt)\n{\n\tint i;\n\tfor (i = 0; i < lines_cnt; i++) {\n\t\tfprintf(stderr, \"%s\\n\", lines[i]);\n\t}\n}\n\n \nstatic int\nmake_disks(zpool_handle_t *zhp, nvlist_t *nv, boolean_t replacing)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tconst char *type, *path;\n\tchar devpath[MAXPATHLEN];\n\tchar udevpath[MAXPATHLEN];\n\tuint64_t wholedisk;\n\tstruct stat64 statbuf;\n\tint is_exclusive = 0;\n\tint fd;\n\tint ret;\n\n\tverify(nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) == 0);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\n\t\tif (strcmp(type, VDEV_TYPE_DISK) != 0)\n\t\t\treturn (0);\n\n\t\t \n\t\tverify(!nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path));\n\t\tverify(!nvlist_lookup_uint64(nv, ZPOOL_CONFIG_WHOLE_DISK,\n\t\t    &wholedisk));\n\n\t\tif (!wholedisk) {\n\t\t\t \n\t\t\tif (is_mpath_whole_disk(path))\n\t\t\t\tupdate_vdev_config_dev_strs(nv);\n\n\t\t\tif (!is_spare(NULL, path))\n\t\t\t\t(void) zero_label(path);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif (realpath(path, devpath) == NULL) {\n\t\t\tret = errno;\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"cannot resolve path '%s'\\n\"), path);\n\t\t\treturn (ret);\n\t\t}\n\n\t\t \n\t\tstrlcpy(udevpath, path, MAXPATHLEN);\n\t\t(void) zfs_append_partition(udevpath, MAXPATHLEN);\n\n\t\tfd = open(devpath, O_RDWR|O_EXCL);\n\t\tif (fd == -1) {\n\t\t\tif (errno == EBUSY)\n\t\t\t\tis_exclusive = 1;\n#ifdef __FreeBSD__\n\t\t\tif (errno == EPERM)\n\t\t\t\tis_exclusive = 1;\n#endif\n\t\t} else {\n\t\t\t(void) close(fd);\n\t\t}\n\n\t\t \n\t\tif (!is_exclusive && !is_spare(NULL, udevpath)) {\n\t\t\tchar *devnode = strrchr(devpath, '/') + 1;\n\t\t\tchar **lines = NULL;\n\t\t\tint lines_cnt = 0;\n\n\t\t\tret = strncmp(udevpath, UDISK_ROOT, strlen(UDISK_ROOT));\n\t\t\tif (ret == 0) {\n\t\t\t\tret = lstat64(udevpath, &statbuf);\n\t\t\t\tif (ret == 0 && S_ISLNK(statbuf.st_mode))\n\t\t\t\t\t(void) unlink(udevpath);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (zpool_prepare_and_label_disk(g_zfs, zhp, devnode,\n\t\t\t    nv, zhp == NULL ? \"create\" :\n\t\t\t    replacing ? \"replace\" : \"add\", &lines,\n\t\t\t    &lines_cnt) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\n\t\t\t\t    \"Error preparing/labeling disk.\\n\"));\n\t\t\t\tif (lines_cnt > 0) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\tgettext(\"zfs_prepare_disk output:\\n\"));\n\t\t\t\t\tlines_to_stderr(lines, lines_cnt);\n\t\t\t\t}\n\n\t\t\t\tlibzfs_free_str_array(lines, lines_cnt);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tlibzfs_free_str_array(lines, lines_cnt);\n\n\t\t\t \n\t\t\tret = zpool_label_disk_wait(udevpath, DISK_LABEL_WAIT);\n\t\t\tif (ret) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"missing link: %s was \"\n\t\t\t\t    \"partitioned but %s is missing\\n\"),\n\t\t\t\t    devnode, udevpath);\n\t\t\t\treturn (ret);\n\t\t\t}\n\n\t\t\tret = zero_label(udevpath);\n\t\t\tif (ret)\n\t\t\t\treturn (ret);\n\t\t}\n\n\t\t \n\t\tverify(nvlist_add_string(nv, ZPOOL_CONFIG_PATH, udevpath) == 0);\n\n\t\t \n\t\tupdate_vdev_config_dev_strs(nv);\n\n\t\treturn (0);\n\t}\n\n\tfor (c = 0; c < children; c++)\n\t\tif ((ret = make_disks(zhp, child[c], replacing)) != 0)\n\t\t\treturn (ret);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0)\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif ((ret = make_disks(zhp, child[c], replacing)) != 0)\n\t\t\t\treturn (ret);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0)\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif ((ret = make_disks(zhp, child[c], replacing)) != 0)\n\t\t\t\treturn (ret);\n\n\treturn (0);\n}\n\n \nstatic boolean_t\nis_device_in_use(nvlist_t *config, nvlist_t *nv, boolean_t force,\n    boolean_t replacing, boolean_t isspare)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tconst char *type, *path;\n\tint ret = 0;\n\tchar buf[MAXPATHLEN];\n\tuint64_t wholedisk = B_FALSE;\n\tboolean_t anyinuse = B_FALSE;\n\n\tverify(nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) == 0);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\n\t\tverify(!nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path));\n\t\tif (strcmp(type, VDEV_TYPE_DISK) == 0)\n\t\t\tverify(!nvlist_lookup_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_WHOLE_DISK, &wholedisk));\n\n\t\t \n\t\tif (replacing) {\n\t\t\t(void) strlcpy(buf, path, sizeof (buf));\n\t\t\tif (wholedisk) {\n\t\t\t\tret = zfs_append_partition(buf,  sizeof (buf));\n\t\t\t\tif (ret == -1)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (is_spare(config, buf))\n\t\t\t\treturn (B_FALSE);\n\t\t}\n\n\t\tif (strcmp(type, VDEV_TYPE_DISK) == 0)\n\t\t\tret = check_device(path, force, isspare, wholedisk);\n\n\t\telse if (strcmp(type, VDEV_TYPE_FILE) == 0)\n\t\t\tret = check_file(path, force, isspare);\n\n\t\treturn (ret != 0);\n\t}\n\n\tfor (c = 0; c < children; c++)\n\t\tif (is_device_in_use(config, child[c], force, replacing,\n\t\t    B_FALSE))\n\t\t\tanyinuse = B_TRUE;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0)\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (is_device_in_use(config, child[c], force, replacing,\n\t\t\t    B_TRUE))\n\t\t\t\tanyinuse = B_TRUE;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0)\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (is_device_in_use(config, child[c], force, replacing,\n\t\t\t    B_FALSE))\n\t\t\t\tanyinuse = B_TRUE;\n\n\treturn (anyinuse);\n}\n\n \nstatic int\nget_parity(const char *type)\n{\n\tlong parity = 0;\n\tconst char *p;\n\n\tif (strncmp(type, VDEV_TYPE_RAIDZ, strlen(VDEV_TYPE_RAIDZ)) == 0) {\n\t\tp = type + strlen(VDEV_TYPE_RAIDZ);\n\n\t\tif (*p == '\\0') {\n\t\t\t \n\t\t\treturn (1);\n\t\t} else if (*p == '0') {\n\t\t\t \n\t\t\treturn (0);\n\t\t} else {\n\t\t\t \n\t\t\tchar *end;\n\t\t\terrno = 0;\n\t\t\tparity = strtol(p, &end, 10);\n\t\t\tif (errno != 0 || *end != '\\0' ||\n\t\t\t    parity < 1 || parity > VDEV_RAIDZ_MAXPARITY) {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t} else if (strncmp(type, VDEV_TYPE_DRAID,\n\t    strlen(VDEV_TYPE_DRAID)) == 0) {\n\t\tp = type + strlen(VDEV_TYPE_DRAID);\n\n\t\tif (*p == '\\0' || *p == ':') {\n\t\t\t \n\t\t\treturn (1);\n\t\t} else if (*p == '0') {\n\t\t\t \n\t\t\treturn (0);\n\t\t} else {\n\t\t\t \n\t\t\tchar *end;\n\t\t\terrno = 0;\n\t\t\tparity = strtol(p, &end, 10);\n\t\t\tif (errno != 0 ||\n\t\t\t    parity < 1 || parity > VDEV_DRAID_MAXPARITY ||\n\t\t\t    (*end != '\\0' && *end != ':')) {\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ((int)parity);\n}\n\n \nstatic const char *\nis_grouping(const char *type, int *mindev, int *maxdev)\n{\n\tint nparity;\n\n\tif (strncmp(type, VDEV_TYPE_RAIDZ, strlen(VDEV_TYPE_RAIDZ)) == 0 ||\n\t    strncmp(type, VDEV_TYPE_DRAID, strlen(VDEV_TYPE_DRAID)) == 0) {\n\t\tnparity = get_parity(type);\n\t\tif (nparity == 0)\n\t\t\treturn (NULL);\n\t\tif (mindev != NULL)\n\t\t\t*mindev = nparity + 1;\n\t\tif (maxdev != NULL)\n\t\t\t*maxdev = 255;\n\n\t\tif (strncmp(type, VDEV_TYPE_RAIDZ,\n\t\t    strlen(VDEV_TYPE_RAIDZ)) == 0) {\n\t\t\treturn (VDEV_TYPE_RAIDZ);\n\t\t} else {\n\t\t\treturn (VDEV_TYPE_DRAID);\n\t\t}\n\t}\n\n\tif (maxdev != NULL)\n\t\t*maxdev = INT_MAX;\n\n\tif (strcmp(type, \"mirror\") == 0) {\n\t\tif (mindev != NULL)\n\t\t\t*mindev = 2;\n\t\treturn (VDEV_TYPE_MIRROR);\n\t}\n\n\tif (strcmp(type, \"spare\") == 0) {\n\t\tif (mindev != NULL)\n\t\t\t*mindev = 1;\n\t\treturn (VDEV_TYPE_SPARE);\n\t}\n\n\tif (strcmp(type, \"log\") == 0) {\n\t\tif (mindev != NULL)\n\t\t\t*mindev = 1;\n\t\treturn (VDEV_TYPE_LOG);\n\t}\n\n\tif (strcmp(type, VDEV_ALLOC_BIAS_SPECIAL) == 0 ||\n\t    strcmp(type, VDEV_ALLOC_BIAS_DEDUP) == 0) {\n\t\tif (mindev != NULL)\n\t\t\t*mindev = 1;\n\t\treturn (type);\n\t}\n\n\tif (strcmp(type, \"cache\") == 0) {\n\t\tif (mindev != NULL)\n\t\t\t*mindev = 1;\n\t\treturn (VDEV_TYPE_L2CACHE);\n\t}\n\n\treturn (NULL);\n}\n\n \nstatic int\ndraid_config_by_type(nvlist_t *nv, const char *type, uint64_t children)\n{\n\tuint64_t nparity = 1;\n\tuint64_t nspares = 0;\n\tuint64_t ndata = UINT64_MAX;\n\tuint64_t ngroups = 1;\n\tlong value;\n\n\tif (strncmp(type, VDEV_TYPE_DRAID, strlen(VDEV_TYPE_DRAID)) != 0)\n\t\treturn (EINVAL);\n\n\tnparity = (uint64_t)get_parity(type);\n\tif (nparity == 0 || nparity > VDEV_DRAID_MAXPARITY) {\n\t\tfprintf(stderr,\n\t\t    gettext(\"invalid dRAID parity level %llu; must be \"\n\t\t    \"between 1 and %d\\n\"), (u_longlong_t)nparity,\n\t\t    VDEV_DRAID_MAXPARITY);\n\t\treturn (EINVAL);\n\t}\n\n\tchar *p = (char *)type;\n\twhile ((p = strchr(p, ':')) != NULL) {\n\t\tchar *end;\n\n\t\tp = p + 1;\n\t\terrno = 0;\n\n\t\tif (!isdigit(p[0])) {\n\t\t\t(void) fprintf(stderr, gettext(\"invalid dRAID \"\n\t\t\t    \"syntax; expected [:<number><c|d|s>] not '%s'\\n\"),\n\t\t\t    type);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\t \n\t\tvalue = strtol(p, &end, 10);\n\t\tchar suffix = tolower(*end);\n\t\tif (errno != 0 ||\n\t\t    (suffix != 'c' && suffix != 'd' && suffix != 's')) {\n\t\t\t(void) fprintf(stderr, gettext(\"invalid dRAID \"\n\t\t\t    \"syntax; expected [:<number><c|d|s>] not '%s'\\n\"),\n\t\t\t    type);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\tif (suffix == 'c') {\n\t\t\tif ((uint64_t)value != children) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    gettext(\"invalid number of dRAID children; \"\n\t\t\t\t    \"%llu required but %llu provided\\n\"),\n\t\t\t\t    (u_longlong_t)value,\n\t\t\t\t    (u_longlong_t)children);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\t\t} else if (suffix == 'd') {\n\t\t\tndata = (uint64_t)value;\n\t\t} else if (suffix == 's') {\n\t\t\tnspares = (uint64_t)value;\n\t\t} else {\n\t\t\tverify(0);  \n\t\t}\n\t}\n\n\t \n\tif (ndata == UINT64_MAX) {\n\t\tif (children > nspares + nparity) {\n\t\t\tndata = MIN(children - nspares - nparity, 8);\n\t\t} else {\n\t\t\tfprintf(stderr, gettext(\"request number of \"\n\t\t\t    \"distributed spares %llu and parity level %llu\\n\"\n\t\t\t    \"leaves no disks available for data\\n\"),\n\t\t\t    (u_longlong_t)nspares, (u_longlong_t)nparity);\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\t \n\tif (ndata == 0 || (ndata + nparity > children - nspares)) {\n\t\tfprintf(stderr, gettext(\"requested number of dRAID data \"\n\t\t    \"disks per group %llu is too high,\\nat most %llu disks \"\n\t\t    \"are available for data\\n\"), (u_longlong_t)ndata,\n\t\t    (u_longlong_t)(children - nspares - nparity));\n\t\treturn (EINVAL);\n\t}\n\n\t \n\tif (nspares > 100 || nspares > (children - (ndata + nparity))) {\n\t\tfprintf(stderr,\n\t\t    gettext(\"invalid number of dRAID spares %llu; additional \"\n\t\t    \"disks would be required\\n\"), (u_longlong_t)nspares);\n\t\treturn (EINVAL);\n\t}\n\n\t \n\tif (children < (ndata + nparity + nspares)) {\n\t\tfprintf(stderr, gettext(\"%llu disks were provided, but at \"\n\t\t    \"least %llu disks are required for this config\\n\"),\n\t\t    (u_longlong_t)children,\n\t\t    (u_longlong_t)(ndata + nparity + nspares));\n\t}\n\n\tif (children > VDEV_DRAID_MAX_CHILDREN) {\n\t\tfprintf(stderr, gettext(\"%llu disks were provided, but \"\n\t\t    \"dRAID only supports up to %u disks\"),\n\t\t    (u_longlong_t)children, VDEV_DRAID_MAX_CHILDREN);\n\t}\n\n\t \n\twhile (ngroups * (ndata + nparity) % (children - nspares) != 0)\n\t\tngroups++;\n\n\t \n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_NPARITY, nparity);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DRAID_NDATA, ndata);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DRAID_NSPARES, nspares);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DRAID_NGROUPS, ngroups);\n\n\treturn (0);\n}\n\n \nstatic nvlist_t *\nconstruct_spec(nvlist_t *props, int argc, char **argv)\n{\n\tnvlist_t *nvroot, *nv, **top, **spares, **l2cache;\n\tint t, toplevels, mindev, maxdev, nspares, nlogs, nl2cache;\n\tconst char *type, *fulltype;\n\tboolean_t is_log, is_special, is_dedup, is_spare;\n\tboolean_t seen_logs;\n\n\ttop = NULL;\n\ttoplevels = 0;\n\tspares = NULL;\n\tl2cache = NULL;\n\tnspares = 0;\n\tnlogs = 0;\n\tnl2cache = 0;\n\tis_log = is_special = is_dedup = is_spare = B_FALSE;\n\tseen_logs = B_FALSE;\n\tnvroot = NULL;\n\n\twhile (argc > 0) {\n\t\tfulltype = argv[0];\n\t\tnv = NULL;\n\n\t\t \n\t\tif ((type = is_grouping(fulltype, &mindev, &maxdev)) != NULL) {\n\t\t\tnvlist_t **child = NULL;\n\t\t\tint c, children = 0;\n\n\t\t\tif (strcmp(type, VDEV_TYPE_SPARE) == 0) {\n\t\t\t\tif (spares != NULL) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    gettext(\"invalid vdev \"\n\t\t\t\t\t    \"specification: 'spare' can be \"\n\t\t\t\t\t    \"specified only once\\n\"));\n\t\t\t\t\tgoto spec_out;\n\t\t\t\t}\n\t\t\t\tis_spare = B_TRUE;\n\t\t\t\tis_log = is_special = is_dedup = B_FALSE;\n\t\t\t}\n\n\t\t\tif (strcmp(type, VDEV_TYPE_LOG) == 0) {\n\t\t\t\tif (seen_logs) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    gettext(\"invalid vdev \"\n\t\t\t\t\t    \"specification: 'log' can be \"\n\t\t\t\t\t    \"specified only once\\n\"));\n\t\t\t\t\tgoto spec_out;\n\t\t\t\t}\n\t\t\t\tseen_logs = B_TRUE;\n\t\t\t\tis_log = B_TRUE;\n\t\t\t\tis_special = is_dedup = is_spare = B_FALSE;\n\t\t\t\targc--;\n\t\t\t\targv++;\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(type, VDEV_ALLOC_BIAS_SPECIAL) == 0) {\n\t\t\t\tis_special = B_TRUE;\n\t\t\t\tis_log = is_dedup = is_spare = B_FALSE;\n\t\t\t\targc--;\n\t\t\t\targv++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(type, VDEV_ALLOC_BIAS_DEDUP) == 0) {\n\t\t\t\tis_dedup = B_TRUE;\n\t\t\t\tis_log = is_special = is_spare = B_FALSE;\n\t\t\t\targc--;\n\t\t\t\targv++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(type, VDEV_TYPE_L2CACHE) == 0) {\n\t\t\t\tif (l2cache != NULL) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    gettext(\"invalid vdev \"\n\t\t\t\t\t    \"specification: 'cache' can be \"\n\t\t\t\t\t    \"specified only once\\n\"));\n\t\t\t\t\tgoto spec_out;\n\t\t\t\t}\n\t\t\t\tis_log = is_special = B_FALSE;\n\t\t\t\tis_dedup = is_spare = B_FALSE;\n\t\t\t}\n\n\t\t\tif (is_log || is_special || is_dedup) {\n\t\t\t\tif (strcmp(type, VDEV_TYPE_MIRROR) != 0) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    gettext(\"invalid vdev \"\n\t\t\t\t\t    \"specification: unsupported '%s' \"\n\t\t\t\t\t    \"device: %s\\n\"), is_log ? \"log\" :\n\t\t\t\t\t    \"special\", type);\n\t\t\t\t\tgoto spec_out;\n\t\t\t\t}\n\t\t\t\tnlogs++;\n\t\t\t}\n\n\t\t\tfor (c = 1; c < argc; c++) {\n\t\t\t\tif (is_grouping(argv[c], NULL, NULL) != NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tchildren++;\n\t\t\t\tchild = realloc(child,\n\t\t\t\t    children * sizeof (nvlist_t *));\n\t\t\t\tif (child == NULL)\n\t\t\t\t\tzpool_no_memory();\n\t\t\t\tif ((nv = make_leaf_vdev(props, argv[c],\n\t\t\t\t    !(is_log || is_special || is_dedup ||\n\t\t\t\t    is_spare))) == NULL) {\n\t\t\t\t\tfor (c = 0; c < children - 1; c++)\n\t\t\t\t\t\tnvlist_free(child[c]);\n\t\t\t\t\tfree(child);\n\t\t\t\t\tgoto spec_out;\n\t\t\t\t}\n\n\t\t\t\tchild[children - 1] = nv;\n\t\t\t}\n\n\t\t\tif (children < mindev) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"invalid vdev \"\n\t\t\t\t    \"specification: %s requires at least %d \"\n\t\t\t\t    \"devices\\n\"), argv[0], mindev);\n\t\t\t\tfor (c = 0; c < children; c++)\n\t\t\t\t\tnvlist_free(child[c]);\n\t\t\t\tfree(child);\n\t\t\t\tgoto spec_out;\n\t\t\t}\n\n\t\t\tif (children > maxdev) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"invalid vdev \"\n\t\t\t\t    \"specification: %s supports no more than \"\n\t\t\t\t    \"%d devices\\n\"), argv[0], maxdev);\n\t\t\t\tfor (c = 0; c < children; c++)\n\t\t\t\t\tnvlist_free(child[c]);\n\t\t\t\tfree(child);\n\t\t\t\tgoto spec_out;\n\t\t\t}\n\n\t\t\targc -= c;\n\t\t\targv += c;\n\n\t\t\tif (strcmp(type, VDEV_TYPE_SPARE) == 0) {\n\t\t\t\tspares = child;\n\t\t\t\tnspares = children;\n\t\t\t\tcontinue;\n\t\t\t} else if (strcmp(type, VDEV_TYPE_L2CACHE) == 0) {\n\t\t\t\tl2cache = child;\n\t\t\t\tnl2cache = children;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tverify(nvlist_alloc(&nv, NV_UNIQUE_NAME,\n\t\t\t\t    0) == 0);\n\t\t\t\tverify(nvlist_add_string(nv, ZPOOL_CONFIG_TYPE,\n\t\t\t\t    type) == 0);\n\t\t\t\tverify(nvlist_add_uint64(nv,\n\t\t\t\t    ZPOOL_CONFIG_IS_LOG, is_log) == 0);\n\t\t\t\tif (is_log) {\n\t\t\t\t\tverify(nvlist_add_string(nv,\n\t\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t\t    VDEV_ALLOC_BIAS_LOG) == 0);\n\t\t\t\t}\n\t\t\t\tif (is_special) {\n\t\t\t\t\tverify(nvlist_add_string(nv,\n\t\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t\t    VDEV_ALLOC_BIAS_SPECIAL) == 0);\n\t\t\t\t}\n\t\t\t\tif (is_dedup) {\n\t\t\t\t\tverify(nvlist_add_string(nv,\n\t\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t\t    VDEV_ALLOC_BIAS_DEDUP) == 0);\n\t\t\t\t}\n\t\t\t\tif (strcmp(type, VDEV_TYPE_RAIDZ) == 0) {\n\t\t\t\t\tverify(nvlist_add_uint64(nv,\n\t\t\t\t\t    ZPOOL_CONFIG_NPARITY,\n\t\t\t\t\t    mindev - 1) == 0);\n\t\t\t\t}\n\t\t\t\tif (strcmp(type, VDEV_TYPE_DRAID) == 0) {\n\t\t\t\t\tif (draid_config_by_type(nv,\n\t\t\t\t\t    fulltype, children) != 0) {\n\t\t\t\t\t\tfor (c = 0; c < children; c++)\n\t\t\t\t\t\t\tnvlist_free(child[c]);\n\t\t\t\t\t\tfree(child);\n\t\t\t\t\t\tgoto spec_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tverify(nvlist_add_nvlist_array(nv,\n\t\t\t\t    ZPOOL_CONFIG_CHILDREN,\n\t\t\t\t    (const nvlist_t **)child, children) == 0);\n\n\t\t\t\tfor (c = 0; c < children; c++)\n\t\t\t\t\tnvlist_free(child[c]);\n\t\t\t\tfree(child);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((nv = make_leaf_vdev(props, argv[0], !(is_log ||\n\t\t\t    is_special || is_dedup || is_spare))) == NULL)\n\t\t\t\tgoto spec_out;\n\n\t\t\tverify(nvlist_add_uint64(nv,\n\t\t\t    ZPOOL_CONFIG_IS_LOG, is_log) == 0);\n\t\t\tif (is_log) {\n\t\t\t\tverify(nvlist_add_string(nv,\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t    VDEV_ALLOC_BIAS_LOG) == 0);\n\t\t\t\tnlogs++;\n\t\t\t}\n\n\t\t\tif (is_special) {\n\t\t\t\tverify(nvlist_add_string(nv,\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t    VDEV_ALLOC_BIAS_SPECIAL) == 0);\n\t\t\t}\n\t\t\tif (is_dedup) {\n\t\t\t\tverify(nvlist_add_string(nv,\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t\t    VDEV_ALLOC_BIAS_DEDUP) == 0);\n\t\t\t}\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\n\t\ttoplevels++;\n\t\ttop = realloc(top, toplevels * sizeof (nvlist_t *));\n\t\tif (top == NULL)\n\t\t\tzpool_no_memory();\n\t\ttop[toplevels - 1] = nv;\n\t}\n\n\tif (toplevels == 0 && nspares == 0 && nl2cache == 0) {\n\t\t(void) fprintf(stderr, gettext(\"invalid vdev \"\n\t\t    \"specification: at least one toplevel vdev must be \"\n\t\t    \"specified\\n\"));\n\t\tgoto spec_out;\n\t}\n\n\tif (seen_logs && nlogs == 0) {\n\t\t(void) fprintf(stderr, gettext(\"invalid vdev specification: \"\n\t\t    \"log requires at least 1 device\\n\"));\n\t\tgoto spec_out;\n\t}\n\n\t \n\tverify(nvlist_alloc(&nvroot, NV_UNIQUE_NAME, 0) == 0);\n\tverify(nvlist_add_string(nvroot, ZPOOL_CONFIG_TYPE,\n\t    VDEV_TYPE_ROOT) == 0);\n\tverify(nvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)top, toplevels) == 0);\n\tif (nspares != 0)\n\t\tverify(nvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t\t    (const nvlist_t **)spares, nspares) == 0);\n\tif (nl2cache != 0)\n\t\tverify(nvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_L2CACHE,\n\t\t    (const nvlist_t **)l2cache, nl2cache) == 0);\n\nspec_out:\n\tfor (t = 0; t < toplevels; t++)\n\t\tnvlist_free(top[t]);\n\tfor (t = 0; t < nspares; t++)\n\t\tnvlist_free(spares[t]);\n\tfor (t = 0; t < nl2cache; t++)\n\t\tnvlist_free(l2cache[t]);\n\n\tfree(spares);\n\tfree(l2cache);\n\tfree(top);\n\n\treturn (nvroot);\n}\n\nnvlist_t *\nsplit_mirror_vdev(zpool_handle_t *zhp, char *newname, nvlist_t *props,\n    splitflags_t flags, int argc, char **argv)\n{\n\tnvlist_t *newroot = NULL, **child;\n\tuint_t c, children;\n\n\tif (argc > 0) {\n\t\tif ((newroot = construct_spec(props, argc, argv)) == NULL) {\n\t\t\t(void) fprintf(stderr, gettext(\"Unable to build a \"\n\t\t\t    \"pool from the specified devices\\n\"));\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tif (!flags.dryrun && make_disks(zhp, newroot, B_FALSE) != 0) {\n\t\t\tnvlist_free(newroot);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t \n\t\tverify(nvlist_lookup_nvlist_array(newroot,\n\t\t    ZPOOL_CONFIG_CHILDREN, &child, &children) == 0);\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tconst char *path;\n\t\t\tconst char *type;\n\t\t\tint min, max;\n\n\t\t\tverify(nvlist_lookup_string(child[c],\n\t\t\t    ZPOOL_CONFIG_PATH, &path) == 0);\n\t\t\tif ((type = is_grouping(path, &min, &max)) != NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"Cannot use \"\n\t\t\t\t    \"'%s' as a device for splitting\\n\"), type);\n\t\t\t\tnvlist_free(newroot);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zpool_vdev_split(zhp, newname, &newroot, props, flags) != 0) {\n\t\tnvlist_free(newroot);\n\t\treturn (NULL);\n\t}\n\n\treturn (newroot);\n}\n\nstatic int\nnum_normal_vdevs(nvlist_t *nvroot)\n{\n\tnvlist_t **top;\n\tuint_t t, toplevels, normal = 0;\n\n\tverify(nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &top, &toplevels) == 0);\n\n\tfor (t = 0; t < toplevels; t++) {\n\t\tuint64_t log = B_FALSE;\n\n\t\t(void) nvlist_lookup_uint64(top[t], ZPOOL_CONFIG_IS_LOG, &log);\n\t\tif (log)\n\t\t\tcontinue;\n\t\tif (nvlist_exists(top[t], ZPOOL_CONFIG_ALLOCATION_BIAS))\n\t\t\tcontinue;\n\n\t\tnormal++;\n\t}\n\n\treturn (normal);\n}\n\n \nnvlist_t *\nmake_root_vdev(zpool_handle_t *zhp, nvlist_t *props, int force, int check_rep,\n    boolean_t replacing, boolean_t dryrun, int argc, char **argv)\n{\n\tnvlist_t *newroot;\n\tnvlist_t *poolconfig = NULL;\n\tis_force = force;\n\n\t \n\tif ((newroot = construct_spec(props, argc, argv)) == NULL)\n\t\treturn (NULL);\n\n\tif (zhp && ((poolconfig = zpool_get_config(zhp, NULL)) == NULL)) {\n\t\tnvlist_free(newroot);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (is_device_in_use(poolconfig, newroot, force, replacing, B_FALSE)) {\n\t\tnvlist_free(newroot);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (check_rep && check_replication(poolconfig, newroot) != 0) {\n\t\tnvlist_free(newroot);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (poolconfig == NULL && num_normal_vdevs(newroot) == 0) {\n\t\tvdev_error(gettext(\"at least one general top-level vdev must \"\n\t\t    \"be specified\\n\"));\n\t\tnvlist_free(newroot);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (!dryrun && make_disks(zhp, newroot, replacing) != 0) {\n\t\tnvlist_free(newroot);\n\t\treturn (NULL);\n\t}\n\n\treturn (newroot);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}