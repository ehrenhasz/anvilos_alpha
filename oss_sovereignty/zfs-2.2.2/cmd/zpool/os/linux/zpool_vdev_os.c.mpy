{
  "module_name": "zpool_vdev_os.c",
  "hash_id": "ad53ca5fa4b30ff38ab7dea0ad9e7f7b97b10b81faea381420a822414ebd72d3",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool/os/linux/zpool_vdev_os.c",
  "human_readable_source": " \n\n \n\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libintl.h>\n#include <libnvpair.h>\n#include <libzutil.h>\n#include <limits.h>\n#include <sys/spa.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include \"zpool_util.h\"\n#include <sys/zfs_context.h>\n\n#include <scsi/scsi.h>\n#include <scsi/sg.h>\n#include <sys/efi_partition.h>\n#include <sys/stat.h>\n#include <sys/mntent.h>\n#include <uuid/uuid.h>\n#include <blkid/blkid.h>\n\ntypedef struct vdev_disk_db_entry\n{\n\tchar id[24];\n\tint sector_size;\n} vdev_disk_db_entry_t;\n\n \nstatic vdev_disk_db_entry_t vdev_disk_database[] = {\n\t{\"ATA     ADATA SSD S396 3\", 8192},\n\t{\"ATA     APPLE SSD SM128E\", 8192},\n\t{\"ATA     APPLE SSD SM256E\", 8192},\n\t{\"ATA     APPLE SSD SM512E\", 8192},\n\t{\"ATA     APPLE SSD SM768E\", 8192},\n\t{\"ATA     C400-MTFDDAC064M\", 8192},\n\t{\"ATA     C400-MTFDDAC128M\", 8192},\n\t{\"ATA     C400-MTFDDAC256M\", 8192},\n\t{\"ATA     C400-MTFDDAC512M\", 8192},\n\t{\"ATA     Corsair Force 3 \", 8192},\n\t{\"ATA     Corsair Force GS\", 8192},\n\t{\"ATA     INTEL SSDSA2CT04\", 8192},\n\t{\"ATA     INTEL SSDSA2BZ10\", 8192},\n\t{\"ATA     INTEL SSDSA2BZ20\", 8192},\n\t{\"ATA     INTEL SSDSA2BZ30\", 8192},\n\t{\"ATA     INTEL SSDSA2CW04\", 8192},\n\t{\"ATA     INTEL SSDSA2CW08\", 8192},\n\t{\"ATA     INTEL SSDSA2CW12\", 8192},\n\t{\"ATA     INTEL SSDSA2CW16\", 8192},\n\t{\"ATA     INTEL SSDSA2CW30\", 8192},\n\t{\"ATA     INTEL SSDSA2CW60\", 8192},\n\t{\"ATA     INTEL SSDSC2CT06\", 8192},\n\t{\"ATA     INTEL SSDSC2CT12\", 8192},\n\t{\"ATA     INTEL SSDSC2CT18\", 8192},\n\t{\"ATA     INTEL SSDSC2CT24\", 8192},\n\t{\"ATA     INTEL SSDSC2CW06\", 8192},\n\t{\"ATA     INTEL SSDSC2CW12\", 8192},\n\t{\"ATA     INTEL SSDSC2CW18\", 8192},\n\t{\"ATA     INTEL SSDSC2CW24\", 8192},\n\t{\"ATA     INTEL SSDSC2CW48\", 8192},\n\t{\"ATA     KINGSTON SH100S3\", 8192},\n\t{\"ATA     KINGSTON SH103S3\", 8192},\n\t{\"ATA     M4-CT064M4SSD2  \", 8192},\n\t{\"ATA     M4-CT128M4SSD2  \", 8192},\n\t{\"ATA     M4-CT256M4SSD2  \", 8192},\n\t{\"ATA     M4-CT512M4SSD2  \", 8192},\n\t{\"ATA     OCZ-AGILITY2    \", 8192},\n\t{\"ATA     OCZ-AGILITY3    \", 8192},\n\t{\"ATA     OCZ-VERTEX2 3.5 \", 8192},\n\t{\"ATA     OCZ-VERTEX3     \", 8192},\n\t{\"ATA     OCZ-VERTEX3 LT  \", 8192},\n\t{\"ATA     OCZ-VERTEX3 MI  \", 8192},\n\t{\"ATA     OCZ-VERTEX4     \", 8192},\n\t{\"ATA     SAMSUNG MZ7WD120\", 8192},\n\t{\"ATA     SAMSUNG MZ7WD240\", 8192},\n\t{\"ATA     SAMSUNG MZ7WD480\", 8192},\n\t{\"ATA     SAMSUNG MZ7WD960\", 8192},\n\t{\"ATA     SAMSUNG SSD 830 \", 8192},\n\t{\"ATA     Samsung SSD 840 \", 8192},\n\t{\"ATA     SanDisk SSD U100\", 8192},\n\t{\"ATA     TOSHIBA THNSNH06\", 8192},\n\t{\"ATA     TOSHIBA THNSNH12\", 8192},\n\t{\"ATA     TOSHIBA THNSNH25\", 8192},\n\t{\"ATA     TOSHIBA THNSNH51\", 8192},\n\t{\"ATA     APPLE SSD TS064C\", 4096},\n\t{\"ATA     APPLE SSD TS128C\", 4096},\n\t{\"ATA     APPLE SSD TS256C\", 4096},\n\t{\"ATA     APPLE SSD TS512C\", 4096},\n\t{\"ATA     INTEL SSDSA2M040\", 4096},\n\t{\"ATA     INTEL SSDSA2M080\", 4096},\n\t{\"ATA     INTEL SSDSA2M160\", 4096},\n\t{\"ATA     INTEL SSDSC2MH12\", 4096},\n\t{\"ATA     INTEL SSDSC2MH25\", 4096},\n\t{\"ATA     OCZ CORE_SSD    \", 4096},\n\t{\"ATA     OCZ-VERTEX      \", 4096},\n\t{\"ATA     SAMSUNG MCCOE32G\", 4096},\n\t{\"ATA     SAMSUNG MCCOE64G\", 4096},\n\t{\"ATA     SAMSUNG SSD PM80\", 4096},\n\t \n\t{\"ATA     INTEL SSDSC2BA10\", 4096},\n\t{\"ATA     INTEL SSDSC2BA20\", 4096},\n\t{\"ATA     INTEL SSDSC2BA40\", 4096},\n\t{\"ATA     INTEL SSDSC2BA80\", 4096},\n\t{\"ATA     INTEL SSDSC2BB08\", 4096},\n\t{\"ATA     INTEL SSDSC2BB12\", 4096},\n\t{\"ATA     INTEL SSDSC2BB16\", 4096},\n\t{\"ATA     INTEL SSDSC2BB24\", 4096},\n\t{\"ATA     INTEL SSDSC2BB30\", 4096},\n\t{\"ATA     INTEL SSDSC2BB40\", 4096},\n\t{\"ATA     INTEL SSDSC2BB48\", 4096},\n\t{\"ATA     INTEL SSDSC2BB60\", 4096},\n\t{\"ATA     INTEL SSDSC2BB80\", 4096},\n\t{\"ATA     INTEL SSDSC2BW24\", 4096},\n\t{\"ATA     INTEL SSDSC2BW48\", 4096},\n\t{\"ATA     INTEL SSDSC2BP24\", 4096},\n\t{\"ATA     INTEL SSDSC2BP48\", 4096},\n\t{\"NA      SmrtStorSDLKAE9W\", 4096},\n\t{\"NVMe    Amazon EC2 NVMe \", 4096},\n\t \n\t{\"ATA     MARVELL SD88SA02\", 4096},\n\t \n\t{\"ATA     Hitachi HDS5C303\", 4096},\n\t{\"ATA     SAMSUNG HD204UI \", 4096},\n\t{\"ATA     ST2000DL004 HD20\", 4096},\n\t{\"ATA     WDC WD10EARS-00M\", 4096},\n\t{\"ATA     WDC WD10EARS-00S\", 4096},\n\t{\"ATA     WDC WD10EARS-00Z\", 4096},\n\t{\"ATA     WDC WD15EARS-00M\", 4096},\n\t{\"ATA     WDC WD15EARS-00S\", 4096},\n\t{\"ATA     WDC WD15EARS-00Z\", 4096},\n\t{\"ATA     WDC WD20EARS-00M\", 4096},\n\t{\"ATA     WDC WD20EARS-00S\", 4096},\n\t{\"ATA     WDC WD20EARS-00Z\", 4096},\n\t{\"ATA     WDC WD1600BEVT-0\", 4096},\n\t{\"ATA     WDC WD2500BEVT-0\", 4096},\n\t{\"ATA     WDC WD3200BEVT-0\", 4096},\n\t{\"ATA     WDC WD5000BEVT-0\", 4096},\n};\n\n\n#define\tINQ_REPLY_LEN\t96\n#define\tINQ_CMD_LEN\t6\n\nstatic const int vdev_disk_database_size =\n\tsizeof (vdev_disk_database) / sizeof (vdev_disk_database[0]);\n\nboolean_t\ncheck_sector_size_database(char *path, int *sector_size)\n{\n\tunsigned char inq_buff[INQ_REPLY_LEN];\n\tunsigned char sense_buffer[32];\n\tunsigned char inq_cmd_blk[INQ_CMD_LEN] =\n\t    {INQUIRY, 0, 0, 0, INQ_REPLY_LEN, 0};\n\tsg_io_hdr_t io_hdr;\n\tint error;\n\tint fd;\n\tint i;\n\n\t \n\tmemset(&io_hdr, 0, sizeof (sg_io_hdr_t));\n\tio_hdr.interface_id = 'S';\n\tio_hdr.cmd_len = sizeof (inq_cmd_blk);\n\tio_hdr.mx_sb_len = sizeof (sense_buffer);\n\tio_hdr.dxfer_direction = SG_DXFER_FROM_DEV;\n\tio_hdr.dxfer_len = INQ_REPLY_LEN;\n\tio_hdr.dxferp = inq_buff;\n\tio_hdr.cmdp = inq_cmd_blk;\n\tio_hdr.sbp = sense_buffer;\n\tio_hdr.timeout = 10;\t\t \n\n\tif ((fd = open(path, O_RDONLY|O_DIRECT)) < 0)\n\t\treturn (B_FALSE);\n\n\terror = ioctl(fd, SG_IO, (unsigned long) &io_hdr);\n\n\t(void) close(fd);\n\n\tif (error < 0)\n\t\treturn (B_FALSE);\n\n\tif ((io_hdr.info & SG_INFO_OK_MASK) != SG_INFO_OK)\n\t\treturn (B_FALSE);\n\n\tfor (i = 0; i < vdev_disk_database_size; i++) {\n\t\tif (memcmp(inq_buff + 8, vdev_disk_database[i].id, 24))\n\t\t\tcontinue;\n\n\t\t*sector_size = vdev_disk_database[i].sector_size;\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic int\ncheck_slice(const char *path, blkid_cache cache, int force, boolean_t isspare)\n{\n\tint err;\n\tchar *value;\n\n\t \n\tvalue = blkid_get_tag_value(cache, \"TYPE\", path);\n\tif (value == NULL)\n\t\treturn (0);\n\n\t \n\tif (strcmp(value, \"zfs_member\") == 0) {\n\t\terr = check_file(path, force, isspare);\n\t} else {\n\t\tif (force) {\n\t\t\terr = 0;\n\t\t} else {\n\t\t\terr = -1;\n\t\t\tvdev_error(gettext(\"%s contains a filesystem of \"\n\t\t\t    \"type '%s'\\n\"), path, value);\n\t\t}\n\t}\n\n\tfree(value);\n\n\treturn (err);\n}\n\n \nstatic int\ncheck_disk(const char *path, blkid_cache cache, int force,\n    boolean_t isspare, boolean_t iswholedisk)\n{\n\tstruct dk_gpt *vtoc;\n\tchar slice_path[MAXPATHLEN];\n\tint err = 0;\n\tint fd, i;\n\tint flags = O_RDONLY|O_DIRECT;\n\n\tif (!iswholedisk)\n\t\treturn (check_slice(path, cache, force, isspare));\n\n\t \n\tif (!isspare)\n\t\tflags |= O_EXCL;\n\n\tif ((fd = open(path, flags)) < 0) {\n\t\tchar *value = blkid_get_tag_value(cache, \"TYPE\", path);\n\t\t(void) fprintf(stderr, gettext(\"%s is in use and contains \"\n\t\t    \"a %s filesystem.\\n\"), path, value ? value : \"unknown\");\n\t\tfree(value);\n\t\treturn (-1);\n\t}\n\n\t \n\terr = efi_alloc_and_read(fd, &vtoc);\n\tif (err) {\n\t\t(void) close(fd);\n\t\treturn (check_slice(path, cache, force, isspare));\n\t}\n\n\t \n\tif (vtoc->efi_flags & EFI_GPT_PRIMARY_CORRUPT) {\n\t\tefi_free(vtoc);\n\t\t(void) close(fd);\n\n\t\tif (force) {\n\t\t\t \n\t\t\treturn (0);\n\t\t} else {\n\t\t\tvdev_error(gettext(\"%s contains a corrupt primary \"\n\t\t\t    \"EFI label.\\n\"), path);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < vtoc->efi_nparts; i++) {\n\n\t\tif (vtoc->efi_parts[i].p_tag == V_UNASSIGNED ||\n\t\t    uuid_is_null((uchar_t *)&vtoc->efi_parts[i].p_guid))\n\t\t\tcontinue;\n\n\t\tif (strncmp(path, UDISK_ROOT, strlen(UDISK_ROOT)) == 0)\n\t\t\t(void) snprintf(slice_path, sizeof (slice_path),\n\t\t\t    \"%s%s%d\", path, \"-part\", i+1);\n\t\telse\n\t\t\t(void) snprintf(slice_path, sizeof (slice_path),\n\t\t\t    \"%s%s%d\", path, isdigit(path[strlen(path)-1]) ?\n\t\t\t    \"p\" : \"\", i+1);\n\n\t\terr = check_slice(slice_path, cache, force, isspare);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tefi_free(vtoc);\n\t(void) close(fd);\n\n\treturn (err);\n}\n\nint\ncheck_device(const char *path, boolean_t force,\n    boolean_t isspare, boolean_t iswholedisk)\n{\n\tblkid_cache cache;\n\tint error;\n\n\terror = blkid_get_cache(&cache, NULL);\n\tif (error != 0) {\n\t\t(void) fprintf(stderr, gettext(\"unable to access the blkid \"\n\t\t    \"cache.\\n\"));\n\t\treturn (-1);\n\t}\n\n\terror = check_disk(path, cache, force, isspare, iswholedisk);\n\tblkid_put_cache(cache);\n\n\treturn (error);\n}\n\nvoid\nafter_zpool_upgrade(zpool_handle_t *zhp)\n{\n\t(void) zhp;\n}\n\nint\ncheck_file(const char *file, boolean_t force, boolean_t isspare)\n{\n\treturn (check_file_generic(file, force, isspare));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}