{
  "module_name": "zpool_main.c",
  "hash_id": "0679b5e7e3a9be4b58caa7a21e199432ecdfa63040cd844ca4fe77cec8d4bb3e",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool/zpool_main.c",
  "human_readable_source": " \n\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <libintl.h>\n#include <libuutil.h>\n#include <locale.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <zone.h>\n#include <sys/wait.h>\n#include <zfs_prop.h>\n#include <sys/fs/zfs.h>\n#include <sys/stat.h>\n#include <sys/systeminfo.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/fm/util.h>\n#include <sys/fm/protocol.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/mount.h>\n#include <sys/sysmacros.h>\n\n#include <math.h>\n\n#include <libzfs.h>\n#include <libzutil.h>\n\n#include \"zpool_util.h\"\n#include \"zfs_comutil.h\"\n#include \"zfeature_common.h\"\n\n#include \"statcommon.h\"\n\nlibzfs_handle_t *g_zfs;\n\nstatic int zpool_do_create(int, char **);\nstatic int zpool_do_destroy(int, char **);\n\nstatic int zpool_do_add(int, char **);\nstatic int zpool_do_remove(int, char **);\nstatic int zpool_do_labelclear(int, char **);\n\nstatic int zpool_do_checkpoint(int, char **);\n\nstatic int zpool_do_list(int, char **);\nstatic int zpool_do_iostat(int, char **);\nstatic int zpool_do_status(int, char **);\n\nstatic int zpool_do_online(int, char **);\nstatic int zpool_do_offline(int, char **);\nstatic int zpool_do_clear(int, char **);\nstatic int zpool_do_reopen(int, char **);\n\nstatic int zpool_do_reguid(int, char **);\n\nstatic int zpool_do_attach(int, char **);\nstatic int zpool_do_detach(int, char **);\nstatic int zpool_do_replace(int, char **);\nstatic int zpool_do_split(int, char **);\n\nstatic int zpool_do_initialize(int, char **);\nstatic int zpool_do_scrub(int, char **);\nstatic int zpool_do_resilver(int, char **);\nstatic int zpool_do_trim(int, char **);\n\nstatic int zpool_do_import(int, char **);\nstatic int zpool_do_export(int, char **);\n\nstatic int zpool_do_upgrade(int, char **);\n\nstatic int zpool_do_history(int, char **);\nstatic int zpool_do_events(int, char **);\n\nstatic int zpool_do_get(int, char **);\nstatic int zpool_do_set(int, char **);\n\nstatic int zpool_do_sync(int, char **);\n\nstatic int zpool_do_version(int, char **);\n\nstatic int zpool_do_wait(int, char **);\n\nstatic int zpool_do_help(int argc, char **argv);\n\nstatic zpool_compat_status_t zpool_do_load_compat(\n    const char *, boolean_t *);\n\n \n\n#ifdef DEBUG\nconst char *\n_umem_debug_init(void)\n{\n\treturn (\"default,verbose\");  \n}\n\nconst char *\n_umem_logging_init(void)\n{\n\treturn (\"fail,contents\");  \n}\n#endif\n\ntypedef enum {\n\tHELP_ADD,\n\tHELP_ATTACH,\n\tHELP_CLEAR,\n\tHELP_CREATE,\n\tHELP_CHECKPOINT,\n\tHELP_DESTROY,\n\tHELP_DETACH,\n\tHELP_EXPORT,\n\tHELP_HISTORY,\n\tHELP_IMPORT,\n\tHELP_IOSTAT,\n\tHELP_LABELCLEAR,\n\tHELP_LIST,\n\tHELP_OFFLINE,\n\tHELP_ONLINE,\n\tHELP_REPLACE,\n\tHELP_REMOVE,\n\tHELP_INITIALIZE,\n\tHELP_SCRUB,\n\tHELP_RESILVER,\n\tHELP_TRIM,\n\tHELP_STATUS,\n\tHELP_UPGRADE,\n\tHELP_EVENTS,\n\tHELP_GET,\n\tHELP_SET,\n\tHELP_SPLIT,\n\tHELP_SYNC,\n\tHELP_REGUID,\n\tHELP_REOPEN,\n\tHELP_VERSION,\n\tHELP_WAIT\n} zpool_help_t;\n\n\n \nenum iostat_type {\n\tIOS_DEFAULT = 0,\n\tIOS_LATENCY = 1,\n\tIOS_QUEUES = 2,\n\tIOS_L_HISTO = 3,\n\tIOS_RQ_HISTO = 4,\n\tIOS_COUNT,\t \n};\n\n \n#define\tIOS_DEFAULT_M\t(1ULL << IOS_DEFAULT)\n#define\tIOS_LATENCY_M\t(1ULL << IOS_LATENCY)\n#define\tIOS_QUEUES_M\t(1ULL << IOS_QUEUES)\n#define\tIOS_L_HISTO_M\t(1ULL << IOS_L_HISTO)\n#define\tIOS_RQ_HISTO_M\t(1ULL << IOS_RQ_HISTO)\n\n \n#define\tIOS_ANYHISTO_M (IOS_L_HISTO_M | IOS_RQ_HISTO_M)\n\n \nstatic const char *vsx_type_to_nvlist[IOS_COUNT][15] = {\n\t[IOS_L_HISTO] = {\n\t    ZPOOL_CONFIG_VDEV_TOT_R_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_TOT_W_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_DISK_R_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_DISK_W_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_SYNC_R_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_SYNC_W_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_R_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_W_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_SCRUB_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_TRIM_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_REBUILD_LAT_HISTO,\n\t    NULL},\n\t[IOS_LATENCY] = {\n\t    ZPOOL_CONFIG_VDEV_TOT_R_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_TOT_W_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_DISK_R_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_DISK_W_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_TRIM_LAT_HISTO,\n\t    ZPOOL_CONFIG_VDEV_REBUILD_LAT_HISTO,\n\t    NULL},\n\t[IOS_QUEUES] = {\n\t    ZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE,\n\t    ZPOOL_CONFIG_VDEV_SYNC_W_ACTIVE_QUEUE,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_R_ACTIVE_QUEUE,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_W_ACTIVE_QUEUE,\n\t    ZPOOL_CONFIG_VDEV_SCRUB_ACTIVE_QUEUE,\n\t    ZPOOL_CONFIG_VDEV_TRIM_ACTIVE_QUEUE,\n\t    ZPOOL_CONFIG_VDEV_REBUILD_ACTIVE_QUEUE,\n\t    NULL},\n\t[IOS_RQ_HISTO] = {\n\t    ZPOOL_CONFIG_VDEV_SYNC_IND_R_HISTO,\n\t    ZPOOL_CONFIG_VDEV_SYNC_AGG_R_HISTO,\n\t    ZPOOL_CONFIG_VDEV_SYNC_IND_W_HISTO,\n\t    ZPOOL_CONFIG_VDEV_SYNC_AGG_W_HISTO,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_IND_R_HISTO,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_AGG_R_HISTO,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_IND_W_HISTO,\n\t    ZPOOL_CONFIG_VDEV_ASYNC_AGG_W_HISTO,\n\t    ZPOOL_CONFIG_VDEV_IND_SCRUB_HISTO,\n\t    ZPOOL_CONFIG_VDEV_AGG_SCRUB_HISTO,\n\t    ZPOOL_CONFIG_VDEV_IND_TRIM_HISTO,\n\t    ZPOOL_CONFIG_VDEV_AGG_TRIM_HISTO,\n\t    ZPOOL_CONFIG_VDEV_IND_REBUILD_HISTO,\n\t    ZPOOL_CONFIG_VDEV_AGG_REBUILD_HISTO,\n\t    NULL},\n};\n\n\n \n#define\tIOS_HISTO_IDX(a)\t(highbit64(a & IOS_ANYHISTO_M) - 1)\n\ntypedef struct zpool_command {\n\tconst char\t*name;\n\tint\t\t(*func)(int, char **);\n\tzpool_help_t\tusage;\n} zpool_command_t;\n\n \nstatic zpool_command_t command_table[] = {\n\t{ \"version\",\tzpool_do_version,\tHELP_VERSION\t\t},\n\t{ NULL },\n\t{ \"create\",\tzpool_do_create,\tHELP_CREATE\t\t},\n\t{ \"destroy\",\tzpool_do_destroy,\tHELP_DESTROY\t\t},\n\t{ NULL },\n\t{ \"add\",\tzpool_do_add,\t\tHELP_ADD\t\t},\n\t{ \"remove\",\tzpool_do_remove,\tHELP_REMOVE\t\t},\n\t{ NULL },\n\t{ \"labelclear\",\tzpool_do_labelclear,\tHELP_LABELCLEAR\t\t},\n\t{ NULL },\n\t{ \"checkpoint\",\tzpool_do_checkpoint,\tHELP_CHECKPOINT\t\t},\n\t{ NULL },\n\t{ \"list\",\tzpool_do_list,\t\tHELP_LIST\t\t},\n\t{ \"iostat\",\tzpool_do_iostat,\tHELP_IOSTAT\t\t},\n\t{ \"status\",\tzpool_do_status,\tHELP_STATUS\t\t},\n\t{ NULL },\n\t{ \"online\",\tzpool_do_online,\tHELP_ONLINE\t\t},\n\t{ \"offline\",\tzpool_do_offline,\tHELP_OFFLINE\t\t},\n\t{ \"clear\",\tzpool_do_clear,\t\tHELP_CLEAR\t\t},\n\t{ \"reopen\",\tzpool_do_reopen,\tHELP_REOPEN\t\t},\n\t{ NULL },\n\t{ \"attach\",\tzpool_do_attach,\tHELP_ATTACH\t\t},\n\t{ \"detach\",\tzpool_do_detach,\tHELP_DETACH\t\t},\n\t{ \"replace\",\tzpool_do_replace,\tHELP_REPLACE\t\t},\n\t{ \"split\",\tzpool_do_split,\t\tHELP_SPLIT\t\t},\n\t{ NULL },\n\t{ \"initialize\",\tzpool_do_initialize,\tHELP_INITIALIZE\t\t},\n\t{ \"resilver\",\tzpool_do_resilver,\tHELP_RESILVER\t\t},\n\t{ \"scrub\",\tzpool_do_scrub,\t\tHELP_SCRUB\t\t},\n\t{ \"trim\",\tzpool_do_trim,\t\tHELP_TRIM\t\t},\n\t{ NULL },\n\t{ \"import\",\tzpool_do_import,\tHELP_IMPORT\t\t},\n\t{ \"export\",\tzpool_do_export,\tHELP_EXPORT\t\t},\n\t{ \"upgrade\",\tzpool_do_upgrade,\tHELP_UPGRADE\t\t},\n\t{ \"reguid\",\tzpool_do_reguid,\tHELP_REGUID\t\t},\n\t{ NULL },\n\t{ \"history\",\tzpool_do_history,\tHELP_HISTORY\t\t},\n\t{ \"events\",\tzpool_do_events,\tHELP_EVENTS\t\t},\n\t{ NULL },\n\t{ \"get\",\tzpool_do_get,\t\tHELP_GET\t\t},\n\t{ \"set\",\tzpool_do_set,\t\tHELP_SET\t\t},\n\t{ \"sync\",\tzpool_do_sync,\t\tHELP_SYNC\t\t},\n\t{ NULL },\n\t{ \"wait\",\tzpool_do_wait,\t\tHELP_WAIT\t\t},\n};\n\n#define\tNCOMMAND\t(ARRAY_SIZE(command_table))\n\n#define\tVDEV_ALLOC_CLASS_LOGS\t\"logs\"\n\nstatic zpool_command_t *current_command;\nstatic zfs_type_t current_prop_type = (ZFS_TYPE_POOL | ZFS_TYPE_VDEV);\nstatic char history_str[HIS_MAX_RECORD_LEN];\nstatic boolean_t log_history = B_TRUE;\nstatic uint_t timestamp_fmt = NODATE;\n\nstatic const char *\nget_usage(zpool_help_t idx)\n{\n\tswitch (idx) {\n\tcase HELP_ADD:\n\t\treturn (gettext(\"\\tadd [-fgLnP] [-o property=value] \"\n\t\t    \"<pool> <vdev> ...\\n\"));\n\tcase HELP_ATTACH:\n\t\treturn (gettext(\"\\tattach [-fsw] [-o property=value] \"\n\t\t    \"<pool> <device> <new-device>\\n\"));\n\tcase HELP_CLEAR:\n\t\treturn (gettext(\"\\tclear [-nF] <pool> [device]\\n\"));\n\tcase HELP_CREATE:\n\t\treturn (gettext(\"\\tcreate [-fnd] [-o property=value] ... \\n\"\n\t\t    \"\\t    [-O file-system-property=value] ... \\n\"\n\t\t    \"\\t    [-m mountpoint] [-R root] <pool> <vdev> ...\\n\"));\n\tcase HELP_CHECKPOINT:\n\t\treturn (gettext(\"\\tcheckpoint [-d [-w]] <pool> ...\\n\"));\n\tcase HELP_DESTROY:\n\t\treturn (gettext(\"\\tdestroy [-f] <pool>\\n\"));\n\tcase HELP_DETACH:\n\t\treturn (gettext(\"\\tdetach <pool> <device>\\n\"));\n\tcase HELP_EXPORT:\n\t\treturn (gettext(\"\\texport [-af] <pool> ...\\n\"));\n\tcase HELP_HISTORY:\n\t\treturn (gettext(\"\\thistory [-il] [<pool>] ...\\n\"));\n\tcase HELP_IMPORT:\n\t\treturn (gettext(\"\\timport [-d dir] [-D]\\n\"\n\t\t    \"\\timport [-o mntopts] [-o property=value] ... \\n\"\n\t\t    \"\\t    [-d dir | -c cachefile] [-D] [-l] [-f] [-m] [-N] \"\n\t\t    \"[-R root] [-F [-n]] -a\\n\"\n\t\t    \"\\timport [-o mntopts] [-o property=value] ... \\n\"\n\t\t    \"\\t    [-d dir | -c cachefile] [-D] [-l] [-f] [-m] [-N] \"\n\t\t    \"[-R root] [-F [-n]]\\n\"\n\t\t    \"\\t    [--rewind-to-checkpoint] <pool | id> [newpool]\\n\"));\n\tcase HELP_IOSTAT:\n\t\treturn (gettext(\"\\tiostat [[[-c [script1,script2,...]\"\n\t\t    \"[-lq]]|[-rw]] [-T d | u] [-ghHLpPvy]\\n\"\n\t\t    \"\\t    [[pool ...]|[pool vdev ...]|[vdev ...]]\"\n\t\t    \" [[-n] interval [count]]\\n\"));\n\tcase HELP_LABELCLEAR:\n\t\treturn (gettext(\"\\tlabelclear [-f] <vdev>\\n\"));\n\tcase HELP_LIST:\n\t\treturn (gettext(\"\\tlist [-gHLpPv] [-o property[,...]] \"\n\t\t    \"[-T d|u] [pool] ... \\n\"\n\t\t    \"\\t    [interval [count]]\\n\"));\n\tcase HELP_OFFLINE:\n\t\treturn (gettext(\"\\toffline [-f] [-t] <pool> <device> ...\\n\"));\n\tcase HELP_ONLINE:\n\t\treturn (gettext(\"\\tonline [-e] <pool> <device> ...\\n\"));\n\tcase HELP_REPLACE:\n\t\treturn (gettext(\"\\treplace [-fsw] [-o property=value] \"\n\t\t    \"<pool> <device> [new-device]\\n\"));\n\tcase HELP_REMOVE:\n\t\treturn (gettext(\"\\tremove [-npsw] <pool> <device> ...\\n\"));\n\tcase HELP_REOPEN:\n\t\treturn (gettext(\"\\treopen [-n] <pool>\\n\"));\n\tcase HELP_INITIALIZE:\n\t\treturn (gettext(\"\\tinitialize [-c | -s | -u] [-w] <pool> \"\n\t\t    \"[<device> ...]\\n\"));\n\tcase HELP_SCRUB:\n\t\treturn (gettext(\"\\tscrub [-s | -p] [-w] [-e] <pool> ...\\n\"));\n\tcase HELP_RESILVER:\n\t\treturn (gettext(\"\\tresilver <pool> ...\\n\"));\n\tcase HELP_TRIM:\n\t\treturn (gettext(\"\\ttrim [-dw] [-r <rate>] [-c | -s] <pool> \"\n\t\t    \"[<device> ...]\\n\"));\n\tcase HELP_STATUS:\n\t\treturn (gettext(\"\\tstatus [-c [script1,script2,...]] \"\n\t\t    \"[-igLpPstvxD]  [-T d|u] [pool] ... \\n\"\n\t\t    \"\\t    [interval [count]]\\n\"));\n\tcase HELP_UPGRADE:\n\t\treturn (gettext(\"\\tupgrade\\n\"\n\t\t    \"\\tupgrade -v\\n\"\n\t\t    \"\\tupgrade [-V version] <-a | pool ...>\\n\"));\n\tcase HELP_EVENTS:\n\t\treturn (gettext(\"\\tevents [-vHf [pool] | -c]\\n\"));\n\tcase HELP_GET:\n\t\treturn (gettext(\"\\tget [-Hp] [-o \\\"all\\\" | field[,...]] \"\n\t\t    \"<\\\"all\\\" | property[,...]> <pool> ...\\n\"));\n\tcase HELP_SET:\n\t\treturn (gettext(\"\\tset <property=value> <pool>\\n\"\n\t\t    \"\\tset <vdev_property=value> <pool> <vdev>\\n\"));\n\tcase HELP_SPLIT:\n\t\treturn (gettext(\"\\tsplit [-gLnPl] [-R altroot] [-o mntopts]\\n\"\n\t\t    \"\\t    [-o property=value] <pool> <newpool> \"\n\t\t    \"[<device> ...]\\n\"));\n\tcase HELP_REGUID:\n\t\treturn (gettext(\"\\treguid <pool>\\n\"));\n\tcase HELP_SYNC:\n\t\treturn (gettext(\"\\tsync [pool] ...\\n\"));\n\tcase HELP_VERSION:\n\t\treturn (gettext(\"\\tversion\\n\"));\n\tcase HELP_WAIT:\n\t\treturn (gettext(\"\\twait [-Hp] [-T d|u] [-t <activity>[,...]] \"\n\t\t    \"<pool> [interval]\\n\"));\n\tdefault:\n\t\t__builtin_unreachable();\n\t}\n}\n\nstatic void\nzpool_collect_leaves(zpool_handle_t *zhp, nvlist_t *nvroot, nvlist_t *res)\n{\n\tuint_t children = 0;\n\tnvlist_t **child;\n\tuint_t i;\n\n\t(void) nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children);\n\n\tif (children == 0) {\n\t\tchar *path = zpool_vdev_name(g_zfs, zhp, nvroot,\n\t\t    VDEV_NAME_PATH);\n\n\t\tif (strcmp(path, VDEV_TYPE_INDIRECT) != 0 &&\n\t\t    strcmp(path, VDEV_TYPE_HOLE) != 0)\n\t\t\tfnvlist_add_boolean(res, path);\n\n\t\tfree(path);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < children; i++) {\n\t\tzpool_collect_leaves(zhp, child[i], res);\n\t}\n}\n\n \nstatic int\nprint_pool_prop_cb(int prop, void *cb)\n{\n\tFILE *fp = cb;\n\n\t(void) fprintf(fp, \"\\t%-19s  \", zpool_prop_to_name(prop));\n\n\tif (zpool_prop_readonly(prop))\n\t\t(void) fprintf(fp, \"  NO   \");\n\telse\n\t\t(void) fprintf(fp, \" YES   \");\n\n\tif (zpool_prop_values(prop) == NULL)\n\t\t(void) fprintf(fp, \"-\\n\");\n\telse\n\t\t(void) fprintf(fp, \"%s\\n\", zpool_prop_values(prop));\n\n\treturn (ZPROP_CONT);\n}\n\n \nstatic int\nprint_vdev_prop_cb(int prop, void *cb)\n{\n\tFILE *fp = cb;\n\n\t(void) fprintf(fp, \"\\t%-19s  \", vdev_prop_to_name(prop));\n\n\tif (vdev_prop_readonly(prop))\n\t\t(void) fprintf(fp, \"  NO   \");\n\telse\n\t\t(void) fprintf(fp, \" YES   \");\n\n\tif (vdev_prop_values(prop) == NULL)\n\t\t(void) fprintf(fp, \"-\\n\");\n\telse\n\t\t(void) fprintf(fp, \"%s\\n\", vdev_prop_values(prop));\n\n\treturn (ZPROP_CONT);\n}\n\n \nstatic __attribute__((noreturn)) void\nusage(boolean_t requested)\n{\n\tFILE *fp = requested ? stdout : stderr;\n\n\tif (current_command == NULL) {\n\t\tint i;\n\n\t\t(void) fprintf(fp, gettext(\"usage: zpool command args ...\\n\"));\n\t\t(void) fprintf(fp,\n\t\t    gettext(\"where 'command' is one of the following:\\n\\n\"));\n\n\t\tfor (i = 0; i < NCOMMAND; i++) {\n\t\t\tif (command_table[i].name == NULL)\n\t\t\t\t(void) fprintf(fp, \"\\n\");\n\t\t\telse\n\t\t\t\t(void) fprintf(fp, \"%s\",\n\t\t\t\t    get_usage(command_table[i].usage));\n\t\t}\n\n\t\t(void) fprintf(fp,\n\t\t    gettext(\"\\nFor further help on a command or topic, \"\n\t\t    \"run: %s\\n\"), \"zpool help [<topic>]\");\n\t} else {\n\t\t(void) fprintf(fp, gettext(\"usage:\\n\"));\n\t\t(void) fprintf(fp, \"%s\", get_usage(current_command->usage));\n\t}\n\n\tif (current_command != NULL &&\n\t    current_prop_type != (ZFS_TYPE_POOL | ZFS_TYPE_VDEV) &&\n\t    ((strcmp(current_command->name, \"set\") == 0) ||\n\t    (strcmp(current_command->name, \"get\") == 0) ||\n\t    (strcmp(current_command->name, \"list\") == 0))) {\n\n\t\t(void) fprintf(fp, \"%s\",\n\t\t    gettext(\"\\nthe following properties are supported:\\n\"));\n\n\t\t(void) fprintf(fp, \"\\n\\t%-19s  %s   %s\\n\\n\",\n\t\t    \"PROPERTY\", \"EDIT\", \"VALUES\");\n\n\t\t \n\t\tif (current_prop_type == ZFS_TYPE_POOL) {\n\t\t\t(void) zprop_iter(print_pool_prop_cb, fp, B_FALSE,\n\t\t\t    B_TRUE, current_prop_type);\n\n\t\t\t(void) fprintf(fp, \"\\t%-19s   \", \"feature@...\");\n\t\t\t(void) fprintf(fp, \"YES   \"\n\t\t\t    \"disabled | enabled | active\\n\");\n\n\t\t\t(void) fprintf(fp, gettext(\"\\nThe feature@ properties \"\n\t\t\t    \"must be appended with a feature name.\\n\"\n\t\t\t    \"See zpool-features(7).\\n\"));\n\t\t} else if (current_prop_type == ZFS_TYPE_VDEV) {\n\t\t\t(void) zprop_iter(print_vdev_prop_cb, fp, B_FALSE,\n\t\t\t    B_TRUE, current_prop_type);\n\t\t}\n\t}\n\n\t \n\tif (getenv(\"ZFS_ABORT\") != NULL) {\n\t\t(void) printf(\"dumping core by request\\n\");\n\t\tabort();\n\t}\n\n\texit(requested ? 0 : 2);\n}\n\n \nint\nzpool_do_initialize(int argc, char **argv)\n{\n\tint c;\n\tchar *poolname;\n\tzpool_handle_t *zhp;\n\tnvlist_t *vdevs;\n\tint err = 0;\n\tboolean_t wait = B_FALSE;\n\n\tstruct option long_options[] = {\n\t\t{\"cancel\",\tno_argument,\t\tNULL, 'c'},\n\t\t{\"suspend\",\tno_argument,\t\tNULL, 's'},\n\t\t{\"uninit\",\tno_argument,\t\tNULL, 'u'},\n\t\t{\"wait\",\tno_argument,\t\tNULL, 'w'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tpool_initialize_func_t cmd_type = POOL_INITIALIZE_START;\n\twhile ((c = getopt_long(argc, argv, \"csuw\", long_options,\n\t    NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (cmd_type != POOL_INITIALIZE_START &&\n\t\t\t    cmd_type != POOL_INITIALIZE_CANCEL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-c cannot be \"\n\t\t\t\t    \"combined with other options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tcmd_type = POOL_INITIALIZE_CANCEL;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (cmd_type != POOL_INITIALIZE_START &&\n\t\t\t    cmd_type != POOL_INITIALIZE_SUSPEND) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-s cannot be \"\n\t\t\t\t    \"combined with other options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tcmd_type = POOL_INITIALIZE_SUSPEND;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (cmd_type != POOL_INITIALIZE_START &&\n\t\t\t    cmd_type != POOL_INITIALIZE_UNINIT) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-u cannot be \"\n\t\t\t\t    \"combined with other options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tcmd_type = POOL_INITIALIZE_UNINIT;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twait = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tif (optopt != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%s'\\n\"),\n\t\t\t\t    argv[optind - 1]);\n\t\t\t}\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t\treturn (-1);\n\t}\n\n\tif (wait && (cmd_type != POOL_INITIALIZE_START)) {\n\t\t(void) fprintf(stderr, gettext(\"-w cannot be used with -c, -s\"\n\t\t    \"or -u\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\tzhp = zpool_open(g_zfs, poolname);\n\tif (zhp == NULL)\n\t\treturn (-1);\n\n\tvdevs = fnvlist_alloc();\n\tif (argc == 1) {\n\t\t \n\t\tnvlist_t *config = zpool_get_config(zhp, NULL);\n\t\tnvlist_t *nvroot = fnvlist_lookup_nvlist(config,\n\t\t    ZPOOL_CONFIG_VDEV_TREE);\n\t\tzpool_collect_leaves(zhp, nvroot, vdevs);\n\t} else {\n\t\tfor (int i = 1; i < argc; i++) {\n\t\t\tfnvlist_add_boolean(vdevs, argv[i]);\n\t\t}\n\t}\n\n\tif (wait)\n\t\terr = zpool_initialize_wait(zhp, cmd_type, vdevs);\n\telse\n\t\terr = zpool_initialize(zhp, cmd_type, vdevs);\n\n\tfnvlist_free(vdevs);\n\tzpool_close(zhp);\n\n\treturn (err);\n}\n\n \nstatic void\nprint_vdev_tree(zpool_handle_t *zhp, const char *name, nvlist_t *nv, int indent,\n    const char *match, int name_flags)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tchar *vname;\n\tboolean_t printed = B_FALSE;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\t\tif (name != NULL)\n\t\t\t(void) printf(\"\\t%*s%s\\n\", indent, \"\", name);\n\t\treturn;\n\t}\n\n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t is_log = B_FALSE, is_hole = B_FALSE;\n\t\tconst char *class = \"\";\n\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_HOLE,\n\t\t    &is_hole);\n\n\t\tif (is_hole == B_TRUE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &is_log);\n\t\tif (is_log)\n\t\t\tclass = VDEV_ALLOC_BIAS_LOG;\n\t\t(void) nvlist_lookup_string(child[c],\n\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, &class);\n\t\tif (strcmp(match, class) != 0)\n\t\t\tcontinue;\n\n\t\tif (!printed && name != NULL) {\n\t\t\t(void) printf(\"\\t%*s%s\\n\", indent, \"\", name);\n\t\t\tprinted = B_TRUE;\n\t\t}\n\t\tvname = zpool_vdev_name(g_zfs, zhp, child[c], name_flags);\n\t\tprint_vdev_tree(zhp, vname, child[c], indent + 2, \"\",\n\t\t    name_flags);\n\t\tfree(vname);\n\t}\n}\n\n \nstatic void\nprint_cache_list(nvlist_t *nv, int indent)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0 && children > 0) {\n\t\t(void) printf(\"\\t%*s%s\\n\", indent, \"\", \"cache\");\n\t} else {\n\t\treturn;\n\t}\n\tfor (c = 0; c < children; c++) {\n\t\tchar *vname;\n\n\t\tvname = zpool_vdev_name(g_zfs, NULL, child[c], 0);\n\t\t(void) printf(\"\\t%*s%s\\n\", indent + 2, \"\", vname);\n\t\tfree(vname);\n\t}\n}\n\n \nstatic void\nprint_spare_list(nvlist_t *nv, int indent)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0 && children > 0) {\n\t\t(void) printf(\"\\t%*s%s\\n\", indent, \"\", \"spares\");\n\t} else {\n\t\treturn;\n\t}\n\tfor (c = 0; c < children; c++) {\n\t\tchar *vname;\n\n\t\tvname = zpool_vdev_name(g_zfs, NULL, child[c], 0);\n\t\t(void) printf(\"\\t%*s%s\\n\", indent + 2, \"\", vname);\n\t\tfree(vname);\n\t}\n}\n\nstatic boolean_t\nprop_list_contains_feature(nvlist_t *proplist)\n{\n\tnvpair_t *nvp;\n\tfor (nvp = nvlist_next_nvpair(proplist, NULL); NULL != nvp;\n\t    nvp = nvlist_next_nvpair(proplist, nvp)) {\n\t\tif (zpool_prop_feature(nvpair_name(nvp)))\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic int\nadd_prop_list(const char *propname, const char *propval, nvlist_t **props,\n    boolean_t poolprop)\n{\n\tzpool_prop_t prop = ZPOOL_PROP_INVAL;\n\tnvlist_t *proplist;\n\tconst char *normnm;\n\tconst char *strval;\n\n\tif (*props == NULL &&\n\t    nvlist_alloc(props, NV_UNIQUE_NAME, 0) != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"internal error: out of memory\\n\"));\n\t\treturn (1);\n\t}\n\n\tproplist = *props;\n\n\tif (poolprop) {\n\t\tconst char *vname = zpool_prop_to_name(ZPOOL_PROP_VERSION);\n\t\tconst char *cname =\n\t\t    zpool_prop_to_name(ZPOOL_PROP_COMPATIBILITY);\n\n\t\tif ((prop = zpool_name_to_prop(propname)) == ZPOOL_PROP_INVAL &&\n\t\t    (!zpool_prop_feature(propname) &&\n\t\t    !zpool_prop_vdev(propname))) {\n\t\t\t(void) fprintf(stderr, gettext(\"property '%s' is \"\n\t\t\t    \"not a valid pool or vdev property\\n\"), propname);\n\t\t\treturn (2);\n\t\t}\n\n\t\t \n\t\tif ((prop == ZPOOL_PROP_INVAL && zpool_prop_feature(propname) &&\n\t\t    nvlist_exists(proplist, vname)) ||\n\t\t    (prop == ZPOOL_PROP_VERSION &&\n\t\t    prop_list_contains_feature(proplist))) {\n\t\t\t(void) fprintf(stderr, gettext(\"'feature@' and \"\n\t\t\t    \"'version' properties cannot be specified \"\n\t\t\t    \"together\\n\"));\n\t\t\treturn (2);\n\t\t}\n\n\t\t \n\t\tif ((prop == ZPOOL_PROP_COMPATIBILITY &&\n\t\t    strcmp(propval, ZPOOL_COMPAT_LEGACY) != 0 &&\n\t\t    nvlist_exists(proplist, vname)) ||\n\t\t    (prop == ZPOOL_PROP_VERSION &&\n\t\t    nvlist_exists(proplist, cname) &&\n\t\t    strcmp(fnvlist_lookup_string(proplist, cname),\n\t\t    ZPOOL_COMPAT_LEGACY) != 0)) {\n\t\t\t(void) fprintf(stderr, gettext(\"when 'version' is \"\n\t\t\t    \"specified, the 'compatibility' feature may only \"\n\t\t\t    \"be set to '\" ZPOOL_COMPAT_LEGACY \"'\\n\"));\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (zpool_prop_feature(propname) || zpool_prop_vdev(propname))\n\t\t\tnormnm = propname;\n\t\telse\n\t\t\tnormnm = zpool_prop_to_name(prop);\n\t} else {\n\t\tzfs_prop_t fsprop = zfs_name_to_prop(propname);\n\n\t\tif (zfs_prop_valid_for_type(fsprop, ZFS_TYPE_FILESYSTEM,\n\t\t    B_FALSE)) {\n\t\t\tnormnm = zfs_prop_to_name(fsprop);\n\t\t} else if (zfs_prop_user(propname) ||\n\t\t    zfs_prop_userquota(propname)) {\n\t\t\tnormnm = propname;\n\t\t} else {\n\t\t\t(void) fprintf(stderr, gettext(\"property '%s' is \"\n\t\t\t    \"not a valid filesystem property\\n\"), propname);\n\t\t\treturn (2);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_string(proplist, normnm, &strval) == 0 &&\n\t    prop != ZPOOL_PROP_CACHEFILE) {\n\t\t(void) fprintf(stderr, gettext(\"property '%s' \"\n\t\t    \"specified multiple times\\n\"), propname);\n\t\treturn (2);\n\t}\n\n\tif (nvlist_add_string(proplist, normnm, propval) != 0) {\n\t\t(void) fprintf(stderr, gettext(\"internal \"\n\t\t    \"error: out of memory\\n\"));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nadd_prop_list_default(const char *propname, const char *propval,\n    nvlist_t **props)\n{\n\tconst char *pval;\n\n\tif (nvlist_lookup_string(*props, propname, &pval) == 0)\n\t\treturn (0);\n\n\treturn (add_prop_list(propname, propval, props, B_TRUE));\n}\n\n \nint\nzpool_do_add(int argc, char **argv)\n{\n\tboolean_t force = B_FALSE;\n\tboolean_t dryrun = B_FALSE;\n\tint name_flags = 0;\n\tint c;\n\tnvlist_t *nvroot;\n\tchar *poolname;\n\tint ret;\n\tzpool_handle_t *zhp;\n\tnvlist_t *config;\n\tnvlist_t *props = NULL;\n\tchar *propval;\n\n\t \n\twhile ((c = getopt(argc, argv, \"fgLno:P\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tname_flags |= VDEV_NAME_GUID;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tname_flags |= VDEV_NAME_FOLLOW_LINKS;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((propval = strchr(optarg, '=')) == NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"missing \"\n\t\t\t\t    \"'=' for -o option\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\t*propval = '\\0';\n\t\t\tpropval++;\n\n\t\t\tif ((strcmp(optarg, ZPOOL_CONFIG_ASHIFT) != 0) ||\n\t\t\t    (add_prop_list(optarg, propval, &props, B_TRUE)))\n\t\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tname_flags |= VDEV_NAME_PATH;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing vdev specification\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\n\targc--;\n\targv++;\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL)\n\t\treturn (1);\n\n\tif ((config = zpool_get_config(zhp, NULL)) == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"pool '%s' is unavailable\\n\"),\n\t\t    poolname);\n\t\tzpool_close(zhp);\n\t\treturn (1);\n\t}\n\n\t \n\tif (!nvlist_exists(props, ZPOOL_CONFIG_ASHIFT)) {\n\t\tint intval;\n\t\tzprop_source_t src;\n\t\tchar strval[ZPOOL_MAXPROPLEN];\n\n\t\tintval = zpool_get_prop_int(zhp, ZPOOL_PROP_ASHIFT, &src);\n\t\tif (src != ZPROP_SRC_DEFAULT) {\n\t\t\t(void) sprintf(strval, \"%\" PRId32, intval);\n\t\t\tverify(add_prop_list(ZPOOL_CONFIG_ASHIFT, strval,\n\t\t\t    &props, B_TRUE) == 0);\n\t\t}\n\t}\n\n\t \n\tnvroot = make_root_vdev(zhp, props, force, !force, B_FALSE, dryrun,\n\t    argc, argv);\n\tif (nvroot == NULL) {\n\t\tzpool_close(zhp);\n\t\treturn (1);\n\t}\n\n\tif (dryrun) {\n\t\tnvlist_t *poolnvroot;\n\t\tnvlist_t **l2child, **sparechild;\n\t\tuint_t l2children, sparechildren, c;\n\t\tchar *vname;\n\t\tboolean_t hadcache = B_FALSE, hadspare = B_FALSE;\n\n\t\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &poolnvroot) == 0);\n\n\t\t(void) printf(gettext(\"would update '%s' to the following \"\n\t\t    \"configuration:\\n\\n\"), zpool_get_name(zhp));\n\n\t\t \n\t\tprint_vdev_tree(zhp, poolname, poolnvroot, 0, \"\",\n\t\t    name_flags | VDEV_NAME_TYPE_ID);\n\t\tprint_vdev_tree(zhp, NULL, nvroot, 0, \"\", name_flags);\n\n\t\t \n\t\tif (zfs_special_devs(poolnvroot, VDEV_ALLOC_BIAS_DEDUP)) {\n\t\t\tprint_vdev_tree(zhp, \"dedup\", poolnvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_DEDUP, name_flags);\n\t\t\tprint_vdev_tree(zhp, NULL, nvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_DEDUP, name_flags);\n\t\t} else if (zfs_special_devs(nvroot, VDEV_ALLOC_BIAS_DEDUP)) {\n\t\t\tprint_vdev_tree(zhp, \"dedup\", nvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_DEDUP, name_flags);\n\t\t}\n\n\t\tif (zfs_special_devs(poolnvroot, VDEV_ALLOC_BIAS_SPECIAL)) {\n\t\t\tprint_vdev_tree(zhp, \"special\", poolnvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_SPECIAL, name_flags);\n\t\t\tprint_vdev_tree(zhp, NULL, nvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_SPECIAL, name_flags);\n\t\t} else if (zfs_special_devs(nvroot, VDEV_ALLOC_BIAS_SPECIAL)) {\n\t\t\tprint_vdev_tree(zhp, \"special\", nvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_SPECIAL, name_flags);\n\t\t}\n\n\t\tif (num_logs(poolnvroot) > 0) {\n\t\t\tprint_vdev_tree(zhp, \"logs\", poolnvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_LOG, name_flags);\n\t\t\tprint_vdev_tree(zhp, NULL, nvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_LOG, name_flags);\n\t\t} else if (num_logs(nvroot) > 0) {\n\t\t\tprint_vdev_tree(zhp, \"logs\", nvroot, 0,\n\t\t\t    VDEV_ALLOC_BIAS_LOG, name_flags);\n\t\t}\n\n\t\t \n\t\tif (nvlist_lookup_nvlist_array(poolnvroot, ZPOOL_CONFIG_L2CACHE,\n\t\t    &l2child, &l2children) == 0 && l2children) {\n\t\t\thadcache = B_TRUE;\n\t\t\t(void) printf(gettext(\"\\tcache\\n\"));\n\t\t\tfor (c = 0; c < l2children; c++) {\n\t\t\t\tvname = zpool_vdev_name(g_zfs, NULL,\n\t\t\t\t    l2child[c], name_flags);\n\t\t\t\t(void) printf(\"\\t  %s\\n\", vname);\n\t\t\t\tfree(vname);\n\t\t\t}\n\t\t}\n\t\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_L2CACHE,\n\t\t    &l2child, &l2children) == 0 && l2children) {\n\t\t\tif (!hadcache)\n\t\t\t\t(void) printf(gettext(\"\\tcache\\n\"));\n\t\t\tfor (c = 0; c < l2children; c++) {\n\t\t\t\tvname = zpool_vdev_name(g_zfs, NULL,\n\t\t\t\t    l2child[c], name_flags);\n\t\t\t\t(void) printf(\"\\t  %s\\n\", vname);\n\t\t\t\tfree(vname);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (nvlist_lookup_nvlist_array(poolnvroot, ZPOOL_CONFIG_SPARES,\n\t\t    &sparechild, &sparechildren) == 0 && sparechildren > 0) {\n\t\t\thadspare = B_TRUE;\n\t\t\t(void) printf(gettext(\"\\tspares\\n\"));\n\t\t\tfor (c = 0; c < sparechildren; c++) {\n\t\t\t\tvname = zpool_vdev_name(g_zfs, NULL,\n\t\t\t\t    sparechild[c], name_flags);\n\t\t\t\t(void) printf(\"\\t  %s\\n\", vname);\n\t\t\t\tfree(vname);\n\t\t\t}\n\t\t}\n\t\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t\t    &sparechild, &sparechildren) == 0 && sparechildren > 0) {\n\t\t\tif (!hadspare)\n\t\t\t\t(void) printf(gettext(\"\\tspares\\n\"));\n\t\t\tfor (c = 0; c < sparechildren; c++) {\n\t\t\t\tvname = zpool_vdev_name(g_zfs, NULL,\n\t\t\t\t    sparechild[c], name_flags);\n\t\t\t\t(void) printf(\"\\t  %s\\n\", vname);\n\t\t\t\tfree(vname);\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t} else {\n\t\tret = (zpool_add(zhp, nvroot) != 0);\n\t}\n\n\tnvlist_free(props);\n\tnvlist_free(nvroot);\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_remove(int argc, char **argv)\n{\n\tchar *poolname;\n\tint i, ret = 0;\n\tzpool_handle_t *zhp = NULL;\n\tboolean_t stop = B_FALSE;\n\tint c;\n\tboolean_t noop = B_FALSE;\n\tboolean_t parsable = B_FALSE;\n\tboolean_t wait = B_FALSE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"npsw\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tnoop = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparsable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tstop = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twait = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL)\n\t\treturn (1);\n\n\tif (stop && noop) {\n\t\tzpool_close(zhp);\n\t\t(void) fprintf(stderr, gettext(\"stop request ignored\\n\"));\n\t\treturn (0);\n\t}\n\n\tif (stop) {\n\t\tif (argc > 1) {\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (zpool_vdev_remove_cancel(zhp) != 0)\n\t\t\tret = 1;\n\t\tif (wait) {\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option \"\n\t\t\t    \"combination: -w cannot be used with -s\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t} else {\n\t\tif (argc < 2) {\n\t\t\t(void) fprintf(stderr, gettext(\"missing device\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\tfor (i = 1; i < argc; i++) {\n\t\t\tif (noop) {\n\t\t\t\tuint64_t size;\n\n\t\t\t\tif (zpool_vdev_indirect_size(zhp, argv[i],\n\t\t\t\t    &size) != 0) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parsable) {\n\t\t\t\t\t(void) printf(\"%s %llu\\n\",\n\t\t\t\t\t    argv[i], (unsigned long long)size);\n\t\t\t\t} else {\n\t\t\t\t\tchar valstr[32];\n\t\t\t\t\tzfs_nicenum(size, valstr,\n\t\t\t\t\t    sizeof (valstr));\n\t\t\t\t\t(void) printf(\"Memory that will be \"\n\t\t\t\t\t    \"used after removing %s: %s\\n\",\n\t\t\t\t\t    argv[i], valstr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (zpool_vdev_remove(zhp, argv[i]) != 0)\n\t\t\t\t\tret = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ret == 0 && wait)\n\t\t\tret = zpool_wait(zhp, ZPOOL_WAIT_REMOVE);\n\t}\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\n \nstatic int\nvdev_is_active(char *vdev_path)\n{\n\tint fd;\n\tfd = open(vdev_path, O_EXCL);\n\tif (fd < 0) {\n\t\treturn (1);    \n\t}\n\n\tclose(fd);\n\treturn (0);    \n}\n\n \nint\nzpool_do_labelclear(int argc, char **argv)\n{\n\tchar vdev[MAXPATHLEN];\n\tchar *name = NULL;\n\tint c, fd = -1, ret = 0;\n\tnvlist_t *config;\n\tpool_state_t state;\n\tboolean_t inuse = B_FALSE;\n\tboolean_t force = B_FALSE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"f\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing vdev name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t(void) strlcpy(vdev, argv[0], sizeof (vdev));\n\n\t \n\tif ((fd = open(vdev, O_RDWR)) < 0) {\n\t\tint error;\n\t\tif (vdev[0] == '/') {\n\t\t\t(void) fprintf(stderr, gettext(\"failed to open \"\n\t\t\t    \"%s: %s\\n\"), vdev, strerror(errno));\n\t\t\treturn (1);\n\t\t}\n\n\t\terror = zfs_resolve_shortname(argv[0], vdev, MAXPATHLEN);\n\t\tif (error == 0 && zfs_dev_is_whole_disk(vdev)) {\n\t\t\tif (zfs_append_partition(vdev, MAXPATHLEN) == -1)\n\t\t\t\terror = ENOENT;\n\t\t}\n\n\t\tif (error || ((fd = open(vdev, O_RDWR)) < 0)) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t    \"failed to find device %s, try \"\n\t\t\t\t    \"specifying absolute path instead\\n\"),\n\t\t\t\t    argv[0]);\n\t\t\t\treturn (1);\n\t\t\t}\n\n\t\t\t(void) fprintf(stderr, gettext(\"failed to open %s:\"\n\t\t\t    \" %s\\n\"), vdev, strerror(errno));\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\t \n\tif ((zfs_dev_flush(fd) != 0) && (errno != ENOTTY))\n\t\t(void) fprintf(stderr, gettext(\"failed to invalidate \"\n\t\t    \"cache for %s: %s\\n\"), vdev, strerror(errno));\n\n\tif (zpool_read_label(fd, &config, NULL) != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"failed to read label from %s\\n\"), vdev);\n\t\tret = 1;\n\t\tgoto errout;\n\t}\n\tnvlist_free(config);\n\n\tret = zpool_in_use(g_zfs, fd, &state, &name, &inuse);\n\tif (ret != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"failed to check state for %s\\n\"), vdev);\n\t\tret = 1;\n\t\tgoto errout;\n\t}\n\n\tif (!inuse)\n\t\tgoto wipe_label;\n\n\tswitch (state) {\n\tdefault:\n\tcase POOL_STATE_ACTIVE:\n\tcase POOL_STATE_SPARE:\n\tcase POOL_STATE_L2CACHE:\n\t\t \n\t\tif (force && !vdev_is_active(vdev))\n\t\t\tbreak;\n\n\t\t(void) fprintf(stderr, gettext(\n\t\t    \"%s is a member (%s) of pool \\\"%s\\\"\"),\n\t\t    vdev, zpool_pool_state_to_name(state), name);\n\n\t\tif (force) {\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \". Offline the disk first to clear its label.\"));\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tret = 1;\n\t\tgoto errout;\n\n\tcase POOL_STATE_EXPORTED:\n\t\tif (force)\n\t\t\tbreak;\n\t\t(void) fprintf(stderr, gettext(\n\t\t    \"use '-f' to override the following error:\\n\"\n\t\t    \"%s is a member of exported pool \\\"%s\\\"\\n\"),\n\t\t    vdev, name);\n\t\tret = 1;\n\t\tgoto errout;\n\n\tcase POOL_STATE_POTENTIALLY_ACTIVE:\n\t\tif (force)\n\t\t\tbreak;\n\t\t(void) fprintf(stderr, gettext(\n\t\t    \"use '-f' to override the following error:\\n\"\n\t\t    \"%s is a member of potentially active pool \\\"%s\\\"\\n\"),\n\t\t    vdev, name);\n\t\tret = 1;\n\t\tgoto errout;\n\n\tcase POOL_STATE_DESTROYED:\n\t\t \n\t\tassert(0);\n\t\tbreak;\n\t}\n\nwipe_label:\n\tret = zpool_clear_label(fd);\n\tif (ret != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"failed to clear label for %s\\n\"), vdev);\n\t}\n\nerrout:\n\tfree(name);\n\t(void) close(fd);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_create(int argc, char **argv)\n{\n\tboolean_t force = B_FALSE;\n\tboolean_t dryrun = B_FALSE;\n\tboolean_t enable_pool_features = B_TRUE;\n\n\tint c;\n\tnvlist_t *nvroot = NULL;\n\tchar *poolname;\n\tchar *tname = NULL;\n\tint ret = 1;\n\tchar *altroot = NULL;\n\tchar *compat = NULL;\n\tchar *mountpoint = NULL;\n\tnvlist_t *fsprops = NULL;\n\tnvlist_t *props = NULL;\n\tchar *propval;\n\n\t \n\twhile ((c = getopt(argc, argv, \":fndR:m:o:O:t:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tenable_pool_features = B_FALSE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\taltroot = optarg;\n\t\t\tif (add_prop_list(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_ALTROOT), optarg, &props, B_TRUE))\n\t\t\t\tgoto errout;\n\t\t\tif (add_prop_list_default(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_CACHEFILE), \"none\", &props))\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\t \n\t\t\tmountpoint = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((propval = strchr(optarg, '=')) == NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"missing \"\n\t\t\t\t    \"'=' for -o option\\n\"));\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t*propval = '\\0';\n\t\t\tpropval++;\n\n\t\t\tif (add_prop_list(optarg, propval, &props, B_TRUE))\n\t\t\t\tgoto errout;\n\n\t\t\t \n\t\t\tif (zpool_name_to_prop(optarg) == ZPOOL_PROP_VERSION) {\n\t\t\t\tchar *end;\n\t\t\t\tu_longlong_t ver;\n\n\t\t\t\tver = strtoull(propval, &end, 10);\n\t\t\t\tif (*end == '\\0' &&\n\t\t\t\t    ver < SPA_VERSION_FEATURES) {\n\t\t\t\t\tenable_pool_features = B_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (zpool_name_to_prop(optarg) == ZPOOL_PROP_ALTROOT)\n\t\t\t\taltroot = propval;\n\t\t\tif (zpool_name_to_prop(optarg) ==\n\t\t\t    ZPOOL_PROP_COMPATIBILITY)\n\t\t\t\tcompat = propval;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif ((propval = strchr(optarg, '=')) == NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"missing \"\n\t\t\t\t    \"'=' for -O option\\n\"));\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t*propval = '\\0';\n\t\t\tpropval++;\n\n\t\t\t \n\t\t\tif (0 == strcmp(optarg,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_MOUNTPOINT))) {\n\t\t\t\tmountpoint = propval;\n\t\t\t} else if (add_prop_list(optarg, propval, &fsprops,\n\t\t\t    B_FALSE)) {\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t \n\t\t\tif (strchr(optarg, '/') != NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot create \"\n\t\t\t\t    \"'%s': invalid character '/' in temporary \"\n\t\t\t\t    \"name\\n\"), optarg);\n\t\t\t\t(void) fprintf(stderr, gettext(\"use 'zfs \"\n\t\t\t\t    \"create' to create a dataset\\n\"));\n\t\t\t\tgoto errout;\n\t\t\t}\n\n\t\t\tif (add_prop_list(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_TNAME), optarg, &props, B_TRUE))\n\t\t\t\tgoto errout;\n\t\t\tif (add_prop_list_default(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_CACHEFILE), \"none\", &props))\n\t\t\t\tgoto errout;\n\t\t\ttname = optarg;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tgoto badusage;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tgoto badusage;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tgoto badusage;\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing vdev specification\\n\"));\n\t\tgoto badusage;\n\t}\n\n\tpoolname = argv[0];\n\n\t \n\tif (strchr(poolname, '/') != NULL) {\n\t\t(void) fprintf(stderr, gettext(\"cannot create '%s': invalid \"\n\t\t    \"character '/' in pool name\\n\"), poolname);\n\t\t(void) fprintf(stderr, gettext(\"use 'zfs create' to \"\n\t\t    \"create a dataset\\n\"));\n\t\tgoto errout;\n\t}\n\n\t \n\tnvroot = make_root_vdev(NULL, props, force, !force, B_FALSE, dryrun,\n\t    argc - 1, argv + 1);\n\tif (nvroot == NULL)\n\t\tgoto errout;\n\n\t \n\tif (!zfs_allocatable_devs(nvroot)) {\n\t\t(void) fprintf(stderr, gettext(\"invalid vdev \"\n\t\t    \"specification: at least one toplevel vdev must be \"\n\t\t    \"specified\\n\"));\n\t\tgoto errout;\n\t}\n\n\tif (altroot != NULL && altroot[0] != '/') {\n\t\t(void) fprintf(stderr, gettext(\"invalid alternate root '%s': \"\n\t\t    \"must be an absolute path\\n\"), altroot);\n\t\tgoto errout;\n\t}\n\n\t \n\tif (mountpoint == NULL ||\n\t    (strcmp(mountpoint, ZFS_MOUNTPOINT_LEGACY) != 0 &&\n\t    strcmp(mountpoint, ZFS_MOUNTPOINT_NONE) != 0)) {\n\t\tchar buf[MAXPATHLEN];\n\t\tDIR *dirp;\n\n\t\tif (mountpoint && mountpoint[0] != '/') {\n\t\t\t(void) fprintf(stderr, gettext(\"invalid mountpoint \"\n\t\t\t    \"'%s': must be an absolute path, 'legacy', or \"\n\t\t\t    \"'none'\\n\"), mountpoint);\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (mountpoint == NULL) {\n\t\t\tif (altroot != NULL)\n\t\t\t\t(void) snprintf(buf, sizeof (buf), \"%s/%s\",\n\t\t\t\t    altroot, poolname);\n\t\t\telse\n\t\t\t\t(void) snprintf(buf, sizeof (buf), \"/%s\",\n\t\t\t\t    poolname);\n\t\t} else {\n\t\t\tif (altroot != NULL)\n\t\t\t\t(void) snprintf(buf, sizeof (buf), \"%s%s\",\n\t\t\t\t    altroot, mountpoint);\n\t\t\telse\n\t\t\t\t(void) snprintf(buf, sizeof (buf), \"%s\",\n\t\t\t\t    mountpoint);\n\t\t}\n\n\t\tif ((dirp = opendir(buf)) == NULL && errno != ENOENT) {\n\t\t\t(void) fprintf(stderr, gettext(\"mountpoint '%s' : \"\n\t\t\t    \"%s\\n\"), buf, strerror(errno));\n\t\t\t(void) fprintf(stderr, gettext(\"use '-m' \"\n\t\t\t    \"option to provide a different default\\n\"));\n\t\t\tgoto errout;\n\t\t} else if (dirp) {\n\t\t\tint count = 0;\n\n\t\t\twhile (count < 3 && readdir(dirp) != NULL)\n\t\t\t\tcount++;\n\t\t\t(void) closedir(dirp);\n\n\t\t\tif (count > 2) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"mountpoint \"\n\t\t\t\t    \"'%s' exists and is not empty\\n\"), buf);\n\t\t\t\t(void) fprintf(stderr, gettext(\"use '-m' \"\n\t\t\t\t    \"option to provide a \"\n\t\t\t\t    \"different default\\n\"));\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (mountpoint != NULL) {\n\t\tret = add_prop_list(zfs_prop_to_name(ZFS_PROP_MOUNTPOINT),\n\t\t    mountpoint, &fsprops, B_FALSE);\n\t\tif (ret != 0)\n\t\t\tgoto errout;\n\t}\n\n\tret = 1;\n\tif (dryrun) {\n\t\t \n\t\t(void) printf(gettext(\"would create '%s' with the \"\n\t\t    \"following layout:\\n\\n\"), poolname);\n\n\t\tprint_vdev_tree(NULL, poolname, nvroot, 0, \"\", 0);\n\t\tprint_vdev_tree(NULL, \"dedup\", nvroot, 0,\n\t\t    VDEV_ALLOC_BIAS_DEDUP, 0);\n\t\tprint_vdev_tree(NULL, \"special\", nvroot, 0,\n\t\t    VDEV_ALLOC_BIAS_SPECIAL, 0);\n\t\tprint_vdev_tree(NULL, \"logs\", nvroot, 0,\n\t\t    VDEV_ALLOC_BIAS_LOG, 0);\n\t\tprint_cache_list(nvroot, 0);\n\t\tprint_spare_list(nvroot, 0);\n\n\t\tret = 0;\n\t} else {\n\t\t \n\t\tboolean_t requested_features[SPA_FEATURES];\n\t\tif (zpool_do_load_compat(compat, requested_features) !=\n\t\t    ZPOOL_COMPATIBILITY_OK)\n\t\t\tgoto errout;\n\n\t\t \n\t\tfor (spa_feature_t i = 0; i < SPA_FEATURES; i++) {\n\t\t\tchar propname[MAXPATHLEN];\n\t\t\tconst char *propval;\n\t\t\tzfeature_info_t *feat = &spa_feature_table[i];\n\n\t\t\t(void) snprintf(propname, sizeof (propname),\n\t\t\t    \"feature@%s\", feat->fi_uname);\n\n\t\t\tif (!nvlist_lookup_string(props, propname, &propval)) {\n\t\t\t\tif (strcmp(propval,\n\t\t\t\t    ZFS_FEATURE_DISABLED) == 0) {\n\t\t\t\t\t(void) nvlist_remove_all(props,\n\t\t\t\t\t    propname);\n\t\t\t\t} else if (strcmp(propval,\n\t\t\t\t    ZFS_FEATURE_ENABLED) == 0 &&\n\t\t\t\t    !requested_features[i]) {\n\t\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t\t    \"Warning: feature \\\"%s\\\" enabled \"\n\t\t\t\t\t    \"but is not in specified \"\n\t\t\t\t\t    \"'compatibility' feature set.\\n\"),\n\t\t\t\t\t    feat->fi_uname);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t    enable_pool_features &&\n\t\t\t    feat->fi_zfs_mod_supported &&\n\t\t\t    requested_features[i]) {\n\t\t\t\tret = add_prop_list(propname,\n\t\t\t\t    ZFS_FEATURE_ENABLED, &props, B_TRUE);\n\t\t\t\tif (ret != 0)\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tret = 1;\n\t\tif (zpool_create(g_zfs, poolname,\n\t\t    nvroot, props, fsprops) == 0) {\n\t\t\tzfs_handle_t *pool = zfs_open(g_zfs,\n\t\t\t    tname ? tname : poolname, ZFS_TYPE_FILESYSTEM);\n\t\t\tif (pool != NULL) {\n\t\t\t\tif (zfs_mount(pool, NULL, 0) == 0) {\n\t\t\t\t\tret = zfs_share(pool, NULL);\n\t\t\t\t\tzfs_commit_shares(NULL);\n\t\t\t\t}\n\t\t\t\tzfs_close(pool);\n\t\t\t}\n\t\t} else if (libzfs_errno(g_zfs) == EZFS_INVALIDNAME) {\n\t\t\t(void) fprintf(stderr, gettext(\"pool name may have \"\n\t\t\t    \"been omitted\\n\"));\n\t\t}\n\t}\n\nerrout:\n\tnvlist_free(nvroot);\n\tnvlist_free(fsprops);\n\tnvlist_free(props);\n\treturn (ret);\nbadusage:\n\tnvlist_free(fsprops);\n\tnvlist_free(props);\n\tusage(B_FALSE);\n\treturn (2);\n}\n\n \nint\nzpool_do_destroy(int argc, char **argv)\n{\n\tboolean_t force = B_FALSE;\n\tint c;\n\tchar *pool;\n\tzpool_handle_t *zhp;\n\tint ret;\n\n\t \n\twhile ((c = getopt(argc, argv, \"f\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpool = argv[0];\n\n\tif ((zhp = zpool_open_canfail(g_zfs, pool)) == NULL) {\n\t\t \n\t\tif (strchr(pool, '/') != NULL)\n\t\t\t(void) fprintf(stderr, gettext(\"use 'zfs destroy' to \"\n\t\t\t    \"destroy a dataset\\n\"));\n\t\treturn (1);\n\t}\n\n\tif (zpool_disable_datasets(zhp, force) != 0) {\n\t\t(void) fprintf(stderr, gettext(\"could not destroy '%s': \"\n\t\t    \"could not unmount datasets\\n\"), zpool_get_name(zhp));\n\t\tzpool_close(zhp);\n\t\treturn (1);\n\t}\n\n\t \n\tlog_history = B_FALSE;\n\n\tret = (zpool_destroy(zhp, history_str) != 0);\n\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\ntypedef struct export_cbdata {\n\tboolean_t force;\n\tboolean_t hardforce;\n} export_cbdata_t;\n\n \nstatic int\nzpool_export_one(zpool_handle_t *zhp, void *data)\n{\n\texport_cbdata_t *cb = data;\n\n\tif (zpool_disable_datasets(zhp, cb->force) != 0)\n\t\treturn (1);\n\n\t \n\tlog_history = B_FALSE;\n\n\tif (cb->hardforce) {\n\t\tif (zpool_export_force(zhp, history_str) != 0)\n\t\t\treturn (1);\n\t} else if (zpool_export(zhp, cb->force, history_str) != 0) {\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_do_export(int argc, char **argv)\n{\n\texport_cbdata_t cb;\n\tboolean_t do_all = B_FALSE;\n\tboolean_t force = B_FALSE;\n\tboolean_t hardforce = B_FALSE;\n\tint c, ret;\n\n\t \n\twhile ((c = getopt(argc, argv, \"afF\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tdo_all = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\thardforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tcb.force = force;\n\tcb.hardforce = hardforce;\n\targc -= optind;\n\targv += optind;\n\n\tif (do_all) {\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\treturn (for_each_pool(argc, argv, B_TRUE, NULL,\n\t\t    ZFS_TYPE_POOL, B_FALSE, zpool_export_one, &cb));\n\t}\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tret = for_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, zpool_export_one, &cb);\n\n\treturn (ret);\n}\n\n \nstatic int\nmax_width(zpool_handle_t *zhp, nvlist_t *nv, int depth, int max,\n    int name_flags)\n{\n\tstatic const char *const subtypes[] =\n\t    {ZPOOL_CONFIG_SPARES, ZPOOL_CONFIG_L2CACHE, ZPOOL_CONFIG_CHILDREN};\n\n\tchar *name = zpool_vdev_name(g_zfs, zhp, nv, name_flags);\n\tmax = MAX(strlen(name) + depth, max);\n\tfree(name);\n\n\tnvlist_t **child;\n\tuint_t children;\n\tfor (size_t i = 0; i < ARRAY_SIZE(subtypes); ++i)\n\t\tif (nvlist_lookup_nvlist_array(nv, subtypes[i],\n\t\t    &child, &children) == 0)\n\t\t\tfor (uint_t c = 0; c < children; ++c)\n\t\t\t\tmax = MAX(max_width(zhp, child[c], depth + 2,\n\t\t\t\t    max, name_flags), max);\n\n\treturn (max);\n}\n\ntypedef struct spare_cbdata {\n\tuint64_t\tcb_guid;\n\tzpool_handle_t\t*cb_zhp;\n} spare_cbdata_t;\n\nstatic boolean_t\nfind_vdev(nvlist_t *nv, uint64_t search)\n{\n\tuint64_t guid;\n\tnvlist_t **child;\n\tuint_t c, children;\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) == 0 &&\n\t    search == guid)\n\t\treturn (B_TRUE);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tif (find_vdev(child[c], search))\n\t\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic int\nfind_spare(zpool_handle_t *zhp, void *data)\n{\n\tspare_cbdata_t *cbp = data;\n\tnvlist_t *config, *nvroot;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\n\tif (find_vdev(nvroot, cbp->cb_guid)) {\n\t\tcbp->cb_zhp = zhp;\n\t\treturn (1);\n\t}\n\n\tzpool_close(zhp);\n\treturn (0);\n}\n\ntypedef struct status_cbdata {\n\tint\t\tcb_count;\n\tint\t\tcb_name_flags;\n\tint\t\tcb_namewidth;\n\tboolean_t\tcb_allpools;\n\tboolean_t\tcb_verbose;\n\tboolean_t\tcb_literal;\n\tboolean_t\tcb_explain;\n\tboolean_t\tcb_first;\n\tboolean_t\tcb_dedup_stats;\n\tboolean_t\tcb_print_status;\n\tboolean_t\tcb_print_slow_ios;\n\tboolean_t\tcb_print_vdev_init;\n\tboolean_t\tcb_print_vdev_trim;\n\tvdev_cmd_data_list_t\t*vcdl;\n} status_cbdata_t;\n\n \nstatic boolean_t\nis_blank_str(const char *str)\n{\n\tfor (; str != NULL && *str != '\\0'; ++str)\n\t\tif (!isblank(*str))\n\t\t\treturn (B_FALSE);\n\treturn (B_TRUE);\n}\n\n \nstatic void\nzpool_print_cmd(vdev_cmd_data_list_t *vcdl, const char *pool, const char *path)\n{\n\tvdev_cmd_data_t *data;\n\tint i, j;\n\tconst char *val;\n\n\tfor (i = 0; i < vcdl->count; i++) {\n\t\tif ((strcmp(vcdl->data[i].path, path) != 0) ||\n\t\t    (strcmp(vcdl->data[i].pool, pool) != 0)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tdata = &vcdl->data[i];\n\t\t \n\t\tfor (j = 0; j < vcdl->uniq_cols_cnt; j++) {\n\t\t\tval = NULL;\n\t\t\t \n\t\t\tfor (int k = 0; k < data->cols_cnt; k++) {\n\t\t\t\tif (strcmp(data->cols[k],\n\t\t\t\t    vcdl->uniq_cols[j]) == 0) {\n\t\t\t\t\t \n\t\t\t\t\tval = data->lines[k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (val == NULL || is_blank_str(val))\n\t\t\t\tval = \"-\";\n\n\t\t\tprintf(\"%*s\", vcdl->uniq_cols_width[j], val);\n\t\t\tif (j < vcdl->uniq_cols_cnt - 1)\n\t\t\t\tfputs(\"  \", stdout);\n\t\t}\n\n\t\t \n\t\tfor (j = data->cols_cnt; j < data->lines_cnt; j++) {\n\t\t\t \n\t\t\tif (vcdl->uniq_cols_cnt > 0)\n\t\t\t\tfputs(\"  \", stdout);\n\n\t\t\tval = data->lines[j];\n\t\t\tfputs(val ?: \"\", stdout);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nprint_status_initialize(vdev_stat_t *vs, boolean_t verbose)\n{\n\tif (verbose) {\n\t\tif ((vs->vs_initialize_state == VDEV_INITIALIZE_ACTIVE ||\n\t\t    vs->vs_initialize_state == VDEV_INITIALIZE_SUSPENDED ||\n\t\t    vs->vs_initialize_state == VDEV_INITIALIZE_COMPLETE) &&\n\t\t    !vs->vs_scan_removing) {\n\t\t\tchar zbuf[1024];\n\t\t\tchar tbuf[256];\n\t\t\tstruct tm zaction_ts;\n\n\t\t\ttime_t t = vs->vs_initialize_action_time;\n\t\t\tint initialize_pct = 100;\n\t\t\tif (vs->vs_initialize_state !=\n\t\t\t    VDEV_INITIALIZE_COMPLETE) {\n\t\t\t\tinitialize_pct = (vs->vs_initialize_bytes_done *\n\t\t\t\t    100 / (vs->vs_initialize_bytes_est + 1));\n\t\t\t}\n\n\t\t\t(void) localtime_r(&t, &zaction_ts);\n\t\t\t(void) strftime(tbuf, sizeof (tbuf), \"%c\", &zaction_ts);\n\n\t\t\tswitch (vs->vs_initialize_state) {\n\t\t\tcase VDEV_INITIALIZE_SUSPENDED:\n\t\t\t\t(void) snprintf(zbuf, sizeof (zbuf), \", %s %s\",\n\t\t\t\t    gettext(\"suspended, started at\"), tbuf);\n\t\t\t\tbreak;\n\t\t\tcase VDEV_INITIALIZE_ACTIVE:\n\t\t\t\t(void) snprintf(zbuf, sizeof (zbuf), \", %s %s\",\n\t\t\t\t    gettext(\"started at\"), tbuf);\n\t\t\t\tbreak;\n\t\t\tcase VDEV_INITIALIZE_COMPLETE:\n\t\t\t\t(void) snprintf(zbuf, sizeof (zbuf), \", %s %s\",\n\t\t\t\t    gettext(\"completed at\"), tbuf);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t(void) printf(gettext(\"  (%d%% initialized%s)\"),\n\t\t\t    initialize_pct, zbuf);\n\t\t} else {\n\t\t\t(void) printf(gettext(\"  (uninitialized)\"));\n\t\t}\n\t} else if (vs->vs_initialize_state == VDEV_INITIALIZE_ACTIVE) {\n\t\t(void) printf(gettext(\"  (initializing)\"));\n\t}\n}\n\n \nstatic void\nprint_status_trim(vdev_stat_t *vs, boolean_t verbose)\n{\n\tif (verbose) {\n\t\tif ((vs->vs_trim_state == VDEV_TRIM_ACTIVE ||\n\t\t    vs->vs_trim_state == VDEV_TRIM_SUSPENDED ||\n\t\t    vs->vs_trim_state == VDEV_TRIM_COMPLETE) &&\n\t\t    !vs->vs_scan_removing) {\n\t\t\tchar zbuf[1024];\n\t\t\tchar tbuf[256];\n\t\t\tstruct tm zaction_ts;\n\n\t\t\ttime_t t = vs->vs_trim_action_time;\n\t\t\tint trim_pct = 100;\n\t\t\tif (vs->vs_trim_state != VDEV_TRIM_COMPLETE) {\n\t\t\t\ttrim_pct = (vs->vs_trim_bytes_done *\n\t\t\t\t    100 / (vs->vs_trim_bytes_est + 1));\n\t\t\t}\n\n\t\t\t(void) localtime_r(&t, &zaction_ts);\n\t\t\t(void) strftime(tbuf, sizeof (tbuf), \"%c\", &zaction_ts);\n\n\t\t\tswitch (vs->vs_trim_state) {\n\t\t\tcase VDEV_TRIM_SUSPENDED:\n\t\t\t\t(void) snprintf(zbuf, sizeof (zbuf), \", %s %s\",\n\t\t\t\t    gettext(\"suspended, started at\"), tbuf);\n\t\t\t\tbreak;\n\t\t\tcase VDEV_TRIM_ACTIVE:\n\t\t\t\t(void) snprintf(zbuf, sizeof (zbuf), \", %s %s\",\n\t\t\t\t    gettext(\"started at\"), tbuf);\n\t\t\t\tbreak;\n\t\t\tcase VDEV_TRIM_COMPLETE:\n\t\t\t\t(void) snprintf(zbuf, sizeof (zbuf), \", %s %s\",\n\t\t\t\t    gettext(\"completed at\"), tbuf);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t(void) printf(gettext(\"  (%d%% trimmed%s)\"),\n\t\t\t    trim_pct, zbuf);\n\t\t} else if (vs->vs_trim_notsup) {\n\t\t\t(void) printf(gettext(\"  (trim unsupported)\"));\n\t\t} else {\n\t\t\t(void) printf(gettext(\"  (untrimmed)\"));\n\t\t}\n\t} else if (vs->vs_trim_state == VDEV_TRIM_ACTIVE) {\n\t\t(void) printf(gettext(\"  (trimming)\"));\n\t}\n}\n\n \nstatic const char *\nhealth_str_to_color(const char *health)\n{\n\tif (strcmp(health, gettext(\"FAULTED\")) == 0 ||\n\t    strcmp(health, gettext(\"SUSPENDED\")) == 0 ||\n\t    strcmp(health, gettext(\"UNAVAIL\")) == 0) {\n\t\treturn (ANSI_RED);\n\t}\n\n\tif (strcmp(health, gettext(\"OFFLINE\")) == 0 ||\n\t    strcmp(health, gettext(\"DEGRADED\")) == 0 ||\n\t    strcmp(health, gettext(\"REMOVED\")) == 0) {\n\t\treturn (ANSI_YELLOW);\n\t}\n\n\treturn (NULL);\n}\n\n \nstatic void\nprint_status_config(zpool_handle_t *zhp, status_cbdata_t *cb, const char *name,\n    nvlist_t *nv, int depth, boolean_t isspare, vdev_rebuild_stat_t *vrs)\n{\n\tnvlist_t **child, *root;\n\tuint_t c, i, vsc, children;\n\tpool_scan_stat_t *ps = NULL;\n\tvdev_stat_t *vs;\n\tchar rbuf[6], wbuf[6], cbuf[6];\n\tchar *vname;\n\tuint64_t notpresent;\n\tspare_cbdata_t spare_cb;\n\tconst char *state;\n\tconst char *type;\n\tconst char *path = NULL;\n\tconst char *rcolor = NULL, *wcolor = NULL, *ccolor = NULL;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\tchildren = 0;\n\n\tverify(nvlist_lookup_uint64_array(nv, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &vsc) == 0);\n\n\tverify(nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) == 0);\n\n\tif (strcmp(type, VDEV_TYPE_INDIRECT) == 0)\n\t\treturn;\n\n\tstate = zpool_state_to_name(vs->vs_state, vs->vs_aux);\n\n\tif (isspare) {\n\t\t \n\t\tif (vs->vs_aux == VDEV_AUX_SPARED)\n\t\t\tstate = gettext(\"INUSE\");\n\t\telse if (vs->vs_state == VDEV_STATE_HEALTHY)\n\t\t\tstate = gettext(\"AVAIL\");\n\t}\n\n\tprintf_color(health_str_to_color(state),\n\t    \"\\t%*s%-*s  %-8s\", depth, \"\", cb->cb_namewidth - depth,\n\t    name, state);\n\n\tif (!isspare) {\n\t\tif (vs->vs_read_errors)\n\t\t\trcolor = ANSI_RED;\n\n\t\tif (vs->vs_write_errors)\n\t\t\twcolor = ANSI_RED;\n\n\t\tif (vs->vs_checksum_errors)\n\t\t\tccolor = ANSI_RED;\n\n\t\tif (cb->cb_literal) {\n\t\t\tfputc(' ', stdout);\n\t\t\tprintf_color(rcolor, \"%5llu\",\n\t\t\t    (u_longlong_t)vs->vs_read_errors);\n\t\t\tfputc(' ', stdout);\n\t\t\tprintf_color(wcolor, \"%5llu\",\n\t\t\t    (u_longlong_t)vs->vs_write_errors);\n\t\t\tfputc(' ', stdout);\n\t\t\tprintf_color(ccolor, \"%5llu\",\n\t\t\t    (u_longlong_t)vs->vs_checksum_errors);\n\t\t} else {\n\t\t\tzfs_nicenum(vs->vs_read_errors, rbuf, sizeof (rbuf));\n\t\t\tzfs_nicenum(vs->vs_write_errors, wbuf, sizeof (wbuf));\n\t\t\tzfs_nicenum(vs->vs_checksum_errors, cbuf,\n\t\t\t    sizeof (cbuf));\n\t\t\tfputc(' ', stdout);\n\t\t\tprintf_color(rcolor, \"%5s\", rbuf);\n\t\t\tfputc(' ', stdout);\n\t\t\tprintf_color(wcolor, \"%5s\", wbuf);\n\t\t\tfputc(' ', stdout);\n\t\t\tprintf_color(ccolor, \"%5s\", cbuf);\n\t\t}\n\t\tif (cb->cb_print_slow_ios) {\n\t\t\tif (children == 0)  {\n\t\t\t\t \n\t\t\t\tzfs_nicenum(vs->vs_slow_ios, rbuf,\n\t\t\t\t    sizeof (rbuf));\n\t\t\t} else {\n\t\t\t\tsnprintf(rbuf, sizeof (rbuf), \"-\");\n\t\t\t}\n\n\t\t\tif (cb->cb_literal)\n\t\t\t\tprintf(\" %5llu\", (u_longlong_t)vs->vs_slow_ios);\n\t\t\telse\n\t\t\t\tprintf(\" %5s\", rbuf);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NOT_PRESENT,\n\t    &notpresent) == 0) {\n\t\tverify(nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) == 0);\n\t\t(void) printf(\"  %s %s\", gettext(\"was\"), path);\n\t} else if (vs->vs_aux != 0) {\n\t\t(void) printf(\"  \");\n\t\tcolor_start(ANSI_RED);\n\t\tswitch (vs->vs_aux) {\n\t\tcase VDEV_AUX_OPEN_FAILED:\n\t\t\t(void) printf(gettext(\"cannot open\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_BAD_GUID_SUM:\n\t\t\t(void) printf(gettext(\"missing device\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_NO_REPLICAS:\n\t\t\t(void) printf(gettext(\"insufficient replicas\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_VERSION_NEWER:\n\t\t\t(void) printf(gettext(\"newer version\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_UNSUP_FEAT:\n\t\t\t(void) printf(gettext(\"unsupported feature(s)\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_ASHIFT_TOO_BIG:\n\t\t\t(void) printf(gettext(\"unsupported minimum blocksize\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_SPARED:\n\t\t\tverify(nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID,\n\t\t\t    &spare_cb.cb_guid) == 0);\n\t\t\tif (zpool_iter(g_zfs, find_spare, &spare_cb) == 1) {\n\t\t\t\tif (strcmp(zpool_get_name(spare_cb.cb_zhp),\n\t\t\t\t    zpool_get_name(zhp)) == 0)\n\t\t\t\t\t(void) printf(gettext(\"currently in \"\n\t\t\t\t\t    \"use\"));\n\t\t\t\telse\n\t\t\t\t\t(void) printf(gettext(\"in use by \"\n\t\t\t\t\t    \"pool '%s'\"),\n\t\t\t\t\t    zpool_get_name(spare_cb.cb_zhp));\n\t\t\t\tzpool_close(spare_cb.cb_zhp);\n\t\t\t} else {\n\t\t\t\t(void) printf(gettext(\"currently in use\"));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_ERR_EXCEEDED:\n\t\t\t(void) printf(gettext(\"too many errors\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_IO_FAILURE:\n\t\t\t(void) printf(gettext(\"experienced I/O failures\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_BAD_LOG:\n\t\t\t(void) printf(gettext(\"bad intent log\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_EXTERNAL:\n\t\t\t(void) printf(gettext(\"external device fault\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_SPLIT_POOL:\n\t\t\t(void) printf(gettext(\"split into new pool\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_ACTIVE:\n\t\t\t(void) printf(gettext(\"currently in use\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_CHILDREN_OFFLINE:\n\t\t\t(void) printf(gettext(\"all children offline\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_BAD_LABEL:\n\t\t\t(void) printf(gettext(\"invalid label\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) printf(gettext(\"corrupted data\"));\n\t\t\tbreak;\n\t\t}\n\t\tcolor_end();\n\t} else if (children == 0 && !isspare &&\n\t    getenv(\"ZPOOL_STATUS_NON_NATIVE_ASHIFT_IGNORE\") == NULL &&\n\t    VDEV_STAT_VALID(vs_physical_ashift, vsc) &&\n\t    vs->vs_configured_ashift < vs->vs_physical_ashift) {\n\t\t(void) printf(\n\t\t    gettext(\"  block size: %dB configured, %dB native\"),\n\t\t    1 << vs->vs_configured_ashift, 1 << vs->vs_physical_ashift);\n\t}\n\n\tif (vs->vs_scan_removing != 0) {\n\t\t(void) printf(gettext(\"  (removing)\"));\n\t} else if (VDEV_STAT_VALID(vs_noalloc, vsc) && vs->vs_noalloc != 0) {\n\t\t(void) printf(gettext(\"  (non-allocating)\"));\n\t}\n\n\t \n\troot = fnvlist_lookup_nvlist(zpool_get_config(zhp, NULL),\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\t(void) nvlist_lookup_uint64_array(root, ZPOOL_CONFIG_SCAN_STATS,\n\t    (uint64_t **)&ps, &c);\n\n\t \n\tif (ps != NULL && ps->pss_state == DSS_SCANNING && children == 0 &&\n\t    vs->vs_state == VDEV_STATE_HEALTHY) {\n\t\tif (vs->vs_scan_processed != 0) {\n\t\t\t(void) printf(gettext(\"  (%s)\"),\n\t\t\t    (ps->pss_func == POOL_SCAN_RESILVER) ?\n\t\t\t    \"resilvering\" : \"repairing\");\n\t\t} else if (vs->vs_resilver_deferred) {\n\t\t\t(void) printf(gettext(\"  (awaiting resilver)\"));\n\t\t}\n\t}\n\n\t \n\tif (vrs != NULL && vrs->vrs_state == VDEV_REBUILD_ACTIVE &&\n\t    children == 0 && vs->vs_state == VDEV_STATE_HEALTHY) {\n\t\tif (vs->vs_rebuild_processed != 0) {\n\t\t\t(void) printf(gettext(\"  (resilvering)\"));\n\t\t}\n\t}\n\n\tif (cb->vcdl != NULL) {\n\t\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) == 0) {\n\t\t\tprintf(\"  \");\n\t\t\tzpool_print_cmd(cb->vcdl, zpool_get_name(zhp), path);\n\t\t}\n\t}\n\n\t \n\tif (children == 0) {\n\t\tprint_status_initialize(vs, cb->cb_print_vdev_init);\n\t\tprint_status_trim(vs, cb->cb_print_vdev_trim);\n\t}\n\n\t(void) printf(\"\\n\");\n\n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t islog = B_FALSE, ishole = B_FALSE;\n\n\t\t \n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &islog);\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_HOLE,\n\t\t    &ishole);\n\t\tif (islog || ishole)\n\t\t\tcontinue;\n\t\t \n\t\tif (nvlist_exists(child[c], ZPOOL_CONFIG_ALLOCATION_BIAS))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vrs == NULL) {\n\t\t\t(void) nvlist_lookup_uint64_array(nv,\n\t\t\t    ZPOOL_CONFIG_REBUILD_STATS,\n\t\t\t    (uint64_t **)&vrs, &i);\n\t\t}\n\n\t\tvname = zpool_vdev_name(g_zfs, zhp, child[c],\n\t\t    cb->cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\tprint_status_config(zhp, cb, vname, child[c], depth + 2,\n\t\t    isspare, vrs);\n\t\tfree(vname);\n\t}\n}\n\n \nstatic void\nprint_import_config(status_cbdata_t *cb, const char *name, nvlist_t *nv,\n    int depth)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tvdev_stat_t *vs;\n\tconst char *type;\n\tchar *vname;\n\n\tverify(nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) == 0);\n\tif (strcmp(type, VDEV_TYPE_MISSING) == 0 ||\n\t    strcmp(type, VDEV_TYPE_HOLE) == 0)\n\t\treturn;\n\n\tverify(nvlist_lookup_uint64_array(nv, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\n\t(void) printf(\"\\t%*s%-*s\", depth, \"\", cb->cb_namewidth - depth, name);\n\t(void) printf(\"  %s\", zpool_state_to_name(vs->vs_state, vs->vs_aux));\n\n\tif (vs->vs_aux != 0) {\n\t\t(void) printf(\"  \");\n\n\t\tswitch (vs->vs_aux) {\n\t\tcase VDEV_AUX_OPEN_FAILED:\n\t\t\t(void) printf(gettext(\"cannot open\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_BAD_GUID_SUM:\n\t\t\t(void) printf(gettext(\"missing device\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_NO_REPLICAS:\n\t\t\t(void) printf(gettext(\"insufficient replicas\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_VERSION_NEWER:\n\t\t\t(void) printf(gettext(\"newer version\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_UNSUP_FEAT:\n\t\t\t(void) printf(gettext(\"unsupported feature(s)\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_ERR_EXCEEDED:\n\t\t\t(void) printf(gettext(\"too many errors\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_ACTIVE:\n\t\t\t(void) printf(gettext(\"currently in use\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_CHILDREN_OFFLINE:\n\t\t\t(void) printf(gettext(\"all children offline\"));\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_BAD_LABEL:\n\t\t\t(void) printf(gettext(\"invalid label\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void) printf(gettext(\"corrupted data\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\t(void) printf(\"\\n\");\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\treturn;\n\n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t is_log = B_FALSE;\n\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &is_log);\n\t\tif (is_log)\n\t\t\tcontinue;\n\t\tif (nvlist_exists(child[c], ZPOOL_CONFIG_ALLOCATION_BIAS))\n\t\t\tcontinue;\n\n\t\tvname = zpool_vdev_name(g_zfs, NULL, child[c],\n\t\t    cb->cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\tprint_import_config(cb, vname, child[c], depth + 2);\n\t\tfree(vname);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0) {\n\t\t(void) printf(gettext(\"\\tcache\\n\"));\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tvname = zpool_vdev_name(g_zfs, NULL, child[c],\n\t\t\t    cb->cb_name_flags);\n\t\t\t(void) printf(\"\\t  %s\\n\", vname);\n\t\t\tfree(vname);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0) {\n\t\t(void) printf(gettext(\"\\tspares\\n\"));\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tvname = zpool_vdev_name(g_zfs, NULL, child[c],\n\t\t\t    cb->cb_name_flags);\n\t\t\t(void) printf(\"\\t  %s\\n\", vname);\n\t\t\tfree(vname);\n\t\t}\n\t}\n}\n\n \nstatic void\nprint_class_vdevs(zpool_handle_t *zhp, status_cbdata_t *cb, nvlist_t *nv,\n    const char *class)\n{\n\tuint_t c, children;\n\tnvlist_t **child;\n\tboolean_t printed = B_FALSE;\n\n\tassert(zhp != NULL || !cb->cb_verbose);\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) != 0)\n\t\treturn;\n\n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t is_log = B_FALSE;\n\t\tconst char *bias = NULL;\n\t\tconst char *type = NULL;\n\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &is_log);\n\n\t\tif (is_log) {\n\t\t\tbias = (char *)VDEV_ALLOC_CLASS_LOGS;\n\t\t} else {\n\t\t\t(void) nvlist_lookup_string(child[c],\n\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, &bias);\n\t\t\t(void) nvlist_lookup_string(child[c],\n\t\t\t    ZPOOL_CONFIG_TYPE, &type);\n\t\t}\n\n\t\tif (bias == NULL || strcmp(bias, class) != 0)\n\t\t\tcontinue;\n\t\tif (!is_log && strcmp(type, VDEV_TYPE_INDIRECT) == 0)\n\t\t\tcontinue;\n\n\t\tif (!printed) {\n\t\t\t(void) printf(\"\\t%s\\t\\n\", gettext(class));\n\t\t\tprinted = B_TRUE;\n\t\t}\n\n\t\tchar *name = zpool_vdev_name(g_zfs, zhp, child[c],\n\t\t    cb->cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\tif (cb->cb_print_status)\n\t\t\tprint_status_config(zhp, cb, name, child[c], 2,\n\t\t\t    B_FALSE, NULL);\n\t\telse\n\t\t\tprint_import_config(cb, name, child[c], 2);\n\t\tfree(name);\n\t}\n}\n\n \nstatic int\nshow_import(nvlist_t *config, boolean_t report_error)\n{\n\tuint64_t pool_state;\n\tvdev_stat_t *vs;\n\tconst char *name;\n\tuint64_t guid;\n\tuint64_t hostid = 0;\n\tconst char *msgid;\n\tconst char *hostname = \"unknown\";\n\tnvlist_t *nvroot, *nvinfo;\n\tzpool_status_t reason;\n\tzpool_errata_t errata;\n\tconst char *health;\n\tuint_t vsc;\n\tconst char *comment;\n\tstatus_cbdata_t cb = { 0 };\n\n\tverify(nvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME,\n\t    &name) == 0);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t    &guid) == 0);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE,\n\t    &pool_state) == 0);\n\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\n\tverify(nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &vsc) == 0);\n\thealth = zpool_state_to_name(vs->vs_state, vs->vs_aux);\n\n\treason = zpool_import_status(config, &msgid, &errata);\n\n\t \n\tif (reason != ZPOOL_STATUS_OK && !report_error)\n\t\treturn (reason);\n\n\t(void) printf(gettext(\"   pool: %s\\n\"), name);\n\t(void) printf(gettext(\"     id: %llu\\n\"), (u_longlong_t)guid);\n\t(void) printf(gettext(\"  state: %s\"), health);\n\tif (pool_state == POOL_STATE_DESTROYED)\n\t\t(void) printf(gettext(\" (DESTROYED)\"));\n\t(void) printf(\"\\n\");\n\n\tswitch (reason) {\n\tcase ZPOOL_STATUS_MISSING_DEV_R:\n\tcase ZPOOL_STATUS_MISSING_DEV_NR:\n\tcase ZPOOL_STATUS_BAD_GUID_SUM:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices are \"\n\t\t    \"missing from the system.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_LABEL_R:\n\tcase ZPOOL_STATUS_CORRUPT_LABEL_NR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices contains\"\n\t\t    \" corrupted data.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_DATA:\n\t\t(void) printf(\n\t\t    gettext(\" status: The pool data is corrupted.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_OFFLINE_DEV:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices \"\n\t\t    \"are offlined.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_POOL:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool metadata is \"\n\t\t    \"corrupted.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_VERSION_OLDER:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool is formatted using \"\n\t\t    \"a legacy on-disk version.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_VERSION_NEWER:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool is formatted using \"\n\t\t    \"an incompatible version.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_FEAT_DISABLED:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Some supported \"\n\t\t    \"features are not enabled on the pool.\\n\\t\"\n\t\t    \"(Note that they may be intentionally disabled \"\n\t\t    \"if the\\n\\t'compatibility' property is set.)\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_COMPATIBILITY_ERR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Error reading or parsing \"\n\t\t    \"the file(s) indicated by the 'compatibility'\\n\"\n\t\t    \"property.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_INCOMPATIBLE_FEAT:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more features \"\n\t\t    \"are enabled on the pool despite not being\\n\"\n\t\t    \"requested by the 'compatibility' property.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_UNSUP_FEAT_READ:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool uses the following \"\n\t\t    \"feature(s) not supported on this system:\\n\"));\n\t\tcolor_start(ANSI_YELLOW);\n\t\tzpool_print_unsup_feat(config);\n\t\tcolor_end();\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_UNSUP_FEAT_WRITE:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool can only be \"\n\t\t    \"accessed in read-only mode on this system. It\\n\\tcannot be\"\n\t\t    \" accessed in read-write mode because it uses the \"\n\t\t    \"following\\n\\tfeature(s) not supported on this system:\\n\"));\n\t\tcolor_start(ANSI_YELLOW);\n\t\tzpool_print_unsup_feat(config);\n\t\tcolor_end();\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_HOSTID_ACTIVE:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool is currently \"\n\t\t    \"imported by another system.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_HOSTID_REQUIRED:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool has the \"\n\t\t    \"multihost property on.  It cannot\\n\\tbe safely imported \"\n\t\t    \"when the system hostid is not set.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_HOSTID_MISMATCH:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool was last accessed \"\n\t\t    \"by another system.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_FAULTED_DEV_R:\n\tcase ZPOOL_STATUS_FAULTED_DEV_NR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices are \"\n\t\t    \"faulted.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_BAD_LOG:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"An intent log record cannot \"\n\t\t    \"be read.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_RESILVERING:\n\tcase ZPOOL_STATUS_REBUILDING:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices were \"\n\t\t    \"being resilvered.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_ERRATA:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Errata #%d detected.\\n\"),\n\t\t    errata);\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_NON_NATIVE_ASHIFT:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices are \"\n\t\t    \"configured to use a non-native block size.\\n\"\n\t\t    \"\\tExpect reduced performance.\\n\"));\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tassert(reason == ZPOOL_STATUS_OK);\n\t}\n\n\t \n\tif (vs->vs_state == VDEV_STATE_HEALTHY) {\n\t\tif (reason == ZPOOL_STATUS_VERSION_OLDER ||\n\t\t    reason == ZPOOL_STATUS_FEAT_DISABLED) {\n\t\t\t(void) printf(gettext(\" action: The pool can be \"\n\t\t\t    \"imported using its name or numeric identifier, \"\n\t\t\t    \"though\\n\\tsome features will not be available \"\n\t\t\t    \"without an explicit 'zpool upgrade'.\\n\"));\n\t\t} else if (reason == ZPOOL_STATUS_COMPATIBILITY_ERR) {\n\t\t\t(void) printf(gettext(\" action: The pool can be \"\n\t\t\t    \"imported using its name or numeric\\n\\tidentifier, \"\n\t\t\t    \"though the file(s) indicated by its \"\n\t\t\t    \"'compatibility'\\n\\tproperty cannot be parsed at \"\n\t\t\t    \"this time.\\n\"));\n\t\t} else if (reason == ZPOOL_STATUS_HOSTID_MISMATCH) {\n\t\t\t(void) printf(gettext(\" action: The pool can be \"\n\t\t\t    \"imported using its name or numeric \"\n\t\t\t    \"identifier and\\n\\tthe '-f' flag.\\n\"));\n\t\t} else if (reason == ZPOOL_STATUS_ERRATA) {\n\t\t\tswitch (errata) {\n\t\t\tcase ZPOOL_ERRATA_NONE:\n\t\t\t\tbreak;\n\n\t\t\tcase ZPOOL_ERRATA_ZOL_2094_SCRUB:\n\t\t\t\t(void) printf(gettext(\" action: The pool can \"\n\t\t\t\t    \"be imported using its name or numeric \"\n\t\t\t\t    \"identifier,\\n\\thowever there is a compat\"\n\t\t\t\t    \"ibility issue which should be corrected\"\n\t\t\t\t    \"\\n\\tby running 'zpool scrub'\\n\"));\n\t\t\t\tbreak;\n\n\t\t\tcase ZPOOL_ERRATA_ZOL_2094_ASYNC_DESTROY:\n\t\t\t\t(void) printf(gettext(\" action: The pool can\"\n\t\t\t\t    \"not be imported with this version of ZFS \"\n\t\t\t\t    \"due to\\n\\tan active asynchronous destroy. \"\n\t\t\t\t    \"Revert to an earlier version\\n\\tand \"\n\t\t\t\t    \"allow the destroy to complete before \"\n\t\t\t\t    \"updating.\\n\"));\n\t\t\t\tbreak;\n\n\t\t\tcase ZPOOL_ERRATA_ZOL_6845_ENCRYPTION:\n\t\t\t\t(void) printf(gettext(\" action: Existing \"\n\t\t\t\t    \"encrypted datasets contain an on-disk \"\n\t\t\t\t    \"incompatibility, which\\n\\tneeds to be \"\n\t\t\t\t    \"corrected. Backup these datasets to new \"\n\t\t\t\t    \"encrypted datasets\\n\\tand destroy the \"\n\t\t\t\t    \"old ones.\\n\"));\n\t\t\t\tbreak;\n\n\t\t\tcase ZPOOL_ERRATA_ZOL_8308_ENCRYPTION:\n\t\t\t\t(void) printf(gettext(\" action: Existing \"\n\t\t\t\t    \"encrypted snapshots and bookmarks contain \"\n\t\t\t\t    \"an on-disk\\n\\tincompatibility. This may \"\n\t\t\t\t    \"cause on-disk corruption if they are used\"\n\t\t\t\t    \"\\n\\twith 'zfs recv'. To correct the \"\n\t\t\t\t    \"issue, enable the bookmark_v2 feature.\\n\\t\"\n\t\t\t\t    \"No additional action is needed if there \"\n\t\t\t\t    \"are no encrypted snapshots or\\n\\t\"\n\t\t\t\t    \"bookmarks. If preserving the encrypted \"\n\t\t\t\t    \"snapshots and bookmarks is\\n\\trequired, \"\n\t\t\t\t    \"use a non-raw send to backup and restore \"\n\t\t\t\t    \"them. Alternately,\\n\\tthey may be removed\"\n\t\t\t\t    \" to resolve the incompatibility.\\n\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tassert(0);\n\t\t\t}\n\t\t} else {\n\t\t\t(void) printf(gettext(\" action: The pool can be \"\n\t\t\t    \"imported using its name or numeric \"\n\t\t\t    \"identifier.\\n\"));\n\t\t}\n\t} else if (vs->vs_state == VDEV_STATE_DEGRADED) {\n\t\t(void) printf(gettext(\" action: The pool can be imported \"\n\t\t    \"despite missing or damaged devices.  The\\n\\tfault \"\n\t\t    \"tolerance of the pool may be compromised if imported.\\n\"));\n\t} else {\n\t\tswitch (reason) {\n\t\tcase ZPOOL_STATUS_VERSION_NEWER:\n\t\t\t(void) printf(gettext(\" action: The pool cannot be \"\n\t\t\t    \"imported.  Access the pool on a system running \"\n\t\t\t    \"newer\\n\\tsoftware, or recreate the pool from \"\n\t\t\t    \"backup.\\n\"));\n\t\t\tbreak;\n\t\tcase ZPOOL_STATUS_UNSUP_FEAT_READ:\n\t\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool cannot be \"\n\t\t\t    \"imported. Access the pool on a system that \"\n\t\t\t    \"supports\\n\\tthe required feature(s), or recreate \"\n\t\t\t    \"the pool from backup.\\n\"));\n\t\t\tbreak;\n\t\tcase ZPOOL_STATUS_UNSUP_FEAT_WRITE:\n\t\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool cannot be \"\n\t\t\t    \"imported in read-write mode. Import the pool \"\n\t\t\t    \"with\\n\"\n\t\t\t    \"\\t\\\"-o readonly=on\\\", access the pool on a system \"\n\t\t\t    \"that supports the\\n\\trequired feature(s), or \"\n\t\t\t    \"recreate the pool from backup.\\n\"));\n\t\t\tbreak;\n\t\tcase ZPOOL_STATUS_MISSING_DEV_R:\n\t\tcase ZPOOL_STATUS_MISSING_DEV_NR:\n\t\tcase ZPOOL_STATUS_BAD_GUID_SUM:\n\t\t\t(void) printf(gettext(\" action: The pool cannot be \"\n\t\t\t    \"imported. Attach the missing\\n\\tdevices and try \"\n\t\t\t    \"again.\\n\"));\n\t\t\tbreak;\n\t\tcase ZPOOL_STATUS_HOSTID_ACTIVE:\n\t\t\tVERIFY0(nvlist_lookup_nvlist(config,\n\t\t\t    ZPOOL_CONFIG_LOAD_INFO, &nvinfo));\n\n\t\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_MMP_HOSTNAME))\n\t\t\t\thostname = fnvlist_lookup_string(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTNAME);\n\n\t\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_MMP_HOSTID))\n\t\t\t\thostid = fnvlist_lookup_uint64(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTID);\n\n\t\t\t(void) printf(gettext(\" action: The pool must be \"\n\t\t\t    \"exported from %s (hostid=%\"PRIx64\")\\n\\tbefore it \"\n\t\t\t    \"can be safely imported.\\n\"), hostname, hostid);\n\t\t\tbreak;\n\t\tcase ZPOOL_STATUS_HOSTID_REQUIRED:\n\t\t\t(void) printf(gettext(\" action: Set a unique system \"\n\t\t\t    \"hostid with the zgenhostid(8) command.\\n\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) printf(gettext(\" action: The pool cannot be \"\n\t\t\t    \"imported due to damaged devices or data.\\n\"));\n\t\t}\n\t}\n\n\t \n\tif (nvlist_lookup_string(config, ZPOOL_CONFIG_COMMENT, &comment) == 0)\n\t\t(void) printf(gettext(\"comment: %s\\n\"), comment);\n\n\t \n\tif (((vs->vs_state == VDEV_STATE_CLOSED) ||\n\t    (vs->vs_state == VDEV_STATE_CANT_OPEN)) &&\n\t    (vs->vs_aux == VDEV_AUX_CORRUPT_DATA)) {\n\t\tif (pool_state == POOL_STATE_DESTROYED)\n\t\t\t(void) printf(gettext(\"\\tThe pool was destroyed, \"\n\t\t\t    \"but can be imported using the '-Df' flags.\\n\"));\n\t\telse if (pool_state != POOL_STATE_EXPORTED)\n\t\t\t(void) printf(gettext(\"\\tThe pool may be active on \"\n\t\t\t    \"another system, but can be imported using\\n\\t\"\n\t\t\t    \"the '-f' flag.\\n\"));\n\t}\n\n\tif (msgid != NULL) {\n\t\t(void) printf(gettext(\n\t\t    \"   see: https:\n\t\t    msgid);\n\t}\n\n\t(void) printf(gettext(\" config:\\n\\n\"));\n\n\tcb.cb_namewidth = max_width(NULL, nvroot, 0, strlen(name),\n\t    VDEV_NAME_TYPE_ID);\n\tif (cb.cb_namewidth < 10)\n\t\tcb.cb_namewidth = 10;\n\n\tprint_import_config(&cb, name, nvroot, 0);\n\n\tprint_class_vdevs(NULL, &cb, nvroot, VDEV_ALLOC_BIAS_DEDUP);\n\tprint_class_vdevs(NULL, &cb, nvroot, VDEV_ALLOC_BIAS_SPECIAL);\n\tprint_class_vdevs(NULL, &cb, nvroot, VDEV_ALLOC_CLASS_LOGS);\n\n\tif (reason == ZPOOL_STATUS_BAD_GUID_SUM) {\n\t\t(void) printf(gettext(\"\\n\\tAdditional devices are known to \"\n\t\t    \"be part of this pool, though their\\n\\texact \"\n\t\t    \"configuration cannot be determined.\\n\"));\n\t}\n\treturn (0);\n}\n\nstatic boolean_t\nzfs_force_import_required(nvlist_t *config)\n{\n\tuint64_t state;\n\tuint64_t hostid = 0;\n\tnvlist_t *nvinfo;\n\n\tstate = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE);\n\tnvinfo = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_LOAD_INFO);\n\n\t/*\n\t * The hostid on LOAD_INFO comes from the MOS label via\n\t * spa_tryimport(). If its not there then we're likely talking to an\n\t * older kernel, so use the top one, which will be from the label\n\t * discovered in zpool_find_import(), or if a cachefile is in use, the\n\t * local hostid.\n\t */\n\tif (nvlist_lookup_uint64(nvinfo, ZPOOL_CONFIG_HOSTID, &hostid) != 0)\n\t\tnvlist_lookup_uint64(config, ZPOOL_CONFIG_HOSTID, &hostid);\n\n\tif (state != POOL_STATE_EXPORTED && hostid != get_system_hostid())\n\t\treturn (B_TRUE);\n\n\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_MMP_STATE)) {\n\t\tmmp_state_t mmp_state = fnvlist_lookup_uint64(nvinfo,\n\t\t    ZPOOL_CONFIG_MMP_STATE);\n\n\t\tif (mmp_state != MMP_STATE_INACTIVE)\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n/*\n * Perform the import for the given configuration.  This passes the heavy\n * lifting off to zpool_import_props(), and then mounts the datasets contained\n * within the pool.\n */\nstatic int\ndo_import(nvlist_t *config, const char *newname, const char *mntopts,\n    nvlist_t *props, int flags)\n{\n\tint ret = 0;\n\tint ms_status = 0;\n\tzpool_handle_t *zhp;\n\tconst char *name;\n\tuint64_t version;\n\n\tname = fnvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME);\n\tversion = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION);\n\n\tif (!SPA_VERSION_IS_SUPPORTED(version)) {\n\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': pool \"\n\t\t    \"is formatted using an unsupported ZFS version\\n\"), name);\n\t\treturn (1);\n\t} else if (zfs_force_import_required(config) &&\n\t    !(flags & ZFS_IMPORT_ANY_HOST)) {\n\t\tmmp_state_t mmp_state = MMP_STATE_INACTIVE;\n\t\tnvlist_t *nvinfo;\n\n\t\tnvinfo = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_LOAD_INFO);\n\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_MMP_STATE))\n\t\t\tmmp_state = fnvlist_lookup_uint64(nvinfo,\n\t\t\t    ZPOOL_CONFIG_MMP_STATE);\n\n\t\tif (mmp_state == MMP_STATE_ACTIVE) {\n\t\t\tconst char *hostname = \"<unknown>\";\n\t\t\tuint64_t hostid = 0;\n\n\t\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_MMP_HOSTNAME))\n\t\t\t\thostname = fnvlist_lookup_string(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTNAME);\n\n\t\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_MMP_HOSTID))\n\t\t\t\thostid = fnvlist_lookup_uint64(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_MMP_HOSTID);\n\n\t\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': \"\n\t\t\t    \"pool is imported on %s (hostid: \"\n\t\t\t    \"0x%\"PRIx64\")\\nExport the pool on the other \"\n\t\t\t    \"system, then run 'zpool import'.\\n\"),\n\t\t\t    name, hostname, hostid);\n\t\t} else if (mmp_state == MMP_STATE_NO_HOSTID) {\n\t\t\t(void) fprintf(stderr, gettext(\"Cannot import '%s': \"\n\t\t\t    \"pool has the multihost property on and the\\n\"\n\t\t\t    \"system's hostid is not set. Set a unique hostid \"\n\t\t\t    \"with the zgenhostid(8) command.\\n\"), name);\n\t\t} else {\n\t\t\tconst char *hostname = \"<unknown>\";\n\t\t\ttime_t timestamp = 0;\n\t\t\tuint64_t hostid = 0;\n\n\t\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_HOSTNAME))\n\t\t\t\thostname = fnvlist_lookup_string(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_HOSTNAME);\n\t\t\telse if (nvlist_exists(config, ZPOOL_CONFIG_HOSTNAME))\n\t\t\t\thostname = fnvlist_lookup_string(config,\n\t\t\t\t    ZPOOL_CONFIG_HOSTNAME);\n\n\t\t\tif (nvlist_exists(config, ZPOOL_CONFIG_TIMESTAMP))\n\t\t\t\ttimestamp = fnvlist_lookup_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_TIMESTAMP);\n\n\t\t\tif (nvlist_exists(nvinfo, ZPOOL_CONFIG_HOSTID))\n\t\t\t\thostid = fnvlist_lookup_uint64(nvinfo,\n\t\t\t\t    ZPOOL_CONFIG_HOSTID);\n\t\t\telse if (nvlist_exists(config, ZPOOL_CONFIG_HOSTID))\n\t\t\t\thostid = fnvlist_lookup_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_HOSTID);\n\n\t\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': \"\n\t\t\t    \"pool was previously in use from another system.\\n\"\n\t\t\t    \"Last accessed by %s (hostid=%\"PRIx64\") at %s\"\n\t\t\t    \"The pool can be imported, use 'zpool import -f' \"\n\t\t\t    \"to import the pool.\\n\"), name, hostname,\n\t\t\t    hostid, ctime(&timestamp));\n\t\t}\n\n\t\treturn (1);\n\t}\n\n\tif (zpool_import_props(g_zfs, config, newname, props, flags) != 0)\n\t\treturn (1);\n\n\tif (newname != NULL)\n\t\tname = newname;\n\n\tif ((zhp = zpool_open_canfail(g_zfs, name)) == NULL)\n\t\treturn (1);\n\n\t/*\n\t * Loading keys is best effort. We don't want to return immediately\n\t * if it fails but we do want to give the error to the caller.\n\t */\n\tif (flags & ZFS_IMPORT_LOAD_KEYS &&\n\t    zfs_crypto_attempt_load_keys(g_zfs, name) != 0)\n\t\t\tret = 1;\n\n\tif (zpool_get_state(zhp) != POOL_STATE_UNAVAIL &&\n\t    !(flags & ZFS_IMPORT_ONLY)) {\n\t\tms_status = zpool_enable_datasets(zhp, mntopts, 0);\n\t\tif (ms_status == EZFS_SHAREFAILED) {\n\t\t\t(void) fprintf(stderr, gettext(\"Import was \"\n\t\t\t    \"successful, but unable to share some datasets\"));\n\t\t} else if (ms_status == EZFS_MOUNTFAILED) {\n\t\t\t(void) fprintf(stderr, gettext(\"Import was \"\n\t\t\t    \"successful, but unable to mount some datasets\"));\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\treturn (ret);\n}\n\nstatic int\nimport_pools(nvlist_t *pools, nvlist_t *props, char *mntopts, int flags,\n    char *orig_name, char *new_name,\n    boolean_t do_destroyed, boolean_t pool_specified, boolean_t do_all,\n    importargs_t *import)\n{\n\tnvlist_t *config = NULL;\n\tnvlist_t *found_config = NULL;\n\tuint64_t pool_state;\n\n\t \n\tint err = 0;\n\tnvpair_t *elem = NULL;\n\tboolean_t first = B_TRUE;\n\twhile ((elem = nvlist_next_nvpair(pools, elem)) != NULL) {\n\n\t\tverify(nvpair_value_nvlist(elem, &config) == 0);\n\n\t\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE,\n\t\t    &pool_state) == 0);\n\t\tif (!do_destroyed && pool_state == POOL_STATE_DESTROYED)\n\t\t\tcontinue;\n\t\tif (do_destroyed && pool_state != POOL_STATE_DESTROYED)\n\t\t\tcontinue;\n\n\t\tverify(nvlist_add_nvlist(config, ZPOOL_LOAD_POLICY,\n\t\t    import->policy) == 0);\n\n\t\tif (!pool_specified) {\n\t\t\tif (first)\n\t\t\t\tfirst = B_FALSE;\n\t\t\telse if (!do_all)\n\t\t\t\t(void) fputc('\\n', stdout);\n\n\t\t\tif (do_all) {\n\t\t\t\terr |= do_import(config, NULL, mntopts,\n\t\t\t\t    props, flags);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (import->cachefile && !import->scan)\n\t\t\t\t\terr = show_import(config, B_FALSE);\n\t\t\t\telse\n\t\t\t\t\t(void) show_import(config, B_TRUE);\n\t\t\t}\n\t\t} else if (import->poolname != NULL) {\n\t\t\tconst char *name;\n\n\t\t\t \n\t\t\tverify(nvlist_lookup_string(config,\n\t\t\t    ZPOOL_CONFIG_POOL_NAME, &name) == 0);\n\n\t\t\tif (strcmp(name, import->poolname) == 0) {\n\t\t\t\tif (found_config != NULL) {\n\t\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t\t    \"cannot import '%s': more than \"\n\t\t\t\t\t    \"one matching pool\\n\"),\n\t\t\t\t\t    import->poolname);\n\t\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t\t    \"import by numeric ID instead\\n\"));\n\t\t\t\t\terr = B_TRUE;\n\t\t\t\t}\n\t\t\t\tfound_config = config;\n\t\t\t}\n\t\t} else {\n\t\t\tuint64_t guid;\n\n\t\t\t \n\t\t\tverify(nvlist_lookup_uint64(config,\n\t\t\t    ZPOOL_CONFIG_POOL_GUID, &guid) == 0);\n\n\t\t\tif (guid == import->guid)\n\t\t\t\tfound_config = config;\n\t\t}\n\t}\n\n\t \n\tif (pool_specified && err == 0) {\n\t\tif (found_config == NULL) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': \"\n\t\t\t    \"no such pool available\\n\"), orig_name);\n\t\t\terr = B_TRUE;\n\t\t} else {\n\t\t\terr |= do_import(found_config, new_name,\n\t\t\t    mntopts, props, flags);\n\t\t}\n\t}\n\n\t \n\tif (!pool_specified && first)\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"no pools available to import\\n\"));\n\treturn (err);\n}\n\ntypedef struct target_exists_args {\n\tconst char\t*poolname;\n\tuint64_t\tpoolguid;\n} target_exists_args_t;\n\nstatic int\nname_or_guid_exists(zpool_handle_t *zhp, void *data)\n{\n\ttarget_exists_args_t *args = data;\n\tnvlist_t *config = zpool_get_config(zhp, NULL);\n\tint found = 0;\n\n\tif (config == NULL)\n\t\treturn (0);\n\n\tif (args->poolname != NULL) {\n\t\tconst char *pool_name;\n\n\t\tverify(nvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME,\n\t\t    &pool_name) == 0);\n\t\tif (strcmp(pool_name, args->poolname) == 0)\n\t\t\tfound = 1;\n\t} else {\n\t\tuint64_t pool_guid;\n\n\t\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t\t    &pool_guid) == 0);\n\t\tif (pool_guid == args->poolguid)\n\t\t\tfound = 1;\n\t}\n\tzpool_close(zhp);\n\n\treturn (found);\n}\n \nint\nzpool_do_checkpoint(int argc, char **argv)\n{\n\tboolean_t discard, wait;\n\tchar *pool;\n\tzpool_handle_t *zhp;\n\tint c, err;\n\n\tstruct option long_options[] = {\n\t\t{\"discard\", no_argument, NULL, 'd'},\n\t\t{\"wait\", no_argument, NULL, 'w'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tdiscard = B_FALSE;\n\twait = B_FALSE;\n\twhile ((c = getopt_long(argc, argv, \":dw\", long_options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'd':\n\t\t\tdiscard = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twait = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (wait && !discard) {\n\t\t(void) fprintf(stderr, gettext(\"--wait only valid when \"\n\t\t    \"--discard also specified\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpool = argv[0];\n\n\tif ((zhp = zpool_open(g_zfs, pool)) == NULL) {\n\t\t \n\t\tif (strchr(pool, '/') != NULL)\n\t\t\t(void) fprintf(stderr, gettext(\"'zpool checkpoint' \"\n\t\t\t    \"doesn't work on datasets. To save the state \"\n\t\t\t    \"of a dataset from a specific point in time \"\n\t\t\t    \"please use 'zfs snapshot'\\n\"));\n\t\treturn (1);\n\t}\n\n\tif (discard) {\n\t\terr = (zpool_discard_checkpoint(zhp) != 0);\n\t\tif (err == 0 && wait)\n\t\t\terr = zpool_wait(zhp, ZPOOL_WAIT_CKPT_DISCARD);\n\t} else {\n\t\terr = (zpool_checkpoint(zhp) != 0);\n\t}\n\n\tzpool_close(zhp);\n\n\treturn (err);\n}\n\n#define\tCHECKPOINT_OPT\t1024\n\n \nint\nzpool_do_import(int argc, char **argv)\n{\n\tchar **searchdirs = NULL;\n\tchar *env, *envdup = NULL;\n\tint nsearch = 0;\n\tint c;\n\tint err = 0;\n\tnvlist_t *pools = NULL;\n\tboolean_t do_all = B_FALSE;\n\tboolean_t do_destroyed = B_FALSE;\n\tchar *mntopts = NULL;\n\tuint64_t searchguid = 0;\n\tchar *searchname = NULL;\n\tchar *propval;\n\tnvlist_t *policy = NULL;\n\tnvlist_t *props = NULL;\n\tint flags = ZFS_IMPORT_NORMAL;\n\tuint32_t rewind_policy = ZPOOL_NO_REWIND;\n\tboolean_t dryrun = B_FALSE;\n\tboolean_t do_rewind = B_FALSE;\n\tboolean_t xtreme_rewind = B_FALSE;\n\tboolean_t do_scan = B_FALSE;\n\tboolean_t pool_exists = B_FALSE;\n\tboolean_t pool_specified = B_FALSE;\n\tuint64_t txg = -1ULL;\n\tchar *cachefile = NULL;\n\timportargs_t idata = { 0 };\n\tchar *endptr;\n\n\tstruct option long_options[] = {\n\t\t{\"rewind-to-checkpoint\", no_argument, NULL, CHECKPOINT_OPT},\n\t\t{0, 0, 0, 0}\n\t};\n\n\t \n\twhile ((c = getopt_long(argc, argv, \":aCc:d:DEfFlmnNo:R:stT:VX\",\n\t    long_options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tdo_all = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcachefile = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tsearchdirs = safe_realloc(searchdirs,\n\t\t\t    (nsearch + 1) * sizeof (char *));\n\t\t\tsearchdirs[nsearch++] = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdo_destroyed = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= ZFS_IMPORT_ANY_HOST;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tdo_rewind = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags |= ZFS_IMPORT_LOAD_KEYS;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tflags |= ZFS_IMPORT_MISSING_LOG;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tflags |= ZFS_IMPORT_ONLY;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((propval = strchr(optarg, '=')) != NULL) {\n\t\t\t\t*propval = '\\0';\n\t\t\t\tpropval++;\n\t\t\t\tif (add_prop_list(optarg, propval,\n\t\t\t\t    &props, B_TRUE))\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tmntopts = optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif (add_prop_list(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_ALTROOT), optarg, &props, B_TRUE))\n\t\t\t\tgoto error;\n\t\t\tif (add_prop_list_default(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_CACHEFILE), \"none\", &props))\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdo_scan = B_TRUE;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tflags |= ZFS_IMPORT_TEMP_NAME;\n\t\t\tif (add_prop_list_default(zpool_prop_to_name(\n\t\t\t    ZPOOL_PROP_CACHEFILE), \"none\", &props))\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tcase 'T':\n\t\t\terrno = 0;\n\t\t\ttxg = strtoull(optarg, &endptr, 0);\n\t\t\tif (errno != 0 || *endptr != '\\0') {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid txg value\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\trewind_policy = ZPOOL_DO_REWIND | ZPOOL_EXTREME_REWIND;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tflags |= ZFS_IMPORT_VERBATIM;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\txtreme_rewind = B_TRUE;\n\t\t\tbreak;\n\t\tcase CHECKPOINT_OPT:\n\t\t\tflags |= ZFS_IMPORT_CHECKPOINT;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (cachefile && nsearch != 0) {\n\t\t(void) fprintf(stderr, gettext(\"-c is incompatible with -d\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (cachefile && do_scan) {\n\t\t(void) fprintf(stderr, gettext(\"-c is incompatible with -s\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif ((flags & ZFS_IMPORT_LOAD_KEYS) && (flags & ZFS_IMPORT_ONLY)) {\n\t\t(void) fprintf(stderr, gettext(\"-l is incompatible with -N\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif ((flags & ZFS_IMPORT_LOAD_KEYS) && !do_all && argc == 0) {\n\t\t(void) fprintf(stderr, gettext(\"-l is only meaningful during \"\n\t\t    \"an import\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif ((dryrun || xtreme_rewind) && !do_rewind) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"-n or -X only meaningful with -F\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (dryrun)\n\t\trewind_policy = ZPOOL_TRY_REWIND;\n\telse if (do_rewind)\n\t\trewind_policy = ZPOOL_DO_REWIND;\n\tif (xtreme_rewind)\n\t\trewind_policy |= ZPOOL_EXTREME_REWIND;\n\n\t \n\tif (nvlist_alloc(&policy, NV_UNIQUE_NAME, 0) != 0 ||\n\t    nvlist_add_uint64(policy, ZPOOL_LOAD_REQUEST_TXG, txg) != 0 ||\n\t    nvlist_add_uint32(policy, ZPOOL_LOAD_REWIND_POLICY,\n\t    rewind_policy) != 0)\n\t\tgoto error;\n\n\t \n\tif (do_all) {\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t} else {\n\t\tif (argc > 2) {\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\t \n\tif (argc == 0 && geteuid() != 0) {\n\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t    \"discover pools: permission denied\\n\"));\n\n\t\tfree(searchdirs);\n\t\tnvlist_free(props);\n\t\tnvlist_free(policy);\n\t\treturn (1);\n\t}\n\n\t \n\tif (argc != 0) {\n\t\tchar *endptr;\n\n\t\terrno = 0;\n\t\tsearchguid = strtoull(argv[0], &endptr, 10);\n\t\tif (errno != 0 || *endptr != '\\0') {\n\t\t\tsearchname = argv[0];\n\t\t\tsearchguid = 0;\n\t\t}\n\t\tpool_specified = B_TRUE;\n\n\t\t \n\t\ttarget_exists_args_t search = {searchname, searchguid};\n\t\tpool_exists = zpool_iter(g_zfs, name_or_guid_exists, &search);\n\t}\n\n\t \n\tif ((searchdirs == NULL) && (env = getenv(\"ZPOOL_IMPORT_PATH\"))) {\n\t\tchar *dir, *tmp = NULL;\n\n\t\tenvdup = strdup(env);\n\n\t\tfor (dir = strtok_r(envdup, \":\", &tmp);\n\t\t    dir != NULL;\n\t\t    dir = strtok_r(NULL, \":\", &tmp)) {\n\t\t\tsearchdirs = safe_realloc(searchdirs,\n\t\t\t    (nsearch + 1) * sizeof (char *));\n\t\t\tsearchdirs[nsearch++] = dir;\n\t\t}\n\t}\n\n\tidata.path = searchdirs;\n\tidata.paths = nsearch;\n\tidata.poolname = searchname;\n\tidata.guid = searchguid;\n\tidata.cachefile = cachefile;\n\tidata.scan = do_scan;\n\tidata.policy = policy;\n\n\tlibpc_handle_t lpch = {\n\t\t.lpc_lib_handle = g_zfs,\n\t\t.lpc_ops = &libzfs_config_ops,\n\t\t.lpc_printerr = B_TRUE\n\t};\n\tpools = zpool_search_import(&lpch, &idata);\n\n\tif (pools != NULL && pool_exists &&\n\t    (argc == 1 || strcmp(argv[0], argv[1]) == 0)) {\n\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': \"\n\t\t    \"a pool with that name already exists\\n\"),\n\t\t    argv[0]);\n\t\t(void) fprintf(stderr, gettext(\"use the form '%s \"\n\t\t    \"<pool | id> <newpool>' to give it a new name\\n\"),\n\t\t    \"zpool import\");\n\t\terr = 1;\n\t} else if (pools == NULL && pool_exists) {\n\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': \"\n\t\t    \"a pool with that name is already created/imported,\\n\"),\n\t\t    argv[0]);\n\t\t(void) fprintf(stderr, gettext(\"and no additional pools \"\n\t\t    \"with that name were found\\n\"));\n\t\terr = 1;\n\t} else if (pools == NULL) {\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot import '%s': \"\n\t\t\t    \"no such pool available\\n\"), argv[0]);\n\t\t}\n\t\terr = 1;\n\t}\n\n\tif (err == 1) {\n\t\tfree(searchdirs);\n\t\tfree(envdup);\n\t\tnvlist_free(policy);\n\t\tnvlist_free(pools);\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\terr = import_pools(pools, props, mntopts, flags,\n\t    argc >= 1 ? argv[0] : NULL,\n\t    argc >= 2 ? argv[1] : NULL,\n\t    do_destroyed, pool_specified, do_all, &idata);\n\n\t \n\tif (err != 0 && cachefile != NULL) {\n\t\t(void) printf(gettext(\"cachefile import failed, retrying\\n\"));\n\n\t\t \n\t\tidata.scan = B_TRUE;\n\t\tnvlist_free(pools);\n\t\tpools = zpool_search_import(&lpch, &idata);\n\n\t\terr = import_pools(pools, props, mntopts, flags,\n\t\t    argc >= 1 ? argv[0] : NULL,\n\t\t    argc >= 2 ? argv[1] : NULL,\n\t\t    do_destroyed, pool_specified, do_all, &idata);\n\t}\n\nerror:\n\tnvlist_free(props);\n\tnvlist_free(pools);\n\tnvlist_free(policy);\n\tfree(searchdirs);\n\tfree(envdup);\n\n\treturn (err ? 1 : 0);\n}\n\n \nstatic int\nzpool_do_sync(int argc, char **argv)\n{\n\tint ret;\n\tboolean_t force = B_FALSE;\n\n\t \n\twhile ((ret  = getopt(argc, argv, \"f\")) != -1) {\n\t\tswitch (ret) {\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tret = for_each_pool(argc, argv, B_FALSE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, zpool_sync_one, &force);\n\n\treturn (ret);\n}\n\ntypedef struct iostat_cbdata {\n\tuint64_t cb_flags;\n\tint cb_namewidth;\n\tint cb_iteration;\n\tboolean_t cb_verbose;\n\tboolean_t cb_literal;\n\tboolean_t cb_scripted;\n\tzpool_list_t *cb_list;\n\tvdev_cmd_data_list_t *vcdl;\n\tvdev_cbdata_t cb_vdevs;\n} iostat_cbdata_t;\n\n \ntypedef struct name_and_columns {\n\tconst char *name;\t \n\tunsigned int columns;\t \n} name_and_columns_t;\n\n#define\tIOSTAT_MAX_LABELS\t15\t \n\nstatic const name_and_columns_t iostat_top_labels[][IOSTAT_MAX_LABELS] =\n{\n\t[IOS_DEFAULT] = {{\"capacity\", 2}, {\"operations\", 2}, {\"bandwidth\", 2},\n\t    {NULL}},\n\t[IOS_LATENCY] = {{\"total_wait\", 2}, {\"disk_wait\", 2}, {\"syncq_wait\", 2},\n\t    {\"asyncq_wait\", 2}, {\"scrub\", 1}, {\"trim\", 1}, {\"rebuild\", 1},\n\t    {NULL}},\n\t[IOS_QUEUES] = {{\"syncq_read\", 2}, {\"syncq_write\", 2},\n\t    {\"asyncq_read\", 2}, {\"asyncq_write\", 2}, {\"scrubq_read\", 2},\n\t    {\"trimq_write\", 2}, {\"rebuildq_write\", 2}, {NULL}},\n\t[IOS_L_HISTO] = {{\"total_wait\", 2}, {\"disk_wait\", 2}, {\"syncq_wait\", 2},\n\t    {\"asyncq_wait\", 2}, {NULL}},\n\t[IOS_RQ_HISTO] = {{\"sync_read\", 2}, {\"sync_write\", 2},\n\t    {\"async_read\", 2}, {\"async_write\", 2}, {\"scrub\", 2},\n\t    {\"trim\", 2}, {\"rebuild\", 2}, {NULL}},\n};\n\n \nstatic const name_and_columns_t iostat_bottom_labels[][IOSTAT_MAX_LABELS] =\n{\n\t[IOS_DEFAULT] = {{\"alloc\"}, {\"free\"}, {\"read\"}, {\"write\"}, {\"read\"},\n\t    {\"write\"}, {NULL}},\n\t[IOS_LATENCY] = {{\"read\"}, {\"write\"}, {\"read\"}, {\"write\"}, {\"read\"},\n\t    {\"write\"}, {\"read\"}, {\"write\"}, {\"wait\"}, {\"wait\"}, {\"wait\"},\n\t    {NULL}},\n\t[IOS_QUEUES] = {{\"pend\"}, {\"activ\"}, {\"pend\"}, {\"activ\"}, {\"pend\"},\n\t    {\"activ\"}, {\"pend\"}, {\"activ\"}, {\"pend\"}, {\"activ\"},\n\t    {\"pend\"}, {\"activ\"}, {\"pend\"}, {\"activ\"}, {NULL}},\n\t[IOS_L_HISTO] = {{\"read\"}, {\"write\"}, {\"read\"}, {\"write\"}, {\"read\"},\n\t    {\"write\"}, {\"read\"}, {\"write\"}, {\"scrub\"}, {\"trim\"}, {\"rebuild\"},\n\t    {NULL}},\n\t[IOS_RQ_HISTO] = {{\"ind\"}, {\"agg\"}, {\"ind\"}, {\"agg\"}, {\"ind\"}, {\"agg\"},\n\t    {\"ind\"}, {\"agg\"}, {\"ind\"}, {\"agg\"}, {\"ind\"}, {\"agg\"},\n\t    {\"ind\"}, {\"agg\"}, {NULL}},\n};\n\nstatic const char *histo_to_title[] = {\n\t[IOS_L_HISTO] = \"latency\",\n\t[IOS_RQ_HISTO] = \"req_size\",\n};\n\n \nstatic unsigned int\nlabel_array_len(const name_and_columns_t *labels)\n{\n\tint i = 0;\n\n\twhile (labels[i].name)\n\t\ti++;\n\n\treturn (i);\n}\n\n \nstatic uint64_t\nstr_array_len(const char *array[])\n{\n\tuint64_t i = 0;\n\twhile (array[i])\n\t\ti++;\n\n\treturn (i);\n}\n\n\n \nstatic unsigned int\ndefault_column_width(iostat_cbdata_t *cb, enum iostat_type type)\n{\n\tunsigned long column_width = 5;  \n\tstatic unsigned long widths[] = {\n\t\t \n\t\t[IOS_DEFAULT] = 15,  \n\t\t[IOS_LATENCY] = 10,  \n\t\t[IOS_QUEUES] = 6,    \n\t\t[IOS_L_HISTO] = 10,  \n\t\t[IOS_RQ_HISTO] = 6,  \n\t};\n\n\tif (cb->cb_literal)\n\t\tcolumn_width = widths[type];\n\n\treturn (column_width);\n}\n\n \nstatic void\nprint_iostat_labels(iostat_cbdata_t *cb, unsigned int force_column_width,\n    const name_and_columns_t labels[][IOSTAT_MAX_LABELS])\n{\n\tint i, idx, s;\n\tint text_start, rw_column_width, spaces_to_end;\n\tuint64_t flags = cb->cb_flags;\n\tuint64_t f;\n\tunsigned int column_width = force_column_width;\n\n\t \n\tfor (f = flags; f; f &= ~(1ULL << idx)) {\n\t\tidx = lowbit64(f) - 1;\n\t\tif (!force_column_width)\n\t\t\tcolumn_width = default_column_width(cb, idx);\n\t\t \n\t\tfor (i = 0; i < label_array_len(labels[idx]); i++) {\n\t\t\tconst char *name = labels[idx][i].name;\n\t\t\t \n\t\t\tunsigned int columns = MAX(1, labels[idx][i].columns);\n\t\t\tunsigned int slen = strlen(name);\n\n\t\t\trw_column_width = (column_width * columns) +\n\t\t\t    (2 * (columns - 1));\n\n\t\t\ttext_start = (int)((rw_column_width) / columns -\n\t\t\t    slen / columns);\n\t\t\tif (text_start < 0)\n\t\t\t\ttext_start = 0;\n\n\t\t\tprintf(\"  \");\t \n\n\t\t\t \n\t\t\tfor (s = 0; s < text_start; s++)\n\t\t\t\tprintf(\" \");\n\n\t\t\tprintf(\"%s\", name);\n\n\t\t\t \n\t\t\tspaces_to_end = rw_column_width - text_start - slen;\n\t\t\tif (spaces_to_end < 0)\n\t\t\t\tspaces_to_end = 0;\n\n\t\t\tfor (s = 0; s < spaces_to_end; s++)\n\t\t\t\tprintf(\" \");\n\t\t}\n\t}\n}\n\n\n \nstatic void\nprint_cmd_columns(vdev_cmd_data_list_t *vcdl, int use_dashes)\n{\n\tint i, j;\n\tvdev_cmd_data_t *data = &vcdl->data[0];\n\n\tif (vcdl->count == 0 || data == NULL)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < vcdl->uniq_cols_cnt; i++) {\n\t\tprintf(\"  \");\n\t\tif (use_dashes) {\n\t\t\tfor (j = 0; j < vcdl->uniq_cols_width[i]; j++)\n\t\t\t\tprintf(\"-\");\n\t\t} else {\n\t\t\tprintf_color(ANSI_BOLD, \"%*s\", vcdl->uniq_cols_width[i],\n\t\t\t    vcdl->uniq_cols[i]);\n\t\t}\n\t}\n}\n\n\n \nstatic void\nprint_iostat_dashes(iostat_cbdata_t *cb, unsigned int force_column_width,\n    const char *name)\n{\n\tint i;\n\tunsigned int namewidth;\n\tuint64_t flags = cb->cb_flags;\n\tuint64_t f;\n\tint idx;\n\tconst name_and_columns_t *labels;\n\tconst char *title;\n\n\n\tif (cb->cb_flags & IOS_ANYHISTO_M) {\n\t\ttitle = histo_to_title[IOS_HISTO_IDX(cb->cb_flags)];\n\t} else if (cb->cb_vdevs.cb_names_count) {\n\t\ttitle = \"vdev\";\n\t} else  {\n\t\ttitle = \"pool\";\n\t}\n\n\tnamewidth = MAX(MAX(strlen(title), cb->cb_namewidth),\n\t    name ? strlen(name) : 0);\n\n\n\tif (name) {\n\t\tprintf(\"%-*s\", namewidth, name);\n\t} else {\n\t\tfor (i = 0; i < namewidth; i++)\n\t\t\t(void) printf(\"-\");\n\t}\n\n\t \n\tfor (f = flags; f; f &= ~(1ULL << idx)) {\n\t\tunsigned int column_width;\n\t\tidx = lowbit64(f) - 1;\n\t\tif (force_column_width)\n\t\t\tcolumn_width = force_column_width;\n\t\telse\n\t\t\tcolumn_width = default_column_width(cb, idx);\n\n\t\tlabels = iostat_bottom_labels[idx];\n\t\tfor (i = 0; i < label_array_len(labels); i++) {\n\t\t\tif (name)\n\t\t\t\tprintf(\"  %*s-\", column_width - 1, \" \");\n\t\t\telse\n\t\t\t\tprintf(\"  %.*s\", column_width,\n\t\t\t\t    \"--------------------\");\n\t\t}\n\t}\n}\n\n\nstatic void\nprint_iostat_separator_impl(iostat_cbdata_t *cb,\n    unsigned int force_column_width)\n{\n\tprint_iostat_dashes(cb, force_column_width, NULL);\n}\n\nstatic void\nprint_iostat_separator(iostat_cbdata_t *cb)\n{\n\tprint_iostat_separator_impl(cb, 0);\n}\n\nstatic void\nprint_iostat_header_impl(iostat_cbdata_t *cb, unsigned int force_column_width,\n    const char *histo_vdev_name)\n{\n\tunsigned int namewidth;\n\tconst char *title;\n\n\tcolor_start(ANSI_BOLD);\n\n\tif (cb->cb_flags & IOS_ANYHISTO_M) {\n\t\ttitle = histo_to_title[IOS_HISTO_IDX(cb->cb_flags)];\n\t} else if (cb->cb_vdevs.cb_names_count) {\n\t\ttitle = \"vdev\";\n\t} else  {\n\t\ttitle = \"pool\";\n\t}\n\n\tnamewidth = MAX(MAX(strlen(title), cb->cb_namewidth),\n\t    histo_vdev_name ? strlen(histo_vdev_name) : 0);\n\n\tif (histo_vdev_name)\n\t\tprintf(\"%-*s\", namewidth, histo_vdev_name);\n\telse\n\t\tprintf(\"%*s\", namewidth, \"\");\n\n\n\tprint_iostat_labels(cb, force_column_width, iostat_top_labels);\n\tprintf(\"\\n\");\n\n\tprintf(\"%-*s\", namewidth, title);\n\n\tprint_iostat_labels(cb, force_column_width, iostat_bottom_labels);\n\tif (cb->vcdl != NULL)\n\t\tprint_cmd_columns(cb->vcdl, 0);\n\n\tprintf(\"\\n\");\n\n\tprint_iostat_separator_impl(cb, force_column_width);\n\n\tif (cb->vcdl != NULL)\n\t\tprint_cmd_columns(cb->vcdl, 1);\n\n\tcolor_end();\n\n\tprintf(\"\\n\");\n}\n\nstatic void\nprint_iostat_header(iostat_cbdata_t *cb)\n{\n\tprint_iostat_header_impl(cb, 0, NULL);\n}\n\n \nstatic void\nprint_stat_color(const char *statbuf, unsigned int column_size)\n{\n\tfputs(\"  \", stdout);\n\tsize_t len = strlen(statbuf);\n\twhile (len < column_size) {\n\t\tfputc(' ', stdout);\n\t\tcolumn_size--;\n\t}\n\tif (*statbuf == '0') {\n\t\tcolor_start(ANSI_GRAY);\n\t\tfputc('0', stdout);\n\t} else {\n\t\tfor (; *statbuf; statbuf++) {\n\t\t\tif (*statbuf == 'K') color_start(ANSI_GREEN);\n\t\t\telse if (*statbuf == 'M') color_start(ANSI_YELLOW);\n\t\t\telse if (*statbuf == 'G') color_start(ANSI_RED);\n\t\t\telse if (*statbuf == 'T') color_start(ANSI_BOLD_BLUE);\n\t\t\telse if (*statbuf == 'P') color_start(ANSI_MAGENTA);\n\t\t\telse if (*statbuf == 'E') color_start(ANSI_CYAN);\n\t\t\tfputc(*statbuf, stdout);\n\t\t\tif (--column_size <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcolor_end();\n}\n\n \nstatic void\nprint_one_stat(uint64_t value, enum zfs_nicenum_format format,\n    unsigned int column_size, boolean_t scripted)\n{\n\tchar buf[64];\n\n\tzfs_nicenum_format(value, buf, sizeof (buf), format);\n\n\tif (scripted)\n\t\tprintf(\"\\t%s\", buf);\n\telse\n\t\tprint_stat_color(buf, column_size);\n}\n\n \nstatic void\ncalc_default_iostats(vdev_stat_t *oldvs, vdev_stat_t *newvs,\n    vdev_stat_t *calcvs)\n{\n\tint i;\n\n\tmemcpy(calcvs, newvs, sizeof (*calcvs));\n\tfor (i = 0; i < ARRAY_SIZE(calcvs->vs_ops); i++)\n\t\tcalcvs->vs_ops[i] = (newvs->vs_ops[i] - oldvs->vs_ops[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(calcvs->vs_bytes); i++)\n\t\tcalcvs->vs_bytes[i] = (newvs->vs_bytes[i] - oldvs->vs_bytes[i]);\n}\n\n \nstruct stat_array {\n\tuint64_t *data;\n\tuint_t count;\t \n\tuint64_t __data;  \n};\n\nstatic uint64_t\nstat_histo_max(struct stat_array *nva, unsigned int len)\n{\n\tuint64_t max = 0;\n\tint i;\n\tfor (i = 0; i < len; i++)\n\t\tmax = MAX(max, array64_max(nva[i].data, nva[i].count));\n\n\treturn (max);\n}\n\n \nstatic int\nnvpair64_to_stat_array(nvlist_t *nvl, const char *name,\n    struct stat_array *nva)\n{\n\tnvpair_t *tmp;\n\tint ret;\n\n\tverify(nvlist_lookup_nvpair(nvl, name, &tmp) == 0);\n\tswitch (nvpair_type(tmp)) {\n\tcase DATA_TYPE_UINT64_ARRAY:\n\t\tret = nvpair_value_uint64_array(tmp, &nva->data, &nva->count);\n\t\tbreak;\n\tcase DATA_TYPE_UINT64:\n\t\tret = nvpair_value_uint64(tmp, &nva->__data);\n\t\tnva->data = &nva->__data;\n\t\tnva->count = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (ret);\n}\n\n \nstatic struct stat_array *\ncalc_and_alloc_stats_ex(const char **names, unsigned int len, nvlist_t *oldnv,\n    nvlist_t *newnv)\n{\n\tnvlist_t *oldnvx = NULL, *newnvx;\n\tstruct stat_array *oldnva, *newnva, *calcnva;\n\tint i, j;\n\tunsigned int alloc_size = (sizeof (struct stat_array)) * len;\n\n\t \n\tverify(nvlist_lookup_nvlist(newnv, ZPOOL_CONFIG_VDEV_STATS_EX,\n\t    &newnvx) == 0);\n\tif (oldnv) {\n\t\tverify(nvlist_lookup_nvlist(oldnv, ZPOOL_CONFIG_VDEV_STATS_EX,\n\t\t    &oldnvx) == 0);\n\t}\n\n\tnewnva = safe_malloc(alloc_size);\n\toldnva = safe_malloc(alloc_size);\n\tcalcnva = safe_malloc(alloc_size);\n\n\tfor (j = 0; j < len; j++) {\n\t\tverify(nvpair64_to_stat_array(newnvx, names[j],\n\t\t    &newnva[j]) == 0);\n\t\tcalcnva[j].count = newnva[j].count;\n\t\talloc_size = calcnva[j].count * sizeof (calcnva[j].data[0]);\n\t\tcalcnva[j].data = safe_malloc(alloc_size);\n\t\tmemcpy(calcnva[j].data, newnva[j].data, alloc_size);\n\n\t\tif (oldnvx) {\n\t\t\tverify(nvpair64_to_stat_array(oldnvx, names[j],\n\t\t\t    &oldnva[j]) == 0);\n\t\t\tfor (i = 0; i < oldnva[j].count; i++)\n\t\t\t\tcalcnva[j].data[i] -= oldnva[j].data[i];\n\t\t}\n\t}\n\tfree(newnva);\n\tfree(oldnva);\n\treturn (calcnva);\n}\n\nstatic void\nfree_calc_stats(struct stat_array *nva, unsigned int len)\n{\n\tint i;\n\tfor (i = 0; i < len; i++)\n\t\tfree(nva[i].data);\n\n\tfree(nva);\n}\n\nstatic void\nprint_iostat_histo(struct stat_array *nva, unsigned int len,\n    iostat_cbdata_t *cb, unsigned int column_width, unsigned int namewidth,\n    double scale)\n{\n\tint i, j;\n\tchar buf[6];\n\tuint64_t val;\n\tenum zfs_nicenum_format format;\n\tunsigned int buckets;\n\tunsigned int start_bucket;\n\n\tif (cb->cb_literal)\n\t\tformat = ZFS_NICENUM_RAW;\n\telse\n\t\tformat = ZFS_NICENUM_1024;\n\n\t \n\tbuckets = nva[0].count;\n\n\tif (cb->cb_flags & IOS_RQ_HISTO_M) {\n\t\t \n\t\tstart_bucket = 9;\n\t} else {\n\t\tstart_bucket = 0;\n\t}\n\n\tfor (j = start_bucket; j < buckets; j++) {\n\t\t \n\t\tif (cb->cb_flags & IOS_L_HISTO_M) {\n\t\t\t \n\t\t\tval = (1UL << (j + 1)) - 1;\n\t\t\tzfs_nicetime(val, buf, sizeof (buf));\n\t\t} else {\n\t\t\t \n\t\t\tval = (1UL << j);\n\t\t\tzfs_nicenum(val, buf, sizeof (buf));\n\t\t}\n\n\t\tif (cb->cb_scripted)\n\t\t\tprintf(\"%llu\", (u_longlong_t)val);\n\t\telse\n\t\t\tprintf(\"%-*s\", namewidth, buf);\n\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\tprint_one_stat(nva[i].data[j] * scale, format,\n\t\t\t    column_width, cb->cb_scripted);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nstatic void\nprint_solid_separator(unsigned int length)\n{\n\twhile (length--)\n\t\tprintf(\"-\");\n\tprintf(\"\\n\");\n}\n\nstatic void\nprint_iostat_histos(iostat_cbdata_t *cb, nvlist_t *oldnv,\n    nvlist_t *newnv, double scale, const char *name)\n{\n\tunsigned int column_width;\n\tunsigned int namewidth;\n\tunsigned int entire_width;\n\tenum iostat_type type;\n\tstruct stat_array *nva;\n\tconst char **names;\n\tunsigned int names_len;\n\n\t \n\ttype = IOS_HISTO_IDX(cb->cb_flags);\n\n\t \n\tnames = vsx_type_to_nvlist[type];\n\tnames_len = str_array_len(names);  \n\n\tnva = calc_and_alloc_stats_ex(names, names_len, oldnv, newnv);\n\n\tif (cb->cb_literal) {\n\t\tcolumn_width = MAX(5,\n\t\t    (unsigned int) log10(stat_histo_max(nva, names_len)) + 1);\n\t} else {\n\t\tcolumn_width = 5;\n\t}\n\n\tnamewidth = MAX(cb->cb_namewidth,\n\t    strlen(histo_to_title[IOS_HISTO_IDX(cb->cb_flags)]));\n\n\t \n\t \n\t \n\t \n\t \n\t \n\t \n\tentire_width = namewidth + (column_width + 2) *\n\t    label_array_len(iostat_bottom_labels[type]);\n\n\tif (cb->cb_scripted)\n\t\tprintf(\"%s\\n\", name);\n\telse\n\t\tprint_iostat_header_impl(cb, column_width, name);\n\n\tprint_iostat_histo(nva, names_len, cb, column_width,\n\t    namewidth, scale);\n\n\tfree_calc_stats(nva, names_len);\n\tif (!cb->cb_scripted)\n\t\tprint_solid_separator(entire_width);\n}\n\n \nstatic uint64_t\nsingle_histo_average(uint64_t *histo, unsigned int buckets)\n{\n\tint i;\n\tuint64_t count = 0, total = 0;\n\n\tfor (i = 0; i < buckets; i++) {\n\t\t \n\t\tif (histo[i] != 0) {\n\t\t\ttotal += histo[i] * (((1UL << i) + ((1UL << i)/2)));\n\t\t\tcount += histo[i];\n\t\t}\n\t}\n\n\t \n\treturn (count == 0 ? 0 : total / count);\n}\n\nstatic void\nprint_iostat_queues(iostat_cbdata_t *cb, nvlist_t *newnv)\n{\n\tconst char *names[] = {\n\t\tZPOOL_CONFIG_VDEV_SYNC_R_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_SYNC_W_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_SYNC_W_ACTIVE_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_ASYNC_R_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_ASYNC_R_ACTIVE_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_ASYNC_W_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_ASYNC_W_ACTIVE_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_SCRUB_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_SCRUB_ACTIVE_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_TRIM_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_TRIM_ACTIVE_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_REBUILD_PEND_QUEUE,\n\t\tZPOOL_CONFIG_VDEV_REBUILD_ACTIVE_QUEUE,\n\t};\n\n\tstruct stat_array *nva;\n\n\tunsigned int column_width = default_column_width(cb, IOS_QUEUES);\n\tenum zfs_nicenum_format format;\n\n\tnva = calc_and_alloc_stats_ex(names, ARRAY_SIZE(names), NULL, newnv);\n\n\tif (cb->cb_literal)\n\t\tformat = ZFS_NICENUM_RAW;\n\telse\n\t\tformat = ZFS_NICENUM_1024;\n\n\tfor (int i = 0; i < ARRAY_SIZE(names); i++) {\n\t\tuint64_t val = nva[i].data[0];\n\t\tprint_one_stat(val, format, column_width, cb->cb_scripted);\n\t}\n\n\tfree_calc_stats(nva, ARRAY_SIZE(names));\n}\n\nstatic void\nprint_iostat_latency(iostat_cbdata_t *cb, nvlist_t *oldnv,\n    nvlist_t *newnv)\n{\n\tint i;\n\tuint64_t val;\n\tconst char *names[] = {\n\t\tZPOOL_CONFIG_VDEV_TOT_R_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_TOT_W_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_DISK_R_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_DISK_W_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_SYNC_R_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_SYNC_W_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_ASYNC_R_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_ASYNC_W_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_SCRUB_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_TRIM_LAT_HISTO,\n\t\tZPOOL_CONFIG_VDEV_REBUILD_LAT_HISTO,\n\t};\n\tstruct stat_array *nva;\n\n\tunsigned int column_width = default_column_width(cb, IOS_LATENCY);\n\tenum zfs_nicenum_format format;\n\n\tnva = calc_and_alloc_stats_ex(names, ARRAY_SIZE(names), oldnv, newnv);\n\n\tif (cb->cb_literal)\n\t\tformat = ZFS_NICENUM_RAWTIME;\n\telse\n\t\tformat = ZFS_NICENUM_TIME;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(names); i++) {\n\t\t \n\t\tval = single_histo_average(nva[i].data, nva[i].count);\n\t\tprint_one_stat(val, format, column_width, cb->cb_scripted);\n\t}\n\tfree_calc_stats(nva, ARRAY_SIZE(names));\n}\n\n \nstatic void\nprint_iostat_default(vdev_stat_t *vs, iostat_cbdata_t *cb, double scale)\n{\n\tunsigned int column_width = default_column_width(cb, IOS_DEFAULT);\n\tenum zfs_nicenum_format format;\n\tchar na;\t \n\n\tif (cb->cb_literal) {\n\t\tformat = ZFS_NICENUM_RAW;\n\t\tna = '0';\n\t} else {\n\t\tformat = ZFS_NICENUM_1024;\n\t\tna = '-';\n\t}\n\n\t \n\tif (vs->vs_space == 0) {\n\t\tif (cb->cb_scripted)\n\t\t\tprintf(\"\\t%c\\t%c\", na, na);\n\t\telse\n\t\t\tprintf(\"  %*c  %*c\", column_width, na, column_width,\n\t\t\t    na);\n\t} else {\n\t\tprint_one_stat(vs->vs_alloc, format, column_width,\n\t\t    cb->cb_scripted);\n\t\tprint_one_stat(vs->vs_space - vs->vs_alloc, format,\n\t\t    column_width, cb->cb_scripted);\n\t}\n\n\tprint_one_stat((uint64_t)(vs->vs_ops[ZIO_TYPE_READ] * scale),\n\t    format, column_width, cb->cb_scripted);\n\tprint_one_stat((uint64_t)(vs->vs_ops[ZIO_TYPE_WRITE] * scale),\n\t    format, column_width, cb->cb_scripted);\n\tprint_one_stat((uint64_t)(vs->vs_bytes[ZIO_TYPE_READ] * scale),\n\t    format, column_width, cb->cb_scripted);\n\tprint_one_stat((uint64_t)(vs->vs_bytes[ZIO_TYPE_WRITE] * scale),\n\t    format, column_width, cb->cb_scripted);\n}\n\nstatic const char *const class_name[] = {\n\tVDEV_ALLOC_BIAS_DEDUP,\n\tVDEV_ALLOC_BIAS_SPECIAL,\n\tVDEV_ALLOC_CLASS_LOGS\n};\n\n \nstatic unsigned int\nprint_vdev_stats(zpool_handle_t *zhp, const char *name, nvlist_t *oldnv,\n    nvlist_t *newnv, iostat_cbdata_t *cb, int depth)\n{\n\tnvlist_t **oldchild, **newchild;\n\tuint_t c, children, oldchildren;\n\tvdev_stat_t *oldvs, *newvs, *calcvs;\n\tvdev_stat_t zerovs = { 0 };\n\tchar *vname;\n\tint i;\n\tint ret = 0;\n\tuint64_t tdelta;\n\tdouble scale;\n\n\tif (strcmp(name, VDEV_TYPE_INDIRECT) == 0)\n\t\treturn (ret);\n\n\tcalcvs = safe_malloc(sizeof (*calcvs));\n\n\tif (oldnv != NULL) {\n\t\tverify(nvlist_lookup_uint64_array(oldnv,\n\t\t    ZPOOL_CONFIG_VDEV_STATS, (uint64_t **)&oldvs, &c) == 0);\n\t} else {\n\t\toldvs = &zerovs;\n\t}\n\n\t \n\tfor (i = 0; i < cb->cb_vdevs.cb_names_count; i++) {\n\t\t \n\t\tif (strcmp(name, cb->cb_vdevs.cb_names[i]) == 0) {\n\t\t\t \n\t\t\tdepth = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cb->cb_vdevs.cb_names_count && (i == cb->cb_vdevs.cb_names_count)) {\n\t\t \n\t\tgoto children;\n\t}\n\n\n\tverify(nvlist_lookup_uint64_array(newnv, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&newvs, &c) == 0);\n\n\t \n\tif (!(cb->cb_flags & IOS_ANYHISTO_M)) {\n\t\tif (cb->cb_scripted) {\n\t\t\tprintf(\"%s\", name);\n\t\t} else {\n\t\t\tif (strlen(name) + depth > cb->cb_namewidth)\n\t\t\t\t(void) printf(\"%*s%s\", depth, \"\", name);\n\t\t\telse\n\t\t\t\t(void) printf(\"%*s%s%*s\", depth, \"\", name,\n\t\t\t\t    (int)(cb->cb_namewidth - strlen(name) -\n\t\t\t\t    depth), \"\");\n\t\t}\n\t}\n\n\t \n\ttdelta = newvs->vs_timestamp - oldvs->vs_timestamp;\n\tif ((oldvs->vs_timestamp == 0) && (cb->cb_flags & IOS_ANYHISTO_M)) {\n\t\t \n\t\tscale = 1;\n\t} else {\n\t\tif (tdelta == 0)\n\t\t\tscale = 1.0;\n\t\telse\n\t\t\tscale = (double)NANOSEC / tdelta;\n\t}\n\n\tif (cb->cb_flags & IOS_DEFAULT_M) {\n\t\tcalc_default_iostats(oldvs, newvs, calcvs);\n\t\tprint_iostat_default(calcvs, cb, scale);\n\t}\n\tif (cb->cb_flags & IOS_LATENCY_M)\n\t\tprint_iostat_latency(cb, oldnv, newnv);\n\tif (cb->cb_flags & IOS_QUEUES_M)\n\t\tprint_iostat_queues(cb, newnv);\n\tif (cb->cb_flags & IOS_ANYHISTO_M) {\n\t\tprintf(\"\\n\");\n\t\tprint_iostat_histos(cb, oldnv, newnv, scale, name);\n\t}\n\n\tif (cb->vcdl != NULL) {\n\t\tconst char *path;\n\t\tif (nvlist_lookup_string(newnv, ZPOOL_CONFIG_PATH,\n\t\t    &path) == 0) {\n\t\t\tprintf(\"  \");\n\t\t\tzpool_print_cmd(cb->vcdl, zpool_get_name(zhp), path);\n\t\t}\n\t}\n\n\tif (!(cb->cb_flags & IOS_ANYHISTO_M))\n\t\tprintf(\"\\n\");\n\n\tret++;\n\nchildren:\n\n\tfree(calcvs);\n\n\tif (!cb->cb_verbose)\n\t\treturn (ret);\n\n\tif (nvlist_lookup_nvlist_array(newnv, ZPOOL_CONFIG_CHILDREN,\n\t    &newchild, &children) != 0)\n\t\treturn (ret);\n\n\tif (oldnv) {\n\t\tif (nvlist_lookup_nvlist_array(oldnv, ZPOOL_CONFIG_CHILDREN,\n\t\t    &oldchild, &oldchildren) != 0)\n\t\t\treturn (ret);\n\n\t\tchildren = MIN(oldchildren, children);\n\t}\n\n\t \n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t ishole = B_FALSE, islog = B_FALSE;\n\n\t\t(void) nvlist_lookup_uint64(newchild[c], ZPOOL_CONFIG_IS_HOLE,\n\t\t    &ishole);\n\n\t\t(void) nvlist_lookup_uint64(newchild[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &islog);\n\n\t\tif (ishole || islog)\n\t\t\tcontinue;\n\n\t\tif (nvlist_exists(newchild[c], ZPOOL_CONFIG_ALLOCATION_BIAS))\n\t\t\tcontinue;\n\n\t\tvname = zpool_vdev_name(g_zfs, zhp, newchild[c],\n\t\t    cb->cb_vdevs.cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\tret += print_vdev_stats(zhp, vname, oldnv ? oldchild[c] : NULL,\n\t\t    newchild[c], cb, depth + 2);\n\t\tfree(vname);\n\t}\n\n\t \n\tfor (uint_t n = 0; n < ARRAY_SIZE(class_name); n++) {\n\t\tboolean_t printed = B_FALSE;\n\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tuint64_t islog = B_FALSE;\n\t\t\tconst char *bias = NULL;\n\t\t\tconst char *type = NULL;\n\n\t\t\t(void) nvlist_lookup_uint64(newchild[c],\n\t\t\t    ZPOOL_CONFIG_IS_LOG, &islog);\n\t\t\tif (islog) {\n\t\t\t\tbias = VDEV_ALLOC_CLASS_LOGS;\n\t\t\t} else {\n\t\t\t\t(void) nvlist_lookup_string(newchild[c],\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, &bias);\n\t\t\t\t(void) nvlist_lookup_string(newchild[c],\n\t\t\t\t    ZPOOL_CONFIG_TYPE, &type);\n\t\t\t}\n\t\t\tif (bias == NULL || strcmp(bias, class_name[n]) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!islog && strcmp(type, VDEV_TYPE_INDIRECT) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed) {\n\t\t\t\tif ((!(cb->cb_flags & IOS_ANYHISTO_M)) &&\n\t\t\t\t    !cb->cb_scripted &&\n\t\t\t\t    !cb->cb_vdevs.cb_names) {\n\t\t\t\t\tprint_iostat_dashes(cb, 0,\n\t\t\t\t\t    class_name[n]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprinted = B_TRUE;\n\t\t\t}\n\n\t\t\tvname = zpool_vdev_name(g_zfs, zhp, newchild[c],\n\t\t\t    cb->cb_vdevs.cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\t\tret += print_vdev_stats(zhp, vname, oldnv ?\n\t\t\t    oldchild[c] : NULL, newchild[c], cb, depth + 2);\n\t\t\tfree(vname);\n\t\t}\n\t}\n\n\t \n\tif (nvlist_lookup_nvlist_array(newnv, ZPOOL_CONFIG_L2CACHE,\n\t    &newchild, &children) != 0)\n\t\treturn (ret);\n\n\tif (oldnv) {\n\t\tif (nvlist_lookup_nvlist_array(oldnv, ZPOOL_CONFIG_L2CACHE,\n\t\t    &oldchild, &oldchildren) != 0)\n\t\t\treturn (ret);\n\n\t\tchildren = MIN(oldchildren, children);\n\t}\n\n\tif (children > 0) {\n\t\tif ((!(cb->cb_flags & IOS_ANYHISTO_M)) && !cb->cb_scripted &&\n\t\t    !cb->cb_vdevs.cb_names) {\n\t\t\tprint_iostat_dashes(cb, 0, \"cache\");\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tvname = zpool_vdev_name(g_zfs, zhp, newchild[c],\n\t\t\t    cb->cb_vdevs.cb_name_flags);\n\t\t\tret += print_vdev_stats(zhp, vname, oldnv ? oldchild[c]\n\t\t\t    : NULL, newchild[c], cb, depth + 2);\n\t\t\tfree(vname);\n\t\t}\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nrefresh_iostat(zpool_handle_t *zhp, void *data)\n{\n\tiostat_cbdata_t *cb = data;\n\tboolean_t missing;\n\n\t \n\tif (zpool_refresh_stats(zhp, &missing) != 0)\n\t\treturn (-1);\n\n\tif (missing)\n\t\tpool_list_remove(cb->cb_list, zhp);\n\n\treturn (0);\n}\n\n \nstatic int\nprint_iostat(zpool_handle_t *zhp, void *data)\n{\n\tiostat_cbdata_t *cb = data;\n\tnvlist_t *oldconfig, *newconfig;\n\tnvlist_t *oldnvroot, *newnvroot;\n\tint ret;\n\n\tnewconfig = zpool_get_config(zhp, &oldconfig);\n\n\tif (cb->cb_iteration == 1)\n\t\toldconfig = NULL;\n\n\tverify(nvlist_lookup_nvlist(newconfig, ZPOOL_CONFIG_VDEV_TREE,\n\t    &newnvroot) == 0);\n\n\tif (oldconfig == NULL)\n\t\toldnvroot = NULL;\n\telse\n\t\tverify(nvlist_lookup_nvlist(oldconfig, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &oldnvroot) == 0);\n\n\tret = print_vdev_stats(zhp, zpool_get_name(zhp), oldnvroot, newnvroot,\n\t    cb, 0);\n\tif ((ret != 0) && !(cb->cb_flags & IOS_ANYHISTO_M) &&\n\t    !cb->cb_scripted && cb->cb_verbose &&\n\t    !cb->cb_vdevs.cb_names_count) {\n\t\tprint_iostat_separator(cb);\n\t\tif (cb->vcdl != NULL) {\n\t\t\tprint_cmd_columns(cb->vcdl, 1);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nget_columns(void)\n{\n\tstruct winsize ws;\n\tint columns = 80;\n\tint error;\n\n\tif (isatty(STDOUT_FILENO)) {\n\t\terror = ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws);\n\t\tif (error == 0)\n\t\t\tcolumns = ws.ws_col;\n\t} else {\n\t\tcolumns = 999;\n\t}\n\n\treturn (columns);\n}\n\n \nstatic int\nget_namewidth(zpool_handle_t *zhp, int min_width, int flags, boolean_t verbose)\n{\n\tnvlist_t *config, *nvroot;\n\tint width = min_width;\n\n\tif ((config = zpool_get_config(zhp, NULL)) != NULL) {\n\t\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &nvroot) == 0);\n\t\tsize_t poolname_len = strlen(zpool_get_name(zhp));\n\t\tif (verbose == B_FALSE) {\n\t\t\twidth = MAX(poolname_len, min_width);\n\t\t} else {\n\t\t\twidth = MAX(poolname_len,\n\t\t\t    max_width(zhp, nvroot, 0, min_width, flags));\n\t\t}\n\t}\n\n\treturn (width);\n}\n\n \nstatic void\nget_interval_count(int *argcp, char **argv, float *iv,\n    unsigned long *cnt)\n{\n\tfloat interval = 0;\n\tunsigned long count = 0;\n\tint argc = *argcp;\n\n\t \n\tif (argc > 0 && zfs_isnumber(argv[argc - 1])) {\n\t\tchar *end;\n\n\t\terrno = 0;\n\t\tinterval = strtof(argv[argc - 1], &end);\n\n\t\tif (*end == '\\0' && errno == 0) {\n\t\t\tif (interval == 0) {\n\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t    \"interval cannot be zero\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\t \n\t\t\targc--;\n\t\t} else {\n\t\t\t \n\t\t\tinterval = 0;\n\t\t}\n\t}\n\n\t \n\tif (argc > 0 && zfs_isnumber(argv[argc - 1])) {\n\t\tchar *end;\n\n\t\terrno = 0;\n\t\tcount = interval;\n\t\tinterval = strtof(argv[argc - 1], &end);\n\n\t\tif (*end == '\\0' && errno == 0) {\n\t\t\tif (interval == 0) {\n\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t    \"interval cannot be zero\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\n\t\t\t \n\t\t\targc--;\n\t\t} else {\n\t\t\tinterval = 0;\n\t\t}\n\t}\n\n\t*iv = interval;\n\t*cnt = count;\n\t*argcp = argc;\n}\n\nstatic void\nget_timestamp_arg(char c)\n{\n\tif (c == 'u')\n\t\ttimestamp_fmt = UDATE;\n\telse if (c == 'd')\n\t\ttimestamp_fmt = DDATE;\n\telse\n\t\tusage(B_FALSE);\n}\n\n \nstatic int\nget_stat_flags_cb(zpool_handle_t *zhp, void *data)\n{\n\tuint64_t *mask = data;\n\tnvlist_t *config, *nvroot, *nvx;\n\tuint64_t flags = 0;\n\tint i, j;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) == 0);\n\n\t \n\tif (nvlist_exists(nvroot, ZPOOL_CONFIG_VDEV_STATS))\n\t\tflags |= IOS_DEFAULT_M;\n\n\t \n\tif (nvlist_lookup_nvlist(nvroot, ZPOOL_CONFIG_VDEV_STATS_EX,\n\t    &nvx) != 0) {\n\t\t \n\t\tgoto end;\n\t}\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(vsx_type_to_nvlist); j++) {\n\t\tif (!vsx_type_to_nvlist[j][0])\n\t\t\tcontinue;\n\n\t\t \n\t\tflags |= (1ULL << j);\n\t\tfor (i = 0; vsx_type_to_nvlist[j][i]; i++) {\n\t\t\tif (!nvlist_exists(nvx, vsx_type_to_nvlist[j][i])) {\n\t\t\t\t \n\t\t\t\tflags = flags & ~(1ULL  << j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nend:\n\t*mask = *mask & flags;\n\treturn (0);\n}\n\n \nstatic uint64_t\nget_stat_flags(zpool_list_t *list)\n{\n\tuint64_t mask = -1;\n\n\t \n\tpool_list_iter(list, B_FALSE, get_stat_flags_cb, &mask);\n\treturn (mask);\n}\n\n \nstatic int\nis_vdev_cb(void *zhp_data, nvlist_t *nv, void *cb_data)\n{\n\tuint64_t guid;\n\tvdev_cbdata_t *cb = cb_data;\n\tzpool_handle_t *zhp = zhp_data;\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) != 0)\n\t\treturn (0);\n\n\treturn (guid == zpool_vdev_path_to_guid(zhp, cb->cb_names[0]));\n}\n\n \nstatic int\nis_vdev(zpool_handle_t *zhp, void *cb_data)\n{\n\treturn (for_each_vdev(zhp, is_vdev_cb, cb_data));\n}\n\n \nstatic int\nare_vdevs_in_pool(int argc, char **argv, char *pool_name,\n    vdev_cbdata_t *cb)\n{\n\tchar **tmp_name;\n\tint ret = 0;\n\tint i;\n\tint pool_count = 0;\n\n\tif ((argc == 0) || !*argv)\n\t\treturn (0);\n\n\tif (pool_name)\n\t\tpool_count = 1;\n\n\t \n\ttmp_name = cb->cb_names;\n\n\t \n\tfor (i = 0; i < argc; i++) {\n\t\tcb->cb_names = argv + i;\n\n\t\t \n\t\tret = for_each_pool(pool_count, &pool_name, B_TRUE, NULL,\n\t\t    ZFS_TYPE_POOL, B_FALSE, is_vdev, cb);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->cb_names = tmp_name;\n\n\treturn (ret);\n}\n\nstatic int\nis_pool_cb(zpool_handle_t *zhp, void *data)\n{\n\tchar *name = data;\n\tif (strcmp(name, zpool_get_name(zhp)) == 0)\n\t\treturn (1);\n\n\treturn (0);\n}\n\n \nstatic int\nis_pool(char *name)\n{\n\treturn (for_each_pool(0, NULL, B_TRUE, NULL, ZFS_TYPE_POOL, B_FALSE,\n\t    is_pool_cb, name));\n}\n\n \nstatic int\nare_all_pools(int argc, char **argv)\n{\n\tif ((argc == 0) || !*argv)\n\t\treturn (0);\n\n\twhile (--argc >= 0)\n\t\tif (!is_pool(argv[argc]))\n\t\t\treturn (0);\n\n\treturn (1);\n}\n\n \nstatic void\nerror_list_unresolved_vdevs(int argc, char **argv, char *pool_name,\n    vdev_cbdata_t *cb)\n{\n\tint i;\n\tchar *name;\n\tchar *str;\n\tfor (i = 0; i < argc; i++) {\n\t\tname = argv[i];\n\n\t\tif (is_pool(name))\n\t\t\tstr = gettext(\"pool\");\n\t\telse if (are_vdevs_in_pool(1, &name, pool_name, cb))\n\t\t\tstr = gettext(\"vdev in this pool\");\n\t\telse if (are_vdevs_in_pool(1, &name, NULL, cb))\n\t\t\tstr = gettext(\"vdev in another pool\");\n\t\telse\n\t\t\tstr = gettext(\"unknown\");\n\n\t\tfprintf(stderr, \"\\t%s (%s)\\n\", name, str);\n\t}\n}\n\n \nstatic void\nget_interval_count_filter_guids(int *argc, char **argv, float *interval,\n    unsigned long *count, iostat_cbdata_t *cb)\n{\n\tchar **tmpargv = argv;\n\tint argc_for_interval = 0;\n\n\t \n\tif (*argc >= 1 && !are_vdevs_in_pool(1, &argv[*argc - 1], NULL,\n\t    &cb->cb_vdevs)) {\n\t\t \n\t\targc_for_interval++;\n\n\t\tif (*argc >= 2 &&\n\t\t    !are_vdevs_in_pool(1, &argv[*argc - 2], NULL,\n\t\t    &cb->cb_vdevs)) {\n\t\t\t \n\t\t\targc_for_interval++;\n\t\t}\n\t}\n\n\t \n\ttmpargv = &argv[*argc - argc_for_interval];\n\n\t*argc = *argc - argc_for_interval;\n\tget_interval_count(&argc_for_interval, tmpargv,\n\t    interval, count);\n}\n\n \nstatic void\nfsleep(float sec)\n{\n\tstruct timespec req;\n\treq.tv_sec = floor(sec);\n\treq.tv_nsec = (sec - (float)req.tv_sec) * NANOSEC;\n\tnanosleep(&req, NULL);\n}\n\n \nstatic int\nterminal_height(void)\n{\n\tstruct winsize win;\n\n\tif (isatty(STDOUT_FILENO) == 0)\n\t\treturn (-1);\n\n\tif (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != -1 && win.ws_row > 0)\n\t\treturn (win.ws_row);\n\n\treturn (-1);\n}\n\n \nstatic void\nprint_zpool_script_help(char *name, char *path)\n{\n\tchar *argv[] = {path, (char *)\"-h\", NULL};\n\tchar **lines = NULL;\n\tint lines_cnt = 0;\n\tint rc;\n\n\trc = libzfs_run_process_get_stdout_nopath(path, argv, NULL, &lines,\n\t    &lines_cnt);\n\tif (rc != 0 || lines == NULL || lines_cnt <= 0) {\n\t\tif (lines != NULL)\n\t\t\tlibzfs_free_str_array(lines, lines_cnt);\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < lines_cnt; i++)\n\t\tif (!is_blank_str(lines[i]))\n\t\t\tprintf(\"  %-14s  %s\\n\", name, lines[i]);\n\n\tlibzfs_free_str_array(lines, lines_cnt);\n}\n\n \nstatic void\nprint_zpool_dir_scripts(char *dirpath)\n{\n\tDIR *dir;\n\tstruct dirent *ent;\n\tchar fullpath[MAXPATHLEN];\n\tstruct stat dir_stat;\n\n\tif ((dir = opendir(dirpath)) != NULL) {\n\t\t \n\t\twhile ((ent = readdir(dir)) != NULL) {\n\t\t\tif (snprintf(fullpath, sizeof (fullpath), \"%s/%s\",\n\t\t\t    dirpath, ent->d_name) >= sizeof (fullpath)) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"internal error: \"\n\t\t\t\t    \"ZPOOL_SCRIPTS_PATH too large.\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (stat(fullpath, &dir_stat) == 0)\n\t\t\t\tif (dir_stat.st_mode & S_IXUSR &&\n\t\t\t\t    S_ISREG(dir_stat.st_mode))\n\t\t\t\t\tprint_zpool_script_help(ent->d_name,\n\t\t\t\t\t    fullpath);\n\t\t}\n\t\tclosedir(dir);\n\t}\n}\n\n \nstatic void\nprint_zpool_script_list(const char *subcommand)\n{\n\tchar *dir, *sp, *tmp;\n\n\tprintf(gettext(\"Available 'zpool %s -c' commands:\\n\"), subcommand);\n\n\tsp = zpool_get_cmd_search_path();\n\tif (sp == NULL)\n\t\treturn;\n\n\tfor (dir = strtok_r(sp, \":\", &tmp);\n\t    dir != NULL;\n\t    dir = strtok_r(NULL, \":\", &tmp))\n\t\tprint_zpool_dir_scripts(dir);\n\n\tfree(sp);\n}\n\n \nstatic int\nget_namewidth_iostat(zpool_handle_t *zhp, void *data)\n{\n\tiostat_cbdata_t *cb = data;\n\tint width, available_width;\n\n\t \n\twidth = get_namewidth(zhp, cb->cb_namewidth,\n\t    cb->cb_vdevs.cb_name_flags | VDEV_NAME_TYPE_ID, cb->cb_verbose);\n\n\t \n\tavailable_width = get_columns() - 42;\n\n\t \n\tif (width > available_width)\n\t\twidth = available_width;\n\n\t \n\tif (width < 10)\n\t\twidth = 10;\n\n\t \n\tcb->cb_namewidth = width;\n\n\treturn (0);\n}\n\n \nint\nzpool_do_iostat(int argc, char **argv)\n{\n\tint c;\n\tint ret;\n\tint npools;\n\tfloat interval = 0;\n\tunsigned long count = 0;\n\tint winheight = 24;\n\tzpool_list_t *list;\n\tboolean_t verbose = B_FALSE;\n\tboolean_t latency = B_FALSE, l_histo = B_FALSE, rq_histo = B_FALSE;\n\tboolean_t queues = B_FALSE, parsable = B_FALSE, scripted = B_FALSE;\n\tboolean_t omit_since_boot = B_FALSE;\n\tboolean_t guid = B_FALSE;\n\tboolean_t follow_links = B_FALSE;\n\tboolean_t full_name = B_FALSE;\n\tboolean_t headers_once = B_FALSE;\n\tiostat_cbdata_t cb = { 0 };\n\tchar *cmd = NULL;\n\n\t \n\tconst char flag_to_arg[] = {[IOS_LATENCY] = 'l', [IOS_QUEUES] = 'q',\n\t    [IOS_L_HISTO] = 'w', [IOS_RQ_HISTO] = 'r'};\n\n\tuint64_t unsupported_flags;\n\n\t \n\twhile ((c = getopt(argc, argv, \"c:gLPT:vyhplqrwnH\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (cmd != NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    gettext(\"Can't set -c flag twice\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (getenv(\"ZPOOL_SCRIPTS_ENABLED\") != NULL &&\n\t\t\t    !libzfs_envvar_is_set(\"ZPOOL_SCRIPTS_ENABLED\")) {\n\t\t\t\tfprintf(stderr, gettext(\n\t\t\t\t    \"Can't run -c, disabled by \"\n\t\t\t\t    \"ZPOOL_SCRIPTS_ENABLED.\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((getuid() <= 0 || geteuid() <= 0) &&\n\t\t\t    !libzfs_envvar_is_set(\"ZPOOL_SCRIPTS_AS_ROOT\")) {\n\t\t\t\tfprintf(stderr, gettext(\n\t\t\t\t    \"Can't run -c with root privileges \"\n\t\t\t\t    \"unless ZPOOL_SCRIPTS_AS_ROOT is set.\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcmd = optarg;\n\t\t\tverbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tguid = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tfollow_links = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tfull_name = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tget_timestamp_arg(*optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparsable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlatency = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tqueues = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tscripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tl_histo = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trq_histo = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tomit_since_boot = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\theaders_once = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tif (optopt == 'c') {\n\t\t\t\tprint_zpool_script_list(\"iostat\");\n\t\t\t\texit(0);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\t}\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tcb.cb_literal = parsable;\n\tcb.cb_scripted = scripted;\n\n\tif (guid)\n\t\tcb.cb_vdevs.cb_name_flags |= VDEV_NAME_GUID;\n\tif (follow_links)\n\t\tcb.cb_vdevs.cb_name_flags |= VDEV_NAME_FOLLOW_LINKS;\n\tif (full_name)\n\t\tcb.cb_vdevs.cb_name_flags |= VDEV_NAME_PATH;\n\tcb.cb_iteration = 0;\n\tcb.cb_namewidth = 0;\n\tcb.cb_verbose = verbose;\n\n\t \n\tif (guid) {\n\t\tget_interval_count_filter_guids(&argc, argv, &interval,\n\t\t    &count, &cb);\n\t} else {\n\t\tget_interval_count(&argc, argv, &interval, &count);\n\t}\n\n\tif (argc == 0) {\n\t\t \n\t} else if (are_all_pools(argc, argv)) {\n\t\t \n\t} else if (are_vdevs_in_pool(argc, argv, NULL, &cb.cb_vdevs)) {\n\t\t \n\t\tcb.cb_vdevs.cb_names = argv;\n\t\tcb.cb_vdevs.cb_names_count = argc;\n\t\targc = 0;  \n\t} else if (are_all_pools(1, argv)) {\n\t\t \n\t\tif (are_vdevs_in_pool(argc - 1, argv + 1, argv[0],\n\t\t    &cb.cb_vdevs)) {\n\t\t\t \n\t\t\tcb.cb_vdevs.cb_names = argv + 1;\n\t\t\tcb.cb_vdevs.cb_names_count = argc - 1;\n\t\t\targc = 1;  \n\t\t} else {\n\t\t\tfprintf(stderr, gettext(\"Expected either a list of \"));\n\t\t\tfprintf(stderr, gettext(\"pools, or list of vdevs in\"));\n\t\t\tfprintf(stderr, \" \\\"%s\\\", \", argv[0]);\n\t\t\tfprintf(stderr, gettext(\"but got:\\n\"));\n\t\t\terror_list_unresolved_vdevs(argc - 1, argv + 1,\n\t\t\t    argv[0], &cb.cb_vdevs);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tusage(B_FALSE);\n\t\t\treturn (1);\n\t\t}\n\t} else {\n\t\t \n\t\tfprintf(stderr, gettext(\"Unable to parse pools/vdevs list.\\n\"));\n\t\tfprintf(stderr, \"\\n\");\n\t\treturn (1);\n\t}\n\n\tif (cb.cb_vdevs.cb_names_count != 0) {\n\t\t \n\t\tcb.cb_verbose = B_TRUE;\n\t}\n\n\t \n\tret = 0;\n\tif ((list = pool_list_get(argc, argv, NULL, ZFS_TYPE_POOL, parsable,\n\t    &ret)) == NULL)\n\t\treturn (1);\n\n\tif (pool_list_count(list) == 0 && argc != 0) {\n\t\tpool_list_free(list);\n\t\treturn (1);\n\t}\n\n\tif (pool_list_count(list) == 0 && interval == 0) {\n\t\tpool_list_free(list);\n\t\t(void) fprintf(stderr, gettext(\"no pools available\\n\"));\n\t\treturn (1);\n\t}\n\n\tif ((l_histo || rq_histo) && (cmd != NULL || latency || queues)) {\n\t\tpool_list_free(list);\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"[-r|-w] isn't allowed with [-c|-l|-q]\\n\"));\n\t\tusage(B_FALSE);\n\t\treturn (1);\n\t}\n\n\tif (l_histo && rq_histo) {\n\t\tpool_list_free(list);\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Only one of [-r|-w] can be passed at a time\\n\"));\n\t\tusage(B_FALSE);\n\t\treturn (1);\n\t}\n\n\t \n\tcb.cb_list = list;\n\n\tif (l_histo) {\n\t\t \n\t\tcb.cb_flags = IOS_L_HISTO_M;\n\t} else if (rq_histo) {\n\t\tcb.cb_flags = IOS_RQ_HISTO_M;\n\t} else {\n\t\tcb.cb_flags = IOS_DEFAULT_M;\n\t\tif (latency)\n\t\t\tcb.cb_flags |= IOS_LATENCY_M;\n\t\tif (queues)\n\t\t\tcb.cb_flags |= IOS_QUEUES_M;\n\t}\n\n\t \n\tunsupported_flags = cb.cb_flags & ~get_stat_flags(list);\n\tif (unsupported_flags) {\n\t\tuint64_t f;\n\t\tint idx;\n\t\tfprintf(stderr,\n\t\t    gettext(\"The loaded zfs module doesn't support:\"));\n\n\t\t \n\t\tfor (f = unsupported_flags; f; f &= ~(1ULL << idx)) {\n\t\t\tidx = lowbit64(f) - 1;\n\t\t\tfprintf(stderr, \" -%c\", flag_to_arg[idx]);\n\t\t}\n\n\t\tfprintf(stderr, \".  Try running a newer module.\\n\");\n\t\tpool_list_free(list);\n\n\t\treturn (1);\n\t}\n\n\tfor (;;) {\n\t\tif ((npools = pool_list_count(list)) == 0)\n\t\t\t(void) fprintf(stderr, gettext(\"no pools available\\n\"));\n\t\telse {\n\t\t\t \n\t\t\tboolean_t skip = (omit_since_boot &&\n\t\t\t    cb.cb_iteration == 0);\n\n\t\t\t \n\t\t\t(void) pool_list_iter(list, B_FALSE, refresh_iostat,\n\t\t\t    &cb);\n\n\t\t\t \n\t\t\tcb.cb_namewidth = 0;\n\t\t\t(void) pool_list_iter(list, B_FALSE,\n\t\t\t    get_namewidth_iostat, &cb);\n\n\t\t\tif (timestamp_fmt != NODATE)\n\t\t\t\tprint_timestamp(timestamp_fmt);\n\n\t\t\tif (cmd != NULL && cb.cb_verbose &&\n\t\t\t    !(cb.cb_flags & IOS_ANYHISTO_M)) {\n\t\t\t\tcb.vcdl = all_pools_for_each_vdev_run(argc,\n\t\t\t\t    argv, cmd, g_zfs, cb.cb_vdevs.cb_names,\n\t\t\t\t    cb.cb_vdevs.cb_names_count,\n\t\t\t\t    cb.cb_vdevs.cb_name_flags);\n\t\t\t} else {\n\t\t\t\tcb.vcdl = NULL;\n\t\t\t}\n\n\n\t\t\t \n\t\t\twinheight = terminal_height();\n\t\t\t \n\t\t\tif (winheight < 0)\n\t\t\t\theaders_once = B_TRUE;\n\n\t\t\t \n\t\t\tif (((++cb.cb_iteration == 1 && !skip) ||\n\t\t\t    (skip != verbose) ||\n\t\t\t    (!headers_once &&\n\t\t\t    (cb.cb_iteration % winheight) == 0)) &&\n\t\t\t    (!(cb.cb_flags & IOS_ANYHISTO_M)) &&\n\t\t\t    !cb.cb_scripted)\n\t\t\t\tprint_iostat_header(&cb);\n\n\t\t\tif (skip) {\n\t\t\t\t(void) fsleep(interval);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpool_list_iter(list, B_FALSE, print_iostat, &cb);\n\n\t\t\t \n\t\t\tif (((npools > 1 && !verbose &&\n\t\t\t    !(cb.cb_flags & IOS_ANYHISTO_M)) ||\n\t\t\t    (!(cb.cb_flags & IOS_ANYHISTO_M) &&\n\t\t\t    cb.cb_vdevs.cb_names_count)) &&\n\t\t\t    !cb.cb_scripted) {\n\t\t\t\tprint_iostat_separator(&cb);\n\t\t\t\tif (cb.vcdl != NULL)\n\t\t\t\t\tprint_cmd_columns(cb.vcdl, 1);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\n\t\t\tif (cb.vcdl != NULL)\n\t\t\t\tfree_vdev_cmd_data_list(cb.vcdl);\n\n\t\t}\n\n\t\t \n\t\t(void) fflush(stdout);\n\n\t\tif (interval == 0)\n\t\t\tbreak;\n\n\t\tif (count != 0 && --count == 0)\n\t\t\tbreak;\n\n\t\t(void) fsleep(interval);\n\t}\n\n\tpool_list_free(list);\n\n\treturn (ret);\n}\n\ntypedef struct list_cbdata {\n\tboolean_t\tcb_verbose;\n\tint\t\tcb_name_flags;\n\tint\t\tcb_namewidth;\n\tboolean_t\tcb_scripted;\n\tzprop_list_t\t*cb_proplist;\n\tboolean_t\tcb_literal;\n} list_cbdata_t;\n\n\n \nstatic void\nprint_header(list_cbdata_t *cb)\n{\n\tzprop_list_t *pl = cb->cb_proplist;\n\tchar headerbuf[ZPOOL_MAXPROPLEN];\n\tconst char *header;\n\tboolean_t first = B_TRUE;\n\tboolean_t right_justify;\n\tsize_t width = 0;\n\n\tfor (; pl != NULL; pl = pl->pl_next) {\n\t\twidth = pl->pl_width;\n\t\tif (first && cb->cb_verbose) {\n\t\t\t \n\t\t\twidth = cb->cb_namewidth;\n\t\t}\n\n\t\tif (!first)\n\t\t\t(void) fputs(\"  \", stdout);\n\t\telse\n\t\t\tfirst = B_FALSE;\n\n\t\tright_justify = B_FALSE;\n\t\tif (pl->pl_prop != ZPROP_USERPROP) {\n\t\t\theader = zpool_prop_column_name(pl->pl_prop);\n\t\t\tright_justify = zpool_prop_align_right(pl->pl_prop);\n\t\t} else {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; pl->pl_user_prop[i] != '\\0'; i++)\n\t\t\t\theaderbuf[i] = toupper(pl->pl_user_prop[i]);\n\t\t\theaderbuf[i] = '\\0';\n\t\t\theader = headerbuf;\n\t\t}\n\n\t\tif (pl->pl_next == NULL && !right_justify)\n\t\t\t(void) fputs(header, stdout);\n\t\telse if (right_justify)\n\t\t\t(void) printf(\"%*s\", (int)width, header);\n\t\telse\n\t\t\t(void) printf(\"%-*s\", (int)width, header);\n\t}\n\n\t(void) fputc('\\n', stdout);\n}\n\n \nstatic void\nprint_pool(zpool_handle_t *zhp, list_cbdata_t *cb)\n{\n\tzprop_list_t *pl = cb->cb_proplist;\n\tboolean_t first = B_TRUE;\n\tchar property[ZPOOL_MAXPROPLEN];\n\tconst char *propstr;\n\tboolean_t right_justify;\n\tsize_t width;\n\n\tfor (; pl != NULL; pl = pl->pl_next) {\n\n\t\twidth = pl->pl_width;\n\t\tif (first && cb->cb_verbose) {\n\t\t\t \n\t\t\twidth = cb->cb_namewidth;\n\t\t}\n\n\t\tif (!first) {\n\t\t\tif (cb->cb_scripted)\n\t\t\t\t(void) fputc('\\t', stdout);\n\t\t\telse\n\t\t\t\t(void) fputs(\"  \", stdout);\n\t\t} else {\n\t\t\tfirst = B_FALSE;\n\t\t}\n\n\t\tright_justify = B_FALSE;\n\t\tif (pl->pl_prop != ZPROP_USERPROP) {\n\t\t\tif (zpool_get_prop(zhp, pl->pl_prop, property,\n\t\t\t    sizeof (property), NULL, cb->cb_literal) != 0)\n\t\t\t\tpropstr = \"-\";\n\t\t\telse\n\t\t\t\tpropstr = property;\n\n\t\t\tright_justify = zpool_prop_align_right(pl->pl_prop);\n\t\t} else if ((zpool_prop_feature(pl->pl_user_prop) ||\n\t\t    zpool_prop_unsupported(pl->pl_user_prop)) &&\n\t\t    zpool_prop_get_feature(zhp, pl->pl_user_prop, property,\n\t\t    sizeof (property)) == 0) {\n\t\t\tpropstr = property;\n\t\t} else if (zfs_prop_user(pl->pl_user_prop) &&\n\t\t    zpool_get_userprop(zhp, pl->pl_user_prop, property,\n\t\t    sizeof (property), NULL) == 0) {\n\t\t\tpropstr = property;\n\t\t} else {\n\t\t\tpropstr = \"-\";\n\t\t}\n\n\t\t \n\t\tif (cb->cb_scripted || (pl->pl_next == NULL && !right_justify))\n\t\t\t(void) fputs(propstr, stdout);\n\t\telse if (right_justify)\n\t\t\t(void) printf(\"%*s\", (int)width, propstr);\n\t\telse\n\t\t\t(void) printf(\"%-*s\", (int)width, propstr);\n\t}\n\n\t(void) fputc('\\n', stdout);\n}\n\nstatic void\nprint_one_column(zpool_prop_t prop, uint64_t value, const char *str,\n    boolean_t scripted, boolean_t valid, enum zfs_nicenum_format format)\n{\n\tchar propval[64];\n\tboolean_t fixed;\n\tsize_t width = zprop_width(prop, &fixed, ZFS_TYPE_POOL);\n\n\tswitch (prop) {\n\tcase ZPOOL_PROP_SIZE:\n\tcase ZPOOL_PROP_EXPANDSZ:\n\tcase ZPOOL_PROP_CHECKPOINT:\n\tcase ZPOOL_PROP_DEDUPRATIO:\n\t\tif (value == 0)\n\t\t\t(void) strlcpy(propval, \"-\", sizeof (propval));\n\t\telse\n\t\t\tzfs_nicenum_format(value, propval, sizeof (propval),\n\t\t\t    format);\n\t\tbreak;\n\tcase ZPOOL_PROP_FRAGMENTATION:\n\t\tif (value == ZFS_FRAG_INVALID) {\n\t\t\t(void) strlcpy(propval, \"-\", sizeof (propval));\n\t\t} else if (format == ZFS_NICENUM_RAW) {\n\t\t\t(void) snprintf(propval, sizeof (propval), \"%llu\",\n\t\t\t    (unsigned long long)value);\n\t\t} else {\n\t\t\t(void) snprintf(propval, sizeof (propval), \"%llu%%\",\n\t\t\t    (unsigned long long)value);\n\t\t}\n\t\tbreak;\n\tcase ZPOOL_PROP_CAPACITY:\n\t\t \n\t\tif (format == ZFS_NICENUM_RAW)\n\t\t\t(void) snprintf(propval, sizeof (propval), \"%llu\",\n\t\t\t    (unsigned long long)value / 100);\n\t\telse\n\t\t\t(void) snprintf(propval, sizeof (propval),\n\t\t\t    value < 1000 ? \"%1.2f%%\" : value < 10000 ?\n\t\t\t    \"%2.1f%%\" : \"%3.0f%%\", value / 100.0);\n\t\tbreak;\n\tcase ZPOOL_PROP_HEALTH:\n\t\twidth = 8;\n\t\t(void) strlcpy(propval, str, sizeof (propval));\n\t\tbreak;\n\tdefault:\n\t\tzfs_nicenum_format(value, propval, sizeof (propval), format);\n\t}\n\n\tif (!valid)\n\t\t(void) strlcpy(propval, \"-\", sizeof (propval));\n\n\tif (scripted)\n\t\t(void) printf(\"\\t%s\", propval);\n\telse\n\t\t(void) printf(\"  %*s\", (int)width, propval);\n}\n\n \nstatic void\nprint_list_stats(zpool_handle_t *zhp, const char *name, nvlist_t *nv,\n    list_cbdata_t *cb, int depth, boolean_t isspare)\n{\n\tnvlist_t **child;\n\tvdev_stat_t *vs;\n\tuint_t c, children;\n\tchar *vname;\n\tboolean_t scripted = cb->cb_scripted;\n\tuint64_t islog = B_FALSE;\n\tconst char *dashes = \"%-*s      -      -      -        -         \"\n\t    \"-      -      -      -         -\\n\";\n\n\tverify(nvlist_lookup_uint64_array(nv, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\n\tif (name != NULL) {\n\t\tboolean_t toplevel = (vs->vs_space != 0);\n\t\tuint64_t cap;\n\t\tenum zfs_nicenum_format format;\n\t\tconst char *state;\n\n\t\tif (cb->cb_literal)\n\t\t\tformat = ZFS_NICENUM_RAW;\n\t\telse\n\t\t\tformat = ZFS_NICENUM_1024;\n\n\t\tif (strcmp(name, VDEV_TYPE_INDIRECT) == 0)\n\t\t\treturn;\n\n\t\tif (scripted)\n\t\t\t(void) printf(\"\\t%s\", name);\n\t\telse if (strlen(name) + depth > cb->cb_namewidth)\n\t\t\t(void) printf(\"%*s%s\", depth, \"\", name);\n\t\telse\n\t\t\t(void) printf(\"%*s%s%*s\", depth, \"\", name,\n\t\t\t    (int)(cb->cb_namewidth - strlen(name) - depth), \"\");\n\n\t\t \n\t\tif (VDEV_STAT_VALID(vs_pspace, c) && vs->vs_pspace)\n\t\t\tprint_one_column(ZPOOL_PROP_SIZE, vs->vs_pspace, NULL,\n\t\t\t    scripted, B_TRUE, format);\n\t\telse\n\t\t\tprint_one_column(ZPOOL_PROP_SIZE, vs->vs_space, NULL,\n\t\t\t    scripted, toplevel, format);\n\t\tprint_one_column(ZPOOL_PROP_ALLOCATED, vs->vs_alloc, NULL,\n\t\t    scripted, toplevel, format);\n\t\tprint_one_column(ZPOOL_PROP_FREE, vs->vs_space - vs->vs_alloc,\n\t\t    NULL, scripted, toplevel, format);\n\t\tprint_one_column(ZPOOL_PROP_CHECKPOINT,\n\t\t    vs->vs_checkpoint_space, NULL, scripted, toplevel, format);\n\t\tprint_one_column(ZPOOL_PROP_EXPANDSZ, vs->vs_esize, NULL,\n\t\t    scripted, B_TRUE, format);\n\t\tprint_one_column(ZPOOL_PROP_FRAGMENTATION,\n\t\t    vs->vs_fragmentation, NULL, scripted,\n\t\t    (vs->vs_fragmentation != ZFS_FRAG_INVALID && toplevel),\n\t\t    format);\n\t\tcap = (vs->vs_space == 0) ? 0 :\n\t\t    (vs->vs_alloc * 10000 / vs->vs_space);\n\t\tprint_one_column(ZPOOL_PROP_CAPACITY, cap, NULL,\n\t\t    scripted, toplevel, format);\n\t\tprint_one_column(ZPOOL_PROP_DEDUPRATIO, 0, NULL,\n\t\t    scripted, toplevel, format);\n\t\tstate = zpool_state_to_name(vs->vs_state, vs->vs_aux);\n\t\tif (isspare) {\n\t\t\tif (vs->vs_aux == VDEV_AUX_SPARED)\n\t\t\t\tstate = \"INUSE\";\n\t\t\telse if (vs->vs_state == VDEV_STATE_HEALTHY)\n\t\t\t\tstate = \"AVAIL\";\n\t\t}\n\t\tprint_one_column(ZPOOL_PROP_HEALTH, 0, state, scripted,\n\t\t    B_TRUE, format);\n\t\t(void) fputc('\\n', stdout);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\treturn;\n\n\t \n\tfor (c = 0; c < children; c++) {\n\t\tuint64_t ishole = B_FALSE;\n\n\t\tif (nvlist_lookup_uint64(child[c],\n\t\t    ZPOOL_CONFIG_IS_HOLE, &ishole) == 0 && ishole)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(child[c],\n\t\t    ZPOOL_CONFIG_IS_LOG, &islog) == 0 && islog)\n\t\t\tcontinue;\n\n\t\tif (nvlist_exists(child[c], ZPOOL_CONFIG_ALLOCATION_BIAS))\n\t\t\tcontinue;\n\n\t\tvname = zpool_vdev_name(g_zfs, zhp, child[c],\n\t\t    cb->cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\tprint_list_stats(zhp, vname, child[c], cb, depth + 2, B_FALSE);\n\t\tfree(vname);\n\t}\n\n\t \n\tfor (uint_t n = 0; n < ARRAY_SIZE(class_name); n++) {\n\t\tboolean_t printed = B_FALSE;\n\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tconst char *bias = NULL;\n\t\t\tconst char *type = NULL;\n\n\t\t\tif (nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t\t    &islog) == 0 && islog) {\n\t\t\t\tbias = VDEV_ALLOC_CLASS_LOGS;\n\t\t\t} else {\n\t\t\t\t(void) nvlist_lookup_string(child[c],\n\t\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, &bias);\n\t\t\t\t(void) nvlist_lookup_string(child[c],\n\t\t\t\t    ZPOOL_CONFIG_TYPE, &type);\n\t\t\t}\n\t\t\tif (bias == NULL || strcmp(bias, class_name[n]) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!islog && strcmp(type, VDEV_TYPE_INDIRECT) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed) {\n\t\t\t\t \n\t\t\t\t(void) printf(dashes, cb->cb_namewidth,\n\t\t\t\t    class_name[n]);\n\t\t\t\tprinted = B_TRUE;\n\t\t\t}\n\t\t\tvname = zpool_vdev_name(g_zfs, zhp, child[c],\n\t\t\t    cb->cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\t\tprint_list_stats(zhp, vname, child[c], cb, depth + 2,\n\t\t\t    B_FALSE);\n\t\t\tfree(vname);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0 && children > 0) {\n\t\t \n\t\t(void) printf(dashes, cb->cb_namewidth, \"cache\");\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tvname = zpool_vdev_name(g_zfs, zhp, child[c],\n\t\t\t    cb->cb_name_flags);\n\t\t\tprint_list_stats(zhp, vname, child[c], cb, depth + 2,\n\t\t\t    B_FALSE);\n\t\t\tfree(vname);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES, &child,\n\t    &children) == 0 && children > 0) {\n\t\t \n\t\t(void) printf(dashes, cb->cb_namewidth, \"spare\");\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tvname = zpool_vdev_name(g_zfs, zhp, child[c],\n\t\t\t    cb->cb_name_flags);\n\t\t\tprint_list_stats(zhp, vname, child[c], cb, depth + 2,\n\t\t\t    B_TRUE);\n\t\t\tfree(vname);\n\t\t}\n\t}\n}\n\n \nstatic int\nlist_callback(zpool_handle_t *zhp, void *data)\n{\n\tlist_cbdata_t *cbp = data;\n\n\tprint_pool(zhp, cbp);\n\n\tif (cbp->cb_verbose) {\n\t\tnvlist_t *config, *nvroot;\n\n\t\tconfig = zpool_get_config(zhp, NULL);\n\t\tverify(nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &nvroot) == 0);\n\t\tprint_list_stats(zhp, NULL, nvroot, cbp, 0, B_FALSE);\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nget_namewidth_list(zpool_handle_t *zhp, void *data)\n{\n\tlist_cbdata_t *cb = data;\n\tint width;\n\n\twidth = get_namewidth(zhp, cb->cb_namewidth,\n\t    cb->cb_name_flags | VDEV_NAME_TYPE_ID, cb->cb_verbose);\n\n\tif (width < 9)\n\t\twidth = 9;\n\n\tcb->cb_namewidth = width;\n\n\treturn (0);\n}\n\n \nint\nzpool_do_list(int argc, char **argv)\n{\n\tint c;\n\tint ret = 0;\n\tlist_cbdata_t cb = { 0 };\n\tstatic char default_props[] =\n\t    \"name,size,allocated,free,checkpoint,expandsize,fragmentation,\"\n\t    \"capacity,dedupratio,health,altroot\";\n\tchar *props = default_props;\n\tfloat interval = 0;\n\tunsigned long count = 0;\n\tzpool_list_t *list;\n\tboolean_t first = B_TRUE;\n\tcurrent_prop_type = ZFS_TYPE_POOL;\n\n\t \n\twhile ((c = getopt(argc, argv, \":gHLo:pPT:v\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'g':\n\t\t\tcb.cb_name_flags |= VDEV_NAME_GUID;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcb.cb_scripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tcb.cb_name_flags |= VDEV_NAME_FOLLOW_LINKS;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tprops = optarg;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcb.cb_name_flags |= VDEV_NAME_PATH;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcb.cb_literal = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tget_timestamp_arg(*optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcb.cb_verbose = B_TRUE;\n\t\t\tcb.cb_namewidth = 8;\t \n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tget_interval_count(&argc, argv, &interval, &count);\n\n\tif (zprop_get_list(g_zfs, props, &cb.cb_proplist, ZFS_TYPE_POOL) != 0)\n\t\tusage(B_FALSE);\n\n\tfor (;;) {\n\t\tif ((list = pool_list_get(argc, argv, &cb.cb_proplist,\n\t\t    ZFS_TYPE_POOL, cb.cb_literal, &ret)) == NULL)\n\t\t\treturn (1);\n\n\t\tif (pool_list_count(list) == 0)\n\t\t\tbreak;\n\n\t\tcb.cb_namewidth = 0;\n\t\t(void) pool_list_iter(list, B_FALSE, get_namewidth_list, &cb);\n\n\t\tif (timestamp_fmt != NODATE)\n\t\t\tprint_timestamp(timestamp_fmt);\n\n\t\tif (!cb.cb_scripted && (first || cb.cb_verbose)) {\n\t\t\tprint_header(&cb);\n\t\t\tfirst = B_FALSE;\n\t\t}\n\t\tret = pool_list_iter(list, B_TRUE, list_callback, &cb);\n\n\t\tif (interval == 0)\n\t\t\tbreak;\n\n\t\tif (count != 0 && --count == 0)\n\t\t\tbreak;\n\n\t\tpool_list_free(list);\n\t\t(void) fsleep(interval);\n\t}\n\n\tif (argc == 0 && !cb.cb_scripted && pool_list_count(list) == 0) {\n\t\t(void) printf(gettext(\"no pools available\\n\"));\n\t\tret = 0;\n\t}\n\n\tpool_list_free(list);\n\tzprop_free_list(cb.cb_proplist);\n\treturn (ret);\n}\n\nstatic int\nzpool_do_attach_or_replace(int argc, char **argv, int replacing)\n{\n\tboolean_t force = B_FALSE;\n\tboolean_t rebuild = B_FALSE;\n\tboolean_t wait = B_FALSE;\n\tint c;\n\tnvlist_t *nvroot;\n\tchar *poolname, *old_disk, *new_disk;\n\tzpool_handle_t *zhp;\n\tnvlist_t *props = NULL;\n\tchar *propval;\n\tint ret;\n\n\t \n\twhile ((c = getopt(argc, argv, \"fo:sw\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((propval = strchr(optarg, '=')) == NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"missing \"\n\t\t\t\t    \"'=' for -o option\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\t*propval = '\\0';\n\t\t\tpropval++;\n\n\t\t\tif ((strcmp(optarg, ZPOOL_CONFIG_ASHIFT) != 0) ||\n\t\t\t    (add_prop_list(optarg, propval, &props, B_TRUE)))\n\t\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\trebuild = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twait = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"missing <device> specification\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\told_disk = argv[1];\n\n\tif (argc < 3) {\n\t\tif (!replacing) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"missing <new_device> specification\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tnew_disk = old_disk;\n\t\targc -= 1;\n\t\targv += 1;\n\t} else {\n\t\tnew_disk = argv[2];\n\t\targc -= 2;\n\t\targv += 2;\n\t}\n\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL) {\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\tif (zpool_get_config(zhp, NULL) == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"pool '%s' is unavailable\\n\"),\n\t\t    poolname);\n\t\tzpool_close(zhp);\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\t \n\tif (!nvlist_exists(props, ZPOOL_CONFIG_ASHIFT)) {\n\t\tint intval;\n\t\tzprop_source_t src;\n\t\tchar strval[ZPOOL_MAXPROPLEN];\n\n\t\tintval = zpool_get_prop_int(zhp, ZPOOL_PROP_ASHIFT, &src);\n\t\tif (src != ZPROP_SRC_DEFAULT) {\n\t\t\t(void) sprintf(strval, \"%\" PRId32, intval);\n\t\t\tverify(add_prop_list(ZPOOL_CONFIG_ASHIFT, strval,\n\t\t\t    &props, B_TRUE) == 0);\n\t\t}\n\t}\n\n\tnvroot = make_root_vdev(zhp, props, force, B_FALSE, replacing, B_FALSE,\n\t    argc, argv);\n\tif (nvroot == NULL) {\n\t\tzpool_close(zhp);\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\tret = zpool_vdev_attach(zhp, old_disk, new_disk, nvroot, replacing,\n\t    rebuild);\n\n\tif (ret == 0 && wait)\n\t\tret = zpool_wait(zhp,\n\t\t    replacing ? ZPOOL_WAIT_REPLACE : ZPOOL_WAIT_RESILVER);\n\n\tnvlist_free(props);\n\tnvlist_free(nvroot);\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_replace(int argc, char **argv)\n{\n\treturn (zpool_do_attach_or_replace(argc, argv, B_TRUE));\n}\n\n \nint\nzpool_do_attach(int argc, char **argv)\n{\n\treturn (zpool_do_attach_or_replace(argc, argv, B_FALSE));\n}\n\n \nint\nzpool_do_detach(int argc, char **argv)\n{\n\tint c;\n\tchar *poolname, *path;\n\tzpool_handle_t *zhp;\n\tint ret;\n\n\t \n\twhile ((c = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"missing <device> specification\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\tpath = argv[1];\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL)\n\t\treturn (1);\n\n\tret = zpool_vdev_detach(zhp, path);\n\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_split(int argc, char **argv)\n{\n\tchar *srcpool, *newpool, *propval;\n\tchar *mntopts = NULL;\n\tsplitflags_t flags;\n\tint c, ret = 0;\n\tint ms_status = 0;\n\tboolean_t loadkeys = B_FALSE;\n\tzpool_handle_t *zhp;\n\tnvlist_t *config, *props = NULL;\n\n\tflags.dryrun = B_FALSE;\n\tflags.import = B_FALSE;\n\tflags.name_flags = 0;\n\n\t \n\twhile ((c = getopt(argc, argv, \":gLR:lno:P\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'g':\n\t\t\tflags.name_flags |= VDEV_NAME_GUID;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tflags.name_flags |= VDEV_NAME_FOLLOW_LINKS;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags.import = B_TRUE;\n\t\t\tif (add_prop_list(\n\t\t\t    zpool_prop_to_name(ZPOOL_PROP_ALTROOT), optarg,\n\t\t\t    &props, B_TRUE) != 0) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tloadkeys = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags.dryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((propval = strchr(optarg, '=')) != NULL) {\n\t\t\t\t*propval = '\\0';\n\t\t\t\tpropval++;\n\t\t\t\tif (add_prop_list(optarg, propval,\n\t\t\t\t    &props, B_TRUE) != 0) {\n\t\t\t\t\tnvlist_free(props);\n\t\t\t\t\tusage(B_FALSE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmntopts = optarg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags.name_flags |= VDEV_NAME_PATH;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!flags.import && mntopts != NULL) {\n\t\t(void) fprintf(stderr, gettext(\"setting mntopts is only \"\n\t\t    \"valid when importing the pool\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (!flags.import && loadkeys) {\n\t\t(void) fprintf(stderr, gettext(\"loading keys is only \"\n\t\t    \"valid when importing the pool\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"Missing pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"Missing new pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tsrcpool = argv[0];\n\tnewpool = argv[1];\n\n\targc -= 2;\n\targv += 2;\n\n\tif ((zhp = zpool_open(g_zfs, srcpool)) == NULL) {\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\tconfig = split_mirror_vdev(zhp, newpool, props, flags, argc, argv);\n\tif (config == NULL) {\n\t\tret = 1;\n\t} else {\n\t\tif (flags.dryrun) {\n\t\t\t(void) printf(gettext(\"would create '%s' with the \"\n\t\t\t    \"following layout:\\n\\n\"), newpool);\n\t\t\tprint_vdev_tree(NULL, newpool, config, 0, \"\",\n\t\t\t    flags.name_flags);\n\t\t\tprint_vdev_tree(NULL, \"dedup\", config, 0,\n\t\t\t    VDEV_ALLOC_BIAS_DEDUP, 0);\n\t\t\tprint_vdev_tree(NULL, \"special\", config, 0,\n\t\t\t    VDEV_ALLOC_BIAS_SPECIAL, 0);\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\n\tif (ret != 0 || flags.dryrun || !flags.import) {\n\t\tnvlist_free(config);\n\t\tnvlist_free(props);\n\t\treturn (ret);\n\t}\n\n\t \n\tif ((zhp = zpool_open_canfail(g_zfs, newpool)) == NULL) {\n\t\tnvlist_free(config);\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\tif (loadkeys) {\n\t\tret = zfs_crypto_attempt_load_keys(g_zfs, newpool);\n\t\tif (ret != 0)\n\t\t\tret = 1;\n\t}\n\n\tif (zpool_get_state(zhp) != POOL_STATE_UNAVAIL) {\n\t\tms_status = zpool_enable_datasets(zhp, mntopts, 0);\n\t\tif (ms_status == EZFS_SHAREFAILED) {\n\t\t\t(void) fprintf(stderr, gettext(\"Split was successful, \"\n\t\t\t    \"datasets are mounted but sharing of some datasets \"\n\t\t\t    \"has failed\\n\"));\n\t\t} else if (ms_status == EZFS_MOUNTFAILED) {\n\t\t\t(void) fprintf(stderr, gettext(\"Split was successful\"\n\t\t\t    \", but some datasets could not be mounted\\n\"));\n\t\t\t(void) fprintf(stderr, gettext(\"Try doing '%s' with a \"\n\t\t\t    \"different altroot\\n\"), \"zpool import\");\n\t\t}\n\t}\n\tzpool_close(zhp);\n\tnvlist_free(config);\n\tnvlist_free(props);\n\n\treturn (ret);\n}\n\n\n\n \nint\nzpool_do_online(int argc, char **argv)\n{\n\tint c, i;\n\tchar *poolname;\n\tzpool_handle_t *zhp;\n\tint ret = 0;\n\tvdev_state_t newstate;\n\tint flags = 0;\n\n\t \n\twhile ((c = getopt(argc, argv, \"e\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'e':\n\t\t\tflags |= ZFS_ONLINE_EXPAND;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing device name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL)\n\t\treturn (1);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tvdev_state_t oldstate;\n\t\tboolean_t avail_spare, l2cache;\n\t\tnvlist_t *tgt = zpool_find_vdev(zhp, argv[i], &avail_spare,\n\t\t    &l2cache, NULL);\n\t\tif (tgt == NULL) {\n\t\t\tret = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tuint_t vsc;\n\t\toldstate = ((vdev_stat_t *)fnvlist_lookup_uint64_array(tgt,\n\t\t    ZPOOL_CONFIG_VDEV_STATS, &vsc))->vs_state;\n\t\tif (zpool_vdev_online(zhp, argv[i], flags, &newstate) == 0) {\n\t\t\tif (newstate != VDEV_STATE_HEALTHY) {\n\t\t\t\t(void) printf(gettext(\"warning: device '%s' \"\n\t\t\t\t    \"onlined, but remains in faulted state\\n\"),\n\t\t\t\t    argv[i]);\n\t\t\t\tif (newstate == VDEV_STATE_FAULTED)\n\t\t\t\t\t(void) printf(gettext(\"use 'zpool \"\n\t\t\t\t\t    \"clear' to restore a faulted \"\n\t\t\t\t\t    \"device\\n\"));\n\t\t\t\telse\n\t\t\t\t\t(void) printf(gettext(\"use 'zpool \"\n\t\t\t\t\t    \"replace' to replace devices \"\n\t\t\t\t\t    \"that are no longer present\\n\"));\n\t\t\t\tif ((flags & ZFS_ONLINE_EXPAND)) {\n\t\t\t\t\t(void) printf(gettext(\"%s: failed \"\n\t\t\t\t\t    \"to expand usable space on \"\n\t\t\t\t\t    \"unhealthy device '%s'\\n\"),\n\t\t\t\t\t    (oldstate >= VDEV_STATE_DEGRADED ?\n\t\t\t\t\t    \"error\" : \"warning\"), argv[i]);\n\t\t\t\t\tif (oldstate >= VDEV_STATE_DEGRADED) {\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_offline(int argc, char **argv)\n{\n\tint c, i;\n\tchar *poolname;\n\tzpool_handle_t *zhp;\n\tint ret = 0;\n\tboolean_t istmp = B_FALSE;\n\tboolean_t fault = B_FALSE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"ft\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tfault = B_TRUE;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tistmp = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing device name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL)\n\t\treturn (1);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (fault) {\n\t\t\tuint64_t guid = zpool_vdev_path_to_guid(zhp, argv[i]);\n\t\t\tvdev_aux_t aux;\n\t\t\tif (istmp == B_FALSE) {\n\t\t\t\t \n\t\t\t\taux = VDEV_AUX_EXTERNAL_PERSIST;\n\t\t\t} else {\n\t\t\t\taux = VDEV_AUX_EXTERNAL;\n\t\t\t}\n\n\t\t\tif (guid == 0 || zpool_vdev_fault(zhp, guid, aux) != 0)\n\t\t\t\tret = 1;\n\t\t} else {\n\t\t\tif (zpool_vdev_offline(zhp, argv[i], istmp) != 0)\n\t\t\t\tret = 1;\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_clear(int argc, char **argv)\n{\n\tint c;\n\tint ret = 0;\n\tboolean_t dryrun = B_FALSE;\n\tboolean_t do_rewind = B_FALSE;\n\tboolean_t xtreme_rewind = B_FALSE;\n\tuint32_t rewind_policy = ZPOOL_NO_REWIND;\n\tnvlist_t *policy = NULL;\n\tzpool_handle_t *zhp;\n\tchar *pool, *device;\n\n\t \n\twhile ((c = getopt(argc, argv, \"FnX\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'F':\n\t\t\tdo_rewind = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\txtreme_rewind = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc > 2) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif ((dryrun || xtreme_rewind) && !do_rewind) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"-n or -X only meaningful with -F\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (dryrun)\n\t\trewind_policy = ZPOOL_TRY_REWIND;\n\telse if (do_rewind)\n\t\trewind_policy = ZPOOL_DO_REWIND;\n\tif (xtreme_rewind)\n\t\trewind_policy |= ZPOOL_EXTREME_REWIND;\n\n\t \n\tif (nvlist_alloc(&policy, NV_UNIQUE_NAME, 0) != 0 ||\n\t    nvlist_add_uint32(policy, ZPOOL_LOAD_REWIND_POLICY,\n\t    rewind_policy) != 0) {\n\t\treturn (1);\n\t}\n\n\tpool = argv[0];\n\tdevice = argc == 2 ? argv[1] : NULL;\n\n\tif ((zhp = zpool_open_canfail(g_zfs, pool)) == NULL) {\n\t\tnvlist_free(policy);\n\t\treturn (1);\n\t}\n\n\tif (zpool_clear(zhp, device, policy) != 0)\n\t\tret = 1;\n\n\tzpool_close(zhp);\n\n\tnvlist_free(policy);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_reguid(int argc, char **argv)\n{\n\tint c;\n\tchar *poolname;\n\tzpool_handle_t *zhp;\n\tint ret = 0;\n\n\t \n\twhile ((c = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpoolname = argv[0];\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL)\n\t\treturn (1);\n\n\tret = zpool_reguid(zhp);\n\n\tzpool_close(zhp);\n\treturn (ret);\n}\n\n\n \nint\nzpool_do_reopen(int argc, char **argv)\n{\n\tint c;\n\tint ret = 0;\n\tboolean_t scrub_restart = B_TRUE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"n\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tscrub_restart = B_FALSE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tret = for_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, zpool_reopen_one, &scrub_restart);\n\n\treturn (ret);\n}\n\ntypedef struct scrub_cbdata {\n\tint\tcb_type;\n\tpool_scrub_cmd_t cb_scrub_cmd;\n} scrub_cbdata_t;\n\nstatic boolean_t\nzpool_has_checkpoint(zpool_handle_t *zhp)\n{\n\tnvlist_t *config, *nvroot;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\n\tif (config != NULL) {\n\t\tpool_checkpoint_stat_t *pcs = NULL;\n\t\tuint_t c;\n\n\t\tnvroot = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE);\n\t\t(void) nvlist_lookup_uint64_array(nvroot,\n\t\t    ZPOOL_CONFIG_CHECKPOINT_STATS, (uint64_t **)&pcs, &c);\n\n\t\tif (pcs == NULL || pcs->pcs_state == CS_NONE)\n\t\t\treturn (B_FALSE);\n\n\t\tassert(pcs->pcs_state == CS_CHECKPOINT_EXISTS ||\n\t\t    pcs->pcs_state == CS_CHECKPOINT_DISCARDING);\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic int\nscrub_callback(zpool_handle_t *zhp, void *data)\n{\n\tscrub_cbdata_t *cb = data;\n\tint err;\n\n\t \n\tif (zpool_get_state(zhp) == POOL_STATE_UNAVAIL) {\n\t\t(void) fprintf(stderr, gettext(\"cannot scan '%s': pool is \"\n\t\t    \"currently unavailable\\n\"), zpool_get_name(zhp));\n\t\treturn (1);\n\t}\n\n\terr = zpool_scan(zhp, cb->cb_type, cb->cb_scrub_cmd);\n\n\tif (err == 0 && zpool_has_checkpoint(zhp) &&\n\t    cb->cb_type == POOL_SCAN_SCRUB) {\n\t\t(void) printf(gettext(\"warning: will not scrub state that \"\n\t\t    \"belongs to the checkpoint of pool '%s'\\n\"),\n\t\t    zpool_get_name(zhp));\n\t}\n\n\treturn (err != 0);\n}\n\nstatic int\nwait_callback(zpool_handle_t *zhp, void *data)\n{\n\tzpool_wait_activity_t *act = data;\n\treturn (zpool_wait(zhp, *act));\n}\n\n \nint\nzpool_do_scrub(int argc, char **argv)\n{\n\tint c;\n\tscrub_cbdata_t cb;\n\tboolean_t wait = B_FALSE;\n\tint error;\n\n\tcb.cb_type = POOL_SCAN_SCRUB;\n\tcb.cb_scrub_cmd = POOL_SCRUB_NORMAL;\n\n\tboolean_t is_error_scrub = B_FALSE;\n\tboolean_t is_pause = B_FALSE;\n\tboolean_t is_stop = B_FALSE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"spwe\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'e':\n\t\t\tis_error_scrub = B_TRUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tis_stop = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tis_pause = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twait = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (is_pause && is_stop) {\n\t\t(void) fprintf(stderr, gettext(\"invalid option \"\n\t\t    \"combination :-s and -p are mutually exclusive\\n\"));\n\t\tusage(B_FALSE);\n\t} else {\n\t\tif (is_error_scrub)\n\t\t\tcb.cb_type = POOL_SCAN_ERRORSCRUB;\n\n\t\tif (is_pause) {\n\t\t\tcb.cb_scrub_cmd = POOL_SCRUB_PAUSE;\n\t\t} else if (is_stop) {\n\t\t\tcb.cb_type = POOL_SCAN_NONE;\n\t\t} else {\n\t\t\tcb.cb_scrub_cmd = POOL_SCRUB_NORMAL;\n\t\t}\n\t}\n\n\tif (wait && (cb.cb_type == POOL_SCAN_NONE ||\n\t    cb.cb_scrub_cmd == POOL_SCRUB_PAUSE)) {\n\t\t(void) fprintf(stderr, gettext(\"invalid option combination: \"\n\t\t    \"-w cannot be used with -p or -s\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\terror = for_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, scrub_callback, &cb);\n\n\tif (wait && !error) {\n\t\tzpool_wait_activity_t act = ZPOOL_WAIT_SCRUB;\n\t\terror = for_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t\t    B_FALSE, wait_callback, &act);\n\t}\n\n\treturn (error);\n}\n\n \nint\nzpool_do_resilver(int argc, char **argv)\n{\n\tint c;\n\tscrub_cbdata_t cb;\n\n\tcb.cb_type = POOL_SCAN_RESILVER;\n\tcb.cb_scrub_cmd = POOL_SCRUB_NORMAL;\n\n\t \n\twhile ((c = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\treturn (for_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, scrub_callback, &cb));\n}\n\n \nint\nzpool_do_trim(int argc, char **argv)\n{\n\tstruct option long_options[] = {\n\t\t{\"cancel\",\tno_argument,\t\tNULL,\t'c'},\n\t\t{\"secure\",\tno_argument,\t\tNULL,\t'd'},\n\t\t{\"rate\",\trequired_argument,\tNULL,\t'r'},\n\t\t{\"suspend\",\tno_argument,\t\tNULL,\t's'},\n\t\t{\"wait\",\tno_argument,\t\tNULL,\t'w'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tpool_trim_func_t cmd_type = POOL_TRIM_START;\n\tuint64_t rate = 0;\n\tboolean_t secure = B_FALSE;\n\tboolean_t wait = B_FALSE;\n\n\tint c;\n\twhile ((c = getopt_long(argc, argv, \"cdr:sw\", long_options, NULL))\n\t    != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (cmd_type != POOL_TRIM_START &&\n\t\t\t    cmd_type != POOL_TRIM_CANCEL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-c cannot be \"\n\t\t\t\t    \"combined with other options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tcmd_type = POOL_TRIM_CANCEL;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (cmd_type != POOL_TRIM_START) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-d cannot be \"\n\t\t\t\t    \"combined with the -c or -s options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tsecure = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (cmd_type != POOL_TRIM_START) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-r cannot be \"\n\t\t\t\t    \"combined with the -c or -s options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tif (zfs_nicestrtonum(g_zfs, optarg, &rate) == -1) {\n\t\t\t\t(void) fprintf(stderr, \"%s: %s\\n\",\n\t\t\t\t    gettext(\"invalid value for rate\"),\n\t\t\t\t    libzfs_error_description(g_zfs));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (cmd_type != POOL_TRIM_START &&\n\t\t\t    cmd_type != POOL_TRIM_SUSPEND) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"-s cannot be \"\n\t\t\t\t    \"combined with other options\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tcmd_type = POOL_TRIM_SUSPEND;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twait = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tif (optopt != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%s'\\n\"),\n\t\t\t\t    argv[optind - 1]);\n\t\t\t}\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name argument\\n\"));\n\t\tusage(B_FALSE);\n\t\treturn (-1);\n\t}\n\n\tif (wait && (cmd_type != POOL_TRIM_START)) {\n\t\t(void) fprintf(stderr, gettext(\"-w cannot be used with -c or \"\n\t\t    \"-s\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tchar *poolname = argv[0];\n\tzpool_handle_t *zhp = zpool_open(g_zfs, poolname);\n\tif (zhp == NULL)\n\t\treturn (-1);\n\n\ttrimflags_t trim_flags = {\n\t\t.secure = secure,\n\t\t.rate = rate,\n\t\t.wait = wait,\n\t};\n\n\tnvlist_t *vdevs = fnvlist_alloc();\n\tif (argc == 1) {\n\t\t \n\t\tnvlist_t *config = zpool_get_config(zhp, NULL);\n\t\tnvlist_t *nvroot = fnvlist_lookup_nvlist(config,\n\t\t    ZPOOL_CONFIG_VDEV_TREE);\n\t\tzpool_collect_leaves(zhp, nvroot, vdevs);\n\t\ttrim_flags.fullpool = B_TRUE;\n\t} else {\n\t\ttrim_flags.fullpool = B_FALSE;\n\t\tfor (int i = 1; i < argc; i++) {\n\t\t\tfnvlist_add_boolean(vdevs, argv[i]);\n\t\t}\n\t}\n\n\tint error = zpool_trim(zhp, cmd_type, vdevs, &trim_flags);\n\n\tfnvlist_free(vdevs);\n\tzpool_close(zhp);\n\n\treturn (error);\n}\n\n \nstatic void\nsecs_to_dhms(uint64_t total, char *buf)\n{\n\tuint64_t days = total / 60 / 60 / 24;\n\tuint64_t hours = (total / 60 / 60) % 24;\n\tuint64_t mins = (total / 60) % 60;\n\tuint64_t secs = (total % 60);\n\n\tif (days > 0) {\n\t\t(void) sprintf(buf, \"%llu days %02llu:%02llu:%02llu\",\n\t\t    (u_longlong_t)days, (u_longlong_t)hours,\n\t\t    (u_longlong_t)mins, (u_longlong_t)secs);\n\t} else {\n\t\t(void) sprintf(buf, \"%02llu:%02llu:%02llu\",\n\t\t    (u_longlong_t)hours, (u_longlong_t)mins,\n\t\t    (u_longlong_t)secs);\n\t}\n}\n\n \nstatic void\nprint_err_scrub_status(pool_scan_stat_t *ps)\n{\n\ttime_t start, end, pause;\n\tuint64_t total_secs_left;\n\tuint64_t secs_left, mins_left, hours_left, days_left;\n\tuint64_t examined, to_be_examined;\n\n\tif (ps == NULL || ps->pss_error_scrub_func != POOL_SCAN_ERRORSCRUB) {\n\t\treturn;\n\t}\n\n\t(void) printf(gettext(\" scrub: \"));\n\n\tstart = ps->pss_error_scrub_start;\n\tend = ps->pss_error_scrub_end;\n\tpause = ps->pss_pass_error_scrub_pause;\n\texamined = ps->pss_error_scrub_examined;\n\tto_be_examined = ps->pss_error_scrub_to_be_examined;\n\n\tassert(ps->pss_error_scrub_func == POOL_SCAN_ERRORSCRUB);\n\n\tif (ps->pss_error_scrub_state == DSS_FINISHED) {\n\t\ttotal_secs_left = end - start;\n\t\tdays_left = total_secs_left / 60 / 60 / 24;\n\t\thours_left = (total_secs_left / 60 / 60) % 24;\n\t\tmins_left = (total_secs_left / 60) % 60;\n\t\tsecs_left = (total_secs_left % 60);\n\n\t\t(void) printf(gettext(\"scrubbed %llu error blocks in %llu days \"\n\t\t    \"%02llu:%02llu:%02llu on %s\"), (u_longlong_t)examined,\n\t\t    (u_longlong_t)days_left, (u_longlong_t)hours_left,\n\t\t    (u_longlong_t)mins_left, (u_longlong_t)secs_left,\n\t\t    ctime(&end));\n\n\t\treturn;\n\t} else if (ps->pss_error_scrub_state == DSS_CANCELED) {\n\t\t(void) printf(gettext(\"error scrub canceled on %s\"),\n\t\t    ctime(&end));\n\t\treturn;\n\t}\n\tassert(ps->pss_error_scrub_state == DSS_ERRORSCRUBBING);\n\n\t \n\tif (pause == 0) {\n\t\t(void) printf(gettext(\"error scrub in progress since %s\"),\n\t\t    ctime(&start));\n\t} else {\n\t\t(void) printf(gettext(\"error scrub paused since %s\"),\n\t\t    ctime(&pause));\n\t\t(void) printf(gettext(\"\\terror scrub started on %s\"),\n\t\t    ctime(&start));\n\t}\n\n\tdouble fraction_done = (double)examined / (to_be_examined + examined);\n\t(void) printf(gettext(\"\\t%.2f%% done, issued I/O for %llu error\"\n\t    \" blocks\"), 100 * fraction_done, (u_longlong_t)examined);\n\n\t(void) printf(\"\\n\");\n}\n\n \nstatic void\nprint_scan_scrub_resilver_status(pool_scan_stat_t *ps)\n{\n\ttime_t start, end, pause;\n\tuint64_t pass_scanned, scanned, pass_issued, issued, total_s, total_i;\n\tuint64_t elapsed, scan_rate, issue_rate;\n\tdouble fraction_done;\n\tchar processed_buf[7], scanned_buf[7], issued_buf[7], total_s_buf[7];\n\tchar total_i_buf[7], srate_buf[7], irate_buf[7], time_buf[32];\n\n\tprintf(\"  \");\n\tprintf_color(ANSI_BOLD, gettext(\"scan:\"));\n\tprintf(\" \");\n\n\t \n\tif (ps == NULL || ps->pss_func == POOL_SCAN_NONE ||\n\t    ps->pss_func >= POOL_SCAN_FUNCS) {\n\t\t(void) printf(gettext(\"none requested\\n\"));\n\t\treturn;\n\t}\n\n\tstart = ps->pss_start_time;\n\tend = ps->pss_end_time;\n\tpause = ps->pss_pass_scrub_pause;\n\n\tzfs_nicebytes(ps->pss_processed, processed_buf, sizeof (processed_buf));\n\n\tint is_resilver = ps->pss_func == POOL_SCAN_RESILVER;\n\tint is_scrub = ps->pss_func == POOL_SCAN_SCRUB;\n\tassert(is_resilver || is_scrub);\n\n\t \n\tif (ps->pss_state == DSS_FINISHED) {\n\t\tsecs_to_dhms(end - start, time_buf);\n\n\t\tif (is_scrub) {\n\t\t\t(void) printf(gettext(\"scrub repaired %s \"\n\t\t\t    \"in %s with %llu errors on %s\"), processed_buf,\n\t\t\t    time_buf, (u_longlong_t)ps->pss_errors,\n\t\t\t    ctime(&end));\n\t\t} else if (is_resilver) {\n\t\t\t(void) printf(gettext(\"resilvered %s \"\n\t\t\t    \"in %s with %llu errors on %s\"), processed_buf,\n\t\t\t    time_buf, (u_longlong_t)ps->pss_errors,\n\t\t\t    ctime(&end));\n\t\t}\n\t\treturn;\n\t} else if (ps->pss_state == DSS_CANCELED) {\n\t\tif (is_scrub) {\n\t\t\t(void) printf(gettext(\"scrub canceled on %s\"),\n\t\t\t    ctime(&end));\n\t\t} else if (is_resilver) {\n\t\t\t(void) printf(gettext(\"resilver canceled on %s\"),\n\t\t\t    ctime(&end));\n\t\t}\n\t\treturn;\n\t}\n\n\tassert(ps->pss_state == DSS_SCANNING);\n\n\t \n\tif (is_scrub) {\n\t\tif (pause == 0) {\n\t\t\t(void) printf(gettext(\"scrub in progress since %s\"),\n\t\t\t    ctime(&start));\n\t\t} else {\n\t\t\t(void) printf(gettext(\"scrub paused since %s\"),\n\t\t\t    ctime(&pause));\n\t\t\t(void) printf(gettext(\"\\tscrub started on %s\"),\n\t\t\t    ctime(&start));\n\t\t}\n\t} else if (is_resilver) {\n\t\t(void) printf(gettext(\"resilver in progress since %s\"),\n\t\t    ctime(&start));\n\t}\n\n\tscanned = ps->pss_examined;\n\tpass_scanned = ps->pss_pass_exam;\n\tissued = ps->pss_issued;\n\tpass_issued = ps->pss_pass_issued;\n\ttotal_s = ps->pss_to_examine;\n\ttotal_i = ps->pss_to_examine - ps->pss_skipped;\n\n\t \n\tfraction_done = (double)issued / total_i;\n\n\t \n\telapsed = time(NULL) - ps->pss_pass_start;\n\telapsed -= ps->pss_pass_scrub_spent_paused;\n\telapsed = (elapsed != 0) ? elapsed : 1;\n\n\tscan_rate = pass_scanned / elapsed;\n\tissue_rate = pass_issued / elapsed;\n\n\t \n\tzfs_nicebytes(scanned, scanned_buf, sizeof (scanned_buf));\n\tzfs_nicebytes(issued, issued_buf, sizeof (issued_buf));\n\tzfs_nicebytes(total_s, total_s_buf, sizeof (total_s_buf));\n\tzfs_nicebytes(total_i, total_i_buf, sizeof (total_i_buf));\n\n\t \n\t(void) printf(gettext(\"\\t%s / %s scanned\"), scanned_buf, total_s_buf);\n\tif (pause == 0 && scan_rate > 0) {\n\t\tzfs_nicebytes(scan_rate, srate_buf, sizeof (srate_buf));\n\t\t(void) printf(gettext(\" at %s/s\"), srate_buf);\n\t}\n\t(void) printf(gettext(\", %s / %s issued\"), issued_buf, total_i_buf);\n\tif (pause == 0 && issue_rate > 0) {\n\t\tzfs_nicebytes(issue_rate, irate_buf, sizeof (irate_buf));\n\t\t(void) printf(gettext(\" at %s/s\"), irate_buf);\n\t}\n\t(void) printf(gettext(\"\\n\"));\n\n\tif (is_resilver) {\n\t\t(void) printf(gettext(\"\\t%s resilvered, %.2f%% done\"),\n\t\t    processed_buf, 100 * fraction_done);\n\t} else if (is_scrub) {\n\t\t(void) printf(gettext(\"\\t%s repaired, %.2f%% done\"),\n\t\t    processed_buf, 100 * fraction_done);\n\t}\n\n\tif (pause == 0) {\n\t\t \n\t\tif (total_i >= issued && issue_rate >= 10 * 1024 * 1024 &&\n\t\t    ((is_resilver && ps->pss_processed > 0) ||\n\t\t    (is_scrub && issued > 0))) {\n\t\t\tsecs_to_dhms((total_i - issued) / issue_rate, time_buf);\n\t\t\t(void) printf(gettext(\", %s to go\\n\"), time_buf);\n\t\t} else {\n\t\t\t(void) printf(gettext(\", no estimated \"\n\t\t\t    \"completion time\\n\"));\n\t\t}\n\t} else {\n\t\t(void) printf(gettext(\"\\n\"));\n\t}\n}\n\nstatic void\nprint_rebuild_status_impl(vdev_rebuild_stat_t *vrs, uint_t c, char *vdev_name)\n{\n\tif (vrs == NULL || vrs->vrs_state == VDEV_REBUILD_NONE)\n\t\treturn;\n\n\tprintf(\"  \");\n\tprintf_color(ANSI_BOLD, gettext(\"scan:\"));\n\tprintf(\" \");\n\n\tuint64_t bytes_scanned = vrs->vrs_bytes_scanned;\n\tuint64_t bytes_issued = vrs->vrs_bytes_issued;\n\tuint64_t bytes_rebuilt = vrs->vrs_bytes_rebuilt;\n\tuint64_t bytes_est_s = vrs->vrs_bytes_est;\n\tuint64_t bytes_est_i = vrs->vrs_bytes_est;\n\tif (c > offsetof(vdev_rebuild_stat_t, vrs_pass_bytes_skipped) / 8)\n\t\tbytes_est_i -= vrs->vrs_pass_bytes_skipped;\n\tuint64_t scan_rate = (vrs->vrs_pass_bytes_scanned /\n\t    (vrs->vrs_pass_time_ms + 1)) * 1000;\n\tuint64_t issue_rate = (vrs->vrs_pass_bytes_issued /\n\t    (vrs->vrs_pass_time_ms + 1)) * 1000;\n\tdouble scan_pct = MIN((double)bytes_scanned * 100 /\n\t    (bytes_est_s + 1), 100);\n\n\t \n\tchar bytes_scanned_buf[7], bytes_issued_buf[7];\n\tchar bytes_rebuilt_buf[7], bytes_est_s_buf[7], bytes_est_i_buf[7];\n\tchar scan_rate_buf[7], issue_rate_buf[7], time_buf[32];\n\tzfs_nicebytes(bytes_scanned, bytes_scanned_buf,\n\t    sizeof (bytes_scanned_buf));\n\tzfs_nicebytes(bytes_issued, bytes_issued_buf,\n\t    sizeof (bytes_issued_buf));\n\tzfs_nicebytes(bytes_rebuilt, bytes_rebuilt_buf,\n\t    sizeof (bytes_rebuilt_buf));\n\tzfs_nicebytes(bytes_est_s, bytes_est_s_buf, sizeof (bytes_est_s_buf));\n\tzfs_nicebytes(bytes_est_i, bytes_est_i_buf, sizeof (bytes_est_i_buf));\n\n\ttime_t start = vrs->vrs_start_time;\n\ttime_t end = vrs->vrs_end_time;\n\n\t \n\tif (vrs->vrs_state == VDEV_REBUILD_COMPLETE) {\n\t\tsecs_to_dhms(vrs->vrs_scan_time_ms / 1000, time_buf);\n\t\t(void) printf(gettext(\"resilvered (%s) %s in %s \"\n\t\t    \"with %llu errors on %s\"), vdev_name, bytes_rebuilt_buf,\n\t\t    time_buf, (u_longlong_t)vrs->vrs_errors, ctime(&end));\n\t\treturn;\n\t} else if (vrs->vrs_state == VDEV_REBUILD_CANCELED) {\n\t\t(void) printf(gettext(\"resilver (%s) canceled on %s\"),\n\t\t    vdev_name, ctime(&end));\n\t\treturn;\n\t} else if (vrs->vrs_state == VDEV_REBUILD_ACTIVE) {\n\t\t(void) printf(gettext(\"resilver (%s) in progress since %s\"),\n\t\t    vdev_name, ctime(&start));\n\t}\n\n\tassert(vrs->vrs_state == VDEV_REBUILD_ACTIVE);\n\n\t(void) printf(gettext(\"\\t%s / %s scanned\"), bytes_scanned_buf,\n\t    bytes_est_s_buf);\n\tif (scan_rate > 0) {\n\t\tzfs_nicebytes(scan_rate, scan_rate_buf, sizeof (scan_rate_buf));\n\t\t(void) printf(gettext(\" at %s/s\"), scan_rate_buf);\n\t}\n\t(void) printf(gettext(\", %s / %s issued\"), bytes_issued_buf,\n\t    bytes_est_i_buf);\n\tif (issue_rate > 0) {\n\t\tzfs_nicebytes(issue_rate, issue_rate_buf,\n\t\t    sizeof (issue_rate_buf));\n\t\t(void) printf(gettext(\" at %s/s\"), issue_rate_buf);\n\t}\n\t(void) printf(gettext(\"\\n\"));\n\n\t(void) printf(gettext(\"\\t%s resilvered, %.2f%% done\"),\n\t    bytes_rebuilt_buf, scan_pct);\n\n\tif (vrs->vrs_state == VDEV_REBUILD_ACTIVE) {\n\t\tif (bytes_est_s >= bytes_scanned &&\n\t\t    scan_rate >= 10 * 1024 * 1024) {\n\t\t\tsecs_to_dhms((bytes_est_s - bytes_scanned) / scan_rate,\n\t\t\t    time_buf);\n\t\t\t(void) printf(gettext(\", %s to go\\n\"), time_buf);\n\t\t} else {\n\t\t\t(void) printf(gettext(\", no estimated \"\n\t\t\t    \"completion time\\n\"));\n\t\t}\n\t} else {\n\t\t(void) printf(gettext(\"\\n\"));\n\t}\n}\n\n \nstatic void\nprint_rebuild_status(zpool_handle_t *zhp, nvlist_t *nvroot)\n{\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\tchildren = 0;\n\n\tfor (uint_t c = 0; c < children; c++) {\n\t\tvdev_rebuild_stat_t *vrs;\n\t\tuint_t i;\n\n\t\tif (nvlist_lookup_uint64_array(child[c],\n\t\t    ZPOOL_CONFIG_REBUILD_STATS, (uint64_t **)&vrs, &i) == 0) {\n\t\t\tchar *name = zpool_vdev_name(g_zfs, zhp,\n\t\t\t    child[c], VDEV_NAME_TYPE_ID);\n\t\t\tprint_rebuild_status_impl(vrs, i, name);\n\t\t\tfree(name);\n\t\t}\n\t}\n}\n\n \nstatic void\nprint_checkpoint_scan_warning(pool_scan_stat_t *ps, pool_checkpoint_stat_t *pcs)\n{\n\tif (ps == NULL || pcs == NULL)\n\t\treturn;\n\n\tif (pcs->pcs_state == CS_NONE ||\n\t    pcs->pcs_state == CS_CHECKPOINT_DISCARDING)\n\t\treturn;\n\n\tassert(pcs->pcs_state == CS_CHECKPOINT_EXISTS);\n\n\tif (ps->pss_state == DSS_NONE)\n\t\treturn;\n\n\tif ((ps->pss_state == DSS_FINISHED || ps->pss_state == DSS_CANCELED) &&\n\t    ps->pss_end_time < pcs->pcs_start_time)\n\t\treturn;\n\n\tif (ps->pss_state == DSS_FINISHED || ps->pss_state == DSS_CANCELED) {\n\t\t(void) printf(gettext(\"    scan warning: skipped blocks \"\n\t\t    \"that are only referenced by the checkpoint.\\n\"));\n\t} else {\n\t\tassert(ps->pss_state == DSS_SCANNING);\n\t\t(void) printf(gettext(\"    scan warning: skipping blocks \"\n\t\t    \"that are only referenced by the checkpoint.\\n\"));\n\t}\n}\n\n \nstatic boolean_t\ncheck_rebuilding(nvlist_t *nvroot, uint64_t *rebuild_end_time)\n{\n\tnvlist_t **child;\n\tuint_t children;\n\tboolean_t rebuilding = B_FALSE;\n\tuint64_t end_time = 0;\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\tchildren = 0;\n\n\tfor (uint_t c = 0; c < children; c++) {\n\t\tvdev_rebuild_stat_t *vrs;\n\t\tuint_t i;\n\n\t\tif (nvlist_lookup_uint64_array(child[c],\n\t\t    ZPOOL_CONFIG_REBUILD_STATS, (uint64_t **)&vrs, &i) == 0) {\n\n\t\t\tif (vrs->vrs_end_time > end_time)\n\t\t\t\tend_time = vrs->vrs_end_time;\n\n\t\t\tif (vrs->vrs_state == VDEV_REBUILD_ACTIVE) {\n\t\t\t\trebuilding = B_TRUE;\n\t\t\t\tend_time = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rebuild_end_time != NULL)\n\t\t*rebuild_end_time = end_time;\n\n\treturn (rebuilding);\n}\n\n \nstatic void\nprint_scan_status(zpool_handle_t *zhp, nvlist_t *nvroot)\n{\n\tuint64_t rebuild_end_time = 0, resilver_end_time = 0;\n\tboolean_t have_resilver = B_FALSE, have_scrub = B_FALSE;\n\tboolean_t have_errorscrub = B_FALSE;\n\tboolean_t active_resilver = B_FALSE;\n\tpool_checkpoint_stat_t *pcs = NULL;\n\tpool_scan_stat_t *ps = NULL;\n\tuint_t c;\n\ttime_t scrub_start = 0, errorscrub_start = 0;\n\n\tif (nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_SCAN_STATS,\n\t    (uint64_t **)&ps, &c) == 0) {\n\t\tif (ps->pss_func == POOL_SCAN_RESILVER) {\n\t\t\tresilver_end_time = ps->pss_end_time;\n\t\t\tactive_resilver = (ps->pss_state == DSS_SCANNING);\n\t\t}\n\n\t\thave_resilver = (ps->pss_func == POOL_SCAN_RESILVER);\n\t\thave_scrub = (ps->pss_func == POOL_SCAN_SCRUB);\n\t\tscrub_start = ps->pss_start_time;\n\t\tif (c > offsetof(pool_scan_stat_t,\n\t\t    pss_pass_error_scrub_pause) / 8) {\n\t\t\thave_errorscrub = (ps->pss_error_scrub_func ==\n\t\t\t    POOL_SCAN_ERRORSCRUB);\n\t\t\terrorscrub_start = ps->pss_error_scrub_start;\n\t\t}\n\t}\n\n\tboolean_t active_rebuild = check_rebuilding(nvroot, &rebuild_end_time);\n\tboolean_t have_rebuild = (active_rebuild || (rebuild_end_time > 0));\n\n\t \n\tif (have_scrub && scrub_start > errorscrub_start)\n\t\tprint_scan_scrub_resilver_status(ps);\n\telse if (have_errorscrub && errorscrub_start >= scrub_start)\n\t\tprint_err_scrub_status(ps);\n\n\t \n\tif (active_resilver || (!active_rebuild && have_resilver &&\n\t    resilver_end_time && resilver_end_time > rebuild_end_time)) {\n\t\tprint_scan_scrub_resilver_status(ps);\n\t} else if (active_rebuild || (!active_resilver && have_rebuild &&\n\t    rebuild_end_time && rebuild_end_time > resilver_end_time)) {\n\t\tprint_rebuild_status(zhp, nvroot);\n\t}\n\n\t(void) nvlist_lookup_uint64_array(nvroot,\n\t    ZPOOL_CONFIG_CHECKPOINT_STATS, (uint64_t **)&pcs, &c);\n\tprint_checkpoint_scan_warning(ps, pcs);\n}\n\n \nstatic void\nprint_removal_status(zpool_handle_t *zhp, pool_removal_stat_t *prs)\n{\n\tchar copied_buf[7], examined_buf[7], total_buf[7], rate_buf[7];\n\ttime_t start, end;\n\tnvlist_t *config, *nvroot;\n\tnvlist_t **child;\n\tuint_t children;\n\tchar *vdev_name;\n\n\tif (prs == NULL || prs->prs_state == DSS_NONE)\n\t\treturn;\n\n\t \n\tconfig = zpool_get_config(zhp, NULL);\n\tnvroot = fnvlist_lookup_nvlist(config,\n\t    ZPOOL_CONFIG_VDEV_TREE);\n\tverify(nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0);\n\tassert(prs->prs_removing_vdev < children);\n\tvdev_name = zpool_vdev_name(g_zfs, zhp,\n\t    child[prs->prs_removing_vdev], B_TRUE);\n\n\tprintf_color(ANSI_BOLD, gettext(\"remove: \"));\n\n\tstart = prs->prs_start_time;\n\tend = prs->prs_end_time;\n\tzfs_nicenum(prs->prs_copied, copied_buf, sizeof (copied_buf));\n\n\t \n\tif (prs->prs_state == DSS_FINISHED) {\n\t\tuint64_t minutes_taken = (end - start) / 60;\n\n\t\t(void) printf(gettext(\"Removal of vdev %llu copied %s \"\n\t\t    \"in %lluh%um, completed on %s\"),\n\t\t    (longlong_t)prs->prs_removing_vdev,\n\t\t    copied_buf,\n\t\t    (u_longlong_t)(minutes_taken / 60),\n\t\t    (uint_t)(minutes_taken % 60),\n\t\t    ctime((time_t *)&end));\n\t} else if (prs->prs_state == DSS_CANCELED) {\n\t\t(void) printf(gettext(\"Removal of %s canceled on %s\"),\n\t\t    vdev_name, ctime(&end));\n\t} else {\n\t\tuint64_t copied, total, elapsed, mins_left, hours_left;\n\t\tdouble fraction_done;\n\t\tuint_t rate;\n\n\t\tassert(prs->prs_state == DSS_SCANNING);\n\n\t\t \n\t\t(void) printf(gettext(\n\t\t    \"Evacuation of %s in progress since %s\"),\n\t\t    vdev_name, ctime(&start));\n\n\t\tcopied = prs->prs_copied > 0 ? prs->prs_copied : 1;\n\t\ttotal = prs->prs_to_copy;\n\t\tfraction_done = (double)copied / total;\n\n\t\t \n\t\telapsed = time(NULL) - prs->prs_start_time;\n\t\telapsed = elapsed > 0 ? elapsed : 1;\n\t\trate = copied / elapsed;\n\t\trate = rate > 0 ? rate : 1;\n\t\tmins_left = ((total - copied) / rate) / 60;\n\t\thours_left = mins_left / 60;\n\n\t\tzfs_nicenum(copied, examined_buf, sizeof (examined_buf));\n\t\tzfs_nicenum(total, total_buf, sizeof (total_buf));\n\t\tzfs_nicenum(rate, rate_buf, sizeof (rate_buf));\n\n\t\t \n\t\t(void) printf(gettext(\n\t\t    \"\\t%s copied out of %s at %s/s, %.2f%% done\"),\n\t\t    examined_buf, total_buf, rate_buf, 100 * fraction_done);\n\t\tif (hours_left < (30 * 24)) {\n\t\t\t(void) printf(gettext(\", %lluh%um to go\\n\"),\n\t\t\t    (u_longlong_t)hours_left, (uint_t)(mins_left % 60));\n\t\t} else {\n\t\t\t(void) printf(gettext(\n\t\t\t    \", (copy is slow, no estimated time)\\n\"));\n\t\t}\n\t}\n\tfree(vdev_name);\n\n\tif (prs->prs_mapping_memory > 0) {\n\t\tchar mem_buf[7];\n\t\tzfs_nicenum(prs->prs_mapping_memory, mem_buf, sizeof (mem_buf));\n\t\t(void) printf(gettext(\n\t\t    \"\\t%s memory used for removed device mappings\\n\"),\n\t\t    mem_buf);\n\t}\n}\n\nstatic void\nprint_checkpoint_status(pool_checkpoint_stat_t *pcs)\n{\n\ttime_t start;\n\tchar space_buf[7];\n\n\tif (pcs == NULL || pcs->pcs_state == CS_NONE)\n\t\treturn;\n\n\t(void) printf(gettext(\"checkpoint: \"));\n\n\tstart = pcs->pcs_start_time;\n\tzfs_nicenum(pcs->pcs_space, space_buf, sizeof (space_buf));\n\n\tif (pcs->pcs_state == CS_CHECKPOINT_EXISTS) {\n\t\tchar *date = ctime(&start);\n\n\t\t \n\t\t(void) printf(gettext(\"created %.*s, consumes %s\\n\"),\n\t\t    (int)(strlen(date) - 1), date, space_buf);\n\t\treturn;\n\t}\n\n\tassert(pcs->pcs_state == CS_CHECKPOINT_DISCARDING);\n\n\t(void) printf(gettext(\"discarding, %s remaining.\\n\"),\n\t    space_buf);\n}\n\nstatic void\nprint_error_log(zpool_handle_t *zhp)\n{\n\tnvlist_t *nverrlist = NULL;\n\tnvpair_t *elem;\n\tchar *pathname;\n\tsize_t len = MAXPATHLEN * 2;\n\n\tif (zpool_get_errlog(zhp, &nverrlist) != 0)\n\t\treturn;\n\n\t(void) printf(\"errors: Permanent errors have been \"\n\t    \"detected in the following files:\\n\\n\");\n\n\tpathname = safe_malloc(len);\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(nverrlist, elem)) != NULL) {\n\t\tnvlist_t *nv;\n\t\tuint64_t dsobj, obj;\n\n\t\tverify(nvpair_value_nvlist(elem, &nv) == 0);\n\t\tverify(nvlist_lookup_uint64(nv, ZPOOL_ERR_DATASET,\n\t\t    &dsobj) == 0);\n\t\tverify(nvlist_lookup_uint64(nv, ZPOOL_ERR_OBJECT,\n\t\t    &obj) == 0);\n\t\tzpool_obj_to_path(zhp, dsobj, obj, pathname, len);\n\t\t(void) printf(\"%7s %s\\n\", \"\", pathname);\n\t}\n\tfree(pathname);\n\tnvlist_free(nverrlist);\n}\n\nstatic void\nprint_spares(zpool_handle_t *zhp, status_cbdata_t *cb, nvlist_t **spares,\n    uint_t nspares)\n{\n\tuint_t i;\n\tchar *name;\n\n\tif (nspares == 0)\n\t\treturn;\n\n\t(void) printf(gettext(\"\\tspares\\n\"));\n\n\tfor (i = 0; i < nspares; i++) {\n\t\tname = zpool_vdev_name(g_zfs, zhp, spares[i],\n\t\t    cb->cb_name_flags);\n\t\tprint_status_config(zhp, cb, name, spares[i], 2, B_TRUE, NULL);\n\t\tfree(name);\n\t}\n}\n\nstatic void\nprint_l2cache(zpool_handle_t *zhp, status_cbdata_t *cb, nvlist_t **l2cache,\n    uint_t nl2cache)\n{\n\tuint_t i;\n\tchar *name;\n\n\tif (nl2cache == 0)\n\t\treturn;\n\n\t(void) printf(gettext(\"\\tcache\\n\"));\n\n\tfor (i = 0; i < nl2cache; i++) {\n\t\tname = zpool_vdev_name(g_zfs, zhp, l2cache[i],\n\t\t    cb->cb_name_flags);\n\t\tprint_status_config(zhp, cb, name, l2cache[i], 2,\n\t\t    B_FALSE, NULL);\n\t\tfree(name);\n\t}\n}\n\nstatic void\nprint_dedup_stats(nvlist_t *config)\n{\n\tddt_histogram_t *ddh;\n\tddt_stat_t *dds;\n\tddt_object_t *ddo;\n\tuint_t c;\n\tchar dspace[6], mspace[6];\n\n\t \n\tif (nvlist_lookup_uint64_array(config, ZPOOL_CONFIG_DDT_OBJ_STATS,\n\t    (uint64_t **)&ddo, &c) != 0)\n\t\treturn;\n\n\t(void) printf(\"\\n\");\n\t(void) printf(gettext(\" dedup: \"));\n\tif (ddo->ddo_count == 0) {\n\t\t(void) printf(gettext(\"no DDT entries\\n\"));\n\t\treturn;\n\t}\n\n\tzfs_nicebytes(ddo->ddo_dspace, dspace, sizeof (dspace));\n\tzfs_nicebytes(ddo->ddo_mspace, mspace, sizeof (mspace));\n\t(void) printf(\"DDT entries %llu, size %s on disk, %s in core\\n\",\n\t    (u_longlong_t)ddo->ddo_count,\n\t    dspace,\n\t    mspace);\n\n\tverify(nvlist_lookup_uint64_array(config, ZPOOL_CONFIG_DDT_STATS,\n\t    (uint64_t **)&dds, &c) == 0);\n\tverify(nvlist_lookup_uint64_array(config, ZPOOL_CONFIG_DDT_HISTOGRAM,\n\t    (uint64_t **)&ddh, &c) == 0);\n\tzpool_dump_ddt(dds, ddh);\n}\n\n \nstatic int\nstatus_callback(zpool_handle_t *zhp, void *data)\n{\n\tstatus_cbdata_t *cbp = data;\n\tnvlist_t *config, *nvroot;\n\tconst char *msgid;\n\tzpool_status_t reason;\n\tzpool_errata_t errata;\n\tconst char *health;\n\tuint_t c;\n\tvdev_stat_t *vs;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\treason = zpool_get_status(zhp, &msgid, &errata);\n\n\tcbp->cb_count++;\n\n\t \n\tif (cbp->cb_explain &&\n\t    (reason == ZPOOL_STATUS_OK ||\n\t    reason == ZPOOL_STATUS_VERSION_OLDER ||\n\t    reason == ZPOOL_STATUS_FEAT_DISABLED ||\n\t    reason == ZPOOL_STATUS_COMPATIBILITY_ERR ||\n\t    reason == ZPOOL_STATUS_INCOMPATIBLE_FEAT)) {\n\t\tif (!cbp->cb_allpools) {\n\t\t\t(void) printf(gettext(\"pool '%s' is healthy\\n\"),\n\t\t\t    zpool_get_name(zhp));\n\t\t\tif (cbp->cb_first)\n\t\t\t\tcbp->cb_first = B_FALSE;\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (cbp->cb_first)\n\t\tcbp->cb_first = B_FALSE;\n\telse\n\t\t(void) printf(\"\\n\");\n\n\tnvroot = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE);\n\tverify(nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\n\thealth = zpool_get_state_str(zhp);\n\n\tprintf(\"  \");\n\tprintf_color(ANSI_BOLD, gettext(\"pool:\"));\n\tprintf(\" %s\\n\", zpool_get_name(zhp));\n\tfputc(' ', stdout);\n\tprintf_color(ANSI_BOLD, gettext(\"state: \"));\n\n\tprintf_color(health_str_to_color(health), \"%s\", health);\n\n\tfputc('\\n', stdout);\n\n\tswitch (reason) {\n\tcase ZPOOL_STATUS_MISSING_DEV_R:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices could \"\n\t\t    \"not be opened.  Sufficient replicas exist for\\n\\tthe pool \"\n\t\t    \"to continue functioning in a degraded state.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Attach the missing device \"\n\t\t    \"and online it using 'zpool online'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_MISSING_DEV_NR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices could \"\n\t\t    \"not be opened.  There are insufficient\\n\\treplicas for the\"\n\t\t    \" pool to continue functioning.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Attach the missing device \"\n\t\t    \"and online it using 'zpool online'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_LABEL_R:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices could \"\n\t\t    \"not be used because the label is missing or\\n\\tinvalid.  \"\n\t\t    \"Sufficient replicas exist for the pool to continue\\n\\t\"\n\t\t    \"functioning in a degraded state.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Replace the device using \"\n\t\t    \"'zpool replace'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_LABEL_NR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices could \"\n\t\t    \"not be used because the label is missing \\n\\tor invalid.  \"\n\t\t    \"There are insufficient replicas for the pool to \"\n\t\t    \"continue\\n\\tfunctioning.\\n\"));\n\t\tzpool_explain_recover(zpool_get_handle(zhp),\n\t\t    zpool_get_name(zhp), reason, config);\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_FAILING_DEV:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices has \"\n\t\t    \"experienced an unrecoverable error.  An\\n\\tattempt was \"\n\t\t    \"made to correct the error.  Applications are \"\n\t\t    \"unaffected.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\t\tprintf_color(ANSI_YELLOW, gettext(\"Determine if the \"\n\t\t    \"device needs to be replaced, and clear the errors\\n\\tusing\"\n\t\t    \" 'zpool clear' or replace the device with 'zpool \"\n\t\t    \"replace'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_OFFLINE_DEV:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices has \"\n\t\t    \"been taken offline by the administrator.\\n\\tSufficient \"\n\t\t    \"replicas exist for the pool to continue functioning in \"\n\t\t    \"a\\n\\tdegraded state.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Online the device \"\n\t\t    \"using 'zpool online' or replace the device with\\n\\t'zpool \"\n\t\t    \"replace'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_REMOVED_DEV:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices has \"\n\t\t    \"been removed by the administrator.\\n\\tSufficient \"\n\t\t    \"replicas exist for the pool to continue functioning in \"\n\t\t    \"a\\n\\tdegraded state.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Online the device \"\n\t\t    \"using zpool online' or replace the device with\\n\\t'zpool \"\n\t\t    \"replace'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_RESILVERING:\n\tcase ZPOOL_STATUS_REBUILDING:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices is \"\n\t\t    \"currently being resilvered.  The pool will\\n\\tcontinue \"\n\t\t    \"to function, possibly in a degraded state.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Wait for the resilver to \"\n\t\t    \"complete.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_REBUILD_SCRUB:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices have \"\n\t\t    \"been sequentially resilvered, scrubbing\\n\\tthe pool \"\n\t\t    \"is recommended.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Use 'zpool scrub' to \"\n\t\t    \"verify all data checksums.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_DATA:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices has \"\n\t\t    \"experienced an error resulting in data\\n\\tcorruption.  \"\n\t\t    \"Applications may be affected.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Restore the file in question\"\n\t\t    \" if possible.  Otherwise restore the\\n\\tentire pool from \"\n\t\t    \"backup.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_CORRUPT_POOL:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool metadata is \"\n\t\t    \"corrupted and the pool cannot be opened.\\n\"));\n\t\tzpool_explain_recover(zpool_get_handle(zhp),\n\t\t    zpool_get_name(zhp), reason, config);\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_VERSION_OLDER:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool is formatted using \"\n\t\t    \"a legacy on-disk format.  The pool can\\n\\tstill be used, \"\n\t\t    \"but some features are unavailable.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Upgrade the pool using \"\n\t\t    \"'zpool upgrade'.  Once this is done, the\\n\\tpool will no \"\n\t\t    \"longer be accessible on software that does not support\\n\\t\"\n\t\t    \"feature flags.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_VERSION_NEWER:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool has been upgraded \"\n\t\t    \"to a newer, incompatible on-disk version.\\n\\tThe pool \"\n\t\t    \"cannot be accessed on this system.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Access the pool from a \"\n\t\t    \"system running more recent software, or\\n\\trestore the \"\n\t\t    \"pool from backup.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_FEAT_DISABLED:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Some supported and \"\n\t\t    \"requested features are not enabled on the pool.\\n\\t\"\n\t\t    \"The pool can still be used, but some features are \"\n\t\t    \"unavailable.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Enable all features using \"\n\t\t    \"'zpool upgrade'. Once this is done,\\n\\tthe pool may no \"\n\t\t    \"longer be accessible by software that does not support\\n\\t\"\n\t\t    \"the features. See zpool-features(7) for details.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_COMPATIBILITY_ERR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"This pool has a \"\n\t\t    \"compatibility list specified, but it could not be\\n\\t\"\n\t\t    \"read/parsed at this time. The pool can still be used, \"\n\t\t    \"but this\\n\\tshould be investigated.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Check the value of the \"\n\t\t    \"'compatibility' property against the\\n\\t\"\n\t\t    \"appropriate file in \" ZPOOL_SYSCONF_COMPAT_D \" or \"\n\t\t    ZPOOL_DATA_COMPAT_D \".\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_INCOMPATIBLE_FEAT:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more features \"\n\t\t    \"are enabled on the pool despite not being\\n\\t\"\n\t\t    \"requested by the 'compatibility' property.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Consider setting \"\n\t\t    \"'compatibility' to an appropriate value, or\\n\\t\"\n\t\t    \"adding needed features to the relevant file in\\n\\t\"\n\t\t    ZPOOL_SYSCONF_COMPAT_D \" or \" ZPOOL_DATA_COMPAT_D \".\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_UNSUP_FEAT_READ:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool cannot be accessed \"\n\t\t    \"on this system because it uses the\\n\\tfollowing feature(s)\"\n\t\t    \" not supported on this system:\\n\"));\n\t\tzpool_print_unsup_feat(config);\n\t\t(void) printf(\"\\n\");\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Access the pool from a \"\n\t\t    \"system that supports the required feature(s),\\n\\tor \"\n\t\t    \"restore the pool from backup.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_UNSUP_FEAT_WRITE:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool can only be \"\n\t\t    \"accessed in read-only mode on this system. It\\n\\tcannot be\"\n\t\t    \" accessed in read-write mode because it uses the \"\n\t\t    \"following\\n\\tfeature(s) not supported on this system:\\n\"));\n\t\tzpool_print_unsup_feat(config);\n\t\t(void) printf(\"\\n\");\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool cannot be accessed \"\n\t\t    \"in read-write mode. Import the pool with\\n\"\n\t\t    \"\\t\\\"-o readonly=on\\\", access the pool from a system that \"\n\t\t    \"supports the\\n\\trequired feature(s), or restore the \"\n\t\t    \"pool from backup.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_FAULTED_DEV_R:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices are \"\n\t\t    \"faulted in response to persistent errors.\\n\\tSufficient \"\n\t\t    \"replicas exist for the pool to continue functioning \"\n\t\t    \"in a\\n\\tdegraded state.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Replace the faulted device, \"\n\t\t    \"or use 'zpool clear' to mark the device\\n\\trepaired.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_FAULTED_DEV_NR:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices are \"\n\t\t    \"faulted in response to persistent errors.  There are \"\n\t\t    \"insufficient replicas for the pool to\\n\\tcontinue \"\n\t\t    \"functioning.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Destroy and re-create the \"\n\t\t    \"pool from a backup source.  Manually marking the device\\n\"\n\t\t    \"\\trepaired using 'zpool clear' may allow some data \"\n\t\t    \"to be recovered.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_IO_FAILURE_MMP:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"The pool is suspended \"\n\t\t    \"because multihost writes failed or were delayed;\\n\\t\"\n\t\t    \"another system could import the pool undetected.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Make sure the pool's devices\"\n\t\t    \" are connected, then reboot your system and\\n\\timport the \"\n\t\t    \"pool.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_IO_FAILURE_WAIT:\n\tcase ZPOOL_STATUS_IO_FAILURE_CONTINUE:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"One or more devices are \"\n\t\t    \"faulted in response to IO failures.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Make sure the affected \"\n\t\t    \"devices are connected, then run 'zpool clear'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_BAD_LOG:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"An intent log record \"\n\t\t    \"could not be read.\\n\"\n\t\t    \"\\tWaiting for administrator intervention to fix the \"\n\t\t    \"faulted pool.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Either restore the affected \"\n\t\t    \"device(s) and run 'zpool online',\\n\"\n\t\t    \"\\tor ignore the intent log records by running \"\n\t\t    \"'zpool clear'.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_NON_NATIVE_ASHIFT:\n\t\t(void) printf(gettext(\"status: One or more devices are \"\n\t\t    \"configured to use a non-native block size.\\n\"\n\t\t    \"\\tExpect reduced performance.\\n\"));\n\t\t(void) printf(gettext(\"action: Replace affected devices with \"\n\t\t    \"devices that support the\\n\\tconfigured block size, or \"\n\t\t    \"migrate data to a properly configured\\n\\tpool.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_HOSTID_MISMATCH:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Mismatch between pool hostid\"\n\t\t    \" and system hostid on imported pool.\\n\\tThis pool was \"\n\t\t    \"previously imported into a system with a different \"\n\t\t    \"hostid,\\n\\tand then was verbatim imported into this \"\n\t\t    \"system.\\n\"));\n\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Export this pool on all \"\n\t\t    \"systems on which it is imported.\\n\"\n\t\t    \"\\tThen import it to correct the mismatch.\\n\"));\n\t\tbreak;\n\n\tcase ZPOOL_STATUS_ERRATA:\n\t\tprintf_color(ANSI_BOLD, gettext(\"status: \"));\n\t\tprintf_color(ANSI_YELLOW, gettext(\"Errata #%d detected.\\n\"),\n\t\t    errata);\n\n\t\tswitch (errata) {\n\t\tcase ZPOOL_ERRATA_NONE:\n\t\t\tbreak;\n\n\t\tcase ZPOOL_ERRATA_ZOL_2094_SCRUB:\n\t\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\t\tprintf_color(ANSI_YELLOW, gettext(\"To correct the issue\"\n\t\t\t    \" run 'zpool scrub'.\\n\"));\n\t\t\tbreak;\n\n\t\tcase ZPOOL_ERRATA_ZOL_6845_ENCRYPTION:\n\t\t\t(void) printf(gettext(\"\\tExisting encrypted datasets \"\n\t\t\t    \"contain an on-disk incompatibility\\n\\twhich \"\n\t\t\t    \"needs to be corrected.\\n\"));\n\t\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\t\tprintf_color(ANSI_YELLOW, gettext(\"To correct the issue\"\n\t\t\t    \" backup existing encrypted datasets to new\\n\\t\"\n\t\t\t    \"encrypted datasets and destroy the old ones. \"\n\t\t\t    \"'zfs mount -o ro' can\\n\\tbe used to temporarily \"\n\t\t\t    \"mount existing encrypted datasets readonly.\\n\"));\n\t\t\tbreak;\n\n\t\tcase ZPOOL_ERRATA_ZOL_8308_ENCRYPTION:\n\t\t\t(void) printf(gettext(\"\\tExisting encrypted snapshots \"\n\t\t\t    \"and bookmarks contain an on-disk\\n\\tincompat\"\n\t\t\t    \"ibility. This may cause on-disk corruption if \"\n\t\t\t    \"they are used\\n\\twith 'zfs recv'.\\n\"));\n\t\t\tprintf_color(ANSI_BOLD, gettext(\"action: \"));\n\t\t\tprintf_color(ANSI_YELLOW, gettext(\"To correct the\"\n\t\t\t    \"issue, enable the bookmark_v2 feature. No \"\n\t\t\t    \"additional\\n\\taction is needed if there are no \"\n\t\t\t    \"encrypted snapshots or bookmarks.\\n\\tIf preserving\"\n\t\t\t    \"the encrypted snapshots and bookmarks is required,\"\n\t\t\t    \" use\\n\\ta non-raw send to backup and restore them.\"\n\t\t\t    \" Alternately, they may be\\n\\tremoved to resolve \"\n\t\t\t    \"the incompatibility.\\n\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tassert(0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tassert(reason == ZPOOL_STATUS_OK);\n\t}\n\n\tif (msgid != NULL) {\n\t\tprintf(\"   \");\n\t\tprintf_color(ANSI_BOLD, gettext(\"see:\"));\n\t\tprintf(gettext(\n\t\t    \" https://openzfs.github.io/openzfs-docs/msg/%s\\n\"),\n\t\t    msgid);\n\t}\n\n\tif (config != NULL) {\n\t\tuint64_t nerr;\n\t\tnvlist_t **spares, **l2cache;\n\t\tuint_t nspares, nl2cache;\n\t\tpool_checkpoint_stat_t *pcs = NULL;\n\t\tpool_removal_stat_t *prs = NULL;\n\n\t\tprint_scan_status(zhp, nvroot);\n\n\t\t(void) nvlist_lookup_uint64_array(nvroot,\n\t\t    ZPOOL_CONFIG_REMOVAL_STATS, (uint64_t **)&prs, &c);\n\t\tprint_removal_status(zhp, prs);\n\n\t\t(void) nvlist_lookup_uint64_array(nvroot,\n\t\t    ZPOOL_CONFIG_CHECKPOINT_STATS, (uint64_t **)&pcs, &c);\n\t\tprint_checkpoint_status(pcs);\n\n\t\tcbp->cb_namewidth = max_width(zhp, nvroot, 0, 0,\n\t\t    cbp->cb_name_flags | VDEV_NAME_TYPE_ID);\n\t\tif (cbp->cb_namewidth < 10)\n\t\t\tcbp->cb_namewidth = 10;\n\n\t\tcolor_start(ANSI_BOLD);\n\t\t(void) printf(gettext(\"config:\\n\\n\"));\n\t\t(void) printf(gettext(\"\\t%-*s  %-8s %5s %5s %5s\"),\n\t\t    cbp->cb_namewidth, \"NAME\", \"STATE\", \"READ\", \"WRITE\",\n\t\t    \"CKSUM\");\n\t\tcolor_end();\n\n\t\tif (cbp->cb_print_slow_ios) {\n\t\t\tprintf_color(ANSI_BOLD, \" %5s\", gettext(\"SLOW\"));\n\t\t}\n\n\t\tif (cbp->vcdl != NULL)\n\t\t\tprint_cmd_columns(cbp->vcdl, 0);\n\n\t\tprintf(\"\\n\");\n\n\t\tprint_status_config(zhp, cbp, zpool_get_name(zhp), nvroot, 0,\n\t\t    B_FALSE, NULL);\n\n\t\tprint_class_vdevs(zhp, cbp, nvroot, VDEV_ALLOC_BIAS_DEDUP);\n\t\tprint_class_vdevs(zhp, cbp, nvroot, VDEV_ALLOC_BIAS_SPECIAL);\n\t\tprint_class_vdevs(zhp, cbp, nvroot, VDEV_ALLOC_CLASS_LOGS);\n\n\t\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_L2CACHE,\n\t\t    &l2cache, &nl2cache) == 0)\n\t\t\tprint_l2cache(zhp, cbp, l2cache, nl2cache);\n\n\t\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t\t    &spares, &nspares) == 0)\n\t\t\tprint_spares(zhp, cbp, spares, nspares);\n\n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_ERRCOUNT,\n\t\t    &nerr) == 0) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tif (nerr == 0) {\n\t\t\t\t(void) printf(gettext(\n\t\t\t\t    \"errors: No known data errors\\n\"));\n\t\t\t} else if (!cbp->cb_verbose) {\n\t\t\t\t(void) printf(gettext(\"errors: %llu data \"\n\t\t\t\t    \"errors, use '-v' for a list\\n\"),\n\t\t\t\t    (u_longlong_t)nerr);\n\t\t\t} else {\n\t\t\t\tprint_error_log(zhp);\n\t\t\t}\n\t\t}\n\n\t\tif (cbp->cb_dedup_stats)\n\t\t\tprint_dedup_stats(config);\n\t} else {\n\t\t(void) printf(gettext(\"config: The configuration cannot be \"\n\t\t    \"determined.\\n\"));\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_do_status(int argc, char **argv)\n{\n\tint c;\n\tint ret;\n\tfloat interval = 0;\n\tunsigned long count = 0;\n\tstatus_cbdata_t cb = { 0 };\n\tchar *cmd = NULL;\n\n\t \n\twhile ((c = getopt(argc, argv, \"c:igLpPsvxDtT:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (cmd != NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    gettext(\"Can't set -c flag twice\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (getenv(\"ZPOOL_SCRIPTS_ENABLED\") != NULL &&\n\t\t\t    !libzfs_envvar_is_set(\"ZPOOL_SCRIPTS_ENABLED\")) {\n\t\t\t\tfprintf(stderr, gettext(\n\t\t\t\t    \"Can't run -c, disabled by \"\n\t\t\t\t    \"ZPOOL_SCRIPTS_ENABLED.\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif ((getuid() <= 0 || geteuid() <= 0) &&\n\t\t\t    !libzfs_envvar_is_set(\"ZPOOL_SCRIPTS_AS_ROOT\")) {\n\t\t\t\tfprintf(stderr, gettext(\n\t\t\t\t    \"Can't run -c with root privileges \"\n\t\t\t\t    \"unless ZPOOL_SCRIPTS_AS_ROOT is set.\\n\"));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcmd = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcb.cb_print_vdev_init = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tcb.cb_name_flags |= VDEV_NAME_GUID;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tcb.cb_name_flags |= VDEV_NAME_FOLLOW_LINKS;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcb.cb_literal = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tcb.cb_name_flags |= VDEV_NAME_PATH;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcb.cb_print_slow_ios = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tcb.cb_verbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tcb.cb_explain = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tcb.cb_dedup_stats = B_TRUE;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tcb.cb_print_vdev_trim = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tget_timestamp_arg(*optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tif (optopt == 'c') {\n\t\t\t\tprint_zpool_script_list(\"status\");\n\t\t\t\texit(0);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\t}\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tget_interval_count(&argc, argv, &interval, &count);\n\n\tif (argc == 0)\n\t\tcb.cb_allpools = B_TRUE;\n\n\tcb.cb_first = B_TRUE;\n\tcb.cb_print_status = B_TRUE;\n\n\tfor (;;) {\n\t\tif (timestamp_fmt != NODATE)\n\t\t\tprint_timestamp(timestamp_fmt);\n\n\t\tif (cmd != NULL)\n\t\t\tcb.vcdl = all_pools_for_each_vdev_run(argc, argv, cmd,\n\t\t\t    NULL, NULL, 0, 0);\n\n\t\tret = for_each_pool(argc, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t\t    cb.cb_literal, status_callback, &cb);\n\n\t\tif (cb.vcdl != NULL)\n\t\t\tfree_vdev_cmd_data_list(cb.vcdl);\n\n\t\tif (argc == 0 && cb.cb_count == 0)\n\t\t\t(void) fprintf(stderr, gettext(\"no pools available\\n\"));\n\t\telse if (cb.cb_explain && cb.cb_first && cb.cb_allpools)\n\t\t\t(void) printf(gettext(\"all pools are healthy\\n\"));\n\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\n\t\tif (interval == 0)\n\t\t\tbreak;\n\n\t\tif (count != 0 && --count == 0)\n\t\t\tbreak;\n\n\t\t(void) fsleep(interval);\n\t}\n\n\treturn (0);\n}\n\ntypedef struct upgrade_cbdata {\n\tint\tcb_first;\n\tint\tcb_argc;\n\tuint64_t cb_version;\n\tchar\t**cb_argv;\n} upgrade_cbdata_t;\n\nstatic int\ncheck_unsupp_fs(zfs_handle_t *zhp, void *unsupp_fs)\n{\n\tint zfs_version = (int)zfs_prop_get_int(zhp, ZFS_PROP_VERSION);\n\tint *count = (int *)unsupp_fs;\n\n\tif (zfs_version > ZPL_VERSION) {\n\t\t(void) printf(gettext(\"%s (v%d) is not supported by this \"\n\t\t    \"implementation of ZFS.\\n\"),\n\t\t    zfs_get_name(zhp), zfs_version);\n\t\t(*count)++;\n\t}\n\n\tzfs_iter_filesystems_v2(zhp, 0, check_unsupp_fs, unsupp_fs);\n\n\tzfs_close(zhp);\n\n\treturn (0);\n}\n\nstatic int\nupgrade_version(zpool_handle_t *zhp, uint64_t version)\n{\n\tint ret;\n\tnvlist_t *config;\n\tuint64_t oldversion;\n\tint unsupp_fs = 0;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION,\n\t    &oldversion) == 0);\n\n\tchar compat[ZFS_MAXPROPLEN];\n\tif (zpool_get_prop(zhp, ZPOOL_PROP_COMPATIBILITY, compat,\n\t    ZFS_MAXPROPLEN, NULL, B_FALSE) != 0)\n\t\tcompat[0] = '\\0';\n\n\tassert(SPA_VERSION_IS_SUPPORTED(oldversion));\n\tassert(oldversion < version);\n\n\tret = zfs_iter_root(zpool_get_handle(zhp), check_unsupp_fs, &unsupp_fs);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tif (unsupp_fs) {\n\t\t(void) fprintf(stderr, gettext(\"Upgrade not performed due \"\n\t\t    \"to %d unsupported filesystems (max v%d).\\n\"),\n\t\t    unsupp_fs, (int)ZPL_VERSION);\n\t\treturn (1);\n\t}\n\n\tif (strcmp(compat, ZPOOL_COMPAT_LEGACY) == 0) {\n\t\t(void) fprintf(stderr, gettext(\"Upgrade not performed because \"\n\t\t    \"'compatibility' property set to '\"\n\t\t    ZPOOL_COMPAT_LEGACY \"'.\\n\"));\n\t\treturn (1);\n\t}\n\n\tret = zpool_upgrade(zhp, version);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tif (version >= SPA_VERSION_FEATURES) {\n\t\t(void) printf(gettext(\"Successfully upgraded \"\n\t\t    \"'%s' from version %llu to feature flags.\\n\"),\n\t\t    zpool_get_name(zhp), (u_longlong_t)oldversion);\n\t} else {\n\t\t(void) printf(gettext(\"Successfully upgraded \"\n\t\t    \"'%s' from version %llu to version %llu.\\n\"),\n\t\t    zpool_get_name(zhp), (u_longlong_t)oldversion,\n\t\t    (u_longlong_t)version);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nupgrade_enable_all(zpool_handle_t *zhp, int *countp)\n{\n\tint i, ret, count;\n\tboolean_t firstff = B_TRUE;\n\tnvlist_t *enabled = zpool_get_features(zhp);\n\n\tchar compat[ZFS_MAXPROPLEN];\n\tif (zpool_get_prop(zhp, ZPOOL_PROP_COMPATIBILITY, compat,\n\t    ZFS_MAXPROPLEN, NULL, B_FALSE) != 0)\n\t\tcompat[0] = '\\0';\n\n\tboolean_t requested_features[SPA_FEATURES];\n\tif (zpool_do_load_compat(compat, requested_features) !=\n\t    ZPOOL_COMPATIBILITY_OK)\n\t\treturn (-1);\n\n\tcount = 0;\n\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\tconst char *fname = spa_feature_table[i].fi_uname;\n\t\tconst char *fguid = spa_feature_table[i].fi_guid;\n\n\t\tif (!spa_feature_table[i].fi_zfs_mod_supported)\n\t\t\tcontinue;\n\n\t\tif (!nvlist_exists(enabled, fguid) && requested_features[i]) {\n\t\t\tchar *propname;\n\t\t\tverify(-1 != asprintf(&propname, \"feature@%s\", fname));\n\t\t\tret = zpool_set_prop(zhp, propname,\n\t\t\t    ZFS_FEATURE_ENABLED);\n\t\t\tif (ret != 0) {\n\t\t\t\tfree(propname);\n\t\t\t\treturn (ret);\n\t\t\t}\n\t\t\tcount++;\n\n\t\t\tif (firstff) {\n\t\t\t\t(void) printf(gettext(\"Enabled the \"\n\t\t\t\t    \"following features on '%s':\\n\"),\n\t\t\t\t    zpool_get_name(zhp));\n\t\t\t\tfirstff = B_FALSE;\n\t\t\t}\n\t\t\t(void) printf(gettext(\"  %s\\n\"), fname);\n\t\t\tfree(propname);\n\t\t}\n\t}\n\n\tif (countp != NULL)\n\t\t*countp = count;\n\treturn (0);\n}\n\nstatic int\nupgrade_cb(zpool_handle_t *zhp, void *arg)\n{\n\tupgrade_cbdata_t *cbp = arg;\n\tnvlist_t *config;\n\tuint64_t version;\n\tboolean_t modified_pool = B_FALSE;\n\tint ret;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION,\n\t    &version) == 0);\n\n\tassert(SPA_VERSION_IS_SUPPORTED(version));\n\n\tif (version < cbp->cb_version) {\n\t\tcbp->cb_first = B_FALSE;\n\t\tret = upgrade_version(zhp, cbp->cb_version);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\t\tmodified_pool = B_TRUE;\n\n\t\t \n\t\t(void) zpool_log_history(g_zfs, history_str);\n\t\tlog_history = B_FALSE;\n\t}\n\n\tif (cbp->cb_version >= SPA_VERSION_FEATURES) {\n\t\tint count;\n\t\tret = upgrade_enable_all(zhp, &count);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\n\t\tif (count > 0) {\n\t\t\tcbp->cb_first = B_FALSE;\n\t\t\tmodified_pool = B_TRUE;\n\t\t}\n\t}\n\n\tif (modified_pool) {\n\t\t(void) printf(\"\\n\");\n\t\t(void) after_zpool_upgrade(zhp);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nupgrade_list_older_cb(zpool_handle_t *zhp, void *arg)\n{\n\tupgrade_cbdata_t *cbp = arg;\n\tnvlist_t *config;\n\tuint64_t version;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION,\n\t    &version) == 0);\n\n\tassert(SPA_VERSION_IS_SUPPORTED(version));\n\n\tif (version < SPA_VERSION_FEATURES) {\n\t\tif (cbp->cb_first) {\n\t\t\t(void) printf(gettext(\"The following pools are \"\n\t\t\t    \"formatted with legacy version numbers and can\\n\"\n\t\t\t    \"be upgraded to use feature flags.  After \"\n\t\t\t    \"being upgraded, these pools\\nwill no \"\n\t\t\t    \"longer be accessible by software that does not \"\n\t\t\t    \"support feature\\nflags.\\n\\n\"\n\t\t\t    \"Note that setting a pool's 'compatibility' \"\n\t\t\t    \"feature to '\" ZPOOL_COMPAT_LEGACY \"' will\\n\"\n\t\t\t    \"inhibit upgrades.\\n\\n\"));\n\t\t\t(void) printf(gettext(\"VER  POOL\\n\"));\n\t\t\t(void) printf(gettext(\"---  ------------\\n\"));\n\t\t\tcbp->cb_first = B_FALSE;\n\t\t}\n\n\t\t(void) printf(\"%2llu   %s\\n\", (u_longlong_t)version,\n\t\t    zpool_get_name(zhp));\n\t}\n\n\treturn (0);\n}\n\nstatic int\nupgrade_list_disabled_cb(zpool_handle_t *zhp, void *arg)\n{\n\tupgrade_cbdata_t *cbp = arg;\n\tnvlist_t *config;\n\tuint64_t version;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tverify(nvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION,\n\t    &version) == 0);\n\n\tif (version >= SPA_VERSION_FEATURES) {\n\t\tint i;\n\t\tboolean_t poolfirst = B_TRUE;\n\t\tnvlist_t *enabled = zpool_get_features(zhp);\n\n\t\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\t\tconst char *fguid = spa_feature_table[i].fi_guid;\n\t\t\tconst char *fname = spa_feature_table[i].fi_uname;\n\n\t\t\tif (!spa_feature_table[i].fi_zfs_mod_supported)\n\t\t\t\tcontinue;\n\n\t\t\tif (!nvlist_exists(enabled, fguid)) {\n\t\t\t\tif (cbp->cb_first) {\n\t\t\t\t\t(void) printf(gettext(\"\\nSome \"\n\t\t\t\t\t    \"supported features are not \"\n\t\t\t\t\t    \"enabled on the following pools. \"\n\t\t\t\t\t    \"Once a\\nfeature is enabled the \"\n\t\t\t\t\t    \"pool may become incompatible with \"\n\t\t\t\t\t    \"software\\nthat does not support \"\n\t\t\t\t\t    \"the feature. See \"\n\t\t\t\t\t    \"zpool-features(7) for \"\n\t\t\t\t\t    \"details.\\n\\n\"\n\t\t\t\t\t    \"Note that the pool \"\n\t\t\t\t\t    \"'compatibility' feature can be \"\n\t\t\t\t\t    \"used to inhibit\\nfeature \"\n\t\t\t\t\t    \"upgrades.\\n\\n\"));\n\t\t\t\t\t(void) printf(gettext(\"POOL  \"\n\t\t\t\t\t    \"FEATURE\\n\"));\n\t\t\t\t\t(void) printf(gettext(\"------\"\n\t\t\t\t\t    \"---------\\n\"));\n\t\t\t\t\tcbp->cb_first = B_FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (poolfirst) {\n\t\t\t\t\t(void) printf(gettext(\"%s\\n\"),\n\t\t\t\t\t    zpool_get_name(zhp));\n\t\t\t\t\tpoolfirst = B_FALSE;\n\t\t\t\t}\n\n\t\t\t\t(void) printf(gettext(\"      %s\\n\"), fname);\n\t\t\t}\n\t\t\t \n\t\t\t(void) zpool_log_history(g_zfs, history_str);\n\t\t\tlog_history = B_FALSE;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nupgrade_one(zpool_handle_t *zhp, void *data)\n{\n\tboolean_t modified_pool = B_FALSE;\n\tupgrade_cbdata_t *cbp = data;\n\tuint64_t cur_version;\n\tint ret;\n\n\tif (strcmp(\"log\", zpool_get_name(zhp)) == 0) {\n\t\t(void) fprintf(stderr, gettext(\"'log' is now a reserved word\\n\"\n\t\t    \"Pool 'log' must be renamed using export and import\"\n\t\t    \" to upgrade.\\n\"));\n\t\treturn (1);\n\t}\n\n\tcur_version = zpool_get_prop_int(zhp, ZPOOL_PROP_VERSION, NULL);\n\tif (cur_version > cbp->cb_version) {\n\t\t(void) printf(gettext(\"Pool '%s' is already formatted \"\n\t\t    \"using more current version '%llu'.\\n\\n\"),\n\t\t    zpool_get_name(zhp), (u_longlong_t)cur_version);\n\t\treturn (0);\n\t}\n\n\tif (cbp->cb_version != SPA_VERSION && cur_version == cbp->cb_version) {\n\t\t(void) printf(gettext(\"Pool '%s' is already formatted \"\n\t\t    \"using version %llu.\\n\\n\"), zpool_get_name(zhp),\n\t\t    (u_longlong_t)cbp->cb_version);\n\t\treturn (0);\n\t}\n\n\tif (cur_version != cbp->cb_version) {\n\t\tmodified_pool = B_TRUE;\n\t\tret = upgrade_version(zhp, cbp->cb_version);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\t}\n\n\tif (cbp->cb_version >= SPA_VERSION_FEATURES) {\n\t\tint count = 0;\n\t\tret = upgrade_enable_all(zhp, &count);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\n\t\tif (count != 0) {\n\t\t\tmodified_pool = B_TRUE;\n\t\t} else if (cur_version == SPA_VERSION) {\n\t\t\t(void) printf(gettext(\"Pool '%s' already has all \"\n\t\t\t    \"supported and requested features enabled.\\n\"),\n\t\t\t    zpool_get_name(zhp));\n\t\t}\n\t}\n\n\tif (modified_pool) {\n\t\t(void) printf(\"\\n\");\n\t\t(void) after_zpool_upgrade(zhp);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_do_upgrade(int argc, char **argv)\n{\n\tint c;\n\tupgrade_cbdata_t cb = { 0 };\n\tint ret = 0;\n\tboolean_t showversions = B_FALSE;\n\tboolean_t upgradeall = B_FALSE;\n\tchar *end;\n\n\n\t \n\twhile ((c = getopt(argc, argv, \":avV:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tupgradeall = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tshowversions = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tcb.cb_version = strtoll(optarg, &end, 10);\n\t\t\tif (*end != '\\0' ||\n\t\t\t    !SPA_VERSION_IS_SUPPORTED(cb.cb_version)) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid version '%s'\\n\"), optarg);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tcb.cb_argc = argc;\n\tcb.cb_argv = argv;\n\targc -= optind;\n\targv += optind;\n\n\tif (cb.cb_version == 0) {\n\t\tcb.cb_version = SPA_VERSION;\n\t} else if (!upgradeall && argc == 0) {\n\t\t(void) fprintf(stderr, gettext(\"-V option is \"\n\t\t    \"incompatible with other arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (showversions) {\n\t\tif (upgradeall || argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"-v option is \"\n\t\t\t    \"incompatible with other arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t} else if (upgradeall) {\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"-a option should not \"\n\t\t\t    \"be used along with a pool name\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\t(void) printf(\"%s\", gettext(\"This system supports ZFS pool feature \"\n\t    \"flags.\\n\\n\"));\n\tif (showversions) {\n\t\tint i;\n\n\t\t(void) printf(gettext(\"The following features are \"\n\t\t    \"supported:\\n\\n\"));\n\t\t(void) printf(gettext(\"FEAT DESCRIPTION\\n\"));\n\t\t(void) printf(\"----------------------------------------------\"\n\t\t    \"---------------\\n\");\n\t\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\t\tzfeature_info_t *fi = &spa_feature_table[i];\n\t\t\tif (!fi->fi_zfs_mod_supported)\n\t\t\t\tcontinue;\n\t\t\tconst char *ro =\n\t\t\t    (fi->fi_flags & ZFEATURE_FLAG_READONLY_COMPAT) ?\n\t\t\t    \" (read-only compatible)\" : \"\";\n\n\t\t\t(void) printf(\"%-37s%s\\n\", fi->fi_uname, ro);\n\t\t\t(void) printf(\"     %s\\n\", fi->fi_desc);\n\t\t}\n\t\t(void) printf(\"\\n\");\n\n\t\t(void) printf(gettext(\"The following legacy versions are also \"\n\t\t    \"supported:\\n\\n\"));\n\t\t(void) printf(gettext(\"VER  DESCRIPTION\\n\"));\n\t\t(void) printf(\"---  -----------------------------------------\"\n\t\t    \"---------------\\n\");\n\t\t(void) printf(gettext(\" 1   Initial ZFS version\\n\"));\n\t\t(void) printf(gettext(\" 2   Ditto blocks \"\n\t\t    \"(replicated metadata)\\n\"));\n\t\t(void) printf(gettext(\" 3   Hot spares and double parity \"\n\t\t    \"RAID-Z\\n\"));\n\t\t(void) printf(gettext(\" 4   zpool history\\n\"));\n\t\t(void) printf(gettext(\" 5   Compression using the gzip \"\n\t\t    \"algorithm\\n\"));\n\t\t(void) printf(gettext(\" 6   bootfs pool property\\n\"));\n\t\t(void) printf(gettext(\" 7   Separate intent log devices\\n\"));\n\t\t(void) printf(gettext(\" 8   Delegated administration\\n\"));\n\t\t(void) printf(gettext(\" 9   refquota and refreservation \"\n\t\t    \"properties\\n\"));\n\t\t(void) printf(gettext(\" 10  Cache devices\\n\"));\n\t\t(void) printf(gettext(\" 11  Improved scrub performance\\n\"));\n\t\t(void) printf(gettext(\" 12  Snapshot properties\\n\"));\n\t\t(void) printf(gettext(\" 13  snapused property\\n\"));\n\t\t(void) printf(gettext(\" 14  passthrough-x aclinherit\\n\"));\n\t\t(void) printf(gettext(\" 15  user/group space accounting\\n\"));\n\t\t(void) printf(gettext(\" 16  stmf property support\\n\"));\n\t\t(void) printf(gettext(\" 17  Triple-parity RAID-Z\\n\"));\n\t\t(void) printf(gettext(\" 18  Snapshot user holds\\n\"));\n\t\t(void) printf(gettext(\" 19  Log device removal\\n\"));\n\t\t(void) printf(gettext(\" 20  Compression using zle \"\n\t\t    \"(zero-length encoding)\\n\"));\n\t\t(void) printf(gettext(\" 21  Deduplication\\n\"));\n\t\t(void) printf(gettext(\" 22  Received properties\\n\"));\n\t\t(void) printf(gettext(\" 23  Slim ZIL\\n\"));\n\t\t(void) printf(gettext(\" 24  System attributes\\n\"));\n\t\t(void) printf(gettext(\" 25  Improved scrub stats\\n\"));\n\t\t(void) printf(gettext(\" 26  Improved snapshot deletion \"\n\t\t    \"performance\\n\"));\n\t\t(void) printf(gettext(\" 27  Improved snapshot creation \"\n\t\t    \"performance\\n\"));\n\t\t(void) printf(gettext(\" 28  Multiple vdev replacements\\n\"));\n\t\t(void) printf(gettext(\"\\nFor more information on a particular \"\n\t\t    \"version, including supported releases,\\n\"));\n\t\t(void) printf(gettext(\"see the ZFS Administration Guide.\\n\\n\"));\n\t} else if (argc == 0 && upgradeall) {\n\t\tcb.cb_first = B_TRUE;\n\t\tret = zpool_iter(g_zfs, upgrade_cb, &cb);\n\t\tif (ret == 0 && cb.cb_first) {\n\t\t\tif (cb.cb_version == SPA_VERSION) {\n\t\t\t\t(void) printf(gettext(\"All pools are already \"\n\t\t\t\t    \"formatted using feature flags.\\n\\n\"));\n\t\t\t\t(void) printf(gettext(\"Every feature flags \"\n\t\t\t\t    \"pool already has all supported and \"\n\t\t\t\t    \"requested features enabled.\\n\"));\n\t\t\t} else {\n\t\t\t\t(void) printf(gettext(\"All pools are already \"\n\t\t\t\t    \"formatted with version %llu or higher.\\n\"),\n\t\t\t\t    (u_longlong_t)cb.cb_version);\n\t\t\t}\n\t\t}\n\t} else if (argc == 0) {\n\t\tcb.cb_first = B_TRUE;\n\t\tret = zpool_iter(g_zfs, upgrade_list_older_cb, &cb);\n\t\tassert(ret == 0);\n\n\t\tif (cb.cb_first) {\n\t\t\t(void) printf(gettext(\"All pools are formatted \"\n\t\t\t    \"using feature flags.\\n\\n\"));\n\t\t} else {\n\t\t\t(void) printf(gettext(\"\\nUse 'zpool upgrade -v' \"\n\t\t\t    \"for a list of available legacy versions.\\n\"));\n\t\t}\n\n\t\tcb.cb_first = B_TRUE;\n\t\tret = zpool_iter(g_zfs, upgrade_list_disabled_cb, &cb);\n\t\tassert(ret == 0);\n\n\t\tif (cb.cb_first) {\n\t\t\t(void) printf(gettext(\"Every feature flags pool has \"\n\t\t\t    \"all supported and requested features enabled.\\n\"));\n\t\t} else {\n\t\t\t(void) printf(gettext(\"\\n\"));\n\t\t}\n\t} else {\n\t\tret = for_each_pool(argc, argv, B_FALSE, NULL, ZFS_TYPE_POOL,\n\t\t    B_FALSE, upgrade_one, &cb);\n\t}\n\n\treturn (ret);\n}\n\ntypedef struct hist_cbdata {\n\tboolean_t first;\n\tboolean_t longfmt;\n\tboolean_t internal;\n} hist_cbdata_t;\n\nstatic void\nprint_history_records(nvlist_t *nvhis, hist_cbdata_t *cb)\n{\n\tnvlist_t **records;\n\tuint_t numrecords;\n\tint i;\n\n\tverify(nvlist_lookup_nvlist_array(nvhis, ZPOOL_HIST_RECORD,\n\t    &records, &numrecords) == 0);\n\tfor (i = 0; i < numrecords; i++) {\n\t\tnvlist_t *rec = records[i];\n\t\tchar tbuf[64] = \"\";\n\n\t\tif (nvlist_exists(rec, ZPOOL_HIST_TIME)) {\n\t\t\ttime_t tsec;\n\t\t\tstruct tm t;\n\n\t\t\ttsec = fnvlist_lookup_uint64(records[i],\n\t\t\t    ZPOOL_HIST_TIME);\n\t\t\t(void) localtime_r(&tsec, &t);\n\t\t\t(void) strftime(tbuf, sizeof (tbuf), \"%F.%T\", &t);\n\t\t}\n\n\t\tif (nvlist_exists(rec, ZPOOL_HIST_ELAPSED_NS)) {\n\t\t\tuint64_t elapsed_ns = fnvlist_lookup_int64(records[i],\n\t\t\t    ZPOOL_HIST_ELAPSED_NS);\n\t\t\t(void) snprintf(tbuf + strlen(tbuf),\n\t\t\t    sizeof (tbuf) - strlen(tbuf),\n\t\t\t    \" (%lldms)\", (long long)elapsed_ns / 1000 / 1000);\n\t\t}\n\n\t\tif (nvlist_exists(rec, ZPOOL_HIST_CMD)) {\n\t\t\t(void) printf(\"%s %s\", tbuf,\n\t\t\t    fnvlist_lookup_string(rec, ZPOOL_HIST_CMD));\n\t\t} else if (nvlist_exists(rec, ZPOOL_HIST_INT_EVENT)) {\n\t\t\tint ievent =\n\t\t\t    fnvlist_lookup_uint64(rec, ZPOOL_HIST_INT_EVENT);\n\t\t\tif (!cb->internal)\n\t\t\t\tcontinue;\n\t\t\tif (ievent >= ZFS_NUM_LEGACY_HISTORY_EVENTS) {\n\t\t\t\t(void) printf(\"%s unrecognized record:\\n\",\n\t\t\t\t    tbuf);\n\t\t\t\tdump_nvlist(rec, 4);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void) printf(\"%s [internal %s txg:%lld] %s\", tbuf,\n\t\t\t    zfs_history_event_names[ievent],\n\t\t\t    (longlong_t)fnvlist_lookup_uint64(\n\t\t\t    rec, ZPOOL_HIST_TXG),\n\t\t\t    fnvlist_lookup_string(rec, ZPOOL_HIST_INT_STR));\n\t\t} else if (nvlist_exists(rec, ZPOOL_HIST_INT_NAME)) {\n\t\t\tif (!cb->internal)\n\t\t\t\tcontinue;\n\t\t\t(void) printf(\"%s [txg:%lld] %s\", tbuf,\n\t\t\t    (longlong_t)fnvlist_lookup_uint64(\n\t\t\t    rec, ZPOOL_HIST_TXG),\n\t\t\t    fnvlist_lookup_string(rec, ZPOOL_HIST_INT_NAME));\n\t\t\tif (nvlist_exists(rec, ZPOOL_HIST_DSNAME)) {\n\t\t\t\t(void) printf(\" %s (%llu)\",\n\t\t\t\t    fnvlist_lookup_string(rec,\n\t\t\t\t    ZPOOL_HIST_DSNAME),\n\t\t\t\t    (u_longlong_t)fnvlist_lookup_uint64(rec,\n\t\t\t\t    ZPOOL_HIST_DSID));\n\t\t\t}\n\t\t\t(void) printf(\" %s\", fnvlist_lookup_string(rec,\n\t\t\t    ZPOOL_HIST_INT_STR));\n\t\t} else if (nvlist_exists(rec, ZPOOL_HIST_IOCTL)) {\n\t\t\tif (!cb->internal)\n\t\t\t\tcontinue;\n\t\t\t(void) printf(\"%s ioctl %s\\n\", tbuf,\n\t\t\t    fnvlist_lookup_string(rec, ZPOOL_HIST_IOCTL));\n\t\t\tif (nvlist_exists(rec, ZPOOL_HIST_INPUT_NVL)) {\n\t\t\t\t(void) printf(\"    input:\\n\");\n\t\t\t\tdump_nvlist(fnvlist_lookup_nvlist(rec,\n\t\t\t\t    ZPOOL_HIST_INPUT_NVL), 8);\n\t\t\t}\n\t\t\tif (nvlist_exists(rec, ZPOOL_HIST_OUTPUT_NVL)) {\n\t\t\t\t(void) printf(\"    output:\\n\");\n\t\t\t\tdump_nvlist(fnvlist_lookup_nvlist(rec,\n\t\t\t\t    ZPOOL_HIST_OUTPUT_NVL), 8);\n\t\t\t}\n\t\t\tif (nvlist_exists(rec, ZPOOL_HIST_OUTPUT_SIZE)) {\n\t\t\t\t(void) printf(\"    output nvlist omitted; \"\n\t\t\t\t    \"original size: %lldKB\\n\",\n\t\t\t\t    (longlong_t)fnvlist_lookup_int64(rec,\n\t\t\t\t    ZPOOL_HIST_OUTPUT_SIZE) / 1024);\n\t\t\t}\n\t\t\tif (nvlist_exists(rec, ZPOOL_HIST_ERRNO)) {\n\t\t\t\t(void) printf(\"    errno: %lld\\n\",\n\t\t\t\t    (longlong_t)fnvlist_lookup_int64(rec,\n\t\t\t\t    ZPOOL_HIST_ERRNO));\n\t\t\t}\n\t\t} else {\n\t\t\tif (!cb->internal)\n\t\t\t\tcontinue;\n\t\t\t(void) printf(\"%s unrecognized record:\\n\", tbuf);\n\t\t\tdump_nvlist(rec, 4);\n\t\t}\n\n\t\tif (!cb->longfmt) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t(void) printf(\" [\");\n\t\tif (nvlist_exists(rec, ZPOOL_HIST_WHO)) {\n\t\t\tuid_t who = fnvlist_lookup_uint64(rec, ZPOOL_HIST_WHO);\n\t\t\tstruct passwd *pwd = getpwuid(who);\n\t\t\t(void) printf(\"user %d \", (int)who);\n\t\t\tif (pwd != NULL)\n\t\t\t\t(void) printf(\"(%s) \", pwd->pw_name);\n\t\t}\n\t\tif (nvlist_exists(rec, ZPOOL_HIST_HOST)) {\n\t\t\t(void) printf(\"on %s\",\n\t\t\t    fnvlist_lookup_string(rec, ZPOOL_HIST_HOST));\n\t\t}\n\t\tif (nvlist_exists(rec, ZPOOL_HIST_ZONE)) {\n\t\t\t(void) printf(\":%s\",\n\t\t\t    fnvlist_lookup_string(rec, ZPOOL_HIST_ZONE));\n\t\t}\n\n\t\t(void) printf(\"]\");\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\n \nstatic int\nget_history_one(zpool_handle_t *zhp, void *data)\n{\n\tnvlist_t *nvhis;\n\tint ret;\n\thist_cbdata_t *cb = (hist_cbdata_t *)data;\n\tuint64_t off = 0;\n\tboolean_t eof = B_FALSE;\n\n\tcb->first = B_FALSE;\n\n\t(void) printf(gettext(\"History for '%s':\\n\"), zpool_get_name(zhp));\n\n\twhile (!eof) {\n\t\tif ((ret = zpool_get_history(zhp, &nvhis, &off, &eof)) != 0)\n\t\t\treturn (ret);\n\n\t\tprint_history_records(nvhis, cb);\n\t\tnvlist_free(nvhis);\n\t}\n\t(void) printf(\"\\n\");\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_history(int argc, char **argv)\n{\n\thist_cbdata_t cbdata = { 0 };\n\tint ret;\n\tint c;\n\n\tcbdata.first = B_TRUE;\n\t \n\twhile ((c = getopt(argc, argv, \"li\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tcbdata.longfmt = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tcbdata.internal = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tret = for_each_pool(argc, argv, B_FALSE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, get_history_one, &cbdata);\n\n\tif (argc == 0 && cbdata.first == B_TRUE) {\n\t\t(void) fprintf(stderr, gettext(\"no pools available\\n\"));\n\t\treturn (0);\n\t}\n\n\treturn (ret);\n}\n\ntypedef struct ev_opts {\n\tint verbose;\n\tint scripted;\n\tint follow;\n\tint clear;\n\tchar poolname[ZFS_MAX_DATASET_NAME_LEN];\n} ev_opts_t;\n\nstatic void\nzpool_do_events_short(nvlist_t *nvl, ev_opts_t *opts)\n{\n\tchar ctime_str[26], str[32];\n\tconst char *ptr;\n\tint64_t *tv;\n\tuint_t n;\n\n\tverify(nvlist_lookup_int64_array(nvl, FM_EREPORT_TIME, &tv, &n) == 0);\n\tmemset(str, ' ', 32);\n\t(void) ctime_r((const time_t *)&tv[0], ctime_str);\n\t(void) memcpy(str, ctime_str+4,  6);\t\t \n\t(void) memcpy(str+7, ctime_str+20, 4);\t\t \n\t(void) memcpy(str+12, ctime_str+11, 8);\t\t \n\t(void) sprintf(str+20, \".%09lld\", (longlong_t)tv[1]);  \n\tif (opts->scripted)\n\t\t(void) printf(gettext(\"%s\\t\"), str);\n\telse\n\t\t(void) printf(gettext(\"%s \"), str);\n\n\tverify(nvlist_lookup_string(nvl, FM_CLASS, &ptr) == 0);\n\t(void) printf(gettext(\"%s\\n\"), ptr);\n}\n\nstatic void\nzpool_do_events_nvprint(nvlist_t *nvl, int depth)\n{\n\tnvpair_t *nvp;\n\n\tfor (nvp = nvlist_next_nvpair(nvl, NULL);\n\t    nvp != NULL; nvp = nvlist_next_nvpair(nvl, nvp)) {\n\n\t\tdata_type_t type = nvpair_type(nvp);\n\t\tconst char *name = nvpair_name(nvp);\n\n\t\tboolean_t b;\n\t\tuint8_t i8;\n\t\tuint16_t i16;\n\t\tuint32_t i32;\n\t\tuint64_t i64;\n\t\tconst char *str;\n\t\tnvlist_t *cnv;\n\n\t\tprintf(gettext(\"%*s%s = \"), depth, \"\", name);\n\n\t\tswitch (type) {\n\t\tcase DATA_TYPE_BOOLEAN:\n\t\t\tprintf(gettext(\"%s\"), \"1\");\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\t\t(void) nvpair_value_boolean_value(nvp, &b);\n\t\t\tprintf(gettext(\"%s\"), b ? \"1\" : \"0\");\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_BYTE:\n\t\t\t(void) nvpair_value_byte(nvp, &i8);\n\t\t\tprintf(gettext(\"0x%x\"), i8);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_INT8:\n\t\t\t(void) nvpair_value_int8(nvp, (void *)&i8);\n\t\t\tprintf(gettext(\"0x%x\"), i8);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_UINT8:\n\t\t\t(void) nvpair_value_uint8(nvp, &i8);\n\t\t\tprintf(gettext(\"0x%x\"), i8);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_INT16:\n\t\t\t(void) nvpair_value_int16(nvp, (void *)&i16);\n\t\t\tprintf(gettext(\"0x%x\"), i16);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_UINT16:\n\t\t\t(void) nvpair_value_uint16(nvp, &i16);\n\t\t\tprintf(gettext(\"0x%x\"), i16);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_INT32:\n\t\t\t(void) nvpair_value_int32(nvp, (void *)&i32);\n\t\t\tprintf(gettext(\"0x%x\"), i32);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_UINT32:\n\t\t\t(void) nvpair_value_uint32(nvp, &i32);\n\t\t\tprintf(gettext(\"0x%x\"), i32);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_INT64:\n\t\t\t(void) nvpair_value_int64(nvp, (void *)&i64);\n\t\t\tprintf(gettext(\"0x%llx\"), (u_longlong_t)i64);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_UINT64:\n\t\t\t(void) nvpair_value_uint64(nvp, &i64);\n\t\t\t \n\t\t\tif (strcmp(name,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_STATE) == 0 ||\n\t\t\t    strcmp(name,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_LASTSTATE) == 0) {\n\t\t\t\tprintf(gettext(\"\\\"%s\\\" (0x%llx)\"),\n\t\t\t\t    zpool_state_to_name(i64, VDEV_AUX_NONE),\n\t\t\t\t    (u_longlong_t)i64);\n\t\t\t} else {\n\t\t\t\tprintf(gettext(\"0x%llx\"), (u_longlong_t)i64);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_HRTIME:\n\t\t\t(void) nvpair_value_hrtime(nvp, (void *)&i64);\n\t\t\tprintf(gettext(\"0x%llx\"), (u_longlong_t)i64);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_STRING:\n\t\t\t(void) nvpair_value_string(nvp, &str);\n\t\t\tprintf(gettext(\"\\\"%s\\\"\"), str ? str : \"<NULL>\");\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_NVLIST:\n\t\t\tprintf(gettext(\"(embedded nvlist)\\n\"));\n\t\t\t(void) nvpair_value_nvlist(nvp, &cnv);\n\t\t\tzpool_do_events_nvprint(cnv, depth + 8);\n\t\t\tprintf(gettext(\"%*s(end %s)\"), depth, \"\", name);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_NVLIST_ARRAY: {\n\t\t\tnvlist_t **val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_nvlist_array(nvp, &val, &nelem);\n\t\t\tprintf(gettext(\"(%d embedded nvlists)\\n\"), nelem);\n\t\t\tfor (i = 0; i < nelem; i++) {\n\t\t\t\tprintf(gettext(\"%*s%s[%d] = %s\\n\"),\n\t\t\t\t    depth, \"\", name, i, \"(embedded nvlist)\");\n\t\t\t\tzpool_do_events_nvprint(val[i], depth + 8);\n\t\t\t\tprintf(gettext(\"%*s(end %s[%i])\\n\"),\n\t\t\t\t    depth, \"\", name, i);\n\t\t\t}\n\t\t\tprintf(gettext(\"%*s(end %s)\\n\"), depth, \"\", name);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_INT8_ARRAY: {\n\t\t\tint8_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_int8_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%x \"), val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_UINT8_ARRAY: {\n\t\t\tuint8_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_uint8_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%x \"), val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_INT16_ARRAY: {\n\t\t\tint16_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_int16_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%x \"), val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_UINT16_ARRAY: {\n\t\t\tuint16_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_uint16_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%x \"), val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_INT32_ARRAY: {\n\t\t\tint32_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_int32_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%x \"), val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_UINT32_ARRAY: {\n\t\t\tuint32_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_uint32_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%x \"), val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_INT64_ARRAY: {\n\t\t\tint64_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_int64_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%llx \"),\n\t\t\t\t    (u_longlong_t)val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_UINT64_ARRAY: {\n\t\t\tuint64_t *val;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_uint64_array(nvp, &val, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"0x%llx \"),\n\t\t\t\t    (u_longlong_t)val[i]);\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_STRING_ARRAY: {\n\t\t\tconst char **str;\n\t\t\tuint_t i, nelem;\n\n\t\t\t(void) nvpair_value_string_array(nvp, &str, &nelem);\n\t\t\tfor (i = 0; i < nelem; i++)\n\t\t\t\tprintf(gettext(\"\\\"%s\\\" \"),\n\t\t\t\t    str[i] ? str[i] : \"<NULL>\");\n\n\t\t\tbreak;\n\t\t\t}\n\n\t\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\t\tcase DATA_TYPE_BYTE_ARRAY:\n\t\tcase DATA_TYPE_DOUBLE:\n\t\tcase DATA_TYPE_DONTCARE:\n\t\tcase DATA_TYPE_UNKNOWN:\n\t\t\tprintf(gettext(\"<unknown>\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tprintf(gettext(\"\\n\"));\n\t}\n}\n\nstatic int\nzpool_do_events_next(ev_opts_t *opts)\n{\n\tnvlist_t *nvl;\n\tint zevent_fd, ret, dropped;\n\tconst char *pool;\n\n\tzevent_fd = open(ZFS_DEV, O_RDWR);\n\tVERIFY(zevent_fd >= 0);\n\n\tif (!opts->scripted)\n\t\t(void) printf(gettext(\"%-30s %s\\n\"), \"TIME\", \"CLASS\");\n\n\twhile (1) {\n\t\tret = zpool_events_next(g_zfs, &nvl, &dropped,\n\t\t    (opts->follow ? ZEVENT_NONE : ZEVENT_NONBLOCK), zevent_fd);\n\t\tif (ret || nvl == NULL)\n\t\t\tbreak;\n\n\t\tif (dropped > 0)\n\t\t\t(void) printf(gettext(\"dropped %d events\\n\"), dropped);\n\n\t\tif (strlen(opts->poolname) > 0 &&\n\t\t    nvlist_lookup_string(nvl, FM_FMRI_ZFS_POOL, &pool) == 0 &&\n\t\t    strcmp(opts->poolname, pool) != 0)\n\t\t\tcontinue;\n\n\t\tzpool_do_events_short(nvl, opts);\n\n\t\tif (opts->verbose) {\n\t\t\tzpool_do_events_nvprint(nvl, 8);\n\t\t\tprintf(gettext(\"\\n\"));\n\t\t}\n\t\t(void) fflush(stdout);\n\n\t\tnvlist_free(nvl);\n\t}\n\n\tVERIFY(0 == close(zevent_fd));\n\n\treturn (ret);\n}\n\nstatic int\nzpool_do_events_clear(void)\n{\n\tint count, ret;\n\n\tret = zpool_events_clear(g_zfs, &count);\n\tif (!ret)\n\t\t(void) printf(gettext(\"cleared %d events\\n\"), count);\n\n\treturn (ret);\n}\n\n \nint\nzpool_do_events(int argc, char **argv)\n{\n\tev_opts_t opts = { 0 };\n\tint ret;\n\tint c;\n\n\t \n\twhile ((c = getopt(argc, argv, \"vHfc\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\topts.verbose = 1;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\topts.scripted = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\topts.follow = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\topts.clear = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t} else if (argc == 1) {\n\t\t(void) strlcpy(opts.poolname, argv[0], sizeof (opts.poolname));\n\t\tif (!zfs_name_valid(opts.poolname, ZFS_TYPE_POOL)) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"invalid pool name '%s'\\n\"), opts.poolname);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif ((argc == 1 || opts.verbose || opts.scripted || opts.follow) &&\n\t    opts.clear) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"invalid options combined with -c\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (opts.clear)\n\t\tret = zpool_do_events_clear();\n\telse\n\t\tret = zpool_do_events_next(&opts);\n\n\treturn (ret);\n}\n\nstatic int\nget_callback_vdev(zpool_handle_t *zhp, char *vdevname, void *data)\n{\n\tzprop_get_cbdata_t *cbp = (zprop_get_cbdata_t *)data;\n\tchar value[ZFS_MAXPROPLEN];\n\tzprop_source_t srctype;\n\n\tfor (zprop_list_t *pl = cbp->cb_proplist; pl != NULL;\n\t    pl = pl->pl_next) {\n\t\tchar *prop_name;\n\t\t \n\t\tif (pl->pl_prop == ZPOOL_PROP_NAME &&\n\t\t    pl == cbp->cb_proplist)\n\t\t\tcontinue;\n\n\t\tif (pl->pl_prop == ZPROP_INVAL) {\n\t\t\tprop_name = pl->pl_user_prop;\n\t\t} else {\n\t\t\tprop_name = (char *)vdev_prop_to_name(pl->pl_prop);\n\t\t}\n\t\tif (zpool_get_vdev_prop(zhp, vdevname, pl->pl_prop,\n\t\t    prop_name, value, sizeof (value), &srctype,\n\t\t    cbp->cb_literal) == 0) {\n\t\t\tzprop_print_one_property(vdevname, cbp, prop_name,\n\t\t\t    value, srctype, NULL, NULL);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nget_callback_vdev_cb(void *zhp_data, nvlist_t *nv, void *data)\n{\n\tzpool_handle_t *zhp = zhp_data;\n\tzprop_get_cbdata_t *cbp = (zprop_get_cbdata_t *)data;\n\tchar *vdevname;\n\tconst char *type;\n\tint ret;\n\n\t \n\ttype = fnvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE);\n\tif (zhp != NULL && strcmp(type, \"root\") == 0)\n\t\tvdevname = strdup(\"root-0\");\n\telse\n\t\tvdevname = zpool_vdev_name(g_zfs, zhp, nv,\n\t\t    cbp->cb_vdevs.cb_name_flags);\n\n\t(void) vdev_expand_proplist(zhp, vdevname, &cbp->cb_proplist);\n\n\tret = get_callback_vdev(zhp, vdevname, data);\n\n\tfree(vdevname);\n\n\treturn (ret);\n}\n\nstatic int\nget_callback(zpool_handle_t *zhp, void *data)\n{\n\tzprop_get_cbdata_t *cbp = (zprop_get_cbdata_t *)data;\n\tchar value[ZFS_MAXPROPLEN];\n\tzprop_source_t srctype;\n\tzprop_list_t *pl;\n\tint vid;\n\n\tif (cbp->cb_type == ZFS_TYPE_VDEV) {\n\t\tif (strcmp(cbp->cb_vdevs.cb_names[0], \"all-vdevs\") == 0) {\n\t\t\tfor_each_vdev(zhp, get_callback_vdev_cb, data);\n\t\t} else {\n\t\t\t \n\t\t\tfor (vid = 0; vid < cbp->cb_vdevs.cb_names_count;\n\t\t\t    vid++) {\n\t\t\t\tvdev_expand_proplist(zhp,\n\t\t\t\t    cbp->cb_vdevs.cb_names[vid],\n\t\t\t\t    &cbp->cb_proplist);\n\t\t\t}\n\t\t\t \n\t\t\tfor (vid = 0; vid < cbp->cb_vdevs.cb_names_count;\n\t\t\t    vid++) {\n\t\t\t\tget_callback_vdev(zhp,\n\t\t\t\t    cbp->cb_vdevs.cb_names[vid], data);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tassert(cbp->cb_type == ZFS_TYPE_POOL);\n\t\tfor (pl = cbp->cb_proplist; pl != NULL; pl = pl->pl_next) {\n\t\t\t \n\t\t\tif (pl->pl_prop == ZPOOL_PROP_NAME &&\n\t\t\t    pl == cbp->cb_proplist)\n\t\t\t\tcontinue;\n\n\t\t\tif (pl->pl_prop == ZPROP_INVAL &&\n\t\t\t    zfs_prop_user(pl->pl_user_prop)) {\n\t\t\t\tsrctype = ZPROP_SRC_LOCAL;\n\n\t\t\t\tif (zpool_get_userprop(zhp, pl->pl_user_prop,\n\t\t\t\t    value, sizeof (value), &srctype) != 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tzprop_print_one_property(zpool_get_name(zhp),\n\t\t\t\t    cbp, pl->pl_user_prop, value, srctype,\n\t\t\t\t    NULL, NULL);\n\t\t\t} else if (pl->pl_prop == ZPROP_INVAL &&\n\t\t\t    (zpool_prop_feature(pl->pl_user_prop) ||\n\t\t\t    zpool_prop_unsupported(pl->pl_user_prop))) {\n\t\t\t\tsrctype = ZPROP_SRC_LOCAL;\n\n\t\t\t\tif (zpool_prop_get_feature(zhp,\n\t\t\t\t    pl->pl_user_prop, value,\n\t\t\t\t    sizeof (value)) == 0) {\n\t\t\t\t\tzprop_print_one_property(\n\t\t\t\t\t    zpool_get_name(zhp), cbp,\n\t\t\t\t\t    pl->pl_user_prop, value, srctype,\n\t\t\t\t\t    NULL, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (zpool_get_prop(zhp, pl->pl_prop, value,\n\t\t\t\t    sizeof (value), &srctype,\n\t\t\t\t    cbp->cb_literal) != 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tzprop_print_one_property(zpool_get_name(zhp),\n\t\t\t\t    cbp, zpool_prop_to_name(pl->pl_prop),\n\t\t\t\t    value, srctype, NULL, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nint\nzpool_do_get(int argc, char **argv)\n{\n\tzprop_get_cbdata_t cb = { 0 };\n\tzprop_list_t fake_name = { 0 };\n\tint ret;\n\tint c, i;\n\tchar *propstr = NULL;\n\tchar *vdev = NULL;\n\n\tcb.cb_first = B_TRUE;\n\n\t \n\tcb.cb_sources = ZPROP_SRC_ALL;\n\tcb.cb_columns[0] = GET_COL_NAME;\n\tcb.cb_columns[1] = GET_COL_PROPERTY;\n\tcb.cb_columns[2] = GET_COL_VALUE;\n\tcb.cb_columns[3] = GET_COL_SOURCE;\n\tcb.cb_type = ZFS_TYPE_POOL;\n\tcb.cb_vdevs.cb_name_flags |= VDEV_NAME_TYPE_ID;\n\tcurrent_prop_type = cb.cb_type;\n\n\t \n\twhile ((c = getopt(argc, argv, \":Hpo:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'p':\n\t\t\tcb.cb_literal = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcb.cb_scripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tmemset(&cb.cb_columns, 0, sizeof (cb.cb_columns));\n\t\t\ti = 0;\n\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const col_opts[] =\n\t\t\t\t{ \"name\", \"property\", \"value\", \"source\",\n\t\t\t\t    \"all\" };\n\t\t\t\tstatic const zfs_get_column_t col_cols[] =\n\t\t\t\t{ GET_COL_NAME, GET_COL_PROPERTY, GET_COL_VALUE,\n\t\t\t\t    GET_COL_SOURCE };\n\n\t\t\t\tif (i == ZFS_GET_NCOLS - 1) {\n\t\t\t\t\t(void) fprintf(stderr, gettext(\"too \"\n\t\t\t\t\t\"many fields given to -o \"\n\t\t\t\t\t\"option\\n\"));\n\t\t\t\t\tusage(B_FALSE);\n\t\t\t\t}\n\n\t\t\t\tfor (c = 0; c < ARRAY_SIZE(col_opts); ++c)\n\t\t\t\t\tif (strcmp(tok, col_opts[c]) == 0)\n\t\t\t\t\t\tgoto found;\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid column name '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\n\nfound:\n\t\t\t\tif (c >= 4) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t\t    gettext(\"\\\"all\\\" conflicts \"\n\t\t\t\t\t\t    \"with specific fields \"\n\t\t\t\t\t\t    \"given to -o option\\n\"));\n\t\t\t\t\t\tusage(B_FALSE);\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(cb.cb_columns, col_cols,\n\t\t\t\t\t    sizeof (col_cols));\n\t\t\t\t\ti = ZFS_GET_NCOLS - 1;\n\t\t\t\t} else\n\t\t\t\t\tcb.cb_columns[i++] = col_cols[c];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing property \"\n\t\t    \"argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tpropstr = argv[0];\n\n\targc--;\n\targv++;\n\n\tif (argc == 0) {\n\t\t \n\t} else if (are_all_pools(argc, argv)) {\n\t\t \n\t} else if (are_all_pools(1, argv)) {\n\t\t \n\t\tif ((argc == 2 && strcmp(argv[1], \"all-vdevs\") == 0) ||\n\t\t    (argc == 2 && strcmp(argv[1], \"root\") == 0) ||\n\t\t    are_vdevs_in_pool(argc - 1, argv + 1, argv[0],\n\t\t    &cb.cb_vdevs)) {\n\n\t\t\tif (strcmp(argv[1], \"root\") == 0)\n\t\t\t\tvdev = strdup(\"root-0\");\n\t\t\telse\n\t\t\t\tvdev = strdup(argv[1]);\n\n\t\t\t \n\t\t\tcb.cb_vdevs.cb_names = &vdev;\n\t\t\tcb.cb_vdevs.cb_names_count = argc - 1;\n\t\t\tcb.cb_type = ZFS_TYPE_VDEV;\n\t\t\targc = 1;  \n\t\t} else {\n\t\t\tfprintf(stderr, gettext(\"Expected a list of vdevs in\"\n\t\t\t    \" \\\"%s\\\", but got:\\n\"), argv[0]);\n\t\t\terror_list_unresolved_vdevs(argc - 1, argv + 1,\n\t\t\t    argv[0], &cb.cb_vdevs);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tusage(B_FALSE);\n\t\t\treturn (1);\n\t\t}\n\t} else {\n\t\t \n\t\tfprintf(stderr, gettext(\"missing pool name.\\n\"));\n\t\tfprintf(stderr, \"\\n\");\n\t\tusage(B_FALSE);\n\t\treturn (1);\n\t}\n\n\tif (zprop_get_list(g_zfs, propstr, &cb.cb_proplist,\n\t    cb.cb_type) != 0) {\n\t\t \n\t\tcurrent_prop_type = cb.cb_type;\n\t\tusage(B_FALSE);\n\t}\n\n\tif (cb.cb_proplist != NULL) {\n\t\tfake_name.pl_prop = ZPOOL_PROP_NAME;\n\t\tfake_name.pl_width = strlen(gettext(\"NAME\"));\n\t\tfake_name.pl_next = cb.cb_proplist;\n\t\tcb.cb_proplist = &fake_name;\n\t}\n\n\tret = for_each_pool(argc, argv, B_TRUE, &cb.cb_proplist, cb.cb_type,\n\t    cb.cb_literal, get_callback, &cb);\n\n\tif (cb.cb_proplist == &fake_name)\n\t\tzprop_free_list(fake_name.pl_next);\n\telse\n\t\tzprop_free_list(cb.cb_proplist);\n\n\tif (vdev != NULL)\n\t\tfree(vdev);\n\n\treturn (ret);\n}\n\ntypedef struct set_cbdata {\n\tchar *cb_propname;\n\tchar *cb_value;\n\tzfs_type_t cb_type;\n\tvdev_cbdata_t cb_vdevs;\n\tboolean_t cb_any_successful;\n} set_cbdata_t;\n\nstatic int\nset_pool_callback(zpool_handle_t *zhp, set_cbdata_t *cb)\n{\n\tint error;\n\n\t \n\tif (strcmp(cb->cb_propname, ZPOOL_CONFIG_COMPATIBILITY) == 0) {\n\t\tboolean_t features[SPA_FEATURES];\n\t\tif (zpool_do_load_compat(cb->cb_value, features) !=\n\t\t    ZPOOL_COMPATIBILITY_OK)\n\t\t\treturn (-1);\n\n\t\tnvlist_t *enabled = zpool_get_features(zhp);\n\t\tspa_feature_t i;\n\t\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\t\tconst char *fguid = spa_feature_table[i].fi_guid;\n\t\t\tif (nvlist_exists(enabled, fguid) && !features[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < SPA_FEATURES)\n\t\t\t(void) fprintf(stderr, gettext(\"Warning: one or \"\n\t\t\t    \"more features already enabled on pool '%s'\\n\"\n\t\t\t    \"are not present in this compatibility set.\\n\"),\n\t\t\t    zpool_get_name(zhp));\n\t}\n\n\t \n\tif (zpool_prop_feature(cb->cb_propname) &&\n\t    strcmp(cb->cb_value, ZFS_FEATURE_ENABLED) == 0) {\n\t\tchar *fname = strchr(cb->cb_propname, '@') + 1;\n\t\tspa_feature_t f;\n\n\t\tif (zfeature_lookup_name(fname, &f) == 0) {\n\t\t\tchar compat[ZFS_MAXPROPLEN];\n\t\t\tif (zpool_get_prop(zhp, ZPOOL_PROP_COMPATIBILITY,\n\t\t\t    compat, ZFS_MAXPROPLEN, NULL, B_FALSE) != 0)\n\t\t\t\tcompat[0] = '\\0';\n\n\t\t\tboolean_t features[SPA_FEATURES];\n\t\t\tif (zpool_do_load_compat(compat, features) !=\n\t\t\t    ZPOOL_COMPATIBILITY_OK) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"Error: \"\n\t\t\t\t    \"cannot enable feature '%s' on pool '%s'\\n\"\n\t\t\t\t    \"because the pool's 'compatibility' \"\n\t\t\t\t    \"property cannot be parsed.\\n\"),\n\t\t\t\t    fname, zpool_get_name(zhp));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (!features[f]) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"Error: \"\n\t\t\t\t    \"cannot enable feature '%s' on pool '%s'\\n\"\n\t\t\t\t    \"as it is not specified in this pool's \"\n\t\t\t\t    \"current compatibility set.\\n\"\n\t\t\t\t    \"Consider setting 'compatibility' to a \"\n\t\t\t\t    \"less restrictive set, or to 'off'.\\n\"),\n\t\t\t\t    fname, zpool_get_name(zhp));\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t}\n\n\terror = zpool_set_prop(zhp, cb->cb_propname, cb->cb_value);\n\n\treturn (error);\n}\n\nstatic int\nset_callback(zpool_handle_t *zhp, void *data)\n{\n\tint error;\n\tset_cbdata_t *cb = (set_cbdata_t *)data;\n\n\tif (cb->cb_type == ZFS_TYPE_VDEV) {\n\t\terror = zpool_set_vdev_prop(zhp, *cb->cb_vdevs.cb_names,\n\t\t    cb->cb_propname, cb->cb_value);\n\t} else {\n\t\tassert(cb->cb_type == ZFS_TYPE_POOL);\n\t\terror = set_pool_callback(zhp, cb);\n\t}\n\n\tcb->cb_any_successful = !error;\n\treturn (error);\n}\n\nint\nzpool_do_set(int argc, char **argv)\n{\n\tset_cbdata_t cb = { 0 };\n\tint error;\n\tchar *vdev = NULL;\n\n\tcurrent_prop_type = ZFS_TYPE_POOL;\n\tif (argc > 1 && argv[1][0] == '-') {\n\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t    argv[1][1]);\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing property=value \"\n\t\t    \"argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc < 3) {\n\t\t(void) fprintf(stderr, gettext(\"missing pool name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc > 4) {\n\t\t(void) fprintf(stderr, gettext(\"too many pool names\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tcb.cb_propname = argv[1];\n\tcb.cb_type = ZFS_TYPE_POOL;\n\tcb.cb_vdevs.cb_name_flags |= VDEV_NAME_TYPE_ID;\n\tcb.cb_value = strchr(cb.cb_propname, '=');\n\tif (cb.cb_value == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"missing value in \"\n\t\t    \"property=value argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t*(cb.cb_value) = '\\0';\n\tcb.cb_value++;\n\targc -= 2;\n\targv += 2;\n\n\t \n\tif (!is_pool(argv[0])) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"cannot open '%s': is not a pool\\n\"), argv[0]);\n\t\treturn (EINVAL);\n\t}\n\n\t \n\tif (argc == 2) {\n\n\t\tif (strcmp(argv[1], \"root\") == 0)\n\t\t\tvdev = strdup(\"root-0\");\n\t\telse\n\t\t\tvdev = strdup(argv[1]);\n\n\t\tif (!are_vdevs_in_pool(1, &vdev, argv[0], &cb.cb_vdevs)) {\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"cannot find '%s' in '%s': device not in pool\\n\"),\n\t\t\t    vdev, argv[0]);\n\t\t\tfree(vdev);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tcb.cb_vdevs.cb_names = &vdev;\n\t\tcb.cb_vdevs.cb_names_count = 1;\n\t\tcb.cb_type = ZFS_TYPE_VDEV;\n\t}\n\n\terror = for_each_pool(1, argv, B_TRUE, NULL, ZFS_TYPE_POOL,\n\t    B_FALSE, set_callback, &cb);\n\n\tif (vdev != NULL)\n\t\tfree(vdev);\n\n\treturn (error);\n}\n\n \nstatic uint64_t\nvdev_activity_remaining(nvlist_t *nv, zpool_wait_activity_t activity)\n{\n\tuint64_t bytes_remaining;\n\tnvlist_t **child;\n\tuint_t c, children;\n\tvdev_stat_t *vs;\n\n\tassert(activity == ZPOOL_WAIT_INITIALIZE ||\n\t    activity == ZPOOL_WAIT_TRIM);\n\n\tverify(nvlist_lookup_uint64_array(nv, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\n\tif (activity == ZPOOL_WAIT_INITIALIZE &&\n\t    vs->vs_initialize_state == VDEV_INITIALIZE_ACTIVE)\n\t\tbytes_remaining = vs->vs_initialize_bytes_est -\n\t\t    vs->vs_initialize_bytes_done;\n\telse if (activity == ZPOOL_WAIT_TRIM &&\n\t    vs->vs_trim_state == VDEV_TRIM_ACTIVE)\n\t\tbytes_remaining = vs->vs_trim_bytes_est -\n\t\t    vs->vs_trim_bytes_done;\n\telse\n\t\tbytes_remaining = 0;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\tchildren = 0;\n\n\tfor (c = 0; c < children; c++)\n\t\tbytes_remaining += vdev_activity_remaining(child[c], activity);\n\n\treturn (bytes_remaining);\n}\n\n \nstatic uint64_t\nvdev_activity_top_remaining(nvlist_t *nv)\n{\n\tuint64_t bytes_remaining = 0;\n\tnvlist_t **child;\n\tuint_t children;\n\tint error;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\tchildren = 0;\n\n\tfor (uint_t c = 0; c < children; c++) {\n\t\tvdev_rebuild_stat_t *vrs;\n\t\tuint_t i;\n\n\t\terror = nvlist_lookup_uint64_array(child[c],\n\t\t    ZPOOL_CONFIG_REBUILD_STATS, (uint64_t **)&vrs, &i);\n\t\tif (error == 0) {\n\t\t\tif (vrs->vrs_state == VDEV_REBUILD_ACTIVE) {\n\t\t\t\tbytes_remaining += (vrs->vrs_bytes_est -\n\t\t\t\t    vrs->vrs_bytes_rebuilt);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (bytes_remaining);\n}\n\n \nstatic boolean_t\nvdev_any_spare_replacing(nvlist_t *nv)\n{\n\tnvlist_t **child;\n\tuint_t c, children;\n\tconst char *vdev_type;\n\n\t(void) nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &vdev_type);\n\n\tif (strcmp(vdev_type, VDEV_TYPE_REPLACING) == 0 ||\n\t    strcmp(vdev_type, VDEV_TYPE_SPARE) == 0 ||\n\t    strcmp(vdev_type, VDEV_TYPE_DRAID_SPARE) == 0) {\n\t\treturn (B_TRUE);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\tchildren = 0;\n\n\tfor (c = 0; c < children; c++) {\n\t\tif (vdev_any_spare_replacing(child[c]))\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\ntypedef struct wait_data {\n\tchar *wd_poolname;\n\tboolean_t wd_scripted;\n\tboolean_t wd_exact;\n\tboolean_t wd_headers_once;\n\tboolean_t wd_should_exit;\n\t \n\tboolean_t wd_enabled[ZPOOL_WAIT_NUM_ACTIVITIES];\n\tfloat wd_interval;\n\tpthread_cond_t wd_cv;\n\tpthread_mutex_t wd_mutex;\n} wait_data_t;\n\n \nstatic void\nprint_wait_status_row(wait_data_t *wd, zpool_handle_t *zhp, int row)\n{\n\tnvlist_t *config, *nvroot;\n\tuint_t c;\n\tint i;\n\tpool_checkpoint_stat_t *pcs = NULL;\n\tpool_scan_stat_t *pss = NULL;\n\tpool_removal_stat_t *prs = NULL;\n\tconst char *const headers[] = {\"DISCARD\", \"FREE\", \"INITIALIZE\",\n\t    \"REPLACE\", \"REMOVE\", \"RESILVER\", \"SCRUB\", \"TRIM\"};\n\tint col_widths[ZPOOL_WAIT_NUM_ACTIVITIES];\n\n\t \n\tfor (i = 0; i < ZPOOL_WAIT_NUM_ACTIVITIES; i++) {\n\t\t \n\t\tcol_widths[i] = MAX(strlen(headers[i]), 6) + 2;\n\t}\n\n\t \n\tint term_height = terminal_height();\n\tboolean_t reprint_header = (!wd->wd_headers_once && term_height > 0 &&\n\t    row % (term_height-1) == 0);\n\tif (!wd->wd_scripted && (row == 0 || reprint_header)) {\n\t\tfor (i = 0; i < ZPOOL_WAIT_NUM_ACTIVITIES; i++) {\n\t\t\tif (wd->wd_enabled[i])\n\t\t\t\t(void) printf(\"%*s\", col_widths[i], headers[i]);\n\t\t}\n\t\t(void) fputc('\\n', stdout);\n\t}\n\n\t \n\tint64_t bytes_rem[ZPOOL_WAIT_NUM_ACTIVITIES] = {0};\n\n\tbytes_rem[ZPOOL_WAIT_FREE] =\n\t    zpool_get_prop_int(zhp, ZPOOL_PROP_FREEING, NULL);\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tnvroot = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE);\n\n\t(void) nvlist_lookup_uint64_array(nvroot,\n\t    ZPOOL_CONFIG_CHECKPOINT_STATS, (uint64_t **)&pcs, &c);\n\tif (pcs != NULL && pcs->pcs_state == CS_CHECKPOINT_DISCARDING)\n\t\tbytes_rem[ZPOOL_WAIT_CKPT_DISCARD] = pcs->pcs_space;\n\n\t(void) nvlist_lookup_uint64_array(nvroot,\n\t    ZPOOL_CONFIG_REMOVAL_STATS, (uint64_t **)&prs, &c);\n\tif (prs != NULL && prs->prs_state == DSS_SCANNING)\n\t\tbytes_rem[ZPOOL_WAIT_REMOVE] = prs->prs_to_copy -\n\t\t    prs->prs_copied;\n\n\t(void) nvlist_lookup_uint64_array(nvroot,\n\t    ZPOOL_CONFIG_SCAN_STATS, (uint64_t **)&pss, &c);\n\tif (pss != NULL && pss->pss_state == DSS_SCANNING &&\n\t    pss->pss_pass_scrub_pause == 0) {\n\t\tint64_t rem = pss->pss_to_examine - pss->pss_issued;\n\t\tif (pss->pss_func == POOL_SCAN_SCRUB)\n\t\t\tbytes_rem[ZPOOL_WAIT_SCRUB] = rem;\n\t\telse\n\t\t\tbytes_rem[ZPOOL_WAIT_RESILVER] = rem;\n\t} else if (check_rebuilding(nvroot, NULL)) {\n\t\tbytes_rem[ZPOOL_WAIT_RESILVER] =\n\t\t    vdev_activity_top_remaining(nvroot);\n\t}\n\n\tbytes_rem[ZPOOL_WAIT_INITIALIZE] =\n\t    vdev_activity_remaining(nvroot, ZPOOL_WAIT_INITIALIZE);\n\tbytes_rem[ZPOOL_WAIT_TRIM] =\n\t    vdev_activity_remaining(nvroot, ZPOOL_WAIT_TRIM);\n\n\t \n\tif (vdev_any_spare_replacing(nvroot))\n\t\tbytes_rem[ZPOOL_WAIT_REPLACE] =  bytes_rem[ZPOOL_WAIT_RESILVER];\n\n\tif (timestamp_fmt != NODATE)\n\t\tprint_timestamp(timestamp_fmt);\n\n\tfor (i = 0; i < ZPOOL_WAIT_NUM_ACTIVITIES; i++) {\n\t\tchar buf[64];\n\t\tif (!wd->wd_enabled[i])\n\t\t\tcontinue;\n\n\t\tif (wd->wd_exact)\n\t\t\t(void) snprintf(buf, sizeof (buf), \"%\" PRIi64,\n\t\t\t    bytes_rem[i]);\n\t\telse\n\t\t\tzfs_nicenum(bytes_rem[i], buf, sizeof (buf));\n\n\t\tif (wd->wd_scripted)\n\t\t\t(void) printf(i == 0 ? \"%s\" : \"\\t%s\", buf);\n\t\telse\n\t\t\t(void) printf(\" %*s\", col_widths[i] - 1, buf);\n\t}\n\t(void) printf(\"\\n\");\n\t(void) fflush(stdout);\n}\n\nstatic void *\nwait_status_thread(void *arg)\n{\n\twait_data_t *wd = (wait_data_t *)arg;\n\tzpool_handle_t *zhp;\n\n\tif ((zhp = zpool_open(g_zfs, wd->wd_poolname)) == NULL)\n\t\treturn (void *)(1);\n\n\tfor (int row = 0; ; row++) {\n\t\tboolean_t missing;\n\t\tstruct timespec timeout;\n\t\tint ret = 0;\n\t\t(void) clock_gettime(CLOCK_REALTIME, &timeout);\n\n\t\tif (zpool_refresh_stats(zhp, &missing) != 0 || missing ||\n\t\t    zpool_props_refresh(zhp) != 0) {\n\t\t\tzpool_close(zhp);\n\t\t\treturn (void *)(uintptr_t)(missing ? 0 : 1);\n\t\t}\n\n\t\tprint_wait_status_row(wd, zhp, row);\n\n\t\ttimeout.tv_sec += floor(wd->wd_interval);\n\t\tlong nanos = timeout.tv_nsec +\n\t\t    (wd->wd_interval - floor(wd->wd_interval)) * NANOSEC;\n\t\tif (nanos >= NANOSEC) {\n\t\t\ttimeout.tv_sec++;\n\t\t\ttimeout.tv_nsec = nanos - NANOSEC;\n\t\t} else {\n\t\t\ttimeout.tv_nsec = nanos;\n\t\t}\n\t\tpthread_mutex_lock(&wd->wd_mutex);\n\t\tif (!wd->wd_should_exit)\n\t\t\tret = pthread_cond_timedwait(&wd->wd_cv, &wd->wd_mutex,\n\t\t\t    &timeout);\n\t\tpthread_mutex_unlock(&wd->wd_mutex);\n\t\tif (ret == 0) {\n\t\t\tbreak;  \n\t\t} else if (ret != ETIMEDOUT) {\n\t\t\t(void) fprintf(stderr, gettext(\"pthread_cond_timedwait \"\n\t\t\t    \"failed: %s\\n\"), strerror(ret));\n\t\t\tzpool_close(zhp);\n\t\t\treturn (void *)(uintptr_t)(1);\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\treturn (void *)(0);\n}\n\nint\nzpool_do_wait(int argc, char **argv)\n{\n\tboolean_t verbose = B_FALSE;\n\tint c, i;\n\tunsigned long count;\n\tpthread_t status_thr;\n\tint error = 0;\n\tzpool_handle_t *zhp;\n\n\twait_data_t wd;\n\twd.wd_scripted = B_FALSE;\n\twd.wd_exact = B_FALSE;\n\twd.wd_headers_once = B_FALSE;\n\twd.wd_should_exit = B_FALSE;\n\n\tpthread_mutex_init(&wd.wd_mutex, NULL);\n\tpthread_cond_init(&wd.wd_cv, NULL);\n\n\t \n\tfor (i = 0; i < ZPOOL_WAIT_NUM_ACTIVITIES; i++)\n\t\twd.wd_enabled[i] = B_TRUE;\n\n\twhile ((c = getopt(argc, argv, \"HpT:t:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'H':\n\t\t\twd.wd_scripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\twd.wd_headers_once = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\twd.wd_exact = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tget_timestamp_arg(*optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t \n\t\t\tmemset(&wd.wd_enabled, 0, sizeof (wd.wd_enabled));\n\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const col_opts[] = {\n\t\t\t\t    \"discard\", \"free\", \"initialize\", \"replace\",\n\t\t\t\t    \"remove\", \"resilver\", \"scrub\", \"trim\" };\n\n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(col_opts); ++i)\n\t\t\t\t\tif (strcmp(tok, col_opts[i]) == 0) {\n\t\t\t\t\t\twd.wd_enabled[i] = B_TRUE;\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid activity '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\nfound:;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tget_interval_count(&argc, argv, &wd.wd_interval, &count);\n\tif (count != 0) {\n\t\t \n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (wd.wd_interval != 0)\n\t\tverbose = B_TRUE;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing 'pool' argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\twd.wd_poolname = argv[0];\n\n\tif ((zhp = zpool_open(g_zfs, wd.wd_poolname)) == NULL)\n\t\treturn (1);\n\n\tif (verbose) {\n\t\t \n\t\tif (pthread_create(&status_thr, NULL, wait_status_thread, &wd)\n\t\t    != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"failed to create status\"\n\t\t\t    \"thread: %s\\n\"), strerror(errno));\n\t\t\tzpool_close(zhp);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\t \n\tfor (;;) {\n\t\tboolean_t missing = B_FALSE;\n\t\tboolean_t any_waited = B_FALSE;\n\n\t\tfor (i = 0; i < ZPOOL_WAIT_NUM_ACTIVITIES; i++) {\n\t\t\tboolean_t waited;\n\n\t\t\tif (!wd.wd_enabled[i])\n\t\t\t\tcontinue;\n\n\t\t\terror = zpool_wait_status(zhp, i, &missing, &waited);\n\t\t\tif (error != 0 || missing)\n\t\t\t\tbreak;\n\n\t\t\tany_waited = (any_waited || waited);\n\t\t}\n\n\t\tif (error != 0 || missing || !any_waited)\n\t\t\tbreak;\n\t}\n\n\tzpool_close(zhp);\n\n\tif (verbose) {\n\t\tuintptr_t status;\n\t\tpthread_mutex_lock(&wd.wd_mutex);\n\t\twd.wd_should_exit = B_TRUE;\n\t\tpthread_cond_signal(&wd.wd_cv);\n\t\tpthread_mutex_unlock(&wd.wd_mutex);\n\t\t(void) pthread_join(status_thr, (void *)&status);\n\t\tif (status != 0)\n\t\t\terror = status;\n\t}\n\n\tpthread_mutex_destroy(&wd.wd_mutex);\n\tpthread_cond_destroy(&wd.wd_cv);\n\treturn (error);\n}\n\nstatic int\nfind_command_idx(const char *command, int *idx)\n{\n\tfor (int i = 0; i < NCOMMAND; ++i) {\n\t\tif (command_table[i].name == NULL)\n\t\t\tcontinue;\n\n\t\tif (strcmp(command, command_table[i].name) == 0) {\n\t\t\t*idx = i;\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}\n\n \nstatic int\nzpool_do_version(int argc, char **argv)\n{\n\t(void) argc, (void) argv;\n\treturn (zfs_version_print() != 0);\n}\n\n \nstatic int\nzpool_do_help(int argc, char **argv)\n{\n\tchar page[MAXNAMELEN];\n\tif (argc < 3 || strcmp(argv[2], \"zpool\") == 0)\n\t\tstrcpy(page, \"zpool\");\n\telse if (strcmp(argv[2], \"concepts\") == 0 ||\n\t    strcmp(argv[2], \"props\") == 0)\n\t\tsnprintf(page, sizeof (page), \"zpool%s\", argv[2]);\n\telse\n\t\tsnprintf(page, sizeof (page), \"zpool-%s\", argv[2]);\n\n\texeclp(\"man\", \"man\", page, NULL);\n\n\tfprintf(stderr, \"couldn't run man program: %s\", strerror(errno));\n\treturn (-1);\n}\n\n \nstatic zpool_compat_status_t\nzpool_do_load_compat(const char *compat, boolean_t *list)\n{\n\tchar report[1024];\n\n\tzpool_compat_status_t ret;\n\n\tret = zpool_load_compat(compat, list, report, 1024);\n\tswitch (ret) {\n\n\tcase ZPOOL_COMPATIBILITY_OK:\n\t\tbreak;\n\n\tcase ZPOOL_COMPATIBILITY_NOFILES:\n\tcase ZPOOL_COMPATIBILITY_BADFILE:\n\tcase ZPOOL_COMPATIBILITY_BADTOKEN:\n\t\t(void) fprintf(stderr, \"Error: %s\\n\", report);\n\t\tbreak;\n\n\tcase ZPOOL_COMPATIBILITY_WARNTOKEN:\n\t\t(void) fprintf(stderr, \"Warning: %s\\n\", report);\n\t\tret = ZPOOL_COMPATIBILITY_OK;\n\t\tbreak;\n\t}\n\treturn (ret);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint ret = 0;\n\tint i = 0;\n\tchar *cmdname;\n\tchar **newargv;\n\n\t(void) setlocale(LC_ALL, \"\");\n\t(void) setlocale(LC_NUMERIC, \"C\");\n\t(void) textdomain(TEXT_DOMAIN);\n\tsrand(time(NULL));\n\n\topterr = 0;\n\n\t \n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing command\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tcmdname = argv[1];\n\n\t \n\tif ((strcmp(cmdname, \"-?\") == 0) || strcmp(cmdname, \"--help\") == 0)\n\t\tusage(B_TRUE);\n\n\t \n\tif ((strcmp(cmdname, \"-V\") == 0) || (strcmp(cmdname, \"--version\") == 0))\n\t\treturn (zpool_do_version(argc, argv));\n\n\t \n\tif (strcmp(cmdname, \"help\") == 0)\n\t\treturn (zpool_do_help(argc, argv));\n\n\tif ((g_zfs = libzfs_init()) == NULL) {\n\t\t(void) fprintf(stderr, \"%s\\n\", libzfs_error_init(errno));\n\t\treturn (1);\n\t}\n\n\tlibzfs_print_on_error(g_zfs, B_TRUE);\n\n\tzfs_save_arguments(argc, argv, history_str, sizeof (history_str));\n\n\t \n\tnewargv = safe_malloc((argc + 1) * sizeof (newargv[0]));\n\tfor (i = 0; i < argc; i++)\n\t\tnewargv[i] = strdup(argv[i]);\n\tnewargv[argc] = NULL;\n\n\t \n\tif (find_command_idx(cmdname, &i) == 0) {\n\t\tcurrent_command = &command_table[i];\n\t\tret = command_table[i].func(argc - 1, newargv + 1);\n\t} else if (strchr(cmdname, '=')) {\n\t\tverify(find_command_idx(\"set\", &i) == 0);\n\t\tcurrent_command = &command_table[i];\n\t\tret = command_table[i].func(argc, newargv);\n\t} else if (strcmp(cmdname, \"freeze\") == 0 && argc == 3) {\n\t\t \n\t\tzfs_cmd_t zc = {\"\\0\"};\n\n\t\t(void) strlcpy(zc.zc_name, argv[2], sizeof (zc.zc_name));\n\t\tret = zfs_ioctl(g_zfs, ZFS_IOC_POOL_FREEZE, &zc);\n\t\tif (ret != 0) {\n\t\t\t(void) fprintf(stderr,\n\t\t\tgettext(\"failed to freeze pool: %d\\n\"), errno);\n\t\t\tret = 1;\n\t\t}\n\n\t\tlog_history = 0;\n\t} else {\n\t\t(void) fprintf(stderr, gettext(\"unrecognized \"\n\t\t    \"command '%s'\\n\"), cmdname);\n\t\tusage(B_FALSE);\n\t\tret = 1;\n\t}\n\n\tfor (i = 0; i < argc; i++)\n\t\tfree(newargv[i]);\n\tfree(newargv);\n\n\tif (ret == 0 && log_history)\n\t\t(void) zpool_log_history(g_zfs, history_str);\n\n\tlibzfs_fini(g_zfs);\n\n\t \n\tif (getenv(\"ZFS_ABORT\") != NULL) {\n\t\t(void) printf(\"dumping core by request\\n\");\n\t\tabort();\n\t}\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}