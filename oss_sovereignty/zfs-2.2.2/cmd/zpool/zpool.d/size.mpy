{
  "module_name": "size",
  "hash_id": "bf63cc206bb6fbc134b1daba9858cae7d064cb593c6b5516b72f927a127901c2",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool/zpool.d/size",
  "human_readable_source": "#!/bin/sh\n#\n# Print some common lsblk values\n#\n# Any (lowercased) name symlinked to the lsblk script will be passed to lsblk\n# as one of its --output names.  Here's a partial list of --output names\n# from the lsblk binary:\n#\n# Available columns (for --output):\n#        NAME  device name\n#       KNAME  internal kernel device name\n#     MAJ:MIN  major:minor device number\n#      FSTYPE  filesystem type\n#  MOUNTPOINT  where the device is mounted\n#       LABEL  filesystem LABEL\n#        UUID  filesystem UUID\n#          RA  read-ahead of the device\n#          RO  read-only device\n#          RM  removable device\n#       MODEL  device identifier\n#        SIZE  size of the device\n#       STATE  state of the device\n#       OWNER  user name\n#       GROUP  group name\n#        MODE  device node permissions\n#   ALIGNMENT  alignment offset\n#      MIN-IO  minimum I/O size\n#      OPT-IO  optimal I/O size\n#     PHY-SEC  physical sector size\n#     LOG-SEC  logical sector size\n#        ROTA  rotational device\n#       SCHED  I/O scheduler name\n#     RQ-SIZE  request queue size\n#        TYPE  device type\n#    DISC-ALN  discard alignment offset\n#   DISC-GRAN  discard granularity\n#    DISC-MAX  discard max bytes\n#   DISC-ZERO  discard zeroes data\n#\n# If the script is run as just 'lsblk' then print out disk size, vendor,\n# and model number.\n\n\nhelpstr=\"\nlabel:\tShow filesystem label.\nmodel:\tShow disk model number.\nsize:\tShow the disk capacity.\nvendor:\tShow the disk vendor.\nlsblk:\tShow the disk size, vendor, and model number.\"\n\nscript=\"${0##*/}\"\n\nif [ \"$1\" = \"-h\" ] ; then\n        echo \"$helpstr\" | grep \"$script:\" | tr -s '\\t' | cut -f 2-\n        exit\nfi\n\nif [ \"$script\" = \"lsblk\" ] ; then\n\tlist=\"size vendor model\"\nelse\n\tlist=$(echo \"$script\" | tr '[:upper:]' '[:lower:]')\nfi\n\n# Sometimes, UPATH ends up /dev/(null).\n# That should be corrected, but for now...\n# shellcheck disable=SC2154\nif [ ! -b \"$VDEV_UPATH\" ]; then\n\tsomepath=\"${VDEV_PATH}\"\nelse\n\tsomepath=\"${VDEV_UPATH}\"\nfi\n\n# Older versions of lsblk don't support all these values (like SERIAL).\nfor i in $list ; do\n\n\t# Special case: Looking up the size of a file-based vdev can't\n\t# be done with lsblk.\n\tif [ \"$i\" = \"size\" ] && [ -f \"$somepath\" ] ; then\n\t\tsize=$(du -h --apparent-size \"$somepath\" | cut -f 1)\n\t\techo \"size=$size\"\n\t\tcontinue\n\tfi\n\n\n\tval=\"\"\n\tif val=$(eval \"lsblk -dl -n -o $i $somepath 2>/dev/null\") ; then\n\t\t# Remove leading/trailing whitespace from value\n\t\tval=$(echo \"$val\" | sed -e 's/^[[:space:]]*//' \\\n\t\t     -e 's/[[:space:]]*$//')\n\tfi\n\techo \"$i=$val\"\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}