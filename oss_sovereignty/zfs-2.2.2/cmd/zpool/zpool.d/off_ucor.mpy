{
  "module_name": "off_ucor",
  "hash_id": "b05b0750fe26e1d299bf7f2fa77b9a12eac0d59ea583e2aae9379193c0ce6d7c",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool/zpool.d/off_ucor",
  "human_readable_source": "#!/bin/sh\n#\n# Show SMART stats\n#\n\nhelpstr=\"\nsmart:\t\tShow SMART temperature and error stats (specific to drive type)\nsmartx:\t\tShow SMART extended drive stats (specific to drive type).\ntemp:\t\tShow SMART drive temperature in celsius (all drives).\nhealth:\t\tShow reported SMART status (all drives).\nr_proc:\t\tShow SMART read GBytes processed over drive lifetime (SAS).\nw_proc:\t\tShow SMART write GBytes processed over drive lifetime (SAS).\nr_ucor:\t\tShow SMART read uncorrectable errors (SAS).\nw_ucor:\t\tShow SMART write uncorrectable errors (SAS).\nnonmed:\t\tShow SMART non-medium errors (SAS).\ndefect:\t\tShow SMART grown defect list (SAS).\nhours_on:\tShow number of hours drive powered on (all drives).\nrealloc:\tShow SMART reallocated sectors count (ATA).\nrep_ucor:\tShow SMART reported uncorrectable count (ATA).\ncmd_to:\t\tShow SMART command timeout count (ATA).\npend_sec:\tShow SMART current pending sector count (ATA).\noff_ucor:\tShow SMART offline uncorrectable errors (ATA).\nata_err:\tShow SMART ATA errors (ATA).\npwr_cyc:\tShow SMART power cycle count (ATA).\nserial:\t\tShow disk serial number.\nnvme_err:\tShow SMART NVMe errors (NVMe).\nsmart_test:\tShow SMART self-test results summary.\ntest_type:\tShow SMART self-test type (short, long... ).\ntest_status:\tShow SMART self-test status.\ntest_progress:\tShow SMART self-test percentage done.\ntest_ended:\tShow when the last SMART self-test ended (if supported).\n\"\n\n# Hack for developer testing\n#\n# If you set $samples to a directory containing smartctl output text files,\n# we will use them instead of running smartctl on the vdevs.  This can be\n# useful if you want to test a bunch of different smartctl outputs.  Also, if\n# $samples is set, and additional 'file' column is added to the zpool output\n# showing the filename.\nsamples=\n\n# get_filename_from_dir DIR\n#\n# Look in directory DIR and return a filename from it.  The filename returned\n# is chosen quasi-sequentially (based off our PID).  This allows us to return\n# a different filename every time this script is invoked (which we do for each\n# vdev), without having to maintain state.\nget_filename_from_dir()\n{\n\tdir=$1\n\tpid=\"$$\"\n\tnum_files=$(find \"$dir\" -maxdepth 1 -type f | wc -l)\n\tmod=$((pid % num_files))\n\ti=0\n\tfind \"$dir\" -type f -printf '%f\\n' | while read -r file ; do\n\t\tif [ \"$mod\" = \"$i\" ] ; then\n\t\t\techo \"$file\"\n\t\t\tbreak\n\t\tfi\n\t\ti=$((i+1))\n\tdone\n}\n\nscript=\"${0##*/}\"\n\nif [ \"$1\" = \"-h\" ] ; then\n        echo \"$helpstr\" | grep \"$script:\" | tr -s '\\t' | cut -f 2-\n        exit\nfi\n\n# Sometimes, UPATH ends up /dev/(null).\n# That should be corrected, but for now...\n# shellcheck disable=SC2154\nif [ ! -b \"$VDEV_UPATH\" ]; then\n\tsomepath=\"${VDEV_PATH}\"\nelse\n\tsomepath=\"${VDEV_UPATH}\"\nfi\n\nif [ -b \"$somepath\" ] && PATH=\"/usr/sbin:$PATH\" command -v smartctl > /dev/null || [ -n \"$samples\" ] ; then\n\tif [ -n \"$samples\" ] ; then\n\t\t# cat a smartctl output text file instead of running smartctl\n\t\t# on a vdev (only used for developer testing).\n\t\tfile=$(get_filename_from_dir \"$samples\")\n\t\techo \"file=$file\"\n\t\traw_out=$(cat \"$samples/$file\")\n\telse\n\t\traw_out=$(sudo smartctl -a \"$somepath\")\n\tfi\n\n\t# What kind of drive are we?  Look for the right line in smartctl:\n\t#\n\t# SAS:\n\t#\tTransport protocol:   SAS\n\t#\n\t# SATA:\n\t#\tATA Version is:   8\n\t#\n\t# NVMe:\n\t#       SMART/Health Information (NVMe Log 0xnn, NSID 0xnn)\n\t#\n\tout=$(echo \"$raw_out\" | awk '\n# SAS specific\n/read:/{print \"rrd=\"$4\"\\nr_cor=\"$5\"\\nr_proc=\"$7\"\\nr_ucor=\"$8}\n/write:/{print \"rwr=\"$4\"\\nw_cor=\"$5\"\\nw_proc=\"$7\"\\nw_ucor=\"$8}\n/Non-medium error count/{print \"nonmed=\"$4}\n/Elements in grown defect list/{print \"defect=\"$6}\n\n# SAS common\n/SAS/{type=\"sas\"}\n/Drive Temperature:/{print \"temp=\"$4}\n# Status can be a long string, substitute spaces for '_'\n/SMART Health Status:/{printf \"health=\"; for(i=4;i<=NF-1;i++){printf \"%s_\", $i}; printf \"%s\\n\", $i}\n/number of hours powered up/{print \"hours_on=\"$7; hours_on=int($7)}\n/Serial number:/{print \"serial=\"$3}\n\n# SATA specific\n/Reallocated_Sector_Ct/{print \"realloc=\"$10}\n/Reported_Uncorrect/{print \"rep_ucor=\"$10}\n/Command_Timeout/{print \"cmd_to=\"$10}\n/Current_Pending_Sector/{print \"pend_sec=\"$10}\n/Offline_Uncorrectable/{print \"off_ucor=\"$10}\n/ATA Error Count:/{print \"ata_err=\"$4}\n/Power_Cycle_Count/{print \"pwr_cyc=\"$10}\n\n# SATA common\n/SATA/{type=\"sata\"}\n/Temperature_Celsius/{print \"temp=\"$10}\n/Airflow_Temperature_Cel/{print \"temp=\"$10}\n/Current Temperature:/{print \"temp=\"$3}\n/SMART overall-health self-assessment test result:/{print \"health=\"$6}\n/Power_On_Hours/{print \"hours_on=\"$10; hours_on=int($10)}\n/Serial Number:/{print \"serial=\"$3}\n\n# NVMe common\n/NVMe/{type=\"nvme\"}\n/Temperature:/{print \"temp=\"$2}\n/SMART overall-health self-assessment test result:/{print \"health=\"$6}\n/Power On Hours:/{gsub(\"[^0-9]\",\"\",$4); print \"hours_on=\"$4}\n/Serial Number:/{print \"serial=\"$3}\n/Power Cycles:/{print \"pwr_cyc=\"$3}\n\n# NVMe specific\n/Media and Data Integrity Errors:/{print \"nvme_err=\"$6}\n\n# SMART self-test info\n/Self-test execution status:/{progress=tolower($4)} # SAS\n/SMART Self-test log/{test_seen=1} # SAS\n/SMART Extended Self-test Log/{test_seen=1} # SATA\n/# 1/{\n\ttest_type=tolower($3\"_\"$4);\n\t# Status could be one word (\"Completed\") or multiple (\"Completed: read\n\t# failure\").  Look for the \":\" to see if we need to grab more words.\n\n\tif ($5 ~ \":\")\n\t\tstatus=tolower($5\"\"$6\"_\"$7)\n\telse\n\t\tstatus=tolower($5)\n\tif (status==\"self\")\n\t\tstatus=\"running\";\n\n\tif (type == \"sas\") {\n\t\thours=int($(NF-4))\n\t} else {\n\t\thours=int($(NF-1))\n\t\t# SATA reports percent remaining, rather than percent done\n\t\t# Convert it to percent done.\n\t\tprogress=(100-int($(NF-2)))\"%\"\n\t}\n\t# When we int()-ify \"hours\", it converts stuff like \"NOW\" and \"-\" into\n\t# 0.  In those cases, set it to hours_on, so they will cancel out in\n\t# the \"hours_ago\" calculation later on.\n\tif (hours == 0)\n\t\thours=hours_on\n\n\tif (test_seen) {\n\t\tprint \"test=\"hours_on\n\t\tprint \"test_type=\"test_type\n\t\tprint \"test_status=\"status\n\t\tprint \"test_progress=\"progress\n\t}\n\t# Not all drives report hours_on\n\tif (hours_on && hours) {\n\t\ttotal_hours_ago=(hours_on-hours)\n\t\tdays_ago=int(total_hours_ago/24)\n\t\thours_ago=(total_hours_ago % 24)\n\t\tif (days_ago != 0)\n\t\t\tago_str=days_ago\"d\"\n\t\tif (hours_ago !=0)\n\t\t\tago_str=ago_str\"\"hours_ago\"h\"\n\t\tprint \"test_ended=\"ago_str\n\t}\n}\n\nEND {print \"type=\"type; ORS=\"\\n\"; print \"\"}\n');\nfi\ntype=$(echo \"$out\" | grep '^type=' | cut -d '=' -f 2)\n\n# If type is not set by now, either we don't have a block device\n# or smartctl failed. Either way, default to ATA and set $out to\n# nothing.\nif [ -z \"$type\" ]; then\n\ttype=\"sata\"\n\tout=\nfi\n\ncase $script in\nsmart)\n\t# Print temperature plus common predictors of drive failure\n\tif [ \"$type\" = \"sas\" ] ; then\n\t\tscripts=\"temp|health|r_ucor|w_ucor\"\n\telif [ \"$type\" = \"sata\" ] ; then\n\t\tscripts=\"temp|health|ata_err|realloc|rep_ucor|cmd_to|pend_sec|off_ucor\"\n\telif [ \"$type\" = \"nvme\" ] ; then\n\t\tscripts=\"temp|health|nvme_err\"\n\tfi\n\t;;\nsmartx)\n\t# Print some other interesting stats\n\tif [ \"$type\" = \"sas\" ] ; then\n\t\tscripts=\"hours_on|defect|nonmed|r_proc|w_proc\"\n\telif [ \"$type\" = \"sata\" ] ; then\n\t\tscripts=\"hours_on|pwr_cyc\"\n\telif [ \"$type\" = \"nvme\" ] ; then\n\t\tscripts=\"hours_on|pwr_cyc\"\n\tfi\n\t;;\nsmart_test)\n\tscripts=\"test_type|test_status|test_progress|test_ended\"\n\t;;\n*)\n\tscripts=\"$script\"\nesac\n\nwith_vals=$(echo \"$out\" | grep -E \"$scripts\")\nif [ -n \"$with_vals\" ]; then\n\techo \"$with_vals\"\n\twithout_vals=$(echo \"$scripts\" | tr '|' '\\n' |\n\t\tgrep -v -E \"$(echo \"$with_vals\" |\n\t\tawk -F \"=\" '{print $1}')\" | awk '{print $0\"=\"}')\nelse\n\twithout_vals=$(echo \"$scripts\" | tr '|' '\\n' | awk '{print $0\"=\"}')\nfi\n\nif [ -n \"$without_vals\" ]; then\n\techo \"$without_vals\"\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}