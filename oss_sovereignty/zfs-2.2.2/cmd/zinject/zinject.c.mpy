{
  "module_name": "zinject.c",
  "hash_id": "5acf92932139f00a37045ec23b428a72bbf030e468ae30035819150e5226f1b5",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zinject/zinject.c",
  "human_readable_source": " \n \n\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <unistd.h>\n\n#include <sys/fs/zfs.h>\n#include <sys/mount.h>\n\n#include <libzfs.h>\n\n#undef verify\t \n\n#include \"zinject.h\"\n\nlibzfs_handle_t *g_zfs;\nint zfs_fd;\n\nstatic const char *const errtable[TYPE_INVAL] = {\n\t\"data\",\n\t\"dnode\",\n\t\"mos\",\n\t\"mosdir\",\n\t\"metaslab\",\n\t\"config\",\n\t\"bpobj\",\n\t\"spacemap\",\n\t\"errlog\",\n\t\"uber\",\n\t\"nvlist\",\n\t\"pad1\",\n\t\"pad2\"\n};\n\nstatic err_type_t\nname_to_type(const char *arg)\n{\n\tint i;\n\tfor (i = 0; i < TYPE_INVAL; i++)\n\t\tif (strcmp(errtable[i], arg) == 0)\n\t\t\treturn (i);\n\n\treturn (TYPE_INVAL);\n}\n\nstatic const char *\ntype_to_name(uint64_t type)\n{\n\tswitch (type) {\n\tcase DMU_OT_OBJECT_DIRECTORY:\n\t\treturn (\"mosdir\");\n\tcase DMU_OT_OBJECT_ARRAY:\n\t\treturn (\"metaslab\");\n\tcase DMU_OT_PACKED_NVLIST:\n\t\treturn (\"config\");\n\tcase DMU_OT_BPOBJ:\n\t\treturn (\"bpobj\");\n\tcase DMU_OT_SPACE_MAP:\n\t\treturn (\"spacemap\");\n\tcase DMU_OT_ERROR_LOG:\n\t\treturn (\"errlog\");\n\tdefault:\n\t\treturn (\"-\");\n\t}\n}\n\n\n \nvoid\nusage(void)\n{\n\t(void) printf(\n\t    \"usage:\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tList all active injection records.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -c <id|all>\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tClear the particular record (if given a numeric ID), or\\n\"\n\t    \"\\t\\tall records if 'all' is specified.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -p <function name> pool\\n\"\n\t    \"\\t\\tInject a panic fault at the specified function. Only \\n\"\n\t    \"\\t\\tfunctions which call spa_vdev_config_exit(), or \\n\"\n\t    \"\\t\\tspa_vdev_exit() will trigger a panic.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -d device [-e errno] [-L <nvlist|uber|pad1|pad2>] [-F]\\n\"\n\t    \"\\t\\t[-T <read|write|free|claim|all>] [-f frequency] pool\\n\\n\"\n\t    \"\\t\\tInject a fault into a particular device or the device's\\n\"\n\t    \"\\t\\tlabel.  Label injection can either be 'nvlist', 'uber',\\n \"\n\t    \"\\t\\t'pad1', or 'pad2'.\\n\"\n\t    \"\\t\\t'errno' can be 'nxio' (the default), 'io', 'dtl', or\\n\"\n\t    \"\\t\\t'corrupt' (bit flip).\\n\"\n\t    \"\\t\\t'frequency' is a value between 0.0001 and 100.0 that limits\\n\"\n\t    \"\\t\\tdevice error injection to a percentage of the IOs.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -d device -A <degrade|fault> -D <delay secs> pool\\n\"\n\t    \"\\t\\tPerform a specific action on a particular device.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -d device -D latency:lanes pool\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tAdd an artificial delay to IO requests on a particular\\n\"\n\t    \"\\t\\tdevice, such that the requests take a minimum of 'latency'\\n\"\n\t    \"\\t\\tmilliseconds to complete. Each delay has an associated\\n\"\n\t    \"\\t\\tnumber of 'lanes' which defines the number of concurrent\\n\"\n\t    \"\\t\\tIO requests that can be processed.\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tFor example, with a single lane delay of 10 ms (-D 10:1),\\n\"\n\t    \"\\t\\tthe device will only be able to service a single IO request\\n\"\n\t    \"\\t\\tat a time with each request taking 10 ms to complete. So,\\n\"\n\t    \"\\t\\tif only a single request is submitted every 10 ms, the\\n\"\n\t    \"\\t\\taverage latency will be 10 ms; but if more than one request\\n\"\n\t    \"\\t\\tis submitted every 10 ms, the average latency will be more\\n\"\n\t    \"\\t\\tthan 10 ms.\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tSimilarly, if a delay of 10 ms is specified to have two\\n\"\n\t    \"\\t\\tlanes (-D 10:2), then the device will be able to service\\n\"\n\t    \"\\t\\ttwo requests at a time, each with a minimum latency of\\n\"\n\t    \"\\t\\t10 ms. So, if two requests are submitted every 10 ms, then\\n\"\n\t    \"\\t\\tthe average latency will be 10 ms; but if more than two\\n\"\n\t    \"\\t\\trequests are submitted every 10 ms, the average latency\\n\"\n\t    \"\\t\\twill be more than 10 ms.\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tAlso note, these delays are additive. So two invocations\\n\"\n\t    \"\\t\\tof '-D 10:1', is roughly equivalent to a single invocation\\n\"\n\t    \"\\t\\tof '-D 10:2'. This also means, one can specify multiple\\n\"\n\t    \"\\t\\tlanes with differing target latencies. For example, an\\n\"\n\t    \"\\t\\tinvocation of '-D 10:1' followed by '-D 25:2' will\\n\"\n\t    \"\\t\\tcreate 3 lanes on the device; one lane with a latency\\n\"\n\t    \"\\t\\tof 10 ms and two lanes with a 25 ms latency.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -I [-s <seconds> | -g <txgs>] pool\\n\"\n\t    \"\\t\\tCause the pool to stop writing blocks yet not\\n\"\n\t    \"\\t\\treport errors for a duration.  Simulates buggy hardware\\n\"\n\t    \"\\t\\tthat fails to honor cache flush requests.\\n\"\n\t    \"\\t\\tDefault duration is 30 seconds.  The machine is panicked\\n\"\n\t    \"\\t\\tat the end of the duration.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject -b objset:object:level:blkid pool\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tInject an error into pool 'pool' with the numeric bookmark\\n\"\n\t    \"\\t\\tspecified by the remaining tuple.  Each number is in\\n\"\n\t    \"\\t\\thexadecimal, and only one block can be specified.\\n\"\n\t    \"\\n\"\n\t    \"\\tzinject [-q] <-t type> [-C dvas] [-e errno] [-l level]\\n\"\n\t    \"\\t\\t[-r range] [-a] [-m] [-u] [-f freq] <object>\\n\"\n\t    \"\\n\"\n\t    \"\\t\\tInject an error into the object specified by the '-t' option\\n\"\n\t    \"\\t\\tand the object descriptor.  The 'object' parameter is\\n\"\n\t    \"\\t\\tinterpreted depending on the '-t' option.\\n\"\n\t    \"\\n\"\n\t    \"\\t\\t-q\\tQuiet mode.  Only print out the handler number added.\\n\"\n\t    \"\\t\\t-e\\tInject a specific error.  Must be one of 'io',\\n\"\n\t    \"\\t\\t\\t'checksum', 'decompress', or 'decrypt'.  Default is 'io'.\\n\"\n\t    \"\\t\\t-C\\tInject the given error only into specific DVAs. The\\n\"\n\t    \"\\t\\t\\tDVAs should be specified as a list of 0-indexed DVAs\\n\"\n\t    \"\\t\\t\\tseparated by commas (ex. '0,2').\\n\"\n\t    \"\\t\\t-l\\tInject error at a particular block level. Default is \"\n\t    \"0.\\n\"\n\t    \"\\t\\t-m\\tAutomatically remount underlying filesystem.\\n\"\n\t    \"\\t\\t-r\\tInject error over a particular logical range of an\\n\"\n\t    \"\\t\\t\\tobject.  Will be translated to the appropriate blkid\\n\"\n\t    \"\\t\\t\\trange according to the object's properties.\\n\"\n\t    \"\\t\\t-a\\tFlush the ARC cache.  Can be specified without any\\n\"\n\t    \"\\t\\t\\tassociated object.\\n\"\n\t    \"\\t\\t-u\\tUnload the associated pool.  Can be specified with only\\n\"\n\t    \"\\t\\t\\ta pool object.\\n\"\n\t    \"\\t\\t-f\\tOnly inject errors a fraction of the time.  Expressed as\\n\"\n\t    \"\\t\\t\\ta percentage between 0.0001 and 100.\\n\"\n\t    \"\\n\"\n\t    \"\\t-t data\\t\\tInject an error into the plain file contents of a\\n\"\n\t    \"\\t\\t\\tfile.  The object must be specified as a complete path\\n\"\n\t    \"\\t\\t\\tto a file on a ZFS filesystem.\\n\"\n\t    \"\\n\"\n\t    \"\\t-t dnode\\tInject an error into the metadnode in the block\\n\"\n\t    \"\\t\\t\\tcorresponding to the dnode for a file or directory.  The\\n\"\n\t    \"\\t\\t\\t'-r' option is incompatible with this mode.  The object\\n\"\n\t    \"\\t\\t\\tis specified as a complete path to a file or directory\\n\"\n\t    \"\\t\\t\\ton a ZFS filesystem.\\n\"\n\t    \"\\n\"\n\t    \"\\t-t <mos>\\tInject errors into the MOS for objects of the given\\n\"\n\t    \"\\t\\t\\ttype.  Valid types are: mos, mosdir, config, bpobj,\\n\"\n\t    \"\\t\\t\\tspacemap, metaslab, errlog.  The only valid <object> is\\n\"\n\t    \"\\t\\t\\tthe poolname.\\n\");\n}\n\nstatic int\niter_handlers(int (*func)(int, const char *, zinject_record_t *, void *),\n    void *data)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\tint ret;\n\n\twhile (zfs_ioctl(g_zfs, ZFS_IOC_INJECT_LIST_NEXT, &zc) == 0)\n\t\tif ((ret = func((int)zc.zc_guid, zc.zc_name,\n\t\t    &zc.zc_inject_record, data)) != 0)\n\t\t\treturn (ret);\n\n\tif (errno != ENOENT) {\n\t\t(void) fprintf(stderr, \"Unable to list handlers: %s\\n\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nprint_data_handler(int id, const char *pool, zinject_record_t *record,\n    void *data)\n{\n\tint *count = data;\n\n\tif (record->zi_guid != 0 || record->zi_func[0] != '\\0')\n\t\treturn (0);\n\n\tif (*count == 0) {\n\t\t(void) printf(\"%3s  %-15s  %-6s  %-6s  %-8s  %3s  %-4s  \"\n\t\t    \"%-15s\\n\", \"ID\", \"POOL\", \"OBJSET\", \"OBJECT\", \"TYPE\",\n\t\t    \"LVL\", \"DVAs\", \"RANGE\");\n\t\t(void) printf(\"---  ---------------  ------  \"\n\t\t    \"------  --------  ---  ----  ---------------\\n\");\n\t}\n\n\t*count += 1;\n\n\t(void) printf(\"%3d  %-15s  %-6llu  %-6llu  %-8s  %-3d  0x%02x  \",\n\t    id, pool, (u_longlong_t)record->zi_objset,\n\t    (u_longlong_t)record->zi_object, type_to_name(record->zi_type),\n\t    record->zi_level, record->zi_dvas);\n\n\n\tif (record->zi_start == 0 &&\n\t    record->zi_end == -1ULL)\n\t\t(void) printf(\"all\\n\");\n\telse\n\t\t(void) printf(\"[%llu, %llu]\\n\", (u_longlong_t)record->zi_start,\n\t\t    (u_longlong_t)record->zi_end);\n\n\treturn (0);\n}\n\nstatic int\nprint_device_handler(int id, const char *pool, zinject_record_t *record,\n    void *data)\n{\n\tint *count = data;\n\n\tif (record->zi_guid == 0 || record->zi_func[0] != '\\0')\n\t\treturn (0);\n\n\tif (record->zi_cmd == ZINJECT_DELAY_IO)\n\t\treturn (0);\n\n\tif (*count == 0) {\n\t\t(void) printf(\"%3s  %-15s  %s\\n\", \"ID\", \"POOL\", \"GUID\");\n\t\t(void) printf(\"---  ---------------  ----------------\\n\");\n\t}\n\n\t*count += 1;\n\n\t(void) printf(\"%3d  %-15s  %llx\\n\", id, pool,\n\t    (u_longlong_t)record->zi_guid);\n\n\treturn (0);\n}\n\nstatic int\nprint_delay_handler(int id, const char *pool, zinject_record_t *record,\n    void *data)\n{\n\tint *count = data;\n\n\tif (record->zi_guid == 0 || record->zi_func[0] != '\\0')\n\t\treturn (0);\n\n\tif (record->zi_cmd != ZINJECT_DELAY_IO)\n\t\treturn (0);\n\n\tif (*count == 0) {\n\t\t(void) printf(\"%3s  %-15s  %-15s  %-15s  %s\\n\",\n\t\t    \"ID\", \"POOL\", \"DELAY (ms)\", \"LANES\", \"GUID\");\n\t\t(void) printf(\"---  ---------------  ---------------  \"\n\t\t    \"---------------  ----------------\\n\");\n\t}\n\n\t*count += 1;\n\n\t(void) printf(\"%3d  %-15s  %-15llu  %-15llu  %llx\\n\", id, pool,\n\t    (u_longlong_t)NSEC2MSEC(record->zi_timer),\n\t    (u_longlong_t)record->zi_nlanes,\n\t    (u_longlong_t)record->zi_guid);\n\n\treturn (0);\n}\n\nstatic int\nprint_panic_handler(int id, const char *pool, zinject_record_t *record,\n    void *data)\n{\n\tint *count = data;\n\n\tif (record->zi_func[0] == '\\0')\n\t\treturn (0);\n\n\tif (*count == 0) {\n\t\t(void) printf(\"%3s  %-15s  %s\\n\", \"ID\", \"POOL\", \"FUNCTION\");\n\t\t(void) printf(\"---  ---------------  ----------------\\n\");\n\t}\n\n\t*count += 1;\n\n\t(void) printf(\"%3d  %-15s  %s\\n\", id, pool, record->zi_func);\n\n\treturn (0);\n}\n\n \nstatic int\nprint_all_handlers(void)\n{\n\tint count = 0, total = 0;\n\n\t(void) iter_handlers(print_device_handler, &count);\n\tif (count > 0) {\n\t\ttotal += count;\n\t\t(void) printf(\"\\n\");\n\t\tcount = 0;\n\t}\n\n\t(void) iter_handlers(print_delay_handler, &count);\n\tif (count > 0) {\n\t\ttotal += count;\n\t\t(void) printf(\"\\n\");\n\t\tcount = 0;\n\t}\n\n\t(void) iter_handlers(print_data_handler, &count);\n\tif (count > 0) {\n\t\ttotal += count;\n\t\t(void) printf(\"\\n\");\n\t\tcount = 0;\n\t}\n\n\t(void) iter_handlers(print_panic_handler, &count);\n\n\treturn (count + total);\n}\n\nstatic int\ncancel_one_handler(int id, const char *pool, zinject_record_t *record,\n    void *data)\n{\n\t(void) pool, (void) record, (void) data;\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tzc.zc_guid = (uint64_t)id;\n\n\tif (zfs_ioctl(g_zfs, ZFS_IOC_CLEAR_FAULT, &zc) != 0) {\n\t\t(void) fprintf(stderr, \"failed to remove handler %d: %s\\n\",\n\t\t    id, strerror(errno));\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\ncancel_all_handlers(void)\n{\n\tint ret = iter_handlers(cancel_one_handler, NULL);\n\n\tif (ret == 0)\n\t\t(void) printf(\"removed all registered handlers\\n\");\n\n\treturn (ret);\n}\n\n \nstatic int\ncancel_handler(int id)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tzc.zc_guid = (uint64_t)id;\n\n\tif (zfs_ioctl(g_zfs, ZFS_IOC_CLEAR_FAULT, &zc) != 0) {\n\t\t(void) fprintf(stderr, \"failed to remove handler %d: %s\\n\",\n\t\t    id, strerror(errno));\n\t\treturn (1);\n\t}\n\n\t(void) printf(\"removed handler %d\\n\", id);\n\n\treturn (0);\n}\n\n \nstatic int\nregister_handler(const char *pool, int flags, zinject_record_t *record,\n    int quiet)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\t(void) strlcpy(zc.zc_name, pool, sizeof (zc.zc_name));\n\tzc.zc_inject_record = *record;\n\tzc.zc_guid = flags;\n\n\tif (zfs_ioctl(g_zfs, ZFS_IOC_INJECT_FAULT, &zc) != 0) {\n\t\t(void) fprintf(stderr, \"failed to add handler: %s\\n\",\n\t\t    errno == EDOM ? \"block level exceeds max level of object\" :\n\t\t    strerror(errno));\n\t\treturn (1);\n\t}\n\n\tif (flags & ZINJECT_NULL)\n\t\treturn (0);\n\n\tif (quiet) {\n\t\t(void) printf(\"%llu\\n\", (u_longlong_t)zc.zc_guid);\n\t} else {\n\t\t(void) printf(\"Added handler %llu with the following \"\n\t\t    \"properties:\\n\", (u_longlong_t)zc.zc_guid);\n\t\t(void) printf(\"  pool: %s\\n\", pool);\n\t\tif (record->zi_guid) {\n\t\t\t(void) printf(\"  vdev: %llx\\n\",\n\t\t\t    (u_longlong_t)record->zi_guid);\n\t\t} else if (record->zi_func[0] != '\\0') {\n\t\t\t(void) printf(\"  panic function: %s\\n\",\n\t\t\t    record->zi_func);\n\t\t} else if (record->zi_duration > 0) {\n\t\t\t(void) printf(\" time: %lld seconds\\n\",\n\t\t\t    (u_longlong_t)record->zi_duration);\n\t\t} else if (record->zi_duration < 0) {\n\t\t\t(void) printf(\" txgs: %lld \\n\",\n\t\t\t    (u_longlong_t)-record->zi_duration);\n\t\t} else {\n\t\t\t(void) printf(\"objset: %llu\\n\",\n\t\t\t    (u_longlong_t)record->zi_objset);\n\t\t\t(void) printf(\"object: %llu\\n\",\n\t\t\t    (u_longlong_t)record->zi_object);\n\t\t\t(void) printf(\"  type: %llu\\n\",\n\t\t\t    (u_longlong_t)record->zi_type);\n\t\t\t(void) printf(\" level: %d\\n\", record->zi_level);\n\t\t\tif (record->zi_start == 0 &&\n\t\t\t    record->zi_end == -1ULL)\n\t\t\t\t(void) printf(\" range: all\\n\");\n\t\t\telse\n\t\t\t\t(void) printf(\" range: [%llu, %llu)\\n\",\n\t\t\t\t    (u_longlong_t)record->zi_start,\n\t\t\t\t    (u_longlong_t)record->zi_end);\n\t\t\t(void) printf(\"  dvas: 0x%x\\n\", record->zi_dvas);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nperform_action(const char *pool, zinject_record_t *record, int cmd)\n{\n\tzfs_cmd_t zc = {\"\\0\"};\n\n\tASSERT(cmd == VDEV_STATE_DEGRADED || cmd == VDEV_STATE_FAULTED);\n\t(void) strlcpy(zc.zc_name, pool, sizeof (zc.zc_name));\n\tzc.zc_guid = record->zi_guid;\n\tzc.zc_cookie = cmd;\n\n\tif (zfs_ioctl(g_zfs, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)\n\t\treturn (0);\n\n\treturn (1);\n}\n\nstatic int\nparse_delay(char *str, uint64_t *delay, uint64_t *nlanes)\n{\n\tunsigned long scan_delay;\n\tunsigned long scan_nlanes;\n\n\tif (sscanf(str, \"%lu:%lu\", &scan_delay, &scan_nlanes) != 2)\n\t\treturn (1);\n\n\t \n\tif (scan_delay == 0)\n\t\treturn (1);\n\n\t \n\t*delay = MSEC2NSEC(scan_delay);\n\t*nlanes = scan_nlanes;\n\n\treturn (0);\n}\n\nstatic int\nparse_frequency(const char *str, uint32_t *percent)\n{\n\tdouble val;\n\tchar *post;\n\n\tval = strtod(str, &post);\n\tif (post == NULL || *post != '\\0')\n\t\treturn (EINVAL);\n\n\t \n\tval /= 100.0f;\n\tif (val < 0.000001f || val > 1.0f)\n\t\treturn (ERANGE);\n\n\t \n\t*percent = ((uint32_t)(val * ZI_PERCENTAGE_MAX));\n\n\treturn (0);\n}\n\n \nstatic int\nparse_dvas(const char *str, uint32_t *dvas_out)\n{\n\tconst char *c = str;\n\tuint32_t mask = 0;\n\tboolean_t need_delim = B_FALSE;\n\n\t \n\tif (strlen(str) > 5 || strlen(str) == 0)\n\t\treturn (EINVAL);\n\n\twhile (*c != '\\0') {\n\t\tswitch (*c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\t\t \n\t\t\tif (need_delim)\n\t\t\t\treturn (EINVAL);\n\n\t\t\t \n\t\t\tif (mask & (1 << ((*c) - '0')))\n\t\t\t\treturn (EINVAL);\n\n\t\t\tmask |= (1 << ((*c) - '0'));\n\t\t\tneed_delim = B_TRUE;\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tneed_delim = B_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn (EINVAL);\n\t\t}\n\t\tc++;\n\t}\n\n\t \n\tif (!need_delim)\n\t\treturn (EINVAL);\n\n\t*dvas_out = mask;\n\treturn (0);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint c;\n\tchar *range = NULL;\n\tchar *cancel = NULL;\n\tchar *end;\n\tchar *raw = NULL;\n\tchar *device = NULL;\n\tint level = 0;\n\tint quiet = 0;\n\tint error = 0;\n\tint domount = 0;\n\tint io_type = ZIO_TYPES;\n\tint action = VDEV_STATE_UNKNOWN;\n\terr_type_t type = TYPE_INVAL;\n\terr_type_t label = TYPE_INVAL;\n\tzinject_record_t record = { 0 };\n\tchar pool[MAXNAMELEN] = \"\";\n\tchar dataset[MAXNAMELEN] = \"\";\n\tzfs_handle_t *zhp = NULL;\n\tint nowrites = 0;\n\tint dur_txg = 0;\n\tint dur_secs = 0;\n\tint ret;\n\tint flags = 0;\n\tuint32_t dvas = 0;\n\n\tif ((g_zfs = libzfs_init()) == NULL) {\n\t\t(void) fprintf(stderr, \"%s\\n\", libzfs_error_init(errno));\n\t\treturn (1);\n\t}\n\n\tlibzfs_print_on_error(g_zfs, B_TRUE);\n\n\tif ((zfs_fd = open(ZFS_DEV, O_RDWR)) < 0) {\n\t\t(void) fprintf(stderr, \"failed to open ZFS device\\n\");\n\t\tlibzfs_fini(g_zfs);\n\t\treturn (1);\n\t}\n\n\tif (argc == 1) {\n\t\t \n\t\tif (print_all_handlers() == 0) {\n\t\t\t(void) printf(\"No handlers registered.\\n\");\n\t\t\t(void) printf(\"Run 'zinject -h' for usage \"\n\t\t\t    \"information.\\n\");\n\t\t}\n\t\tlibzfs_fini(g_zfs);\n\t\treturn (0);\n\t}\n\n\twhile ((c = getopt(argc, argv,\n\t    \":aA:b:C:d:D:f:Fg:qhIc:t:T:l:mr:s:e:uL:p:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tflags |= ZINJECT_FLUSH_ARC;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tif (strcasecmp(optarg, \"degrade\") == 0) {\n\t\t\t\taction = VDEV_STATE_DEGRADED;\n\t\t\t} else if (strcasecmp(optarg, \"fault\") == 0) {\n\t\t\t\taction = VDEV_STATE_FAULTED;\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr, \"invalid action '%s': \"\n\t\t\t\t    \"must be 'degrade' or 'fault'\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\traw = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcancel = optarg;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tret = parse_dvas(optarg, &dvas);\n\t\t\tif (ret != 0) {\n\t\t\t\t(void) fprintf(stderr, \"invalid DVA list '%s': \"\n\t\t\t\t    \"DVAs should be 0 indexed and separated by \"\n\t\t\t\t    \"commas.\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\terrno = 0;\n\t\t\tret = parse_delay(optarg, &record.zi_timer,\n\t\t\t    &record.zi_nlanes);\n\t\t\tif (ret != 0) {\n\n\t\t\t\t(void) fprintf(stderr, \"invalid i/o delay \"\n\t\t\t\t    \"value: '%s'\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (strcasecmp(optarg, \"io\") == 0) {\n\t\t\t\terror = EIO;\n\t\t\t} else if (strcasecmp(optarg, \"checksum\") == 0) {\n\t\t\t\terror = ECKSUM;\n\t\t\t} else if (strcasecmp(optarg, \"decompress\") == 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t} else if (strcasecmp(optarg, \"decrypt\") == 0) {\n\t\t\t\terror = EACCES;\n\t\t\t} else if (strcasecmp(optarg, \"nxio\") == 0) {\n\t\t\t\terror = ENXIO;\n\t\t\t} else if (strcasecmp(optarg, \"dtl\") == 0) {\n\t\t\t\terror = ECHILD;\n\t\t\t} else if (strcasecmp(optarg, \"corrupt\") == 0) {\n\t\t\t\terror = EILSEQ;\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr, \"invalid error type \"\n\t\t\t\t    \"'%s': must be 'io', 'checksum' or \"\n\t\t\t\t    \"'nxio'\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tret = parse_frequency(optarg, &record.zi_freq);\n\t\t\tif (ret != 0) {\n\t\t\t\t(void) fprintf(stderr, \"%sfrequency value must \"\n\t\t\t\t    \"be in the range [0.0001, 100.0]\\n\",\n\t\t\t\t    ret == EINVAL ? \"invalid value: \" :\n\t\t\t\t    ret == ERANGE ? \"out of range: \" : \"\");\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\trecord.zi_failfast = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tdur_txg = 1;\n\t\t\trecord.zi_duration = (int)strtol(optarg, &end, 10);\n\t\t\tif (record.zi_duration <= 0 || *end != '\\0') {\n\t\t\t\t(void) fprintf(stderr, \"invalid duration '%s': \"\n\t\t\t\t    \"must be a positive integer\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t \n\t\t\trecord.zi_duration *= -1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (0);\n\t\tcase 'I':\n\t\t\t \n\t\t\tnowrites = 1;\n\t\t\tif (dur_secs == 0 && dur_txg == 0)\n\t\t\t\trecord.zi_duration = 30;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlevel = (int)strtol(optarg, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\t(void) fprintf(stderr, \"invalid level '%s': \"\n\t\t\t\t    \"must be an integer\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tdomount = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t(void) strlcpy(record.zi_func, optarg,\n\t\t\t    sizeof (record.zi_func));\n\t\t\trecord.zi_cmd = ZINJECT_PANIC;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trange = optarg;\n\t\t\tflags |= ZINJECT_CALC_RANGE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tdur_secs = 1;\n\t\t\trecord.zi_duration = (int)strtol(optarg, &end, 10);\n\t\t\tif (record.zi_duration <= 0 || *end != '\\0') {\n\t\t\t\t(void) fprintf(stderr, \"invalid duration '%s': \"\n\t\t\t\t    \"must be a positive integer\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tif (strcasecmp(optarg, \"read\") == 0) {\n\t\t\t\tio_type = ZIO_TYPE_READ;\n\t\t\t} else if (strcasecmp(optarg, \"write\") == 0) {\n\t\t\t\tio_type = ZIO_TYPE_WRITE;\n\t\t\t} else if (strcasecmp(optarg, \"free\") == 0) {\n\t\t\t\tio_type = ZIO_TYPE_FREE;\n\t\t\t} else if (strcasecmp(optarg, \"claim\") == 0) {\n\t\t\t\tio_type = ZIO_TYPE_CLAIM;\n\t\t\t} else if (strcasecmp(optarg, \"all\") == 0) {\n\t\t\t\tio_type = ZIO_TYPES;\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr, \"invalid I/O type \"\n\t\t\t\t    \"'%s': must be 'read', 'write', 'free', \"\n\t\t\t\t    \"'claim' or 'all'\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((type = name_to_type(optarg)) == TYPE_INVAL &&\n\t\t\t    !MOS_TYPE(type)) {\n\t\t\t\t(void) fprintf(stderr, \"invalid type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags |= ZINJECT_UNLOAD_SPA;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif ((label = name_to_type(optarg)) == TYPE_INVAL &&\n\t\t\t    !LABEL_TYPE(type)) {\n\t\t\t\t(void) fprintf(stderr, \"invalid label type \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, \"option -%c requires an \"\n\t\t\t    \"operand\\n\", optopt);\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, \"invalid option '%c'\\n\",\n\t\t\t    optopt);\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (record.zi_duration != 0)\n\t\trecord.zi_cmd = ZINJECT_IGNORED_WRITES;\n\n\tif (cancel != NULL) {\n\t\t \n\t\tif (raw != NULL || range != NULL || type != TYPE_INVAL ||\n\t\t    level != 0 || record.zi_cmd != ZINJECT_UNINITIALIZED ||\n\t\t    record.zi_freq > 0 || dvas != 0) {\n\t\t\t(void) fprintf(stderr, \"cancel (-c) incompatible with \"\n\t\t\t    \"any other options\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, \"extraneous argument to '-c'\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (strcmp(cancel, \"all\") == 0) {\n\t\t\treturn (cancel_all_handlers());\n\t\t} else {\n\t\t\tint id = (int)strtol(cancel, &end, 10);\n\t\t\tif (*end != '\\0') {\n\t\t\t\t(void) fprintf(stderr, \"invalid handle id '%s':\"\n\t\t\t\t    \" must be an integer or 'all'\\n\", cancel);\n\t\t\t\tusage();\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\treturn (cancel_handler(id));\n\t\t}\n\t}\n\n\tif (device != NULL) {\n\t\t \n\t\tif (raw != NULL || range != NULL || type != TYPE_INVAL ||\n\t\t    level != 0 || record.zi_cmd != ZINJECT_UNINITIALIZED ||\n\t\t    dvas != 0) {\n\t\t\t(void) fprintf(stderr, \"device (-d) incompatible with \"\n\t\t\t    \"data error injection\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (argc != 1) {\n\t\t\t(void) fprintf(stderr, \"device (-d) injection requires \"\n\t\t\t    \"a single pool name\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\t(void) strlcpy(pool, argv[0], sizeof (pool));\n\t\tdataset[0] = '\\0';\n\n\t\tif (error == ECKSUM) {\n\t\t\t(void) fprintf(stderr, \"device error type must be \"\n\t\t\t    \"'io', 'nxio' or 'corrupt'\\n\");\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (error == EILSEQ &&\n\t\t    (record.zi_freq == 0 || io_type != ZIO_TYPE_READ)) {\n\t\t\t(void) fprintf(stderr, \"device corrupt errors require \"\n\t\t\t    \"io type read and a frequency value\\n\");\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\n\t\trecord.zi_iotype = io_type;\n\t\tif (translate_device(pool, device, label, &record) != 0) {\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\t\tif (!error)\n\t\t\terror = ENXIO;\n\n\t\tif (action != VDEV_STATE_UNKNOWN)\n\t\t\treturn (perform_action(pool, &record, action));\n\n\t} else if (raw != NULL) {\n\t\tif (range != NULL || type != TYPE_INVAL || level != 0 ||\n\t\t    record.zi_cmd != ZINJECT_UNINITIALIZED ||\n\t\t    record.zi_freq > 0 || dvas != 0) {\n\t\t\t(void) fprintf(stderr, \"raw (-b) format with \"\n\t\t\t    \"any other options\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (argc != 1) {\n\t\t\t(void) fprintf(stderr, \"raw (-b) format expects a \"\n\t\t\t    \"single pool name\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\t(void) strlcpy(pool, argv[0], sizeof (pool));\n\t\tdataset[0] = '\\0';\n\n\t\tif (error == ENXIO) {\n\t\t\t(void) fprintf(stderr, \"data error type must be \"\n\t\t\t    \"'checksum' or 'io'\\n\");\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\n\t\trecord.zi_cmd = ZINJECT_DATA_FAULT;\n\t\tif (translate_raw(raw, &record) != 0) {\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\t\tif (!error)\n\t\t\terror = EIO;\n\t} else if (record.zi_cmd == ZINJECT_PANIC) {\n\t\tif (raw != NULL || range != NULL || type != TYPE_INVAL ||\n\t\t    level != 0 || device != NULL || record.zi_freq > 0 ||\n\t\t    dvas != 0) {\n\t\t\t(void) fprintf(stderr, \"panic (-p) incompatible with \"\n\t\t\t    \"other options\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (argc < 1 || argc > 2) {\n\t\t\t(void) fprintf(stderr, \"panic (-p) injection requires \"\n\t\t\t    \"a single pool name and an optional id\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\t(void) strlcpy(pool, argv[0], sizeof (pool));\n\t\tif (argv[1] != NULL)\n\t\t\trecord.zi_type = atoi(argv[1]);\n\t\tdataset[0] = '\\0';\n\t} else if (record.zi_cmd == ZINJECT_IGNORED_WRITES) {\n\t\tif (raw != NULL || range != NULL || type != TYPE_INVAL ||\n\t\t    level != 0 || record.zi_freq > 0 || dvas != 0) {\n\t\t\t(void) fprintf(stderr, \"hardware failure (-I) \"\n\t\t\t    \"incompatible with other options\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (nowrites == 0) {\n\t\t\t(void) fprintf(stderr, \"-s or -g meaningless \"\n\t\t\t    \"without -I (ignore writes)\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t} else if (dur_secs && dur_txg) {\n\t\t\t(void) fprintf(stderr, \"choose a duration either \"\n\t\t\t    \"in seconds (-s) or a number of txgs (-g) \"\n\t\t\t    \"but not both\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t} else if (argc != 1) {\n\t\t\t(void) fprintf(stderr, \"ignore writes (-I) \"\n\t\t\t    \"injection requires a single pool name\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\t(void) strlcpy(pool, argv[0], sizeof (pool));\n\t\tdataset[0] = '\\0';\n\t} else if (type == TYPE_INVAL) {\n\t\tif (flags == 0) {\n\t\t\t(void) fprintf(stderr, \"at least one of '-b', '-d', \"\n\t\t\t    \"'-t', '-a', '-p', '-I' or '-u' \"\n\t\t\t    \"must be specified\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (argc == 1 && (flags & ZINJECT_UNLOAD_SPA)) {\n\t\t\t(void) strlcpy(pool, argv[0], sizeof (pool));\n\t\t\tdataset[0] = '\\0';\n\t\t} else if (argc != 0) {\n\t\t\t(void) fprintf(stderr, \"extraneous argument for \"\n\t\t\t    \"'-f'\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tflags |= ZINJECT_NULL;\n\t} else {\n\t\tif (argc != 1) {\n\t\t\t(void) fprintf(stderr, \"missing object\\n\");\n\t\t\tusage();\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (2);\n\t\t}\n\n\t\tif (error == ENXIO || error == EILSEQ) {\n\t\t\t(void) fprintf(stderr, \"data error type must be \"\n\t\t\t    \"'checksum' or 'io'\\n\");\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (dvas != 0) {\n\t\t\tif (error == EACCES || error == EINVAL) {\n\t\t\t\t(void) fprintf(stderr, \"the '-C' option may \"\n\t\t\t\t    \"not be used with logical data errors \"\n\t\t\t\t    \"'decrypt' and 'decompress'\\n\");\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\n\t\t\trecord.zi_dvas = dvas;\n\t\t}\n\n\t\tif (error == EACCES) {\n\t\t\tif (type != TYPE_DATA) {\n\t\t\t\t(void) fprintf(stderr, \"decryption errors \"\n\t\t\t\t    \"may only be injected for 'data' types\\n\");\n\t\t\t\tlibzfs_fini(g_zfs);\n\t\t\t\treturn (1);\n\t\t\t}\n\n\t\t\trecord.zi_cmd = ZINJECT_DECRYPT_FAULT;\n\t\t\t \n\t\t\terror = ECKSUM;\n\t\t} else {\n\t\t\trecord.zi_cmd = ZINJECT_DATA_FAULT;\n\t\t}\n\n\t\tif (translate_record(type, argv[0], range, level, &record, pool,\n\t\t    dataset) != 0) {\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\t\tif (!error)\n\t\t\terror = EIO;\n\t}\n\n\t \n\tif (dataset[0] != '\\0' && domount) {\n\t\tif ((zhp = zfs_open(g_zfs, dataset,\n\t\t    ZFS_TYPE_DATASET)) == NULL) {\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\t\tif (zfs_unmount(zhp, NULL, 0) != 0) {\n\t\t\tlibzfs_fini(g_zfs);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\trecord.zi_error = error;\n\n\tret = register_handler(pool, flags, &record, quiet);\n\n\tif (dataset[0] != '\\0' && domount)\n\t\tret = (zfs_mount(zhp, NULL, 0) != 0);\n\n\tlibzfs_fini(g_zfs);\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}