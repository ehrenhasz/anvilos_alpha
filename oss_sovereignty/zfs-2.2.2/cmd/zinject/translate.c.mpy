{
  "module_name": "translate.c",
  "hash_id": "70d6d17e160136108674167ffddb29dbc18abdde4d532d8c7833ad025d2f1971",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zinject/translate.c",
  "human_readable_source": " \n \n\n#include <libzfs.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/mntent.h>\n#include <sys/mnttab.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dnode.h>\n#include <sys/vdev_impl.h>\n\n#include <sys/mkdev.h>\n\n#include \"zinject.h\"\n\nstatic int debug;\n\nstatic void\nziprintf(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (!debug)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\t(void) vprintf(fmt, ap);\n\tva_end(ap);\n}\n\nstatic void\ncompress_slashes(const char *src, char *dest)\n{\n\twhile (*src != '\\0') {\n\t\t*dest = *src++;\n\t\twhile (*dest == '/' && *src == '/')\n\t\t\t++src;\n\t\t++dest;\n\t}\n\t*dest = '\\0';\n}\n\n \nstatic int\nparse_pathname(const char *inpath, char *dataset, char *relpath,\n    struct stat64 *statbuf)\n{\n\tstruct extmnttab mp;\n\tconst char *rel;\n\tchar fullpath[MAXPATHLEN];\n\n\tcompress_slashes(inpath, fullpath);\n\n\tif (fullpath[0] != '/') {\n\t\t(void) fprintf(stderr, \"invalid object '%s': must be full \"\n\t\t    \"path\\n\", fullpath);\n\t\tusage();\n\t\treturn (-1);\n\t}\n\n\tif (getextmntent(fullpath, &mp, statbuf) != 0) {\n\t\t(void) fprintf(stderr, \"cannot find mountpoint for '%s'\\n\",\n\t\t    fullpath);\n\t\treturn (-1);\n\t}\n\n\tif (strcmp(mp.mnt_fstype, MNTTYPE_ZFS) != 0) {\n\t\t(void) fprintf(stderr, \"invalid path '%s': not a ZFS \"\n\t\t    \"filesystem\\n\", fullpath);\n\t\treturn (-1);\n\t}\n\n\tif (strncmp(fullpath, mp.mnt_mountp, strlen(mp.mnt_mountp)) != 0) {\n\t\t(void) fprintf(stderr, \"invalid path '%s': mountpoint \"\n\t\t    \"doesn't match path\\n\", fullpath);\n\t\treturn (-1);\n\t}\n\n\t(void) strlcpy(dataset, mp.mnt_special, MAXNAMELEN);\n\n\trel = fullpath + strlen(mp.mnt_mountp);\n\tif (rel[0] == '/')\n\t\trel++;\n\t(void) strlcpy(relpath, rel, MAXPATHLEN);\n\n\treturn (0);\n}\n\n \nstatic int\nobject_from_path(const char *dataset, uint64_t object, zinject_record_t *record)\n{\n\tzfs_handle_t *zhp;\n\n\tif ((zhp = zfs_open(g_zfs, dataset, ZFS_TYPE_DATASET)) == NULL)\n\t\treturn (-1);\n\n\trecord->zi_objset = zfs_prop_get_int(zhp, ZFS_PROP_OBJSETID);\n\trecord->zi_object = object;\n\n\tzfs_close(zhp);\n\n\treturn (0);\n}\n\n \nstatic int\ninitialize_range(err_type_t type, int level, char *range,\n    zinject_record_t *record)\n{\n\t \n\tif (range == NULL) {\n\t\t \n\t\trecord->zi_start = 0;\n\t\trecord->zi_end = -1ULL;\n\t} else {\n\t\tchar *end;\n\n\t\t \n\t\trecord->zi_start = strtoull(range, &end, 10);\n\n\n\t\tif (*end == '\\0')\n\t\t\trecord->zi_end = record->zi_start + 1;\n\t\telse if (*end == ',')\n\t\t\trecord->zi_end = strtoull(end + 1, &end, 10);\n\n\t\tif (*end != '\\0') {\n\t\t\t(void) fprintf(stderr, \"invalid range '%s': must be \"\n\t\t\t    \"a numeric range of the form 'start[,end]'\\n\",\n\t\t\t    range);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tswitch (type) {\n\tdefault:\n\t\tbreak;\n\n\tcase TYPE_DATA:\n\t\tbreak;\n\n\tcase TYPE_DNODE:\n\t\t \n\t\tif (range != NULL) {\n\t\t\t(void) fprintf(stderr, \"range cannot be specified when \"\n\t\t\t    \"type is 'dnode'\\n\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\trecord->zi_start = record->zi_object * sizeof (dnode_phys_t);\n\t\trecord->zi_end = record->zi_start + sizeof (dnode_phys_t);\n\t\trecord->zi_object = 0;\n\t\tbreak;\n\t}\n\n\trecord->zi_level = level;\n\n\treturn (0);\n}\n\nint\ntranslate_record(err_type_t type, const char *object, const char *range,\n    int level, zinject_record_t *record, char *poolname, char *dataset)\n{\n\tchar path[MAXPATHLEN];\n\tchar *slash;\n\tstruct stat64 statbuf;\n\tint ret = -1;\n\n\tdebug = (getenv(\"ZINJECT_DEBUG\") != NULL);\n\n\tziprintf(\"translating: %s\\n\", object);\n\n\tif (MOS_TYPE(type)) {\n\t\t \n\t\tswitch (type) {\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase TYPE_MOS:\n\t\t\trecord->zi_type = 0;\n\t\t\tbreak;\n\t\tcase TYPE_MOSDIR:\n\t\t\trecord->zi_type = DMU_OT_OBJECT_DIRECTORY;\n\t\t\tbreak;\n\t\tcase TYPE_METASLAB:\n\t\t\trecord->zi_type = DMU_OT_OBJECT_ARRAY;\n\t\t\tbreak;\n\t\tcase TYPE_CONFIG:\n\t\t\trecord->zi_type = DMU_OT_PACKED_NVLIST;\n\t\t\tbreak;\n\t\tcase TYPE_BPOBJ:\n\t\t\trecord->zi_type = DMU_OT_BPOBJ;\n\t\t\tbreak;\n\t\tcase TYPE_SPACEMAP:\n\t\t\trecord->zi_type = DMU_OT_SPACE_MAP;\n\t\t\tbreak;\n\t\tcase TYPE_ERRLOG:\n\t\t\trecord->zi_type = DMU_OT_ERROR_LOG;\n\t\t\tbreak;\n\t\t}\n\n\t\tdataset[0] = '\\0';\n\t\t(void) strlcpy(poolname, object, MAXNAMELEN);\n\t\treturn (0);\n\t}\n\n\t \n\tif (parse_pathname(object, dataset, path, &statbuf) != 0)\n\t\tgoto err;\n\n\tziprintf(\"   dataset: %s\\n\", dataset);\n\tziprintf(\"      path: %s\\n\", path);\n\n\t \n\tif (object_from_path(dataset, statbuf.st_ino, record) != 0)\n\t\tgoto err;\n\n\tziprintf(\"raw objset: %llu\\n\", record->zi_objset);\n\tziprintf(\"raw object: %llu\\n\", record->zi_object);\n\n\t \n\tif (initialize_range(type, level, (char *)range, record) != 0)\n\t\tgoto err;\n\n\tziprintf(\"    objset: %llu\\n\", record->zi_objset);\n\tziprintf(\"    object: %llu\\n\", record->zi_object);\n\tif (record->zi_start == 0 &&\n\t    record->zi_end == -1ULL)\n\t\tziprintf(\"     range: all\\n\");\n\telse\n\t\tziprintf(\"     range: [%llu, %llu]\\n\", record->zi_start,\n\t\t    record->zi_end);\n\n\t \n\t(void) strlcpy(poolname, dataset, MAXNAMELEN);\n\tif ((slash = strchr(poolname, '/')) != NULL)\n\t\t*slash = '\\0';\n\n\tret = 0;\n\nerr:\n\treturn (ret);\n}\n\nint\ntranslate_raw(const char *str, zinject_record_t *record)\n{\n\t \n\tif (sscanf(str, \"%llx:%llx:%x:%llx\", (u_longlong_t *)&record->zi_objset,\n\t    (u_longlong_t *)&record->zi_object, &record->zi_level,\n\t    (u_longlong_t *)&record->zi_start) != 4) {\n\t\t(void) fprintf(stderr, \"bad raw spec '%s': must be of the form \"\n\t\t    \"'objset:object:level:blkid'\\n\", str);\n\t\treturn (-1);\n\t}\n\n\trecord->zi_end = record->zi_start;\n\n\treturn (0);\n}\n\nint\ntranslate_device(const char *pool, const char *device, err_type_t label_type,\n    zinject_record_t *record)\n{\n\tchar *end;\n\tzpool_handle_t *zhp;\n\tnvlist_t *tgt;\n\tboolean_t isspare, iscache;\n\n\t \n\tif ((zhp = zpool_open(g_zfs, pool)) == NULL)\n\t\treturn (-1);\n\n\trecord->zi_guid = strtoull(device, &end, 0);\n\tif (record->zi_guid == 0 || *end != '\\0') {\n\t\ttgt = zpool_find_vdev(zhp, device, &isspare, &iscache, NULL);\n\n\t\tif (tgt == NULL) {\n\t\t\t(void) fprintf(stderr, \"cannot find device '%s' in \"\n\t\t\t    \"pool '%s'\\n\", device, pool);\n\t\t\tzpool_close(zhp);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tverify(nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_GUID,\n\t\t    &record->zi_guid) == 0);\n\t}\n\n\t \n\tif (record->zi_timer != 0) {\n\t\trecord->zi_cmd = ZINJECT_DELAY_IO;\n\t} else if (label_type != TYPE_INVAL) {\n\t\trecord->zi_cmd = ZINJECT_LABEL_FAULT;\n\t} else {\n\t\trecord->zi_cmd = ZINJECT_DEVICE_FAULT;\n\t}\n\n\tswitch (label_type) {\n\tdefault:\n\t\tbreak;\n\tcase TYPE_LABEL_UBERBLOCK:\n\t\trecord->zi_start = offsetof(vdev_label_t, vl_uberblock[0]);\n\t\trecord->zi_end = record->zi_start + VDEV_UBERBLOCK_RING - 1;\n\t\tbreak;\n\tcase TYPE_LABEL_NVLIST:\n\t\trecord->zi_start = offsetof(vdev_label_t, vl_vdev_phys);\n\t\trecord->zi_end = record->zi_start + VDEV_PHYS_SIZE - 1;\n\t\tbreak;\n\tcase TYPE_LABEL_PAD1:\n\t\trecord->zi_start = offsetof(vdev_label_t, vl_pad1);\n\t\trecord->zi_end = record->zi_start + VDEV_PAD_SIZE - 1;\n\t\tbreak;\n\tcase TYPE_LABEL_PAD2:\n\t\trecord->zi_start = offsetof(vdev_label_t, vl_be);\n\t\trecord->zi_end = record->zi_start + VDEV_PAD_SIZE - 1;\n\t\tbreak;\n\t}\n\tzpool_close(zhp);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}