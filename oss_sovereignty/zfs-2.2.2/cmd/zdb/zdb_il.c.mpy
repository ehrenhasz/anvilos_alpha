{
  "module_name": "zdb_il.c",
  "hash_id": "4d6db2a9042db173aac50cae88d106806b05cd1fa6dbc11782a977dee83f339f",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zdb/zdb_il.c",
  "human_readable_source": " \n \n\n \n\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/zil.h>\n#include <sys/zil_impl.h>\n#include <sys/spa_impl.h>\n#include <sys/abd.h>\n\n#include \"zdb.h\"\n\nextern uint8_t dump_opt[256];\n\nstatic char tab_prefix[4] = \"\\t\\t\\t\";\n\nstatic void\nprint_log_bp(const blkptr_t *bp, const char *prefix)\n{\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), bp);\n\t(void) printf(\"%s%s\\n\", prefix, blkbuf);\n}\n\nstatic void\nzil_prt_rec_create(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog;\n\tconst lr_create_t *lr = arg;\n\ttime_t crtime = lr->lr_crtime[0];\n\tchar *name, *link;\n\tlr_attr_t *lrattr;\n\n\tname = (char *)(lr + 1);\n\n\tif (lr->lr_common.lrc_txtype == TX_CREATE_ATTR ||\n\t    lr->lr_common.lrc_txtype == TX_MKDIR_ATTR) {\n\t\tlrattr = (lr_attr_t *)(lr + 1);\n\t\tname += ZIL_XVAT_SIZE(lrattr->lr_attr_masksize);\n\t}\n\n\tif (txtype == TX_SYMLINK) {\n\t\tlink = name + strlen(name) + 1;\n\t\t(void) printf(\"%s%s -> %s\\n\", tab_prefix, name, link);\n\t} else if (txtype != TX_MKXATTR) {\n\t\t(void) printf(\"%s%s\\n\", tab_prefix, name);\n\t}\n\n\t(void) printf(\"%s%s\", tab_prefix, ctime(&crtime));\n\t(void) printf(\"%sdoid %llu, foid %llu, slots %llu, mode %llo\\n\",\n\t    tab_prefix, (u_longlong_t)lr->lr_doid,\n\t    (u_longlong_t)LR_FOID_GET_OBJ(lr->lr_foid),\n\t    (u_longlong_t)LR_FOID_GET_SLOTS(lr->lr_foid),\n\t    (longlong_t)lr->lr_mode);\n\t(void) printf(\"%suid %llu, gid %llu, gen %llu, rdev 0x%llx\\n\",\n\t    tab_prefix,\n\t    (u_longlong_t)lr->lr_uid, (u_longlong_t)lr->lr_gid,\n\t    (u_longlong_t)lr->lr_gen, (u_longlong_t)lr->lr_rdev);\n}\n\nstatic void\nzil_prt_rec_remove(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_remove_t *lr = arg;\n\n\t(void) printf(\"%sdoid %llu, name %s\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_doid, (char *)(lr + 1));\n}\n\nstatic void\nzil_prt_rec_link(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_link_t *lr = arg;\n\n\t(void) printf(\"%sdoid %llu, link_obj %llu, name %s\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_doid, (u_longlong_t)lr->lr_link_obj,\n\t    (char *)(lr + 1));\n}\n\nstatic void\nzil_prt_rec_rename(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_rename_t *lr = arg;\n\tchar *snm = (char *)(lr + 1);\n\tchar *tnm = snm + strlen(snm) + 1;\n\n\t(void) printf(\"%ssdoid %llu, tdoid %llu\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_sdoid, (u_longlong_t)lr->lr_tdoid);\n\t(void) printf(\"%ssrc %s tgt %s\\n\", tab_prefix, snm, tnm);\n\tswitch (txtype) {\n\tcase TX_RENAME_EXCHANGE:\n\t\t(void) printf(\"%sflags RENAME_EXCHANGE\\n\", tab_prefix);\n\t\tbreak;\n\tcase TX_RENAME_WHITEOUT:\n\t\t(void) printf(\"%sflags RENAME_WHITEOUT\\n\", tab_prefix);\n\t\tbreak;\n\t}\n}\n\nstatic int\nzil_prt_rec_write_cb(void *data, size_t len, void *unused)\n{\n\t(void) unused;\n\tchar *cdata = data;\n\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (isprint(*cdata))\n\t\t\t(void) printf(\"%c \", *cdata);\n\t\telse\n\t\t\t(void) printf(\"%2X\", *cdata);\n\t\tcdata++;\n\t}\n\treturn (0);\n}\n\nstatic void\nzil_prt_rec_write(zilog_t *zilog, int txtype, const void *arg)\n{\n\tconst lr_write_t *lr = arg;\n\tabd_t *data;\n\tconst blkptr_t *bp = &lr->lr_blkptr;\n\tzbookmark_phys_t zb;\n\tint verbose = MAX(dump_opt['d'], dump_opt['i']);\n\tint error;\n\n\t(void) printf(\"%sfoid %llu, offset %llx, length %llx\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_foid, (u_longlong_t)lr->lr_offset,\n\t    (u_longlong_t)lr->lr_length);\n\n\tif (txtype == TX_WRITE2 || verbose < 5)\n\t\treturn;\n\n\tif (lr->lr_common.lrc_reclen == sizeof (lr_write_t)) {\n\t\t(void) printf(\"%shas blkptr, %s\\n\", tab_prefix,\n\t\t    !BP_IS_HOLE(bp) &&\n\t\t    bp->blk_birth >= spa_min_claim_txg(zilog->zl_spa) ?\n\t\t    \"will claim\" : \"won't claim\");\n\t\tprint_log_bp(bp, tab_prefix);\n\n\t\tif (BP_IS_HOLE(bp)) {\n\t\t\t(void) printf(\"\\t\\t\\tLSIZE 0x%llx\\n\",\n\t\t\t    (u_longlong_t)BP_GET_LSIZE(bp));\n\t\t\t(void) printf(\"%s<hole>\\n\", tab_prefix);\n\t\t\treturn;\n\t\t}\n\t\tif (bp->blk_birth < zilog->zl_header->zh_claim_txg) {\n\t\t\t(void) printf(\"%s<block already committed>\\n\",\n\t\t\t    tab_prefix);\n\t\t\treturn;\n\t\t}\n\n\t\tASSERT3U(BP_GET_LSIZE(bp), !=, 0);\n\t\tSET_BOOKMARK(&zb, dmu_objset_id(zilog->zl_os),\n\t\t    lr->lr_foid, ZB_ZIL_LEVEL,\n\t\t    lr->lr_offset / BP_GET_LSIZE(bp));\n\n\t\tdata = abd_alloc(BP_GET_LSIZE(bp), B_FALSE);\n\t\terror = zio_wait(zio_read(NULL, zilog->zl_spa,\n\t\t    bp, data, BP_GET_LSIZE(bp), NULL, NULL,\n\t\t    ZIO_PRIORITY_SYNC_READ, ZIO_FLAG_CANFAIL, &zb));\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\tdata = abd_alloc(lr->lr_length, B_FALSE);\n\t\tabd_copy_from_buf(data, lr + 1, lr->lr_length);\n\t}\n\n\t(void) printf(\"%s\", tab_prefix);\n\t(void) abd_iterate_func(data,\n\t    0, MIN(lr->lr_length, (verbose < 6 ? 20 : SPA_MAXBLOCKSIZE)),\n\t    zil_prt_rec_write_cb, NULL);\n\t(void) printf(\"\\n\");\n\nout:\n\tabd_free(data);\n}\n\nstatic void\nzil_prt_rec_truncate(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_truncate_t *lr = arg;\n\n\t(void) printf(\"%sfoid %llu, offset 0x%llx, length 0x%llx\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_foid, (longlong_t)lr->lr_offset,\n\t    (u_longlong_t)lr->lr_length);\n}\n\nstatic void\nzil_prt_rec_setattr(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_setattr_t *lr = arg;\n\ttime_t atime = (time_t)lr->lr_atime[0];\n\ttime_t mtime = (time_t)lr->lr_mtime[0];\n\n\t(void) printf(\"%sfoid %llu, mask 0x%llx\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_foid, (u_longlong_t)lr->lr_mask);\n\n\tif (lr->lr_mask & AT_MODE) {\n\t\t(void) printf(\"%sAT_MODE  %llo\\n\", tab_prefix,\n\t\t    (longlong_t)lr->lr_mode);\n\t}\n\n\tif (lr->lr_mask & AT_UID) {\n\t\t(void) printf(\"%sAT_UID   %llu\\n\", tab_prefix,\n\t\t    (u_longlong_t)lr->lr_uid);\n\t}\n\n\tif (lr->lr_mask & AT_GID) {\n\t\t(void) printf(\"%sAT_GID   %llu\\n\", tab_prefix,\n\t\t    (u_longlong_t)lr->lr_gid);\n\t}\n\n\tif (lr->lr_mask & AT_SIZE) {\n\t\t(void) printf(\"%sAT_SIZE  %llu\\n\", tab_prefix,\n\t\t    (u_longlong_t)lr->lr_size);\n\t}\n\n\tif (lr->lr_mask & AT_ATIME) {\n\t\t(void) printf(\"%sAT_ATIME %llu.%09llu %s\", tab_prefix,\n\t\t    (u_longlong_t)lr->lr_atime[0],\n\t\t    (u_longlong_t)lr->lr_atime[1],\n\t\t    ctime(&atime));\n\t}\n\n\tif (lr->lr_mask & AT_MTIME) {\n\t\t(void) printf(\"%sAT_MTIME %llu.%09llu %s\", tab_prefix,\n\t\t    (u_longlong_t)lr->lr_mtime[0],\n\t\t    (u_longlong_t)lr->lr_mtime[1],\n\t\t    ctime(&mtime));\n\t}\n}\n\nstatic void\nzil_prt_rec_setsaxattr(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_setsaxattr_t *lr = arg;\n\n\tchar *name = (char *)(lr + 1);\n\t(void) printf(\"%sfoid %llu\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_foid);\n\n\t(void) printf(\"%sXAT_NAME  %s\\n\", tab_prefix, name);\n\tif (lr->lr_size == 0) {\n\t\t(void) printf(\"%sXAT_VALUE  NULL\\n\", tab_prefix);\n\t} else {\n\t\t(void) printf(\"%sXAT_VALUE  \", tab_prefix);\n\t\tchar *val = name + (strlen(name) + 1);\n\t\tfor (int i = 0; i < lr->lr_size; i++) {\n\t\t\t(void) printf(\"%c\", *val);\n\t\t\tval++;\n\t\t}\n\t}\n}\n\nstatic void\nzil_prt_rec_acl(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_acl_t *lr = arg;\n\n\t(void) printf(\"%sfoid %llu, aclcnt %llu\\n\", tab_prefix,\n\t    (u_longlong_t)lr->lr_foid, (u_longlong_t)lr->lr_aclcnt);\n}\n\nstatic void\nzil_prt_rec_clone_range(zilog_t *zilog, int txtype, const void *arg)\n{\n\t(void) zilog, (void) txtype;\n\tconst lr_clone_range_t *lr = arg;\n\n\t(void) printf(\"%sfoid %llu, offset %llx, length %llx, blksize %llx\\n\",\n\t    tab_prefix, (u_longlong_t)lr->lr_foid, (u_longlong_t)lr->lr_offset,\n\t    (u_longlong_t)lr->lr_length, (u_longlong_t)lr->lr_blksz);\n\n\tfor (unsigned int i = 0; i < lr->lr_nbps; i++) {\n\t\t(void) printf(\"%s[%u/%llu] \", tab_prefix, i + 1,\n\t\t    (u_longlong_t)lr->lr_nbps);\n\t\tprint_log_bp(&lr->lr_bps[i], \"\");\n\t}\n}\n\ntypedef void (*zil_prt_rec_func_t)(zilog_t *, int, const void *);\ntypedef struct zil_rec_info {\n\tzil_prt_rec_func_t\tzri_print;\n\tconst char\t\t*zri_name;\n\tuint64_t\t\tzri_count;\n} zil_rec_info_t;\n\nstatic zil_rec_info_t zil_rec_info[TX_MAX_TYPE] = {\n\t{.zri_print = NULL,\t\t    .zri_name = \"Total              \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_CREATE          \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_MKDIR           \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_MKXATTR         \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_SYMLINK         \"},\n\t{.zri_print = zil_prt_rec_remove,   .zri_name = \"TX_REMOVE          \"},\n\t{.zri_print = zil_prt_rec_remove,   .zri_name = \"TX_RMDIR           \"},\n\t{.zri_print = zil_prt_rec_link,\t    .zri_name = \"TX_LINK            \"},\n\t{.zri_print = zil_prt_rec_rename,   .zri_name = \"TX_RENAME          \"},\n\t{.zri_print = zil_prt_rec_write,    .zri_name = \"TX_WRITE           \"},\n\t{.zri_print = zil_prt_rec_truncate, .zri_name = \"TX_TRUNCATE        \"},\n\t{.zri_print = zil_prt_rec_setattr,  .zri_name = \"TX_SETATTR         \"},\n\t{.zri_print = zil_prt_rec_acl,\t    .zri_name = \"TX_ACL_V0          \"},\n\t{.zri_print = zil_prt_rec_acl,\t    .zri_name = \"TX_ACL_ACL         \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_CREATE_ACL      \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_CREATE_ATTR     \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_CREATE_ACL_ATTR \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_MKDIR_ACL       \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_MKDIR_ATTR      \"},\n\t{.zri_print = zil_prt_rec_create,   .zri_name = \"TX_MKDIR_ACL_ATTR  \"},\n\t{.zri_print = zil_prt_rec_write,    .zri_name = \"TX_WRITE2          \"},\n\t{.zri_print = zil_prt_rec_setsaxattr,\n\t    .zri_name = \"TX_SETSAXATTR      \"},\n\t{.zri_print = zil_prt_rec_rename,   .zri_name = \"TX_RENAME_EXCHANGE \"},\n\t{.zri_print = zil_prt_rec_rename,   .zri_name = \"TX_RENAME_WHITEOUT \"},\n\t{.zri_print = zil_prt_rec_clone_range,\n\t    .zri_name = \"TX_CLONE_RANGE     \"},\n};\n\nstatic int\nprint_log_record(zilog_t *zilog, const lr_t *lr, void *arg, uint64_t claim_txg)\n{\n\t(void) arg, (void) claim_txg;\n\tint txtype;\n\tint verbose = MAX(dump_opt['d'], dump_opt['i']);\n\n\t \n\ttxtype = lr->lrc_txtype;\n\n\tASSERT(txtype != 0 && (uint_t)txtype < TX_MAX_TYPE);\n\tASSERT(lr->lrc_txg);\n\n\t(void) printf(\"\\t\\t%s%s len %6llu, txg %llu, seq %llu\\n\",\n\t    (lr->lrc_txtype & TX_CI) ? \"CI-\" : \"\",\n\t    zil_rec_info[txtype].zri_name,\n\t    (u_longlong_t)lr->lrc_reclen,\n\t    (u_longlong_t)lr->lrc_txg,\n\t    (u_longlong_t)lr->lrc_seq);\n\n\tif (txtype && verbose >= 3) {\n\t\tif (!zilog->zl_os->os_encrypted) {\n\t\t\tzil_rec_info[txtype].zri_print(zilog, txtype, lr);\n\t\t} else {\n\t\t\t(void) printf(\"%s(encrypted)\\n\", tab_prefix);\n\t\t}\n\t}\n\n\tzil_rec_info[txtype].zri_count++;\n\tzil_rec_info[0].zri_count++;\n\n\treturn (0);\n}\n\nstatic int\nprint_log_block(zilog_t *zilog, const blkptr_t *bp, void *arg,\n    uint64_t claim_txg)\n{\n\t(void) arg;\n\tchar blkbuf[BP_SPRINTF_LEN + 10];\n\tint verbose = MAX(dump_opt['d'], dump_opt['i']);\n\tconst char *claim;\n\n\tif (verbose <= 3)\n\t\treturn (0);\n\n\tif (verbose >= 5) {\n\t\t(void) strcpy(blkbuf, \", \");\n\t\tsnprintf_blkptr(blkbuf + strlen(blkbuf),\n\t\t    sizeof (blkbuf) - strlen(blkbuf), bp);\n\t} else {\n\t\tblkbuf[0] = '\\0';\n\t}\n\n\tif (claim_txg != 0)\n\t\tclaim = \"already claimed\";\n\telse if (bp->blk_birth >= spa_min_claim_txg(zilog->zl_spa))\n\t\tclaim = \"will claim\";\n\telse\n\t\tclaim = \"won't claim\";\n\n\t(void) printf(\"\\tBlock seqno %llu, %s%s\\n\",\n\t    (u_longlong_t)bp->blk_cksum.zc_word[ZIL_ZC_SEQ], claim, blkbuf);\n\n\treturn (0);\n}\n\nstatic void\nprint_log_stats(int verbose)\n{\n\tunsigned i, w, p10;\n\n\tif (verbose > 3)\n\t\t(void) printf(\"\\n\");\n\n\tif (zil_rec_info[0].zri_count == 0)\n\t\treturn;\n\n\tfor (w = 1, p10 = 10; zil_rec_info[0].zri_count >= p10; p10 *= 10)\n\t\tw++;\n\n\tfor (i = 0; i < TX_MAX_TYPE; i++)\n\t\tif (zil_rec_info[i].zri_count || verbose >= 3)\n\t\t\t(void) printf(\"\\t\\t%s %*llu\\n\",\n\t\t\t    zil_rec_info[i].zri_name, w,\n\t\t\t    (u_longlong_t)zil_rec_info[i].zri_count);\n\t(void) printf(\"\\n\");\n}\n\nvoid\ndump_intent_log(zilog_t *zilog)\n{\n\tconst zil_header_t *zh = zilog->zl_header;\n\tint verbose = MAX(dump_opt['d'], dump_opt['i']);\n\tint i;\n\n\tif (BP_IS_HOLE(&zh->zh_log) || verbose < 1)\n\t\treturn;\n\n\t(void) printf(\"\\n    ZIL header: claim_txg %llu, \"\n\t    \"claim_blk_seq %llu, claim_lr_seq %llu\",\n\t    (u_longlong_t)zh->zh_claim_txg,\n\t    (u_longlong_t)zh->zh_claim_blk_seq,\n\t    (u_longlong_t)zh->zh_claim_lr_seq);\n\t(void) printf(\" replay_seq %llu, flags 0x%llx\\n\",\n\t    (u_longlong_t)zh->zh_replay_seq, (u_longlong_t)zh->zh_flags);\n\n\tfor (i = 0; i < TX_MAX_TYPE; i++)\n\t\tzil_rec_info[i].zri_count = 0;\n\n\t \n\tif (zilog->zl_spa->spa_uberblock.ub_checkpoint_txg != 0 &&\n\t    zh->zh_claim_txg == 0)\n\t\treturn;\n\n\tif (verbose >= 2) {\n\t\t(void) printf(\"\\n\");\n\t\t(void) zil_parse(zilog, print_log_block, print_log_record, NULL,\n\t\t    zh->zh_claim_txg, B_FALSE);\n\t\tprint_log_stats(verbose);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}