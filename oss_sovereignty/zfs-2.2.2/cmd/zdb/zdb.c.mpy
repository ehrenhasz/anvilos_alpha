{
  "module_name": "zdb.c",
  "hash_id": "92914b169958b5e684a4d0e7a7f257c201365d524279bfd8f16c78d6ff89709e",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zdb/zdb.c",
  "human_readable_source": " \n\n \n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <getopt.h>\n#include <openssl/evp.h>\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu.h>\n#include <sys/zap.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_sa.h>\n#include <sys/sa.h>\n#include <sys/sa_impl.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/metaslab_impl.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dbuf.h>\n#include <sys/zil.h>\n#include <sys/zil_impl.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/dmu_send.h>\n#include <sys/dmu_traverse.h>\n#include <sys/zio_checksum.h>\n#include <sys/zio_compress.h>\n#include <sys/zfs_fuid.h>\n#include <sys/arc.h>\n#include <sys/arc_impl.h>\n#include <sys/ddt.h>\n#include <sys/zfeature.h>\n#include <sys/abd.h>\n#include <sys/blkptr.h>\n#include <sys/dsl_crypt.h>\n#include <sys/dsl_scan.h>\n#include <sys/btree.h>\n#include <sys/brt.h>\n#include <sys/brt_impl.h>\n#include <zfs_comutil.h>\n#include <sys/zstd/zstd.h>\n\n#include <libnvpair.h>\n#include <libzutil.h>\n\n#include \"zdb.h\"\n\n#define\tZDB_COMPRESS_NAME(idx) ((idx) < ZIO_COMPRESS_FUNCTIONS ?\t\\\n\tzio_compress_table[(idx)].ci_name : \"UNKNOWN\")\n#define\tZDB_CHECKSUM_NAME(idx) ((idx) < ZIO_CHECKSUM_FUNCTIONS ?\t\\\n\tzio_checksum_table[(idx)].ci_name : \"UNKNOWN\")\n#define\tZDB_OT_TYPE(idx) ((idx) < DMU_OT_NUMTYPES ? (idx) :\t\t\\\n\t(idx) == DMU_OTN_ZAP_DATA || (idx) == DMU_OTN_ZAP_METADATA ?\t\\\n\tDMU_OT_ZAP_OTHER : \\\n\t(idx) == DMU_OTN_UINT64_DATA || (idx) == DMU_OTN_UINT64_METADATA ? \\\n\tDMU_OT_UINT64_OTHER : DMU_OT_NUMTYPES)\n\n \n#ifdef __APPLE__\n#define\tZDB_MAP_OBJECT_ID(obj) INO_XNUTOZFS(obj, 2)\n#else\n#define\tZDB_MAP_OBJECT_ID(obj) (obj)\n#endif\n\nstatic const char *\nzdb_ot_name(dmu_object_type_t type)\n{\n\tif (type < DMU_OT_NUMTYPES)\n\t\treturn (dmu_ot[type].ot_name);\n\telse if ((type & DMU_OT_NEWTYPE) &&\n\t    ((type & DMU_OT_BYTESWAP_MASK) < DMU_BSWAP_NUMFUNCS))\n\t\treturn (dmu_ot_byteswap[type & DMU_OT_BYTESWAP_MASK].ob_name);\n\telse\n\t\treturn (\"UNKNOWN\");\n}\n\nextern int reference_tracking_enable;\nextern int zfs_recover;\nextern uint_t zfs_vdev_async_read_max_active;\nextern boolean_t spa_load_verify_dryrun;\nextern boolean_t spa_mode_readable_spacemaps;\nextern uint_t zfs_reconstruct_indirect_combinations_max;\nextern uint_t zfs_btree_verify_intensity;\n\nstatic const char cmdname[] = \"zdb\";\nuint8_t dump_opt[256];\n\ntypedef void object_viewer_t(objset_t *, uint64_t, void *data, size_t size);\n\nstatic uint64_t *zopt_metaslab = NULL;\nstatic unsigned zopt_metaslab_args = 0;\n\ntypedef struct zopt_object_range {\n\tuint64_t zor_obj_start;\n\tuint64_t zor_obj_end;\n\tuint64_t zor_flags;\n} zopt_object_range_t;\n\nstatic zopt_object_range_t *zopt_object_ranges = NULL;\nstatic unsigned zopt_object_args = 0;\n\nstatic int flagbits[256];\n\n#define\tZOR_FLAG_PLAIN_FILE\t0x0001\n#define\tZOR_FLAG_DIRECTORY\t0x0002\n#define\tZOR_FLAG_SPACE_MAP\t0x0004\n#define\tZOR_FLAG_ZAP\t\t0x0008\n#define\tZOR_FLAG_ALL_TYPES\t-1\n#define\tZOR_SUPPORTED_FLAGS\t(ZOR_FLAG_PLAIN_FILE\t| \\\n\t\t\t\tZOR_FLAG_DIRECTORY\t| \\\n\t\t\t\tZOR_FLAG_SPACE_MAP\t| \\\n\t\t\t\tZOR_FLAG_ZAP)\n\n#define\tZDB_FLAG_CHECKSUM\t0x0001\n#define\tZDB_FLAG_DECOMPRESS\t0x0002\n#define\tZDB_FLAG_BSWAP\t\t0x0004\n#define\tZDB_FLAG_GBH\t\t0x0008\n#define\tZDB_FLAG_INDIRECT\t0x0010\n#define\tZDB_FLAG_RAW\t\t0x0020\n#define\tZDB_FLAG_PRINT_BLKPTR\t0x0040\n#define\tZDB_FLAG_VERBOSE\t0x0080\n\nstatic uint64_t max_inflight_bytes = 256 * 1024 * 1024;  \nstatic int leaked_objects = 0;\nstatic range_tree_t *mos_refd_objs;\n\nstatic void snprintf_blkptr_compact(char *, size_t, const blkptr_t *,\n    boolean_t);\nstatic void mos_obj_refd(uint64_t);\nstatic void mos_obj_refd_multiple(uint64_t);\nstatic int dump_bpobj_cb(void *arg, const blkptr_t *bp, boolean_t free,\n    dmu_tx_t *tx);\n\ntypedef struct sublivelist_verify {\n\t \n\tzfs_btree_t sv_pair;\n\n\t \n\tzfs_btree_t sv_leftover;\n} sublivelist_verify_t;\n\nstatic int\nlivelist_compare(const void *larg, const void *rarg)\n{\n\tconst blkptr_t *l = larg;\n\tconst blkptr_t *r = rarg;\n\n\t \n\tuint64_t l_dva0_vdev, r_dva0_vdev;\n\tl_dva0_vdev = DVA_GET_VDEV(&l->blk_dva[0]);\n\tr_dva0_vdev = DVA_GET_VDEV(&r->blk_dva[0]);\n\tif (l_dva0_vdev < r_dva0_vdev)\n\t\treturn (-1);\n\telse if (l_dva0_vdev > r_dva0_vdev)\n\t\treturn (+1);\n\n\t \n\tuint64_t l_dva0_offset;\n\tuint64_t r_dva0_offset;\n\tl_dva0_offset = DVA_GET_OFFSET(&l->blk_dva[0]);\n\tr_dva0_offset = DVA_GET_OFFSET(&r->blk_dva[0]);\n\tif (l_dva0_offset < r_dva0_offset) {\n\t\treturn (-1);\n\t} else if (l_dva0_offset > r_dva0_offset) {\n\t\treturn (+1);\n\t}\n\n\t \n\tif (l->blk_birth < r->blk_birth) {\n\t\treturn (-1);\n\t} else if (l->blk_birth > r->blk_birth) {\n\t\treturn (+1);\n\t}\n\treturn (0);\n}\n\ntypedef struct sublivelist_verify_block {\n\tdva_t svb_dva;\n\n\t \n\tuint64_t svb_allocated_txg;\n} sublivelist_verify_block_t;\n\nstatic void zdb_print_blkptr(const blkptr_t *bp, int flags);\n\ntypedef struct sublivelist_verify_block_refcnt {\n\t \n\tblkptr_t svbr_blk;\n\n\t \n\tuint32_t svbr_refcnt;\n} sublivelist_verify_block_refcnt_t;\n\nstatic int\nsublivelist_block_refcnt_compare(const void *larg, const void *rarg)\n{\n\tconst sublivelist_verify_block_refcnt_t *l = larg;\n\tconst sublivelist_verify_block_refcnt_t *r = rarg;\n\treturn (livelist_compare(&l->svbr_blk, &r->svbr_blk));\n}\n\nstatic int\nsublivelist_verify_blkptr(void *arg, const blkptr_t *bp, boolean_t free,\n    dmu_tx_t *tx)\n{\n\tASSERT3P(tx, ==, NULL);\n\tstruct sublivelist_verify *sv = arg;\n\tsublivelist_verify_block_refcnt_t current = {\n\t\t\t.svbr_blk = *bp,\n\n\t\t\t \n\t\t\t.svbr_refcnt = 1,\n\t};\n\n\tzfs_btree_index_t where;\n\tsublivelist_verify_block_refcnt_t *pair =\n\t    zfs_btree_find(&sv->sv_pair, &current, &where);\n\tif (free) {\n\t\tif (pair == NULL) {\n\t\t\t \n\t\t\tzfs_btree_add(&sv->sv_pair, &current);\n\t\t} else {\n\t\t\tpair->svbr_refcnt++;\n\t\t}\n\t} else {\n\t\tif (pair == NULL) {\n\t\t\t \n\t\t\tfor (int i = 0; i < SPA_DVAS_PER_BP; i++) {\n\t\t\t\tif (DVA_IS_EMPTY(&bp->blk_dva[i]))\n\t\t\t\t\tbreak;\n\t\t\t\tsublivelist_verify_block_t svb = {\n\t\t\t\t    .svb_dva = bp->blk_dva[i],\n\t\t\t\t    .svb_allocated_txg = bp->blk_birth\n\t\t\t\t};\n\n\t\t\t\tif (zfs_btree_find(&sv->sv_leftover, &svb,\n\t\t\t\t    &where) == NULL) {\n\t\t\t\t\tzfs_btree_add_idx(&sv->sv_leftover,\n\t\t\t\t\t    &svb, &where);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tpair->svbr_refcnt--;\n\t\t\tif (pair->svbr_refcnt == 0) {\n\t\t\t\t \n\t\t\t\tzfs_btree_remove_idx(&sv->sv_pair, &where);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nsublivelist_verify_func(void *args, dsl_deadlist_entry_t *dle)\n{\n\tint err;\n\tstruct sublivelist_verify *sv = args;\n\n\tzfs_btree_create(&sv->sv_pair, sublivelist_block_refcnt_compare, NULL,\n\t    sizeof (sublivelist_verify_block_refcnt_t));\n\n\terr = bpobj_iterate_nofree(&dle->dle_bpobj, sublivelist_verify_blkptr,\n\t    sv, NULL);\n\n\tsublivelist_verify_block_refcnt_t *e;\n\tzfs_btree_index_t *cookie = NULL;\n\twhile ((e = zfs_btree_destroy_nodes(&sv->sv_pair, &cookie)) != NULL) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\tsnprintf_blkptr_compact(blkbuf, sizeof (blkbuf),\n\t\t    &e->svbr_blk, B_TRUE);\n\t\t(void) printf(\"\\tERROR: %d unmatched FREE(s): %s\\n\",\n\t\t    e->svbr_refcnt, blkbuf);\n\t}\n\tzfs_btree_destroy(&sv->sv_pair);\n\n\treturn (err);\n}\n\nstatic int\nlivelist_block_compare(const void *larg, const void *rarg)\n{\n\tconst sublivelist_verify_block_t *l = larg;\n\tconst sublivelist_verify_block_t *r = rarg;\n\n\tif (DVA_GET_VDEV(&l->svb_dva) < DVA_GET_VDEV(&r->svb_dva))\n\t\treturn (-1);\n\telse if (DVA_GET_VDEV(&l->svb_dva) > DVA_GET_VDEV(&r->svb_dva))\n\t\treturn (+1);\n\n\tif (DVA_GET_OFFSET(&l->svb_dva) < DVA_GET_OFFSET(&r->svb_dva))\n\t\treturn (-1);\n\telse if (DVA_GET_OFFSET(&l->svb_dva) > DVA_GET_OFFSET(&r->svb_dva))\n\t\treturn (+1);\n\n\tif (DVA_GET_ASIZE(&l->svb_dva) < DVA_GET_ASIZE(&r->svb_dva))\n\t\treturn (-1);\n\telse if (DVA_GET_ASIZE(&l->svb_dva) > DVA_GET_ASIZE(&r->svb_dva))\n\t\treturn (+1);\n\n\treturn (0);\n}\n\n \nstatic void\nlivelist_verify(dsl_deadlist_t *dl, void *arg)\n{\n\tsublivelist_verify_t *sv = arg;\n\tdsl_deadlist_iterate(dl, sublivelist_verify_func, sv);\n}\n\n \nstatic int\nsublivelist_verify_lightweight(void *args, dsl_deadlist_entry_t *dle)\n{\n\t(void) args;\n\tsublivelist_verify_t sv;\n\tzfs_btree_create(&sv.sv_leftover, livelist_block_compare, NULL,\n\t    sizeof (sublivelist_verify_block_t));\n\tint err = sublivelist_verify_func(&sv, dle);\n\tzfs_btree_clear(&sv.sv_leftover);\n\tzfs_btree_destroy(&sv.sv_leftover);\n\treturn (err);\n}\n\ntypedef struct metaslab_verify {\n\t \n\tzfs_btree_t mv_livelist_allocs;\n\n\t \n\tuint64_t mv_vdid;\n\tuint64_t mv_msid;\n\tuint64_t mv_start;\n\tuint64_t mv_end;\n\n\t \n\trange_tree_t *mv_allocated;\n} metaslab_verify_t;\n\ntypedef void ll_iter_t(dsl_deadlist_t *ll, void *arg);\n\ntypedef int (*zdb_log_sm_cb_t)(spa_t *spa, space_map_entry_t *sme, uint64_t txg,\n    void *arg);\n\ntypedef struct unflushed_iter_cb_arg {\n\tspa_t *uic_spa;\n\tuint64_t uic_txg;\n\tvoid *uic_arg;\n\tzdb_log_sm_cb_t uic_cb;\n} unflushed_iter_cb_arg_t;\n\nstatic int\niterate_through_spacemap_logs_cb(space_map_entry_t *sme, void *arg)\n{\n\tunflushed_iter_cb_arg_t *uic = arg;\n\treturn (uic->uic_cb(uic->uic_spa, sme, uic->uic_txg, uic->uic_arg));\n}\n\nstatic void\niterate_through_spacemap_logs(spa_t *spa, zdb_log_sm_cb_t cb, void *arg)\n{\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP))\n\t\treturn;\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tfor (spa_log_sm_t *sls = avl_first(&spa->spa_sm_logs_by_txg);\n\t    sls; sls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls)) {\n\t\tspace_map_t *sm = NULL;\n\t\tVERIFY0(space_map_open(&sm, spa_meta_objset(spa),\n\t\t    sls->sls_sm_obj, 0, UINT64_MAX, SPA_MINBLOCKSHIFT));\n\n\t\tunflushed_iter_cb_arg_t uic = {\n\t\t\t.uic_spa = spa,\n\t\t\t.uic_txg = sls->sls_txg,\n\t\t\t.uic_arg = arg,\n\t\t\t.uic_cb = cb\n\t\t};\n\t\tVERIFY0(space_map_iterate(sm, space_map_length(sm),\n\t\t    iterate_through_spacemap_logs_cb, &uic));\n\t\tspace_map_close(sm);\n\t}\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n}\n\nstatic void\nverify_livelist_allocs(metaslab_verify_t *mv, uint64_t txg,\n    uint64_t offset, uint64_t size)\n{\n\tsublivelist_verify_block_t svb = {{{0}}};\n\tDVA_SET_VDEV(&svb.svb_dva, mv->mv_vdid);\n\tDVA_SET_OFFSET(&svb.svb_dva, offset);\n\tDVA_SET_ASIZE(&svb.svb_dva, size);\n\tzfs_btree_index_t where;\n\tuint64_t end_offset = offset + size;\n\n\t \n\tsublivelist_verify_block_t *found =\n\t    zfs_btree_find(&mv->mv_livelist_allocs, &svb, &where);\n\tif (found == NULL) {\n\t\tfound = zfs_btree_next(&mv->mv_livelist_allocs, &where, &where);\n\t}\n\tfor (; found != NULL && DVA_GET_VDEV(&found->svb_dva) == mv->mv_vdid &&\n\t    DVA_GET_OFFSET(&found->svb_dva) < end_offset;\n\t    found = zfs_btree_next(&mv->mv_livelist_allocs, &where, &where)) {\n\t\tif (found->svb_allocated_txg <= txg) {\n\t\t\t(void) printf(\"ERROR: Livelist ALLOC [%llx:%llx] \"\n\t\t\t    \"from TXG %llx FREED at TXG %llx\\n\",\n\t\t\t    (u_longlong_t)DVA_GET_OFFSET(&found->svb_dva),\n\t\t\t    (u_longlong_t)DVA_GET_ASIZE(&found->svb_dva),\n\t\t\t    (u_longlong_t)found->svb_allocated_txg,\n\t\t\t    (u_longlong_t)txg);\n\t\t}\n\t}\n}\n\nstatic int\nmetaslab_spacemap_validation_cb(space_map_entry_t *sme, void *arg)\n{\n\tmetaslab_verify_t *mv = arg;\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t size = sme->sme_run;\n\tuint64_t txg = sme->sme_txg;\n\n\tif (sme->sme_type == SM_ALLOC) {\n\t\tif (range_tree_contains(mv->mv_allocated,\n\t\t    offset, size)) {\n\t\t\t(void) printf(\"ERROR: DOUBLE ALLOC: \"\n\t\t\t    \"%llu [%llx:%llx] \"\n\t\t\t    \"%llu:%llu LOG_SM\\n\",\n\t\t\t    (u_longlong_t)txg, (u_longlong_t)offset,\n\t\t\t    (u_longlong_t)size, (u_longlong_t)mv->mv_vdid,\n\t\t\t    (u_longlong_t)mv->mv_msid);\n\t\t} else {\n\t\t\trange_tree_add(mv->mv_allocated,\n\t\t\t    offset, size);\n\t\t}\n\t} else {\n\t\tif (!range_tree_contains(mv->mv_allocated,\n\t\t    offset, size)) {\n\t\t\t(void) printf(\"ERROR: DOUBLE FREE: \"\n\t\t\t    \"%llu [%llx:%llx] \"\n\t\t\t    \"%llu:%llu LOG_SM\\n\",\n\t\t\t    (u_longlong_t)txg, (u_longlong_t)offset,\n\t\t\t    (u_longlong_t)size, (u_longlong_t)mv->mv_vdid,\n\t\t\t    (u_longlong_t)mv->mv_msid);\n\t\t} else {\n\t\t\trange_tree_remove(mv->mv_allocated,\n\t\t\t    offset, size);\n\t\t}\n\t}\n\n\tif (sme->sme_type != SM_ALLOC) {\n\t\t \n\t\tverify_livelist_allocs(mv, txg, offset, size);\n\t}\n\treturn (0);\n}\n\nstatic int\nspacemap_check_sm_log_cb(spa_t *spa, space_map_entry_t *sme,\n    uint64_t txg, void *arg)\n{\n\tmetaslab_verify_t *mv = arg;\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t vdev_id = sme->sme_vdev;\n\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\n\t \n\tif (!vdev_is_concrete(vd))\n\t\treturn (0);\n\n\tif (vdev_id != mv->mv_vdid)\n\t\treturn (0);\n\n\tmetaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\tif (ms->ms_id != mv->mv_msid)\n\t\treturn (0);\n\n\tif (txg < metaslab_unflushed_txg(ms))\n\t\treturn (0);\n\n\n\tASSERT3U(txg, ==, sme->sme_txg);\n\treturn (metaslab_spacemap_validation_cb(sme, mv));\n}\n\nstatic void\nspacemap_check_sm_log(spa_t *spa, metaslab_verify_t *mv)\n{\n\titerate_through_spacemap_logs(spa, spacemap_check_sm_log_cb, mv);\n}\n\nstatic void\nspacemap_check_ms_sm(space_map_t  *sm, metaslab_verify_t *mv)\n{\n\tif (sm == NULL)\n\t\treturn;\n\n\tVERIFY0(space_map_iterate(sm, space_map_length(sm),\n\t    metaslab_spacemap_validation_cb, mv));\n}\n\nstatic void iterate_deleted_livelists(spa_t *spa, ll_iter_t func, void *arg);\n\n \nstatic void\nmv_populate_livelist_allocs(metaslab_verify_t *mv, sublivelist_verify_t *sv)\n{\n\tzfs_btree_index_t where;\n\tsublivelist_verify_block_t *svb;\n\tASSERT3U(zfs_btree_numnodes(&mv->mv_livelist_allocs), ==, 0);\n\tfor (svb = zfs_btree_first(&sv->sv_leftover, &where);\n\t    svb != NULL;\n\t    svb = zfs_btree_next(&sv->sv_leftover, &where, &where)) {\n\t\tif (DVA_GET_VDEV(&svb->svb_dva) != mv->mv_vdid)\n\t\t\tcontinue;\n\n\t\tif (DVA_GET_OFFSET(&svb->svb_dva) < mv->mv_start &&\n\t\t    (DVA_GET_OFFSET(&svb->svb_dva) +\n\t\t    DVA_GET_ASIZE(&svb->svb_dva)) > mv->mv_start) {\n\t\t\t(void) printf(\"ERROR: Found block that crosses \"\n\t\t\t    \"metaslab boundary: <%llu:%llx:%llx>\\n\",\n\t\t\t    (u_longlong_t)DVA_GET_VDEV(&svb->svb_dva),\n\t\t\t    (u_longlong_t)DVA_GET_OFFSET(&svb->svb_dva),\n\t\t\t    (u_longlong_t)DVA_GET_ASIZE(&svb->svb_dva));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (DVA_GET_OFFSET(&svb->svb_dva) < mv->mv_start)\n\t\t\tcontinue;\n\n\t\tif (DVA_GET_OFFSET(&svb->svb_dva) >= mv->mv_end)\n\t\t\tcontinue;\n\n\t\tif ((DVA_GET_OFFSET(&svb->svb_dva) +\n\t\t    DVA_GET_ASIZE(&svb->svb_dva)) > mv->mv_end) {\n\t\t\t(void) printf(\"ERROR: Found block that crosses \"\n\t\t\t    \"metaslab boundary: <%llu:%llx:%llx>\\n\",\n\t\t\t    (u_longlong_t)DVA_GET_VDEV(&svb->svb_dva),\n\t\t\t    (u_longlong_t)DVA_GET_OFFSET(&svb->svb_dva),\n\t\t\t    (u_longlong_t)DVA_GET_ASIZE(&svb->svb_dva));\n\t\t\tcontinue;\n\t\t}\n\n\t\tzfs_btree_add(&mv->mv_livelist_allocs, svb);\n\t}\n\n\tfor (svb = zfs_btree_first(&mv->mv_livelist_allocs, &where);\n\t    svb != NULL;\n\t    svb = zfs_btree_next(&mv->mv_livelist_allocs, &where, &where)) {\n\t\tzfs_btree_remove(&sv->sv_leftover, svb);\n\t}\n}\n\n \nstatic void\nlivelist_metaslab_validate(spa_t *spa)\n{\n\t(void) printf(\"Verifying deleted livelist entries\\n\");\n\n\tsublivelist_verify_t sv;\n\tzfs_btree_create(&sv.sv_leftover, livelist_block_compare, NULL,\n\t    sizeof (sublivelist_verify_block_t));\n\titerate_deleted_livelists(spa, livelist_verify, &sv);\n\n\t(void) printf(\"Verifying metaslab entries\\n\");\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *vd = rvd->vdev_child[c];\n\n\t\tif (!vdev_is_concrete(vd))\n\t\t\tcontinue;\n\n\t\tfor (uint64_t mid = 0; mid < vd->vdev_ms_count; mid++) {\n\t\t\tmetaslab_t *m = vd->vdev_ms[mid];\n\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"\\rverifying concrete vdev %llu, \"\n\t\t\t    \"metaslab %llu of %llu ...\",\n\t\t\t    (longlong_t)vd->vdev_id,\n\t\t\t    (longlong_t)mid,\n\t\t\t    (longlong_t)vd->vdev_ms_count);\n\n\t\t\tuint64_t shift, start;\n\t\t\trange_seg_type_t type =\n\t\t\t    metaslab_calculate_range_tree_type(vd, m,\n\t\t\t    &start, &shift);\n\t\t\tmetaslab_verify_t mv;\n\t\t\tmv.mv_allocated = range_tree_create(NULL,\n\t\t\t    type, NULL, start, shift);\n\t\t\tmv.mv_vdid = vd->vdev_id;\n\t\t\tmv.mv_msid = m->ms_id;\n\t\t\tmv.mv_start = m->ms_start;\n\t\t\tmv.mv_end = m->ms_start + m->ms_size;\n\t\t\tzfs_btree_create(&mv.mv_livelist_allocs,\n\t\t\t    livelist_block_compare, NULL,\n\t\t\t    sizeof (sublivelist_verify_block_t));\n\n\t\t\tmv_populate_livelist_allocs(&mv, &sv);\n\n\t\t\tspacemap_check_ms_sm(m->ms_sm, &mv);\n\t\t\tspacemap_check_sm_log(spa, &mv);\n\n\t\t\trange_tree_vacate(mv.mv_allocated, NULL, NULL);\n\t\t\trange_tree_destroy(mv.mv_allocated);\n\t\t\tzfs_btree_clear(&mv.mv_livelist_allocs);\n\t\t\tzfs_btree_destroy(&mv.mv_livelist_allocs);\n\t\t}\n\t}\n\t(void) fprintf(stderr, \"\\n\");\n\n\t \n\tif (zfs_btree_numnodes(&sv.sv_leftover) == 0) {\n\t\tzfs_btree_destroy(&sv.sv_leftover);\n\t\treturn;\n\t}\n\t(void) printf(\"ERROR: Found livelist blocks marked as allocated \"\n\t    \"for indirect vdevs:\\n\");\n\n\tzfs_btree_index_t *where = NULL;\n\tsublivelist_verify_block_t *svb;\n\twhile ((svb = zfs_btree_destroy_nodes(&sv.sv_leftover, &where)) !=\n\t    NULL) {\n\t\tint vdev_id = DVA_GET_VDEV(&svb->svb_dva);\n\t\tASSERT3U(vdev_id, <, rvd->vdev_children);\n\t\tvdev_t *vd = rvd->vdev_child[vdev_id];\n\t\tASSERT(!vdev_is_concrete(vd));\n\t\t(void) printf(\"<%d:%llx:%llx> TXG %llx\\n\",\n\t\t    vdev_id, (u_longlong_t)DVA_GET_OFFSET(&svb->svb_dva),\n\t\t    (u_longlong_t)DVA_GET_ASIZE(&svb->svb_dva),\n\t\t    (u_longlong_t)svb->svb_allocated_txg);\n\t}\n\t(void) printf(\"\\n\");\n\tzfs_btree_destroy(&sv.sv_leftover);\n}\n\n \nconst char *\n_umem_debug_init(void)\n{\n\treturn (\"default,verbose\");  \n}\n\nconst char *\n_umem_logging_init(void)\n{\n\treturn (\"fail,contents\");  \n}\n\nstatic void\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"Usage:\\t%s [-AbcdDFGhikLMPsvXy] [-e [-V] [-p <path> ...]] \"\n\t    \"[-I <inflight I/Os>]\\n\"\n\t    \"\\t\\t[-o <var>=<value>]... [-t <txg>] [-U <cache>] [-x <dumpdir>]\\n\"\n\t    \"\\t\\t[-K <key>]\\n\"\n\t    \"\\t\\t[<poolname>[/<dataset | objset id>] [<object | range> ...]]\\n\"\n\t    \"\\t%s [-AdiPv] [-e [-V] [-p <path> ...]] [-U <cache>] [-K <key>]\\n\"\n\t    \"\\t\\t[<poolname>[/<dataset | objset id>] [<object | range> ...]\\n\"\n\t    \"\\t%s -B [-e [-V] [-p <path> ...]] [-I <inflight I/Os>]\\n\"\n\t    \"\\t\\t[-o <var>=<value>]... [-t <txg>] [-U <cache>] [-x <dumpdir>]\\n\"\n\t    \"\\t\\t[-K <key>] <poolname>/<objset id> [<backupflags>]\\n\"\n\t    \"\\t%s [-v] <bookmark>\\n\"\n\t    \"\\t%s -C [-A] [-U <cache>] [<poolname>]\\n\"\n\t    \"\\t%s -l [-Aqu] <device>\\n\"\n\t    \"\\t%s -m [-AFLPX] [-e [-V] [-p <path> ...]] [-t <txg>] \"\n\t    \"[-U <cache>]\\n\\t\\t<poolname> [<vdev> [<metaslab> ...]]\\n\"\n\t    \"\\t%s -O [-K <key>] <dataset> <path>\\n\"\n\t    \"\\t%s -r [-K <key>] <dataset> <path> <destination>\\n\"\n\t    \"\\t%s -R [-A] [-e [-V] [-p <path> ...]] [-U <cache>]\\n\"\n\t    \"\\t\\t<poolname> <vdev>:<offset>:<size>[:<flags>]\\n\"\n\t    \"\\t%s -E [-A] word0:word1:...:word15\\n\"\n\t    \"\\t%s -S [-AP] [-e [-V] [-p <path> ...]] [-U <cache>] \"\n\t    \"<poolname>\\n\\n\",\n\t    cmdname, cmdname, cmdname, cmdname, cmdname, cmdname, cmdname,\n\t    cmdname, cmdname, cmdname, cmdname, cmdname);\n\n\t(void) fprintf(stderr, \"    Dataset name must include at least one \"\n\t    \"separator character '/' or '@'\\n\");\n\t(void) fprintf(stderr, \"    If dataset name is specified, only that \"\n\t    \"dataset is dumped\\n\");\n\t(void) fprintf(stderr,  \"    If object numbers or object number \"\n\t    \"ranges are specified, only those\\n\"\n\t    \"    objects or ranges are dumped.\\n\\n\");\n\t(void) fprintf(stderr,\n\t    \"    Object ranges take the form <start>:<end>[:<flags>]\\n\"\n\t    \"        start    Starting object number\\n\"\n\t    \"        end      Ending object number, or -1 for no upper bound\\n\"\n\t    \"        flags    Optional flags to select object types:\\n\"\n\t    \"            A     All objects (this is the default)\\n\"\n\t    \"            d     ZFS directories\\n\"\n\t    \"            f     ZFS files \\n\"\n\t    \"            m     SPA space maps\\n\"\n\t    \"            z     ZAPs\\n\"\n\t    \"            -     Negate effect of next flag\\n\\n\");\n\t(void) fprintf(stderr, \"    Options to control amount of output:\\n\");\n\t(void) fprintf(stderr, \"        -b --block-stats             \"\n\t    \"block statistics\\n\");\n\t(void) fprintf(stderr, \"        -B --backup                  \"\n\t    \"backup stream\\n\");\n\t(void) fprintf(stderr, \"        -c --checksum                \"\n\t    \"checksum all metadata (twice for all data) blocks\\n\");\n\t(void) fprintf(stderr, \"        -C --config                  \"\n\t    \"config (or cachefile if alone)\\n\");\n\t(void) fprintf(stderr, \"        -d --datasets                \"\n\t    \"dataset(s)\\n\");\n\t(void) fprintf(stderr, \"        -D --dedup-stats             \"\n\t    \"dedup statistics\\n\");\n\t(void) fprintf(stderr, \"        -E --embedded-block-pointer=INTEGER\\n\"\n\t    \"                                     decode and display block \"\n\t    \"from an embedded block pointer\\n\");\n\t(void) fprintf(stderr, \"        -h --history                 \"\n\t    \"pool history\\n\");\n\t(void) fprintf(stderr, \"        -i --intent-logs             \"\n\t    \"intent logs\\n\");\n\t(void) fprintf(stderr, \"        -l --label                   \"\n\t    \"read label contents\\n\");\n\t(void) fprintf(stderr, \"        -k --checkpointed-state      \"\n\t    \"examine the checkpointed state of the pool\\n\");\n\t(void) fprintf(stderr, \"        -L --disable-leak-tracking   \"\n\t    \"disable leak tracking (do not load spacemaps)\\n\");\n\t(void) fprintf(stderr, \"        -m --metaslabs               \"\n\t    \"metaslabs\\n\");\n\t(void) fprintf(stderr, \"        -M --metaslab-groups         \"\n\t    \"metaslab groups\\n\");\n\t(void) fprintf(stderr, \"        -O --object-lookups          \"\n\t    \"perform object lookups by path\\n\");\n\t(void) fprintf(stderr, \"        -r --copy-object             \"\n\t    \"copy an object by path to file\\n\");\n\t(void) fprintf(stderr, \"        -R --read-block              \"\n\t    \"read and display block from a device\\n\");\n\t(void) fprintf(stderr, \"        -s --io-stats                \"\n\t    \"report stats on zdb's I/O\\n\");\n\t(void) fprintf(stderr, \"        -S --simulate-dedup          \"\n\t    \"simulate dedup to measure effect\\n\");\n\t(void) fprintf(stderr, \"        -v --verbose                 \"\n\t    \"verbose (applies to all others)\\n\");\n\t(void) fprintf(stderr, \"        -y --livelist                \"\n\t    \"perform livelist and metaslab validation on any livelists being \"\n\t    \"deleted\\n\\n\");\n\t(void) fprintf(stderr, \"    Below options are intended for use \"\n\t    \"with other options:\\n\");\n\t(void) fprintf(stderr, \"        -A --ignore-assertions       \"\n\t    \"ignore assertions (-A), enable panic recovery (-AA) or both \"\n\t    \"(-AAA)\\n\");\n\t(void) fprintf(stderr, \"        -e --exported                \"\n\t    \"pool is exported/destroyed/has altroot/not in a cachefile\\n\");\n\t(void) fprintf(stderr, \"        -F --automatic-rewind        \"\n\t    \"attempt automatic rewind within safe range of transaction \"\n\t    \"groups\\n\");\n\t(void) fprintf(stderr, \"        -G --dump-debug-msg          \"\n\t    \"dump zfs_dbgmsg buffer before exiting\\n\");\n\t(void) fprintf(stderr, \"        -I --inflight=INTEGER        \"\n\t    \"specify the maximum number of checksumming I/Os \"\n\t    \"[default is 200]\\n\");\n\t(void) fprintf(stderr, \"        -K --key=KEY                 \"\n\t    \"decryption key for encrypted dataset\\n\");\n\t(void) fprintf(stderr, \"        -o --option=\\\"OPTION=INTEGER\\\" \"\n\t    \"set global variable to an unsigned 32-bit integer\\n\");\n\t(void) fprintf(stderr, \"        -p --path==PATH              \"\n\t    \"use one or more with -e to specify path to vdev dir\\n\");\n\t(void) fprintf(stderr, \"        -P --parseable               \"\n\t    \"print numbers in parseable form\\n\");\n\t(void) fprintf(stderr, \"        -q --skip-label              \"\n\t    \"don't print label contents\\n\");\n\t(void) fprintf(stderr, \"        -t --txg=INTEGER             \"\n\t    \"highest txg to use when searching for uberblocks\\n\");\n\t(void) fprintf(stderr, \"        -T --brt-stats               \"\n\t    \"BRT statistics\\n\");\n\t(void) fprintf(stderr, \"        -u --uberblock               \"\n\t    \"uberblock\\n\");\n\t(void) fprintf(stderr, \"        -U --cachefile=PATH          \"\n\t    \"use alternate cachefile\\n\");\n\t(void) fprintf(stderr, \"        -V --verbatim                \"\n\t    \"do verbatim import\\n\");\n\t(void) fprintf(stderr, \"        -x --dump-blocks=PATH        \"\n\t    \"dump all read blocks into specified directory\\n\");\n\t(void) fprintf(stderr, \"        -X --extreme-rewind          \"\n\t    \"attempt extreme rewind (does not work with dataset)\\n\");\n\t(void) fprintf(stderr, \"        -Y --all-reconstruction      \"\n\t    \"attempt all reconstruction combinations for split blocks\\n\");\n\t(void) fprintf(stderr, \"        -Z --zstd-headers            \"\n\t    \"show ZSTD headers \\n\");\n\t(void) fprintf(stderr, \"Specify an option more than once (e.g. -bb) \"\n\t    \"to make only that option verbose\\n\");\n\t(void) fprintf(stderr, \"Default is to dump everything non-verbosely\\n\");\n\texit(1);\n}\n\nstatic void\ndump_debug_buffer(void)\n{\n\tif (dump_opt['G']) {\n\t\t(void) printf(\"\\n\");\n\t\t(void) fflush(stdout);\n\t\tzfs_dbgmsg_print(\"zdb\");\n\t}\n}\n\n \n\nstatic void\nfatal(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void) fprintf(stderr, \"%s: \", cmdname);\n\t(void) vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\t(void) fprintf(stderr, \"\\n\");\n\n\tdump_debug_buffer();\n\n\texit(1);\n}\n\nstatic void\ndump_packed_nvlist(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) size;\n\tnvlist_t *nv;\n\tsize_t nvsize = *(uint64_t *)data;\n\tchar *packed = umem_alloc(nvsize, UMEM_NOFAIL);\n\n\tVERIFY(0 == dmu_read(os, object, 0, nvsize, packed, DMU_READ_PREFETCH));\n\n\tVERIFY(nvlist_unpack(packed, nvsize, &nv, 0) == 0);\n\n\tumem_free(packed, nvsize);\n\n\tdump_nvlist(nv, 8);\n\n\tnvlist_free(nv);\n}\n\nstatic void\ndump_history_offsets(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) size;\n\tspa_history_phys_t *shp = data;\n\n\tif (shp == NULL)\n\t\treturn;\n\n\t(void) printf(\"\\t\\tpool_create_len = %llu\\n\",\n\t    (u_longlong_t)shp->sh_pool_create_len);\n\t(void) printf(\"\\t\\tphys_max_off = %llu\\n\",\n\t    (u_longlong_t)shp->sh_phys_max_off);\n\t(void) printf(\"\\t\\tbof = %llu\\n\",\n\t    (u_longlong_t)shp->sh_bof);\n\t(void) printf(\"\\t\\teof = %llu\\n\",\n\t    (u_longlong_t)shp->sh_eof);\n\t(void) printf(\"\\t\\trecords_lost = %llu\\n\",\n\t    (u_longlong_t)shp->sh_records_lost);\n}\n\nstatic void\nzdb_nicenum(uint64_t num, char *buf, size_t buflen)\n{\n\tif (dump_opt['P'])\n\t\t(void) snprintf(buf, buflen, \"%llu\", (longlong_t)num);\n\telse\n\t\tnicenum(num, buf, buflen);\n}\n\nstatic void\nzdb_nicebytes(uint64_t bytes, char *buf, size_t buflen)\n{\n\tif (dump_opt['P'])\n\t\t(void) snprintf(buf, buflen, \"%llu\", (longlong_t)bytes);\n\telse\n\t\tzfs_nicebytes(bytes, buf, buflen);\n}\n\nstatic const char histo_stars[] = \"****************************************\";\nstatic const uint64_t histo_width = sizeof (histo_stars) - 1;\n\nstatic void\ndump_histogram(const uint64_t *histo, int size, int offset)\n{\n\tint i;\n\tint minidx = size - 1;\n\tint maxidx = 0;\n\tuint64_t max = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (histo[i] == 0)\n\t\t\tcontinue;\n\t\tif (histo[i] > max)\n\t\t\tmax = histo[i];\n\t\tif (i > maxidx)\n\t\t\tmaxidx = i;\n\t\tif (i < minidx)\n\t\t\tminidx = i;\n\t}\n\n\tif (max < histo_width)\n\t\tmax = histo_width;\n\n\tfor (i = minidx; i <= maxidx; i++) {\n\t\t(void) printf(\"\\t\\t\\t%3u: %6llu %s\\n\",\n\t\t    i + offset, (u_longlong_t)histo[i],\n\t\t    &histo_stars[(max - histo[i]) * histo_width / max]);\n\t}\n}\n\nstatic void\ndump_zap_stats(objset_t *os, uint64_t object)\n{\n\tint error;\n\tzap_stats_t zs;\n\n\terror = zap_get_stats(os, object, &zs);\n\tif (error)\n\t\treturn;\n\n\tif (zs.zs_ptrtbl_len == 0) {\n\t\tASSERT(zs.zs_num_blocks == 1);\n\t\t(void) printf(\"\\tmicrozap: %llu bytes, %llu entries\\n\",\n\t\t    (u_longlong_t)zs.zs_blocksize,\n\t\t    (u_longlong_t)zs.zs_num_entries);\n\t\treturn;\n\t}\n\n\t(void) printf(\"\\tFat ZAP stats:\\n\");\n\n\t(void) printf(\"\\t\\tPointer table:\\n\");\n\t(void) printf(\"\\t\\t\\t%llu elements\\n\",\n\t    (u_longlong_t)zs.zs_ptrtbl_len);\n\t(void) printf(\"\\t\\t\\tzt_blk: %llu\\n\",\n\t    (u_longlong_t)zs.zs_ptrtbl_zt_blk);\n\t(void) printf(\"\\t\\t\\tzt_numblks: %llu\\n\",\n\t    (u_longlong_t)zs.zs_ptrtbl_zt_numblks);\n\t(void) printf(\"\\t\\t\\tzt_shift: %llu\\n\",\n\t    (u_longlong_t)zs.zs_ptrtbl_zt_shift);\n\t(void) printf(\"\\t\\t\\tzt_blks_copied: %llu\\n\",\n\t    (u_longlong_t)zs.zs_ptrtbl_blks_copied);\n\t(void) printf(\"\\t\\t\\tzt_nextblk: %llu\\n\",\n\t    (u_longlong_t)zs.zs_ptrtbl_nextblk);\n\n\t(void) printf(\"\\t\\tZAP entries: %llu\\n\",\n\t    (u_longlong_t)zs.zs_num_entries);\n\t(void) printf(\"\\t\\tLeaf blocks: %llu\\n\",\n\t    (u_longlong_t)zs.zs_num_leafs);\n\t(void) printf(\"\\t\\tTotal blocks: %llu\\n\",\n\t    (u_longlong_t)zs.zs_num_blocks);\n\t(void) printf(\"\\t\\tzap_block_type: 0x%llx\\n\",\n\t    (u_longlong_t)zs.zs_block_type);\n\t(void) printf(\"\\t\\tzap_magic: 0x%llx\\n\",\n\t    (u_longlong_t)zs.zs_magic);\n\t(void) printf(\"\\t\\tzap_salt: 0x%llx\\n\",\n\t    (u_longlong_t)zs.zs_salt);\n\n\t(void) printf(\"\\t\\tLeafs with 2^n pointers:\\n\");\n\tdump_histogram(zs.zs_leafs_with_2n_pointers, ZAP_HISTOGRAM_SIZE, 0);\n\n\t(void) printf(\"\\t\\tBlocks with n*5 entries:\\n\");\n\tdump_histogram(zs.zs_blocks_with_n5_entries, ZAP_HISTOGRAM_SIZE, 0);\n\n\t(void) printf(\"\\t\\tBlocks n/10 full:\\n\");\n\tdump_histogram(zs.zs_blocks_n_tenths_full, ZAP_HISTOGRAM_SIZE, 0);\n\n\t(void) printf(\"\\t\\tEntries with n chunks:\\n\");\n\tdump_histogram(zs.zs_entries_using_n_chunks, ZAP_HISTOGRAM_SIZE, 0);\n\n\t(void) printf(\"\\t\\tBuckets with n entries:\\n\");\n\tdump_histogram(zs.zs_buckets_with_n_entries, ZAP_HISTOGRAM_SIZE, 0);\n}\n\nstatic void\ndump_none(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) data, (void) size;\n}\n\nstatic void\ndump_unknown(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) data, (void) size;\n\t(void) printf(\"\\tUNKNOWN OBJECT TYPE\\n\");\n}\n\nstatic void\ndump_uint8(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) data, (void) size;\n}\n\nstatic void\ndump_uint64(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\tuint64_t *arr;\n\tuint64_t oursize;\n\tif (dump_opt['d'] < 6)\n\t\treturn;\n\n\tif (data == NULL) {\n\t\tdmu_object_info_t doi;\n\n\t\tVERIFY0(dmu_object_info(os, object, &doi));\n\t\tsize = doi.doi_max_offset;\n\t\t \n\t\toursize = MIN(size, 1 << 20);\n\t\tarr = kmem_alloc(oursize, KM_SLEEP);\n\n\t\tint err = dmu_read(os, object, 0, oursize, arr, 0);\n\t\tif (err != 0) {\n\t\t\t(void) printf(\"got error %u from dmu_read\\n\", err);\n\t\t\tkmem_free(arr, oursize);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\toursize = MIN(size, 1 << 20);\n\t\tarr = data;\n\t}\n\n\tif (size == 0) {\n\t\tif (data == NULL)\n\t\t\tkmem_free(arr, oursize);\n\t\t(void) printf(\"\\t\\t[]\\n\");\n\t\treturn;\n\t}\n\n\t(void) printf(\"\\t\\t[%0llx\", (u_longlong_t)arr[0]);\n\tfor (size_t i = 1; i * sizeof (uint64_t) < oursize; i++) {\n\t\tif (i % 4 != 0)\n\t\t\t(void) printf(\", %0llx\", (u_longlong_t)arr[i]);\n\t\telse\n\t\t\t(void) printf(\",\\n\\t\\t%0llx\", (u_longlong_t)arr[i]);\n\t}\n\tif (oursize != size)\n\t\t(void) printf(\", ... \");\n\t(void) printf(\"]\\n\");\n\n\tif (data == NULL)\n\t\tkmem_free(arr, oursize);\n}\n\nstatic void\ndump_zap(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tvoid *prop;\n\tunsigned i;\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = \", attr.za_name);\n\t\tif (attr.za_num_integers == 0) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprop = umem_zalloc(attr.za_num_integers *\n\t\t    attr.za_integer_length, UMEM_NOFAIL);\n\t\t(void) zap_lookup(os, object, attr.za_name,\n\t\t    attr.za_integer_length, attr.za_num_integers, prop);\n\t\tif (attr.za_integer_length == 1) {\n\t\t\tif (strcmp(attr.za_name,\n\t\t\t    DSL_CRYPTO_KEY_MASTER_KEY) == 0 ||\n\t\t\t    strcmp(attr.za_name,\n\t\t\t    DSL_CRYPTO_KEY_HMAC_KEY) == 0 ||\n\t\t\t    strcmp(attr.za_name, DSL_CRYPTO_KEY_IV) == 0 ||\n\t\t\t    strcmp(attr.za_name, DSL_CRYPTO_KEY_MAC) == 0 ||\n\t\t\t    strcmp(attr.za_name, DMU_POOL_CHECKSUM_SALT) == 0) {\n\t\t\t\tuint8_t *u8 = prop;\n\n\t\t\t\tfor (i = 0; i < attr.za_num_integers; i++) {\n\t\t\t\t\t(void) printf(\"%02x\", u8[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t(void) printf(\"%s\", (char *)prop);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < attr.za_num_integers; i++) {\n\t\t\t\tswitch (attr.za_integer_length) {\n\t\t\t\tcase 2:\n\t\t\t\t\t(void) printf(\"%u \",\n\t\t\t\t\t    ((uint16_t *)prop)[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t(void) printf(\"%u \",\n\t\t\t\t\t    ((uint32_t *)prop)[i]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\t(void) printf(\"%lld \",\n\t\t\t\t\t    (u_longlong_t)((int64_t *)prop)[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(void) printf(\"\\n\");\n\t\tumem_free(prop, attr.za_num_integers * attr.za_integer_length);\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic void\ndump_bpobj(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\tbpobj_phys_t *bpop = data;\n\tuint64_t i;\n\tchar bytes[32], comp[32], uncomp[32];\n\n\t \n\t_Static_assert(sizeof (bytes) >= NN_NUMBUF_SZ, \"bytes truncated\");\n\t_Static_assert(sizeof (comp) >= NN_NUMBUF_SZ, \"comp truncated\");\n\t_Static_assert(sizeof (uncomp) >= NN_NUMBUF_SZ, \"uncomp truncated\");\n\n\tif (bpop == NULL)\n\t\treturn;\n\n\tzdb_nicenum(bpop->bpo_bytes, bytes, sizeof (bytes));\n\tzdb_nicenum(bpop->bpo_comp, comp, sizeof (comp));\n\tzdb_nicenum(bpop->bpo_uncomp, uncomp, sizeof (uncomp));\n\n\t(void) printf(\"\\t\\tnum_blkptrs = %llu\\n\",\n\t    (u_longlong_t)bpop->bpo_num_blkptrs);\n\t(void) printf(\"\\t\\tbytes = %s\\n\", bytes);\n\tif (size >= BPOBJ_SIZE_V1) {\n\t\t(void) printf(\"\\t\\tcomp = %s\\n\", comp);\n\t\t(void) printf(\"\\t\\tuncomp = %s\\n\", uncomp);\n\t}\n\tif (size >= BPOBJ_SIZE_V2) {\n\t\t(void) printf(\"\\t\\tsubobjs = %llu\\n\",\n\t\t    (u_longlong_t)bpop->bpo_subobjs);\n\t\t(void) printf(\"\\t\\tnum_subobjs = %llu\\n\",\n\t\t    (u_longlong_t)bpop->bpo_num_subobjs);\n\t}\n\tif (size >= sizeof (*bpop)) {\n\t\t(void) printf(\"\\t\\tnum_freed = %llu\\n\",\n\t\t    (u_longlong_t)bpop->bpo_num_freed);\n\t}\n\n\tif (dump_opt['d'] < 5)\n\t\treturn;\n\n\tfor (i = 0; i < bpop->bpo_num_blkptrs; i++) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\tblkptr_t bp;\n\n\t\tint err = dmu_read(os, object,\n\t\t    i * sizeof (bp), sizeof (bp), &bp, 0);\n\t\tif (err != 0) {\n\t\t\t(void) printf(\"got error %u from dmu_read\\n\", err);\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf_blkptr_compact(blkbuf, sizeof (blkbuf), &bp,\n\t\t    BP_GET_FREE(&bp));\n\t\t(void) printf(\"\\t%s\\n\", blkbuf);\n\t}\n}\n\nstatic void\ndump_bpobj_subobjs(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tdmu_object_info_t doi;\n\tint64_t i;\n\n\tVERIFY0(dmu_object_info(os, object, &doi));\n\tuint64_t *subobjs = kmem_alloc(doi.doi_max_offset, KM_SLEEP);\n\n\tint err = dmu_read(os, object, 0, doi.doi_max_offset, subobjs, 0);\n\tif (err != 0) {\n\t\t(void) printf(\"got error %u from dmu_read\\n\", err);\n\t\tkmem_free(subobjs, doi.doi_max_offset);\n\t\treturn;\n\t}\n\n\tint64_t last_nonzero = -1;\n\tfor (i = 0; i < doi.doi_max_offset / 8; i++) {\n\t\tif (subobjs[i] != 0)\n\t\t\tlast_nonzero = i;\n\t}\n\n\tfor (i = 0; i <= last_nonzero; i++) {\n\t\t(void) printf(\"\\t%llu\\n\", (u_longlong_t)subobjs[i]);\n\t}\n\tkmem_free(subobjs, doi.doi_max_offset);\n}\n\nstatic void\ndump_ddt_zap(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tdump_zap_stats(os, object);\n\t \n}\n\nstatic void\ndump_sa_attrs(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = \", attr.za_name);\n\t\tif (attr.za_num_integers == 0) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t(void) printf(\" %llx : [%d:%d:%d]\\n\",\n\t\t    (u_longlong_t)attr.za_first_integer,\n\t\t    (int)ATTR_LENGTH(attr.za_first_integer),\n\t\t    (int)ATTR_BSWAP(attr.za_first_integer),\n\t\t    (int)ATTR_NUM(attr.za_first_integer));\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic void\ndump_sa_layouts(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tuint16_t *layout_attrs;\n\tunsigned i;\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = [\", attr.za_name);\n\t\tif (attr.za_num_integers == 0) {\n\t\t\t(void) printf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tVERIFY(attr.za_integer_length == 2);\n\t\tlayout_attrs = umem_zalloc(attr.za_num_integers *\n\t\t    attr.za_integer_length, UMEM_NOFAIL);\n\n\t\tVERIFY(zap_lookup(os, object, attr.za_name,\n\t\t    attr.za_integer_length,\n\t\t    attr.za_num_integers, layout_attrs) == 0);\n\n\t\tfor (i = 0; i != attr.za_num_integers; i++)\n\t\t\t(void) printf(\" %d \", (int)layout_attrs[i]);\n\t\t(void) printf(\"]\\n\");\n\t\tumem_free(layout_attrs,\n\t\t    attr.za_num_integers * attr.za_integer_length);\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic void\ndump_zpldir(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tconst char *typenames[] = {\n\t\t  \"not specified\",\n\t\t  \"FIFO\",\n\t\t  \"Character Device\",\n\t\t  \"3 (invalid)\",\n\t\t  \"Directory\",\n\t\t  \"5 (invalid)\",\n\t\t  \"Block Device\",\n\t\t  \"7 (invalid)\",\n\t\t  \"Regular File\",\n\t\t  \"9 (invalid)\",\n\t\t  \"Symbolic Link\",\n\t\t  \"11 (invalid)\",\n\t\t  \"Socket\",\n\t\t  \"Door\",\n\t\t  \"Event Port\",\n\t\t  \"15 (invalid)\",\n\t};\n\n\tdump_zap_stats(os, object);\n\t(void) printf(\"\\n\");\n\n\tfor (zap_cursor_init(&zc, os, object);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\t(void) printf(\"\\t\\t%s = %lld (type: %s)\\n\",\n\t\t    attr.za_name, ZFS_DIRENT_OBJ(attr.za_first_integer),\n\t\t    typenames[ZFS_DIRENT_TYPE(attr.za_first_integer)]);\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic int\nget_dtl_refcount(vdev_t *vd)\n{\n\tint refcount = 0;\n\n\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\tspace_map_t *sm = vd->vdev_dtl_sm;\n\n\t\tif (sm != NULL &&\n\t\t    sm->sm_dbuf->db_size == sizeof (space_map_phys_t))\n\t\t\treturn (1);\n\t\treturn (0);\n\t}\n\n\tfor (unsigned c = 0; c < vd->vdev_children; c++)\n\t\trefcount += get_dtl_refcount(vd->vdev_child[c]);\n\treturn (refcount);\n}\n\nstatic int\nget_metaslab_refcount(vdev_t *vd)\n{\n\tint refcount = 0;\n\n\tif (vd->vdev_top == vd) {\n\t\tfor (uint64_t m = 0; m < vd->vdev_ms_count; m++) {\n\t\t\tspace_map_t *sm = vd->vdev_ms[m]->ms_sm;\n\n\t\t\tif (sm != NULL &&\n\t\t\t    sm->sm_dbuf->db_size == sizeof (space_map_phys_t))\n\t\t\t\trefcount++;\n\t\t}\n\t}\n\tfor (unsigned c = 0; c < vd->vdev_children; c++)\n\t\trefcount += get_metaslab_refcount(vd->vdev_child[c]);\n\n\treturn (refcount);\n}\n\nstatic int\nget_obsolete_refcount(vdev_t *vd)\n{\n\tuint64_t obsolete_sm_object;\n\tint refcount = 0;\n\n\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\tif (vd->vdev_top == vd && obsolete_sm_object != 0) {\n\t\tdmu_object_info_t doi;\n\t\tVERIFY0(dmu_object_info(vd->vdev_spa->spa_meta_objset,\n\t\t    obsolete_sm_object, &doi));\n\t\tif (doi.doi_bonus_size == sizeof (space_map_phys_t)) {\n\t\t\trefcount++;\n\t\t}\n\t} else {\n\t\tASSERT3P(vd->vdev_obsolete_sm, ==, NULL);\n\t\tASSERT3U(obsolete_sm_object, ==, 0);\n\t}\n\tfor (unsigned c = 0; c < vd->vdev_children; c++) {\n\t\trefcount += get_obsolete_refcount(vd->vdev_child[c]);\n\t}\n\n\treturn (refcount);\n}\n\nstatic int\nget_prev_obsolete_spacemap_refcount(spa_t *spa)\n{\n\tuint64_t prev_obj =\n\t    spa->spa_condensing_indirect_phys.scip_prev_obsolete_sm_object;\n\tif (prev_obj != 0) {\n\t\tdmu_object_info_t doi;\n\t\tVERIFY0(dmu_object_info(spa->spa_meta_objset, prev_obj, &doi));\n\t\tif (doi.doi_bonus_size == sizeof (space_map_phys_t)) {\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nget_checkpoint_refcount(vdev_t *vd)\n{\n\tint refcount = 0;\n\n\tif (vd->vdev_top == vd && vd->vdev_top_zap != 0 &&\n\t    zap_contains(spa_meta_objset(vd->vdev_spa),\n\t    vd->vdev_top_zap, VDEV_TOP_ZAP_POOL_CHECKPOINT_SM) == 0)\n\t\trefcount++;\n\n\tfor (uint64_t c = 0; c < vd->vdev_children; c++)\n\t\trefcount += get_checkpoint_refcount(vd->vdev_child[c]);\n\n\treturn (refcount);\n}\n\nstatic int\nget_log_spacemap_refcount(spa_t *spa)\n{\n\treturn (avl_numnodes(&spa->spa_sm_logs_by_txg));\n}\n\nstatic int\nverify_spacemap_refcounts(spa_t *spa)\n{\n\tuint64_t expected_refcount = 0;\n\tuint64_t actual_refcount;\n\n\t(void) feature_get_refcount(spa,\n\t    &spa_feature_table[SPA_FEATURE_SPACEMAP_HISTOGRAM],\n\t    &expected_refcount);\n\tactual_refcount = get_dtl_refcount(spa->spa_root_vdev);\n\tactual_refcount += get_metaslab_refcount(spa->spa_root_vdev);\n\tactual_refcount += get_obsolete_refcount(spa->spa_root_vdev);\n\tactual_refcount += get_prev_obsolete_spacemap_refcount(spa);\n\tactual_refcount += get_checkpoint_refcount(spa->spa_root_vdev);\n\tactual_refcount += get_log_spacemap_refcount(spa);\n\n\tif (expected_refcount != actual_refcount) {\n\t\t(void) printf(\"space map refcount mismatch: expected %lld != \"\n\t\t    \"actual %lld\\n\",\n\t\t    (longlong_t)expected_refcount,\n\t\t    (longlong_t)actual_refcount);\n\t\treturn (2);\n\t}\n\treturn (0);\n}\n\nstatic void\ndump_spacemap(objset_t *os, space_map_t *sm)\n{\n\tconst char *ddata[] = { \"ALLOC\", \"FREE\", \"CONDENSE\", \"INVALID\",\n\t    \"INVALID\", \"INVALID\", \"INVALID\", \"INVALID\" };\n\n\tif (sm == NULL)\n\t\treturn;\n\n\t(void) printf(\"space map object %llu:\\n\",\n\t    (longlong_t)sm->sm_object);\n\t(void) printf(\"  smp_length = 0x%llx\\n\",\n\t    (longlong_t)sm->sm_phys->smp_length);\n\t(void) printf(\"  smp_alloc = 0x%llx\\n\",\n\t    (longlong_t)sm->sm_phys->smp_alloc);\n\n\tif (dump_opt['d'] < 6 && dump_opt['m'] < 4)\n\t\treturn;\n\n\t \n\tuint8_t mapshift = sm->sm_shift;\n\tint64_t alloc = 0;\n\tuint64_t word, entry_id = 0;\n\tfor (uint64_t offset = 0; offset < space_map_length(sm);\n\t    offset += sizeof (word)) {\n\n\t\tVERIFY0(dmu_read(os, space_map_object(sm), offset,\n\t\t    sizeof (word), &word, DMU_READ_PREFETCH));\n\n\t\tif (sm_entry_is_debug(word)) {\n\t\t\tuint64_t de_txg = SM_DEBUG_TXG_DECODE(word);\n\t\t\tuint64_t de_sync_pass = SM_DEBUG_SYNCPASS_DECODE(word);\n\t\t\tif (de_txg == 0) {\n\t\t\t\t(void) printf(\n\t\t\t\t    \"\\t    [%6llu] PADDING\\n\",\n\t\t\t\t    (u_longlong_t)entry_id);\n\t\t\t} else {\n\t\t\t\t(void) printf(\n\t\t\t\t    \"\\t    [%6llu] %s: txg %llu pass %llu\\n\",\n\t\t\t\t    (u_longlong_t)entry_id,\n\t\t\t\t    ddata[SM_DEBUG_ACTION_DECODE(word)],\n\t\t\t\t    (u_longlong_t)de_txg,\n\t\t\t\t    (u_longlong_t)de_sync_pass);\n\t\t\t}\n\t\t\tentry_id++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint8_t words;\n\t\tchar entry_type;\n\t\tuint64_t entry_off, entry_run, entry_vdev = SM_NO_VDEVID;\n\n\t\tif (sm_entry_is_single_word(word)) {\n\t\t\tentry_type = (SM_TYPE_DECODE(word) == SM_ALLOC) ?\n\t\t\t    'A' : 'F';\n\t\t\tentry_off = (SM_OFFSET_DECODE(word) << mapshift) +\n\t\t\t    sm->sm_start;\n\t\t\tentry_run = SM_RUN_DECODE(word) << mapshift;\n\t\t\twords = 1;\n\t\t} else {\n\t\t\t \n\t\t\tASSERT(sm_entry_is_double_word(word));\n\n\t\t\tuint64_t extra_word;\n\t\t\toffset += sizeof (extra_word);\n\t\t\tVERIFY0(dmu_read(os, space_map_object(sm), offset,\n\t\t\t    sizeof (extra_word), &extra_word,\n\t\t\t    DMU_READ_PREFETCH));\n\n\t\t\tASSERT3U(offset, <=, space_map_length(sm));\n\n\t\t\tentry_run = SM2_RUN_DECODE(word) << mapshift;\n\t\t\tentry_vdev = SM2_VDEV_DECODE(word);\n\t\t\tentry_type = (SM2_TYPE_DECODE(extra_word) == SM_ALLOC) ?\n\t\t\t    'A' : 'F';\n\t\t\tentry_off = (SM2_OFFSET_DECODE(extra_word) <<\n\t\t\t    mapshift) + sm->sm_start;\n\t\t\twords = 2;\n\t\t}\n\n\t\t(void) printf(\"\\t    [%6llu]    %c  range:\"\n\t\t    \" %010llx-%010llx  size: %06llx vdev: %06llu words: %u\\n\",\n\t\t    (u_longlong_t)entry_id,\n\t\t    entry_type, (u_longlong_t)entry_off,\n\t\t    (u_longlong_t)(entry_off + entry_run),\n\t\t    (u_longlong_t)entry_run,\n\t\t    (u_longlong_t)entry_vdev, words);\n\n\t\tif (entry_type == 'A')\n\t\t\talloc += entry_run;\n\t\telse\n\t\t\talloc -= entry_run;\n\t\tentry_id++;\n\t}\n\tif (alloc != space_map_allocated(sm)) {\n\t\t(void) printf(\"space_map_object alloc (%lld) INCONSISTENT \"\n\t\t    \"with space map summary (%lld)\\n\",\n\t\t    (longlong_t)space_map_allocated(sm), (longlong_t)alloc);\n\t}\n}\n\nstatic void\ndump_metaslab_stats(metaslab_t *msp)\n{\n\tchar maxbuf[32];\n\trange_tree_t *rt = msp->ms_allocatable;\n\tzfs_btree_t *t = &msp->ms_allocatable_by_size;\n\tint free_pct = range_tree_space(rt) * 100 / msp->ms_size;\n\n\t \n\t_Static_assert(sizeof (maxbuf) >= NN_NUMBUF_SZ, \"maxbuf truncated\");\n\n\tzdb_nicenum(metaslab_largest_allocatable(msp), maxbuf, sizeof (maxbuf));\n\n\t(void) printf(\"\\t %25s %10lu   %7s  %6s   %4s %4d%%\\n\",\n\t    \"segments\", zfs_btree_numnodes(t), \"maxsize\", maxbuf,\n\t    \"freepct\", free_pct);\n\t(void) printf(\"\\tIn-memory histogram:\\n\");\n\tdump_histogram(rt->rt_histogram, RANGE_TREE_HISTOGRAM_SIZE, 0);\n}\n\nstatic void\ndump_metaslab(metaslab_t *msp)\n{\n\tvdev_t *vd = msp->ms_group->mg_vd;\n\tspa_t *spa = vd->vdev_spa;\n\tspace_map_t *sm = msp->ms_sm;\n\tchar freebuf[32];\n\n\tzdb_nicenum(msp->ms_size - space_map_allocated(sm), freebuf,\n\t    sizeof (freebuf));\n\n\t(void) printf(\n\t    \"\\tmetaslab %6llu   offset %12llx   spacemap %6llu   free    %5s\\n\",\n\t    (u_longlong_t)msp->ms_id, (u_longlong_t)msp->ms_start,\n\t    (u_longlong_t)space_map_object(sm), freebuf);\n\n\tif (dump_opt['m'] > 2 && !dump_opt['L']) {\n\t\tmutex_enter(&msp->ms_lock);\n\t\tVERIFY0(metaslab_load(msp));\n\t\trange_tree_stat_verify(msp->ms_allocatable);\n\t\tdump_metaslab_stats(msp);\n\t\tmetaslab_unload(msp);\n\t\tmutex_exit(&msp->ms_lock);\n\t}\n\n\tif (dump_opt['m'] > 1 && sm != NULL &&\n\t    spa_feature_is_active(spa, SPA_FEATURE_SPACEMAP_HISTOGRAM)) {\n\t\t \n\t\t(void) printf(\"\\tOn-disk histogram:\\t\\tfragmentation %llu\\n\",\n\t\t    (u_longlong_t)msp->ms_fragmentation);\n\t\tdump_histogram(sm->sm_phys->smp_histogram,\n\t\t    SPACE_MAP_HISTOGRAM_SIZE, sm->sm_shift);\n\t}\n\n\tif (vd->vdev_ops == &vdev_draid_ops)\n\t\tASSERT3U(msp->ms_size, <=, 1ULL << vd->vdev_ms_shift);\n\telse\n\t\tASSERT3U(msp->ms_size, ==, 1ULL << vd->vdev_ms_shift);\n\n\tdump_spacemap(spa->spa_meta_objset, msp->ms_sm);\n\n\tif (spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP)) {\n\t\t(void) printf(\"\\tFlush data:\\n\\tunflushed txg=%llu\\n\\n\",\n\t\t    (u_longlong_t)metaslab_unflushed_txg(msp));\n\t}\n}\n\nstatic void\nprint_vdev_metaslab_header(vdev_t *vd)\n{\n\tvdev_alloc_bias_t alloc_bias = vd->vdev_alloc_bias;\n\tconst char *bias_str = \"\";\n\tif (alloc_bias == VDEV_BIAS_LOG || vd->vdev_islog) {\n\t\tbias_str = VDEV_ALLOC_BIAS_LOG;\n\t} else if (alloc_bias == VDEV_BIAS_SPECIAL) {\n\t\tbias_str = VDEV_ALLOC_BIAS_SPECIAL;\n\t} else if (alloc_bias == VDEV_BIAS_DEDUP) {\n\t\tbias_str = VDEV_ALLOC_BIAS_DEDUP;\n\t}\n\n\tuint64_t ms_flush_data_obj = 0;\n\tif (vd->vdev_top_zap != 0) {\n\t\tint error = zap_lookup(spa_meta_objset(vd->vdev_spa),\n\t\t    vd->vdev_top_zap, VDEV_TOP_ZAP_MS_UNFLUSHED_PHYS_TXGS,\n\t\t    sizeof (uint64_t), 1, &ms_flush_data_obj);\n\t\tif (error != ENOENT) {\n\t\t\tASSERT0(error);\n\t\t}\n\t}\n\n\t(void) printf(\"\\tvdev %10llu   %s\",\n\t    (u_longlong_t)vd->vdev_id, bias_str);\n\n\tif (ms_flush_data_obj != 0) {\n\t\t(void) printf(\"   ms_unflushed_phys object %llu\",\n\t\t    (u_longlong_t)ms_flush_data_obj);\n\t}\n\n\t(void) printf(\"\\n\\t%-10s%5llu   %-19s   %-15s   %-12s\\n\",\n\t    \"metaslabs\", (u_longlong_t)vd->vdev_ms_count,\n\t    \"offset\", \"spacemap\", \"free\");\n\t(void) printf(\"\\t%15s   %19s   %15s   %12s\\n\",\n\t    \"---------------\", \"-------------------\",\n\t    \"---------------\", \"------------\");\n}\n\nstatic void\ndump_metaslab_groups(spa_t *spa, boolean_t show_special)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tmetaslab_class_t *mc = spa_normal_class(spa);\n\tmetaslab_class_t *smc = spa_special_class(spa);\n\tuint64_t fragmentation;\n\n\tmetaslab_class_histogram_verify(mc);\n\n\tfor (unsigned c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *tvd = rvd->vdev_child[c];\n\t\tmetaslab_group_t *mg = tvd->vdev_mg;\n\n\t\tif (mg == NULL || (mg->mg_class != mc &&\n\t\t    (!show_special || mg->mg_class != smc)))\n\t\t\tcontinue;\n\n\t\tmetaslab_group_histogram_verify(mg);\n\t\tmg->mg_fragmentation = metaslab_group_fragmentation(mg);\n\n\t\t(void) printf(\"\\tvdev %10llu\\t\\tmetaslabs%5llu\\t\\t\"\n\t\t    \"fragmentation\",\n\t\t    (u_longlong_t)tvd->vdev_id,\n\t\t    (u_longlong_t)tvd->vdev_ms_count);\n\t\tif (mg->mg_fragmentation == ZFS_FRAG_INVALID) {\n\t\t\t(void) printf(\"%3s\\n\", \"-\");\n\t\t} else {\n\t\t\t(void) printf(\"%3llu%%\\n\",\n\t\t\t    (u_longlong_t)mg->mg_fragmentation);\n\t\t}\n\t\tdump_histogram(mg->mg_histogram, RANGE_TREE_HISTOGRAM_SIZE, 0);\n\t}\n\n\t(void) printf(\"\\tpool %s\\tfragmentation\", spa_name(spa));\n\tfragmentation = metaslab_class_fragmentation(mc);\n\tif (fragmentation == ZFS_FRAG_INVALID)\n\t\t(void) printf(\"\\t%3s\\n\", \"-\");\n\telse\n\t\t(void) printf(\"\\t%3llu%%\\n\", (u_longlong_t)fragmentation);\n\tdump_histogram(mc->mc_histogram, RANGE_TREE_HISTOGRAM_SIZE, 0);\n}\n\nstatic void\nprint_vdev_indirect(vdev_t *vd)\n{\n\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tvdev_indirect_births_t *vib = vd->vdev_indirect_births;\n\n\tif (vim == NULL) {\n\t\tASSERT3P(vib, ==, NULL);\n\t\treturn;\n\t}\n\n\tASSERT3U(vdev_indirect_mapping_object(vim), ==,\n\t    vic->vic_mapping_object);\n\tASSERT3U(vdev_indirect_births_object(vib), ==,\n\t    vic->vic_births_object);\n\n\t(void) printf(\"indirect births obj %llu:\\n\",\n\t    (longlong_t)vic->vic_births_object);\n\t(void) printf(\"    vib_count = %llu\\n\",\n\t    (longlong_t)vdev_indirect_births_count(vib));\n\tfor (uint64_t i = 0; i < vdev_indirect_births_count(vib); i++) {\n\t\tvdev_indirect_birth_entry_phys_t *cur_vibe =\n\t\t    &vib->vib_entries[i];\n\t\t(void) printf(\"\\toffset %llx -> txg %llu\\n\",\n\t\t    (longlong_t)cur_vibe->vibe_offset,\n\t\t    (longlong_t)cur_vibe->vibe_phys_birth_txg);\n\t}\n\t(void) printf(\"\\n\");\n\n\t(void) printf(\"indirect mapping obj %llu:\\n\",\n\t    (longlong_t)vic->vic_mapping_object);\n\t(void) printf(\"    vim_max_offset = 0x%llx\\n\",\n\t    (longlong_t)vdev_indirect_mapping_max_offset(vim));\n\t(void) printf(\"    vim_bytes_mapped = 0x%llx\\n\",\n\t    (longlong_t)vdev_indirect_mapping_bytes_mapped(vim));\n\t(void) printf(\"    vim_count = %llu\\n\",\n\t    (longlong_t)vdev_indirect_mapping_num_entries(vim));\n\n\tif (dump_opt['d'] <= 5 && dump_opt['m'] <= 3)\n\t\treturn;\n\n\tuint32_t *counts = vdev_indirect_mapping_load_obsolete_counts(vim);\n\n\tfor (uint64_t i = 0; i < vdev_indirect_mapping_num_entries(vim); i++) {\n\t\tvdev_indirect_mapping_entry_phys_t *vimep =\n\t\t    &vim->vim_entries[i];\n\t\t(void) printf(\"\\t<%llx:%llx:%llx> -> \"\n\t\t    \"<%llx:%llx:%llx> (%x obsolete)\\n\",\n\t\t    (longlong_t)vd->vdev_id,\n\t\t    (longlong_t)DVA_MAPPING_GET_SRC_OFFSET(vimep),\n\t\t    (longlong_t)DVA_GET_ASIZE(&vimep->vimep_dst),\n\t\t    (longlong_t)DVA_GET_VDEV(&vimep->vimep_dst),\n\t\t    (longlong_t)DVA_GET_OFFSET(&vimep->vimep_dst),\n\t\t    (longlong_t)DVA_GET_ASIZE(&vimep->vimep_dst),\n\t\t    counts[i]);\n\t}\n\t(void) printf(\"\\n\");\n\n\tuint64_t obsolete_sm_object;\n\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\tif (obsolete_sm_object != 0) {\n\t\tobjset_t *mos = vd->vdev_spa->spa_meta_objset;\n\t\t(void) printf(\"obsolete space map object %llu:\\n\",\n\t\t    (u_longlong_t)obsolete_sm_object);\n\t\tASSERT(vd->vdev_obsolete_sm != NULL);\n\t\tASSERT3U(space_map_object(vd->vdev_obsolete_sm), ==,\n\t\t    obsolete_sm_object);\n\t\tdump_spacemap(mos, vd->vdev_obsolete_sm);\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\nstatic void\ndump_metaslabs(spa_t *spa)\n{\n\tvdev_t *vd, *rvd = spa->spa_root_vdev;\n\tuint64_t m, c = 0, children = rvd->vdev_children;\n\n\t(void) printf(\"\\nMetaslabs:\\n\");\n\n\tif (!dump_opt['d'] && zopt_metaslab_args > 0) {\n\t\tc = zopt_metaslab[0];\n\n\t\tif (c >= children)\n\t\t\t(void) fatal(\"bad vdev id: %llu\", (u_longlong_t)c);\n\n\t\tif (zopt_metaslab_args > 1) {\n\t\t\tvd = rvd->vdev_child[c];\n\t\t\tprint_vdev_metaslab_header(vd);\n\n\t\t\tfor (m = 1; m < zopt_metaslab_args; m++) {\n\t\t\t\tif (zopt_metaslab[m] < vd->vdev_ms_count)\n\t\t\t\t\tdump_metaslab(\n\t\t\t\t\t    vd->vdev_ms[zopt_metaslab[m]]);\n\t\t\t\telse\n\t\t\t\t\t(void) fprintf(stderr, \"bad metaslab \"\n\t\t\t\t\t    \"number %llu\\n\",\n\t\t\t\t\t    (u_longlong_t)zopt_metaslab[m]);\n\t\t\t}\n\t\t\t(void) printf(\"\\n\");\n\t\t\treturn;\n\t\t}\n\t\tchildren = c + 1;\n\t}\n\tfor (; c < children; c++) {\n\t\tvd = rvd->vdev_child[c];\n\t\tprint_vdev_metaslab_header(vd);\n\n\t\tprint_vdev_indirect(vd);\n\n\t\tfor (m = 0; m < vd->vdev_ms_count; m++)\n\t\t\tdump_metaslab(vd->vdev_ms[m]);\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\nstatic void\ndump_log_spacemaps(spa_t *spa)\n{\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP))\n\t\treturn;\n\n\t(void) printf(\"\\nLog Space Maps in Pool:\\n\");\n\tfor (spa_log_sm_t *sls = avl_first(&spa->spa_sm_logs_by_txg);\n\t    sls; sls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls)) {\n\t\tspace_map_t *sm = NULL;\n\t\tVERIFY0(space_map_open(&sm, spa_meta_objset(spa),\n\t\t    sls->sls_sm_obj, 0, UINT64_MAX, SPA_MINBLOCKSHIFT));\n\n\t\t(void) printf(\"Log Spacemap object %llu txg %llu\\n\",\n\t\t    (u_longlong_t)sls->sls_sm_obj, (u_longlong_t)sls->sls_txg);\n\t\tdump_spacemap(spa->spa_meta_objset, sm);\n\t\tspace_map_close(sm);\n\t}\n\t(void) printf(\"\\n\");\n}\n\nstatic void\ndump_dde(const ddt_t *ddt, const ddt_entry_t *dde, uint64_t index)\n{\n\tconst ddt_phys_t *ddp = dde->dde_phys;\n\tconst ddt_key_t *ddk = &dde->dde_key;\n\tconst char *types[4] = { \"ditto\", \"single\", \"double\", \"triple\" };\n\tchar blkbuf[BP_SPRINTF_LEN];\n\tblkptr_t blk;\n\tint p;\n\n\tfor (p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {\n\t\tif (ddp->ddp_phys_birth == 0)\n\t\t\tcontinue;\n\t\tddt_bp_create(ddt->ddt_checksum, ddk, ddp, &blk);\n\t\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), &blk);\n\t\t(void) printf(\"index %llx refcnt %llu %s %s\\n\",\n\t\t    (u_longlong_t)index, (u_longlong_t)ddp->ddp_refcnt,\n\t\t    types[p], blkbuf);\n\t}\n}\n\nstatic void\ndump_dedup_ratio(const ddt_stat_t *dds)\n{\n\tdouble rL, rP, rD, D, dedup, compress, copies;\n\n\tif (dds->dds_blocks == 0)\n\t\treturn;\n\n\trL = (double)dds->dds_ref_lsize;\n\trP = (double)dds->dds_ref_psize;\n\trD = (double)dds->dds_ref_dsize;\n\tD = (double)dds->dds_dsize;\n\n\tdedup = rD / D;\n\tcompress = rL / rP;\n\tcopies = rD / rP;\n\n\t(void) printf(\"dedup = %.2f, compress = %.2f, copies = %.2f, \"\n\t    \"dedup * compress / copies = %.2f\\n\\n\",\n\t    dedup, compress, copies, dedup * compress / copies);\n}\n\nstatic void\ndump_ddt(ddt_t *ddt, enum ddt_type type, enum ddt_class class)\n{\n\tchar name[DDT_NAMELEN];\n\tddt_entry_t dde;\n\tuint64_t walk = 0;\n\tdmu_object_info_t doi;\n\tuint64_t count, dspace, mspace;\n\tint error;\n\n\terror = ddt_object_info(ddt, type, class, &doi);\n\n\tif (error == ENOENT)\n\t\treturn;\n\tASSERT(error == 0);\n\n\terror = ddt_object_count(ddt, type, class, &count);\n\tASSERT(error == 0);\n\tif (count == 0)\n\t\treturn;\n\n\tdspace = doi.doi_physical_blocks_512 << 9;\n\tmspace = doi.doi_fill_count * doi.doi_data_block_size;\n\n\tddt_object_name(ddt, type, class, name);\n\n\t(void) printf(\"%s: %llu entries, size %llu on disk, %llu in core\\n\",\n\t    name,\n\t    (u_longlong_t)count,\n\t    (u_longlong_t)(dspace / count),\n\t    (u_longlong_t)(mspace / count));\n\n\tif (dump_opt['D'] < 3)\n\t\treturn;\n\n\tzpool_dump_ddt(NULL, &ddt->ddt_histogram[type][class]);\n\n\tif (dump_opt['D'] < 4)\n\t\treturn;\n\n\tif (dump_opt['D'] < 5 && class == DDT_CLASS_UNIQUE)\n\t\treturn;\n\n\t(void) printf(\"%s contents:\\n\\n\", name);\n\n\twhile ((error = ddt_object_walk(ddt, type, class, &walk, &dde)) == 0)\n\t\tdump_dde(ddt, &dde, walk);\n\n\tASSERT3U(error, ==, ENOENT);\n\n\t(void) printf(\"\\n\");\n}\n\nstatic void\ndump_all_ddts(spa_t *spa)\n{\n\tddt_histogram_t ddh_total = {{{0}}};\n\tddt_stat_t dds_total = {0};\n\n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++) {\n\t\tddt_t *ddt = spa->spa_ddt[c];\n\t\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES;\n\t\t\t    class++) {\n\t\t\t\tdump_ddt(ddt, type, class);\n\t\t\t}\n\t\t}\n\t}\n\n\tddt_get_dedup_stats(spa, &dds_total);\n\n\tif (dds_total.dds_blocks == 0) {\n\t\t(void) printf(\"All DDTs are empty\\n\");\n\t\treturn;\n\t}\n\n\t(void) printf(\"\\n\");\n\n\tif (dump_opt['D'] > 1) {\n\t\t(void) printf(\"DDT histogram (aggregated over all DDTs):\\n\");\n\t\tddt_get_dedup_histogram(spa, &ddh_total);\n\t\tzpool_dump_ddt(&dds_total, &ddh_total);\n\t}\n\n\tdump_dedup_ratio(&dds_total);\n}\n\nstatic void\ndump_brt(spa_t *spa)\n{\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_BLOCK_CLONING)) {\n\t\tprintf(\"BRT: unsupported on this pool\\n\");\n\t\treturn;\n\t}\n\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_BLOCK_CLONING)) {\n\t\tprintf(\"BRT: empty\\n\");\n\t\treturn;\n\t}\n\n\tbrt_t *brt = spa->spa_brt;\n\tVERIFY(brt);\n\n\tchar count[32], used[32], saved[32];\n\tzdb_nicebytes(brt_get_used(spa), used, sizeof (used));\n\tzdb_nicebytes(brt_get_saved(spa), saved, sizeof (saved));\n\tuint64_t ratio = brt_get_ratio(spa);\n\tprintf(\"BRT: used %s; saved %s; ratio %llu.%02llux\\n\", used, saved,\n\t    (u_longlong_t)(ratio / 100), (u_longlong_t)(ratio % 100));\n\n\tif (dump_opt['T'] < 2)\n\t\treturn;\n\n\tfor (uint64_t vdevid = 0; vdevid < brt->brt_nvdevs; vdevid++) {\n\t\tbrt_vdev_t *brtvd = &brt->brt_vdevs[vdevid];\n\t\tif (brtvd == NULL)\n\t\t\tcontinue;\n\n\t\tif (!brtvd->bv_initiated) {\n\t\t\tprintf(\"BRT: vdev %\" PRIu64 \": empty\\n\", vdevid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tzdb_nicenum(brtvd->bv_totalcount, count, sizeof (count));\n\t\tzdb_nicebytes(brtvd->bv_usedspace, used, sizeof (used));\n\t\tzdb_nicebytes(brtvd->bv_savedspace, saved, sizeof (saved));\n\t\tprintf(\"BRT: vdev %\" PRIu64 \": refcnt %s; used %s; saved %s\\n\",\n\t\t    vdevid, count, used, saved);\n\t}\n\n\tif (dump_opt['T'] < 3)\n\t\treturn;\n\n\tchar dva[64];\n\tprintf(\"\\n%-16s %-10s\\n\", \"DVA\", \"REFCNT\");\n\n\tfor (uint64_t vdevid = 0; vdevid < brt->brt_nvdevs; vdevid++) {\n\t\tbrt_vdev_t *brtvd = &brt->brt_vdevs[vdevid];\n\t\tif (brtvd == NULL || !brtvd->bv_initiated)\n\t\t\tcontinue;\n\n\t\tzap_cursor_t zc;\n\t\tzap_attribute_t za;\n\t\tfor (zap_cursor_init(&zc, brt->brt_mos, brtvd->bv_mos_entries);\n\t\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t\t    zap_cursor_advance(&zc)) {\n\t\t\tuint64_t offset = *(uint64_t *)za.za_name;\n\t\t\tuint64_t refcnt = za.za_first_integer;\n\n\t\t\tsnprintf(dva, sizeof (dva), \"%\" PRIu64 \":%llx\", vdevid,\n\t\t\t    (u_longlong_t)offset);\n\t\t\tprintf(\"%-16s %-10llu\\n\", dva, (u_longlong_t)refcnt);\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\t}\n}\n\nstatic void\ndump_dtl_seg(void *arg, uint64_t start, uint64_t size)\n{\n\tchar *prefix = arg;\n\n\t(void) printf(\"%s [%llu,%llu) length %llu\\n\",\n\t    prefix,\n\t    (u_longlong_t)start,\n\t    (u_longlong_t)(start + size),\n\t    (u_longlong_t)(size));\n}\n\nstatic void\ndump_dtl(vdev_t *vd, int indent)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tboolean_t required;\n\tconst char *name[DTL_TYPES] = { \"missing\", \"partial\", \"scrub\",\n\t\t\"outage\" };\n\tchar prefix[256];\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\trequired = vdev_dtl_required(vd);\n\t(void) spa_vdev_state_exit(spa, NULL, 0);\n\n\tif (indent == 0)\n\t\t(void) printf(\"\\nDirty time logs:\\n\\n\");\n\n\t(void) printf(\"\\t%*s%s [%s]\\n\", indent, \"\",\n\t    vd->vdev_path ? vd->vdev_path :\n\t    vd->vdev_parent ? vd->vdev_ops->vdev_op_type : spa_name(spa),\n\t    required ? \"DTL-required\" : \"DTL-expendable\");\n\n\tfor (int t = 0; t < DTL_TYPES; t++) {\n\t\trange_tree_t *rt = vd->vdev_dtl[t];\n\t\tif (range_tree_space(rt) == 0)\n\t\t\tcontinue;\n\t\t(void) snprintf(prefix, sizeof (prefix), \"\\t%*s%s\",\n\t\t    indent + 2, \"\", name[t]);\n\t\trange_tree_walk(rt, dump_dtl_seg, prefix);\n\t\tif (dump_opt['d'] > 5 && vd->vdev_children == 0)\n\t\t\tdump_spacemap(spa->spa_meta_objset,\n\t\t\t    vd->vdev_dtl_sm);\n\t}\n\n\tfor (unsigned c = 0; c < vd->vdev_children; c++)\n\t\tdump_dtl(vd->vdev_child[c], indent + 4);\n}\n\nstatic void\ndump_history(spa_t *spa)\n{\n\tnvlist_t **events = NULL;\n\tchar *buf;\n\tuint64_t resid, len, off = 0;\n\tuint_t num = 0;\n\tint error;\n\tchar tbuf[30];\n\n\tif ((buf = malloc(SPA_OLD_MAXBLOCKSIZE)) == NULL) {\n\t\t(void) fprintf(stderr, \"%s: unable to allocate I/O buffer\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tlen = SPA_OLD_MAXBLOCKSIZE;\n\n\t\tif ((error = spa_history_get(spa, &off, &len, buf)) != 0) {\n\t\t\t(void) fprintf(stderr, \"Unable to read history: \"\n\t\t\t    \"error %d\\n\", error);\n\t\t\tfree(buf);\n\t\t\treturn;\n\t\t}\n\n\t\tif (zpool_history_unpack(buf, len, &resid, &events, &num) != 0)\n\t\t\tbreak;\n\n\t\toff -= resid;\n\t} while (len != 0);\n\n\t(void) printf(\"\\nHistory:\\n\");\n\tfor (unsigned i = 0; i < num; i++) {\n\t\tboolean_t printed = B_FALSE;\n\n\t\tif (nvlist_exists(events[i], ZPOOL_HIST_TIME)) {\n\t\t\ttime_t tsec;\n\t\t\tstruct tm t;\n\n\t\t\ttsec = fnvlist_lookup_uint64(events[i],\n\t\t\t    ZPOOL_HIST_TIME);\n\t\t\t(void) localtime_r(&tsec, &t);\n\t\t\t(void) strftime(tbuf, sizeof (tbuf), \"%F.%T\", &t);\n\t\t} else {\n\t\t\ttbuf[0] = '\\0';\n\t\t}\n\n\t\tif (nvlist_exists(events[i], ZPOOL_HIST_CMD)) {\n\t\t\t(void) printf(\"%s %s\\n\", tbuf,\n\t\t\t    fnvlist_lookup_string(events[i], ZPOOL_HIST_CMD));\n\t\t} else if (nvlist_exists(events[i], ZPOOL_HIST_INT_EVENT)) {\n\t\t\tuint64_t ievent;\n\n\t\t\tievent = fnvlist_lookup_uint64(events[i],\n\t\t\t    ZPOOL_HIST_INT_EVENT);\n\t\t\tif (ievent >= ZFS_NUM_LEGACY_HISTORY_EVENTS)\n\t\t\t\tgoto next;\n\n\t\t\t(void) printf(\" %s [internal %s txg:%ju] %s\\n\",\n\t\t\t    tbuf,\n\t\t\t    zfs_history_event_names[ievent],\n\t\t\t    fnvlist_lookup_uint64(events[i],\n\t\t\t    ZPOOL_HIST_TXG),\n\t\t\t    fnvlist_lookup_string(events[i],\n\t\t\t    ZPOOL_HIST_INT_STR));\n\t\t} else if (nvlist_exists(events[i], ZPOOL_HIST_INT_NAME)) {\n\t\t\t(void) printf(\"%s [txg:%ju] %s\", tbuf,\n\t\t\t    fnvlist_lookup_uint64(events[i],\n\t\t\t    ZPOOL_HIST_TXG),\n\t\t\t    fnvlist_lookup_string(events[i],\n\t\t\t    ZPOOL_HIST_INT_NAME));\n\n\t\t\tif (nvlist_exists(events[i], ZPOOL_HIST_DSNAME)) {\n\t\t\t\t(void) printf(\" %s (%llu)\",\n\t\t\t\t    fnvlist_lookup_string(events[i],\n\t\t\t\t    ZPOOL_HIST_DSNAME),\n\t\t\t\t    (u_longlong_t)fnvlist_lookup_uint64(\n\t\t\t\t    events[i],\n\t\t\t\t    ZPOOL_HIST_DSID));\n\t\t\t}\n\n\t\t\t(void) printf(\" %s\\n\", fnvlist_lookup_string(events[i],\n\t\t\t    ZPOOL_HIST_INT_STR));\n\t\t} else if (nvlist_exists(events[i], ZPOOL_HIST_IOCTL)) {\n\t\t\t(void) printf(\"%s ioctl %s\\n\", tbuf,\n\t\t\t    fnvlist_lookup_string(events[i],\n\t\t\t    ZPOOL_HIST_IOCTL));\n\n\t\t\tif (nvlist_exists(events[i], ZPOOL_HIST_INPUT_NVL)) {\n\t\t\t\t(void) printf(\"    input:\\n\");\n\t\t\t\tdump_nvlist(fnvlist_lookup_nvlist(events[i],\n\t\t\t\t    ZPOOL_HIST_INPUT_NVL), 8);\n\t\t\t}\n\t\t\tif (nvlist_exists(events[i], ZPOOL_HIST_OUTPUT_NVL)) {\n\t\t\t\t(void) printf(\"    output:\\n\");\n\t\t\t\tdump_nvlist(fnvlist_lookup_nvlist(events[i],\n\t\t\t\t    ZPOOL_HIST_OUTPUT_NVL), 8);\n\t\t\t}\n\t\t\tif (nvlist_exists(events[i], ZPOOL_HIST_ERRNO)) {\n\t\t\t\t(void) printf(\"    errno: %lld\\n\",\n\t\t\t\t    (longlong_t)fnvlist_lookup_int64(events[i],\n\t\t\t\t    ZPOOL_HIST_ERRNO));\n\t\t\t}\n\t\t} else {\n\t\t\tgoto next;\n\t\t}\n\n\t\tprinted = B_TRUE;\nnext:\n\t\tif (dump_opt['h'] > 1) {\n\t\t\tif (!printed)\n\t\t\t\t(void) printf(\"unrecognized record:\\n\");\n\t\t\tdump_nvlist(events[i], 2);\n\t\t}\n\t}\n\tfree(buf);\n}\n\nstatic void\ndump_dnode(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) data, (void) size;\n}\n\nstatic uint64_t\nblkid2offset(const dnode_phys_t *dnp, const blkptr_t *bp,\n    const zbookmark_phys_t *zb)\n{\n\tif (dnp == NULL) {\n\t\tASSERT(zb->zb_level < 0);\n\t\tif (zb->zb_object == 0)\n\t\t\treturn (zb->zb_blkid);\n\t\treturn (zb->zb_blkid * BP_GET_LSIZE(bp));\n\t}\n\n\tASSERT(zb->zb_level >= 0);\n\n\treturn ((zb->zb_blkid <<\n\t    (zb->zb_level * (dnp->dn_indblkshift - SPA_BLKPTRSHIFT))) *\n\t    dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT);\n}\n\nstatic void\nsnprintf_zstd_header(spa_t *spa, char *blkbuf, size_t buflen,\n    const blkptr_t *bp)\n{\n\tabd_t *pabd;\n\tvoid *buf;\n\tzio_t *zio;\n\tzfs_zstdhdr_t zstd_hdr;\n\tint error;\n\n\tif (BP_GET_COMPRESS(bp) != ZIO_COMPRESS_ZSTD)\n\t\treturn;\n\n\tif (BP_IS_HOLE(bp))\n\t\treturn;\n\n\tif (BP_IS_EMBEDDED(bp)) {\n\t\tbuf = malloc(SPA_MAXBLOCKSIZE);\n\t\tif (buf == NULL) {\n\t\t\t(void) fprintf(stderr, \"out of memory\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tdecode_embedded_bp_compressed(bp, buf);\n\t\tmemcpy(&zstd_hdr, buf, sizeof (zstd_hdr));\n\t\tfree(buf);\n\t\tzstd_hdr.c_len = BE_32(zstd_hdr.c_len);\n\t\tzstd_hdr.raw_version_level = BE_32(zstd_hdr.raw_version_level);\n\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t    buflen - strlen(blkbuf),\n\t\t    \" ZSTD:size=%u:version=%u:level=%u:EMBEDDED\",\n\t\t    zstd_hdr.c_len, zfs_get_hdrversion(&zstd_hdr),\n\t\t    zfs_get_hdrlevel(&zstd_hdr));\n\t\treturn;\n\t}\n\n\tpabd = abd_alloc_for_io(SPA_MAXBLOCKSIZE, B_FALSE);\n\tzio = zio_root(spa, NULL, NULL, 0);\n\n\t \n\tzio_nowait(zio_read(zio, spa, bp, pabd, BP_GET_PSIZE(bp), NULL, NULL,\n\t    ZIO_PRIORITY_SYNC_READ, ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW_COMPRESS,\n\t    NULL));\n\terror = zio_wait(zio);\n\tif (error) {\n\t\t(void) fprintf(stderr, \"read failed: %d\\n\", error);\n\t\treturn;\n\t}\n\tbuf = abd_borrow_buf_copy(pabd, BP_GET_LSIZE(bp));\n\tmemcpy(&zstd_hdr, buf, sizeof (zstd_hdr));\n\tzstd_hdr.c_len = BE_32(zstd_hdr.c_len);\n\tzstd_hdr.raw_version_level = BE_32(zstd_hdr.raw_version_level);\n\n\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t    buflen - strlen(blkbuf),\n\t    \" ZSTD:size=%u:version=%u:level=%u:NORMAL\",\n\t    zstd_hdr.c_len, zfs_get_hdrversion(&zstd_hdr),\n\t    zfs_get_hdrlevel(&zstd_hdr));\n\n\tabd_return_buf_copy(pabd, buf, BP_GET_LSIZE(bp));\n}\n\nstatic void\nsnprintf_blkptr_compact(char *blkbuf, size_t buflen, const blkptr_t *bp,\n    boolean_t bp_freed)\n{\n\tconst dva_t *dva = bp->blk_dva;\n\tint ndvas = dump_opt['d'] > 5 ? BP_GET_NDVAS(bp) : 1;\n\tint i;\n\n\tif (dump_opt['b'] >= 6) {\n\t\tsnprintf_blkptr(blkbuf, buflen, bp);\n\t\tif (bp_freed) {\n\t\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t\t    buflen - strlen(blkbuf), \" %s\", \"FREE\");\n\t\t}\n\t\treturn;\n\t}\n\n\tif (BP_IS_EMBEDDED(bp)) {\n\t\t(void) sprintf(blkbuf,\n\t\t    \"EMBEDDED et=%u %llxL/%llxP B=%llu\",\n\t\t    (int)BPE_GET_ETYPE(bp),\n\t\t    (u_longlong_t)BPE_GET_LSIZE(bp),\n\t\t    (u_longlong_t)BPE_GET_PSIZE(bp),\n\t\t    (u_longlong_t)bp->blk_birth);\n\t\treturn;\n\t}\n\n\tblkbuf[0] = '\\0';\n\n\tfor (i = 0; i < ndvas; i++)\n\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t    buflen - strlen(blkbuf), \"%llu:%llx:%llx \",\n\t\t    (u_longlong_t)DVA_GET_VDEV(&dva[i]),\n\t\t    (u_longlong_t)DVA_GET_OFFSET(&dva[i]),\n\t\t    (u_longlong_t)DVA_GET_ASIZE(&dva[i]));\n\n\tif (BP_IS_HOLE(bp)) {\n\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t    buflen - strlen(blkbuf),\n\t\t    \"%llxL B=%llu\",\n\t\t    (u_longlong_t)BP_GET_LSIZE(bp),\n\t\t    (u_longlong_t)bp->blk_birth);\n\t} else {\n\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t    buflen - strlen(blkbuf),\n\t\t    \"%llxL/%llxP F=%llu B=%llu/%llu\",\n\t\t    (u_longlong_t)BP_GET_LSIZE(bp),\n\t\t    (u_longlong_t)BP_GET_PSIZE(bp),\n\t\t    (u_longlong_t)BP_GET_FILL(bp),\n\t\t    (u_longlong_t)bp->blk_birth,\n\t\t    (u_longlong_t)BP_PHYSICAL_BIRTH(bp));\n\t\tif (bp_freed)\n\t\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t\t    buflen - strlen(blkbuf), \" %s\", \"FREE\");\n\t\t(void) snprintf(blkbuf + strlen(blkbuf),\n\t\t    buflen - strlen(blkbuf),\n\t\t    \" cksum=%016llx:%016llx:%016llx:%016llx\",\n\t\t    (u_longlong_t)bp->blk_cksum.zc_word[0],\n\t\t    (u_longlong_t)bp->blk_cksum.zc_word[1],\n\t\t    (u_longlong_t)bp->blk_cksum.zc_word[2],\n\t\t    (u_longlong_t)bp->blk_cksum.zc_word[3]);\n\t}\n}\n\nstatic void\nprint_indirect(spa_t *spa, blkptr_t *bp, const zbookmark_phys_t *zb,\n    const dnode_phys_t *dnp)\n{\n\tchar blkbuf[BP_SPRINTF_LEN];\n\tint l;\n\n\tif (!BP_IS_EMBEDDED(bp)) {\n\t\tASSERT3U(BP_GET_TYPE(bp), ==, dnp->dn_type);\n\t\tASSERT3U(BP_GET_LEVEL(bp), ==, zb->zb_level);\n\t}\n\n\t(void) printf(\"%16llx \", (u_longlong_t)blkid2offset(dnp, bp, zb));\n\n\tASSERT(zb->zb_level >= 0);\n\n\tfor (l = dnp->dn_nlevels - 1; l >= -1; l--) {\n\t\tif (l == zb->zb_level) {\n\t\t\t(void) printf(\"L%llx\", (u_longlong_t)zb->zb_level);\n\t\t} else {\n\t\t\t(void) printf(\" \");\n\t\t}\n\t}\n\n\tsnprintf_blkptr_compact(blkbuf, sizeof (blkbuf), bp, B_FALSE);\n\tif (dump_opt['Z'] && BP_GET_COMPRESS(bp) == ZIO_COMPRESS_ZSTD)\n\t\tsnprintf_zstd_header(spa, blkbuf, sizeof (blkbuf), bp);\n\t(void) printf(\"%s\\n\", blkbuf);\n}\n\nstatic int\nvisit_indirect(spa_t *spa, const dnode_phys_t *dnp,\n    blkptr_t *bp, const zbookmark_phys_t *zb)\n{\n\tint err = 0;\n\n\tif (bp->blk_birth == 0)\n\t\treturn (0);\n\n\tprint_indirect(spa, bp, zb, dnp);\n\n\tif (BP_GET_LEVEL(bp) > 0 && !BP_IS_HOLE(bp)) {\n\t\tarc_flags_t flags = ARC_FLAG_WAIT;\n\t\tint i;\n\t\tblkptr_t *cbp;\n\t\tint epb = BP_GET_LSIZE(bp) >> SPA_BLKPTRSHIFT;\n\t\tarc_buf_t *buf;\n\t\tuint64_t fill = 0;\n\t\tASSERT(!BP_IS_REDACTED(bp));\n\n\t\terr = arc_read(NULL, spa, bp, arc_getbuf_func, &buf,\n\t\t    ZIO_PRIORITY_ASYNC_READ, ZIO_FLAG_CANFAIL, &flags, zb);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tASSERT(buf->b_data);\n\n\t\t \n\t\tcbp = buf->b_data;\n\t\tfor (i = 0; i < epb; i++, cbp++) {\n\t\t\tzbookmark_phys_t czb;\n\n\t\t\tSET_BOOKMARK(&czb, zb->zb_objset, zb->zb_object,\n\t\t\t    zb->zb_level - 1,\n\t\t\t    zb->zb_blkid * epb + i);\n\t\t\terr = visit_indirect(spa, dnp, cbp, &czb);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tfill += BP_GET_FILL(cbp);\n\t\t}\n\t\tif (!err)\n\t\t\tASSERT3U(fill, ==, BP_GET_FILL(bp));\n\t\tarc_buf_destroy(buf, &buf);\n\t}\n\n\treturn (err);\n}\n\nstatic void\ndump_indirect(dnode_t *dn)\n{\n\tdnode_phys_t *dnp = dn->dn_phys;\n\tzbookmark_phys_t czb;\n\n\t(void) printf(\"Indirect blocks:\\n\");\n\n\tSET_BOOKMARK(&czb, dmu_objset_id(dn->dn_objset),\n\t    dn->dn_object, dnp->dn_nlevels - 1, 0);\n\tfor (int j = 0; j < dnp->dn_nblkptr; j++) {\n\t\tczb.zb_blkid = j;\n\t\t(void) visit_indirect(dmu_objset_spa(dn->dn_objset), dnp,\n\t\t    &dnp->dn_blkptr[j], &czb);\n\t}\n\n\t(void) printf(\"\\n\");\n}\n\nstatic void\ndump_dsl_dir(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object;\n\tdsl_dir_phys_t *dd = data;\n\ttime_t crtime;\n\tchar nice[32];\n\n\t \n\t_Static_assert(sizeof (nice) >= NN_NUMBUF_SZ, \"nice truncated\");\n\n\tif (dd == NULL)\n\t\treturn;\n\n\tASSERT3U(size, >=, sizeof (dsl_dir_phys_t));\n\n\tcrtime = dd->dd_creation_time;\n\t(void) printf(\"\\t\\tcreation_time = %s\", ctime(&crtime));\n\t(void) printf(\"\\t\\thead_dataset_obj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_head_dataset_obj);\n\t(void) printf(\"\\t\\tparent_dir_obj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_parent_obj);\n\t(void) printf(\"\\t\\torigin_obj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_origin_obj);\n\t(void) printf(\"\\t\\tchild_dir_zapobj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_child_dir_zapobj);\n\tzdb_nicenum(dd->dd_used_bytes, nice, sizeof (nice));\n\t(void) printf(\"\\t\\tused_bytes = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_compressed_bytes, nice, sizeof (nice));\n\t(void) printf(\"\\t\\tcompressed_bytes = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_uncompressed_bytes, nice, sizeof (nice));\n\t(void) printf(\"\\t\\tuncompressed_bytes = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_quota, nice, sizeof (nice));\n\t(void) printf(\"\\t\\tquota = %s\\n\", nice);\n\tzdb_nicenum(dd->dd_reserved, nice, sizeof (nice));\n\t(void) printf(\"\\t\\treserved = %s\\n\", nice);\n\t(void) printf(\"\\t\\tprops_zapobj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_props_zapobj);\n\t(void) printf(\"\\t\\tdeleg_zapobj = %llu\\n\",\n\t    (u_longlong_t)dd->dd_deleg_zapobj);\n\t(void) printf(\"\\t\\tflags = %llx\\n\",\n\t    (u_longlong_t)dd->dd_flags);\n\n#define\tDO(which) \\\n\tzdb_nicenum(dd->dd_used_breakdown[DD_USED_ ## which], nice, \\\n\t    sizeof (nice)); \\\n\t(void) printf(\"\\t\\tused_breakdown[\" #which \"] = %s\\n\", nice)\n\tDO(HEAD);\n\tDO(SNAP);\n\tDO(CHILD);\n\tDO(CHILD_RSRV);\n\tDO(REFRSRV);\n#undef DO\n\t(void) printf(\"\\t\\tclones = %llu\\n\",\n\t    (u_longlong_t)dd->dd_clones);\n}\n\nstatic void\ndump_dsl_dataset(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object;\n\tdsl_dataset_phys_t *ds = data;\n\ttime_t crtime;\n\tchar used[32], compressed[32], uncompressed[32], unique[32];\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\t \n\t_Static_assert(sizeof (used) >= NN_NUMBUF_SZ, \"used truncated\");\n\t_Static_assert(sizeof (compressed) >= NN_NUMBUF_SZ,\n\t    \"compressed truncated\");\n\t_Static_assert(sizeof (uncompressed) >= NN_NUMBUF_SZ,\n\t    \"uncompressed truncated\");\n\t_Static_assert(sizeof (unique) >= NN_NUMBUF_SZ, \"unique truncated\");\n\n\tif (ds == NULL)\n\t\treturn;\n\n\tASSERT(size == sizeof (*ds));\n\tcrtime = ds->ds_creation_time;\n\tzdb_nicenum(ds->ds_referenced_bytes, used, sizeof (used));\n\tzdb_nicenum(ds->ds_compressed_bytes, compressed, sizeof (compressed));\n\tzdb_nicenum(ds->ds_uncompressed_bytes, uncompressed,\n\t    sizeof (uncompressed));\n\tzdb_nicenum(ds->ds_unique_bytes, unique, sizeof (unique));\n\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), &ds->ds_bp);\n\n\t(void) printf(\"\\t\\tdir_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_dir_obj);\n\t(void) printf(\"\\t\\tprev_snap_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_prev_snap_obj);\n\t(void) printf(\"\\t\\tprev_snap_txg = %llu\\n\",\n\t    (u_longlong_t)ds->ds_prev_snap_txg);\n\t(void) printf(\"\\t\\tnext_snap_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_next_snap_obj);\n\t(void) printf(\"\\t\\tsnapnames_zapobj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_snapnames_zapobj);\n\t(void) printf(\"\\t\\tnum_children = %llu\\n\",\n\t    (u_longlong_t)ds->ds_num_children);\n\t(void) printf(\"\\t\\tuserrefs_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_userrefs_obj);\n\t(void) printf(\"\\t\\tcreation_time = %s\", ctime(&crtime));\n\t(void) printf(\"\\t\\tcreation_txg = %llu\\n\",\n\t    (u_longlong_t)ds->ds_creation_txg);\n\t(void) printf(\"\\t\\tdeadlist_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_deadlist_obj);\n\t(void) printf(\"\\t\\tused_bytes = %s\\n\", used);\n\t(void) printf(\"\\t\\tcompressed_bytes = %s\\n\", compressed);\n\t(void) printf(\"\\t\\tuncompressed_bytes = %s\\n\", uncompressed);\n\t(void) printf(\"\\t\\tunique = %s\\n\", unique);\n\t(void) printf(\"\\t\\tfsid_guid = %llu\\n\",\n\t    (u_longlong_t)ds->ds_fsid_guid);\n\t(void) printf(\"\\t\\tguid = %llu\\n\",\n\t    (u_longlong_t)ds->ds_guid);\n\t(void) printf(\"\\t\\tflags = %llx\\n\",\n\t    (u_longlong_t)ds->ds_flags);\n\t(void) printf(\"\\t\\tnext_clones_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_next_clones_obj);\n\t(void) printf(\"\\t\\tprops_obj = %llu\\n\",\n\t    (u_longlong_t)ds->ds_props_obj);\n\t(void) printf(\"\\t\\tbp = %s\\n\", blkbuf);\n}\n\nstatic int\ndump_bptree_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\t(void) arg, (void) tx;\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\tif (bp->blk_birth != 0) {\n\t\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), bp);\n\t\t(void) printf(\"\\t%s\\n\", blkbuf);\n\t}\n\treturn (0);\n}\n\nstatic void\ndump_bptree(objset_t *os, uint64_t obj, const char *name)\n{\n\tchar bytes[32];\n\tbptree_phys_t *bt;\n\tdmu_buf_t *db;\n\n\t \n\t_Static_assert(sizeof (bytes) >= NN_NUMBUF_SZ, \"bytes truncated\");\n\n\tif (dump_opt['d'] < 3)\n\t\treturn;\n\n\tVERIFY3U(0, ==, dmu_bonus_hold(os, obj, FTAG, &db));\n\tbt = db->db_data;\n\tzdb_nicenum(bt->bt_bytes, bytes, sizeof (bytes));\n\t(void) printf(\"\\n    %s: %llu datasets, %s\\n\",\n\t    name, (unsigned long long)(bt->bt_end - bt->bt_begin), bytes);\n\tdmu_buf_rele(db, FTAG);\n\n\tif (dump_opt['d'] < 5)\n\t\treturn;\n\n\t(void) printf(\"\\n\");\n\n\t(void) bptree_iterate(os, obj, B_FALSE, dump_bptree_cb, NULL, NULL);\n}\n\nstatic int\ndump_bpobj_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed, dmu_tx_t *tx)\n{\n\t(void) arg, (void) tx;\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\tASSERT(bp->blk_birth != 0);\n\tsnprintf_blkptr_compact(blkbuf, sizeof (blkbuf), bp, bp_freed);\n\t(void) printf(\"\\t%s\\n\", blkbuf);\n\treturn (0);\n}\n\nstatic void\ndump_full_bpobj(bpobj_t *bpo, const char *name, int indent)\n{\n\tchar bytes[32];\n\tchar comp[32];\n\tchar uncomp[32];\n\tuint64_t i;\n\n\t \n\t_Static_assert(sizeof (bytes) >= NN_NUMBUF_SZ, \"bytes truncated\");\n\t_Static_assert(sizeof (comp) >= NN_NUMBUF_SZ, \"comp truncated\");\n\t_Static_assert(sizeof (uncomp) >= NN_NUMBUF_SZ, \"uncomp truncated\");\n\n\tif (dump_opt['d'] < 3)\n\t\treturn;\n\n\tzdb_nicenum(bpo->bpo_phys->bpo_bytes, bytes, sizeof (bytes));\n\tif (bpo->bpo_havesubobj && bpo->bpo_phys->bpo_subobjs != 0) {\n\t\tzdb_nicenum(bpo->bpo_phys->bpo_comp, comp, sizeof (comp));\n\t\tzdb_nicenum(bpo->bpo_phys->bpo_uncomp, uncomp, sizeof (uncomp));\n\t\tif (bpo->bpo_havefreed) {\n\t\t\t(void) printf(\"    %*s: object %llu, %llu local \"\n\t\t\t    \"blkptrs, %llu freed, %llu subobjs in object %llu, \"\n\t\t\t    \"%s (%s/%s comp)\\n\",\n\t\t\t    indent * 8, name,\n\t\t\t    (u_longlong_t)bpo->bpo_object,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_blkptrs,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_freed,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_subobjs,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_subobjs,\n\t\t\t    bytes, comp, uncomp);\n\t\t} else {\n\t\t\t(void) printf(\"    %*s: object %llu, %llu local \"\n\t\t\t    \"blkptrs, %llu subobjs in object %llu, \"\n\t\t\t    \"%s (%s/%s comp)\\n\",\n\t\t\t    indent * 8, name,\n\t\t\t    (u_longlong_t)bpo->bpo_object,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_blkptrs,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_subobjs,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_subobjs,\n\t\t\t    bytes, comp, uncomp);\n\t\t}\n\n\t\tfor (i = 0; i < bpo->bpo_phys->bpo_num_subobjs; i++) {\n\t\t\tuint64_t subobj;\n\t\t\tbpobj_t subbpo;\n\t\t\tint error;\n\t\t\tVERIFY0(dmu_read(bpo->bpo_os,\n\t\t\t    bpo->bpo_phys->bpo_subobjs,\n\t\t\t    i * sizeof (subobj), sizeof (subobj), &subobj, 0));\n\t\t\terror = bpobj_open(&subbpo, bpo->bpo_os, subobj);\n\t\t\tif (error != 0) {\n\t\t\t\t(void) printf(\"ERROR %u while trying to open \"\n\t\t\t\t    \"subobj id %llu\\n\",\n\t\t\t\t    error, (u_longlong_t)subobj);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdump_full_bpobj(&subbpo, \"subobj\", indent + 1);\n\t\t\tbpobj_close(&subbpo);\n\t\t}\n\t} else {\n\t\tif (bpo->bpo_havefreed) {\n\t\t\t(void) printf(\"    %*s: object %llu, %llu blkptrs, \"\n\t\t\t    \"%llu freed, %s\\n\",\n\t\t\t    indent * 8, name,\n\t\t\t    (u_longlong_t)bpo->bpo_object,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_blkptrs,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_freed,\n\t\t\t    bytes);\n\t\t} else {\n\t\t\t(void) printf(\"    %*s: object %llu, %llu blkptrs, \"\n\t\t\t    \"%s\\n\",\n\t\t\t    indent * 8, name,\n\t\t\t    (u_longlong_t)bpo->bpo_object,\n\t\t\t    (u_longlong_t)bpo->bpo_phys->bpo_num_blkptrs,\n\t\t\t    bytes);\n\t\t}\n\t}\n\n\tif (dump_opt['d'] < 5)\n\t\treturn;\n\n\n\tif (indent == 0) {\n\t\t(void) bpobj_iterate_nofree(bpo, dump_bpobj_cb, NULL, NULL);\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\nstatic int\ndump_bookmark(dsl_pool_t *dp, char *name, boolean_t print_redact,\n    boolean_t print_list)\n{\n\tint err = 0;\n\tzfs_bookmark_phys_t prop;\n\tobjset_t *mos = dp->dp_spa->spa_meta_objset;\n\terr = dsl_bookmark_lookup(dp, name, NULL, &prop);\n\n\tif (err != 0) {\n\t\treturn (err);\n\t}\n\n\t(void) printf(\"\\t#%s: \", strchr(name, '#') + 1);\n\t(void) printf(\"{guid: %llx creation_txg: %llu creation_time: \"\n\t    \"%llu redaction_obj: %llu}\\n\", (u_longlong_t)prop.zbm_guid,\n\t    (u_longlong_t)prop.zbm_creation_txg,\n\t    (u_longlong_t)prop.zbm_creation_time,\n\t    (u_longlong_t)prop.zbm_redaction_obj);\n\n\tIMPLY(print_list, print_redact);\n\tif (!print_redact || prop.zbm_redaction_obj == 0)\n\t\treturn (0);\n\n\tredaction_list_t *rl;\n\tVERIFY0(dsl_redaction_list_hold_obj(dp,\n\t    prop.zbm_redaction_obj, FTAG, &rl));\n\n\tredaction_list_phys_t *rlp = rl->rl_phys;\n\t(void) printf(\"\\tRedacted:\\n\\t\\tProgress: \");\n\tif (rlp->rlp_last_object != UINT64_MAX ||\n\t    rlp->rlp_last_blkid != UINT64_MAX) {\n\t\t(void) printf(\"%llu %llu (incomplete)\\n\",\n\t\t    (u_longlong_t)rlp->rlp_last_object,\n\t\t    (u_longlong_t)rlp->rlp_last_blkid);\n\t} else {\n\t\t(void) printf(\"complete\\n\");\n\t}\n\t(void) printf(\"\\t\\tSnapshots: [\");\n\tfor (unsigned int i = 0; i < rlp->rlp_num_snaps; i++) {\n\t\tif (i > 0)\n\t\t\t(void) printf(\", \");\n\t\t(void) printf(\"%0llu\",\n\t\t    (u_longlong_t)rlp->rlp_snaps[i]);\n\t}\n\t(void) printf(\"]\\n\\t\\tLength: %llu\\n\",\n\t    (u_longlong_t)rlp->rlp_num_entries);\n\n\tif (!print_list) {\n\t\tdsl_redaction_list_rele(rl, FTAG);\n\t\treturn (0);\n\t}\n\n\tif (rlp->rlp_num_entries == 0) {\n\t\tdsl_redaction_list_rele(rl, FTAG);\n\t\t(void) printf(\"\\t\\tRedaction List: []\\n\\n\");\n\t\treturn (0);\n\t}\n\n\tredact_block_phys_t *rbp_buf;\n\tuint64_t size;\n\tdmu_object_info_t doi;\n\n\tVERIFY0(dmu_object_info(mos, prop.zbm_redaction_obj, &doi));\n\tsize = doi.doi_max_offset;\n\trbp_buf = kmem_alloc(size, KM_SLEEP);\n\n\terr = dmu_read(mos, prop.zbm_redaction_obj, 0, size,\n\t    rbp_buf, 0);\n\tif (err != 0) {\n\t\tdsl_redaction_list_rele(rl, FTAG);\n\t\tkmem_free(rbp_buf, size);\n\t\treturn (err);\n\t}\n\n\t(void) printf(\"\\t\\tRedaction List: [{object: %llx, offset: \"\n\t    \"%llx, blksz: %x, count: %llx}\",\n\t    (u_longlong_t)rbp_buf[0].rbp_object,\n\t    (u_longlong_t)rbp_buf[0].rbp_blkid,\n\t    (uint_t)(redact_block_get_size(&rbp_buf[0])),\n\t    (u_longlong_t)redact_block_get_count(&rbp_buf[0]));\n\n\tfor (size_t i = 1; i < rlp->rlp_num_entries; i++) {\n\t\t(void) printf(\",\\n\\t\\t{object: %llx, offset: %llx, \"\n\t\t    \"blksz: %x, count: %llx}\",\n\t\t    (u_longlong_t)rbp_buf[i].rbp_object,\n\t\t    (u_longlong_t)rbp_buf[i].rbp_blkid,\n\t\t    (uint_t)(redact_block_get_size(&rbp_buf[i])),\n\t\t    (u_longlong_t)redact_block_get_count(&rbp_buf[i]));\n\t}\n\tdsl_redaction_list_rele(rl, FTAG);\n\tkmem_free(rbp_buf, size);\n\t(void) printf(\"]\\n\\n\");\n\treturn (0);\n}\n\nstatic void\ndump_bookmarks(objset_t *os, int verbosity)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tdsl_dataset_t *ds = dmu_objset_ds(os);\n\tdsl_pool_t *dp = spa_get_dsl(os->os_spa);\n\tobjset_t *mos = os->os_spa->spa_meta_objset;\n\tif (verbosity < 4)\n\t\treturn;\n\tdsl_pool_config_enter(dp, FTAG);\n\n\tfor (zap_cursor_init(&zc, mos, ds->ds_bookmarks_obj);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tchar osname[ZFS_MAX_DATASET_NAME_LEN];\n\t\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\t\tint len;\n\t\tdmu_objset_name(os, osname);\n\t\tlen = snprintf(buf, sizeof (buf), \"%s#%s\", osname,\n\t\t    attr.za_name);\n\t\tVERIFY3S(len, <, ZFS_MAX_DATASET_NAME_LEN);\n\t\t(void) dump_bookmark(dp, buf, verbosity >= 5, verbosity >= 6);\n\t}\n\tzap_cursor_fini(&zc);\n\tdsl_pool_config_exit(dp, FTAG);\n}\n\nstatic void\nbpobj_count_refd(bpobj_t *bpo)\n{\n\tmos_obj_refd(bpo->bpo_object);\n\n\tif (bpo->bpo_havesubobj && bpo->bpo_phys->bpo_subobjs != 0) {\n\t\tmos_obj_refd(bpo->bpo_phys->bpo_subobjs);\n\t\tfor (uint64_t i = 0; i < bpo->bpo_phys->bpo_num_subobjs; i++) {\n\t\t\tuint64_t subobj;\n\t\t\tbpobj_t subbpo;\n\t\t\tint error;\n\t\t\tVERIFY0(dmu_read(bpo->bpo_os,\n\t\t\t    bpo->bpo_phys->bpo_subobjs,\n\t\t\t    i * sizeof (subobj), sizeof (subobj), &subobj, 0));\n\t\t\terror = bpobj_open(&subbpo, bpo->bpo_os, subobj);\n\t\t\tif (error != 0) {\n\t\t\t\t(void) printf(\"ERROR %u while trying to open \"\n\t\t\t\t    \"subobj id %llu\\n\",\n\t\t\t\t    error, (u_longlong_t)subobj);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbpobj_count_refd(&subbpo);\n\t\t\tbpobj_close(&subbpo);\n\t\t}\n\t}\n}\n\nstatic int\ndsl_deadlist_entry_count_refd(void *arg, dsl_deadlist_entry_t *dle)\n{\n\tspa_t *spa = arg;\n\tuint64_t empty_bpobj = spa->spa_dsl_pool->dp_empty_bpobj;\n\tif (dle->dle_bpobj.bpo_object != empty_bpobj)\n\t\tbpobj_count_refd(&dle->dle_bpobj);\n\treturn (0);\n}\n\nstatic int\ndsl_deadlist_entry_dump(void *arg, dsl_deadlist_entry_t *dle)\n{\n\tASSERT(arg == NULL);\n\tif (dump_opt['d'] >= 5) {\n\t\tchar buf[128];\n\t\t(void) snprintf(buf, sizeof (buf),\n\t\t    \"mintxg %llu -> obj %llu\",\n\t\t    (longlong_t)dle->dle_mintxg,\n\t\t    (longlong_t)dle->dle_bpobj.bpo_object);\n\n\t\tdump_full_bpobj(&dle->dle_bpobj, buf, 0);\n\t} else {\n\t\t(void) printf(\"mintxg %llu -> obj %llu\\n\",\n\t\t    (longlong_t)dle->dle_mintxg,\n\t\t    (longlong_t)dle->dle_bpobj.bpo_object);\n\t}\n\treturn (0);\n}\n\nstatic void\ndump_blkptr_list(dsl_deadlist_t *dl, const char *name)\n{\n\tchar bytes[32];\n\tchar comp[32];\n\tchar uncomp[32];\n\tchar entries[32];\n\tspa_t *spa = dmu_objset_spa(dl->dl_os);\n\tuint64_t empty_bpobj = spa->spa_dsl_pool->dp_empty_bpobj;\n\n\tif (dl->dl_oldfmt) {\n\t\tif (dl->dl_bpobj.bpo_object != empty_bpobj)\n\t\t\tbpobj_count_refd(&dl->dl_bpobj);\n\t} else {\n\t\tmos_obj_refd(dl->dl_object);\n\t\tdsl_deadlist_iterate(dl, dsl_deadlist_entry_count_refd, spa);\n\t}\n\n\t \n\t_Static_assert(sizeof (bytes) >= NN_NUMBUF_SZ, \"bytes truncated\");\n\t_Static_assert(sizeof (comp) >= NN_NUMBUF_SZ, \"comp truncated\");\n\t_Static_assert(sizeof (uncomp) >= NN_NUMBUF_SZ, \"uncomp truncated\");\n\t_Static_assert(sizeof (entries) >= NN_NUMBUF_SZ, \"entries truncated\");\n\n\tif (dump_opt['d'] < 3)\n\t\treturn;\n\n\tif (dl->dl_oldfmt) {\n\t\tdump_full_bpobj(&dl->dl_bpobj, \"old-format deadlist\", 0);\n\t\treturn;\n\t}\n\n\tzdb_nicenum(dl->dl_phys->dl_used, bytes, sizeof (bytes));\n\tzdb_nicenum(dl->dl_phys->dl_comp, comp, sizeof (comp));\n\tzdb_nicenum(dl->dl_phys->dl_uncomp, uncomp, sizeof (uncomp));\n\tzdb_nicenum(avl_numnodes(&dl->dl_tree), entries, sizeof (entries));\n\t(void) printf(\"\\n    %s: %s (%s/%s comp), %s entries\\n\",\n\t    name, bytes, comp, uncomp, entries);\n\n\tif (dump_opt['d'] < 4)\n\t\treturn;\n\n\t(void) putchar('\\n');\n\n\tdsl_deadlist_iterate(dl, dsl_deadlist_entry_dump, NULL);\n}\n\nstatic int\nverify_dd_livelist(objset_t *os)\n{\n\tuint64_t ll_used, used, ll_comp, comp, ll_uncomp, uncomp;\n\tdsl_pool_t *dp = spa_get_dsl(os->os_spa);\n\tdsl_dir_t  *dd = os->os_dsl_dataset->ds_dir;\n\n\tASSERT(!dmu_objset_is_snapshot(os));\n\tif (!dsl_deadlist_is_open(&dd->dd_livelist))\n\t\treturn (0);\n\n\t \n\tdsl_deadlist_iterate(&dd->dd_livelist, sublivelist_verify_lightweight,\n\t    NULL);\n\n\tdsl_pool_config_enter(dp, FTAG);\n\tdsl_deadlist_space(&dd->dd_livelist, &ll_used,\n\t    &ll_comp, &ll_uncomp);\n\n\tdsl_dataset_t *origin_ds;\n\tASSERT(dsl_pool_config_held(dp));\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(dd)->dd_origin_obj, FTAG, &origin_ds));\n\tVERIFY0(dsl_dataset_space_written(origin_ds, os->os_dsl_dataset,\n\t    &used, &comp, &uncomp));\n\tdsl_dataset_rele(origin_ds, FTAG);\n\tdsl_pool_config_exit(dp, FTAG);\n\t \n\tif (used != ll_used || comp != ll_comp || uncomp < ll_uncomp) {\n\t\tchar nice_used[32], nice_comp[32], nice_uncomp[32];\n\t\t(void) printf(\"Discrepancy in space accounting:\\n\");\n\t\tzdb_nicenum(used, nice_used, sizeof (nice_used));\n\t\tzdb_nicenum(comp, nice_comp, sizeof (nice_comp));\n\t\tzdb_nicenum(uncomp, nice_uncomp, sizeof (nice_uncomp));\n\t\t(void) printf(\"dir: used %s, comp %s, uncomp %s\\n\",\n\t\t    nice_used, nice_comp, nice_uncomp);\n\t\tzdb_nicenum(ll_used, nice_used, sizeof (nice_used));\n\t\tzdb_nicenum(ll_comp, nice_comp, sizeof (nice_comp));\n\t\tzdb_nicenum(ll_uncomp, nice_uncomp, sizeof (nice_uncomp));\n\t\t(void) printf(\"livelist: used %s, comp %s, uncomp %s\\n\",\n\t\t    nice_used, nice_comp, nice_uncomp);\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nstatic char *key_material = NULL;\n\nstatic boolean_t\nzdb_derive_key(dsl_dir_t *dd, uint8_t *key_out)\n{\n\tuint64_t keyformat, salt, iters;\n\tint i;\n\tunsigned char c;\n\n\tVERIFY0(zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), sizeof (uint64_t),\n\t    1, &keyformat));\n\n\tswitch (keyformat) {\n\tcase ZFS_KEYFORMAT_HEX:\n\t\tfor (i = 0; i < WRAPPING_KEY_LEN * 2; i += 2) {\n\t\t\tif (!isxdigit(key_material[i]) ||\n\t\t\t    !isxdigit(key_material[i+1]))\n\t\t\t\treturn (B_FALSE);\n\t\t\tif (sscanf(&key_material[i], \"%02hhx\", &c) != 1)\n\t\t\t\treturn (B_FALSE);\n\t\t\tkey_out[i / 2] = c;\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_KEYFORMAT_PASSPHRASE:\n\t\tVERIFY0(zap_lookup(dd->dd_pool->dp_meta_objset,\n\t\t    dd->dd_crypto_obj, zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT),\n\t\t    sizeof (uint64_t), 1, &salt));\n\t\tVERIFY0(zap_lookup(dd->dd_pool->dp_meta_objset,\n\t\t    dd->dd_crypto_obj, zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS),\n\t\t    sizeof (uint64_t), 1, &iters));\n\n\t\tif (PKCS5_PBKDF2_HMAC_SHA1(key_material, strlen(key_material),\n\t\t    ((uint8_t *)&salt), sizeof (uint64_t), iters,\n\t\t    WRAPPING_KEY_LEN, key_out) != 1)\n\t\t\treturn (B_FALSE);\n\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"no support for key format %u\\n\",\n\t\t    (unsigned int) keyformat);\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic char encroot[ZFS_MAX_DATASET_NAME_LEN];\nstatic boolean_t key_loaded = B_FALSE;\n\nstatic void\nzdb_load_key(objset_t *os)\n{\n\tdsl_pool_t *dp;\n\tdsl_dir_t *dd, *rdd;\n\tuint8_t key[WRAPPING_KEY_LEN];\n\tuint64_t rddobj;\n\tint err;\n\n\tdp = spa_get_dsl(os->os_spa);\n\tdd = os->os_dsl_dataset->ds_dir;\n\n\tdsl_pool_config_enter(dp, FTAG);\n\tVERIFY0(zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    DSL_CRYPTO_KEY_ROOT_DDOBJ, sizeof (uint64_t), 1, &rddobj));\n\tVERIFY0(dsl_dir_hold_obj(dd->dd_pool, rddobj, NULL, FTAG, &rdd));\n\tdsl_dir_name(rdd, encroot);\n\tdsl_dir_rele(rdd, FTAG);\n\n\tif (!zdb_derive_key(dd, key))\n\t\tfatal(\"couldn't derive encryption key\");\n\n\tdsl_pool_config_exit(dp, FTAG);\n\n\tASSERT3U(dsl_dataset_get_keystatus(dd), ==, ZFS_KEYSTATUS_UNAVAILABLE);\n\n\tdsl_crypto_params_t *dcp;\n\tnvlist_t *crypto_args;\n\n\tcrypto_args = fnvlist_alloc();\n\tfnvlist_add_uint8_array(crypto_args, \"wkeydata\",\n\t    (uint8_t *)key, WRAPPING_KEY_LEN);\n\tVERIFY0(dsl_crypto_params_create_nvlist(DCP_CMD_NONE,\n\t    NULL, crypto_args, &dcp));\n\terr = spa_keystore_load_wkey(encroot, dcp, B_FALSE);\n\n\tdsl_crypto_params_free(dcp, (err != 0));\n\tfnvlist_free(crypto_args);\n\n\tif (err != 0)\n\t\tfatal(\n\t\t    \"couldn't load encryption key for %s: %s\",\n\t\t    encroot, err == ZFS_ERR_CRYPTO_NOTSUP ?\n\t\t    \"crypto params not supported\" : strerror(err));\n\n\tASSERT3U(dsl_dataset_get_keystatus(dd), ==, ZFS_KEYSTATUS_AVAILABLE);\n\n\tprintf(\"Unlocked encryption root: %s\\n\", encroot);\n\tkey_loaded = B_TRUE;\n}\n\nstatic void\nzdb_unload_key(void)\n{\n\tif (!key_loaded)\n\t\treturn;\n\n\tVERIFY0(spa_keystore_unload_wkey(encroot));\n\tkey_loaded = B_FALSE;\n}\n\nstatic avl_tree_t idx_tree;\nstatic avl_tree_t domain_tree;\nstatic boolean_t fuid_table_loaded;\nstatic objset_t *sa_os = NULL;\nstatic sa_attr_type_t *sa_attr_table = NULL;\n\nstatic int\nopen_objset(const char *path, const void *tag, objset_t **osp)\n{\n\tint err;\n\tuint64_t sa_attrs = 0;\n\tuint64_t version = 0;\n\n\tVERIFY3P(sa_os, ==, NULL);\n\n\t \n\n\tif (dump_opt['K']) {\n\t\t \n\t\terr = dmu_objset_hold(path, tag, osp);\n\t\tif (err != 0) {\n\t\t\t(void) fprintf(stderr, \"failed to hold dataset \"\n\t\t\t    \"'%s': %s\\n\",\n\t\t\t    path, strerror(err));\n\t\t\treturn (err);\n\t\t}\n\t\tdsl_dataset_long_hold(dmu_objset_ds(*osp), tag);\n\t\tdsl_pool_rele(dmu_objset_pool(*osp), tag);\n\n\t\t \n\t\tzdb_load_key(*osp);\n\n\t\t \n\t\tdsl_dataset_long_rele(dmu_objset_ds(*osp), tag);\n\t\tdsl_dataset_rele(dmu_objset_ds(*osp), tag);\n\t}\n\n\tint ds_hold_flags = key_loaded ? DS_HOLD_FLAG_DECRYPT : 0;\n\n\terr = dmu_objset_hold_flags(path, ds_hold_flags, tag, osp);\n\tif (err != 0) {\n\t\t(void) fprintf(stderr, \"failed to hold dataset '%s': %s\\n\",\n\t\t    path, strerror(err));\n\t\treturn (err);\n\t}\n\tdsl_dataset_long_hold(dmu_objset_ds(*osp), tag);\n\tdsl_pool_rele(dmu_objset_pool(*osp), tag);\n\n\tif (dmu_objset_type(*osp) == DMU_OST_ZFS &&\n\t    (key_loaded || !(*osp)->os_encrypted)) {\n\t\t(void) zap_lookup(*osp, MASTER_NODE_OBJ, ZPL_VERSION_STR,\n\t\t    8, 1, &version);\n\t\tif (version >= ZPL_VERSION_SA) {\n\t\t\t(void) zap_lookup(*osp, MASTER_NODE_OBJ, ZFS_SA_ATTRS,\n\t\t\t    8, 1, &sa_attrs);\n\t\t}\n\t\terr = sa_setup(*osp, sa_attrs, zfs_attr_table, ZPL_END,\n\t\t    &sa_attr_table);\n\t\tif (err != 0) {\n\t\t\t(void) fprintf(stderr, \"sa_setup failed: %s\\n\",\n\t\t\t    strerror(err));\n\t\t\tdsl_dataset_long_rele(dmu_objset_ds(*osp), tag);\n\t\t\tdsl_dataset_rele_flags(dmu_objset_ds(*osp),\n\t\t\t    ds_hold_flags, tag);\n\t\t\t*osp = NULL;\n\t\t}\n\t}\n\tsa_os = *osp;\n\n\treturn (err);\n}\n\nstatic void\nclose_objset(objset_t *os, const void *tag)\n{\n\tVERIFY3P(os, ==, sa_os);\n\tif (os->os_sa != NULL)\n\t\tsa_tear_down(os);\n\tdsl_dataset_long_rele(dmu_objset_ds(os), tag);\n\tdsl_dataset_rele_flags(dmu_objset_ds(os),\n\t    key_loaded ? DS_HOLD_FLAG_DECRYPT : 0, tag);\n\tsa_attr_table = NULL;\n\tsa_os = NULL;\n\n\tzdb_unload_key();\n}\n\nstatic void\nfuid_table_destroy(void)\n{\n\tif (fuid_table_loaded) {\n\t\tzfs_fuid_table_destroy(&idx_tree, &domain_tree);\n\t\tfuid_table_loaded = B_FALSE;\n\t}\n}\n\n \nstatic void\nprint_idstr(uint64_t id, const char *id_type)\n{\n\tif (FUID_INDEX(id)) {\n\t\tconst char *domain =\n\t\t    zfs_fuid_idx_domain(&idx_tree, FUID_INDEX(id));\n\t\t(void) printf(\"\\t%s     %llx [%s-%d]\\n\", id_type,\n\t\t    (u_longlong_t)id, domain, (int)FUID_RID(id));\n\t} else {\n\t\t(void) printf(\"\\t%s     %llu\\n\", id_type, (u_longlong_t)id);\n\t}\n\n}\n\nstatic void\ndump_uidgid(objset_t *os, uint64_t uid, uint64_t gid)\n{\n\tuint32_t uid_idx, gid_idx;\n\n\tuid_idx = FUID_INDEX(uid);\n\tgid_idx = FUID_INDEX(gid);\n\n\t \n\tif (!fuid_table_loaded && (uid_idx || gid_idx)) {\n\t\tuint64_t fuid_obj;\n\n\t\t \n\t\tVERIFY(zap_lookup(os, MASTER_NODE_OBJ, ZFS_FUID_TABLES,\n\t\t    8, 1, &fuid_obj) == 0);\n\t\tzfs_fuid_avl_tree_create(&idx_tree, &domain_tree);\n\t\t(void) zfs_fuid_table_load(os, fuid_obj,\n\t\t    &idx_tree, &domain_tree);\n\t\tfuid_table_loaded = B_TRUE;\n\t}\n\n\tprint_idstr(uid, \"uid\");\n\tprint_idstr(gid, \"gid\");\n}\n\nstatic void\ndump_znode_sa_xattr(sa_handle_t *hdl)\n{\n\tnvlist_t *sa_xattr;\n\tnvpair_t *elem = NULL;\n\tint sa_xattr_size = 0;\n\tint sa_xattr_entries = 0;\n\tint error;\n\tchar *sa_xattr_packed;\n\n\terror = sa_size(hdl, sa_attr_table[ZPL_DXATTR], &sa_xattr_size);\n\tif (error || sa_xattr_size == 0)\n\t\treturn;\n\n\tsa_xattr_packed = malloc(sa_xattr_size);\n\tif (sa_xattr_packed == NULL)\n\t\treturn;\n\n\terror = sa_lookup(hdl, sa_attr_table[ZPL_DXATTR],\n\t    sa_xattr_packed, sa_xattr_size);\n\tif (error) {\n\t\tfree(sa_xattr_packed);\n\t\treturn;\n\t}\n\n\terror = nvlist_unpack(sa_xattr_packed, sa_xattr_size, &sa_xattr, 0);\n\tif (error) {\n\t\tfree(sa_xattr_packed);\n\t\treturn;\n\t}\n\n\twhile ((elem = nvlist_next_nvpair(sa_xattr, elem)) != NULL)\n\t\tsa_xattr_entries++;\n\n\t(void) printf(\"\\tSA xattrs: %d bytes, %d entries\\n\\n\",\n\t    sa_xattr_size, sa_xattr_entries);\n\twhile ((elem = nvlist_next_nvpair(sa_xattr, elem)) != NULL) {\n\t\tboolean_t can_print = !dump_opt['P'];\n\t\tuchar_t *value;\n\t\tuint_t cnt, idx;\n\n\t\t(void) printf(\"\\t\\t%s = \", nvpair_name(elem));\n\t\tnvpair_value_byte_array(elem, &value, &cnt);\n\n\t\tfor (idx = 0; idx < cnt; ++idx) {\n\t\t\tif (!isprint(value[idx])) {\n\t\t\t\tcan_print = B_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (idx = 0; idx < cnt; ++idx) {\n\t\t\tif (can_print)\n\t\t\t\t(void) putchar(value[idx]);\n\t\t\telse\n\t\t\t\t(void) printf(\"\\\\%3.3o\", value[idx]);\n\t\t}\n\t\t(void) putchar('\\n');\n\t}\n\n\tnvlist_free(sa_xattr);\n\tfree(sa_xattr_packed);\n}\n\nstatic void\ndump_znode_symlink(sa_handle_t *hdl)\n{\n\tint sa_symlink_size = 0;\n\tchar linktarget[MAXPATHLEN];\n\tint error;\n\n\terror = sa_size(hdl, sa_attr_table[ZPL_SYMLINK], &sa_symlink_size);\n\tif (error || sa_symlink_size == 0) {\n\t\treturn;\n\t}\n\tif (sa_symlink_size >= sizeof (linktarget)) {\n\t\t(void) printf(\"symlink size %d is too large\\n\",\n\t\t    sa_symlink_size);\n\t\treturn;\n\t}\n\tlinktarget[sa_symlink_size] = '\\0';\n\tif (sa_lookup(hdl, sa_attr_table[ZPL_SYMLINK],\n\t    &linktarget, sa_symlink_size) == 0)\n\t\t(void) printf(\"\\ttarget\t%s\\n\", linktarget);\n}\n\nstatic void\ndump_znode(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) data, (void) size;\n\tchar path[MAXPATHLEN * 2];\t \n\tsa_handle_t *hdl;\n\tuint64_t xattr, rdev, gen;\n\tuint64_t uid, gid, mode, fsize, parent, links;\n\tuint64_t pflags;\n\tuint64_t acctm[2], modtm[2], chgtm[2], crtm[2];\n\ttime_t z_crtime, z_atime, z_mtime, z_ctime;\n\tsa_bulk_attr_t bulk[12];\n\tint idx = 0;\n\tint error;\n\n\tVERIFY3P(os, ==, sa_os);\n\tif (sa_handle_get(os, object, NULL, SA_HDL_PRIVATE, &hdl)) {\n\t\t(void) printf(\"Failed to get handle for SA znode\\n\");\n\t\treturn;\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_UID], NULL, &uid, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_GID], NULL, &gid, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_LINKS], NULL,\n\t    &links, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_GEN], NULL, &gen, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_MODE], NULL,\n\t    &mode, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_PARENT],\n\t    NULL, &parent, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_SIZE], NULL,\n\t    &fsize, 8);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_ATIME], NULL,\n\t    acctm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_MTIME], NULL,\n\t    modtm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_CRTIME], NULL,\n\t    crtm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_CTIME], NULL,\n\t    chgtm, 16);\n\tSA_ADD_BULK_ATTR(bulk, idx, sa_attr_table[ZPL_FLAGS], NULL,\n\t    &pflags, 8);\n\n\tif (sa_bulk_lookup(hdl, bulk, idx)) {\n\t\t(void) sa_handle_destroy(hdl);\n\t\treturn;\n\t}\n\n\tz_crtime = (time_t)crtm[0];\n\tz_atime = (time_t)acctm[0];\n\tz_mtime = (time_t)modtm[0];\n\tz_ctime = (time_t)chgtm[0];\n\n\tif (dump_opt['d'] > 4) {\n\t\terror = zfs_obj_to_path(os, object, path, sizeof (path));\n\t\tif (error == ESTALE) {\n\t\t\t(void) snprintf(path, sizeof (path), \"on delete queue\");\n\t\t} else if (error != 0) {\n\t\t\tleaked_objects++;\n\t\t\t(void) snprintf(path, sizeof (path),\n\t\t\t    \"path not found, possibly leaked\");\n\t\t}\n\t\t(void) printf(\"\\tpath\t%s\\n\", path);\n\t}\n\n\tif (S_ISLNK(mode))\n\t\tdump_znode_symlink(hdl);\n\tdump_uidgid(os, uid, gid);\n\t(void) printf(\"\\tatime\t%s\", ctime(&z_atime));\n\t(void) printf(\"\\tmtime\t%s\", ctime(&z_mtime));\n\t(void) printf(\"\\tctime\t%s\", ctime(&z_ctime));\n\t(void) printf(\"\\tcrtime\t%s\", ctime(&z_crtime));\n\t(void) printf(\"\\tgen\t%llu\\n\", (u_longlong_t)gen);\n\t(void) printf(\"\\tmode\t%llo\\n\", (u_longlong_t)mode);\n\t(void) printf(\"\\tsize\t%llu\\n\", (u_longlong_t)fsize);\n\t(void) printf(\"\\tparent\t%llu\\n\", (u_longlong_t)parent);\n\t(void) printf(\"\\tlinks\t%llu\\n\", (u_longlong_t)links);\n\t(void) printf(\"\\tpflags\t%llx\\n\", (u_longlong_t)pflags);\n\tif (dmu_objset_projectquota_enabled(os) && (pflags & ZFS_PROJID)) {\n\t\tuint64_t projid;\n\n\t\tif (sa_lookup(hdl, sa_attr_table[ZPL_PROJID], &projid,\n\t\t    sizeof (uint64_t)) == 0)\n\t\t\t(void) printf(\"\\tprojid\t%llu\\n\", (u_longlong_t)projid);\n\t}\n\tif (sa_lookup(hdl, sa_attr_table[ZPL_XATTR], &xattr,\n\t    sizeof (uint64_t)) == 0)\n\t\t(void) printf(\"\\txattr\t%llu\\n\", (u_longlong_t)xattr);\n\tif (sa_lookup(hdl, sa_attr_table[ZPL_RDEV], &rdev,\n\t    sizeof (uint64_t)) == 0)\n\t\t(void) printf(\"\\trdev\t0x%016llx\\n\", (u_longlong_t)rdev);\n\tdump_znode_sa_xattr(hdl);\n\tsa_handle_destroy(hdl);\n}\n\nstatic void\ndump_acl(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) data, (void) size;\n}\n\nstatic void\ndump_dmu_objset(objset_t *os, uint64_t object, void *data, size_t size)\n{\n\t(void) os, (void) object, (void) data, (void) size;\n}\n\nstatic object_viewer_t *object_viewer[DMU_OT_NUMTYPES + 1] = {\n\tdump_none,\t\t \n\tdump_zap,\t\t \n\tdump_uint64,\t\t \n\tdump_none,\t\t \n\tdump_packed_nvlist,\t \n\tdump_none,\t\t \n\tdump_bpobj,\t\t \n\tdump_none,\t\t \n\tdump_none,\t\t \n\tdump_none,\t\t \n\tdump_dnode,\t\t \n\tdump_dmu_objset,\t \n\tdump_dsl_dir,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_dsl_dataset,\t \n\tdump_znode,\t\t \n\tdump_acl,\t\t \n\tdump_uint8,\t\t \n\tdump_zpldir,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_uint8,\t\t \n\tdump_zap,\t\t \n\tdump_uint8,\t\t \n\tdump_uint64,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_uint8,\t\t \n\tdump_history_offsets,\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_acl,\t\t \n\tdump_uint8,\t\t \n\tdump_none,\t\t \n\tdump_packed_nvlist,\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_zap,\t\t \n\tdump_ddt_zap,\t\t \n\tdump_zap,\t\t \n\tdump_znode,\t\t \n\tdump_zap,\t\t \n\tdump_sa_attrs,\t\t \n\tdump_sa_layouts,\t \n\tdump_zap,\t\t \n\tdump_none,\t\t \n\tdump_zap,\t\t \n\tdump_none,\t\t \n\tdump_zap,\t\t \n\tdump_bpobj_subobjs,\t \n\tdump_unknown,\t\t \n};\n\nstatic boolean_t\nmatch_object_type(dmu_object_type_t obj_type, uint64_t flags)\n{\n\tboolean_t match = B_TRUE;\n\n\tswitch (obj_type) {\n\tcase DMU_OT_DIRECTORY_CONTENTS:\n\t\tif (!(flags & ZOR_FLAG_DIRECTORY))\n\t\t\tmatch = B_FALSE;\n\t\tbreak;\n\tcase DMU_OT_PLAIN_FILE_CONTENTS:\n\t\tif (!(flags & ZOR_FLAG_PLAIN_FILE))\n\t\t\tmatch = B_FALSE;\n\t\tbreak;\n\tcase DMU_OT_SPACE_MAP:\n\t\tif (!(flags & ZOR_FLAG_SPACE_MAP))\n\t\t\tmatch = B_FALSE;\n\t\tbreak;\n\tdefault:\n\t\tif (strcmp(zdb_ot_name(obj_type), \"zap\") == 0) {\n\t\t\tif (!(flags & ZOR_FLAG_ZAP))\n\t\t\t\tmatch = B_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((flags | ZOR_SUPPORTED_FLAGS) != ZOR_FLAG_ALL_TYPES)\n\t\t\tmatch = B_FALSE;\n\n\t\tbreak;\n\t}\n\n\treturn (match);\n}\n\nstatic void\ndump_object(objset_t *os, uint64_t object, int verbosity,\n    boolean_t *print_header, uint64_t *dnode_slots_used, uint64_t flags)\n{\n\tdmu_buf_t *db = NULL;\n\tdmu_object_info_t doi;\n\tdnode_t *dn;\n\tboolean_t dnode_held = B_FALSE;\n\tvoid *bonus = NULL;\n\tsize_t bsize = 0;\n\tchar iblk[32], dblk[32], lsize[32], asize[32], fill[32], dnsize[32];\n\tchar bonus_size[32];\n\tchar aux[50];\n\tint error;\n\n\t \n\t_Static_assert(sizeof (iblk) >= NN_NUMBUF_SZ, \"iblk truncated\");\n\t_Static_assert(sizeof (dblk) >= NN_NUMBUF_SZ, \"dblk truncated\");\n\t_Static_assert(sizeof (lsize) >= NN_NUMBUF_SZ, \"lsize truncated\");\n\t_Static_assert(sizeof (asize) >= NN_NUMBUF_SZ, \"asize truncated\");\n\t_Static_assert(sizeof (bonus_size) >= NN_NUMBUF_SZ,\n\t    \"bonus_size truncated\");\n\n\tif (*print_header) {\n\t\t(void) printf(\"\\n%10s  %3s  %5s  %5s  %5s  %6s  %5s  %6s  %s\\n\",\n\t\t    \"Object\", \"lvl\", \"iblk\", \"dblk\", \"dsize\", \"dnsize\",\n\t\t    \"lsize\", \"%full\", \"type\");\n\t\t*print_header = 0;\n\t}\n\n\tif (object == 0) {\n\t\tdn = DMU_META_DNODE(os);\n\t\tdmu_object_info_from_dnode(dn, &doi);\n\t} else {\n\t\t \n\t\terror = dmu_object_info(os, object, &doi);\n\t\tif (error)\n\t\t\tfatal(\"dmu_object_info() failed, errno %u\", error);\n\n\t\tif (!key_loaded && os->os_encrypted &&\n\t\t    DMU_OT_IS_ENCRYPTED(doi.doi_bonus_type)) {\n\t\t\terror = dnode_hold(os, object, FTAG, &dn);\n\t\t\tif (error)\n\t\t\t\tfatal(\"dnode_hold() failed, errno %u\", error);\n\t\t\tdnode_held = B_TRUE;\n\t\t} else {\n\t\t\terror = dmu_bonus_hold(os, object, FTAG, &db);\n\t\t\tif (error)\n\t\t\t\tfatal(\"dmu_bonus_hold(%llu) failed, errno %u\",\n\t\t\t\t    object, error);\n\t\t\tbonus = db->db_data;\n\t\t\tbsize = db->db_size;\n\t\t\tdn = DB_DNODE((dmu_buf_impl_t *)db);\n\t\t}\n\t}\n\n\t \n\tif (flags != 0 && flags != ZOR_FLAG_ALL_TYPES &&\n\t    !match_object_type(doi.doi_type, flags))\n\t\tgoto out;\n\n\tif (dnode_slots_used)\n\t\t*dnode_slots_used = doi.doi_dnodesize / DNODE_MIN_SIZE;\n\n\tzdb_nicenum(doi.doi_metadata_block_size, iblk, sizeof (iblk));\n\tzdb_nicenum(doi.doi_data_block_size, dblk, sizeof (dblk));\n\tzdb_nicenum(doi.doi_max_offset, lsize, sizeof (lsize));\n\tzdb_nicenum(doi.doi_physical_blocks_512 << 9, asize, sizeof (asize));\n\tzdb_nicenum(doi.doi_bonus_size, bonus_size, sizeof (bonus_size));\n\tzdb_nicenum(doi.doi_dnodesize, dnsize, sizeof (dnsize));\n\t(void) snprintf(fill, sizeof (fill), \"%6.2f\", 100.0 *\n\t    doi.doi_fill_count * doi.doi_data_block_size / (object == 0 ?\n\t    DNODES_PER_BLOCK : 1) / doi.doi_max_offset);\n\n\taux[0] = '\\0';\n\n\tif (doi.doi_checksum != ZIO_CHECKSUM_INHERIT || verbosity >= 6) {\n\t\t(void) snprintf(aux + strlen(aux), sizeof (aux) - strlen(aux),\n\t\t    \" (K=%s)\", ZDB_CHECKSUM_NAME(doi.doi_checksum));\n\t}\n\n\tif (doi.doi_compress == ZIO_COMPRESS_INHERIT &&\n\t    ZIO_COMPRESS_HASLEVEL(os->os_compress) && verbosity >= 6) {\n\t\tconst char *compname = NULL;\n\t\tif (zfs_prop_index_to_string(ZFS_PROP_COMPRESSION,\n\t\t    ZIO_COMPRESS_RAW(os->os_compress, os->os_complevel),\n\t\t    &compname) == 0) {\n\t\t\t(void) snprintf(aux + strlen(aux),\n\t\t\t    sizeof (aux) - strlen(aux), \" (Z=inherit=%s)\",\n\t\t\t    compname);\n\t\t} else {\n\t\t\t(void) snprintf(aux + strlen(aux),\n\t\t\t    sizeof (aux) - strlen(aux),\n\t\t\t    \" (Z=inherit=%s-unknown)\",\n\t\t\t    ZDB_COMPRESS_NAME(os->os_compress));\n\t\t}\n\t} else if (doi.doi_compress == ZIO_COMPRESS_INHERIT && verbosity >= 6) {\n\t\t(void) snprintf(aux + strlen(aux), sizeof (aux) - strlen(aux),\n\t\t    \" (Z=inherit=%s)\", ZDB_COMPRESS_NAME(os->os_compress));\n\t} else if (doi.doi_compress != ZIO_COMPRESS_INHERIT || verbosity >= 6) {\n\t\t(void) snprintf(aux + strlen(aux), sizeof (aux) - strlen(aux),\n\t\t    \" (Z=%s)\", ZDB_COMPRESS_NAME(doi.doi_compress));\n\t}\n\n\t(void) printf(\"%10lld  %3u  %5s  %5s  %5s  %6s  %5s  %6s  %s%s\\n\",\n\t    (u_longlong_t)object, doi.doi_indirection, iblk, dblk,\n\t    asize, dnsize, lsize, fill, zdb_ot_name(doi.doi_type), aux);\n\n\tif (doi.doi_bonus_type != DMU_OT_NONE && verbosity > 3) {\n\t\t(void) printf(\"%10s  %3s  %5s  %5s  %5s  %5s  %5s  %6s  %s\\n\",\n\t\t    \"\", \"\", \"\", \"\", \"\", \"\", bonus_size, \"bonus\",\n\t\t    zdb_ot_name(doi.doi_bonus_type));\n\t}\n\n\tif (verbosity >= 4) {\n\t\t(void) printf(\"\\tdnode flags: %s%s%s%s\\n\",\n\t\t    (dn->dn_phys->dn_flags & DNODE_FLAG_USED_BYTES) ?\n\t\t    \"USED_BYTES \" : \"\",\n\t\t    (dn->dn_phys->dn_flags & DNODE_FLAG_USERUSED_ACCOUNTED) ?\n\t\t    \"USERUSED_ACCOUNTED \" : \"\",\n\t\t    (dn->dn_phys->dn_flags & DNODE_FLAG_USEROBJUSED_ACCOUNTED) ?\n\t\t    \"USEROBJUSED_ACCOUNTED \" : \"\",\n\t\t    (dn->dn_phys->dn_flags & DNODE_FLAG_SPILL_BLKPTR) ?\n\t\t    \"SPILL_BLKPTR\" : \"\");\n\t\t(void) printf(\"\\tdnode maxblkid: %llu\\n\",\n\t\t    (longlong_t)dn->dn_phys->dn_maxblkid);\n\n\t\tif (!dnode_held) {\n\t\t\tobject_viewer[ZDB_OT_TYPE(doi.doi_bonus_type)](os,\n\t\t\t    object, bonus, bsize);\n\t\t} else {\n\t\t\t(void) printf(\"\\t\\t(bonus encrypted)\\n\");\n\t\t}\n\n\t\tif (key_loaded ||\n\t\t    (!os->os_encrypted || !DMU_OT_IS_ENCRYPTED(doi.doi_type))) {\n\t\t\tobject_viewer[ZDB_OT_TYPE(doi.doi_type)](os, object,\n\t\t\t    NULL, 0);\n\t\t} else {\n\t\t\t(void) printf(\"\\t\\t(object encrypted)\\n\");\n\t\t}\n\n\t\t*print_header = B_TRUE;\n\t}\n\n\tif (verbosity >= 5) {\n\t\tif (dn->dn_phys->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\t\tsnprintf_blkptr_compact(blkbuf, sizeof (blkbuf),\n\t\t\t    DN_SPILL_BLKPTR(dn->dn_phys), B_FALSE);\n\t\t\t(void) printf(\"\\nSpill block: %s\\n\", blkbuf);\n\t\t}\n\t\tdump_indirect(dn);\n\t}\n\n\tif (verbosity >= 5) {\n\t\t \n\t\tuint64_t start = 0;\n\t\tuint64_t end;\n\t\tuint64_t blkfill = 1;\n\t\tint minlvl = 1;\n\n\t\tif (dn->dn_type == DMU_OT_DNODE) {\n\t\t\tminlvl = 0;\n\t\t\tblkfill = DNODES_PER_BLOCK;\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tchar segsize[32];\n\t\t\t \n\t\t\t_Static_assert(sizeof (segsize) >= NN_NUMBUF_SZ,\n\t\t\t    \"segsize truncated\");\n\t\t\terror = dnode_next_offset(dn,\n\t\t\t    0, &start, minlvl, blkfill, 0);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tend = start;\n\t\t\terror = dnode_next_offset(dn,\n\t\t\t    DNODE_FIND_HOLE, &end, minlvl, blkfill, 0);\n\t\t\tzdb_nicenum(end - start, segsize, sizeof (segsize));\n\t\t\t(void) printf(\"\\t\\tsegment [%016llx, %016llx)\"\n\t\t\t    \" size %5s\\n\", (u_longlong_t)start,\n\t\t\t    (u_longlong_t)end, segsize);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tstart = end;\n\t\t}\n\t}\n\nout:\n\tif (db != NULL)\n\t\tdmu_buf_rele(db, FTAG);\n\tif (dnode_held)\n\t\tdnode_rele(dn, FTAG);\n}\n\nstatic void\ncount_dir_mos_objects(dsl_dir_t *dd)\n{\n\tmos_obj_refd(dd->dd_object);\n\tmos_obj_refd(dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\tmos_obj_refd(dsl_dir_phys(dd)->dd_deleg_zapobj);\n\tmos_obj_refd(dsl_dir_phys(dd)->dd_props_zapobj);\n\tmos_obj_refd(dsl_dir_phys(dd)->dd_clones);\n\n\t \n\tmos_obj_refd_multiple(dd->dd_crypto_obj);\n}\n\nstatic void\ncount_ds_mos_objects(dsl_dataset_t *ds)\n{\n\tmos_obj_refd(ds->ds_object);\n\tmos_obj_refd(dsl_dataset_phys(ds)->ds_next_clones_obj);\n\tmos_obj_refd(dsl_dataset_phys(ds)->ds_props_obj);\n\tmos_obj_refd(dsl_dataset_phys(ds)->ds_userrefs_obj);\n\tmos_obj_refd(dsl_dataset_phys(ds)->ds_snapnames_zapobj);\n\tmos_obj_refd(ds->ds_bookmarks_obj);\n\n\tif (!dsl_dataset_is_snapshot(ds)) {\n\t\tcount_dir_mos_objects(ds->ds_dir);\n\t}\n}\n\nstatic const char *const objset_types[DMU_OST_NUMTYPES] = {\n\t\"NONE\", \"META\", \"ZPL\", \"ZVOL\", \"OTHER\", \"ANY\" };\n\n \nstatic int\nparse_object_range(char *range, zopt_object_range_t *zor, const char **msg)\n{\n\tuint64_t flags = 0;\n\tchar *p, *s, *dup, *flagstr, *tmp = NULL;\n\tsize_t len;\n\tint i;\n\tint rc = 0;\n\n\tif (strchr(range, ':') == NULL) {\n\t\tzor->zor_obj_start = strtoull(range, &p, 0);\n\t\tif (*p != '\\0') {\n\t\t\t*msg = \"Invalid characters in object ID\";\n\t\t\trc = 1;\n\t\t}\n\t\tzor->zor_obj_start = ZDB_MAP_OBJECT_ID(zor->zor_obj_start);\n\t\tzor->zor_obj_end = zor->zor_obj_start;\n\t\treturn (rc);\n\t}\n\n\tif (strchr(range, ':') == range) {\n\t\t*msg = \"Invalid leading colon\";\n\t\trc = 1;\n\t\treturn (rc);\n\t}\n\n\tlen = strlen(range);\n\tif (range[len - 1] == ':') {\n\t\t*msg = \"Invalid trailing colon\";\n\t\trc = 1;\n\t\treturn (rc);\n\t}\n\n\tdup = strdup(range);\n\ts = strtok_r(dup, \":\", &tmp);\n\tzor->zor_obj_start = strtoull(s, &p, 0);\n\n\tif (*p != '\\0') {\n\t\t*msg = \"Invalid characters in start object ID\";\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\ts = strtok_r(NULL, \":\", &tmp);\n\tzor->zor_obj_end = strtoull(s, &p, 0);\n\n\tif (*p != '\\0') {\n\t\t*msg = \"Invalid characters in end object ID\";\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\tif (zor->zor_obj_start > zor->zor_obj_end) {\n\t\t*msg = \"Start object ID may not exceed end object ID\";\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\ts = strtok_r(NULL, \":\", &tmp);\n\tif (s == NULL) {\n\t\tzor->zor_flags = ZOR_FLAG_ALL_TYPES;\n\t\tgoto out;\n\t} else if (strtok_r(NULL, \":\", &tmp) != NULL) {\n\t\t*msg = \"Invalid colon-delimited field after flags\";\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\tflagstr = s;\n\tfor (i = 0; flagstr[i]; i++) {\n\t\tint bit;\n\t\tboolean_t negation = (flagstr[i] == '-');\n\n\t\tif (negation) {\n\t\t\ti++;\n\t\t\tif (flagstr[i] == '\\0') {\n\t\t\t\t*msg = \"Invalid trailing negation operator\";\n\t\t\t\trc = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbit = flagbits[(uchar_t)flagstr[i]];\n\t\tif (bit == 0) {\n\t\t\t*msg = \"Invalid flag\";\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (negation)\n\t\t\tflags &= ~bit;\n\t\telse\n\t\t\tflags |= bit;\n\t}\n\tzor->zor_flags = flags;\n\n\tzor->zor_obj_start = ZDB_MAP_OBJECT_ID(zor->zor_obj_start);\n\tzor->zor_obj_end = ZDB_MAP_OBJECT_ID(zor->zor_obj_end);\n\nout:\n\tfree(dup);\n\treturn (rc);\n}\n\nstatic void\ndump_objset(objset_t *os)\n{\n\tdmu_objset_stats_t dds = { 0 };\n\tuint64_t object, object_count;\n\tuint64_t refdbytes, usedobjs, scratch;\n\tchar numbuf[32];\n\tchar blkbuf[BP_SPRINTF_LEN + 20];\n\tchar osname[ZFS_MAX_DATASET_NAME_LEN];\n\tconst char *type = \"UNKNOWN\";\n\tint verbosity = dump_opt['d'];\n\tboolean_t print_header;\n\tunsigned i;\n\tint error;\n\tuint64_t total_slots_used = 0;\n\tuint64_t max_slot_used = 0;\n\tuint64_t dnode_slots;\n\tuint64_t obj_start;\n\tuint64_t obj_end;\n\tuint64_t flags;\n\n\t \n\t_Static_assert(sizeof (numbuf) >= NN_NUMBUF_SZ, \"numbuf truncated\");\n\n\tdsl_pool_config_enter(dmu_objset_pool(os), FTAG);\n\tdmu_objset_fast_stat(os, &dds);\n\tdsl_pool_config_exit(dmu_objset_pool(os), FTAG);\n\n\tprint_header = B_TRUE;\n\n\tif (dds.dds_type < DMU_OST_NUMTYPES)\n\t\ttype = objset_types[dds.dds_type];\n\n\tif (dds.dds_type == DMU_OST_META) {\n\t\tdds.dds_creation_txg = TXG_INITIAL;\n\t\tusedobjs = BP_GET_FILL(os->os_rootbp);\n\t\trefdbytes = dsl_dir_phys(os->os_spa->spa_dsl_pool->dp_mos_dir)->\n\t\t    dd_used_bytes;\n\t} else {\n\t\tdmu_objset_space(os, &refdbytes, &scratch, &usedobjs, &scratch);\n\t}\n\n\tASSERT3U(usedobjs, ==, BP_GET_FILL(os->os_rootbp));\n\n\tzdb_nicenum(refdbytes, numbuf, sizeof (numbuf));\n\n\tif (verbosity >= 4) {\n\t\t(void) snprintf(blkbuf, sizeof (blkbuf), \", rootbp \");\n\t\t(void) snprintf_blkptr(blkbuf + strlen(blkbuf),\n\t\t    sizeof (blkbuf) - strlen(blkbuf), os->os_rootbp);\n\t} else {\n\t\tblkbuf[0] = '\\0';\n\t}\n\n\tdmu_objset_name(os, osname);\n\n\t(void) printf(\"Dataset %s [%s], ID %llu, cr_txg %llu, \"\n\t    \"%s, %llu objects%s%s\\n\",\n\t    osname, type, (u_longlong_t)dmu_objset_id(os),\n\t    (u_longlong_t)dds.dds_creation_txg,\n\t    numbuf, (u_longlong_t)usedobjs, blkbuf,\n\t    (dds.dds_inconsistent) ? \" (inconsistent)\" : \"\");\n\n\tfor (i = 0; i < zopt_object_args; i++) {\n\t\tobj_start = zopt_object_ranges[i].zor_obj_start;\n\t\tobj_end = zopt_object_ranges[i].zor_obj_end;\n\t\tflags = zopt_object_ranges[i].zor_flags;\n\n\t\tobject = obj_start;\n\t\tif (object == 0 || obj_start == obj_end)\n\t\t\tdump_object(os, object, verbosity, &print_header, NULL,\n\t\t\t    flags);\n\t\telse\n\t\t\tobject--;\n\n\t\twhile ((dmu_object_next(os, &object, B_FALSE, 0) == 0) &&\n\t\t    object <= obj_end) {\n\t\t\tdump_object(os, object, verbosity, &print_header, NULL,\n\t\t\t    flags);\n\t\t}\n\t}\n\n\tif (zopt_object_args > 0) {\n\t\t(void) printf(\"\\n\");\n\t\treturn;\n\t}\n\n\tif (dump_opt['i'] != 0 || verbosity >= 2)\n\t\tdump_intent_log(dmu_objset_zil(os));\n\n\tif (dmu_objset_ds(os) != NULL) {\n\t\tdsl_dataset_t *ds = dmu_objset_ds(os);\n\t\tdump_blkptr_list(&ds->ds_deadlist, \"Deadlist\");\n\t\tif (dsl_deadlist_is_open(&ds->ds_dir->dd_livelist) &&\n\t\t    !dmu_objset_is_snapshot(os)) {\n\t\t\tdump_blkptr_list(&ds->ds_dir->dd_livelist, \"Livelist\");\n\t\t\tif (verify_dd_livelist(os) != 0)\n\t\t\t\tfatal(\"livelist is incorrect\");\n\t\t}\n\n\t\tif (dsl_dataset_remap_deadlist_exists(ds)) {\n\t\t\t(void) printf(\"ds_remap_deadlist:\\n\");\n\t\t\tdump_blkptr_list(&ds->ds_remap_deadlist, \"Deadlist\");\n\t\t}\n\t\tcount_ds_mos_objects(ds);\n\t}\n\n\tif (dmu_objset_ds(os) != NULL)\n\t\tdump_bookmarks(os, verbosity);\n\n\tif (verbosity < 2)\n\t\treturn;\n\n\tif (BP_IS_HOLE(os->os_rootbp))\n\t\treturn;\n\n\tdump_object(os, 0, verbosity, &print_header, NULL, 0);\n\tobject_count = 0;\n\tif (DMU_USERUSED_DNODE(os) != NULL &&\n\t    DMU_USERUSED_DNODE(os)->dn_type != 0) {\n\t\tdump_object(os, DMU_USERUSED_OBJECT, verbosity, &print_header,\n\t\t    NULL, 0);\n\t\tdump_object(os, DMU_GROUPUSED_OBJECT, verbosity, &print_header,\n\t\t    NULL, 0);\n\t}\n\n\tif (DMU_PROJECTUSED_DNODE(os) != NULL &&\n\t    DMU_PROJECTUSED_DNODE(os)->dn_type != 0)\n\t\tdump_object(os, DMU_PROJECTUSED_OBJECT, verbosity,\n\t\t    &print_header, NULL, 0);\n\n\tobject = 0;\n\twhile ((error = dmu_object_next(os, &object, B_FALSE, 0)) == 0) {\n\t\tdump_object(os, object, verbosity, &print_header, &dnode_slots,\n\t\t    0);\n\t\tobject_count++;\n\t\ttotal_slots_used += dnode_slots;\n\t\tmax_slot_used = object + dnode_slots - 1;\n\t}\n\n\t(void) printf(\"\\n\");\n\n\t(void) printf(\"    Dnode slots:\\n\");\n\t(void) printf(\"\\tTotal used:    %10llu\\n\",\n\t    (u_longlong_t)total_slots_used);\n\t(void) printf(\"\\tMax used:      %10llu\\n\",\n\t    (u_longlong_t)max_slot_used);\n\t(void) printf(\"\\tPercent empty: %10lf\\n\",\n\t    (double)(max_slot_used - total_slots_used)*100 /\n\t    (double)max_slot_used);\n\t(void) printf(\"\\n\");\n\n\tif (error != ESRCH) {\n\t\t(void) fprintf(stderr, \"dmu_object_next() = %d\\n\", error);\n\t\tabort();\n\t}\n\n\tASSERT3U(object_count, ==, usedobjs);\n\n\tif (leaked_objects != 0) {\n\t\t(void) printf(\"%d potentially leaked objects detected\\n\",\n\t\t    leaked_objects);\n\t\tleaked_objects = 0;\n\t}\n}\n\nstatic void\ndump_uberblock(uberblock_t *ub, const char *header, const char *footer)\n{\n\ttime_t timestamp = ub->ub_timestamp;\n\n\t(void) printf(\"%s\", header ? header : \"\");\n\t(void) printf(\"\\tmagic = %016llx\\n\", (u_longlong_t)ub->ub_magic);\n\t(void) printf(\"\\tversion = %llu\\n\", (u_longlong_t)ub->ub_version);\n\t(void) printf(\"\\ttxg = %llu\\n\", (u_longlong_t)ub->ub_txg);\n\t(void) printf(\"\\tguid_sum = %llu\\n\", (u_longlong_t)ub->ub_guid_sum);\n\t(void) printf(\"\\ttimestamp = %llu UTC = %s\",\n\t    (u_longlong_t)ub->ub_timestamp, ctime(&timestamp));\n\n\t(void) printf(\"\\tmmp_magic = %016llx\\n\",\n\t    (u_longlong_t)ub->ub_mmp_magic);\n\tif (MMP_VALID(ub)) {\n\t\t(void) printf(\"\\tmmp_delay = %0llu\\n\",\n\t\t    (u_longlong_t)ub->ub_mmp_delay);\n\t\tif (MMP_SEQ_VALID(ub))\n\t\t\t(void) printf(\"\\tmmp_seq = %u\\n\",\n\t\t\t    (unsigned int) MMP_SEQ(ub));\n\t\tif (MMP_FAIL_INT_VALID(ub))\n\t\t\t(void) printf(\"\\tmmp_fail = %u\\n\",\n\t\t\t    (unsigned int) MMP_FAIL_INT(ub));\n\t\tif (MMP_INTERVAL_VALID(ub))\n\t\t\t(void) printf(\"\\tmmp_write = %u\\n\",\n\t\t\t    (unsigned int) MMP_INTERVAL(ub));\n\t\t \n\t\t(void) printf(\"\\tmmp_valid = %x\\n\",\n\t\t    (unsigned int) ub->ub_mmp_config & 0xFF);\n\t}\n\n\tif (dump_opt['u'] >= 4) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), &ub->ub_rootbp);\n\t\t(void) printf(\"\\trootbp = %s\\n\", blkbuf);\n\t}\n\t(void) printf(\"\\tcheckpoint_txg = %llu\\n\",\n\t    (u_longlong_t)ub->ub_checkpoint_txg);\n\t(void) printf(\"%s\", footer ? footer : \"\");\n}\n\nstatic void\ndump_config(spa_t *spa)\n{\n\tdmu_buf_t *db;\n\tsize_t nvsize = 0;\n\tint error = 0;\n\n\n\terror = dmu_bonus_hold(spa->spa_meta_objset,\n\t    spa->spa_config_object, FTAG, &db);\n\n\tif (error == 0) {\n\t\tnvsize = *(uint64_t *)db->db_data;\n\t\tdmu_buf_rele(db, FTAG);\n\n\t\t(void) printf(\"\\nMOS Configuration:\\n\");\n\t\tdump_packed_nvlist(spa->spa_meta_objset,\n\t\t    spa->spa_config_object, (void *)&nvsize, 1);\n\t} else {\n\t\t(void) fprintf(stderr, \"dmu_bonus_hold(%llu) failed, errno %d\",\n\t\t    (u_longlong_t)spa->spa_config_object, error);\n\t}\n}\n\nstatic void\ndump_cachefile(const char *cachefile)\n{\n\tint fd;\n\tstruct stat64 statbuf;\n\tchar *buf;\n\tnvlist_t *config;\n\n\tif ((fd = open64(cachefile, O_RDONLY)) < 0) {\n\t\t(void) printf(\"cannot open '%s': %s\\n\", cachefile,\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (fstat64(fd, &statbuf) != 0) {\n\t\t(void) printf(\"failed to stat '%s': %s\\n\", cachefile,\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\n\tif ((buf = malloc(statbuf.st_size)) == NULL) {\n\t\t(void) fprintf(stderr, \"failed to allocate %llu bytes\\n\",\n\t\t    (u_longlong_t)statbuf.st_size);\n\t\texit(1);\n\t}\n\n\tif (read(fd, buf, statbuf.st_size) != statbuf.st_size) {\n\t\t(void) fprintf(stderr, \"failed to read %llu bytes\\n\",\n\t\t    (u_longlong_t)statbuf.st_size);\n\t\texit(1);\n\t}\n\n\t(void) close(fd);\n\n\tif (nvlist_unpack(buf, statbuf.st_size, &config, 0) != 0) {\n\t\t(void) fprintf(stderr, \"failed to unpack nvlist\\n\");\n\t\texit(1);\n\t}\n\n\tfree(buf);\n\n\tdump_nvlist(config, 0);\n\n\tnvlist_free(config);\n}\n\n \ntypedef struct zdb_nvl_stats {\n\tint\t\tzns_list_count;\n\tint\t\tzns_leaf_count;\n\tsize_t\t\tzns_leaf_largest;\n\tsize_t\t\tzns_leaf_total;\n\tnvlist_t\t*zns_string;\n\tnvlist_t\t*zns_uint64;\n\tnvlist_t\t*zns_boolean;\n} zdb_nvl_stats_t;\n\nstatic void\ncollect_nvlist_stats(nvlist_t *nvl, zdb_nvl_stats_t *stats)\n{\n\tnvlist_t *list, **array;\n\tnvpair_t *nvp = NULL;\n\tconst char *name;\n\tuint_t i, items;\n\n\tstats->zns_list_count++;\n\n\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {\n\t\tname = nvpair_name(nvp);\n\n\t\tswitch (nvpair_type(nvp)) {\n\t\tcase DATA_TYPE_STRING:\n\t\t\tfnvlist_add_string(stats->zns_string, name,\n\t\t\t    fnvpair_value_string(nvp));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT64:\n\t\t\tfnvlist_add_uint64(stats->zns_uint64, name,\n\t\t\t    fnvpair_value_uint64(nvp));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_BOOLEAN:\n\t\t\tfnvlist_add_boolean(stats->zns_boolean, name);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_NVLIST:\n\t\t\tif (nvpair_value_nvlist(nvp, &list) == 0)\n\t\t\t\tcollect_nvlist_stats(list, stats);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\t\tif (nvpair_value_nvlist_array(nvp, &array, &items) != 0)\n\t\t\t\tbreak;\n\n\t\t\tfor (i = 0; i < items; i++) {\n\t\t\t\tcollect_nvlist_stats(array[i], stats);\n\n\t\t\t\t \n\t\t\t\tif (strcmp(name, \"children\") == 0) {\n\t\t\t\t\tsize_t size;\n\n\t\t\t\t\t(void) nvlist_size(array[i], &size,\n\t\t\t\t\t    NV_ENCODE_XDR);\n\t\t\t\t\tstats->zns_leaf_total += size;\n\t\t\t\t\tif (size > stats->zns_leaf_largest)\n\t\t\t\t\t\tstats->zns_leaf_largest = size;\n\t\t\t\t\tstats->zns_leaf_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) printf(\"skip type %d!\\n\", (int)nvpair_type(nvp));\n\t\t}\n\t}\n}\n\nstatic void\ndump_nvlist_stats(nvlist_t *nvl, size_t cap)\n{\n\tzdb_nvl_stats_t stats = { 0 };\n\tsize_t size, sum = 0, total;\n\tsize_t noise;\n\n\t \n\tVERIFY0(nvlist_alloc(&stats.zns_string, 0, 0));\n\tVERIFY0(nvlist_alloc(&stats.zns_uint64, 0, 0));\n\tVERIFY0(nvlist_alloc(&stats.zns_boolean, 0, 0));\n\tVERIFY0(nvlist_size(stats.zns_boolean, &noise, NV_ENCODE_XDR));\n\n\t(void) printf(\"\\n\\nZFS Label NVList Config Stats:\\n\");\n\n\tVERIFY0(nvlist_size(nvl, &total, NV_ENCODE_XDR));\n\t(void) printf(\"  %d bytes used, %d bytes free (using %4.1f%%)\\n\\n\",\n\t    (int)total, (int)(cap - total), 100.0 * total / cap);\n\n\tcollect_nvlist_stats(nvl, &stats);\n\n\tVERIFY0(nvlist_size(stats.zns_uint64, &size, NV_ENCODE_XDR));\n\tsize -= noise;\n\tsum += size;\n\t(void) printf(\"%12s %4d %6d bytes (%5.2f%%)\\n\", \"integers:\",\n\t    (int)fnvlist_num_pairs(stats.zns_uint64),\n\t    (int)size, 100.0 * size / total);\n\n\tVERIFY0(nvlist_size(stats.zns_string, &size, NV_ENCODE_XDR));\n\tsize -= noise;\n\tsum += size;\n\t(void) printf(\"%12s %4d %6d bytes (%5.2f%%)\\n\", \"strings:\",\n\t    (int)fnvlist_num_pairs(stats.zns_string),\n\t    (int)size, 100.0 * size / total);\n\n\tVERIFY0(nvlist_size(stats.zns_boolean, &size, NV_ENCODE_XDR));\n\tsize -= noise;\n\tsum += size;\n\t(void) printf(\"%12s %4d %6d bytes (%5.2f%%)\\n\", \"booleans:\",\n\t    (int)fnvlist_num_pairs(stats.zns_boolean),\n\t    (int)size, 100.0 * size / total);\n\n\tsize = total - sum;\t \n\t(void) printf(\"%12s %4d %6d bytes (%5.2f%%)\\n\\n\", \"nvlists:\",\n\t    stats.zns_list_count, (int)size, 100.0 * size / total);\n\n\tif (stats.zns_leaf_count > 0) {\n\t\tsize_t average = stats.zns_leaf_total / stats.zns_leaf_count;\n\n\t\t(void) printf(\"%12s %4d %6d bytes average\\n\", \"leaf vdevs:\",\n\t\t    stats.zns_leaf_count, (int)average);\n\t\t(void) printf(\"%24d bytes largest\\n\",\n\t\t    (int)stats.zns_leaf_largest);\n\n\t\tif (dump_opt['l'] >= 3 && average > 0)\n\t\t\t(void) printf(\"  space for %d additional leaf vdevs\\n\",\n\t\t\t    (int)((cap - total) / average));\n\t}\n\t(void) printf(\"\\n\");\n\n\tnvlist_free(stats.zns_string);\n\tnvlist_free(stats.zns_uint64);\n\tnvlist_free(stats.zns_boolean);\n}\n\ntypedef struct cksum_record {\n\tzio_cksum_t cksum;\n\tboolean_t labels[VDEV_LABELS];\n\tavl_node_t link;\n} cksum_record_t;\n\nstatic int\ncksum_record_compare(const void *x1, const void *x2)\n{\n\tconst cksum_record_t *l = (cksum_record_t *)x1;\n\tconst cksum_record_t *r = (cksum_record_t *)x2;\n\tint arraysize = ARRAY_SIZE(l->cksum.zc_word);\n\tint difference = 0;\n\n\tfor (int i = 0; i < arraysize; i++) {\n\t\tdifference = TREE_CMP(l->cksum.zc_word[i], r->cksum.zc_word[i]);\n\t\tif (difference)\n\t\t\tbreak;\n\t}\n\n\treturn (difference);\n}\n\nstatic cksum_record_t *\ncksum_record_alloc(zio_cksum_t *cksum, int l)\n{\n\tcksum_record_t *rec;\n\n\trec = umem_zalloc(sizeof (*rec), UMEM_NOFAIL);\n\trec->cksum = *cksum;\n\trec->labels[l] = B_TRUE;\n\n\treturn (rec);\n}\n\nstatic cksum_record_t *\ncksum_record_lookup(avl_tree_t *tree, zio_cksum_t *cksum)\n{\n\tcksum_record_t lookup = { .cksum = *cksum };\n\tavl_index_t where;\n\n\treturn (avl_find(tree, &lookup, &where));\n}\n\nstatic cksum_record_t *\ncksum_record_insert(avl_tree_t *tree, zio_cksum_t *cksum, int l)\n{\n\tcksum_record_t *rec;\n\n\trec = cksum_record_lookup(tree, cksum);\n\tif (rec) {\n\t\trec->labels[l] = B_TRUE;\n\t} else {\n\t\trec = cksum_record_alloc(cksum, l);\n\t\tavl_add(tree, rec);\n\t}\n\n\treturn (rec);\n}\n\nstatic int\nfirst_label(cksum_record_t *rec)\n{\n\tfor (int i = 0; i < VDEV_LABELS; i++)\n\t\tif (rec->labels[i])\n\t\t\treturn (i);\n\n\treturn (-1);\n}\n\nstatic void\nprint_label_numbers(const char *prefix, const cksum_record_t *rec)\n{\n\tfputs(prefix, stdout);\n\tfor (int i = 0; i < VDEV_LABELS; i++)\n\t\tif (rec->labels[i] == B_TRUE)\n\t\t\tprintf(\"%d \", i);\n\tputchar('\\n');\n}\n\n#define\tMAX_UBERBLOCK_COUNT (VDEV_UBERBLOCK_RING >> UBERBLOCK_SHIFT)\n\ntypedef struct zdb_label {\n\tvdev_label_t label;\n\tuint64_t label_offset;\n\tnvlist_t *config_nv;\n\tcksum_record_t *config;\n\tcksum_record_t *uberblocks[MAX_UBERBLOCK_COUNT];\n\tboolean_t header_printed;\n\tboolean_t read_failed;\n\tboolean_t cksum_valid;\n} zdb_label_t;\n\nstatic void\nprint_label_header(zdb_label_t *label, int l)\n{\n\n\tif (dump_opt['q'])\n\t\treturn;\n\n\tif (label->header_printed == B_TRUE)\n\t\treturn;\n\n\t(void) printf(\"------------------------------------\\n\");\n\t(void) printf(\"LABEL %d %s\\n\", l,\n\t    label->cksum_valid ? \"\" : \"(Bad label cksum)\");\n\t(void) printf(\"------------------------------------\\n\");\n\n\tlabel->header_printed = B_TRUE;\n}\n\nstatic void\nprint_l2arc_header(void)\n{\n\t(void) printf(\"------------------------------------\\n\");\n\t(void) printf(\"L2ARC device header\\n\");\n\t(void) printf(\"------------------------------------\\n\");\n}\n\nstatic void\nprint_l2arc_log_blocks(void)\n{\n\t(void) printf(\"------------------------------------\\n\");\n\t(void) printf(\"L2ARC device log blocks\\n\");\n\t(void) printf(\"------------------------------------\\n\");\n}\n\nstatic void\ndump_l2arc_log_entries(uint64_t log_entries,\n    l2arc_log_ent_phys_t *le, uint64_t i)\n{\n\tfor (int j = 0; j < log_entries; j++) {\n\t\tdva_t dva = le[j].le_dva;\n\t\t(void) printf(\"lb[%4llu]\\tle[%4d]\\tDVA asize: %llu, \"\n\t\t    \"vdev: %llu, offset: %llu\\n\",\n\t\t    (u_longlong_t)i, j + 1,\n\t\t    (u_longlong_t)DVA_GET_ASIZE(&dva),\n\t\t    (u_longlong_t)DVA_GET_VDEV(&dva),\n\t\t    (u_longlong_t)DVA_GET_OFFSET(&dva));\n\t\t(void) printf(\"|\\t\\t\\t\\tbirth: %llu\\n\",\n\t\t    (u_longlong_t)le[j].le_birth);\n\t\t(void) printf(\"|\\t\\t\\t\\tlsize: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_LSIZE((&le[j])->le_prop));\n\t\t(void) printf(\"|\\t\\t\\t\\tpsize: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_PSIZE((&le[j])->le_prop));\n\t\t(void) printf(\"|\\t\\t\\t\\tcompr: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_COMPRESS((&le[j])->le_prop));\n\t\t(void) printf(\"|\\t\\t\\t\\tcomplevel: %llu\\n\",\n\t\t    (u_longlong_t)(&le[j])->le_complevel);\n\t\t(void) printf(\"|\\t\\t\\t\\ttype: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_TYPE((&le[j])->le_prop));\n\t\t(void) printf(\"|\\t\\t\\t\\tprotected: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_PROTECTED((&le[j])->le_prop));\n\t\t(void) printf(\"|\\t\\t\\t\\tprefetch: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_PREFETCH((&le[j])->le_prop));\n\t\t(void) printf(\"|\\t\\t\\t\\taddress: %llu\\n\",\n\t\t    (u_longlong_t)le[j].le_daddr);\n\t\t(void) printf(\"|\\t\\t\\t\\tARC state: %llu\\n\",\n\t\t    (u_longlong_t)L2BLK_GET_STATE((&le[j])->le_prop));\n\t\t(void) printf(\"|\\n\");\n\t}\n\t(void) printf(\"\\n\");\n}\n\nstatic void\ndump_l2arc_log_blkptr(const l2arc_log_blkptr_t *lbps)\n{\n\t(void) printf(\"|\\t\\tdaddr: %llu\\n\", (u_longlong_t)lbps->lbp_daddr);\n\t(void) printf(\"|\\t\\tpayload_asize: %llu\\n\",\n\t    (u_longlong_t)lbps->lbp_payload_asize);\n\t(void) printf(\"|\\t\\tpayload_start: %llu\\n\",\n\t    (u_longlong_t)lbps->lbp_payload_start);\n\t(void) printf(\"|\\t\\tlsize: %llu\\n\",\n\t    (u_longlong_t)L2BLK_GET_LSIZE(lbps->lbp_prop));\n\t(void) printf(\"|\\t\\tasize: %llu\\n\",\n\t    (u_longlong_t)L2BLK_GET_PSIZE(lbps->lbp_prop));\n\t(void) printf(\"|\\t\\tcompralgo: %llu\\n\",\n\t    (u_longlong_t)L2BLK_GET_COMPRESS(lbps->lbp_prop));\n\t(void) printf(\"|\\t\\tcksumalgo: %llu\\n\",\n\t    (u_longlong_t)L2BLK_GET_CHECKSUM(lbps->lbp_prop));\n\t(void) printf(\"|\\n\\n\");\n}\n\nstatic void\ndump_l2arc_log_blocks(int fd, const l2arc_dev_hdr_phys_t *l2dhdr,\n    l2arc_dev_hdr_phys_t *rebuild)\n{\n\tl2arc_log_blk_phys_t this_lb;\n\tuint64_t asize;\n\tl2arc_log_blkptr_t lbps[2];\n\tabd_t *abd;\n\tzio_cksum_t cksum;\n\tint failed = 0;\n\tl2arc_dev_t dev;\n\n\tif (!dump_opt['q'])\n\t\tprint_l2arc_log_blocks();\n\tmemcpy(lbps, l2dhdr->dh_start_lbps, sizeof (lbps));\n\n\tdev.l2ad_evict = l2dhdr->dh_evict;\n\tdev.l2ad_start = l2dhdr->dh_start;\n\tdev.l2ad_end = l2dhdr->dh_end;\n\n\tif (l2dhdr->dh_start_lbps[0].lbp_daddr == 0) {\n\t\t \n\t\tif (!dump_opt['q']) {\n\t\t\t(void) printf(\"No log blocks to read\\n\");\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\treturn;\n\t} else {\n\t\tdev.l2ad_hand = lbps[0].lbp_daddr +\n\t\t    L2BLK_GET_PSIZE((&lbps[0])->lbp_prop);\n\t}\n\n\tdev.l2ad_first = !!(l2dhdr->dh_flags & L2ARC_DEV_HDR_EVICT_FIRST);\n\n\tfor (;;) {\n\t\tif (!l2arc_log_blkptr_valid(&dev, &lbps[0]))\n\t\t\tbreak;\n\n\t\t \n\t\tasize = L2BLK_GET_PSIZE((&lbps[0])->lbp_prop);\n\t\tif (pread64(fd, &this_lb, asize, lbps[0].lbp_daddr) != asize) {\n\t\t\tif (!dump_opt['q']) {\n\t\t\t\t(void) printf(\"Error while reading next log \"\n\t\t\t\t    \"block\\n\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tfletcher_4_native_varsize(&this_lb, asize, &cksum);\n\t\tif (!ZIO_CHECKSUM_EQUAL(cksum, lbps[0].lbp_cksum)) {\n\t\t\tfailed++;\n\t\t\tif (!dump_opt['q']) {\n\t\t\t\t(void) printf(\"Invalid cksum\\n\");\n\t\t\t\tdump_l2arc_log_blkptr(&lbps[0]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (L2BLK_GET_COMPRESS((&lbps[0])->lbp_prop)) {\n\t\tcase ZIO_COMPRESS_OFF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabd = abd_alloc_for_io(asize, B_TRUE);\n\t\t\tabd_copy_from_buf_off(abd, &this_lb, 0, asize);\n\t\t\tif (zio_decompress_data(L2BLK_GET_COMPRESS(\n\t\t\t    (&lbps[0])->lbp_prop), abd, &this_lb,\n\t\t\t    asize, sizeof (this_lb), NULL) != 0) {\n\t\t\t\t(void) printf(\"L2ARC block decompression \"\n\t\t\t\t    \"failed\\n\");\n\t\t\t\tabd_free(abd);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tabd_free(abd);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this_lb.lb_magic == BSWAP_64(L2ARC_LOG_BLK_MAGIC))\n\t\t\tbyteswap_uint64_array(&this_lb, sizeof (this_lb));\n\t\tif (this_lb.lb_magic != L2ARC_LOG_BLK_MAGIC) {\n\t\t\tif (!dump_opt['q'])\n\t\t\t\t(void) printf(\"Invalid log block magic\\n\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\trebuild->dh_lb_count++;\n\t\trebuild->dh_lb_asize += asize;\n\t\tif (dump_opt['l'] > 1 && !dump_opt['q']) {\n\t\t\t(void) printf(\"lb[%4llu]\\tmagic: %llu\\n\",\n\t\t\t    (u_longlong_t)rebuild->dh_lb_count,\n\t\t\t    (u_longlong_t)this_lb.lb_magic);\n\t\t\tdump_l2arc_log_blkptr(&lbps[0]);\n\t\t}\n\n\t\tif (dump_opt['l'] > 2 && !dump_opt['q'])\n\t\t\tdump_l2arc_log_entries(l2dhdr->dh_log_entries,\n\t\t\t    this_lb.lb_entries,\n\t\t\t    rebuild->dh_lb_count);\n\n\t\tif (l2arc_range_check_overlap(lbps[1].lbp_payload_start,\n\t\t    lbps[0].lbp_payload_start, dev.l2ad_evict) &&\n\t\t    !dev.l2ad_first)\n\t\t\tbreak;\n\n\t\tlbps[0] = lbps[1];\n\t\tlbps[1] = this_lb.lb_prev_lbp;\n\t}\nout:\n\tif (!dump_opt['q']) {\n\t\t(void) printf(\"log_blk_count:\\t %llu with valid cksum\\n\",\n\t\t    (u_longlong_t)rebuild->dh_lb_count);\n\t\t(void) printf(\"\\t\\t %d with invalid cksum\\n\", failed);\n\t\t(void) printf(\"log_blk_asize:\\t %llu\\n\\n\",\n\t\t    (u_longlong_t)rebuild->dh_lb_asize);\n\t}\n}\n\nstatic int\ndump_l2arc_header(int fd)\n{\n\tl2arc_dev_hdr_phys_t l2dhdr = {0}, rebuild = {0};\n\tint error = B_FALSE;\n\n\tif (pread64(fd, &l2dhdr, sizeof (l2dhdr),\n\t    VDEV_LABEL_START_SIZE) != sizeof (l2dhdr)) {\n\t\terror = B_TRUE;\n\t} else {\n\t\tif (l2dhdr.dh_magic == BSWAP_64(L2ARC_DEV_HDR_MAGIC))\n\t\t\tbyteswap_uint64_array(&l2dhdr, sizeof (l2dhdr));\n\n\t\tif (l2dhdr.dh_magic != L2ARC_DEV_HDR_MAGIC)\n\t\t\terror = B_TRUE;\n\t}\n\n\tif (error) {\n\t\t(void) printf(\"L2ARC device header not found\\n\\n\");\n\t\t \n\t\treturn (0);\n\t} else if (!dump_opt['q']) {\n\t\tprint_l2arc_header();\n\n\t\t(void) printf(\"    magic: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_magic);\n\t\t(void) printf(\"    version: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_version);\n\t\t(void) printf(\"    pool_guid: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_spa_guid);\n\t\t(void) printf(\"    flags: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_flags);\n\t\t(void) printf(\"    start_lbps[0]: %llu\\n\",\n\t\t    (u_longlong_t)\n\t\t    l2dhdr.dh_start_lbps[0].lbp_daddr);\n\t\t(void) printf(\"    start_lbps[1]: %llu\\n\",\n\t\t    (u_longlong_t)\n\t\t    l2dhdr.dh_start_lbps[1].lbp_daddr);\n\t\t(void) printf(\"    log_blk_ent: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_log_entries);\n\t\t(void) printf(\"    start: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_start);\n\t\t(void) printf(\"    end: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_end);\n\t\t(void) printf(\"    evict: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_evict);\n\t\t(void) printf(\"    lb_asize_refcount: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_lb_asize);\n\t\t(void) printf(\"    lb_count_refcount: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_lb_count);\n\t\t(void) printf(\"    trim_action_time: %llu\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_trim_action_time);\n\t\t(void) printf(\"    trim_state: %llu\\n\\n\",\n\t\t    (u_longlong_t)l2dhdr.dh_trim_state);\n\t}\n\n\tdump_l2arc_log_blocks(fd, &l2dhdr, &rebuild);\n\t \n\tif (l2dhdr.dh_lb_asize > rebuild.dh_lb_asize ||\n\t    l2dhdr.dh_lb_count > rebuild.dh_lb_count)\n\t\treturn (1);\n\n\treturn (0);\n}\n\nstatic void\ndump_config_from_label(zdb_label_t *label, size_t buflen, int l)\n{\n\tif (dump_opt['q'])\n\t\treturn;\n\n\tif ((dump_opt['l'] < 3) && (first_label(label->config) != l))\n\t\treturn;\n\n\tprint_label_header(label, l);\n\tdump_nvlist(label->config_nv, 4);\n\tprint_label_numbers(\"    labels = \", label->config);\n\n\tif (dump_opt['l'] >= 2)\n\t\tdump_nvlist_stats(label->config_nv, buflen);\n}\n\n#define\tZDB_MAX_UB_HEADER_SIZE 32\n\nstatic void\ndump_label_uberblocks(zdb_label_t *label, uint64_t ashift, int label_num)\n{\n\n\tvdev_t vd;\n\tchar header[ZDB_MAX_UB_HEADER_SIZE];\n\n\tvd.vdev_ashift = ashift;\n\tvd.vdev_top = &vd;\n\n\tfor (int i = 0; i < VDEV_UBERBLOCK_COUNT(&vd); i++) {\n\t\tuint64_t uoff = VDEV_UBERBLOCK_OFFSET(&vd, i);\n\t\tuberblock_t *ub = (void *)((char *)&label->label + uoff);\n\t\tcksum_record_t *rec = label->uberblocks[i];\n\n\t\tif (rec == NULL) {\n\t\t\tif (dump_opt['u'] >= 2) {\n\t\t\t\tprint_label_header(label, label_num);\n\t\t\t\t(void) printf(\"    Uberblock[%d] invalid\\n\", i);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((dump_opt['u'] < 3) && (first_label(rec) != label_num))\n\t\t\tcontinue;\n\n\t\tif ((dump_opt['u'] < 4) &&\n\t\t    (ub->ub_mmp_magic == MMP_MAGIC) && ub->ub_mmp_delay &&\n\t\t    (i >= VDEV_UBERBLOCK_COUNT(&vd) - MMP_BLOCKS_PER_LABEL))\n\t\t\tcontinue;\n\n\t\tprint_label_header(label, label_num);\n\t\t(void) snprintf(header, ZDB_MAX_UB_HEADER_SIZE,\n\t\t    \"    Uberblock[%d]\\n\", i);\n\t\tdump_uberblock(ub, header, \"\");\n\t\tprint_label_numbers(\"        labels = \", rec);\n\t}\n}\n\nstatic char curpath[PATH_MAX];\n\n \nstatic int\ndump_path_impl(objset_t *os, uint64_t obj, char *name, uint64_t *retobj)\n{\n\tint err;\n\tboolean_t header = B_TRUE;\n\tuint64_t child_obj;\n\tchar *s;\n\tdmu_buf_t *db;\n\tdmu_object_info_t doi;\n\n\tif ((s = strchr(name, '/')) != NULL)\n\t\t*s = '\\0';\n\terr = zap_lookup(os, obj, name, 8, 1, &child_obj);\n\n\t(void) strlcat(curpath, name, sizeof (curpath));\n\n\tif (err != 0) {\n\t\t(void) fprintf(stderr, \"failed to lookup %s: %s\\n\",\n\t\t    curpath, strerror(err));\n\t\treturn (err);\n\t}\n\n\tchild_obj = ZFS_DIRENT_OBJ(child_obj);\n\terr = sa_buf_hold(os, child_obj, FTAG, &db);\n\tif (err != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"failed to get SA dbuf for obj %llu: %s\\n\",\n\t\t    (u_longlong_t)child_obj, strerror(err));\n\t\treturn (EINVAL);\n\t}\n\tdmu_object_info_from_db(db, &doi);\n\tsa_buf_rele(db, FTAG);\n\n\tif (doi.doi_bonus_type != DMU_OT_SA &&\n\t    doi.doi_bonus_type != DMU_OT_ZNODE) {\n\t\t(void) fprintf(stderr, \"invalid bonus type %d for obj %llu\\n\",\n\t\t    doi.doi_bonus_type, (u_longlong_t)child_obj);\n\t\treturn (EINVAL);\n\t}\n\n\tif (dump_opt['v'] > 6) {\n\t\t(void) printf(\"obj=%llu %s type=%d bonustype=%d\\n\",\n\t\t    (u_longlong_t)child_obj, curpath, doi.doi_type,\n\t\t    doi.doi_bonus_type);\n\t}\n\n\t(void) strlcat(curpath, \"/\", sizeof (curpath));\n\n\tswitch (doi.doi_type) {\n\tcase DMU_OT_DIRECTORY_CONTENTS:\n\t\tif (s != NULL && *(s + 1) != '\\0')\n\t\t\treturn (dump_path_impl(os, child_obj, s + 1, retobj));\n\t\tzfs_fallthrough;\n\tcase DMU_OT_PLAIN_FILE_CONTENTS:\n\t\tif (retobj != NULL) {\n\t\t\t*retobj = child_obj;\n\t\t} else {\n\t\t\tdump_object(os, child_obj, dump_opt['v'], &header,\n\t\t\t    NULL, 0);\n\t\t}\n\t\treturn (0);\n\tdefault:\n\t\t(void) fprintf(stderr, \"object %llu has non-file/directory \"\n\t\t    \"type %d\\n\", (u_longlong_t)obj, doi.doi_type);\n\t\tbreak;\n\t}\n\n\treturn (EINVAL);\n}\n\n \nstatic int\ndump_path(char *ds, char *path, uint64_t *retobj)\n{\n\tint err;\n\tobjset_t *os;\n\tuint64_t root_obj;\n\n\terr = open_objset(ds, FTAG, &os);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = zap_lookup(os, MASTER_NODE_OBJ, ZFS_ROOT_OBJ, 8, 1, &root_obj);\n\tif (err != 0) {\n\t\t(void) fprintf(stderr, \"can't lookup root znode: %s\\n\",\n\t\t    strerror(err));\n\t\tclose_objset(os, FTAG);\n\t\treturn (EINVAL);\n\t}\n\n\t(void) snprintf(curpath, sizeof (curpath), \"dataset=%s path=/\", ds);\n\n\terr = dump_path_impl(os, root_obj, path, retobj);\n\n\tclose_objset(os, FTAG);\n\treturn (err);\n}\n\nstatic int\ndump_backup_bytes(objset_t *os, void *buf, int len, void *arg)\n{\n\tconst char *p = (const char *)buf;\n\tssize_t nwritten;\n\n\t(void) os;\n\t(void) arg;\n\n\t \n\twhile ((nwritten = write(STDOUT_FILENO, p, len)) < len) {\n\t\tif (nwritten < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn (errno);\n\t\t}\n\t\tp += nwritten;\n\t\tlen -= nwritten;\n\t}\n\n\treturn (0);\n}\n\nstatic void\ndump_backup(const char *pool, uint64_t objset_id, const char *flagstr)\n{\n\tboolean_t embed = B_FALSE;\n\tboolean_t large_block = B_FALSE;\n\tboolean_t compress = B_FALSE;\n\tboolean_t raw = B_FALSE;\n\n\tconst char *c;\n\tfor (c = flagstr; c != NULL && *c != '\\0'; c++) {\n\t\tswitch (*c) {\n\t\t\tcase 'e':\n\t\t\t\tembed = B_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tlarge_block = B_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcompress = B_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\traw = B_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"dump_backup: invalid flag \"\n\t\t\t\t    \"'%c'\\n\", *c);\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (isatty(STDOUT_FILENO)) {\n\t\tfprintf(stderr, \"dump_backup: stream cannot be written \"\n\t\t    \"to a terminal\\n\");\n\t\treturn;\n\t}\n\n\toffset_t off = 0;\n\tdmu_send_outparams_t out = {\n\t    .dso_outfunc = dump_backup_bytes,\n\t    .dso_dryrun  = B_FALSE,\n\t};\n\n\tint err = dmu_send_obj(pool, objset_id,  0, embed,\n\t    large_block, compress, raw,   B_FALSE, STDOUT_FILENO,\n\t    &off, &out);\n\tif (err != 0) {\n\t\tfprintf(stderr, \"dump_backup: dmu_send_obj: %s\\n\",\n\t\t    strerror(err));\n\t\treturn;\n\t}\n}\n\nstatic int\nzdb_copy_object(objset_t *os, uint64_t srcobj, char *destfile)\n{\n\tint err = 0;\n\tuint64_t size, readsize, oursize, offset;\n\tssize_t writesize;\n\tsa_handle_t *hdl;\n\n\t(void) printf(\"Copying object %\" PRIu64 \" to file %s\\n\", srcobj,\n\t    destfile);\n\n\tVERIFY3P(os, ==, sa_os);\n\tif ((err = sa_handle_get(os, srcobj, NULL, SA_HDL_PRIVATE, &hdl))) {\n\t\t(void) printf(\"Failed to get handle for SA znode\\n\");\n\t\treturn (err);\n\t}\n\tif ((err = sa_lookup(hdl, sa_attr_table[ZPL_SIZE], &size, 8))) {\n\t\t(void) sa_handle_destroy(hdl);\n\t\treturn (err);\n\t}\n\t(void) sa_handle_destroy(hdl);\n\n\t(void) printf(\"Object %\" PRIu64 \" is %\" PRIu64 \" bytes\\n\", srcobj,\n\t    size);\n\tif (size == 0) {\n\t\treturn (EINVAL);\n\t}\n\n\tint fd = open(destfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n\tif (fd == -1)\n\t\treturn (errno);\n\t \n\toursize = MIN(size, 1 << 20);\n\toffset = 0;\n\tchar *buf = kmem_alloc(oursize, KM_NOSLEEP);\n\tif (buf == NULL) {\n\t\t(void) close(fd);\n\t\treturn (ENOMEM);\n\t}\n\n\twhile (offset < size) {\n\t\treadsize = MIN(size - offset, 1 << 20);\n\t\terr = dmu_read(os, srcobj, offset, readsize, buf, 0);\n\t\tif (err != 0) {\n\t\t\t(void) printf(\"got error %u from dmu_read\\n\", err);\n\t\t\tkmem_free(buf, oursize);\n\t\t\t(void) close(fd);\n\t\t\treturn (err);\n\t\t}\n\t\tif (dump_opt['v'] > 3) {\n\t\t\t(void) printf(\"Read offset=%\" PRIu64 \" size=%\" PRIu64\n\t\t\t    \" error=%d\\n\", offset, readsize, err);\n\t\t}\n\n\t\twritesize = write(fd, buf, readsize);\n\t\tif (writesize < 0) {\n\t\t\terr = errno;\n\t\t\tbreak;\n\t\t} else if (writesize != readsize) {\n\t\t\t \n\t\t\t(void) fprintf(stderr, \"Short write, only wrote %llu of\"\n\t\t\t    \" %\" PRIu64 \" bytes, exiting...\\n\",\n\t\t\t    (u_longlong_t)writesize, readsize);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += readsize;\n\t}\n\n\t(void) close(fd);\n\n\tif (buf != NULL)\n\t\tkmem_free(buf, oursize);\n\n\treturn (err);\n}\n\nstatic boolean_t\nlabel_cksum_valid(vdev_label_t *label, uint64_t offset)\n{\n\tzio_checksum_info_t *ci = &zio_checksum_table[ZIO_CHECKSUM_LABEL];\n\tzio_cksum_t expected_cksum;\n\tzio_cksum_t actual_cksum;\n\tzio_cksum_t verifier;\n\tzio_eck_t *eck;\n\tint byteswap;\n\n\tvoid *data = (char *)label + offsetof(vdev_label_t, vl_vdev_phys);\n\teck = (zio_eck_t *)((char *)(data) + VDEV_PHYS_SIZE) - 1;\n\n\toffset += offsetof(vdev_label_t, vl_vdev_phys);\n\tZIO_SET_CHECKSUM(&verifier, offset, 0, 0, 0);\n\n\tbyteswap = (eck->zec_magic == BSWAP_64(ZEC_MAGIC));\n\tif (byteswap)\n\t\tbyteswap_uint64_array(&verifier, sizeof (zio_cksum_t));\n\n\texpected_cksum = eck->zec_cksum;\n\teck->zec_cksum = verifier;\n\n\tabd_t *abd = abd_get_from_buf(data, VDEV_PHYS_SIZE);\n\tci->ci_func[byteswap](abd, VDEV_PHYS_SIZE, NULL, &actual_cksum);\n\tabd_free(abd);\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(&expected_cksum, sizeof (zio_cksum_t));\n\n\tif (ZIO_CHECKSUM_EQUAL(actual_cksum, expected_cksum))\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\nstatic int\ndump_label(const char *dev)\n{\n\tchar path[MAXPATHLEN];\n\tzdb_label_t labels[VDEV_LABELS] = {{{{0}}}};\n\tuint64_t psize, ashift, l2cache;\n\tstruct stat64 statbuf;\n\tboolean_t config_found = B_FALSE;\n\tboolean_t error = B_FALSE;\n\tboolean_t read_l2arc_header = B_FALSE;\n\tavl_tree_t config_tree;\n\tavl_tree_t uberblock_tree;\n\tvoid *node, *cookie;\n\tint fd;\n\n\t \n\t(void) strlcpy(path, dev, sizeof (path));\n\tif (dev[0] != '/' && stat64(path, &statbuf) != 0) {\n\t\tint error;\n\n\t\terror = zfs_resolve_shortname(dev, path, MAXPATHLEN);\n\t\tif (error == 0 && zfs_dev_is_whole_disk(path)) {\n\t\t\tif (zfs_append_partition(path, MAXPATHLEN) == -1)\n\t\t\t\terror = ENOENT;\n\t\t}\n\n\t\tif (error || (stat64(path, &statbuf) != 0)) {\n\t\t\t(void) printf(\"failed to find device %s, try \"\n\t\t\t    \"specifying absolute path instead\\n\", dev);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif ((fd = open64(path, O_RDONLY)) < 0) {\n\t\t(void) printf(\"cannot open '%s': %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (fstat64_blk(fd, &statbuf) != 0) {\n\t\t(void) printf(\"failed to stat '%s': %s\\n\", path,\n\t\t    strerror(errno));\n\t\t(void) close(fd);\n\t\texit(1);\n\t}\n\n\tif (S_ISBLK(statbuf.st_mode) && zfs_dev_flush(fd) != 0)\n\t\t(void) printf(\"failed to invalidate cache '%s' : %s\\n\", path,\n\t\t    strerror(errno));\n\n\tavl_create(&config_tree, cksum_record_compare,\n\t    sizeof (cksum_record_t), offsetof(cksum_record_t, link));\n\tavl_create(&uberblock_tree, cksum_record_compare,\n\t    sizeof (cksum_record_t), offsetof(cksum_record_t, link));\n\n\tpsize = statbuf.st_size;\n\tpsize = P2ALIGN(psize, (uint64_t)sizeof (vdev_label_t));\n\tashift = SPA_MINBLOCKSHIFT;\n\n\t \n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tzdb_label_t *label = &labels[l];\n\t\tchar *buf = label->label.vl_vdev_phys.vp_nvlist;\n\t\tsize_t buflen = sizeof (label->label.vl_vdev_phys.vp_nvlist);\n\t\tnvlist_t *config;\n\t\tcksum_record_t *rec;\n\t\tzio_cksum_t cksum;\n\t\tvdev_t vd;\n\n\t\tlabel->label_offset = vdev_label_offset(psize, l, 0);\n\n\t\tif (pread64(fd, &label->label, sizeof (label->label),\n\t\t    label->label_offset) != sizeof (label->label)) {\n\t\t\tif (!dump_opt['q'])\n\t\t\t\t(void) printf(\"failed to read label %d\\n\", l);\n\t\t\tlabel->read_failed = B_TRUE;\n\t\t\terror = B_TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlabel->read_failed = B_FALSE;\n\t\tlabel->cksum_valid = label_cksum_valid(&label->label,\n\t\t    label->label_offset);\n\n\t\tif (nvlist_unpack(buf, buflen, &config, 0) == 0) {\n\t\t\tnvlist_t *vdev_tree = NULL;\n\t\t\tsize_t size;\n\n\t\t\tif ((nvlist_lookup_nvlist(config,\n\t\t\t    ZPOOL_CONFIG_VDEV_TREE, &vdev_tree) != 0) ||\n\t\t\t    (nvlist_lookup_uint64(vdev_tree,\n\t\t\t    ZPOOL_CONFIG_ASHIFT, &ashift) != 0))\n\t\t\t\tashift = SPA_MINBLOCKSHIFT;\n\n\t\t\tif (nvlist_size(config, &size, NV_ENCODE_XDR) != 0)\n\t\t\t\tsize = buflen;\n\n\t\t\t \n\t\t\tif (!read_l2arc_header) {\n\t\t\t\tif (nvlist_lookup_uint64(config,\n\t\t\t\t    ZPOOL_CONFIG_POOL_STATE, &l2cache) == 0 &&\n\t\t\t\t    l2cache == POOL_STATE_L2CACHE) {\n\t\t\t\t\tread_l2arc_header = B_TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfletcher_4_native_varsize(buf, size, &cksum);\n\t\t\trec = cksum_record_insert(&config_tree, &cksum, l);\n\n\t\t\tlabel->config = rec;\n\t\t\tlabel->config_nv = config;\n\t\t\tconfig_found = B_TRUE;\n\t\t} else {\n\t\t\terror = B_TRUE;\n\t\t}\n\n\t\tvd.vdev_ashift = ashift;\n\t\tvd.vdev_top = &vd;\n\n\t\tfor (int i = 0; i < VDEV_UBERBLOCK_COUNT(&vd); i++) {\n\t\t\tuint64_t uoff = VDEV_UBERBLOCK_OFFSET(&vd, i);\n\t\t\tuberblock_t *ub = (void *)((char *)label + uoff);\n\n\t\t\tif (uberblock_verify(ub))\n\t\t\t\tcontinue;\n\n\t\t\tfletcher_4_native_varsize(ub, sizeof (*ub), &cksum);\n\t\t\trec = cksum_record_insert(&uberblock_tree, &cksum, l);\n\n\t\t\tlabel->uberblocks[i] = rec;\n\t\t}\n\t}\n\n\t \n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tzdb_label_t *label = &labels[l];\n\t\tsize_t buflen = sizeof (label->label.vl_vdev_phys.vp_nvlist);\n\n\t\tif (label->read_failed == B_TRUE)\n\t\t\tcontinue;\n\n\t\tif (label->config_nv) {\n\t\t\tdump_config_from_label(label, buflen, l);\n\t\t} else {\n\t\t\tif (!dump_opt['q'])\n\t\t\t\t(void) printf(\"failed to unpack label %d\\n\", l);\n\t\t}\n\n\t\tif (dump_opt['u'])\n\t\t\tdump_label_uberblocks(label, ashift, l);\n\n\t\tnvlist_free(label->config_nv);\n\t}\n\n\t \n\tif (read_l2arc_header)\n\t\terror |= dump_l2arc_header(fd);\n\n\tcookie = NULL;\n\twhile ((node = avl_destroy_nodes(&config_tree, &cookie)) != NULL)\n\t\tumem_free(node, sizeof (cksum_record_t));\n\n\tcookie = NULL;\n\twhile ((node = avl_destroy_nodes(&uberblock_tree, &cookie)) != NULL)\n\t\tumem_free(node, sizeof (cksum_record_t));\n\n\tavl_destroy(&config_tree);\n\tavl_destroy(&uberblock_tree);\n\n\t(void) close(fd);\n\n\treturn (config_found == B_FALSE ? 2 :\n\t    (error == B_TRUE ? 1 : 0));\n}\n\nstatic uint64_t dataset_feature_count[SPA_FEATURES];\nstatic uint64_t global_feature_count[SPA_FEATURES];\nstatic uint64_t remap_deadlist_count = 0;\n\nstatic int\ndump_one_objset(const char *dsname, void *arg)\n{\n\t(void) arg;\n\tint error;\n\tobjset_t *os;\n\tspa_feature_t f;\n\n\terror = open_objset(dsname, FTAG, &os);\n\tif (error != 0)\n\t\treturn (0);\n\n\tfor (f = 0; f < SPA_FEATURES; f++) {\n\t\tif (!dsl_dataset_feature_is_active(dmu_objset_ds(os), f))\n\t\t\tcontinue;\n\t\tASSERT(spa_feature_table[f].fi_flags &\n\t\t    ZFEATURE_FLAG_PER_DATASET);\n\t\tdataset_feature_count[f]++;\n\t}\n\n\tif (dsl_dataset_remap_deadlist_exists(dmu_objset_ds(os))) {\n\t\tremap_deadlist_count++;\n\t}\n\n\tfor (dsl_bookmark_node_t *dbn =\n\t    avl_first(&dmu_objset_ds(os)->ds_bookmarks); dbn != NULL;\n\t    dbn = AVL_NEXT(&dmu_objset_ds(os)->ds_bookmarks, dbn)) {\n\t\tmos_obj_refd(dbn->dbn_phys.zbm_redaction_obj);\n\t\tif (dbn->dbn_phys.zbm_redaction_obj != 0)\n\t\t\tglobal_feature_count[SPA_FEATURE_REDACTION_BOOKMARKS]++;\n\t\tif (dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN)\n\t\t\tglobal_feature_count[SPA_FEATURE_BOOKMARK_WRITTEN]++;\n\t}\n\n\tif (dsl_deadlist_is_open(&dmu_objset_ds(os)->ds_dir->dd_livelist) &&\n\t    !dmu_objset_is_snapshot(os)) {\n\t\tglobal_feature_count[SPA_FEATURE_LIVELIST]++;\n\t}\n\n\tdump_objset(os);\n\tclose_objset(os, FTAG);\n\tfuid_table_destroy();\n\treturn (0);\n}\n\n \n#define\tPSIZE_HISTO_SIZE (SPA_OLD_MAXBLOCKSIZE / SPA_MINBLOCKSIZE + 2)\ntypedef struct zdb_blkstats {\n\tuint64_t zb_asize;\n\tuint64_t zb_lsize;\n\tuint64_t zb_psize;\n\tuint64_t zb_count;\n\tuint64_t zb_gangs;\n\tuint64_t zb_ditto_samevdev;\n\tuint64_t zb_ditto_same_ms;\n\tuint64_t zb_psize_histogram[PSIZE_HISTO_SIZE];\n} zdb_blkstats_t;\n\n \n#define\tZDB_OT_DEFERRED\t(DMU_OT_NUMTYPES + 0)\n#define\tZDB_OT_DITTO\t(DMU_OT_NUMTYPES + 1)\n#define\tZDB_OT_OTHER\t(DMU_OT_NUMTYPES + 2)\n#define\tZDB_OT_TOTAL\t(DMU_OT_NUMTYPES + 3)\n\nstatic const char *zdb_ot_extname[] = {\n\t\"deferred free\",\n\t\"dedup ditto\",\n\t\"other\",\n\t\"Total\",\n};\n\n#define\tZB_TOTAL\tDN_MAX_LEVELS\n#define\tSPA_MAX_FOR_16M\t(SPA_MAXBLOCKSHIFT+1)\n\ntypedef struct zdb_brt_entry {\n\tdva_t\t\tzbre_dva;\n\tuint64_t\tzbre_refcount;\n\tavl_node_t\tzbre_node;\n} zdb_brt_entry_t;\n\ntypedef struct zdb_cb {\n\tzdb_blkstats_t\tzcb_type[ZB_TOTAL + 1][ZDB_OT_TOTAL + 1];\n\tuint64_t\tzcb_removing_size;\n\tuint64_t\tzcb_checkpoint_size;\n\tuint64_t\tzcb_dedup_asize;\n\tuint64_t\tzcb_dedup_blocks;\n\tuint64_t\tzcb_clone_asize;\n\tuint64_t\tzcb_clone_blocks;\n\tuint64_t\tzcb_psize_count[SPA_MAX_FOR_16M];\n\tuint64_t\tzcb_lsize_count[SPA_MAX_FOR_16M];\n\tuint64_t\tzcb_asize_count[SPA_MAX_FOR_16M];\n\tuint64_t\tzcb_psize_len[SPA_MAX_FOR_16M];\n\tuint64_t\tzcb_lsize_len[SPA_MAX_FOR_16M];\n\tuint64_t\tzcb_asize_len[SPA_MAX_FOR_16M];\n\tuint64_t\tzcb_psize_total;\n\tuint64_t\tzcb_lsize_total;\n\tuint64_t\tzcb_asize_total;\n\tuint64_t\tzcb_embedded_blocks[NUM_BP_EMBEDDED_TYPES];\n\tuint64_t\tzcb_embedded_histogram[NUM_BP_EMBEDDED_TYPES]\n\t    [BPE_PAYLOAD_SIZE + 1];\n\tuint64_t\tzcb_start;\n\thrtime_t\tzcb_lastprint;\n\tuint64_t\tzcb_totalasize;\n\tuint64_t\tzcb_errors[256];\n\tint\t\tzcb_readfails;\n\tint\t\tzcb_haderrors;\n\tspa_t\t\t*zcb_spa;\n\tuint32_t\t**zcb_vd_obsolete_counts;\n\tavl_tree_t\tzcb_brt;\n\tboolean_t\tzcb_brt_is_active;\n} zdb_cb_t;\n\n \nstatic boolean_t\nsame_metaslab(spa_t *spa, uint64_t vdev, uint64_t off1, uint64_t off2)\n{\n\tvdev_t *vd = vdev_lookup_top(spa, vdev);\n\tuint64_t ms_shift = vd->vdev_ms_shift;\n\n\treturn ((off1 >> ms_shift) == (off2 >> ms_shift));\n}\n\n \ntypedef struct one_histo {\n\tconst char *name;\n\tuint64_t *count;\n\tuint64_t *len;\n\tuint64_t cumulative;\n} one_histo_t;\n\n \n#define\tNUM_HISTO 3\n\n \nstatic void\ndump_size_histograms(zdb_cb_t *zcb)\n{\n\t \n\tchar numbuf[32];\n\n\t \n\tconst char blocksize_title1[] = \"block\";\n\tconst char blocksize_title2[] = \"size\";\n\tconst char count_title[] = \"Count\";\n\tconst char length_title[] = \"Size\";\n\tconst char cumulative_title[] = \"Cum.\";\n\n\t \n\tone_histo_t parm_histo[NUM_HISTO];\n\n\tparm_histo[0].name = \"psize\";\n\tparm_histo[0].count = zcb->zcb_psize_count;\n\tparm_histo[0].len = zcb->zcb_psize_len;\n\tparm_histo[0].cumulative = 0;\n\n\tparm_histo[1].name = \"lsize\";\n\tparm_histo[1].count = zcb->zcb_lsize_count;\n\tparm_histo[1].len = zcb->zcb_lsize_len;\n\tparm_histo[1].cumulative = 0;\n\n\tparm_histo[2].name = \"asize\";\n\tparm_histo[2].count = zcb->zcb_asize_count;\n\tparm_histo[2].len = zcb->zcb_asize_len;\n\tparm_histo[2].cumulative = 0;\n\n\n\t(void) printf(\"\\nBlock Size Histogram\\n\");\n\t \n\tif (dump_opt['P'])\n\t\t(void) printf(\"\\n%s\\t\", blocksize_title1);\n\telse\n\t\t(void) printf(\"\\n%7s   \", blocksize_title1);\n\n\tfor (int j = 0; j < NUM_HISTO; j++) {\n\t\tif (dump_opt['P']) {\n\t\t\tif (j < NUM_HISTO - 1) {\n\t\t\t\t(void) printf(\"%s\\t\\t\\t\", parm_histo[j].name);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t(void) printf(\"  %s\", parm_histo[j].name);\n\t\t\t}\n\t\t} else {\n\t\t\tif (j < NUM_HISTO - 1) {\n\t\t\t\t \n\t\t\t\t(void) printf(\"%-7s              \",\n\t\t\t\t    parm_histo[j].name);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t(void) printf(\"%s\", parm_histo[j].name);\n\t\t\t}\n\t\t}\n\t}\n\t(void) printf(\"\\n\");\n\n\t \n\tif (dump_opt['P']) {\n\t\t(void) printf(\"%s\\t\", blocksize_title2);\n\t} else {\n\t\t(void) printf(\"%7s \", blocksize_title2);\n\t}\n\n\tfor (int i = 0; i < NUM_HISTO; i++) {\n\t\tif (dump_opt['P']) {\n\t\t\t(void) printf(\"%s\\t%s\\t%s\\t\",\n\t\t\t    count_title, length_title, cumulative_title);\n\t\t} else {\n\t\t\t(void) printf(\"%7s%7s%7s\",\n\t\t\t    count_title, length_title, cumulative_title);\n\t\t}\n\t}\n\t(void) printf(\"\\n\");\n\n\t \n\tfor (int i = SPA_MINBLOCKSHIFT; i < SPA_MAX_FOR_16M; i++) {\n\n\t\t \n\t\tzdb_nicenum((1ULL << i), numbuf, sizeof (numbuf));\n\n\t\tif (dump_opt['P']) {\n\t\t\tprintf(\"%s\", numbuf);\n\t\t} else {\n\t\t\tprintf(\"%7s:\", numbuf);\n\t\t}\n\n\t\t \n\t\tfor (int j = 0; j < NUM_HISTO; j++) {\n\t\t\tparm_histo[j].cumulative += parm_histo[j].len[i];\n\n\t\t\tzdb_nicenum(parm_histo[j].count[i],\n\t\t\t    numbuf, sizeof (numbuf));\n\t\t\tif (dump_opt['P'])\n\t\t\t\t(void) printf(\"\\t%s\", numbuf);\n\t\t\telse\n\t\t\t\t(void) printf(\"%7s\", numbuf);\n\n\t\t\tzdb_nicenum(parm_histo[j].len[i],\n\t\t\t    numbuf, sizeof (numbuf));\n\t\t\tif (dump_opt['P'])\n\t\t\t\t(void) printf(\"\\t%s\", numbuf);\n\t\t\telse\n\t\t\t\t(void) printf(\"%7s\", numbuf);\n\n\t\t\tzdb_nicenum(parm_histo[j].cumulative,\n\t\t\t    numbuf, sizeof (numbuf));\n\t\t\tif (dump_opt['P'])\n\t\t\t\t(void) printf(\"\\t%s\", numbuf);\n\t\t\telse\n\t\t\t\t(void) printf(\"%7s\", numbuf);\n\t\t}\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\nstatic void\nzdb_count_block(zdb_cb_t *zcb, zilog_t *zilog, const blkptr_t *bp,\n    dmu_object_type_t type)\n{\n\tuint64_t refcnt = 0;\n\tint i;\n\n\tASSERT(type < ZDB_OT_TOTAL);\n\n\tif (zilog && zil_bp_tree_add(zilog, bp) != 0)\n\t\treturn;\n\n\tspa_config_enter(zcb->zcb_spa, SCL_CONFIG, FTAG, RW_READER);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint l = (i < 2) ? BP_GET_LEVEL(bp) : ZB_TOTAL;\n\t\tint t = (i & 1) ? type : ZDB_OT_TOTAL;\n\t\tint equal;\n\t\tzdb_blkstats_t *zb = &zcb->zcb_type[l][t];\n\n\t\tzb->zb_asize += BP_GET_ASIZE(bp);\n\t\tzb->zb_lsize += BP_GET_LSIZE(bp);\n\t\tzb->zb_psize += BP_GET_PSIZE(bp);\n\t\tzb->zb_count++;\n\n\t\t \n\t\tunsigned idx = BP_GET_PSIZE(bp) >> SPA_MINBLOCKSHIFT;\n\t\tidx = MIN(idx, SPA_OLD_MAXBLOCKSIZE / SPA_MINBLOCKSIZE + 1);\n\t\tzb->zb_psize_histogram[idx]++;\n\n\t\tzb->zb_gangs += BP_COUNT_GANG(bp);\n\n\t\tswitch (BP_GET_NDVAS(bp)) {\n\t\tcase 2:\n\t\t\tif (DVA_GET_VDEV(&bp->blk_dva[0]) ==\n\t\t\t    DVA_GET_VDEV(&bp->blk_dva[1])) {\n\t\t\t\tzb->zb_ditto_samevdev++;\n\n\t\t\t\tif (same_metaslab(zcb->zcb_spa,\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[0]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[0]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[1])))\n\t\t\t\t\tzb->zb_ditto_same_ms++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tequal = (DVA_GET_VDEV(&bp->blk_dva[0]) ==\n\t\t\t    DVA_GET_VDEV(&bp->blk_dva[1])) +\n\t\t\t    (DVA_GET_VDEV(&bp->blk_dva[0]) ==\n\t\t\t    DVA_GET_VDEV(&bp->blk_dva[2])) +\n\t\t\t    (DVA_GET_VDEV(&bp->blk_dva[1]) ==\n\t\t\t    DVA_GET_VDEV(&bp->blk_dva[2]));\n\t\t\tif (equal != 0) {\n\t\t\t\tzb->zb_ditto_samevdev++;\n\n\t\t\t\tif (DVA_GET_VDEV(&bp->blk_dva[0]) ==\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[1]) &&\n\t\t\t\t    same_metaslab(zcb->zcb_spa,\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[0]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[0]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[1])))\n\t\t\t\t\tzb->zb_ditto_same_ms++;\n\t\t\t\telse if (DVA_GET_VDEV(&bp->blk_dva[0]) ==\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[2]) &&\n\t\t\t\t    same_metaslab(zcb->zcb_spa,\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[0]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[0]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[2])))\n\t\t\t\t\tzb->zb_ditto_same_ms++;\n\t\t\t\telse if (DVA_GET_VDEV(&bp->blk_dva[1]) ==\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[2]) &&\n\t\t\t\t    same_metaslab(zcb->zcb_spa,\n\t\t\t\t    DVA_GET_VDEV(&bp->blk_dva[1]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[1]),\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[2])))\n\t\t\t\t\tzb->zb_ditto_same_ms++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspa_config_exit(zcb->zcb_spa, SCL_CONFIG, FTAG);\n\n\tif (BP_IS_EMBEDDED(bp)) {\n\t\tzcb->zcb_embedded_blocks[BPE_GET_ETYPE(bp)]++;\n\t\tzcb->zcb_embedded_histogram[BPE_GET_ETYPE(bp)]\n\t\t    [BPE_GET_PSIZE(bp)]++;\n\t\treturn;\n\t}\n\t \n\tint bin = highbit64(BP_GET_PSIZE(bp)) - 1;\n\n\tzcb->zcb_psize_count[bin]++;\n\tzcb->zcb_psize_len[bin] += BP_GET_PSIZE(bp);\n\tzcb->zcb_psize_total += BP_GET_PSIZE(bp);\n\n\tbin = highbit64(BP_GET_LSIZE(bp)) - 1;\n\n\tzcb->zcb_lsize_count[bin]++;\n\tzcb->zcb_lsize_len[bin] += BP_GET_LSIZE(bp);\n\tzcb->zcb_lsize_total += BP_GET_LSIZE(bp);\n\n\tbin = highbit64(BP_GET_ASIZE(bp)) - 1;\n\n\tzcb->zcb_asize_count[bin]++;\n\tzcb->zcb_asize_len[bin] += BP_GET_ASIZE(bp);\n\tzcb->zcb_asize_total += BP_GET_ASIZE(bp);\n\n\tif (zcb->zcb_brt_is_active && brt_maybe_exists(zcb->zcb_spa, bp)) {\n\t\t \n\t\tzdb_brt_entry_t zbre_search, *zbre;\n\t\tavl_index_t where;\n\n\t\tzbre_search.zbre_dva = bp->blk_dva[0];\n\t\tzbre = avl_find(&zcb->zcb_brt, &zbre_search, &where);\n\t\tif (zbre != NULL) {\n\t\t\tzcb->zcb_clone_asize += BP_GET_ASIZE(bp);\n\t\t\tzcb->zcb_clone_blocks++;\n\n\t\t\tzbre->zbre_refcount--;\n\t\t\tif (zbre->zbre_refcount == 0) {\n\t\t\t\tavl_remove(&zcb->zcb_brt, zbre);\n\t\t\t\tumem_free(zbre, sizeof (zdb_brt_entry_t));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tuint64_t crefcnt = brt_entry_get_refcount(zcb->zcb_spa, bp);\n\t\tif (crefcnt > 0) {\n\t\t\tzbre = umem_zalloc(sizeof (zdb_brt_entry_t),\n\t\t\t    UMEM_NOFAIL);\n\t\t\tzbre->zbre_dva = bp->blk_dva[0];\n\t\t\tzbre->zbre_refcount = crefcnt;\n\t\t\tavl_insert(&zcb->zcb_brt, zbre, where);\n\t\t}\n\t}\n\n\tif (dump_opt['L'])\n\t\treturn;\n\n\tif (BP_GET_DEDUP(bp)) {\n\t\tddt_t *ddt;\n\t\tddt_entry_t *dde;\n\n\t\tddt = ddt_select(zcb->zcb_spa, bp);\n\t\tddt_enter(ddt);\n\t\tdde = ddt_lookup(ddt, bp, B_FALSE);\n\n\t\tif (dde == NULL) {\n\t\t\trefcnt = 0;\n\t\t} else {\n\t\t\tddt_phys_t *ddp = ddt_phys_select(dde, bp);\n\t\t\tddt_phys_decref(ddp);\n\t\t\trefcnt = ddp->ddp_refcnt;\n\t\t\tif (ddt_phys_total_refcnt(dde) == 0)\n\t\t\t\tddt_remove(ddt, dde);\n\t\t}\n\t\tddt_exit(ddt);\n\t}\n\n\tVERIFY3U(zio_wait(zio_claim(NULL, zcb->zcb_spa,\n\t    refcnt ? 0 : spa_min_claim_txg(zcb->zcb_spa),\n\t    bp, NULL, NULL, ZIO_FLAG_CANFAIL)), ==, 0);\n}\n\nstatic void\nzdb_blkptr_done(zio_t *zio)\n{\n\tspa_t *spa = zio->io_spa;\n\tblkptr_t *bp = zio->io_bp;\n\tint ioerr = zio->io_error;\n\tzdb_cb_t *zcb = zio->io_private;\n\tzbookmark_phys_t *zb = &zio->io_bookmark;\n\n\tmutex_enter(&spa->spa_scrub_lock);\n\tspa->spa_load_verify_bytes -= BP_GET_PSIZE(bp);\n\tcv_broadcast(&spa->spa_scrub_io_cv);\n\n\tif (ioerr && !(zio->io_flags & ZIO_FLAG_SPECULATIVE)) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\n\t\tzcb->zcb_haderrors = 1;\n\t\tzcb->zcb_errors[ioerr]++;\n\n\t\tif (dump_opt['b'] >= 2)\n\t\t\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), bp);\n\t\telse\n\t\t\tblkbuf[0] = '\\0';\n\n\t\t(void) printf(\"zdb_blkptr_cb: \"\n\t\t    \"Got error %d reading \"\n\t\t    \"<%llu, %llu, %lld, %llx> %s -- skipping\\n\",\n\t\t    ioerr,\n\t\t    (u_longlong_t)zb->zb_objset,\n\t\t    (u_longlong_t)zb->zb_object,\n\t\t    (u_longlong_t)zb->zb_level,\n\t\t    (u_longlong_t)zb->zb_blkid,\n\t\t    blkbuf);\n\t}\n\tmutex_exit(&spa->spa_scrub_lock);\n\n\tabd_free(zio->io_abd);\n}\n\nstatic int\nzdb_blkptr_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)\n{\n\tzdb_cb_t *zcb = arg;\n\tdmu_object_type_t type;\n\tboolean_t is_metadata;\n\n\tif (zb->zb_level == ZB_DNODE_LEVEL)\n\t\treturn (0);\n\n\tif (dump_opt['b'] >= 5 && bp->blk_birth > 0) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), bp);\n\t\t(void) printf(\"objset %llu object %llu \"\n\t\t    \"level %lld offset 0x%llx %s\\n\",\n\t\t    (u_longlong_t)zb->zb_objset,\n\t\t    (u_longlong_t)zb->zb_object,\n\t\t    (longlong_t)zb->zb_level,\n\t\t    (u_longlong_t)blkid2offset(dnp, bp, zb),\n\t\t    blkbuf);\n\t}\n\n\tif (BP_IS_HOLE(bp) || BP_IS_REDACTED(bp))\n\t\treturn (0);\n\n\ttype = BP_GET_TYPE(bp);\n\n\tzdb_count_block(zcb, zilog, bp,\n\t    (type & DMU_OT_NEWTYPE) ? ZDB_OT_OTHER : type);\n\n\tis_metadata = (BP_GET_LEVEL(bp) != 0 || DMU_OT_IS_METADATA(type));\n\n\tif (!BP_IS_EMBEDDED(bp) &&\n\t    (dump_opt['c'] > 1 || (dump_opt['c'] && is_metadata))) {\n\t\tsize_t size = BP_GET_PSIZE(bp);\n\t\tabd_t *abd = abd_alloc(size, B_FALSE);\n\t\tint flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_SCRUB | ZIO_FLAG_RAW;\n\n\t\t \n\t\tif (zb->zb_level == ZB_ZIL_LEVEL)\n\t\t\tflags |= ZIO_FLAG_SPECULATIVE;\n\n\t\tmutex_enter(&spa->spa_scrub_lock);\n\t\twhile (spa->spa_load_verify_bytes > max_inflight_bytes)\n\t\t\tcv_wait(&spa->spa_scrub_io_cv, &spa->spa_scrub_lock);\n\t\tspa->spa_load_verify_bytes += size;\n\t\tmutex_exit(&spa->spa_scrub_lock);\n\n\t\tzio_nowait(zio_read(NULL, spa, bp, abd, size,\n\t\t    zdb_blkptr_done, zcb, ZIO_PRIORITY_ASYNC_READ, flags, zb));\n\t}\n\n\tzcb->zcb_readfails = 0;\n\n\t \n\tstatic int iters;\n\tif (++iters > 100)\n\t\titers = 0;\n\telse\n\t\treturn (0);\n\n\tif (dump_opt['b'] < 5 && gethrtime() > zcb->zcb_lastprint + NANOSEC) {\n\t\tuint64_t now = gethrtime();\n\t\tchar buf[10];\n\t\tuint64_t bytes = zcb->zcb_type[ZB_TOTAL][ZDB_OT_TOTAL].zb_asize;\n\t\tuint64_t kb_per_sec =\n\t\t    1 + bytes / (1 + ((now - zcb->zcb_start) / 1000 / 1000));\n\t\tuint64_t sec_remaining =\n\t\t    (zcb->zcb_totalasize - bytes) / 1024 / kb_per_sec;\n\n\t\t \n\t\t_Static_assert(sizeof (buf) >= NN_NUMBUF_SZ, \"buf truncated\");\n\n\t\tzfs_nicebytes(bytes, buf, sizeof (buf));\n\t\t(void) fprintf(stderr,\n\t\t    \"\\r%5s completed (%4\"PRIu64\"MB/s) \"\n\t\t    \"estimated time remaining: \"\n\t\t    \"%\"PRIu64\"hr %02\"PRIu64\"min %02\"PRIu64\"sec        \",\n\t\t    buf, kb_per_sec / 1024,\n\t\t    sec_remaining / 60 / 60,\n\t\t    sec_remaining / 60 % 60,\n\t\t    sec_remaining % 60);\n\n\t\tzcb->zcb_lastprint = now;\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzdb_leak(void *arg, uint64_t start, uint64_t size)\n{\n\tvdev_t *vd = arg;\n\n\t(void) printf(\"leaked space: vdev %llu, offset 0x%llx, size %llu\\n\",\n\t    (u_longlong_t)vd->vdev_id, (u_longlong_t)start, (u_longlong_t)size);\n}\n\nstatic metaslab_ops_t zdb_metaslab_ops = {\n\tNULL\t \n};\n\nstatic int\nload_unflushed_svr_segs_cb(spa_t *spa, space_map_entry_t *sme,\n    uint64_t txg, void *arg)\n{\n\tspa_vdev_removal_t *svr = arg;\n\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t size = sme->sme_run;\n\n\t \n\tif (sme->sme_vdev != svr->svr_vdev_id)\n\t\treturn (0);\n\n\tvdev_t *vd = vdev_lookup_top(spa, sme->sme_vdev);\n\tmetaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\tASSERT(sme->sme_type == SM_ALLOC || sme->sme_type == SM_FREE);\n\n\tif (txg < metaslab_unflushed_txg(ms))\n\t\treturn (0);\n\n\tif (sme->sme_type == SM_ALLOC)\n\t\trange_tree_add(svr->svr_allocd_segs, offset, size);\n\telse\n\t\trange_tree_remove(svr->svr_allocd_segs, offset, size);\n\n\treturn (0);\n}\n\nstatic void\nclaim_segment_impl_cb(uint64_t inner_offset, vdev_t *vd, uint64_t offset,\n    uint64_t size, void *arg)\n{\n\t(void) inner_offset, (void) arg;\n\n\t \n\tASSERT(vdev_is_concrete(vd));\n\n\tVERIFY0(metaslab_claim_impl(vd, offset, size,\n\t    spa_min_claim_txg(vd->vdev_spa)));\n}\n\nstatic void\nclaim_segment_cb(void *arg, uint64_t offset, uint64_t size)\n{\n\tvdev_t *vd = arg;\n\n\tvdev_indirect_ops.vdev_op_remap(vd, offset, size,\n\t    claim_segment_impl_cb, NULL);\n}\n\n \nstatic void\nzdb_claim_removing(spa_t *spa, zdb_cb_t *zcb)\n{\n\tif (dump_opt['L'])\n\t\treturn;\n\n\tif (spa->spa_vdev_removal == NULL)\n\t\treturn;\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tvdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\n\tASSERT0(range_tree_space(svr->svr_allocd_segs));\n\n\trange_tree_t *allocs = range_tree_create(NULL, RANGE_SEG64, NULL, 0, 0);\n\tfor (uint64_t msi = 0; msi < vd->vdev_ms_count; msi++) {\n\t\tmetaslab_t *msp = vd->vdev_ms[msi];\n\n\t\tASSERT0(range_tree_space(allocs));\n\t\tif (msp->ms_sm != NULL)\n\t\t\tVERIFY0(space_map_load(msp->ms_sm, allocs, SM_ALLOC));\n\t\trange_tree_vacate(allocs, range_tree_add, svr->svr_allocd_segs);\n\t}\n\trange_tree_destroy(allocs);\n\n\titerate_through_spacemap_logs(spa, load_unflushed_svr_segs_cb, svr);\n\n\t \n\trange_tree_clear(svr->svr_allocd_segs,\n\t    vdev_indirect_mapping_max_offset(vim),\n\t    vd->vdev_asize - vdev_indirect_mapping_max_offset(vim));\n\n\tzcb->zcb_removing_size += range_tree_space(svr->svr_allocd_segs);\n\trange_tree_vacate(svr->svr_allocd_segs, claim_segment_cb, vd);\n\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n}\n\nstatic int\nincrement_indirect_mapping_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\t(void) tx;\n\tzdb_cb_t *zcb = arg;\n\tspa_t *spa = zcb->zcb_spa;\n\tvdev_t *vd;\n\tconst dva_t *dva = &bp->blk_dva[0];\n\n\tASSERT(!bp_freed);\n\tASSERT(!dump_opt['L']);\n\tASSERT3U(BP_GET_NDVAS(bp), ==, 1);\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\tvd = vdev_lookup_top(zcb->zcb_spa, DVA_GET_VDEV(dva));\n\tASSERT3P(vd, !=, NULL);\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\tASSERT(vd->vdev_indirect_config.vic_mapping_object != 0);\n\tASSERT3P(zcb->zcb_vd_obsolete_counts[vd->vdev_id], !=, NULL);\n\n\tvdev_indirect_mapping_increment_obsolete_count(\n\t    vd->vdev_indirect_mapping,\n\t    DVA_GET_OFFSET(dva), DVA_GET_ASIZE(dva),\n\t    zcb->zcb_vd_obsolete_counts[vd->vdev_id]);\n\n\treturn (0);\n}\n\nstatic uint32_t *\nzdb_load_obsolete_counts(vdev_t *vd)\n{\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tspa_t *spa = vd->vdev_spa;\n\tspa_condensing_indirect_phys_t *scip =\n\t    &spa->spa_condensing_indirect_phys;\n\tuint64_t obsolete_sm_object;\n\tuint32_t *counts;\n\n\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\tEQUIV(obsolete_sm_object != 0, vd->vdev_obsolete_sm != NULL);\n\tcounts = vdev_indirect_mapping_load_obsolete_counts(vim);\n\tif (vd->vdev_obsolete_sm != NULL) {\n\t\tvdev_indirect_mapping_load_obsolete_spacemap(vim, counts,\n\t\t    vd->vdev_obsolete_sm);\n\t}\n\tif (scip->scip_vdev == vd->vdev_id &&\n\t    scip->scip_prev_obsolete_sm_object != 0) {\n\t\tspace_map_t *prev_obsolete_sm = NULL;\n\t\tVERIFY0(space_map_open(&prev_obsolete_sm, spa->spa_meta_objset,\n\t\t    scip->scip_prev_obsolete_sm_object, 0, vd->vdev_asize, 0));\n\t\tvdev_indirect_mapping_load_obsolete_spacemap(vim, counts,\n\t\t    prev_obsolete_sm);\n\t\tspace_map_close(prev_obsolete_sm);\n\t}\n\treturn (counts);\n}\n\nstatic void\nzdb_ddt_leak_init(spa_t *spa, zdb_cb_t *zcb)\n{\n\tddt_bookmark_t ddb = {0};\n\tddt_entry_t dde;\n\tint error;\n\tint p;\n\n\tASSERT(!dump_opt['L']);\n\n\twhile ((error = ddt_walk(spa, &ddb, &dde)) == 0) {\n\t\tblkptr_t blk;\n\t\tddt_phys_t *ddp = dde.dde_phys;\n\n\t\tif (ddb.ddb_class == DDT_CLASS_UNIQUE)\n\t\t\treturn;\n\n\t\tASSERT(ddt_phys_total_refcnt(&dde) > 1);\n\n\t\tfor (p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {\n\t\t\tif (ddp->ddp_phys_birth == 0)\n\t\t\t\tcontinue;\n\t\t\tddt_bp_create(ddb.ddb_checksum,\n\t\t\t    &dde.dde_key, ddp, &blk);\n\t\t\tif (p == DDT_PHYS_DITTO) {\n\t\t\t\tzdb_count_block(zcb, NULL, &blk, ZDB_OT_DITTO);\n\t\t\t} else {\n\t\t\t\tzcb->zcb_dedup_asize +=\n\t\t\t\t    BP_GET_ASIZE(&blk) * (ddp->ddp_refcnt - 1);\n\t\t\t\tzcb->zcb_dedup_blocks++;\n\t\t\t}\n\t\t}\n\t\tddt_t *ddt = spa->spa_ddt[ddb.ddb_checksum];\n\t\tddt_enter(ddt);\n\t\tVERIFY(ddt_lookup(ddt, &blk, B_TRUE) != NULL);\n\t\tddt_exit(ddt);\n\t}\n\n\tASSERT(error == ENOENT);\n}\n\ntypedef struct checkpoint_sm_exclude_entry_arg {\n\tvdev_t *cseea_vd;\n\tuint64_t cseea_checkpoint_size;\n} checkpoint_sm_exclude_entry_arg_t;\n\nstatic int\ncheckpoint_sm_exclude_entry_cb(space_map_entry_t *sme, void *arg)\n{\n\tcheckpoint_sm_exclude_entry_arg_t *cseea = arg;\n\tvdev_t *vd = cseea->cseea_vd;\n\tmetaslab_t *ms = vd->vdev_ms[sme->sme_offset >> vd->vdev_ms_shift];\n\tuint64_t end = sme->sme_offset + sme->sme_run;\n\n\tASSERT(sme->sme_type == SM_FREE);\n\n\t \n\tVERIFY3U(sme->sme_offset, >=, ms->ms_start);\n\tVERIFY3U(end, <=, ms->ms_start + ms->ms_size);\n\n\t \n\tmutex_enter(&ms->ms_lock);\n\trange_tree_remove(ms->ms_allocatable, sme->sme_offset, sme->sme_run);\n\tmutex_exit(&ms->ms_lock);\n\n\tcseea->cseea_checkpoint_size += sme->sme_run;\n\treturn (0);\n}\n\nstatic void\nzdb_leak_init_vdev_exclude_checkpoint(vdev_t *vd, zdb_cb_t *zcb)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tspace_map_t *checkpoint_sm = NULL;\n\tuint64_t checkpoint_sm_obj;\n\n\t \n\tif (vd->vdev_top_zap == 0)\n\t\treturn;\n\n\t \n\tif (zap_contains(spa_meta_objset(spa), vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_POOL_CHECKPOINT_SM) != 0)\n\t\treturn;\n\n\tVERIFY0(zap_lookup(spa_meta_objset(spa), vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_POOL_CHECKPOINT_SM, sizeof (uint64_t), 1,\n\t    &checkpoint_sm_obj));\n\n\tcheckpoint_sm_exclude_entry_arg_t cseea;\n\tcseea.cseea_vd = vd;\n\tcseea.cseea_checkpoint_size = 0;\n\n\tVERIFY0(space_map_open(&checkpoint_sm, spa_meta_objset(spa),\n\t    checkpoint_sm_obj, 0, vd->vdev_asize, vd->vdev_ashift));\n\n\tVERIFY0(space_map_iterate(checkpoint_sm,\n\t    space_map_length(checkpoint_sm),\n\t    checkpoint_sm_exclude_entry_cb, &cseea));\n\tspace_map_close(checkpoint_sm);\n\n\tzcb->zcb_checkpoint_size += cseea.cseea_checkpoint_size;\n}\n\nstatic void\nzdb_leak_init_exclude_checkpoint(spa_t *spa, zdb_cb_t *zcb)\n{\n\tASSERT(!dump_opt['L']);\n\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tASSERT3U(c, ==, rvd->vdev_child[c]->vdev_id);\n\t\tzdb_leak_init_vdev_exclude_checkpoint(rvd->vdev_child[c], zcb);\n\t}\n}\n\nstatic int\ncount_unflushed_space_cb(spa_t *spa, space_map_entry_t *sme,\n    uint64_t txg, void *arg)\n{\n\tint64_t *ualloc_space = arg;\n\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t vdev_id = sme->sme_vdev;\n\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\tif (!vdev_is_concrete(vd))\n\t\treturn (0);\n\n\tmetaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\tASSERT(sme->sme_type == SM_ALLOC || sme->sme_type == SM_FREE);\n\n\tif (txg < metaslab_unflushed_txg(ms))\n\t\treturn (0);\n\n\tif (sme->sme_type == SM_ALLOC)\n\t\t*ualloc_space += sme->sme_run;\n\telse\n\t\t*ualloc_space -= sme->sme_run;\n\n\treturn (0);\n}\n\nstatic int64_t\nget_unflushed_alloc_space(spa_t *spa)\n{\n\tif (dump_opt['L'])\n\t\treturn (0);\n\n\tint64_t ualloc_space = 0;\n\titerate_through_spacemap_logs(spa, count_unflushed_space_cb,\n\t    &ualloc_space);\n\treturn (ualloc_space);\n}\n\nstatic int\nload_unflushed_cb(spa_t *spa, space_map_entry_t *sme, uint64_t txg, void *arg)\n{\n\tmaptype_t *uic_maptype = arg;\n\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t size = sme->sme_run;\n\tuint64_t vdev_id = sme->sme_vdev;\n\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\n\t \n\tif (!vdev_is_concrete(vd))\n\t\treturn (0);\n\n\tmetaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\n\tASSERT(sme->sme_type == SM_ALLOC || sme->sme_type == SM_FREE);\n\tASSERT(*uic_maptype == SM_ALLOC || *uic_maptype == SM_FREE);\n\n\tif (txg < metaslab_unflushed_txg(ms))\n\t\treturn (0);\n\n\tif (*uic_maptype == sme->sme_type)\n\t\trange_tree_add(ms->ms_allocatable, offset, size);\n\telse\n\t\trange_tree_remove(ms->ms_allocatable, offset, size);\n\n\treturn (0);\n}\n\nstatic void\nload_unflushed_to_ms_allocatables(spa_t *spa, maptype_t maptype)\n{\n\titerate_through_spacemap_logs(spa, load_unflushed_cb, &maptype);\n}\n\nstatic void\nload_concrete_ms_allocatable_trees(spa_t *spa, maptype_t maptype)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tfor (uint64_t i = 0; i < rvd->vdev_children; i++) {\n\t\tvdev_t *vd = rvd->vdev_child[i];\n\n\t\tASSERT3U(i, ==, vd->vdev_id);\n\n\t\tif (vd->vdev_ops == &vdev_indirect_ops)\n\t\t\tcontinue;\n\n\t\tfor (uint64_t m = 0; m < vd->vdev_ms_count; m++) {\n\t\t\tmetaslab_t *msp = vd->vdev_ms[m];\n\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"\\rloading concrete vdev %llu, \"\n\t\t\t    \"metaslab %llu of %llu ...\",\n\t\t\t    (longlong_t)vd->vdev_id,\n\t\t\t    (longlong_t)msp->ms_id,\n\t\t\t    (longlong_t)vd->vdev_ms_count);\n\n\t\t\tmutex_enter(&msp->ms_lock);\n\t\t\trange_tree_vacate(msp->ms_allocatable, NULL, NULL);\n\n\t\t\t \n\t\t\tmsp->ms_allocatable->rt_ops = NULL;\n\n\t\t\tif (msp->ms_sm != NULL) {\n\t\t\t\tVERIFY0(space_map_load(msp->ms_sm,\n\t\t\t\t    msp->ms_allocatable, maptype));\n\t\t\t}\n\t\t\tif (!msp->ms_loaded)\n\t\t\t\tmsp->ms_loaded = B_TRUE;\n\t\t\tmutex_exit(&msp->ms_lock);\n\t\t}\n\t}\n\n\tload_unflushed_to_ms_allocatables(spa, maptype);\n}\n\n \nstatic void\nload_indirect_ms_allocatable_tree(vdev_t *vd, metaslab_t *msp,\n    uint64_t *vim_idxp)\n{\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\n\tmutex_enter(&msp->ms_lock);\n\trange_tree_vacate(msp->ms_allocatable, NULL, NULL);\n\n\t \n\tmsp->ms_allocatable->rt_ops = NULL;\n\n\tfor (; *vim_idxp < vdev_indirect_mapping_num_entries(vim);\n\t    (*vim_idxp)++) {\n\t\tvdev_indirect_mapping_entry_phys_t *vimep =\n\t\t    &vim->vim_entries[*vim_idxp];\n\t\tuint64_t ent_offset = DVA_MAPPING_GET_SRC_OFFSET(vimep);\n\t\tuint64_t ent_len = DVA_GET_ASIZE(&vimep->vimep_dst);\n\t\tASSERT3U(ent_offset, >=, msp->ms_start);\n\t\tif (ent_offset >= msp->ms_start + msp->ms_size)\n\t\t\tbreak;\n\n\t\t \n\t\tASSERT3U(ent_offset + ent_len, <=,\n\t\t    msp->ms_start + msp->ms_size);\n\t\trange_tree_add(msp->ms_allocatable, ent_offset, ent_len);\n\t}\n\n\tif (!msp->ms_loaded)\n\t\tmsp->ms_loaded = B_TRUE;\n\tmutex_exit(&msp->ms_lock);\n}\n\nstatic void\nzdb_leak_init_prepare_indirect_vdevs(spa_t *spa, zdb_cb_t *zcb)\n{\n\tASSERT(!dump_opt['L']);\n\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *vd = rvd->vdev_child[c];\n\n\t\tASSERT3U(c, ==, vd->vdev_id);\n\n\t\tif (vd->vdev_ops != &vdev_indirect_ops)\n\t\t\tcontinue;\n\n\t\t \n\t\tzcb->zcb_vd_obsolete_counts[c] = zdb_load_obsolete_counts(vd);\n\n\t\t \n\t\tvdev_metaslab_group_create(vd);\n\t\tVERIFY0(vdev_metaslab_init(vd, 0));\n\n\t\tvdev_indirect_mapping_t *vim __maybe_unused =\n\t\t    vd->vdev_indirect_mapping;\n\t\tuint64_t vim_idx = 0;\n\t\tfor (uint64_t m = 0; m < vd->vdev_ms_count; m++) {\n\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"\\rloading indirect vdev %llu, \"\n\t\t\t    \"metaslab %llu of %llu ...\",\n\t\t\t    (longlong_t)vd->vdev_id,\n\t\t\t    (longlong_t)vd->vdev_ms[m]->ms_id,\n\t\t\t    (longlong_t)vd->vdev_ms_count);\n\n\t\t\tload_indirect_ms_allocatable_tree(vd, vd->vdev_ms[m],\n\t\t\t    &vim_idx);\n\t\t}\n\t\tASSERT3U(vim_idx, ==, vdev_indirect_mapping_num_entries(vim));\n\t}\n}\n\nstatic void\nzdb_leak_init(spa_t *spa, zdb_cb_t *zcb)\n{\n\tzcb->zcb_spa = spa;\n\n\tif (dump_opt['L'])\n\t\treturn;\n\n\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\t \n\tspa->spa_normal_class->mc_ops = &zdb_metaslab_ops;\n\tspa->spa_log_class->mc_ops = &zdb_metaslab_ops;\n\tspa->spa_embedded_log_class->mc_ops = &zdb_metaslab_ops;\n\n\tzcb->zcb_vd_obsolete_counts =\n\t    umem_zalloc(rvd->vdev_children * sizeof (uint32_t *),\n\t    UMEM_NOFAIL);\n\n\t \n\tzdb_leak_init_prepare_indirect_vdevs(spa, zcb);\n\tload_concrete_ms_allocatable_trees(spa, SM_ALLOC);\n\n\t \n\tzdb_leak_init_exclude_checkpoint(spa, zcb);\n\tASSERT3U(zcb->zcb_checkpoint_size, ==, spa_get_checkpoint_space(spa));\n\n\t \n\t(void) fprintf(stderr, \"\\n\");\n\n\tif (bpobj_is_open(&dp->dp_obsolete_bpobj)) {\n\t\tASSERT(spa_feature_is_enabled(spa,\n\t\t    SPA_FEATURE_DEVICE_REMOVAL));\n\t\t(void) bpobj_iterate_nofree(&dp->dp_obsolete_bpobj,\n\t\t    increment_indirect_mapping_cb, zcb, NULL);\n\t}\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tzdb_ddt_leak_init(spa, zcb);\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n}\n\nstatic boolean_t\nzdb_check_for_obsolete_leaks(vdev_t *vd, zdb_cb_t *zcb)\n{\n\tboolean_t leaks = B_FALSE;\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tuint64_t total_leaked = 0;\n\tboolean_t are_precise = B_FALSE;\n\n\tASSERT(vim != NULL);\n\n\tfor (uint64_t i = 0; i < vdev_indirect_mapping_num_entries(vim); i++) {\n\t\tvdev_indirect_mapping_entry_phys_t *vimep =\n\t\t    &vim->vim_entries[i];\n\t\tuint64_t obsolete_bytes = 0;\n\t\tuint64_t offset = DVA_MAPPING_GET_SRC_OFFSET(vimep);\n\t\tmetaslab_t *msp = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\n\t\t \n\t\tfor (uint64_t inner_offset = 0;\n\t\t    inner_offset < DVA_GET_ASIZE(&vimep->vimep_dst);\n\t\t    inner_offset += 1ULL << vd->vdev_ashift) {\n\t\t\tif (range_tree_contains(msp->ms_allocatable,\n\t\t\t    offset + inner_offset, 1ULL << vd->vdev_ashift)) {\n\t\t\t\tobsolete_bytes += 1ULL << vd->vdev_ashift;\n\t\t\t}\n\t\t}\n\n\t\tint64_t bytes_leaked = obsolete_bytes -\n\t\t    zcb->zcb_vd_obsolete_counts[vd->vdev_id][i];\n\t\tASSERT3U(DVA_GET_ASIZE(&vimep->vimep_dst), >=,\n\t\t    zcb->zcb_vd_obsolete_counts[vd->vdev_id][i]);\n\n\t\tVERIFY0(vdev_obsolete_counts_are_precise(vd, &are_precise));\n\t\tif (bytes_leaked != 0 && (are_precise || dump_opt['d'] >= 5)) {\n\t\t\t(void) printf(\"obsolete indirect mapping count \"\n\t\t\t    \"mismatch on %llu:%llx:%llx : %llx bytes leaked\\n\",\n\t\t\t    (u_longlong_t)vd->vdev_id,\n\t\t\t    (u_longlong_t)DVA_MAPPING_GET_SRC_OFFSET(vimep),\n\t\t\t    (u_longlong_t)DVA_GET_ASIZE(&vimep->vimep_dst),\n\t\t\t    (u_longlong_t)bytes_leaked);\n\t\t}\n\t\ttotal_leaked += ABS(bytes_leaked);\n\t}\n\n\tVERIFY0(vdev_obsolete_counts_are_precise(vd, &are_precise));\n\tif (!are_precise && total_leaked > 0) {\n\t\tint pct_leaked = total_leaked * 100 /\n\t\t    vdev_indirect_mapping_bytes_mapped(vim);\n\t\t(void) printf(\"cannot verify obsolete indirect mapping \"\n\t\t    \"counts of vdev %llu because precise feature was not \"\n\t\t    \"enabled when it was removed: %d%% (%llx bytes) of mapping\"\n\t\t    \"unreferenced\\n\",\n\t\t    (u_longlong_t)vd->vdev_id, pct_leaked,\n\t\t    (u_longlong_t)total_leaked);\n\t} else if (total_leaked > 0) {\n\t\t(void) printf(\"obsolete indirect mapping count mismatch \"\n\t\t    \"for vdev %llu -- %llx total bytes mismatched\\n\",\n\t\t    (u_longlong_t)vd->vdev_id,\n\t\t    (u_longlong_t)total_leaked);\n\t\tleaks |= B_TRUE;\n\t}\n\n\tvdev_indirect_mapping_free_obsolete_counts(vim,\n\t    zcb->zcb_vd_obsolete_counts[vd->vdev_id]);\n\tzcb->zcb_vd_obsolete_counts[vd->vdev_id] = NULL;\n\n\treturn (leaks);\n}\n\nstatic boolean_t\nzdb_leak_fini(spa_t *spa, zdb_cb_t *zcb)\n{\n\tif (dump_opt['L'])\n\t\treturn (B_FALSE);\n\n\tboolean_t leaks = B_FALSE;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tfor (unsigned c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *vd = rvd->vdev_child[c];\n\n\t\tif (zcb->zcb_vd_obsolete_counts[c] != NULL) {\n\t\t\tleaks |= zdb_check_for_obsolete_leaks(vd, zcb);\n\t\t}\n\n\t\tfor (uint64_t m = 0; m < vd->vdev_ms_count; m++) {\n\t\t\tmetaslab_t *msp = vd->vdev_ms[m];\n\t\t\tASSERT3P(msp->ms_group, ==, (msp->ms_group->mg_class ==\n\t\t\t    spa_embedded_log_class(spa)) ?\n\t\t\t    vd->vdev_log_mg : vd->vdev_mg);\n\n\t\t\t \n\t\t\tif (vd->vdev_ops == &vdev_indirect_ops) {\n\t\t\t\trange_tree_vacate(msp->ms_allocatable,\n\t\t\t\t    NULL, NULL);\n\t\t\t} else {\n\t\t\t\trange_tree_vacate(msp->ms_allocatable,\n\t\t\t\t    zdb_leak, vd);\n\t\t\t}\n\t\t\tif (msp->ms_loaded) {\n\t\t\t\tmsp->ms_loaded = B_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tumem_free(zcb->zcb_vd_obsolete_counts,\n\t    rvd->vdev_children * sizeof (uint32_t *));\n\tzcb->zcb_vd_obsolete_counts = NULL;\n\n\treturn (leaks);\n}\n\nstatic int\ncount_block_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\t(void) tx;\n\tzdb_cb_t *zcb = arg;\n\n\tif (dump_opt['b'] >= 5) {\n\t\tchar blkbuf[BP_SPRINTF_LEN];\n\t\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), bp);\n\t\t(void) printf(\"[%s] %s\\n\",\n\t\t    \"deferred free\", blkbuf);\n\t}\n\tzdb_count_block(zcb, NULL, bp, ZDB_OT_DEFERRED);\n\treturn (0);\n}\n\n \nstatic void\niterate_deleted_livelists(spa_t *spa, ll_iter_t func, void *arg)\n{\n\tobjset_t *mos = spa->spa_meta_objset;\n\tuint64_t zap_obj;\n\tint err = zap_lookup(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_DELETED_CLONES, sizeof (uint64_t), 1, &zap_obj);\n\tif (err == ENOENT)\n\t\treturn;\n\tASSERT0(err);\n\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\tdsl_deadlist_t ll;\n\t \n\tll.dl_os = NULL;\n\tfor (zap_cursor_init(&zc, mos, zap_obj);\n\t    zap_cursor_retrieve(&zc, &attr) == 0;\n\t    (void) zap_cursor_advance(&zc)) {\n\t\tdsl_deadlist_open(&ll, mos, attr.za_first_integer);\n\t\tfunc(&ll, arg);\n\t\tdsl_deadlist_close(&ll);\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic int\nbpobj_count_block_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\tASSERT(!bp_freed);\n\treturn (count_block_cb(arg, bp, tx));\n}\n\nstatic int\nlivelist_entry_count_blocks_cb(void *args, dsl_deadlist_entry_t *dle)\n{\n\tzdb_cb_t *zbc = args;\n\tbplist_t blks;\n\tbplist_create(&blks);\n\t \n\tVERIFY0(dsl_process_sub_livelist(&dle->dle_bpobj, &blks, NULL, NULL));\n\t \n\t(void) bplist_iterate(&blks, count_block_cb, zbc, NULL);\n\tbplist_destroy(&blks);\n\treturn (0);\n}\n\nstatic void\nlivelist_count_blocks(dsl_deadlist_t *ll, void *arg)\n{\n\tdsl_deadlist_iterate(ll, livelist_entry_count_blocks_cb, arg);\n}\n\n \nstatic void\ndeleted_livelists_count_blocks(spa_t *spa, zdb_cb_t *zbc)\n{\n\titerate_deleted_livelists(spa, livelist_count_blocks, zbc);\n}\n\nstatic void\ndump_livelist_cb(dsl_deadlist_t *ll, void *arg)\n{\n\tASSERT3P(arg, ==, NULL);\n\tglobal_feature_count[SPA_FEATURE_LIVELIST]++;\n\tdump_blkptr_list(ll, \"Deleted Livelist\");\n\tdsl_deadlist_iterate(ll, sublivelist_verify_lightweight, NULL);\n}\n\n \nstatic void\ndeleted_livelists_dump_mos(spa_t *spa)\n{\n\tuint64_t zap_obj;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tint err = zap_lookup(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_DELETED_CLONES, sizeof (uint64_t), 1, &zap_obj);\n\tif (err == ENOENT)\n\t\treturn;\n\tmos_obj_refd(zap_obj);\n\titerate_deleted_livelists(spa, dump_livelist_cb, NULL);\n}\n\nstatic int\nzdb_brt_entry_compare(const void *zcn1, const void *zcn2)\n{\n\tconst dva_t *dva1 = &((const zdb_brt_entry_t *)zcn1)->zbre_dva;\n\tconst dva_t *dva2 = &((const zdb_brt_entry_t *)zcn2)->zbre_dva;\n\tint cmp;\n\n\tcmp = TREE_CMP(DVA_GET_VDEV(dva1), DVA_GET_VDEV(dva2));\n\tif (cmp == 0)\n\t\tcmp = TREE_CMP(DVA_GET_OFFSET(dva1), DVA_GET_OFFSET(dva2));\n\n\treturn (cmp);\n}\n\nstatic int\ndump_block_stats(spa_t *spa)\n{\n\tzdb_cb_t *zcb;\n\tzdb_blkstats_t *zb, *tzb;\n\tuint64_t norm_alloc, norm_space, total_alloc, total_found;\n\tint flags = TRAVERSE_PRE | TRAVERSE_PREFETCH_METADATA |\n\t    TRAVERSE_NO_DECRYPT | TRAVERSE_HARD;\n\tboolean_t leaks = B_FALSE;\n\tint e, c, err;\n\tbp_embedded_type_t i;\n\n\tzcb = umem_zalloc(sizeof (zdb_cb_t), UMEM_NOFAIL);\n\n\tif (spa_feature_is_active(spa, SPA_FEATURE_BLOCK_CLONING)) {\n\t\tavl_create(&zcb->zcb_brt, zdb_brt_entry_compare,\n\t\t    sizeof (zdb_brt_entry_t),\n\t\t    offsetof(zdb_brt_entry_t, zbre_node));\n\t\tzcb->zcb_brt_is_active = B_TRUE;\n\t}\n\n\t(void) printf(\"\\nTraversing all blocks %s%s%s%s%s...\\n\\n\",\n\t    (dump_opt['c'] || !dump_opt['L']) ? \"to verify \" : \"\",\n\t    (dump_opt['c'] == 1) ? \"metadata \" : \"\",\n\t    dump_opt['c'] ? \"checksums \" : \"\",\n\t    (dump_opt['c'] && !dump_opt['L']) ? \"and verify \" : \"\",\n\t    !dump_opt['L'] ? \"nothing leaked \" : \"\");\n\n\t \n\tzdb_leak_init(spa, zcb);\n\n\t \n\t(void) bpobj_iterate_nofree(&spa->spa_deferred_bpobj,\n\t    bpobj_count_block_cb, zcb, NULL);\n\n\tif (spa_version(spa) >= SPA_VERSION_DEADLISTS) {\n\t\t(void) bpobj_iterate_nofree(&spa->spa_dsl_pool->dp_free_bpobj,\n\t\t    bpobj_count_block_cb, zcb, NULL);\n\t}\n\n\tzdb_claim_removing(spa, zcb);\n\n\tif (spa_feature_is_active(spa, SPA_FEATURE_ASYNC_DESTROY)) {\n\t\tVERIFY3U(0, ==, bptree_iterate(spa->spa_meta_objset,\n\t\t    spa->spa_dsl_pool->dp_bptree_obj, B_FALSE, count_block_cb,\n\t\t    zcb, NULL));\n\t}\n\n\tdeleted_livelists_count_blocks(spa, zcb);\n\n\tif (dump_opt['c'] > 1)\n\t\tflags |= TRAVERSE_PREFETCH_DATA;\n\n\tzcb->zcb_totalasize = metaslab_class_get_alloc(spa_normal_class(spa));\n\tzcb->zcb_totalasize += metaslab_class_get_alloc(spa_special_class(spa));\n\tzcb->zcb_totalasize += metaslab_class_get_alloc(spa_dedup_class(spa));\n\tzcb->zcb_totalasize +=\n\t    metaslab_class_get_alloc(spa_embedded_log_class(spa));\n\tzcb->zcb_start = zcb->zcb_lastprint = gethrtime();\n\terr = traverse_pool(spa, 0, flags, zdb_blkptr_cb, zcb);\n\n\t \n\tif (dump_opt['c']) {\n\t\tfor (c = 0; c < max_ncpus; c++) {\n\t\t\t(void) zio_wait(spa->spa_async_zio_root[c]);\n\t\t\tspa->spa_async_zio_root[c] = zio_root(spa, NULL, NULL,\n\t\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_SPECULATIVE |\n\t\t\t    ZIO_FLAG_GODFATHER);\n\t\t}\n\t}\n\tASSERT0(spa->spa_load_verify_bytes);\n\n\t \n\tzcb->zcb_haderrors |= err;\n\n\tif (zcb->zcb_haderrors) {\n\t\t(void) printf(\"\\nError counts:\\n\\n\");\n\t\t(void) printf(\"\\t%5s  %s\\n\", \"errno\", \"count\");\n\t\tfor (e = 0; e < 256; e++) {\n\t\t\tif (zcb->zcb_errors[e] != 0) {\n\t\t\t\t(void) printf(\"\\t%5d  %llu\\n\",\n\t\t\t\t    e, (u_longlong_t)zcb->zcb_errors[e]);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tleaks |= zdb_leak_fini(spa, zcb);\n\n\ttzb = &zcb->zcb_type[ZB_TOTAL][ZDB_OT_TOTAL];\n\n\tnorm_alloc = metaslab_class_get_alloc(spa_normal_class(spa));\n\tnorm_space = metaslab_class_get_space(spa_normal_class(spa));\n\n\ttotal_alloc = norm_alloc +\n\t    metaslab_class_get_alloc(spa_log_class(spa)) +\n\t    metaslab_class_get_alloc(spa_embedded_log_class(spa)) +\n\t    metaslab_class_get_alloc(spa_special_class(spa)) +\n\t    metaslab_class_get_alloc(spa_dedup_class(spa)) +\n\t    get_unflushed_alloc_space(spa);\n\ttotal_found =\n\t    tzb->zb_asize - zcb->zcb_dedup_asize - zcb->zcb_clone_asize +\n\t    zcb->zcb_removing_size + zcb->zcb_checkpoint_size;\n\n\tif (total_found == total_alloc && !dump_opt['L']) {\n\t\t(void) printf(\"\\n\\tNo leaks (block sum matches space\"\n\t\t    \" maps exactly)\\n\");\n\t} else if (!dump_opt['L']) {\n\t\t(void) printf(\"block traversal size %llu != alloc %llu \"\n\t\t    \"(%s %lld)\\n\",\n\t\t    (u_longlong_t)total_found,\n\t\t    (u_longlong_t)total_alloc,\n\t\t    (dump_opt['L']) ? \"unreachable\" : \"leaked\",\n\t\t    (longlong_t)(total_alloc - total_found));\n\t\tleaks = B_TRUE;\n\t}\n\n\tif (tzb->zb_count == 0) {\n\t\tumem_free(zcb, sizeof (zdb_cb_t));\n\t\treturn (2);\n\t}\n\n\t(void) printf(\"\\n\");\n\t(void) printf(\"\\t%-16s %14llu\\n\", \"bp count:\",\n\t    (u_longlong_t)tzb->zb_count);\n\t(void) printf(\"\\t%-16s %14llu\\n\", \"ganged count:\",\n\t    (longlong_t)tzb->zb_gangs);\n\t(void) printf(\"\\t%-16s %14llu      avg: %6llu\\n\", \"bp logical:\",\n\t    (u_longlong_t)tzb->zb_lsize,\n\t    (u_longlong_t)(tzb->zb_lsize / tzb->zb_count));\n\t(void) printf(\"\\t%-16s %14llu      avg: %6llu     compression: %6.2f\\n\",\n\t    \"bp physical:\", (u_longlong_t)tzb->zb_psize,\n\t    (u_longlong_t)(tzb->zb_psize / tzb->zb_count),\n\t    (double)tzb->zb_lsize / tzb->zb_psize);\n\t(void) printf(\"\\t%-16s %14llu      avg: %6llu     compression: %6.2f\\n\",\n\t    \"bp allocated:\", (u_longlong_t)tzb->zb_asize,\n\t    (u_longlong_t)(tzb->zb_asize / tzb->zb_count),\n\t    (double)tzb->zb_lsize / tzb->zb_asize);\n\t(void) printf(\"\\t%-16s %14llu    ref>1: %6llu   deduplication: %6.2f\\n\",\n\t    \"bp deduped:\", (u_longlong_t)zcb->zcb_dedup_asize,\n\t    (u_longlong_t)zcb->zcb_dedup_blocks,\n\t    (double)zcb->zcb_dedup_asize / tzb->zb_asize + 1.0);\n\t(void) printf(\"\\t%-16s %14llu    count: %6llu\\n\",\n\t    \"bp cloned:\", (u_longlong_t)zcb->zcb_clone_asize,\n\t    (u_longlong_t)zcb->zcb_clone_blocks);\n\t(void) printf(\"\\t%-16s %14llu     used: %5.2f%%\\n\", \"Normal class:\",\n\t    (u_longlong_t)norm_alloc, 100.0 * norm_alloc / norm_space);\n\n\tif (spa_special_class(spa)->mc_allocator[0].mca_rotor != NULL) {\n\t\tuint64_t alloc = metaslab_class_get_alloc(\n\t\t    spa_special_class(spa));\n\t\tuint64_t space = metaslab_class_get_space(\n\t\t    spa_special_class(spa));\n\n\t\t(void) printf(\"\\t%-16s %14llu     used: %5.2f%%\\n\",\n\t\t    \"Special class\", (u_longlong_t)alloc,\n\t\t    100.0 * alloc / space);\n\t}\n\n\tif (spa_dedup_class(spa)->mc_allocator[0].mca_rotor != NULL) {\n\t\tuint64_t alloc = metaslab_class_get_alloc(\n\t\t    spa_dedup_class(spa));\n\t\tuint64_t space = metaslab_class_get_space(\n\t\t    spa_dedup_class(spa));\n\n\t\t(void) printf(\"\\t%-16s %14llu     used: %5.2f%%\\n\",\n\t\t    \"Dedup class\", (u_longlong_t)alloc,\n\t\t    100.0 * alloc / space);\n\t}\n\n\tif (spa_embedded_log_class(spa)->mc_allocator[0].mca_rotor != NULL) {\n\t\tuint64_t alloc = metaslab_class_get_alloc(\n\t\t    spa_embedded_log_class(spa));\n\t\tuint64_t space = metaslab_class_get_space(\n\t\t    spa_embedded_log_class(spa));\n\n\t\t(void) printf(\"\\t%-16s %14llu     used: %5.2f%%\\n\",\n\t\t    \"Embedded log class\", (u_longlong_t)alloc,\n\t\t    100.0 * alloc / space);\n\t}\n\n\tfor (i = 0; i < NUM_BP_EMBEDDED_TYPES; i++) {\n\t\tif (zcb->zcb_embedded_blocks[i] == 0)\n\t\t\tcontinue;\n\t\t(void) printf(\"\\n\");\n\t\t(void) printf(\"\\tadditional, non-pointer bps of type %u: \"\n\t\t    \"%10llu\\n\",\n\t\t    i, (u_longlong_t)zcb->zcb_embedded_blocks[i]);\n\n\t\tif (dump_opt['b'] >= 3) {\n\t\t\t(void) printf(\"\\t number of (compressed) bytes:  \"\n\t\t\t    \"number of bps\\n\");\n\t\t\tdump_histogram(zcb->zcb_embedded_histogram[i],\n\t\t\t    sizeof (zcb->zcb_embedded_histogram[i]) /\n\t\t\t    sizeof (zcb->zcb_embedded_histogram[i][0]), 0);\n\t\t}\n\t}\n\n\tif (tzb->zb_ditto_samevdev != 0) {\n\t\t(void) printf(\"\\tDittoed blocks on same vdev: %llu\\n\",\n\t\t    (longlong_t)tzb->zb_ditto_samevdev);\n\t}\n\tif (tzb->zb_ditto_same_ms != 0) {\n\t\t(void) printf(\"\\tDittoed blocks in same metaslab: %llu\\n\",\n\t\t    (longlong_t)tzb->zb_ditto_same_ms);\n\t}\n\n\tfor (uint64_t v = 0; v < spa->spa_root_vdev->vdev_children; v++) {\n\t\tvdev_t *vd = spa->spa_root_vdev->vdev_child[v];\n\t\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\n\t\tif (vim == NULL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar mem[32];\n\t\tzdb_nicenum(vdev_indirect_mapping_num_entries(vim),\n\t\t    mem, vdev_indirect_mapping_size(vim));\n\n\t\t(void) printf(\"\\tindirect vdev id %llu has %llu segments \"\n\t\t    \"(%s in memory)\\n\",\n\t\t    (longlong_t)vd->vdev_id,\n\t\t    (longlong_t)vdev_indirect_mapping_num_entries(vim), mem);\n\t}\n\n\tif (dump_opt['b'] >= 2) {\n\t\tint l, t, level;\n\t\tchar csize[32], lsize[32], psize[32], asize[32];\n\t\tchar avg[32], gang[32];\n\t\t(void) printf(\"\\nBlocks\\tLSIZE\\tPSIZE\\tASIZE\"\n\t\t    \"\\t  avg\\t comp\\t%%Total\\tType\\n\");\n\n\t\tzfs_blkstat_t *mdstats = umem_zalloc(sizeof (zfs_blkstat_t),\n\t\t    UMEM_NOFAIL);\n\n\t\tfor (t = 0; t <= ZDB_OT_TOTAL; t++) {\n\t\t\tconst char *typename;\n\n\t\t\t \n\t\t\t_Static_assert(sizeof (csize) >= NN_NUMBUF_SZ,\n\t\t\t    \"csize truncated\");\n\t\t\t_Static_assert(sizeof (lsize) >= NN_NUMBUF_SZ,\n\t\t\t    \"lsize truncated\");\n\t\t\t_Static_assert(sizeof (psize) >= NN_NUMBUF_SZ,\n\t\t\t    \"psize truncated\");\n\t\t\t_Static_assert(sizeof (asize) >= NN_NUMBUF_SZ,\n\t\t\t    \"asize truncated\");\n\t\t\t_Static_assert(sizeof (avg) >= NN_NUMBUF_SZ,\n\t\t\t    \"avg truncated\");\n\t\t\t_Static_assert(sizeof (gang) >= NN_NUMBUF_SZ,\n\t\t\t    \"gang truncated\");\n\n\t\t\tif (t < DMU_OT_NUMTYPES)\n\t\t\t\ttypename = dmu_ot[t].ot_name;\n\t\t\telse\n\t\t\t\ttypename = zdb_ot_extname[t - DMU_OT_NUMTYPES];\n\n\t\t\tif (zcb->zcb_type[ZB_TOTAL][t].zb_asize == 0) {\n\t\t\t\t(void) printf(\"%6s\\t%5s\\t%5s\\t%5s\"\n\t\t\t\t    \"\\t%5s\\t%5s\\t%6s\\t%s\\n\",\n\t\t\t\t    \"-\",\n\t\t\t\t    \"-\",\n\t\t\t\t    \"-\",\n\t\t\t\t    \"-\",\n\t\t\t\t    \"-\",\n\t\t\t\t    \"-\",\n\t\t\t\t    \"-\",\n\t\t\t\t    typename);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (l = ZB_TOTAL - 1; l >= -1; l--) {\n\t\t\t\tlevel = (l == -1 ? ZB_TOTAL : l);\n\t\t\t\tzb = &zcb->zcb_type[level][t];\n\n\t\t\t\tif (zb->zb_asize == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (level != ZB_TOTAL && t < DMU_OT_NUMTYPES &&\n\t\t\t\t    (level > 0 || DMU_OT_IS_METADATA(t))) {\n\t\t\t\t\tmdstats->zb_count += zb->zb_count;\n\t\t\t\t\tmdstats->zb_lsize += zb->zb_lsize;\n\t\t\t\t\tmdstats->zb_psize += zb->zb_psize;\n\t\t\t\t\tmdstats->zb_asize += zb->zb_asize;\n\t\t\t\t\tmdstats->zb_gangs += zb->zb_gangs;\n\t\t\t\t}\n\n\t\t\t\tif (dump_opt['b'] < 3 && level != ZB_TOTAL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (level == 0 && zb->zb_asize ==\n\t\t\t\t    zcb->zcb_type[ZB_TOTAL][t].zb_asize)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tzdb_nicenum(zb->zb_count, csize,\n\t\t\t\t    sizeof (csize));\n\t\t\t\tzdb_nicenum(zb->zb_lsize, lsize,\n\t\t\t\t    sizeof (lsize));\n\t\t\t\tzdb_nicenum(zb->zb_psize, psize,\n\t\t\t\t    sizeof (psize));\n\t\t\t\tzdb_nicenum(zb->zb_asize, asize,\n\t\t\t\t    sizeof (asize));\n\t\t\t\tzdb_nicenum(zb->zb_asize / zb->zb_count, avg,\n\t\t\t\t    sizeof (avg));\n\t\t\t\tzdb_nicenum(zb->zb_gangs, gang, sizeof (gang));\n\n\t\t\t\t(void) printf(\"%6s\\t%5s\\t%5s\\t%5s\\t%5s\"\n\t\t\t\t    \"\\t%5.2f\\t%6.2f\\t\",\n\t\t\t\t    csize, lsize, psize, asize, avg,\n\t\t\t\t    (double)zb->zb_lsize / zb->zb_psize,\n\t\t\t\t    100.0 * zb->zb_asize / tzb->zb_asize);\n\n\t\t\t\tif (level == ZB_TOTAL)\n\t\t\t\t\t(void) printf(\"%s\\n\", typename);\n\t\t\t\telse\n\t\t\t\t\t(void) printf(\"    L%d %s\\n\",\n\t\t\t\t\t    level, typename);\n\n\t\t\t\tif (dump_opt['b'] >= 3 && zb->zb_gangs > 0) {\n\t\t\t\t\t(void) printf(\"\\t number of ganged \"\n\t\t\t\t\t    \"blocks: %s\\n\", gang);\n\t\t\t\t}\n\n\t\t\t\tif (dump_opt['b'] >= 4) {\n\t\t\t\t\t(void) printf(\"psize \"\n\t\t\t\t\t    \"(in 512-byte sectors): \"\n\t\t\t\t\t    \"number of blocks\\n\");\n\t\t\t\t\tdump_histogram(zb->zb_psize_histogram,\n\t\t\t\t\t    PSIZE_HISTO_SIZE, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tzdb_nicenum(mdstats->zb_count, csize,\n\t\t    sizeof (csize));\n\t\tzdb_nicenum(mdstats->zb_lsize, lsize,\n\t\t    sizeof (lsize));\n\t\tzdb_nicenum(mdstats->zb_psize, psize,\n\t\t    sizeof (psize));\n\t\tzdb_nicenum(mdstats->zb_asize, asize,\n\t\t    sizeof (asize));\n\t\tzdb_nicenum(mdstats->zb_asize / mdstats->zb_count, avg,\n\t\t    sizeof (avg));\n\t\tzdb_nicenum(mdstats->zb_gangs, gang, sizeof (gang));\n\n\t\t(void) printf(\"%6s\\t%5s\\t%5s\\t%5s\\t%5s\"\n\t\t    \"\\t%5.2f\\t%6.2f\\t\",\n\t\t    csize, lsize, psize, asize, avg,\n\t\t    (double)mdstats->zb_lsize / mdstats->zb_psize,\n\t\t    100.0 * mdstats->zb_asize / tzb->zb_asize);\n\t\t(void) printf(\"%s\\n\", \"Metadata Total\");\n\n\t\t \n\t\tif (dump_opt['b'] >= 2) {\n\t\t\tdump_size_histograms(zcb);\n\t\t}\n\n\t\tumem_free(mdstats, sizeof (zfs_blkstat_t));\n\t}\n\n\t(void) printf(\"\\n\");\n\n\tif (leaks) {\n\t\tumem_free(zcb, sizeof (zdb_cb_t));\n\t\treturn (2);\n\t}\n\n\tif (zcb->zcb_haderrors) {\n\t\tumem_free(zcb, sizeof (zdb_cb_t));\n\t\treturn (3);\n\t}\n\n\tumem_free(zcb, sizeof (zdb_cb_t));\n\treturn (0);\n}\n\ntypedef struct zdb_ddt_entry {\n\tddt_key_t\tzdde_key;\n\tuint64_t\tzdde_ref_blocks;\n\tuint64_t\tzdde_ref_lsize;\n\tuint64_t\tzdde_ref_psize;\n\tuint64_t\tzdde_ref_dsize;\n\tavl_node_t\tzdde_node;\n} zdb_ddt_entry_t;\n\nstatic int\nzdb_ddt_add_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)\n{\n\t(void) zilog, (void) dnp;\n\tavl_tree_t *t = arg;\n\tavl_index_t where;\n\tzdb_ddt_entry_t *zdde, zdde_search;\n\n\tif (zb->zb_level == ZB_DNODE_LEVEL || BP_IS_HOLE(bp) ||\n\t    BP_IS_EMBEDDED(bp))\n\t\treturn (0);\n\n\tif (dump_opt['S'] > 1 && zb->zb_level == ZB_ROOT_LEVEL) {\n\t\t(void) printf(\"traversing objset %llu, %llu objects, \"\n\t\t    \"%lu blocks so far\\n\",\n\t\t    (u_longlong_t)zb->zb_objset,\n\t\t    (u_longlong_t)BP_GET_FILL(bp),\n\t\t    avl_numnodes(t));\n\t}\n\n\tif (BP_IS_HOLE(bp) || BP_GET_CHECKSUM(bp) == ZIO_CHECKSUM_OFF ||\n\t    BP_GET_LEVEL(bp) > 0 || DMU_OT_IS_METADATA(BP_GET_TYPE(bp)))\n\t\treturn (0);\n\n\tddt_key_fill(&zdde_search.zdde_key, bp);\n\n\tzdde = avl_find(t, &zdde_search, &where);\n\n\tif (zdde == NULL) {\n\t\tzdde = umem_zalloc(sizeof (*zdde), UMEM_NOFAIL);\n\t\tzdde->zdde_key = zdde_search.zdde_key;\n\t\tavl_insert(t, zdde, where);\n\t}\n\n\tzdde->zdde_ref_blocks += 1;\n\tzdde->zdde_ref_lsize += BP_GET_LSIZE(bp);\n\tzdde->zdde_ref_psize += BP_GET_PSIZE(bp);\n\tzdde->zdde_ref_dsize += bp_get_dsize_sync(spa, bp);\n\n\treturn (0);\n}\n\nstatic void\ndump_simulated_ddt(spa_t *spa)\n{\n\tavl_tree_t t;\n\tvoid *cookie = NULL;\n\tzdb_ddt_entry_t *zdde;\n\tddt_histogram_t ddh_total = {{{0}}};\n\tddt_stat_t dds_total = {0};\n\n\tavl_create(&t, ddt_entry_compare,\n\t    sizeof (zdb_ddt_entry_t), offsetof(zdb_ddt_entry_t, zdde_node));\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\n\t(void) traverse_pool(spa, 0, TRAVERSE_PRE | TRAVERSE_PREFETCH_METADATA |\n\t    TRAVERSE_NO_DECRYPT, zdb_ddt_add_cb, &t);\n\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\twhile ((zdde = avl_destroy_nodes(&t, &cookie)) != NULL) {\n\t\tddt_stat_t dds;\n\t\tuint64_t refcnt = zdde->zdde_ref_blocks;\n\t\tASSERT(refcnt != 0);\n\n\t\tdds.dds_blocks = zdde->zdde_ref_blocks / refcnt;\n\t\tdds.dds_lsize = zdde->zdde_ref_lsize / refcnt;\n\t\tdds.dds_psize = zdde->zdde_ref_psize / refcnt;\n\t\tdds.dds_dsize = zdde->zdde_ref_dsize / refcnt;\n\n\t\tdds.dds_ref_blocks = zdde->zdde_ref_blocks;\n\t\tdds.dds_ref_lsize = zdde->zdde_ref_lsize;\n\t\tdds.dds_ref_psize = zdde->zdde_ref_psize;\n\t\tdds.dds_ref_dsize = zdde->zdde_ref_dsize;\n\n\t\tddt_stat_add(&ddh_total.ddh_stat[highbit64(refcnt) - 1],\n\t\t    &dds, 0);\n\n\t\tumem_free(zdde, sizeof (*zdde));\n\t}\n\n\tavl_destroy(&t);\n\n\tddt_histogram_stat(&dds_total, &ddh_total);\n\n\t(void) printf(\"Simulated DDT histogram:\\n\");\n\n\tzpool_dump_ddt(&dds_total, &ddh_total);\n\n\tdump_dedup_ratio(&dds_total);\n}\n\nstatic int\nverify_device_removal_feature_counts(spa_t *spa)\n{\n\tuint64_t dr_feature_refcount = 0;\n\tuint64_t oc_feature_refcount = 0;\n\tuint64_t indirect_vdev_count = 0;\n\tuint64_t precise_vdev_count = 0;\n\tuint64_t obsolete_counts_object_count = 0;\n\tuint64_t obsolete_sm_count = 0;\n\tuint64_t obsolete_counts_count = 0;\n\tuint64_t scip_count = 0;\n\tuint64_t obsolete_bpobj_count = 0;\n\tint ret = 0;\n\n\tspa_condensing_indirect_phys_t *scip =\n\t    &spa->spa_condensing_indirect_phys;\n\tif (scip->scip_next_mapping_object != 0) {\n\t\tvdev_t *vd = spa->spa_root_vdev->vdev_child[scip->scip_vdev];\n\t\tASSERT(scip->scip_prev_obsolete_sm_object != 0);\n\t\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\n\t\t(void) printf(\"Condensing indirect vdev %llu: new mapping \"\n\t\t    \"object %llu, prev obsolete sm %llu\\n\",\n\t\t    (u_longlong_t)scip->scip_vdev,\n\t\t    (u_longlong_t)scip->scip_next_mapping_object,\n\t\t    (u_longlong_t)scip->scip_prev_obsolete_sm_object);\n\t\tif (scip->scip_prev_obsolete_sm_object != 0) {\n\t\t\tspace_map_t *prev_obsolete_sm = NULL;\n\t\t\tVERIFY0(space_map_open(&prev_obsolete_sm,\n\t\t\t    spa->spa_meta_objset,\n\t\t\t    scip->scip_prev_obsolete_sm_object,\n\t\t\t    0, vd->vdev_asize, 0));\n\t\t\tdump_spacemap(spa->spa_meta_objset, prev_obsolete_sm);\n\t\t\t(void) printf(\"\\n\");\n\t\t\tspace_map_close(prev_obsolete_sm);\n\t\t}\n\n\t\tscip_count += 2;\n\t}\n\n\tfor (uint64_t i = 0; i < spa->spa_root_vdev->vdev_children; i++) {\n\t\tvdev_t *vd = spa->spa_root_vdev->vdev_child[i];\n\t\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\n\t\tif (vic->vic_mapping_object != 0) {\n\t\t\tASSERT(vd->vdev_ops == &vdev_indirect_ops ||\n\t\t\t    vd->vdev_removing);\n\t\t\tindirect_vdev_count++;\n\n\t\t\tif (vd->vdev_indirect_mapping->vim_havecounts) {\n\t\t\t\tobsolete_counts_count++;\n\t\t\t}\n\t\t}\n\n\t\tboolean_t are_precise;\n\t\tVERIFY0(vdev_obsolete_counts_are_precise(vd, &are_precise));\n\t\tif (are_precise) {\n\t\t\tASSERT(vic->vic_mapping_object != 0);\n\t\t\tprecise_vdev_count++;\n\t\t}\n\n\t\tuint64_t obsolete_sm_object;\n\t\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\t\tif (obsolete_sm_object != 0) {\n\t\t\tASSERT(vic->vic_mapping_object != 0);\n\t\t\tobsolete_sm_count++;\n\t\t}\n\t}\n\n\t(void) feature_get_refcount(spa,\n\t    &spa_feature_table[SPA_FEATURE_DEVICE_REMOVAL],\n\t    &dr_feature_refcount);\n\t(void) feature_get_refcount(spa,\n\t    &spa_feature_table[SPA_FEATURE_OBSOLETE_COUNTS],\n\t    &oc_feature_refcount);\n\n\tif (dr_feature_refcount != indirect_vdev_count) {\n\t\tret = 1;\n\t\t(void) printf(\"Number of indirect vdevs (%llu) \" \\\n\t\t    \"does not match feature count (%llu)\\n\",\n\t\t    (u_longlong_t)indirect_vdev_count,\n\t\t    (u_longlong_t)dr_feature_refcount);\n\t} else {\n\t\t(void) printf(\"Verified device_removal feature refcount \" \\\n\t\t    \"of %llu is correct\\n\",\n\t\t    (u_longlong_t)dr_feature_refcount);\n\t}\n\n\tif (zap_contains(spa_meta_objset(spa), DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_OBSOLETE_BPOBJ) == 0) {\n\t\tobsolete_bpobj_count++;\n\t}\n\n\n\tobsolete_counts_object_count = precise_vdev_count;\n\tobsolete_counts_object_count += obsolete_sm_count;\n\tobsolete_counts_object_count += obsolete_counts_count;\n\tobsolete_counts_object_count += scip_count;\n\tobsolete_counts_object_count += obsolete_bpobj_count;\n\tobsolete_counts_object_count += remap_deadlist_count;\n\n\tif (oc_feature_refcount != obsolete_counts_object_count) {\n\t\tret = 1;\n\t\t(void) printf(\"Number of obsolete counts objects (%llu) \" \\\n\t\t    \"does not match feature count (%llu)\\n\",\n\t\t    (u_longlong_t)obsolete_counts_object_count,\n\t\t    (u_longlong_t)oc_feature_refcount);\n\t\t(void) printf(\"pv:%llu os:%llu oc:%llu sc:%llu \"\n\t\t    \"ob:%llu rd:%llu\\n\",\n\t\t    (u_longlong_t)precise_vdev_count,\n\t\t    (u_longlong_t)obsolete_sm_count,\n\t\t    (u_longlong_t)obsolete_counts_count,\n\t\t    (u_longlong_t)scip_count,\n\t\t    (u_longlong_t)obsolete_bpobj_count,\n\t\t    (u_longlong_t)remap_deadlist_count);\n\t} else {\n\t\t(void) printf(\"Verified indirect_refcount feature refcount \" \\\n\t\t    \"of %llu is correct\\n\",\n\t\t    (u_longlong_t)oc_feature_refcount);\n\t}\n\treturn (ret);\n}\n\nstatic void\nzdb_set_skip_mmp(char *target)\n{\n\tspa_t *spa;\n\n\t \n\tmutex_enter(&spa_namespace_lock);\n\tif ((spa = spa_lookup(target)) != NULL) {\n\t\tspa->spa_import_flags |= ZFS_IMPORT_SKIP_MMP;\n\t}\n\tmutex_exit(&spa_namespace_lock);\n}\n\n#define\tBOGUS_SUFFIX \"_CHECKPOINTED_UNIVERSE\"\n \nstatic char *\nimport_checkpointed_state(char *target, nvlist_t *cfg, char **new_path)\n{\n\tint error = 0;\n\tchar *poolname, *bogus_name = NULL;\n\tboolean_t freecfg = B_FALSE;\n\n\t \n\tchar *path_start = strchr(target, '/');\n\tif (path_start != NULL) {\n\t\tsize_t poolname_len = path_start - target;\n\t\tpoolname = strndup(target, poolname_len);\n\t} else {\n\t\tpoolname = target;\n\t}\n\n\tif (cfg == NULL) {\n\t\tzdb_set_skip_mmp(poolname);\n\t\terror = spa_get_stats(poolname, &cfg, NULL, 0);\n\t\tif (error != 0) {\n\t\t\tfatal(\"Tried to read config of pool \\\"%s\\\" but \"\n\t\t\t    \"spa_get_stats() failed with error %d\\n\",\n\t\t\t    poolname, error);\n\t\t}\n\t\tfreecfg = B_TRUE;\n\t}\n\n\tif (asprintf(&bogus_name, \"%s%s\", poolname, BOGUS_SUFFIX) == -1) {\n\t\tif (target != poolname)\n\t\t\tfree(poolname);\n\t\treturn (NULL);\n\t}\n\tfnvlist_add_string(cfg, ZPOOL_CONFIG_POOL_NAME, bogus_name);\n\n\terror = spa_import(bogus_name, cfg, NULL,\n\t    ZFS_IMPORT_MISSING_LOG | ZFS_IMPORT_CHECKPOINT |\n\t    ZFS_IMPORT_SKIP_MMP);\n\tif (freecfg)\n\t\tnvlist_free(cfg);\n\tif (error != 0) {\n\t\tfatal(\"Tried to import pool \\\"%s\\\" but spa_import() failed \"\n\t\t    \"with error %d\\n\", bogus_name, error);\n\t}\n\n\tif (new_path != NULL && path_start != NULL) {\n\t\tif (asprintf(new_path, \"%s%s\", bogus_name, path_start) == -1) {\n\t\t\tfree(bogus_name);\n\t\t\tif (path_start != NULL)\n\t\t\t\tfree(poolname);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\tif (target != poolname)\n\t\tfree(poolname);\n\n\treturn (bogus_name);\n}\n\ntypedef struct verify_checkpoint_sm_entry_cb_arg {\n\tvdev_t *vcsec_vd;\n\n\t \n\tuint64_t vcsec_entryid;\n\tuint64_t vcsec_num_entries;\n} verify_checkpoint_sm_entry_cb_arg_t;\n\n#define\tENTRIES_PER_PROGRESS_UPDATE 10000\n\nstatic int\nverify_checkpoint_sm_entry_cb(space_map_entry_t *sme, void *arg)\n{\n\tverify_checkpoint_sm_entry_cb_arg_t *vcsec = arg;\n\tvdev_t *vd = vcsec->vcsec_vd;\n\tmetaslab_t *ms = vd->vdev_ms[sme->sme_offset >> vd->vdev_ms_shift];\n\tuint64_t end = sme->sme_offset + sme->sme_run;\n\n\tASSERT(sme->sme_type == SM_FREE);\n\n\tif ((vcsec->vcsec_entryid % ENTRIES_PER_PROGRESS_UPDATE) == 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"\\rverifying vdev %llu, space map entry %llu of %llu ...\",\n\t\t    (longlong_t)vd->vdev_id,\n\t\t    (longlong_t)vcsec->vcsec_entryid,\n\t\t    (longlong_t)vcsec->vcsec_num_entries);\n\t}\n\tvcsec->vcsec_entryid++;\n\n\t \n\tVERIFY3U(sme->sme_offset, >=, ms->ms_start);\n\tVERIFY3U(end, <=, ms->ms_start + ms->ms_size);\n\n\t \n\tmutex_enter(&ms->ms_lock);\n\trange_tree_verify_not_present(ms->ms_allocatable,\n\t    sme->sme_offset, sme->sme_run);\n\tmutex_exit(&ms->ms_lock);\n\n\treturn (0);\n}\n\n \nstatic void\nverify_checkpoint_vdev_spacemaps(spa_t *checkpoint, spa_t *current)\n{\n\tvdev_t *ckpoint_rvd = checkpoint->spa_root_vdev;\n\tvdev_t *current_rvd = current->spa_root_vdev;\n\n\tload_concrete_ms_allocatable_trees(checkpoint, SM_FREE);\n\n\tfor (uint64_t c = 0; c < ckpoint_rvd->vdev_children; c++) {\n\t\tvdev_t *ckpoint_vd = ckpoint_rvd->vdev_child[c];\n\t\tvdev_t *current_vd = current_rvd->vdev_child[c];\n\n\t\tspace_map_t *checkpoint_sm = NULL;\n\t\tuint64_t checkpoint_sm_obj;\n\n\t\tif (ckpoint_vd->vdev_ops == &vdev_indirect_ops) {\n\t\t\t \n\t\t\tASSERT3P(current_vd->vdev_ops, ==, &vdev_indirect_ops);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (current_vd->vdev_top_zap == 0 ||\n\t\t    zap_contains(spa_meta_objset(current),\n\t\t    current_vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_POOL_CHECKPOINT_SM) != 0)\n\t\t\tcontinue;\n\n\t\tVERIFY0(zap_lookup(spa_meta_objset(current),\n\t\t    current_vd->vdev_top_zap, VDEV_TOP_ZAP_POOL_CHECKPOINT_SM,\n\t\t    sizeof (uint64_t), 1, &checkpoint_sm_obj));\n\n\t\tVERIFY0(space_map_open(&checkpoint_sm, spa_meta_objset(current),\n\t\t    checkpoint_sm_obj, 0, current_vd->vdev_asize,\n\t\t    current_vd->vdev_ashift));\n\n\t\tverify_checkpoint_sm_entry_cb_arg_t vcsec;\n\t\tvcsec.vcsec_vd = ckpoint_vd;\n\t\tvcsec.vcsec_entryid = 0;\n\t\tvcsec.vcsec_num_entries =\n\t\t    space_map_length(checkpoint_sm) / sizeof (uint64_t);\n\t\tVERIFY0(space_map_iterate(checkpoint_sm,\n\t\t    space_map_length(checkpoint_sm),\n\t\t    verify_checkpoint_sm_entry_cb, &vcsec));\n\t\tif (dump_opt['m'] > 3)\n\t\t\tdump_spacemap(current->spa_meta_objset, checkpoint_sm);\n\t\tspace_map_close(checkpoint_sm);\n\t}\n\n\t \n\tif (ckpoint_rvd->vdev_children < current_rvd->vdev_children) {\n\t\tfor (uint64_t c = ckpoint_rvd->vdev_children;\n\t\t    c < current_rvd->vdev_children; c++) {\n\t\t\tvdev_t *current_vd = current_rvd->vdev_child[c];\n\t\t\tVERIFY3P(current_vd->vdev_checkpoint_sm, ==, NULL);\n\t\t}\n\t}\n\n\t \n\t(void) fprintf(stderr, \"\\n\");\n}\n\n \nstatic void\nverify_checkpoint_ms_spacemaps(spa_t *checkpoint, spa_t *current)\n{\n\tvdev_t *ckpoint_rvd = checkpoint->spa_root_vdev;\n\tvdev_t *current_rvd = current->spa_root_vdev;\n\n\tload_concrete_ms_allocatable_trees(checkpoint, SM_ALLOC);\n\tload_concrete_ms_allocatable_trees(current, SM_FREE);\n\n\tfor (uint64_t i = 0; i < ckpoint_rvd->vdev_children; i++) {\n\t\tvdev_t *ckpoint_vd = ckpoint_rvd->vdev_child[i];\n\t\tvdev_t *current_vd = current_rvd->vdev_child[i];\n\n\t\tif (ckpoint_vd->vdev_ops == &vdev_indirect_ops) {\n\t\t\t \n\t\t\tASSERT3P(current_vd->vdev_ops, ==, &vdev_indirect_ops);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (uint64_t m = 0; m < ckpoint_vd->vdev_ms_count; m++) {\n\t\t\tmetaslab_t *ckpoint_msp = ckpoint_vd->vdev_ms[m];\n\t\t\tmetaslab_t *current_msp = current_vd->vdev_ms[m];\n\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"\\rverifying vdev %llu of %llu, \"\n\t\t\t    \"metaslab %llu of %llu ...\",\n\t\t\t    (longlong_t)current_vd->vdev_id,\n\t\t\t    (longlong_t)current_rvd->vdev_children,\n\t\t\t    (longlong_t)current_vd->vdev_ms[m]->ms_id,\n\t\t\t    (longlong_t)current_vd->vdev_ms_count);\n\n\t\t\t \n\t\t\trange_tree_walk(ckpoint_msp->ms_allocatable,\n\t\t\t    (range_tree_func_t *)range_tree_verify_not_present,\n\t\t\t    current_msp->ms_allocatable);\n\t\t}\n\t}\n\n\t \n\t(void) fprintf(stderr, \"\\n\");\n}\n\nstatic void\nverify_checkpoint_blocks(spa_t *spa)\n{\n\tASSERT(!dump_opt['L']);\n\n\tspa_t *checkpoint_spa;\n\tchar *checkpoint_pool;\n\tint error = 0;\n\n\t \n\tcheckpoint_pool = import_checkpointed_state(spa->spa_name, NULL,\n\t    NULL);\n\tASSERT(strcmp(spa->spa_name, checkpoint_pool) != 0);\n\n\terror = spa_open(checkpoint_pool, &checkpoint_spa, FTAG);\n\tif (error != 0) {\n\t\tfatal(\"Tried to open pool \\\"%s\\\" but spa_open() failed with \"\n\t\t    \"error %d\\n\", checkpoint_pool, error);\n\t}\n\n\t \n\tverify_checkpoint_vdev_spacemaps(checkpoint_spa, spa);\n\n\t \n\tverify_checkpoint_ms_spacemaps(checkpoint_spa, spa);\n\n\t \n\tspa_close(checkpoint_spa, FTAG);\n\tfree(checkpoint_pool);\n}\n\nstatic void\ndump_leftover_checkpoint_blocks(spa_t *spa)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tfor (uint64_t i = 0; i < rvd->vdev_children; i++) {\n\t\tvdev_t *vd = rvd->vdev_child[i];\n\n\t\tspace_map_t *checkpoint_sm = NULL;\n\t\tuint64_t checkpoint_sm_obj;\n\n\t\tif (vd->vdev_top_zap == 0)\n\t\t\tcontinue;\n\n\t\tif (zap_contains(spa_meta_objset(spa), vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_POOL_CHECKPOINT_SM) != 0)\n\t\t\tcontinue;\n\n\t\tVERIFY0(zap_lookup(spa_meta_objset(spa), vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_POOL_CHECKPOINT_SM,\n\t\t    sizeof (uint64_t), 1, &checkpoint_sm_obj));\n\n\t\tVERIFY0(space_map_open(&checkpoint_sm, spa_meta_objset(spa),\n\t\t    checkpoint_sm_obj, 0, vd->vdev_asize, vd->vdev_ashift));\n\t\tdump_spacemap(spa->spa_meta_objset, checkpoint_sm);\n\t\tspace_map_close(checkpoint_sm);\n\t}\n}\n\nstatic int\nverify_checkpoint(spa_t *spa)\n{\n\tuberblock_t checkpoint;\n\tint error;\n\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))\n\t\treturn (0);\n\n\terror = zap_lookup(spa->spa_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_ZPOOL_CHECKPOINT, sizeof (uint64_t),\n\t    sizeof (uberblock_t) / sizeof (uint64_t), &checkpoint);\n\n\tif (error == ENOENT && !dump_opt['L']) {\n\t\t \n\t\t(void) printf(\"\\nPartially discarded checkpoint \"\n\t\t    \"state found:\\n\");\n\t\tif (dump_opt['m'] > 3)\n\t\t\tdump_leftover_checkpoint_blocks(spa);\n\t\treturn (0);\n\t} else if (error != 0) {\n\t\t(void) printf(\"lookup error %d when looking for \"\n\t\t    \"checkpointed uberblock in MOS\\n\", error);\n\t\treturn (error);\n\t}\n\tdump_uberblock(&checkpoint, \"\\nCheckpointed uberblock found:\\n\", \"\\n\");\n\n\tif (checkpoint.ub_checkpoint_txg == 0) {\n\t\t(void) printf(\"\\nub_checkpoint_txg not set in checkpointed \"\n\t\t    \"uberblock\\n\");\n\t\terror = 3;\n\t}\n\n\tif (error == 0 && !dump_opt['L'])\n\t\tverify_checkpoint_blocks(spa);\n\n\treturn (error);\n}\n\nstatic void\nmos_leaks_cb(void *arg, uint64_t start, uint64_t size)\n{\n\t(void) arg;\n\tfor (uint64_t i = start; i < size; i++) {\n\t\t(void) printf(\"MOS object %llu referenced but not allocated\\n\",\n\t\t    (u_longlong_t)i);\n\t}\n}\n\nstatic void\nmos_obj_refd(uint64_t obj)\n{\n\tif (obj != 0 && mos_refd_objs != NULL)\n\t\trange_tree_add(mos_refd_objs, obj, 1);\n}\n\n \nstatic void\nmos_obj_refd_multiple(uint64_t obj)\n{\n\tif (obj != 0 && mos_refd_objs != NULL &&\n\t    !range_tree_contains(mos_refd_objs, obj, 1))\n\t\trange_tree_add(mos_refd_objs, obj, 1);\n}\n\nstatic void\nmos_leak_vdev_top_zap(vdev_t *vd)\n{\n\tuint64_t ms_flush_data_obj;\n\tint error = zap_lookup(spa_meta_objset(vd->vdev_spa),\n\t    vd->vdev_top_zap, VDEV_TOP_ZAP_MS_UNFLUSHED_PHYS_TXGS,\n\t    sizeof (ms_flush_data_obj), 1, &ms_flush_data_obj);\n\tif (error == ENOENT)\n\t\treturn;\n\tASSERT0(error);\n\n\tmos_obj_refd(ms_flush_data_obj);\n}\n\nstatic void\nmos_leak_vdev(vdev_t *vd)\n{\n\tmos_obj_refd(vd->vdev_dtl_object);\n\tmos_obj_refd(vd->vdev_ms_array);\n\tmos_obj_refd(vd->vdev_indirect_config.vic_births_object);\n\tmos_obj_refd(vd->vdev_indirect_config.vic_mapping_object);\n\tmos_obj_refd(vd->vdev_leaf_zap);\n\tif (vd->vdev_checkpoint_sm != NULL)\n\t\tmos_obj_refd(vd->vdev_checkpoint_sm->sm_object);\n\tif (vd->vdev_indirect_mapping != NULL) {\n\t\tmos_obj_refd(vd->vdev_indirect_mapping->\n\t\t    vim_phys->vimp_counts_object);\n\t}\n\tif (vd->vdev_obsolete_sm != NULL)\n\t\tmos_obj_refd(vd->vdev_obsolete_sm->sm_object);\n\n\tfor (uint64_t m = 0; m < vd->vdev_ms_count; m++) {\n\t\tmetaslab_t *ms = vd->vdev_ms[m];\n\t\tmos_obj_refd(space_map_object(ms->ms_sm));\n\t}\n\n\tif (vd->vdev_root_zap != 0)\n\t\tmos_obj_refd(vd->vdev_root_zap);\n\n\tif (vd->vdev_top_zap != 0) {\n\t\tmos_obj_refd(vd->vdev_top_zap);\n\t\tmos_leak_vdev_top_zap(vd);\n\t}\n\n\tfor (uint64_t c = 0; c < vd->vdev_children; c++) {\n\t\tmos_leak_vdev(vd->vdev_child[c]);\n\t}\n}\n\nstatic void\nmos_leak_log_spacemaps(spa_t *spa)\n{\n\tuint64_t spacemap_zap;\n\tint error = zap_lookup(spa_meta_objset(spa),\n\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_LOG_SPACEMAP_ZAP,\n\t    sizeof (spacemap_zap), 1, &spacemap_zap);\n\tif (error == ENOENT)\n\t\treturn;\n\tASSERT0(error);\n\n\tmos_obj_refd(spacemap_zap);\n\tfor (spa_log_sm_t *sls = avl_first(&spa->spa_sm_logs_by_txg);\n\t    sls; sls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls))\n\t\tmos_obj_refd(sls->sls_sm_obj);\n}\n\nstatic void\nerrorlog_count_refd(objset_t *mos, uint64_t errlog)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tfor (zap_cursor_init(&zc, mos, errlog);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tmos_obj_refd(za.za_first_integer);\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic int\ndump_mos_leaks(spa_t *spa)\n{\n\tint rv = 0;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\n\t \n\n\tmos_obj_refd(DMU_POOL_DIRECTORY_OBJECT);\n\tmos_obj_refd(spa->spa_pool_props_object);\n\tmos_obj_refd(spa->spa_config_object);\n\tmos_obj_refd(spa->spa_ddt_stat_object);\n\tmos_obj_refd(spa->spa_feat_desc_obj);\n\tmos_obj_refd(spa->spa_feat_enabled_txg_obj);\n\tmos_obj_refd(spa->spa_feat_for_read_obj);\n\tmos_obj_refd(spa->spa_feat_for_write_obj);\n\tmos_obj_refd(spa->spa_history);\n\tmos_obj_refd(spa->spa_errlog_last);\n\tmos_obj_refd(spa->spa_errlog_scrub);\n\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\terrorlog_count_refd(mos, spa->spa_errlog_last);\n\t\terrorlog_count_refd(mos, spa->spa_errlog_scrub);\n\t}\n\n\tmos_obj_refd(spa->spa_all_vdev_zaps);\n\tmos_obj_refd(spa->spa_dsl_pool->dp_bptree_obj);\n\tmos_obj_refd(spa->spa_dsl_pool->dp_tmp_userrefs_obj);\n\tmos_obj_refd(spa->spa_dsl_pool->dp_scan->scn_phys.scn_queue_obj);\n\tbpobj_count_refd(&spa->spa_deferred_bpobj);\n\tmos_obj_refd(dp->dp_empty_bpobj);\n\tbpobj_count_refd(&dp->dp_obsolete_bpobj);\n\tbpobj_count_refd(&dp->dp_free_bpobj);\n\tmos_obj_refd(spa->spa_l2cache.sav_object);\n\tmos_obj_refd(spa->spa_spares.sav_object);\n\n\tif (spa->spa_syncing_log_sm != NULL)\n\t\tmos_obj_refd(spa->spa_syncing_log_sm->sm_object);\n\tmos_leak_log_spacemaps(spa);\n\n\tmos_obj_refd(spa->spa_condensing_indirect_phys.\n\t    scip_next_mapping_object);\n\tmos_obj_refd(spa->spa_condensing_indirect_phys.\n\t    scip_prev_obsolete_sm_object);\n\tif (spa->spa_condensing_indirect_phys.scip_next_mapping_object != 0) {\n\t\tvdev_indirect_mapping_t *vim =\n\t\t    vdev_indirect_mapping_open(mos,\n\t\t    spa->spa_condensing_indirect_phys.scip_next_mapping_object);\n\t\tmos_obj_refd(vim->vim_phys->vimp_counts_object);\n\t\tvdev_indirect_mapping_close(vim);\n\t}\n\tdeleted_livelists_dump_mos(spa);\n\n\tif (dp->dp_origin_snap != NULL) {\n\t\tdsl_dataset_t *ds;\n\n\t\tdsl_pool_config_enter(dp, FTAG);\n\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t    dsl_dataset_phys(dp->dp_origin_snap)->ds_next_snap_obj,\n\t\t    FTAG, &ds));\n\t\tcount_ds_mos_objects(ds);\n\t\tdump_blkptr_list(&ds->ds_deadlist, \"Deadlist\");\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tdsl_pool_config_exit(dp, FTAG);\n\n\t\tcount_ds_mos_objects(dp->dp_origin_snap);\n\t\tdump_blkptr_list(&dp->dp_origin_snap->ds_deadlist, \"Deadlist\");\n\t}\n\tcount_dir_mos_objects(dp->dp_mos_dir);\n\tif (dp->dp_free_dir != NULL)\n\t\tcount_dir_mos_objects(dp->dp_free_dir);\n\tif (dp->dp_leak_dir != NULL)\n\t\tcount_dir_mos_objects(dp->dp_leak_dir);\n\n\tmos_leak_vdev(spa->spa_root_vdev);\n\n\tfor (uint64_t class = 0; class < DDT_CLASSES; class++) {\n\t\tfor (uint64_t type = 0; type < DDT_TYPES; type++) {\n\t\t\tfor (uint64_t cksum = 0;\n\t\t\t    cksum < ZIO_CHECKSUM_FUNCTIONS; cksum++) {\n\t\t\t\tddt_t *ddt = spa->spa_ddt[cksum];\n\t\t\t\tmos_obj_refd(ddt->ddt_object[type][class]);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tuint64_t object = 0;\n\twhile (dmu_object_next(mos, &object, B_FALSE, 0) == 0) {\n\t\tif (range_tree_contains(mos_refd_objs, object, 1)) {\n\t\t\trange_tree_remove(mos_refd_objs, object, 1);\n\t\t} else {\n\t\t\tdmu_object_info_t doi;\n\t\t\tconst char *name;\n\t\t\tVERIFY0(dmu_object_info(mos, object, &doi));\n\t\t\tif (doi.doi_type & DMU_OT_NEWTYPE) {\n\t\t\t\tdmu_object_byteswap_t bswap =\n\t\t\t\t    DMU_OT_BYTESWAP(doi.doi_type);\n\t\t\t\tname = dmu_ot_byteswap[bswap].ob_name;\n\t\t\t} else {\n\t\t\t\tname = dmu_ot[doi.doi_type].ot_name;\n\t\t\t}\n\n\t\t\t(void) printf(\"MOS object %llu (%s) leaked\\n\",\n\t\t\t    (u_longlong_t)object, name);\n\t\t\trv = 2;\n\t\t}\n\t}\n\t(void) range_tree_walk(mos_refd_objs, mos_leaks_cb, NULL);\n\tif (!range_tree_is_empty(mos_refd_objs))\n\t\trv = 2;\n\trange_tree_vacate(mos_refd_objs, NULL, NULL);\n\trange_tree_destroy(mos_refd_objs);\n\treturn (rv);\n}\n\ntypedef struct log_sm_obsolete_stats_arg {\n\tuint64_t lsos_current_txg;\n\n\tuint64_t lsos_total_entries;\n\tuint64_t lsos_valid_entries;\n\n\tuint64_t lsos_sm_entries;\n\tuint64_t lsos_valid_sm_entries;\n} log_sm_obsolete_stats_arg_t;\n\nstatic int\nlog_spacemap_obsolete_stats_cb(spa_t *spa, space_map_entry_t *sme,\n    uint64_t txg, void *arg)\n{\n\tlog_sm_obsolete_stats_arg_t *lsos = arg;\n\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t vdev_id = sme->sme_vdev;\n\n\tif (lsos->lsos_current_txg == 0) {\n\t\t \n\t\tlsos->lsos_current_txg = txg;\n\t} else if (lsos->lsos_current_txg < txg) {\n\t\t \n\t\t(void) printf(\"%-8llu valid entries out of %-8llu - txg %llu\\n\",\n\t\t    (u_longlong_t)lsos->lsos_valid_sm_entries,\n\t\t    (u_longlong_t)lsos->lsos_sm_entries,\n\t\t    (u_longlong_t)lsos->lsos_current_txg);\n\t\tlsos->lsos_valid_sm_entries = 0;\n\t\tlsos->lsos_sm_entries = 0;\n\t\tlsos->lsos_current_txg = txg;\n\t}\n\tASSERT3U(lsos->lsos_current_txg, ==, txg);\n\n\tlsos->lsos_sm_entries++;\n\tlsos->lsos_total_entries++;\n\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\tif (!vdev_is_concrete(vd))\n\t\treturn (0);\n\n\tmetaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\tASSERT(sme->sme_type == SM_ALLOC || sme->sme_type == SM_FREE);\n\n\tif (txg < metaslab_unflushed_txg(ms))\n\t\treturn (0);\n\tlsos->lsos_valid_sm_entries++;\n\tlsos->lsos_valid_entries++;\n\treturn (0);\n}\n\nstatic void\ndump_log_spacemap_obsolete_stats(spa_t *spa)\n{\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP))\n\t\treturn;\n\n\tlog_sm_obsolete_stats_arg_t lsos = {0};\n\n\t(void) printf(\"Log Space Map Obsolete Entry Statistics:\\n\");\n\n\titerate_through_spacemap_logs(spa,\n\t    log_spacemap_obsolete_stats_cb, &lsos);\n\n\t \n\t(void) printf(\"%-8llu valid entries out of %-8llu - txg %llu\\n\",\n\t    (u_longlong_t)lsos.lsos_valid_sm_entries,\n\t    (u_longlong_t)lsos.lsos_sm_entries,\n\t    (u_longlong_t)lsos.lsos_current_txg);\n\n\t(void) printf(\"%-8llu valid entries out of %-8llu - total\\n\\n\",\n\t    (u_longlong_t)lsos.lsos_valid_entries,\n\t    (u_longlong_t)lsos.lsos_total_entries);\n}\n\nstatic void\ndump_zpool(spa_t *spa)\n{\n\tdsl_pool_t *dp = spa_get_dsl(spa);\n\tint rc = 0;\n\n\tif (dump_opt['y']) {\n\t\tlivelist_metaslab_validate(spa);\n\t}\n\n\tif (dump_opt['S']) {\n\t\tdump_simulated_ddt(spa);\n\t\treturn;\n\t}\n\n\tif (!dump_opt['e'] && dump_opt['C'] > 1) {\n\t\t(void) printf(\"\\nCached configuration:\\n\");\n\t\tdump_nvlist(spa->spa_config, 8);\n\t}\n\n\tif (dump_opt['C'])\n\t\tdump_config(spa);\n\n\tif (dump_opt['u'])\n\t\tdump_uberblock(&spa->spa_uberblock, \"\\nUberblock:\\n\", \"\\n\");\n\n\tif (dump_opt['D'])\n\t\tdump_all_ddts(spa);\n\n\tif (dump_opt['T'])\n\t\tdump_brt(spa);\n\n\tif (dump_opt['d'] > 2 || dump_opt['m'])\n\t\tdump_metaslabs(spa);\n\tif (dump_opt['M'])\n\t\tdump_metaslab_groups(spa, dump_opt['M'] > 1);\n\tif (dump_opt['d'] > 2 || dump_opt['m']) {\n\t\tdump_log_spacemaps(spa);\n\t\tdump_log_spacemap_obsolete_stats(spa);\n\t}\n\n\tif (dump_opt['d'] || dump_opt['i']) {\n\t\tspa_feature_t f;\n\t\tmos_refd_objs = range_tree_create(NULL, RANGE_SEG64, NULL, 0,\n\t\t    0);\n\t\tdump_objset(dp->dp_meta_objset);\n\n\t\tif (dump_opt['d'] >= 3) {\n\t\t\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\t\t\tdump_full_bpobj(&spa->spa_deferred_bpobj,\n\t\t\t    \"Deferred frees\", 0);\n\t\t\tif (spa_version(spa) >= SPA_VERSION_DEADLISTS) {\n\t\t\t\tdump_full_bpobj(&dp->dp_free_bpobj,\n\t\t\t\t    \"Pool snapshot frees\", 0);\n\t\t\t}\n\t\t\tif (bpobj_is_open(&dp->dp_obsolete_bpobj)) {\n\t\t\t\tASSERT(spa_feature_is_enabled(spa,\n\t\t\t\t    SPA_FEATURE_DEVICE_REMOVAL));\n\t\t\t\tdump_full_bpobj(&dp->dp_obsolete_bpobj,\n\t\t\t\t    \"Pool obsolete blocks\", 0);\n\t\t\t}\n\n\t\t\tif (spa_feature_is_active(spa,\n\t\t\t    SPA_FEATURE_ASYNC_DESTROY)) {\n\t\t\t\tdump_bptree(spa->spa_meta_objset,\n\t\t\t\t    dp->dp_bptree_obj,\n\t\t\t\t    \"Pool dataset frees\");\n\t\t\t}\n\t\t\tdump_dtl(spa->spa_root_vdev, 0);\n\t\t}\n\n\t\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++)\n\t\t\tglobal_feature_count[f] = UINT64_MAX;\n\t\tglobal_feature_count[SPA_FEATURE_REDACTION_BOOKMARKS] = 0;\n\t\tglobal_feature_count[SPA_FEATURE_BOOKMARK_WRITTEN] = 0;\n\t\tglobal_feature_count[SPA_FEATURE_LIVELIST] = 0;\n\n\t\t(void) dmu_objset_find(spa_name(spa), dump_one_objset,\n\t\t    NULL, DS_FIND_SNAPSHOTS | DS_FIND_CHILDREN);\n\n\t\tif (rc == 0 && !dump_opt['L'])\n\t\t\trc = dump_mos_leaks(spa);\n\n\t\tfor (f = 0; f < SPA_FEATURES; f++) {\n\t\t\tuint64_t refcount;\n\n\t\t\tuint64_t *arr;\n\t\t\tif (!(spa_feature_table[f].fi_flags &\n\t\t\t    ZFEATURE_FLAG_PER_DATASET)) {\n\t\t\t\tif (global_feature_count[f] == UINT64_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!spa_feature_is_enabled(spa, f)) {\n\t\t\t\t\tASSERT0(global_feature_count[f]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tarr = global_feature_count;\n\t\t\t} else {\n\t\t\t\tif (!spa_feature_is_enabled(spa, f)) {\n\t\t\t\t\tASSERT0(dataset_feature_count[f]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tarr = dataset_feature_count;\n\t\t\t}\n\t\t\tif (feature_get_refcount(spa, &spa_feature_table[f],\n\t\t\t    &refcount) == ENOTSUP)\n\t\t\t\tcontinue;\n\t\t\tif (arr[f] != refcount) {\n\t\t\t\t(void) printf(\"%s feature refcount mismatch: \"\n\t\t\t\t    \"%lld consumers != %lld refcount\\n\",\n\t\t\t\t    spa_feature_table[f].fi_uname,\n\t\t\t\t    (longlong_t)arr[f], (longlong_t)refcount);\n\t\t\t\trc = 2;\n\t\t\t} else {\n\t\t\t\t(void) printf(\"Verified %s feature refcount \"\n\t\t\t\t    \"of %llu is correct\\n\",\n\t\t\t\t    spa_feature_table[f].fi_uname,\n\t\t\t\t    (longlong_t)refcount);\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0)\n\t\t\trc = verify_device_removal_feature_counts(spa);\n\t}\n\n\tif (rc == 0 && (dump_opt['b'] || dump_opt['c']))\n\t\trc = dump_block_stats(spa);\n\n\tif (rc == 0)\n\t\trc = verify_spacemap_refcounts(spa);\n\n\tif (dump_opt['s'])\n\t\tshow_pool_stats(spa);\n\n\tif (dump_opt['h'])\n\t\tdump_history(spa);\n\n\tif (rc == 0)\n\t\trc = verify_checkpoint(spa);\n\n\tif (rc != 0) {\n\t\tdump_debug_buffer();\n\t\texit(rc);\n\t}\n}\n\n#define\tZDB_FLAG_CHECKSUM\t0x0001\n#define\tZDB_FLAG_DECOMPRESS\t0x0002\n#define\tZDB_FLAG_BSWAP\t\t0x0004\n#define\tZDB_FLAG_GBH\t\t0x0008\n#define\tZDB_FLAG_INDIRECT\t0x0010\n#define\tZDB_FLAG_RAW\t\t0x0020\n#define\tZDB_FLAG_PRINT_BLKPTR\t0x0040\n#define\tZDB_FLAG_VERBOSE\t0x0080\n\nstatic int flagbits[256];\nstatic char flagbitstr[16];\n\nstatic void\nzdb_print_blkptr(const blkptr_t *bp, int flags)\n{\n\tchar blkbuf[BP_SPRINTF_LEN];\n\n\tif (flags & ZDB_FLAG_BSWAP)\n\t\tbyteswap_uint64_array((void *)bp, sizeof (blkptr_t));\n\n\tsnprintf_blkptr(blkbuf, sizeof (blkbuf), bp);\n\t(void) printf(\"%s\\n\", blkbuf);\n}\n\nstatic void\nzdb_dump_indirect(blkptr_t *bp, int nbps, int flags)\n{\n\tint i;\n\n\tfor (i = 0; i < nbps; i++)\n\t\tzdb_print_blkptr(&bp[i], flags);\n}\n\nstatic void\nzdb_dump_gbh(void *buf, int flags)\n{\n\tzdb_dump_indirect((blkptr_t *)buf, SPA_GBH_NBLKPTRS, flags);\n}\n\nstatic void\nzdb_dump_block_raw(void *buf, uint64_t size, int flags)\n{\n\tif (flags & ZDB_FLAG_BSWAP)\n\t\tbyteswap_uint64_array(buf, size);\n\tVERIFY(write(fileno(stdout), buf, size) == size);\n}\n\nstatic void\nzdb_dump_block(char *label, void *buf, uint64_t size, int flags)\n{\n\tuint64_t *d = (uint64_t *)buf;\n\tunsigned nwords = size / sizeof (uint64_t);\n\tint do_bswap = !!(flags & ZDB_FLAG_BSWAP);\n\tunsigned i, j;\n\tconst char *hdr;\n\tchar *c;\n\n\n\tif (do_bswap)\n\t\thdr = \" 7 6 5 4 3 2 1 0   f e d c b a 9 8\";\n\telse\n\t\thdr = \" 0 1 2 3 4 5 6 7   8 9 a b c d e f\";\n\n\t(void) printf(\"\\n%s\\n%6s   %s  0123456789abcdef\\n\", label, \"\", hdr);\n\n#ifdef _LITTLE_ENDIAN\n\t \n\tdo_bswap = !do_bswap;\n#endif\n\tfor (i = 0; i < nwords; i += 2) {\n\t\t(void) printf(\"%06llx:  %016llx  %016llx  \",\n\t\t    (u_longlong_t)(i * sizeof (uint64_t)),\n\t\t    (u_longlong_t)(do_bswap ? BSWAP_64(d[i]) : d[i]),\n\t\t    (u_longlong_t)(do_bswap ? BSWAP_64(d[i + 1]) : d[i + 1]));\n\n\t\tc = (char *)&d[i];\n\t\tfor (j = 0; j < 2 * sizeof (uint64_t); j++)\n\t\t\t(void) printf(\"%c\", isprint(c[j]) ? c[j] : '.');\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\n \nstatic vdev_t *\nzdb_vdev_lookup(vdev_t *vdev, const char *path)\n{\n\tchar *s, *p, *q;\n\tunsigned i;\n\n\tif (vdev == NULL)\n\t\treturn (NULL);\n\n\t \n\ti = strtoul(path, &s, 10);\n\tif (s == path || (s && *s != '.' && *s != '\\0'))\n\t\tgoto name;\n\tif (i >= vdev->vdev_children)\n\t\treturn (NULL);\n\n\tvdev = vdev->vdev_child[i];\n\tif (s && *s == '\\0')\n\t\treturn (vdev);\n\treturn (zdb_vdev_lookup(vdev, s+1));\n\nname:\n\tfor (i = 0; i < vdev->vdev_children; i++) {\n\t\tvdev_t *vc = vdev->vdev_child[i];\n\n\t\tif (vc->vdev_path == NULL) {\n\t\t\tvc = zdb_vdev_lookup(vc, path);\n\t\t\tif (vc == NULL)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn (vc);\n\t\t}\n\n\t\tp = strrchr(vc->vdev_path, '/');\n\t\tp = p ? p + 1 : vc->vdev_path;\n\t\tq = &vc->vdev_path[strlen(vc->vdev_path) - 2];\n\n\t\tif (strcmp(vc->vdev_path, path) == 0)\n\t\t\treturn (vc);\n\t\tif (strcmp(p, path) == 0)\n\t\t\treturn (vc);\n\t\tif (strcmp(q, \"s0\") == 0 && strncmp(p, path, q - p) == 0)\n\t\t\treturn (vc);\n\t}\n\n\treturn (NULL);\n}\n\nstatic int\nname_from_objset_id(spa_t *spa, uint64_t objset_id, char *outstr)\n{\n\tdsl_dataset_t *ds;\n\n\tdsl_pool_config_enter(spa->spa_dsl_pool, FTAG);\n\tint error = dsl_dataset_hold_obj(spa->spa_dsl_pool, objset_id,\n\t    NULL, &ds);\n\tif (error != 0) {\n\t\t(void) fprintf(stderr, \"failed to hold objset %llu: %s\\n\",\n\t\t    (u_longlong_t)objset_id, strerror(error));\n\t\tdsl_pool_config_exit(spa->spa_dsl_pool, FTAG);\n\t\treturn (error);\n\t}\n\tdsl_dataset_name(ds, outstr);\n\tdsl_dataset_rele(ds, NULL);\n\tdsl_pool_config_exit(spa->spa_dsl_pool, FTAG);\n\treturn (0);\n}\n\nstatic boolean_t\nzdb_parse_block_sizes(char *sizes, uint64_t *lsize, uint64_t *psize)\n{\n\tchar *s0, *s1, *tmp = NULL;\n\n\tif (sizes == NULL)\n\t\treturn (B_FALSE);\n\n\ts0 = strtok_r(sizes, \"/\", &tmp);\n\tif (s0 == NULL)\n\t\treturn (B_FALSE);\n\ts1 = strtok_r(NULL, \"/\", &tmp);\n\t*lsize = strtoull(s0, NULL, 16);\n\t*psize = s1 ? strtoull(s1, NULL, 16) : *lsize;\n\treturn (*lsize >= *psize && *psize > 0);\n}\n\n#define\tZIO_COMPRESS_MASK(alg)\t(1ULL << (ZIO_COMPRESS_##alg))\n\nstatic boolean_t\nzdb_decompress_block(abd_t *pabd, void *buf, void *lbuf, uint64_t lsize,\n    uint64_t psize, int flags)\n{\n\t(void) buf;\n\tboolean_t exceeded = B_FALSE;\n\t \n\tvoid *lbuf2 = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\tint cfuncs[ZIO_COMPRESS_FUNCTIONS] = { 0 };\n\tint *cfuncp = cfuncs;\n\tuint64_t maxlsize = SPA_MAXBLOCKSIZE;\n\tuint64_t mask = ZIO_COMPRESS_MASK(ON) | ZIO_COMPRESS_MASK(OFF) |\n\t    ZIO_COMPRESS_MASK(INHERIT) | ZIO_COMPRESS_MASK(EMPTY) |\n\t    (getenv(\"ZDB_NO_ZLE\") ? ZIO_COMPRESS_MASK(ZLE) : 0);\n\t*cfuncp++ = ZIO_COMPRESS_LZ4;\n\t*cfuncp++ = ZIO_COMPRESS_LZJB;\n\tmask |= ZIO_COMPRESS_MASK(LZ4) | ZIO_COMPRESS_MASK(LZJB);\n\tfor (int c = 0; c < ZIO_COMPRESS_FUNCTIONS; c++)\n\t\tif (((1ULL << c) & mask) == 0)\n\t\t\t*cfuncp++ = c;\n\n\t \n\tif (lsize == psize)\n\t\tlsize += SPA_MINBLOCKSIZE;\n\telse\n\t\tmaxlsize = lsize;\n\tfor (; lsize <= maxlsize; lsize += SPA_MINBLOCKSIZE) {\n\t\tfor (cfuncp = cfuncs; *cfuncp; cfuncp++) {\n\t\t\tif (flags & ZDB_FLAG_VERBOSE) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"Trying %05llx -> %05llx (%s)\\n\",\n\t\t\t\t    (u_longlong_t)psize,\n\t\t\t\t    (u_longlong_t)lsize,\n\t\t\t\t    zio_compress_table[*cfuncp].\\\n\t\t\t\t    ci_name);\n\t\t\t}\n\n\t\t\t \n\t\t\tVERIFY0(random_get_pseudo_bytes(lbuf2, lsize));\n\n\t\t\tif (zio_decompress_data(*cfuncp, pabd,\n\t\t\t    lbuf, psize, lsize, NULL) == 0 &&\n\t\t\t    zio_decompress_data(*cfuncp, pabd,\n\t\t\t    lbuf2, psize, lsize, NULL) == 0 &&\n\t\t\t    memcmp(lbuf, lbuf2, lsize) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*cfuncp != 0)\n\t\t\tbreak;\n\t}\n\tumem_free(lbuf2, SPA_MAXBLOCKSIZE);\n\n\tif (lsize > maxlsize) {\n\t\texceeded = B_TRUE;\n\t}\n\tif (*cfuncp == ZIO_COMPRESS_ZLE) {\n\t\tprintf(\"\\nZLE decompression was selected. If you \"\n\t\t    \"suspect the results are wrong,\\ntry avoiding ZLE \"\n\t\t    \"by setting and exporting ZDB_NO_ZLE=\\\"true\\\"\\n\");\n\t}\n\n\treturn (exceeded);\n}\n\n \nstatic void\nzdb_read_block(char *thing, spa_t *spa)\n{\n\tblkptr_t blk, *bp = &blk;\n\tdva_t *dva = bp->blk_dva;\n\tint flags = 0;\n\tuint64_t offset = 0, psize = 0, lsize = 0, blkptr_offset = 0;\n\tzio_t *zio;\n\tvdev_t *vd;\n\tabd_t *pabd;\n\tvoid *lbuf, *buf;\n\tchar *s, *p, *dup, *flagstr, *sizes, *tmp = NULL;\n\tconst char *vdev, *errmsg = NULL;\n\tint i, error;\n\tboolean_t borrowed = B_FALSE, found = B_FALSE;\n\n\tdup = strdup(thing);\n\ts = strtok_r(dup, \":\", &tmp);\n\tvdev = s ?: \"\";\n\ts = strtok_r(NULL, \":\", &tmp);\n\toffset = strtoull(s ? s : \"\", NULL, 16);\n\tsizes = strtok_r(NULL, \":\", &tmp);\n\ts = strtok_r(NULL, \":\", &tmp);\n\tflagstr = strdup(s ?: \"\");\n\n\tif (!zdb_parse_block_sizes(sizes, &lsize, &psize))\n\t\terrmsg = \"invalid size(s)\";\n\tif (!IS_P2ALIGNED(psize, DEV_BSIZE) || !IS_P2ALIGNED(lsize, DEV_BSIZE))\n\t\terrmsg = \"size must be a multiple of sector size\";\n\tif (!IS_P2ALIGNED(offset, DEV_BSIZE))\n\t\terrmsg = \"offset must be a multiple of sector size\";\n\tif (errmsg) {\n\t\t(void) printf(\"Invalid block specifier: %s  - %s\\n\",\n\t\t    thing, errmsg);\n\t\tgoto done;\n\t}\n\n\ttmp = NULL;\n\tfor (s = strtok_r(flagstr, \":\", &tmp);\n\t    s != NULL;\n\t    s = strtok_r(NULL, \":\", &tmp)) {\n\t\tfor (i = 0; i < strlen(flagstr); i++) {\n\t\t\tint bit = flagbits[(uchar_t)flagstr[i]];\n\n\t\t\tif (bit == 0) {\n\t\t\t\t(void) printf(\"***Ignoring flag: %c\\n\",\n\t\t\t\t    (uchar_t)flagstr[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = B_TRUE;\n\t\t\tflags |= bit;\n\n\t\t\tp = &flagstr[i + 1];\n\t\t\tif (*p != ':' && *p != '\\0') {\n\t\t\t\tint j = 0, nextbit = flagbits[(uchar_t)*p];\n\t\t\t\tchar *end, offstr[8] = { 0 };\n\t\t\t\tif ((bit == ZDB_FLAG_PRINT_BLKPTR) &&\n\t\t\t\t    (nextbit == 0)) {\n\t\t\t\t\t \n\t\t\t\t\twhile (nextbit == 0 &&\n\t\t\t\t\t    strchr(flagbitstr, *p) == NULL) {\n\t\t\t\t\t\toffstr[j] = *p;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tif (i + j > strlen(flagstr))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tnextbit = flagbits[(uchar_t)*p];\n\t\t\t\t\t}\n\t\t\t\t\tblkptr_offset = strtoull(offstr, &end,\n\t\t\t\t\t    16);\n\t\t\t\t\ti += j;\n\t\t\t\t} else if (nextbit == 0) {\n\t\t\t\t\t(void) printf(\"***Ignoring flag arg:\"\n\t\t\t\t\t    \" '%c'\\n\", (uchar_t)*p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (blkptr_offset % sizeof (blkptr_t)) {\n\t\tprintf(\"Block pointer offset 0x%llx \"\n\t\t    \"must be divisible by 0x%x\\n\",\n\t\t    (longlong_t)blkptr_offset, (int)sizeof (blkptr_t));\n\t\tgoto done;\n\t}\n\tif (found == B_FALSE && strlen(flagstr) > 0) {\n\t\tprintf(\"Invalid flag arg: '%s'\\n\", flagstr);\n\t\tgoto done;\n\t}\n\n\tvd = zdb_vdev_lookup(spa->spa_root_vdev, vdev);\n\tif (vd == NULL) {\n\t\t(void) printf(\"***Invalid vdev: %s\\n\", vdev);\n\t\tgoto done;\n\t} else {\n\t\tif (vd->vdev_path)\n\t\t\t(void) fprintf(stderr, \"Found vdev: %s\\n\",\n\t\t\t    vd->vdev_path);\n\t\telse\n\t\t\t(void) fprintf(stderr, \"Found vdev type: %s\\n\",\n\t\t\t    vd->vdev_ops->vdev_op_type);\n\t}\n\n\tpabd = abd_alloc_for_io(SPA_MAXBLOCKSIZE, B_FALSE);\n\tlbuf = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);\n\n\tBP_ZERO(bp);\n\n\tDVA_SET_VDEV(&dva[0], vd->vdev_id);\n\tDVA_SET_OFFSET(&dva[0], offset);\n\tDVA_SET_GANG(&dva[0], !!(flags & ZDB_FLAG_GBH));\n\tDVA_SET_ASIZE(&dva[0], vdev_psize_to_asize(vd, psize));\n\n\tBP_SET_BIRTH(bp, TXG_INITIAL, TXG_INITIAL);\n\n\tBP_SET_LSIZE(bp, lsize);\n\tBP_SET_PSIZE(bp, psize);\n\tBP_SET_COMPRESS(bp, ZIO_COMPRESS_OFF);\n\tBP_SET_CHECKSUM(bp, ZIO_CHECKSUM_OFF);\n\tBP_SET_TYPE(bp, DMU_OT_NONE);\n\tBP_SET_LEVEL(bp, 0);\n\tBP_SET_DEDUP(bp, 0);\n\tBP_SET_BYTEORDER(bp, ZFS_HOST_BYTEORDER);\n\n\tspa_config_enter(spa, SCL_STATE, FTAG, RW_READER);\n\tzio = zio_root(spa, NULL, NULL, 0);\n\n\tif (vd == vd->vdev_top) {\n\t\t \n\t\tzio_nowait(zio_read(zio, spa, bp, pabd, psize, NULL, NULL,\n\t\t    ZIO_PRIORITY_SYNC_READ,\n\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW, NULL));\n\t} else {\n\t\t \n\t\tzio_nowait(zio_vdev_child_io(zio, bp, vd, offset, pabd,\n\t\t    psize, ZIO_TYPE_READ, ZIO_PRIORITY_SYNC_READ,\n\t\t    ZIO_FLAG_DONT_PROPAGATE | ZIO_FLAG_DONT_RETRY |\n\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW | ZIO_FLAG_OPTIONAL,\n\t\t    NULL, NULL));\n\t}\n\n\terror = zio_wait(zio);\n\tspa_config_exit(spa, SCL_STATE, FTAG);\n\n\tif (error) {\n\t\t(void) printf(\"Read of %s failed, error: %d\\n\", thing, error);\n\t\tgoto out;\n\t}\n\n\tuint64_t orig_lsize = lsize;\n\tbuf = lbuf;\n\tif (flags & ZDB_FLAG_DECOMPRESS) {\n\t\tboolean_t failed = zdb_decompress_block(pabd, buf, lbuf,\n\t\t    lsize, psize, flags);\n\t\tif (failed) {\n\t\t\t(void) printf(\"Decompress of %s failed\\n\", thing);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tbuf = abd_borrow_buf_copy(pabd, lsize);\n\t\tborrowed = B_TRUE;\n\t}\n\t \n\tif ((flags & ZDB_FLAG_PRINT_BLKPTR || flags & ZDB_FLAG_INDIRECT) &&\n\t    !(flags & ZDB_FLAG_DECOMPRESS)) {\n\t\tconst blkptr_t *b = (const blkptr_t *)(void *)\n\t\t    ((uintptr_t)buf + (uintptr_t)blkptr_offset);\n\t\tif (zfs_blkptr_verify(spa, b,\n\t\t    BLK_CONFIG_NEEDED, BLK_VERIFY_ONLY) == B_FALSE) {\n\t\t\tabd_return_buf_copy(pabd, buf, lsize);\n\t\t\tborrowed = B_FALSE;\n\t\t\tbuf = lbuf;\n\t\t\tboolean_t failed = zdb_decompress_block(pabd, buf,\n\t\t\t    lbuf, lsize, psize, flags);\n\t\t\tb = (const blkptr_t *)(void *)\n\t\t\t    ((uintptr_t)buf + (uintptr_t)blkptr_offset);\n\t\t\tif (failed || zfs_blkptr_verify(spa, b,\n\t\t\t    BLK_CONFIG_NEEDED, BLK_VERIFY_LOG) == B_FALSE) {\n\t\t\t\tprintf(\"invalid block pointer at this DVA\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & ZDB_FLAG_PRINT_BLKPTR)\n\t\tzdb_print_blkptr((blkptr_t *)(void *)\n\t\t    ((uintptr_t)buf + (uintptr_t)blkptr_offset), flags);\n\telse if (flags & ZDB_FLAG_RAW)\n\t\tzdb_dump_block_raw(buf, lsize, flags);\n\telse if (flags & ZDB_FLAG_INDIRECT)\n\t\tzdb_dump_indirect((blkptr_t *)buf,\n\t\t    orig_lsize / sizeof (blkptr_t), flags);\n\telse if (flags & ZDB_FLAG_GBH)\n\t\tzdb_dump_gbh(buf, flags);\n\telse\n\t\tzdb_dump_block(thing, buf, lsize, flags);\n\n\t \n\tif ((flags & ZDB_FLAG_CHECKSUM) && !(flags & ZDB_FLAG_RAW) &&\n\t    !(flags & ZDB_FLAG_GBH)) {\n\t\tzio_t *czio;\n\t\t(void) printf(\"\\n\");\n\t\tfor (enum zio_checksum ck = ZIO_CHECKSUM_LABEL;\n\t\t    ck < ZIO_CHECKSUM_FUNCTIONS; ck++) {\n\n\t\t\tif ((zio_checksum_table[ck].ci_flags &\n\t\t\t    ZCHECKSUM_FLAG_EMBEDDED) ||\n\t\t\t    ck == ZIO_CHECKSUM_NOPARITY) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBP_SET_CHECKSUM(bp, ck);\n\t\t\tspa_config_enter(spa, SCL_STATE, FTAG, RW_READER);\n\t\t\tczio = zio_root(spa, NULL, NULL, ZIO_FLAG_CANFAIL);\n\t\t\tczio->io_bp = bp;\n\n\t\t\tif (vd == vd->vdev_top) {\n\t\t\t\tzio_nowait(zio_read(czio, spa, bp, pabd, psize,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    ZIO_PRIORITY_SYNC_READ,\n\t\t\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW |\n\t\t\t\t    ZIO_FLAG_DONT_RETRY, NULL));\n\t\t\t} else {\n\t\t\t\tzio_nowait(zio_vdev_child_io(czio, bp, vd,\n\t\t\t\t    offset, pabd, psize, ZIO_TYPE_READ,\n\t\t\t\t    ZIO_PRIORITY_SYNC_READ,\n\t\t\t\t    ZIO_FLAG_DONT_PROPAGATE |\n\t\t\t\t    ZIO_FLAG_DONT_RETRY |\n\t\t\t\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_RAW |\n\t\t\t\t    ZIO_FLAG_SPECULATIVE |\n\t\t\t\t    ZIO_FLAG_OPTIONAL, NULL, NULL));\n\t\t\t}\n\t\t\terror = zio_wait(czio);\n\t\t\tif (error == 0 || error == ECKSUM) {\n\t\t\t\tzio_t *ck_zio = zio_root(spa, NULL, NULL, 0);\n\t\t\t\tck_zio->io_offset =\n\t\t\t\t    DVA_GET_OFFSET(&bp->blk_dva[0]);\n\t\t\t\tck_zio->io_bp = bp;\n\t\t\t\tzio_checksum_compute(ck_zio, ck, pabd, lsize);\n\t\t\t\tprintf(\n\t\t\t\t    \"%12s\\t\"\n\t\t\t\t    \"cksum=%016llx:%016llx:%016llx:%016llx\\n\",\n\t\t\t\t    zio_checksum_table[ck].ci_name,\n\t\t\t\t    (u_longlong_t)bp->blk_cksum.zc_word[0],\n\t\t\t\t    (u_longlong_t)bp->blk_cksum.zc_word[1],\n\t\t\t\t    (u_longlong_t)bp->blk_cksum.zc_word[2],\n\t\t\t\t    (u_longlong_t)bp->blk_cksum.zc_word[3]);\n\t\t\t\tzio_wait(ck_zio);\n\t\t\t} else {\n\t\t\t\tprintf(\"error %d reading block\\n\", error);\n\t\t\t}\n\t\t\tspa_config_exit(spa, SCL_STATE, FTAG);\n\t\t}\n\t}\n\n\tif (borrowed)\n\t\tabd_return_buf_copy(pabd, buf, lsize);\n\nout:\n\tabd_free(pabd);\n\tumem_free(lbuf, SPA_MAXBLOCKSIZE);\ndone:\n\tfree(flagstr);\n\tfree(dup);\n}\n\nstatic void\nzdb_embedded_block(char *thing)\n{\n\tblkptr_t bp = {{{{0}}}};\n\tunsigned long long *words = (void *)&bp;\n\tchar *buf;\n\tint err;\n\n\terr = sscanf(thing, \"%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx:\"\n\t    \"%llx:%llx:%llx:%llx:%llx:%llx:%llx:%llx\",\n\t    words + 0, words + 1, words + 2, words + 3,\n\t    words + 4, words + 5, words + 6, words + 7,\n\t    words + 8, words + 9, words + 10, words + 11,\n\t    words + 12, words + 13, words + 14, words + 15);\n\tif (err != 16) {\n\t\t(void) fprintf(stderr, \"invalid input format\\n\");\n\t\texit(1);\n\t}\n\tASSERT3U(BPE_GET_LSIZE(&bp), <=, SPA_MAXBLOCKSIZE);\n\tbuf = malloc(SPA_MAXBLOCKSIZE);\n\tif (buf == NULL) {\n\t\t(void) fprintf(stderr, \"out of memory\\n\");\n\t\texit(1);\n\t}\n\terr = decode_embedded_bp(&bp, buf, BPE_GET_LSIZE(&bp));\n\tif (err != 0) {\n\t\t(void) fprintf(stderr, \"decode failed: %u\\n\", err);\n\t\texit(1);\n\t}\n\tzdb_dump_block_raw(buf, BPE_GET_LSIZE(&bp), 0);\n\tfree(buf);\n}\n\n \nstatic boolean_t\nzdb_numeric(char *str)\n{\n\tint i = 0;\n\n\tif (strlen(str) == 0)\n\t\treturn (B_FALSE);\n\tif (strncmp(str, \"0x\", 2) == 0 || strncmp(str, \"0X\", 2) == 0)\n\t\ti = 2;\n\tfor (; i < strlen(str); i++) {\n\t\tif (!isxdigit(str[i]))\n\t\t\treturn (B_FALSE);\n\t}\n\treturn (B_TRUE);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint c;\n\tspa_t *spa = NULL;\n\tobjset_t *os = NULL;\n\tint dump_all = 1;\n\tint verbose = 0;\n\tint error = 0;\n\tchar **searchdirs = NULL;\n\tint nsearch = 0;\n\tchar *target, *target_pool, dsname[ZFS_MAX_DATASET_NAME_LEN];\n\tnvlist_t *policy = NULL;\n\tuint64_t max_txg = UINT64_MAX;\n\tint64_t objset_id = -1;\n\tuint64_t object;\n\tint flags = ZFS_IMPORT_MISSING_LOG;\n\tint rewind = ZPOOL_NEVER_REWIND;\n\tchar *spa_config_path_env, *objset_str;\n\tboolean_t target_is_spa = B_TRUE, dataset_lookup = B_FALSE;\n\tnvlist_t *cfg = NULL;\n\n\tdprintf_setup(&argc, argv);\n\n\t \n\tspa_config_path_env = getenv(\"SPA_CONFIG_PATH\");\n\tif (spa_config_path_env != NULL)\n\t\tspa_config_path = spa_config_path_env;\n\n\t \n\tzfs_btree_verify_intensity = 3;\n\n\tstruct option long_options[] = {\n\t\t{\"ignore-assertions\",\tno_argument,\t\tNULL, 'A'},\n\t\t{\"block-stats\",\t\tno_argument,\t\tNULL, 'b'},\n\t\t{\"backup\",\t\tno_argument,\t\tNULL, 'B'},\n\t\t{\"checksum\",\t\tno_argument,\t\tNULL, 'c'},\n\t\t{\"config\",\t\tno_argument,\t\tNULL, 'C'},\n\t\t{\"datasets\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"dedup-stats\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"exported\",\t\tno_argument,\t\tNULL, 'e'},\n\t\t{\"embedded-block-pointer\",\tno_argument,\tNULL, 'E'},\n\t\t{\"automatic-rewind\",\tno_argument,\t\tNULL, 'F'},\n\t\t{\"dump-debug-msg\",\tno_argument,\t\tNULL, 'G'},\n\t\t{\"history\",\t\tno_argument,\t\tNULL, 'h'},\n\t\t{\"intent-logs\",\t\tno_argument,\t\tNULL, 'i'},\n\t\t{\"inflight\",\t\trequired_argument,\tNULL, 'I'},\n\t\t{\"checkpointed-state\",\tno_argument,\t\tNULL, 'k'},\n\t\t{\"key\",\t\t\trequired_argument,\tNULL, 'K'},\n\t\t{\"label\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"disable-leak-tracking\",\tno_argument,\tNULL, 'L'},\n\t\t{\"metaslabs\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"metaslab-groups\",\tno_argument,\t\tNULL, 'M'},\n\t\t{\"numeric\",\t\tno_argument,\t\tNULL, 'N'},\n\t\t{\"option\",\t\trequired_argument,\tNULL, 'o'},\n\t\t{\"object-lookups\",\tno_argument,\t\tNULL, 'O'},\n\t\t{\"path\",\t\trequired_argument,\tNULL, 'p'},\n\t\t{\"parseable\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"skip-label\",\t\tno_argument,\t\tNULL, 'q'},\n\t\t{\"copy-object\",\t\tno_argument,\t\tNULL, 'r'},\n\t\t{\"read-block\",\t\tno_argument,\t\tNULL, 'R'},\n\t\t{\"io-stats\",\t\tno_argument,\t\tNULL, 's'},\n\t\t{\"simulate-dedup\",\tno_argument,\t\tNULL, 'S'},\n\t\t{\"txg\",\t\t\trequired_argument,\tNULL, 't'},\n\t\t{\"brt-stats\",\t\tno_argument,\t\tNULL, 'T'},\n\t\t{\"uberblock\",\t\tno_argument,\t\tNULL, 'u'},\n\t\t{\"cachefile\",\t\trequired_argument,\tNULL, 'U'},\n\t\t{\"verbose\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"verbatim\",\t\tno_argument,\t\tNULL, 'V'},\n\t\t{\"dump-blocks\",\t\trequired_argument,\tNULL, 'x'},\n\t\t{\"extreme-rewind\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"all-reconstruction\",\tno_argument,\t\tNULL, 'Y'},\n\t\t{\"livelist\",\t\tno_argument,\t\tNULL, 'y'},\n\t\t{\"zstd-headers\",\tno_argument,\t\tNULL, 'Z'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\twhile ((c = getopt_long(argc, argv,\n\t    \"AbBcCdDeEFGhiI:kK:lLmMNo:Op:PqrRsSt:TuU:vVx:XYyZ\",\n\t    long_options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\tcase 'B':\n\t\tcase 'c':\n\t\tcase 'C':\n\t\tcase 'd':\n\t\tcase 'D':\n\t\tcase 'E':\n\t\tcase 'G':\n\t\tcase 'h':\n\t\tcase 'i':\n\t\tcase 'l':\n\t\tcase 'm':\n\t\tcase 'M':\n\t\tcase 'N':\n\t\tcase 'O':\n\t\tcase 'r':\n\t\tcase 'R':\n\t\tcase 's':\n\t\tcase 'S':\n\t\tcase 'T':\n\t\tcase 'u':\n\t\tcase 'y':\n\t\tcase 'Z':\n\t\t\tdump_opt[c]++;\n\t\t\tdump_all = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\tcase 'e':\n\t\tcase 'F':\n\t\tcase 'k':\n\t\tcase 'L':\n\t\tcase 'P':\n\t\tcase 'q':\n\t\tcase 'X':\n\t\t\tdump_opt[c]++;\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\tzfs_reconstruct_indirect_combinations_max = INT_MAX;\n\t\t\tzfs_deadman_enabled = 0;\n\t\t\tbreak;\n\t\t \n\t\tcase 'I':\n\t\t\tmax_inflight_bytes = strtoull(optarg, NULL, 0);\n\t\t\tif (max_inflight_bytes == 0) {\n\t\t\t\t(void) fprintf(stderr, \"maximum number \"\n\t\t\t\t    \"of inflight bytes must be greater \"\n\t\t\t\t    \"than 0\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tdump_opt[c]++;\n\t\t\tkey_material = strdup(optarg);\n\t\t\t \n\t\t\twhile (*optarg != '\\0') { *optarg++ = '*'; }\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\terror = set_global_var(optarg);\n\t\t\tif (error != 0)\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (searchdirs == NULL) {\n\t\t\t\tsearchdirs = umem_alloc(sizeof (char *),\n\t\t\t\t    UMEM_NOFAIL);\n\t\t\t} else {\n\t\t\t\tchar **tmp = umem_alloc((nsearch + 1) *\n\t\t\t\t    sizeof (char *), UMEM_NOFAIL);\n\t\t\t\tmemcpy(tmp, searchdirs, nsearch *\n\t\t\t\t    sizeof (char *));\n\t\t\t\tumem_free(searchdirs,\n\t\t\t\t    nsearch * sizeof (char *));\n\t\t\t\tsearchdirs = tmp;\n\t\t\t}\n\t\t\tsearchdirs[nsearch++] = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tmax_txg = strtoull(optarg, NULL, 0);\n\t\t\tif (max_txg < TXG_INITIAL) {\n\t\t\t\t(void) fprintf(stderr, \"incorrect txg \"\n\t\t\t\t    \"specified: %s\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tspa_config_path = optarg;\n\t\t\tif (spa_config_path[0] != '/') {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"cachefile must be an absolute path \"\n\t\t\t\t    \"(i.e. start with a slash)\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tflags = ZFS_IMPORT_VERBATIM;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tvn_dumpdir = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dump_opt['e'] && searchdirs != NULL) {\n\t\t(void) fprintf(stderr, \"-p option requires use of -e\\n\");\n\t\tusage();\n\t}\n#if defined(_LP64)\n\t \n\tzfs_arc_min = 2ULL << SPA_MAXBLOCKSHIFT;\n\tzfs_arc_max = 256 * 1024 * 1024;\n#endif\n\n\t \n\tzfs_vdev_async_read_max_active = 10;\n\n\t \n\treference_tracking_enable = B_FALSE;\n\n\t \n\tspa_load_verify_dryrun = B_TRUE;\n\n\t \n\tspa_mode_readable_spacemaps = B_TRUE;\n\n\tkernel_init(SPA_MODE_READ);\n\n\tif (dump_all)\n\t\tverbose = MAX(verbose, 1);\n\n\tfor (c = 0; c < 256; c++) {\n\t\tif (dump_all && strchr(\"ABeEFkKlLNOPrRSXy\", c) == NULL)\n\t\t\tdump_opt[c] = 1;\n\t\tif (dump_opt[c])\n\t\t\tdump_opt[c] += verbose;\n\t}\n\n\tlibspl_set_assert_ok((dump_opt['A'] == 1) || (dump_opt['A'] > 2));\n\tzfs_recover = (dump_opt['A'] > 1);\n\n\targc -= optind;\n\targv += optind;\n\tif (argc < 2 && dump_opt['R'])\n\t\tusage();\n\n\tif (dump_opt['E']) {\n\t\tif (argc != 1)\n\t\t\tusage();\n\t\tzdb_embedded_block(argv[0]);\n\t\treturn (0);\n\t}\n\n\tif (argc < 1) {\n\t\tif (!dump_opt['e'] && dump_opt['C']) {\n\t\t\tdump_cachefile(spa_config_path);\n\t\t\treturn (0);\n\t\t}\n\t\tusage();\n\t}\n\n\tif (dump_opt['l'])\n\t\treturn (dump_label(argv[0]));\n\n\tif (dump_opt['X'] || dump_opt['F'])\n\t\trewind = ZPOOL_DO_REWIND |\n\t\t    (dump_opt['X'] ? ZPOOL_EXTREME_REWIND : 0);\n\n\t \n\tif (dump_opt['N'] && dump_opt['d'] == 0)\n\t\tdump_opt['d'] = dump_opt['N'];\n\n\tif (nvlist_alloc(&policy, NV_UNIQUE_NAME_TYPE, 0) != 0 ||\n\t    nvlist_add_uint64(policy, ZPOOL_LOAD_REQUEST_TXG, max_txg) != 0 ||\n\t    nvlist_add_uint32(policy, ZPOOL_LOAD_REWIND_POLICY, rewind) != 0)\n\t\tfatal(\"internal error: %s\", strerror(ENOMEM));\n\n\terror = 0;\n\ttarget = argv[0];\n\n\tif (strpbrk(target, \"/@\") != NULL) {\n\t\tsize_t targetlen;\n\n\t\ttarget_pool = strdup(target);\n\t\t*strpbrk(target_pool, \"/@\") = '\\0';\n\n\t\ttarget_is_spa = B_FALSE;\n\t\ttargetlen = strlen(target);\n\t\tif (targetlen && target[targetlen - 1] == '/')\n\t\t\ttarget[targetlen - 1] = '\\0';\n\n\t\t \n\t\tobjset_str = strchr(target, '/');\n\t\tif (objset_str && strlen(objset_str) > 1 &&\n\t\t    zdb_numeric(objset_str + 1)) {\n\t\t\tchar *endptr;\n\t\t\terrno = 0;\n\t\t\tobjset_str++;\n\t\t\tobjset_id = strtoull(objset_str, &endptr, 0);\n\t\t\t \n\t\t\tif (errno == 0 && endptr != objset_str &&\n\t\t\t    objset_id != 0) {\n\t\t\t\tif (dump_opt['N'])\n\t\t\t\t\tdataset_lookup = B_TRUE;\n\t\t\t}\n\t\t\t \n\t\t\tif (endptr == objset_str) {\n\t\t\t\tobjset_id = -1;\n\t\t\t}\n\t\t} else if (objset_str && !zdb_numeric(objset_str + 1) &&\n\t\t    dump_opt['N']) {\n\t\t\tprintf(\"Supply a numeric objset ID with -N\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\ttarget_pool = target;\n\t}\n\n\tif (dump_opt['e']) {\n\t\timportargs_t args = { 0 };\n\n\t\targs.paths = nsearch;\n\t\targs.path = searchdirs;\n\t\targs.can_be_active = B_TRUE;\n\n\t\tlibpc_handle_t lpch = {\n\t\t\t.lpc_lib_handle = NULL,\n\t\t\t.lpc_ops = &libzpool_config_ops,\n\t\t\t.lpc_printerr = B_TRUE\n\t\t};\n\t\terror = zpool_find_config(&lpch, target_pool, &cfg, &args);\n\n\t\tif (error == 0) {\n\n\t\t\tif (nvlist_add_nvlist(cfg,\n\t\t\t    ZPOOL_LOAD_POLICY, policy) != 0) {\n\t\t\t\tfatal(\"can't open '%s': %s\",\n\t\t\t\t    target, strerror(ENOMEM));\n\t\t\t}\n\n\t\t\tif (dump_opt['C'] > 1) {\n\t\t\t\t(void) printf(\"\\nConfiguration for import:\\n\");\n\t\t\t\tdump_nvlist(cfg, 8);\n\t\t\t}\n\n\t\t\t \n\t\t\terror = spa_import(target_pool, cfg, NULL,\n\t\t\t    flags | ZFS_IMPORT_SKIP_MMP);\n\t\t}\n\t}\n\n\tif (searchdirs != NULL) {\n\t\tumem_free(searchdirs, nsearch * sizeof (char *));\n\t\tsearchdirs = NULL;\n\t}\n\n\t \n\tif (dump_opt['O']) {\n\t\tif (argc != 2)\n\t\t\tusage();\n\t\tdump_opt['v'] = verbose + 3;\n\t\treturn (dump_path(argv[0], argv[1], NULL));\n\t}\n\n\tif (dump_opt['r']) {\n\t\ttarget_is_spa = B_FALSE;\n\t\tif (argc != 3)\n\t\t\tusage();\n\t\tdump_opt['v'] = verbose;\n\t\terror = dump_path(argv[0], argv[1], &object);\n\t\tif (error != 0)\n\t\t\tfatal(\"internal error: %s\", strerror(error));\n\t}\n\n\t \n\tchar *checkpoint_pool = NULL;\n\tchar *checkpoint_target = NULL;\n\tif (dump_opt['k']) {\n\t\tcheckpoint_pool = import_checkpointed_state(target, cfg,\n\t\t    &checkpoint_target);\n\n\t\tif (checkpoint_target != NULL)\n\t\t\ttarget = checkpoint_target;\n\t}\n\n\tif (cfg != NULL) {\n\t\tnvlist_free(cfg);\n\t\tcfg = NULL;\n\t}\n\n\tif (target_pool != target)\n\t\tfree(target_pool);\n\n\tif (error == 0) {\n\t\tif (dump_opt['k'] && (target_is_spa || dump_opt['R'])) {\n\t\t\tASSERT(checkpoint_pool != NULL);\n\t\t\tASSERT(checkpoint_target == NULL);\n\n\t\t\terror = spa_open(checkpoint_pool, &spa, FTAG);\n\t\t\tif (error != 0) {\n\t\t\t\tfatal(\"Tried to open pool \\\"%s\\\" but \"\n\t\t\t\t    \"spa_open() failed with error %d\\n\",\n\t\t\t\t    checkpoint_pool, error);\n\t\t\t}\n\n\t\t} else if (target_is_spa || dump_opt['R'] || dump_opt['B'] ||\n\t\t    objset_id == 0) {\n\t\t\tzdb_set_skip_mmp(target);\n\t\t\terror = spa_open_rewind(target, &spa, FTAG, policy,\n\t\t\t    NULL);\n\t\t\tif (error) {\n\t\t\t\t \n\t\t\t\tmutex_enter(&spa_namespace_lock);\n\t\t\t\tif ((spa = spa_lookup(target)) != NULL &&\n\t\t\t\t    spa->spa_log_state == SPA_LOG_MISSING) {\n\t\t\t\t\tspa->spa_log_state = SPA_LOG_CLEAR;\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t\tmutex_exit(&spa_namespace_lock);\n\n\t\t\t\tif (!error) {\n\t\t\t\t\terror = spa_open_rewind(target, &spa,\n\t\t\t\t\t    FTAG, policy, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (strpbrk(target, \"#\") != NULL) {\n\t\t\tdsl_pool_t *dp;\n\t\t\terror = dsl_pool_hold(target, FTAG, &dp);\n\t\t\tif (error != 0) {\n\t\t\t\tfatal(\"can't dump '%s': %s\", target,\n\t\t\t\t    strerror(error));\n\t\t\t}\n\t\t\terror = dump_bookmark(dp, target, B_TRUE, verbose > 1);\n\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\tif (error != 0) {\n\t\t\t\tfatal(\"can't dump '%s': %s\", target,\n\t\t\t\t    strerror(error));\n\t\t\t}\n\t\t\treturn (error);\n\t\t} else {\n\t\t\ttarget_pool = strdup(target);\n\t\t\tif (strpbrk(target, \"/@\") != NULL)\n\t\t\t\t*strpbrk(target_pool, \"/@\") = '\\0';\n\n\t\t\tzdb_set_skip_mmp(target);\n\t\t\t \n\t\t\tboolean_t retry = B_TRUE;\nretry_lookup:\n\t\t\tif (dataset_lookup == B_TRUE) {\n\t\t\t\t \n\t\t\t\terror = spa_open(target_pool, &spa, FTAG);\n\t\t\t\tif (error == 0) {\n\t\t\t\t\terror = name_from_objset_id(spa,\n\t\t\t\t\t    objset_id, dsname);\n\t\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\ttarget = dsname;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (error == 0) {\n\t\t\t\tif (objset_id > 0 && retry) {\n\t\t\t\t\tint err = dmu_objset_hold(target, FTAG,\n\t\t\t\t\t    &os);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tdataset_lookup = B_TRUE;\n\t\t\t\t\t\tretry = B_FALSE;\n\t\t\t\t\t\tgoto retry_lookup;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdmu_objset_rele(os, FTAG);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terror = open_objset(target, FTAG, &os);\n\t\t\t}\n\t\t\tif (error == 0)\n\t\t\t\tspa = dmu_objset_spa(os);\n\t\t\tfree(target_pool);\n\t\t}\n\t}\n\tnvlist_free(policy);\n\n\tif (error)\n\t\tfatal(\"can't open '%s': %s\", target, strerror(error));\n\n\t \n\tif (spa != NULL)\n\t\tspa->spa_failmode = ZIO_FAILURE_MODE_PANIC;\n\n\targv++;\n\targc--;\n\tif (dump_opt['r']) {\n\t\terror = zdb_copy_object(os, object, argv[1]);\n\t} else if (!dump_opt['R']) {\n\t\tflagbits['d'] = ZOR_FLAG_DIRECTORY;\n\t\tflagbits['f'] = ZOR_FLAG_PLAIN_FILE;\n\t\tflagbits['m'] = ZOR_FLAG_SPACE_MAP;\n\t\tflagbits['z'] = ZOR_FLAG_ZAP;\n\t\tflagbits['A'] = ZOR_FLAG_ALL_TYPES;\n\n\t\tif (argc > 0 && dump_opt['d']) {\n\t\t\tzopt_object_args = argc;\n\t\t\tzopt_object_ranges = calloc(zopt_object_args,\n\t\t\t    sizeof (zopt_object_range_t));\n\t\t\tfor (unsigned i = 0; i < zopt_object_args; i++) {\n\t\t\t\tint err;\n\t\t\t\tconst char *msg = NULL;\n\n\t\t\t\terr = parse_object_range(argv[i],\n\t\t\t\t    &zopt_object_ranges[i], &msg);\n\t\t\t\tif (err != 0)\n\t\t\t\t\tfatal(\"Bad object or range: '%s': %s\\n\",\n\t\t\t\t\t    argv[i], msg ?: \"\");\n\t\t\t}\n\t\t} else if (argc > 0 && dump_opt['m']) {\n\t\t\tzopt_metaslab_args = argc;\n\t\t\tzopt_metaslab = calloc(zopt_metaslab_args,\n\t\t\t    sizeof (uint64_t));\n\t\t\tfor (unsigned i = 0; i < zopt_metaslab_args; i++) {\n\t\t\t\terrno = 0;\n\t\t\t\tzopt_metaslab[i] = strtoull(argv[i], NULL, 0);\n\t\t\t\tif (zopt_metaslab[i] == 0 && errno != 0)\n\t\t\t\t\tfatal(\"bad number %s: %s\", argv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t}\n\t\tif (dump_opt['B']) {\n\t\t\tdump_backup(target, objset_id,\n\t\t\t    argc > 0 ? argv[0] : NULL);\n\t\t} else if (os != NULL) {\n\t\t\tdump_objset(os);\n\t\t} else if (zopt_object_args > 0 && !dump_opt['m']) {\n\t\t\tdump_objset(spa->spa_meta_objset);\n\t\t} else {\n\t\t\tdump_zpool(spa);\n\t\t}\n\t} else {\n\t\tflagbits['b'] = ZDB_FLAG_PRINT_BLKPTR;\n\t\tflagbits['c'] = ZDB_FLAG_CHECKSUM;\n\t\tflagbits['d'] = ZDB_FLAG_DECOMPRESS;\n\t\tflagbits['e'] = ZDB_FLAG_BSWAP;\n\t\tflagbits['g'] = ZDB_FLAG_GBH;\n\t\tflagbits['i'] = ZDB_FLAG_INDIRECT;\n\t\tflagbits['r'] = ZDB_FLAG_RAW;\n\t\tflagbits['v'] = ZDB_FLAG_VERBOSE;\n\n\t\tfor (int i = 0; i < argc; i++)\n\t\t\tzdb_read_block(argv[i], spa);\n\t}\n\n\tif (dump_opt['k']) {\n\t\tfree(checkpoint_pool);\n\t\tif (!target_is_spa)\n\t\t\tfree(checkpoint_target);\n\t}\n\n\tif (os != NULL) {\n\t\tclose_objset(os, FTAG);\n\t} else {\n\t\tspa_close(spa, FTAG);\n\t}\n\n\tfuid_table_destroy();\n\n\tdump_debug_buffer();\n\n\tkernel_fini();\n\n\treturn (error);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}