{
  "module_name": "arc_summary",
  "hash_id": "44e8d4aec6614aacfece3a12a6953e0f68b4358fa9621415f25200b346020132",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/arc_summary",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# Copyright (c) 2008 Ben Rockwood <benr@cuddletech.com>,\n# Copyright (c) 2010 Martin Matuska <mm@FreeBSD.org>,\n# Copyright (c) 2010-2011 Jason J. Hellenthal <jhell@DataIX.net>,\n# Copyright (c) 2017 Scot W. Stevenson <scot.stevenson@gmail.com>\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\"\"\"Print statistics on the ZFS ARC Cache and other information\n\nProvides basic information on the ARC, its efficiency, the L2ARC (if present),\nthe Data Management Unit (DMU), Virtual Devices (VDEVs), and tunables. See\nthe in-source documentation and code at\nhttps://github.com/openzfs/zfs/blob/master/module/zfs/arc.c for details.\nThe original introduction to arc_summary can be found at\nhttp://cuddletech.com/?p=454\n\"\"\"\n\nimport argparse\nimport os\nimport subprocess\nimport sys\nimport time\nimport errno\n\n# We can't use env -S portably, and we need python3 -u to handle pipes in\n# the shell abruptly closing the way we want to, so...\nimport io\nif isinstance(sys.__stderr__.buffer, io.BufferedWriter):\n    os.execv(sys.executable, [sys.executable, \"-u\"] + sys.argv)\n\nDESCRIPTION = 'Print ARC and other statistics for OpenZFS'\nINDENT = ' '*8\nLINE_LENGTH = 72\nDATE_FORMAT = '%a %b %d %H:%M:%S %Y'\nTITLE = 'ZFS Subsystem Report'\n\nSECTIONS = 'arc archits dmu l2arc spl tunables vdev zil'.split()\nSECTION_HELP = 'print info from one section ('+' '.join(SECTIONS)+')'\n\n# Tunables and SPL are handled separately because they come from\n# different sources\nSECTION_PATHS = {'arc': 'arcstats',\n                 'dmu': 'dmu_tx',\n                 'l2arc': 'arcstats',  # L2ARC stuff lives in arcstats\n                 'zfetch': 'zfetchstats',\n                 'zil': 'zil'}\n\nparser = argparse.ArgumentParser(description=DESCRIPTION)\nparser.add_argument('-a', '--alternate', action='store_true', default=False,\n                    help='use alternate formatting for tunables and SPL',\n                    dest='alt')\nparser.add_argument('-d', '--description', action='store_true', default=False,\n                    help='print descriptions with tunables and SPL',\n                    dest='desc')\nparser.add_argument('-g', '--graph', action='store_true', default=False,\n                    help='print graph on ARC use and exit', dest='graph')\nparser.add_argument('-p', '--page', type=int, dest='page',\n                    help='print page by number (DEPRECATED, use \"-s\")')\nparser.add_argument('-r', '--raw', action='store_true', default=False,\n                    help='dump all available data with minimal formatting',\n                    dest='raw')\nparser.add_argument('-s', '--section', dest='section', help=SECTION_HELP)\nARGS = parser.parse_args()\n\n\nif sys.platform.startswith('freebsd'):\n    # Requires py36-sysctl on FreeBSD\n    import sysctl\n\n    def is_value(ctl):\n        return ctl.type != sysctl.CTLTYPE_NODE\n\n    def namefmt(ctl, base='vfs.zfs.'):\n        # base is removed from the name\n        cut = len(base)\n        return ctl.name[cut:]\n\n    def load_kstats(section):\n        base = 'kstat.zfs.misc.{section}.'.format(section=section)\n        fmt = lambda kstat: '{name} : {value}'.format(name=namefmt(kstat, base),\n                                                      value=kstat.value)\n        kstats = sysctl.filter(base)\n        return [fmt(kstat) for kstat in kstats if is_value(kstat)]\n\n    def get_params(base):\n        ctls = sysctl.filter(base)\n        return {namefmt(ctl): str(ctl.value) for ctl in ctls if is_value(ctl)}\n\n    def get_tunable_params():\n        return get_params('vfs.zfs')\n\n    def get_vdev_params():\n        return get_params('vfs.zfs.vdev')\n\n    def get_version_impl(request):\n        # FreeBSD reports versions for zpl and spa instead of zfs and spl.\n        name = {'zfs': 'zpl',\n                'spl': 'spa'}[request]\n        mib = 'vfs.zfs.version.{}'.format(name)\n        version = sysctl.filter(mib)[0].value\n        return '{} version {}'.format(name, version)\n\n    def get_descriptions(_request):\n        ctls = sysctl.filter('vfs.zfs')\n        return {namefmt(ctl): ctl.description for ctl in ctls if is_value(ctl)}\n\n\nelif sys.platform.startswith('linux'):\n    KSTAT_PATH = '/proc/spl/kstat/zfs'\n    SPL_PATH = '/sys/module/spl/parameters'\n    TUNABLES_PATH = '/sys/module/zfs/parameters'\n\n    def load_kstats(section):\n        path = os.path.join(KSTAT_PATH, section)\n        with open(path) as f:\n            return list(f)[2:] # Get rid of header\n\n    def get_params(basepath):\n        \"\"\"Collect information on the Solaris Porting Layer (SPL) or the\n        tunables, depending on the PATH given. Does not check if PATH is\n        legal.\n        \"\"\"\n        result = {}\n        for name in os.listdir(basepath):\n            path = os.path.join(basepath, name)\n            with open(path) as f:\n                value = f.read()\n                result[name] = value.strip()\n        return result\n\n    def get_spl_params():\n        return get_params(SPL_PATH)\n\n    def get_tunable_params():\n        return get_params(TUNABLES_PATH)\n\n    def get_vdev_params():\n        return get_params(TUNABLES_PATH)\n\n    def get_version_impl(request):\n        # The original arc_summary called /sbin/modinfo/{spl,zfs} to get\n        # the version information. We switch to /sys/module/{spl,zfs}/version\n        # to make sure we get what is really loaded in the kernel\n        try:\n            with open(\"/sys/module/{}/version\".format(request)) as f:\n                return f.read().strip()\n        except:\n            return \"(unknown)\"\n\n    def get_descriptions(request):\n        \"\"\"Get the descriptions of the Solaris Porting Layer (SPL) or the\n        tunables, return with minimal formatting.\n        \"\"\"\n\n        if request not in ('spl', 'zfs'):\n            print('ERROR: description of \"{0}\" requested)'.format(request))\n            sys.exit(1)\n\n        descs = {}\n        target_prefix = 'parm:'\n\n        # We would prefer to do this with /sys/modules -- see the discussion at\n        # get_version() -- but there isn't a way to get the descriptions from\n        # there, so we fall back on modinfo\n        command = [\"/sbin/modinfo\", request, \"-0\"]\n\n        info = ''\n\n        try:\n\n            info = subprocess.run(command, stdout=subprocess.PIPE,\n                                  check=True, universal_newlines=True)\n            raw_output = info.stdout.split('\\0')\n\n        except subprocess.CalledProcessError:\n            print(\"Error: Descriptions not available\",\n                  \"(can't access kernel module)\")\n            sys.exit(1)\n\n        for line in raw_output:\n\n            if not line.startswith(target_prefix):\n                continue\n\n            line = line[len(target_prefix):].strip()\n            name, raw_desc = line.split(':', 1)\n            desc = raw_desc.rsplit('(', 1)[0]\n\n            if desc == '':\n                desc = '(No description found)'\n\n            descs[name.strip()] = desc.strip()\n\n        return descs\n\ndef handle_unraisableException(exc_type, exc_value=None, exc_traceback=None,\n                               err_msg=None, object=None):\n   handle_Exception(exc_type, object, exc_traceback)\n\ndef handle_Exception(ex_cls, ex, tb):\n    if ex_cls is KeyboardInterrupt:\n        sys.exit()\n\n    if ex_cls is BrokenPipeError:\n        # It turns out that while sys.exit() triggers an exception\n        # not handled message on Python 3.8+, os._exit() does not.\n        os._exit(0)\n\n    if ex_cls is OSError:\n      if ex.errno == errno.ENOTCONN:\n        sys.exit()\n\n    raise ex\n\nif hasattr(sys,'unraisablehook'): # Python 3.8+\n    sys.unraisablehook = handle_unraisableException\nsys.excepthook = handle_Exception\n\n\ndef cleanup_line(single_line):\n    \"\"\"Format a raw line of data from /proc and isolate the name value\n    part, returning a tuple with each. Currently, this gets rid of the\n    middle '4'. For example \"arc_no_grow    4    0\" returns the tuple\n    (\"arc_no_grow\", \"0\").\n    \"\"\"\n    name, _, value = single_line.split()\n\n    return name, value\n\n\ndef draw_graph(kstats_dict):\n    \"\"\"Draw a primitive graph representing the basic information on the\n    ARC -- its size and the proportion used by MFU and MRU -- and quit.\n    We use max size of the ARC to calculate how full it is. This is a\n    very rough representation.\n    \"\"\"\n\n    arc_stats = isolate_section('arcstats', kstats_dict)\n\n    GRAPH_INDENT = ' '*4\n    GRAPH_WIDTH = 60\n    arc_size = f_bytes(arc_stats['size'])\n    arc_perc = f_perc(arc_stats['size'], arc_stats['c_max'])\n    mfu_size = f_bytes(arc_stats['mfu_size'])\n    mru_size = f_bytes(arc_stats['mru_size'])\n    meta_size = f_bytes(arc_stats['arc_meta_used'])\n    dnode_limit = f_bytes(arc_stats['arc_dnode_limit'])\n    dnode_size = f_bytes(arc_stats['dnode_size'])\n\n    info_form = ('ARC: {0} ({1})  MFU: {2}  MRU: {3}  META: {4} '\n                 'DNODE {5} ({6})')\n    info_line = info_form.format(arc_size, arc_perc, mfu_size, mru_size,\n                                 meta_size, dnode_size, dnode_limit)\n    info_spc = ' '*int((GRAPH_WIDTH-len(info_line))/2)\n    info_line = GRAPH_INDENT+info_spc+info_line\n\n    graph_line = GRAPH_INDENT+'+'+('-'*(GRAPH_WIDTH-2))+'+'\n\n    mfu_perc = float(int(arc_stats['mfu_size'])/int(arc_stats['c_max']))\n    mru_perc = float(int(arc_stats['mru_size'])/int(arc_stats['c_max']))\n    arc_perc = float(int(arc_stats['size'])/int(arc_stats['c_max']))\n    total_ticks = float(arc_perc)*GRAPH_WIDTH\n    mfu_ticks = mfu_perc*GRAPH_WIDTH\n    mru_ticks = mru_perc*GRAPH_WIDTH\n    other_ticks = total_ticks-(mfu_ticks+mru_ticks)\n\n    core_form = 'F'*int(mfu_ticks)+'R'*int(mru_ticks)+'O'*int(other_ticks)\n    core_spc = ' '*(GRAPH_WIDTH-(2+len(core_form)))\n    core_line = GRAPH_INDENT+'|'+core_form+core_spc+'|'\n\n    for line in ('', info_line, graph_line, core_line, graph_line, ''):\n        print(line)\n\n\ndef f_bytes(byte_string):\n    \"\"\"Return human-readable representation of a byte value in\n    powers of 2 (eg \"KiB\" for \"kibibytes\", etc) to two decimal\n    points. Values smaller than one KiB are returned without\n    decimal points. Note \"bytes\" is a reserved keyword.\n    \"\"\"\n\n    prefixes = ([2**80, \"YiB\"],   # yobibytes (yotta)\n                [2**70, \"ZiB\"],   # zebibytes (zetta)\n                [2**60, \"EiB\"],   # exbibytes (exa)\n                [2**50, \"PiB\"],   # pebibytes (peta)\n                [2**40, \"TiB\"],   # tebibytes (tera)\n                [2**30, \"GiB\"],   # gibibytes (giga)\n                [2**20, \"MiB\"],   # mebibytes (mega)\n                [2**10, \"KiB\"])   # kibibytes (kilo)\n\n    bites = int(byte_string)\n\n    if bites >= 2**10:\n        for limit, unit in prefixes:\n\n            if bites >= limit:\n                value = bites / limit\n                break\n\n        result = '{0:.1f} {1}'.format(value, unit)\n    else:\n        result = '{0} Bytes'.format(bites)\n\n    return result\n\n\ndef f_hits(hits_string):\n    \"\"\"Create a human-readable representation of the number of hits.\n    The single-letter symbols used are SI to avoid the confusion caused\n    by the different \"short scale\" and \"long scale\" representations in\n    English, which use the same words for different values. See\n    https://en.wikipedia.org/wiki/Names_of_large_numbers and:\n    https://physics.nist.gov/cuu/Units/prefixes.html\n    \"\"\"\n\n    numbers = ([10**24, 'Y'],  # yotta (septillion)\n               [10**21, 'Z'],  # zetta (sextillion)\n               [10**18, 'E'],  # exa   (quintrillion)\n               [10**15, 'P'],  # peta  (quadrillion)\n               [10**12, 'T'],  # tera  (trillion)\n               [10**9, 'G'],   # giga  (billion)\n               [10**6, 'M'],   # mega  (million)\n               [10**3, 'k'])   # kilo  (thousand)\n\n    hits = int(hits_string)\n\n    if hits >= 1000:\n        for limit, symbol in numbers:\n\n            if hits >= limit:\n                value = hits/limit\n                break\n\n        result = \"%0.1f%s\" % (value, symbol)\n    else:\n        result = \"%d\" % hits\n\n    return result\n\n\ndef f_perc(value1, value2):\n    \"\"\"Calculate percentage and return in human-readable form. If\n    rounding produces the result '0.0' though the first number is\n    not zero, include a 'less-than' symbol to avoid confusion.\n    Division by zero is handled by returning 'n/a'; no error\n    is called.\n    \"\"\"\n\n    v1 = float(value1)\n    v2 = float(value2)\n\n    try:\n        perc = 100 * v1/v2\n    except ZeroDivisionError:\n        result = 'n/a'\n    else:\n        result = '{0:0.1f} %'.format(perc)\n\n    if result == '0.0 %' and v1 > 0:\n        result = '< 0.1 %'\n\n    return result\n\n\ndef format_raw_line(name, value):\n    \"\"\"For the --raw option for the tunable and SPL outputs, decide on the\n    correct formatting based on the --alternate flag.\n    \"\"\"\n\n    if ARGS.alt:\n        result = '{0}{1}={2}'.format(INDENT, name, value)\n    else:\n        # Right-align the value within the line length if it fits,\n        # otherwise just separate it from the name by a single space.\n        fit = LINE_LENGTH - len(INDENT) - len(name)\n        overflow = len(value) + 1\n        w = max(fit, overflow)\n        result = '{0}{1}{2:>{w}}'.format(INDENT, name, value, w=w)\n\n    return result\n\n\ndef get_kstats():\n    \"\"\"Collect information on the ZFS subsystem. The step does not perform any\n    further processing, giving us the option to only work on what is actually\n    needed. The name \"kstat\" is a holdover from the Solaris utility of the same\n    name.\n    \"\"\"\n\n    result = {}\n\n    for section in SECTION_PATHS.values():\n        if section not in result:\n            result[section] = load_kstats(section)\n\n    return result\n\n\ndef get_version(request):\n    \"\"\"Get the version number of ZFS or SPL on this machine for header.\n    Returns an error string, but does not raise an error, if we can't\n    get the ZFS/SPL version.\n    \"\"\"\n\n    if request not in ('spl', 'zfs'):\n        error_msg = '(ERROR: \"{0}\" requested)'.format(request)\n        return error_msg\n\n    return get_version_impl(request)\n\n\ndef print_header():\n    \"\"\"Print the initial heading with date and time as well as info on the\n    kernel and ZFS versions. This is not called for the graph.\n    \"\"\"\n\n    # datetime is now recommended over time but we keep the exact formatting\n    # from the older version of arc_summary in case there are scripts\n    # that expect it in this way\n    daydate = time.strftime(DATE_FORMAT)\n    spc_date = LINE_LENGTH-len(daydate)\n    sys_version = os.uname()\n\n    sys_msg = sys_version.sysname+' '+sys_version.release\n    zfs = get_version('zfs')\n    spc_zfs = LINE_LENGTH-len(zfs)\n\n    machine_msg = 'Machine: '+sys_version.nodename+' ('+sys_version.machine+')'\n    spl = get_version('spl')\n    spc_spl = LINE_LENGTH-len(spl)\n\n    print('\\n'+('-'*LINE_LENGTH))\n    print('{0:<{spc}}{1}'.format(TITLE, daydate, spc=spc_date))\n    print('{0:<{spc}}{1}'.format(sys_msg, zfs, spc=spc_zfs))\n    print('{0:<{spc}}{1}\\n'.format(machine_msg, spl, spc=spc_spl))\n\n\ndef print_raw(kstats_dict):\n    \"\"\"Print all available data from the system in a minimally sorted format.\n    This can be used as a source to be piped through 'grep'.\n    \"\"\"\n\n    sections = sorted(kstats_dict.keys())\n\n    for section in sections:\n\n        print('\\n{0}:'.format(section.upper()))\n        lines = sorted(kstats_dict[section])\n\n        for line in lines:\n            name, value = cleanup_line(line)\n            print(format_raw_line(name, value))\n\n    # Tunables and SPL must be handled separately because they come from a\n    # different source and have descriptions the user might request\n    print()\n    section_spl()\n    section_tunables()\n\n\ndef isolate_section(section_name, kstats_dict):\n    \"\"\"From the complete information on all sections, retrieve only those\n    for one section.\n    \"\"\"\n\n    try:\n        section_data = kstats_dict[section_name]\n    except KeyError:\n        print('ERROR: Data on {0} not available'.format(section_data))\n        sys.exit(1)\n\n    section_dict = dict(cleanup_line(l) for l in section_data)\n\n    return section_dict\n\n\n# Formatted output helper functions\n\n\ndef prt_1(text, value):\n    \"\"\"Print text and one value, no indent\"\"\"\n    spc = ' '*(LINE_LENGTH-(len(text)+len(value)))\n    print('{0}{spc}{1}'.format(text, value, spc=spc))\n\n\ndef prt_i1(text, value):\n    \"\"\"Print text and one value, with indent\"\"\"\n    spc = ' '*(LINE_LENGTH-(len(INDENT)+len(text)+len(value)))\n    print(INDENT+'{0}{spc}{1}'.format(text, value, spc=spc))\n\n\ndef prt_2(text, value1, value2):\n    \"\"\"Print text and two values, no indent\"\"\"\n    values = '{0:>9}  {1:>9}'.format(value1, value2)\n    spc = ' '*(LINE_LENGTH-(len(text)+len(values)+2))\n    print('{0}{spc}  {1}'.format(text, values, spc=spc))\n\n\ndef prt_i2(text, value1, value2):\n    \"\"\"Print text and two values, with indent\"\"\"\n    values = '{0:>9}  {1:>9}'.format(value1, value2)\n    spc = ' '*(LINE_LENGTH-(len(INDENT)+len(text)+len(values)+2))\n    print(INDENT+'{0}{spc}  {1}'.format(text, values, spc=spc))\n\n\n# The section output concentrates on important parameters instead of\n# being exhaustive (that is what the --raw parameter is for)\n\n\ndef section_arc(kstats_dict):\n    \"\"\"Give basic information on the ARC, MRU and MFU. This is the first\n    and most used section.\n    \"\"\"\n\n    arc_stats = isolate_section('arcstats', kstats_dict)\n\n    throttle = arc_stats['memory_throttle_count']\n\n    if throttle == '0':\n        health = 'HEALTHY'\n    else:\n        health = 'THROTTLED'\n\n    prt_1('ARC status:', health)\n    prt_i1('Memory throttle count:', throttle)\n    print()\n\n    arc_size = arc_stats['size']\n    arc_target_size = arc_stats['c']\n    arc_max = arc_stats['c_max']\n    arc_min = arc_stats['c_min']\n    meta = arc_stats['meta']\n    pd = arc_stats['pd']\n    pm = arc_stats['pm']\n    anon_data = arc_stats['anon_data']\n    anon_metadata = arc_stats['anon_metadata']\n    mfu_data = arc_stats['mfu_data']\n    mfu_metadata = arc_stats['mfu_metadata']\n    mru_data = arc_stats['mru_data']\n    mru_metadata = arc_stats['mru_metadata']\n    mfug_data = arc_stats['mfu_ghost_data']\n    mfug_metadata = arc_stats['mfu_ghost_metadata']\n    mrug_data = arc_stats['mru_ghost_data']\n    mrug_metadata = arc_stats['mru_ghost_metadata']\n    unc_data = arc_stats['uncached_data']\n    unc_metadata = arc_stats['uncached_metadata']\n    bonus_size = arc_stats['bonus_size']\n    dnode_limit = arc_stats['arc_dnode_limit']\n    dnode_size = arc_stats['dnode_size']\n    dbuf_size = arc_stats['dbuf_size']\n    hdr_size = arc_stats['hdr_size']\n    l2_hdr_size = arc_stats['l2_hdr_size']\n    abd_chunk_waste_size = arc_stats['abd_chunk_waste_size']\n    target_size_ratio = '{0}:1'.format(int(arc_max) // int(arc_min))\n\n    prt_2('ARC size (current):',\n          f_perc(arc_size, arc_max), f_bytes(arc_size))\n    prt_i2('Target size (adaptive):',\n           f_perc(arc_target_size, arc_max), f_bytes(arc_target_size))\n    prt_i2('Min size (hard limit):',\n           f_perc(arc_min, arc_max), f_bytes(arc_min))\n    prt_i2('Max size (high water):',\n           target_size_ratio, f_bytes(arc_max))\n    caches_size = int(anon_data)+int(anon_metadata)+\\\n        int(mfu_data)+int(mfu_metadata)+int(mru_data)+int(mru_metadata)+\\\n        int(unc_data)+int(unc_metadata)\n    prt_i2('Anonymous data size:',\n           f_perc(anon_data, caches_size), f_bytes(anon_data))\n    prt_i2('Anonymous metadata size:',\n           f_perc(anon_metadata, caches_size), f_bytes(anon_metadata))\n    s = 4294967296\n    v = (s-int(pd))*(s-int(meta))/s\n    prt_i2('MFU data target:', f_perc(v, s),\n        f_bytes(v / 65536 * caches_size / 65536))\n    prt_i2('MFU data size:',\n           f_perc(mfu_data, caches_size), f_bytes(mfu_data))\n    prt_i1('MFU ghost data size:', f_bytes(mfug_data))\n    v = (s-int(pm))*int(meta)/s\n    prt_i2('MFU metadata target:', f_perc(v, s),\n        f_bytes(v / 65536 * caches_size / 65536))\n    prt_i2('MFU metadata size:',\n           f_perc(mfu_metadata, caches_size), f_bytes(mfu_metadata))\n    prt_i1('MFU ghost metadata size:', f_bytes(mfug_metadata))\n    v = int(pd)*(s-int(meta))/s\n    prt_i2('MRU data target:', f_perc(v, s),\n        f_bytes(v / 65536 * caches_size / 65536))\n    prt_i2('MRU data size:',\n           f_perc(mru_data, caches_size), f_bytes(mru_data))\n    prt_i1('MRU ghost data size:', f_bytes(mrug_data))\n    v = int(pm)*int(meta)/s\n    prt_i2('MRU metadata target:', f_perc(v, s),\n        f_bytes(v / 65536 * caches_size / 65536))\n    prt_i2('MRU metadata size:',\n           f_perc(mru_metadata, caches_size), f_bytes(mru_metadata))\n    prt_i1('MRU ghost metadata size:', f_bytes(mrug_metadata))\n    prt_i2('Uncached data size:',\n           f_perc(unc_data, caches_size), f_bytes(unc_data))\n    prt_i2('Uncached metadata size:',\n           f_perc(unc_metadata, caches_size), f_bytes(unc_metadata))\n    prt_i2('Bonus size:',\n           f_perc(bonus_size, arc_size), f_bytes(bonus_size))\n    prt_i2('Dnode cache target:',\n           f_perc(dnode_limit, arc_max), f_bytes(dnode_limit))\n    prt_i2('Dnode cache size:',\n           f_perc(dnode_size, dnode_limit), f_bytes(dnode_size))\n    prt_i2('Dbuf size:',\n           f_perc(dbuf_size, arc_size), f_bytes(dbuf_size))\n    prt_i2('Header size:',\n           f_perc(hdr_size, arc_size), f_bytes(hdr_size))\n    prt_i2('L2 header size:',\n           f_perc(l2_hdr_size, arc_size), f_bytes(l2_hdr_size))\n    prt_i2('ABD chunk waste size:',\n           f_perc(abd_chunk_waste_size, arc_size), f_bytes(abd_chunk_waste_size))\n    print()\n\n    print('ARC hash breakdown:')\n    prt_i1('Elements max:', f_hits(arc_stats['hash_elements_max']))\n    prt_i2('Elements current:',\n           f_perc(arc_stats['hash_elements'], arc_stats['hash_elements_max']),\n           f_hits(arc_stats['hash_elements']))\n    prt_i1('Collisions:', f_hits(arc_stats['hash_collisions']))\n\n    prt_i1('Chain max:', f_hits(arc_stats['hash_chain_max']))\n    prt_i1('Chains:', f_hits(arc_stats['hash_chains']))\n    print()\n\n    print('ARC misc:')\n    prt_i1('Deleted:', f_hits(arc_stats['deleted']))\n    prt_i1('Mutex misses:', f_hits(arc_stats['mutex_miss']))\n    prt_i1('Eviction skips:', f_hits(arc_stats['evict_skip']))\n    prt_i1('Eviction skips due to L2 writes:',\n           f_hits(arc_stats['evict_l2_skip']))\n    prt_i1('L2 cached evictions:', f_bytes(arc_stats['evict_l2_cached']))\n    prt_i1('L2 eligible evictions:', f_bytes(arc_stats['evict_l2_eligible']))\n    prt_i2('L2 eligible MFU evictions:',\n           f_perc(arc_stats['evict_l2_eligible_mfu'],\n           arc_stats['evict_l2_eligible']),\n           f_bytes(arc_stats['evict_l2_eligible_mfu']))\n    prt_i2('L2 eligible MRU evictions:',\n           f_perc(arc_stats['evict_l2_eligible_mru'],\n           arc_stats['evict_l2_eligible']),\n           f_bytes(arc_stats['evict_l2_eligible_mru']))\n    prt_i1('L2 ineligible evictions:',\n           f_bytes(arc_stats['evict_l2_ineligible']))\n    print()\n\n\ndef section_archits(kstats_dict):\n    \"\"\"Print information on how the caches are accessed (\"arc hits\").\n    \"\"\"\n\n    arc_stats = isolate_section('arcstats', kstats_dict)\n    all_accesses = int(arc_stats['hits'])+int(arc_stats['iohits'])+\\\n        int(arc_stats['misses'])\n\n    prt_1('ARC total accesses:', f_hits(all_accesses))\n    ta_todo = (('Total hits:', arc_stats['hits']),\n               ('Total I/O hits:', arc_stats['iohits']),\n               ('Total misses:', arc_stats['misses']))\n    for title, value in ta_todo:\n        prt_i2(title, f_perc(value, all_accesses), f_hits(value))\n    print()\n\n    dd_total = int(arc_stats['demand_data_hits']) +\\\n        int(arc_stats['demand_data_iohits']) +\\\n        int(arc_stats['demand_data_misses'])\n    prt_2('ARC demand data accesses:', f_perc(dd_total, all_accesses),\n         f_hits(dd_total))\n    dd_todo = (('Demand data hits:', arc_stats['demand_data_hits']),\n               ('Demand data I/O hits:', arc_stats['demand_data_iohits']),\n               ('Demand data misses:', arc_stats['demand_data_misses']))\n    for title, value in dd_todo:\n        prt_i2(title, f_perc(value, dd_total), f_hits(value))\n    print()\n\n    dm_total = int(arc_stats['demand_metadata_hits']) +\\\n        int(arc_stats['demand_metadata_iohits']) +\\\n        int(arc_stats['demand_metadata_misses'])\n    prt_2('ARC demand metadata accesses:', f_perc(dm_total, all_accesses),\n          f_hits(dm_total))\n    dm_todo = (('Demand metadata hits:', arc_stats['demand_metadata_hits']),\n               ('Demand metadata I/O hits:',\n                arc_stats['demand_metadata_iohits']),\n               ('Demand metadata misses:', arc_stats['demand_metadata_misses']))\n    for title, value in dm_todo:\n        prt_i2(title, f_perc(value, dm_total), f_hits(value))\n    print()\n\n    pd_total = int(arc_stats['prefetch_data_hits']) +\\\n        int(arc_stats['prefetch_data_iohits']) +\\\n        int(arc_stats['prefetch_data_misses'])\n    prt_2('ARC prefetch data accesses:', f_perc(pd_total, all_accesses),\n          f_hits(pd_total))\n    pd_todo = (('Prefetch data hits:', arc_stats['prefetch_data_hits']),\n               ('Prefetch data I/O hits:', arc_stats['prefetch_data_iohits']),\n               ('Prefetch data misses:', arc_stats['prefetch_data_misses']))\n    for title, value in pd_todo:\n        prt_i2(title, f_perc(value, pd_total), f_hits(value))\n    print()\n\n    pm_total = int(arc_stats['prefetch_metadata_hits']) +\\\n        int(arc_stats['prefetch_metadata_iohits']) +\\\n        int(arc_stats['prefetch_metadata_misses'])\n    prt_2('ARC prefetch metadata accesses:', f_perc(pm_total, all_accesses),\n          f_hits(pm_total))\n    pm_todo = (('Prefetch metadata hits:',\n                arc_stats['prefetch_metadata_hits']),\n               ('Prefetch metadata I/O hits:',\n                arc_stats['prefetch_metadata_iohits']),\n               ('Prefetch metadata misses:',\n                arc_stats['prefetch_metadata_misses']))\n    for title, value in pm_todo:\n        prt_i2(title, f_perc(value, pm_total), f_hits(value))\n    print()\n\n    all_prefetches = int(arc_stats['predictive_prefetch'])+\\\n        int(arc_stats['prescient_prefetch'])\n    prt_2('ARC predictive prefetches:',\n           f_perc(arc_stats['predictive_prefetch'], all_prefetches),\n           f_hits(arc_stats['predictive_prefetch']))\n    prt_i2('Demand hits after predictive:',\n           f_perc(arc_stats['demand_hit_predictive_prefetch'],\n                  arc_stats['predictive_prefetch']),\n           f_hits(arc_stats['demand_hit_predictive_prefetch']))\n    prt_i2('Demand I/O hits after predictive:',\n           f_perc(arc_stats['demand_iohit_predictive_prefetch'],\n                  arc_stats['predictive_prefetch']),\n           f_hits(arc_stats['demand_iohit_predictive_prefetch']))\n    never = int(arc_stats['predictive_prefetch']) -\\\n        int(arc_stats['demand_hit_predictive_prefetch']) -\\\n        int(arc_stats['demand_iohit_predictive_prefetch'])\n    prt_i2('Never demanded after predictive:',\n           f_perc(never, arc_stats['predictive_prefetch']),\n           f_hits(never))\n    print()\n\n    prt_2('ARC prescient prefetches:',\n           f_perc(arc_stats['prescient_prefetch'], all_prefetches),\n           f_hits(arc_stats['prescient_prefetch']))\n    prt_i2('Demand hits after prescient:',\n           f_perc(arc_stats['demand_hit_prescient_prefetch'],\n                  arc_stats['prescient_prefetch']),\n           f_hits(arc_stats['demand_hit_prescient_prefetch']))\n    prt_i2('Demand I/O hits after prescient:',\n           f_perc(arc_stats['demand_iohit_prescient_prefetch'],\n                  arc_stats['prescient_prefetch']),\n           f_hits(arc_stats['demand_iohit_prescient_prefetch']))\n    never = int(arc_stats['prescient_prefetch'])-\\\n        int(arc_stats['demand_hit_prescient_prefetch'])-\\\n        int(arc_stats['demand_iohit_prescient_prefetch'])\n    prt_i2('Never demanded after prescient:',\n           f_perc(never, arc_stats['prescient_prefetch']),\n           f_hits(never))\n    print()\n\n    print('ARC states hits of all accesses:')\n    cl_todo = (('Most frequently used (MFU):', arc_stats['mfu_hits']),\n               ('Most recently used (MRU):', arc_stats['mru_hits']),\n               ('Most frequently used (MFU) ghost:',\n                arc_stats['mfu_ghost_hits']),\n               ('Most recently used (MRU) ghost:',\n                arc_stats['mru_ghost_hits']),\n               ('Uncached:', arc_stats['uncached_hits']))\n    for title, value in cl_todo:\n        prt_i2(title, f_perc(value, all_accesses), f_hits(value))\n    print()\n\n\ndef section_dmu(kstats_dict):\n    \"\"\"Collect information on the DMU\"\"\"\n\n    zfetch_stats = isolate_section('zfetchstats', kstats_dict)\n\n    zfetch_access_total = int(zfetch_stats['hits'])+int(zfetch_stats['misses'])\n\n    prt_1('DMU predictive prefetcher calls:', f_hits(zfetch_access_total))\n    prt_i2('Stream hits:',\n           f_perc(zfetch_stats['hits'], zfetch_access_total),\n           f_hits(zfetch_stats['hits']))\n    prt_i2('Stream misses:',\n           f_perc(zfetch_stats['misses'], zfetch_access_total),\n           f_hits(zfetch_stats['misses']))\n    prt_i2('Streams limit reached:',\n           f_perc(zfetch_stats['max_streams'], zfetch_stats['misses']),\n           f_hits(zfetch_stats['max_streams']))\n    prt_i1('Prefetches issued', f_hits(zfetch_stats['io_issued']))\n    print()\n\n\ndef section_l2arc(kstats_dict):\n    \"\"\"Collect information on L2ARC device if present. If not, tell user\n    that we're skipping the section.\n    \"\"\"\n\n    # The L2ARC statistics live in the same section as the normal ARC stuff\n    arc_stats = isolate_section('arcstats', kstats_dict)\n\n    if arc_stats['l2_size'] == '0':\n        print('L2ARC not detected, skipping section\\n')\n        return\n\n    l2_errors = int(arc_stats['l2_writes_error']) +\\\n        int(arc_stats['l2_cksum_bad']) +\\\n        int(arc_stats['l2_io_error'])\n\n    l2_access_total = int(arc_stats['l2_hits'])+int(arc_stats['l2_misses'])\n    health = 'HEALTHY'\n\n    if l2_errors > 0:\n        health = 'DEGRADED'\n\n    prt_1('L2ARC status:', health)\n\n    l2_todo = (('Low memory aborts:', 'l2_abort_lowmem'),\n               ('Free on write:', 'l2_free_on_write'),\n               ('R/W clashes:', 'l2_rw_clash'),\n               ('Bad checksums:', 'l2_cksum_bad'),\n               ('Read errors:', 'l2_io_error'),\n               ('Write errors:', 'l2_writes_error'))\n\n    for title, value in l2_todo:\n        prt_i1(title, f_hits(arc_stats[value]))\n\n    print()\n    prt_1('L2ARC size (adaptive):', f_bytes(arc_stats['l2_size']))\n    prt_i2('Compressed:', f_perc(arc_stats['l2_asize'], arc_stats['l2_size']),\n           f_bytes(arc_stats['l2_asize']))\n    prt_i2('Header size:',\n           f_perc(arc_stats['l2_hdr_size'], arc_stats['l2_size']),\n           f_bytes(arc_stats['l2_hdr_size']))\n    prt_i2('MFU allocated size:',\n           f_perc(arc_stats['l2_mfu_asize'], arc_stats['l2_asize']),\n           f_bytes(arc_stats['l2_mfu_asize']))\n    prt_i2('MRU allocated size:',\n           f_perc(arc_stats['l2_mru_asize'], arc_stats['l2_asize']),\n           f_bytes(arc_stats['l2_mru_asize']))\n    prt_i2('Prefetch allocated size:',\n           f_perc(arc_stats['l2_prefetch_asize'], arc_stats['l2_asize']),\n           f_bytes(arc_stats['l2_prefetch_asize']))\n    prt_i2('Data (buffer content) allocated size:',\n           f_perc(arc_stats['l2_bufc_data_asize'], arc_stats['l2_asize']),\n           f_bytes(arc_stats['l2_bufc_data_asize']))\n    prt_i2('Metadata (buffer content) allocated size:',\n           f_perc(arc_stats['l2_bufc_metadata_asize'], arc_stats['l2_asize']),\n           f_bytes(arc_stats['l2_bufc_metadata_asize']))\n\n    print()\n    prt_1('L2ARC breakdown:', f_hits(l2_access_total))\n    prt_i2('Hit ratio:',\n           f_perc(arc_stats['l2_hits'], l2_access_total),\n           f_hits(arc_stats['l2_hits']))\n    prt_i2('Miss ratio:',\n           f_perc(arc_stats['l2_misses'], l2_access_total),\n           f_hits(arc_stats['l2_misses']))\n\n    print()\n    print('L2ARC I/O:')\n    prt_i2('Reads:',\n           f_bytes(arc_stats['l2_read_bytes']),\n           f_hits(arc_stats['l2_hits']))\n    prt_i2('Writes:',\n           f_bytes(arc_stats['l2_write_bytes']),\n           f_hits(arc_stats['l2_writes_sent']))\n\n    print()\n    print('L2ARC evicts:')\n    prt_i1('L1 cached:', f_hits(arc_stats['l2_evict_l1cached']))\n    prt_i1('While reading:', f_hits(arc_stats['l2_evict_reading']))\n    print()\n\n\ndef section_spl(*_):\n    \"\"\"Print the SPL parameters, if requested with alternative format\n    and/or descriptions. This does not use kstats.\n    \"\"\"\n\n    if sys.platform.startswith('freebsd'):\n        # No SPL support in FreeBSD\n        return\n\n    spls = get_spl_params()\n    keylist = sorted(spls.keys())\n    print('Solaris Porting Layer (SPL):')\n\n    if ARGS.desc:\n        descriptions = get_descriptions('spl')\n\n    for key in keylist:\n        value = spls[key]\n\n        if ARGS.desc:\n            try:\n                print(INDENT+'#', descriptions[key])\n            except KeyError:\n                print(INDENT+'# (No description found)')  # paranoid\n\n        print(format_raw_line(key, value))\n\n    print()\n\n\ndef section_tunables(*_):\n    \"\"\"Print the tunables, if requested with alternative format and/or\n    descriptions. This does not use kstasts.\n    \"\"\"\n\n    tunables = get_tunable_params()\n    keylist = sorted(tunables.keys())\n    print('Tunables:')\n\n    if ARGS.desc:\n        descriptions = get_descriptions('zfs')\n\n    for key in keylist:\n        value = tunables[key]\n\n        if ARGS.desc:\n            try:\n                print(INDENT+'#', descriptions[key])\n            except KeyError:\n                print(INDENT+'# (No description found)')  # paranoid\n\n        print(format_raw_line(key, value))\n\n    print()\n\n\ndef section_zil(kstats_dict):\n    \"\"\"Collect information on the ZFS Intent Log. Some of the information\n    taken from https://github.com/openzfs/zfs/blob/master/include/sys/zil.h\n    \"\"\"\n\n    zil_stats = isolate_section('zil', kstats_dict)\n\n    prt_1('ZIL committed transactions:',\n          f_hits(zil_stats['zil_itx_count']))\n    prt_i1('Commit requests:', f_hits(zil_stats['zil_commit_count']))\n    prt_i1('Flushes to stable storage:',\n           f_hits(zil_stats['zil_commit_writer_count']))\n    prt_i2('Transactions to SLOG storage pool:',\n           f_bytes(zil_stats['zil_itx_metaslab_slog_bytes']),\n           f_hits(zil_stats['zil_itx_metaslab_slog_count']))\n    prt_i2('Transactions to non-SLOG storage pool:',\n           f_bytes(zil_stats['zil_itx_metaslab_normal_bytes']),\n           f_hits(zil_stats['zil_itx_metaslab_normal_count']))\n    print()\n\n\nsection_calls = {'arc': section_arc,\n                 'archits': section_archits,\n                 'dmu': section_dmu,\n                 'l2arc': section_l2arc,\n                 'spl': section_spl,\n                 'tunables': section_tunables,\n                 'zil': section_zil}\n\n\ndef main():\n    \"\"\"Run program. The options to draw a graph and to print all data raw are\n    treated separately because they come with their own call.\n    \"\"\"\n\n    kstats = get_kstats()\n\n    if ARGS.graph:\n        draw_graph(kstats)\n        sys.exit(0)\n\n    print_header()\n\n    if ARGS.raw:\n        print_raw(kstats)\n\n    elif ARGS.section:\n\n        try:\n            section_calls[ARGS.section](kstats)\n        except KeyError:\n            print('Error: Section \"{0}\" unknown'.format(ARGS.section))\n            sys.exit(1)\n\n    elif ARGS.page:\n        print('WARNING: Pages are deprecated, please use \"--section\"\\n')\n\n        pages_to_calls = {1: 'arc',\n                          2: 'archits',\n                          3: 'l2arc',\n                          4: 'dmu',\n                          5: 'vdev',\n                          6: 'tunables'}\n\n        try:\n            call = pages_to_calls[ARGS.page]\n        except KeyError:\n            print('Error: Page \"{0}\" not supported'.format(ARGS.page))\n            sys.exit(1)\n        else:\n            section_calls[call](kstats)\n\n    else:\n        # If no parameters were given, we print all sections. We might want to\n        # change the sequence by hand\n        calls = sorted(section_calls.keys())\n\n        for section in calls:\n            section_calls[section](kstats)\n\n    sys.exit(0)\n\n\nif __name__ == '__main__':\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}