{
  "module_name": "zilstat.in",
  "hash_id": "ef200f291ee2ecbb8bd37d0ec21a38f3ffc5acb5d249fde73386a25bc2801831",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zilstat.in",
  "human_readable_source": "#!/usr/bin/env @PYTHON_SHEBANG@\n#\n# Print out statistics for all zil stats. This information is\n# available through the zil kstat.\n#\n# CDDL HEADER START\n#\n# The contents of this file are subject to the terms of the\n# Common Development and Distribution License, Version 1.0 only\n# (the \"License\").  You may not use this file except in compliance\n# with the License.\n#\n# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n# or https://opensource.org/licenses/CDDL-1.0.\n# See the License for the specific language governing permissions\n# and limitations under the License.\n#\n# When distributing Covered Code, include this CDDL HEADER in each\n# file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n# If applicable, add the following below this CDDL HEADER, with the\n# fields enclosed by brackets \"[]\" replaced with your own identifying\n# information: Portions Copyright [yyyy] [name of copyright owner]\n#\n# This script must remain compatible with Python 3.6+.\n#\n\nimport sys\nimport subprocess\nimport time\nimport copy\nimport os\nimport re\nimport signal\nfrom collections import defaultdict\nimport argparse\nfrom argparse import RawTextHelpFormatter\n\ncols = {\n\t# hdr:       [size,      scale,      kstat name]\n\t\"time\":      [8,         -1,         \"time\"],\n\t\"pool\":      [12,        -1,         \"pool\"],\n\t\"ds\":        [12,        -1,         \"dataset_name\"],\n\t\"obj\":       [12,        -1,         \"objset\"],\n\t\"cc\":        [5,         1000,       \"zil_commit_count\"],\n\t\"cwc\":       [5,         1000,       \"zil_commit_writer_count\"],\n\t\"ic\":        [5,         1000,       \"zil_itx_count\"],\n\t\"iic\":       [5,         1000,       \"zil_itx_indirect_count\"],\n\t\"iib\":       [5,         1024,       \"zil_itx_indirect_bytes\"],\n\t\"icc\":       [5,         1000,       \"zil_itx_copied_count\"],\n\t\"icb\":       [5,         1024,       \"zil_itx_copied_bytes\"],\n\t\"inc\":       [5,         1000,       \"zil_itx_needcopy_count\"],\n\t\"inb\":       [5,         1024,       \"zil_itx_needcopy_bytes\"],\n\t\"idc\":       [5,         1000,       \"icc+inc\"],\n\t\"idb\":       [5,         1024,       \"icb+inb\"],\n\t\"iwc\":       [5,         1000,       \"iic+idc\"],\n\t\"iwb\":       [5,         1024,       \"iib+idb\"],\n\t\"imnc\":      [6,         1000,       \"zil_itx_metaslab_normal_count\"],\n\t\"imnb\":      [6,         1024,       \"zil_itx_metaslab_normal_bytes\"],\n\t\"imnw\":      [6,         1024,       \"zil_itx_metaslab_normal_write\"],\n\t\"imna\":      [6,         1024,       \"zil_itx_metaslab_normal_alloc\"],\n\t\"imsc\":      [6,         1000,       \"zil_itx_metaslab_slog_count\"],\n\t\"imsb\":      [6,         1024,       \"zil_itx_metaslab_slog_bytes\"],\n\t\"imsw\":      [6,         1024,       \"zil_itx_metaslab_slog_write\"],\n\t\"imsa\":      [6,         1024,       \"zil_itx_metaslab_slog_alloc\"],\n\t\"imc\":       [5,         1000,       \"imnc+imsc\"],\n\t\"imb\":       [5,         1024,       \"imnb+imsb\"],\n\t\"imw\":       [5,         1024,       \"imnw+imsw\"],\n\t\"ima\":       [5,         1024,       \"imna+imsa\"],\n\t\"se%\":       [3,         100,        \"imb/ima\"],\n\t\"sen%\":      [4,         100,        \"imnb/imna\"],\n\t\"ses%\":      [4,         100,        \"imsb/imsa\"],\n\t\"te%\":       [3,         100,        \"imb/imw\"],\n\t\"ten%\":      [4,         100,        \"imnb/imnw\"],\n\t\"tes%\":      [4,         100,        \"imsb/imsw\"],\n}\n\nhdr = [\"time\", \"ds\", \"cc\", \"ic\", \"idc\", \"idb\", \"iic\", \"iib\",\n\t\"imnc\", \"imnw\", \"imsc\", \"imsw\"]\n\nghdr = [\"time\", \"cc\", \"ic\", \"idc\", \"idb\", \"iic\", \"iib\",\n\t\"imnc\", \"imnw\", \"imsc\", \"imsw\"]\n\ncmd = (\"Usage: zilstat [-hgdv] [-i interval] [-p pool_name]\")\n\ncurr = {}\ndiff = {}\nkstat = {}\nds_pairs = {}\npool_name = None\ndataset_name = None\ninterval = 0\nsep = \"  \"\ngFlag = True\ndsFlag = False\n\ndef prettynum(sz, scale, num=0):\n\tsuffix = [' ', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']\n\tindex = 0\n\tsave = 0\n\n\tif scale == -1:\n\t\treturn \"%*s\" % (sz, num)\n\n\t# Rounding error, return 0\n\telif 0 < num < 1:\n\t\tnum = 0\n\n\twhile num > scale and index < 5:\n\t\tsave = num\n\t\tnum = num / scale\n\t\tindex += 1\n\n\tif index == 0:\n\t\treturn \"%*d\" % (sz, num)\n\n\tif (save / scale) < 10:\n\t\treturn \"%*.1f%s\" % (sz - 1, num, suffix[index])\n\telse:\n\t\treturn \"%*d%s\" % (sz - 1, num, suffix[index])\n\ndef print_header():\n\tglobal hdr\n\tglobal sep\n\tfor col in hdr:\n\t\tnew_col = col\n\t\tif interval > 0 and cols[col][1] > 100:\n\t\t\tnew_col += \"/s\"\n\t\tsys.stdout.write(\"%*s%s\" % (cols[col][0], new_col, sep))\n\tsys.stdout.write(\"\\n\")\n\ndef print_values(v):\n\tglobal hdr\n\tglobal sep\n\tfor col in hdr:\n\t\tval = v[cols[col][2]]\n\t\tif interval > 0 and cols[col][1] > 100:\n\t\t\tval = v[cols[col][2]] // interval\n\t\tsys.stdout.write(\"%s%s\" % (\n\t\t\tprettynum(cols[col][0], cols[col][1], val), sep))\n\tsys.stdout.write(\"\\n\")\n\ndef print_dict(d):\n\tfor pool in d:\n\t\tfor objset in d[pool]:\n\t\t\tprint_values(d[pool][objset])\n\ndef detailed_usage():\n\tsys.stderr.write(\"%s\\n\" % cmd)\n\tsys.stderr.write(\"Field definitions are as follows:\\n\")\n\tfor key in cols:\n\t\tsys.stderr.write(\"%11s : %s\\n\" % (key, cols[key][2]))\n\tsys.stderr.write(\"\\n\")\n\tsys.exit(0)\n\ndef init():\n\tglobal pool_name\n\tglobal dataset_name\n\tglobal interval\n\tglobal hdr\n\tglobal curr\n\tglobal gFlag\n\tglobal sep\n\n\tcurr = dict()\n\n\tparser = argparse.ArgumentParser(description='Program to print zilstats',\n                                \t add_help=True,\n\t\t\t\t\t formatter_class=RawTextHelpFormatter,\n\t\t\t\t\t epilog=\"\\nUsage Examples\\n\"\\\n\t\t\t\t \t\t\"Note: Global zilstats is shown by default,\"\\\n\t\t\t\t\t\t\" if none of a|p|d option is not provided\\n\"\\\n\t\t\t\t \t\t\"\\tzilstat -a\\n\"\\\n\t\t\t\t\t\t'\\tzilstat -v\\n'\\\n\t\t\t\t\t\t'\\tzilstat -p tank\\n'\\\n\t\t\t\t\t\t'\\tzilstat -d tank/d1,tank/d2,tank/zv1\\n'\\\n\t\t\t\t\t\t'\\tzilstat -i 1\\n'\\\n\t\t\t\t\t\t'\\tzilstat -s \\\"***\\\"\\n'\\\n\t\t\t\t\t\t'\\tzilstat -f zcwc,zimnb,zimsb\\n')\n\n\tparser.add_argument(\n\t\t\"-v\", \"--verbose\",\n\t\taction=\"store_true\",\n\t\thelp=\"List field headers and definitions\"\n\t)\n\n\tpool_grp = parser.add_mutually_exclusive_group()\n\n\tpool_grp.add_argument(\n\t\t\"-a\", \"--all\",\n\t\taction=\"store_true\",\n\t\tdest=\"all\",\n\t\thelp=\"Print all dataset stats\"\n\t)\n\n\tpool_grp.add_argument(\n\t\t\"-p\", \"--pool\",\n\t\ttype=str,\n\t\thelp=\"Print stats for all datasets of a speicfied pool\"\n\t)\n\n\tpool_grp.add_argument(\n\t\t\"-d\", \"--dataset\",\n\t\ttype=str,\n\t\thelp=\"Print given dataset(s) (Comma separated)\"\n\t)\n\n\tparser.add_argument(\n\t\t\"-f\", \"--columns\",\n\t\ttype=str,\n\t\thelp=\"Specify specific fields to print (see -v)\"\n\t)\n\n\tparser.add_argument(\n\t\t\"-s\", \"--separator\",\n\t\ttype=str,\n\t\thelp=\"Override default field separator with custom \"\n\t\t\t \"character or string\"\n\t)\n\n\tparser.add_argument(\n\t\t\"-i\", \"--interval\",\n\t\ttype=int,\n\t\tdest=\"interval\",\n\t\thelp=\"Print stats between specified interval\"\n\t\t\t \" (in seconds)\"\n\t)\n\n\tparsed_args = parser.parse_args()\n\n\tif parsed_args.verbose:\n\t\tdetailed_usage()\n\n\tif parsed_args.all:\n\t\tgFlag = False\n\n\tif parsed_args.interval:\n\t\tinterval = parsed_args.interval\n\n\tif parsed_args.pool:\n\t\tpool_name = parsed_args.pool\n\t\tgFlag = False\n\n\tif parsed_args.dataset:\n\t\tdataset_name = parsed_args.dataset\n\t\tgFlag = False\n\n\tif parsed_args.separator:\n\t\tsep = parsed_args.separator\n\n\tif gFlag:\n\t\thdr = ghdr\n\n\tif parsed_args.columns:\n\t\thdr = parsed_args.columns.split(\",\")\n\n\t\tinvalid = []\n\t\tfor ele in hdr:\n\t\t\tif ele not in cols:\n\t\t\t\tinvalid.append(ele)\n\n\t\tif len(invalid) > 0:\n\t\t\tsys.stderr.write(\"Invalid column definition! -- %s\\n\" % invalid)\n\t\t\tsys.exit(1)\n\n\tif pool_name and dataset_name:\n\t\tprint (\"Error: Can not filter both dataset and pool\")\n\t\tsys.exit(1)\n\ndef FileCheck(fname):\n\ttry:\n\t\treturn (open(fname))\n\texcept IOError:\n\t\tprint (\"Unable to open zilstat proc file: \" + fname)\n\t\tsys.exit(1)\n\nif sys.platform.startswith('freebsd'):\n\t# Requires py-sysctl on FreeBSD\n\timport sysctl\n\n\tdef kstat_update(pool = None, objid = None):\n\t\tglobal kstat\n\t\tkstat = {}\n\t\tif not pool:\n\t\t\tfile = \"kstat.zfs.misc.zil\"\n\t\t\tk = [ctl for ctl in sysctl.filter(file) \\\n\t\t\t\tif ctl.type != sysctl.CTLTYPE_NODE]\n\t\t\tkstat_process_str(k, file, \"GLOBAL\", len(file + \".\"))\n\t\telif objid:\n\t\t\tfile = \"kstat.zfs.\" + pool + \".dataset.objset-\" + objid\n\t\t\tk = [ctl for ctl in sysctl.filter(file) if ctl.type \\\n\t\t\t\t!= sysctl.CTLTYPE_NODE]\n\t\t\tkstat_process_str(k, file, objid, len(file + \".\"))\n\t\telse:\n\t\t\tfile = \"kstat.zfs.\" + pool + \".dataset\"\n\t\t\tzil_start = len(file + \".\")\n\t\t\tobj_start = len(\"kstat.zfs.\" + pool + \".\")\n\t\t\tk = [ctl for ctl in sysctl.filter(file)\n\t\t\t\tif ctl.type != sysctl.CTLTYPE_NODE]\n\t\t\tfor s in k:\n\t\t\t\tif not s or (s.name.find(\"zil\") == -1 and \\\n\t\t\t\t\ts.name.find(\"dataset_name\") == -1):\n\t\t\t\t\tcontinue\n\t\t\t\tname, value = s.name, s.value\n\t\t\t\tobjid = re.findall(r'0x[0-9A-F]+', \\\n\t\t\t\t\tname[obj_start:], re.I)[0]\n\t\t\t\tif objid not in kstat:\n\t\t\t\t\tkstat[objid] = dict()\n\t\t\t\tzil_start = len(file + \".objset-\" + \\\n\t\t\t\t\tobjid + \".\")\n\t\t\t\tkstat[objid][name[zil_start:]] = value \\\n\t\t\t\t\tif (name.find(\"dataset_name\")) \\\n\t\t\t\t\telse int(value)\n\n\tdef kstat_process_str(k, file, objset = \"GLOBAL\", zil_start = 0):\n\t\t\tglobal kstat\n\t\t\tif not k:\n\t\t\t\tprint(\"Unable to process kstat for: \" + file)\n\t\t\t\tsys.exit(1)\n\t\t\tkstat[objset] = dict()\n\t\t\tfor s in k:\n\t\t\t\tif not s or (s.name.find(\"zil\") == -1 and \\\n\t\t\t\t    s.name.find(\"dataset_name\") == -1):\n\t\t\t\t\tcontinue\n\t\t\t\tname, value = s.name, s.value\n\t\t\t\tkstat[objset][name[zil_start:]] = value \\\n\t\t\t\t    if (name.find(\"dataset_name\")) else int(value)\n\nelif sys.platform.startswith('linux'):\n\tdef kstat_update(pool = None, objid = None):\n\t\tglobal kstat\n\t\tkstat = {}\n\t\tif not pool:\n\t\t\tk = [line.strip() for line in \\\n\t\t\t\tFileCheck(\"/proc/spl/kstat/zfs/zil\")]\n\t\t\tkstat_process_str(k, \"/proc/spl/kstat/zfs/zil\")\n\t\telif objid:\n\t\t\tfile = \"/proc/spl/kstat/zfs/\" + pool + \"/objset-\" + objid\n\t\t\tk = [line.strip() for line in FileCheck(file)]\n\t\t\tkstat_process_str(k, file, objid)\n\t\telse:\n\t\t\tif not os.path.exists(f\"/proc/spl/kstat/zfs/{pool}\"):\n\t\t\t\tprint(\"Pool \\\"\" + pool + \"\\\" does not exist, Exitting\")\n\t\t\t\tsys.exit(1)\n\t\t\tobjsets = os.listdir(f'/proc/spl/kstat/zfs/{pool}')\n\t\t\tfor objid in objsets:\n\t\t\t\tif objid.find(\"objset-\") == -1:\n\t\t\t\t\tcontinue\n\t\t\t\tfile = \"/proc/spl/kstat/zfs/\" + pool + \"/\" + objid\n\t\t\t\tk = [line.strip() for line in FileCheck(file)]\n\t\t\t\tkstat_process_str(k, file, objid.replace(\"objset-\", \"\"))\n\n\tdef kstat_process_str(k, file, objset = \"GLOBAL\", zil_start = 0):\n\t\t\tglobal kstat\n\t\t\tif not k:\n\t\t\t\tprint(\"Unable to process kstat for: \" + file)\n\t\t\t\tsys.exit(1)\n\n\t\t\tkstat[objset] = dict()\n\t\t\tfor s in k:\n\t\t\t\tif not s or (s.find(\"zil\") == -1 and \\\n\t\t\t\t    s.find(\"dataset_name\") == -1):\n\t\t\t\t\tcontinue\n\t\t\t\tname, unused, value = s.split()\n\t\t\t\tkstat[objset][name] = value \\\n\t\t\t\t    if (name == \"dataset_name\") else int(value)\n\ndef zil_process_kstat():\n\tglobal curr, pool_name, dataset_name, dsFlag, ds_pairs\n\tcurr.clear()\n\tif gFlag == True:\n\t\tkstat_update()\n\t\tzil_build_dict()\n\telse:\n\t\tif pool_name:\n\t\t\tkstat_update(pool_name)\n\t\t\tzil_build_dict(pool_name)\n\t\telif dataset_name:\n\t\t\tif dsFlag == False:\n\t\t\t\tdsFlag = True\n\t\t\t\tdatasets = dataset_name.split(',')\n\t\t\t\tds_pairs = defaultdict(list)\n\t\t\t\tfor ds in datasets:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tobjid = subprocess.check_output(['zfs',\n\t\t\t\t\t\t    'list', '-Hpo', 'objsetid', ds], \\\n\t\t\t\t\t\t    stderr=subprocess.DEVNULL) \\\n\t\t\t\t\t\t    .decode('utf-8').strip()\n\t\t\t\t\texcept subprocess.CalledProcessError as e:\n\t\t\t\t\t\tprint(\"Command: \\\"zfs list -Hpo objset \"\\\n\t\t\t\t\t\t+ str(ds) + \"\\\" failed with error code:\"\\\n\t\t\t\t\t\t+ str(e.returncode))\n\t\t\t\t\t\tprint(\"Please make sure that dataset \\\"\"\\\n\t\t\t\t\t\t+ str(ds) + \"\\\" exists\")\n\t\t\t\t\t\tsys.exit(1)\n\t\t\t\t\tif not objid:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tds_pairs[ds.split('/')[0]]. \\\n\t\t\t\t\t\tappend(hex(int(objid)))\n\t\t\tfor pool, objids in ds_pairs.items():\n\t\t\t\tfor objid in objids:\n\t\t\t\t\tkstat_update(pool, objid)\n\t\t\t\t\tzil_build_dict(pool)\n\t\telse:\n\t\t\ttry:\n\t\t\t\tpools = subprocess.check_output(['zpool', 'list', '-Hpo',\\\n\t\t\t\t    'name']).decode('utf-8').split()\n\t\t\texcept subprocess.CalledProcessError as e:\n\t\t\t\tprint(\"Command: \\\"zpool list -Hpo name\\\" failed with error\"\\\n\t\t\t\t    \"code: \" + str(e.returncode))\n\t\t\t\tsys.exit(1)\n\t\t\tfor pool in pools:\n\t\t\t\tkstat_update(pool)\n\t\t\t\tzil_build_dict(pool)\n\ndef calculate_diff():\n\tglobal curr, diff\n\tprev = copy.deepcopy(curr)\n\tzil_process_kstat()\n\tdiff = copy.deepcopy(curr)\n\tfor pool in curr:\n\t\tfor objset in curr[pool]:\n\t\t\tfor key in curr[pool][objset]:\n\t\t\t\tif not isinstance(diff[pool][objset][key], int):\n\t\t\t\t\tcontinue\n\t\t\t\t# If prev is NULL, this is the\n\t\t\t\t# first time we are here\n\t\t\t\tif not prev:\n\t\t\t\t\tdiff[pool][objset][key] = 0\n\t\t\t\telse:\n\t\t\t\t\tdiff[pool][objset][key] \\\n\t\t\t\t\t\t= curr[pool][objset][key] \\\n\t\t\t\t\t\t- prev[pool][objset][key]\n\ndef zil_build_dict(pool = \"GLOBAL\"):\n\tglobal kstat\n\tfor objset in kstat:\n\t\tfor key in kstat[objset]:\n\t\t\tval = kstat[objset][key]\n\t\t\tif pool not in curr:\n\t\t\t\tcurr[pool] = dict()\n\t\t\tif objset not in curr[pool]:\n\t\t\t\tcurr[pool][objset] = dict()\n\t\t\tcurr[pool][objset][key] = val\n\ndef zil_extend_dict():\n\tglobal diff\n\tfor pool in diff:\n\t\tfor objset in diff[pool]:\n\t\t\tdiff[pool][objset][\"pool\"] = pool\n\t\t\tdiff[pool][objset][\"objset\"] = objset\n\t\t\tdiff[pool][objset][\"time\"] = time.strftime(\"%H:%M:%S\", \\\n\t\t\t\ttime.localtime())\n\t\t\tdiff[pool][objset][\"icc+inc\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_copied_count\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_needcopy_count\"]\n\t\t\tdiff[pool][objset][\"icb+inb\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_copied_bytes\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_needcopy_bytes\"]\n\t\t\tdiff[pool][objset][\"iic+idc\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_indirect_count\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_copied_count\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_needcopy_count\"]\n\t\t\tdiff[pool][objset][\"iib+idb\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_indirect_bytes\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_copied_bytes\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_needcopy_bytes\"]\n\t\t\tdiff[pool][objset][\"imnc+imsc\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_count\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_count\"]\n\t\t\tdiff[pool][objset][\"imnb+imsb\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_bytes\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_bytes\"]\n\t\t\tdiff[pool][objset][\"imnw+imsw\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_write\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_write\"]\n\t\t\tdiff[pool][objset][\"imna+imsa\"] = \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_alloc\"] + \\\n\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_alloc\"]\n\t\t\tif diff[pool][objset][\"imna+imsa\"] > 0:\n\t\t\t\tdiff[pool][objset][\"imb/ima\"] = 100 * \\\n\t\t\t\t\tdiff[pool][objset][\"imnb+imsb\"] // \\\n\t\t\t\t\tdiff[pool][objset][\"imna+imsa\"]\n\t\t\telse:\n\t\t\t\tdiff[pool][objset][\"imb/ima\"] = 100\n\t\t\tif diff[pool][objset][\"zil_itx_metaslab_normal_alloc\"] > 0:\n\t\t\t\tdiff[pool][objset][\"imnb/imna\"] = 100 * \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_bytes\"] // \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_alloc\"]\n\t\t\telse:\n\t\t\t\tdiff[pool][objset][\"imnb/imna\"] = 100\n\t\t\tif diff[pool][objset][\"zil_itx_metaslab_slog_alloc\"] > 0:\n\t\t\t\tdiff[pool][objset][\"imsb/imsa\"] = 100 * \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_bytes\"] // \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_alloc\"]\n\t\t\telse:\n\t\t\t\tdiff[pool][objset][\"imsb/imsa\"] = 100\n\t\t\tif diff[pool][objset][\"imnw+imsw\"] > 0:\n\t\t\t\tdiff[pool][objset][\"imb/imw\"] = 100 * \\\n\t\t\t\t\tdiff[pool][objset][\"imnb+imsb\"] // \\\n\t\t\t\t\tdiff[pool][objset][\"imnw+imsw\"]\n\t\t\telse:\n\t\t\t\tdiff[pool][objset][\"imb/imw\"] = 100\n\t\t\tif diff[pool][objset][\"zil_itx_metaslab_normal_alloc\"] > 0:\n\t\t\t\tdiff[pool][objset][\"imnb/imnw\"] = 100 * \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_bytes\"] // \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_normal_write\"]\n\t\t\telse:\n\t\t\t\tdiff[pool][objset][\"imnb/imnw\"] = 100\n\t\t\tif diff[pool][objset][\"zil_itx_metaslab_slog_alloc\"] > 0:\n\t\t\t\tdiff[pool][objset][\"imsb/imsw\"] = 100 * \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_bytes\"] // \\\n\t\t\t\t\tdiff[pool][objset][\"zil_itx_metaslab_slog_write\"]\n\t\t\telse:\n\t\t\t\tdiff[pool][objset][\"imsb/imsw\"] = 100\n\ndef sign_handler_epipe(sig, frame):\n\tprint(\"Caught EPIPE signal: \" + str(frame))\n\tprint(\"Exitting...\")\n\tsys.exit(0)\n\ndef main():\n\tglobal interval\n\tglobal curr, diff\n\thprint = False\n\tinit()\n\tsignal.signal(signal.SIGINT, signal.SIG_DFL)\n\tsignal.signal(signal.SIGPIPE, sign_handler_epipe)\n\n\tzil_process_kstat()\n\tif not curr:\n\t\tprint (\"Error: No stats to show\")\n\t\tsys.exit(0)\n\tprint_header()\n\tif interval > 0:\n\t\ttime.sleep(interval)\n\t\twhile True:\n\t\t\tcalculate_diff()\n\t\t\tif not diff:\n\t\t\t\tprint (\"Error: No stats to show\")\n\t\t\t\tsys.exit(0)\n\t\t\tzil_extend_dict()\n\t\t\tprint_dict(diff)\n\t\t\ttime.sleep(interval)\n\telse:\n\t\tdiff = curr\n\t\tzil_extend_dict()\n\t\tprint_dict(diff)\n\nif __name__ == '__main__':\n\tmain()\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}