{
  "module_name": "zgenhostid.c",
  "hash_id": "553bc7ff37786e5f6ff9c0bd37874dbf9b4dac58538feb8b887979a5176995fd",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zgenhostid.c",
  "human_readable_source": " \n\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\nstatic __attribute__((noreturn)) void\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: zgenhostid [-fh] [-o path] [value]\\n\\n\"\n\t    \"  -f\\t\\t force hostid file write\\n\"\n\t    \"  -h\\t\\t print this usage and exit\\n\"\n\t    \"  -o <filename>\\t write hostid to this file\\n\\n\"\n\t    \"If hostid file is not present, store a hostid in it.\\n\"\n\t    \"The optional value should be an 8-digit hex number between\"\n\t    \" 1 and 2^32-1.\\n\"\n\t    \"If the value is 0 or no value is provided, a random one\"\n\t    \" will be generated.\\n\"\n\t    \"The value must be unique among your systems.\\n\");\n\texit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char **argv)\n{\n\t \n\tconst char *path = \"/etc/hostid\";\n\t \n\tunsigned long input_i = 0;\n\n\tint opt;\n\tint force_fwrite = 0;\n\twhile ((opt = getopt_long(argc, argv, \"fo:h?\", 0, 0)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'f':\n\t\t\tforce_fwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tpath = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tusage();\n\t\t}\n\t}\n\n\tchar *in_s = argv[optind];\n\tif (in_s != NULL) {\n\t\t \n\t\tif (strncasecmp(\"0x\", in_s, 2) == 0) {\n\t\t\tin_s += 2;\n\t\t}\n\n\t\t \n\t\tconst char *hex = \"0123456789abcdefABCDEF\";\n\t\tif (strlen(in_s) != 8 || strspn(in_s, hex) != 8) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(ERANGE));\n\t\t\tusage();\n\t\t}\n\n\t\tinput_i = strtoul(in_s, NULL, 16);\n\t\tif (errno != 0) {\n\t\t\tperror(\"strtoul\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (input_i > UINT32_MAX) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(ERANGE));\n\t\t\tusage();\n\t\t}\n\t}\n\n\tstruct stat fstat;\n\tif (force_fwrite == 0 && stat(path, &fstat) == 0 &&\n\t    S_ISREG(fstat.st_mode)) {\n\t\tfprintf(stderr, \"%s: %s\\n\", path, strerror(EEXIST));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\twhile (input_i == 0) {\n\t\tsrand48(getpid() ^ time(NULL));\n\t\tinput_i = lrand48();\n\t}\n\n\tFILE *fp = fopen(path, \"wb\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\tuint32_t hostid = input_i;\n\tint written = fwrite(&hostid, 1, 4, fp);\n\tif (written != 4) {\n\t\tperror(\"fwrite\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfclose(fp);\n\texit(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}