{
  "module_name": "zhack.c",
  "hash_id": "100cb3ba176d17fe3fe08e7193b48bc582bbf2e91bf99cb7ea82362c0c64fad8",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zhack.c",
  "human_readable_source": " \n\n \n\n \n\n#include <zfs_prop.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu.h>\n#include <sys/zap.h>\n#include <sys/zfs_znode.h>\n#include <sys/dsl_synctask.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/fs/zfs.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_pool.h>\n#include <sys/zio_checksum.h>\n#include <sys/zio_compress.h>\n#include <sys/zfeature.h>\n#include <sys/dmu_tx.h>\n#include <zfeature_common.h>\n#include <libzutil.h>\n\nstatic importargs_t g_importargs;\nstatic char *g_pool;\nstatic boolean_t g_readonly;\n\ntypedef enum {\n\tZHACK_REPAIR_OP_UNKNOWN  = 0,\n\tZHACK_REPAIR_OP_CKSUM    = (1 << 0),\n\tZHACK_REPAIR_OP_UNDETACH = (1 << 1)\n} zhack_repair_op_t;\n\nstatic __attribute__((noreturn)) void\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"Usage: zhack [-c cachefile] [-d dir] <subcommand> <args> ...\\n\"\n\t    \"where <subcommand> <args> is one of the following:\\n\"\n\t    \"\\n\");\n\n\t(void) fprintf(stderr,\n\t    \"    feature stat <pool>\\n\"\n\t    \"        print information about enabled features\\n\"\n\t    \"    feature enable [-r] [-d desc] <pool> <feature>\\n\"\n\t    \"        add a new enabled feature to the pool\\n\"\n\t    \"        -d <desc> sets the feature's description\\n\"\n\t    \"        -r set read-only compatible flag for feature\\n\"\n\t    \"    feature ref [-md] <pool> <feature>\\n\"\n\t    \"        change the refcount on the given feature\\n\"\n\t    \"        -d decrease instead of increase the refcount\\n\"\n\t    \"        -m add the feature to the label if increasing refcount\\n\"\n\t    \"\\n\"\n\t    \"    <feature> : should be a feature guid\\n\"\n\t    \"\\n\"\n\t    \"    label repair <device>\\n\"\n\t    \"        repair labels of a specified device according to options\\n\"\n\t    \"        which may be combined to do their functions in one call\\n\"\n\t    \"        -c repair corrupted label checksums\\n\"\n\t    \"        -u restore the label on a detached device\\n\"\n\t    \"\\n\"\n\t    \"    <device> : path to vdev\\n\");\n\texit(1);\n}\n\n\nstatic __attribute__((format(printf, 3, 4))) __attribute__((noreturn)) void\nfatal(spa_t *spa, const void *tag, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (spa != NULL) {\n\t\tspa_close(spa, tag);\n\t\t(void) spa_export(g_pool, NULL, B_TRUE, B_FALSE);\n\t}\n\n\tva_start(ap, fmt);\n\t(void) fputs(\"zhack: \", stderr);\n\t(void) vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\t(void) fputc('\\n', stderr);\n\n\texit(1);\n}\n\nstatic int\nspace_delta_cb(dmu_object_type_t bonustype, const void *data,\n    zfs_file_info_t *zoi)\n{\n\t(void) data, (void) zoi;\n\n\t \n\tif (bonustype != DMU_OT_ZNODE && bonustype != DMU_OT_SA)\n\t\treturn (ENOENT);\n\t(void) fprintf(stderr, \"modifying object that needs user accounting\");\n\tabort();\n}\n\n \nstatic void\nzhack_import(char *target, boolean_t readonly)\n{\n\tnvlist_t *config;\n\tnvlist_t *props;\n\tint error;\n\n\tkernel_init(readonly ? SPA_MODE_READ :\n\t    (SPA_MODE_READ | SPA_MODE_WRITE));\n\n\tdmu_objset_register_type(DMU_OST_ZFS, space_delta_cb);\n\n\tg_readonly = readonly;\n\tg_importargs.can_be_active = readonly;\n\tg_pool = strdup(target);\n\n\tlibpc_handle_t lpch = {\n\t\t.lpc_lib_handle = NULL,\n\t\t.lpc_ops = &libzpool_config_ops,\n\t\t.lpc_printerr = B_TRUE\n\t};\n\terror = zpool_find_config(&lpch, target, &config, &g_importargs);\n\tif (error)\n\t\tfatal(NULL, FTAG, \"cannot import '%s'\", target);\n\n\tprops = NULL;\n\tif (readonly) {\n\t\tVERIFY(nvlist_alloc(&props, NV_UNIQUE_NAME, 0) == 0);\n\t\tVERIFY(nvlist_add_uint64(props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_READONLY), 1) == 0);\n\t}\n\n\tzfeature_checks_disable = B_TRUE;\n\terror = spa_import(target, config, props,\n\t    (readonly ?  ZFS_IMPORT_SKIP_MMP : ZFS_IMPORT_NORMAL));\n\tfnvlist_free(config);\n\tzfeature_checks_disable = B_FALSE;\n\tif (error == EEXIST)\n\t\terror = 0;\n\n\tif (error)\n\t\tfatal(NULL, FTAG, \"can't import '%s': %s\", target,\n\t\t    strerror(error));\n}\n\nstatic void\nzhack_spa_open(char *target, boolean_t readonly, const void *tag, spa_t **spa)\n{\n\tint err;\n\n\tzhack_import(target, readonly);\n\n\tzfeature_checks_disable = B_TRUE;\n\terr = spa_open(target, spa, tag);\n\tzfeature_checks_disable = B_FALSE;\n\n\tif (err != 0)\n\t\tfatal(*spa, FTAG, \"cannot open '%s': %s\", target,\n\t\t    strerror(err));\n\tif (spa_version(*spa) < SPA_VERSION_FEATURES) {\n\t\tfatal(*spa, FTAG, \"'%s' has version %d, features not enabled\",\n\t\t    target, (int)spa_version(*spa));\n\t}\n}\n\nstatic void\ndump_obj(objset_t *os, uint64_t obj, const char *name)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\n\t(void) printf(\"%s_obj:\\n\", name);\n\n\tfor (zap_cursor_init(&zc, os, obj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tif (za.za_integer_length == 8) {\n\t\t\tASSERT(za.za_num_integers == 1);\n\t\t\t(void) printf(\"\\t%s = %llu\\n\",\n\t\t\t    za.za_name, (u_longlong_t)za.za_first_integer);\n\t\t} else {\n\t\t\tASSERT(za.za_integer_length == 1);\n\t\t\tchar val[1024];\n\t\t\tVERIFY(zap_lookup(os, obj, za.za_name,\n\t\t\t    1, sizeof (val), val) == 0);\n\t\t\t(void) printf(\"\\t%s = %s\\n\", za.za_name, val);\n\t\t}\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nstatic void\ndump_mos(spa_t *spa)\n{\n\tnvlist_t *nv = spa->spa_label_features;\n\tnvpair_t *pair;\n\n\t(void) printf(\"label config:\\n\");\n\tfor (pair = nvlist_next_nvpair(nv, NULL);\n\t    pair != NULL;\n\t    pair = nvlist_next_nvpair(nv, pair)) {\n\t\t(void) printf(\"\\t%s\\n\", nvpair_name(pair));\n\t}\n}\n\nstatic void\nzhack_do_feature_stat(int argc, char **argv)\n{\n\tspa_t *spa;\n\tobjset_t *os;\n\tchar *target;\n\n\targc--;\n\targv++;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, \"error: missing pool name\\n\");\n\t\tusage();\n\t}\n\ttarget = argv[0];\n\n\tzhack_spa_open(target, B_TRUE, FTAG, &spa);\n\tos = spa->spa_meta_objset;\n\n\tdump_obj(os, spa->spa_feat_for_read_obj, \"for_read\");\n\tdump_obj(os, spa->spa_feat_for_write_obj, \"for_write\");\n\tdump_obj(os, spa->spa_feat_desc_obj, \"descriptions\");\n\tif (spa_feature_is_active(spa, SPA_FEATURE_ENABLED_TXG)) {\n\t\tdump_obj(os, spa->spa_feat_enabled_txg_obj, \"enabled_txg\");\n\t}\n\tdump_mos(spa);\n\n\tspa_close(spa, FTAG);\n}\n\nstatic void\nzhack_feature_enable_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tzfeature_info_t *feature = arg;\n\n\tfeature_enable_sync(spa, feature, tx);\n\n\tspa_history_log_internal(spa, \"zhack enable feature\", tx,\n\t    \"name=%s flags=%u\",\n\t    feature->fi_guid, feature->fi_flags);\n}\n\nstatic void\nzhack_do_feature_enable(int argc, char **argv)\n{\n\tint c;\n\tchar *desc, *target;\n\tspa_t *spa;\n\tobjset_t *mos;\n\tzfeature_info_t feature;\n\tconst spa_feature_t nodeps[] = { SPA_FEATURE_NONE };\n\n\t \n\tdesc = NULL;\n\tfeature.fi_uname = \"zhack\";\n\tfeature.fi_flags = 0;\n\tfeature.fi_depends = nodeps;\n\tfeature.fi_feature = SPA_FEATURE_NONE;\n\n\toptind = 1;\n\twhile ((c = getopt(argc, argv, \"+rd:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tfeature.fi_flags |= ZFEATURE_FLAG_READONLY_COMPAT;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (desc != NULL)\n\t\t\t\tfree(desc);\n\t\t\tdesc = strdup(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (desc == NULL)\n\t\tdesc = strdup(\"zhack injected\");\n\tfeature.fi_desc = desc;\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, \"error: missing feature or pool name\\n\");\n\t\tusage();\n\t}\n\ttarget = argv[0];\n\tfeature.fi_guid = argv[1];\n\n\tif (!zfeature_is_valid_guid(feature.fi_guid))\n\t\tfatal(NULL, FTAG, \"invalid feature guid: %s\", feature.fi_guid);\n\n\tzhack_spa_open(target, B_FALSE, FTAG, &spa);\n\tmos = spa->spa_meta_objset;\n\n\tif (zfeature_is_supported(feature.fi_guid))\n\t\tfatal(spa, FTAG, \"'%s' is a real feature, will not enable\",\n\t\t    feature.fi_guid);\n\tif (0 == zap_contains(mos, spa->spa_feat_desc_obj, feature.fi_guid))\n\t\tfatal(spa, FTAG, \"feature already enabled: %s\",\n\t\t    feature.fi_guid);\n\n\tVERIFY0(dsl_sync_task(spa_name(spa), NULL,\n\t    zhack_feature_enable_sync, &feature, 5, ZFS_SPACE_CHECK_NORMAL));\n\n\tspa_close(spa, FTAG);\n\n\tfree(desc);\n}\n\nstatic void\nfeature_incr_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tzfeature_info_t *feature = arg;\n\tuint64_t refcount;\n\n\tVERIFY0(feature_get_refcount_from_disk(spa, feature, &refcount));\n\tfeature_sync(spa, feature, refcount + 1, tx);\n\tspa_history_log_internal(spa, \"zhack feature incr\", tx,\n\t    \"name=%s\", feature->fi_guid);\n}\n\nstatic void\nfeature_decr_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tzfeature_info_t *feature = arg;\n\tuint64_t refcount;\n\n\tVERIFY0(feature_get_refcount_from_disk(spa, feature, &refcount));\n\tfeature_sync(spa, feature, refcount - 1, tx);\n\tspa_history_log_internal(spa, \"zhack feature decr\", tx,\n\t    \"name=%s\", feature->fi_guid);\n}\n\nstatic void\nzhack_do_feature_ref(int argc, char **argv)\n{\n\tint c;\n\tchar *target;\n\tboolean_t decr = B_FALSE;\n\tspa_t *spa;\n\tobjset_t *mos;\n\tzfeature_info_t feature;\n\tconst spa_feature_t nodeps[] = { SPA_FEATURE_NONE };\n\n\t \n\tfeature.fi_uname = \"zhack\";\n\tfeature.fi_flags = 0;\n\tfeature.fi_desc = NULL;\n\tfeature.fi_depends = nodeps;\n\tfeature.fi_feature = SPA_FEATURE_NONE;\n\n\toptind = 1;\n\twhile ((c = getopt(argc, argv, \"+md\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'm':\n\t\t\tfeature.fi_flags |= ZFEATURE_FLAG_MOS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdecr = B_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, \"error: missing feature or pool name\\n\");\n\t\tusage();\n\t}\n\ttarget = argv[0];\n\tfeature.fi_guid = argv[1];\n\n\tif (!zfeature_is_valid_guid(feature.fi_guid))\n\t\tfatal(NULL, FTAG, \"invalid feature guid: %s\", feature.fi_guid);\n\n\tzhack_spa_open(target, B_FALSE, FTAG, &spa);\n\tmos = spa->spa_meta_objset;\n\n\tif (zfeature_is_supported(feature.fi_guid)) {\n\t\tfatal(spa, FTAG,\n\t\t    \"'%s' is a real feature, will not change refcount\",\n\t\t    feature.fi_guid);\n\t}\n\n\tif (0 == zap_contains(mos, spa->spa_feat_for_read_obj,\n\t    feature.fi_guid)) {\n\t\tfeature.fi_flags &= ~ZFEATURE_FLAG_READONLY_COMPAT;\n\t} else if (0 == zap_contains(mos, spa->spa_feat_for_write_obj,\n\t    feature.fi_guid)) {\n\t\tfeature.fi_flags |= ZFEATURE_FLAG_READONLY_COMPAT;\n\t} else {\n\t\tfatal(spa, FTAG, \"feature is not enabled: %s\", feature.fi_guid);\n\t}\n\n\tif (decr) {\n\t\tuint64_t count;\n\t\tif (feature_get_refcount_from_disk(spa, &feature,\n\t\t    &count) == 0 && count == 0) {\n\t\t\tfatal(spa, FTAG, \"feature refcount already 0: %s\",\n\t\t\t    feature.fi_guid);\n\t\t}\n\t}\n\n\tVERIFY0(dsl_sync_task(spa_name(spa), NULL,\n\t    decr ? feature_decr_sync : feature_incr_sync, &feature,\n\t    5, ZFS_SPACE_CHECK_NORMAL));\n\n\tspa_close(spa, FTAG);\n}\n\nstatic int\nzhack_do_feature(int argc, char **argv)\n{\n\tchar *subcommand;\n\n\targc--;\n\targv++;\n\tif (argc == 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: no feature operation specified\\n\");\n\t\tusage();\n\t}\n\n\tsubcommand = argv[0];\n\tif (strcmp(subcommand, \"stat\") == 0) {\n\t\tzhack_do_feature_stat(argc, argv);\n\t} else if (strcmp(subcommand, \"enable\") == 0) {\n\t\tzhack_do_feature_enable(argc, argv);\n\t} else if (strcmp(subcommand, \"ref\") == 0) {\n\t\tzhack_do_feature_ref(argc, argv);\n\t} else {\n\t\t(void) fprintf(stderr, \"error: unknown subcommand: %s\\n\",\n\t\t    subcommand);\n\t\tusage();\n\t}\n\n\treturn (0);\n}\n\n#define\tASHIFT_UBERBLOCK_SHIFT(ashift)\t\\\n\tMIN(MAX(ashift, UBERBLOCK_SHIFT), \\\n\tMAX_UBERBLOCK_SHIFT)\n#define\tASHIFT_UBERBLOCK_SIZE(ashift) \\\n\t(1ULL << ASHIFT_UBERBLOCK_SHIFT(ashift))\n\n#define\tREPAIR_LABEL_STATUS_CKSUM (1 << 0)\n#define\tREPAIR_LABEL_STATUS_UB    (1 << 1)\n\nstatic int\nzhack_repair_read_label(const int fd, vdev_label_t *vl,\n    const uint64_t label_offset, const int l)\n{\n\tconst int err = pread64(fd, vl, sizeof (vdev_label_t), label_offset);\n\n\tif (err == -1) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: cannot read label %d: %s\\n\",\n\t\t    l, strerror(errno));\n\t\treturn (err);\n\t} else if (err != sizeof (vdev_label_t)) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: bad label %d read size\\n\", l);\n\t\treturn (err);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzhack_repair_calc_cksum(const int byteswap, void *data, const uint64_t offset,\n    const uint64_t abdsize, zio_eck_t *eck, zio_cksum_t *cksum)\n{\n\tzio_cksum_t verifier;\n\tzio_cksum_t current_cksum;\n\tzio_checksum_info_t *ci;\n\tabd_t *abd;\n\n\tZIO_SET_CHECKSUM(&verifier, offset, 0, 0, 0);\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(&verifier, sizeof (zio_cksum_t));\n\n\tcurrent_cksum = eck->zec_cksum;\n\teck->zec_cksum = verifier;\n\n\tci = &zio_checksum_table[ZIO_CHECKSUM_LABEL];\n\tabd = abd_get_from_buf(data, abdsize);\n\tci->ci_func[byteswap](abd, abdsize, NULL, cksum);\n\tabd_free(abd);\n\n\teck->zec_cksum = current_cksum;\n}\n\nstatic int\nzhack_repair_check_label(uberblock_t *ub, const int l, const char **cfg_keys,\n    const size_t cfg_keys_len, nvlist_t *cfg, nvlist_t *vdev_tree_cfg,\n    uint64_t *ashift)\n{\n\tint err;\n\n\tif (ub->ub_txg != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: label %d: UB TXG of 0 expected, but got %\"\n\t\t    PRIu64 \"\\n\",\n\t\t    l, ub->ub_txg);\n\t\t(void) fprintf(stderr, \"It would appear the device was not \"\n\t\t    \"properly removed.\\n\");\n\t\treturn (1);\n\t}\n\n\tfor (int i = 0; i < cfg_keys_len; i++) {\n\t\tuint64_t val;\n\t\terr = nvlist_lookup_uint64(cfg, cfg_keys[i], &val);\n\t\tif (err) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"error: label %d, %d: \"\n\t\t\t    \"cannot find nvlist key %s\\n\",\n\t\t\t    l, i, cfg_keys[i]);\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\terr = nvlist_lookup_nvlist(cfg,\n\t    ZPOOL_CONFIG_VDEV_TREE, &vdev_tree_cfg);\n\tif (err) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: label %d: cannot find nvlist key %s\\n\",\n\t\t    l, ZPOOL_CONFIG_VDEV_TREE);\n\t\treturn (err);\n\t}\n\n\terr = nvlist_lookup_uint64(vdev_tree_cfg,\n\t    ZPOOL_CONFIG_ASHIFT, ashift);\n\tif (err) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: label %d: cannot find nvlist key %s\\n\",\n\t\t    l, ZPOOL_CONFIG_ASHIFT);\n\t\treturn (err);\n\t}\n\n\tif (*ashift == 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: label %d: nvlist key %s is zero\\n\",\n\t\t    l, ZPOOL_CONFIG_ASHIFT);\n\t\treturn (err);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzhack_repair_undetach(uberblock_t *ub, nvlist_t *cfg, const int l)\n{\n\t \n\tif (ub->ub_rootbp.blk_birth != 0) {\n\t\tconst uint64_t txg = ub->ub_rootbp.blk_birth;\n\t\tub->ub_txg = txg;\n\n\t\tif (nvlist_remove_all(cfg, ZPOOL_CONFIG_CREATE_TXG) != 0) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"error: label %d: \"\n\t\t\t    \"Failed to remove pool creation TXG\\n\",\n\t\t\t    l);\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (nvlist_remove_all(cfg, ZPOOL_CONFIG_POOL_TXG) != 0) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"error: label %d: Failed to remove pool TXG to \"\n\t\t\t    \"be replaced.\\n\",\n\t\t\t    l);\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (nvlist_add_uint64(cfg, ZPOOL_CONFIG_POOL_TXG, txg) != 0) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"error: label %d: \"\n\t\t\t    \"Failed to add pool TXG of %\" PRIu64 \"\\n\",\n\t\t\t    l, txg);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic boolean_t\nzhack_repair_write_label(const int l, const int fd, const int byteswap,\n    void *data, zio_eck_t *eck, const uint64_t offset, const uint64_t abdsize)\n{\n\tzio_cksum_t actual_cksum;\n\tzhack_repair_calc_cksum(byteswap, data, offset, abdsize, eck,\n\t    &actual_cksum);\n\tzio_cksum_t expected_cksum = eck->zec_cksum;\n\tssize_t err;\n\n\tif (ZIO_CHECKSUM_EQUAL(actual_cksum, expected_cksum))\n\t\treturn (B_FALSE);\n\n\teck->zec_cksum = actual_cksum;\n\n\terr = pwrite64(fd, data, abdsize, offset);\n\tif (err == -1) {\n\t\t(void) fprintf(stderr, \"error: cannot write label %d: %s\\n\",\n\t\t    l, strerror(errno));\n\t\treturn (B_FALSE);\n\t} else if (err != abdsize) {\n\t\t(void) fprintf(stderr, \"error: bad write size label %d\\n\", l);\n\t\treturn (B_FALSE);\n\t} else {\n\t\t(void) fprintf(stderr,\n\t\t    \"label %d: wrote %\" PRIu64 \" bytes at offset %\" PRIu64 \"\\n\",\n\t\t    l, abdsize, offset);\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic void\nzhack_repair_write_uberblock(vdev_label_t *vl, const int l,\n    const uint64_t ashift, const int fd, const int byteswap,\n    const uint64_t label_offset, uint32_t *labels_repaired)\n{\n\tvoid *ub_data =\n\t    (char *)vl + offsetof(vdev_label_t, vl_uberblock);\n\tzio_eck_t *ub_eck =\n\t    (zio_eck_t *)\n\t    ((char *)(ub_data) + (ASHIFT_UBERBLOCK_SIZE(ashift))) - 1;\n\n\tif (ub_eck->zec_magic != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: label %d: \"\n\t\t    \"Expected Uberblock checksum magic number to \"\n\t\t    \"be 0, but got %\" PRIu64 \"\\n\",\n\t\t    l, ub_eck->zec_magic);\n\t\t(void) fprintf(stderr, \"It would appear there's already \"\n\t\t    \"a checksum for the uberblock.\\n\");\n\t\treturn;\n\t}\n\n\n\tub_eck->zec_magic = byteswap ? BSWAP_64(ZEC_MAGIC) : ZEC_MAGIC;\n\n\tif (zhack_repair_write_label(l, fd, byteswap,\n\t    ub_data, ub_eck,\n\t    label_offset + offsetof(vdev_label_t, vl_uberblock),\n\t    ASHIFT_UBERBLOCK_SIZE(ashift)))\n\t\t\tlabels_repaired[l] |= REPAIR_LABEL_STATUS_UB;\n}\n\nstatic void\nzhack_repair_print_cksum(FILE *stream, const zio_cksum_t *cksum)\n{\n\t(void) fprintf(stream,\n\t    \"%016llx:%016llx:%016llx:%016llx\",\n\t    (u_longlong_t)cksum->zc_word[0],\n\t    (u_longlong_t)cksum->zc_word[1],\n\t    (u_longlong_t)cksum->zc_word[2],\n\t    (u_longlong_t)cksum->zc_word[3]);\n}\n\nstatic int\nzhack_repair_test_cksum(const int byteswap, void *vdev_data,\n    zio_eck_t *vdev_eck, const uint64_t vdev_phys_offset, const int l)\n{\n\tconst zio_cksum_t expected_cksum = vdev_eck->zec_cksum;\n\tzio_cksum_t actual_cksum;\n\tzhack_repair_calc_cksum(byteswap, vdev_data, vdev_phys_offset,\n\t    VDEV_PHYS_SIZE, vdev_eck, &actual_cksum);\n\tconst uint64_t expected_magic = byteswap ?\n\t    BSWAP_64(ZEC_MAGIC) : ZEC_MAGIC;\n\tconst uint64_t actual_magic = vdev_eck->zec_magic;\n\tint err = 0;\n\tif (actual_magic != expected_magic) {\n\t\t(void) fprintf(stderr, \"error: label %d: \"\n\t\t    \"Expected \"\n\t\t    \"the nvlist checksum magic number to not be %\"\n\t\t    PRIu64 \" not %\" PRIu64 \"\\n\",\n\t\t    l, expected_magic, actual_magic);\n\t\terr = ECKSUM;\n\t}\n\tif (!ZIO_CHECKSUM_EQUAL(actual_cksum, expected_cksum)) {\n\t\t(void) fprintf(stderr, \"error: label %d: \"\n\t\t    \"Expected the nvlist checksum to be \", l);\n\t\t(void) zhack_repair_print_cksum(stderr,\n\t\t    &expected_cksum);\n\t\t(void) fprintf(stderr, \" not \");\n\t\tzhack_repair_print_cksum(stderr, &actual_cksum);\n\t\t(void) fprintf(stderr, \"\\n\");\n\t\terr = ECKSUM;\n\t}\n\treturn (err);\n}\n\nstatic void\nzhack_repair_one_label(const zhack_repair_op_t op, const int fd,\n    vdev_label_t *vl, const uint64_t label_offset, const int l,\n    uint32_t *labels_repaired)\n{\n\tssize_t err;\n\tuberblock_t *ub = (uberblock_t *)vl->vl_uberblock;\n\tvoid *vdev_data =\n\t    (char *)vl + offsetof(vdev_label_t, vl_vdev_phys);\n\tzio_eck_t *vdev_eck =\n\t    (zio_eck_t *)((char *)(vdev_data) + VDEV_PHYS_SIZE) - 1;\n\tconst uint64_t vdev_phys_offset =\n\t    label_offset + offsetof(vdev_label_t, vl_vdev_phys);\n\tconst char *cfg_keys[] = { ZPOOL_CONFIG_VERSION,\n\t    ZPOOL_CONFIG_POOL_STATE, ZPOOL_CONFIG_GUID };\n\tnvlist_t *cfg;\n\tnvlist_t *vdev_tree_cfg = NULL;\n\tuint64_t ashift;\n\tint byteswap;\n\n\terr = zhack_repair_read_label(fd, vl, label_offset, l);\n\tif (err)\n\t\treturn;\n\n\tif (vdev_eck->zec_magic == 0) {\n\t\t(void) fprintf(stderr, \"error: label %d: \"\n\t\t    \"Expected the nvlist checksum magic number to not be zero\"\n\t\t    \"\\n\",\n\t\t    l);\n\t\t(void) fprintf(stderr, \"There should already be a checksum \"\n\t\t    \"for the label.\\n\");\n\t\treturn;\n\t}\n\n\tbyteswap =\n\t    (vdev_eck->zec_magic == BSWAP_64((uint64_t)ZEC_MAGIC));\n\n\tif (byteswap) {\n\t\tbyteswap_uint64_array(&vdev_eck->zec_cksum,\n\t\t    sizeof (zio_cksum_t));\n\t\tvdev_eck->zec_magic = BSWAP_64(vdev_eck->zec_magic);\n\t}\n\n\tif ((op & ZHACK_REPAIR_OP_CKSUM) == 0 &&\n\t    zhack_repair_test_cksum(byteswap, vdev_data, vdev_eck,\n\t    vdev_phys_offset, l) != 0) {\n\t\t(void) fprintf(stderr, \"It would appear checksums are \"\n\t\t    \"corrupted. Try zhack repair label -c <device>\\n\");\n\t\treturn;\n\t}\n\n\terr = nvlist_unpack(vl->vl_vdev_phys.vp_nvlist,\n\t    VDEV_PHYS_SIZE - sizeof (zio_eck_t), &cfg, 0);\n\tif (err) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: cannot unpack nvlist label %d\\n\", l);\n\t\treturn;\n\t}\n\n\terr = zhack_repair_check_label(ub,\n\t    l, cfg_keys, ARRAY_SIZE(cfg_keys), cfg, vdev_tree_cfg, &ashift);\n\tif (err)\n\t\treturn;\n\n\tif ((op & ZHACK_REPAIR_OP_UNDETACH) != 0) {\n\t\tchar *buf;\n\t\tsize_t buflen;\n\n\t\terr = zhack_repair_undetach(ub, cfg, l);\n\t\tif (err)\n\t\t\treturn;\n\n\t\tbuf = vl->vl_vdev_phys.vp_nvlist;\n\t\tbuflen = VDEV_PHYS_SIZE - sizeof (zio_eck_t);\n\t\tif (nvlist_pack(cfg, &buf, &buflen, NV_ENCODE_XDR, 0) != 0) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"error: label %d: Failed to pack nvlist\\n\", l);\n\t\t\treturn;\n\t\t}\n\n\t\tzhack_repair_write_uberblock(vl,\n\t\t    l, ashift, fd, byteswap, label_offset, labels_repaired);\n\t}\n\n\tif (zhack_repair_write_label(l, fd, byteswap, vdev_data, vdev_eck,\n\t    vdev_phys_offset, VDEV_PHYS_SIZE))\n\t\t\tlabels_repaired[l] |= REPAIR_LABEL_STATUS_CKSUM;\n\n\tfsync(fd);\n}\n\nstatic const char *\nzhack_repair_label_status(const uint32_t label_status,\n    const uint32_t to_check)\n{\n\treturn ((label_status & to_check) != 0 ? \"repaired\" : \"skipped\");\n}\n\nstatic int\nzhack_label_repair(const zhack_repair_op_t op, const int argc, char **argv)\n{\n\tuint32_t labels_repaired[VDEV_LABELS] = {0};\n\tvdev_label_t labels[VDEV_LABELS] = {{{0}}};\n\tstruct stat64 st;\n\tint fd;\n\toff_t filesize;\n\tuint32_t repaired = 0;\n\n\tabd_init();\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, \"error: missing device\\n\");\n\t\tusage();\n\t}\n\n\tif ((fd = open(argv[0], O_RDWR)) == -1)\n\t\tfatal(NULL, FTAG, \"cannot open '%s': %s\", argv[0],\n\t\t    strerror(errno));\n\n\tif (fstat64_blk(fd, &st) != 0)\n\t\tfatal(NULL, FTAG, \"cannot stat '%s': %s\", argv[0],\n\t\t    strerror(errno));\n\n\tfilesize = st.st_size;\n\t(void) fprintf(stderr, \"Calculated filesize to be %jd\\n\",\n\t    (intmax_t)filesize);\n\n\tif (filesize % sizeof (vdev_label_t) != 0)\n\t\tfilesize =\n\t\t    (filesize / sizeof (vdev_label_t)) * sizeof (vdev_label_t);\n\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tzhack_repair_one_label(op, fd, &labels[l],\n\t\t    vdev_label_offset(filesize, l, 0), l, labels_repaired);\n\t}\n\n\tclose(fd);\n\n\tabd_fini();\n\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tconst uint32_t lr = labels_repaired[l];\n\t\t(void) printf(\"label %d: \", l);\n\t\t(void) printf(\"uberblock: %s \",\n\t\t    zhack_repair_label_status(lr, REPAIR_LABEL_STATUS_UB));\n\t\t(void) printf(\"checksum: %s\\n\",\n\t\t    zhack_repair_label_status(lr, REPAIR_LABEL_STATUS_CKSUM));\n\t\trepaired |= lr;\n\t}\n\n\tif (repaired > 0)\n\t\treturn (0);\n\n\treturn (1);\n}\n\nstatic int\nzhack_do_label_repair(int argc, char **argv)\n{\n\tzhack_repair_op_t op = ZHACK_REPAIR_OP_UNKNOWN;\n\tint c;\n\n\toptind = 1;\n\twhile ((c = getopt(argc, argv, \"+cu\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\top |= ZHACK_REPAIR_OP_CKSUM;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\top |= ZHACK_REPAIR_OP_UNDETACH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (op == ZHACK_REPAIR_OP_UNKNOWN)\n\t\top = ZHACK_REPAIR_OP_CKSUM;\n\n\treturn (zhack_label_repair(op, argc, argv));\n}\n\nstatic int\nzhack_do_label(int argc, char **argv)\n{\n\tchar *subcommand;\n\tint err;\n\n\targc--;\n\targv++;\n\tif (argc == 0) {\n\t\t(void) fprintf(stderr,\n\t\t    \"error: no label operation specified\\n\");\n\t\tusage();\n\t}\n\n\tsubcommand = argv[0];\n\tif (strcmp(subcommand, \"repair\") == 0) {\n\t\terr = zhack_do_label_repair(argc, argv);\n\t} else {\n\t\t(void) fprintf(stderr, \"error: unknown subcommand: %s\\n\",\n\t\t    subcommand);\n\t\tusage();\n\t}\n\n\treturn (err);\n}\n\n#define\tMAX_NUM_PATHS 1024\n\nint\nmain(int argc, char **argv)\n{\n\tchar *path[MAX_NUM_PATHS];\n\tconst char *subcommand;\n\tint rv = 0;\n\tint c;\n\n\tg_importargs.path = path;\n\n\tdprintf_setup(&argc, argv);\n\tzfs_prop_init();\n\n\twhile ((c = getopt(argc, argv, \"+c:d:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tg_importargs.cachefile = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tassert(g_importargs.paths < MAX_NUM_PATHS);\n\t\t\tg_importargs.path[g_importargs.paths++] = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\toptind = 1;\n\n\tif (argc == 0) {\n\t\t(void) fprintf(stderr, \"error: no command specified\\n\");\n\t\tusage();\n\t}\n\n\tsubcommand = argv[0];\n\n\tif (strcmp(subcommand, \"feature\") == 0) {\n\t\trv = zhack_do_feature(argc, argv);\n\t} else if (strcmp(subcommand, \"label\") == 0) {\n\t\treturn (zhack_do_label(argc, argv));\n\t} else {\n\t\t(void) fprintf(stderr, \"error: unknown subcommand: %s\\n\",\n\t\t    subcommand);\n\t\tusage();\n\t}\n\n\tif (!g_readonly && spa_export(g_pool, NULL, B_TRUE, B_FALSE) != 0) {\n\t\tfatal(NULL, FTAG, \"pool export failed; \"\n\t\t    \"changes may not be committed to disk\\n\");\n\t}\n\n\tkernel_fini();\n\n\treturn (rv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}