{
  "module_name": "fmd_api.c",
  "hash_id": "d7fe8725e3e92e58ef6baa0e2722a3c6f74861dac9432d1a54f1d9e4b7263547",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/agents/fmd_api.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/types.h>\n#include <sys/fm/protocol.h>\n#include <uuid/uuid.h>\n#include <signal.h>\n#include <string.h>\n#include <time.h>\n\n#include \"fmd_api.h\"\n#include \"fmd_serd.h\"\n\n#include \"zfs_agents.h\"\n#include \"../zed_log.h\"\n\ntypedef struct fmd_modstat {\n\tfmd_stat_t\tms_accepted;\t \n\tfmd_stat_t\tms_caseopen;\t \n\tfmd_stat_t\tms_casesolved;\t \n\tfmd_stat_t\tms_caseclosed;\t \n} fmd_modstat_t;\n\ntypedef struct fmd_module {\n\tconst char\t*mod_name;\t \n\tconst fmd_hdl_info_t *mod_info;\t \n\tvoid\t\t*mod_spec;\t \n\tfmd_stat_t\t*mod_ustat;\t \n\tuint_t\t\tmod_ustat_cnt;\t \n\tfmd_modstat_t\tmod_stats;\t \n\tfmd_serd_hash_t\tmod_serds;\t \n\tchar\t\t*mod_vers;\t \n} fmd_module_t;\n\n \nfmd_module_t\tzfs_retire_module;\nfmd_module_t\tzfs_diagnosis_module;\n\n \n\n#ifdef DEBUG\nconst char *\n_umem_debug_init(void)\n{\n\treturn (\"default,verbose\");  \n}\n\nconst char *\n_umem_logging_init(void)\n{\n\treturn (\"fail,contents\");  \n}\n#endif\n\n \nint\nfmd_hdl_register(fmd_hdl_t *hdl, int version, const fmd_hdl_info_t *mip)\n{\n\t(void) version;\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\tmp->mod_info = mip;\n\tmp->mod_name = mip->fmdi_desc + 4;\t \n\tmp->mod_spec = NULL;\n\n\t \n\t(void) strcpy(mp->mod_stats.ms_accepted.fmds_name, \"fmd.accepted\");\n\t(void) strcpy(mp->mod_stats.ms_caseopen.fmds_name, \"fmd.caseopen\");\n\t(void) strcpy(mp->mod_stats.ms_casesolved.fmds_name, \"fmd.casesolved\");\n\t(void) strcpy(mp->mod_stats.ms_caseclosed.fmds_name, \"fmd.caseclosed\");\n\n\tfmd_serd_hash_create(&mp->mod_serds);\n\n\tfmd_hdl_debug(hdl, \"register module\");\n\n\treturn (0);\n}\n\nvoid\nfmd_hdl_unregister(fmd_hdl_t *hdl)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tfmd_modstat_t *msp = &mp->mod_stats;\n\tconst fmd_hdl_ops_t *ops = mp->mod_info->fmdi_ops;\n\n\t \n\tfmd_hdl_debug(hdl, \"%s: %llu\", msp->ms_accepted.fmds_name,\n\t    msp->ms_accepted.fmds_value.ui64);\n\tif (ops->fmdo_close != NULL) {\n\t\tfmd_hdl_debug(hdl, \"%s: %llu\", msp->ms_caseopen.fmds_name,\n\t\t    msp->ms_caseopen.fmds_value.ui64);\n\t\tfmd_hdl_debug(hdl, \"%s: %llu\", msp->ms_casesolved.fmds_name,\n\t\t    msp->ms_casesolved.fmds_value.ui64);\n\t\tfmd_hdl_debug(hdl, \"%s: %llu\", msp->ms_caseclosed.fmds_name,\n\t\t    msp->ms_caseclosed.fmds_value.ui64);\n\t}\n\n\t \n\tif (mp->mod_ustat != NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < mp->mod_ustat_cnt; i++) {\n\t\t\tfmd_hdl_debug(hdl, \"%s: %llu\",\n\t\t\t    mp->mod_ustat[i].fmds_name,\n\t\t\t    mp->mod_ustat[i].fmds_value.ui64);\n\t\t}\n\t}\n\n\tfmd_serd_hash_destroy(&mp->mod_serds);\n\n\tfmd_hdl_debug(hdl, \"unregister module\");\n}\n\n \nvoid\nfmd_hdl_setspecific(fmd_hdl_t *hdl, void *spec)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\tmp->mod_spec = spec;\n}\n\n \nvoid *\nfmd_hdl_getspecific(fmd_hdl_t *hdl)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\treturn (mp->mod_spec);\n}\n\nvoid *\nfmd_hdl_alloc(fmd_hdl_t *hdl, size_t size, int flags)\n{\n\t(void) hdl;\n\treturn (umem_alloc(size, flags));\n}\n\nvoid *\nfmd_hdl_zalloc(fmd_hdl_t *hdl, size_t size, int flags)\n{\n\t(void) hdl;\n\treturn (umem_zalloc(size, flags));\n}\n\nvoid\nfmd_hdl_free(fmd_hdl_t *hdl, void *data, size_t size)\n{\n\t(void) hdl;\n\tumem_free(data, size);\n}\n\n \nvoid\nfmd_hdl_debug(fmd_hdl_t *hdl, const char *format, ...)\n{\n\tchar message[256];\n\tva_list vargs;\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\tva_start(vargs, format);\n\t(void) vsnprintf(message, sizeof (message), format, vargs);\n\tva_end(vargs);\n\n\t \n\tzed_log_msg(LOG_INFO, \"%s: %s\", mp->mod_name, message);\n}\n\n \n\nint32_t\nfmd_prop_get_int32(fmd_hdl_t *hdl, const char *name)\n{\n\t(void) hdl;\n\n\t \n\tif (strcmp(name, \"spare_on_remove\") == 0)\n\t\treturn (1);\n\n\tif (strcmp(name, \"io_N\") == 0 || strcmp(name, \"checksum_N\") == 0)\n\t\treturn (10);\t \n\n\treturn (0);\n}\n\nint64_t\nfmd_prop_get_int64(fmd_hdl_t *hdl, const char *name)\n{\n\t(void) hdl;\n\n\t \n\tif (strcmp(name, \"remove_timeout\") == 0)\n\t\treturn (15ULL * 1000ULL * 1000ULL * 1000ULL);\t \n\n\tif (strcmp(name, \"io_T\") == 0 || strcmp(name, \"checksum_T\") == 0)\n\t\treturn (1000ULL * 1000ULL * 1000ULL * 600ULL);\t \n\n\treturn (0);\n}\n\n \n\nfmd_stat_t *\nfmd_stat_create(fmd_hdl_t *hdl, uint_t flags, uint_t nstats, fmd_stat_t *statv)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\tif (flags == FMD_STAT_NOALLOC) {\n\t\tmp->mod_ustat = statv;\n\t\tmp->mod_ustat_cnt = nstats;\n\t}\n\n\treturn (statv);\n}\n\n \n\nfmd_case_t *\nfmd_case_open(fmd_hdl_t *hdl, void *data)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tuuid_t uuid;\n\n\tfmd_case_t *cp;\n\n\tcp = fmd_hdl_zalloc(hdl, sizeof (fmd_case_t), FMD_SLEEP);\n\tcp->ci_mod = hdl;\n\tcp->ci_state = FMD_CASE_UNSOLVED;\n\tcp->ci_flags = FMD_CF_DIRTY;\n\tcp->ci_data = data;\n\tcp->ci_bufptr = NULL;\n\tcp->ci_bufsiz = 0;\n\n\tuuid_generate(uuid);\n\tuuid_unparse(uuid, cp->ci_uuid);\n\n\tfmd_hdl_debug(hdl, \"case opened (%s)\", cp->ci_uuid);\n\tmp->mod_stats.ms_caseopen.fmds_value.ui64++;\n\n\treturn (cp);\n}\n\nvoid\nfmd_case_solve(fmd_hdl_t *hdl, fmd_case_t *cp)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\t \n\n\tif (cp->ci_state >= FMD_CASE_SOLVED)\n\t\tfmd_hdl_debug(hdl, \"case is already solved or closed\");\n\n\tcp->ci_state = FMD_CASE_SOLVED;\n\n\tfmd_hdl_debug(hdl, \"case solved (%s)\", cp->ci_uuid);\n\tmp->mod_stats.ms_casesolved.fmds_value.ui64++;\n}\n\nvoid\nfmd_case_close(fmd_hdl_t *hdl, fmd_case_t *cp)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tconst fmd_hdl_ops_t *ops = mp->mod_info->fmdi_ops;\n\n\tfmd_hdl_debug(hdl, \"case closed (%s)\", cp->ci_uuid);\n\n\tif (ops->fmdo_close != NULL)\n\t\tops->fmdo_close(hdl, cp);\n\n\tmp->mod_stats.ms_caseopen.fmds_value.ui64--;\n\tmp->mod_stats.ms_caseclosed.fmds_value.ui64++;\n\n\tif (cp->ci_bufptr != NULL && cp->ci_bufsiz > 0)\n\t\tfmd_hdl_free(hdl, cp->ci_bufptr, cp->ci_bufsiz);\n\n\tfmd_hdl_free(hdl, cp, sizeof (fmd_case_t));\n}\n\nvoid\nfmd_case_uuresolved(fmd_hdl_t *hdl, const char *uuid)\n{\n\tfmd_hdl_debug(hdl, \"case resolved by uuid (%s)\", uuid);\n}\n\nboolean_t\nfmd_case_solved(fmd_hdl_t *hdl, fmd_case_t *cp)\n{\n\t(void) hdl;\n\treturn (cp->ci_state >= FMD_CASE_SOLVED);\n}\n\nvoid\nfmd_case_add_ereport(fmd_hdl_t *hdl, fmd_case_t *cp, fmd_event_t *ep)\n{\n\t(void) hdl, (void) cp, (void) ep;\n}\n\nstatic void\nzed_log_fault(nvlist_t *nvl, const char *uuid, const char *code)\n{\n\tnvlist_t *rsrc;\n\tconst char *strval;\n\tuint64_t guid;\n\tuint8_t byte;\n\n\tzed_log_msg(LOG_INFO, \"\\nzed_fault_event:\");\n\n\tif (uuid != NULL)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", FM_SUSPECT_UUID, uuid);\n\tif (nvlist_lookup_string(nvl, FM_CLASS, &strval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", FM_CLASS, strval);\n\tif (code != NULL)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", FM_SUSPECT_DIAG_CODE, code);\n\tif (nvlist_lookup_uint8(nvl, FM_FAULT_CERTAINTY, &byte) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %hhu\", FM_FAULT_CERTAINTY, byte);\n\tif (nvlist_lookup_nvlist(nvl, FM_FAULT_RESOURCE, &rsrc) == 0) {\n\t\tif (nvlist_lookup_string(rsrc, FM_FMRI_SCHEME, &strval) == 0)\n\t\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", FM_FMRI_SCHEME,\n\t\t\t    strval);\n\t\tif (nvlist_lookup_uint64(rsrc, FM_FMRI_ZFS_POOL, &guid) == 0)\n\t\t\tzed_log_msg(LOG_INFO, \"\\t%s: %llu\", FM_FMRI_ZFS_POOL,\n\t\t\t    guid);\n\t\tif (nvlist_lookup_uint64(rsrc, FM_FMRI_ZFS_VDEV, &guid) == 0)\n\t\t\tzed_log_msg(LOG_INFO, \"\\t%s: %llu \\n\", FM_FMRI_ZFS_VDEV,\n\t\t\t    guid);\n\t}\n}\n\nstatic const char *\nfmd_fault_mkcode(nvlist_t *fault)\n{\n\tconst char *class;\n\tconst char *code = \"-\";\n\n\t \n\tif (nvlist_lookup_string(fault, FM_CLASS, &class) == 0) {\n\t\tif (strcmp(class, \"fault.fs.zfs.vdev.io\") == 0)\n\t\t\tcode = \"ZFS-8000-FD\";\n\t\telse if (strcmp(class, \"fault.fs.zfs.vdev.checksum\") == 0)\n\t\t\tcode = \"ZFS-8000-GH\";\n\t\telse if (strcmp(class, \"fault.fs.zfs.io_failure_wait\") == 0)\n\t\t\tcode = \"ZFS-8000-HC\";\n\t\telse if (strcmp(class, \"fault.fs.zfs.io_failure_continue\") == 0)\n\t\t\tcode = \"ZFS-8000-JQ\";\n\t\telse if (strcmp(class, \"fault.fs.zfs.log_replay\") == 0)\n\t\t\tcode = \"ZFS-8000-K4\";\n\t\telse if (strcmp(class, \"fault.fs.zfs.pool\") == 0)\n\t\t\tcode = \"ZFS-8000-CS\";\n\t\telse if (strcmp(class, \"fault.fs.zfs.device\") == 0)\n\t\t\tcode = \"ZFS-8000-D3\";\n\n\t}\n\treturn (code);\n}\n\nvoid\nfmd_case_add_suspect(fmd_hdl_t *hdl, fmd_case_t *cp, nvlist_t *fault)\n{\n\tnvlist_t *nvl;\n\tconst char *code = fmd_fault_mkcode(fault);\n\tint64_t tod[2];\n\tint err = 0;\n\n\t \n\n\t(void) gettimeofday(&cp->ci_tv, NULL);\n\ttod[0] = cp->ci_tv.tv_sec;\n\ttod[1] = cp->ci_tv.tv_usec;\n\n\tnvl = fmd_nvl_alloc(hdl, FMD_SLEEP);\n\n\terr |= nvlist_add_uint8(nvl, FM_VERSION, FM_SUSPECT_VERSION);\n\terr |= nvlist_add_string(nvl, FM_CLASS, FM_LIST_SUSPECT_CLASS);\n\terr |= nvlist_add_string(nvl, FM_SUSPECT_UUID, cp->ci_uuid);\n\terr |= nvlist_add_string(nvl, FM_SUSPECT_DIAG_CODE, code);\n\terr |= nvlist_add_int64_array(nvl, FM_SUSPECT_DIAG_TIME, tod, 2);\n\terr |= nvlist_add_uint32(nvl, FM_SUSPECT_FAULT_SZ, 1);\n\terr |= nvlist_add_nvlist_array(nvl, FM_SUSPECT_FAULT_LIST,\n\t    (const nvlist_t **)&fault, 1);\n\n\tif (err)\n\t\tzed_log_die(\"failed to populate nvlist\");\n\n\tzed_log_fault(fault, cp->ci_uuid, code);\n\tzfs_agent_post_event(FM_LIST_SUSPECT_CLASS, NULL, nvl);\n\n\tnvlist_free(nvl);\n\tnvlist_free(fault);\n}\n\nvoid\nfmd_case_setspecific(fmd_hdl_t *hdl, fmd_case_t *cp, void *data)\n{\n\t(void) hdl;\n\tcp->ci_data = data;\n}\n\nvoid *\nfmd_case_getspecific(fmd_hdl_t *hdl, fmd_case_t *cp)\n{\n\t(void) hdl;\n\treturn (cp->ci_data);\n}\n\nvoid\nfmd_buf_create(fmd_hdl_t *hdl, fmd_case_t *cp, const char *name, size_t size)\n{\n\tassert(strcmp(name, \"data\") == 0), (void) name;\n\tassert(cp->ci_bufptr == NULL);\n\tassert(size < (1024 * 1024));\n\n\tcp->ci_bufptr = fmd_hdl_alloc(hdl, size, FMD_SLEEP);\n\tcp->ci_bufsiz = size;\n}\n\nvoid\nfmd_buf_read(fmd_hdl_t *hdl, fmd_case_t *cp,\n    const char *name, void *buf, size_t size)\n{\n\t(void) hdl;\n\tassert(strcmp(name, \"data\") == 0), (void) name;\n\tassert(cp->ci_bufptr != NULL);\n\tassert(size <= cp->ci_bufsiz);\n\n\tmemcpy(buf, cp->ci_bufptr, size);\n}\n\nvoid\nfmd_buf_write(fmd_hdl_t *hdl, fmd_case_t *cp,\n    const char *name, const void *buf, size_t size)\n{\n\t(void) hdl;\n\tassert(strcmp(name, \"data\") == 0), (void) name;\n\tassert(cp->ci_bufptr != NULL);\n\tassert(cp->ci_bufsiz >= size);\n\n\tmemcpy(cp->ci_bufptr, buf, size);\n}\n\n \n\nvoid\nfmd_serd_create(fmd_hdl_t *hdl, const char *name, uint_t n, hrtime_t t)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\tif (fmd_serd_eng_lookup(&mp->mod_serds, name) != NULL) {\n\t\tzed_log_msg(LOG_ERR, \"failed to create SERD engine '%s': \"\n\t\t    \" name already exists\", name);\n\t\treturn;\n\t}\n\n\t(void) fmd_serd_eng_insert(&mp->mod_serds, name, n, t);\n}\n\nvoid\nfmd_serd_destroy(fmd_hdl_t *hdl, const char *name)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\tfmd_serd_eng_delete(&mp->mod_serds, name);\n\n\tfmd_hdl_debug(hdl, \"serd_destroy %s\", name);\n}\n\nint\nfmd_serd_exists(fmd_hdl_t *hdl, const char *name)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\treturn (fmd_serd_eng_lookup(&mp->mod_serds, name) != NULL);\n}\n\nvoid\nfmd_serd_reset(fmd_hdl_t *hdl, const char *name)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tfmd_serd_eng_t *sgp;\n\n\tif ((sgp = fmd_serd_eng_lookup(&mp->mod_serds, name)) == NULL) {\n\t\tzed_log_msg(LOG_ERR, \"serd engine '%s' does not exist\", name);\n\t\treturn;\n\t}\n\n\tfmd_serd_eng_reset(sgp);\n\n\tfmd_hdl_debug(hdl, \"serd_reset %s\", name);\n}\n\nint\nfmd_serd_record(fmd_hdl_t *hdl, const char *name, fmd_event_t *ep)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tfmd_serd_eng_t *sgp;\n\tint err;\n\n\tif ((sgp = fmd_serd_eng_lookup(&mp->mod_serds, name)) == NULL) {\n\t\tzed_log_msg(LOG_ERR, \"failed to add record to SERD engine '%s'\",\n\t\t    name);\n\t\treturn (0);\n\t}\n\terr = fmd_serd_eng_record(sgp, ep->ev_hrt);\n\n\treturn (err);\n}\n\n \n\nstatic void\n_timer_notify(union sigval sv)\n{\n\tfmd_timer_t *ftp = sv.sival_ptr;\n\tfmd_hdl_t *hdl = ftp->ft_hdl;\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tconst fmd_hdl_ops_t *ops = mp->mod_info->fmdi_ops;\n\tstruct itimerspec its;\n\n\tfmd_hdl_debug(hdl, \"timer fired (%p)\", ftp->ft_tid);\n\n\t \n\tmemset(&its, 0, sizeof (struct itimerspec));\n\ttimer_settime(ftp->ft_tid, 0, &its, NULL);\n\n\t \n\tif (ops->fmdo_timeout != NULL)\n\t\tops->fmdo_timeout(hdl, ftp, ftp->ft_arg);\n}\n\n \nfmd_timer_t *\nfmd_timer_install(fmd_hdl_t *hdl, void *arg, fmd_event_t *ep, hrtime_t delta)\n{\n\t(void) ep;\n\tstruct sigevent sev;\n\tstruct itimerspec its;\n\tfmd_timer_t *ftp;\n\n\tftp = fmd_hdl_alloc(hdl, sizeof (fmd_timer_t), FMD_SLEEP);\n\tftp->ft_arg = arg;\n\tftp->ft_hdl = hdl;\n\n\tits.it_value.tv_sec = delta / 1000000000;\n\tits.it_value.tv_nsec = delta % 1000000000;\n\tits.it_interval.tv_sec = its.it_value.tv_sec;\n\tits.it_interval.tv_nsec = its.it_value.tv_nsec;\n\n\tsev.sigev_notify = SIGEV_THREAD;\n\tsev.sigev_notify_function = _timer_notify;\n\tsev.sigev_notify_attributes = NULL;\n\tsev.sigev_value.sival_ptr = ftp;\n\tsev.sigev_signo = 0;\n\n\ttimer_create(CLOCK_REALTIME, &sev, &ftp->ft_tid);\n\ttimer_settime(ftp->ft_tid, 0, &its, NULL);\n\n\tfmd_hdl_debug(hdl, \"installing timer for %d secs (%p)\",\n\t    (int)its.it_value.tv_sec, ftp->ft_tid);\n\n\treturn (ftp);\n}\n\nvoid\nfmd_timer_remove(fmd_hdl_t *hdl, fmd_timer_t *ftp)\n{\n\tfmd_hdl_debug(hdl, \"removing timer (%p)\", ftp->ft_tid);\n\n\ttimer_delete(ftp->ft_tid);\n\n\tfmd_hdl_free(hdl, ftp, sizeof (fmd_timer_t));\n}\n\n \n\nnvlist_t *\nfmd_nvl_create_fault(fmd_hdl_t *hdl, const char *class, uint8_t certainty,\n    nvlist_t *asru, nvlist_t *fru, nvlist_t *resource)\n{\n\t(void) hdl;\n\tnvlist_t *nvl;\n\tint err = 0;\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\tzed_log_die(\"failed to xalloc fault nvlist\");\n\n\terr |= nvlist_add_uint8(nvl, FM_VERSION, FM_FAULT_VERSION);\n\terr |= nvlist_add_string(nvl, FM_CLASS, class);\n\terr |= nvlist_add_uint8(nvl, FM_FAULT_CERTAINTY, certainty);\n\n\tif (asru != NULL)\n\t\terr |= nvlist_add_nvlist(nvl, FM_FAULT_ASRU, asru);\n\tif (fru != NULL)\n\t\terr |= nvlist_add_nvlist(nvl, FM_FAULT_FRU, fru);\n\tif (resource != NULL)\n\t\terr |= nvlist_add_nvlist(nvl, FM_FAULT_RESOURCE, resource);\n\n\tif (err)\n\t\tzed_log_die(\"failed to populate nvlist: %s\\n\", strerror(err));\n\n\treturn (nvl);\n}\n\n \nstatic int\nfmd_strmatch(const char *s, const char *p)\n{\n\tchar c;\n\n\tif (p == NULL)\n\t\treturn (0);\n\n\tif (s == NULL)\n\t\ts = \"\";  \n\n\tdo {\n\t\tif ((c = *p++) == '\\0')\n\t\t\treturn (*s == '\\0');\n\n\t\tif (c == '*') {\n\t\t\twhile (*p == '*')\n\t\t\t\tp++;  \n\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn (1);\n\n\t\t\twhile (*s != '\\0') {\n\t\t\t\tif (fmd_strmatch(s++, p) != 0)\n\t\t\t\t\treturn (1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t} while (c == *s++);\n\n\treturn (0);\n}\n\nint\nfmd_nvl_class_match(fmd_hdl_t *hdl, nvlist_t *nvl, const char *pattern)\n{\n\t(void) hdl;\n\tconst char *class;\n\n\treturn (nvl != NULL &&\n\t    nvlist_lookup_string(nvl, FM_CLASS, &class) == 0 &&\n\t    fmd_strmatch(class, pattern));\n}\n\nnvlist_t *\nfmd_nvl_alloc(fmd_hdl_t *hdl, int flags)\n{\n\t(void) hdl, (void) flags;\n\tnvlist_t *nvl = NULL;\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (NULL);\n\n\treturn (nvl);\n}\n\n\n \n\nfmd_hdl_t *\nfmd_module_hdl(const char *name)\n{\n\tif (strcmp(name, \"zfs-retire\") == 0)\n\t\treturn ((fmd_hdl_t *)&zfs_retire_module);\n\tif (strcmp(name, \"zfs-diagnosis\") == 0)\n\t\treturn ((fmd_hdl_t *)&zfs_diagnosis_module);\n\n\treturn (NULL);\n}\n\nboolean_t\nfmd_module_initialized(fmd_hdl_t *hdl)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\n\treturn (mp->mod_info != NULL);\n}\n\n \nvoid\nfmd_module_recv(fmd_hdl_t *hdl, nvlist_t *nvl, const char *class)\n{\n\tfmd_module_t *mp = (fmd_module_t *)hdl;\n\tconst fmd_hdl_ops_t *ops = mp->mod_info->fmdi_ops;\n\tfmd_event_t faux_event = {0};\n\tint64_t *tv;\n\tuint_t n;\n\n\t \n\tif (nvlist_lookup_int64_array(nvl, FM_EREPORT_TIME, &tv, &n) == 0)\n\t\tfaux_event.ev_hrt = tv[0] * NANOSEC + tv[1];\n\telse\n\t\tfaux_event.ev_hrt = 0;\n\n\tops->fmdo_recv(hdl, &faux_event, nvl, class);\n\n\tmp->mod_stats.ms_accepted.fmds_value.ui64++;\n\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}