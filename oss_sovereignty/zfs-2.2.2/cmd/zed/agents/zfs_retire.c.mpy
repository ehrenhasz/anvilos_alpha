{
  "module_name": "zfs_retire.c",
  "hash_id": "3bed5fe28b0a3b0a2cd4a776dcd86103f42f7856dee1ccce87e0aca2e5a09d40",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/agents/zfs_retire.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/fs/zfs.h>\n#include <sys/fm/protocol.h>\n#include <sys/fm/fs/zfs.h>\n#include <libzutil.h>\n#include <libzfs.h>\n#include <string.h>\n#include <libgen.h>\n\n#include \"zfs_agents.h\"\n#include \"fmd_api.h\"\n\n\ntypedef struct zfs_retire_repaired {\n\tstruct zfs_retire_repaired\t*zrr_next;\n\tuint64_t\t\t\tzrr_pool;\n\tuint64_t\t\t\tzrr_vdev;\n} zfs_retire_repaired_t;\n\ntypedef struct zfs_retire_data {\n\tlibzfs_handle_t\t\t\t*zrd_hdl;\n\tzfs_retire_repaired_t\t\t*zrd_repaired;\n} zfs_retire_data_t;\n\nstatic void\nzfs_retire_clear_data(fmd_hdl_t *hdl, zfs_retire_data_t *zdp)\n{\n\tzfs_retire_repaired_t *zrp;\n\n\twhile ((zrp = zdp->zrd_repaired) != NULL) {\n\t\tzdp->zrd_repaired = zrp->zrr_next;\n\t\tfmd_hdl_free(hdl, zrp, sizeof (zfs_retire_repaired_t));\n\t}\n}\n\n \ntypedef struct find_cbdata {\n\tuint64_t\tcb_guid;\n\tzpool_handle_t\t*cb_zhp;\n\tnvlist_t\t*cb_vdev;\n\tuint64_t\tcb_vdev_guid;\n\tuint64_t\tcb_num_spares;\n} find_cbdata_t;\n\nstatic int\nfind_pool(zpool_handle_t *zhp, void *data)\n{\n\tfind_cbdata_t *cbp = data;\n\n\tif (cbp->cb_guid ==\n\t    zpool_get_prop_int(zhp, ZPOOL_PROP_GUID, NULL)) {\n\t\tcbp->cb_zhp = zhp;\n\t\treturn (1);\n\t}\n\n\tzpool_close(zhp);\n\treturn (0);\n}\n\n \nstatic nvlist_t *\nfind_vdev(libzfs_handle_t *zhdl, nvlist_t *nv, uint64_t search_guid)\n{\n\tuint64_t guid;\n\tnvlist_t **child;\n\tuint_t c, children;\n\tnvlist_t *ret;\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) == 0 &&\n\t    guid == search_guid) {\n\t\tfmd_hdl_debug(fmd_module_hdl(\"zfs-retire\"),\n\t\t    \"matched vdev %llu\", guid);\n\t\treturn (nv);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0)\n\t\treturn (NULL);\n\n\tfor (c = 0; c < children; c++) {\n\t\tif ((ret = find_vdev(zhdl, child[c], search_guid)) != NULL)\n\t\t\treturn (ret);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) != 0)\n\t\treturn (NULL);\n\n\tfor (c = 0; c < children; c++) {\n\t\tif ((ret = find_vdev(zhdl, child[c], search_guid)) != NULL)\n\t\t\treturn (ret);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) != 0)\n\t\treturn (NULL);\n\n\tfor (c = 0; c < children; c++) {\n\t\tif ((ret = find_vdev(zhdl, child[c], search_guid)) != NULL)\n\t\t\treturn (ret);\n\t}\n\n\treturn (NULL);\n}\n\nstatic int\nremove_spares(zpool_handle_t *zhp, void *data)\n{\n\tnvlist_t *config, *nvroot;\n\tnvlist_t **spares;\n\tuint_t nspares;\n\tchar *devname;\n\tfind_cbdata_t *cbp = data;\n\tuint64_t spareguid = 0;\n\tvdev_stat_t *vs;\n\tunsigned int c;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tif (nvlist_lookup_nvlist(config,\n\t    ZPOOL_CONFIG_VDEV_TREE, &nvroot) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t    &spares, &nspares) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (0);\n\t}\n\n\tfor (int i = 0; i < nspares; i++) {\n\t\tif (nvlist_lookup_uint64(spares[i], ZPOOL_CONFIG_GUID,\n\t\t    &spareguid) == 0 && spareguid == cbp->cb_vdev_guid) {\n\t\t\tdevname = zpool_vdev_name(NULL, zhp, spares[i],\n\t\t\t    B_FALSE);\n\t\t\tnvlist_lookup_uint64_array(spares[i],\n\t\t\t    ZPOOL_CONFIG_VDEV_STATS, (uint64_t **)&vs, &c);\n\t\t\tif (vs->vs_state != VDEV_STATE_REMOVED &&\n\t\t\t    zpool_vdev_remove_wanted(zhp, devname) == 0)\n\t\t\t\tcbp->cb_num_spares++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\treturn (0);\n}\n\n \nstatic int\nfind_and_remove_spares(libzfs_handle_t *zhdl, uint64_t vdev_guid)\n{\n\tfind_cbdata_t cb;\n\n\tcb.cb_num_spares = 0;\n\tcb.cb_vdev_guid = vdev_guid;\n\tzpool_iter(zhdl, remove_spares, &cb);\n\n\treturn (cb.cb_num_spares);\n}\n\n \nstatic zpool_handle_t *\nfind_by_guid(libzfs_handle_t *zhdl, uint64_t pool_guid, uint64_t vdev_guid,\n    nvlist_t **vdevp)\n{\n\tfind_cbdata_t cb;\n\tzpool_handle_t *zhp;\n\tnvlist_t *config, *nvroot;\n\n\t \n\tcb.cb_guid = pool_guid;\n\tif (zpool_iter(zhdl, find_pool, &cb) != 1)\n\t\treturn (NULL);\n\n\tzhp = cb.cb_zhp;\n\tconfig = zpool_get_config(zhp, NULL);\n\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (NULL);\n\t}\n\n\tif (vdev_guid != 0) {\n\t\tif ((*vdevp = find_vdev(zhdl, nvroot, vdev_guid)) == NULL) {\n\t\t\tzpool_close(zhp);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\treturn (zhp);\n}\n\n \nstatic boolean_t\nreplace_with_spare(fmd_hdl_t *hdl, zpool_handle_t *zhp, nvlist_t *vdev)\n{\n\tnvlist_t *config, *nvroot, *replacement;\n\tnvlist_t **spares;\n\tuint_t s, nspares;\n\tchar *dev_name;\n\tzprop_source_t source;\n\tint ashift;\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t    &nvroot) != 0)\n\t\treturn (B_FALSE);\n\n\t \n\tif (nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t    &spares, &nspares) != 0)\n\t\treturn (B_FALSE);\n\n\t \n\tashift = zpool_get_prop_int(zhp, ZPOOL_PROP_ASHIFT, &source);\n\n\treplacement = fmd_nvl_alloc(hdl, FMD_SLEEP);\n\n\t(void) nvlist_add_string(replacement, ZPOOL_CONFIG_TYPE,\n\t    VDEV_TYPE_ROOT);\n\n\tdev_name = zpool_vdev_name(NULL, zhp, vdev, B_FALSE);\n\n\t \n\tfor (s = 0; s < nspares; s++) {\n\t\tboolean_t rebuild = B_FALSE;\n\t\tconst char *spare_name, *type;\n\n\t\tif (nvlist_lookup_string(spares[s], ZPOOL_CONFIG_PATH,\n\t\t    &spare_name) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((nvlist_lookup_string(spares[s], ZPOOL_CONFIG_TYPE,\n\t\t    &type) == 0) && strcmp(type, VDEV_TYPE_DRAID_SPARE) == 0)\n\t\t\trebuild = B_TRUE;\n\n\t\t \n\t\tif (source != ZPROP_SRC_DEFAULT)\n\t\t\t(void) nvlist_add_uint64(spares[s],\n\t\t\t    ZPOOL_CONFIG_ASHIFT, ashift);\n\n\t\t(void) nvlist_add_nvlist_array(replacement,\n\t\t    ZPOOL_CONFIG_CHILDREN, (const nvlist_t **)&spares[s], 1);\n\n\t\tfmd_hdl_debug(hdl, \"zpool_vdev_replace '%s' with spare '%s'\",\n\t\t    dev_name, zfs_basename(spare_name));\n\n\t\tif (zpool_vdev_attach(zhp, dev_name, spare_name,\n\t\t    replacement, B_TRUE, rebuild) == 0) {\n\t\t\tfree(dev_name);\n\t\t\tnvlist_free(replacement);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tfree(dev_name);\n\tnvlist_free(replacement);\n\n\treturn (B_FALSE);\n}\n\n \nstatic void\nzfs_vdev_repair(fmd_hdl_t *hdl, nvlist_t *nvl)\n{\n\tzfs_retire_data_t *zdp = fmd_hdl_getspecific(hdl);\n\tzfs_retire_repaired_t *zrp;\n\tuint64_t pool_guid, vdev_guid;\n\tif (nvlist_lookup_uint64(nvl, FM_EREPORT_PAYLOAD_ZFS_POOL_GUID,\n\t    &pool_guid) != 0 || nvlist_lookup_uint64(nvl,\n\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID, &vdev_guid) != 0)\n\t\treturn;\n\n\t \n\tfor (zrp = zdp->zrd_repaired; zrp != NULL; zrp = zrp->zrr_next) {\n\t\tif (zrp->zrr_pool == pool_guid &&\n\t\t    zrp->zrr_vdev == vdev_guid)\n\t\t\treturn;\n\t}\n\n\tzrp = fmd_hdl_alloc(hdl, sizeof (zfs_retire_repaired_t), FMD_SLEEP);\n\tzrp->zrr_next = zdp->zrd_repaired;\n\tzrp->zrr_pool = pool_guid;\n\tzrp->zrr_vdev = vdev_guid;\n\tzdp->zrd_repaired = zrp;\n\n\tfmd_hdl_debug(hdl, \"marking repaired vdev %llu on pool %llu\",\n\t    vdev_guid, pool_guid);\n}\n\nstatic void\nzfs_retire_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl,\n    const char *class)\n{\n\t(void) ep;\n\tuint64_t pool_guid, vdev_guid;\n\tzpool_handle_t *zhp;\n\tnvlist_t *resource, *fault;\n\tnvlist_t **faults;\n\tuint_t f, nfaults;\n\tzfs_retire_data_t *zdp = fmd_hdl_getspecific(hdl);\n\tlibzfs_handle_t *zhdl = zdp->zrd_hdl;\n\tboolean_t fault_device, degrade_device;\n\tboolean_t is_repair;\n\tboolean_t l2arc = B_FALSE;\n\tboolean_t spare = B_FALSE;\n\tconst char *scheme;\n\tnvlist_t *vdev = NULL;\n\tconst char *uuid;\n\tint repair_done = 0;\n\tboolean_t retire;\n\tboolean_t is_disk;\n\tvdev_aux_t aux;\n\tuint64_t state = 0;\n\tvdev_stat_t *vs;\n\tunsigned int c;\n\n\tfmd_hdl_debug(hdl, \"zfs_retire_recv: '%s'\", class);\n\n\t(void) nvlist_lookup_uint64(nvl, FM_EREPORT_PAYLOAD_ZFS_VDEV_STATE,\n\t    &state);\n\n\t \n\tif (strcmp(class, \"resource.fs.zfs.removed\") == 0 ||\n\t    (strcmp(class, \"resource.fs.zfs.statechange\") == 0 &&\n\t    (state == VDEV_STATE_REMOVED || state == VDEV_STATE_FAULTED))) {\n\t\tconst char *devtype;\n\t\tchar *devname;\n\n\t\tif (nvlist_lookup_string(nvl, FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE,\n\t\t    &devtype) == 0) {\n\t\t\tif (strcmp(devtype, VDEV_TYPE_SPARE) == 0)\n\t\t\t\tspare = B_TRUE;\n\t\t\telse if (strcmp(devtype, VDEV_TYPE_L2CACHE) == 0)\n\t\t\t\tl2arc = B_TRUE;\n\t\t}\n\n\t\tif (nvlist_lookup_uint64(nvl,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID, &vdev_guid) != 0)\n\t\t\treturn;\n\n\t\tif (vdev_guid == 0) {\n\t\t\tfmd_hdl_debug(hdl, \"Got a zero GUID\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (spare) {\n\t\t\tint nspares = find_and_remove_spares(zhdl, vdev_guid);\n\t\t\tfmd_hdl_debug(hdl, \"%d spares removed\", nspares);\n\t\t\treturn;\n\t\t}\n\n\t\tif (nvlist_lookup_uint64(nvl, FM_EREPORT_PAYLOAD_ZFS_POOL_GUID,\n\t\t    &pool_guid) != 0)\n\t\t\treturn;\n\n\t\tif ((zhp = find_by_guid(zhdl, pool_guid, vdev_guid,\n\t\t    &vdev)) == NULL)\n\t\t\treturn;\n\n\t\tdevname = zpool_vdev_name(NULL, zhp, vdev, B_FALSE);\n\n\t\tnvlist_lookup_uint64_array(vdev, ZPOOL_CONFIG_VDEV_STATS,\n\t\t    (uint64_t **)&vs, &c);\n\n\t\t \n\t\tif (vs->vs_state == VDEV_STATE_REMOVED &&\n\t\t    state == VDEV_STATE_REMOVED)\n\t\t\treturn;\n\n\t\t \n\t\tint remove_status = 0;\n\t\tif (l2arc || (strcmp(class, \"resource.fs.zfs.removed\") == 0)) {\n\t\t\tremove_status = zpool_vdev_remove_wanted(zhp, devname);\n\t\t\tfmd_hdl_debug(hdl, \"zpool_vdev_remove_wanted '%s'\"\n\t\t\t    \", err:%d\", devname, libzfs_errno(zhdl));\n\t\t}\n\n\t\t \n\t\tif (!l2arc && !remove_status &&\n\t\t    (!fmd_prop_get_int32(hdl, \"spare_on_remove\") ||\n\t\t    replace_with_spare(hdl, zhp, vdev) == B_FALSE)) {\n\t\t\t \n\t\t\tfmd_hdl_debug(hdl, \"no spare for '%s'\", devname);\n\t\t}\n\n\t\tfree(devname);\n\t\tzpool_close(zhp);\n\t\treturn;\n\t}\n\n\tif (strcmp(class, FM_LIST_RESOLVED_CLASS) == 0)\n\t\treturn;\n\n\t \n\tif (strcmp(class, \"resource.fs.zfs.statechange\") == 0 &&\n\t    state == VDEV_STATE_HEALTHY) {\n\t\tzfs_vdev_repair(hdl, nvl);\n\t\treturn;\n\t}\n\tif (strcmp(class, \"sysevent.fs.zfs.vdev_remove\") == 0) {\n\t\tzfs_vdev_repair(hdl, nvl);\n\t\treturn;\n\t}\n\n\tzfs_retire_clear_data(hdl, zdp);\n\n\tif (strcmp(class, FM_LIST_REPAIRED_CLASS) == 0)\n\t\tis_repair = B_TRUE;\n\telse\n\t\tis_repair = B_FALSE;\n\n\t \n\tif (nvlist_lookup_nvlist_array(nvl, FM_SUSPECT_FAULT_LIST,\n\t    &faults, &nfaults) != 0)\n\t\treturn;\n\n\tfor (f = 0; f < nfaults; f++) {\n\t\tfault = faults[f];\n\n\t\tfault_device = B_FALSE;\n\t\tdegrade_device = B_FALSE;\n\t\tis_disk = B_FALSE;\n\n\t\tif (nvlist_lookup_boolean_value(fault, FM_SUSPECT_RETIRE,\n\t\t    &retire) == 0 && retire == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fmd_nvl_class_match(hdl, fault, \"fault.fs.zfs.vdev.io\")) {\n\t\t\tfault_device = B_TRUE;\n\t\t} else if (fmd_nvl_class_match(hdl, fault,\n\t\t    \"fault.fs.zfs.vdev.checksum\")) {\n\t\t\tdegrade_device = B_TRUE;\n\t\t} else if (fmd_nvl_class_match(hdl, fault,\n\t\t    \"fault.fs.zfs.device\")) {\n\t\t\tfault_device = B_FALSE;\n\t\t} else if (fmd_nvl_class_match(hdl, fault, \"fault.io.*\")) {\n\t\t\tis_disk = B_TRUE;\n\t\t\tfault_device = B_TRUE;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_disk) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (nvlist_lookup_nvlist(fault, FM_FAULT_RESOURCE,\n\t\t\t    &resource) != 0 ||\n\t\t\t    nvlist_lookup_string(resource, FM_FMRI_SCHEME,\n\t\t\t    &scheme) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(scheme, FM_FMRI_SCHEME_ZFS) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (nvlist_lookup_uint64(resource, FM_FMRI_ZFS_POOL,\n\t\t\t    &pool_guid) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (nvlist_lookup_uint64(resource, FM_FMRI_ZFS_VDEV,\n\t\t\t    &vdev_guid) != 0) {\n\t\t\t\tif (is_repair)\n\t\t\t\t\tvdev_guid = 0;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((zhp = find_by_guid(zhdl, pool_guid, vdev_guid,\n\t\t\t    &vdev)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\taux = VDEV_AUX_ERR_EXCEEDED;\n\t\t}\n\n\t\tif (vdev_guid == 0) {\n\t\t\t \n\t\t\tfmd_hdl_debug(hdl, \"zpool_clear of pool '%s'\",\n\t\t\t    zpool_get_name(zhp));\n\t\t\t(void) zpool_clear(zhp, NULL, NULL);\n\t\t\tzpool_close(zhp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (is_repair) {\n\t\t\trepair_done = 1;\n\t\t\tfmd_hdl_debug(hdl, \"zpool_clear of pool '%s' vdev %llu\",\n\t\t\t    zpool_get_name(zhp), vdev_guid);\n\t\t\t(void) zpool_vdev_clear(zhp, vdev_guid);\n\t\t\tzpool_close(zhp);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (fault_device)\n\t\t\t(void) zpool_vdev_fault(zhp, vdev_guid, aux);\n\t\tif (degrade_device)\n\t\t\t(void) zpool_vdev_degrade(zhp, vdev_guid, aux);\n\n\t\tif (fault_device || degrade_device)\n\t\t\tfmd_hdl_debug(hdl, \"zpool_vdev_%s: vdev %llu on '%s'\",\n\t\t\t    fault_device ? \"fault\" : \"degrade\", vdev_guid,\n\t\t\t    zpool_get_name(zhp));\n\n\t\t \n\t\t(void) replace_with_spare(hdl, zhp, vdev);\n\n\t\tzpool_close(zhp);\n\t}\n\n\tif (strcmp(class, FM_LIST_REPAIRED_CLASS) == 0 && repair_done &&\n\t    nvlist_lookup_string(nvl, FM_SUSPECT_UUID, &uuid) == 0)\n\t\tfmd_case_uuresolved(hdl, uuid);\n}\n\nstatic const fmd_hdl_ops_t fmd_ops = {\n\tzfs_retire_recv,\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n};\n\nstatic const fmd_prop_t fmd_props[] = {\n\t{ \"spare_on_remove\", FMD_TYPE_BOOL, \"true\" },\n\t{ NULL, 0, NULL }\n};\n\nstatic const fmd_hdl_info_t fmd_info = {\n\t\"ZFS Retire Agent\", \"1.0\", &fmd_ops, fmd_props\n};\n\nvoid\n_zfs_retire_init(fmd_hdl_t *hdl)\n{\n\tzfs_retire_data_t *zdp;\n\tlibzfs_handle_t *zhdl;\n\n\tif ((zhdl = libzfs_init()) == NULL)\n\t\treturn;\n\n\tif (fmd_hdl_register(hdl, FMD_API_VERSION, &fmd_info) != 0) {\n\t\tlibzfs_fini(zhdl);\n\t\treturn;\n\t}\n\n\tzdp = fmd_hdl_zalloc(hdl, sizeof (zfs_retire_data_t), FMD_SLEEP);\n\tzdp->zrd_hdl = zhdl;\n\n\tfmd_hdl_setspecific(hdl, zdp);\n}\n\nvoid\n_zfs_retire_fini(fmd_hdl_t *hdl)\n{\n\tzfs_retire_data_t *zdp = fmd_hdl_getspecific(hdl);\n\n\tif (zdp != NULL) {\n\t\tzfs_retire_clear_data(hdl, zdp);\n\t\tlibzfs_fini(zdp->zrd_hdl);\n\t\tfmd_hdl_free(hdl, zdp, sizeof (zfs_retire_data_t));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}