{
  "module_name": "fmd_serd.c",
  "hash_id": "0677b828c1608f344f7b1c30bb7ff8b3b7a56527171ee41bffa91ada23f67a38",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/agents/fmd_serd.c",
  "human_readable_source": " \n \n\n#include <assert.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/list.h>\n#include <sys/time.h>\n\n#include \"fmd_api.h\"\n#include \"fmd_serd.h\"\n#include \"../zed_log.h\"\n\n\n#define\tFMD_STR_BUCKETS\t\t211\n\n\n#ifdef SERD_ENG_DEBUG\n#define\tserd_log_msg(fmt, ...) \\\n\tzed_log_msg(LOG_INFO, fmt, __VA_ARGS__)\n#else\n#define\tserd_log_msg(fmt, ...)\n#endif\n\n\n \n\n \nstatic hrtime_t\nfmd_event_delta(hrtime_t t1, hrtime_t t2)\n{\n\tuint64_t old = t1;\n\tuint64_t new = t2;\n\n\treturn (new >= old ? new - old : (UINT64_MAX - old) + new + 1);\n}\n\nstatic fmd_serd_eng_t *\nfmd_serd_eng_alloc(const char *name, uint64_t n, hrtime_t t)\n{\n\tfmd_serd_eng_t *sgp;\n\n\tsgp = malloc(sizeof (fmd_serd_eng_t));\n\tif (sgp == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tmemset(sgp, 0, sizeof (fmd_serd_eng_t));\n\n\tsgp->sg_name = strdup(name);\n\tif (sgp->sg_name == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsgp->sg_flags = FMD_SERD_DIRTY;\n\tsgp->sg_n = n;\n\tsgp->sg_t = t;\n\n\tlist_create(&sgp->sg_list, sizeof (fmd_serd_elem_t),\n\t    offsetof(fmd_serd_elem_t, se_list));\n\n\treturn (sgp);\n}\n\nstatic void\nfmd_serd_eng_free(fmd_serd_eng_t *sgp)\n{\n\tfmd_serd_eng_reset(sgp);\n\tfree(sgp->sg_name);\n\tlist_destroy(&sgp->sg_list);\n\tfree(sgp);\n}\n\n \nstatic ulong_t\nfmd_strhash(const char *key)\n{\n\tulong_t g, h = 0;\n\tconst char *p;\n\n\tfor (p = key; *p != '\\0'; p++) {\n\t\th = (h << 4) + *p;\n\n\t\tif ((g = (h & 0xf0000000)) != 0) {\n\t\t\th ^= (g >> 24);\n\t\t\th ^= g;\n\t\t}\n\t}\n\n\treturn (h);\n}\n\nvoid\nfmd_serd_hash_create(fmd_serd_hash_t *shp)\n{\n\tshp->sh_hashlen = FMD_STR_BUCKETS;\n\tshp->sh_hash = calloc(shp->sh_hashlen, sizeof (void *));\n\tshp->sh_count = 0;\n\n\tif (shp->sh_hash == NULL) {\n\t\tperror(\"calloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n}\n\nvoid\nfmd_serd_hash_destroy(fmd_serd_hash_t *shp)\n{\n\tfmd_serd_eng_t *sgp, *ngp;\n\tuint_t i;\n\n\tfor (i = 0; i < shp->sh_hashlen; i++) {\n\t\tfor (sgp = shp->sh_hash[i]; sgp != NULL; sgp = ngp) {\n\t\t\tngp = sgp->sg_next;\n\t\t\tfmd_serd_eng_free(sgp);\n\t\t}\n\t}\n\n\tfree(shp->sh_hash);\n\tmemset(shp, 0, sizeof (fmd_serd_hash_t));\n}\n\nvoid\nfmd_serd_hash_apply(fmd_serd_hash_t *shp, fmd_serd_eng_f *func, void *arg)\n{\n\tfmd_serd_eng_t *sgp;\n\tuint_t i;\n\n\tfor (i = 0; i < shp->sh_hashlen; i++) {\n\t\tfor (sgp = shp->sh_hash[i]; sgp != NULL; sgp = sgp->sg_next)\n\t\t\tfunc(sgp, arg);\n\t}\n}\n\nfmd_serd_eng_t *\nfmd_serd_eng_insert(fmd_serd_hash_t *shp, const char *name,\n    uint_t n, hrtime_t t)\n{\n\tuint_t h = fmd_strhash(name) % shp->sh_hashlen;\n\tfmd_serd_eng_t *sgp = fmd_serd_eng_alloc(name, n, t);\n\n\tserd_log_msg(\"  SERD Engine: inserting  %s N %d T %llu\",\n\t    name, (int)n, (long long unsigned)t);\n\n\tsgp->sg_next = shp->sh_hash[h];\n\tshp->sh_hash[h] = sgp;\n\tshp->sh_count++;\n\n\treturn (sgp);\n}\n\nfmd_serd_eng_t *\nfmd_serd_eng_lookup(fmd_serd_hash_t *shp, const char *name)\n{\n\tuint_t h = fmd_strhash(name) % shp->sh_hashlen;\n\tfmd_serd_eng_t *sgp;\n\n\tfor (sgp = shp->sh_hash[h]; sgp != NULL; sgp = sgp->sg_next) {\n\t\tif (strcmp(name, sgp->sg_name) == 0)\n\t\t\treturn (sgp);\n\t}\n\n\treturn (NULL);\n}\n\nvoid\nfmd_serd_eng_delete(fmd_serd_hash_t *shp, const char *name)\n{\n\tuint_t h = fmd_strhash(name) % shp->sh_hashlen;\n\tfmd_serd_eng_t *sgp, **pp = &shp->sh_hash[h];\n\n\tserd_log_msg(\"  SERD Engine: deleting %s\", name);\n\n\tfor (sgp = *pp; sgp != NULL; sgp = sgp->sg_next) {\n\t\tif (strcmp(sgp->sg_name, name) != 0)\n\t\t\tpp = &sgp->sg_next;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (sgp != NULL) {\n\t\t*pp = sgp->sg_next;\n\t\tfmd_serd_eng_free(sgp);\n\t\tassert(shp->sh_count != 0);\n\t\tshp->sh_count--;\n\t}\n}\n\nstatic void\nfmd_serd_eng_discard(fmd_serd_eng_t *sgp, fmd_serd_elem_t *sep)\n{\n\tlist_remove(&sgp->sg_list, sep);\n\tsgp->sg_count--;\n\n\tserd_log_msg(\"  SERD Engine: discarding %s, %d remaining\",\n\t    sgp->sg_name, (int)sgp->sg_count);\n\n\tfree(sep);\n}\n\nint\nfmd_serd_eng_record(fmd_serd_eng_t *sgp, hrtime_t hrt)\n{\n\tfmd_serd_elem_t *sep, *oep;\n\n\t \n\tif (sgp->sg_flags & FMD_SERD_FIRED) {\n\t\tserd_log_msg(\"  SERD Engine: record %s already fired!\",\n\t\t    sgp->sg_name);\n\t\treturn (B_FALSE);\n\t}\n\n\twhile (sgp->sg_count >= sgp->sg_n)\n\t\tfmd_serd_eng_discard(sgp, list_tail(&sgp->sg_list));\n\n\tsep = malloc(sizeof (fmd_serd_elem_t));\n\tif (sep == NULL) {\n\t\tperror(\"malloc\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tsep->se_hrt = hrt;\n\n\tlist_insert_head(&sgp->sg_list, sep);\n\tsgp->sg_count++;\n\n\tserd_log_msg(\"  SERD Engine: recording %s of %d (%llu)\",\n\t    sgp->sg_name, (int)sgp->sg_count, (long long unsigned)hrt);\n\n\t \n\toep = list_tail(&sgp->sg_list);\n\n\tif (sgp->sg_count >= sgp->sg_n &&\n\t    fmd_event_delta(oep->se_hrt, sep->se_hrt) <= sgp->sg_t) {\n\t\tsgp->sg_flags |= FMD_SERD_FIRED | FMD_SERD_DIRTY;\n\t\tserd_log_msg(\"  SERD Engine: fired %s\", sgp->sg_name);\n\t\treturn (B_TRUE);\n\t}\n\n\tsgp->sg_flags |= FMD_SERD_DIRTY;\n\treturn (B_FALSE);\n}\n\nint\nfmd_serd_eng_fired(fmd_serd_eng_t *sgp)\n{\n\treturn (sgp->sg_flags & FMD_SERD_FIRED);\n}\n\nint\nfmd_serd_eng_empty(fmd_serd_eng_t *sgp)\n{\n\treturn (sgp->sg_count == 0);\n}\n\nvoid\nfmd_serd_eng_reset(fmd_serd_eng_t *sgp)\n{\n\tserd_log_msg(\"  SERD Engine: resetting %s\", sgp->sg_name);\n\n\twhile (sgp->sg_count != 0)\n\t\tfmd_serd_eng_discard(sgp, list_head(&sgp->sg_list));\n\n\tsgp->sg_flags &= ~FMD_SERD_FIRED;\n\tsgp->sg_flags |= FMD_SERD_DIRTY;\n}\n\nvoid\nfmd_serd_eng_gc(fmd_serd_eng_t *sgp)\n{\n\tfmd_serd_elem_t *sep, *nep;\n\thrtime_t hrt;\n\n\tif (sgp->sg_count == 0 || (sgp->sg_flags & FMD_SERD_FIRED))\n\t\treturn;  \n\n\tsep = list_head(&sgp->sg_list);\n\tif (sep == NULL)\n\t\treturn;\n\n\thrt = sep->se_hrt - sgp->sg_t;\n\n\tfor (sep = list_head(&sgp->sg_list); sep != NULL; sep = nep) {\n\t\tif (sep->se_hrt >= hrt)\n\t\t\tbreak;  \n\n\t\tnep = list_next(&sgp->sg_list, sep);\n\t\tfmd_serd_eng_discard(sgp, sep);\n\t\tsgp->sg_flags |= FMD_SERD_DIRTY;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}