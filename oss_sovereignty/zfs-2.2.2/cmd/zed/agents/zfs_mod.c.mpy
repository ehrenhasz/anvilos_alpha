{
  "module_name": "zfs_mod.c",
  "hash_id": "94edf2d5d1511ad1b9351789f4a2551c13bc4723e533e3f4a8cb8e169dc380aa",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/agents/zfs_mod.c",
  "human_readable_source": " \n \n\n \n\n#include <ctype.h>\n#include <fcntl.h>\n#include <libnvpair.h>\n#include <libzfs.h>\n#include <libzutil.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <sys/list.h>\n#include <sys/sunddi.h>\n#include <sys/sysevent/eventdefs.h>\n#include <sys/sysevent/dev.h>\n#include <thread_pool.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <errno.h>\n#include \"zfs_agents.h\"\n#include \"../zed_log.h\"\n\n#define\tDEV_BYID_PATH\t\"/dev/disk/by-id/\"\n#define\tDEV_BYPATH_PATH\t\"/dev/disk/by-path/\"\n#define\tDEV_BYVDEV_PATH\t\"/dev/disk/by-vdev/\"\n\ntypedef void (*zfs_process_func_t)(zpool_handle_t *, nvlist_t *, boolean_t);\n\nlibzfs_handle_t *g_zfshdl;\nlist_t g_pool_list;\t \nlist_t g_device_list;\t \ntpool_t *g_tpool;\nboolean_t g_enumeration_done;\npthread_t g_zfs_tid;\t \n\ntypedef struct unavailpool {\n\tzpool_handle_t\t*uap_zhp;\n\tlist_node_t\tuap_node;\n} unavailpool_t;\n\ntypedef struct pendingdev {\n\tchar\t\tpd_physpath[128];\n\tlist_node_t\tpd_node;\n} pendingdev_t;\n\nstatic int\nzfs_toplevel_state(zpool_handle_t *zhp)\n{\n\tnvlist_t *nvroot;\n\tvdev_stat_t *vs;\n\tunsigned int c;\n\n\tverify(nvlist_lookup_nvlist(zpool_get_config(zhp, NULL),\n\t    ZPOOL_CONFIG_VDEV_TREE, &nvroot) == 0);\n\tverify(nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\treturn (vs->vs_state);\n}\n\nstatic int\nzfs_unavail_pool(zpool_handle_t *zhp, void *data)\n{\n\tzed_log_msg(LOG_INFO, \"zfs_unavail_pool: examining '%s' (state %d)\",\n\t    zpool_get_name(zhp), (int)zfs_toplevel_state(zhp));\n\n\tif (zfs_toplevel_state(zhp) < VDEV_STATE_DEGRADED) {\n\t\tunavailpool_t *uap;\n\t\tuap = malloc(sizeof (unavailpool_t));\n\t\tif (uap == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tuap->uap_zhp = zhp;\n\t\tlist_insert_tail((list_t *)data, uap);\n\t} else {\n\t\tzpool_close(zhp);\n\t}\n\treturn (0);\n}\n\n \nstatic void lines_to_zed_log_msg(char **lines, int lines_cnt)\n{\n\tint i;\n\tfor (i = 0; i < lines_cnt; i++) {\n\t\tzed_log_msg(LOG_INFO, \"%s\", lines[i]);\n\t}\n}\n\n \n\n \nstatic void\nzfs_process_add(zpool_handle_t *zhp, nvlist_t *vdev, boolean_t labeled)\n{\n\tconst char *path;\n\tvdev_state_t newstate;\n\tnvlist_t *nvroot, *newvd;\n\tpendingdev_t *device;\n\tuint64_t wholedisk = 0ULL;\n\tuint64_t offline = 0ULL, faulted = 0ULL;\n\tuint64_t guid = 0ULL;\n\tuint64_t is_spare = 0;\n\tconst char *physpath = NULL, *new_devid = NULL, *enc_sysfs_path = NULL;\n\tchar rawpath[PATH_MAX], fullpath[PATH_MAX];\n\tchar pathbuf[PATH_MAX];\n\tint ret;\n\tint online_flag = ZFS_ONLINE_CHECKREMOVE | ZFS_ONLINE_UNSPARE;\n\tboolean_t is_sd = B_FALSE;\n\tboolean_t is_mpath_wholedisk = B_FALSE;\n\tuint_t c;\n\tvdev_stat_t *vs;\n\tchar **lines = NULL;\n\tint lines_cnt = 0;\n\n\t \n\tif (nvlist_lookup_string(vdev, ZPOOL_CONFIG_PATH, &path) != 0)\n\t\treturn;\n\n\t \n\tverify(nvlist_lookup_uint64_array(vdev, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\tif (vs->vs_state == VDEV_STATE_HEALTHY) {\n\t\tzed_log_msg(LOG_INFO, \"%s: %s is already healthy, skip it.\",\n\t\t    __func__, path);\n\t\treturn;\n\t}\n\n\t(void) nvlist_lookup_string(vdev, ZPOOL_CONFIG_PHYS_PATH, &physpath);\n\t(void) nvlist_lookup_string(vdev, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH,\n\t    &enc_sysfs_path);\n\t(void) nvlist_lookup_uint64(vdev, ZPOOL_CONFIG_WHOLE_DISK, &wholedisk);\n\t(void) nvlist_lookup_uint64(vdev, ZPOOL_CONFIG_OFFLINE, &offline);\n\t(void) nvlist_lookup_uint64(vdev, ZPOOL_CONFIG_FAULTED, &faulted);\n\n\t(void) nvlist_lookup_uint64(vdev, ZPOOL_CONFIG_GUID, &guid);\n\t(void) nvlist_lookup_uint64(vdev, ZPOOL_CONFIG_IS_SPARE, &is_spare);\n\n\t \n\tif (physpath == NULL && path != NULL) {\n\t\t \n\t\tif (strncmp(path, DEV_BYVDEV_PATH,\n\t\t    strlen(DEV_BYVDEV_PATH)) == 0) {\n\t\t\t \n\t\t\tphyspath = &path[strlen(DEV_BYVDEV_PATH)];\n\t\t}\n\t}\n\n\t \n\tif (offline && !faulted) {\n\t\tzed_log_msg(LOG_INFO, \"%s: %s is offline, skip autoreplace\",\n\t\t    __func__, path);\n\t\treturn;\n\t}\n\n\tis_mpath_wholedisk = is_mpath_whole_disk(path);\n\tzed_log_msg(LOG_INFO, \"zfs_process_add: pool '%s' vdev '%s', phys '%s'\"\n\t    \" %s blank disk, %s mpath blank disk, %s labeled, enc sysfs '%s', \"\n\t    \"(guid %llu)\",\n\t    zpool_get_name(zhp), path,\n\t    physpath ? physpath : \"NULL\",\n\t    wholedisk ? \"is\" : \"not\",\n\t    is_mpath_wholedisk? \"is\" : \"not\",\n\t    labeled ? \"is\" : \"not\",\n\t    enc_sysfs_path,\n\t    (long long unsigned int)guid);\n\n\t \n\tif (guid != 0) {\n\t\t(void) snprintf(fullpath, sizeof (fullpath), \"%llu\",\n\t\t    (long long unsigned int)guid);\n\t} else {\n\t\t \n\t\t(void) strlcpy(fullpath, path, sizeof (fullpath));\n\t\tif (wholedisk) {\n\t\t\tchar *spath = zfs_strip_partition(fullpath);\n\t\t\tif (!spath) {\n\t\t\t\tzed_log_msg(LOG_INFO, \"%s: Can't alloc\",\n\t\t\t\t    __func__);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t(void) strlcpy(fullpath, spath, sizeof (fullpath));\n\t\t\tfree(spath);\n\t\t}\n\t}\n\n\tif (is_spare)\n\t\tonline_flag |= ZFS_ONLINE_SPARE;\n\n\t \n\tif (zpool_vdev_online(zhp, fullpath, online_flag, &newstate) == 0 &&\n\t    (newstate == VDEV_STATE_HEALTHY ||\n\t    newstate == VDEV_STATE_DEGRADED)) {\n\t\tzed_log_msg(LOG_INFO,\n\t\t    \"  zpool_vdev_online: vdev '%s' ('%s') is \"\n\t\t    \"%s\", fullpath, physpath, (newstate == VDEV_STATE_HEALTHY) ?\n\t\t    \"HEALTHY\" : \"DEGRADED\");\n\t\treturn;\n\t}\n\n\t \n\tif (physpath != NULL && strcmp(\"scsidebug\", physpath) == 0)\n\t\tis_sd = B_TRUE;\n\n\t \n\tif (!zpool_get_prop_int(zhp, ZPOOL_PROP_AUTOREPLACE, NULL) ||\n\t    !(wholedisk || is_mpath_wholedisk) || (physpath == NULL)) {\n\t\t(void) zpool_vdev_online(zhp, fullpath, ZFS_ONLINE_FORCEFAULT,\n\t\t    &newstate);\n\t\tzed_log_msg(LOG_INFO, \"Pool's autoreplace is not enabled or \"\n\t\t    \"not a blank disk for '%s' ('%s')\", fullpath,\n\t\t    physpath);\n\t\treturn;\n\t}\n\n\t \n\t(void) snprintf(rawpath, sizeof (rawpath), \"%s%s\",\n\t    is_sd ? DEV_BYVDEV_PATH : DEV_BYPATH_PATH, physpath);\n\n\tif (realpath(rawpath, pathbuf) == NULL && !is_mpath_wholedisk) {\n\t\tzed_log_msg(LOG_INFO, \"  realpath: %s failed (%s)\",\n\t\t    rawpath, strerror(errno));\n\n\t\tint err = zpool_vdev_online(zhp, fullpath,\n\t\t    ZFS_ONLINE_FORCEFAULT, &newstate);\n\n\t\tzed_log_msg(LOG_INFO, \"  zpool_vdev_online: %s FORCEFAULT (%s) \"\n\t\t    \"err %d, new state %d\",\n\t\t    fullpath, libzfs_error_description(g_zfshdl), err,\n\t\t    err ? (int)newstate : 0);\n\t\treturn;\n\t}\n\n\t \n\tif ((vs->vs_state != VDEV_STATE_DEGRADED) &&\n\t    (vs->vs_state != VDEV_STATE_FAULTED) &&\n\t    (vs->vs_state != VDEV_STATE_REMOVED) &&\n\t    (vs->vs_state != VDEV_STATE_CANT_OPEN)) {\n\t\tzed_log_msg(LOG_INFO, \"  not autoreplacing since disk isn't in \"\n\t\t    \"a bad state (currently %llu)\", vs->vs_state);\n\t\treturn;\n\t}\n\n\tnvlist_lookup_string(vdev, \"new_devid\", &new_devid);\n\n\tif (is_mpath_wholedisk) {\n\t\t \n\t\tzed_log_msg(LOG_INFO,\n\t\t    \"  it's a multipath wholedisk, don't label\");\n\t\tif (zpool_prepare_disk(zhp, vdev, \"autoreplace\", &lines,\n\t\t    &lines_cnt) != 0) {\n\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t    \"  zpool_prepare_disk: could not \"\n\t\t\t    \"prepare '%s' (%s)\", fullpath,\n\t\t\t    libzfs_error_description(g_zfshdl));\n\t\t\tif (lines_cnt > 0) {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t    \"  zfs_prepare_disk output:\");\n\t\t\t\tlines_to_zed_log_msg(lines, lines_cnt);\n\t\t\t}\n\t\t\tlibzfs_free_str_array(lines, lines_cnt);\n\t\t\treturn;\n\t\t}\n\t} else if (!labeled) {\n\t\t \n\t\tchar *leafname;\n\n\t\t \n\t\tleafname = strrchr(pathbuf, '/') + 1;\n\n\t\t \n\t\tif (zpool_prepare_and_label_disk(g_zfshdl, zhp, leafname,\n\t\t    vdev, \"autoreplace\", &lines, &lines_cnt) != 0) {\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"  zpool_prepare_and_label_disk: could not \"\n\t\t\t    \"label '%s' (%s)\", leafname,\n\t\t\t    libzfs_error_description(g_zfshdl));\n\t\t\tif (lines_cnt > 0) {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t\"  zfs_prepare_disk output:\");\n\t\t\t\tlines_to_zed_log_msg(lines, lines_cnt);\n\t\t\t}\n\t\t\tlibzfs_free_str_array(lines, lines_cnt);\n\n\t\t\t(void) zpool_vdev_online(zhp, fullpath,\n\t\t\t    ZFS_ONLINE_FORCEFAULT, &newstate);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tdevice = malloc(sizeof (pendingdev_t));\n\t\tif (device == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\t(void) strlcpy(device->pd_physpath, physpath,\n\t\t    sizeof (device->pd_physpath));\n\t\tlist_insert_tail(&g_device_list, device);\n\n\t\tzed_log_msg(LOG_NOTICE, \"  zpool_label_disk: async '%s' (%llu)\",\n\t\t    leafname, (u_longlong_t)guid);\n\n\t\treturn;\t \n\n\t} else   {\n\t\tboolean_t found = B_FALSE;\n\t\t \n\t\tfor (device = list_head(&g_device_list); device != NULL;\n\t\t    device = list_next(&g_device_list, device)) {\n\t\t\tif (strcmp(physpath, device->pd_physpath) == 0) {\n\t\t\t\tlist_remove(&g_device_list, device);\n\t\t\t\tfree(device);\n\t\t\t\tfound = B_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzed_log_msg(LOG_INFO, \"zpool_label_disk: %s != %s\",\n\t\t\t    physpath, device->pd_physpath);\n\t\t}\n\t\tif (!found) {\n\t\t\t \n\t\t\tzed_log_msg(LOG_WARNING, \"labeled disk %s was \"\n\t\t\t    \"unexpected here\", fullpath);\n\t\t\t(void) zpool_vdev_online(zhp, fullpath,\n\t\t\t    ZFS_ONLINE_FORCEFAULT, &newstate);\n\t\t\treturn;\n\t\t}\n\n\t\tzed_log_msg(LOG_INFO, \"  zpool_label_disk: resume '%s' (%llu)\",\n\t\t    physpath, (u_longlong_t)guid);\n\n\t\t \n\t\tif (strncmp(path, DEV_BYID_PATH, strlen(DEV_BYID_PATH)) == 0) {\n\t\t\t(void) snprintf(pathbuf, sizeof (pathbuf), \"%s%s\",\n\t\t\t    DEV_BYID_PATH, new_devid);\n\t\t\tzed_log_msg(LOG_INFO, \"  zpool_label_disk: path '%s' \"\n\t\t\t    \"replaced by '%s'\", path, pathbuf);\n\t\t\tpath = pathbuf;\n\t\t}\n\t}\n\n\tlibzfs_free_str_array(lines, lines_cnt);\n\n\t \n\tif (nvlist_alloc(&nvroot, NV_UNIQUE_NAME, 0) != 0) {\n\t\tzed_log_msg(LOG_WARNING, \"zfs_mod: nvlist_alloc out of memory\");\n\t\treturn;\n\t}\n\tif (nvlist_alloc(&newvd, NV_UNIQUE_NAME, 0) != 0) {\n\t\tzed_log_msg(LOG_WARNING, \"zfs_mod: nvlist_alloc out of memory\");\n\t\tnvlist_free(nvroot);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_string(newvd, ZPOOL_CONFIG_TYPE, VDEV_TYPE_DISK) != 0 ||\n\t    nvlist_add_string(newvd, ZPOOL_CONFIG_PATH, path) != 0 ||\n\t    nvlist_add_string(newvd, ZPOOL_CONFIG_DEVID, new_devid) != 0 ||\n\t    (physpath != NULL && nvlist_add_string(newvd,\n\t    ZPOOL_CONFIG_PHYS_PATH, physpath) != 0) ||\n\t    (enc_sysfs_path != NULL && nvlist_add_string(newvd,\n\t    ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH, enc_sysfs_path) != 0) ||\n\t    nvlist_add_uint64(newvd, ZPOOL_CONFIG_WHOLE_DISK, wholedisk) != 0 ||\n\t    nvlist_add_string(nvroot, ZPOOL_CONFIG_TYPE, VDEV_TYPE_ROOT) != 0 ||\n\t    nvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)&newvd, 1) != 0) {\n\t\tzed_log_msg(LOG_WARNING, \"zfs_mod: unable to add nvlist pairs\");\n\t\tnvlist_free(newvd);\n\t\tnvlist_free(nvroot);\n\t\treturn;\n\t}\n\n\tnvlist_free(newvd);\n\n\t \n\tif (zpool_label_disk_wait(path, DISK_LABEL_WAIT) != 0) {\n\t\tzed_log_msg(LOG_WARNING, \"zfs_mod: pool '%s', after labeling \"\n\t\t    \"replacement disk, the expected disk partition link '%s' \"\n\t\t    \"is missing after waiting %u ms\",\n\t\t    zpool_get_name(zhp), path, DISK_LABEL_WAIT);\n\t\tnvlist_free(nvroot);\n\t\treturn;\n\t}\n\n\t \n\tret = zpool_vdev_attach(zhp, fullpath, path, nvroot, B_TRUE, B_TRUE);\n\tif (ret != 0) {\n\t\tret = zpool_vdev_attach(zhp, fullpath, path, nvroot,\n\t\t    B_TRUE, B_FALSE);\n\t}\n\n\tzed_log_msg(LOG_WARNING, \"  zpool_vdev_replace: %s with %s (%s)\",\n\t    fullpath, path, (ret == 0) ? \"no errors\" :\n\t    libzfs_error_description(g_zfshdl));\n\n\tnvlist_free(nvroot);\n}\n\n \ntypedef struct dev_data {\n\tconst char\t\t*dd_compare;\n\tconst char\t\t*dd_prop;\n\tzfs_process_func_t\tdd_func;\n\tboolean_t\t\tdd_found;\n\tboolean_t\t\tdd_islabeled;\n\tuint64_t\t\tdd_pool_guid;\n\tuint64_t\t\tdd_vdev_guid;\n\tuint64_t\t\tdd_new_vdev_guid;\n\tconst char\t\t*dd_new_devid;\n\tuint64_t\t\tdd_num_spares;\n} dev_data_t;\n\nstatic void\nzfs_iter_vdev(zpool_handle_t *zhp, nvlist_t *nvl, void *data)\n{\n\tdev_data_t *dp = data;\n\tconst char *path = NULL;\n\tuint_t c, children;\n\tnvlist_t **child;\n\tuint64_t guid = 0;\n\tuint64_t isspare = 0;\n\n\t \n\tif (nvlist_lookup_nvlist_array(nvl, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tzfs_iter_vdev(zhp, child[c], data);\n\t}\n\n\t \n\tif (nvlist_lookup_nvlist_array(nvl, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tzfs_iter_vdev(zhp, child[c], data);\n\t}\n\tif (nvlist_lookup_nvlist_array(nvl, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tzfs_iter_vdev(zhp, child[c], data);\n\t}\n\n\t \n\tif (dp->dd_found && dp->dd_num_spares == 0)\n\t\treturn;\n\t(void) nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_GUID, &guid);\n\n\t \n\tif (dp->dd_vdev_guid != 0) {\n\t\tif (guid != dp->dd_vdev_guid)\n\t\t\treturn;\n\t\tzed_log_msg(LOG_INFO, \"  zfs_iter_vdev: matched on %llu\", guid);\n\t\tdp->dd_found = B_TRUE;\n\n\t} else if (dp->dd_compare != NULL) {\n\t\t \n\t\tif (nvlist_lookup_string(nvl, dp->dd_prop, &path) != 0 ||\n\t\t    strcmp(dp->dd_compare, path) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (dp->dd_new_vdev_guid != 0 && dp->dd_new_vdev_guid != guid) {\n\t\t\tzed_log_msg(LOG_INFO, \"  %s: no match (GUID:%llu\"\n\t\t\t    \" != vdev GUID:%llu)\", __func__,\n\t\t\t    dp->dd_new_vdev_guid, guid);\n\t\t\treturn;\n\t\t}\n\n\t\tzed_log_msg(LOG_INFO, \"  zfs_iter_vdev: matched %s on %s\",\n\t\t    dp->dd_prop, path);\n\t\tdp->dd_found = B_TRUE;\n\n\t\t \n\t\tif (dp->dd_new_devid != NULL) {\n\t\t\t(void) nvlist_add_string(nvl, \"new_devid\",\n\t\t\t    dp->dd_new_devid);\n\t\t}\n\t}\n\n\tif (dp->dd_found == B_TRUE && nvlist_lookup_uint64(nvl,\n\t    ZPOOL_CONFIG_IS_SPARE, &isspare) == 0 && isspare)\n\t\tdp->dd_num_spares++;\n\n\t(dp->dd_func)(zhp, nvl, dp->dd_islabeled);\n}\n\nstatic void\nzfs_enable_ds(void *arg)\n{\n\tunavailpool_t *pool = (unavailpool_t *)arg;\n\n\t(void) zpool_enable_datasets(pool->uap_zhp, NULL, 0);\n\tzpool_close(pool->uap_zhp);\n\tfree(pool);\n}\n\nstatic int\nzfs_iter_pool(zpool_handle_t *zhp, void *data)\n{\n\tnvlist_t *config, *nvl;\n\tdev_data_t *dp = data;\n\tuint64_t pool_guid;\n\tunavailpool_t *pool;\n\n\tzed_log_msg(LOG_INFO, \"zfs_iter_pool: evaluating vdevs on %s (by %s)\",\n\t    zpool_get_name(zhp), dp->dd_vdev_guid ? \"GUID\" : dp->dd_prop);\n\n\t \n\tif ((config = zpool_get_config(zhp, NULL)) != NULL) {\n\t\tif (dp->dd_pool_guid == 0 ||\n\t\t    (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t\t    &pool_guid) == 0 && pool_guid == dp->dd_pool_guid)) {\n\t\t\t(void) nvlist_lookup_nvlist(config,\n\t\t\t    ZPOOL_CONFIG_VDEV_TREE, &nvl);\n\t\t\tzfs_iter_vdev(zhp, nvl, data);\n\t\t}\n\t} else {\n\t\tzed_log_msg(LOG_INFO, \"%s: no config\\n\", __func__);\n\t}\n\n\t \n\tif (g_enumeration_done)  {\n\t\tfor (pool = list_head(&g_pool_list); pool != NULL;\n\t\t    pool = list_next(&g_pool_list, pool)) {\n\n\t\t\tif (strcmp(zpool_get_name(zhp),\n\t\t\t    zpool_get_name(pool->uap_zhp)))\n\t\t\t\tcontinue;\n\t\t\tif (zfs_toplevel_state(zhp) >= VDEV_STATE_DEGRADED) {\n\t\t\t\tlist_remove(&g_pool_list, pool);\n\t\t\t\t(void) tpool_dispatch(g_tpool, zfs_enable_ds,\n\t\t\t\t    pool);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tzpool_close(zhp);\n\n\t \n\treturn (dp->dd_found && dp->dd_num_spares == 0);\n}\n\n \nstatic boolean_t\ndevphys_iter(const char *physical, const char *devid, zfs_process_func_t func,\n    boolean_t is_slice, uint64_t new_vdev_guid)\n{\n\tdev_data_t data = { 0 };\n\n\tdata.dd_compare = physical;\n\tdata.dd_func = func;\n\tdata.dd_prop = ZPOOL_CONFIG_PHYS_PATH;\n\tdata.dd_found = B_FALSE;\n\tdata.dd_islabeled = is_slice;\n\tdata.dd_new_devid = devid;\t \n\tdata.dd_new_vdev_guid = new_vdev_guid;\n\n\t(void) zpool_iter(g_zfshdl, zfs_iter_pool, &data);\n\n\treturn (data.dd_found);\n}\n\n \nstatic boolean_t\nby_vdev_path_iter(const char *by_vdev_path, const char *devid,\n    zfs_process_func_t func, boolean_t is_slice)\n{\n\tdev_data_t data = { 0 };\n\n\tdata.dd_compare = by_vdev_path;\n\tdata.dd_func = func;\n\tdata.dd_prop = ZPOOL_CONFIG_PATH;\n\tdata.dd_found = B_FALSE;\n\tdata.dd_islabeled = is_slice;\n\tdata.dd_new_devid = devid;\n\n\tif (strncmp(by_vdev_path, DEV_BYVDEV_PATH,\n\t    strlen(DEV_BYVDEV_PATH)) != 0) {\n\t\t \n\t\treturn (B_FALSE);\n\t}\n\n\t(void) zpool_iter(g_zfshdl, zfs_iter_pool, &data);\n\n\treturn (data.dd_found);\n}\n\n \nstatic boolean_t\ndevid_iter(const char *devid, zfs_process_func_t func, boolean_t is_slice)\n{\n\tdev_data_t data = { 0 };\n\n\tdata.dd_compare = devid;\n\tdata.dd_func = func;\n\tdata.dd_prop = ZPOOL_CONFIG_DEVID;\n\tdata.dd_found = B_FALSE;\n\tdata.dd_islabeled = is_slice;\n\tdata.dd_new_devid = devid;\n\n\t(void) zpool_iter(g_zfshdl, zfs_iter_pool, &data);\n\n\treturn (data.dd_found);\n}\n\n \nstatic boolean_t\nguid_iter(uint64_t pool_guid, uint64_t vdev_guid, const char *devid,\n    zfs_process_func_t func, boolean_t is_slice)\n{\n\tdev_data_t data = { 0 };\n\n\tdata.dd_func = func;\n\tdata.dd_found = B_FALSE;\n\tdata.dd_pool_guid = pool_guid;\n\tdata.dd_vdev_guid = vdev_guid;\n\tdata.dd_islabeled = is_slice;\n\tdata.dd_new_devid = devid;\n\n\t(void) zpool_iter(g_zfshdl, zfs_iter_pool, &data);\n\n\treturn (data.dd_found);\n}\n\n \nstatic int\nzfs_deliver_add(nvlist_t *nvl)\n{\n\tconst char *devpath = NULL, *devid = NULL;\n\tuint64_t pool_guid = 0, vdev_guid = 0;\n\tboolean_t is_slice;\n\n\t \n\tif (nvlist_lookup_string(nvl, DEV_IDENTIFIER, &devid) != 0) {\n\t\tzed_log_msg(LOG_INFO, \"%s: no dev identifier\\n\", __func__);\n\t\treturn (-1);\n\t}\n\n\t(void) nvlist_lookup_string(nvl, DEV_PHYS_PATH, &devpath);\n\t(void) nvlist_lookup_uint64(nvl, ZFS_EV_POOL_GUID, &pool_guid);\n\t(void) nvlist_lookup_uint64(nvl, ZFS_EV_VDEV_GUID, &vdev_guid);\n\n\tis_slice = (nvlist_lookup_boolean(nvl, DEV_IS_PART) == 0);\n\n\tzed_log_msg(LOG_INFO, \"zfs_deliver_add: adding %s (%s) (is_slice %d)\",\n\t    devid, devpath ? devpath : \"NULL\", is_slice);\n\n\t \n\tif (devid_iter(devid, zfs_process_add, is_slice))\n\t\treturn (0);\n\tif (devpath != NULL && devphys_iter(devpath, devid, zfs_process_add,\n\t    is_slice, vdev_guid))\n\t\treturn (0);\n\tif (vdev_guid != 0)\n\t\t(void) guid_iter(pool_guid, vdev_guid, devid, zfs_process_add,\n\t\t    is_slice);\n\n\tif (devpath != NULL) {\n\t\t \n\t\tchar by_vdev_path[MAXPATHLEN];\n\t\tsnprintf(by_vdev_path, sizeof (by_vdev_path),\n\t\t    \"/dev/disk/by-vdev/%s\", devpath);\n\t\tif (by_vdev_path_iter(by_vdev_path, devid, zfs_process_add,\n\t\t    is_slice))\n\t\t\treturn (0);\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_deliver_check(nvlist_t *nvl)\n{\n\tdev_data_t data = { 0 };\n\n\tif (nvlist_lookup_uint64(nvl, ZFS_EV_POOL_GUID,\n\t    &data.dd_pool_guid) != 0 ||\n\t    nvlist_lookup_uint64(nvl, ZFS_EV_VDEV_GUID,\n\t    &data.dd_vdev_guid) != 0 ||\n\t    data.dd_vdev_guid == 0)\n\t\treturn (0);\n\n\tzed_log_msg(LOG_INFO, \"zfs_deliver_check: pool '%llu', vdev %llu\",\n\t    data.dd_pool_guid, data.dd_vdev_guid);\n\n\tdata.dd_func = zfs_process_add;\n\n\t(void) zpool_iter(g_zfshdl, zfs_iter_pool, &data);\n\n\treturn (0);\n}\n\n \nstatic uint64_t\nvdev_size_from_config(zpool_handle_t *zhp, const char *vdev_path)\n{\n\tnvlist_t *nvl = NULL;\n\tboolean_t avail_spare, l2cache, log;\n\tvdev_stat_t *vs = NULL;\n\tuint_t c;\n\n\tnvl = zpool_find_vdev(zhp, vdev_path, &avail_spare, &l2cache, &log);\n\tif (!nvl)\n\t\treturn (0);\n\n\tverify(nvlist_lookup_uint64_array(nvl, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) == 0);\n\tif (!vs) {\n\t\tzed_log_msg(LOG_INFO, \"%s: no nvlist for '%s'\", __func__,\n\t\t    vdev_path);\n\t\treturn (0);\n\t}\n\n\treturn (vs->vs_pspace);\n}\n\n \nstatic uint64_t\nvdev_whole_disk_from_config(zpool_handle_t *zhp, const char *vdev_path)\n{\n\tnvlist_t *nvl = NULL;\n\tboolean_t avail_spare, l2cache, log;\n\tuint64_t wholedisk = 0;\n\n\tnvl = zpool_find_vdev(zhp, vdev_path, &avail_spare, &l2cache, &log);\n\tif (!nvl)\n\t\treturn (0);\n\n\t(void) nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_WHOLE_DISK, &wholedisk);\n\n\treturn (wholedisk);\n}\n\n \n#define\tDEVICE_GREW(oldsize, newsize) \\\n\t\t    ((newsize > oldsize) && \\\n\t\t    ((newsize / (newsize - oldsize)) <= 100))\n\nstatic int\nzfsdle_vdev_online(zpool_handle_t *zhp, void *data)\n{\n\tboolean_t avail_spare, l2cache;\n\tnvlist_t *udev_nvl = data;\n\tnvlist_t *tgt;\n\tint error;\n\n\tconst char *tmp_devname;\n\tchar devname[MAXPATHLEN] = \"\";\n\tuint64_t guid;\n\n\tif (nvlist_lookup_uint64(udev_nvl, ZFS_EV_VDEV_GUID, &guid) == 0) {\n\t\tsprintf(devname, \"%llu\", (u_longlong_t)guid);\n\t} else if (nvlist_lookup_string(udev_nvl, DEV_PHYS_PATH,\n\t    &tmp_devname) == 0) {\n\t\tstrlcpy(devname, tmp_devname, MAXPATHLEN);\n\t\tzfs_append_partition(devname, MAXPATHLEN);\n\t} else {\n\t\tzed_log_msg(LOG_INFO, \"%s: no guid or physpath\", __func__);\n\t}\n\n\tzed_log_msg(LOG_INFO, \"zfsdle_vdev_online: searching for '%s' in '%s'\",\n\t    devname, zpool_get_name(zhp));\n\n\tif ((tgt = zpool_find_vdev_by_physpath(zhp, devname,\n\t    &avail_spare, &l2cache, NULL)) != NULL) {\n\t\tconst char *path;\n\t\tchar fullpath[MAXPATHLEN];\n\t\tuint64_t wholedisk = 0;\n\n\t\terror = nvlist_lookup_string(tgt, ZPOOL_CONFIG_PATH, &path);\n\t\tif (error) {\n\t\t\tzpool_close(zhp);\n\t\t\treturn (0);\n\t\t}\n\n\t\t(void) nvlist_lookup_uint64(tgt, ZPOOL_CONFIG_WHOLE_DISK,\n\t\t    &wholedisk);\n\n\t\tif (wholedisk) {\n\t\t\tchar *tmp;\n\t\t\tpath = strrchr(path, '/');\n\t\t\tif (path != NULL) {\n\t\t\t\ttmp = zfs_strip_partition(path + 1);\n\t\t\t\tif (tmp == NULL) {\n\t\t\t\t\tzpool_close(zhp);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzpool_close(zhp);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t(void) strlcpy(fullpath, tmp, sizeof (fullpath));\n\t\t\tfree(tmp);\n\n\t\t\t \n\t\t\tboolean_t scrub_restart = B_FALSE;\n\t\t\t(void) zpool_reopen_one(zhp, &scrub_restart);\n\t\t} else {\n\t\t\t(void) strlcpy(fullpath, path, sizeof (fullpath));\n\t\t}\n\n\t\tif (zpool_get_prop_int(zhp, ZPOOL_PROP_AUTOEXPAND, NULL)) {\n\t\t\tvdev_state_t newstate;\n\n\t\t\tif (zpool_get_state(zhp) != POOL_STATE_UNAVAIL) {\n\t\t\t\t \n\t\t\t\tuint64_t udev_size = 0, conf_size = 0,\n\t\t\t\t    wholedisk = 0, udev_parent_size = 0;\n\n\t\t\t\t \n\t\t\t\tif (nvlist_lookup_uint64(udev_nvl, DEV_SIZE,\n\t\t\t\t    &udev_size) != 0) {\n\t\t\t\t\tudev_size = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (nvlist_lookup_uint64(udev_nvl,\n\t\t\t\t    DEV_PARENT_SIZE, &udev_parent_size) != 0) {\n\t\t\t\t\tudev_parent_size = 0;\n\t\t\t\t}\n\n\t\t\t\tconf_size = vdev_size_from_config(zhp,\n\t\t\t\t    fullpath);\n\n\t\t\t\twholedisk = vdev_whole_disk_from_config(zhp,\n\t\t\t\t    fullpath);\n\n\t\t\t\t \n\t\t\t\tif (DEVICE_GREW(conf_size, udev_size) ||\n\t\t\t\t    (wholedisk && DEVICE_GREW(conf_size,\n\t\t\t\t    udev_parent_size))) {\n\t\t\t\t\terror = zpool_vdev_online(zhp, fullpath,\n\t\t\t\t\t    0, &newstate);\n\n\t\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t\t    \"%s: autoexpanding '%s' from %llu\"\n\t\t\t\t\t    \" to %llu bytes in pool '%s': %d\",\n\t\t\t\t\t    __func__, fullpath, conf_size,\n\t\t\t\t\t    MAX(udev_size, udev_parent_size),\n\t\t\t\t\t    zpool_get_name(zhp), error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tzpool_close(zhp);\n\t\treturn (1);\n\t}\n\tzpool_close(zhp);\n\treturn (0);\n}\n\n \nstatic int\nzfs_deliver_dle(nvlist_t *nvl)\n{\n\tconst char *devname;\n\tchar name[MAXPATHLEN];\n\tuint64_t guid;\n\n\tif (nvlist_lookup_uint64(nvl, ZFS_EV_VDEV_GUID, &guid) == 0) {\n\t\tsprintf(name, \"%llu\", (u_longlong_t)guid);\n\t} else if (nvlist_lookup_string(nvl, DEV_PHYS_PATH, &devname) == 0) {\n\t\tstrlcpy(name, devname, MAXPATHLEN);\n\t\tzfs_append_partition(name, MAXPATHLEN);\n\t} else {\n\t\tsprintf(name, \"unknown\");\n\t\tzed_log_msg(LOG_INFO, \"zfs_deliver_dle: no guid or physpath\");\n\t}\n\n\tif (zpool_iter(g_zfshdl, zfsdle_vdev_online, nvl) != 1) {\n\t\tzed_log_msg(LOG_INFO, \"zfs_deliver_dle: device '%s' not \"\n\t\t    \"found\", name);\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_slm_deliver_event(const char *class, const char *subclass, nvlist_t *nvl)\n{\n\tint ret;\n\tboolean_t is_check = B_FALSE, is_dle = B_FALSE;\n\n\tif (strcmp(class, EC_DEV_ADD) == 0) {\n\t\t \n\t\tif (strcmp(subclass, ESC_DISK) != 0 &&\n\t\t    strcmp(subclass, ESC_LOFI) != 0)\n\t\t\treturn (0);\n\n\t\tis_check = B_FALSE;\n\t} else if (strcmp(class, EC_ZFS) == 0 &&\n\t    strcmp(subclass, ESC_ZFS_VDEV_CHECK) == 0) {\n\t\t \n\t\tis_check = B_TRUE;\n\t} else if (strcmp(class, EC_DEV_STATUS) == 0 &&\n\t    strcmp(subclass, ESC_DEV_DLE) == 0) {\n\t\tis_dle = B_TRUE;\n\t} else {\n\t\treturn (0);\n\t}\n\n\tif (is_dle)\n\t\tret = zfs_deliver_dle(nvl);\n\telse if (is_check)\n\t\tret = zfs_deliver_check(nvl);\n\telse\n\t\tret = zfs_deliver_add(nvl);\n\n\treturn (ret);\n}\n\nstatic void *\nzfs_enum_pools(void *arg)\n{\n\t(void) arg;\n\n\t(void) zpool_iter(g_zfshdl, zfs_unavail_pool, (void *)&g_pool_list);\n\t \n\tg_enumeration_done = B_TRUE;\n\treturn (NULL);\n}\n\n \nint\nzfs_slm_init(void)\n{\n\tif ((g_zfshdl = libzfs_init()) == NULL)\n\t\treturn (-1);\n\n\t \n\tlist_create(&g_pool_list, sizeof (struct unavailpool),\n\t    offsetof(struct unavailpool, uap_node));\n\n\tif (pthread_create(&g_zfs_tid, NULL, zfs_enum_pools, NULL) != 0) {\n\t\tlist_destroy(&g_pool_list);\n\t\tlibzfs_fini(g_zfshdl);\n\t\treturn (-1);\n\t}\n\n\tpthread_setname_np(g_zfs_tid, \"enum-pools\");\n\tlist_create(&g_device_list, sizeof (struct pendingdev),\n\t    offsetof(struct pendingdev, pd_node));\n\n\treturn (0);\n}\n\nvoid\nzfs_slm_fini(void)\n{\n\tunavailpool_t *pool;\n\tpendingdev_t *device;\n\n\t \n\t(void) pthread_join(g_zfs_tid, NULL);\n\t \n\tif (g_tpool != NULL) {\n\t\ttpool_wait(g_tpool);\n\t\ttpool_destroy(g_tpool);\n\t}\n\n\twhile ((pool = list_remove_head(&g_pool_list)) != NULL) {\n\t\tzpool_close(pool->uap_zhp);\n\t\tfree(pool);\n\t}\n\tlist_destroy(&g_pool_list);\n\n\twhile ((device = list_remove_head(&g_device_list)) != NULL)\n\t\tfree(device);\n\tlist_destroy(&g_device_list);\n\n\tlibzfs_fini(g_zfshdl);\n}\n\nvoid\nzfs_slm_event(const char *class, const char *subclass, nvlist_t *nvl)\n{\n\tzed_log_msg(LOG_INFO, \"zfs_slm_event: %s.%s\", class, subclass);\n\t(void) zfs_slm_deliver_event(class, subclass, nvl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}