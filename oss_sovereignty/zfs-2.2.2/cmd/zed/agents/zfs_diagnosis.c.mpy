{
  "module_name": "zfs_diagnosis.c",
  "hash_id": "6f8f307b10d8b1cd6b5447b42ebb6af660d586c4de6d5b2da7b83f28364e843b",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/agents/zfs_diagnosis.c",
  "human_readable_source": " \n\n \n\n#include <stddef.h>\n#include <string.h>\n#include <libuutil.h>\n#include <libzfs.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/fs/zfs.h>\n#include <sys/fm/protocol.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/zio.h>\n\n#include \"zfs_agents.h\"\n#include \"fmd_api.h\"\n\n \n#define\tDEFAULT_CHECKSUM_N\t10\t \n#define\tDEFAULT_CHECKSUM_T\t600\t \n#define\tDEFAULT_IO_N\t\t10\t \n#define\tDEFAULT_IO_T\t\t600\t \n\n \n#define\tMAX_SERDLEN\t(16 * 2 + sizeof (\"zfs___checksum\"))\n\n \ntypedef struct zfs_case_data {\n\tuint64_t\tzc_version;\n\tuint64_t\tzc_ena;\n\tuint64_t\tzc_pool_guid;\n\tuint64_t\tzc_vdev_guid;\n\tint\t\tzc_pool_state;\n\tchar\t\tzc_serd_checksum[MAX_SERDLEN];\n\tchar\t\tzc_serd_io[MAX_SERDLEN];\n\tint\t\tzc_has_remove_timer;\n} zfs_case_data_t;\n\n \ntypedef struct er_timeval {\n\tuint64_t\tertv_sec;\n\tuint64_t\tertv_nsec;\n} er_timeval_t;\n\n \ntypedef struct zfs_case {\n\tboolean_t\tzc_present;\n\tuint32_t\tzc_version;\n\tzfs_case_data_t\tzc_data;\n\tfmd_case_t\t*zc_case;\n\tuu_list_node_t\tzc_node;\n\tid_t\t\tzc_remove_timer;\n\tchar\t\t*zc_fru;\n\ter_timeval_t\tzc_when;\n} zfs_case_t;\n\n#define\tCASE_DATA\t\t\t\"data\"\n#define\tCASE_FRU\t\t\t\"fru\"\n#define\tCASE_DATA_VERSION_INITIAL\t1\n#define\tCASE_DATA_VERSION_SERD\t\t2\n\ntypedef struct zfs_de_stats {\n\tfmd_stat_t\told_drops;\n\tfmd_stat_t\tdev_drops;\n\tfmd_stat_t\tvdev_drops;\n\tfmd_stat_t\timport_drops;\n\tfmd_stat_t\tresource_drops;\n} zfs_de_stats_t;\n\nzfs_de_stats_t zfs_stats = {\n\t{ \"old_drops\", FMD_TYPE_UINT64, \"ereports dropped (from before load)\" },\n\t{ \"dev_drops\", FMD_TYPE_UINT64, \"ereports dropped (dev during open)\"},\n\t{ \"vdev_drops\", FMD_TYPE_UINT64, \"ereports dropped (weird vdev types)\"},\n\t{ \"import_drops\", FMD_TYPE_UINT64, \"ereports dropped (during import)\" },\n\t{ \"resource_drops\", FMD_TYPE_UINT64, \"resource related ereports\" }\n};\n\nstatic hrtime_t zfs_remove_timeout;\n\nuu_list_pool_t *zfs_case_pool;\nuu_list_t *zfs_cases;\n\n#define\tZFS_MAKE_RSRC(type)\t\\\n    FM_RSRC_CLASS \".\" ZFS_ERROR_CLASS \".\" type\n#define\tZFS_MAKE_EREPORT(type)\t\\\n    FM_EREPORT_CLASS \".\" ZFS_ERROR_CLASS \".\" type\n\n \nstatic void\nzfs_case_serialize(zfs_case_t *zcp)\n{\n\tzcp->zc_data.zc_version = CASE_DATA_VERSION_SERD;\n}\n\n \nstatic zfs_case_t *\nzfs_case_unserialize(fmd_hdl_t *hdl, fmd_case_t *cp)\n{\n\tzfs_case_t *zcp;\n\n\tzcp = fmd_hdl_zalloc(hdl, sizeof (zfs_case_t), FMD_SLEEP);\n\tzcp->zc_case = cp;\n\n\tfmd_buf_read(hdl, cp, CASE_DATA, &zcp->zc_data,\n\t    sizeof (zcp->zc_data));\n\n\tif (zcp->zc_data.zc_version > CASE_DATA_VERSION_SERD) {\n\t\tfmd_hdl_free(hdl, zcp, sizeof (zfs_case_t));\n\t\treturn (NULL);\n\t}\n\n\t \n\n\tif (zcp->zc_data.zc_has_remove_timer)\n\t\tzcp->zc_remove_timer = fmd_timer_install(hdl, zcp,\n\t\t    NULL, zfs_remove_timeout);\n\n\tuu_list_node_init(zcp, &zcp->zc_node, zfs_case_pool);\n\t(void) uu_list_insert_before(zfs_cases, NULL, zcp);\n\n\tfmd_case_setspecific(hdl, cp, zcp);\n\n\treturn (zcp);\n}\n\n \nstatic void\nzfs_mark_vdev(uint64_t pool_guid, nvlist_t *vd, er_timeval_t *loaded)\n{\n\tuint64_t vdev_guid = 0;\n\tuint_t c, children;\n\tnvlist_t **child;\n\tzfs_case_t *zcp;\n\n\t(void) nvlist_lookup_uint64(vd, ZPOOL_CONFIG_GUID, &vdev_guid);\n\n\t \n\tfor (zcp = uu_list_first(zfs_cases); zcp != NULL;\n\t    zcp = uu_list_next(zfs_cases, zcp)) {\n\t\tif (zcp->zc_data.zc_pool_guid == pool_guid &&\n\t\t    zcp->zc_data.zc_vdev_guid == vdev_guid) {\n\t\t\tzcp->zc_present = B_TRUE;\n\t\t\tzcp->zc_when = *loaded;\n\t\t}\n\t}\n\n\t \n\tif (nvlist_lookup_nvlist_array(vd, ZPOOL_CONFIG_CHILDREN, &child,\n\t    &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tzfs_mark_vdev(pool_guid, child[c], loaded);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(vd, ZPOOL_CONFIG_L2CACHE, &child,\n\t    &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tzfs_mark_vdev(pool_guid, child[c], loaded);\n\t}\n\n\tif (nvlist_lookup_nvlist_array(vd, ZPOOL_CONFIG_SPARES, &child,\n\t    &children) == 0) {\n\t\tfor (c = 0; c < children; c++)\n\t\t\tzfs_mark_vdev(pool_guid, child[c], loaded);\n\t}\n}\n\nstatic int\nzfs_mark_pool(zpool_handle_t *zhp, void *unused)\n{\n\t(void) unused;\n\tzfs_case_t *zcp;\n\tuint64_t pool_guid;\n\tuint64_t *tod;\n\ter_timeval_t loaded = { 0 };\n\tnvlist_t *config, *vd;\n\tuint_t nelem = 0;\n\tint ret;\n\n\tpool_guid = zpool_get_prop_int(zhp, ZPOOL_PROP_GUID, NULL);\n\t \n\tfor (zcp = uu_list_first(zfs_cases); zcp != NULL;\n\t    zcp = uu_list_next(zfs_cases, zcp)) {\n\t\tif (zcp->zc_data.zc_pool_guid == pool_guid &&\n\t\t    zcp->zc_data.zc_vdev_guid == 0)\n\t\t\tzcp->zc_present = B_TRUE;\n\t}\n\n\tif ((config = zpool_get_config(zhp, NULL)) == NULL) {\n\t\tzpool_close(zhp);\n\t\treturn (-1);\n\t}\n\n\t(void) nvlist_lookup_uint64_array(config, ZPOOL_CONFIG_LOADED_TIME,\n\t    &tod, &nelem);\n\tif (nelem == 2) {\n\t\tloaded.ertv_sec = tod[0];\n\t\tloaded.ertv_nsec = tod[1];\n\t\tfor (zcp = uu_list_first(zfs_cases); zcp != NULL;\n\t\t    zcp = uu_list_next(zfs_cases, zcp)) {\n\t\t\tif (zcp->zc_data.zc_pool_guid == pool_guid &&\n\t\t\t    zcp->zc_data.zc_vdev_guid == 0) {\n\t\t\t\tzcp->zc_when = loaded;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE, &vd);\n\tif (ret) {\n\t\tzpool_close(zhp);\n\t\treturn (-1);\n\t}\n\n\tzfs_mark_vdev(pool_guid, vd, &loaded);\n\n\tzpool_close(zhp);\n\n\treturn (0);\n}\n\nstruct load_time_arg {\n\tuint64_t lt_guid;\n\ter_timeval_t *lt_time;\n\tboolean_t lt_found;\n};\n\nstatic int\nzpool_find_load_time(zpool_handle_t *zhp, void *arg)\n{\n\tstruct load_time_arg *lta = arg;\n\tuint64_t pool_guid;\n\tuint64_t *tod;\n\tnvlist_t *config;\n\tuint_t nelem;\n\n\tif (lta->lt_found) {\n\t\tzpool_close(zhp);\n\t\treturn (0);\n\t}\n\n\tpool_guid = zpool_get_prop_int(zhp, ZPOOL_PROP_GUID, NULL);\n\tif (pool_guid != lta->lt_guid) {\n\t\tzpool_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif ((config = zpool_get_config(zhp, NULL)) == NULL) {\n\t\tzpool_close(zhp);\n\t\treturn (-1);\n\t}\n\n\tif (nvlist_lookup_uint64_array(config, ZPOOL_CONFIG_LOADED_TIME,\n\t    &tod, &nelem) == 0 && nelem == 2) {\n\t\tlta->lt_found = B_TRUE;\n\t\tlta->lt_time->ertv_sec = tod[0];\n\t\tlta->lt_time->ertv_nsec = tod[1];\n\t}\n\n\tzpool_close(zhp);\n\n\treturn (0);\n}\n\nstatic void\nzfs_purge_cases(fmd_hdl_t *hdl)\n{\n\tzfs_case_t *zcp;\n\tuu_list_walk_t *walk;\n\tlibzfs_handle_t *zhdl = fmd_hdl_getspecific(hdl);\n\n\t \n\n\t \n\tfor (zcp = uu_list_first(zfs_cases); zcp != NULL;\n\t    zcp = uu_list_next(zfs_cases, zcp))\n\t\tzcp->zc_present = B_FALSE;\n\n\t \n\tif (zpool_iter(zhdl, zfs_mark_pool, NULL) != 0)\n\t\treturn;\n\n\t \n\twalk = uu_list_walk_start(zfs_cases, UU_WALK_ROBUST);\n\twhile ((zcp = uu_list_walk_next(walk)) != NULL) {\n\t\tif (!zcp->zc_present)\n\t\t\tfmd_case_close(hdl, zcp->zc_case);\n\t}\n\tuu_list_walk_end(walk);\n}\n\n \nstatic void\nzfs_serd_name(char *buf, uint64_t pool_guid, uint64_t vdev_guid,\n    const char *type)\n{\n\t(void) snprintf(buf, MAX_SERDLEN, \"zfs_%llx_%llx_%s\",\n\t    (long long unsigned int)pool_guid,\n\t    (long long unsigned int)vdev_guid, type);\n}\n\n \nstatic void\nzfs_case_solve(fmd_hdl_t *hdl, zfs_case_t *zcp, const char *faultname)\n{\n\tnvlist_t *detector, *fault;\n\tboolean_t serialize;\n\tnvlist_t *fru = NULL;\n\tfmd_hdl_debug(hdl, \"solving fault '%s'\", faultname);\n\n\t \n\tdetector = fmd_nvl_alloc(hdl, FMD_SLEEP);\n\n\t(void) nvlist_add_uint8(detector, FM_VERSION, ZFS_SCHEME_VERSION0);\n\t(void) nvlist_add_string(detector, FM_FMRI_SCHEME, FM_FMRI_SCHEME_ZFS);\n\t(void) nvlist_add_uint64(detector, FM_FMRI_ZFS_POOL,\n\t    zcp->zc_data.zc_pool_guid);\n\tif (zcp->zc_data.zc_vdev_guid != 0) {\n\t\t(void) nvlist_add_uint64(detector, FM_FMRI_ZFS_VDEV,\n\t\t    zcp->zc_data.zc_vdev_guid);\n\t}\n\n\tfault = fmd_nvl_create_fault(hdl, faultname, 100, detector,\n\t    fru, detector);\n\tfmd_case_add_suspect(hdl, zcp->zc_case, fault);\n\n\tnvlist_free(fru);\n\n\tfmd_case_solve(hdl, zcp->zc_case);\n\n\tserialize = B_FALSE;\n\tif (zcp->zc_data.zc_has_remove_timer) {\n\t\tfmd_timer_remove(hdl, zcp->zc_remove_timer);\n\t\tzcp->zc_data.zc_has_remove_timer = 0;\n\t\tserialize = B_TRUE;\n\t}\n\tif (serialize)\n\t\tzfs_case_serialize(zcp);\n\n\tnvlist_free(detector);\n}\n\nstatic boolean_t\ntimeval_earlier(er_timeval_t *a, er_timeval_t *b)\n{\n\treturn (a->ertv_sec < b->ertv_sec ||\n\t    (a->ertv_sec == b->ertv_sec && a->ertv_nsec < b->ertv_nsec));\n}\n\nstatic void\nzfs_ereport_when(fmd_hdl_t *hdl, nvlist_t *nvl, er_timeval_t *when)\n{\n\t(void) hdl;\n\tint64_t *tod;\n\tuint_t\tnelem;\n\n\tif (nvlist_lookup_int64_array(nvl, FM_EREPORT_TIME, &tod,\n\t    &nelem) == 0 && nelem == 2) {\n\t\twhen->ertv_sec = tod[0];\n\t\twhen->ertv_nsec = tod[1];\n\t} else {\n\t\twhen->ertv_sec = when->ertv_nsec = UINT64_MAX;\n\t}\n}\n\n \nstatic void\nzfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)\n{\n\tzfs_case_t *zcp, *dcp;\n\tint32_t pool_state;\n\tuint64_t ena, pool_guid, vdev_guid;\n\tuint64_t checksum_n, checksum_t;\n\tuint64_t io_n, io_t;\n\ter_timeval_t pool_load;\n\ter_timeval_t er_when;\n\tnvlist_t *detector;\n\tboolean_t pool_found = B_FALSE;\n\tboolean_t isresource;\n\tconst char *type;\n\n\t \n\tif (fmd_nvl_class_match(hdl, nvl, \"sysevent.fs.zfs.*\")) {\n\t\tfmd_hdl_debug(hdl, \"purging orphaned cases from %s\",\n\t\t    strrchr(class, '.') + 1);\n\t\tzfs_purge_cases(hdl);\n\t\tzfs_stats.resource_drops.fmds_value.ui64++;\n\t\treturn;\n\t}\n\n\tisresource = fmd_nvl_class_match(hdl, nvl, \"resource.fs.zfs.*\");\n\n\tif (isresource) {\n\t\t \n\t\tif (nvlist_lookup_uint64(nvl, FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID,\n\t\t    &vdev_guid) != 0)\n\t\t\tpool_state = SPA_LOAD_OPEN;\n\t\telse\n\t\t\tpool_state = SPA_LOAD_NONE;\n\t\tdetector = NULL;\n\t} else {\n\t\t(void) nvlist_lookup_nvlist(nvl,\n\t\t    FM_EREPORT_DETECTOR, &detector);\n\t\t(void) nvlist_lookup_int32(nvl,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_POOL_CONTEXT, &pool_state);\n\t}\n\n\t \n\tif (pool_state == SPA_LOAD_IMPORT) {\n\t\tzfs_stats.import_drops.fmds_value.ui64++;\n\t\tfmd_hdl_debug(hdl, \"ignoring '%s' during import\", class);\n\t\treturn;\n\t}\n\n\t \n\tif (pool_state == SPA_LOAD_OPEN &&\n\t    (fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_CHECKSUM)) ||\n\t    fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO)) ||\n\t    fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_PROBE_FAILURE)))) {\n\t\tfmd_hdl_debug(hdl, \"ignoring '%s' during pool open\", class);\n\t\tzfs_stats.dev_drops.fmds_value.ui64++;\n\t\treturn;\n\t}\n\n\t \n\tif (nvlist_lookup_string(nvl, FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE,\n\t    &type) == 0) {\n\t\tif (strcmp(type, VDEV_TYPE_DISK) != 0 &&\n\t\t    strcmp(type, VDEV_TYPE_FILE) != 0) {\n\t\t\tzfs_stats.vdev_drops.fmds_value.ui64++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\t(void) nvlist_lookup_uint64(nvl,\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_GUID, &pool_guid);\n\tif (nvlist_lookup_uint64(nvl,\n\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID, &vdev_guid) != 0)\n\t\tvdev_guid = 0;\n\tif (nvlist_lookup_uint64(nvl, FM_EREPORT_ENA, &ena) != 0)\n\t\tena = 0;\n\n\tzfs_ereport_when(hdl, nvl, &er_when);\n\n\tfor (zcp = uu_list_first(zfs_cases); zcp != NULL;\n\t    zcp = uu_list_next(zfs_cases, zcp)) {\n\t\tif (zcp->zc_data.zc_pool_guid == pool_guid) {\n\t\t\tpool_found = B_TRUE;\n\t\t\tpool_load = zcp->zc_when;\n\t\t}\n\t\tif (zcp->zc_data.zc_vdev_guid == vdev_guid)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (pool_found && timeval_earlier(&er_when, &pool_load)) {\n\t\tfmd_hdl_debug(hdl, \"ignoring pool %llx, \"\n\t\t    \"ereport time %lld.%lld, pool load time = %lld.%lld\",\n\t\t    pool_guid, er_when.ertv_sec, er_when.ertv_nsec,\n\t\t    pool_load.ertv_sec, pool_load.ertv_nsec);\n\t\tzfs_stats.old_drops.fmds_value.ui64++;\n\t\treturn;\n\t}\n\n\tif (!pool_found) {\n\t\t \n\t\tlibzfs_handle_t *zhdl = fmd_hdl_getspecific(hdl);\n\t\tstruct load_time_arg la;\n\n\t\tla.lt_guid = pool_guid;\n\t\tla.lt_time = &pool_load;\n\t\tla.lt_found = B_FALSE;\n\n\t\tif (zhdl != NULL &&\n\t\t    zpool_iter(zhdl, zpool_find_load_time, &la) == 0 &&\n\t\t    la.lt_found == B_TRUE) {\n\t\t\tpool_found = B_TRUE;\n\n\t\t\tif (timeval_earlier(&er_when, &pool_load)) {\n\t\t\t\tfmd_hdl_debug(hdl, \"ignoring pool %llx, \"\n\t\t\t\t    \"ereport time %lld.%lld, \"\n\t\t\t\t    \"pool load time = %lld.%lld\",\n\t\t\t\t    pool_guid, er_when.ertv_sec,\n\t\t\t\t    er_when.ertv_nsec, pool_load.ertv_sec,\n\t\t\t\t    pool_load.ertv_nsec);\n\t\t\t\tzfs_stats.old_drops.fmds_value.ui64++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zcp == NULL) {\n\t\tfmd_case_t *cs;\n\t\tzfs_case_data_t data = { 0 };\n\n\t\t \n\t\tif (isresource) {\n\t\t\tzfs_stats.resource_drops.fmds_value.ui64++;\n\t\t\tfmd_hdl_debug(hdl, \"discarding '%s for vdev %llu\",\n\t\t\t    class, vdev_guid);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (strcmp(class,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_DATA)) == 0 ||\n\t\t    strcmp(class,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_CONFIG_CACHE_WRITE)) == 0 ||\n\t\t    strcmp(class,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_DELAY)) == 0) {\n\t\t\tzfs_stats.resource_drops.fmds_value.ui64++;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcs = fmd_case_open(hdl, NULL);\n\n\t\tfmd_hdl_debug(hdl, \"opening case for vdev %llu due to '%s'\",\n\t\t    vdev_guid, class);\n\n\t\t \n\t\tfmd_buf_create(hdl, cs, CASE_DATA, sizeof (zfs_case_data_t));\n\n\t\tdata.zc_version = CASE_DATA_VERSION_SERD;\n\t\tdata.zc_ena = ena;\n\t\tdata.zc_pool_guid = pool_guid;\n\t\tdata.zc_vdev_guid = vdev_guid;\n\t\tdata.zc_pool_state = (int)pool_state;\n\n\t\tfmd_buf_write(hdl, cs, CASE_DATA, &data, sizeof (data));\n\n\t\tzcp = zfs_case_unserialize(hdl, cs);\n\t\tassert(zcp != NULL);\n\t\tif (pool_found)\n\t\t\tzcp->zc_when = pool_load;\n\t}\n\n\tif (isresource) {\n\t\tfmd_hdl_debug(hdl, \"resource event '%s'\", class);\n\n\t\tif (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_RSRC(FM_RESOURCE_AUTOREPLACE))) {\n\t\t\t \n\t\t\tfmd_case_close(hdl, zcp->zc_case);\n\t\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_RSRC(FM_RESOURCE_REMOVED))) {\n\t\t\t \n\t\t\tif (zcp->zc_data.zc_has_remove_timer) {\n\t\t\t\tfmd_timer_remove(hdl, zcp->zc_remove_timer);\n\t\t\t\tzcp->zc_data.zc_has_remove_timer = 0;\n\t\t\t\tzfs_case_serialize(zcp);\n\t\t\t}\n\t\t\tif (zcp->zc_data.zc_serd_io[0] != '\\0')\n\t\t\t\tfmd_serd_reset(hdl, zcp->zc_data.zc_serd_io);\n\t\t\tif (zcp->zc_data.zc_serd_checksum[0] != '\\0')\n\t\t\t\tfmd_serd_reset(hdl,\n\t\t\t\t    zcp->zc_data.zc_serd_checksum);\n\t\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_RSRC(FM_RESOURCE_STATECHANGE))) {\n\t\t\tuint64_t state = 0;\n\n\t\t\tif (zcp != NULL &&\n\t\t\t    nvlist_lookup_uint64(nvl,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_STATE, &state) == 0 &&\n\t\t\t    state == VDEV_STATE_HEALTHY) {\n\t\t\t\tfmd_hdl_debug(hdl, \"closing case after a \"\n\t\t\t\t    \"device statechange to healthy\");\n\t\t\t\tfmd_case_close(hdl, zcp->zc_case);\n\t\t\t}\n\t\t}\n\t\tzfs_stats.resource_drops.fmds_value.ui64++;\n\t\treturn;\n\t}\n\n\t \n\tfmd_case_add_ereport(hdl, zcp->zc_case, ep);\n\n\t \n\tif (fmd_case_solved(hdl, zcp->zc_case))\n\t\treturn;\n\n\tfmd_hdl_debug(hdl, \"error event '%s'\", class);\n\n\t \n\tif (fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_POOL))) {\n\t\t \n\t\tfor (dcp = uu_list_first(zfs_cases); dcp != NULL;\n\t\t    dcp = uu_list_next(zfs_cases, dcp)) {\n\t\t\tif (dcp->zc_data.zc_pool_guid ==\n\t\t\t    zcp->zc_data.zc_pool_guid &&\n\t\t\t    dcp->zc_data.zc_vdev_guid != 0)\n\t\t\t\tfmd_case_close(hdl, dcp->zc_case);\n\t\t}\n\n\t\tzfs_case_solve(hdl, zcp, \"fault.fs.zfs.pool\");\n\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_LOG_REPLAY))) {\n\t\t \n\t\tzfs_case_solve(hdl, zcp, \"fault.fs.zfs.log_replay\");\n\t} else if (fmd_nvl_class_match(hdl, nvl, \"ereport.fs.zfs.vdev.*\")) {\n\t\t \n\t\tzfs_case_solve(hdl, zcp, \"fault.fs.zfs.device\");\n\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO)) ||\n\t    fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_CHECKSUM)) ||\n\t    fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO_FAILURE)) ||\n\t    fmd_nvl_class_match(hdl, nvl,\n\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_PROBE_FAILURE))) {\n\t\tconst char *failmode = NULL;\n\t\tboolean_t checkremove = B_FALSE;\n\t\tuint32_t pri = 0;\n\t\tint32_t flags = 0;\n\n\t\t \n\t\tif (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO))) {\n\t\t\tif (zcp->zc_data.zc_serd_io[0] == '\\0') {\n\t\t\t\tif (nvlist_lookup_uint64(nvl,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_IO_N,\n\t\t\t\t    &io_n) != 0) {\n\t\t\t\t\tio_n = DEFAULT_IO_N;\n\t\t\t\t}\n\t\t\t\tif (nvlist_lookup_uint64(nvl,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_IO_T,\n\t\t\t\t    &io_t) != 0) {\n\t\t\t\t\tio_t = DEFAULT_IO_T;\n\t\t\t\t}\n\t\t\t\tzfs_serd_name(zcp->zc_data.zc_serd_io,\n\t\t\t\t    pool_guid, vdev_guid, \"io\");\n\t\t\t\tfmd_serd_create(hdl, zcp->zc_data.zc_serd_io,\n\t\t\t\t    io_n,\n\t\t\t\t    SEC2NSEC(io_t));\n\t\t\t\tzfs_case_serialize(zcp);\n\t\t\t}\n\t\t\tif (fmd_serd_record(hdl, zcp->zc_data.zc_serd_io, ep))\n\t\t\t\tcheckremove = B_TRUE;\n\t\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_CHECKSUM))) {\n\t\t\t \n\t\t\tif (((nvlist_lookup_uint32(nvl,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_PRIORITY, &pri) == 0) &&\n\t\t\t    (pri == ZIO_PRIORITY_SCRUB ||\n\t\t\t    pri == ZIO_PRIORITY_REBUILD)) ||\n\t\t\t    ((nvlist_lookup_int32(nvl,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_FLAGS, &flags) == 0) &&\n\t\t\t    (flags & (ZIO_FLAG_SCRUB | ZIO_FLAG_RESILVER)))) {\n\t\t\t\tfmd_hdl_debug(hdl, \"ignoring '%s' for \"\n\t\t\t\t    \"scrub/resilver I/O\", class);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (zcp->zc_data.zc_serd_checksum[0] == '\\0') {\n\t\t\t\tif (nvlist_lookup_uint64(nvl,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_CKSUM_N,\n\t\t\t\t    &checksum_n) != 0) {\n\t\t\t\t\tchecksum_n = DEFAULT_CHECKSUM_N;\n\t\t\t\t}\n\t\t\t\tif (nvlist_lookup_uint64(nvl,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_CKSUM_T,\n\t\t\t\t    &checksum_t) != 0) {\n\t\t\t\t\tchecksum_t = DEFAULT_CHECKSUM_T;\n\t\t\t\t}\n\n\t\t\t\tzfs_serd_name(zcp->zc_data.zc_serd_checksum,\n\t\t\t\t    pool_guid, vdev_guid, \"checksum\");\n\t\t\t\tfmd_serd_create(hdl,\n\t\t\t\t    zcp->zc_data.zc_serd_checksum,\n\t\t\t\t    checksum_n,\n\t\t\t\t    SEC2NSEC(checksum_t));\n\t\t\t\tzfs_case_serialize(zcp);\n\t\t\t}\n\t\t\tif (fmd_serd_record(hdl,\n\t\t\t    zcp->zc_data.zc_serd_checksum, ep)) {\n\t\t\t\tzfs_case_solve(hdl, zcp,\n\t\t\t\t    \"fault.fs.zfs.vdev.checksum\");\n\t\t\t}\n\t\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO_FAILURE)) &&\n\t\t    (nvlist_lookup_string(nvl,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_POOL_FAILMODE, &failmode) == 0) &&\n\t\t    failmode != NULL) {\n\t\t\tif (strncmp(failmode, FM_EREPORT_FAILMODE_CONTINUE,\n\t\t\t    strlen(FM_EREPORT_FAILMODE_CONTINUE)) == 0) {\n\t\t\t\tzfs_case_solve(hdl, zcp,\n\t\t\t\t    \"fault.fs.zfs.io_failure_continue\");\n\t\t\t} else if (strncmp(failmode, FM_EREPORT_FAILMODE_WAIT,\n\t\t\t    strlen(FM_EREPORT_FAILMODE_WAIT)) == 0) {\n\t\t\t\tzfs_case_solve(hdl, zcp,\n\t\t\t\t    \"fault.fs.zfs.io_failure_wait\");\n\t\t\t}\n\t\t} else if (fmd_nvl_class_match(hdl, nvl,\n\t\t    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_PROBE_FAILURE))) {\n#ifndef __linux__\n\t\t\t \n\t\t\tcheckremove = B_TRUE;\n#endif\n\t\t}\n\n\t\t \n\t\tif (checkremove) {\n\t\t\tif (zcp->zc_data.zc_has_remove_timer)\n\t\t\t\tfmd_timer_remove(hdl, zcp->zc_remove_timer);\n\t\t\tzcp->zc_remove_timer = fmd_timer_install(hdl, zcp, NULL,\n\t\t\t    zfs_remove_timeout);\n\t\t\tif (!zcp->zc_data.zc_has_remove_timer) {\n\t\t\t\tzcp->zc_data.zc_has_remove_timer = 1;\n\t\t\t\tzfs_case_serialize(zcp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nzfs_fm_timeout(fmd_hdl_t *hdl, id_t id, void *data)\n{\n\tzfs_case_t *zcp = data;\n\n\tif (id == zcp->zc_remove_timer)\n\t\tzfs_case_solve(hdl, zcp, \"fault.fs.zfs.vdev.io\");\n}\n\n \nstatic void\nzfs_fm_close(fmd_hdl_t *hdl, fmd_case_t *cs)\n{\n\tzfs_case_t *zcp = fmd_case_getspecific(hdl, cs);\n\n\tif (zcp->zc_data.zc_serd_checksum[0] != '\\0')\n\t\tfmd_serd_destroy(hdl, zcp->zc_data.zc_serd_checksum);\n\tif (zcp->zc_data.zc_serd_io[0] != '\\0')\n\t\tfmd_serd_destroy(hdl, zcp->zc_data.zc_serd_io);\n\tif (zcp->zc_data.zc_has_remove_timer)\n\t\tfmd_timer_remove(hdl, zcp->zc_remove_timer);\n\n\tuu_list_remove(zfs_cases, zcp);\n\tuu_list_node_fini(zcp, &zcp->zc_node, zfs_case_pool);\n\tfmd_hdl_free(hdl, zcp, sizeof (zfs_case_t));\n}\n\n \nstatic void\nzfs_fm_gc(fmd_hdl_t *hdl)\n{\n\tzfs_purge_cases(hdl);\n}\n\nstatic const fmd_hdl_ops_t fmd_ops = {\n\tzfs_fm_recv,\t \n\tzfs_fm_timeout,\t \n\tzfs_fm_close,\t \n\tNULL,\t\t \n\tzfs_fm_gc,\t \n};\n\nstatic const fmd_prop_t fmd_props[] = {\n\t{ \"checksum_N\", FMD_TYPE_UINT32, \"10\" },\n\t{ \"checksum_T\", FMD_TYPE_TIME, \"10min\" },\n\t{ \"io_N\", FMD_TYPE_UINT32, \"10\" },\n\t{ \"io_T\", FMD_TYPE_TIME, \"10min\" },\n\t{ \"remove_timeout\", FMD_TYPE_TIME, \"15sec\" },\n\t{ NULL, 0, NULL }\n};\n\nstatic const fmd_hdl_info_t fmd_info = {\n\t\"ZFS Diagnosis Engine\", \"1.0\", &fmd_ops, fmd_props\n};\n\nvoid\n_zfs_diagnosis_init(fmd_hdl_t *hdl)\n{\n\tlibzfs_handle_t *zhdl;\n\n\tif ((zhdl = libzfs_init()) == NULL)\n\t\treturn;\n\n\tif ((zfs_case_pool = uu_list_pool_create(\"zfs_case_pool\",\n\t    sizeof (zfs_case_t), offsetof(zfs_case_t, zc_node),\n\t    NULL, UU_LIST_POOL_DEBUG)) == NULL) {\n\t\tlibzfs_fini(zhdl);\n\t\treturn;\n\t}\n\n\tif ((zfs_cases = uu_list_create(zfs_case_pool, NULL,\n\t    UU_LIST_DEBUG)) == NULL) {\n\t\tuu_list_pool_destroy(zfs_case_pool);\n\t\tlibzfs_fini(zhdl);\n\t\treturn;\n\t}\n\n\tif (fmd_hdl_register(hdl, FMD_API_VERSION, &fmd_info) != 0) {\n\t\tuu_list_destroy(zfs_cases);\n\t\tuu_list_pool_destroy(zfs_case_pool);\n\t\tlibzfs_fini(zhdl);\n\t\treturn;\n\t}\n\n\tfmd_hdl_setspecific(hdl, zhdl);\n\n\t(void) fmd_stat_create(hdl, FMD_STAT_NOALLOC, sizeof (zfs_stats) /\n\t    sizeof (fmd_stat_t), (fmd_stat_t *)&zfs_stats);\n\n\tzfs_remove_timeout = fmd_prop_get_int64(hdl, \"remove_timeout\");\n}\n\nvoid\n_zfs_diagnosis_fini(fmd_hdl_t *hdl)\n{\n\tzfs_case_t *zcp;\n\tuu_list_walk_t *walk;\n\tlibzfs_handle_t *zhdl;\n\n\t \n\twalk = uu_list_walk_start(zfs_cases, UU_WALK_ROBUST);\n\twhile ((zcp = uu_list_walk_next(walk)) != NULL) {\n\t\tfmd_hdl_debug(hdl, \"removing case ena %llu\",\n\t\t    (long long unsigned)zcp->zc_data.zc_ena);\n\t\tuu_list_remove(zfs_cases, zcp);\n\t\tuu_list_node_fini(zcp, &zcp->zc_node, zfs_case_pool);\n\t\tfmd_hdl_free(hdl, zcp, sizeof (zfs_case_t));\n\t}\n\tuu_list_walk_end(walk);\n\n\tuu_list_destroy(zfs_cases);\n\tuu_list_pool_destroy(zfs_case_pool);\n\n\tzhdl = fmd_hdl_getspecific(hdl);\n\tlibzfs_fini(zhdl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}