{
  "module_name": "zfs_agents.c",
  "hash_id": "c1885b5e51885aafcf1226d82dd01a910f633752e4f1b22e3047ed4086a3c71a",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/agents/zfs_agents.c",
  "human_readable_source": " \n\n \n\n#include <libnvpair.h>\n#include <libzfs.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/list.h>\n#include <sys/time.h>\n#include <sys/sysevent/eventdefs.h>\n#include <sys/sysevent/dev.h>\n#include <sys/fm/protocol.h>\n#include <sys/fm/fs/zfs.h>\n#include <pthread.h>\n#include <unistd.h>\n\n#include \"zfs_agents.h\"\n#include \"fmd_api.h\"\n#include \"../zed_log.h\"\n\n \n\nstatic pthread_mutex_t\tagent_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t\tagent_cond = PTHREAD_COND_INITIALIZER;\nstatic list_t\t\tagent_events;\t \nstatic int\t\tagent_exiting;\n\ntypedef struct agent_event {\n\tchar\t\tae_class[64];\n\tchar\t\tae_subclass[32];\n\tnvlist_t\t*ae_nvl;\n\tlist_node_t\tae_node;\n} agent_event_t;\n\npthread_t g_agents_tid;\n\nlibzfs_handle_t *g_zfs_hdl;\n\n \ntypedef enum device_type {\n\tDEVICE_TYPE_L2ARC,\t \n\tDEVICE_TYPE_SPARE,\t \n\tDEVICE_TYPE_PRIMARY\t \n} device_type_t;\n\ntypedef struct guid_search {\n\tuint64_t\tgs_pool_guid;\n\tuint64_t\tgs_vdev_guid;\n\tconst char\t*gs_devid;\n\tdevice_type_t\tgs_vdev_type;\n\tuint64_t\tgs_vdev_expandtime;\t \n} guid_search_t;\n\n \nstatic boolean_t\nzfs_agent_iter_vdev(zpool_handle_t *zhp, nvlist_t *nvl, void *arg)\n{\n\tguid_search_t *gsp = arg;\n\tconst char *path = NULL;\n\tuint_t c, children;\n\tnvlist_t **child;\n\tuint64_t vdev_guid;\n\n\t \n\tif (nvlist_lookup_nvlist_array(nvl, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif (zfs_agent_iter_vdev(zhp, child[c], gsp)) {\n\t\t\t\tgsp->gs_vdev_type = DEVICE_TYPE_PRIMARY;\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (nvlist_lookup_nvlist_array(nvl, ZPOOL_CONFIG_SPARES,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif (zfs_agent_iter_vdev(zhp, child[c], gsp)) {\n\t\t\t\tgsp->gs_vdev_type = DEVICE_TYPE_SPARE;\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\tif (nvlist_lookup_nvlist_array(nvl, ZPOOL_CONFIG_L2CACHE,\n\t    &child, &children) == 0) {\n\t\tfor (c = 0; c < children; c++) {\n\t\t\tif (zfs_agent_iter_vdev(zhp, child[c], gsp)) {\n\t\t\t\tgsp->gs_vdev_type = DEVICE_TYPE_L2ARC;\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (gsp->gs_devid != NULL &&\n\t    (nvlist_lookup_string(nvl, ZPOOL_CONFIG_DEVID, &path) == 0) &&\n\t    (strcmp(gsp->gs_devid, path) == 0)) {\n\t\t(void) nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_GUID,\n\t\t    &gsp->gs_vdev_guid);\n\t\t(void) nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_EXPANSION_TIME,\n\t\t    &gsp->gs_vdev_expandtime);\n\t\treturn (B_TRUE);\n\t}\n\t \n\telse if (gsp->gs_vdev_guid != 0 && gsp->gs_devid == NULL &&\n\t    nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_GUID, &vdev_guid) == 0 &&\n\t    gsp->gs_vdev_guid == vdev_guid) {\n\t\t(void) nvlist_lookup_string(nvl, ZPOOL_CONFIG_DEVID,\n\t\t    &gsp->gs_devid);\n\t\t(void) nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_EXPANSION_TIME,\n\t\t    &gsp->gs_vdev_expandtime);\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic int\nzfs_agent_iter_pool(zpool_handle_t *zhp, void *arg)\n{\n\tguid_search_t *gsp = arg;\n\tnvlist_t *config, *nvl;\n\n\t \n\tif ((config = zpool_get_config(zhp, NULL)) != NULL) {\n\t\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE,\n\t\t    &nvl) == 0) {\n\t\t\t(void) zfs_agent_iter_vdev(zhp, nvl, gsp);\n\t\t}\n\t}\n\t \n\tif (gsp->gs_vdev_guid && gsp->gs_devid) {\n\t\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID,\n\t\t    &gsp->gs_pool_guid);\n\t}\n\n\tzpool_close(zhp);\n\treturn (gsp->gs_devid != NULL && gsp->gs_vdev_guid != 0);\n}\n\nvoid\nzfs_agent_post_event(const char *class, const char *subclass, nvlist_t *nvl)\n{\n\tagent_event_t *event;\n\n\tif (subclass == NULL)\n\t\tsubclass = \"\";\n\n\tevent = malloc(sizeof (agent_event_t));\n\tif (event == NULL || nvlist_dup(nvl, &event->ae_nvl, 0) != 0) {\n\t\tif (event)\n\t\t\tfree(event);\n\t\treturn;\n\t}\n\n\tif (strcmp(class, \"sysevent.fs.zfs.vdev_check\") == 0) {\n\t\tclass = EC_ZFS;\n\t\tsubclass = ESC_ZFS_VDEV_CHECK;\n\t}\n\n\t \n\tif ((strcmp(class, EC_DEV_REMOVE) == 0) &&\n\t    (strcmp(subclass, ESC_DISK) == 0) &&\n\t    (nvlist_exists(nvl, ZFS_EV_VDEV_GUID) ||\n\t    nvlist_exists(nvl, DEV_IDENTIFIER))) {\n\t\tnvlist_t *payload = event->ae_nvl;\n\t\tstruct timeval tv;\n\t\tint64_t tod[2];\n\t\tuint64_t pool_guid = 0, vdev_guid = 0;\n\t\tguid_search_t search = { 0 };\n\t\tdevice_type_t devtype = DEVICE_TYPE_PRIMARY;\n\t\tconst char *devid = NULL;\n\n\t\tclass = \"resource.fs.zfs.removed\";\n\t\tsubclass = \"\";\n\n\t\t(void) nvlist_add_string(payload, FM_CLASS, class);\n\t\t(void) nvlist_lookup_string(nvl, DEV_IDENTIFIER, &devid);\n\t\t(void) nvlist_lookup_uint64(nvl, ZFS_EV_POOL_GUID, &pool_guid);\n\t\t(void) nvlist_lookup_uint64(nvl, ZFS_EV_VDEV_GUID, &vdev_guid);\n\n\t\t(void) gettimeofday(&tv, NULL);\n\t\ttod[0] = tv.tv_sec;\n\t\ttod[1] = tv.tv_usec;\n\t\t(void) nvlist_add_int64_array(payload, FM_EREPORT_TIME, tod, 2);\n\n\t\t \n\t\tif (devid == NULL || pool_guid == 0 || vdev_guid == 0) {\n\t\t\tif (devid == NULL)\n\t\t\t\tsearch.gs_vdev_guid = vdev_guid;\n\t\t\telse\n\t\t\t\tsearch.gs_devid = devid;\n\t\t\tzpool_iter(g_zfs_hdl, zfs_agent_iter_pool, &search);\n\t\t\tif (devid == NULL)\n\t\t\t\tdevid = search.gs_devid;\n\t\t\tif (pool_guid == 0)\n\t\t\t\tpool_guid = search.gs_pool_guid;\n\t\t\tif (vdev_guid == 0)\n\t\t\t\tvdev_guid = search.gs_vdev_guid;\n\t\t\tdevtype = search.gs_vdev_type;\n\t\t}\n\n\t\t \n\t\tif (search.gs_vdev_expandtime != 0 &&\n\t\t    search.gs_vdev_expandtime + 10 > tv.tv_sec) {\n\t\t\tzed_log_msg(LOG_INFO, \"agent post event: ignoring '%s' \"\n\t\t\t    \"for recently expanded device '%s'\", EC_DEV_REMOVE,\n\t\t\t    devid);\n\t\t\tfnvlist_free(payload);\n\t\t\tfree(event);\n\t\t\tgoto out;\n\t\t}\n\n\t\t(void) nvlist_add_uint64(payload,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_POOL_GUID, pool_guid);\n\t\t(void) nvlist_add_uint64(payload,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID, vdev_guid);\n\t\tswitch (devtype) {\n\t\tcase DEVICE_TYPE_L2ARC:\n\t\t\t(void) nvlist_add_string(payload,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE,\n\t\t\t    VDEV_TYPE_L2CACHE);\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_SPARE:\n\t\t\t(void) nvlist_add_string(payload,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE, VDEV_TYPE_SPARE);\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_PRIMARY:\n\t\t\t(void) nvlist_add_string(payload,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE, VDEV_TYPE_DISK);\n\t\t\tbreak;\n\t\t}\n\n\t\tzed_log_msg(LOG_INFO, \"agent post event: mapping '%s' to '%s'\",\n\t\t    EC_DEV_REMOVE, class);\n\t}\n\n\t(void) strlcpy(event->ae_class, class, sizeof (event->ae_class));\n\t(void) strlcpy(event->ae_subclass, subclass,\n\t    sizeof (event->ae_subclass));\n\n\t(void) pthread_mutex_lock(&agent_lock);\n\tlist_insert_tail(&agent_events, event);\n\t(void) pthread_mutex_unlock(&agent_lock);\n\nout:\n\t(void) pthread_cond_signal(&agent_cond);\n}\n\nstatic void\nzfs_agent_dispatch(const char *class, const char *subclass, nvlist_t *nvl)\n{\n\t \n\tif (strstr(class, \"ereport.fs.zfs.\") != NULL ||\n\t    strstr(class, \"resource.fs.zfs.\") != NULL ||\n\t    strcmp(class, \"sysevent.fs.zfs.vdev_remove\") == 0 ||\n\t    strcmp(class, \"sysevent.fs.zfs.vdev_remove_dev\") == 0 ||\n\t    strcmp(class, \"sysevent.fs.zfs.pool_destroy\") == 0) {\n\t\tfmd_module_recv(fmd_module_hdl(\"zfs-diagnosis\"), nvl, class);\n\t}\n\n\t \n\tif (strcmp(class, FM_LIST_SUSPECT_CLASS) == 0 ||\n\t    strcmp(class, \"resource.fs.zfs.removed\") == 0 ||\n\t    strcmp(class, \"resource.fs.zfs.statechange\") == 0 ||\n\t    strcmp(class, \"sysevent.fs.zfs.vdev_remove\")  == 0) {\n\t\tfmd_module_recv(fmd_module_hdl(\"zfs-retire\"), nvl, class);\n\t}\n\n\t \n\tif (strstr(class, \"EC_dev_\") != NULL ||\n\t    strcmp(class, EC_ZFS) == 0) {\n\t\t(void) zfs_slm_event(class, subclass, nvl);\n\t}\n}\n\n \nstatic void *\nzfs_agent_consumer_thread(void *arg)\n{\n\t(void) arg;\n\n\tfor (;;) {\n\t\tagent_event_t *event;\n\n\t\t(void) pthread_mutex_lock(&agent_lock);\n\n\t\t \n\t\twhile (!agent_exiting && list_is_empty(&agent_events))\n\t\t\t(void) pthread_cond_wait(&agent_cond, &agent_lock);\n\n\t\tif (agent_exiting) {\n\t\t\t(void) pthread_mutex_unlock(&agent_lock);\n\t\t\tzed_log_msg(LOG_INFO, \"zfs_agent_consumer_thread: \"\n\t\t\t    \"exiting\");\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tif ((event = list_remove_head(&agent_events)) != NULL) {\n\t\t\t(void) pthread_mutex_unlock(&agent_lock);\n\n\t\t\t \n\t\t\tzfs_agent_dispatch(event->ae_class, event->ae_subclass,\n\t\t\t    event->ae_nvl);\n\n\t\t\tnvlist_free(event->ae_nvl);\n\t\t\tfree(event);\n\t\t\tcontinue;\n\t\t}\n\n\t\t(void) pthread_mutex_unlock(&agent_lock);\n\t}\n\n\treturn (NULL);\n}\n\nvoid\nzfs_agent_init(libzfs_handle_t *zfs_hdl)\n{\n\tfmd_hdl_t *hdl;\n\n\tg_zfs_hdl = zfs_hdl;\n\n\tif (zfs_slm_init() != 0)\n\t\tzed_log_die(\"Failed to initialize zfs slm\");\n\tzed_log_msg(LOG_INFO, \"Add Agent: init\");\n\n\thdl = fmd_module_hdl(\"zfs-diagnosis\");\n\t_zfs_diagnosis_init(hdl);\n\tif (!fmd_module_initialized(hdl))\n\t\tzed_log_die(\"Failed to initialize zfs diagnosis\");\n\n\thdl = fmd_module_hdl(\"zfs-retire\");\n\t_zfs_retire_init(hdl);\n\tif (!fmd_module_initialized(hdl))\n\t\tzed_log_die(\"Failed to initialize zfs retire\");\n\n\tlist_create(&agent_events, sizeof (agent_event_t),\n\t    offsetof(struct agent_event, ae_node));\n\n\tif (pthread_create(&g_agents_tid, NULL, zfs_agent_consumer_thread,\n\t    NULL) != 0) {\n\t\tlist_destroy(&agent_events);\n\t\tzed_log_die(\"Failed to initialize agents\");\n\t}\n\tpthread_setname_np(g_agents_tid, \"agents\");\n}\n\nvoid\nzfs_agent_fini(void)\n{\n\tfmd_hdl_t *hdl;\n\tagent_event_t *event;\n\n\tagent_exiting = 1;\n\t(void) pthread_cond_signal(&agent_cond);\n\n\t \n\t(void) pthread_join(g_agents_tid, NULL);\n\n\t \n\twhile ((event = list_remove_head(&agent_events)) != NULL) {\n\t\tnvlist_free(event->ae_nvl);\n\t\tfree(event);\n\t}\n\n\tlist_destroy(&agent_events);\n\n\tif ((hdl = fmd_module_hdl(\"zfs-retire\")) != NULL) {\n\t\t_zfs_retire_fini(hdl);\n\t\tfmd_hdl_unregister(hdl);\n\t}\n\tif ((hdl = fmd_module_hdl(\"zfs-diagnosis\")) != NULL) {\n\t\t_zfs_diagnosis_fini(hdl);\n\t\tfmd_hdl_unregister(hdl);\n\t}\n\n\tzed_log_msg(LOG_INFO, \"Add Agent: fini\");\n\tzfs_slm_fini();\n\n\tg_zfs_hdl = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}