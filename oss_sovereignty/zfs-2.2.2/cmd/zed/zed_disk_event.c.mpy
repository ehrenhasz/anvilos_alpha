{
  "module_name": "zed_disk_event.c",
  "hash_id": "f9107bc0c1cdf947f6fd8b117e19d6ffcec9e723c12be16856a73d016d0e66e6",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/zed_disk_event.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_LIBUDEV\n\n#include <errno.h>\n#include <fcntl.h>\n#include <libnvpair.h>\n#include <libudev.h>\n#include <libzfs.h>\n#include <libzutil.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <sys/sysevent/eventdefs.h>\n#include <sys/sysevent/dev.h>\n\n#include \"zed_log.h\"\n#include \"zed_disk_event.h\"\n#include \"agents/zfs_agents.h\"\n\n \n\npthread_t g_mon_tid;\nstruct udev *g_udev;\nstruct udev_monitor *g_mon;\n\n\n#define\tDEV_BYID_PATH\t\"/dev/disk/by-id/\"\n\n \n#define\tMINIMUM_SECTORS\t\t131072ULL\n\n\n \nstatic void\nzed_udev_event(const char *class, const char *subclass, nvlist_t *nvl)\n{\n\tconst char *strval;\n\tuint64_t numval;\n\n\tzed_log_msg(LOG_INFO, \"zed_disk_event:\");\n\tzed_log_msg(LOG_INFO, \"\\tclass: %s\", class);\n\tzed_log_msg(LOG_INFO, \"\\tsubclass: %s\", subclass);\n\tif (nvlist_lookup_string(nvl, DEV_NAME, &strval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", DEV_NAME, strval);\n\tif (nvlist_lookup_string(nvl, DEV_PATH, &strval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", DEV_PATH, strval);\n\tif (nvlist_lookup_string(nvl, DEV_IDENTIFIER, &strval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", DEV_IDENTIFIER, strval);\n\tif (nvlist_lookup_boolean(nvl, DEV_IS_PART) == B_TRUE)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: B_TRUE\", DEV_IS_PART);\n\tif (nvlist_lookup_string(nvl, DEV_PHYS_PATH, &strval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %s\", DEV_PHYS_PATH, strval);\n\tif (nvlist_lookup_uint64(nvl, DEV_SIZE, &numval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %llu\", DEV_SIZE, numval);\n\tif (nvlist_lookup_uint64(nvl, DEV_PARENT_SIZE, &numval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %llu\", DEV_PARENT_SIZE, numval);\n\tif (nvlist_lookup_uint64(nvl, ZFS_EV_POOL_GUID, &numval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %llu\", ZFS_EV_POOL_GUID, numval);\n\tif (nvlist_lookup_uint64(nvl, ZFS_EV_VDEV_GUID, &numval) == 0)\n\t\tzed_log_msg(LOG_INFO, \"\\t%s: %llu\", ZFS_EV_VDEV_GUID, numval);\n\n\t(void) zfs_agent_post_event(class, subclass, nvl);\n}\n\n \nstatic nvlist_t *\ndev_event_nvlist(struct udev_device *dev)\n{\n\tnvlist_t *nvl;\n\tchar strval[128];\n\tconst char *value, *path;\n\tuint64_t guid;\n\n\tif (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\treturn (NULL);\n\n\tif (zfs_device_get_devid(dev, strval, sizeof (strval)) == 0)\n\t\t(void) nvlist_add_string(nvl, DEV_IDENTIFIER, strval);\n\tif (zfs_device_get_physical(dev, strval, sizeof (strval)) == 0)\n\t\t(void) nvlist_add_string(nvl, DEV_PHYS_PATH, strval);\n\tif ((path = udev_device_get_devnode(dev)) != NULL)\n\t\t(void) nvlist_add_string(nvl, DEV_NAME, path);\n\tif ((value = udev_device_get_devpath(dev)) != NULL)\n\t\t(void) nvlist_add_string(nvl, DEV_PATH, value);\n\tvalue = udev_device_get_devtype(dev);\n\tif ((value != NULL && strcmp(\"partition\", value) == 0) ||\n\t    (udev_device_get_property_value(dev, \"ID_PART_ENTRY_NUMBER\")\n\t    != NULL)) {\n\t\t(void) nvlist_add_boolean(nvl, DEV_IS_PART);\n\t}\n\tif ((value = udev_device_get_sysattr_value(dev, \"size\")) != NULL) {\n\t\tuint64_t numval = DEV_BSIZE;\n\n\t\tnumval *= strtoull(value, NULL, 10);\n\t\t(void) nvlist_add_uint64(nvl, DEV_SIZE, numval);\n\n\t\t \n\t\tstruct udev_device *parent_dev = udev_device_get_parent(dev);\n\t\tif ((value = udev_device_get_sysattr_value(parent_dev, \"size\"))\n\t\t    != NULL) {\n\t\t\tuint64_t numval = DEV_BSIZE;\n\n\t\t\tnumval *= strtoull(value, NULL, 10);\n\t\t\t(void) nvlist_add_uint64(nvl, DEV_PARENT_SIZE, numval);\n\t\t}\n\t}\n\n\t \n\tvalue = udev_device_get_property_value(dev, \"ID_FS_UUID\");\n\tif (value != NULL && (guid = strtoull(value, NULL, 10)) != 0)\n\t\t(void) nvlist_add_uint64(nvl, ZFS_EV_POOL_GUID, guid);\n\n\tvalue = udev_device_get_property_value(dev, \"ID_FS_UUID_SUB\");\n\tif (value != NULL && (guid = strtoull(value, NULL, 10)) != 0)\n\t\t(void) nvlist_add_uint64(nvl, ZFS_EV_VDEV_GUID, guid);\n\n\t \n\tif (!nvlist_exists(nvl, DEV_IDENTIFIER) &&\n\t    !nvlist_exists(nvl, ZFS_EV_VDEV_GUID)) {\n\t\tnvlist_free(nvl);\n\t\treturn (NULL);\n\t}\n\n\treturn (nvl);\n}\n\n \nstatic void *\nzed_udev_monitor(void *arg)\n{\n\tstruct udev_monitor *mon = arg;\n\tconst char *tmp;\n\tchar *tmp2;\n\n\tzed_log_msg(LOG_INFO, \"Waiting for new udev disk events...\");\n\n\twhile (1) {\n\t\tstruct udev_device *dev;\n\t\tconst char *action, *type, *part, *sectors;\n\t\tconst char *bus, *uuid, *devpath;\n\t\tconst char *class, *subclass;\n\t\tnvlist_t *nvl;\n\t\tboolean_t is_zfs = B_FALSE;\n\n\t\t \n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\n\t\t \n\t\tif ((dev = udev_monitor_receive_device(mon)) == NULL) {\n\t\t\tzed_log_msg(LOG_WARNING, \"zed_udev_monitor: receive \"\n\t\t\t    \"device error %d\", errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\n\t\t \n\t\ttype = udev_device_get_property_value(dev, \"ID_FS_TYPE\");\n\t\tif (type != NULL && type[0] != '\\0') {\n\t\t\tif (strcmp(type, \"zfs_member\") == 0) {\n\t\t\t\tis_zfs = B_TRUE;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tzed_log_msg(LOG_INFO, \"zed_udev_monitor: skip \"\n\t\t\t\t    \"%s (in use by %s)\",\n\t\t\t\t    udev_device_get_devnode(dev), type);\n\t\t\t\tudev_device_unref(dev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttype = udev_device_get_property_value(dev, \"DEVTYPE\");\n\t\tpart = udev_device_get_property_value(dev,\n\t\t    \"ID_PART_TABLE_TYPE\");\n\t\tif (type != NULL && type[0] != '\\0' &&\n\t\t    strcmp(type, \"disk\") == 0 &&\n\t\t    part != NULL && part[0] != '\\0') {\n\t\t\tconst char *devname =\n\t\t\t    udev_device_get_property_value(dev, \"DEVNAME\");\n\n\t\t\tif (strcmp(part, \"atari\") == 0) {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t    \"%s: %s is reporting an atari partition, \"\n\t\t\t\t    \"but we're going to assume it's a false \"\n\t\t\t\t    \"positive and still use it (issue #13497)\",\n\t\t\t\t    __func__, devname);\n\t\t\t} else {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t    \"%s: skip %s since it has a %s partition \"\n\t\t\t\t    \"already\", __func__, devname, part);\n\t\t\t\t \n\t\t\t\tudev_device_unref(dev);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tsectors = udev_device_get_property_value(dev,\n\t\t    \"ID_PART_ENTRY_SIZE\");\n\t\tif (sectors == NULL)\n\t\t\tsectors = udev_device_get_sysattr_value(dev, \"size\");\n\t\tif (sectors != NULL &&\n\t\t    strtoull(sectors, NULL, 10) < MINIMUM_SECTORS) {\n\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t    \"%s: %s sectors %s < %llu (minimum)\",\n\t\t\t    __func__,\n\t\t\t    udev_device_get_property_value(dev, \"DEVNAME\"),\n\t\t\t    sectors, MINIMUM_SECTORS);\n\t\t\tudev_device_unref(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbus = udev_device_get_property_value(dev, \"ID_BUS\");\n\t\tuuid = udev_device_get_property_value(dev, \"DM_UUID\");\n\t\tdevpath = udev_device_get_devpath(dev);\n\t\tif (!is_zfs && (bus == NULL && uuid == NULL &&\n\t\t    strstr(devpath, \"/nvme/\") == NULL)) {\n\t\t\tzed_log_msg(LOG_INFO, \"zed_udev_monitor: %s no devid \"\n\t\t\t    \"source\", udev_device_get_devnode(dev));\n\t\t\tudev_device_unref(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\taction = udev_device_get_action(dev);\n\t\tif (strcmp(action, \"add\") == 0) {\n\t\t\tclass = EC_DEV_ADD;\n\t\t\tsubclass = ESC_DISK;\n\t\t} else if (strcmp(action, \"remove\") == 0) {\n\t\t\tclass = EC_DEV_REMOVE;\n\t\t\tsubclass = ESC_DISK;\n\t\t} else if (strcmp(action, \"change\") == 0) {\n\t\t\tclass = EC_DEV_STATUS;\n\t\t\tsubclass = ESC_DEV_DLE;\n\t\t} else {\n\t\t\tzed_log_msg(LOG_WARNING, \"zed_udev_monitor: %s unknown\",\n\t\t\t    action);\n\t\t\tudev_device_unref(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (strcmp(class, EC_DEV_STATUS) == 0 &&\n\t\t    udev_device_get_property_value(dev, \"DM_UUID\") &&\n\t\t    udev_device_get_property_value(dev, \"MPATH_SBIN_PATH\")) {\n\t\t\ttmp = udev_device_get_devnode(dev);\n\t\t\ttmp2 = zfs_get_underlying_path(tmp);\n\t\t\tif (tmp && tmp2 && (strcmp(tmp, tmp2) != 0)) {\n\t\t\t\t \n\t\t\t\tclass = EC_DEV_ADD;\n\t\t\t\tsubclass = ESC_DISK;\n\t\t\t} else {\n\t\t\t\ttmp = udev_device_get_property_value(dev,\n\t\t\t\t    \"DM_NR_VALID_PATHS\");\n\t\t\t\t \n\t\t\t\tif (tmp != NULL && strcmp(tmp, \"0\") == 0) {\n\t\t\t\t\tclass = EC_DEV_REMOVE;\n\t\t\t\t\tsubclass = ESC_DISK;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(tmp2);\n\t\t}\n\n\t\t \n\t\tif (strcmp(class, EC_DEV_STATUS) == 0 &&\n\t\t    udev_device_get_property_value(dev, \"ID_VDEV\") &&\n\t\t    udev_device_get_property_value(dev, \"ID_MODEL\")) {\n\t\t\tconst char *id_model, *id_model_sd = \"scsi_debug\";\n\n\t\t\tid_model = udev_device_get_property_value(dev,\n\t\t\t    \"ID_MODEL\");\n\t\t\tif (strcmp(id_model, id_model_sd) == 0) {\n\t\t\t\tclass = EC_DEV_ADD;\n\t\t\t\tsubclass = ESC_DISK;\n\t\t\t}\n\t\t}\n\n\t\tif ((nvl = dev_event_nvlist(dev)) != NULL) {\n\t\t\tzed_udev_event(class, subclass, nvl);\n\t\t\tnvlist_free(nvl);\n\t\t}\n\n\t\tudev_device_unref(dev);\n\t}\n\n\treturn (NULL);\n}\n\nint\nzed_disk_event_init(void)\n{\n\tint fd, fflags;\n\n\tif ((g_udev = udev_new()) == NULL) {\n\t\tzed_log_msg(LOG_WARNING, \"udev_new failed (%d)\", errno);\n\t\treturn (-1);\n\t}\n\n\t \n\tg_mon = udev_monitor_new_from_netlink(g_udev, \"udev\");\n\tudev_monitor_filter_add_match_subsystem_devtype(g_mon, \"block\", \"disk\");\n\tudev_monitor_filter_add_match_subsystem_devtype(g_mon, \"block\",\n\t    \"partition\");\n\tudev_monitor_enable_receiving(g_mon);\n\n\t \n\tfd = udev_monitor_get_fd(g_mon);\n\tif ((fflags = fcntl(fd, F_GETFL)) & O_NONBLOCK)\n\t\t(void) fcntl(fd, F_SETFL, fflags & ~O_NONBLOCK);\n\n\t \n\tif (pthread_create(&g_mon_tid, NULL, zed_udev_monitor, g_mon) != 0) {\n\t\tudev_monitor_unref(g_mon);\n\t\tudev_unref(g_udev);\n\t\tzed_log_msg(LOG_WARNING, \"pthread_create failed\");\n\t\treturn (-1);\n\t}\n\n\tpthread_setname_np(g_mon_tid, \"udev monitor\");\n\tzed_log_msg(LOG_INFO, \"zed_disk_event_init\");\n\n\treturn (0);\n}\n\nvoid\nzed_disk_event_fini(void)\n{\n\t \n\t(void) pthread_cancel(g_mon_tid);\n\t(void) pthread_join(g_mon_tid, NULL);\n\n\t \n\tudev_monitor_unref(g_mon);\n\tudev_unref(g_udev);\n\n\tzed_log_msg(LOG_INFO, \"zed_disk_event_fini\");\n}\n\n#else\n\n#include \"zed_disk_event.h\"\n\nint\nzed_disk_event_init(void)\n{\n\treturn (0);\n}\n\nvoid\nzed_disk_event_fini(void)\n{\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}