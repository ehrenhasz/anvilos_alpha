{
  "module_name": "zed_conf.c",
  "hash_id": "b8284b36fda894c190f29b42786f0be234502be419cba6c76efdaf0530d629eb",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/zed_conf.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"zed.h\"\n#include \"zed_conf.h\"\n#include \"zed_file.h\"\n#include \"zed_log.h\"\n#include \"zed_strings.h\"\n\n \nvoid\nzed_conf_init(struct zed_conf *zcp)\n{\n\tmemset(zcp, 0, sizeof (*zcp));\n\n\t \n\t \n\n\tzcp->pid_fd = -1;\t\t \n\tzcp->state_fd = -1;\t\t \n\tzcp->zevent_fd = -1;\t\t \n\n\tzcp->max_jobs = 16;\n\tzcp->max_zevent_buf_len = 1 << 20;\n\n\tif (!(zcp->pid_file = strdup(ZED_PID_FILE)) ||\n\t    !(zcp->zedlet_dir = strdup(ZED_ZEDLET_DIR)) ||\n\t    !(zcp->state_file = strdup(ZED_STATE_FILE)))\n\t\tzed_log_die(\"Failed to create conf: %s\", strerror(errno));\n}\n\n \nvoid\nzed_conf_destroy(struct zed_conf *zcp)\n{\n\tif (zcp->state_fd >= 0) {\n\t\tif (close(zcp->state_fd) < 0)\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Failed to close state file \\\"%s\\\": %s\",\n\t\t\t    zcp->state_file, strerror(errno));\n\t\tzcp->state_fd = -1;\n\t}\n\tif (zcp->pid_file) {\n\t\tif ((unlink(zcp->pid_file) < 0) && (errno != ENOENT))\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Failed to remove PID file \\\"%s\\\": %s\",\n\t\t\t    zcp->pid_file, strerror(errno));\n\t}\n\tif (zcp->pid_fd >= 0) {\n\t\tif (close(zcp->pid_fd) < 0)\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Failed to close PID file \\\"%s\\\": %s\",\n\t\t\t    zcp->pid_file, strerror(errno));\n\t\tzcp->pid_fd = -1;\n\t}\n\tif (zcp->pid_file) {\n\t\tfree(zcp->pid_file);\n\t\tzcp->pid_file = NULL;\n\t}\n\tif (zcp->zedlet_dir) {\n\t\tfree(zcp->zedlet_dir);\n\t\tzcp->zedlet_dir = NULL;\n\t}\n\tif (zcp->state_file) {\n\t\tfree(zcp->state_file);\n\t\tzcp->state_file = NULL;\n\t}\n\tif (zcp->zedlets) {\n\t\tzed_strings_destroy(zcp->zedlets);\n\t\tzcp->zedlets = NULL;\n\t}\n}\n\n \nstatic void\n_zed_conf_display_help(const char *prog, boolean_t got_err)\n{\n\tstruct opt { const char *o, *d, *v; };\n\n\tFILE *fp = got_err ? stderr : stdout;\n\n\tstruct opt *oo;\n\tstruct opt iopts[] = {\n\t\t{ .o = \"-h\", .d = \"Display help\" },\n\t\t{ .o = \"-L\", .d = \"Display license information\" },\n\t\t{ .o = \"-V\", .d = \"Display version information\" },\n\t\t{},\n\t};\n\tstruct opt nopts[] = {\n\t\t{ .o = \"-v\", .d = \"Be verbose\" },\n\t\t{ .o = \"-f\", .d = \"Force daemon to run\" },\n\t\t{ .o = \"-F\", .d = \"Run daemon in the foreground\" },\n\t\t{ .o = \"-I\",\n\t\t    .d = \"Idle daemon until kernel module is (re)loaded\" },\n\t\t{ .o = \"-M\", .d = \"Lock all pages in memory\" },\n\t\t{ .o = \"-P\", .d = \"$PATH for ZED to use (only used by ZTS)\" },\n\t\t{ .o = \"-Z\", .d = \"Zero state file\" },\n\t\t{},\n\t};\n\tstruct opt vopts[] = {\n\t\t{ .o = \"-d DIR\", .d = \"Read enabled ZEDLETs from DIR.\",\n\t\t    .v = ZED_ZEDLET_DIR },\n\t\t{ .o = \"-p FILE\", .d = \"Write daemon's PID to FILE.\",\n\t\t    .v = ZED_PID_FILE },\n\t\t{ .o = \"-s FILE\", .d = \"Write daemon's state to FILE.\",\n\t\t    .v = ZED_STATE_FILE },\n\t\t{ .o = \"-j JOBS\", .d = \"Start at most JOBS at once.\",\n\t\t    .v = \"16\" },\n\t\t{ .o = \"-b LEN\", .d = \"Cap kernel event buffer at LEN entries.\",\n\t\t    .v = \"1048576\" },\n\t\t{},\n\t};\n\n\tfprintf(fp, \"Usage: %s [OPTION]...\\n\", (prog ? prog : \"zed\"));\n\tfprintf(fp, \"\\n\");\n\tfor (oo = iopts; oo->o; ++oo)\n\t\tfprintf(fp, \"    %*s %s\\n\", -8, oo->o, oo->d);\n\tfprintf(fp, \"\\n\");\n\tfor (oo = nopts; oo->o; ++oo)\n\t\tfprintf(fp, \"    %*s %s\\n\", -8, oo->o, oo->d);\n\tfprintf(fp, \"\\n\");\n\tfor (oo = vopts; oo->o; ++oo)\n\t\tfprintf(fp, \"    %*s %s [%s]\\n\", -8, oo->o, oo->d, oo->v);\n\tfprintf(fp, \"\\n\");\n\n\texit(got_err ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\n \nstatic void\n_zed_conf_display_license(void)\n{\n\tprintf(\n\t    \"The ZFS Event Daemon (ZED) is distributed under the terms of the\\n\"\n\t    \"  Common Development and Distribution License (CDDL-1.0)\\n\"\n\t    \"  <http://opensource.org/licenses/CDDL-1.0>.\\n\"\n\t    \"\\n\"\n\t    \"Developed at Lawrence Livermore National Laboratory\"\n\t    \" (LLNL-CODE-403049).\\n\"\n\t    \"\\n\");\n\n\texit(EXIT_SUCCESS);\n}\n\n \nstatic void\n_zed_conf_display_version(void)\n{\n\tprintf(\"%s-%s-%s\\n\",\n\t    ZFS_META_NAME, ZFS_META_VERSION, ZFS_META_RELEASE);\n\n\texit(EXIT_SUCCESS);\n}\n\n \nstatic void\n_zed_conf_parse_path(char **resultp, const char *path)\n{\n\tchar buf[PATH_MAX];\n\n\tassert(resultp != NULL);\n\tassert(path != NULL);\n\n\tif (*resultp)\n\t\tfree(*resultp);\n\n\tif (path[0] == '/') {\n\t\t*resultp = strdup(path);\n\t} else {\n\t\tif (!getcwd(buf, sizeof (buf)))\n\t\t\tzed_log_die(\"Failed to get current working dir: %s\",\n\t\t\t    strerror(errno));\n\n\t\tif (strlcat(buf, \"/\", sizeof (buf)) >= sizeof (buf) ||\n\t\t    strlcat(buf, path, sizeof (buf)) >= sizeof (buf))\n\t\t\tzed_log_die(\"Failed to copy path: %s\",\n\t\t\t    strerror(ENAMETOOLONG));\n\n\t\t*resultp = strdup(buf);\n\t}\n\n\tif (!*resultp)\n\t\tzed_log_die(\"Failed to copy path: %s\", strerror(ENOMEM));\n}\n\n \nvoid\nzed_conf_parse_opts(struct zed_conf *zcp, int argc, char **argv)\n{\n\tconst char * const opts = \":hLVd:p:P:s:vfFMZIj:b:\";\n\tint opt;\n\tunsigned long raw;\n\n\tif (!zcp || !argv || !argv[0])\n\t\tzed_log_die(\"Failed to parse options: Internal error\");\n\n\topterr = 0;\t\t\t \n\n\twhile ((opt = getopt(argc, argv, opts)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'h':\n\t\t\t_zed_conf_display_help(argv[0], B_FALSE);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t_zed_conf_display_license();\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\t_zed_conf_display_version();\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t_zed_conf_parse_path(&zcp->zedlet_dir, optarg);\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tzcp->do_idle = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t_zed_conf_parse_path(&zcp->pid_file, optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t_zed_conf_parse_path(&zcp->path, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t_zed_conf_parse_path(&zcp->state_file, optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tzcp->do_verbose = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tzcp->do_force = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tzcp->do_foreground = 1;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tzcp->do_memlock = 1;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tzcp->do_zero = 1;\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\terrno = 0;\n\t\t\traw = strtoul(optarg, NULL, 0);\n\t\t\tif (errno == ERANGE || raw > INT16_MAX) {\n\t\t\t\tzed_log_die(\"%lu is too many jobs\", raw);\n\t\t\t} if (raw == 0) {\n\t\t\t\tzed_log_die(\"0 jobs makes no sense\");\n\t\t\t} else {\n\t\t\t\tzcp->max_jobs = raw;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\terrno = 0;\n\t\t\traw = strtoul(optarg, NULL, 0);\n\t\t\tif (errno == ERANGE || raw > INT32_MAX) {\n\t\t\t\tzed_log_die(\"%lu is too large\", raw);\n\t\t\t} if (raw == 0) {\n\t\t\t\tzcp->max_zevent_buf_len = INT32_MAX;\n\t\t\t} else {\n\t\t\t\tzcp->max_zevent_buf_len = raw;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tif (optopt == '?')\n\t\t\t\t_zed_conf_display_help(argv[0], B_FALSE);\n\n\t\t\tfprintf(stderr, \"%s: Invalid option '-%c'\\n\\n\",\n\t\t\t    argv[0], optopt);\n\t\t\t_zed_conf_display_help(argv[0], B_TRUE);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nint\nzed_conf_scan_dir(struct zed_conf *zcp)\n{\n\tzed_strings_t *zedlets;\n\tDIR *dirp;\n\tstruct dirent *direntp;\n\tchar pathname[PATH_MAX];\n\tstruct stat st;\n\tint n;\n\n\tif (!zcp) {\n\t\terrno = EINVAL;\n\t\tzed_log_msg(LOG_ERR, \"Failed to scan zedlet dir: %s\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\tzedlets = zed_strings_create();\n\tif (!zedlets) {\n\t\terrno = ENOMEM;\n\t\tzed_log_msg(LOG_WARNING, \"Failed to scan dir \\\"%s\\\": %s\",\n\t\t    zcp->zedlet_dir, strerror(errno));\n\t\treturn (-1);\n\t}\n\tdirp = opendir(zcp->zedlet_dir);\n\tif (!dirp) {\n\t\tint errno_bak = errno;\n\t\tzed_log_msg(LOG_WARNING, \"Failed to open dir \\\"%s\\\": %s\",\n\t\t    zcp->zedlet_dir, strerror(errno));\n\t\tzed_strings_destroy(zedlets);\n\t\terrno = errno_bak;\n\t\treturn (-1);\n\t}\n\twhile ((direntp = readdir(dirp))) {\n\t\tif (direntp->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\tn = snprintf(pathname, sizeof (pathname),\n\t\t    \"%s/%s\", zcp->zedlet_dir, direntp->d_name);\n\t\tif ((n < 0) || (n >= sizeof (pathname))) {\n\t\t\tzed_log_msg(LOG_WARNING, \"Failed to stat \\\"%s\\\": %s\",\n\t\t\t    direntp->d_name, strerror(ENAMETOOLONG));\n\t\t\tcontinue;\n\t\t}\n\t\tif (stat(pathname, &st) < 0) {\n\t\t\tzed_log_msg(LOG_WARNING, \"Failed to stat \\\"%s\\\": %s\",\n\t\t\t    pathname, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!S_ISREG(st.st_mode)) {\n\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t    \"Ignoring \\\"%s\\\": not a regular file\",\n\t\t\t    direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((st.st_uid != 0) && !zcp->do_force) {\n\t\t\tzed_log_msg(LOG_NOTICE,\n\t\t\t    \"Ignoring \\\"%s\\\": not owned by root\",\n\t\t\t    direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(st.st_mode & S_IXUSR)) {\n\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t    \"Ignoring \\\"%s\\\": not executable by user\",\n\t\t\t    direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((st.st_mode & S_IWGRP) && !zcp->do_force) {\n\t\t\tzed_log_msg(LOG_NOTICE,\n\t\t\t    \"Ignoring \\\"%s\\\": writable by group\",\n\t\t\t    direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((st.st_mode & S_IWOTH) && !zcp->do_force) {\n\t\t\tzed_log_msg(LOG_NOTICE,\n\t\t\t    \"Ignoring \\\"%s\\\": writable by other\",\n\t\t\t    direntp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (zed_strings_add(zedlets, NULL, direntp->d_name) < 0) {\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Failed to register \\\"%s\\\": %s\",\n\t\t\t    direntp->d_name, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (zcp->do_verbose)\n\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t    \"Registered zedlet \\\"%s\\\"\", direntp->d_name);\n\t}\n\tif (closedir(dirp) < 0) {\n\t\tint errno_bak = errno;\n\t\tzed_log_msg(LOG_WARNING, \"Failed to close dir \\\"%s\\\": %s\",\n\t\t    zcp->zedlet_dir, strerror(errno));\n\t\tzed_strings_destroy(zedlets);\n\t\terrno = errno_bak;\n\t\treturn (-1);\n\t}\n\tif (zcp->zedlets)\n\t\tzed_strings_destroy(zcp->zedlets);\n\n\tzcp->zedlets = zedlets;\n\treturn (0);\n}\n\n \nint\nzed_conf_write_pid(struct zed_conf *zcp)\n{\n\tchar buf[PATH_MAX];\n\tint n;\n\tchar *p;\n\tmode_t mask;\n\tint rv;\n\n\tif (!zcp || !zcp->pid_file) {\n\t\terrno = EINVAL;\n\t\tzed_log_msg(LOG_ERR, \"Failed to create PID file: %s\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\tassert(zcp->pid_fd == -1);\n\t \n\tn = strlcpy(buf, zcp->pid_file, sizeof (buf));\n\tif (n >= sizeof (buf)) {\n\t\terrno = ENAMETOOLONG;\n\t\tzed_log_msg(LOG_ERR, \"Failed to create PID file: %s\",\n\t\t    strerror(errno));\n\t\tgoto err;\n\t}\n\tp = strrchr(buf, '/');\n\tif (p)\n\t\t*p = '\\0';\n\n\tif ((mkdirp(buf, 0755) < 0) && (errno != EEXIST)) {\n\t\tzed_log_msg(LOG_ERR, \"Failed to create directory \\\"%s\\\": %s\",\n\t\t    buf, strerror(errno));\n\t\tgoto err;\n\t}\n\t \n\tmask = umask(0);\n\tumask(mask | 022);\n\tzcp->pid_fd = open(zcp->pid_file, O_RDWR | O_CREAT | O_CLOEXEC, 0644);\n\tumask(mask);\n\tif (zcp->pid_fd < 0) {\n\t\tzed_log_msg(LOG_ERR, \"Failed to open PID file \\\"%s\\\": %s\",\n\t\t    zcp->pid_file, strerror(errno));\n\t\tgoto err;\n\t}\n\trv = zed_file_lock(zcp->pid_fd);\n\tif (rv < 0) {\n\t\tzed_log_msg(LOG_ERR, \"Failed to lock PID file \\\"%s\\\": %s\",\n\t\t    zcp->pid_file, strerror(errno));\n\t\tgoto err;\n\t} else if (rv > 0) {\n\t\tpid_t pid = zed_file_is_locked(zcp->pid_fd);\n\t\tif (pid < 0) {\n\t\t\tzed_log_msg(LOG_ERR,\n\t\t\t    \"Failed to test lock on PID file \\\"%s\\\"\",\n\t\t\t    zcp->pid_file);\n\t\t} else if (pid > 0) {\n\t\t\tzed_log_msg(LOG_ERR,\n\t\t\t    \"Found PID %d bound to PID file \\\"%s\\\"\",\n\t\t\t    pid, zcp->pid_file);\n\t\t} else {\n\t\t\tzed_log_msg(LOG_ERR,\n\t\t\t    \"Inconsistent lock state on PID file \\\"%s\\\"\",\n\t\t\t    zcp->pid_file);\n\t\t}\n\t\tgoto err;\n\t}\n\t \n\tn = snprintf(buf, sizeof (buf), \"%d\\n\", (int)getpid());\n\tif ((n < 0) || (n >= sizeof (buf))) {\n\t\terrno = ERANGE;\n\t\tzed_log_msg(LOG_ERR, \"Failed to write PID file \\\"%s\\\": %s\",\n\t\t    zcp->pid_file, strerror(errno));\n\t} else if (write(zcp->pid_fd, buf, n) != n) {\n\t\tzed_log_msg(LOG_ERR, \"Failed to write PID file \\\"%s\\\": %s\",\n\t\t    zcp->pid_file, strerror(errno));\n\t} else if (fdatasync(zcp->pid_fd) < 0) {\n\t\tzed_log_msg(LOG_ERR, \"Failed to sync PID file \\\"%s\\\": %s\",\n\t\t    zcp->pid_file, strerror(errno));\n\t} else {\n\t\treturn (0);\n\t}\n\nerr:\n\tif (zcp->pid_fd >= 0) {\n\t\t(void) close(zcp->pid_fd);\n\t\tzcp->pid_fd = -1;\n\t}\n\treturn (-1);\n}\n\n \nint\nzed_conf_open_state(struct zed_conf *zcp)\n{\n\tchar dirbuf[PATH_MAX];\n\tint n;\n\tchar *p;\n\tint rv;\n\n\tif (!zcp || !zcp->state_file) {\n\t\terrno = EINVAL;\n\t\tzed_log_msg(LOG_ERR, \"Failed to open state file: %s\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\tn = strlcpy(dirbuf, zcp->state_file, sizeof (dirbuf));\n\tif (n >= sizeof (dirbuf)) {\n\t\terrno = ENAMETOOLONG;\n\t\tzed_log_msg(LOG_WARNING, \"Failed to open state file: %s\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\tp = strrchr(dirbuf, '/');\n\tif (p)\n\t\t*p = '\\0';\n\n\tif ((mkdirp(dirbuf, 0755) < 0) && (errno != EEXIST)) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to create directory \\\"%s\\\": %s\",\n\t\t    dirbuf, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (zcp->state_fd >= 0) {\n\t\tif (close(zcp->state_fd) < 0) {\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Failed to close state file \\\"%s\\\": %s\",\n\t\t\t    zcp->state_file, strerror(errno));\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tif (zcp->do_zero)\n\t\t(void) unlink(zcp->state_file);\n\n\tzcp->state_fd = open(zcp->state_file,\n\t    O_RDWR | O_CREAT | O_CLOEXEC, 0644);\n\tif (zcp->state_fd < 0) {\n\t\tzed_log_msg(LOG_WARNING, \"Failed to open state file \\\"%s\\\": %s\",\n\t\t    zcp->state_file, strerror(errno));\n\t\treturn (-1);\n\t}\n\trv = zed_file_lock(zcp->state_fd);\n\tif (rv < 0) {\n\t\tzed_log_msg(LOG_WARNING, \"Failed to lock state file \\\"%s\\\": %s\",\n\t\t    zcp->state_file, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (rv > 0) {\n\t\tpid_t pid = zed_file_is_locked(zcp->state_fd);\n\t\tif (pid < 0) {\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Failed to test lock on state file \\\"%s\\\"\",\n\t\t\t    zcp->state_file);\n\t\t} else if (pid > 0) {\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Found PID %d bound to state file \\\"%s\\\"\",\n\t\t\t    pid, zcp->state_file);\n\t\t} else {\n\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t    \"Inconsistent lock state on state file \\\"%s\\\"\",\n\t\t\t    zcp->state_file);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n \nint\nzed_conf_read_state(struct zed_conf *zcp, uint64_t *eidp, int64_t etime[])\n{\n\tssize_t len;\n\tstruct iovec iov[3];\n\tssize_t n;\n\n\tif (!zcp || !eidp || !etime) {\n\t\terrno = EINVAL;\n\t\tzed_log_msg(LOG_ERR,\n\t\t    \"Failed to read state file: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (lseek(zcp->state_fd, 0, SEEK_SET) == (off_t)-1) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to reposition state file offset: %s\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\tlen = 0;\n\tiov[0].iov_base = eidp;\n\tlen += iov[0].iov_len = sizeof (*eidp);\n\tiov[1].iov_base = &etime[0];\n\tlen += iov[1].iov_len = sizeof (etime[0]);\n\tiov[2].iov_base = &etime[1];\n\tlen += iov[2].iov_len = sizeof (etime[1]);\n\n\tn = readv(zcp->state_fd, iov, 3);\n\tif (n == 0) {\n\t\t*eidp = 0;\n\t} else if (n < 0) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to read state file \\\"%s\\\": %s\",\n\t\t    zcp->state_file, strerror(errno));\n\t\treturn (-1);\n\t} else if (n != len) {\n\t\terrno = EIO;\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to read state file \\\"%s\\\": Read %zd of %zd bytes\",\n\t\t    zcp->state_file, n, len);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n \nint\nzed_conf_write_state(struct zed_conf *zcp, uint64_t eid, int64_t etime[])\n{\n\tssize_t len;\n\tstruct iovec iov[3];\n\tssize_t n;\n\n\tif (!zcp) {\n\t\terrno = EINVAL;\n\t\tzed_log_msg(LOG_ERR,\n\t\t    \"Failed to write state file: %s\", strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (lseek(zcp->state_fd, 0, SEEK_SET) == (off_t)-1) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to reposition state file offset: %s\",\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\tlen = 0;\n\tiov[0].iov_base = &eid;\n\tlen += iov[0].iov_len = sizeof (eid);\n\tiov[1].iov_base = &etime[0];\n\tlen += iov[1].iov_len = sizeof (etime[0]);\n\tiov[2].iov_base = &etime[1];\n\tlen += iov[2].iov_len = sizeof (etime[1]);\n\n\tn = writev(zcp->state_fd, iov, 3);\n\tif (n < 0) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to write state file \\\"%s\\\": %s\",\n\t\t    zcp->state_file, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (n != len) {\n\t\terrno = EIO;\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to write state file \\\"%s\\\": Wrote %zd of %zd bytes\",\n\t\t    zcp->state_file, n, len);\n\t\treturn (-1);\n\t}\n\tif (fdatasync(zcp->state_fd) < 0) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to sync state file \\\"%s\\\": %s\",\n\t\t    zcp->state_file, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}