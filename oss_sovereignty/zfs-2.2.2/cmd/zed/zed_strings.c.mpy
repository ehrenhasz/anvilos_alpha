{
  "module_name": "zed_strings.c",
  "hash_id": "12238bc950497d2cfc59065760a8a3d16e37757ad589ff3761c32ae5a2f11cca",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/zed_strings.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/avl.h>\n#include <sys/sysmacros.h>\n#include \"zed_strings.h\"\n\nstruct zed_strings {\n\tavl_tree_t tree;\n\tavl_node_t *iteratorp;\n};\n\nstruct zed_strings_node {\n\tavl_node_t node;\n\tchar *key;\n\tchar *val;\n};\n\ntypedef struct zed_strings_node zed_strings_node_t;\n\n \nstatic int\n_zed_strings_node_compare(const void *x1, const void *x2)\n{\n\tconst char *s1;\n\tconst char *s2;\n\tint rv;\n\n\tassert(x1 != NULL);\n\tassert(x2 != NULL);\n\n\ts1 = ((const zed_strings_node_t *) x1)->key;\n\tassert(s1 != NULL);\n\ts2 = ((const zed_strings_node_t *) x2)->key;\n\tassert(s2 != NULL);\n\trv = strcmp(s1, s2);\n\n\tif (rv < 0)\n\t\treturn (-1);\n\n\tif (rv > 0)\n\t\treturn (1);\n\n\treturn (0);\n}\n\n \nzed_strings_t *\nzed_strings_create(void)\n{\n\tzed_strings_t *zsp;\n\n\tzsp = calloc(1, sizeof (*zsp));\n\tif (!zsp)\n\t\treturn (NULL);\n\n\tavl_create(&zsp->tree, _zed_strings_node_compare,\n\t    sizeof (zed_strings_node_t), offsetof(zed_strings_node_t, node));\n\n\tzsp->iteratorp = NULL;\n\treturn (zsp);\n}\n\n \nstatic void\n_zed_strings_node_destroy(zed_strings_node_t *np)\n{\n\tif (!np)\n\t\treturn;\n\n\tif (np->key) {\n\t\tif (np->key != np->val)\n\t\t\tfree(np->key);\n\t\tnp->key = NULL;\n\t}\n\tif (np->val) {\n\t\tfree(np->val);\n\t\tnp->val = NULL;\n\t}\n\tfree(np);\n}\n\n \nstatic zed_strings_node_t *\n_zed_strings_node_create(const char *key, const char *val)\n{\n\tzed_strings_node_t *np;\n\n\tassert(val != NULL);\n\n\tnp = calloc(1, sizeof (*np));\n\tif (!np)\n\t\treturn (NULL);\n\n\tnp->val = strdup(val);\n\tif (!np->val)\n\t\tgoto nomem;\n\n\tif (key) {\n\t\tnp->key = strdup(key);\n\t\tif (!np->key)\n\t\t\tgoto nomem;\n\t} else {\n\t\tnp->key = np->val;\n\t}\n\treturn (np);\n\nnomem:\n\t_zed_strings_node_destroy(np);\n\treturn (NULL);\n}\n\n \nvoid\nzed_strings_destroy(zed_strings_t *zsp)\n{\n\tvoid *cookie;\n\tzed_strings_node_t *np;\n\n\tif (!zsp)\n\t\treturn;\n\n\tcookie = NULL;\n\twhile ((np = avl_destroy_nodes(&zsp->tree, &cookie)))\n\t\t_zed_strings_node_destroy(np);\n\n\tavl_destroy(&zsp->tree);\n\tfree(zsp);\n}\n\n \nint\nzed_strings_add(zed_strings_t *zsp, const char *key, const char *s)\n{\n\tzed_strings_node_t *newp, *oldp;\n\n\tif (!zsp || !s) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\tif (key == s)\n\t\tkey = NULL;\n\n\tnewp = _zed_strings_node_create(key, s);\n\tif (!newp)\n\t\treturn (-1);\n\n\toldp = avl_find(&zsp->tree, newp, NULL);\n\tif (oldp) {\n\t\tavl_remove(&zsp->tree, oldp);\n\t\t_zed_strings_node_destroy(oldp);\n\t}\n\tavl_add(&zsp->tree, newp);\n\treturn (0);\n}\n\n \nconst char *\nzed_strings_first(zed_strings_t *zsp)\n{\n\tif (!zsp) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\tzsp->iteratorp = avl_first(&zsp->tree);\n\tif (!zsp->iteratorp)\n\t\treturn (NULL);\n\n\treturn (((zed_strings_node_t *)zsp->iteratorp)->val);\n\n}\n\n \nconst char *\nzed_strings_next(zed_strings_t *zsp)\n{\n\tif (!zsp) {\n\t\terrno = EINVAL;\n\t\treturn (NULL);\n\t}\n\tif (!zsp->iteratorp)\n\t\treturn (NULL);\n\n\tzsp->iteratorp = AVL_NEXT(&zsp->tree, zsp->iteratorp);\n\tif (!zsp->iteratorp)\n\t\treturn (NULL);\n\n\treturn (((zed_strings_node_t *)zsp->iteratorp)->val);\n}\n\n \nint\nzed_strings_count(zed_strings_t *zsp)\n{\n\tif (!zsp) {\n\t\terrno = EINVAL;\n\t\treturn (-1);\n\t}\n\treturn (avl_numnodes(&zsp->tree));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}