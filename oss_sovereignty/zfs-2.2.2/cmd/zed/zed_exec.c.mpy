{
  "module_name": "zed_exec.c",
  "hash_id": "d034915eda6cd8c7b17a606125c3cf3ac38b3cefd75b43e825991dbb2b587b70",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/zed_exec.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <sys/avl.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <signal.h>\n\n#include \"zed_exec.h\"\n#include \"zed_log.h\"\n#include \"zed_strings.h\"\n\n#define\tZEVENT_FILENO\t3\n\nstruct launched_process_node {\n\tavl_node_t node;\n\tpid_t pid;\n\tuint64_t eid;\n\tchar *name;\n};\n\nstatic int\n_launched_process_node_compare(const void *x1, const void *x2)\n{\n\tpid_t p1;\n\tpid_t p2;\n\n\tassert(x1 != NULL);\n\tassert(x2 != NULL);\n\n\tp1 = ((const struct launched_process_node *) x1)->pid;\n\tp2 = ((const struct launched_process_node *) x2)->pid;\n\n\tif (p1 < p2)\n\t\treturn (-1);\n\telse if (p1 == p2)\n\t\treturn (0);\n\telse\n\t\treturn (1);\n}\n\nstatic pthread_t _reap_children_tid = (pthread_t)-1;\nstatic volatile boolean_t _reap_children_stop;\nstatic avl_tree_t _launched_processes;\nstatic pthread_mutex_t _launched_processes_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic int16_t _launched_processes_limit;\n\n \nstatic char **\n_zed_exec_create_env(zed_strings_t *zsp)\n{\n\tint num_ptrs;\n\tint buflen;\n\tchar *buf;\n\tchar **pp;\n\tchar *p;\n\tconst char *q;\n\tint i;\n\tint len;\n\n\tnum_ptrs = zed_strings_count(zsp) + 1;\n\tbuflen = num_ptrs * sizeof (char *);\n\tfor (q = zed_strings_first(zsp); q; q = zed_strings_next(zsp))\n\t\tbuflen += strlen(q) + 1;\n\n\tbuf = calloc(1, buflen);\n\tif (!buf)\n\t\treturn (NULL);\n\n\tpp = (char **)buf;\n\tp = buf + (num_ptrs * sizeof (char *));\n\ti = 0;\n\tfor (q = zed_strings_first(zsp); q; q = zed_strings_next(zsp)) {\n\t\tpp[i] = p;\n\t\tlen = strlen(q) + 1;\n\t\tmemcpy(p, q, len);\n\t\tp += len;\n\t\ti++;\n\t}\n\tpp[i] = NULL;\n\tassert(buf + buflen == p);\n\treturn ((char **)buf);\n}\n\n \nstatic void\n_zed_exec_fork_child(uint64_t eid, const char *dir, const char *prog,\n    char *env[], int zfd, boolean_t in_foreground)\n{\n\tchar path[PATH_MAX];\n\tint n;\n\tpid_t pid;\n\tint fd;\n\tstruct launched_process_node *node;\n\tsigset_t mask;\n\tstruct timespec launch_timeout =\n\t\t{ .tv_sec = 0, .tv_nsec = 200 * 1000 * 1000, };\n\n\tassert(dir != NULL);\n\tassert(prog != NULL);\n\tassert(env != NULL);\n\tassert(zfd >= 0);\n\n\twhile (__atomic_load_n(&_launched_processes_limit,\n\t    __ATOMIC_SEQ_CST) <= 0)\n\t\t(void) nanosleep(&launch_timeout, NULL);\n\n\tn = snprintf(path, sizeof (path), \"%s/%s\", dir, prog);\n\tif ((n < 0) || (n >= sizeof (path))) {\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to fork \\\"%s\\\" for eid=%llu: %s\",\n\t\t    prog, eid, strerror(ENAMETOOLONG));\n\t\treturn;\n\t}\n\t(void) pthread_mutex_lock(&_launched_processes_lock);\n\tpid = fork();\n\tif (pid < 0) {\n\t\t(void) pthread_mutex_unlock(&_launched_processes_lock);\n\t\tzed_log_msg(LOG_WARNING,\n\t\t    \"Failed to fork \\\"%s\\\" for eid=%llu: %s\",\n\t\t    prog, eid, strerror(errno));\n\t\treturn;\n\t} else if (pid == 0) {\n\t\t(void) sigemptyset(&mask);\n\t\t(void) sigprocmask(SIG_SETMASK, &mask, NULL);\n\n\t\t(void) umask(022);\n\t\tif (in_foreground &&  \n\t\t    (fd = open(\"/dev/null\", O_RDWR | O_CLOEXEC)) != -1) {\n\t\t\t(void) dup2(fd, STDIN_FILENO);\n\t\t\t(void) dup2(fd, STDOUT_FILENO);\n\t\t\t(void) dup2(fd, STDERR_FILENO);\n\t\t}\n\t\t(void) dup2(zfd, ZEVENT_FILENO);\n\t\texecle(path, prog, NULL, env);\n\t\t_exit(127);\n\t}\n\n\t \n\n\tnode = calloc(1, sizeof (*node));\n\tif (node) {\n\t\tnode->pid = pid;\n\t\tnode->eid = eid;\n\t\tnode->name = strdup(prog);\n\t\tif (node->name == NULL) {\n\t\t\tperror(\"strdup\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tavl_add(&_launched_processes, node);\n\t}\n\t(void) pthread_mutex_unlock(&_launched_processes_lock);\n\n\t__atomic_sub_fetch(&_launched_processes_limit, 1, __ATOMIC_SEQ_CST);\n\tzed_log_msg(LOG_INFO, \"Invoking \\\"%s\\\" eid=%llu pid=%d\",\n\t    prog, eid, pid);\n}\n\nstatic void\n_nop(int sig)\n{\n\t(void) sig;\n}\n\nstatic void *\n_reap_children(void *arg)\n{\n\t(void) arg;\n\tstruct launched_process_node node, *pnode;\n\tpid_t pid;\n\tint status;\n\tstruct rusage usage;\n\tstruct sigaction sa = {};\n\n\t(void) sigfillset(&sa.sa_mask);\n\t(void) sigdelset(&sa.sa_mask, SIGCHLD);\n\t(void) pthread_sigmask(SIG_SETMASK, &sa.sa_mask, NULL);\n\n\t(void) sigemptyset(&sa.sa_mask);\n\tsa.sa_handler = _nop;\n\tsa.sa_flags = SA_NOCLDSTOP;\n\t(void) sigaction(SIGCHLD, &sa, NULL);\n\n\tfor (_reap_children_stop = B_FALSE; !_reap_children_stop; ) {\n\t\t(void) pthread_mutex_lock(&_launched_processes_lock);\n\t\tpid = wait4(0, &status, WNOHANG, &usage);\n\n\t\tif (pid == 0 || pid == (pid_t)-1) {\n\t\t\t(void) pthread_mutex_unlock(&_launched_processes_lock);\n\t\t\tif (pid == 0 || errno == ECHILD)\n\t\t\t\tpause();\n\t\t\telse if (errno != EINTR)\n\t\t\t\tzed_log_msg(LOG_WARNING,\n\t\t\t\t    \"Failed to wait for children: %s\",\n\t\t\t\t    strerror(errno));\n\t\t} else {\n\t\t\tmemset(&node, 0, sizeof (node));\n\t\t\tnode.pid = pid;\n\t\t\tpnode = avl_find(&_launched_processes, &node, NULL);\n\t\t\tif (pnode) {\n\t\t\t\tmemcpy(&node, pnode, sizeof (node));\n\n\t\t\t\tavl_remove(&_launched_processes, pnode);\n\t\t\t\tfree(pnode);\n\t\t\t}\n\t\t\t(void) pthread_mutex_unlock(&_launched_processes_lock);\n\t\t\t__atomic_add_fetch(&_launched_processes_limit, 1,\n\t\t\t    __ATOMIC_SEQ_CST);\n\n\t\t\tusage.ru_utime.tv_sec += usage.ru_stime.tv_sec;\n\t\t\tusage.ru_utime.tv_usec += usage.ru_stime.tv_usec;\n\t\t\tusage.ru_utime.tv_sec +=\n\t\t\t    usage.ru_utime.tv_usec / (1000 * 1000);\n\t\t\tusage.ru_utime.tv_usec %= 1000 * 1000;\n\n\t\t\tif (WIFEXITED(status)) {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t    \"Finished \\\"%s\\\" eid=%llu pid=%d \"\n\t\t\t\t    \"time=%llu.%06us exit=%d\",\n\t\t\t\t    node.name, node.eid, pid,\n\t\t\t\t    (unsigned long long) usage.ru_utime.tv_sec,\n\t\t\t\t    (unsigned int) usage.ru_utime.tv_usec,\n\t\t\t\t    WEXITSTATUS(status));\n\t\t\t} else if (WIFSIGNALED(status)) {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t    \"Finished \\\"%s\\\" eid=%llu pid=%d \"\n\t\t\t\t    \"time=%llu.%06us sig=%d/%s\",\n\t\t\t\t    node.name, node.eid, pid,\n\t\t\t\t    (unsigned long long) usage.ru_utime.tv_sec,\n\t\t\t\t    (unsigned int) usage.ru_utime.tv_usec,\n\t\t\t\t    WTERMSIG(status),\n\t\t\t\t    strsignal(WTERMSIG(status)));\n\t\t\t} else {\n\t\t\t\tzed_log_msg(LOG_INFO,\n\t\t\t\t    \"Finished \\\"%s\\\" eid=%llu pid=%d \"\n\t\t\t\t    \"time=%llu.%06us status=0x%X\",\n\t\t\t\t    node.name, node.eid, pid,\n\t\t\t\t    (unsigned long long) usage.ru_utime.tv_sec,\n\t\t\t\t    (unsigned int) usage.ru_utime.tv_usec,\n\t\t\t\t    (unsigned int) status);\n\t\t\t}\n\n\t\t\tfree(node.name);\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\nvoid\nzed_exec_fini(void)\n{\n\tstruct launched_process_node *node;\n\tvoid *ck = NULL;\n\n\tif (_reap_children_tid == (pthread_t)-1)\n\t\treturn;\n\n\t_reap_children_stop = B_TRUE;\n\t(void) pthread_kill(_reap_children_tid, SIGCHLD);\n\t(void) pthread_join(_reap_children_tid, NULL);\n\n\twhile ((node = avl_destroy_nodes(&_launched_processes, &ck)) != NULL) {\n\t\tfree(node->name);\n\t\tfree(node);\n\t}\n\tavl_destroy(&_launched_processes);\n\n\t(void) pthread_mutex_destroy(&_launched_processes_lock);\n\t(void) pthread_mutex_init(&_launched_processes_lock, NULL);\n\n\t_reap_children_tid = (pthread_t)-1;\n}\n\n \nint\nzed_exec_process(uint64_t eid, const char *class, const char *subclass,\n    struct zed_conf *zcp, zed_strings_t *envs)\n{\n\tconst char *class_strings[4];\n\tconst char *allclass = \"all\";\n\tconst char **csp;\n\tconst char *z;\n\tchar **e;\n\tint n;\n\n\tif (!zcp->zedlet_dir || !zcp->zedlets || !envs || zcp->zevent_fd < 0)\n\t\treturn (-1);\n\n\tif (_reap_children_tid == (pthread_t)-1) {\n\t\t_launched_processes_limit = zcp->max_jobs;\n\n\t\tif (pthread_create(&_reap_children_tid, NULL,\n\t\t    _reap_children, NULL) != 0)\n\t\t\treturn (-1);\n\t\tpthread_setname_np(_reap_children_tid, \"reap ZEDLETs\");\n\n\t\tavl_create(&_launched_processes, _launched_process_node_compare,\n\t\t    sizeof (struct launched_process_node),\n\t\t    offsetof(struct launched_process_node, node));\n\t}\n\n\tcsp = class_strings;\n\n\tif (class)\n\t\t*csp++ = class;\n\n\tif (subclass)\n\t\t*csp++ = subclass;\n\n\tif (allclass)\n\t\t*csp++ = allclass;\n\n\t*csp = NULL;\n\n\te = _zed_exec_create_env(envs);\n\n\tfor (z = zed_strings_first(zcp->zedlets); z;\n\t    z = zed_strings_next(zcp->zedlets)) {\n\t\tfor (csp = class_strings; *csp; csp++) {\n\t\t\tn = strlen(*csp);\n\t\t\tif ((strncmp(z, *csp, n) == 0) && !isalpha(z[n]))\n\t\t\t\t_zed_exec_fork_child(eid, zcp->zedlet_dir,\n\t\t\t\t    z, e, zcp->zevent_fd, zcp->do_foreground);\n\t\t}\n\t}\n\tfree(e);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}