{
  "module_name": "statechange-led.sh",
  "hash_id": "cb018659bf6e0a21185100ed2a4c1850d8369bc2405d95600920f0a53f038ff4",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/zed.d/statechange-led.sh",
  "human_readable_source": "#!/bin/sh\n# shellcheck disable=SC2154\n#\n# Turn off/on vdevs' enclosure fault LEDs when their pool's state changes.\n#\n# Turn a vdev's fault LED on if it becomes FAULTED, DEGRADED or UNAVAIL.\n# Turn its LED off when it's back ONLINE again.\n#\n# This script run in two basic modes:\n#\n# 1. If $ZEVENT_VDEV_ENC_SYSFS_PATH and $ZEVENT_VDEV_STATE_STR are set, then\n# only set the LED for that particular vdev. This is the case for statechange\n# events and some vdev_* events.\n#\n# 2. If those vars are not set, then check the state of all vdevs in the pool\n# and set the LEDs accordingly.  This is the case for pool_import events.\n#\n# Note that this script requires that your enclosure be supported by the\n# Linux SCSI Enclosure services (SES) driver.  The script will do nothing\n# if you have no enclosure, or if your enclosure isn't supported.\n#\n# Exit codes:\n#   0: enclosure led successfully set\n#   1: enclosure leds not available\n#   2: enclosure leds administratively disabled\n#   3: The led sysfs path passed from ZFS does not exist\n#   4: $ZPOOL not set\n#   5: awk is not installed\n\n[ -f \"${ZED_ZEDLET_DIR}/zed.rc\" ] && . \"${ZED_ZEDLET_DIR}/zed.rc\"\n. \"${ZED_ZEDLET_DIR}/zed-functions.sh\"\n\nif [ ! -d /sys/class/enclosure ] && [ ! -d /sys/bus/pci/slots ] ; then\n\t# No JBOD enclosure or NVMe slots\n\texit 1\nfi\n\nif [ \"${ZED_USE_ENCLOSURE_LEDS}\" != \"1\" ] ; then\n\texit 2\nfi\n\nzed_check_cmd \"$ZPOOL\" || exit 4\nzed_check_cmd awk || exit 5\n\n# Global used in set_led debug print\nvdev=\"\"\n\n# check_and_set_led (file, val)\n#\n# Read an enclosure sysfs file, and write it if it's not already set to 'val'\n#\n# Arguments\n#   file: sysfs file to set (like /sys/class/enclosure/0:0:1:0/SLOT 10/fault)\n#   val: value to set it to\n#\n# Return\n#  0 on success, 3 on missing sysfs path\n#\ncheck_and_set_led()\n{\n\tfile=\"$1\"\n\tval=\"$2\"\n\n\tif [ -z \"$val\" ]; then\n\t\treturn 0\n\tfi\n\n\tif [ ! -e \"$file\" ] ; then\n\t\treturn 3\n\tfi\n\n\t# If another process is accessing the LED when we attempt to update it,\n\t# the update will be lost so retry until the LED actually changes or we\n\t# timeout.\n\tfor _ in 1 2 3 4 5; do\n\t\t# We want to check the current state first, since writing to the\n\t\t# 'fault' entry always causes a SES command, even if the\n\t\t# current state is already what you want.\n\t\tread -r current < \"${file}\"\n\n\t\t# On some enclosures if you write 1 to fault, and read it back,\n\t\t# it will return 2.  Treat all non-zero values as 1 for\n\t\t# simplicity.\n\t\tif [ \"$current\" != \"0\" ] ; then\n\t\t\tcurrent=1\n\t\tfi\n\n\t\tif [ \"$current\" != \"$val\" ] ; then\n\t\t\techo \"$val\" > \"$file\"\n\t\t\tzed_log_msg \"vdev $vdev set '$file' LED to $val\"\n\t\telse\n\t\t\tbreak\n\t\tfi\n\tdone\n}\n\n# Fault LEDs for JBODs and NVMe drives are handled a little differently.\n#\n# On JBODs the fault LED is called 'fault' and on a path like this:\n#\n#   /sys/class/enclosure/0:0:1:0/SLOT 10/fault\n#\n# On NVMe it's called 'attention' and on a path like this:\n#\n#   /sys/bus/pci/slot/0/attention\n#\n# This function returns the full path to the fault LED file for a given\n# enclosure/slot directory.\n#\npath_to_led()\n{\n\tdir=$1\n\tif [ -f \"$dir/fault\" ] ; then\n\t\techo \"$dir/fault\"\n\telif [ -f \"$dir/attention\" ] ; then\n\t\techo \"$dir/attention\"\n\tfi\n}\n\nstate_to_val()\n{\n\tstate=\"$1\"\n\tcase \"$state\" in\n\t\tFAULTED|DEGRADED|UNAVAIL|REMOVED)\n\t\t\techo 1\n\t\t\t;;\n\t\tONLINE)\n\t\t\techo 0\n\t\t\t;;\n\t\t*)\n\t\t\techo \"invalid state: $state\"\n\t\t\t;;\n\tesac\n}\n\n#\n# Given a nvme name like 'nvme0n1', pass back its slot directory\n# like \"/sys/bus/pci/slots/0\"\n#\nnvme_dev_to_slot()\n{\n\tdev=\"$1\"\n\n\t# Get the address \"0000:01:00.0\"\n\tread -r address < \"/sys/class/block/$dev/device/address\"\n\n\tfind /sys/bus/pci/slots -regex '.*/[0-9]+/address$' | \\\n\t\twhile read -r sys_addr; do\n\t\t\tread -r this_address < \"$sys_addr\"\n\n\t\t\t# The format of address is a little different between\n\t\t\t# /sys/class/block/$dev/device/address and\n\t\t\t# /sys/bus/pci/slots/\n\t\t\t#\n\t\t\t# address=           \"0000:01:00.0\"\n\t\t\t# this_address =     \"0000:01:00\"\n\t\t\t#\n\t\t\tif echo \"$address\" | grep -Eq ^\"$this_address\" ; then\n\t\t\t\techo \"${sys_addr%/*}\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\tdone\n}\n\n\n# process_pool (pool)\n#\n# Iterate through a pool and set the vdevs' enclosure slot LEDs to\n# those vdevs' state.\n#\n# Arguments\n#   pool:\tPool name.\n#\n# Return\n#  0 on success, 3 on missing sysfs path\n#\nprocess_pool()\n{\n\tpool=\"$1\"\n\n\t# The output will be the vdevs only (from \"grep '/dev/'\"):\n\t#\n\t#    U45     ONLINE       0     0     0   /dev/sdk          0\n\t#    U46     ONLINE       0     0     0   /dev/sdm          0\n\t#    U47     ONLINE       0     0     0   /dev/sdn          0\n\t#    U50     ONLINE       0     0     0  /dev/sdbn          0\n\t#\n\tZPOOL_SCRIPTS_AS_ROOT=1 $ZPOOL status -c upath,fault_led \"$pool\" | grep '/dev/' | (\n\trc=0\n\twhile read -r vdev state _ _ _ therest; do\n\t\t# Read out current LED value and path\n\t\t# Get dev name (like 'sda')\n\t\tdev=$(basename \"$(echo \"$therest\" | awk '{print $(NF-1)}')\")\n\t\tvdev_enc_sysfs_path=$(realpath \"/sys/class/block/$dev/device/enclosure_device\"*)\n\t\tif [ ! -d \"$vdev_enc_sysfs_path\" ] ; then\n\t\t\t# This is not a JBOD disk, but it could be a PCI NVMe drive\n\t\t\tvdev_enc_sysfs_path=$(nvme_dev_to_slot \"$dev\")\n\t\tfi\n\n\t\tcurrent_val=$(echo \"$therest\" | awk '{print $NF}')\n\n\t\tif [ \"$current_val\" != \"0\" ] ; then\n\t\t\tcurrent_val=1\n\t\tfi\n\n\t\tif [ -z \"$vdev_enc_sysfs_path\" ] ; then\n\t\t\t# Skip anything with no sysfs LED entries\n\t\t\tcontinue\n\t\tfi\n\n\t\tled_path=$(path_to_led \"$vdev_enc_sysfs_path\")\n\t\tif [ ! -e \"$led_path\" ] ; then\n\t\t\trc=3\n\t\t\tzed_log_msg \"vdev $vdev '$led_path' doesn't exist\"\n\t\t\tcontinue\n\t\tfi\n\n\t\tval=$(state_to_val \"$state\")\n\n\t\tif [ \"$current_val\" = \"$val\" ] ; then\n\t\t\t# LED is already set correctly\n\t\t\tcontinue\n\t\tfi\n\n\t\tif ! check_and_set_led \"$led_path\" \"$val\"; then\n\t\t\trc=3\n\t\tfi\n\tdone\n\texit \"$rc\"; )\n}\n\nif [ -n \"$ZEVENT_VDEV_ENC_SYSFS_PATH\" ] && [ -n \"$ZEVENT_VDEV_STATE_STR\" ] ; then\n\t# Got a statechange for an individual vdev\n\tval=$(state_to_val \"$ZEVENT_VDEV_STATE_STR\")\n\tvdev=$(basename \"$ZEVENT_VDEV_PATH\")\n\tledpath=$(path_to_led \"$ZEVENT_VDEV_ENC_SYSFS_PATH\")\n\tcheck_and_set_led \"$ledpath\" \"$val\"\nelse\n\t# Process the entire pool\n\tpoolname=$(zed_guid_to_pool \"$ZEVENT_POOL_GUID\")\n\tprocess_pool \"$poolname\"\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}