{
  "module_name": "zed-functions.sh",
  "hash_id": "a420c378a6335b41f5a64f77176ce762d0688282ee8cf3b1a31f84d714ad4fbc",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zed/zed.d/zed-functions.sh",
  "human_readable_source": "#!/bin/sh\n# shellcheck disable=SC2154,SC3043\n# zed-functions.sh\n#\n# ZED helper functions for use in ZEDLETs\n\n\n# Variable Defaults\n#\n: \"${ZED_LOCKDIR:=\"/var/lock\"}\"\n: \"${ZED_NOTIFY_INTERVAL_SECS:=3600}\"\n: \"${ZED_NOTIFY_VERBOSE:=0}\"\n: \"${ZED_RUNDIR:=\"/var/run\"}\"\n: \"${ZED_SYSLOG_PRIORITY:=\"daemon.notice\"}\"\n: \"${ZED_SYSLOG_TAG:=\"zed\"}\"\n\nZED_FLOCK_FD=8\n\n\n# zed_check_cmd (cmd, ...)\n#\n# For each argument given, search PATH for the executable command [cmd].\n# Log a message if [cmd] is not found.\n#\n# Arguments\n#   cmd: name of executable command for which to search\n#\n# Return\n#   0 if all commands are found in PATH and are executable\n#   n for a count of the command executables that are not found\n#\nzed_check_cmd()\n{\n    local cmd\n    local rv=0\n\n    for cmd; do\n        if ! command -v \"${cmd}\" >/dev/null 2>&1; then\n            zed_log_err \"\\\"${cmd}\\\" not installed\"\n            rv=$((rv + 1))\n        fi\n    done\n    return \"${rv}\"\n}\n\n\n# zed_log_msg (msg, ...)\n#\n# Write all argument strings to the system log.\n#\n# Globals\n#   ZED_SYSLOG_PRIORITY\n#   ZED_SYSLOG_TAG\n#\n# Return\n#   nothing\n#\nzed_log_msg()\n{\n    logger -p \"${ZED_SYSLOG_PRIORITY}\" -t \"${ZED_SYSLOG_TAG}\" -- \"$@\"\n}\n\n\n# zed_log_err (msg, ...)\n#\n# Write an error message to the system log.  This message will contain the\n# script name, EID, and all argument strings.\n#\n# Globals\n#   ZED_SYSLOG_PRIORITY\n#   ZED_SYSLOG_TAG\n#   ZEVENT_EID\n#\n# Return\n#   nothing\n#\nzed_log_err()\n{\n    zed_log_msg \"error: ${0##*/}:\"\"${ZEVENT_EID:+\" eid=${ZEVENT_EID}:\"}\" \"$@\"\n}\n\n\n# zed_lock (lockfile, [fd])\n#\n# Obtain an exclusive (write) lock on [lockfile].  If the lock cannot be\n# immediately acquired, wait until it becomes available.\n#\n# Every zed_lock() must be paired with a corresponding zed_unlock().\n#\n# By default, flock-style locks associate the lockfile with file descriptor 8.\n# The bash manpage warns that file descriptors >9 should be used with care as\n# they may conflict with file descriptors used internally by the shell.  File\n# descriptor 9 is reserved for zed_rate_limit().  If concurrent locks are held\n# within the same process, they must use different file descriptors (preferably\n# decrementing from 8); otherwise, obtaining a new lock with a given file\n# descriptor will release the previous lock associated with that descriptor.\n#\n# Arguments\n#   lockfile: pathname of the lock file; the lock will be stored in\n#     ZED_LOCKDIR unless the pathname contains a \"/\".\n#   fd: integer for the file descriptor used by flock (OPTIONAL unless holding\n#     concurrent locks)\n#\n# Globals\n#   ZED_FLOCK_FD\n#   ZED_LOCKDIR\n#\n# Return\n#   nothing\n#\nzed_lock()\n{\n    local lockfile=\"$1\"\n    local fd=\"${2:-${ZED_FLOCK_FD}}\"\n    local umask_bak\n    local err\n\n    [ -n \"${lockfile}\" ] || return\n    if ! expr \"${lockfile}\" : '.*/' >/dev/null 2>&1; then\n        lockfile=\"${ZED_LOCKDIR}/${lockfile}\"\n    fi\n\n    umask_bak=\"$(umask)\"\n    umask 077\n\n    # Obtain a lock on the file bound to the given file descriptor.\n    #\n    eval \"exec ${fd}>> '${lockfile}'\"\n    if ! err=\"$(flock --exclusive \"${fd}\" 2>&1)\"; then\n        zed_log_err \"failed to lock \\\"${lockfile}\\\": ${err}\"\n    fi\n\n    umask \"${umask_bak}\"\n}\n\n\n# zed_unlock (lockfile, [fd])\n#\n# Release the lock on [lockfile].\n#\n# Arguments\n#   lockfile: pathname of the lock file\n#   fd: integer for the file descriptor used by flock (must match the file\n#     descriptor passed to the zed_lock function call)\n#\n# Globals\n#   ZED_FLOCK_FD\n#   ZED_LOCKDIR\n#\n# Return\n#   nothing\n#\nzed_unlock()\n{\n    local lockfile=\"$1\"\n    local fd=\"${2:-${ZED_FLOCK_FD}}\"\n    local err\n\n    [ -n \"${lockfile}\" ] || return\n    if ! expr \"${lockfile}\" : '.*/' >/dev/null 2>&1; then\n        lockfile=\"${ZED_LOCKDIR}/${lockfile}\"\n    fi\n\n    # Release the lock and close the file descriptor.\n    if ! err=\"$(flock --unlock \"${fd}\" 2>&1)\"; then\n        zed_log_err \"failed to unlock \\\"${lockfile}\\\": ${err}\"\n    fi\n    eval \"exec ${fd}>&-\"\n}\n\n\n# zed_notify (subject, pathname)\n#\n# Send a notification via all available methods.\n#\n# Arguments\n#   subject: notification subject\n#   pathname: pathname containing the notification message (OPTIONAL)\n#\n# Return\n#   0: notification succeeded via at least one method\n#   1: notification failed\n#   2: no notification methods configured\n#\nzed_notify()\n{\n    local subject=\"$1\"\n    local pathname=\"$2\"\n    local num_success=0\n    local num_failure=0\n\n    zed_notify_email \"${subject}\" \"${pathname}\"; rv=$?\n    [ \"${rv}\" -eq 0 ] && num_success=$((num_success + 1))\n    [ \"${rv}\" -eq 1 ] && num_failure=$((num_failure + 1))\n\n    zed_notify_pushbullet \"${subject}\" \"${pathname}\"; rv=$?\n    [ \"${rv}\" -eq 0 ] && num_success=$((num_success + 1))\n    [ \"${rv}\" -eq 1 ] && num_failure=$((num_failure + 1))\n\n    zed_notify_slack_webhook \"${subject}\" \"${pathname}\"; rv=$?\n    [ \"${rv}\" -eq 0 ] && num_success=$((num_success + 1))\n    [ \"${rv}\" -eq 1 ] && num_failure=$((num_failure + 1))\n\n    zed_notify_pushover \"${subject}\" \"${pathname}\"; rv=$?\n    [ \"${rv}\" -eq 0 ] && num_success=$((num_success + 1))\n    [ \"${rv}\" -eq 1 ] && num_failure=$((num_failure + 1))\n\n    [ \"${num_success}\" -gt 0 ] && return 0\n    [ \"${num_failure}\" -gt 0 ] && return 1\n    return 2\n}\n\n\n# zed_notify_email (subject, pathname)\n#\n# Send a notification via email to the address specified by ZED_EMAIL_ADDR.\n#\n# Requires the mail executable to be installed in the standard PATH, or\n# ZED_EMAIL_PROG to be defined with the pathname of an executable capable of\n# reading a message body from stdin.\n#\n# Command-line options to the mail executable can be specified in\n# ZED_EMAIL_OPTS.  This undergoes the following keyword substitutions:\n# - @ADDRESS@ is replaced with the space-delimited recipient email address(es)\n# - @SUBJECT@ is replaced with the notification subject\n#   If @SUBJECT@ was omited here, a \"Subject: ...\" header will be added to notification\n#\n#\n# Arguments\n#   subject: notification subject\n#   pathname: pathname containing the notification message (OPTIONAL)\n#\n# Globals\n#   ZED_EMAIL_PROG\n#   ZED_EMAIL_OPTS\n#   ZED_EMAIL_ADDR\n#\n# Return\n#   0: notification sent\n#   1: notification failed\n#   2: not configured\n#\nzed_notify_email()\n{\n    local subject=\"${1:-\"ZED notification\"}\"\n    local pathname=\"${2:-\"/dev/null\"}\"\n\n    : \"${ZED_EMAIL_PROG:=\"mail\"}\"\n    : \"${ZED_EMAIL_OPTS:=\"-s '@SUBJECT@' @ADDRESS@\"}\"\n\n    # For backward compatibility with ZED_EMAIL.\n    if [ -n \"${ZED_EMAIL}\" ] && [ -z \"${ZED_EMAIL_ADDR}\" ]; then\n        ZED_EMAIL_ADDR=\"${ZED_EMAIL}\"\n    fi\n    [ -n \"${ZED_EMAIL_ADDR}\" ] || return 2\n\n    zed_check_cmd \"${ZED_EMAIL_PROG}\" || return 1\n\n    [ -n \"${subject}\" ] || return 1\n    if [ ! -r \"${pathname}\" ]; then\n        zed_log_err \\\n                \"${ZED_EMAIL_PROG##*/} cannot read \\\"${pathname}\\\"\"\n        return 1\n    fi\n\n    # construct cmdline options\n    ZED_EMAIL_OPTS_PARSED=\"$(echo \"${ZED_EMAIL_OPTS}\" \\\n        | sed   -e \"s/@ADDRESS@/${ZED_EMAIL_ADDR}/g\" \\\n                -e \"s/@SUBJECT@/${subject}/g\")\"\n\n    # pipe message to email prog\n    # shellcheck disable=SC2086,SC2248\n    {\n        # no subject passed as option?\n        if [ \"${ZED_EMAIL_OPTS%@SUBJECT@*}\" = \"${ZED_EMAIL_OPTS}\" ] ; then\n            # inject subject header\n            printf \"Subject: %s\\n\" \"${subject}\"\n        fi\n        # output message\n        cat \"${pathname}\"\n    } |\n    eval ${ZED_EMAIL_PROG} ${ZED_EMAIL_OPTS_PARSED} >/dev/null 2>&1\n    rv=$?\n    if [ \"${rv}\" -ne 0 ]; then\n        zed_log_err \"${ZED_EMAIL_PROG##*/} exit=${rv}\"\n        return 1\n    fi\n    return 0\n}\n\n\n# zed_notify_pushbullet (subject, pathname)\n#\n# Send a notification via Pushbullet <https://www.pushbullet.com/>.\n# The access token (ZED_PUSHBULLET_ACCESS_TOKEN) identifies this client to the\n# Pushbullet server.  The optional channel tag (ZED_PUSHBULLET_CHANNEL_TAG) is\n# for pushing to notification feeds that can be subscribed to; if a channel is\n# not defined, push notifications will instead be sent to all devices\n# associated with the account specified by the access token.\n#\n# Requires awk, curl, and sed executables to be installed in the standard PATH.\n#\n# References\n#   https://docs.pushbullet.com/\n#   https://www.pushbullet.com/security\n#\n# Arguments\n#   subject: notification subject\n#   pathname: pathname containing the notification message (OPTIONAL)\n#\n# Globals\n#   ZED_PUSHBULLET_ACCESS_TOKEN\n#   ZED_PUSHBULLET_CHANNEL_TAG\n#\n# Return\n#   0: notification sent\n#   1: notification failed\n#   2: not configured\n#\nzed_notify_pushbullet()\n{\n    local subject=\"$1\"\n    local pathname=\"${2:-\"/dev/null\"}\"\n    local msg_body\n    local msg_tag\n    local msg_json\n    local msg_out\n    local msg_err\n    local url=\"https://api.pushbullet.com/v2/pushes\"\n\n    [ -n \"${ZED_PUSHBULLET_ACCESS_TOKEN}\" ] || return 2\n\n    [ -n \"${subject}\" ] || return 1\n    if [ ! -r \"${pathname}\" ]; then\n        zed_log_err \"pushbullet cannot read \\\"${pathname}\\\"\"\n        return 1\n    fi\n\n    zed_check_cmd \"awk\" \"curl\" \"sed\" || return 1\n\n    # Escape the following characters in the message body for JSON:\n    # newline, backslash, double quote, horizontal tab, vertical tab,\n    # and carriage return.\n    #\n    msg_body=\"$(awk '{ ORS=\"\\\\n\" } { gsub(/\\\\/, \"\\\\\\\\\"); gsub(/\"/, \"\\\\\\\"\");\n        gsub(/\\t/, \"\\\\t\"); gsub(/\\f/, \"\\\\f\"); gsub(/\\r/, \"\\\\r\"); print }' \\\n        \"${pathname}\")\"\n\n    # Push to a channel if one is configured.\n    #\n    [ -n \"${ZED_PUSHBULLET_CHANNEL_TAG}\" ] && msg_tag=\"$(printf \\\n        '\"channel_tag\": \"%s\", ' \"${ZED_PUSHBULLET_CHANNEL_TAG}\")\"\n\n    # Construct the JSON message for pushing a note.\n    #\n    msg_json=\"$(printf '{%s\"type\": \"note\", \"title\": \"%s\", \"body\": \"%s\"}' \\\n        \"${msg_tag}\" \"${subject}\" \"${msg_body}\")\"\n\n    # Send the POST request and check for errors.\n    #\n    msg_out=\"$(curl -u \"${ZED_PUSHBULLET_ACCESS_TOKEN}:\" -X POST \"${url}\" \\\n        --header \"Content-Type: application/json\" --data-binary \"${msg_json}\" \\\n        2>/dev/null)\"; rv=$?\n    if [ \"${rv}\" -ne 0 ]; then\n        zed_log_err \"curl exit=${rv}\"\n        return 1\n    fi\n    msg_err=\"$(echo \"${msg_out}\" \\\n        | sed -n -e 's/.*\"error\" *:.*\"message\" *: *\"\\([^\"]*\\)\".*/\\1/p')\"\n    if [ -n \"${msg_err}\" ]; then\n        zed_log_err \"pushbullet \\\"${msg_err}\"\\\"\n        return 1\n    fi\n    return 0\n}\n\n\n# zed_notify_slack_webhook (subject, pathname)\n#\n# Notification via Slack Webhook <https://api.slack.com/incoming-webhooks>.\n# The Webhook URL (ZED_SLACK_WEBHOOK_URL) identifies this client to the\n# Slack channel.\n#\n# Requires awk, curl, and sed executables to be installed in the standard PATH.\n#\n# References\n#   https://api.slack.com/incoming-webhooks\n#\n# Arguments\n#   subject: notification subject\n#   pathname: pathname containing the notification message (OPTIONAL)\n#\n# Globals\n#   ZED_SLACK_WEBHOOK_URL\n#\n# Return\n#   0: notification sent\n#   1: notification failed\n#   2: not configured\n#\nzed_notify_slack_webhook()\n{\n    [ -n \"${ZED_SLACK_WEBHOOK_URL}\" ] || return 2\n\n    local subject=\"$1\"\n    local pathname=\"${2:-\"/dev/null\"}\"\n    local msg_body\n    local msg_tag\n    local msg_json\n    local msg_out\n    local msg_err\n    local url=\"${ZED_SLACK_WEBHOOK_URL}\"\n\n    [ -n \"${subject}\" ] || return 1\n    if [ ! -r \"${pathname}\" ]; then\n        zed_log_err \"slack webhook cannot read \\\"${pathname}\\\"\"\n        return 1\n    fi\n\n    zed_check_cmd \"awk\" \"curl\" \"sed\" || return 1\n\n    # Escape the following characters in the message body for JSON:\n    # newline, backslash, double quote, horizontal tab, vertical tab,\n    # and carriage return.\n    #\n    msg_body=\"$(awk '{ ORS=\"\\\\n\" } { gsub(/\\\\/, \"\\\\\\\\\"); gsub(/\"/, \"\\\\\\\"\");\n        gsub(/\\t/, \"\\\\t\"); gsub(/\\f/, \"\\\\f\"); gsub(/\\r/, \"\\\\r\"); print }' \\\n        \"${pathname}\")\"\n\n    # Construct the JSON message for posting.\n    #\n    msg_json=\"$(printf '{\"text\": \"*%s*\\\\n%s\"}' \"${subject}\" \"${msg_body}\" )\"\n\n    # Send the POST request and check for errors.\n    #\n    msg_out=\"$(curl -X POST \"${url}\" \\\n        --header \"Content-Type: application/json\" --data-binary \"${msg_json}\" \\\n        2>/dev/null)\"; rv=$?\n    if [ \"${rv}\" -ne 0 ]; then\n        zed_log_err \"curl exit=${rv}\"\n        return 1\n    fi\n    msg_err=\"$(echo \"${msg_out}\" \\\n        | sed -n -e 's/.*\"error\" *:.*\"message\" *: *\"\\([^\"]*\\)\".*/\\1/p')\"\n    if [ -n \"${msg_err}\" ]; then\n        zed_log_err \"slack webhook \\\"${msg_err}\"\\\"\n        return 1\n    fi\n    return 0\n}\n\n# zed_notify_pushover (subject, pathname)\n#\n# Send a notification via Pushover <https://pushover.net/>.\n# The access token (ZED_PUSHOVER_TOKEN) identifies this client to the\n# Pushover server. The user token (ZED_PUSHOVER_USER) defines the user or\n# group to which the notification will be sent.\n#\n# Requires curl and sed executables to be installed in the standard PATH.\n#\n# References\n#   https://pushover.net/api\n#\n# Arguments\n#   subject: notification subject\n#   pathname: pathname containing the notification message (OPTIONAL)\n#\n# Globals\n#   ZED_PUSHOVER_TOKEN\n#   ZED_PUSHOVER_USER\n#\n# Return\n#   0: notification sent\n#   1: notification failed\n#   2: not configured\n#\nzed_notify_pushover()\n{\n    local subject=\"$1\"\n    local pathname=\"${2:-\"/dev/null\"}\"\n    local msg_body\n    local msg_out\n    local msg_err\n    local url=\"https://api.pushover.net/1/messages.json\"\n\n    [ -n \"${ZED_PUSHOVER_TOKEN}\" ] && [ -n \"${ZED_PUSHOVER_USER}\" ] || return 2\n\n    if [ ! -r \"${pathname}\" ]; then\n        zed_log_err \"pushover cannot read \\\"${pathname}\\\"\"\n        return 1\n    fi\n\n    zed_check_cmd \"curl\" \"sed\" || return 1\n\n    # Read the message body in.\n    #\n    msg_body=\"$(cat \"${pathname}\")\"\n\n    if [ -z \"${msg_body}\" ]\n    then\n        msg_body=$subject\n        subject=\"\"\n    fi\n\n    # Send the POST request and check for errors.\n    #\n    msg_out=\"$( \\\n        curl \\\n        --form-string \"token=${ZED_PUSHOVER_TOKEN}\" \\\n        --form-string \"user=${ZED_PUSHOVER_USER}\" \\\n        --form-string \"message=${msg_body}\" \\\n        --form-string \"title=${subject}\" \\\n        \"${url}\" \\\n        2>/dev/null \\\n        )\"; rv=$?\n    if [ \"${rv}\" -ne 0 ]; then\n        zed_log_err \"curl exit=${rv}\"\n        return 1\n    fi\n    msg_err=\"$(echo \"${msg_out}\" \\\n        | sed -n -e 's/.*\"errors\" *:.*\\[\\(.*\\)\\].*/\\1/p')\"\n    if [ -n \"${msg_err}\" ]; then\n        zed_log_err \"pushover \\\"${msg_err}\"\\\"\n        return 1\n    fi\n    return 0\n}\n\n\n# zed_rate_limit (tag, [interval])\n#\n# Check whether an event of a given type [tag] has already occurred within the\n# last [interval] seconds.\n#\n# This function obtains a lock on the statefile using file descriptor 9.\n#\n# Arguments\n#   tag: arbitrary string for grouping related events to rate-limit\n#   interval: time interval in seconds (OPTIONAL)\n#\n# Globals\n#   ZED_NOTIFY_INTERVAL_SECS\n#   ZED_RUNDIR\n#\n# Return\n#   0 if the event should be processed\n#   1 if the event should be dropped\n#\n# State File Format\n#   time;tag\n#\nzed_rate_limit()\n{\n    local tag=\"$1\"\n    local interval=\"${2:-${ZED_NOTIFY_INTERVAL_SECS}}\"\n    local lockfile=\"zed.zedlet.state.lock\"\n    local lockfile_fd=9\n    local statefile=\"${ZED_RUNDIR}/zed.zedlet.state\"\n    local time_now\n    local time_prev\n    local umask_bak\n    local rv=0\n\n    [ -n \"${tag}\" ] || return 0\n\n    zed_lock \"${lockfile}\" \"${lockfile_fd}\"\n    time_now=\"$(date +%s)\"\n    time_prev=\"$(grep -E \"^[0-9]+;${tag}\\$\" \"${statefile}\" 2>/dev/null \\\n        | tail -1 | cut -d\\; -f1)\"\n\n    if [ -n \"${time_prev}\" ] \\\n            && [ \"$((time_now - time_prev))\" -lt \"${interval}\" ]; then\n        rv=1\n    else\n        umask_bak=\"$(umask)\"\n        umask 077\n        grep -E -v \"^[0-9]+;${tag}\\$\" \"${statefile}\" 2>/dev/null \\\n            > \"${statefile}.$$\"\n        echo \"${time_now};${tag}\" >> \"${statefile}.$$\"\n        mv -f \"${statefile}.$$\" \"${statefile}\"\n        umask \"${umask_bak}\"\n    fi\n\n    zed_unlock \"${lockfile}\" \"${lockfile_fd}\"\n    return \"${rv}\"\n}\n\n\n# zed_guid_to_pool (guid)\n#\n# Convert a pool GUID into its pool name (like \"tank\")\n# Arguments\n#   guid: pool GUID (decimal or hex)\n#\n# Return\n#   Pool name\n#\nzed_guid_to_pool()\n{\n\tif [ -z \"$1\" ] ; then\n\t\treturn\n\tfi\n\n\tguid=\"$(printf \"%u\" \"$1\")\"\n\t$ZPOOL get -H -ovalue,name guid | awk '$1 == '\"$guid\"' {print $2; exit}'\n}\n\n# zed_exit_if_ignoring_this_event\n#\n# Exit the script if we should ignore this event, as determined by\n# $ZED_SYSLOG_SUBCLASS_INCLUDE and $ZED_SYSLOG_SUBCLASS_EXCLUDE in zed.rc.\n# This function assumes you've imported the normal zed variables.\nzed_exit_if_ignoring_this_event()\n{\n\tif [ -n \"${ZED_SYSLOG_SUBCLASS_INCLUDE}\" ]; then\n\t    eval \"case ${ZEVENT_SUBCLASS} in\n\t    ${ZED_SYSLOG_SUBCLASS_INCLUDE});;\n\t    *) exit 0;;\n\t    esac\"\n\telif [ -n \"${ZED_SYSLOG_SUBCLASS_EXCLUDE}\" ]; then\n\t    eval \"case ${ZEVENT_SUBCLASS} in\n\t    ${ZED_SYSLOG_SUBCLASS_EXCLUDE}) exit 0;;\n\t    *);;\n\t    esac\"\n\tfi\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}