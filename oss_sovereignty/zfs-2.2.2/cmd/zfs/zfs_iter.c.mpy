{
  "module_name": "zfs_iter.c",
  "hash_id": "1c1cee26c253e58cba95cafddaa54e09d92b1c1aaa2f7f1a6b40c373237a3c05",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zfs/zfs_iter.c",
  "human_readable_source": " \n\n \n\n#include <libintl.h>\n#include <libuutil.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <libzfs.h>\n\n#include \"zfs_util.h\"\n#include \"zfs_iter.h\"\n\n \n\ntypedef struct zfs_node {\n\tzfs_handle_t\t*zn_handle;\n\tuu_avl_node_t\tzn_avlnode;\n} zfs_node_t;\n\ntypedef struct callback_data {\n\tuu_avl_t\t\t*cb_avl;\n\tint\t\t\tcb_flags;\n\tzfs_type_t\t\tcb_types;\n\tzfs_sort_column_t\t*cb_sortcol;\n\tzprop_list_t\t\t**cb_proplist;\n\tint\t\t\tcb_depth_limit;\n\tint\t\t\tcb_depth;\n\tuint8_t\t\t\tcb_props_table[ZFS_NUM_PROPS];\n} callback_data_t;\n\nuu_avl_pool_t *avl_pool;\n\n \nstatic boolean_t\nzfs_include_snapshots(zfs_handle_t *zhp, callback_data_t *cb)\n{\n\tzpool_handle_t *zph;\n\n\tif ((cb->cb_flags & ZFS_ITER_PROP_LISTSNAPS) == 0)\n\t\treturn (cb->cb_types & ZFS_TYPE_SNAPSHOT);\n\n\tzph = zfs_get_pool_handle(zhp);\n\treturn (zpool_get_prop_int(zph, ZPOOL_PROP_LISTSNAPS, NULL));\n}\n\n \nstatic int\nzfs_callback(zfs_handle_t *zhp, void *data)\n{\n\tcallback_data_t *cb = data;\n\tboolean_t should_close = B_TRUE;\n\tboolean_t include_snaps = zfs_include_snapshots(zhp, cb);\n\tboolean_t include_bmarks = (cb->cb_types & ZFS_TYPE_BOOKMARK);\n\n\tif ((zfs_get_type(zhp) & cb->cb_types) ||\n\t    ((zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) && include_snaps)) {\n\t\tuu_avl_index_t idx;\n\t\tzfs_node_t *node = safe_malloc(sizeof (zfs_node_t));\n\n\t\tnode->zn_handle = zhp;\n\t\tuu_avl_node_init(node, &node->zn_avlnode, avl_pool);\n\t\tif (uu_avl_find(cb->cb_avl, node, cb->cb_sortcol,\n\t\t    &idx) == NULL) {\n\t\t\tif (cb->cb_proplist) {\n\t\t\t\tif ((*cb->cb_proplist) &&\n\t\t\t\t    !(*cb->cb_proplist)->pl_all)\n\t\t\t\t\tzfs_prune_proplist(zhp,\n\t\t\t\t\t    cb->cb_props_table);\n\n\t\t\t\tif (zfs_expand_proplist(zhp, cb->cb_proplist,\n\t\t\t\t    (cb->cb_flags & ZFS_ITER_RECVD_PROPS),\n\t\t\t\t    (cb->cb_flags & ZFS_ITER_LITERAL_PROPS))\n\t\t\t\t    != 0) {\n\t\t\t\t\tfree(node);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tuu_avl_insert(cb->cb_avl, node, idx);\n\t\t\tshould_close = B_FALSE;\n\t\t} else {\n\t\t\tfree(node);\n\t\t}\n\t}\n\n\t \n\tif (cb->cb_flags & ZFS_ITER_RECURSE &&\n\t    ((cb->cb_flags & ZFS_ITER_DEPTH_LIMIT) == 0 ||\n\t    cb->cb_depth < cb->cb_depth_limit)) {\n\t\tcb->cb_depth++;\n\n\t\t \n\t\tif ((cb->cb_depth < cb->cb_depth_limit ||\n\t\t    (cb->cb_flags & ZFS_ITER_DEPTH_LIMIT) == 0 ||\n\t\t    (cb->cb_types &\n\t\t    (ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME))) &&\n\t\t    zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) {\n\t\t\t(void) zfs_iter_filesystems_v2(zhp, cb->cb_flags,\n\t\t\t    zfs_callback, data);\n\t\t}\n\n\t\tif (((zfs_get_type(zhp) & (ZFS_TYPE_SNAPSHOT |\n\t\t    ZFS_TYPE_BOOKMARK)) == 0) && include_snaps) {\n\t\t\t(void) zfs_iter_snapshots_v2(zhp, cb->cb_flags,\n\t\t\t    zfs_callback, data, 0, 0);\n\t\t}\n\n\t\tif (((zfs_get_type(zhp) & (ZFS_TYPE_SNAPSHOT |\n\t\t    ZFS_TYPE_BOOKMARK)) == 0) && include_bmarks) {\n\t\t\t(void) zfs_iter_bookmarks_v2(zhp, cb->cb_flags,\n\t\t\t    zfs_callback, data);\n\t\t}\n\n\t\tcb->cb_depth--;\n\t}\n\n\tif (should_close)\n\t\tzfs_close(zhp);\n\n\treturn (0);\n}\n\nint\nzfs_add_sort_column(zfs_sort_column_t **sc, const char *name,\n    boolean_t reverse)\n{\n\tzfs_sort_column_t *col;\n\tzfs_prop_t prop;\n\n\tif ((prop = zfs_name_to_prop(name)) == ZPROP_USERPROP &&\n\t    !zfs_prop_user(name))\n\t\treturn (-1);\n\n\tcol = safe_malloc(sizeof (zfs_sort_column_t));\n\n\tcol->sc_prop = prop;\n\tcol->sc_reverse = reverse;\n\tif (prop == ZPROP_USERPROP) {\n\t\tcol->sc_user_prop = safe_malloc(strlen(name) + 1);\n\t\t(void) strcpy(col->sc_user_prop, name);\n\t}\n\n\tif (*sc == NULL) {\n\t\tcol->sc_last = col;\n\t\t*sc = col;\n\t} else {\n\t\t(*sc)->sc_last->sc_next = col;\n\t\t(*sc)->sc_last = col;\n\t}\n\n\treturn (0);\n}\n\nvoid\nzfs_free_sort_columns(zfs_sort_column_t *sc)\n{\n\tzfs_sort_column_t *col;\n\n\twhile (sc != NULL) {\n\t\tcol = sc->sc_next;\n\t\tfree(sc->sc_user_prop);\n\t\tfree(sc);\n\t\tsc = col;\n\t}\n}\n\n \nboolean_t\nzfs_sort_only_by_fast(const zfs_sort_column_t *sc)\n{\n\twhile (sc != NULL) {\n\t\tswitch (sc->sc_prop) {\n\t\tcase ZFS_PROP_NAME:\n\t\tcase ZFS_PROP_GUID:\n\t\tcase ZFS_PROP_CREATETXG:\n\t\tcase ZFS_PROP_NUMCLONES:\n\t\tcase ZFS_PROP_INCONSISTENT:\n\t\tcase ZFS_PROP_REDACTED:\n\t\tcase ZFS_PROP_ORIGIN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (B_FALSE);\n\t\t}\n\t\tsc = sc->sc_next;\n\t}\n\n\treturn (B_TRUE);\n}\n\nboolean_t\nzfs_list_only_by_fast(const zprop_list_t *p)\n{\n\tif (p == NULL) {\n\t\t \n\t\treturn (B_FALSE);\n\t}\n\n\twhile (p != NULL) {\n\t\tswitch (p->pl_prop) {\n\t\tcase ZFS_PROP_NAME:\n\t\tcase ZFS_PROP_GUID:\n\t\tcase ZFS_PROP_CREATETXG:\n\t\tcase ZFS_PROP_NUMCLONES:\n\t\tcase ZFS_PROP_INCONSISTENT:\n\t\tcase ZFS_PROP_REDACTED:\n\t\tcase ZFS_PROP_ORIGIN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (B_FALSE);\n\t\t}\n\t\tp = p->pl_next;\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic int\nzfs_compare(const void *larg, const void *rarg)\n{\n\tzfs_handle_t *l = ((zfs_node_t *)larg)->zn_handle;\n\tzfs_handle_t *r = ((zfs_node_t *)rarg)->zn_handle;\n\tconst char *lname = zfs_get_name(l);\n\tconst char *rname = zfs_get_name(r);\n\tchar *lat, *rat;\n\tuint64_t lcreate, rcreate;\n\tint ret;\n\n\tlat = (char *)strchr(lname, '@');\n\trat = (char *)strchr(rname, '@');\n\n\tif (lat != NULL)\n\t\t*lat = '\\0';\n\tif (rat != NULL)\n\t\t*rat = '\\0';\n\n\tret = strcmp(lname, rname);\n\tif (ret == 0 && (lat != NULL || rat != NULL)) {\n\t\t \n\t\tif (lat == NULL) {\n\t\t\tret = -1;\n\t\t} else if (rat == NULL) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\t \n\t\t\tlcreate = zfs_prop_get_int(l, ZFS_PROP_CREATETXG);\n\t\t\trcreate = zfs_prop_get_int(r, ZFS_PROP_CREATETXG);\n\n\t\t\t \n\t\t\tif (lcreate == 0 && rcreate == 0)\n\t\t\t\tret = strcmp(lat + 1, rat + 1);\n\t\t\telse if (lcreate < rcreate)\n\t\t\t\tret = -1;\n\t\t\telse if (lcreate > rcreate)\n\t\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (lat != NULL)\n\t\t*lat = '@';\n\tif (rat != NULL)\n\t\t*rat = '@';\n\n\treturn (ret);\n}\n\n \nstatic int\nzfs_sort(const void *larg, const void *rarg, void *data)\n{\n\tzfs_handle_t *l = ((zfs_node_t *)larg)->zn_handle;\n\tzfs_handle_t *r = ((zfs_node_t *)rarg)->zn_handle;\n\tzfs_sort_column_t *sc = (zfs_sort_column_t *)data;\n\tzfs_sort_column_t *psc;\n\n\tfor (psc = sc; psc != NULL; psc = psc->sc_next) {\n\t\tchar lbuf[ZFS_MAXPROPLEN], rbuf[ZFS_MAXPROPLEN];\n\t\tconst char *lstr, *rstr;\n\t\tuint64_t lnum = 0, rnum = 0;\n\t\tboolean_t lvalid, rvalid;\n\t\tint ret = 0;\n\n\t\t \n\t\tlstr = rstr = NULL;\n\t\tif (psc->sc_prop == ZPROP_USERPROP) {\n\t\t\tnvlist_t *luser, *ruser;\n\t\t\tnvlist_t *lval, *rval;\n\n\t\t\tluser = zfs_get_user_props(l);\n\t\t\truser = zfs_get_user_props(r);\n\n\t\t\tlvalid = (nvlist_lookup_nvlist(luser,\n\t\t\t    psc->sc_user_prop, &lval) == 0);\n\t\t\trvalid = (nvlist_lookup_nvlist(ruser,\n\t\t\t    psc->sc_user_prop, &rval) == 0);\n\n\t\t\tif (lvalid)\n\t\t\t\tverify(nvlist_lookup_string(lval,\n\t\t\t\t    ZPROP_VALUE, &lstr) == 0);\n\t\t\tif (rvalid)\n\t\t\t\tverify(nvlist_lookup_string(rval,\n\t\t\t\t    ZPROP_VALUE, &rstr) == 0);\n\t\t} else if (psc->sc_prop == ZFS_PROP_NAME) {\n\t\t\tlvalid = rvalid = B_TRUE;\n\n\t\t\t(void) strlcpy(lbuf, zfs_get_name(l), sizeof (lbuf));\n\t\t\t(void) strlcpy(rbuf, zfs_get_name(r), sizeof (rbuf));\n\n\t\t\tlstr = lbuf;\n\t\t\trstr = rbuf;\n\t\t} else if (zfs_prop_is_string(psc->sc_prop)) {\n\t\t\tlvalid = (zfs_prop_get(l, psc->sc_prop, lbuf,\n\t\t\t    sizeof (lbuf), NULL, NULL, 0, B_TRUE) == 0);\n\t\t\trvalid = (zfs_prop_get(r, psc->sc_prop, rbuf,\n\t\t\t    sizeof (rbuf), NULL, NULL, 0, B_TRUE) == 0);\n\n\t\t\tlstr = lbuf;\n\t\t\trstr = rbuf;\n\t\t} else {\n\t\t\tlvalid = zfs_prop_valid_for_type(psc->sc_prop,\n\t\t\t    zfs_get_type(l), B_FALSE);\n\t\t\trvalid = zfs_prop_valid_for_type(psc->sc_prop,\n\t\t\t    zfs_get_type(r), B_FALSE);\n\n\t\t\tif (lvalid)\n\t\t\t\tlnum = zfs_prop_get_int(l, psc->sc_prop);\n\t\t\tif (rvalid)\n\t\t\t\trnum = zfs_prop_get_int(r, psc->sc_prop);\n\t\t}\n\n\t\tif (!lvalid && !rvalid)\n\t\t\tcontinue;\n\t\telse if (!lvalid)\n\t\t\treturn (1);\n\t\telse if (!rvalid)\n\t\t\treturn (-1);\n\n\t\tif (lstr)\n\t\t\tret = strcmp(lstr, rstr);\n\t\telse if (lnum < rnum)\n\t\t\tret = -1;\n\t\telse if (lnum > rnum)\n\t\t\tret = 1;\n\n\t\tif (ret != 0) {\n\t\t\tif (psc->sc_reverse == B_TRUE)\n\t\t\t\tret = (ret < 0) ? 1 : -1;\n\t\t\treturn (ret);\n\t\t}\n\t}\n\n\treturn (zfs_compare(larg, rarg));\n}\n\nint\nzfs_for_each(int argc, char **argv, int flags, zfs_type_t types,\n    zfs_sort_column_t *sortcol, zprop_list_t **proplist, int limit,\n    zfs_iter_f callback, void *data)\n{\n\tcallback_data_t cb = {0};\n\tint ret = 0;\n\tzfs_node_t *node;\n\tuu_avl_walk_t *walk;\n\n\tavl_pool = uu_avl_pool_create(\"zfs_pool\", sizeof (zfs_node_t),\n\t    offsetof(zfs_node_t, zn_avlnode), zfs_sort, UU_DEFAULT);\n\n\tif (avl_pool == NULL)\n\t\tnomem();\n\n\tcb.cb_sortcol = sortcol;\n\tcb.cb_flags = flags;\n\tcb.cb_proplist = proplist;\n\tcb.cb_types = types;\n\tcb.cb_depth_limit = limit;\n\t \n\tif (cb.cb_proplist && *cb.cb_proplist) {\n\t\tzprop_list_t *p = *cb.cb_proplist;\n\n\t\twhile (p) {\n\t\t\tif (p->pl_prop >= ZFS_PROP_TYPE &&\n\t\t\t    p->pl_prop < ZFS_NUM_PROPS) {\n\t\t\t\tcb.cb_props_table[p->pl_prop] = B_TRUE;\n\t\t\t}\n\t\t\tp = p->pl_next;\n\t\t}\n\n\t\twhile (sortcol) {\n\t\t\tif (sortcol->sc_prop >= ZFS_PROP_TYPE &&\n\t\t\t    sortcol->sc_prop < ZFS_NUM_PROPS) {\n\t\t\t\tcb.cb_props_table[sortcol->sc_prop] = B_TRUE;\n\t\t\t}\n\t\t\tsortcol = sortcol->sc_next;\n\t\t}\n\n\t\tcb.cb_props_table[ZFS_PROP_ZONED] = B_TRUE;\n\t\tcb.cb_props_table[ZFS_PROP_CREATETXG] = B_TRUE;\n\t} else {\n\t\t(void) memset(cb.cb_props_table, B_TRUE,\n\t\t    sizeof (cb.cb_props_table));\n\t}\n\n\tif ((cb.cb_avl = uu_avl_create(avl_pool, NULL, UU_DEFAULT)) == NULL)\n\t\tnomem();\n\n\tif (argc == 0) {\n\t\t \n\t\tcb.cb_flags |= ZFS_ITER_RECURSE;\n\t\tret = zfs_iter_root(g_zfs, zfs_callback, &cb);\n\t} else {\n\t\tzfs_handle_t *zhp = NULL;\n\t\tzfs_type_t argtype = types;\n\n\t\t \n\t\tif (flags & ZFS_ITER_RECURSE) {\n\t\t\targtype |= ZFS_TYPE_FILESYSTEM;\n\t\t\tif (types & (ZFS_TYPE_SNAPSHOT | ZFS_TYPE_BOOKMARK))\n\t\t\t\targtype |= ZFS_TYPE_VOLUME;\n\t\t}\n\n\t\tfor (int i = 0; i < argc; i++) {\n\t\t\tif (flags & ZFS_ITER_ARGS_CAN_BE_PATHS) {\n\t\t\t\tzhp = zfs_path_to_zhandle(g_zfs, argv[i],\n\t\t\t\t    argtype);\n\t\t\t} else {\n\t\t\t\tzhp = zfs_open(g_zfs, argv[i], argtype);\n\t\t\t}\n\t\t\tif (zhp != NULL)\n\t\t\t\tret |= zfs_callback(zhp, &cb);\n\t\t\telse\n\t\t\t\tret = 1;\n\t\t}\n\t}\n\n\t \n\tfor (node = uu_avl_first(cb.cb_avl); node != NULL;\n\t    node = uu_avl_next(cb.cb_avl, node))\n\t\tret |= callback(node->zn_handle, data);\n\n\t \n\tif ((walk = uu_avl_walk_start(cb.cb_avl, UU_WALK_ROBUST)) == NULL)\n\t\tnomem();\n\n\twhile ((node = uu_avl_walk_next(walk)) != NULL) {\n\t\tuu_avl_remove(cb.cb_avl, node);\n\t\tzfs_close(node->zn_handle);\n\t\tfree(node);\n\t}\n\n\tuu_avl_walk_end(walk);\n\tuu_avl_destroy(cb.cb_avl);\n\tuu_avl_pool_destroy(avl_pool);\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}