{
  "module_name": "zfs_project.c",
  "hash_id": "a14935d3796c465eece36fd8a972e39bebefd751fa047e5af987b842de158f26",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zfs/zfs_project.c",
  "human_readable_source": " \n\n \n\n#include <errno.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <stddef.h>\n#include <libintl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/list.h>\n#include <sys/zfs_project.h>\n\n#include \"zfs_util.h\"\n#include \"zfs_projectutil.h\"\n\ntypedef struct zfs_project_item {\n\tlist_node_t\tzpi_list;\n\tchar\t\tzpi_name[0];\n} zfs_project_item_t;\n\nstatic void\nzfs_project_item_alloc(list_t *head, const char *name)\n{\n\tzfs_project_item_t *zpi;\n\n\tzpi = safe_malloc(sizeof (zfs_project_item_t) + strlen(name) + 1);\n\tstrcpy(zpi->zpi_name, name);\n\tlist_insert_tail(head, zpi);\n}\n\nstatic int\nzfs_project_sanity_check(const char *name, zfs_project_control_t *zpc,\n    struct stat *st)\n{\n\tint ret;\n\n\tret = stat(name, st);\n\tif (ret) {\n\t\t(void) fprintf(stderr, gettext(\"failed to stat %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\t\treturn (ret);\n\t}\n\n\tif (!S_ISREG(st->st_mode) && !S_ISDIR(st->st_mode)) {\n\t\t(void) fprintf(stderr, gettext(\"only support project quota on \"\n\t\t    \"regular file or directory\\n\"));\n\t\treturn (-1);\n\t}\n\n\tif (!S_ISDIR(st->st_mode)) {\n\t\tif (zpc->zpc_dironly) {\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"'-d' option on non-dir target %s\\n\"), name);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (zpc->zpc_recursive) {\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"'-r' option on non-dir target %s\\n\"), name);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzfs_project_load_projid(const char *name, zfs_project_control_t *zpc)\n{\n\tzfsxattr_t fsx;\n\tint ret, fd;\n\n\tfd = open(name, O_RDONLY | O_NOCTTY);\n\tif (fd < 0) {\n\t\t(void) fprintf(stderr, gettext(\"failed to open %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\t\treturn (fd);\n\t}\n\n\tret = ioctl(fd, ZFS_IOC_FSGETXATTR, &fsx);\n\tif (ret)\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"failed to get xattr for %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\telse\n\t\tzpc->zpc_expected_projid = fsx.fsx_projid;\n\n\tclose(fd);\n\treturn (ret);\n}\n\nstatic int\nzfs_project_handle_one(const char *name, zfs_project_control_t *zpc)\n{\n\tzfsxattr_t fsx;\n\tint ret, fd;\n\n\tfd = open(name, O_RDONLY | O_NOCTTY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT && zpc->zpc_ignore_noent)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"failed to open %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\t\treturn (fd);\n\t}\n\n\tret = ioctl(fd, ZFS_IOC_FSGETXATTR, &fsx);\n\tif (ret) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"failed to get xattr for %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tswitch (zpc->zpc_op) {\n\tcase ZFS_PROJECT_OP_LIST:\n\t\t(void) printf(\"%5u %c %s\\n\", fsx.fsx_projid,\n\t\t    (fsx.fsx_xflags & ZFS_PROJINHERIT_FL) ? 'P' : '-', name);\n\t\tgoto out;\n\tcase ZFS_PROJECT_OP_CHECK:\n\t\tif (fsx.fsx_projid == zpc->zpc_expected_projid &&\n\t\t    fsx.fsx_xflags & ZFS_PROJINHERIT_FL)\n\t\t\tgoto out;\n\n\t\tif (!zpc->zpc_newline) {\n\t\t\tchar c = '\\0';\n\n\t\t\t(void) printf(\"%s%c\", name, c);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fsx.fsx_projid != zpc->zpc_expected_projid)\n\t\t\t(void) printf(\"%s - project ID is not set properly \"\n\t\t\t    \"(%u/%u)\\n\", name, fsx.fsx_projid,\n\t\t\t    (uint32_t)zpc->zpc_expected_projid);\n\n\t\tif (!(fsx.fsx_xflags & ZFS_PROJINHERIT_FL))\n\t\t\t(void) printf(\"%s - project inherit flag is not set\\n\",\n\t\t\t    name);\n\n\t\tgoto out;\n\tcase ZFS_PROJECT_OP_CLEAR:\n\t\tif (!(fsx.fsx_xflags & ZFS_PROJINHERIT_FL) &&\n\t\t    (zpc->zpc_keep_projid ||\n\t\t    fsx.fsx_projid == ZFS_DEFAULT_PROJID))\n\t\t\tgoto out;\n\n\t\tfsx.fsx_xflags &= ~ZFS_PROJINHERIT_FL;\n\t\tif (!zpc->zpc_keep_projid)\n\t\t\tfsx.fsx_projid = ZFS_DEFAULT_PROJID;\n\t\tbreak;\n\tcase ZFS_PROJECT_OP_SET:\n\t\tif (fsx.fsx_projid == zpc->zpc_expected_projid &&\n\t\t    (!zpc->zpc_set_flag || fsx.fsx_xflags & ZFS_PROJINHERIT_FL))\n\t\t\tgoto out;\n\n\t\tfsx.fsx_projid = zpc->zpc_expected_projid;\n\t\tif (zpc->zpc_set_flag)\n\t\t\tfsx.fsx_xflags |= ZFS_PROJINHERIT_FL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tret = ioctl(fd, ZFS_IOC_FSSETXATTR, &fsx);\n\tif (ret)\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"failed to set xattr for %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\nout:\n\tclose(fd);\n\treturn (ret);\n}\n\nstatic int\nzfs_project_handle_dir(const char *name, zfs_project_control_t *zpc,\n    list_t *head)\n{\n\tstruct dirent *ent;\n\tDIR *dir;\n\tint ret = 0;\n\n\tdir = opendir(name);\n\tif (dir == NULL) {\n\t\tif (errno == ENOENT && zpc->zpc_ignore_noent)\n\t\t\treturn (0);\n\n\t\tret = -errno;\n\t\t(void) fprintf(stderr, gettext(\"failed to opendir %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\t\treturn (ret);\n\t}\n\n\t \n\tzpc->zpc_ignore_noent = B_TRUE;\n\terrno = 0;\n\twhile (!ret && (ent = readdir(dir)) != NULL) {\n\t\tchar *fullname;\n\n\t\t \n\t\tif (strcmp(ent->d_name, \".\") == 0 ||\n\t\t    strcmp(ent->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tif (strlen(ent->d_name) + strlen(name) + 1 >= PATH_MAX) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (asprintf(&fullname, \"%s/%s\", name, ent->d_name) == -1) {\n\t\t\terrno = ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = zfs_project_handle_one(fullname, zpc);\n\t\tif (!ret && zpc->zpc_recursive && ent->d_type == DT_DIR)\n\t\t\tzfs_project_item_alloc(head, fullname);\n\n\t\tfree(fullname);\n\t}\n\n\tif (errno && !ret) {\n\t\tret = -errno;\n\t\t(void) fprintf(stderr, gettext(\"failed to readdir %s: %s\\n\"),\n\t\t    name, strerror(errno));\n\t}\n\n\tclosedir(dir);\n\treturn (ret);\n}\n\nint\nzfs_project_handle(const char *name, zfs_project_control_t *zpc)\n{\n\tzfs_project_item_t *zpi;\n\tstruct stat st;\n\tlist_t head;\n\tint ret;\n\n\tret = zfs_project_sanity_check(name, zpc, &st);\n\tif (ret)\n\t\treturn (ret);\n\n\tif ((zpc->zpc_op == ZFS_PROJECT_OP_SET ||\n\t    zpc->zpc_op == ZFS_PROJECT_OP_CHECK) &&\n\t    zpc->zpc_expected_projid == ZFS_INVALID_PROJID) {\n\t\tret = zfs_project_load_projid(name, zpc);\n\t\tif (ret)\n\t\t\treturn (ret);\n\t}\n\n\tzpc->zpc_ignore_noent = B_FALSE;\n\tret = zfs_project_handle_one(name, zpc);\n\tif (ret || !S_ISDIR(st.st_mode) || zpc->zpc_dironly ||\n\t    (!zpc->zpc_recursive &&\n\t    zpc->zpc_op != ZFS_PROJECT_OP_LIST &&\n\t    zpc->zpc_op != ZFS_PROJECT_OP_CHECK))\n\t\treturn (ret);\n\n\tlist_create(&head, sizeof (zfs_project_item_t),\n\t    offsetof(zfs_project_item_t, zpi_list));\n\tzfs_project_item_alloc(&head, name);\n\twhile ((zpi = list_remove_head(&head)) != NULL) {\n\t\tif (!ret)\n\t\t\tret = zfs_project_handle_dir(zpi->zpi_name, zpc, &head);\n\t\tfree(zpi);\n\t}\n\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}