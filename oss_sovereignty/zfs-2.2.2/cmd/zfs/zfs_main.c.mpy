{
  "module_name": "zfs_main.c",
  "hash_id": "3386bfdac6154df5eba2ffa1f4c697e0673b3a2dff2eef1c77e3c6270bee5efb",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zfs/zfs_main.c",
  "human_readable_source": " \n\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <sys/debug.h>\n#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <libintl.h>\n#include <libuutil.h>\n#include <libnvpair.h>\n#include <locale.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <zone.h>\n#include <grp.h>\n#include <pwd.h>\n#include <umem.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/list.h>\n#include <sys/mkdev.h>\n#include <sys/mntent.h>\n#include <sys/mnttab.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/fs/zfs.h>\n#include <sys/systeminfo.h>\n#include <sys/types.h>\n#include <time.h>\n#include <sys/zfs_project.h>\n\n#include <libzfs.h>\n#include <libzfs_core.h>\n#include <zfs_prop.h>\n#include <zfs_deleg.h>\n#include <libzutil.h>\n#ifdef HAVE_IDMAP\n#include <aclutils.h>\n#include <directory.h>\n#endif  \n\n#include \"zfs_iter.h\"\n#include \"zfs_util.h\"\n#include \"zfs_comutil.h\"\n#include \"zfs_projectutil.h\"\n\nlibzfs_handle_t *g_zfs;\n\nstatic char history_str[HIS_MAX_RECORD_LEN];\nstatic boolean_t log_history = B_TRUE;\n\nstatic int zfs_do_clone(int argc, char **argv);\nstatic int zfs_do_create(int argc, char **argv);\nstatic int zfs_do_destroy(int argc, char **argv);\nstatic int zfs_do_get(int argc, char **argv);\nstatic int zfs_do_inherit(int argc, char **argv);\nstatic int zfs_do_list(int argc, char **argv);\nstatic int zfs_do_mount(int argc, char **argv);\nstatic int zfs_do_rename(int argc, char **argv);\nstatic int zfs_do_rollback(int argc, char **argv);\nstatic int zfs_do_set(int argc, char **argv);\nstatic int zfs_do_upgrade(int argc, char **argv);\nstatic int zfs_do_snapshot(int argc, char **argv);\nstatic int zfs_do_unmount(int argc, char **argv);\nstatic int zfs_do_share(int argc, char **argv);\nstatic int zfs_do_unshare(int argc, char **argv);\nstatic int zfs_do_send(int argc, char **argv);\nstatic int zfs_do_receive(int argc, char **argv);\nstatic int zfs_do_promote(int argc, char **argv);\nstatic int zfs_do_userspace(int argc, char **argv);\nstatic int zfs_do_allow(int argc, char **argv);\nstatic int zfs_do_unallow(int argc, char **argv);\nstatic int zfs_do_hold(int argc, char **argv);\nstatic int zfs_do_holds(int argc, char **argv);\nstatic int zfs_do_release(int argc, char **argv);\nstatic int zfs_do_diff(int argc, char **argv);\nstatic int zfs_do_bookmark(int argc, char **argv);\nstatic int zfs_do_channel_program(int argc, char **argv);\nstatic int zfs_do_load_key(int argc, char **argv);\nstatic int zfs_do_unload_key(int argc, char **argv);\nstatic int zfs_do_change_key(int argc, char **argv);\nstatic int zfs_do_project(int argc, char **argv);\nstatic int zfs_do_version(int argc, char **argv);\nstatic int zfs_do_redact(int argc, char **argv);\nstatic int zfs_do_wait(int argc, char **argv);\n\n#ifdef __FreeBSD__\nstatic int zfs_do_jail(int argc, char **argv);\nstatic int zfs_do_unjail(int argc, char **argv);\n#endif\n\n#ifdef __linux__\nstatic int zfs_do_zone(int argc, char **argv);\nstatic int zfs_do_unzone(int argc, char **argv);\n#endif\n\nstatic int zfs_do_help(int argc, char **argv);\n\n \n\n#ifdef DEBUG\nconst char *\n_umem_debug_init(void)\n{\n\treturn (\"default,verbose\");  \n}\n\nconst char *\n_umem_logging_init(void)\n{\n\treturn (\"fail,contents\");  \n}\n#endif\n\ntypedef enum {\n\tHELP_CLONE,\n\tHELP_CREATE,\n\tHELP_DESTROY,\n\tHELP_GET,\n\tHELP_INHERIT,\n\tHELP_UPGRADE,\n\tHELP_LIST,\n\tHELP_MOUNT,\n\tHELP_PROMOTE,\n\tHELP_RECEIVE,\n\tHELP_RENAME,\n\tHELP_ROLLBACK,\n\tHELP_SEND,\n\tHELP_SET,\n\tHELP_SHARE,\n\tHELP_SNAPSHOT,\n\tHELP_UNMOUNT,\n\tHELP_UNSHARE,\n\tHELP_ALLOW,\n\tHELP_UNALLOW,\n\tHELP_USERSPACE,\n\tHELP_GROUPSPACE,\n\tHELP_PROJECTSPACE,\n\tHELP_PROJECT,\n\tHELP_HOLD,\n\tHELP_HOLDS,\n\tHELP_RELEASE,\n\tHELP_DIFF,\n\tHELP_BOOKMARK,\n\tHELP_CHANNEL_PROGRAM,\n\tHELP_LOAD_KEY,\n\tHELP_UNLOAD_KEY,\n\tHELP_CHANGE_KEY,\n\tHELP_VERSION,\n\tHELP_REDACT,\n\tHELP_JAIL,\n\tHELP_UNJAIL,\n\tHELP_WAIT,\n\tHELP_ZONE,\n\tHELP_UNZONE,\n} zfs_help_t;\n\ntypedef struct zfs_command {\n\tconst char\t*name;\n\tint\t\t(*func)(int argc, char **argv);\n\tzfs_help_t\tusage;\n} zfs_command_t;\n\n \nstatic zfs_command_t command_table[] = {\n\t{ \"version\",\tzfs_do_version, \tHELP_VERSION\t\t},\n\t{ NULL },\n\t{ \"create\",\tzfs_do_create,\t\tHELP_CREATE\t\t},\n\t{ \"destroy\",\tzfs_do_destroy,\t\tHELP_DESTROY\t\t},\n\t{ NULL },\n\t{ \"snapshot\",\tzfs_do_snapshot,\tHELP_SNAPSHOT\t\t},\n\t{ \"rollback\",\tzfs_do_rollback,\tHELP_ROLLBACK\t\t},\n\t{ \"clone\",\tzfs_do_clone,\t\tHELP_CLONE\t\t},\n\t{ \"promote\",\tzfs_do_promote,\t\tHELP_PROMOTE\t\t},\n\t{ \"rename\",\tzfs_do_rename,\t\tHELP_RENAME\t\t},\n\t{ \"bookmark\",\tzfs_do_bookmark,\tHELP_BOOKMARK\t\t},\n\t{ \"program\",    zfs_do_channel_program, HELP_CHANNEL_PROGRAM    },\n\t{ NULL },\n\t{ \"list\",\tzfs_do_list,\t\tHELP_LIST\t\t},\n\t{ NULL },\n\t{ \"set\",\tzfs_do_set,\t\tHELP_SET\t\t},\n\t{ \"get\",\tzfs_do_get,\t\tHELP_GET\t\t},\n\t{ \"inherit\",\tzfs_do_inherit,\t\tHELP_INHERIT\t\t},\n\t{ \"upgrade\",\tzfs_do_upgrade,\t\tHELP_UPGRADE\t\t},\n\t{ NULL },\n\t{ \"userspace\",\tzfs_do_userspace,\tHELP_USERSPACE\t\t},\n\t{ \"groupspace\",\tzfs_do_userspace,\tHELP_GROUPSPACE\t\t},\n\t{ \"projectspace\", zfs_do_userspace,\tHELP_PROJECTSPACE\t},\n\t{ NULL },\n\t{ \"project\",\tzfs_do_project,\t\tHELP_PROJECT\t\t},\n\t{ NULL },\n\t{ \"mount\",\tzfs_do_mount,\t\tHELP_MOUNT\t\t},\n\t{ \"unmount\",\tzfs_do_unmount,\t\tHELP_UNMOUNT\t\t},\n\t{ \"share\",\tzfs_do_share,\t\tHELP_SHARE\t\t},\n\t{ \"unshare\",\tzfs_do_unshare,\t\tHELP_UNSHARE\t\t},\n\t{ NULL },\n\t{ \"send\",\tzfs_do_send,\t\tHELP_SEND\t\t},\n\t{ \"receive\",\tzfs_do_receive,\t\tHELP_RECEIVE\t\t},\n\t{ NULL },\n\t{ \"allow\",\tzfs_do_allow,\t\tHELP_ALLOW\t\t},\n\t{ NULL },\n\t{ \"unallow\",\tzfs_do_unallow,\t\tHELP_UNALLOW\t\t},\n\t{ NULL },\n\t{ \"hold\",\tzfs_do_hold,\t\tHELP_HOLD\t\t},\n\t{ \"holds\",\tzfs_do_holds,\t\tHELP_HOLDS\t\t},\n\t{ \"release\",\tzfs_do_release,\t\tHELP_RELEASE\t\t},\n\t{ \"diff\",\tzfs_do_diff,\t\tHELP_DIFF\t\t},\n\t{ \"load-key\",\tzfs_do_load_key,\tHELP_LOAD_KEY\t\t},\n\t{ \"unload-key\",\tzfs_do_unload_key,\tHELP_UNLOAD_KEY\t\t},\n\t{ \"change-key\",\tzfs_do_change_key,\tHELP_CHANGE_KEY\t\t},\n\t{ \"redact\",\tzfs_do_redact,\t\tHELP_REDACT\t\t},\n\t{ \"wait\",\tzfs_do_wait,\t\tHELP_WAIT\t\t},\n\n#ifdef __FreeBSD__\n\t{ \"jail\",\tzfs_do_jail,\t\tHELP_JAIL\t\t},\n\t{ \"unjail\",\tzfs_do_unjail,\t\tHELP_UNJAIL\t\t},\n#endif\n\n#ifdef __linux__\n\t{ \"zone\",\tzfs_do_zone,\t\tHELP_ZONE\t\t},\n\t{ \"unzone\",\tzfs_do_unzone,\t\tHELP_UNZONE\t\t},\n#endif\n};\n\n#define\tNCOMMAND\t(sizeof (command_table) / sizeof (command_table[0]))\n\nzfs_command_t *current_command;\n\nstatic const char *\nget_usage(zfs_help_t idx)\n{\n\tswitch (idx) {\n\tcase HELP_CLONE:\n\t\treturn (gettext(\"\\tclone [-p] [-o property=value] ... \"\n\t\t    \"<snapshot> <filesystem|volume>\\n\"));\n\tcase HELP_CREATE:\n\t\treturn (gettext(\"\\tcreate [-Pnpuv] [-o property=value] ... \"\n\t\t    \"<filesystem>\\n\"\n\t\t    \"\\tcreate [-Pnpsv] [-b blocksize] [-o property=value] ... \"\n\t\t    \"-V <size> <volume>\\n\"));\n\tcase HELP_DESTROY:\n\t\treturn (gettext(\"\\tdestroy [-fnpRrv] <filesystem|volume>\\n\"\n\t\t    \"\\tdestroy [-dnpRrv] \"\n\t\t    \"<filesystem|volume>@<snap>[%<snap>][,...]\\n\"\n\t\t    \"\\tdestroy <filesystem|volume>#<bookmark>\\n\"));\n\tcase HELP_GET:\n\t\treturn (gettext(\"\\tget [-rHp] [-d max] \"\n\t\t    \"[-o \\\"all\\\" | field[,...]]\\n\"\n\t\t    \"\\t    [-t type[,...]] [-s source[,...]]\\n\"\n\t\t    \"\\t    <\\\"all\\\" | property[,...]> \"\n\t\t    \"[filesystem|volume|snapshot|bookmark] ...\\n\"));\n\tcase HELP_INHERIT:\n\t\treturn (gettext(\"\\tinherit [-rS] <property> \"\n\t\t    \"<filesystem|volume|snapshot> ...\\n\"));\n\tcase HELP_UPGRADE:\n\t\treturn (gettext(\"\\tupgrade [-v]\\n\"\n\t\t    \"\\tupgrade [-r] [-V version] <-a | filesystem ...>\\n\"));\n\tcase HELP_LIST:\n\t\treturn (gettext(\"\\tlist [-Hp] [-r|-d max] [-o property[,...]] \"\n\t\t    \"[-s property]...\\n\\t    [-S property]... [-t type[,...]] \"\n\t\t    \"[filesystem|volume|snapshot] ...\\n\"));\n\tcase HELP_MOUNT:\n\t\treturn (gettext(\"\\tmount\\n\"\n\t\t    \"\\tmount [-flvO] [-o opts] <-a | filesystem>\\n\"));\n\tcase HELP_PROMOTE:\n\t\treturn (gettext(\"\\tpromote <clone-filesystem>\\n\"));\n\tcase HELP_RECEIVE:\n\t\treturn (gettext(\"\\treceive [-vMnsFhu] \"\n\t\t    \"[-o <property>=<value>] ... [-x <property>] ...\\n\"\n\t\t    \"\\t    <filesystem|volume|snapshot>\\n\"\n\t\t    \"\\treceive [-vMnsFhu] [-o <property>=<value>] ... \"\n\t\t    \"[-x <property>] ... \\n\"\n\t\t    \"\\t    [-d | -e] <filesystem>\\n\"\n\t\t    \"\\treceive -A <filesystem|volume>\\n\"));\n\tcase HELP_RENAME:\n\t\treturn (gettext(\"\\trename [-f] <filesystem|volume|snapshot> \"\n\t\t    \"<filesystem|volume|snapshot>\\n\"\n\t\t    \"\\trename -p [-f] <filesystem|volume> <filesystem|volume>\\n\"\n\t\t    \"\\trename -u [-f] <filesystem> <filesystem>\\n\"\n\t\t    \"\\trename -r <snapshot> <snapshot>\\n\"));\n\tcase HELP_ROLLBACK:\n\t\treturn (gettext(\"\\trollback [-rRf] <snapshot>\\n\"));\n\tcase HELP_SEND:\n\t\treturn (gettext(\"\\tsend [-DLPbcehnpsVvw] \"\n\t\t    \"[-i|-I snapshot]\\n\"\n\t\t    \"\\t     [-R [-X dataset[,dataset]...]]     <snapshot>\\n\"\n\t\t    \"\\tsend [-DnVvPLecw] [-i snapshot|bookmark] \"\n\t\t    \"<filesystem|volume|snapshot>\\n\"\n\t\t    \"\\tsend [-DnPpVvLec] [-i bookmark|snapshot] \"\n\t\t    \"--redact <bookmark> <snapshot>\\n\"\n\t\t    \"\\tsend [-nVvPe] -t <receive_resume_token>\\n\"\n\t\t    \"\\tsend [-PnVv] --saved filesystem\\n\"));\n\tcase HELP_SET:\n\t\treturn (gettext(\"\\tset [-u] <property=value> ... \"\n\t\t    \"<filesystem|volume|snapshot> ...\\n\"));\n\tcase HELP_SHARE:\n\t\treturn (gettext(\"\\tshare [-l] <-a [nfs|smb] | filesystem>\\n\"));\n\tcase HELP_SNAPSHOT:\n\t\treturn (gettext(\"\\tsnapshot [-r] [-o property=value] ... \"\n\t\t    \"<filesystem|volume>@<snap> ...\\n\"));\n\tcase HELP_UNMOUNT:\n\t\treturn (gettext(\"\\tunmount [-fu] \"\n\t\t    \"<-a | filesystem|mountpoint>\\n\"));\n\tcase HELP_UNSHARE:\n\t\treturn (gettext(\"\\tunshare \"\n\t\t    \"<-a [nfs|smb] | filesystem|mountpoint>\\n\"));\n\tcase HELP_ALLOW:\n\t\treturn (gettext(\"\\tallow <filesystem|volume>\\n\"\n\t\t    \"\\tallow [-ldug] \"\n\t\t    \"<\\\"everyone\\\"|user|group>[,...] <perm|@setname>[,...]\\n\"\n\t\t    \"\\t    <filesystem|volume>\\n\"\n\t\t    \"\\tallow [-ld] -e <perm|@setname>[,...] \"\n\t\t    \"<filesystem|volume>\\n\"\n\t\t    \"\\tallow -c <perm|@setname>[,...] <filesystem|volume>\\n\"\n\t\t    \"\\tallow -s @setname <perm|@setname>[,...] \"\n\t\t    \"<filesystem|volume>\\n\"));\n\tcase HELP_UNALLOW:\n\t\treturn (gettext(\"\\tunallow [-rldug] \"\n\t\t    \"<\\\"everyone\\\"|user|group>[,...]\\n\"\n\t\t    \"\\t    [<perm|@setname>[,...]] <filesystem|volume>\\n\"\n\t\t    \"\\tunallow [-rld] -e [<perm|@setname>[,...]] \"\n\t\t    \"<filesystem|volume>\\n\"\n\t\t    \"\\tunallow [-r] -c [<perm|@setname>[,...]] \"\n\t\t    \"<filesystem|volume>\\n\"\n\t\t    \"\\tunallow [-r] -s @setname [<perm|@setname>[,...]] \"\n\t\t    \"<filesystem|volume>\\n\"));\n\tcase HELP_USERSPACE:\n\t\treturn (gettext(\"\\tuserspace [-Hinp] [-o field[,...]] \"\n\t\t    \"[-s field] ...\\n\"\n\t\t    \"\\t    [-S field] ... [-t type[,...]] \"\n\t\t    \"<filesystem|snapshot|path>\\n\"));\n\tcase HELP_GROUPSPACE:\n\t\treturn (gettext(\"\\tgroupspace [-Hinp] [-o field[,...]] \"\n\t\t    \"[-s field] ...\\n\"\n\t\t    \"\\t    [-S field] ... [-t type[,...]] \"\n\t\t    \"<filesystem|snapshot|path>\\n\"));\n\tcase HELP_PROJECTSPACE:\n\t\treturn (gettext(\"\\tprojectspace [-Hp] [-o field[,...]] \"\n\t\t    \"[-s field] ... \\n\"\n\t\t    \"\\t    [-S field] ... <filesystem|snapshot|path>\\n\"));\n\tcase HELP_PROJECT:\n\t\treturn (gettext(\"\\tproject [-d|-r] <directory|file ...>\\n\"\n\t\t    \"\\tproject -c [-0] [-d|-r] [-p id] <directory|file ...>\\n\"\n\t\t    \"\\tproject -C [-k] [-r] <directory ...>\\n\"\n\t\t    \"\\tproject [-p id] [-r] [-s] <directory ...>\\n\"));\n\tcase HELP_HOLD:\n\t\treturn (gettext(\"\\thold [-r] <tag> <snapshot> ...\\n\"));\n\tcase HELP_HOLDS:\n\t\treturn (gettext(\"\\tholds [-rHp] <snapshot> ...\\n\"));\n\tcase HELP_RELEASE:\n\t\treturn (gettext(\"\\trelease [-r] <tag> <snapshot> ...\\n\"));\n\tcase HELP_DIFF:\n\t\treturn (gettext(\"\\tdiff [-FHth] <snapshot> \"\n\t\t    \"[snapshot|filesystem]\\n\"));\n\tcase HELP_BOOKMARK:\n\t\treturn (gettext(\"\\tbookmark <snapshot|bookmark> \"\n\t\t    \"<newbookmark>\\n\"));\n\tcase HELP_CHANNEL_PROGRAM:\n\t\treturn (gettext(\"\\tprogram [-jn] [-t <instruction limit>] \"\n\t\t    \"[-m <memory limit (b)>]\\n\"\n\t\t    \"\\t    <pool> <program file> [lua args...]\\n\"));\n\tcase HELP_LOAD_KEY:\n\t\treturn (gettext(\"\\tload-key [-rn] [-L <keylocation>] \"\n\t\t    \"<-a | filesystem|volume>\\n\"));\n\tcase HELP_UNLOAD_KEY:\n\t\treturn (gettext(\"\\tunload-key [-r] \"\n\t\t    \"<-a | filesystem|volume>\\n\"));\n\tcase HELP_CHANGE_KEY:\n\t\treturn (gettext(\"\\tchange-key [-l] [-o keyformat=<value>]\\n\"\n\t\t    \"\\t    [-o keylocation=<value>] [-o pbkdf2iters=<value>]\\n\"\n\t\t    \"\\t    <filesystem|volume>\\n\"\n\t\t    \"\\tchange-key -i [-l] <filesystem|volume>\\n\"));\n\tcase HELP_VERSION:\n\t\treturn (gettext(\"\\tversion\\n\"));\n\tcase HELP_REDACT:\n\t\treturn (gettext(\"\\tredact <snapshot> <bookmark> \"\n\t\t    \"<redaction_snapshot> ...\\n\"));\n\tcase HELP_JAIL:\n\t\treturn (gettext(\"\\tjail <jailid|jailname> <filesystem>\\n\"));\n\tcase HELP_UNJAIL:\n\t\treturn (gettext(\"\\tunjail <jailid|jailname> <filesystem>\\n\"));\n\tcase HELP_WAIT:\n\t\treturn (gettext(\"\\twait [-t <activity>] <filesystem>\\n\"));\n\tcase HELP_ZONE:\n\t\treturn (gettext(\"\\tzone <nsfile> <filesystem>\\n\"));\n\tcase HELP_UNZONE:\n\t\treturn (gettext(\"\\tunzone <nsfile> <filesystem>\\n\"));\n\tdefault:\n\t\t__builtin_unreachable();\n\t}\n}\n\nvoid\nnomem(void)\n{\n\t(void) fprintf(stderr, gettext(\"internal error: out of memory\\n\"));\n\texit(1);\n}\n\n \n\nvoid *\nsafe_malloc(size_t size)\n{\n\tvoid *data;\n\n\tif ((data = calloc(1, size)) == NULL)\n\t\tnomem();\n\n\treturn (data);\n}\n\nstatic void *\nsafe_realloc(void *data, size_t size)\n{\n\tvoid *newp;\n\tif ((newp = realloc(data, size)) == NULL) {\n\t\tfree(data);\n\t\tnomem();\n\t}\n\n\treturn (newp);\n}\n\nstatic char *\nsafe_strdup(const char *str)\n{\n\tchar *dupstr = strdup(str);\n\n\tif (dupstr == NULL)\n\t\tnomem();\n\n\treturn (dupstr);\n}\n\n \nstatic int\nusage_prop_cb(int prop, void *cb)\n{\n\tFILE *fp = cb;\n\n\t(void) fprintf(fp, \"\\t%-15s \", zfs_prop_to_name(prop));\n\n\tif (zfs_prop_readonly(prop))\n\t\t(void) fprintf(fp, \" NO    \");\n\telse\n\t\t(void) fprintf(fp, \"YES    \");\n\n\tif (zfs_prop_inheritable(prop))\n\t\t(void) fprintf(fp, \"  YES   \");\n\telse\n\t\t(void) fprintf(fp, \"   NO   \");\n\n\t(void) fprintf(fp, \"%s\\n\", zfs_prop_values(prop) ?: \"-\");\n\n\treturn (ZPROP_CONT);\n}\n\n \nstatic __attribute__((noreturn)) void\nusage(boolean_t requested)\n{\n\tint i;\n\tboolean_t show_properties = B_FALSE;\n\tFILE *fp = requested ? stdout : stderr;\n\n\tif (current_command == NULL) {\n\n\t\t(void) fprintf(fp, gettext(\"usage: zfs command args ...\\n\"));\n\t\t(void) fprintf(fp,\n\t\t    gettext(\"where 'command' is one of the following:\\n\\n\"));\n\n\t\tfor (i = 0; i < NCOMMAND; i++) {\n\t\t\tif (command_table[i].name == NULL)\n\t\t\t\t(void) fprintf(fp, \"\\n\");\n\t\t\telse\n\t\t\t\t(void) fprintf(fp, \"%s\",\n\t\t\t\t    get_usage(command_table[i].usage));\n\t\t}\n\n\t\t(void) fprintf(fp, gettext(\"\\nEach dataset is of the form: \"\n\t\t    \"pool/[dataset/]*dataset[@name]\\n\"));\n\t} else {\n\t\t(void) fprintf(fp, gettext(\"usage:\\n\"));\n\t\t(void) fprintf(fp, \"%s\", get_usage(current_command->usage));\n\t}\n\n\tif (current_command != NULL &&\n\t    (strcmp(current_command->name, \"set\") == 0 ||\n\t    strcmp(current_command->name, \"get\") == 0 ||\n\t    strcmp(current_command->name, \"inherit\") == 0 ||\n\t    strcmp(current_command->name, \"list\") == 0))\n\t\tshow_properties = B_TRUE;\n\n\tif (show_properties) {\n\t\t(void) fprintf(fp, \"%s\",\n\t\t    gettext(\"\\nThe following properties are supported:\\n\"));\n\n\t\t(void) fprintf(fp, \"\\n\\t%-14s %s  %s   %s\\n\\n\",\n\t\t    \"PROPERTY\", \"EDIT\", \"INHERIT\", \"VALUES\");\n\n\t\t \n\t\t(void) zprop_iter(usage_prop_cb, fp, B_FALSE, B_TRUE,\n\t\t    ZFS_TYPE_DATASET);\n\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"userused@...\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"groupused@...\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"projectused@...\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"userobjused@...\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"groupobjused@...\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"projectobjused@...\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"userquota@...\");\n\t\t(void) fprintf(fp, \"YES       NO   <size> | none\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"groupquota@...\");\n\t\t(void) fprintf(fp, \"YES       NO   <size> | none\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"projectquota@...\");\n\t\t(void) fprintf(fp, \"YES       NO   <size> | none\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"userobjquota@...\");\n\t\t(void) fprintf(fp, \"YES       NO   <size> | none\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"groupobjquota@...\");\n\t\t(void) fprintf(fp, \"YES       NO   <size> | none\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"projectobjquota@...\");\n\t\t(void) fprintf(fp, \"YES       NO   <size> | none\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"written@<snap>\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\t\t(void) fprintf(fp, \"\\t%-15s \", \"written#<bookmark>\");\n\t\t(void) fprintf(fp, \" NO       NO   <size>\\n\");\n\n\t\t(void) fprintf(fp, gettext(\"\\nSizes are specified in bytes \"\n\t\t    \"with standard units such as K, M, G, etc.\\n\"));\n\t\t(void) fprintf(fp, \"%s\", gettext(\"\\nUser-defined properties \"\n\t\t    \"can be specified by using a name containing a colon \"\n\t\t    \"(:).\\n\"));\n\t\t(void) fprintf(fp, gettext(\"\\nThe {user|group|project}\"\n\t\t    \"[obj]{used|quota}@ properties must be appended with\\n\"\n\t\t    \"a user|group|project specifier of one of these forms:\\n\"\n\t\t    \"    POSIX name      (eg: \\\"matt\\\")\\n\"\n\t\t    \"    POSIX id        (eg: \\\"126829\\\")\\n\"\n\t\t    \"    SMB name@domain (eg: \\\"matt@sun\\\")\\n\"\n\t\t    \"    SMB SID         (eg: \\\"S-1-234-567-89\\\")\\n\"));\n\t} else {\n\t\t(void) fprintf(fp,\n\t\t    gettext(\"\\nFor the property list, run: %s\\n\"),\n\t\t    \"zfs set|get\");\n\t\t(void) fprintf(fp,\n\t\t    gettext(\"\\nFor the delegated permission list, run: %s\\n\"),\n\t\t    \"zfs allow|unallow\");\n\t\t(void) fprintf(fp,\n\t\t    gettext(\"\\nFor further help on a command or topic, \"\n\t\t    \"run: %s\\n\"), \"zfs help [<topic>]\");\n\t}\n\n\t \n\tif (getenv(\"ZFS_ABORT\") != NULL) {\n\t\t(void) printf(\"dumping core by request\\n\");\n\t\tabort();\n\t}\n\n\texit(requested ? 0 : 2);\n}\n\n \nstatic boolean_t\nparseprop(nvlist_t *props, char *propname)\n{\n\tchar *propval;\n\n\tif ((propval = strchr(propname, '=')) == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"missing \"\n\t\t    \"'=' for property=value argument\\n\"));\n\t\treturn (B_FALSE);\n\t}\n\t*propval = '\\0';\n\tpropval++;\n\tif (nvlist_exists(props, propname)) {\n\t\t(void) fprintf(stderr, gettext(\"property '%s' \"\n\t\t    \"specified multiple times\\n\"), propname);\n\t\treturn (B_FALSE);\n\t}\n\tif (nvlist_add_string(props, propname, propval) != 0)\n\t\tnomem();\n\treturn (B_TRUE);\n}\n\n \nstatic boolean_t\nparsepropname(nvlist_t *props, char *propname)\n{\n\tif (strchr(propname, '=') != NULL) {\n\t\t(void) fprintf(stderr, gettext(\"invalid character \"\n\t\t    \"'=' in property argument\\n\"));\n\t\treturn (B_FALSE);\n\t}\n\tif (nvlist_exists(props, propname)) {\n\t\t(void) fprintf(stderr, gettext(\"property '%s' \"\n\t\t    \"specified multiple times\\n\"), propname);\n\t\treturn (B_FALSE);\n\t}\n\tif (nvlist_add_boolean(props, propname) != 0)\n\t\tnomem();\n\treturn (B_TRUE);\n}\n\nstatic int\nparse_depth(char *opt, int *flags)\n{\n\tchar *tmp;\n\tint depth;\n\n\tdepth = (int)strtol(opt, &tmp, 0);\n\tif (*tmp) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"%s is not an integer\\n\"), optarg);\n\t\tusage(B_FALSE);\n\t}\n\tif (depth < 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Depth can not be negative.\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\t*flags |= (ZFS_ITER_DEPTH_LIMIT|ZFS_ITER_RECURSE);\n\treturn (depth);\n}\n\n#define\tPROGRESS_DELAY 2\t\t \n\nstatic const char *pt_reverse =\n\t\"\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\";\nstatic time_t pt_begin;\nstatic char *pt_header = NULL;\nstatic boolean_t pt_shown;\n\nstatic void\nstart_progress_timer(void)\n{\n\tpt_begin = time(NULL) + PROGRESS_DELAY;\n\tpt_shown = B_FALSE;\n}\n\nstatic void\nset_progress_header(const char *header)\n{\n\tassert(pt_header == NULL);\n\tpt_header = safe_strdup(header);\n\tif (pt_shown) {\n\t\t(void) printf(\"%s: \", header);\n\t\t(void) fflush(stdout);\n\t}\n}\n\nstatic void\nupdate_progress(const char *update)\n{\n\tif (!pt_shown && time(NULL) > pt_begin) {\n\t\tint len = strlen(update);\n\n\t\t(void) printf(\"%s: %s%*.*s\", pt_header, update, len, len,\n\t\t    pt_reverse);\n\t\t(void) fflush(stdout);\n\t\tpt_shown = B_TRUE;\n\t} else if (pt_shown) {\n\t\tint len = strlen(update);\n\n\t\t(void) printf(\"%s%*.*s\", update, len, len, pt_reverse);\n\t\t(void) fflush(stdout);\n\t}\n}\n\nstatic void\nfinish_progress(const char *done)\n{\n\tif (pt_shown) {\n\t\t(void) puts(done);\n\t\t(void) fflush(stdout);\n\t}\n\tfree(pt_header);\n\tpt_header = NULL;\n}\n\nstatic int\nzfs_mount_and_share(libzfs_handle_t *hdl, const char *dataset, zfs_type_t type)\n{\n\tzfs_handle_t *zhp = NULL;\n\tint ret = 0;\n\n\tzhp = zfs_open(hdl, dataset, type);\n\tif (zhp == NULL)\n\t\treturn (1);\n\n\t \n\tif (zfs_get_type(zhp) == ZFS_TYPE_VOLUME) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\t \n\tif (zfs_prop_valid_for_type(ZFS_PROP_CANMOUNT, type, B_FALSE) &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) == ZFS_CANMOUNT_ON) {\n\t\tif (zfs_mount_delegation_check()) {\n\t\t\t(void) fprintf(stderr, gettext(\"filesystem \"\n\t\t\t    \"successfully created, but it may only be \"\n\t\t\t    \"mounted by root\\n\"));\n\t\t\tret = 1;\n\t\t} else if (zfs_mount(zhp, NULL, 0) != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"filesystem \"\n\t\t\t    \"successfully created, but not mounted\\n\"));\n\t\t\tret = 1;\n\t\t} else if (zfs_share(zhp, NULL) != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"filesystem \"\n\t\t\t    \"successfully created, but not shared\\n\"));\n\t\t\tret = 1;\n\t\t}\n\t\tzfs_commit_shares(NULL);\n\t}\n\n\tzfs_close(zhp);\n\n\treturn (ret);\n}\n\n \nstatic int\nzfs_do_clone(int argc, char **argv)\n{\n\tzfs_handle_t *zhp = NULL;\n\tboolean_t parents = B_FALSE;\n\tnvlist_t *props;\n\tint ret = 0;\n\tint c;\n\n\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\n\t \n\twhile ((c = getopt(argc, argv, \"o:p\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'o':\n\t\t\tif (!parseprop(props, optarg)) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparents = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tgoto usage;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing source dataset \"\n\t\t    \"argument\\n\"));\n\t\tgoto usage;\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing target dataset \"\n\t\t    \"argument\\n\"));\n\t\tgoto usage;\n\t}\n\tif (argc > 2) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tgoto usage;\n\t}\n\n\t \n\tif ((zhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_SNAPSHOT)) == NULL) {\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\n\tif (parents && zfs_name_valid(argv[1], ZFS_TYPE_FILESYSTEM |\n\t    ZFS_TYPE_VOLUME)) {\n\t\t \n\t\tif (zfs_dataset_exists(g_zfs, argv[1], ZFS_TYPE_FILESYSTEM |\n\t\t    ZFS_TYPE_VOLUME)) {\n\t\t\tzfs_close(zhp);\n\t\t\tnvlist_free(props);\n\t\t\treturn (0);\n\t\t}\n\t\tif (zfs_create_ancestors(g_zfs, argv[1]) != 0) {\n\t\t\tzfs_close(zhp);\n\t\t\tnvlist_free(props);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\t \n\tret = zfs_clone(zhp, argv[1], props);\n\n\t \n\tif (ret == 0) {\n\t\tif (log_history) {\n\t\t\t(void) zpool_log_history(g_zfs, history_str);\n\t\t\tlog_history = B_FALSE;\n\t\t}\n\n\t\tret = zfs_mount_and_share(g_zfs, argv[1], ZFS_TYPE_DATASET);\n\t}\n\n\tzfs_close(zhp);\n\tnvlist_free(props);\n\n\treturn (!!ret);\n\nusage:\n\tASSERT3P(zhp, ==, NULL);\n\tnvlist_free(props);\n\tusage(B_FALSE);\n\treturn (-1);\n}\n\n \nstatic uint64_t\ndefault_volblocksize(zpool_handle_t *zhp, nvlist_t *props)\n{\n\tuint64_t volblocksize, asize = SPA_MINBLOCKSIZE;\n\tnvlist_t *tree, **vdevs;\n\tuint_t nvdevs;\n\n\tnvlist_t *config = zpool_get_config(zhp, NULL);\n\n\tif (nvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE, &tree) != 0 ||\n\t    nvlist_lookup_nvlist_array(tree, ZPOOL_CONFIG_CHILDREN,\n\t    &vdevs, &nvdevs) != 0) {\n\t\treturn (ZVOL_DEFAULT_BLOCKSIZE);\n\t}\n\n\tfor (int i = 0; i < nvdevs; i++) {\n\t\tnvlist_t *nv = vdevs[i];\n\t\tuint64_t ashift, ndata, nparity;\n\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_ASHIFT, &ashift) != 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_DRAID_NDATA,\n\t\t    &ndata) == 0) {\n\t\t\t \n\t\t\tasize = MAX(asize, ndata * (1ULL << ashift));\n\t\t} else if (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NPARITY,\n\t\t    &nparity) == 0) {\n\t\t\t \n\t\t\tif (nparity == 1)\n\t\t\t\tasize = MAX(asize, 2 * (1ULL << ashift));\n\t\t\telse\n\t\t\t\tasize = MAX(asize, 4 * (1ULL << ashift));\n\t\t} else {\n\t\t\t \n\t\t\tasize = MAX(asize, 1ULL << ashift);\n\t\t}\n\t}\n\n\t \n\tuint64_t tgt_volblocksize = ZVOL_DEFAULT_BLOCKSIZE;\n\twhile (tgt_volblocksize * 2 <= asize)\n\t\ttgt_volblocksize *= 2;\n\n\tconst char *prop = zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE);\n\tif (nvlist_lookup_uint64(props, prop, &volblocksize) == 0) {\n\n\t\t \n\t\tif (volblocksize < ZVOL_DEFAULT_BLOCKSIZE) {\n\t\t\t(void) fprintf(stderr, gettext(\"Warning: \"\n\t\t\t    \"volblocksize (%llu) is less than the default \"\n\t\t\t    \"minimum block size (%llu).\\nTo reduce wasted \"\n\t\t\t    \"space a volblocksize of %llu is recommended.\\n\"),\n\t\t\t    (u_longlong_t)volblocksize,\n\t\t\t    (u_longlong_t)ZVOL_DEFAULT_BLOCKSIZE,\n\t\t\t    (u_longlong_t)tgt_volblocksize);\n\t\t} else if (volblocksize < tgt_volblocksize) {\n\t\t\t(void) fprintf(stderr, gettext(\"Warning: \"\n\t\t\t    \"volblocksize (%llu) is much less than the \"\n\t\t\t    \"minimum allocation\\nunit (%llu), which wastes \"\n\t\t\t    \"at least %llu%% of space. To reduce wasted \"\n\t\t\t    \"space,\\nuse a larger volblocksize (%llu is \"\n\t\t\t    \"recommended), fewer dRAID data disks\\n\"\n\t\t\t    \"per group, or smaller sector size (ashift).\\n\"),\n\t\t\t    (u_longlong_t)volblocksize, (u_longlong_t)asize,\n\t\t\t    (u_longlong_t)((100 * (asize - volblocksize)) /\n\t\t\t    asize), (u_longlong_t)tgt_volblocksize);\n\t\t}\n\t} else {\n\t\tvolblocksize = tgt_volblocksize;\n\t\tfnvlist_add_uint64(props, prop, volblocksize);\n\t}\n\n\treturn (volblocksize);\n}\n\n \nstatic int\nzfs_do_create(int argc, char **argv)\n{\n\tzfs_type_t type = ZFS_TYPE_FILESYSTEM;\n\tzpool_handle_t *zpool_handle = NULL;\n\tnvlist_t *real_props = NULL;\n\tuint64_t volsize = 0;\n\tint c;\n\tboolean_t noreserve = B_FALSE;\n\tboolean_t bflag = B_FALSE;\n\tboolean_t parents = B_FALSE;\n\tboolean_t dryrun = B_FALSE;\n\tboolean_t nomount = B_FALSE;\n\tboolean_t verbose = B_FALSE;\n\tboolean_t parseable = B_FALSE;\n\tint ret = 1;\n\tnvlist_t *props;\n\tuint64_t intval;\n\tconst char *strval;\n\n\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\n\t \n\twhile ((c = getopt(argc, argv, \":PV:b:nso:puv\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'V':\n\t\t\ttype = ZFS_TYPE_VOLUME;\n\t\t\tif (zfs_nicestrtonum(g_zfs, optarg, &intval) != 0) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"bad volume \"\n\t\t\t\t    \"size '%s': %s\\n\"), optarg,\n\t\t\t\t    libzfs_error_description(g_zfs));\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (nvlist_add_uint64(props,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE), intval) != 0)\n\t\t\t\tnomem();\n\t\t\tvolsize = intval;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tverbose = B_TRUE;\n\t\t\tparseable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparents = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbflag = B_TRUE;\n\t\t\tif (zfs_nicestrtonum(g_zfs, optarg, &intval) != 0) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"bad volume \"\n\t\t\t\t    \"block size '%s': %s\\n\"), optarg,\n\t\t\t\t    libzfs_error_description(g_zfs));\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (nvlist_add_uint64(props,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),\n\t\t\t    intval) != 0)\n\t\t\t\tnomem();\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tdryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (!parseprop(props, optarg))\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tnoreserve = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnomount = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing size \"\n\t\t\t    \"argument\\n\"));\n\t\t\tgoto badusage;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tgoto badusage;\n\t\t}\n\t}\n\n\tif ((bflag || noreserve) && type != ZFS_TYPE_VOLUME) {\n\t\t(void) fprintf(stderr, gettext(\"'-s' and '-b' can only be \"\n\t\t    \"used when creating a volume\\n\"));\n\t\tgoto badusage;\n\t}\n\tif (nomount && type != ZFS_TYPE_FILESYSTEM) {\n\t\t(void) fprintf(stderr, gettext(\"'-u' can only be \"\n\t\t    \"used when creating a filesystem\\n\"));\n\t\tgoto badusage;\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc == 0) {\n\t\t(void) fprintf(stderr, gettext(\"missing %s argument\\n\"),\n\t\t    zfs_type_to_name(type));\n\t\tgoto badusage;\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tgoto badusage;\n\t}\n\n\tif (dryrun || type == ZFS_TYPE_VOLUME) {\n\t\tchar msg[ZFS_MAX_DATASET_NAME_LEN * 2];\n\t\tchar *p;\n\n\t\tif ((p = strchr(argv[0], '/')) != NULL)\n\t\t\t*p = '\\0';\n\t\tzpool_handle = zpool_open(g_zfs, argv[0]);\n\t\tif (p != NULL)\n\t\t\t*p = '/';\n\t\tif (zpool_handle == NULL)\n\t\t\tgoto error;\n\n\t\t(void) snprintf(msg, sizeof (msg),\n\t\t    dryrun ? gettext(\"cannot verify '%s'\") :\n\t\t    gettext(\"cannot create '%s'\"), argv[0]);\n\t\tif (props && (real_props = zfs_valid_proplist(g_zfs, type,\n\t\t    props, 0, NULL, zpool_handle, B_TRUE, msg)) == NULL) {\n\t\t\tzpool_close(zpool_handle);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (type == ZFS_TYPE_VOLUME) {\n\t\tconst char *prop = zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE);\n\t\tuint64_t volblocksize = default_volblocksize(zpool_handle,\n\t\t    real_props);\n\n\t\tif (volblocksize != ZVOL_DEFAULT_BLOCKSIZE &&\n\t\t    nvlist_lookup_string(props, prop, &strval) != 0) {\n\t\t\tchar *tmp;\n\t\t\tif (asprintf(&tmp, \"%llu\",\n\t\t\t    (u_longlong_t)volblocksize) == -1)\n\t\t\t\tnomem();\n\t\t\tnvlist_add_string(props, prop, tmp);\n\t\t\tfree(tmp);\n\t\t}\n\n\t\t \n\t\tif (volsize % volblocksize) {\n\t\t\tvolsize = P2ROUNDUP_TYPED(volsize, volblocksize,\n\t\t\t    uint64_t);\n\n\t\t\tif (nvlist_add_uint64(props,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE), volsize) != 0) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tnomem();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type == ZFS_TYPE_VOLUME && !noreserve) {\n\t\tuint64_t spa_version;\n\t\tzfs_prop_t resv_prop;\n\n\t\tspa_version = zpool_get_prop_int(zpool_handle,\n\t\t    ZPOOL_PROP_VERSION, NULL);\n\t\tif (spa_version >= SPA_VERSION_REFRESERVATION)\n\t\t\tresv_prop = ZFS_PROP_REFRESERVATION;\n\t\telse\n\t\t\tresv_prop = ZFS_PROP_RESERVATION;\n\n\t\tvolsize = zvol_volsize_to_reservation(zpool_handle, volsize,\n\t\t    real_props);\n\n\t\tif (nvlist_lookup_string(props, zfs_prop_to_name(resv_prop),\n\t\t    &strval) != 0) {\n\t\t\tif (nvlist_add_uint64(props,\n\t\t\t    zfs_prop_to_name(resv_prop), volsize) != 0) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tnomem();\n\t\t\t}\n\t\t}\n\t}\n\tif (zpool_handle != NULL) {\n\t\tzpool_close(zpool_handle);\n\t\tnvlist_free(real_props);\n\t}\n\n\tif (parents && zfs_name_valid(argv[0], type)) {\n\t\t \n\t\tif (zfs_dataset_exists(g_zfs, argv[0], type)) {\n\t\t\tret = 0;\n\t\t\tgoto error;\n\t\t}\n\t\tif (verbose) {\n\t\t\t(void) printf(parseable ? \"create_ancestors\\t%s\\n\" :\n\t\t\t    dryrun ?  \"would create ancestors of %s\\n\" :\n\t\t\t    \"create ancestors of %s\\n\", argv[0]);\n\t\t}\n\t\tif (!dryrun) {\n\t\t\tif (zfs_create_ancestors(g_zfs, argv[0]) != 0) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (verbose) {\n\t\tnvpair_t *nvp = NULL;\n\t\t(void) printf(parseable ? \"create\\t%s\\n\" :\n\t\t    dryrun ? \"would create %s\\n\" : \"create %s\\n\", argv[0]);\n\t\twhile ((nvp = nvlist_next_nvpair(props, nvp)) != NULL) {\n\t\t\tuint64_t uval;\n\t\t\tconst char *sval;\n\n\t\t\tswitch (nvpair_type(nvp)) {\n\t\t\tcase DATA_TYPE_UINT64:\n\t\t\t\tVERIFY0(nvpair_value_uint64(nvp, &uval));\n\t\t\t\t(void) printf(parseable ?\n\t\t\t\t    \"property\\t%s\\t%llu\\n\" : \"\\t%s=%llu\\n\",\n\t\t\t\t    nvpair_name(nvp), (u_longlong_t)uval);\n\t\t\t\tbreak;\n\t\t\tcase DATA_TYPE_STRING:\n\t\t\t\tVERIFY0(nvpair_value_string(nvp, &sval));\n\t\t\t\t(void) printf(parseable ?\n\t\t\t\t    \"property\\t%s\\t%s\\n\" : \"\\t%s=%s\\n\",\n\t\t\t\t    nvpair_name(nvp), sval);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(void) fprintf(stderr, \"property '%s' \"\n\t\t\t\t    \"has illegal type %d\\n\",\n\t\t\t\t    nvpair_name(nvp), nvpair_type(nvp));\n\t\t\t\tabort();\n\t\t\t}\n\t\t}\n\t}\n\tif (dryrun) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\t \n\tif (zfs_create(g_zfs, argv[0], type, props) != 0)\n\t\tgoto error;\n\n\tif (log_history) {\n\t\t(void) zpool_log_history(g_zfs, history_str);\n\t\tlog_history = B_FALSE;\n\t}\n\n\tif (nomount) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tret = zfs_mount_and_share(g_zfs, argv[0], ZFS_TYPE_DATASET);\nerror:\n\tnvlist_free(props);\n\treturn (ret);\nbadusage:\n\tnvlist_free(props);\n\tusage(B_FALSE);\n\treturn (2);\n}\n\n \ntypedef struct destroy_cbdata {\n\tboolean_t\tcb_first;\n\tboolean_t\tcb_force;\n\tboolean_t\tcb_recurse;\n\tboolean_t\tcb_error;\n\tboolean_t\tcb_doclones;\n\tzfs_handle_t\t*cb_target;\n\tboolean_t\tcb_defer_destroy;\n\tboolean_t\tcb_verbose;\n\tboolean_t\tcb_parsable;\n\tboolean_t\tcb_dryrun;\n\tnvlist_t\t*cb_nvl;\n\tnvlist_t\t*cb_batchedsnaps;\n\n\t \n\tchar\t\t*cb_firstsnap;\n\t \n\tchar\t\t*cb_prevsnap;\n\tint64_t\t\tcb_snapused;\n\tchar\t\t*cb_snapspec;\n\tchar\t\t*cb_bookmark;\n\tuint64_t\tcb_snap_count;\n} destroy_cbdata_t;\n\n \nstatic int\ndestroy_check_dependent(zfs_handle_t *zhp, void *data)\n{\n\tdestroy_cbdata_t *cbp = data;\n\tconst char *tname = zfs_get_name(cbp->cb_target);\n\tconst char *name = zfs_get_name(zhp);\n\n\tif (strncmp(tname, name, strlen(tname)) == 0 &&\n\t    (name[strlen(tname)] == '/' || name[strlen(tname)] == '@')) {\n\t\t \n\t\tif (cbp->cb_recurse)\n\t\t\tgoto out;\n\n\t\tif (cbp->cb_first) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot destroy '%s': \"\n\t\t\t    \"%s has children\\n\"),\n\t\t\t    zfs_get_name(cbp->cb_target),\n\t\t\t    zfs_type_to_name(zfs_get_type(cbp->cb_target)));\n\t\t\t(void) fprintf(stderr, gettext(\"use '-r' to destroy \"\n\t\t\t    \"the following datasets:\\n\"));\n\t\t\tcbp->cb_first = B_FALSE;\n\t\t\tcbp->cb_error = B_TRUE;\n\t\t}\n\n\t\t(void) fprintf(stderr, \"%s\\n\", zfs_get_name(zhp));\n\t} else {\n\t\t \n\t\tif (!cbp->cb_recurse &&\n\t\t    zfs_get_type(cbp->cb_target) != ZFS_TYPE_SNAPSHOT)\n\t\t\tgoto out;\n\n\t\tif (cbp->cb_first) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot destroy '%s': \"\n\t\t\t    \"%s has dependent clones\\n\"),\n\t\t\t    zfs_get_name(cbp->cb_target),\n\t\t\t    zfs_type_to_name(zfs_get_type(cbp->cb_target)));\n\t\t\t(void) fprintf(stderr, gettext(\"use '-R' to destroy \"\n\t\t\t    \"the following datasets:\\n\"));\n\t\t\tcbp->cb_first = B_FALSE;\n\t\t\tcbp->cb_error = B_TRUE;\n\t\t\tcbp->cb_dryrun = B_TRUE;\n\t\t}\n\n\t\t(void) fprintf(stderr, \"%s\\n\", zfs_get_name(zhp));\n\t}\n\nout:\n\tzfs_close(zhp);\n\treturn (0);\n}\n\nstatic int\ndestroy_batched(destroy_cbdata_t *cb)\n{\n\tint error = zfs_destroy_snaps_nvl(g_zfs,\n\t    cb->cb_batchedsnaps, B_FALSE);\n\tfnvlist_free(cb->cb_batchedsnaps);\n\tcb->cb_batchedsnaps = fnvlist_alloc();\n\treturn (error);\n}\n\nstatic int\ndestroy_callback(zfs_handle_t *zhp, void *data)\n{\n\tdestroy_cbdata_t *cb = data;\n\tconst char *name = zfs_get_name(zhp);\n\tint error;\n\n\tif (cb->cb_verbose) {\n\t\tif (cb->cb_parsable) {\n\t\t\t(void) printf(\"destroy\\t%s\\n\", name);\n\t\t} else if (cb->cb_dryrun) {\n\t\t\t(void) printf(gettext(\"would destroy %s\\n\"),\n\t\t\t    name);\n\t\t} else {\n\t\t\t(void) printf(gettext(\"will destroy %s\\n\"),\n\t\t\t    name);\n\t\t}\n\t}\n\n\t \n\tif (strchr(zfs_get_name(zhp), '/') == NULL &&\n\t    zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\tif (cb->cb_dryrun) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\t \n\tif (zfs_get_type(zhp) == ZFS_TYPE_SNAPSHOT) {\n\t\tcb->cb_snap_count++;\n\t\tfnvlist_add_boolean(cb->cb_batchedsnaps, name);\n\t\tif (cb->cb_snap_count % 10 == 0 && cb->cb_defer_destroy) {\n\t\t\terror = destroy_batched(cb);\n\t\t\tif (error != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\terror = destroy_batched(cb);\n\t\tif (error != 0 ||\n\t\t    zfs_unmount(zhp, NULL, cb->cb_force ? MS_FORCE : 0) != 0 ||\n\t\t    zfs_destroy(zhp, cb->cb_defer_destroy) != 0) {\n\t\t\tzfs_close(zhp);\n\t\t\t \n\t\t\tif (cb->cb_recurse) {\n\t\t\t\tcb->cb_error = B_TRUE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tzfs_close(zhp);\n\treturn (0);\n}\n\nstatic int\ndestroy_print_cb(zfs_handle_t *zhp, void *arg)\n{\n\tdestroy_cbdata_t *cb = arg;\n\tconst char *name = zfs_get_name(zhp);\n\tint err = 0;\n\n\tif (nvlist_exists(cb->cb_nvl, name)) {\n\t\tif (cb->cb_firstsnap == NULL)\n\t\t\tcb->cb_firstsnap = strdup(name);\n\t\tif (cb->cb_prevsnap != NULL)\n\t\t\tfree(cb->cb_prevsnap);\n\t\t \n\t\tcb->cb_prevsnap = strdup(name);\n\t\tif (cb->cb_firstsnap == NULL || cb->cb_prevsnap == NULL)\n\t\t\tnomem();\n\t\tif (cb->cb_verbose) {\n\t\t\tif (cb->cb_parsable) {\n\t\t\t\t(void) printf(\"destroy\\t%s\\n\", name);\n\t\t\t} else if (cb->cb_dryrun) {\n\t\t\t\t(void) printf(gettext(\"would destroy %s\\n\"),\n\t\t\t\t    name);\n\t\t\t} else {\n\t\t\t\t(void) printf(gettext(\"will destroy %s\\n\"),\n\t\t\t\t    name);\n\t\t\t}\n\t\t}\n\t} else if (cb->cb_firstsnap != NULL) {\n\t\t \n\t\tuint64_t used = 0;\n\t\terr = lzc_snaprange_space(cb->cb_firstsnap,\n\t\t    cb->cb_prevsnap, &used);\n\t\tcb->cb_snapused += used;\n\t\tfree(cb->cb_firstsnap);\n\t\tcb->cb_firstsnap = NULL;\n\t\tfree(cb->cb_prevsnap);\n\t\tcb->cb_prevsnap = NULL;\n\t}\n\tzfs_close(zhp);\n\treturn (err);\n}\n\nstatic int\ndestroy_print_snapshots(zfs_handle_t *fs_zhp, destroy_cbdata_t *cb)\n{\n\tint err;\n\tassert(cb->cb_firstsnap == NULL);\n\tassert(cb->cb_prevsnap == NULL);\n\terr = zfs_iter_snapshots_sorted_v2(fs_zhp, 0, destroy_print_cb, cb, 0,\n\t    0);\n\tif (cb->cb_firstsnap != NULL) {\n\t\tuint64_t used = 0;\n\t\tif (err == 0) {\n\t\t\terr = lzc_snaprange_space(cb->cb_firstsnap,\n\t\t\t    cb->cb_prevsnap, &used);\n\t\t}\n\t\tcb->cb_snapused += used;\n\t\tfree(cb->cb_firstsnap);\n\t\tcb->cb_firstsnap = NULL;\n\t\tfree(cb->cb_prevsnap);\n\t\tcb->cb_prevsnap = NULL;\n\t}\n\treturn (err);\n}\n\nstatic int\nsnapshot_to_nvl_cb(zfs_handle_t *zhp, void *arg)\n{\n\tdestroy_cbdata_t *cb = arg;\n\tint err = 0;\n\n\t \n\tif (!cb->cb_doclones && !cb->cb_defer_destroy) {\n\t\tcb->cb_target = zhp;\n\t\tcb->cb_first = B_TRUE;\n\t\terr = zfs_iter_dependents_v2(zhp, 0, B_TRUE,\n\t\t    destroy_check_dependent, cb);\n\t}\n\n\tif (err == 0) {\n\t\tif (nvlist_add_boolean(cb->cb_nvl, zfs_get_name(zhp)))\n\t\t\tnomem();\n\t}\n\tzfs_close(zhp);\n\treturn (err);\n}\n\nstatic int\ngather_snapshots(zfs_handle_t *zhp, void *arg)\n{\n\tdestroy_cbdata_t *cb = arg;\n\tint err = 0;\n\n\terr = zfs_iter_snapspec_v2(zhp, 0, cb->cb_snapspec,\n\t    snapshot_to_nvl_cb, cb);\n\tif (err == ENOENT)\n\t\terr = 0;\n\tif (err != 0)\n\t\tgoto out;\n\n\tif (cb->cb_verbose) {\n\t\terr = destroy_print_snapshots(zhp, cb);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\tif (cb->cb_recurse)\n\t\terr = zfs_iter_filesystems_v2(zhp, 0, gather_snapshots, cb);\n\nout:\n\tzfs_close(zhp);\n\treturn (err);\n}\n\nstatic int\ndestroy_clones(destroy_cbdata_t *cb)\n{\n\tnvpair_t *pair;\n\tfor (pair = nvlist_next_nvpair(cb->cb_nvl, NULL);\n\t    pair != NULL;\n\t    pair = nvlist_next_nvpair(cb->cb_nvl, pair)) {\n\t\tzfs_handle_t *zhp = zfs_open(g_zfs, nvpair_name(pair),\n\t\t    ZFS_TYPE_SNAPSHOT);\n\t\tif (zhp != NULL) {\n\t\t\tboolean_t defer = cb->cb_defer_destroy;\n\t\t\tint err;\n\n\t\t\t \n\t\t\tcb->cb_defer_destroy = B_FALSE;\n\t\t\terr = zfs_iter_dependents_v2(zhp, 0, B_FALSE,\n\t\t\t    destroy_callback, cb);\n\t\t\tcb->cb_defer_destroy = defer;\n\t\t\tzfs_close(zhp);\n\t\t\tif (err != 0)\n\t\t\t\treturn (err);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_do_destroy(int argc, char **argv)\n{\n\tdestroy_cbdata_t cb = { 0 };\n\tint rv = 0;\n\tint err = 0;\n\tint c;\n\tzfs_handle_t *zhp = NULL;\n\tchar *at, *pound;\n\tzfs_type_t type = ZFS_TYPE_DATASET;\n\n\t \n\twhile ((c = getopt(argc, argv, \"vpndfrR\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tcb.cb_verbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcb.cb_verbose = B_TRUE;\n\t\t\tcb.cb_parsable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcb.cb_dryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcb.cb_defer_destroy = B_TRUE;\n\t\t\ttype = ZFS_TYPE_SNAPSHOT;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tcb.cb_force = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tcb.cb_recurse = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tcb.cb_recurse = B_TRUE;\n\t\t\tcb.cb_doclones = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc == 0) {\n\t\t(void) fprintf(stderr, gettext(\"missing dataset argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tat = strchr(argv[0], '@');\n\tpound = strchr(argv[0], '#');\n\tif (at != NULL) {\n\n\t\t \n\t\tcb.cb_nvl = fnvlist_alloc();\n\n\t\t*at = '\\0';\n\t\tzhp = zfs_open(g_zfs, argv[0],\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\tif (zhp == NULL) {\n\t\t\tnvlist_free(cb.cb_nvl);\n\t\t\treturn (1);\n\t\t}\n\n\t\tcb.cb_snapspec = at + 1;\n\t\tif (gather_snapshots(zfs_handle_dup(zhp), &cb) != 0 ||\n\t\t    cb.cb_error) {\n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (nvlist_empty(cb.cb_nvl)) {\n\t\t\t(void) fprintf(stderr, gettext(\"could not find any \"\n\t\t\t    \"snapshots to destroy; check snapshot names.\\n\"));\n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cb.cb_verbose) {\n\t\t\tchar buf[16];\n\t\t\tzfs_nicebytes(cb.cb_snapused, buf, sizeof (buf));\n\t\t\tif (cb.cb_parsable) {\n\t\t\t\t(void) printf(\"reclaim\\t%llu\\n\",\n\t\t\t\t    (u_longlong_t)cb.cb_snapused);\n\t\t\t} else if (cb.cb_dryrun) {\n\t\t\t\t(void) printf(gettext(\"would reclaim %s\\n\"),\n\t\t\t\t    buf);\n\t\t\t} else {\n\t\t\t\t(void) printf(gettext(\"will reclaim %s\\n\"),\n\t\t\t\t    buf);\n\t\t\t}\n\t\t}\n\n\t\tif (!cb.cb_dryrun) {\n\t\t\tif (cb.cb_doclones) {\n\t\t\t\tcb.cb_batchedsnaps = fnvlist_alloc();\n\t\t\t\terr = destroy_clones(&cb);\n\t\t\t\tif (err == 0) {\n\t\t\t\t\terr = zfs_destroy_snaps_nvl(g_zfs,\n\t\t\t\t\t    cb.cb_batchedsnaps, B_FALSE);\n\t\t\t\t}\n\t\t\t\tif (err != 0) {\n\t\t\t\t\trv = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = zfs_destroy_snaps_nvl(g_zfs, cb.cb_nvl,\n\t\t\t\t    cb.cb_defer_destroy);\n\t\t\t}\n\t\t}\n\n\t\tif (err != 0)\n\t\t\trv = 1;\n\t} else if (pound != NULL) {\n\t\tint err;\n\t\tnvlist_t *nvl;\n\n\t\tif (cb.cb_dryrun) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"dryrun is not supported with bookmark\\n\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (cb.cb_defer_destroy) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"defer destroy is not supported with bookmark\\n\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (cb.cb_recurse) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"recursive is not supported with bookmark\\n\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\tif (!zfs_bookmark_exists(argv[0])) {\n\t\t\t(void) fprintf(stderr, gettext(\"bookmark '%s' \"\n\t\t\t    \"does not exist.\\n\"), argv[0]);\n\t\t\treturn (1);\n\t\t}\n\n\t\tnvl = fnvlist_alloc();\n\t\tfnvlist_add_boolean(nvl, argv[0]);\n\n\t\terr = lzc_destroy_bookmarks(nvl, NULL);\n\t\tif (err != 0) {\n\t\t\t(void) zfs_standard_error(g_zfs, err,\n\t\t\t    \"cannot destroy bookmark\");\n\t\t}\n\n\t\tnvlist_free(nvl);\n\n\t\treturn (err);\n\t} else {\n\t\t \n\t\tif ((zhp = zfs_open(g_zfs, argv[0], type)) == NULL)\n\t\t\treturn (1);\n\n\t\tcb.cb_target = zhp;\n\n\t\t \n\t\tif (!cb.cb_recurse && strchr(zfs_get_name(zhp), '/') == NULL &&\n\t\t    zfs_get_type(zhp) == ZFS_TYPE_FILESYSTEM) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot destroy '%s': \"\n\t\t\t    \"operation does not apply to pools\\n\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\t(void) fprintf(stderr, gettext(\"use 'zfs destroy -r \"\n\t\t\t    \"%s' to destroy all datasets in the pool\\n\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\t(void) fprintf(stderr, gettext(\"use 'zpool destroy %s' \"\n\t\t\t    \"to destroy the pool itself\\n\"), zfs_get_name(zhp));\n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tcb.cb_first = B_TRUE;\n\t\tif (!cb.cb_doclones && zfs_iter_dependents_v2(zhp, 0, B_TRUE,\n\t\t    destroy_check_dependent, &cb) != 0) {\n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cb.cb_error) {\n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcb.cb_batchedsnaps = fnvlist_alloc();\n\t\tif (zfs_iter_dependents_v2(zhp, 0, B_FALSE, destroy_callback,\n\t\t    &cb) != 0) {\n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terr = destroy_callback(zhp, &cb);\n\t\tzhp = NULL;\n\t\tif (err == 0) {\n\t\t\terr = zfs_destroy_snaps_nvl(g_zfs,\n\t\t\t    cb.cb_batchedsnaps, cb.cb_defer_destroy);\n\t\t}\n\t\tif (err != 0 || cb.cb_error == B_TRUE)\n\t\t\trv = 1;\n\t}\n\nout:\n\tfnvlist_free(cb.cb_batchedsnaps);\n\tfnvlist_free(cb.cb_nvl);\n\tif (zhp != NULL)\n\t\tzfs_close(zhp);\n\treturn (rv);\n}\n\nstatic boolean_t\nis_recvd_column(zprop_get_cbdata_t *cbp)\n{\n\tint i;\n\tzfs_get_column_t col;\n\n\tfor (i = 0; i < ZFS_GET_NCOLS &&\n\t    (col = cbp->cb_columns[i]) != GET_COL_NONE; i++)\n\t\tif (col == GET_COL_RECVD)\n\t\t\treturn (B_TRUE);\n\treturn (B_FALSE);\n}\n\n \n\n \nstatic int\nget_callback(zfs_handle_t *zhp, void *data)\n{\n\tchar buf[ZFS_MAXPROPLEN];\n\tchar rbuf[ZFS_MAXPROPLEN];\n\tzprop_source_t sourcetype;\n\tchar source[ZFS_MAX_DATASET_NAME_LEN];\n\tzprop_get_cbdata_t *cbp = data;\n\tnvlist_t *user_props = zfs_get_user_props(zhp);\n\tzprop_list_t *pl = cbp->cb_proplist;\n\tnvlist_t *propval;\n\tconst char *strval;\n\tconst char *sourceval;\n\tboolean_t received = is_recvd_column(cbp);\n\n\tfor (; pl != NULL; pl = pl->pl_next) {\n\t\tchar *recvdval = NULL;\n\t\t \n\t\tif (pl->pl_prop == ZFS_PROP_NAME &&\n\t\t    pl == cbp->cb_proplist)\n\t\t\tcontinue;\n\n\t\tif (pl->pl_prop != ZPROP_USERPROP) {\n\t\t\tif (zfs_prop_get(zhp, pl->pl_prop, buf,\n\t\t\t    sizeof (buf), &sourcetype, source,\n\t\t\t    sizeof (source),\n\t\t\t    cbp->cb_literal) != 0) {\n\t\t\t\tif (pl->pl_all)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!zfs_prop_valid_for_type(pl->pl_prop,\n\t\t\t\t    ZFS_TYPE_DATASET, B_FALSE)) {\n\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t    gettext(\"No such property '%s'\\n\"),\n\t\t\t\t\t    zfs_prop_to_name(pl->pl_prop));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsourcetype = ZPROP_SRC_NONE;\n\t\t\t\t(void) strlcpy(buf, \"-\", sizeof (buf));\n\t\t\t}\n\n\t\t\tif (received && (zfs_prop_get_recvd(zhp,\n\t\t\t    zfs_prop_to_name(pl->pl_prop), rbuf, sizeof (rbuf),\n\t\t\t    cbp->cb_literal) == 0))\n\t\t\t\trecvdval = rbuf;\n\n\t\t\tzprop_print_one_property(zfs_get_name(zhp), cbp,\n\t\t\t    zfs_prop_to_name(pl->pl_prop),\n\t\t\t    buf, sourcetype, source, recvdval);\n\t\t} else if (zfs_prop_userquota(pl->pl_user_prop)) {\n\t\t\tsourcetype = ZPROP_SRC_LOCAL;\n\n\t\t\tif (zfs_prop_get_userquota(zhp, pl->pl_user_prop,\n\t\t\t    buf, sizeof (buf), cbp->cb_literal) != 0) {\n\t\t\t\tsourcetype = ZPROP_SRC_NONE;\n\t\t\t\t(void) strlcpy(buf, \"-\", sizeof (buf));\n\t\t\t}\n\n\t\t\tzprop_print_one_property(zfs_get_name(zhp), cbp,\n\t\t\t    pl->pl_user_prop, buf, sourcetype, source, NULL);\n\t\t} else if (zfs_prop_written(pl->pl_user_prop)) {\n\t\t\tsourcetype = ZPROP_SRC_LOCAL;\n\n\t\t\tif (zfs_prop_get_written(zhp, pl->pl_user_prop,\n\t\t\t    buf, sizeof (buf), cbp->cb_literal) != 0) {\n\t\t\t\tsourcetype = ZPROP_SRC_NONE;\n\t\t\t\t(void) strlcpy(buf, \"-\", sizeof (buf));\n\t\t\t}\n\n\t\t\tzprop_print_one_property(zfs_get_name(zhp), cbp,\n\t\t\t    pl->pl_user_prop, buf, sourcetype, source, NULL);\n\t\t} else {\n\t\t\tif (nvlist_lookup_nvlist(user_props,\n\t\t\t    pl->pl_user_prop, &propval) != 0) {\n\t\t\t\tif (pl->pl_all)\n\t\t\t\t\tcontinue;\n\t\t\t\tsourcetype = ZPROP_SRC_NONE;\n\t\t\t\tstrval = \"-\";\n\t\t\t} else {\n\t\t\t\tstrval = fnvlist_lookup_string(propval,\n\t\t\t\t    ZPROP_VALUE);\n\t\t\t\tsourceval = fnvlist_lookup_string(propval,\n\t\t\t\t    ZPROP_SOURCE);\n\n\t\t\t\tif (strcmp(sourceval,\n\t\t\t\t    zfs_get_name(zhp)) == 0) {\n\t\t\t\t\tsourcetype = ZPROP_SRC_LOCAL;\n\t\t\t\t} else if (strcmp(sourceval,\n\t\t\t\t    ZPROP_SOURCE_VAL_RECVD) == 0) {\n\t\t\t\t\tsourcetype = ZPROP_SRC_RECEIVED;\n\t\t\t\t} else {\n\t\t\t\t\tsourcetype = ZPROP_SRC_INHERITED;\n\t\t\t\t\t(void) strlcpy(source,\n\t\t\t\t\t    sourceval, sizeof (source));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (received && (zfs_prop_get_recvd(zhp,\n\t\t\t    pl->pl_user_prop, rbuf, sizeof (rbuf),\n\t\t\t    cbp->cb_literal) == 0))\n\t\t\t\trecvdval = rbuf;\n\n\t\t\tzprop_print_one_property(zfs_get_name(zhp), cbp,\n\t\t\t    pl->pl_user_prop, strval, sourcetype,\n\t\t\t    source, recvdval);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzfs_do_get(int argc, char **argv)\n{\n\tzprop_get_cbdata_t cb = { 0 };\n\tint i, c, flags = ZFS_ITER_ARGS_CAN_BE_PATHS;\n\tint types = ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK;\n\tchar *fields;\n\tint ret = 0;\n\tint limit = 0;\n\tzprop_list_t fake_name = { 0 };\n\n\t \n\tcb.cb_sources = ZPROP_SRC_ALL;\n\tcb.cb_columns[0] = GET_COL_NAME;\n\tcb.cb_columns[1] = GET_COL_PROPERTY;\n\tcb.cb_columns[2] = GET_COL_VALUE;\n\tcb.cb_columns[3] = GET_COL_SOURCE;\n\tcb.cb_type = ZFS_TYPE_DATASET;\n\n\t \n\twhile ((c = getopt(argc, argv, \":d:o:s:rt:Hp\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'p':\n\t\t\tcb.cb_literal = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tlimit = parse_depth(optarg, &flags);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags |= ZFS_ITER_RECURSE;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcb.cb_scripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\t \n\t\t\tmemset(&cb.cb_columns, 0, sizeof (cb.cb_columns));\n\n\t\t\ti = 0;\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const col_subopts[] =\n\t\t\t\t{ \"name\", \"property\", \"value\",\n\t\t\t\t    \"received\", \"source\", \"all\" };\n\t\t\t\tstatic const zfs_get_column_t col_subopt_col[] =\n\t\t\t\t{ GET_COL_NAME, GET_COL_PROPERTY, GET_COL_VALUE,\n\t\t\t\t    GET_COL_RECVD, GET_COL_SOURCE };\n\t\t\t\tstatic const int col_subopt_flags[] =\n\t\t\t\t{ 0, 0, 0, ZFS_ITER_RECVD_PROPS, 0 };\n\n\t\t\t\tif (i == ZFS_GET_NCOLS) {\n\t\t\t\t\t(void) fprintf(stderr, gettext(\"too \"\n\t\t\t\t\t    \"many fields given to -o \"\n\t\t\t\t\t    \"option\\n\"));\n\t\t\t\t\tusage(B_FALSE);\n\t\t\t\t}\n\n\t\t\t\tfor (c = 0; c < ARRAY_SIZE(col_subopts); ++c)\n\t\t\t\t\tif (strcmp(tok, col_subopts[c]) == 0)\n\t\t\t\t\t\tgoto found;\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid column name '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\n\nfound:\n\t\t\t\tif (c >= 5) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t\t\t    gettext(\"\\\"all\\\" conflicts \"\n\t\t\t\t\t\t    \"with specific fields \"\n\t\t\t\t\t\t    \"given to -o option\\n\"));\n\t\t\t\t\t\tusage(B_FALSE);\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(cb.cb_columns, col_subopt_col,\n\t\t\t\t\t    sizeof (col_subopt_col));\n\t\t\t\t\tflags |= ZFS_ITER_RECVD_PROPS;\n\t\t\t\t\ti = ZFS_GET_NCOLS;\n\t\t\t\t} else {\n\t\t\t\t\tcb.cb_columns[i++] = col_subopt_col[c];\n\t\t\t\t\tflags |= col_subopt_flags[c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tcb.cb_sources = 0;\n\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const source_opt[] = {\n\t\t\t\t\t\"local\", \"default\",\n\t\t\t\t\t\"inherited\", \"received\",\n\t\t\t\t\t\"temporary\", \"none\" };\n\t\t\t\tstatic const int source_flg[] = {\n\t\t\t\t\tZPROP_SRC_LOCAL, ZPROP_SRC_DEFAULT,\n\t\t\t\t\tZPROP_SRC_INHERITED, ZPROP_SRC_RECEIVED,\n\t\t\t\t\tZPROP_SRC_TEMPORARY, ZPROP_SRC_NONE };\n\n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(source_opt); ++i)\n\t\t\t\t\tif (strcmp(tok, source_opt[i]) == 0) {\n\t\t\t\t\t\tcb.cb_sources |= source_flg[i];\n\t\t\t\t\t\tgoto found2;\n\t\t\t\t\t}\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid source '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\nfound2:;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\ttypes = 0;\n\t\t\tflags &= ~ZFS_ITER_PROP_LISTSNAPS;\n\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const type_opts[] = {\n\t\t\t\t\t\"filesystem\", \"volume\",\n\t\t\t\t\t\"snapshot\", \"snap\",\n\t\t\t\t\t\"bookmark\",\n\t\t\t\t\t\"all\" };\n\t\t\t\tstatic const int type_types[] = {\n\t\t\t\t\tZFS_TYPE_FILESYSTEM, ZFS_TYPE_VOLUME,\n\t\t\t\t\tZFS_TYPE_SNAPSHOT, ZFS_TYPE_SNAPSHOT,\n\t\t\t\t\tZFS_TYPE_BOOKMARK,\n\t\t\t\t\tZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK };\n\n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(type_opts); ++i)\n\t\t\t\t\tif (strcmp(tok, type_opts[i]) == 0) {\n\t\t\t\t\t\ttypes |= type_types[i];\n\t\t\t\t\t\tgoto found3;\n\t\t\t\t\t}\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid type '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\nfound3:;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing property \"\n\t\t    \"argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tfields = argv[0];\n\n\t \n\tif ((types == ZFS_TYPE_SNAPSHOT || types == ZFS_TYPE_BOOKMARK) &&\n\t    argc > 1 && (flags & ZFS_ITER_RECURSE) == 0 && limit == 0) {\n\t\tflags |= (ZFS_ITER_DEPTH_LIMIT | ZFS_ITER_RECURSE);\n\t\tlimit = 1;\n\t}\n\n\tif (zprop_get_list(g_zfs, fields, &cb.cb_proplist, ZFS_TYPE_DATASET)\n\t    != 0)\n\t\tusage(B_FALSE);\n\n\targc--;\n\targv++;\n\n\t \n\tif (cb.cb_proplist != NULL) {\n\t\tfake_name.pl_prop = ZFS_PROP_NAME;\n\t\tfake_name.pl_width = strlen(gettext(\"NAME\"));\n\t\tfake_name.pl_next = cb.cb_proplist;\n\t\tcb.cb_proplist = &fake_name;\n\t}\n\n\tcb.cb_first = B_TRUE;\n\n\t \n\tret = zfs_for_each(argc, argv, flags, types, NULL,\n\t    &cb.cb_proplist, limit, get_callback, &cb);\n\n\tif (cb.cb_proplist == &fake_name)\n\t\tzprop_free_list(fake_name.pl_next);\n\telse\n\t\tzprop_free_list(cb.cb_proplist);\n\n\treturn (ret);\n}\n\n \n\ntypedef struct inherit_cbdata {\n\tconst char *cb_propname;\n\tboolean_t cb_received;\n} inherit_cbdata_t;\n\nstatic int\ninherit_recurse_cb(zfs_handle_t *zhp, void *data)\n{\n\tinherit_cbdata_t *cb = data;\n\tzfs_prop_t prop = zfs_name_to_prop(cb->cb_propname);\n\n\t \n\tif (prop != ZPROP_INVAL &&\n\t    !zfs_prop_valid_for_type(prop, zfs_get_type(zhp), B_FALSE))\n\t\treturn (0);\n\n\treturn (zfs_prop_inherit(zhp, cb->cb_propname, cb->cb_received) != 0);\n}\n\nstatic int\ninherit_cb(zfs_handle_t *zhp, void *data)\n{\n\tinherit_cbdata_t *cb = data;\n\n\treturn (zfs_prop_inherit(zhp, cb->cb_propname, cb->cb_received) != 0);\n}\n\nstatic int\nzfs_do_inherit(int argc, char **argv)\n{\n\tint c;\n\tzfs_prop_t prop;\n\tinherit_cbdata_t cb = { 0 };\n\tchar *propname;\n\tint ret = 0;\n\tint flags = 0;\n\tboolean_t received = B_FALSE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"rS\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tflags |= ZFS_ITER_RECURSE;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\treceived = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing property argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing dataset argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tpropname = argv[0];\n\targc--;\n\targv++;\n\n\tif ((prop = zfs_name_to_prop(propname)) != ZPROP_USERPROP) {\n\t\tif (zfs_prop_readonly(prop)) {\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"%s property is read-only\\n\"),\n\t\t\t    propname);\n\t\t\treturn (1);\n\t\t}\n\t\tif (!zfs_prop_inheritable(prop) && !received) {\n\t\t\t(void) fprintf(stderr, gettext(\"'%s' property cannot \"\n\t\t\t    \"be inherited\\n\"), propname);\n\t\t\tif (prop == ZFS_PROP_QUOTA ||\n\t\t\t    prop == ZFS_PROP_RESERVATION ||\n\t\t\t    prop == ZFS_PROP_REFQUOTA ||\n\t\t\t    prop == ZFS_PROP_REFRESERVATION) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"use 'zfs set \"\n\t\t\t\t    \"%s=none' to clear\\n\"), propname);\n\t\t\t\t(void) fprintf(stderr, gettext(\"use 'zfs \"\n\t\t\t\t    \"inherit -S %s' to revert to received \"\n\t\t\t\t    \"value\\n\"), propname);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\tif (received && (prop == ZFS_PROP_VOLSIZE ||\n\t\t    prop == ZFS_PROP_VERSION)) {\n\t\t\t(void) fprintf(stderr, gettext(\"'%s' property cannot \"\n\t\t\t    \"be reverted to a received value\\n\"), propname);\n\t\t\treturn (1);\n\t\t}\n\t} else if (!zfs_prop_user(propname)) {\n\t\t(void) fprintf(stderr, gettext(\"invalid property '%s'\\n\"),\n\t\t    propname);\n\t\tusage(B_FALSE);\n\t}\n\n\tcb.cb_propname = propname;\n\tcb.cb_received = received;\n\n\tif (flags & ZFS_ITER_RECURSE) {\n\t\tret = zfs_for_each(argc, argv, flags, ZFS_TYPE_DATASET,\n\t\t    NULL, NULL, 0, inherit_recurse_cb, &cb);\n\t} else {\n\t\tret = zfs_for_each(argc, argv, flags, ZFS_TYPE_DATASET,\n\t\t    NULL, NULL, 0, inherit_cb, &cb);\n\t}\n\n\treturn (ret);\n}\n\ntypedef struct upgrade_cbdata {\n\tuint64_t cb_numupgraded;\n\tuint64_t cb_numsamegraded;\n\tuint64_t cb_numfailed;\n\tuint64_t cb_version;\n\tboolean_t cb_newer;\n\tboolean_t cb_foundone;\n\tchar cb_lastfs[ZFS_MAX_DATASET_NAME_LEN];\n} upgrade_cbdata_t;\n\nstatic int\nsame_pool(zfs_handle_t *zhp, const char *name)\n{\n\tint len1 = strcspn(name, \"/@\");\n\tconst char *zhname = zfs_get_name(zhp);\n\tint len2 = strcspn(zhname, \"/@\");\n\n\tif (len1 != len2)\n\t\treturn (B_FALSE);\n\treturn (strncmp(name, zhname, len1) == 0);\n}\n\nstatic int\nupgrade_list_callback(zfs_handle_t *zhp, void *data)\n{\n\tupgrade_cbdata_t *cb = data;\n\tint version = zfs_prop_get_int(zhp, ZFS_PROP_VERSION);\n\n\t \n\tif ((!cb->cb_newer && version < ZPL_VERSION) ||\n\t    (cb->cb_newer && version > ZPL_VERSION)) {\n\t\tchar *str;\n\t\tif (cb->cb_newer) {\n\t\t\tstr = gettext(\"The following filesystems are \"\n\t\t\t    \"formatted using a newer software version and\\n\"\n\t\t\t    \"cannot be accessed on the current system.\\n\\n\");\n\t\t} else {\n\t\t\tstr = gettext(\"The following filesystems are \"\n\t\t\t    \"out of date, and can be upgraded.  After being\\n\"\n\t\t\t    \"upgraded, these filesystems (and any 'zfs send' \"\n\t\t\t    \"streams generated from\\n\"\n\t\t\t    \"subsequent snapshots) will no longer be \"\n\t\t\t    \"accessible by older software versions.\\n\\n\");\n\t\t}\n\n\t\tif (!cb->cb_foundone) {\n\t\t\t(void) puts(str);\n\t\t\t(void) printf(gettext(\"VER  FILESYSTEM\\n\"));\n\t\t\t(void) printf(gettext(\"---  ------------\\n\"));\n\t\t\tcb->cb_foundone = B_TRUE;\n\t\t}\n\n\t\t(void) printf(\"%2u   %s\\n\", version, zfs_get_name(zhp));\n\t}\n\n\treturn (0);\n}\n\nstatic int\nupgrade_set_callback(zfs_handle_t *zhp, void *data)\n{\n\tupgrade_cbdata_t *cb = data;\n\tint version = zfs_prop_get_int(zhp, ZFS_PROP_VERSION);\n\tint needed_spa_version;\n\tint spa_version;\n\n\tif (zfs_spa_version(zhp, &spa_version) < 0)\n\t\treturn (-1);\n\n\tneeded_spa_version = zfs_spa_version_map(cb->cb_version);\n\n\tif (needed_spa_version < 0)\n\t\treturn (-1);\n\n\tif (spa_version < needed_spa_version) {\n\t\t \n\t\t(void) printf(gettext(\"%s: can not be \"\n\t\t    \"upgraded; the pool version needs to first \"\n\t\t    \"be upgraded\\nto version %d\\n\\n\"),\n\t\t    zfs_get_name(zhp), needed_spa_version);\n\t\tcb->cb_numfailed++;\n\t\treturn (0);\n\t}\n\n\t \n\tif (version < cb->cb_version) {\n\t\tchar verstr[24];\n\t\t(void) snprintf(verstr, sizeof (verstr),\n\t\t    \"%llu\", (u_longlong_t)cb->cb_version);\n\t\tif (cb->cb_lastfs[0] && !same_pool(zhp, cb->cb_lastfs)) {\n\t\t\t \n\t\t\t(void) zpool_log_history(g_zfs, history_str);\n\t\t\tlog_history = B_FALSE;\n\t\t}\n\t\tif (zfs_prop_set(zhp, \"version\", verstr) == 0)\n\t\t\tcb->cb_numupgraded++;\n\t\telse\n\t\t\tcb->cb_numfailed++;\n\t\t(void) strlcpy(cb->cb_lastfs, zfs_get_name(zhp),\n\t\t    sizeof (cb->cb_lastfs));\n\t} else if (version > cb->cb_version) {\n\t\t \n\t\t(void) printf(gettext(\"%s: can not be downgraded; \"\n\t\t    \"it is already at version %u\\n\"),\n\t\t    zfs_get_name(zhp), version);\n\t\tcb->cb_numfailed++;\n\t} else {\n\t\tcb->cb_numsamegraded++;\n\t}\n\treturn (0);\n}\n\n \nstatic int\nzfs_do_upgrade(int argc, char **argv)\n{\n\tboolean_t all = B_FALSE;\n\tboolean_t showversions = B_FALSE;\n\tint ret = 0;\n\tupgrade_cbdata_t cb = { 0 };\n\tint c;\n\tint flags = ZFS_ITER_ARGS_CAN_BE_PATHS;\n\n\t \n\twhile ((c = getopt(argc, argv, \"rvV:a\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tflags |= ZFS_ITER_RECURSE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tshowversions = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tif (zfs_prop_string_to_index(ZFS_PROP_VERSION,\n\t\t\t    optarg, &cb.cb_version) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid version %s\\n\"), optarg);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tall = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif ((!all && !argc) && ((flags & ZFS_ITER_RECURSE) | cb.cb_version))\n\t\tusage(B_FALSE);\n\tif (showversions && (flags & ZFS_ITER_RECURSE || all ||\n\t    cb.cb_version || argc))\n\t\tusage(B_FALSE);\n\tif ((all || argc) && (showversions))\n\t\tusage(B_FALSE);\n\tif (all && argc)\n\t\tusage(B_FALSE);\n\n\tif (showversions) {\n\t\t \n\t\t(void) printf(gettext(\"The following filesystem versions are \"\n\t\t    \"supported:\\n\\n\"));\n\t\t(void) printf(gettext(\"VER  DESCRIPTION\\n\"));\n\t\t(void) printf(\"---  -----------------------------------------\"\n\t\t    \"---------------\\n\");\n\t\t(void) printf(gettext(\" 1   Initial ZFS filesystem version\\n\"));\n\t\t(void) printf(gettext(\" 2   Enhanced directory entries\\n\"));\n\t\t(void) printf(gettext(\" 3   Case insensitive and filesystem \"\n\t\t    \"user identifier (FUID)\\n\"));\n\t\t(void) printf(gettext(\" 4   userquota, groupquota \"\n\t\t    \"properties\\n\"));\n\t\t(void) printf(gettext(\" 5   System attributes\\n\"));\n\t\t(void) printf(gettext(\"\\nFor more information on a particular \"\n\t\t    \"version, including supported releases,\\n\"));\n\t\t(void) printf(\"see the ZFS Administration Guide.\\n\\n\");\n\t\tret = 0;\n\t} else if (argc || all) {\n\t\t \n\t\tif (cb.cb_version == 0)\n\t\t\tcb.cb_version = ZPL_VERSION;\n\t\tret = zfs_for_each(argc, argv, flags, ZFS_TYPE_FILESYSTEM,\n\t\t    NULL, NULL, 0, upgrade_set_callback, &cb);\n\t\t(void) printf(gettext(\"%llu filesystems upgraded\\n\"),\n\t\t    (u_longlong_t)cb.cb_numupgraded);\n\t\tif (cb.cb_numsamegraded) {\n\t\t\t(void) printf(gettext(\"%llu filesystems already at \"\n\t\t\t    \"this version\\n\"),\n\t\t\t    (u_longlong_t)cb.cb_numsamegraded);\n\t\t}\n\t\tif (cb.cb_numfailed != 0)\n\t\t\tret = 1;\n\t} else {\n\t\t \n\t\tboolean_t found;\n\t\t(void) printf(gettext(\"This system is currently running \"\n\t\t    \"ZFS filesystem version %llu.\\n\\n\"), ZPL_VERSION);\n\n\t\tflags |= ZFS_ITER_RECURSE;\n\t\tret = zfs_for_each(0, NULL, flags, ZFS_TYPE_FILESYSTEM,\n\t\t    NULL, NULL, 0, upgrade_list_callback, &cb);\n\n\t\tfound = cb.cb_foundone;\n\t\tcb.cb_foundone = B_FALSE;\n\t\tcb.cb_newer = B_TRUE;\n\n\t\tret |= zfs_for_each(0, NULL, flags, ZFS_TYPE_FILESYSTEM,\n\t\t    NULL, NULL, 0, upgrade_list_callback, &cb);\n\n\t\tif (!cb.cb_foundone && !found) {\n\t\t\t(void) printf(gettext(\"All filesystems are \"\n\t\t\t    \"formatted with the current version.\\n\"));\n\t\t}\n\t}\n\n\treturn (ret);\n}\n\n \n\n \nenum us_field_types {\n\tUSFIELD_TYPE,\n\tUSFIELD_NAME,\n\tUSFIELD_USED,\n\tUSFIELD_QUOTA,\n\tUSFIELD_OBJUSED,\n\tUSFIELD_OBJQUOTA\n};\nstatic const char *const us_field_hdr[] = { \"TYPE\", \"NAME\", \"USED\", \"QUOTA\",\n\t\t\t\t    \"OBJUSED\", \"OBJQUOTA\" };\nstatic const char *const us_field_names[] = { \"type\", \"name\", \"used\", \"quota\",\n\t\t\t\t    \"objused\", \"objquota\" };\n#define\tUSFIELD_LAST\t(sizeof (us_field_names) / sizeof (char *))\n\n#define\tUSTYPE_PSX_GRP\t(1 << 0)\n#define\tUSTYPE_PSX_USR\t(1 << 1)\n#define\tUSTYPE_SMB_GRP\t(1 << 2)\n#define\tUSTYPE_SMB_USR\t(1 << 3)\n#define\tUSTYPE_PROJ\t(1 << 4)\n#define\tUSTYPE_ALL\t\\\n\t(USTYPE_PSX_GRP | USTYPE_PSX_USR | USTYPE_SMB_GRP | USTYPE_SMB_USR | \\\n\t    USTYPE_PROJ)\n\nstatic int us_type_bits[] = {\n\tUSTYPE_PSX_GRP,\n\tUSTYPE_PSX_USR,\n\tUSTYPE_SMB_GRP,\n\tUSTYPE_SMB_USR,\n\tUSTYPE_ALL\n};\nstatic const char *const us_type_names[] = { \"posixgroup\", \"posixuser\",\n\t\"smbgroup\", \"smbuser\", \"all\" };\n\ntypedef struct us_node {\n\tnvlist_t\t*usn_nvl;\n\tuu_avl_node_t\tusn_avlnode;\n\tuu_list_node_t\tusn_listnode;\n} us_node_t;\n\ntypedef struct us_cbdata {\n\tnvlist_t\t**cb_nvlp;\n\tuu_avl_pool_t\t*cb_avl_pool;\n\tuu_avl_t\t*cb_avl;\n\tboolean_t\tcb_numname;\n\tboolean_t\tcb_nicenum;\n\tboolean_t\tcb_sid2posix;\n\tzfs_userquota_prop_t cb_prop;\n\tzfs_sort_column_t *cb_sortcol;\n\tsize_t\t\tcb_width[USFIELD_LAST];\n} us_cbdata_t;\n\nstatic boolean_t us_populated = B_FALSE;\n\ntypedef struct {\n\tzfs_sort_column_t *si_sortcol;\n\tboolean_t\tsi_numname;\n} us_sort_info_t;\n\nstatic int\nus_field_index(const char *field)\n{\n\tfor (int i = 0; i < USFIELD_LAST; i++) {\n\t\tif (strcmp(field, us_field_names[i]) == 0)\n\t\t\treturn (i);\n\t}\n\n\treturn (-1);\n}\n\nstatic int\nus_compare(const void *larg, const void *rarg, void *unused)\n{\n\tconst us_node_t *l = larg;\n\tconst us_node_t *r = rarg;\n\tus_sort_info_t *si = (us_sort_info_t *)unused;\n\tzfs_sort_column_t *sortcol = si->si_sortcol;\n\tboolean_t numname = si->si_numname;\n\tnvlist_t *lnvl = l->usn_nvl;\n\tnvlist_t *rnvl = r->usn_nvl;\n\tint rc = 0;\n\tboolean_t lvb, rvb;\n\n\tfor (; sortcol != NULL; sortcol = sortcol->sc_next) {\n\t\tconst char *lvstr = \"\";\n\t\tconst char *rvstr = \"\";\n\t\tuint32_t lv32 = 0;\n\t\tuint32_t rv32 = 0;\n\t\tuint64_t lv64 = 0;\n\t\tuint64_t rv64 = 0;\n\t\tzfs_prop_t prop = sortcol->sc_prop;\n\t\tconst char *propname = NULL;\n\t\tboolean_t reverse = sortcol->sc_reverse;\n\n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_TYPE:\n\t\t\tpropname = \"type\";\n\t\t\t(void) nvlist_lookup_uint32(lnvl, propname, &lv32);\n\t\t\t(void) nvlist_lookup_uint32(rnvl, propname, &rv32);\n\t\t\tif (rv32 != lv32)\n\t\t\t\trc = (rv32 < lv32) ? 1 : -1;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_NAME:\n\t\t\tpropname = \"name\";\n\t\t\tif (numname) {\ncompare_nums:\n\t\t\t\t(void) nvlist_lookup_uint64(lnvl, propname,\n\t\t\t\t    &lv64);\n\t\t\t\t(void) nvlist_lookup_uint64(rnvl, propname,\n\t\t\t\t    &rv64);\n\t\t\t\tif (rv64 != lv64)\n\t\t\t\t\trc = (rv64 < lv64) ? 1 : -1;\n\t\t\t} else {\n\t\t\t\tif ((nvlist_lookup_string(lnvl, propname,\n\t\t\t\t    &lvstr) == ENOENT) ||\n\t\t\t\t    (nvlist_lookup_string(rnvl, propname,\n\t\t\t\t    &rvstr) == ENOENT)) {\n\t\t\t\t\tgoto compare_nums;\n\t\t\t\t}\n\t\t\t\trc = strcmp(lvstr, rvstr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ZFS_PROP_USED:\n\t\tcase ZFS_PROP_QUOTA:\n\t\t\tif (!us_populated)\n\t\t\t\tbreak;\n\t\t\tif (prop == ZFS_PROP_USED)\n\t\t\t\tpropname = \"used\";\n\t\t\telse\n\t\t\t\tpropname = \"quota\";\n\t\t\t(void) nvlist_lookup_uint64(lnvl, propname, &lv64);\n\t\t\t(void) nvlist_lookup_uint64(rnvl, propname, &rv64);\n\t\t\tif (rv64 != lv64)\n\t\t\t\trc = (rv64 < lv64) ? 1 : -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc != 0) {\n\t\t\tif (rc < 0)\n\t\t\t\treturn (reverse ? 1 : -1);\n\t\t\telse\n\t\t\t\treturn (reverse ? -1 : 1);\n\t\t}\n\t}\n\n\t \n\tif (nvlist_lookup_boolean_value(lnvl, \"smbentity\", &lvb) == 0 &&\n\t    nvlist_lookup_boolean_value(rnvl, \"smbentity\", &rvb) == 0 &&\n\t    lvb != rvb)\n\t\treturn (lvb < rvb ? -1 : 1);\n\n\treturn (0);\n}\n\nstatic boolean_t\nzfs_prop_is_user(unsigned p)\n{\n\treturn (p == ZFS_PROP_USERUSED || p == ZFS_PROP_USERQUOTA ||\n\t    p == ZFS_PROP_USEROBJUSED || p == ZFS_PROP_USEROBJQUOTA);\n}\n\nstatic boolean_t\nzfs_prop_is_group(unsigned p)\n{\n\treturn (p == ZFS_PROP_GROUPUSED || p == ZFS_PROP_GROUPQUOTA ||\n\t    p == ZFS_PROP_GROUPOBJUSED || p == ZFS_PROP_GROUPOBJQUOTA);\n}\n\nstatic boolean_t\nzfs_prop_is_project(unsigned p)\n{\n\treturn (p == ZFS_PROP_PROJECTUSED || p == ZFS_PROP_PROJECTQUOTA ||\n\t    p == ZFS_PROP_PROJECTOBJUSED || p == ZFS_PROP_PROJECTOBJQUOTA);\n}\n\nstatic inline const char *\nus_type2str(unsigned field_type)\n{\n\tswitch (field_type) {\n\tcase USTYPE_PSX_USR:\n\t\treturn (\"POSIX User\");\n\tcase USTYPE_PSX_GRP:\n\t\treturn (\"POSIX Group\");\n\tcase USTYPE_SMB_USR:\n\t\treturn (\"SMB User\");\n\tcase USTYPE_SMB_GRP:\n\t\treturn (\"SMB Group\");\n\tcase USTYPE_PROJ:\n\t\treturn (\"Project\");\n\tdefault:\n\t\treturn (\"Undefined\");\n\t}\n}\n\nstatic int\nuserspace_cb(void *arg, const char *domain, uid_t rid, uint64_t space)\n{\n\tus_cbdata_t *cb = (us_cbdata_t *)arg;\n\tzfs_userquota_prop_t prop = cb->cb_prop;\n\tchar *name = NULL;\n\tconst char *propname;\n\tchar sizebuf[32];\n\tus_node_t *node;\n\tuu_avl_pool_t *avl_pool = cb->cb_avl_pool;\n\tuu_avl_t *avl = cb->cb_avl;\n\tuu_avl_index_t idx;\n\tnvlist_t *props;\n\tus_node_t *n;\n\tzfs_sort_column_t *sortcol = cb->cb_sortcol;\n\tunsigned type = 0;\n\tconst char *typestr;\n\tsize_t namelen;\n\tsize_t typelen;\n\tsize_t sizelen;\n\tint typeidx, nameidx, sizeidx;\n\tus_sort_info_t sortinfo = { sortcol, cb->cb_numname };\n\tboolean_t smbentity = B_FALSE;\n\n\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\tnode = safe_malloc(sizeof (us_node_t));\n\tuu_avl_node_init(node, &node->usn_avlnode, avl_pool);\n\tnode->usn_nvl = props;\n\n\tif (domain != NULL && domain[0] != '\\0') {\n#ifdef HAVE_IDMAP\n\t\t \n\t\tchar sid[MAXNAMELEN + 32];\n\t\tuid_t id;\n\t\tuint64_t classes;\n\t\tint err;\n\t\tdirectory_error_t e;\n\n\t\tsmbentity = B_TRUE;\n\n\t\t(void) snprintf(sid, sizeof (sid), \"%s-%u\", domain, rid);\n\n\t\tif (prop == ZFS_PROP_GROUPUSED || prop == ZFS_PROP_GROUPQUOTA) {\n\t\t\ttype = USTYPE_SMB_GRP;\n\t\t\terr = sid_to_id(sid, B_FALSE, &id);\n\t\t} else {\n\t\t\ttype = USTYPE_SMB_USR;\n\t\t\terr = sid_to_id(sid, B_TRUE, &id);\n\t\t}\n\n\t\tif (err == 0) {\n\t\t\trid = id;\n\t\t\tif (!cb->cb_sid2posix) {\n\t\t\t\te = directory_name_from_sid(NULL, sid, &name,\n\t\t\t\t    &classes);\n\t\t\t\tif (e != NULL)\n\t\t\t\t\tdirectory_error_free(e);\n\t\t\t\tif (name == NULL)\n\t\t\t\t\tname = sid;\n\t\t\t}\n\t\t}\n#else\n\t\tnvlist_free(props);\n\t\tfree(node);\n\n\t\treturn (-1);\n#endif  \n\t}\n\n\tif (cb->cb_sid2posix || domain == NULL || domain[0] == '\\0') {\n\t\t \n\t\tif (zfs_prop_is_group(prop)) {\n\t\t\ttype = USTYPE_PSX_GRP;\n\t\t\tif (!cb->cb_numname) {\n\t\t\t\tstruct group *g;\n\n\t\t\t\tif ((g = getgrgid(rid)) != NULL)\n\t\t\t\t\tname = g->gr_name;\n\t\t\t}\n\t\t} else if (zfs_prop_is_user(prop)) {\n\t\t\ttype = USTYPE_PSX_USR;\n\t\t\tif (!cb->cb_numname) {\n\t\t\t\tstruct passwd *p;\n\n\t\t\t\tif ((p = getpwuid(rid)) != NULL)\n\t\t\t\t\tname = p->pw_name;\n\t\t\t}\n\t\t} else {\n\t\t\ttype = USTYPE_PROJ;\n\t\t}\n\t}\n\n\t \n\tif (cb->cb_sid2posix &&\n\t    nvlist_add_boolean_value(props, \"smbentity\", smbentity) != 0)\n\t\tnomem();\n\n\t \n\ttypestr = us_type2str(type);\n\ttypelen = strlen(gettext(typestr));\n\ttypeidx = us_field_index(\"type\");\n\tif (typelen > cb->cb_width[typeidx])\n\t\tcb->cb_width[typeidx] = typelen;\n\tif (nvlist_add_uint32(props, \"type\", type) != 0)\n\t\tnomem();\n\n\t \n\tif ((cb->cb_numname && cb->cb_sid2posix) || name == NULL) {\n\t\tif (nvlist_add_uint64(props, \"name\", rid) != 0)\n\t\t\tnomem();\n\t\tnamelen = snprintf(NULL, 0, \"%u\", rid);\n\t} else {\n\t\tif (nvlist_add_string(props, \"name\", name) != 0)\n\t\t\tnomem();\n\t\tnamelen = strlen(name);\n\t}\n\tnameidx = us_field_index(\"name\");\n\tif (nameidx >= 0 && namelen > cb->cb_width[nameidx])\n\t\tcb->cb_width[nameidx] = namelen;\n\n\t \n\tif ((n = uu_avl_find(avl, node, &sortinfo, &idx)) == NULL) {\n\t\tuu_avl_insert(avl, node, idx);\n\t} else {\n\t\tnvlist_free(props);\n\t\tfree(node);\n\t\tnode = n;\n\t\tprops = node->usn_nvl;\n\t}\n\n\t \n\tif (cb->cb_nicenum) {\n\t\tif (prop == ZFS_PROP_USERUSED || prop == ZFS_PROP_GROUPUSED ||\n\t\t    prop == ZFS_PROP_USERQUOTA || prop == ZFS_PROP_GROUPQUOTA ||\n\t\t    prop == ZFS_PROP_PROJECTUSED ||\n\t\t    prop == ZFS_PROP_PROJECTQUOTA) {\n\t\t\tzfs_nicebytes(space, sizebuf, sizeof (sizebuf));\n\t\t} else {\n\t\t\tzfs_nicenum(space, sizebuf, sizeof (sizebuf));\n\t\t}\n\t} else {\n\t\t(void) snprintf(sizebuf, sizeof (sizebuf), \"%llu\",\n\t\t    (u_longlong_t)space);\n\t}\n\tsizelen = strlen(sizebuf);\n\tif (prop == ZFS_PROP_USERUSED || prop == ZFS_PROP_GROUPUSED ||\n\t    prop == ZFS_PROP_PROJECTUSED) {\n\t\tpropname = \"used\";\n\t\tif (!nvlist_exists(props, \"quota\"))\n\t\t\t(void) nvlist_add_uint64(props, \"quota\", 0);\n\t} else if (prop == ZFS_PROP_USERQUOTA || prop == ZFS_PROP_GROUPQUOTA ||\n\t    prop == ZFS_PROP_PROJECTQUOTA) {\n\t\tpropname = \"quota\";\n\t\tif (!nvlist_exists(props, \"used\"))\n\t\t\t(void) nvlist_add_uint64(props, \"used\", 0);\n\t} else if (prop == ZFS_PROP_USEROBJUSED ||\n\t    prop == ZFS_PROP_GROUPOBJUSED || prop == ZFS_PROP_PROJECTOBJUSED) {\n\t\tpropname = \"objused\";\n\t\tif (!nvlist_exists(props, \"objquota\"))\n\t\t\t(void) nvlist_add_uint64(props, \"objquota\", 0);\n\t} else if (prop == ZFS_PROP_USEROBJQUOTA ||\n\t    prop == ZFS_PROP_GROUPOBJQUOTA ||\n\t    prop == ZFS_PROP_PROJECTOBJQUOTA) {\n\t\tpropname = \"objquota\";\n\t\tif (!nvlist_exists(props, \"objused\"))\n\t\t\t(void) nvlist_add_uint64(props, \"objused\", 0);\n\t} else {\n\t\treturn (-1);\n\t}\n\tsizeidx = us_field_index(propname);\n\tif (sizeidx >= 0 && sizelen > cb->cb_width[sizeidx])\n\t\tcb->cb_width[sizeidx] = sizelen;\n\n\tif (nvlist_add_uint64(props, propname, space) != 0)\n\t\tnomem();\n\n\treturn (0);\n}\n\nstatic void\nprint_us_node(boolean_t scripted, boolean_t parsable, int *fields, int types,\n    size_t *width, us_node_t *node)\n{\n\tnvlist_t *nvl = node->usn_nvl;\n\tchar valstr[MAXNAMELEN];\n\tboolean_t first = B_TRUE;\n\tint cfield = 0;\n\tint field;\n\tuint32_t ustype;\n\n\t \n\t(void) nvlist_lookup_uint32(nvl, \"type\", &ustype);\n\tif (!(ustype & types))\n\t\treturn;\n\n\twhile ((field = fields[cfield]) != USFIELD_LAST) {\n\t\tnvpair_t *nvp = NULL;\n\t\tdata_type_t type;\n\t\tuint32_t val32 = -1;\n\t\tuint64_t val64 = -1;\n\t\tconst char *strval = \"-\";\n\n\t\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL)\n\t\t\tif (strcmp(nvpair_name(nvp),\n\t\t\t    us_field_names[field]) == 0)\n\t\t\t\tbreak;\n\n\t\ttype = nvp == NULL ? DATA_TYPE_UNKNOWN : nvpair_type(nvp);\n\t\tswitch (type) {\n\t\tcase DATA_TYPE_UINT32:\n\t\t\tval32 = fnvpair_value_uint32(nvp);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT64:\n\t\t\tval64 = fnvpair_value_uint64(nvp);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_STRING:\n\t\t\tstrval = fnvpair_value_string(nvp);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UNKNOWN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, \"invalid data type\\n\");\n\t\t}\n\n\t\tswitch (field) {\n\t\tcase USFIELD_TYPE:\n\t\t\tif (type == DATA_TYPE_UINT32)\n\t\t\t\tstrval = us_type2str(val32);\n\t\t\tbreak;\n\t\tcase USFIELD_NAME:\n\t\t\tif (type == DATA_TYPE_UINT64) {\n\t\t\t\t(void) sprintf(valstr, \"%llu\",\n\t\t\t\t    (u_longlong_t)val64);\n\t\t\t\tstrval = valstr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USFIELD_USED:\n\t\tcase USFIELD_QUOTA:\n\t\t\tif (type == DATA_TYPE_UINT64) {\n\t\t\t\tif (parsable) {\n\t\t\t\t\t(void) sprintf(valstr, \"%llu\",\n\t\t\t\t\t    (u_longlong_t)val64);\n\t\t\t\t\tstrval = valstr;\n\t\t\t\t} else if (field == USFIELD_QUOTA &&\n\t\t\t\t    val64 == 0) {\n\t\t\t\t\tstrval = \"none\";\n\t\t\t\t} else {\n\t\t\t\t\tzfs_nicebytes(val64, valstr,\n\t\t\t\t\t    sizeof (valstr));\n\t\t\t\t\tstrval = valstr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USFIELD_OBJUSED:\n\t\tcase USFIELD_OBJQUOTA:\n\t\t\tif (type == DATA_TYPE_UINT64) {\n\t\t\t\tif (parsable) {\n\t\t\t\t\t(void) sprintf(valstr, \"%llu\",\n\t\t\t\t\t    (u_longlong_t)val64);\n\t\t\t\t\tstrval = valstr;\n\t\t\t\t} else if (field == USFIELD_OBJQUOTA &&\n\t\t\t\t    val64 == 0) {\n\t\t\t\t\tstrval = \"none\";\n\t\t\t\t} else {\n\t\t\t\t\tzfs_nicenum(val64, valstr,\n\t\t\t\t\t    sizeof (valstr));\n\t\t\t\t\tstrval = valstr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!first) {\n\t\t\tif (scripted)\n\t\t\t\t(void) putchar('\\t');\n\t\t\telse\n\t\t\t\t(void) fputs(\"  \", stdout);\n\t\t}\n\t\tif (scripted)\n\t\t\t(void) fputs(strval, stdout);\n\t\telse if (field == USFIELD_TYPE || field == USFIELD_NAME)\n\t\t\t(void) printf(\"%-*s\", (int)width[field], strval);\n\t\telse\n\t\t\t(void) printf(\"%*s\", (int)width[field], strval);\n\n\t\tfirst = B_FALSE;\n\t\tcfield++;\n\t}\n\n\t(void) putchar('\\n');\n}\n\nstatic void\nprint_us(boolean_t scripted, boolean_t parsable, int *fields, int types,\n    size_t *width, boolean_t rmnode, uu_avl_t *avl)\n{\n\tus_node_t *node;\n\tconst char *col;\n\tint cfield = 0;\n\tint field;\n\n\tif (!scripted) {\n\t\tboolean_t first = B_TRUE;\n\n\t\twhile ((field = fields[cfield]) != USFIELD_LAST) {\n\t\t\tcol = gettext(us_field_hdr[field]);\n\t\t\tif (field == USFIELD_TYPE || field == USFIELD_NAME) {\n\t\t\t\t(void) printf(first ? \"%-*s\" : \"  %-*s\",\n\t\t\t\t    (int)width[field], col);\n\t\t\t} else {\n\t\t\t\t(void) printf(first ? \"%*s\" : \"  %*s\",\n\t\t\t\t    (int)width[field], col);\n\t\t\t}\n\t\t\tfirst = B_FALSE;\n\t\t\tcfield++;\n\t\t}\n\t\t(void) printf(\"\\n\");\n\t}\n\n\tfor (node = uu_avl_first(avl); node; node = uu_avl_next(avl, node)) {\n\t\tprint_us_node(scripted, parsable, fields, types, width, node);\n\t\tif (rmnode)\n\t\t\tnvlist_free(node->usn_nvl);\n\t}\n}\n\nstatic int\nzfs_do_userspace(int argc, char **argv)\n{\n\tzfs_handle_t *zhp;\n\tzfs_userquota_prop_t p;\n\tuu_avl_pool_t *avl_pool;\n\tuu_avl_t *avl_tree;\n\tuu_avl_walk_t *walk;\n\tchar *delim;\n\tchar deffields[] = \"type,name,used,quota,objused,objquota\";\n\tchar *ofield = NULL;\n\tchar *tfield = NULL;\n\tint cfield = 0;\n\tint fields[256];\n\tint i;\n\tboolean_t scripted = B_FALSE;\n\tboolean_t prtnum = B_FALSE;\n\tboolean_t parsable = B_FALSE;\n\tboolean_t sid2posix = B_FALSE;\n\tint ret = 0;\n\tint c;\n\tzfs_sort_column_t *sortcol = NULL;\n\tint types = USTYPE_PSX_USR | USTYPE_SMB_USR;\n\tus_cbdata_t cb;\n\tus_node_t *node;\n\tus_node_t *rmnode;\n\tuu_list_pool_t *listpool;\n\tuu_list_t *list;\n\tuu_avl_index_t idx = 0;\n\tuu_list_index_t idx2 = 0;\n\n\tif (argc < 2)\n\t\tusage(B_FALSE);\n\n\tif (strcmp(argv[0], \"groupspace\") == 0) {\n\t\t \n\t\ttypes = USTYPE_PSX_GRP | USTYPE_SMB_GRP;\n\t} else if (strcmp(argv[0], \"projectspace\") == 0) {\n\t\ttypes = USTYPE_PROJ;\n\t\tprtnum = B_TRUE;\n\t}\n\n\twhile ((c = getopt(argc, argv, \"nHpo:s:S:t:i\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tif (types == USTYPE_PROJ) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option 'n'\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tprtnum = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tscripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparsable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tofield = optarg;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (zfs_add_sort_column(&sortcol, optarg,\n\t\t\t    c == 's' ? B_FALSE : B_TRUE) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid field '%s'\\n\"), optarg);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (types == USTYPE_PROJ) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option 't'\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\ttfield = optarg;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (types == USTYPE_PROJ) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option 'i'\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tsid2posix = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing dataset name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tif (ofield == NULL)\n\t\tofield = deffields;\n\tdo {\n\t\tif ((delim = strchr(ofield, ',')) != NULL)\n\t\t\t*delim = '\\0';\n\t\tif ((fields[cfield++] = us_field_index(ofield)) == -1) {\n\t\t\t(void) fprintf(stderr, gettext(\"invalid type '%s' \"\n\t\t\t    \"for -o option\\n\"), ofield);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (delim != NULL)\n\t\t\tofield = delim + 1;\n\t} while (delim != NULL);\n\tfields[cfield] = USFIELD_LAST;\n\n\t \n\tif (tfield != NULL) {\n\t\ttypes = 0;\n\n\t\tdo {\n\t\t\tboolean_t found = B_FALSE;\n\n\t\t\tif ((delim = strchr(tfield, ',')) != NULL)\n\t\t\t\t*delim = '\\0';\n\t\t\tfor (i = 0; i < sizeof (us_type_bits) / sizeof (int);\n\t\t\t    i++) {\n\t\t\t\tif (strcmp(tfield, us_type_names[i]) == 0) {\n\t\t\t\t\tfound = B_TRUE;\n\t\t\t\t\ttypes |= us_type_bits[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"invalid type \"\n\t\t\t\t    \"'%s' for -t option\\n\"), tfield);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (delim != NULL)\n\t\t\t\ttfield = delim + 1;\n\t\t} while (delim != NULL);\n\t}\n\n\tif ((zhp = zfs_path_to_zhandle(g_zfs, argv[0], ZFS_TYPE_FILESYSTEM |\n\t    ZFS_TYPE_SNAPSHOT)) == NULL)\n\t\treturn (1);\n\tif (zfs_get_underlying_type(zhp) != ZFS_TYPE_FILESYSTEM) {\n\t\t(void) fprintf(stderr, gettext(\"operation is only applicable \"\n\t\t    \"to filesystems and their snapshots\\n\"));\n\t\tzfs_close(zhp);\n\t\treturn (1);\n\t}\n\n\tif ((avl_pool = uu_avl_pool_create(\"us_avl_pool\", sizeof (us_node_t),\n\t    offsetof(us_node_t, usn_avlnode), us_compare, UU_DEFAULT)) == NULL)\n\t\tnomem();\n\tif ((avl_tree = uu_avl_create(avl_pool, NULL, UU_DEFAULT)) == NULL)\n\t\tnomem();\n\n\t \n\t(void) zfs_add_sort_column(&sortcol, \"type\", B_FALSE);\n\t(void) zfs_add_sort_column(&sortcol, \"name\", B_FALSE);\n\n\tcb.cb_sortcol = sortcol;\n\tcb.cb_numname = prtnum;\n\tcb.cb_nicenum = !parsable;\n\tcb.cb_avl_pool = avl_pool;\n\tcb.cb_avl = avl_tree;\n\tcb.cb_sid2posix = sid2posix;\n\n\tfor (i = 0; i < USFIELD_LAST; i++)\n\t\tcb.cb_width[i] = strlen(gettext(us_field_hdr[i]));\n\n\tfor (p = 0; p < ZFS_NUM_USERQUOTA_PROPS; p++) {\n\t\tif ((zfs_prop_is_user(p) &&\n\t\t    !(types & (USTYPE_PSX_USR | USTYPE_SMB_USR))) ||\n\t\t    (zfs_prop_is_group(p) &&\n\t\t    !(types & (USTYPE_PSX_GRP | USTYPE_SMB_GRP))) ||\n\t\t    (zfs_prop_is_project(p) && types != USTYPE_PROJ))\n\t\t\tcontinue;\n\n\t\tcb.cb_prop = p;\n\t\tif ((ret = zfs_userspace(zhp, p, userspace_cb, &cb)) != 0) {\n\t\t\tzfs_close(zhp);\n\t\t\treturn (ret);\n\t\t}\n\t}\n\tzfs_close(zhp);\n\n\t \n\tif ((node = uu_avl_first(avl_tree)) == NULL)\n\t\treturn (0);\n\n\tus_populated = B_TRUE;\n\n\tlistpool = uu_list_pool_create(\"tmplist\", sizeof (us_node_t),\n\t    offsetof(us_node_t, usn_listnode), NULL, UU_DEFAULT);\n\tlist = uu_list_create(listpool, NULL, UU_DEFAULT);\n\tuu_list_node_init(node, &node->usn_listnode, listpool);\n\n\twhile (node != NULL) {\n\t\trmnode = node;\n\t\tnode = uu_avl_next(avl_tree, node);\n\t\tuu_avl_remove(avl_tree, rmnode);\n\t\tif (uu_list_find(list, rmnode, NULL, &idx2) == NULL)\n\t\t\tuu_list_insert(list, rmnode, idx2);\n\t}\n\n\tfor (node = uu_list_first(list); node != NULL;\n\t    node = uu_list_next(list, node)) {\n\t\tus_sort_info_t sortinfo = { sortcol, cb.cb_numname };\n\n\t\tif (uu_avl_find(avl_tree, node, &sortinfo, &idx) == NULL)\n\t\t\tuu_avl_insert(avl_tree, node, idx);\n\t}\n\n\tuu_list_destroy(list);\n\tuu_list_pool_destroy(listpool);\n\n\t \n\tprint_us(scripted, parsable, fields, types, cb.cb_width, B_TRUE,\n\t    cb.cb_avl);\n\n\tzfs_free_sort_columns(sortcol);\n\n\t \n\tif ((walk = uu_avl_walk_start(cb.cb_avl, UU_WALK_ROBUST)) == NULL)\n\t\tnomem();\n\n\twhile ((node = uu_avl_walk_next(walk)) != NULL) {\n\t\tuu_avl_remove(cb.cb_avl, node);\n\t\tfree(node);\n\t}\n\n\tuu_avl_walk_end(walk);\n\tuu_avl_destroy(avl_tree);\n\tuu_avl_pool_destroy(avl_pool);\n\n\treturn (ret);\n}\n\n \ntypedef struct list_cbdata {\n\tboolean_t\tcb_first;\n\tboolean_t\tcb_literal;\n\tboolean_t\tcb_scripted;\n\tzprop_list_t\t*cb_proplist;\n} list_cbdata_t;\n\n \nstatic void\nprint_header(list_cbdata_t *cb)\n{\n\tzprop_list_t *pl = cb->cb_proplist;\n\tchar headerbuf[ZFS_MAXPROPLEN];\n\tconst char *header;\n\tint i;\n\tboolean_t first = B_TRUE;\n\tboolean_t right_justify;\n\n\tcolor_start(ANSI_BOLD);\n\n\tfor (; pl != NULL; pl = pl->pl_next) {\n\t\tif (!first) {\n\t\t\t(void) printf(\"  \");\n\t\t} else {\n\t\t\tfirst = B_FALSE;\n\t\t}\n\n\t\tright_justify = B_FALSE;\n\t\tif (pl->pl_prop != ZPROP_USERPROP) {\n\t\t\theader = zfs_prop_column_name(pl->pl_prop);\n\t\t\tright_justify = zfs_prop_align_right(pl->pl_prop);\n\t\t} else {\n\t\t\tfor (i = 0; pl->pl_user_prop[i] != '\\0'; i++)\n\t\t\t\theaderbuf[i] = toupper(pl->pl_user_prop[i]);\n\t\t\theaderbuf[i] = '\\0';\n\t\t\theader = headerbuf;\n\t\t}\n\n\t\tif (pl->pl_next == NULL && !right_justify)\n\t\t\t(void) printf(\"%s\", header);\n\t\telse if (right_justify)\n\t\t\t(void) printf(\"%*s\", (int)pl->pl_width, header);\n\t\telse\n\t\t\t(void) printf(\"%-*s\", (int)pl->pl_width, header);\n\t}\n\n\tcolor_end();\n\n\t(void) printf(\"\\n\");\n}\n\n \nstatic const char *\nzfs_list_avail_color(zfs_handle_t *zhp)\n{\n\tuint64_t used = zfs_prop_get_int(zhp, ZFS_PROP_USED);\n\tuint64_t avail = zfs_prop_get_int(zhp, ZFS_PROP_AVAILABLE);\n\tint percentage = (int)((double)avail / MAX(avail + used, 1) * 100);\n\n\tif (percentage > 20)\n\t\treturn (NULL);\n\telse if (percentage > 10)\n\t\treturn (ANSI_YELLOW);\n\telse\n\t\treturn (ANSI_RED);\n}\n\n \nstatic void\nprint_dataset(zfs_handle_t *zhp, list_cbdata_t *cb)\n{\n\tzprop_list_t *pl = cb->cb_proplist;\n\tboolean_t first = B_TRUE;\n\tchar property[ZFS_MAXPROPLEN];\n\tnvlist_t *userprops = zfs_get_user_props(zhp);\n\tnvlist_t *propval;\n\tconst char *propstr;\n\tboolean_t right_justify;\n\n\tfor (; pl != NULL; pl = pl->pl_next) {\n\t\tif (!first) {\n\t\t\tif (cb->cb_scripted)\n\t\t\t\t(void) putchar('\\t');\n\t\t\telse\n\t\t\t\t(void) fputs(\"  \", stdout);\n\t\t} else {\n\t\t\tfirst = B_FALSE;\n\t\t}\n\n\t\tif (pl->pl_prop == ZFS_PROP_NAME) {\n\t\t\t(void) strlcpy(property, zfs_get_name(zhp),\n\t\t\t    sizeof (property));\n\t\t\tpropstr = property;\n\t\t\tright_justify = zfs_prop_align_right(pl->pl_prop);\n\t\t} else if (pl->pl_prop != ZPROP_USERPROP) {\n\t\t\tif (zfs_prop_get(zhp, pl->pl_prop, property,\n\t\t\t    sizeof (property), NULL, NULL, 0,\n\t\t\t    cb->cb_literal) != 0)\n\t\t\t\tpropstr = \"-\";\n\t\t\telse\n\t\t\t\tpropstr = property;\n\t\t\tright_justify = zfs_prop_align_right(pl->pl_prop);\n\t\t} else if (zfs_prop_userquota(pl->pl_user_prop)) {\n\t\t\tif (zfs_prop_get_userquota(zhp, pl->pl_user_prop,\n\t\t\t    property, sizeof (property), cb->cb_literal) != 0)\n\t\t\t\tpropstr = \"-\";\n\t\t\telse\n\t\t\t\tpropstr = property;\n\t\t\tright_justify = B_TRUE;\n\t\t} else if (zfs_prop_written(pl->pl_user_prop)) {\n\t\t\tif (zfs_prop_get_written(zhp, pl->pl_user_prop,\n\t\t\t    property, sizeof (property), cb->cb_literal) != 0)\n\t\t\t\tpropstr = \"-\";\n\t\t\telse\n\t\t\t\tpropstr = property;\n\t\t\tright_justify = B_TRUE;\n\t\t} else {\n\t\t\tif (nvlist_lookup_nvlist(userprops,\n\t\t\t    pl->pl_user_prop, &propval) != 0)\n\t\t\t\tpropstr = \"-\";\n\t\t\telse\n\t\t\t\tpropstr = fnvlist_lookup_string(propval,\n\t\t\t\t    ZPROP_VALUE);\n\t\t\tright_justify = B_FALSE;\n\t\t}\n\n\t\t \n\t\tif (use_color() && pl->pl_prop == ZFS_PROP_AVAILABLE) {\n\t\t\tzprop_list_t *pl2 = cb->cb_proplist;\n\t\t\tfor (; pl2 != NULL; pl2 = pl2->pl_next) {\n\t\t\t\tif (pl2->pl_prop == ZFS_PROP_USED) {\n\t\t\t\t\tcolor_start(zfs_list_avail_color(zhp));\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (cb->cb_scripted || (pl->pl_next == NULL && !right_justify))\n\t\t\t(void) fputs(propstr, stdout);\n\t\telse if (right_justify)\n\t\t\t(void) printf(\"%*s\", (int)pl->pl_width, propstr);\n\t\telse\n\t\t\t(void) printf(\"%-*s\", (int)pl->pl_width, propstr);\n\n\t\tif (pl->pl_prop == ZFS_PROP_AVAILABLE)\n\t\t\tcolor_end();\n\t}\n\n\t(void) putchar('\\n');\n}\n\n \nstatic int\nlist_callback(zfs_handle_t *zhp, void *data)\n{\n\tlist_cbdata_t *cbp = data;\n\n\tif (cbp->cb_first) {\n\t\tif (!cbp->cb_scripted)\n\t\t\tprint_header(cbp);\n\t\tcbp->cb_first = B_FALSE;\n\t}\n\n\tprint_dataset(zhp, cbp);\n\n\treturn (0);\n}\n\nstatic int\nzfs_do_list(int argc, char **argv)\n{\n\tint c;\n\tchar default_fields[] =\n\t    \"name,used,available,referenced,mountpoint\";\n\tint types = ZFS_TYPE_DATASET;\n\tboolean_t types_specified = B_FALSE;\n\tchar *fields = default_fields;\n\tlist_cbdata_t cb = { 0 };\n\tint limit = 0;\n\tint ret = 0;\n\tzfs_sort_column_t *sortcol = NULL;\n\tint flags = ZFS_ITER_PROP_LISTSNAPS | ZFS_ITER_ARGS_CAN_BE_PATHS;\n\n\t \n\twhile ((c = getopt(argc, argv, \"HS:d:o:prs:t:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'o':\n\t\t\tfields = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tcb.cb_literal = B_TRUE;\n\t\t\tflags |= ZFS_ITER_LITERAL_PROPS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tlimit = parse_depth(optarg, &flags);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags |= ZFS_ITER_RECURSE;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tcb.cb_scripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (zfs_add_sort_column(&sortcol, optarg,\n\t\t\t    B_FALSE) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid property '%s'\\n\"), optarg);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (zfs_add_sort_column(&sortcol, optarg,\n\t\t\t    B_TRUE) != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid property '%s'\\n\"), optarg);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = 0;\n\t\t\ttypes_specified = B_TRUE;\n\t\t\tflags &= ~ZFS_ITER_PROP_LISTSNAPS;\n\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const type_subopts[] = {\n\t\t\t\t\t\"filesystem\", \"volume\",\n\t\t\t\t\t\"snapshot\", \"snap\",\n\t\t\t\t\t\"bookmark\",\n\t\t\t\t\t\"all\" };\n\t\t\t\tstatic const int type_types[] = {\n\t\t\t\t\tZFS_TYPE_FILESYSTEM, ZFS_TYPE_VOLUME,\n\t\t\t\t\tZFS_TYPE_SNAPSHOT, ZFS_TYPE_SNAPSHOT,\n\t\t\t\t\tZFS_TYPE_BOOKMARK,\n\t\t\t\t\tZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK };\n\n\t\t\t\tfor (c = 0; c < ARRAY_SIZE(type_subopts); ++c)\n\t\t\t\t\tif (strcmp(tok, type_subopts[c]) == 0) {\n\t\t\t\t\t\ttypes |= type_types[c];\n\t\t\t\t\t\tgoto found3;\n\t\t\t\t\t}\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid type '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\nfound3:;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (strcmp(fields, \"space\") == 0 && types_specified == B_FALSE)\n\t\ttypes &= ~ZFS_TYPE_SNAPSHOT;\n\n\t \n\tif ((types == ZFS_TYPE_SNAPSHOT || types == ZFS_TYPE_BOOKMARK) &&\n\t    argc > 0 && (flags & ZFS_ITER_RECURSE) == 0 && limit == 0) {\n\t\tflags |= (ZFS_ITER_DEPTH_LIMIT | ZFS_ITER_RECURSE);\n\t\tlimit = 1;\n\t}\n\n\t \n\tif (zprop_get_list(g_zfs, fields, &cb.cb_proplist, ZFS_TYPE_DATASET)\n\t    != 0)\n\t\tusage(B_FALSE);\n\n\tcb.cb_first = B_TRUE;\n\n\t \n\tif (zfs_list_only_by_fast(cb.cb_proplist) &&\n\t    zfs_sort_only_by_fast(sortcol))\n\t\tflags |= ZFS_ITER_SIMPLE;\n\n\tret = zfs_for_each(argc, argv, flags, types, sortcol, &cb.cb_proplist,\n\t    limit, list_callback, &cb);\n\n\tzprop_free_list(cb.cb_proplist);\n\tzfs_free_sort_columns(sortcol);\n\n\tif (ret == 0 && cb.cb_first && !cb.cb_scripted)\n\t\t(void) fprintf(stderr, gettext(\"no datasets available\\n\"));\n\n\treturn (ret);\n}\n\n \nstatic int\nzfs_do_rename(int argc, char **argv)\n{\n\tzfs_handle_t *zhp;\n\trenameflags_t flags = { 0 };\n\tint c;\n\tint ret = 0;\n\tint types;\n\tboolean_t parents = B_FALSE;\n\n\t \n\twhile ((c = getopt(argc, argv, \"pruf\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'p':\n\t\t\tparents = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags.recursive = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags.nounmount = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags.forceunmount = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing source dataset \"\n\t\t    \"argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing target dataset \"\n\t\t    \"argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 2) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (flags.recursive && parents) {\n\t\t(void) fprintf(stderr, gettext(\"-p and -r options are mutually \"\n\t\t    \"exclusive\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (flags.nounmount && parents) {\n\t\t(void) fprintf(stderr, gettext(\"-u and -p options are mutually \"\n\t\t    \"exclusive\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (flags.recursive && strchr(argv[0], '@') == 0) {\n\t\t(void) fprintf(stderr, gettext(\"source dataset for recursive \"\n\t\t    \"rename must be a snapshot\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (flags.nounmount)\n\t\ttypes = ZFS_TYPE_FILESYSTEM;\n\telse if (parents)\n\t\ttypes = ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME;\n\telse\n\t\ttypes = ZFS_TYPE_DATASET;\n\n\tif ((zhp = zfs_open(g_zfs, argv[0], types)) == NULL)\n\t\treturn (1);\n\n\t \n\tif (parents && zfs_name_valid(argv[1], zfs_get_type(zhp)) &&\n\t    zfs_create_ancestors(g_zfs, argv[1]) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (1);\n\t}\n\n\tret = (zfs_rename(zhp, argv[1], flags) != 0);\n\n\tzfs_close(zhp);\n\treturn (ret);\n}\n\n \nstatic int\nzfs_do_promote(int argc, char **argv)\n{\n\tzfs_handle_t *zhp;\n\tint ret = 0;\n\n\t \n\tif (argc > 1 && argv[1][0] == '-') {\n\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t    argv[1][1]);\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing clone filesystem\"\n\t\t    \" argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 2) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tzhp = zfs_open(g_zfs, argv[1], ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\tif (zhp == NULL)\n\t\treturn (1);\n\n\tret = (zfs_promote(zhp) != 0);\n\n\n\tzfs_close(zhp);\n\treturn (ret);\n}\n\nstatic int\nzfs_do_redact(int argc, char **argv)\n{\n\tchar *snap = NULL;\n\tchar *bookname = NULL;\n\tchar **rsnaps = NULL;\n\tint numrsnaps = 0;\n\targv++;\n\targc--;\n\tif (argc < 3) {\n\t\t(void) fprintf(stderr, gettext(\"too few arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tsnap = argv[0];\n\tbookname = argv[1];\n\trsnaps = argv + 2;\n\tnumrsnaps = argc - 2;\n\n\tnvlist_t *rsnapnv = fnvlist_alloc();\n\n\tfor (int i = 0; i < numrsnaps; i++) {\n\t\tfnvlist_add_boolean(rsnapnv, rsnaps[i]);\n\t}\n\n\tint err = lzc_redact(snap, bookname, rsnapnv);\n\tfnvlist_free(rsnapnv);\n\n\tswitch (err) {\n\tcase 0:\n\t\tbreak;\n\tcase ENOENT: {\n\t\tzfs_handle_t *zhp = zfs_open(g_zfs, snap, ZFS_TYPE_SNAPSHOT);\n\t\tif (zhp == NULL) {\n\t\t\t(void) fprintf(stderr, gettext(\"provided snapshot %s \"\n\t\t\t    \"does not exist\\n\"), snap);\n\t\t} else {\n\t\t\tzfs_close(zhp);\n\t\t}\n\t\tfor (int i = 0; i < numrsnaps; i++) {\n\t\t\tzhp = zfs_open(g_zfs, rsnaps[i], ZFS_TYPE_SNAPSHOT);\n\t\t\tif (zhp == NULL) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"provided \"\n\t\t\t\t    \"snapshot %s does not exist\\n\"), rsnaps[i]);\n\t\t\t} else {\n\t\t\t\tzfs_close(zhp);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase EEXIST:\n\t\t(void) fprintf(stderr, gettext(\"specified redaction bookmark \"\n\t\t    \"(%s) provided already exists\\n\"), bookname);\n\t\tbreak;\n\tcase ENAMETOOLONG:\n\t\t(void) fprintf(stderr, gettext(\"provided bookmark name cannot \"\n\t\t    \"be used, final name would be too long\\n\"));\n\t\tbreak;\n\tcase E2BIG:\n\t\t(void) fprintf(stderr, gettext(\"too many redaction snapshots \"\n\t\t    \"specified\\n\"));\n\t\tbreak;\n\tcase EINVAL:\n\t\tif (strchr(bookname, '#') != NULL)\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"redaction bookmark name must not contain '#'\\n\"));\n\t\telse\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"redaction snapshot must be descendent of \"\n\t\t\t    \"snapshot being redacted\\n\"));\n\t\tbreak;\n\tcase EALREADY:\n\t\t(void) fprintf(stderr, gettext(\"attempted to redact redacted \"\n\t\t    \"dataset or with respect to redacted dataset\\n\"));\n\t\tbreak;\n\tcase ENOTSUP:\n\t\t(void) fprintf(stderr, gettext(\"redaction bookmarks feature \"\n\t\t    \"not enabled\\n\"));\n\t\tbreak;\n\tcase EXDEV:\n\t\t(void) fprintf(stderr, gettext(\"potentially invalid redaction \"\n\t\t    \"snapshot; full dataset names required\\n\"));\n\t\tbreak;\n\tdefault:\n\t\t(void) fprintf(stderr, gettext(\"internal error: %s\\n\"),\n\t\t    strerror(errno));\n\t}\n\n\treturn (err);\n}\n\n \ntypedef struct rollback_cbdata {\n\tuint64_t\tcb_create;\n\tuint8_t\t\tcb_younger_ds_printed;\n\tboolean_t\tcb_first;\n\tint\t\tcb_doclones;\n\tchar\t\t*cb_target;\n\tint\t\tcb_error;\n\tboolean_t\tcb_recurse;\n} rollback_cbdata_t;\n\nstatic int\nrollback_check_dependent(zfs_handle_t *zhp, void *data)\n{\n\trollback_cbdata_t *cbp = data;\n\n\tif (cbp->cb_first && cbp->cb_recurse) {\n\t\t(void) fprintf(stderr, gettext(\"cannot rollback to \"\n\t\t    \"'%s': clones of previous snapshots exist\\n\"),\n\t\t    cbp->cb_target);\n\t\t(void) fprintf(stderr, gettext(\"use '-R' to \"\n\t\t    \"force deletion of the following clones and \"\n\t\t    \"dependents:\\n\"));\n\t\tcbp->cb_first = 0;\n\t\tcbp->cb_error = 1;\n\t}\n\n\t(void) fprintf(stderr, \"%s\\n\", zfs_get_name(zhp));\n\n\tzfs_close(zhp);\n\treturn (0);\n}\n\n\n \nstatic int\nrollback_check(zfs_handle_t *zhp, void *data)\n{\n\trollback_cbdata_t *cbp = data;\n\t \n\tconst uint8_t max_younger = 32;\n\n\tif (cbp->cb_doclones) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_CREATETXG) > cbp->cb_create) {\n\t\tif (cbp->cb_first && !cbp->cb_recurse) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t    \"rollback to '%s': more recent snapshots \"\n\t\t\t    \"or bookmarks exist\\n\"),\n\t\t\t    cbp->cb_target);\n\t\t\t(void) fprintf(stderr, gettext(\"use '-r' to \"\n\t\t\t    \"force deletion of the following \"\n\t\t\t    \"snapshots and bookmarks:\\n\"));\n\t\t\tcbp->cb_first = 0;\n\t\t\tcbp->cb_error = 1;\n\t\t}\n\n\t\tif (cbp->cb_recurse) {\n\t\t\tif (zfs_iter_dependents_v2(zhp, 0, B_TRUE,\n\t\t\t    rollback_check_dependent, cbp) != 0) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t(void) fprintf(stderr, \"%s\\n\",\n\t\t\t    zfs_get_name(zhp));\n\t\t\tcbp->cb_younger_ds_printed++;\n\t\t}\n\t}\n\tzfs_close(zhp);\n\n\tif (cbp->cb_younger_ds_printed == max_younger) {\n\t\t \n\t\t(void) fprintf(stderr, gettext(\"Output limited to %d \"\n\t\t    \"snapshots/bookmarks\\n\"), max_younger);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_do_rollback(int argc, char **argv)\n{\n\tint ret = 0;\n\tint c;\n\tboolean_t force = B_FALSE;\n\trollback_cbdata_t cb = { 0 };\n\tzfs_handle_t *zhp, *snap;\n\tchar parentname[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *delim;\n\tuint64_t min_txg = 0;\n\n\t \n\twhile ((c = getopt(argc, argv, \"rRf\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\tcb.cb_recurse = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tcb.cb_recurse = 1;\n\t\t\tcb.cb_doclones = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tforce = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing dataset argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tif ((snap = zfs_open(g_zfs, argv[0], ZFS_TYPE_SNAPSHOT)) == NULL)\n\t\treturn (1);\n\n\t \n\t(void) strlcpy(parentname, argv[0], sizeof (parentname));\n\tverify((delim = strrchr(parentname, '@')) != NULL);\n\t*delim = '\\0';\n\tif ((zhp = zfs_open(g_zfs, parentname, ZFS_TYPE_DATASET)) == NULL) {\n\t\tzfs_close(snap);\n\t\treturn (1);\n\t}\n\n\t \n\tcb.cb_target = argv[0];\n\tcb.cb_create = zfs_prop_get_int(snap, ZFS_PROP_CREATETXG);\n\tcb.cb_first = B_TRUE;\n\tcb.cb_error = 0;\n\n\tif (cb.cb_create > 0)\n\t\tmin_txg = cb.cb_create;\n\n\tif ((ret = zfs_iter_snapshots_v2(zhp, 0, rollback_check, &cb,\n\t    min_txg, 0)) != 0)\n\t\tgoto out;\n\tif ((ret = zfs_iter_bookmarks_v2(zhp, 0, rollback_check, &cb)) != 0)\n\t\tgoto out;\n\n\tif ((ret = cb.cb_error) != 0)\n\t\tgoto out;\n\n\t \n\tret = zfs_rollback(zhp, snap, force);\n\nout:\n\tzfs_close(snap);\n\tzfs_close(zhp);\n\n\tif (ret == 0)\n\t\treturn (0);\n\telse\n\t\treturn (1);\n}\n\n \n\nstatic int\nset_callback(zfs_handle_t *zhp, void *data)\n{\n\tzprop_set_cbdata_t *cb = data;\n\tint ret = zfs_prop_set_list_flags(zhp, cb->cb_proplist, cb->cb_flags);\n\n\tif (ret != 0 || libzfs_errno(g_zfs) != EZFS_SUCCESS) {\n\t\tswitch (libzfs_errno(g_zfs)) {\n\t\tcase EZFS_MOUNTFAILED:\n\t\t\t(void) fprintf(stderr, gettext(\"property may be set \"\n\t\t\t    \"but unable to remount filesystem\\n\"));\n\t\t\tbreak;\n\t\tcase EZFS_SHARENFSFAILED:\n\t\t\t(void) fprintf(stderr, gettext(\"property may be set \"\n\t\t\t    \"but unable to reshare filesystem\\n\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (ret);\n}\n\nstatic int\nzfs_do_set(int argc, char **argv)\n{\n\tzprop_set_cbdata_t cb = { 0 };\n\tint ds_start = -1;  \n\tint ret = 0;\n\tint i, c;\n\n\t \n\twhile ((c = getopt(argc, argv, \"u\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'u':\n\t\t\tcb.cb_flags |= ZFS_SET_NOMOUNT;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc < 2) {\n\t\tif (strchr(argv[0], '=') == NULL) {\n\t\t\t(void) fprintf(stderr, gettext(\"missing property=value \"\n\t\t\t    \"argument(s)\\n\"));\n\t\t} else {\n\t\t\t(void) fprintf(stderr, gettext(\"missing dataset \"\n\t\t\t    \"name(s)\\n\"));\n\t\t}\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tfor (i = 0; i < argc; i++) {\n\t\tif (strchr(argv[i], '=') != NULL) {\n\t\t\tif (ds_start > 0) {\n\t\t\t\t \n\t\t\t\t(void) fprintf(stderr, gettext(\"invalid \"\n\t\t\t\t    \"argument order\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t} else if (ds_start < 0) {\n\t\t\tds_start = i;\n\t\t}\n\t}\n\tif (ds_start < 0) {\n\t\t(void) fprintf(stderr, gettext(\"missing dataset name(s)\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tif (nvlist_alloc(&cb.cb_proplist, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\tfor (i = 0; i < ds_start; i++) {\n\t\tif (!parseprop(cb.cb_proplist, argv[i])) {\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = zfs_for_each(argc - ds_start, argv + ds_start, 0,\n\t    ZFS_TYPE_DATASET, NULL, NULL, 0, set_callback, &cb);\n\nerror:\n\tnvlist_free(cb.cb_proplist);\n\treturn (ret);\n}\n\ntypedef struct snap_cbdata {\n\tnvlist_t *sd_nvl;\n\tboolean_t sd_recursive;\n\tconst char *sd_snapname;\n} snap_cbdata_t;\n\nstatic int\nzfs_snapshot_cb(zfs_handle_t *zhp, void *arg)\n{\n\tsnap_cbdata_t *sd = arg;\n\tchar *name;\n\tint rv = 0;\n\tint error;\n\n\tif (sd->sd_recursive &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\n\terror = asprintf(&name, \"%s@%s\", zfs_get_name(zhp), sd->sd_snapname);\n\tif (error == -1)\n\t\tnomem();\n\tfnvlist_add_boolean(sd->sd_nvl, name);\n\tfree(name);\n\n\tif (sd->sd_recursive)\n\t\trv = zfs_iter_filesystems_v2(zhp, 0, zfs_snapshot_cb, sd);\n\tzfs_close(zhp);\n\treturn (rv);\n}\n\n \nstatic int\nzfs_do_snapshot(int argc, char **argv)\n{\n\tint ret = 0;\n\tint c;\n\tnvlist_t *props;\n\tsnap_cbdata_t sd = { 0 };\n\tboolean_t multiple_snaps = B_FALSE;\n\n\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\tif (nvlist_alloc(&sd.sd_nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\n\t \n\twhile ((c = getopt(argc, argv, \"ro:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'o':\n\t\t\tif (!parseprop(props, optarg)) {\n\t\t\t\tnvlist_free(sd.sd_nvl);\n\t\t\t\tnvlist_free(props);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tsd.sd_recursive = B_TRUE;\n\t\t\tmultiple_snaps = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tgoto usage;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing snapshot argument\\n\"));\n\t\tgoto usage;\n\t}\n\n\tif (argc > 1)\n\t\tmultiple_snaps = B_TRUE;\n\tfor (; argc > 0; argc--, argv++) {\n\t\tchar *atp;\n\t\tzfs_handle_t *zhp;\n\n\t\tatp = strchr(argv[0], '@');\n\t\tif (atp == NULL)\n\t\t\tgoto usage;\n\t\t*atp = '\\0';\n\t\tsd.sd_snapname = atp + 1;\n\t\tzhp = zfs_open(g_zfs, argv[0],\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\tif (zhp == NULL)\n\t\t\tgoto usage;\n\t\tif (zfs_snapshot_cb(zhp, &sd) != 0)\n\t\t\tgoto usage;\n\t}\n\n\tret = zfs_snapshot_nvl(g_zfs, sd.sd_nvl, props);\n\tnvlist_free(sd.sd_nvl);\n\tnvlist_free(props);\n\tif (ret != 0 && multiple_snaps)\n\t\t(void) fprintf(stderr, gettext(\"no snapshots were created\\n\"));\n\treturn (ret != 0);\n\nusage:\n\tnvlist_free(sd.sd_nvl);\n\tnvlist_free(props);\n\tusage(B_FALSE);\n\treturn (-1);\n}\n\n \ntypedef struct zfs_send_exclude_arg {\n\tsize_t count;\n\tconst char **list;\n} zfs_send_exclude_arg_t;\n\nstatic boolean_t\nzfs_do_send_exclude(zfs_handle_t *zhp, void *context)\n{\n\tzfs_send_exclude_arg_t *excludes = context;\n\tconst char *name = zfs_get_name(zhp);\n\n\tfor (size_t i = 0; i < excludes->count; ++i) {\n\t\tsize_t len = strlen(excludes->list[i]);\n\t\tif (strncmp(name, excludes->list[i], len) == 0 &&\n\t\t    memchr(\"/@\", name[len], sizeof (\"/@\")))\n\t\t\treturn (B_FALSE);\n\t}\n\n\treturn (B_TRUE);\n}\n\n \nstatic int\nzfs_do_send(int argc, char **argv)\n{\n\tchar *fromname = NULL;\n\tchar *toname = NULL;\n\tchar *resume_token = NULL;\n\tchar *cp;\n\tzfs_handle_t *zhp;\n\tsendflags_t flags = { 0 };\n\tint c, err;\n\tnvlist_t *dbgnv = NULL;\n\tchar *redactbook = NULL;\n\tzfs_send_exclude_arg_t excludes = { 0 };\n\n\tstruct option long_options[] = {\n\t\t{\"replicate\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"skip-missing\",\tno_argument,\tNULL, 's'},\n\t\t{\"redact\",\trequired_argument,\tNULL, 'd'},\n\t\t{\"props\",\tno_argument,\t\tNULL, 'p'},\n\t\t{\"parsable\",\tno_argument,\t\tNULL, 'P'},\n\t\t{\"dedup\",\tno_argument,\t\tNULL, 'D'},\n\t\t{\"proctitle\",\tno_argument,\t\tNULL, 'V'},\n\t\t{\"verbose\",\tno_argument,\t\tNULL, 'v'},\n\t\t{\"dryrun\",\tno_argument,\t\tNULL, 'n'},\n\t\t{\"large-block\",\tno_argument,\t\tNULL, 'L'},\n\t\t{\"embed\",\tno_argument,\t\tNULL, 'e'},\n\t\t{\"resume\",\trequired_argument,\tNULL, 't'},\n\t\t{\"compressed\",\tno_argument,\t\tNULL, 'c'},\n\t\t{\"raw\",\t\tno_argument,\t\tNULL, 'w'},\n\t\t{\"backup\",\tno_argument,\t\tNULL, 'b'},\n\t\t{\"holds\",\tno_argument,\t\tNULL, 'h'},\n\t\t{\"saved\",\tno_argument,\t\tNULL, 'S'},\n\t\t{\"exclude\",\trequired_argument,\tNULL, 'X'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\t \n\twhile ((c = getopt_long(argc, argv, \":i:I:RsDpVvnPLeht:cwbd:SX:\",\n\t    long_options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'X':\n\t\t\tfor (char *ds; (ds = strsep(&optarg, \",\")) != NULL; ) {\n\t\t\t\tif (!zfs_name_valid(ds, ZFS_TYPE_DATASET) ||\n\t\t\t\t    strchr(ds, '/') == NULL) {\n\t\t\t\t\t(void) fprintf(stderr, gettext(\"-X %s: \"\n\t\t\t\t\t    \"not a valid non-root dataset name\"\n\t\t\t\t\t    \".\\n\"), ds);\n\t\t\t\t\tusage(B_FALSE);\n\t\t\t\t}\n\t\t\t\texcludes.list = safe_realloc(excludes.list,\n\t\t\t\t    sizeof (char *) * (excludes.count + 1));\n\t\t\t\texcludes.list[excludes.count++] = ds;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tif (fromname)\n\t\t\t\tusage(B_FALSE);\n\t\t\tfromname = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tif (fromname)\n\t\t\t\tusage(B_FALSE);\n\t\t\tfromname = optarg;\n\t\t\tflags.doall = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags.replicate = B_TRUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tflags.skipmissing = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tredactbook = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tflags.props = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tflags.backup = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tflags.holds = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags.parsable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tflags.progressastitle = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags.verbosity++;\n\t\t\tflags.progress = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"WARNING: deduplicated send is no \"\n\t\t\t    \"longer supported.  A regular,\\n\"\n\t\t\t    \"non-deduplicated stream will be generated.\\n\\n\"));\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags.dryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tflags.largeblock = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tflags.embed_data = B_TRUE;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tresume_token = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags.compress = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tflags.raw = B_TRUE;\n\t\t\tflags.compress = B_TRUE;\n\t\t\tflags.embed_data = B_TRUE;\n\t\t\tflags.largeblock = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tflags.saved = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t \n\t\t\tif (optopt <= UINT8_MAX) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"missing argument for '%c' \"\n\t\t\t\t    \"option\\n\"), optopt);\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"missing argument for '%s' \"\n\t\t\t\t    \"option\\n\"), argv[optind - 1]);\n\t\t\t}\n\t\t\tfree(excludes.list);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\t \n\t\t\tif (optopt != 0) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\t} else {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid option '%s'\\n\"),\n\t\t\t\t    argv[optind - 1]);\n\n\t\t\t}\n\t\t\tfree(excludes.list);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif ((flags.parsable || flags.progressastitle) && flags.verbosity == 0)\n\t\tflags.verbosity = 1;\n\n\tif (excludes.count > 0 && !flags.replicate) {\n\t\tfree(excludes.list);\n\t\t(void) fprintf(stderr, gettext(\"Cannot specify \"\n\t\t    \"dataset exclusion (-X) on a non-recursive \"\n\t\t    \"send.\\n\"));\n\t\treturn (1);\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (resume_token != NULL) {\n\t\tif (fromname != NULL || flags.replicate || flags.props ||\n\t\t    flags.backup || flags.holds ||\n\t\t    flags.saved || redactbook != NULL) {\n\t\t\tfree(excludes.list);\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"invalid flags combined with -t\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (argc > 0) {\n\t\t\tfree(excludes.list);\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t} else {\n\t\tif (argc < 1) {\n\t\t\tfree(excludes.list);\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"missing snapshot argument\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (argc > 1) {\n\t\t\tfree(excludes.list);\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (flags.saved) {\n\t\tif (fromname != NULL || flags.replicate || flags.props ||\n\t\t    flags.doall || flags.backup ||\n\t\t    flags.holds || flags.largeblock || flags.embed_data ||\n\t\t    flags.compress || flags.raw || redactbook != NULL) {\n\t\t\tfree(excludes.list);\n\n\t\t\t(void) fprintf(stderr, gettext(\"incompatible flags \"\n\t\t\t    \"combined with saved send flag\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (strchr(argv[0], '@') != NULL) {\n\t\t\tfree(excludes.list);\n\n\t\t\t(void) fprintf(stderr, gettext(\"saved send must \"\n\t\t\t    \"specify the dataset with partially-received \"\n\t\t\t    \"state\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (flags.raw && redactbook != NULL) {\n\t\tfree(excludes.list);\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Error: raw sends may not be redacted.\\n\"));\n\t\treturn (1);\n\t}\n\n\tif (!flags.dryrun && isatty(STDOUT_FILENO)) {\n\t\tfree(excludes.list);\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Error: Stream can not be written to a terminal.\\n\"\n\t\t    \"You must redirect standard output.\\n\"));\n\t\treturn (1);\n\t}\n\n\tif (flags.saved) {\n\t\tzhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\tfree(excludes.list);\n\t\t\treturn (1);\n\t\t}\n\n\t\terr = zfs_send_saved(zhp, &flags, STDOUT_FILENO,\n\t\t    resume_token);\n\t\tfree(excludes.list);\n\t\tzfs_close(zhp);\n\t\treturn (err != 0);\n\t} else if (resume_token != NULL) {\n\t\tfree(excludes.list);\n\t\treturn (zfs_send_resume(g_zfs, &flags, STDOUT_FILENO,\n\t\t    resume_token));\n\t}\n\n\tif (flags.skipmissing && !flags.replicate) {\n\t\tfree(excludes.list);\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"skip-missing flag can only be used in \"\n\t\t    \"conjunction with replicate\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\t \n\tif (!(flags.replicate || flags.doall)) {\n\t\tchar frombuf[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\tif (fromname != NULL && (strchr(fromname, '#') == NULL &&\n\t\t    strchr(fromname, '@') == NULL)) {\n\t\t\t \n\t\t\t(void) fprintf(stderr, \"Warning: incremental source \"\n\t\t\t    \"didn't specify type, assuming snapshot. Use '@' \"\n\t\t\t    \"or '#' prefix to avoid ambiguity.\\n\");\n\t\t\t(void) snprintf(frombuf, sizeof (frombuf), \"@%s\",\n\t\t\t    fromname);\n\t\t\tfromname = frombuf;\n\t\t}\n\t\tif (fromname != NULL &&\n\t\t    (fromname[0] == '#' || fromname[0] == '@')) {\n\t\t\t \n\t\t\tchar tmpbuf[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t(void) strlcpy(tmpbuf, fromname, sizeof (tmpbuf));\n\t\t\t(void) strlcpy(frombuf, argv[0], sizeof (frombuf));\n\t\t\tcp = strchr(frombuf, '@');\n\t\t\tif (cp != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\t(void) strlcat(frombuf, tmpbuf, sizeof (frombuf));\n\t\t\tfromname = frombuf;\n\t\t}\n\n\t\tzhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_DATASET);\n\t\tif (zhp == NULL) {\n\t\t\tfree(excludes.list);\n\t\t\treturn (1);\n\t\t}\n\t\terr = zfs_send_one(zhp, fromname, STDOUT_FILENO, &flags,\n\t\t    redactbook);\n\n\t\tfree(excludes.list);\n\t\tzfs_close(zhp);\n\t\treturn (err != 0);\n\t}\n\n\tif (fromname != NULL && strchr(fromname, '#')) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Error: multiple snapshots cannot be \"\n\t\t    \"sent from a bookmark.\\n\"));\n\t\tfree(excludes.list);\n\t\treturn (1);\n\t}\n\n\tif (redactbook != NULL) {\n\t\t(void) fprintf(stderr, gettext(\"Error: multiple snapshots \"\n\t\t    \"cannot be sent redacted.\\n\"));\n\t\tfree(excludes.list);\n\t\treturn (1);\n\t}\n\n\tif ((cp = strchr(argv[0], '@')) == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"Error: \"\n\t\t    \"Unsupported flag with filesystem or bookmark.\\n\"));\n\t\tfree(excludes.list);\n\t\treturn (1);\n\t}\n\t*cp = '\\0';\n\ttoname = cp + 1;\n\tzhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\tif (zhp == NULL) {\n\t\tfree(excludes.list);\n\t\treturn (1);\n\t}\n\n\t \n\tif (fromname && (cp = strchr(fromname, '@')) != NULL) {\n\t\tchar origin[ZFS_MAX_DATASET_NAME_LEN];\n\t\tzprop_source_t src;\n\n\t\t(void) zfs_prop_get(zhp, ZFS_PROP_ORIGIN,\n\t\t    origin, sizeof (origin), &src, NULL, 0, B_FALSE);\n\n\t\tif (strcmp(origin, fromname) == 0) {\n\t\t\tfromname = NULL;\n\t\t\tflags.fromorigin = B_TRUE;\n\t\t} else {\n\t\t\t*cp = '\\0';\n\t\t\tif (cp != fromname && strcmp(argv[0], fromname)) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tfree(excludes.list);\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"incremental source must be \"\n\t\t\t\t    \"in same filesystem\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tfromname = cp + 1;\n\t\t\tif (strchr(fromname, '@') || strchr(fromname, '/')) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tfree(excludes.list);\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid incremental source\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags.replicate && fromname == NULL)\n\t\tflags.doall = B_TRUE;\n\n\terr = zfs_send(zhp, fromname, toname, &flags, STDOUT_FILENO,\n\t    excludes.count > 0 ? zfs_do_send_exclude : NULL,\n\t    &excludes, flags.verbosity >= 3 ? &dbgnv : NULL);\n\n\tif (flags.verbosity >= 3 && dbgnv != NULL) {\n\t\t \n\t\t(void) dup2(STDERR_FILENO, STDOUT_FILENO);\n\t\tdump_nvlist(dbgnv, 0);\n\t\tnvlist_free(dbgnv);\n\t}\n\n\tzfs_close(zhp);\n\tfree(excludes.list);\n\treturn (err != 0);\n}\n\n \nstatic int\nzfs_do_receive(int argc, char **argv)\n{\n\tint c, err = 0;\n\trecvflags_t flags = { 0 };\n\tboolean_t abort_resumable = B_FALSE;\n\tnvlist_t *props;\n\n\tif (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\n\t \n\twhile ((c = getopt(argc, argv, \":o:x:dehMnuvFsAc\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'o':\n\t\t\tif (!parseprop(props, optarg)) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (!parsepropname(props, optarg)) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (flags.istail) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"invalid option \"\n\t\t\t\t    \"combination: -d and -e are mutually \"\n\t\t\t\t    \"exclusive\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tflags.isprefix = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (flags.isprefix) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"invalid option \"\n\t\t\t\t    \"combination: -d and -e are mutually \"\n\t\t\t\t    \"exclusive\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tflags.istail = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tflags.skipholds = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tflags.forceunmount = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags.dryrun = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags.nomount = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags.verbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tflags.resumable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tflags.force = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tabort_resumable = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags.heal = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (flags.istail)\n\t\tflags.isprefix = B_TRUE;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing snapshot argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (abort_resumable) {\n\t\tif (flags.isprefix || flags.istail || flags.dryrun ||\n\t\t    flags.resumable || flags.nomount) {\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\t\t(void) snprintf(namebuf, sizeof (namebuf),\n\t\t    \"%s/%%recv\", argv[0]);\n\n\t\tif (zfs_dataset_exists(g_zfs, namebuf,\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME)) {\n\t\t\tzfs_handle_t *zhp = zfs_open(g_zfs,\n\t\t\t    namebuf, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\t\tif (zhp == NULL) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\terr = zfs_destroy(zhp, B_FALSE);\n\t\t\tzfs_close(zhp);\n\t\t} else {\n\t\t\tzfs_handle_t *zhp = zfs_open(g_zfs,\n\t\t\t    argv[0], ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\t\tif (zhp == NULL)\n\t\t\t\tusage(B_FALSE);\n\t\t\tif (!zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) ||\n\t\t\t    zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN,\n\t\t\t    NULL, 0, NULL, NULL, 0, B_TRUE) == -1) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"'%s' does not have any \"\n\t\t\t\t    \"resumable receive state to abort\\n\"),\n\t\t\t\t    argv[0]);\n\t\t\t\tnvlist_free(props);\n\t\t\t\tzfs_close(zhp);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\terr = zfs_destroy(zhp, B_FALSE);\n\t\t\tzfs_close(zhp);\n\t\t}\n\t\tnvlist_free(props);\n\t\treturn (err != 0);\n\t}\n\n\tif (isatty(STDIN_FILENO)) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Error: Backup stream can not be read \"\n\t\t    \"from a terminal.\\n\"\n\t\t    \"You must redirect standard input.\\n\"));\n\t\tnvlist_free(props);\n\t\treturn (1);\n\t}\n\terr = zfs_receive(g_zfs, argv[0], props, &flags, STDIN_FILENO, NULL);\n\tnvlist_free(props);\n\n\treturn (err != 0);\n}\n\n \n \n#define\tZFS_DELEG_PERM_CREATE\t\t\"create\"\n#define\tZFS_DELEG_PERM_DESTROY\t\t\"destroy\"\n#define\tZFS_DELEG_PERM_SNAPSHOT\t\t\"snapshot\"\n#define\tZFS_DELEG_PERM_ROLLBACK\t\t\"rollback\"\n#define\tZFS_DELEG_PERM_CLONE\t\t\"clone\"\n#define\tZFS_DELEG_PERM_PROMOTE\t\t\"promote\"\n#define\tZFS_DELEG_PERM_RENAME\t\t\"rename\"\n#define\tZFS_DELEG_PERM_MOUNT\t\t\"mount\"\n#define\tZFS_DELEG_PERM_SHARE\t\t\"share\"\n#define\tZFS_DELEG_PERM_SEND\t\t\"send\"\n#define\tZFS_DELEG_PERM_RECEIVE\t\t\"receive\"\n#define\tZFS_DELEG_PERM_ALLOW\t\t\"allow\"\n#define\tZFS_DELEG_PERM_USERPROP\t\t\"userprop\"\n#define\tZFS_DELEG_PERM_VSCAN\t\t\"vscan\"  \n#define\tZFS_DELEG_PERM_USERQUOTA\t\"userquota\"\n#define\tZFS_DELEG_PERM_GROUPQUOTA\t\"groupquota\"\n#define\tZFS_DELEG_PERM_USERUSED\t\t\"userused\"\n#define\tZFS_DELEG_PERM_GROUPUSED\t\"groupused\"\n#define\tZFS_DELEG_PERM_USEROBJQUOTA\t\"userobjquota\"\n#define\tZFS_DELEG_PERM_GROUPOBJQUOTA\t\"groupobjquota\"\n#define\tZFS_DELEG_PERM_USEROBJUSED\t\"userobjused\"\n#define\tZFS_DELEG_PERM_GROUPOBJUSED\t\"groupobjused\"\n\n#define\tZFS_DELEG_PERM_HOLD\t\t\"hold\"\n#define\tZFS_DELEG_PERM_RELEASE\t\t\"release\"\n#define\tZFS_DELEG_PERM_DIFF\t\t\"diff\"\n#define\tZFS_DELEG_PERM_BOOKMARK\t\t\"bookmark\"\n#define\tZFS_DELEG_PERM_LOAD_KEY\t\t\"load-key\"\n#define\tZFS_DELEG_PERM_CHANGE_KEY\t\"change-key\"\n\n#define\tZFS_DELEG_PERM_PROJECTUSED\t\"projectused\"\n#define\tZFS_DELEG_PERM_PROJECTQUOTA\t\"projectquota\"\n#define\tZFS_DELEG_PERM_PROJECTOBJUSED\t\"projectobjused\"\n#define\tZFS_DELEG_PERM_PROJECTOBJQUOTA\t\"projectobjquota\"\n\n#define\tZFS_NUM_DELEG_NOTES ZFS_DELEG_NOTE_NONE\n\nstatic zfs_deleg_perm_tab_t zfs_deleg_perm_tbl[] = {\n\t{ ZFS_DELEG_PERM_ALLOW, ZFS_DELEG_NOTE_ALLOW },\n\t{ ZFS_DELEG_PERM_CLONE, ZFS_DELEG_NOTE_CLONE },\n\t{ ZFS_DELEG_PERM_CREATE, ZFS_DELEG_NOTE_CREATE },\n\t{ ZFS_DELEG_PERM_DESTROY, ZFS_DELEG_NOTE_DESTROY },\n\t{ ZFS_DELEG_PERM_DIFF, ZFS_DELEG_NOTE_DIFF},\n\t{ ZFS_DELEG_PERM_HOLD, ZFS_DELEG_NOTE_HOLD },\n\t{ ZFS_DELEG_PERM_MOUNT, ZFS_DELEG_NOTE_MOUNT },\n\t{ ZFS_DELEG_PERM_PROMOTE, ZFS_DELEG_NOTE_PROMOTE },\n\t{ ZFS_DELEG_PERM_RECEIVE, ZFS_DELEG_NOTE_RECEIVE },\n\t{ ZFS_DELEG_PERM_RELEASE, ZFS_DELEG_NOTE_RELEASE },\n\t{ ZFS_DELEG_PERM_RENAME, ZFS_DELEG_NOTE_RENAME },\n\t{ ZFS_DELEG_PERM_ROLLBACK, ZFS_DELEG_NOTE_ROLLBACK },\n\t{ ZFS_DELEG_PERM_SEND, ZFS_DELEG_NOTE_SEND },\n\t{ ZFS_DELEG_PERM_SHARE, ZFS_DELEG_NOTE_SHARE },\n\t{ ZFS_DELEG_PERM_SNAPSHOT, ZFS_DELEG_NOTE_SNAPSHOT },\n\t{ ZFS_DELEG_PERM_BOOKMARK, ZFS_DELEG_NOTE_BOOKMARK },\n\t{ ZFS_DELEG_PERM_LOAD_KEY, ZFS_DELEG_NOTE_LOAD_KEY },\n\t{ ZFS_DELEG_PERM_CHANGE_KEY, ZFS_DELEG_NOTE_CHANGE_KEY },\n\n\t{ ZFS_DELEG_PERM_GROUPQUOTA, ZFS_DELEG_NOTE_GROUPQUOTA },\n\t{ ZFS_DELEG_PERM_GROUPUSED, ZFS_DELEG_NOTE_GROUPUSED },\n\t{ ZFS_DELEG_PERM_USERPROP, ZFS_DELEG_NOTE_USERPROP },\n\t{ ZFS_DELEG_PERM_USERQUOTA, ZFS_DELEG_NOTE_USERQUOTA },\n\t{ ZFS_DELEG_PERM_USERUSED, ZFS_DELEG_NOTE_USERUSED },\n\t{ ZFS_DELEG_PERM_USEROBJQUOTA, ZFS_DELEG_NOTE_USEROBJQUOTA },\n\t{ ZFS_DELEG_PERM_USEROBJUSED, ZFS_DELEG_NOTE_USEROBJUSED },\n\t{ ZFS_DELEG_PERM_GROUPOBJQUOTA, ZFS_DELEG_NOTE_GROUPOBJQUOTA },\n\t{ ZFS_DELEG_PERM_GROUPOBJUSED, ZFS_DELEG_NOTE_GROUPOBJUSED },\n\t{ ZFS_DELEG_PERM_PROJECTUSED, ZFS_DELEG_NOTE_PROJECTUSED },\n\t{ ZFS_DELEG_PERM_PROJECTQUOTA, ZFS_DELEG_NOTE_PROJECTQUOTA },\n\t{ ZFS_DELEG_PERM_PROJECTOBJUSED, ZFS_DELEG_NOTE_PROJECTOBJUSED },\n\t{ ZFS_DELEG_PERM_PROJECTOBJQUOTA, ZFS_DELEG_NOTE_PROJECTOBJQUOTA },\n\t{ NULL, ZFS_DELEG_NOTE_NONE }\n};\n\n \ntypedef struct deleg_perm {\n\tzfs_deleg_who_type_t\tdp_who_type;\n\tconst char\t\t*dp_name;\n\tboolean_t\t\tdp_local;\n\tboolean_t\t\tdp_descend;\n} deleg_perm_t;\n\n \ntypedef struct deleg_perm_node {\n\tdeleg_perm_t\t\tdpn_perm;\n\n\tuu_avl_node_t\t\tdpn_avl_node;\n} deleg_perm_node_t;\n\ntypedef struct fs_perm fs_perm_t;\n\n \ntypedef struct who_perm {\n\tzfs_deleg_who_type_t\twho_type;\n\tconst char\t\t*who_name;\t\t \n\tchar\t\t\twho_ug_name[256];\t \n\tfs_perm_t\t\t*who_fsperm;\t\t \n\n\tuu_avl_t\t\t*who_deleg_perm_avl;\t \n} who_perm_t;\n\n \ntypedef struct who_perm_node {\n\twho_perm_t\twho_perm;\n\tuu_avl_node_t\twho_avl_node;\n} who_perm_node_t;\n\ntypedef struct fs_perm_set fs_perm_set_t;\n \nstruct fs_perm {\n\tconst char\t\t*fsp_name;\n\n\tuu_avl_t\t\t*fsp_sc_avl;\t \n\tuu_avl_t\t\t*fsp_uge_avl;\t \n\n\tfs_perm_set_t\t\t*fsp_set;\t \n};\n\n \ntypedef struct fs_perm_node {\n\tfs_perm_t\tfspn_fsperm;\n\tuu_avl_t\t*fspn_avl;\n\n\tuu_list_node_t\tfspn_list_node;\n} fs_perm_node_t;\n\n \nstruct fs_perm_set {\n\tuu_list_pool_t\t*fsps_list_pool;\n\tuu_list_t\t*fsps_list;  \n\n\tuu_avl_pool_t\t*fsps_named_set_avl_pool;\n\tuu_avl_pool_t\t*fsps_who_perm_avl_pool;\n\tuu_avl_pool_t\t*fsps_deleg_perm_avl_pool;\n};\n\nstatic inline const char *\ndeleg_perm_type(zfs_deleg_note_t note)\n{\n\t \n\tswitch (note) {\n\t\t \n\t\t \n\tcase ZFS_DELEG_NOTE_GROUPQUOTA:\n\tcase ZFS_DELEG_NOTE_GROUPUSED:\n\tcase ZFS_DELEG_NOTE_USERPROP:\n\tcase ZFS_DELEG_NOTE_USERQUOTA:\n\tcase ZFS_DELEG_NOTE_USERUSED:\n\tcase ZFS_DELEG_NOTE_USEROBJQUOTA:\n\tcase ZFS_DELEG_NOTE_USEROBJUSED:\n\tcase ZFS_DELEG_NOTE_GROUPOBJQUOTA:\n\tcase ZFS_DELEG_NOTE_GROUPOBJUSED:\n\tcase ZFS_DELEG_NOTE_PROJECTUSED:\n\tcase ZFS_DELEG_NOTE_PROJECTQUOTA:\n\tcase ZFS_DELEG_NOTE_PROJECTOBJUSED:\n\tcase ZFS_DELEG_NOTE_PROJECTOBJQUOTA:\n\t\t \n\t\treturn (gettext(\"other\"));\n\tdefault:\n\t\treturn (gettext(\"subcommand\"));\n\t}\n}\n\nstatic int\nwho_type2weight(zfs_deleg_who_type_t who_type)\n{\n\tint res;\n\tswitch (who_type) {\n\t\tcase ZFS_DELEG_NAMED_SET_SETS:\n\t\tcase ZFS_DELEG_NAMED_SET:\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\tcase ZFS_DELEG_CREATE_SETS:\n\t\tcase ZFS_DELEG_CREATE:\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\tcase ZFS_DELEG_USER_SETS:\n\t\tcase ZFS_DELEG_USER:\n\t\t\tres = 2;\n\t\t\tbreak;\n\t\tcase ZFS_DELEG_GROUP_SETS:\n\t\tcase ZFS_DELEG_GROUP:\n\t\t\tres = 3;\n\t\t\tbreak;\n\t\tcase ZFS_DELEG_EVERYONE_SETS:\n\t\tcase ZFS_DELEG_EVERYONE:\n\t\t\tres = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = -1;\n\t}\n\n\treturn (res);\n}\n\nstatic int\nwho_perm_compare(const void *larg, const void *rarg, void *unused)\n{\n\t(void) unused;\n\tconst who_perm_node_t *l = larg;\n\tconst who_perm_node_t *r = rarg;\n\tzfs_deleg_who_type_t ltype = l->who_perm.who_type;\n\tzfs_deleg_who_type_t rtype = r->who_perm.who_type;\n\tint lweight = who_type2weight(ltype);\n\tint rweight = who_type2weight(rtype);\n\tint res = lweight - rweight;\n\tif (res == 0)\n\t\tres = strncmp(l->who_perm.who_name, r->who_perm.who_name,\n\t\t    ZFS_MAX_DELEG_NAME-1);\n\n\tif (res == 0)\n\t\treturn (0);\n\tif (res > 0)\n\t\treturn (1);\n\telse\n\t\treturn (-1);\n}\n\nstatic int\ndeleg_perm_compare(const void *larg, const void *rarg, void *unused)\n{\n\t(void) unused;\n\tconst deleg_perm_node_t *l = larg;\n\tconst deleg_perm_node_t *r = rarg;\n\tint res =  strncmp(l->dpn_perm.dp_name, r->dpn_perm.dp_name,\n\t    ZFS_MAX_DELEG_NAME-1);\n\n\tif (res == 0)\n\t\treturn (0);\n\n\tif (res > 0)\n\t\treturn (1);\n\telse\n\t\treturn (-1);\n}\n\nstatic inline void\nfs_perm_set_init(fs_perm_set_t *fspset)\n{\n\tmemset(fspset, 0, sizeof (fs_perm_set_t));\n\n\tif ((fspset->fsps_list_pool = uu_list_pool_create(\"fsps_list_pool\",\n\t    sizeof (fs_perm_node_t), offsetof(fs_perm_node_t, fspn_list_node),\n\t    NULL, UU_DEFAULT)) == NULL)\n\t\tnomem();\n\tif ((fspset->fsps_list = uu_list_create(fspset->fsps_list_pool, NULL,\n\t    UU_DEFAULT)) == NULL)\n\t\tnomem();\n\n\tif ((fspset->fsps_named_set_avl_pool = uu_avl_pool_create(\n\t    \"named_set_avl_pool\", sizeof (who_perm_node_t), offsetof(\n\t    who_perm_node_t, who_avl_node), who_perm_compare,\n\t    UU_DEFAULT)) == NULL)\n\t\tnomem();\n\n\tif ((fspset->fsps_who_perm_avl_pool = uu_avl_pool_create(\n\t    \"who_perm_avl_pool\", sizeof (who_perm_node_t), offsetof(\n\t    who_perm_node_t, who_avl_node), who_perm_compare,\n\t    UU_DEFAULT)) == NULL)\n\t\tnomem();\n\n\tif ((fspset->fsps_deleg_perm_avl_pool = uu_avl_pool_create(\n\t    \"deleg_perm_avl_pool\", sizeof (deleg_perm_node_t), offsetof(\n\t    deleg_perm_node_t, dpn_avl_node), deleg_perm_compare, UU_DEFAULT))\n\t    == NULL)\n\t\tnomem();\n}\n\nstatic inline void fs_perm_fini(fs_perm_t *);\nstatic inline void who_perm_fini(who_perm_t *);\n\nstatic inline void\nfs_perm_set_fini(fs_perm_set_t *fspset)\n{\n\tfs_perm_node_t *node = uu_list_first(fspset->fsps_list);\n\n\twhile (node != NULL) {\n\t\tfs_perm_node_t *next_node =\n\t\t    uu_list_next(fspset->fsps_list, node);\n\t\tfs_perm_t *fsperm = &node->fspn_fsperm;\n\t\tfs_perm_fini(fsperm);\n\t\tuu_list_remove(fspset->fsps_list, node);\n\t\tfree(node);\n\t\tnode = next_node;\n\t}\n\n\tuu_avl_pool_destroy(fspset->fsps_named_set_avl_pool);\n\tuu_avl_pool_destroy(fspset->fsps_who_perm_avl_pool);\n\tuu_avl_pool_destroy(fspset->fsps_deleg_perm_avl_pool);\n}\n\nstatic inline void\ndeleg_perm_init(deleg_perm_t *deleg_perm, zfs_deleg_who_type_t type,\n    const char *name)\n{\n\tdeleg_perm->dp_who_type = type;\n\tdeleg_perm->dp_name = name;\n}\n\nstatic inline void\nwho_perm_init(who_perm_t *who_perm, fs_perm_t *fsperm,\n    zfs_deleg_who_type_t type, const char *name)\n{\n\tuu_avl_pool_t\t*pool;\n\tpool = fsperm->fsp_set->fsps_deleg_perm_avl_pool;\n\n\tmemset(who_perm, 0, sizeof (who_perm_t));\n\n\tif ((who_perm->who_deleg_perm_avl = uu_avl_create(pool, NULL,\n\t    UU_DEFAULT)) == NULL)\n\t\tnomem();\n\n\twho_perm->who_type = type;\n\twho_perm->who_name = name;\n\twho_perm->who_fsperm = fsperm;\n}\n\nstatic inline void\nwho_perm_fini(who_perm_t *who_perm)\n{\n\tdeleg_perm_node_t *node = uu_avl_first(who_perm->who_deleg_perm_avl);\n\n\twhile (node != NULL) {\n\t\tdeleg_perm_node_t *next_node =\n\t\t    uu_avl_next(who_perm->who_deleg_perm_avl, node);\n\n\t\tuu_avl_remove(who_perm->who_deleg_perm_avl, node);\n\t\tfree(node);\n\t\tnode = next_node;\n\t}\n\n\tuu_avl_destroy(who_perm->who_deleg_perm_avl);\n}\n\nstatic inline void\nfs_perm_init(fs_perm_t *fsperm, fs_perm_set_t *fspset, const char *fsname)\n{\n\tuu_avl_pool_t\t*nset_pool = fspset->fsps_named_set_avl_pool;\n\tuu_avl_pool_t\t*who_pool = fspset->fsps_who_perm_avl_pool;\n\n\tmemset(fsperm, 0, sizeof (fs_perm_t));\n\n\tif ((fsperm->fsp_sc_avl = uu_avl_create(nset_pool, NULL, UU_DEFAULT))\n\t    == NULL)\n\t\tnomem();\n\n\tif ((fsperm->fsp_uge_avl = uu_avl_create(who_pool, NULL, UU_DEFAULT))\n\t    == NULL)\n\t\tnomem();\n\n\tfsperm->fsp_set = fspset;\n\tfsperm->fsp_name = fsname;\n}\n\nstatic inline void\nfs_perm_fini(fs_perm_t *fsperm)\n{\n\twho_perm_node_t *node = uu_avl_first(fsperm->fsp_sc_avl);\n\twhile (node != NULL) {\n\t\twho_perm_node_t *next_node = uu_avl_next(fsperm->fsp_sc_avl,\n\t\t    node);\n\t\twho_perm_t *who_perm = &node->who_perm;\n\t\twho_perm_fini(who_perm);\n\t\tuu_avl_remove(fsperm->fsp_sc_avl, node);\n\t\tfree(node);\n\t\tnode = next_node;\n\t}\n\n\tnode = uu_avl_first(fsperm->fsp_uge_avl);\n\twhile (node != NULL) {\n\t\twho_perm_node_t *next_node = uu_avl_next(fsperm->fsp_uge_avl,\n\t\t    node);\n\t\twho_perm_t *who_perm = &node->who_perm;\n\t\twho_perm_fini(who_perm);\n\t\tuu_avl_remove(fsperm->fsp_uge_avl, node);\n\t\tfree(node);\n\t\tnode = next_node;\n\t}\n\n\tuu_avl_destroy(fsperm->fsp_sc_avl);\n\tuu_avl_destroy(fsperm->fsp_uge_avl);\n}\n\nstatic void\nset_deleg_perm_node(uu_avl_t *avl, deleg_perm_node_t *node,\n    zfs_deleg_who_type_t who_type, const char *name, char locality)\n{\n\tuu_avl_index_t idx = 0;\n\n\tdeleg_perm_node_t *found_node = NULL;\n\tdeleg_perm_t\t*deleg_perm = &node->dpn_perm;\n\n\tdeleg_perm_init(deleg_perm, who_type, name);\n\n\tif ((found_node = uu_avl_find(avl, node, NULL, &idx))\n\t    == NULL)\n\t\tuu_avl_insert(avl, node, idx);\n\telse {\n\t\tnode = found_node;\n\t\tdeleg_perm = &node->dpn_perm;\n\t}\n\n\n\tswitch (locality) {\n\tcase ZFS_DELEG_LOCAL:\n\t\tdeleg_perm->dp_local = B_TRUE;\n\t\tbreak;\n\tcase ZFS_DELEG_DESCENDENT:\n\t\tdeleg_perm->dp_descend = B_TRUE;\n\t\tbreak;\n\tcase ZFS_DELEG_NA:\n\t\tbreak;\n\tdefault:\n\t\tassert(B_FALSE);  \n\t}\n}\n\nstatic inline int\nparse_who_perm(who_perm_t *who_perm, nvlist_t *nvl, char locality)\n{\n\tnvpair_t *nvp = NULL;\n\tfs_perm_set_t *fspset = who_perm->who_fsperm->fsp_set;\n\tuu_avl_t *avl = who_perm->who_deleg_perm_avl;\n\tzfs_deleg_who_type_t who_type = who_perm->who_type;\n\n\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {\n\t\tconst char *name = nvpair_name(nvp);\n\t\tdata_type_t type = nvpair_type(nvp);\n\t\tuu_avl_pool_t *avl_pool = fspset->fsps_deleg_perm_avl_pool;\n\t\tdeleg_perm_node_t *node =\n\t\t    safe_malloc(sizeof (deleg_perm_node_t));\n\n\t\tVERIFY(type == DATA_TYPE_BOOLEAN);\n\n\t\tuu_avl_node_init(node, &node->dpn_avl_node, avl_pool);\n\t\tset_deleg_perm_node(avl, node, who_type, name, locality);\n\t}\n\n\treturn (0);\n}\n\nstatic inline int\nparse_fs_perm(fs_perm_t *fsperm, nvlist_t *nvl)\n{\n\tnvpair_t *nvp = NULL;\n\tfs_perm_set_t *fspset = fsperm->fsp_set;\n\n\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {\n\t\tnvlist_t *nvl2 = NULL;\n\t\tconst char *name = nvpair_name(nvp);\n\t\tuu_avl_t *avl = NULL;\n\t\tuu_avl_pool_t *avl_pool = NULL;\n\t\tzfs_deleg_who_type_t perm_type = name[0];\n\t\tchar perm_locality = name[1];\n\t\tconst char *perm_name = name + 3;\n\t\twho_perm_t *who_perm = NULL;\n\n\t\tassert('$' == name[2]);\n\n\t\tif (nvpair_value_nvlist(nvp, &nvl2) != 0)\n\t\t\treturn (-1);\n\n\t\tswitch (perm_type) {\n\t\tcase ZFS_DELEG_CREATE:\n\t\tcase ZFS_DELEG_CREATE_SETS:\n\t\tcase ZFS_DELEG_NAMED_SET:\n\t\tcase ZFS_DELEG_NAMED_SET_SETS:\n\t\t\tavl_pool = fspset->fsps_named_set_avl_pool;\n\t\t\tavl = fsperm->fsp_sc_avl;\n\t\t\tbreak;\n\t\tcase ZFS_DELEG_USER:\n\t\tcase ZFS_DELEG_USER_SETS:\n\t\tcase ZFS_DELEG_GROUP:\n\t\tcase ZFS_DELEG_GROUP_SETS:\n\t\tcase ZFS_DELEG_EVERYONE:\n\t\tcase ZFS_DELEG_EVERYONE_SETS:\n\t\t\tavl_pool = fspset->fsps_who_perm_avl_pool;\n\t\t\tavl = fsperm->fsp_uge_avl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tassert(!\"unhandled zfs_deleg_who_type_t\");\n\t\t}\n\n\t\twho_perm_node_t *found_node = NULL;\n\t\twho_perm_node_t *node = safe_malloc(\n\t\t    sizeof (who_perm_node_t));\n\t\twho_perm = &node->who_perm;\n\t\tuu_avl_index_t idx = 0;\n\n\t\tuu_avl_node_init(node, &node->who_avl_node, avl_pool);\n\t\twho_perm_init(who_perm, fsperm, perm_type, perm_name);\n\n\t\tif ((found_node = uu_avl_find(avl, node, NULL, &idx))\n\t\t    == NULL) {\n\t\t\tif (avl == fsperm->fsp_uge_avl) {\n\t\t\t\tuid_t rid = 0;\n\t\t\t\tstruct passwd *p = NULL;\n\t\t\t\tstruct group *g = NULL;\n\t\t\t\tconst char *nice_name = NULL;\n\n\t\t\t\tswitch (perm_type) {\n\t\t\t\tcase ZFS_DELEG_USER_SETS:\n\t\t\t\tcase ZFS_DELEG_USER:\n\t\t\t\t\trid = atoi(perm_name);\n\t\t\t\t\tp = getpwuid(rid);\n\t\t\t\t\tif (p)\n\t\t\t\t\t\tnice_name = p->pw_name;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZFS_DELEG_GROUP_SETS:\n\t\t\t\tcase ZFS_DELEG_GROUP:\n\t\t\t\t\trid = atoi(perm_name);\n\t\t\t\t\tg = getgrgid(rid);\n\t\t\t\t\tif (g)\n\t\t\t\t\t\tnice_name = g->gr_name;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (nice_name != NULL) {\n\t\t\t\t\t(void) strlcpy(\n\t\t\t\t\t    node->who_perm.who_ug_name,\n\t\t\t\t\t    nice_name, 256);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\t(void) snprintf(\n\t\t\t\t\t    node->who_perm.who_ug_name,\n\t\t\t\t\t    sizeof (node->who_perm.who_ug_name),\n\t\t\t\t\t    \"(unknown: %d)\", rid);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tuu_avl_insert(avl, node, idx);\n\t\t} else {\n\t\t\tnode = found_node;\n\t\t\twho_perm = &node->who_perm;\n\t\t}\n\n\t\tassert(who_perm != NULL);\n\t\t(void) parse_who_perm(who_perm, nvl2, perm_locality);\n\t}\n\n\treturn (0);\n}\n\nstatic inline int\nparse_fs_perm_set(fs_perm_set_t *fspset, nvlist_t *nvl)\n{\n\tnvpair_t *nvp = NULL;\n\tuu_avl_index_t idx = 0;\n\n\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {\n\t\tnvlist_t *nvl2 = NULL;\n\t\tconst char *fsname = nvpair_name(nvp);\n\t\tdata_type_t type = nvpair_type(nvp);\n\t\tfs_perm_t *fsperm = NULL;\n\t\tfs_perm_node_t *node = safe_malloc(sizeof (fs_perm_node_t));\n\n\t\tfsperm = &node->fspn_fsperm;\n\n\t\tVERIFY(DATA_TYPE_NVLIST == type);\n\n\t\tuu_list_node_init(node, &node->fspn_list_node,\n\t\t    fspset->fsps_list_pool);\n\n\t\tidx = uu_list_numnodes(fspset->fsps_list);\n\t\tfs_perm_init(fsperm, fspset, fsname);\n\n\t\tif (nvpair_value_nvlist(nvp, &nvl2) != 0)\n\t\t\treturn (-1);\n\n\t\t(void) parse_fs_perm(fsperm, nvl2);\n\n\t\tuu_list_insert(fspset->fsps_list, node, idx);\n\t}\n\n\treturn (0);\n}\n\nstatic inline const char *\ndeleg_perm_comment(zfs_deleg_note_t note)\n{\n\tconst char *str = \"\";\n\n\t \n\tswitch (note) {\n\t\t \n\tcase ZFS_DELEG_NOTE_ALLOW:\n\t\tstr = gettext(\"Must also have the permission that is being\"\n\t\t    \"\\n\\t\\t\\t\\tallowed\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_CLONE:\n\t\tstr = gettext(\"Must also have the 'create' ability and 'mount'\"\n\t\t    \"\\n\\t\\t\\t\\tability in the origin file system\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_CREATE:\n\t\tstr = gettext(\"Must also have the 'mount' ability\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_DESTROY:\n\t\tstr = gettext(\"Must also have the 'mount' ability\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_DIFF:\n\t\tstr = gettext(\"Allows lookup of paths within a dataset;\"\n\t\t    \"\\n\\t\\t\\t\\tgiven an object number. Ordinary users need this\"\n\t\t    \"\\n\\t\\t\\t\\tin order to use zfs diff\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_HOLD:\n\t\tstr = gettext(\"Allows adding a user hold to a snapshot\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_MOUNT:\n\t\tstr = gettext(\"Allows mount/umount of ZFS datasets\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_PROMOTE:\n\t\tstr = gettext(\"Must also have the 'mount'\\n\\t\\t\\t\\tand\"\n\t\t    \" 'promote' ability in the origin file system\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_RECEIVE:\n\t\tstr = gettext(\"Must also have the 'mount' and 'create'\"\n\t\t    \" ability\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_RELEASE:\n\t\tstr = gettext(\"Allows releasing a user hold which\\n\\t\\t\\t\\t\"\n\t\t    \"might destroy the snapshot\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_RENAME:\n\t\tstr = gettext(\"Must also have the 'mount' and 'create'\"\n\t\t    \"\\n\\t\\t\\t\\tability in the new parent\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_ROLLBACK:\n\t\tstr = gettext(\"\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_SEND:\n\t\tstr = gettext(\"\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_SHARE:\n\t\tstr = gettext(\"Allows sharing file systems over NFS or SMB\"\n\t\t    \"\\n\\t\\t\\t\\tprotocols\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_SNAPSHOT:\n\t\tstr = gettext(\"\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_LOAD_KEY:\n\t\tstr = gettext(\"Allows loading or unloading an encryption key\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_CHANGE_KEY:\n\t\tstr = gettext(\"Allows changing or adding an encryption key\");\n\t\tbreak;\n \n\t\t \n\tcase ZFS_DELEG_NOTE_GROUPQUOTA:\n\t\tstr = gettext(\"Allows accessing any groupquota@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_GROUPUSED:\n\t\tstr = gettext(\"Allows reading any groupused@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_USERPROP:\n\t\tstr = gettext(\"Allows changing any user property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_USERQUOTA:\n\t\tstr = gettext(\"Allows accessing any userquota@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_USERUSED:\n\t\tstr = gettext(\"Allows reading any userused@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_USEROBJQUOTA:\n\t\tstr = gettext(\"Allows accessing any userobjquota@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_GROUPOBJQUOTA:\n\t\tstr = gettext(\"Allows accessing any \\n\\t\\t\\t\\t\"\n\t\t    \"groupobjquota@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_GROUPOBJUSED:\n\t\tstr = gettext(\"Allows reading any groupobjused@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_USEROBJUSED:\n\t\tstr = gettext(\"Allows reading any userobjused@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_PROJECTQUOTA:\n\t\tstr = gettext(\"Allows accessing any projectquota@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_PROJECTOBJQUOTA:\n\t\tstr = gettext(\"Allows accessing any \\n\\t\\t\\t\\t\"\n\t\t    \"projectobjquota@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_PROJECTUSED:\n\t\tstr = gettext(\"Allows reading any projectused@... property\");\n\t\tbreak;\n\tcase ZFS_DELEG_NOTE_PROJECTOBJUSED:\n\t\tstr = gettext(\"Allows accessing any \\n\\t\\t\\t\\t\"\n\t\t    \"projectobjused@... property\");\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tstr = \"\";\n\t}\n\n\treturn (str);\n}\n\nstruct allow_opts {\n\tboolean_t local;\n\tboolean_t descend;\n\tboolean_t user;\n\tboolean_t group;\n\tboolean_t everyone;\n\tboolean_t create;\n\tboolean_t set;\n\tboolean_t recursive;  \n\tboolean_t prt_usage;\n\n\tboolean_t prt_perms;\n\tchar *who;\n\tchar *perms;\n\tconst char *dataset;\n};\n\nstatic inline int\nprop_cmp(const void *a, const void *b)\n{\n\tconst char *str1 = *(const char **)a;\n\tconst char *str2 = *(const char **)b;\n\treturn (strcmp(str1, str2));\n}\n\nstatic void\nallow_usage(boolean_t un, boolean_t requested, const char *msg)\n{\n\tconst char *opt_desc[] = {\n\t\t\"-h\", gettext(\"show this help message and exit\"),\n\t\t\"-l\", gettext(\"set permission locally\"),\n\t\t\"-d\", gettext(\"set permission for descents\"),\n\t\t\"-u\", gettext(\"set permission for user\"),\n\t\t\"-g\", gettext(\"set permission for group\"),\n\t\t\"-e\", gettext(\"set permission for everyone\"),\n\t\t\"-c\", gettext(\"set create time permission\"),\n\t\t\"-s\", gettext(\"define permission set\"),\n\t\t \n\t\t\"-r\", gettext(\"remove permissions recursively\"),\n\t};\n\tsize_t unallow_size = sizeof (opt_desc) / sizeof (char *);\n\tsize_t allow_size = unallow_size - 2;\n\tconst char *props[ZFS_NUM_PROPS];\n\tint i;\n\tsize_t count = 0;\n\tFILE *fp = requested ? stdout : stderr;\n\tzprop_desc_t *pdtbl = zfs_prop_get_table();\n\tconst char *fmt = gettext(\"%-16s %-14s\\t%s\\n\");\n\n\t(void) fprintf(fp, gettext(\"Usage: %s\\n\"), get_usage(un ? HELP_UNALLOW :\n\t    HELP_ALLOW));\n\t(void) fprintf(fp, gettext(\"Options:\\n\"));\n\tfor (i = 0; i < (un ? unallow_size : allow_size); i += 2) {\n\t\tconst char *opt = opt_desc[i];\n\t\tconst char *optdsc = opt_desc[i + 1];\n\t\t(void) fprintf(fp, gettext(\"  %-10s  %s\\n\"), opt, optdsc);\n\t}\n\n\t(void) fprintf(fp, gettext(\"\\nThe following permissions are \"\n\t    \"supported:\\n\\n\"));\n\t(void) fprintf(fp, fmt, gettext(\"NAME\"), gettext(\"TYPE\"),\n\t    gettext(\"NOTES\"));\n\tfor (i = 0; i < ZFS_NUM_DELEG_NOTES; i++) {\n\t\tconst char *perm_name = zfs_deleg_perm_tbl[i].z_perm;\n\t\tzfs_deleg_note_t perm_note = zfs_deleg_perm_tbl[i].z_note;\n\t\tconst char *perm_type = deleg_perm_type(perm_note);\n\t\tconst char *perm_comment = deleg_perm_comment(perm_note);\n\t\t(void) fprintf(fp, fmt, perm_name, perm_type, perm_comment);\n\t}\n\n\tfor (i = 0; i < ZFS_NUM_PROPS; i++) {\n\t\tzprop_desc_t *pd = &pdtbl[i];\n\t\tif (pd->pd_visible != B_TRUE)\n\t\t\tcontinue;\n\n\t\tif (pd->pd_attr == PROP_READONLY)\n\t\t\tcontinue;\n\n\t\tprops[count++] = pd->pd_name;\n\t}\n\tprops[count] = NULL;\n\n\tqsort(props, count, sizeof (char *), prop_cmp);\n\n\tfor (i = 0; i < count; i++)\n\t\t(void) fprintf(fp, fmt, props[i], gettext(\"property\"), \"\");\n\n\tif (msg != NULL)\n\t\t(void) fprintf(fp, gettext(\"\\nzfs: error: %s\"), msg);\n\n\texit(requested ? 0 : 2);\n}\n\nstatic inline const char *\nmunge_args(int argc, char **argv, boolean_t un, size_t expected_argc,\n    char **permsp)\n{\n\tif (un && argc == expected_argc - 1)\n\t\t*permsp = NULL;\n\telse if (argc == expected_argc)\n\t\t*permsp = argv[argc - 2];\n\telse\n\t\tallow_usage(un, B_FALSE,\n\t\t    gettext(\"wrong number of parameters\\n\"));\n\n\treturn (argv[argc - 1]);\n}\n\nstatic void\nparse_allow_args(int argc, char **argv, boolean_t un, struct allow_opts *opts)\n{\n\tint uge_sum = opts->user + opts->group + opts->everyone;\n\tint csuge_sum = opts->create + opts->set + uge_sum;\n\tint ldcsuge_sum = csuge_sum + opts->local + opts->descend;\n\tint all_sum = un ? ldcsuge_sum + opts->recursive : ldcsuge_sum;\n\n\tif (uge_sum > 1)\n\t\tallow_usage(un, B_FALSE,\n\t\t    gettext(\"-u, -g, and -e are mutually exclusive\\n\"));\n\n\tif (opts->prt_usage) {\n\t\tif (argc == 0 && all_sum == 0)\n\t\t\tallow_usage(un, B_TRUE, NULL);\n\t\telse\n\t\t\tusage(B_FALSE);\n\t}\n\n\tif (opts->set) {\n\t\tif (csuge_sum > 1)\n\t\t\tallow_usage(un, B_FALSE,\n\t\t\t    gettext(\"invalid options combined with -s\\n\"));\n\n\t\topts->dataset = munge_args(argc, argv, un, 3, &opts->perms);\n\t\tif (argv[0][0] != '@')\n\t\t\tallow_usage(un, B_FALSE,\n\t\t\t    gettext(\"invalid set name: missing '@' prefix\\n\"));\n\t\topts->who = argv[0];\n\t} else if (opts->create) {\n\t\tif (ldcsuge_sum > 1)\n\t\t\tallow_usage(un, B_FALSE,\n\t\t\t    gettext(\"invalid options combined with -c\\n\"));\n\t\topts->dataset = munge_args(argc, argv, un, 2, &opts->perms);\n\t} else if (opts->everyone) {\n\t\tif (csuge_sum > 1)\n\t\t\tallow_usage(un, B_FALSE,\n\t\t\t    gettext(\"invalid options combined with -e\\n\"));\n\t\topts->dataset = munge_args(argc, argv, un, 2, &opts->perms);\n\t} else if (uge_sum == 0 && argc > 0 && strcmp(argv[0], \"everyone\")\n\t    == 0) {\n\t\topts->everyone = B_TRUE;\n\t\targc--;\n\t\targv++;\n\t\topts->dataset = munge_args(argc, argv, un, 2, &opts->perms);\n\t} else if (argc == 1 && !un) {\n\t\topts->prt_perms = B_TRUE;\n\t\topts->dataset = argv[argc-1];\n\t} else {\n\t\topts->dataset = munge_args(argc, argv, un, 3, &opts->perms);\n\t\topts->who = argv[0];\n\t}\n\n\tif (!opts->local && !opts->descend) {\n\t\topts->local = B_TRUE;\n\t\topts->descend = B_TRUE;\n\t}\n}\n\nstatic void\nstore_allow_perm(zfs_deleg_who_type_t type, boolean_t local, boolean_t descend,\n    const char *who, char *perms, nvlist_t *top_nvl)\n{\n\tint i;\n\tchar ld[2] = { '\\0', '\\0' };\n\tchar who_buf[MAXNAMELEN + 32];\n\tchar base_type = '\\0';\n\tchar set_type = '\\0';\n\tnvlist_t *base_nvl = NULL;\n\tnvlist_t *set_nvl = NULL;\n\tnvlist_t *nvl;\n\n\tif (nvlist_alloc(&base_nvl, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\tif (nvlist_alloc(&set_nvl, NV_UNIQUE_NAME, 0) !=  0)\n\t\tnomem();\n\n\tswitch (type) {\n\tcase ZFS_DELEG_NAMED_SET_SETS:\n\tcase ZFS_DELEG_NAMED_SET:\n\t\tset_type = ZFS_DELEG_NAMED_SET_SETS;\n\t\tbase_type = ZFS_DELEG_NAMED_SET;\n\t\tld[0] = ZFS_DELEG_NA;\n\t\tbreak;\n\tcase ZFS_DELEG_CREATE_SETS:\n\tcase ZFS_DELEG_CREATE:\n\t\tset_type = ZFS_DELEG_CREATE_SETS;\n\t\tbase_type = ZFS_DELEG_CREATE;\n\t\tld[0] = ZFS_DELEG_NA;\n\t\tbreak;\n\tcase ZFS_DELEG_USER_SETS:\n\tcase ZFS_DELEG_USER:\n\t\tset_type = ZFS_DELEG_USER_SETS;\n\t\tbase_type = ZFS_DELEG_USER;\n\t\tif (local)\n\t\t\tld[0] = ZFS_DELEG_LOCAL;\n\t\tif (descend)\n\t\t\tld[1] = ZFS_DELEG_DESCENDENT;\n\t\tbreak;\n\tcase ZFS_DELEG_GROUP_SETS:\n\tcase ZFS_DELEG_GROUP:\n\t\tset_type = ZFS_DELEG_GROUP_SETS;\n\t\tbase_type = ZFS_DELEG_GROUP;\n\t\tif (local)\n\t\t\tld[0] = ZFS_DELEG_LOCAL;\n\t\tif (descend)\n\t\t\tld[1] = ZFS_DELEG_DESCENDENT;\n\t\tbreak;\n\tcase ZFS_DELEG_EVERYONE_SETS:\n\tcase ZFS_DELEG_EVERYONE:\n\t\tset_type = ZFS_DELEG_EVERYONE_SETS;\n\t\tbase_type = ZFS_DELEG_EVERYONE;\n\t\tif (local)\n\t\t\tld[0] = ZFS_DELEG_LOCAL;\n\t\tif (descend)\n\t\t\tld[1] = ZFS_DELEG_DESCENDENT;\n\t\tbreak;\n\n\tdefault:\n\t\tassert(set_type != '\\0' && base_type != '\\0');\n\t}\n\n\tif (perms != NULL) {\n\t\tchar *curr = perms;\n\t\tchar *end = curr + strlen(perms);\n\n\t\twhile (curr < end) {\n\t\t\tchar *delim = strchr(curr, ',');\n\t\t\tif (delim == NULL)\n\t\t\t\tdelim = end;\n\t\t\telse\n\t\t\t\t*delim = '\\0';\n\n\t\t\tif (curr[0] == '@')\n\t\t\t\tnvl = set_nvl;\n\t\t\telse\n\t\t\t\tnvl = base_nvl;\n\n\t\t\t(void) nvlist_add_boolean(nvl, curr);\n\t\t\tif (delim != end)\n\t\t\t\t*delim = ',';\n\t\t\tcurr = delim + 1;\n\t\t}\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tchar locality = ld[i];\n\t\t\tif (locality == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!nvlist_empty(base_nvl)) {\n\t\t\t\tif (who != NULL)\n\t\t\t\t\t(void) snprintf(who_buf,\n\t\t\t\t\t    sizeof (who_buf), \"%c%c$%s\",\n\t\t\t\t\t    base_type, locality, who);\n\t\t\t\telse\n\t\t\t\t\t(void) snprintf(who_buf,\n\t\t\t\t\t    sizeof (who_buf), \"%c%c$\",\n\t\t\t\t\t    base_type, locality);\n\n\t\t\t\t(void) nvlist_add_nvlist(top_nvl, who_buf,\n\t\t\t\t    base_nvl);\n\t\t\t}\n\n\n\t\t\tif (!nvlist_empty(set_nvl)) {\n\t\t\t\tif (who != NULL)\n\t\t\t\t\t(void) snprintf(who_buf,\n\t\t\t\t\t    sizeof (who_buf), \"%c%c$%s\",\n\t\t\t\t\t    set_type, locality, who);\n\t\t\t\telse\n\t\t\t\t\t(void) snprintf(who_buf,\n\t\t\t\t\t    sizeof (who_buf), \"%c%c$\",\n\t\t\t\t\t    set_type, locality);\n\n\t\t\t\t(void) nvlist_add_nvlist(top_nvl, who_buf,\n\t\t\t\t    set_nvl);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tchar locality = ld[i];\n\t\t\tif (locality == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (who != NULL)\n\t\t\t\t(void) snprintf(who_buf, sizeof (who_buf),\n\t\t\t\t    \"%c%c$%s\", base_type, locality, who);\n\t\t\telse\n\t\t\t\t(void) snprintf(who_buf, sizeof (who_buf),\n\t\t\t\t    \"%c%c$\", base_type, locality);\n\t\t\t(void) nvlist_add_boolean(top_nvl, who_buf);\n\n\t\t\tif (who != NULL)\n\t\t\t\t(void) snprintf(who_buf, sizeof (who_buf),\n\t\t\t\t    \"%c%c$%s\", set_type, locality, who);\n\t\t\telse\n\t\t\t\t(void) snprintf(who_buf, sizeof (who_buf),\n\t\t\t\t    \"%c%c$\", set_type, locality);\n\t\t\t(void) nvlist_add_boolean(top_nvl, who_buf);\n\t\t}\n\t}\n}\n\nstatic int\nconstruct_fsacl_list(boolean_t un, struct allow_opts *opts, nvlist_t **nvlp)\n{\n\tif (nvlist_alloc(nvlp, NV_UNIQUE_NAME, 0) != 0)\n\t\tnomem();\n\n\tif (opts->set) {\n\t\tstore_allow_perm(ZFS_DELEG_NAMED_SET, opts->local,\n\t\t    opts->descend, opts->who, opts->perms, *nvlp);\n\t} else if (opts->create) {\n\t\tstore_allow_perm(ZFS_DELEG_CREATE, opts->local,\n\t\t    opts->descend, NULL, opts->perms, *nvlp);\n\t} else if (opts->everyone) {\n\t\tstore_allow_perm(ZFS_DELEG_EVERYONE, opts->local,\n\t\t    opts->descend, NULL, opts->perms, *nvlp);\n\t} else {\n\t\tchar *curr = opts->who;\n\t\tchar *end = curr + strlen(curr);\n\n\t\twhile (curr < end) {\n\t\t\tconst char *who;\n\t\t\tzfs_deleg_who_type_t who_type = ZFS_DELEG_WHO_UNKNOWN;\n\t\t\tchar *endch;\n\t\t\tchar *delim = strchr(curr, ',');\n\t\t\tchar errbuf[256];\n\t\t\tchar id[64];\n\t\t\tstruct passwd *p = NULL;\n\t\t\tstruct group *g = NULL;\n\n\t\t\tuid_t rid;\n\t\t\tif (delim == NULL)\n\t\t\t\tdelim = end;\n\t\t\telse\n\t\t\t\t*delim = '\\0';\n\n\t\t\trid = (uid_t)strtol(curr, &endch, 0);\n\t\t\tif (opts->user) {\n\t\t\t\twho_type = ZFS_DELEG_USER;\n\t\t\t\tif (*endch != '\\0')\n\t\t\t\t\tp = getpwnam(curr);\n\t\t\t\telse\n\t\t\t\t\tp = getpwuid(rid);\n\n\t\t\t\tif (p != NULL)\n\t\t\t\t\trid = p->pw_uid;\n\t\t\t\telse if (*endch != '\\0') {\n\t\t\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t\t\t    gettext(\"invalid user %s\\n\"), curr);\n\t\t\t\t\tallow_usage(un, B_TRUE, errbuf);\n\t\t\t\t}\n\t\t\t} else if (opts->group) {\n\t\t\t\twho_type = ZFS_DELEG_GROUP;\n\t\t\t\tif (*endch != '\\0')\n\t\t\t\t\tg = getgrnam(curr);\n\t\t\t\telse\n\t\t\t\t\tg = getgrgid(rid);\n\n\t\t\t\tif (g != NULL)\n\t\t\t\t\trid = g->gr_gid;\n\t\t\t\telse if (*endch != '\\0') {\n\t\t\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t\t\t    gettext(\"invalid group %s\\n\"),\n\t\t\t\t\t    curr);\n\t\t\t\t\tallow_usage(un, B_TRUE, errbuf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (*endch != '\\0') {\n\t\t\t\t\tp = getpwnam(curr);\n\t\t\t\t} else {\n\t\t\t\t\tp = getpwuid(rid);\n\t\t\t\t}\n\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tif (*endch != '\\0') {\n\t\t\t\t\t\tg = getgrnam(curr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg = getgrgid(rid);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (p != NULL) {\n\t\t\t\t\twho_type = ZFS_DELEG_USER;\n\t\t\t\t\trid = p->pw_uid;\n\t\t\t\t} else if (g != NULL) {\n\t\t\t\t\twho_type = ZFS_DELEG_GROUP;\n\t\t\t\t\trid = g->gr_gid;\n\t\t\t\t} else {\n\t\t\t\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t\t\t\t    gettext(\"invalid user/group %s\\n\"),\n\t\t\t\t\t    curr);\n\t\t\t\t\tallow_usage(un, B_TRUE, errbuf);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(void) sprintf(id, \"%u\", rid);\n\t\t\twho = id;\n\n\t\t\tstore_allow_perm(who_type, opts->local,\n\t\t\t    opts->descend, who, opts->perms, *nvlp);\n\t\t\tcurr = delim + 1;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic void\nprint_set_creat_perms(uu_avl_t *who_avl)\n{\n\tconst char *sc_title[] = {\n\t\tgettext(\"Permission sets:\\n\"),\n\t\tgettext(\"Create time permissions:\\n\"),\n\t\tNULL\n\t};\n\twho_perm_node_t *who_node = NULL;\n\tint prev_weight = -1;\n\n\tfor (who_node = uu_avl_first(who_avl); who_node != NULL;\n\t    who_node = uu_avl_next(who_avl, who_node)) {\n\t\tuu_avl_t *avl = who_node->who_perm.who_deleg_perm_avl;\n\t\tzfs_deleg_who_type_t who_type = who_node->who_perm.who_type;\n\t\tconst char *who_name = who_node->who_perm.who_name;\n\t\tint weight = who_type2weight(who_type);\n\t\tboolean_t first = B_TRUE;\n\t\tdeleg_perm_node_t *deleg_node;\n\n\t\tif (prev_weight != weight) {\n\t\t\t(void) printf(\"%s\", sc_title[weight]);\n\t\t\tprev_weight = weight;\n\t\t}\n\n\t\tif (who_name == NULL || strnlen(who_name, 1) == 0)\n\t\t\t(void) printf(\"\\t\");\n\t\telse\n\t\t\t(void) printf(\"\\t%s \", who_name);\n\n\t\tfor (deleg_node = uu_avl_first(avl); deleg_node != NULL;\n\t\t    deleg_node = uu_avl_next(avl, deleg_node)) {\n\t\t\tif (first) {\n\t\t\t\t(void) printf(\"%s\",\n\t\t\t\t    deleg_node->dpn_perm.dp_name);\n\t\t\t\tfirst = B_FALSE;\n\t\t\t} else\n\t\t\t\t(void) printf(\",%s\",\n\t\t\t\t    deleg_node->dpn_perm.dp_name);\n\t\t}\n\n\t\t(void) printf(\"\\n\");\n\t}\n}\n\nstatic void\nprint_uge_deleg_perms(uu_avl_t *who_avl, boolean_t local, boolean_t descend,\n    const char *title)\n{\n\twho_perm_node_t *who_node = NULL;\n\tboolean_t prt_title = B_TRUE;\n\tuu_avl_walk_t *walk;\n\n\tif ((walk = uu_avl_walk_start(who_avl, UU_WALK_ROBUST)) == NULL)\n\t\tnomem();\n\n\twhile ((who_node = uu_avl_walk_next(walk)) != NULL) {\n\t\tconst char *who_name = who_node->who_perm.who_name;\n\t\tconst char *nice_who_name = who_node->who_perm.who_ug_name;\n\t\tuu_avl_t *avl = who_node->who_perm.who_deleg_perm_avl;\n\t\tzfs_deleg_who_type_t who_type = who_node->who_perm.who_type;\n\t\tchar delim = ' ';\n\t\tdeleg_perm_node_t *deleg_node;\n\t\tboolean_t prt_who = B_TRUE;\n\n\t\tfor (deleg_node = uu_avl_first(avl);\n\t\t    deleg_node != NULL;\n\t\t    deleg_node = uu_avl_next(avl, deleg_node)) {\n\t\t\tif (local != deleg_node->dpn_perm.dp_local ||\n\t\t\t    descend != deleg_node->dpn_perm.dp_descend)\n\t\t\t\tcontinue;\n\n\t\t\tif (prt_who) {\n\t\t\t\tconst char *who = NULL;\n\t\t\t\tif (prt_title) {\n\t\t\t\t\tprt_title = B_FALSE;\n\t\t\t\t\t(void) printf(\"%s\", title);\n\t\t\t\t}\n\n\t\t\t\tswitch (who_type) {\n\t\t\t\tcase ZFS_DELEG_USER_SETS:\n\t\t\t\tcase ZFS_DELEG_USER:\n\t\t\t\t\twho = gettext(\"user\");\n\t\t\t\t\tif (nice_who_name)\n\t\t\t\t\t\twho_name  = nice_who_name;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZFS_DELEG_GROUP_SETS:\n\t\t\t\tcase ZFS_DELEG_GROUP:\n\t\t\t\t\twho = gettext(\"group\");\n\t\t\t\t\tif (nice_who_name)\n\t\t\t\t\t\twho_name  = nice_who_name;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZFS_DELEG_EVERYONE_SETS:\n\t\t\t\tcase ZFS_DELEG_EVERYONE:\n\t\t\t\t\twho = gettext(\"everyone\");\n\t\t\t\t\twho_name = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tassert(who != NULL);\n\t\t\t\t}\n\n\t\t\t\tprt_who = B_FALSE;\n\t\t\t\tif (who_name == NULL)\n\t\t\t\t\t(void) printf(\"\\t%s\", who);\n\t\t\t\telse\n\t\t\t\t\t(void) printf(\"\\t%s %s\", who, who_name);\n\t\t\t}\n\n\t\t\t(void) printf(\"%c%s\", delim,\n\t\t\t    deleg_node->dpn_perm.dp_name);\n\t\t\tdelim = ',';\n\t\t}\n\n\t\tif (!prt_who)\n\t\t\t(void) printf(\"\\n\");\n\t}\n\n\tuu_avl_walk_end(walk);\n}\n\nstatic void\nprint_fs_perms(fs_perm_set_t *fspset)\n{\n\tfs_perm_node_t *node = NULL;\n\tchar buf[MAXNAMELEN + 32];\n\tconst char *dsname = buf;\n\n\tfor (node = uu_list_first(fspset->fsps_list); node != NULL;\n\t    node = uu_list_next(fspset->fsps_list, node)) {\n\t\tuu_avl_t *sc_avl = node->fspn_fsperm.fsp_sc_avl;\n\t\tuu_avl_t *uge_avl = node->fspn_fsperm.fsp_uge_avl;\n\t\tint left = 0;\n\n\t\t(void) snprintf(buf, sizeof (buf),\n\t\t    gettext(\"---- Permissions on %s \"),\n\t\t    node->fspn_fsperm.fsp_name);\n\t\t(void) printf(\"%s\", dsname);\n\t\tleft = 70 - strlen(buf);\n\t\twhile (left-- > 0)\n\t\t\t(void) printf(\"-\");\n\t\t(void) printf(\"\\n\");\n\n\t\tprint_set_creat_perms(sc_avl);\n\t\tprint_uge_deleg_perms(uge_avl, B_TRUE, B_FALSE,\n\t\t    gettext(\"Local permissions:\\n\"));\n\t\tprint_uge_deleg_perms(uge_avl, B_FALSE, B_TRUE,\n\t\t    gettext(\"Descendent permissions:\\n\"));\n\t\tprint_uge_deleg_perms(uge_avl, B_TRUE, B_TRUE,\n\t\t    gettext(\"Local+Descendent permissions:\\n\"));\n\t}\n}\n\nstatic fs_perm_set_t fs_perm_set = { NULL, NULL, NULL, NULL };\n\nstruct deleg_perms {\n\tboolean_t un;\n\tnvlist_t *nvl;\n};\n\nstatic int\nset_deleg_perms(zfs_handle_t *zhp, void *data)\n{\n\tstruct deleg_perms *perms = (struct deleg_perms *)data;\n\tzfs_type_t zfs_type = zfs_get_type(zhp);\n\n\tif (zfs_type != ZFS_TYPE_FILESYSTEM && zfs_type != ZFS_TYPE_VOLUME)\n\t\treturn (0);\n\n\treturn (zfs_set_fsacl(zhp, perms->un, perms->nvl));\n}\n\nstatic int\nzfs_do_allow_unallow_impl(int argc, char **argv, boolean_t un)\n{\n\tzfs_handle_t *zhp;\n\tnvlist_t *perm_nvl = NULL;\n\tnvlist_t *update_perm_nvl = NULL;\n\tint error = 1;\n\tint c;\n\tstruct allow_opts opts = { 0 };\n\n\tconst char *optstr = un ? \"ldugecsrh\" : \"ldugecsh\";\n\n\t \n\twhile ((c = getopt(argc, argv, optstr)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\topts.local = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\topts.descend = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\topts.user = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\topts.group = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\topts.everyone = B_TRUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\topts.set = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\topts.create = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\topts.recursive = B_TRUE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\topts.prt_usage = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tparse_allow_args(argc, argv, un, &opts);\n\n\t \n\tif ((zhp = zfs_open(g_zfs, opts.dataset, ZFS_TYPE_FILESYSTEM |\n\t    ZFS_TYPE_VOLUME)) == NULL) {\n\t\t(void) fprintf(stderr, \"Failed to open dataset: %s\\n\",\n\t\t    opts.dataset);\n\t\treturn (-1);\n\t}\n\n\tif (zfs_get_fsacl(zhp, &perm_nvl) != 0)\n\t\tgoto cleanup2;\n\n\tfs_perm_set_init(&fs_perm_set);\n\tif (parse_fs_perm_set(&fs_perm_set, perm_nvl) != 0) {\n\t\t(void) fprintf(stderr, \"Failed to parse fsacl permissions\\n\");\n\t\tgoto cleanup1;\n\t}\n\n\tif (opts.prt_perms)\n\t\tprint_fs_perms(&fs_perm_set);\n\telse {\n\t\t(void) construct_fsacl_list(un, &opts, &update_perm_nvl);\n\t\tif (zfs_set_fsacl(zhp, un, update_perm_nvl) != 0)\n\t\t\tgoto cleanup0;\n\n\t\tif (un && opts.recursive) {\n\t\t\tstruct deleg_perms data = { un, update_perm_nvl };\n\t\t\tif (zfs_iter_filesystems_v2(zhp, 0, set_deleg_perms,\n\t\t\t    &data) != 0)\n\t\t\t\tgoto cleanup0;\n\t\t}\n\t}\n\n\terror = 0;\n\ncleanup0:\n\tnvlist_free(perm_nvl);\n\tnvlist_free(update_perm_nvl);\ncleanup1:\n\tfs_perm_set_fini(&fs_perm_set);\ncleanup2:\n\tzfs_close(zhp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_do_allow(int argc, char **argv)\n{\n\treturn (zfs_do_allow_unallow_impl(argc, argv, B_FALSE));\n}\n\nstatic int\nzfs_do_unallow(int argc, char **argv)\n{\n\treturn (zfs_do_allow_unallow_impl(argc, argv, B_TRUE));\n}\n\nstatic int\nzfs_do_hold_rele_impl(int argc, char **argv, boolean_t holding)\n{\n\tint errors = 0;\n\tint i;\n\tconst char *tag;\n\tboolean_t recursive = B_FALSE;\n\tconst char *opts = holding ? \"rt\" : \"r\";\n\tint c;\n\n\t \n\twhile ((c = getopt(argc, argv, opts)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\trecursive = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 2)\n\t\tusage(B_FALSE);\n\n\ttag = argv[0];\n\t--argc;\n\t++argv;\n\n\tif (holding && tag[0] == '.') {\n\t\t \n\t\t(void) fprintf(stderr, gettext(\"tag may not start with '.'\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tfor (i = 0; i < argc; ++i) {\n\t\tzfs_handle_t *zhp;\n\t\tchar parent[ZFS_MAX_DATASET_NAME_LEN];\n\t\tconst char *delim;\n\t\tchar *path = argv[i];\n\n\t\tdelim = strchr(path, '@');\n\t\tif (delim == NULL) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'%s' is not a snapshot\\n\"), path);\n\t\t\t++errors;\n\t\t\tcontinue;\n\t\t}\n\t\t(void) strlcpy(parent, path, MIN(sizeof (parent),\n\t\t    delim - path + 1));\n\n\t\tzhp = zfs_open(g_zfs, parent,\n\t\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\t\tif (zhp == NULL) {\n\t\t\t++errors;\n\t\t\tcontinue;\n\t\t}\n\t\tif (holding) {\n\t\t\tif (zfs_hold(zhp, delim+1, tag, recursive, -1) != 0)\n\t\t\t\t++errors;\n\t\t} else {\n\t\t\tif (zfs_release(zhp, delim+1, tag, recursive) != 0)\n\t\t\t\t++errors;\n\t\t}\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (errors != 0);\n}\n\n \nstatic int\nzfs_do_hold(int argc, char **argv)\n{\n\treturn (zfs_do_hold_rele_impl(argc, argv, B_TRUE));\n}\n\n \nstatic int\nzfs_do_release(int argc, char **argv)\n{\n\treturn (zfs_do_hold_rele_impl(argc, argv, B_FALSE));\n}\n\ntypedef struct holds_cbdata {\n\tboolean_t\tcb_recursive;\n\tconst char\t*cb_snapname;\n\tnvlist_t\t**cb_nvlp;\n\tsize_t\t\tcb_max_namelen;\n\tsize_t\t\tcb_max_taglen;\n} holds_cbdata_t;\n\n#define\tSTRFTIME_FMT_STR \"%a %b %e %H:%M %Y\"\n#define\tDATETIME_BUF_LEN (32)\n \nstatic void\nprint_holds(boolean_t scripted, int nwidth, int tagwidth, nvlist_t *nvl,\n    boolean_t parsable)\n{\n\tint i;\n\tnvpair_t *nvp = NULL;\n\tconst char *const hdr_cols[] = { \"NAME\", \"TAG\", \"TIMESTAMP\" };\n\tconst char *col;\n\n\tif (!scripted) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tcol = gettext(hdr_cols[i]);\n\t\t\tif (i < 2)\n\t\t\t\t(void) printf(\"%-*s  \", i ? tagwidth : nwidth,\n\t\t\t\t    col);\n\t\t\telse\n\t\t\t\t(void) printf(\"%s\\n\", col);\n\t\t}\n\t}\n\n\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {\n\t\tconst char *zname = nvpair_name(nvp);\n\t\tnvlist_t *nvl2;\n\t\tnvpair_t *nvp2 = NULL;\n\t\t(void) nvpair_value_nvlist(nvp, &nvl2);\n\t\twhile ((nvp2 = nvlist_next_nvpair(nvl2, nvp2)) != NULL) {\n\t\t\tchar tsbuf[DATETIME_BUF_LEN];\n\t\t\tconst char *tagname = nvpair_name(nvp2);\n\t\t\tuint64_t val = 0;\n\t\t\ttime_t time;\n\t\t\tstruct tm t;\n\n\t\t\t(void) nvpair_value_uint64(nvp2, &val);\n\t\t\ttime = (time_t)val;\n\t\t\t(void) localtime_r(&time, &t);\n\t\t\t(void) strftime(tsbuf, DATETIME_BUF_LEN,\n\t\t\t    gettext(STRFTIME_FMT_STR), &t);\n\n\t\t\tif (scripted) {\n\t\t\t\tif (parsable) {\n\t\t\t\t\t(void) printf(\"%s\\t%s\\t%ld\\n\", zname,\n\t\t\t\t\t    tagname, time);\n\t\t\t\t} else {\n\t\t\t\t\t(void) printf(\"%s\\t%s\\t%s\\n\", zname,\n\t\t\t\t\t    tagname, tsbuf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (parsable) {\n\t\t\t\t\t(void) printf(\"%-*s  %-*s  %ld\\n\",\n\t\t\t\t\t    nwidth, zname, tagwidth,\n\t\t\t\t\t    tagname, time);\n\t\t\t\t} else {\n\t\t\t\t\t(void) printf(\"%-*s  %-*s  %s\\n\",\n\t\t\t\t\t    nwidth, zname, tagwidth,\n\t\t\t\t\t    tagname, tsbuf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int\nholds_callback(zfs_handle_t *zhp, void *data)\n{\n\tholds_cbdata_t *cbp = data;\n\tnvlist_t *top_nvl = *cbp->cb_nvlp;\n\tnvlist_t *nvl = NULL;\n\tnvpair_t *nvp = NULL;\n\tconst char *zname = zfs_get_name(zhp);\n\tsize_t znamelen = strlen(zname);\n\n\tif (cbp->cb_recursive) {\n\t\tconst char *snapname;\n\t\tchar *delim  = strchr(zname, '@');\n\t\tif (delim == NULL)\n\t\t\treturn (0);\n\n\t\tsnapname = delim + 1;\n\t\tif (strcmp(cbp->cb_snapname, snapname))\n\t\t\treturn (0);\n\t}\n\n\tif (zfs_get_holds(zhp, &nvl) != 0)\n\t\treturn (-1);\n\n\tif (znamelen > cbp->cb_max_namelen)\n\t\tcbp->cb_max_namelen  = znamelen;\n\n\twhile ((nvp = nvlist_next_nvpair(nvl, nvp)) != NULL) {\n\t\tconst char *tag = nvpair_name(nvp);\n\t\tsize_t taglen = strlen(tag);\n\t\tif (taglen > cbp->cb_max_taglen)\n\t\t\tcbp->cb_max_taglen  = taglen;\n\t}\n\n\treturn (nvlist_add_nvlist(top_nvl, zname, nvl));\n}\n\n \nstatic int\nzfs_do_holds(int argc, char **argv)\n{\n\tint c;\n\tboolean_t errors = B_FALSE;\n\tboolean_t scripted = B_FALSE;\n\tboolean_t recursive = B_FALSE;\n\tboolean_t parsable = B_FALSE;\n\n\tint types = ZFS_TYPE_SNAPSHOT;\n\tholds_cbdata_t cb = { 0 };\n\n\tint limit = 0;\n\tint ret = 0;\n\tint flags = 0;\n\n\t \n\twhile ((c = getopt(argc, argv, \"rHp\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'r':\n\t\t\trecursive = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tscripted = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tparsable = B_TRUE;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (recursive) {\n\t\ttypes |= ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME;\n\t\tflags |= ZFS_ITER_RECURSE;\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1)\n\t\tusage(B_FALSE);\n\n\tnvlist_t *nvl = fnvlist_alloc();\n\n\tfor (int i = 0; i < argc; ++i) {\n\t\tchar *snapshot = argv[i];\n\t\tconst char *delim;\n\t\tconst char *snapname;\n\n\t\tdelim = strchr(snapshot, '@');\n\t\tif (delim == NULL) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'%s' is not a snapshot\\n\"), snapshot);\n\t\t\terrors = B_TRUE;\n\t\t\tcontinue;\n\t\t}\n\t\tsnapname = delim + 1;\n\t\tif (recursive)\n\t\t\tsnapshot[delim - snapshot] = '\\0';\n\n\t\tcb.cb_recursive = recursive;\n\t\tcb.cb_snapname = snapname;\n\t\tcb.cb_nvlp = &nvl;\n\n\t\t \n\t\tret = zfs_for_each(1, argv + i, flags, types, NULL, NULL, limit,\n\t\t    holds_callback, &cb);\n\t\tif (ret != 0)\n\t\t\terrors = B_TRUE;\n\t}\n\n\t \n\tprint_holds(scripted, cb.cb_max_namelen, cb.cb_max_taglen, nvl,\n\t    parsable);\n\n\tif (nvlist_empty(nvl))\n\t\t(void) fprintf(stderr, gettext(\"no datasets available\\n\"));\n\n\tnvlist_free(nvl);\n\n\treturn (errors);\n}\n\n#define\tCHECK_SPINNER 30\n#define\tSPINNER_TIME 3\t\t \n#define\tMOUNT_TIME 1\t\t \n\ntypedef struct get_all_state {\n\tboolean_t\tga_verbose;\n\tget_all_cb_t\t*ga_cbp;\n} get_all_state_t;\n\nstatic int\nget_one_dataset(zfs_handle_t *zhp, void *data)\n{\n\tstatic const char *const spin[] = { \"-\", \"\\\\\", \"|\", \"/\" };\n\tstatic int spinval = 0;\n\tstatic int spincheck = 0;\n\tstatic time_t last_spin_time = (time_t)0;\n\tget_all_state_t *state = data;\n\tzfs_type_t type = zfs_get_type(zhp);\n\n\tif (state->ga_verbose) {\n\t\tif (--spincheck < 0) {\n\t\t\ttime_t now = time(NULL);\n\t\t\tif (last_spin_time + SPINNER_TIME < now) {\n\t\t\t\tupdate_progress(spin[spinval++ % 4]);\n\t\t\t\tlast_spin_time = now;\n\t\t\t}\n\t\t\tspincheck = CHECK_SPINNER;\n\t\t}\n\t}\n\n\t \n\tif (zfs_iter_filesystems_v2(zhp, 0, get_one_dataset, data) != 0) {\n\t\tzfs_close(zhp);\n\t\treturn (1);\n\t}\n\n\t \n\tif ((type & ZFS_TYPE_FILESYSTEM) == 0) {\n\t\tzfs_close(zhp);\n\t\treturn (0);\n\t}\n\tlibzfs_add_handle(state->ga_cbp, zhp);\n\tassert(state->ga_cbp->cb_used <= state->ga_cbp->cb_alloc);\n\n\treturn (0);\n}\n\nstatic void\nget_all_datasets(get_all_cb_t *cbp, boolean_t verbose)\n{\n\tget_all_state_t state = {\n\t    .ga_verbose = verbose,\n\t    .ga_cbp = cbp\n\t};\n\n\tif (verbose)\n\t\tset_progress_header(gettext(\"Reading ZFS config\"));\n\t(void) zfs_iter_root(g_zfs, get_one_dataset, &state);\n\n\tif (verbose)\n\t\tfinish_progress(gettext(\"done.\"));\n}\n\n \ntypedef enum { OP_SHARE, OP_MOUNT } share_mount_op_t;\n\ntypedef struct share_mount_state {\n\tshare_mount_op_t\tsm_op;\n\tboolean_t\tsm_verbose;\n\tint\tsm_flags;\n\tchar\t*sm_options;\n\tenum sa_protocol\tsm_proto;  \n\tpthread_mutex_t\tsm_lock;  \n\tuint_t\tsm_total;  \n\tuint_t\tsm_done;  \n\tint\tsm_status;  \n} share_mount_state_t;\n\n \nstatic int\nshare_mount_one(zfs_handle_t *zhp, int op, int flags, enum sa_protocol protocol,\n    boolean_t explicit, const char *options)\n{\n\tchar mountpoint[ZFS_MAXPROPLEN];\n\tchar shareopts[ZFS_MAXPROPLEN];\n\tchar smbshareopts[ZFS_MAXPROPLEN];\n\tconst char *cmdname = op == OP_SHARE ? \"share\" : \"mount\";\n\tstruct mnttab mnt;\n\tuint64_t zoned, canmount;\n\tboolean_t shared_nfs, shared_smb;\n\n\tassert(zfs_get_type(zhp) & ZFS_TYPE_FILESYSTEM);\n\n\t \n\tzoned = zfs_prop_get_int(zhp, ZFS_PROP_ZONED);\n\n\tif (zoned && getzoneid() == GLOBAL_ZONEID) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"dataset is exported to a local zone\\n\"), cmdname,\n\t\t    zfs_get_name(zhp));\n\t\treturn (1);\n\n\t} else if (!zoned && getzoneid() != GLOBAL_ZONEID) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"permission denied\\n\"), cmdname,\n\t\t    zfs_get_name(zhp));\n\t\treturn (1);\n\t}\n\n\t \n\tverify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mountpoint,\n\t    sizeof (mountpoint), NULL, NULL, 0, B_FALSE) == 0);\n\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS, shareopts,\n\t    sizeof (shareopts), NULL, NULL, 0, B_FALSE) == 0);\n\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB, smbshareopts,\n\t    sizeof (smbshareopts), NULL, NULL, 0, B_FALSE) == 0);\n\n\tif (op == OP_SHARE && strcmp(shareopts, \"off\") == 0 &&\n\t    strcmp(smbshareopts, \"off\") == 0) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot share '%s': \"\n\t\t    \"legacy share\\n\"), zfs_get_name(zhp));\n\t\t(void) fprintf(stderr, gettext(\"use exports(5) or \"\n\t\t    \"smb.conf(5) to share this filesystem, or set \"\n\t\t    \"the sharenfs or sharesmb property\\n\"));\n\t\treturn (1);\n\t}\n\n\t \n\tif (strcmp(mountpoint, \"legacy\") == 0) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"legacy mountpoint\\n\"), cmdname, zfs_get_name(zhp));\n\t\t(void) fprintf(stderr, gettext(\"use %s(8) to \"\n\t\t    \"%s this filesystem\\n\"), cmdname, cmdname);\n\t\treturn (1);\n\t}\n\n\tif (strcmp(mountpoint, \"none\") == 0) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': no \"\n\t\t    \"mountpoint set\\n\"), cmdname, zfs_get_name(zhp));\n\t\treturn (1);\n\t}\n\n\t \n\tcanmount = zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT);\n\tif (canmount == ZFS_CANMOUNT_OFF) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"'canmount' property is set to 'off'\\n\"), cmdname,\n\t\t    zfs_get_name(zhp));\n\t\treturn (1);\n\t} else if (canmount == ZFS_CANMOUNT_NOAUTO && !explicit) {\n\t\t \n\t\tif (op == OP_MOUNT)\n\t\t\treturn (0);\n\t\tif (op == OP_SHARE && !zfs_is_mounted(zhp, NULL)) {\n\t\t\t \n\t\t\tzfs_unshare(zhp, mountpoint, NULL);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t \n\tif ((flags & MS_CRYPT) == 0 &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_ENCRYPTION) != ZIO_CRYPT_OFF &&\n\t    zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS) ==\n\t    ZFS_KEYSTATUS_UNAVAILABLE) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"encryption key not loaded\\n\"), cmdname, zfs_get_name(zhp));\n\t\treturn (1);\n\t}\n\n\t \n\tif (zfs_prop_get_int(zhp, ZFS_PROP_INCONSISTENT) &&\n\t    zfs_prop_get(zhp, ZFS_PROP_RECEIVE_RESUME_TOKEN,\n\t    NULL, 0, NULL, NULL, 0, B_TRUE) == 0) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"Contains partially-completed state from \"\n\t\t    \"\\\"zfs receive -s\\\", which can be resumed with \"\n\t\t    \"\\\"zfs send -t\\\"\\n\"),\n\t\t    cmdname, zfs_get_name(zhp));\n\t\treturn (1);\n\t}\n\n\tif (zfs_prop_get_int(zhp, ZFS_PROP_REDACTED) && !(flags & MS_FORCE)) {\n\t\tif (!explicit)\n\t\t\treturn (0);\n\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': \"\n\t\t    \"Dataset is not complete, was created by receiving \"\n\t\t    \"a redacted zfs send stream.\\n\"), cmdname,\n\t\t    zfs_get_name(zhp));\n\t\treturn (1);\n\t}\n\n\t \n\tswitch (op) {\n\tcase OP_SHARE: {\n\t\tenum sa_protocol prot[] = {SA_PROTOCOL_NFS, SA_NO_PROTOCOL};\n\t\tshared_nfs = zfs_is_shared(zhp, NULL, prot);\n\t\t*prot = SA_PROTOCOL_SMB;\n\t\tshared_smb = zfs_is_shared(zhp, NULL, prot);\n\n\t\tif ((shared_nfs && shared_smb) ||\n\t\t    (shared_nfs && strcmp(shareopts, \"on\") == 0 &&\n\t\t    strcmp(smbshareopts, \"off\") == 0) ||\n\t\t    (shared_smb && strcmp(smbshareopts, \"on\") == 0 &&\n\t\t    strcmp(shareopts, \"off\") == 0)) {\n\t\t\tif (!explicit)\n\t\t\t\treturn (0);\n\n\t\t\t(void) fprintf(stderr, gettext(\"cannot share \"\n\t\t\t    \"'%s': filesystem already shared\\n\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (!zfs_is_mounted(zhp, NULL) &&\n\t\t    zfs_mount(zhp, NULL, flags) != 0)\n\t\t\treturn (1);\n\n\t\t*prot = protocol;\n\t\tif (zfs_share(zhp, protocol == SA_NO_PROTOCOL ? NULL : prot))\n\t\t\treturn (1);\n\n\t}\n\t\tbreak;\n\n\tcase OP_MOUNT:\n\t\tmnt.mnt_mntopts = (char *)(options ?: \"\");\n\n\t\tif (!hasmntopt(&mnt, MNTOPT_REMOUNT) &&\n\t\t    zfs_is_mounted(zhp, NULL)) {\n\t\t\tif (!explicit)\n\t\t\t\treturn (0);\n\n\t\t\t(void) fprintf(stderr, gettext(\"cannot mount \"\n\t\t\t    \"'%s': filesystem already mounted\\n\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\treturn (1);\n\t\t}\n\n\t\tif (zfs_mount(zhp, options, flags) != 0)\n\t\t\treturn (1);\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nreport_mount_progress(int current, int total)\n{\n\tstatic time_t last_progress_time = 0;\n\ttime_t now = time(NULL);\n\tchar info[32];\n\n\t \n\tif (current == 1) {\n\t\tset_progress_header(gettext(\"Mounting ZFS filesystems\"));\n\t} else if (current != total && last_progress_time + MOUNT_TIME >= now) {\n\t\t \n\t\treturn;\n\t}\n\n\tlast_progress_time = now;\n\n\t(void) sprintf(info, \"(%d/%d)\", current, total);\n\n\tif (current == total)\n\t\tfinish_progress(info);\n\telse\n\t\tupdate_progress(info);\n}\n\n \nstatic int\nshare_mount_one_cb(zfs_handle_t *zhp, void *arg)\n{\n\tshare_mount_state_t *sms = arg;\n\tint ret;\n\n\tret = share_mount_one(zhp, sms->sm_op, sms->sm_flags, sms->sm_proto,\n\t    B_FALSE, sms->sm_options);\n\n\tpthread_mutex_lock(&sms->sm_lock);\n\tif (ret != 0)\n\t\tsms->sm_status = ret;\n\tsms->sm_done++;\n\tif (sms->sm_verbose)\n\t\treport_mount_progress(sms->sm_done, sms->sm_total);\n\tpthread_mutex_unlock(&sms->sm_lock);\n\treturn (ret);\n}\n\nstatic void\nappend_options(char *mntopts, char *newopts)\n{\n\tint len = strlen(mntopts);\n\n\t \n\tif (len + 1 + strlen(newopts) >= MNT_LINE_MAX) {\n\t\t(void) fprintf(stderr, gettext(\"the opts argument for \"\n\t\t    \"'%s' option is too long (more than %d chars)\\n\"),\n\t\t    \"-o\", MNT_LINE_MAX);\n\t\tusage(B_FALSE);\n\t}\n\n\tif (*mntopts)\n\t\tmntopts[len++] = ',';\n\n\t(void) strcpy(&mntopts[len], newopts);\n}\n\nstatic enum sa_protocol\nsa_protocol_decode(const char *protocol)\n{\n\tfor (enum sa_protocol i = 0; i < ARRAY_SIZE(sa_protocol_names); ++i)\n\t\tif (strcmp(protocol, sa_protocol_names[i]) == 0)\n\t\t\treturn (i);\n\n\t(void) fputs(gettext(\"share type must be one of: \"), stderr);\n\tfor (enum sa_protocol i = 0;\n\t    i < ARRAY_SIZE(sa_protocol_names); ++i)\n\t\t(void) fprintf(stderr, \"%s%s\",\n\t\t    i != 0 ? \", \" : \"\", sa_protocol_names[i]);\n\t(void) fputc('\\n', stderr);\n\tusage(B_FALSE);\n}\n\nstatic int\nshare_mount(int op, int argc, char **argv)\n{\n\tint do_all = 0;\n\tboolean_t verbose = B_FALSE;\n\tint c, ret = 0;\n\tchar *options = NULL;\n\tint flags = 0;\n\n\t \n\twhile ((c = getopt(argc, argv, op == OP_MOUNT ? \":alvo:Of\" : \"al\"))\n\t    != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tdo_all = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags |= MS_CRYPT;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (*optarg == '\\0') {\n\t\t\t\t(void) fprintf(stderr, gettext(\"empty mount \"\n\t\t\t\t    \"options (-o) specified\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\n\t\t\tif (options == NULL)\n\t\t\t\toptions = safe_malloc(MNT_LINE_MAX + 1);\n\n\t\t\t \n\t\t\tappend_options(options, optarg);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tflags |= MS_OVERLAY;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= MS_FORCE;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (do_all) {\n\t\tenum sa_protocol protocol = SA_NO_PROTOCOL;\n\n\t\tif (op == OP_SHARE && argc > 0) {\n\t\t\tprotocol = sa_protocol_decode(argv[0]);\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\tstart_progress_timer();\n\t\tget_all_cb_t cb = { 0 };\n\t\tget_all_datasets(&cb, verbose);\n\n\t\tif (cb.cb_used == 0) {\n\t\t\tfree(options);\n\t\t\treturn (0);\n\t\t}\n\n\t\tshare_mount_state_t share_mount_state = { 0 };\n\t\tshare_mount_state.sm_op = op;\n\t\tshare_mount_state.sm_verbose = verbose;\n\t\tshare_mount_state.sm_flags = flags;\n\t\tshare_mount_state.sm_options = options;\n\t\tshare_mount_state.sm_proto = protocol;\n\t\tshare_mount_state.sm_total = cb.cb_used;\n\t\tpthread_mutex_init(&share_mount_state.sm_lock, NULL);\n\n\t\t \n\t\tzfs_truncate_shares(NULL);\n\n\t\t \n\t\tzfs_foreach_mountpoint(g_zfs, cb.cb_handles, cb.cb_used,\n\t\t    share_mount_one_cb, &share_mount_state,\n\t\t    op == OP_MOUNT && !(flags & MS_CRYPT));\n\t\tzfs_commit_shares(NULL);\n\n\t\tret = share_mount_state.sm_status;\n\n\t\tfor (int i = 0; i < cb.cb_used; i++)\n\t\t\tzfs_close(cb.cb_handles[i]);\n\t\tfree(cb.cb_handles);\n\t} else if (argc == 0) {\n\t\tFILE *mnttab;\n\t\tstruct mnttab entry;\n\n\t\tif ((op == OP_SHARE) || (options != NULL)) {\n\t\t\t(void) fprintf(stderr, gettext(\"missing filesystem \"\n\t\t\t    \"argument (specify -a for all)\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\t \n\n\t\tif ((mnttab = fopen(MNTTAB, \"re\")) == NULL) {\n\t\t\tfree(options);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\twhile (getmntent(mnttab, &entry) == 0) {\n\t\t\tif (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0 ||\n\t\t\t    strchr(entry.mnt_special, '@') != NULL)\n\t\t\t\tcontinue;\n\n\t\t\t(void) printf(\"%-30s  %s\\n\", entry.mnt_special,\n\t\t\t    entry.mnt_mountp);\n\t\t}\n\n\t\t(void) fclose(mnttab);\n\t} else {\n\t\tzfs_handle_t *zhp;\n\n\t\tif (argc > 1) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\tif ((zhp = zfs_open(g_zfs, argv[0],\n\t\t    ZFS_TYPE_FILESYSTEM)) == NULL) {\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tret = share_mount_one(zhp, op, flags, SA_NO_PROTOCOL,\n\t\t\t    B_TRUE, options);\n\t\t\tzfs_commit_shares(NULL);\n\t\t\tzfs_close(zhp);\n\t\t}\n\t}\n\n\tfree(options);\n\treturn (ret);\n}\n\n \nstatic int\nzfs_do_mount(int argc, char **argv)\n{\n\treturn (share_mount(OP_MOUNT, argc, argv));\n}\n\n \nstatic int\nzfs_do_share(int argc, char **argv)\n{\n\treturn (share_mount(OP_SHARE, argc, argv));\n}\n\ntypedef struct unshare_unmount_node {\n\tzfs_handle_t\t*un_zhp;\n\tchar\t\t*un_mountp;\n\tuu_avl_node_t\tun_avlnode;\n} unshare_unmount_node_t;\n\nstatic int\nunshare_unmount_compare(const void *larg, const void *rarg, void *unused)\n{\n\t(void) unused;\n\tconst unshare_unmount_node_t *l = larg;\n\tconst unshare_unmount_node_t *r = rarg;\n\n\treturn (strcmp(l->un_mountp, r->un_mountp));\n}\n\n \nstatic int\nunshare_unmount_path(int op, char *path, int flags, boolean_t is_manual)\n{\n\tzfs_handle_t *zhp;\n\tint ret = 0;\n\tstruct stat64 statbuf;\n\tstruct extmnttab entry;\n\tconst char *cmdname = (op == OP_SHARE) ? \"unshare\" : \"unmount\";\n\tino_t path_inode;\n\n\t \n\n\tif (getextmntent(path, &entry, &statbuf) != 0) {\n\t\tif (op == OP_SHARE) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': not \"\n\t\t\t    \"currently mounted\\n\"), cmdname, path);\n\t\t\treturn (1);\n\t\t}\n\t\t(void) fprintf(stderr, gettext(\"warning: %s not in\"\n\t\t    \"/proc/self/mounts\\n\"), path);\n\t\tif ((ret = umount2(path, flags)) != 0)\n\t\t\t(void) fprintf(stderr, gettext(\"%s: %s\\n\"), path,\n\t\t\t    strerror(errno));\n\t\treturn (ret != 0);\n\t}\n\tpath_inode = statbuf.st_ino;\n\n\tif (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0) {\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': not a ZFS \"\n\t\t    \"filesystem\\n\"), cmdname, path);\n\t\treturn (1);\n\t}\n\n\tif ((zhp = zfs_open(g_zfs, entry.mnt_special,\n\t    ZFS_TYPE_FILESYSTEM)) == NULL)\n\t\treturn (1);\n\n\tret = 1;\n\tif (stat64(entry.mnt_mountp, &statbuf) != 0) {\n\t\t(void) fprintf(stderr, gettext(\"cannot %s '%s': %s\\n\"),\n\t\t    cmdname, path, strerror(errno));\n\t\tgoto out;\n\t} else if (statbuf.st_ino != path_inode) {\n\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t    \"%s '%s': not a mountpoint\\n\"), cmdname, path);\n\t\tgoto out;\n\t}\n\n\tif (op == OP_SHARE) {\n\t\tchar nfs_mnt_prop[ZFS_MAXPROPLEN];\n\t\tchar smbshare_prop[ZFS_MAXPROPLEN];\n\n\t\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS, nfs_mnt_prop,\n\t\t    sizeof (nfs_mnt_prop), NULL, NULL, 0, B_FALSE) == 0);\n\t\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB, smbshare_prop,\n\t\t    sizeof (smbshare_prop), NULL, NULL, 0, B_FALSE) == 0);\n\n\t\tif (strcmp(nfs_mnt_prop, \"off\") == 0 &&\n\t\t    strcmp(smbshare_prop, \"off\") == 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot unshare \"\n\t\t\t    \"'%s': legacy share\\n\"), path);\n\t\t\t(void) fprintf(stderr, gettext(\"use exportfs(8) \"\n\t\t\t    \"or smbcontrol(1) to unshare this filesystem\\n\"));\n\t\t} else if (!zfs_is_shared(zhp, NULL, NULL)) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot unshare '%s': \"\n\t\t\t    \"not currently shared\\n\"), path);\n\t\t} else {\n\t\t\tret = zfs_unshare(zhp, path, NULL);\n\t\t\tzfs_commit_shares(NULL);\n\t\t}\n\t} else {\n\t\tchar mtpt_prop[ZFS_MAXPROPLEN];\n\n\t\tverify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT, mtpt_prop,\n\t\t    sizeof (mtpt_prop), NULL, NULL, 0, B_FALSE) == 0);\n\n\t\tif (is_manual) {\n\t\t\tret = zfs_unmount(zhp, NULL, flags);\n\t\t} else if (strcmp(mtpt_prop, \"legacy\") == 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"cannot unmount \"\n\t\t\t    \"'%s': legacy mountpoint\\n\"),\n\t\t\t    zfs_get_name(zhp));\n\t\t\t(void) fprintf(stderr, gettext(\"use umount(8) \"\n\t\t\t    \"to unmount this filesystem\\n\"));\n\t\t} else {\n\t\t\tret = zfs_unmountall(zhp, flags);\n\t\t}\n\t}\n\nout:\n\tzfs_close(zhp);\n\n\treturn (ret != 0);\n}\n\n \nstatic int\nunshare_unmount(int op, int argc, char **argv)\n{\n\tint do_all = 0;\n\tint flags = 0;\n\tint ret = 0;\n\tint c;\n\tzfs_handle_t *zhp;\n\tchar nfs_mnt_prop[ZFS_MAXPROPLEN];\n\tchar sharesmb[ZFS_MAXPROPLEN];\n\n\t \n\twhile ((c = getopt(argc, argv, op == OP_SHARE ? \":a\" : \"afu\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tdo_all = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= MS_FORCE;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tflags |= MS_CRYPT;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t(void) fprintf(stderr, gettext(\"missing argument for \"\n\t\t\t    \"'%c' option\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (do_all) {\n\t\t \n\t\tFILE *mnttab;\n\t\tstruct mnttab entry;\n\t\tuu_avl_pool_t *pool;\n\t\tuu_avl_t *tree = NULL;\n\t\tunshare_unmount_node_t *node;\n\t\tuu_avl_index_t idx;\n\t\tuu_avl_walk_t *walk;\n\t\tenum sa_protocol *protocol = NULL,\n\t\t    single_protocol[] = {SA_NO_PROTOCOL, SA_NO_PROTOCOL};\n\n\t\tif (op == OP_SHARE && argc > 0) {\n\t\t\t*single_protocol = sa_protocol_decode(argv[0]);\n\t\t\tprotocol = single_protocol;\n\t\t\targc--;\n\t\t\targv++;\n\t\t}\n\n\t\tif (argc != 0) {\n\t\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\tif (((pool = uu_avl_pool_create(\"unmount_pool\",\n\t\t    sizeof (unshare_unmount_node_t),\n\t\t    offsetof(unshare_unmount_node_t, un_avlnode),\n\t\t    unshare_unmount_compare, UU_DEFAULT)) == NULL) ||\n\t\t    ((tree = uu_avl_create(pool, NULL, UU_DEFAULT)) == NULL))\n\t\t\tnomem();\n\n\t\tif ((mnttab = fopen(MNTTAB, \"re\")) == NULL) {\n\t\t\tuu_avl_destroy(tree);\n\t\t\tuu_avl_pool_destroy(pool);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\twhile (getmntent(mnttab, &entry) == 0) {\n\n\t\t\t \n\t\t\tif (strcmp(entry.mnt_fstype, MNTTYPE_ZFS) != 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (strchr(entry.mnt_special, '@') != NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif ((zhp = zfs_open(g_zfs, entry.mnt_special,\n\t\t\t    ZFS_TYPE_FILESYSTEM)) == NULL) {\n\t\t\t\tret = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (zpool_skip_pool(zfs_get_pool_name(zhp))) {\n\t\t\t\tzfs_close(zhp);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (op) {\n\t\t\tcase OP_SHARE:\n\t\t\t\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS,\n\t\t\t\t    nfs_mnt_prop,\n\t\t\t\t    sizeof (nfs_mnt_prop),\n\t\t\t\t    NULL, NULL, 0, B_FALSE) == 0);\n\t\t\t\tif (strcmp(nfs_mnt_prop, \"off\") != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB,\n\t\t\t\t    nfs_mnt_prop,\n\t\t\t\t    sizeof (nfs_mnt_prop),\n\t\t\t\t    NULL, NULL, 0, B_FALSE) == 0);\n\t\t\t\tif (strcmp(nfs_mnt_prop, \"off\") == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase OP_MOUNT:\n\t\t\t\t \n\t\t\t\tverify(zfs_prop_get(zhp, ZFS_PROP_MOUNTPOINT,\n\t\t\t\t    nfs_mnt_prop,\n\t\t\t\t    sizeof (nfs_mnt_prop),\n\t\t\t\t    NULL, NULL, 0, B_FALSE) == 0);\n\t\t\t\tif (strcmp(nfs_mnt_prop, \"legacy\") == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) ==\n\t\t\t\t    ZFS_CANMOUNT_NOAUTO)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = safe_malloc(sizeof (unshare_unmount_node_t));\n\t\t\tnode->un_zhp = zhp;\n\t\t\tnode->un_mountp = safe_strdup(entry.mnt_mountp);\n\n\t\t\tuu_avl_node_init(node, &node->un_avlnode, pool);\n\n\t\t\tif (uu_avl_find(tree, node, NULL, &idx) == NULL) {\n\t\t\t\tuu_avl_insert(tree, node, idx);\n\t\t\t} else {\n\t\t\t\tzfs_close(node->un_zhp);\n\t\t\t\tfree(node->un_mountp);\n\t\t\t\tfree(node);\n\t\t\t}\n\t\t}\n\t\t(void) fclose(mnttab);\n\n\t\t \n\t\tif ((walk = uu_avl_walk_start(tree,\n\t\t    UU_WALK_REVERSE | UU_WALK_ROBUST)) == NULL)\n\t\t\tnomem();\n\n\t\twhile ((node = uu_avl_walk_next(walk)) != NULL) {\n\t\t\tconst char *mntarg = NULL;\n\n\t\t\tuu_avl_remove(tree, node);\n\t\t\tswitch (op) {\n\t\t\tcase OP_SHARE:\n\t\t\t\tif (zfs_unshare(node->un_zhp,\n\t\t\t\t    node->un_mountp, protocol) != 0)\n\t\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase OP_MOUNT:\n\t\t\t\tif (zfs_unmount(node->un_zhp,\n\t\t\t\t    mntarg, flags) != 0)\n\t\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tzfs_close(node->un_zhp);\n\t\t\tfree(node->un_mountp);\n\t\t\tfree(node);\n\t\t}\n\n\t\tif (op == OP_SHARE)\n\t\t\tzfs_commit_shares(protocol);\n\n\t\tuu_avl_walk_end(walk);\n\t\tuu_avl_destroy(tree);\n\t\tuu_avl_pool_destroy(pool);\n\n\t} else {\n\t\tif (argc != 1) {\n\t\t\tif (argc == 0)\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"missing filesystem argument\\n\"));\n\t\t\telse\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"too many arguments\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\t \n\t\tif (argv[0][0] == '/')\n\t\t\treturn (unshare_unmount_path(op, argv[0],\n\t\t\t    flags, B_FALSE));\n\n\t\tif ((zhp = zfs_open(g_zfs, argv[0],\n\t\t    ZFS_TYPE_FILESYSTEM)) == NULL)\n\t\t\treturn (1);\n\n\t\tverify(zfs_prop_get(zhp, op == OP_SHARE ?\n\t\t    ZFS_PROP_SHARENFS : ZFS_PROP_MOUNTPOINT,\n\t\t    nfs_mnt_prop, sizeof (nfs_mnt_prop), NULL,\n\t\t    NULL, 0, B_FALSE) == 0);\n\n\t\tswitch (op) {\n\t\tcase OP_SHARE:\n\t\t\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARENFS,\n\t\t\t    nfs_mnt_prop,\n\t\t\t    sizeof (nfs_mnt_prop),\n\t\t\t    NULL, NULL, 0, B_FALSE) == 0);\n\t\t\tverify(zfs_prop_get(zhp, ZFS_PROP_SHARESMB,\n\t\t\t    sharesmb, sizeof (sharesmb), NULL, NULL,\n\t\t\t    0, B_FALSE) == 0);\n\n\t\t\tif (strcmp(nfs_mnt_prop, \"off\") == 0 &&\n\t\t\t    strcmp(sharesmb, \"off\") == 0) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"unshare '%s': legacy share\\n\"),\n\t\t\t\t    zfs_get_name(zhp));\n\t\t\t\t(void) fprintf(stderr, gettext(\"use \"\n\t\t\t\t    \"exports(5) or smb.conf(5) to unshare \"\n\t\t\t\t    \"this filesystem\\n\"));\n\t\t\t\tret = 1;\n\t\t\t} else if (!zfs_is_shared(zhp, NULL, NULL)) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"unshare '%s': not currently \"\n\t\t\t\t    \"shared\\n\"), zfs_get_name(zhp));\n\t\t\t\tret = 1;\n\t\t\t} else if (zfs_unshareall(zhp, NULL) != 0) {\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OP_MOUNT:\n\t\t\tif (strcmp(nfs_mnt_prop, \"legacy\") == 0) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"unmount '%s': legacy \"\n\t\t\t\t    \"mountpoint\\n\"), zfs_get_name(zhp));\n\t\t\t\t(void) fprintf(stderr, gettext(\"use \"\n\t\t\t\t    \"umount(8) to unmount this \"\n\t\t\t\t    \"filesystem\\n\"));\n\t\t\t\tret = 1;\n\t\t\t} else if (!zfs_is_mounted(zhp, NULL)) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"unmount '%s': not currently \"\n\t\t\t\t    \"mounted\\n\"),\n\t\t\t\t    zfs_get_name(zhp));\n\t\t\t\tret = 1;\n\t\t\t} else if (zfs_unmountall(zhp, flags) != 0) {\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tzfs_close(zhp);\n\t}\n\n\treturn (ret);\n}\n\n \nstatic int\nzfs_do_unmount(int argc, char **argv)\n{\n\treturn (unshare_unmount(OP_MOUNT, argc, argv));\n}\n\n \nstatic int\nzfs_do_unshare(int argc, char **argv)\n{\n\treturn (unshare_unmount(OP_SHARE, argc, argv));\n}\n\nstatic int\nfind_command_idx(const char *command, int *idx)\n{\n\tint i;\n\n\tfor (i = 0; i < NCOMMAND; i++) {\n\t\tif (command_table[i].name == NULL)\n\t\t\tcontinue;\n\n\t\tif (strcmp(command, command_table[i].name) == 0) {\n\t\t\t*idx = i;\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}\n\nstatic int\nzfs_do_diff(int argc, char **argv)\n{\n\tzfs_handle_t *zhp;\n\tint flags = 0;\n\tchar *tosnap = NULL;\n\tchar *fromsnap = NULL;\n\tchar *atp, *copy;\n\tint err = 0;\n\tint c;\n\tstruct sigaction sa;\n\n\twhile ((c = getopt(argc, argv, \"FHth\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'F':\n\t\t\tflags |= ZFS_DIFF_CLASSIFY;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tflags |= ZFS_DIFF_PARSEABLE;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tflags |= ZFS_DIFF_TIMESTAMP;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tflags |= ZFS_DIFF_NO_MANGLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"must provide at least one snapshot name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc > 2) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tfromsnap = argv[0];\n\ttosnap = (argc == 2) ? argv[1] : NULL;\n\n\tcopy = NULL;\n\tif (*fromsnap != '@')\n\t\tcopy = strdup(fromsnap);\n\telse if (tosnap)\n\t\tcopy = strdup(tosnap);\n\tif (copy == NULL)\n\t\tusage(B_FALSE);\n\n\tif ((atp = strchr(copy, '@')) != NULL)\n\t\t*atp = '\\0';\n\n\tif ((zhp = zfs_open(g_zfs, copy, ZFS_TYPE_FILESYSTEM)) == NULL) {\n\t\tfree(copy);\n\t\treturn (1);\n\t}\n\tfree(copy);\n\n\t \n\tif (sigemptyset(&sa.sa_mask) == -1) {\n\t\terr = errno;\n\t\tgoto out;\n\t}\n\tsa.sa_flags = 0;\n\tsa.sa_handler = SIG_IGN;\n\tif (sigaction(SIGPIPE, &sa, NULL) == -1) {\n\t\terr = errno;\n\t\tgoto out;\n\t}\n\n\terr = zfs_show_diffs(zhp, STDOUT_FILENO, fromsnap, tosnap, flags);\nout:\n\tzfs_close(zhp);\n\n\treturn (err != 0);\n}\n\n \nstatic int\nzfs_do_bookmark(int argc, char **argv)\n{\n\tchar *source, *bookname;\n\tchar expbuf[ZFS_MAX_DATASET_NAME_LEN];\n\tint source_type;\n\tnvlist_t *nvl;\n\tint ret = 0;\n\tint c;\n\n\t \n\twhile ((c = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\tgoto usage;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing source argument\\n\"));\n\t\tgoto usage;\n\t}\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing bookmark argument\\n\"));\n\t\tgoto usage;\n\t}\n\n\tsource = argv[0];\n\tbookname = argv[1];\n\n\tif (strchr(source, '@') == NULL && strchr(source, '#') == NULL) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"invalid source name '%s': \"\n\t\t    \"must contain a '@' or '#'\\n\"), source);\n\t\tgoto usage;\n\t}\n\tif (strchr(bookname, '#') == NULL) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"invalid bookmark name '%s': \"\n\t\t    \"must contain a '#'\\n\"), bookname);\n\t\tgoto usage;\n\t}\n\n\t \n\t{\n\t\tchar **expand;\n\t\tchar *source_short, *bookname_short;\n\t\tsource_short = strpbrk(source, \"@#\");\n\t\tbookname_short = strpbrk(bookname, \"#\");\n\t\tif (source_short == source &&\n\t\t    bookname_short == bookname) {\n\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t    \"either source or bookmark must be specified as \"\n\t\t\t    \"full dataset paths\"));\n\t\t\tgoto usage;\n\t\t} else if (source_short != source &&\n\t\t    bookname_short != bookname) {\n\t\t\texpand = NULL;\n\t\t} else if (source_short != source) {\n\t\t\tstrlcpy(expbuf, source, sizeof (expbuf));\n\t\t\texpand = &bookname;\n\t\t} else if (bookname_short != bookname) {\n\t\t\tstrlcpy(expbuf, bookname, sizeof (expbuf));\n\t\t\texpand = &source;\n\t\t} else {\n\t\t\tabort();\n\t\t}\n\t\tif (expand != NULL) {\n\t\t\t*strpbrk(expbuf, \"@#\") = '\\0';  \n\t\t\t(void) strlcat(expbuf, *expand, sizeof (expbuf));\n\t\t\t*expand = expbuf;\n\t\t}\n\t}\n\n\t \n\tswitch (*strpbrk(source, \"@#\")) {\n\t\tcase '@': source_type = ZFS_TYPE_SNAPSHOT; break;\n\t\tcase '#': source_type = ZFS_TYPE_BOOKMARK; break;\n\t\tdefault: abort();\n\t}\n\n\t \n\tzfs_handle_t *zhp;\n\tzhp = zfs_open(g_zfs, source, source_type);\n\tif (zhp == NULL)\n\t\tgoto usage;\n\tzfs_close(zhp);\n\n\tnvl = fnvlist_alloc();\n\tfnvlist_add_string(nvl, bookname, source);\n\tret = lzc_bookmark(nvl, NULL);\n\tfnvlist_free(nvl);\n\n\tif (ret != 0) {\n\t\tconst char *err_msg = NULL;\n\t\tchar errbuf[1024];\n\n\t\t(void) snprintf(errbuf, sizeof (errbuf),\n\t\t    dgettext(TEXT_DOMAIN,\n\t\t    \"cannot create bookmark '%s'\"), bookname);\n\n\t\tswitch (ret) {\n\t\tcase EXDEV:\n\t\t\terr_msg = \"bookmark is in a different pool\";\n\t\t\tbreak;\n\t\tcase ZFS_ERR_BOOKMARK_SOURCE_NOT_ANCESTOR:\n\t\t\terr_msg = \"source is not an ancestor of the \"\n\t\t\t    \"new bookmark's dataset\";\n\t\t\tbreak;\n\t\tcase EEXIST:\n\t\t\terr_msg = \"bookmark exists\";\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\terr_msg = \"invalid argument\";\n\t\t\tbreak;\n\t\tcase ENOTSUP:\n\t\t\terr_msg = \"bookmark feature not enabled\";\n\t\t\tbreak;\n\t\tcase ENOSPC:\n\t\t\terr_msg = \"out of space\";\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\terr_msg = \"dataset does not exist\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) zfs_standard_error(g_zfs, ret, errbuf);\n\t\t\tbreak;\n\t\t}\n\t\tif (err_msg != NULL) {\n\t\t\t(void) fprintf(stderr, \"%s: %s\\n\", errbuf,\n\t\t\t    dgettext(TEXT_DOMAIN, err_msg));\n\t\t}\n\t}\n\n\treturn (ret != 0);\n\nusage:\n\tusage(B_FALSE);\n\treturn (-1);\n}\n\nstatic int\nzfs_do_channel_program(int argc, char **argv)\n{\n\tint ret, fd, c;\n\tsize_t progsize, progread;\n\tnvlist_t *outnvl = NULL;\n\tuint64_t instrlimit = ZCP_DEFAULT_INSTRLIMIT;\n\tuint64_t memlimit = ZCP_DEFAULT_MEMLIMIT;\n\tboolean_t sync_flag = B_TRUE, json_output = B_FALSE;\n\tzpool_handle_t *zhp;\n\n\t \n\twhile ((c = getopt(argc, argv, \"nt:m:j\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 't':\n\t\tcase 'm': {\n\t\t\tuint64_t arg;\n\t\t\tchar *endp;\n\n\t\t\terrno = 0;\n\t\t\targ = strtoull(optarg, &endp, 0);\n\t\t\tif (errno != 0 || *endp != '\\0') {\n\t\t\t\t(void) fprintf(stderr, gettext(\n\t\t\t\t    \"invalid argument \"\n\t\t\t\t    \"'%s': expected integer\\n\"), optarg);\n\t\t\t\tgoto usage;\n\t\t\t}\n\n\t\t\tif (c == 't') {\n\t\t\t\tinstrlimit = arg;\n\t\t\t} else {\n\t\t\t\tASSERT3U(c, ==, 'm');\n\t\t\t\tmemlimit = arg;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'n': {\n\t\t\tsync_flag = B_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'j': {\n\t\t\tjson_output = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tgoto usage;\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 2) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"invalid number of arguments\\n\"));\n\t\tgoto usage;\n\t}\n\n\tconst char *poolname = argv[0];\n\tconst char *filename = argv[1];\n\tif (strcmp(filename, \"-\") == 0) {\n\t\tfd = 0;\n\t\tfilename = \"standard input\";\n\t} else if ((fd = open(filename, O_RDONLY)) < 0) {\n\t\t(void) fprintf(stderr, gettext(\"cannot open '%s': %s\\n\"),\n\t\t    filename, strerror(errno));\n\t\treturn (1);\n\t}\n\n\tif ((zhp = zpool_open(g_zfs, poolname)) == NULL) {\n\t\t(void) fprintf(stderr, gettext(\"cannot open pool '%s'\\n\"),\n\t\t    poolname);\n\t\tif (fd != 0)\n\t\t\t(void) close(fd);\n\t\treturn (1);\n\t}\n\tzpool_close(zhp);\n\n\t \n\tprogread = 0;\n\tprogsize = 1024;\n\tchar *progbuf = safe_malloc(progsize);\n\tdo {\n\t\tret = read(fd, progbuf + progread, progsize - progread);\n\t\tprogread += ret;\n\t\tif (progread == progsize && ret > 0) {\n\t\t\tprogsize *= 2;\n\t\t\tprogbuf = safe_realloc(progbuf, progsize);\n\t\t}\n\t} while (ret > 0);\n\n\tif (fd != 0)\n\t\t(void) close(fd);\n\tif (ret < 0) {\n\t\tfree(progbuf);\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"cannot read '%s': %s\\n\"),\n\t\t    filename, strerror(errno));\n\t\treturn (1);\n\t}\n\tprogbuf[progread] = '\\0';\n\n\t \n\tnvlist_t *argnvl = fnvlist_alloc();\n\tfnvlist_add_string_array(argnvl, ZCP_ARG_CLIARGV,\n\t    (const char **)argv + 2, argc - 2);\n\n\tif (sync_flag) {\n\t\tret = lzc_channel_program(poolname, progbuf,\n\t\t    instrlimit, memlimit, argnvl, &outnvl);\n\t} else {\n\t\tret = lzc_channel_program_nosync(poolname, progbuf,\n\t\t    instrlimit, memlimit, argnvl, &outnvl);\n\t}\n\n\tif (ret != 0) {\n\t\t \n\t\tconst char *errstring = NULL;\n\t\tconst char *msg = gettext(\"Channel program execution failed\");\n\t\tuint64_t instructions = 0;\n\t\tif (outnvl != NULL && nvlist_exists(outnvl, ZCP_RET_ERROR)) {\n\t\t\tconst char *es = NULL;\n\t\t\t(void) nvlist_lookup_string(outnvl,\n\t\t\t    ZCP_RET_ERROR, &es);\n\t\t\tif (es == NULL)\n\t\t\t\terrstring = strerror(ret);\n\t\t\telse\n\t\t\t\terrstring = es;\n\t\t\tif (ret == ETIME) {\n\t\t\t\t(void) nvlist_lookup_uint64(outnvl,\n\t\t\t\t    ZCP_ARG_INSTRLIMIT, &instructions);\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (ret) {\n\t\t\tcase EINVAL:\n\t\t\t\terrstring =\n\t\t\t\t    \"Invalid instruction or memory limit.\";\n\t\t\t\tbreak;\n\t\t\tcase ENOMEM:\n\t\t\t\terrstring = \"Return value too large.\";\n\t\t\t\tbreak;\n\t\t\tcase ENOSPC:\n\t\t\t\terrstring = \"Memory limit exhausted.\";\n\t\t\t\tbreak;\n\t\t\tcase ETIME:\n\t\t\t\terrstring = \"Timed out.\";\n\t\t\t\tbreak;\n\t\t\tcase EPERM:\n\t\t\t\terrstring = \"Permission denied. Channel \"\n\t\t\t\t    \"programs must be run as root.\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(void) zfs_standard_error(g_zfs, ret, msg);\n\t\t\t}\n\t\t}\n\t\tif (errstring != NULL)\n\t\t\t(void) fprintf(stderr, \"%s:\\n%s\\n\", msg, errstring);\n\n\t\tif (ret == ETIME && instructions != 0)\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"%llu Lua instructions\\n\"),\n\t\t\t    (u_longlong_t)instructions);\n\t} else {\n\t\tif (json_output) {\n\t\t\t(void) nvlist_print_json(stdout, outnvl);\n\t\t} else if (nvlist_empty(outnvl)) {\n\t\t\t(void) fprintf(stdout, gettext(\"Channel program fully \"\n\t\t\t    \"executed and did not produce output.\\n\"));\n\t\t} else {\n\t\t\t(void) fprintf(stdout, gettext(\"Channel program fully \"\n\t\t\t    \"executed and produced output:\\n\"));\n\t\t\tdump_nvlist(outnvl, 4);\n\t\t}\n\t}\n\n\tfree(progbuf);\n\tfnvlist_free(outnvl);\n\tfnvlist_free(argnvl);\n\treturn (ret != 0);\n\nusage:\n\tusage(B_FALSE);\n\treturn (-1);\n}\n\n\ntypedef struct loadkey_cbdata {\n\tboolean_t cb_loadkey;\n\tboolean_t cb_recursive;\n\tboolean_t cb_noop;\n\tchar *cb_keylocation;\n\tuint64_t cb_numfailed;\n\tuint64_t cb_numattempted;\n} loadkey_cbdata_t;\n\nstatic int\nload_key_callback(zfs_handle_t *zhp, void *data)\n{\n\tint ret;\n\tboolean_t is_encroot;\n\tloadkey_cbdata_t *cb = data;\n\tuint64_t keystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\n\t \n\tif (cb->cb_recursive) {\n\t\tret = zfs_crypto_get_encryption_root(zhp, &is_encroot, NULL);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\t\tif (!is_encroot)\n\t\t\treturn (0);\n\n\t\tif ((cb->cb_loadkey && keystatus == ZFS_KEYSTATUS_AVAILABLE) ||\n\t\t    (!cb->cb_loadkey && keystatus == ZFS_KEYSTATUS_UNAVAILABLE))\n\t\t\treturn (0);\n\t}\n\n\tcb->cb_numattempted++;\n\n\tif (cb->cb_loadkey)\n\t\tret = zfs_crypto_load_key(zhp, cb->cb_noop, cb->cb_keylocation);\n\telse\n\t\tret = zfs_crypto_unload_key(zhp);\n\n\tif (ret != 0) {\n\t\tcb->cb_numfailed++;\n\t\treturn (ret);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nload_unload_keys(int argc, char **argv, boolean_t loadkey)\n{\n\tint c, ret = 0, flags = 0;\n\tboolean_t do_all = B_FALSE;\n\tloadkey_cbdata_t cb = { 0 };\n\n\tcb.cb_loadkey = loadkey;\n\n\twhile ((c = getopt(argc, argv, \"anrL:\")) != -1) {\n\t\t \n\t\tif (loadkey) {\n\t\t\tswitch (c) {\n\t\t\tcase 'n':\n\t\t\t\tcb.cb_noop = B_TRUE;\n\t\t\t\tcontinue;\n\t\t\tcase 'L':\n\t\t\t\tcb.cb_keylocation = optarg;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t\tdo_all = B_TRUE;\n\t\t\tcb.cb_recursive = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags |= ZFS_ITER_RECURSE;\n\t\t\tcb.cb_recursive = B_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (!do_all && argc == 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Missing dataset argument or -a option\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (do_all && argc != 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Cannot specify dataset with -a option\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (cb.cb_recursive && cb.cb_keylocation != NULL &&\n\t    strcmp(cb.cb_keylocation, \"prompt\") != 0) {\n\t\t(void) fprintf(stderr, gettext(\"alternate keylocation may only \"\n\t\t    \"be 'prompt' with -r or -a\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tret = zfs_for_each(argc, argv, flags,\n\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, NULL, NULL, 0,\n\t    load_key_callback, &cb);\n\n\tif (cb.cb_noop || (cb.cb_recursive && cb.cb_numattempted != 0)) {\n\t\t(void) printf(gettext(\"%llu / %llu key(s) successfully %s\\n\"),\n\t\t    (u_longlong_t)(cb.cb_numattempted - cb.cb_numfailed),\n\t\t    (u_longlong_t)cb.cb_numattempted,\n\t\t    loadkey ? (cb.cb_noop ? \"verified\" : \"loaded\") :\n\t\t    \"unloaded\");\n\t}\n\n\tif (cb.cb_numfailed != 0)\n\t\tret = -1;\n\n\treturn (ret);\n}\n\nstatic int\nzfs_do_load_key(int argc, char **argv)\n{\n\treturn (load_unload_keys(argc, argv, B_TRUE));\n}\n\n\nstatic int\nzfs_do_unload_key(int argc, char **argv)\n{\n\treturn (load_unload_keys(argc, argv, B_FALSE));\n}\n\nstatic int\nzfs_do_change_key(int argc, char **argv)\n{\n\tint c, ret;\n\tuint64_t keystatus;\n\tboolean_t loadkey = B_FALSE, inheritkey = B_FALSE;\n\tzfs_handle_t *zhp = NULL;\n\tnvlist_t *props = fnvlist_alloc();\n\n\twhile ((c = getopt(argc, argv, \"lio:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tloadkey = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinheritkey = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (!parseprop(props, optarg)) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"invalid option '%c'\\n\"), optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (inheritkey && !nvlist_empty(props)) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"Properties not allowed for inheriting\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"Missing dataset argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"Too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tzhp = zfs_open(g_zfs, argv[argc - 1],\n\t    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);\n\tif (zhp == NULL)\n\t\tusage(B_FALSE);\n\n\tif (loadkey) {\n\t\tkeystatus = zfs_prop_get_int(zhp, ZFS_PROP_KEYSTATUS);\n\t\tif (keystatus != ZFS_KEYSTATUS_AVAILABLE) {\n\t\t\tret = zfs_crypto_load_key(zhp, B_FALSE, NULL);\n\t\t\tif (ret != 0) {\n\t\t\t\tnvlist_free(props);\n\t\t\t\tzfs_close(zhp);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tzfs_refresh_properties(zhp);\n\t}\n\n\tret = zfs_crypto_rewrap(zhp, props, inheritkey);\n\tif (ret != 0) {\n\t\tnvlist_free(props);\n\t\tzfs_close(zhp);\n\t\treturn (-1);\n\t}\n\n\tnvlist_free(props);\n\tzfs_close(zhp);\n\treturn (0);\n}\n\n \nstatic int\nzfs_do_project(int argc, char **argv)\n{\n\tzfs_project_control_t zpc = {\n\t\t.zpc_expected_projid = ZFS_INVALID_PROJID,\n\t\t.zpc_op = ZFS_PROJECT_OP_DEFAULT,\n\t\t.zpc_dironly = B_FALSE,\n\t\t.zpc_keep_projid = B_FALSE,\n\t\t.zpc_newline = B_TRUE,\n\t\t.zpc_recursive = B_FALSE,\n\t\t.zpc_set_flag = B_FALSE,\n\t};\n\tint ret = 0, c;\n\n\tif (argc < 2)\n\t\tusage(B_FALSE);\n\n\twhile ((c = getopt(argc, argv, \"0Ccdkp:rs\")) != -1) {\n\t\tswitch (c) {\n\t\tcase '0':\n\t\t\tzpc.zpc_newline = B_FALSE;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (zpc.zpc_op != ZFS_PROJECT_OP_DEFAULT) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"specify '-C' '-c' '-s' together\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\n\t\t\tzpc.zpc_op = ZFS_PROJECT_OP_CLEAR;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (zpc.zpc_op != ZFS_PROJECT_OP_DEFAULT) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"specify '-C' '-c' '-s' together\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\n\t\t\tzpc.zpc_op = ZFS_PROJECT_OP_CHECK;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tzpc.zpc_dironly = B_TRUE;\n\t\t\t \n\t\t\tzpc.zpc_recursive = B_FALSE;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tzpc.zpc_keep_projid = B_TRUE;\n\t\t\tbreak;\n\t\tcase 'p': {\n\t\t\tchar *endptr;\n\n\t\t\terrno = 0;\n\t\t\tzpc.zpc_expected_projid = strtoull(optarg, &endptr, 0);\n\t\t\tif (errno != 0 || *endptr != '\\0') {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"project ID must be less than \"\n\t\t\t\t    \"%u\\n\"), UINT32_MAX);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tif (zpc.zpc_expected_projid >= UINT32_MAX) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid project ID\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'r':\n\t\t\tzpc.zpc_recursive = B_TRUE;\n\t\t\t \n\t\t\tzpc.zpc_dironly = B_FALSE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (zpc.zpc_op != ZFS_PROJECT_OP_DEFAULT) {\n\t\t\t\t(void) fprintf(stderr, gettext(\"cannot \"\n\t\t\t\t    \"specify '-C' '-c' '-s' together\\n\"));\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\n\t\t\tzpc.zpc_set_flag = B_TRUE;\n\t\t\tzpc.zpc_op = ZFS_PROJECT_OP_SET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\tif (zpc.zpc_op == ZFS_PROJECT_OP_DEFAULT) {\n\t\tif (zpc.zpc_expected_projid != ZFS_INVALID_PROJID)\n\t\t\tzpc.zpc_op = ZFS_PROJECT_OP_SET;\n\t\telse\n\t\t\tzpc.zpc_op = ZFS_PROJECT_OP_LIST;\n\t}\n\n\tswitch (zpc.zpc_op) {\n\tcase ZFS_PROJECT_OP_LIST:\n\t\tif (zpc.zpc_keep_projid) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-k' is only valid together with '-C'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (!zpc.zpc_newline) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-0' is only valid together with '-c'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tbreak;\n\tcase ZFS_PROJECT_OP_CHECK:\n\t\tif (zpc.zpc_keep_projid) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-k' is only valid together with '-C'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tbreak;\n\tcase ZFS_PROJECT_OP_CLEAR:\n\t\tif (zpc.zpc_dironly) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-d' is useless together with '-C'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (!zpc.zpc_newline) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-0' is only valid together with '-c'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (zpc.zpc_expected_projid != ZFS_INVALID_PROJID) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-p' is useless together with '-C'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tbreak;\n\tcase ZFS_PROJECT_OP_SET:\n\t\tif (zpc.zpc_dironly) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-d' is useless for set project ID and/or \"\n\t\t\t    \"inherit flag\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (zpc.zpc_keep_projid) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-k' is only valid together with '-C'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tif (!zpc.zpc_newline) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    gettext(\"'-0' is only valid together with '-c'\\n\"));\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\targv += optind;\n\targc -= optind;\n\tif (argc == 0) {\n\t\t(void) fprintf(stderr,\n\t\t    gettext(\"missing file or directory target(s)\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tfor (int i = 0; i < argc; i++) {\n\t\tint err;\n\n\t\terr = zfs_project_handle(argv[i], &zpc);\n\t\tif (err && !ret)\n\t\t\tret = err;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nzfs_do_wait(int argc, char **argv)\n{\n\tboolean_t enabled[ZFS_WAIT_NUM_ACTIVITIES];\n\tint error = 0, i;\n\tint c;\n\n\t \n\tfor (i = 0; i < ZFS_WAIT_NUM_ACTIVITIES; i++)\n\t\tenabled[i] = B_TRUE;\n\n\twhile ((c = getopt(argc, argv, \"t:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 't':\n\t\t\t \n\t\t\tmemset(&enabled, 0, sizeof (enabled));\n\n\t\t\tfor (char *tok; (tok = strsep(&optarg, \",\")); ) {\n\t\t\t\tstatic const char *const col_subopts[\n\t\t\t\t    ZFS_WAIT_NUM_ACTIVITIES] = { \"deleteq\" };\n\n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(col_subopts); ++i)\n\t\t\t\t\tif (strcmp(tok, col_subopts[i]) == 0) {\n\t\t\t\t\t\tenabled[i] = B_TRUE;\n\t\t\t\t\t\tgoto found;\n\t\t\t\t\t}\n\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    gettext(\"invalid activity '%s'\\n\"), tok);\n\t\t\t\tusage(B_FALSE);\nfound:;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t(void) fprintf(stderr, gettext(\"invalid option '%c'\\n\"),\n\t\t\t    optopt);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t}\n\n\targv += optind;\n\targc -= optind;\n\tif (argc < 1) {\n\t\t(void) fprintf(stderr, gettext(\"missing 'filesystem' \"\n\t\t    \"argument\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 1) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tzfs_handle_t *zhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_FILESYSTEM);\n\tif (zhp == NULL)\n\t\treturn (1);\n\n\tfor (;;) {\n\t\tboolean_t missing = B_FALSE;\n\t\tboolean_t any_waited = B_FALSE;\n\n\t\tfor (int i = 0; i < ZFS_WAIT_NUM_ACTIVITIES; i++) {\n\t\t\tboolean_t waited;\n\n\t\t\tif (!enabled[i])\n\t\t\t\tcontinue;\n\n\t\t\terror = zfs_wait_status(zhp, i, &missing, &waited);\n\t\t\tif (error != 0 || missing)\n\t\t\t\tbreak;\n\n\t\t\tany_waited = (any_waited || waited);\n\t\t}\n\n\t\tif (error != 0 || missing || !any_waited)\n\t\t\tbreak;\n\t}\n\n\tzfs_close(zhp);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_do_version(int argc, char **argv)\n{\n\t(void) argc, (void) argv;\n\treturn (zfs_version_print() != 0);\n}\n\n \nstatic int\nzfs_do_help(int argc, char **argv)\n{\n\tchar page[MAXNAMELEN];\n\tif (argc < 3 || strcmp(argv[2], \"zfs\") == 0)\n\t\tstrcpy(page, \"zfs\");\n\telse if (strcmp(argv[2], \"concepts\") == 0 ||\n\t    strcmp(argv[2], \"props\") == 0)\n\t\tsnprintf(page, sizeof (page), \"zfs%s\", argv[2]);\n\telse\n\t\tsnprintf(page, sizeof (page), \"zfs-%s\", argv[2]);\n\n\texeclp(\"man\", \"man\", page, NULL);\n\n\tfprintf(stderr, \"couldn't run man program: %s\", strerror(errno));\n\treturn (-1);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint ret = 0;\n\tint i = 0;\n\tconst char *cmdname;\n\tchar **newargv;\n\n\t(void) setlocale(LC_ALL, \"\");\n\t(void) setlocale(LC_NUMERIC, \"C\");\n\t(void) textdomain(TEXT_DOMAIN);\n\n\topterr = 0;\n\n\t \n\tif (argc < 2) {\n\t\t(void) fprintf(stderr, gettext(\"missing command\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tcmdname = argv[1];\n\n\t \n\tif (strcmp(cmdname, \"umount\") == 0)\n\t\tcmdname = \"unmount\";\n\n\t \n\tif (strcmp(cmdname, \"recv\") == 0)\n\t\tcmdname = \"receive\";\n\n\t \n\tif (strcmp(cmdname, \"snap\") == 0)\n\t\tcmdname = \"snapshot\";\n\n\t \n\tif ((strcmp(cmdname, \"-?\") == 0) ||\n\t    (strcmp(cmdname, \"--help\") == 0))\n\t\tusage(B_TRUE);\n\n\t \n\tif ((strcmp(cmdname, \"-V\") == 0) || (strcmp(cmdname, \"--version\") == 0))\n\t\treturn (zfs_do_version(argc, argv));\n\n\t \n\tif (strcmp(cmdname, \"help\") == 0)\n\t\treturn (zfs_do_help(argc, argv));\n\n\tif ((g_zfs = libzfs_init()) == NULL) {\n\t\t(void) fprintf(stderr, \"%s\\n\", libzfs_error_init(errno));\n\t\treturn (1);\n\t}\n\n\tzfs_save_arguments(argc, argv, history_str, sizeof (history_str));\n\n\tlibzfs_print_on_error(g_zfs, B_TRUE);\n\n\tzfs_setproctitle_init(argc, argv, environ);\n\n\t \n\tnewargv = safe_malloc((argc + 1) * sizeof (newargv[0]));\n\tfor (i = 0; i < argc; i++)\n\t\tnewargv[i] = strdup(argv[i]);\n\tnewargv[argc] = NULL;\n\n\t \n\tlibzfs_mnttab_cache(g_zfs, B_TRUE);\n\tif (find_command_idx(cmdname, &i) == 0) {\n\t\tcurrent_command = &command_table[i];\n\t\tret = command_table[i].func(argc - 1, newargv + 1);\n\t} else if (strchr(cmdname, '=') != NULL) {\n\t\tverify(find_command_idx(\"set\", &i) == 0);\n\t\tcurrent_command = &command_table[i];\n\t\tret = command_table[i].func(argc, newargv);\n\t} else {\n\t\t(void) fprintf(stderr, gettext(\"unrecognized \"\n\t\t    \"command '%s'\\n\"), cmdname);\n\t\tusage(B_FALSE);\n\t\tret = 1;\n\t}\n\n\tfor (i = 0; i < argc; i++)\n\t\tfree(newargv[i]);\n\tfree(newargv);\n\n\tif (ret == 0 && log_history)\n\t\t(void) zpool_log_history(g_zfs, history_str);\n\n\tlibzfs_fini(g_zfs);\n\n\t \n\tif (getenv(\"ZFS_ABORT\") != NULL) {\n\t\t(void) printf(\"dumping core by request\\n\");\n\t\tabort();\n\t}\n\n\treturn (ret);\n}\n\n \n#ifdef __linux__\nstatic int\nzfs_do_zone_impl(int argc, char **argv, boolean_t attach)\n{\n\tzfs_handle_t *zhp;\n\tint ret;\n\n\tif (argc < 3) {\n\t\t(void) fprintf(stderr, gettext(\"missing argument(s)\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 3) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tzhp = zfs_open(g_zfs, argv[2], ZFS_TYPE_FILESYSTEM);\n\tif (zhp == NULL)\n\t\treturn (1);\n\n\tret = (zfs_userns(zhp, argv[1], attach) != 0);\n\n\tzfs_close(zhp);\n\treturn (ret);\n}\n\nstatic int\nzfs_do_zone(int argc, char **argv)\n{\n\treturn (zfs_do_zone_impl(argc, argv, B_TRUE));\n}\n\nstatic int\nzfs_do_unzone(int argc, char **argv)\n{\n\treturn (zfs_do_zone_impl(argc, argv, B_FALSE));\n}\n#endif\n\n#ifdef __FreeBSD__\n#include <sys/jail.h>\n#include <jail.h>\n \nstatic int\nzfs_do_jail_impl(int argc, char **argv, boolean_t attach)\n{\n\tzfs_handle_t *zhp;\n\tint jailid, ret;\n\n\t \n\tif (argc < 3) {\n\t\t(void) fprintf(stderr, gettext(\"missing argument(s)\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\tif (argc > 3) {\n\t\t(void) fprintf(stderr, gettext(\"too many arguments\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tjailid = jail_getid(argv[1]);\n\tif (jailid < 0) {\n\t\t(void) fprintf(stderr, gettext(\"invalid jail id or name\\n\"));\n\t\tusage(B_FALSE);\n\t}\n\n\tzhp = zfs_open(g_zfs, argv[2], ZFS_TYPE_FILESYSTEM);\n\tif (zhp == NULL)\n\t\treturn (1);\n\n\tret = (zfs_jail(zhp, jailid, attach) != 0);\n\n\tzfs_close(zhp);\n\treturn (ret);\n}\n\n \nstatic int\nzfs_do_jail(int argc, char **argv)\n{\n\treturn (zfs_do_jail_impl(argc, argv, B_TRUE));\n}\n\n \nstatic int\nzfs_do_unjail(int argc, char **argv)\n{\n\treturn (zfs_do_jail_impl(argc, argv, B_FALSE));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}