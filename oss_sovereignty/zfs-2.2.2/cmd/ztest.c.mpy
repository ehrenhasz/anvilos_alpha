{
  "module_name": "ztest.c",
  "hash_id": "9b6e929a244810b91351655a220f312a2528ec99d2cc2d275d394143e9dfb647",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/ztest.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/txg.h>\n#include <sys/dbuf.h>\n#include <sys/zap.h>\n#include <sys/dmu_objset.h>\n#include <sys/poll.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/zio.h>\n#include <sys/zil.h>\n#include <sys/zil_impl.h>\n#include <sys/vdev_draid.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_file.h>\n#include <sys/vdev_initialize.h>\n#include <sys/vdev_raidz.h>\n#include <sys/vdev_trim.h>\n#include <sys/spa_impl.h>\n#include <sys/metaslab_impl.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_scan.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_refcount.h>\n#include <sys/zfeature.h>\n#include <sys/dsl_userhold.h>\n#include <sys/abd.h>\n#include <sys/blake3.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <signal.h>\n#include <umem.h>\n#include <ctype.h>\n#include <math.h>\n#include <sys/fs/zfs.h>\n#include <zfs_fletcher.h>\n#include <libnvpair.h>\n#include <libzutil.h>\n#include <sys/crypto/icp.h>\n#include <sys/zfs_impl.h>\n#if (__GLIBC__ && !__UCLIBC__)\n#include <execinfo.h>  \n#endif\n\nstatic int ztest_fd_data = -1;\nstatic int ztest_fd_rand = -1;\n\ntypedef struct ztest_shared_hdr {\n\tuint64_t\tzh_hdr_size;\n\tuint64_t\tzh_opts_size;\n\tuint64_t\tzh_size;\n\tuint64_t\tzh_stats_size;\n\tuint64_t\tzh_stats_count;\n\tuint64_t\tzh_ds_size;\n\tuint64_t\tzh_ds_count;\n} ztest_shared_hdr_t;\n\nstatic ztest_shared_hdr_t *ztest_shared_hdr;\n\nenum ztest_class_state {\n\tZTEST_VDEV_CLASS_OFF,\n\tZTEST_VDEV_CLASS_ON,\n\tZTEST_VDEV_CLASS_RND\n};\n\n#define\tZO_GVARS_MAX_ARGLEN\t((size_t)64)\n#define\tZO_GVARS_MAX_COUNT\t((size_t)10)\n\ntypedef struct ztest_shared_opts {\n\tchar zo_pool[ZFS_MAX_DATASET_NAME_LEN];\n\tchar zo_dir[ZFS_MAX_DATASET_NAME_LEN];\n\tchar zo_alt_ztest[MAXNAMELEN];\n\tchar zo_alt_libpath[MAXNAMELEN];\n\tuint64_t zo_vdevs;\n\tuint64_t zo_vdevtime;\n\tsize_t zo_vdev_size;\n\tint zo_ashift;\n\tint zo_mirrors;\n\tint zo_raid_children;\n\tint zo_raid_parity;\n\tchar zo_raid_type[8];\n\tint zo_draid_data;\n\tint zo_draid_spares;\n\tint zo_datasets;\n\tint zo_threads;\n\tuint64_t zo_passtime;\n\tuint64_t zo_killrate;\n\tint zo_verbose;\n\tint zo_init;\n\tuint64_t zo_time;\n\tuint64_t zo_maxloops;\n\tuint64_t zo_metaslab_force_ganging;\n\tint zo_mmp_test;\n\tint zo_special_vdevs;\n\tint zo_dump_dbgmsg;\n\tint zo_gvars_count;\n\tchar zo_gvars[ZO_GVARS_MAX_COUNT][ZO_GVARS_MAX_ARGLEN];\n} ztest_shared_opts_t;\n\n \n#define\tDEFAULT_POOL \"ztest\"\n#define\tDEFAULT_VDEV_DIR \"/tmp\"\n#define\tDEFAULT_VDEV_COUNT 5\n#define\tDEFAULT_VDEV_SIZE (SPA_MINDEVSIZE * 4)\t \n#define\tDEFAULT_VDEV_SIZE_STR \"256M\"\n#define\tDEFAULT_ASHIFT SPA_MINBLOCKSHIFT\n#define\tDEFAULT_MIRRORS 2\n#define\tDEFAULT_RAID_CHILDREN 4\n#define\tDEFAULT_RAID_PARITY 1\n#define\tDEFAULT_DRAID_DATA 4\n#define\tDEFAULT_DRAID_SPARES 1\n#define\tDEFAULT_DATASETS_COUNT 7\n#define\tDEFAULT_THREADS 23\n#define\tDEFAULT_RUN_TIME 300  \n#define\tDEFAULT_RUN_TIME_STR \"300 sec\"\n#define\tDEFAULT_PASS_TIME 60  \n#define\tDEFAULT_PASS_TIME_STR \"60 sec\"\n#define\tDEFAULT_KILL_RATE 70  \n#define\tDEFAULT_KILLRATE_STR \"70%\"\n#define\tDEFAULT_INITS 1\n#define\tDEFAULT_MAX_LOOPS 50  \n#define\tDEFAULT_FORCE_GANGING (64 << 10)\n#define\tDEFAULT_FORCE_GANGING_STR \"64K\"\n\n \n#define\tNO_DEFAULT -1\n\nstatic const ztest_shared_opts_t ztest_opts_defaults = {\n\t.zo_pool = DEFAULT_POOL,\n\t.zo_dir = DEFAULT_VDEV_DIR,\n\t.zo_alt_ztest = { '\\0' },\n\t.zo_alt_libpath = { '\\0' },\n\t.zo_vdevs = DEFAULT_VDEV_COUNT,\n\t.zo_ashift = DEFAULT_ASHIFT,\n\t.zo_mirrors = DEFAULT_MIRRORS,\n\t.zo_raid_children = DEFAULT_RAID_CHILDREN,\n\t.zo_raid_parity = DEFAULT_RAID_PARITY,\n\t.zo_raid_type = VDEV_TYPE_RAIDZ,\n\t.zo_vdev_size = DEFAULT_VDEV_SIZE,\n\t.zo_draid_data = DEFAULT_DRAID_DATA,\t \n\t.zo_draid_spares = DEFAULT_DRAID_SPARES,  \n\t.zo_datasets = DEFAULT_DATASETS_COUNT,\n\t.zo_threads = DEFAULT_THREADS,\n\t.zo_passtime = DEFAULT_PASS_TIME,\n\t.zo_killrate = DEFAULT_KILL_RATE,\n\t.zo_verbose = 0,\n\t.zo_mmp_test = 0,\n\t.zo_init = DEFAULT_INITS,\n\t.zo_time = DEFAULT_RUN_TIME,\n\t.zo_maxloops = DEFAULT_MAX_LOOPS,  \n\t.zo_metaslab_force_ganging = DEFAULT_FORCE_GANGING,\n\t.zo_special_vdevs = ZTEST_VDEV_CLASS_RND,\n\t.zo_gvars_count = 0,\n};\n\nextern uint64_t metaslab_force_ganging;\nextern uint64_t metaslab_df_alloc_threshold;\nextern uint64_t zfs_deadman_synctime_ms;\nextern uint_t metaslab_preload_limit;\nextern int zfs_compressed_arc_enabled;\nextern int zfs_abd_scatter_enabled;\nextern uint_t dmu_object_alloc_chunk_shift;\nextern boolean_t zfs_force_some_double_word_sm_entries;\nextern unsigned long zio_decompress_fail_fraction;\nextern unsigned long zfs_reconstruct_indirect_damage_fraction;\n\n\nstatic ztest_shared_opts_t *ztest_shared_opts;\nstatic ztest_shared_opts_t ztest_opts;\nstatic const char *const ztest_wkeydata = \"abcdefghijklmnopqrstuvwxyz012345\";\n\ntypedef struct ztest_shared_ds {\n\tuint64_t\tzd_seq;\n} ztest_shared_ds_t;\n\nstatic ztest_shared_ds_t *ztest_shared_ds;\n#define\tZTEST_GET_SHARED_DS(d) (&ztest_shared_ds[d])\n\n#define\tBT_MAGIC\t0x123456789abcdefULL\n#define\tMAXFAULTS(zs) \\\n\t(MAX((zs)->zs_mirrors, 1) * (ztest_opts.zo_raid_parity + 1) - 1)\n\nenum ztest_io_type {\n\tZTEST_IO_WRITE_TAG,\n\tZTEST_IO_WRITE_PATTERN,\n\tZTEST_IO_WRITE_ZEROES,\n\tZTEST_IO_TRUNCATE,\n\tZTEST_IO_SETATTR,\n\tZTEST_IO_REWRITE,\n\tZTEST_IO_TYPES\n};\n\ntypedef struct ztest_block_tag {\n\tuint64_t\tbt_magic;\n\tuint64_t\tbt_objset;\n\tuint64_t\tbt_object;\n\tuint64_t\tbt_dnodesize;\n\tuint64_t\tbt_offset;\n\tuint64_t\tbt_gen;\n\tuint64_t\tbt_txg;\n\tuint64_t\tbt_crtxg;\n} ztest_block_tag_t;\n\ntypedef struct bufwad {\n\tuint64_t\tbw_index;\n\tuint64_t\tbw_txg;\n\tuint64_t\tbw_data;\n} bufwad_t;\n\n \ntypedef enum {\n\tRL_READER,\n\tRL_WRITER,\n\tRL_APPEND\n} rl_type_t;\n\ntypedef struct rll {\n\tvoid\t\t*rll_writer;\n\tint\t\trll_readers;\n\tkmutex_t\trll_lock;\n\tkcondvar_t\trll_cv;\n} rll_t;\n\ntypedef struct rl {\n\tuint64_t\trl_object;\n\tuint64_t\trl_offset;\n\tuint64_t\trl_size;\n\trll_t\t\t*rl_lock;\n} rl_t;\n\n#define\tZTEST_RANGE_LOCKS\t64\n#define\tZTEST_OBJECT_LOCKS\t64\n\n \ntypedef struct ztest_od {\n\tuint64_t\tod_dir;\n\tuint64_t\tod_object;\n\tdmu_object_type_t od_type;\n\tdmu_object_type_t od_crtype;\n\tuint64_t\tod_blocksize;\n\tuint64_t\tod_crblocksize;\n\tuint64_t\tod_crdnodesize;\n\tuint64_t\tod_gen;\n\tuint64_t\tod_crgen;\n\tchar\t\tod_name[ZFS_MAX_DATASET_NAME_LEN];\n} ztest_od_t;\n\n \ntypedef struct ztest_ds {\n\tztest_shared_ds_t *zd_shared;\n\tobjset_t\t*zd_os;\n\tpthread_rwlock_t zd_zilog_lock;\n\tzilog_t\t\t*zd_zilog;\n\tztest_od_t\t*zd_od;\t\t \n\tchar\t\tzd_name[ZFS_MAX_DATASET_NAME_LEN];\n\tkmutex_t\tzd_dirobj_lock;\n\trll_t\t\tzd_object_lock[ZTEST_OBJECT_LOCKS];\n\trll_t\t\tzd_range_lock[ZTEST_RANGE_LOCKS];\n} ztest_ds_t;\n\n \ntypedef void ztest_func_t(ztest_ds_t *zd, uint64_t id);\n\ntypedef struct ztest_info {\n\tztest_func_t\t*zi_func;\t \n\tuint64_t\tzi_iters;\t \n\tuint64_t\t*zi_interval;\t \n\tconst char\t*zi_funcname;\t \n} ztest_info_t;\n\ntypedef struct ztest_shared_callstate {\n\tuint64_t\tzc_count;\t \n\tuint64_t\tzc_time;\t \n\tuint64_t\tzc_next;\t \n} ztest_shared_callstate_t;\n\nstatic ztest_shared_callstate_t *ztest_shared_callstate;\n#define\tZTEST_GET_SHARED_CALLSTATE(c) (&ztest_shared_callstate[c])\n\nztest_func_t ztest_dmu_read_write;\nztest_func_t ztest_dmu_write_parallel;\nztest_func_t ztest_dmu_object_alloc_free;\nztest_func_t ztest_dmu_object_next_chunk;\nztest_func_t ztest_dmu_commit_callbacks;\nztest_func_t ztest_zap;\nztest_func_t ztest_zap_parallel;\nztest_func_t ztest_zil_commit;\nztest_func_t ztest_zil_remount;\nztest_func_t ztest_dmu_read_write_zcopy;\nztest_func_t ztest_dmu_objset_create_destroy;\nztest_func_t ztest_dmu_prealloc;\nztest_func_t ztest_fzap;\nztest_func_t ztest_dmu_snapshot_create_destroy;\nztest_func_t ztest_dsl_prop_get_set;\nztest_func_t ztest_spa_prop_get_set;\nztest_func_t ztest_spa_create_destroy;\nztest_func_t ztest_fault_inject;\nztest_func_t ztest_dmu_snapshot_hold;\nztest_func_t ztest_mmp_enable_disable;\nztest_func_t ztest_scrub;\nztest_func_t ztest_dsl_dataset_promote_busy;\nztest_func_t ztest_vdev_attach_detach;\nztest_func_t ztest_vdev_LUN_growth;\nztest_func_t ztest_vdev_add_remove;\nztest_func_t ztest_vdev_class_add;\nztest_func_t ztest_vdev_aux_add_remove;\nztest_func_t ztest_split_pool;\nztest_func_t ztest_reguid;\nztest_func_t ztest_spa_upgrade;\nztest_func_t ztest_device_removal;\nztest_func_t ztest_spa_checkpoint_create_discard;\nztest_func_t ztest_initialize;\nztest_func_t ztest_trim;\nztest_func_t ztest_blake3;\nztest_func_t ztest_fletcher;\nztest_func_t ztest_fletcher_incr;\nztest_func_t ztest_verify_dnode_bt;\n\nstatic uint64_t zopt_always = 0ULL * NANOSEC;\t\t \nstatic uint64_t zopt_incessant = 1ULL * NANOSEC / 10;\t \nstatic uint64_t zopt_often = 1ULL * NANOSEC;\t\t \nstatic uint64_t zopt_sometimes = 10ULL * NANOSEC;\t \nstatic uint64_t zopt_rarely = 60ULL * NANOSEC;\t\t \n\n#define\tZTI_INIT(func, iters, interval) \\\n\t{   .zi_func = (func), \\\n\t    .zi_iters = (iters), \\\n\t    .zi_interval = (interval), \\\n\t    .zi_funcname = # func }\n\nstatic ztest_info_t ztest_info[] = {\n\tZTI_INIT(ztest_dmu_read_write, 1, &zopt_always),\n\tZTI_INIT(ztest_dmu_write_parallel, 10, &zopt_always),\n\tZTI_INIT(ztest_dmu_object_alloc_free, 1, &zopt_always),\n\tZTI_INIT(ztest_dmu_object_next_chunk, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_dmu_commit_callbacks, 1, &zopt_always),\n\tZTI_INIT(ztest_zap, 30, &zopt_always),\n\tZTI_INIT(ztest_zap_parallel, 100, &zopt_always),\n\tZTI_INIT(ztest_split_pool, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_zil_commit, 1, &zopt_incessant),\n\tZTI_INIT(ztest_zil_remount, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_dmu_read_write_zcopy, 1, &zopt_often),\n\tZTI_INIT(ztest_dmu_objset_create_destroy, 1, &zopt_often),\n\tZTI_INIT(ztest_dsl_prop_get_set, 1, &zopt_often),\n\tZTI_INIT(ztest_spa_prop_get_set, 1, &zopt_sometimes),\n#if 0\n\tZTI_INIT(ztest_dmu_prealloc, 1, &zopt_sometimes),\n#endif\n\tZTI_INIT(ztest_fzap, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_dmu_snapshot_create_destroy, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_spa_create_destroy, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_fault_inject, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_dmu_snapshot_hold, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_mmp_enable_disable, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_reguid, 1, &zopt_rarely),\n\tZTI_INIT(ztest_scrub, 1, &zopt_rarely),\n\tZTI_INIT(ztest_spa_upgrade, 1, &zopt_rarely),\n\tZTI_INIT(ztest_dsl_dataset_promote_busy, 1, &zopt_rarely),\n\tZTI_INIT(ztest_vdev_attach_detach, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_vdev_LUN_growth, 1, &zopt_rarely),\n\tZTI_INIT(ztest_vdev_add_remove, 1, &ztest_opts.zo_vdevtime),\n\tZTI_INIT(ztest_vdev_class_add, 1, &ztest_opts.zo_vdevtime),\n\tZTI_INIT(ztest_vdev_aux_add_remove, 1, &ztest_opts.zo_vdevtime),\n\tZTI_INIT(ztest_device_removal, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_spa_checkpoint_create_discard, 1, &zopt_rarely),\n\tZTI_INIT(ztest_initialize, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_trim, 1, &zopt_sometimes),\n\tZTI_INIT(ztest_blake3, 1, &zopt_rarely),\n\tZTI_INIT(ztest_fletcher, 1, &zopt_rarely),\n\tZTI_INIT(ztest_fletcher_incr, 1, &zopt_rarely),\n\tZTI_INIT(ztest_verify_dnode_bt, 1, &zopt_sometimes),\n};\n\n#define\tZTEST_FUNCS\t(sizeof (ztest_info) / sizeof (ztest_info_t))\n\n \ntypedef struct ztest_cb_list {\n\tkmutex_t\tzcl_callbacks_lock;\n\tlist_t\t\tzcl_callbacks;\n} ztest_cb_list_t;\n\n \ntypedef struct ztest_shared {\n\tboolean_t\tzs_do_init;\n\thrtime_t\tzs_proc_start;\n\thrtime_t\tzs_proc_stop;\n\thrtime_t\tzs_thread_start;\n\thrtime_t\tzs_thread_stop;\n\thrtime_t\tzs_thread_kill;\n\tuint64_t\tzs_enospc_count;\n\tuint64_t\tzs_vdev_next_leaf;\n\tuint64_t\tzs_vdev_aux;\n\tuint64_t\tzs_alloc;\n\tuint64_t\tzs_space;\n\tuint64_t\tzs_splits;\n\tuint64_t\tzs_mirrors;\n\tuint64_t\tzs_metaslab_sz;\n\tuint64_t\tzs_metaslab_df_alloc_threshold;\n\tuint64_t\tzs_guid;\n} ztest_shared_t;\n\n#define\tID_PARALLEL\t-1ULL\n\nstatic char ztest_dev_template[] = \"%s/%s.%llua\";\nstatic char ztest_aux_template[] = \"%s/%s.%s.%llu\";\nstatic ztest_shared_t *ztest_shared;\n\nstatic spa_t *ztest_spa = NULL;\nstatic ztest_ds_t *ztest_ds;\n\nstatic kmutex_t ztest_vdev_lock;\nstatic boolean_t ztest_device_removal_active = B_FALSE;\nstatic boolean_t ztest_pool_scrubbed = B_FALSE;\nstatic kmutex_t ztest_checkpoint_lock;\n\n \nstatic pthread_rwlock_t ztest_name_lock;\n\nstatic boolean_t ztest_dump_core = B_TRUE;\nstatic boolean_t ztest_exiting;\n\n \nstatic ztest_cb_list_t zcl;\n \nstatic uint64_t zc_min_txg_delay = UINT64_MAX;\nstatic int zc_cb_counter = 0;\n\n \n#define\tZTEST_COMMIT_CB_MIN_REG\t100\n\n \n#define\tZTEST_COMMIT_CB_THRESH\t(TXG_CONCURRENT_STATES + 1000)\n\nenum ztest_object {\n\tZTEST_META_DNODE = 0,\n\tZTEST_DIROBJ,\n\tZTEST_OBJECTS\n};\n\nstatic __attribute__((noreturn)) void usage(boolean_t requested);\nstatic int ztest_scrub_impl(spa_t *spa);\n\n \nconst char *\n_umem_debug_init(void)\n{\n\treturn (\"default,verbose\");  \n}\n\nconst char *\n_umem_logging_init(void)\n{\n\treturn (\"fail,contents\");  \n}\n\nstatic void\ndump_debug_buffer(void)\n{\n\tssize_t ret __attribute__((unused));\n\n\tif (!ztest_opts.zo_dump_dbgmsg)\n\t\treturn;\n\n\t \n\tret = write(STDOUT_FILENO, \"\\n\", 1);\n\tzfs_dbgmsg_print(\"ztest\");\n}\n\n#define\tBACKTRACE_SZ\t100\n\nstatic void sig_handler(int signo)\n{\n\tstruct sigaction action;\n#if (__GLIBC__ && !__UCLIBC__)  \n\tint nptrs;\n\tvoid *buffer[BACKTRACE_SZ];\n\n\tnptrs = backtrace(buffer, BACKTRACE_SZ);\n\tbacktrace_symbols_fd(buffer, nptrs, STDERR_FILENO);\n#endif\n\tdump_debug_buffer();\n\n\t \n\taction.sa_handler = SIG_DFL;\n\tsigemptyset(&action.sa_mask);\n\taction.sa_flags = 0;\n\t(void) sigaction(signo, &action, NULL);\n\traise(signo);\n}\n\n#define\tFATAL_MSG_SZ\t1024\n\nstatic const char *fatal_msg;\n\nstatic __attribute__((format(printf, 2, 3))) __attribute__((noreturn)) void\nfatal(int do_perror, const char *message, ...)\n{\n\tva_list args;\n\tint save_errno = errno;\n\tchar *buf;\n\n\t(void) fflush(stdout);\n\tbuf = umem_alloc(FATAL_MSG_SZ, UMEM_NOFAIL);\n\tif (buf == NULL)\n\t\tgoto out;\n\n\tva_start(args, message);\n\t(void) sprintf(buf, \"ztest: \");\n\t \n\t(void) vsprintf(buf + strlen(buf), message, args);\n\tva_end(args);\n\tif (do_perror) {\n\t\t(void) snprintf(buf + strlen(buf), FATAL_MSG_SZ - strlen(buf),\n\t\t    \": %s\", strerror(save_errno));\n\t}\n\t(void) fprintf(stderr, \"%s\\n\", buf);\n\tfatal_msg = buf;\t\t\t \n\nout:\n\tif (ztest_dump_core)\n\t\tabort();\n\telse\n\t\tdump_debug_buffer();\n\n\texit(3);\n}\n\nstatic int\nstr2shift(const char *buf)\n{\n\tconst char *ends = \"BKMGTPEZ\";\n\tint i;\n\n\tif (buf[0] == '\\0')\n\t\treturn (0);\n\tfor (i = 0; i < strlen(ends); i++) {\n\t\tif (toupper(buf[0]) == ends[i])\n\t\t\tbreak;\n\t}\n\tif (i == strlen(ends)) {\n\t\t(void) fprintf(stderr, \"ztest: invalid bytes suffix: %s\\n\",\n\t\t    buf);\n\t\tusage(B_FALSE);\n\t}\n\tif (buf[1] == '\\0' || (toupper(buf[1]) == 'B' && buf[2] == '\\0')) {\n\t\treturn (10*i);\n\t}\n\t(void) fprintf(stderr, \"ztest: invalid bytes suffix: %s\\n\", buf);\n\tusage(B_FALSE);\n}\n\nstatic uint64_t\nnicenumtoull(const char *buf)\n{\n\tchar *end;\n\tuint64_t val;\n\n\tval = strtoull(buf, &end, 0);\n\tif (end == buf) {\n\t\t(void) fprintf(stderr, \"ztest: bad numeric value: %s\\n\", buf);\n\t\tusage(B_FALSE);\n\t} else if (end[0] == '.') {\n\t\tdouble fval = strtod(buf, &end);\n\t\tfval *= pow(2, str2shift(end));\n\t\t \n\t\tif (fval >= (double)UINT64_MAX) {\n\t\t\t(void) fprintf(stderr, \"ztest: value too large: %s\\n\",\n\t\t\t    buf);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tval = (uint64_t)fval;\n\t} else {\n\t\tint shift = str2shift(end);\n\t\tif (shift >= 64 || (val << shift) >> shift != val) {\n\t\t\t(void) fprintf(stderr, \"ztest: value too large: %s\\n\",\n\t\t\t    buf);\n\t\t\tusage(B_FALSE);\n\t\t}\n\t\tval <<= shift;\n\t}\n\treturn (val);\n}\n\ntypedef struct ztest_option {\n\tconst char\tshort_opt;\n\tconst char\t*long_opt;\n\tconst char\t*long_opt_param;\n\tconst char\t*comment;\n\tunsigned int\tdefault_int;\n\tconst char\t*default_str;\n} ztest_option_t;\n\n \nstatic ztest_option_t option_table[] = {\n\t{ 'v',\t\"vdevs\", \"INTEGER\", \"Number of vdevs\", DEFAULT_VDEV_COUNT,\n\t    NULL},\n\t{ 's',\t\"vdev-size\", \"INTEGER\", \"Size of each vdev\",\n\t    NO_DEFAULT, DEFAULT_VDEV_SIZE_STR},\n\t{ 'a',\t\"alignment-shift\", \"INTEGER\",\n\t    \"Alignment shift; use 0 for random\", DEFAULT_ASHIFT, NULL},\n\t{ 'm',\t\"mirror-copies\", \"INTEGER\", \"Number of mirror copies\",\n\t    DEFAULT_MIRRORS, NULL},\n\t{ 'r',\t\"raid-disks\", \"INTEGER\", \"Number of raidz/draid disks\",\n\t    DEFAULT_RAID_CHILDREN, NULL},\n\t{ 'R',\t\"raid-parity\", \"INTEGER\", \"Raid parity\",\n\t    DEFAULT_RAID_PARITY, NULL},\n\t{ 'K',\t\"raid-kind\", \"raidz|draid|random\", \"Raid kind\",\n\t    NO_DEFAULT, \"random\"},\n\t{ 'D',\t\"draid-data\", \"INTEGER\", \"Number of draid data drives\",\n\t    DEFAULT_DRAID_DATA, NULL},\n\t{ 'S',\t\"draid-spares\", \"INTEGER\", \"Number of draid spares\",\n\t    DEFAULT_DRAID_SPARES, NULL},\n\t{ 'd',\t\"datasets\", \"INTEGER\", \"Number of datasets\",\n\t    DEFAULT_DATASETS_COUNT, NULL},\n\t{ 't',\t\"threads\", \"INTEGER\", \"Number of ztest threads\",\n\t    DEFAULT_THREADS, NULL},\n\t{ 'g',\t\"gang-block-threshold\", \"INTEGER\",\n\t    \"Metaslab gang block threshold\",\n\t    NO_DEFAULT, DEFAULT_FORCE_GANGING_STR},\n\t{ 'i',\t\"init-count\", \"INTEGER\", \"Number of times to initialize pool\",\n\t    DEFAULT_INITS, NULL},\n\t{ 'k',\t\"kill-percentage\", \"INTEGER\", \"Kill percentage\",\n\t    NO_DEFAULT, DEFAULT_KILLRATE_STR},\n\t{ 'p',\t\"pool-name\", \"STRING\", \"Pool name\",\n\t    NO_DEFAULT, DEFAULT_POOL},\n\t{ 'f',\t\"vdev-file-directory\", \"PATH\", \"File directory for vdev files\",\n\t    NO_DEFAULT, DEFAULT_VDEV_DIR},\n\t{ 'M',\t\"multi-host\", NULL,\n\t    \"Multi-host; simulate pool imported on remote host\",\n\t    NO_DEFAULT, NULL},\n\t{ 'E',\t\"use-existing-pool\", NULL,\n\t    \"Use existing pool instead of creating new one\", NO_DEFAULT, NULL},\n\t{ 'T',\t\"run-time\", \"INTEGER\", \"Total run time\",\n\t    NO_DEFAULT, DEFAULT_RUN_TIME_STR},\n\t{ 'P',\t\"pass-time\", \"INTEGER\", \"Time per pass\",\n\t    NO_DEFAULT, DEFAULT_PASS_TIME_STR},\n\t{ 'F',\t\"freeze-loops\", \"INTEGER\", \"Max loops in spa_freeze()\",\n\t    DEFAULT_MAX_LOOPS, NULL},\n\t{ 'B',\t\"alt-ztest\", \"PATH\", \"Alternate ztest path\",\n\t    NO_DEFAULT, NULL},\n\t{ 'C',\t\"vdev-class-state\", \"on|off|random\", \"vdev class state\",\n\t    NO_DEFAULT, \"random\"},\n\t{ 'o',\t\"option\", \"\\\"OPTION=INTEGER\\\"\",\n\t    \"Set global variable to an unsigned 32-bit integer value\",\n\t    NO_DEFAULT, NULL},\n\t{ 'G',\t\"dump-debug-msg\", NULL,\n\t    \"Dump zfs_dbgmsg buffer before exiting due to an error\",\n\t    NO_DEFAULT, NULL},\n\t{ 'V',\t\"verbose\", NULL,\n\t    \"Verbose (use multiple times for ever more verbosity)\",\n\t    NO_DEFAULT, NULL},\n\t{ 'h',\t\"help\",\tNULL, \"Show this help\",\n\t    NO_DEFAULT, NULL},\n\t{0, 0, 0, 0, 0, 0}\n};\n\nstatic struct option *long_opts = NULL;\nstatic char *short_opts = NULL;\n\nstatic void\ninit_options(void)\n{\n\tASSERT3P(long_opts, ==, NULL);\n\tASSERT3P(short_opts, ==, NULL);\n\n\tint count = sizeof (option_table) / sizeof (option_table[0]);\n\tlong_opts = umem_alloc(sizeof (struct option) * count, UMEM_NOFAIL);\n\n\tshort_opts = umem_alloc(sizeof (char) * 2 * count, UMEM_NOFAIL);\n\tint short_opt_index = 0;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tlong_opts[i].val = option_table[i].short_opt;\n\t\tlong_opts[i].name = option_table[i].long_opt;\n\t\tlong_opts[i].has_arg = option_table[i].long_opt_param != NULL\n\t\t    ? required_argument : no_argument;\n\t\tlong_opts[i].flag = NULL;\n\t\tshort_opts[short_opt_index++] = option_table[i].short_opt;\n\t\tif (option_table[i].long_opt_param != NULL) {\n\t\t\tshort_opts[short_opt_index++] = ':';\n\t\t}\n\t}\n}\n\nstatic void\nfini_options(void)\n{\n\tint count = sizeof (option_table) / sizeof (option_table[0]);\n\n\tumem_free(long_opts, sizeof (struct option) * count);\n\tumem_free(short_opts, sizeof (char) * 2 * count);\n\n\tlong_opts = NULL;\n\tshort_opts = NULL;\n}\n\nstatic __attribute__((noreturn)) void\nusage(boolean_t requested)\n{\n\tchar option[80];\n\tFILE *fp = requested ? stdout : stderr;\n\n\t(void) fprintf(fp, \"Usage: %s [OPTIONS...]\\n\", DEFAULT_POOL);\n\tfor (int i = 0; option_table[i].short_opt != 0; i++) {\n\t\tif (option_table[i].long_opt_param != NULL) {\n\t\t\t(void) sprintf(option, \"  -%c --%s=%s\",\n\t\t\t    option_table[i].short_opt,\n\t\t\t    option_table[i].long_opt,\n\t\t\t    option_table[i].long_opt_param);\n\t\t} else {\n\t\t\t(void) sprintf(option, \"  -%c --%s\",\n\t\t\t    option_table[i].short_opt,\n\t\t\t    option_table[i].long_opt);\n\t\t}\n\t\t(void) fprintf(fp, \"  %-40s%s\", option,\n\t\t    option_table[i].comment);\n\n\t\tif (option_table[i].long_opt_param != NULL) {\n\t\t\tif (option_table[i].default_str != NULL) {\n\t\t\t\t(void) fprintf(fp, \" (default: %s)\",\n\t\t\t\t    option_table[i].default_str);\n\t\t\t} else if (option_table[i].default_int != NO_DEFAULT) {\n\t\t\t\t(void) fprintf(fp, \" (default: %u)\",\n\t\t\t\t    option_table[i].default_int);\n\t\t\t}\n\t\t}\n\t\t(void) fprintf(fp, \"\\n\");\n\t}\n\texit(requested ? 0 : 1);\n}\n\nstatic uint64_t\nztest_random(uint64_t range)\n{\n\tuint64_t r;\n\n\tASSERT3S(ztest_fd_rand, >=, 0);\n\n\tif (range == 0)\n\t\treturn (0);\n\n\tif (read(ztest_fd_rand, &r, sizeof (r)) != sizeof (r))\n\t\tfatal(B_TRUE, \"short read from /dev/urandom\");\n\n\treturn (r % range);\n}\n\nstatic void\nztest_parse_name_value(const char *input, ztest_shared_opts_t *zo)\n{\n\tchar name[32];\n\tchar *value;\n\tint state = ZTEST_VDEV_CLASS_RND;\n\n\t(void) strlcpy(name, input, sizeof (name));\n\n\tvalue = strchr(name, '=');\n\tif (value == NULL) {\n\t\t(void) fprintf(stderr, \"missing value in property=value \"\n\t\t    \"'-C' argument (%s)\\n\", input);\n\t\tusage(B_FALSE);\n\t}\n\t*(value) = '\\0';\n\tvalue++;\n\n\tif (strcmp(value, \"on\") == 0) {\n\t\tstate = ZTEST_VDEV_CLASS_ON;\n\t} else if (strcmp(value, \"off\") == 0) {\n\t\tstate = ZTEST_VDEV_CLASS_OFF;\n\t} else if (strcmp(value, \"random\") == 0) {\n\t\tstate = ZTEST_VDEV_CLASS_RND;\n\t} else {\n\t\t(void) fprintf(stderr, \"invalid property value '%s'\\n\", value);\n\t\tusage(B_FALSE);\n\t}\n\n\tif (strcmp(name, \"special\") == 0) {\n\t\tzo->zo_special_vdevs = state;\n\t} else {\n\t\t(void) fprintf(stderr, \"invalid property name '%s'\\n\", name);\n\t\tusage(B_FALSE);\n\t}\n\tif (zo->zo_verbose >= 3)\n\t\t(void) printf(\"%s vdev state is '%s'\\n\", name, value);\n}\n\nstatic void\nprocess_options(int argc, char **argv)\n{\n\tchar *path;\n\tztest_shared_opts_t *zo = &ztest_opts;\n\n\tint opt;\n\tuint64_t value;\n\tconst char *raid_kind = \"random\";\n\n\tmemcpy(zo, &ztest_opts_defaults, sizeof (*zo));\n\n\tinit_options();\n\n\twhile ((opt = getopt_long(argc, argv, short_opts, long_opts,\n\t    NULL)) != EOF) {\n\t\tvalue = 0;\n\t\tswitch (opt) {\n\t\tcase 'v':\n\t\tcase 's':\n\t\tcase 'a':\n\t\tcase 'm':\n\t\tcase 'r':\n\t\tcase 'R':\n\t\tcase 'D':\n\t\tcase 'S':\n\t\tcase 'd':\n\t\tcase 't':\n\t\tcase 'g':\n\t\tcase 'i':\n\t\tcase 'k':\n\t\tcase 'T':\n\t\tcase 'P':\n\t\tcase 'F':\n\t\t\tvalue = nicenumtoull(optarg);\n\t\t}\n\t\tswitch (opt) {\n\t\tcase 'v':\n\t\t\tzo->zo_vdevs = value;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tzo->zo_vdev_size = MAX(SPA_MINDEVSIZE, value);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tzo->zo_ashift = value;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tzo->zo_mirrors = value;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tzo->zo_raid_children = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tzo->zo_raid_parity = MIN(MAX(value, 1), 3);\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\traid_kind = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tzo->zo_draid_data = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tzo->zo_draid_spares = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tzo->zo_datasets = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tzo->zo_threads = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tzo->zo_metaslab_force_ganging =\n\t\t\t    MAX(SPA_MINBLOCKSIZE << 1, value);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tzo->zo_init = value;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tzo->zo_killrate = value;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\t(void) strlcpy(zo->zo_pool, optarg,\n\t\t\t    sizeof (zo->zo_pool));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tpath = realpath(optarg, NULL);\n\t\t\tif (path == NULL) {\n\t\t\t\t(void) fprintf(stderr, \"error: %s: %s\\n\",\n\t\t\t\t    optarg, strerror(errno));\n\t\t\t\tusage(B_FALSE);\n\t\t\t} else {\n\t\t\t\t(void) strlcpy(zo->zo_dir, path,\n\t\t\t\t    sizeof (zo->zo_dir));\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tzo->zo_mmp_test = 1;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tzo->zo_verbose++;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tzo->zo_init = 0;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tzo->zo_time = value;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tzo->zo_passtime = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tzo->zo_maxloops = MAX(1, value);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\t(void) strlcpy(zo->zo_alt_ztest, optarg,\n\t\t\t    sizeof (zo->zo_alt_ztest));\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tztest_parse_name_value(optarg, zo);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (zo->zo_gvars_count >= ZO_GVARS_MAX_COUNT) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"max global var count (%zu) exceeded\\n\",\n\t\t\t\t    ZO_GVARS_MAX_COUNT);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tchar *v = zo->zo_gvars[zo->zo_gvars_count];\n\t\t\tif (strlcpy(v, optarg, ZO_GVARS_MAX_ARGLEN) >=\n\t\t\t    ZO_GVARS_MAX_ARGLEN) {\n\t\t\t\t(void) fprintf(stderr,\n\t\t\t\t    \"global var option '%s' is too long\\n\",\n\t\t\t\t    optarg);\n\t\t\t\tusage(B_FALSE);\n\t\t\t}\n\t\t\tzo->zo_gvars_count++;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tzo->zo_dump_dbgmsg = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(B_TRUE);\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(B_FALSE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfini_options();\n\n\t \n\tif (strcmp(raid_kind, \"random\") == 0) {\n\t\traid_kind = (ztest_random(2) == 0) ? \"draid\" : \"raidz\";\n\n\t\tif (ztest_opts.zo_verbose >= 3)\n\t\t\t(void) printf(\"choosing RAID type '%s'\\n\", raid_kind);\n\t}\n\n\tif (strcmp(raid_kind, \"draid\") == 0) {\n\t\tuint64_t min_devsize;\n\n\t\t \n\t\tmin_devsize = (ztest_opts.zo_raid_children < 16) ?\n\t\t    (256ULL << 20) : (128ULL << 20);\n\n\t\t \n\t\tzo->zo_mirrors = 0;\n\n\t\t \n\t\tif (zo->zo_vdevs == ztest_opts_defaults.zo_vdevs)\n\t\t\tzo->zo_vdevs = 1;\n\t\tif (zo->zo_raid_children ==\n\t\t    ztest_opts_defaults.zo_raid_children)\n\t\t\tzo->zo_raid_children = 16;\n\t\tif (zo->zo_ashift < 12)\n\t\t\tzo->zo_ashift = 12;\n\t\tif (zo->zo_vdev_size < min_devsize)\n\t\t\tzo->zo_vdev_size = min_devsize;\n\n\t\tif (zo->zo_draid_data + zo->zo_raid_parity >\n\t\t    zo->zo_raid_children - zo->zo_draid_spares) {\n\t\t\t(void) fprintf(stderr, \"error: too few draid \"\n\t\t\t    \"children (%d) for stripe width (%d)\\n\",\n\t\t\t    zo->zo_raid_children,\n\t\t\t    zo->zo_draid_data + zo->zo_raid_parity);\n\t\t\tusage(B_FALSE);\n\t\t}\n\n\t\t(void) strlcpy(zo->zo_raid_type, VDEV_TYPE_DRAID,\n\t\t    sizeof (zo->zo_raid_type));\n\n\t} else   {\n\t\tASSERT0(strcmp(raid_kind, \"raidz\"));\n\n\t\tzo->zo_raid_parity = MIN(zo->zo_raid_parity,\n\t\t    zo->zo_raid_children - 1);\n\t}\n\n\tzo->zo_vdevtime =\n\t    (zo->zo_vdevs > 0 ? zo->zo_time * NANOSEC / zo->zo_vdevs :\n\t    UINT64_MAX >> 2);\n\n\tif (*zo->zo_alt_ztest) {\n\t\tconst char *invalid_what = \"ztest\";\n\t\tchar *val = zo->zo_alt_ztest;\n\t\tif (0 != access(val, X_OK) ||\n\t\t    (strrchr(val, '/') == NULL && (errno == EINVAL)))\n\t\t\tgoto invalid;\n\n\t\tint dirlen = strrchr(val, '/') - val;\n\t\tstrlcpy(zo->zo_alt_libpath, val,\n\t\t    MIN(sizeof (zo->zo_alt_libpath), dirlen + 1));\n\t\tinvalid_what = \"library path\", val = zo->zo_alt_libpath;\n\t\tif (strrchr(val, '/') == NULL && (errno == EINVAL))\n\t\t\tgoto invalid;\n\t\t*strrchr(val, '/') = '\\0';\n\t\tstrlcat(val, \"/lib\", sizeof (zo->zo_alt_libpath));\n\n\t\tif (0 != access(zo->zo_alt_libpath, X_OK))\n\t\t\tgoto invalid;\n\t\treturn;\n\ninvalid:\n\t\tztest_dump_core = B_FALSE;\n\t\tfatal(B_TRUE, \"invalid alternate %s %s\", invalid_what, val);\n\t}\n}\n\nstatic void\nztest_kill(ztest_shared_t *zs)\n{\n\tzs->zs_alloc = metaslab_class_get_alloc(spa_normal_class(ztest_spa));\n\tzs->zs_space = metaslab_class_get_space(spa_normal_class(ztest_spa));\n\n\t \n\tmutex_enter(&spa_namespace_lock);\n\tspa_write_cachefile(ztest_spa, B_FALSE, B_FALSE, B_FALSE);\n\tmutex_exit(&spa_namespace_lock);\n\n\t(void) raise(SIGKILL);\n}\n\nstatic void\nztest_record_enospc(const char *s)\n{\n\t(void) s;\n\tztest_shared->zs_enospc_count++;\n}\n\nstatic uint64_t\nztest_get_ashift(void)\n{\n\tif (ztest_opts.zo_ashift == 0)\n\t\treturn (SPA_MINBLOCKSHIFT + ztest_random(5));\n\treturn (ztest_opts.zo_ashift);\n}\n\nstatic boolean_t\nztest_is_draid_spare(const char *name)\n{\n\tuint64_t spare_id = 0, parity = 0, vdev_id = 0;\n\n\tif (sscanf(name, VDEV_TYPE_DRAID \"%\"PRIu64\"-%\"PRIu64\"-%\"PRIu64\"\",\n\t    &parity, &vdev_id, &spare_id) == 3) {\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic nvlist_t *\nmake_vdev_file(const char *path, const char *aux, const char *pool,\n    size_t size, uint64_t ashift)\n{\n\tchar *pathbuf = NULL;\n\tuint64_t vdev;\n\tnvlist_t *file;\n\tboolean_t draid_spare = B_FALSE;\n\n\n\tif (ashift == 0)\n\t\tashift = ztest_get_ashift();\n\n\tif (path == NULL) {\n\t\tpathbuf = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\t\tpath = pathbuf;\n\n\t\tif (aux != NULL) {\n\t\t\tvdev = ztest_shared->zs_vdev_aux;\n\t\t\t(void) snprintf(pathbuf, MAXPATHLEN,\n\t\t\t    ztest_aux_template, ztest_opts.zo_dir,\n\t\t\t    pool == NULL ? ztest_opts.zo_pool : pool,\n\t\t\t    aux, vdev);\n\t\t} else {\n\t\t\tvdev = ztest_shared->zs_vdev_next_leaf++;\n\t\t\t(void) snprintf(pathbuf, MAXPATHLEN,\n\t\t\t    ztest_dev_template, ztest_opts.zo_dir,\n\t\t\t    pool == NULL ? ztest_opts.zo_pool : pool, vdev);\n\t\t}\n\t} else {\n\t\tdraid_spare = ztest_is_draid_spare(path);\n\t}\n\n\tif (size != 0 && !draid_spare) {\n\t\tint fd = open(path, O_RDWR | O_CREAT | O_TRUNC, 0666);\n\t\tif (fd == -1)\n\t\t\tfatal(B_TRUE, \"can't open %s\", path);\n\t\tif (ftruncate(fd, size) != 0)\n\t\t\tfatal(B_TRUE, \"can't ftruncate %s\", path);\n\t\t(void) close(fd);\n\t}\n\n\tfile = fnvlist_alloc();\n\tfnvlist_add_string(file, ZPOOL_CONFIG_TYPE,\n\t    draid_spare ? VDEV_TYPE_DRAID_SPARE : VDEV_TYPE_FILE);\n\tfnvlist_add_string(file, ZPOOL_CONFIG_PATH, path);\n\tfnvlist_add_uint64(file, ZPOOL_CONFIG_ASHIFT, ashift);\n\tumem_free(pathbuf, MAXPATHLEN);\n\n\treturn (file);\n}\n\nstatic nvlist_t *\nmake_vdev_raid(const char *path, const char *aux, const char *pool, size_t size,\n    uint64_t ashift, int r)\n{\n\tnvlist_t *raid, **child;\n\tint c;\n\n\tif (r < 2)\n\t\treturn (make_vdev_file(path, aux, pool, size, ashift));\n\tchild = umem_alloc(r * sizeof (nvlist_t *), UMEM_NOFAIL);\n\n\tfor (c = 0; c < r; c++)\n\t\tchild[c] = make_vdev_file(path, aux, pool, size, ashift);\n\n\traid = fnvlist_alloc();\n\tfnvlist_add_string(raid, ZPOOL_CONFIG_TYPE,\n\t    ztest_opts.zo_raid_type);\n\tfnvlist_add_uint64(raid, ZPOOL_CONFIG_NPARITY,\n\t    ztest_opts.zo_raid_parity);\n\tfnvlist_add_nvlist_array(raid, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)child, r);\n\n\tif (strcmp(ztest_opts.zo_raid_type, VDEV_TYPE_DRAID) == 0) {\n\t\tuint64_t ndata = ztest_opts.zo_draid_data;\n\t\tuint64_t nparity = ztest_opts.zo_raid_parity;\n\t\tuint64_t nspares = ztest_opts.zo_draid_spares;\n\t\tuint64_t children = ztest_opts.zo_raid_children;\n\t\tuint64_t ngroups = 1;\n\n\t\t \n\t\twhile (ngroups * (ndata + nparity) % (children - nspares) != 0)\n\t\t\tngroups++;\n\n\t\t \n\t\tfnvlist_add_uint64(raid, ZPOOL_CONFIG_DRAID_NDATA, ndata);\n\t\tfnvlist_add_uint64(raid, ZPOOL_CONFIG_DRAID_NSPARES, nspares);\n\t\tfnvlist_add_uint64(raid, ZPOOL_CONFIG_DRAID_NGROUPS, ngroups);\n\t}\n\n\tfor (c = 0; c < r; c++)\n\t\tfnvlist_free(child[c]);\n\n\tumem_free(child, r * sizeof (nvlist_t *));\n\n\treturn (raid);\n}\n\nstatic nvlist_t *\nmake_vdev_mirror(const char *path, const char *aux, const char *pool,\n    size_t size, uint64_t ashift, int r, int m)\n{\n\tnvlist_t *mirror, **child;\n\tint c;\n\n\tif (m < 1)\n\t\treturn (make_vdev_raid(path, aux, pool, size, ashift, r));\n\n\tchild = umem_alloc(m * sizeof (nvlist_t *), UMEM_NOFAIL);\n\n\tfor (c = 0; c < m; c++)\n\t\tchild[c] = make_vdev_raid(path, aux, pool, size, ashift, r);\n\n\tmirror = fnvlist_alloc();\n\tfnvlist_add_string(mirror, ZPOOL_CONFIG_TYPE, VDEV_TYPE_MIRROR);\n\tfnvlist_add_nvlist_array(mirror, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)child, m);\n\n\tfor (c = 0; c < m; c++)\n\t\tfnvlist_free(child[c]);\n\n\tumem_free(child, m * sizeof (nvlist_t *));\n\n\treturn (mirror);\n}\n\nstatic nvlist_t *\nmake_vdev_root(const char *path, const char *aux, const char *pool, size_t size,\n    uint64_t ashift, const char *class, int r, int m, int t)\n{\n\tnvlist_t *root, **child;\n\tint c;\n\tboolean_t log;\n\n\tASSERT3S(t, >, 0);\n\n\tlog = (class != NULL && strcmp(class, \"log\") == 0);\n\n\tchild = umem_alloc(t * sizeof (nvlist_t *), UMEM_NOFAIL);\n\n\tfor (c = 0; c < t; c++) {\n\t\tchild[c] = make_vdev_mirror(path, aux, pool, size, ashift,\n\t\t    r, m);\n\t\tfnvlist_add_uint64(child[c], ZPOOL_CONFIG_IS_LOG, log);\n\n\t\tif (class != NULL && class[0] != '\\0') {\n\t\t\tASSERT(m > 1 || log);    \n\t\t\tfnvlist_add_string(child[c],\n\t\t\t    ZPOOL_CONFIG_ALLOCATION_BIAS, class);\n\t\t}\n\t}\n\n\troot = fnvlist_alloc();\n\tfnvlist_add_string(root, ZPOOL_CONFIG_TYPE, VDEV_TYPE_ROOT);\n\tfnvlist_add_nvlist_array(root, aux ? aux : ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)child, t);\n\n\tfor (c = 0; c < t; c++)\n\t\tfnvlist_free(child[c]);\n\n\tumem_free(child, t * sizeof (nvlist_t *));\n\n\treturn (root);\n}\n\n \nstatic uint64_t\nztest_random_spa_version(uint64_t initial_version)\n{\n\tuint64_t version = initial_version;\n\n\tif (version <= SPA_VERSION_BEFORE_FEATURES) {\n\t\tversion = version +\n\t\t    ztest_random(SPA_VERSION_BEFORE_FEATURES - version + 1);\n\t}\n\n\tif (version > SPA_VERSION_BEFORE_FEATURES)\n\t\tversion = SPA_VERSION_FEATURES;\n\n\tASSERT(SPA_VERSION_IS_SUPPORTED(version));\n\treturn (version);\n}\n\nstatic int\nztest_random_blocksize(void)\n{\n\tASSERT3U(ztest_spa->spa_max_ashift, !=, 0);\n\n\t \n\tint maxbs = SPA_OLD_MAXBLOCKSHIFT;\n\tif (spa_maxblocksize(ztest_spa) == SPA_MAXBLOCKSIZE)\n\t\tmaxbs = 20;\n\tuint64_t block_shift =\n\t    ztest_random(maxbs - ztest_spa->spa_max_ashift + 1);\n\treturn (1 << (SPA_MINBLOCKSHIFT + block_shift));\n}\n\nstatic int\nztest_random_dnodesize(void)\n{\n\tint slots;\n\tint max_slots = spa_maxdnodesize(ztest_spa) >> DNODE_SHIFT;\n\n\tif (max_slots == DNODE_MIN_SLOTS)\n\t\treturn (DNODE_MIN_SIZE);\n\n\t \n\tASSERT3U(max_slots, >, 4);\n\tswitch (ztest_random(10)) {\n\tcase 0:\n\t\tslots = 5 + ztest_random(max_slots - 4);\n\t\tbreak;\n\tcase 1 ... 4:\n\t\tslots = 2 + ztest_random(3);\n\t\tbreak;\n\tdefault:\n\t\tslots = 1;\n\t\tbreak;\n\t}\n\n\treturn (slots << DNODE_SHIFT);\n}\n\nstatic int\nztest_random_ibshift(void)\n{\n\treturn (DN_MIN_INDBLKSHIFT +\n\t    ztest_random(DN_MAX_INDBLKSHIFT - DN_MIN_INDBLKSHIFT + 1));\n}\n\nstatic uint64_t\nztest_random_vdev_top(spa_t *spa, boolean_t log_ok)\n{\n\tuint64_t top;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tvdev_t *tvd;\n\n\tASSERT3U(spa_config_held(spa, SCL_ALL, RW_READER), !=, 0);\n\n\tdo {\n\t\ttop = ztest_random(rvd->vdev_children);\n\t\ttvd = rvd->vdev_child[top];\n\t} while (!vdev_is_concrete(tvd) || (tvd->vdev_islog && !log_ok) ||\n\t    tvd->vdev_mg == NULL || tvd->vdev_mg->mg_class == NULL);\n\n\treturn (top);\n}\n\nstatic uint64_t\nztest_random_dsl_prop(zfs_prop_t prop)\n{\n\tuint64_t value;\n\n\tdo {\n\t\tvalue = zfs_prop_random_value(prop, ztest_random(-1ULL));\n\t} while (prop == ZFS_PROP_CHECKSUM && value == ZIO_CHECKSUM_OFF);\n\n\treturn (value);\n}\n\nstatic int\nztest_dsl_prop_set_uint64(char *osname, zfs_prop_t prop, uint64_t value,\n    boolean_t inherit)\n{\n\tconst char *propname = zfs_prop_to_name(prop);\n\tconst char *valname;\n\tchar *setpoint;\n\tuint64_t curval;\n\tint error;\n\n\terror = dsl_prop_set_int(osname, propname,\n\t    (inherit ? ZPROP_SRC_NONE : ZPROP_SRC_LOCAL), value);\n\n\tif (error == ENOSPC) {\n\t\tztest_record_enospc(FTAG);\n\t\treturn (error);\n\t}\n\tASSERT0(error);\n\n\tsetpoint = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\tVERIFY0(dsl_prop_get_integer(osname, propname, &curval, setpoint));\n\n\tif (ztest_opts.zo_verbose >= 6) {\n\t\tint err;\n\n\t\terr = zfs_prop_index_to_string(prop, curval, &valname);\n\t\tif (err)\n\t\t\t(void) printf(\"%s %s = %llu at '%s'\\n\", osname,\n\t\t\t    propname, (unsigned long long)curval, setpoint);\n\t\telse\n\t\t\t(void) printf(\"%s %s = %s at '%s'\\n\",\n\t\t\t    osname, propname, valname, setpoint);\n\t}\n\tumem_free(setpoint, MAXPATHLEN);\n\n\treturn (error);\n}\n\nstatic int\nztest_spa_prop_set_uint64(zpool_prop_t prop, uint64_t value)\n{\n\tspa_t *spa = ztest_spa;\n\tnvlist_t *props = NULL;\n\tint error;\n\n\tprops = fnvlist_alloc();\n\tfnvlist_add_uint64(props, zpool_prop_to_name(prop), value);\n\n\terror = spa_prop_set(spa, props);\n\n\tfnvlist_free(props);\n\n\tif (error == ENOSPC) {\n\t\tztest_record_enospc(FTAG);\n\t\treturn (error);\n\t}\n\tASSERT0(error);\n\n\treturn (error);\n}\n\nstatic int\nztest_dmu_objset_own(const char *name, dmu_objset_type_t type,\n    boolean_t readonly, boolean_t decrypt, const void *tag, objset_t **osp)\n{\n\tint err;\n\tchar *cp = NULL;\n\tchar ddname[ZFS_MAX_DATASET_NAME_LEN];\n\n\tstrlcpy(ddname, name, sizeof (ddname));\n\tcp = strchr(ddname, '@');\n\tif (cp != NULL)\n\t\t*cp = '\\0';\n\n\terr = dmu_objset_own(name, type, readonly, decrypt, tag, osp);\n\twhile (decrypt && err == EACCES) {\n\t\tdsl_crypto_params_t *dcp;\n\t\tnvlist_t *crypto_args = fnvlist_alloc();\n\n\t\tfnvlist_add_uint8_array(crypto_args, \"wkeydata\",\n\t\t    (uint8_t *)ztest_wkeydata, WRAPPING_KEY_LEN);\n\t\tVERIFY0(dsl_crypto_params_create_nvlist(DCP_CMD_NONE, NULL,\n\t\t    crypto_args, &dcp));\n\t\terr = spa_keystore_load_wkey(ddname, dcp, B_FALSE);\n\t\t \n\t\tdsl_crypto_params_free(dcp, (err != 0));\n\t\tfnvlist_free(crypto_args);\n\n\t\tif (err == EINVAL) {\n\t\t\t \n\t\t\tcp = strrchr(ddname, '/');\n\t\t\tif (cp == NULL)\n\t\t\t\treturn (err);\n\n\t\t\t*cp = '\\0';\n\t\t\terr = EACCES;\n\t\t\tcontinue;\n\t\t} else if (err != 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dmu_objset_own(name, type, readonly, decrypt, tag, osp);\n\t\tbreak;\n\t}\n\n\treturn (err);\n}\n\nstatic void\nztest_rll_init(rll_t *rll)\n{\n\trll->rll_writer = NULL;\n\trll->rll_readers = 0;\n\tmutex_init(&rll->rll_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&rll->rll_cv, NULL, CV_DEFAULT, NULL);\n}\n\nstatic void\nztest_rll_destroy(rll_t *rll)\n{\n\tASSERT3P(rll->rll_writer, ==, NULL);\n\tASSERT0(rll->rll_readers);\n\tmutex_destroy(&rll->rll_lock);\n\tcv_destroy(&rll->rll_cv);\n}\n\nstatic void\nztest_rll_lock(rll_t *rll, rl_type_t type)\n{\n\tmutex_enter(&rll->rll_lock);\n\n\tif (type == RL_READER) {\n\t\twhile (rll->rll_writer != NULL)\n\t\t\t(void) cv_wait(&rll->rll_cv, &rll->rll_lock);\n\t\trll->rll_readers++;\n\t} else {\n\t\twhile (rll->rll_writer != NULL || rll->rll_readers)\n\t\t\t(void) cv_wait(&rll->rll_cv, &rll->rll_lock);\n\t\trll->rll_writer = curthread;\n\t}\n\n\tmutex_exit(&rll->rll_lock);\n}\n\nstatic void\nztest_rll_unlock(rll_t *rll)\n{\n\tmutex_enter(&rll->rll_lock);\n\n\tif (rll->rll_writer) {\n\t\tASSERT0(rll->rll_readers);\n\t\trll->rll_writer = NULL;\n\t} else {\n\t\tASSERT3S(rll->rll_readers, >, 0);\n\t\tASSERT3P(rll->rll_writer, ==, NULL);\n\t\trll->rll_readers--;\n\t}\n\n\tif (rll->rll_writer == NULL && rll->rll_readers == 0)\n\t\tcv_broadcast(&rll->rll_cv);\n\n\tmutex_exit(&rll->rll_lock);\n}\n\nstatic void\nztest_object_lock(ztest_ds_t *zd, uint64_t object, rl_type_t type)\n{\n\trll_t *rll = &zd->zd_object_lock[object & (ZTEST_OBJECT_LOCKS - 1)];\n\n\tztest_rll_lock(rll, type);\n}\n\nstatic void\nztest_object_unlock(ztest_ds_t *zd, uint64_t object)\n{\n\trll_t *rll = &zd->zd_object_lock[object & (ZTEST_OBJECT_LOCKS - 1)];\n\n\tztest_rll_unlock(rll);\n}\n\nstatic rl_t *\nztest_range_lock(ztest_ds_t *zd, uint64_t object, uint64_t offset,\n    uint64_t size, rl_type_t type)\n{\n\tuint64_t hash = object ^ (offset % (ZTEST_RANGE_LOCKS + 1));\n\trll_t *rll = &zd->zd_range_lock[hash & (ZTEST_RANGE_LOCKS - 1)];\n\trl_t *rl;\n\n\trl = umem_alloc(sizeof (*rl), UMEM_NOFAIL);\n\trl->rl_object = object;\n\trl->rl_offset = offset;\n\trl->rl_size = size;\n\trl->rl_lock = rll;\n\n\tztest_rll_lock(rll, type);\n\n\treturn (rl);\n}\n\nstatic void\nztest_range_unlock(rl_t *rl)\n{\n\trll_t *rll = rl->rl_lock;\n\n\tztest_rll_unlock(rll);\n\n\tumem_free(rl, sizeof (*rl));\n}\n\nstatic void\nztest_zd_init(ztest_ds_t *zd, ztest_shared_ds_t *szd, objset_t *os)\n{\n\tzd->zd_os = os;\n\tzd->zd_zilog = dmu_objset_zil(os);\n\tzd->zd_shared = szd;\n\tdmu_objset_name(os, zd->zd_name);\n\tint l;\n\n\tif (zd->zd_shared != NULL)\n\t\tzd->zd_shared->zd_seq = 0;\n\n\tVERIFY0(pthread_rwlock_init(&zd->zd_zilog_lock, NULL));\n\tmutex_init(&zd->zd_dirobj_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tfor (l = 0; l < ZTEST_OBJECT_LOCKS; l++)\n\t\tztest_rll_init(&zd->zd_object_lock[l]);\n\n\tfor (l = 0; l < ZTEST_RANGE_LOCKS; l++)\n\t\tztest_rll_init(&zd->zd_range_lock[l]);\n}\n\nstatic void\nztest_zd_fini(ztest_ds_t *zd)\n{\n\tint l;\n\n\tmutex_destroy(&zd->zd_dirobj_lock);\n\t(void) pthread_rwlock_destroy(&zd->zd_zilog_lock);\n\n\tfor (l = 0; l < ZTEST_OBJECT_LOCKS; l++)\n\t\tztest_rll_destroy(&zd->zd_object_lock[l]);\n\n\tfor (l = 0; l < ZTEST_RANGE_LOCKS; l++)\n\t\tztest_rll_destroy(&zd->zd_range_lock[l]);\n}\n\n#define\tTXG_MIGHTWAIT\t(ztest_random(10) == 0 ? TXG_NOWAIT : TXG_WAIT)\n\nstatic uint64_t\nztest_tx_assign(dmu_tx_t *tx, uint64_t txg_how, const char *tag)\n{\n\tuint64_t txg;\n\tint error;\n\n\t \n\terror = dmu_tx_assign(tx, txg_how);\n\tif (error) {\n\t\tif (error == ERESTART) {\n\t\t\tASSERT3U(txg_how, ==, TXG_NOWAIT);\n\t\t\tdmu_tx_wait(tx);\n\t\t} else {\n\t\t\tASSERT3U(error, ==, ENOSPC);\n\t\t\tztest_record_enospc(tag);\n\t\t}\n\t\tdmu_tx_abort(tx);\n\t\treturn (0);\n\t}\n\ttxg = dmu_tx_get_txg(tx);\n\tASSERT3U(txg, !=, 0);\n\treturn (txg);\n}\n\nstatic void\nztest_bt_generate(ztest_block_tag_t *bt, objset_t *os, uint64_t object,\n    uint64_t dnodesize, uint64_t offset, uint64_t gen, uint64_t txg,\n    uint64_t crtxg)\n{\n\tbt->bt_magic = BT_MAGIC;\n\tbt->bt_objset = dmu_objset_id(os);\n\tbt->bt_object = object;\n\tbt->bt_dnodesize = dnodesize;\n\tbt->bt_offset = offset;\n\tbt->bt_gen = gen;\n\tbt->bt_txg = txg;\n\tbt->bt_crtxg = crtxg;\n}\n\nstatic void\nztest_bt_verify(ztest_block_tag_t *bt, objset_t *os, uint64_t object,\n    uint64_t dnodesize, uint64_t offset, uint64_t gen, uint64_t txg,\n    uint64_t crtxg)\n{\n\tASSERT3U(bt->bt_magic, ==, BT_MAGIC);\n\tASSERT3U(bt->bt_objset, ==, dmu_objset_id(os));\n\tASSERT3U(bt->bt_object, ==, object);\n\tASSERT3U(bt->bt_dnodesize, ==, dnodesize);\n\tASSERT3U(bt->bt_offset, ==, offset);\n\tASSERT3U(bt->bt_gen, <=, gen);\n\tASSERT3U(bt->bt_txg, <=, txg);\n\tASSERT3U(bt->bt_crtxg, ==, crtxg);\n}\n\nstatic ztest_block_tag_t *\nztest_bt_bonus(dmu_buf_t *db)\n{\n\tdmu_object_info_t doi;\n\tztest_block_tag_t *bt;\n\n\tdmu_object_info_from_db(db, &doi);\n\tASSERT3U(doi.doi_bonus_size, <=, db->db_size);\n\tASSERT3U(doi.doi_bonus_size, >=, sizeof (*bt));\n\tbt = (void *)((char *)db->db_data + doi.doi_bonus_size - sizeof (*bt));\n\n\treturn (bt);\n}\n\n \n#define\tZTEST_BONUS_FILL_TOKEN(obj, ds, gen, offset) \\\n\t(((ds) << 48) | ((gen) << 32) | ((obj) << 8) | (offset))\n\n \nstatic void\nztest_fill_unused_bonus(dmu_buf_t *db, void *end, uint64_t obj,\n    objset_t *os, uint64_t gen)\n{\n\tuint64_t *bonusp;\n\n\tASSERT(IS_P2ALIGNED((char *)end - (char *)db->db_data, 8));\n\n\tfor (bonusp = db->db_data; bonusp < (uint64_t *)end; bonusp++) {\n\t\tuint64_t token = ZTEST_BONUS_FILL_TOKEN(obj, dmu_objset_id(os),\n\t\t    gen, bonusp - (uint64_t *)db->db_data);\n\t\t*bonusp = token;\n\t}\n}\n\n \nstatic void\nztest_verify_unused_bonus(dmu_buf_t *db, void *end, uint64_t obj,\n    objset_t *os, uint64_t gen)\n{\n\tuint64_t *bonusp;\n\n\tfor (bonusp = db->db_data; bonusp < (uint64_t *)end; bonusp++) {\n\t\tuint64_t token = ZTEST_BONUS_FILL_TOKEN(obj, dmu_objset_id(os),\n\t\t    gen, bonusp - (uint64_t *)db->db_data);\n\t\tVERIFY3U(*bonusp, ==, token);\n\t}\n}\n\n \n\n#define\tlrz_type\tlr_mode\n#define\tlrz_blocksize\tlr_uid\n#define\tlrz_ibshift\tlr_gid\n#define\tlrz_bonustype\tlr_rdev\n#define\tlrz_dnodesize\tlr_crtime[1]\n\nstatic void\nztest_log_create(ztest_ds_t *zd, dmu_tx_t *tx, lr_create_t *lr)\n{\n\tchar *name = (void *)(lr + 1);\t\t \n\tsize_t namesize = strlen(name) + 1;\n\titx_t *itx;\n\n\tif (zil_replaying(zd->zd_zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(TX_CREATE, sizeof (*lr) + namesize);\n\tmemcpy(&itx->itx_lr + 1, &lr->lr_common + 1,\n\t    sizeof (*lr) + namesize - sizeof (lr_t));\n\n\tzil_itx_assign(zd->zd_zilog, itx, tx);\n}\n\nstatic void\nztest_log_remove(ztest_ds_t *zd, dmu_tx_t *tx, lr_remove_t *lr, uint64_t object)\n{\n\tchar *name = (void *)(lr + 1);\t\t \n\tsize_t namesize = strlen(name) + 1;\n\titx_t *itx;\n\n\tif (zil_replaying(zd->zd_zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(TX_REMOVE, sizeof (*lr) + namesize);\n\tmemcpy(&itx->itx_lr + 1, &lr->lr_common + 1,\n\t    sizeof (*lr) + namesize - sizeof (lr_t));\n\n\titx->itx_oid = object;\n\tzil_itx_assign(zd->zd_zilog, itx, tx);\n}\n\nstatic void\nztest_log_write(ztest_ds_t *zd, dmu_tx_t *tx, lr_write_t *lr)\n{\n\titx_t *itx;\n\titx_wr_state_t write_state = ztest_random(WR_NUM_STATES);\n\n\tif (zil_replaying(zd->zd_zilog, tx))\n\t\treturn;\n\n\tif (lr->lr_length > zil_max_log_data(zd->zd_zilog, sizeof (lr_write_t)))\n\t\twrite_state = WR_INDIRECT;\n\n\titx = zil_itx_create(TX_WRITE,\n\t    sizeof (*lr) + (write_state == WR_COPIED ? lr->lr_length : 0));\n\n\tif (write_state == WR_COPIED &&\n\t    dmu_read(zd->zd_os, lr->lr_foid, lr->lr_offset, lr->lr_length,\n\t    ((lr_write_t *)&itx->itx_lr) + 1, DMU_READ_NO_PREFETCH) != 0) {\n\t\tzil_itx_destroy(itx);\n\t\titx = zil_itx_create(TX_WRITE, sizeof (*lr));\n\t\twrite_state = WR_NEED_COPY;\n\t}\n\titx->itx_private = zd;\n\titx->itx_wr_state = write_state;\n\titx->itx_sync = (ztest_random(8) == 0);\n\n\tmemcpy(&itx->itx_lr + 1, &lr->lr_common + 1,\n\t    sizeof (*lr) - sizeof (lr_t));\n\n\tzil_itx_assign(zd->zd_zilog, itx, tx);\n}\n\nstatic void\nztest_log_truncate(ztest_ds_t *zd, dmu_tx_t *tx, lr_truncate_t *lr)\n{\n\titx_t *itx;\n\n\tif (zil_replaying(zd->zd_zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(TX_TRUNCATE, sizeof (*lr));\n\tmemcpy(&itx->itx_lr + 1, &lr->lr_common + 1,\n\t    sizeof (*lr) - sizeof (lr_t));\n\n\titx->itx_sync = B_FALSE;\n\tzil_itx_assign(zd->zd_zilog, itx, tx);\n}\n\nstatic void\nztest_log_setattr(ztest_ds_t *zd, dmu_tx_t *tx, lr_setattr_t *lr)\n{\n\titx_t *itx;\n\n\tif (zil_replaying(zd->zd_zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(TX_SETATTR, sizeof (*lr));\n\tmemcpy(&itx->itx_lr + 1, &lr->lr_common + 1,\n\t    sizeof (*lr) - sizeof (lr_t));\n\n\titx->itx_sync = B_FALSE;\n\tzil_itx_assign(zd->zd_zilog, itx, tx);\n}\n\n \nstatic int\nztest_replay_create(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tztest_ds_t *zd = arg1;\n\tlr_create_t *lr = arg2;\n\tchar *name = (void *)(lr + 1);\t\t \n\tobjset_t *os = zd->zd_os;\n\tztest_block_tag_t *bbt;\n\tdmu_buf_t *db;\n\tdmu_tx_t *tx;\n\tuint64_t txg;\n\tint error = 0;\n\tint bonuslen;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tASSERT3U(lr->lr_doid, ==, ZTEST_DIROBJ);\n\tASSERT3S(name[0], !=, '\\0');\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_zap(tx, lr->lr_doid, B_TRUE, name);\n\n\tif (lr->lrz_type == DMU_OT_ZAP_OTHER) {\n\t\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, B_TRUE, NULL);\n\t} else {\n\t\tdmu_tx_hold_bonus(tx, DMU_NEW_OBJECT);\n\t}\n\n\ttxg = ztest_tx_assign(tx, TXG_WAIT, FTAG);\n\tif (txg == 0)\n\t\treturn (ENOSPC);\n\n\tASSERT3U(dmu_objset_zil(os)->zl_replay, ==, !!lr->lr_foid);\n\tbonuslen = DN_BONUS_SIZE(lr->lrz_dnodesize);\n\n\tif (lr->lrz_type == DMU_OT_ZAP_OTHER) {\n\t\tif (lr->lr_foid == 0) {\n\t\t\tlr->lr_foid = zap_create_dnsize(os,\n\t\t\t    lr->lrz_type, lr->lrz_bonustype,\n\t\t\t    bonuslen, lr->lrz_dnodesize, tx);\n\t\t} else {\n\t\t\terror = zap_create_claim_dnsize(os, lr->lr_foid,\n\t\t\t    lr->lrz_type, lr->lrz_bonustype,\n\t\t\t    bonuslen, lr->lrz_dnodesize, tx);\n\t\t}\n\t} else {\n\t\tif (lr->lr_foid == 0) {\n\t\t\tlr->lr_foid = dmu_object_alloc_dnsize(os,\n\t\t\t    lr->lrz_type, 0, lr->lrz_bonustype,\n\t\t\t    bonuslen, lr->lrz_dnodesize, tx);\n\t\t} else {\n\t\t\terror = dmu_object_claim_dnsize(os, lr->lr_foid,\n\t\t\t    lr->lrz_type, 0, lr->lrz_bonustype,\n\t\t\t    bonuslen, lr->lrz_dnodesize, tx);\n\t\t}\n\t}\n\n\tif (error) {\n\t\tASSERT3U(error, ==, EEXIST);\n\t\tASSERT(zd->zd_zilog->zl_replay);\n\t\tdmu_tx_commit(tx);\n\t\treturn (error);\n\t}\n\n\tASSERT3U(lr->lr_foid, !=, 0);\n\n\tif (lr->lrz_type != DMU_OT_ZAP_OTHER)\n\t\tVERIFY0(dmu_object_set_blocksize(os, lr->lr_foid,\n\t\t    lr->lrz_blocksize, lr->lrz_ibshift, tx));\n\n\tVERIFY0(dmu_bonus_hold(os, lr->lr_foid, FTAG, &db));\n\tbbt = ztest_bt_bonus(db);\n\tdmu_buf_will_dirty(db, tx);\n\tztest_bt_generate(bbt, os, lr->lr_foid, lr->lrz_dnodesize, -1ULL,\n\t    lr->lr_gen, txg, txg);\n\tztest_fill_unused_bonus(db, bbt, lr->lr_foid, os, lr->lr_gen);\n\tdmu_buf_rele(db, FTAG);\n\n\tVERIFY0(zap_add(os, lr->lr_doid, name, sizeof (uint64_t), 1,\n\t    &lr->lr_foid, tx));\n\n\t(void) ztest_log_create(zd, tx, lr);\n\n\tdmu_tx_commit(tx);\n\n\treturn (0);\n}\n\nstatic int\nztest_replay_remove(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tztest_ds_t *zd = arg1;\n\tlr_remove_t *lr = arg2;\n\tchar *name = (void *)(lr + 1);\t\t \n\tobjset_t *os = zd->zd_os;\n\tdmu_object_info_t doi;\n\tdmu_tx_t *tx;\n\tuint64_t object, txg;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tASSERT3U(lr->lr_doid, ==, ZTEST_DIROBJ);\n\tASSERT3S(name[0], !=, '\\0');\n\n\tVERIFY0(\n\t    zap_lookup(os, lr->lr_doid, name, sizeof (object), 1, &object));\n\tASSERT3U(object, !=, 0);\n\n\tztest_object_lock(zd, object, RL_WRITER);\n\n\tVERIFY0(dmu_object_info(os, object, &doi));\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_zap(tx, lr->lr_doid, B_FALSE, name);\n\tdmu_tx_hold_free(tx, object, 0, DMU_OBJECT_END);\n\n\ttxg = ztest_tx_assign(tx, TXG_WAIT, FTAG);\n\tif (txg == 0) {\n\t\tztest_object_unlock(zd, object);\n\t\treturn (ENOSPC);\n\t}\n\n\tif (doi.doi_type == DMU_OT_ZAP_OTHER) {\n\t\tVERIFY0(zap_destroy(os, object, tx));\n\t} else {\n\t\tVERIFY0(dmu_object_free(os, object, tx));\n\t}\n\n\tVERIFY0(zap_remove(os, lr->lr_doid, name, tx));\n\n\t(void) ztest_log_remove(zd, tx, lr, object);\n\n\tdmu_tx_commit(tx);\n\n\tztest_object_unlock(zd, object);\n\n\treturn (0);\n}\n\nstatic int\nztest_replay_write(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tztest_ds_t *zd = arg1;\n\tlr_write_t *lr = arg2;\n\tobjset_t *os = zd->zd_os;\n\tvoid *data = lr + 1;\t\t\t \n\tuint64_t offset, length;\n\tztest_block_tag_t *bt = data;\n\tztest_block_tag_t *bbt;\n\tuint64_t gen, txg, lrtxg, crtxg;\n\tdmu_object_info_t doi;\n\tdmu_tx_t *tx;\n\tdmu_buf_t *db;\n\tarc_buf_t *abuf = NULL;\n\trl_t *rl;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\toffset = lr->lr_offset;\n\tlength = lr->lr_length;\n\n\t \n\tif (lr->lr_common.lrc_reclen == sizeof (lr_write_t)) {\n\t\tuint64_t blocksize = BP_GET_LSIZE(&lr->lr_blkptr);\n\t\tif (length < blocksize) {\n\t\t\toffset -= offset % blocksize;\n\t\t\tlength = blocksize;\n\t\t}\n\t}\n\n\tif (bt->bt_magic == BSWAP_64(BT_MAGIC))\n\t\tbyteswap_uint64_array(bt, sizeof (*bt));\n\n\tif (bt->bt_magic != BT_MAGIC)\n\t\tbt = NULL;\n\n\tztest_object_lock(zd, lr->lr_foid, RL_READER);\n\trl = ztest_range_lock(zd, lr->lr_foid, offset, length, RL_WRITER);\n\n\tVERIFY0(dmu_bonus_hold(os, lr->lr_foid, FTAG, &db));\n\n\tdmu_object_info_from_db(db, &doi);\n\n\tbbt = ztest_bt_bonus(db);\n\tASSERT3U(bbt->bt_magic, ==, BT_MAGIC);\n\tgen = bbt->bt_gen;\n\tcrtxg = bbt->bt_crtxg;\n\tlrtxg = lr->lr_common.lrc_txg;\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_write(tx, lr->lr_foid, offset, length);\n\n\tif (ztest_random(8) == 0 && length == doi.doi_data_block_size &&\n\t    P2PHASE(offset, length) == 0)\n\t\tabuf = dmu_request_arcbuf(db, length);\n\n\ttxg = ztest_tx_assign(tx, TXG_WAIT, FTAG);\n\tif (txg == 0) {\n\t\tif (abuf != NULL)\n\t\t\tdmu_return_arcbuf(abuf);\n\t\tdmu_buf_rele(db, FTAG);\n\t\tztest_range_unlock(rl);\n\t\tztest_object_unlock(zd, lr->lr_foid);\n\t\treturn (ENOSPC);\n\t}\n\n\tif (bt != NULL) {\n\t\t \n\t\tASSERT(doi.doi_data_block_size);\n\t\tASSERT0(offset % doi.doi_data_block_size);\n\t\tif (ztest_random(4) != 0) {\n\t\t\tint prefetch = ztest_random(2) ?\n\t\t\t    DMU_READ_PREFETCH : DMU_READ_NO_PREFETCH;\n\t\t\tztest_block_tag_t rbt;\n\n\t\t\tVERIFY(dmu_read(os, lr->lr_foid, offset,\n\t\t\t    sizeof (rbt), &rbt, prefetch) == 0);\n\t\t\tif (rbt.bt_magic == BT_MAGIC) {\n\t\t\t\tztest_bt_verify(&rbt, os, lr->lr_foid, 0,\n\t\t\t\t    offset, gen, txg, crtxg);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (zd->zd_zilog->zl_replay) {\n\t\t\tztest_bt_verify(bt, os, lr->lr_foid, 0, offset,\n\t\t\t    MAX(gen, bt->bt_gen), MAX(txg, lrtxg),\n\t\t\t    bt->bt_crtxg);\n\t\t}\n\n\t\t \n\t\tztest_bt_generate(bt, os, lr->lr_foid, 0, offset, gen, txg,\n\t\t    crtxg);\n\t}\n\n\tif (abuf == NULL) {\n\t\tdmu_write(os, lr->lr_foid, offset, length, data, tx);\n\t} else {\n\t\tmemcpy(abuf->b_data, data, length);\n\t\tVERIFY0(dmu_assign_arcbuf_by_dbuf(db, offset, abuf, tx));\n\t}\n\n\t(void) ztest_log_write(zd, tx, lr);\n\n\tdmu_buf_rele(db, FTAG);\n\n\tdmu_tx_commit(tx);\n\n\tztest_range_unlock(rl);\n\tztest_object_unlock(zd, lr->lr_foid);\n\n\treturn (0);\n}\n\nstatic int\nztest_replay_truncate(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tztest_ds_t *zd = arg1;\n\tlr_truncate_t *lr = arg2;\n\tobjset_t *os = zd->zd_os;\n\tdmu_tx_t *tx;\n\tuint64_t txg;\n\trl_t *rl;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tztest_object_lock(zd, lr->lr_foid, RL_READER);\n\trl = ztest_range_lock(zd, lr->lr_foid, lr->lr_offset, lr->lr_length,\n\t    RL_WRITER);\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_free(tx, lr->lr_foid, lr->lr_offset, lr->lr_length);\n\n\ttxg = ztest_tx_assign(tx, TXG_WAIT, FTAG);\n\tif (txg == 0) {\n\t\tztest_range_unlock(rl);\n\t\tztest_object_unlock(zd, lr->lr_foid);\n\t\treturn (ENOSPC);\n\t}\n\n\tVERIFY0(dmu_free_range(os, lr->lr_foid, lr->lr_offset,\n\t    lr->lr_length, tx));\n\n\t(void) ztest_log_truncate(zd, tx, lr);\n\n\tdmu_tx_commit(tx);\n\n\tztest_range_unlock(rl);\n\tztest_object_unlock(zd, lr->lr_foid);\n\n\treturn (0);\n}\n\nstatic int\nztest_replay_setattr(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tztest_ds_t *zd = arg1;\n\tlr_setattr_t *lr = arg2;\n\tobjset_t *os = zd->zd_os;\n\tdmu_tx_t *tx;\n\tdmu_buf_t *db;\n\tztest_block_tag_t *bbt;\n\tuint64_t txg, lrtxg, crtxg, dnodesize;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tztest_object_lock(zd, lr->lr_foid, RL_WRITER);\n\n\tVERIFY0(dmu_bonus_hold(os, lr->lr_foid, FTAG, &db));\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_bonus(tx, lr->lr_foid);\n\n\ttxg = ztest_tx_assign(tx, TXG_WAIT, FTAG);\n\tif (txg == 0) {\n\t\tdmu_buf_rele(db, FTAG);\n\t\tztest_object_unlock(zd, lr->lr_foid);\n\t\treturn (ENOSPC);\n\t}\n\n\tbbt = ztest_bt_bonus(db);\n\tASSERT3U(bbt->bt_magic, ==, BT_MAGIC);\n\tcrtxg = bbt->bt_crtxg;\n\tlrtxg = lr->lr_common.lrc_txg;\n\tdnodesize = bbt->bt_dnodesize;\n\n\tif (zd->zd_zilog->zl_replay) {\n\t\tASSERT3U(lr->lr_size, !=, 0);\n\t\tASSERT3U(lr->lr_mode, !=, 0);\n\t\tASSERT3U(lrtxg, !=, 0);\n\t} else {\n\t\t \n\t\tlr->lr_size = (ztest_random(db->db_size / sizeof (*bbt)) + 1) *\n\t\t    sizeof (*bbt);\n\t\tlr->lr_mode = bbt->bt_gen + 1;\n\t\tASSERT0(lrtxg);\n\t}\n\n\t \n\tztest_bt_verify(bbt, os, lr->lr_foid, dnodesize, -1ULL, lr->lr_mode,\n\t    MAX(txg, lrtxg), crtxg);\n\n\tdmu_buf_will_dirty(db, tx);\n\n\tASSERT3U(lr->lr_size, >=, sizeof (*bbt));\n\tASSERT3U(lr->lr_size, <=, db->db_size);\n\tVERIFY0(dmu_set_bonus(db, lr->lr_size, tx));\n\tbbt = ztest_bt_bonus(db);\n\n\tztest_bt_generate(bbt, os, lr->lr_foid, dnodesize, -1ULL, lr->lr_mode,\n\t    txg, crtxg);\n\tztest_fill_unused_bonus(db, bbt, lr->lr_foid, os, bbt->bt_gen);\n\tdmu_buf_rele(db, FTAG);\n\n\t(void) ztest_log_setattr(zd, tx, lr);\n\n\tdmu_tx_commit(tx);\n\n\tztest_object_unlock(zd, lr->lr_foid);\n\n\treturn (0);\n}\n\nstatic zil_replay_func_t *ztest_replay_vector[TX_MAX_TYPE] = {\n\tNULL,\t\t\t \n\tztest_replay_create,\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tztest_replay_remove,\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tztest_replay_write,\t \n\tztest_replay_truncate,\t \n\tztest_replay_setattr,\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n};\n\n \n\nstatic void\nztest_get_done(zgd_t *zgd, int error)\n{\n\t(void) error;\n\tztest_ds_t *zd = zgd->zgd_private;\n\tuint64_t object = ((rl_t *)zgd->zgd_lr)->rl_object;\n\n\tif (zgd->zgd_db)\n\t\tdmu_buf_rele(zgd->zgd_db, zgd);\n\n\tztest_range_unlock((rl_t *)zgd->zgd_lr);\n\tztest_object_unlock(zd, object);\n\n\tumem_free(zgd, sizeof (*zgd));\n}\n\nstatic int\nztest_get_data(void *arg, uint64_t arg2, lr_write_t *lr, char *buf,\n    struct lwb *lwb, zio_t *zio)\n{\n\t(void) arg2;\n\tztest_ds_t *zd = arg;\n\tobjset_t *os = zd->zd_os;\n\tuint64_t object = lr->lr_foid;\n\tuint64_t offset = lr->lr_offset;\n\tuint64_t size = lr->lr_length;\n\tuint64_t txg = lr->lr_common.lrc_txg;\n\tuint64_t crtxg;\n\tdmu_object_info_t doi;\n\tdmu_buf_t *db;\n\tzgd_t *zgd;\n\tint error;\n\n\tASSERT3P(lwb, !=, NULL);\n\tASSERT3U(size, !=, 0);\n\n\tztest_object_lock(zd, object, RL_READER);\n\terror = dmu_bonus_hold(os, object, FTAG, &db);\n\tif (error) {\n\t\tztest_object_unlock(zd, object);\n\t\treturn (error);\n\t}\n\n\tcrtxg = ztest_bt_bonus(db)->bt_crtxg;\n\n\tif (crtxg == 0 || crtxg > txg) {\n\t\tdmu_buf_rele(db, FTAG);\n\t\tztest_object_unlock(zd, object);\n\t\treturn (ENOENT);\n\t}\n\n\tdmu_object_info_from_db(db, &doi);\n\tdmu_buf_rele(db, FTAG);\n\tdb = NULL;\n\n\tzgd = umem_zalloc(sizeof (*zgd), UMEM_NOFAIL);\n\tzgd->zgd_lwb = lwb;\n\tzgd->zgd_private = zd;\n\n\tif (buf != NULL) {\t \n\t\tzgd->zgd_lr = (struct zfs_locked_range *)ztest_range_lock(zd,\n\t\t    object, offset, size, RL_READER);\n\n\t\terror = dmu_read(os, object, offset, size, buf,\n\t\t    DMU_READ_NO_PREFETCH);\n\t\tASSERT0(error);\n\t} else {\n\t\tASSERT3P(zio, !=, NULL);\n\t\tsize = doi.doi_data_block_size;\n\t\tif (ISP2(size)) {\n\t\t\toffset = P2ALIGN(offset, size);\n\t\t} else {\n\t\t\tASSERT3U(offset, <, size);\n\t\t\toffset = 0;\n\t\t}\n\n\t\tzgd->zgd_lr = (struct zfs_locked_range *)ztest_range_lock(zd,\n\t\t    object, offset, size, RL_READER);\n\n\t\terror = dmu_buf_hold_noread(os, object, offset, zgd, &db);\n\n\t\tif (error == 0) {\n\t\t\tblkptr_t *bp = &lr->lr_blkptr;\n\n\t\t\tzgd->zgd_db = db;\n\t\t\tzgd->zgd_bp = bp;\n\n\t\t\tASSERT3U(db->db_offset, ==, offset);\n\t\t\tASSERT3U(db->db_size, ==, size);\n\n\t\t\terror = dmu_sync(zio, lr->lr_common.lrc_txg,\n\t\t\t    ztest_get_done, zgd);\n\n\t\t\tif (error == 0)\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\tztest_get_done(zgd, error);\n\n\treturn (error);\n}\n\nstatic void *\nztest_lr_alloc(size_t lrsize, char *name)\n{\n\tchar *lr;\n\tsize_t namesize = name ? strlen(name) + 1 : 0;\n\n\tlr = umem_zalloc(lrsize + namesize, UMEM_NOFAIL);\n\n\tif (name)\n\t\tmemcpy(lr + lrsize, name, namesize);\n\n\treturn (lr);\n}\n\nstatic void\nztest_lr_free(void *lr, size_t lrsize, char *name)\n{\n\tsize_t namesize = name ? strlen(name) + 1 : 0;\n\n\tumem_free(lr, lrsize + namesize);\n}\n\n \nstatic int\nztest_lookup(ztest_ds_t *zd, ztest_od_t *od, int count)\n{\n\tint missing = 0;\n\tint error;\n\tint i;\n\n\tASSERT(MUTEX_HELD(&zd->zd_dirobj_lock));\n\n\tfor (i = 0; i < count; i++, od++) {\n\t\tod->od_object = 0;\n\t\terror = zap_lookup(zd->zd_os, od->od_dir, od->od_name,\n\t\t    sizeof (uint64_t), 1, &od->od_object);\n\t\tif (error) {\n\t\t\tASSERT3S(error, ==, ENOENT);\n\t\t\tASSERT0(od->od_object);\n\t\t\tmissing++;\n\t\t} else {\n\t\t\tdmu_buf_t *db;\n\t\t\tztest_block_tag_t *bbt;\n\t\t\tdmu_object_info_t doi;\n\n\t\t\tASSERT3U(od->od_object, !=, 0);\n\t\t\tASSERT0(missing);\t \n\n\t\t\tztest_object_lock(zd, od->od_object, RL_READER);\n\t\t\tVERIFY0(dmu_bonus_hold(zd->zd_os, od->od_object,\n\t\t\t    FTAG, &db));\n\t\t\tdmu_object_info_from_db(db, &doi);\n\t\t\tbbt = ztest_bt_bonus(db);\n\t\t\tASSERT3U(bbt->bt_magic, ==, BT_MAGIC);\n\t\t\tod->od_type = doi.doi_type;\n\t\t\tod->od_blocksize = doi.doi_data_block_size;\n\t\t\tod->od_gen = bbt->bt_gen;\n\t\t\tdmu_buf_rele(db, FTAG);\n\t\t\tztest_object_unlock(zd, od->od_object);\n\t\t}\n\t}\n\n\treturn (missing);\n}\n\nstatic int\nztest_create(ztest_ds_t *zd, ztest_od_t *od, int count)\n{\n\tint missing = 0;\n\tint i;\n\n\tASSERT(MUTEX_HELD(&zd->zd_dirobj_lock));\n\n\tfor (i = 0; i < count; i++, od++) {\n\t\tif (missing) {\n\t\t\tod->od_object = 0;\n\t\t\tmissing++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlr_create_t *lr = ztest_lr_alloc(sizeof (*lr), od->od_name);\n\n\t\tlr->lr_doid = od->od_dir;\n\t\tlr->lr_foid = 0;\t \n\t\tlr->lrz_type = od->od_crtype;\n\t\tlr->lrz_blocksize = od->od_crblocksize;\n\t\tlr->lrz_ibshift = ztest_random_ibshift();\n\t\tlr->lrz_bonustype = DMU_OT_UINT64_OTHER;\n\t\tlr->lrz_dnodesize = od->od_crdnodesize;\n\t\tlr->lr_gen = od->od_crgen;\n\t\tlr->lr_crtime[0] = time(NULL);\n\n\t\tif (ztest_replay_create(zd, lr, B_FALSE) != 0) {\n\t\t\tASSERT0(missing);\n\t\t\tod->od_object = 0;\n\t\t\tmissing++;\n\t\t} else {\n\t\t\tod->od_object = lr->lr_foid;\n\t\t\tod->od_type = od->od_crtype;\n\t\t\tod->od_blocksize = od->od_crblocksize;\n\t\t\tod->od_gen = od->od_crgen;\n\t\t\tASSERT3U(od->od_object, !=, 0);\n\t\t}\n\n\t\tztest_lr_free(lr, sizeof (*lr), od->od_name);\n\t}\n\n\treturn (missing);\n}\n\nstatic int\nztest_remove(ztest_ds_t *zd, ztest_od_t *od, int count)\n{\n\tint missing = 0;\n\tint error;\n\tint i;\n\n\tASSERT(MUTEX_HELD(&zd->zd_dirobj_lock));\n\n\tod += count - 1;\n\n\tfor (i = count - 1; i >= 0; i--, od--) {\n\t\tif (missing) {\n\t\t\tmissing++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (od->od_object == 0)\n\t\t\tcontinue;\n\n\t\tlr_remove_t *lr = ztest_lr_alloc(sizeof (*lr), od->od_name);\n\n\t\tlr->lr_doid = od->od_dir;\n\n\t\tif ((error = ztest_replay_remove(zd, lr, B_FALSE)) != 0) {\n\t\t\tASSERT3U(error, ==, ENOSPC);\n\t\t\tmissing++;\n\t\t} else {\n\t\t\tod->od_object = 0;\n\t\t}\n\t\tztest_lr_free(lr, sizeof (*lr), od->od_name);\n\t}\n\n\treturn (missing);\n}\n\nstatic int\nztest_write(ztest_ds_t *zd, uint64_t object, uint64_t offset, uint64_t size,\n    void *data)\n{\n\tlr_write_t *lr;\n\tint error;\n\n\tlr = ztest_lr_alloc(sizeof (*lr) + size, NULL);\n\n\tlr->lr_foid = object;\n\tlr->lr_offset = offset;\n\tlr->lr_length = size;\n\tlr->lr_blkoff = 0;\n\tBP_ZERO(&lr->lr_blkptr);\n\n\tmemcpy(lr + 1, data, size);\n\n\terror = ztest_replay_write(zd, lr, B_FALSE);\n\n\tztest_lr_free(lr, sizeof (*lr) + size, NULL);\n\n\treturn (error);\n}\n\nstatic int\nztest_truncate(ztest_ds_t *zd, uint64_t object, uint64_t offset, uint64_t size)\n{\n\tlr_truncate_t *lr;\n\tint error;\n\n\tlr = ztest_lr_alloc(sizeof (*lr), NULL);\n\n\tlr->lr_foid = object;\n\tlr->lr_offset = offset;\n\tlr->lr_length = size;\n\n\terror = ztest_replay_truncate(zd, lr, B_FALSE);\n\n\tztest_lr_free(lr, sizeof (*lr), NULL);\n\n\treturn (error);\n}\n\nstatic int\nztest_setattr(ztest_ds_t *zd, uint64_t object)\n{\n\tlr_setattr_t *lr;\n\tint error;\n\n\tlr = ztest_lr_alloc(sizeof (*lr), NULL);\n\n\tlr->lr_foid = object;\n\tlr->lr_size = 0;\n\tlr->lr_mode = 0;\n\n\terror = ztest_replay_setattr(zd, lr, B_FALSE);\n\n\tztest_lr_free(lr, sizeof (*lr), NULL);\n\n\treturn (error);\n}\n\nstatic void\nztest_prealloc(ztest_ds_t *zd, uint64_t object, uint64_t offset, uint64_t size)\n{\n\tobjset_t *os = zd->zd_os;\n\tdmu_tx_t *tx;\n\tuint64_t txg;\n\trl_t *rl;\n\n\ttxg_wait_synced(dmu_objset_pool(os), 0);\n\n\tztest_object_lock(zd, object, RL_READER);\n\trl = ztest_range_lock(zd, object, offset, size, RL_WRITER);\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_write(tx, object, offset, size);\n\n\ttxg = ztest_tx_assign(tx, TXG_WAIT, FTAG);\n\n\tif (txg != 0) {\n\t\tdmu_prealloc(os, object, offset, size, tx);\n\t\tdmu_tx_commit(tx);\n\t\ttxg_wait_synced(dmu_objset_pool(os), txg);\n\t} else {\n\t\t(void) dmu_free_long_range(os, object, offset, size);\n\t}\n\n\tztest_range_unlock(rl);\n\tztest_object_unlock(zd, object);\n}\n\nstatic void\nztest_io(ztest_ds_t *zd, uint64_t object, uint64_t offset)\n{\n\tint err;\n\tztest_block_tag_t wbt;\n\tdmu_object_info_t doi;\n\tenum ztest_io_type io_type;\n\tuint64_t blocksize;\n\tvoid *data;\n\n\tVERIFY0(dmu_object_info(zd->zd_os, object, &doi));\n\tblocksize = doi.doi_data_block_size;\n\tdata = umem_alloc(blocksize, UMEM_NOFAIL);\n\n\t \n\tio_type = ztest_random(ZTEST_IO_TYPES);\n\tif (ztest_random(2) == 0)\n\t\tio_type = ZTEST_IO_WRITE_TAG;\n\n\t(void) pthread_rwlock_rdlock(&zd->zd_zilog_lock);\n\n\tswitch (io_type) {\n\n\tcase ZTEST_IO_WRITE_TAG:\n\t\tztest_bt_generate(&wbt, zd->zd_os, object, doi.doi_dnodesize,\n\t\t    offset, 0, 0, 0);\n\t\t(void) ztest_write(zd, object, offset, sizeof (wbt), &wbt);\n\t\tbreak;\n\n\tcase ZTEST_IO_WRITE_PATTERN:\n\t\t(void) memset(data, 'a' + (object + offset) % 5, blocksize);\n\t\tif (ztest_random(2) == 0) {\n\t\t\t \n\t\t\t((uint64_t *)data)[0] ^= 1ULL << 63;\n\t\t\t((uint64_t *)data)[4] ^= 1ULL << 63;\n\t\t}\n\t\t(void) ztest_write(zd, object, offset, blocksize, data);\n\t\tbreak;\n\n\tcase ZTEST_IO_WRITE_ZEROES:\n\t\tmemset(data, 0, blocksize);\n\t\t(void) ztest_write(zd, object, offset, blocksize, data);\n\t\tbreak;\n\n\tcase ZTEST_IO_TRUNCATE:\n\t\t(void) ztest_truncate(zd, object, offset, blocksize);\n\t\tbreak;\n\n\tcase ZTEST_IO_SETATTR:\n\t\t(void) ztest_setattr(zd, object);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\tcase ZTEST_IO_REWRITE:\n\t\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\t\terr = ztest_dsl_prop_set_uint64(zd->zd_name,\n\t\t    ZFS_PROP_CHECKSUM, spa_dedup_checksum(ztest_spa),\n\t\t    B_FALSE);\n\t\tASSERT(err == 0 || err == ENOSPC);\n\t\terr = ztest_dsl_prop_set_uint64(zd->zd_name,\n\t\t    ZFS_PROP_COMPRESSION,\n\t\t    ztest_random_dsl_prop(ZFS_PROP_COMPRESSION),\n\t\t    B_FALSE);\n\t\tASSERT(err == 0 || err == ENOSPC);\n\t\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\t\tVERIFY0(dmu_read(zd->zd_os, object, offset, blocksize, data,\n\t\t    DMU_READ_NO_PREFETCH));\n\n\t\t(void) ztest_write(zd, object, offset, blocksize, data);\n\t\tbreak;\n\t}\n\n\t(void) pthread_rwlock_unlock(&zd->zd_zilog_lock);\n\n\tumem_free(data, blocksize);\n}\n\n \nstatic void\nztest_od_init(ztest_od_t *od, uint64_t id, const char *tag, uint64_t index,\n    dmu_object_type_t type, uint64_t blocksize, uint64_t dnodesize,\n    uint64_t gen)\n{\n\tod->od_dir = ZTEST_DIROBJ;\n\tod->od_object = 0;\n\n\tod->od_crtype = type;\n\tod->od_crblocksize = blocksize ? blocksize : ztest_random_blocksize();\n\tod->od_crdnodesize = dnodesize ? dnodesize : ztest_random_dnodesize();\n\tod->od_crgen = gen;\n\n\tod->od_type = DMU_OT_NONE;\n\tod->od_blocksize = 0;\n\tod->od_gen = 0;\n\n\t(void) snprintf(od->od_name, sizeof (od->od_name),\n\t    \"%s(%\"PRId64\")[%\"PRIu64\"]\",\n\t    tag, id, index);\n}\n\n \nstatic int\nztest_object_init(ztest_ds_t *zd, ztest_od_t *od, size_t size, boolean_t remove)\n{\n\tint count = size / sizeof (*od);\n\tint rv = 0;\n\n\tmutex_enter(&zd->zd_dirobj_lock);\n\tif ((ztest_lookup(zd, od, count) != 0 || remove) &&\n\t    (ztest_remove(zd, od, count) != 0 ||\n\t    ztest_create(zd, od, count) != 0))\n\t\trv = -1;\n\tzd->zd_od = od;\n\tmutex_exit(&zd->zd_dirobj_lock);\n\n\treturn (rv);\n}\n\nvoid\nztest_zil_commit(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tzilog_t *zilog = zd->zd_zilog;\n\n\t(void) pthread_rwlock_rdlock(&zd->zd_zilog_lock);\n\n\tzil_commit(zilog, ztest_random(ZTEST_OBJECTS));\n\n\t \n\tmutex_enter(&zilog->zl_lock);\n\tASSERT3P(zd->zd_shared, !=, NULL);\n\tASSERT3U(zd->zd_shared->zd_seq, <=, zilog->zl_commit_lr_seq);\n\tzd->zd_shared->zd_seq = zilog->zl_commit_lr_seq;\n\tmutex_exit(&zilog->zl_lock);\n\n\t(void) pthread_rwlock_unlock(&zd->zd_zilog_lock);\n}\n\n \nvoid\nztest_zil_remount(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tobjset_t *os = zd->zd_os;\n\n\t \n\tmutex_enter(&ztest_vdev_lock);\n\n\t \n\tmutex_enter(&zd->zd_dirobj_lock);\n\t(void) pthread_rwlock_wrlock(&zd->zd_zilog_lock);\n\n\t \n\tzil_close(zd->zd_zilog);\n\n\t \n\tVERIFY3P(zil_open(os, ztest_get_data, NULL), ==, zd->zd_zilog);\n\tzil_replay(os, zd, ztest_replay_vector);\n\n\t(void) pthread_rwlock_unlock(&zd->zd_zilog_lock);\n\tmutex_exit(&zd->zd_dirobj_lock);\n\tmutex_exit(&ztest_vdev_lock);\n}\n\n \nvoid\nztest_spa_create_destroy(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_opts_t *zo = &ztest_opts;\n\tspa_t *spa;\n\tnvlist_t *nvroot;\n\n\tif (zo->zo_mmp_test)\n\t\treturn;\n\n\t \n\tnvroot = make_vdev_root(\"/dev/bogus\", NULL, NULL, 0, 0, NULL, 0, 0, 1);\n\tVERIFY3U(ENOENT, ==,\n\t    spa_create(\"ztest_bad_file\", nvroot, NULL, NULL, NULL));\n\tfnvlist_free(nvroot);\n\n\t \n\tnvroot = make_vdev_root(\"/dev/bogus\", NULL, NULL, 0, 0, NULL, 0, 2, 1);\n\tVERIFY3U(ENOENT, ==,\n\t    spa_create(\"ztest_bad_mirror\", nvroot, NULL, NULL, NULL));\n\tfnvlist_free(nvroot);\n\n\t \n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\tnvroot = make_vdev_root(\"/dev/bogus\", NULL, NULL, 0, 0, NULL, 0, 0, 1);\n\tVERIFY3U(EEXIST, ==,\n\t    spa_create(zo->zo_pool, nvroot, NULL, NULL, NULL));\n\tfnvlist_free(nvroot);\n\n\t \n\tVERIFY0(spa_open(zo->zo_pool, &spa, FTAG));\n\tint error = spa_destroy(zo->zo_pool);\n\tif (error != EBUSY && error != ZFS_ERR_EXPORT_IN_PROGRESS) {\n\t\tfatal(B_FALSE, \"spa_destroy(%s) returned unexpected value %d\",\n\t\t    spa->spa_name, error);\n\t}\n\tspa_close(spa, FTAG);\n\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n}\n\n \nvoid\nztest_mmp_enable_disable(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_opts_t *zo = &ztest_opts;\n\tspa_t *spa = ztest_spa;\n\n\tif (zo->zo_mmp_test)\n\t\treturn;\n\n\t \n\tif (spa_suspended(spa))\n\t\treturn;\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tmutex_enter(&spa->spa_props_lock);\n\n\tzfs_multihost_fail_intervals = 0;\n\n\tif (!spa_multihost(spa)) {\n\t\tspa->spa_multihost = B_TRUE;\n\t\tmmp_thread_start(spa);\n\t}\n\n\tmutex_exit(&spa->spa_props_lock);\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\tmmp_signal_all_threads();\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tmutex_enter(&spa->spa_props_lock);\n\n\tif (spa_multihost(spa)) {\n\t\tmmp_thread_stop(spa);\n\t\tspa->spa_multihost = B_FALSE;\n\t}\n\n\tmutex_exit(&spa->spa_props_lock);\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n}\n\nvoid\nztest_spa_upgrade(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa;\n\tuint64_t initial_version = SPA_VERSION_INITIAL;\n\tuint64_t version, newversion;\n\tnvlist_t *nvroot, *props;\n\tchar *name;\n\n\tif (ztest_opts.zo_mmp_test)\n\t\treturn;\n\n\t \n\tif (strcmp(ztest_opts.zo_raid_type, VDEV_TYPE_DRAID) == 0)\n\t\treturn;\n\n\tmutex_enter(&ztest_vdev_lock);\n\tname = kmem_asprintf(\"%s_upgrade\", ztest_opts.zo_pool);\n\n\t \n\t(void) spa_destroy(name);\n\n\tnvroot = make_vdev_root(NULL, NULL, name, ztest_opts.zo_vdev_size, 0,\n\t    NULL, ztest_opts.zo_raid_children, ztest_opts.zo_mirrors, 1);\n\n\t \n\tswitch (ztest_opts.zo_raid_parity) {\n\tcase 0:\n\tcase 1:\n\t\tinitial_version = SPA_VERSION_INITIAL;\n\t\tbreak;\n\tcase 2:\n\t\tinitial_version = SPA_VERSION_RAIDZ2;\n\t\tbreak;\n\tcase 3:\n\t\tinitial_version = SPA_VERSION_RAIDZ3;\n\t\tbreak;\n\t}\n\n\t \n\tdo {\n\t\tversion = ztest_random_spa_version(initial_version);\n\t} while (version > SPA_VERSION_BEFORE_FEATURES);\n\n\tprops = fnvlist_alloc();\n\tfnvlist_add_uint64(props,\n\t    zpool_prop_to_name(ZPOOL_PROP_VERSION), version);\n\tVERIFY0(spa_create(name, nvroot, props, NULL, NULL));\n\tfnvlist_free(nvroot);\n\tfnvlist_free(props);\n\n\tVERIFY0(spa_open(name, &spa, FTAG));\n\tVERIFY3U(spa_version(spa), ==, version);\n\tnewversion = ztest_random_spa_version(version + 1);\n\n\tif (ztest_opts.zo_verbose >= 4) {\n\t\t(void) printf(\"upgrading spa version from \"\n\t\t    \"%\"PRIu64\" to %\"PRIu64\"\\n\",\n\t\t    version, newversion);\n\t}\n\n\tspa_upgrade(spa, newversion);\n\tVERIFY3U(spa_version(spa), >, version);\n\tVERIFY3U(spa_version(spa), ==, fnvlist_lookup_uint64(spa->spa_config,\n\t    zpool_prop_to_name(ZPOOL_PROP_VERSION)));\n\tspa_close(spa, FTAG);\n\n\tkmem_strfree(name);\n\tmutex_exit(&ztest_vdev_lock);\n}\n\nstatic void\nztest_spa_checkpoint(spa_t *spa)\n{\n\tASSERT(MUTEX_HELD(&ztest_checkpoint_lock));\n\n\tint error = spa_checkpoint(spa->spa_name);\n\n\tswitch (error) {\n\tcase 0:\n\tcase ZFS_ERR_DEVRM_IN_PROGRESS:\n\tcase ZFS_ERR_DISCARDING_CHECKPOINT:\n\tcase ZFS_ERR_CHECKPOINT_EXISTS:\n\t\tbreak;\n\tcase ENOSPC:\n\t\tztest_record_enospc(FTAG);\n\t\tbreak;\n\tdefault:\n\t\tfatal(B_FALSE, \"spa_checkpoint(%s) = %d\", spa->spa_name, error);\n\t}\n}\n\nstatic void\nztest_spa_discard_checkpoint(spa_t *spa)\n{\n\tASSERT(MUTEX_HELD(&ztest_checkpoint_lock));\n\n\tint error = spa_checkpoint_discard(spa->spa_name);\n\n\tswitch (error) {\n\tcase 0:\n\tcase ZFS_ERR_DISCARDING_CHECKPOINT:\n\tcase ZFS_ERR_NO_CHECKPOINT:\n\t\tbreak;\n\tdefault:\n\t\tfatal(B_FALSE, \"spa_discard_checkpoint(%s) = %d\",\n\t\t    spa->spa_name, error);\n\t}\n\n}\n\nvoid\nztest_spa_checkpoint_create_discard(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\n\tmutex_enter(&ztest_checkpoint_lock);\n\tif (ztest_random(2) == 0) {\n\t\tztest_spa_checkpoint(spa);\n\t} else {\n\t\tztest_spa_discard_checkpoint(spa);\n\t}\n\tmutex_exit(&ztest_checkpoint_lock);\n}\n\n\nstatic vdev_t *\nvdev_lookup_by_path(vdev_t *vd, const char *path)\n{\n\tvdev_t *mvd;\n\tint c;\n\n\tif (vd->vdev_path != NULL && strcmp(path, vd->vdev_path) == 0)\n\t\treturn (vd);\n\n\tfor (c = 0; c < vd->vdev_children; c++)\n\t\tif ((mvd = vdev_lookup_by_path(vd->vdev_child[c], path)) !=\n\t\t    NULL)\n\t\t\treturn (mvd);\n\n\treturn (NULL);\n}\n\nstatic int\nspa_num_top_vdevs(spa_t *spa)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tASSERT3U(spa_config_held(spa, SCL_VDEV, RW_READER), ==, SCL_VDEV);\n\treturn (rvd->vdev_children);\n}\n\n \nvoid\nztest_vdev_add_remove(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_t *zs = ztest_shared;\n\tspa_t *spa = ztest_spa;\n\tuint64_t leaves;\n\tuint64_t guid;\n\tnvlist_t *nvroot;\n\tint error;\n\n\tif (ztest_opts.zo_mmp_test)\n\t\treturn;\n\n\tmutex_enter(&ztest_vdev_lock);\n\tleaves = MAX(zs->zs_mirrors + zs->zs_splits, 1) *\n\t    ztest_opts.zo_raid_children;\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\n\tztest_shared->zs_vdev_next_leaf = spa_num_top_vdevs(spa) * leaves;\n\n\t \n\tif (spa_has_slogs(spa) && ztest_random(4) == 0) {\n\t\tmetaslab_group_t *mg;\n\n\t\t \n\t\tmg =  spa_log_class(spa)->mc_allocator[0].mca_rotor;\n\t\twhile (!mg->mg_vd->vdev_islog)\n\t\t\tmg = mg->mg_next;\n\n\t\tguid = mg->mg_vd->vdev_guid;\n\n\t\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\t\t \n\t\tpthread_rwlock_wrlock(&ztest_name_lock);\n\t\terror = spa_vdev_remove(spa, guid, B_FALSE);\n\t\tpthread_rwlock_unlock(&ztest_name_lock);\n\n\t\tswitch (error) {\n\t\tcase 0:\n\t\tcase EEXIST:\t \n\t\tcase EBUSY:\t \n\t\tcase EACCES:\t \n\t\tcase ZFS_ERR_CHECKPOINT_EXISTS:\n\t\tcase ZFS_ERR_DISCARDING_CHECKPOINT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(B_FALSE, \"spa_vdev_remove() = %d\", error);\n\t\t}\n\t} else {\n\t\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\t\t \n\t\tnvroot = make_vdev_root(NULL, NULL, NULL,\n\t\t    ztest_opts.zo_vdev_size, 0, (ztest_random(4) == 0) ?\n\t\t    \"log\" : NULL, ztest_opts.zo_raid_children, zs->zs_mirrors,\n\t\t    1);\n\n\t\terror = spa_vdev_add(spa, nvroot);\n\t\tfnvlist_free(nvroot);\n\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase ENOSPC:\n\t\t\tztest_record_enospc(\"spa_vdev_add\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(B_FALSE, \"spa_vdev_add() = %d\", error);\n\t\t}\n\t}\n\n\tmutex_exit(&ztest_vdev_lock);\n}\n\nvoid\nztest_vdev_class_add(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_t *zs = ztest_shared;\n\tspa_t *spa = ztest_spa;\n\tuint64_t leaves;\n\tnvlist_t *nvroot;\n\tconst char *class = (ztest_random(2) == 0) ?\n\t    VDEV_ALLOC_BIAS_SPECIAL : VDEV_ALLOC_BIAS_DEDUP;\n\tint error;\n\n\t \n\tif ((ztest_opts.zo_special_vdevs == ZTEST_VDEV_CLASS_OFF) ||\n\t    (ztest_opts.zo_special_vdevs == ZTEST_VDEV_CLASS_RND &&\n\t    ztest_random(2) == 0)) {\n\t\treturn;\n\t}\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\t \n\tif (zs->zs_mirrors < 2) {\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\t \n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_ALLOCATION_CLASSES)) {\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\tleaves = MAX(zs->zs_mirrors + zs->zs_splits, 1) *\n\t    ztest_opts.zo_raid_children;\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\tztest_shared->zs_vdev_next_leaf = spa_num_top_vdevs(spa) * leaves;\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\tnvroot = make_vdev_root(NULL, NULL, NULL, ztest_opts.zo_vdev_size, 0,\n\t    class, ztest_opts.zo_raid_children, zs->zs_mirrors, 1);\n\n\terror = spa_vdev_add(spa, nvroot);\n\tfnvlist_free(nvroot);\n\n\tif (error == ENOSPC)\n\t\tztest_record_enospc(\"spa_vdev_add\");\n\telse if (error != 0)\n\t\tfatal(B_FALSE, \"spa_vdev_add() = %d\", error);\n\n\t \n\tif (error == 0 &&\n\t    spa_special_class(spa)->mc_groups == 1 && ztest_random(2) == 0) {\n\t\tif (ztest_opts.zo_verbose >= 3)\n\t\t\t(void) printf(\"Enabling special VDEV small blocks\\n\");\n\t\terror = ztest_dsl_prop_set_uint64(zd->zd_name,\n\t\t    ZFS_PROP_SPECIAL_SMALL_BLOCKS, 32768, B_FALSE);\n\t\tASSERT(error == 0 || error == ENOSPC);\n\t}\n\n\tmutex_exit(&ztest_vdev_lock);\n\n\tif (ztest_opts.zo_verbose >= 3) {\n\t\tmetaslab_class_t *mc;\n\n\t\tif (strcmp(class, VDEV_ALLOC_BIAS_SPECIAL) == 0)\n\t\t\tmc = spa_special_class(spa);\n\t\telse\n\t\t\tmc = spa_dedup_class(spa);\n\t\t(void) printf(\"Added a %s mirrored vdev (of %d)\\n\",\n\t\t    class, (int)mc->mc_groups);\n\t}\n}\n\n \nvoid\nztest_vdev_aux_add_remove(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_t *zs = ztest_shared;\n\tspa_t *spa = ztest_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tspa_aux_vdev_t *sav;\n\tconst char *aux;\n\tchar *path;\n\tuint64_t guid = 0;\n\tint error, ignore_err = 0;\n\n\tif (ztest_opts.zo_mmp_test)\n\t\treturn;\n\n\tpath = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\n\tif (ztest_random(2) == 0) {\n\t\tsav = &spa->spa_spares;\n\t\taux = ZPOOL_CONFIG_SPARES;\n\t} else {\n\t\tsav = &spa->spa_l2cache;\n\t\taux = ZPOOL_CONFIG_L2CACHE;\n\t}\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\n\tif (sav->sav_count != 0 && ztest_random(4) == 0) {\n\t\t \n\t\tvdev_t *svd = sav->sav_vdevs[ztest_random(sav->sav_count)];\n\n\t\t \n\t\tif (strstr(svd->vdev_path, VDEV_TYPE_DRAID) != NULL)\n\t\t\tignore_err = ENOTSUP;\n\n\t\tguid = svd->vdev_guid;\n\t} else {\n\t\t \n\t\tzs->zs_vdev_aux = 0;\n\t\tfor (;;) {\n\t\t\tint c;\n\t\t\t(void) snprintf(path, MAXPATHLEN, ztest_aux_template,\n\t\t\t    ztest_opts.zo_dir, ztest_opts.zo_pool, aux,\n\t\t\t    zs->zs_vdev_aux);\n\t\t\tfor (c = 0; c < sav->sav_count; c++)\n\t\t\t\tif (strcmp(sav->sav_vdevs[c]->vdev_path,\n\t\t\t\t    path) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (c == sav->sav_count &&\n\t\t\t    vdev_lookup_by_path(rvd, path) == NULL)\n\t\t\t\tbreak;\n\t\t\tzs->zs_vdev_aux++;\n\t\t}\n\t}\n\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\tif (guid == 0) {\n\t\t \n\t\tnvlist_t *nvroot = make_vdev_root(NULL, aux, NULL,\n\t\t    (ztest_opts.zo_vdev_size * 5) / 4, 0, NULL, 0, 0, 1);\n\t\terror = spa_vdev_add(spa, nvroot);\n\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(B_FALSE, \"spa_vdev_add(%p) = %d\", nvroot, error);\n\t\t}\n\t\tfnvlist_free(nvroot);\n\t} else {\n\t\t \n\t\tif (ztest_random(2) == 0)\n\t\t\t(void) vdev_online(spa, guid, 0, NULL);\n\n\t\terror = spa_vdev_remove(spa, guid, B_FALSE);\n\n\t\tswitch (error) {\n\t\tcase 0:\n\t\tcase EBUSY:\n\t\tcase ZFS_ERR_CHECKPOINT_EXISTS:\n\t\tcase ZFS_ERR_DISCARDING_CHECKPOINT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (error != ignore_err)\n\t\t\t\tfatal(B_FALSE,\n\t\t\t\t    \"spa_vdev_remove(%\"PRIu64\") = %d\",\n\t\t\t\t    guid, error);\n\t\t}\n\t}\n\n\tmutex_exit(&ztest_vdev_lock);\n\n\tumem_free(path, MAXPATHLEN);\n}\n\n \nvoid\nztest_split_pool(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_t *zs = ztest_shared;\n\tspa_t *spa = ztest_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tnvlist_t *tree, **child, *config, *split, **schild;\n\tuint_t c, children, schildren = 0, lastlogid = 0;\n\tint error = 0;\n\n\tif (ztest_opts.zo_mmp_test)\n\t\treturn;\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\t \n\tif (zs->zs_mirrors < 3 || ztest_opts.zo_raid_children > 1) {\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\t \n\t(void) spa_destroy(\"splitp\");\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\n\t \n\tmutex_enter(&spa->spa_props_lock);\n\ttree = fnvlist_lookup_nvlist(spa->spa_config, ZPOOL_CONFIG_VDEV_TREE);\n\tmutex_exit(&spa->spa_props_lock);\n\n\tVERIFY0(nvlist_lookup_nvlist_array(tree, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children));\n\n\tschild = umem_alloc(rvd->vdev_children * sizeof (nvlist_t *),\n\t    UMEM_NOFAIL);\n\tfor (c = 0; c < children; c++) {\n\t\tvdev_t *tvd = rvd->vdev_child[c];\n\t\tnvlist_t **mchild;\n\t\tuint_t mchildren;\n\n\t\tif (tvd->vdev_islog || tvd->vdev_ops == &vdev_hole_ops) {\n\t\t\tschild[schildren] = fnvlist_alloc();\n\t\t\tfnvlist_add_string(schild[schildren],\n\t\t\t    ZPOOL_CONFIG_TYPE, VDEV_TYPE_HOLE);\n\t\t\tfnvlist_add_uint64(schild[schildren],\n\t\t\t    ZPOOL_CONFIG_IS_HOLE, 1);\n\t\t\tif (lastlogid == 0)\n\t\t\t\tlastlogid = schildren;\n\t\t\t++schildren;\n\t\t\tcontinue;\n\t\t}\n\t\tlastlogid = 0;\n\t\tVERIFY0(nvlist_lookup_nvlist_array(child[c],\n\t\t    ZPOOL_CONFIG_CHILDREN, &mchild, &mchildren));\n\t\tschild[schildren++] = fnvlist_dup(mchild[0]);\n\t}\n\n\t \n\tsplit = fnvlist_alloc();\n\tfnvlist_add_string(split, ZPOOL_CONFIG_TYPE, VDEV_TYPE_ROOT);\n\tfnvlist_add_nvlist_array(split, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t **)schild, lastlogid != 0 ? lastlogid : schildren);\n\n\tconfig = fnvlist_alloc();\n\tfnvlist_add_nvlist(config, ZPOOL_CONFIG_VDEV_TREE, split);\n\n\tfor (c = 0; c < schildren; c++)\n\t\tfnvlist_free(schild[c]);\n\tumem_free(schild, rvd->vdev_children * sizeof (nvlist_t *));\n\tfnvlist_free(split);\n\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\t(void) pthread_rwlock_wrlock(&ztest_name_lock);\n\terror = spa_vdev_split_mirror(spa, \"splitp\", config, NULL, B_FALSE);\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\tfnvlist_free(config);\n\n\tif (error == 0) {\n\t\t(void) printf(\"successful split - results:\\n\");\n\t\tmutex_enter(&spa_namespace_lock);\n\t\tshow_pool_stats(spa);\n\t\tshow_pool_stats(spa_lookup(\"splitp\"));\n\t\tmutex_exit(&spa_namespace_lock);\n\t\t++zs->zs_splits;\n\t\t--zs->zs_mirrors;\n\t}\n\tmutex_exit(&ztest_vdev_lock);\n}\n\n \nvoid\nztest_vdev_attach_detach(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_t *zs = ztest_shared;\n\tspa_t *spa = ztest_spa;\n\tspa_aux_vdev_t *sav = &spa->spa_spares;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tvdev_t *oldvd, *newvd, *pvd;\n\tnvlist_t *root;\n\tuint64_t leaves;\n\tuint64_t leaf, top;\n\tuint64_t ashift = ztest_get_ashift();\n\tuint64_t oldguid, pguid;\n\tuint64_t oldsize, newsize;\n\tchar *oldpath, *newpath;\n\tint replacing;\n\tint oldvd_has_siblings = B_FALSE;\n\tint newvd_is_spare = B_FALSE;\n\tint newvd_is_dspare = B_FALSE;\n\tint oldvd_is_log;\n\tint oldvd_is_special;\n\tint error, expected_error;\n\n\tif (ztest_opts.zo_mmp_test)\n\t\treturn;\n\n\toldpath = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\tnewpath = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\n\tmutex_enter(&ztest_vdev_lock);\n\tleaves = MAX(zs->zs_mirrors, 1) * ztest_opts.zo_raid_children;\n\n\tspa_config_enter(spa, SCL_ALL, FTAG, RW_WRITER);\n\n\t \n\tif (ztest_device_removal_active) {\n\t\tspa_config_exit(spa, SCL_ALL, FTAG);\n\t\tgoto out;\n\t}\n\n\t \n\treplacing = ztest_random(2);\n\n\t \n\ttop = ztest_random_vdev_top(spa, B_TRUE);\n\n\t \n\tleaf = ztest_random(leaves);\n\n\t \n\toldvd = rvd->vdev_child[top];\n\n\t \n\tif (zs->zs_mirrors >= 1) {\n\t\tASSERT3P(oldvd->vdev_ops, ==, &vdev_mirror_ops);\n\t\tASSERT3U(oldvd->vdev_children, >=, zs->zs_mirrors);\n\t\toldvd = oldvd->vdev_child[leaf / ztest_opts.zo_raid_children];\n\t}\n\n\t \n\tif (ztest_opts.zo_raid_children > 1) {\n\t\tif (strcmp(oldvd->vdev_ops->vdev_op_type, \"raidz\") == 0)\n\t\t\tASSERT3P(oldvd->vdev_ops, ==, &vdev_raidz_ops);\n\t\telse\n\t\t\tASSERT3P(oldvd->vdev_ops, ==, &vdev_draid_ops);\n\t\tASSERT3U(oldvd->vdev_children, ==, ztest_opts.zo_raid_children);\n\t\toldvd = oldvd->vdev_child[leaf % ztest_opts.zo_raid_children];\n\t}\n\n\t \n\twhile (oldvd->vdev_children != 0) {\n\t\toldvd_has_siblings = B_TRUE;\n\t\tASSERT3U(oldvd->vdev_children, >=, 2);\n\t\toldvd = oldvd->vdev_child[ztest_random(oldvd->vdev_children)];\n\t}\n\n\toldguid = oldvd->vdev_guid;\n\toldsize = vdev_get_min_asize(oldvd);\n\toldvd_is_log = oldvd->vdev_top->vdev_islog;\n\toldvd_is_special =\n\t    oldvd->vdev_top->vdev_alloc_bias == VDEV_BIAS_SPECIAL ||\n\t    oldvd->vdev_top->vdev_alloc_bias == VDEV_BIAS_DEDUP;\n\t(void) strlcpy(oldpath, oldvd->vdev_path, MAXPATHLEN);\n\tpvd = oldvd->vdev_parent;\n\tpguid = pvd->vdev_guid;\n\n\t \n\tif (oldvd_has_siblings && ztest_random(2) == 0) {\n\t\tspa_config_exit(spa, SCL_ALL, FTAG);\n\n\t\terror = ztest_scrub_impl(spa);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = spa_vdev_detach(spa, oldguid, pguid, B_FALSE);\n\t\tif (error != 0 && error != ENODEV && error != EBUSY &&\n\t\t    error != ENOTSUP && error != ZFS_ERR_CHECKPOINT_EXISTS &&\n\t\t    error != ZFS_ERR_DISCARDING_CHECKPOINT)\n\t\t\tfatal(B_FALSE, \"detach (%s) returned %d\",\n\t\t\t    oldpath, error);\n\t\tgoto out;\n\t}\n\n\t \n\tif (sav->sav_count != 0 && ztest_random(3) == 0) {\n\t\tnewvd = sav->sav_vdevs[ztest_random(sav->sav_count)];\n\t\tnewvd_is_spare = B_TRUE;\n\n\t\tif (newvd->vdev_ops == &vdev_draid_spare_ops)\n\t\t\tnewvd_is_dspare = B_TRUE;\n\n\t\t(void) strlcpy(newpath, newvd->vdev_path, MAXPATHLEN);\n\t} else {\n\t\t(void) snprintf(newpath, MAXPATHLEN, ztest_dev_template,\n\t\t    ztest_opts.zo_dir, ztest_opts.zo_pool,\n\t\t    top * leaves + leaf);\n\t\tif (ztest_random(2) == 0)\n\t\t\tnewpath[strlen(newpath) - 1] = 'b';\n\t\tnewvd = vdev_lookup_by_path(rvd, newpath);\n\t}\n\n\tif (newvd) {\n\t\t \n\t\tvdev_reopen(newvd);\n\t\tnewsize = vdev_get_min_asize(newvd);\n\t} else {\n\t\t \n\t\tnewsize = 10 * oldsize / (9 + ztest_random(3));\n\t}\n\n\t \n\tif (pvd->vdev_ops != &vdev_mirror_ops &&\n\t    pvd->vdev_ops != &vdev_root_ops && (!replacing ||\n\t    pvd->vdev_ops == &vdev_replacing_ops ||\n\t    pvd->vdev_ops == &vdev_spare_ops))\n\t\texpected_error = ENOTSUP;\n\telse if (newvd_is_spare &&\n\t    (!replacing || oldvd_is_log || oldvd_is_special))\n\t\texpected_error = ENOTSUP;\n\telse if (newvd == oldvd)\n\t\texpected_error = replacing ? 0 : EBUSY;\n\telse if (vdev_lookup_by_path(rvd, newpath) != NULL)\n\t\texpected_error = EBUSY;\n\telse if (!newvd_is_dspare && newsize < oldsize)\n\t\texpected_error = EOVERFLOW;\n\telse if (ashift > oldvd->vdev_top->vdev_ashift)\n\t\texpected_error = EDOM;\n\telse if (newvd_is_dspare && pvd != vdev_draid_spare_get_parent(newvd))\n\t\texpected_error = EINVAL;\n\telse\n\t\texpected_error = 0;\n\n\tspa_config_exit(spa, SCL_ALL, FTAG);\n\n\t \n\troot = make_vdev_root(newpath, NULL, NULL, newvd == NULL ? newsize : 0,\n\t    ashift, NULL, 0, 0, 1);\n\n\t \n\tboolean_t rebuilding = B_FALSE;\n\tif (pvd->vdev_ops == &vdev_mirror_ops ||\n\t    pvd->vdev_ops ==  &vdev_root_ops) {\n\t\trebuilding = !!ztest_random(2);\n\t}\n\n\terror = spa_vdev_attach(spa, oldguid, root, replacing, rebuilding);\n\n\tfnvlist_free(root);\n\n\t \n\tif (expected_error == ENOTSUP &&\n\t    (error == 0 || error == ENODEV || error == EOVERFLOW))\n\t\texpected_error = error;\n\n\t \n\tif (error == EOVERFLOW || error == EBUSY)\n\t\texpected_error = error;\n\n\tif (error == ZFS_ERR_CHECKPOINT_EXISTS ||\n\t    error == ZFS_ERR_DISCARDING_CHECKPOINT ||\n\t    error == ZFS_ERR_RESILVER_IN_PROGRESS ||\n\t    error == ZFS_ERR_REBUILD_IN_PROGRESS)\n\t\texpected_error = error;\n\n\tif (error != expected_error && expected_error != EBUSY) {\n\t\tfatal(B_FALSE, \"attach (%s %\"PRIu64\", %s %\"PRIu64\", %d) \"\n\t\t    \"returned %d, expected %d\",\n\t\t    oldpath, oldsize, newpath,\n\t\t    newsize, replacing, error, expected_error);\n\t}\nout:\n\tmutex_exit(&ztest_vdev_lock);\n\n\tumem_free(oldpath, MAXPATHLEN);\n\tumem_free(newpath, MAXPATHLEN);\n}\n\nvoid\nztest_device_removal(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\tvdev_t *vd;\n\tuint64_t guid;\n\tint error;\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\tif (ztest_device_removal_active) {\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\t \n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\tvd = vdev_lookup_top(spa, ztest_random_vdev_top(spa, B_FALSE));\n\tguid = vd->vdev_guid;\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\terror = spa_vdev_remove(spa, guid, B_FALSE);\n\tif (error == 0) {\n\t\tztest_device_removal_active = B_TRUE;\n\t\tmutex_exit(&ztest_vdev_lock);\n\n\t\t \n\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\t\twhile (spa->spa_removing_phys.sr_state == DSS_SCANNING)\n\t\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\t} else {\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\t \n\terror = spa_scan(spa, POOL_SCAN_SCRUB);\n\tif (error == 0) {\n\t\twhile (dsl_scan_scrubbing(spa_get_dsl(spa)))\n\t\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\t}\n\n\tmutex_enter(&ztest_vdev_lock);\n\tztest_device_removal_active = B_FALSE;\n\tmutex_exit(&ztest_vdev_lock);\n}\n\n \nstatic vdev_t *\ngrow_vdev(vdev_t *vd, void *arg)\n{\n\tspa_t *spa __maybe_unused = vd->vdev_spa;\n\tsize_t *newsize = arg;\n\tsize_t fsize;\n\tint fd;\n\n\tASSERT3S(spa_config_held(spa, SCL_STATE, RW_READER), ==, SCL_STATE);\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\tif ((fd = open(vd->vdev_path, O_RDWR)) == -1)\n\t\treturn (vd);\n\n\tfsize = lseek(fd, 0, SEEK_END);\n\tVERIFY0(ftruncate(fd, *newsize));\n\n\tif (ztest_opts.zo_verbose >= 6) {\n\t\t(void) printf(\"%s grew from %lu to %lu bytes\\n\",\n\t\t    vd->vdev_path, (ulong_t)fsize, (ulong_t)*newsize);\n\t}\n\t(void) close(fd);\n\treturn (NULL);\n}\n\n \nstatic vdev_t *\nonline_vdev(vdev_t *vd, void *arg)\n{\n\t(void) arg;\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *tvd = vd->vdev_top;\n\tuint64_t guid = vd->vdev_guid;\n\tuint64_t generation = spa->spa_config_generation + 1;\n\tvdev_state_t newstate = VDEV_STATE_UNKNOWN;\n\tint error;\n\n\tASSERT3S(spa_config_held(spa, SCL_STATE, RW_READER), ==, SCL_STATE);\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\t \n\tspa_config_exit(spa, SCL_STATE, spa);\n\terror = vdev_online(spa, guid, ZFS_ONLINE_EXPAND, &newstate);\n\tspa_config_enter(spa, SCL_STATE, spa, RW_READER);\n\n\t \n\tif (error || newstate != VDEV_STATE_HEALTHY) {\n\t\tif (ztest_opts.zo_verbose >= 5) {\n\t\t\t(void) printf(\"Unable to expand vdev, state %u, \"\n\t\t\t    \"error %d\\n\", newstate, error);\n\t\t}\n\t\treturn (vd);\n\t}\n\tASSERT3U(newstate, ==, VDEV_STATE_HEALTHY);\n\n\t \n\tif (generation != spa->spa_config_generation) {\n\t\tif (ztest_opts.zo_verbose >= 5) {\n\t\t\t(void) printf(\"vdev configuration has changed, \"\n\t\t\t    \"guid %\"PRIu64\", state %\"PRIu64\", \"\n\t\t\t    \"expected gen %\"PRIu64\", got gen %\"PRIu64\"\\n\",\n\t\t\t    guid,\n\t\t\t    tvd->vdev_state,\n\t\t\t    generation,\n\t\t\t    spa->spa_config_generation);\n\t\t}\n\t\treturn (vd);\n\t}\n\treturn (NULL);\n}\n\n \nstatic vdev_t *\nvdev_walk_tree(vdev_t *vd, vdev_t *(*func)(vdev_t *, void *), void *arg)\n{\n\tuint_t c;\n\n\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\tif (func == NULL)\n\t\t\treturn (vd);\n\t\telse\n\t\t\treturn (func(vd, arg));\n\t}\n\n\tfor (c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\t\tif ((cvd = vdev_walk_tree(cvd, func, arg)) != NULL)\n\t\t\treturn (cvd);\n\t}\n\treturn (NULL);\n}\n\n \nvoid\nztest_vdev_LUN_growth(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\tvdev_t *vd, *tvd;\n\tmetaslab_class_t *mc;\n\tmetaslab_group_t *mg;\n\tsize_t psize, newsize;\n\tuint64_t top;\n\tuint64_t old_class_space, new_class_space, old_ms_count, new_ms_count;\n\n\tmutex_enter(&ztest_checkpoint_lock);\n\tmutex_enter(&ztest_vdev_lock);\n\tspa_config_enter(spa, SCL_STATE, spa, RW_READER);\n\n\t \n\tif (ztest_device_removal_active) {\n\t\tspa_config_exit(spa, SCL_STATE, spa);\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\tmutex_exit(&ztest_checkpoint_lock);\n\t\treturn;\n\t}\n\n\ttop = ztest_random_vdev_top(spa, B_TRUE);\n\n\ttvd = spa->spa_root_vdev->vdev_child[top];\n\tmg = tvd->vdev_mg;\n\tmc = mg->mg_class;\n\told_ms_count = tvd->vdev_ms_count;\n\told_class_space = metaslab_class_get_space(mc);\n\n\t \n\tvd = vdev_walk_tree(tvd, NULL, NULL);\n\tASSERT3P(vd, !=, NULL);\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\tpsize = vd->vdev_psize;\n\n\t \n\tif (tvd->vdev_state != VDEV_STATE_HEALTHY ||\n\t    psize == 0 || psize >= 4 * ztest_opts.zo_vdev_size) {\n\t\tspa_config_exit(spa, SCL_STATE, spa);\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\tmutex_exit(&ztest_checkpoint_lock);\n\t\treturn;\n\t}\n\tASSERT3U(psize, >, 0);\n\tnewsize = psize + MAX(psize / 8, SPA_MAXBLOCKSIZE);\n\tASSERT3U(newsize, >, psize);\n\n\tif (ztest_opts.zo_verbose >= 6) {\n\t\t(void) printf(\"Expanding LUN %s from %lu to %lu\\n\",\n\t\t    vd->vdev_path, (ulong_t)psize, (ulong_t)newsize);\n\t}\n\n\t \n\tif (vdev_walk_tree(tvd, grow_vdev, &newsize) != NULL ||\n\t    vdev_walk_tree(tvd, online_vdev, NULL) != NULL ||\n\t    tvd->vdev_state != VDEV_STATE_HEALTHY) {\n\t\tif (ztest_opts.zo_verbose >= 5) {\n\t\t\t(void) printf(\"Could not expand LUN because \"\n\t\t\t    \"the vdev configuration changed.\\n\");\n\t\t}\n\t\tspa_config_exit(spa, SCL_STATE, spa);\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\tmutex_exit(&ztest_checkpoint_lock);\n\t\treturn;\n\t}\n\n\tspa_config_exit(spa, SCL_STATE, spa);\n\n\t \n\tfor (;;) {\n\t\tboolean_t done;\n\t\tmutex_enter(&spa->spa_async_lock);\n\t\tdone = (spa->spa_async_thread == NULL && !spa->spa_async_tasks);\n\t\tmutex_exit(&spa->spa_async_lock);\n\t\tif (done)\n\t\t\tbreak;\n\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\t\t(void) poll(NULL, 0, 100);\n\t}\n\n\tspa_config_enter(spa, SCL_STATE, spa, RW_READER);\n\n\ttvd = spa->spa_root_vdev->vdev_child[top];\n\tnew_ms_count = tvd->vdev_ms_count;\n\tnew_class_space = metaslab_class_get_space(mc);\n\n\tif (tvd->vdev_mg != mg || mg->mg_class != mc) {\n\t\tif (ztest_opts.zo_verbose >= 5) {\n\t\t\t(void) printf(\"Could not verify LUN expansion due to \"\n\t\t\t    \"intervening vdev offline or remove.\\n\");\n\t\t}\n\t\tspa_config_exit(spa, SCL_STATE, spa);\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\tmutex_exit(&ztest_checkpoint_lock);\n\t\treturn;\n\t}\n\n\t \n\tif (new_ms_count <= old_ms_count) {\n\t\tfatal(B_FALSE,\n\t\t    \"LUN expansion failed: ms_count %\"PRIu64\" < %\"PRIu64\"\\n\",\n\t\t    old_ms_count, new_ms_count);\n\t}\n\n\t \n\tif (new_class_space <= old_class_space) {\n\t\tfatal(B_FALSE,\n\t\t    \"LUN expansion failed: class_space %\"PRIu64\" < %\"PRIu64\"\\n\",\n\t\t    old_class_space, new_class_space);\n\t}\n\n\tif (ztest_opts.zo_verbose >= 5) {\n\t\tchar oldnumbuf[NN_NUMBUF_SZ], newnumbuf[NN_NUMBUF_SZ];\n\n\t\tnicenum(old_class_space, oldnumbuf, sizeof (oldnumbuf));\n\t\tnicenum(new_class_space, newnumbuf, sizeof (newnumbuf));\n\t\t(void) printf(\"%s grew from %s to %s\\n\",\n\t\t    spa->spa_name, oldnumbuf, newnumbuf);\n\t}\n\n\tspa_config_exit(spa, SCL_STATE, spa);\n\tmutex_exit(&ztest_vdev_lock);\n\tmutex_exit(&ztest_checkpoint_lock);\n}\n\n \nstatic void\nztest_objset_create_cb(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx)\n{\n\t(void) arg, (void) cr;\n\n\t \n\tVERIFY0(zap_create_claim(os, ZTEST_DIROBJ,\n\t    DMU_OT_ZAP_OTHER, DMU_OT_NONE, 0, tx));\n}\n\nstatic int\nztest_dataset_create(char *dsname)\n{\n\tint err;\n\tuint64_t rand;\n\tdsl_crypto_params_t *dcp = NULL;\n\n\t \n\trand = ztest_random(2);\n\tif (rand != 0) {\n\t\tnvlist_t *crypto_args = fnvlist_alloc();\n\t\tnvlist_t *props = fnvlist_alloc();\n\n\t\t \n\t\trand = ztest_random(ZIO_CRYPT_FUNCTIONS);\n\t\tif (rand < ZIO_CRYPT_AES_128_CCM)\n\t\t\trand = ZIO_CRYPT_ON;\n\n\t\tfnvlist_add_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_ENCRYPTION), rand);\n\t\tfnvlist_add_uint8_array(crypto_args, \"wkeydata\",\n\t\t    (uint8_t *)ztest_wkeydata, WRAPPING_KEY_LEN);\n\n\t\t \n\t\tfnvlist_add_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), ZFS_KEYFORMAT_RAW);\n\t\tfnvlist_add_string(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), \"prompt\");\n\t\tfnvlist_add_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), 0ULL);\n\t\tfnvlist_add_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), 0ULL);\n\n\t\tVERIFY0(dsl_crypto_params_create_nvlist(DCP_CMD_NONE, props,\n\t\t    crypto_args, &dcp));\n\n\t\t \n\t\tVERIFY0(gcm_impl_set(\"cycle\"));\n\t\tVERIFY0(aes_impl_set(\"cycle\"));\n\n\t\tfnvlist_free(crypto_args);\n\t\tfnvlist_free(props);\n\t}\n\n\terr = dmu_objset_create(dsname, DMU_OST_OTHER, 0, dcp,\n\t    ztest_objset_create_cb, NULL);\n\tdsl_crypto_params_free(dcp, !!err);\n\n\trand = ztest_random(100);\n\tif (err || rand < 80)\n\t\treturn (err);\n\n\tif (ztest_opts.zo_verbose >= 5)\n\t\t(void) printf(\"Setting dataset %s to sync always\\n\", dsname);\n\treturn (ztest_dsl_prop_set_uint64(dsname, ZFS_PROP_SYNC,\n\t    ZFS_SYNC_ALWAYS, B_FALSE));\n}\n\nstatic int\nztest_objset_destroy_cb(const char *name, void *arg)\n{\n\t(void) arg;\n\tobjset_t *os;\n\tdmu_object_info_t doi;\n\tint error;\n\n\t \n\tVERIFY0(ztest_dmu_objset_own(name, DMU_OST_OTHER, B_TRUE,\n\t    B_TRUE, FTAG, &os));\n\terror = dmu_object_info(os, ZTEST_DIROBJ, &doi);\n\tif (error != ENOENT) {\n\t\t \n\t\tASSERT0(error);\n\t\tASSERT3U(doi.doi_type, ==, DMU_OT_ZAP_OTHER);\n\t\tASSERT3S(doi.doi_physical_blocks_512, >=, 0);\n\t}\n\tdmu_objset_disown(os, B_TRUE, FTAG);\n\n\t \n\tif (strchr(name, '@') != NULL) {\n\t\terror = dsl_destroy_snapshot(name, B_TRUE);\n\t\tif (error != ECHRNG) {\n\t\t\t \n\t\t\tASSERT0(error);\n\t\t}\n\t} else {\n\t\terror = dsl_destroy_head(name);\n\t\tif (error == ENOSPC) {\n\t\t\t \n\t\t\tztest_record_enospc(FTAG);\n\t\t} else if (error != EBUSY) {\n\t\t\t \n\t\t\tASSERT0(error);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic boolean_t\nztest_snapshot_create(char *osname, uint64_t id)\n{\n\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\tint error;\n\n\t(void) snprintf(snapname, sizeof (snapname), \"%\"PRIu64\"\", id);\n\n\terror = dmu_objset_snapshot_one(osname, snapname);\n\tif (error == ENOSPC) {\n\t\tztest_record_enospc(FTAG);\n\t\treturn (B_FALSE);\n\t}\n\tif (error != 0 && error != EEXIST && error != ECHRNG) {\n\t\tfatal(B_FALSE, \"ztest_snapshot_create(%s@%s) = %d\", osname,\n\t\t    snapname, error);\n\t}\n\treturn (B_TRUE);\n}\n\nstatic boolean_t\nztest_snapshot_destroy(char *osname, uint64_t id)\n{\n\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\tint error;\n\n\t(void) snprintf(snapname, sizeof (snapname), \"%s@%\"PRIu64\"\",\n\t    osname, id);\n\n\terror = dsl_destroy_snapshot(snapname, B_FALSE);\n\tif (error != 0 && error != ENOENT && error != ECHRNG)\n\t\tfatal(B_FALSE, \"ztest_snapshot_destroy(%s) = %d\",\n\t\t    snapname, error);\n\treturn (B_TRUE);\n}\n\nvoid\nztest_dmu_objset_create_destroy(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd;\n\tztest_ds_t *zdtmp;\n\tint iters;\n\tint error;\n\tobjset_t *os, *os2;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tzilog_t *zilog;\n\tint i;\n\n\tzdtmp = umem_alloc(sizeof (ztest_ds_t), UMEM_NOFAIL);\n\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\t(void) snprintf(name, sizeof (name), \"%s/temp_%\"PRIu64\"\",\n\t    ztest_opts.zo_pool, id);\n\n\t \n\tif (ztest_random(2) == 0 &&\n\t    ztest_dmu_objset_own(name, DMU_OST_OTHER, B_FALSE,\n\t    B_TRUE, FTAG, &os) == 0) {\n\t\tztest_zd_init(zdtmp, NULL, os);\n\t\tzil_replay(os, zdtmp, ztest_replay_vector);\n\t\tztest_zd_fini(zdtmp);\n\t\tdmu_objset_disown(os, B_TRUE, FTAG);\n\t}\n\n\t \n\t(void) dmu_objset_find(name, ztest_objset_destroy_cb, NULL,\n\t    DS_FIND_CHILDREN | DS_FIND_SNAPSHOTS);\n\n\t \n\terror = ztest_dmu_objset_own(name, DMU_OST_OTHER, B_TRUE, B_TRUE,\n\t    FTAG, &os);\n\tif (error == 0) {\n\t\tdmu_objset_disown(os, B_TRUE, FTAG);\n\t\tztest_record_enospc(FTAG);\n\t\tgoto out;\n\t}\n\tVERIFY3U(ENOENT, ==, error);\n\n\t \n\terror = ztest_dataset_create(name);\n\tif (error) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(FTAG);\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_objset_create(%s) = %d\", name, error);\n\t}\n\n\tVERIFY0(ztest_dmu_objset_own(name, DMU_OST_OTHER, B_FALSE, B_TRUE,\n\t    FTAG, &os));\n\n\tztest_zd_init(zdtmp, NULL, os);\n\n\t \n\tzilog = zil_open(os, ztest_get_data, NULL);\n\n\t \n\titers = ztest_random(5);\n\tfor (i = 0; i < iters; i++) {\n\t\tztest_dmu_object_alloc_free(zdtmp, id);\n\t\tif (ztest_random(iters) == 0)\n\t\t\t(void) ztest_snapshot_create(name, i);\n\t}\n\n\t \n\tVERIFY3U(EEXIST, ==,\n\t    dmu_objset_create(name, DMU_OST_OTHER, 0, NULL, NULL, NULL));\n\n\t \n\tVERIFY0(dmu_objset_hold(name, FTAG, &os2));\n\tdmu_objset_rele(os2, FTAG);\n\n\t \n\tVERIFY3U(EBUSY, ==, ztest_dmu_objset_own(name, DMU_OST_OTHER,\n\t    B_FALSE, B_TRUE, FTAG, &os2));\n\n\tzil_close(zilog);\n\tdmu_objset_disown(os, B_TRUE, FTAG);\n\tztest_zd_fini(zdtmp);\nout:\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\tumem_free(zdtmp, sizeof (ztest_ds_t));\n}\n\n \nvoid\nztest_dmu_snapshot_create_destroy(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\t(void) ztest_snapshot_destroy(zd->zd_name, id);\n\t(void) ztest_snapshot_create(zd->zd_name, id);\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n}\n\n \nstatic void\nztest_dsl_dataset_cleanup(char *osname, uint64_t id)\n{\n\tchar *snap1name;\n\tchar *clone1name;\n\tchar *snap2name;\n\tchar *clone2name;\n\tchar *snap3name;\n\tint error;\n\n\tsnap1name  = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tclone1name = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tsnap2name  = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tclone2name = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tsnap3name  = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\n\t(void) snprintf(snap1name, ZFS_MAX_DATASET_NAME_LEN, \"%s@s1_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(clone1name, ZFS_MAX_DATASET_NAME_LEN, \"%s/c1_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(snap2name, ZFS_MAX_DATASET_NAME_LEN, \"%s@s2_%\"PRIu64\"\",\n\t    clone1name, id);\n\t(void) snprintf(clone2name, ZFS_MAX_DATASET_NAME_LEN, \"%s/c2_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(snap3name, ZFS_MAX_DATASET_NAME_LEN, \"%s@s3_%\"PRIu64\"\",\n\t    clone1name, id);\n\n\terror = dsl_destroy_head(clone2name);\n\tif (error && error != ENOENT)\n\t\tfatal(B_FALSE, \"dsl_destroy_head(%s) = %d\", clone2name, error);\n\terror = dsl_destroy_snapshot(snap3name, B_FALSE);\n\tif (error && error != ENOENT)\n\t\tfatal(B_FALSE, \"dsl_destroy_snapshot(%s) = %d\",\n\t\t    snap3name, error);\n\terror = dsl_destroy_snapshot(snap2name, B_FALSE);\n\tif (error && error != ENOENT)\n\t\tfatal(B_FALSE, \"dsl_destroy_snapshot(%s) = %d\",\n\t\t    snap2name, error);\n\terror = dsl_destroy_head(clone1name);\n\tif (error && error != ENOENT)\n\t\tfatal(B_FALSE, \"dsl_destroy_head(%s) = %d\", clone1name, error);\n\terror = dsl_destroy_snapshot(snap1name, B_FALSE);\n\tif (error && error != ENOENT)\n\t\tfatal(B_FALSE, \"dsl_destroy_snapshot(%s) = %d\",\n\t\t    snap1name, error);\n\n\tumem_free(snap1name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(clone1name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(snap2name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(clone2name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(snap3name, ZFS_MAX_DATASET_NAME_LEN);\n}\n\n \nvoid\nztest_dsl_dataset_promote_busy(ztest_ds_t *zd, uint64_t id)\n{\n\tobjset_t *os;\n\tchar *snap1name;\n\tchar *clone1name;\n\tchar *snap2name;\n\tchar *clone2name;\n\tchar *snap3name;\n\tchar *osname = zd->zd_name;\n\tint error;\n\n\tsnap1name  = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tclone1name = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tsnap2name  = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tclone2name = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\tsnap3name  = umem_alloc(ZFS_MAX_DATASET_NAME_LEN, UMEM_NOFAIL);\n\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\tztest_dsl_dataset_cleanup(osname, id);\n\n\t(void) snprintf(snap1name, ZFS_MAX_DATASET_NAME_LEN, \"%s@s1_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(clone1name, ZFS_MAX_DATASET_NAME_LEN, \"%s/c1_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(snap2name, ZFS_MAX_DATASET_NAME_LEN, \"%s@s2_%\"PRIu64\"\",\n\t    clone1name, id);\n\t(void) snprintf(clone2name, ZFS_MAX_DATASET_NAME_LEN, \"%s/c2_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(snap3name, ZFS_MAX_DATASET_NAME_LEN, \"%s@s3_%\"PRIu64\"\",\n\t    clone1name, id);\n\n\terror = dmu_objset_snapshot_one(osname, strchr(snap1name, '@') + 1);\n\tif (error && error != EEXIST) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(FTAG);\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_take_snapshot(%s) = %d\", snap1name, error);\n\t}\n\n\terror = dmu_objset_clone(clone1name, snap1name);\n\tif (error) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(FTAG);\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_objset_create(%s) = %d\", clone1name, error);\n\t}\n\n\terror = dmu_objset_snapshot_one(clone1name, strchr(snap2name, '@') + 1);\n\tif (error && error != EEXIST) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(FTAG);\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_open_snapshot(%s) = %d\", snap2name, error);\n\t}\n\n\terror = dmu_objset_snapshot_one(clone1name, strchr(snap3name, '@') + 1);\n\tif (error && error != EEXIST) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(FTAG);\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_open_snapshot(%s) = %d\", snap3name, error);\n\t}\n\n\terror = dmu_objset_clone(clone2name, snap3name);\n\tif (error) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(FTAG);\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_objset_create(%s) = %d\", clone2name, error);\n\t}\n\n\terror = ztest_dmu_objset_own(snap2name, DMU_OST_ANY, B_TRUE, B_TRUE,\n\t    FTAG, &os);\n\tif (error)\n\t\tfatal(B_FALSE, \"dmu_objset_own(%s) = %d\", snap2name, error);\n\terror = dsl_dataset_promote(clone2name, NULL);\n\tif (error == ENOSPC) {\n\t\tdmu_objset_disown(os, B_TRUE, FTAG);\n\t\tztest_record_enospc(FTAG);\n\t\tgoto out;\n\t}\n\tif (error != EBUSY)\n\t\tfatal(B_FALSE, \"dsl_dataset_promote(%s), %d, not EBUSY\",\n\t\t    clone2name, error);\n\tdmu_objset_disown(os, B_TRUE, FTAG);\n\nout:\n\tztest_dsl_dataset_cleanup(osname, id);\n\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\tumem_free(snap1name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(clone1name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(snap2name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(clone2name, ZFS_MAX_DATASET_NAME_LEN);\n\tumem_free(snap3name, ZFS_MAX_DATASET_NAME_LEN);\n}\n\n#undef OD_ARRAY_SIZE\n#define\tOD_ARRAY_SIZE\t4\n\n \nvoid\nztest_dmu_object_alloc_free(ztest_ds_t *zd, uint64_t id)\n{\n\tztest_od_t *od;\n\tint batchsize;\n\tint size;\n\tint b;\n\n\tsize = sizeof (ztest_od_t) * OD_ARRAY_SIZE;\n\tod = umem_alloc(size, UMEM_NOFAIL);\n\tbatchsize = OD_ARRAY_SIZE;\n\n\tfor (b = 0; b < batchsize; b++)\n\t\tztest_od_init(od + b, id, FTAG, b, DMU_OT_UINT64_OTHER,\n\t\t    0, 0, 0);\n\n\t \n\tif (ztest_object_init(zd, od, size, B_TRUE) != 0) {\n\t\tzd->zd_od = NULL;\n\t\tumem_free(od, size);\n\t\treturn;\n\t}\n\n\twhile (ztest_random(4 * batchsize) != 0)\n\t\tztest_io(zd, od[ztest_random(batchsize)].od_object,\n\t\t    ztest_random(ZTEST_RANGE_LOCKS) << SPA_MAXBLOCKSHIFT);\n\n\tumem_free(od, size);\n}\n\n \nvoid\nztest_dmu_object_next_chunk(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tobjset_t *os = zd->zd_os;\n\tuint_t dnodes_per_chunk = 1 << dmu_object_alloc_chunk_shift;\n\tuint64_t object;\n\n\t \n\tmutex_enter(&os->os_obj_lock);\n\tobject = ztest_random(os->os_obj_next_chunk);\n\tos->os_obj_next_chunk = P2ALIGN(object, dnodes_per_chunk);\n\tmutex_exit(&os->os_obj_lock);\n}\n\n#undef OD_ARRAY_SIZE\n#define\tOD_ARRAY_SIZE\t2\n\n \nvoid\nztest_dmu_read_write(ztest_ds_t *zd, uint64_t id)\n{\n\tint size;\n\tztest_od_t *od;\n\n\tobjset_t *os = zd->zd_os;\n\tsize = sizeof (ztest_od_t) * OD_ARRAY_SIZE;\n\tod = umem_alloc(size, UMEM_NOFAIL);\n\tdmu_tx_t *tx;\n\tint freeit, error;\n\tuint64_t i, n, s, txg;\n\tbufwad_t *packbuf, *bigbuf, *pack, *bigH, *bigT;\n\tuint64_t packobj, packoff, packsize, bigobj, bigoff, bigsize;\n\tuint64_t chunksize = (1000 + ztest_random(1000)) * sizeof (uint64_t);\n\tuint64_t regions = 997;\n\tuint64_t stride = 123456789ULL;\n\tuint64_t width = 40;\n\tint free_percent = 5;\n\n\t \n\n\t \n\tztest_od_init(od, id, FTAG, 0, DMU_OT_UINT64_OTHER, 0, 0, chunksize);\n\tztest_od_init(od + 1, id, FTAG, 1, DMU_OT_UINT64_OTHER, 0, 0,\n\t    chunksize);\n\n\tif (ztest_object_init(zd, od, size, B_FALSE) != 0) {\n\t\tumem_free(od, size);\n\t\treturn;\n\t}\n\n\tbigobj = od[0].od_object;\n\tpackobj = od[1].od_object;\n\tchunksize = od[0].od_gen;\n\tASSERT3U(chunksize, ==, od[1].od_gen);\n\n\t \n\tn = ztest_random(regions) * stride + ztest_random(width);\n\ts = 1 + ztest_random(2 * width - 1);\n\tdmu_prefetch(os, bigobj, 0, n * chunksize, s * chunksize,\n\t    ZIO_PRIORITY_SYNC_READ);\n\n\t \n\tn = ztest_random(regions) * stride + ztest_random(width);\n\ts = 1 + ztest_random(width - 1);\n\n\tpackoff = n * sizeof (bufwad_t);\n\tpacksize = s * sizeof (bufwad_t);\n\n\tbigoff = n * chunksize;\n\tbigsize = s * chunksize;\n\n\tpackbuf = umem_alloc(packsize, UMEM_NOFAIL);\n\tbigbuf = umem_alloc(bigsize, UMEM_NOFAIL);\n\n\t \n\tfreeit = (ztest_random(100) < free_percent);\n\n\t \n\terror = dmu_read(os, packobj, packoff, packsize, packbuf,\n\t    DMU_READ_PREFETCH);\n\tASSERT0(error);\n\terror = dmu_read(os, bigobj, bigoff, bigsize, bigbuf,\n\t    DMU_READ_PREFETCH);\n\tASSERT0(error);\n\n\t \n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_write(tx, packobj, packoff, packsize);\n\n\tif (freeit)\n\t\tdmu_tx_hold_free(tx, bigobj, bigoff, bigsize);\n\telse\n\t\tdmu_tx_hold_write(tx, bigobj, bigoff, bigsize);\n\n\t \n\tdmu_tx_hold_bonus(tx, bigobj);\n\n\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\tif (txg == 0) {\n\t\tumem_free(packbuf, packsize);\n\t\tumem_free(bigbuf, bigsize);\n\t\tumem_free(od, size);\n\t\treturn;\n\t}\n\n\tenum zio_checksum cksum;\n\tdo {\n\t\tcksum = (enum zio_checksum)\n\t\t    ztest_random_dsl_prop(ZFS_PROP_CHECKSUM);\n\t} while (cksum >= ZIO_CHECKSUM_LEGACY_FUNCTIONS);\n\tdmu_object_set_checksum(os, bigobj, cksum, tx);\n\n\tenum zio_compress comp;\n\tdo {\n\t\tcomp = (enum zio_compress)\n\t\t    ztest_random_dsl_prop(ZFS_PROP_COMPRESSION);\n\t} while (comp >= ZIO_COMPRESS_LEGACY_FUNCTIONS);\n\tdmu_object_set_compress(os, bigobj, comp, tx);\n\n\t \n\tfor (i = 0; i < s; i++) {\n\t\t \n\t\tpack = (bufwad_t *)((char *)packbuf + i * sizeof (bufwad_t));\n\t\t \n\t\tbigH = (bufwad_t *)((char *)bigbuf + i * chunksize);\n\t\t \n\t\tbigT = (bufwad_t *)((char *)bigH + chunksize) - 1;\n\n\t\tASSERT3U((uintptr_t)bigH - (uintptr_t)bigbuf, <, bigsize);\n\t\tASSERT3U((uintptr_t)bigT - (uintptr_t)bigbuf, <, bigsize);\n\n\t\tif (pack->bw_txg > txg)\n\t\t\tfatal(B_FALSE,\n\t\t\t    \"future leak: got %\"PRIx64\", open txg is %\"PRIx64\"\",\n\t\t\t    pack->bw_txg, txg);\n\n\t\tif (pack->bw_data != 0 && pack->bw_index != n + i)\n\t\t\tfatal(B_FALSE, \"wrong index: \"\n\t\t\t    \"got %\"PRIx64\", wanted %\"PRIx64\"+%\"PRIx64\"\",\n\t\t\t    pack->bw_index, n, i);\n\n\t\tif (memcmp(pack, bigH, sizeof (bufwad_t)) != 0)\n\t\t\tfatal(B_FALSE, \"pack/bigH mismatch in %p/%p\",\n\t\t\t    pack, bigH);\n\n\t\tif (memcmp(pack, bigT, sizeof (bufwad_t)) != 0)\n\t\t\tfatal(B_FALSE, \"pack/bigT mismatch in %p/%p\",\n\t\t\t    pack, bigT);\n\n\t\tif (freeit) {\n\t\t\tmemset(pack, 0, sizeof (bufwad_t));\n\t\t} else {\n\t\t\tpack->bw_index = n + i;\n\t\t\tpack->bw_txg = txg;\n\t\t\tpack->bw_data = 1 + ztest_random(-2ULL);\n\t\t}\n\t\t*bigH = *pack;\n\t\t*bigT = *pack;\n\t}\n\n\t \n\tdmu_write(os, packobj, packoff, packsize, packbuf, tx);\n\n\tif (freeit) {\n\t\tif (ztest_opts.zo_verbose >= 7) {\n\t\t\t(void) printf(\"freeing offset %\"PRIx64\" size %\"PRIx64\"\"\n\t\t\t    \" txg %\"PRIx64\"\\n\",\n\t\t\t    bigoff, bigsize, txg);\n\t\t}\n\t\tVERIFY0(dmu_free_range(os, bigobj, bigoff, bigsize, tx));\n\t} else {\n\t\tif (ztest_opts.zo_verbose >= 7) {\n\t\t\t(void) printf(\"writing offset %\"PRIx64\" size %\"PRIx64\"\"\n\t\t\t    \" txg %\"PRIx64\"\\n\",\n\t\t\t    bigoff, bigsize, txg);\n\t\t}\n\t\tdmu_write(os, bigobj, bigoff, bigsize, bigbuf, tx);\n\t}\n\n\tdmu_tx_commit(tx);\n\n\t \n\t{\n\t\tvoid *packcheck = umem_alloc(packsize, UMEM_NOFAIL);\n\t\tvoid *bigcheck = umem_alloc(bigsize, UMEM_NOFAIL);\n\n\t\tVERIFY0(dmu_read(os, packobj, packoff,\n\t\t    packsize, packcheck, DMU_READ_PREFETCH));\n\t\tVERIFY0(dmu_read(os, bigobj, bigoff,\n\t\t    bigsize, bigcheck, DMU_READ_PREFETCH));\n\n\t\tASSERT0(memcmp(packbuf, packcheck, packsize));\n\t\tASSERT0(memcmp(bigbuf, bigcheck, bigsize));\n\n\t\tumem_free(packcheck, packsize);\n\t\tumem_free(bigcheck, bigsize);\n\t}\n\n\tumem_free(packbuf, packsize);\n\tumem_free(bigbuf, bigsize);\n\tumem_free(od, size);\n}\n\nstatic void\ncompare_and_update_pbbufs(uint64_t s, bufwad_t *packbuf, bufwad_t *bigbuf,\n    uint64_t bigsize, uint64_t n, uint64_t chunksize, uint64_t txg)\n{\n\tuint64_t i;\n\tbufwad_t *pack;\n\tbufwad_t *bigH;\n\tbufwad_t *bigT;\n\n\t \n\tfor (i = 0; i < s; i++) {\n\t\t \n\t\tpack = (bufwad_t *)((char *)packbuf + i * sizeof (bufwad_t));\n\t\t \n\t\tbigH = (bufwad_t *)((char *)bigbuf + i * chunksize);\n\t\t \n\t\tbigT = (bufwad_t *)((char *)bigH + chunksize) - 1;\n\n\t\tASSERT3U((uintptr_t)bigH - (uintptr_t)bigbuf, <, bigsize);\n\t\tASSERT3U((uintptr_t)bigT - (uintptr_t)bigbuf, <, bigsize);\n\n\t\tif (pack->bw_txg > txg)\n\t\t\tfatal(B_FALSE,\n\t\t\t    \"future leak: got %\"PRIx64\", open txg is %\"PRIx64\"\",\n\t\t\t    pack->bw_txg, txg);\n\n\t\tif (pack->bw_data != 0 && pack->bw_index != n + i)\n\t\t\tfatal(B_FALSE, \"wrong index: \"\n\t\t\t    \"got %\"PRIx64\", wanted %\"PRIx64\"+%\"PRIx64\"\",\n\t\t\t    pack->bw_index, n, i);\n\n\t\tif (memcmp(pack, bigH, sizeof (bufwad_t)) != 0)\n\t\t\tfatal(B_FALSE, \"pack/bigH mismatch in %p/%p\",\n\t\t\t    pack, bigH);\n\n\t\tif (memcmp(pack, bigT, sizeof (bufwad_t)) != 0)\n\t\t\tfatal(B_FALSE, \"pack/bigT mismatch in %p/%p\",\n\t\t\t    pack, bigT);\n\n\t\tpack->bw_index = n + i;\n\t\tpack->bw_txg = txg;\n\t\tpack->bw_data = 1 + ztest_random(-2ULL);\n\n\t\t*bigH = *pack;\n\t\t*bigT = *pack;\n\t}\n}\n\n#undef OD_ARRAY_SIZE\n#define\tOD_ARRAY_SIZE\t2\n\nvoid\nztest_dmu_read_write_zcopy(ztest_ds_t *zd, uint64_t id)\n{\n\tobjset_t *os = zd->zd_os;\n\tztest_od_t *od;\n\tdmu_tx_t *tx;\n\tuint64_t i;\n\tint error;\n\tint size;\n\tuint64_t n, s, txg;\n\tbufwad_t *packbuf, *bigbuf;\n\tuint64_t packobj, packoff, packsize, bigobj, bigoff, bigsize;\n\tuint64_t blocksize = ztest_random_blocksize();\n\tuint64_t chunksize = blocksize;\n\tuint64_t regions = 997;\n\tuint64_t stride = 123456789ULL;\n\tuint64_t width = 9;\n\tdmu_buf_t *bonus_db;\n\tarc_buf_t **bigbuf_arcbufs;\n\tdmu_object_info_t doi;\n\n\tsize = sizeof (ztest_od_t) * OD_ARRAY_SIZE;\n\tod = umem_alloc(size, UMEM_NOFAIL);\n\n\t \n\n\t \n\tztest_od_init(od, id, FTAG, 0, DMU_OT_UINT64_OTHER, blocksize, 0, 0);\n\tztest_od_init(od + 1, id, FTAG, 1, DMU_OT_UINT64_OTHER, 0, 0,\n\t    chunksize);\n\n\n\tif (ztest_object_init(zd, od, size, B_FALSE) != 0) {\n\t\tumem_free(od, size);\n\t\treturn;\n\t}\n\n\tbigobj = od[0].od_object;\n\tpackobj = od[1].od_object;\n\tblocksize = od[0].od_blocksize;\n\tchunksize = blocksize;\n\tASSERT3U(chunksize, ==, od[1].od_gen);\n\n\tVERIFY0(dmu_object_info(os, bigobj, &doi));\n\tVERIFY(ISP2(doi.doi_data_block_size));\n\tVERIFY3U(chunksize, ==, doi.doi_data_block_size);\n\tVERIFY3U(chunksize, >=, 2 * sizeof (bufwad_t));\n\n\t \n\tn = ztest_random(regions) * stride + ztest_random(width);\n\ts = 1 + ztest_random(width - 1);\n\n\tpackoff = n * sizeof (bufwad_t);\n\tpacksize = s * sizeof (bufwad_t);\n\n\tbigoff = n * chunksize;\n\tbigsize = s * chunksize;\n\n\tpackbuf = umem_zalloc(packsize, UMEM_NOFAIL);\n\tbigbuf = umem_zalloc(bigsize, UMEM_NOFAIL);\n\n\tVERIFY0(dmu_bonus_hold(os, bigobj, FTAG, &bonus_db));\n\n\tbigbuf_arcbufs = umem_zalloc(2 * s * sizeof (arc_buf_t *), UMEM_NOFAIL);\n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tuint64_t j;\n\t\tuint64_t off;\n\n\t\t \n\t\tfor (j = 0; j < s; j++) {\n\t\t\tif (i != 5 || chunksize < (SPA_MINBLOCKSIZE * 2)) {\n\t\t\t\tbigbuf_arcbufs[j] =\n\t\t\t\t    dmu_request_arcbuf(bonus_db, chunksize);\n\t\t\t} else {\n\t\t\t\tbigbuf_arcbufs[2 * j] =\n\t\t\t\t    dmu_request_arcbuf(bonus_db, chunksize / 2);\n\t\t\t\tbigbuf_arcbufs[2 * j + 1] =\n\t\t\t\t    dmu_request_arcbuf(bonus_db, chunksize / 2);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttx = dmu_tx_create(os);\n\n\t\tdmu_tx_hold_write(tx, packobj, packoff, packsize);\n\t\tdmu_tx_hold_write(tx, bigobj, bigoff, bigsize);\n\n\t\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\t\tif (txg == 0) {\n\t\t\tumem_free(packbuf, packsize);\n\t\t\tumem_free(bigbuf, bigsize);\n\t\t\tfor (j = 0; j < s; j++) {\n\t\t\t\tif (i != 5 ||\n\t\t\t\t    chunksize < (SPA_MINBLOCKSIZE * 2)) {\n\t\t\t\t\tdmu_return_arcbuf(bigbuf_arcbufs[j]);\n\t\t\t\t} else {\n\t\t\t\t\tdmu_return_arcbuf(\n\t\t\t\t\t    bigbuf_arcbufs[2 * j]);\n\t\t\t\t\tdmu_return_arcbuf(\n\t\t\t\t\t    bigbuf_arcbufs[2 * j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tumem_free(bigbuf_arcbufs, 2 * s * sizeof (arc_buf_t *));\n\t\t\tumem_free(od, size);\n\t\t\tdmu_buf_rele(bonus_db, FTAG);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (i != 0 || ztest_random(2) != 0) {\n\t\t\terror = dmu_read(os, packobj, packoff,\n\t\t\t    packsize, packbuf, DMU_READ_PREFETCH);\n\t\t\tASSERT0(error);\n\t\t\terror = dmu_read(os, bigobj, bigoff, bigsize,\n\t\t\t    bigbuf, DMU_READ_PREFETCH);\n\t\t\tASSERT0(error);\n\t\t}\n\t\tcompare_and_update_pbbufs(s, packbuf, bigbuf, bigsize,\n\t\t    n, chunksize, txg);\n\n\t\t \n\t\tdmu_write(os, packobj, packoff, packsize, packbuf, tx);\n\t\tif (ztest_opts.zo_verbose >= 7) {\n\t\t\t(void) printf(\"writing offset %\"PRIx64\" size %\"PRIx64\"\"\n\t\t\t    \" txg %\"PRIx64\"\\n\",\n\t\t\t    bigoff, bigsize, txg);\n\t\t}\n\t\tfor (off = bigoff, j = 0; j < s; j++, off += chunksize) {\n\t\t\tdmu_buf_t *dbt;\n\t\t\tif (i != 5 || chunksize < (SPA_MINBLOCKSIZE * 2)) {\n\t\t\t\tmemcpy(bigbuf_arcbufs[j]->b_data,\n\t\t\t\t    (caddr_t)bigbuf + (off - bigoff),\n\t\t\t\t    chunksize);\n\t\t\t} else {\n\t\t\t\tmemcpy(bigbuf_arcbufs[2 * j]->b_data,\n\t\t\t\t    (caddr_t)bigbuf + (off - bigoff),\n\t\t\t\t    chunksize / 2);\n\t\t\t\tmemcpy(bigbuf_arcbufs[2 * j + 1]->b_data,\n\t\t\t\t    (caddr_t)bigbuf + (off - bigoff) +\n\t\t\t\t    chunksize / 2,\n\t\t\t\t    chunksize / 2);\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tVERIFY(dmu_buf_hold(os, bigobj, off,\n\t\t\t\t    FTAG, &dbt, DMU_READ_NO_PREFETCH) == 0);\n\t\t\t}\n\t\t\tif (i != 5 || chunksize < (SPA_MINBLOCKSIZE * 2)) {\n\t\t\t\tVERIFY0(dmu_assign_arcbuf_by_dbuf(bonus_db,\n\t\t\t\t    off, bigbuf_arcbufs[j], tx));\n\t\t\t} else {\n\t\t\t\tVERIFY0(dmu_assign_arcbuf_by_dbuf(bonus_db,\n\t\t\t\t    off, bigbuf_arcbufs[2 * j], tx));\n\t\t\t\tVERIFY0(dmu_assign_arcbuf_by_dbuf(bonus_db,\n\t\t\t\t    off + chunksize / 2,\n\t\t\t\t    bigbuf_arcbufs[2 * j + 1], tx));\n\t\t\t}\n\t\t\tif (i == 1) {\n\t\t\t\tdmu_buf_rele(dbt, FTAG);\n\t\t\t}\n\t\t}\n\t\tdmu_tx_commit(tx);\n\n\t\t \n\t\t{\n\t\t\tvoid *packcheck = umem_alloc(packsize, UMEM_NOFAIL);\n\t\t\tvoid *bigcheck = umem_alloc(bigsize, UMEM_NOFAIL);\n\n\t\t\tVERIFY0(dmu_read(os, packobj, packoff,\n\t\t\t    packsize, packcheck, DMU_READ_PREFETCH));\n\t\t\tVERIFY0(dmu_read(os, bigobj, bigoff,\n\t\t\t    bigsize, bigcheck, DMU_READ_PREFETCH));\n\n\t\t\tASSERT0(memcmp(packbuf, packcheck, packsize));\n\t\t\tASSERT0(memcmp(bigbuf, bigcheck, bigsize));\n\n\t\t\tumem_free(packcheck, packsize);\n\t\t\tumem_free(bigcheck, bigsize);\n\t\t}\n\t\tif (i == 2) {\n\t\t\ttxg_wait_open(dmu_objset_pool(os), 0, B_TRUE);\n\t\t} else if (i == 3) {\n\t\t\ttxg_wait_synced(dmu_objset_pool(os), 0);\n\t\t}\n\t}\n\n\tdmu_buf_rele(bonus_db, FTAG);\n\tumem_free(packbuf, packsize);\n\tumem_free(bigbuf, bigsize);\n\tumem_free(bigbuf_arcbufs, 2 * s * sizeof (arc_buf_t *));\n\tumem_free(od, size);\n}\n\nvoid\nztest_dmu_write_parallel(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tztest_od_t *od;\n\n\tod = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);\n\tuint64_t offset = (1ULL << (ztest_random(20) + 43)) +\n\t    (ztest_random(ZTEST_RANGE_LOCKS) << SPA_MAXBLOCKSHIFT);\n\n\t \n\tztest_od_init(od, ID_PARALLEL, FTAG, 0, DMU_OT_UINT64_OTHER, 0, 0, 0);\n\n\tif (ztest_object_init(zd, od, sizeof (ztest_od_t), B_FALSE) != 0)\n\t\treturn;\n\n\twhile (ztest_random(10) != 0)\n\t\tztest_io(zd, od->od_object, offset);\n\n\tumem_free(od, sizeof (ztest_od_t));\n}\n\nvoid\nztest_dmu_prealloc(ztest_ds_t *zd, uint64_t id)\n{\n\tztest_od_t *od;\n\tuint64_t offset = (1ULL << (ztest_random(4) + SPA_MAXBLOCKSHIFT)) +\n\t    (ztest_random(ZTEST_RANGE_LOCKS) << SPA_MAXBLOCKSHIFT);\n\tuint64_t count = ztest_random(20) + 1;\n\tuint64_t blocksize = ztest_random_blocksize();\n\tvoid *data;\n\n\tod = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);\n\n\tztest_od_init(od, id, FTAG, 0, DMU_OT_UINT64_OTHER, blocksize, 0, 0);\n\n\tif (ztest_object_init(zd, od, sizeof (ztest_od_t),\n\t    !ztest_random(2)) != 0) {\n\t\tumem_free(od, sizeof (ztest_od_t));\n\t\treturn;\n\t}\n\n\tif (ztest_truncate(zd, od->od_object, offset, count * blocksize) != 0) {\n\t\tumem_free(od, sizeof (ztest_od_t));\n\t\treturn;\n\t}\n\n\tztest_prealloc(zd, od->od_object, offset, count * blocksize);\n\n\tdata = umem_zalloc(blocksize, UMEM_NOFAIL);\n\n\twhile (ztest_random(count) != 0) {\n\t\tuint64_t randoff = offset + (ztest_random(count) * blocksize);\n\t\tif (ztest_write(zd, od->od_object, randoff, blocksize,\n\t\t    data) != 0)\n\t\t\tbreak;\n\t\twhile (ztest_random(4) != 0)\n\t\t\tztest_io(zd, od->od_object, randoff);\n\t}\n\n\tumem_free(data, blocksize);\n\tumem_free(od, sizeof (ztest_od_t));\n}\n\n \n#define\tZTEST_ZAP_MIN_INTS\t1\n#define\tZTEST_ZAP_MAX_INTS\t4\n#define\tZTEST_ZAP_MAX_PROPS\t1000\n\nvoid\nztest_zap(ztest_ds_t *zd, uint64_t id)\n{\n\tobjset_t *os = zd->zd_os;\n\tztest_od_t *od;\n\tuint64_t object;\n\tuint64_t txg, last_txg;\n\tuint64_t value[ZTEST_ZAP_MAX_INTS];\n\tuint64_t zl_ints, zl_intsize, prop;\n\tint i, ints;\n\tdmu_tx_t *tx;\n\tchar propname[100], txgname[100];\n\tint error;\n\tconst char *const hc[2] = { \"s.acl.h\", \".s.open.h.hyLZlg\" };\n\n\tod = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);\n\tztest_od_init(od, id, FTAG, 0, DMU_OT_ZAP_OTHER, 0, 0, 0);\n\n\tif (ztest_object_init(zd, od, sizeof (ztest_od_t),\n\t    !ztest_random(2)) != 0)\n\t\tgoto out;\n\n\tobject = od->od_object;\n\n\t \n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_zap(tx, object, B_TRUE, NULL);\n\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\tif (txg == 0)\n\t\tgoto out;\n\tfor (i = 0; i < 2; i++) {\n\t\tvalue[i] = i;\n\t\tVERIFY0(zap_add(os, object, hc[i], sizeof (uint64_t),\n\t\t    1, &value[i], tx));\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tVERIFY3U(EEXIST, ==, zap_add(os, object, hc[i],\n\t\t    sizeof (uint64_t), 1, &value[i], tx));\n\t\tVERIFY0(\n\t\t    zap_length(os, object, hc[i], &zl_intsize, &zl_ints));\n\t\tASSERT3U(zl_intsize, ==, sizeof (uint64_t));\n\t\tASSERT3U(zl_ints, ==, 1);\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\tVERIFY0(zap_remove(os, object, hc[i], tx));\n\t}\n\tdmu_tx_commit(tx);\n\n\t \n\tints = MAX(ZTEST_ZAP_MIN_INTS, object % ZTEST_ZAP_MAX_INTS);\n\n\tprop = ztest_random(ZTEST_ZAP_MAX_PROPS);\n\t(void) sprintf(propname, \"prop_%\"PRIu64\"\", prop);\n\t(void) sprintf(txgname, \"txg_%\"PRIu64\"\", prop);\n\tmemset(value, 0, sizeof (value));\n\tlast_txg = 0;\n\n\t \n\terror = zap_length(os, object, txgname, &zl_intsize, &zl_ints);\n\tif (error == 0) {\n\t\tASSERT3U(zl_intsize, ==, sizeof (uint64_t));\n\t\tASSERT3U(zl_ints, ==, 1);\n\n\t\tVERIFY0(zap_lookup(os, object, txgname, zl_intsize,\n\t\t    zl_ints, &last_txg));\n\n\t\tVERIFY0(zap_length(os, object, propname, &zl_intsize,\n\t\t    &zl_ints));\n\n\t\tASSERT3U(zl_intsize, ==, sizeof (uint64_t));\n\t\tASSERT3U(zl_ints, ==, ints);\n\n\t\tVERIFY0(zap_lookup(os, object, propname, zl_intsize,\n\t\t    zl_ints, value));\n\n\t\tfor (i = 0; i < ints; i++) {\n\t\t\tASSERT3U(value[i], ==, last_txg + object + i);\n\t\t}\n\t} else {\n\t\tASSERT3U(error, ==, ENOENT);\n\t}\n\n\t \n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_zap(tx, object, B_TRUE, NULL);\n\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\tif (txg == 0)\n\t\tgoto out;\n\n\tif (last_txg > txg)\n\t\tfatal(B_FALSE, \"zap future leak: old %\"PRIu64\" new %\"PRIu64\"\",\n\t\t    last_txg, txg);\n\n\tfor (i = 0; i < ints; i++)\n\t\tvalue[i] = txg + object + i;\n\n\tVERIFY0(zap_update(os, object, txgname, sizeof (uint64_t),\n\t    1, &txg, tx));\n\tVERIFY0(zap_update(os, object, propname, sizeof (uint64_t),\n\t    ints, value, tx));\n\n\tdmu_tx_commit(tx);\n\n\t \n\tprop = ztest_random(ZTEST_ZAP_MAX_PROPS);\n\t(void) sprintf(propname, \"prop_%\"PRIu64\"\", prop);\n\t(void) sprintf(txgname, \"txg_%\"PRIu64\"\", prop);\n\n\terror = zap_length(os, object, txgname, &zl_intsize, &zl_ints);\n\n\tif (error == ENOENT)\n\t\tgoto out;\n\n\tASSERT0(error);\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_zap(tx, object, B_TRUE, NULL);\n\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\tif (txg == 0)\n\t\tgoto out;\n\tVERIFY0(zap_remove(os, object, txgname, tx));\n\tVERIFY0(zap_remove(os, object, propname, tx));\n\tdmu_tx_commit(tx);\nout:\n\tumem_free(od, sizeof (ztest_od_t));\n}\n\n \nvoid\nztest_fzap(ztest_ds_t *zd, uint64_t id)\n{\n\tobjset_t *os = zd->zd_os;\n\tztest_od_t *od;\n\tuint64_t object, txg, value;\n\n\tod = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);\n\tztest_od_init(od, id, FTAG, 0, DMU_OT_ZAP_OTHER, 0, 0, 0);\n\n\tif (ztest_object_init(zd, od, sizeof (ztest_od_t),\n\t    !ztest_random(2)) != 0)\n\t\tgoto out;\n\tobject = od->od_object;\n\n\t \n\tfor (value = 0; value < 2050; value++) {\n\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\tdmu_tx_t *tx;\n\t\tint error;\n\n\t\t(void) snprintf(name, sizeof (name), \"fzap-%\"PRIu64\"-%\"PRIu64\"\",\n\t\t    id, value);\n\n\t\ttx = dmu_tx_create(os);\n\t\tdmu_tx_hold_zap(tx, object, B_TRUE, name);\n\t\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\t\tif (txg == 0)\n\t\t\tgoto out;\n\t\terror = zap_add(os, object, name, sizeof (uint64_t), 1,\n\t\t    &value, tx);\n\t\tASSERT(error == 0 || error == EEXIST);\n\t\tdmu_tx_commit(tx);\n\t}\nout:\n\tumem_free(od, sizeof (ztest_od_t));\n}\n\nvoid\nztest_zap_parallel(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tobjset_t *os = zd->zd_os;\n\tztest_od_t *od;\n\tuint64_t txg, object, count, wsize, wc, zl_wsize, zl_wc;\n\tdmu_tx_t *tx;\n\tint i, namelen, error;\n\tint micro = ztest_random(2);\n\tchar name[20], string_value[20];\n\tvoid *data;\n\n\tod = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);\n\tztest_od_init(od, ID_PARALLEL, FTAG, micro, DMU_OT_ZAP_OTHER, 0, 0, 0);\n\n\tif (ztest_object_init(zd, od, sizeof (ztest_od_t), B_FALSE) != 0) {\n\t\tumem_free(od, sizeof (ztest_od_t));\n\t\treturn;\n\t}\n\n\tobject = od->od_object;\n\n\t \n\tnamelen = ztest_random(sizeof (name) - 5) + 5 + 1;\n\n\tfor (i = 0; i < 3; i++)\n\t\tname[i] = '!' + ztest_random('~' - '!' + 1);\n\tfor (; i < namelen - 1; i++)\n\t\tname[i] = '.';\n\tname[i] = '\\0';\n\n\tif ((namelen & 1) || micro) {\n\t\twsize = sizeof (txg);\n\t\twc = 1;\n\t\tdata = &txg;\n\t} else {\n\t\twsize = 1;\n\t\twc = namelen;\n\t\tdata = string_value;\n\t}\n\n\tcount = -1ULL;\n\tVERIFY0(zap_count(os, object, &count));\n\tASSERT3S(count, !=, -1ULL);\n\n\t \n\ti = ztest_random(5);\n\n\tif (i >= 2) {\n\t\ttx = dmu_tx_create(os);\n\t\tdmu_tx_hold_zap(tx, object, B_TRUE, NULL);\n\t\ttxg = ztest_tx_assign(tx, TXG_MIGHTWAIT, FTAG);\n\t\tif (txg == 0) {\n\t\t\tumem_free(od, sizeof (ztest_od_t));\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(string_value, name, namelen);\n\t} else {\n\t\ttx = NULL;\n\t\ttxg = 0;\n\t\tmemset(string_value, 0, namelen);\n\t}\n\n\tswitch (i) {\n\n\tcase 0:\n\t\terror = zap_length(os, object, name, &zl_wsize, &zl_wc);\n\t\tif (error == 0) {\n\t\t\tASSERT3U(wsize, ==, zl_wsize);\n\t\t\tASSERT3U(wc, ==, zl_wc);\n\t\t} else {\n\t\t\tASSERT3U(error, ==, ENOENT);\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\terror = zap_lookup(os, object, name, wsize, wc, data);\n\t\tif (error == 0) {\n\t\t\tif (data == string_value &&\n\t\t\t    memcmp(name, data, namelen) != 0)\n\t\t\t\tfatal(B_FALSE, \"name '%s' != val '%s' len %d\",\n\t\t\t\t    name, (char *)data, namelen);\n\t\t} else {\n\t\t\tASSERT3U(error, ==, ENOENT);\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\terror = zap_add(os, object, name, wsize, wc, data, tx);\n\t\tASSERT(error == 0 || error == EEXIST);\n\t\tbreak;\n\n\tcase 3:\n\t\tVERIFY0(zap_update(os, object, name, wsize, wc, data, tx));\n\t\tbreak;\n\n\tcase 4:\n\t\terror = zap_remove(os, object, name, tx);\n\t\tASSERT(error == 0 || error == ENOENT);\n\t\tbreak;\n\t}\n\n\tif (tx != NULL)\n\t\tdmu_tx_commit(tx);\n\n\tumem_free(od, sizeof (ztest_od_t));\n}\n\n \ntypedef struct ztest_cb_data {\n\tlist_node_t\t\tzcd_node;\n\tuint64_t\t\tzcd_txg;\n\tint\t\t\tzcd_expected_err;\n\tboolean_t\t\tzcd_added;\n\tboolean_t\t\tzcd_called;\n\tspa_t\t\t\t*zcd_spa;\n} ztest_cb_data_t;\n\n \nstatic void\nztest_commit_callback(void *arg, int error)\n{\n\tztest_cb_data_t *data = arg;\n\tuint64_t synced_txg;\n\n\tVERIFY3P(data, !=, NULL);\n\tVERIFY3S(data->zcd_expected_err, ==, error);\n\tVERIFY(!data->zcd_called);\n\n\tsynced_txg = spa_last_synced_txg(data->zcd_spa);\n\tif (data->zcd_txg > synced_txg)\n\t\tfatal(B_FALSE,\n\t\t    \"commit callback of txg %\"PRIu64\" called prematurely, \"\n\t\t    \"last synced txg = %\"PRIu64\"\\n\",\n\t\t    data->zcd_txg, synced_txg);\n\n\tdata->zcd_called = B_TRUE;\n\n\tif (error == ECANCELED) {\n\t\tASSERT0(data->zcd_txg);\n\t\tASSERT(!data->zcd_added);\n\n\t\t \n\t\treturn;\n\t}\n\n\tASSERT(data->zcd_added);\n\tASSERT3U(data->zcd_txg, !=, 0);\n\n\t(void) mutex_enter(&zcl.zcl_callbacks_lock);\n\n\t \n\tif ((synced_txg - data->zcd_txg) < zc_min_txg_delay)\n\t\tzc_min_txg_delay = synced_txg - data->zcd_txg;\n\n\t \n\tlist_remove(&zcl.zcl_callbacks, data);\n\n\t(void) mutex_exit(&zcl.zcl_callbacks_lock);\n\n\tumem_free(data, sizeof (ztest_cb_data_t));\n}\n\n \nstatic ztest_cb_data_t *\nztest_create_cb_data(objset_t *os, uint64_t txg)\n{\n\tztest_cb_data_t *cb_data;\n\n\tcb_data = umem_zalloc(sizeof (ztest_cb_data_t), UMEM_NOFAIL);\n\n\tcb_data->zcd_txg = txg;\n\tcb_data->zcd_spa = dmu_objset_spa(os);\n\tlist_link_init(&cb_data->zcd_node);\n\n\treturn (cb_data);\n}\n\n \nvoid\nztest_dmu_commit_callbacks(ztest_ds_t *zd, uint64_t id)\n{\n\tobjset_t *os = zd->zd_os;\n\tztest_od_t *od;\n\tdmu_tx_t *tx;\n\tztest_cb_data_t *cb_data[3], *tmp_cb;\n\tuint64_t old_txg, txg;\n\tint i, error = 0;\n\n\tod = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);\n\tztest_od_init(od, id, FTAG, 0, DMU_OT_UINT64_OTHER, 0, 0, 0);\n\n\tif (ztest_object_init(zd, od, sizeof (ztest_od_t), B_FALSE) != 0) {\n\t\tumem_free(od, sizeof (ztest_od_t));\n\t\treturn;\n\t}\n\n\ttx = dmu_tx_create(os);\n\n\tcb_data[0] = ztest_create_cb_data(os, 0);\n\tdmu_tx_callback_register(tx, ztest_commit_callback, cb_data[0]);\n\n\tdmu_tx_hold_write(tx, od->od_object, 0, sizeof (uint64_t));\n\n\t \n\tif (ztest_random(100) == 0)\n\t\terror = -1;\n\n\tif (!error)\n\t\terror = dmu_tx_assign(tx, TXG_NOWAIT);\n\n\ttxg = error ? 0 : dmu_tx_get_txg(tx);\n\n\tcb_data[0]->zcd_txg = txg;\n\tcb_data[1] = ztest_create_cb_data(os, txg);\n\tdmu_tx_callback_register(tx, ztest_commit_callback, cb_data[1]);\n\n\tif (error) {\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tcb_data[i]->zcd_expected_err = ECANCELED;\n\t\t\tVERIFY(!cb_data[i]->zcd_called);\n\t\t}\n\n\t\tdmu_tx_abort(tx);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tVERIFY(cb_data[i]->zcd_called);\n\t\t\tumem_free(cb_data[i], sizeof (ztest_cb_data_t));\n\t\t}\n\n\t\tumem_free(od, sizeof (ztest_od_t));\n\t\treturn;\n\t}\n\n\tcb_data[2] = ztest_create_cb_data(os, txg);\n\tdmu_tx_callback_register(tx, ztest_commit_callback, cb_data[2]);\n\n\t \n\tVERIFY0(dmu_read(os, od->od_object, 0, sizeof (uint64_t),\n\t    &old_txg, DMU_READ_PREFETCH));\n\n\tif (old_txg > txg)\n\t\tfatal(B_FALSE,\n\t\t    \"future leak: got %\"PRIu64\", open txg is %\"PRIu64\"\",\n\t\t    old_txg, txg);\n\n\tdmu_write(os, od->od_object, 0, sizeof (uint64_t), &txg, tx);\n\n\t(void) mutex_enter(&zcl.zcl_callbacks_lock);\n\n\t \n\ttmp_cb = list_head(&zcl.zcl_callbacks);\n\tif (tmp_cb != NULL &&\n\t    tmp_cb->zcd_txg + ZTEST_COMMIT_CB_THRESH < txg) {\n\t\tfatal(B_FALSE,\n\t\t    \"Commit callback threshold exceeded, \"\n\t\t    \"oldest txg: %\"PRIu64\", open txg: %\"PRIu64\"\\n\",\n\t\t    tmp_cb->zcd_txg, txg);\n\t}\n\n\t \n\ttmp_cb = list_tail(&zcl.zcl_callbacks);\n\twhile (tmp_cb != NULL && tmp_cb->zcd_txg > txg)\n\t\ttmp_cb = list_prev(&zcl.zcl_callbacks, tmp_cb);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tif (tmp_cb == NULL)\n\t\t\tlist_insert_head(&zcl.zcl_callbacks, cb_data[i]);\n\t\telse\n\t\t\tlist_insert_after(&zcl.zcl_callbacks, tmp_cb,\n\t\t\t    cb_data[i]);\n\n\t\tcb_data[i]->zcd_added = B_TRUE;\n\t\tVERIFY(!cb_data[i]->zcd_called);\n\n\t\ttmp_cb = cb_data[i];\n\t}\n\n\tzc_cb_counter += 3;\n\n\t(void) mutex_exit(&zcl.zcl_callbacks_lock);\n\n\tdmu_tx_commit(tx);\n\n\tumem_free(od, sizeof (ztest_od_t));\n}\n\n \nvoid\nztest_verify_dnode_bt(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tobjset_t *os = zd->zd_os;\n\tuint64_t obj;\n\tint err = 0;\n\n\tfor (obj = 0; err == 0; err = dmu_object_next(os, &obj, FALSE, 0)) {\n\t\tztest_block_tag_t *bt = NULL;\n\t\tdmu_object_info_t doi;\n\t\tdmu_buf_t *db;\n\n\t\tztest_object_lock(zd, obj, RL_READER);\n\t\tif (dmu_bonus_hold(os, obj, FTAG, &db) != 0) {\n\t\t\tztest_object_unlock(zd, obj);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdmu_object_info_from_db(db, &doi);\n\t\tif (doi.doi_bonus_size >= sizeof (*bt))\n\t\t\tbt = ztest_bt_bonus(db);\n\n\t\tif (bt && bt->bt_magic == BT_MAGIC) {\n\t\t\tztest_bt_verify(bt, os, obj, doi.doi_dnodesize,\n\t\t\t    bt->bt_offset, bt->bt_gen, bt->bt_txg,\n\t\t\t    bt->bt_crtxg);\n\t\t\tztest_verify_unused_bonus(db, bt, obj, os, bt->bt_gen);\n\t\t}\n\n\t\tdmu_buf_rele(db, FTAG);\n\t\tztest_object_unlock(zd, obj);\n\t}\n}\n\nvoid\nztest_dsl_prop_get_set(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) id;\n\tzfs_prop_t proplist[] = {\n\t\tZFS_PROP_CHECKSUM,\n\t\tZFS_PROP_COMPRESSION,\n\t\tZFS_PROP_COPIES,\n\t\tZFS_PROP_DEDUP\n\t};\n\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\tfor (int p = 0; p < sizeof (proplist) / sizeof (proplist[0]); p++) {\n\t\tint error = ztest_dsl_prop_set_uint64(zd->zd_name, proplist[p],\n\t\t    ztest_random_dsl_prop(proplist[p]), (int)ztest_random(2));\n\t\tASSERT(error == 0 || error == ENOSPC);\n\t}\n\n\tint error = ztest_dsl_prop_set_uint64(zd->zd_name, ZFS_PROP_RECORDSIZE,\n\t    ztest_random_blocksize(), (int)ztest_random(2));\n\tASSERT(error == 0 || error == ENOSPC);\n\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n}\n\nvoid\nztest_spa_prop_get_set(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tnvlist_t *props = NULL;\n\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\t(void) ztest_spa_prop_set_uint64(ZPOOL_PROP_AUTOTRIM, ztest_random(2));\n\n\tVERIFY0(spa_prop_get(ztest_spa, &props));\n\n\tif (ztest_opts.zo_verbose >= 6)\n\t\tdump_nvlist(props, 4);\n\n\tfnvlist_free(props);\n\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n}\n\nstatic int\nuser_release_one(const char *snapname, const char *holdname)\n{\n\tnvlist_t *snaps, *holds;\n\tint error;\n\n\tsnaps = fnvlist_alloc();\n\tholds = fnvlist_alloc();\n\tfnvlist_add_boolean(holds, holdname);\n\tfnvlist_add_nvlist(snaps, snapname, holds);\n\tfnvlist_free(holds);\n\terror = dsl_dataset_user_release(snaps, NULL);\n\tfnvlist_free(snaps);\n\treturn (error);\n}\n\n \nvoid\nztest_dmu_snapshot_hold(ztest_ds_t *zd, uint64_t id)\n{\n\tint error;\n\tobjset_t *os = zd->zd_os;\n\tobjset_t *origin;\n\tchar snapname[100];\n\tchar fullname[100];\n\tchar clonename[100];\n\tchar tag[100];\n\tchar osname[ZFS_MAX_DATASET_NAME_LEN];\n\tnvlist_t *holds;\n\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\tdmu_objset_name(os, osname);\n\n\t(void) snprintf(snapname, sizeof (snapname), \"sh1_%\"PRIu64\"\", id);\n\t(void) snprintf(fullname, sizeof (fullname), \"%s@%s\", osname, snapname);\n\t(void) snprintf(clonename, sizeof (clonename), \"%s/ch1_%\"PRIu64\"\",\n\t    osname, id);\n\t(void) snprintf(tag, sizeof (tag), \"tag_%\"PRIu64\"\", id);\n\n\t \n\terror = dsl_destroy_head(clonename);\n\tif (error != ENOENT)\n\t\tASSERT0(error);\n\terror = user_release_one(fullname, tag);\n\tif (error != ESRCH && error != ENOENT)\n\t\tASSERT0(error);\n\terror = dsl_destroy_snapshot(fullname, B_FALSE);\n\tif (error != ENOENT)\n\t\tASSERT0(error);\n\n\t \n\terror = dmu_objset_snapshot_one(osname, snapname);\n\tif (error) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(\"dmu_objset_snapshot\");\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_objset_snapshot(%s) = %d\", fullname, error);\n\t}\n\n\terror = dmu_objset_clone(clonename, fullname);\n\tif (error) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(\"dmu_objset_clone\");\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_objset_clone(%s) = %d\", clonename, error);\n\t}\n\n\terror = dsl_destroy_snapshot(fullname, B_TRUE);\n\tif (error) {\n\t\tfatal(B_FALSE, \"dsl_destroy_snapshot(%s, B_TRUE) = %d\",\n\t\t    fullname, error);\n\t}\n\n\terror = dsl_destroy_head(clonename);\n\tif (error)\n\t\tfatal(B_FALSE, \"dsl_destroy_head(%s) = %d\", clonename, error);\n\n\terror = dmu_objset_hold(fullname, FTAG, &origin);\n\tif (error != ENOENT)\n\t\tfatal(B_FALSE, \"dmu_objset_hold(%s) = %d\", fullname, error);\n\n\t \n\terror = dmu_objset_snapshot_one(osname, snapname);\n\tif (error) {\n\t\tif (error == ENOSPC) {\n\t\t\tztest_record_enospc(\"dmu_objset_snapshot\");\n\t\t\tgoto out;\n\t\t}\n\t\tfatal(B_FALSE, \"dmu_objset_snapshot(%s) = %d\", fullname, error);\n\t}\n\n\tholds = fnvlist_alloc();\n\tfnvlist_add_string(holds, fullname, tag);\n\terror = dsl_dataset_user_hold(holds, 0, NULL);\n\tfnvlist_free(holds);\n\n\tif (error == ENOSPC) {\n\t\tztest_record_enospc(\"dsl_dataset_user_hold\");\n\t\tgoto out;\n\t} else if (error) {\n\t\tfatal(B_FALSE, \"dsl_dataset_user_hold(%s, %s) = %u\",\n\t\t    fullname, tag, error);\n\t}\n\n\terror = dsl_destroy_snapshot(fullname, B_FALSE);\n\tif (error != EBUSY) {\n\t\tfatal(B_FALSE, \"dsl_destroy_snapshot(%s, B_FALSE) = %d\",\n\t\t    fullname, error);\n\t}\n\n\terror = dsl_destroy_snapshot(fullname, B_TRUE);\n\tif (error) {\n\t\tfatal(B_FALSE, \"dsl_destroy_snapshot(%s, B_TRUE) = %d\",\n\t\t    fullname, error);\n\t}\n\n\terror = user_release_one(fullname, tag);\n\tif (error)\n\t\tfatal(B_FALSE, \"user_release_one(%s, %s) = %d\",\n\t\t    fullname, tag, error);\n\n\tVERIFY3U(dmu_objset_hold(fullname, FTAG, &origin), ==, ENOENT);\n\nout:\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n}\n\n \nvoid\nztest_fault_inject(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tztest_shared_t *zs = ztest_shared;\n\tspa_t *spa = ztest_spa;\n\tint fd;\n\tuint64_t offset;\n\tuint64_t leaves;\n\tuint64_t bad = 0x1990c0ffeedecadeull;\n\tuint64_t top, leaf;\n\tchar *path0;\n\tchar *pathrand;\n\tsize_t fsize;\n\tint bshift = SPA_MAXBLOCKSHIFT + 2;\n\tint iters = 1000;\n\tint maxfaults;\n\tint mirror_save;\n\tvdev_t *vd0 = NULL;\n\tuint64_t guid0 = 0;\n\tboolean_t islog = B_FALSE;\n\n\tpath0 = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\tpathrand = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\t \n\tif (ztest_device_removal_active) {\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\tgoto out;\n\t}\n\n\tmaxfaults = MAXFAULTS(zs);\n\tleaves = MAX(zs->zs_mirrors, 1) * ztest_opts.zo_raid_children;\n\tmirror_save = zs->zs_mirrors;\n\tmutex_exit(&ztest_vdev_lock);\n\n\tASSERT3U(leaves, >=, 1);\n\n\t \n\tif (ztest_pool_scrubbed == B_FALSE)\n\t\tgoto out;\n\n\t \n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\t \n\tspa_config_enter(spa, SCL_STATE, FTAG, RW_READER);\n\n\tif (ztest_random(2) == 0) {\n\t\t \n\t\ttop = ztest_random_vdev_top(spa, B_TRUE);\n\t\tleaf = ztest_random(leaves) + zs->zs_splits;\n\n\t\t \n\t\t(void) snprintf(path0, MAXPATHLEN, ztest_dev_template,\n\t\t    ztest_opts.zo_dir, ztest_opts.zo_pool,\n\t\t    top * leaves + zs->zs_splits);\n\t\t(void) snprintf(pathrand, MAXPATHLEN, ztest_dev_template,\n\t\t    ztest_opts.zo_dir, ztest_opts.zo_pool,\n\t\t    top * leaves + leaf);\n\n\t\tvd0 = vdev_lookup_by_path(spa->spa_root_vdev, path0);\n\t\tif (vd0 != NULL && vd0->vdev_top->vdev_islog)\n\t\t\tislog = B_TRUE;\n\n\t\t \n\t\tif (vd0 != NULL && maxfaults != 1 &&\n\t\t    (!vdev_resilver_needed(vd0->vdev_top, NULL, NULL) ||\n\t\t    vd0->vdev_resilver_txg != 0)) {\n\t\t\t \n\t\t\tvdev_file_t *vf = vd0->vdev_tsd;\n\n\t\t\tzfs_dbgmsg(\"injecting fault to vdev %llu; maxfaults=%d\",\n\t\t\t    (long long)vd0->vdev_id, (int)maxfaults);\n\n\t\t\tif (vf != NULL && ztest_random(3) == 0) {\n\t\t\t\t(void) close(vf->vf_file->f_fd);\n\t\t\t\tvf->vf_file->f_fd = -1;\n\t\t\t} else if (ztest_random(2) == 0) {\n\t\t\t\tvd0->vdev_cant_read = B_TRUE;\n\t\t\t} else {\n\t\t\t\tvd0->vdev_cant_write = B_TRUE;\n\t\t\t}\n\t\t\tguid0 = vd0->vdev_guid;\n\t\t}\n\t} else {\n\t\t \n\t\tspa_aux_vdev_t *sav = &spa->spa_l2cache;\n\n\t\tif (sav->sav_count == 0) {\n\t\t\tspa_config_exit(spa, SCL_STATE, FTAG);\n\t\t\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tvd0 = sav->sav_vdevs[ztest_random(sav->sav_count)];\n\t\tguid0 = vd0->vdev_guid;\n\t\t(void) strlcpy(path0, vd0->vdev_path, MAXPATHLEN);\n\t\t(void) strlcpy(pathrand, vd0->vdev_path, MAXPATHLEN);\n\n\t\tleaf = 0;\n\t\tleaves = 1;\n\t\tmaxfaults = INT_MAX;\t \n\t}\n\n\tspa_config_exit(spa, SCL_STATE, FTAG);\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\t \n\tif ((maxfaults >= 2 || islog) && guid0 != 0) {\n\t\tif (ztest_random(10) < 6) {\n\t\t\tint flags = (ztest_random(2) == 0 ?\n\t\t\t    ZFS_OFFLINE_TEMPORARY : 0);\n\n\t\t\t \n\t\t\tif (islog)\n\t\t\t\t(void) pthread_rwlock_wrlock(&ztest_name_lock);\n\n\t\t\tVERIFY3U(vdev_offline(spa, guid0, flags), !=, EBUSY);\n\n\t\t\tif (islog)\n\t\t\t\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\t\t} else {\n\t\t\t \n\t\t\tmutex_enter(&ztest_vdev_lock);\n\t\t\t(void) vdev_online(spa, guid0, 0, NULL);\n\t\t\tmutex_exit(&ztest_vdev_lock);\n\t\t}\n\t}\n\n\tif (maxfaults == 0)\n\t\tgoto out;\n\n\t \n\tfd = open(pathrand, O_RDWR);\n\n\tif (fd == -1)  \n\t\tgoto out;\n\n\tfsize = lseek(fd, 0, SEEK_END);\n\n\twhile (--iters != 0) {\n\t\t \n\t\toffset = ztest_random(fsize / (leaves << bshift)) *\n\t\t    (leaves << bshift) + (leaf << bshift) +\n\t\t    (ztest_random(1ULL << (bshift - 1)) & -8ULL);\n\n\t\t \n\t\tif ((leaf & 1) == 0 && offset < VDEV_LABEL_START_SIZE)\n\t\t\tcontinue;\n\n\t\t \n\t\tuint64_t psize = P2ALIGN(fsize, sizeof (vdev_label_t));\n\t\tif ((leaf & 1) == 1 &&\n\t\t    offset + sizeof (bad) > psize - VDEV_LABEL_END_SIZE)\n\t\t\tcontinue;\n\n\t\tmutex_enter(&ztest_vdev_lock);\n\t\tif (mirror_save != zs->zs_mirrors) {\n\t\t\tmutex_exit(&ztest_vdev_lock);\n\t\t\t(void) close(fd);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pwrite(fd, &bad, sizeof (bad), offset) != sizeof (bad))\n\t\t\tfatal(B_TRUE,\n\t\t\t    \"can't inject bad word at 0x%\"PRIx64\" in %s\",\n\t\t\t    offset, pathrand);\n\n\t\tmutex_exit(&ztest_vdev_lock);\n\n\t\tif (ztest_opts.zo_verbose >= 7)\n\t\t\t(void) printf(\"injected bad word into %s,\"\n\t\t\t    \" offset 0x%\"PRIx64\"\\n\", pathrand, offset);\n\t}\n\n\t(void) close(fd);\nout:\n\tumem_free(path0, MAXPATHLEN);\n\tumem_free(pathrand, MAXPATHLEN);\n}\n\n \nstatic int\nztest_scrub_impl(spa_t *spa)\n{\n\tint error = spa_scan(spa, POOL_SCAN_SCRUB);\n\tif (error)\n\t\treturn (error);\n\n\twhile (dsl_scan_scrubbing(spa_get_dsl(spa)))\n\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\tif (spa_approx_errlog_size(spa) > 0)\n\t\treturn (ECKSUM);\n\n\tztest_pool_scrubbed = B_TRUE;\n\n\treturn (0);\n}\n\n \nvoid\nztest_scrub(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\tint error;\n\n\t \n\tif (ztest_device_removal_active)\n\t\treturn;\n\n\t \n\t(void) spa_scan(spa, POOL_SCAN_SCRUB);\n\t(void) poll(NULL, 0, 100);\n\n\terror = ztest_scrub_impl(spa);\n\tif (error == EBUSY)\n\t\terror = 0;\n\tASSERT0(error);\n}\n\n \nvoid\nztest_reguid(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\tuint64_t orig, load;\n\tint error;\n\tztest_shared_t *zs = ztest_shared;\n\n\tif (ztest_opts.zo_mmp_test)\n\t\treturn;\n\n\torig = spa_guid(spa);\n\tload = spa_load_guid(spa);\n\n\t(void) pthread_rwlock_wrlock(&ztest_name_lock);\n\terror = spa_change_guid(spa);\n\tzs->zs_guid = spa_guid(spa);\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\tif (error != 0)\n\t\treturn;\n\n\tif (ztest_opts.zo_verbose >= 4) {\n\t\t(void) printf(\"Changed guid old %\"PRIu64\" -> %\"PRIu64\"\\n\",\n\t\t    orig, spa_guid(spa));\n\t}\n\n\tVERIFY3U(orig, !=, spa_guid(spa));\n\tVERIFY3U(load, ==, spa_load_guid(spa));\n}\n\nvoid\nztest_blake3(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\thrtime_t end = gethrtime() + NANOSEC;\n\tzio_cksum_salt_t salt;\n\tvoid *salt_ptr = &salt.zcs_bytes;\n\tstruct abd *abd_data, *abd_meta;\n\tvoid *buf, *templ;\n\tint i, *ptr;\n\tuint32_t size;\n\tBLAKE3_CTX ctx;\n\tconst zfs_impl_t *blake3 = zfs_impl_get_ops(\"blake3\");\n\n\tsize = ztest_random_blocksize();\n\tbuf = umem_alloc(size, UMEM_NOFAIL);\n\tabd_data = abd_alloc(size, B_FALSE);\n\tabd_meta = abd_alloc(size, B_TRUE);\n\n\tfor (i = 0, ptr = buf; i < size / sizeof (*ptr); i++, ptr++)\n\t\t*ptr = ztest_random(UINT_MAX);\n\tmemset(salt_ptr, 'A', 32);\n\n\tabd_copy_from_buf_off(abd_data, buf, 0, size);\n\tabd_copy_from_buf_off(abd_meta, buf, 0, size);\n\n\twhile (gethrtime() <= end) {\n\t\tint run_count = 100;\n\t\tzio_cksum_t zc_ref1, zc_ref2;\n\t\tzio_cksum_t zc_res1, zc_res2;\n\n\t\tvoid *ref1 = &zc_ref1;\n\t\tvoid *ref2 = &zc_ref2;\n\t\tvoid *res1 = &zc_res1;\n\t\tvoid *res2 = &zc_res2;\n\n\t\t \n\t\tVERIFY0(blake3->setname(\"generic\"));\n\t\ttempl = abd_checksum_blake3_tmpl_init(&salt);\n\t\tBlake3_InitKeyed(&ctx, salt_ptr);\n\t\tBlake3_Update(&ctx, buf, size);\n\t\tBlake3_Final(&ctx, ref1);\n\t\tzc_ref2 = zc_ref1;\n\t\tZIO_CHECKSUM_BSWAP(&zc_ref2);\n\t\tabd_checksum_blake3_tmpl_free(templ);\n\n\t\tVERIFY0(blake3->setname(\"cycle\"));\n\t\twhile (run_count-- > 0) {\n\n\t\t\t \n\t\t\tBlake3_InitKeyed(&ctx, salt_ptr);\n\t\t\tBlake3_Update(&ctx, buf, size);\n\t\t\tBlake3_Final(&ctx, res1);\n\t\t\tzc_res2 = zc_res1;\n\t\t\tZIO_CHECKSUM_BSWAP(&zc_res2);\n\n\t\t\tVERIFY0(memcmp(ref1, res1, 32));\n\t\t\tVERIFY0(memcmp(ref2, res2, 32));\n\n\t\t\t \n\t\t\ttempl = abd_checksum_blake3_tmpl_init(&salt);\n\t\t\tabd_checksum_blake3_native(abd_data, size,\n\t\t\t    templ, &zc_res1);\n\t\t\tabd_checksum_blake3_byteswap(abd_data, size,\n\t\t\t    templ, &zc_res2);\n\n\t\t\tVERIFY0(memcmp(ref1, res1, 32));\n\t\t\tVERIFY0(memcmp(ref2, res2, 32));\n\n\t\t\t \n\t\t\tabd_checksum_blake3_native(abd_meta, size,\n\t\t\t    templ, &zc_res1);\n\t\t\tabd_checksum_blake3_byteswap(abd_meta, size,\n\t\t\t    templ, &zc_res2);\n\t\t\tabd_checksum_blake3_tmpl_free(templ);\n\n\t\t\tVERIFY0(memcmp(ref1, res1, 32));\n\t\t\tVERIFY0(memcmp(ref2, res2, 32));\n\n\t\t}\n\t}\n\n\tabd_free(abd_data);\n\tabd_free(abd_meta);\n\tumem_free(buf, size);\n}\n\nvoid\nztest_fletcher(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\thrtime_t end = gethrtime() + NANOSEC;\n\n\twhile (gethrtime() <= end) {\n\t\tint run_count = 100;\n\t\tvoid *buf;\n\t\tstruct abd *abd_data, *abd_meta;\n\t\tuint32_t size;\n\t\tint *ptr;\n\t\tint i;\n\t\tzio_cksum_t zc_ref;\n\t\tzio_cksum_t zc_ref_byteswap;\n\n\t\tsize = ztest_random_blocksize();\n\n\t\tbuf = umem_alloc(size, UMEM_NOFAIL);\n\t\tabd_data = abd_alloc(size, B_FALSE);\n\t\tabd_meta = abd_alloc(size, B_TRUE);\n\n\t\tfor (i = 0, ptr = buf; i < size / sizeof (*ptr); i++, ptr++)\n\t\t\t*ptr = ztest_random(UINT_MAX);\n\n\t\tabd_copy_from_buf_off(abd_data, buf, 0, size);\n\t\tabd_copy_from_buf_off(abd_meta, buf, 0, size);\n\n\t\tVERIFY0(fletcher_4_impl_set(\"scalar\"));\n\t\tfletcher_4_native(buf, size, NULL, &zc_ref);\n\t\tfletcher_4_byteswap(buf, size, NULL, &zc_ref_byteswap);\n\n\t\tVERIFY0(fletcher_4_impl_set(\"cycle\"));\n\t\twhile (run_count-- > 0) {\n\t\t\tzio_cksum_t zc;\n\t\t\tzio_cksum_t zc_byteswap;\n\n\t\t\tfletcher_4_byteswap(buf, size, NULL, &zc_byteswap);\n\t\t\tfletcher_4_native(buf, size, NULL, &zc);\n\n\t\t\tVERIFY0(memcmp(&zc, &zc_ref, sizeof (zc)));\n\t\t\tVERIFY0(memcmp(&zc_byteswap, &zc_ref_byteswap,\n\t\t\t    sizeof (zc_byteswap)));\n\n\t\t\t \n\t\t\tabd_fletcher_4_byteswap(abd_data, size, NULL,\n\t\t\t    &zc_byteswap);\n\t\t\tabd_fletcher_4_native(abd_data, size, NULL, &zc);\n\n\t\t\tVERIFY0(memcmp(&zc, &zc_ref, sizeof (zc)));\n\t\t\tVERIFY0(memcmp(&zc_byteswap, &zc_ref_byteswap,\n\t\t\t    sizeof (zc_byteswap)));\n\n\t\t\t \n\t\t\tabd_fletcher_4_byteswap(abd_meta, size, NULL,\n\t\t\t    &zc_byteswap);\n\t\t\tabd_fletcher_4_native(abd_meta, size, NULL, &zc);\n\n\t\t\tVERIFY0(memcmp(&zc, &zc_ref, sizeof (zc)));\n\t\t\tVERIFY0(memcmp(&zc_byteswap, &zc_ref_byteswap,\n\t\t\t    sizeof (zc_byteswap)));\n\n\t\t}\n\n\t\tumem_free(buf, size);\n\t\tabd_free(abd_data);\n\t\tabd_free(abd_meta);\n\t}\n}\n\nvoid\nztest_fletcher_incr(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tvoid *buf;\n\tsize_t size;\n\tint *ptr;\n\tint i;\n\tzio_cksum_t zc_ref;\n\tzio_cksum_t zc_ref_bswap;\n\n\thrtime_t end = gethrtime() + NANOSEC;\n\n\twhile (gethrtime() <= end) {\n\t\tint run_count = 100;\n\n\t\tsize = ztest_random_blocksize();\n\t\tbuf = umem_alloc(size, UMEM_NOFAIL);\n\n\t\tfor (i = 0, ptr = buf; i < size / sizeof (*ptr); i++, ptr++)\n\t\t\t*ptr = ztest_random(UINT_MAX);\n\n\t\tVERIFY0(fletcher_4_impl_set(\"scalar\"));\n\t\tfletcher_4_native(buf, size, NULL, &zc_ref);\n\t\tfletcher_4_byteswap(buf, size, NULL, &zc_ref_bswap);\n\n\t\tVERIFY0(fletcher_4_impl_set(\"cycle\"));\n\n\t\twhile (run_count-- > 0) {\n\t\t\tzio_cksum_t zc;\n\t\t\tzio_cksum_t zc_bswap;\n\t\t\tsize_t pos = 0;\n\n\t\t\tZIO_SET_CHECKSUM(&zc, 0, 0, 0, 0);\n\t\t\tZIO_SET_CHECKSUM(&zc_bswap, 0, 0, 0, 0);\n\n\t\t\twhile (pos < size) {\n\t\t\t\tsize_t inc = 64 * ztest_random(size / 67);\n\t\t\t\t \n\t\t\t\tif (ztest_random(100) < 10)\n\t\t\t\t\tinc += P2ALIGN(ztest_random(64),\n\t\t\t\t\t    sizeof (uint32_t));\n\n\t\t\t\tif (inc > (size - pos))\n\t\t\t\t\tinc = size - pos;\n\n\t\t\t\tfletcher_4_incremental_native(buf + pos, inc,\n\t\t\t\t    &zc);\n\t\t\t\tfletcher_4_incremental_byteswap(buf + pos, inc,\n\t\t\t\t    &zc_bswap);\n\n\t\t\t\tpos += inc;\n\t\t\t}\n\n\t\t\tVERIFY3U(pos, ==, size);\n\n\t\t\tVERIFY(ZIO_CHECKSUM_EQUAL(zc, zc_ref));\n\t\t\tVERIFY(ZIO_CHECKSUM_EQUAL(zc_bswap, zc_ref_bswap));\n\n\t\t\t \n\t\t\tZIO_SET_CHECKSUM(&zc, 0, 0, 0, 0);\n\t\t\tZIO_SET_CHECKSUM(&zc_bswap, 0, 0, 0, 0);\n\n\t\t\tfletcher_4_incremental_native(buf, size, &zc);\n\t\t\tfletcher_4_incremental_byteswap(buf, size, &zc_bswap);\n\n\t\t\tVERIFY(ZIO_CHECKSUM_EQUAL(zc, zc_ref));\n\t\t\tVERIFY(ZIO_CHECKSUM_EQUAL(zc_bswap, zc_ref_bswap));\n\t\t}\n\n\t\tumem_free(buf, size);\n\t}\n}\n\nstatic int\nztest_set_global_vars(void)\n{\n\tfor (size_t i = 0; i < ztest_opts.zo_gvars_count; i++) {\n\t\tchar *kv = ztest_opts.zo_gvars[i];\n\t\tVERIFY3U(strlen(kv), <=, ZO_GVARS_MAX_ARGLEN);\n\t\tVERIFY3U(strlen(kv), >, 0);\n\t\tint err = set_global_var(kv);\n\t\tif (ztest_opts.zo_verbose > 0) {\n\t\t\t(void) printf(\"setting global var %s ... %s\\n\", kv,\n\t\t\t    err ? \"failed\" : \"ok\");\n\t\t}\n\t\tif (err != 0) {\n\t\t\t(void) fprintf(stderr,\n\t\t\t    \"failed to set global var '%s'\\n\", kv);\n\t\t\treturn (err);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic char **\nztest_global_vars_to_zdb_args(void)\n{\n\tchar **args = calloc(2*ztest_opts.zo_gvars_count + 1, sizeof (char *));\n\tchar **cur = args;\n\tif (args == NULL)\n\t\treturn (NULL);\n\tfor (size_t i = 0; i < ztest_opts.zo_gvars_count; i++) {\n\t\t*cur++ = (char *)\"-o\";\n\t\t*cur++ = ztest_opts.zo_gvars[i];\n\t}\n\tASSERT3P(cur, ==, &args[2*ztest_opts.zo_gvars_count]);\n\t*cur = NULL;\n\treturn (args);\n}\n\n \nstatic char *\njoin_strings(char **strings, const char *sep)\n{\n\tsize_t totallen = 0;\n\tfor (char **sp = strings; *sp != NULL; sp++) {\n\t\ttotallen += strlen(*sp);\n\t\ttotallen += strlen(sep);\n\t}\n\tif (totallen > 0) {\n\t\tASSERT(totallen >= strlen(sep));\n\t\ttotallen -= strlen(sep);\n\t}\n\n\tsize_t buflen = totallen + 1;\n\tchar *o = umem_alloc(buflen, UMEM_NOFAIL);  \n\to[0] = '\\0';\n\tfor (char **sp = strings; *sp != NULL; sp++) {\n\t\tsize_t would;\n\t\twould = strlcat(o, *sp, buflen);\n\t\tVERIFY3U(would, <, buflen);\n\t\tif (*(sp+1) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\twould = strlcat(o, sep, buflen);\n\t\tVERIFY3U(would, <, buflen);\n\t}\n\tASSERT3S(strlen(o), ==, totallen);\n\treturn (o);\n}\n\nstatic int\nztest_check_path(char *path)\n{\n\tstruct stat s;\n\t \n\treturn (!stat(path, &s));\n}\n\nstatic void\nztest_get_zdb_bin(char *bin, int len)\n{\n\tchar *zdb_path;\n\t \n\tif ((zdb_path = getenv(\"ZDB\"))) {\n\t\tstrlcpy(bin, zdb_path, len);  \n\t\tif (!ztest_check_path(bin)) {\n\t\t\tztest_dump_core = 0;\n\t\t\tfatal(B_TRUE, \"invalid ZDB '%s'\", bin);\n\t\t}\n\t\treturn;\n\t}\n\n\tVERIFY3P(realpath(getexecname(), bin), !=, NULL);\n\tif (strstr(bin, \".libs/ztest\")) {\n\t\tstrstr(bin, \".libs/ztest\")[0] = '\\0';  \n\t\tstrcat(bin, \"zdb\");\n\t\tif (ztest_check_path(bin))\n\t\t\treturn;\n\t}\n\tstrcpy(bin, \"zdb\");\n}\n\nstatic vdev_t *\nztest_random_concrete_vdev_leaf(vdev_t *vd)\n{\n\tif (vd == NULL)\n\t\treturn (NULL);\n\n\tif (vd->vdev_children == 0)\n\t\treturn (vd);\n\n\tvdev_t *eligible[vd->vdev_children];\n\tint eligible_idx = 0, i;\n\tfor (i = 0; i < vd->vdev_children; i++) {\n\t\tvdev_t *cvd = vd->vdev_child[i];\n\t\tif (cvd->vdev_top->vdev_removing)\n\t\t\tcontinue;\n\t\tif (cvd->vdev_children > 0 ||\n\t\t    (vdev_is_concrete(cvd) && !cvd->vdev_detached)) {\n\t\t\teligible[eligible_idx++] = cvd;\n\t\t}\n\t}\n\tVERIFY3S(eligible_idx, >, 0);\n\n\tuint64_t child_no = ztest_random(eligible_idx);\n\treturn (ztest_random_concrete_vdev_leaf(eligible[child_no]));\n}\n\nvoid\nztest_initialize(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\tint error = 0;\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\n\t \n\tvdev_t *rand_vd = ztest_random_concrete_vdev_leaf(spa->spa_root_vdev);\n\tif (rand_vd == NULL) {\n\t\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\t \n\tuint64_t guid = rand_vd->vdev_guid;\n\tchar *path = strdup(rand_vd->vdev_path);\n\tboolean_t active = rand_vd->vdev_initialize_thread != NULL;\n\n\tzfs_dbgmsg(\"vd %px, guid %llu\", rand_vd, (u_longlong_t)guid);\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\tuint64_t cmd = ztest_random(POOL_INITIALIZE_FUNCS);\n\n\tnvlist_t *vdev_guids = fnvlist_alloc();\n\tnvlist_t *vdev_errlist = fnvlist_alloc();\n\tfnvlist_add_uint64(vdev_guids, path, guid);\n\terror = spa_vdev_initialize(spa, vdev_guids, cmd, vdev_errlist);\n\tfnvlist_free(vdev_guids);\n\tfnvlist_free(vdev_errlist);\n\n\tswitch (cmd) {\n\tcase POOL_INITIALIZE_CANCEL:\n\t\tif (ztest_opts.zo_verbose >= 4) {\n\t\t\t(void) printf(\"Cancel initialize %s\", path);\n\t\t\tif (!active)\n\t\t\t\t(void) printf(\" failed (no initialize active)\");\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase POOL_INITIALIZE_START:\n\t\tif (ztest_opts.zo_verbose >= 4) {\n\t\t\t(void) printf(\"Start initialize %s\", path);\n\t\t\tif (active && error == 0)\n\t\t\t\t(void) printf(\" failed (already active)\");\n\t\t\telse if (error != 0)\n\t\t\t\t(void) printf(\" failed (error %d)\", error);\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase POOL_INITIALIZE_SUSPEND:\n\t\tif (ztest_opts.zo_verbose >= 4) {\n\t\t\t(void) printf(\"Suspend initialize %s\", path);\n\t\t\tif (!active)\n\t\t\t\t(void) printf(\" failed (no initialize active)\");\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tfree(path);\n\tmutex_exit(&ztest_vdev_lock);\n}\n\nvoid\nztest_trim(ztest_ds_t *zd, uint64_t id)\n{\n\t(void) zd, (void) id;\n\tspa_t *spa = ztest_spa;\n\tint error = 0;\n\n\tmutex_enter(&ztest_vdev_lock);\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\n\t \n\tvdev_t *rand_vd = ztest_random_concrete_vdev_leaf(spa->spa_root_vdev);\n\tif (rand_vd == NULL) {\n\t\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\t\tmutex_exit(&ztest_vdev_lock);\n\t\treturn;\n\t}\n\n\t \n\tuint64_t guid = rand_vd->vdev_guid;\n\tchar *path = strdup(rand_vd->vdev_path);\n\tboolean_t active = rand_vd->vdev_trim_thread != NULL;\n\n\tzfs_dbgmsg(\"vd %p, guid %llu\", rand_vd, (u_longlong_t)guid);\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\tuint64_t cmd = ztest_random(POOL_TRIM_FUNCS);\n\tuint64_t rate = 1 << ztest_random(30);\n\tboolean_t partial = (ztest_random(5) > 0);\n\tboolean_t secure = (ztest_random(5) > 0);\n\n\tnvlist_t *vdev_guids = fnvlist_alloc();\n\tnvlist_t *vdev_errlist = fnvlist_alloc();\n\tfnvlist_add_uint64(vdev_guids, path, guid);\n\terror = spa_vdev_trim(spa, vdev_guids, cmd, rate, partial,\n\t    secure, vdev_errlist);\n\tfnvlist_free(vdev_guids);\n\tfnvlist_free(vdev_errlist);\n\n\tswitch (cmd) {\n\tcase POOL_TRIM_CANCEL:\n\t\tif (ztest_opts.zo_verbose >= 4) {\n\t\t\t(void) printf(\"Cancel TRIM %s\", path);\n\t\t\tif (!active)\n\t\t\t\t(void) printf(\" failed (no TRIM active)\");\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase POOL_TRIM_START:\n\t\tif (ztest_opts.zo_verbose >= 4) {\n\t\t\t(void) printf(\"Start TRIM %s\", path);\n\t\t\tif (active && error == 0)\n\t\t\t\t(void) printf(\" failed (already active)\");\n\t\t\telse if (error != 0)\n\t\t\t\t(void) printf(\" failed (error %d)\", error);\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\tcase POOL_TRIM_SUSPEND:\n\t\tif (ztest_opts.zo_verbose >= 4) {\n\t\t\t(void) printf(\"Suspend TRIM %s\", path);\n\t\t\tif (!active)\n\t\t\t\t(void) printf(\" failed (no TRIM active)\");\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tfree(path);\n\tmutex_exit(&ztest_vdev_lock);\n}\n\n \nstatic void\nztest_run_zdb(uint64_t guid)\n{\n\tint status;\n\tchar *bin;\n\tchar *zdb;\n\tchar *zbuf;\n\tconst int len = MAXPATHLEN + MAXNAMELEN + 20;\n\tFILE *fp;\n\n\tbin = umem_alloc(len, UMEM_NOFAIL);\n\tzdb = umem_alloc(len, UMEM_NOFAIL);\n\tzbuf = umem_alloc(1024, UMEM_NOFAIL);\n\n\tztest_get_zdb_bin(bin, len);\n\n\tchar **set_gvars_args = ztest_global_vars_to_zdb_args();\n\tif (set_gvars_args == NULL) {\n\t\tfatal(B_FALSE, \"Failed to allocate memory in \"\n\t\t    \"ztest_global_vars_to_zdb_args(). Cannot run zdb.\\n\");\n\t}\n\tchar *set_gvars_args_joined = join_strings(set_gvars_args, \" \");\n\tfree(set_gvars_args);\n\n\tsize_t would = snprintf(zdb, len,\n\t    \"%s -bcc%s%s -G -d -Y -e -y %s -p %s %\"PRIu64,\n\t    bin,\n\t    ztest_opts.zo_verbose >= 3 ? \"s\" : \"\",\n\t    ztest_opts.zo_verbose >= 4 ? \"v\" : \"\",\n\t    set_gvars_args_joined,\n\t    ztest_opts.zo_dir,\n\t    guid);\n\tASSERT3U(would, <, len);\n\n\tumem_free(set_gvars_args_joined, strlen(set_gvars_args_joined) + 1);\n\n\tif (ztest_opts.zo_verbose >= 5)\n\t\t(void) printf(\"Executing %s\\n\", zdb);\n\n\tfp = popen(zdb, \"r\");\n\n\twhile (fgets(zbuf, 1024, fp) != NULL)\n\t\tif (ztest_opts.zo_verbose >= 3)\n\t\t\t(void) printf(\"%s\", zbuf);\n\n\tstatus = pclose(fp);\n\n\tif (status == 0)\n\t\tgoto out;\n\n\tztest_dump_core = 0;\n\tif (WIFEXITED(status))\n\t\tfatal(B_FALSE, \"'%s' exit code %d\", zdb, WEXITSTATUS(status));\n\telse\n\t\tfatal(B_FALSE, \"'%s' died with signal %d\",\n\t\t    zdb, WTERMSIG(status));\nout:\n\tumem_free(bin, len);\n\tumem_free(zdb, len);\n\tumem_free(zbuf, 1024);\n}\n\nstatic void\nztest_walk_pool_directory(const char *header)\n{\n\tspa_t *spa = NULL;\n\n\tif (ztest_opts.zo_verbose >= 6)\n\t\t(void) puts(header);\n\n\tmutex_enter(&spa_namespace_lock);\n\twhile ((spa = spa_next(spa)) != NULL)\n\t\tif (ztest_opts.zo_verbose >= 6)\n\t\t\t(void) printf(\"\\t%s\\n\", spa_name(spa));\n\tmutex_exit(&spa_namespace_lock);\n}\n\nstatic void\nztest_spa_import_export(char *oldname, char *newname)\n{\n\tnvlist_t *config, *newconfig;\n\tuint64_t pool_guid;\n\tspa_t *spa;\n\tint error;\n\n\tif (ztest_opts.zo_verbose >= 4) {\n\t\t(void) printf(\"import/export: old = %s, new = %s\\n\",\n\t\t    oldname, newname);\n\t}\n\n\t \n\t(void) spa_destroy(newname);\n\n\t \n\tVERIFY0(spa_open(oldname, &spa, FTAG));\n\n\t \n\tif (ztest_random(2) == 0)\n\t\t(void) spa_scan(spa, POOL_SCAN_SCRUB);\n\n\tpool_guid = spa_guid(spa);\n\tspa_close(spa, FTAG);\n\n\tztest_walk_pool_directory(\"pools before export\");\n\n\t \n\tVERIFY0(spa_export(oldname, &config, B_FALSE, B_FALSE));\n\n\tztest_walk_pool_directory(\"pools after export\");\n\n\t \n\tnewconfig = spa_tryimport(config);\n\tASSERT3P(newconfig, !=, NULL);\n\tfnvlist_free(newconfig);\n\n\t \n\terror = spa_import(newname, config, NULL, 0);\n\tif (error != 0) {\n\t\tdump_nvlist(config, 0);\n\t\tfatal(B_FALSE, \"couldn't import pool %s as %s: error %u\",\n\t\t    oldname, newname, error);\n\t}\n\n\tztest_walk_pool_directory(\"pools after import\");\n\n\t \n\tVERIFY3U(EEXIST, ==, spa_import(newname, config, NULL, 0));\n\n\t \n\tVERIFY3U(EEXIST, ==, spa_import(oldname, config, NULL, 0));\n\n\t \n\tVERIFY3U(ENOENT, ==, spa_open(oldname, &spa, FTAG));\n\n\t \n\tVERIFY0(spa_open(newname, &spa, FTAG));\n\tASSERT3U(pool_guid, ==, spa_guid(spa));\n\tspa_close(spa, FTAG);\n\n\tfnvlist_free(config);\n}\n\nstatic void\nztest_resume(spa_t *spa)\n{\n\tif (spa_suspended(spa) && ztest_opts.zo_verbose >= 6)\n\t\t(void) printf(\"resuming from suspended state\\n\");\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\tvdev_clear(spa, NULL);\n\t(void) spa_vdev_state_exit(spa, NULL, 0);\n\t(void) zio_resume(spa);\n}\n\nstatic __attribute__((noreturn)) void\nztest_resume_thread(void *arg)\n{\n\tspa_t *spa = arg;\n\n\twhile (!ztest_exiting) {\n\t\tif (spa_suspended(spa))\n\t\t\tztest_resume(spa);\n\t\t(void) poll(NULL, 0, 100);\n\n\t\t \n\t\tif (ztest_random(10) == 0)\n\t\t\tzfs_compressed_arc_enabled = ztest_random(2);\n\n\t\t \n\t\tif (ztest_random(10) == 0)\n\t\t\tzfs_abd_scatter_enabled = ztest_random(2);\n\t}\n\n\tthread_exit();\n}\n\nstatic __attribute__((noreturn)) void\nztest_deadman_thread(void *arg)\n{\n\tztest_shared_t *zs = arg;\n\tspa_t *spa = ztest_spa;\n\thrtime_t delay, overdue, last_run = gethrtime();\n\n\tdelay = (zs->zs_thread_stop - zs->zs_thread_start) +\n\t    MSEC2NSEC(zfs_deadman_synctime_ms);\n\n\twhile (!ztest_exiting) {\n\t\t \n\t\tif (gethrtime() < last_run + delay) {\n\t\t\t(void) poll(NULL, 0, 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (spa_suspended(spa) || spa->spa_root_vdev == NULL) {\n\t\t\tfatal(B_FALSE,\n\t\t\t    \"aborting test after %llu seconds because \"\n\t\t\t    \"pool has transitioned to a suspended state.\",\n\t\t\t    (u_longlong_t)zfs_deadman_synctime_ms / 1000);\n\t\t}\n\t\tvdev_deadman(spa->spa_root_vdev, FTAG);\n\n\t\t \n\t\toverdue = zs->zs_proc_stop + MSEC2NSEC(zfs_deadman_synctime_ms);\n\t\tif (gethrtime() > overdue) {\n\t\t\tfatal(B_FALSE,\n\t\t\t    \"aborting test after %llu seconds because \"\n\t\t\t    \"the process is overdue for termination.\",\n\t\t\t    (gethrtime() - zs->zs_proc_start) / NANOSEC);\n\t\t}\n\n\t\t(void) printf(\"ztest has been running for %lld seconds\\n\",\n\t\t    (gethrtime() - zs->zs_proc_start) / NANOSEC);\n\n\t\tlast_run = gethrtime();\n\t\tdelay = MSEC2NSEC(zfs_deadman_checktime_ms);\n\t}\n\n\tthread_exit();\n}\n\nstatic void\nztest_execute(int test, ztest_info_t *zi, uint64_t id)\n{\n\tztest_ds_t *zd = &ztest_ds[id % ztest_opts.zo_datasets];\n\tztest_shared_callstate_t *zc = ZTEST_GET_SHARED_CALLSTATE(test);\n\thrtime_t functime = gethrtime();\n\tint i;\n\n\tfor (i = 0; i < zi->zi_iters; i++)\n\t\tzi->zi_func(zd, id);\n\n\tfunctime = gethrtime() - functime;\n\n\tatomic_add_64(&zc->zc_count, 1);\n\tatomic_add_64(&zc->zc_time, functime);\n\n\tif (ztest_opts.zo_verbose >= 4)\n\t\t(void) printf(\"%6.2f sec in %s\\n\",\n\t\t    (double)functime / NANOSEC, zi->zi_funcname);\n}\n\nstatic __attribute__((noreturn)) void\nztest_thread(void *arg)\n{\n\tint rand;\n\tuint64_t id = (uintptr_t)arg;\n\tztest_shared_t *zs = ztest_shared;\n\tuint64_t call_next;\n\thrtime_t now;\n\tztest_info_t *zi;\n\tztest_shared_callstate_t *zc;\n\n\twhile ((now = gethrtime()) < zs->zs_thread_stop) {\n\t\t \n\t\tif (now > zs->zs_thread_kill)\n\t\t\tztest_kill(zs);\n\n\t\t \n\t\tif (zs->zs_enospc_count > 10)\n\t\t\tbreak;\n\n\t\t \n\t\trand = ztest_random(ZTEST_FUNCS);\n\t\tzi = &ztest_info[rand];\n\t\tzc = ZTEST_GET_SHARED_CALLSTATE(rand);\n\t\tcall_next = zc->zc_next;\n\n\t\tif (now >= call_next &&\n\t\t    atomic_cas_64(&zc->zc_next, call_next, call_next +\n\t\t    ztest_random(2 * zi->zi_interval[0] + 1)) == call_next) {\n\t\t\tztest_execute(rand, zi, id);\n\t\t}\n\t}\n\n\tthread_exit();\n}\n\nstatic void\nztest_dataset_name(char *dsname, const char *pool, int d)\n{\n\t(void) snprintf(dsname, ZFS_MAX_DATASET_NAME_LEN, \"%s/ds_%d\", pool, d);\n}\n\nstatic void\nztest_dataset_destroy(int d)\n{\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tint t;\n\n\tztest_dataset_name(name, ztest_opts.zo_pool, d);\n\n\tif (ztest_opts.zo_verbose >= 3)\n\t\t(void) printf(\"Destroying %s to free up space\\n\", name);\n\n\t \n\tfor (t = d; t < ztest_opts.zo_threads;\n\t    t += ztest_opts.zo_datasets)\n\t\tztest_dsl_dataset_cleanup(name, t);\n\n\t(void) dmu_objset_find(name, ztest_objset_destroy_cb, NULL,\n\t    DS_FIND_SNAPSHOTS | DS_FIND_CHILDREN);\n}\n\nstatic void\nztest_dataset_dirobj_verify(ztest_ds_t *zd)\n{\n\tuint64_t usedobjs, dirobjs, scratch;\n\n\t \n\tVERIFY0(zap_count(zd->zd_os, ZTEST_DIROBJ, &dirobjs));\n\tdmu_objset_space(zd->zd_os, &scratch, &scratch, &usedobjs, &scratch);\n\tASSERT3U(dirobjs + 1, ==, usedobjs);\n}\n\nstatic int\nztest_dataset_open(int d)\n{\n\tztest_ds_t *zd = &ztest_ds[d];\n\tuint64_t committed_seq = ZTEST_GET_SHARED_DS(d)->zd_seq;\n\tobjset_t *os;\n\tzilog_t *zilog;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tint error;\n\n\tztest_dataset_name(name, ztest_opts.zo_pool, d);\n\n\t(void) pthread_rwlock_rdlock(&ztest_name_lock);\n\n\terror = ztest_dataset_create(name);\n\tif (error == ENOSPC) {\n\t\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\t\tztest_record_enospc(FTAG);\n\t\treturn (error);\n\t}\n\tASSERT(error == 0 || error == EEXIST);\n\n\tVERIFY0(ztest_dmu_objset_own(name, DMU_OST_OTHER, B_FALSE,\n\t    B_TRUE, zd, &os));\n\t(void) pthread_rwlock_unlock(&ztest_name_lock);\n\n\tztest_zd_init(zd, ZTEST_GET_SHARED_DS(d), os);\n\n\tzilog = zd->zd_zilog;\n\n\tif (zilog->zl_header->zh_claim_lr_seq != 0 &&\n\t    zilog->zl_header->zh_claim_lr_seq < committed_seq)\n\t\tfatal(B_FALSE, \"missing log records: \"\n\t\t    \"claimed %\"PRIu64\" < committed %\"PRIu64\"\",\n\t\t    zilog->zl_header->zh_claim_lr_seq, committed_seq);\n\n\tztest_dataset_dirobj_verify(zd);\n\n\tzil_replay(os, zd, ztest_replay_vector);\n\n\tztest_dataset_dirobj_verify(zd);\n\n\tif (ztest_opts.zo_verbose >= 6)\n\t\t(void) printf(\"%s replay %\"PRIu64\" blocks, \"\n\t\t    \"%\"PRIu64\" records, seq %\"PRIu64\"\\n\",\n\t\t    zd->zd_name,\n\t\t    zilog->zl_parse_blk_count,\n\t\t    zilog->zl_parse_lr_count,\n\t\t    zilog->zl_replaying_seq);\n\n\tzilog = zil_open(os, ztest_get_data, NULL);\n\n\tif (zilog->zl_replaying_seq != 0 &&\n\t    zilog->zl_replaying_seq < committed_seq)\n\t\tfatal(B_FALSE, \"missing log records: \"\n\t\t    \"replayed %\"PRIu64\" < committed %\"PRIu64\"\",\n\t\t    zilog->zl_replaying_seq, committed_seq);\n\n\treturn (0);\n}\n\nstatic void\nztest_dataset_close(int d)\n{\n\tztest_ds_t *zd = &ztest_ds[d];\n\n\tzil_close(zd->zd_zilog);\n\tdmu_objset_disown(zd->zd_os, B_TRUE, zd);\n\n\tztest_zd_fini(zd);\n}\n\nstatic int\nztest_replay_zil_cb(const char *name, void *arg)\n{\n\t(void) arg;\n\tobjset_t *os;\n\tztest_ds_t *zdtmp;\n\n\tVERIFY0(ztest_dmu_objset_own(name, DMU_OST_ANY, B_TRUE,\n\t    B_TRUE, FTAG, &os));\n\n\tzdtmp = umem_alloc(sizeof (ztest_ds_t), UMEM_NOFAIL);\n\n\tztest_zd_init(zdtmp, NULL, os);\n\tzil_replay(os, zdtmp, ztest_replay_vector);\n\tztest_zd_fini(zdtmp);\n\n\tif (dmu_objset_zil(os)->zl_parse_lr_count != 0 &&\n\t    ztest_opts.zo_verbose >= 6) {\n\t\tzilog_t *zilog = dmu_objset_zil(os);\n\n\t\t(void) printf(\"%s replay %\"PRIu64\" blocks, \"\n\t\t    \"%\"PRIu64\" records, seq %\"PRIu64\"\\n\",\n\t\t    name,\n\t\t    zilog->zl_parse_blk_count,\n\t\t    zilog->zl_parse_lr_count,\n\t\t    zilog->zl_replaying_seq);\n\t}\n\n\tumem_free(zdtmp, sizeof (ztest_ds_t));\n\n\tdmu_objset_disown(os, B_TRUE, FTAG);\n\treturn (0);\n}\n\nstatic void\nztest_freeze(void)\n{\n\tztest_ds_t *zd = &ztest_ds[0];\n\tspa_t *spa;\n\tint numloops = 0;\n\n\tif (ztest_opts.zo_verbose >= 3)\n\t\t(void) printf(\"testing spa_freeze()...\\n\");\n\n\tkernel_init(SPA_MODE_READ | SPA_MODE_WRITE);\n\tVERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));\n\tVERIFY0(ztest_dataset_open(0));\n\tztest_spa = spa;\n\n\t \n\twhile (BP_IS_HOLE(&zd->zd_zilog->zl_header->zh_log)) {\n\t\tztest_dmu_object_alloc_free(zd, 0);\n\t\tzil_commit(zd->zd_zilog, 0);\n\t}\n\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\t \n\tspa_freeze(spa);\n\n\t \n\tuint64_t capacity = metaslab_class_get_space(spa_normal_class(spa)) / 2;\n\n\t \n\twhile (ztest_random(10) != 0 &&\n\t    numloops++ < ztest_opts.zo_maxloops &&\n\t    metaslab_class_get_alloc(spa_normal_class(spa)) < capacity) {\n\t\tztest_od_t od;\n\t\tztest_od_init(&od, 0, FTAG, 0, DMU_OT_UINT64_OTHER, 0, 0, 0);\n\t\tVERIFY0(ztest_object_init(zd, &od, sizeof (od), B_FALSE));\n\t\tztest_io(zd, od.od_object,\n\t\t    ztest_random(ZTEST_RANGE_LOCKS) << SPA_MAXBLOCKSHIFT);\n\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\t}\n\n\t \n\tzil_commit(zd->zd_zilog, 0);\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\t \n\tztest_dataset_close(0);\n\tspa_close(spa, FTAG);\n\tkernel_fini();\n\n\t \n\tkernel_init(SPA_MODE_READ | SPA_MODE_WRITE);\n\tVERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));\n\tASSERT3U(spa_freeze_txg(spa), ==, UINT64_MAX);\n\tVERIFY0(ztest_dataset_open(0));\n\tztest_spa = spa;\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\tztest_dataset_close(0);\n\tztest_reguid(NULL, 0);\n\n\tspa_close(spa, FTAG);\n\tkernel_fini();\n}\n\nstatic void\nztest_import_impl(void)\n{\n\timportargs_t args = { 0 };\n\tnvlist_t *cfg = NULL;\n\tint nsearch = 1;\n\tchar *searchdirs[nsearch];\n\tint flags = ZFS_IMPORT_MISSING_LOG;\n\n\tsearchdirs[0] = ztest_opts.zo_dir;\n\targs.paths = nsearch;\n\targs.path = searchdirs;\n\targs.can_be_active = B_FALSE;\n\n\tlibpc_handle_t lpch = {\n\t\t.lpc_lib_handle = NULL,\n\t\t.lpc_ops = &libzpool_config_ops,\n\t\t.lpc_printerr = B_TRUE\n\t};\n\tVERIFY0(zpool_find_config(&lpch, ztest_opts.zo_pool, &cfg, &args));\n\tVERIFY0(spa_import(ztest_opts.zo_pool, cfg, NULL, flags));\n\tfnvlist_free(cfg);\n}\n\n \nstatic void\nztest_import(ztest_shared_t *zs)\n{\n\tspa_t *spa;\n\n\tmutex_init(&ztest_vdev_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&ztest_checkpoint_lock, NULL, MUTEX_DEFAULT, NULL);\n\tVERIFY0(pthread_rwlock_init(&ztest_name_lock, NULL));\n\n\tkernel_init(SPA_MODE_READ | SPA_MODE_WRITE);\n\n\tztest_import_impl();\n\n\tVERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));\n\tzs->zs_metaslab_sz =\n\t    1ULL << spa->spa_root_vdev->vdev_child[0]->vdev_ms_shift;\n\tzs->zs_guid = spa_guid(spa);\n\tspa_close(spa, FTAG);\n\n\tkernel_fini();\n\n\tif (!ztest_opts.zo_mmp_test) {\n\t\tztest_run_zdb(zs->zs_guid);\n\t\tztest_freeze();\n\t\tztest_run_zdb(zs->zs_guid);\n\t}\n\n\t(void) pthread_rwlock_destroy(&ztest_name_lock);\n\tmutex_destroy(&ztest_vdev_lock);\n\tmutex_destroy(&ztest_checkpoint_lock);\n}\n\n \nstatic void\nztest_run(ztest_shared_t *zs)\n{\n\tspa_t *spa;\n\tobjset_t *os;\n\tkthread_t *resume_thread, *deadman_thread;\n\tkthread_t **run_threads;\n\tuint64_t object;\n\tint error;\n\tint t, d;\n\n\tztest_exiting = B_FALSE;\n\n\t \n\tmutex_init(&ztest_vdev_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&ztest_checkpoint_lock, NULL, MUTEX_DEFAULT, NULL);\n\tVERIFY0(pthread_rwlock_init(&ztest_name_lock, NULL));\n\n\tzs->zs_thread_start = gethrtime();\n\tzs->zs_thread_stop =\n\t    zs->zs_thread_start + ztest_opts.zo_passtime * NANOSEC;\n\tzs->zs_thread_stop = MIN(zs->zs_thread_stop, zs->zs_proc_stop);\n\tzs->zs_thread_kill = zs->zs_thread_stop;\n\tif (ztest_random(100) < ztest_opts.zo_killrate) {\n\t\tzs->zs_thread_kill -=\n\t\t    ztest_random(ztest_opts.zo_passtime * NANOSEC);\n\t}\n\n\tmutex_init(&zcl.zcl_callbacks_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tlist_create(&zcl.zcl_callbacks, sizeof (ztest_cb_data_t),\n\t    offsetof(ztest_cb_data_t, zcd_node));\n\n\t \n\tkernel_init(SPA_MODE_READ | SPA_MODE_WRITE);\n\terror = spa_open(ztest_opts.zo_pool, &spa, FTAG);\n\tif (error) {\n\t\tVERIFY3S(error, ==, ENOENT);\n\t\tztest_import_impl();\n\t\tVERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));\n\t\tzs->zs_metaslab_sz =\n\t\t    1ULL << spa->spa_root_vdev->vdev_child[0]->vdev_ms_shift;\n\t}\n\n\tmetaslab_preload_limit = ztest_random(20) + 1;\n\tztest_spa = spa;\n\n\tVERIFY0(vdev_raidz_impl_set(\"cycle\"));\n\n\tdmu_objset_stats_t dds;\n\tVERIFY0(ztest_dmu_objset_own(ztest_opts.zo_pool,\n\t    DMU_OST_ANY, B_TRUE, B_TRUE, FTAG, &os));\n\tdsl_pool_config_enter(dmu_objset_pool(os), FTAG);\n\tdmu_objset_fast_stat(os, &dds);\n\tdsl_pool_config_exit(dmu_objset_pool(os), FTAG);\n\tdmu_objset_disown(os, B_TRUE, FTAG);\n\n\t \n\tresume_thread = thread_create(NULL, 0, ztest_resume_thread,\n\t    spa, 0, NULL, TS_RUN | TS_JOINABLE, defclsyspri);\n\n\t \n\tdeadman_thread = thread_create(NULL, 0, ztest_deadman_thread,\n\t    zs, 0, NULL, TS_RUN | TS_JOINABLE, defclsyspri);\n\n\tspa->spa_deadman_failmode = ZIO_FAILURE_MODE_PANIC;\n\n\t \n\tfor (t = 0; t < 64; t++) {\n\t\tfor (d = -5; d <= 5; d++) {\n\t\t\terror = dmu_object_info(spa->spa_meta_objset,\n\t\t\t    (1ULL << t) + d, NULL);\n\t\t\tASSERT(error == 0 || error == ENOENT ||\n\t\t\t    error == EINVAL);\n\t\t}\n\t}\n\n\t \n\tif (zs->zs_enospc_count != 0) {\n\t\tint d = ztest_random(ztest_opts.zo_datasets);\n\t\tztest_dataset_destroy(d);\n\t}\n\tzs->zs_enospc_count = 0;\n\n\t \n\tif (spa->spa_removing_phys.sr_state == DSS_SCANNING ||\n\t    spa->spa_removing_phys.sr_prev_indirect_vdev != -1) {\n\t\twhile (spa->spa_removing_phys.sr_state == DSS_SCANNING)\n\t\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\t\terror = ztest_scrub_impl(spa);\n\t\tif (error == EBUSY)\n\t\t\terror = 0;\n\t\tASSERT0(error);\n\t}\n\n\trun_threads = umem_zalloc(ztest_opts.zo_threads * sizeof (kthread_t *),\n\t    UMEM_NOFAIL);\n\n\tif (ztest_opts.zo_verbose >= 4)\n\t\t(void) printf(\"starting main threads...\\n\");\n\n\t \n\t(void) dmu_objset_find(ztest_opts.zo_pool, ztest_replay_zil_cb,\n\t    NULL, DS_FIND_CHILDREN);\n\n\t \n\tfor (t = 0; t < ztest_opts.zo_threads; t++) {\n\t\tif (t < ztest_opts.zo_datasets && ztest_dataset_open(t) != 0) {\n\t\t\tumem_free(run_threads, ztest_opts.zo_threads *\n\t\t\t    sizeof (kthread_t *));\n\t\t\treturn;\n\t\t}\n\n\t\trun_threads[t] = thread_create(NULL, 0, ztest_thread,\n\t\t    (void *)(uintptr_t)t, 0, NULL, TS_RUN | TS_JOINABLE,\n\t\t    defclsyspri);\n\t}\n\n\t \n\tfor (t = 0; t < ztest_opts.zo_threads; t++)\n\t\tVERIFY0(thread_join(run_threads[t]));\n\n\t \n\tfor (t = 0; t < ztest_opts.zo_threads; t++) {\n\t\tif (t < ztest_opts.zo_datasets)\n\t\t\tztest_dataset_close(t);\n\t}\n\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\tzs->zs_alloc = metaslab_class_get_alloc(spa_normal_class(spa));\n\tzs->zs_space = metaslab_class_get_space(spa_normal_class(spa));\n\n\tumem_free(run_threads, ztest_opts.zo_threads * sizeof (kthread_t *));\n\n\t \n\tztest_exiting = B_TRUE;\n\tVERIFY0(thread_join(resume_thread));\n\tVERIFY0(thread_join(deadman_thread));\n\tztest_resume(spa);\n\n\t \n\tfor (object = 1; object < 50; object++) {\n\t\tdmu_prefetch(spa->spa_meta_objset, object, 0, 0, 1ULL << 20,\n\t\t    ZIO_PRIORITY_SYNC_READ);\n\t}\n\n\t \n\tif (zc_cb_counter >= ZTEST_COMMIT_CB_MIN_REG)\n\t\tVERIFY0(zc_min_txg_delay);\n\n\tspa_close(spa, FTAG);\n\n\t \n\tmutex_enter(&spa_namespace_lock);\n\tfor (spa = spa_next(NULL); spa != NULL; spa = spa_next(spa))\n\t\tif (ztest_opts.zo_verbose > 3)\n\t\t\t(void) printf(\"spa_next: found %s\\n\", spa_name(spa));\n\tmutex_exit(&spa_namespace_lock);\n\n\t \n\tif ((ztest_random(2) == 0) && !ztest_opts.zo_mmp_test) {\n\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\t(void) snprintf(name, sizeof (name), \"%s_import\",\n\t\t    ztest_opts.zo_pool);\n\t\tztest_spa_import_export(ztest_opts.zo_pool, name);\n\t\tztest_spa_import_export(name, ztest_opts.zo_pool);\n\t}\n\n\tkernel_fini();\n\n\tlist_destroy(&zcl.zcl_callbacks);\n\tmutex_destroy(&zcl.zcl_callbacks_lock);\n\t(void) pthread_rwlock_destroy(&ztest_name_lock);\n\tmutex_destroy(&ztest_vdev_lock);\n\tmutex_destroy(&ztest_checkpoint_lock);\n}\n\nstatic void\nprint_time(hrtime_t t, char *timebuf)\n{\n\thrtime_t s = t / NANOSEC;\n\thrtime_t m = s / 60;\n\thrtime_t h = m / 60;\n\thrtime_t d = h / 24;\n\n\ts -= m * 60;\n\tm -= h * 60;\n\th -= d * 24;\n\n\ttimebuf[0] = '\\0';\n\n\tif (d)\n\t\t(void) sprintf(timebuf,\n\t\t    \"%llud%02lluh%02llum%02llus\", d, h, m, s);\n\telse if (h)\n\t\t(void) sprintf(timebuf, \"%lluh%02llum%02llus\", h, m, s);\n\telse if (m)\n\t\t(void) sprintf(timebuf, \"%llum%02llus\", m, s);\n\telse\n\t\t(void) sprintf(timebuf, \"%llus\", s);\n}\n\nstatic nvlist_t *\nmake_random_props(void)\n{\n\tnvlist_t *props;\n\n\tprops = fnvlist_alloc();\n\n\tif (ztest_random(2) == 0)\n\t\treturn (props);\n\n\tfnvlist_add_uint64(props,\n\t    zpool_prop_to_name(ZPOOL_PROP_AUTOREPLACE), 1);\n\n\treturn (props);\n}\n\n \nstatic void\nztest_init(ztest_shared_t *zs)\n{\n\tspa_t *spa;\n\tnvlist_t *nvroot, *props;\n\tint i;\n\n\tmutex_init(&ztest_vdev_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&ztest_checkpoint_lock, NULL, MUTEX_DEFAULT, NULL);\n\tVERIFY0(pthread_rwlock_init(&ztest_name_lock, NULL));\n\n\tkernel_init(SPA_MODE_READ | SPA_MODE_WRITE);\n\n\t \n\t(void) spa_destroy(ztest_opts.zo_pool);\n\tztest_shared->zs_vdev_next_leaf = 0;\n\tzs->zs_splits = 0;\n\tzs->zs_mirrors = ztest_opts.zo_mirrors;\n\tnvroot = make_vdev_root(NULL, NULL, NULL, ztest_opts.zo_vdev_size, 0,\n\t    NULL, ztest_opts.zo_raid_children, zs->zs_mirrors, 1);\n\tprops = make_random_props();\n\n\t \n\tfnvlist_add_uint64(props,\n\t    zpool_prop_to_name(ZPOOL_PROP_FAILUREMODE),\n\t    MAXFAULTS(zs) ? ZIO_FAILURE_MODE_PANIC : ZIO_FAILURE_MODE_WAIT);\n\n\tfor (i = 0; i < SPA_FEATURES; i++) {\n\t\tchar *buf;\n\n\t\tif (!spa_feature_table[i].fi_zfs_mod_supported)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i == SPA_FEATURE_LOG_SPACEMAP && ztest_random(4) == 0)\n\t\t\tcontinue;\n\n\t\tVERIFY3S(-1, !=, asprintf(&buf, \"feature@%s\",\n\t\t    spa_feature_table[i].fi_uname));\n\t\tfnvlist_add_uint64(props, buf, 0);\n\t\tfree(buf);\n\t}\n\n\tVERIFY0(spa_create(ztest_opts.zo_pool, nvroot, props, NULL, NULL));\n\tfnvlist_free(nvroot);\n\tfnvlist_free(props);\n\n\tVERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));\n\tzs->zs_metaslab_sz =\n\t    1ULL << spa->spa_root_vdev->vdev_child[0]->vdev_ms_shift;\n\tzs->zs_guid = spa_guid(spa);\n\tspa_close(spa, FTAG);\n\n\tkernel_fini();\n\n\tif (!ztest_opts.zo_mmp_test) {\n\t\tztest_run_zdb(zs->zs_guid);\n\t\tztest_freeze();\n\t\tztest_run_zdb(zs->zs_guid);\n\t}\n\n\t(void) pthread_rwlock_destroy(&ztest_name_lock);\n\tmutex_destroy(&ztest_vdev_lock);\n\tmutex_destroy(&ztest_checkpoint_lock);\n}\n\nstatic void\nsetup_data_fd(void)\n{\n\tstatic char ztest_name_data[] = \"/tmp/ztest.data.XXXXXX\";\n\n\tztest_fd_data = mkstemp(ztest_name_data);\n\tASSERT3S(ztest_fd_data, >=, 0);\n\t(void) unlink(ztest_name_data);\n}\n\nstatic int\nshared_data_size(ztest_shared_hdr_t *hdr)\n{\n\tint size;\n\n\tsize = hdr->zh_hdr_size;\n\tsize += hdr->zh_opts_size;\n\tsize += hdr->zh_size;\n\tsize += hdr->zh_stats_size * hdr->zh_stats_count;\n\tsize += hdr->zh_ds_size * hdr->zh_ds_count;\n\n\treturn (size);\n}\n\nstatic void\nsetup_hdr(void)\n{\n\tint size;\n\tztest_shared_hdr_t *hdr;\n\n\thdr = (void *)mmap(0, P2ROUNDUP(sizeof (*hdr), getpagesize()),\n\t    PROT_READ | PROT_WRITE, MAP_SHARED, ztest_fd_data, 0);\n\tASSERT3P(hdr, !=, MAP_FAILED);\n\n\tVERIFY0(ftruncate(ztest_fd_data, sizeof (ztest_shared_hdr_t)));\n\n\thdr->zh_hdr_size = sizeof (ztest_shared_hdr_t);\n\thdr->zh_opts_size = sizeof (ztest_shared_opts_t);\n\thdr->zh_size = sizeof (ztest_shared_t);\n\thdr->zh_stats_size = sizeof (ztest_shared_callstate_t);\n\thdr->zh_stats_count = ZTEST_FUNCS;\n\thdr->zh_ds_size = sizeof (ztest_shared_ds_t);\n\thdr->zh_ds_count = ztest_opts.zo_datasets;\n\n\tsize = shared_data_size(hdr);\n\tVERIFY0(ftruncate(ztest_fd_data, size));\n\n\t(void) munmap((caddr_t)hdr, P2ROUNDUP(sizeof (*hdr), getpagesize()));\n}\n\nstatic void\nsetup_data(void)\n{\n\tint size, offset;\n\tztest_shared_hdr_t *hdr;\n\tuint8_t *buf;\n\n\thdr = (void *)mmap(0, P2ROUNDUP(sizeof (*hdr), getpagesize()),\n\t    PROT_READ, MAP_SHARED, ztest_fd_data, 0);\n\tASSERT3P(hdr, !=, MAP_FAILED);\n\n\tsize = shared_data_size(hdr);\n\n\t(void) munmap((caddr_t)hdr, P2ROUNDUP(sizeof (*hdr), getpagesize()));\n\thdr = ztest_shared_hdr = (void *)mmap(0, P2ROUNDUP(size, getpagesize()),\n\t    PROT_READ | PROT_WRITE, MAP_SHARED, ztest_fd_data, 0);\n\tASSERT3P(hdr, !=, MAP_FAILED);\n\tbuf = (uint8_t *)hdr;\n\n\toffset = hdr->zh_hdr_size;\n\tztest_shared_opts = (void *)&buf[offset];\n\toffset += hdr->zh_opts_size;\n\tztest_shared = (void *)&buf[offset];\n\toffset += hdr->zh_size;\n\tztest_shared_callstate = (void *)&buf[offset];\n\toffset += hdr->zh_stats_size * hdr->zh_stats_count;\n\tztest_shared_ds = (void *)&buf[offset];\n}\n\nstatic boolean_t\nexec_child(char *cmd, char *libpath, boolean_t ignorekill, int *statusp)\n{\n\tpid_t pid;\n\tint status;\n\tchar *cmdbuf = NULL;\n\n\tpid = fork();\n\n\tif (cmd == NULL) {\n\t\tcmdbuf = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);\n\t\t(void) strlcpy(cmdbuf, getexecname(), MAXPATHLEN);\n\t\tcmd = cmdbuf;\n\t}\n\n\tif (pid == -1)\n\t\tfatal(B_TRUE, \"fork failed\");\n\n\tif (pid == 0) {\t \n\t\tchar fd_data_str[12];\n\n\t\tVERIFY3S(11, >=,\n\t\t    snprintf(fd_data_str, 12, \"%d\", ztest_fd_data));\n\t\tVERIFY0(setenv(\"ZTEST_FD_DATA\", fd_data_str, 1));\n\n\t\tif (libpath != NULL) {\n\t\t\tconst char *curlp = getenv(\"LD_LIBRARY_PATH\");\n\t\t\tif (curlp == NULL)\n\t\t\t\tVERIFY0(setenv(\"LD_LIBRARY_PATH\", libpath, 1));\n\t\t\telse {\n\t\t\t\tchar *newlp = NULL;\n\t\t\t\tVERIFY3S(-1, !=,\n\t\t\t\t    asprintf(&newlp, \"%s:%s\", libpath, curlp));\n\t\t\t\tVERIFY0(setenv(\"LD_LIBRARY_PATH\", newlp, 1));\n\t\t\t\tfree(newlp);\n\t\t\t}\n\t\t}\n\t\t(void) execl(cmd, cmd, (char *)NULL);\n\t\tztest_dump_core = B_FALSE;\n\t\tfatal(B_TRUE, \"exec failed: %s\", cmd);\n\t}\n\n\tif (cmdbuf != NULL) {\n\t\tumem_free(cmdbuf, MAXPATHLEN);\n\t\tcmd = NULL;\n\t}\n\n\twhile (waitpid(pid, &status, 0) != pid)\n\t\tcontinue;\n\tif (statusp != NULL)\n\t\t*statusp = status;\n\n\tif (WIFEXITED(status)) {\n\t\tif (WEXITSTATUS(status) != 0) {\n\t\t\t(void) fprintf(stderr, \"child exited with code %d\\n\",\n\t\t\t    WEXITSTATUS(status));\n\t\t\texit(2);\n\t\t}\n\t\treturn (B_FALSE);\n\t} else if (WIFSIGNALED(status)) {\n\t\tif (!ignorekill || WTERMSIG(status) != SIGKILL) {\n\t\t\t(void) fprintf(stderr, \"child died with signal %d\\n\",\n\t\t\t    WTERMSIG(status));\n\t\t\texit(3);\n\t\t}\n\t\treturn (B_TRUE);\n\t} else {\n\t\t(void) fprintf(stderr, \"something strange happened to child\\n\");\n\t\texit(4);\n\t}\n}\n\nstatic void\nztest_run_init(void)\n{\n\tint i;\n\n\tztest_shared_t *zs = ztest_shared;\n\n\t \n\t(void) remove(spa_config_path);\n\n\tif (ztest_opts.zo_init == 0) {\n\t\tif (ztest_opts.zo_verbose >= 1)\n\t\t\t(void) printf(\"Importing pool %s\\n\",\n\t\t\t    ztest_opts.zo_pool);\n\t\tztest_import(zs);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 1; i <= ztest_opts.zo_init; i++) {\n\t\tmemset(zs, 0, sizeof (*zs));\n\t\tif (ztest_opts.zo_verbose >= 3 &&\n\t\t    ztest_opts.zo_init != 1) {\n\t\t\t(void) printf(\"ztest_init(), pass %d\\n\", i);\n\t\t}\n\t\tztest_init(zs);\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint kills = 0;\n\tint iters = 0;\n\tint older = 0;\n\tint newer = 0;\n\tztest_shared_t *zs;\n\tztest_info_t *zi;\n\tztest_shared_callstate_t *zc;\n\tchar timebuf[100];\n\tchar numbuf[NN_NUMBUF_SZ];\n\tchar *cmd;\n\tboolean_t hasalt;\n\tint f, err;\n\tchar *fd_data_str = getenv(\"ZTEST_FD_DATA\");\n\tstruct sigaction action;\n\n\t(void) setvbuf(stdout, NULL, _IOLBF, 0);\n\n\tdprintf_setup(&argc, argv);\n\tzfs_deadman_synctime_ms = 300000;\n\tzfs_deadman_checktime_ms = 30000;\n\t \n\tzfs_force_some_double_word_sm_entries = B_TRUE;\n\n\t \n\tzfs_reconstruct_indirect_damage_fraction = 100;\n\n\taction.sa_handler = sig_handler;\n\tsigemptyset(&action.sa_mask);\n\taction.sa_flags = 0;\n\n\tif (sigaction(SIGSEGV, &action, NULL) < 0) {\n\t\t(void) fprintf(stderr, \"ztest: cannot catch SIGSEGV: %s.\\n\",\n\t\t    strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (sigaction(SIGABRT, &action, NULL) < 0) {\n\t\t(void) fprintf(stderr, \"ztest: cannot catch SIGABRT: %s.\\n\",\n\t\t    strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t \n\trandom_path = \"/dev/urandom\";\n\tztest_fd_rand = open(random_path, O_RDONLY | O_CLOEXEC);\n\tASSERT3S(ztest_fd_rand, >=, 0);\n\n\tif (!fd_data_str) {\n\t\tprocess_options(argc, argv);\n\n\t\tsetup_data_fd();\n\t\tsetup_hdr();\n\t\tsetup_data();\n\t\tmemcpy(ztest_shared_opts, &ztest_opts,\n\t\t    sizeof (*ztest_shared_opts));\n\t} else {\n\t\tztest_fd_data = atoi(fd_data_str);\n\t\tsetup_data();\n\t\tmemcpy(&ztest_opts, ztest_shared_opts, sizeof (ztest_opts));\n\t}\n\tASSERT3U(ztest_opts.zo_datasets, ==, ztest_shared_hdr->zh_ds_count);\n\n\terr = ztest_set_global_vars();\n\tif (err != 0 && !fd_data_str) {\n\t\t \n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\t \n\t\tVERIFY3S(err, ==, 0);\n\t}\n\n\t \n\tVERIFY3S(asprintf((char **)&spa_config_path, \"%s/zpool.cache\",\n\t    ztest_opts.zo_dir), !=, -1);\n\n\tztest_ds = umem_alloc(ztest_opts.zo_datasets * sizeof (ztest_ds_t),\n\t    UMEM_NOFAIL);\n\tzs = ztest_shared;\n\n\tif (fd_data_str) {\n\t\tmetaslab_force_ganging = ztest_opts.zo_metaslab_force_ganging;\n\t\tmetaslab_df_alloc_threshold =\n\t\t    zs->zs_metaslab_df_alloc_threshold;\n\n\t\tif (zs->zs_do_init)\n\t\t\tztest_run_init();\n\t\telse\n\t\t\tztest_run(zs);\n\t\texit(0);\n\t}\n\n\thasalt = (strlen(ztest_opts.zo_alt_ztest) != 0);\n\n\tif (ztest_opts.zo_verbose >= 1) {\n\t\t(void) printf(\"%\"PRIu64\" vdevs, %d datasets, %d threads,\"\n\t\t    \"%d %s disks, %\"PRIu64\" seconds...\\n\\n\",\n\t\t    ztest_opts.zo_vdevs,\n\t\t    ztest_opts.zo_datasets,\n\t\t    ztest_opts.zo_threads,\n\t\t    ztest_opts.zo_raid_children,\n\t\t    ztest_opts.zo_raid_type,\n\t\t    ztest_opts.zo_time);\n\t}\n\n\tcmd = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);\n\t(void) strlcpy(cmd, getexecname(), MAXNAMELEN);\n\n\tzs->zs_do_init = B_TRUE;\n\tif (strlen(ztest_opts.zo_alt_ztest) != 0) {\n\t\tif (ztest_opts.zo_verbose >= 1) {\n\t\t\t(void) printf(\"Executing older ztest for \"\n\t\t\t    \"initialization: %s\\n\", ztest_opts.zo_alt_ztest);\n\t\t}\n\t\tVERIFY(!exec_child(ztest_opts.zo_alt_ztest,\n\t\t    ztest_opts.zo_alt_libpath, B_FALSE, NULL));\n\t} else {\n\t\tVERIFY(!exec_child(NULL, NULL, B_FALSE, NULL));\n\t}\n\tzs->zs_do_init = B_FALSE;\n\n\tzs->zs_proc_start = gethrtime();\n\tzs->zs_proc_stop = zs->zs_proc_start + ztest_opts.zo_time * NANOSEC;\n\n\tfor (f = 0; f < ZTEST_FUNCS; f++) {\n\t\tzi = &ztest_info[f];\n\t\tzc = ZTEST_GET_SHARED_CALLSTATE(f);\n\t\tif (zs->zs_proc_start + zi->zi_interval[0] > zs->zs_proc_stop)\n\t\t\tzc->zc_next = UINT64_MAX;\n\t\telse\n\t\t\tzc->zc_next = zs->zs_proc_start +\n\t\t\t    ztest_random(2 * zi->zi_interval[0] + 1);\n\t}\n\n\t \n\twhile (gethrtime() < zs->zs_proc_stop) {\n\t\tint status;\n\t\tboolean_t killed;\n\n\t\t \n\t\tfor (f = 0; f < ZTEST_FUNCS; f++) {\n\t\t\tzc = ZTEST_GET_SHARED_CALLSTATE(f);\n\t\t\tzc->zc_count = 0;\n\t\t\tzc->zc_time = 0;\n\t\t}\n\n\t\t \n\t\tzs->zs_metaslab_df_alloc_threshold =\n\t\t    ztest_random(zs->zs_metaslab_sz / 4) + 1;\n\n\t\tif (!hasalt || ztest_random(2) == 0) {\n\t\t\tif (hasalt && ztest_opts.zo_verbose >= 1) {\n\t\t\t\t(void) printf(\"Executing newer ztest: %s\\n\",\n\t\t\t\t    cmd);\n\t\t\t}\n\t\t\tnewer++;\n\t\t\tkilled = exec_child(cmd, NULL, B_TRUE, &status);\n\t\t} else {\n\t\t\tif (hasalt && ztest_opts.zo_verbose >= 1) {\n\t\t\t\t(void) printf(\"Executing older ztest: %s\\n\",\n\t\t\t\t    ztest_opts.zo_alt_ztest);\n\t\t\t}\n\t\t\tolder++;\n\t\t\tkilled = exec_child(ztest_opts.zo_alt_ztest,\n\t\t\t    ztest_opts.zo_alt_libpath, B_TRUE, &status);\n\t\t}\n\n\t\tif (killed)\n\t\t\tkills++;\n\t\titers++;\n\n\t\tif (ztest_opts.zo_verbose >= 1) {\n\t\t\thrtime_t now = gethrtime();\n\n\t\t\tnow = MIN(now, zs->zs_proc_stop);\n\t\t\tprint_time(zs->zs_proc_stop - now, timebuf);\n\t\t\tnicenum(zs->zs_space, numbuf, sizeof (numbuf));\n\n\t\t\t(void) printf(\"Pass %3d, %8s, %3\"PRIu64\" ENOSPC, \"\n\t\t\t    \"%4.1f%% of %5s used, %3.0f%% done, %8s to go\\n\",\n\t\t\t    iters,\n\t\t\t    WIFEXITED(status) ? \"Complete\" : \"SIGKILL\",\n\t\t\t    zs->zs_enospc_count,\n\t\t\t    100.0 * zs->zs_alloc / zs->zs_space,\n\t\t\t    numbuf,\n\t\t\t    100.0 * (now - zs->zs_proc_start) /\n\t\t\t    (ztest_opts.zo_time * NANOSEC), timebuf);\n\t\t}\n\n\t\tif (ztest_opts.zo_verbose >= 2) {\n\t\t\t(void) printf(\"\\nWorkload summary:\\n\\n\");\n\t\t\t(void) printf(\"%7s %9s   %s\\n\",\n\t\t\t    \"Calls\", \"Time\", \"Function\");\n\t\t\t(void) printf(\"%7s %9s   %s\\n\",\n\t\t\t    \"-----\", \"----\", \"--------\");\n\t\t\tfor (f = 0; f < ZTEST_FUNCS; f++) {\n\t\t\t\tzi = &ztest_info[f];\n\t\t\t\tzc = ZTEST_GET_SHARED_CALLSTATE(f);\n\t\t\t\tprint_time(zc->zc_time, timebuf);\n\t\t\t\t(void) printf(\"%7\"PRIu64\" %9s   %s\\n\",\n\t\t\t\t    zc->zc_count, timebuf,\n\t\t\t\t    zi->zi_funcname);\n\t\t\t}\n\t\t\t(void) printf(\"\\n\");\n\t\t}\n\n\t\tif (!ztest_opts.zo_mmp_test)\n\t\t\tztest_run_zdb(zs->zs_guid);\n\t}\n\n\tif (ztest_opts.zo_verbose >= 1) {\n\t\tif (hasalt) {\n\t\t\t(void) printf(\"%d runs of older ztest: %s\\n\", older,\n\t\t\t    ztest_opts.zo_alt_ztest);\n\t\t\t(void) printf(\"%d runs of newer ztest: %s\\n\", newer,\n\t\t\t    cmd);\n\t\t}\n\t\t(void) printf(\"%d killed, %d completed, %.0f%% kill rate\\n\",\n\t\t    kills, iters - kills, (100.0 * kills) / MAX(1, iters));\n\t}\n\n\tumem_free(cmd, MAXNAMELEN);\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}