{
  "module_name": "zpool_influxdb.c",
  "hash_id": "551aec2ae41d11de133223f9b5edba9eaf12f033b1e3dcc368c1c9ebd062b3fc",
  "original_prompt": "Ingested from zfs-2.2.2/cmd/zpool_influxdb/zpool_influxdb.c",
  "human_readable_source": " \n#include <string.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <libzfs.h>\n\n#define\tPOOL_MEASUREMENT\t\"zpool_stats\"\n#define\tSCAN_MEASUREMENT\t\"zpool_scan_stats\"\n#define\tVDEV_MEASUREMENT\t\"zpool_vdev_stats\"\n#define\tPOOL_LATENCY_MEASUREMENT\t\"zpool_latency\"\n#define\tPOOL_QUEUE_MEASUREMENT\t\"zpool_vdev_queue\"\n#define\tMIN_LAT_INDEX\t10   \n#define\tPOOL_IO_SIZE_MEASUREMENT\t\"zpool_io_size\"\n#define\tMIN_SIZE_INDEX\t9   \n\n \nint execd_mode = 0;\nint no_histograms = 0;\nint sum_histogram_buckets = 0;\nchar metric_data_type = 'u';\nuint64_t metric_value_mask = UINT64_MAX;\nuint64_t timestamp = 0;\nint complained_about_sync = 0;\nconst char *tags = \"\";\n\ntypedef int (*stat_printer_f)(nvlist_t *, const char *, const char *);\n\n \nstatic char *\nescape_string(const char *s)\n{\n\tconst char *c;\n\tchar *d;\n\tchar *t = (char *)malloc(ZFS_MAX_DATASET_NAME_LEN * 2);\n\tif (t == NULL) {\n\t\tfprintf(stderr, \"error: cannot allocate memory\\n\");\n\t\texit(1);\n\t}\n\n\tfor (c = s, d = t; *c != '\\0'; c++, d++) {\n\t\tswitch (*c) {\n\t\tcase ' ':\n\t\tcase ',':\n\t\tcase '=':\n\t\tcase '\\\\':\n\t\t\t*d++ = '\\\\';\n\t\t\tzfs_fallthrough;\n\t\tdefault:\n\t\t\t*d = *c;\n\t\t}\n\t}\n\t*d = '\\0';\n\treturn (t);\n}\n\n \nstatic void\nprint_kv(const char *key, uint64_t value)\n{\n\tprintf(\"%s=%llu%c\", key,\n\t    (u_longlong_t)value & metric_value_mask, metric_data_type);\n}\n\n \nstatic int\nprint_scan_status(nvlist_t *nvroot, const char *pool_name)\n{\n\tuint_t c;\n\tint64_t elapsed;\n\tuint64_t examined, pass_exam, paused_time, paused_ts, rate;\n\tuint64_t remaining_time;\n\tpool_scan_stat_t *ps = NULL;\n\tdouble pct_done;\n\tconst char *const state[DSS_NUM_STATES] = {\n\t    \"none\", \"scanning\", \"finished\", \"canceled\"};\n\tconst char *func;\n\n\t(void) nvlist_lookup_uint64_array(nvroot,\n\t    ZPOOL_CONFIG_SCAN_STATS,\n\t    (uint64_t **)&ps, &c);\n\n\t \n\tif (ps == NULL)\n\t\treturn (0);\n\n\t \n\tif (ps->pss_state >= DSS_NUM_STATES ||\n\t    ps->pss_func >= POOL_SCAN_FUNCS) {\n\t\tif (complained_about_sync % 1000 == 0) {\n\t\t\tfprintf(stderr, \"error: cannot decode scan stats: \"\n\t\t\t    \"ZFS is out of sync with compiled zpool_influxdb\");\n\t\t\tcomplained_about_sync++;\n\t\t}\n\t\treturn (1);\n\t}\n\n\tswitch (ps->pss_func) {\n\tcase POOL_SCAN_NONE:\n\t\tfunc = \"none_requested\";\n\t\tbreak;\n\tcase POOL_SCAN_SCRUB:\n\t\tfunc = \"scrub\";\n\t\tbreak;\n\tcase POOL_SCAN_RESILVER:\n\t\tfunc = \"resilver\";\n\t\tbreak;\n#ifdef POOL_SCAN_REBUILD\n\tcase POOL_SCAN_REBUILD:\n\t\tfunc = \"rebuild\";\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfunc = \"scan\";\n\t}\n\n\t \n\texamined = ps->pss_examined ? ps->pss_examined : 1;\n\tpct_done = 0.0;\n\tif (ps->pss_to_examine > 0)\n\t\tpct_done = 100.0 * examined / ps->pss_to_examine;\n\n#ifdef EZFS_SCRUB_PAUSED\n\tpaused_ts = ps->pss_pass_scrub_pause;\n\tpaused_time = ps->pss_pass_scrub_spent_paused;\n#else\n\tpaused_ts = 0;\n\tpaused_time = 0;\n#endif\n\n\t \n\tif (ps->pss_state == DSS_SCANNING) {\n\t\telapsed = (int64_t)time(NULL) - (int64_t)ps->pss_pass_start -\n\t\t    (int64_t)paused_time;\n\t\telapsed = (elapsed > 0) ? elapsed : 1;\n\t\tpass_exam = ps->pss_pass_exam ? ps->pss_pass_exam : 1;\n\t\trate = pass_exam / elapsed;\n\t\trate = (rate > 0) ? rate : 1;\n\t\tremaining_time = ps->pss_to_examine - examined / rate;\n\t} else {\n\t\telapsed =\n\t\t    (int64_t)ps->pss_end_time - (int64_t)ps->pss_pass_start -\n\t\t    (int64_t)paused_time;\n\t\telapsed = (elapsed > 0) ? elapsed : 1;\n\t\tpass_exam = ps->pss_pass_exam ? ps->pss_pass_exam : 1;\n\t\trate = pass_exam / elapsed;\n\t\tremaining_time = 0;\n\t}\n\trate = rate ? rate : 1;\n\n\t \n\tprintf(\"%s%s,function=%s,name=%s,state=%s \",\n\t    SCAN_MEASUREMENT, tags, func, pool_name, state[ps->pss_state]);\n\tprint_kv(\"end_ts\", ps->pss_end_time);\n\tprint_kv(\",errors\", ps->pss_errors);\n\tprint_kv(\",examined\", examined);\n\tprint_kv(\",skipped\", ps->pss_skipped);\n\tprint_kv(\",issued\", ps->pss_issued);\n\tprint_kv(\",pass_examined\", pass_exam);\n\tprint_kv(\",pass_issued\", ps->pss_pass_issued);\n\tprint_kv(\",paused_ts\", paused_ts);\n\tprint_kv(\",paused_t\", paused_time);\n\tprintf(\",pct_done=%.2f\", pct_done);\n\tprint_kv(\",processed\", ps->pss_processed);\n\tprint_kv(\",rate\", rate);\n\tprint_kv(\",remaining_t\", remaining_time);\n\tprint_kv(\",start_ts\", ps->pss_start_time);\n\tprint_kv(\",to_examine\", ps->pss_to_examine);\n\tprintf(\" %llu\\n\", (u_longlong_t)timestamp);\n\treturn (0);\n}\n\n \nstatic char *\nget_vdev_name(nvlist_t *nvroot, const char *parent_name)\n{\n\tstatic char vdev_name[256];\n\tuint64_t vdev_id = 0;\n\n\tconst char *vdev_type = \"unknown\";\n\t(void) nvlist_lookup_string(nvroot, ZPOOL_CONFIG_TYPE, &vdev_type);\n\n\tif (nvlist_lookup_uint64(\n\t    nvroot, ZPOOL_CONFIG_ID, &vdev_id) != 0)\n\t\tvdev_id = UINT64_MAX;\n\n\tif (parent_name == NULL) {\n\t\t(void) snprintf(vdev_name, sizeof (vdev_name), \"%s\",\n\t\t    vdev_type);\n\t} else {\n\t\t(void) snprintf(vdev_name, sizeof (vdev_name),\n\t\t    \"%.220s/%s-%llu\",\n\t\t    parent_name, vdev_type, (u_longlong_t)vdev_id);\n\t}\n\treturn (vdev_name);\n}\n\n \nstatic char *\nget_vdev_desc(nvlist_t *nvroot, const char *parent_name)\n{\n\tstatic char vdev_desc[2 * MAXPATHLEN];\n\tchar vdev_value[MAXPATHLEN];\n\tchar *s, *t;\n\n\tconst char *vdev_type = \"unknown\";\n\tuint64_t vdev_id = UINT64_MAX;\n\tconst char *vdev_path = NULL;\n\t(void) nvlist_lookup_string(nvroot, ZPOOL_CONFIG_TYPE, &vdev_type);\n\t(void) nvlist_lookup_uint64(nvroot, ZPOOL_CONFIG_ID, &vdev_id);\n\t(void) nvlist_lookup_string(nvroot, ZPOOL_CONFIG_PATH, &vdev_path);\n\n\tif (parent_name == NULL) {\n\t\ts = escape_string(vdev_type);\n\t\t(void) snprintf(vdev_value, sizeof (vdev_value), \"vdev=%s\", s);\n\t\tfree(s);\n\t} else {\n\t\ts = escape_string((char *)parent_name);\n\t\tt = escape_string(vdev_type);\n\t\t(void) snprintf(vdev_value, sizeof (vdev_value),\n\t\t    \"vdev=%s/%s-%llu\", s, t, (u_longlong_t)vdev_id);\n\t\tfree(s);\n\t\tfree(t);\n\t}\n\tif (vdev_path == NULL) {\n\t\t(void) snprintf(vdev_desc, sizeof (vdev_desc), \"%s\",\n\t\t    vdev_value);\n\t} else {\n\t\ts = escape_string(vdev_path);\n\t\t(void) snprintf(vdev_desc, sizeof (vdev_desc), \"path=%s,%s\",\n\t\t    s, vdev_value);\n\t\tfree(s);\n\t}\n\treturn (vdev_desc);\n}\n\n \nstatic int\nprint_summary_stats(nvlist_t *nvroot, const char *pool_name,\n    const char *parent_name)\n{\n\tuint_t c;\n\tvdev_stat_t *vs;\n\tchar *vdev_desc = NULL;\n\tvdev_desc = get_vdev_desc(nvroot, parent_name);\n\tif (nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) != 0) {\n\t\treturn (1);\n\t}\n\tprintf(\"%s%s,name=%s,state=%s,%s \", POOL_MEASUREMENT, tags,\n\t    pool_name, zpool_state_to_name((vdev_state_t)vs->vs_state,\n\t    (vdev_aux_t)vs->vs_aux), vdev_desc);\n\tprint_kv(\"alloc\", vs->vs_alloc);\n\tprint_kv(\",free\", vs->vs_space - vs->vs_alloc);\n\tprint_kv(\",size\", vs->vs_space);\n\tprint_kv(\",read_bytes\", vs->vs_bytes[ZIO_TYPE_READ]);\n\tprint_kv(\",read_errors\", vs->vs_read_errors);\n\tprint_kv(\",read_ops\", vs->vs_ops[ZIO_TYPE_READ]);\n\tprint_kv(\",write_bytes\", vs->vs_bytes[ZIO_TYPE_WRITE]);\n\tprint_kv(\",write_errors\", vs->vs_write_errors);\n\tprint_kv(\",write_ops\", vs->vs_ops[ZIO_TYPE_WRITE]);\n\tprint_kv(\",checksum_errors\", vs->vs_checksum_errors);\n\tprint_kv(\",fragmentation\", vs->vs_fragmentation);\n\tprintf(\" %llu\\n\", (u_longlong_t)timestamp);\n\treturn (0);\n}\n\n \nstatic int\nprint_vdev_latency_stats(nvlist_t *nvroot, const char *pool_name,\n    const char *parent_name)\n{\n\tuint_t c, end = 0;\n\tnvlist_t *nv_ex;\n\tchar *vdev_desc = NULL;\n\n\t \n\tstruct lat_lookup {\n\t    const char *name;\n\t    const char *short_name;\n\t    uint64_t sum;\n\t    uint64_t *array;\n\t};\n\tstruct lat_lookup lat_type[] = {\n\t    {ZPOOL_CONFIG_VDEV_TOT_R_LAT_HISTO,   \"total_read\", 0},\n\t    {ZPOOL_CONFIG_VDEV_TOT_W_LAT_HISTO,   \"total_write\", 0},\n\t    {ZPOOL_CONFIG_VDEV_DISK_R_LAT_HISTO,  \"disk_read\", 0},\n\t    {ZPOOL_CONFIG_VDEV_DISK_W_LAT_HISTO,  \"disk_write\", 0},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_R_LAT_HISTO,  \"sync_read\", 0},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_W_LAT_HISTO,  \"sync_write\", 0},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_R_LAT_HISTO, \"async_read\", 0},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_W_LAT_HISTO, \"async_write\", 0},\n\t    {ZPOOL_CONFIG_VDEV_SCRUB_LAT_HISTO,   \"scrub\", 0},\n#ifdef ZPOOL_CONFIG_VDEV_TRIM_LAT_HISTO\n\t    {ZPOOL_CONFIG_VDEV_TRIM_LAT_HISTO,    \"trim\", 0},\n#endif\n\t    {ZPOOL_CONFIG_VDEV_REBUILD_LAT_HISTO,    \"rebuild\", 0},\n\t    {NULL,\tNULL}\n\t};\n\n\tif (nvlist_lookup_nvlist(nvroot,\n\t    ZPOOL_CONFIG_VDEV_STATS_EX, &nv_ex) != 0) {\n\t\treturn (6);\n\t}\n\n\tvdev_desc = get_vdev_desc(nvroot, parent_name);\n\n\tfor (int i = 0; lat_type[i].name; i++) {\n\t\tif (nvlist_lookup_uint64_array(nv_ex,\n\t\t    lat_type[i].name, &lat_type[i].array, &c) != 0) {\n\t\t\tfprintf(stderr, \"error: can't get %s\\n\",\n\t\t\t    lat_type[i].name);\n\t\t\treturn (3);\n\t\t}\n\t\t \n\t\tend = c - 1;\n\t}\n\n\tfor (int bucket = 0; bucket <= end; bucket++) {\n\t\tif (bucket < MIN_LAT_INDEX) {\n\t\t\t \n\t\t\tfor (int i = 0; lat_type[i].name; i++) {\n\t\t\t\tlat_type[i].sum += lat_type[i].array[bucket];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bucket < end) {\n\t\t\tprintf(\"%s%s,le=%0.6f,name=%s,%s \",\n\t\t\t    POOL_LATENCY_MEASUREMENT, tags,\n\t\t\t    (float)(1ULL << bucket) * 1e-9,\n\t\t\t    pool_name, vdev_desc);\n\t\t} else {\n\t\t\tprintf(\"%s%s,le=+Inf,name=%s,%s \",\n\t\t\t    POOL_LATENCY_MEASUREMENT, tags, pool_name,\n\t\t\t    vdev_desc);\n\t\t}\n\t\tfor (int i = 0; lat_type[i].name; i++) {\n\t\t\tif (bucket <= MIN_LAT_INDEX || sum_histogram_buckets) {\n\t\t\t\tlat_type[i].sum += lat_type[i].array[bucket];\n\t\t\t} else {\n\t\t\t\tlat_type[i].sum = lat_type[i].array[bucket];\n\t\t\t}\n\t\t\tprint_kv(lat_type[i].short_name, lat_type[i].sum);\n\t\t\tif (lat_type[i + 1].name != NULL) {\n\t\t\t\tprintf(\",\");\n\t\t\t}\n\t\t}\n\t\tprintf(\" %llu\\n\", (u_longlong_t)timestamp);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nprint_vdev_size_stats(nvlist_t *nvroot, const char *pool_name,\n    const char *parent_name)\n{\n\tuint_t c, end = 0;\n\tnvlist_t *nv_ex;\n\tchar *vdev_desc = NULL;\n\n\t \n\tstruct size_lookup {\n\t    const char *name;\n\t    const char *short_name;\n\t    uint64_t sum;\n\t    uint64_t *array;\n\t};\n\tstruct size_lookup size_type[] = {\n\t    {ZPOOL_CONFIG_VDEV_SYNC_IND_R_HISTO,   \"sync_read_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_IND_W_HISTO,   \"sync_write_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_IND_R_HISTO,  \"async_read_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_IND_W_HISTO,  \"async_write_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_IND_SCRUB_HISTO,    \"scrub_read_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_AGG_R_HISTO,   \"sync_read_agg\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_AGG_W_HISTO,   \"sync_write_agg\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_AGG_R_HISTO,  \"async_read_agg\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_AGG_W_HISTO,  \"async_write_agg\"},\n\t    {ZPOOL_CONFIG_VDEV_AGG_SCRUB_HISTO,    \"scrub_read_agg\"},\n#ifdef ZPOOL_CONFIG_VDEV_IND_TRIM_HISTO\n\t    {ZPOOL_CONFIG_VDEV_IND_TRIM_HISTO,    \"trim_write_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_AGG_TRIM_HISTO,    \"trim_write_agg\"},\n#endif\n\t    {ZPOOL_CONFIG_VDEV_IND_REBUILD_HISTO,    \"rebuild_write_ind\"},\n\t    {ZPOOL_CONFIG_VDEV_AGG_REBUILD_HISTO,    \"rebuild_write_agg\"},\n\t    {NULL,\tNULL}\n\t};\n\n\tif (nvlist_lookup_nvlist(nvroot,\n\t    ZPOOL_CONFIG_VDEV_STATS_EX, &nv_ex) != 0) {\n\t\treturn (6);\n\t}\n\n\tvdev_desc = get_vdev_desc(nvroot, parent_name);\n\n\tfor (int i = 0; size_type[i].name; i++) {\n\t\tif (nvlist_lookup_uint64_array(nv_ex, size_type[i].name,\n\t\t    &size_type[i].array, &c) != 0) {\n\t\t\tfprintf(stderr, \"error: can't get %s\\n\",\n\t\t\t    size_type[i].name);\n\t\t\treturn (3);\n\t\t}\n\t\t \n\t\tend = c - 1;\n\t}\n\n\tfor (int bucket = 0; bucket <= end; bucket++) {\n\t\tif (bucket < MIN_SIZE_INDEX) {\n\t\t\t \n\t\t\tfor (int i = 0; size_type[i].name; i++) {\n\t\t\t\tsize_type[i].sum += size_type[i].array[bucket];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bucket < end) {\n\t\t\tprintf(\"%s%s,le=%llu,name=%s,%s \",\n\t\t\t    POOL_IO_SIZE_MEASUREMENT, tags, 1ULL << bucket,\n\t\t\t    pool_name, vdev_desc);\n\t\t} else {\n\t\t\tprintf(\"%s%s,le=+Inf,name=%s,%s \",\n\t\t\t    POOL_IO_SIZE_MEASUREMENT, tags, pool_name,\n\t\t\t    vdev_desc);\n\t\t}\n\t\tfor (int i = 0; size_type[i].name; i++) {\n\t\t\tif (bucket <= MIN_SIZE_INDEX || sum_histogram_buckets) {\n\t\t\t\tsize_type[i].sum += size_type[i].array[bucket];\n\t\t\t} else {\n\t\t\t\tsize_type[i].sum = size_type[i].array[bucket];\n\t\t\t}\n\t\t\tprint_kv(size_type[i].short_name, size_type[i].sum);\n\t\t\tif (size_type[i + 1].name != NULL) {\n\t\t\t\tprintf(\",\");\n\t\t\t}\n\t\t}\n\t\tprintf(\" %llu\\n\", (u_longlong_t)timestamp);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nprint_queue_stats(nvlist_t *nvroot, const char *pool_name,\n    const char *parent_name)\n{\n\tnvlist_t *nv_ex;\n\tuint64_t value;\n\n\t \n\tstruct queue_lookup {\n\t    const char *name;\n\t    const char *short_name;\n\t};\n\tstruct queue_lookup queue_type[] = {\n\t    {ZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE,\t\"sync_r_active\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_W_ACTIVE_QUEUE,\t\"sync_w_active\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_R_ACTIVE_QUEUE,\t\"async_r_active\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_W_ACTIVE_QUEUE,\t\"async_w_active\"},\n\t    {ZPOOL_CONFIG_VDEV_SCRUB_ACTIVE_QUEUE,\t\"async_scrub_active\"},\n\t    {ZPOOL_CONFIG_VDEV_REBUILD_ACTIVE_QUEUE,\t\"rebuild_active\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_R_PEND_QUEUE,\t\"sync_r_pend\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_W_PEND_QUEUE,\t\"sync_w_pend\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_R_PEND_QUEUE,\t\"async_r_pend\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_W_PEND_QUEUE,\t\"async_w_pend\"},\n\t    {ZPOOL_CONFIG_VDEV_SCRUB_PEND_QUEUE,\t\"async_scrub_pend\"},\n\t    {ZPOOL_CONFIG_VDEV_REBUILD_PEND_QUEUE,\t\"rebuild_pend\"},\n\t    {NULL,\tNULL}\n\t};\n\n\tif (nvlist_lookup_nvlist(nvroot,\n\t    ZPOOL_CONFIG_VDEV_STATS_EX, &nv_ex) != 0) {\n\t\treturn (6);\n\t}\n\n\tprintf(\"%s%s,name=%s,%s \", POOL_QUEUE_MEASUREMENT, tags, pool_name,\n\t    get_vdev_desc(nvroot, parent_name));\n\tfor (int i = 0; queue_type[i].name; i++) {\n\t\tif (nvlist_lookup_uint64(nv_ex,\n\t\t    queue_type[i].name, &value) != 0) {\n\t\t\tfprintf(stderr, \"error: can't get %s\\n\",\n\t\t\t    queue_type[i].name);\n\t\t\treturn (3);\n\t\t}\n\t\tprint_kv(queue_type[i].short_name, value);\n\t\tif (queue_type[i + 1].name != NULL) {\n\t\t\tprintf(\",\");\n\t\t}\n\t}\n\tprintf(\" %llu\\n\", (u_longlong_t)timestamp);\n\treturn (0);\n}\n\n \nstatic int\nprint_top_level_vdev_stats(nvlist_t *nvroot, const char *pool_name)\n{\n\tnvlist_t *nv_ex;\n\tuint64_t value;\n\n\t \n\tstruct queue_lookup {\n\t    const char *name;\n\t    const char *short_name;\n\t};\n\tstruct queue_lookup queue_type[] = {\n\t    {ZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE, \"sync_r_active_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_W_ACTIVE_QUEUE, \"sync_w_active_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_R_ACTIVE_QUEUE, \"async_r_active_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_W_ACTIVE_QUEUE, \"async_w_active_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_SCRUB_ACTIVE_QUEUE, \"async_scrub_active_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_REBUILD_ACTIVE_QUEUE, \"rebuild_active_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_R_PEND_QUEUE, \"sync_r_pend_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_SYNC_W_PEND_QUEUE, \"sync_w_pend_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_R_PEND_QUEUE, \"async_r_pend_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_ASYNC_W_PEND_QUEUE, \"async_w_pend_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_SCRUB_PEND_QUEUE, \"async_scrub_pend_queue\"},\n\t    {ZPOOL_CONFIG_VDEV_REBUILD_PEND_QUEUE, \"rebuild_pend_queue\"},\n\t    {NULL, NULL}\n\t};\n\n\tif (nvlist_lookup_nvlist(nvroot,\n\t    ZPOOL_CONFIG_VDEV_STATS_EX, &nv_ex) != 0) {\n\t\treturn (6);\n\t}\n\n\tprintf(\"%s%s,name=%s,vdev=root \", VDEV_MEASUREMENT, tags,\n\t    pool_name);\n\tfor (int i = 0; queue_type[i].name; i++) {\n\t\tif (nvlist_lookup_uint64(nv_ex,\n\t\t    queue_type[i].name, &value) != 0) {\n\t\t\tfprintf(stderr, \"error: can't get %s\\n\",\n\t\t\t    queue_type[i].name);\n\t\t\treturn (3);\n\t\t}\n\t\tif (i > 0)\n\t\t\tprintf(\",\");\n\t\tprint_kv(queue_type[i].short_name, value);\n\t}\n\n\tprintf(\" %llu\\n\", (u_longlong_t)timestamp);\n\treturn (0);\n}\n\n \nstatic int\nprint_recursive_stats(stat_printer_f func, nvlist_t *nvroot,\n    const char *pool_name, const char *parent_name, int descend)\n{\n\tuint_t c, children;\n\tnvlist_t **child;\n\tchar vdev_name[256];\n\tint err;\n\n\terr = func(nvroot, pool_name, parent_name);\n\tif (err)\n\t\treturn (err);\n\n\tif (descend && nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) == 0) {\n\t\t(void) strlcpy(vdev_name, get_vdev_name(nvroot, parent_name),\n\t\t    sizeof (vdev_name));\n\n\t\tfor (c = 0; c < children; c++) {\n\t\t\terr = print_recursive_stats(func, child[c], pool_name,\n\t\t\t    vdev_name, descend);\n\t\t\tif (err)\n\t\t\t\treturn (err);\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nstatic int\nprint_stats(zpool_handle_t *zhp, void *data)\n{\n\tuint_t c;\n\tint err;\n\tboolean_t missing;\n\tnvlist_t *config, *nvroot;\n\tvdev_stat_t *vs;\n\tstruct timespec tv;\n\tchar *pool_name;\n\n\t \n\tif (data &&\n\t    strncmp(data, zpool_get_name(zhp), ZFS_MAX_DATASET_NAME_LEN) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (0);\n\t}\n\n\tif (zpool_refresh_stats(zhp, &missing) != 0) {\n\t\tzpool_close(zhp);\n\t\treturn (1);\n\t}\n\n\tconfig = zpool_get_config(zhp, NULL);\n\tif (clock_gettime(CLOCK_REALTIME, &tv) != 0)\n\t\ttimestamp = (uint64_t)time(NULL) * 1000000000;\n\telse\n\t\ttimestamp =\n\t\t    ((uint64_t)tv.tv_sec * 1000000000) + (uint64_t)tv.tv_nsec;\n\n\tif (nvlist_lookup_nvlist(\n\t    config, ZPOOL_CONFIG_VDEV_TREE, &nvroot) != 0) {\n\tzpool_close(zhp);\n\t\treturn (2);\n\t}\n\tif (nvlist_lookup_uint64_array(nvroot, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t **)&vs, &c) != 0) {\n\tzpool_close(zhp);\n\t\treturn (3);\n\t}\n\n\tpool_name = escape_string(zpool_get_name(zhp));\n\terr = print_recursive_stats(print_summary_stats, nvroot,\n\t    pool_name, NULL, 1);\n\t \n\tif (err == 0)\n\terr = print_top_level_vdev_stats(nvroot, pool_name);\n\n\tif (no_histograms == 0) {\n\tif (err == 0)\n\t\terr = print_recursive_stats(print_vdev_latency_stats, nvroot,\n\t\t    pool_name, NULL, 1);\n\tif (err == 0)\n\t\terr = print_recursive_stats(print_vdev_size_stats, nvroot,\n\t\t    pool_name, NULL, 1);\n\tif (err == 0)\n\t\terr = print_recursive_stats(print_queue_stats, nvroot,\n\t\t    pool_name, NULL, 0);\n\t}\n\tif (err == 0)\n\t\terr = print_scan_status(nvroot, pool_name);\n\n\tfree(pool_name);\n\tzpool_close(zhp);\n\treturn (err);\n}\n\nstatic void\nusage(char *name)\n{\n\tfprintf(stderr, \"usage: %s [--execd][--no-histograms]\"\n\t    \"[--sum-histogram-buckets] [--signed-int] [poolname]\\n\", name);\n\texit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tint opt;\n\tint ret = 8;\n\tchar *line = NULL, *ttags = NULL;\n\tsize_t len, tagslen = 0;\n\tstruct option long_options[] = {\n\t    {\"execd\", no_argument, NULL, 'e'},\n\t    {\"help\", no_argument, NULL, 'h'},\n\t    {\"no-histograms\", no_argument, NULL, 'n'},\n\t    {\"signed-int\", no_argument, NULL, 'i'},\n\t    {\"sum-histogram-buckets\", no_argument, NULL, 's'},\n\t    {\"tags\", required_argument, NULL, 't'},\n\t    {0, 0, 0, 0}\n\t};\n\twhile ((opt = getopt_long(\n\t    argc, argv, \"ehinst:\", long_options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'e':\n\t\t\texecd_mode = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmetric_data_type = 'i';\n\t\t\tmetric_value_mask = INT64_MAX;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tno_histograms = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsum_histogram_buckets = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tfree(ttags);\n\t\t\ttagslen = strlen(optarg) + 2;\n\t\t\tttags = calloc(1, tagslen);\n\t\t\tif (ttags == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"error: cannot allocate memory \"\n\t\t\t\t    \"for tags\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t(void) snprintf(ttags, tagslen, \",%s\", optarg);\n\t\t\ttags = ttags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tlibzfs_handle_t *g_zfs;\n\tif ((g_zfs = libzfs_init()) == NULL) {\n\t\tfprintf(stderr,\n\t\t    \"error: cannot initialize libzfs. \"\n\t\t    \"Is the zfs module loaded or zrepl running?\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (execd_mode == 0) {\n\t\tret = zpool_iter(g_zfs, print_stats, argv[optind]);\n\t\treturn (ret);\n\t}\n\twhile (getline(&line, &len, stdin) != -1) {\n\t\tret = zpool_iter(g_zfs, print_stats, argv[optind]);\n\t\tfflush(stdout);\n\t}\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}