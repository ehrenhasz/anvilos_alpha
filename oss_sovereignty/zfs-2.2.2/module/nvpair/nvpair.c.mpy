{
  "module_name": "nvpair.c",
  "hash_id": "2edf2a769b1b02e050e1c89b77c5c058ee8c9a95f0773f7de6eb826da04fe296",
  "original_prompt": "Ingested from zfs-2.2.2/module/nvpair/nvpair.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/debug.h>\n#include <sys/isa_defs.h>\n#include <sys/nvpair.h>\n#include <sys/nvpair_impl.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/string.h>\n#include <rpc/xdr.h>\n#include <sys/mod.h>\n\n#if defined(_KERNEL)\n#include <sys/sunddi.h>\n#include <sys/sysmacros.h>\n#else\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stddef.h>\n#endif\n\n#define\tskip_whitespace(p)\twhile ((*(p) == ' ') || (*(p) == '\\t')) (p)++\n\n \n#define\tNVP_SIZE_CALC(name_len, data_len) \\\n\t(NV_ALIGN((sizeof (nvpair_t)) + name_len) + NV_ALIGN(data_len))\n\nstatic int i_get_value_size(data_type_t type, const void *data, uint_t nelem);\nstatic int nvlist_add_common(nvlist_t *nvl, const char *name, data_type_t type,\n    uint_t nelem, const void *data);\n\n#define\tNV_STAT_EMBEDDED\t0x1\n#define\tEMBEDDED_NVL(nvp)\t((nvlist_t *)(void *)NVP_VALUE(nvp))\n#define\tEMBEDDED_NVL_ARRAY(nvp)\t((nvlist_t **)(void *)NVP_VALUE(nvp))\n\n#define\tNVP_VALOFF(nvp)\t(NV_ALIGN(sizeof (nvpair_t) + (nvp)->nvp_name_sz))\n#define\tNVPAIR2I_NVP(nvp) \\\n\t((i_nvp_t *)((size_t)(nvp) - offsetof(i_nvp_t, nvi_nvp)))\n\n#ifdef _KERNEL\nstatic const int nvpair_max_recursion = 20;\n#else\nstatic const int nvpair_max_recursion = 100;\n#endif\n\nstatic const uint64_t nvlist_hashtable_init_size = (1 << 4);\n\nint\nnv_alloc_init(nv_alloc_t *nva, const nv_alloc_ops_t *nvo,   ...)\n{\n\tva_list valist;\n\tint err = 0;\n\n\tnva->nva_ops = nvo;\n\tnva->nva_arg = NULL;\n\n\tva_start(valist, nvo);\n\tif (nva->nva_ops->nv_ao_init != NULL)\n\t\terr = nva->nva_ops->nv_ao_init(nva, valist);\n\tva_end(valist);\n\n\treturn (err);\n}\n\nvoid\nnv_alloc_reset(nv_alloc_t *nva)\n{\n\tif (nva->nva_ops->nv_ao_reset != NULL)\n\t\tnva->nva_ops->nv_ao_reset(nva);\n}\n\nvoid\nnv_alloc_fini(nv_alloc_t *nva)\n{\n\tif (nva->nva_ops->nv_ao_fini != NULL)\n\t\tnva->nva_ops->nv_ao_fini(nva);\n}\n\nnv_alloc_t *\nnvlist_lookup_nv_alloc(nvlist_t *nvl)\n{\n\tnvpriv_t *priv;\n\n\tif (nvl == NULL ||\n\t    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn (NULL);\n\n\treturn (priv->nvp_nva);\n}\n\nstatic void *\nnv_mem_zalloc(nvpriv_t *nvp, size_t size)\n{\n\tnv_alloc_t *nva = nvp->nvp_nva;\n\tvoid *buf;\n\n\tif ((buf = nva->nva_ops->nv_ao_alloc(nva, size)) != NULL)\n\t\tmemset(buf, 0, size);\n\n\treturn (buf);\n}\n\nstatic void\nnv_mem_free(nvpriv_t *nvp, void *buf, size_t size)\n{\n\tnv_alloc_t *nva = nvp->nvp_nva;\n\n\tnva->nva_ops->nv_ao_free(nva, buf, size);\n}\n\nstatic void\nnv_priv_init(nvpriv_t *priv, nv_alloc_t *nva, uint32_t stat)\n{\n\tmemset(priv, 0, sizeof (nvpriv_t));\n\n\tpriv->nvp_nva = nva;\n\tpriv->nvp_stat = stat;\n}\n\nstatic nvpriv_t *\nnv_priv_alloc(nv_alloc_t *nva)\n{\n\tnvpriv_t *priv;\n\n\t \n\tif ((priv = nva->nva_ops->nv_ao_alloc(nva, sizeof (nvpriv_t))) == NULL)\n\t\treturn (NULL);\n\n\tnv_priv_init(priv, nva, 0);\n\n\treturn (priv);\n}\n\n \nstatic nvpriv_t *\nnv_priv_alloc_embedded(nvpriv_t *priv)\n{\n\tnvpriv_t *emb_priv;\n\n\tif ((emb_priv = nv_mem_zalloc(priv, sizeof (nvpriv_t))) == NULL)\n\t\treturn (NULL);\n\n\tnv_priv_init(emb_priv, priv->nvp_nva, NV_STAT_EMBEDDED);\n\n\treturn (emb_priv);\n}\n\nstatic int\nnvt_tab_alloc(nvpriv_t *priv, uint64_t buckets)\n{\n\tASSERT3P(priv->nvp_hashtable, ==, NULL);\n\tASSERT0(priv->nvp_nbuckets);\n\tASSERT0(priv->nvp_nentries);\n\n\ti_nvp_t **tab = nv_mem_zalloc(priv, buckets * sizeof (i_nvp_t *));\n\tif (tab == NULL)\n\t\treturn (ENOMEM);\n\n\tpriv->nvp_hashtable = tab;\n\tpriv->nvp_nbuckets = buckets;\n\treturn (0);\n}\n\nstatic void\nnvt_tab_free(nvpriv_t *priv)\n{\n\ti_nvp_t **tab = priv->nvp_hashtable;\n\tif (tab == NULL) {\n\t\tASSERT0(priv->nvp_nbuckets);\n\t\tASSERT0(priv->nvp_nentries);\n\t\treturn;\n\t}\n\n\tnv_mem_free(priv, tab, priv->nvp_nbuckets * sizeof (i_nvp_t *));\n\n\tpriv->nvp_hashtable = NULL;\n\tpriv->nvp_nbuckets = 0;\n\tpriv->nvp_nentries = 0;\n}\n\nstatic uint32_t\nnvt_hash(const char *p)\n{\n\tuint32_t g, hval = 0;\n\n\twhile (*p) {\n\t\thval = (hval << 4) + *p++;\n\t\tif ((g = (hval & 0xf0000000)) != 0)\n\t\t\thval ^= g >> 24;\n\t\thval &= ~g;\n\t}\n\treturn (hval);\n}\n\nstatic boolean_t\nnvt_nvpair_match(const nvpair_t *nvp1, const nvpair_t *nvp2, uint32_t nvflag)\n{\n\tboolean_t match = B_FALSE;\n\tif (nvflag & NV_UNIQUE_NAME_TYPE) {\n\t\tif (strcmp(NVP_NAME(nvp1), NVP_NAME(nvp2)) == 0 &&\n\t\t    NVP_TYPE(nvp1) == NVP_TYPE(nvp2))\n\t\t\tmatch = B_TRUE;\n\t} else {\n\t\tASSERT(nvflag == 0 || nvflag & NV_UNIQUE_NAME);\n\t\tif (strcmp(NVP_NAME(nvp1), NVP_NAME(nvp2)) == 0)\n\t\t\tmatch = B_TRUE;\n\t}\n\treturn (match);\n}\n\nstatic nvpair_t *\nnvt_lookup_name_type(const nvlist_t *nvl, const char *name, data_type_t type)\n{\n\tconst nvpriv_t *priv = (const nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\tASSERT(priv != NULL);\n\n\ti_nvp_t **tab = priv->nvp_hashtable;\n\n\tif (tab == NULL) {\n\t\tASSERT3P(priv->nvp_list, ==, NULL);\n\t\tASSERT0(priv->nvp_nbuckets);\n\t\tASSERT0(priv->nvp_nentries);\n\t\treturn (NULL);\n\t} else {\n\t\tASSERT(priv->nvp_nbuckets != 0);\n\t}\n\n\tuint64_t hash = nvt_hash(name);\n\tuint64_t index = hash & (priv->nvp_nbuckets - 1);\n\n\tASSERT3U(index, <, priv->nvp_nbuckets);\n\ti_nvp_t *entry = tab[index];\n\n\tfor (i_nvp_t *e = entry; e != NULL; e = e->nvi_hashtable_next) {\n\t\tif (strcmp(NVP_NAME(&e->nvi_nvp), name) == 0 &&\n\t\t    (type == DATA_TYPE_DONTCARE ||\n\t\t    NVP_TYPE(&e->nvi_nvp) == type))\n\t\t\treturn (&e->nvi_nvp);\n\t}\n\treturn (NULL);\n}\n\nstatic nvpair_t *\nnvt_lookup_name(const nvlist_t *nvl, const char *name)\n{\n\treturn (nvt_lookup_name_type(nvl, name, DATA_TYPE_DONTCARE));\n}\n\nstatic int\nnvt_resize(nvpriv_t *priv, uint32_t new_size)\n{\n\ti_nvp_t **tab = priv->nvp_hashtable;\n\n\t \n\tuint32_t size = priv->nvp_nbuckets;\n\tuint32_t new_mask = new_size - 1;\n\tASSERT(ISP2(new_size));\n\n\ti_nvp_t **new_tab = nv_mem_zalloc(priv, new_size * sizeof (i_nvp_t *));\n\tif (new_tab == NULL)\n\t\treturn (ENOMEM);\n\n\tuint32_t nentries = 0;\n\tfor (uint32_t i = 0; i < size; i++) {\n\t\ti_nvp_t *next, *e = tab[i];\n\n\t\twhile (e != NULL) {\n\t\t\tnext = e->nvi_hashtable_next;\n\n\t\t\tuint32_t hash = nvt_hash(NVP_NAME(&e->nvi_nvp));\n\t\t\tuint32_t index = hash & new_mask;\n\n\t\t\te->nvi_hashtable_next = new_tab[index];\n\t\t\tnew_tab[index] = e;\n\t\t\tnentries++;\n\n\t\t\te = next;\n\t\t}\n\t\ttab[i] = NULL;\n\t}\n\tASSERT3U(nentries, ==, priv->nvp_nentries);\n\n\tnvt_tab_free(priv);\n\n\tpriv->nvp_hashtable = new_tab;\n\tpriv->nvp_nbuckets = new_size;\n\tpriv->nvp_nentries = nentries;\n\n\treturn (0);\n}\n\nstatic boolean_t\nnvt_needs_togrow(nvpriv_t *priv)\n{\n\t \n\treturn (priv->nvp_nentries > priv->nvp_nbuckets &&\n\t    (UINT32_MAX >> 1) >= priv->nvp_nbuckets);\n}\n\n \nstatic int\nnvt_grow(nvpriv_t *priv)\n{\n\tuint32_t current_size = priv->nvp_nbuckets;\n\t \n\tASSERT3U(UINT32_MAX >> 1, >=, current_size);\n\treturn (nvt_resize(priv, current_size << 1));\n}\n\nstatic boolean_t\nnvt_needs_toshrink(nvpriv_t *priv)\n{\n\t \n\tASSERT3U(priv->nvp_nbuckets, >=, nvlist_hashtable_init_size);\n\tif (priv->nvp_nbuckets == nvlist_hashtable_init_size)\n\t\treturn (B_FALSE);\n\treturn (priv->nvp_nentries <= (priv->nvp_nbuckets >> 2));\n}\n\n \nstatic int\nnvt_shrink(nvpriv_t *priv)\n{\n\tuint32_t current_size = priv->nvp_nbuckets;\n\t \n\tASSERT3U(current_size, >=, nvlist_hashtable_init_size);\n\treturn (nvt_resize(priv, current_size >> 1));\n}\n\nstatic int\nnvt_remove_nvpair(nvlist_t *nvl, const nvpair_t *nvp)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\n\tif (nvt_needs_toshrink(priv)) {\n\t\tint err = nvt_shrink(priv);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\ti_nvp_t **tab = priv->nvp_hashtable;\n\n\tconst char *name = NVP_NAME(nvp);\n\tuint64_t hash = nvt_hash(name);\n\tuint64_t index = hash & (priv->nvp_nbuckets - 1);\n\n\tASSERT3U(index, <, priv->nvp_nbuckets);\n\ti_nvp_t *bucket = tab[index];\n\n\tfor (i_nvp_t *prev = NULL, *e = bucket;\n\t    e != NULL; prev = e, e = e->nvi_hashtable_next) {\n\t\tif (nvt_nvpair_match(&e->nvi_nvp, nvp, nvl->nvl_nvflag)) {\n\t\t\tif (prev != NULL) {\n\t\t\t\tprev->nvi_hashtable_next =\n\t\t\t\t    e->nvi_hashtable_next;\n\t\t\t} else {\n\t\t\t\tASSERT3P(e, ==, bucket);\n\t\t\t\ttab[index] = e->nvi_hashtable_next;\n\t\t\t}\n\t\t\te->nvi_hashtable_next = NULL;\n\t\t\tpriv->nvp_nentries--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic int\nnvt_add_nvpair(nvlist_t *nvl, nvpair_t *nvp)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\n\t \n\tif (priv->nvp_hashtable == NULL) {\n\t\tint err = nvt_tab_alloc(priv, nvlist_hashtable_init_size);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\t \n\tif (nvl->nvl_nvflag != 0) {\n\t\tint err = nvt_remove_nvpair(nvl, nvp);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\tif (nvt_needs_togrow(priv)) {\n\t\tint err = nvt_grow(priv);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\ti_nvp_t **tab = priv->nvp_hashtable;\n\n\tconst char *name = NVP_NAME(nvp);\n\tuint64_t hash = nvt_hash(name);\n\tuint64_t index = hash & (priv->nvp_nbuckets - 1);\n\n\tASSERT3U(index, <, priv->nvp_nbuckets);\n\t \n\ti_nvp_t *bucket = tab[index];\n\n\t \n\ti_nvp_t *new_entry = NVPAIR2I_NVP(nvp);\n\tASSERT3P(new_entry->nvi_hashtable_next, ==, NULL);\n\tnew_entry->nvi_hashtable_next = bucket;\n\t \n\ttab[index] = new_entry;\n\n\tpriv->nvp_nentries++;\n\treturn (0);\n}\n\nstatic void\nnvlist_init(nvlist_t *nvl, uint32_t nvflag, nvpriv_t *priv)\n{\n\tnvl->nvl_version = NV_VERSION;\n\tnvl->nvl_nvflag = nvflag & (NV_UNIQUE_NAME|NV_UNIQUE_NAME_TYPE);\n\tnvl->nvl_priv = (uint64_t)(uintptr_t)priv;\n\tnvl->nvl_flag = 0;\n\tnvl->nvl_pad = 0;\n}\n\nuint_t\nnvlist_nvflag(nvlist_t *nvl)\n{\n\treturn (nvl->nvl_nvflag);\n}\n\nstatic nv_alloc_t *\nnvlist_nv_alloc(int kmflag)\n{\n#if defined(_KERNEL)\n\tswitch (kmflag) {\n\tcase KM_SLEEP:\n\t\treturn (nv_alloc_sleep);\n\tcase KM_NOSLEEP:\n\t\treturn (nv_alloc_nosleep);\n\tdefault:\n\t\treturn (nv_alloc_pushpage);\n\t}\n#else\n\t(void) kmflag;\n\treturn (nv_alloc_nosleep);\n#endif  \n}\n\n \nint\nnvlist_alloc(nvlist_t **nvlp, uint_t nvflag, int kmflag)\n{\n\treturn (nvlist_xalloc(nvlp, nvflag, nvlist_nv_alloc(kmflag)));\n}\n\nint\nnvlist_xalloc(nvlist_t **nvlp, uint_t nvflag, nv_alloc_t *nva)\n{\n\tnvpriv_t *priv;\n\n\tif (nvlp == NULL || nva == NULL)\n\t\treturn (EINVAL);\n\n\tif ((priv = nv_priv_alloc(nva)) == NULL)\n\t\treturn (ENOMEM);\n\n\tif ((*nvlp = nv_mem_zalloc(priv,\n\t    NV_ALIGN(sizeof (nvlist_t)))) == NULL) {\n\t\tnv_mem_free(priv, priv, sizeof (nvpriv_t));\n\t\treturn (ENOMEM);\n\t}\n\n\tnvlist_init(*nvlp, nvflag, priv);\n\n\treturn (0);\n}\n\n \nstatic nvpair_t *\nnvp_buf_alloc(nvlist_t *nvl, size_t len)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\ti_nvp_t *buf;\n\tnvpair_t *nvp;\n\tsize_t nvsize;\n\n\t \n\tnvsize = len + offsetof(i_nvp_t, nvi_nvp);\n\n\tif ((buf = nv_mem_zalloc(priv, nvsize)) == NULL)\n\t\treturn (NULL);\n\n\tnvp = &buf->nvi_nvp;\n\tnvp->nvp_size = len;\n\n\treturn (nvp);\n}\n\n \nstatic void\nnvp_buf_free(nvlist_t *nvl, nvpair_t *nvp)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\tsize_t nvsize = nvp->nvp_size + offsetof(i_nvp_t, nvi_nvp);\n\n\tnv_mem_free(priv, NVPAIR2I_NVP(nvp), nvsize);\n}\n\n \nstatic void\nnvp_buf_link(nvlist_t *nvl, nvpair_t *nvp)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\ti_nvp_t *curr = NVPAIR2I_NVP(nvp);\n\n\t \n\tif (priv->nvp_list == NULL) {\n\t\tpriv->nvp_list = priv->nvp_last = curr;\n\t} else {\n\t\tcurr->nvi_prev = priv->nvp_last;\n\t\tpriv->nvp_last->nvi_next = curr;\n\t\tpriv->nvp_last = curr;\n\t}\n}\n\n \nstatic void\nnvp_buf_unlink(nvlist_t *nvl, nvpair_t *nvp)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\ti_nvp_t *curr = NVPAIR2I_NVP(nvp);\n\n\t \n\tif (priv->nvp_curr == curr)\n\t\tpriv->nvp_curr = curr->nvi_next;\n\n\tif (curr == priv->nvp_list)\n\t\tpriv->nvp_list = curr->nvi_next;\n\telse\n\t\tcurr->nvi_prev->nvi_next = curr->nvi_next;\n\n\tif (curr == priv->nvp_last)\n\t\tpriv->nvp_last = curr->nvi_prev;\n\telse\n\t\tcurr->nvi_next->nvi_prev = curr->nvi_prev;\n}\n\n \nstatic int\ni_validate_type_nelem(data_type_t type, uint_t nelem)\n{\n\tswitch (type) {\n\tcase DATA_TYPE_BOOLEAN:\n\t\tif (nelem != 0)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\tcase DATA_TYPE_BYTE:\n\tcase DATA_TYPE_INT8:\n\tcase DATA_TYPE_UINT8:\n\tcase DATA_TYPE_INT16:\n\tcase DATA_TYPE_UINT16:\n\tcase DATA_TYPE_INT32:\n\tcase DATA_TYPE_UINT32:\n\tcase DATA_TYPE_INT64:\n\tcase DATA_TYPE_UINT64:\n\tcase DATA_TYPE_STRING:\n\tcase DATA_TYPE_HRTIME:\n\tcase DATA_TYPE_NVLIST:\n#if !defined(_KERNEL)\n\tcase DATA_TYPE_DOUBLE:\n#endif\n\t\tif (nelem != 1)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\tcase DATA_TYPE_BYTE_ARRAY:\n\tcase DATA_TYPE_INT8_ARRAY:\n\tcase DATA_TYPE_UINT8_ARRAY:\n\tcase DATA_TYPE_INT16_ARRAY:\n\tcase DATA_TYPE_UINT16_ARRAY:\n\tcase DATA_TYPE_INT32_ARRAY:\n\tcase DATA_TYPE_UINT32_ARRAY:\n\tcase DATA_TYPE_INT64_ARRAY:\n\tcase DATA_TYPE_UINT64_ARRAY:\n\tcase DATA_TYPE_STRING_ARRAY:\n\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}\n\n \nstatic int\ni_validate_nvpair_name(nvpair_t *nvp)\n{\n\tif ((nvp->nvp_name_sz <= 0) ||\n\t    (nvp->nvp_size < NVP_SIZE_CALC(nvp->nvp_name_sz, 0)))\n\t\treturn (EFAULT);\n\n\t \n\tif (NVP_NAME(nvp)[nvp->nvp_name_sz - 1] != '\\0')\n\t\treturn (EFAULT);\n\n\treturn (strlen(NVP_NAME(nvp)) == nvp->nvp_name_sz - 1 ? 0 : EFAULT);\n}\n\nstatic int\ni_validate_nvpair_value(data_type_t type, uint_t nelem, const void *data)\n{\n\tswitch (type) {\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\tif (*(boolean_t *)data != B_TRUE &&\n\t\t    *(boolean_t *)data != B_FALSE)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase DATA_TYPE_BOOLEAN_ARRAY: {\n\t\tint i;\n\n\t\tfor (i = 0; i < nelem; i++)\n\t\t\tif (((boolean_t *)data)[i] != B_TRUE &&\n\t\t\t    ((boolean_t *)data)[i] != B_FALSE)\n\t\t\t\treturn (EINVAL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\ni_validate_nvpair(nvpair_t *nvp)\n{\n\tdata_type_t type = NVP_TYPE(nvp);\n\tint size1, size2;\n\n\t \n\tif (i_validate_nvpair_name(nvp) != 0)\n\t\treturn (EFAULT);\n\n\tif (i_validate_nvpair_value(type, NVP_NELEM(nvp), NVP_VALUE(nvp)) != 0)\n\t\treturn (EFAULT);\n\n\t \n\tsize2 = i_get_value_size(type, NVP_VALUE(nvp), NVP_NELEM(nvp));\n\tsize1 = nvp->nvp_size - NVP_VALOFF(nvp);\n\tif (size2 < 0 || size1 != NV_ALIGN(size2))\n\t\treturn (EFAULT);\n\n\treturn (0);\n}\n\nstatic int\nnvlist_copy_pairs(const nvlist_t *snvl, nvlist_t *dnvl)\n{\n\tconst nvpriv_t *priv;\n\tconst i_nvp_t *curr;\n\n\tif ((priv = (const nvpriv_t *)(uintptr_t)snvl->nvl_priv) == NULL)\n\t\treturn (EINVAL);\n\n\tfor (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {\n\t\tconst nvpair_t *nvp = &curr->nvi_nvp;\n\t\tint err;\n\n\t\tif ((err = nvlist_add_common(dnvl, NVP_NAME(nvp), NVP_TYPE(nvp),\n\t\t    NVP_NELEM(nvp), NVP_VALUE(nvp))) != 0)\n\t\t\treturn (err);\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nnvpair_free(nvpair_t *nvp)\n{\n\tswitch (NVP_TYPE(nvp)) {\n\tcase DATA_TYPE_NVLIST:\n\t\tnvlist_free(EMBEDDED_NVL(nvp));\n\t\tbreak;\n\tcase DATA_TYPE_NVLIST_ARRAY: {\n\t\tnvlist_t **nvlp = EMBEDDED_NVL_ARRAY(nvp);\n\t\tint i;\n\n\t\tfor (i = 0; i < NVP_NELEM(nvp); i++)\n\t\t\tif (nvlp[i] != NULL)\n\t\t\t\tnvlist_free(nvlp[i]);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid\nnvlist_free(nvlist_t *nvl)\n{\n\tnvpriv_t *priv;\n\ti_nvp_t *curr;\n\n\tif (nvl == NULL ||\n\t    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn;\n\n\t \n\tcurr = priv->nvp_list;\n\twhile (curr != NULL) {\n\t\tnvpair_t *nvp = &curr->nvi_nvp;\n\t\tcurr = curr->nvi_next;\n\n\t\tnvpair_free(nvp);\n\t\tnvp_buf_free(nvl, nvp);\n\t}\n\n\tif (!(priv->nvp_stat & NV_STAT_EMBEDDED))\n\t\tnv_mem_free(priv, nvl, NV_ALIGN(sizeof (nvlist_t)));\n\telse\n\t\tnvl->nvl_priv = 0;\n\n\tnvt_tab_free(priv);\n\tnv_mem_free(priv, priv, sizeof (nvpriv_t));\n}\n\nstatic int\nnvlist_contains_nvp(const nvlist_t *nvl, const nvpair_t *nvp)\n{\n\tconst nvpriv_t *priv = (const nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\tconst i_nvp_t *curr;\n\n\tif (nvp == NULL)\n\t\treturn (0);\n\n\tfor (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next)\n\t\tif (&curr->nvi_nvp == nvp)\n\t\t\treturn (1);\n\n\treturn (0);\n}\n\n \nint\nnvlist_dup(const nvlist_t *nvl, nvlist_t **nvlp, int kmflag)\n{\n\treturn (nvlist_xdup(nvl, nvlp, nvlist_nv_alloc(kmflag)));\n}\n\nint\nnvlist_xdup(const nvlist_t *nvl, nvlist_t **nvlp, nv_alloc_t *nva)\n{\n\tint err;\n\tnvlist_t *ret;\n\n\tif (nvl == NULL || nvlp == NULL)\n\t\treturn (EINVAL);\n\n\tif ((err = nvlist_xalloc(&ret, nvl->nvl_nvflag, nva)) != 0)\n\t\treturn (err);\n\n\tif ((err = nvlist_copy_pairs(nvl, ret)) != 0)\n\t\tnvlist_free(ret);\n\telse\n\t\t*nvlp = ret;\n\n\treturn (err);\n}\n\n \nint\nnvlist_remove_all(nvlist_t *nvl, const char *name)\n{\n\tint error = ENOENT;\n\n\tif (nvl == NULL || name == NULL || nvl->nvl_priv == 0)\n\t\treturn (EINVAL);\n\n\tnvpair_t *nvp;\n\twhile ((nvp = nvt_lookup_name(nvl, name)) != NULL) {\n\t\tVERIFY0(nvlist_remove_nvpair(nvl, nvp));\n\t\terror = 0;\n\t}\n\n\treturn (error);\n}\n\n \nint\nnvlist_remove(nvlist_t *nvl, const char *name, data_type_t type)\n{\n\tif (nvl == NULL || name == NULL || nvl->nvl_priv == 0)\n\t\treturn (EINVAL);\n\n\tnvpair_t *nvp = nvt_lookup_name_type(nvl, name, type);\n\tif (nvp == NULL)\n\t\treturn (ENOENT);\n\n\treturn (nvlist_remove_nvpair(nvl, nvp));\n}\n\nint\nnvlist_remove_nvpair(nvlist_t *nvl, nvpair_t *nvp)\n{\n\tif (nvl == NULL || nvp == NULL)\n\t\treturn (EINVAL);\n\n\tint err = nvt_remove_nvpair(nvl, nvp);\n\tif (err != 0)\n\t\treturn (err);\n\n\tnvp_buf_unlink(nvl, nvp);\n\tnvpair_free(nvp);\n\tnvp_buf_free(nvl, nvp);\n\treturn (0);\n}\n\n \nstatic int\ni_get_value_size(data_type_t type, const void *data, uint_t nelem)\n{\n\tuint64_t value_sz;\n\n\tif (i_validate_type_nelem(type, nelem) != 0)\n\t\treturn (-1);\n\n\t \n\tswitch (type) {\n\tcase DATA_TYPE_BOOLEAN:\n\t\tvalue_sz = 0;\n\t\tbreak;\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\tvalue_sz = sizeof (boolean_t);\n\t\tbreak;\n\tcase DATA_TYPE_BYTE:\n\t\tvalue_sz = sizeof (uchar_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT8:\n\t\tvalue_sz = sizeof (int8_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT8:\n\t\tvalue_sz = sizeof (uint8_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT16:\n\t\tvalue_sz = sizeof (int16_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT16:\n\t\tvalue_sz = sizeof (uint16_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT32:\n\t\tvalue_sz = sizeof (int32_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT32:\n\t\tvalue_sz = sizeof (uint32_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT64:\n\t\tvalue_sz = sizeof (int64_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT64:\n\t\tvalue_sz = sizeof (uint64_t);\n\t\tbreak;\n#if !defined(_KERNEL)\n\tcase DATA_TYPE_DOUBLE:\n\t\tvalue_sz = sizeof (double);\n\t\tbreak;\n#endif\n\tcase DATA_TYPE_STRING:\n\t\tif (data == NULL)\n\t\t\tvalue_sz = 0;\n\t\telse\n\t\t\tvalue_sz = strlen(data) + 1;\n\t\tbreak;\n\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (boolean_t);\n\t\tbreak;\n\tcase DATA_TYPE_BYTE_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uchar_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT8_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (int8_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT8_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uint8_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT16_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (int16_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT16_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uint16_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT32_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (int32_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT32_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uint32_t);\n\t\tbreak;\n\tcase DATA_TYPE_INT64_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (int64_t);\n\t\tbreak;\n\tcase DATA_TYPE_UINT64_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uint64_t);\n\t\tbreak;\n\tcase DATA_TYPE_STRING_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uint64_t);\n\n\t\tif (data != NULL) {\n\t\t\tchar *const *strs = data;\n\t\t\tuint_t i;\n\n\t\t\t \n\t\t\tfor (i = 0; i < nelem; i++) {\n\t\t\t\tif (strs[i] == NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t\tvalue_sz += strlen(strs[i]) + 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DATA_TYPE_HRTIME:\n\t\tvalue_sz = sizeof (hrtime_t);\n\t\tbreak;\n\tcase DATA_TYPE_NVLIST:\n\t\tvalue_sz = NV_ALIGN(sizeof (nvlist_t));\n\t\tbreak;\n\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\tvalue_sz = (uint64_t)nelem * sizeof (uint64_t) +\n\t\t    (uint64_t)nelem * NV_ALIGN(sizeof (nvlist_t));\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\treturn (value_sz > INT32_MAX ? -1 : (int)value_sz);\n}\n\nstatic int\nnvlist_copy_embedded(nvlist_t *nvl, nvlist_t *onvl, nvlist_t *emb_nvl)\n{\n\tnvpriv_t *priv;\n\tint err;\n\n\tif ((priv = nv_priv_alloc_embedded((nvpriv_t *)(uintptr_t)\n\t    nvl->nvl_priv)) == NULL)\n\t\treturn (ENOMEM);\n\n\tnvlist_init(emb_nvl, onvl->nvl_nvflag, priv);\n\n\tif ((err = nvlist_copy_pairs(onvl, emb_nvl)) != 0) {\n\t\tnvlist_free(emb_nvl);\n\t\temb_nvl->nvl_priv = 0;\n\t}\n\n\treturn (err);\n}\n\n \nstatic int\nnvlist_add_common(nvlist_t *nvl, const char *name,\n    data_type_t type, uint_t nelem, const void *data)\n{\n\tnvpair_t *nvp;\n\tuint_t i;\n\n\tint nvp_sz, name_sz, value_sz;\n\tint err = 0;\n\n\tif (name == NULL || nvl == NULL || nvl->nvl_priv == 0)\n\t\treturn (EINVAL);\n\n\tif (nelem != 0 && data == NULL)\n\t\treturn (EINVAL);\n\n\t \n\tif ((value_sz = i_get_value_size(type, data, nelem)) < 0)\n\t\treturn (EINVAL);\n\n\tif (i_validate_nvpair_value(type, nelem, data) != 0)\n\t\treturn (EINVAL);\n\n\t \n\tswitch (type) {\n\tcase DATA_TYPE_NVLIST:\n\t\tif (data == nvl || data == NULL)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase DATA_TYPE_NVLIST_ARRAY: {\n\t\tnvlist_t **onvlp = (nvlist_t **)data;\n\t\tfor (i = 0; i < nelem; i++) {\n\t\t\tif (onvlp[i] == nvl || onvlp[i] == NULL)\n\t\t\t\treturn (EINVAL);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tname_sz = strlen(name) + 1;\n\tif (name_sz >= 1ULL << (sizeof (nvp->nvp_name_sz) * NBBY - 1))\n\t\treturn (EINVAL);\n\n\tnvp_sz = NVP_SIZE_CALC(name_sz, value_sz);\n\n\tif ((nvp = nvp_buf_alloc(nvl, nvp_sz)) == NULL)\n\t\treturn (ENOMEM);\n\n\tASSERT(nvp->nvp_size == nvp_sz);\n\tnvp->nvp_name_sz = name_sz;\n\tnvp->nvp_value_elem = nelem;\n\tnvp->nvp_type = type;\n\tmemcpy(NVP_NAME(nvp), name, name_sz);\n\n\tswitch (type) {\n\tcase DATA_TYPE_BOOLEAN:\n\t\tbreak;\n\tcase DATA_TYPE_STRING_ARRAY: {\n\t\tchar *const *strs = data;\n\t\tchar *buf = NVP_VALUE(nvp);\n\t\tchar **cstrs = (void *)buf;\n\n\t\t \n\t\tbuf += nelem * sizeof (uint64_t);\n\t\tfor (i = 0; i < nelem; i++) {\n\t\t\tint slen = strlen(strs[i]) + 1;\n\t\t\tmemcpy(buf, strs[i], slen);\n\t\t\tcstrs[i] = buf;\n\t\t\tbuf += slen;\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_TYPE_NVLIST: {\n\t\tnvlist_t *nnvl = EMBEDDED_NVL(nvp);\n\t\tnvlist_t *onvl = (nvlist_t *)data;\n\n\t\tif ((err = nvlist_copy_embedded(nvl, onvl, nnvl)) != 0) {\n\t\t\tnvp_buf_free(nvl, nvp);\n\t\t\treturn (err);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_TYPE_NVLIST_ARRAY: {\n\t\tnvlist_t **onvlp = (nvlist_t **)data;\n\t\tnvlist_t **nvlp = EMBEDDED_NVL_ARRAY(nvp);\n\t\tnvlist_t *embedded = (nvlist_t *)\n\t\t    ((uintptr_t)nvlp + nelem * sizeof (uint64_t));\n\n\t\tfor (i = 0; i < nelem; i++) {\n\t\t\tif ((err = nvlist_copy_embedded(nvl,\n\t\t\t    onvlp[i], embedded)) != 0) {\n\t\t\t\t \n\t\t\t\tnvpair_free(nvp);\n\t\t\t\tnvp_buf_free(nvl, nvp);\n\t\t\t\treturn (err);\n\t\t\t}\n\n\t\t\tnvlp[i] = embedded++;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tmemcpy(NVP_VALUE(nvp), data, value_sz);\n\t}\n\n\t \n\tif (nvl->nvl_nvflag & NV_UNIQUE_NAME)\n\t\t(void) nvlist_remove_all(nvl, name);\n\telse if (nvl->nvl_nvflag & NV_UNIQUE_NAME_TYPE)\n\t\t(void) nvlist_remove(nvl, name, type);\n\n\terr = nvt_add_nvpair(nvl, nvp);\n\tif (err != 0) {\n\t\tnvpair_free(nvp);\n\t\tnvp_buf_free(nvl, nvp);\n\t\treturn (err);\n\t}\n\tnvp_buf_link(nvl, nvp);\n\n\treturn (0);\n}\n\nint\nnvlist_add_boolean(nvlist_t *nvl, const char *name)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_BOOLEAN, 0, NULL));\n}\n\nint\nnvlist_add_boolean_value(nvlist_t *nvl, const char *name, boolean_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_BOOLEAN_VALUE, 1, &val));\n}\n\nint\nnvlist_add_byte(nvlist_t *nvl, const char *name, uchar_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_BYTE, 1, &val));\n}\n\nint\nnvlist_add_int8(nvlist_t *nvl, const char *name, int8_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT8, 1, &val));\n}\n\nint\nnvlist_add_uint8(nvlist_t *nvl, const char *name, uint8_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT8, 1, &val));\n}\n\nint\nnvlist_add_int16(nvlist_t *nvl, const char *name, int16_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT16, 1, &val));\n}\n\nint\nnvlist_add_uint16(nvlist_t *nvl, const char *name, uint16_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT16, 1, &val));\n}\n\nint\nnvlist_add_int32(nvlist_t *nvl, const char *name, int32_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT32, 1, &val));\n}\n\nint\nnvlist_add_uint32(nvlist_t *nvl, const char *name, uint32_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT32, 1, &val));\n}\n\nint\nnvlist_add_int64(nvlist_t *nvl, const char *name, int64_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT64, 1, &val));\n}\n\nint\nnvlist_add_uint64(nvlist_t *nvl, const char *name, uint64_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT64, 1, &val));\n}\n\n#if !defined(_KERNEL)\nint\nnvlist_add_double(nvlist_t *nvl, const char *name, double val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_DOUBLE, 1, &val));\n}\n#endif\n\nint\nnvlist_add_string(nvlist_t *nvl, const char *name, const char *val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_STRING, 1, (void *)val));\n}\n\nint\nnvlist_add_boolean_array(nvlist_t *nvl, const char *name,\n    const boolean_t *a, uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_BOOLEAN_ARRAY, n, a));\n}\n\nint\nnvlist_add_byte_array(nvlist_t *nvl, const char *name, const uchar_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_BYTE_ARRAY, n, a));\n}\n\nint\nnvlist_add_int8_array(nvlist_t *nvl, const char *name, const int8_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT8_ARRAY, n, a));\n}\n\nint\nnvlist_add_uint8_array(nvlist_t *nvl, const char *name, const uint8_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT8_ARRAY, n, a));\n}\n\nint\nnvlist_add_int16_array(nvlist_t *nvl, const char *name, const int16_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT16_ARRAY, n, a));\n}\n\nint\nnvlist_add_uint16_array(nvlist_t *nvl, const char *name, const uint16_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT16_ARRAY, n, a));\n}\n\nint\nnvlist_add_int32_array(nvlist_t *nvl, const char *name, const int32_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT32_ARRAY, n, a));\n}\n\nint\nnvlist_add_uint32_array(nvlist_t *nvl, const char *name, const uint32_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT32_ARRAY, n, a));\n}\n\nint\nnvlist_add_int64_array(nvlist_t *nvl, const char *name, const int64_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_INT64_ARRAY, n, a));\n}\n\nint\nnvlist_add_uint64_array(nvlist_t *nvl, const char *name, const uint64_t *a,\n    uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_UINT64_ARRAY, n, a));\n}\n\nint\nnvlist_add_string_array(nvlist_t *nvl, const char *name,\n    const char *const *a, uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_STRING_ARRAY, n, a));\n}\n\nint\nnvlist_add_hrtime(nvlist_t *nvl, const char *name, hrtime_t val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_HRTIME, 1, &val));\n}\n\nint\nnvlist_add_nvlist(nvlist_t *nvl, const char *name, const nvlist_t *val)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_NVLIST, 1, val));\n}\n\nint\nnvlist_add_nvlist_array(nvlist_t *nvl, const char *name,\n    const nvlist_t * const *a, uint_t n)\n{\n\treturn (nvlist_add_common(nvl, name, DATA_TYPE_NVLIST_ARRAY, n, a));\n}\n\n \nnvpair_t *\nnvlist_next_nvpair(nvlist_t *nvl, const nvpair_t *nvp)\n{\n\tnvpriv_t *priv;\n\ti_nvp_t *curr;\n\n\tif (nvl == NULL ||\n\t    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn (NULL);\n\n\tcurr = NVPAIR2I_NVP(nvp);\n\n\t \n\tif (nvp == NULL)\n\t\tcurr = priv->nvp_list;\n\telse if (priv->nvp_curr == curr || nvlist_contains_nvp(nvl, nvp))\n\t\tcurr = curr->nvi_next;\n\telse\n\t\tcurr = NULL;\n\n\tpriv->nvp_curr = curr;\n\n\treturn (curr != NULL ? &curr->nvi_nvp : NULL);\n}\n\nnvpair_t *\nnvlist_prev_nvpair(nvlist_t *nvl, const nvpair_t *nvp)\n{\n\tnvpriv_t *priv;\n\ti_nvp_t *curr;\n\n\tif (nvl == NULL ||\n\t    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn (NULL);\n\n\tcurr = NVPAIR2I_NVP(nvp);\n\n\tif (nvp == NULL)\n\t\tcurr = priv->nvp_last;\n\telse if (priv->nvp_curr == curr || nvlist_contains_nvp(nvl, nvp))\n\t\tcurr = curr->nvi_prev;\n\telse\n\t\tcurr = NULL;\n\n\tpriv->nvp_curr = curr;\n\n\treturn (curr != NULL ? &curr->nvi_nvp : NULL);\n}\n\nboolean_t\nnvlist_empty(const nvlist_t *nvl)\n{\n\tconst nvpriv_t *priv;\n\n\tif (nvl == NULL ||\n\t    (priv = (const nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn (B_TRUE);\n\n\treturn (priv->nvp_list == NULL);\n}\n\nconst char *\nnvpair_name(const nvpair_t *nvp)\n{\n\treturn (NVP_NAME(nvp));\n}\n\ndata_type_t\nnvpair_type(const nvpair_t *nvp)\n{\n\treturn (NVP_TYPE(nvp));\n}\n\nint\nnvpair_type_is_array(const nvpair_t *nvp)\n{\n\tdata_type_t type = NVP_TYPE(nvp);\n\n\tif ((type == DATA_TYPE_BYTE_ARRAY) ||\n\t    (type == DATA_TYPE_INT8_ARRAY) ||\n\t    (type == DATA_TYPE_UINT8_ARRAY) ||\n\t    (type == DATA_TYPE_INT16_ARRAY) ||\n\t    (type == DATA_TYPE_UINT16_ARRAY) ||\n\t    (type == DATA_TYPE_INT32_ARRAY) ||\n\t    (type == DATA_TYPE_UINT32_ARRAY) ||\n\t    (type == DATA_TYPE_INT64_ARRAY) ||\n\t    (type == DATA_TYPE_UINT64_ARRAY) ||\n\t    (type == DATA_TYPE_BOOLEAN_ARRAY) ||\n\t    (type == DATA_TYPE_STRING_ARRAY) ||\n\t    (type == DATA_TYPE_NVLIST_ARRAY))\n\t\treturn (1);\n\treturn (0);\n\n}\n\nstatic int\nnvpair_value_common(const nvpair_t *nvp, data_type_t type, uint_t *nelem,\n    void *data)\n{\n\tint value_sz;\n\n\tif (nvp == NULL || nvpair_type(nvp) != type)\n\t\treturn (EINVAL);\n\n\t \n\tswitch (type) {\n\tcase DATA_TYPE_BOOLEAN:\n\t\tif (nelem != NULL)\n\t\t\t*nelem = 0;\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\tcase DATA_TYPE_BYTE:\n\tcase DATA_TYPE_INT8:\n\tcase DATA_TYPE_UINT8:\n\tcase DATA_TYPE_INT16:\n\tcase DATA_TYPE_UINT16:\n\tcase DATA_TYPE_INT32:\n\tcase DATA_TYPE_UINT32:\n\tcase DATA_TYPE_INT64:\n\tcase DATA_TYPE_UINT64:\n\tcase DATA_TYPE_HRTIME:\n#if !defined(_KERNEL)\n\tcase DATA_TYPE_DOUBLE:\n#endif\n\t\tif (data == NULL)\n\t\t\treturn (EINVAL);\n\t\tif ((value_sz = i_get_value_size(type, NULL, 1)) < 0)\n\t\t\treturn (EINVAL);\n\t\tmemcpy(data, NVP_VALUE(nvp), (size_t)value_sz);\n\t\tif (nelem != NULL)\n\t\t\t*nelem = 1;\n\t\tbreak;\n\n\tcase DATA_TYPE_NVLIST:\n\tcase DATA_TYPE_STRING:\n\t\tif (data == NULL)\n\t\t\treturn (EINVAL);\n\t\t \n\t\t*(void **)data = (void *)NVP_VALUE(nvp);\n\t\tif (nelem != NULL)\n\t\t\t*nelem = 1;\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\tcase DATA_TYPE_BYTE_ARRAY:\n\tcase DATA_TYPE_INT8_ARRAY:\n\tcase DATA_TYPE_UINT8_ARRAY:\n\tcase DATA_TYPE_INT16_ARRAY:\n\tcase DATA_TYPE_UINT16_ARRAY:\n\tcase DATA_TYPE_INT32_ARRAY:\n\tcase DATA_TYPE_UINT32_ARRAY:\n\tcase DATA_TYPE_INT64_ARRAY:\n\tcase DATA_TYPE_UINT64_ARRAY:\n\tcase DATA_TYPE_STRING_ARRAY:\n\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\tif (nelem == NULL || data == NULL)\n\t\t\treturn (EINVAL);\n\t\t \n\t\tif ((*nelem = NVP_NELEM(nvp)) != 0)\n\t\t\t*(void **)data = (void *)NVP_VALUE(nvp);\n\t\telse\n\t\t\t*(void **)data = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (ENOTSUP);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nnvlist_lookup_common(const nvlist_t *nvl, const char *name, data_type_t type,\n    uint_t *nelem, void *data)\n{\n\tif (name == NULL || nvl == NULL || nvl->nvl_priv == 0)\n\t\treturn (EINVAL);\n\n\tif (!(nvl->nvl_nvflag & (NV_UNIQUE_NAME | NV_UNIQUE_NAME_TYPE)))\n\t\treturn (ENOTSUP);\n\n\tnvpair_t *nvp = nvt_lookup_name_type(nvl, name, type);\n\tif (nvp == NULL)\n\t\treturn (ENOENT);\n\n\treturn (nvpair_value_common(nvp, type, nelem, data));\n}\n\nint\nnvlist_lookup_boolean(const nvlist_t *nvl, const char *name)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_BOOLEAN, NULL, NULL));\n}\n\nint\nnvlist_lookup_boolean_value(const nvlist_t *nvl, const char *name,\n    boolean_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name,\n\t    DATA_TYPE_BOOLEAN_VALUE, NULL, val));\n}\n\nint\nnvlist_lookup_byte(const nvlist_t *nvl, const char *name, uchar_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_BYTE, NULL, val));\n}\n\nint\nnvlist_lookup_int8(const nvlist_t *nvl, const char *name, int8_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT8, NULL, val));\n}\n\nint\nnvlist_lookup_uint8(const nvlist_t *nvl, const char *name, uint8_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT8, NULL, val));\n}\n\nint\nnvlist_lookup_int16(const nvlist_t *nvl, const char *name, int16_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT16, NULL, val));\n}\n\nint\nnvlist_lookup_uint16(const nvlist_t *nvl, const char *name, uint16_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT16, NULL, val));\n}\n\nint\nnvlist_lookup_int32(const nvlist_t *nvl, const char *name, int32_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT32, NULL, val));\n}\n\nint\nnvlist_lookup_uint32(const nvlist_t *nvl, const char *name, uint32_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT32, NULL, val));\n}\n\nint\nnvlist_lookup_int64(const nvlist_t *nvl, const char *name, int64_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT64, NULL, val));\n}\n\nint\nnvlist_lookup_uint64(const nvlist_t *nvl, const char *name, uint64_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT64, NULL, val));\n}\n\n#if !defined(_KERNEL)\nint\nnvlist_lookup_double(const nvlist_t *nvl, const char *name, double *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_DOUBLE, NULL, val));\n}\n#endif\n\nint\nnvlist_lookup_string(const nvlist_t *nvl, const char *name, const char **val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_STRING, NULL, val));\n}\n\nint\nnvlist_lookup_nvlist(nvlist_t *nvl, const char *name, nvlist_t **val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_NVLIST, NULL, val));\n}\n\nint\nnvlist_lookup_boolean_array(nvlist_t *nvl, const char *name,\n    boolean_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name,\n\t    DATA_TYPE_BOOLEAN_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_byte_array(nvlist_t *nvl, const char *name,\n    uchar_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_BYTE_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_int8_array(nvlist_t *nvl, const char *name, int8_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT8_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_uint8_array(nvlist_t *nvl, const char *name,\n    uint8_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT8_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_int16_array(nvlist_t *nvl, const char *name,\n    int16_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT16_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_uint16_array(nvlist_t *nvl, const char *name,\n    uint16_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT16_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_int32_array(nvlist_t *nvl, const char *name,\n    int32_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT32_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_uint32_array(nvlist_t *nvl, const char *name,\n    uint32_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT32_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_int64_array(nvlist_t *nvl, const char *name,\n    int64_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_INT64_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_uint64_array(nvlist_t *nvl, const char *name,\n    uint64_t **a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_UINT64_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_string_array(nvlist_t *nvl, const char *name,\n    char ***a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_STRING_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_nvlist_array(nvlist_t *nvl, const char *name,\n    nvlist_t ***a, uint_t *n)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_NVLIST_ARRAY, n, a));\n}\n\nint\nnvlist_lookup_hrtime(nvlist_t *nvl, const char *name, hrtime_t *val)\n{\n\treturn (nvlist_lookup_common(nvl, name, DATA_TYPE_HRTIME, NULL, val));\n}\n\nint\nnvlist_lookup_pairs(nvlist_t *nvl, int flag, ...)\n{\n\tva_list ap;\n\tchar *name;\n\tint noentok = (flag & NV_FLAG_NOENTOK ? 1 : 0);\n\tint ret = 0;\n\n\tva_start(ap, flag);\n\twhile (ret == 0 && (name = va_arg(ap, char *)) != NULL) {\n\t\tdata_type_t type;\n\t\tvoid *val;\n\t\tuint_t *nelem;\n\n\t\tswitch (type = va_arg(ap, data_type_t)) {\n\t\tcase DATA_TYPE_BOOLEAN:\n\t\t\tret = nvlist_lookup_common(nvl, name, type, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\tcase DATA_TYPE_BYTE:\n\t\tcase DATA_TYPE_INT8:\n\t\tcase DATA_TYPE_UINT8:\n\t\tcase DATA_TYPE_INT16:\n\t\tcase DATA_TYPE_UINT16:\n\t\tcase DATA_TYPE_INT32:\n\t\tcase DATA_TYPE_UINT32:\n\t\tcase DATA_TYPE_INT64:\n\t\tcase DATA_TYPE_UINT64:\n\t\tcase DATA_TYPE_HRTIME:\n\t\tcase DATA_TYPE_STRING:\n\t\tcase DATA_TYPE_NVLIST:\n#if !defined(_KERNEL)\n\t\tcase DATA_TYPE_DOUBLE:\n#endif\n\t\t\tval = va_arg(ap, void *);\n\t\t\tret = nvlist_lookup_common(nvl, name, type, NULL, val);\n\t\t\tbreak;\n\n\t\tcase DATA_TYPE_BYTE_ARRAY:\n\t\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\t\tcase DATA_TYPE_INT8_ARRAY:\n\t\tcase DATA_TYPE_UINT8_ARRAY:\n\t\tcase DATA_TYPE_INT16_ARRAY:\n\t\tcase DATA_TYPE_UINT16_ARRAY:\n\t\tcase DATA_TYPE_INT32_ARRAY:\n\t\tcase DATA_TYPE_UINT32_ARRAY:\n\t\tcase DATA_TYPE_INT64_ARRAY:\n\t\tcase DATA_TYPE_UINT64_ARRAY:\n\t\tcase DATA_TYPE_STRING_ARRAY:\n\t\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\t\tval = va_arg(ap, void *);\n\t\t\tnelem = va_arg(ap, uint_t *);\n\t\t\tret = nvlist_lookup_common(nvl, name, type, nelem, val);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = EINVAL;\n\t\t}\n\n\t\tif (ret == ENOENT && noentok)\n\t\t\tret = 0;\n\t}\n\tva_end(ap);\n\n\treturn (ret);\n}\n\n \nstatic int\nnvlist_lookup_nvpair_ei_sep(nvlist_t *nvl, const char *name, const char sep,\n    nvpair_t **ret, int *ip, const char **ep)\n{\n\tnvpair_t\t*nvp;\n\tconst char\t*np;\n\tchar\t\t*sepp = NULL;\n\tchar\t\t*idxp, *idxep;\n\tnvlist_t\t**nva;\n\tlong\t\tidx = 0;\n\tint\t\tn;\n\n\tif (ip)\n\t\t*ip = -1;\t\t\t \n\tif (ep)\n\t\t*ep = NULL;\n\n\tif ((nvl == NULL) || (name == NULL))\n\t\treturn (EINVAL);\n\n\tsepp = NULL;\n\tidx = 0;\n\t \n\tfor (np = name; np && *np; np = sepp) {\n\t\t \n\t\tif (!(nvl->nvl_nvflag & NV_UNIQUE_NAME))\n\t\t\treturn (ENOTSUP);\n\n\t\t \n\t\tskip_whitespace(np);\n\t\tif (*np == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sep)\n\t\t\tsepp = strchr(np, sep);\n\t\telse\n\t\t\tsepp = NULL;\n\n\t\t \n\t\tidxp = strchr(np, '[');\n\n\t\t \n\t\tif (sepp && idxp && (sepp < idxp))\n\t\t\tidxp = NULL;\n\n\t\t \n\t\tif (idxp) {\n\t\t\t \n\t\t\tn = idxp++ - np;\n\n\t\t\t \n\t\t\tskip_whitespace(idxp);\n\t\t\tsepp = idxp;\n\n\t\t\t \n#if defined(_KERNEL)\n\t\t\tif (ddi_strtol(idxp, &idxep, 0, &idx))\n\t\t\t\tgoto fail;\n#else\n\t\t\tidx = strtol(idxp, &idxep, 0);\n#endif\n\t\t\tif (idxep == idxp)\n\t\t\t\tgoto fail;\n\n\t\t\t \n\t\t\tsepp = idxep;\n\n\t\t\t \n\t\t\tskip_whitespace(sepp);\n\t\t\tif (*sepp++ != ']')\n\t\t\t\tgoto fail;\n\n\t\t\t \n\t\t\tskip_whitespace(sepp);\n\t\t\tif (sep && (*sepp == sep))\n\t\t\t\tsepp++;\n\t\t} else if (sepp) {\n\t\t\tn = sepp++ - np;\n\t\t} else {\n\t\t\tn = strlen(np);\n\t\t}\n\n\t\t \n\t\tif (n == 0)\n\t\t\tgoto fail;\n\t\tfor (n--; (np[n] == ' ') || (np[n] == '\\t'); n--)\n\t\t\t;\n\t\tn++;\n\n\t\t \n\t\tif (sepp) {\n\t\t\tskip_whitespace(sepp);\n\t\t\tif (*sepp == 0)\n\t\t\t\tsepp = NULL;\n\t\t}\n\n\t\t \n\t\tfor (nvp = nvlist_next_nvpair(nvl, NULL); nvp != NULL;\n\t\t    nvp = nvlist_next_nvpair(nvl, nvp)) {\n\n\t\t\t \n\t\t\tif (strncmp(np, nvpair_name(nvp), n) ||\n\t\t\t    (strlen(nvpair_name(nvp)) != n))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (idxp && !nvpair_type_is_array(nvp))\n\t\t\t\tgoto fail;\n\n\t\t\t \n\t\t\tif (sepp == NULL) {\n\t\t\t\tif (ret)\n\t\t\t\t\t*ret = nvp;\n\t\t\t\tif (ip && idxp)\n\t\t\t\t\t*ip = (int)idx;\t \n\t\t\t\treturn (0);\t\t \n\t\t\t}\n\n\t\t\t \n\t\t\tif (nvpair_type(nvp) == DATA_TYPE_NVLIST) {\n\t\t\t\tnvl = EMBEDDED_NVL(nvp);\n\t\t\t\tbreak;\n\t\t\t} else if (nvpair_type(nvp) == DATA_TYPE_NVLIST_ARRAY) {\n\t\t\t\tif (nvpair_value_nvlist_array(nvp,\n\t\t\t\t    &nva, (uint_t *)&n) != 0)\n\t\t\t\t\tgoto fail;\n\t\t\t\tif (nva == NULL)\n\t\t\t\t\tgoto fail;\n\t\t\t\tif ((n < 0) || (idx >= n))\n\t\t\t\t\tgoto fail;\n\t\t\t\tnvl = nva[idx];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tgoto fail;\n\t\t}\n\t\tif (nvp == NULL)\n\t\t\tgoto fail;\t\t \n\n\t\t \n\t}\n\nfail:\tif (ep && sepp)\n\t\t*ep = sepp;\n\treturn (EINVAL);\n}\n\n \nint\nnvlist_lookup_nvpair(nvlist_t *nvl, const char *name, nvpair_t **ret)\n{\n\treturn (nvlist_lookup_nvpair_ei_sep(nvl, name, 0, ret, NULL, NULL));\n}\n\n \nint nvlist_lookup_nvpair_embedded_index(nvlist_t *nvl,\n    const char *name, nvpair_t **ret, int *ip, const char **ep)\n{\n\treturn (nvlist_lookup_nvpair_ei_sep(nvl, name, '.', ret, ip, ep));\n}\n\nboolean_t\nnvlist_exists(const nvlist_t *nvl, const char *name)\n{\n\tnvpriv_t *priv;\n\tnvpair_t *nvp;\n\ti_nvp_t *curr;\n\n\tif (name == NULL || nvl == NULL ||\n\t    (priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn (B_FALSE);\n\n\tfor (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {\n\t\tnvp = &curr->nvi_nvp;\n\n\t\tif (strcmp(name, NVP_NAME(nvp)) == 0)\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nint\nnvpair_value_boolean_value(const nvpair_t *nvp, boolean_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_BOOLEAN_VALUE, NULL, val));\n}\n\nint\nnvpair_value_byte(const nvpair_t *nvp, uchar_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_BYTE, NULL, val));\n}\n\nint\nnvpair_value_int8(const nvpair_t *nvp, int8_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT8, NULL, val));\n}\n\nint\nnvpair_value_uint8(const nvpair_t *nvp, uint8_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT8, NULL, val));\n}\n\nint\nnvpair_value_int16(const nvpair_t *nvp, int16_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT16, NULL, val));\n}\n\nint\nnvpair_value_uint16(const nvpair_t *nvp, uint16_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT16, NULL, val));\n}\n\nint\nnvpair_value_int32(const nvpair_t *nvp, int32_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT32, NULL, val));\n}\n\nint\nnvpair_value_uint32(const nvpair_t *nvp, uint32_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT32, NULL, val));\n}\n\nint\nnvpair_value_int64(const nvpair_t *nvp, int64_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT64, NULL, val));\n}\n\nint\nnvpair_value_uint64(const nvpair_t *nvp, uint64_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT64, NULL, val));\n}\n\n#if !defined(_KERNEL)\nint\nnvpair_value_double(const nvpair_t *nvp, double *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_DOUBLE, NULL, val));\n}\n#endif\n\nint\nnvpair_value_string(const nvpair_t *nvp, const char **val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_STRING, NULL, val));\n}\n\nint\nnvpair_value_nvlist(nvpair_t *nvp, nvlist_t **val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_NVLIST, NULL, val));\n}\n\nint\nnvpair_value_boolean_array(nvpair_t *nvp, boolean_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_BOOLEAN_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_byte_array(nvpair_t *nvp, uchar_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_BYTE_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_int8_array(nvpair_t *nvp, int8_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT8_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_uint8_array(nvpair_t *nvp, uint8_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT8_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_int16_array(nvpair_t *nvp, int16_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT16_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_uint16_array(nvpair_t *nvp, uint16_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT16_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_int32_array(nvpair_t *nvp, int32_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT32_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_uint32_array(nvpair_t *nvp, uint32_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT32_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_int64_array(nvpair_t *nvp, int64_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_INT64_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_uint64_array(nvpair_t *nvp, uint64_t **val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_UINT64_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_string_array(nvpair_t *nvp, const char ***val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_STRING_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_nvlist_array(nvpair_t *nvp, nvlist_t ***val, uint_t *nelem)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_NVLIST_ARRAY, nelem, val));\n}\n\nint\nnvpair_value_hrtime(nvpair_t *nvp, hrtime_t *val)\n{\n\treturn (nvpair_value_common(nvp, DATA_TYPE_HRTIME, NULL, val));\n}\n\n \nint\nnvlist_add_nvpair(nvlist_t *nvl, nvpair_t *nvp)\n{\n\tif (nvl == NULL || nvp == NULL)\n\t\treturn (EINVAL);\n\n\treturn (nvlist_add_common(nvl, NVP_NAME(nvp), NVP_TYPE(nvp),\n\t    NVP_NELEM(nvp), NVP_VALUE(nvp)));\n}\n\n \nint\nnvlist_merge(nvlist_t *dst, nvlist_t *nvl, int flag)\n{\n\t(void) flag;\n\n\tif (nvl == NULL || dst == NULL)\n\t\treturn (EINVAL);\n\n\tif (dst != nvl)\n\t\treturn (nvlist_copy_pairs(nvl, dst));\n\n\treturn (0);\n}\n\n \n#define\tNVS_OP_ENCODE\t0\n#define\tNVS_OP_DECODE\t1\n#define\tNVS_OP_GETSIZE\t2\n\ntypedef struct nvs_ops nvs_ops_t;\n\ntypedef struct {\n\tint\t\tnvs_op;\n\tconst nvs_ops_t\t*nvs_ops;\n\tvoid\t\t*nvs_private;\n\tnvpriv_t\t*nvs_priv;\n\tint\t\tnvs_recursion;\n} nvstream_t;\n\n \nstruct nvs_ops {\n\tint (*nvs_nvlist)(nvstream_t *, nvlist_t *, size_t *);\n\tint (*nvs_nvpair)(nvstream_t *, nvpair_t *, size_t *);\n\tint (*nvs_nvp_op)(nvstream_t *, nvpair_t *);\n\tint (*nvs_nvp_size)(nvstream_t *, nvpair_t *, size_t *);\n\tint (*nvs_nvl_fini)(nvstream_t *);\n};\n\ntypedef struct {\n\tchar\tnvh_encoding;\t \n\tchar\tnvh_endian;\t \n\tchar\tnvh_reserved1;\t \n\tchar\tnvh_reserved2;\t \n} nvs_header_t;\n\nstatic int\nnvs_encode_pairs(nvstream_t *nvs, nvlist_t *nvl)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\ti_nvp_t *curr;\n\n\t \n\tfor (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next)\n\t\tif (nvs->nvs_ops->nvs_nvpair(nvs, &curr->nvi_nvp, NULL) != 0)\n\t\t\treturn (EFAULT);\n\n\treturn (nvs->nvs_ops->nvs_nvl_fini(nvs));\n}\n\nstatic int\nnvs_decode_pairs(nvstream_t *nvs, nvlist_t *nvl)\n{\n\tnvpair_t *nvp;\n\tsize_t nvsize;\n\tint err;\n\n\t \n\twhile ((err = nvs->nvs_ops->nvs_nvpair(nvs, NULL, &nvsize)) == 0) {\n\t\tif (nvsize == 0)  \n\t\t\tbreak;\n\n\t\t \n\t\tif (nvsize < NVP_SIZE_CALC(1, 0))\n\t\t\treturn (EFAULT);\n\n\t\tif ((nvp = nvp_buf_alloc(nvl, nvsize)) == NULL)\n\t\t\treturn (ENOMEM);\n\n\t\tif ((err = nvs->nvs_ops->nvs_nvp_op(nvs, nvp)) != 0) {\n\t\t\tnvp_buf_free(nvl, nvp);\n\t\t\treturn (err);\n\t\t}\n\n\t\tif (i_validate_nvpair(nvp) != 0) {\n\t\t\tnvpair_free(nvp);\n\t\t\tnvp_buf_free(nvl, nvp);\n\t\t\treturn (EFAULT);\n\t\t}\n\n\t\terr = nvt_add_nvpair(nvl, nvp);\n\t\tif (err != 0) {\n\t\t\tnvpair_free(nvp);\n\t\t\tnvp_buf_free(nvl, nvp);\n\t\t\treturn (err);\n\t\t}\n\t\tnvp_buf_link(nvl, nvp);\n\t}\n\treturn (err);\n}\n\nstatic int\nnvs_getsize_pairs(nvstream_t *nvs, nvlist_t *nvl, size_t *buflen)\n{\n\tnvpriv_t *priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv;\n\ti_nvp_t *curr;\n\tuint64_t nvsize = *buflen;\n\tsize_t size;\n\n\t \n\tfor (curr = priv->nvp_list; curr != NULL; curr = curr->nvi_next) {\n\t\tif (nvs->nvs_ops->nvs_nvp_size(nvs, &curr->nvi_nvp, &size) != 0)\n\t\t\treturn (EINVAL);\n\n\t\tif ((nvsize += size) > INT32_MAX)\n\t\t\treturn (EINVAL);\n\t}\n\n\t*buflen = nvsize;\n\treturn (0);\n}\n\nstatic int\nnvs_operation(nvstream_t *nvs, nvlist_t *nvl, size_t *buflen)\n{\n\tint err;\n\n\tif (nvl->nvl_priv == 0)\n\t\treturn (EFAULT);\n\n\t \n\tif ((err = nvs->nvs_ops->nvs_nvlist(nvs, nvl, buflen)) != 0)\n\t\treturn (err);\n\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\t\terr = nvs_encode_pairs(nvs, nvl);\n\t\tbreak;\n\n\tcase NVS_OP_DECODE:\n\t\terr = nvs_decode_pairs(nvs, nvl);\n\t\tbreak;\n\n\tcase NVS_OP_GETSIZE:\n\t\terr = nvs_getsize_pairs(nvs, nvl, buflen);\n\t\tbreak;\n\n\tdefault:\n\t\terr = EINVAL;\n\t}\n\n\treturn (err);\n}\n\nstatic int\nnvs_embedded(nvstream_t *nvs, nvlist_t *embedded)\n{\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE: {\n\t\tint err;\n\n\t\tif (nvs->nvs_recursion >= nvpair_max_recursion)\n\t\t\treturn (EINVAL);\n\t\tnvs->nvs_recursion++;\n\t\terr = nvs_operation(nvs, embedded, NULL);\n\t\tnvs->nvs_recursion--;\n\t\treturn (err);\n\t}\n\tcase NVS_OP_DECODE: {\n\t\tnvpriv_t *priv;\n\t\tint err;\n\n\t\tif (embedded->nvl_version != NV_VERSION)\n\t\t\treturn (ENOTSUP);\n\n\t\tif ((priv = nv_priv_alloc_embedded(nvs->nvs_priv)) == NULL)\n\t\t\treturn (ENOMEM);\n\n\t\tnvlist_init(embedded, embedded->nvl_nvflag, priv);\n\n\t\tif (nvs->nvs_recursion >= nvpair_max_recursion) {\n\t\t\tnvlist_free(embedded);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tnvs->nvs_recursion++;\n\t\tif ((err = nvs_operation(nvs, embedded, NULL)) != 0)\n\t\t\tnvlist_free(embedded);\n\t\tnvs->nvs_recursion--;\n\t\treturn (err);\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (EINVAL);\n}\n\nstatic int\nnvs_embedded_nvl_array(nvstream_t *nvs, nvpair_t *nvp, size_t *size)\n{\n\tsize_t nelem = NVP_NELEM(nvp);\n\tnvlist_t **nvlp = EMBEDDED_NVL_ARRAY(nvp);\n\tint i;\n\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\t\tfor (i = 0; i < nelem; i++)\n\t\t\tif (nvs_embedded(nvs, nvlp[i]) != 0)\n\t\t\t\treturn (EFAULT);\n\t\tbreak;\n\n\tcase NVS_OP_DECODE: {\n\t\tsize_t len = nelem * sizeof (uint64_t);\n\t\tnvlist_t *embedded = (nvlist_t *)((uintptr_t)nvlp + len);\n\n\t\tmemset(nvlp, 0, len);\t \n\t\tfor (i = 0; i < nelem; i++) {\n\t\t\tif (nvs_embedded(nvs, embedded) != 0) {\n\t\t\t\tnvpair_free(nvp);\n\t\t\t\treturn (EFAULT);\n\t\t\t}\n\n\t\t\tnvlp[i] = embedded++;\n\t\t}\n\t\tbreak;\n\t}\n\tcase NVS_OP_GETSIZE: {\n\t\tuint64_t nvsize = 0;\n\n\t\tfor (i = 0; i < nelem; i++) {\n\t\t\tsize_t nvp_sz = 0;\n\n\t\t\tif (nvs_operation(nvs, nvlp[i], &nvp_sz) != 0)\n\t\t\t\treturn (EINVAL);\n\n\t\t\tif ((nvsize += nvp_sz) > INT32_MAX)\n\t\t\t\treturn (EINVAL);\n\t\t}\n\n\t\t*size = nvsize;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}\n\nstatic int nvs_native(nvstream_t *, nvlist_t *, char *, size_t *);\nstatic int nvs_xdr(nvstream_t *, nvlist_t *, char *, size_t *);\n\n \nstatic int\nnvlist_common(nvlist_t *nvl, char *buf, size_t *buflen, int encoding,\n    int nvs_op)\n{\n\tint err = 0;\n\tnvstream_t nvs;\n\tint nvl_endian;\n#if defined(_ZFS_LITTLE_ENDIAN)\n\tint host_endian = 1;\n#elif defined(_ZFS_BIG_ENDIAN)\n\tint host_endian = 0;\n#else\n#error \"No endian defined!\"\n#endif\t \n\tnvs_header_t *nvh;\n\n\tif (buflen == NULL || nvl == NULL ||\n\t    (nvs.nvs_priv = (nvpriv_t *)(uintptr_t)nvl->nvl_priv) == NULL)\n\t\treturn (EINVAL);\n\n\tnvs.nvs_op = nvs_op;\n\tnvs.nvs_recursion = 0;\n\n\t \n\tswitch (nvs_op) {\n\tcase NVS_OP_ENCODE:\n\t\tif (buf == NULL || *buflen < sizeof (nvs_header_t))\n\t\t\treturn (EINVAL);\n\n\t\tnvh = (void *)buf;\n\t\tnvh->nvh_encoding = encoding;\n\t\tnvh->nvh_endian = nvl_endian = host_endian;\n\t\tnvh->nvh_reserved1 = 0;\n\t\tnvh->nvh_reserved2 = 0;\n\t\tbreak;\n\n\tcase NVS_OP_DECODE:\n\t\tif (buf == NULL || *buflen < sizeof (nvs_header_t))\n\t\t\treturn (EINVAL);\n\n\t\t \n\t\tnvh = (void *)buf;\n\t\tencoding = nvh->nvh_encoding;\n\t\tnvl_endian = nvh->nvh_endian;\n\t\tbreak;\n\n\tcase NVS_OP_GETSIZE:\n\t\tnvl_endian = host_endian;\n\n\t\t \n\t\t*buflen = sizeof (nvs_header_t);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (ENOTSUP);\n\t}\n\n\t \n\tswitch (encoding) {\n\tcase NV_ENCODE_NATIVE:\n\t\t \n\t\tif (nvl_endian != host_endian)\n\t\t\treturn (ENOTSUP);\n\t\terr = nvs_native(&nvs, nvl, buf, buflen);\n\t\tbreak;\n\tcase NV_ENCODE_XDR:\n\t\terr = nvs_xdr(&nvs, nvl, buf, buflen);\n\t\tbreak;\n\tdefault:\n\t\terr = ENOTSUP;\n\t\tbreak;\n\t}\n\n\treturn (err);\n}\n\nint\nnvlist_size(nvlist_t *nvl, size_t *size, int encoding)\n{\n\treturn (nvlist_common(nvl, NULL, size, encoding, NVS_OP_GETSIZE));\n}\n\n \nint\nnvlist_pack(nvlist_t *nvl, char **bufp, size_t *buflen, int encoding,\n    int kmflag)\n{\n\treturn (nvlist_xpack(nvl, bufp, buflen, encoding,\n\t    nvlist_nv_alloc(kmflag)));\n}\n\nint\nnvlist_xpack(nvlist_t *nvl, char **bufp, size_t *buflen, int encoding,\n    nv_alloc_t *nva)\n{\n\tnvpriv_t nvpriv;\n\tsize_t alloc_size;\n\tchar *buf;\n\tint err;\n\n\tif (nva == NULL || nvl == NULL || bufp == NULL || buflen == NULL)\n\t\treturn (EINVAL);\n\n\tif (*bufp != NULL)\n\t\treturn (nvlist_common(nvl, *bufp, buflen, encoding,\n\t\t    NVS_OP_ENCODE));\n\n\t \n\tnv_priv_init(&nvpriv, nva, 0);\n\n\tif ((err = nvlist_size(nvl, &alloc_size, encoding)))\n\t\treturn (err);\n\n\tif ((buf = nv_mem_zalloc(&nvpriv, alloc_size)) == NULL)\n\t\treturn (ENOMEM);\n\n\tif ((err = nvlist_common(nvl, buf, &alloc_size, encoding,\n\t    NVS_OP_ENCODE)) != 0) {\n\t\tnv_mem_free(&nvpriv, buf, alloc_size);\n\t} else {\n\t\t*buflen = alloc_size;\n\t\t*bufp = buf;\n\t}\n\n\treturn (err);\n}\n\n \nint\nnvlist_unpack(char *buf, size_t buflen, nvlist_t **nvlp, int kmflag)\n{\n\treturn (nvlist_xunpack(buf, buflen, nvlp, nvlist_nv_alloc(kmflag)));\n}\n\nint\nnvlist_xunpack(char *buf, size_t buflen, nvlist_t **nvlp, nv_alloc_t *nva)\n{\n\tnvlist_t *nvl;\n\tint err;\n\n\tif (nvlp == NULL)\n\t\treturn (EINVAL);\n\n\tif ((err = nvlist_xalloc(&nvl, 0, nva)) != 0)\n\t\treturn (err);\n\n\tif ((err = nvlist_common(nvl, buf, &buflen, NV_ENCODE_NATIVE,\n\t    NVS_OP_DECODE)) != 0)\n\t\tnvlist_free(nvl);\n\telse\n\t\t*nvlp = nvl;\n\n\treturn (err);\n}\n\n \ntypedef struct {\n\t \n\tcaddr_t n_base;\n\tcaddr_t n_end;\n\tcaddr_t n_curr;\n\tuint_t  n_flag;\n} nvs_native_t;\n\nstatic int\nnvs_native_create(nvstream_t *nvs, nvs_native_t *native, char *buf,\n    size_t buflen)\n{\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\tcase NVS_OP_DECODE:\n\t\tnvs->nvs_private = native;\n\t\tnative->n_curr = native->n_base = buf;\n\t\tnative->n_end = buf + buflen;\n\t\tnative->n_flag = 0;\n\t\treturn (0);\n\n\tcase NVS_OP_GETSIZE:\n\t\tnvs->nvs_private = native;\n\t\tnative->n_curr = native->n_base = native->n_end = NULL;\n\t\tnative->n_flag = 0;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}\n\nstatic void\nnvs_native_destroy(nvstream_t *nvs)\n{\n\tnvs->nvs_private = NULL;\n}\n\nstatic int\nnative_cp(nvstream_t *nvs, void *buf, size_t size)\n{\n\tnvs_native_t *native = (nvs_native_t *)nvs->nvs_private;\n\n\tif (native->n_curr + size > native->n_end)\n\t\treturn (EFAULT);\n\n\t \n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\t\tmemcpy(native->n_curr, buf, size);\n\t\tbreak;\n\tcase NVS_OP_DECODE:\n\t\tmemcpy(buf, native->n_curr, size);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tnative->n_curr += size;\n\treturn (0);\n}\n\n \nstatic int\nnvs_native_nvlist(nvstream_t *nvs, nvlist_t *nvl, size_t *size)\n{\n\tnvs_native_t *native = nvs->nvs_private;\n\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\tcase NVS_OP_DECODE:\n\t\tif (native->n_flag)\n\t\t\treturn (0);\t \n\n\t\tnative->n_flag = 1;\n\n\t\t \n\t\tif (native_cp(nvs, &nvl->nvl_version, sizeof (int32_t)) != 0 ||\n\t\t    native_cp(nvs, &nvl->nvl_nvflag, sizeof (int32_t)) != 0)\n\t\t\treturn (EFAULT);\n\n\t\treturn (0);\n\n\tcase NVS_OP_GETSIZE:\n\t\t \n\t\tif (native->n_flag) {\n\t\t\t*size += 4;\n\t\t} else {\n\t\t\tnative->n_flag = 1;\n\t\t\t*size += 2 * sizeof (int32_t) + 4;\n\t\t}\n\n\t\treturn (0);\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}\n\nstatic int\nnvs_native_nvl_fini(nvstream_t *nvs)\n{\n\tif (nvs->nvs_op == NVS_OP_ENCODE) {\n\t\tnvs_native_t *native = (nvs_native_t *)nvs->nvs_private;\n\t\t \n\t\tif (native->n_curr + sizeof (int) > native->n_end)\n\t\t\treturn (EFAULT);\n\n\t\tmemset(native->n_curr, 0, sizeof (int));\n\t\tnative->n_curr += sizeof (int);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nnvpair_native_embedded(nvstream_t *nvs, nvpair_t *nvp)\n{\n\tif (nvs->nvs_op == NVS_OP_ENCODE) {\n\t\tnvs_native_t *native = (nvs_native_t *)nvs->nvs_private;\n\t\tnvlist_t *packed = (void *)\n\t\t    (native->n_curr - nvp->nvp_size + NVP_VALOFF(nvp));\n\t\t \n\t\tmemset((char *)packed + offsetof(nvlist_t, nvl_priv),\n\t\t    0, sizeof (uint64_t));\n\t}\n\n\treturn (nvs_embedded(nvs, EMBEDDED_NVL(nvp)));\n}\n\nstatic int\nnvpair_native_embedded_array(nvstream_t *nvs, nvpair_t *nvp)\n{\n\tif (nvs->nvs_op == NVS_OP_ENCODE) {\n\t\tnvs_native_t *native = (nvs_native_t *)nvs->nvs_private;\n\t\tchar *value = native->n_curr - nvp->nvp_size + NVP_VALOFF(nvp);\n\t\tsize_t len = NVP_NELEM(nvp) * sizeof (uint64_t);\n\t\tnvlist_t *packed = (nvlist_t *)((uintptr_t)value + len);\n\t\tint i;\n\t\t \n\t\tmemset(value, 0, len);\n\n\t\tfor (i = 0; i < NVP_NELEM(nvp); i++, packed++)\n\t\t\t \n\t\t\tmemset((char *)packed + offsetof(nvlist_t, nvl_priv),\n\t\t\t    0, sizeof (uint64_t));\n\t}\n\n\treturn (nvs_embedded_nvl_array(nvs, nvp, NULL));\n}\n\nstatic void\nnvpair_native_string_array(nvstream_t *nvs, nvpair_t *nvp)\n{\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE: {\n\t\tnvs_native_t *native = (nvs_native_t *)nvs->nvs_private;\n\t\tuint64_t *strp = (void *)\n\t\t    (native->n_curr - nvp->nvp_size + NVP_VALOFF(nvp));\n\t\t \n\t\tmemset(strp, 0, NVP_NELEM(nvp) * sizeof (uint64_t));\n\t\tbreak;\n\t}\n\tcase NVS_OP_DECODE: {\n\t\tchar **strp = (void *)NVP_VALUE(nvp);\n\t\tchar *buf = ((char *)strp + NVP_NELEM(nvp) * sizeof (uint64_t));\n\t\tint i;\n\n\t\tfor (i = 0; i < NVP_NELEM(nvp); i++) {\n\t\t\tstrp[i] = buf;\n\t\t\tbuf += strlen(buf) + 1;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic int\nnvs_native_nvp_op(nvstream_t *nvs, nvpair_t *nvp)\n{\n\tdata_type_t type;\n\tint value_sz;\n\tint ret = 0;\n\n\t \n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\tcase NVS_OP_DECODE:\n\t\tif (native_cp(nvs, nvp, nvp->nvp_size) != 0)\n\t\t\treturn (EFAULT);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\t \n\tif (i_validate_nvpair_name(nvp) != 0)\n\t\treturn (EFAULT);\n\n\ttype = NVP_TYPE(nvp);\n\n\t \n\tif ((value_sz = i_get_value_size(type, NULL, NVP_NELEM(nvp))) < 0)\n\t\treturn (EFAULT);\n\n\tif (NVP_SIZE_CALC(nvp->nvp_name_sz, value_sz) > nvp->nvp_size)\n\t\treturn (EFAULT);\n\n\tswitch (type) {\n\tcase DATA_TYPE_NVLIST:\n\t\tret = nvpair_native_embedded(nvs, nvp);\n\t\tbreak;\n\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\tret = nvpair_native_embedded_array(nvs, nvp);\n\t\tbreak;\n\tcase DATA_TYPE_STRING_ARRAY:\n\t\tnvpair_native_string_array(nvs, nvp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nnvs_native_nvp_size(nvstream_t *nvs, nvpair_t *nvp, size_t *size)\n{\n\tuint64_t nvp_sz = nvp->nvp_size;\n\n\tswitch (NVP_TYPE(nvp)) {\n\tcase DATA_TYPE_NVLIST: {\n\t\tsize_t nvsize = 0;\n\n\t\tif (nvs_operation(nvs, EMBEDDED_NVL(nvp), &nvsize) != 0)\n\t\t\treturn (EINVAL);\n\n\t\tnvp_sz += nvsize;\n\t\tbreak;\n\t}\n\tcase DATA_TYPE_NVLIST_ARRAY: {\n\t\tsize_t nvsize;\n\n\t\tif (nvs_embedded_nvl_array(nvs, nvp, &nvsize) != 0)\n\t\t\treturn (EINVAL);\n\n\t\tnvp_sz += nvsize;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nvp_sz > INT32_MAX)\n\t\treturn (EINVAL);\n\n\t*size = nvp_sz;\n\n\treturn (0);\n}\n\nstatic int\nnvs_native_nvpair(nvstream_t *nvs, nvpair_t *nvp, size_t *size)\n{\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\t\treturn (nvs_native_nvp_op(nvs, nvp));\n\n\tcase NVS_OP_DECODE: {\n\t\tnvs_native_t *native = (nvs_native_t *)nvs->nvs_private;\n\t\tint32_t decode_len;\n\n\t\t \n\t\tif (native->n_curr + sizeof (int32_t) > native->n_end)\n\t\t\treturn (EFAULT);\n\t\tmemcpy(&decode_len, native->n_curr, sizeof (int32_t));\n\n\t\t \n\t\tif (decode_len < 0 ||\n\t\t    decode_len > native->n_end - native->n_curr)\n\t\t\treturn (EFAULT);\n\n\t\t*size = decode_len;\n\n\t\t \n\t\tif (*size == 0)\n\t\t\tnative->n_curr += sizeof (int32_t);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}\n\nstatic const nvs_ops_t nvs_native_ops = {\n\t.nvs_nvlist = nvs_native_nvlist,\n\t.nvs_nvpair = nvs_native_nvpair,\n\t.nvs_nvp_op = nvs_native_nvp_op,\n\t.nvs_nvp_size = nvs_native_nvp_size,\n\t.nvs_nvl_fini = nvs_native_nvl_fini\n};\n\nstatic int\nnvs_native(nvstream_t *nvs, nvlist_t *nvl, char *buf, size_t *buflen)\n{\n\tnvs_native_t native;\n\tint err;\n\n\tnvs->nvs_ops = &nvs_native_ops;\n\n\tif ((err = nvs_native_create(nvs, &native, buf + sizeof (nvs_header_t),\n\t    *buflen - sizeof (nvs_header_t))) != 0)\n\t\treturn (err);\n\n\terr = nvs_operation(nvs, nvl, buflen);\n\n\tnvs_native_destroy(nvs);\n\n\treturn (err);\n}\n\n \nstatic int\nnvs_xdr_create(nvstream_t *nvs, XDR *xdr, char *buf, size_t buflen)\n{\n\t \n\tif ((ulong_t)buf % 4 != 0)\n\t\treturn (EFAULT);\n\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\t\txdrmem_create(xdr, buf, (uint_t)buflen, XDR_ENCODE);\n\t\tnvs->nvs_private = xdr;\n\t\treturn (0);\n\tcase NVS_OP_DECODE:\n\t\txdrmem_create(xdr, buf, (uint_t)buflen, XDR_DECODE);\n\t\tnvs->nvs_private = xdr;\n\t\treturn (0);\n\tcase NVS_OP_GETSIZE:\n\t\tnvs->nvs_private = NULL;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}\n\nstatic void\nnvs_xdr_destroy(nvstream_t *nvs)\n{\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\tcase NVS_OP_DECODE:\n\t\tnvs->nvs_private = NULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int\nnvs_xdr_nvlist(nvstream_t *nvs, nvlist_t *nvl, size_t *size)\n{\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE:\n\tcase NVS_OP_DECODE: {\n\t\tXDR \t*xdr = nvs->nvs_private;\n\n\t\tif (!xdr_int(xdr, &nvl->nvl_version) ||\n\t\t    !xdr_u_int(xdr, &nvl->nvl_nvflag))\n\t\t\treturn (EFAULT);\n\t\tbreak;\n\t}\n\tcase NVS_OP_GETSIZE: {\n\t\t \n\t\t*size += 2 * 4 + 8;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}\n\nstatic int\nnvs_xdr_nvl_fini(nvstream_t *nvs)\n{\n\tif (nvs->nvs_op == NVS_OP_ENCODE) {\n\t\tXDR *xdr = nvs->nvs_private;\n\t\tint zero = 0;\n\n\t\tif (!xdr_int(xdr, &zero) || !xdr_int(xdr, &zero))\n\t\t\treturn (EFAULT);\n\t}\n\n\treturn (0);\n}\n\n \n\n#if defined(_KERNEL) && defined(__linux__)  \n\n#define\tNVS_BUILD_XDRPROC_T(type)\t\t\\\nstatic bool_t\t\t\t\t\t\\\nnvs_xdr_nvp_##type(XDR *xdrs, void *ptr)\t\\\n{\t\t\t\t\t\t\\\n\treturn (xdr_##type(xdrs, ptr));\t\t\\\n}\n\n#elif !defined(_KERNEL) && defined(XDR_CONTROL)  \n\n#define\tNVS_BUILD_XDRPROC_T(type)\t\t\\\nstatic bool_t\t\t\t\t\t\\\nnvs_xdr_nvp_##type(XDR *xdrs, ...)\t\t\\\n{\t\t\t\t\t\t\\\n\tva_list args;\t\t\t\t\\\n\tvoid *ptr;\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tva_start(args, xdrs);\t\t\t\\\n\tptr = va_arg(args, void *);\t\t\\\n\tva_end(args);\t\t\t\t\\\n\t\t\t\t\t\t\\\n\treturn (xdr_##type(xdrs, ptr));\t\t\\\n}\n\n#else  \n\n#define\tNVS_BUILD_XDRPROC_T(type)\t\t\\\nstatic bool_t\t\t\t\t\t\\\nnvs_xdr_nvp_##type(XDR *xdrs, void *ptr, ...)\t\\\n{\t\t\t\t\t\t\\\n\treturn (xdr_##type(xdrs, ptr));\t\t\\\n}\n\n#endif\n\n \nNVS_BUILD_XDRPROC_T(char);\nNVS_BUILD_XDRPROC_T(short);\nNVS_BUILD_XDRPROC_T(u_short);\nNVS_BUILD_XDRPROC_T(int);\nNVS_BUILD_XDRPROC_T(u_int);\nNVS_BUILD_XDRPROC_T(longlong_t);\nNVS_BUILD_XDRPROC_T(u_longlong_t);\n \n\n \nstatic int\nnvs_xdr_nvp_op(nvstream_t *nvs, nvpair_t *nvp)\n{\n\tASSERT(nvs != NULL && nvp != NULL);\n\n\tdata_type_t type;\n\tchar\t*buf;\n\tchar\t*buf_end = (char *)nvp + nvp->nvp_size;\n\tint\tvalue_sz;\n\tuint_t\tnelem, buflen;\n\tbool_t\tret = FALSE;\n\tXDR\t*xdr = nvs->nvs_private;\n\n\tASSERT(xdr != NULL);\n\n\t \n\tif ((buf = NVP_NAME(nvp)) >= buf_end)\n\t\treturn (EFAULT);\n\tbuflen = buf_end - buf;\n\n\tif (!xdr_string(xdr, &buf, buflen - 1))\n\t\treturn (EFAULT);\n\tnvp->nvp_name_sz = strlen(buf) + 1;\n\n\t \n\tif (!xdr_int(xdr, (int *)&nvp->nvp_type) ||\n\t    !xdr_int(xdr, &nvp->nvp_value_elem))\n\t\treturn (EFAULT);\n\n\ttype = NVP_TYPE(nvp);\n\tnelem = nvp->nvp_value_elem;\n\n\t \n\tif ((value_sz = i_get_value_size(type, NULL, nelem)) < 0)\n\t\treturn (EFAULT);\n\n\t \n\tif (nelem == 0)\n\t\treturn (0);\n\n\t \n\tif ((buf = NVP_VALUE(nvp)) >= buf_end)\n\t\treturn (EFAULT);\n\tbuflen = buf_end - buf;\n\n\tif (buflen < value_sz)\n\t\treturn (EFAULT);\n\n\tswitch (type) {\n\tcase DATA_TYPE_NVLIST:\n\t\tif (nvs_embedded(nvs, (void *)buf) == 0)\n\t\t\treturn (0);\n\t\tbreak;\n\n\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\tif (nvs_embedded_nvl_array(nvs, nvp, NULL) == 0)\n\t\t\treturn (0);\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN:\n\t\tret = TRUE;\n\t\tbreak;\n\n\tcase DATA_TYPE_BYTE:\n\tcase DATA_TYPE_INT8:\n\tcase DATA_TYPE_UINT8:\n\t\tret = xdr_char(xdr, buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT16:\n\t\tret = xdr_short(xdr, (void *)buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT16:\n\t\tret = xdr_u_short(xdr, (void *)buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\tcase DATA_TYPE_INT32:\n\t\tret = xdr_int(xdr, (void *)buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT32:\n\t\tret = xdr_u_int(xdr, (void *)buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT64:\n\t\tret = xdr_longlong_t(xdr, (void *)buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT64:\n\t\tret = xdr_u_longlong_t(xdr, (void *)buf);\n\t\tbreak;\n\n\tcase DATA_TYPE_HRTIME:\n\t\t \n\t\tret = xdr_longlong_t(xdr, (void *)buf);\n\t\tbreak;\n#if !defined(_KERNEL)\n\tcase DATA_TYPE_DOUBLE:\n\t\tret = xdr_double(xdr, (void *)buf);\n\t\tbreak;\n#endif\n\tcase DATA_TYPE_STRING:\n\t\tret = xdr_string(xdr, &buf, buflen - 1);\n\t\tbreak;\n\n\tcase DATA_TYPE_BYTE_ARRAY:\n\t\tret = xdr_opaque(xdr, buf, nelem);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT8_ARRAY:\n\tcase DATA_TYPE_UINT8_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen, sizeof (int8_t),\n\t\t    nvs_xdr_nvp_char);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT16_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (int16_t),\n\t\t    sizeof (int16_t), nvs_xdr_nvp_short);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT16_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (uint16_t),\n\t\t    sizeof (uint16_t), nvs_xdr_nvp_u_short);\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\tcase DATA_TYPE_INT32_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (int32_t),\n\t\t    sizeof (int32_t), nvs_xdr_nvp_int);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT32_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (uint32_t),\n\t\t    sizeof (uint32_t), nvs_xdr_nvp_u_int);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT64_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (int64_t),\n\t\t    sizeof (int64_t), nvs_xdr_nvp_longlong_t);\n\t\tbreak;\n\n\tcase DATA_TYPE_UINT64_ARRAY:\n\t\tret = xdr_array(xdr, &buf, &nelem, buflen / sizeof (uint64_t),\n\t\t    sizeof (uint64_t), nvs_xdr_nvp_u_longlong_t);\n\t\tbreak;\n\n\tcase DATA_TYPE_STRING_ARRAY: {\n\t\tsize_t len = nelem * sizeof (uint64_t);\n\t\tchar **strp = (void *)buf;\n\t\tint i;\n\n\t\tif (nvs->nvs_op == NVS_OP_DECODE)\n\t\t\tmemset(buf, 0, len);\t \n\n\t\tfor (i = 0; i < nelem; i++) {\n\t\t\tif (buflen <= len)\n\t\t\t\treturn (EFAULT);\n\n\t\t\tbuf += len;\n\t\t\tbuflen -= len;\n\n\t\t\tif (xdr_string(xdr, &buf, buflen - 1) != TRUE)\n\t\t\t\treturn (EFAULT);\n\n\t\t\tif (nvs->nvs_op == NVS_OP_DECODE)\n\t\t\t\tstrp[i] = buf;\n\t\t\tlen = strlen(buf) + 1;\n\t\t}\n\t\tret = TRUE;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (ret == TRUE ? 0 : EFAULT);\n}\n\nstatic int\nnvs_xdr_nvp_size(nvstream_t *nvs, nvpair_t *nvp, size_t *size)\n{\n\tdata_type_t type = NVP_TYPE(nvp);\n\t \n\tuint64_t nvp_sz = 4 + 4 + 4 + NV_ALIGN4(strlen(NVP_NAME(nvp))) + 4 + 4;\n\n\tswitch (type) {\n\tcase DATA_TYPE_BOOLEAN:\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\tcase DATA_TYPE_BYTE:\n\tcase DATA_TYPE_INT8:\n\tcase DATA_TYPE_UINT8:\n\tcase DATA_TYPE_INT16:\n\tcase DATA_TYPE_UINT16:\n\tcase DATA_TYPE_INT32:\n\tcase DATA_TYPE_UINT32:\n\t\tnvp_sz += 4;\t \n\t\tbreak;\n\n\tcase DATA_TYPE_INT64:\n\tcase DATA_TYPE_UINT64:\n\tcase DATA_TYPE_HRTIME:\n#if !defined(_KERNEL)\n\tcase DATA_TYPE_DOUBLE:\n#endif\n\t\tnvp_sz += 8;\n\t\tbreak;\n\n\tcase DATA_TYPE_STRING:\n\t\tnvp_sz += 4 + NV_ALIGN4(strlen((char *)NVP_VALUE(nvp)));\n\t\tbreak;\n\n\tcase DATA_TYPE_BYTE_ARRAY:\n\t\tnvp_sz += NV_ALIGN4(NVP_NELEM(nvp));\n\t\tbreak;\n\n\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\tcase DATA_TYPE_INT8_ARRAY:\n\tcase DATA_TYPE_UINT8_ARRAY:\n\tcase DATA_TYPE_INT16_ARRAY:\n\tcase DATA_TYPE_UINT16_ARRAY:\n\tcase DATA_TYPE_INT32_ARRAY:\n\tcase DATA_TYPE_UINT32_ARRAY:\n\t\tnvp_sz += 4 + 4 * (uint64_t)NVP_NELEM(nvp);\n\t\tbreak;\n\n\tcase DATA_TYPE_INT64_ARRAY:\n\tcase DATA_TYPE_UINT64_ARRAY:\n\t\tnvp_sz += 4 + 8 * (uint64_t)NVP_NELEM(nvp);\n\t\tbreak;\n\n\tcase DATA_TYPE_STRING_ARRAY: {\n\t\tint i;\n\t\tchar **strs = (void *)NVP_VALUE(nvp);\n\n\t\tfor (i = 0; i < NVP_NELEM(nvp); i++)\n\t\t\tnvp_sz += 4 + NV_ALIGN4(strlen(strs[i]));\n\n\t\tbreak;\n\t}\n\n\tcase DATA_TYPE_NVLIST:\n\tcase DATA_TYPE_NVLIST_ARRAY: {\n\t\tsize_t nvsize = 0;\n\t\tint old_nvs_op = nvs->nvs_op;\n\t\tint err;\n\n\t\tnvs->nvs_op = NVS_OP_GETSIZE;\n\t\tif (type == DATA_TYPE_NVLIST)\n\t\t\terr = nvs_operation(nvs, EMBEDDED_NVL(nvp), &nvsize);\n\t\telse\n\t\t\terr = nvs_embedded_nvl_array(nvs, nvp, &nvsize);\n\t\tnvs->nvs_op = old_nvs_op;\n\n\t\tif (err != 0)\n\t\t\treturn (EINVAL);\n\n\t\tnvp_sz += nvsize;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\tif (nvp_sz > INT32_MAX)\n\t\treturn (EINVAL);\n\n\t*size = nvp_sz;\n\n\treturn (0);\n}\n\n\n \n#define\tNVS_XDR_HDR_LEN\t\t((size_t)(5 * 4))\n#define\tNVS_XDR_DATA_LEN(y)\t(((size_t)(y) <= NVS_XDR_HDR_LEN) ? \\\n\t\t\t\t\t0 : ((size_t)(y) - NVS_XDR_HDR_LEN))\n#define\tNVS_XDR_MAX_LEN(x)\t(NVP_SIZE_CALC(1, 0) + \\\n\t\t\t\t\t(NVS_XDR_DATA_LEN(x) * 2) + \\\n\t\t\t\t\tNV_ALIGN4((NVS_XDR_DATA_LEN(x) / 4)))\n\nstatic int\nnvs_xdr_nvpair(nvstream_t *nvs, nvpair_t *nvp, size_t *size)\n{\n\tXDR \t*xdr = nvs->nvs_private;\n\tint32_t\tencode_len, decode_len;\n\n\tswitch (nvs->nvs_op) {\n\tcase NVS_OP_ENCODE: {\n\t\tsize_t nvsize;\n\n\t\tif (nvs_xdr_nvp_size(nvs, nvp, &nvsize) != 0)\n\t\t\treturn (EFAULT);\n\n\t\tdecode_len = nvp->nvp_size;\n\t\tencode_len = nvsize;\n\t\tif (!xdr_int(xdr, &encode_len) || !xdr_int(xdr, &decode_len))\n\t\t\treturn (EFAULT);\n\n\t\treturn (nvs_xdr_nvp_op(nvs, nvp));\n\t}\n\tcase NVS_OP_DECODE: {\n\t\tstruct xdr_bytesrec bytesrec;\n\n\t\t \n\t\tif (!xdr_int(xdr, &encode_len) || !xdr_int(xdr, &decode_len))\n\t\t\treturn (EFAULT);\n\t\t*size = decode_len;\n\n\t\t \n\t\tif (*size == 0)\n\t\t\treturn (0);\n\n\t\t \n\t\tif (!xdr_control(xdr, XDR_GET_BYTES_AVAIL, &bytesrec))\n\t\t\treturn (EFAULT);\n\n\t\tif (*size > NVS_XDR_MAX_LEN(bytesrec.xc_num_avail))\n\t\t\treturn (EFAULT);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}\n\nstatic const struct nvs_ops nvs_xdr_ops = {\n\t.nvs_nvlist = nvs_xdr_nvlist,\n\t.nvs_nvpair = nvs_xdr_nvpair,\n\t.nvs_nvp_op = nvs_xdr_nvp_op,\n\t.nvs_nvp_size = nvs_xdr_nvp_size,\n\t.nvs_nvl_fini = nvs_xdr_nvl_fini\n};\n\nstatic int\nnvs_xdr(nvstream_t *nvs, nvlist_t *nvl, char *buf, size_t *buflen)\n{\n\tXDR xdr;\n\tint err;\n\n\tnvs->nvs_ops = &nvs_xdr_ops;\n\n\tif ((err = nvs_xdr_create(nvs, &xdr, buf + sizeof (nvs_header_t),\n\t    *buflen - sizeof (nvs_header_t))) != 0)\n\t\treturn (err);\n\n\terr = nvs_operation(nvs, nvl, buflen);\n\n\tnvs_xdr_destroy(nvs);\n\n\treturn (err);\n}\n\nEXPORT_SYMBOL(nv_alloc_init);\nEXPORT_SYMBOL(nv_alloc_reset);\nEXPORT_SYMBOL(nv_alloc_fini);\n\n \nEXPORT_SYMBOL(nvlist_alloc);\nEXPORT_SYMBOL(nvlist_free);\nEXPORT_SYMBOL(nvlist_size);\nEXPORT_SYMBOL(nvlist_pack);\nEXPORT_SYMBOL(nvlist_unpack);\nEXPORT_SYMBOL(nvlist_dup);\nEXPORT_SYMBOL(nvlist_merge);\n\nEXPORT_SYMBOL(nvlist_xalloc);\nEXPORT_SYMBOL(nvlist_xpack);\nEXPORT_SYMBOL(nvlist_xunpack);\nEXPORT_SYMBOL(nvlist_xdup);\nEXPORT_SYMBOL(nvlist_lookup_nv_alloc);\n\nEXPORT_SYMBOL(nvlist_add_nvpair);\nEXPORT_SYMBOL(nvlist_add_boolean);\nEXPORT_SYMBOL(nvlist_add_boolean_value);\nEXPORT_SYMBOL(nvlist_add_byte);\nEXPORT_SYMBOL(nvlist_add_int8);\nEXPORT_SYMBOL(nvlist_add_uint8);\nEXPORT_SYMBOL(nvlist_add_int16);\nEXPORT_SYMBOL(nvlist_add_uint16);\nEXPORT_SYMBOL(nvlist_add_int32);\nEXPORT_SYMBOL(nvlist_add_uint32);\nEXPORT_SYMBOL(nvlist_add_int64);\nEXPORT_SYMBOL(nvlist_add_uint64);\nEXPORT_SYMBOL(nvlist_add_string);\nEXPORT_SYMBOL(nvlist_add_nvlist);\nEXPORT_SYMBOL(nvlist_add_boolean_array);\nEXPORT_SYMBOL(nvlist_add_byte_array);\nEXPORT_SYMBOL(nvlist_add_int8_array);\nEXPORT_SYMBOL(nvlist_add_uint8_array);\nEXPORT_SYMBOL(nvlist_add_int16_array);\nEXPORT_SYMBOL(nvlist_add_uint16_array);\nEXPORT_SYMBOL(nvlist_add_int32_array);\nEXPORT_SYMBOL(nvlist_add_uint32_array);\nEXPORT_SYMBOL(nvlist_add_int64_array);\nEXPORT_SYMBOL(nvlist_add_uint64_array);\nEXPORT_SYMBOL(nvlist_add_string_array);\nEXPORT_SYMBOL(nvlist_add_nvlist_array);\nEXPORT_SYMBOL(nvlist_next_nvpair);\nEXPORT_SYMBOL(nvlist_prev_nvpair);\nEXPORT_SYMBOL(nvlist_empty);\nEXPORT_SYMBOL(nvlist_add_hrtime);\n\nEXPORT_SYMBOL(nvlist_remove);\nEXPORT_SYMBOL(nvlist_remove_nvpair);\nEXPORT_SYMBOL(nvlist_remove_all);\n\nEXPORT_SYMBOL(nvlist_lookup_boolean);\nEXPORT_SYMBOL(nvlist_lookup_boolean_value);\nEXPORT_SYMBOL(nvlist_lookup_byte);\nEXPORT_SYMBOL(nvlist_lookup_int8);\nEXPORT_SYMBOL(nvlist_lookup_uint8);\nEXPORT_SYMBOL(nvlist_lookup_int16);\nEXPORT_SYMBOL(nvlist_lookup_uint16);\nEXPORT_SYMBOL(nvlist_lookup_int32);\nEXPORT_SYMBOL(nvlist_lookup_uint32);\nEXPORT_SYMBOL(nvlist_lookup_int64);\nEXPORT_SYMBOL(nvlist_lookup_uint64);\nEXPORT_SYMBOL(nvlist_lookup_string);\nEXPORT_SYMBOL(nvlist_lookup_nvlist);\nEXPORT_SYMBOL(nvlist_lookup_boolean_array);\nEXPORT_SYMBOL(nvlist_lookup_byte_array);\nEXPORT_SYMBOL(nvlist_lookup_int8_array);\nEXPORT_SYMBOL(nvlist_lookup_uint8_array);\nEXPORT_SYMBOL(nvlist_lookup_int16_array);\nEXPORT_SYMBOL(nvlist_lookup_uint16_array);\nEXPORT_SYMBOL(nvlist_lookup_int32_array);\nEXPORT_SYMBOL(nvlist_lookup_uint32_array);\nEXPORT_SYMBOL(nvlist_lookup_int64_array);\nEXPORT_SYMBOL(nvlist_lookup_uint64_array);\nEXPORT_SYMBOL(nvlist_lookup_string_array);\nEXPORT_SYMBOL(nvlist_lookup_nvlist_array);\nEXPORT_SYMBOL(nvlist_lookup_hrtime);\nEXPORT_SYMBOL(nvlist_lookup_pairs);\n\nEXPORT_SYMBOL(nvlist_lookup_nvpair);\nEXPORT_SYMBOL(nvlist_exists);\n\n \nEXPORT_SYMBOL(nvpair_name);\nEXPORT_SYMBOL(nvpair_type);\nEXPORT_SYMBOL(nvpair_value_boolean_value);\nEXPORT_SYMBOL(nvpair_value_byte);\nEXPORT_SYMBOL(nvpair_value_int8);\nEXPORT_SYMBOL(nvpair_value_uint8);\nEXPORT_SYMBOL(nvpair_value_int16);\nEXPORT_SYMBOL(nvpair_value_uint16);\nEXPORT_SYMBOL(nvpair_value_int32);\nEXPORT_SYMBOL(nvpair_value_uint32);\nEXPORT_SYMBOL(nvpair_value_int64);\nEXPORT_SYMBOL(nvpair_value_uint64);\nEXPORT_SYMBOL(nvpair_value_string);\nEXPORT_SYMBOL(nvpair_value_nvlist);\nEXPORT_SYMBOL(nvpair_value_boolean_array);\nEXPORT_SYMBOL(nvpair_value_byte_array);\nEXPORT_SYMBOL(nvpair_value_int8_array);\nEXPORT_SYMBOL(nvpair_value_uint8_array);\nEXPORT_SYMBOL(nvpair_value_int16_array);\nEXPORT_SYMBOL(nvpair_value_uint16_array);\nEXPORT_SYMBOL(nvpair_value_int32_array);\nEXPORT_SYMBOL(nvpair_value_uint32_array);\nEXPORT_SYMBOL(nvpair_value_int64_array);\nEXPORT_SYMBOL(nvpair_value_uint64_array);\nEXPORT_SYMBOL(nvpair_value_string_array);\nEXPORT_SYMBOL(nvpair_value_nvlist_array);\nEXPORT_SYMBOL(nvpair_value_hrtime);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}