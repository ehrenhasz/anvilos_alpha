{
  "module_name": "avl.c",
  "hash_id": "59b81f4aee1f2d572672bcdd066facdd8320c872282d2aea0d1a00ea16799d03",
  "original_prompt": "Ingested from zfs-2.2.2/module/avl/avl.c",
  "human_readable_source": " \n \n\n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/debug.h>\n#include <sys/avl.h>\n#include <sys/cmn_err.h>\n#include <sys/mod.h>\n\n#ifndef _KERNEL\n#include <string.h>\n#endif\n\n \nvoid *\navl_walk(avl_tree_t *tree, void\t*oldnode, int left)\n{\n\tsize_t off = tree->avl_offset;\n\tavl_node_t *node = AVL_DATA2NODE(oldnode, off);\n\tint right = 1 - left;\n\tint was_child;\n\n\n\t \n\tif (node == NULL)\n\t\treturn (NULL);\n\n\t \n\tif (node->avl_child[left] != NULL) {\n\t\tfor (node = node->avl_child[left];\n\t\t    node->avl_child[right] != NULL;\n\t\t    node = node->avl_child[right])\n\t\t\t;\n\t \n\t} else {\n\t\tfor (;;) {\n\t\t\twas_child = AVL_XCHILD(node);\n\t\t\tnode = AVL_XPARENT(node);\n\t\t\tif (node == NULL)\n\t\t\t\treturn (NULL);\n\t\t\tif (was_child == right)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (AVL_NODE2DATA(node, off));\n}\n\n \nvoid *\navl_first(avl_tree_t *tree)\n{\n\tavl_node_t *node;\n\tavl_node_t *prev = NULL;\n\tsize_t off = tree->avl_offset;\n\n\tfor (node = tree->avl_root; node != NULL; node = node->avl_child[0])\n\t\tprev = node;\n\n\tif (prev != NULL)\n\t\treturn (AVL_NODE2DATA(prev, off));\n\treturn (NULL);\n}\n\n \nvoid *\navl_last(avl_tree_t *tree)\n{\n\tavl_node_t *node;\n\tavl_node_t *prev = NULL;\n\tsize_t off = tree->avl_offset;\n\n\tfor (node = tree->avl_root; node != NULL; node = node->avl_child[1])\n\t\tprev = node;\n\n\tif (prev != NULL)\n\t\treturn (AVL_NODE2DATA(prev, off));\n\treturn (NULL);\n}\n\n \nvoid *\navl_nearest(avl_tree_t *tree, avl_index_t where, int direction)\n{\n\tint child = AVL_INDEX2CHILD(where);\n\tavl_node_t *node = AVL_INDEX2NODE(where);\n\tvoid *data;\n\tsize_t off = tree->avl_offset;\n\n\tif (node == NULL) {\n\t\tASSERT(tree->avl_root == NULL);\n\t\treturn (NULL);\n\t}\n\tdata = AVL_NODE2DATA(node, off);\n\tif (child != direction)\n\t\treturn (data);\n\n\treturn (avl_walk(tree, data, direction));\n}\n\n\n \nvoid *\navl_find(avl_tree_t *tree, const void *value, avl_index_t *where)\n{\n\tavl_node_t *node;\n\tavl_node_t *prev = NULL;\n\tint child = 0;\n\tint diff;\n\tsize_t off = tree->avl_offset;\n\n\tfor (node = tree->avl_root; node != NULL;\n\t    node = node->avl_child[child]) {\n\n\t\tprev = node;\n\n\t\tdiff = tree->avl_compar(value, AVL_NODE2DATA(node, off));\n\t\tASSERT(-1 <= diff && diff <= 1);\n\t\tif (diff == 0) {\n#ifdef ZFS_DEBUG\n\t\t\tif (where != NULL)\n\t\t\t\t*where = 0;\n#endif\n\t\t\treturn (AVL_NODE2DATA(node, off));\n\t\t}\n\t\tchild = (diff > 0);\n\t}\n\n\tif (where != NULL)\n\t\t*where = AVL_MKINDEX(prev, child);\n\n\treturn (NULL);\n}\n\n\n \nstatic int\navl_rotation(avl_tree_t *tree, avl_node_t *node, int balance)\n{\n\tint left = !(balance < 0);\t \n\tint right = 1 - left;\n\tint left_heavy = balance >> 1;\n\tint right_heavy = -left_heavy;\n\tavl_node_t *parent = AVL_XPARENT(node);\n\tavl_node_t *child = node->avl_child[left];\n\tavl_node_t *cright;\n\tavl_node_t *gchild;\n\tavl_node_t *gright;\n\tavl_node_t *gleft;\n\tint which_child = AVL_XCHILD(node);\n\tint child_bal = AVL_XBALANCE(child);\n\n\t \n\tif (child_bal != right_heavy) {\n\n\t\t \n\t\tchild_bal += right_heavy;  \n\n\t\t \n\t\tcright = child->avl_child[right];\n\t\tnode->avl_child[left] = cright;\n\t\tif (cright != NULL) {\n\t\t\tAVL_SETPARENT(cright, node);\n\t\t\tAVL_SETCHILD(cright, left);\n\t\t}\n\n\t\t \n\t\tchild->avl_child[right] = node;\n\t\tAVL_SETBALANCE(node, -child_bal);\n\t\tAVL_SETCHILD(node, right);\n\t\tAVL_SETPARENT(node, child);\n\n\t\t \n\t\tAVL_SETBALANCE(child, child_bal);\n\t\tAVL_SETCHILD(child, which_child);\n\t\tAVL_SETPARENT(child, parent);\n\t\tif (parent != NULL)\n\t\t\tparent->avl_child[which_child] = child;\n\t\telse\n\t\t\ttree->avl_root = child;\n\n\t\treturn (child_bal == 0);\n\t}\n\n\t \n\tgchild = child->avl_child[right];\n\tgleft = gchild->avl_child[left];\n\tgright = gchild->avl_child[right];\n\n\t \n\tnode->avl_child[left] = gright;\n\tif (gright != NULL) {\n\t\tAVL_SETPARENT(gright, node);\n\t\tAVL_SETCHILD(gright, left);\n\t}\n\n\tchild->avl_child[right] = gleft;\n\tif (gleft != NULL) {\n\t\tAVL_SETPARENT(gleft, child);\n\t\tAVL_SETCHILD(gleft, right);\n\t}\n\n\t \n\tbalance = AVL_XBALANCE(gchild);\n\tgchild->avl_child[left] = child;\n\tAVL_SETBALANCE(child, (balance == right_heavy ? left_heavy : 0));\n\tAVL_SETPARENT(child, gchild);\n\tAVL_SETCHILD(child, left);\n\n\tgchild->avl_child[right] = node;\n\tAVL_SETBALANCE(node, (balance == left_heavy ? right_heavy : 0));\n\tAVL_SETPARENT(node, gchild);\n\tAVL_SETCHILD(node, right);\n\n\tAVL_SETBALANCE(gchild, 0);\n\tAVL_SETPARENT(gchild, parent);\n\tAVL_SETCHILD(gchild, which_child);\n\tif (parent != NULL)\n\t\tparent->avl_child[which_child] = gchild;\n\telse\n\t\ttree->avl_root = gchild;\n\n\treturn (1);\t \n}\n\n\n \nvoid\navl_insert(avl_tree_t *tree, void *new_data, avl_index_t where)\n{\n\tavl_node_t *node;\n\tavl_node_t *parent = AVL_INDEX2NODE(where);\n\tint old_balance;\n\tint new_balance;\n\tint which_child = AVL_INDEX2CHILD(where);\n\tsize_t off = tree->avl_offset;\n\n#ifdef _LP64\n\tASSERT(((uintptr_t)new_data & 0x7) == 0);\n#endif\n\n\tnode = AVL_DATA2NODE(new_data, off);\n\n\t \n\t++tree->avl_numnodes;\n\n\tnode->avl_child[0] = NULL;\n\tnode->avl_child[1] = NULL;\n\n\tAVL_SETCHILD(node, which_child);\n\tAVL_SETBALANCE(node, 0);\n\tAVL_SETPARENT(node, parent);\n\tif (parent != NULL) {\n\t\tASSERT(parent->avl_child[which_child] == NULL);\n\t\tparent->avl_child[which_child] = node;\n\t} else {\n\t\tASSERT(tree->avl_root == NULL);\n\t\ttree->avl_root = node;\n\t}\n\t \n\tfor (;;) {\n\t\tnode = parent;\n\t\tif (node == NULL)\n\t\t\treturn;\n\n\t\t \n\t\told_balance = AVL_XBALANCE(node);\n\t\tnew_balance = old_balance + (which_child ? 1 : -1);\n\n\t\t \n\t\tif (new_balance == 0) {\n\t\t\tAVL_SETBALANCE(node, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (old_balance != 0)\n\t\t\tbreak;\n\n\t\tAVL_SETBALANCE(node, new_balance);\n\t\tparent = AVL_XPARENT(node);\n\t\twhich_child = AVL_XCHILD(node);\n\t}\n\n\t \n\t(void) avl_rotation(tree, node, new_balance);\n}\n\n \nvoid\navl_insert_here(\n\tavl_tree_t *tree,\n\tvoid *new_data,\n\tvoid *here,\n\tint direction)\n{\n\tavl_node_t *node;\n\tint child = direction;\t \n#ifdef ZFS_DEBUG\n\tint diff;\n#endif\n\n\tASSERT(tree != NULL);\n\tASSERT(new_data != NULL);\n\tASSERT(here != NULL);\n\tASSERT(direction == AVL_BEFORE || direction == AVL_AFTER);\n\n\t \n\tnode = AVL_DATA2NODE(here, tree->avl_offset);\n\n#ifdef ZFS_DEBUG\n\tdiff = tree->avl_compar(new_data, here);\n\tASSERT(-1 <= diff && diff <= 1);\n\tASSERT(diff != 0);\n\tASSERT(diff > 0 ? child == 1 : child == 0);\n#endif\n\n\tif (node->avl_child[child] != NULL) {\n\t\tnode = node->avl_child[child];\n\t\tchild = 1 - child;\n\t\twhile (node->avl_child[child] != NULL) {\n#ifdef ZFS_DEBUG\n\t\t\tdiff = tree->avl_compar(new_data,\n\t\t\t    AVL_NODE2DATA(node, tree->avl_offset));\n\t\t\tASSERT(-1 <= diff && diff <= 1);\n\t\t\tASSERT(diff != 0);\n\t\t\tASSERT(diff > 0 ? child == 1 : child == 0);\n#endif\n\t\t\tnode = node->avl_child[child];\n\t\t}\n#ifdef ZFS_DEBUG\n\t\tdiff = tree->avl_compar(new_data,\n\t\t    AVL_NODE2DATA(node, tree->avl_offset));\n\t\tASSERT(-1 <= diff && diff <= 1);\n\t\tASSERT(diff != 0);\n\t\tASSERT(diff > 0 ? child == 1 : child == 0);\n#endif\n\t}\n\tASSERT(node->avl_child[child] == NULL);\n\n\tavl_insert(tree, new_data, AVL_MKINDEX(node, child));\n}\n\n \nvoid\navl_add(avl_tree_t *tree, void *new_node)\n{\n\tavl_index_t where = 0;\n\n\tVERIFY(avl_find(tree, new_node, &where) == NULL);\n\n\tavl_insert(tree, new_node, where);\n}\n\n \nvoid\navl_remove(avl_tree_t *tree, void *data)\n{\n\tavl_node_t *delete;\n\tavl_node_t *parent;\n\tavl_node_t *node;\n\tavl_node_t tmp;\n\tint old_balance;\n\tint new_balance;\n\tint left;\n\tint right;\n\tint which_child;\n\tsize_t off = tree->avl_offset;\n\n\tdelete = AVL_DATA2NODE(data, off);\n\n\t \n\tif (delete->avl_child[0] != NULL && delete->avl_child[1] != NULL) {\n\n\t\t \n\t\told_balance = AVL_XBALANCE(delete);\n\t\tleft = (old_balance > 0);\n\t\tright = 1 - left;\n\n\t\t \n\t\tfor (node = delete->avl_child[left];\n\t\t    node->avl_child[right] != NULL;\n\t\t    node = node->avl_child[right])\n\t\t\t;\n\n\t\t \n\t\ttmp = *node;\n\n\t\tmemcpy(node, delete, sizeof (*node));\n\t\tif (node->avl_child[left] == node)\n\t\t\tnode->avl_child[left] = &tmp;\n\n\t\tparent = AVL_XPARENT(node);\n\t\tif (parent != NULL)\n\t\t\tparent->avl_child[AVL_XCHILD(node)] = node;\n\t\telse\n\t\t\ttree->avl_root = node;\n\t\tAVL_SETPARENT(node->avl_child[left], node);\n\t\tAVL_SETPARENT(node->avl_child[right], node);\n\n\t\t \n\t\tdelete = &tmp;\n\t\tparent = AVL_XPARENT(delete);\n\t\tparent->avl_child[AVL_XCHILD(delete)] = delete;\n\t\twhich_child = (delete->avl_child[1] != 0);\n\t\tif (delete->avl_child[which_child] != NULL)\n\t\t\tAVL_SETPARENT(delete->avl_child[which_child], delete);\n\t}\n\n\n\t \n\tASSERT(tree->avl_numnodes > 0);\n\t--tree->avl_numnodes;\n\tparent = AVL_XPARENT(delete);\n\twhich_child = AVL_XCHILD(delete);\n\tif (delete->avl_child[0] != NULL)\n\t\tnode = delete->avl_child[0];\n\telse\n\t\tnode = delete->avl_child[1];\n\n\t \n\tif (node != NULL) {\n\t\tAVL_SETPARENT(node, parent);\n\t\tAVL_SETCHILD(node, which_child);\n\t}\n\tif (parent == NULL) {\n\t\ttree->avl_root = node;\n\t\treturn;\n\t}\n\tparent->avl_child[which_child] = node;\n\n\n\t \n\tdo {\n\n\t\t \n\t\tnode = parent;\n\t\told_balance = AVL_XBALANCE(node);\n\t\tnew_balance = old_balance - (which_child ? 1 : -1);\n\t\tparent = AVL_XPARENT(node);\n\t\twhich_child = AVL_XCHILD(node);\n\n\t\t \n\t\tif (old_balance == 0) {\n\t\t\tAVL_SETBALANCE(node, new_balance);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (new_balance == 0)\n\t\t\tAVL_SETBALANCE(node, new_balance);\n\t\telse if (!avl_rotation(tree, node, new_balance))\n\t\t\tbreak;\n\t} while (parent != NULL);\n}\n\n#define\tAVL_REINSERT(tree, obj)\t\t\\\n\tavl_remove((tree), (obj));\t\\\n\tavl_add((tree), (obj))\n\nboolean_t\navl_update_lt(avl_tree_t *t, void *obj)\n{\n\tvoid *neighbor;\n\n\tASSERT(((neighbor = AVL_NEXT(t, obj)) == NULL) ||\n\t    (t->avl_compar(obj, neighbor) <= 0));\n\n\tneighbor = AVL_PREV(t, obj);\n\tif ((neighbor != NULL) && (t->avl_compar(obj, neighbor) < 0)) {\n\t\tAVL_REINSERT(t, obj);\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nboolean_t\navl_update_gt(avl_tree_t *t, void *obj)\n{\n\tvoid *neighbor;\n\n\tASSERT(((neighbor = AVL_PREV(t, obj)) == NULL) ||\n\t    (t->avl_compar(obj, neighbor) >= 0));\n\n\tneighbor = AVL_NEXT(t, obj);\n\tif ((neighbor != NULL) && (t->avl_compar(obj, neighbor) > 0)) {\n\t\tAVL_REINSERT(t, obj);\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nboolean_t\navl_update(avl_tree_t *t, void *obj)\n{\n\tvoid *neighbor;\n\n\tneighbor = AVL_PREV(t, obj);\n\tif ((neighbor != NULL) && (t->avl_compar(obj, neighbor) < 0)) {\n\t\tAVL_REINSERT(t, obj);\n\t\treturn (B_TRUE);\n\t}\n\n\tneighbor = AVL_NEXT(t, obj);\n\tif ((neighbor != NULL) && (t->avl_compar(obj, neighbor) > 0)) {\n\t\tAVL_REINSERT(t, obj);\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nvoid\navl_swap(avl_tree_t *tree1, avl_tree_t *tree2)\n{\n\tavl_node_t *temp_node;\n\tulong_t temp_numnodes;\n\n\tASSERT3P(tree1->avl_compar, ==, tree2->avl_compar);\n\tASSERT3U(tree1->avl_offset, ==, tree2->avl_offset);\n\n\ttemp_node = tree1->avl_root;\n\ttemp_numnodes = tree1->avl_numnodes;\n\ttree1->avl_root = tree2->avl_root;\n\ttree1->avl_numnodes = tree2->avl_numnodes;\n\ttree2->avl_root = temp_node;\n\ttree2->avl_numnodes = temp_numnodes;\n}\n\n \nvoid\navl_create(avl_tree_t *tree, int (*compar) (const void *, const void *),\n    size_t size, size_t offset)\n{\n\tASSERT(tree);\n\tASSERT(compar);\n\tASSERT(size > 0);\n\tASSERT(size >= offset + sizeof (avl_node_t));\n#ifdef _LP64\n\tASSERT((offset & 0x7) == 0);\n#endif\n\n\ttree->avl_compar = compar;\n\ttree->avl_root = NULL;\n\ttree->avl_numnodes = 0;\n\ttree->avl_offset = offset;\n}\n\n \nvoid\navl_destroy(avl_tree_t *tree)\n{\n\tASSERT(tree);\n\tASSERT(tree->avl_numnodes == 0);\n\tASSERT(tree->avl_root == NULL);\n}\n\n\n \nulong_t\navl_numnodes(avl_tree_t *tree)\n{\n\tASSERT(tree);\n\treturn (tree->avl_numnodes);\n}\n\nboolean_t\navl_is_empty(avl_tree_t *tree)\n{\n\tASSERT(tree);\n\treturn (tree->avl_numnodes == 0);\n}\n\n#define\tCHILDBIT\t(1L)\n\n \nvoid *\navl_destroy_nodes(avl_tree_t *tree, void **cookie)\n{\n\tavl_node_t\t*node;\n\tavl_node_t\t*parent;\n\tint\t\tchild;\n\tvoid\t\t*first;\n\tsize_t\t\toff = tree->avl_offset;\n\n\t \n\tif (*cookie == NULL) {\n\t\tfirst = avl_first(tree);\n\n\t\t \n\t\tif (first == NULL) {\n\t\t\t*cookie = (void *)CHILDBIT;\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tnode = AVL_DATA2NODE(first, off);\n\t\tparent = AVL_XPARENT(node);\n\t\tgoto check_right_side;\n\t}\n\n\t \n\tparent = (avl_node_t *)((uintptr_t)(*cookie) & ~CHILDBIT);\n\tif (parent == NULL) {\n\t\tif (tree->avl_root != NULL) {\n\t\t\tASSERT(tree->avl_numnodes == 1);\n\t\t\ttree->avl_root = NULL;\n\t\t\ttree->avl_numnodes = 0;\n\t\t}\n\t\treturn (NULL);\n\t}\n\n\t \n\tchild = (uintptr_t)(*cookie) & CHILDBIT;\n\tparent->avl_child[child] = NULL;\n\tASSERT(tree->avl_numnodes > 1);\n\t--tree->avl_numnodes;\n\n\t \n\tif (child == 1 || parent->avl_child[1] == NULL) {\n\t\tnode = parent;\n\t\tparent = AVL_XPARENT(parent);\n\t\tgoto done;\n\t}\n\n\t \n\tnode = parent->avl_child[1];\n\twhile (node->avl_child[0] != NULL) {\n\t\tparent = node;\n\t\tnode = node->avl_child[0];\n\t}\n\n\t \ncheck_right_side:\n\tif (node->avl_child[1] != NULL) {\n\t\tASSERT(AVL_XBALANCE(node) == 1);\n\t\tparent = node;\n\t\tnode = node->avl_child[1];\n\t\tASSERT(node->avl_child[0] == NULL &&\n\t\t    node->avl_child[1] == NULL);\n\t} else {\n\t\tASSERT(AVL_XBALANCE(node) <= 0);\n\t}\n\ndone:\n\tif (parent == NULL) {\n\t\t*cookie = (void *)CHILDBIT;\n\t\tASSERT(node == tree->avl_root);\n\t} else {\n\t\t*cookie = (void *)((uintptr_t)parent | AVL_XCHILD(node));\n\t}\n\n\treturn (AVL_NODE2DATA(node, off));\n}\n\nEXPORT_SYMBOL(avl_create);\nEXPORT_SYMBOL(avl_find);\nEXPORT_SYMBOL(avl_insert);\nEXPORT_SYMBOL(avl_insert_here);\nEXPORT_SYMBOL(avl_walk);\nEXPORT_SYMBOL(avl_first);\nEXPORT_SYMBOL(avl_last);\nEXPORT_SYMBOL(avl_nearest);\nEXPORT_SYMBOL(avl_add);\nEXPORT_SYMBOL(avl_swap);\nEXPORT_SYMBOL(avl_is_empty);\nEXPORT_SYMBOL(avl_remove);\nEXPORT_SYMBOL(avl_numnodes);\nEXPORT_SYMBOL(avl_destroy_nodes);\nEXPORT_SYMBOL(avl_destroy);\nEXPORT_SYMBOL(avl_update_lt);\nEXPORT_SYMBOL(avl_update_gt);\nEXPORT_SYMBOL(avl_update);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}