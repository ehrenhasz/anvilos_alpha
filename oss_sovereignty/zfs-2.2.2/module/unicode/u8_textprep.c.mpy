{
  "module_name": "u8_textprep.c",
  "hash_id": "7d4e5191064a9cfa3124faa7efca33757949bd992dee6212bddd58a32bd85f78",
  "original_prompt": "Ingested from zfs-2.2.2/module/unicode/u8_textprep.c",
  "human_readable_source": " \n \n\n \n\n\n\n \n\n#include <sys/types.h>\n#include <sys/string.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/debug.h>\n#include <sys/kmem.h>\n#include <sys/sunddi.h>\n#include <sys/u8_textprep.h>\n#include <sys/byteorder.h>\n#include <sys/errno.h>\n#include <sys/u8_textprep_data.h>\n#include <sys/mod.h>\n\n \n#define\tU8_MB_CUR_MAX\t\t\t(4)\n\n \n#define\tU8_MAX_BYTES_UCS2\t\t(3)\n\n \n#define\tU8_STREAM_SAFE_TEXT_MAX\t\t(128)\n\n \n#define\tU8_MAX_CHARS_A_SEQ\t\t(32)\n#define\tU8_UPPER_LIMIT_IN_A_SEQ\t\t(31)\n\n \n#define\tU8_COMBINING_CLASS_STARTER\t(0)\n\n \n#define\tU8_HANGUL_SYL_FIRST\t\t(0xAC00U)\n#define\tU8_HANGUL_SYL_LAST\t\t(0xD7A3U)\n\n#define\tU8_HANGUL_JAMO_L_FIRST\t\t(0x1100U)\n#define\tU8_HANGUL_JAMO_L_LAST\t\t(0x1112U)\n#define\tU8_HANGUL_JAMO_V_FIRST\t\t(0x1161U)\n#define\tU8_HANGUL_JAMO_V_LAST\t\t(0x1175U)\n#define\tU8_HANGUL_JAMO_T_FIRST\t\t(0x11A7U)\n#define\tU8_HANGUL_JAMO_T_LAST\t\t(0x11C2U)\n\n#define\tU8_HANGUL_V_COUNT\t\t(21)\n#define\tU8_HANGUL_VT_COUNT\t\t(588)\n#define\tU8_HANGUL_T_COUNT\t\t(28)\n\n#define\tU8_HANGUL_JAMO_1ST_BYTE\t\t(0xE1U)\n\n#define\tU8_SAVE_HANGUL_AS_UTF8(s, i, j, k, b) \\\n\t(s)[(i)] = (uchar_t)(0xE0U | ((uint32_t)(b) & 0xF000U) >> 12); \\\n\t(s)[(j)] = (uchar_t)(0x80U | ((uint32_t)(b) & 0x0FC0U) >> 6); \\\n\t(s)[(k)] = (uchar_t)(0x80U | ((uint32_t)(b) & 0x003FU));\n\n#define\tU8_HANGUL_JAMO_L(u) \\\n\t((u) >= U8_HANGUL_JAMO_L_FIRST && (u) <= U8_HANGUL_JAMO_L_LAST)\n\n#define\tU8_HANGUL_JAMO_V(u) \\\n\t((u) >= U8_HANGUL_JAMO_V_FIRST && (u) <= U8_HANGUL_JAMO_V_LAST)\n\n#define\tU8_HANGUL_JAMO_T(u) \\\n\t((u) > U8_HANGUL_JAMO_T_FIRST && (u) <= U8_HANGUL_JAMO_T_LAST)\n\n#define\tU8_HANGUL_JAMO(u) \\\n\t((u) >= U8_HANGUL_JAMO_L_FIRST && (u) <= U8_HANGUL_JAMO_T_LAST)\n\n#define\tU8_HANGUL_SYLLABLE(u) \\\n\t((u) >= U8_HANGUL_SYL_FIRST && (u) <= U8_HANGUL_SYL_LAST)\n\n#define\tU8_HANGUL_COMPOSABLE_L_V(s, u) \\\n\t((s) == U8_STATE_HANGUL_L && U8_HANGUL_JAMO_V((u)))\n\n#define\tU8_HANGUL_COMPOSABLE_LV_T(s, u) \\\n\t((s) == U8_STATE_HANGUL_LV && U8_HANGUL_JAMO_T((u)))\n\n \n#define\tU8_DECOMP_BOTH\t\t\t(0xF5U)\n#define\tU8_DECOMP_CANONICAL\t\t(0xF6U)\n\n \n#define\tU8_16BIT_TABLE_INDICATOR\t(0x8000U)\n\n \n#define\tU8_PUT_3BYTES_INTO_UTF32(u, b1, b2, b3)  \\\n\t(u) = ((((uint32_t)(b1) & 0x0F) << 12) | \\\n\t\t(((uint32_t)(b2) & 0x3F) << 6)  | \\\n\t\t((uint32_t)(b3) & 0x3F));\n\n#define\tU8_SIMPLE_SWAP(a, b, t) \\\n\t(t) = (a); \\\n\t(a) = (b); \\\n\t(b) = (t);\n\n#define\tU8_ASCII_TOUPPER(c) \\\n\t(((c) >= 'a' && (c) <= 'z') ? (c) - 'a' + 'A' : (c))\n\n#define\tU8_ASCII_TOLOWER(c) \\\n\t(((c) >= 'A' && (c) <= 'Z') ? (c) - 'A' + 'a' : (c))\n\n#define\tU8_ISASCII(c)\t\t\t(((uchar_t)(c)) < 0x80U)\n \n#define\tU8_SWAP_COMB_MARKS(a, b) \\\n\tfor (k = 0; k < disp[(a)]; k++) \\\n\t\tu8t[k] = u8s[start[(a)] + k]; \\\n\tfor (k = 0; k < disp[(b)]; k++) \\\n\t\tu8s[start[(a)] + k] = u8s[start[(b)] + k]; \\\n\tstart[(b)] = start[(a)] + disp[(b)]; \\\n\tfor (k = 0; k < disp[(a)]; k++) \\\n\t\tu8s[start[(b)] + k] = u8t[k]; \\\n\tU8_SIMPLE_SWAP(comb_class[(a)], comb_class[(b)], tc); \\\n\tU8_SIMPLE_SWAP(disp[(a)], disp[(b)], tc);\n\n \ntypedef enum {\n\tU8_STATE_START = 0,\n\tU8_STATE_HANGUL_L = 1,\n\tU8_STATE_HANGUL_LV = 2,\n\tU8_STATE_HANGUL_LVT = 3,\n\tU8_STATE_HANGUL_V = 4,\n\tU8_STATE_HANGUL_T = 5,\n\tU8_STATE_COMBINING_MARK = 6\n} u8_normalization_states_t;\n\n \n\n#define\tU8_ILLEGAL_NEXT_BYTE_COMMON(c)\t((c) < 0x80 || (c) > 0xBF)\n\n#define\tI_\t\t\t\tU8_ILLEGAL_CHAR\n#define\tO_\t\t\t\tU8_OUT_OF_RANGE_CHAR\n\nstatic const int8_t u8_number_of_bytes[0x100] = {\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\n \n\tI_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,\n\n \n\tI_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,\n\n \n\tI_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,\n\n \n\tI_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_, I_,\n\n \n\tI_, I_, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n\n \n\t2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n\n \n\t3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n\n \n\t4,  4,  4,  4,  4,  O_, O_, O_, O_, O_, O_, O_, O_, O_, O_, O_,\n};\n\n#undef\tI_\n#undef\tO_\n\nstatic const uint8_t u8_valid_min_2nd_byte[0x100] = {\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n \n\t0,    0,    0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n \n\t0xa0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n \n\t0x90, 0x80, 0x80, 0x80, 0x80, 0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n};\n\nstatic const uint8_t u8_valid_max_2nd_byte[0x100] = {\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n \n\t0,    0,    0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0x9f, 0xbf, 0xbf,\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0x8f, 0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n};\n\n\n \nint\nu8_validate(const char *u8str, size_t n, char **list, int flag, int *errnum)\n{\n\tuchar_t *ib;\n\tuchar_t *ibtail;\n\tuchar_t **p;\n\tuchar_t *s1;\n\tuchar_t *s2;\n\tuchar_t f;\n\tint sz;\n\tsize_t i;\n\tint ret_val;\n\tboolean_t second;\n\tboolean_t no_need_to_validate_entire;\n\tboolean_t check_additional;\n\tboolean_t validate_ucs2_range_only;\n\n\tif (! u8str)\n\t\treturn (0);\n\n\tib = (uchar_t *)u8str;\n\tibtail = ib + n;\n\n\tret_val = 0;\n\n\tno_need_to_validate_entire = ! (flag & U8_VALIDATE_ENTIRE);\n\tcheck_additional = flag & U8_VALIDATE_CHECK_ADDITIONAL;\n\tvalidate_ucs2_range_only = flag & U8_VALIDATE_UCS2_RANGE;\n\n\twhile (ib < ibtail) {\n\t\t \n\t\tsz = u8_number_of_bytes[*ib];\n\t\tif (sz == U8_ILLEGAL_CHAR) {\n\t\t\t*errnum = EILSEQ;\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (sz == U8_OUT_OF_RANGE_CHAR ||\n\t\t    (validate_ucs2_range_only && sz > U8_MAX_BYTES_UCS2)) {\n\t\t\t*errnum = ERANGE;\n\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\tif ((ibtail - ib) < sz) {\n\t\t\t*errnum = EINVAL;\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (sz == 1) {\n\t\t\tib++;\n\t\t\tret_val++;\n\t\t} else {\n\t\t\t \n\t\t\tf = *ib++;\n\t\t\tret_val++;\n\t\t\tsecond = B_TRUE;\n\t\t\tfor (i = 1; i < sz; i++) {\n\t\t\t\tif (second) {\n\t\t\t\t\tif (*ib < u8_valid_min_2nd_byte[f] ||\n\t\t\t\t\t    *ib > u8_valid_max_2nd_byte[f]) {\n\t\t\t\t\t\t*errnum = EILSEQ;\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\tsecond = B_FALSE;\n\t\t\t\t} else if (U8_ILLEGAL_NEXT_BYTE_COMMON(*ib)) {\n\t\t\t\t\t*errnum = EILSEQ;\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\tib++;\n\t\t\t\tret_val++;\n\t\t\t}\n\t\t}\n\n\t\tif (check_additional) {\n\t\t\tfor (p = (uchar_t **)list, i = 0; p[i]; i++) {\n\t\t\t\ts1 = ib - sz;\n\t\t\t\ts2 = p[i];\n\t\t\t\twhile (s1 < ib) {\n\t\t\t\t\tif (*s1 != *s2 || *s2 == '\\0')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ts1++;\n\t\t\t\t\ts2++;\n\t\t\t\t}\n\n\t\t\t\tif (s1 >= ib && *s2 == '\\0') {\n\t\t\t\t\t*errnum = EBADF;\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (no_need_to_validate_entire)\n\t\t\tbreak;\n\t}\n\n\treturn (ret_val);\n}\n\n \nstatic size_t\ndo_case_conv(int uv, uchar_t *u8s, uchar_t *s, int sz, boolean_t is_it_toupper)\n{\n\tsize_t i;\n\tuint16_t b1 = 0;\n\tuint16_t b2 = 0;\n\tuint16_t b3 = 0;\n\tuint16_t b3_tbl;\n\tuint16_t b3_base;\n\tuint16_t b4 = 0;\n\tsize_t start_id;\n\tsize_t end_id;\n\n\t \n\tif (sz == 2) {\n\t\tb3 = u8s[0] = s[0];\n\t\tb4 = u8s[1] = s[1];\n\t} else if (sz == 3) {\n\t\tb2 = u8s[0] = s[0];\n\t\tb3 = u8s[1] = s[1];\n\t\tb4 = u8s[2] = s[2];\n\t} else if (sz == 4) {\n\t\tb1 = u8s[0] = s[0];\n\t\tb2 = u8s[1] = s[1];\n\t\tb3 = u8s[2] = s[2];\n\t\tb4 = u8s[3] = s[3];\n\t} else {\n\t\t \n\t\tif (is_it_toupper)\n\t\t\t*u8s = U8_ASCII_TOUPPER(*s);\n\t\telse\n\t\t\t*u8s = U8_ASCII_TOLOWER(*s);\n\t\tu8s[1] = '\\0';\n\n\t\treturn (1);\n\t}\n\tu8s[sz] = '\\0';\n\n\t \n\tb1 = u8_common_b1_tbl[uv][b1];\n\tif (b1 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn ((size_t)sz);\n\n\tb2 = u8_case_common_b2_tbl[uv][b1][b2];\n\tif (b2 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn ((size_t)sz);\n\n\tif (is_it_toupper) {\n\t\tb3_tbl = u8_toupper_b3_tbl[uv][b2][b3].tbl_id;\n\t\tif (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)\n\t\t\treturn ((size_t)sz);\n\n\t\tstart_id = u8_toupper_b4_tbl[uv][b3_tbl][b4];\n\t\tend_id = u8_toupper_b4_tbl[uv][b3_tbl][b4 + 1];\n\n\t\t \n\t\tif (start_id >= end_id || (end_id - start_id) > U8_MB_CUR_MAX)\n\t\t\treturn ((size_t)sz);\n\n\t\tb3_base = u8_toupper_b3_tbl[uv][b2][b3].base;\n\n\t\tfor (i = 0; start_id < end_id; start_id++)\n\t\t\tu8s[i++] = u8_toupper_final_tbl[uv][b3_base + start_id];\n\t} else {\n\t\tb3_tbl = u8_tolower_b3_tbl[uv][b2][b3].tbl_id;\n\t\tif (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)\n\t\t\treturn ((size_t)sz);\n\n\t\tstart_id = u8_tolower_b4_tbl[uv][b3_tbl][b4];\n\t\tend_id = u8_tolower_b4_tbl[uv][b3_tbl][b4 + 1];\n\n\t\tif (start_id >= end_id || (end_id - start_id) > U8_MB_CUR_MAX)\n\t\t\treturn ((size_t)sz);\n\n\t\tb3_base = u8_tolower_b3_tbl[uv][b2][b3].base;\n\n\t\tfor (i = 0; start_id < end_id; start_id++)\n\t\t\tu8s[i++] = u8_tolower_final_tbl[uv][b3_base + start_id];\n\t}\n\n\t \n\tif (i == 0)\n\t\treturn ((size_t)sz);\n\n\tu8s[i] = '\\0';\n\n\treturn (i);\n}\n\n \nstatic int\ndo_case_compare(size_t uv, uchar_t *s1, uchar_t *s2, size_t n1,\n    size_t n2, boolean_t is_it_toupper, int *errnum)\n{\n\tint f;\n\tint sz1;\n\tint sz2;\n\tsize_t j;\n\tsize_t i1;\n\tsize_t i2;\n\tuchar_t u8s1[U8_MB_CUR_MAX + 1];\n\tuchar_t u8s2[U8_MB_CUR_MAX + 1];\n\n\ti1 = i2 = 0;\n\twhile (i1 < n1 && i2 < n2) {\n\t\t \n\t\tsz1 = u8_number_of_bytes[*s1];\n\t\tif (sz1 < 0) {\n\t\t\t*errnum = EILSEQ;\n\t\t\tsz1 = 1;\n\t\t}\n\n\t\t \n\t\tif (sz1 == 1) {\n\t\t\tif (is_it_toupper)\n\t\t\t\tu8s1[0] = U8_ASCII_TOUPPER(*s1);\n\t\t\telse\n\t\t\t\tu8s1[0] = U8_ASCII_TOLOWER(*s1);\n\t\t\ts1++;\n\t\t\tu8s1[1] = '\\0';\n\t\t} else if ((i1 + sz1) > n1) {\n\t\t\t*errnum = EINVAL;\n\t\t\tfor (j = 0; (i1 + j) < n1; )\n\t\t\t\tu8s1[j++] = *s1++;\n\t\t\tu8s1[j] = '\\0';\n\t\t} else {\n\t\t\t(void) do_case_conv(uv, u8s1, s1, sz1, is_it_toupper);\n\t\t\ts1 += sz1;\n\t\t}\n\n\t\t \n\t\tsz2 = u8_number_of_bytes[*s2];\n\t\tif (sz2 < 0) {\n\t\t\t*errnum = EILSEQ;\n\t\t\tsz2 = 1;\n\t\t}\n\n\t\tif (sz2 == 1) {\n\t\t\tif (is_it_toupper)\n\t\t\t\tu8s2[0] = U8_ASCII_TOUPPER(*s2);\n\t\t\telse\n\t\t\t\tu8s2[0] = U8_ASCII_TOLOWER(*s2);\n\t\t\ts2++;\n\t\t\tu8s2[1] = '\\0';\n\t\t} else if ((i2 + sz2) > n2) {\n\t\t\t*errnum = EINVAL;\n\t\t\tfor (j = 0; (i2 + j) < n2; )\n\t\t\t\tu8s2[j++] = *s2++;\n\t\t\tu8s2[j] = '\\0';\n\t\t} else {\n\t\t\t(void) do_case_conv(uv, u8s2, s2, sz2, is_it_toupper);\n\t\t\ts2 += sz2;\n\t\t}\n\n\t\t \n\t\tif (sz1 == 1 && sz2 == 1) {\n\t\t\tif (*u8s1 > *u8s2)\n\t\t\t\treturn (1);\n\t\t\tif (*u8s1 < *u8s2)\n\t\t\t\treturn (-1);\n\t\t} else {\n\t\t\tf = strcmp((const char *)u8s1, (const char *)u8s2);\n\t\t\tif (f != 0)\n\t\t\t\treturn (f);\n\t\t}\n\n\t\t \n\t\ti1 += sz1;\n\t\ti2 += sz2;\n\t}\n\n\t \n\tif (i1 >= n1) {\n\t\tif (i2 >= n2)\n\t\t\treturn (0);\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\n \nstatic uchar_t\ncombining_class(size_t uv, uchar_t *s, size_t sz)\n{\n\tuint16_t b1 = 0;\n\tuint16_t b2 = 0;\n\tuint16_t b3 = 0;\n\tuint16_t b4 = 0;\n\n\tif (sz == 1 || sz > 4)\n\t\treturn (0);\n\n\tif (sz == 2) {\n\t\tb3 = s[0];\n\t\tb4 = s[1];\n\t} else if (sz == 3) {\n\t\tb2 = s[0];\n\t\tb3 = s[1];\n\t\tb4 = s[2];\n\t} else if (sz == 4) {\n\t\tb1 = s[0];\n\t\tb2 = s[1];\n\t\tb3 = s[2];\n\t\tb4 = s[3];\n\t}\n\n\tb1 = u8_common_b1_tbl[uv][b1];\n\tif (b1 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn (0);\n\n\tb2 = u8_combining_class_b2_tbl[uv][b1][b2];\n\tif (b2 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn (0);\n\n\tb3 = u8_combining_class_b3_tbl[uv][b2][b3];\n\tif (b3 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn (0);\n\n\treturn (u8_combining_class_b4_tbl[uv][b3][b4]);\n}\n\n \nstatic size_t\ndo_decomp(size_t uv, uchar_t *u8s, uchar_t *s, int sz,\n    boolean_t canonical_decomposition, u8_normalization_states_t *state)\n{\n\tuint16_t b1 = 0;\n\tuint16_t b2 = 0;\n\tuint16_t b3 = 0;\n\tuint16_t b3_tbl;\n\tuint16_t b3_base;\n\tuint16_t b4 = 0;\n\tsize_t start_id;\n\tsize_t end_id;\n\tsize_t i;\n\tuint32_t u1;\n\n\tif (sz == 2) {\n\t\tb3 = u8s[0] = s[0];\n\t\tb4 = u8s[1] = s[1];\n\t\tu8s[2] = '\\0';\n\t} else if (sz == 3) {\n\t\t \n\t\tU8_PUT_3BYTES_INTO_UTF32(u1, s[0], s[1], s[2]);\n\n\t\t \n\t\tif (U8_HANGUL_SYLLABLE(u1)) {\n\t\t\tu1 -= U8_HANGUL_SYL_FIRST;\n\n\t\t\tb1 = U8_HANGUL_JAMO_L_FIRST + u1 / U8_HANGUL_VT_COUNT;\n\t\t\tb2 = U8_HANGUL_JAMO_V_FIRST + (u1 % U8_HANGUL_VT_COUNT)\n\t\t\t    / U8_HANGUL_T_COUNT;\n\t\t\tb3 = u1 % U8_HANGUL_T_COUNT;\n\n\t\t\tU8_SAVE_HANGUL_AS_UTF8(u8s, 0, 1, 2, b1);\n\t\t\tU8_SAVE_HANGUL_AS_UTF8(u8s, 3, 4, 5, b2);\n\t\t\tif (b3) {\n\t\t\t\tb3 += U8_HANGUL_JAMO_T_FIRST;\n\t\t\t\tU8_SAVE_HANGUL_AS_UTF8(u8s, 6, 7, 8, b3);\n\n\t\t\t\tu8s[9] = '\\0';\n\t\t\t\t*state = U8_STATE_HANGUL_LVT;\n\t\t\t\treturn (9);\n\t\t\t}\n\n\t\t\tu8s[6] = '\\0';\n\t\t\t*state = U8_STATE_HANGUL_LV;\n\t\t\treturn (6);\n\t\t}\n\n\t\tb2 = u8s[0] = s[0];\n\t\tb3 = u8s[1] = s[1];\n\t\tb4 = u8s[2] = s[2];\n\t\tu8s[3] = '\\0';\n\n\t\t \n\t\tif (U8_HANGUL_JAMO_L(u1)) {\n\t\t\t*state = U8_STATE_HANGUL_L;\n\t\t\treturn (3);\n\t\t}\n\n\t\tif (U8_HANGUL_JAMO_V(u1)) {\n\t\t\tif (*state == U8_STATE_HANGUL_L)\n\t\t\t\t*state = U8_STATE_HANGUL_LV;\n\t\t\telse\n\t\t\t\t*state = U8_STATE_HANGUL_V;\n\t\t\treturn (3);\n\t\t}\n\n\t\tif (U8_HANGUL_JAMO_T(u1)) {\n\t\t\tif (*state == U8_STATE_HANGUL_LV)\n\t\t\t\t*state = U8_STATE_HANGUL_LVT;\n\t\t\telse\n\t\t\t\t*state = U8_STATE_HANGUL_T;\n\t\t\treturn (3);\n\t\t}\n\t} else if (sz == 4) {\n\t\tb1 = u8s[0] = s[0];\n\t\tb2 = u8s[1] = s[1];\n\t\tb3 = u8s[2] = s[2];\n\t\tb4 = u8s[3] = s[3];\n\t\tu8s[4] = '\\0';\n\t} else {\n\t\t \n\t\tu8s[0] = s[0];\n\t\tu8s[1] = '\\0';\n\t\t*state = U8_STATE_START;\n\t\treturn (1);\n\t}\n\n\t \n\t*state = U8_STATE_START;\n\n\t \n\tb1 = u8_common_b1_tbl[uv][b1];\n\tif (b1 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn ((size_t)sz);\n\n\tb2 = u8_decomp_b2_tbl[uv][b1][b2];\n\tif (b2 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn ((size_t)sz);\n\n\tb3_tbl = u8_decomp_b3_tbl[uv][b2][b3].tbl_id;\n\tif (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn ((size_t)sz);\n\n\t \n\tif (b3_tbl >= U8_16BIT_TABLE_INDICATOR) {\n\t\tb3_tbl -= U8_16BIT_TABLE_INDICATOR;\n\t\tstart_id = u8_decomp_b4_16bit_tbl[uv][b3_tbl][b4];\n\t\tend_id = u8_decomp_b4_16bit_tbl[uv][b3_tbl][b4 + 1];\n\t} else {\n\t\t \n\t\tstart_id = u8_decomp_b4_tbl[uv][b3_tbl][b4];\n\t\t \n\t\tend_id = u8_decomp_b4_tbl[uv][b3_tbl][b4 + 1];\n\t}\n\n\t \n\tif (start_id >= end_id)\n\t\treturn ((size_t)sz);\n\n\t \n\n\tb3_base = u8_decomp_b3_tbl[uv][b2][b3].base;\n\n\t \n\tb1 = u8_decomp_final_tbl[uv][b3_base + start_id];\n\n\t \n\tif (canonical_decomposition) {\n\t\t \n\t\tif (b1 < U8_DECOMP_BOTH)\n\t\t\treturn ((size_t)sz);\n\n\t\tstart_id++;\n\n\t\tif (b1 == U8_DECOMP_BOTH) {\n\t\t\tend_id = start_id +\n\t\t\t    u8_decomp_final_tbl[uv][b3_base + start_id];\n\t\t\tstart_id++;\n\t\t}\n\t} else {\n\t\t \n\t\tif (b1 == U8_DECOMP_BOTH) {\n\t\t\tstart_id++;\n\t\t\tstart_id += u8_decomp_final_tbl[uv][b3_base + start_id];\n\t\t} else if (b1 == U8_DECOMP_CANONICAL) {\n\t\t\tstart_id++;\n\t\t}\n\t}\n\n\tfor (i = 0; start_id < end_id; start_id++)\n\t\tu8s[i++] = u8_decomp_final_tbl[uv][b3_base + start_id];\n\tu8s[i] = '\\0';\n\n\treturn (i);\n}\n\n \nstatic uchar_t *\nfind_composition_start(size_t uv, uchar_t *s, size_t sz)\n{\n\tuint16_t b1 = 0;\n\tuint16_t b2 = 0;\n\tuint16_t b3 = 0;\n\tuint16_t b3_tbl;\n\tuint16_t b3_base;\n\tuint16_t b4 = 0;\n\tsize_t start_id;\n\tsize_t end_id;\n\n\tif (sz == 1) {\n\t\tb4 = s[0];\n\t} else if (sz == 2) {\n\t\tb3 = s[0];\n\t\tb4 = s[1];\n\t} else if (sz == 3) {\n\t\tb2 = s[0];\n\t\tb3 = s[1];\n\t\tb4 = s[2];\n\t} else if (sz == 4) {\n\t\tb1 = s[0];\n\t\tb2 = s[1];\n\t\tb3 = s[2];\n\t\tb4 = s[3];\n\t} else {\n\t\t \n\t\treturn (NULL);\n\t}\n\n\tb1 = u8_composition_b1_tbl[uv][b1];\n\tif (b1 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn (NULL);\n\n\tb2 = u8_composition_b2_tbl[uv][b1][b2];\n\tif (b2 == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn (NULL);\n\n\tb3_tbl = u8_composition_b3_tbl[uv][b2][b3].tbl_id;\n\tif (b3_tbl == U8_TBL_ELEMENT_NOT_DEF)\n\t\treturn (NULL);\n\n\tif (b3_tbl >= U8_16BIT_TABLE_INDICATOR) {\n\t\tb3_tbl -= U8_16BIT_TABLE_INDICATOR;\n\t\tstart_id = u8_composition_b4_16bit_tbl[uv][b3_tbl][b4];\n\t\tend_id = u8_composition_b4_16bit_tbl[uv][b3_tbl][b4 + 1];\n\t} else {\n\t\t\n\t\tstart_id = u8_composition_b4_tbl[uv][b3_tbl][b4];\n\t\t\n\t\tend_id = u8_composition_b4_tbl[uv][b3_tbl][b4 + 1];\n\t}\n\n\tif (start_id >= end_id)\n\t\treturn (NULL);\n\n\tb3_base = u8_composition_b3_tbl[uv][b2][b3].base;\n\n\treturn ((uchar_t *)&(u8_composition_final_tbl[uv][b3_base + start_id]));\n}\n\n \nstatic boolean_t\nblocked(uchar_t *comb_class, size_t last)\n{\n\tuchar_t my_comb_class;\n\tsize_t i;\n\n\tmy_comb_class = comb_class[last];\n\tfor (i = 1; i < last; i++)\n\t\tif (comb_class[i] >= my_comb_class ||\n\t\t    comb_class[i] == U8_COMBINING_CLASS_STARTER)\n\t\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\n \nstatic size_t\ndo_composition(size_t uv, uchar_t *s, uchar_t *comb_class, uchar_t *start,\n    uchar_t *disp, size_t last, uchar_t **os, uchar_t *oslast)\n{\n\tuchar_t t[U8_STREAM_SAFE_TEXT_MAX + 1];\n\tuchar_t tc[U8_MB_CUR_MAX] = { '\\0' };\n\tuint8_t saved_marks[U8_MAX_CHARS_A_SEQ];\n\tsize_t saved_marks_count;\n\tuchar_t *p;\n\tuchar_t *saved_p;\n\tuchar_t *q;\n\tsize_t i;\n\tsize_t saved_i;\n\tsize_t j;\n\tsize_t k;\n\tsize_t l;\n\tsize_t C;\n\tsize_t saved_l;\n\tsize_t size;\n\tuint32_t u1;\n\tuint32_t u2;\n\tboolean_t match_not_found = B_TRUE;\n\n\t \n\tif (last >= U8_MAX_CHARS_A_SEQ)\n\t\tlast = U8_UPPER_LIMIT_IN_A_SEQ;\n\n\tfor (i = l = 0; i <= last; i++) {\n\t\t \n\t\tif (i >= last || comb_class[i] != U8_COMBINING_CLASS_STARTER) {\nSAVE_THE_CHAR:\n\t\t\tp = s + start[i];\n\t\t\tsize = disp[i];\n\t\t\tfor (k = 0; k < size; k++)\n\t\t\t\tt[l++] = *p++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (s[start[i]] == U8_HANGUL_JAMO_1ST_BYTE) {\n\t\t\tU8_PUT_3BYTES_INTO_UTF32(u1, s[start[i]],\n\t\t\t    s[start[i] + 1], s[start[i] + 2]);\n\t\t\tU8_PUT_3BYTES_INTO_UTF32(u2, s[start[i] + 3],\n\t\t\t    s[start[i] + 4], s[start[i] + 5]);\n\n\t\t\tif (U8_HANGUL_JAMO_L(u1) && U8_HANGUL_JAMO_V(u2)) {\n\t\t\t\tu1 -= U8_HANGUL_JAMO_L_FIRST;\n\t\t\t\tu2 -= U8_HANGUL_JAMO_V_FIRST;\n\t\t\t\tu1 = U8_HANGUL_SYL_FIRST +\n\t\t\t\t    (u1 * U8_HANGUL_V_COUNT + u2) *\n\t\t\t\t    U8_HANGUL_T_COUNT;\n\n\t\t\t\ti += 2;\n\t\t\t\tif (i <= last) {\n\t\t\t\t\tU8_PUT_3BYTES_INTO_UTF32(u2,\n\t\t\t\t\t    s[start[i]], s[start[i] + 1],\n\t\t\t\t\t    s[start[i] + 2]);\n\n\t\t\t\t\tif (U8_HANGUL_JAMO_T(u2)) {\n\t\t\t\t\t\tu1 += u2 -\n\t\t\t\t\t\t    U8_HANGUL_JAMO_T_FIRST;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tU8_SAVE_HANGUL_AS_UTF8(t + l, 0, 1, 2, u1);\n\t\t\t\ti--;\n\t\t\t\tl += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tp = find_composition_start(uv, s + start[i], disp[i]);\n\t\tif (p == NULL)\n\t\t\tgoto SAVE_THE_CHAR;\n\n\t\t \n\n\t\tsaved_p = p;\n\t\tsaved_i = i;\n\t\tsaved_l = l;\n\t\tsaved_marks_count = 0;\n\nTRY_THE_NEXT_MARK:\n\t\tq = s + start[++i];\n\t\tsize = disp[i];\n\n\t\t \n\n\t\tmatch_not_found = B_TRUE;\n\n\t\tfor (C = *p++; C > 0; C--) {\n\t\t\tfor (k = 0; k < size; p++, k++)\n\t\t\t\tif (*p != q[k])\n\t\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (k >= size && *p == U8_TBL_ELEMENT_FILLER) {\n\t\t\t\tmatch_not_found = B_FALSE;\n\n\t\t\t\tl = saved_l;\n\n\t\t\t\twhile (*++p != U8_TBL_ELEMENT_FILLER)\n\t\t\t\t\tt[l++] = *p;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (*p != U8_TBL_ELEMENT_FILLER)\n\t\t\t\twhile (*++p != U8_TBL_ELEMENT_FILLER)\n\t\t\t\t\t;\n\t\t\twhile (*++p != U8_TBL_ELEMENT_FILLER)\n\t\t\t\t;\n\t\t\tp++;\n\t\t}\n\n\t\t \n\n\t\tif (match_not_found) {\n\t\t\tif (comb_class[i] == U8_COMBINING_CLASS_STARTER) {\n\t\t\t\ti--;\n\t\t\t\tgoto SAVE_THE_CHAR;\n\t\t\t}\n\n\t\t\tsaved_marks[saved_marks_count++] = i;\n\t\t}\n\n\t\tif (saved_l == l) {\n\t\t\twhile (i < last) {\n\t\t\t\tif (blocked(comb_class, i + 1))\n\t\t\t\t\tsaved_marks[saved_marks_count++] = ++i;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < last) {\n\t\t\t\tp = saved_p;\n\t\t\t\tgoto TRY_THE_NEXT_MARK;\n\t\t\t}\n\t\t} else if (i < last) {\n\t\t\tp = find_composition_start(uv, t + saved_l,\n\t\t\t    l - saved_l);\n\t\t\tif (p != NULL) {\n\t\t\t\tsaved_p = p;\n\t\t\t\tgoto TRY_THE_NEXT_MARK;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (saved_l == l) {\n\t\t\tp = s + start[saved_i];\n\t\t\tsize = disp[saved_i];\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t\tt[l++] = *p++;\n\t\t}\n\n\t\tfor (k = 0; k < saved_marks_count; k++) {\n\t\t\tp = s + start[saved_marks[k]];\n\t\t\tsize = disp[saved_marks[k]];\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t\tt[l++] = *p++;\n\t\t}\n\t}\n\n\t \n\tif (comb_class[last] == U8_COMBINING_CLASS_STARTER) {\n\t\tp = *os;\n\t\tsaved_l = l - disp[last];\n\n\t\twhile (p < oslast) {\n\t\t\tint8_t number_of_bytes = u8_number_of_bytes[*p];\n\n\t\t\tif (number_of_bytes <= 1)\n\t\t\t\tbreak;\n\t\t\tsize = number_of_bytes;\n\t\t\tif ((p + size) > oslast)\n\t\t\t\tbreak;\n\n\t\t\tsaved_p = p;\n\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\ttc[i] = *p++;\n\n\t\t\tq = find_composition_start(uv, t + saved_l,\n\t\t\t    l - saved_l);\n\t\t\tif (q == NULL) {\n\t\t\t\tp = saved_p;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmatch_not_found = B_TRUE;\n\n\t\t\tfor (C = *q++; C > 0; C--) {\n\t\t\t\tfor (k = 0; k < size; q++, k++)\n\t\t\t\t\tif (*q != tc[k])\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif (k >= size && *q == U8_TBL_ELEMENT_FILLER) {\n\t\t\t\t\tmatch_not_found = B_FALSE;\n\n\t\t\t\t\tl = saved_l;\n\n\t\t\t\t\twhile (*++q != U8_TBL_ELEMENT_FILLER) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (l >=\n\t\t\t\t\t\t    U8_STREAM_SAFE_TEXT_MAX) {\n\t\t\t\t\t\t\tp = saved_p;\n\t\t\t\t\t\t\tgoto SAFE_RETURN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt[l++] = *q;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (*q != U8_TBL_ELEMENT_FILLER)\n\t\t\t\t\twhile (*++q != U8_TBL_ELEMENT_FILLER)\n\t\t\t\t\t\t;\n\t\t\t\twhile (*++q != U8_TBL_ELEMENT_FILLER)\n\t\t\t\t\t;\n\t\t\t\tq++;\n\t\t\t}\n\n\t\t\tif (match_not_found) {\n\t\t\t\tp = saved_p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nSAFE_RETURN:\n\t\t*os = p;\n\t}\n\n\t \n\tfor (i = 0; i < l; i++)\n\t\ts[i] = t[i];\n\ts[l] = '\\0';\n\n\treturn (l);\n}\n\n \nstatic size_t\ncollect_a_seq(size_t uv, uchar_t *u8s, uchar_t **source, uchar_t *slast,\n    boolean_t is_it_toupper,\n    boolean_t is_it_tolower,\n    boolean_t canonical_decomposition,\n    boolean_t compatibility_decomposition,\n    boolean_t canonical_composition,\n    int *errnum, u8_normalization_states_t *state)\n{\n\tuchar_t *s;\n\tint sz;\n\tint saved_sz;\n\tsize_t i;\n\tsize_t j;\n\tsize_t k;\n\tsize_t l;\n\tuchar_t comb_class[U8_MAX_CHARS_A_SEQ];\n\tuchar_t disp[U8_MAX_CHARS_A_SEQ];\n\tuchar_t start[U8_MAX_CHARS_A_SEQ];\n\tuchar_t u8t[U8_MB_CUR_MAX] = { '\\0' };\n\tuchar_t uts[U8_STREAM_SAFE_TEXT_MAX + 1];\n\tuchar_t tc;\n\tsize_t last;\n\tsize_t saved_last;\n\tuint32_t u1;\n\n\t \n\ts = *source;\n\n\t \n\tif (s >= slast) {\n\t\tu8s[0] = '\\0';\n\n\t\treturn (0);\n\t}\n\n\t \n\n\tsz = u8_number_of_bytes[*s];\n\n\tif (sz < 0) {\n\t\t*errnum = EILSEQ;\n\n\t\tu8s[0] = *s++;\n\t\tu8s[1] = '\\0';\n\n\t\t*source = s;\n\n\t\treturn (1);\n\t}\n\n\tif (sz == 1) {\n\t\tif (is_it_toupper)\n\t\t\tu8s[0] = U8_ASCII_TOUPPER(*s);\n\t\telse if (is_it_tolower)\n\t\t\tu8s[0] = U8_ASCII_TOLOWER(*s);\n\t\telse\n\t\t\tu8s[0] = *s;\n\t\ts++;\n\t\tu8s[1] = '\\0';\n\t} else if ((s + sz) > slast) {\n\t\t*errnum = EINVAL;\n\n\t\tfor (i = 0; s < slast; )\n\t\t\tu8s[i++] = *s++;\n\t\tu8s[i] = '\\0';\n\n\t\t*source = s;\n\n\t\treturn (i);\n\t} else {\n\t\tif (is_it_toupper || is_it_tolower) {\n\t\t\ti = do_case_conv(uv, u8s, s, sz, is_it_toupper);\n\t\t\ts += sz;\n\t\t\tsz = i;\n\t\t} else {\n\t\t\tfor (i = 0; i < sz; )\n\t\t\t\tu8s[i++] = *s++;\n\t\t\tu8s[i] = '\\0';\n\t\t}\n\t}\n\n\t \n\tif (canonical_decomposition || compatibility_decomposition) {\n\t\tif (sz == 1) {\n\t\t\t*state = U8_STATE_START;\n\n\t\t\tsaved_sz = 1;\n\n\t\t\tcomb_class[0] = 0;\n\t\t\tstart[0] = 0;\n\t\t\tdisp[0] = 1;\n\n\t\t\tlast = 1;\n\t\t} else {\n\t\t\tsaved_sz = do_decomp(uv, u8s, u8s, sz,\n\t\t\t    canonical_decomposition, state);\n\n\t\t\tlast = 0;\n\n\t\t\tfor (i = 0; i < saved_sz; ) {\n\t\t\t\tsz = u8_number_of_bytes[u8s[i]];\n\n\t\t\t\tcomb_class[last] = combining_class(uv,\n\t\t\t\t    u8s + i, sz);\n\t\t\t\tstart[last] = i;\n\t\t\t\tdisp[last] = sz;\n\n\t\t\t\tlast++;\n\t\t\t\ti += sz;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (*state == U8_STATE_START) {\n\t\t\t\tif (comb_class[last - 1])\n\t\t\t\t\t*state = U8_STATE_COMBINING_MARK;\n\t\t\t}\n\t\t}\n\n\t\tsaved_last = last;\n\n\t\twhile (s < slast) {\n\t\t\tsz = u8_number_of_bytes[*s];\n\n\t\t\t \n\t\t\tif (sz <= 1) {\n\t\t\t\tbreak;\n\t\t\t} else if ((s + sz) > slast) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (*s == U8_HANGUL_JAMO_1ST_BYTE) {\n\t\t\t\t\tU8_PUT_3BYTES_INTO_UTF32(u1,\n\t\t\t\t\t    *s, *(s + 1), *(s + 2));\n\n\t\t\t\t\tif (U8_HANGUL_COMPOSABLE_L_V(*state,\n\t\t\t\t\t    u1)) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t*state = U8_STATE_HANGUL_LV;\n\t\t\t\t\t\tgoto COLLECT_A_HANGUL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (U8_HANGUL_COMPOSABLE_LV_T(*state,\n\t\t\t\t\t    u1)) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t*state = U8_STATE_HANGUL_LVT;\n\t\t\t\t\t\tgoto COLLECT_A_HANGUL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\ti = combining_class(uv, s, sz);\n\t\t\t\tif (i == U8_COMBINING_CLASS_STARTER)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (*state != U8_STATE_START &&\n\t\t\t\t    *state != U8_STATE_COMBINING_MARK)\n\t\t\t\t\tbreak;\n\n\t\t\t\t*state = U8_STATE_COMBINING_MARK;\nCOLLECT_A_HANGUL:\n\t\t\t\t \n\t\t\t\tif (last >= U8_UPPER_LIMIT_IN_A_SEQ) {\nTURN_STREAM_SAFE:\n\t\t\t\t\t*state = U8_STATE_START;\n\t\t\t\t\tcomb_class[last] = 0;\n\t\t\t\t\tstart[last] = saved_sz;\n\t\t\t\t\tdisp[last] = 2;\n\t\t\t\t\tlast++;\n\n\t\t\t\t\tu8s[saved_sz++] = 0xCD;\n\t\t\t\t\tu8s[saved_sz++] = 0x8F;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (*state == U8_STATE_COMBINING_MARK) {\n\t\t\t\t\tk = last;\n\t\t\t\t\tl = sz;\n\t\t\t\t\ti = do_decomp(uv, uts, s, sz,\n\t\t\t\t\t    canonical_decomposition, state);\n\t\t\t\t\tfor (j = 0; j < i; ) {\n\t\t\t\t\t\tsz = u8_number_of_bytes[uts[j]];\n\n\t\t\t\t\t\tcomb_class[last] =\n\t\t\t\t\t\t    combining_class(uv,\n\t\t\t\t\t\t    uts + j, sz);\n\t\t\t\t\t\tstart[last] = saved_sz + j;\n\t\t\t\t\t\tdisp[last] = sz;\n\n\t\t\t\t\t\tlast++;\n\t\t\t\t\t\tif (last >=\n\t\t\t\t\t\t    U8_UPPER_LIMIT_IN_A_SEQ) {\n\t\t\t\t\t\t\tlast = k;\n\t\t\t\t\t\t\tgoto TURN_STREAM_SAFE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj += sz;\n\t\t\t\t\t}\n\n\t\t\t\t\t*state = U8_STATE_COMBINING_MARK;\n\t\t\t\t\tsz = i;\n\t\t\t\t\ts += l;\n\n\t\t\t\t\tfor (i = 0; i < sz; i++)\n\t\t\t\t\t\tu8s[saved_sz++] = uts[i];\n\t\t\t\t} else {\n\t\t\t\t\tcomb_class[last] = i;\n\t\t\t\t\tstart[last] = saved_sz;\n\t\t\t\t\tdisp[last] = sz;\n\t\t\t\t\tlast++;\n\n\t\t\t\t\tfor (i = 0; i < sz; i++)\n\t\t\t\t\t\tu8s[saved_sz++] = *s++;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (is_it_toupper && sz >= 2 &&\n\t\t\t\t    u8s[saved_sz - 2] == 0xCD &&\n\t\t\t\t    u8s[saved_sz - 1] == 0x85) {\n\t\t\t\t\tu8s[saved_sz - 2] = 0xCE;\n\t\t\t\t\tu8s[saved_sz - 1] = 0x99;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlast--;\n\t\tif (last >= saved_last) {\n\t\t\tfor (i = 0; i < last; i++)\n\t\t\t\tfor (j = last; j > i; j--)\n\t\t\t\t\tif (comb_class[j] &&\n\t\t\t\t\t    comb_class[j - 1] > comb_class[j]) {\n\t\t\t\t\t\tU8_SWAP_COMB_MARKS(j - 1, j);\n\t\t\t\t\t}\n\t\t}\n\n\t\t*source = s;\n\n\t\tif (! canonical_composition) {\n\t\t\tu8s[saved_sz] = '\\0';\n\t\t\treturn (saved_sz);\n\t\t}\n\n\t\t \n\t\tsz = do_composition(uv, u8s, comb_class, start, disp, last,\n\t\t    &s, slast);\n\t}\n\n\t*source = s;\n\n\treturn ((size_t)sz);\n}\n\n \nstatic int\ndo_norm_compare(size_t uv, uchar_t *s1, uchar_t *s2, size_t n1, size_t n2,\n    int flag, int *errnum)\n{\n\tint result;\n\tsize_t sz1;\n\tsize_t sz2;\n\tuchar_t u8s1[U8_STREAM_SAFE_TEXT_MAX + 1];\n\tuchar_t u8s2[U8_STREAM_SAFE_TEXT_MAX + 1];\n\tuchar_t *s1last;\n\tuchar_t *s2last;\n\tboolean_t is_it_toupper;\n\tboolean_t is_it_tolower;\n\tboolean_t canonical_decomposition;\n\tboolean_t compatibility_decomposition;\n\tboolean_t canonical_composition;\n\tu8_normalization_states_t state;\n\n\ts1last = s1 + n1;\n\ts2last = s2 + n2;\n\n\tis_it_toupper = flag & U8_TEXTPREP_TOUPPER;\n\tis_it_tolower = flag & U8_TEXTPREP_TOLOWER;\n\tcanonical_decomposition = flag & U8_CANON_DECOMP;\n\tcompatibility_decomposition = flag & U8_COMPAT_DECOMP;\n\tcanonical_composition = flag & U8_CANON_COMP;\n\n\twhile (s1 < s1last && s2 < s2last) {\n\t\t \n\n\t\tif (U8_ISASCII(*s1) && ((s1 + 1) >= s1last ||\n\t\t    ((s1 + 1) < s1last && U8_ISASCII(*(s1 + 1))))) {\n\t\t\tif (is_it_toupper)\n\t\t\t\tu8s1[0] = U8_ASCII_TOUPPER(*s1);\n\t\t\telse if (is_it_tolower)\n\t\t\t\tu8s1[0] = U8_ASCII_TOLOWER(*s1);\n\t\t\telse\n\t\t\t\tu8s1[0] = *s1;\n\t\t\tu8s1[1] = '\\0';\n\t\t\tsz1 = 1;\n\t\t\ts1++;\n\t\t} else {\n\t\t\tstate = U8_STATE_START;\n\t\t\tsz1 = collect_a_seq(uv, u8s1, &s1, s1last,\n\t\t\t    is_it_toupper, is_it_tolower,\n\t\t\t    canonical_decomposition,\n\t\t\t    compatibility_decomposition,\n\t\t\t    canonical_composition, errnum, &state);\n\t\t}\n\n\t\tif (U8_ISASCII(*s2) && ((s2 + 1) >= s2last ||\n\t\t    ((s2 + 1) < s2last && U8_ISASCII(*(s2 + 1))))) {\n\t\t\tif (is_it_toupper)\n\t\t\t\tu8s2[0] = U8_ASCII_TOUPPER(*s2);\n\t\t\telse if (is_it_tolower)\n\t\t\t\tu8s2[0] = U8_ASCII_TOLOWER(*s2);\n\t\t\telse\n\t\t\t\tu8s2[0] = *s2;\n\t\t\tu8s2[1] = '\\0';\n\t\t\tsz2 = 1;\n\t\t\ts2++;\n\t\t} else {\n\t\t\tstate = U8_STATE_START;\n\t\t\tsz2 = collect_a_seq(uv, u8s2, &s2, s2last,\n\t\t\t    is_it_toupper, is_it_tolower,\n\t\t\t    canonical_decomposition,\n\t\t\t    compatibility_decomposition,\n\t\t\t    canonical_composition, errnum, &state);\n\t\t}\n\n\t\t \n\t\tif (sz1 == 1 && sz2 == 1) {\n\t\t\tif (*u8s1 > *u8s2)\n\t\t\t\treturn (1);\n\t\t\tif (*u8s1 < *u8s2)\n\t\t\t\treturn (-1);\n\t\t} else {\n\t\t\tresult = strcmp((const char *)u8s1, (const char *)u8s2);\n\t\t\tif (result != 0)\n\t\t\t\treturn (result);\n\t\t}\n\t}\n\n\t \n\tif (s1 >= s1last) {\n\t\tif (s2 >= s2last)\n\t\t\treturn (0);\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\n \nint\nu8_strcmp(const char *s1, const char *s2, size_t n, int flag, size_t uv,\n    int *errnum)\n{\n\tint f;\n\tsize_t n1;\n\tsize_t n2;\n\n\t*errnum = 0;\n\n\t \n\n\tif (uv > U8_UNICODE_LATEST) {\n\t\t*errnum = ERANGE;\n\t\tuv = U8_UNICODE_LATEST;\n\t}\n\n\tif (flag == 0) {\n\t\tflag = U8_STRCMP_CS;\n\t} else {\n\t\tf = flag & (U8_STRCMP_CS | U8_STRCMP_CI_UPPER |\n\t\t    U8_STRCMP_CI_LOWER);\n\t\tif (f == 0) {\n\t\t\tflag |= U8_STRCMP_CS;\n\t\t} else if (f != U8_STRCMP_CS && f != U8_STRCMP_CI_UPPER &&\n\t\t    f != U8_STRCMP_CI_LOWER) {\n\t\t\t*errnum = EBADF;\n\t\t\tflag = U8_STRCMP_CS;\n\t\t}\n\n\t\tf = flag & (U8_CANON_DECOMP | U8_COMPAT_DECOMP | U8_CANON_COMP);\n\t\tif (f && f != U8_STRCMP_NFD && f != U8_STRCMP_NFC &&\n\t\t    f != U8_STRCMP_NFKD && f != U8_STRCMP_NFKC) {\n\t\t\t*errnum = EBADF;\n\t\t\tflag = U8_STRCMP_CS;\n\t\t}\n\t}\n\n\tif (flag == U8_STRCMP_CS) {\n\t\treturn (n == 0 ? strcmp(s1, s2) : strncmp(s1, s2, n));\n\t}\n\n\tn1 = strlen(s1);\n\tn2 = strlen(s2);\n\tif (n != 0) {\n\t\tif (n < n1)\n\t\t\tn1 = n;\n\t\tif (n < n2)\n\t\t\tn2 = n;\n\t}\n\n\t \n\tif (flag == U8_STRCMP_CI_UPPER) {\n\t\treturn (do_case_compare(uv, (uchar_t *)s1, (uchar_t *)s2,\n\t\t    n1, n2, B_TRUE, errnum));\n\t} else if (flag == U8_STRCMP_CI_LOWER) {\n\t\treturn (do_case_compare(uv, (uchar_t *)s1, (uchar_t *)s2,\n\t\t    n1, n2, B_FALSE, errnum));\n\t}\n\n\treturn (do_norm_compare(uv, (uchar_t *)s1, (uchar_t *)s2, n1, n2,\n\t    flag, errnum));\n}\n\nsize_t\nu8_textprep_str(char *inarray, size_t *inlen, char *outarray, size_t *outlen,\n    int flag, size_t unicode_version, int *errnum)\n{\n\tint f;\n\tint sz;\n\tuchar_t *ib;\n\tuchar_t *ibtail;\n\tuchar_t *ob;\n\tuchar_t *obtail;\n\tboolean_t do_not_ignore_null;\n\tboolean_t do_not_ignore_invalid;\n\tboolean_t is_it_toupper;\n\tboolean_t is_it_tolower;\n\tboolean_t canonical_decomposition;\n\tboolean_t compatibility_decomposition;\n\tboolean_t canonical_composition;\n\tsize_t ret_val;\n\tsize_t i;\n\tsize_t j;\n\tuchar_t u8s[U8_STREAM_SAFE_TEXT_MAX + 1];\n\tu8_normalization_states_t state;\n\n\tif (unicode_version > U8_UNICODE_LATEST) {\n\t\t*errnum = ERANGE;\n\t\treturn ((size_t)-1);\n\t}\n\n\tf = flag & (U8_TEXTPREP_TOUPPER | U8_TEXTPREP_TOLOWER);\n\tif (f == (U8_TEXTPREP_TOUPPER | U8_TEXTPREP_TOLOWER)) {\n\t\t*errnum = EBADF;\n\t\treturn ((size_t)-1);\n\t}\n\n\tf = flag & (U8_CANON_DECOMP | U8_COMPAT_DECOMP | U8_CANON_COMP);\n\tif (f && f != U8_TEXTPREP_NFD && f != U8_TEXTPREP_NFC &&\n\t    f != U8_TEXTPREP_NFKD && f != U8_TEXTPREP_NFKC) {\n\t\t*errnum = EBADF;\n\t\treturn ((size_t)-1);\n\t}\n\n\tif (inarray == NULL || *inlen == 0)\n\t\treturn (0);\n\n\tif (outarray == NULL) {\n\t\t*errnum = E2BIG;\n\t\treturn ((size_t)-1);\n\t}\n\n\tib = (uchar_t *)inarray;\n\tob = (uchar_t *)outarray;\n\tibtail = ib + *inlen;\n\tobtail = ob + *outlen;\n\n\tdo_not_ignore_null = !(flag & U8_TEXTPREP_IGNORE_NULL);\n\tdo_not_ignore_invalid = !(flag & U8_TEXTPREP_IGNORE_INVALID);\n\tis_it_toupper = flag & U8_TEXTPREP_TOUPPER;\n\tis_it_tolower = flag & U8_TEXTPREP_TOLOWER;\n\n\tret_val = 0;\n\n\t \n\tif (f == 0) {\n\t\twhile (ib < ibtail) {\n\t\t\tif (*ib == '\\0' && do_not_ignore_null)\n\t\t\t\tbreak;\n\n\t\t\tsz = u8_number_of_bytes[*ib];\n\n\t\t\tif (sz < 0) {\n\t\t\t\tif (do_not_ignore_invalid) {\n\t\t\t\t\t*errnum = EILSEQ;\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsz = 1;\n\t\t\t\tret_val++;\n\t\t\t}\n\n\t\t\tif (sz == 1) {\n\t\t\t\tif (ob >= obtail) {\n\t\t\t\t\t*errnum = E2BIG;\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (is_it_toupper)\n\t\t\t\t\t*ob = U8_ASCII_TOUPPER(*ib);\n\t\t\t\telse if (is_it_tolower)\n\t\t\t\t\t*ob = U8_ASCII_TOLOWER(*ib);\n\t\t\t\telse\n\t\t\t\t\t*ob = *ib;\n\t\t\t\tib++;\n\t\t\t\tob++;\n\t\t\t} else if ((ib + sz) > ibtail) {\n\t\t\t\tif (do_not_ignore_invalid) {\n\t\t\t\t\t*errnum = EINVAL;\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ((obtail - ob) < (ibtail - ib)) {\n\t\t\t\t\t*errnum = E2BIG;\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tret_val++;\n\n\t\t\t\twhile (ib < ibtail)\n\t\t\t\t\t*ob++ = *ib++;\n\t\t\t} else {\n\t\t\t\tif (is_it_toupper || is_it_tolower) {\n\t\t\t\t\ti = do_case_conv(unicode_version, u8s,\n\t\t\t\t\t    ib, sz, is_it_toupper);\n\n\t\t\t\t\tif ((obtail - ob) < i) {\n\t\t\t\t\t\t*errnum = E2BIG;\n\t\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tib += sz;\n\n\t\t\t\t\tfor (sz = 0; sz < i; sz++)\n\t\t\t\t\t\t*ob++ = u8s[sz];\n\t\t\t\t} else {\n\t\t\t\t\tif ((obtail - ob) < sz) {\n\t\t\t\t\t\t*errnum = E2BIG;\n\t\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = 0; i < sz; i++)\n\t\t\t\t\t\t*ob++ = *ib++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcanonical_decomposition = flag & U8_CANON_DECOMP;\n\t\tcompatibility_decomposition = flag & U8_COMPAT_DECOMP;\n\t\tcanonical_composition = flag & U8_CANON_COMP;\n\n\t\twhile (ib < ibtail) {\n\t\t\tif (*ib == '\\0' && do_not_ignore_null)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (U8_ISASCII(*ib) && ((ib + 1) >= ibtail ||\n\t\t\t    ((ib + 1) < ibtail && U8_ISASCII(*(ib + 1))))) {\n\t\t\t\tif (ob >= obtail) {\n\t\t\t\t\t*errnum = E2BIG;\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (is_it_toupper)\n\t\t\t\t\t*ob = U8_ASCII_TOUPPER(*ib);\n\t\t\t\telse if (is_it_tolower)\n\t\t\t\t\t*ob = U8_ASCII_TOLOWER(*ib);\n\t\t\t\telse\n\t\t\t\t\t*ob = *ib;\n\t\t\t\tib++;\n\t\t\t\tob++;\n\t\t\t} else {\n\t\t\t\t*errnum = 0;\n\t\t\t\tstate = U8_STATE_START;\n\n\t\t\t\tj = collect_a_seq(unicode_version, u8s,\n\t\t\t\t    &ib, ibtail,\n\t\t\t\t    is_it_toupper,\n\t\t\t\t    is_it_tolower,\n\t\t\t\t    canonical_decomposition,\n\t\t\t\t    compatibility_decomposition,\n\t\t\t\t    canonical_composition,\n\t\t\t\t    errnum, &state);\n\n\t\t\t\tif (*errnum && do_not_ignore_invalid) {\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ((obtail - ob) < j) {\n\t\t\t\t\t*errnum = E2BIG;\n\t\t\t\t\tret_val = (size_t)-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < j; i++)\n\t\t\t\t\t*ob++ = u8s[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t*inlen = ibtail - ib;\n\t*outlen = obtail - ob;\n\n\treturn (ret_val);\n}\n\nEXPORT_SYMBOL(u8_validate);\nEXPORT_SYMBOL(u8_strcmp);\nEXPORT_SYMBOL(u8_textprep_str);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}