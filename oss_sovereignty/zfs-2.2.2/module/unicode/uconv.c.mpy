{
  "module_name": "uconv.c",
  "hash_id": "0dda535407f22179615612a1cf94d785a2e8ce557b993197abf38164a43bef7f",
  "original_prompt": "Ingested from zfs-2.2.2/module/unicode/uconv.c",
  "human_readable_source": " \n \n\n\n\n \n\n#include <sys/types.h>\n#ifdef\t_KERNEL\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/debug.h>\n#include <sys/kmem.h>\n#include <sys/sunddi.h>\n#else\n#include <sys/u8_textprep.h>\n#endif\t \n#include <sys/byteorder.h>\n#include <sys/errno.h>\n\n\n \n#define\tUCONV_U16_HI_MIN\t(0xd800U)\n#define\tUCONV_U16_HI_MAX\t(0xdbffU)\n#define\tUCONV_U16_LO_MIN\t(0xdc00U)\n#define\tUCONV_U16_LO_MAX\t(0xdfffU)\n#define\tUCONV_U16_BIT_SHIFT\t(0x0400U)\n#define\tUCONV_U16_BIT_MASK\t(0x0fffffU)\n#define\tUCONV_U16_START\t\t(0x010000U)\n\n \n#define\tUCONV_UNICODE_MAX\t(0x10ffffU)\n#define\tUCONV_ASCII_MAX\t\t(0x7fU)\n\n \n#define\tUCONV_IN_ENDIAN_MASKS\t(UCONV_IN_BIG_ENDIAN | UCONV_IN_LITTLE_ENDIAN)\n#define\tUCONV_OUT_ENDIAN_MASKS\t(UCONV_OUT_BIG_ENDIAN | UCONV_OUT_LITTLE_ENDIAN)\n\n \n#ifdef\t_ZFS_BIG_ENDIAN\n#define\tUCONV_IN_NAT_ENDIAN\tUCONV_IN_BIG_ENDIAN\n#define\tUCONV_IN_REV_ENDIAN\tUCONV_IN_LITTLE_ENDIAN\n#define\tUCONV_OUT_NAT_ENDIAN\tUCONV_OUT_BIG_ENDIAN\n#define\tUCONV_OUT_REV_ENDIAN\tUCONV_OUT_LITTLE_ENDIAN\n#else\n#define\tUCONV_IN_NAT_ENDIAN\tUCONV_IN_LITTLE_ENDIAN\n#define\tUCONV_IN_REV_ENDIAN\tUCONV_IN_BIG_ENDIAN\n#define\tUCONV_OUT_NAT_ENDIAN\tUCONV_OUT_LITTLE_ENDIAN\n#define\tUCONV_OUT_REV_ENDIAN\tUCONV_OUT_BIG_ENDIAN\n#endif\t \n\n \n#define\tUCONV_BOM_NORMAL\t(0xfeffU)\n#define\tUCONV_BOM_SWAPPED\t(0xfffeU)\n#define\tUCONV_BOM_SWAPPED_32\t(0xfffe0000U)\n\n \n#define\tUCONV_U8_ONE_BYTE\t(0x7fU)\n#define\tUCONV_U8_TWO_BYTES\t(0x7ffU)\n#define\tUCONV_U8_THREE_BYTES\t(0xffffU)\n#define\tUCONV_U8_FOUR_BYTES\t(0x10ffffU)\n\n \n#define\tUCONV_U8_BYTE_MIN\t(0x80U)\n#define\tUCONV_U8_BYTE_MAX\t(0xbfU)\n\n \n#define\tUCONV_U8_BIT_SHIFT\t6\n#define\tUCONV_U8_BIT_MASK\t0x3f\n\n \nstatic const uchar_t remaining_bytes_tbl[0x100] = {\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\n \n\t0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\n \n\t1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n\n \n\t2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n\n \n\t3,  3,  3,  3,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0\n};\n\n \nstatic const uchar_t u8_masks_tbl[6] = { 0x00, 0x1f, 0x0f, 0x07, 0x03, 0x01 };\n\n \nstatic const uchar_t valid_min_2nd_byte[0x100] = {\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\n \n\t0,    0,    0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\n \n\t0xa0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\n \n\t0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,\n\n \n\t0x90, 0x80, 0x80, 0x80, 0x80, 0,    0,    0,\n\n\t0,    0,    0,    0,    0,    0,    0,    0\n};\n\nstatic const uchar_t valid_max_2nd_byte[0x100] = {\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\t0,    0,    0,    0,    0,    0,    0,    0,\n\n \n\t0,    0,    0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf,\n\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0x9f, 0xbf, 0xbf,\n\n \n\t0xbf, 0xbf, 0xbf, 0xbf, 0x8f, 0,    0,    0,\n\n\t0,    0,    0,    0,    0,    0,    0,    0\n};\n\n\nstatic int\ncheck_endian(int flag, int *in, int *out)\n{\n\t*in = flag & UCONV_IN_ENDIAN_MASKS;\n\n\t \n\tif (*in == UCONV_IN_ENDIAN_MASKS)\n\t\treturn (EBADF);\n\n\tif (*in == 0)\n\t\t*in = UCONV_IN_NAT_ENDIAN;\n\n\t*out = flag & UCONV_OUT_ENDIAN_MASKS;\n\n\t \n\tif (*out == UCONV_OUT_ENDIAN_MASKS)\n\t\treturn (EBADF);\n\n\tif (*out == 0)\n\t\t*out = UCONV_OUT_NAT_ENDIAN;\n\n\treturn (0);\n}\n\nstatic boolean_t\ncheck_bom16(const uint16_t *u16s, size_t u16l, int *in)\n{\n\tif (u16l > 0) {\n\t\tif (*u16s == UCONV_BOM_NORMAL) {\n\t\t\t*in = UCONV_IN_NAT_ENDIAN;\n\t\t\treturn (B_TRUE);\n\t\t}\n\t\tif (*u16s == UCONV_BOM_SWAPPED) {\n\t\t\t*in = UCONV_IN_REV_ENDIAN;\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic boolean_t\ncheck_bom32(const uint32_t *u32s, size_t u32l, int *in)\n{\n\tif (u32l > 0) {\n\t\tif (*u32s == UCONV_BOM_NORMAL) {\n\t\t\t*in = UCONV_IN_NAT_ENDIAN;\n\t\t\treturn (B_TRUE);\n\t\t}\n\t\tif (*u32s == UCONV_BOM_SWAPPED_32) {\n\t\t\t*in = UCONV_IN_REV_ENDIAN;\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\treturn (B_FALSE);\n}\n\nint\nuconv_u16tou32(const uint16_t *u16s, size_t *utf16len,\n    uint32_t *u32s, size_t *utf32len, int flag)\n{\n\tint inendian;\n\tint outendian;\n\tsize_t u16l;\n\tsize_t u32l;\n\tuint32_t hi;\n\tuint32_t lo;\n\tboolean_t do_not_ignore_null;\n\n\t \n\tif (u16s == NULL || utf16len == NULL)\n\t\treturn (EILSEQ);\n\n\tif (u32s == NULL || utf32len == NULL)\n\t\treturn (E2BIG);\n\n\tif (check_endian(flag, &inendian, &outendian) != 0)\n\t\treturn (EBADF);\n\n\t \n\tu16l = u32l = 0;\n\thi = 0;\n\tdo_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);\n\n\t \n\tif ((flag & UCONV_IN_ACCEPT_BOM) &&\n\t    check_bom16(u16s, *utf16len, &inendian))\n\t\tu16l++;\n\n\t \n\tinendian &= UCONV_IN_NAT_ENDIAN;\n\toutendian &= UCONV_OUT_NAT_ENDIAN;\n\n\t \n\tif (*utf16len > 0 && *utf32len > 0 && (flag & UCONV_OUT_EMIT_BOM))\n\t\tu32s[u32l++] = (outendian) ? UCONV_BOM_NORMAL :\n\t\t    UCONV_BOM_SWAPPED_32;\n\n\t \n\tfor (; u16l < *utf16len; u16l++) {\n\t\tif (u16s[u16l] == 0 && do_not_ignore_null)\n\t\t\tbreak;\n\n\t\tlo = (uint32_t)((inendian) ? u16s[u16l] : BSWAP_16(u16s[u16l]));\n\n\t\tif (lo >= UCONV_U16_HI_MIN && lo <= UCONV_U16_HI_MAX) {\n\t\t\tif (hi)\n\t\t\t\treturn (EILSEQ);\n\t\t\thi = lo;\n\t\t\tcontinue;\n\t\t} else if (lo >= UCONV_U16_LO_MIN && lo <= UCONV_U16_LO_MAX) {\n\t\t\tif (! hi)\n\t\t\t\treturn (EILSEQ);\n\t\t\tlo = (((hi - UCONV_U16_HI_MIN) * UCONV_U16_BIT_SHIFT +\n\t\t\t    lo - UCONV_U16_LO_MIN) & UCONV_U16_BIT_MASK)\n\t\t\t    + UCONV_U16_START;\n\t\t\thi = 0;\n\t\t} else if (hi) {\n\t\t\treturn (EILSEQ);\n\t\t}\n\n\t\tif (u32l >= *utf32len)\n\t\t\treturn (E2BIG);\n\n\t\tu32s[u32l++] = (outendian) ? lo : BSWAP_32(lo);\n\t}\n\n\t \n\tif (hi)\n\t\treturn (EINVAL);\n\n\t \n\t*utf16len = u16l;\n\t*utf32len = u32l;\n\n\treturn (0);\n}\n\nint\nuconv_u16tou8(const uint16_t *u16s, size_t *utf16len,\n    uchar_t *u8s, size_t *utf8len, int flag)\n{\n\tint inendian;\n\tint outendian;\n\tsize_t u16l;\n\tsize_t u8l;\n\tuint32_t hi;\n\tuint32_t lo;\n\tboolean_t do_not_ignore_null;\n\n\tif (u16s == NULL || utf16len == NULL)\n\t\treturn (EILSEQ);\n\n\tif (u8s == NULL || utf8len == NULL)\n\t\treturn (E2BIG);\n\n\tif (check_endian(flag, &inendian, &outendian) != 0)\n\t\treturn (EBADF);\n\n\tu16l = u8l = 0;\n\thi = 0;\n\tdo_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);\n\n\tif ((flag & UCONV_IN_ACCEPT_BOM) &&\n\t    check_bom16(u16s, *utf16len, &inendian))\n\t\tu16l++;\n\n\tinendian &= UCONV_IN_NAT_ENDIAN;\n\n\tfor (; u16l < *utf16len; u16l++) {\n\t\tif (u16s[u16l] == 0 && do_not_ignore_null)\n\t\t\tbreak;\n\n\t\tlo = (uint32_t)((inendian) ? u16s[u16l] : BSWAP_16(u16s[u16l]));\n\n\t\tif (lo >= UCONV_U16_HI_MIN && lo <= UCONV_U16_HI_MAX) {\n\t\t\tif (hi)\n\t\t\t\treturn (EILSEQ);\n\t\t\thi = lo;\n\t\t\tcontinue;\n\t\t} else if (lo >= UCONV_U16_LO_MIN && lo <= UCONV_U16_LO_MAX) {\n\t\t\tif (! hi)\n\t\t\t\treturn (EILSEQ);\n\t\t\tlo = (((hi - UCONV_U16_HI_MIN) * UCONV_U16_BIT_SHIFT +\n\t\t\t    lo - UCONV_U16_LO_MIN) & UCONV_U16_BIT_MASK)\n\t\t\t    + UCONV_U16_START;\n\t\t\thi = 0;\n\t\t} else if (hi) {\n\t\t\treturn (EILSEQ);\n\t\t}\n\n\t\t \n\t\tif (lo <= UCONV_U8_ONE_BYTE) {\n\t\t\tif (u8l >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)lo;\n\t\t} else if (lo <= UCONV_U8_TWO_BYTES) {\n\t\t\tif ((u8l + 1) >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)(0xc0 | ((lo & 0x07c0) >> 6));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 |  (lo & 0x003f));\n\t\t} else if (lo <= UCONV_U8_THREE_BYTES) {\n\t\t\tif ((u8l + 2) >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)(0xe0 | ((lo & 0x0f000) >> 12));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 | ((lo & 0x00fc0) >> 6));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 |  (lo & 0x0003f));\n\t\t} else if (lo <= UCONV_U8_FOUR_BYTES) {\n\t\t\tif ((u8l + 3) >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)(0xf0 | ((lo & 0x01c0000) >> 18));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 | ((lo & 0x003f000) >> 12));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 | ((lo & 0x0000fc0) >> 6));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 |  (lo & 0x000003f));\n\t\t} else {\n\t\t\treturn (EILSEQ);\n\t\t}\n\t}\n\n\tif (hi)\n\t\treturn (EINVAL);\n\n\t*utf16len = u16l;\n\t*utf8len = u8l;\n\n\treturn (0);\n}\n\nint\nuconv_u32tou16(const uint32_t *u32s, size_t *utf32len,\n    uint16_t *u16s, size_t *utf16len, int flag)\n{\n\tint inendian;\n\tint outendian;\n\tsize_t u16l;\n\tsize_t u32l;\n\tuint32_t hi;\n\tuint32_t lo;\n\tboolean_t do_not_ignore_null;\n\n\tif (u32s == NULL || utf32len == NULL)\n\t\treturn (EILSEQ);\n\n\tif (u16s == NULL || utf16len == NULL)\n\t\treturn (E2BIG);\n\n\tif (check_endian(flag, &inendian, &outendian) != 0)\n\t\treturn (EBADF);\n\n\tu16l = u32l = 0;\n\tdo_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);\n\n\tif ((flag & UCONV_IN_ACCEPT_BOM) &&\n\t    check_bom32(u32s, *utf32len, &inendian))\n\t\tu32l++;\n\n\tinendian &= UCONV_IN_NAT_ENDIAN;\n\toutendian &= UCONV_OUT_NAT_ENDIAN;\n\n\tif (*utf32len > 0 && *utf16len > 0 && (flag & UCONV_OUT_EMIT_BOM))\n\t\tu16s[u16l++] = (outendian) ? UCONV_BOM_NORMAL :\n\t\t    UCONV_BOM_SWAPPED;\n\n\tfor (; u32l < *utf32len; u32l++) {\n\t\tif (u32s[u32l] == 0 && do_not_ignore_null)\n\t\t\tbreak;\n\n\t\thi = (inendian) ? u32s[u32l] : BSWAP_32(u32s[u32l]);\n\n\t\t \n\t\tif (hi > UCONV_UNICODE_MAX)\n\t\t\treturn (EILSEQ);\n\n\t\t \n\t\tif (hi >= UCONV_U16_START) {\n\t\t\tlo = ((hi - UCONV_U16_START) % UCONV_U16_BIT_SHIFT) +\n\t\t\t    UCONV_U16_LO_MIN;\n\t\t\thi = ((hi - UCONV_U16_START) / UCONV_U16_BIT_SHIFT) +\n\t\t\t    UCONV_U16_HI_MIN;\n\n\t\t\tif ((u16l + 1) >= *utf16len)\n\t\t\t\treturn (E2BIG);\n\n\t\t\tif (outendian) {\n\t\t\t\tu16s[u16l++] = (uint16_t)hi;\n\t\t\t\tu16s[u16l++] = (uint16_t)lo;\n\t\t\t} else {\n\t\t\t\tu16s[u16l++] = BSWAP_16(((uint16_t)hi));\n\t\t\t\tu16s[u16l++] = BSWAP_16(((uint16_t)lo));\n\t\t\t}\n\t\t} else {\n\t\t\tif (u16l >= *utf16len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu16s[u16l++] = (outendian) ? (uint16_t)hi :\n\t\t\t    BSWAP_16(((uint16_t)hi));\n\t\t}\n\t}\n\n\t*utf16len = u16l;\n\t*utf32len = u32l;\n\n\treturn (0);\n}\n\nint\nuconv_u32tou8(const uint32_t *u32s, size_t *utf32len,\n    uchar_t *u8s, size_t *utf8len, int flag)\n{\n\tint inendian;\n\tint outendian;\n\tsize_t u32l;\n\tsize_t u8l;\n\tuint32_t lo;\n\tboolean_t do_not_ignore_null;\n\n\tif (u32s == NULL || utf32len == NULL)\n\t\treturn (EILSEQ);\n\n\tif (u8s == NULL || utf8len == NULL)\n\t\treturn (E2BIG);\n\n\tif (check_endian(flag, &inendian, &outendian) != 0)\n\t\treturn (EBADF);\n\n\tu32l = u8l = 0;\n\tdo_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);\n\n\tif ((flag & UCONV_IN_ACCEPT_BOM) &&\n\t    check_bom32(u32s, *utf32len, &inendian))\n\t\tu32l++;\n\n\tinendian &= UCONV_IN_NAT_ENDIAN;\n\n\tfor (; u32l < *utf32len; u32l++) {\n\t\tif (u32s[u32l] == 0 && do_not_ignore_null)\n\t\t\tbreak;\n\n\t\tlo = (inendian) ? u32s[u32l] : BSWAP_32(u32s[u32l]);\n\n\t\tif (lo <= UCONV_U8_ONE_BYTE) {\n\t\t\tif (u8l >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)lo;\n\t\t} else if (lo <= UCONV_U8_TWO_BYTES) {\n\t\t\tif ((u8l + 1) >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)(0xc0 | ((lo & 0x07c0) >> 6));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 |  (lo & 0x003f));\n\t\t} else if (lo <= UCONV_U8_THREE_BYTES) {\n\t\t\tif ((u8l + 2) >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)(0xe0 | ((lo & 0x0f000) >> 12));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 | ((lo & 0x00fc0) >> 6));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 |  (lo & 0x0003f));\n\t\t} else if (lo <= UCONV_U8_FOUR_BYTES) {\n\t\t\tif ((u8l + 3) >= *utf8len)\n\t\t\t\treturn (E2BIG);\n\t\t\tu8s[u8l++] = (uchar_t)(0xf0 | ((lo & 0x01c0000) >> 18));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 | ((lo & 0x003f000) >> 12));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 | ((lo & 0x0000fc0) >> 6));\n\t\t\tu8s[u8l++] = (uchar_t)(0x80 |  (lo & 0x000003f));\n\t\t} else {\n\t\t\treturn (EILSEQ);\n\t\t}\n\t}\n\n\t*utf32len = u32l;\n\t*utf8len = u8l;\n\n\treturn (0);\n}\n\nint\nuconv_u8tou16(const uchar_t *u8s, size_t *utf8len,\n    uint16_t *u16s, size_t *utf16len, int flag)\n{\n\tint inendian;\n\tint outendian;\n\tsize_t u16l;\n\tsize_t u8l;\n\tuint32_t hi;\n\tuint32_t lo;\n\tint remaining_bytes;\n\tint first_b;\n\tboolean_t do_not_ignore_null;\n\n\tif (u8s == NULL || utf8len == NULL)\n\t\treturn (EILSEQ);\n\n\tif (u16s == NULL || utf16len == NULL)\n\t\treturn (E2BIG);\n\n\tif (check_endian(flag, &inendian, &outendian) != 0)\n\t\treturn (EBADF);\n\n\tu16l = u8l = 0;\n\tdo_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);\n\n\toutendian &= UCONV_OUT_NAT_ENDIAN;\n\n\tif (*utf8len > 0 && *utf16len > 0 && (flag & UCONV_OUT_EMIT_BOM))\n\t\tu16s[u16l++] = (outendian) ? UCONV_BOM_NORMAL :\n\t\t    UCONV_BOM_SWAPPED;\n\n\tfor (; u8l < *utf8len; ) {\n\t\tif (u8s[u8l] == 0 && do_not_ignore_null)\n\t\t\tbreak;\n\n\t\t \n\t\thi = (uint32_t)u8s[u8l++];\n\n\t\tif (hi > UCONV_ASCII_MAX) {\n\t\t\tif ((remaining_bytes = remaining_bytes_tbl[hi]) == 0)\n\t\t\t\treturn (EILSEQ);\n\n\t\t\tfirst_b = hi;\n\t\t\thi = hi & u8_masks_tbl[remaining_bytes];\n\n\t\t\tfor (; remaining_bytes > 0; remaining_bytes--) {\n\t\t\t\t \n\t\t\t\tif (u8l >= *utf8len)\n\t\t\t\t\treturn (EINVAL);\n\n\t\t\t\tlo = (uint32_t)u8s[u8l++];\n\n\t\t\t\tif (first_b) {\n\t\t\t\t\tif (lo < valid_min_2nd_byte[first_b] ||\n\t\t\t\t\t    lo > valid_max_2nd_byte[first_b])\n\t\t\t\t\t\treturn (EILSEQ);\n\t\t\t\t\tfirst_b = 0;\n\t\t\t\t} else if (lo < UCONV_U8_BYTE_MIN ||\n\t\t\t\t    lo > UCONV_U8_BYTE_MAX) {\n\t\t\t\t\treturn (EILSEQ);\n\t\t\t\t}\n\t\t\t\thi = (hi << UCONV_U8_BIT_SHIFT) |\n\t\t\t\t    (lo & UCONV_U8_BIT_MASK);\n\t\t\t}\n\t\t}\n\n\t\tif (hi >= UCONV_U16_START) {\n\t\t\tlo = ((hi - UCONV_U16_START) % UCONV_U16_BIT_SHIFT) +\n\t\t\t    UCONV_U16_LO_MIN;\n\t\t\thi = ((hi - UCONV_U16_START) / UCONV_U16_BIT_SHIFT) +\n\t\t\t    UCONV_U16_HI_MIN;\n\n\t\t\tif ((u16l + 1) >= *utf16len)\n\t\t\t\treturn (E2BIG);\n\n\t\t\tif (outendian) {\n\t\t\t\tu16s[u16l++] = (uint16_t)hi;\n\t\t\t\tu16s[u16l++] = (uint16_t)lo;\n\t\t\t} else {\n\t\t\t\tu16s[u16l++] = BSWAP_16(((uint16_t)hi));\n\t\t\t\tu16s[u16l++] = BSWAP_16(((uint16_t)lo));\n\t\t\t}\n\t\t} else {\n\t\t\tif (u16l >= *utf16len)\n\t\t\t\treturn (E2BIG);\n\n\t\t\tu16s[u16l++] = (outendian) ? (uint16_t)hi :\n\t\t\t    BSWAP_16(((uint16_t)hi));\n\t\t}\n\t}\n\n\t*utf16len = u16l;\n\t*utf8len = u8l;\n\n\treturn (0);\n}\n\nint\nuconv_u8tou32(const uchar_t *u8s, size_t *utf8len,\n    uint32_t *u32s, size_t *utf32len, int flag)\n{\n\tint inendian;\n\tint outendian;\n\tsize_t u32l;\n\tsize_t u8l;\n\tuint32_t hi;\n\tuint32_t c;\n\tint remaining_bytes;\n\tint first_b;\n\tboolean_t do_not_ignore_null;\n\n\tif (u8s == NULL || utf8len == NULL)\n\t\treturn (EILSEQ);\n\n\tif (u32s == NULL || utf32len == NULL)\n\t\treturn (E2BIG);\n\n\tif (check_endian(flag, &inendian, &outendian) != 0)\n\t\treturn (EBADF);\n\n\tu32l = u8l = 0;\n\tdo_not_ignore_null = ((flag & UCONV_IGNORE_NULL) == 0);\n\n\toutendian &= UCONV_OUT_NAT_ENDIAN;\n\n\tif (*utf8len > 0 && *utf32len > 0 && (flag & UCONV_OUT_EMIT_BOM))\n\t\tu32s[u32l++] = (outendian) ? UCONV_BOM_NORMAL :\n\t\t    UCONV_BOM_SWAPPED_32;\n\n\tfor (; u8l < *utf8len; ) {\n\t\tif (u8s[u8l] == 0 && do_not_ignore_null)\n\t\t\tbreak;\n\n\t\thi = (uint32_t)u8s[u8l++];\n\n\t\tif (hi > UCONV_ASCII_MAX) {\n\t\t\tif ((remaining_bytes = remaining_bytes_tbl[hi]) == 0)\n\t\t\t\treturn (EILSEQ);\n\n\t\t\tfirst_b = hi;\n\t\t\thi = hi & u8_masks_tbl[remaining_bytes];\n\n\t\t\tfor (; remaining_bytes > 0; remaining_bytes--) {\n\t\t\t\tif (u8l >= *utf8len)\n\t\t\t\t\treturn (EINVAL);\n\n\t\t\t\tc = (uint32_t)u8s[u8l++];\n\n\t\t\t\tif (first_b) {\n\t\t\t\t\tif (c < valid_min_2nd_byte[first_b] ||\n\t\t\t\t\t    c > valid_max_2nd_byte[first_b])\n\t\t\t\t\t\treturn (EILSEQ);\n\t\t\t\t\tfirst_b = 0;\n\t\t\t\t} else if (c < UCONV_U8_BYTE_MIN ||\n\t\t\t\t    c > UCONV_U8_BYTE_MAX) {\n\t\t\t\t\treturn (EILSEQ);\n\t\t\t\t}\n\t\t\t\thi = (hi << UCONV_U8_BIT_SHIFT) |\n\t\t\t\t    (c & UCONV_U8_BIT_MASK);\n\t\t\t}\n\t\t}\n\n\t\tif (u32l >= *utf32len)\n\t\t\treturn (E2BIG);\n\n\t\tu32s[u32l++] = (outendian) ? hi : BSWAP_32(hi);\n\t}\n\n\t*utf32len = u32l;\n\t*utf8len = u8l;\n\n\treturn (0);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(uconv_u16tou32);\nEXPORT_SYMBOL(uconv_u16tou8);\nEXPORT_SYMBOL(uconv_u32tou16);\nEXPORT_SYMBOL(uconv_u32tou8);\nEXPORT_SYMBOL(uconv_u8tou16);\nEXPORT_SYMBOL(uconv_u8tou32);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}