{
  "module_name": "vdev_indirect.c",
  "hash_id": "55dae3b7a8660e14b5997fc03707120cb8fb3a6313ee177a0b95ff2b3d2b2eb5",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_indirect.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev_impl.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio.h>\n#include <sys/zio_checksum.h>\n#include <sys/metaslab.h>\n#include <sys/dmu.h>\n#include <sys/vdev_indirect_mapping.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_synctask.h>\n#include <sys/zap.h>\n#include <sys/abd.h>\n#include <sys/zthr.h>\n\n \n\n \n\n \n\nstatic int zfs_condense_indirect_vdevs_enable = B_TRUE;\n\n \nstatic uint_t zfs_condense_indirect_obsolete_pct = 25;\n\n \nstatic uint64_t zfs_condense_max_obsolete_bytes = 1024 * 1024 * 1024;\n\n \nstatic uint64_t zfs_condense_min_mapping_bytes = 128 * 1024;\n\n \nstatic uint_t zfs_condense_indirect_commit_entry_delay_ms = 0;\n\n \nuint_t zfs_reconstruct_indirect_combinations_max = 4096;\n\n \nunsigned long zfs_reconstruct_indirect_damage_fraction = 0;\n\n \ntypedef struct indirect_child {\n\tabd_t *ic_data;\n\tvdev_t *ic_vdev;\n\n\t \n\tstruct indirect_child *ic_duplicate;\n\tlist_node_t ic_node;  \n\tint ic_error;  \n} indirect_child_t;\n\n \ntypedef struct indirect_split {\n\tlist_node_t is_node;  \n\n\t \n\tuint64_t is_split_offset;\n\n\tvdev_t *is_vdev;  \n\tuint64_t is_target_offset;  \n\tuint64_t is_size;\n\tint is_children;  \n\tint is_unique_children;  \n\tlist_t is_unique_child;\n\n\t \n\tindirect_child_t *is_good_child;\n\n\tindirect_child_t is_child[];\n} indirect_split_t;\n\n \ntypedef struct indirect_vsd {\n\tboolean_t iv_split_block;\n\tboolean_t iv_reconstruct;\n\tuint64_t iv_unique_combinations;\n\tuint64_t iv_attempts;\n\tuint64_t iv_attempts_max;\n\n\tlist_t iv_splits;  \n} indirect_vsd_t;\n\nstatic void\nvdev_indirect_map_free(zio_t *zio)\n{\n\tindirect_vsd_t *iv = zio->io_vsd;\n\n\tindirect_split_t *is;\n\twhile ((is = list_remove_head(&iv->iv_splits)) != NULL) {\n\t\tfor (int c = 0; c < is->is_children; c++) {\n\t\t\tindirect_child_t *ic = &is->is_child[c];\n\t\t\tif (ic->ic_data != NULL)\n\t\t\t\tabd_free(ic->ic_data);\n\t\t}\n\n\t\tindirect_child_t *ic;\n\t\twhile ((ic = list_remove_head(&is->is_unique_child)) != NULL)\n\t\t\t;\n\n\t\tlist_destroy(&is->is_unique_child);\n\n\t\tkmem_free(is,\n\t\t    offsetof(indirect_split_t, is_child[is->is_children]));\n\t}\n\tkmem_free(iv, sizeof (*iv));\n}\n\nstatic const zio_vsd_ops_t vdev_indirect_vsd_ops = {\n\t.vsd_free = vdev_indirect_map_free,\n};\n\n \nvoid\nvdev_indirect_mark_obsolete(vdev_t *vd, uint64_t offset, uint64_t size)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT3U(vd->vdev_indirect_config.vic_mapping_object, !=, 0);\n\tASSERT(vd->vdev_removing || vd->vdev_ops == &vdev_indirect_ops);\n\tASSERT(size > 0);\n\tVERIFY(vdev_indirect_mapping_entry_for_offset(\n\t    vd->vdev_indirect_mapping, offset) != NULL);\n\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_OBSOLETE_COUNTS)) {\n\t\tmutex_enter(&vd->vdev_obsolete_lock);\n\t\trange_tree_add(vd->vdev_obsolete_segments, offset, size);\n\t\tmutex_exit(&vd->vdev_obsolete_lock);\n\t\tvdev_dirty(vd, 0, NULL, spa_syncing_txg(spa));\n\t}\n}\n\n \nvoid\nspa_vdev_indirect_mark_obsolete(spa_t *spa, uint64_t vdev_id, uint64_t offset,\n    uint64_t size, dmu_tx_t *tx)\n{\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\t \n\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\tvdev_indirect_mark_obsolete(vd, offset, size);\n}\n\nstatic spa_condensing_indirect_t *\nspa_condensing_indirect_create(spa_t *spa)\n{\n\tspa_condensing_indirect_phys_t *scip =\n\t    &spa->spa_condensing_indirect_phys;\n\tspa_condensing_indirect_t *sci = kmem_zalloc(sizeof (*sci), KM_SLEEP);\n\tobjset_t *mos = spa->spa_meta_objset;\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tlist_create(&sci->sci_new_mapping_entries[i],\n\t\t    sizeof (vdev_indirect_mapping_entry_t),\n\t\t    offsetof(vdev_indirect_mapping_entry_t, vime_node));\n\t}\n\n\tsci->sci_new_mapping =\n\t    vdev_indirect_mapping_open(mos, scip->scip_next_mapping_object);\n\n\treturn (sci);\n}\n\nstatic void\nspa_condensing_indirect_destroy(spa_condensing_indirect_t *sci)\n{\n\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\tlist_destroy(&sci->sci_new_mapping_entries[i]);\n\n\tif (sci->sci_new_mapping != NULL)\n\t\tvdev_indirect_mapping_close(sci->sci_new_mapping);\n\n\tkmem_free(sci, sizeof (*sci));\n}\n\nboolean_t\nvdev_indirect_should_condense(vdev_t *vd)\n{\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(dsl_pool_sync_context(spa->spa_dsl_pool));\n\n\tif (!zfs_condense_indirect_vdevs_enable)\n\t\treturn (B_FALSE);\n\n\t \n\tif (spa->spa_condensing_indirect != NULL)\n\t\treturn (B_FALSE);\n\n\tif (spa_shutting_down(spa))\n\t\treturn (B_FALSE);\n\n\t \n\tif (vd->vdev_ops != &vdev_indirect_ops)\n\t\treturn (B_FALSE);\n\n\t \n\tuint64_t obsolete_sm_obj __maybe_unused;\n\tASSERT0(vdev_obsolete_sm_object(vd, &obsolete_sm_obj));\n\tif (vd->vdev_obsolete_sm == NULL) {\n\t\tASSERT0(obsolete_sm_obj);\n\t\treturn (B_FALSE);\n\t}\n\n\tASSERT(vd->vdev_obsolete_sm != NULL);\n\n\tASSERT3U(obsolete_sm_obj, ==, space_map_object(vd->vdev_obsolete_sm));\n\n\tuint64_t bytes_mapped = vdev_indirect_mapping_bytes_mapped(vim);\n\tuint64_t bytes_obsolete = space_map_allocated(vd->vdev_obsolete_sm);\n\tuint64_t mapping_size = vdev_indirect_mapping_size(vim);\n\tuint64_t obsolete_sm_size = space_map_length(vd->vdev_obsolete_sm);\n\n\tASSERT3U(bytes_obsolete, <=, bytes_mapped);\n\n\t \n\tif (bytes_obsolete * 100 / bytes_mapped >=\n\t    zfs_condense_indirect_obsolete_pct &&\n\t    mapping_size > zfs_condense_min_mapping_bytes) {\n\t\tzfs_dbgmsg(\"should condense vdev %llu because obsolete \"\n\t\t    \"spacemap covers %d%% of %lluMB mapping\",\n\t\t    (u_longlong_t)vd->vdev_id,\n\t\t    (int)(bytes_obsolete * 100 / bytes_mapped),\n\t\t    (u_longlong_t)bytes_mapped / 1024 / 1024);\n\t\treturn (B_TRUE);\n\t}\n\n\t \n\tif (obsolete_sm_size >= zfs_condense_max_obsolete_bytes) {\n\t\tzfs_dbgmsg(\"should condense vdev %llu because obsolete sm \"\n\t\t    \"length %lluMB >= max size %lluMB\",\n\t\t    (u_longlong_t)vd->vdev_id,\n\t\t    (u_longlong_t)obsolete_sm_size / 1024 / 1024,\n\t\t    (u_longlong_t)zfs_condense_max_obsolete_bytes /\n\t\t    1024 / 1024);\n\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic void\nspa_condense_indirect_complete_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_condensing_indirect_t *sci = arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tspa_condensing_indirect_phys_t *scip =\n\t    &spa->spa_condensing_indirect_phys;\n\tvdev_t *vd = vdev_lookup_top(spa, scip->scip_vdev);\n\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tvdev_indirect_mapping_t *old_mapping = vd->vdev_indirect_mapping;\n\tuint64_t old_count = vdev_indirect_mapping_num_entries(old_mapping);\n\tuint64_t new_count =\n\t    vdev_indirect_mapping_num_entries(sci->sci_new_mapping);\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\tASSERT3P(sci, ==, spa->spa_condensing_indirect);\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT(list_is_empty(&sci->sci_new_mapping_entries[i]));\n\t}\n\tASSERT(vic->vic_mapping_object != 0);\n\tASSERT3U(vd->vdev_id, ==, scip->scip_vdev);\n\tASSERT(scip->scip_next_mapping_object != 0);\n\tASSERT(scip->scip_prev_obsolete_sm_object != 0);\n\n\t \n\trw_enter(&vd->vdev_indirect_rwlock, RW_WRITER);\n\tvdev_indirect_mapping_close(vd->vdev_indirect_mapping);\n\tvd->vdev_indirect_mapping = sci->sci_new_mapping;\n\trw_exit(&vd->vdev_indirect_rwlock);\n\n\tsci->sci_new_mapping = NULL;\n\tvdev_indirect_mapping_free(mos, vic->vic_mapping_object, tx);\n\tvic->vic_mapping_object = scip->scip_next_mapping_object;\n\tscip->scip_next_mapping_object = 0;\n\n\tspace_map_free_obj(mos, scip->scip_prev_obsolete_sm_object, tx);\n\tspa_feature_decr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\tscip->scip_prev_obsolete_sm_object = 0;\n\n\tscip->scip_vdev = 0;\n\n\tVERIFY0(zap_remove(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_CONDENSING_INDIRECT, tx));\n\tspa_condensing_indirect_destroy(spa->spa_condensing_indirect);\n\tspa->spa_condensing_indirect = NULL;\n\n\tzfs_dbgmsg(\"finished condense of vdev %llu in txg %llu: \"\n\t    \"new mapping object %llu has %llu entries \"\n\t    \"(was %llu entries)\",\n\t    (u_longlong_t)vd->vdev_id, (u_longlong_t)dmu_tx_get_txg(tx),\n\t    (u_longlong_t)vic->vic_mapping_object,\n\t    (u_longlong_t)new_count, (u_longlong_t)old_count);\n\n\tvdev_config_dirty(spa->spa_root_vdev);\n}\n\n \nstatic void\nspa_condense_indirect_commit_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_condensing_indirect_t *sci = arg;\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tspa_t *spa __maybe_unused = dmu_tx_pool(tx)->dp_spa;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT3P(sci, ==, spa->spa_condensing_indirect);\n\n\tvdev_indirect_mapping_add_entries(sci->sci_new_mapping,\n\t    &sci->sci_new_mapping_entries[txg & TXG_MASK], tx);\n\tASSERT(list_is_empty(&sci->sci_new_mapping_entries[txg & TXG_MASK]));\n}\n\n \nstatic void\nspa_condense_indirect_commit_entry(spa_t *spa,\n    vdev_indirect_mapping_entry_phys_t *vimep, uint32_t count)\n{\n\tspa_condensing_indirect_t *sci = spa->spa_condensing_indirect;\n\n\tASSERT3U(count, <, DVA_GET_ASIZE(&vimep->vimep_dst));\n\n\tdmu_tx_t *tx = dmu_tx_create_dd(spa_get_dsl(spa)->dp_mos_dir);\n\tdmu_tx_hold_space(tx, sizeof (*vimep) + sizeof (count));\n\tVERIFY0(dmu_tx_assign(tx, TXG_WAIT));\n\tint txgoff = dmu_tx_get_txg(tx) & TXG_MASK;\n\n\t \n\tif (list_is_empty(&sci->sci_new_mapping_entries[txgoff])) {\n\t\tdsl_sync_task_nowait(dmu_tx_pool(tx),\n\t\t    spa_condense_indirect_commit_sync, sci, tx);\n\t}\n\n\tvdev_indirect_mapping_entry_t *vime =\n\t    kmem_alloc(sizeof (*vime), KM_SLEEP);\n\tvime->vime_mapping = *vimep;\n\tvime->vime_obsolete_count = count;\n\tlist_insert_tail(&sci->sci_new_mapping_entries[txgoff], vime);\n\n\tdmu_tx_commit(tx);\n}\n\nstatic void\nspa_condense_indirect_generate_new_mapping(vdev_t *vd,\n    uint32_t *obsolete_counts, uint64_t start_index, zthr_t *zthr)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tuint64_t mapi = start_index;\n\tvdev_indirect_mapping_t *old_mapping = vd->vdev_indirect_mapping;\n\tuint64_t old_num_entries =\n\t    vdev_indirect_mapping_num_entries(old_mapping);\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\tASSERT3U(vd->vdev_id, ==, spa->spa_condensing_indirect_phys.scip_vdev);\n\n\tzfs_dbgmsg(\"starting condense of vdev %llu from index %llu\",\n\t    (u_longlong_t)vd->vdev_id,\n\t    (u_longlong_t)mapi);\n\n\twhile (mapi < old_num_entries) {\n\n\t\tif (zthr_iscancelled(zthr)) {\n\t\t\tzfs_dbgmsg(\"pausing condense of vdev %llu \"\n\t\t\t    \"at index %llu\", (u_longlong_t)vd->vdev_id,\n\t\t\t    (u_longlong_t)mapi);\n\t\t\tbreak;\n\t\t}\n\n\t\tvdev_indirect_mapping_entry_phys_t *entry =\n\t\t    &old_mapping->vim_entries[mapi];\n\t\tuint64_t entry_size = DVA_GET_ASIZE(&entry->vimep_dst);\n\t\tASSERT3U(obsolete_counts[mapi], <=, entry_size);\n\t\tif (obsolete_counts[mapi] < entry_size) {\n\t\t\tspa_condense_indirect_commit_entry(spa, entry,\n\t\t\t    obsolete_counts[mapi]);\n\n\t\t\t \n\t\t\thrtime_t now = gethrtime();\n\t\t\thrtime_t sleep_until = now + MSEC2NSEC(\n\t\t\t    zfs_condense_indirect_commit_entry_delay_ms);\n\t\t\tzfs_sleep_until(sleep_until);\n\t\t}\n\n\t\tmapi++;\n\t}\n}\n\nstatic boolean_t\nspa_condense_indirect_thread_check(void *arg, zthr_t *zthr)\n{\n\t(void) zthr;\n\tspa_t *spa = arg;\n\n\treturn (spa->spa_condensing_indirect != NULL);\n}\n\nstatic void\nspa_condense_indirect_thread(void *arg, zthr_t *zthr)\n{\n\tspa_t *spa = arg;\n\tvdev_t *vd;\n\n\tASSERT3P(spa->spa_condensing_indirect, !=, NULL);\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\tvd = vdev_lookup_top(spa, spa->spa_condensing_indirect_phys.scip_vdev);\n\tASSERT3P(vd, !=, NULL);\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\tspa_condensing_indirect_t *sci = spa->spa_condensing_indirect;\n\tspa_condensing_indirect_phys_t *scip =\n\t    &spa->spa_condensing_indirect_phys;\n\tuint32_t *counts;\n\tuint64_t start_index;\n\tvdev_indirect_mapping_t *old_mapping = vd->vdev_indirect_mapping;\n\tspace_map_t *prev_obsolete_sm = NULL;\n\n\tASSERT3U(vd->vdev_id, ==, scip->scip_vdev);\n\tASSERT(scip->scip_next_mapping_object != 0);\n\tASSERT(scip->scip_prev_obsolete_sm_object != 0);\n\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\t \n\t\tASSERT(list_is_empty(&sci->sci_new_mapping_entries[i]));\n\t}\n\n\tVERIFY0(space_map_open(&prev_obsolete_sm, spa->spa_meta_objset,\n\t    scip->scip_prev_obsolete_sm_object, 0, vd->vdev_asize, 0));\n\tcounts = vdev_indirect_mapping_load_obsolete_counts(old_mapping);\n\tif (prev_obsolete_sm != NULL) {\n\t\tvdev_indirect_mapping_load_obsolete_spacemap(old_mapping,\n\t\t    counts, prev_obsolete_sm);\n\t}\n\tspace_map_close(prev_obsolete_sm);\n\n\t \n\tuint64_t max_offset =\n\t    vdev_indirect_mapping_max_offset(sci->sci_new_mapping);\n\tif (max_offset == 0) {\n\t\t \n\t\tstart_index = 0;\n\t} else {\n\t\t \n\n\t\tvdev_indirect_mapping_entry_phys_t *entry =\n\t\t    vdev_indirect_mapping_entry_for_offset_or_next(old_mapping,\n\t\t    max_offset);\n\n\t\tif (entry == NULL) {\n\t\t\t \n\t\t\tstart_index = UINT64_MAX;\n\t\t} else {\n\t\t\tstart_index = entry - old_mapping->vim_entries;\n\t\t\tASSERT3U(start_index, <,\n\t\t\t    vdev_indirect_mapping_num_entries(old_mapping));\n\t\t}\n\t}\n\n\tspa_condense_indirect_generate_new_mapping(vd, counts,\n\t    start_index, zthr);\n\n\tvdev_indirect_mapping_free_obsolete_counts(old_mapping, counts);\n\n\t \n\tif (zthr_iscancelled(zthr))\n\t\treturn;\n\n\tVERIFY0(dsl_sync_task(spa_name(spa), NULL,\n\t    spa_condense_indirect_complete_sync, sci, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\n \nvoid\nspa_condense_indirect_start_sync(vdev_t *vd, dmu_tx_t *tx)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tspa_condensing_indirect_phys_t *scip =\n\t    &spa->spa_condensing_indirect_phys;\n\n\tASSERT0(scip->scip_next_mapping_object);\n\tASSERT0(scip->scip_prev_obsolete_sm_object);\n\tASSERT0(scip->scip_vdev);\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_OBSOLETE_COUNTS));\n\tASSERT(vdev_indirect_mapping_num_entries(vd->vdev_indirect_mapping));\n\n\tuint64_t obsolete_sm_obj;\n\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_obj));\n\tASSERT3U(obsolete_sm_obj, !=, 0);\n\n\tscip->scip_vdev = vd->vdev_id;\n\tscip->scip_next_mapping_object =\n\t    vdev_indirect_mapping_alloc(spa->spa_meta_objset, tx);\n\n\tscip->scip_prev_obsolete_sm_object = obsolete_sm_obj;\n\n\t \n\tspace_map_close(vd->vdev_obsolete_sm);\n\tvd->vdev_obsolete_sm = NULL;\n\tVERIFY0(zap_remove(spa->spa_meta_objset, vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_INDIRECT_OBSOLETE_SM, tx));\n\n\tVERIFY0(zap_add(spa->spa_dsl_pool->dp_meta_objset,\n\t    DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_CONDENSING_INDIRECT, sizeof (uint64_t),\n\t    sizeof (*scip) / sizeof (uint64_t), scip, tx));\n\n\tASSERT3P(spa->spa_condensing_indirect, ==, NULL);\n\tspa->spa_condensing_indirect = spa_condensing_indirect_create(spa);\n\n\tzfs_dbgmsg(\"starting condense of vdev %llu in txg %llu: \"\n\t    \"posm=%llu nm=%llu\",\n\t    (u_longlong_t)vd->vdev_id, (u_longlong_t)dmu_tx_get_txg(tx),\n\t    (u_longlong_t)scip->scip_prev_obsolete_sm_object,\n\t    (u_longlong_t)scip->scip_next_mapping_object);\n\n\tzthr_wakeup(spa->spa_condense_zthr);\n}\n\n \nvoid\nvdev_indirect_sync_obsolete(vdev_t *vd, dmu_tx_t *tx)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_indirect_config_t *vic __maybe_unused = &vd->vdev_indirect_config;\n\n\tASSERT3U(vic->vic_mapping_object, !=, 0);\n\tASSERT(range_tree_space(vd->vdev_obsolete_segments) > 0);\n\tASSERT(vd->vdev_removing || vd->vdev_ops == &vdev_indirect_ops);\n\tASSERT(spa_feature_is_enabled(spa, SPA_FEATURE_OBSOLETE_COUNTS));\n\n\tuint64_t obsolete_sm_object;\n\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\tif (obsolete_sm_object == 0) {\n\t\tobsolete_sm_object = space_map_alloc(spa->spa_meta_objset,\n\t\t    zfs_vdev_standard_sm_blksz, tx);\n\n\t\tASSERT(vd->vdev_top_zap != 0);\n\t\tVERIFY0(zap_add(vd->vdev_spa->spa_meta_objset, vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_INDIRECT_OBSOLETE_SM,\n\t\t    sizeof (obsolete_sm_object), 1, &obsolete_sm_object, tx));\n\t\tASSERT0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\t\tASSERT3U(obsolete_sm_object, !=, 0);\n\n\t\tspa_feature_incr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\t\tVERIFY0(space_map_open(&vd->vdev_obsolete_sm,\n\t\t    spa->spa_meta_objset, obsolete_sm_object,\n\t\t    0, vd->vdev_asize, 0));\n\t}\n\n\tASSERT(vd->vdev_obsolete_sm != NULL);\n\tASSERT3U(obsolete_sm_object, ==,\n\t    space_map_object(vd->vdev_obsolete_sm));\n\n\tspace_map_write(vd->vdev_obsolete_sm,\n\t    vd->vdev_obsolete_segments, SM_ALLOC, SM_NO_VDEVID, tx);\n\trange_tree_vacate(vd->vdev_obsolete_segments, NULL, NULL);\n}\n\nint\nspa_condense_init(spa_t *spa)\n{\n\tint error = zap_lookup(spa->spa_meta_objset,\n\t    DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_CONDENSING_INDIRECT, sizeof (uint64_t),\n\t    sizeof (spa->spa_condensing_indirect_phys) / sizeof (uint64_t),\n\t    &spa->spa_condensing_indirect_phys);\n\tif (error == 0) {\n\t\tif (spa_writeable(spa)) {\n\t\t\tspa->spa_condensing_indirect =\n\t\t\t    spa_condensing_indirect_create(spa);\n\t\t}\n\t\treturn (0);\n\t} else if (error == ENOENT) {\n\t\treturn (0);\n\t} else {\n\t\treturn (error);\n\t}\n}\n\nvoid\nspa_condense_fini(spa_t *spa)\n{\n\tif (spa->spa_condensing_indirect != NULL) {\n\t\tspa_condensing_indirect_destroy(spa->spa_condensing_indirect);\n\t\tspa->spa_condensing_indirect = NULL;\n\t}\n}\n\nvoid\nspa_start_indirect_condensing_thread(spa_t *spa)\n{\n\tASSERT3P(spa->spa_condense_zthr, ==, NULL);\n\tspa->spa_condense_zthr = zthr_create(\"z_indirect_condense\",\n\t    spa_condense_indirect_thread_check,\n\t    spa_condense_indirect_thread, spa, minclsyspri);\n}\n\n \nint\nvdev_obsolete_sm_object(vdev_t *vd, uint64_t *sm_obj)\n{\n\tASSERT0(spa_config_held(vd->vdev_spa, SCL_ALL, RW_WRITER));\n\n\tif (vd->vdev_top_zap == 0) {\n\t\t*sm_obj = 0;\n\t\treturn (0);\n\t}\n\n\tint error = zap_lookup(vd->vdev_spa->spa_meta_objset, vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_INDIRECT_OBSOLETE_SM, sizeof (uint64_t), 1, sm_obj);\n\tif (error == ENOENT) {\n\t\t*sm_obj = 0;\n\t\terror = 0;\n\t}\n\n\treturn (error);\n}\n\n \nint\nvdev_obsolete_counts_are_precise(vdev_t *vd, boolean_t *are_precise)\n{\n\tASSERT0(spa_config_held(vd->vdev_spa, SCL_ALL, RW_WRITER));\n\n\tif (vd->vdev_top_zap == 0) {\n\t\t*are_precise = B_FALSE;\n\t\treturn (0);\n\t}\n\n\tuint64_t val = 0;\n\tint error = zap_lookup(vd->vdev_spa->spa_meta_objset, vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_OBSOLETE_COUNTS_ARE_PRECISE, sizeof (val), 1, &val);\n\tif (error == 0) {\n\t\t*are_precise = (val != 0);\n\t} else if (error == ENOENT) {\n\t\t*are_precise = B_FALSE;\n\t\terror = 0;\n\t}\n\n\treturn (error);\n}\n\nstatic void\nvdev_indirect_close(vdev_t *vd)\n{\n\t(void) vd;\n}\n\nstatic int\nvdev_indirect_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,\n    uint64_t *logical_ashift, uint64_t *physical_ashift)\n{\n\t*psize = *max_psize = vd->vdev_asize +\n\t    VDEV_LABEL_START_SIZE + VDEV_LABEL_END_SIZE;\n\t*logical_ashift = vd->vdev_ashift;\n\t*physical_ashift = vd->vdev_physical_ashift;\n\treturn (0);\n}\n\ntypedef struct remap_segment {\n\tvdev_t *rs_vd;\n\tuint64_t rs_offset;\n\tuint64_t rs_asize;\n\tuint64_t rs_split_offset;\n\tlist_node_t rs_node;\n} remap_segment_t;\n\nstatic remap_segment_t *\nrs_alloc(vdev_t *vd, uint64_t offset, uint64_t asize, uint64_t split_offset)\n{\n\tremap_segment_t *rs = kmem_alloc(sizeof (remap_segment_t), KM_SLEEP);\n\trs->rs_vd = vd;\n\trs->rs_offset = offset;\n\trs->rs_asize = asize;\n\trs->rs_split_offset = split_offset;\n\treturn (rs);\n}\n\n \nstatic vdev_indirect_mapping_entry_phys_t *\nvdev_indirect_mapping_duplicate_adjacent_entries(vdev_t *vd, uint64_t offset,\n    uint64_t asize, uint64_t *copied_entries)\n{\n\tvdev_indirect_mapping_entry_phys_t *duplicate_mappings = NULL;\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tuint64_t entries = 0;\n\n\tASSERT(RW_READ_HELD(&vd->vdev_indirect_rwlock));\n\n\tvdev_indirect_mapping_entry_phys_t *first_mapping =\n\t    vdev_indirect_mapping_entry_for_offset(vim, offset);\n\tASSERT3P(first_mapping, !=, NULL);\n\n\tvdev_indirect_mapping_entry_phys_t *m = first_mapping;\n\twhile (asize > 0) {\n\t\tuint64_t size = DVA_GET_ASIZE(&m->vimep_dst);\n\n\t\tASSERT3U(offset, >=, DVA_MAPPING_GET_SRC_OFFSET(m));\n\t\tASSERT3U(offset, <, DVA_MAPPING_GET_SRC_OFFSET(m) + size);\n\n\t\tuint64_t inner_offset = offset - DVA_MAPPING_GET_SRC_OFFSET(m);\n\t\tuint64_t inner_size = MIN(asize, size - inner_offset);\n\n\t\toffset += inner_size;\n\t\tasize -= inner_size;\n\t\tentries++;\n\t\tm++;\n\t}\n\n\tsize_t copy_length = entries * sizeof (*first_mapping);\n\tduplicate_mappings = kmem_alloc(copy_length, KM_SLEEP);\n\tmemcpy(duplicate_mappings, first_mapping, copy_length);\n\t*copied_entries = entries;\n\n\treturn (duplicate_mappings);\n}\n\n \nstatic void\nvdev_indirect_remap(vdev_t *vd, uint64_t offset, uint64_t asize,\n    void (*func)(uint64_t, vdev_t *, uint64_t, uint64_t, void *), void *arg)\n{\n\tlist_t stack;\n\tspa_t *spa = vd->vdev_spa;\n\n\tlist_create(&stack, sizeof (remap_segment_t),\n\t    offsetof(remap_segment_t, rs_node));\n\n\tfor (remap_segment_t *rs = rs_alloc(vd, offset, asize, 0);\n\t    rs != NULL; rs = list_remove_head(&stack)) {\n\t\tvdev_t *v = rs->rs_vd;\n\t\tuint64_t num_entries = 0;\n\n\t\tASSERT(spa_config_held(spa, SCL_ALL, RW_READER) != 0);\n\t\tASSERT(rs->rs_asize > 0);\n\n\t\t \n\t\trw_enter(&v->vdev_indirect_rwlock, RW_READER);\n\t\tASSERT3P(v->vdev_indirect_mapping, !=, NULL);\n\n\t\tvdev_indirect_mapping_entry_phys_t *mapping =\n\t\t    vdev_indirect_mapping_duplicate_adjacent_entries(v,\n\t\t    rs->rs_offset, rs->rs_asize, &num_entries);\n\t\tASSERT3P(mapping, !=, NULL);\n\t\tASSERT3U(num_entries, >, 0);\n\t\trw_exit(&v->vdev_indirect_rwlock);\n\n\t\tfor (uint64_t i = 0; i < num_entries; i++) {\n\t\t\t \n\t\t\tvdev_indirect_mapping_entry_phys_t *m = &mapping[i];\n\n\t\t\tASSERT3P(m, !=, NULL);\n\t\t\tASSERT3U(rs->rs_asize, >, 0);\n\n\t\t\tuint64_t size = DVA_GET_ASIZE(&m->vimep_dst);\n\t\t\tuint64_t dst_offset = DVA_GET_OFFSET(&m->vimep_dst);\n\t\t\tuint64_t dst_vdev = DVA_GET_VDEV(&m->vimep_dst);\n\n\t\t\tASSERT3U(rs->rs_offset, >=,\n\t\t\t    DVA_MAPPING_GET_SRC_OFFSET(m));\n\t\t\tASSERT3U(rs->rs_offset, <,\n\t\t\t    DVA_MAPPING_GET_SRC_OFFSET(m) + size);\n\t\t\tASSERT3U(dst_vdev, !=, v->vdev_id);\n\n\t\t\tuint64_t inner_offset = rs->rs_offset -\n\t\t\t    DVA_MAPPING_GET_SRC_OFFSET(m);\n\t\t\tuint64_t inner_size =\n\t\t\t    MIN(rs->rs_asize, size - inner_offset);\n\n\t\t\tvdev_t *dst_v = vdev_lookup_top(spa, dst_vdev);\n\t\t\tASSERT3P(dst_v, !=, NULL);\n\n\t\t\tif (dst_v->vdev_ops == &vdev_indirect_ops) {\n\t\t\t\tlist_insert_head(&stack,\n\t\t\t\t    rs_alloc(dst_v, dst_offset + inner_offset,\n\t\t\t\t    inner_size, rs->rs_split_offset));\n\n\t\t\t}\n\n\t\t\tif ((zfs_flags & ZFS_DEBUG_INDIRECT_REMAP) &&\n\t\t\t    IS_P2ALIGNED(inner_size, 2 * SPA_MINBLOCKSIZE)) {\n\t\t\t\t \n\t\t\t\tuint64_t inner_half = inner_size / 2;\n\n\t\t\t\tfunc(rs->rs_split_offset + inner_half, dst_v,\n\t\t\t\t    dst_offset + inner_offset + inner_half,\n\t\t\t\t    inner_half, arg);\n\n\t\t\t\tfunc(rs->rs_split_offset, dst_v,\n\t\t\t\t    dst_offset + inner_offset,\n\t\t\t\t    inner_half, arg);\n\t\t\t} else {\n\t\t\t\tfunc(rs->rs_split_offset, dst_v,\n\t\t\t\t    dst_offset + inner_offset,\n\t\t\t\t    inner_size, arg);\n\t\t\t}\n\n\t\t\trs->rs_offset += inner_size;\n\t\t\trs->rs_asize -= inner_size;\n\t\t\trs->rs_split_offset += inner_size;\n\t\t}\n\t\tVERIFY0(rs->rs_asize);\n\n\t\tkmem_free(mapping, num_entries * sizeof (*mapping));\n\t\tkmem_free(rs, sizeof (remap_segment_t));\n\t}\n\tlist_destroy(&stack);\n}\n\nstatic void\nvdev_indirect_child_io_done(zio_t *zio)\n{\n\tzio_t *pio = zio->io_private;\n\n\tmutex_enter(&pio->io_lock);\n\tpio->io_error = zio_worst_error(pio->io_error, zio->io_error);\n\tmutex_exit(&pio->io_lock);\n\n\tabd_free(zio->io_abd);\n}\n\n \nstatic void\nvdev_indirect_gather_splits(uint64_t split_offset, vdev_t *vd, uint64_t offset,\n    uint64_t size, void *arg)\n{\n\tzio_t *zio = arg;\n\tindirect_vsd_t *iv = zio->io_vsd;\n\n\tASSERT3P(vd, !=, NULL);\n\n\tif (vd->vdev_ops == &vdev_indirect_ops)\n\t\treturn;\n\n\tint n = 1;\n\tif (vd->vdev_ops == &vdev_mirror_ops)\n\t\tn = vd->vdev_children;\n\n\tindirect_split_t *is =\n\t    kmem_zalloc(offsetof(indirect_split_t, is_child[n]), KM_SLEEP);\n\n\tis->is_children = n;\n\tis->is_size = size;\n\tis->is_split_offset = split_offset;\n\tis->is_target_offset = offset;\n\tis->is_vdev = vd;\n\tlist_create(&is->is_unique_child, sizeof (indirect_child_t),\n\t    offsetof(indirect_child_t, ic_node));\n\n\t \n\tif (vd->vdev_ops == &vdev_mirror_ops) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tis->is_child[i].ic_vdev = vd->vdev_child[i];\n\t\t\tlist_link_init(&is->is_child[i].ic_node);\n\t\t}\n\t} else {\n\t\tis->is_child[0].ic_vdev = vd;\n\t}\n\n\tlist_insert_tail(&iv->iv_splits, is);\n}\n\nstatic void\nvdev_indirect_read_split_done(zio_t *zio)\n{\n\tindirect_child_t *ic = zio->io_private;\n\n\tif (zio->io_error != 0) {\n\t\t \n\t\tabd_free(ic->ic_data);\n\t\tic->ic_data = NULL;\n\t}\n}\n\n \nstatic void\nvdev_indirect_read_all(zio_t *zio)\n{\n\tindirect_vsd_t *iv = zio->io_vsd;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tfor (int i = 0; i < is->is_children; i++) {\n\t\t\tindirect_child_t *ic = &is->is_child[i];\n\n\t\t\tif (!vdev_readable(ic->ic_vdev))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (vdev_dtl_contains(ic->ic_vdev, DTL_MISSING,\n\t\t\t    zio->io_txg, 1))\n\t\t\t\tic->ic_error = SET_ERROR(ESTALE);\n\n\t\t\tic->ic_data = abd_alloc_sametype(zio->io_abd,\n\t\t\t    is->is_size);\n\t\t\tic->ic_duplicate = NULL;\n\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL,\n\t\t\t    ic->ic_vdev, is->is_target_offset, ic->ic_data,\n\t\t\t    is->is_size, zio->io_type, zio->io_priority, 0,\n\t\t\t    vdev_indirect_read_split_done, ic));\n\t\t}\n\t}\n\tiv->iv_reconstruct = B_TRUE;\n}\n\nstatic void\nvdev_indirect_io_start(zio_t *zio)\n{\n\tspa_t *spa __maybe_unused = zio->io_spa;\n\tindirect_vsd_t *iv = kmem_zalloc(sizeof (*iv), KM_SLEEP);\n\tlist_create(&iv->iv_splits,\n\t    sizeof (indirect_split_t), offsetof(indirect_split_t, is_node));\n\n\tzio->io_vsd = iv;\n\tzio->io_vsd_ops = &vdev_indirect_vsd_ops;\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_READER) != 0);\n\tif (zio->io_type != ZIO_TYPE_READ) {\n\t\tASSERT3U(zio->io_type, ==, ZIO_TYPE_WRITE);\n\t\t \n\t\tASSERT((zio->io_flags & (ZIO_FLAG_SELF_HEAL |\n\t\t    ZIO_FLAG_RESILVER | ZIO_FLAG_INDUCE_DAMAGE)) != 0);\n\t}\n\n\tvdev_indirect_remap(zio->io_vd, zio->io_offset, zio->io_size,\n\t    vdev_indirect_gather_splits, zio);\n\n\tindirect_split_t *first = list_head(&iv->iv_splits);\n\tASSERT3P(first, !=, NULL);\n\tif (first->is_size == zio->io_size) {\n\t\t \n\t\tASSERT0(first->is_split_offset);\n\t\tASSERT3P(list_next(&iv->iv_splits, first), ==, NULL);\n\t\tzio_nowait(zio_vdev_child_io(zio, zio->io_bp,\n\t\t    first->is_vdev, first->is_target_offset,\n\t\t    abd_get_offset(zio->io_abd, 0),\n\t\t    zio->io_size, zio->io_type, zio->io_priority, 0,\n\t\t    vdev_indirect_child_io_done, zio));\n\t} else {\n\t\tiv->iv_split_block = B_TRUE;\n\t\tif (zio->io_type == ZIO_TYPE_READ &&\n\t\t    zio->io_flags & (ZIO_FLAG_SCRUB | ZIO_FLAG_RESILVER)) {\n\t\t\t \n\t\t\tvdev_indirect_read_all(zio);\n\t\t} else {\n\t\t\t \n\t\t\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t\t\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL,\n\t\t\t\t    is->is_vdev, is->is_target_offset,\n\t\t\t\t    abd_get_offset_size(zio->io_abd,\n\t\t\t\t    is->is_split_offset, is->is_size),\n\t\t\t\t    is->is_size, zio->io_type,\n\t\t\t\t    zio->io_priority, 0,\n\t\t\t\t    vdev_indirect_child_io_done, zio));\n\t\t\t}\n\n\t\t}\n\t}\n\n\tzio_execute(zio);\n}\n\n \nstatic void\nvdev_indirect_checksum_error(zio_t *zio,\n    indirect_split_t *is, indirect_child_t *ic)\n{\n\tvdev_t *vd = ic->ic_vdev;\n\n\tif (zio->io_flags & ZIO_FLAG_SPECULATIVE)\n\t\treturn;\n\n\tmutex_enter(&vd->vdev_stat_lock);\n\tvd->vdev_stat.vs_checksum_errors++;\n\tmutex_exit(&vd->vdev_stat_lock);\n\n\tzio_bad_cksum_t zbc = { 0 };\n\tabd_t *bad_abd = ic->ic_data;\n\tabd_t *good_abd = is->is_good_child->ic_data;\n\t(void) zfs_ereport_post_checksum(zio->io_spa, vd, NULL, zio,\n\t    is->is_target_offset, is->is_size, good_abd, bad_abd, &zbc);\n}\n\n \nstatic void\nvdev_indirect_repair(zio_t *zio)\n{\n\tindirect_vsd_t *iv = zio->io_vsd;\n\n\tif (!spa_writeable(zio->io_spa))\n\t\treturn;\n\n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tfor (int c = 0; c < is->is_children; c++) {\n\t\t\tindirect_child_t *ic = &is->is_child[c];\n\t\t\tif (ic == is->is_good_child)\n\t\t\t\tcontinue;\n\t\t\tif (ic->ic_data == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (ic->ic_duplicate == is->is_good_child)\n\t\t\t\tcontinue;\n\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL,\n\t\t\t    ic->ic_vdev, is->is_target_offset,\n\t\t\t    is->is_good_child->ic_data, is->is_size,\n\t\t\t    ZIO_TYPE_WRITE, ZIO_PRIORITY_ASYNC_WRITE,\n\t\t\t    ZIO_FLAG_IO_REPAIR | ZIO_FLAG_SELF_HEAL,\n\t\t\t    NULL, NULL));\n\n\t\t\t \n\t\t\tif (ic->ic_error == ESTALE)\n\t\t\t\tcontinue;\n\n\t\t\tvdev_indirect_checksum_error(zio, is, ic);\n\t\t}\n\t}\n}\n\n \nstatic void\nvdev_indirect_all_checksum_errors(zio_t *zio)\n{\n\tindirect_vsd_t *iv = zio->io_vsd;\n\n\tif (zio->io_flags & ZIO_FLAG_SPECULATIVE)\n\t\treturn;\n\n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tfor (int c = 0; c < is->is_children; c++) {\n\t\t\tindirect_child_t *ic = &is->is_child[c];\n\n\t\t\tif (ic->ic_data == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tvdev_t *vd = ic->ic_vdev;\n\n\t\t\tmutex_enter(&vd->vdev_stat_lock);\n\t\t\tvd->vdev_stat.vs_checksum_errors++;\n\t\t\tmutex_exit(&vd->vdev_stat_lock);\n\t\t\t(void) zfs_ereport_post_checksum(zio->io_spa, vd,\n\t\t\t    NULL, zio, is->is_target_offset, is->is_size,\n\t\t\t    NULL, NULL, NULL);\n\t\t}\n\t}\n}\n\n \nstatic int\nvdev_indirect_splits_checksum_validate(indirect_vsd_t *iv, zio_t *zio)\n{\n\tzio_bad_cksum_t zbc;\n\n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\n\t\tASSERT3P(is->is_good_child->ic_data, !=, NULL);\n\t\tASSERT3P(is->is_good_child->ic_duplicate, ==, NULL);\n\n\t\tabd_copy_off(zio->io_abd, is->is_good_child->ic_data,\n\t\t    is->is_split_offset, 0, is->is_size);\n\t}\n\n\treturn (zio_checksum_error(zio, &zbc));\n}\n\n \nstatic int\nvdev_indirect_splits_enumerate_all(indirect_vsd_t *iv, zio_t *zio)\n{\n\tboolean_t more = B_TRUE;\n\n\tiv->iv_attempts = 0;\n\n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is))\n\t\tis->is_good_child = list_head(&is->is_unique_child);\n\n\twhile (more == B_TRUE) {\n\t\tiv->iv_attempts++;\n\t\tmore = B_FALSE;\n\n\t\tif (vdev_indirect_splits_checksum_validate(iv, zio) == 0)\n\t\t\treturn (0);\n\n\t\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\t\tis->is_good_child = list_next(&is->is_unique_child,\n\t\t\t    is->is_good_child);\n\t\t\tif (is->is_good_child != NULL) {\n\t\t\t\tmore = B_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tis->is_good_child = list_head(&is->is_unique_child);\n\t\t}\n\t}\n\n\tASSERT3S(iv->iv_attempts, <=, iv->iv_unique_combinations);\n\n\treturn (SET_ERROR(ECKSUM));\n}\n\n \nstatic int\nvdev_indirect_splits_enumerate_randomly(indirect_vsd_t *iv, zio_t *zio)\n{\n\tiv->iv_attempts = 0;\n\n\twhile (iv->iv_attempts < iv->iv_attempts_max) {\n\t\tiv->iv_attempts++;\n\n\t\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\t\tindirect_child_t *ic = list_head(&is->is_unique_child);\n\t\t\tint children = is->is_unique_children;\n\n\t\t\tfor (int i = random_in_range(children); i > 0; i--)\n\t\t\t\tic = list_next(&is->is_unique_child, ic);\n\n\t\t\tASSERT3P(ic, !=, NULL);\n\t\t\tis->is_good_child = ic;\n\t\t}\n\n\t\tif (vdev_indirect_splits_checksum_validate(iv, zio) == 0)\n\t\t\treturn (0);\n\t}\n\n\treturn (SET_ERROR(ECKSUM));\n}\n\n \nstatic int\nvdev_indirect_splits_damage(indirect_vsd_t *iv, zio_t *zio)\n{\n\tint error;\n\n\t \n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tis->is_unique_children = 0;\n\n\t\tfor (int i = 0; i < is->is_children; i++) {\n\t\t\tindirect_child_t *ic = &is->is_child[i];\n\t\t\tif (ic->ic_data != NULL) {\n\t\t\t\tis->is_unique_children++;\n\t\t\t\tlist_insert_tail(&is->is_unique_child, ic);\n\t\t\t}\n\t\t}\n\n\t\tif (list_is_empty(&is->is_unique_child)) {\n\t\t\terror = SET_ERROR(EIO);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\terror = vdev_indirect_splits_enumerate_randomly(iv, zio);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tiv->iv_attempts_max = 1;\n\n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tfor (int c = 0; c < is->is_children; c++) {\n\t\t\tindirect_child_t *ic = &is->is_child[c];\n\n\t\t\tif (ic == is->is_good_child)\n\t\t\t\tcontinue;\n\t\t\tif (ic->ic_data == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tabd_zero(ic->ic_data, abd_get_size(ic->ic_data));\n\t\t}\n\n\t\tiv->iv_attempts_max *= 2;\n\t\tif (iv->iv_attempts_max >= (1ULL << 12)) {\n\t\t\tiv->iv_attempts_max = UINT64_MAX;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\t \n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tindirect_child_t *ic;\n\t\twhile ((ic = list_remove_head(&is->is_unique_child)) != NULL)\n\t\t\t;\n\n\t\tis->is_unique_children = 0;\n\t}\n\n\treturn (error);\n}\n\n \nstatic void\nvdev_indirect_reconstruct_io_done(zio_t *zio)\n{\n\tindirect_vsd_t *iv = zio->io_vsd;\n\tboolean_t known_good = B_FALSE;\n\tint error;\n\n\tiv->iv_unique_combinations = 1;\n\tiv->iv_attempts_max = UINT64_MAX;\n\n\tif (zfs_reconstruct_indirect_combinations_max > 0)\n\t\tiv->iv_attempts_max = zfs_reconstruct_indirect_combinations_max;\n\n\t \n\tif (zfs_reconstruct_indirect_damage_fraction != 0 &&\n\t    random_in_range(zfs_reconstruct_indirect_damage_fraction) == 0)\n\t\tknown_good = (vdev_indirect_splits_damage(iv, zio) == 0);\n\n\t \n\tfor (indirect_split_t *is = list_head(&iv->iv_splits);\n\t    is != NULL; is = list_next(&iv->iv_splits, is)) {\n\t\tis->is_unique_children = 0;\n\n\t\tfor (int i = 0; i < is->is_children; i++) {\n\t\t\tindirect_child_t *ic_i = &is->is_child[i];\n\n\t\t\tif (ic_i->ic_data == NULL ||\n\t\t\t    ic_i->ic_duplicate != NULL)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = i + 1; j < is->is_children; j++) {\n\t\t\t\tindirect_child_t *ic_j = &is->is_child[j];\n\n\t\t\t\tif (ic_j->ic_data == NULL ||\n\t\t\t\t    ic_j->ic_duplicate != NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (abd_cmp(ic_i->ic_data, ic_j->ic_data) == 0)\n\t\t\t\t\tic_j->ic_duplicate = ic_i;\n\t\t\t}\n\n\t\t\tis->is_unique_children++;\n\t\t\tlist_insert_tail(&is->is_unique_child, ic_i);\n\t\t}\n\n\t\t \n\t\tEQUIV(list_is_empty(&is->is_unique_child),\n\t\t    is->is_unique_children == 0);\n\t\tif (list_is_empty(&is->is_unique_child)) {\n\t\t\tzio->io_error = EIO;\n\t\t\tvdev_indirect_all_checksum_errors(zio);\n\t\t\tzio_checksum_verified(zio);\n\t\t\treturn;\n\t\t}\n\n\t\tiv->iv_unique_combinations *= is->is_unique_children;\n\t}\n\n\tif (iv->iv_unique_combinations <= iv->iv_attempts_max)\n\t\terror = vdev_indirect_splits_enumerate_all(iv, zio);\n\telse\n\t\terror = vdev_indirect_splits_enumerate_randomly(iv, zio);\n\n\tif (error != 0) {\n\t\t \n\t\tASSERT3B(known_good, ==, B_FALSE);\n\t\tzio->io_error = error;\n\t\tvdev_indirect_all_checksum_errors(zio);\n\t} else {\n\t\t \n\t\tASSERT0(vdev_indirect_splits_checksum_validate(iv, zio));\n\t\tvdev_indirect_repair(zio);\n\t\tzio_checksum_verified(zio);\n\t}\n}\n\nstatic void\nvdev_indirect_io_done(zio_t *zio)\n{\n\tindirect_vsd_t *iv = zio->io_vsd;\n\n\tif (iv->iv_reconstruct) {\n\t\t \n\t\tvdev_indirect_reconstruct_io_done(zio);\n\t\treturn;\n\t}\n\n\tif (!iv->iv_split_block) {\n\t\t \n\t\treturn;\n\t}\n\n\tzio_bad_cksum_t zbc;\n\tint ret = zio_checksum_error(zio, &zbc);\n\tif (ret == 0) {\n\t\tzio_checksum_verified(zio);\n\t\treturn;\n\t}\n\n\t \n\tvdev_indirect_read_all(zio);\n\n\tzio_vdev_io_redone(zio);\n}\n\nvdev_ops_t vdev_indirect_ops = {\n\t.vdev_op_init = NULL,\n\t.vdev_op_fini = NULL,\n\t.vdev_op_open = vdev_indirect_open,\n\t.vdev_op_close = vdev_indirect_close,\n\t.vdev_op_asize = vdev_default_asize,\n\t.vdev_op_min_asize = vdev_default_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = vdev_indirect_io_start,\n\t.vdev_op_io_done = vdev_indirect_io_done,\n\t.vdev_op_state_change = NULL,\n\t.vdev_op_need_resilver = NULL,\n\t.vdev_op_hold = NULL,\n\t.vdev_op_rele = NULL,\n\t.vdev_op_remap = vdev_indirect_remap,\n\t.vdev_op_xlate = NULL,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = NULL,\n\t.vdev_op_nparity = NULL,\n\t.vdev_op_ndisks = NULL,\n\t.vdev_op_type = VDEV_TYPE_INDIRECT,\t \n\t.vdev_op_leaf = B_FALSE\t\t\t \n};\n\nEXPORT_SYMBOL(spa_condense_fini);\nEXPORT_SYMBOL(spa_start_indirect_condensing_thread);\nEXPORT_SYMBOL(spa_condense_indirect_start_sync);\nEXPORT_SYMBOL(spa_condense_init);\nEXPORT_SYMBOL(spa_vdev_indirect_mark_obsolete);\nEXPORT_SYMBOL(vdev_indirect_mark_obsolete);\nEXPORT_SYMBOL(vdev_indirect_should_condense);\nEXPORT_SYMBOL(vdev_indirect_sync_obsolete);\nEXPORT_SYMBOL(vdev_obsolete_counts_are_precise);\nEXPORT_SYMBOL(vdev_obsolete_sm_object);\n\n \nZFS_MODULE_PARAM(zfs_condense, zfs_condense_, indirect_vdevs_enable, INT,\n\tZMOD_RW, \"Whether to attempt condensing indirect vdev mappings\");\n\nZFS_MODULE_PARAM(zfs_condense, zfs_condense_, indirect_obsolete_pct, UINT,\n\tZMOD_RW,\n\t\"Minimum obsolete percent of bytes in the mapping \"\n\t\"to attempt condensing\");\n\nZFS_MODULE_PARAM(zfs_condense, zfs_condense_, min_mapping_bytes, U64, ZMOD_RW,\n\t\"Don't bother condensing if the mapping uses less than this amount of \"\n\t\"memory\");\n\nZFS_MODULE_PARAM(zfs_condense, zfs_condense_, max_obsolete_bytes, U64,\n\tZMOD_RW,\n\t\"Minimum size obsolete spacemap to attempt condensing\");\n\nZFS_MODULE_PARAM(zfs_condense, zfs_condense_, indirect_commit_entry_delay_ms,\n\tUINT, ZMOD_RW,\n\t\"Used by tests to ensure certain actions happen in the middle of a \"\n\t\"condense. A maximum value of 1 should be sufficient.\");\n\nZFS_MODULE_PARAM(zfs_reconstruct, zfs_reconstruct_, indirect_combinations_max,\n\tUINT, ZMOD_RW,\n\t\"Maximum number of combinations when reconstructing split segments\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}