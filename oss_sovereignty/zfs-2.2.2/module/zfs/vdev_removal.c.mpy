{
  "module_name": "vdev_removal.c",
  "hash_id": "c44814f3d9b03e16533ee7b9b4355630957a7479ad3a05e244385b7b19fb2fc9",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_removal.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu.h>\n#include <sys/dmu_tx.h>\n#include <sys/zap.h>\n#include <sys/vdev_impl.h>\n#include <sys/metaslab.h>\n#include <sys/metaslab_impl.h>\n#include <sys/uberblock_impl.h>\n#include <sys/txg.h>\n#include <sys/avl.h>\n#include <sys/bpobj.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_dir.h>\n#include <sys/arc.h>\n#include <sys/zfeature.h>\n#include <sys/vdev_indirect_births.h>\n#include <sys/vdev_indirect_mapping.h>\n#include <sys/abd.h>\n#include <sys/vdev_initialize.h>\n#include <sys/vdev_trim.h>\n#include <sys/trace_zfs.h>\n\n \n\ntypedef struct vdev_copy_arg {\n\tmetaslab_t\t*vca_msp;\n\tuint64_t\tvca_outstanding_bytes;\n\tuint64_t\tvca_read_error_bytes;\n\tuint64_t\tvca_write_error_bytes;\n\tkcondvar_t\tvca_cv;\n\tkmutex_t\tvca_lock;\n} vdev_copy_arg_t;\n\n \nstatic const uint_t zfs_remove_max_copy_bytes = 64 * 1024 * 1024;\n\n \nuint_t zfs_remove_max_segment = SPA_MAXBLOCKSIZE;\n\n \nstatic int zfs_removal_ignore_errors = 0;\n\n \nuint_t vdev_removal_max_span = 32 * 1024;\n\n \nint zfs_removal_suspend_progress = 0;\n\n#define\tVDEV_REMOVAL_ZAP_OBJS\t\"lzap\"\n\nstatic __attribute__((noreturn)) void spa_vdev_remove_thread(void *arg);\nstatic int spa_vdev_remove_cancel_impl(spa_t *spa);\n\nstatic void\nspa_sync_removing_state(spa_t *spa, dmu_tx_t *tx)\n{\n\tVERIFY0(zap_update(spa->spa_dsl_pool->dp_meta_objset,\n\t    DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_REMOVING, sizeof (uint64_t),\n\t    sizeof (spa->spa_removing_phys) / sizeof (uint64_t),\n\t    &spa->spa_removing_phys, tx));\n}\n\nstatic nvlist_t *\nspa_nvlist_lookup_by_guid(nvlist_t **nvpp, int count, uint64_t target_guid)\n{\n\tfor (int i = 0; i < count; i++) {\n\t\tuint64_t guid =\n\t\t    fnvlist_lookup_uint64(nvpp[i], ZPOOL_CONFIG_GUID);\n\n\t\tif (guid == target_guid)\n\t\t\treturn (nvpp[i]);\n\t}\n\n\treturn (NULL);\n}\n\nstatic void\nvdev_activate(vdev_t *vd)\n{\n\tmetaslab_group_t *mg = vd->vdev_mg;\n\tspa_t *spa = vd->vdev_spa;\n\tuint64_t vdev_space = spa_deflate(spa) ?\n\t    vd->vdev_stat.vs_dspace : vd->vdev_stat.vs_space;\n\n\tASSERT(!vd->vdev_islog);\n\tASSERT(vd->vdev_noalloc);\n\n\tmetaslab_group_activate(mg);\n\tmetaslab_group_activate(vd->vdev_log_mg);\n\n\tASSERT3U(spa->spa_nonallocating_dspace, >=, vdev_space);\n\n\tspa->spa_nonallocating_dspace -= vdev_space;\n\n\tvd->vdev_noalloc = B_FALSE;\n}\n\nstatic int\nvdev_passivate(vdev_t *vd, uint64_t *txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tint error;\n\n\tASSERT(!vd->vdev_noalloc);\n\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tmetaslab_group_t *mg = vd->vdev_mg;\n\tmetaslab_class_t *normal = spa_normal_class(spa);\n\tif (mg->mg_class == normal) {\n\t\t \n\t\tboolean_t last = B_TRUE;\n\t\tfor (uint64_t id = 0; id < rvd->vdev_children; id++) {\n\t\t\tvdev_t *cvd = rvd->vdev_child[id];\n\n\t\t\tif (cvd == vd ||\n\t\t\t    cvd->vdev_ops == &vdev_indirect_ops)\n\t\t\t\tcontinue;\n\n\t\t\tmetaslab_class_t *mc = cvd->vdev_mg->mg_class;\n\t\t\tif (mc != normal)\n\t\t\t\tcontinue;\n\n\t\t\tif (!cvd->vdev_noalloc) {\n\t\t\t\tlast = B_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (last)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tmetaslab_group_passivate(mg);\n\tASSERT(!vd->vdev_islog);\n\tmetaslab_group_passivate(vd->vdev_log_mg);\n\n\t \n\tspa_vdev_config_exit(spa, NULL,\n\t    *txg + TXG_CONCURRENT_STATES + TXG_DEFER_SIZE, 0, FTAG);\n\n\t \n\terror = spa_reset_logs(spa);\n\n\t*txg = spa_vdev_config_enter(spa);\n\n\tif (error != 0) {\n\t\tmetaslab_group_activate(mg);\n\t\tASSERT(!vd->vdev_islog);\n\t\tif (vd->vdev_log_mg != NULL)\n\t\t\tmetaslab_group_activate(vd->vdev_log_mg);\n\t\treturn (error);\n\t}\n\n\tspa->spa_nonallocating_dspace += spa_deflate(spa) ?\n\t    vd->vdev_stat.vs_dspace : vd->vdev_stat.vs_space;\n\tvd->vdev_noalloc = B_TRUE;\n\n\treturn (0);\n}\n\n \nint\nspa_vdev_noalloc(spa_t *spa, uint64_t guid)\n{\n\tvdev_t *vd;\n\tuint64_t txg;\n\tint error = 0;\n\n\tASSERT(!MUTEX_HELD(&spa_namespace_lock));\n\tASSERT(spa_writeable(spa));\n\n\ttxg = spa_vdev_enter(spa);\n\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\n\tvd = spa_lookup_by_guid(spa, guid, B_FALSE);\n\n\tif (vd == NULL)\n\t\terror = SET_ERROR(ENOENT);\n\telse if (vd->vdev_mg == NULL)\n\t\terror = SET_ERROR(ZFS_ERR_VDEV_NOTSUP);\n\telse if (!vd->vdev_noalloc)\n\t\terror = vdev_passivate(vd, &txg);\n\n\tif (error == 0) {\n\t\tvdev_dirty_leaves(vd, VDD_DTL, txg);\n\t\tvdev_config_dirty(vd);\n\t}\n\n\terror = spa_vdev_exit(spa, NULL, txg, error);\n\n\treturn (error);\n}\n\nint\nspa_vdev_alloc(spa_t *spa, uint64_t guid)\n{\n\tvdev_t *vd;\n\tuint64_t txg;\n\tint error = 0;\n\n\tASSERT(!MUTEX_HELD(&spa_namespace_lock));\n\tASSERT(spa_writeable(spa));\n\n\ttxg = spa_vdev_enter(spa);\n\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\n\tvd = spa_lookup_by_guid(spa, guid, B_FALSE);\n\n\tif (vd == NULL)\n\t\terror = SET_ERROR(ENOENT);\n\telse if (vd->vdev_mg == NULL)\n\t\terror = SET_ERROR(ZFS_ERR_VDEV_NOTSUP);\n\telse if (!vd->vdev_removing)\n\t\tvdev_activate(vd);\n\n\tif (error == 0) {\n\t\tvdev_dirty_leaves(vd, VDD_DTL, txg);\n\t\tvdev_config_dirty(vd);\n\t}\n\n\t(void) spa_vdev_exit(spa, NULL, txg, error);\n\n\treturn (error);\n}\n\nstatic void\nspa_vdev_remove_aux(nvlist_t *config, const char *name, nvlist_t **dev,\n    int count, nvlist_t *dev_to_remove)\n{\n\tnvlist_t **newdev = NULL;\n\n\tif (count > 1)\n\t\tnewdev = kmem_alloc((count - 1) * sizeof (void *), KM_SLEEP);\n\n\tfor (int i = 0, j = 0; i < count; i++) {\n\t\tif (dev[i] == dev_to_remove)\n\t\t\tcontinue;\n\t\tVERIFY(nvlist_dup(dev[i], &newdev[j++], KM_SLEEP) == 0);\n\t}\n\n\tVERIFY(nvlist_remove(config, name, DATA_TYPE_NVLIST_ARRAY) == 0);\n\tfnvlist_add_nvlist_array(config, name, (const nvlist_t * const *)newdev,\n\t    count - 1);\n\n\tfor (int i = 0; i < count - 1; i++)\n\t\tnvlist_free(newdev[i]);\n\n\tif (count > 1)\n\t\tkmem_free(newdev, (count - 1) * sizeof (void *));\n}\n\nstatic spa_vdev_removal_t *\nspa_vdev_removal_create(vdev_t *vd)\n{\n\tspa_vdev_removal_t *svr = kmem_zalloc(sizeof (*svr), KM_SLEEP);\n\tmutex_init(&svr->svr_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&svr->svr_cv, NULL, CV_DEFAULT, NULL);\n\tsvr->svr_allocd_segs = range_tree_create(NULL, RANGE_SEG64, NULL, 0, 0);\n\tsvr->svr_vdev_id = vd->vdev_id;\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tsvr->svr_frees[i] = range_tree_create(NULL, RANGE_SEG64, NULL,\n\t\t    0, 0);\n\t\tlist_create(&svr->svr_new_segments[i],\n\t\t    sizeof (vdev_indirect_mapping_entry_t),\n\t\t    offsetof(vdev_indirect_mapping_entry_t, vime_node));\n\t}\n\n\treturn (svr);\n}\n\nvoid\nspa_vdev_removal_destroy(spa_vdev_removal_t *svr)\n{\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT0(svr->svr_bytes_done[i]);\n\t\tASSERT0(svr->svr_max_offset_to_sync[i]);\n\t\trange_tree_destroy(svr->svr_frees[i]);\n\t\tlist_destroy(&svr->svr_new_segments[i]);\n\t}\n\n\trange_tree_destroy(svr->svr_allocd_segs);\n\tmutex_destroy(&svr->svr_lock);\n\tcv_destroy(&svr->svr_cv);\n\tkmem_free(svr, sizeof (*svr));\n}\n\n \nstatic void\nvdev_remove_initiate_sync(void *arg, dmu_tx_t *tx)\n{\n\tint vdev_id = (uintptr_t)arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\tobjset_t *mos = spa->spa_dsl_pool->dp_meta_objset;\n\tspa_vdev_removal_t *svr = NULL;\n\tuint64_t txg __maybe_unused = dmu_tx_get_txg(tx);\n\n\tASSERT0(vdev_get_nparity(vd));\n\tsvr = spa_vdev_removal_create(vd);\n\n\tASSERT(vd->vdev_removing);\n\tASSERT3P(vd->vdev_indirect_mapping, ==, NULL);\n\n\tspa_feature_incr(spa, SPA_FEATURE_DEVICE_REMOVAL, tx);\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_OBSOLETE_COUNTS)) {\n\t\t \n\t\tspa_feature_incr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\t\tuint64_t one = 1;\n\t\tVERIFY0(zap_add(spa->spa_meta_objset, vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_OBSOLETE_COUNTS_ARE_PRECISE, sizeof (one), 1,\n\t\t    &one, tx));\n\t\tboolean_t are_precise __maybe_unused;\n\t\tASSERT0(vdev_obsolete_counts_are_precise(vd, &are_precise));\n\t\tASSERT3B(are_precise, ==, B_TRUE);\n\t}\n\n\tvic->vic_mapping_object = vdev_indirect_mapping_alloc(mos, tx);\n\tvd->vdev_indirect_mapping =\n\t    vdev_indirect_mapping_open(mos, vic->vic_mapping_object);\n\tvic->vic_births_object = vdev_indirect_births_alloc(mos, tx);\n\tvd->vdev_indirect_births =\n\t    vdev_indirect_births_open(mos, vic->vic_births_object);\n\tspa->spa_removing_phys.sr_removing_vdev = vd->vdev_id;\n\tspa->spa_removing_phys.sr_start_time = gethrestime_sec();\n\tspa->spa_removing_phys.sr_end_time = 0;\n\tspa->spa_removing_phys.sr_state = DSS_SCANNING;\n\tspa->spa_removing_phys.sr_to_copy = 0;\n\tspa->spa_removing_phys.sr_copied = 0;\n\n\t \n\tfor (uint64_t i = 0; i < vd->vdev_ms_count; i++) {\n\t\tmetaslab_t *ms = vd->vdev_ms[i];\n\t\tif (ms->ms_sm == NULL)\n\t\t\tcontinue;\n\n\t\tspa->spa_removing_phys.sr_to_copy +=\n\t\t    metaslab_allocated_space(ms);\n\n\t\t \n\t\tspa->spa_removing_phys.sr_to_copy -=\n\t\t    range_tree_space(ms->ms_freeing);\n\n\t\tASSERT0(range_tree_space(ms->ms_freed));\n\t\tfor (int t = 0; t < TXG_SIZE; t++)\n\t\t\tASSERT0(range_tree_space(ms->ms_allocating[t]));\n\t}\n\n\t \n\tASSERT3P(txg_list_head(&vd->vdev_ms_list, TXG_CLEAN(txg)), ==, NULL);\n\n\tspa_sync_removing_state(spa, tx);\n\n\t \n\tdmu_object_info_t doi;\n\tVERIFY0(dmu_object_info(mos, DMU_POOL_DIRECTORY_OBJECT, &doi));\n\tfor (uint64_t offset = 0; offset < doi.doi_max_offset; ) {\n\t\tdmu_buf_t *dbuf;\n\t\tVERIFY0(dmu_buf_hold(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    offset, FTAG, &dbuf, 0));\n\t\tdmu_buf_will_dirty(dbuf, tx);\n\t\toffset += dbuf->db_size;\n\t\tdmu_buf_rele(dbuf, FTAG);\n\t}\n\n\t \n\tvdev_config_dirty(vd);\n\n\tzfs_dbgmsg(\"starting removal thread for vdev %llu (%px) in txg %llu \"\n\t    \"im_obj=%llu\", (u_longlong_t)vd->vdev_id, vd,\n\t    (u_longlong_t)dmu_tx_get_txg(tx),\n\t    (u_longlong_t)vic->vic_mapping_object);\n\n\tspa_history_log_internal(spa, \"vdev remove started\", tx,\n\t    \"%s vdev %llu %s\", spa_name(spa), (u_longlong_t)vd->vdev_id,\n\t    (vd->vdev_path != NULL) ? vd->vdev_path : \"-\");\n\t \n\tASSERT3P(spa->spa_vdev_removal, ==, NULL);\n\tspa->spa_vdev_removal = svr;\n\tsvr->svr_thread = thread_create(NULL, 0,\n\t    spa_vdev_remove_thread, spa, 0, &p0, TS_RUN, minclsyspri);\n}\n\n \nint\nspa_remove_init(spa_t *spa)\n{\n\tint error;\n\n\terror = zap_lookup(spa->spa_dsl_pool->dp_meta_objset,\n\t    DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_REMOVING, sizeof (uint64_t),\n\t    sizeof (spa->spa_removing_phys) / sizeof (uint64_t),\n\t    &spa->spa_removing_phys);\n\n\tif (error == ENOENT) {\n\t\tspa->spa_removing_phys.sr_state = DSS_NONE;\n\t\tspa->spa_removing_phys.sr_removing_vdev = -1;\n\t\tspa->spa_removing_phys.sr_prev_indirect_vdev = -1;\n\t\tspa->spa_indirect_vdevs_loaded = B_TRUE;\n\t\treturn (0);\n\t} else if (error != 0) {\n\t\treturn (error);\n\t}\n\n\tif (spa->spa_removing_phys.sr_state == DSS_SCANNING) {\n\t\t \n\t\tspa_config_enter(spa, SCL_STATE, FTAG, RW_READER);\n\t\tvdev_t *vd = vdev_lookup_top(spa,\n\t\t    spa->spa_removing_phys.sr_removing_vdev);\n\n\t\tif (vd == NULL) {\n\t\t\tspa_config_exit(spa, SCL_STATE, FTAG);\n\t\t\treturn (EINVAL);\n\t\t}\n\n\t\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\n\t\tASSERT(vdev_is_concrete(vd));\n\t\tspa_vdev_removal_t *svr = spa_vdev_removal_create(vd);\n\t\tASSERT3U(svr->svr_vdev_id, ==, vd->vdev_id);\n\t\tASSERT(vd->vdev_removing);\n\n\t\tvd->vdev_indirect_mapping = vdev_indirect_mapping_open(\n\t\t    spa->spa_meta_objset, vic->vic_mapping_object);\n\t\tvd->vdev_indirect_births = vdev_indirect_births_open(\n\t\t    spa->spa_meta_objset, vic->vic_births_object);\n\t\tspa_config_exit(spa, SCL_STATE, FTAG);\n\n\t\tspa->spa_vdev_removal = svr;\n\t}\n\n\tspa_config_enter(spa, SCL_STATE, FTAG, RW_READER);\n\tuint64_t indirect_vdev_id =\n\t    spa->spa_removing_phys.sr_prev_indirect_vdev;\n\twhile (indirect_vdev_id != UINT64_MAX) {\n\t\tvdev_t *vd = vdev_lookup_top(spa, indirect_vdev_id);\n\t\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\n\t\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\t\tvd->vdev_indirect_mapping = vdev_indirect_mapping_open(\n\t\t    spa->spa_meta_objset, vic->vic_mapping_object);\n\t\tvd->vdev_indirect_births = vdev_indirect_births_open(\n\t\t    spa->spa_meta_objset, vic->vic_births_object);\n\n\t\tindirect_vdev_id = vic->vic_prev_indirect_vdev;\n\t}\n\tspa_config_exit(spa, SCL_STATE, FTAG);\n\n\t \n\tspa->spa_indirect_vdevs_loaded = B_TRUE;\n\treturn (0);\n}\n\nvoid\nspa_restart_removal(spa_t *spa)\n{\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\n\tif (svr == NULL)\n\t\treturn;\n\n\t \n\tif (svr->svr_thread != NULL)\n\t\treturn;\n\n\tif (!spa_writeable(spa))\n\t\treturn;\n\n\tzfs_dbgmsg(\"restarting removal of %llu\",\n\t    (u_longlong_t)svr->svr_vdev_id);\n\tsvr->svr_thread = thread_create(NULL, 0, spa_vdev_remove_thread, spa,\n\t    0, &p0, TS_RUN, minclsyspri);\n}\n\n \nvoid\nfree_from_removing_vdev(vdev_t *vd, uint64_t offset, uint64_t size)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tuint64_t txg = spa_syncing_txg(spa);\n\tuint64_t max_offset_yet = 0;\n\n\tASSERT(vd->vdev_indirect_config.vic_mapping_object != 0);\n\tASSERT3U(vd->vdev_indirect_config.vic_mapping_object, ==,\n\t    vdev_indirect_mapping_object(vim));\n\tASSERT3U(vd->vdev_id, ==, svr->svr_vdev_id);\n\n\tmutex_enter(&svr->svr_lock);\n\n\t \n\tASSERT(!spa_has_checkpoint(spa));\n\tmetaslab_free_concrete(vd, offset, size, B_FALSE);\n\n\tuint64_t synced_size = 0;\n\tuint64_t synced_offset = 0;\n\tuint64_t max_offset_synced = vdev_indirect_mapping_max_offset(vim);\n\tif (offset < max_offset_synced) {\n\t\t \n\t\tsynced_size = MIN(size, max_offset_synced - offset);\n\t\tsynced_offset = offset;\n\n\t\tASSERT3U(max_offset_yet, <=, max_offset_synced);\n\t\tmax_offset_yet = max_offset_synced;\n\n\t\tDTRACE_PROBE3(remove__free__synced,\n\t\t    spa_t *, spa,\n\t\t    uint64_t, offset,\n\t\t    uint64_t, synced_size);\n\n\t\tsize -= synced_size;\n\t\toffset += synced_size;\n\t}\n\n\t \n\tfor (int i = 0; i < TXG_CONCURRENT_STATES; i++) {\n\t\tint txgoff = (txg + i) & TXG_MASK;\n\t\tif (size > 0 && offset < svr->svr_max_offset_to_sync[txgoff]) {\n\t\t\t \n\t\t\tuint64_t inflight_size = MIN(size,\n\t\t\t    svr->svr_max_offset_to_sync[txgoff] - offset);\n\n\t\t\tDTRACE_PROBE4(remove__free__inflight,\n\t\t\t    spa_t *, spa,\n\t\t\t    uint64_t, offset,\n\t\t\t    uint64_t, inflight_size,\n\t\t\t    uint64_t, txg + i);\n\n\t\t\t \n\t\t\tif (svr->svr_max_offset_to_sync[txgoff] != 0) {\n\t\t\t\tASSERT3U(svr->svr_max_offset_to_sync[txgoff],\n\t\t\t\t    >=, max_offset_yet);\n\t\t\t\tmax_offset_yet =\n\t\t\t\t    svr->svr_max_offset_to_sync[txgoff];\n\t\t\t}\n\n\t\t\t \n\t\t\trange_tree_add(svr->svr_frees[txgoff],\n\t\t\t    offset, inflight_size);\n\t\t\tsize -= inflight_size;\n\t\t\toffset += inflight_size;\n\n\t\t\t \n\t\t\tASSERT3U(svr->svr_bytes_done[txgoff], >=,\n\t\t\t    inflight_size);\n\t\t\tsvr->svr_bytes_done[txgoff] -= inflight_size;\n\t\t\tsvr->svr_bytes_done[txg & TXG_MASK] += inflight_size;\n\t\t}\n\t}\n\tASSERT0(svr->svr_max_offset_to_sync[TXG_CLEAN(txg) & TXG_MASK]);\n\n\tif (size > 0) {\n\t\t \n\n\t\tDTRACE_PROBE3(remove__free__unvisited,\n\t\t    spa_t *, spa,\n\t\t    uint64_t, offset,\n\t\t    uint64_t, size);\n\n\t\tif (svr->svr_allocd_segs != NULL)\n\t\t\trange_tree_clear(svr->svr_allocd_segs, offset, size);\n\n\t\t \n\t\tsvr->svr_bytes_done[txg & TXG_MASK] += size;\n\t}\n\tmutex_exit(&svr->svr_lock);\n\n\t \n\tif (synced_size > 0) {\n\t\tvdev_indirect_mark_obsolete(vd, synced_offset, synced_size);\n\n\t\t \n\t\tboolean_t checkpoint = B_FALSE;\n\t\tvdev_indirect_ops.vdev_op_remap(vd, synced_offset, synced_size,\n\t\t    metaslab_free_impl_cb, &checkpoint);\n\t}\n}\n\n \nstatic void\nspa_finish_removal(spa_t *spa, dsl_scan_state_t state, dmu_tx_t *tx)\n{\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tASSERT3U(dmu_tx_get_txg(tx), ==, spa_syncing_txg(spa));\n\n\t \n\tspa_vdev_remove_suspend(spa);\n\n\tASSERT(state == DSS_FINISHED || state == DSS_CANCELED);\n\n\tif (state == DSS_FINISHED) {\n\t\tspa_removing_phys_t *srp = &spa->spa_removing_phys;\n\t\tvdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\t\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\n\t\tif (srp->sr_prev_indirect_vdev != -1) {\n\t\t\tvdev_t *pvd;\n\t\t\tpvd = vdev_lookup_top(spa,\n\t\t\t    srp->sr_prev_indirect_vdev);\n\t\t\tASSERT3P(pvd->vdev_ops, ==, &vdev_indirect_ops);\n\t\t}\n\n\t\tvic->vic_prev_indirect_vdev = srp->sr_prev_indirect_vdev;\n\t\tsrp->sr_prev_indirect_vdev = vd->vdev_id;\n\t}\n\tspa->spa_removing_phys.sr_state = state;\n\tspa->spa_removing_phys.sr_end_time = gethrestime_sec();\n\n\tspa->spa_vdev_removal = NULL;\n\tspa_vdev_removal_destroy(svr);\n\n\tspa_sync_removing_state(spa, tx);\n\tspa_notify_waiters(spa);\n\n\tvdev_config_dirty(spa->spa_root_vdev);\n}\n\nstatic void\nfree_mapped_segment_cb(void *arg, uint64_t offset, uint64_t size)\n{\n\tvdev_t *vd = arg;\n\tvdev_indirect_mark_obsolete(vd, offset, size);\n\tboolean_t checkpoint = B_FALSE;\n\tvdev_indirect_ops.vdev_op_remap(vd, offset, size,\n\t    metaslab_free_impl_cb, &checkpoint);\n}\n\n \nstatic void\nvdev_mapping_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_vdev_removal_t *svr = arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tvdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\tvdev_indirect_config_t *vic __maybe_unused = &vd->vdev_indirect_config;\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\n\tASSERT(vic->vic_mapping_object != 0);\n\tASSERT3U(txg, ==, spa_syncing_txg(spa));\n\n\tvdev_indirect_mapping_add_entries(vim,\n\t    &svr->svr_new_segments[txg & TXG_MASK], tx);\n\tvdev_indirect_births_add_entry(vd->vdev_indirect_births,\n\t    vdev_indirect_mapping_max_offset(vim), dmu_tx_get_txg(tx), tx);\n\n\t \n\tmutex_enter(&svr->svr_lock);\n\trange_tree_vacate(svr->svr_frees[txg & TXG_MASK],\n\t    free_mapped_segment_cb, vd);\n\tASSERT3U(svr->svr_max_offset_to_sync[txg & TXG_MASK], >=,\n\t    vdev_indirect_mapping_max_offset(vim));\n\tsvr->svr_max_offset_to_sync[txg & TXG_MASK] = 0;\n\tmutex_exit(&svr->svr_lock);\n\n\tspa_sync_removing_state(spa, tx);\n}\n\ntypedef struct vdev_copy_segment_arg {\n\tspa_t *vcsa_spa;\n\tdva_t *vcsa_dest_dva;\n\tuint64_t vcsa_txg;\n\trange_tree_t *vcsa_obsolete_segs;\n} vdev_copy_segment_arg_t;\n\nstatic void\nunalloc_seg(void *arg, uint64_t start, uint64_t size)\n{\n\tvdev_copy_segment_arg_t *vcsa = arg;\n\tspa_t *spa = vcsa->vcsa_spa;\n\tblkptr_t bp = { { { {0} } } };\n\n\tBP_SET_BIRTH(&bp, TXG_INITIAL, TXG_INITIAL);\n\tBP_SET_LSIZE(&bp, size);\n\tBP_SET_PSIZE(&bp, size);\n\tBP_SET_COMPRESS(&bp, ZIO_COMPRESS_OFF);\n\tBP_SET_CHECKSUM(&bp, ZIO_CHECKSUM_OFF);\n\tBP_SET_TYPE(&bp, DMU_OT_NONE);\n\tBP_SET_LEVEL(&bp, 0);\n\tBP_SET_DEDUP(&bp, 0);\n\tBP_SET_BYTEORDER(&bp, ZFS_HOST_BYTEORDER);\n\n\tDVA_SET_VDEV(&bp.blk_dva[0], DVA_GET_VDEV(vcsa->vcsa_dest_dva));\n\tDVA_SET_OFFSET(&bp.blk_dva[0],\n\t    DVA_GET_OFFSET(vcsa->vcsa_dest_dva) + start);\n\tDVA_SET_ASIZE(&bp.blk_dva[0], size);\n\n\tzio_free(spa, vcsa->vcsa_txg, &bp);\n}\n\n \nstatic void\nspa_vdev_copy_segment_done(zio_t *zio)\n{\n\tvdev_copy_segment_arg_t *vcsa = zio->io_private;\n\n\trange_tree_vacate(vcsa->vcsa_obsolete_segs,\n\t    unalloc_seg, vcsa);\n\trange_tree_destroy(vcsa->vcsa_obsolete_segs);\n\tkmem_free(vcsa, sizeof (*vcsa));\n\n\tspa_config_exit(zio->io_spa, SCL_STATE, zio->io_spa);\n}\n\n \nstatic void\nspa_vdev_copy_segment_write_done(zio_t *zio)\n{\n\tvdev_copy_arg_t *vca = zio->io_private;\n\n\tabd_free(zio->io_abd);\n\n\tmutex_enter(&vca->vca_lock);\n\tvca->vca_outstanding_bytes -= zio->io_size;\n\n\tif (zio->io_error != 0)\n\t\tvca->vca_write_error_bytes += zio->io_size;\n\n\tcv_signal(&vca->vca_cv);\n\tmutex_exit(&vca->vca_lock);\n}\n\n \nstatic void\nspa_vdev_copy_segment_read_done(zio_t *zio)\n{\n\tvdev_copy_arg_t *vca = zio->io_private;\n\n\tif (zio->io_error != 0) {\n\t\tmutex_enter(&vca->vca_lock);\n\t\tvca->vca_read_error_bytes += zio->io_size;\n\t\tmutex_exit(&vca->vca_lock);\n\t}\n\n\tzio_nowait(zio_unique_parent(zio));\n}\n\n \nstatic void\nspa_vdev_copy_one_child(vdev_copy_arg_t *vca, zio_t *nzio,\n    vdev_t *source_vd, uint64_t source_offset,\n    vdev_t *dest_child_vd, uint64_t dest_offset, int dest_id, uint64_t size)\n{\n\tASSERT3U(spa_config_held(nzio->io_spa, SCL_ALL, RW_READER), !=, 0);\n\n\t \n\tif (!vdev_writeable(dest_child_vd))\n\t\treturn;\n\n\tmutex_enter(&vca->vca_lock);\n\tvca->vca_outstanding_bytes += size;\n\tmutex_exit(&vca->vca_lock);\n\n\tabd_t *abd = abd_alloc_for_io(size, B_FALSE);\n\n\tvdev_t *source_child_vd = NULL;\n\tif (source_vd->vdev_ops == &vdev_mirror_ops && dest_id != -1) {\n\t\t \n\t\tfor (int i = 0; i < source_vd->vdev_children; i++) {\n\t\t\tsource_child_vd = source_vd->vdev_child[\n\t\t\t    (dest_id + i) % source_vd->vdev_children];\n\t\t\tif (vdev_readable(source_child_vd))\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsource_child_vd = source_vd;\n\t}\n\n\t \n\tASSERT3P(source_child_vd, !=, NULL);\n\n\tzio_t *write_zio = zio_vdev_child_io(nzio, NULL,\n\t    dest_child_vd, dest_offset, abd, size,\n\t    ZIO_TYPE_WRITE, ZIO_PRIORITY_REMOVAL,\n\t    ZIO_FLAG_CANFAIL,\n\t    spa_vdev_copy_segment_write_done, vca);\n\n\tzio_nowait(zio_vdev_child_io(write_zio, NULL,\n\t    source_child_vd, source_offset, abd, size,\n\t    ZIO_TYPE_READ, ZIO_PRIORITY_REMOVAL,\n\t    ZIO_FLAG_CANFAIL,\n\t    spa_vdev_copy_segment_read_done, vca));\n}\n\n \nstatic int\nspa_vdev_copy_segment(vdev_t *vd, range_tree_t *segs,\n    uint64_t maxalloc, uint64_t txg,\n    vdev_copy_arg_t *vca, zio_alloc_list_t *zal)\n{\n\tmetaslab_group_t *mg = vd->vdev_mg;\n\tspa_t *spa = vd->vdev_spa;\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tvdev_indirect_mapping_entry_t *entry;\n\tdva_t dst = {{ 0 }};\n\tuint64_t start = range_tree_min(segs);\n\tASSERT0(P2PHASE(start, 1 << spa->spa_min_ashift));\n\n\tASSERT3U(maxalloc, <=, SPA_MAXBLOCKSIZE);\n\tASSERT0(P2PHASE(maxalloc, 1 << spa->spa_min_ashift));\n\n\tuint64_t size = range_tree_span(segs);\n\tif (range_tree_span(segs) > maxalloc) {\n\t\t \n\t\trange_seg_max_t search;\n\t\tzfs_btree_index_t where;\n\t\trs_set_start(&search, segs, start + maxalloc);\n\t\trs_set_end(&search, segs, start + maxalloc);\n\t\t(void) zfs_btree_find(&segs->rt_root, &search, &where);\n\t\trange_seg_t *rs = zfs_btree_prev(&segs->rt_root, &where,\n\t\t    &where);\n\t\tif (rs != NULL) {\n\t\t\tsize = rs_get_end(rs, segs) - start;\n\t\t} else {\n\t\t\t \n\t\t\tsize = maxalloc;\n\t\t}\n\t}\n\tASSERT3U(size, <=, maxalloc);\n\tASSERT0(P2PHASE(size, 1 << spa->spa_min_ashift));\n\n\t \n\tmetaslab_class_t *mc = mg->mg_class;\n\tif (mc->mc_groups == 0)\n\t\tmc = spa_normal_class(spa);\n\tint error = metaslab_alloc_dva(spa, mc, size, &dst, 0, NULL, txg,\n\t    METASLAB_DONT_THROTTLE, zal, 0);\n\tif (error == ENOSPC && mc != spa_normal_class(spa)) {\n\t\terror = metaslab_alloc_dva(spa, spa_normal_class(spa), size,\n\t\t    &dst, 0, NULL, txg, METASLAB_DONT_THROTTLE, zal, 0);\n\t}\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\trange_tree_t *obsolete_segs = range_tree_create(NULL, RANGE_SEG64, NULL,\n\t    0, 0);\n\n\tzfs_btree_index_t where;\n\trange_seg_t *rs = zfs_btree_first(&segs->rt_root, &where);\n\tASSERT3U(rs_get_start(rs, segs), ==, start);\n\tuint64_t prev_seg_end = rs_get_end(rs, segs);\n\twhile ((rs = zfs_btree_next(&segs->rt_root, &where, &where)) != NULL) {\n\t\tif (rs_get_start(rs, segs) >= start + size) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\trange_tree_add(obsolete_segs,\n\t\t\t    prev_seg_end - start,\n\t\t\t    rs_get_start(rs, segs) - prev_seg_end);\n\t\t}\n\t\tprev_seg_end = rs_get_end(rs, segs);\n\t}\n\t \n\tASSERT3U(start + size, <=, prev_seg_end);\n\n\trange_tree_clear(segs, start, size);\n\n\t \n\tVERIFY3U(DVA_GET_ASIZE(&dst), ==, size);\n\n\tentry = kmem_zalloc(sizeof (vdev_indirect_mapping_entry_t), KM_SLEEP);\n\tDVA_MAPPING_SET_SRC_OFFSET(&entry->vime_mapping, start);\n\tentry->vime_mapping.vimep_dst = dst;\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_OBSOLETE_COUNTS)) {\n\t\tentry->vime_obsolete_count = range_tree_space(obsolete_segs);\n\t}\n\n\tvdev_copy_segment_arg_t *vcsa = kmem_zalloc(sizeof (*vcsa), KM_SLEEP);\n\tvcsa->vcsa_dest_dva = &entry->vime_mapping.vimep_dst;\n\tvcsa->vcsa_obsolete_segs = obsolete_segs;\n\tvcsa->vcsa_spa = spa;\n\tvcsa->vcsa_txg = txg;\n\n\t \n\tspa_config_enter(spa, SCL_STATE, spa, RW_READER);\n\tzio_t *nzio = zio_null(spa->spa_txg_zio[txg & TXG_MASK], spa, NULL,\n\t    spa_vdev_copy_segment_done, vcsa, 0);\n\tvdev_t *dest_vd = vdev_lookup_top(spa, DVA_GET_VDEV(&dst));\n\tif (dest_vd->vdev_ops == &vdev_mirror_ops) {\n\t\tfor (int i = 0; i < dest_vd->vdev_children; i++) {\n\t\t\tvdev_t *child = dest_vd->vdev_child[i];\n\t\t\tspa_vdev_copy_one_child(vca, nzio, vd, start,\n\t\t\t    child, DVA_GET_OFFSET(&dst), i, size);\n\t\t}\n\t} else {\n\t\tspa_vdev_copy_one_child(vca, nzio, vd, start,\n\t\t    dest_vd, DVA_GET_OFFSET(&dst), -1, size);\n\t}\n\tzio_nowait(nzio);\n\n\tlist_insert_tail(&svr->svr_new_segments[txg & TXG_MASK], entry);\n\tASSERT3U(start + size, <=, vd->vdev_ms_count << vd->vdev_ms_shift);\n\tvdev_dirty(vd, 0, NULL, txg);\n\n\treturn (0);\n}\n\n \nstatic void\nvdev_remove_complete_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_vdev_removal_t *svr = arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tvdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT0(svr->svr_bytes_done[i]);\n\t}\n\n\tASSERT3U(spa->spa_removing_phys.sr_copied, ==,\n\t    spa->spa_removing_phys.sr_to_copy);\n\n\tvdev_destroy_spacemaps(vd, tx);\n\n\t \n\tASSERT3P(svr->svr_zaplist, !=, NULL);\n\tfor (nvpair_t *pair = nvlist_next_nvpair(svr->svr_zaplist, NULL);\n\t    pair != NULL;\n\t    pair = nvlist_next_nvpair(svr->svr_zaplist, pair)) {\n\t\tvdev_destroy_unlink_zap(vd, fnvpair_value_uint64(pair), tx);\n\t}\n\tfnvlist_free(svr->svr_zaplist);\n\n\tspa_finish_removal(dmu_tx_pool(tx)->dp_spa, DSS_FINISHED, tx);\n\t \n\tspa_history_log_internal(spa, \"vdev remove completed\",  tx,\n\t    \"%s vdev %llu\", spa_name(spa), (u_longlong_t)vd->vdev_id);\n}\n\nstatic void\nvdev_remove_enlist_zaps(vdev_t *vd, nvlist_t *zlist)\n{\n\tASSERT3P(zlist, !=, NULL);\n\tASSERT0(vdev_get_nparity(vd));\n\n\tif (vd->vdev_leaf_zap != 0) {\n\t\tchar zkey[32];\n\t\t(void) snprintf(zkey, sizeof (zkey), \"%s-%llu\",\n\t\t    VDEV_REMOVAL_ZAP_OBJS, (u_longlong_t)vd->vdev_leaf_zap);\n\t\tfnvlist_add_uint64(zlist, zkey, vd->vdev_leaf_zap);\n\t}\n\n\tfor (uint64_t id = 0; id < vd->vdev_children; id++) {\n\t\tvdev_remove_enlist_zaps(vd->vdev_child[id], zlist);\n\t}\n}\n\nstatic void\nvdev_remove_replace_with_indirect(vdev_t *vd, uint64_t txg)\n{\n\tvdev_t *ivd;\n\tdmu_tx_t *tx;\n\tspa_t *spa = vd->vdev_spa;\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\n\t \n\tsvr->svr_zaplist = fnvlist_alloc();\n\tvdev_remove_enlist_zaps(vd, svr->svr_zaplist);\n\n\tivd = vdev_add_parent(vd, &vdev_indirect_ops);\n\tivd->vdev_removing = 0;\n\n\tvd->vdev_leaf_zap = 0;\n\n\tvdev_remove_child(ivd, vd);\n\tvdev_compact_children(ivd);\n\n\tASSERT(!list_link_active(&vd->vdev_state_dirty_node));\n\n\tmutex_enter(&svr->svr_lock);\n\tsvr->svr_thread = NULL;\n\tcv_broadcast(&svr->svr_cv);\n\tmutex_exit(&svr->svr_lock);\n\n\t \n\ttx = dmu_tx_create_assigned(spa->spa_dsl_pool, txg);\n\tdsl_sync_task_nowait(spa->spa_dsl_pool,\n\t    vdev_remove_complete_sync, svr, tx);\n\tdmu_tx_commit(tx);\n}\n\n \nstatic void\nvdev_remove_complete(spa_t *spa)\n{\n\tuint64_t txg;\n\n\t \n\ttxg_wait_synced(spa->spa_dsl_pool, 0);\n\ttxg = spa_vdev_enter(spa);\n\tvdev_t *vd = vdev_lookup_top(spa, spa->spa_vdev_removal->svr_vdev_id);\n\tASSERT3P(vd->vdev_initialize_thread, ==, NULL);\n\tASSERT3P(vd->vdev_trim_thread, ==, NULL);\n\tASSERT3P(vd->vdev_autotrim_thread, ==, NULL);\n\tvdev_rebuild_stop_wait(vd);\n\tASSERT3P(vd->vdev_rebuild_thread, ==, NULL);\n\tuint64_t vdev_space = spa_deflate(spa) ?\n\t    vd->vdev_stat.vs_dspace : vd->vdev_stat.vs_space;\n\n\tsysevent_t *ev = spa_event_create(spa, vd, NULL,\n\t    ESC_ZFS_VDEV_REMOVE_DEV);\n\n\tzfs_dbgmsg(\"finishing device removal for vdev %llu in txg %llu\",\n\t    (u_longlong_t)vd->vdev_id, (u_longlong_t)txg);\n\n\tASSERT3U(0, !=, vdev_space);\n\tASSERT3U(spa->spa_nonallocating_dspace, >=, vdev_space);\n\n\t \n\tspa->spa_nonallocating_dspace -= vdev_space;\n\n\t \n\tif (vd->vdev_mg != NULL) {\n\t\tvdev_metaslab_fini(vd);\n\t\tmetaslab_group_destroy(vd->vdev_mg);\n\t\tvd->vdev_mg = NULL;\n\t}\n\tif (vd->vdev_log_mg != NULL) {\n\t\tASSERT0(vd->vdev_ms_count);\n\t\tmetaslab_group_destroy(vd->vdev_log_mg);\n\t\tvd->vdev_log_mg = NULL;\n\t}\n\tASSERT0(vd->vdev_stat.vs_space);\n\tASSERT0(vd->vdev_stat.vs_dspace);\n\n\tvdev_remove_replace_with_indirect(vd, txg);\n\n\t \n\t(void) spa_vdev_exit(spa, NULL, txg, 0);\n\n\t \n\tASSERT0(vd->vdev_top_zap);\n\n\t \n\tASSERT0(vd->vdev_leaf_zap);\n\n\ttxg = spa_vdev_enter(spa);\n\t(void) vdev_label_init(vd, 0, VDEV_LABEL_REMOVE);\n\t \n\tvdev_config_dirty(spa->spa_root_vdev);\n\t(void) spa_vdev_exit(spa, vd, txg, 0);\n\n\tif (ev != NULL)\n\t\tspa_event_post(ev);\n}\n\n \nstatic void\nspa_vdev_copy_impl(vdev_t *vd, spa_vdev_removal_t *svr, vdev_copy_arg_t *vca,\n    uint64_t *max_alloc, dmu_tx_t *tx)\n{\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\n\tmutex_enter(&svr->svr_lock);\n\n\t \n\trange_tree_t *segs = range_tree_create(NULL, RANGE_SEG64, NULL, 0, 0);\n\tfor (;;) {\n\t\trange_tree_t *rt = svr->svr_allocd_segs;\n\t\trange_seg_t *rs = range_tree_first(rt);\n\n\t\tif (rs == NULL)\n\t\t\tbreak;\n\n\t\tuint64_t seg_length;\n\n\t\tif (range_tree_is_empty(segs)) {\n\t\t\t \n\t\t\tseg_length = MIN(rs_get_end(rs, rt) - rs_get_start(rs,\n\t\t\t    rt), *max_alloc);\n\t\t} else {\n\t\t\tif (rs_get_start(rs, rt) - range_tree_max(segs) >\n\t\t\t    vdev_removal_max_span) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else if (rs_get_end(rs, rt) - range_tree_min(segs) >\n\t\t\t    *max_alloc) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tseg_length = rs_get_end(rs, rt) -\n\t\t\t\t    rs_get_start(rs, rt);\n\t\t\t}\n\t\t}\n\n\t\trange_tree_add(segs, rs_get_start(rs, rt), seg_length);\n\t\trange_tree_remove(svr->svr_allocd_segs,\n\t\t    rs_get_start(rs, rt), seg_length);\n\t}\n\n\tif (range_tree_is_empty(segs)) {\n\t\tmutex_exit(&svr->svr_lock);\n\t\trange_tree_destroy(segs);\n\t\treturn;\n\t}\n\n\tif (svr->svr_max_offset_to_sync[txg & TXG_MASK] == 0) {\n\t\tdsl_sync_task_nowait(dmu_tx_pool(tx), vdev_mapping_sync,\n\t\t    svr, tx);\n\t}\n\n\tsvr->svr_max_offset_to_sync[txg & TXG_MASK] = range_tree_max(segs);\n\n\t \n\tsvr->svr_bytes_done[txg & TXG_MASK] += range_tree_space(segs);\n\n\tmutex_exit(&svr->svr_lock);\n\n\tzio_alloc_list_t zal;\n\tmetaslab_trace_init(&zal);\n\tuint64_t thismax = SPA_MAXBLOCKSIZE;\n\twhile (!range_tree_is_empty(segs)) {\n\t\tint error = spa_vdev_copy_segment(vd,\n\t\t    segs, thismax, txg, vca, &zal);\n\n\t\tif (error == ENOSPC) {\n\t\t\t \n\t\t\tASSERT3U(spa->spa_max_ashift, >=, SPA_MINBLOCKSHIFT);\n\t\t\tASSERT3U(spa->spa_max_ashift, ==, spa->spa_min_ashift);\n\t\t\tuint64_t attempted =\n\t\t\t    MIN(range_tree_span(segs), thismax);\n\t\t\tthismax = P2ROUNDUP(attempted / 2,\n\t\t\t    1 << spa->spa_max_ashift);\n\t\t\t \n\t\t\tASSERT3U(attempted, >, 1 << spa->spa_max_ashift);\n\t\t\t*max_alloc = attempted - (1 << spa->spa_max_ashift);\n\t\t} else {\n\t\t\tASSERT0(error);\n\n\t\t\t \n\t\t\tmetaslab_trace_fini(&zal);\n\t\t\tmetaslab_trace_init(&zal);\n\t\t}\n\t}\n\tmetaslab_trace_fini(&zal);\n\trange_tree_destroy(segs);\n}\n\n \nuint64_t\nspa_remove_max_segment(spa_t *spa)\n{\n\treturn (P2ROUNDUP(zfs_remove_max_segment, 1 << spa->spa_max_ashift));\n}\n\n \nstatic __attribute__((noreturn)) void\nspa_vdev_remove_thread(void *arg)\n{\n\tspa_t *spa = arg;\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tvdev_copy_arg_t vca;\n\tuint64_t max_alloc = spa_remove_max_segment(spa);\n\tuint64_t last_txg = 0;\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tvdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tuint64_t start_offset = vdev_indirect_mapping_max_offset(vim);\n\n\tASSERT3P(vd->vdev_ops, !=, &vdev_indirect_ops);\n\tASSERT(vdev_is_concrete(vd));\n\tASSERT(vd->vdev_removing);\n\tASSERT(vd->vdev_indirect_config.vic_mapping_object != 0);\n\tASSERT(vim != NULL);\n\n\tmutex_init(&vca.vca_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&vca.vca_cv, NULL, CV_DEFAULT, NULL);\n\tvca.vca_outstanding_bytes = 0;\n\tvca.vca_read_error_bytes = 0;\n\tvca.vca_write_error_bytes = 0;\n\n\tmutex_enter(&svr->svr_lock);\n\n\t \n\tuint64_t msi;\n\tfor (msi = start_offset >> vd->vdev_ms_shift;\n\t    msi < vd->vdev_ms_count && !svr->svr_thread_exit; msi++) {\n\t\tmetaslab_t *msp = vd->vdev_ms[msi];\n\t\tASSERT3U(msi, <=, vd->vdev_ms_count);\n\n\t\tASSERT0(range_tree_space(svr->svr_allocd_segs));\n\n\t\tmutex_enter(&msp->ms_sync_lock);\n\t\tmutex_enter(&msp->ms_lock);\n\n\t\t \n\t\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\t\tASSERT0(range_tree_space(msp->ms_allocating[i]));\n\t\t}\n\n\t\t \n\t\tif (msp->ms_sm != NULL) {\n\t\t\tVERIFY0(space_map_load(msp->ms_sm,\n\t\t\t    svr->svr_allocd_segs, SM_ALLOC));\n\n\t\t\trange_tree_walk(msp->ms_unflushed_allocs,\n\t\t\t    range_tree_add, svr->svr_allocd_segs);\n\t\t\trange_tree_walk(msp->ms_unflushed_frees,\n\t\t\t    range_tree_remove, svr->svr_allocd_segs);\n\t\t\trange_tree_walk(msp->ms_freeing,\n\t\t\t    range_tree_remove, svr->svr_allocd_segs);\n\n\t\t\t \n\t\t\trange_tree_clear(svr->svr_allocd_segs, 0, start_offset);\n\t\t}\n\t\tmutex_exit(&msp->ms_lock);\n\t\tmutex_exit(&msp->ms_sync_lock);\n\n\t\tvca.vca_msp = msp;\n\t\tzfs_dbgmsg(\"copying %llu segments for metaslab %llu\",\n\t\t    (u_longlong_t)zfs_btree_numnodes(\n\t\t    &svr->svr_allocd_segs->rt_root),\n\t\t    (u_longlong_t)msp->ms_id);\n\n\t\twhile (!svr->svr_thread_exit &&\n\t\t    !range_tree_is_empty(svr->svr_allocd_segs)) {\n\n\t\t\tmutex_exit(&svr->svr_lock);\n\n\t\t\t \n\t\t\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\t\t\t \n\t\t\twhile (zfs_removal_suspend_progress &&\n\t\t\t    !svr->svr_thread_exit)\n\t\t\t\tdelay(hz);\n\n\t\t\tmutex_enter(&vca.vca_lock);\n\t\t\twhile (vca.vca_outstanding_bytes >\n\t\t\t    zfs_remove_max_copy_bytes) {\n\t\t\t\tcv_wait(&vca.vca_cv, &vca.vca_lock);\n\t\t\t}\n\t\t\tmutex_exit(&vca.vca_lock);\n\n\t\t\tdmu_tx_t *tx =\n\t\t\t    dmu_tx_create_dd(spa_get_dsl(spa)->dp_mos_dir);\n\n\t\t\tVERIFY0(dmu_tx_assign(tx, TXG_WAIT));\n\t\t\tuint64_t txg = dmu_tx_get_txg(tx);\n\n\t\t\t \n\t\t\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\t\t\tvd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\n\t\t\tif (txg != last_txg)\n\t\t\t\tmax_alloc = spa_remove_max_segment(spa);\n\t\t\tlast_txg = txg;\n\n\t\t\tspa_vdev_copy_impl(vd, svr, &vca, &max_alloc, tx);\n\n\t\t\tdmu_tx_commit(tx);\n\t\t\tmutex_enter(&svr->svr_lock);\n\t\t}\n\n\t\tmutex_enter(&vca.vca_lock);\n\t\tif (zfs_removal_ignore_errors == 0 &&\n\t\t    (vca.vca_read_error_bytes > 0 ||\n\t\t    vca.vca_write_error_bytes > 0)) {\n\t\t\tsvr->svr_thread_exit = B_TRUE;\n\t\t}\n\t\tmutex_exit(&vca.vca_lock);\n\t}\n\n\tmutex_exit(&svr->svr_lock);\n\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\t \n\ttxg_wait_synced(spa->spa_dsl_pool, 0);\n\tASSERT0(vca.vca_outstanding_bytes);\n\n\tmutex_destroy(&vca.vca_lock);\n\tcv_destroy(&vca.vca_cv);\n\n\tif (svr->svr_thread_exit) {\n\t\tmutex_enter(&svr->svr_lock);\n\t\trange_tree_vacate(svr->svr_allocd_segs, NULL, NULL);\n\t\tsvr->svr_thread = NULL;\n\t\tcv_broadcast(&svr->svr_cv);\n\t\tmutex_exit(&svr->svr_lock);\n\n\t\t \n\t\tif (zfs_removal_ignore_errors == 0 &&\n\t\t    (vca.vca_read_error_bytes > 0 ||\n\t\t    vca.vca_write_error_bytes > 0)) {\n\t\t\tzfs_dbgmsg(\"canceling removal due to IO errors: \"\n\t\t\t    \"[read_error_bytes=%llu] [write_error_bytes=%llu]\",\n\t\t\t    (u_longlong_t)vca.vca_read_error_bytes,\n\t\t\t    (u_longlong_t)vca.vca_write_error_bytes);\n\t\t\tspa_vdev_remove_cancel_impl(spa);\n\t\t}\n\t} else {\n\t\tASSERT0(range_tree_space(svr->svr_allocd_segs));\n\t\tvdev_remove_complete(spa);\n\t}\n\n\tthread_exit();\n}\n\nvoid\nspa_vdev_remove_suspend(spa_t *spa)\n{\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\n\tif (svr == NULL)\n\t\treturn;\n\n\tmutex_enter(&svr->svr_lock);\n\tsvr->svr_thread_exit = B_TRUE;\n\twhile (svr->svr_thread != NULL)\n\t\tcv_wait(&svr->svr_cv, &svr->svr_lock);\n\tsvr->svr_thread_exit = B_FALSE;\n\tmutex_exit(&svr->svr_lock);\n}\n\n \nstatic boolean_t\nvdev_prop_allocating_off(vdev_t *vd)\n{\n\tuint64_t objid = vd->vdev_top_zap;\n\tuint64_t allocating = 1;\n\n\t \n\tif (objid != 0) {\n\t\tspa_t *spa = vd->vdev_spa;\n\t\tobjset_t *mos = spa->spa_meta_objset;\n\n\t\tmutex_enter(&spa->spa_props_lock);\n\t\t(void) zap_lookup(mos, objid, \"allocating\", sizeof (uint64_t),\n\t\t    1, &allocating);\n\t\tmutex_exit(&spa->spa_props_lock);\n\t}\n\treturn (allocating == 0);\n}\n\nstatic int\nspa_vdev_remove_cancel_check(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\n\tif (spa->spa_vdev_removal == NULL)\n\t\treturn (ENOTACTIVE);\n\treturn (0);\n}\n\n \nstatic void\nspa_vdev_remove_cancel_sync(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tvdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);\n\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\tobjset_t *mos = spa->spa_meta_objset;\n\n\tASSERT3P(svr->svr_thread, ==, NULL);\n\n\tspa_feature_decr(spa, SPA_FEATURE_DEVICE_REMOVAL, tx);\n\n\tboolean_t are_precise;\n\tVERIFY0(vdev_obsolete_counts_are_precise(vd, &are_precise));\n\tif (are_precise) {\n\t\tspa_feature_decr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\t\tVERIFY0(zap_remove(spa->spa_meta_objset, vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_OBSOLETE_COUNTS_ARE_PRECISE, tx));\n\t}\n\n\tuint64_t obsolete_sm_object;\n\tVERIFY0(vdev_obsolete_sm_object(vd, &obsolete_sm_object));\n\tif (obsolete_sm_object != 0) {\n\t\tASSERT(vd->vdev_obsolete_sm != NULL);\n\t\tASSERT3U(obsolete_sm_object, ==,\n\t\t    space_map_object(vd->vdev_obsolete_sm));\n\n\t\tspace_map_free(vd->vdev_obsolete_sm, tx);\n\t\tVERIFY0(zap_remove(spa->spa_meta_objset, vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_INDIRECT_OBSOLETE_SM, tx));\n\t\tspace_map_close(vd->vdev_obsolete_sm);\n\t\tvd->vdev_obsolete_sm = NULL;\n\t\tspa_feature_decr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\t}\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT(list_is_empty(&svr->svr_new_segments[i]));\n\t\tASSERT3U(svr->svr_max_offset_to_sync[i], <=,\n\t\t    vdev_indirect_mapping_max_offset(vim));\n\t}\n\n\tfor (uint64_t msi = 0; msi < vd->vdev_ms_count; msi++) {\n\t\tmetaslab_t *msp = vd->vdev_ms[msi];\n\n\t\tif (msp->ms_start >= vdev_indirect_mapping_max_offset(vim))\n\t\t\tbreak;\n\n\t\tASSERT0(range_tree_space(svr->svr_allocd_segs));\n\n\t\tmutex_enter(&msp->ms_lock);\n\n\t\t \n\t\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\t\tASSERT0(range_tree_space(msp->ms_allocating[i]));\n\t\tfor (int i = 0; i < TXG_DEFER_SIZE; i++)\n\t\t\tASSERT0(range_tree_space(msp->ms_defer[i]));\n\t\tASSERT0(range_tree_space(msp->ms_freed));\n\n\t\tif (msp->ms_sm != NULL) {\n\t\t\tmutex_enter(&svr->svr_lock);\n\t\t\tVERIFY0(space_map_load(msp->ms_sm,\n\t\t\t    svr->svr_allocd_segs, SM_ALLOC));\n\n\t\t\trange_tree_walk(msp->ms_unflushed_allocs,\n\t\t\t    range_tree_add, svr->svr_allocd_segs);\n\t\t\trange_tree_walk(msp->ms_unflushed_frees,\n\t\t\t    range_tree_remove, svr->svr_allocd_segs);\n\t\t\trange_tree_walk(msp->ms_freeing,\n\t\t\t    range_tree_remove, svr->svr_allocd_segs);\n\n\t\t\t \n\t\t\tuint64_t syncd = vdev_indirect_mapping_max_offset(vim);\n\t\t\tuint64_t sm_end = msp->ms_sm->sm_start +\n\t\t\t    msp->ms_sm->sm_size;\n\t\t\tif (sm_end > syncd)\n\t\t\t\trange_tree_clear(svr->svr_allocd_segs,\n\t\t\t\t    syncd, sm_end - syncd);\n\n\t\t\tmutex_exit(&svr->svr_lock);\n\t\t}\n\t\tmutex_exit(&msp->ms_lock);\n\n\t\tmutex_enter(&svr->svr_lock);\n\t\trange_tree_vacate(svr->svr_allocd_segs,\n\t\t    free_mapped_segment_cb, vd);\n\t\tmutex_exit(&svr->svr_lock);\n\t}\n\n\t \n\trange_tree_vacate(vd->vdev_obsolete_segments, NULL, NULL);\n\n\tASSERT3U(vic->vic_mapping_object, ==,\n\t    vdev_indirect_mapping_object(vd->vdev_indirect_mapping));\n\tvdev_indirect_mapping_close(vd->vdev_indirect_mapping);\n\tvd->vdev_indirect_mapping = NULL;\n\tvdev_indirect_mapping_free(mos, vic->vic_mapping_object, tx);\n\tvic->vic_mapping_object = 0;\n\n\tASSERT3U(vic->vic_births_object, ==,\n\t    vdev_indirect_births_object(vd->vdev_indirect_births));\n\tvdev_indirect_births_close(vd->vdev_indirect_births);\n\tvd->vdev_indirect_births = NULL;\n\tvdev_indirect_births_free(mos, vic->vic_births_object, tx);\n\tvic->vic_births_object = 0;\n\n\t \n\tsvr->svr_bytes_done[dmu_tx_get_txg(tx) & TXG_MASK] = 0;\n\tspa_finish_removal(spa, DSS_CANCELED, tx);\n\n\tvd->vdev_removing = B_FALSE;\n\n\tif (!vdev_prop_allocating_off(vd)) {\n\t\tspa_config_enter(spa, SCL_ALLOC | SCL_VDEV, FTAG, RW_WRITER);\n\t\tvdev_activate(vd);\n\t\tspa_config_exit(spa, SCL_ALLOC | SCL_VDEV, FTAG);\n\t}\n\n\tvdev_config_dirty(vd);\n\n\tzfs_dbgmsg(\"canceled device removal for vdev %llu in %llu\",\n\t    (u_longlong_t)vd->vdev_id, (u_longlong_t)dmu_tx_get_txg(tx));\n\tspa_history_log_internal(spa, \"vdev remove canceled\", tx,\n\t    \"%s vdev %llu %s\", spa_name(spa),\n\t    (u_longlong_t)vd->vdev_id,\n\t    (vd->vdev_path != NULL) ? vd->vdev_path : \"-\");\n}\n\nstatic int\nspa_vdev_remove_cancel_impl(spa_t *spa)\n{\n\tint error = dsl_sync_task(spa->spa_name, spa_vdev_remove_cancel_check,\n\t    spa_vdev_remove_cancel_sync, NULL, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED);\n\treturn (error);\n}\n\nint\nspa_vdev_remove_cancel(spa_t *spa)\n{\n\tspa_vdev_remove_suspend(spa);\n\n\tif (spa->spa_vdev_removal == NULL)\n\t\treturn (ENOTACTIVE);\n\n\treturn (spa_vdev_remove_cancel_impl(spa));\n}\n\nvoid\nsvr_sync(spa_t *spa, dmu_tx_t *tx)\n{\n\tspa_vdev_removal_t *svr = spa->spa_vdev_removal;\n\tint txgoff = dmu_tx_get_txg(tx) & TXG_MASK;\n\n\tif (svr == NULL)\n\t\treturn;\n\n\t \n\tif (svr->svr_bytes_done[txgoff] == 0)\n\t\treturn;\n\n\t \n\tspa->spa_removing_phys.sr_copied += svr->svr_bytes_done[txgoff];\n\tsvr->svr_bytes_done[txgoff] = 0;\n\n\tspa_sync_removing_state(spa, tx);\n}\n\nstatic void\nvdev_remove_make_hole_and_free(vdev_t *vd)\n{\n\tuint64_t id = vd->vdev_id;\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tvdev_free(vd);\n\n\tvd = vdev_alloc_common(spa, id, 0, &vdev_hole_ops);\n\tvdev_add_child(rvd, vd);\n\tvdev_config_dirty(rvd);\n\n\t \n\tvdev_reopen(rvd);\n}\n\n \nstatic int\nspa_vdev_remove_log(vdev_t *vd, uint64_t *txg)\n{\n\tmetaslab_group_t *mg = vd->vdev_mg;\n\tspa_t *spa = vd->vdev_spa;\n\tint error = 0;\n\n\tASSERT(vd->vdev_islog);\n\tASSERT(vd == vd->vdev_top);\n\tASSERT3P(vd->vdev_log_mg, ==, NULL);\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\n\t \n\tmetaslab_group_passivate(mg);\n\n\t \n\tspa_vdev_config_exit(spa, NULL,\n\t    *txg + TXG_CONCURRENT_STATES + TXG_DEFER_SIZE, 0, FTAG);\n\n\t \n\tvdev_initialize_stop_all(vd, VDEV_INITIALIZE_CANCELED);\n\tvdev_trim_stop_all(vd, VDEV_TRIM_CANCELED);\n\tvdev_autotrim_stop_wait(vd);\n\n\t \n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\tif (vd->vdev_stat.vs_alloc != 0)\n\t\terror = spa_reset_logs(spa);\n\n\t*txg = spa_vdev_config_enter(spa);\n\n\tif (error != 0) {\n\t\tmetaslab_group_activate(mg);\n\t\tASSERT3P(vd->vdev_log_mg, ==, NULL);\n\t\treturn (error);\n\t}\n\tASSERT0(vd->vdev_stat.vs_alloc);\n\n\t \n\tvd->vdev_removing = B_TRUE;\n\n\tvdev_dirty_leaves(vd, VDD_DTL, *txg);\n\tvdev_config_dirty(vd);\n\n\t \n\tvdev_metaslab_fini(vd);\n\n\tspa_vdev_config_exit(spa, NULL, *txg, 0, FTAG);\n\t*txg = spa_vdev_config_enter(spa);\n\n\tsysevent_t *ev = spa_event_create(spa, vd, NULL,\n\t    ESC_ZFS_VDEV_REMOVE_DEV);\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\t \n\tASSERT0(vd->vdev_top_zap);\n\t \n\tASSERT0(vd->vdev_leaf_zap);\n\n\t(void) vdev_label_init(vd, 0, VDEV_LABEL_REMOVE);\n\n\tif (list_link_active(&vd->vdev_state_dirty_node))\n\t\tvdev_state_clean(vd);\n\tif (list_link_active(&vd->vdev_config_dirty_node))\n\t\tvdev_config_clean(vd);\n\n\tASSERT0(vd->vdev_stat.vs_alloc);\n\n\t \n\tvdev_remove_make_hole_and_free(vd);\n\n\tif (ev != NULL)\n\t\tspa_event_post(ev);\n\n\treturn (0);\n}\n\nstatic int\nspa_vdev_remove_top_check(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tif (vd != vd->vdev_top)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (!vdev_is_concrete(vd))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_DEVICE_REMOVAL))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\t \n\tif (vd->vdev_removing)\n\t\treturn (SET_ERROR(EALREADY));\n\n\tmetaslab_class_t *mc = vd->vdev_mg->mg_class;\n\tmetaslab_class_t *normal = spa_normal_class(spa);\n\tif (mc != normal) {\n\t\t \n\t\tuint64_t available = metaslab_class_get_space(normal) -\n\t\t    metaslab_class_get_alloc(normal);\n\t\tASSERT3U(available, >=, vd->vdev_stat.vs_alloc);\n\t\tif (available < vd->vdev_stat.vs_alloc)\n\t\t\treturn (SET_ERROR(ENOSPC));\n\t} else if (!vd->vdev_noalloc) {\n\t\t \n\t\tuint64_t available = dsl_dir_space_available(\n\t\t    spa->spa_dsl_pool->dp_root_dir, NULL, 0, B_TRUE);\n\t\tif (available < vd->vdev_stat.vs_dspace)\n\t\t\treturn (SET_ERROR(ENOSPC));\n\t}\n\n\t \n\tif (spa->spa_removing_phys.sr_state == DSS_SCANNING)\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tif (!vdev_dtl_empty(vd, DTL_MISSING) ||\n\t    !vdev_dtl_empty(vd, DTL_OUTAGE))\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tif (!vdev_readable(vd))\n\t\treturn (SET_ERROR(EIO));\n\n\t \n\tif (spa->spa_max_ashift != spa->spa_min_ashift) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tASSERT(!vd->vdev_islog);\n\tif (vd->vdev_alloc_bias != VDEV_BIAS_NONE &&\n\t    vd->vdev_ashift != spa->spa_max_ashift) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tvdev_t *rvd = spa->spa_root_vdev;\n\tfor (uint64_t id = 0; id < rvd->vdev_children; id++) {\n\t\tvdev_t *cvd = rvd->vdev_child[id];\n\n\t\t \n\t\tif (vd->vdev_alloc_bias != VDEV_BIAS_NONE &&\n\t\t    cvd->vdev_alloc_bias == vd->vdev_alloc_bias &&\n\t\t    cvd->vdev_ashift != vd->vdev_ashift) {\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t\tif (cvd->vdev_ashift != 0 &&\n\t\t    cvd->vdev_alloc_bias == VDEV_BIAS_NONE)\n\t\t\tASSERT3U(cvd->vdev_ashift, ==, spa->spa_max_ashift);\n\t\tif (!vdev_is_concrete(cvd))\n\t\t\tcontinue;\n\t\tif (vdev_get_nparity(cvd) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t \n\t\tif (cvd->vdev_ops == &vdev_mirror_ops) {\n\t\t\tfor (uint64_t cid = 0;\n\t\t\t    cid < cvd->vdev_children; cid++) {\n\t\t\t\tif (!cvd->vdev_child[cid]->vdev_ops->\n\t\t\t\t    vdev_op_leaf)\n\t\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nspa_vdev_remove_top(vdev_t *vd, uint64_t *txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tboolean_t set_noalloc = B_FALSE;\n\tint error;\n\n\t \n\terror = spa_vdev_remove_top_check(vd);\n\n\t \n\tif (error == 0 && !vd->vdev_noalloc) {\n\t\tset_noalloc = B_TRUE;\n\t\terror = vdev_passivate(vd, txg);\n\t}\n\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\n\tspa_vdev_config_exit(spa, NULL, *txg, 0, FTAG);\n\n\tvdev_initialize_stop_all(vd, VDEV_INITIALIZE_ACTIVE);\n\tvdev_trim_stop_all(vd, VDEV_TRIM_ACTIVE);\n\tvdev_autotrim_stop_wait(vd);\n\n\t*txg = spa_vdev_config_enter(spa);\n\n\t \n\terror = spa_vdev_remove_top_check(vd);\n\n\tif (error != 0) {\n\t\tif (set_noalloc)\n\t\t\tvdev_activate(vd);\n\t\tspa_async_request(spa, SPA_ASYNC_INITIALIZE_RESTART);\n\t\tspa_async_request(spa, SPA_ASYNC_TRIM_RESTART);\n\t\tspa_async_request(spa, SPA_ASYNC_AUTOTRIM_RESTART);\n\t\treturn (error);\n\t}\n\n\tvd->vdev_removing = B_TRUE;\n\n\tvdev_dirty_leaves(vd, VDD_DTL, *txg);\n\tvdev_config_dirty(vd);\n\tdmu_tx_t *tx = dmu_tx_create_assigned(spa->spa_dsl_pool, *txg);\n\tdsl_sync_task_nowait(spa->spa_dsl_pool,\n\t    vdev_remove_initiate_sync, (void *)(uintptr_t)vd->vdev_id, tx);\n\tdmu_tx_commit(tx);\n\n\treturn (0);\n}\n\n \nint\nspa_vdev_remove(spa_t *spa, uint64_t guid, boolean_t unspare)\n{\n\tvdev_t *vd;\n\tnvlist_t **spares, **l2cache, *nv;\n\tuint64_t txg = 0;\n\tuint_t nspares, nl2cache;\n\tint error = 0, error_log;\n\tboolean_t locked = MUTEX_HELD(&spa_namespace_lock);\n\tsysevent_t *ev = NULL;\n\tconst char *vd_type = NULL;\n\tchar *vd_path = NULL;\n\n\tASSERT(spa_writeable(spa));\n\n\tif (!locked)\n\t\ttxg = spa_vdev_enter(spa);\n\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\tif (spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT)) {\n\t\terror = (spa_has_checkpoint(spa)) ?\n\t\t    ZFS_ERR_CHECKPOINT_EXISTS : ZFS_ERR_DISCARDING_CHECKPOINT;\n\n\t\tif (!locked)\n\t\t\treturn (spa_vdev_exit(spa, NULL, txg, error));\n\n\t\treturn (error);\n\t}\n\n\tvd = spa_lookup_by_guid(spa, guid, B_FALSE);\n\n\tif (spa->spa_spares.sav_vdevs != NULL &&\n\t    nvlist_lookup_nvlist_array(spa->spa_spares.sav_config,\n\t    ZPOOL_CONFIG_SPARES, &spares, &nspares) == 0 &&\n\t    (nv = spa_nvlist_lookup_by_guid(spares, nspares, guid)) != NULL) {\n\t\t \n\t\tif (vd == NULL || unspare) {\n\t\t\tconst char *type;\n\t\t\tboolean_t draid_spare = B_FALSE;\n\n\t\t\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type)\n\t\t\t    == 0 && strcmp(type, VDEV_TYPE_DRAID_SPARE) == 0)\n\t\t\t\tdraid_spare = B_TRUE;\n\n\t\t\tif (vd == NULL && draid_spare) {\n\t\t\t\terror = SET_ERROR(ENOTSUP);\n\t\t\t} else {\n\t\t\t\tif (vd == NULL)\n\t\t\t\t\tvd = spa_lookup_by_guid(spa,\n\t\t\t\t\t    guid, B_TRUE);\n\t\t\t\tev = spa_event_create(spa, vd, NULL,\n\t\t\t\t    ESC_ZFS_VDEV_REMOVE_AUX);\n\n\t\t\t\tvd_type = VDEV_TYPE_SPARE;\n\t\t\t\tvd_path = spa_strdup(fnvlist_lookup_string(\n\t\t\t\t    nv, ZPOOL_CONFIG_PATH));\n\t\t\t\tspa_vdev_remove_aux(spa->spa_spares.sav_config,\n\t\t\t\t    ZPOOL_CONFIG_SPARES, spares, nspares, nv);\n\t\t\t\tspa_load_spares(spa);\n\t\t\t\tspa->spa_spares.sav_sync = B_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\terror = SET_ERROR(EBUSY);\n\t\t}\n\t} else if (spa->spa_l2cache.sav_vdevs != NULL &&\n\t    nvlist_lookup_nvlist_array(spa->spa_l2cache.sav_config,\n\t    ZPOOL_CONFIG_L2CACHE, &l2cache, &nl2cache) == 0 &&\n\t    (nv = spa_nvlist_lookup_by_guid(l2cache, nl2cache, guid)) != NULL) {\n\t\tvd_type = VDEV_TYPE_L2CACHE;\n\t\tvd_path = spa_strdup(fnvlist_lookup_string(\n\t\t    nv, ZPOOL_CONFIG_PATH));\n\t\t \n\t\tvd = spa_lookup_by_guid(spa, guid, B_TRUE);\n\n\t\t \n\t\tspa_vdev_config_exit(spa, NULL,\n\t\t    txg + TXG_CONCURRENT_STATES + TXG_DEFER_SIZE, 0, FTAG);\n\t\tmutex_enter(&vd->vdev_trim_lock);\n\t\tvdev_trim_stop(vd, VDEV_TRIM_CANCELED, NULL);\n\t\tmutex_exit(&vd->vdev_trim_lock);\n\t\ttxg = spa_vdev_config_enter(spa);\n\n\t\tev = spa_event_create(spa, vd, NULL, ESC_ZFS_VDEV_REMOVE_AUX);\n\t\tspa_vdev_remove_aux(spa->spa_l2cache.sav_config,\n\t\t    ZPOOL_CONFIG_L2CACHE, l2cache, nl2cache, nv);\n\t\tspa_load_l2cache(spa);\n\t\tspa->spa_l2cache.sav_sync = B_TRUE;\n\t} else if (vd != NULL && vd->vdev_islog) {\n\t\tASSERT(!locked);\n\t\tvd_type = VDEV_TYPE_LOG;\n\t\tvd_path = spa_strdup((vd->vdev_path != NULL) ?\n\t\t    vd->vdev_path : \"-\");\n\t\terror = spa_vdev_remove_log(vd, &txg);\n\t} else if (vd != NULL) {\n\t\tASSERT(!locked);\n\t\terror = spa_vdev_remove_top(vd, &txg);\n\t} else {\n\t\t \n\t\terror = SET_ERROR(ENOENT);\n\t}\n\n\terror_log = error;\n\n\tif (!locked)\n\t\terror = spa_vdev_exit(spa, NULL, txg, error);\n\n\t \n\tif (error_log == 0 && vd_type != NULL && vd_path != NULL) {\n\t\tspa_history_log_internal(spa, \"vdev remove\", NULL,\n\t\t    \"%s vdev (%s) %s\", spa_name(spa), vd_type, vd_path);\n\t}\n\tif (vd_path != NULL)\n\t\tspa_strfree(vd_path);\n\n\tif (ev != NULL)\n\t\tspa_event_post(ev);\n\n\treturn (error);\n}\n\nint\nspa_removal_get_stats(spa_t *spa, pool_removal_stat_t *prs)\n{\n\tprs->prs_state = spa->spa_removing_phys.sr_state;\n\n\tif (prs->prs_state == DSS_NONE)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tprs->prs_removing_vdev = spa->spa_removing_phys.sr_removing_vdev;\n\tprs->prs_start_time = spa->spa_removing_phys.sr_start_time;\n\tprs->prs_end_time = spa->spa_removing_phys.sr_end_time;\n\tprs->prs_to_copy = spa->spa_removing_phys.sr_to_copy;\n\tprs->prs_copied = spa->spa_removing_phys.sr_copied;\n\n\tprs->prs_mapping_memory = 0;\n\tuint64_t indirect_vdev_id =\n\t    spa->spa_removing_phys.sr_prev_indirect_vdev;\n\twhile (indirect_vdev_id != -1) {\n\t\tvdev_t *vd = spa->spa_root_vdev->vdev_child[indirect_vdev_id];\n\t\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\t\tvdev_indirect_mapping_t *vim = vd->vdev_indirect_mapping;\n\n\t\tASSERT3P(vd->vdev_ops, ==, &vdev_indirect_ops);\n\t\tprs->prs_mapping_memory += vdev_indirect_mapping_size(vim);\n\t\tindirect_vdev_id = vic->vic_prev_indirect_vdev;\n\t}\n\n\treturn (0);\n}\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_, removal_ignore_errors, INT, ZMOD_RW,\n\t\"Ignore hard IO errors when removing device\");\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_, remove_max_segment, UINT, ZMOD_RW,\n\t\"Largest contiguous segment to allocate when removing device\");\n\nZFS_MODULE_PARAM(zfs_vdev, vdev_, removal_max_span, UINT, ZMOD_RW,\n\t\"Largest span of free chunks a remap segment can span\");\n\n \nZFS_MODULE_PARAM(zfs_vdev, zfs_, removal_suspend_progress, UINT, ZMOD_RW,\n\t\"Pause device removal after this many bytes are copied \"\n\t\"(debug use only - causes removal to hang)\");\n \n\nEXPORT_SYMBOL(free_from_removing_vdev);\nEXPORT_SYMBOL(spa_removal_get_stats);\nEXPORT_SYMBOL(spa_remove_init);\nEXPORT_SYMBOL(spa_restart_removal);\nEXPORT_SYMBOL(spa_vdev_removal_destroy);\nEXPORT_SYMBOL(spa_vdev_remove);\nEXPORT_SYMBOL(spa_vdev_remove_cancel);\nEXPORT_SYMBOL(spa_vdev_remove_suspend);\nEXPORT_SYMBOL(svr_sync);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}