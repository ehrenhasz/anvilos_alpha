{
  "module_name": "space_map.c",
  "hash_id": "4432b222f6ffa6a6c9b456078446f99640edb00f306fe3e076813f630f577ce1",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/space_map.c",
  "human_readable_source": " \n \n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/dmu_tx.h>\n#include <sys/dnode.h>\n#include <sys/dsl_pool.h>\n#include <sys/zio.h>\n#include <sys/space_map.h>\n#include <sys/zfeature.h>\n\n \n\n \nboolean_t zfs_force_some_double_word_sm_entries = B_FALSE;\n\n \nint space_map_ibs = 14;\n\nboolean_t\nsm_entry_is_debug(uint64_t e)\n{\n\treturn (SM_PREFIX_DECODE(e) == SM_DEBUG_PREFIX);\n}\n\nboolean_t\nsm_entry_is_single_word(uint64_t e)\n{\n\tuint8_t prefix = SM_PREFIX_DECODE(e);\n\treturn (prefix != SM_DEBUG_PREFIX && prefix != SM2_PREFIX);\n}\n\nboolean_t\nsm_entry_is_double_word(uint64_t e)\n{\n\treturn (SM_PREFIX_DECODE(e) == SM2_PREFIX);\n}\n\n \nint\nspace_map_iterate(space_map_t *sm, uint64_t end, sm_cb_t callback, void *arg)\n{\n\tuint64_t blksz = sm->sm_blksz;\n\n\tASSERT3U(blksz, !=, 0);\n\tASSERT3U(end, <=, space_map_length(sm));\n\tASSERT0(P2PHASE(end, sizeof (uint64_t)));\n\n\tdmu_prefetch(sm->sm_os, space_map_object(sm), 0, 0, end,\n\t    ZIO_PRIORITY_SYNC_READ);\n\n\tint error = 0;\n\tuint64_t txg = 0, sync_pass = 0;\n\tfor (uint64_t block_base = 0; block_base < end && error == 0;\n\t    block_base += blksz) {\n\t\tdmu_buf_t *db;\n\t\terror = dmu_buf_hold(sm->sm_os, space_map_object(sm),\n\t\t    block_base, FTAG, &db, DMU_READ_PREFETCH);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\tuint64_t *block_start = db->db_data;\n\t\tuint64_t block_length = MIN(end - block_base, blksz);\n\t\tuint64_t *block_end = block_start +\n\t\t    (block_length / sizeof (uint64_t));\n\n\t\tVERIFY0(P2PHASE(block_length, sizeof (uint64_t)));\n\t\tVERIFY3U(block_length, !=, 0);\n\t\tASSERT3U(blksz, ==, db->db_size);\n\n\t\tfor (uint64_t *block_cursor = block_start;\n\t\t    block_cursor < block_end && error == 0; block_cursor++) {\n\t\t\tuint64_t e = *block_cursor;\n\n\t\t\tif (sm_entry_is_debug(e)) {\n\t\t\t\t \n\t\t\t\tuint64_t e_txg = SM_DEBUG_TXG_DECODE(e);\n\t\t\t\tif (e_txg != 0) {\n\t\t\t\t\ttxg = e_txg;\n\t\t\t\t\tsync_pass = SM_DEBUG_SYNCPASS_DECODE(e);\n\t\t\t\t} else {\n\t\t\t\t\tASSERT0(SM_DEBUG_SYNCPASS_DECODE(e));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuint64_t raw_offset, raw_run, vdev_id;\n\t\t\tmaptype_t type;\n\t\t\tif (sm_entry_is_single_word(e)) {\n\t\t\t\ttype = SM_TYPE_DECODE(e);\n\t\t\t\tvdev_id = SM_NO_VDEVID;\n\t\t\t\traw_offset = SM_OFFSET_DECODE(e);\n\t\t\t\traw_run = SM_RUN_DECODE(e);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tASSERT(sm_entry_is_double_word(e));\n\t\t\t\traw_run = SM2_RUN_DECODE(e);\n\t\t\t\tvdev_id = SM2_VDEV_DECODE(e);\n\n\t\t\t\t \n\t\t\t\tblock_cursor++;\n\t\t\t\te = *block_cursor;\n\t\t\t\tVERIFY3P(block_cursor, <=, block_end);\n\n\t\t\t\ttype = SM2_TYPE_DECODE(e);\n\t\t\t\traw_offset = SM2_OFFSET_DECODE(e);\n\t\t\t}\n\n\t\t\tuint64_t entry_offset = (raw_offset << sm->sm_shift) +\n\t\t\t    sm->sm_start;\n\t\t\tuint64_t entry_run = raw_run << sm->sm_shift;\n\n\t\t\tVERIFY0(P2PHASE(entry_offset, 1ULL << sm->sm_shift));\n\t\t\tVERIFY0(P2PHASE(entry_run, 1ULL << sm->sm_shift));\n\t\t\tASSERT3U(entry_offset, >=, sm->sm_start);\n\t\t\tASSERT3U(entry_offset, <, sm->sm_start + sm->sm_size);\n\t\t\tASSERT3U(entry_run, <=, sm->sm_size);\n\t\t\tASSERT3U(entry_offset + entry_run, <=,\n\t\t\t    sm->sm_start + sm->sm_size);\n\n\t\t\tspace_map_entry_t sme = {\n\t\t\t    .sme_type = type,\n\t\t\t    .sme_vdev = vdev_id,\n\t\t\t    .sme_offset = entry_offset,\n\t\t\t    .sme_run = entry_run,\n\t\t\t    .sme_txg = txg,\n\t\t\t    .sme_sync_pass = sync_pass\n\t\t\t};\n\t\t\terror = callback(&sme, arg);\n\t\t}\n\t\tdmu_buf_rele(db, FTAG);\n\t}\n\treturn (error);\n}\n\n \nstatic int\nspace_map_reversed_last_block_entries(space_map_t *sm, uint64_t *buf,\n    uint64_t bufsz, uint64_t *nwords)\n{\n\tint error = 0;\n\tdmu_buf_t *db;\n\n\t \n\tuint64_t last_word_offset =\n\t    sm->sm_phys->smp_length - sizeof (uint64_t);\n\terror = dmu_buf_hold(sm->sm_os, space_map_object(sm), last_word_offset,\n\t    FTAG, &db, DMU_READ_NO_PREFETCH);\n\tif (error != 0)\n\t\treturn (error);\n\n\tASSERT3U(sm->sm_object, ==, db->db_object);\n\tASSERT3U(sm->sm_blksz, ==, db->db_size);\n\tASSERT3U(bufsz, >=, db->db_size);\n\tASSERT(nwords != NULL);\n\n\tuint64_t *words = db->db_data;\n\t*nwords =\n\t    (sm->sm_phys->smp_length - db->db_offset) / sizeof (uint64_t);\n\n\tASSERT3U(*nwords, <=, bufsz / sizeof (uint64_t));\n\n\tuint64_t n = *nwords;\n\tuint64_t j = n - 1;\n\tfor (uint64_t i = 0; i < n; i++) {\n\t\tuint64_t entry = words[i];\n\t\tif (sm_entry_is_double_word(entry)) {\n\t\t\t \n\t\t\tASSERT3U(j, >, 0);\n\t\t\tbuf[j - 1] = entry;\n\n\t\t\ti++;\n\t\t\tASSERT3U(i, <, n);\n\t\t\tentry = words[i];\n\t\t\tbuf[j] = entry;\n\t\t\tj -= 2;\n\t\t} else {\n\t\t\tASSERT(sm_entry_is_debug(entry) ||\n\t\t\t    sm_entry_is_single_word(entry));\n\t\t\tbuf[j] = entry;\n\t\t\tj--;\n\t\t}\n\t}\n\n\t \n\tASSERT3S(j, ==, -1);\n\n\tdmu_buf_rele(db, FTAG);\n\treturn (error);\n}\n\n \nint\nspace_map_incremental_destroy(space_map_t *sm, sm_cb_t callback, void *arg,\n    dmu_tx_t *tx)\n{\n\tuint64_t bufsz = MAX(sm->sm_blksz, SPA_MINBLOCKSIZE);\n\tuint64_t *buf = zio_buf_alloc(bufsz);\n\n\tdmu_buf_will_dirty(sm->sm_dbuf, tx);\n\n\t \n\tint error = 0;\n\twhile (space_map_length(sm) > 0 && error == 0) {\n\t\tuint64_t nwords = 0;\n\t\terror = space_map_reversed_last_block_entries(sm, buf, bufsz,\n\t\t    &nwords);\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\tASSERT3U(nwords, <=, bufsz / sizeof (uint64_t));\n\n\t\tfor (uint64_t i = 0; i < nwords; i++) {\n\t\t\tuint64_t e = buf[i];\n\n\t\t\tif (sm_entry_is_debug(e)) {\n\t\t\t\tsm->sm_phys->smp_length -= sizeof (uint64_t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint words = 1;\n\t\t\tuint64_t raw_offset, raw_run, vdev_id;\n\t\t\tmaptype_t type;\n\t\t\tif (sm_entry_is_single_word(e)) {\n\t\t\t\ttype = SM_TYPE_DECODE(e);\n\t\t\t\tvdev_id = SM_NO_VDEVID;\n\t\t\t\traw_offset = SM_OFFSET_DECODE(e);\n\t\t\t\traw_run = SM_RUN_DECODE(e);\n\t\t\t} else {\n\t\t\t\tASSERT(sm_entry_is_double_word(e));\n\t\t\t\twords = 2;\n\n\t\t\t\traw_run = SM2_RUN_DECODE(e);\n\t\t\t\tvdev_id = SM2_VDEV_DECODE(e);\n\n\t\t\t\t \n\t\t\t\ti++;\n\t\t\t\te = buf[i];\n\n\t\t\t\tASSERT3P(i, <=, nwords);\n\n\t\t\t\ttype = SM2_TYPE_DECODE(e);\n\t\t\t\traw_offset = SM2_OFFSET_DECODE(e);\n\t\t\t}\n\n\t\t\tuint64_t entry_offset =\n\t\t\t    (raw_offset << sm->sm_shift) + sm->sm_start;\n\t\t\tuint64_t entry_run = raw_run << sm->sm_shift;\n\n\t\t\tVERIFY0(P2PHASE(entry_offset, 1ULL << sm->sm_shift));\n\t\t\tVERIFY0(P2PHASE(entry_run, 1ULL << sm->sm_shift));\n\t\t\tVERIFY3U(entry_offset, >=, sm->sm_start);\n\t\t\tVERIFY3U(entry_offset, <, sm->sm_start + sm->sm_size);\n\t\t\tVERIFY3U(entry_run, <=, sm->sm_size);\n\t\t\tVERIFY3U(entry_offset + entry_run, <=,\n\t\t\t    sm->sm_start + sm->sm_size);\n\n\t\t\tspace_map_entry_t sme = {\n\t\t\t    .sme_type = type,\n\t\t\t    .sme_vdev = vdev_id,\n\t\t\t    .sme_offset = entry_offset,\n\t\t\t    .sme_run = entry_run\n\t\t\t};\n\t\t\terror = callback(&sme, arg);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (type == SM_ALLOC)\n\t\t\t\tsm->sm_phys->smp_alloc -= entry_run;\n\t\t\telse\n\t\t\t\tsm->sm_phys->smp_alloc += entry_run;\n\t\t\tsm->sm_phys->smp_length -= words * sizeof (uint64_t);\n\t\t}\n\t}\n\n\tif (space_map_length(sm) == 0) {\n\t\tASSERT0(error);\n\t\tASSERT0(space_map_allocated(sm));\n\t}\n\n\tzio_buf_free(buf, bufsz);\n\treturn (error);\n}\n\ntypedef struct space_map_load_arg {\n\tspace_map_t\t*smla_sm;\n\trange_tree_t\t*smla_rt;\n\tmaptype_t\tsmla_type;\n} space_map_load_arg_t;\n\nstatic int\nspace_map_load_callback(space_map_entry_t *sme, void *arg)\n{\n\tspace_map_load_arg_t *smla = arg;\n\tif (sme->sme_type == smla->smla_type) {\n\t\tVERIFY3U(range_tree_space(smla->smla_rt) + sme->sme_run, <=,\n\t\t    smla->smla_sm->sm_size);\n\t\trange_tree_add(smla->smla_rt, sme->sme_offset, sme->sme_run);\n\t} else {\n\t\trange_tree_remove(smla->smla_rt, sme->sme_offset, sme->sme_run);\n\t}\n\n\treturn (0);\n}\n\n \nint\nspace_map_load_length(space_map_t *sm, range_tree_t *rt, maptype_t maptype,\n    uint64_t length)\n{\n\tspace_map_load_arg_t smla;\n\n\tVERIFY0(range_tree_space(rt));\n\n\tif (maptype == SM_FREE)\n\t\trange_tree_add(rt, sm->sm_start, sm->sm_size);\n\n\tsmla.smla_rt = rt;\n\tsmla.smla_sm = sm;\n\tsmla.smla_type = maptype;\n\tint err = space_map_iterate(sm, length,\n\t    space_map_load_callback, &smla);\n\n\tif (err != 0)\n\t\trange_tree_vacate(rt, NULL, NULL);\n\n\treturn (err);\n}\n\n \nint\nspace_map_load(space_map_t *sm, range_tree_t *rt, maptype_t maptype)\n{\n\treturn (space_map_load_length(sm, rt, maptype, space_map_length(sm)));\n}\n\nvoid\nspace_map_histogram_clear(space_map_t *sm)\n{\n\tif (sm->sm_dbuf->db_size != sizeof (space_map_phys_t))\n\t\treturn;\n\n\tmemset(sm->sm_phys->smp_histogram, 0,\n\t    sizeof (sm->sm_phys->smp_histogram));\n}\n\nboolean_t\nspace_map_histogram_verify(space_map_t *sm, range_tree_t *rt)\n{\n\t \n\tfor (int i = 0; i < sm->sm_shift; i++) {\n\t\tif (rt->rt_histogram[i] != 0)\n\t\t\treturn (B_FALSE);\n\t}\n\treturn (B_TRUE);\n}\n\nvoid\nspace_map_histogram_add(space_map_t *sm, range_tree_t *rt, dmu_tx_t *tx)\n{\n\tint idx = 0;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tVERIFY3U(space_map_object(sm), !=, 0);\n\n\tif (sm->sm_dbuf->db_size != sizeof (space_map_phys_t))\n\t\treturn;\n\n\tdmu_buf_will_dirty(sm->sm_dbuf, tx);\n\n\tASSERT(space_map_histogram_verify(sm, rt));\n\t \n\tfor (int i = sm->sm_shift; i < RANGE_TREE_HISTOGRAM_SIZE; i++) {\n\n\t\t \n\t\tASSERT3U(i, >=, idx + sm->sm_shift);\n\t\tsm->sm_phys->smp_histogram[idx] +=\n\t\t    rt->rt_histogram[i] << (i - idx - sm->sm_shift);\n\n\t\t \n\t\tif (idx < SPACE_MAP_HISTOGRAM_SIZE - 1) {\n\t\t\tASSERT3U(idx + sm->sm_shift, ==, i);\n\t\t\tidx++;\n\t\t\tASSERT3U(idx, <, SPACE_MAP_HISTOGRAM_SIZE);\n\t\t}\n\t}\n}\n\nstatic void\nspace_map_write_intro_debug(space_map_t *sm, maptype_t maptype, dmu_tx_t *tx)\n{\n\tdmu_buf_will_dirty(sm->sm_dbuf, tx);\n\n\tuint64_t dentry = SM_PREFIX_ENCODE(SM_DEBUG_PREFIX) |\n\t    SM_DEBUG_ACTION_ENCODE(maptype) |\n\t    SM_DEBUG_SYNCPASS_ENCODE(spa_sync_pass(tx->tx_pool->dp_spa)) |\n\t    SM_DEBUG_TXG_ENCODE(dmu_tx_get_txg(tx));\n\n\tdmu_write(sm->sm_os, space_map_object(sm), sm->sm_phys->smp_length,\n\t    sizeof (dentry), &dentry, tx);\n\n\tsm->sm_phys->smp_length += sizeof (dentry);\n}\n\n \nstatic void\nspace_map_write_seg(space_map_t *sm, uint64_t rstart, uint64_t rend,\n    maptype_t maptype, uint64_t vdev_id, uint8_t words, dmu_buf_t **dbp,\n    const void *tag, dmu_tx_t *tx)\n{\n\tASSERT3U(words, !=, 0);\n\tASSERT3U(words, <=, 2);\n\n\t \n\tASSERT3U(vdev_id, <=, SM_NO_VDEVID);\n\n\t \n\tIMPLY(words == 1, vdev_id == SM_NO_VDEVID);\n\n\tdmu_buf_t *db = *dbp;\n\tASSERT3U(db->db_size, ==, sm->sm_blksz);\n\n\tuint64_t *block_base = db->db_data;\n\tuint64_t *block_end = block_base + (sm->sm_blksz / sizeof (uint64_t));\n\tuint64_t *block_cursor = block_base +\n\t    (sm->sm_phys->smp_length - db->db_offset) / sizeof (uint64_t);\n\n\tASSERT3P(block_cursor, <=, block_end);\n\n\tuint64_t size = (rend - rstart) >> sm->sm_shift;\n\tuint64_t start = (rstart - sm->sm_start) >> sm->sm_shift;\n\tuint64_t run_max = (words == 2) ? SM2_RUN_MAX : SM_RUN_MAX;\n\n\tASSERT3U(rstart, >=, sm->sm_start);\n\tASSERT3U(rstart, <, sm->sm_start + sm->sm_size);\n\tASSERT3U(rend - rstart, <=, sm->sm_size);\n\tASSERT3U(rend, <=, sm->sm_start + sm->sm_size);\n\n\twhile (size != 0) {\n\t\tASSERT3P(block_cursor, <=, block_end);\n\n\t\t \n\t\tif (block_cursor == block_end) {\n\t\t\tdmu_buf_rele(db, tag);\n\n\t\t\tuint64_t next_word_offset = sm->sm_phys->smp_length;\n\t\t\tVERIFY0(dmu_buf_hold(sm->sm_os,\n\t\t\t    space_map_object(sm), next_word_offset,\n\t\t\t    tag, &db, DMU_READ_PREFETCH));\n\t\t\tdmu_buf_will_dirty(db, tx);\n\n\t\t\t \n\t\t\t*dbp = db;\n\n\t\t\tASSERT3U(db->db_size, ==, sm->sm_blksz);\n\n\t\t\tblock_base = db->db_data;\n\t\t\tblock_cursor = block_base;\n\t\t\tblock_end = block_base +\n\t\t\t    (db->db_size / sizeof (uint64_t));\n\t\t}\n\n\t\t \n\t\tuint64_t *next_entry = block_cursor + 1;\n\t\tif (next_entry == block_end && words > 1) {\n\t\t\tASSERT3U(words, ==, 2);\n\t\t\t*block_cursor = SM_PREFIX_ENCODE(SM_DEBUG_PREFIX) |\n\t\t\t    SM_DEBUG_ACTION_ENCODE(0) |\n\t\t\t    SM_DEBUG_SYNCPASS_ENCODE(0) |\n\t\t\t    SM_DEBUG_TXG_ENCODE(0);\n\t\t\tblock_cursor++;\n\t\t\tsm->sm_phys->smp_length += sizeof (uint64_t);\n\t\t\tASSERT3P(block_cursor, ==, block_end);\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint64_t run_len = MIN(size, run_max);\n\t\tswitch (words) {\n\t\tcase 1:\n\t\t\t*block_cursor = SM_OFFSET_ENCODE(start) |\n\t\t\t    SM_TYPE_ENCODE(maptype) |\n\t\t\t    SM_RUN_ENCODE(run_len);\n\t\t\tblock_cursor++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\t*block_cursor = SM_PREFIX_ENCODE(SM2_PREFIX) |\n\t\t\t    SM2_RUN_ENCODE(run_len) |\n\t\t\t    SM2_VDEV_ENCODE(vdev_id);\n\t\t\tblock_cursor++;\n\n\t\t\t \n\t\t\tASSERT3P(block_cursor, <, block_end);\n\t\t\t*block_cursor = SM2_TYPE_ENCODE(maptype) |\n\t\t\t    SM2_OFFSET_ENCODE(start);\n\t\t\tblock_cursor++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"%d-word space map entries are not supported\",\n\t\t\t    words);\n\t\t\tbreak;\n\t\t}\n\t\tsm->sm_phys->smp_length += words * sizeof (uint64_t);\n\n\t\tstart += run_len;\n\t\tsize -= run_len;\n\t}\n\tASSERT0(size);\n\n}\n\n \nstatic void\nspace_map_write_impl(space_map_t *sm, range_tree_t *rt, maptype_t maptype,\n    uint64_t vdev_id, dmu_tx_t *tx)\n{\n\tspa_t *spa = tx->tx_pool->dp_spa;\n\tdmu_buf_t *db;\n\n\tspace_map_write_intro_debug(sm, maptype, tx);\n\n#ifdef ZFS_DEBUG\n\t \n\tuint64_t initial_objsize = sm->sm_phys->smp_length;\n\tuint64_t estimated_growth =\n\t    space_map_estimate_optimal_size(sm, rt, SM_NO_VDEVID);\n\tuint64_t estimated_final_objsize = initial_objsize + estimated_growth;\n#endif\n\n\t \n\tuint64_t next_word_offset = sm->sm_phys->smp_length;\n\tVERIFY0(dmu_buf_hold(sm->sm_os, space_map_object(sm),\n\t    next_word_offset, FTAG, &db, DMU_READ_PREFETCH));\n\tASSERT3U(db->db_size, ==, sm->sm_blksz);\n\n\tdmu_buf_will_dirty(db, tx);\n\n\tzfs_btree_t *t = &rt->rt_root;\n\tzfs_btree_index_t where;\n\tfor (range_seg_t *rs = zfs_btree_first(t, &where); rs != NULL;\n\t    rs = zfs_btree_next(t, &where, &where)) {\n\t\tuint64_t offset = (rs_get_start(rs, rt) - sm->sm_start) >>\n\t\t    sm->sm_shift;\n\t\tuint64_t length = (rs_get_end(rs, rt) - rs_get_start(rs, rt)) >>\n\t\t    sm->sm_shift;\n\t\tuint8_t words = 1;\n\n\t\t \n\t\tif (spa_feature_is_active(spa, SPA_FEATURE_SPACEMAP_V2) &&\n\t\t    (offset >= (1ULL << SM_OFFSET_BITS) ||\n\t\t    length > SM_RUN_MAX ||\n\t\t    vdev_id != SM_NO_VDEVID ||\n\t\t    (zfs_force_some_double_word_sm_entries &&\n\t\t    random_in_range(100) == 0)))\n\t\t\twords = 2;\n\n\t\tspace_map_write_seg(sm, rs_get_start(rs, rt), rs_get_end(rs,\n\t\t    rt), maptype, vdev_id, words, &db, FTAG, tx);\n\t}\n\n\tdmu_buf_rele(db, FTAG);\n\n#ifdef ZFS_DEBUG\n\t \n\tASSERT3U(estimated_final_objsize, >=, sm->sm_phys->smp_length);\n#endif\n}\n\n \nvoid\nspace_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,\n    uint64_t vdev_id, dmu_tx_t *tx)\n{\n\tASSERT(dsl_pool_sync_context(dmu_objset_pool(sm->sm_os)));\n\tVERIFY3U(space_map_object(sm), !=, 0);\n\n\tdmu_buf_will_dirty(sm->sm_dbuf, tx);\n\n\t \n\tsm->sm_phys->smp_object = sm->sm_object;\n\n\tif (range_tree_is_empty(rt)) {\n\t\tVERIFY3U(sm->sm_object, ==, sm->sm_phys->smp_object);\n\t\treturn;\n\t}\n\n\tif (maptype == SM_ALLOC)\n\t\tsm->sm_phys->smp_alloc += range_tree_space(rt);\n\telse\n\t\tsm->sm_phys->smp_alloc -= range_tree_space(rt);\n\n\tuint64_t nodes = zfs_btree_numnodes(&rt->rt_root);\n\tuint64_t rt_space = range_tree_space(rt);\n\n\tspace_map_write_impl(sm, rt, maptype, vdev_id, tx);\n\n\t \n\tVERIFY3U(nodes, ==, zfs_btree_numnodes(&rt->rt_root));\n\tVERIFY3U(range_tree_space(rt), ==, rt_space);\n}\n\nstatic int\nspace_map_open_impl(space_map_t *sm)\n{\n\tint error;\n\tu_longlong_t blocks;\n\n\terror = dmu_bonus_hold(sm->sm_os, sm->sm_object, sm, &sm->sm_dbuf);\n\tif (error)\n\t\treturn (error);\n\n\tdmu_object_size_from_db(sm->sm_dbuf, &sm->sm_blksz, &blocks);\n\tsm->sm_phys = sm->sm_dbuf->db_data;\n\treturn (0);\n}\n\nint\nspace_map_open(space_map_t **smp, objset_t *os, uint64_t object,\n    uint64_t start, uint64_t size, uint8_t shift)\n{\n\tspace_map_t *sm;\n\tint error;\n\n\tASSERT(*smp == NULL);\n\tASSERT(os != NULL);\n\tASSERT(object != 0);\n\n\tsm = kmem_alloc(sizeof (space_map_t), KM_SLEEP);\n\n\tsm->sm_start = start;\n\tsm->sm_size = size;\n\tsm->sm_shift = shift;\n\tsm->sm_os = os;\n\tsm->sm_object = object;\n\tsm->sm_blksz = 0;\n\tsm->sm_dbuf = NULL;\n\tsm->sm_phys = NULL;\n\n\terror = space_map_open_impl(sm);\n\tif (error != 0) {\n\t\tspace_map_close(sm);\n\t\treturn (error);\n\t}\n\t*smp = sm;\n\n\treturn (0);\n}\n\nvoid\nspace_map_close(space_map_t *sm)\n{\n\tif (sm == NULL)\n\t\treturn;\n\n\tif (sm->sm_dbuf != NULL)\n\t\tdmu_buf_rele(sm->sm_dbuf, sm);\n\tsm->sm_dbuf = NULL;\n\tsm->sm_phys = NULL;\n\n\tkmem_free(sm, sizeof (*sm));\n}\n\nvoid\nspace_map_truncate(space_map_t *sm, int blocksize, dmu_tx_t *tx)\n{\n\tobjset_t *os = sm->sm_os;\n\tspa_t *spa = dmu_objset_spa(os);\n\tdmu_object_info_t doi;\n\n\tASSERT(dsl_pool_sync_context(dmu_objset_pool(os)));\n\tASSERT(dmu_tx_is_syncing(tx));\n\tVERIFY3U(dmu_tx_get_txg(tx), <=, spa_final_dirty_txg(spa));\n\n\tdmu_object_info_from_db(sm->sm_dbuf, &doi);\n\n\t \n\tif ((spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_HISTOGRAM) &&\n\t    doi.doi_bonus_size != sizeof (space_map_phys_t)) ||\n\t    doi.doi_data_block_size != blocksize ||\n\t    doi.doi_metadata_block_size != 1 << space_map_ibs) {\n\t\tzfs_dbgmsg(\"txg %llu, spa %s, sm %px, reallocating \"\n\t\t    \"object[%llu]: old bonus %llu, old blocksz %u\",\n\t\t    (u_longlong_t)dmu_tx_get_txg(tx), spa_name(spa), sm,\n\t\t    (u_longlong_t)sm->sm_object,\n\t\t    (u_longlong_t)doi.doi_bonus_size,\n\t\t    doi.doi_data_block_size);\n\n\t\tspace_map_free(sm, tx);\n\t\tdmu_buf_rele(sm->sm_dbuf, sm);\n\n\t\tsm->sm_object = space_map_alloc(sm->sm_os, blocksize, tx);\n\t\tVERIFY0(space_map_open_impl(sm));\n\t} else {\n\t\tVERIFY0(dmu_free_range(os, space_map_object(sm), 0, -1ULL, tx));\n\n\t\t \n\t\tmemset(sm->sm_phys->smp_histogram, 0,\n\t\t    sizeof (sm->sm_phys->smp_histogram));\n\t}\n\n\tdmu_buf_will_dirty(sm->sm_dbuf, tx);\n\tsm->sm_phys->smp_length = 0;\n\tsm->sm_phys->smp_alloc = 0;\n}\n\nuint64_t\nspace_map_alloc(objset_t *os, int blocksize, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_objset_spa(os);\n\tuint64_t object;\n\tint bonuslen;\n\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_HISTOGRAM)) {\n\t\tspa_feature_incr(spa, SPA_FEATURE_SPACEMAP_HISTOGRAM, tx);\n\t\tbonuslen = sizeof (space_map_phys_t);\n\t\tASSERT3U(bonuslen, <=, dmu_bonus_max());\n\t} else {\n\t\tbonuslen = SPACE_MAP_SIZE_V0;\n\t}\n\n\tobject = dmu_object_alloc_ibs(os, DMU_OT_SPACE_MAP, blocksize,\n\t    space_map_ibs, DMU_OT_SPACE_MAP_HEADER, bonuslen, tx);\n\n\treturn (object);\n}\n\nvoid\nspace_map_free_obj(objset_t *os, uint64_t smobj, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_objset_spa(os);\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_HISTOGRAM)) {\n\t\tdmu_object_info_t doi;\n\n\t\tVERIFY0(dmu_object_info(os, smobj, &doi));\n\t\tif (doi.doi_bonus_size != SPACE_MAP_SIZE_V0) {\n\t\t\tspa_feature_decr(spa,\n\t\t\t    SPA_FEATURE_SPACEMAP_HISTOGRAM, tx);\n\t\t}\n\t}\n\n\tVERIFY0(dmu_object_free(os, smobj, tx));\n}\n\nvoid\nspace_map_free(space_map_t *sm, dmu_tx_t *tx)\n{\n\tif (sm == NULL)\n\t\treturn;\n\n\tspace_map_free_obj(sm->sm_os, space_map_object(sm), tx);\n\tsm->sm_object = 0;\n}\n\n \nuint64_t\nspace_map_estimate_optimal_size(space_map_t *sm, range_tree_t *rt,\n    uint64_t vdev_id)\n{\n\tspa_t *spa = dmu_objset_spa(sm->sm_os);\n\tuint64_t shift = sm->sm_shift;\n\tuint64_t *histogram = rt->rt_histogram;\n\tuint64_t entries_for_seg = 0;\n\n\t \n\tuint64_t size = 0;\n\tuint64_t idx = 0;\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2) ||\n\t    (vdev_id == SM_NO_VDEVID && sm->sm_size < SM_OFFSET_MAX)) {\n\n\t\t \n\t\tuint64_t entry_size =\n\t\t    (spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2) &&\n\t\t    zfs_force_some_double_word_sm_entries) ?\n\t\t    (2 * sizeof (uint64_t)) : sizeof (uint64_t);\n\n\t\tuint64_t single_entry_max_bucket = SM_RUN_BITS + shift - 1;\n\t\tfor (; idx <= single_entry_max_bucket; idx++)\n\t\t\tsize += histogram[idx] * entry_size;\n\n\t\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2)) {\n\t\t\tfor (; idx < RANGE_TREE_HISTOGRAM_SIZE; idx++) {\n\t\t\t\tASSERT3U(idx, >=, single_entry_max_bucket);\n\t\t\t\tentries_for_seg =\n\t\t\t\t    1ULL << (idx - single_entry_max_bucket);\n\t\t\t\tsize += histogram[idx] *\n\t\t\t\t    entries_for_seg * entry_size;\n\t\t\t}\n\t\t\treturn (size);\n\t\t}\n\t}\n\n\tASSERT(spa_feature_is_enabled(spa, SPA_FEATURE_SPACEMAP_V2));\n\n\tuint64_t double_entry_max_bucket = SM2_RUN_BITS + shift - 1;\n\tfor (; idx <= double_entry_max_bucket; idx++)\n\t\tsize += histogram[idx] * 2 * sizeof (uint64_t);\n\n\tfor (; idx < RANGE_TREE_HISTOGRAM_SIZE; idx++) {\n\t\tASSERT3U(idx, >=, double_entry_max_bucket);\n\t\tentries_for_seg = 1ULL << (idx - double_entry_max_bucket);\n\t\tsize += histogram[idx] *\n\t\t    entries_for_seg * 2 * sizeof (uint64_t);\n\t}\n\n\t \n\tsize += ((size / sm->sm_blksz) + 1) * sizeof (uint64_t);\n\n\treturn (size);\n}\n\nuint64_t\nspace_map_object(space_map_t *sm)\n{\n\treturn (sm != NULL ? sm->sm_object : 0);\n}\n\nint64_t\nspace_map_allocated(space_map_t *sm)\n{\n\treturn (sm != NULL ? sm->sm_phys->smp_alloc : 0);\n}\n\nuint64_t\nspace_map_length(space_map_t *sm)\n{\n\treturn (sm != NULL ? sm->sm_phys->smp_length : 0);\n}\n\nuint64_t\nspace_map_nblocks(space_map_t *sm)\n{\n\tif (sm == NULL)\n\t\treturn (0);\n\treturn (DIV_ROUND_UP(space_map_length(sm), sm->sm_blksz));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}