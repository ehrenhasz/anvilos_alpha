{
  "module_name": "dmu_objset.c",
  "hash_id": "b20c5b994dbdfed980a7c701cc8e9efbbad029164606253df85cfd0a40172f13",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu_objset.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/cred.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_deleg.h>\n#include <sys/dnode.h>\n#include <sys/dbuf.h>\n#include <sys/zvol.h>\n#include <sys/dmu_tx.h>\n#include <sys/zap.h>\n#include <sys/zil.h>\n#include <sys/dmu_impl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/sa.h>\n#include <sys/zfs_onexit.h>\n#include <sys/dsl_destroy.h>\n#include <sys/vdev.h>\n#include <sys/zfeature.h>\n#include <sys/policy.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu_recv.h>\n#include <sys/zfs_project.h>\n#include \"zfs_namecheck.h\"\n#include <sys/vdev_impl.h>\n#include <sys/arc.h>\n\n \nkrwlock_t os_lock;\n\n \nstatic const int dmu_find_threads = 0;\n\n \nstatic const int dmu_rescan_dnode_threshold = 1 << DN_MAX_INDBLKSHIFT;\n\nstatic const char *upgrade_tag = \"upgrade_tag\";\n\nstatic void dmu_objset_find_dp_cb(void *arg);\n\nstatic void dmu_objset_upgrade(objset_t *os, dmu_objset_upgrade_cb_t cb);\nstatic void dmu_objset_upgrade_stop(objset_t *os);\n\nvoid\ndmu_objset_init(void)\n{\n\trw_init(&os_lock, NULL, RW_DEFAULT, NULL);\n}\n\nvoid\ndmu_objset_fini(void)\n{\n\trw_destroy(&os_lock);\n}\n\nspa_t *\ndmu_objset_spa(objset_t *os)\n{\n\treturn (os->os_spa);\n}\n\nzilog_t *\ndmu_objset_zil(objset_t *os)\n{\n\treturn (os->os_zil);\n}\n\ndsl_pool_t *\ndmu_objset_pool(objset_t *os)\n{\n\tdsl_dataset_t *ds;\n\n\tif ((ds = os->os_dsl_dataset) != NULL && ds->ds_dir)\n\t\treturn (ds->ds_dir->dd_pool);\n\telse\n\t\treturn (spa_get_dsl(os->os_spa));\n}\n\ndsl_dataset_t *\ndmu_objset_ds(objset_t *os)\n{\n\treturn (os->os_dsl_dataset);\n}\n\ndmu_objset_type_t\ndmu_objset_type(objset_t *os)\n{\n\treturn (os->os_phys->os_type);\n}\n\nvoid\ndmu_objset_name(objset_t *os, char *buf)\n{\n\tdsl_dataset_name(os->os_dsl_dataset, buf);\n}\n\nuint64_t\ndmu_objset_id(objset_t *os)\n{\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\n\treturn (ds ? ds->ds_object : 0);\n}\n\nuint64_t\ndmu_objset_dnodesize(objset_t *os)\n{\n\treturn (os->os_dnodesize);\n}\n\nzfs_sync_type_t\ndmu_objset_syncprop(objset_t *os)\n{\n\treturn (os->os_sync);\n}\n\nzfs_logbias_op_t\ndmu_objset_logbias(objset_t *os)\n{\n\treturn (os->os_logbias);\n}\n\nstatic void\nchecksum_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval != ZIO_CHECKSUM_INHERIT);\n\n\tos->os_checksum = zio_checksum_select(newval, ZIO_CHECKSUM_ON_VALUE);\n}\n\nstatic void\ncompression_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval != ZIO_COMPRESS_INHERIT);\n\n\tos->os_compress = zio_compress_select(os->os_spa,\n\t    ZIO_COMPRESS_ALGO(newval), ZIO_COMPRESS_ON);\n\tos->os_complevel = zio_complevel_select(os->os_spa, os->os_compress,\n\t    ZIO_COMPRESS_LEVEL(newval), ZIO_COMPLEVEL_DEFAULT);\n}\n\nstatic void\ncopies_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval > 0);\n\tASSERT(newval <= spa_max_replication(os->os_spa));\n\n\tos->os_copies = newval;\n}\n\nstatic void\ndedup_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\tspa_t *spa = os->os_spa;\n\tenum zio_checksum checksum;\n\n\t \n\tASSERT(newval != ZIO_CHECKSUM_INHERIT);\n\n\tchecksum = zio_checksum_dedup_select(spa, newval, ZIO_CHECKSUM_OFF);\n\n\tos->os_dedup_checksum = checksum & ZIO_CHECKSUM_MASK;\n\tos->os_dedup_verify = !!(checksum & ZIO_CHECKSUM_VERIFY);\n}\n\nstatic void\nprimary_cache_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval == ZFS_CACHE_ALL || newval == ZFS_CACHE_NONE ||\n\t    newval == ZFS_CACHE_METADATA);\n\n\tos->os_primary_cache = newval;\n}\n\nstatic void\nsecondary_cache_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval == ZFS_CACHE_ALL || newval == ZFS_CACHE_NONE ||\n\t    newval == ZFS_CACHE_METADATA);\n\n\tos->os_secondary_cache = newval;\n}\n\nstatic void\nsync_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval == ZFS_SYNC_STANDARD || newval == ZFS_SYNC_ALWAYS ||\n\t    newval == ZFS_SYNC_DISABLED);\n\n\tos->os_sync = newval;\n\tif (os->os_zil)\n\t\tzil_set_sync(os->os_zil, newval);\n}\n\nstatic void\nredundant_metadata_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval == ZFS_REDUNDANT_METADATA_ALL ||\n\t    newval == ZFS_REDUNDANT_METADATA_MOST ||\n\t    newval == ZFS_REDUNDANT_METADATA_SOME ||\n\t    newval == ZFS_REDUNDANT_METADATA_NONE);\n\n\tos->os_redundant_metadata = newval;\n}\n\nstatic void\ndnodesize_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\tswitch (newval) {\n\tcase ZFS_DNSIZE_LEGACY:\n\t\tos->os_dnodesize = DNODE_MIN_SIZE;\n\t\tbreak;\n\tcase ZFS_DNSIZE_AUTO:\n\t\t \n\t\tos->os_dnodesize = DNODE_MIN_SIZE * 2;\n\t\tbreak;\n\tcase ZFS_DNSIZE_1K:\n\tcase ZFS_DNSIZE_2K:\n\tcase ZFS_DNSIZE_4K:\n\tcase ZFS_DNSIZE_8K:\n\tcase ZFS_DNSIZE_16K:\n\t\tos->os_dnodesize = newval;\n\t\tbreak;\n\t}\n}\n\nstatic void\nsmallblk_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\t \n\tASSERT(newval <= SPA_MAXBLOCKSIZE);\n\tASSERT(ISP2(newval));\n\n\tos->os_zpl_special_smallblock = newval;\n}\n\nstatic void\nlogbias_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\tASSERT(newval == ZFS_LOGBIAS_LATENCY ||\n\t    newval == ZFS_LOGBIAS_THROUGHPUT);\n\tos->os_logbias = newval;\n\tif (os->os_zil)\n\t\tzil_set_logbias(os->os_zil, newval);\n}\n\nstatic void\nrecordsize_changed_cb(void *arg, uint64_t newval)\n{\n\tobjset_t *os = arg;\n\n\tos->os_recordsize = newval;\n}\n\nvoid\ndmu_objset_byteswap(void *buf, size_t size)\n{\n\tobjset_phys_t *osp = buf;\n\n\tASSERT(size == OBJSET_PHYS_SIZE_V1 || size == OBJSET_PHYS_SIZE_V2 ||\n\t    size == sizeof (objset_phys_t));\n\tdnode_byteswap(&osp->os_meta_dnode);\n\tbyteswap_uint64_array(&osp->os_zil_header, sizeof (zil_header_t));\n\tosp->os_type = BSWAP_64(osp->os_type);\n\tosp->os_flags = BSWAP_64(osp->os_flags);\n\tif (size >= OBJSET_PHYS_SIZE_V2) {\n\t\tdnode_byteswap(&osp->os_userused_dnode);\n\t\tdnode_byteswap(&osp->os_groupused_dnode);\n\t\tif (size >= sizeof (objset_phys_t))\n\t\t\tdnode_byteswap(&osp->os_projectused_dnode);\n\t}\n}\n\n \nstatic uint64_t\ndnode_hash(const objset_t *os, uint64_t obj)\n{\n\tuintptr_t osv = (uintptr_t)os;\n\tuint64_t crc = -1ULL;\n\n\tASSERT(zfs_crc64_table[128] == ZFS_CRC64_POLY);\n\t \n\tcrc = (crc >> 8) ^ zfs_crc64_table[(crc ^ (osv >> 6)) & 0xFF];\n\tcrc = (crc >> 8) ^ zfs_crc64_table[(crc ^ (obj >> 0)) & 0xFF];\n\tcrc = (crc >> 8) ^ zfs_crc64_table[(crc ^ (obj >> 8)) & 0xFF];\n\tcrc = (crc >> 8) ^ zfs_crc64_table[(crc ^ (obj >> 16)) & 0xFF];\n\n\tcrc ^= (osv>>14) ^ (obj>>24);\n\n\treturn (crc);\n}\n\nstatic unsigned int\ndnode_multilist_index_func(multilist_t *ml, void *obj)\n{\n\tdnode_t *dn = obj;\n\n\t \n\treturn ((unsigned int)dnode_hash(dn->dn_objset, dn->dn_object) %\n\t    multilist_get_num_sublists(ml));\n}\n\nstatic inline boolean_t\ndmu_os_is_l2cacheable(objset_t *os)\n{\n\tif (os->os_secondary_cache == ZFS_CACHE_ALL ||\n\t    os->os_secondary_cache == ZFS_CACHE_METADATA) {\n\t\tif (l2arc_exclude_special == 0)\n\t\t\treturn (B_TRUE);\n\n\t\tblkptr_t *bp = os->os_rootbp;\n\t\tif (bp == NULL || BP_IS_HOLE(bp))\n\t\t\treturn (B_FALSE);\n\t\tuint64_t vdev = DVA_GET_VDEV(bp->blk_dva);\n\t\tvdev_t *rvd = os->os_spa->spa_root_vdev;\n\t\tvdev_t *vd = NULL;\n\n\t\tif (vdev < rvd->vdev_children)\n\t\t\tvd = rvd->vdev_child[vdev];\n\n\t\tif (vd == NULL)\n\t\t\treturn (B_TRUE);\n\n\t\tif (vd->vdev_alloc_bias != VDEV_BIAS_SPECIAL &&\n\t\t    vd->vdev_alloc_bias != VDEV_BIAS_DEDUP)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nint\ndmu_objset_open_impl(spa_t *spa, dsl_dataset_t *ds, blkptr_t *bp,\n    objset_t **osp)\n{\n\tobjset_t *os;\n\tint i, err;\n\n\tASSERT(ds == NULL || MUTEX_HELD(&ds->ds_opening_lock));\n\tASSERT(!BP_IS_REDACTED(bp));\n\n\t \n\tASSERT(ds == NULL || dsl_pool_config_held(ds->ds_dir->dd_pool));\n\n\t \n\tif (ds != NULL && spa_get_dsl(spa) != NULL &&\n\t    spa_get_dsl(spa)->dp_origin_snap != NULL) {\n\t\tASSERT3P(ds->ds_dir, !=,\n\t\t    spa_get_dsl(spa)->dp_origin_snap->ds_dir);\n\t}\n\n\tos = kmem_zalloc(sizeof (objset_t), KM_SLEEP);\n\tos->os_dsl_dataset = ds;\n\tos->os_spa = spa;\n\tos->os_rootbp = bp;\n\tif (!BP_IS_HOLE(os->os_rootbp)) {\n\t\tarc_flags_t aflags = ARC_FLAG_WAIT;\n\t\tzbookmark_phys_t zb;\n\t\tint size;\n\t\tzio_flag_t zio_flags = ZIO_FLAG_CANFAIL;\n\t\tSET_BOOKMARK(&zb, ds ? ds->ds_object : DMU_META_OBJSET,\n\t\t    ZB_ROOT_OBJECT, ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\n\t\tif (dmu_os_is_l2cacheable(os))\n\t\t\taflags |= ARC_FLAG_L2CACHE;\n\n\t\tif (ds != NULL && ds->ds_dir->dd_crypto_obj != 0) {\n\t\t\tASSERT3U(BP_GET_COMPRESS(bp), ==, ZIO_COMPRESS_OFF);\n\t\t\tASSERT(BP_IS_AUTHENTICATED(bp));\n\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\t\t}\n\n\t\tdprintf_bp(os->os_rootbp, \"reading %s\", \"\");\n\t\terr = arc_read(NULL, spa, os->os_rootbp,\n\t\t    arc_getbuf_func, &os->os_phys_buf,\n\t\t    ZIO_PRIORITY_SYNC_READ, zio_flags, &aflags, &zb);\n\t\tif (err != 0) {\n\t\t\tkmem_free(os, sizeof (objset_t));\n\t\t\t \n\t\t\tif (err == ECKSUM)\n\t\t\t\terr = SET_ERROR(EIO);\n\t\t\treturn (err);\n\t\t}\n\n\t\tif (spa_version(spa) < SPA_VERSION_USERSPACE)\n\t\t\tsize = OBJSET_PHYS_SIZE_V1;\n\t\telse if (!spa_feature_is_enabled(spa,\n\t\t    SPA_FEATURE_PROJECT_QUOTA))\n\t\t\tsize = OBJSET_PHYS_SIZE_V2;\n\t\telse\n\t\t\tsize = sizeof (objset_phys_t);\n\n\t\t \n\t\tif (arc_buf_size(os->os_phys_buf) < size) {\n\t\t\tarc_buf_t *buf = arc_alloc_buf(spa, &os->os_phys_buf,\n\t\t\t    ARC_BUFC_METADATA, size);\n\t\t\tmemset(buf->b_data, 0, size);\n\t\t\tmemcpy(buf->b_data, os->os_phys_buf->b_data,\n\t\t\t    arc_buf_size(os->os_phys_buf));\n\t\t\tarc_buf_destroy(os->os_phys_buf, &os->os_phys_buf);\n\t\t\tos->os_phys_buf = buf;\n\t\t}\n\n\t\tos->os_phys = os->os_phys_buf->b_data;\n\t\tos->os_flags = os->os_phys->os_flags;\n\t} else {\n\t\tint size = spa_version(spa) >= SPA_VERSION_USERSPACE ?\n\t\t    sizeof (objset_phys_t) : OBJSET_PHYS_SIZE_V1;\n\t\tos->os_phys_buf = arc_alloc_buf(spa, &os->os_phys_buf,\n\t\t    ARC_BUFC_METADATA, size);\n\t\tos->os_phys = os->os_phys_buf->b_data;\n\t\tmemset(os->os_phys, 0, size);\n\t}\n\t \n\tos->os_version = OBJSET_PROP_UNINITIALIZED;\n\tos->os_normalization = OBJSET_PROP_UNINITIALIZED;\n\tos->os_utf8only = OBJSET_PROP_UNINITIALIZED;\n\tos->os_casesensitivity = OBJSET_PROP_UNINITIALIZED;\n\n\t \n\tif (ds != NULL) {\n\t\tos->os_encrypted = (ds->ds_dir->dd_crypto_obj != 0);\n\n\t\terr = dsl_prop_register(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_PRIMARYCACHE),\n\t\t    primary_cache_changed_cb, os);\n\t\tif (err == 0) {\n\t\t\terr = dsl_prop_register(ds,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_SECONDARYCACHE),\n\t\t\t    secondary_cache_changed_cb, os);\n\t\t}\n\t\tif (!ds->ds_is_snapshot) {\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_CHECKSUM),\n\t\t\t\t    checksum_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_COMPRESSION),\n\t\t\t\t    compression_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_COPIES),\n\t\t\t\t    copies_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_DEDUP),\n\t\t\t\t    dedup_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_LOGBIAS),\n\t\t\t\t    logbias_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_SYNC),\n\t\t\t\t    sync_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(\n\t\t\t\t    ZFS_PROP_REDUNDANT_METADATA),\n\t\t\t\t    redundant_metadata_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_RECORDSIZE),\n\t\t\t\t    recordsize_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_DNODESIZE),\n\t\t\t\t    dnodesize_changed_cb, os);\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_register(ds,\n\t\t\t\t    zfs_prop_to_name(\n\t\t\t\t    ZFS_PROP_SPECIAL_SMALL_BLOCKS),\n\t\t\t\t    smallblk_changed_cb, os);\n\t\t\t}\n\t\t}\n\t\tif (err != 0) {\n\t\t\tarc_buf_destroy(os->os_phys_buf, &os->os_phys_buf);\n\t\t\tkmem_free(os, sizeof (objset_t));\n\t\t\treturn (err);\n\t\t}\n\t} else {\n\t\t \n\t\tos->os_checksum = ZIO_CHECKSUM_FLETCHER_4;\n\t\tos->os_compress = ZIO_COMPRESS_ON;\n\t\tos->os_complevel = ZIO_COMPLEVEL_DEFAULT;\n\t\tos->os_encrypted = B_FALSE;\n\t\tos->os_copies = spa_max_replication(spa);\n\t\tos->os_dedup_checksum = ZIO_CHECKSUM_OFF;\n\t\tos->os_dedup_verify = B_FALSE;\n\t\tos->os_logbias = ZFS_LOGBIAS_LATENCY;\n\t\tos->os_sync = ZFS_SYNC_STANDARD;\n\t\tos->os_primary_cache = ZFS_CACHE_ALL;\n\t\tos->os_secondary_cache = ZFS_CACHE_ALL;\n\t\tos->os_dnodesize = DNODE_MIN_SIZE;\n\t}\n\n\tif (ds == NULL || !ds->ds_is_snapshot)\n\t\tos->os_zil_header = os->os_phys->os_zil_header;\n\tos->os_zil = zil_alloc(os, &os->os_zil_header);\n\n\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\tmultilist_create(&os->os_dirty_dnodes[i], sizeof (dnode_t),\n\t\t    offsetof(dnode_t, dn_dirty_link[i]),\n\t\t    dnode_multilist_index_func);\n\t}\n\tlist_create(&os->os_dnodes, sizeof (dnode_t),\n\t    offsetof(dnode_t, dn_link));\n\tlist_create(&os->os_downgraded_dbufs, sizeof (dmu_buf_impl_t),\n\t    offsetof(dmu_buf_impl_t, db_link));\n\n\tlist_link_init(&os->os_evicting_node);\n\n\tmutex_init(&os->os_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&os->os_userused_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&os->os_obj_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&os->os_user_ptr_lock, NULL, MUTEX_DEFAULT, NULL);\n\tos->os_obj_next_percpu_len = boot_ncpus;\n\tos->os_obj_next_percpu = kmem_zalloc(os->os_obj_next_percpu_len *\n\t    sizeof (os->os_obj_next_percpu[0]), KM_SLEEP);\n\n\tdnode_special_open(os, &os->os_phys->os_meta_dnode,\n\t    DMU_META_DNODE_OBJECT, &os->os_meta_dnode);\n\tif (OBJSET_BUF_HAS_USERUSED(os->os_phys_buf)) {\n\t\tdnode_special_open(os, &os->os_phys->os_userused_dnode,\n\t\t    DMU_USERUSED_OBJECT, &os->os_userused_dnode);\n\t\tdnode_special_open(os, &os->os_phys->os_groupused_dnode,\n\t\t    DMU_GROUPUSED_OBJECT, &os->os_groupused_dnode);\n\t\tif (OBJSET_BUF_HAS_PROJECTUSED(os->os_phys_buf))\n\t\t\tdnode_special_open(os,\n\t\t\t    &os->os_phys->os_projectused_dnode,\n\t\t\t    DMU_PROJECTUSED_OBJECT, &os->os_projectused_dnode);\n\t}\n\n\tmutex_init(&os->os_upgrade_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\t*osp = os;\n\treturn (0);\n}\n\nint\ndmu_objset_from_ds(dsl_dataset_t *ds, objset_t **osp)\n{\n\tint err = 0;\n\n\t \n\tASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));\n\n\tmutex_enter(&ds->ds_opening_lock);\n\tif (ds->ds_objset == NULL) {\n\t\tobjset_t *os;\n\t\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\t\terr = dmu_objset_open_impl(dsl_dataset_get_spa(ds),\n\t\t    ds, dsl_dataset_get_blkptr(ds), &os);\n\t\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\n\t\tif (err == 0) {\n\t\t\tmutex_enter(&ds->ds_lock);\n\t\t\tASSERT(ds->ds_objset == NULL);\n\t\t\tds->ds_objset = os;\n\t\t\tmutex_exit(&ds->ds_lock);\n\t\t}\n\t}\n\t*osp = ds->ds_objset;\n\tmutex_exit(&ds->ds_opening_lock);\n\treturn (err);\n}\n\n \nint\ndmu_objset_hold_flags(const char *name, boolean_t decrypt, const void *tag,\n    objset_t **osp)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tint err;\n\tds_hold_flags_t flags;\n\n\tflags = (decrypt) ? DS_HOLD_FLAG_DECRYPT : DS_HOLD_FLAG_NONE;\n\terr = dsl_pool_hold(name, tag, &dp);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dsl_dataset_hold_flags(dp, name, flags, tag, &ds);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dp, tag);\n\t\treturn (err);\n\t}\n\n\terr = dmu_objset_from_ds(ds, osp);\n\tif (err != 0) {\n\t\tdsl_dataset_rele(ds, tag);\n\t\tdsl_pool_rele(dp, tag);\n\t}\n\n\treturn (err);\n}\n\nint\ndmu_objset_hold(const char *name, const void *tag, objset_t **osp)\n{\n\treturn (dmu_objset_hold_flags(name, B_FALSE, tag, osp));\n}\n\nstatic int\ndmu_objset_own_impl(dsl_dataset_t *ds, dmu_objset_type_t type,\n    boolean_t readonly, boolean_t decrypt, const void *tag, objset_t **osp)\n{\n\t(void) tag;\n\n\tint err = dmu_objset_from_ds(ds, osp);\n\tif (err != 0) {\n\t\treturn (err);\n\t} else if (type != DMU_OST_ANY && type != (*osp)->os_phys->os_type) {\n\t\treturn (SET_ERROR(EINVAL));\n\t} else if (!readonly && dsl_dataset_is_snapshot(ds)) {\n\t\treturn (SET_ERROR(EROFS));\n\t} else if (!readonly && decrypt &&\n\t    dsl_dir_incompatible_encryption_version(ds->ds_dir)) {\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\tif (decrypt && arc_is_unauthenticated((*osp)->os_phys_buf)) {\n\t\tzbookmark_phys_t zb;\n\n\t\tSET_BOOKMARK(&zb, ds->ds_object, ZB_ROOT_OBJECT,\n\t\t    ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\t\terr = arc_untransform((*osp)->os_phys_buf, (*osp)->os_spa,\n\t\t    &zb, B_FALSE);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tASSERT0(arc_is_unauthenticated((*osp)->os_phys_buf));\n\t}\n\n\treturn (0);\n}\n\n \nint\ndmu_objset_own(const char *name, dmu_objset_type_t type,\n    boolean_t readonly, boolean_t decrypt, const void *tag, objset_t **osp)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tint err;\n\tds_hold_flags_t flags;\n\n\tflags = (decrypt) ? DS_HOLD_FLAG_DECRYPT : DS_HOLD_FLAG_NONE;\n\terr = dsl_pool_hold(name, FTAG, &dp);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dsl_dataset_own(dp, name, flags, tag, &ds);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (err);\n\t}\n\terr = dmu_objset_own_impl(ds, type, readonly, decrypt, tag, osp);\n\tif (err != 0) {\n\t\tdsl_dataset_disown(ds, flags, tag);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (err);\n\t}\n\n\t \n\tif (!readonly && !dp->dp_spa->spa_claiming &&\n\t    (ds->ds_dir->dd_crypto_obj == 0 || decrypt)) {\n\t\tif (dmu_objset_userobjspace_upgradable(*osp) ||\n\t\t    dmu_objset_projectquota_upgradable(*osp)) {\n\t\t\tdmu_objset_id_quota_upgrade(*osp);\n\t\t} else if (dmu_objset_userused_enabled(*osp)) {\n\t\t\tdmu_objset_userspace_upgrade(*osp);\n\t\t}\n\t}\n\n\tdsl_pool_rele(dp, FTAG);\n\treturn (0);\n}\n\nint\ndmu_objset_own_obj(dsl_pool_t *dp, uint64_t obj, dmu_objset_type_t type,\n    boolean_t readonly, boolean_t decrypt, const void *tag, objset_t **osp)\n{\n\tdsl_dataset_t *ds;\n\tint err;\n\tds_hold_flags_t flags;\n\n\tflags = (decrypt) ? DS_HOLD_FLAG_DECRYPT : DS_HOLD_FLAG_NONE;\n\terr = dsl_dataset_own_obj(dp, obj, flags, tag, &ds);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = dmu_objset_own_impl(ds, type, readonly, decrypt, tag, osp);\n\tif (err != 0) {\n\t\tdsl_dataset_disown(ds, flags, tag);\n\t\treturn (err);\n\t}\n\n\treturn (0);\n}\n\nvoid\ndmu_objset_rele_flags(objset_t *os, boolean_t decrypt, const void *tag)\n{\n\tds_hold_flags_t flags;\n\tdsl_pool_t *dp = dmu_objset_pool(os);\n\n\tflags = (decrypt) ? DS_HOLD_FLAG_DECRYPT : DS_HOLD_FLAG_NONE;\n\tdsl_dataset_rele_flags(os->os_dsl_dataset, flags, tag);\n\tdsl_pool_rele(dp, tag);\n}\n\nvoid\ndmu_objset_rele(objset_t *os, const void *tag)\n{\n\tdmu_objset_rele_flags(os, B_FALSE, tag);\n}\n\n \nvoid\ndmu_objset_refresh_ownership(dsl_dataset_t *ds, dsl_dataset_t **newds,\n    boolean_t decrypt, const void *tag)\n{\n\tdsl_pool_t *dp;\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tds_hold_flags_t flags;\n\n\tflags = (decrypt) ? DS_HOLD_FLAG_DECRYPT : DS_HOLD_FLAG_NONE;\n\tVERIFY3P(ds, !=, NULL);\n\tVERIFY3P(ds->ds_owner, ==, tag);\n\tVERIFY(dsl_dataset_long_held(ds));\n\n\tdsl_dataset_name(ds, name);\n\tdp = ds->ds_dir->dd_pool;\n\tdsl_pool_config_enter(dp, FTAG);\n\tdsl_dataset_disown(ds, flags, tag);\n\tVERIFY0(dsl_dataset_own(dp, name, flags, tag, newds));\n\tdsl_pool_config_exit(dp, FTAG);\n}\n\nvoid\ndmu_objset_disown(objset_t *os, boolean_t decrypt, const void *tag)\n{\n\tds_hold_flags_t flags;\n\n\tflags = (decrypt) ? DS_HOLD_FLAG_DECRYPT : DS_HOLD_FLAG_NONE;\n\t \n\tdmu_objset_upgrade_stop(os);\n\tdsl_dataset_disown(os->os_dsl_dataset, flags, tag);\n}\n\nvoid\ndmu_objset_evict_dbufs(objset_t *os)\n{\n\tdnode_t *dn_marker;\n\tdnode_t *dn;\n\n\tdn_marker = kmem_alloc(sizeof (dnode_t), KM_SLEEP);\n\n\tmutex_enter(&os->os_lock);\n\tdn = list_head(&os->os_dnodes);\n\twhile (dn != NULL) {\n\t\t \n\t\tif (dnode_add_ref(dn, FTAG)) {\n\t\t\tlist_insert_after(&os->os_dnodes, dn, dn_marker);\n\t\t\tmutex_exit(&os->os_lock);\n\n\t\t\tdnode_evict_dbufs(dn);\n\t\t\tdnode_rele(dn, FTAG);\n\n\t\t\tmutex_enter(&os->os_lock);\n\t\t\tdn = list_next(&os->os_dnodes, dn_marker);\n\t\t\tlist_remove(&os->os_dnodes, dn_marker);\n\t\t} else {\n\t\t\tdn = list_next(&os->os_dnodes, dn);\n\t\t}\n\t}\n\tmutex_exit(&os->os_lock);\n\n\tkmem_free(dn_marker, sizeof (dnode_t));\n\n\tif (DMU_USERUSED_DNODE(os) != NULL) {\n\t\tif (DMU_PROJECTUSED_DNODE(os) != NULL)\n\t\t\tdnode_evict_dbufs(DMU_PROJECTUSED_DNODE(os));\n\t\tdnode_evict_dbufs(DMU_GROUPUSED_DNODE(os));\n\t\tdnode_evict_dbufs(DMU_USERUSED_DNODE(os));\n\t}\n\tdnode_evict_dbufs(DMU_META_DNODE(os));\n}\n\n \nvoid\ndmu_objset_evict(objset_t *os)\n{\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\n\tfor (int t = 0; t < TXG_SIZE; t++)\n\t\tASSERT(!dmu_objset_is_dirty(os, t));\n\n\tif (ds)\n\t\tdsl_prop_unregister_all(ds, os);\n\n\tif (os->os_sa)\n\t\tsa_tear_down(os);\n\n\tdmu_objset_evict_dbufs(os);\n\n\tmutex_enter(&os->os_lock);\n\tspa_evicting_os_register(os->os_spa, os);\n\tif (list_is_empty(&os->os_dnodes)) {\n\t\tmutex_exit(&os->os_lock);\n\t\tdmu_objset_evict_done(os);\n\t} else {\n\t\tmutex_exit(&os->os_lock);\n\t}\n\n\n}\n\nvoid\ndmu_objset_evict_done(objset_t *os)\n{\n\tASSERT3P(list_head(&os->os_dnodes), ==, NULL);\n\n\tdnode_special_close(&os->os_meta_dnode);\n\tif (DMU_USERUSED_DNODE(os)) {\n\t\tif (DMU_PROJECTUSED_DNODE(os))\n\t\t\tdnode_special_close(&os->os_projectused_dnode);\n\t\tdnode_special_close(&os->os_userused_dnode);\n\t\tdnode_special_close(&os->os_groupused_dnode);\n\t}\n\tzil_free(os->os_zil);\n\n\tarc_buf_destroy(os->os_phys_buf, &os->os_phys_buf);\n\n\t \n\trw_enter(&os_lock, RW_READER);\n\trw_exit(&os_lock);\n\n\tkmem_free(os->os_obj_next_percpu,\n\t    os->os_obj_next_percpu_len * sizeof (os->os_obj_next_percpu[0]));\n\n\tmutex_destroy(&os->os_lock);\n\tmutex_destroy(&os->os_userused_lock);\n\tmutex_destroy(&os->os_obj_lock);\n\tmutex_destroy(&os->os_user_ptr_lock);\n\tmutex_destroy(&os->os_upgrade_lock);\n\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\tmultilist_destroy(&os->os_dirty_dnodes[i]);\n\tspa_evicting_os_deregister(os->os_spa, os);\n\tkmem_free(os, sizeof (objset_t));\n}\n\ninode_timespec_t\ndmu_objset_snap_cmtime(objset_t *os)\n{\n\treturn (dsl_dir_snap_cmtime(os->os_dsl_dataset->ds_dir));\n}\n\nobjset_t *\ndmu_objset_create_impl_dnstats(spa_t *spa, dsl_dataset_t *ds, blkptr_t *bp,\n    dmu_objset_type_t type, int levels, int blksz, int ibs, dmu_tx_t *tx)\n{\n\tobjset_t *os;\n\tdnode_t *mdn;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tif (blksz == 0)\n\t\tblksz = DNODE_BLOCK_SIZE;\n\tif (ibs == 0)\n\t\tibs = DN_MAX_INDBLKSHIFT;\n\n\tif (ds != NULL)\n\t\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\telse\n\t\tVERIFY0(dmu_objset_open_impl(spa, NULL, bp, &os));\n\n\tmdn = DMU_META_DNODE(os);\n\n\tdnode_allocate(mdn, DMU_OT_DNODE, blksz, ibs, DMU_OT_NONE, 0,\n\t    DNODE_MIN_SLOTS, tx);\n\n\t \n\tif (ds != NULL) {\n\t\tif (levels == 0) {\n\t\t\tlevels = 1;\n\n\t\t\t \n\t\t\twhile ((uint64_t)mdn->dn_nblkptr <<\n\t\t\t    (mdn->dn_datablkshift - DNODE_SHIFT + (levels - 1) *\n\t\t\t    (mdn->dn_indblkshift - SPA_BLKPTRSHIFT)) <\n\t\t\t    DN_MAX_OBJECT)\n\t\t\t\tlevels++;\n\t\t}\n\n\t\tmdn->dn_next_nlevels[tx->tx_txg & TXG_MASK] =\n\t\t    mdn->dn_nlevels = levels;\n\t}\n\n\tASSERT(type != DMU_OST_NONE);\n\tASSERT(type != DMU_OST_ANY);\n\tASSERT(type < DMU_OST_NUMTYPES);\n\tos->os_phys->os_type = type;\n\n\t \n\tif (dmu_objset_userused_enabled(os) &&\n\t    (!os->os_encrypted || !dmu_objset_is_receiving(os))) {\n\t\tos->os_phys->os_flags |= OBJSET_FLAG_USERACCOUNTING_COMPLETE;\n\t\tif (dmu_objset_userobjused_enabled(os)) {\n\t\t\tASSERT3P(ds, !=, NULL);\n\t\t\tds->ds_feature_activation[\n\t\t\t    SPA_FEATURE_USEROBJ_ACCOUNTING] = (void *)B_TRUE;\n\t\t\tos->os_phys->os_flags |=\n\t\t\t    OBJSET_FLAG_USEROBJACCOUNTING_COMPLETE;\n\t\t}\n\t\tif (dmu_objset_projectquota_enabled(os)) {\n\t\t\tASSERT3P(ds, !=, NULL);\n\t\t\tds->ds_feature_activation[\n\t\t\t    SPA_FEATURE_PROJECT_QUOTA] = (void *)B_TRUE;\n\t\t\tos->os_phys->os_flags |=\n\t\t\t    OBJSET_FLAG_PROJECTQUOTA_COMPLETE;\n\t\t}\n\t\tos->os_flags = os->os_phys->os_flags;\n\t}\n\n\tdsl_dataset_dirty(ds, tx);\n\n\treturn (os);\n}\n\n \nobjset_t *\ndmu_objset_create_impl(spa_t *spa, dsl_dataset_t *ds, blkptr_t *bp,\n    dmu_objset_type_t type, dmu_tx_t *tx)\n{\n\treturn (dmu_objset_create_impl_dnstats(spa, ds, bp, type, 0, 0, 0, tx));\n}\n\ntypedef struct dmu_objset_create_arg {\n\tconst char *doca_name;\n\tcred_t *doca_cred;\n\tproc_t *doca_proc;\n\tvoid (*doca_userfunc)(objset_t *os, void *arg,\n\t    cred_t *cr, dmu_tx_t *tx);\n\tvoid *doca_userarg;\n\tdmu_objset_type_t doca_type;\n\tuint64_t doca_flags;\n\tdsl_crypto_params_t *doca_dcp;\n} dmu_objset_create_arg_t;\n\nstatic int\ndmu_objset_create_check(void *arg, dmu_tx_t *tx)\n{\n\tdmu_objset_create_arg_t *doca = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *pdd;\n\tdsl_dataset_t *parentds;\n\tobjset_t *parentos;\n\tconst char *tail;\n\tint error;\n\n\tif (strchr(doca->doca_name, '@') != NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (strlen(doca->doca_name) >= ZFS_MAX_DATASET_NAME_LEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\tif (dataset_nestcheck(doca->doca_name) != 0)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\terror = dsl_dir_hold(dp, doca->doca_name, FTAG, &pdd, &tail);\n\tif (error != 0)\n\t\treturn (error);\n\tif (tail == NULL) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (SET_ERROR(EEXIST));\n\t}\n\n\terror = dmu_objset_create_crypt_check(pdd, doca->doca_dcp, NULL);\n\tif (error != 0) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = dsl_fs_ss_limit_check(pdd, 1, ZFS_PROP_FILESYSTEM_LIMIT, NULL,\n\t    doca->doca_cred, doca->doca_proc);\n\tif (error != 0) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = dsl_dataset_hold_obj(pdd->dd_pool,\n\t    dsl_dir_phys(pdd)->dd_head_dataset_obj, FTAG, &parentds);\n\tif (error != 0) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (error);\n\t}\n\terror = dmu_objset_from_ds(parentds, &parentos);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(parentds, FTAG);\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (error);\n\t}\n\tif (dmu_objset_type(parentos) != DMU_OST_ZFS) {\n\t\tdsl_dataset_rele(parentds, FTAG);\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (SET_ERROR(ZFS_ERR_WRONG_PARENT));\n\t}\n\tdsl_dataset_rele(parentds, FTAG);\n\tdsl_dir_rele(pdd, FTAG);\n\n\treturn (error);\n}\n\nstatic void\ndmu_objset_create_sync(void *arg, dmu_tx_t *tx)\n{\n\tdmu_objset_create_arg_t *doca = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tspa_t *spa = dp->dp_spa;\n\tdsl_dir_t *pdd;\n\tconst char *tail;\n\tdsl_dataset_t *ds;\n\tuint64_t obj;\n\tblkptr_t *bp;\n\tobjset_t *os;\n\tzio_t *rzio;\n\n\tVERIFY0(dsl_dir_hold(dp, doca->doca_name, FTAG, &pdd, &tail));\n\n\tobj = dsl_dataset_create_sync(pdd, tail, NULL, doca->doca_flags,\n\t    doca->doca_cred, doca->doca_dcp, tx);\n\n\tVERIFY0(dsl_dataset_hold_obj_flags(pdd->dd_pool, obj,\n\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds));\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tbp = dsl_dataset_get_blkptr(ds);\n\tos = dmu_objset_create_impl(spa, ds, bp, doca->doca_type, tx);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\n\tif (doca->doca_userfunc != NULL) {\n\t\tdoca->doca_userfunc(os, doca->doca_userarg,\n\t\t    doca->doca_cred, tx);\n\t}\n\n\t \n\tif (os->os_encrypted) {\n\t\tdsl_dataset_t *tmpds = NULL;\n\t\tboolean_t need_sync_done = B_FALSE;\n\n\t\tmutex_enter(&ds->ds_lock);\n\t\tds->ds_owner = FTAG;\n\t\tmutex_exit(&ds->ds_lock);\n\n\t\trzio = zio_root(spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\t\ttmpds = txg_list_remove_this(&dp->dp_dirty_datasets, ds,\n\t\t    tx->tx_txg);\n\t\tif (tmpds != NULL) {\n\t\t\tdsl_dataset_sync(ds, rzio, tx);\n\t\t\tneed_sync_done = B_TRUE;\n\t\t}\n\t\tVERIFY0(zio_wait(rzio));\n\n\t\tdmu_objset_sync_done(os, tx);\n\t\ttaskq_wait(dp->dp_sync_taskq);\n\t\tif (txg_list_member(&dp->dp_dirty_datasets, ds, tx->tx_txg)) {\n\t\t\tASSERT3P(ds->ds_key_mapping, !=, NULL);\n\t\t\tkey_mapping_rele(spa, ds->ds_key_mapping, ds);\n\t\t}\n\n\t\trzio = zio_root(spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\t\ttmpds = txg_list_remove_this(&dp->dp_dirty_datasets, ds,\n\t\t    tx->tx_txg);\n\t\tif (tmpds != NULL) {\n\t\t\tdmu_buf_rele(ds->ds_dbuf, ds);\n\t\t\tdsl_dataset_sync(ds, rzio, tx);\n\t\t}\n\t\tVERIFY0(zio_wait(rzio));\n\n\t\tif (need_sync_done) {\n\t\t\tASSERT3P(ds->ds_key_mapping, !=, NULL);\n\t\t\tkey_mapping_rele(spa, ds->ds_key_mapping, ds);\n\t\t\tdsl_dataset_sync_done(ds, tx);\n\t\t\tdmu_buf_rele(ds->ds_dbuf, ds);\n\t\t}\n\n\t\tmutex_enter(&ds->ds_lock);\n\t\tds->ds_owner = NULL;\n\t\tmutex_exit(&ds->ds_lock);\n\t}\n\n\tspa_history_log_internal_ds(ds, \"create\", tx, \" \");\n\n\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\tdsl_dir_rele(pdd, FTAG);\n}\n\nint\ndmu_objset_create(const char *name, dmu_objset_type_t type, uint64_t flags,\n    dsl_crypto_params_t *dcp, dmu_objset_create_sync_func_t func, void *arg)\n{\n\tdmu_objset_create_arg_t doca;\n\tdsl_crypto_params_t tmp_dcp = { 0 };\n\n\tdoca.doca_name = name;\n\tdoca.doca_cred = CRED();\n\tdoca.doca_proc = curproc;\n\tdoca.doca_flags = flags;\n\tdoca.doca_userfunc = func;\n\tdoca.doca_userarg = arg;\n\tdoca.doca_type = type;\n\n\t \n\tdoca.doca_dcp = (dcp != NULL) ? dcp : &tmp_dcp;\n\n\tint rv = dsl_sync_task(name,\n\t    dmu_objset_create_check, dmu_objset_create_sync, &doca,\n\t    6, ZFS_SPACE_CHECK_NORMAL);\n\n\tif (rv == 0)\n\t\tzvol_create_minor(name);\n\treturn (rv);\n}\n\ntypedef struct dmu_objset_clone_arg {\n\tconst char *doca_clone;\n\tconst char *doca_origin;\n\tcred_t *doca_cred;\n\tproc_t *doca_proc;\n} dmu_objset_clone_arg_t;\n\nstatic int\ndmu_objset_clone_check(void *arg, dmu_tx_t *tx)\n{\n\tdmu_objset_clone_arg_t *doca = arg;\n\tdsl_dir_t *pdd;\n\tconst char *tail;\n\tint error;\n\tdsl_dataset_t *origin;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\tif (strchr(doca->doca_clone, '@') != NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (strlen(doca->doca_clone) >= ZFS_MAX_DATASET_NAME_LEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\terror = dsl_dir_hold(dp, doca->doca_clone, FTAG, &pdd, &tail);\n\tif (error != 0)\n\t\treturn (error);\n\tif (tail == NULL) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (SET_ERROR(EEXIST));\n\t}\n\n\terror = dsl_fs_ss_limit_check(pdd, 1, ZFS_PROP_FILESYSTEM_LIMIT, NULL,\n\t    doca->doca_cred, doca->doca_proc);\n\tif (error != 0) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\terror = dsl_dataset_hold(dp, doca->doca_origin, FTAG, &origin);\n\tif (error != 0) {\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (!origin->ds_is_snapshot) {\n\t\tdsl_dataset_rele(origin, FTAG);\n\t\tdsl_dir_rele(pdd, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tdsl_dataset_rele(origin, FTAG);\n\tdsl_dir_rele(pdd, FTAG);\n\n\treturn (0);\n}\n\nstatic void\ndmu_objset_clone_sync(void *arg, dmu_tx_t *tx)\n{\n\tdmu_objset_clone_arg_t *doca = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *pdd;\n\tconst char *tail;\n\tdsl_dataset_t *origin, *ds;\n\tuint64_t obj;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\n\tVERIFY0(dsl_dir_hold(dp, doca->doca_clone, FTAG, &pdd, &tail));\n\tVERIFY0(dsl_dataset_hold(dp, doca->doca_origin, FTAG, &origin));\n\n\tobj = dsl_dataset_create_sync(pdd, tail, origin, 0,\n\t    doca->doca_cred, NULL, tx);\n\n\tVERIFY0(dsl_dataset_hold_obj(pdd->dd_pool, obj, FTAG, &ds));\n\tdsl_dataset_name(origin, namebuf);\n\tspa_history_log_internal_ds(ds, \"clone\", tx,\n\t    \"origin=%s (%llu)\", namebuf, (u_longlong_t)origin->ds_object);\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_dataset_rele(origin, FTAG);\n\tdsl_dir_rele(pdd, FTAG);\n}\n\nint\ndmu_objset_clone(const char *clone, const char *origin)\n{\n\tdmu_objset_clone_arg_t doca;\n\n\tdoca.doca_clone = clone;\n\tdoca.doca_origin = origin;\n\tdoca.doca_cred = CRED();\n\tdoca.doca_proc = curproc;\n\n\tint rv = dsl_sync_task(clone,\n\t    dmu_objset_clone_check, dmu_objset_clone_sync, &doca,\n\t    6, ZFS_SPACE_CHECK_NORMAL);\n\n\tif (rv == 0)\n\t\tzvol_create_minor(clone);\n\n\treturn (rv);\n}\n\nint\ndmu_objset_snapshot_one(const char *fsname, const char *snapname)\n{\n\tint err;\n\tchar *longsnap = kmem_asprintf(\"%s@%s\", fsname, snapname);\n\tnvlist_t *snaps = fnvlist_alloc();\n\n\tfnvlist_add_boolean(snaps, longsnap);\n\tkmem_strfree(longsnap);\n\terr = dsl_dataset_snapshot(snaps, NULL, NULL);\n\tfnvlist_free(snaps);\n\treturn (err);\n}\n\nstatic void\ndmu_objset_upgrade_task_cb(void *data)\n{\n\tobjset_t *os = data;\n\n\tmutex_enter(&os->os_upgrade_lock);\n\tos->os_upgrade_status = EINTR;\n\tif (!os->os_upgrade_exit) {\n\t\tint status;\n\n\t\tmutex_exit(&os->os_upgrade_lock);\n\n\t\tstatus = os->os_upgrade_cb(os);\n\n\t\tmutex_enter(&os->os_upgrade_lock);\n\n\t\tos->os_upgrade_status = status;\n\t}\n\tos->os_upgrade_exit = B_TRUE;\n\tos->os_upgrade_id = 0;\n\tmutex_exit(&os->os_upgrade_lock);\n\tdsl_dataset_long_rele(dmu_objset_ds(os), upgrade_tag);\n}\n\nstatic void\ndmu_objset_upgrade(objset_t *os, dmu_objset_upgrade_cb_t cb)\n{\n\tif (os->os_upgrade_id != 0)\n\t\treturn;\n\n\tASSERT(dsl_pool_config_held(dmu_objset_pool(os)));\n\tdsl_dataset_long_hold(dmu_objset_ds(os), upgrade_tag);\n\n\tmutex_enter(&os->os_upgrade_lock);\n\tif (os->os_upgrade_id == 0 && os->os_upgrade_status == 0) {\n\t\tos->os_upgrade_exit = B_FALSE;\n\t\tos->os_upgrade_cb = cb;\n\t\tos->os_upgrade_id = taskq_dispatch(\n\t\t    os->os_spa->spa_upgrade_taskq,\n\t\t    dmu_objset_upgrade_task_cb, os, TQ_SLEEP);\n\t\tif (os->os_upgrade_id == TASKQID_INVALID) {\n\t\t\tdsl_dataset_long_rele(dmu_objset_ds(os), upgrade_tag);\n\t\t\tos->os_upgrade_status = ENOMEM;\n\t\t}\n\t} else {\n\t\tdsl_dataset_long_rele(dmu_objset_ds(os), upgrade_tag);\n\t}\n\tmutex_exit(&os->os_upgrade_lock);\n}\n\nstatic void\ndmu_objset_upgrade_stop(objset_t *os)\n{\n\tmutex_enter(&os->os_upgrade_lock);\n\tos->os_upgrade_exit = B_TRUE;\n\tif (os->os_upgrade_id != 0) {\n\t\ttaskqid_t id = os->os_upgrade_id;\n\n\t\tos->os_upgrade_id = 0;\n\t\tmutex_exit(&os->os_upgrade_lock);\n\n\t\tif ((taskq_cancel_id(os->os_spa->spa_upgrade_taskq, id)) == 0) {\n\t\t\tdsl_dataset_long_rele(dmu_objset_ds(os), upgrade_tag);\n\t\t}\n\t\ttxg_wait_synced(os->os_spa->spa_dsl_pool, 0);\n\t} else {\n\t\tmutex_exit(&os->os_upgrade_lock);\n\t}\n}\n\nstatic void\ndmu_objset_sync_dnodes(multilist_sublist_t *list, dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\n\twhile ((dn = multilist_sublist_head(list)) != NULL) {\n\t\tASSERT(dn->dn_object != DMU_META_DNODE_OBJECT);\n\t\tASSERT(dn->dn_dbuf->db_data_pending);\n\t\t \n\t\tdn->dn_zio = dn->dn_dbuf->db_data_pending->dr_zio;\n\t\tASSERT(dn->dn_zio);\n\n\t\tASSERT3U(dn->dn_nlevels, <=, DN_MAX_LEVELS);\n\t\tmultilist_sublist_remove(list, dn);\n\n\t\t \n\t\tmultilist_t *newlist = &dn->dn_objset->os_synced_dnodes;\n\t\t(void) dnode_add_ref(dn, newlist);\n\t\tmultilist_insert(newlist, dn);\n\n\t\tdnode_sync(dn, tx);\n\t}\n}\n\nstatic void\ndmu_objset_write_ready(zio_t *zio, arc_buf_t *abuf, void *arg)\n{\n\t(void) abuf;\n\tblkptr_t *bp = zio->io_bp;\n\tobjset_t *os = arg;\n\tdnode_phys_t *dnp = &os->os_phys->os_meta_dnode;\n\tuint64_t fill = 0;\n\n\tASSERT(!BP_IS_EMBEDDED(bp));\n\tASSERT3U(BP_GET_TYPE(bp), ==, DMU_OT_OBJSET);\n\tASSERT0(BP_GET_LEVEL(bp));\n\n\t \n\tfor (int i = 0; i < dnp->dn_nblkptr; i++)\n\t\tfill += BP_GET_FILL(&dnp->dn_blkptr[i]);\n\n\tBP_SET_FILL(bp, fill);\n\n\tif (os->os_dsl_dataset != NULL)\n\t\trrw_enter(&os->os_dsl_dataset->ds_bp_rwlock, RW_WRITER, FTAG);\n\t*os->os_rootbp = *bp;\n\tif (os->os_dsl_dataset != NULL)\n\t\trrw_exit(&os->os_dsl_dataset->ds_bp_rwlock, FTAG);\n}\n\nstatic void\ndmu_objset_write_done(zio_t *zio, arc_buf_t *abuf, void *arg)\n{\n\t(void) abuf;\n\tblkptr_t *bp = zio->io_bp;\n\tblkptr_t *bp_orig = &zio->io_bp_orig;\n\tobjset_t *os = arg;\n\n\tif (zio->io_flags & ZIO_FLAG_IO_REWRITE) {\n\t\tASSERT(BP_EQUAL(bp, bp_orig));\n\t} else {\n\t\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\t\tdmu_tx_t *tx = os->os_synctx;\n\n\t\t(void) dsl_dataset_block_kill(ds, bp_orig, tx, B_TRUE);\n\t\tdsl_dataset_block_born(ds, bp, tx);\n\t}\n\tkmem_free(bp, sizeof (*bp));\n}\n\ntypedef struct sync_dnodes_arg {\n\tmultilist_t *sda_list;\n\tint sda_sublist_idx;\n\tmultilist_t *sda_newlist;\n\tdmu_tx_t *sda_tx;\n} sync_dnodes_arg_t;\n\nstatic void\nsync_dnodes_task(void *arg)\n{\n\tsync_dnodes_arg_t *sda = arg;\n\n\tmultilist_sublist_t *ms =\n\t    multilist_sublist_lock(sda->sda_list, sda->sda_sublist_idx);\n\n\tdmu_objset_sync_dnodes(ms, sda->sda_tx);\n\n\tmultilist_sublist_unlock(ms);\n\n\tkmem_free(sda, sizeof (*sda));\n}\n\n\n \nvoid\ndmu_objset_sync(objset_t *os, zio_t *pio, dmu_tx_t *tx)\n{\n\tint txgoff;\n\tzbookmark_phys_t zb;\n\tzio_prop_t zp;\n\tzio_t *zio;\n\tlist_t *list;\n\tdbuf_dirty_record_t *dr;\n\tint num_sublists;\n\tmultilist_t *ml;\n\tblkptr_t *blkptr_copy = kmem_alloc(sizeof (*os->os_rootbp), KM_SLEEP);\n\t*blkptr_copy = *os->os_rootbp;\n\n\tdprintf_ds(os->os_dsl_dataset, \"txg=%llu\\n\", (u_longlong_t)tx->tx_txg);\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\t \n\tos->os_synctx = tx;\n\n\tif (os->os_dsl_dataset == NULL) {\n\t\t \n\t\tos->os_copies = spa_max_replication(os->os_spa);\n\t}\n\n\t \n\tSET_BOOKMARK(&zb, os->os_dsl_dataset ?\n\t    os->os_dsl_dataset->ds_object : DMU_META_OBJSET,\n\t    ZB_ROOT_OBJECT, ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\tarc_release(os->os_phys_buf, &os->os_phys_buf);\n\n\tdmu_write_policy(os, NULL, 0, 0, &zp);\n\n\t \n\tif (os->os_raw_receive ||\n\t    os->os_next_write_raw[tx->tx_txg & TXG_MASK]) {\n\t\tASSERT(os->os_encrypted);\n\t\tarc_convert_to_raw(os->os_phys_buf,\n\t\t    os->os_dsl_dataset->ds_object, ZFS_HOST_BYTEORDER,\n\t\t    DMU_OT_OBJSET, NULL, NULL, NULL);\n\t}\n\n\tzio = arc_write(pio, os->os_spa, tx->tx_txg,\n\t    blkptr_copy, os->os_phys_buf, B_FALSE, dmu_os_is_l2cacheable(os),\n\t    &zp, dmu_objset_write_ready, NULL, dmu_objset_write_done,\n\t    os, ZIO_PRIORITY_ASYNC_WRITE, ZIO_FLAG_MUSTSUCCEED, &zb);\n\n\t \n\tDMU_META_DNODE(os)->dn_zio = zio;\n\tdnode_sync(DMU_META_DNODE(os), tx);\n\n\tos->os_phys->os_flags = os->os_flags;\n\n\tif (DMU_USERUSED_DNODE(os) &&\n\t    DMU_USERUSED_DNODE(os)->dn_type != DMU_OT_NONE) {\n\t\tDMU_USERUSED_DNODE(os)->dn_zio = zio;\n\t\tdnode_sync(DMU_USERUSED_DNODE(os), tx);\n\t\tDMU_GROUPUSED_DNODE(os)->dn_zio = zio;\n\t\tdnode_sync(DMU_GROUPUSED_DNODE(os), tx);\n\t}\n\n\tif (DMU_PROJECTUSED_DNODE(os) &&\n\t    DMU_PROJECTUSED_DNODE(os)->dn_type != DMU_OT_NONE) {\n\t\tDMU_PROJECTUSED_DNODE(os)->dn_zio = zio;\n\t\tdnode_sync(DMU_PROJECTUSED_DNODE(os), tx);\n\t}\n\n\ttxgoff = tx->tx_txg & TXG_MASK;\n\n\t \n\tif (os->os_synced_dnodes.ml_sublists == NULL) {\n\t\tmultilist_create(&os->os_synced_dnodes, sizeof (dnode_t),\n\t\t    offsetof(dnode_t, dn_dirty_link[txgoff]),\n\t\t    dnode_multilist_index_func);\n\t} else {\n\t\tASSERT3U(os->os_synced_dnodes.ml_offset, ==,\n\t\t    offsetof(dnode_t, dn_dirty_link[txgoff]));\n\t}\n\n\tml = &os->os_dirty_dnodes[txgoff];\n\tnum_sublists = multilist_get_num_sublists(ml);\n\tfor (int i = 0; i < num_sublists; i++) {\n\t\tif (multilist_sublist_is_empty_idx(ml, i))\n\t\t\tcontinue;\n\t\tsync_dnodes_arg_t *sda = kmem_alloc(sizeof (*sda), KM_SLEEP);\n\t\tsda->sda_list = ml;\n\t\tsda->sda_sublist_idx = i;\n\t\tsda->sda_tx = tx;\n\t\t(void) taskq_dispatch(dmu_objset_pool(os)->dp_sync_taskq,\n\t\t    sync_dnodes_task, sda, 0);\n\t\t \n\t}\n\ttaskq_wait(dmu_objset_pool(os)->dp_sync_taskq);\n\n\tlist = &DMU_META_DNODE(os)->dn_dirty_records[txgoff];\n\twhile ((dr = list_remove_head(list)) != NULL) {\n\t\tASSERT0(dr->dr_dbuf->db_level);\n\t\tzio_nowait(dr->dr_zio);\n\t}\n\n\t \n\tif (os->os_freed_dnodes >= dmu_rescan_dnode_threshold) {\n\t\tos->os_rescan_dnodes = B_TRUE;\n\t\tos->os_freed_dnodes = 0;\n\t}\n\n\t \n\tzil_sync(os->os_zil, tx);\n\tos->os_phys->os_zil_header = os->os_zil_header;\n\tzio_nowait(zio);\n}\n\nboolean_t\ndmu_objset_is_dirty(objset_t *os, uint64_t txg)\n{\n\treturn (!multilist_is_empty(&os->os_dirty_dnodes[txg & TXG_MASK]));\n}\n\nstatic file_info_cb_t *file_cbs[DMU_OST_NUMTYPES];\n\nvoid\ndmu_objset_register_type(dmu_objset_type_t ost, file_info_cb_t *cb)\n{\n\tfile_cbs[ost] = cb;\n}\n\nint\ndmu_get_file_info(objset_t *os, dmu_object_type_t bonustype, const void *data,\n    zfs_file_info_t *zfi)\n{\n\tfile_info_cb_t *cb = file_cbs[os->os_phys->os_type];\n\tif (cb == NULL)\n\t\treturn (EINVAL);\n\treturn (cb(bonustype, data, zfi));\n}\n\nboolean_t\ndmu_objset_userused_enabled(objset_t *os)\n{\n\treturn (spa_version(os->os_spa) >= SPA_VERSION_USERSPACE &&\n\t    file_cbs[os->os_phys->os_type] != NULL &&\n\t    DMU_USERUSED_DNODE(os) != NULL);\n}\n\nboolean_t\ndmu_objset_userobjused_enabled(objset_t *os)\n{\n\treturn (dmu_objset_userused_enabled(os) &&\n\t    spa_feature_is_enabled(os->os_spa, SPA_FEATURE_USEROBJ_ACCOUNTING));\n}\n\nboolean_t\ndmu_objset_projectquota_enabled(objset_t *os)\n{\n\treturn (file_cbs[os->os_phys->os_type] != NULL &&\n\t    DMU_PROJECTUSED_DNODE(os) != NULL &&\n\t    spa_feature_is_enabled(os->os_spa, SPA_FEATURE_PROJECT_QUOTA));\n}\n\ntypedef struct userquota_node {\n\t \n\tchar\t\tuqn_id[20 + DMU_OBJACCT_PREFIX_LEN];\n\tint64_t\t\tuqn_delta;\n\tavl_node_t\tuqn_node;\n} userquota_node_t;\n\ntypedef struct userquota_cache {\n\tavl_tree_t uqc_user_deltas;\n\tavl_tree_t uqc_group_deltas;\n\tavl_tree_t uqc_project_deltas;\n} userquota_cache_t;\n\nstatic int\nuserquota_compare(const void *l, const void *r)\n{\n\tconst userquota_node_t *luqn = l;\n\tconst userquota_node_t *ruqn = r;\n\tint rv;\n\n\t \n\trv = strcmp(luqn->uqn_id, ruqn->uqn_id);\n\n\treturn (TREE_ISIGN(rv));\n}\n\nstatic void\ndo_userquota_cacheflush(objset_t *os, userquota_cache_t *cache, dmu_tx_t *tx)\n{\n\tvoid *cookie;\n\tuserquota_node_t *uqn;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tcookie = NULL;\n\twhile ((uqn = avl_destroy_nodes(&cache->uqc_user_deltas,\n\t    &cookie)) != NULL) {\n\t\t \n\t\tmutex_enter(&os->os_userused_lock);\n\t\tVERIFY0(zap_increment(os, DMU_USERUSED_OBJECT,\n\t\t    uqn->uqn_id, uqn->uqn_delta, tx));\n\t\tmutex_exit(&os->os_userused_lock);\n\t\tkmem_free(uqn, sizeof (*uqn));\n\t}\n\tavl_destroy(&cache->uqc_user_deltas);\n\n\tcookie = NULL;\n\twhile ((uqn = avl_destroy_nodes(&cache->uqc_group_deltas,\n\t    &cookie)) != NULL) {\n\t\tmutex_enter(&os->os_userused_lock);\n\t\tVERIFY0(zap_increment(os, DMU_GROUPUSED_OBJECT,\n\t\t    uqn->uqn_id, uqn->uqn_delta, tx));\n\t\tmutex_exit(&os->os_userused_lock);\n\t\tkmem_free(uqn, sizeof (*uqn));\n\t}\n\tavl_destroy(&cache->uqc_group_deltas);\n\n\tif (dmu_objset_projectquota_enabled(os)) {\n\t\tcookie = NULL;\n\t\twhile ((uqn = avl_destroy_nodes(&cache->uqc_project_deltas,\n\t\t    &cookie)) != NULL) {\n\t\t\tmutex_enter(&os->os_userused_lock);\n\t\t\tVERIFY0(zap_increment(os, DMU_PROJECTUSED_OBJECT,\n\t\t\t    uqn->uqn_id, uqn->uqn_delta, tx));\n\t\t\tmutex_exit(&os->os_userused_lock);\n\t\t\tkmem_free(uqn, sizeof (*uqn));\n\t\t}\n\t\tavl_destroy(&cache->uqc_project_deltas);\n\t}\n}\n\nstatic void\nuserquota_update_cache(avl_tree_t *avl, const char *id, int64_t delta)\n{\n\tuserquota_node_t *uqn;\n\tavl_index_t idx;\n\n\tASSERT(strlen(id) < sizeof (uqn->uqn_id));\n\t \n\tuqn = avl_find(avl, (const void *)id, &idx);\n\tif (uqn == NULL) {\n\t\tuqn = kmem_zalloc(sizeof (*uqn), KM_SLEEP);\n\t\tstrlcpy(uqn->uqn_id, id, sizeof (uqn->uqn_id));\n\t\tavl_insert(avl, uqn, idx);\n\t}\n\tuqn->uqn_delta += delta;\n}\n\nstatic void\ndo_userquota_update(objset_t *os, userquota_cache_t *cache, uint64_t used,\n    uint64_t flags, uint64_t user, uint64_t group, uint64_t project,\n    boolean_t subtract)\n{\n\tif (flags & DNODE_FLAG_USERUSED_ACCOUNTED) {\n\t\tint64_t delta = DNODE_MIN_SIZE + used;\n\t\tchar name[20];\n\n\t\tif (subtract)\n\t\t\tdelta = -delta;\n\n\t\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)user);\n\t\tuserquota_update_cache(&cache->uqc_user_deltas, name, delta);\n\n\t\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)group);\n\t\tuserquota_update_cache(&cache->uqc_group_deltas, name, delta);\n\n\t\tif (dmu_objset_projectquota_enabled(os)) {\n\t\t\t(void) snprintf(name, sizeof (name), \"%llx\",\n\t\t\t    (longlong_t)project);\n\t\t\tuserquota_update_cache(&cache->uqc_project_deltas,\n\t\t\t    name, delta);\n\t\t}\n\t}\n}\n\nstatic void\ndo_userobjquota_update(objset_t *os, userquota_cache_t *cache, uint64_t flags,\n    uint64_t user, uint64_t group, uint64_t project, boolean_t subtract)\n{\n\tif (flags & DNODE_FLAG_USEROBJUSED_ACCOUNTED) {\n\t\tchar name[20 + DMU_OBJACCT_PREFIX_LEN];\n\t\tint delta = subtract ? -1 : 1;\n\n\t\t(void) snprintf(name, sizeof (name), DMU_OBJACCT_PREFIX \"%llx\",\n\t\t    (longlong_t)user);\n\t\tuserquota_update_cache(&cache->uqc_user_deltas, name, delta);\n\n\t\t(void) snprintf(name, sizeof (name), DMU_OBJACCT_PREFIX \"%llx\",\n\t\t    (longlong_t)group);\n\t\tuserquota_update_cache(&cache->uqc_group_deltas, name, delta);\n\n\t\tif (dmu_objset_projectquota_enabled(os)) {\n\t\t\t(void) snprintf(name, sizeof (name),\n\t\t\t    DMU_OBJACCT_PREFIX \"%llx\", (longlong_t)project);\n\t\t\tuserquota_update_cache(&cache->uqc_project_deltas,\n\t\t\t    name, delta);\n\t\t}\n\t}\n}\n\ntypedef struct userquota_updates_arg {\n\tobjset_t *uua_os;\n\tint uua_sublist_idx;\n\tdmu_tx_t *uua_tx;\n} userquota_updates_arg_t;\n\nstatic void\nuserquota_updates_task(void *arg)\n{\n\tuserquota_updates_arg_t *uua = arg;\n\tobjset_t *os = uua->uua_os;\n\tdmu_tx_t *tx = uua->uua_tx;\n\tdnode_t *dn;\n\tuserquota_cache_t cache = { { 0 } };\n\n\tmultilist_sublist_t *list =\n\t    multilist_sublist_lock(&os->os_synced_dnodes, uua->uua_sublist_idx);\n\n\tASSERT(multilist_sublist_head(list) == NULL ||\n\t    dmu_objset_userused_enabled(os));\n\tavl_create(&cache.uqc_user_deltas, userquota_compare,\n\t    sizeof (userquota_node_t), offsetof(userquota_node_t, uqn_node));\n\tavl_create(&cache.uqc_group_deltas, userquota_compare,\n\t    sizeof (userquota_node_t), offsetof(userquota_node_t, uqn_node));\n\tif (dmu_objset_projectquota_enabled(os))\n\t\tavl_create(&cache.uqc_project_deltas, userquota_compare,\n\t\t    sizeof (userquota_node_t), offsetof(userquota_node_t,\n\t\t    uqn_node));\n\n\twhile ((dn = multilist_sublist_head(list)) != NULL) {\n\t\tint flags;\n\t\tASSERT(!DMU_OBJECT_IS_SPECIAL(dn->dn_object));\n\t\tASSERT(dn->dn_phys->dn_type == DMU_OT_NONE ||\n\t\t    dn->dn_phys->dn_flags &\n\t\t    DNODE_FLAG_USERUSED_ACCOUNTED);\n\n\t\tflags = dn->dn_id_flags;\n\t\tASSERT(flags);\n\t\tif (flags & DN_ID_OLD_EXIST)  {\n\t\t\tdo_userquota_update(os, &cache, dn->dn_oldused,\n\t\t\t    dn->dn_oldflags, dn->dn_olduid, dn->dn_oldgid,\n\t\t\t    dn->dn_oldprojid, B_TRUE);\n\t\t\tdo_userobjquota_update(os, &cache, dn->dn_oldflags,\n\t\t\t    dn->dn_olduid, dn->dn_oldgid,\n\t\t\t    dn->dn_oldprojid, B_TRUE);\n\t\t}\n\t\tif (flags & DN_ID_NEW_EXIST) {\n\t\t\tdo_userquota_update(os, &cache,\n\t\t\t    DN_USED_BYTES(dn->dn_phys), dn->dn_phys->dn_flags,\n\t\t\t    dn->dn_newuid, dn->dn_newgid,\n\t\t\t    dn->dn_newprojid, B_FALSE);\n\t\t\tdo_userobjquota_update(os, &cache,\n\t\t\t    dn->dn_phys->dn_flags, dn->dn_newuid, dn->dn_newgid,\n\t\t\t    dn->dn_newprojid, B_FALSE);\n\t\t}\n\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tdn->dn_oldused = 0;\n\t\tdn->dn_oldflags = 0;\n\t\tif (dn->dn_id_flags & DN_ID_NEW_EXIST) {\n\t\t\tdn->dn_olduid = dn->dn_newuid;\n\t\t\tdn->dn_oldgid = dn->dn_newgid;\n\t\t\tdn->dn_oldprojid = dn->dn_newprojid;\n\t\t\tdn->dn_id_flags |= DN_ID_OLD_EXIST;\n\t\t\tif (dn->dn_bonuslen == 0)\n\t\t\t\tdn->dn_id_flags |= DN_ID_CHKED_SPILL;\n\t\t\telse\n\t\t\t\tdn->dn_id_flags |= DN_ID_CHKED_BONUS;\n\t\t}\n\t\tdn->dn_id_flags &= ~(DN_ID_NEW_EXIST);\n\t\tmutex_exit(&dn->dn_mtx);\n\n\t\tmultilist_sublist_remove(list, dn);\n\t\tdnode_rele(dn, &os->os_synced_dnodes);\n\t}\n\tdo_userquota_cacheflush(os, &cache, tx);\n\tmultilist_sublist_unlock(list);\n\tkmem_free(uua, sizeof (*uua));\n}\n\n \nstatic void\ndnode_rele_task(void *arg)\n{\n\tuserquota_updates_arg_t *uua = arg;\n\tobjset_t *os = uua->uua_os;\n\n\tmultilist_sublist_t *list =\n\t    multilist_sublist_lock(&os->os_synced_dnodes, uua->uua_sublist_idx);\n\n\tdnode_t *dn;\n\twhile ((dn = multilist_sublist_head(list)) != NULL) {\n\t\tmultilist_sublist_remove(list, dn);\n\t\tdnode_rele(dn, &os->os_synced_dnodes);\n\t}\n\tmultilist_sublist_unlock(list);\n\tkmem_free(uua, sizeof (*uua));\n}\n\n \nstatic boolean_t\ndmu_objset_do_userquota_updates_prep(objset_t *os, dmu_tx_t *tx)\n{\n\tif (!dmu_objset_userused_enabled(os))\n\t\treturn (B_FALSE);\n\n\t \n\tif (os->os_encrypted && dmu_objset_is_receiving(os))\n\t\treturn (B_FALSE);\n\n\tif (tx->tx_txg <= os->os_spa->spa_claim_max_txg)\n\t\treturn (B_FALSE);\n\n\t \n\tif (DMU_USERUSED_DNODE(os)->dn_type == DMU_OT_NONE) {\n\t\tVERIFY0(zap_create_claim(os,\n\t\t    DMU_USERUSED_OBJECT,\n\t\t    DMU_OT_USERGROUP_USED, DMU_OT_NONE, 0, tx));\n\t\tVERIFY0(zap_create_claim(os,\n\t\t    DMU_GROUPUSED_OBJECT,\n\t\t    DMU_OT_USERGROUP_USED, DMU_OT_NONE, 0, tx));\n\t}\n\n\tif (dmu_objset_projectquota_enabled(os) &&\n\t    DMU_PROJECTUSED_DNODE(os)->dn_type == DMU_OT_NONE) {\n\t\tVERIFY0(zap_create_claim(os, DMU_PROJECTUSED_OBJECT,\n\t\t    DMU_OT_USERGROUP_USED, DMU_OT_NONE, 0, tx));\n\t}\n\treturn (B_TRUE);\n}\n\n \nvoid\ndmu_objset_sync_done(objset_t *os, dmu_tx_t *tx)\n{\n\tboolean_t need_userquota = dmu_objset_do_userquota_updates_prep(os, tx);\n\n\tint num_sublists = multilist_get_num_sublists(&os->os_synced_dnodes);\n\tfor (int i = 0; i < num_sublists; i++) {\n\t\tuserquota_updates_arg_t *uua =\n\t\t    kmem_alloc(sizeof (*uua), KM_SLEEP);\n\t\tuua->uua_os = os;\n\t\tuua->uua_sublist_idx = i;\n\t\tuua->uua_tx = tx;\n\n\t\t \n\t\t(void) taskq_dispatch(dmu_objset_pool(os)->dp_sync_taskq,\n\t\t    need_userquota ? userquota_updates_task : dnode_rele_task,\n\t\t    uua, 0);\n\t\t \n\t}\n}\n\n\n \nstatic void *\ndmu_objset_userquota_find_data(dmu_buf_impl_t *db, dmu_tx_t *tx)\n{\n\tdbuf_dirty_record_t *dr;\n\tvoid *data;\n\n\tif (db->db_dirtycnt == 0)\n\t\treturn (db->db.db_data);   \n\n\tdr = dbuf_find_dirty_eq(db, tx->tx_txg);\n\n\tif (dr == NULL) {\n\t\tdata = NULL;\n\t} else {\n\t\tif (dr->dr_dnode->dn_bonuslen == 0 &&\n\t\t    dr->dr_dbuf->db_blkid == DMU_SPILL_BLKID)\n\t\t\tdata = dr->dt.dl.dr_data->b_data;\n\t\telse\n\t\t\tdata = dr->dt.dl.dr_data;\n\t}\n\n\treturn (data);\n}\n\nvoid\ndmu_objset_userquota_get_ids(dnode_t *dn, boolean_t before, dmu_tx_t *tx)\n{\n\tobjset_t *os = dn->dn_objset;\n\tvoid *data = NULL;\n\tdmu_buf_impl_t *db = NULL;\n\tint flags = dn->dn_id_flags;\n\tint error;\n\tboolean_t have_spill = B_FALSE;\n\n\tif (!dmu_objset_userused_enabled(dn->dn_objset))\n\t\treturn;\n\n\t \n\tif (os->os_encrypted && dmu_objset_is_receiving(os))\n\t\treturn;\n\n\tif (before && (flags & (DN_ID_CHKED_BONUS|DN_ID_OLD_EXIST|\n\t    DN_ID_CHKED_SPILL)))\n\t\treturn;\n\n\tif (before && dn->dn_bonuslen != 0)\n\t\tdata = DN_BONUS(dn->dn_phys);\n\telse if (!before && dn->dn_bonuslen != 0) {\n\t\tif (dn->dn_bonus) {\n\t\t\tdb = dn->dn_bonus;\n\t\t\tmutex_enter(&db->db_mtx);\n\t\t\tdata = dmu_objset_userquota_find_data(db, tx);\n\t\t} else {\n\t\t\tdata = DN_BONUS(dn->dn_phys);\n\t\t}\n\t} else if (dn->dn_bonuslen == 0 && dn->dn_bonustype == DMU_OT_SA) {\n\t\t\tint rf = 0;\n\n\t\t\tif (RW_WRITE_HELD(&dn->dn_struct_rwlock))\n\t\t\t\trf |= DB_RF_HAVESTRUCT;\n\t\t\terror = dmu_spill_hold_by_dnode(dn,\n\t\t\t    rf | DB_RF_MUST_SUCCEED,\n\t\t\t    FTAG, (dmu_buf_t **)&db);\n\t\t\tASSERT(error == 0);\n\t\t\tmutex_enter(&db->db_mtx);\n\t\t\tdata = (before) ? db->db.db_data :\n\t\t\t    dmu_objset_userquota_find_data(db, tx);\n\t\t\thave_spill = B_TRUE;\n\t} else {\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tdn->dn_id_flags |= DN_ID_CHKED_BONUS;\n\t\tmutex_exit(&dn->dn_mtx);\n\t\treturn;\n\t}\n\n\t \n\tzfs_file_info_t zfi;\n\terror = file_cbs[os->os_phys->os_type](dn->dn_bonustype, data, &zfi);\n\n\tif (before) {\n\t\tASSERT(data);\n\t\tdn->dn_olduid = zfi.zfi_user;\n\t\tdn->dn_oldgid = zfi.zfi_group;\n\t\tdn->dn_oldprojid = zfi.zfi_project;\n\t} else if (data) {\n\t\tdn->dn_newuid = zfi.zfi_user;\n\t\tdn->dn_newgid = zfi.zfi_group;\n\t\tdn->dn_newprojid = zfi.zfi_project;\n\t}\n\n\t \n\tif (!before && data == NULL && error == EEXIST) {\n\t\tif (flags & DN_ID_OLD_EXIST) {\n\t\t\tdn->dn_newuid = dn->dn_olduid;\n\t\t\tdn->dn_newgid = dn->dn_oldgid;\n\t\t\tdn->dn_newprojid = dn->dn_oldprojid;\n\t\t} else {\n\t\t\tdn->dn_newuid = 0;\n\t\t\tdn->dn_newgid = 0;\n\t\t\tdn->dn_newprojid = ZFS_DEFAULT_PROJID;\n\t\t}\n\t\terror = 0;\n\t}\n\n\tif (db)\n\t\tmutex_exit(&db->db_mtx);\n\n\tmutex_enter(&dn->dn_mtx);\n\tif (error == 0 && before)\n\t\tdn->dn_id_flags |= DN_ID_OLD_EXIST;\n\tif (error == 0 && !before)\n\t\tdn->dn_id_flags |= DN_ID_NEW_EXIST;\n\n\tif (have_spill) {\n\t\tdn->dn_id_flags |= DN_ID_CHKED_SPILL;\n\t} else {\n\t\tdn->dn_id_flags |= DN_ID_CHKED_BONUS;\n\t}\n\tmutex_exit(&dn->dn_mtx);\n\tif (have_spill)\n\t\tdmu_buf_rele((dmu_buf_t *)db, FTAG);\n}\n\nboolean_t\ndmu_objset_userspace_present(objset_t *os)\n{\n\treturn (os->os_phys->os_flags &\n\t    OBJSET_FLAG_USERACCOUNTING_COMPLETE);\n}\n\nboolean_t\ndmu_objset_userobjspace_present(objset_t *os)\n{\n\treturn (os->os_phys->os_flags &\n\t    OBJSET_FLAG_USEROBJACCOUNTING_COMPLETE);\n}\n\nboolean_t\ndmu_objset_projectquota_present(objset_t *os)\n{\n\treturn (os->os_phys->os_flags &\n\t    OBJSET_FLAG_PROJECTQUOTA_COMPLETE);\n}\n\nstatic int\ndmu_objset_space_upgrade(objset_t *os)\n{\n\tuint64_t obj;\n\tint err = 0;\n\n\t \n\n\tfor (obj = 0; err == 0; err = dmu_object_next(os, &obj, FALSE, 0)) {\n\t\tdmu_tx_t *tx;\n\t\tdmu_buf_t *db;\n\t\tint objerr;\n\n\t\tmutex_enter(&os->os_upgrade_lock);\n\t\tif (os->os_upgrade_exit)\n\t\t\terr = SET_ERROR(EINTR);\n\t\tmutex_exit(&os->os_upgrade_lock);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tif (issig(JUSTLOOKING) && issig(FORREAL))\n\t\t\treturn (SET_ERROR(EINTR));\n\n\t\tobjerr = dmu_bonus_hold(os, obj, FTAG, &db);\n\t\tif (objerr != 0)\n\t\t\tcontinue;\n\t\ttx = dmu_tx_create(os);\n\t\tdmu_tx_hold_bonus(tx, obj);\n\t\tobjerr = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (objerr != 0) {\n\t\t\tdmu_buf_rele(db, FTAG);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tcontinue;\n\t\t}\n\t\tdmu_buf_will_dirty(db, tx);\n\t\tdmu_buf_rele(db, FTAG);\n\t\tdmu_tx_commit(tx);\n\t}\n\treturn (0);\n}\n\nstatic int\ndmu_objset_userspace_upgrade_cb(objset_t *os)\n{\n\tint err = 0;\n\n\tif (dmu_objset_userspace_present(os))\n\t\treturn (0);\n\tif (dmu_objset_is_snapshot(os))\n\t\treturn (SET_ERROR(EINVAL));\n\tif (!dmu_objset_userused_enabled(os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\terr = dmu_objset_space_upgrade(os);\n\tif (err)\n\t\treturn (err);\n\n\tos->os_flags |= OBJSET_FLAG_USERACCOUNTING_COMPLETE;\n\ttxg_wait_synced(dmu_objset_pool(os), 0);\n\treturn (0);\n}\n\nvoid\ndmu_objset_userspace_upgrade(objset_t *os)\n{\n\tdmu_objset_upgrade(os, dmu_objset_userspace_upgrade_cb);\n}\n\nstatic int\ndmu_objset_id_quota_upgrade_cb(objset_t *os)\n{\n\tint err = 0;\n\n\tif (dmu_objset_userobjspace_present(os) &&\n\t    dmu_objset_projectquota_present(os))\n\t\treturn (0);\n\tif (dmu_objset_is_snapshot(os))\n\t\treturn (SET_ERROR(EINVAL));\n\tif (!dmu_objset_userused_enabled(os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif (!dmu_objset_projectquota_enabled(os) &&\n\t    dmu_objset_userobjspace_present(os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (dmu_objset_userobjused_enabled(os))\n\t\tdmu_objset_ds(os)->ds_feature_activation[\n\t\t    SPA_FEATURE_USEROBJ_ACCOUNTING] = (void *)B_TRUE;\n\tif (dmu_objset_projectquota_enabled(os))\n\t\tdmu_objset_ds(os)->ds_feature_activation[\n\t\t    SPA_FEATURE_PROJECT_QUOTA] = (void *)B_TRUE;\n\n\terr = dmu_objset_space_upgrade(os);\n\tif (err)\n\t\treturn (err);\n\n\tos->os_flags |= OBJSET_FLAG_USERACCOUNTING_COMPLETE;\n\tif (dmu_objset_userobjused_enabled(os))\n\t\tos->os_flags |= OBJSET_FLAG_USEROBJACCOUNTING_COMPLETE;\n\tif (dmu_objset_projectquota_enabled(os))\n\t\tos->os_flags |= OBJSET_FLAG_PROJECTQUOTA_COMPLETE;\n\n\ttxg_wait_synced(dmu_objset_pool(os), 0);\n\treturn (0);\n}\n\nvoid\ndmu_objset_id_quota_upgrade(objset_t *os)\n{\n\tdmu_objset_upgrade(os, dmu_objset_id_quota_upgrade_cb);\n}\n\nboolean_t\ndmu_objset_userobjspace_upgradable(objset_t *os)\n{\n\treturn (dmu_objset_type(os) == DMU_OST_ZFS &&\n\t    !dmu_objset_is_snapshot(os) &&\n\t    dmu_objset_userobjused_enabled(os) &&\n\t    !dmu_objset_userobjspace_present(os) &&\n\t    spa_writeable(dmu_objset_spa(os)));\n}\n\nboolean_t\ndmu_objset_projectquota_upgradable(objset_t *os)\n{\n\treturn (dmu_objset_type(os) == DMU_OST_ZFS &&\n\t    !dmu_objset_is_snapshot(os) &&\n\t    dmu_objset_projectquota_enabled(os) &&\n\t    !dmu_objset_projectquota_present(os) &&\n\t    spa_writeable(dmu_objset_spa(os)));\n}\n\nvoid\ndmu_objset_space(objset_t *os, uint64_t *refdbytesp, uint64_t *availbytesp,\n    uint64_t *usedobjsp, uint64_t *availobjsp)\n{\n\tdsl_dataset_space(os->os_dsl_dataset, refdbytesp, availbytesp,\n\t    usedobjsp, availobjsp);\n}\n\nuint64_t\ndmu_objset_fsid_guid(objset_t *os)\n{\n\treturn (dsl_dataset_fsid_guid(os->os_dsl_dataset));\n}\n\nvoid\ndmu_objset_fast_stat(objset_t *os, dmu_objset_stats_t *stat)\n{\n\tstat->dds_type = os->os_phys->os_type;\n\tif (os->os_dsl_dataset)\n\t\tdsl_dataset_fast_stat(os->os_dsl_dataset, stat);\n}\n\nvoid\ndmu_objset_stats(objset_t *os, nvlist_t *nv)\n{\n\tASSERT(os->os_dsl_dataset ||\n\t    os->os_phys->os_type == DMU_OST_META);\n\n\tif (os->os_dsl_dataset != NULL)\n\t\tdsl_dataset_stats(os->os_dsl_dataset, nv);\n\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_TYPE,\n\t    os->os_phys->os_type);\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USERACCOUNTING,\n\t    dmu_objset_userspace_present(os));\n}\n\nint\ndmu_objset_is_snapshot(objset_t *os)\n{\n\tif (os->os_dsl_dataset != NULL)\n\t\treturn (os->os_dsl_dataset->ds_is_snapshot);\n\telse\n\t\treturn (B_FALSE);\n}\n\nint\ndmu_snapshot_realname(objset_t *os, const char *name, char *real, int maxlen,\n    boolean_t *conflict)\n{\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\tuint64_t ignored;\n\n\tif (dsl_dataset_phys(ds)->ds_snapnames_zapobj == 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (zap_lookup_norm(ds->ds_dir->dd_pool->dp_meta_objset,\n\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj, name, 8, 1, &ignored,\n\t    MT_NORMALIZE, real, maxlen, conflict));\n}\n\nint\ndmu_snapshot_list_next(objset_t *os, int namelen, char *name,\n    uint64_t *idp, uint64_t *offp, boolean_t *case_conflict)\n{\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\tzap_cursor_t cursor;\n\tzap_attribute_t attr;\n\n\tASSERT(dsl_pool_config_held(dmu_objset_pool(os)));\n\n\tif (dsl_dataset_phys(ds)->ds_snapnames_zapobj == 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tzap_cursor_init_serialized(&cursor,\n\t    ds->ds_dir->dd_pool->dp_meta_objset,\n\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj, *offp);\n\n\tif (zap_cursor_retrieve(&cursor, &attr) != 0) {\n\t\tzap_cursor_fini(&cursor);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tif (strlen(attr.za_name) + 1 > namelen) {\n\t\tzap_cursor_fini(&cursor);\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t}\n\n\t(void) strlcpy(name, attr.za_name, namelen);\n\tif (idp)\n\t\t*idp = attr.za_first_integer;\n\tif (case_conflict)\n\t\t*case_conflict = attr.za_normalization_conflict;\n\tzap_cursor_advance(&cursor);\n\t*offp = zap_cursor_serialize(&cursor);\n\tzap_cursor_fini(&cursor);\n\n\treturn (0);\n}\n\nint\ndmu_snapshot_lookup(objset_t *os, const char *name, uint64_t *value)\n{\n\treturn (dsl_dataset_snap_lookup(os->os_dsl_dataset, name, value));\n}\n\nint\ndmu_dir_list_next(objset_t *os, int namelen, char *name,\n    uint64_t *idp, uint64_t *offp)\n{\n\tdsl_dir_t *dd = os->os_dsl_dataset->ds_dir;\n\tzap_cursor_t cursor;\n\tzap_attribute_t attr;\n\n\t \n\tif (os->os_dsl_dataset->ds_object !=\n\t    dsl_dir_phys(dd)->dd_head_dataset_obj)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tzap_cursor_init_serialized(&cursor,\n\t    dd->dd_pool->dp_meta_objset,\n\t    dsl_dir_phys(dd)->dd_child_dir_zapobj, *offp);\n\n\tif (zap_cursor_retrieve(&cursor, &attr) != 0) {\n\t\tzap_cursor_fini(&cursor);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tif (strlen(attr.za_name) + 1 > namelen) {\n\t\tzap_cursor_fini(&cursor);\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t}\n\n\t(void) strlcpy(name, attr.za_name, namelen);\n\tif (idp)\n\t\t*idp = attr.za_first_integer;\n\tzap_cursor_advance(&cursor);\n\t*offp = zap_cursor_serialize(&cursor);\n\tzap_cursor_fini(&cursor);\n\n\treturn (0);\n}\n\ntypedef struct dmu_objset_find_ctx {\n\ttaskq_t\t\t*dc_tq;\n\tdsl_pool_t\t*dc_dp;\n\tuint64_t\tdc_ddobj;\n\tchar\t\t*dc_ddname;  \n\tint\t\t(*dc_func)(dsl_pool_t *, dsl_dataset_t *, void *);\n\tvoid\t\t*dc_arg;\n\tint\t\tdc_flags;\n\tkmutex_t\t*dc_error_lock;\n\tint\t\t*dc_error;\n} dmu_objset_find_ctx_t;\n\nstatic void\ndmu_objset_find_dp_impl(dmu_objset_find_ctx_t *dcp)\n{\n\tdsl_pool_t *dp = dcp->dc_dp;\n\tdsl_dir_t *dd;\n\tdsl_dataset_t *ds;\n\tzap_cursor_t zc;\n\tzap_attribute_t *attr;\n\tuint64_t thisobj;\n\tint err = 0;\n\n\t \n\tif (*dcp->dc_error != 0)\n\t\tgoto out;\n\n\t \n\terr = dsl_dir_hold_obj(dp, dcp->dc_ddobj, dcp->dc_ddname, FTAG, &dd);\n\tif (err != 0)\n\t\tgoto out;\n\n\t \n\tif (dd->dd_myname[0] == '$') {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\tgoto out;\n\t}\n\n\tthisobj = dsl_dir_phys(dd)->dd_head_dataset_obj;\n\tattr = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\t \n\tif (dcp->dc_flags & DS_FIND_CHILDREN) {\n\t\tfor (zap_cursor_init(&zc, dp->dp_meta_objset,\n\t\t    dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\t\t    zap_cursor_retrieve(&zc, attr) == 0;\n\t\t    (void) zap_cursor_advance(&zc)) {\n\t\t\tASSERT3U(attr->za_integer_length, ==,\n\t\t\t    sizeof (uint64_t));\n\t\t\tASSERT3U(attr->za_num_integers, ==, 1);\n\n\t\t\tdmu_objset_find_ctx_t *child_dcp =\n\t\t\t    kmem_alloc(sizeof (*child_dcp), KM_SLEEP);\n\t\t\t*child_dcp = *dcp;\n\t\t\tchild_dcp->dc_ddobj = attr->za_first_integer;\n\t\t\tchild_dcp->dc_ddname = spa_strdup(attr->za_name);\n\t\t\tif (dcp->dc_tq != NULL)\n\t\t\t\t(void) taskq_dispatch(dcp->dc_tq,\n\t\t\t\t    dmu_objset_find_dp_cb, child_dcp, TQ_SLEEP);\n\t\t\telse\n\t\t\t\tdmu_objset_find_dp_impl(child_dcp);\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\t}\n\n\t \n\tif (dcp->dc_flags & DS_FIND_SNAPSHOTS) {\n\t\tdsl_dataset_t *ds;\n\t\terr = dsl_dataset_hold_obj(dp, thisobj, FTAG, &ds);\n\n\t\tif (err == 0) {\n\t\t\tuint64_t snapobj;\n\n\t\t\tsnapobj = dsl_dataset_phys(ds)->ds_snapnames_zapobj;\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\n\t\t\tfor (zap_cursor_init(&zc, dp->dp_meta_objset, snapobj);\n\t\t\t    zap_cursor_retrieve(&zc, attr) == 0;\n\t\t\t    (void) zap_cursor_advance(&zc)) {\n\t\t\t\tASSERT3U(attr->za_integer_length, ==,\n\t\t\t\t    sizeof (uint64_t));\n\t\t\t\tASSERT3U(attr->za_num_integers, ==, 1);\n\n\t\t\t\terr = dsl_dataset_hold_obj(dp,\n\t\t\t\t    attr->za_first_integer, FTAG, &ds);\n\t\t\t\tif (err != 0)\n\t\t\t\t\tbreak;\n\t\t\t\terr = dcp->dc_func(dp, ds, dcp->dc_arg);\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\tif (err != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzap_cursor_fini(&zc);\n\t\t}\n\t}\n\n\tkmem_free(attr, sizeof (zap_attribute_t));\n\n\tif (err != 0) {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\tgoto out;\n\t}\n\n\t \n\terr = dsl_dataset_hold_obj(dp, thisobj, FTAG, &ds);\n\n\t \n\tdsl_dir_rele(dd, FTAG);\n\tif (err != 0)\n\t\tgoto out;\n\terr = dcp->dc_func(dp, ds, dcp->dc_arg);\n\tdsl_dataset_rele(ds, FTAG);\n\nout:\n\tif (err != 0) {\n\t\tmutex_enter(dcp->dc_error_lock);\n\t\t \n\t\tif (*dcp->dc_error == 0)\n\t\t\t*dcp->dc_error = err;\n\t\tmutex_exit(dcp->dc_error_lock);\n\t}\n\n\tif (dcp->dc_ddname != NULL)\n\t\tspa_strfree(dcp->dc_ddname);\n\tkmem_free(dcp, sizeof (*dcp));\n}\n\nstatic void\ndmu_objset_find_dp_cb(void *arg)\n{\n\tdmu_objset_find_ctx_t *dcp = arg;\n\tdsl_pool_t *dp = dcp->dc_dp;\n\n\t \n\tdsl_pool_config_enter_prio(dp, FTAG);\n\n\tdmu_objset_find_dp_impl(dcp);\n\n\tdsl_pool_config_exit(dp, FTAG);\n}\n\n \nint\ndmu_objset_find_dp(dsl_pool_t *dp, uint64_t ddobj,\n    int func(dsl_pool_t *, dsl_dataset_t *, void *), void *arg, int flags)\n{\n\tint error = 0;\n\ttaskq_t *tq = NULL;\n\tint ntasks;\n\tdmu_objset_find_ctx_t *dcp;\n\tkmutex_t err_lock;\n\n\tmutex_init(&err_lock, NULL, MUTEX_DEFAULT, NULL);\n\tdcp = kmem_alloc(sizeof (*dcp), KM_SLEEP);\n\tdcp->dc_tq = NULL;\n\tdcp->dc_dp = dp;\n\tdcp->dc_ddobj = ddobj;\n\tdcp->dc_ddname = NULL;\n\tdcp->dc_func = func;\n\tdcp->dc_arg = arg;\n\tdcp->dc_flags = flags;\n\tdcp->dc_error_lock = &err_lock;\n\tdcp->dc_error = &error;\n\n\tif ((flags & DS_FIND_SERIALIZE) || dsl_pool_config_held_writer(dp)) {\n\t\t \n\t\tdmu_objset_find_dp_impl(dcp);\n\t\tmutex_destroy(&err_lock);\n\n\t\treturn (error);\n\t}\n\n\tntasks = dmu_find_threads;\n\tif (ntasks == 0)\n\t\tntasks = vdev_count_leaves(dp->dp_spa) * 4;\n\ttq = taskq_create(\"dmu_objset_find\", ntasks, maxclsyspri, ntasks,\n\t    INT_MAX, 0);\n\tif (tq == NULL) {\n\t\tkmem_free(dcp, sizeof (*dcp));\n\t\tmutex_destroy(&err_lock);\n\n\t\treturn (SET_ERROR(ENOMEM));\n\t}\n\tdcp->dc_tq = tq;\n\n\t \n\t(void) taskq_dispatch(tq, dmu_objset_find_dp_cb, dcp, TQ_SLEEP);\n\n\t \n\ttaskq_wait(tq);\n\ttaskq_destroy(tq);\n\tmutex_destroy(&err_lock);\n\n\treturn (error);\n}\n\n \nstatic int\ndmu_objset_find_impl(spa_t *spa, const char *name,\n    int func(const char *, void *), void *arg, int flags)\n{\n\tdsl_dir_t *dd;\n\tdsl_pool_t *dp = spa_get_dsl(spa);\n\tdsl_dataset_t *ds;\n\tzap_cursor_t zc;\n\tzap_attribute_t *attr;\n\tchar *child;\n\tuint64_t thisobj;\n\tint err;\n\n\tdsl_pool_config_enter(dp, FTAG);\n\n\terr = dsl_dir_hold(dp, name, FTAG, &dd, NULL);\n\tif (err != 0) {\n\t\tdsl_pool_config_exit(dp, FTAG);\n\t\treturn (err);\n\t}\n\n\t \n\tif (dd->dd_myname[0] == '$') {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\tdsl_pool_config_exit(dp, FTAG);\n\t\treturn (0);\n\t}\n\n\tthisobj = dsl_dir_phys(dd)->dd_head_dataset_obj;\n\tattr = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\t \n\tif (flags & DS_FIND_CHILDREN) {\n\t\tfor (zap_cursor_init(&zc, dp->dp_meta_objset,\n\t\t    dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\t\t    zap_cursor_retrieve(&zc, attr) == 0;\n\t\t    (void) zap_cursor_advance(&zc)) {\n\t\t\tASSERT3U(attr->za_integer_length, ==,\n\t\t\t    sizeof (uint64_t));\n\t\t\tASSERT3U(attr->za_num_integers, ==, 1);\n\n\t\t\tchild = kmem_asprintf(\"%s/%s\", name, attr->za_name);\n\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\terr = dmu_objset_find_impl(spa, child,\n\t\t\t    func, arg, flags);\n\t\t\tdsl_pool_config_enter(dp, FTAG);\n\t\t\tkmem_strfree(child);\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\n\t\tif (err != 0) {\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\tkmem_free(attr, sizeof (zap_attribute_t));\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\t \n\tif (flags & DS_FIND_SNAPSHOTS) {\n\t\terr = dsl_dataset_hold_obj(dp, thisobj, FTAG, &ds);\n\n\t\tif (err == 0) {\n\t\t\tuint64_t snapobj;\n\n\t\t\tsnapobj = dsl_dataset_phys(ds)->ds_snapnames_zapobj;\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\n\t\t\tfor (zap_cursor_init(&zc, dp->dp_meta_objset, snapobj);\n\t\t\t    zap_cursor_retrieve(&zc, attr) == 0;\n\t\t\t    (void) zap_cursor_advance(&zc)) {\n\t\t\t\tASSERT3U(attr->za_integer_length, ==,\n\t\t\t\t    sizeof (uint64_t));\n\t\t\t\tASSERT3U(attr->za_num_integers, ==, 1);\n\n\t\t\t\tchild = kmem_asprintf(\"%s@%s\",\n\t\t\t\t    name, attr->za_name);\n\t\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\t\terr = func(child, arg);\n\t\t\t\tdsl_pool_config_enter(dp, FTAG);\n\t\t\t\tkmem_strfree(child);\n\t\t\t\tif (err != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzap_cursor_fini(&zc);\n\t\t}\n\t}\n\n\tdsl_dir_rele(dd, FTAG);\n\tkmem_free(attr, sizeof (zap_attribute_t));\n\tdsl_pool_config_exit(dp, FTAG);\n\n\tif (err != 0)\n\t\treturn (err);\n\n\t \n\treturn (func(name, arg));\n}\n\n \nint\ndmu_objset_find(const char *name, int func(const char *, void *), void *arg,\n    int flags)\n{\n\tspa_t *spa;\n\tint error;\n\n\terror = spa_open(name, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\terror = dmu_objset_find_impl(spa, name, func, arg, flags);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nboolean_t\ndmu_objset_incompatible_encryption_version(objset_t *os)\n{\n\treturn (dsl_dir_incompatible_encryption_version(\n\t    os->os_dsl_dataset->ds_dir));\n}\n\nvoid\ndmu_objset_set_user(objset_t *os, void *user_ptr)\n{\n\tASSERT(MUTEX_HELD(&os->os_user_ptr_lock));\n\tos->os_user_ptr = user_ptr;\n}\n\nvoid *\ndmu_objset_get_user(objset_t *os)\n{\n\tASSERT(MUTEX_HELD(&os->os_user_ptr_lock));\n\treturn (os->os_user_ptr);\n}\n\n \nint\ndmu_fsname(const char *snapname, char *buf)\n{\n\tchar *atp = strchr(snapname, '@');\n\tif (atp == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (atp - snapname >= ZFS_MAX_DATASET_NAME_LEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t(void) strlcpy(buf, snapname, atp - snapname + 1);\n\treturn (0);\n}\n\n \nvoid\ndmu_objset_willuse_space(objset_t *os, int64_t space, dmu_tx_t *tx)\n{\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\tint64_t aspace = spa_get_worst_case_asize(os->os_spa, space);\n\n\tif (ds != NULL) {\n\t\tdsl_dir_willuse_space(ds->ds_dir, aspace, tx);\n\t}\n\n\tdsl_pool_dirty_space(dmu_tx_pool(tx), space, tx);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dmu_objset_zil);\nEXPORT_SYMBOL(dmu_objset_pool);\nEXPORT_SYMBOL(dmu_objset_ds);\nEXPORT_SYMBOL(dmu_objset_type);\nEXPORT_SYMBOL(dmu_objset_name);\nEXPORT_SYMBOL(dmu_objset_hold);\nEXPORT_SYMBOL(dmu_objset_hold_flags);\nEXPORT_SYMBOL(dmu_objset_own);\nEXPORT_SYMBOL(dmu_objset_rele);\nEXPORT_SYMBOL(dmu_objset_rele_flags);\nEXPORT_SYMBOL(dmu_objset_disown);\nEXPORT_SYMBOL(dmu_objset_from_ds);\nEXPORT_SYMBOL(dmu_objset_create);\nEXPORT_SYMBOL(dmu_objset_clone);\nEXPORT_SYMBOL(dmu_objset_stats);\nEXPORT_SYMBOL(dmu_objset_fast_stat);\nEXPORT_SYMBOL(dmu_objset_spa);\nEXPORT_SYMBOL(dmu_objset_space);\nEXPORT_SYMBOL(dmu_objset_fsid_guid);\nEXPORT_SYMBOL(dmu_objset_find);\nEXPORT_SYMBOL(dmu_objset_byteswap);\nEXPORT_SYMBOL(dmu_objset_evict_dbufs);\nEXPORT_SYMBOL(dmu_objset_snap_cmtime);\nEXPORT_SYMBOL(dmu_objset_dnodesize);\n\nEXPORT_SYMBOL(dmu_objset_sync);\nEXPORT_SYMBOL(dmu_objset_is_dirty);\nEXPORT_SYMBOL(dmu_objset_create_impl_dnstats);\nEXPORT_SYMBOL(dmu_objset_create_impl);\nEXPORT_SYMBOL(dmu_objset_open_impl);\nEXPORT_SYMBOL(dmu_objset_evict);\nEXPORT_SYMBOL(dmu_objset_register_type);\nEXPORT_SYMBOL(dmu_objset_sync_done);\nEXPORT_SYMBOL(dmu_objset_userquota_get_ids);\nEXPORT_SYMBOL(dmu_objset_userused_enabled);\nEXPORT_SYMBOL(dmu_objset_userspace_upgrade);\nEXPORT_SYMBOL(dmu_objset_userspace_present);\nEXPORT_SYMBOL(dmu_objset_userobjused_enabled);\nEXPORT_SYMBOL(dmu_objset_userobjspace_upgradable);\nEXPORT_SYMBOL(dmu_objset_userobjspace_present);\nEXPORT_SYMBOL(dmu_objset_projectquota_enabled);\nEXPORT_SYMBOL(dmu_objset_projectquota_present);\nEXPORT_SYMBOL(dmu_objset_projectquota_upgradable);\nEXPORT_SYMBOL(dmu_objset_id_quota_upgrade);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}