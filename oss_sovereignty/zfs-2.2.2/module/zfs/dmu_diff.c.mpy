{
  "module_name": "dmu_diff.c",
  "hash_id": "301d6e03a03c2f9d142e34d71b4512c005c56fd2806ad2e0776c09523bbd187a",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu_diff.c",
  "human_readable_source": " \n \n\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_file.h>\n\n\ntypedef struct dmu_diffarg {\n\tzfs_file_t *da_fp;\t\t \n\toffset_t *da_offp;\n\tint da_err;\t\t\t \n\tdmu_diff_record_t da_ddr;\n} dmu_diffarg_t;\n\nstatic int\nwrite_record(dmu_diffarg_t *da)\n{\n\tzfs_file_t *fp;\n\tssize_t resid;\n\n\tif (da->da_ddr.ddr_type == DDR_NONE) {\n\t\tda->da_err = 0;\n\t\treturn (0);\n\t}\n\n\tfp = da->da_fp;\n\tda->da_err = zfs_file_write(fp, (caddr_t)&da->da_ddr,\n\t    sizeof (da->da_ddr), &resid);\n\t*da->da_offp += sizeof (da->da_ddr);\n\treturn (da->da_err);\n}\n\nstatic int\nreport_free_dnode_range(dmu_diffarg_t *da, uint64_t first, uint64_t last)\n{\n\tASSERT(first <= last);\n\tif (da->da_ddr.ddr_type != DDR_FREE ||\n\t    first != da->da_ddr.ddr_last + 1) {\n\t\tif (write_record(da) != 0)\n\t\t\treturn (da->da_err);\n\t\tda->da_ddr.ddr_type = DDR_FREE;\n\t\tda->da_ddr.ddr_first = first;\n\t\tda->da_ddr.ddr_last = last;\n\t\treturn (0);\n\t}\n\tda->da_ddr.ddr_last = last;\n\treturn (0);\n}\n\nstatic int\nreport_dnode(dmu_diffarg_t *da, uint64_t object, dnode_phys_t *dnp)\n{\n\tASSERT(dnp != NULL);\n\tif (dnp->dn_type == DMU_OT_NONE)\n\t\treturn (report_free_dnode_range(da, object, object));\n\n\tif (da->da_ddr.ddr_type != DDR_INUSE ||\n\t    object != da->da_ddr.ddr_last + 1) {\n\t\tif (write_record(da) != 0)\n\t\t\treturn (da->da_err);\n\t\tda->da_ddr.ddr_type = DDR_INUSE;\n\t\tda->da_ddr.ddr_first = da->da_ddr.ddr_last = object;\n\t\treturn (0);\n\t}\n\tda->da_ddr.ddr_last = object;\n\treturn (0);\n}\n\n#define\tDBP_SPAN(dnp, level)\t\t\t\t  \\\n\t(((uint64_t)dnp->dn_datablkszsec) << (SPA_MINBLOCKSHIFT + \\\n\t(level) * (dnp->dn_indblkshift - SPA_BLKPTRSHIFT)))\n\nstatic int\ndiff_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)\n{\n\t(void) zilog;\n\tdmu_diffarg_t *da = arg;\n\tint err = 0;\n\n\tif (issig(JUSTLOOKING) && issig(FORREAL))\n\t\treturn (SET_ERROR(EINTR));\n\n\tif (zb->zb_level == ZB_DNODE_LEVEL ||\n\t    zb->zb_object != DMU_META_DNODE_OBJECT)\n\t\treturn (0);\n\n\tif (BP_IS_HOLE(bp)) {\n\t\tuint64_t span = DBP_SPAN(dnp, zb->zb_level);\n\t\tuint64_t dnobj = (zb->zb_blkid * span) >> DNODE_SHIFT;\n\n\t\terr = report_free_dnode_range(da, dnobj,\n\t\t    dnobj + (span >> DNODE_SHIFT) - 1);\n\t\tif (err)\n\t\t\treturn (err);\n\t} else if (zb->zb_level == 0) {\n\t\tdnode_phys_t *blk;\n\t\tarc_buf_t *abuf;\n\t\tarc_flags_t aflags = ARC_FLAG_WAIT;\n\t\tint epb = BP_GET_LSIZE(bp) >> DNODE_SHIFT;\n\t\tint zio_flags = ZIO_FLAG_CANFAIL;\n\t\tint i;\n\n\t\tif (BP_IS_PROTECTED(bp))\n\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t\tif (arc_read(NULL, spa, bp, arc_getbuf_func, &abuf,\n\t\t    ZIO_PRIORITY_ASYNC_READ, zio_flags, &aflags, zb) != 0)\n\t\t\treturn (SET_ERROR(EIO));\n\n\t\tblk = abuf->b_data;\n\t\tfor (i = 0; i < epb; i += blk[i].dn_extra_slots + 1) {\n\t\t\tuint64_t dnobj = (zb->zb_blkid <<\n\t\t\t    (DNODE_BLOCK_SHIFT - DNODE_SHIFT)) + i;\n\t\t\terr = report_dnode(da, dnobj, blk+i);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tarc_buf_destroy(abuf, &abuf);\n\t\tif (err)\n\t\t\treturn (err);\n\t\t \n\t\treturn (TRAVERSE_VISIT_NO_CHILDREN);\n\t}\n\treturn (0);\n}\n\nint\ndmu_diff(const char *tosnap_name, const char *fromsnap_name,\n    zfs_file_t *fp, offset_t *offp)\n{\n\tdmu_diffarg_t da;\n\tdsl_dataset_t *fromsnap;\n\tdsl_dataset_t *tosnap;\n\tdsl_pool_t *dp;\n\tint error;\n\tuint64_t fromtxg;\n\n\tif (strchr(tosnap_name, '@') == NULL ||\n\t    strchr(fromsnap_name, '@') == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = dsl_pool_hold(tosnap_name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, tosnap_name, FTAG, &tosnap);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = dsl_dataset_hold(dp, fromsnap_name, FTAG, &fromsnap);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (!dsl_dataset_is_before(tosnap, fromsnap, 0)) {\n\t\tdsl_dataset_rele(fromsnap, FTAG);\n\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\tfromtxg = dsl_dataset_phys(fromsnap)->ds_creation_txg;\n\tdsl_dataset_rele(fromsnap, FTAG);\n\n\tdsl_dataset_long_hold(tosnap, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\tda.da_fp = fp;\n\tda.da_offp = offp;\n\tda.da_ddr.ddr_type = DDR_NONE;\n\tda.da_ddr.ddr_first = da.da_ddr.ddr_last = 0;\n\tda.da_err = 0;\n\n\t \n\terror = traverse_dataset(tosnap, fromtxg,\n\t    TRAVERSE_PRE | TRAVERSE_PREFETCH_METADATA | TRAVERSE_NO_DECRYPT,\n\t    diff_cb, &da);\n\n\tif (error != 0) {\n\t\tda.da_err = error;\n\t} else {\n\t\t \n\t\t(void) write_record(&da);\n\t}\n\n\tdsl_dataset_long_rele(tosnap, FTAG);\n\tdsl_dataset_rele(tosnap, FTAG);\n\n\treturn (da.da_err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}