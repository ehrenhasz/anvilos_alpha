{
  "module_name": "zfs_chksum.c",
  "hash_id": "f4fa1d68a0d8854a08bda9bdd500e0ef834120088c7768cda4b91d89a5f89276",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_chksum.c",
  "human_readable_source": " \n\n \n\n#include <sys/zio_checksum.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_chksum.h>\n#include <sys/zfs_impl.h>\n\n#include <sys/blake3.h>\n#include <sys/sha2.h>\n\n \n#define\tLIMIT_PERF_MBS\t300\n\ntypedef struct {\n\tconst char *name;\n\tconst char *impl;\n\tuint64_t bs1k;\n\tuint64_t bs4k;\n\tuint64_t bs16k;\n\tuint64_t bs64k;\n\tuint64_t bs256k;\n\tuint64_t bs1m;\n\tuint64_t bs4m;\n\tuint64_t bs16m;\n\tzio_cksum_salt_t salt;\n\tzio_checksum_t *(func);\n\tzio_checksum_tmpl_init_t *(init);\n\tzio_checksum_tmpl_free_t *(free);\n} chksum_stat_t;\n\nstatic chksum_stat_t *chksum_stat_data = 0;\nstatic int chksum_stat_cnt = 0;\nstatic kstat_t *chksum_kstat = NULL;\n\n \nstatic int\nchksum_kstat_headers(char *buf, size_t size)\n{\n\tssize_t off = 0;\n\n\toff += kmem_scnprintf(buf + off, size, \"%-23s\", \"implementation\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"1k\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"4k\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"16k\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"64k\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"256k\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"1m\");\n\toff += kmem_scnprintf(buf + off, size - off, \"%8s\", \"4m\");\n\t(void) kmem_scnprintf(buf + off, size - off, \"%8s\\n\", \"16m\");\n\n\treturn (0);\n}\n\nstatic int\nchksum_kstat_data(char *buf, size_t size, void *data)\n{\n\tchksum_stat_t *cs;\n\tssize_t off = 0;\n\tchar b[24];\n\n\tcs = (chksum_stat_t *)data;\n\tkmem_scnprintf(b, 23, \"%s-%s\", cs->name, cs->impl);\n\toff += kmem_scnprintf(buf + off, size - off, \"%-23s\", b);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs1k);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs4k);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs16k);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs64k);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs256k);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs1m);\n\toff += kmem_scnprintf(buf + off, size - off, \"%8llu\",\n\t    (u_longlong_t)cs->bs4m);\n\t(void) kmem_scnprintf(buf + off, size - off, \"%8llu\\n\",\n\t    (u_longlong_t)cs->bs16m);\n\n\treturn (0);\n}\n\nstatic void *\nchksum_kstat_addr(kstat_t *ksp, loff_t n)\n{\n\tif (n < chksum_stat_cnt)\n\t\tksp->ks_private = (void *)(chksum_stat_data + n);\n\telse\n\t\tksp->ks_private = NULL;\n\n\treturn (ksp->ks_private);\n}\n\nstatic void\nchksum_run(chksum_stat_t *cs, abd_t *abd, void *ctx, int round,\n    uint64_t *result)\n{\n\thrtime_t start;\n\tuint64_t run_bw, run_time_ns, run_count = 0, size = 0;\n\tuint32_t l, loops = 0;\n\tzio_cksum_t zcp;\n\n\tswitch (round) {\n\tcase 1:  \n\t\tsize = 1<<10; loops = 128; break;\n\tcase 2:  \n\t\tsize = 1<<12; loops = 64; break;\n\tcase 3:  \n\t\tsize = 1<<14; loops = 32; break;\n\tcase 4:  \n\t\tsize = 1<<16; loops = 16; break;\n\tcase 5:  \n\t\tsize = 1<<18; loops = 8; break;\n\tcase 6:  \n\t\tsize = 1<<20; loops = 4; break;\n\tcase 7:  \n\t\tsize = 1<<22; loops = 1; break;\n\tcase 8:  \n\t\tsize = 1<<24; loops = 1; break;\n\t}\n\n\tkpreempt_disable();\n\tstart = gethrtime();\n\tdo {\n\t\tfor (l = 0; l < loops; l++, run_count++)\n\t\t\tcs->func(abd, size, ctx, &zcp);\n\n\t\trun_time_ns = gethrtime() - start;\n\t} while (run_time_ns < MSEC2NSEC(1));\n\tkpreempt_enable();\n\n\trun_bw = size * run_count * NANOSEC;\n\trun_bw /= run_time_ns;\t \n\t*result = run_bw/1024/1024;  \n}\n\n#define\tLIMIT_INIT\t0\n#define\tLIMIT_NEEDED\t1\n#define\tLIMIT_NOLIMIT\t2\n\nstatic void\nchksum_benchit(chksum_stat_t *cs)\n{\n\tabd_t *abd;\n\tvoid *ctx = 0;\n\tvoid *salt = &cs->salt.zcs_bytes;\n\tstatic int chksum_stat_limit = LIMIT_INIT;\n\n\tmemset(salt, 0, sizeof (cs->salt.zcs_bytes));\n\tif (cs->init)\n\t\tctx = cs->init(&cs->salt);\n\n\t \n\tabd = abd_alloc_linear(1<<20, B_FALSE);\n\tchksum_run(cs, abd, ctx, 1, &cs->bs1k);\n\tchksum_run(cs, abd, ctx, 2, &cs->bs4k);\n\tchksum_run(cs, abd, ctx, 3, &cs->bs16k);\n\tchksum_run(cs, abd, ctx, 4, &cs->bs64k);\n\tchksum_run(cs, abd, ctx, 5, &cs->bs256k);\n\n\t \n\tif (chksum_stat_limit == LIMIT_INIT) {\n\t\tif (cs->bs1k < LIMIT_PERF_MBS) {\n\t\t\tchksum_stat_limit = LIMIT_NEEDED;\n\t\t} else {\n\t\t\tchksum_stat_limit = LIMIT_NOLIMIT;\n\t\t}\n\t}\n\n\t \n\tif (chksum_stat_limit == LIMIT_NEEDED)\n\t\tgoto abort;\n\n\tchksum_run(cs, abd, ctx, 6, &cs->bs1m);\n\tabd_free(abd);\n\n\t \n\tabd = abd_alloc(1<<24, B_FALSE);\n\tchksum_run(cs, abd, ctx, 7, &cs->bs4m);\n\tchksum_run(cs, abd, ctx, 8, &cs->bs16m);\n\nabort:\n\tabd_free(abd);\n\n\t \n\tif (cs->free)\n\t\tcs->free(ctx);\n}\n\n \nstatic void\nchksum_benchmark(void)\n{\n#ifndef _KERNEL\n\t \n\treturn;\n#endif\n\n\tchksum_stat_t *cs;\n\tuint64_t max;\n\tuint32_t id, cbid = 0, id_save;\n\tconst zfs_impl_t *blake3 = zfs_impl_get_ops(\"blake3\");\n\tconst zfs_impl_t *sha256 = zfs_impl_get_ops(\"sha256\");\n\tconst zfs_impl_t *sha512 = zfs_impl_get_ops(\"sha512\");\n\n\t \n\tchksum_stat_cnt = 2;\n\tchksum_stat_cnt += sha256->getcnt();\n\tchksum_stat_cnt += sha512->getcnt();\n\tchksum_stat_cnt += blake3->getcnt();\n\tchksum_stat_data = kmem_zalloc(\n\t    sizeof (chksum_stat_t) * chksum_stat_cnt, KM_SLEEP);\n\n\t \n\tcs = &chksum_stat_data[cbid++];\n\n\t \n\tcs->init = abd_checksum_edonr_tmpl_init;\n\tcs->func = abd_checksum_edonr_native;\n\tcs->free = abd_checksum_edonr_tmpl_free;\n\tcs->name = \"edonr\";\n\tcs->impl = \"generic\";\n\tchksum_benchit(cs);\n\n\t \n\tcs = &chksum_stat_data[cbid++];\n\tcs->init = abd_checksum_skein_tmpl_init;\n\tcs->func = abd_checksum_skein_native;\n\tcs->free = abd_checksum_skein_tmpl_free;\n\tcs->name = \"skein\";\n\tcs->impl = \"generic\";\n\tchksum_benchit(cs);\n\n\t \n\tid_save = sha256->getid();\n\tfor (max = 0, id = 0; id < sha256->getcnt(); id++) {\n\t\tsha256->setid(id);\n\t\tcs = &chksum_stat_data[cbid++];\n\t\tcs->init = 0;\n\t\tcs->func = abd_checksum_sha256;\n\t\tcs->free = 0;\n\t\tcs->name = sha256->name;\n\t\tcs->impl = sha256->getname();\n\t\tchksum_benchit(cs);\n\t\tif (cs->bs256k > max) {\n\t\t\tmax = cs->bs256k;\n\t\t\tsha256->set_fastest(id);\n\t\t}\n\t}\n\tsha256->setid(id_save);\n\n\t \n\tid_save = sha512->getid();\n\tfor (max = 0, id = 0; id < sha512->getcnt(); id++) {\n\t\tsha512->setid(id);\n\t\tcs = &chksum_stat_data[cbid++];\n\t\tcs->init = 0;\n\t\tcs->func = abd_checksum_sha512_native;\n\t\tcs->free = 0;\n\t\tcs->name = sha512->name;\n\t\tcs->impl = sha512->getname();\n\t\tchksum_benchit(cs);\n\t\tif (cs->bs256k > max) {\n\t\t\tmax = cs->bs256k;\n\t\t\tsha512->set_fastest(id);\n\t\t}\n\t}\n\tsha512->setid(id_save);\n\n\t \n\tid_save = blake3->getid();\n\tfor (max = 0, id = 0; id < blake3->getcnt(); id++) {\n\t\tblake3->setid(id);\n\t\tcs = &chksum_stat_data[cbid++];\n\t\tcs->init = abd_checksum_blake3_tmpl_init;\n\t\tcs->func = abd_checksum_blake3_native;\n\t\tcs->free = abd_checksum_blake3_tmpl_free;\n\t\tcs->name = blake3->name;\n\t\tcs->impl = blake3->getname();\n\t\tchksum_benchit(cs);\n\t\tif (cs->bs256k > max) {\n\t\t\tmax = cs->bs256k;\n\t\t\tblake3->set_fastest(id);\n\t\t}\n\t}\n\tblake3->setid(id_save);\n}\n\nvoid\nchksum_init(void)\n{\n#ifdef _KERNEL\n\tblake3_per_cpu_ctx_init();\n#endif\n\n\t \n\tchksum_benchmark();\n\n\t \n\tchksum_kstat = kstat_create(\"zfs\", 0, \"chksum_bench\", \"misc\",\n\t    KSTAT_TYPE_RAW, 0, KSTAT_FLAG_VIRTUAL);\n\n\tif (chksum_kstat != NULL) {\n\t\tchksum_kstat->ks_data = NULL;\n\t\tchksum_kstat->ks_ndata = UINT32_MAX;\n\t\tkstat_set_raw_ops(chksum_kstat,\n\t\t    chksum_kstat_headers,\n\t\t    chksum_kstat_data,\n\t\t    chksum_kstat_addr);\n\t\tkstat_install(chksum_kstat);\n\t}\n}\n\nvoid\nchksum_fini(void)\n{\n\tif (chksum_kstat != NULL) {\n\t\tkstat_delete(chksum_kstat);\n\t\tchksum_kstat = NULL;\n\t}\n\n\tif (chksum_stat_cnt) {\n\t\tkmem_free(chksum_stat_data,\n\t\t    sizeof (chksum_stat_t) * chksum_stat_cnt);\n\t\tchksum_stat_cnt = 0;\n\t\tchksum_stat_data = 0;\n\t}\n\n#ifdef _KERNEL\n\tblake3_per_cpu_ctx_fini();\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}