{
  "module_name": "dnode.c",
  "hash_id": "a554acdefc7ce873e869348fc65a89a3b7fca8ac606def0c6355cea7ef3a1ebd",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dnode.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_dataset.h>\n#include <sys/spa.h>\n#include <sys/zio.h>\n#include <sys/dmu_zfetch.h>\n#include <sys/range_tree.h>\n#include <sys/trace_zfs.h>\n#include <sys/zfs_project.h>\n\ndnode_stats_t dnode_stats = {\n\t{ \"dnode_hold_dbuf_hold\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_dbuf_read\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_alloc_hits\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_alloc_misses\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_alloc_interior\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_alloc_lock_retry\",\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_alloc_lock_misses\",\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_alloc_type_none\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_free_hits\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_free_misses\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_free_lock_misses\",\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_free_lock_retry\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_free_overflow\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_hold_free_refcount\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_free_interior_lock_retry\",\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_allocate\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_reallocate\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_buf_evict\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_alloc_next_chunk\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_alloc_race\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_alloc_next_block\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_invalid\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_recheck1\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_recheck2\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_special\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_handle\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_rwlock\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"dnode_move_active\",\t\t\tKSTAT_DATA_UINT64 },\n};\n\ndnode_sums_t dnode_sums;\n\nstatic kstat_t *dnode_ksp;\nstatic kmem_cache_t *dnode_cache;\n\nstatic dnode_phys_t dnode_phys_zero __maybe_unused;\n\nint zfs_default_bs = SPA_MINBLOCKSHIFT;\nint zfs_default_ibs = DN_MAX_INDBLKSHIFT;\n\n#ifdef\t_KERNEL\nstatic kmem_cbrc_t dnode_move(void *, void *, size_t, void *);\n#endif  \n\nstatic int\ndbuf_compare(const void *x1, const void *x2)\n{\n\tconst dmu_buf_impl_t *d1 = x1;\n\tconst dmu_buf_impl_t *d2 = x2;\n\n\tint cmp = TREE_CMP(d1->db_level, d2->db_level);\n\tif (likely(cmp))\n\t\treturn (cmp);\n\n\tcmp = TREE_CMP(d1->db_blkid, d2->db_blkid);\n\tif (likely(cmp))\n\t\treturn (cmp);\n\n\tif (d1->db_state == DB_SEARCH) {\n\t\tASSERT3S(d2->db_state, !=, DB_SEARCH);\n\t\treturn (-1);\n\t} else if (d2->db_state == DB_SEARCH) {\n\t\tASSERT3S(d1->db_state, !=, DB_SEARCH);\n\t\treturn (1);\n\t}\n\n\treturn (TREE_PCMP(d1, d2));\n}\n\nstatic int\ndnode_cons(void *arg, void *unused, int kmflag)\n{\n\t(void) unused, (void) kmflag;\n\tdnode_t *dn = arg;\n\n\trw_init(&dn->dn_struct_rwlock, NULL, RW_NOLOCKDEP, NULL);\n\tmutex_init(&dn->dn_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&dn->dn_dbufs_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&dn->dn_notxholds, NULL, CV_DEFAULT, NULL);\n\tcv_init(&dn->dn_nodnholds, NULL, CV_DEFAULT, NULL);\n\n\t \n\tzfs_refcount_create_untracked(&dn->dn_holds);\n\tzfs_refcount_create(&dn->dn_tx_holds);\n\tlist_link_init(&dn->dn_link);\n\n\tmemset(dn->dn_next_type, 0, sizeof (dn->dn_next_type));\n\tmemset(dn->dn_next_nblkptr, 0, sizeof (dn->dn_next_nblkptr));\n\tmemset(dn->dn_next_nlevels, 0, sizeof (dn->dn_next_nlevels));\n\tmemset(dn->dn_next_indblkshift, 0, sizeof (dn->dn_next_indblkshift));\n\tmemset(dn->dn_next_bonustype, 0, sizeof (dn->dn_next_bonustype));\n\tmemset(dn->dn_rm_spillblk, 0, sizeof (dn->dn_rm_spillblk));\n\tmemset(dn->dn_next_bonuslen, 0, sizeof (dn->dn_next_bonuslen));\n\tmemset(dn->dn_next_blksz, 0, sizeof (dn->dn_next_blksz));\n\tmemset(dn->dn_next_maxblkid, 0, sizeof (dn->dn_next_maxblkid));\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tmultilist_link_init(&dn->dn_dirty_link[i]);\n\t\tdn->dn_free_ranges[i] = NULL;\n\t\tlist_create(&dn->dn_dirty_records[i],\n\t\t    sizeof (dbuf_dirty_record_t),\n\t\t    offsetof(dbuf_dirty_record_t, dr_dirty_node));\n\t}\n\n\tdn->dn_allocated_txg = 0;\n\tdn->dn_free_txg = 0;\n\tdn->dn_assigned_txg = 0;\n\tdn->dn_dirty_txg = 0;\n\tdn->dn_dirtyctx = 0;\n\tdn->dn_dirtyctx_firstset = NULL;\n\tdn->dn_bonus = NULL;\n\tdn->dn_have_spill = B_FALSE;\n\tdn->dn_zio = NULL;\n\tdn->dn_oldused = 0;\n\tdn->dn_oldflags = 0;\n\tdn->dn_olduid = 0;\n\tdn->dn_oldgid = 0;\n\tdn->dn_oldprojid = ZFS_DEFAULT_PROJID;\n\tdn->dn_newuid = 0;\n\tdn->dn_newgid = 0;\n\tdn->dn_newprojid = ZFS_DEFAULT_PROJID;\n\tdn->dn_id_flags = 0;\n\n\tdn->dn_dbufs_count = 0;\n\tavl_create(&dn->dn_dbufs, dbuf_compare, sizeof (dmu_buf_impl_t),\n\t    offsetof(dmu_buf_impl_t, db_link));\n\n\tdn->dn_moved = 0;\n\treturn (0);\n}\n\nstatic void\ndnode_dest(void *arg, void *unused)\n{\n\t(void) unused;\n\tdnode_t *dn = arg;\n\n\trw_destroy(&dn->dn_struct_rwlock);\n\tmutex_destroy(&dn->dn_mtx);\n\tmutex_destroy(&dn->dn_dbufs_mtx);\n\tcv_destroy(&dn->dn_notxholds);\n\tcv_destroy(&dn->dn_nodnholds);\n\tzfs_refcount_destroy(&dn->dn_holds);\n\tzfs_refcount_destroy(&dn->dn_tx_holds);\n\tASSERT(!list_link_active(&dn->dn_link));\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT(!multilist_link_active(&dn->dn_dirty_link[i]));\n\t\tASSERT3P(dn->dn_free_ranges[i], ==, NULL);\n\t\tlist_destroy(&dn->dn_dirty_records[i]);\n\t\tASSERT0(dn->dn_next_nblkptr[i]);\n\t\tASSERT0(dn->dn_next_nlevels[i]);\n\t\tASSERT0(dn->dn_next_indblkshift[i]);\n\t\tASSERT0(dn->dn_next_bonustype[i]);\n\t\tASSERT0(dn->dn_rm_spillblk[i]);\n\t\tASSERT0(dn->dn_next_bonuslen[i]);\n\t\tASSERT0(dn->dn_next_blksz[i]);\n\t\tASSERT0(dn->dn_next_maxblkid[i]);\n\t}\n\n\tASSERT0(dn->dn_allocated_txg);\n\tASSERT0(dn->dn_free_txg);\n\tASSERT0(dn->dn_assigned_txg);\n\tASSERT0(dn->dn_dirty_txg);\n\tASSERT0(dn->dn_dirtyctx);\n\tASSERT3P(dn->dn_dirtyctx_firstset, ==, NULL);\n\tASSERT3P(dn->dn_bonus, ==, NULL);\n\tASSERT(!dn->dn_have_spill);\n\tASSERT3P(dn->dn_zio, ==, NULL);\n\tASSERT0(dn->dn_oldused);\n\tASSERT0(dn->dn_oldflags);\n\tASSERT0(dn->dn_olduid);\n\tASSERT0(dn->dn_oldgid);\n\tASSERT0(dn->dn_oldprojid);\n\tASSERT0(dn->dn_newuid);\n\tASSERT0(dn->dn_newgid);\n\tASSERT0(dn->dn_newprojid);\n\tASSERT0(dn->dn_id_flags);\n\n\tASSERT0(dn->dn_dbufs_count);\n\tavl_destroy(&dn->dn_dbufs);\n}\n\nstatic int\ndnode_kstats_update(kstat_t *ksp, int rw)\n{\n\tdnode_stats_t *ds = ksp->ks_data;\n\n\tif (rw == KSTAT_WRITE)\n\t\treturn (EACCES);\n\tds->dnode_hold_dbuf_hold.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_dbuf_hold);\n\tds->dnode_hold_dbuf_read.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_dbuf_read);\n\tds->dnode_hold_alloc_hits.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_alloc_hits);\n\tds->dnode_hold_alloc_misses.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_alloc_misses);\n\tds->dnode_hold_alloc_interior.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_alloc_interior);\n\tds->dnode_hold_alloc_lock_retry.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_alloc_lock_retry);\n\tds->dnode_hold_alloc_lock_misses.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_alloc_lock_misses);\n\tds->dnode_hold_alloc_type_none.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_alloc_type_none);\n\tds->dnode_hold_free_hits.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_free_hits);\n\tds->dnode_hold_free_misses.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_free_misses);\n\tds->dnode_hold_free_lock_misses.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_free_lock_misses);\n\tds->dnode_hold_free_lock_retry.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_free_lock_retry);\n\tds->dnode_hold_free_refcount.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_free_refcount);\n\tds->dnode_hold_free_overflow.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_hold_free_overflow);\n\tds->dnode_free_interior_lock_retry.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_free_interior_lock_retry);\n\tds->dnode_allocate.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_allocate);\n\tds->dnode_reallocate.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_reallocate);\n\tds->dnode_buf_evict.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_buf_evict);\n\tds->dnode_alloc_next_chunk.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_alloc_next_chunk);\n\tds->dnode_alloc_race.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_alloc_race);\n\tds->dnode_alloc_next_block.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_alloc_next_block);\n\tds->dnode_move_invalid.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_invalid);\n\tds->dnode_move_recheck1.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_recheck1);\n\tds->dnode_move_recheck2.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_recheck2);\n\tds->dnode_move_special.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_special);\n\tds->dnode_move_handle.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_handle);\n\tds->dnode_move_rwlock.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_rwlock);\n\tds->dnode_move_active.value.ui64 =\n\t    wmsum_value(&dnode_sums.dnode_move_active);\n\treturn (0);\n}\n\nvoid\ndnode_init(void)\n{\n\tASSERT(dnode_cache == NULL);\n\tdnode_cache = kmem_cache_create(\"dnode_t\", sizeof (dnode_t),\n\t    0, dnode_cons, dnode_dest, NULL, NULL, NULL, 0);\n\tkmem_cache_set_move(dnode_cache, dnode_move);\n\n\twmsum_init(&dnode_sums.dnode_hold_dbuf_hold, 0);\n\twmsum_init(&dnode_sums.dnode_hold_dbuf_read, 0);\n\twmsum_init(&dnode_sums.dnode_hold_alloc_hits, 0);\n\twmsum_init(&dnode_sums.dnode_hold_alloc_misses, 0);\n\twmsum_init(&dnode_sums.dnode_hold_alloc_interior, 0);\n\twmsum_init(&dnode_sums.dnode_hold_alloc_lock_retry, 0);\n\twmsum_init(&dnode_sums.dnode_hold_alloc_lock_misses, 0);\n\twmsum_init(&dnode_sums.dnode_hold_alloc_type_none, 0);\n\twmsum_init(&dnode_sums.dnode_hold_free_hits, 0);\n\twmsum_init(&dnode_sums.dnode_hold_free_misses, 0);\n\twmsum_init(&dnode_sums.dnode_hold_free_lock_misses, 0);\n\twmsum_init(&dnode_sums.dnode_hold_free_lock_retry, 0);\n\twmsum_init(&dnode_sums.dnode_hold_free_refcount, 0);\n\twmsum_init(&dnode_sums.dnode_hold_free_overflow, 0);\n\twmsum_init(&dnode_sums.dnode_free_interior_lock_retry, 0);\n\twmsum_init(&dnode_sums.dnode_allocate, 0);\n\twmsum_init(&dnode_sums.dnode_reallocate, 0);\n\twmsum_init(&dnode_sums.dnode_buf_evict, 0);\n\twmsum_init(&dnode_sums.dnode_alloc_next_chunk, 0);\n\twmsum_init(&dnode_sums.dnode_alloc_race, 0);\n\twmsum_init(&dnode_sums.dnode_alloc_next_block, 0);\n\twmsum_init(&dnode_sums.dnode_move_invalid, 0);\n\twmsum_init(&dnode_sums.dnode_move_recheck1, 0);\n\twmsum_init(&dnode_sums.dnode_move_recheck2, 0);\n\twmsum_init(&dnode_sums.dnode_move_special, 0);\n\twmsum_init(&dnode_sums.dnode_move_handle, 0);\n\twmsum_init(&dnode_sums.dnode_move_rwlock, 0);\n\twmsum_init(&dnode_sums.dnode_move_active, 0);\n\n\tdnode_ksp = kstat_create(\"zfs\", 0, \"dnodestats\", \"misc\",\n\t    KSTAT_TYPE_NAMED, sizeof (dnode_stats) / sizeof (kstat_named_t),\n\t    KSTAT_FLAG_VIRTUAL);\n\tif (dnode_ksp != NULL) {\n\t\tdnode_ksp->ks_data = &dnode_stats;\n\t\tdnode_ksp->ks_update = dnode_kstats_update;\n\t\tkstat_install(dnode_ksp);\n\t}\n}\n\nvoid\ndnode_fini(void)\n{\n\tif (dnode_ksp != NULL) {\n\t\tkstat_delete(dnode_ksp);\n\t\tdnode_ksp = NULL;\n\t}\n\n\twmsum_fini(&dnode_sums.dnode_hold_dbuf_hold);\n\twmsum_fini(&dnode_sums.dnode_hold_dbuf_read);\n\twmsum_fini(&dnode_sums.dnode_hold_alloc_hits);\n\twmsum_fini(&dnode_sums.dnode_hold_alloc_misses);\n\twmsum_fini(&dnode_sums.dnode_hold_alloc_interior);\n\twmsum_fini(&dnode_sums.dnode_hold_alloc_lock_retry);\n\twmsum_fini(&dnode_sums.dnode_hold_alloc_lock_misses);\n\twmsum_fini(&dnode_sums.dnode_hold_alloc_type_none);\n\twmsum_fini(&dnode_sums.dnode_hold_free_hits);\n\twmsum_fini(&dnode_sums.dnode_hold_free_misses);\n\twmsum_fini(&dnode_sums.dnode_hold_free_lock_misses);\n\twmsum_fini(&dnode_sums.dnode_hold_free_lock_retry);\n\twmsum_fini(&dnode_sums.dnode_hold_free_refcount);\n\twmsum_fini(&dnode_sums.dnode_hold_free_overflow);\n\twmsum_fini(&dnode_sums.dnode_free_interior_lock_retry);\n\twmsum_fini(&dnode_sums.dnode_allocate);\n\twmsum_fini(&dnode_sums.dnode_reallocate);\n\twmsum_fini(&dnode_sums.dnode_buf_evict);\n\twmsum_fini(&dnode_sums.dnode_alloc_next_chunk);\n\twmsum_fini(&dnode_sums.dnode_alloc_race);\n\twmsum_fini(&dnode_sums.dnode_alloc_next_block);\n\twmsum_fini(&dnode_sums.dnode_move_invalid);\n\twmsum_fini(&dnode_sums.dnode_move_recheck1);\n\twmsum_fini(&dnode_sums.dnode_move_recheck2);\n\twmsum_fini(&dnode_sums.dnode_move_special);\n\twmsum_fini(&dnode_sums.dnode_move_handle);\n\twmsum_fini(&dnode_sums.dnode_move_rwlock);\n\twmsum_fini(&dnode_sums.dnode_move_active);\n\n\tkmem_cache_destroy(dnode_cache);\n\tdnode_cache = NULL;\n}\n\n\n#ifdef ZFS_DEBUG\nvoid\ndnode_verify(dnode_t *dn)\n{\n\tint drop_struct_lock = FALSE;\n\n\tASSERT(dn->dn_phys);\n\tASSERT(dn->dn_objset);\n\tASSERT(dn->dn_handle->dnh_dnode == dn);\n\n\tASSERT(DMU_OT_IS_VALID(dn->dn_phys->dn_type));\n\n\tif (!(zfs_flags & ZFS_DEBUG_DNODE_VERIFY))\n\t\treturn;\n\n\tif (!RW_WRITE_HELD(&dn->dn_struct_rwlock)) {\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\tdrop_struct_lock = TRUE;\n\t}\n\tif (dn->dn_phys->dn_type != DMU_OT_NONE || dn->dn_allocated_txg != 0) {\n\t\tint i;\n\t\tint max_bonuslen = DN_SLOTS_TO_BONUSLEN(dn->dn_num_slots);\n\t\tASSERT3U(dn->dn_indblkshift, <=, SPA_MAXBLOCKSHIFT);\n\t\tif (dn->dn_datablkshift) {\n\t\t\tASSERT3U(dn->dn_datablkshift, >=, SPA_MINBLOCKSHIFT);\n\t\t\tASSERT3U(dn->dn_datablkshift, <=, SPA_MAXBLOCKSHIFT);\n\t\t\tASSERT3U(1<<dn->dn_datablkshift, ==, dn->dn_datablksz);\n\t\t}\n\t\tASSERT3U(dn->dn_nlevels, <=, 30);\n\t\tASSERT(DMU_OT_IS_VALID(dn->dn_type));\n\t\tASSERT3U(dn->dn_nblkptr, >=, 1);\n\t\tASSERT3U(dn->dn_nblkptr, <=, DN_MAX_NBLKPTR);\n\t\tASSERT3U(dn->dn_bonuslen, <=, max_bonuslen);\n\t\tASSERT3U(dn->dn_datablksz, ==,\n\t\t    dn->dn_datablkszsec << SPA_MINBLOCKSHIFT);\n\t\tASSERT3U(ISP2(dn->dn_datablksz), ==, dn->dn_datablkshift != 0);\n\t\tASSERT3U((dn->dn_nblkptr - 1) * sizeof (blkptr_t) +\n\t\t    dn->dn_bonuslen, <=, max_bonuslen);\n\t\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\t\tASSERT3U(dn->dn_next_nlevels[i], <=, dn->dn_nlevels);\n\t\t}\n\t}\n\tif (dn->dn_phys->dn_type != DMU_OT_NONE)\n\t\tASSERT3U(dn->dn_phys->dn_nlevels, <=, dn->dn_nlevels);\n\tASSERT(DMU_OBJECT_IS_SPECIAL(dn->dn_object) || dn->dn_dbuf != NULL);\n\tif (dn->dn_dbuf != NULL) {\n\t\tASSERT3P(dn->dn_phys, ==,\n\t\t    (dnode_phys_t *)dn->dn_dbuf->db.db_data +\n\t\t    (dn->dn_object % (dn->dn_dbuf->db.db_size >> DNODE_SHIFT)));\n\t}\n\tif (drop_struct_lock)\n\t\trw_exit(&dn->dn_struct_rwlock);\n}\n#endif\n\nvoid\ndnode_byteswap(dnode_phys_t *dnp)\n{\n\tuint64_t *buf64 = (void*)&dnp->dn_blkptr;\n\tint i;\n\n\tif (dnp->dn_type == DMU_OT_NONE) {\n\t\tmemset(dnp, 0, sizeof (dnode_phys_t));\n\t\treturn;\n\t}\n\n\tdnp->dn_datablkszsec = BSWAP_16(dnp->dn_datablkszsec);\n\tdnp->dn_bonuslen = BSWAP_16(dnp->dn_bonuslen);\n\tdnp->dn_extra_slots = BSWAP_8(dnp->dn_extra_slots);\n\tdnp->dn_maxblkid = BSWAP_64(dnp->dn_maxblkid);\n\tdnp->dn_used = BSWAP_64(dnp->dn_used);\n\n\t \n\tASSERT(dnp->dn_indblkshift <= SPA_MAXBLOCKSHIFT);\n\tASSERT(dnp->dn_nblkptr <= DN_MAX_NBLKPTR);\n\tfor (i = 0; i < dnp->dn_nblkptr * sizeof (blkptr_t)/8; i++)\n\t\tbuf64[i] = BSWAP_64(buf64[i]);\n\n\t \n\tif (dnp->dn_bonuslen != 0) {\n\t\tdmu_object_byteswap_t byteswap;\n\t\tASSERT(DMU_OT_IS_VALID(dnp->dn_bonustype));\n\t\tbyteswap = DMU_OT_BYTESWAP(dnp->dn_bonustype);\n\t\tdmu_ot_byteswap[byteswap].ob_func(DN_BONUS(dnp),\n\t\t    DN_MAX_BONUS_LEN(dnp));\n\t}\n\n\t \n\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR)\n\t\tbyteswap_uint64_array(DN_SPILL_BLKPTR(dnp), sizeof (blkptr_t));\n}\n\nvoid\ndnode_buf_byteswap(void *vbuf, size_t size)\n{\n\tint i = 0;\n\n\tASSERT3U(sizeof (dnode_phys_t), ==, (1<<DNODE_SHIFT));\n\tASSERT((size & (sizeof (dnode_phys_t)-1)) == 0);\n\n\twhile (i < size) {\n\t\tdnode_phys_t *dnp = (void *)(((char *)vbuf) + i);\n\t\tdnode_byteswap(dnp);\n\n\t\ti += DNODE_MIN_SIZE;\n\t\tif (dnp->dn_type != DMU_OT_NONE)\n\t\t\ti += dnp->dn_extra_slots * DNODE_MIN_SIZE;\n\t}\n}\n\nvoid\ndnode_setbonuslen(dnode_t *dn, int newsize, dmu_tx_t *tx)\n{\n\tASSERT3U(zfs_refcount_count(&dn->dn_holds), >=, 1);\n\n\tdnode_setdirty(dn, tx);\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\tASSERT3U(newsize, <=, DN_SLOTS_TO_BONUSLEN(dn->dn_num_slots) -\n\t    (dn->dn_nblkptr-1) * sizeof (blkptr_t));\n\n\tif (newsize < dn->dn_bonuslen) {\n\t\t \n\t\tsize_t diff = dn->dn_bonuslen - newsize;\n\t\tchar *data_end = ((char *)dn->dn_bonus->db.db_data) + newsize;\n\t\tmemset(data_end, 0, diff);\n\t}\n\n\tdn->dn_bonuslen = newsize;\n\tif (newsize == 0)\n\t\tdn->dn_next_bonuslen[tx->tx_txg & TXG_MASK] = DN_ZERO_BONUSLEN;\n\telse\n\t\tdn->dn_next_bonuslen[tx->tx_txg & TXG_MASK] = dn->dn_bonuslen;\n\trw_exit(&dn->dn_struct_rwlock);\n}\n\nvoid\ndnode_setbonus_type(dnode_t *dn, dmu_object_type_t newtype, dmu_tx_t *tx)\n{\n\tASSERT3U(zfs_refcount_count(&dn->dn_holds), >=, 1);\n\tdnode_setdirty(dn, tx);\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\tdn->dn_bonustype = newtype;\n\tdn->dn_next_bonustype[tx->tx_txg & TXG_MASK] = dn->dn_bonustype;\n\trw_exit(&dn->dn_struct_rwlock);\n}\n\nvoid\ndnode_rm_spill(dnode_t *dn, dmu_tx_t *tx)\n{\n\tASSERT3U(zfs_refcount_count(&dn->dn_holds), >=, 1);\n\tASSERT(RW_WRITE_HELD(&dn->dn_struct_rwlock));\n\tdnode_setdirty(dn, tx);\n\tdn->dn_rm_spillblk[tx->tx_txg & TXG_MASK] = DN_KILL_SPILLBLK;\n\tdn->dn_have_spill = B_FALSE;\n}\n\nstatic void\ndnode_setdblksz(dnode_t *dn, int size)\n{\n\tASSERT0(P2PHASE(size, SPA_MINBLOCKSIZE));\n\tASSERT3U(size, <=, SPA_MAXBLOCKSIZE);\n\tASSERT3U(size, >=, SPA_MINBLOCKSIZE);\n\tASSERT3U(size >> SPA_MINBLOCKSHIFT, <,\n\t    1<<(sizeof (dn->dn_phys->dn_datablkszsec) * 8));\n\tdn->dn_datablksz = size;\n\tdn->dn_datablkszsec = size >> SPA_MINBLOCKSHIFT;\n\tdn->dn_datablkshift = ISP2(size) ? highbit64(size - 1) : 0;\n}\n\nstatic dnode_t *\ndnode_create(objset_t *os, dnode_phys_t *dnp, dmu_buf_impl_t *db,\n    uint64_t object, dnode_handle_t *dnh)\n{\n\tdnode_t *dn;\n\n\tdn = kmem_cache_alloc(dnode_cache, KM_SLEEP);\n\tdn->dn_moved = 0;\n\n\t \n\tdn->dn_object = object;\n\tdn->dn_dbuf = db;\n\tdn->dn_handle = dnh;\n\tdn->dn_phys = dnp;\n\n\tif (dnp->dn_datablkszsec) {\n\t\tdnode_setdblksz(dn, dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT);\n\t} else {\n\t\tdn->dn_datablksz = 0;\n\t\tdn->dn_datablkszsec = 0;\n\t\tdn->dn_datablkshift = 0;\n\t}\n\tdn->dn_indblkshift = dnp->dn_indblkshift;\n\tdn->dn_nlevels = dnp->dn_nlevels;\n\tdn->dn_type = dnp->dn_type;\n\tdn->dn_nblkptr = dnp->dn_nblkptr;\n\tdn->dn_checksum = dnp->dn_checksum;\n\tdn->dn_compress = dnp->dn_compress;\n\tdn->dn_bonustype = dnp->dn_bonustype;\n\tdn->dn_bonuslen = dnp->dn_bonuslen;\n\tdn->dn_num_slots = dnp->dn_extra_slots + 1;\n\tdn->dn_maxblkid = dnp->dn_maxblkid;\n\tdn->dn_have_spill = ((dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) != 0);\n\tdn->dn_id_flags = 0;\n\n\tdmu_zfetch_init(&dn->dn_zfetch, dn);\n\n\tASSERT(DMU_OT_IS_VALID(dn->dn_phys->dn_type));\n\tASSERT(zrl_is_locked(&dnh->dnh_zrlock));\n\tASSERT(!DN_SLOT_IS_PTR(dnh->dnh_dnode));\n\n\tmutex_enter(&os->os_lock);\n\n\t \n\tif (!DMU_OBJECT_IS_SPECIAL(object))\n\t\tlist_insert_head(&os->os_dnodes, dn);\n\tmembar_producer();\n\n\t \n\tdn->dn_objset = os;\n\n\tdnh->dnh_dnode = dn;\n\tmutex_exit(&os->os_lock);\n\n\tarc_space_consume(sizeof (dnode_t), ARC_SPACE_DNODE);\n\n\treturn (dn);\n}\n\n \nstatic void\ndnode_destroy(dnode_t *dn)\n{\n\tobjset_t *os = dn->dn_objset;\n\tboolean_t complete_os_eviction = B_FALSE;\n\n\tASSERT((dn->dn_id_flags & DN_ID_NEW_EXIST) == 0);\n\n\tmutex_enter(&os->os_lock);\n\tPOINTER_INVALIDATE(&dn->dn_objset);\n\tif (!DMU_OBJECT_IS_SPECIAL(dn->dn_object)) {\n\t\tlist_remove(&os->os_dnodes, dn);\n\t\tcomplete_os_eviction =\n\t\t    list_is_empty(&os->os_dnodes) &&\n\t\t    list_link_active(&os->os_evicting_node);\n\t}\n\tmutex_exit(&os->os_lock);\n\n\t \n\tif (!zrl_is_locked(&dn->dn_handle->dnh_zrlock))\n\t\tzrl_remove(&dn->dn_handle->dnh_zrlock);\n\n\tdn->dn_allocated_txg = 0;\n\tdn->dn_free_txg = 0;\n\tdn->dn_assigned_txg = 0;\n\tdn->dn_dirty_txg = 0;\n\n\tdn->dn_dirtyctx = 0;\n\tdn->dn_dirtyctx_firstset = NULL;\n\tif (dn->dn_bonus != NULL) {\n\t\tmutex_enter(&dn->dn_bonus->db_mtx);\n\t\tdbuf_destroy(dn->dn_bonus);\n\t\tdn->dn_bonus = NULL;\n\t}\n\tdn->dn_zio = NULL;\n\n\tdn->dn_have_spill = B_FALSE;\n\tdn->dn_oldused = 0;\n\tdn->dn_oldflags = 0;\n\tdn->dn_olduid = 0;\n\tdn->dn_oldgid = 0;\n\tdn->dn_oldprojid = ZFS_DEFAULT_PROJID;\n\tdn->dn_newuid = 0;\n\tdn->dn_newgid = 0;\n\tdn->dn_newprojid = ZFS_DEFAULT_PROJID;\n\tdn->dn_id_flags = 0;\n\n\tdmu_zfetch_fini(&dn->dn_zfetch);\n\tkmem_cache_free(dnode_cache, dn);\n\tarc_space_return(sizeof (dnode_t), ARC_SPACE_DNODE);\n\n\tif (complete_os_eviction)\n\t\tdmu_objset_evict_done(os);\n}\n\nvoid\ndnode_allocate(dnode_t *dn, dmu_object_type_t ot, int blocksize, int ibs,\n    dmu_object_type_t bonustype, int bonuslen, int dn_slots, dmu_tx_t *tx)\n{\n\tint i;\n\n\tASSERT3U(dn_slots, >, 0);\n\tASSERT3U(dn_slots << DNODE_SHIFT, <=,\n\t    spa_maxdnodesize(dmu_objset_spa(dn->dn_objset)));\n\tASSERT3U(blocksize, <=,\n\t    spa_maxblocksize(dmu_objset_spa(dn->dn_objset)));\n\tif (blocksize == 0)\n\t\tblocksize = 1 << zfs_default_bs;\n\telse\n\t\tblocksize = P2ROUNDUP(blocksize, SPA_MINBLOCKSIZE);\n\n\tif (ibs == 0)\n\t\tibs = zfs_default_ibs;\n\n\tibs = MIN(MAX(ibs, DN_MIN_INDBLKSHIFT), DN_MAX_INDBLKSHIFT);\n\n\tdprintf(\"os=%p obj=%llu txg=%llu blocksize=%d ibs=%d dn_slots=%d\\n\",\n\t    dn->dn_objset, (u_longlong_t)dn->dn_object,\n\t    (u_longlong_t)tx->tx_txg, blocksize, ibs, dn_slots);\n\tDNODE_STAT_BUMP(dnode_allocate);\n\n\tASSERT(dn->dn_type == DMU_OT_NONE);\n\tASSERT0(memcmp(dn->dn_phys, &dnode_phys_zero, sizeof (dnode_phys_t)));\n\tASSERT(dn->dn_phys->dn_type == DMU_OT_NONE);\n\tASSERT(ot != DMU_OT_NONE);\n\tASSERT(DMU_OT_IS_VALID(ot));\n\tASSERT((bonustype == DMU_OT_NONE && bonuslen == 0) ||\n\t    (bonustype == DMU_OT_SA && bonuslen == 0) ||\n\t    (bonustype != DMU_OT_NONE && bonuslen != 0));\n\tASSERT(DMU_OT_IS_VALID(bonustype));\n\tASSERT3U(bonuslen, <=, DN_SLOTS_TO_BONUSLEN(dn_slots));\n\tASSERT(dn->dn_type == DMU_OT_NONE);\n\tASSERT0(dn->dn_maxblkid);\n\tASSERT0(dn->dn_allocated_txg);\n\tASSERT0(dn->dn_assigned_txg);\n\tASSERT(zfs_refcount_is_zero(&dn->dn_tx_holds));\n\tASSERT3U(zfs_refcount_count(&dn->dn_holds), <=, 1);\n\tASSERT(avl_is_empty(&dn->dn_dbufs));\n\n\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT0(dn->dn_next_nblkptr[i]);\n\t\tASSERT0(dn->dn_next_nlevels[i]);\n\t\tASSERT0(dn->dn_next_indblkshift[i]);\n\t\tASSERT0(dn->dn_next_bonuslen[i]);\n\t\tASSERT0(dn->dn_next_bonustype[i]);\n\t\tASSERT0(dn->dn_rm_spillblk[i]);\n\t\tASSERT0(dn->dn_next_blksz[i]);\n\t\tASSERT0(dn->dn_next_maxblkid[i]);\n\t\tASSERT(!multilist_link_active(&dn->dn_dirty_link[i]));\n\t\tASSERT3P(list_head(&dn->dn_dirty_records[i]), ==, NULL);\n\t\tASSERT3P(dn->dn_free_ranges[i], ==, NULL);\n\t}\n\n\tdn->dn_type = ot;\n\tdnode_setdblksz(dn, blocksize);\n\tdn->dn_indblkshift = ibs;\n\tdn->dn_nlevels = 1;\n\tdn->dn_num_slots = dn_slots;\n\tif (bonustype == DMU_OT_SA)  \n\t\tdn->dn_nblkptr = 1;\n\telse {\n\t\tdn->dn_nblkptr = MIN(DN_MAX_NBLKPTR,\n\t\t    1 + ((DN_SLOTS_TO_BONUSLEN(dn_slots) - bonuslen) >>\n\t\t    SPA_BLKPTRSHIFT));\n\t}\n\n\tdn->dn_bonustype = bonustype;\n\tdn->dn_bonuslen = bonuslen;\n\tdn->dn_checksum = ZIO_CHECKSUM_INHERIT;\n\tdn->dn_compress = ZIO_COMPRESS_INHERIT;\n\tdn->dn_dirtyctx = 0;\n\n\tdn->dn_free_txg = 0;\n\tdn->dn_dirtyctx_firstset = NULL;\n\tdn->dn_dirty_txg = 0;\n\n\tdn->dn_allocated_txg = tx->tx_txg;\n\tdn->dn_id_flags = 0;\n\n\tdnode_setdirty(dn, tx);\n\tdn->dn_next_indblkshift[tx->tx_txg & TXG_MASK] = ibs;\n\tdn->dn_next_bonuslen[tx->tx_txg & TXG_MASK] = dn->dn_bonuslen;\n\tdn->dn_next_bonustype[tx->tx_txg & TXG_MASK] = dn->dn_bonustype;\n\tdn->dn_next_blksz[tx->tx_txg & TXG_MASK] = dn->dn_datablksz;\n}\n\nvoid\ndnode_reallocate(dnode_t *dn, dmu_object_type_t ot, int blocksize,\n    dmu_object_type_t bonustype, int bonuslen, int dn_slots,\n    boolean_t keep_spill, dmu_tx_t *tx)\n{\n\tint nblkptr;\n\n\tASSERT3U(blocksize, >=, SPA_MINBLOCKSIZE);\n\tASSERT3U(blocksize, <=,\n\t    spa_maxblocksize(dmu_objset_spa(dn->dn_objset)));\n\tASSERT0(blocksize % SPA_MINBLOCKSIZE);\n\tASSERT(dn->dn_object != DMU_META_DNODE_OBJECT || dmu_tx_private_ok(tx));\n\tASSERT(tx->tx_txg != 0);\n\tASSERT((bonustype == DMU_OT_NONE && bonuslen == 0) ||\n\t    (bonustype != DMU_OT_NONE && bonuslen != 0) ||\n\t    (bonustype == DMU_OT_SA && bonuslen == 0));\n\tASSERT(DMU_OT_IS_VALID(bonustype));\n\tASSERT3U(bonuslen, <=,\n\t    DN_BONUS_SIZE(spa_maxdnodesize(dmu_objset_spa(dn->dn_objset))));\n\tASSERT3U(bonuslen, <=, DN_BONUS_SIZE(dn_slots << DNODE_SHIFT));\n\n\tdnode_free_interior_slots(dn);\n\tDNODE_STAT_BUMP(dnode_reallocate);\n\n\t \n\tdnode_evict_dbufs(dn);\n\n\tdn->dn_id_flags = 0;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\tdnode_setdirty(dn, tx);\n\tif (dn->dn_datablksz != blocksize) {\n\t\t \n\t\tASSERT0(dn->dn_maxblkid);\n\t\tASSERT(BP_IS_HOLE(&dn->dn_phys->dn_blkptr[0]) ||\n\t\t    dnode_block_freed(dn, 0));\n\n\t\tdnode_setdblksz(dn, blocksize);\n\t\tdn->dn_next_blksz[tx->tx_txg & TXG_MASK] = blocksize;\n\t}\n\tif (dn->dn_bonuslen != bonuslen)\n\t\tdn->dn_next_bonuslen[tx->tx_txg & TXG_MASK] = bonuslen;\n\n\tif (bonustype == DMU_OT_SA)  \n\t\tnblkptr = 1;\n\telse\n\t\tnblkptr = MIN(DN_MAX_NBLKPTR,\n\t\t    1 + ((DN_SLOTS_TO_BONUSLEN(dn_slots) - bonuslen) >>\n\t\t    SPA_BLKPTRSHIFT));\n\tif (dn->dn_bonustype != bonustype)\n\t\tdn->dn_next_bonustype[tx->tx_txg & TXG_MASK] = bonustype;\n\tif (dn->dn_nblkptr != nblkptr)\n\t\tdn->dn_next_nblkptr[tx->tx_txg & TXG_MASK] = nblkptr;\n\tif (dn->dn_phys->dn_flags & DNODE_FLAG_SPILL_BLKPTR && !keep_spill) {\n\t\tdbuf_rm_spill(dn, tx);\n\t\tdnode_rm_spill(dn, tx);\n\t}\n\n\trw_exit(&dn->dn_struct_rwlock);\n\n\t \n\tdn->dn_type = ot;\n\n\t \n\tmutex_enter(&dn->dn_mtx);\n\tdn->dn_bonustype = bonustype;\n\tdn->dn_bonuslen = bonuslen;\n\tdn->dn_num_slots = dn_slots;\n\tdn->dn_nblkptr = nblkptr;\n\tdn->dn_checksum = ZIO_CHECKSUM_INHERIT;\n\tdn->dn_compress = ZIO_COMPRESS_INHERIT;\n\tASSERT3U(dn->dn_nblkptr, <=, DN_MAX_NBLKPTR);\n\n\t \n\tif (dn->dn_bonus) {\n\t\tdn->dn_bonus->db.db_size =\n\t\t    DN_SLOTS_TO_BONUSLEN(dn->dn_num_slots) -\n\t\t    (dn->dn_nblkptr-1) * sizeof (blkptr_t);\n\t\tASSERT(dn->dn_bonuslen <= dn->dn_bonus->db.db_size);\n\t}\n\n\tdn->dn_allocated_txg = tx->tx_txg;\n\tmutex_exit(&dn->dn_mtx);\n}\n\n#ifdef\t_KERNEL\nstatic void\ndnode_move_impl(dnode_t *odn, dnode_t *ndn)\n{\n\tASSERT(!RW_LOCK_HELD(&odn->dn_struct_rwlock));\n\tASSERT(MUTEX_NOT_HELD(&odn->dn_mtx));\n\tASSERT(MUTEX_NOT_HELD(&odn->dn_dbufs_mtx));\n\n\t \n\tndn->dn_objset = odn->dn_objset;\n\tndn->dn_object = odn->dn_object;\n\tndn->dn_dbuf = odn->dn_dbuf;\n\tndn->dn_handle = odn->dn_handle;\n\tndn->dn_phys = odn->dn_phys;\n\tndn->dn_type = odn->dn_type;\n\tndn->dn_bonuslen = odn->dn_bonuslen;\n\tndn->dn_bonustype = odn->dn_bonustype;\n\tndn->dn_nblkptr = odn->dn_nblkptr;\n\tndn->dn_checksum = odn->dn_checksum;\n\tndn->dn_compress = odn->dn_compress;\n\tndn->dn_nlevels = odn->dn_nlevels;\n\tndn->dn_indblkshift = odn->dn_indblkshift;\n\tndn->dn_datablkshift = odn->dn_datablkshift;\n\tndn->dn_datablkszsec = odn->dn_datablkszsec;\n\tndn->dn_datablksz = odn->dn_datablksz;\n\tndn->dn_maxblkid = odn->dn_maxblkid;\n\tndn->dn_num_slots = odn->dn_num_slots;\n\tmemcpy(ndn->dn_next_type, odn->dn_next_type,\n\t    sizeof (odn->dn_next_type));\n\tmemcpy(ndn->dn_next_nblkptr, odn->dn_next_nblkptr,\n\t    sizeof (odn->dn_next_nblkptr));\n\tmemcpy(ndn->dn_next_nlevels, odn->dn_next_nlevels,\n\t    sizeof (odn->dn_next_nlevels));\n\tmemcpy(ndn->dn_next_indblkshift, odn->dn_next_indblkshift,\n\t    sizeof (odn->dn_next_indblkshift));\n\tmemcpy(ndn->dn_next_bonustype, odn->dn_next_bonustype,\n\t    sizeof (odn->dn_next_bonustype));\n\tmemcpy(ndn->dn_rm_spillblk, odn->dn_rm_spillblk,\n\t    sizeof (odn->dn_rm_spillblk));\n\tmemcpy(ndn->dn_next_bonuslen, odn->dn_next_bonuslen,\n\t    sizeof (odn->dn_next_bonuslen));\n\tmemcpy(ndn->dn_next_blksz, odn->dn_next_blksz,\n\t    sizeof (odn->dn_next_blksz));\n\tmemcpy(ndn->dn_next_maxblkid, odn->dn_next_maxblkid,\n\t    sizeof (odn->dn_next_maxblkid));\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tlist_move_tail(&ndn->dn_dirty_records[i],\n\t\t    &odn->dn_dirty_records[i]);\n\t}\n\tmemcpy(ndn->dn_free_ranges, odn->dn_free_ranges,\n\t    sizeof (odn->dn_free_ranges));\n\tndn->dn_allocated_txg = odn->dn_allocated_txg;\n\tndn->dn_free_txg = odn->dn_free_txg;\n\tndn->dn_assigned_txg = odn->dn_assigned_txg;\n\tndn->dn_dirty_txg = odn->dn_dirty_txg;\n\tndn->dn_dirtyctx = odn->dn_dirtyctx;\n\tndn->dn_dirtyctx_firstset = odn->dn_dirtyctx_firstset;\n\tASSERT(zfs_refcount_count(&odn->dn_tx_holds) == 0);\n\tzfs_refcount_transfer(&ndn->dn_holds, &odn->dn_holds);\n\tASSERT(avl_is_empty(&ndn->dn_dbufs));\n\tavl_swap(&ndn->dn_dbufs, &odn->dn_dbufs);\n\tndn->dn_dbufs_count = odn->dn_dbufs_count;\n\tndn->dn_bonus = odn->dn_bonus;\n\tndn->dn_have_spill = odn->dn_have_spill;\n\tndn->dn_zio = odn->dn_zio;\n\tndn->dn_oldused = odn->dn_oldused;\n\tndn->dn_oldflags = odn->dn_oldflags;\n\tndn->dn_olduid = odn->dn_olduid;\n\tndn->dn_oldgid = odn->dn_oldgid;\n\tndn->dn_oldprojid = odn->dn_oldprojid;\n\tndn->dn_newuid = odn->dn_newuid;\n\tndn->dn_newgid = odn->dn_newgid;\n\tndn->dn_newprojid = odn->dn_newprojid;\n\tndn->dn_id_flags = odn->dn_id_flags;\n\tdmu_zfetch_init(&ndn->dn_zfetch, ndn);\n\n\t \n\tASSERT(ndn->dn_handle->dnh_dnode == odn);\n\tndn->dn_handle->dnh_dnode = ndn;\n\n\t \n\todn->dn_dbuf = NULL;\n\todn->dn_handle = NULL;\n\tavl_create(&odn->dn_dbufs, dbuf_compare, sizeof (dmu_buf_impl_t),\n\t    offsetof(dmu_buf_impl_t, db_link));\n\todn->dn_dbufs_count = 0;\n\todn->dn_bonus = NULL;\n\tdmu_zfetch_fini(&odn->dn_zfetch);\n\n\t \n\tPOINTER_INVALIDATE(&odn->dn_objset);\n\n\t \n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tlist_create(&odn->dn_dirty_records[i],\n\t\t    sizeof (dbuf_dirty_record_t),\n\t\t    offsetof(dbuf_dirty_record_t, dr_dirty_node));\n\t\todn->dn_free_ranges[i] = NULL;\n\t\todn->dn_next_nlevels[i] = 0;\n\t\todn->dn_next_indblkshift[i] = 0;\n\t\todn->dn_next_bonustype[i] = 0;\n\t\todn->dn_rm_spillblk[i] = 0;\n\t\todn->dn_next_bonuslen[i] = 0;\n\t\todn->dn_next_blksz[i] = 0;\n\t}\n\todn->dn_allocated_txg = 0;\n\todn->dn_free_txg = 0;\n\todn->dn_assigned_txg = 0;\n\todn->dn_dirty_txg = 0;\n\todn->dn_dirtyctx = 0;\n\todn->dn_dirtyctx_firstset = NULL;\n\todn->dn_have_spill = B_FALSE;\n\todn->dn_zio = NULL;\n\todn->dn_oldused = 0;\n\todn->dn_oldflags = 0;\n\todn->dn_olduid = 0;\n\todn->dn_oldgid = 0;\n\todn->dn_oldprojid = ZFS_DEFAULT_PROJID;\n\todn->dn_newuid = 0;\n\todn->dn_newgid = 0;\n\todn->dn_newprojid = ZFS_DEFAULT_PROJID;\n\todn->dn_id_flags = 0;\n\n\t \n\tndn->dn_moved = 1;\n\todn->dn_moved = (uint8_t)-1;\n}\n\nstatic kmem_cbrc_t\ndnode_move(void *buf, void *newbuf, size_t size, void *arg)\n{\n\tdnode_t *odn = buf, *ndn = newbuf;\n\tobjset_t *os;\n\tint64_t refcount;\n\tuint32_t dbufs;\n\n\t \n\tos = odn->dn_objset;\n\tif (!POINTER_IS_VALID(os)) {\n\t\tDNODE_STAT_BUMP(dnode_move_invalid);\n\t\treturn (KMEM_CBRC_DONT_KNOW);\n\t}\n\n\t \n\trw_enter(&os_lock, RW_WRITER);\n\tif (os != odn->dn_objset) {\n\t\trw_exit(&os_lock);\n\t\tDNODE_STAT_BUMP(dnode_move_recheck1);\n\t\treturn (KMEM_CBRC_DONT_KNOW);\n\t}\n\n\t \n\tmutex_enter(&os->os_lock);\n\n\t \n\tif (os != odn->dn_objset) {\n\t\tmutex_exit(&os->os_lock);\n\t\trw_exit(&os_lock);\n\t\tDNODE_STAT_BUMP(dnode_move_recheck2);\n\t\treturn (KMEM_CBRC_DONT_KNOW);\n\t}\n\n\t \n\trw_exit(&os_lock);\n\tif (DMU_OBJECT_IS_SPECIAL(odn->dn_object)) {\n\t\tmutex_exit(&os->os_lock);\n\t\tDNODE_STAT_BUMP(dnode_move_special);\n\t\treturn (KMEM_CBRC_NO);\n\t}\n\tASSERT(odn->dn_dbuf != NULL);  \n\n\t \n\tif (!zrl_tryenter(&odn->dn_handle->dnh_zrlock)) {\n\t\tmutex_exit(&os->os_lock);\n\t\tDNODE_STAT_BUMP(dnode_move_handle);\n\t\treturn (KMEM_CBRC_LATER);\n\t}\n\n\t \n\tif (!rw_tryenter(&odn->dn_struct_rwlock, RW_WRITER)) {\n\t\tzrl_exit(&odn->dn_handle->dnh_zrlock);\n\t\tmutex_exit(&os->os_lock);\n\t\tDNODE_STAT_BUMP(dnode_move_rwlock);\n\t\treturn (KMEM_CBRC_LATER);\n\t}\n\n\t \n\trefcount = zfs_refcount_count(&odn->dn_holds);\n\tASSERT(refcount >= 0);\n\tdbufs = DN_DBUFS_COUNT(odn);\n\n\t \n\tASSERT3U(dbufs, <=, refcount);\n\tDTRACE_PROBE3(dnode__move, dnode_t *, odn, int64_t, refcount,\n\t    uint32_t, dbufs);\n\n\tif (refcount > dbufs) {\n\t\trw_exit(&odn->dn_struct_rwlock);\n\t\tzrl_exit(&odn->dn_handle->dnh_zrlock);\n\t\tmutex_exit(&os->os_lock);\n\t\tDNODE_STAT_BUMP(dnode_move_active);\n\t\treturn (KMEM_CBRC_LATER);\n\t}\n\n\trw_exit(&odn->dn_struct_rwlock);\n\n\t \n\tdnode_move_impl(odn, ndn);\n\n\tlist_link_replace(&odn->dn_link, &ndn->dn_link);\n\t \n\tASSERT(refcount == zfs_refcount_count(&ndn->dn_holds));\n\tASSERT(dbufs == DN_DBUFS_COUNT(ndn));\n\tzrl_exit(&ndn->dn_handle->dnh_zrlock);  \n\tmutex_exit(&os->os_lock);\n\n\treturn (KMEM_CBRC_YES);\n}\n#endif\t \n\nstatic void\ndnode_slots_hold(dnode_children_t *children, int idx, int slots)\n{\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\tfor (int i = idx; i < idx + slots; i++) {\n\t\tdnode_handle_t *dnh = &children->dnc_children[i];\n\t\tzrl_add(&dnh->dnh_zrlock);\n\t}\n}\n\nstatic void\ndnode_slots_rele(dnode_children_t *children, int idx, int slots)\n{\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\tfor (int i = idx; i < idx + slots; i++) {\n\t\tdnode_handle_t *dnh = &children->dnc_children[i];\n\n\t\tif (zrl_is_locked(&dnh->dnh_zrlock))\n\t\t\tzrl_exit(&dnh->dnh_zrlock);\n\t\telse\n\t\t\tzrl_remove(&dnh->dnh_zrlock);\n\t}\n}\n\nstatic int\ndnode_slots_tryenter(dnode_children_t *children, int idx, int slots)\n{\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\tfor (int i = idx; i < idx + slots; i++) {\n\t\tdnode_handle_t *dnh = &children->dnc_children[i];\n\n\t\tif (!zrl_tryenter(&dnh->dnh_zrlock)) {\n\t\t\tfor (int j = idx; j < i; j++) {\n\t\t\t\tdnh = &children->dnc_children[j];\n\t\t\t\tzrl_exit(&dnh->dnh_zrlock);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}\n\nstatic void\ndnode_set_slots(dnode_children_t *children, int idx, int slots, void *ptr)\n{\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\tfor (int i = idx; i < idx + slots; i++) {\n\t\tdnode_handle_t *dnh = &children->dnc_children[i];\n\t\tdnh->dnh_dnode = ptr;\n\t}\n}\n\nstatic boolean_t\ndnode_check_slots_free(dnode_children_t *children, int idx, int slots)\n{\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\t \n\tfor (int i = idx; i < idx + slots; i++) {\n\t\tdnode_handle_t *dnh = &children->dnc_children[i];\n\t\tdnode_t *dn = dnh->dnh_dnode;\n\n\t\tif (dn == DN_SLOT_FREE) {\n\t\t\tcontinue;\n\t\t} else if (DN_SLOT_IS_PTR(dn)) {\n\t\t\tmutex_enter(&dn->dn_mtx);\n\t\t\tboolean_t can_free = (dn->dn_type == DMU_OT_NONE &&\n\t\t\t    zfs_refcount_is_zero(&dn->dn_holds) &&\n\t\t\t    !DNODE_IS_DIRTY(dn));\n\t\t\tmutex_exit(&dn->dn_mtx);\n\n\t\t\tif (!can_free)\n\t\t\t\treturn (B_FALSE);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\treturn (B_FALSE);\n\t\t}\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic void\ndnode_reclaim_slots(dnode_children_t *children, int idx, int slots)\n{\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\tfor (int i = idx; i < idx + slots; i++) {\n\t\tdnode_handle_t *dnh = &children->dnc_children[i];\n\n\t\tASSERT(zrl_is_locked(&dnh->dnh_zrlock));\n\n\t\tif (DN_SLOT_IS_PTR(dnh->dnh_dnode)) {\n\t\t\tASSERT3S(dnh->dnh_dnode->dn_type, ==, DMU_OT_NONE);\n\t\t\tdnode_destroy(dnh->dnh_dnode);\n\t\t\tdnh->dnh_dnode = DN_SLOT_FREE;\n\t\t}\n\t}\n}\n\nvoid\ndnode_free_interior_slots(dnode_t *dn)\n{\n\tdnode_children_t *children = dmu_buf_get_user(&dn->dn_dbuf->db);\n\tint epb = dn->dn_dbuf->db.db_size >> DNODE_SHIFT;\n\tint idx = (dn->dn_object & (epb - 1)) + 1;\n\tint slots = dn->dn_num_slots - 1;\n\n\tif (slots == 0)\n\t\treturn;\n\n\tASSERT3S(idx + slots, <=, DNODES_PER_BLOCK);\n\n\twhile (!dnode_slots_tryenter(children, idx, slots)) {\n\t\tDNODE_STAT_BUMP(dnode_free_interior_lock_retry);\n\t\tkpreempt(KPREEMPT_SYNC);\n\t}\n\n\tdnode_set_slots(children, idx, slots, DN_SLOT_FREE);\n\tdnode_slots_rele(children, idx, slots);\n}\n\nvoid\ndnode_special_close(dnode_handle_t *dnh)\n{\n\tdnode_t *dn = dnh->dnh_dnode;\n\n\t \n\tmutex_enter(&dn->dn_mtx);\n\tif (zfs_refcount_count(&dn->dn_holds) > 0)\n\t\tcv_wait(&dn->dn_nodnholds, &dn->dn_mtx);\n\tmutex_exit(&dn->dn_mtx);\n\tASSERT3U(zfs_refcount_count(&dn->dn_holds), ==, 0);\n\n\tASSERT(dn->dn_dbuf == NULL ||\n\t    dmu_buf_get_user(&dn->dn_dbuf->db) == NULL);\n\tzrl_add(&dnh->dnh_zrlock);\n\tdnode_destroy(dn);  \n\tzrl_destroy(&dnh->dnh_zrlock);\n\tdnh->dnh_dnode = NULL;\n}\n\nvoid\ndnode_special_open(objset_t *os, dnode_phys_t *dnp, uint64_t object,\n    dnode_handle_t *dnh)\n{\n\tdnode_t *dn;\n\n\tzrl_init(&dnh->dnh_zrlock);\n\tVERIFY3U(1, ==, zrl_tryenter(&dnh->dnh_zrlock));\n\n\tdn = dnode_create(os, dnp, NULL, object, dnh);\n\tDNODE_VERIFY(dn);\n\n\tzrl_exit(&dnh->dnh_zrlock);\n}\n\nstatic void\ndnode_buf_evict_async(void *dbu)\n{\n\tdnode_children_t *dnc = dbu;\n\n\tDNODE_STAT_BUMP(dnode_buf_evict);\n\n\tfor (int i = 0; i < dnc->dnc_count; i++) {\n\t\tdnode_handle_t *dnh = &dnc->dnc_children[i];\n\t\tdnode_t *dn;\n\n\t\t \n\t\tif (!DN_SLOT_IS_PTR(dnh->dnh_dnode)) {\n\t\t\tzrl_destroy(&dnh->dnh_zrlock);\n\t\t\tdnh->dnh_dnode = DN_SLOT_UNINIT;\n\t\t\tcontinue;\n\t\t}\n\n\t\tzrl_add(&dnh->dnh_zrlock);\n\t\tdn = dnh->dnh_dnode;\n\t\t \n\t\tASSERT(zfs_refcount_is_zero(&dn->dn_holds));\n\t\tASSERT(zfs_refcount_is_zero(&dn->dn_tx_holds));\n\n\t\tdnode_destroy(dn);  \n\t\tzrl_destroy(&dnh->dnh_zrlock);\n\t\tdnh->dnh_dnode = DN_SLOT_UNINIT;\n\t}\n\tkmem_free(dnc, sizeof (dnode_children_t) +\n\t    dnc->dnc_count * sizeof (dnode_handle_t));\n}\n\n \nint\ndnode_hold_impl(objset_t *os, uint64_t object, int flag, int slots,\n    const void *tag, dnode_t **dnp)\n{\n\tint epb, idx, err;\n\tint drop_struct_lock = FALSE;\n\tint type;\n\tuint64_t blk;\n\tdnode_t *mdn, *dn;\n\tdmu_buf_impl_t *db;\n\tdnode_children_t *dnc;\n\tdnode_phys_t *dn_block;\n\tdnode_handle_t *dnh;\n\n\tASSERT(!(flag & DNODE_MUST_BE_ALLOCATED) || (slots == 0));\n\tASSERT(!(flag & DNODE_MUST_BE_FREE) || (slots > 0));\n\tIMPLY(flag & DNODE_DRY_RUN, (tag == NULL) && (dnp == NULL));\n\n\t \n\tASSERT(spa_config_held(os->os_spa, SCL_ALL, RW_WRITER) == 0 ||\n\t    (spa_is_root(os->os_spa) &&\n\t    spa_config_held(os->os_spa, SCL_STATE, RW_WRITER)));\n\n\tASSERT((flag & DNODE_MUST_BE_ALLOCATED) || (flag & DNODE_MUST_BE_FREE));\n\n\tif (object == DMU_USERUSED_OBJECT || object == DMU_GROUPUSED_OBJECT ||\n\t    object == DMU_PROJECTUSED_OBJECT) {\n\t\tif (object == DMU_USERUSED_OBJECT)\n\t\t\tdn = DMU_USERUSED_DNODE(os);\n\t\telse if (object == DMU_GROUPUSED_OBJECT)\n\t\t\tdn = DMU_GROUPUSED_DNODE(os);\n\t\telse\n\t\t\tdn = DMU_PROJECTUSED_DNODE(os);\n\t\tif (dn == NULL)\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\ttype = dn->dn_type;\n\t\tif ((flag & DNODE_MUST_BE_ALLOCATED) && type == DMU_OT_NONE)\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\tif ((flag & DNODE_MUST_BE_FREE) && type != DMU_OT_NONE)\n\t\t\treturn (SET_ERROR(EEXIST));\n\t\tDNODE_VERIFY(dn);\n\t\t \n\t\tif (!(flag & DNODE_DRY_RUN)) {\n\t\t\t(void) zfs_refcount_add(&dn->dn_holds, tag);\n\t\t\t*dnp = dn;\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (object == 0 || object >= DN_MAX_OBJECT)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tmdn = DMU_META_DNODE(os);\n\tASSERT(mdn->dn_object == DMU_META_DNODE_OBJECT);\n\n\tDNODE_VERIFY(mdn);\n\n\tif (!RW_WRITE_HELD(&mdn->dn_struct_rwlock)) {\n\t\trw_enter(&mdn->dn_struct_rwlock, RW_READER);\n\t\tdrop_struct_lock = TRUE;\n\t}\n\n\tblk = dbuf_whichblock(mdn, 0, object * sizeof (dnode_phys_t));\n\tdb = dbuf_hold(mdn, blk, FTAG);\n\tif (drop_struct_lock)\n\t\trw_exit(&mdn->dn_struct_rwlock);\n\tif (db == NULL) {\n\t\tDNODE_STAT_BUMP(dnode_hold_dbuf_hold);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t \n\terr = dbuf_read(db, NULL, DB_RF_CANFAIL |\n\t    DB_RF_NO_DECRYPT | DB_RF_NOPREFETCH);\n\tif (err) {\n\t\tDNODE_STAT_BUMP(dnode_hold_dbuf_read);\n\t\tdbuf_rele(db, FTAG);\n\t\treturn (err);\n\t}\n\n\tASSERT3U(db->db.db_size, >=, 1<<DNODE_SHIFT);\n\tepb = db->db.db_size >> DNODE_SHIFT;\n\n\tidx = object & (epb - 1);\n\tdn_block = (dnode_phys_t *)db->db.db_data;\n\n\tASSERT(DB_DNODE(db)->dn_type == DMU_OT_DNODE);\n\tdnc = dmu_buf_get_user(&db->db);\n\tdnh = NULL;\n\tif (dnc == NULL) {\n\t\tdnode_children_t *winner;\n\t\tint skip = 0;\n\n\t\tdnc = kmem_zalloc(sizeof (dnode_children_t) +\n\t\t    epb * sizeof (dnode_handle_t), KM_SLEEP);\n\t\tdnc->dnc_count = epb;\n\t\tdnh = &dnc->dnc_children[0];\n\n\t\t \n\t\tfor (int i = 0; i < epb; i++) {\n\t\t\tzrl_init(&dnh[i].dnh_zrlock);\n\n\t\t\tif (skip) {\n\t\t\t\tskip--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dn_block[i].dn_type != DMU_OT_NONE) {\n\t\t\t\tint interior = dn_block[i].dn_extra_slots;\n\n\t\t\t\tdnode_set_slots(dnc, i, 1, DN_SLOT_ALLOCATED);\n\t\t\t\tdnode_set_slots(dnc, i + 1, interior,\n\t\t\t\t    DN_SLOT_INTERIOR);\n\t\t\t\tskip = interior;\n\t\t\t} else {\n\t\t\t\tdnh[i].dnh_dnode = DN_SLOT_FREE;\n\t\t\t\tskip = 0;\n\t\t\t}\n\t\t}\n\n\t\tdmu_buf_init_user(&dnc->dnc_dbu, NULL,\n\t\t    dnode_buf_evict_async, NULL);\n\t\twinner = dmu_buf_set_user(&db->db, &dnc->dnc_dbu);\n\t\tif (winner != NULL) {\n\n\t\t\tfor (int i = 0; i < epb; i++)\n\t\t\t\tzrl_destroy(&dnh[i].dnh_zrlock);\n\n\t\t\tkmem_free(dnc, sizeof (dnode_children_t) +\n\t\t\t    epb * sizeof (dnode_handle_t));\n\t\t\tdnc = winner;\n\t\t}\n\t}\n\n\tASSERT(dnc->dnc_count == epb);\n\n\tif (flag & DNODE_MUST_BE_ALLOCATED) {\n\t\tslots = 1;\n\n\t\tdnode_slots_hold(dnc, idx, slots);\n\t\tdnh = &dnc->dnc_children[idx];\n\n\t\tif (DN_SLOT_IS_PTR(dnh->dnh_dnode)) {\n\t\t\tdn = dnh->dnh_dnode;\n\t\t} else if (dnh->dnh_dnode == DN_SLOT_INTERIOR) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_alloc_interior);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(EEXIST));\n\t\t} else if (dnh->dnh_dnode != DN_SLOT_ALLOCATED) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_alloc_misses);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t} else {\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\twhile (!dnode_slots_tryenter(dnc, idx, slots)) {\n\t\t\t\tDNODE_STAT_BUMP(dnode_hold_alloc_lock_retry);\n\t\t\t\tkpreempt(KPREEMPT_SYNC);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (DN_SLOT_IS_PTR(dnh->dnh_dnode)) {\n\t\t\t\tDNODE_STAT_BUMP(dnode_hold_alloc_lock_misses);\n\t\t\t\tdn = dnh->dnh_dnode;\n\t\t\t} else {\n\t\t\t\tdn = dnode_create(os, dn_block + idx, db,\n\t\t\t\t    object, dnh);\n\t\t\t}\n\t\t}\n\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tif (dn->dn_type == DMU_OT_NONE || dn->dn_free_txg != 0) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_alloc_type_none);\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\n\t\t \n\t\tif (flag & DNODE_DRY_RUN) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (0);\n\t\t}\n\n\t\tDNODE_STAT_BUMP(dnode_hold_alloc_hits);\n\t} else if (flag & DNODE_MUST_BE_FREE) {\n\n\t\tif (idx + slots - 1 >= DNODES_PER_BLOCK) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_free_overflow);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(ENOSPC));\n\t\t}\n\n\t\tdnode_slots_hold(dnc, idx, slots);\n\n\t\tif (!dnode_check_slots_free(dnc, idx, slots)) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_free_misses);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(ENOSPC));\n\t\t}\n\n\t\tdnode_slots_rele(dnc, idx, slots);\n\t\twhile (!dnode_slots_tryenter(dnc, idx, slots)) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_free_lock_retry);\n\t\t\tkpreempt(KPREEMPT_SYNC);\n\t\t}\n\n\t\tif (!dnode_check_slots_free(dnc, idx, slots)) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_free_lock_misses);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(ENOSPC));\n\t\t}\n\n\t\t \n\t\tif (slots > 1)\n\t\t\tdnode_reclaim_slots(dnc, idx + 1, slots - 1);\n\n\t\tdnh = &dnc->dnc_children[idx];\n\t\tif (DN_SLOT_IS_PTR(dnh->dnh_dnode)) {\n\t\t\tdn = dnh->dnh_dnode;\n\t\t} else {\n\t\t\tdn = dnode_create(os, dn_block + idx, db,\n\t\t\t    object, dnh);\n\t\t}\n\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tif (!zfs_refcount_is_zero(&dn->dn_holds) || dn->dn_free_txg) {\n\t\t\tDNODE_STAT_BUMP(dnode_hold_free_refcount);\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (SET_ERROR(EEXIST));\n\t\t}\n\n\t\t \n\t\tif (flag & DNODE_DRY_RUN) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\tdnode_slots_rele(dnc, idx, slots);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (0);\n\t\t}\n\n\t\tdnode_set_slots(dnc, idx + 1, slots - 1, DN_SLOT_INTERIOR);\n\t\tDNODE_STAT_BUMP(dnode_hold_free_hits);\n\t} else {\n\t\tdbuf_rele(db, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tASSERT0(dn->dn_free_txg);\n\n\tif (zfs_refcount_add(&dn->dn_holds, tag) == 1)\n\t\tdbuf_add_ref(db, dnh);\n\n\tmutex_exit(&dn->dn_mtx);\n\n\t \n\tdnode_slots_rele(dnc, idx, slots);\n\n\tDNODE_VERIFY(dn);\n\tASSERT3P(dnp, !=, NULL);\n\tASSERT3P(dn->dn_dbuf, ==, db);\n\tASSERT3U(dn->dn_object, ==, object);\n\tdbuf_rele(db, FTAG);\n\n\t*dnp = dn;\n\treturn (0);\n}\n\n \nint\ndnode_hold(objset_t *os, uint64_t object, const void *tag, dnode_t **dnp)\n{\n\treturn (dnode_hold_impl(os, object, DNODE_MUST_BE_ALLOCATED, 0, tag,\n\t    dnp));\n}\n\n \nboolean_t\ndnode_add_ref(dnode_t *dn, const void *tag)\n{\n\tmutex_enter(&dn->dn_mtx);\n\tif (zfs_refcount_is_zero(&dn->dn_holds)) {\n\t\tmutex_exit(&dn->dn_mtx);\n\t\treturn (FALSE);\n\t}\n\tVERIFY(1 < zfs_refcount_add(&dn->dn_holds, tag));\n\tmutex_exit(&dn->dn_mtx);\n\treturn (TRUE);\n}\n\nvoid\ndnode_rele(dnode_t *dn, const void *tag)\n{\n\tmutex_enter(&dn->dn_mtx);\n\tdnode_rele_and_unlock(dn, tag, B_FALSE);\n}\n\nvoid\ndnode_rele_and_unlock(dnode_t *dn, const void *tag, boolean_t evicting)\n{\n\tuint64_t refs;\n\t \n\tdmu_buf_impl_t *db = dn->dn_dbuf;\n\tdnode_handle_t *dnh = dn->dn_handle;\n\n\trefs = zfs_refcount_remove(&dn->dn_holds, tag);\n\tif (refs == 0)\n\t\tcv_broadcast(&dn->dn_nodnholds);\n\tmutex_exit(&dn->dn_mtx);\n\t \n\n\t \n#ifdef ZFS_DEBUG\n\tASSERT(refs > 0 || dnh->dnh_zrlock.zr_owner != curthread);\n#endif\n\n\t \n\tif (refs == 0 && db != NULL) {\n\t\t \n\t\tmutex_enter(&db->db_mtx);\n\t\tdbuf_rele_and_unlock(db, dnh, evicting);\n\t}\n}\n\n \nint\ndnode_try_claim(objset_t *os, uint64_t object, int slots)\n{\n\treturn (dnode_hold_impl(os, object, DNODE_MUST_BE_FREE | DNODE_DRY_RUN,\n\t    slots, NULL, NULL));\n}\n\n \nboolean_t\ndnode_is_dirty(dnode_t *dn)\n{\n\tmutex_enter(&dn->dn_mtx);\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tif (multilist_link_active(&dn->dn_dirty_link[i]) ||\n\t\t    !list_is_empty(&dn->dn_dirty_records[i])) {\n\t\t\tmutex_exit(&dn->dn_mtx);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tmutex_exit(&dn->dn_mtx);\n\n\treturn (B_FALSE);\n}\n\nvoid\ndnode_setdirty(dnode_t *dn, dmu_tx_t *tx)\n{\n\tobjset_t *os = dn->dn_objset;\n\tuint64_t txg = tx->tx_txg;\n\n\tif (DMU_OBJECT_IS_SPECIAL(dn->dn_object)) {\n\t\tdsl_dataset_dirty(os->os_dsl_dataset, tx);\n\t\treturn;\n\t}\n\n\tDNODE_VERIFY(dn);\n\n#ifdef ZFS_DEBUG\n\tmutex_enter(&dn->dn_mtx);\n\tASSERT(dn->dn_phys->dn_type || dn->dn_allocated_txg);\n\tASSERT(dn->dn_free_txg == 0 || dn->dn_free_txg >= txg);\n\tmutex_exit(&dn->dn_mtx);\n#endif\n\n\t \n\tdmu_objset_userquota_get_ids(dn, B_TRUE, tx);\n\n\tmultilist_t *dirtylist = &os->os_dirty_dnodes[txg & TXG_MASK];\n\tmultilist_sublist_t *mls = multilist_sublist_lock_obj(dirtylist, dn);\n\n\t \n\tif (multilist_link_active(&dn->dn_dirty_link[txg & TXG_MASK])) {\n\t\tmultilist_sublist_unlock(mls);\n\t\treturn;\n\t}\n\n\tASSERT(!zfs_refcount_is_zero(&dn->dn_holds) ||\n\t    !avl_is_empty(&dn->dn_dbufs));\n\tASSERT(dn->dn_datablksz != 0);\n\tASSERT0(dn->dn_next_bonuslen[txg & TXG_MASK]);\n\tASSERT0(dn->dn_next_blksz[txg & TXG_MASK]);\n\tASSERT0(dn->dn_next_bonustype[txg & TXG_MASK]);\n\n\tdprintf_ds(os->os_dsl_dataset, \"obj=%llu txg=%llu\\n\",\n\t    (u_longlong_t)dn->dn_object, (u_longlong_t)txg);\n\n\tmultilist_sublist_insert_head(mls, dn);\n\n\tmultilist_sublist_unlock(mls);\n\n\t \n\tVERIFY(dnode_add_ref(dn, (void *)(uintptr_t)tx->tx_txg));\n\n\t(void) dbuf_dirty(dn->dn_dbuf, tx);\n\n\tdsl_dataset_dirty(os->os_dsl_dataset, tx);\n}\n\nvoid\ndnode_free(dnode_t *dn, dmu_tx_t *tx)\n{\n\tmutex_enter(&dn->dn_mtx);\n\tif (dn->dn_type == DMU_OT_NONE || dn->dn_free_txg) {\n\t\tmutex_exit(&dn->dn_mtx);\n\t\treturn;\n\t}\n\tdn->dn_free_txg = tx->tx_txg;\n\tmutex_exit(&dn->dn_mtx);\n\n\tdnode_setdirty(dn, tx);\n}\n\n \nint\ndnode_set_blksz(dnode_t *dn, uint64_t size, int ibs, dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db;\n\tint err;\n\n\tASSERT3U(size, <=, spa_maxblocksize(dmu_objset_spa(dn->dn_objset)));\n\tif (size == 0)\n\t\tsize = SPA_MINBLOCKSIZE;\n\telse\n\t\tsize = P2ROUNDUP(size, SPA_MINBLOCKSIZE);\n\n\tif (ibs == dn->dn_indblkshift)\n\t\tibs = 0;\n\n\tif (size == dn->dn_datablksz && ibs == 0)\n\t\treturn (0);\n\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\n\t \n\tif (dn->dn_maxblkid != 0)\n\t\tgoto fail;\n\n\tmutex_enter(&dn->dn_dbufs_mtx);\n\tfor (db = avl_first(&dn->dn_dbufs); db != NULL;\n\t    db = AVL_NEXT(&dn->dn_dbufs, db)) {\n\t\tif (db->db_blkid != 0 && db->db_blkid != DMU_BONUS_BLKID &&\n\t\t    db->db_blkid != DMU_SPILL_BLKID) {\n\t\t\tmutex_exit(&dn->dn_dbufs_mtx);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tmutex_exit(&dn->dn_dbufs_mtx);\n\n\tif (ibs && dn->dn_nlevels != 1)\n\t\tgoto fail;\n\n\tdnode_setdirty(dn, tx);\n\tif (size != dn->dn_datablksz) {\n\t\t \n\t\terr = dbuf_hold_impl(dn, 0, 0, TRUE, FALSE, FTAG, &db);\n\t\tif (err == 0) {\n\t\t\tdbuf_new_size(db, size, tx);\n\t\t} else if (err != ENOENT) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdnode_setdblksz(dn, size);\n\t\tdn->dn_next_blksz[tx->tx_txg & TXG_MASK] = size;\n\t\tif (db)\n\t\t\tdbuf_rele(db, FTAG);\n\t}\n\tif (ibs) {\n\t\tdn->dn_indblkshift = ibs;\n\t\tdn->dn_next_indblkshift[tx->tx_txg & TXG_MASK] = ibs;\n\t}\n\n\trw_exit(&dn->dn_struct_rwlock);\n\treturn (0);\n\nfail:\n\trw_exit(&dn->dn_struct_rwlock);\n\treturn (SET_ERROR(ENOTSUP));\n}\n\nstatic void\ndnode_set_nlevels_impl(dnode_t *dn, int new_nlevels, dmu_tx_t *tx)\n{\n\tuint64_t txgoff = tx->tx_txg & TXG_MASK;\n\tint old_nlevels = dn->dn_nlevels;\n\tdmu_buf_impl_t *db;\n\tlist_t *list;\n\tdbuf_dirty_record_t *new, *dr, *dr_next;\n\n\tASSERT(RW_WRITE_HELD(&dn->dn_struct_rwlock));\n\n\tASSERT3U(new_nlevels, >, dn->dn_nlevels);\n\tdn->dn_nlevels = new_nlevels;\n\n\tASSERT3U(new_nlevels, >, dn->dn_next_nlevels[txgoff]);\n\tdn->dn_next_nlevels[txgoff] = new_nlevels;\n\n\t \n\tdb = dbuf_hold_level(dn, old_nlevels, 0, FTAG);\n\tASSERT(db != NULL);\n\tnew = dbuf_dirty(db, tx);\n\tdbuf_rele(db, FTAG);\n\n\t \n\tmutex_enter(&dn->dn_mtx);\n\tmutex_enter(&new->dt.di.dr_mtx);\n\tlist = &dn->dn_dirty_records[txgoff];\n\tfor (dr = list_head(list); dr; dr = dr_next) {\n\t\tdr_next = list_next(&dn->dn_dirty_records[txgoff], dr);\n\n\t\tIMPLY(dr->dr_dbuf == NULL, old_nlevels == 1);\n\t\tif (dr->dr_dbuf == NULL ||\n\t\t    (dr->dr_dbuf->db_level == old_nlevels - 1 &&\n\t\t    dr->dr_dbuf->db_blkid != DMU_BONUS_BLKID &&\n\t\t    dr->dr_dbuf->db_blkid != DMU_SPILL_BLKID)) {\n\t\t\tlist_remove(&dn->dn_dirty_records[txgoff], dr);\n\t\t\tlist_insert_tail(&new->dt.di.dr_children, dr);\n\t\t\tdr->dr_parent = new;\n\t\t}\n\t}\n\tmutex_exit(&new->dt.di.dr_mtx);\n\tmutex_exit(&dn->dn_mtx);\n}\n\nint\ndnode_set_nlevels(dnode_t *dn, int nlevels, dmu_tx_t *tx)\n{\n\tint ret = 0;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\n\tif (dn->dn_nlevels == nlevels) {\n\t\tret = 0;\n\t\tgoto out;\n\t} else if (nlevels < dn->dn_nlevels) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\n\tdnode_set_nlevels_impl(dn, nlevels, tx);\n\nout:\n\trw_exit(&dn->dn_struct_rwlock);\n\treturn (ret);\n}\n\n \nvoid\ndnode_new_blkid(dnode_t *dn, uint64_t blkid, dmu_tx_t *tx, boolean_t have_read,\n    boolean_t force)\n{\n\tint epbs, new_nlevels;\n\tuint64_t sz;\n\n\tASSERT(blkid != DMU_BONUS_BLKID);\n\n\tASSERT(have_read ?\n\t    RW_READ_HELD(&dn->dn_struct_rwlock) :\n\t    RW_WRITE_HELD(&dn->dn_struct_rwlock));\n\n\t \n\tif (have_read) {\n\t\tif (blkid <= dn->dn_maxblkid)\n\t\t\treturn;\n\n\t\tif (!rw_tryupgrade(&dn->dn_struct_rwlock)) {\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\t\t}\n\t}\n\n\t \n\tif (!force && blkid <= dn->dn_maxblkid)\n\t\tgoto out;\n\n\t \n\tdn->dn_maxblkid = blkid;\n\tdn->dn_next_maxblkid[tx->tx_txg & TXG_MASK] =\n\t    blkid | DMU_NEXT_MAXBLKID_SET;\n\n\t \n\tnew_nlevels = 1;\n\tepbs = dn->dn_indblkshift - SPA_BLKPTRSHIFT;\n\tfor (sz = dn->dn_nblkptr;\n\t    sz <= blkid && sz >= dn->dn_nblkptr; sz <<= epbs)\n\t\tnew_nlevels++;\n\n\tASSERT3U(new_nlevels, <=, DN_MAX_LEVELS);\n\n\tif (!force) {\n\t\tif (new_nlevels > dn->dn_nlevels)\n\t\t\tdnode_set_nlevels_impl(dn, new_nlevels, tx);\n\t} else {\n\t\tASSERT3U(dn->dn_nlevels, >=, new_nlevels);\n\t}\n\nout:\n\tif (have_read)\n\t\trw_downgrade(&dn->dn_struct_rwlock);\n}\n\nstatic void\ndnode_dirty_l1(dnode_t *dn, uint64_t l1blkid, dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db = dbuf_hold_level(dn, 1, l1blkid, FTAG);\n\tif (db != NULL) {\n\t\tdmu_buf_will_dirty(&db->db, tx);\n\t\tdbuf_rele(db, FTAG);\n\t}\n}\n\n \nstatic void\ndnode_dirty_l1range(dnode_t *dn, uint64_t start_blkid, uint64_t end_blkid,\n    dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db_search;\n\tdmu_buf_impl_t *db;\n\tavl_index_t where;\n\n\tdb_search = kmem_zalloc(sizeof (dmu_buf_impl_t), KM_SLEEP);\n\n\tmutex_enter(&dn->dn_dbufs_mtx);\n\n\tdb_search->db_level = 1;\n\tdb_search->db_blkid = start_blkid + 1;\n\tdb_search->db_state = DB_SEARCH;\n\tfor (;;) {\n\n\t\tdb = avl_find(&dn->dn_dbufs, db_search, &where);\n\t\tif (db == NULL)\n\t\t\tdb = avl_nearest(&dn->dn_dbufs, where, AVL_AFTER);\n\n\t\tif (db == NULL || db->db_level != 1 ||\n\t\t    db->db_blkid >= end_blkid) {\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdb_search->db_blkid = db->db_blkid + 1;\n\t\tASSERT3U(db->db_blkid, >=, start_blkid);\n\n\t\t \n\t\tmutex_exit(&dn->dn_dbufs_mtx);\n\t\tdnode_dirty_l1(dn, db->db_blkid, tx);\n\t\tmutex_enter(&dn->dn_dbufs_mtx);\n\t}\n\n#ifdef ZFS_DEBUG\n\t \n\tdb_search->db_level = 1;\n\tdb_search->db_blkid = start_blkid + 1;\n\tdb_search->db_state = DB_SEARCH;\n\tdb = avl_find(&dn->dn_dbufs, db_search, &where);\n\tif (db == NULL)\n\t\tdb = avl_nearest(&dn->dn_dbufs, where, AVL_AFTER);\n\tfor (; db != NULL; db = AVL_NEXT(&dn->dn_dbufs, db)) {\n\t\tif (db->db_level != 1 || db->db_blkid >= end_blkid)\n\t\t\tbreak;\n\t\tif (db->db_state != DB_EVICTING)\n\t\t\tASSERT(db->db_dirtycnt > 0);\n\t}\n#endif\n\tkmem_free(db_search, sizeof (dmu_buf_impl_t));\n\tmutex_exit(&dn->dn_dbufs_mtx);\n}\n\nvoid\ndnode_set_dirtyctx(dnode_t *dn, dmu_tx_t *tx, const void *tag)\n{\n\t \n\tif (dn->dn_dirtyctx == DN_UNDIRTIED) {\n\t\tdsl_dataset_t *ds = dn->dn_objset->os_dsl_dataset;\n\n\t\tif (ds != NULL) {\n\t\t\trrw_enter(&ds->ds_bp_rwlock, RW_READER, tag);\n\t\t}\n\t\tif (!BP_IS_HOLE(dn->dn_objset->os_rootbp)) {\n\t\t\tif (dmu_tx_is_syncing(tx))\n\t\t\t\tdn->dn_dirtyctx = DN_DIRTY_SYNC;\n\t\t\telse\n\t\t\t\tdn->dn_dirtyctx = DN_DIRTY_OPEN;\n\t\t\tdn->dn_dirtyctx_firstset = tag;\n\t\t}\n\t\tif (ds != NULL) {\n\t\t\trrw_exit(&ds->ds_bp_rwlock, tag);\n\t\t}\n\t}\n}\n\nstatic void\ndnode_partial_zero(dnode_t *dn, uint64_t off, uint64_t blkoff, uint64_t len,\n    dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db;\n\tint res;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tres = dbuf_hold_impl(dn, 0, dbuf_whichblock(dn, 0, off), TRUE, FALSE,\n\t    FTAG, &db);\n\trw_exit(&dn->dn_struct_rwlock);\n\tif (res == 0) {\n\t\tdb_lock_type_t dblt;\n\t\tboolean_t dirty;\n\n\t\tdblt = dmu_buf_lock_parent(db, RW_READER, FTAG);\n\t\t \n\t\tdirty = !list_is_empty(&db->db_dirty_records) ||\n\t\t    (db->db_blkptr && !BP_IS_HOLE(db->db_blkptr));\n\t\tdmu_buf_unlock_parent(db, dblt, FTAG);\n\t\tif (dirty) {\n\t\t\tcaddr_t data;\n\n\t\t\tdmu_buf_will_dirty(&db->db, tx);\n\t\t\tdata = db->db.db_data;\n\t\t\tmemset(data + blkoff, 0, len);\n\t\t}\n\t\tdbuf_rele(db, FTAG);\n\t}\n}\n\nvoid\ndnode_free_range(dnode_t *dn, uint64_t off, uint64_t len, dmu_tx_t *tx)\n{\n\tuint64_t blkoff, blkid, nblks;\n\tint blksz, blkshift, head, tail;\n\tint trunc = FALSE;\n\tint epbs;\n\n\tblksz = dn->dn_datablksz;\n\tblkshift = dn->dn_datablkshift;\n\tepbs = dn->dn_indblkshift - SPA_BLKPTRSHIFT;\n\n\tif (len == DMU_OBJECT_END) {\n\t\tlen = UINT64_MAX - off;\n\t\ttrunc = TRUE;\n\t}\n\n\t \n\tif (ISP2(blksz)) {\n\t\thead = P2NPHASE(off, blksz);\n\t\tblkoff = P2PHASE(off, blksz);\n\t\tif ((off >> blkshift) > dn->dn_maxblkid)\n\t\t\treturn;\n\t} else {\n\t\tASSERT(dn->dn_maxblkid == 0);\n\t\tif (off == 0 && len >= blksz) {\n\t\t\t \n\t\t\tblkid = 0;\n\t\t\tnblks = 1;\n\t\t\tif (dn->dn_nlevels > 1) {\n\t\t\t\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\t\t\t\tdnode_dirty_l1(dn, 0, tx);\n\t\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\t}\n\t\t\tgoto done;\n\t\t} else if (off >= blksz) {\n\t\t\t \n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\thead = blksz - off;\n\t\t\tASSERT3U(head, >, 0);\n\t\t}\n\t\tblkoff = off;\n\t}\n\t \n\tif (head) {\n\t\tASSERT3U(blkoff + head, ==, blksz);\n\t\tif (len < head)\n\t\t\thead = len;\n\t\tdnode_partial_zero(dn, off, blkoff, head, tx);\n\t\toff += head;\n\t\tlen -= head;\n\t}\n\n\t \n\tif (len == 0)\n\t\treturn;\n\n\t \n\tif ((off >> blkshift) > dn->dn_maxblkid)\n\t\treturn;\n\n\tASSERT(ISP2(blksz));\n\tif (trunc)\n\t\ttail = 0;\n\telse\n\t\ttail = P2PHASE(len, blksz);\n\n\tASSERT0(P2PHASE(off, blksz));\n\t \n\tif (tail) {\n\t\tif (len < tail)\n\t\t\ttail = len;\n\t\tdnode_partial_zero(dn, off + len, 0, tail, tx);\n\t\tlen -= tail;\n\t}\n\n\t \n\tif (len == 0)\n\t\treturn;\n\n\tASSERT(IS_P2ALIGNED(off, blksz));\n\tASSERT(trunc || IS_P2ALIGNED(len, blksz));\n\tblkid = off >> blkshift;\n\tnblks = len >> blkshift;\n\tif (trunc)\n\t\tnblks += 1;\n\n\t \n\tif (dn->dn_nlevels > 1) {\n\t\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\t\tuint64_t first, last;\n\n\t\tfirst = blkid >> epbs;\n\t\tdnode_dirty_l1(dn, first, tx);\n\t\tif (trunc)\n\t\t\tlast = dn->dn_maxblkid >> epbs;\n\t\telse\n\t\t\tlast = (blkid + nblks - 1) >> epbs;\n\t\tif (last != first)\n\t\t\tdnode_dirty_l1(dn, last, tx);\n\n\t\tdnode_dirty_l1range(dn, first, last, tx);\n\n\t\tint shift = dn->dn_datablkshift + dn->dn_indblkshift -\n\t\t    SPA_BLKPTRSHIFT;\n\t\tfor (uint64_t i = first + 1; i < last; i++) {\n\t\t\t \n\t\t\tuint64_t ibyte = i << shift;\n\t\t\tint err = dnode_next_offset(dn, DNODE_FIND_HAVELOCK,\n\t\t\t    &ibyte, 2, 1, 0);\n\t\t\ti = ibyte >> shift;\n\t\t\tif (i >= last)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\n\t\t\tdnode_dirty_l1(dn, i, tx);\n\t\t}\n\t\trw_exit(&dn->dn_struct_rwlock);\n\t}\n\ndone:\n\t \n\tmutex_enter(&dn->dn_mtx);\n\t{\n\t\tint txgoff = tx->tx_txg & TXG_MASK;\n\t\tif (dn->dn_free_ranges[txgoff] == NULL) {\n\t\t\tdn->dn_free_ranges[txgoff] = range_tree_create(NULL,\n\t\t\t    RANGE_SEG64, NULL, 0, 0);\n\t\t}\n\t\trange_tree_clear(dn->dn_free_ranges[txgoff], blkid, nblks);\n\t\trange_tree_add(dn->dn_free_ranges[txgoff], blkid, nblks);\n\t}\n\tdprintf_dnode(dn, \"blkid=%llu nblks=%llu txg=%llu\\n\",\n\t    (u_longlong_t)blkid, (u_longlong_t)nblks,\n\t    (u_longlong_t)tx->tx_txg);\n\tmutex_exit(&dn->dn_mtx);\n\n\tdbuf_free_range(dn, blkid, blkid + nblks - 1, tx);\n\tdnode_setdirty(dn, tx);\n}\n\nstatic boolean_t\ndnode_spill_freed(dnode_t *dn)\n{\n\tint i;\n\n\tmutex_enter(&dn->dn_mtx);\n\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\tif (dn->dn_rm_spillblk[i] == DN_KILL_SPILLBLK)\n\t\t\tbreak;\n\t}\n\tmutex_exit(&dn->dn_mtx);\n\treturn (i < TXG_SIZE);\n}\n\n \nuint64_t\ndnode_block_freed(dnode_t *dn, uint64_t blkid)\n{\n\tint i;\n\n\tif (blkid == DMU_BONUS_BLKID)\n\t\treturn (FALSE);\n\n\tif (dn->dn_free_txg)\n\t\treturn (TRUE);\n\n\tif (blkid == DMU_SPILL_BLKID)\n\t\treturn (dnode_spill_freed(dn));\n\n\tmutex_enter(&dn->dn_mtx);\n\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\tif (dn->dn_free_ranges[i] != NULL &&\n\t\t    range_tree_contains(dn->dn_free_ranges[i], blkid, 1))\n\t\t\tbreak;\n\t}\n\tmutex_exit(&dn->dn_mtx);\n\treturn (i < TXG_SIZE);\n}\n\n \nvoid\ndnode_diduse_space(dnode_t *dn, int64_t delta)\n{\n\tuint64_t space;\n\tdprintf_dnode(dn, \"dn=%p dnp=%p used=%llu delta=%lld\\n\",\n\t    dn, dn->dn_phys,\n\t    (u_longlong_t)dn->dn_phys->dn_used,\n\t    (longlong_t)delta);\n\n\tmutex_enter(&dn->dn_mtx);\n\tspace = DN_USED_BYTES(dn->dn_phys);\n\tif (delta > 0) {\n\t\tASSERT3U(space + delta, >=, space);  \n\t} else {\n\t\tASSERT3U(space, >=, -delta);  \n\t}\n\tspace += delta;\n\tif (spa_version(dn->dn_objset->os_spa) < SPA_VERSION_DNODE_BYTES) {\n\t\tASSERT((dn->dn_phys->dn_flags & DNODE_FLAG_USED_BYTES) == 0);\n\t\tASSERT0(P2PHASE(space, 1<<DEV_BSHIFT));\n\t\tdn->dn_phys->dn_used = space >> DEV_BSHIFT;\n\t} else {\n\t\tdn->dn_phys->dn_used = space;\n\t\tdn->dn_phys->dn_flags |= DNODE_FLAG_USED_BYTES;\n\t}\n\tmutex_exit(&dn->dn_mtx);\n}\n\n \nstatic int\ndnode_next_offset_level(dnode_t *dn, int flags, uint64_t *offset,\n    int lvl, uint64_t blkfill, uint64_t txg)\n{\n\tdmu_buf_impl_t *db = NULL;\n\tvoid *data = NULL;\n\tuint64_t epbs = dn->dn_phys->dn_indblkshift - SPA_BLKPTRSHIFT;\n\tuint64_t epb = 1ULL << epbs;\n\tuint64_t minfill, maxfill;\n\tboolean_t hole;\n\tint i, inc, error, span;\n\n\tASSERT(RW_LOCK_HELD(&dn->dn_struct_rwlock));\n\n\thole = ((flags & DNODE_FIND_HOLE) != 0);\n\tinc = (flags & DNODE_FIND_BACKWARDS) ? -1 : 1;\n\tASSERT(txg == 0 || !hole);\n\n\tif (lvl == dn->dn_phys->dn_nlevels) {\n\t\terror = 0;\n\t\tepb = dn->dn_phys->dn_nblkptr;\n\t\tdata = dn->dn_phys->dn_blkptr;\n\t} else {\n\t\tuint64_t blkid = dbuf_whichblock(dn, lvl, *offset);\n\t\terror = dbuf_hold_impl(dn, lvl, blkid, TRUE, FALSE, FTAG, &db);\n\t\tif (error) {\n\t\t\tif (error != ENOENT)\n\t\t\t\treturn (error);\n\t\t\tif (hole)\n\t\t\t\treturn (0);\n\t\t\t \n\t\t\treturn (SET_ERROR(ESRCH));\n\t\t}\n\t\terror = dbuf_read(db, NULL,\n\t\t    DB_RF_CANFAIL | DB_RF_HAVESTRUCT |\n\t\t    DB_RF_NO_DECRYPT | DB_RF_NOPREFETCH);\n\t\tif (error) {\n\t\t\tdbuf_rele(db, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\tdata = db->db.db_data;\n\t\trw_enter(&db->db_rwlock, RW_READER);\n\t}\n\n\tif (db != NULL && txg != 0 && (db->db_blkptr == NULL ||\n\t    db->db_blkptr->blk_birth <= txg ||\n\t    BP_IS_HOLE(db->db_blkptr))) {\n\t\t \n\t\terror = SET_ERROR(ESRCH);\n\t} else if (lvl == 0) {\n\t\tdnode_phys_t *dnp = data;\n\n\t\tASSERT(dn->dn_type == DMU_OT_DNODE);\n\t\tASSERT(!(flags & DNODE_FIND_BACKWARDS));\n\n\t\tfor (i = (*offset >> DNODE_SHIFT) & (blkfill - 1);\n\t\t    i < blkfill; i += dnp[i].dn_extra_slots + 1) {\n\t\t\tif ((dnp[i].dn_type == DMU_OT_NONE) == hole)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == blkfill)\n\t\t\terror = SET_ERROR(ESRCH);\n\n\t\t*offset = (*offset & ~(DNODE_BLOCK_SIZE - 1)) +\n\t\t    (i << DNODE_SHIFT);\n\t} else {\n\t\tblkptr_t *bp = data;\n\t\tuint64_t start = *offset;\n\t\tspan = (lvl - 1) * epbs + dn->dn_datablkshift;\n\t\tminfill = 0;\n\t\tmaxfill = blkfill << ((lvl - 1) * epbs);\n\n\t\tif (hole)\n\t\t\tmaxfill--;\n\t\telse\n\t\t\tminfill++;\n\n\t\tif (span >= 8 * sizeof (*offset)) {\n\t\t\t \n\t\t\tASSERT3U((lvl - 1), ==, dn->dn_phys->dn_nlevels - 1);\n\t\t\t*offset = 0;\n\t\t} else {\n\t\t\t*offset = *offset >> span;\n\t\t}\n\n\t\tfor (i = BF64_GET(*offset, 0, epbs);\n\t\t    i >= 0 && i < epb; i += inc) {\n\t\t\tif (BP_GET_FILL(&bp[i]) >= minfill &&\n\t\t\t    BP_GET_FILL(&bp[i]) <= maxfill &&\n\t\t\t    (hole || bp[i].blk_birth > txg))\n\t\t\t\tbreak;\n\t\t\tif (inc > 0 || *offset > 0)\n\t\t\t\t*offset += inc;\n\t\t}\n\n\t\tif (span >= 8 * sizeof (*offset)) {\n\t\t\t*offset = start;\n\t\t} else {\n\t\t\t*offset = *offset << span;\n\t\t}\n\n\t\tif (inc < 0) {\n\t\t\t \n\t\t\tif (span < 8 * sizeof (*offset))\n\t\t\t\t*offset = MIN(*offset + (1ULL << span) - 1,\n\t\t\t\t    start);\n\t\t} else if (*offset < start) {\n\t\t\t*offset = start;\n\t\t}\n\t\tif (i < 0 || i >= epb)\n\t\t\terror = SET_ERROR(ESRCH);\n\t}\n\n\tif (db != NULL) {\n\t\trw_exit(&db->db_rwlock);\n\t\tdbuf_rele(db, FTAG);\n\t}\n\n\treturn (error);\n}\n\n \nint\ndnode_next_offset(dnode_t *dn, int flags, uint64_t *offset,\n    int minlvl, uint64_t blkfill, uint64_t txg)\n{\n\tuint64_t initial_offset = *offset;\n\tint lvl, maxlvl;\n\tint error = 0;\n\n\tif (!(flags & DNODE_FIND_HAVELOCK))\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\n\tif (dn->dn_phys->dn_nlevels == 0) {\n\t\terror = SET_ERROR(ESRCH);\n\t\tgoto out;\n\t}\n\n\tif (dn->dn_datablkshift == 0) {\n\t\tif (*offset < dn->dn_datablksz) {\n\t\t\tif (flags & DNODE_FIND_HOLE)\n\t\t\t\t*offset = dn->dn_datablksz;\n\t\t} else {\n\t\t\terror = SET_ERROR(ESRCH);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tmaxlvl = dn->dn_phys->dn_nlevels;\n\n\tfor (lvl = minlvl; lvl <= maxlvl; lvl++) {\n\t\terror = dnode_next_offset_level(dn,\n\t\t    flags, offset, lvl, blkfill, txg);\n\t\tif (error != ESRCH)\n\t\t\tbreak;\n\t}\n\n\twhile (error == 0 && --lvl >= minlvl) {\n\t\terror = dnode_next_offset_level(dn,\n\t\t    flags, offset, lvl, blkfill, txg);\n\t}\n\n\t \n\tif ((flags & DNODE_FIND_HOLE) && error == ESRCH && txg == 0 &&\n\t    minlvl == 1 && blkfill == 1 && !(flags & DNODE_FIND_BACKWARDS)) {\n\t\terror = 0;\n\t}\n\n\tif (error == 0 && (flags & DNODE_FIND_BACKWARDS ?\n\t    initial_offset < *offset : initial_offset > *offset))\n\t\terror = SET_ERROR(ESRCH);\nout:\n\tif (!(flags & DNODE_FIND_HAVELOCK))\n\t\trw_exit(&dn->dn_struct_rwlock);\n\n\treturn (error);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dnode_hold);\nEXPORT_SYMBOL(dnode_rele);\nEXPORT_SYMBOL(dnode_set_nlevels);\nEXPORT_SYMBOL(dnode_set_blksz);\nEXPORT_SYMBOL(dnode_free_range);\nEXPORT_SYMBOL(dnode_evict_dbufs);\nEXPORT_SYMBOL(dnode_evict_bonus);\n#endif\n\nZFS_MODULE_PARAM(zfs, zfs_, default_bs, INT, ZMOD_RW,\n\t\"Default dnode block shift\");\nZFS_MODULE_PARAM(zfs, zfs_, default_ibs, INT, ZMOD_RW,\n\t\"Default dnode indirect block shift\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}