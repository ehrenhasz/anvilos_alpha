{
  "module_name": "txg.c",
  "hash_id": "c9494745e0f7b7f80a9974ac48a960e7db2b48fbbddfa2d08e3304a69e277cee",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/txg.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/txg_impl.h>\n#include <sys/dmu_impl.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_scan.h>\n#include <sys/zil.h>\n#include <sys/callb.h>\n#include <sys/trace_zfs.h>\n\n \n\nstatic __attribute__((noreturn)) void txg_sync_thread(void *arg);\nstatic __attribute__((noreturn)) void txg_quiesce_thread(void *arg);\n\nuint_t zfs_txg_timeout = 5;\t \n\n \nvoid\ntxg_init(dsl_pool_t *dp, uint64_t txg)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\tint c;\n\tmemset(tx, 0, sizeof (tx_state_t));\n\n\ttx->tx_cpu = vmem_zalloc(max_ncpus * sizeof (tx_cpu_t), KM_SLEEP);\n\n\tfor (c = 0; c < max_ncpus; c++) {\n\t\tint i;\n\n\t\tmutex_init(&tx->tx_cpu[c].tc_lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tmutex_init(&tx->tx_cpu[c].tc_open_lock, NULL, MUTEX_NOLOCKDEP,\n\t\t    NULL);\n\t\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\t\tcv_init(&tx->tx_cpu[c].tc_cv[i], NULL, CV_DEFAULT,\n\t\t\t    NULL);\n\t\t\tlist_create(&tx->tx_cpu[c].tc_callbacks[i],\n\t\t\t    sizeof (dmu_tx_callback_t),\n\t\t\t    offsetof(dmu_tx_callback_t, dcb_node));\n\t\t}\n\t}\n\n\tmutex_init(&tx->tx_sync_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tcv_init(&tx->tx_sync_more_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&tx->tx_sync_done_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&tx->tx_quiesce_more_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&tx->tx_quiesce_done_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&tx->tx_exit_cv, NULL, CV_DEFAULT, NULL);\n\n\ttx->tx_open_txg = txg;\n}\n\n \nvoid\ntxg_fini(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\tint c;\n\n\tASSERT0(tx->tx_threads);\n\n\tmutex_destroy(&tx->tx_sync_lock);\n\n\tcv_destroy(&tx->tx_sync_more_cv);\n\tcv_destroy(&tx->tx_sync_done_cv);\n\tcv_destroy(&tx->tx_quiesce_more_cv);\n\tcv_destroy(&tx->tx_quiesce_done_cv);\n\tcv_destroy(&tx->tx_exit_cv);\n\n\tfor (c = 0; c < max_ncpus; c++) {\n\t\tint i;\n\n\t\tmutex_destroy(&tx->tx_cpu[c].tc_open_lock);\n\t\tmutex_destroy(&tx->tx_cpu[c].tc_lock);\n\t\tfor (i = 0; i < TXG_SIZE; i++) {\n\t\t\tcv_destroy(&tx->tx_cpu[c].tc_cv[i]);\n\t\t\tlist_destroy(&tx->tx_cpu[c].tc_callbacks[i]);\n\t\t}\n\t}\n\n\tif (tx->tx_commit_cb_taskq != NULL)\n\t\ttaskq_destroy(tx->tx_commit_cb_taskq);\n\n\tvmem_free(tx->tx_cpu, max_ncpus * sizeof (tx_cpu_t));\n\n\tmemset(tx, 0, sizeof (tx_state_t));\n}\n\n \nvoid\ntxg_sync_start(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\tmutex_enter(&tx->tx_sync_lock);\n\n\tdprintf(\"pool %p\\n\", dp);\n\n\tASSERT0(tx->tx_threads);\n\n\ttx->tx_threads = 2;\n\n\ttx->tx_quiesce_thread = thread_create(NULL, 0, txg_quiesce_thread,\n\t    dp, 0, &p0, TS_RUN, defclsyspri);\n\n\t \n\ttx->tx_sync_thread = thread_create(NULL, 0, txg_sync_thread,\n\t    dp, 0, &p0, TS_RUN, defclsyspri);\n\n\tmutex_exit(&tx->tx_sync_lock);\n}\n\nstatic void\ntxg_thread_enter(tx_state_t *tx, callb_cpr_t *cpr)\n{\n\tCALLB_CPR_INIT(cpr, &tx->tx_sync_lock, callb_generic_cpr, FTAG);\n\tmutex_enter(&tx->tx_sync_lock);\n}\n\nstatic void\ntxg_thread_exit(tx_state_t *tx, callb_cpr_t *cpr, kthread_t **tpp)\n{\n\tASSERT(*tpp != NULL);\n\t*tpp = NULL;\n\ttx->tx_threads--;\n\tcv_broadcast(&tx->tx_exit_cv);\n\tCALLB_CPR_EXIT(cpr);\t\t \n\tthread_exit();\n}\n\nstatic void\ntxg_thread_wait(tx_state_t *tx, callb_cpr_t *cpr, kcondvar_t *cv, clock_t time)\n{\n\tCALLB_CPR_SAFE_BEGIN(cpr);\n\n\tif (time) {\n\t\t(void) cv_timedwait_idle(cv, &tx->tx_sync_lock,\n\t\t    ddi_get_lbolt() + time);\n\t} else {\n\t\tcv_wait_idle(cv, &tx->tx_sync_lock);\n\t}\n\n\tCALLB_CPR_SAFE_END(cpr, &tx->tx_sync_lock);\n}\n\n \nvoid\ntxg_sync_stop(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\tdprintf(\"pool %p\\n\", dp);\n\t \n\tASSERT3U(tx->tx_threads, ==, 2);\n\n\t \n\ttxg_wait_synced(dp, tx->tx_open_txg + TXG_DEFER_SIZE);\n\n\t \n\tmutex_enter(&tx->tx_sync_lock);\n\n\tASSERT3U(tx->tx_threads, ==, 2);\n\n\ttx->tx_exiting = 1;\n\n\tcv_broadcast(&tx->tx_quiesce_more_cv);\n\tcv_broadcast(&tx->tx_quiesce_done_cv);\n\tcv_broadcast(&tx->tx_sync_more_cv);\n\n\twhile (tx->tx_threads != 0)\n\t\tcv_wait(&tx->tx_exit_cv, &tx->tx_sync_lock);\n\n\ttx->tx_exiting = 0;\n\n\tmutex_exit(&tx->tx_sync_lock);\n}\n\n \nuint64_t\ntxg_hold_open(dsl_pool_t *dp, txg_handle_t *th)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\ttx_cpu_t *tc;\n\tuint64_t txg;\n\n\t \n\ttc = &tx->tx_cpu[CPU_SEQID_UNSTABLE];\n\n\tmutex_enter(&tc->tc_open_lock);\n\ttxg = tx->tx_open_txg;\n\n\tmutex_enter(&tc->tc_lock);\n\ttc->tc_count[txg & TXG_MASK]++;\n\tmutex_exit(&tc->tc_lock);\n\n\tth->th_cpu = tc;\n\tth->th_txg = txg;\n\n\treturn (txg);\n}\n\nvoid\ntxg_rele_to_quiesce(txg_handle_t *th)\n{\n\ttx_cpu_t *tc = th->th_cpu;\n\n\tASSERT(!MUTEX_HELD(&tc->tc_lock));\n\tmutex_exit(&tc->tc_open_lock);\n}\n\nvoid\ntxg_register_callbacks(txg_handle_t *th, list_t *tx_callbacks)\n{\n\ttx_cpu_t *tc = th->th_cpu;\n\tint g = th->th_txg & TXG_MASK;\n\n\tmutex_enter(&tc->tc_lock);\n\tlist_move_tail(&tc->tc_callbacks[g], tx_callbacks);\n\tmutex_exit(&tc->tc_lock);\n}\n\nvoid\ntxg_rele_to_sync(txg_handle_t *th)\n{\n\ttx_cpu_t *tc = th->th_cpu;\n\tint g = th->th_txg & TXG_MASK;\n\n\tmutex_enter(&tc->tc_lock);\n\tASSERT(tc->tc_count[g] != 0);\n\tif (--tc->tc_count[g] == 0)\n\t\tcv_broadcast(&tc->tc_cv[g]);\n\tmutex_exit(&tc->tc_lock);\n\n\tth->th_cpu = NULL;\t \n}\n\n \nstatic void\ntxg_quiesce(dsl_pool_t *dp, uint64_t txg)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\tuint64_t tx_open_time;\n\tint g = txg & TXG_MASK;\n\tint c;\n\n\t \n\tfor (c = 0; c < max_ncpus; c++)\n\t\tmutex_enter(&tx->tx_cpu[c].tc_open_lock);\n\n\tASSERT(txg == tx->tx_open_txg);\n\ttx->tx_open_txg++;\n\ttx->tx_open_time = tx_open_time = gethrtime();\n\n\tDTRACE_PROBE2(txg__quiescing, dsl_pool_t *, dp, uint64_t, txg);\n\tDTRACE_PROBE2(txg__opened, dsl_pool_t *, dp, uint64_t, tx->tx_open_txg);\n\n\t \n\tfor (c = 0; c < max_ncpus; c++)\n\t\tmutex_exit(&tx->tx_cpu[c].tc_open_lock);\n\n\tspa_txg_history_set(dp->dp_spa, txg, TXG_STATE_OPEN, tx_open_time);\n\tspa_txg_history_add(dp->dp_spa, txg + 1, tx_open_time);\n\n\t \n\tfor (c = 0; c < max_ncpus; c++) {\n\t\ttx_cpu_t *tc = &tx->tx_cpu[c];\n\t\tmutex_enter(&tc->tc_lock);\n\t\twhile (tc->tc_count[g] != 0)\n\t\t\tcv_wait(&tc->tc_cv[g], &tc->tc_lock);\n\t\tmutex_exit(&tc->tc_lock);\n\t}\n\n\tspa_txg_history_set(dp->dp_spa, txg, TXG_STATE_QUIESCED, gethrtime());\n}\n\nstatic void\ntxg_do_callbacks(void *cb_list)\n{\n\tdmu_tx_do_callbacks(cb_list, 0);\n\n\tlist_destroy(cb_list);\n\n\tkmem_free(cb_list, sizeof (list_t));\n}\n\n \nstatic void\ntxg_dispatch_callbacks(dsl_pool_t *dp, uint64_t txg)\n{\n\tint c;\n\ttx_state_t *tx = &dp->dp_tx;\n\tlist_t *cb_list;\n\n\tfor (c = 0; c < max_ncpus; c++) {\n\t\ttx_cpu_t *tc = &tx->tx_cpu[c];\n\t\t \n\n\t\tint g = txg & TXG_MASK;\n\n\t\tif (list_is_empty(&tc->tc_callbacks[g]))\n\t\t\tcontinue;\n\n\t\tif (tx->tx_commit_cb_taskq == NULL) {\n\t\t\t \n\t\t\ttx->tx_commit_cb_taskq = taskq_create(\"tx_commit_cb\",\n\t\t\t    100, defclsyspri, boot_ncpus, boot_ncpus * 2,\n\t\t\t    TASKQ_PREPOPULATE | TASKQ_DYNAMIC |\n\t\t\t    TASKQ_THREADS_CPU_PCT);\n\t\t}\n\n\t\tcb_list = kmem_alloc(sizeof (list_t), KM_SLEEP);\n\t\tlist_create(cb_list, sizeof (dmu_tx_callback_t),\n\t\t    offsetof(dmu_tx_callback_t, dcb_node));\n\n\t\tlist_move_tail(cb_list, &tc->tc_callbacks[g]);\n\n\t\t(void) taskq_dispatch(tx->tx_commit_cb_taskq,\n\t\t    txg_do_callbacks, cb_list, TQ_SLEEP);\n\t}\n}\n\n \nvoid\ntxg_wait_callbacks(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\tif (tx->tx_commit_cb_taskq != NULL)\n\t\ttaskq_wait_outstanding(tx->tx_commit_cb_taskq, 0);\n}\n\nstatic boolean_t\ntxg_is_quiescing(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\tASSERT(MUTEX_HELD(&tx->tx_sync_lock));\n\treturn (tx->tx_quiescing_txg != 0);\n}\n\nstatic boolean_t\ntxg_has_quiesced_to_sync(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\tASSERT(MUTEX_HELD(&tx->tx_sync_lock));\n\treturn (tx->tx_quiesced_txg != 0);\n}\n\nstatic __attribute__((noreturn)) void\ntxg_sync_thread(void *arg)\n{\n\tdsl_pool_t *dp = arg;\n\tspa_t *spa = dp->dp_spa;\n\ttx_state_t *tx = &dp->dp_tx;\n\tcallb_cpr_t cpr;\n\tclock_t start, delta;\n\n\t(void) spl_fstrans_mark();\n\ttxg_thread_enter(tx, &cpr);\n\n\tstart = delta = 0;\n\tfor (;;) {\n\t\tclock_t timeout = zfs_txg_timeout * hz;\n\t\tclock_t timer;\n\t\tuint64_t txg;\n\n\t\t \n\t\ttimer = (delta >= timeout ? 0 : timeout - delta);\n\t\twhile (!dsl_scan_active(dp->dp_scan) &&\n\t\t    !tx->tx_exiting && timer > 0 &&\n\t\t    tx->tx_synced_txg >= tx->tx_sync_txg_waiting &&\n\t\t    !txg_has_quiesced_to_sync(dp)) {\n\t\t\tdprintf(\"waiting; tx_synced=%llu waiting=%llu dp=%p\\n\",\n\t\t\t    (u_longlong_t)tx->tx_synced_txg,\n\t\t\t    (u_longlong_t)tx->tx_sync_txg_waiting, dp);\n\t\t\ttxg_thread_wait(tx, &cpr, &tx->tx_sync_more_cv, timer);\n\t\t\tdelta = ddi_get_lbolt() - start;\n\t\t\ttimer = (delta > timeout ? 0 : timeout - delta);\n\t\t}\n\n\t\t \n\t\twhile (!tx->tx_exiting && !txg_has_quiesced_to_sync(dp)) {\n\t\t\tif (txg_is_quiescing(dp)) {\n\t\t\t\ttxg_thread_wait(tx, &cpr,\n\t\t\t\t    &tx->tx_quiesce_done_cv, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tx->tx_quiesce_txg_waiting < tx->tx_open_txg+1)\n\t\t\t\ttx->tx_quiesce_txg_waiting = tx->tx_open_txg+1;\n\t\t\tcv_broadcast(&tx->tx_quiesce_more_cv);\n\t\t\ttxg_thread_wait(tx, &cpr, &tx->tx_quiesce_done_cv, 0);\n\t\t}\n\n\t\tif (tx->tx_exiting)\n\t\t\ttxg_thread_exit(tx, &cpr, &tx->tx_sync_thread);\n\n\t\t \n\t\tASSERT(tx->tx_quiesced_txg != 0);\n\t\ttxg = tx->tx_quiesced_txg;\n\t\ttx->tx_quiesced_txg = 0;\n\t\ttx->tx_syncing_txg = txg;\n\t\tDTRACE_PROBE2(txg__syncing, dsl_pool_t *, dp, uint64_t, txg);\n\t\tcv_broadcast(&tx->tx_quiesce_more_cv);\n\n\t\tdprintf(\"txg=%llu quiesce_txg=%llu sync_txg=%llu\\n\",\n\t\t    (u_longlong_t)txg, (u_longlong_t)tx->tx_quiesce_txg_waiting,\n\t\t    (u_longlong_t)tx->tx_sync_txg_waiting);\n\t\tmutex_exit(&tx->tx_sync_lock);\n\n\t\ttxg_stat_t *ts = spa_txg_history_init_io(spa, txg, dp);\n\t\tstart = ddi_get_lbolt();\n\t\tspa_sync(spa, txg);\n\t\tdelta = ddi_get_lbolt() - start;\n\t\tspa_txg_history_fini_io(spa, ts);\n\n\t\tmutex_enter(&tx->tx_sync_lock);\n\t\ttx->tx_synced_txg = txg;\n\t\ttx->tx_syncing_txg = 0;\n\t\tDTRACE_PROBE2(txg__synced, dsl_pool_t *, dp, uint64_t, txg);\n\t\tcv_broadcast(&tx->tx_sync_done_cv);\n\n\t\t \n\t\ttxg_dispatch_callbacks(dp, txg);\n\t}\n}\n\nstatic __attribute__((noreturn)) void\ntxg_quiesce_thread(void *arg)\n{\n\tdsl_pool_t *dp = arg;\n\ttx_state_t *tx = &dp->dp_tx;\n\tcallb_cpr_t cpr;\n\n\ttxg_thread_enter(tx, &cpr);\n\n\tfor (;;) {\n\t\tuint64_t txg;\n\n\t\t \n\t\twhile (!tx->tx_exiting &&\n\t\t    (tx->tx_open_txg >= tx->tx_quiesce_txg_waiting ||\n\t\t    txg_has_quiesced_to_sync(dp)))\n\t\t\ttxg_thread_wait(tx, &cpr, &tx->tx_quiesce_more_cv, 0);\n\n\t\tif (tx->tx_exiting)\n\t\t\ttxg_thread_exit(tx, &cpr, &tx->tx_quiesce_thread);\n\n\t\ttxg = tx->tx_open_txg;\n\t\tdprintf(\"txg=%llu quiesce_txg=%llu sync_txg=%llu\\n\",\n\t\t    (u_longlong_t)txg,\n\t\t    (u_longlong_t)tx->tx_quiesce_txg_waiting,\n\t\t    (u_longlong_t)tx->tx_sync_txg_waiting);\n\t\ttx->tx_quiescing_txg = txg;\n\n\t\tmutex_exit(&tx->tx_sync_lock);\n\t\ttxg_quiesce(dp, txg);\n\t\tmutex_enter(&tx->tx_sync_lock);\n\n\t\t \n\t\tdprintf(\"quiesce done, handing off txg %llu\\n\",\n\t\t    (u_longlong_t)txg);\n\t\ttx->tx_quiescing_txg = 0;\n\t\ttx->tx_quiesced_txg = txg;\n\t\tDTRACE_PROBE2(txg__quiesced, dsl_pool_t *, dp, uint64_t, txg);\n\t\tcv_broadcast(&tx->tx_sync_more_cv);\n\t\tcv_broadcast(&tx->tx_quiesce_done_cv);\n\t}\n}\n\n \nvoid\ntxg_delay(dsl_pool_t *dp, uint64_t txg, hrtime_t delay, hrtime_t resolution)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\thrtime_t start = gethrtime();\n\n\t \n\tif (tx->tx_open_txg > txg ||\n\t    tx->tx_syncing_txg == txg-1 || tx->tx_synced_txg == txg-1)\n\t\treturn;\n\n\tmutex_enter(&tx->tx_sync_lock);\n\tif (tx->tx_open_txg > txg || tx->tx_synced_txg == txg-1) {\n\t\tmutex_exit(&tx->tx_sync_lock);\n\t\treturn;\n\t}\n\n\twhile (gethrtime() - start < delay &&\n\t    tx->tx_syncing_txg < txg-1 && !txg_stalled(dp)) {\n\t\t(void) cv_timedwait_hires(&tx->tx_quiesce_more_cv,\n\t\t    &tx->tx_sync_lock, delay, resolution, 0);\n\t}\n\n\tDMU_TX_STAT_BUMP(dmu_tx_delay);\n\n\tmutex_exit(&tx->tx_sync_lock);\n}\n\nstatic boolean_t\ntxg_wait_synced_impl(dsl_pool_t *dp, uint64_t txg, boolean_t wait_sig)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\tASSERT(!dsl_pool_config_held(dp));\n\n\tmutex_enter(&tx->tx_sync_lock);\n\tASSERT3U(tx->tx_threads, ==, 2);\n\tif (txg == 0)\n\t\ttxg = tx->tx_open_txg + TXG_DEFER_SIZE;\n\tif (tx->tx_sync_txg_waiting < txg)\n\t\ttx->tx_sync_txg_waiting = txg;\n\tdprintf(\"txg=%llu quiesce_txg=%llu sync_txg=%llu\\n\",\n\t    (u_longlong_t)txg, (u_longlong_t)tx->tx_quiesce_txg_waiting,\n\t    (u_longlong_t)tx->tx_sync_txg_waiting);\n\twhile (tx->tx_synced_txg < txg) {\n\t\tdprintf(\"broadcasting sync more \"\n\t\t    \"tx_synced=%llu waiting=%llu dp=%px\\n\",\n\t\t    (u_longlong_t)tx->tx_synced_txg,\n\t\t    (u_longlong_t)tx->tx_sync_txg_waiting, dp);\n\t\tcv_broadcast(&tx->tx_sync_more_cv);\n\t\tif (wait_sig) {\n\t\t\t \n\t\t\tif (cv_wait_io_sig(&tx->tx_sync_done_cv,\n\t\t\t    &tx->tx_sync_lock) == 0) {\n\t\t\t\tmutex_exit(&tx->tx_sync_lock);\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t} else {\n\t\t\tcv_wait_io(&tx->tx_sync_done_cv, &tx->tx_sync_lock);\n\t\t}\n\t}\n\tmutex_exit(&tx->tx_sync_lock);\n\treturn (B_FALSE);\n}\n\nvoid\ntxg_wait_synced(dsl_pool_t *dp, uint64_t txg)\n{\n\tVERIFY0(txg_wait_synced_impl(dp, txg, B_FALSE));\n}\n\n \nboolean_t\ntxg_wait_synced_sig(dsl_pool_t *dp, uint64_t txg)\n{\n\treturn (txg_wait_synced_impl(dp, txg, B_TRUE));\n}\n\n \nvoid\ntxg_wait_open(dsl_pool_t *dp, uint64_t txg, boolean_t should_quiesce)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\tASSERT(!dsl_pool_config_held(dp));\n\n\tmutex_enter(&tx->tx_sync_lock);\n\tASSERT3U(tx->tx_threads, ==, 2);\n\tif (txg == 0)\n\t\ttxg = tx->tx_open_txg + 1;\n\tif (tx->tx_quiesce_txg_waiting < txg && should_quiesce)\n\t\ttx->tx_quiesce_txg_waiting = txg;\n\tdprintf(\"txg=%llu quiesce_txg=%llu sync_txg=%llu\\n\",\n\t    (u_longlong_t)txg, (u_longlong_t)tx->tx_quiesce_txg_waiting,\n\t    (u_longlong_t)tx->tx_sync_txg_waiting);\n\twhile (tx->tx_open_txg < txg) {\n\t\tcv_broadcast(&tx->tx_quiesce_more_cv);\n\t\t \n\t\tif (should_quiesce == B_TRUE) {\n\t\t\tcv_wait_io(&tx->tx_quiesce_done_cv, &tx->tx_sync_lock);\n\t\t} else {\n\t\t\tcv_wait_idle(&tx->tx_quiesce_done_cv,\n\t\t\t    &tx->tx_sync_lock);\n\t\t}\n\t}\n\tmutex_exit(&tx->tx_sync_lock);\n}\n\n \nvoid\ntxg_kick(dsl_pool_t *dp, uint64_t txg)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\tASSERT(!dsl_pool_config_held(dp));\n\n\tif (tx->tx_sync_txg_waiting >= txg)\n\t\treturn;\n\n\tmutex_enter(&tx->tx_sync_lock);\n\tif (tx->tx_sync_txg_waiting < txg) {\n\t\ttx->tx_sync_txg_waiting = txg;\n\t\tcv_broadcast(&tx->tx_sync_more_cv);\n\t}\n\tmutex_exit(&tx->tx_sync_lock);\n}\n\nboolean_t\ntxg_stalled(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\treturn (tx->tx_quiesce_txg_waiting > tx->tx_open_txg);\n}\n\nboolean_t\ntxg_sync_waiting(dsl_pool_t *dp)\n{\n\ttx_state_t *tx = &dp->dp_tx;\n\n\treturn (tx->tx_syncing_txg <= tx->tx_sync_txg_waiting ||\n\t    tx->tx_quiesced_txg != 0);\n}\n\n \n#ifdef ZFS_DEBUG\nvoid\ntxg_verify(spa_t *spa, uint64_t txg)\n{\n\tdsl_pool_t *dp __maybe_unused = spa_get_dsl(spa);\n\tif (txg <= TXG_INITIAL || txg == ZILTEST_TXG)\n\t\treturn;\n\tASSERT3U(txg, <=, dp->dp_tx.tx_open_txg);\n\tASSERT3U(txg, >=, dp->dp_tx.tx_synced_txg);\n\tASSERT3U(txg, >=, dp->dp_tx.tx_open_txg - TXG_CONCURRENT_STATES);\n}\n#endif\n\n \nvoid\ntxg_list_create(txg_list_t *tl, spa_t *spa, size_t offset)\n{\n\tint t;\n\n\tmutex_init(&tl->tl_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\ttl->tl_offset = offset;\n\ttl->tl_spa = spa;\n\n\tfor (t = 0; t < TXG_SIZE; t++)\n\t\ttl->tl_head[t] = NULL;\n}\n\nstatic boolean_t\ntxg_list_empty_impl(txg_list_t *tl, uint64_t txg)\n{\n\tASSERT(MUTEX_HELD(&tl->tl_lock));\n\tTXG_VERIFY(tl->tl_spa, txg);\n\treturn (tl->tl_head[txg & TXG_MASK] == NULL);\n}\n\nboolean_t\ntxg_list_empty(txg_list_t *tl, uint64_t txg)\n{\n\tmutex_enter(&tl->tl_lock);\n\tboolean_t ret = txg_list_empty_impl(tl, txg);\n\tmutex_exit(&tl->tl_lock);\n\n\treturn (ret);\n}\n\nvoid\ntxg_list_destroy(txg_list_t *tl)\n{\n\tint t;\n\n\tmutex_enter(&tl->tl_lock);\n\tfor (t = 0; t < TXG_SIZE; t++)\n\t\tASSERT(txg_list_empty_impl(tl, t));\n\tmutex_exit(&tl->tl_lock);\n\n\tmutex_destroy(&tl->tl_lock);\n}\n\n \nboolean_t\ntxg_all_lists_empty(txg_list_t *tl)\n{\n\tboolean_t res = B_TRUE;\n\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\tres &= (tl->tl_head[i] == NULL);\n\treturn (res);\n}\n\n \nboolean_t\ntxg_list_add(txg_list_t *tl, void *p, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn = (txg_node_t *)((char *)p + tl->tl_offset);\n\tboolean_t add;\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\tmutex_enter(&tl->tl_lock);\n\tadd = (tn->tn_member[t] == 0);\n\tif (add) {\n\t\ttn->tn_member[t] = 1;\n\t\ttn->tn_next[t] = tl->tl_head[t];\n\t\ttl->tl_head[t] = tn;\n\t}\n\tmutex_exit(&tl->tl_lock);\n\n\treturn (add);\n}\n\n \nboolean_t\ntxg_list_add_tail(txg_list_t *tl, void *p, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn = (txg_node_t *)((char *)p + tl->tl_offset);\n\tboolean_t add;\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\tmutex_enter(&tl->tl_lock);\n\tadd = (tn->tn_member[t] == 0);\n\tif (add) {\n\t\ttxg_node_t **tp;\n\n\t\tfor (tp = &tl->tl_head[t]; *tp != NULL; tp = &(*tp)->tn_next[t])\n\t\t\tcontinue;\n\n\t\ttn->tn_member[t] = 1;\n\t\ttn->tn_next[t] = NULL;\n\t\t*tp = tn;\n\t}\n\tmutex_exit(&tl->tl_lock);\n\n\treturn (add);\n}\n\n \nvoid *\ntxg_list_remove(txg_list_t *tl, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn;\n\tvoid *p = NULL;\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\tmutex_enter(&tl->tl_lock);\n\tif ((tn = tl->tl_head[t]) != NULL) {\n\t\tASSERT(tn->tn_member[t]);\n\t\tASSERT(tn->tn_next[t] == NULL || tn->tn_next[t]->tn_member[t]);\n\t\tp = (char *)tn - tl->tl_offset;\n\t\ttl->tl_head[t] = tn->tn_next[t];\n\t\ttn->tn_next[t] = NULL;\n\t\ttn->tn_member[t] = 0;\n\t}\n\tmutex_exit(&tl->tl_lock);\n\n\treturn (p);\n}\n\n \nvoid *\ntxg_list_remove_this(txg_list_t *tl, void *p, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn, **tp;\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\tmutex_enter(&tl->tl_lock);\n\n\tfor (tp = &tl->tl_head[t]; (tn = *tp) != NULL; tp = &tn->tn_next[t]) {\n\t\tif ((char *)tn - tl->tl_offset == p) {\n\t\t\t*tp = tn->tn_next[t];\n\t\t\ttn->tn_next[t] = NULL;\n\t\t\ttn->tn_member[t] = 0;\n\t\t\tmutex_exit(&tl->tl_lock);\n\t\t\treturn (p);\n\t\t}\n\t}\n\n\tmutex_exit(&tl->tl_lock);\n\n\treturn (NULL);\n}\n\nboolean_t\ntxg_list_member(txg_list_t *tl, void *p, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn = (txg_node_t *)((char *)p + tl->tl_offset);\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\treturn (tn->tn_member[t] != 0);\n}\n\n \nvoid *\ntxg_list_head(txg_list_t *tl, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn;\n\n\tmutex_enter(&tl->tl_lock);\n\ttn = tl->tl_head[t];\n\tmutex_exit(&tl->tl_lock);\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\treturn (tn == NULL ? NULL : (char *)tn - tl->tl_offset);\n}\n\nvoid *\ntxg_list_next(txg_list_t *tl, void *p, uint64_t txg)\n{\n\tint t = txg & TXG_MASK;\n\ttxg_node_t *tn = (txg_node_t *)((char *)p + tl->tl_offset);\n\n\tTXG_VERIFY(tl->tl_spa, txg);\n\n\tmutex_enter(&tl->tl_lock);\n\ttn = tn->tn_next[t];\n\tmutex_exit(&tl->tl_lock);\n\n\treturn (tn == NULL ? NULL : (char *)tn - tl->tl_offset);\n}\n\nEXPORT_SYMBOL(txg_init);\nEXPORT_SYMBOL(txg_fini);\nEXPORT_SYMBOL(txg_sync_start);\nEXPORT_SYMBOL(txg_sync_stop);\nEXPORT_SYMBOL(txg_hold_open);\nEXPORT_SYMBOL(txg_rele_to_quiesce);\nEXPORT_SYMBOL(txg_rele_to_sync);\nEXPORT_SYMBOL(txg_register_callbacks);\nEXPORT_SYMBOL(txg_delay);\nEXPORT_SYMBOL(txg_wait_synced);\nEXPORT_SYMBOL(txg_wait_open);\nEXPORT_SYMBOL(txg_wait_callbacks);\nEXPORT_SYMBOL(txg_stalled);\nEXPORT_SYMBOL(txg_sync_waiting);\n\nZFS_MODULE_PARAM(zfs_txg, zfs_txg_, timeout, UINT, ZMOD_RW,\n\t\"Max seconds worth of delta per txg\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}