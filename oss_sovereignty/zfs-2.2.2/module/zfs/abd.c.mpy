{
  "module_name": "abd.c",
  "hash_id": "acaa51a270b4610876ce1eab2c0be507214e607f6a2eac932a988e4288a536e0",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/abd.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/abd_impl.h>\n#include <sys/param.h>\n#include <sys/zio.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_znode.h>\n\n \nint zfs_abd_scatter_enabled = B_TRUE;\n\nvoid\nabd_verify(abd_t *abd)\n{\n#ifdef ZFS_DEBUG\n\tASSERT3U(abd->abd_size, <=, SPA_MAXBLOCKSIZE);\n\tASSERT3U(abd->abd_flags, ==, abd->abd_flags & (ABD_FLAG_LINEAR |\n\t    ABD_FLAG_OWNER | ABD_FLAG_META | ABD_FLAG_MULTI_ZONE |\n\t    ABD_FLAG_MULTI_CHUNK | ABD_FLAG_LINEAR_PAGE | ABD_FLAG_GANG |\n\t    ABD_FLAG_GANG_FREE | ABD_FLAG_ZEROS | ABD_FLAG_ALLOCD));\n\tIMPLY(abd->abd_parent != NULL, !(abd->abd_flags & ABD_FLAG_OWNER));\n\tIMPLY(abd->abd_flags & ABD_FLAG_META, abd->abd_flags & ABD_FLAG_OWNER);\n\tif (abd_is_linear(abd)) {\n\t\tASSERT3U(abd->abd_size, >, 0);\n\t\tASSERT3P(ABD_LINEAR_BUF(abd), !=, NULL);\n\t} else if (abd_is_gang(abd)) {\n\t\tuint_t child_sizes = 0;\n\t\tfor (abd_t *cabd = list_head(&ABD_GANG(abd).abd_gang_chain);\n\t\t    cabd != NULL;\n\t\t    cabd = list_next(&ABD_GANG(abd).abd_gang_chain, cabd)) {\n\t\t\tASSERT(list_link_active(&cabd->abd_gang_link));\n\t\t\tchild_sizes += cabd->abd_size;\n\t\t\tabd_verify(cabd);\n\t\t}\n\t\tASSERT3U(abd->abd_size, ==, child_sizes);\n\t} else {\n\t\tASSERT3U(abd->abd_size, >, 0);\n\t\tabd_verify_scatter(abd);\n\t}\n#endif\n}\n\nstatic void\nabd_init_struct(abd_t *abd)\n{\n\tlist_link_init(&abd->abd_gang_link);\n\tmutex_init(&abd->abd_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tabd->abd_flags = 0;\n#ifdef ZFS_DEBUG\n\tzfs_refcount_create(&abd->abd_children);\n\tabd->abd_parent = NULL;\n#endif\n\tabd->abd_size = 0;\n}\n\nstatic void\nabd_fini_struct(abd_t *abd)\n{\n\tmutex_destroy(&abd->abd_mtx);\n\tASSERT(!list_link_active(&abd->abd_gang_link));\n#ifdef ZFS_DEBUG\n\tzfs_refcount_destroy(&abd->abd_children);\n#endif\n}\n\nabd_t *\nabd_alloc_struct(size_t size)\n{\n\tabd_t *abd = abd_alloc_struct_impl(size);\n\tabd_init_struct(abd);\n\tabd->abd_flags |= ABD_FLAG_ALLOCD;\n\treturn (abd);\n}\n\nvoid\nabd_free_struct(abd_t *abd)\n{\n\tabd_fini_struct(abd);\n\tabd_free_struct_impl(abd);\n}\n\n \nabd_t *\nabd_alloc(size_t size, boolean_t is_metadata)\n{\n\tif (abd_size_alloc_linear(size))\n\t\treturn (abd_alloc_linear(size, is_metadata));\n\n\tVERIFY3U(size, <=, SPA_MAXBLOCKSIZE);\n\n\tabd_t *abd = abd_alloc_struct(size);\n\tabd->abd_flags |= ABD_FLAG_OWNER;\n\tabd->abd_u.abd_scatter.abd_offset = 0;\n\tabd_alloc_chunks(abd, size);\n\n\tif (is_metadata) {\n\t\tabd->abd_flags |= ABD_FLAG_META;\n\t}\n\tabd->abd_size = size;\n\n\tabd_update_scatter_stats(abd, ABDSTAT_INCR);\n\n\treturn (abd);\n}\n\n \nabd_t *\nabd_alloc_linear(size_t size, boolean_t is_metadata)\n{\n\tabd_t *abd = abd_alloc_struct(0);\n\n\tVERIFY3U(size, <=, SPA_MAXBLOCKSIZE);\n\n\tabd->abd_flags |= ABD_FLAG_LINEAR | ABD_FLAG_OWNER;\n\tif (is_metadata) {\n\t\tabd->abd_flags |= ABD_FLAG_META;\n\t}\n\tabd->abd_size = size;\n\n\tif (is_metadata) {\n\t\tABD_LINEAR_BUF(abd) = zio_buf_alloc(size);\n\t} else {\n\t\tABD_LINEAR_BUF(abd) = zio_data_buf_alloc(size);\n\t}\n\n\tabd_update_linear_stats(abd, ABDSTAT_INCR);\n\n\treturn (abd);\n}\n\nstatic void\nabd_free_linear(abd_t *abd)\n{\n\tif (abd_is_linear_page(abd)) {\n\t\tabd_free_linear_page(abd);\n\t\treturn;\n\t}\n\tif (abd->abd_flags & ABD_FLAG_META) {\n\t\tzio_buf_free(ABD_LINEAR_BUF(abd), abd->abd_size);\n\t} else {\n\t\tzio_data_buf_free(ABD_LINEAR_BUF(abd), abd->abd_size);\n\t}\n\n\tabd_update_linear_stats(abd, ABDSTAT_DECR);\n}\n\nstatic void\nabd_free_gang(abd_t *abd)\n{\n\tASSERT(abd_is_gang(abd));\n\tabd_t *cabd;\n\n\twhile ((cabd = list_head(&ABD_GANG(abd).abd_gang_chain)) != NULL) {\n\t\t \n\t\tmutex_enter(&cabd->abd_mtx);\n\t\tASSERT(list_link_active(&cabd->abd_gang_link));\n\t\tlist_remove(&ABD_GANG(abd).abd_gang_chain, cabd);\n\t\tmutex_exit(&cabd->abd_mtx);\n\t\tif (cabd->abd_flags & ABD_FLAG_GANG_FREE)\n\t\t\tabd_free(cabd);\n\t}\n\tlist_destroy(&ABD_GANG(abd).abd_gang_chain);\n}\n\nstatic void\nabd_free_scatter(abd_t *abd)\n{\n\tabd_free_chunks(abd);\n\tabd_update_scatter_stats(abd, ABDSTAT_DECR);\n}\n\n \nvoid\nabd_free(abd_t *abd)\n{\n\tif (abd == NULL)\n\t\treturn;\n\n\tabd_verify(abd);\n#ifdef ZFS_DEBUG\n\tIMPLY(abd->abd_flags & ABD_FLAG_OWNER, abd->abd_parent == NULL);\n#endif\n\n\tif (abd_is_gang(abd)) {\n\t\tabd_free_gang(abd);\n\t} else if (abd_is_linear(abd)) {\n\t\tif (abd->abd_flags & ABD_FLAG_OWNER)\n\t\t\tabd_free_linear(abd);\n\t} else {\n\t\tif (abd->abd_flags & ABD_FLAG_OWNER)\n\t\t\tabd_free_scatter(abd);\n\t}\n\n#ifdef ZFS_DEBUG\n\tif (abd->abd_parent != NULL) {\n\t\t(void) zfs_refcount_remove_many(&abd->abd_parent->abd_children,\n\t\t    abd->abd_size, abd);\n\t}\n#endif\n\n\tabd_fini_struct(abd);\n\tif (abd->abd_flags & ABD_FLAG_ALLOCD)\n\t\tabd_free_struct_impl(abd);\n}\n\n \nabd_t *\nabd_alloc_sametype(abd_t *sabd, size_t size)\n{\n\tboolean_t is_metadata = (sabd->abd_flags & ABD_FLAG_META) != 0;\n\tif (abd_is_linear(sabd) &&\n\t    !abd_is_linear_page(sabd)) {\n\t\treturn (abd_alloc_linear(size, is_metadata));\n\t} else {\n\t\treturn (abd_alloc(size, is_metadata));\n\t}\n}\n\n \nabd_t *\nabd_alloc_gang(void)\n{\n\tabd_t *abd = abd_alloc_struct(0);\n\tabd->abd_flags |= ABD_FLAG_GANG | ABD_FLAG_OWNER;\n\tlist_create(&ABD_GANG(abd).abd_gang_chain,\n\t    sizeof (abd_t), offsetof(abd_t, abd_gang_link));\n\treturn (abd);\n}\n\n \nstatic void\nabd_gang_add_gang(abd_t *pabd, abd_t *cabd, boolean_t free_on_free)\n{\n\tASSERT(abd_is_gang(pabd));\n\tASSERT(abd_is_gang(cabd));\n\n\tif (free_on_free) {\n\t\t \n#ifdef ZFS_DEBUG\n\t\t \n\t\tif (cabd->abd_parent != NULL) {\n\t\t\t(void) zfs_refcount_remove_many(\n\t\t\t    &cabd->abd_parent->abd_children,\n\t\t\t    cabd->abd_size, cabd);\n\t\t\tcabd->abd_parent = NULL;\n\t\t}\n#endif\n\t\tpabd->abd_size += cabd->abd_size;\n\t\tcabd->abd_size = 0;\n\t\tlist_move_tail(&ABD_GANG(pabd).abd_gang_chain,\n\t\t    &ABD_GANG(cabd).abd_gang_chain);\n\t\tASSERT(list_is_empty(&ABD_GANG(cabd).abd_gang_chain));\n\t\tabd_verify(pabd);\n\t\tabd_free(cabd);\n\t} else {\n\t\tfor (abd_t *child = list_head(&ABD_GANG(cabd).abd_gang_chain);\n\t\t    child != NULL;\n\t\t    child = list_next(&ABD_GANG(cabd).abd_gang_chain, child)) {\n\t\t\t \n\t\t\tabd_gang_add(pabd, child, B_FALSE);\n\t\t}\n\t\tabd_verify(pabd);\n\t}\n}\n\n \nvoid\nabd_gang_add(abd_t *pabd, abd_t *cabd, boolean_t free_on_free)\n{\n\tASSERT(abd_is_gang(pabd));\n\tabd_t *child_abd = NULL;\n\n\t \n\tif (abd_is_gang(cabd)) {\n\t\tASSERT(!list_link_active(&cabd->abd_gang_link));\n\t\treturn (abd_gang_add_gang(pabd, cabd, free_on_free));\n\t}\n\tASSERT(!abd_is_gang(cabd));\n\n\t \n\tmutex_enter(&cabd->abd_mtx);\n\tif (list_link_active(&cabd->abd_gang_link)) {\n\t\t \n\t\tASSERT3B(free_on_free, ==, B_FALSE);\n\t\tchild_abd = abd_get_offset(cabd, 0);\n\t\tchild_abd->abd_flags |= ABD_FLAG_GANG_FREE;\n\t} else {\n\t\tchild_abd = cabd;\n\t\tif (free_on_free)\n\t\t\tchild_abd->abd_flags |= ABD_FLAG_GANG_FREE;\n\t}\n\tASSERT3P(child_abd, !=, NULL);\n\n\tlist_insert_tail(&ABD_GANG(pabd).abd_gang_chain, child_abd);\n\tmutex_exit(&cabd->abd_mtx);\n\tpabd->abd_size += child_abd->abd_size;\n}\n\n \nabd_t *\nabd_gang_get_offset(abd_t *abd, size_t *off)\n{\n\tabd_t *cabd;\n\n\tASSERT(abd_is_gang(abd));\n\tASSERT3U(*off, <, abd->abd_size);\n\tfor (cabd = list_head(&ABD_GANG(abd).abd_gang_chain); cabd != NULL;\n\t    cabd = list_next(&ABD_GANG(abd).abd_gang_chain, cabd)) {\n\t\tif (*off >= cabd->abd_size)\n\t\t\t*off -= cabd->abd_size;\n\t\telse\n\t\t\treturn (cabd);\n\t}\n\tVERIFY3P(cabd, !=, NULL);\n\treturn (cabd);\n}\n\n \nstatic abd_t *\nabd_get_offset_impl(abd_t *abd, abd_t *sabd, size_t off, size_t size)\n{\n\tabd_verify(sabd);\n\tASSERT3U(off + size, <=, sabd->abd_size);\n\n\tif (abd_is_linear(sabd)) {\n\t\tif (abd == NULL)\n\t\t\tabd = abd_alloc_struct(0);\n\t\t \n\t\tabd->abd_flags |= ABD_FLAG_LINEAR;\n\n\t\tABD_LINEAR_BUF(abd) = (char *)ABD_LINEAR_BUF(sabd) + off;\n\t} else if (abd_is_gang(sabd)) {\n\t\tsize_t left = size;\n\t\tif (abd == NULL) {\n\t\t\tabd = abd_alloc_gang();\n\t\t} else {\n\t\t\tabd->abd_flags |= ABD_FLAG_GANG;\n\t\t\tlist_create(&ABD_GANG(abd).abd_gang_chain,\n\t\t\t    sizeof (abd_t), offsetof(abd_t, abd_gang_link));\n\t\t}\n\n\t\tabd->abd_flags &= ~ABD_FLAG_OWNER;\n\t\tfor (abd_t *cabd = abd_gang_get_offset(sabd, &off);\n\t\t    cabd != NULL && left > 0;\n\t\t    cabd = list_next(&ABD_GANG(sabd).abd_gang_chain, cabd)) {\n\t\t\tint csize = MIN(left, cabd->abd_size - off);\n\n\t\t\tabd_t *nabd = abd_get_offset_size(cabd, off, csize);\n\t\t\tabd_gang_add(abd, nabd, B_TRUE);\n\t\t\tleft -= csize;\n\t\t\toff = 0;\n\t\t}\n\t\tASSERT3U(left, ==, 0);\n\t} else {\n\t\tabd = abd_get_offset_scatter(abd, sabd, off, size);\n\t}\n\n\tASSERT3P(abd, !=, NULL);\n\tabd->abd_size = size;\n#ifdef ZFS_DEBUG\n\tabd->abd_parent = sabd;\n\t(void) zfs_refcount_add_many(&sabd->abd_children, abd->abd_size, abd);\n#endif\n\treturn (abd);\n}\n\n \nabd_t *\nabd_get_offset_struct(abd_t *abd, abd_t *sabd, size_t off, size_t size)\n{\n\tabd_t *result;\n\tabd_init_struct(abd);\n\tresult = abd_get_offset_impl(abd, sabd, off, size);\n\tif (result != abd)\n\t\tabd_fini_struct(abd);\n\treturn (result);\n}\n\nabd_t *\nabd_get_offset(abd_t *sabd, size_t off)\n{\n\tsize_t size = sabd->abd_size > off ? sabd->abd_size - off : 0;\n\tVERIFY3U(size, >, 0);\n\treturn (abd_get_offset_impl(NULL, sabd, off, size));\n}\n\nabd_t *\nabd_get_offset_size(abd_t *sabd, size_t off, size_t size)\n{\n\tASSERT3U(off + size, <=, sabd->abd_size);\n\treturn (abd_get_offset_impl(NULL, sabd, off, size));\n}\n\n \nabd_t *\nabd_get_zeros(size_t size)\n{\n\tASSERT3P(abd_zero_scatter, !=, NULL);\n\tASSERT3U(size, <=, SPA_MAXBLOCKSIZE);\n\treturn (abd_get_offset_size(abd_zero_scatter, 0, size));\n}\n\n \nabd_t *\nabd_get_from_buf(void *buf, size_t size)\n{\n\tabd_t *abd = abd_alloc_struct(0);\n\n\tVERIFY3U(size, <=, SPA_MAXBLOCKSIZE);\n\n\t \n\tabd->abd_flags |= ABD_FLAG_LINEAR;\n\tabd->abd_size = size;\n\n\tABD_LINEAR_BUF(abd) = buf;\n\n\treturn (abd);\n}\n\n \nvoid *\nabd_to_buf(abd_t *abd)\n{\n\tASSERT(abd_is_linear(abd));\n\tabd_verify(abd);\n\treturn (ABD_LINEAR_BUF(abd));\n}\n\n \nvoid *\nabd_borrow_buf(abd_t *abd, size_t n)\n{\n\tvoid *buf;\n\tabd_verify(abd);\n\tASSERT3U(abd->abd_size, >=, n);\n\tif (abd_is_linear(abd)) {\n\t\tbuf = abd_to_buf(abd);\n\t} else {\n\t\tbuf = zio_buf_alloc(n);\n\t}\n#ifdef ZFS_DEBUG\n\t(void) zfs_refcount_add_many(&abd->abd_children, n, buf);\n#endif\n\treturn (buf);\n}\n\nvoid *\nabd_borrow_buf_copy(abd_t *abd, size_t n)\n{\n\tvoid *buf = abd_borrow_buf(abd, n);\n\tif (!abd_is_linear(abd)) {\n\t\tabd_copy_to_buf(buf, abd, n);\n\t}\n\treturn (buf);\n}\n\n \nvoid\nabd_return_buf(abd_t *abd, void *buf, size_t n)\n{\n\tabd_verify(abd);\n\tASSERT3U(abd->abd_size, >=, n);\n#ifdef ZFS_DEBUG\n\t(void) zfs_refcount_remove_many(&abd->abd_children, n, buf);\n#endif\n\tif (abd_is_linear(abd)) {\n\t\tASSERT3P(buf, ==, abd_to_buf(abd));\n\t} else {\n\t\tASSERT0(abd_cmp_buf(abd, buf, n));\n\t\tzio_buf_free(buf, n);\n\t}\n}\n\nvoid\nabd_return_buf_copy(abd_t *abd, void *buf, size_t n)\n{\n\tif (!abd_is_linear(abd)) {\n\t\tabd_copy_from_buf(abd, buf, n);\n\t}\n\tabd_return_buf(abd, buf, n);\n}\n\nvoid\nabd_release_ownership_of_buf(abd_t *abd)\n{\n\tASSERT(abd_is_linear(abd));\n\tASSERT(abd->abd_flags & ABD_FLAG_OWNER);\n\n\t \n\tASSERT(!abd_is_linear_page(abd));\n\n\tabd_verify(abd);\n\n\tabd->abd_flags &= ~ABD_FLAG_OWNER;\n\t \n\tabd->abd_flags &= ~ABD_FLAG_META;\n\n\tabd_update_linear_stats(abd, ABDSTAT_DECR);\n}\n\n\n \nvoid\nabd_take_ownership_of_buf(abd_t *abd, boolean_t is_metadata)\n{\n\tASSERT(abd_is_linear(abd));\n\tASSERT(!(abd->abd_flags & ABD_FLAG_OWNER));\n\tabd_verify(abd);\n\n\tabd->abd_flags |= ABD_FLAG_OWNER;\n\tif (is_metadata) {\n\t\tabd->abd_flags |= ABD_FLAG_META;\n\t}\n\n\tabd_update_linear_stats(abd, ABDSTAT_INCR);\n}\n\n \nstatic inline abd_t *\nabd_init_abd_iter(abd_t *abd, struct abd_iter *aiter, size_t off)\n{\n\tabd_t *cabd = NULL;\n\n\tif (abd_is_gang(abd)) {\n\t\tcabd = abd_gang_get_offset(abd, &off);\n\t\tif (cabd) {\n\t\t\tabd_iter_init(aiter, cabd);\n\t\t\tabd_iter_advance(aiter, off);\n\t\t}\n\t} else {\n\t\tabd_iter_init(aiter, abd);\n\t\tabd_iter_advance(aiter, off);\n\t}\n\treturn (cabd);\n}\n\n \nstatic inline abd_t *\nabd_advance_abd_iter(abd_t *abd, abd_t *cabd, struct abd_iter *aiter,\n    size_t len)\n{\n\tabd_iter_advance(aiter, len);\n\tif (abd_is_gang(abd) && abd_iter_at_end(aiter)) {\n\t\tASSERT3P(cabd, !=, NULL);\n\t\tcabd = list_next(&ABD_GANG(abd).abd_gang_chain, cabd);\n\t\tif (cabd) {\n\t\t\tabd_iter_init(aiter, cabd);\n\t\t\tabd_iter_advance(aiter, 0);\n\t\t}\n\t}\n\treturn (cabd);\n}\n\nint\nabd_iterate_func(abd_t *abd, size_t off, size_t size,\n    abd_iter_func_t *func, void *private)\n{\n\tstruct abd_iter aiter;\n\tint ret = 0;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\tabd_verify(abd);\n\tASSERT3U(off + size, <=, abd->abd_size);\n\n\tboolean_t gang = abd_is_gang(abd);\n\tabd_t *c_abd = abd_init_abd_iter(abd, &aiter, off);\n\n\twhile (size > 0) {\n\t\t \n\t\tif (gang && !c_abd)\n\t\t\tbreak;\n\n\t\tabd_iter_map(&aiter);\n\n\t\tsize_t len = MIN(aiter.iter_mapsize, size);\n\t\tASSERT3U(len, >, 0);\n\n\t\tret = func(aiter.iter_mapaddr, len, private);\n\n\t\tabd_iter_unmap(&aiter);\n\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\tsize -= len;\n\t\tc_abd = abd_advance_abd_iter(abd, c_abd, &aiter, len);\n\t}\n\n\treturn (ret);\n}\n\nstruct buf_arg {\n\tvoid *arg_buf;\n};\n\nstatic int\nabd_copy_to_buf_off_cb(void *buf, size_t size, void *private)\n{\n\tstruct buf_arg *ba_ptr = private;\n\n\t(void) memcpy(ba_ptr->arg_buf, buf, size);\n\tba_ptr->arg_buf = (char *)ba_ptr->arg_buf + size;\n\n\treturn (0);\n}\n\n \nvoid\nabd_copy_to_buf_off(void *buf, abd_t *abd, size_t off, size_t size)\n{\n\tstruct buf_arg ba_ptr = { buf };\n\n\t(void) abd_iterate_func(abd, off, size, abd_copy_to_buf_off_cb,\n\t    &ba_ptr);\n}\n\nstatic int\nabd_cmp_buf_off_cb(void *buf, size_t size, void *private)\n{\n\tint ret;\n\tstruct buf_arg *ba_ptr = private;\n\n\tret = memcmp(buf, ba_ptr->arg_buf, size);\n\tba_ptr->arg_buf = (char *)ba_ptr->arg_buf + size;\n\n\treturn (ret);\n}\n\n \nint\nabd_cmp_buf_off(abd_t *abd, const void *buf, size_t off, size_t size)\n{\n\tstruct buf_arg ba_ptr = { (void *) buf };\n\n\treturn (abd_iterate_func(abd, off, size, abd_cmp_buf_off_cb, &ba_ptr));\n}\n\nstatic int\nabd_copy_from_buf_off_cb(void *buf, size_t size, void *private)\n{\n\tstruct buf_arg *ba_ptr = private;\n\n\t(void) memcpy(buf, ba_ptr->arg_buf, size);\n\tba_ptr->arg_buf = (char *)ba_ptr->arg_buf + size;\n\n\treturn (0);\n}\n\n \nvoid\nabd_copy_from_buf_off(abd_t *abd, const void *buf, size_t off, size_t size)\n{\n\tstruct buf_arg ba_ptr = { (void *) buf };\n\n\t(void) abd_iterate_func(abd, off, size, abd_copy_from_buf_off_cb,\n\t    &ba_ptr);\n}\n\nstatic int\nabd_zero_off_cb(void *buf, size_t size, void *private)\n{\n\t(void) private;\n\t(void) memset(buf, 0, size);\n\treturn (0);\n}\n\n \nvoid\nabd_zero_off(abd_t *abd, size_t off, size_t size)\n{\n\t(void) abd_iterate_func(abd, off, size, abd_zero_off_cb, NULL);\n}\n\n \nint\nabd_iterate_func2(abd_t *dabd, abd_t *sabd, size_t doff, size_t soff,\n    size_t size, abd_iter_func2_t *func, void *private)\n{\n\tint ret = 0;\n\tstruct abd_iter daiter, saiter;\n\tboolean_t dabd_is_gang_abd, sabd_is_gang_abd;\n\tabd_t *c_dabd, *c_sabd;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\tabd_verify(dabd);\n\tabd_verify(sabd);\n\n\tASSERT3U(doff + size, <=, dabd->abd_size);\n\tASSERT3U(soff + size, <=, sabd->abd_size);\n\n\tdabd_is_gang_abd = abd_is_gang(dabd);\n\tsabd_is_gang_abd = abd_is_gang(sabd);\n\tc_dabd = abd_init_abd_iter(dabd, &daiter, doff);\n\tc_sabd = abd_init_abd_iter(sabd, &saiter, soff);\n\n\twhile (size > 0) {\n\t\t \n\t\tif ((dabd_is_gang_abd && !c_dabd) ||\n\t\t    (sabd_is_gang_abd && !c_sabd))\n\t\t\tbreak;\n\n\t\tabd_iter_map(&daiter);\n\t\tabd_iter_map(&saiter);\n\n\t\tsize_t dlen = MIN(daiter.iter_mapsize, size);\n\t\tsize_t slen = MIN(saiter.iter_mapsize, size);\n\t\tsize_t len = MIN(dlen, slen);\n\t\tASSERT(dlen > 0 || slen > 0);\n\n\t\tret = func(daiter.iter_mapaddr, saiter.iter_mapaddr, len,\n\t\t    private);\n\n\t\tabd_iter_unmap(&saiter);\n\t\tabd_iter_unmap(&daiter);\n\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\tsize -= len;\n\t\tc_dabd =\n\t\t    abd_advance_abd_iter(dabd, c_dabd, &daiter, len);\n\t\tc_sabd =\n\t\t    abd_advance_abd_iter(sabd, c_sabd, &saiter, len);\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nabd_copy_off_cb(void *dbuf, void *sbuf, size_t size, void *private)\n{\n\t(void) private;\n\t(void) memcpy(dbuf, sbuf, size);\n\treturn (0);\n}\n\n \nvoid\nabd_copy_off(abd_t *dabd, abd_t *sabd, size_t doff, size_t soff, size_t size)\n{\n\t(void) abd_iterate_func2(dabd, sabd, doff, soff, size,\n\t    abd_copy_off_cb, NULL);\n}\n\nstatic int\nabd_cmp_cb(void *bufa, void *bufb, size_t size, void *private)\n{\n\t(void) private;\n\treturn (memcmp(bufa, bufb, size));\n}\n\n \nint\nabd_cmp(abd_t *dabd, abd_t *sabd)\n{\n\tASSERT3U(dabd->abd_size, ==, sabd->abd_size);\n\treturn (abd_iterate_func2(dabd, sabd, 0, 0, dabd->abd_size,\n\t    abd_cmp_cb, NULL));\n}\n\n \nvoid\nabd_raidz_gen_iterate(abd_t **cabds, abd_t *dabd,\n    ssize_t csize, ssize_t dsize, const unsigned parity,\n    void (*func_raidz_gen)(void **, const void *, size_t, size_t))\n{\n\tint i;\n\tssize_t len, dlen;\n\tstruct abd_iter caiters[3];\n\tstruct abd_iter daiter = {0};\n\tvoid *caddrs[3];\n\tunsigned long flags __maybe_unused = 0;\n\tabd_t *c_cabds[3];\n\tabd_t *c_dabd = NULL;\n\tboolean_t cabds_is_gang_abd[3];\n\tboolean_t dabd_is_gang_abd = B_FALSE;\n\n\tASSERT3U(parity, <=, 3);\n\n\tfor (i = 0; i < parity; i++) {\n\t\tcabds_is_gang_abd[i] = abd_is_gang(cabds[i]);\n\t\tc_cabds[i] = abd_init_abd_iter(cabds[i], &caiters[i], 0);\n\t}\n\n\tif (dabd) {\n\t\tdabd_is_gang_abd = abd_is_gang(dabd);\n\t\tc_dabd = abd_init_abd_iter(dabd, &daiter, 0);\n\t}\n\n\tASSERT3S(dsize, >=, 0);\n\n\tabd_enter_critical(flags);\n\twhile (csize > 0) {\n\t\t \n\t\tif (dabd_is_gang_abd && !c_dabd)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < parity; i++) {\n\t\t\t \n\t\t\tif (cabds_is_gang_abd[i] && !c_cabds[i])\n\t\t\t\tbreak;\n\t\t\tabd_iter_map(&caiters[i]);\n\t\t\tcaddrs[i] = caiters[i].iter_mapaddr;\n\t\t}\n\n\t\tlen = csize;\n\n\t\tif (dabd && dsize > 0)\n\t\t\tabd_iter_map(&daiter);\n\n\t\tswitch (parity) {\n\t\t\tcase 3:\n\t\t\t\tlen = MIN(caiters[2].iter_mapsize, len);\n\t\t\t\tzfs_fallthrough;\n\t\t\tcase 2:\n\t\t\t\tlen = MIN(caiters[1].iter_mapsize, len);\n\t\t\t\tzfs_fallthrough;\n\t\t\tcase 1:\n\t\t\t\tlen = MIN(caiters[0].iter_mapsize, len);\n\t\t}\n\n\t\t \n\t\tASSERT3S(len, >, 0);\n\n\t\tif (dabd && dsize > 0) {\n\t\t\t \n\t\t\tlen = MIN(daiter.iter_mapsize, len);\n\t\t\tdlen = len;\n\t\t} else\n\t\t\tdlen = 0;\n\n\t\t \n\t\tASSERT3S(len, >, 0);\n\t\t \n\t\tASSERT3U(((uint64_t)len & 511ULL), ==, 0);\n\n\t\tfunc_raidz_gen(caddrs, daiter.iter_mapaddr, len, dlen);\n\n\t\tfor (i = parity-1; i >= 0; i--) {\n\t\t\tabd_iter_unmap(&caiters[i]);\n\t\t\tc_cabds[i] =\n\t\t\t    abd_advance_abd_iter(cabds[i], c_cabds[i],\n\t\t\t    &caiters[i], len);\n\t\t}\n\n\t\tif (dabd && dsize > 0) {\n\t\t\tabd_iter_unmap(&daiter);\n\t\t\tc_dabd =\n\t\t\t    abd_advance_abd_iter(dabd, c_dabd, &daiter,\n\t\t\t    dlen);\n\t\t\tdsize -= dlen;\n\t\t}\n\n\t\tcsize -= len;\n\n\t\tASSERT3S(dsize, >=, 0);\n\t\tASSERT3S(csize, >=, 0);\n\t}\n\tabd_exit_critical(flags);\n}\n\n \nvoid\nabd_raidz_rec_iterate(abd_t **cabds, abd_t **tabds,\n    ssize_t tsize, const unsigned parity,\n    void (*func_raidz_rec)(void **t, const size_t tsize, void **c,\n    const unsigned *mul),\n    const unsigned *mul)\n{\n\tint i;\n\tssize_t len;\n\tstruct abd_iter citers[3];\n\tstruct abd_iter xiters[3];\n\tvoid *caddrs[3], *xaddrs[3];\n\tunsigned long flags __maybe_unused = 0;\n\tboolean_t cabds_is_gang_abd[3];\n\tboolean_t tabds_is_gang_abd[3];\n\tabd_t *c_cabds[3];\n\tabd_t *c_tabds[3];\n\n\tASSERT3U(parity, <=, 3);\n\n\tfor (i = 0; i < parity; i++) {\n\t\tcabds_is_gang_abd[i] = abd_is_gang(cabds[i]);\n\t\ttabds_is_gang_abd[i] = abd_is_gang(tabds[i]);\n\t\tc_cabds[i] =\n\t\t    abd_init_abd_iter(cabds[i], &citers[i], 0);\n\t\tc_tabds[i] =\n\t\t    abd_init_abd_iter(tabds[i], &xiters[i], 0);\n\t}\n\n\tabd_enter_critical(flags);\n\twhile (tsize > 0) {\n\n\t\tfor (i = 0; i < parity; i++) {\n\t\t\t \n\t\t\tif (cabds_is_gang_abd[i] && !c_cabds[i])\n\t\t\t\tbreak;\n\t\t\tif (tabds_is_gang_abd[i] && !c_tabds[i])\n\t\t\t\tbreak;\n\t\t\tabd_iter_map(&citers[i]);\n\t\t\tabd_iter_map(&xiters[i]);\n\t\t\tcaddrs[i] = citers[i].iter_mapaddr;\n\t\t\txaddrs[i] = xiters[i].iter_mapaddr;\n\t\t}\n\n\t\tlen = tsize;\n\t\tswitch (parity) {\n\t\t\tcase 3:\n\t\t\t\tlen = MIN(xiters[2].iter_mapsize, len);\n\t\t\t\tlen = MIN(citers[2].iter_mapsize, len);\n\t\t\t\tzfs_fallthrough;\n\t\t\tcase 2:\n\t\t\t\tlen = MIN(xiters[1].iter_mapsize, len);\n\t\t\t\tlen = MIN(citers[1].iter_mapsize, len);\n\t\t\t\tzfs_fallthrough;\n\t\t\tcase 1:\n\t\t\t\tlen = MIN(xiters[0].iter_mapsize, len);\n\t\t\t\tlen = MIN(citers[0].iter_mapsize, len);\n\t\t}\n\t\t \n\t\tASSERT3S(len, >, 0);\n\t\t \n\t\tASSERT3U(((uint64_t)len & 511ULL), ==, 0);\n\n\t\tfunc_raidz_rec(xaddrs, len, caddrs, mul);\n\n\t\tfor (i = parity-1; i >= 0; i--) {\n\t\t\tabd_iter_unmap(&xiters[i]);\n\t\t\tabd_iter_unmap(&citers[i]);\n\t\t\tc_tabds[i] =\n\t\t\t    abd_advance_abd_iter(tabds[i], c_tabds[i],\n\t\t\t    &xiters[i], len);\n\t\t\tc_cabds[i] =\n\t\t\t    abd_advance_abd_iter(cabds[i], c_cabds[i],\n\t\t\t    &citers[i], len);\n\t\t}\n\n\t\ttsize -= len;\n\t\tASSERT3S(tsize, >=, 0);\n\t}\n\tabd_exit_critical(flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}