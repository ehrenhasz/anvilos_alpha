{
  "module_name": "zthr.c",
  "hash_id": "25f87e5f91125c54a45bb18671797f05bac2c836b836091e4548db7721ca3a68",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zthr.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/zthr.h>\n\nstruct zthr {\n\t \n\tkthread_t\t*zthr_thread;\n\n\t \n\tkmutex_t\tzthr_state_lock;\n\n\t \n\tkmutex_t\tzthr_request_lock;\n\n\t \n\tkcondvar_t\tzthr_cv;\n\n\t \n\tboolean_t\tzthr_cancel;\n\n\t \n\tboolean_t\tzthr_haswaiters;\n\tkcondvar_t\tzthr_wait_cv;\n\t \n\thrtime_t\tzthr_sleep_timeout;\n\n\t \n\tpri_t\t\tzthr_pri;\n\n\t \n\tzthr_checkfunc_t\t*zthr_checkfunc;\n\tzthr_func_t\t*zthr_func;\n\tvoid\t\t*zthr_arg;\n\tconst char\t*zthr_name;\n};\n\nstatic __attribute__((noreturn)) void\nzthr_procedure(void *arg)\n{\n\tzthr_t *t = arg;\n\n\tmutex_enter(&t->zthr_state_lock);\n\tASSERT3P(t->zthr_thread, ==, curthread);\n\n\twhile (!t->zthr_cancel) {\n\t\tif (t->zthr_checkfunc(t->zthr_arg, t)) {\n\t\t\tmutex_exit(&t->zthr_state_lock);\n\t\t\tt->zthr_func(t->zthr_arg, t);\n\t\t\tmutex_enter(&t->zthr_state_lock);\n\t\t} else {\n\t\t\tif (t->zthr_sleep_timeout == 0) {\n\t\t\t\tcv_wait_idle(&t->zthr_cv, &t->zthr_state_lock);\n\t\t\t} else {\n\t\t\t\t(void) cv_timedwait_idle_hires(&t->zthr_cv,\n\t\t\t\t    &t->zthr_state_lock, t->zthr_sleep_timeout,\n\t\t\t\t    MSEC2NSEC(1), 0);\n\t\t\t}\n\t\t}\n\t\tif (t->zthr_haswaiters) {\n\t\t\tt->zthr_haswaiters = B_FALSE;\n\t\t\tcv_broadcast(&t->zthr_wait_cv);\n\t\t}\n\t}\n\n\t \n\tt->zthr_thread = NULL;\n\tt->zthr_cancel = B_FALSE;\n\tcv_broadcast(&t->zthr_cv);\n\n\tmutex_exit(&t->zthr_state_lock);\n\tthread_exit();\n}\n\nzthr_t *\nzthr_create(const char *zthr_name, zthr_checkfunc_t *checkfunc,\n    zthr_func_t *func, void *arg, pri_t pri)\n{\n\treturn (zthr_create_timer(zthr_name, checkfunc,\n\t    func, arg, (hrtime_t)0, pri));\n}\n\n \nzthr_t *\nzthr_create_timer(const char *zthr_name, zthr_checkfunc_t *checkfunc,\n    zthr_func_t *func, void *arg, hrtime_t max_sleep, pri_t pri)\n{\n\tzthr_t *t = kmem_zalloc(sizeof (*t), KM_SLEEP);\n\tmutex_init(&t->zthr_state_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&t->zthr_request_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&t->zthr_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&t->zthr_wait_cv, NULL, CV_DEFAULT, NULL);\n\n\tmutex_enter(&t->zthr_state_lock);\n\tt->zthr_checkfunc = checkfunc;\n\tt->zthr_func = func;\n\tt->zthr_arg = arg;\n\tt->zthr_sleep_timeout = max_sleep;\n\tt->zthr_name = zthr_name;\n\tt->zthr_pri = pri;\n\n\tt->zthr_thread = thread_create_named(zthr_name, NULL, 0,\n\t    zthr_procedure, t, 0, &p0, TS_RUN, pri);\n\n\tmutex_exit(&t->zthr_state_lock);\n\n\treturn (t);\n}\n\nvoid\nzthr_destroy(zthr_t *t)\n{\n\tASSERT(!MUTEX_HELD(&t->zthr_state_lock));\n\tASSERT(!MUTEX_HELD(&t->zthr_request_lock));\n\tVERIFY3P(t->zthr_thread, ==, NULL);\n\tmutex_destroy(&t->zthr_request_lock);\n\tmutex_destroy(&t->zthr_state_lock);\n\tcv_destroy(&t->zthr_cv);\n\tcv_destroy(&t->zthr_wait_cv);\n\tkmem_free(t, sizeof (*t));\n}\n\n \nvoid\nzthr_wakeup(zthr_t *t)\n{\n\tmutex_enter(&t->zthr_state_lock);\n\n\t \n\tcv_broadcast(&t->zthr_cv);\n\n\tmutex_exit(&t->zthr_state_lock);\n}\n\n \nvoid\nzthr_cancel(zthr_t *t)\n{\n\tmutex_enter(&t->zthr_request_lock);\n\tmutex_enter(&t->zthr_state_lock);\n\n\t \n\tif (t->zthr_thread != NULL) {\n\t\tt->zthr_cancel = B_TRUE;\n\n\t\t \n\t\tcv_broadcast(&t->zthr_cv);\n\n\t\twhile (t->zthr_thread != NULL)\n\t\t\tcv_wait(&t->zthr_cv, &t->zthr_state_lock);\n\n\t\tASSERT(!t->zthr_cancel);\n\t}\n\n\tmutex_exit(&t->zthr_state_lock);\n\tmutex_exit(&t->zthr_request_lock);\n}\n\n \nvoid\nzthr_resume(zthr_t *t)\n{\n\tmutex_enter(&t->zthr_request_lock);\n\tmutex_enter(&t->zthr_state_lock);\n\n\tASSERT3P(&t->zthr_checkfunc, !=, NULL);\n\tASSERT3P(&t->zthr_func, !=, NULL);\n\tASSERT(!t->zthr_cancel);\n\tASSERT(!t->zthr_haswaiters);\n\n\t \n\tif (t->zthr_thread == NULL) {\n\t\tt->zthr_thread = thread_create_named(t->zthr_name, NULL, 0,\n\t\t    zthr_procedure, t, 0, &p0, TS_RUN, t->zthr_pri);\n\t}\n\n\tmutex_exit(&t->zthr_state_lock);\n\tmutex_exit(&t->zthr_request_lock);\n}\n\n \nboolean_t\nzthr_iscancelled(zthr_t *t)\n{\n\tASSERT3P(t->zthr_thread, ==, curthread);\n\n\t \n\tmutex_enter(&t->zthr_state_lock);\n\tboolean_t cancelled = t->zthr_cancel;\n\tmutex_exit(&t->zthr_state_lock);\n\treturn (cancelled);\n}\n\nboolean_t\nzthr_iscurthread(zthr_t *t)\n{\n\treturn (t->zthr_thread == curthread);\n}\n\n \nvoid\nzthr_wait_cycle_done(zthr_t *t)\n{\n\tmutex_enter(&t->zthr_state_lock);\n\n\t \n\tif (t->zthr_thread != NULL) {\n\t\tt->zthr_haswaiters = B_TRUE;\n\n\t\t \n\t\tcv_broadcast(&t->zthr_cv);\n\n\t\twhile ((t->zthr_haswaiters) && (t->zthr_thread != NULL))\n\t\t\tcv_wait(&t->zthr_wait_cv, &t->zthr_state_lock);\n\n\t\tASSERT(!t->zthr_haswaiters);\n\t}\n\n\tmutex_exit(&t->zthr_state_lock);\n}\n\n \nboolean_t\nzthr_has_waiters(zthr_t *t)\n{\n\tASSERT3P(t->zthr_thread, ==, curthread);\n\n\tmutex_enter(&t->zthr_state_lock);\n\n\t \n\tboolean_t has_waiters = t->zthr_haswaiters;\n\tmutex_exit(&t->zthr_state_lock);\n\treturn (has_waiters);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}