{
  "module_name": "dsl_crypt.c",
  "hash_id": "5e34a2f31b9ba08428a025a9b01564debf73f7eb8037f37af7836f6d605f7e07",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_crypt.c",
  "human_readable_source": " \n\n \n\n#include <sys/dsl_crypt.h>\n#include <sys/dsl_pool.h>\n#include <sys/zap.h>\n#include <sys/zil.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu_objset.h>\n#include <sys/zvol.h>\n\n \n\n \nint zfs_disable_ivset_guid_check = 0;\n\nstatic void\ndsl_wrapping_key_hold(dsl_wrapping_key_t *wkey, const void *tag)\n{\n\t(void) zfs_refcount_add(&wkey->wk_refcnt, tag);\n}\n\nstatic void\ndsl_wrapping_key_rele(dsl_wrapping_key_t *wkey, const void *tag)\n{\n\t(void) zfs_refcount_remove(&wkey->wk_refcnt, tag);\n}\n\nstatic void\ndsl_wrapping_key_free(dsl_wrapping_key_t *wkey)\n{\n\tASSERT0(zfs_refcount_count(&wkey->wk_refcnt));\n\n\tif (wkey->wk_key.ck_data) {\n\t\tmemset(wkey->wk_key.ck_data, 0,\n\t\t    CRYPTO_BITS2BYTES(wkey->wk_key.ck_length));\n\t\tkmem_free(wkey->wk_key.ck_data,\n\t\t    CRYPTO_BITS2BYTES(wkey->wk_key.ck_length));\n\t}\n\n\tzfs_refcount_destroy(&wkey->wk_refcnt);\n\tkmem_free(wkey, sizeof (dsl_wrapping_key_t));\n}\n\nstatic void\ndsl_wrapping_key_create(uint8_t *wkeydata, zfs_keyformat_t keyformat,\n    uint64_t salt, uint64_t iters, dsl_wrapping_key_t **wkey_out)\n{\n\tdsl_wrapping_key_t *wkey;\n\n\t \n\twkey = kmem_alloc(sizeof (dsl_wrapping_key_t), KM_SLEEP);\n\n\t \n\twkey->wk_key.ck_data = kmem_alloc(WRAPPING_KEY_LEN, KM_SLEEP);\n\n\twkey->wk_key.ck_length = CRYPTO_BYTES2BITS(WRAPPING_KEY_LEN);\n\tmemcpy(wkey->wk_key.ck_data, wkeydata, WRAPPING_KEY_LEN);\n\n\t \n\tzfs_refcount_create(&wkey->wk_refcnt);\n\twkey->wk_keyformat = keyformat;\n\twkey->wk_salt = salt;\n\twkey->wk_iters = iters;\n\n\t*wkey_out = wkey;\n}\n\nint\ndsl_crypto_params_create_nvlist(dcp_cmd_t cmd, nvlist_t *props,\n    nvlist_t *crypto_args, dsl_crypto_params_t **dcp_out)\n{\n\tint ret;\n\tuint64_t crypt = ZIO_CRYPT_INHERIT;\n\tuint64_t keyformat = ZFS_KEYFORMAT_NONE;\n\tuint64_t salt = 0, iters = 0;\n\tdsl_crypto_params_t *dcp = NULL;\n\tdsl_wrapping_key_t *wkey = NULL;\n\tuint8_t *wkeydata = NULL;\n\tuint_t wkeydata_len = 0;\n\tconst char *keylocation = NULL;\n\n\tdcp = kmem_zalloc(sizeof (dsl_crypto_params_t), KM_SLEEP);\n\tdcp->cp_cmd = cmd;\n\n\t \n\tif (props != NULL) {\n\t\t(void) nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_ENCRYPTION), &crypt);\n\t\t(void) nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), &keyformat);\n\t\t(void) nvlist_lookup_string(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), &keylocation);\n\t\t(void) nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), &salt);\n\t\t(void) nvlist_lookup_uint64(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), &iters);\n\n\t\tdcp->cp_crypt = crypt;\n\t}\n\n\tif (crypto_args != NULL) {\n\t\t(void) nvlist_lookup_uint8_array(crypto_args, \"wkeydata\",\n\t\t    &wkeydata, &wkeydata_len);\n\t}\n\n\t \n\tif (dcp->cp_cmd >= DCP_CMD_MAX) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t} else {\n\t\tdcp->cp_cmd = cmd;\n\t}\n\n\t \n\tif (dcp->cp_crypt >= ZIO_CRYPT_FUNCTIONS) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t} else {\n\t\tdcp->cp_crypt = crypt;\n\t}\n\n\t \n\tif (keyformat >= ZFS_KEYFORMAT_FORMATS) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (keylocation != NULL) {\n\t\tif (!zfs_prop_valid_keylocation(keylocation, B_FALSE)) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdcp->cp_keylocation = spa_strdup(keylocation);\n\t}\n\n\t \n\tif (wkeydata != NULL && wkeydata_len != WRAPPING_KEY_LEN) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dcp->cp_crypt == ZIO_CRYPT_ON)\n\t\tdcp->cp_crypt = ZIO_CRYPT_ON_VALUE;\n\n\t \n\tif (wkeydata != NULL) {\n\t\t \n\t\tdsl_wrapping_key_create(wkeydata, keyformat, salt,\n\t\t    iters, &wkey);\n\t\tdcp->cp_wkey = wkey;\n\t}\n\n\t \n\t(void) nvlist_remove_all(props, zfs_prop_to_name(ZFS_PROP_ENCRYPTION));\n\t(void) nvlist_remove_all(props, zfs_prop_to_name(ZFS_PROP_KEYFORMAT));\n\t(void) nvlist_remove_all(props, zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT));\n\t(void) nvlist_remove_all(props,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS));\n\n\t*dcp_out = dcp;\n\n\treturn (0);\n\nerror:\n\tkmem_free(dcp, sizeof (dsl_crypto_params_t));\n\t*dcp_out = NULL;\n\treturn (ret);\n}\n\nvoid\ndsl_crypto_params_free(dsl_crypto_params_t *dcp, boolean_t unload)\n{\n\tif (dcp == NULL)\n\t\treturn;\n\n\tif (dcp->cp_keylocation != NULL)\n\t\tspa_strfree(dcp->cp_keylocation);\n\tif (unload && dcp->cp_wkey != NULL)\n\t\tdsl_wrapping_key_free(dcp->cp_wkey);\n\n\tkmem_free(dcp, sizeof (dsl_crypto_params_t));\n}\n\nstatic int\nspa_crypto_key_compare(const void *a, const void *b)\n{\n\tconst dsl_crypto_key_t *dcka = a;\n\tconst dsl_crypto_key_t *dckb = b;\n\n\tif (dcka->dck_obj < dckb->dck_obj)\n\t\treturn (-1);\n\tif (dcka->dck_obj > dckb->dck_obj)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic int\nspa_key_mapping_compare(const void *a, const void *b)\n{\n\tconst dsl_key_mapping_t *kma = a;\n\tconst dsl_key_mapping_t *kmb = b;\n\n\tif (kma->km_dsobj < kmb->km_dsobj)\n\t\treturn (-1);\n\tif (kma->km_dsobj > kmb->km_dsobj)\n\t\treturn (1);\n\treturn (0);\n}\n\nstatic int\nspa_wkey_compare(const void *a, const void *b)\n{\n\tconst dsl_wrapping_key_t *wka = a;\n\tconst dsl_wrapping_key_t *wkb = b;\n\n\tif (wka->wk_ddobj < wkb->wk_ddobj)\n\t\treturn (-1);\n\tif (wka->wk_ddobj > wkb->wk_ddobj)\n\t\treturn (1);\n\treturn (0);\n}\n\nvoid\nspa_keystore_init(spa_keystore_t *sk)\n{\n\trw_init(&sk->sk_dk_lock, NULL, RW_DEFAULT, NULL);\n\trw_init(&sk->sk_km_lock, NULL, RW_DEFAULT, NULL);\n\trw_init(&sk->sk_wkeys_lock, NULL, RW_DEFAULT, NULL);\n\tavl_create(&sk->sk_dsl_keys, spa_crypto_key_compare,\n\t    sizeof (dsl_crypto_key_t),\n\t    offsetof(dsl_crypto_key_t, dck_avl_link));\n\tavl_create(&sk->sk_key_mappings, spa_key_mapping_compare,\n\t    sizeof (dsl_key_mapping_t),\n\t    offsetof(dsl_key_mapping_t, km_avl_link));\n\tavl_create(&sk->sk_wkeys, spa_wkey_compare, sizeof (dsl_wrapping_key_t),\n\t    offsetof(dsl_wrapping_key_t, wk_avl_link));\n}\n\nvoid\nspa_keystore_fini(spa_keystore_t *sk)\n{\n\tdsl_wrapping_key_t *wkey;\n\tvoid *cookie = NULL;\n\n\tASSERT(avl_is_empty(&sk->sk_dsl_keys));\n\tASSERT(avl_is_empty(&sk->sk_key_mappings));\n\n\twhile ((wkey = avl_destroy_nodes(&sk->sk_wkeys, &cookie)) != NULL)\n\t\tdsl_wrapping_key_free(wkey);\n\n\tavl_destroy(&sk->sk_wkeys);\n\tavl_destroy(&sk->sk_key_mappings);\n\tavl_destroy(&sk->sk_dsl_keys);\n\trw_destroy(&sk->sk_wkeys_lock);\n\trw_destroy(&sk->sk_km_lock);\n\trw_destroy(&sk->sk_dk_lock);\n}\n\nstatic int\ndsl_dir_get_encryption_root_ddobj(dsl_dir_t *dd, uint64_t *rddobj)\n{\n\tif (dd->dd_crypto_obj == 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    DSL_CRYPTO_KEY_ROOT_DDOBJ, 8, 1, rddobj));\n}\n\nstatic int\ndsl_dir_get_encryption_version(dsl_dir_t *dd, uint64_t *version)\n{\n\t*version = 0;\n\n\tif (dd->dd_crypto_obj == 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\t \n\t(void) zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    DSL_CRYPTO_KEY_VERSION, 8, 1, version);\n\n\treturn (0);\n}\n\nboolean_t\ndsl_dir_incompatible_encryption_version(dsl_dir_t *dd)\n{\n\tint ret;\n\tuint64_t version = 0;\n\n\tret = dsl_dir_get_encryption_version(dd, &version);\n\tif (ret != 0)\n\t\treturn (B_FALSE);\n\n\treturn (version != ZIO_CRYPT_KEY_CURRENT_VERSION);\n}\n\nstatic int\nspa_keystore_wkey_hold_ddobj_impl(spa_t *spa, uint64_t ddobj,\n    const void *tag, dsl_wrapping_key_t **wkey_out)\n{\n\tint ret;\n\tdsl_wrapping_key_t search_wkey;\n\tdsl_wrapping_key_t *found_wkey;\n\n\tASSERT(RW_LOCK_HELD(&spa->spa_keystore.sk_wkeys_lock));\n\n\t \n\tsearch_wkey.wk_ddobj = ddobj;\n\n\t \n\tfound_wkey = avl_find(&spa->spa_keystore.sk_wkeys, &search_wkey, NULL);\n\tif (!found_wkey) {\n\t\tret = SET_ERROR(ENOENT);\n\t\tgoto error;\n\t}\n\n\t \n\tdsl_wrapping_key_hold(found_wkey, tag);\n\n\t*wkey_out = found_wkey;\n\treturn (0);\n\nerror:\n\t*wkey_out = NULL;\n\treturn (ret);\n}\n\nstatic int\nspa_keystore_wkey_hold_dd(spa_t *spa, dsl_dir_t *dd, const void *tag,\n    dsl_wrapping_key_t **wkey_out)\n{\n\tint ret;\n\tdsl_wrapping_key_t *wkey;\n\tuint64_t rddobj;\n\tboolean_t locked = B_FALSE;\n\n\tif (!RW_WRITE_HELD(&spa->spa_keystore.sk_wkeys_lock)) {\n\t\trw_enter(&spa->spa_keystore.sk_wkeys_lock, RW_READER);\n\t\tlocked = B_TRUE;\n\t}\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(dd, &rddobj);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = spa_keystore_wkey_hold_ddobj_impl(spa, rddobj, tag, &wkey);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tif (locked)\n\t\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\n\t*wkey_out = wkey;\n\treturn (0);\n\nerror:\n\tif (locked)\n\t\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\n\t*wkey_out = NULL;\n\treturn (ret);\n}\n\nint\ndsl_crypto_can_set_keylocation(const char *dsname, const char *keylocation)\n{\n\tint ret = 0;\n\tdsl_dir_t *dd = NULL;\n\tdsl_pool_t *dp = NULL;\n\tuint64_t rddobj;\n\n\t \n\tret = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = dsl_dir_hold(dp, dsname, FTAG, &dd, NULL);\n\tif (ret != 0) {\n\t\tdd = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (dd->dd_crypto_obj == 0) {\n\t\tif (strcmp(keylocation, \"none\") != 0) {\n\t\t\tret = SET_ERROR(EACCES);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!zfs_prop_valid_keylocation(keylocation, B_TRUE)) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(dd, &rddobj);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (rddobj != dd->dd_object) {\n\t\tret = SET_ERROR(EACCES);\n\t\tgoto out;\n\t}\n\n\tdsl_dir_rele(dd, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\treturn (0);\n\nout:\n\tif (dd != NULL)\n\t\tdsl_dir_rele(dd, FTAG);\n\tif (dp != NULL)\n\t\tdsl_pool_rele(dp, FTAG);\n\n\treturn (ret);\n}\n\nstatic void\ndsl_crypto_key_free(dsl_crypto_key_t *dck)\n{\n\tASSERT(zfs_refcount_count(&dck->dck_holds) == 0);\n\n\t \n\tzio_crypt_key_destroy(&dck->dck_key);\n\n\t \n\tzfs_refcount_destroy(&dck->dck_holds);\n\tif (dck->dck_wkey)\n\t\tdsl_wrapping_key_rele(dck->dck_wkey, dck);\n\n\t \n\tkmem_free(dck, sizeof (dsl_crypto_key_t));\n}\n\nstatic void\ndsl_crypto_key_rele(dsl_crypto_key_t *dck, const void *tag)\n{\n\tif (zfs_refcount_remove(&dck->dck_holds, tag) == 0)\n\t\tdsl_crypto_key_free(dck);\n}\n\nstatic int\ndsl_crypto_key_open(objset_t *mos, dsl_wrapping_key_t *wkey,\n    uint64_t dckobj, const void *tag, dsl_crypto_key_t **dck_out)\n{\n\tint ret;\n\tuint64_t crypt = 0, guid = 0, version = 0;\n\tuint8_t raw_keydata[MASTER_KEY_MAX_LEN];\n\tuint8_t raw_hmac_keydata[SHA512_HMAC_KEYLEN];\n\tuint8_t iv[WRAPPING_IV_LEN];\n\tuint8_t mac[WRAPPING_MAC_LEN];\n\tdsl_crypto_key_t *dck;\n\n\t \n\tdck = kmem_zalloc(sizeof (dsl_crypto_key_t), KM_SLEEP);\n\n\t \n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_CRYPTO_SUITE, 8, 1,\n\t    &crypt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tif (crypt >= ZIO_CRYPT_FUNCTIONS) {\n\t\tret = (SET_ERROR(ZFS_ERR_CRYPTO_NOTSUP));\n\t\tgoto error;\n\t}\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_GUID, 8, 1, &guid);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_MASTER_KEY, 1,\n\t    MASTER_KEY_MAX_LEN, raw_keydata);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_HMAC_KEY, 1,\n\t    SHA512_HMAC_KEYLEN, raw_hmac_keydata);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_IV, 1, WRAPPING_IV_LEN,\n\t    iv);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_MAC, 1, WRAPPING_MAC_LEN,\n\t    mac);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\t(void) zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_VERSION, 8, 1, &version);\n\n\t \n\tret = zio_crypt_key_unwrap(&wkey->wk_key, crypt, version, guid,\n\t    raw_keydata, raw_hmac_keydata, iv, mac, &dck->dck_key);\n\tif (ret != 0) {\n\t\tret = SET_ERROR(EACCES);\n\t\tgoto error;\n\t}\n\n\t \n\tzfs_refcount_create(&dck->dck_holds);\n\tdsl_wrapping_key_hold(wkey, dck);\n\tdck->dck_wkey = wkey;\n\tdck->dck_obj = dckobj;\n\tzfs_refcount_add(&dck->dck_holds, tag);\n\n\t*dck_out = dck;\n\treturn (0);\n\nerror:\n\tif (dck != NULL) {\n\t\tmemset(dck, 0, sizeof (dsl_crypto_key_t));\n\t\tkmem_free(dck, sizeof (dsl_crypto_key_t));\n\t}\n\n\t*dck_out = NULL;\n\treturn (ret);\n}\n\nstatic int\nspa_keystore_dsl_key_hold_impl(spa_t *spa, uint64_t dckobj, const void *tag,\n    dsl_crypto_key_t **dck_out)\n{\n\tint ret;\n\tdsl_crypto_key_t search_dck;\n\tdsl_crypto_key_t *found_dck;\n\n\tASSERT(RW_LOCK_HELD(&spa->spa_keystore.sk_dk_lock));\n\n\t \n\tsearch_dck.dck_obj = dckobj;\n\n\t \n\tfound_dck = avl_find(&spa->spa_keystore.sk_dsl_keys, &search_dck, NULL);\n\tif (!found_dck) {\n\t\tret = SET_ERROR(ENOENT);\n\t\tgoto error;\n\t}\n\n\t \n\tzfs_refcount_add(&found_dck->dck_holds, tag);\n\n\t*dck_out = found_dck;\n\treturn (0);\n\nerror:\n\t*dck_out = NULL;\n\treturn (ret);\n}\n\nstatic int\nspa_keystore_dsl_key_hold_dd(spa_t *spa, dsl_dir_t *dd, const void *tag,\n    dsl_crypto_key_t **dck_out)\n{\n\tint ret;\n\tavl_index_t where;\n\tdsl_crypto_key_t *dck_io = NULL, *dck_ks = NULL;\n\tdsl_wrapping_key_t *wkey = NULL;\n\tuint64_t dckobj = dd->dd_crypto_obj;\n\n\t \n\trw_enter(&spa->spa_keystore.sk_dk_lock, RW_READER);\n\tret = spa_keystore_dsl_key_hold_impl(spa, dckobj, tag, &dck_ks);\n\trw_exit(&spa->spa_keystore.sk_dk_lock);\n\tif (ret == 0) {\n\t\t*dck_out = dck_ks;\n\t\treturn (0);\n\t}\n\n\t \n\tret = spa_keystore_wkey_hold_dd(spa, dd, FTAG, &wkey);\n\tif (ret != 0) {\n\t\t*dck_out = NULL;\n\t\treturn (SET_ERROR(EACCES));\n\t}\n\n\t \n\tret = dsl_crypto_key_open(spa->spa_meta_objset, wkey, dckobj,\n\t    tag, &dck_io);\n\tif (ret != 0) {\n\t\tdsl_wrapping_key_rele(wkey, FTAG);\n\t\t*dck_out = NULL;\n\t\treturn (ret);\n\t}\n\n\t \n\trw_enter(&spa->spa_keystore.sk_dk_lock, RW_WRITER);\n\tret = spa_keystore_dsl_key_hold_impl(spa, dckobj, tag, &dck_ks);\n\tif (ret != 0) {\n\t\tavl_find(&spa->spa_keystore.sk_dsl_keys, dck_io, &where);\n\t\tavl_insert(&spa->spa_keystore.sk_dsl_keys, dck_io, where);\n\t\t*dck_out = dck_io;\n\t} else {\n\t\tdsl_crypto_key_free(dck_io);\n\t\t*dck_out = dck_ks;\n\t}\n\n\t \n\tdsl_wrapping_key_rele(wkey, FTAG);\n\trw_exit(&spa->spa_keystore.sk_dk_lock);\n\n\treturn (0);\n}\n\nvoid\nspa_keystore_dsl_key_rele(spa_t *spa, dsl_crypto_key_t *dck, const void *tag)\n{\n\trw_enter(&spa->spa_keystore.sk_dk_lock, RW_WRITER);\n\n\tif (zfs_refcount_remove(&dck->dck_holds, tag) == 0) {\n\t\tavl_remove(&spa->spa_keystore.sk_dsl_keys, dck);\n\t\tdsl_crypto_key_free(dck);\n\t}\n\n\trw_exit(&spa->spa_keystore.sk_dk_lock);\n}\n\nint\nspa_keystore_load_wkey_impl(spa_t *spa, dsl_wrapping_key_t *wkey)\n{\n\tint ret;\n\tavl_index_t where;\n\tdsl_wrapping_key_t *found_wkey;\n\n\trw_enter(&spa->spa_keystore.sk_wkeys_lock, RW_WRITER);\n\n\t \n\tfound_wkey = avl_find(&spa->spa_keystore.sk_wkeys, wkey, &where);\n\tif (found_wkey != NULL) {\n\t\tret = SET_ERROR(EEXIST);\n\t\tgoto error_unlock;\n\t}\n\tavl_insert(&spa->spa_keystore.sk_wkeys, wkey, where);\n\n\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\n\treturn (0);\n\nerror_unlock:\n\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\treturn (ret);\n}\n\nint\nspa_keystore_load_wkey(const char *dsname, dsl_crypto_params_t *dcp,\n    boolean_t noop)\n{\n\tint ret;\n\tdsl_dir_t *dd = NULL;\n\tdsl_crypto_key_t *dck = NULL;\n\tdsl_wrapping_key_t *wkey = dcp->cp_wkey;\n\tdsl_pool_t *dp = NULL;\n\tuint64_t rddobj, keyformat, salt, iters;\n\n\t \n\tif (dcp->cp_wkey == NULL ||\n\t    dcp->cp_cmd != DCP_CMD_NONE ||\n\t    dcp->cp_crypt != ZIO_CRYPT_INHERIT ||\n\t    dcp->cp_keylocation != NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_ENCRYPTION)) {\n\t\tret = SET_ERROR(ENOTSUP);\n\t\tgoto error;\n\t}\n\n\t \n\tret = dsl_dir_hold(dp, dsname, FTAG, &dd, NULL);\n\tif (ret != 0) {\n\t\tdd = NULL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(dd, &rddobj);\n\tif (ret != 0 || rddobj != dd->dd_object) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\twkey->wk_ddobj = dd->dd_object;\n\n\t \n\tret = dsl_crypto_key_open(dp->dp_meta_objset, wkey,\n\t    dd->dd_crypto_obj, FTAG, &dck);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = zap_lookup(dp->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), 8, 1, &keyformat);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(dp->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), 8, 1, &salt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(dp->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), 8, 1, &iters);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tASSERT3U(keyformat, <, ZFS_KEYFORMAT_FORMATS);\n\tASSERT3U(keyformat, !=, ZFS_KEYFORMAT_NONE);\n\tIMPLY(keyformat == ZFS_KEYFORMAT_PASSPHRASE, iters != 0);\n\tIMPLY(keyformat == ZFS_KEYFORMAT_PASSPHRASE, salt != 0);\n\tIMPLY(keyformat != ZFS_KEYFORMAT_PASSPHRASE, iters == 0);\n\tIMPLY(keyformat != ZFS_KEYFORMAT_PASSPHRASE, salt == 0);\n\n\twkey->wk_keyformat = keyformat;\n\twkey->wk_salt = salt;\n\twkey->wk_iters = iters;\n\n\t \n\tif (noop)\n\t\tgoto error;\n\n\t \n\tret = spa_keystore_load_wkey_impl(dp->dp_spa, wkey);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tdsl_crypto_key_rele(dck, FTAG);\n\tdsl_dir_rele(dd, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\t \n\tzvol_create_minors_recursive(dsname);\n\n\treturn (0);\n\nerror:\n\tif (dck != NULL)\n\t\tdsl_crypto_key_rele(dck, FTAG);\n\tif (dd != NULL)\n\t\tdsl_dir_rele(dd, FTAG);\n\tif (dp != NULL)\n\t\tdsl_pool_rele(dp, FTAG);\n\n\treturn (ret);\n}\n\nint\nspa_keystore_unload_wkey_impl(spa_t *spa, uint64_t ddobj)\n{\n\tint ret;\n\tdsl_wrapping_key_t search_wkey;\n\tdsl_wrapping_key_t *found_wkey;\n\n\t \n\tsearch_wkey.wk_ddobj = ddobj;\n\n\trw_enter(&spa->spa_keystore.sk_wkeys_lock, RW_WRITER);\n\n\t \n\tfound_wkey = avl_find(&spa->spa_keystore.sk_wkeys,\n\t    &search_wkey, NULL);\n\tif (!found_wkey) {\n\t\tret = SET_ERROR(EACCES);\n\t\tgoto error_unlock;\n\t} else if (zfs_refcount_count(&found_wkey->wk_refcnt) != 0) {\n\t\tret = SET_ERROR(EBUSY);\n\t\tgoto error_unlock;\n\t}\n\tavl_remove(&spa->spa_keystore.sk_wkeys, found_wkey);\n\n\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\n\t \n\tdsl_wrapping_key_free(found_wkey);\n\n\treturn (0);\n\nerror_unlock:\n\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\treturn (ret);\n}\n\nint\nspa_keystore_unload_wkey(const char *dsname)\n{\n\tint ret = 0;\n\tdsl_dir_t *dd = NULL;\n\tdsl_pool_t *dp = NULL;\n\tspa_t *spa = NULL;\n\n\tret = spa_open(dsname, &spa, FTAG);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\t \n\tif (spa_mode(spa) != SPA_MODE_READ)\n\t\ttxg_wait_synced(spa->spa_dsl_pool, 0);\n\n\tspa_close(spa, FTAG);\n\n\t \n\tret = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_ENCRYPTION)) {\n\t\tret = (SET_ERROR(ENOTSUP));\n\t\tgoto error;\n\t}\n\n\tret = dsl_dir_hold(dp, dsname, FTAG, &dd, NULL);\n\tif (ret != 0) {\n\t\tdd = NULL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = spa_keystore_unload_wkey_impl(dp->dp_spa, dd->dd_object);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tdsl_dir_rele(dd, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\t \n\tzvol_remove_minors(dp->dp_spa, dsname, B_TRUE);\n\n\treturn (0);\n\nerror:\n\tif (dd != NULL)\n\t\tdsl_dir_rele(dd, FTAG);\n\tif (dp != NULL)\n\t\tdsl_pool_rele(dp, FTAG);\n\n\treturn (ret);\n}\n\nvoid\nkey_mapping_add_ref(dsl_key_mapping_t *km, const void *tag)\n{\n\tASSERT3U(zfs_refcount_count(&km->km_refcnt), >=, 1);\n\tzfs_refcount_add(&km->km_refcnt, tag);\n}\n\n \nvoid\nkey_mapping_rele(spa_t *spa, dsl_key_mapping_t *km, const void *tag)\n{\n\tASSERT3U(zfs_refcount_count(&km->km_refcnt), >=, 1);\n\n\tif (zfs_refcount_remove(&km->km_refcnt, tag) != 0)\n\t\treturn;\n\n\t \n\tzfs_refcount_add(&km->km_refcnt, FTAG);\n\n\trw_enter(&spa->spa_keystore.sk_km_lock, RW_WRITER);\n\tif (zfs_refcount_remove(&km->km_refcnt, FTAG) != 0) {\n\t\trw_exit(&spa->spa_keystore.sk_km_lock);\n\t\treturn;\n\t}\n\n\tavl_remove(&spa->spa_keystore.sk_key_mappings, km);\n\trw_exit(&spa->spa_keystore.sk_km_lock);\n\n\tspa_keystore_dsl_key_rele(spa, km->km_key, km);\n\tzfs_refcount_destroy(&km->km_refcnt);\n\tkmem_free(km, sizeof (dsl_key_mapping_t));\n}\n\nint\nspa_keystore_create_mapping(spa_t *spa, dsl_dataset_t *ds, const void *tag,\n    dsl_key_mapping_t **km_out)\n{\n\tint ret;\n\tavl_index_t where;\n\tdsl_key_mapping_t *km, *found_km;\n\tboolean_t should_free = B_FALSE;\n\n\t \n\tkm = kmem_zalloc(sizeof (dsl_key_mapping_t), KM_SLEEP);\n\tzfs_refcount_create(&km->km_refcnt);\n\n\tret = spa_keystore_dsl_key_hold_dd(spa, ds->ds_dir, km, &km->km_key);\n\tif (ret != 0) {\n\t\tzfs_refcount_destroy(&km->km_refcnt);\n\t\tkmem_free(km, sizeof (dsl_key_mapping_t));\n\n\t\tif (km_out != NULL)\n\t\t\t*km_out = NULL;\n\t\treturn (ret);\n\t}\n\n\tkm->km_dsobj = ds->ds_object;\n\n\trw_enter(&spa->spa_keystore.sk_km_lock, RW_WRITER);\n\n\t \n\tfound_km = avl_find(&spa->spa_keystore.sk_key_mappings, km, &where);\n\tif (found_km != NULL) {\n\t\tshould_free = B_TRUE;\n\t\tzfs_refcount_add(&found_km->km_refcnt, tag);\n\t\tif (km_out != NULL)\n\t\t\t*km_out = found_km;\n\t} else {\n\t\tzfs_refcount_add(&km->km_refcnt, tag);\n\t\tavl_insert(&spa->spa_keystore.sk_key_mappings, km, where);\n\t\tif (km_out != NULL)\n\t\t\t*km_out = km;\n\t}\n\n\trw_exit(&spa->spa_keystore.sk_km_lock);\n\n\tif (should_free) {\n\t\tspa_keystore_dsl_key_rele(spa, km->km_key, km);\n\t\tzfs_refcount_destroy(&km->km_refcnt);\n\t\tkmem_free(km, sizeof (dsl_key_mapping_t));\n\t}\n\n\treturn (0);\n}\n\nint\nspa_keystore_remove_mapping(spa_t *spa, uint64_t dsobj, const void *tag)\n{\n\tint ret;\n\tdsl_key_mapping_t search_km;\n\tdsl_key_mapping_t *found_km;\n\n\t \n\tsearch_km.km_dsobj = dsobj;\n\n\trw_enter(&spa->spa_keystore.sk_km_lock, RW_READER);\n\n\t \n\tfound_km = avl_find(&spa->spa_keystore.sk_key_mappings,\n\t    &search_km, NULL);\n\tif (found_km == NULL) {\n\t\tret = SET_ERROR(ENOENT);\n\t\tgoto error_unlock;\n\t}\n\n\trw_exit(&spa->spa_keystore.sk_km_lock);\n\n\tkey_mapping_rele(spa, found_km, tag);\n\n\treturn (0);\n\nerror_unlock:\n\trw_exit(&spa->spa_keystore.sk_km_lock);\n\treturn (ret);\n}\n\n \nint\nspa_keystore_lookup_key(spa_t *spa, uint64_t dsobj, const void *tag,\n    dsl_crypto_key_t **dck_out)\n{\n\tint ret;\n\tdsl_key_mapping_t search_km;\n\tdsl_key_mapping_t *found_km;\n\n\tASSERT((tag != NULL && dck_out != NULL) ||\n\t    (tag == NULL && dck_out == NULL));\n\n\t \n\tsearch_km.km_dsobj = dsobj;\n\n\trw_enter(&spa->spa_keystore.sk_km_lock, RW_READER);\n\n\t \n\tfound_km = avl_find(&spa->spa_keystore.sk_key_mappings, &search_km,\n\t    NULL);\n\tif (found_km == NULL) {\n\t\tret = SET_ERROR(ENOENT);\n\t\tgoto error_unlock;\n\t}\n\n\tif (found_km && tag)\n\t\tzfs_refcount_add(&found_km->km_key->dck_holds, tag);\n\n\trw_exit(&spa->spa_keystore.sk_km_lock);\n\n\tif (dck_out != NULL)\n\t\t*dck_out = found_km->km_key;\n\treturn (0);\n\nerror_unlock:\n\trw_exit(&spa->spa_keystore.sk_km_lock);\n\n\tif (dck_out != NULL)\n\t\t*dck_out = NULL;\n\treturn (ret);\n}\n\nstatic int\ndmu_objset_check_wkey_loaded(dsl_dir_t *dd)\n{\n\tint ret;\n\tdsl_wrapping_key_t *wkey = NULL;\n\n\tret = spa_keystore_wkey_hold_dd(dd->dd_pool->dp_spa, dd, FTAG,\n\t    &wkey);\n\tif (ret != 0)\n\t\treturn (SET_ERROR(EACCES));\n\n\tdsl_wrapping_key_rele(wkey, FTAG);\n\n\treturn (0);\n}\n\nzfs_keystatus_t\ndsl_dataset_get_keystatus(dsl_dir_t *dd)\n{\n\t \n\tif (dd->dd_crypto_obj == 0)\n\t\treturn (ZFS_KEYSTATUS_NONE);\n\n\treturn (dmu_objset_check_wkey_loaded(dd) == 0 ?\n\t    ZFS_KEYSTATUS_AVAILABLE : ZFS_KEYSTATUS_UNAVAILABLE);\n}\n\nstatic int\ndsl_dir_get_crypt(dsl_dir_t *dd, uint64_t *crypt)\n{\n\tif (dd->dd_crypto_obj == 0) {\n\t\t*crypt = ZIO_CRYPT_OFF;\n\t\treturn (0);\n\t}\n\n\treturn (zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    DSL_CRYPTO_KEY_CRYPTO_SUITE, 8, 1, crypt));\n}\n\nstatic void\ndsl_crypto_key_sync_impl(objset_t *mos, uint64_t dckobj, uint64_t crypt,\n    uint64_t root_ddobj, uint64_t guid, uint8_t *iv, uint8_t *mac,\n    uint8_t *keydata, uint8_t *hmac_keydata, uint64_t keyformat,\n    uint64_t salt, uint64_t iters, dmu_tx_t *tx)\n{\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_CRYPTO_SUITE, 8, 1,\n\t    &crypt, tx));\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_ROOT_DDOBJ, 8, 1,\n\t    &root_ddobj, tx));\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_GUID, 8, 1,\n\t    &guid, tx));\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_IV, 1, WRAPPING_IV_LEN,\n\t    iv, tx));\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_MAC, 1, WRAPPING_MAC_LEN,\n\t    mac, tx));\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_MASTER_KEY, 1,\n\t    MASTER_KEY_MAX_LEN, keydata, tx));\n\tVERIFY0(zap_update(mos, dckobj, DSL_CRYPTO_KEY_HMAC_KEY, 1,\n\t    SHA512_HMAC_KEYLEN, hmac_keydata, tx));\n\tVERIFY0(zap_update(mos, dckobj, zfs_prop_to_name(ZFS_PROP_KEYFORMAT),\n\t    8, 1, &keyformat, tx));\n\tVERIFY0(zap_update(mos, dckobj, zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT),\n\t    8, 1, &salt, tx));\n\tVERIFY0(zap_update(mos, dckobj, zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS),\n\t    8, 1, &iters, tx));\n}\n\nstatic void\ndsl_crypto_key_sync(dsl_crypto_key_t *dck, dmu_tx_t *tx)\n{\n\tzio_crypt_key_t *key = &dck->dck_key;\n\tdsl_wrapping_key_t *wkey = dck->dck_wkey;\n\tuint8_t keydata[MASTER_KEY_MAX_LEN];\n\tuint8_t hmac_keydata[SHA512_HMAC_KEYLEN];\n\tuint8_t iv[WRAPPING_IV_LEN];\n\tuint8_t mac[WRAPPING_MAC_LEN];\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT3U(key->zk_crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\t \n\tVERIFY0(zio_crypt_key_wrap(&dck->dck_wkey->wk_key, key, iv, mac,\n\t    keydata, hmac_keydata));\n\n\t \n\tdsl_crypto_key_sync_impl(tx->tx_pool->dp_meta_objset, dck->dck_obj,\n\t    key->zk_crypt, wkey->wk_ddobj, key->zk_guid, iv, mac, keydata,\n\t    hmac_keydata, wkey->wk_keyformat, wkey->wk_salt, wkey->wk_iters,\n\t    tx);\n}\n\ntypedef struct spa_keystore_change_key_args {\n\tconst char *skcka_dsname;\n\tdsl_crypto_params_t *skcka_cp;\n} spa_keystore_change_key_args_t;\n\nstatic int\nspa_keystore_change_key_check(void *arg, dmu_tx_t *tx)\n{\n\tint ret;\n\tdsl_dir_t *dd = NULL;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tspa_keystore_change_key_args_t *skcka = arg;\n\tdsl_crypto_params_t *dcp = skcka->skcka_cp;\n\tuint64_t rddobj;\n\n\t \n\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_ENCRYPTION)) {\n\t\tret = SET_ERROR(ENOTSUP);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dcp->cp_cmd != DCP_CMD_NEW_KEY &&\n\t    dcp->cp_cmd != DCP_CMD_INHERIT &&\n\t    dcp->cp_cmd != DCP_CMD_FORCE_NEW_KEY &&\n\t    dcp->cp_cmd != DCP_CMD_FORCE_INHERIT) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tret = dsl_dir_hold(dp, skcka->skcka_dsname, FTAG, &dd, NULL);\n\tif (ret != 0) {\n\t\tdd = NULL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (dd->dd_crypto_obj == 0) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dsl_dir_is_clone(dd)) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(dd, &rddobj);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tif (dcp->cp_cmd == DCP_CMD_INHERIT ||\n\t    dcp->cp_cmd == DCP_CMD_FORCE_INHERIT) {\n\t\t \n\t\tif (dcp->cp_crypt != ZIO_CRYPT_INHERIT ||\n\t\t    dcp->cp_keylocation != NULL ||\n\t\t    dcp->cp_wkey != NULL) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (dd->dd_object != rddobj) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (dd->dd_parent->dd_crypto_obj == 0) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (dcp->cp_cmd == DCP_CMD_INHERIT) {\n\t\t\tret = dmu_objset_check_wkey_loaded(dd);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\n\t\t\tret = dmu_objset_check_wkey_loaded(dd->dd_parent);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tif (dcp->cp_cmd == DCP_CMD_FORCE_NEW_KEY) {\n\t\t \n\t\tif (dcp->cp_crypt != ZIO_CRYPT_INHERIT ||\n\t\t    dcp->cp_keylocation != NULL ||\n\t\t    dcp->cp_wkey != NULL) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (dd->dd_object == rddobj) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tif (dcp->cp_crypt != ZIO_CRYPT_INHERIT) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dcp->cp_wkey == NULL) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dcp->cp_wkey->wk_keyformat >= ZFS_KEYFORMAT_FORMATS ||\n\t    dcp->cp_wkey->wk_keyformat == ZFS_KEYFORMAT_NONE) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dd->dd_object != rddobj && dcp->cp_keylocation == NULL) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dcp->cp_keylocation != NULL &&\n\t    !zfs_prop_valid_keylocation(dcp->cp_keylocation, B_TRUE)) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\t \n\tif (dcp->cp_wkey->wk_keyformat == ZFS_KEYFORMAT_PASSPHRASE) {\n\t\tif (dcp->cp_wkey->wk_salt == 0 ||\n\t\t    dcp->cp_wkey->wk_iters < MIN_PBKDF2_ITERATIONS) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif (dcp->cp_wkey->wk_salt != 0 || dcp->cp_wkey->wk_iters != 0) {\n\t\t\tret = SET_ERROR(EINVAL);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tret = dmu_objset_check_wkey_loaded(dd);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tdsl_dir_rele(dd, FTAG);\n\n\treturn (0);\n\nerror:\n\tif (dd != NULL)\n\t\tdsl_dir_rele(dd, FTAG);\n\n\treturn (ret);\n}\n\n \nstatic void\nspa_keystore_change_key_sync_impl(uint64_t rddobj, uint64_t ddobj,\n    uint64_t new_rddobj, dsl_wrapping_key_t *wkey, boolean_t skip,\n    dmu_tx_t *tx)\n{\n\tint ret;\n\tzap_cursor_t *zc;\n\tzap_attribute_t *za;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd = NULL;\n\tdsl_crypto_key_t *dck = NULL;\n\tuint64_t curr_rddobj;\n\n\tASSERT(RW_WRITE_HELD(&dp->dp_spa->spa_keystore.sk_wkeys_lock));\n\n\t \n\tVERIFY0(dsl_dir_hold_obj(dp, ddobj, NULL, FTAG, &dd));\n\n\t \n\tif (dd->dd_myname[0] == '$' || dd->dd_myname[0] == '%') {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn;\n\t}\n\n\tret = dsl_dir_get_encryption_root_ddobj(dd, &curr_rddobj);\n\tVERIFY(ret == 0 || ret == ENOENT);\n\n\t \n\tif (ret == ENOENT ||\n\t    (!skip && (curr_rddobj != rddobj || dsl_dir_is_clone(dd)))) {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn;\n\t}\n\n\t \n\tif (!skip) {\n\t\tif (wkey == NULL) {\n\t\t\tVERIFY0(zap_update(dp->dp_meta_objset,\n\t\t\t    dd->dd_crypto_obj,\n\t\t\t    DSL_CRYPTO_KEY_ROOT_DDOBJ, 8, 1,\n\t\t\t    &new_rddobj, tx));\n\t\t} else {\n\t\t\tVERIFY0(spa_keystore_dsl_key_hold_dd(dp->dp_spa, dd,\n\t\t\t    FTAG, &dck));\n\t\t\tdsl_wrapping_key_hold(wkey, dck);\n\t\t\tdsl_wrapping_key_rele(dck->dck_wkey, dck);\n\t\t\tdck->dck_wkey = wkey;\n\t\t\tdsl_crypto_key_sync(dck, tx);\n\t\t\tspa_keystore_dsl_key_rele(dp->dp_spa, dck, FTAG);\n\t\t}\n\t}\n\n\tzc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\t \n\tfor (zap_cursor_init(zc, dp->dp_meta_objset,\n\t    dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\t\tspa_keystore_change_key_sync_impl(rddobj,\n\t\t    za->za_first_integer, new_rddobj, wkey, B_FALSE, tx);\n\t}\n\tzap_cursor_fini(zc);\n\n\t \n\tfor (zap_cursor_init(zc, dp->dp_meta_objset,\n\t    dsl_dir_phys(dd)->dd_clones);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\t\tdsl_dataset_t *clone;\n\n\t\tVERIFY0(dsl_dataset_hold_obj(dp, za->za_first_integer,\n\t\t    FTAG, &clone));\n\t\tspa_keystore_change_key_sync_impl(rddobj,\n\t\t    clone->ds_dir->dd_object, new_rddobj, wkey, B_TRUE, tx);\n\t\tdsl_dataset_rele(clone, FTAG);\n\t}\n\tzap_cursor_fini(zc);\n\n\tkmem_free(za, sizeof (zap_attribute_t));\n\tkmem_free(zc, sizeof (zap_cursor_t));\n\n\tdsl_dir_rele(dd, FTAG);\n}\n\nstatic void\nspa_keystore_change_key_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_t *ds;\n\tavl_index_t where;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tspa_t *spa = dp->dp_spa;\n\tspa_keystore_change_key_args_t *skcka = arg;\n\tdsl_crypto_params_t *dcp = skcka->skcka_cp;\n\tdsl_wrapping_key_t *wkey = NULL, *found_wkey;\n\tdsl_wrapping_key_t wkey_search;\n\tconst char *keylocation = dcp->cp_keylocation;\n\tuint64_t rddobj, new_rddobj;\n\n\t \n\tVERIFY0(dsl_dataset_hold(dp, skcka->skcka_dsname, FTAG, &ds));\n\tASSERT(!ds->ds_is_snapshot);\n\n\tif (dcp->cp_cmd == DCP_CMD_NEW_KEY ||\n\t    dcp->cp_cmd == DCP_CMD_FORCE_NEW_KEY) {\n\t\t \n\t\tif (dcp->cp_cmd == DCP_CMD_NEW_KEY) {\n\t\t\twkey = dcp->cp_wkey;\n\t\t\twkey->wk_ddobj = ds->ds_dir->dd_object;\n\t\t} else {\n\t\t\tkeylocation = \"prompt\";\n\t\t}\n\n\t\tif (keylocation != NULL) {\n\t\t\tdsl_prop_set_sync_impl(ds,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t\t\t    ZPROP_SRC_LOCAL, 1, strlen(keylocation) + 1,\n\t\t\t    keylocation, tx);\n\t\t}\n\n\t\tVERIFY0(dsl_dir_get_encryption_root_ddobj(ds->ds_dir, &rddobj));\n\t\tnew_rddobj = ds->ds_dir->dd_object;\n\t} else {\n\t\t \n\t\tif (dcp->cp_cmd == DCP_CMD_INHERIT) {\n\t\t\tVERIFY0(spa_keystore_wkey_hold_dd(spa,\n\t\t\t    ds->ds_dir->dd_parent, FTAG, &wkey));\n\t\t}\n\n\t\tdsl_prop_set_sync_impl(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION), ZPROP_SRC_NONE,\n\t\t    0, 0, NULL, tx);\n\n\t\trddobj = ds->ds_dir->dd_object;\n\t\tVERIFY0(dsl_dir_get_encryption_root_ddobj(ds->ds_dir->dd_parent,\n\t\t    &new_rddobj));\n\t}\n\n\tif (wkey == NULL) {\n\t\tASSERT(dcp->cp_cmd == DCP_CMD_FORCE_INHERIT ||\n\t\t    dcp->cp_cmd == DCP_CMD_FORCE_NEW_KEY);\n\t}\n\n\trw_enter(&spa->spa_keystore.sk_wkeys_lock, RW_WRITER);\n\n\t \n\tspa_keystore_change_key_sync_impl(rddobj, ds->ds_dir->dd_object,\n\t    new_rddobj, wkey, B_FALSE, tx);\n\n\t \n\twkey_search.wk_ddobj = ds->ds_dir->dd_object;\n\tfound_wkey = avl_find(&spa->spa_keystore.sk_wkeys, &wkey_search, NULL);\n\tif (found_wkey != NULL) {\n\t\tASSERT0(zfs_refcount_count(&found_wkey->wk_refcnt));\n\t\tavl_remove(&spa->spa_keystore.sk_wkeys, found_wkey);\n\t\tdsl_wrapping_key_free(found_wkey);\n\t}\n\n\tif (dcp->cp_cmd == DCP_CMD_NEW_KEY) {\n\t\tavl_find(&spa->spa_keystore.sk_wkeys, wkey, &where);\n\t\tavl_insert(&spa->spa_keystore.sk_wkeys, wkey, where);\n\t} else if (wkey != NULL) {\n\t\tdsl_wrapping_key_rele(wkey, FTAG);\n\t}\n\n\trw_exit(&spa->spa_keystore.sk_wkeys_lock);\n\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\nspa_keystore_change_key(const char *dsname, dsl_crypto_params_t *dcp)\n{\n\tspa_keystore_change_key_args_t skcka;\n\n\t \n\tskcka.skcka_dsname = dsname;\n\tskcka.skcka_cp = dcp;\n\n\t \n\treturn (dsl_sync_task(dsname, spa_keystore_change_key_check,\n\t    spa_keystore_change_key_sync, &skcka, 15,\n\t    ZFS_SPACE_CHECK_RESERVED));\n}\n\nint\ndsl_dir_rename_crypt_check(dsl_dir_t *dd, dsl_dir_t *newparent)\n{\n\tint ret;\n\tuint64_t curr_rddobj, parent_rddobj;\n\n\tif (dd->dd_crypto_obj == 0)\n\t\treturn (0);\n\n\tret = dsl_dir_get_encryption_root_ddobj(dd, &curr_rddobj);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tif (dd->dd_object != curr_rddobj) {\n\t\tret = dsl_dir_get_encryption_root_ddobj(newparent,\n\t\t    &parent_rddobj);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tif (parent_rddobj != curr_rddobj) {\n\t\t\tret = SET_ERROR(EACCES);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\n \nint\ndsl_dataset_promote_crypt_check(dsl_dir_t *target, dsl_dir_t *origin)\n{\n\tint ret;\n\tuint64_t rddobj, op_rddobj, tp_rddobj;\n\n\t \n\tif (origin->dd_crypto_obj == 0)\n\t\treturn (0);\n\n\t \n\tif (dsl_dir_is_clone(origin))\n\t\treturn (0);\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(origin, &rddobj);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tif (rddobj == origin->dd_object)\n\t\treturn (0);\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(origin->dd_parent, &op_rddobj);\n\tif (ret == ENOENT)\n\t\treturn (SET_ERROR(EACCES));\n\telse if (ret != 0)\n\t\treturn (ret);\n\n\tret = dsl_dir_get_encryption_root_ddobj(target->dd_parent, &tp_rddobj);\n\tif (ret == ENOENT)\n\t\treturn (SET_ERROR(EACCES));\n\telse if (ret != 0)\n\t\treturn (ret);\n\n\tif (op_rddobj != tp_rddobj)\n\t\treturn (SET_ERROR(EACCES));\n\n\treturn (0);\n}\n\nvoid\ndsl_dataset_promote_crypt_sync(dsl_dir_t *target, dsl_dir_t *origin,\n    dmu_tx_t *tx)\n{\n\tuint64_t rddobj;\n\tdsl_pool_t *dp = target->dd_pool;\n\tdsl_dataset_t *targetds;\n\tdsl_dataset_t *originds;\n\tchar *keylocation;\n\n\tif (origin->dd_crypto_obj == 0)\n\t\treturn;\n\tif (dsl_dir_is_clone(origin))\n\t\treturn;\n\n\tVERIFY0(dsl_dir_get_encryption_root_ddobj(origin, &rddobj));\n\n\tif (rddobj != origin->dd_object)\n\t\treturn;\n\n\t \n\tkeylocation = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);\n\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(target)->dd_head_dataset_obj, FTAG, &targetds));\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(origin)->dd_head_dataset_obj, FTAG, &originds));\n\n\tVERIFY0(dsl_prop_get_dd(origin, zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t    1, ZAP_MAXVALUELEN, keylocation, NULL, B_FALSE));\n\tdsl_prop_set_sync_impl(targetds, zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t    ZPROP_SRC_LOCAL, 1, strlen(keylocation) + 1, keylocation, tx);\n\tdsl_prop_set_sync_impl(originds, zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t    ZPROP_SRC_NONE, 0, 0, NULL, tx);\n\n\trw_enter(&dp->dp_spa->spa_keystore.sk_wkeys_lock, RW_WRITER);\n\tspa_keystore_change_key_sync_impl(rddobj, origin->dd_object,\n\t    target->dd_object, NULL, B_FALSE, tx);\n\trw_exit(&dp->dp_spa->spa_keystore.sk_wkeys_lock);\n\n\tdsl_dataset_rele(targetds, FTAG);\n\tdsl_dataset_rele(originds, FTAG);\n\tkmem_free(keylocation, ZAP_MAXVALUELEN);\n}\n\nint\ndmu_objset_create_crypt_check(dsl_dir_t *parentdd, dsl_crypto_params_t *dcp,\n    boolean_t *will_encrypt)\n{\n\tint ret;\n\tuint64_t pcrypt, crypt;\n\tdsl_crypto_params_t dummy_dcp = { 0 };\n\n\tif (will_encrypt != NULL)\n\t\t*will_encrypt = B_FALSE;\n\n\tif (dcp == NULL)\n\t\tdcp = &dummy_dcp;\n\n\tif (dcp->cp_cmd != DCP_CMD_NONE)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (parentdd != NULL) {\n\t\tret = dsl_dir_get_crypt(parentdd, &pcrypt);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\t} else {\n\t\tpcrypt = ZIO_CRYPT_OFF;\n\t}\n\n\tcrypt = (dcp->cp_crypt == ZIO_CRYPT_INHERIT) ? pcrypt : dcp->cp_crypt;\n\n\tASSERT3U(pcrypt, !=, ZIO_CRYPT_INHERIT);\n\tASSERT3U(crypt, !=, ZIO_CRYPT_INHERIT);\n\n\t \n\tif (crypt == ZIO_CRYPT_OFF) {\n\t\t \n\t\tif (dcp->cp_wkey != NULL ||\n\t\t    (dcp->cp_keylocation != NULL &&\n\t\t    strcmp(dcp->cp_keylocation, \"none\") != 0))\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\treturn (0);\n\t}\n\n\tif (will_encrypt != NULL)\n\t\t*will_encrypt = B_TRUE;\n\n\t \n\tif (parentdd != NULL &&\n\t    !spa_feature_is_enabled(parentdd->dd_pool->dp_spa,\n\t    SPA_FEATURE_ENCRYPTION)) {\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t}\n\n\t \n\tif (parentdd != NULL &&\n\t    !spa_feature_is_enabled(parentdd->dd_pool->dp_spa,\n\t    SPA_FEATURE_BOOKMARK_V2)) {\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t}\n\n\t \n\tif (dcp->cp_wkey == NULL) {\n\t\tASSERT3P(parentdd, !=, NULL);\n\n\t\t \n\t\tif (dcp->cp_keylocation != NULL)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (pcrypt == ZIO_CRYPT_OFF)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tret = dmu_objset_check_wkey_loaded(parentdd);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\n\t\treturn (0);\n\t}\n\n\t \n\tif (dcp->cp_keylocation == NULL ||\n\t    !zfs_prop_valid_keylocation(dcp->cp_keylocation, B_TRUE))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tswitch (dcp->cp_wkey->wk_keyformat) {\n\tcase ZFS_KEYFORMAT_HEX:\n\tcase ZFS_KEYFORMAT_RAW:\n\t\t \n\t\tif (dcp->cp_wkey->wk_salt != 0 || dcp->cp_wkey->wk_iters != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\tbreak;\n\tcase ZFS_KEYFORMAT_PASSPHRASE:\n\t\t \n\t\tif (dcp->cp_wkey->wk_salt == 0 ||\n\t\t    dcp->cp_wkey->wk_iters < MIN_PBKDF2_ITERATIONS)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\tbreak;\n\tcase ZFS_KEYFORMAT_NONE:\n\tdefault:\n\t\t \n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\treturn (0);\n}\n\nvoid\ndsl_dataset_create_crypt_sync(uint64_t dsobj, dsl_dir_t *dd,\n    dsl_dataset_t *origin, dsl_crypto_params_t *dcp, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dd->dd_pool;\n\tuint64_t crypt;\n\tdsl_wrapping_key_t *wkey;\n\n\t \n\tif (dsl_dir_is_clone(dd)) {\n\t\tASSERT3P(dcp, ==, NULL);\n\n\t\t \n\t\tif (origin->ds_dir->dd_crypto_obj != 0) {\n\t\t\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\t\t\tdsl_dir_zapify(dd, tx);\n\n\t\t\tdd->dd_crypto_obj =\n\t\t\t    dsl_crypto_key_clone_sync(origin->ds_dir, tx);\n\t\t\tVERIFY0(zap_add(dp->dp_meta_objset, dd->dd_object,\n\t\t\t    DD_FIELD_CRYPTO_KEY_OBJ, sizeof (uint64_t), 1,\n\t\t\t    &dd->dd_crypto_obj, tx));\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tif (dcp == NULL || dcp->cp_cmd == DCP_CMD_RAW_RECV)\n\t\treturn;\n\n\tcrypt = dcp->cp_crypt;\n\twkey = dcp->cp_wkey;\n\n\t \n\tif (crypt == ZIO_CRYPT_INHERIT && dd->dd_parent != NULL)\n\t\tVERIFY0(dsl_dir_get_crypt(dd->dd_parent, &crypt));\n\n\t \n\tif (crypt == ZIO_CRYPT_OFF || crypt == ZIO_CRYPT_INHERIT)\n\t\treturn;\n\n\t \n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\tdsl_dir_zapify(dd, tx);\n\n\t \n\tif (wkey == NULL) {\n\t\tVERIFY0(spa_keystore_wkey_hold_dd(dp->dp_spa,\n\t\t    dd->dd_parent, FTAG, &wkey));\n\t} else {\n\t\twkey->wk_ddobj = dd->dd_object;\n\t}\n\n\tASSERT3P(wkey, !=, NULL);\n\n\t \n\tdd->dd_crypto_obj = dsl_crypto_key_create_sync(crypt, wkey, tx);\n\tVERIFY0(zap_add(dp->dp_meta_objset, dd->dd_object,\n\t    DD_FIELD_CRYPTO_KEY_OBJ, sizeof (uint64_t), 1, &dd->dd_crypto_obj,\n\t    tx));\n\tdsl_dataset_activate_feature(dsobj, SPA_FEATURE_ENCRYPTION,\n\t    (void *)B_TRUE, tx);\n\n\t \n\tif (dcp->cp_wkey == NULL) {\n\t\tdsl_wrapping_key_rele(wkey, FTAG);\n\t} else {\n\t\tVERIFY0(spa_keystore_load_wkey_impl(dp->dp_spa, wkey));\n\t}\n}\n\ntypedef struct dsl_crypto_recv_key_arg {\n\tuint64_t dcrka_dsobj;\n\tuint64_t dcrka_fromobj;\n\tdmu_objset_type_t dcrka_ostype;\n\tnvlist_t *dcrka_nvl;\n\tboolean_t dcrka_do_key;\n} dsl_crypto_recv_key_arg_t;\n\nstatic int\ndsl_crypto_recv_raw_objset_check(dsl_dataset_t *ds, dsl_dataset_t *fromds,\n    dmu_objset_type_t ostype, nvlist_t *nvl, dmu_tx_t *tx)\n{\n\tint ret;\n\tobjset_t *os;\n\tdnode_t *mdn;\n\tuint8_t *buf = NULL;\n\tuint_t len;\n\tuint64_t intval, nlevels, blksz, ibs;\n\tuint64_t nblkptr, maxblkid;\n\n\tif (ostype != DMU_OST_ZFS && ostype != DMU_OST_ZVOL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tret = nvlist_lookup_uint64(nvl, \"mdn_compress\", &intval);\n\tif (ret != 0 || intval >= ZIO_COMPRESS_LEGACY_FUNCTIONS)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint64(nvl, \"mdn_checksum\", &intval);\n\tif (ret != 0 || intval >= ZIO_CHECKSUM_LEGACY_FUNCTIONS)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint64(nvl, \"mdn_nlevels\", &nlevels);\n\tif (ret != 0 || nlevels > DN_MAX_LEVELS)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint64(nvl, \"mdn_blksz\", &blksz);\n\tif (ret != 0 || blksz < SPA_MINBLOCKSIZE)\n\t\treturn (SET_ERROR(EINVAL));\n\telse if (blksz > spa_maxblocksize(tx->tx_pool->dp_spa))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tret = nvlist_lookup_uint64(nvl, \"mdn_indblkshift\", &ibs);\n\tif (ret != 0 || ibs < DN_MIN_INDBLKSHIFT || ibs > DN_MAX_INDBLKSHIFT)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tret = nvlist_lookup_uint64(nvl, \"mdn_nblkptr\", &nblkptr);\n\tif (ret != 0 || nblkptr != DN_MAX_NBLKPTR)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tret = nvlist_lookup_uint64(nvl, \"mdn_maxblkid\", &maxblkid);\n\tif (ret != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint8_array(nvl, \"portable_mac\", &buf, &len);\n\tif (ret != 0 || len != ZIO_OBJSET_MAC_LEN)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = dmu_objset_from_ds(ds, &os);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tmdn = DMU_META_DNODE(os);\n\n\t \n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tif (!BP_IS_HOLE(dsl_dataset_get_blkptr(ds)) &&\n\t    (mdn->dn_nlevels != nlevels || mdn->dn_datablksz != blksz ||\n\t    mdn->dn_indblkshift != ibs || mdn->dn_nblkptr != nblkptr)) {\n\t\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\n\t \n\tif (fromds != NULL && !zfs_disable_ivset_guid_check) {\n\t\tuint64_t from_ivset_guid = 0;\n\t\tintval = 0;\n\n\t\t(void) nvlist_lookup_uint64(nvl, \"from_ivset_guid\", &intval);\n\t\t(void) zap_lookup(tx->tx_pool->dp_meta_objset,\n\t\t    fromds->ds_object, DS_FIELD_IVSET_GUID,\n\t\t    sizeof (from_ivset_guid), 1, &from_ivset_guid);\n\n\t\tif (intval == 0 || from_ivset_guid == 0)\n\t\t\treturn (SET_ERROR(ZFS_ERR_FROM_IVSET_GUID_MISSING));\n\n\t\tif (intval != from_ivset_guid)\n\t\t\treturn (SET_ERROR(ZFS_ERR_FROM_IVSET_GUID_MISMATCH));\n\t}\n\n\treturn (0);\n}\n\nstatic void\ndsl_crypto_recv_raw_objset_sync(dsl_dataset_t *ds, dmu_objset_type_t ostype,\n    nvlist_t *nvl, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = tx->tx_pool;\n\tobjset_t *os;\n\tdnode_t *mdn;\n\tzio_t *zio;\n\tuint8_t *portable_mac;\n\tuint_t len;\n\tuint64_t compress, checksum, nlevels, blksz, ibs, maxblkid;\n\tboolean_t newds = B_FALSE;\n\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tmdn = DMU_META_DNODE(os);\n\n\t \n\tcompress = fnvlist_lookup_uint64(nvl, \"mdn_compress\");\n\tchecksum = fnvlist_lookup_uint64(nvl, \"mdn_checksum\");\n\tnlevels = fnvlist_lookup_uint64(nvl, \"mdn_nlevels\");\n\tblksz = fnvlist_lookup_uint64(nvl, \"mdn_blksz\");\n\tibs = fnvlist_lookup_uint64(nvl, \"mdn_indblkshift\");\n\tmaxblkid = fnvlist_lookup_uint64(nvl, \"mdn_maxblkid\");\n\tVERIFY0(nvlist_lookup_uint8_array(nvl, \"portable_mac\", &portable_mac,\n\t    &len));\n\n\t \n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tif (BP_IS_HOLE(dsl_dataset_get_blkptr(ds))) {\n\t\t(void) dmu_objset_create_impl_dnstats(dp->dp_spa, ds,\n\t\t    dsl_dataset_get_blkptr(ds), ostype, nlevels, blksz,\n\t\t    ibs, tx);\n\t\tnewds = B_TRUE;\n\t}\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\n\t \n\tarc_release(os->os_phys_buf, &os->os_phys_buf);\n\tmemcpy(os->os_phys->os_portable_mac, portable_mac, ZIO_OBJSET_MAC_LEN);\n\tmemset(os->os_phys->os_local_mac, 0, ZIO_OBJSET_MAC_LEN);\n\tos->os_flags &= ~OBJSET_FLAG_USERACCOUNTING_COMPLETE;\n\tos->os_next_write_raw[tx->tx_txg & TXG_MASK] = B_TRUE;\n\n\t \n\tmdn->dn_compress = compress;\n\tmdn->dn_checksum = checksum;\n\n\trw_enter(&mdn->dn_struct_rwlock, RW_WRITER);\n\tdnode_new_blkid(mdn, maxblkid, tx, B_FALSE, B_TRUE);\n\trw_exit(&mdn->dn_struct_rwlock);\n\n\t \n\tif (newds) {\n\t\tdsl_dataset_dirty(ds, tx);\n\t} else {\n\t\tzio = zio_root(dp->dp_spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\t\tdsl_dataset_sync(ds, zio, tx);\n\t\tVERIFY0(zio_wait(zio));\n\t\tdsl_dataset_sync_done(ds, tx);\n\t}\n}\n\nint\ndsl_crypto_recv_raw_key_check(dsl_dataset_t *ds, nvlist_t *nvl, dmu_tx_t *tx)\n{\n\tint ret;\n\tobjset_t *mos = tx->tx_pool->dp_meta_objset;\n\tuint8_t *buf = NULL;\n\tuint_t len;\n\tuint64_t intval, key_guid, version;\n\tboolean_t is_passphrase = B_FALSE;\n\n\tASSERT(dsl_dataset_phys(ds)->ds_flags & DS_FLAG_INCONSISTENT);\n\n\t \n\tret = nvlist_lookup_uint64(nvl, DSL_CRYPTO_KEY_CRYPTO_SUITE, &intval);\n\tif (ret != 0 || intval <= ZIO_CRYPT_OFF)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (intval >= ZIO_CRYPT_FUNCTIONS)\n\t\treturn (SET_ERROR(ZFS_ERR_CRYPTO_NOTSUP));\n\n\tret = nvlist_lookup_uint64(nvl, DSL_CRYPTO_KEY_GUID, &intval);\n\tif (ret != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (ds->ds_dir->dd_crypto_obj != 0) {\n\t\tret = zap_lookup(mos, ds->ds_dir->dd_crypto_obj,\n\t\t    DSL_CRYPTO_KEY_GUID, 8, 1, &key_guid);\n\t\tif (ret != 0)\n\t\t\treturn (ret);\n\t\tif (intval != key_guid)\n\t\t\treturn (SET_ERROR(EACCES));\n\t}\n\n\tret = nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_MASTER_KEY,\n\t    &buf, &len);\n\tif (ret != 0 || len != MASTER_KEY_MAX_LEN)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_HMAC_KEY,\n\t    &buf, &len);\n\tif (ret != 0 || len != SHA512_HMAC_KEYLEN)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_IV, &buf, &len);\n\tif (ret != 0 || len != WRAPPING_IV_LEN)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_MAC, &buf, &len);\n\tif (ret != 0 || len != WRAPPING_MAC_LEN)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tret = nvlist_lookup_uint64(nvl, DSL_CRYPTO_KEY_VERSION, &version);\n\tif (ret != 0 || version != ZIO_CRYPT_KEY_CURRENT_VERSION)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tret = nvlist_lookup_uint64(nvl, zfs_prop_to_name(ZFS_PROP_KEYFORMAT),\n\t    &intval);\n\tif (ret != 0 || intval >= ZFS_KEYFORMAT_FORMATS ||\n\t    intval == ZFS_KEYFORMAT_NONE)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tis_passphrase = (intval == ZFS_KEYFORMAT_PASSPHRASE);\n\n\t \n\tret = nvlist_lookup_uint64(nvl, zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS),\n\t    &intval);\n\tif (ret != 0 || (is_passphrase == (intval == 0)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tret = nvlist_lookup_uint64(nvl, zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT),\n\t    &intval);\n\tif (ret != 0 || (is_passphrase == (intval == 0)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\treturn (0);\n}\n\nvoid\ndsl_crypto_recv_raw_key_sync(dsl_dataset_t *ds, nvlist_t *nvl, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = tx->tx_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdsl_dir_t *dd = ds->ds_dir;\n\tuint_t len;\n\tuint64_t rddobj, one = 1;\n\tuint8_t *keydata, *hmac_keydata, *iv, *mac;\n\tuint64_t crypt, key_guid, keyformat, iters, salt;\n\tuint64_t version = ZIO_CRYPT_KEY_CURRENT_VERSION;\n\tconst char *keylocation = \"prompt\";\n\n\t \n\tcrypt = fnvlist_lookup_uint64(nvl, DSL_CRYPTO_KEY_CRYPTO_SUITE);\n\tkey_guid = fnvlist_lookup_uint64(nvl, DSL_CRYPTO_KEY_GUID);\n\tkeyformat = fnvlist_lookup_uint64(nvl,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT));\n\titers = fnvlist_lookup_uint64(nvl,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS));\n\tsalt = fnvlist_lookup_uint64(nvl,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT));\n\tVERIFY0(nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_MASTER_KEY,\n\t    &keydata, &len));\n\tVERIFY0(nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_HMAC_KEY,\n\t    &hmac_keydata, &len));\n\tVERIFY0(nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_IV, &iv, &len));\n\tVERIFY0(nvlist_lookup_uint8_array(nvl, DSL_CRYPTO_KEY_MAC, &mac, &len));\n\n\t \n\tif (dd->dd_crypto_obj == 0) {\n\t\t \n\t\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\t\tdsl_dir_zapify(dd, tx);\n\n\t\t \n\t\tdd->dd_crypto_obj = zap_create(mos,\n\t\t    DMU_OTN_ZAP_METADATA, DMU_OT_NONE, 0, tx);\n\t\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset,\n\t\t    dd->dd_crypto_obj, DSL_CRYPTO_KEY_REFCOUNT,\n\t\t    sizeof (uint64_t), 1, &one, tx));\n\t\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset,\n\t\t    dd->dd_crypto_obj, DSL_CRYPTO_KEY_VERSION,\n\t\t    sizeof (uint64_t), 1, &version, tx));\n\n\t\tdsl_dataset_activate_feature(ds->ds_object,\n\t\t    SPA_FEATURE_ENCRYPTION, (void *)B_TRUE, tx);\n\t\tds->ds_feature[SPA_FEATURE_ENCRYPTION] = (void *)B_TRUE;\n\n\t\t \n\t\tVERIFY0(zap_add(mos, dd->dd_object, DD_FIELD_CRYPTO_KEY_OBJ,\n\t\t    sizeof (uint64_t), 1, &dd->dd_crypto_obj, tx));\n\n\t\t \n\t\tdsl_prop_set_sync_impl(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_KEYLOCATION),\n\t\t    ZPROP_SRC_LOCAL, 1, strlen(keylocation) + 1,\n\t\t    keylocation, tx);\n\n\t\trddobj = dd->dd_object;\n\t} else {\n\t\tVERIFY0(dsl_dir_get_encryption_root_ddobj(dd, &rddobj));\n\t}\n\n\t \n\tdsl_crypto_key_sync_impl(mos, dd->dd_crypto_obj, crypt,\n\t    rddobj, key_guid, iv, mac, keydata, hmac_keydata, keyformat, salt,\n\t    iters, tx);\n}\n\nstatic int\ndsl_crypto_recv_key_check(void *arg, dmu_tx_t *tx)\n{\n\tint ret;\n\tdsl_crypto_recv_key_arg_t *dcrka = arg;\n\tdsl_dataset_t *ds = NULL, *fromds = NULL;\n\n\tret = dsl_dataset_hold_obj(tx->tx_pool, dcrka->dcrka_dsobj,\n\t    FTAG, &ds);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (dcrka->dcrka_fromobj != 0) {\n\t\tret = dsl_dataset_hold_obj(tx->tx_pool, dcrka->dcrka_fromobj,\n\t\t    FTAG, &fromds);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t}\n\n\tret = dsl_crypto_recv_raw_objset_check(ds, fromds,\n\t    dcrka->dcrka_ostype, dcrka->dcrka_nvl, tx);\n\tif (ret != 0)\n\t\tgoto out;\n\n\t \n\tret = dsl_crypto_recv_raw_key_check(ds, dcrka->dcrka_nvl, tx);\n\tif (ret != 0)\n\t\tgoto out;\n\nout:\n\tif (ds != NULL)\n\t\tdsl_dataset_rele(ds, FTAG);\n\tif (fromds != NULL)\n\t\tdsl_dataset_rele(fromds, FTAG);\n\treturn (ret);\n}\n\nstatic void\ndsl_crypto_recv_key_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_crypto_recv_key_arg_t *dcrka = arg;\n\tdsl_dataset_t *ds;\n\n\tVERIFY0(dsl_dataset_hold_obj(tx->tx_pool, dcrka->dcrka_dsobj,\n\t    FTAG, &ds));\n\tdsl_crypto_recv_raw_objset_sync(ds, dcrka->dcrka_ostype,\n\t    dcrka->dcrka_nvl, tx);\n\tif (dcrka->dcrka_do_key)\n\t\tdsl_crypto_recv_raw_key_sync(ds, dcrka->dcrka_nvl, tx);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\n \nint\ndsl_crypto_recv_raw(const char *poolname, uint64_t dsobj, uint64_t fromobj,\n    dmu_objset_type_t ostype, nvlist_t *nvl, boolean_t do_key)\n{\n\tdsl_crypto_recv_key_arg_t dcrka;\n\n\tdcrka.dcrka_dsobj = dsobj;\n\tdcrka.dcrka_fromobj = fromobj;\n\tdcrka.dcrka_ostype = ostype;\n\tdcrka.dcrka_nvl = nvl;\n\tdcrka.dcrka_do_key = do_key;\n\n\treturn (dsl_sync_task(poolname, dsl_crypto_recv_key_check,\n\t    dsl_crypto_recv_key_sync, &dcrka, 1, ZFS_SPACE_CHECK_NORMAL));\n}\n\nint\ndsl_crypto_populate_key_nvlist(objset_t *os, uint64_t from_ivset_guid,\n    nvlist_t **nvl_out)\n{\n\tint ret;\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\tdnode_t *mdn;\n\tuint64_t rddobj;\n\tnvlist_t *nvl = NULL;\n\tuint64_t dckobj = ds->ds_dir->dd_crypto_obj;\n\tdsl_dir_t *rdd = NULL;\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t crypt = 0, key_guid = 0, format = 0;\n\tuint64_t iters = 0, salt = 0, version = 0;\n\tuint64_t to_ivset_guid = 0;\n\tuint8_t raw_keydata[MASTER_KEY_MAX_LEN];\n\tuint8_t raw_hmac_keydata[SHA512_HMAC_KEYLEN];\n\tuint8_t iv[WRAPPING_IV_LEN];\n\tuint8_t mac[WRAPPING_MAC_LEN];\n\n\tASSERT(dckobj != 0);\n\n\tmdn = DMU_META_DNODE(os);\n\n\tnvl = fnvlist_alloc();\n\n\t \n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_CRYPTO_SUITE, 8, 1,\n\t    &crypt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_GUID, 8, 1, &key_guid);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_MASTER_KEY, 1,\n\t    MASTER_KEY_MAX_LEN, raw_keydata);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_HMAC_KEY, 1,\n\t    SHA512_HMAC_KEYLEN, raw_hmac_keydata);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_IV, 1, WRAPPING_IV_LEN,\n\t    iv);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_MAC, 1, WRAPPING_MAC_LEN,\n\t    mac);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = zap_lookup(mos, ds->ds_object, DS_FIELD_IVSET_GUID, 8, 1,\n\t    &to_ivset_guid);\n\tif (ret != 0)\n\t\tASSERT3U(dp->dp_spa->spa_errata, !=, 0);\n\n\t \n\tret = zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_VERSION, 8, 1, &version);\n\tif (ret != 0 || version != ZIO_CRYPT_KEY_CURRENT_VERSION) {\n\t\tdp->dp_spa->spa_errata = ZPOOL_ERRATA_ZOL_6845_ENCRYPTION;\n\t\tret = SET_ERROR(ENOTSUP);\n\t\tgoto error;\n\t}\n\n\t \n\tret = dsl_dir_get_encryption_root_ddobj(ds->ds_dir, &rddobj);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tdsl_pool_config_enter(dp, FTAG);\n\n\tret = dsl_dir_hold_obj(dp, rddobj, NULL, FTAG, &rdd);\n\tif (ret != 0)\n\t\tgoto error_unlock;\n\n\tret = zap_lookup(dp->dp_meta_objset, rdd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), 8, 1, &format);\n\tif (ret != 0)\n\t\tgoto error_unlock;\n\n\tif (format == ZFS_KEYFORMAT_PASSPHRASE) {\n\t\tret = zap_lookup(dp->dp_meta_objset, rdd->dd_crypto_obj,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), 8, 1, &iters);\n\t\tif (ret != 0)\n\t\t\tgoto error_unlock;\n\n\t\tret = zap_lookup(dp->dp_meta_objset, rdd->dd_crypto_obj,\n\t\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), 8, 1, &salt);\n\t\tif (ret != 0)\n\t\t\tgoto error_unlock;\n\t}\n\n\tdsl_dir_rele(rdd, FTAG);\n\tdsl_pool_config_exit(dp, FTAG);\n\n\tfnvlist_add_uint64(nvl, DSL_CRYPTO_KEY_CRYPTO_SUITE, crypt);\n\tfnvlist_add_uint64(nvl, DSL_CRYPTO_KEY_GUID, key_guid);\n\tfnvlist_add_uint64(nvl, DSL_CRYPTO_KEY_VERSION, version);\n\tVERIFY0(nvlist_add_uint8_array(nvl, DSL_CRYPTO_KEY_MASTER_KEY,\n\t    raw_keydata, MASTER_KEY_MAX_LEN));\n\tVERIFY0(nvlist_add_uint8_array(nvl, DSL_CRYPTO_KEY_HMAC_KEY,\n\t    raw_hmac_keydata, SHA512_HMAC_KEYLEN));\n\tVERIFY0(nvlist_add_uint8_array(nvl, DSL_CRYPTO_KEY_IV, iv,\n\t    WRAPPING_IV_LEN));\n\tVERIFY0(nvlist_add_uint8_array(nvl, DSL_CRYPTO_KEY_MAC, mac,\n\t    WRAPPING_MAC_LEN));\n\tVERIFY0(nvlist_add_uint8_array(nvl, \"portable_mac\",\n\t    os->os_phys->os_portable_mac, ZIO_OBJSET_MAC_LEN));\n\tfnvlist_add_uint64(nvl, zfs_prop_to_name(ZFS_PROP_KEYFORMAT), format);\n\tfnvlist_add_uint64(nvl, zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), iters);\n\tfnvlist_add_uint64(nvl, zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), salt);\n\tfnvlist_add_uint64(nvl, \"mdn_checksum\", mdn->dn_checksum);\n\tfnvlist_add_uint64(nvl, \"mdn_compress\", mdn->dn_compress);\n\tfnvlist_add_uint64(nvl, \"mdn_nlevels\", mdn->dn_nlevels);\n\tfnvlist_add_uint64(nvl, \"mdn_blksz\", mdn->dn_datablksz);\n\tfnvlist_add_uint64(nvl, \"mdn_indblkshift\", mdn->dn_indblkshift);\n\tfnvlist_add_uint64(nvl, \"mdn_nblkptr\", mdn->dn_nblkptr);\n\tfnvlist_add_uint64(nvl, \"mdn_maxblkid\", mdn->dn_maxblkid);\n\tfnvlist_add_uint64(nvl, \"to_ivset_guid\", to_ivset_guid);\n\tfnvlist_add_uint64(nvl, \"from_ivset_guid\", from_ivset_guid);\n\n\t*nvl_out = nvl;\n\treturn (0);\n\nerror_unlock:\n\tdsl_pool_config_exit(dp, FTAG);\nerror:\n\tif (rdd != NULL)\n\t\tdsl_dir_rele(rdd, FTAG);\n\tnvlist_free(nvl);\n\n\t*nvl_out = NULL;\n\treturn (ret);\n}\n\nuint64_t\ndsl_crypto_key_create_sync(uint64_t crypt, dsl_wrapping_key_t *wkey,\n    dmu_tx_t *tx)\n{\n\tdsl_crypto_key_t dck;\n\tuint64_t version = ZIO_CRYPT_KEY_CURRENT_VERSION;\n\tuint64_t one = 1ULL;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\tASSERT3U(crypt, >, ZIO_CRYPT_OFF);\n\n\t \n\tdck.dck_obj = zap_create(tx->tx_pool->dp_meta_objset,\n\t    DMU_OTN_ZAP_METADATA, DMU_OT_NONE, 0, tx);\n\n\t \n\tdck.dck_wkey = wkey;\n\tVERIFY0(zio_crypt_key_init(crypt, &dck.dck_key));\n\n\tdsl_crypto_key_sync(&dck, tx);\n\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset, dck.dck_obj,\n\t    DSL_CRYPTO_KEY_REFCOUNT, sizeof (uint64_t), 1, &one, tx));\n\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset, dck.dck_obj,\n\t    DSL_CRYPTO_KEY_VERSION, sizeof (uint64_t), 1, &version, tx));\n\n\tzio_crypt_key_destroy(&dck.dck_key);\n\tmemset(&dck.dck_key, 0, sizeof (zio_crypt_key_t));\n\n\treturn (dck.dck_obj);\n}\n\nuint64_t\ndsl_crypto_key_clone_sync(dsl_dir_t *origindd, dmu_tx_t *tx)\n{\n\tobjset_t *mos = tx->tx_pool->dp_meta_objset;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tVERIFY0(zap_increment(mos, origindd->dd_crypto_obj,\n\t    DSL_CRYPTO_KEY_REFCOUNT, 1, tx));\n\n\treturn (origindd->dd_crypto_obj);\n}\n\nvoid\ndsl_crypto_key_destroy_sync(uint64_t dckobj, dmu_tx_t *tx)\n{\n\tobjset_t *mos = tx->tx_pool->dp_meta_objset;\n\tuint64_t refcnt;\n\n\t \n\tVERIFY0(zap_lookup(mos, dckobj, DSL_CRYPTO_KEY_REFCOUNT,\n\t    sizeof (uint64_t), 1, &refcnt));\n\n\tif (refcnt != 1) {\n\t\tVERIFY0(zap_increment(mos, dckobj, DSL_CRYPTO_KEY_REFCOUNT,\n\t\t    -1, tx));\n\t} else {\n\t\tVERIFY0(zap_destroy(mos, dckobj, tx));\n\t}\n}\n\nvoid\ndsl_dataset_crypt_stats(dsl_dataset_t *ds, nvlist_t *nv)\n{\n\tuint64_t intval;\n\tdsl_dir_t *dd = ds->ds_dir;\n\tdsl_dir_t *enc_root;\n\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\n\tif (dd->dd_crypto_obj == 0)\n\t\treturn;\n\n\tintval = dsl_dataset_get_keystatus(dd);\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_KEYSTATUS, intval);\n\n\tif (dsl_dir_get_crypt(dd, &intval) == 0)\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_ENCRYPTION, intval);\n\tif (zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    DSL_CRYPTO_KEY_GUID, 8, 1, &intval) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_KEY_GUID, intval);\n\t}\n\tif (zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_KEYFORMAT), 8, 1, &intval) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_KEYFORMAT, intval);\n\t}\n\tif (zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_SALT), 8, 1, &intval) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_PBKDF2_SALT, intval);\n\t}\n\tif (zap_lookup(dd->dd_pool->dp_meta_objset, dd->dd_crypto_obj,\n\t    zfs_prop_to_name(ZFS_PROP_PBKDF2_ITERS), 8, 1, &intval) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_PBKDF2_ITERS, intval);\n\t}\n\tif (zap_lookup(dd->dd_pool->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_IVSET_GUID, 8, 1, &intval) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_IVSET_GUID, intval);\n\t}\n\n\tif (dsl_dir_get_encryption_root_ddobj(dd, &intval) == 0) {\n\t\tif (dsl_dir_hold_obj(dd->dd_pool, intval, NULL, FTAG,\n\t\t    &enc_root) == 0) {\n\t\t\tdsl_dir_name(enc_root, buf);\n\t\t\tdsl_dir_rele(enc_root, FTAG);\n\t\t\tdsl_prop_nvlist_add_string(nv,\n\t\t\t    ZFS_PROP_ENCRYPTION_ROOT, buf);\n\t\t}\n\t}\n}\n\nint\nspa_crypt_get_salt(spa_t *spa, uint64_t dsobj, uint8_t *salt)\n{\n\tint ret;\n\tdsl_crypto_key_t *dck = NULL;\n\n\t \n\tret = spa_keystore_lookup_key(spa, dsobj, FTAG, &dck);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = zio_crypt_key_get_salt(&dck->dck_key, salt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\treturn (0);\n\nerror:\n\tif (dck != NULL)\n\t\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\treturn (ret);\n}\n\n \nint\nspa_do_crypt_objset_mac_abd(boolean_t generate, spa_t *spa, uint64_t dsobj,\n    abd_t *abd, uint_t datalen, boolean_t byteswap)\n{\n\tint ret;\n\tdsl_crypto_key_t *dck = NULL;\n\tvoid *buf = abd_borrow_buf_copy(abd, datalen);\n\tobjset_phys_t *osp = buf;\n\tuint8_t portable_mac[ZIO_OBJSET_MAC_LEN];\n\tuint8_t local_mac[ZIO_OBJSET_MAC_LEN];\n\tconst uint8_t zeroed_mac[ZIO_OBJSET_MAC_LEN] = {0};\n\n\t \n\tret = spa_keystore_lookup_key(spa, dsobj, FTAG, &dck);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = zio_crypt_do_objset_hmacs(&dck->dck_key, buf, datalen,\n\t    byteswap, portable_mac, local_mac);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\n\t \n\tif (generate) {\n\t\tmemcpy(osp->os_portable_mac, portable_mac, ZIO_OBJSET_MAC_LEN);\n\t\tmemcpy(osp->os_local_mac, local_mac, ZIO_OBJSET_MAC_LEN);\n\t\tabd_return_buf_copy(abd, buf, datalen);\n\t\treturn (0);\n\t}\n\n\tif (memcmp(portable_mac, osp->os_portable_mac,\n\t    ZIO_OBJSET_MAC_LEN) != 0 ||\n\t    memcmp(local_mac, osp->os_local_mac, ZIO_OBJSET_MAC_LEN) != 0) {\n\t\t \n\t\tif (memcmp(local_mac, zeroed_mac, ZIO_OBJSET_MAC_LEN) != 0) {\n\t\t\tabd_return_buf(abd, buf, datalen);\n\t\t\treturn (SET_ERROR(ECKSUM));\n\t\t}\n\t}\n\n\tabd_return_buf(abd, buf, datalen);\n\n\treturn (0);\n\nerror:\n\tif (dck != NULL)\n\t\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\tabd_return_buf(abd, buf, datalen);\n\treturn (ret);\n}\n\nint\nspa_do_crypt_mac_abd(boolean_t generate, spa_t *spa, uint64_t dsobj, abd_t *abd,\n    uint_t datalen, uint8_t *mac)\n{\n\tint ret;\n\tdsl_crypto_key_t *dck = NULL;\n\tuint8_t *buf = abd_borrow_buf_copy(abd, datalen);\n\tuint8_t digestbuf[ZIO_DATA_MAC_LEN];\n\n\t \n\tret = spa_keystore_lookup_key(spa, dsobj, FTAG, &dck);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = zio_crypt_do_hmac(&dck->dck_key, buf, datalen,\n\t    digestbuf, ZIO_DATA_MAC_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tabd_return_buf(abd, buf, datalen);\n\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\n\t \n\tif (generate) {\n\t\tmemcpy(mac, digestbuf, ZIO_DATA_MAC_LEN);\n\t\treturn (0);\n\t}\n\n\tif (memcmp(digestbuf, mac, ZIO_DATA_MAC_LEN) != 0)\n\t\treturn (SET_ERROR(ECKSUM));\n\n\treturn (0);\n\nerror:\n\tif (dck != NULL)\n\t\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\tabd_return_buf(abd, buf, datalen);\n\treturn (ret);\n}\n\n \nint\nspa_do_crypt_abd(boolean_t encrypt, spa_t *spa, const zbookmark_phys_t *zb,\n    dmu_object_type_t ot, boolean_t dedup, boolean_t bswap, uint8_t *salt,\n    uint8_t *iv, uint8_t *mac, uint_t datalen, abd_t *pabd, abd_t *cabd,\n    boolean_t *no_crypt)\n{\n\tint ret;\n\tdsl_crypto_key_t *dck = NULL;\n\tuint8_t *plainbuf = NULL, *cipherbuf = NULL;\n\n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_ENCRYPTION));\n\n\t \n\tret = spa_keystore_lookup_key(spa, zb->zb_objset, FTAG, &dck);\n\tif (ret != 0) {\n\t\tret = SET_ERROR(EACCES);\n\t\treturn (ret);\n\t}\n\n\tif (encrypt) {\n\t\tplainbuf = abd_borrow_buf_copy(pabd, datalen);\n\t\tcipherbuf = abd_borrow_buf(cabd, datalen);\n\t} else {\n\t\tplainbuf = abd_borrow_buf(pabd, datalen);\n\t\tcipherbuf = abd_borrow_buf_copy(cabd, datalen);\n\t}\n\n\t \n\tif (encrypt && ot != DMU_OT_INTENT_LOG && !dedup) {\n\t\tret = zio_crypt_key_get_salt(&dck->dck_key, salt);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tret = zio_crypt_generate_iv(iv);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t} else if (encrypt && dedup) {\n\t\tret = zio_crypt_generate_iv_salt_dedup(&dck->dck_key,\n\t\t    plainbuf, datalen, iv, salt);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tret = zio_do_crypt_data(encrypt, &dck->dck_key, ot, bswap, salt, iv,\n\t    mac, datalen, plainbuf, cipherbuf, no_crypt);\n\n\t \n\tif (zio_injection_enabled && !encrypt && ot != DMU_OT_DNODE && ret == 0)\n\t\tret = zio_handle_decrypt_injection(spa, zb, ot, ECKSUM);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tif (encrypt) {\n\t\tabd_return_buf(pabd, plainbuf, datalen);\n\t\tabd_return_buf_copy(cabd, cipherbuf, datalen);\n\t} else {\n\t\tabd_return_buf_copy(pabd, plainbuf, datalen);\n\t\tabd_return_buf(cabd, cipherbuf, datalen);\n\t}\n\n\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\n\treturn (0);\n\nerror:\n\tif (encrypt) {\n\t\t \n\t\tmemset(salt, 0, ZIO_DATA_SALT_LEN);\n\t\tmemset(iv, 0, ZIO_DATA_IV_LEN);\n\t\tmemset(mac, 0, ZIO_DATA_MAC_LEN);\n\t\tabd_return_buf(pabd, plainbuf, datalen);\n\t\tabd_return_buf_copy(cabd, cipherbuf, datalen);\n\t} else {\n\t\tabd_return_buf_copy(pabd, plainbuf, datalen);\n\t\tabd_return_buf(cabd, cipherbuf, datalen);\n\t}\n\n\tspa_keystore_dsl_key_rele(spa, dck, FTAG);\n\n\treturn (ret);\n}\n\nZFS_MODULE_PARAM(zfs, zfs_, disable_ivset_guid_check, INT, ZMOD_RW,\n\t\"Set to allow raw receives without IVset guids\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}