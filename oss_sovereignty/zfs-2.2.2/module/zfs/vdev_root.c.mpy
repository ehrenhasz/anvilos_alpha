{
  "module_name": "vdev_root.c",
  "hash_id": "e5ab0ab5c0748fa2c71eaf6b975c73235b0ab4854785d567ce2180e74cd6e6fb",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_root.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/vdev_impl.h>\n#include <sys/zio.h>\n#include <sys/fs/zfs.h>\n\n \n\nstatic uint64_t\nvdev_root_core_tvds(vdev_t *vd)\n{\n\tuint64_t tvds = 0;\n\n\tfor (uint64_t c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (!cvd->vdev_ishole && !cvd->vdev_islog &&\n\t\t    cvd->vdev_ops != &vdev_indirect_ops) {\n\t\t\ttvds++;\n\t\t}\n\t}\n\n\treturn (tvds);\n}\n\n \nstatic boolean_t\ntoo_many_errors(vdev_t *vd, uint64_t numerrors)\n{\n\tuint64_t tvds;\n\n\tif (numerrors == 0)\n\t\treturn (B_FALSE);\n\n\ttvds = vdev_root_core_tvds(vd);\n\tASSERT3U(numerrors, <=, tvds);\n\n\tif (numerrors == tvds)\n\t\treturn (B_TRUE);\n\n\treturn (numerrors > spa_missing_tvds_allowed(vd->vdev_spa));\n}\n\nstatic int\nvdev_root_open(vdev_t *vd, uint64_t *asize, uint64_t *max_asize,\n    uint64_t *ashift, uint64_t *pshift)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tint lasterror = 0;\n\tint numerrors = 0;\n\n\tif (vd->vdev_children == 0) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_BAD_LABEL;\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tvdev_open_children(vd);\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (cvd->vdev_open_error && !cvd->vdev_islog &&\n\t\t    cvd->vdev_ops != &vdev_indirect_ops) {\n\t\t\tlasterror = cvd->vdev_open_error;\n\t\t\tnumerrors++;\n\t\t}\n\t}\n\n\tif (spa_load_state(spa) != SPA_LOAD_NONE)\n\t\tspa_set_missing_tvds(spa, numerrors);\n\n\tif (too_many_errors(vd, numerrors)) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_NO_REPLICAS;\n\t\treturn (lasterror);\n\t}\n\n\t*asize = 0;\n\t*max_asize = 0;\n\t*ashift = 0;\n\t*pshift = 0;\n\n\treturn (0);\n}\n\nstatic void\nvdev_root_close(vdev_t *vd)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_close(vd->vdev_child[c]);\n}\n\nstatic void\nvdev_root_state_change(vdev_t *vd, int faulted, int degraded)\n{\n\tif (too_many_errors(vd, faulted)) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_NO_REPLICAS);\n\t} else if (degraded || faulted) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_DEGRADED, VDEV_AUX_NONE);\n\t} else {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_HEALTHY, VDEV_AUX_NONE);\n\t}\n}\n\nvdev_ops_t vdev_root_ops = {\n\t.vdev_op_init = NULL,\n\t.vdev_op_fini = NULL,\n\t.vdev_op_open = vdev_root_open,\n\t.vdev_op_close = vdev_root_close,\n\t.vdev_op_asize = vdev_default_asize,\n\t.vdev_op_min_asize = vdev_default_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = NULL,\t \n\t.vdev_op_io_done = NULL,\t \n\t.vdev_op_state_change = vdev_root_state_change,\n\t.vdev_op_need_resilver = NULL,\n\t.vdev_op_hold = NULL,\n\t.vdev_op_rele = NULL,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = NULL,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = NULL,\n\t.vdev_op_nparity = NULL,\n\t.vdev_op_ndisks = NULL,\n\t.vdev_op_type = VDEV_TYPE_ROOT,\t \n\t.vdev_op_leaf = B_FALSE\t\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}