{
  "module_name": "spa_errlog.c",
  "hash_id": "ec6cd7859b974f02bf49c1dd2591bb731deb259b3b468b6f790680b0dca5f773",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/spa_errlog.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/dmu_tx.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zap.h>\n#include <sys/zio.h>\n#include <sys/dsl_dir.h>\n#include <sys/dmu_objset.h>\n#include <sys/dbuf.h>\n#include <sys/zfs_znode.h>\n\n#define\tNAME_MAX_LEN 64\n\ntypedef struct clones {\n\tuint64_t clone_ds;\n\tlist_node_t node;\n} clones_t;\n\n \nstatic uint_t spa_upgrade_errlog_limit = 0;\n\n \nstatic void\nbookmark_to_name(zbookmark_phys_t *zb, char *buf, size_t len)\n{\n\t(void) snprintf(buf, len, \"%llx:%llx:%llx:%llx\",\n\t    (u_longlong_t)zb->zb_objset, (u_longlong_t)zb->zb_object,\n\t    (u_longlong_t)zb->zb_level, (u_longlong_t)zb->zb_blkid);\n}\n\n \nstatic void\nerrphys_to_name(zbookmark_err_phys_t *zep, char *buf, size_t len)\n{\n\t(void) snprintf(buf, len, \"%llx:%llx:%llx:%llx\",\n\t    (u_longlong_t)zep->zb_object, (u_longlong_t)zep->zb_level,\n\t    (u_longlong_t)zep->zb_blkid, (u_longlong_t)zep->zb_birth);\n}\n\n \nvoid\nname_to_errphys(char *buf, zbookmark_err_phys_t *zep)\n{\n\tzep->zb_object = zfs_strtonum(buf, &buf);\n\tASSERT(*buf == ':');\n\tzep->zb_level = (int)zfs_strtonum(buf + 1, &buf);\n\tASSERT(*buf == ':');\n\tzep->zb_blkid = zfs_strtonum(buf + 1, &buf);\n\tASSERT(*buf == ':');\n\tzep->zb_birth = zfs_strtonum(buf + 1, &buf);\n\tASSERT(*buf == '\\0');\n}\n\n \nstatic void\nname_to_bookmark(char *buf, zbookmark_phys_t *zb)\n{\n\tzb->zb_objset = zfs_strtonum(buf, &buf);\n\tASSERT(*buf == ':');\n\tzb->zb_object = zfs_strtonum(buf + 1, &buf);\n\tASSERT(*buf == ':');\n\tzb->zb_level = (int)zfs_strtonum(buf + 1, &buf);\n\tASSERT(*buf == ':');\n\tzb->zb_blkid = zfs_strtonum(buf + 1, &buf);\n\tASSERT(*buf == '\\0');\n}\n\nvoid\nzep_to_zb(uint64_t dataset, zbookmark_err_phys_t *zep, zbookmark_phys_t *zb)\n{\n\tzb->zb_objset = dataset;\n\tzb->zb_object = zep->zb_object;\n\tzb->zb_level = zep->zb_level;\n\tzb->zb_blkid = zep->zb_blkid;\n}\n\nstatic void\nname_to_object(char *buf, uint64_t *obj)\n{\n\t*obj = zfs_strtonum(buf, &buf);\n\tASSERT(*buf == '\\0');\n}\n\n \nstatic int get_head_ds(spa_t *spa, uint64_t dsobj, uint64_t *head_ds)\n{\n\tdsl_dataset_t *ds;\n\tint error = dsl_dataset_hold_obj_flags(spa->spa_dsl_pool,\n\t    dsobj, DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\n\tif (error != 0)\n\t\treturn (error);\n\n\tASSERT(head_ds);\n\t*head_ds = dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj;\n\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\n\treturn (error);\n}\n\n \nvoid\nspa_log_error(spa_t *spa, const zbookmark_phys_t *zb, const uint64_t *birth)\n{\n\tspa_error_entry_t search;\n\tspa_error_entry_t *new;\n\tavl_tree_t *tree;\n\tavl_index_t where;\n\n\t \n\tif (spa_load_state(spa) == SPA_LOAD_TRYIMPORT)\n\t\treturn;\n\n\tmutex_enter(&spa->spa_errlist_lock);\n\n\t \n\tif (spa->spa_scrub_active || spa->spa_scrub_finished)\n\t\ttree = &spa->spa_errlist_scrub;\n\telse\n\t\ttree = &spa->spa_errlist_last;\n\n\tsearch.se_bookmark = *zb;\n\tif (avl_find(tree, &search, &where) != NULL) {\n\t\tmutex_exit(&spa->spa_errlist_lock);\n\t\treturn;\n\t}\n\n\tnew = kmem_zalloc(sizeof (spa_error_entry_t), KM_SLEEP);\n\tnew->se_bookmark = *zb;\n\n\t \n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tnew->se_zep.zb_object = zb->zb_object;\n\t\tnew->se_zep.zb_level = zb->zb_level;\n\t\tnew->se_zep.zb_blkid = zb->zb_blkid;\n\n\t\t \n\t\tif (birth != NULL)\n\t\t\tnew->se_zep.zb_birth = *birth;\n\t}\n\n\tavl_insert(tree, new, where);\n\tmutex_exit(&spa->spa_errlist_lock);\n}\n\nint\nfind_birth_txg(dsl_dataset_t *ds, zbookmark_err_phys_t *zep,\n    uint64_t *birth_txg)\n{\n\tobjset_t *os;\n\tint error = dmu_objset_from_ds(ds, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\tdnode_t *dn;\n\tblkptr_t bp;\n\n\terror = dnode_hold(os, zep->zb_object, FTAG, &dn);\n\tif (error != 0)\n\t\treturn (error);\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\terror = dbuf_dnode_findbp(dn, zep->zb_level, zep->zb_blkid, &bp, NULL,\n\t    NULL);\n\tif (error == 0 && BP_IS_HOLE(&bp))\n\t\terror = SET_ERROR(ENOENT);\n\n\t*birth_txg = bp.blk_birth;\n\trw_exit(&dn->dn_struct_rwlock);\n\tdnode_rele(dn, FTAG);\n\treturn (error);\n}\n\n \nint\nfind_top_affected_fs(spa_t *spa, uint64_t head_ds, zbookmark_err_phys_t *zep,\n    uint64_t *top_affected_fs)\n{\n\tuint64_t oldest_dsobj;\n\tint error = dsl_dataset_oldest_snapshot(spa, head_ds, zep->zb_birth,\n\t    &oldest_dsobj);\n\tif (error != 0)\n\t\treturn (error);\n\n\tdsl_dataset_t *ds;\n\terror = dsl_dataset_hold_obj_flags(spa->spa_dsl_pool, oldest_dsobj,\n\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\t*top_affected_fs =\n\t    dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj;\n\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\treturn (0);\n}\n\n\n#ifdef _KERNEL\n \nstatic int\ncopyout_entry(const zbookmark_phys_t *zb, void *uaddr, uint64_t *count)\n{\n\tif (*count == 0)\n\t\treturn (SET_ERROR(ENOMEM));\n\n\t*count -= 1;\n\tif (copyout(zb, (char *)uaddr + (*count) * sizeof (zbookmark_phys_t),\n\t    sizeof (zbookmark_phys_t)) != 0)\n\t\treturn (SET_ERROR(EFAULT));\n\treturn (0);\n}\n\n \nstatic int\ncheck_filesystem(spa_t *spa, uint64_t head_ds, zbookmark_err_phys_t *zep,\n    void *uaddr, uint64_t *count, list_t *clones_list)\n{\n\tdsl_dataset_t *ds;\n\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\n\tint error = dsl_dataset_hold_obj_flags(dp, head_ds,\n\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tuint64_t latest_txg;\n\tuint64_t txg_to_consider = spa->spa_syncing_txg;\n\tboolean_t check_snapshot = B_TRUE;\n\terror = find_birth_txg(ds, zep, &latest_txg);\n\n\t \n\tif (error == 0 && zep->zb_birth == latest_txg) {\n\t\t \n\t\tzbookmark_phys_t zb;\n\t\tzep_to_zb(head_ds, zep, &zb);\n\t\terror = copyout_entry(&zb, uaddr, count);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\tcheck_snapshot = B_FALSE;\n\t} else if (error == 0) {\n\t\ttxg_to_consider = latest_txg;\n\t}\n\n\t \n\tuint64_t snap_count = 0;\n\tif (dsl_dataset_phys(ds)->ds_snapnames_zapobj != 0) {\n\n\t\terror = zap_count(spa->spa_meta_objset,\n\t\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj, &snap_count);\n\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (snap_count == 0) {\n\t\t \n\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\treturn (0);\n\t}\n\n\tuint64_t *snap_obj_array = kmem_zalloc(snap_count * sizeof (uint64_t),\n\t    KM_SLEEP);\n\n\tint aff_snap_count = 0;\n\tuint64_t snap_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\tuint64_t snap_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\tuint64_t zap_clone = dsl_dir_phys(ds->ds_dir)->dd_clones;\n\n\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\n\t \n\twhile (snap_obj != 0 && zep->zb_birth < snap_obj_txg &&\n\t    snap_obj_txg <= txg_to_consider) {\n\n\t\terror = dsl_dataset_hold_obj_flags(dp, snap_obj,\n\t\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\n\t\tif (dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj != head_ds) {\n\t\t\tsnap_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t\t\tsnap_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\tboolean_t affected = B_TRUE;\n\t\tif (check_snapshot) {\n\t\t\tuint64_t blk_txg;\n\t\t\terror = find_birth_txg(ds, zep, &blk_txg);\n\t\t\taffected = (error == 0 && zep->zb_birth == blk_txg);\n\t\t}\n\n\t\t \n\t\tif (affected) {\n\t\t\tsnap_obj_array[aff_snap_count] = snap_obj;\n\t\t\taff_snap_count++;\n\n\t\t\tzbookmark_phys_t zb;\n\t\t\tzep_to_zb(snap_obj, zep, &zb);\n\t\t\terror = copyout_entry(&zb, uaddr, count);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT,\n\t\t\t\t    FTAG);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tsnap_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t\tsnap_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t}\n\n\tif (zap_clone == 0 || aff_snap_count == 0)\n\t\treturn (0);\n\n\t \n\tzap_cursor_t *zc;\n\tzap_attribute_t *za;\n\n\tzc = kmem_zalloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tza = kmem_zalloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\tfor (zap_cursor_init(zc, spa->spa_meta_objset, zap_clone);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\n\t\tdsl_dataset_t *clone;\n\t\terror = dsl_dataset_hold_obj_flags(dp, za->za_first_integer,\n\t\t    DS_HOLD_FLAG_DECRYPT, FTAG, &clone);\n\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tboolean_t found = B_FALSE;\n\t\tfor (int i = 0; i < snap_count; i++) {\n\t\t\tif (dsl_dir_phys(clone->ds_dir)->dd_origin_obj\n\t\t\t    == snap_obj_array[i])\n\t\t\t\tfound = B_TRUE;\n\t\t}\n\t\tdsl_dataset_rele_flags(clone, DS_HOLD_FLAG_DECRYPT, FTAG);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tclones_t *ct = kmem_zalloc(sizeof (*ct), KM_SLEEP);\n\t\tct->clone_ds = za->za_first_integer;\n\t\tlist_insert_tail(clones_list, ct);\n\t}\n\n\tzap_cursor_fini(zc);\n\tkmem_free(za, sizeof (*za));\n\tkmem_free(zc, sizeof (*zc));\n\nout:\n\tkmem_free(snap_obj_array, sizeof (*snap_obj_array));\n\treturn (error);\n}\n\nstatic int\nprocess_error_block(spa_t *spa, uint64_t head_ds, zbookmark_err_phys_t *zep,\n    void *uaddr, uint64_t *count)\n{\n\t \n\tif (zep->zb_birth == 0 || head_ds == 0) {\n\t\tzbookmark_phys_t zb;\n\t\tzep_to_zb(head_ds, zep, &zb);\n\t\tint error = copyout_entry(&zb, uaddr, count);\n\t\tif (error != 0) {\n\t\t\treturn (error);\n\t\t}\n\t\treturn (0);\n\t}\n\n\tuint64_t top_affected_fs;\n\tuint64_t init_count = *count;\n\tint error = find_top_affected_fs(spa, head_ds, zep, &top_affected_fs);\n\tif (error == 0) {\n\t\tclones_t *ct;\n\t\tlist_t clones_list;\n\n\t\tlist_create(&clones_list, sizeof (clones_t),\n\t\t    offsetof(clones_t, node));\n\n\t\terror = check_filesystem(spa, top_affected_fs, zep,\n\t\t    uaddr, count, &clones_list);\n\n\t\twhile ((ct = list_remove_head(&clones_list)) != NULL) {\n\t\t\terror = check_filesystem(spa, ct->clone_ds, zep,\n\t\t\t    uaddr, count, &clones_list);\n\t\t\tkmem_free(ct, sizeof (*ct));\n\n\t\t\tif (error) {\n\t\t\t\twhile (!list_is_empty(&clones_list)) {\n\t\t\t\t\tct = list_remove_head(&clones_list);\n\t\t\t\t\tkmem_free(ct, sizeof (*ct));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlist_destroy(&clones_list);\n\t}\n\tif (error == 0 && init_count == *count) {\n\t\t \n\t\tzbookmark_phys_t zb;\n\t\tzep_to_zb(head_ds, zep, &zb);\n\t\tspa_remove_error(spa, &zb, &zep->zb_birth);\n\t}\n\n\treturn (error);\n}\n#endif\n\n \nuint64_t\nspa_get_last_errlog_size(spa_t *spa)\n{\n\tuint64_t total = 0, count;\n\tmutex_enter(&spa->spa_errlog_lock);\n\n\tif (spa->spa_errlog_last != 0 &&\n\t    zap_count(spa->spa_meta_objset, spa->spa_errlog_last,\n\t    &count) == 0)\n\t\ttotal += count;\n\tmutex_exit(&spa->spa_errlog_lock);\n\treturn (total);\n}\n\n \nstatic void\nspa_add_healed_error(spa_t *spa, uint64_t obj, zbookmark_phys_t *healed_zb,\n    const uint64_t *birth)\n{\n\tchar name[NAME_MAX_LEN];\n\n\tif (obj == 0)\n\t\treturn;\n\n\tboolean_t held_list = B_FALSE;\n\tboolean_t held_log = B_FALSE;\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tbookmark_to_name(healed_zb, name, sizeof (name));\n\n\t\tif (zap_contains(spa->spa_meta_objset, healed_zb->zb_objset,\n\t\t    name) == 0) {\n\t\t\tif (!MUTEX_HELD(&spa->spa_errlog_lock)) {\n\t\t\t\tmutex_enter(&spa->spa_errlog_lock);\n\t\t\t\theld_log = B_TRUE;\n\t\t\t}\n\n\t\t\t \n\t\t\tavl_tree_t *tree = &spa->spa_errlist_healed;\n\t\t\tspa_error_entry_t search;\n\t\t\tspa_error_entry_t *new;\n\t\t\tavl_index_t where;\n\t\t\tsearch.se_bookmark = *healed_zb;\n\t\t\tif (!MUTEX_HELD(&spa->spa_errlist_lock)) {\n\t\t\t\tmutex_enter(&spa->spa_errlist_lock);\n\t\t\t\theld_list = B_TRUE;\n\t\t\t}\n\t\t\tif (avl_find(tree, &search, &where) != NULL) {\n\t\t\t\tif (held_list)\n\t\t\t\t\tmutex_exit(&spa->spa_errlist_lock);\n\t\t\t\tif (held_log)\n\t\t\t\t\tmutex_exit(&spa->spa_errlog_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnew = kmem_zalloc(sizeof (spa_error_entry_t), KM_SLEEP);\n\t\t\tnew->se_bookmark = *healed_zb;\n\t\t\tavl_insert(tree, new, where);\n\t\t\tif (held_list)\n\t\t\t\tmutex_exit(&spa->spa_errlist_lock);\n\t\t\tif (held_log)\n\t\t\t\tmutex_exit(&spa->spa_errlog_lock);\n\t\t}\n\t\treturn;\n\t}\n\n\tzbookmark_err_phys_t healed_zep;\n\thealed_zep.zb_object = healed_zb->zb_object;\n\thealed_zep.zb_level = healed_zb->zb_level;\n\thealed_zep.zb_blkid = healed_zb->zb_blkid;\n\n\tif (birth != NULL)\n\t\thealed_zep.zb_birth = *birth;\n\telse\n\t\thealed_zep.zb_birth = 0;\n\n\terrphys_to_name(&healed_zep, name, sizeof (name));\n\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tfor (zap_cursor_init(&zc, spa->spa_meta_objset, spa->spa_errlog_last);\n\t    zap_cursor_retrieve(&zc, &za) == 0; zap_cursor_advance(&zc)) {\n\t\tif (zap_contains(spa->spa_meta_objset, za.za_first_integer,\n\t\t    name) == 0) {\n\t\t\tif (!MUTEX_HELD(&spa->spa_errlog_lock)) {\n\t\t\t\tmutex_enter(&spa->spa_errlog_lock);\n\t\t\t\theld_log = B_TRUE;\n\t\t\t}\n\n\t\t\tavl_tree_t *tree = &spa->spa_errlist_healed;\n\t\t\tspa_error_entry_t search;\n\t\t\tspa_error_entry_t *new;\n\t\t\tavl_index_t where;\n\t\t\tsearch.se_bookmark = *healed_zb;\n\n\t\t\tif (!MUTEX_HELD(&spa->spa_errlist_lock)) {\n\t\t\t\tmutex_enter(&spa->spa_errlist_lock);\n\t\t\t\theld_list = B_TRUE;\n\t\t\t}\n\n\t\t\tif (avl_find(tree, &search, &where) != NULL) {\n\t\t\t\tif (held_list)\n\t\t\t\t\tmutex_exit(&spa->spa_errlist_lock);\n\t\t\t\tif (held_log)\n\t\t\t\t\tmutex_exit(&spa->spa_errlog_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew = kmem_zalloc(sizeof (spa_error_entry_t), KM_SLEEP);\n\t\t\tnew->se_bookmark = *healed_zb;\n\t\t\tnew->se_zep = healed_zep;\n\t\t\tavl_insert(tree, new, where);\n\n\t\t\tif (held_list)\n\t\t\t\tmutex_exit(&spa->spa_errlist_lock);\n\t\t\tif (held_log)\n\t\t\t\tmutex_exit(&spa->spa_errlog_lock);\n\t\t}\n\t}\n\tzap_cursor_fini(&zc);\n}\n\n \nstatic void\nremove_error_from_list(spa_t *spa, avl_tree_t *t, const zbookmark_phys_t *zb)\n{\n\tspa_error_entry_t search, *found;\n\tavl_index_t where;\n\n\tmutex_enter(&spa->spa_errlist_lock);\n\tsearch.se_bookmark = *zb;\n\tif ((found = avl_find(t, &search, &where)) != NULL) {\n\t\tavl_remove(t, found);\n\t\tkmem_free(found, sizeof (spa_error_entry_t));\n\t}\n\tmutex_exit(&spa->spa_errlist_lock);\n}\n\n\n \nstatic void\nspa_remove_healed_errors(spa_t *spa, avl_tree_t *s, avl_tree_t *l, dmu_tx_t *tx)\n{\n\tchar name[NAME_MAX_LEN];\n\tspa_error_entry_t *se;\n\tvoid *cookie = NULL;\n\n\tASSERT(MUTEX_HELD(&spa->spa_errlog_lock));\n\n\twhile ((se = avl_destroy_nodes(&spa->spa_errlist_healed,\n\t    &cookie)) != NULL) {\n\t\tremove_error_from_list(spa, s, &se->se_bookmark);\n\t\tremove_error_from_list(spa, l, &se->se_bookmark);\n\n\t\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\t\tbookmark_to_name(&se->se_bookmark, name, sizeof (name));\n\t\t\t(void) zap_remove(spa->spa_meta_objset,\n\t\t\t    spa->spa_errlog_last, name, tx);\n\t\t\t(void) zap_remove(spa->spa_meta_objset,\n\t\t\t    spa->spa_errlog_scrub, name, tx);\n\t\t} else {\n\t\t\terrphys_to_name(&se->se_zep, name, sizeof (name));\n\t\t\tzap_cursor_t zc;\n\t\t\tzap_attribute_t za;\n\t\t\tfor (zap_cursor_init(&zc, spa->spa_meta_objset,\n\t\t\t    spa->spa_errlog_last);\n\t\t\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t\t\t    zap_cursor_advance(&zc)) {\n\t\t\t\tzap_remove(spa->spa_meta_objset,\n\t\t\t\t    za.za_first_integer, name, tx);\n\t\t\t}\n\t\t\tzap_cursor_fini(&zc);\n\n\t\t\tfor (zap_cursor_init(&zc, spa->spa_meta_objset,\n\t\t\t    spa->spa_errlog_scrub);\n\t\t\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t\t\t    zap_cursor_advance(&zc)) {\n\t\t\t\tzap_remove(spa->spa_meta_objset,\n\t\t\t\t    za.za_first_integer, name, tx);\n\t\t\t}\n\t\t\tzap_cursor_fini(&zc);\n\t\t}\n\t\tkmem_free(se, sizeof (spa_error_entry_t));\n\t}\n}\n\n \nvoid\nspa_remove_error(spa_t *spa, zbookmark_phys_t *zb, const uint64_t *birth)\n{\n\tspa_add_healed_error(spa, spa->spa_errlog_last, zb, birth);\n\tspa_add_healed_error(spa, spa->spa_errlog_scrub, zb, birth);\n}\n\nstatic uint64_t\napprox_errlog_size_impl(spa_t *spa, uint64_t spa_err_obj)\n{\n\tif (spa_err_obj == 0)\n\t\treturn (0);\n\tuint64_t total = 0;\n\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tfor (zap_cursor_init(&zc, spa->spa_meta_objset, spa_err_obj);\n\t    zap_cursor_retrieve(&zc, &za) == 0; zap_cursor_advance(&zc)) {\n\t\tuint64_t count;\n\t\tif (zap_count(spa->spa_meta_objset, za.za_first_integer,\n\t\t    &count) == 0)\n\t\t\ttotal += count;\n\t}\n\tzap_cursor_fini(&zc);\n\treturn (total);\n}\n\n \nuint64_t\nspa_approx_errlog_size(spa_t *spa)\n{\n\tuint64_t total = 0;\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tmutex_enter(&spa->spa_errlog_lock);\n\t\tuint64_t count;\n\t\tif (spa->spa_errlog_scrub != 0 &&\n\t\t    zap_count(spa->spa_meta_objset, spa->spa_errlog_scrub,\n\t\t    &count) == 0)\n\t\t\ttotal += count;\n\n\t\tif (spa->spa_errlog_last != 0 && !spa->spa_scrub_finished &&\n\t\t    zap_count(spa->spa_meta_objset, spa->spa_errlog_last,\n\t\t    &count) == 0)\n\t\t\ttotal += count;\n\t\tmutex_exit(&spa->spa_errlog_lock);\n\n\t} else {\n\t\tmutex_enter(&spa->spa_errlog_lock);\n\t\ttotal += approx_errlog_size_impl(spa, spa->spa_errlog_last);\n\t\ttotal += approx_errlog_size_impl(spa, spa->spa_errlog_scrub);\n\t\tmutex_exit(&spa->spa_errlog_lock);\n\t}\n\tmutex_enter(&spa->spa_errlist_lock);\n\ttotal += avl_numnodes(&spa->spa_errlist_last);\n\ttotal += avl_numnodes(&spa->spa_errlist_scrub);\n\tmutex_exit(&spa->spa_errlist_lock);\n\treturn (total);\n}\n\n \nstatic void\nsync_upgrade_errlog(spa_t *spa, uint64_t spa_err_obj, uint64_t *newobj,\n    dmu_tx_t *tx)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tzbookmark_phys_t zb;\n\tuint64_t count;\n\n\t*newobj = zap_create(spa->spa_meta_objset, DMU_OT_ERROR_LOG,\n\t    DMU_OT_NONE, 0, tx);\n\n\t \n\tif (zap_count(spa->spa_meta_objset, spa_err_obj, &count) != 0) {\n\t\tVERIFY0(dmu_object_free(spa->spa_meta_objset, spa_err_obj, tx));\n\t\treturn;\n\t}\n\n\tfor (zap_cursor_init(&zc, spa->spa_meta_objset, spa_err_obj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tif (spa_upgrade_errlog_limit != 0 &&\n\t\t    zc.zc_cd == spa_upgrade_errlog_limit)\n\t\t\tbreak;\n\n\t\tname_to_bookmark(za.za_name, &zb);\n\n\t\tzbookmark_err_phys_t zep;\n\t\tzep.zb_object = zb.zb_object;\n\t\tzep.zb_level = zb.zb_level;\n\t\tzep.zb_blkid = zb.zb_blkid;\n\t\tzep.zb_birth = 0;\n\n\t\t \n\t\tuint64_t head_ds;\n\t\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\t\tdsl_dataset_t *ds;\n\t\tobjset_t *os;\n\n\t\tint error = dsl_dataset_hold_obj_flags(dp, zb.zb_objset,\n\t\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\t\tif (error != 0)\n\t\t\tcontinue;\n\n\t\thead_ds = dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj;\n\n\t\t \n\t\tif (dmu_objset_from_ds(ds, &os) != 0) {\n\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdnode_t *dn;\n\t\tblkptr_t bp;\n\n\t\tif (dnode_hold(os, zep.zb_object, FTAG, &dn) != 0) {\n\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\terror = dbuf_dnode_findbp(dn, zep.zb_level, zep.zb_blkid, &bp,\n\t\t    NULL, NULL);\n\t\tif (error == EACCES)\n\t\t\terror = 0;\n\t\telse if (!error)\n\t\t\tzep.zb_birth = bp.blk_birth;\n\n\t\trw_exit(&dn->dn_struct_rwlock);\n\t\tdnode_rele(dn, FTAG);\n\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\n\t\tif (error != 0 || BP_IS_HOLE(&bp))\n\t\t\tcontinue;\n\n\t\tuint64_t err_obj;\n\t\terror = zap_lookup_int_key(spa->spa_meta_objset, *newobj,\n\t\t    head_ds, &err_obj);\n\n\t\tif (error == ENOENT) {\n\t\t\terr_obj = zap_create(spa->spa_meta_objset,\n\t\t\t    DMU_OT_ERROR_LOG, DMU_OT_NONE, 0, tx);\n\n\t\t\t(void) zap_update_int_key(spa->spa_meta_objset,\n\t\t\t    *newobj, head_ds, err_obj, tx);\n\t\t}\n\n\t\tchar buf[64];\n\t\terrphys_to_name(&zep, buf, sizeof (buf));\n\n\t\tconst char *name = \"\";\n\t\t(void) zap_update(spa->spa_meta_objset, err_obj,\n\t\t    buf, 1, strlen(name) + 1, name, tx);\n\t}\n\tzap_cursor_fini(&zc);\n\n\tVERIFY0(dmu_object_free(spa->spa_meta_objset, spa_err_obj, tx));\n}\n\nvoid\nspa_upgrade_errlog(spa_t *spa, dmu_tx_t *tx)\n{\n\tuint64_t newobj = 0;\n\n\tmutex_enter(&spa->spa_errlog_lock);\n\tif (spa->spa_errlog_last != 0) {\n\t\tsync_upgrade_errlog(spa, spa->spa_errlog_last, &newobj, tx);\n\t\tspa->spa_errlog_last = newobj;\n\n\t\t(void) zap_update(spa->spa_meta_objset,\n\t\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_ERRLOG_LAST,\n\t\t    sizeof (uint64_t), 1, &spa->spa_errlog_last, tx);\n\t}\n\n\tif (spa->spa_errlog_scrub != 0) {\n\t\tsync_upgrade_errlog(spa, spa->spa_errlog_scrub, &newobj, tx);\n\t\tspa->spa_errlog_scrub = newobj;\n\n\t\t(void) zap_update(spa->spa_meta_objset,\n\t\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_ERRLOG_SCRUB,\n\t\t    sizeof (uint64_t), 1, &spa->spa_errlog_scrub, tx);\n\t}\n\n\tmutex_exit(&spa->spa_errlog_lock);\n}\n\n#ifdef _KERNEL\n \nstatic int\nprocess_error_log(spa_t *spa, uint64_t obj, void *uaddr, uint64_t *count)\n{\n\tif (obj == 0)\n\t\treturn (0);\n\n\tzap_cursor_t *zc;\n\tzap_attribute_t *za;\n\n\tzc = kmem_zalloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tza = kmem_zalloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tfor (zap_cursor_init(zc, spa->spa_meta_objset, obj);\n\t\t    zap_cursor_retrieve(zc, za) == 0;\n\t\t    zap_cursor_advance(zc)) {\n\t\t\tif (*count == 0) {\n\t\t\t\tzap_cursor_fini(zc);\n\t\t\t\tkmem_free(zc, sizeof (*zc));\n\t\t\t\tkmem_free(za, sizeof (*za));\n\t\t\t\treturn (SET_ERROR(ENOMEM));\n\t\t\t}\n\n\t\t\tzbookmark_phys_t zb;\n\t\t\tname_to_bookmark(za->za_name, &zb);\n\n\t\t\tint error = copyout_entry(&zb, uaddr, count);\n\t\t\tif (error != 0) {\n\t\t\t\tzap_cursor_fini(zc);\n\t\t\t\tkmem_free(zc, sizeof (*zc));\n\t\t\t\tkmem_free(za, sizeof (*za));\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\tzap_cursor_fini(zc);\n\t\tkmem_free(zc, sizeof (*zc));\n\t\tkmem_free(za, sizeof (*za));\n\t\treturn (0);\n\t}\n\n\tfor (zap_cursor_init(zc, spa->spa_meta_objset, obj);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\n\t\tzap_cursor_t *head_ds_cursor;\n\t\tzap_attribute_t *head_ds_attr;\n\n\t\thead_ds_cursor = kmem_zalloc(sizeof (zap_cursor_t), KM_SLEEP);\n\t\thead_ds_attr = kmem_zalloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\t\tuint64_t head_ds_err_obj = za->za_first_integer;\n\t\tuint64_t head_ds;\n\t\tname_to_object(za->za_name, &head_ds);\n\t\tfor (zap_cursor_init(head_ds_cursor, spa->spa_meta_objset,\n\t\t    head_ds_err_obj); zap_cursor_retrieve(head_ds_cursor,\n\t\t    head_ds_attr) == 0; zap_cursor_advance(head_ds_cursor)) {\n\n\t\t\tzbookmark_err_phys_t head_ds_block;\n\t\t\tname_to_errphys(head_ds_attr->za_name, &head_ds_block);\n\t\t\tint error = process_error_block(spa, head_ds,\n\t\t\t    &head_ds_block, uaddr, count);\n\n\t\t\tif (error != 0) {\n\t\t\t\tzap_cursor_fini(head_ds_cursor);\n\t\t\t\tkmem_free(head_ds_cursor,\n\t\t\t\t    sizeof (*head_ds_cursor));\n\t\t\t\tkmem_free(head_ds_attr, sizeof (*head_ds_attr));\n\n\t\t\t\tzap_cursor_fini(zc);\n\t\t\t\tkmem_free(za, sizeof (*za));\n\t\t\t\tkmem_free(zc, sizeof (*zc));\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\tzap_cursor_fini(head_ds_cursor);\n\t\tkmem_free(head_ds_cursor, sizeof (*head_ds_cursor));\n\t\tkmem_free(head_ds_attr, sizeof (*head_ds_attr));\n\t}\n\tzap_cursor_fini(zc);\n\tkmem_free(za, sizeof (*za));\n\tkmem_free(zc, sizeof (*zc));\n\treturn (0);\n}\n\nstatic int\nprocess_error_list(spa_t *spa, avl_tree_t *list, void *uaddr, uint64_t *count)\n{\n\tspa_error_entry_t *se;\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tfor (se = avl_first(list); se != NULL;\n\t\t    se = AVL_NEXT(list, se)) {\n\t\t\tint error =\n\t\t\t    copyout_entry(&se->se_bookmark, uaddr, count);\n\t\t\tif (error != 0) {\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\treturn (0);\n\t}\n\n\tfor (se = avl_first(list); se != NULL; se = AVL_NEXT(list, se)) {\n\t\tuint64_t head_ds = 0;\n\t\tint error = get_head_ds(spa, se->se_bookmark.zb_objset,\n\t\t    &head_ds);\n\n\t\t \n\t\tif (error != 0)\n\t\t\thead_ds = se->se_bookmark.zb_objset;\n\n\t\terror = process_error_block(spa, head_ds,\n\t\t    &se->se_zep, uaddr, count);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\treturn (0);\n}\n#endif\n\n \nint\nspa_get_errlog(spa_t *spa, void *uaddr, uint64_t *count)\n{\n\tint ret = 0;\n\n#ifdef _KERNEL\n\t \n\tdsl_pool_config_enter(spa->spa_dsl_pool, FTAG);\n\tmutex_enter(&spa->spa_errlog_lock);\n\n\tret = process_error_log(spa, spa->spa_errlog_scrub, uaddr, count);\n\n\tif (!ret && !spa->spa_scrub_finished)\n\t\tret = process_error_log(spa, spa->spa_errlog_last, uaddr,\n\t\t    count);\n\n\tmutex_enter(&spa->spa_errlist_lock);\n\tif (!ret)\n\t\tret = process_error_list(spa, &spa->spa_errlist_scrub, uaddr,\n\t\t    count);\n\tif (!ret)\n\t\tret = process_error_list(spa, &spa->spa_errlist_last, uaddr,\n\t\t    count);\n\tmutex_exit(&spa->spa_errlist_lock);\n\n\tmutex_exit(&spa->spa_errlog_lock);\n\tdsl_pool_config_exit(spa->spa_dsl_pool, FTAG);\n#else\n\t(void) spa, (void) uaddr, (void) count;\n#endif\n\n\treturn (ret);\n}\n\n \nvoid\nspa_errlog_rotate(spa_t *spa)\n{\n\tmutex_enter(&spa->spa_errlist_lock);\n\tspa->spa_scrub_finished = B_TRUE;\n\tmutex_exit(&spa->spa_errlist_lock);\n}\n\n \nvoid\nspa_errlog_drain(spa_t *spa)\n{\n\tspa_error_entry_t *se;\n\tvoid *cookie;\n\n\tmutex_enter(&spa->spa_errlist_lock);\n\n\tcookie = NULL;\n\twhile ((se = avl_destroy_nodes(&spa->spa_errlist_last,\n\t    &cookie)) != NULL)\n\t\tkmem_free(se, sizeof (spa_error_entry_t));\n\tcookie = NULL;\n\twhile ((se = avl_destroy_nodes(&spa->spa_errlist_scrub,\n\t    &cookie)) != NULL)\n\t\tkmem_free(se, sizeof (spa_error_entry_t));\n\n\tmutex_exit(&spa->spa_errlist_lock);\n}\n\n \nvoid\nsync_error_list(spa_t *spa, avl_tree_t *t, uint64_t *obj, dmu_tx_t *tx)\n{\n\tspa_error_entry_t *se;\n\tchar buf[NAME_MAX_LEN];\n\tvoid *cookie;\n\n\tif (avl_numnodes(t) == 0)\n\t\treturn;\n\n\t \n\tif (*obj == 0)\n\t\t*obj = zap_create(spa->spa_meta_objset, DMU_OT_ERROR_LOG,\n\t\t    DMU_OT_NONE, 0, tx);\n\n\t \n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tfor (se = avl_first(t); se != NULL; se = AVL_NEXT(t, se)) {\n\t\t\tbookmark_to_name(&se->se_bookmark, buf, sizeof (buf));\n\n\t\t\tconst char *name = se->se_name ? se->se_name : \"\";\n\t\t\t(void) zap_update(spa->spa_meta_objset, *obj, buf, 1,\n\t\t\t    strlen(name) + 1, name, tx);\n\t\t}\n\t} else {\n\t\tfor (se = avl_first(t); se != NULL; se = AVL_NEXT(t, se)) {\n\t\t\tzbookmark_err_phys_t zep;\n\t\t\tzep.zb_object = se->se_zep.zb_object;\n\t\t\tzep.zb_level = se->se_zep.zb_level;\n\t\t\tzep.zb_blkid = se->se_zep.zb_blkid;\n\t\t\tzep.zb_birth = se->se_zep.zb_birth;\n\n\t\t\tuint64_t head_ds = 0;\n\t\t\tint error = get_head_ds(spa, se->se_bookmark.zb_objset,\n\t\t\t    &head_ds);\n\n\t\t\t \n\t\t\tif (error != 0)\n\t\t\t\thead_ds = se->se_bookmark.zb_objset;\n\n\t\t\tuint64_t err_obj;\n\t\t\terror = zap_lookup_int_key(spa->spa_meta_objset,\n\t\t\t    *obj, head_ds, &err_obj);\n\n\t\t\tif (error == ENOENT) {\n\t\t\t\terr_obj = zap_create(spa->spa_meta_objset,\n\t\t\t\t    DMU_OT_ERROR_LOG, DMU_OT_NONE, 0, tx);\n\n\t\t\t\t(void) zap_update_int_key(spa->spa_meta_objset,\n\t\t\t\t    *obj, head_ds, err_obj, tx);\n\t\t\t}\n\t\t\terrphys_to_name(&zep, buf, sizeof (buf));\n\n\t\t\tconst char *name = se->se_name ? se->se_name : \"\";\n\t\t\t(void) zap_update(spa->spa_meta_objset,\n\t\t\t    err_obj, buf, 1, strlen(name) + 1, name, tx);\n\t\t}\n\t}\n\t \n\tcookie = NULL;\n\twhile ((se = avl_destroy_nodes(t, &cookie)) != NULL)\n\t\tkmem_free(se, sizeof (spa_error_entry_t));\n}\n\nstatic void\ndelete_errlog(spa_t *spa, uint64_t spa_err_obj, dmu_tx_t *tx)\n{\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tzap_cursor_t zc;\n\t\tzap_attribute_t za;\n\t\tfor (zap_cursor_init(&zc, spa->spa_meta_objset, spa_err_obj);\n\t\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t\t    zap_cursor_advance(&zc)) {\n\t\t\tVERIFY0(dmu_object_free(spa->spa_meta_objset,\n\t\t\t    za.za_first_integer, tx));\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\t}\n\tVERIFY0(dmu_object_free(spa->spa_meta_objset, spa_err_obj, tx));\n}\n\n \nvoid\nspa_errlog_sync(spa_t *spa, uint64_t txg)\n{\n\tdmu_tx_t *tx;\n\tavl_tree_t scrub, last;\n\tint scrub_finished;\n\n\tmutex_enter(&spa->spa_errlist_lock);\n\n\t \n\tif (avl_numnodes(&spa->spa_errlist_scrub) == 0 &&\n\t    avl_numnodes(&spa->spa_errlist_last) == 0 &&\n\t    avl_numnodes(&spa->spa_errlist_healed) == 0 &&\n\t    !spa->spa_scrub_finished) {\n\t\tmutex_exit(&spa->spa_errlist_lock);\n\t\treturn;\n\t}\n\n\tspa_get_errlists(spa, &last, &scrub);\n\tscrub_finished = spa->spa_scrub_finished;\n\tspa->spa_scrub_finished = B_FALSE;\n\n\tmutex_exit(&spa->spa_errlist_lock);\n\n\t \n\tdsl_pool_config_enter(spa->spa_dsl_pool, FTAG);\n\tmutex_enter(&spa->spa_errlog_lock);\n\n\ttx = dmu_tx_create_assigned(spa->spa_dsl_pool, txg);\n\n\t \n\tspa_remove_healed_errors(spa, &last, &scrub, tx);\n\n\t \n\tsync_error_list(spa, &last, &spa->spa_errlog_last, tx);\n\n\t \n\tif (scrub_finished) {\n\t\tif (spa->spa_errlog_last != 0)\n\t\t\tdelete_errlog(spa, spa->spa_errlog_last, tx);\n\t\tspa->spa_errlog_last = spa->spa_errlog_scrub;\n\t\tspa->spa_errlog_scrub = 0;\n\n\t\tsync_error_list(spa, &scrub, &spa->spa_errlog_last, tx);\n\t}\n\n\t \n\tsync_error_list(spa, &scrub, &spa->spa_errlog_scrub, tx);\n\n\t \n\t(void) zap_update(spa->spa_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_ERRLOG_LAST, sizeof (uint64_t), 1,\n\t    &spa->spa_errlog_last, tx);\n\t(void) zap_update(spa->spa_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_ERRLOG_SCRUB, sizeof (uint64_t), 1,\n\t    &spa->spa_errlog_scrub, tx);\n\n\tdmu_tx_commit(tx);\n\n\tmutex_exit(&spa->spa_errlog_lock);\n\tdsl_pool_config_exit(spa->spa_dsl_pool, FTAG);\n}\n\nstatic void\ndelete_dataset_errlog(spa_t *spa, uint64_t spa_err_obj, uint64_t ds,\n    dmu_tx_t *tx)\n{\n\tif (spa_err_obj == 0)\n\t\treturn;\n\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tfor (zap_cursor_init(&zc, spa->spa_meta_objset, spa_err_obj);\n\t    zap_cursor_retrieve(&zc, &za) == 0; zap_cursor_advance(&zc)) {\n\t\tuint64_t head_ds;\n\t\tname_to_object(za.za_name, &head_ds);\n\t\tif (head_ds == ds) {\n\t\t\t(void) zap_remove(spa->spa_meta_objset, spa_err_obj,\n\t\t\t    za.za_name, tx);\n\t\t\tVERIFY0(dmu_object_free(spa->spa_meta_objset,\n\t\t\t    za.za_first_integer, tx));\n\t\t\tbreak;\n\t\t}\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nvoid\nspa_delete_dataset_errlog(spa_t *spa, uint64_t ds, dmu_tx_t *tx)\n{\n\tmutex_enter(&spa->spa_errlog_lock);\n\tdelete_dataset_errlog(spa, spa->spa_errlog_scrub, ds, tx);\n\tdelete_dataset_errlog(spa, spa->spa_errlog_last, ds, tx);\n\tmutex_exit(&spa->spa_errlog_lock);\n}\n\nstatic int\nfind_txg_ancestor_snapshot(spa_t *spa, uint64_t new_head, uint64_t old_head,\n    uint64_t *txg)\n{\n\tdsl_dataset_t *ds;\n\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\n\tint error = dsl_dataset_hold_obj_flags(dp, old_head,\n\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tuint64_t prev_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\tuint64_t prev_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\n\twhile (prev_obj != 0) {\n\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\tif ((error = dsl_dataset_hold_obj_flags(dp, prev_obj,\n\t\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds)) == 0 &&\n\t\t    dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj == new_head)\n\t\t\tbreak;\n\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\tprev_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t\tprev_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t}\n\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\tASSERT(prev_obj != 0);\n\t*txg = prev_obj_txg;\n\treturn (0);\n}\n\nstatic void\nswap_errlog(spa_t *spa, uint64_t spa_err_obj, uint64_t new_head, uint64_t\n    old_head, dmu_tx_t *tx)\n{\n\tif (spa_err_obj == 0)\n\t\treturn;\n\n\tuint64_t old_head_errlog;\n\tint error = zap_lookup_int_key(spa->spa_meta_objset, spa_err_obj,\n\t    old_head, &old_head_errlog);\n\n\t \n\tif (error != 0)\n\t\treturn;\n\n\tuint64_t txg;\n\terror = find_txg_ancestor_snapshot(spa, new_head, old_head, &txg);\n\tif (error != 0)\n\t\treturn;\n\n\t \n\tuint64_t new_head_errlog;\n\terror = zap_lookup_int_key(spa->spa_meta_objset, spa_err_obj, new_head,\n\t    &new_head_errlog);\n\n\tif (error != 0) {\n\t\tnew_head_errlog = zap_create(spa->spa_meta_objset,\n\t\t    DMU_OT_ERROR_LOG, DMU_OT_NONE, 0, tx);\n\n\t\t(void) zap_update_int_key(spa->spa_meta_objset, spa_err_obj,\n\t\t    new_head, new_head_errlog, tx);\n\t}\n\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tzbookmark_err_phys_t err_block;\n\tfor (zap_cursor_init(&zc, spa->spa_meta_objset, old_head_errlog);\n\t    zap_cursor_retrieve(&zc, &za) == 0; zap_cursor_advance(&zc)) {\n\n\t\tconst char *name = \"\";\n\t\tname_to_errphys(za.za_name, &err_block);\n\t\tif (err_block.zb_birth < txg) {\n\t\t\t(void) zap_update(spa->spa_meta_objset, new_head_errlog,\n\t\t\t    za.za_name, 1, strlen(name) + 1, name, tx);\n\n\t\t\t(void) zap_remove(spa->spa_meta_objset, old_head_errlog,\n\t\t\t    za.za_name, tx);\n\t\t}\n\t}\n\tzap_cursor_fini(&zc);\n}\n\nvoid\nspa_swap_errlog(spa_t *spa, uint64_t new_head_ds, uint64_t old_head_ds,\n    dmu_tx_t *tx)\n{\n\tmutex_enter(&spa->spa_errlog_lock);\n\tswap_errlog(spa, spa->spa_errlog_scrub, new_head_ds, old_head_ds, tx);\n\tswap_errlog(spa, spa->spa_errlog_last, new_head_ds, old_head_ds, tx);\n\tmutex_exit(&spa->spa_errlog_lock);\n}\n\n#if defined(_KERNEL)\n \nEXPORT_SYMBOL(spa_log_error);\nEXPORT_SYMBOL(spa_approx_errlog_size);\nEXPORT_SYMBOL(spa_get_last_errlog_size);\nEXPORT_SYMBOL(spa_get_errlog);\nEXPORT_SYMBOL(spa_errlog_rotate);\nEXPORT_SYMBOL(spa_errlog_drain);\nEXPORT_SYMBOL(spa_errlog_sync);\nEXPORT_SYMBOL(spa_get_errlists);\nEXPORT_SYMBOL(spa_delete_dataset_errlog);\nEXPORT_SYMBOL(spa_swap_errlog);\nEXPORT_SYMBOL(sync_error_list);\nEXPORT_SYMBOL(spa_upgrade_errlog);\nEXPORT_SYMBOL(find_top_affected_fs);\nEXPORT_SYMBOL(find_birth_txg);\nEXPORT_SYMBOL(zep_to_zb);\nEXPORT_SYMBOL(name_to_errphys);\n#endif\n\n \nZFS_MODULE_PARAM(zfs_spa, spa_, upgrade_errlog_limit, UINT, ZMOD_RW,\n\t\"Limit the number of errors which will be upgraded to the new \"\n\t\"on-disk error log when enabling head_errlog\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}