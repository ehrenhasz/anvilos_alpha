{
  "module_name": "zap.c",
  "hash_id": "1a155df0071d9b2698c14069b57021da6396989bc4c6172e9ffec07112c68eba",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zap.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_znode.h>\n#include <sys/fs/zfs.h>\n#include <sys/zap.h>\n#include <sys/zap_impl.h>\n#include <sys/zap_leaf.h>\n\n \nstatic int zap_iterate_prefetch = B_TRUE;\n\nint fzap_default_block_shift = 14;  \n\nstatic uint64_t zap_allocate_blocks(zap_t *zap, int nblocks);\n\nvoid\nfzap_byteswap(void *vbuf, size_t size)\n{\n\tuint64_t block_type = *(uint64_t *)vbuf;\n\n\tif (block_type == ZBT_LEAF || block_type == BSWAP_64(ZBT_LEAF))\n\t\tzap_leaf_byteswap(vbuf, size);\n\telse {\n\t\t \n\t\tbyteswap_uint64_array(vbuf, size);\n\t}\n}\n\nvoid\nfzap_upgrade(zap_t *zap, dmu_tx_t *tx, zap_flags_t flags)\n{\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\tzap->zap_ismicro = FALSE;\n\n\tzap->zap_dbu.dbu_evict_func_sync = zap_evict_sync;\n\tzap->zap_dbu.dbu_evict_func_async = NULL;\n\n\tmutex_init(&zap->zap_f.zap_num_entries_mtx, 0, MUTEX_DEFAULT, 0);\n\tzap->zap_f.zap_block_shift = highbit64(zap->zap_dbuf->db_size) - 1;\n\n\tzap_phys_t *zp = zap_f_phys(zap);\n\t \n\tmemset(zap->zap_dbuf->db_data, 0, zap->zap_dbuf->db_size);\n\tzp->zap_block_type = ZBT_HEADER;\n\tzp->zap_magic = ZAP_MAGIC;\n\n\tzp->zap_ptrtbl.zt_shift = ZAP_EMBEDDED_PTRTBL_SHIFT(zap);\n\n\tzp->zap_freeblk = 2;\t\t \n\tzp->zap_num_leafs = 1;\n\tzp->zap_num_entries = 0;\n\tzp->zap_salt = zap->zap_salt;\n\tzp->zap_normflags = zap->zap_normflags;\n\tzp->zap_flags = flags;\n\n\t \n\tfor (int i = 0; i < (1<<zp->zap_ptrtbl.zt_shift); i++)\n\t\tZAP_EMBEDDED_PTRTBL_ENT(zap, i) = 1;\n\n\t \n\tdmu_buf_t *db;\n\tVERIFY0(dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t    1<<FZAP_BLOCK_SHIFT(zap), FTAG, &db, DMU_READ_NO_PREFETCH));\n\tdmu_buf_will_dirty(db, tx);\n\n\tzap_leaf_t *l = kmem_zalloc(sizeof (zap_leaf_t), KM_SLEEP);\n\tl->l_dbuf = db;\n\n\tzap_leaf_init(l, zp->zap_normflags != 0);\n\n\tkmem_free(l, sizeof (zap_leaf_t));\n\tdmu_buf_rele(db, FTAG);\n}\n\nstatic int\nzap_tryupgradedir(zap_t *zap, dmu_tx_t *tx)\n{\n\tif (RW_WRITE_HELD(&zap->zap_rwlock))\n\t\treturn (1);\n\tif (rw_tryupgrade(&zap->zap_rwlock)) {\n\t\tdmu_buf_will_dirty(zap->zap_dbuf, tx);\n\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n \n\nstatic int\nzap_table_grow(zap_t *zap, zap_table_phys_t *tbl,\n    void (*transfer_func)(const uint64_t *src, uint64_t *dst, int n),\n    dmu_tx_t *tx)\n{\n\tuint64_t newblk;\n\tint bs = FZAP_BLOCK_SHIFT(zap);\n\tint hepb = 1<<(bs-4);\n\t \n\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\tASSERT(tbl->zt_blk != 0);\n\tASSERT(tbl->zt_numblks > 0);\n\n\tif (tbl->zt_nextblk != 0) {\n\t\tnewblk = tbl->zt_nextblk;\n\t} else {\n\t\tnewblk = zap_allocate_blocks(zap, tbl->zt_numblks * 2);\n\t\ttbl->zt_nextblk = newblk;\n\t\tASSERT0(tbl->zt_blks_copied);\n\t\tdmu_prefetch(zap->zap_objset, zap->zap_object, 0,\n\t\t    tbl->zt_blk << bs, tbl->zt_numblks << bs,\n\t\t    ZIO_PRIORITY_SYNC_READ);\n\t}\n\n\t \n\n\tuint64_t b = tbl->zt_blks_copied;\n\tdmu_buf_t *db_old;\n\tint err = dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t    (tbl->zt_blk + b) << bs, FTAG, &db_old, DMU_READ_NO_PREFETCH);\n\tif (err != 0)\n\t\treturn (err);\n\n\t \n\tdmu_buf_t *db_new;\n\tVERIFY0(dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t    (newblk + 2*b+0) << bs, FTAG, &db_new, DMU_READ_NO_PREFETCH));\n\tdmu_buf_will_dirty(db_new, tx);\n\ttransfer_func(db_old->db_data, db_new->db_data, hepb);\n\tdmu_buf_rele(db_new, FTAG);\n\n\t \n\tVERIFY0(dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t    (newblk + 2*b+1) << bs, FTAG, &db_new, DMU_READ_NO_PREFETCH));\n\tdmu_buf_will_dirty(db_new, tx);\n\ttransfer_func((uint64_t *)db_old->db_data + hepb,\n\t    db_new->db_data, hepb);\n\tdmu_buf_rele(db_new, FTAG);\n\n\tdmu_buf_rele(db_old, FTAG);\n\n\ttbl->zt_blks_copied++;\n\n\tdprintf(\"copied block %llu of %llu\\n\",\n\t    (u_longlong_t)tbl->zt_blks_copied,\n\t    (u_longlong_t)tbl->zt_numblks);\n\n\tif (tbl->zt_blks_copied == tbl->zt_numblks) {\n\t\t(void) dmu_free_range(zap->zap_objset, zap->zap_object,\n\t\t    tbl->zt_blk << bs, tbl->zt_numblks << bs, tx);\n\n\t\ttbl->zt_blk = newblk;\n\t\ttbl->zt_numblks *= 2;\n\t\ttbl->zt_shift++;\n\t\ttbl->zt_nextblk = 0;\n\t\ttbl->zt_blks_copied = 0;\n\n\t\tdprintf(\"finished; numblocks now %llu (%uk entries)\\n\",\n\t\t    (u_longlong_t)tbl->zt_numblks, 1<<(tbl->zt_shift-10));\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzap_table_store(zap_t *zap, zap_table_phys_t *tbl, uint64_t idx, uint64_t val,\n    dmu_tx_t *tx)\n{\n\tint bs = FZAP_BLOCK_SHIFT(zap);\n\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\tASSERT(tbl->zt_blk != 0);\n\n\tdprintf(\"storing %llx at index %llx\\n\", (u_longlong_t)val,\n\t    (u_longlong_t)idx);\n\n\tuint64_t blk = idx >> (bs-3);\n\tuint64_t off = idx & ((1<<(bs-3))-1);\n\n\tdmu_buf_t *db;\n\tint err = dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t    (tbl->zt_blk + blk) << bs, FTAG, &db, DMU_READ_NO_PREFETCH);\n\tif (err != 0)\n\t\treturn (err);\n\tdmu_buf_will_dirty(db, tx);\n\n\tif (tbl->zt_nextblk != 0) {\n\t\tuint64_t idx2 = idx * 2;\n\t\tuint64_t blk2 = idx2 >> (bs-3);\n\t\tuint64_t off2 = idx2 & ((1<<(bs-3))-1);\n\t\tdmu_buf_t *db2;\n\n\t\terr = dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t\t    (tbl->zt_nextblk + blk2) << bs, FTAG, &db2,\n\t\t    DMU_READ_NO_PREFETCH);\n\t\tif (err != 0) {\n\t\t\tdmu_buf_rele(db, FTAG);\n\t\t\treturn (err);\n\t\t}\n\t\tdmu_buf_will_dirty(db2, tx);\n\t\t((uint64_t *)db2->db_data)[off2] = val;\n\t\t((uint64_t *)db2->db_data)[off2+1] = val;\n\t\tdmu_buf_rele(db2, FTAG);\n\t}\n\n\t((uint64_t *)db->db_data)[off] = val;\n\tdmu_buf_rele(db, FTAG);\n\n\treturn (0);\n}\n\nstatic int\nzap_table_load(zap_t *zap, zap_table_phys_t *tbl, uint64_t idx, uint64_t *valp)\n{\n\tint bs = FZAP_BLOCK_SHIFT(zap);\n\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\n\tuint64_t blk = idx >> (bs-3);\n\tuint64_t off = idx & ((1<<(bs-3))-1);\n\n\t \n\tdnode_t *dn = dmu_buf_dnode_enter(zap->zap_dbuf);\n\tdmu_buf_t *db;\n\tint err = dmu_buf_hold_by_dnode(dn,\n\t    (tbl->zt_blk + blk) << bs, FTAG, &db, DMU_READ_NO_PREFETCH);\n\tdmu_buf_dnode_exit(zap->zap_dbuf);\n\tif (err != 0)\n\t\treturn (err);\n\t*valp = ((uint64_t *)db->db_data)[off];\n\tdmu_buf_rele(db, FTAG);\n\n\tif (tbl->zt_nextblk != 0) {\n\t\t \n\t\tblk = (idx*2) >> (bs-3);\n\n\t\tdn = dmu_buf_dnode_enter(zap->zap_dbuf);\n\t\terr = dmu_buf_hold_by_dnode(dn,\n\t\t    (tbl->zt_nextblk + blk) << bs, FTAG, &db,\n\t\t    DMU_READ_NO_PREFETCH);\n\t\tdmu_buf_dnode_exit(zap->zap_dbuf);\n\t\tif (err == 0)\n\t\t\tdmu_buf_rele(db, FTAG);\n\t}\n\treturn (err);\n}\n\n \n\nstatic void\nzap_ptrtbl_transfer(const uint64_t *src, uint64_t *dst, int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tuint64_t lb = src[i];\n\t\tdst[2 * i + 0] = lb;\n\t\tdst[2 * i + 1] = lb;\n\t}\n}\n\nstatic int\nzap_grow_ptrtbl(zap_t *zap, dmu_tx_t *tx)\n{\n\t \n\tif (zap_f_phys(zap)->zap_ptrtbl.zt_shift >= zap_hashbits(zap) - 2)\n\t\treturn (SET_ERROR(ENOSPC));\n\n\tif (zap_f_phys(zap)->zap_ptrtbl.zt_numblks == 0) {\n\t\t \n\t\tASSERT3U(zap_f_phys(zap)->zap_ptrtbl.zt_shift, ==,\n\t\t    ZAP_EMBEDDED_PTRTBL_SHIFT(zap));\n\t\tASSERT0(zap_f_phys(zap)->zap_ptrtbl.zt_blk);\n\n\t\tuint64_t newblk = zap_allocate_blocks(zap, 1);\n\t\tdmu_buf_t *db_new;\n\t\tint err = dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t\t    newblk << FZAP_BLOCK_SHIFT(zap), FTAG, &db_new,\n\t\t    DMU_READ_NO_PREFETCH);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t\tdmu_buf_will_dirty(db_new, tx);\n\t\tzap_ptrtbl_transfer(&ZAP_EMBEDDED_PTRTBL_ENT(zap, 0),\n\t\t    db_new->db_data, 1 << ZAP_EMBEDDED_PTRTBL_SHIFT(zap));\n\t\tdmu_buf_rele(db_new, FTAG);\n\n\t\tzap_f_phys(zap)->zap_ptrtbl.zt_blk = newblk;\n\t\tzap_f_phys(zap)->zap_ptrtbl.zt_numblks = 1;\n\t\tzap_f_phys(zap)->zap_ptrtbl.zt_shift++;\n\n\t\tASSERT3U(1ULL << zap_f_phys(zap)->zap_ptrtbl.zt_shift, ==,\n\t\t    zap_f_phys(zap)->zap_ptrtbl.zt_numblks <<\n\t\t    (FZAP_BLOCK_SHIFT(zap)-3));\n\n\t\treturn (0);\n\t} else {\n\t\treturn (zap_table_grow(zap, &zap_f_phys(zap)->zap_ptrtbl,\n\t\t    zap_ptrtbl_transfer, tx));\n\t}\n}\n\nstatic void\nzap_increment_num_entries(zap_t *zap, int delta, dmu_tx_t *tx)\n{\n\tdmu_buf_will_dirty(zap->zap_dbuf, tx);\n\tmutex_enter(&zap->zap_f.zap_num_entries_mtx);\n\tASSERT(delta > 0 || zap_f_phys(zap)->zap_num_entries >= -delta);\n\tzap_f_phys(zap)->zap_num_entries += delta;\n\tmutex_exit(&zap->zap_f.zap_num_entries_mtx);\n}\n\nstatic uint64_t\nzap_allocate_blocks(zap_t *zap, int nblocks)\n{\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\tuint64_t newblk = zap_f_phys(zap)->zap_freeblk;\n\tzap_f_phys(zap)->zap_freeblk += nblocks;\n\treturn (newblk);\n}\n\nstatic void\nzap_leaf_evict_sync(void *dbu)\n{\n\tzap_leaf_t *l = dbu;\n\n\trw_destroy(&l->l_rwlock);\n\tkmem_free(l, sizeof (zap_leaf_t));\n}\n\nstatic zap_leaf_t *\nzap_create_leaf(zap_t *zap, dmu_tx_t *tx)\n{\n\tzap_leaf_t *l = kmem_zalloc(sizeof (zap_leaf_t), KM_SLEEP);\n\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\n\trw_init(&l->l_rwlock, NULL, RW_NOLOCKDEP, NULL);\n\trw_enter(&l->l_rwlock, RW_WRITER);\n\tl->l_blkid = zap_allocate_blocks(zap, 1);\n\tl->l_dbuf = NULL;\n\n\tVERIFY0(dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t    l->l_blkid << FZAP_BLOCK_SHIFT(zap), NULL, &l->l_dbuf,\n\t    DMU_READ_NO_PREFETCH));\n\tdmu_buf_init_user(&l->l_dbu, zap_leaf_evict_sync, NULL, &l->l_dbuf);\n\tVERIFY3P(NULL, ==, dmu_buf_set_user(l->l_dbuf, &l->l_dbu));\n\tdmu_buf_will_dirty(l->l_dbuf, tx);\n\n\tzap_leaf_init(l, zap->zap_normflags != 0);\n\n\tzap_f_phys(zap)->zap_num_leafs++;\n\n\treturn (l);\n}\n\nint\nfzap_count(zap_t *zap, uint64_t *count)\n{\n\tASSERT(!zap->zap_ismicro);\n\tmutex_enter(&zap->zap_f.zap_num_entries_mtx);  \n\t*count = zap_f_phys(zap)->zap_num_entries;\n\tmutex_exit(&zap->zap_f.zap_num_entries_mtx);\n\treturn (0);\n}\n\n \n\nvoid\nzap_put_leaf(zap_leaf_t *l)\n{\n\trw_exit(&l->l_rwlock);\n\tdmu_buf_rele(l->l_dbuf, NULL);\n}\n\nstatic zap_leaf_t *\nzap_open_leaf(uint64_t blkid, dmu_buf_t *db)\n{\n\tASSERT(blkid != 0);\n\n\tzap_leaf_t *l = kmem_zalloc(sizeof (zap_leaf_t), KM_SLEEP);\n\trw_init(&l->l_rwlock, NULL, RW_DEFAULT, NULL);\n\trw_enter(&l->l_rwlock, RW_WRITER);\n\tl->l_blkid = blkid;\n\tl->l_bs = highbit64(db->db_size) - 1;\n\tl->l_dbuf = db;\n\n\tdmu_buf_init_user(&l->l_dbu, zap_leaf_evict_sync, NULL, &l->l_dbuf);\n\tzap_leaf_t *winner = dmu_buf_set_user(db, &l->l_dbu);\n\n\trw_exit(&l->l_rwlock);\n\tif (winner != NULL) {\n\t\t \n\t\tzap_leaf_evict_sync(&l->l_dbu);\n\t\tl = winner;\n\t}\n\n\t \n\tASSERT0(zap_leaf_phys(l)->l_hdr.lh_pad1);\n\n\t \n\tASSERT3U(ZAP_LEAF_HASH_NUMENTRIES(l), >, ZAP_LEAF_NUMCHUNKS(l) / 3);\n\n\t \n\tASSERT3P(&ZAP_LEAF_CHUNK(l, 0), ==, (zap_leaf_chunk_t *)\n\t    &zap_leaf_phys(l)->l_hash[ZAP_LEAF_HASH_NUMENTRIES(l)]);\n\n\t \n\tASSERT3U((uintptr_t)&ZAP_LEAF_CHUNK(l, ZAP_LEAF_NUMCHUNKS(l)) -\n\t    (uintptr_t)zap_leaf_phys(l), ==, l->l_dbuf->db_size);\n\n\treturn (l);\n}\n\nstatic int\nzap_get_leaf_byblk(zap_t *zap, uint64_t blkid, dmu_tx_t *tx, krw_t lt,\n    zap_leaf_t **lp)\n{\n\tdmu_buf_t *db;\n\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\n\t \n\tif (blkid == 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tint bs = FZAP_BLOCK_SHIFT(zap);\n\tdnode_t *dn = dmu_buf_dnode_enter(zap->zap_dbuf);\n\tint err = dmu_buf_hold_by_dnode(dn,\n\t    blkid << bs, NULL, &db, DMU_READ_NO_PREFETCH);\n\tdmu_buf_dnode_exit(zap->zap_dbuf);\n\tif (err != 0)\n\t\treturn (err);\n\n\tASSERT3U(db->db_object, ==, zap->zap_object);\n\tASSERT3U(db->db_offset, ==, blkid << bs);\n\tASSERT3U(db->db_size, ==, 1 << bs);\n\tASSERT(blkid != 0);\n\n\tzap_leaf_t *l = dmu_buf_get_user(db);\n\n\tif (l == NULL)\n\t\tl = zap_open_leaf(blkid, db);\n\n\trw_enter(&l->l_rwlock, lt);\n\t \n\tif (lt == RW_WRITER)\n\t\tdmu_buf_will_dirty(db, tx);\n\tASSERT3U(l->l_blkid, ==, blkid);\n\tASSERT3P(l->l_dbuf, ==, db);\n\tASSERT3U(zap_leaf_phys(l)->l_hdr.lh_block_type, ==, ZBT_LEAF);\n\tASSERT3U(zap_leaf_phys(l)->l_hdr.lh_magic, ==, ZAP_LEAF_MAGIC);\n\n\t*lp = l;\n\treturn (0);\n}\n\nstatic int\nzap_idx_to_blk(zap_t *zap, uint64_t idx, uint64_t *valp)\n{\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\n\tif (zap_f_phys(zap)->zap_ptrtbl.zt_numblks == 0) {\n\t\tASSERT3U(idx, <,\n\t\t    (1ULL << zap_f_phys(zap)->zap_ptrtbl.zt_shift));\n\t\t*valp = ZAP_EMBEDDED_PTRTBL_ENT(zap, idx);\n\t\treturn (0);\n\t} else {\n\t\treturn (zap_table_load(zap, &zap_f_phys(zap)->zap_ptrtbl,\n\t\t    idx, valp));\n\t}\n}\n\nstatic int\nzap_set_idx_to_blk(zap_t *zap, uint64_t idx, uint64_t blk, dmu_tx_t *tx)\n{\n\tASSERT(tx != NULL);\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\n\tif (zap_f_phys(zap)->zap_ptrtbl.zt_blk == 0) {\n\t\tZAP_EMBEDDED_PTRTBL_ENT(zap, idx) = blk;\n\t\treturn (0);\n\t} else {\n\t\treturn (zap_table_store(zap, &zap_f_phys(zap)->zap_ptrtbl,\n\t\t    idx, blk, tx));\n\t}\n}\n\nstatic int\nzap_deref_leaf(zap_t *zap, uint64_t h, dmu_tx_t *tx, krw_t lt, zap_leaf_t **lp)\n{\n\tuint64_t blk;\n\n\tASSERT(zap->zap_dbuf == NULL ||\n\t    zap_f_phys(zap) == zap->zap_dbuf->db_data);\n\n\t \n\tif ((zap_f_phys(zap)->zap_block_type != ZBT_LEAF &&\n\t    zap_f_phys(zap)->zap_block_type != ZBT_HEADER) ||\n\t    zap_f_phys(zap)->zap_magic != ZAP_MAGIC) {\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\tuint64_t idx = ZAP_HASH_IDX(h, zap_f_phys(zap)->zap_ptrtbl.zt_shift);\n\tint err = zap_idx_to_blk(zap, idx, &blk);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_get_leaf_byblk(zap, blk, tx, lt, lp);\n\n\tASSERT(err ||\n\t    ZAP_HASH_IDX(h, zap_leaf_phys(*lp)->l_hdr.lh_prefix_len) ==\n\t    zap_leaf_phys(*lp)->l_hdr.lh_prefix);\n\treturn (err);\n}\n\nstatic int\nzap_expand_leaf(zap_name_t *zn, zap_leaf_t *l,\n    const void *tag, dmu_tx_t *tx, zap_leaf_t **lp)\n{\n\tzap_t *zap = zn->zn_zap;\n\tuint64_t hash = zn->zn_hash;\n\tint err;\n\tint old_prefix_len = zap_leaf_phys(l)->l_hdr.lh_prefix_len;\n\n\tASSERT3U(old_prefix_len, <=, zap_f_phys(zap)->zap_ptrtbl.zt_shift);\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\n\tASSERT3U(ZAP_HASH_IDX(hash, old_prefix_len), ==,\n\t    zap_leaf_phys(l)->l_hdr.lh_prefix);\n\n\tif (zap_tryupgradedir(zap, tx) == 0 ||\n\t    old_prefix_len == zap_f_phys(zap)->zap_ptrtbl.zt_shift) {\n\t\t \n\t\tobjset_t *os = zap->zap_objset;\n\t\tuint64_t object = zap->zap_object;\n\n\t\tzap_put_leaf(l);\n\t\tzap_unlockdir(zap, tag);\n\t\terr = zap_lockdir(os, object, tx, RW_WRITER,\n\t\t    FALSE, FALSE, tag, &zn->zn_zap);\n\t\tzap = zn->zn_zap;\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t\tASSERT(!zap->zap_ismicro);\n\n\t\twhile (old_prefix_len ==\n\t\t    zap_f_phys(zap)->zap_ptrtbl.zt_shift) {\n\t\t\terr = zap_grow_ptrtbl(zap, tx);\n\t\t\tif (err != 0)\n\t\t\t\treturn (err);\n\t\t}\n\n\t\terr = zap_deref_leaf(zap, hash, tx, RW_WRITER, &l);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tif (zap_leaf_phys(l)->l_hdr.lh_prefix_len != old_prefix_len) {\n\t\t\t \n\t\t\t*lp = l;\n\t\t\treturn (0);\n\t\t}\n\t}\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\tASSERT3U(old_prefix_len, <, zap_f_phys(zap)->zap_ptrtbl.zt_shift);\n\tASSERT3U(ZAP_HASH_IDX(hash, old_prefix_len), ==,\n\t    zap_leaf_phys(l)->l_hdr.lh_prefix);\n\n\tint prefix_diff = zap_f_phys(zap)->zap_ptrtbl.zt_shift -\n\t    (old_prefix_len + 1);\n\tuint64_t sibling =\n\t    (ZAP_HASH_IDX(hash, old_prefix_len + 1) | 1) << prefix_diff;\n\n\t \n\tfor (int i = 0; i < (1ULL << prefix_diff); i++) {\n\t\tuint64_t blk;\n\t\terr = zap_idx_to_blk(zap, sibling + i, &blk);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t\tASSERT3U(blk, ==, l->l_blkid);\n\t}\n\n\tzap_leaf_t *nl = zap_create_leaf(zap, tx);\n\tzap_leaf_split(l, nl, zap->zap_normflags != 0);\n\n\t \n\tfor (int i = 0; i < (1ULL << prefix_diff); i++) {\n\t\terr = zap_set_idx_to_blk(zap, sibling + i, nl->l_blkid, tx);\n\t\tASSERT0(err);  \n\t}\n\n\tASSERT3U(zap_leaf_phys(l)->l_hdr.lh_prefix_len, >, 0);\n\n\tif (hash & (1ULL << (64 - zap_leaf_phys(l)->l_hdr.lh_prefix_len))) {\n\t\t \n\t\tzap_put_leaf(l);\n\t\t*lp = nl;\n\t} else {\n\t\tzap_put_leaf(nl);\n\t\t*lp = l;\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzap_put_leaf_maybe_grow_ptrtbl(zap_name_t *zn, zap_leaf_t *l,\n    const void *tag, dmu_tx_t *tx)\n{\n\tzap_t *zap = zn->zn_zap;\n\tint shift = zap_f_phys(zap)->zap_ptrtbl.zt_shift;\n\tint leaffull = (zap_leaf_phys(l)->l_hdr.lh_prefix_len == shift &&\n\t    zap_leaf_phys(l)->l_hdr.lh_nfree < ZAP_LEAF_LOW_WATER);\n\n\tzap_put_leaf(l);\n\n\tif (leaffull || zap_f_phys(zap)->zap_ptrtbl.zt_nextblk) {\n\t\t \n\t\tif (zap_tryupgradedir(zap, tx) == 0) {\n\t\t\tobjset_t *os = zap->zap_objset;\n\t\t\tuint64_t zapobj = zap->zap_object;\n\n\t\t\tzap_unlockdir(zap, tag);\n\t\t\tint err = zap_lockdir(os, zapobj, tx,\n\t\t\t    RW_WRITER, FALSE, FALSE, tag, &zn->zn_zap);\n\t\t\tzap = zn->zn_zap;\n\t\t\tif (err != 0)\n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (zap_f_phys(zap)->zap_ptrtbl.zt_shift == shift)\n\t\t\t(void) zap_grow_ptrtbl(zap, tx);\n\t}\n}\n\nstatic int\nfzap_checkname(zap_name_t *zn)\n{\n\tif (zn->zn_key_orig_numints * zn->zn_key_intlen > ZAP_MAXNAMELEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\treturn (0);\n}\n\nstatic int\nfzap_checksize(uint64_t integer_size, uint64_t num_integers)\n{\n\t \n\tswitch (integer_size) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (integer_size * num_integers > ZAP_MAXVALUELEN)\n\t\treturn (SET_ERROR(E2BIG));\n\n\treturn (0);\n}\n\nstatic int\nfzap_check(zap_name_t *zn, uint64_t integer_size, uint64_t num_integers)\n{\n\tint err = fzap_checkname(zn);\n\tif (err != 0)\n\t\treturn (err);\n\treturn (fzap_checksize(integer_size, num_integers));\n}\n\n \nint\nfzap_lookup(zap_name_t *zn,\n    uint64_t integer_size, uint64_t num_integers, void *buf,\n    char *realname, int rn_len, boolean_t *ncp)\n{\n\tzap_leaf_t *l;\n\tzap_entry_handle_t zeh;\n\n\tint err = fzap_checkname(zn);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = zap_deref_leaf(zn->zn_zap, zn->zn_hash, NULL, RW_READER, &l);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_leaf_lookup(l, zn, &zeh);\n\tif (err == 0) {\n\t\tif ((err = fzap_checksize(integer_size, num_integers)) != 0) {\n\t\t\tzap_put_leaf(l);\n\t\t\treturn (err);\n\t\t}\n\n\t\terr = zap_entry_read(&zeh, integer_size, num_integers, buf);\n\t\t(void) zap_entry_read_name(zn->zn_zap, &zeh, rn_len, realname);\n\t\tif (ncp) {\n\t\t\t*ncp = zap_entry_normalization_conflict(&zeh,\n\t\t\t    zn, NULL, zn->zn_zap);\n\t\t}\n\t}\n\n\tzap_put_leaf(l);\n\treturn (err);\n}\n\nint\nfzap_add_cd(zap_name_t *zn,\n    uint64_t integer_size, uint64_t num_integers,\n    const void *val, uint32_t cd, const void *tag, dmu_tx_t *tx)\n{\n\tzap_leaf_t *l;\n\tint err;\n\tzap_entry_handle_t zeh;\n\tzap_t *zap = zn->zn_zap;\n\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\tASSERT(!zap->zap_ismicro);\n\tASSERT(fzap_check(zn, integer_size, num_integers) == 0);\n\n\terr = zap_deref_leaf(zap, zn->zn_hash, tx, RW_WRITER, &l);\n\tif (err != 0)\n\t\treturn (err);\nretry:\n\terr = zap_leaf_lookup(l, zn, &zeh);\n\tif (err == 0) {\n\t\terr = SET_ERROR(EEXIST);\n\t\tgoto out;\n\t}\n\tif (err != ENOENT)\n\t\tgoto out;\n\n\terr = zap_entry_create(l, zn, cd,\n\t    integer_size, num_integers, val, &zeh);\n\n\tif (err == 0) {\n\t\tzap_increment_num_entries(zap, 1, tx);\n\t} else if (err == EAGAIN) {\n\t\terr = zap_expand_leaf(zn, l, tag, tx, &l);\n\t\tzap = zn->zn_zap;\t \n\t\tif (err == 0) {\n\t\t\tgoto retry;\n\t\t} else if (err == ENOSPC) {\n\t\t\t \n\t\t\treturn (err);\n\t\t}\n\t}\n\nout:\n\tif (zap != NULL)\n\t\tzap_put_leaf_maybe_grow_ptrtbl(zn, l, tag, tx);\n\treturn (err);\n}\n\nint\nfzap_add(zap_name_t *zn,\n    uint64_t integer_size, uint64_t num_integers,\n    const void *val, const void *tag, dmu_tx_t *tx)\n{\n\tint err = fzap_check(zn, integer_size, num_integers);\n\tif (err != 0)\n\t\treturn (err);\n\n\treturn (fzap_add_cd(zn, integer_size, num_integers,\n\t    val, ZAP_NEED_CD, tag, tx));\n}\n\nint\nfzap_update(zap_name_t *zn,\n    int integer_size, uint64_t num_integers, const void *val,\n    const void *tag, dmu_tx_t *tx)\n{\n\tzap_leaf_t *l;\n\tint err;\n\tboolean_t create;\n\tzap_entry_handle_t zeh;\n\tzap_t *zap = zn->zn_zap;\n\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\terr = fzap_check(zn, integer_size, num_integers);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = zap_deref_leaf(zap, zn->zn_hash, tx, RW_WRITER, &l);\n\tif (err != 0)\n\t\treturn (err);\nretry:\n\terr = zap_leaf_lookup(l, zn, &zeh);\n\tcreate = (err == ENOENT);\n\tASSERT(err == 0 || err == ENOENT);\n\n\tif (create) {\n\t\terr = zap_entry_create(l, zn, ZAP_NEED_CD,\n\t\t    integer_size, num_integers, val, &zeh);\n\t\tif (err == 0)\n\t\t\tzap_increment_num_entries(zap, 1, tx);\n\t} else {\n\t\terr = zap_entry_update(&zeh, integer_size, num_integers, val);\n\t}\n\n\tif (err == EAGAIN) {\n\t\terr = zap_expand_leaf(zn, l, tag, tx, &l);\n\t\tzap = zn->zn_zap;\t \n\t\tif (err == 0)\n\t\t\tgoto retry;\n\t}\n\n\tif (zap != NULL)\n\t\tzap_put_leaf_maybe_grow_ptrtbl(zn, l, tag, tx);\n\treturn (err);\n}\n\nint\nfzap_length(zap_name_t *zn,\n    uint64_t *integer_size, uint64_t *num_integers)\n{\n\tzap_leaf_t *l;\n\tint err;\n\tzap_entry_handle_t zeh;\n\n\terr = zap_deref_leaf(zn->zn_zap, zn->zn_hash, NULL, RW_READER, &l);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_leaf_lookup(l, zn, &zeh);\n\tif (err != 0)\n\t\tgoto out;\n\n\tif (integer_size != NULL)\n\t\t*integer_size = zeh.zeh_integer_size;\n\tif (num_integers != NULL)\n\t\t*num_integers = zeh.zeh_num_integers;\nout:\n\tzap_put_leaf(l);\n\treturn (err);\n}\n\nint\nfzap_remove(zap_name_t *zn, dmu_tx_t *tx)\n{\n\tzap_leaf_t *l;\n\tint err;\n\tzap_entry_handle_t zeh;\n\n\terr = zap_deref_leaf(zn->zn_zap, zn->zn_hash, tx, RW_WRITER, &l);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_leaf_lookup(l, zn, &zeh);\n\tif (err == 0) {\n\t\tzap_entry_remove(&zeh);\n\t\tzap_increment_num_entries(zn->zn_zap, -1, tx);\n\t}\n\tzap_put_leaf(l);\n\treturn (err);\n}\n\nvoid\nfzap_prefetch(zap_name_t *zn)\n{\n\tuint64_t blk;\n\tzap_t *zap = zn->zn_zap;\n\n\tuint64_t idx = ZAP_HASH_IDX(zn->zn_hash,\n\t    zap_f_phys(zap)->zap_ptrtbl.zt_shift);\n\tif (zap_idx_to_blk(zap, idx, &blk) != 0)\n\t\treturn;\n\tint bs = FZAP_BLOCK_SHIFT(zap);\n\tdmu_prefetch(zap->zap_objset, zap->zap_object, 0, blk << bs, 1 << bs,\n\t    ZIO_PRIORITY_SYNC_READ);\n}\n\n \n\nuint64_t\nzap_create_link(objset_t *os, dmu_object_type_t ot, uint64_t parent_obj,\n    const char *name, dmu_tx_t *tx)\n{\n\treturn (zap_create_link_dnsize(os, ot, parent_obj, name, 0, tx));\n}\n\nuint64_t\nzap_create_link_dnsize(objset_t *os, dmu_object_type_t ot, uint64_t parent_obj,\n    const char *name, int dnodesize, dmu_tx_t *tx)\n{\n\tuint64_t new_obj;\n\n\tnew_obj = zap_create_dnsize(os, ot, DMU_OT_NONE, 0, dnodesize, tx);\n\tVERIFY(new_obj != 0);\n\tVERIFY0(zap_add(os, parent_obj, name, sizeof (uint64_t), 1, &new_obj,\n\t    tx));\n\n\treturn (new_obj);\n}\n\nint\nzap_value_search(objset_t *os, uint64_t zapobj, uint64_t value, uint64_t mask,\n    char *name)\n{\n\tzap_cursor_t zc;\n\tint err;\n\n\tif (mask == 0)\n\t\tmask = -1ULL;\n\n\tzap_attribute_t *za = kmem_alloc(sizeof (*za), KM_SLEEP);\n\tfor (zap_cursor_init(&zc, os, zapobj);\n\t    (err = zap_cursor_retrieve(&zc, za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tif ((za->za_first_integer & mask) == (value & mask)) {\n\t\t\t(void) strlcpy(name, za->za_name, MAXNAMELEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tzap_cursor_fini(&zc);\n\tkmem_free(za, sizeof (*za));\n\treturn (err);\n}\n\nint\nzap_join(objset_t *os, uint64_t fromobj, uint64_t intoobj, dmu_tx_t *tx)\n{\n\tzap_cursor_t zc;\n\tint err = 0;\n\n\tzap_attribute_t *za = kmem_alloc(sizeof (*za), KM_SLEEP);\n\tfor (zap_cursor_init(&zc, os, fromobj);\n\t    zap_cursor_retrieve(&zc, za) == 0;\n\t    (void) zap_cursor_advance(&zc)) {\n\t\tif (za->za_integer_length != 8 || za->za_num_integers != 1) {\n\t\t\terr = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\terr = zap_add(os, intoobj, za->za_name,\n\t\t    8, 1, &za->za_first_integer, tx);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tzap_cursor_fini(&zc);\n\tkmem_free(za, sizeof (*za));\n\treturn (err);\n}\n\nint\nzap_join_key(objset_t *os, uint64_t fromobj, uint64_t intoobj,\n    uint64_t value, dmu_tx_t *tx)\n{\n\tzap_cursor_t zc;\n\tint err = 0;\n\n\tzap_attribute_t *za = kmem_alloc(sizeof (*za), KM_SLEEP);\n\tfor (zap_cursor_init(&zc, os, fromobj);\n\t    zap_cursor_retrieve(&zc, za) == 0;\n\t    (void) zap_cursor_advance(&zc)) {\n\t\tif (za->za_integer_length != 8 || za->za_num_integers != 1) {\n\t\t\terr = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\terr = zap_add(os, intoobj, za->za_name,\n\t\t    8, 1, &value, tx);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tzap_cursor_fini(&zc);\n\tkmem_free(za, sizeof (*za));\n\treturn (err);\n}\n\nint\nzap_join_increment(objset_t *os, uint64_t fromobj, uint64_t intoobj,\n    dmu_tx_t *tx)\n{\n\tzap_cursor_t zc;\n\tint err = 0;\n\n\tzap_attribute_t *za = kmem_alloc(sizeof (*za), KM_SLEEP);\n\tfor (zap_cursor_init(&zc, os, fromobj);\n\t    zap_cursor_retrieve(&zc, za) == 0;\n\t    (void) zap_cursor_advance(&zc)) {\n\t\tuint64_t delta = 0;\n\n\t\tif (za->za_integer_length != 8 || za->za_num_integers != 1) {\n\t\t\terr = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = zap_lookup(os, intoobj, za->za_name, 8, 1, &delta);\n\t\tif (err != 0 && err != ENOENT)\n\t\t\tbreak;\n\t\tdelta += za->za_first_integer;\n\t\terr = zap_update(os, intoobj, za->za_name, 8, 1, &delta, tx);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tzap_cursor_fini(&zc);\n\tkmem_free(za, sizeof (*za));\n\treturn (err);\n}\n\nint\nzap_add_int(objset_t *os, uint64_t obj, uint64_t value, dmu_tx_t *tx)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)value);\n\treturn (zap_add(os, obj, name, 8, 1, &value, tx));\n}\n\nint\nzap_remove_int(objset_t *os, uint64_t obj, uint64_t value, dmu_tx_t *tx)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)value);\n\treturn (zap_remove(os, obj, name, tx));\n}\n\nint\nzap_lookup_int(objset_t *os, uint64_t obj, uint64_t value)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)value);\n\treturn (zap_lookup(os, obj, name, 8, 1, &value));\n}\n\nint\nzap_add_int_key(objset_t *os, uint64_t obj,\n    uint64_t key, uint64_t value, dmu_tx_t *tx)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)key);\n\treturn (zap_add(os, obj, name, 8, 1, &value, tx));\n}\n\nint\nzap_update_int_key(objset_t *os, uint64_t obj,\n    uint64_t key, uint64_t value, dmu_tx_t *tx)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)key);\n\treturn (zap_update(os, obj, name, 8, 1, &value, tx));\n}\n\nint\nzap_lookup_int_key(objset_t *os, uint64_t obj, uint64_t key, uint64_t *valuep)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)key);\n\treturn (zap_lookup(os, obj, name, 8, 1, valuep));\n}\n\nint\nzap_increment(objset_t *os, uint64_t obj, const char *name, int64_t delta,\n    dmu_tx_t *tx)\n{\n\tuint64_t value = 0;\n\n\tif (delta == 0)\n\t\treturn (0);\n\n\tint err = zap_lookup(os, obj, name, 8, 1, &value);\n\tif (err != 0 && err != ENOENT)\n\t\treturn (err);\n\tvalue += delta;\n\tif (value == 0)\n\t\terr = zap_remove(os, obj, name, tx);\n\telse\n\t\terr = zap_update(os, obj, name, 8, 1, &value, tx);\n\treturn (err);\n}\n\nint\nzap_increment_int(objset_t *os, uint64_t obj, uint64_t key, int64_t delta,\n    dmu_tx_t *tx)\n{\n\tchar name[20];\n\n\t(void) snprintf(name, sizeof (name), \"%llx\", (longlong_t)key);\n\treturn (zap_increment(os, obj, name, delta, tx));\n}\n\n \n\nint\nfzap_cursor_retrieve(zap_t *zap, zap_cursor_t *zc, zap_attribute_t *za)\n{\n\tint err = ENOENT;\n\tzap_entry_handle_t zeh;\n\tzap_leaf_t *l;\n\n\t \n\t \n\n\t \n\tif (zc->zc_hash == 0 && zap_iterate_prefetch &&\n\t    zc->zc_prefetch && zap_f_phys(zap)->zap_freeblk > 2) {\n\t\tdmu_prefetch(zc->zc_objset, zc->zc_zapobj, 0, 0,\n\t\t    zap_f_phys(zap)->zap_freeblk << FZAP_BLOCK_SHIFT(zap),\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t}\n\n\tif (zc->zc_leaf &&\n\t    (ZAP_HASH_IDX(zc->zc_hash,\n\t    zap_leaf_phys(zc->zc_leaf)->l_hdr.lh_prefix_len) !=\n\t    zap_leaf_phys(zc->zc_leaf)->l_hdr.lh_prefix)) {\n\t\trw_enter(&zc->zc_leaf->l_rwlock, RW_READER);\n\t\tzap_put_leaf(zc->zc_leaf);\n\t\tzc->zc_leaf = NULL;\n\t}\n\nagain:\n\tif (zc->zc_leaf == NULL) {\n\t\terr = zap_deref_leaf(zap, zc->zc_hash, NULL, RW_READER,\n\t\t    &zc->zc_leaf);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t} else {\n\t\trw_enter(&zc->zc_leaf->l_rwlock, RW_READER);\n\t}\n\tl = zc->zc_leaf;\n\n\terr = zap_leaf_lookup_closest(l, zc->zc_hash, zc->zc_cd, &zeh);\n\n\tif (err == ENOENT) {\n\t\tif (zap_leaf_phys(l)->l_hdr.lh_prefix_len == 0) {\n\t\t\tzc->zc_hash = -1ULL;\n\t\t\tzc->zc_cd = 0;\n\t\t} else {\n\t\t\tuint64_t nocare = (1ULL <<\n\t\t\t    (64 - zap_leaf_phys(l)->l_hdr.lh_prefix_len)) - 1;\n\n\t\t\tzc->zc_hash = (zc->zc_hash & ~nocare) + nocare + 1;\n\t\t\tzc->zc_cd = 0;\n\n\t\t\tif (zc->zc_hash == 0) {\n\t\t\t\tzc->zc_hash = -1ULL;\n\t\t\t} else {\n\t\t\t\tzap_put_leaf(zc->zc_leaf);\n\t\t\t\tzc->zc_leaf = NULL;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err == 0) {\n\t\tzc->zc_hash = zeh.zeh_hash;\n\t\tzc->zc_cd = zeh.zeh_cd;\n\t\tza->za_integer_length = zeh.zeh_integer_size;\n\t\tza->za_num_integers = zeh.zeh_num_integers;\n\t\tif (zeh.zeh_num_integers == 0) {\n\t\t\tza->za_first_integer = 0;\n\t\t} else {\n\t\t\terr = zap_entry_read(&zeh, 8, 1, &za->za_first_integer);\n\t\t\tASSERT(err == 0 || err == EOVERFLOW);\n\t\t}\n\t\terr = zap_entry_read_name(zap, &zeh,\n\t\t    sizeof (za->za_name), za->za_name);\n\t\tASSERT(err == 0);\n\n\t\tza->za_normalization_conflict =\n\t\t    zap_entry_normalization_conflict(&zeh,\n\t\t    NULL, za->za_name, zap);\n\t}\n\trw_exit(&zc->zc_leaf->l_rwlock);\n\treturn (err);\n}\n\nstatic void\nzap_stats_ptrtbl(zap_t *zap, uint64_t *tbl, int len, zap_stats_t *zs)\n{\n\tuint64_t lastblk = 0;\n\n\t \n\tfor (int i = 0; i < len; i++) {\n\t\tzap_leaf_t *l;\n\n\t\tif (tbl[i] == lastblk)\n\t\t\tcontinue;\n\t\tlastblk = tbl[i];\n\n\t\tint err = zap_get_leaf_byblk(zap, tbl[i], NULL, RW_READER, &l);\n\t\tif (err == 0) {\n\t\t\tzap_leaf_stats(zap, l, zs);\n\t\t\tzap_put_leaf(l);\n\t\t}\n\t}\n}\n\nvoid\nfzap_get_stats(zap_t *zap, zap_stats_t *zs)\n{\n\tint bs = FZAP_BLOCK_SHIFT(zap);\n\tzs->zs_blocksize = 1ULL << bs;\n\n\t \n\tzs->zs_num_leafs = zap_f_phys(zap)->zap_num_leafs;\n\tzs->zs_num_entries = zap_f_phys(zap)->zap_num_entries;\n\tzs->zs_num_blocks = zap_f_phys(zap)->zap_freeblk;\n\tzs->zs_block_type = zap_f_phys(zap)->zap_block_type;\n\tzs->zs_magic = zap_f_phys(zap)->zap_magic;\n\tzs->zs_salt = zap_f_phys(zap)->zap_salt;\n\n\t \n\tzs->zs_ptrtbl_len = 1ULL << zap_f_phys(zap)->zap_ptrtbl.zt_shift;\n\tzs->zs_ptrtbl_nextblk = zap_f_phys(zap)->zap_ptrtbl.zt_nextblk;\n\tzs->zs_ptrtbl_blks_copied =\n\t    zap_f_phys(zap)->zap_ptrtbl.zt_blks_copied;\n\tzs->zs_ptrtbl_zt_blk = zap_f_phys(zap)->zap_ptrtbl.zt_blk;\n\tzs->zs_ptrtbl_zt_numblks = zap_f_phys(zap)->zap_ptrtbl.zt_numblks;\n\tzs->zs_ptrtbl_zt_shift = zap_f_phys(zap)->zap_ptrtbl.zt_shift;\n\n\tif (zap_f_phys(zap)->zap_ptrtbl.zt_numblks == 0) {\n\t\t \n\t\tzap_stats_ptrtbl(zap, &ZAP_EMBEDDED_PTRTBL_ENT(zap, 0),\n\t\t    1 << ZAP_EMBEDDED_PTRTBL_SHIFT(zap), zs);\n\t} else {\n\t\tdmu_prefetch(zap->zap_objset, zap->zap_object, 0,\n\t\t    zap_f_phys(zap)->zap_ptrtbl.zt_blk << bs,\n\t\t    zap_f_phys(zap)->zap_ptrtbl.zt_numblks << bs,\n\t\t    ZIO_PRIORITY_SYNC_READ);\n\n\t\tfor (int b = 0; b < zap_f_phys(zap)->zap_ptrtbl.zt_numblks;\n\t\t    b++) {\n\t\t\tdmu_buf_t *db;\n\t\t\tint err;\n\n\t\t\terr = dmu_buf_hold(zap->zap_objset, zap->zap_object,\n\t\t\t    (zap_f_phys(zap)->zap_ptrtbl.zt_blk + b) << bs,\n\t\t\t    FTAG, &db, DMU_READ_NO_PREFETCH);\n\t\t\tif (err == 0) {\n\t\t\t\tzap_stats_ptrtbl(zap, db->db_data,\n\t\t\t\t    1<<(bs-3), zs);\n\t\t\t\tdmu_buf_rele(db, FTAG);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nZFS_MODULE_PARAM(zfs, , zap_iterate_prefetch, INT, ZMOD_RW,\n\t\"When iterating ZAP object, prefetch it\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}