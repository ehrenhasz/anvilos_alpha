{
  "module_name": "bpobj.c",
  "hash_id": "47422cc900476fc5e3dee267cbc78987e8a87ef104fc4ebcb9e18292b250dea1",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/bpobj.c",
  "human_readable_source": " \n \n\n#include <sys/bpobj.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_refcount.h>\n#include <sys/dsl_pool.h>\n#include <sys/zfeature.h>\n#include <sys/zap.h>\n\n \nuint64_t\nbpobj_alloc_empty(objset_t *os, int blocksize, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_objset_spa(os);\n\tdsl_pool_t *dp = dmu_objset_pool(os);\n\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_EMPTY_BPOBJ)) {\n\t\tif (!spa_feature_is_active(spa, SPA_FEATURE_EMPTY_BPOBJ)) {\n\t\t\tASSERT0(dp->dp_empty_bpobj);\n\t\t\tdp->dp_empty_bpobj =\n\t\t\t    bpobj_alloc(os, SPA_OLD_MAXBLOCKSIZE, tx);\n\t\t\tVERIFY(zap_add(os,\n\t\t\t    DMU_POOL_DIRECTORY_OBJECT,\n\t\t\t    DMU_POOL_EMPTY_BPOBJ, sizeof (uint64_t), 1,\n\t\t\t    &dp->dp_empty_bpobj, tx) == 0);\n\t\t}\n\t\tspa_feature_incr(spa, SPA_FEATURE_EMPTY_BPOBJ, tx);\n\t\tASSERT(dp->dp_empty_bpobj != 0);\n\t\treturn (dp->dp_empty_bpobj);\n\t} else {\n\t\treturn (bpobj_alloc(os, blocksize, tx));\n\t}\n}\n\nvoid\nbpobj_decr_empty(objset_t *os, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_objset_pool(os);\n\n\tspa_feature_decr(dmu_objset_spa(os), SPA_FEATURE_EMPTY_BPOBJ, tx);\n\tif (!spa_feature_is_active(dmu_objset_spa(os),\n\t    SPA_FEATURE_EMPTY_BPOBJ)) {\n\t\tVERIFY3U(0, ==, zap_remove(dp->dp_meta_objset,\n\t\t    DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_EMPTY_BPOBJ, tx));\n\t\tVERIFY3U(0, ==, dmu_object_free(os, dp->dp_empty_bpobj, tx));\n\t\tdp->dp_empty_bpobj = 0;\n\t}\n}\n\nuint64_t\nbpobj_alloc(objset_t *os, int blocksize, dmu_tx_t *tx)\n{\n\tint size;\n\n\tif (spa_version(dmu_objset_spa(os)) < SPA_VERSION_BPOBJ_ACCOUNT)\n\t\tsize = BPOBJ_SIZE_V0;\n\telse if (spa_version(dmu_objset_spa(os)) < SPA_VERSION_DEADLISTS)\n\t\tsize = BPOBJ_SIZE_V1;\n\telse if (!spa_feature_is_active(dmu_objset_spa(os),\n\t    SPA_FEATURE_LIVELIST))\n\t\tsize = BPOBJ_SIZE_V2;\n\telse\n\t\tsize = sizeof (bpobj_phys_t);\n\n\treturn (dmu_object_alloc(os, DMU_OT_BPOBJ, blocksize,\n\t    DMU_OT_BPOBJ_HDR, size, tx));\n}\n\nvoid\nbpobj_free(objset_t *os, uint64_t obj, dmu_tx_t *tx)\n{\n\tint64_t i;\n\tbpobj_t bpo;\n\tdmu_object_info_t doi;\n\tint epb;\n\tdmu_buf_t *dbuf = NULL;\n\n\tASSERT(obj != dmu_objset_pool(os)->dp_empty_bpobj);\n\tVERIFY3U(0, ==, bpobj_open(&bpo, os, obj));\n\n\tmutex_enter(&bpo.bpo_lock);\n\n\tif (!bpo.bpo_havesubobj || bpo.bpo_phys->bpo_subobjs == 0)\n\t\tgoto out;\n\n\tVERIFY3U(0, ==, dmu_object_info(os, bpo.bpo_phys->bpo_subobjs, &doi));\n\tepb = doi.doi_data_block_size / sizeof (uint64_t);\n\n\tfor (i = bpo.bpo_phys->bpo_num_subobjs - 1; i >= 0; i--) {\n\t\tuint64_t *objarray;\n\t\tuint64_t offset, blkoff;\n\n\t\toffset = i * sizeof (uint64_t);\n\t\tblkoff = P2PHASE(i, epb);\n\n\t\tif (dbuf == NULL || dbuf->db_offset > offset) {\n\t\t\tif (dbuf)\n\t\t\t\tdmu_buf_rele(dbuf, FTAG);\n\t\t\tVERIFY3U(0, ==, dmu_buf_hold(os,\n\t\t\t    bpo.bpo_phys->bpo_subobjs, offset, FTAG, &dbuf, 0));\n\t\t}\n\n\t\tASSERT3U(offset, >=, dbuf->db_offset);\n\t\tASSERT3U(offset, <, dbuf->db_offset + dbuf->db_size);\n\n\t\tobjarray = dbuf->db_data;\n\t\tbpobj_free(os, objarray[blkoff], tx);\n\t}\n\tif (dbuf) {\n\t\tdmu_buf_rele(dbuf, FTAG);\n\t\tdbuf = NULL;\n\t}\n\tVERIFY3U(0, ==, dmu_object_free(os, bpo.bpo_phys->bpo_subobjs, tx));\n\nout:\n\tmutex_exit(&bpo.bpo_lock);\n\tbpobj_close(&bpo);\n\n\tVERIFY3U(0, ==, dmu_object_free(os, obj, tx));\n}\n\nint\nbpobj_open(bpobj_t *bpo, objset_t *os, uint64_t object)\n{\n\tdmu_object_info_t doi;\n\tint err;\n\n\terr = dmu_object_info(os, object, &doi);\n\tif (err)\n\t\treturn (err);\n\n\tmemset(bpo, 0, sizeof (*bpo));\n\tmutex_init(&bpo->bpo_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tASSERT(bpo->bpo_dbuf == NULL);\n\tASSERT(bpo->bpo_phys == NULL);\n\tASSERT(object != 0);\n\tASSERT3U(doi.doi_type, ==, DMU_OT_BPOBJ);\n\tASSERT3U(doi.doi_bonus_type, ==, DMU_OT_BPOBJ_HDR);\n\n\terr = dmu_bonus_hold(os, object, bpo, &bpo->bpo_dbuf);\n\tif (err)\n\t\treturn (err);\n\n\tbpo->bpo_os = os;\n\tbpo->bpo_object = object;\n\tbpo->bpo_epb = doi.doi_data_block_size >> SPA_BLKPTRSHIFT;\n\tbpo->bpo_havecomp = (doi.doi_bonus_size > BPOBJ_SIZE_V0);\n\tbpo->bpo_havesubobj = (doi.doi_bonus_size > BPOBJ_SIZE_V1);\n\tbpo->bpo_havefreed = (doi.doi_bonus_size > BPOBJ_SIZE_V2);\n\tbpo->bpo_phys = bpo->bpo_dbuf->db_data;\n\treturn (0);\n}\n\nboolean_t\nbpobj_is_open(const bpobj_t *bpo)\n{\n\treturn (bpo->bpo_object != 0);\n}\n\nvoid\nbpobj_close(bpobj_t *bpo)\n{\n\t \n\tif (bpo->bpo_object == 0)\n\t\treturn;\n\n\tdmu_buf_rele(bpo->bpo_dbuf, bpo);\n\tif (bpo->bpo_cached_dbuf != NULL)\n\t\tdmu_buf_rele(bpo->bpo_cached_dbuf, bpo);\n\tbpo->bpo_dbuf = NULL;\n\tbpo->bpo_phys = NULL;\n\tbpo->bpo_cached_dbuf = NULL;\n\tbpo->bpo_object = 0;\n\n\tmutex_destroy(&bpo->bpo_lock);\n}\n\nstatic boolean_t\nbpobj_is_empty_impl(bpobj_t *bpo)\n{\n\tASSERT(MUTEX_HELD(&bpo->bpo_lock));\n\treturn (bpo->bpo_phys->bpo_num_blkptrs == 0 &&\n\t    (!bpo->bpo_havesubobj || bpo->bpo_phys->bpo_num_subobjs == 0));\n}\n\nboolean_t\nbpobj_is_empty(bpobj_t *bpo)\n{\n\tmutex_enter(&bpo->bpo_lock);\n\tboolean_t is_empty = bpobj_is_empty_impl(bpo);\n\tmutex_exit(&bpo->bpo_lock);\n\treturn (is_empty);\n}\n\n \ntypedef struct bpobj_info {\n\tbpobj_t *bpi_bpo;\n\t \n\tstruct bpobj_info *bpi_parent;\n\tuint64_t bpi_index;\n\t \n\tuint64_t bpi_unprocessed_subobjs;\n\t \n\tboolean_t bpi_visited;\n\tlist_node_t bpi_node;\n} bpobj_info_t;\n\nstatic bpobj_info_t *\nbpi_alloc(bpobj_t *bpo, bpobj_info_t *parent, uint64_t index)\n{\n\tbpobj_info_t *bpi = kmem_zalloc(sizeof (bpobj_info_t), KM_SLEEP);\n\tbpi->bpi_bpo = bpo;\n\tbpi->bpi_parent = parent;\n\tbpi->bpi_index = index;\n\tif (bpo->bpo_havesubobj && bpo->bpo_phys->bpo_subobjs != 0) {\n\t\tbpi->bpi_unprocessed_subobjs = bpo->bpo_phys->bpo_num_subobjs;\n\t}\n\treturn (bpi);\n}\n\n \nstatic void\npropagate_space_reduction(bpobj_info_t *bpi, int64_t freed,\n    int64_t comp_freed, int64_t uncomp_freed, dmu_tx_t *tx)\n{\n\n\tfor (; bpi != NULL; bpi = bpi->bpi_parent) {\n\t\tbpobj_t *p = bpi->bpi_bpo;\n\t\tASSERT(dmu_buf_is_dirty(p->bpo_dbuf, tx));\n\t\tp->bpo_phys->bpo_bytes -= freed;\n\t\tASSERT3S(p->bpo_phys->bpo_bytes, >=, 0);\n\t\tif (p->bpo_havecomp) {\n\t\t\tp->bpo_phys->bpo_comp -= comp_freed;\n\t\t\tp->bpo_phys->bpo_uncomp -= uncomp_freed;\n\t\t}\n\t}\n}\n\nstatic int\nbpobj_iterate_blkptrs(bpobj_info_t *bpi, bpobj_itor_t func, void *arg,\n    int64_t start, dmu_tx_t *tx, boolean_t free)\n{\n\tint err = 0;\n\tint64_t freed = 0, comp_freed = 0, uncomp_freed = 0;\n\tdmu_buf_t *dbuf = NULL;\n\tbpobj_t *bpo = bpi->bpi_bpo;\n\n\tint64_t i = bpo->bpo_phys->bpo_num_blkptrs - 1;\n\tuint64_t pe = P2ALIGN_TYPED(i, bpo->bpo_epb, uint64_t) *\n\t    sizeof (blkptr_t);\n\tuint64_t ps = start * sizeof (blkptr_t);\n\tuint64_t pb = MAX((pe > dmu_prefetch_max) ? pe - dmu_prefetch_max : 0,\n\t    ps);\n\tif (pe > pb) {\n\t\tdmu_prefetch(bpo->bpo_os, bpo->bpo_object, 0, pb, pe - pb,\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t}\n\tfor (; i >= start; i--) {\n\t\tuint64_t offset = i * sizeof (blkptr_t);\n\t\tuint64_t blkoff = P2PHASE(i, bpo->bpo_epb);\n\n\t\tif (dbuf == NULL || dbuf->db_offset > offset) {\n\t\t\tif (dbuf)\n\t\t\t\tdmu_buf_rele(dbuf, FTAG);\n\t\t\terr = dmu_buf_hold(bpo->bpo_os, bpo->bpo_object,\n\t\t\t    offset, FTAG, &dbuf, DMU_READ_NO_PREFETCH);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tpe = pb;\n\t\t\tpb = MAX((dbuf->db_offset > dmu_prefetch_max) ?\n\t\t\t    dbuf->db_offset - dmu_prefetch_max : 0, ps);\n\t\t\tif (pe > pb) {\n\t\t\t\tdmu_prefetch(bpo->bpo_os, bpo->bpo_object, 0,\n\t\t\t\t    pb, pe - pb, ZIO_PRIORITY_ASYNC_READ);\n\t\t\t}\n\t\t}\n\n\t\tASSERT3U(offset, >=, dbuf->db_offset);\n\t\tASSERT3U(offset, <, dbuf->db_offset + dbuf->db_size);\n\n\t\tblkptr_t *bparray = dbuf->db_data;\n\t\tblkptr_t *bp = &bparray[blkoff];\n\n\t\tboolean_t bp_freed = BP_GET_FREE(bp);\n\t\terr = func(arg, bp, bp_freed, tx);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (free) {\n\t\t\tint sign = bp_freed ? -1 : +1;\n\t\t\tspa_t *spa = dmu_objset_spa(bpo->bpo_os);\n\t\t\tfreed += sign * bp_get_dsize_sync(spa, bp);\n\t\t\tcomp_freed += sign * BP_GET_PSIZE(bp);\n\t\t\tuncomp_freed += sign * BP_GET_UCSIZE(bp);\n\t\t\tASSERT(dmu_buf_is_dirty(bpo->bpo_dbuf, tx));\n\t\t\tbpo->bpo_phys->bpo_num_blkptrs--;\n\t\t\tASSERT3S(bpo->bpo_phys->bpo_num_blkptrs, >=, 0);\n\t\t\tif (bp_freed) {\n\t\t\t\tASSERT(bpo->bpo_havefreed);\n\t\t\t\tbpo->bpo_phys->bpo_num_freed--;\n\t\t\t\tASSERT3S(bpo->bpo_phys->bpo_num_freed, >=, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif (free) {\n\t\tpropagate_space_reduction(bpi, freed, comp_freed,\n\t\t    uncomp_freed, tx);\n\t\tVERIFY0(dmu_free_range(bpo->bpo_os,\n\t\t    bpo->bpo_object,\n\t\t    bpo->bpo_phys->bpo_num_blkptrs * sizeof (blkptr_t),\n\t\t    DMU_OBJECT_END, tx));\n\t}\n\tif (dbuf) {\n\t\tdmu_buf_rele(dbuf, FTAG);\n\t\tdbuf = NULL;\n\t}\n\treturn (err);\n}\n\n \nstatic int\nbpobj_iterate_impl(bpobj_t *initial_bpo, bpobj_itor_t func, void *arg,\n    dmu_tx_t *tx, boolean_t free, uint64_t *bpobj_size)\n{\n\tlist_t stack;\n\tbpobj_info_t *bpi;\n\tint err = 0;\n\n\t \n\tlist_create(&stack, sizeof (bpobj_info_t),\n\t    offsetof(bpobj_info_t, bpi_node));\n\tmutex_enter(&initial_bpo->bpo_lock);\n\n\tif (bpobj_size != NULL)\n\t\t*bpobj_size = initial_bpo->bpo_phys->bpo_num_blkptrs;\n\n\tlist_insert_head(&stack, bpi_alloc(initial_bpo, NULL, 0));\n\n\twhile ((bpi = list_head(&stack)) != NULL) {\n\t\tbpobj_t *bpo = bpi->bpi_bpo;\n\n\t\tASSERT3P(bpo, !=, NULL);\n\t\tASSERT(MUTEX_HELD(&bpo->bpo_lock));\n\t\tASSERT(bpobj_is_open(bpo));\n\n\t\tif (free)\n\t\t\tdmu_buf_will_dirty(bpo->bpo_dbuf, tx);\n\n\t\tif (bpi->bpi_visited == B_FALSE) {\n\t\t\terr = bpobj_iterate_blkptrs(bpi, func, arg, 0, tx,\n\t\t\t    free);\n\t\t\tbpi->bpi_visited = B_TRUE;\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (bpi->bpi_unprocessed_subobjs == 0) {\n\t\t\t \n\t\t\tif (bpobj_is_empty_impl(bpo)) {\n\t\t\t\tASSERT0(bpo->bpo_phys->bpo_bytes);\n\t\t\t\tASSERT0(bpo->bpo_phys->bpo_comp);\n\t\t\t\tASSERT0(bpo->bpo_phys->bpo_uncomp);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (bpi->bpi_parent != NULL) {\n\t\t\t\tif (free) {\n\t\t\t\t\tbpobj_t *p = bpi->bpi_parent->bpi_bpo;\n\n\t\t\t\t\tASSERT0(bpo->bpo_phys->bpo_num_blkptrs);\n\t\t\t\t\tASSERT3U(p->bpo_phys->bpo_num_subobjs,\n\t\t\t\t\t    >, 0);\n\t\t\t\t\tASSERT3U(bpi->bpi_index, ==,\n\t\t\t\t\t    p->bpo_phys->bpo_num_subobjs - 1);\n\t\t\t\t\tASSERT(dmu_buf_is_dirty(bpo->bpo_dbuf,\n\t\t\t\t\t    tx));\n\n\t\t\t\t\tp->bpo_phys->bpo_num_subobjs--;\n\n\t\t\t\t\tVERIFY0(dmu_free_range(p->bpo_os,\n\t\t\t\t\t    p->bpo_phys->bpo_subobjs,\n\t\t\t\t\t    bpi->bpi_index * sizeof (uint64_t),\n\t\t\t\t\t    sizeof (uint64_t), tx));\n\n\t\t\t\t\t \n\t\t\t\t\tif (bpo->bpo_havesubobj &&\n\t\t\t\t\t    bpo->bpo_phys->bpo_subobjs != 0) {\n\t\t\t\t\t\tASSERT0(bpo->bpo_phys->\n\t\t\t\t\t\t    bpo_num_subobjs);\n\t\t\t\t\t\terr = dmu_object_free(\n\t\t\t\t\t\t    bpo->bpo_os,\n\t\t\t\t\t\t    bpo->bpo_phys->bpo_subobjs,\n\t\t\t\t\t\t    tx);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tbpo->bpo_phys->bpo_subobjs = 0;\n\t\t\t\t\t}\n\t\t\t\t\terr = dmu_object_free(p->bpo_os,\n\t\t\t\t\t    bpo->bpo_object, tx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmutex_exit(&bpo->bpo_lock);\n\t\t\t\tbpobj_close(bpo);\n\t\t\t\tkmem_free(bpo, sizeof (bpobj_t));\n\t\t\t} else {\n\t\t\t\tmutex_exit(&bpo->bpo_lock);\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_remove_head(&stack);\n\t\t\tkmem_free(bpi, sizeof (bpobj_info_t));\n\t\t} else {\n\t\t\t \n\t\t\tASSERT(bpo->bpo_havecomp);\n\t\t\tASSERT3P(bpobj_size, ==, NULL);\n\n\t\t\t \n\t\t\tint64_t i = bpi->bpi_unprocessed_subobjs - 1;\n\t\t\tuint64_t offset = i * sizeof (uint64_t);\n\n\t\t\tuint64_t subobj;\n\t\t\terr = dmu_read(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs,\n\t\t\t    offset, sizeof (uint64_t), &subobj,\n\t\t\t    DMU_READ_NO_PREFETCH);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tbpobj_t *subbpo = kmem_alloc(sizeof (bpobj_t),\n\t\t\t    KM_SLEEP);\n\t\t\terr = bpobj_open(subbpo, bpo->bpo_os, subobj);\n\t\t\tif (err) {\n\t\t\t\tkmem_free(subbpo, sizeof (bpobj_t));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (subbpo->bpo_havesubobj &&\n\t\t\t    subbpo->bpo_phys->bpo_subobjs != 0) {\n\t\t\t\tdmu_prefetch(subbpo->bpo_os,\n\t\t\t\t    subbpo->bpo_phys->bpo_subobjs, 0, 0, 0,\n\t\t\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t\t\t}\n\n\t\t\tlist_insert_head(&stack, bpi_alloc(subbpo, bpi, i));\n\t\t\tmutex_enter(&subbpo->bpo_lock);\n\t\t\tbpi->bpi_unprocessed_subobjs--;\n\t\t}\n\t}\n\t \n\twhile ((bpi = list_remove_head(&stack)) != NULL) {\n\t\tbpobj_t *bpo = bpi->bpi_bpo;\n\t\tASSERT(err != 0);\n\t\tASSERT3P(bpo, !=, NULL);\n\n\t\tmutex_exit(&bpo->bpo_lock);\n\n\t\t \n\t\tif (bpi->bpi_parent != NULL) {\n\t\t\tbpobj_close(bpi->bpi_bpo);\n\t\t\tkmem_free(bpi->bpi_bpo, sizeof (bpobj_t));\n\t\t}\n\t\tkmem_free(bpi, sizeof (bpobj_info_t));\n\t}\n\n\tlist_destroy(&stack);\n\n\treturn (err);\n}\n\n \nint\nbpobj_iterate(bpobj_t *bpo, bpobj_itor_t func, void *arg, dmu_tx_t *tx)\n{\n\treturn (bpobj_iterate_impl(bpo, func, arg, tx, B_TRUE, NULL));\n}\n\n \nint\nbpobj_iterate_nofree(bpobj_t *bpo, bpobj_itor_t func, void *arg,\n    uint64_t *bpobj_size)\n{\n\treturn (bpobj_iterate_impl(bpo, func, arg, NULL, B_FALSE, bpobj_size));\n}\n\n \nint\nlivelist_bpobj_iterate_from_nofree(bpobj_t *bpo, bpobj_itor_t func, void *arg,\n    int64_t start)\n{\n\tif (bpo->bpo_havesubobj)\n\t\tVERIFY0(bpo->bpo_phys->bpo_subobjs);\n\tbpobj_info_t *bpi = bpi_alloc(bpo, NULL, 0);\n\tint err = bpobj_iterate_blkptrs(bpi, func, arg, start, NULL, B_FALSE);\n\tkmem_free(bpi, sizeof (bpobj_info_t));\n\treturn (err);\n}\n\n \nvoid\nbpobj_enqueue_subobj(bpobj_t *bpo, uint64_t subobj, dmu_tx_t *tx)\n{\n\tbpobj_t subbpo;\n\tuint64_t used, comp, uncomp, subsubobjs;\n\tboolean_t copy_subsub = B_TRUE;\n\tboolean_t copy_bps = B_TRUE;\n\n\tASSERT(bpobj_is_open(bpo));\n\tASSERT(subobj != 0);\n\tASSERT(bpo->bpo_havesubobj);\n\tASSERT(bpo->bpo_havecomp);\n\tASSERT(bpo->bpo_object != dmu_objset_pool(bpo->bpo_os)->dp_empty_bpobj);\n\n\tif (subobj == dmu_objset_pool(bpo->bpo_os)->dp_empty_bpobj) {\n\t\tbpobj_decr_empty(bpo->bpo_os, tx);\n\t\treturn;\n\t}\n\n\tVERIFY3U(0, ==, bpobj_open(&subbpo, bpo->bpo_os, subobj));\n\tif (bpobj_is_empty(&subbpo)) {\n\t\t \n\t\tbpobj_close(&subbpo);\n\t\tbpobj_free(bpo->bpo_os, subobj, tx);\n\t\treturn;\n\t}\n\tVERIFY3U(0, ==, bpobj_space(&subbpo, &used, &comp, &uncomp));\n\n\tmutex_enter(&bpo->bpo_lock);\n\tdmu_buf_will_dirty(bpo->bpo_dbuf, tx);\n\n\tdmu_object_info_t doi;\n\n\tif (bpo->bpo_phys->bpo_subobjs != 0) {\n\t\tASSERT0(dmu_object_info(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs,\n\t\t    &doi));\n\t\tASSERT3U(doi.doi_type, ==, DMU_OT_BPOBJ_SUBOBJ);\n\t}\n\n\t \n\tsubsubobjs = subbpo.bpo_phys->bpo_subobjs;\n\tif (subsubobjs != 0) {\n\t\tVERIFY0(dmu_object_info(bpo->bpo_os, subsubobjs, &doi));\n\t\tif (doi.doi_max_offset > doi.doi_data_block_size) {\n\t\t\tcopy_subsub = B_FALSE;\n\t\t}\n\t}\n\n\t \n\tVERIFY3U(0, ==, dmu_object_info(bpo->bpo_os, subobj, &doi));\n\tif (doi.doi_max_offset > doi.doi_data_block_size || !copy_subsub) {\n\t\tcopy_bps = B_FALSE;\n\t}\n\n\tif (copy_subsub && subsubobjs != 0) {\n\t\tdmu_buf_t *subdb;\n\t\tuint64_t numsubsub = subbpo.bpo_phys->bpo_num_subobjs;\n\n\t\tVERIFY0(dmu_buf_hold(bpo->bpo_os, subsubobjs,\n\t\t    0, FTAG, &subdb, 0));\n\t\t \n\t\tVERIFY3U(subdb->db_size, >=,\n\t\t    numsubsub * sizeof (subobj));\n\t\tif (bpo->bpo_phys->bpo_subobjs == 0) {\n\t\t\tbpo->bpo_phys->bpo_subobjs =\n\t\t\t    dmu_object_alloc(bpo->bpo_os,\n\t\t\t    DMU_OT_BPOBJ_SUBOBJ, SPA_OLD_MAXBLOCKSIZE,\n\t\t\t    DMU_OT_NONE, 0, tx);\n\t\t}\n\t\tdmu_write(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs,\n\t\t    bpo->bpo_phys->bpo_num_subobjs * sizeof (subobj),\n\t\t    numsubsub * sizeof (subobj), subdb->db_data, tx);\n\t\tdmu_buf_rele(subdb, FTAG);\n\t\tbpo->bpo_phys->bpo_num_subobjs += numsubsub;\n\n\t\tdmu_buf_will_dirty(subbpo.bpo_dbuf, tx);\n\t\tsubbpo.bpo_phys->bpo_subobjs = 0;\n\t\tVERIFY0(dmu_object_free(bpo->bpo_os, subsubobjs, tx));\n\t}\n\n\tif (copy_bps) {\n\t\tdmu_buf_t *bps;\n\t\tuint64_t numbps = subbpo.bpo_phys->bpo_num_blkptrs;\n\n\t\tASSERT(copy_subsub);\n\t\tVERIFY0(dmu_buf_hold(bpo->bpo_os, subobj,\n\t\t    0, FTAG, &bps, 0));\n\n\t\t \n\t\tVERIFY3U(bps->db_size, >=, numbps * sizeof (blkptr_t));\n\t\tdmu_write(bpo->bpo_os, bpo->bpo_object,\n\t\t    bpo->bpo_phys->bpo_num_blkptrs * sizeof (blkptr_t),\n\t\t    numbps * sizeof (blkptr_t),\n\t\t    bps->db_data, tx);\n\t\tdmu_buf_rele(bps, FTAG);\n\t\tbpo->bpo_phys->bpo_num_blkptrs += numbps;\n\n\t\tbpobj_close(&subbpo);\n\t\tVERIFY0(dmu_object_free(bpo->bpo_os, subobj, tx));\n\t} else {\n\t\tbpobj_close(&subbpo);\n\t\tif (bpo->bpo_phys->bpo_subobjs == 0) {\n\t\t\tbpo->bpo_phys->bpo_subobjs =\n\t\t\t    dmu_object_alloc(bpo->bpo_os,\n\t\t\t    DMU_OT_BPOBJ_SUBOBJ, SPA_OLD_MAXBLOCKSIZE,\n\t\t\t    DMU_OT_NONE, 0, tx);\n\t\t}\n\n\t\tdmu_write(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs,\n\t\t    bpo->bpo_phys->bpo_num_subobjs * sizeof (subobj),\n\t\t    sizeof (subobj), &subobj, tx);\n\t\tbpo->bpo_phys->bpo_num_subobjs++;\n\t}\n\n\tbpo->bpo_phys->bpo_bytes += used;\n\tbpo->bpo_phys->bpo_comp += comp;\n\tbpo->bpo_phys->bpo_uncomp += uncomp;\n\tmutex_exit(&bpo->bpo_lock);\n\n}\n\n \nvoid\nbpobj_prefetch_subobj(bpobj_t *bpo, uint64_t subobj)\n{\n\tdmu_object_info_t doi;\n\tbpobj_t subbpo;\n\tuint64_t subsubobjs;\n\tboolean_t copy_subsub = B_TRUE;\n\tboolean_t copy_bps = B_TRUE;\n\n\tASSERT(bpobj_is_open(bpo));\n\tASSERT(subobj != 0);\n\n\tif (subobj == dmu_objset_pool(bpo->bpo_os)->dp_empty_bpobj)\n\t\treturn;\n\n\tif (bpobj_open(&subbpo, bpo->bpo_os, subobj) != 0)\n\t\treturn;\n\tif (bpobj_is_empty(&subbpo)) {\n\t\tbpobj_close(&subbpo);\n\t\treturn;\n\t}\n\tsubsubobjs = subbpo.bpo_phys->bpo_subobjs;\n\tbpobj_close(&subbpo);\n\n\tif (subsubobjs != 0) {\n\t\tif (dmu_object_info(bpo->bpo_os, subsubobjs, &doi) != 0)\n\t\t\treturn;\n\t\tif (doi.doi_max_offset > doi.doi_data_block_size)\n\t\t\tcopy_subsub = B_FALSE;\n\t}\n\n\tif (dmu_object_info(bpo->bpo_os, subobj, &doi) != 0)\n\t\treturn;\n\tif (doi.doi_max_offset > doi.doi_data_block_size || !copy_subsub)\n\t\tcopy_bps = B_FALSE;\n\n\tif (copy_subsub && subsubobjs != 0) {\n\t\tif (bpo->bpo_phys->bpo_subobjs) {\n\t\t\tdmu_prefetch(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs, 0,\n\t\t\t    bpo->bpo_phys->bpo_num_subobjs * sizeof (subobj), 1,\n\t\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t\t}\n\t\tdmu_prefetch(bpo->bpo_os, subsubobjs, 0, 0, 1,\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t}\n\n\tif (copy_bps) {\n\t\tdmu_prefetch(bpo->bpo_os, bpo->bpo_object, 0,\n\t\t    bpo->bpo_phys->bpo_num_blkptrs * sizeof (blkptr_t), 1,\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t\tdmu_prefetch(bpo->bpo_os, subobj, 0, 0, 1,\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t} else if (bpo->bpo_phys->bpo_subobjs) {\n\t\tdmu_prefetch(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs, 0,\n\t\t    bpo->bpo_phys->bpo_num_subobjs * sizeof (subobj), 1,\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t}\n}\n\nvoid\nbpobj_enqueue(bpobj_t *bpo, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\tblkptr_t stored_bp = *bp;\n\tuint64_t offset;\n\tint blkoff;\n\tblkptr_t *bparray;\n\n\tASSERT(bpobj_is_open(bpo));\n\tASSERT(!BP_IS_HOLE(bp));\n\tASSERT(bpo->bpo_object != dmu_objset_pool(bpo->bpo_os)->dp_empty_bpobj);\n\n\tif (BP_IS_EMBEDDED(bp)) {\n\t\t \n\t\tmemset(&stored_bp, 0, sizeof (stored_bp));\n\t\tstored_bp.blk_prop = bp->blk_prop;\n\t\tstored_bp.blk_birth = bp->blk_birth;\n\t} else if (!BP_GET_DEDUP(bp)) {\n\t\t \n\t\tmemset(&stored_bp.blk_cksum, 0, sizeof (stored_bp.blk_cksum));\n\t}\n\n\tstored_bp.blk_fill = 0;\n\tBP_SET_FREE(&stored_bp, bp_freed);\n\n\tmutex_enter(&bpo->bpo_lock);\n\n\toffset = bpo->bpo_phys->bpo_num_blkptrs * sizeof (stored_bp);\n\tblkoff = P2PHASE(bpo->bpo_phys->bpo_num_blkptrs, bpo->bpo_epb);\n\n\tif (bpo->bpo_cached_dbuf == NULL ||\n\t    offset < bpo->bpo_cached_dbuf->db_offset ||\n\t    offset >= bpo->bpo_cached_dbuf->db_offset +\n\t    bpo->bpo_cached_dbuf->db_size) {\n\t\tif (bpo->bpo_cached_dbuf)\n\t\t\tdmu_buf_rele(bpo->bpo_cached_dbuf, bpo);\n\t\tVERIFY3U(0, ==, dmu_buf_hold(bpo->bpo_os, bpo->bpo_object,\n\t\t    offset, bpo, &bpo->bpo_cached_dbuf, 0));\n\t\tASSERT3P(bpo->bpo_cached_dbuf, !=, NULL);\n\t}\n\n\tdmu_buf_will_dirty(bpo->bpo_cached_dbuf, tx);\n\tbparray = bpo->bpo_cached_dbuf->db_data;\n\tbparray[blkoff] = stored_bp;\n\n\tdmu_buf_will_dirty(bpo->bpo_dbuf, tx);\n\tbpo->bpo_phys->bpo_num_blkptrs++;\n\tint sign = bp_freed ? -1 : +1;\n\tbpo->bpo_phys->bpo_bytes += sign *\n\t    bp_get_dsize_sync(dmu_objset_spa(bpo->bpo_os), bp);\n\tif (bpo->bpo_havecomp) {\n\t\tbpo->bpo_phys->bpo_comp += sign * BP_GET_PSIZE(bp);\n\t\tbpo->bpo_phys->bpo_uncomp += sign * BP_GET_UCSIZE(bp);\n\t}\n\tif (bp_freed) {\n\t\tASSERT(bpo->bpo_havefreed);\n\t\tbpo->bpo_phys->bpo_num_freed++;\n\t}\n\tmutex_exit(&bpo->bpo_lock);\n}\n\nstruct space_range_arg {\n\tspa_t *spa;\n\tuint64_t mintxg;\n\tuint64_t maxtxg;\n\tuint64_t used;\n\tuint64_t comp;\n\tuint64_t uncomp;\n};\n\nstatic int\nspace_range_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed, dmu_tx_t *tx)\n{\n\t(void) bp_freed, (void) tx;\n\tstruct space_range_arg *sra = arg;\n\n\tif (bp->blk_birth > sra->mintxg && bp->blk_birth <= sra->maxtxg) {\n\t\tif (dsl_pool_sync_context(spa_get_dsl(sra->spa)))\n\t\t\tsra->used += bp_get_dsize_sync(sra->spa, bp);\n\t\telse\n\t\t\tsra->used += bp_get_dsize(sra->spa, bp);\n\t\tsra->comp += BP_GET_PSIZE(bp);\n\t\tsra->uncomp += BP_GET_UCSIZE(bp);\n\t}\n\treturn (0);\n}\n\nint\nbpobj_space(bpobj_t *bpo, uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tASSERT(bpobj_is_open(bpo));\n\tmutex_enter(&bpo->bpo_lock);\n\n\t*usedp = bpo->bpo_phys->bpo_bytes;\n\tif (bpo->bpo_havecomp) {\n\t\t*compp = bpo->bpo_phys->bpo_comp;\n\t\t*uncompp = bpo->bpo_phys->bpo_uncomp;\n\t\tmutex_exit(&bpo->bpo_lock);\n\t\treturn (0);\n\t} else {\n\t\tmutex_exit(&bpo->bpo_lock);\n\t\treturn (bpobj_space_range(bpo, 0, UINT64_MAX,\n\t\t    usedp, compp, uncompp));\n\t}\n}\n\n \nint\nbpobj_space_range(bpobj_t *bpo, uint64_t mintxg, uint64_t maxtxg,\n    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tstruct space_range_arg sra = { 0 };\n\tint err;\n\n\tASSERT(bpobj_is_open(bpo));\n\n\t \n\tif (mintxg < TXG_INITIAL && maxtxg == UINT64_MAX && bpo->bpo_havecomp)\n\t\treturn (bpobj_space(bpo, usedp, compp, uncompp));\n\n\tsra.spa = dmu_objset_spa(bpo->bpo_os);\n\tsra.mintxg = mintxg;\n\tsra.maxtxg = maxtxg;\n\n\terr = bpobj_iterate_nofree(bpo, space_range_cb, &sra, NULL);\n\t*usedp = sra.used;\n\t*compp = sra.comp;\n\t*uncompp = sra.uncomp;\n\treturn (err);\n}\n\n \nint\nbplist_append_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\t(void) bp_freed, (void) tx;\n\tbplist_t *bpl = arg;\n\tbplist_append(bpl, bp);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}