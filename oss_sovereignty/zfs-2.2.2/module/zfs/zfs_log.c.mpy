{
  "module_name": "zfs_log.c",
  "hash_id": "b3df1036f73c183ce09b5e47ca5f0fd7962d4e8184aec771cd23eed9b9ca0d49",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_log.c",
  "human_readable_source": " \n \n\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/cmn_err.h>\n#include <sys/kmem.h>\n#include <sys/thread.h>\n#include <sys/file.h>\n#include <sys/vfs.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_dir.h>\n#include <sys/zil.h>\n#include <sys/zil_impl.h>\n#include <sys/byteorder.h>\n#include <sys/policy.h>\n#include <sys/stat.h>\n#include <sys/acl.h>\n#include <sys/dmu.h>\n#include <sys/dbuf.h>\n#include <sys/spa.h>\n#include <sys/zfs_fuid.h>\n#include <sys/dsl_dataset.h>\n\n \n\nint\nzfs_log_create_txtype(zil_create_t type, vsecattr_t *vsecp, vattr_t *vap)\n{\n\tint isxvattr = (vap->va_mask & ATTR_XVATTR);\n\tswitch (type) {\n\tcase Z_FILE:\n\t\tif (vsecp == NULL && !isxvattr)\n\t\t\treturn (TX_CREATE);\n\t\tif (vsecp && isxvattr)\n\t\t\treturn (TX_CREATE_ACL_ATTR);\n\t\tif (vsecp)\n\t\t\treturn (TX_CREATE_ACL);\n\t\telse\n\t\t\treturn (TX_CREATE_ATTR);\n\tcase Z_DIR:\n\t\tif (vsecp == NULL && !isxvattr)\n\t\t\treturn (TX_MKDIR);\n\t\tif (vsecp && isxvattr)\n\t\t\treturn (TX_MKDIR_ACL_ATTR);\n\t\tif (vsecp)\n\t\t\treturn (TX_MKDIR_ACL);\n\t\telse\n\t\t\treturn (TX_MKDIR_ATTR);\n\tcase Z_XATTRDIR:\n\t\treturn (TX_MKXATTR);\n\t}\n\tASSERT(0);\n\treturn (TX_MAX_TYPE);\n}\n\n \nstatic void\nzfs_log_xvattr(lr_attr_t *lrattr, xvattr_t *xvap)\n{\n\txoptattr_t *xoap;\n\n\txoap = xva_getxoptattr(xvap);\n\tASSERT(xoap);\n\n\tlrattr->lr_attr_masksize = xvap->xva_mapsize;\n\tuint32_t *bitmap = &lrattr->lr_attr_bitmap;\n\tfor (int i = 0; i != xvap->xva_mapsize; i++, bitmap++)\n\t\t*bitmap = xvap->xva_reqattrmap[i];\n\n\tlr_attr_end_t *end = (lr_attr_end_t *)bitmap;\n\tend->lr_attr_attrs = 0;\n\tend->lr_attr_crtime[0] = 0;\n\tend->lr_attr_crtime[1] = 0;\n\tmemset(end->lr_attr_scanstamp, 0, AV_SCANSTAMP_SZ);\n\n\tif (XVA_ISSET_REQ(xvap, XAT_READONLY))\n\t\tend->lr_attr_attrs |= (xoap->xoa_readonly == 0) ? 0 :\n\t\t    XAT0_READONLY;\n\tif (XVA_ISSET_REQ(xvap, XAT_HIDDEN))\n\t\tend->lr_attr_attrs |= (xoap->xoa_hidden == 0) ? 0 :\n\t\t    XAT0_HIDDEN;\n\tif (XVA_ISSET_REQ(xvap, XAT_SYSTEM))\n\t\tend->lr_attr_attrs |= (xoap->xoa_system == 0) ? 0 :\n\t\t    XAT0_SYSTEM;\n\tif (XVA_ISSET_REQ(xvap, XAT_ARCHIVE))\n\t\tend->lr_attr_attrs |= (xoap->xoa_archive == 0) ? 0 :\n\t\t    XAT0_ARCHIVE;\n\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE))\n\t\tend->lr_attr_attrs |= (xoap->xoa_immutable == 0) ? 0 :\n\t\t    XAT0_IMMUTABLE;\n\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK))\n\t\tend->lr_attr_attrs |= (xoap->xoa_nounlink == 0) ? 0 :\n\t\t    XAT0_NOUNLINK;\n\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY))\n\t\tend->lr_attr_attrs |= (xoap->xoa_appendonly == 0) ? 0 :\n\t\t    XAT0_APPENDONLY;\n\tif (XVA_ISSET_REQ(xvap, XAT_OPAQUE))\n\t\tend->lr_attr_attrs |= (xoap->xoa_opaque == 0) ? 0 :\n\t\t    XAT0_APPENDONLY;\n\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP))\n\t\tend->lr_attr_attrs |= (xoap->xoa_nodump == 0) ? 0 :\n\t\t    XAT0_NODUMP;\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED))\n\t\tend->lr_attr_attrs |= (xoap->xoa_av_quarantined == 0) ? 0 :\n\t\t    XAT0_AV_QUARANTINED;\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED))\n\t\tend->lr_attr_attrs |= (xoap->xoa_av_modified == 0) ? 0 :\n\t\t    XAT0_AV_MODIFIED;\n\tif (XVA_ISSET_REQ(xvap, XAT_CREATETIME))\n\t\tZFS_TIME_ENCODE(&xoap->xoa_createtime, end->lr_attr_crtime);\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP)) {\n\t\tASSERT(!XVA_ISSET_REQ(xvap, XAT_PROJID));\n\n\t\tmemcpy(end->lr_attr_scanstamp, xoap->xoa_av_scanstamp,\n\t\t    AV_SCANSTAMP_SZ);\n\t} else if (XVA_ISSET_REQ(xvap, XAT_PROJID)) {\n\t\t \n\t\tmemcpy(end->lr_attr_scanstamp, &xoap->xoa_projid,\n\t\t    sizeof (uint64_t));\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE))\n\t\tend->lr_attr_attrs |= (xoap->xoa_reparse == 0) ? 0 :\n\t\t    XAT0_REPARSE;\n\tif (XVA_ISSET_REQ(xvap, XAT_OFFLINE))\n\t\tend->lr_attr_attrs |= (xoap->xoa_offline == 0) ? 0 :\n\t\t    XAT0_OFFLINE;\n\tif (XVA_ISSET_REQ(xvap, XAT_SPARSE))\n\t\tend->lr_attr_attrs |= (xoap->xoa_sparse == 0) ? 0 :\n\t\t    XAT0_SPARSE;\n\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT))\n\t\tend->lr_attr_attrs |= (xoap->xoa_projinherit == 0) ? 0 :\n\t\t    XAT0_PROJINHERIT;\n}\n\nstatic void *\nzfs_log_fuid_ids(zfs_fuid_info_t *fuidp, void *start)\n{\n\tzfs_fuid_t *zfuid;\n\tuint64_t *fuidloc = start;\n\n\t \n\tfor (zfuid = list_head(&fuidp->z_fuids); zfuid;\n\t    zfuid = list_next(&fuidp->z_fuids, zfuid)) {\n\t\t*fuidloc++ = zfuid->z_logfuid;\n\t}\n\treturn (fuidloc);\n}\n\n\nstatic void *\nzfs_log_fuid_domains(zfs_fuid_info_t *fuidp, void *start)\n{\n\tzfs_fuid_domain_t *zdomain;\n\n\t \n\tif (fuidp->z_domain_str_sz != 0) {\n\t\tfor (zdomain = list_head(&fuidp->z_domains); zdomain;\n\t\t    zdomain = list_next(&fuidp->z_domains, zdomain)) {\n\t\t\tmemcpy(start, zdomain->z_domain,\n\t\t\t    strlen(zdomain->z_domain) + 1);\n\t\t\tstart = (caddr_t)start +\n\t\t\t    strlen(zdomain->z_domain) + 1;\n\t\t}\n\t}\n\treturn (start);\n}\n\n \nstatic int\nzfs_xattr_owner_unlinked(znode_t *zp)\n{\n\tint unlinked = 0;\n\tznode_t *dzp;\n#ifdef __FreeBSD__\n\tznode_t *tzp = zp;\n\n\t \n\t \n\twhile (tzp->z_pflags & ZFS_XATTR) {\n\t\tASSERT3U(zp->z_xattr_parent, !=, 0);\n\t\tif (zfs_zget(ZTOZSB(tzp), tzp->z_xattr_parent, &dzp) != 0) {\n\t\t\tunlinked = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tzp != zp)\n\t\t\tzrele(tzp);\n\t\ttzp = dzp;\n\t\tunlinked = tzp->z_unlinked;\n\t}\n\tif (tzp != zp)\n\t\tzrele(tzp);\n#else\n\tzhold(zp);\n\t \n\twhile (zp->z_pflags & ZFS_XATTR) {\n\t\tASSERT3U(zp->z_xattr_parent, !=, 0);\n\t\tif (zfs_zget(ZTOZSB(zp), zp->z_xattr_parent, &dzp) != 0) {\n\t\t\tunlinked = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tzrele(zp);\n\t\tzp = dzp;\n\t\tunlinked = zp->z_unlinked;\n\t}\n\tzrele(zp);\n#endif\n\treturn (unlinked);\n}\n\n \nvoid\nzfs_log_create(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,\n    znode_t *dzp, znode_t *zp, const char *name, vsecattr_t *vsecp,\n    zfs_fuid_info_t *fuidp, vattr_t *vap)\n{\n\titx_t *itx;\n\tlr_create_t *lr;\n\tlr_acl_create_t *lracl;\n\tsize_t aclsize = 0;\n\tsize_t xvatsize = 0;\n\tsize_t txsize;\n\txvattr_t *xvap = (xvattr_t *)vap;\n\tvoid *end;\n\tsize_t lrsize;\n\tsize_t namesize = strlen(name) + 1;\n\tsize_t fuidsz = 0;\n\n\tif (zil_replaying(zilog, tx) || zfs_xattr_owner_unlinked(dzp))\n\t\treturn;\n\n\t \n\tif (fuidp) {\n\t\tfuidsz += fuidp->z_domain_str_sz;\n\t\tfuidsz += fuidp->z_fuid_cnt * sizeof (uint64_t);\n\t}\n\n\tif (vap->va_mask & ATTR_XVATTR)\n\t\txvatsize = ZIL_XVAT_SIZE(xvap->xva_mapsize);\n\n\tif ((int)txtype == TX_CREATE_ATTR || (int)txtype == TX_MKDIR_ATTR ||\n\t    (int)txtype == TX_CREATE || (int)txtype == TX_MKDIR ||\n\t    (int)txtype == TX_MKXATTR) {\n\t\ttxsize = sizeof (*lr) + namesize + fuidsz + xvatsize;\n\t\tlrsize = sizeof (*lr);\n\t} else {\n\t\ttxsize =\n\t\t    sizeof (lr_acl_create_t) + namesize + fuidsz +\n\t\t    ZIL_ACE_LENGTH(aclsize) + xvatsize;\n\t\tlrsize = sizeof (lr_acl_create_t);\n\t}\n\n\titx = zil_itx_create(txtype, txsize);\n\n\tlr = (lr_create_t *)&itx->itx_lr;\n\tlr->lr_doid = dzp->z_id;\n\tlr->lr_foid = zp->z_id;\n\t \n\tLR_FOID_SET_SLOTS(lr->lr_foid, zp->z_dnodesize >> DNODE_SHIFT);\n\tlr->lr_mode = zp->z_mode;\n\tif (!IS_EPHEMERAL(KUID_TO_SUID(ZTOUID(zp)))) {\n\t\tlr->lr_uid = (uint64_t)KUID_TO_SUID(ZTOUID(zp));\n\t} else {\n\t\tlr->lr_uid = fuidp->z_fuid_owner;\n\t}\n\tif (!IS_EPHEMERAL(KGID_TO_SGID(ZTOGID(zp)))) {\n\t\tlr->lr_gid = (uint64_t)KGID_TO_SGID(ZTOGID(zp));\n\t} else {\n\t\tlr->lr_gid = fuidp->z_fuid_group;\n\t}\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(ZTOZSB(zp)), &lr->lr_gen,\n\t    sizeof (uint64_t));\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_CRTIME(ZTOZSB(zp)),\n\t    lr->lr_crtime, sizeof (uint64_t) * 2);\n\n\tif (sa_lookup(zp->z_sa_hdl, SA_ZPL_RDEV(ZTOZSB(zp)), &lr->lr_rdev,\n\t    sizeof (lr->lr_rdev)) != 0)\n\t\tlr->lr_rdev = 0;\n\n\t \n\tif (vap->va_mask & ATTR_XVATTR) {\n\t\tzfs_log_xvattr((lr_attr_t *)((caddr_t)lr + lrsize), xvap);\n\t\tend = (caddr_t)lr + lrsize + xvatsize;\n\t} else {\n\t\tend = (caddr_t)lr + lrsize;\n\t}\n\n\t \n\n\tif (vsecp) {\n\t\tlracl = (lr_acl_create_t *)&itx->itx_lr;\n\t\tlracl->lr_aclcnt = vsecp->vsa_aclcnt;\n\t\tlracl->lr_acl_bytes = aclsize;\n\t\tlracl->lr_domcnt = fuidp ? fuidp->z_domain_cnt : 0;\n\t\tlracl->lr_fuidcnt  = fuidp ? fuidp->z_fuid_cnt : 0;\n\t\tif (vsecp->vsa_aclflags & VSA_ACE_ACLFLAGS)\n\t\t\tlracl->lr_acl_flags = (uint64_t)vsecp->vsa_aclflags;\n\t\telse\n\t\t\tlracl->lr_acl_flags = 0;\n\n\t\tmemcpy(end, vsecp->vsa_aclentp, aclsize);\n\t\tend = (caddr_t)end + ZIL_ACE_LENGTH(aclsize);\n\t}\n\n\t \n\tif (fuidp) {\n\t\tend = zfs_log_fuid_ids(fuidp, end);\n\t\tend = zfs_log_fuid_domains(fuidp, end);\n\t}\n\t \n\tmemcpy(end, name, namesize);\n\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_remove(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,\n    znode_t *dzp, const char *name, uint64_t foid, boolean_t unlinked)\n{\n\titx_t *itx;\n\tlr_remove_t *lr;\n\tsize_t namesize = strlen(name) + 1;\n\n\tif (zil_replaying(zilog, tx) || zfs_xattr_owner_unlinked(dzp))\n\t\treturn;\n\n\titx = zil_itx_create(txtype, sizeof (*lr) + namesize);\n\tlr = (lr_remove_t *)&itx->itx_lr;\n\tlr->lr_doid = dzp->z_id;\n\tmemcpy(lr + 1, name, namesize);\n\n\titx->itx_oid = foid;\n\n\t \n\tif (unlinked) {\n\t\tASSERT((txtype & ~TX_CI) == TX_REMOVE);\n\t\tzil_remove_async(zilog, foid);\n\t}\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_link(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,\n    znode_t *dzp, znode_t *zp, const char *name)\n{\n\titx_t *itx;\n\tlr_link_t *lr;\n\tsize_t namesize = strlen(name) + 1;\n\n\tif (zil_replaying(zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(txtype, sizeof (*lr) + namesize);\n\tlr = (lr_link_t *)&itx->itx_lr;\n\tlr->lr_doid = dzp->z_id;\n\tlr->lr_link_obj = zp->z_id;\n\tmemcpy(lr + 1, name, namesize);\n\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_symlink(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,\n    znode_t *dzp, znode_t *zp, const char *name, const char *link)\n{\n\titx_t *itx;\n\tlr_create_t *lr;\n\tsize_t namesize = strlen(name) + 1;\n\tsize_t linksize = strlen(link) + 1;\n\n\tif (zil_replaying(zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(txtype, sizeof (*lr) + namesize + linksize);\n\tlr = (lr_create_t *)&itx->itx_lr;\n\tlr->lr_doid = dzp->z_id;\n\tlr->lr_foid = zp->z_id;\n\tlr->lr_uid = KUID_TO_SUID(ZTOUID(zp));\n\tlr->lr_gid = KGID_TO_SGID(ZTOGID(zp));\n\tlr->lr_mode = zp->z_mode;\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(ZTOZSB(zp)), &lr->lr_gen,\n\t    sizeof (uint64_t));\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_CRTIME(ZTOZSB(zp)),\n\t    lr->lr_crtime, sizeof (uint64_t) * 2);\n\tmemcpy((char *)(lr + 1), name, namesize);\n\tmemcpy((char *)(lr + 1) + namesize, link, linksize);\n\n\tzil_itx_assign(zilog, itx, tx);\n}\n\nstatic void\ndo_zfs_log_rename(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype, znode_t *sdzp,\n    const char *sname, znode_t *tdzp, const char *dname, znode_t *szp)\n{\n\titx_t *itx;\n\tlr_rename_t *lr;\n\tsize_t snamesize = strlen(sname) + 1;\n\tsize_t dnamesize = strlen(dname) + 1;\n\n\tif (zil_replaying(zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(txtype, sizeof (*lr) + snamesize + dnamesize);\n\tlr = (lr_rename_t *)&itx->itx_lr;\n\tlr->lr_sdoid = sdzp->z_id;\n\tlr->lr_tdoid = tdzp->z_id;\n\tmemcpy((char *)(lr + 1), sname, snamesize);\n\tmemcpy((char *)(lr + 1) + snamesize, dname, dnamesize);\n\titx->itx_oid = szp->z_id;\n\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_rename(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype, znode_t *sdzp,\n    const char *sname, znode_t *tdzp, const char *dname, znode_t *szp)\n{\n\ttxtype |= TX_RENAME;\n\tdo_zfs_log_rename(zilog, tx, txtype, sdzp, sname, tdzp, dname, szp);\n}\n\n \nvoid\nzfs_log_rename_exchange(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,\n    znode_t *sdzp, const char *sname, znode_t *tdzp, const char *dname,\n    znode_t *szp)\n{\n\ttxtype |= TX_RENAME_EXCHANGE;\n\tdo_zfs_log_rename(zilog, tx, txtype, sdzp, sname, tdzp, dname, szp);\n}\n\n \nvoid\nzfs_log_rename_whiteout(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype,\n    znode_t *sdzp, const char *sname, znode_t *tdzp, const char *dname,\n    znode_t *szp, znode_t *wzp)\n{\n\titx_t *itx;\n\tlr_rename_whiteout_t *lr;\n\tsize_t snamesize = strlen(sname) + 1;\n\tsize_t dnamesize = strlen(dname) + 1;\n\n\tif (zil_replaying(zilog, tx))\n\t\treturn;\n\n\ttxtype |= TX_RENAME_WHITEOUT;\n\titx = zil_itx_create(txtype, sizeof (*lr) + snamesize + dnamesize);\n\tlr = (lr_rename_whiteout_t *)&itx->itx_lr;\n\tlr->lr_rename.lr_sdoid = sdzp->z_id;\n\tlr->lr_rename.lr_tdoid = tdzp->z_id;\n\n\t \n\tlr->lr_wfoid = wzp->z_id;\n\tLR_FOID_SET_SLOTS(lr->lr_wfoid, wzp->z_dnodesize >> DNODE_SHIFT);\n\t(void) sa_lookup(wzp->z_sa_hdl, SA_ZPL_GEN(ZTOZSB(wzp)), &lr->lr_wgen,\n\t    sizeof (uint64_t));\n\t(void) sa_lookup(wzp->z_sa_hdl, SA_ZPL_CRTIME(ZTOZSB(wzp)),\n\t    lr->lr_wcrtime, sizeof (uint64_t) * 2);\n\tlr->lr_wmode = wzp->z_mode;\n\tlr->lr_wuid = (uint64_t)KUID_TO_SUID(ZTOUID(wzp));\n\tlr->lr_wgid = (uint64_t)KGID_TO_SGID(ZTOGID(wzp));\n\n\t \n\t(void) sa_lookup(wzp->z_sa_hdl, SA_ZPL_RDEV(ZTOZSB(wzp)), &lr->lr_wrdev,\n\t    sizeof (lr->lr_wrdev));\n\n\tmemcpy((char *)(lr + 1), sname, snamesize);\n\tmemcpy((char *)(lr + 1) + snamesize, dname, dnamesize);\n\titx->itx_oid = szp->z_id;\n\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nstatic int64_t zfs_immediate_write_sz = 32768;\n\nvoid\nzfs_log_write(zilog_t *zilog, dmu_tx_t *tx, int txtype,\n    znode_t *zp, offset_t off, ssize_t resid, int ioflag,\n    zil_callback_t callback, void *callback_data)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)sa_get_db(zp->z_sa_hdl);\n\tuint32_t blocksize = zp->z_blksz;\n\titx_wr_state_t write_state;\n\tuintptr_t fsync_cnt;\n\tuint64_t gen = 0;\n\tssize_t size = resid;\n\n\tif (zil_replaying(zilog, tx) || zp->z_unlinked ||\n\t    zfs_xattr_owner_unlinked(zp)) {\n\t\tif (callback != NULL)\n\t\t\tcallback(callback_data);\n\t\treturn;\n\t}\n\n\tif (zilog->zl_logbias == ZFS_LOGBIAS_THROUGHPUT)\n\t\twrite_state = WR_INDIRECT;\n\telse if (!spa_has_slogs(zilog->zl_spa) &&\n\t    resid >= zfs_immediate_write_sz)\n\t\twrite_state = WR_INDIRECT;\n\telse if (ioflag & (O_SYNC | O_DSYNC))\n\t\twrite_state = WR_COPIED;\n\telse\n\t\twrite_state = WR_NEED_COPY;\n\n\tif ((fsync_cnt = (uintptr_t)tsd_get(zfs_fsyncer_key)) != 0) {\n\t\t(void) tsd_set(zfs_fsyncer_key, (void *)(fsync_cnt - 1));\n\t}\n\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(ZTOZSB(zp)), &gen,\n\t    sizeof (gen));\n\n\twhile (resid) {\n\t\titx_t *itx;\n\t\tlr_write_t *lr;\n\t\titx_wr_state_t wr_state = write_state;\n\t\tssize_t len = resid;\n\n\t\t \n\t\tif (wr_state == WR_COPIED &&\n\t\t    resid > zil_max_copied_data(zilog))\n\t\t\twr_state = WR_NEED_COPY;\n\t\telse if (wr_state == WR_INDIRECT)\n\t\t\tlen = MIN(blocksize - P2PHASE(off, blocksize), resid);\n\n\t\titx = zil_itx_create(txtype, sizeof (*lr) +\n\t\t    (wr_state == WR_COPIED ? len : 0));\n\t\tlr = (lr_write_t *)&itx->itx_lr;\n\n\t\t \n\t\tif (wr_state == WR_COPIED) {\n\t\t\tint err;\n\t\t\tDB_DNODE_ENTER(db);\n\t\t\terr = dmu_read_by_dnode(DB_DNODE(db), off, len, lr + 1,\n\t\t\t    DMU_READ_NO_PREFETCH);\n\t\t\tif (err != 0) {\n\t\t\t\tzil_itx_destroy(itx);\n\t\t\t\titx = zil_itx_create(txtype, sizeof (*lr));\n\t\t\t\tlr = (lr_write_t *)&itx->itx_lr;\n\t\t\t\twr_state = WR_NEED_COPY;\n\t\t\t}\n\t\t\tDB_DNODE_EXIT(db);\n\t\t}\n\n\t\titx->itx_wr_state = wr_state;\n\t\tlr->lr_foid = zp->z_id;\n\t\tlr->lr_offset = off;\n\t\tlr->lr_length = len;\n\t\tlr->lr_blkoff = 0;\n\t\tBP_ZERO(&lr->lr_blkptr);\n\n\t\titx->itx_private = ZTOZSB(zp);\n\t\titx->itx_gen = gen;\n\n\t\tif (!(ioflag & (O_SYNC | O_DSYNC)) && (zp->z_sync_cnt == 0) &&\n\t\t    (fsync_cnt == 0))\n\t\t\titx->itx_sync = B_FALSE;\n\n\t\titx->itx_callback = callback;\n\t\titx->itx_callback_data = callback_data;\n\t\tzil_itx_assign(zilog, itx, tx);\n\n\t\toff += len;\n\t\tresid -= len;\n\t}\n\n\tif (write_state == WR_COPIED || write_state == WR_NEED_COPY) {\n\t\tdsl_pool_wrlog_count(zilog->zl_dmu_pool, size, tx->tx_txg);\n\t}\n}\n\n \nvoid\nzfs_log_truncate(zilog_t *zilog, dmu_tx_t *tx, int txtype,\n    znode_t *zp, uint64_t off, uint64_t len)\n{\n\titx_t *itx;\n\tlr_truncate_t *lr;\n\n\tif (zil_replaying(zilog, tx) || zp->z_unlinked ||\n\t    zfs_xattr_owner_unlinked(zp))\n\t\treturn;\n\n\titx = zil_itx_create(txtype, sizeof (*lr));\n\tlr = (lr_truncate_t *)&itx->itx_lr;\n\tlr->lr_foid = zp->z_id;\n\tlr->lr_offset = off;\n\tlr->lr_length = len;\n\n\titx->itx_sync = (zp->z_sync_cnt != 0);\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_setattr(zilog_t *zilog, dmu_tx_t *tx, int txtype,\n    znode_t *zp, vattr_t *vap, uint_t mask_applied, zfs_fuid_info_t *fuidp)\n{\n\titx_t\t\t*itx;\n\tlr_setattr_t\t*lr;\n\txvattr_t\t*xvap = (xvattr_t *)vap;\n\tsize_t\t\trecsize = sizeof (lr_setattr_t);\n\tvoid\t\t*start;\n\n\tif (zil_replaying(zilog, tx) || zp->z_unlinked)\n\t\treturn;\n\n\t \n\tif (vap->va_mask & ATTR_XVATTR)\n\t\trecsize = sizeof (*lr) + ZIL_XVAT_SIZE(xvap->xva_mapsize);\n\n\tif (fuidp)\n\t\trecsize += fuidp->z_domain_str_sz;\n\n\titx = zil_itx_create(txtype, recsize);\n\tlr = (lr_setattr_t *)&itx->itx_lr;\n\tlr->lr_foid = zp->z_id;\n\tlr->lr_mask = (uint64_t)mask_applied;\n\tlr->lr_mode = (uint64_t)vap->va_mode;\n\tif ((mask_applied & ATTR_UID) && IS_EPHEMERAL(vap->va_uid))\n\t\tlr->lr_uid = fuidp->z_fuid_owner;\n\telse\n\t\tlr->lr_uid = (uint64_t)vap->va_uid;\n\n\tif ((mask_applied & ATTR_GID) && IS_EPHEMERAL(vap->va_gid))\n\t\tlr->lr_gid = fuidp->z_fuid_group;\n\telse\n\t\tlr->lr_gid = (uint64_t)vap->va_gid;\n\n\tlr->lr_size = (uint64_t)vap->va_size;\n\tZFS_TIME_ENCODE(&vap->va_atime, lr->lr_atime);\n\tZFS_TIME_ENCODE(&vap->va_mtime, lr->lr_mtime);\n\tstart = (lr_setattr_t *)(lr + 1);\n\tif (vap->va_mask & ATTR_XVATTR) {\n\t\tzfs_log_xvattr((lr_attr_t *)start, xvap);\n\t\tstart = (caddr_t)start + ZIL_XVAT_SIZE(xvap->xva_mapsize);\n\t}\n\n\t \n\n\tif (fuidp)\n\t\t(void) zfs_log_fuid_domains(fuidp, start);\n\n\titx->itx_sync = (zp->z_sync_cnt != 0);\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_setsaxattr(zilog_t *zilog, dmu_tx_t *tx, int txtype,\n    znode_t *zp, const char *name, const void *value, size_t size)\n{\n\titx_t\t\t*itx;\n\tlr_setsaxattr_t\t*lr;\n\tsize_t\t\trecsize = sizeof (lr_setsaxattr_t);\n\tvoid\t\t*xattrstart;\n\tint\t\tnamelen;\n\n\tif (zil_replaying(zilog, tx) || zp->z_unlinked)\n\t\treturn;\n\n\tnamelen = strlen(name) + 1;\n\trecsize += (namelen + size);\n\titx = zil_itx_create(txtype, recsize);\n\tlr = (lr_setsaxattr_t *)&itx->itx_lr;\n\tlr->lr_foid = zp->z_id;\n\txattrstart = (char *)(lr + 1);\n\tmemcpy(xattrstart, name, namelen);\n\tif (value != NULL) {\n\t\tmemcpy((char *)xattrstart + namelen, value, size);\n\t\tlr->lr_size = size;\n\t} else {\n\t\tlr->lr_size = 0;\n\t}\n\n\titx->itx_sync = (zp->z_sync_cnt != 0);\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_acl(zilog_t *zilog, dmu_tx_t *tx, znode_t *zp,\n    vsecattr_t *vsecp, zfs_fuid_info_t *fuidp)\n{\n\titx_t *itx;\n\tlr_acl_v0_t *lrv0;\n\tlr_acl_t *lr;\n\tint txtype;\n\tint lrsize;\n\tsize_t txsize;\n\tsize_t aclbytes = vsecp->vsa_aclentsz;\n\n\tif (zil_replaying(zilog, tx) || zp->z_unlinked)\n\t\treturn;\n\n\ttxtype = (ZTOZSB(zp)->z_version < ZPL_VERSION_FUID) ?\n\t    TX_ACL_V0 : TX_ACL;\n\n\tif (txtype == TX_ACL)\n\t\tlrsize = sizeof (*lr);\n\telse\n\t\tlrsize = sizeof (*lrv0);\n\n\ttxsize = lrsize +\n\t    ((txtype == TX_ACL) ? ZIL_ACE_LENGTH(aclbytes) : aclbytes) +\n\t    (fuidp ? fuidp->z_domain_str_sz : 0) +\n\t    sizeof (uint64_t) * (fuidp ? fuidp->z_fuid_cnt : 0);\n\n\titx = zil_itx_create(txtype, txsize);\n\n\tlr = (lr_acl_t *)&itx->itx_lr;\n\tlr->lr_foid = zp->z_id;\n\tif (txtype == TX_ACL) {\n\t\tlr->lr_acl_bytes = aclbytes;\n\t\tlr->lr_domcnt = fuidp ? fuidp->z_domain_cnt : 0;\n\t\tlr->lr_fuidcnt = fuidp ? fuidp->z_fuid_cnt : 0;\n\t\tif (vsecp->vsa_mask & VSA_ACE_ACLFLAGS)\n\t\t\tlr->lr_acl_flags = (uint64_t)vsecp->vsa_aclflags;\n\t\telse\n\t\t\tlr->lr_acl_flags = 0;\n\t}\n\tlr->lr_aclcnt = (uint64_t)vsecp->vsa_aclcnt;\n\n\tif (txtype == TX_ACL_V0) {\n\t\tlrv0 = (lr_acl_v0_t *)lr;\n\t\tmemcpy(lrv0 + 1, vsecp->vsa_aclentp, aclbytes);\n\t} else {\n\t\tvoid *start = (ace_t *)(lr + 1);\n\n\t\tmemcpy(start, vsecp->vsa_aclentp, aclbytes);\n\n\t\tstart = (caddr_t)start + ZIL_ACE_LENGTH(aclbytes);\n\n\t\tif (fuidp) {\n\t\t\tstart = zfs_log_fuid_ids(fuidp, start);\n\t\t\t(void) zfs_log_fuid_domains(fuidp, start);\n\t\t}\n\t}\n\n\titx->itx_sync = (zp->z_sync_cnt != 0);\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n \nvoid\nzfs_log_clone_range(zilog_t *zilog, dmu_tx_t *tx, int txtype, znode_t *zp,\n    uint64_t off, uint64_t len, uint64_t blksz, const blkptr_t *bps,\n    size_t nbps)\n{\n\titx_t *itx;\n\tlr_clone_range_t *lr;\n\tuint64_t partlen, max_log_data;\n\tsize_t i, partnbps;\n\n\tif (zil_replaying(zilog, tx) || zp->z_unlinked)\n\t\treturn;\n\n\tmax_log_data = zil_max_log_data(zilog, sizeof (lr_clone_range_t));\n\n\twhile (nbps > 0) {\n\t\tpartnbps = MIN(nbps, max_log_data / sizeof (bps[0]));\n\t\tpartlen = 0;\n\t\tfor (i = 0; i < partnbps; i++) {\n\t\t\tpartlen += BP_GET_LSIZE(&bps[i]);\n\t\t}\n\t\tpartlen = MIN(partlen, len);\n\n\t\titx = zil_itx_create(txtype,\n\t\t    sizeof (*lr) + sizeof (bps[0]) * partnbps);\n\t\tlr = (lr_clone_range_t *)&itx->itx_lr;\n\t\tlr->lr_foid = zp->z_id;\n\t\tlr->lr_offset = off;\n\t\tlr->lr_length = partlen;\n\t\tlr->lr_blksz = blksz;\n\t\tlr->lr_nbps = partnbps;\n\t\tmemcpy(lr->lr_bps, bps, sizeof (bps[0]) * partnbps);\n\n\t\titx->itx_sync = (zp->z_sync_cnt != 0);\n\n\t\tzil_itx_assign(zilog, itx, tx);\n\n\t\tbps += partnbps;\n\t\tASSERT3U(nbps, >=, partnbps);\n\t\tnbps -= partnbps;\n\t\toff += partlen;\n\t\tASSERT3U(len, >=, partlen);\n\t\tlen -= partlen;\n\t}\n}\n\nZFS_MODULE_PARAM(zfs, zfs_, immediate_write_sz, S64, ZMOD_RW,\n\t\"Largest data block to write to zil\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}