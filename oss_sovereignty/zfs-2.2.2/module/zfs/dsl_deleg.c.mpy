{
  "module_name": "dsl_deleg.c",
  "hash_id": "81b5f6ea7c8b4586fa267e55b2006c0c76912ee1bcadd9178a367822e355717f",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_deleg.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_deleg.h>\n#include <sys/spa.h>\n#include <sys/zap.h>\n#include <sys/fs/zfs.h>\n#include <sys/cred.h>\n#include <sys/sunddi.h>\n\n#include \"zfs_deleg.h\"\n\n \nint\ndsl_deleg_can_allow(char *ddname, nvlist_t *nvp, cred_t *cr)\n{\n\tnvpair_t *whopair = NULL;\n\tint error;\n\n\tif ((error = dsl_deleg_access(ddname, ZFS_DELEG_PERM_ALLOW, cr)) != 0)\n\t\treturn (error);\n\n\twhile ((whopair = nvlist_next_nvpair(nvp, whopair))) {\n\t\tnvlist_t *perms;\n\t\tnvpair_t *permpair = NULL;\n\n\t\tVERIFY(nvpair_value_nvlist(whopair, &perms) == 0);\n\n\t\twhile ((permpair = nvlist_next_nvpair(perms, permpair))) {\n\t\t\tconst char *perm = nvpair_name(permpair);\n\n\t\t\tif (strcmp(perm, ZFS_DELEG_PERM_ALLOW) == 0)\n\t\t\t\treturn (SET_ERROR(EPERM));\n\n\t\t\tif ((error = dsl_deleg_access(ddname, perm, cr)) != 0)\n\t\t\t\treturn (error);\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nint\ndsl_deleg_can_unallow(char *ddname, nvlist_t *nvp, cred_t *cr)\n{\n\tnvpair_t *whopair = NULL;\n\tint error;\n\tchar idstr[32];\n\n\tif ((error = dsl_deleg_access(ddname, ZFS_DELEG_PERM_ALLOW, cr)) != 0)\n\t\treturn (error);\n\n\t(void) snprintf(idstr, sizeof (idstr), \"%lld\",\n\t    (longlong_t)crgetuid(cr));\n\n\twhile ((whopair = nvlist_next_nvpair(nvp, whopair))) {\n\t\tzfs_deleg_who_type_t type = nvpair_name(whopair)[0];\n\n\t\tif (type != ZFS_DELEG_USER &&\n\t\t    type != ZFS_DELEG_USER_SETS)\n\t\t\treturn (SET_ERROR(EPERM));\n\n\t\tif (strcmp(idstr, &nvpair_name(whopair)[3]) != 0)\n\t\t\treturn (SET_ERROR(EPERM));\n\t}\n\treturn (0);\n}\n\ntypedef struct dsl_deleg_arg {\n\tconst char *dda_name;\n\tnvlist_t *dda_nvlist;\n} dsl_deleg_arg_t;\n\nstatic void\ndsl_deleg_set_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_deleg_arg_t *dda = arg;\n\tdsl_dir_t *dd;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tnvpair_t *whopair = NULL;\n\tuint64_t zapobj;\n\n\tVERIFY0(dsl_dir_hold(dp, dda->dda_name, FTAG, &dd, NULL));\n\n\tzapobj = dsl_dir_phys(dd)->dd_deleg_zapobj;\n\tif (zapobj == 0) {\n\t\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\t\tzapobj = dsl_dir_phys(dd)->dd_deleg_zapobj = zap_create(mos,\n\t\t    DMU_OT_DSL_PERMS, DMU_OT_NONE, 0, tx);\n\t}\n\n\twhile ((whopair = nvlist_next_nvpair(dda->dda_nvlist, whopair))) {\n\t\tconst char *whokey = nvpair_name(whopair);\n\t\tnvlist_t *perms;\n\t\tnvpair_t *permpair = NULL;\n\t\tuint64_t jumpobj;\n\n\t\tperms = fnvpair_value_nvlist(whopair);\n\n\t\tif (zap_lookup(mos, zapobj, whokey, 8, 1, &jumpobj) != 0) {\n\t\t\tjumpobj = zap_create_link(mos, DMU_OT_DSL_PERMS,\n\t\t\t    zapobj, whokey, tx);\n\t\t}\n\n\t\twhile ((permpair = nvlist_next_nvpair(perms, permpair))) {\n\t\t\tconst char *perm = nvpair_name(permpair);\n\t\t\tuint64_t n = 0;\n\n\t\t\tVERIFY(zap_update(mos, jumpobj,\n\t\t\t    perm, 8, 1, &n, tx) == 0);\n\t\t\tspa_history_log_internal_dd(dd, \"permission update\", tx,\n\t\t\t    \"%s %s\", whokey, perm);\n\t\t}\n\t}\n\tdsl_dir_rele(dd, FTAG);\n}\n\nstatic void\ndsl_deleg_unset_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_deleg_arg_t *dda = arg;\n\tdsl_dir_t *dd;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tnvpair_t *whopair = NULL;\n\tuint64_t zapobj;\n\n\tVERIFY0(dsl_dir_hold(dp, dda->dda_name, FTAG, &dd, NULL));\n\tzapobj = dsl_dir_phys(dd)->dd_deleg_zapobj;\n\tif (zapobj == 0) {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn;\n\t}\n\n\twhile ((whopair = nvlist_next_nvpair(dda->dda_nvlist, whopair))) {\n\t\tconst char *whokey = nvpair_name(whopair);\n\t\tnvlist_t *perms;\n\t\tnvpair_t *permpair = NULL;\n\t\tuint64_t jumpobj;\n\n\t\tif (nvpair_value_nvlist(whopair, &perms) != 0) {\n\t\t\tif (zap_lookup(mos, zapobj, whokey, 8,\n\t\t\t    1, &jumpobj) == 0) {\n\t\t\t\t(void) zap_remove(mos, zapobj, whokey, tx);\n\t\t\t\tVERIFY(0 == zap_destroy(mos, jumpobj, tx));\n\t\t\t}\n\t\t\tspa_history_log_internal_dd(dd, \"permission who remove\",\n\t\t\t    tx, \"%s\", whokey);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (zap_lookup(mos, zapobj, whokey, 8, 1, &jumpobj) != 0)\n\t\t\tcontinue;\n\n\t\twhile ((permpair = nvlist_next_nvpair(perms, permpair))) {\n\t\t\tconst char *perm = nvpair_name(permpair);\n\t\t\tuint64_t n = 0;\n\n\t\t\t(void) zap_remove(mos, jumpobj, perm, tx);\n\t\t\tif (zap_count(mos, jumpobj, &n) == 0 && n == 0) {\n\t\t\t\t(void) zap_remove(mos, zapobj,\n\t\t\t\t    whokey, tx);\n\t\t\t\tVERIFY(0 == zap_destroy(mos,\n\t\t\t\t    jumpobj, tx));\n\t\t\t}\n\t\t\tspa_history_log_internal_dd(dd, \"permission remove\", tx,\n\t\t\t    \"%s %s\", whokey, perm);\n\t\t}\n\t}\n\tdsl_dir_rele(dd, FTAG);\n}\n\nstatic int\ndsl_deleg_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_deleg_arg_t *dda = arg;\n\tdsl_dir_t *dd;\n\tint error;\n\n\tif (spa_version(dmu_tx_pool(tx)->dp_spa) <\n\t    SPA_VERSION_DELEGATED_PERMS) {\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\terror = dsl_dir_hold(dmu_tx_pool(tx), dda->dda_name, FTAG, &dd, NULL);\n\tif (error == 0)\n\t\tdsl_dir_rele(dd, FTAG);\n\treturn (error);\n}\n\nint\ndsl_deleg_set(const char *ddname, nvlist_t *nvp, boolean_t unset)\n{\n\tdsl_deleg_arg_t dda;\n\n\t \n\n\tdda.dda_name = ddname;\n\tdda.dda_nvlist = nvp;\n\n\treturn (dsl_sync_task(ddname, dsl_deleg_check,\n\t    unset ? dsl_deleg_unset_sync : dsl_deleg_set_sync,\n\t    &dda, fnvlist_num_pairs(nvp), ZFS_SPACE_CHECK_RESERVED));\n}\n\n \nint\ndsl_deleg_get(const char *ddname, nvlist_t **nvp)\n{\n\tdsl_dir_t *dd, *startdd;\n\tdsl_pool_t *dp;\n\tint error;\n\tobjset_t *mos;\n\tzap_cursor_t *basezc, *zc;\n\tzap_attribute_t *baseza, *za;\n\tchar *source;\n\n\terror = dsl_pool_hold(ddname, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dir_hold(dp, ddname, FTAG, &startdd, NULL);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tdp = startdd->dd_pool;\n\tmos = dp->dp_meta_objset;\n\n\tzc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\tbasezc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tbaseza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\tsource = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\tVERIFY(nvlist_alloc(nvp, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\tfor (dd = startdd; dd != NULL; dd = dd->dd_parent) {\n\t\tnvlist_t *sp_nvp;\n\t\tuint64_t n;\n\n\t\tif (dsl_dir_phys(dd)->dd_deleg_zapobj == 0 ||\n\t\t    zap_count(mos,\n\t\t    dsl_dir_phys(dd)->dd_deleg_zapobj, &n) != 0 || n == 0)\n\t\t\tcontinue;\n\n\t\tsp_nvp = fnvlist_alloc();\n\t\tfor (zap_cursor_init(basezc, mos,\n\t\t    dsl_dir_phys(dd)->dd_deleg_zapobj);\n\t\t    zap_cursor_retrieve(basezc, baseza) == 0;\n\t\t    zap_cursor_advance(basezc)) {\n\t\t\tnvlist_t *perms_nvp;\n\n\t\t\tASSERT(baseza->za_integer_length == 8);\n\t\t\tASSERT(baseza->za_num_integers == 1);\n\n\t\t\tperms_nvp = fnvlist_alloc();\n\t\t\tfor (zap_cursor_init(zc, mos, baseza->za_first_integer);\n\t\t\t    zap_cursor_retrieve(zc, za) == 0;\n\t\t\t    zap_cursor_advance(zc)) {\n\t\t\t\tfnvlist_add_boolean(perms_nvp, za->za_name);\n\t\t\t}\n\t\t\tzap_cursor_fini(zc);\n\t\t\tfnvlist_add_nvlist(sp_nvp, baseza->za_name, perms_nvp);\n\t\t\tfnvlist_free(perms_nvp);\n\t\t}\n\n\t\tzap_cursor_fini(basezc);\n\n\t\tdsl_dir_name(dd, source);\n\t\tfnvlist_add_nvlist(*nvp, source, sp_nvp);\n\t\tnvlist_free(sp_nvp);\n\t}\n\n\tkmem_free(source, ZFS_MAX_DATASET_NAME_LEN);\n\tkmem_free(baseza, sizeof (zap_attribute_t));\n\tkmem_free(basezc, sizeof (zap_cursor_t));\n\tkmem_free(za, sizeof (zap_attribute_t));\n\tkmem_free(zc, sizeof (zap_cursor_t));\n\n\tdsl_dir_rele(startdd, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (0);\n}\n\n \ntypedef struct perm_set {\n\tavl_node_t\tp_node;\n\tboolean_t\tp_matched;\n\tchar\t\tp_setname[ZFS_MAX_DELEG_NAME];\n} perm_set_t;\n\nstatic int\nperm_set_compare(const void *arg1, const void *arg2)\n{\n\tconst perm_set_t *node1 = (const perm_set_t *)arg1;\n\tconst perm_set_t *node2 = (const perm_set_t *)arg2;\n\tint val;\n\n\tval = strcmp(node1->p_setname, node2->p_setname);\n\n\treturn (TREE_ISIGN(val));\n}\n\n \nstatic int\ndsl_check_access(objset_t *mos, uint64_t zapobj,\n    char type, char checkflag, void *valp, const char *perm)\n{\n\tint error;\n\tuint64_t jumpobj, zero;\n\tchar whokey[ZFS_MAX_DELEG_NAME];\n\n\tzfs_deleg_whokey(whokey, type, checkflag, valp);\n\terror = zap_lookup(mos, zapobj, whokey, 8, 1, &jumpobj);\n\tif (error == 0) {\n\t\terror = zap_lookup(mos, jumpobj, perm, 8, 1, &zero);\n\t\tif (error == ENOENT)\n\t\t\terror = SET_ERROR(EPERM);\n\t}\n\treturn (error);\n}\n\n \nstatic int\ndsl_check_user_access(objset_t *mos, uint64_t zapobj, const char *perm,\n    int checkflag, cred_t *cr)\n{\n\tconst\tgid_t *gids;\n\tint\tngids;\n\tint\ti;\n\tuint64_t id;\n\n\t \n\tid = crgetuid(cr);\n\tif (dsl_check_access(mos, zapobj,\n\t    ZFS_DELEG_USER, checkflag, &id, perm) == 0)\n\t\treturn (0);\n\n\t \n\tid = crgetgid(cr);\n\tif (dsl_check_access(mos, zapobj,\n\t    ZFS_DELEG_GROUP, checkflag, &id, perm) == 0)\n\t\treturn (0);\n\n\t \n\tid = -1;\n\tif (dsl_check_access(mos, zapobj,\n\t    ZFS_DELEG_EVERYONE, checkflag, &id, perm) == 0)\n\t\treturn (0);\n\n\t \n\tngids = crgetngroups(cr);\n\tgids = crgetgroups(cr);\n\tfor (i = 0; i != ngids; i++) {\n\t\tid = gids[i];\n\t\tif (dsl_check_access(mos, zapobj,\n\t\t    ZFS_DELEG_GROUP, checkflag, &id, perm) == 0)\n\t\t\treturn (0);\n\t}\n\n\treturn (SET_ERROR(EPERM));\n}\n\n \nstatic int\ndsl_load_sets(objset_t *mos, uint64_t zapobj,\n    char type, char checkflag, void *valp, avl_tree_t *avl)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tperm_set_t *permnode;\n\tavl_index_t idx;\n\tuint64_t jumpobj;\n\tint error;\n\tchar whokey[ZFS_MAX_DELEG_NAME];\n\n\tzfs_deleg_whokey(whokey, type, checkflag, valp);\n\n\terror = zap_lookup(mos, zapobj, whokey, 8, 1, &jumpobj);\n\tif (error != 0)\n\t\treturn (error);\n\n\tfor (zap_cursor_init(&zc, mos, jumpobj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tpermnode = kmem_alloc(sizeof (perm_set_t), KM_SLEEP);\n\t\t(void) strlcpy(permnode->p_setname, za.za_name,\n\t\t    sizeof (permnode->p_setname));\n\t\tpermnode->p_matched = B_FALSE;\n\n\t\tif (avl_find(avl, permnode, &idx) == NULL) {\n\t\t\tavl_insert(avl, permnode, idx);\n\t\t} else {\n\t\t\tkmem_free(permnode, sizeof (perm_set_t));\n\t\t}\n\t}\n\tzap_cursor_fini(&zc);\n\treturn (0);\n}\n\n \nstatic void\ndsl_load_user_sets(objset_t *mos, uint64_t zapobj, avl_tree_t *avl,\n    char checkflag, cred_t *cr)\n{\n\tconst\tgid_t *gids;\n\tint\tngids, i;\n\tuint64_t id;\n\n\tid = crgetuid(cr);\n\t(void) dsl_load_sets(mos, zapobj,\n\t    ZFS_DELEG_USER_SETS, checkflag, &id, avl);\n\n\tid = crgetgid(cr);\n\t(void) dsl_load_sets(mos, zapobj,\n\t    ZFS_DELEG_GROUP_SETS, checkflag, &id, avl);\n\n\t(void) dsl_load_sets(mos, zapobj,\n\t    ZFS_DELEG_EVERYONE_SETS, checkflag, NULL, avl);\n\n\tngids = crgetngroups(cr);\n\tgids = crgetgroups(cr);\n\tfor (i = 0; i != ngids; i++) {\n\t\tid = gids[i];\n\t\t(void) dsl_load_sets(mos, zapobj,\n\t\t    ZFS_DELEG_GROUP_SETS, checkflag, &id, avl);\n\t}\n}\n\n \nint\ndsl_deleg_access_impl(dsl_dataset_t *ds, const char *perm, cred_t *cr)\n{\n\tdsl_dir_t *dd;\n\tdsl_pool_t *dp;\n\tvoid *cookie;\n\tint\terror;\n\tchar\tcheckflag;\n\tobjset_t *mos;\n\tavl_tree_t permsets;\n\tperm_set_t *setnode;\n\n\tdp = ds->ds_dir->dd_pool;\n\tmos = dp->dp_meta_objset;\n\n\tif (dsl_delegation_on(mos) == B_FALSE)\n\t\treturn (SET_ERROR(ECANCELED));\n\n\tif (spa_version(dmu_objset_spa(dp->dp_meta_objset)) <\n\t    SPA_VERSION_DELEGATED_PERMS)\n\t\treturn (SET_ERROR(EPERM));\n\n\tif (ds->ds_is_snapshot) {\n\t\t \n\t\tcheckflag = ZFS_DELEG_DESCENDENT;\n\t} else {\n\t\tcheckflag = ZFS_DELEG_LOCAL;\n\t}\n\n\tavl_create(&permsets, perm_set_compare, sizeof (perm_set_t),\n\t    offsetof(perm_set_t, p_node));\n\n\tASSERT(dsl_pool_config_held(dp));\n\tfor (dd = ds->ds_dir; dd != NULL; dd = dd->dd_parent,\n\t    checkflag = ZFS_DELEG_DESCENDENT) {\n\t\tuint64_t zapobj;\n\t\tboolean_t expanded;\n\n\t\t \n\t\tif (!INGLOBALZONE(curproc)) {\n\t\t\tuint64_t zoned;\n\n\t\t\tif (dsl_prop_get_dd(dd,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_ZONED),\n\t\t\t    8, 1, &zoned, NULL, B_FALSE) != 0)\n\t\t\t\tbreak;\n\t\t\tif (!zoned)\n\t\t\t\tbreak;\n\t\t}\n\t\tzapobj = dsl_dir_phys(dd)->dd_deleg_zapobj;\n\n\t\tif (zapobj == 0)\n\t\t\tcontinue;\n\n\t\tdsl_load_user_sets(mos, zapobj, &permsets, checkflag, cr);\nagain:\n\t\texpanded = B_FALSE;\n\t\tfor (setnode = avl_first(&permsets); setnode;\n\t\t    setnode = AVL_NEXT(&permsets, setnode)) {\n\t\t\tif (setnode->p_matched == B_TRUE)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\terror = dsl_check_access(mos, zapobj,\n\t\t\t    ZFS_DELEG_NAMED_SET, 0, setnode->p_setname, perm);\n\t\t\tif (error == 0)\n\t\t\t\tgoto success;\n\t\t\tif (error == EPERM)\n\t\t\t\tsetnode->p_matched = B_TRUE;\n\n\t\t\t \n\t\t\terror = dsl_load_sets(mos, zapobj,\n\t\t\t    ZFS_DELEG_NAMED_SET_SETS, 0,\n\t\t\t    setnode->p_setname, &permsets);\n\t\t\tif (error == 0)\n\t\t\t\tsetnode->p_matched = expanded = B_TRUE;\n\t\t}\n\t\t \n\t\tif (expanded)\n\t\t\tgoto again;\n\n\t\terror = dsl_check_user_access(mos, zapobj, perm, checkflag, cr);\n\t\tif (error == 0)\n\t\t\tgoto success;\n\t}\n\terror = SET_ERROR(EPERM);\nsuccess:\n\n\tcookie = NULL;\n\twhile ((setnode = avl_destroy_nodes(&permsets, &cookie)) != NULL)\n\t\tkmem_free(setnode, sizeof (perm_set_t));\n\n\treturn (error);\n}\n\nint\ndsl_deleg_access(const char *dsname, const char *perm, cred_t *cr)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tint error;\n\n\terror = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\terror = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\tif (error == 0) {\n\t\terror = dsl_deleg_access_impl(ds, perm, cr);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\tdsl_pool_rele(dp, FTAG);\n\n\treturn (error);\n}\n\n \n\nstatic void\ncopy_create_perms(dsl_dir_t *dd, uint64_t pzapobj,\n    boolean_t dosets, uint64_t uid, dmu_tx_t *tx)\n{\n\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\tuint64_t jumpobj, pjumpobj;\n\tuint64_t zapobj = dsl_dir_phys(dd)->dd_deleg_zapobj;\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tchar whokey[ZFS_MAX_DELEG_NAME];\n\n\tzfs_deleg_whokey(whokey,\n\t    dosets ? ZFS_DELEG_CREATE_SETS : ZFS_DELEG_CREATE,\n\t    ZFS_DELEG_LOCAL, NULL);\n\tif (zap_lookup(mos, pzapobj, whokey, 8, 1, &pjumpobj) != 0)\n\t\treturn;\n\n\tif (zapobj == 0) {\n\t\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\t\tzapobj = dsl_dir_phys(dd)->dd_deleg_zapobj = zap_create(mos,\n\t\t    DMU_OT_DSL_PERMS, DMU_OT_NONE, 0, tx);\n\t}\n\n\tzfs_deleg_whokey(whokey,\n\t    dosets ? ZFS_DELEG_USER_SETS : ZFS_DELEG_USER,\n\t    ZFS_DELEG_LOCAL, &uid);\n\tif (zap_lookup(mos, zapobj, whokey, 8, 1, &jumpobj) == ENOENT) {\n\t\tjumpobj = zap_create(mos, DMU_OT_DSL_PERMS, DMU_OT_NONE, 0, tx);\n\t\tVERIFY(zap_add(mos, zapobj, whokey, 8, 1, &jumpobj, tx) == 0);\n\t}\n\n\tfor (zap_cursor_init(&zc, mos, pjumpobj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tuint64_t zero = 0;\n\t\tASSERT(za.za_integer_length == 8 && za.za_num_integers == 1);\n\n\t\tVERIFY(zap_update(mos, jumpobj, za.za_name,\n\t\t    8, 1, &zero, tx) == 0);\n\t}\n\tzap_cursor_fini(&zc);\n}\n\n \nvoid\ndsl_deleg_set_create_perms(dsl_dir_t *sdd, dmu_tx_t *tx, cred_t *cr)\n{\n\tdsl_dir_t *dd;\n\tuint64_t uid = crgetuid(cr);\n\n\tif (spa_version(dmu_objset_spa(sdd->dd_pool->dp_meta_objset)) <\n\t    SPA_VERSION_DELEGATED_PERMS)\n\t\treturn;\n\n\tfor (dd = sdd->dd_parent; dd != NULL; dd = dd->dd_parent) {\n\t\tuint64_t pzapobj = dsl_dir_phys(dd)->dd_deleg_zapobj;\n\n\t\tif (pzapobj == 0)\n\t\t\tcontinue;\n\n\t\tcopy_create_perms(sdd, pzapobj, B_FALSE, uid, tx);\n\t\tcopy_create_perms(sdd, pzapobj, B_TRUE, uid, tx);\n\t}\n}\n\nint\ndsl_deleg_destroy(objset_t *mos, uint64_t zapobj, dmu_tx_t *tx)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\n\tif (zapobj == 0)\n\t\treturn (0);\n\n\tfor (zap_cursor_init(&zc, mos, zapobj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tASSERT(za.za_integer_length == 8 && za.za_num_integers == 1);\n\t\tVERIFY(0 == zap_destroy(mos, za.za_first_integer, tx));\n\t}\n\tzap_cursor_fini(&zc);\n\tVERIFY(0 == zap_destroy(mos, zapobj, tx));\n\treturn (0);\n}\n\nboolean_t\ndsl_delegation_on(objset_t *os)\n{\n\treturn (!!spa_delegation(os->os_spa));\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dsl_deleg_get);\nEXPORT_SYMBOL(dsl_deleg_set);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}