{
  "module_name": "dsl_dir.c",
  "hash_id": "77255991eb2e4fef2076a7c9c6d84f810545d83038259fca03a5cc51f546f019",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_dir.c",
  "human_readable_source": " \n \n\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_deleg.h>\n#include <sys/dmu_impl.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/metaslab.h>\n#include <sys/zap.h>\n#include <sys/zio.h>\n#include <sys/arc.h>\n#include <sys/sunddi.h>\n#include <sys/zfeature.h>\n#include <sys/policy.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n#include <sys/zvol.h>\n#include <sys/zthr.h>\n#include \"zfs_namecheck.h\"\n#include \"zfs_prop.h\"\n\n \nstatic int zvol_enforce_quotas = B_TRUE;\n\n \n\nstatic uint64_t dsl_dir_space_towrite(dsl_dir_t *dd);\n\ntypedef struct ddulrt_arg {\n\tdsl_dir_t\t*ddulrta_dd;\n\tuint64_t\tddlrta_txg;\n} ddulrt_arg_t;\n\nstatic void\ndsl_dir_evict_async(void *dbu)\n{\n\tdsl_dir_t *dd = dbu;\n\tint t;\n\tdsl_pool_t *dp __maybe_unused = dd->dd_pool;\n\n\tdd->dd_dbuf = NULL;\n\n\tfor (t = 0; t < TXG_SIZE; t++) {\n\t\tASSERT(!txg_list_member(&dp->dp_dirty_dirs, dd, t));\n\t\tASSERT(dd->dd_tempreserved[t] == 0);\n\t\tASSERT(dd->dd_space_towrite[t] == 0);\n\t}\n\n\tif (dd->dd_parent)\n\t\tdsl_dir_async_rele(dd->dd_parent, dd);\n\n\tspa_async_close(dd->dd_pool->dp_spa, dd);\n\n\tif (dsl_deadlist_is_open(&dd->dd_livelist))\n\t\tdsl_dir_livelist_close(dd);\n\n\tdsl_prop_fini(dd);\n\tcv_destroy(&dd->dd_activity_cv);\n\tmutex_destroy(&dd->dd_activity_lock);\n\tmutex_destroy(&dd->dd_lock);\n\tkmem_free(dd, sizeof (dsl_dir_t));\n}\n\nint\ndsl_dir_hold_obj(dsl_pool_t *dp, uint64_t ddobj,\n    const char *tail, const void *tag, dsl_dir_t **ddp)\n{\n\tdmu_buf_t *dbuf;\n\tdsl_dir_t *dd;\n\tdmu_object_info_t doi;\n\tint err;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\terr = dmu_bonus_hold(dp->dp_meta_objset, ddobj, tag, &dbuf);\n\tif (err != 0)\n\t\treturn (err);\n\tdd = dmu_buf_get_user(dbuf);\n\n\tdmu_object_info_from_db(dbuf, &doi);\n\tASSERT3U(doi.doi_bonus_type, ==, DMU_OT_DSL_DIR);\n\tASSERT3U(doi.doi_bonus_size, >=, sizeof (dsl_dir_phys_t));\n\n\tif (dd == NULL) {\n\t\tdsl_dir_t *winner;\n\n\t\tdd = kmem_zalloc(sizeof (dsl_dir_t), KM_SLEEP);\n\t\tdd->dd_object = ddobj;\n\t\tdd->dd_dbuf = dbuf;\n\t\tdd->dd_pool = dp;\n\n\t\tmutex_init(&dd->dd_lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tmutex_init(&dd->dd_activity_lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tcv_init(&dd->dd_activity_cv, NULL, CV_DEFAULT, NULL);\n\t\tdsl_prop_init(dd);\n\n\t\tif (dsl_dir_is_zapified(dd)) {\n\t\t\terr = zap_lookup(dp->dp_meta_objset,\n\t\t\t    ddobj, DD_FIELD_CRYPTO_KEY_OBJ,\n\t\t\t    sizeof (uint64_t), 1, &dd->dd_crypto_obj);\n\t\t\tif (err == 0) {\n\t\t\t\t \n\t\t\t\tif (dsl_dir_incompatible_encryption_version(\n\t\t\t\t    dd)) {\n\t\t\t\t\tdp->dp_spa->spa_errata =\n\t\t\t\t\t    ZPOOL_ERRATA_ZOL_6845_ENCRYPTION;\n\t\t\t\t}\n\t\t\t} else if (err != ENOENT) {\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (dsl_dir_phys(dd)->dd_parent_obj) {\n\t\t\terr = dsl_dir_hold_obj(dp,\n\t\t\t    dsl_dir_phys(dd)->dd_parent_obj, NULL, dd,\n\t\t\t    &dd->dd_parent);\n\t\t\tif (err != 0)\n\t\t\t\tgoto errout;\n\t\t\tif (tail) {\n#ifdef ZFS_DEBUG\n\t\t\t\tuint64_t foundobj;\n\n\t\t\t\terr = zap_lookup(dp->dp_meta_objset,\n\t\t\t\t    dsl_dir_phys(dd->dd_parent)->\n\t\t\t\t    dd_child_dir_zapobj, tail,\n\t\t\t\t    sizeof (foundobj), 1, &foundobj);\n\t\t\t\tASSERT(err || foundobj == ddobj);\n#endif\n\t\t\t\t(void) strlcpy(dd->dd_myname, tail,\n\t\t\t\t    sizeof (dd->dd_myname));\n\t\t\t} else {\n\t\t\t\terr = zap_value_search(dp->dp_meta_objset,\n\t\t\t\t    dsl_dir_phys(dd->dd_parent)->\n\t\t\t\t    dd_child_dir_zapobj,\n\t\t\t\t    ddobj, 0, dd->dd_myname);\n\t\t\t}\n\t\t\tif (err != 0)\n\t\t\t\tgoto errout;\n\t\t} else {\n\t\t\t(void) strlcpy(dd->dd_myname, spa_name(dp->dp_spa),\n\t\t\t    sizeof (dd->dd_myname));\n\t\t}\n\n\t\tif (dsl_dir_is_clone(dd)) {\n\t\t\tdmu_buf_t *origin_bonus;\n\t\t\tdsl_dataset_phys_t *origin_phys;\n\n\t\t\t \n\t\t\terr = dmu_bonus_hold(dp->dp_meta_objset,\n\t\t\t    dsl_dir_phys(dd)->dd_origin_obj, FTAG,\n\t\t\t    &origin_bonus);\n\t\t\tif (err != 0)\n\t\t\t\tgoto errout;\n\t\t\torigin_phys = origin_bonus->db_data;\n\t\t\tdd->dd_origin_txg =\n\t\t\t    origin_phys->ds_creation_txg;\n\t\t\tdmu_buf_rele(origin_bonus, FTAG);\n\t\t\tif (dsl_dir_is_zapified(dd)) {\n\t\t\t\tuint64_t obj;\n\t\t\t\terr = zap_lookup(dp->dp_meta_objset,\n\t\t\t\t    dd->dd_object, DD_FIELD_LIVELIST,\n\t\t\t\t    sizeof (uint64_t), 1, &obj);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tdsl_dir_livelist_open(dd, obj);\n\t\t\t\telse if (err != ENOENT)\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (dsl_dir_is_zapified(dd)) {\n\t\t\tinode_timespec_t t = {0};\n\t\t\t(void) zap_lookup(dp->dp_meta_objset, ddobj,\n\t\t\t    DD_FIELD_SNAPSHOTS_CHANGED,\n\t\t\t    sizeof (uint64_t),\n\t\t\t    sizeof (inode_timespec_t) / sizeof (uint64_t),\n\t\t\t    &t);\n\t\t\tdd->dd_snap_cmtime = t;\n\t\t}\n\n\t\tdmu_buf_init_user(&dd->dd_dbu, NULL, dsl_dir_evict_async,\n\t\t    &dd->dd_dbuf);\n\t\twinner = dmu_buf_set_user_ie(dbuf, &dd->dd_dbu);\n\t\tif (winner != NULL) {\n\t\t\tif (dd->dd_parent)\n\t\t\t\tdsl_dir_rele(dd->dd_parent, dd);\n\t\t\tif (dsl_deadlist_is_open(&dd->dd_livelist))\n\t\t\t\tdsl_dir_livelist_close(dd);\n\t\t\tdsl_prop_fini(dd);\n\t\t\tcv_destroy(&dd->dd_activity_cv);\n\t\t\tmutex_destroy(&dd->dd_activity_lock);\n\t\t\tmutex_destroy(&dd->dd_lock);\n\t\t\tkmem_free(dd, sizeof (dsl_dir_t));\n\t\t\tdd = winner;\n\t\t} else {\n\t\t\tspa_open_ref(dp->dp_spa, dd);\n\t\t}\n\t}\n\n\t \n\tspa_open_ref(dp->dp_spa, tag);\n\tASSERT3P(dd->dd_pool, ==, dp);\n\tASSERT3U(dd->dd_object, ==, ddobj);\n\tASSERT3P(dd->dd_dbuf, ==, dbuf);\n\t*ddp = dd;\n\treturn (0);\n\nerrout:\n\tif (dd->dd_parent)\n\t\tdsl_dir_rele(dd->dd_parent, dd);\n\tif (dsl_deadlist_is_open(&dd->dd_livelist))\n\t\tdsl_dir_livelist_close(dd);\n\tdsl_prop_fini(dd);\n\tcv_destroy(&dd->dd_activity_cv);\n\tmutex_destroy(&dd->dd_activity_lock);\n\tmutex_destroy(&dd->dd_lock);\n\tkmem_free(dd, sizeof (dsl_dir_t));\n\tdmu_buf_rele(dbuf, tag);\n\treturn (err);\n}\n\nvoid\ndsl_dir_rele(dsl_dir_t *dd, const void *tag)\n{\n\tdprintf_dd(dd, \"%s\\n\", \"\");\n\tspa_close(dd->dd_pool->dp_spa, tag);\n\tdmu_buf_rele(dd->dd_dbuf, tag);\n}\n\n \nvoid\ndsl_dir_async_rele(dsl_dir_t *dd, const void *tag)\n{\n\tdprintf_dd(dd, \"%s\\n\", \"\");\n\tspa_async_close(dd->dd_pool->dp_spa, tag);\n\tdmu_buf_rele(dd->dd_dbuf, tag);\n}\n\n \nvoid\ndsl_dir_name(dsl_dir_t *dd, char *buf)\n{\n\tif (dd->dd_parent) {\n\t\tdsl_dir_name(dd->dd_parent, buf);\n\t\tVERIFY3U(strlcat(buf, \"/\", ZFS_MAX_DATASET_NAME_LEN), <,\n\t\t    ZFS_MAX_DATASET_NAME_LEN);\n\t} else {\n\t\tbuf[0] = '\\0';\n\t}\n\tif (!MUTEX_HELD(&dd->dd_lock)) {\n\t\t \n\t\tmutex_enter(&dd->dd_lock);\n\t\tVERIFY3U(strlcat(buf, dd->dd_myname, ZFS_MAX_DATASET_NAME_LEN),\n\t\t    <, ZFS_MAX_DATASET_NAME_LEN);\n\t\tmutex_exit(&dd->dd_lock);\n\t} else {\n\t\tVERIFY3U(strlcat(buf, dd->dd_myname, ZFS_MAX_DATASET_NAME_LEN),\n\t\t    <, ZFS_MAX_DATASET_NAME_LEN);\n\t}\n}\n\n \nint\ndsl_dir_namelen(dsl_dir_t *dd)\n{\n\tint result = 0;\n\n\tif (dd->dd_parent) {\n\t\t \n\t\tresult = dsl_dir_namelen(dd->dd_parent) + 1;\n\t}\n\n\tif (!MUTEX_HELD(&dd->dd_lock)) {\n\t\t \n\t\tmutex_enter(&dd->dd_lock);\n\t\tresult += strlen(dd->dd_myname);\n\t\tmutex_exit(&dd->dd_lock);\n\t} else {\n\t\tresult += strlen(dd->dd_myname);\n\t}\n\n\treturn (result);\n}\n\nstatic int\ngetcomponent(const char *path, char *component, const char **nextp)\n{\n\tchar *p;\n\n\tif ((path == NULL) || (path[0] == '\\0'))\n\t\treturn (SET_ERROR(ENOENT));\n\t \n\tp = strpbrk(path, \"/@\");\n\tif (p && (p[1] == '/' || p[1] == '@')) {\n\t\t \n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tif (p == NULL || p == path) {\n\t\t \n\t\tif (p != NULL &&\n\t\t    (p[0] != '@' || strpbrk(path+1, \"/@\") || p[1] == '\\0'))\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\tif (strlen(path) >= ZFS_MAX_DATASET_NAME_LEN)\n\t\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t\t(void) strlcpy(component, path, ZFS_MAX_DATASET_NAME_LEN);\n\t\tp = NULL;\n\t} else if (p[0] == '/') {\n\t\tif (p - path >= ZFS_MAX_DATASET_NAME_LEN)\n\t\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t\t(void) strlcpy(component, path, p - path + 1);\n\t\tp++;\n\t} else if (p[0] == '@') {\n\t\t \n\t\tif (strchr(path, '/'))\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\tif (p - path >= ZFS_MAX_DATASET_NAME_LEN)\n\t\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t\t(void) strlcpy(component, path, p - path + 1);\n\t} else {\n\t\tpanic(\"invalid p=%p\", (void *)p);\n\t}\n\t*nextp = p;\n\treturn (0);\n}\n\n \nint\ndsl_dir_hold(dsl_pool_t *dp, const char *name, const void *tag,\n    dsl_dir_t **ddp, const char **tailp)\n{\n\tchar *buf;\n\tconst char *spaname, *next, *nextnext = NULL;\n\tint err;\n\tdsl_dir_t *dd;\n\tuint64_t ddobj;\n\n\tbuf = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\terr = getcomponent(name, buf, &next);\n\tif (err != 0)\n\t\tgoto error;\n\n\t \n\tspaname = spa_name(dp->dp_spa);\n\tif (strcmp(buf, spaname) != 0) {\n\t\terr = SET_ERROR(EXDEV);\n\t\tgoto error;\n\t}\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\terr = dsl_dir_hold_obj(dp, dp->dp_root_dir_obj, NULL, tag, &dd);\n\tif (err != 0) {\n\t\tgoto error;\n\t}\n\n\twhile (next != NULL) {\n\t\tdsl_dir_t *child_dd;\n\t\terr = getcomponent(next, buf, &nextnext);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t\tASSERT(next[0] != '\\0');\n\t\tif (next[0] == '@')\n\t\t\tbreak;\n\t\tdprintf(\"looking up %s in obj%lld\\n\",\n\t\t    buf, (longlong_t)dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\n\t\terr = zap_lookup(dp->dp_meta_objset,\n\t\t    dsl_dir_phys(dd)->dd_child_dir_zapobj,\n\t\t    buf, sizeof (ddobj), 1, &ddobj);\n\t\tif (err != 0) {\n\t\t\tif (err == ENOENT)\n\t\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = dsl_dir_hold_obj(dp, ddobj, buf, tag, &child_dd);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t\tdsl_dir_rele(dd, tag);\n\t\tdd = child_dd;\n\t\tnext = nextnext;\n\t}\n\n\tif (err != 0) {\n\t\tdsl_dir_rele(dd, tag);\n\t\tgoto error;\n\t}\n\n\t \n\tif (next != NULL &&\n\t    (tailp == NULL || (nextnext && nextnext[0] != '\\0'))) {\n\t\t \n\t\tdsl_dir_rele(dd, tag);\n\t\tdprintf(\"next=%p (%s) tail=%p\\n\", next, next?next:\"\", tailp);\n\t\terr = SET_ERROR(ENOENT);\n\t}\n\tif (tailp != NULL)\n\t\t*tailp = next;\n\tif (err == 0)\n\t\t*ddp = dd;\nerror:\n\tkmem_free(buf, ZFS_MAX_DATASET_NAME_LEN);\n\treturn (err);\n}\n\n \nstatic void\ndsl_dir_init_fs_ss_count(dsl_dir_t *dd, dmu_tx_t *tx)\n{\n\tuint64_t my_fs_cnt = 0;\n\tuint64_t my_ss_cnt = 0;\n\tdsl_pool_t *dp = dd->dd_pool;\n\tobjset_t *os = dp->dp_meta_objset;\n\tzap_cursor_t *zc;\n\tzap_attribute_t *za;\n\tdsl_dataset_t *ds;\n\n\tASSERT(spa_feature_is_active(dp->dp_spa, SPA_FEATURE_FS_SS_LIMIT));\n\tASSERT(dsl_pool_config_held(dp));\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tdsl_dir_zapify(dd, tx);\n\n\t \n\tif (zap_contains(os, dd->dd_object, DD_FIELD_FILESYSTEM_COUNT) == 0)\n\t\treturn;\n\n\tzc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\t \n\tfor (zap_cursor_init(zc, os, dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\t    zap_cursor_retrieve(zc, za) == 0; zap_cursor_advance(zc)) {\n\t\tdsl_dir_t *chld_dd;\n\t\tuint64_t count;\n\n\t\tVERIFY0(dsl_dir_hold_obj(dp, za->za_first_integer, NULL, FTAG,\n\t\t    &chld_dd));\n\n\t\t \n\t\tif (chld_dd->dd_myname[0] == '$') {\n\t\t\tdsl_dir_rele(chld_dd, FTAG);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmy_fs_cnt++;\t \n\n\t\tdsl_dir_init_fs_ss_count(chld_dd, tx);\n\n\t\tVERIFY0(zap_lookup(os, chld_dd->dd_object,\n\t\t    DD_FIELD_FILESYSTEM_COUNT, sizeof (count), 1, &count));\n\t\tmy_fs_cnt += count;\n\t\tVERIFY0(zap_lookup(os, chld_dd->dd_object,\n\t\t    DD_FIELD_SNAPSHOT_COUNT, sizeof (count), 1, &count));\n\t\tmy_ss_cnt += count;\n\n\t\tdsl_dir_rele(chld_dd, FTAG);\n\t}\n\tzap_cursor_fini(zc);\n\t \n\tVERIFY0(dsl_dataset_hold_obj(dd->dd_pool,\n\t    dsl_dir_phys(dd)->dd_head_dataset_obj, FTAG, &ds));\n\n\tfor (zap_cursor_init(zc, os, dsl_dataset_phys(ds)->ds_snapnames_zapobj);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\t\t \n\t\tif (za->za_name[0] != '%')\n\t\t\tmy_ss_cnt++;\n\t}\n\tzap_cursor_fini(zc);\n\n\tdsl_dataset_rele(ds, FTAG);\n\n\tkmem_free(zc, sizeof (zap_cursor_t));\n\tkmem_free(za, sizeof (zap_attribute_t));\n\n\t \n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\tVERIFY0(zap_add(os, dd->dd_object, DD_FIELD_FILESYSTEM_COUNT,\n\t    sizeof (my_fs_cnt), 1, &my_fs_cnt, tx));\n\tVERIFY0(zap_add(os, dd->dd_object, DD_FIELD_SNAPSHOT_COUNT,\n\t    sizeof (my_ss_cnt), 1, &my_ss_cnt, tx));\n}\n\nstatic int\ndsl_dir_actv_fs_ss_limit_check(void *arg, dmu_tx_t *tx)\n{\n\tchar *ddname = (char *)arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tdsl_dir_t *dd;\n\tint error;\n\n\terror = dsl_dataset_hold(dp, ddname, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_FS_SS_LIMIT)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\tdd = ds->ds_dir;\n\tif (spa_feature_is_active(dp->dp_spa, SPA_FEATURE_FS_SS_LIMIT) &&\n\t    dsl_dir_is_zapified(dd) &&\n\t    zap_contains(dp->dp_meta_objset, dd->dd_object,\n\t    DD_FIELD_FILESYSTEM_COUNT) == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EALREADY));\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nstatic void\ndsl_dir_actv_fs_ss_limit_sync(void *arg, dmu_tx_t *tx)\n{\n\tchar *ddname = (char *)arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tspa_t *spa;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddname, FTAG, &ds));\n\n\tspa = dsl_dataset_get_spa(ds);\n\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_FS_SS_LIMIT)) {\n\t\t \n\t\tspa_feature_incr(spa, SPA_FEATURE_FS_SS_LIMIT, tx);\n\t}\n\n\t \n\tdsl_dir_init_fs_ss_count(ds->ds_dir, tx);\n\n\tdsl_dataset_rele(ds, FTAG);\n}\n\n \nint\ndsl_dir_activate_fs_ss_limit(const char *ddname)\n{\n\tint error;\n\n\terror = dsl_sync_task(ddname, dsl_dir_actv_fs_ss_limit_check,\n\t    dsl_dir_actv_fs_ss_limit_sync, (void *)ddname, 0,\n\t    ZFS_SPACE_CHECK_RESERVED);\n\n\tif (error == EALREADY)\n\t\terror = 0;\n\n\treturn (error);\n}\n\n \n\ntypedef enum {\n\tENFORCE_ALWAYS,\n\tENFORCE_NEVER,\n\tENFORCE_ABOVE\n} enforce_res_t;\n\nstatic enforce_res_t\ndsl_enforce_ds_ss_limits(dsl_dir_t *dd, zfs_prop_t prop,\n    cred_t *cr, proc_t *proc)\n{\n\tenforce_res_t enforce = ENFORCE_ALWAYS;\n\tuint64_t obj;\n\tdsl_dataset_t *ds;\n\tuint64_t zoned;\n\tconst char *zonedstr;\n\n\tASSERT(prop == ZFS_PROP_FILESYSTEM_LIMIT ||\n\t    prop == ZFS_PROP_SNAPSHOT_LIMIT);\n\n#ifdef _KERNEL\n\tif (crgetzoneid(cr) != GLOBAL_ZONEID)\n\t\treturn (ENFORCE_ALWAYS);\n\n\t \n\tif (secpolicy_zfs_proc(cr, proc) == 0)\n\t\treturn (ENFORCE_NEVER);\n#else\n\t(void) proc;\n#endif\n\n\tif ((obj = dsl_dir_phys(dd)->dd_head_dataset_obj) == 0)\n\t\treturn (ENFORCE_ALWAYS);\n\n\tASSERT(dsl_pool_config_held(dd->dd_pool));\n\n\tif (dsl_dataset_hold_obj(dd->dd_pool, obj, FTAG, &ds) != 0)\n\t\treturn (ENFORCE_ALWAYS);\n\n\tzonedstr = zfs_prop_to_name(ZFS_PROP_ZONED);\n\tif (dsl_prop_get_ds(ds, zonedstr, 8, 1, &zoned, NULL) || zoned) {\n\t\t \n\t\tenforce = ENFORCE_ALWAYS;\n\t} else {\n\t\tif (dsl_deleg_access_impl(ds, zfs_prop_to_name(prop), cr) == 0)\n\t\t\tenforce = ENFORCE_ABOVE;\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (enforce);\n}\n\n \nint\ndsl_fs_ss_limit_check(dsl_dir_t *dd, uint64_t delta, zfs_prop_t prop,\n    dsl_dir_t *ancestor, cred_t *cr, proc_t *proc)\n{\n\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\tuint64_t limit, count;\n\tconst char *count_prop;\n\tenforce_res_t enforce;\n\tint err = 0;\n\n\tASSERT(dsl_pool_config_held(dd->dd_pool));\n\tASSERT(prop == ZFS_PROP_FILESYSTEM_LIMIT ||\n\t    prop == ZFS_PROP_SNAPSHOT_LIMIT);\n\n\tif (prop == ZFS_PROP_SNAPSHOT_LIMIT) {\n\t\t \n\t\tif (cr == NULL)\n\t\t\treturn (0);\n\n\t\tcount_prop = DD_FIELD_SNAPSHOT_COUNT;\n\t} else {\n\t\tcount_prop = DD_FIELD_FILESYSTEM_COUNT;\n\t}\n\t \n\tenforce = dsl_enforce_ds_ss_limits(dd, prop, cr, proc);\n\tif (enforce == ENFORCE_NEVER)\n\t\treturn (0);\n\n\t \n\tif (delta == 0)\n\t\treturn (0);\n\n\t \n\tif (ancestor == dd)\n\t\treturn (0);\n\n\t \n\tif (!dsl_dir_is_zapified(dd))\n\t\treturn (0);\n\terr = zap_lookup(os, dd->dd_object,\n\t    count_prop, sizeof (count), 1, &count);\n\tif (err == ENOENT)\n\t\treturn (0);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = dsl_prop_get_dd(dd, zfs_prop_to_name(prop), 8, 1, &limit, NULL,\n\t    B_FALSE);\n\tif (err != 0)\n\t\treturn (err);\n\n\t \n\tif (enforce == ENFORCE_ALWAYS && (count + delta) > limit)\n\t\treturn (SET_ERROR(EDQUOT));\n\n\tif (dd->dd_parent != NULL)\n\t\terr = dsl_fs_ss_limit_check(dd->dd_parent, delta, prop,\n\t\t    ancestor, cr, proc);\n\n\treturn (err);\n}\n\n \nvoid\ndsl_fs_ss_count_adjust(dsl_dir_t *dd, int64_t delta, const char *prop,\n    dmu_tx_t *tx)\n{\n\tint err;\n\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\tuint64_t count;\n\n\tASSERT(dsl_pool_config_held(dd->dd_pool));\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(strcmp(prop, DD_FIELD_FILESYSTEM_COUNT) == 0 ||\n\t    strcmp(prop, DD_FIELD_SNAPSHOT_COUNT) == 0);\n\n\t \n\tif (dd->dd_myname[0] == '$' && strcmp(prop,\n\t    DD_FIELD_FILESYSTEM_COUNT) == 0) {\n\t\treturn;\n\t}\n\n\t \n\tif (delta == 0)\n\t\treturn;\n\n\t \n\tif (!dsl_dir_is_zapified(dd) || (err = zap_lookup(os, dd->dd_object,\n\t    prop, sizeof (count), 1, &count)) == ENOENT)\n\t\treturn;\n\tVERIFY0(err);\n\n\tcount += delta;\n\t \n\tVERIFY3S(count, >=, 0);\n\n\tVERIFY0(zap_update(os, dd->dd_object, prop, sizeof (count), 1, &count,\n\t    tx));\n\n\t \n\tif (dd->dd_parent != NULL)\n\t\tdsl_fs_ss_count_adjust(dd->dd_parent, delta, prop, tx);\n}\n\nuint64_t\ndsl_dir_create_sync(dsl_pool_t *dp, dsl_dir_t *pds, const char *name,\n    dmu_tx_t *tx)\n{\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t ddobj;\n\tdsl_dir_phys_t *ddphys;\n\tdmu_buf_t *dbuf;\n\n\tddobj = dmu_object_alloc(mos, DMU_OT_DSL_DIR, 0,\n\t    DMU_OT_DSL_DIR, sizeof (dsl_dir_phys_t), tx);\n\tif (pds) {\n\t\tVERIFY0(zap_add(mos, dsl_dir_phys(pds)->dd_child_dir_zapobj,\n\t\t    name, sizeof (uint64_t), 1, &ddobj, tx));\n\t} else {\n\t\t \n\t\tVERIFY0(zap_add(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_ROOT_DATASET, sizeof (uint64_t), 1, &ddobj, tx));\n\t}\n\tVERIFY0(dmu_bonus_hold(mos, ddobj, FTAG, &dbuf));\n\tdmu_buf_will_dirty(dbuf, tx);\n\tddphys = dbuf->db_data;\n\n\tddphys->dd_creation_time = gethrestime_sec();\n\tif (pds) {\n\t\tddphys->dd_parent_obj = pds->dd_object;\n\n\t\t \n\t\tdsl_fs_ss_count_adjust(pds, 1, DD_FIELD_FILESYSTEM_COUNT, tx);\n\t}\n\tddphys->dd_props_zapobj = zap_create(mos,\n\t    DMU_OT_DSL_PROPS, DMU_OT_NONE, 0, tx);\n\tddphys->dd_child_dir_zapobj = zap_create(mos,\n\t    DMU_OT_DSL_DIR_CHILD_MAP, DMU_OT_NONE, 0, tx);\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_USED_BREAKDOWN)\n\t\tddphys->dd_flags |= DD_FLAG_USED_BREAKDOWN;\n\n\tdmu_buf_rele(dbuf, FTAG);\n\n\treturn (ddobj);\n}\n\nboolean_t\ndsl_dir_is_clone(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_origin_obj &&\n\t    (dd->dd_pool->dp_origin_snap == NULL ||\n\t    dsl_dir_phys(dd)->dd_origin_obj !=\n\t    dd->dd_pool->dp_origin_snap->ds_object));\n}\n\nuint64_t\ndsl_dir_get_used(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_used_bytes);\n}\n\nuint64_t\ndsl_dir_get_compressed(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_compressed_bytes);\n}\n\nuint64_t\ndsl_dir_get_quota(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_quota);\n}\n\nuint64_t\ndsl_dir_get_reservation(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_reserved);\n}\n\nuint64_t\ndsl_dir_get_compressratio(dsl_dir_t *dd)\n{\n\t \n\treturn (dsl_dir_phys(dd)->dd_compressed_bytes == 0 ? 100 :\n\t    (dsl_dir_phys(dd)->dd_uncompressed_bytes * 100 /\n\t    dsl_dir_phys(dd)->dd_compressed_bytes));\n}\n\nuint64_t\ndsl_dir_get_logicalused(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_uncompressed_bytes);\n}\n\nuint64_t\ndsl_dir_get_usedsnap(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_used_breakdown[DD_USED_SNAP]);\n}\n\nuint64_t\ndsl_dir_get_usedds(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_used_breakdown[DD_USED_HEAD]);\n}\n\nuint64_t\ndsl_dir_get_usedrefreserv(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_used_breakdown[DD_USED_REFRSRV]);\n}\n\nuint64_t\ndsl_dir_get_usedchild(dsl_dir_t *dd)\n{\n\treturn (dsl_dir_phys(dd)->dd_used_breakdown[DD_USED_CHILD] +\n\t    dsl_dir_phys(dd)->dd_used_breakdown[DD_USED_CHILD_RSRV]);\n}\n\nvoid\ndsl_dir_get_origin(dsl_dir_t *dd, char *buf)\n{\n\tdsl_dataset_t *ds;\n\tVERIFY0(dsl_dataset_hold_obj(dd->dd_pool,\n\t    dsl_dir_phys(dd)->dd_origin_obj, FTAG, &ds));\n\n\tdsl_dataset_name(ds, buf);\n\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dir_get_filesystem_count(dsl_dir_t *dd, uint64_t *count)\n{\n\tif (dsl_dir_is_zapified(dd)) {\n\t\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\t\treturn (zap_lookup(os, dd->dd_object, DD_FIELD_FILESYSTEM_COUNT,\n\t\t    sizeof (*count), 1, count));\n\t} else {\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n}\n\nint\ndsl_dir_get_snapshot_count(dsl_dir_t *dd, uint64_t *count)\n{\n\tif (dsl_dir_is_zapified(dd)) {\n\t\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\t\treturn (zap_lookup(os, dd->dd_object, DD_FIELD_SNAPSHOT_COUNT,\n\t\t    sizeof (*count), 1, count));\n\t} else {\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n}\n\nvoid\ndsl_dir_stats(dsl_dir_t *dd, nvlist_t *nv)\n{\n\tmutex_enter(&dd->dd_lock);\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_QUOTA,\n\t    dsl_dir_get_quota(dd));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_RESERVATION,\n\t    dsl_dir_get_reservation(dd));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_LOGICALUSED,\n\t    dsl_dir_get_logicalused(dd));\n\tif (dsl_dir_phys(dd)->dd_flags & DD_FLAG_USED_BREAKDOWN) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USEDSNAP,\n\t\t    dsl_dir_get_usedsnap(dd));\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USEDDS,\n\t\t    dsl_dir_get_usedds(dd));\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USEDREFRESERV,\n\t\t    dsl_dir_get_usedrefreserv(dd));\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USEDCHILD,\n\t\t    dsl_dir_get_usedchild(dd));\n\t}\n\tmutex_exit(&dd->dd_lock);\n\n\tuint64_t count;\n\tif (dsl_dir_get_filesystem_count(dd, &count) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_FILESYSTEM_COUNT,\n\t\t    count);\n\t}\n\tif (dsl_dir_get_snapshot_count(dd, &count) == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_SNAPSHOT_COUNT,\n\t\t    count);\n\t}\n\n\tif (dsl_dir_is_clone(dd)) {\n\t\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\t\tdsl_dir_get_origin(dd, buf);\n\t\tdsl_prop_nvlist_add_string(nv, ZFS_PROP_ORIGIN, buf);\n\t}\n\n}\n\nvoid\ndsl_dir_dirty(dsl_dir_t *dd, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dd->dd_pool;\n\n\tASSERT(dsl_dir_phys(dd));\n\n\tif (txg_list_add(&dp->dp_dirty_dirs, dd, tx->tx_txg)) {\n\t\t \n\t\tdmu_buf_add_ref(dd->dd_dbuf, dd);\n\t}\n}\n\nstatic int64_t\nparent_delta(dsl_dir_t *dd, uint64_t used, int64_t delta)\n{\n\tuint64_t old_accounted = MAX(used, dsl_dir_phys(dd)->dd_reserved);\n\tuint64_t new_accounted =\n\t    MAX(used + delta, dsl_dir_phys(dd)->dd_reserved);\n\treturn (new_accounted - old_accounted);\n}\n\nvoid\ndsl_dir_sync(dsl_dir_t *dd, dmu_tx_t *tx)\n{\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tmutex_enter(&dd->dd_lock);\n\tASSERT0(dd->dd_tempreserved[tx->tx_txg & TXG_MASK]);\n\tdprintf_dd(dd, \"txg=%llu towrite=%lluK\\n\", (u_longlong_t)tx->tx_txg,\n\t    (u_longlong_t)dd->dd_space_towrite[tx->tx_txg & TXG_MASK] / 1024);\n\tdd->dd_space_towrite[tx->tx_txg & TXG_MASK] = 0;\n\tmutex_exit(&dd->dd_lock);\n\n\t \n\tdmu_buf_rele(dd->dd_dbuf, dd);\n}\n\nstatic uint64_t\ndsl_dir_space_towrite(dsl_dir_t *dd)\n{\n\tuint64_t space = 0;\n\n\tASSERT(MUTEX_HELD(&dd->dd_lock));\n\n\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\tspace += dd->dd_space_towrite[i & TXG_MASK];\n\n\treturn (space);\n}\n\n \nuint64_t\ndsl_dir_space_available(dsl_dir_t *dd,\n    dsl_dir_t *ancestor, int64_t delta, int ondiskonly)\n{\n\tuint64_t parentspace, myspace, quota, used;\n\n\t \n\tquota = UINT64_MAX;\n\tparentspace = UINT64_MAX;\n\n\tif (dd->dd_parent != NULL) {\n\t\tparentspace = dsl_dir_space_available(dd->dd_parent,\n\t\t    ancestor, delta, ondiskonly);\n\t}\n\n\tmutex_enter(&dd->dd_lock);\n\tif (dsl_dir_phys(dd)->dd_quota != 0)\n\t\tquota = dsl_dir_phys(dd)->dd_quota;\n\tused = dsl_dir_phys(dd)->dd_used_bytes;\n\tif (!ondiskonly)\n\t\tused += dsl_dir_space_towrite(dd);\n\n\tif (dd->dd_parent == NULL) {\n\t\tuint64_t poolsize = dsl_pool_adjustedsize(dd->dd_pool,\n\t\t    ZFS_SPACE_CHECK_NORMAL);\n\t\tquota = MIN(quota, poolsize);\n\t}\n\n\tif (dsl_dir_phys(dd)->dd_reserved > used && parentspace != UINT64_MAX) {\n\t\t \n\t\tparentspace += dsl_dir_phys(dd)->dd_reserved - used;\n\t}\n\n\tif (dd == ancestor) {\n\t\tASSERT(delta <= 0);\n\t\tASSERT(used >= -delta);\n\t\tused += delta;\n\t\tif (parentspace != UINT64_MAX)\n\t\t\tparentspace -= delta;\n\t}\n\n\tif (used > quota) {\n\t\t \n\t\tmyspace = 0;\n\t} else {\n\t\t \n\t\tmyspace = MIN(parentspace, quota - used);\n\t}\n\n\tmutex_exit(&dd->dd_lock);\n\n\treturn (myspace);\n}\n\nstruct tempreserve {\n\tlist_node_t tr_node;\n\tdsl_dir_t *tr_ds;\n\tuint64_t tr_size;\n};\n\nstatic int\ndsl_dir_tempreserve_impl(dsl_dir_t *dd, uint64_t asize, boolean_t netfree,\n    boolean_t ignorequota, list_t *tr_list,\n    dmu_tx_t *tx, boolean_t first)\n{\n\tuint64_t txg;\n\tuint64_t quota;\n\tstruct tempreserve *tr;\n\tint retval;\n\tuint64_t ext_quota;\n\tuint64_t ref_rsrv;\n\ntop_of_function:\n\ttxg = tx->tx_txg;\n\tretval = EDQUOT;\n\tref_rsrv = 0;\n\n\tASSERT3U(txg, !=, 0);\n\tASSERT3S(asize, >, 0);\n\n\tmutex_enter(&dd->dd_lock);\n\n\t \n\tuint64_t est_inflight = dsl_dir_space_towrite(dd);\n\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\test_inflight += dd->dd_tempreserved[i];\n\tuint64_t used_on_disk = dsl_dir_phys(dd)->dd_used_bytes;\n\n\t \n\tif (first && tx->tx_objset) {\n\t\tint error;\n\t\tdsl_dataset_t *ds = tx->tx_objset->os_dsl_dataset;\n\n\t\terror = dsl_dataset_check_quota(ds, !netfree,\n\t\t    asize, est_inflight, &used_on_disk, &ref_rsrv);\n\t\tif (error != 0) {\n\t\t\tmutex_exit(&dd->dd_lock);\n\t\t\tDMU_TX_STAT_BUMP(dmu_tx_quota);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t \n\tif (ignorequota || netfree || dsl_dir_phys(dd)->dd_quota == 0 ||\n\t    (tx->tx_objset && dmu_objset_type(tx->tx_objset) == DMU_OST_ZVOL &&\n\t    zvol_enforce_quotas == B_FALSE))\n\t\tquota = UINT64_MAX;\n\telse\n\t\tquota = dsl_dir_phys(dd)->dd_quota;\n\n\t \n\tif (dd->dd_parent == NULL) {\n\t\tuint64_t avail = dsl_pool_unreserved_space(dd->dd_pool,\n\t\t    (netfree) ?\n\t\t    ZFS_SPACE_CHECK_RESERVED : ZFS_SPACE_CHECK_NORMAL);\n\n\t\tif (avail < quota) {\n\t\t\tquota = avail;\n\t\t\tretval = SET_ERROR(ENOSPC);\n\t\t}\n\t}\n\n\t \n\text_quota = quota >> 5;\n\tif (quota == UINT64_MAX)\n\t\text_quota = 0;\n\n\tif (used_on_disk >= quota) {\n\t\tif (retval == ENOSPC && (used_on_disk - quota) <\n\t\t    dsl_pool_deferred_space(dd->dd_pool)) {\n\t\t\tretval = SET_ERROR(ERESTART);\n\t\t}\n\t\t \n\t\tmutex_exit(&dd->dd_lock);\n\t\tDMU_TX_STAT_BUMP(dmu_tx_quota);\n\t\treturn (retval);\n\t} else if (used_on_disk + est_inflight >= quota + ext_quota) {\n\t\tdprintf_dd(dd, \"failing: used=%lluK inflight = %lluK \"\n\t\t    \"quota=%lluK tr=%lluK\\n\",\n\t\t    (u_longlong_t)used_on_disk>>10,\n\t\t    (u_longlong_t)est_inflight>>10,\n\t\t    (u_longlong_t)quota>>10, (u_longlong_t)asize>>10);\n\t\tmutex_exit(&dd->dd_lock);\n\t\tDMU_TX_STAT_BUMP(dmu_tx_quota);\n\t\treturn (SET_ERROR(ERESTART));\n\t}\n\n\t \n\tdd->dd_tempreserved[txg & TXG_MASK] += asize;\n\n\tuint64_t parent_rsrv = parent_delta(dd, used_on_disk + est_inflight,\n\t    asize - ref_rsrv);\n\tmutex_exit(&dd->dd_lock);\n\n\ttr = kmem_zalloc(sizeof (struct tempreserve), KM_SLEEP);\n\ttr->tr_ds = dd;\n\ttr->tr_size = asize;\n\tlist_insert_tail(tr_list, tr);\n\n\t \n\tif (dd->dd_parent != NULL && parent_rsrv != 0) {\n\t\t \n\n\t\tdd = dd->dd_parent;\n\t\tasize = parent_rsrv;\n\t\tignorequota = (dsl_dir_phys(dd)->dd_head_dataset_obj == 0);\n\t\tfirst = B_FALSE;\n\t\tgoto top_of_function;\n\t}\n\n\treturn (0);\n}\n\n \nint\ndsl_dir_tempreserve_space(dsl_dir_t *dd, uint64_t lsize, uint64_t asize,\n    boolean_t netfree, void **tr_cookiep, dmu_tx_t *tx)\n{\n\tint err;\n\tlist_t *tr_list;\n\n\tif (asize == 0) {\n\t\t*tr_cookiep = NULL;\n\t\treturn (0);\n\t}\n\n\ttr_list = kmem_alloc(sizeof (list_t), KM_SLEEP);\n\tlist_create(tr_list, sizeof (struct tempreserve),\n\t    offsetof(struct tempreserve, tr_node));\n\tASSERT3S(asize, >, 0);\n\n\terr = arc_tempreserve_space(dd->dd_pool->dp_spa, lsize, tx->tx_txg);\n\tif (err == 0) {\n\t\tstruct tempreserve *tr;\n\n\t\ttr = kmem_zalloc(sizeof (struct tempreserve), KM_SLEEP);\n\t\ttr->tr_size = lsize;\n\t\tlist_insert_tail(tr_list, tr);\n\t} else {\n\t\tif (err == EAGAIN) {\n\t\t\t \n\t\t\ttxg_delay(dd->dd_pool, tx->tx_txg,\n\t\t\t    MSEC2NSEC(10), MSEC2NSEC(10));\n\t\t\terr = SET_ERROR(ERESTART);\n\t\t}\n\t}\n\n\tif (err == 0) {\n\t\terr = dsl_dir_tempreserve_impl(dd, asize, netfree,\n\t\t    B_FALSE, tr_list, tx, B_TRUE);\n\t}\n\n\tif (err != 0)\n\t\tdsl_dir_tempreserve_clear(tr_list, tx);\n\telse\n\t\t*tr_cookiep = tr_list;\n\n\treturn (err);\n}\n\n \nvoid\ndsl_dir_tempreserve_clear(void *tr_cookie, dmu_tx_t *tx)\n{\n\tint txgidx = tx->tx_txg & TXG_MASK;\n\tlist_t *tr_list = tr_cookie;\n\tstruct tempreserve *tr;\n\n\tASSERT3U(tx->tx_txg, !=, 0);\n\n\tif (tr_cookie == NULL)\n\t\treturn;\n\n\twhile ((tr = list_remove_head(tr_list)) != NULL) {\n\t\tif (tr->tr_ds) {\n\t\t\tmutex_enter(&tr->tr_ds->dd_lock);\n\t\t\tASSERT3U(tr->tr_ds->dd_tempreserved[txgidx], >=,\n\t\t\t    tr->tr_size);\n\t\t\ttr->tr_ds->dd_tempreserved[txgidx] -= tr->tr_size;\n\t\t\tmutex_exit(&tr->tr_ds->dd_lock);\n\t\t} else {\n\t\t\tarc_tempreserve_clear(tr->tr_size);\n\t\t}\n\t\tkmem_free(tr, sizeof (struct tempreserve));\n\t}\n\n\tkmem_free(tr_list, sizeof (list_t));\n}\n\n \nvoid\ndsl_dir_willuse_space(dsl_dir_t *dd, int64_t space, dmu_tx_t *tx)\n{\n\tint64_t parent_space;\n\tuint64_t est_used;\n\n\tdo {\n\t\tmutex_enter(&dd->dd_lock);\n\t\tif (space > 0)\n\t\t\tdd->dd_space_towrite[tx->tx_txg & TXG_MASK] += space;\n\n\t\test_used = dsl_dir_space_towrite(dd) +\n\t\t    dsl_dir_phys(dd)->dd_used_bytes;\n\t\tparent_space = parent_delta(dd, est_used, space);\n\t\tmutex_exit(&dd->dd_lock);\n\n\t\t \n\t\tdsl_dir_dirty(dd, tx);\n\n\t\tdd = dd->dd_parent;\n\t\tspace = parent_space;\n\t} while (space && dd);\n}\n\n \nvoid\ndsl_dir_diduse_space(dsl_dir_t *dd, dd_used_t type,\n    int64_t used, int64_t compressed, int64_t uncompressed, dmu_tx_t *tx)\n{\n\tint64_t accounted_delta;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(type < DD_USED_NUM);\n\n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\n\t \n\tboolean_t needlock = !MUTEX_HELD(&dd->dd_lock);\n\tif (needlock)\n\t\tmutex_enter(&dd->dd_lock);\n\tdsl_dir_phys_t *ddp = dsl_dir_phys(dd);\n\taccounted_delta = parent_delta(dd, ddp->dd_used_bytes, used);\n\tASSERT(used >= 0 || ddp->dd_used_bytes >= -used);\n\tASSERT(compressed >= 0 || ddp->dd_compressed_bytes >= -compressed);\n\tASSERT(uncompressed >= 0 ||\n\t    ddp->dd_uncompressed_bytes >= -uncompressed);\n\tddp->dd_used_bytes += used;\n\tddp->dd_uncompressed_bytes += uncompressed;\n\tddp->dd_compressed_bytes += compressed;\n\n\tif (ddp->dd_flags & DD_FLAG_USED_BREAKDOWN) {\n\t\tASSERT(used >= 0 || ddp->dd_used_breakdown[type] >= -used);\n\t\tddp->dd_used_breakdown[type] += used;\n#ifdef ZFS_DEBUG\n\t\t{\n\t\t\tdd_used_t t;\n\t\t\tuint64_t u = 0;\n\t\t\tfor (t = 0; t < DD_USED_NUM; t++)\n\t\t\t\tu += ddp->dd_used_breakdown[t];\n\t\t\tASSERT3U(u, ==, ddp->dd_used_bytes);\n\t\t}\n#endif\n\t}\n\tif (needlock)\n\t\tmutex_exit(&dd->dd_lock);\n\n\tif (dd->dd_parent != NULL) {\n\t\tdsl_dir_diduse_transfer_space(dd->dd_parent,\n\t\t    accounted_delta, compressed, uncompressed,\n\t\t    used, DD_USED_CHILD_RSRV, DD_USED_CHILD, tx);\n\t}\n}\n\nvoid\ndsl_dir_transfer_space(dsl_dir_t *dd, int64_t delta,\n    dd_used_t oldtype, dd_used_t newtype, dmu_tx_t *tx)\n{\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(oldtype < DD_USED_NUM);\n\tASSERT(newtype < DD_USED_NUM);\n\n\tdsl_dir_phys_t *ddp = dsl_dir_phys(dd);\n\tif (delta == 0 ||\n\t    !(ddp->dd_flags & DD_FLAG_USED_BREAKDOWN))\n\t\treturn;\n\n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\tmutex_enter(&dd->dd_lock);\n\tASSERT(delta > 0 ?\n\t    ddp->dd_used_breakdown[oldtype] >= delta :\n\t    ddp->dd_used_breakdown[newtype] >= -delta);\n\tASSERT(ddp->dd_used_bytes >= ABS(delta));\n\tddp->dd_used_breakdown[oldtype] -= delta;\n\tddp->dd_used_breakdown[newtype] += delta;\n\tmutex_exit(&dd->dd_lock);\n}\n\nvoid\ndsl_dir_diduse_transfer_space(dsl_dir_t *dd, int64_t used,\n    int64_t compressed, int64_t uncompressed, int64_t tonew,\n    dd_used_t oldtype, dd_used_t newtype, dmu_tx_t *tx)\n{\n\tint64_t accounted_delta;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(oldtype < DD_USED_NUM);\n\tASSERT(newtype < DD_USED_NUM);\n\n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\n\tmutex_enter(&dd->dd_lock);\n\tdsl_dir_phys_t *ddp = dsl_dir_phys(dd);\n\taccounted_delta = parent_delta(dd, ddp->dd_used_bytes, used);\n\tASSERT(used >= 0 || ddp->dd_used_bytes >= -used);\n\tASSERT(compressed >= 0 || ddp->dd_compressed_bytes >= -compressed);\n\tASSERT(uncompressed >= 0 ||\n\t    ddp->dd_uncompressed_bytes >= -uncompressed);\n\tddp->dd_used_bytes += used;\n\tddp->dd_uncompressed_bytes += uncompressed;\n\tddp->dd_compressed_bytes += compressed;\n\n\tif (ddp->dd_flags & DD_FLAG_USED_BREAKDOWN) {\n\t\tASSERT(tonew - used <= 0 ||\n\t\t    ddp->dd_used_breakdown[oldtype] >= tonew - used);\n\t\tASSERT(tonew >= 0 ||\n\t\t    ddp->dd_used_breakdown[newtype] >= -tonew);\n\t\tddp->dd_used_breakdown[oldtype] -= tonew - used;\n\t\tddp->dd_used_breakdown[newtype] += tonew;\n#ifdef ZFS_DEBUG\n\t\t{\n\t\t\tdd_used_t t;\n\t\t\tuint64_t u = 0;\n\t\t\tfor (t = 0; t < DD_USED_NUM; t++)\n\t\t\t\tu += ddp->dd_used_breakdown[t];\n\t\t\tASSERT3U(u, ==, ddp->dd_used_bytes);\n\t\t}\n#endif\n\t}\n\tmutex_exit(&dd->dd_lock);\n\n\tif (dd->dd_parent != NULL) {\n\t\tdsl_dir_diduse_transfer_space(dd->dd_parent,\n\t\t    accounted_delta, compressed, uncompressed,\n\t\t    used, DD_USED_CHILD_RSRV, DD_USED_CHILD, tx);\n\t}\n}\n\ntypedef struct dsl_dir_set_qr_arg {\n\tconst char *ddsqra_name;\n\tzprop_source_t ddsqra_source;\n\tuint64_t ddsqra_value;\n} dsl_dir_set_qr_arg_t;\n\nstatic int\ndsl_dir_set_quota_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dir_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tint error;\n\tuint64_t towrite, newval;\n\n\terror = dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_prop_predict(ds->ds_dir, \"quota\",\n\t    ddsqra->ddsqra_source, ddsqra->ddsqra_value, &newval);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (newval == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\tmutex_enter(&ds->ds_dir->dd_lock);\n\t \n\ttowrite = dsl_dir_space_towrite(ds->ds_dir);\n\tif ((dmu_tx_is_syncing(tx) || towrite == 0) &&\n\t    (newval < dsl_dir_phys(ds->ds_dir)->dd_reserved ||\n\t    newval < dsl_dir_phys(ds->ds_dir)->dd_used_bytes + towrite)) {\n\t\terror = SET_ERROR(ENOSPC);\n\t}\n\tmutex_exit(&ds->ds_dir->dd_lock);\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (error);\n}\n\nstatic void\ndsl_dir_set_quota_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dir_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tuint64_t newval;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds));\n\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_RECVD_PROPS) {\n\t\tdsl_prop_set_sync_impl(ds, zfs_prop_to_name(ZFS_PROP_QUOTA),\n\t\t    ddsqra->ddsqra_source, sizeof (ddsqra->ddsqra_value), 1,\n\t\t    &ddsqra->ddsqra_value, tx);\n\n\t\tVERIFY0(dsl_prop_get_int_ds(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_QUOTA), &newval));\n\t} else {\n\t\tnewval = ddsqra->ddsqra_value;\n\t\tspa_history_log_internal_ds(ds, \"set\", tx, \"%s=%lld\",\n\t\t    zfs_prop_to_name(ZFS_PROP_QUOTA), (longlong_t)newval);\n\t}\n\n\tdmu_buf_will_dirty(ds->ds_dir->dd_dbuf, tx);\n\tmutex_enter(&ds->ds_dir->dd_lock);\n\tdsl_dir_phys(ds->ds_dir)->dd_quota = newval;\n\tmutex_exit(&ds->ds_dir->dd_lock);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dir_set_quota(const char *ddname, zprop_source_t source, uint64_t quota)\n{\n\tdsl_dir_set_qr_arg_t ddsqra;\n\n\tddsqra.ddsqra_name = ddname;\n\tddsqra.ddsqra_source = source;\n\tddsqra.ddsqra_value = quota;\n\n\treturn (dsl_sync_task(ddname, dsl_dir_set_quota_check,\n\t    dsl_dir_set_quota_sync, &ddsqra, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\nstatic int\ndsl_dir_set_reservation_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dir_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tdsl_dir_t *dd;\n\tuint64_t newval, used, avail;\n\tint error;\n\n\terror = dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\tdd = ds->ds_dir;\n\n\t \n\tif (!dmu_tx_is_syncing(tx)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\terror = dsl_prop_predict(ds->ds_dir,\n\t    zfs_prop_to_name(ZFS_PROP_RESERVATION),\n\t    ddsqra->ddsqra_source, ddsqra->ddsqra_value, &newval);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\tmutex_enter(&dd->dd_lock);\n\tused = dsl_dir_phys(dd)->dd_used_bytes;\n\tmutex_exit(&dd->dd_lock);\n\n\tif (dd->dd_parent) {\n\t\tavail = dsl_dir_space_available(dd->dd_parent,\n\t\t    NULL, 0, FALSE);\n\t} else {\n\t\tavail = dsl_pool_adjustedsize(dd->dd_pool,\n\t\t    ZFS_SPACE_CHECK_NORMAL) - used;\n\t}\n\n\tif (MAX(used, newval) > MAX(used, dsl_dir_phys(dd)->dd_reserved)) {\n\t\tuint64_t delta = MAX(used, newval) -\n\t\t    MAX(used, dsl_dir_phys(dd)->dd_reserved);\n\n\t\tif (delta > avail ||\n\t\t    (dsl_dir_phys(dd)->dd_quota > 0 &&\n\t\t    newval > dsl_dir_phys(dd)->dd_quota))\n\t\t\terror = SET_ERROR(ENOSPC);\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (error);\n}\n\nvoid\ndsl_dir_set_reservation_sync_impl(dsl_dir_t *dd, uint64_t value, dmu_tx_t *tx)\n{\n\tuint64_t used;\n\tint64_t delta;\n\n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\n\tmutex_enter(&dd->dd_lock);\n\tused = dsl_dir_phys(dd)->dd_used_bytes;\n\tdelta = MAX(used, value) - MAX(used, dsl_dir_phys(dd)->dd_reserved);\n\tdsl_dir_phys(dd)->dd_reserved = value;\n\n\tif (dd->dd_parent != NULL) {\n\t\t \n\t\tdsl_dir_diduse_space(dd->dd_parent, DD_USED_CHILD_RSRV,\n\t\t    delta, 0, 0, tx);\n\t}\n\tmutex_exit(&dd->dd_lock);\n}\n\nstatic void\ndsl_dir_set_reservation_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dir_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tuint64_t newval;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds));\n\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_RECVD_PROPS) {\n\t\tdsl_prop_set_sync_impl(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_RESERVATION),\n\t\t    ddsqra->ddsqra_source, sizeof (ddsqra->ddsqra_value), 1,\n\t\t    &ddsqra->ddsqra_value, tx);\n\n\t\tVERIFY0(dsl_prop_get_int_ds(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_RESERVATION), &newval));\n\t} else {\n\t\tnewval = ddsqra->ddsqra_value;\n\t\tspa_history_log_internal_ds(ds, \"set\", tx, \"%s=%lld\",\n\t\t    zfs_prop_to_name(ZFS_PROP_RESERVATION),\n\t\t    (longlong_t)newval);\n\t}\n\n\tdsl_dir_set_reservation_sync_impl(ds->ds_dir, newval, tx);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dir_set_reservation(const char *ddname, zprop_source_t source,\n    uint64_t reservation)\n{\n\tdsl_dir_set_qr_arg_t ddsqra;\n\n\tddsqra.ddsqra_name = ddname;\n\tddsqra.ddsqra_source = source;\n\tddsqra.ddsqra_value = reservation;\n\n\treturn (dsl_sync_task(ddname, dsl_dir_set_reservation_check,\n\t    dsl_dir_set_reservation_sync, &ddsqra, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\nstatic dsl_dir_t *\nclosest_common_ancestor(dsl_dir_t *ds1, dsl_dir_t *ds2)\n{\n\tfor (; ds1; ds1 = ds1->dd_parent) {\n\t\tdsl_dir_t *dd;\n\t\tfor (dd = ds2; dd; dd = dd->dd_parent) {\n\t\t\tif (ds1 == dd)\n\t\t\t\treturn (dd);\n\t\t}\n\t}\n\treturn (NULL);\n}\n\n \nstatic int64_t\nwould_change(dsl_dir_t *dd, int64_t delta, dsl_dir_t *ancestor)\n{\n\tif (dd == ancestor)\n\t\treturn (delta);\n\n\tmutex_enter(&dd->dd_lock);\n\tdelta = parent_delta(dd, dsl_dir_phys(dd)->dd_used_bytes, delta);\n\tmutex_exit(&dd->dd_lock);\n\treturn (would_change(dd->dd_parent, delta, ancestor));\n}\n\ntypedef struct dsl_dir_rename_arg {\n\tconst char *ddra_oldname;\n\tconst char *ddra_newname;\n\tcred_t *ddra_cred;\n\tproc_t *ddra_proc;\n} dsl_dir_rename_arg_t;\n\ntypedef struct dsl_valid_rename_arg {\n\tint char_delta;\n\tint nest_delta;\n} dsl_valid_rename_arg_t;\n\nstatic int\ndsl_valid_rename(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)\n{\n\t(void) dp;\n\tdsl_valid_rename_arg_t *dvra = arg;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\n\tdsl_dataset_name(ds, namebuf);\n\n\tASSERT3U(strnlen(namebuf, ZFS_MAX_DATASET_NAME_LEN),\n\t    <, ZFS_MAX_DATASET_NAME_LEN);\n\tint namelen = strlen(namebuf) + dvra->char_delta;\n\tint depth = get_dataset_depth(namebuf) + dvra->nest_delta;\n\n\tif (namelen >= ZFS_MAX_DATASET_NAME_LEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\tif (dvra->nest_delta > 0 && depth >= zfs_max_dataset_nesting)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\treturn (0);\n}\n\nstatic int\ndsl_dir_rename_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dir_rename_arg_t *ddra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd, *newparent;\n\tdsl_valid_rename_arg_t dvra;\n\tdsl_dataset_t *parentds;\n\tobjset_t *parentos;\n\tconst char *mynewname;\n\tint error;\n\n\t \n\terror = dsl_dir_hold(dp, ddra->ddra_oldname, FTAG, &dd, NULL);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\terror = dsl_dir_hold(dp, ddra->ddra_newname, FTAG,\n\t    &newparent, &mynewname);\n\tif (error != 0) {\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (dd->dd_pool != newparent->dd_pool) {\n\t\tdsl_dir_rele(newparent, FTAG);\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\t \n\tif (mynewname == NULL) {\n\t\tdsl_dir_rele(newparent, FTAG);\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (SET_ERROR(EEXIST));\n\t}\n\n\t \n\terror = dsl_dataset_hold_obj(newparent->dd_pool,\n\t    dsl_dir_phys(newparent)->dd_head_dataset_obj, FTAG, &parentds);\n\tif (error != 0) {\n\t\tdsl_dir_rele(newparent, FTAG);\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (error);\n\t}\n\terror = dmu_objset_from_ds(parentds, &parentos);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(parentds, FTAG);\n\t\tdsl_dir_rele(newparent, FTAG);\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (error);\n\t}\n\tif (dmu_objset_type(parentos) != DMU_OST_ZFS) {\n\t\tdsl_dataset_rele(parentds, FTAG);\n\t\tdsl_dir_rele(newparent, FTAG);\n\t\tdsl_dir_rele(dd, FTAG);\n\t\treturn (SET_ERROR(ZFS_ERR_WRONG_PARENT));\n\t}\n\tdsl_dataset_rele(parentds, FTAG);\n\n\tASSERT3U(strnlen(ddra->ddra_newname, ZFS_MAX_DATASET_NAME_LEN),\n\t    <, ZFS_MAX_DATASET_NAME_LEN);\n\tASSERT3U(strnlen(ddra->ddra_oldname, ZFS_MAX_DATASET_NAME_LEN),\n\t    <, ZFS_MAX_DATASET_NAME_LEN);\n\tdvra.char_delta = strlen(ddra->ddra_newname)\n\t    - strlen(ddra->ddra_oldname);\n\tdvra.nest_delta = get_dataset_depth(ddra->ddra_newname)\n\t    - get_dataset_depth(ddra->ddra_oldname);\n\n\t \n\tif (dvra.char_delta > 0 || dvra.nest_delta > 0) {\n\t\terror = dmu_objset_find_dp(dp, dd->dd_object, dsl_valid_rename,\n\t\t    &dvra, DS_FIND_CHILDREN | DS_FIND_SNAPSHOTS);\n\t\tif (error != 0) {\n\t\t\tdsl_dir_rele(newparent, FTAG);\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (dmu_tx_is_syncing(tx)) {\n\t\tif (spa_feature_is_active(dp->dp_spa,\n\t\t    SPA_FEATURE_FS_SS_LIMIT)) {\n\t\t\t \n\t\t\tdsl_dir_init_fs_ss_count(dd, tx);\n\t\t}\n\t}\n\n\tif (newparent != dd->dd_parent) {\n\t\t \n\t\tuint64_t myspace =\n\t\t    MAX(dsl_dir_phys(dd)->dd_used_bytes,\n\t\t    dsl_dir_phys(dd)->dd_reserved);\n\t\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\t\tuint64_t fs_cnt = 0;\n\t\tuint64_t ss_cnt = 0;\n\n\t\tif (dsl_dir_is_zapified(dd)) {\n\t\t\tint err;\n\n\t\t\terr = zap_lookup(os, dd->dd_object,\n\t\t\t    DD_FIELD_FILESYSTEM_COUNT, sizeof (fs_cnt), 1,\n\t\t\t    &fs_cnt);\n\t\t\tif (err != ENOENT && err != 0) {\n\t\t\t\tdsl_dir_rele(newparent, FTAG);\n\t\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\t\treturn (err);\n\t\t\t}\n\n\t\t\t \n\t\t\tfs_cnt++;\n\n\t\t\terr = zap_lookup(os, dd->dd_object,\n\t\t\t    DD_FIELD_SNAPSHOT_COUNT, sizeof (ss_cnt), 1,\n\t\t\t    &ss_cnt);\n\t\t\tif (err != ENOENT && err != 0) {\n\t\t\t\tdsl_dir_rele(newparent, FTAG);\n\t\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\terror = dsl_dir_rename_crypt_check(dd, newparent);\n\t\tif (error != 0) {\n\t\t\tdsl_dir_rele(newparent, FTAG);\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\treturn (SET_ERROR(EACCES));\n\t\t}\n\n\t\t \n\t\tif (closest_common_ancestor(dd, newparent) == dd) {\n\t\t\tdsl_dir_rele(newparent, FTAG);\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\terror = dsl_dir_transfer_possible(dd->dd_parent,\n\t\t    newparent, fs_cnt, ss_cnt, myspace,\n\t\t    ddra->ddra_cred, ddra->ddra_proc);\n\t\tif (error != 0) {\n\t\t\tdsl_dir_rele(newparent, FTAG);\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tdsl_dir_rele(newparent, FTAG);\n\tdsl_dir_rele(dd, FTAG);\n\treturn (0);\n}\n\nstatic void\ndsl_dir_rename_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dir_rename_arg_t *ddra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd, *newparent;\n\tconst char *mynewname;\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tVERIFY0(dsl_dir_hold(dp, ddra->ddra_oldname, FTAG, &dd, NULL));\n\tVERIFY0(dsl_dir_hold(dp, ddra->ddra_newname, FTAG, &newparent,\n\t    &mynewname));\n\n\tASSERT3P(mynewname, !=, NULL);\n\n\t \n\tspa_history_log_internal_dd(dd, \"rename\", tx,\n\t    \"-> %s\", ddra->ddra_newname);\n\n\tif (newparent != dd->dd_parent) {\n\t\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\t\tuint64_t fs_cnt = 0;\n\t\tuint64_t ss_cnt = 0;\n\n\t\t \n\t\tif (spa_feature_is_active(dp->dp_spa,\n\t\t    SPA_FEATURE_FS_SS_LIMIT)) {\n\t\t\tVERIFY0(zap_lookup(os, dd->dd_object,\n\t\t\t    DD_FIELD_FILESYSTEM_COUNT, sizeof (fs_cnt), 1,\n\t\t\t    &fs_cnt));\n\t\t\t \n\t\t\tfs_cnt++;\n\n\t\t\tVERIFY0(zap_lookup(os, dd->dd_object,\n\t\t\t    DD_FIELD_SNAPSHOT_COUNT, sizeof (ss_cnt), 1,\n\t\t\t    &ss_cnt));\n\t\t}\n\n\t\tdsl_fs_ss_count_adjust(dd->dd_parent, -fs_cnt,\n\t\t    DD_FIELD_FILESYSTEM_COUNT, tx);\n\t\tdsl_fs_ss_count_adjust(newparent, fs_cnt,\n\t\t    DD_FIELD_FILESYSTEM_COUNT, tx);\n\n\t\tdsl_fs_ss_count_adjust(dd->dd_parent, -ss_cnt,\n\t\t    DD_FIELD_SNAPSHOT_COUNT, tx);\n\t\tdsl_fs_ss_count_adjust(newparent, ss_cnt,\n\t\t    DD_FIELD_SNAPSHOT_COUNT, tx);\n\n\t\tdsl_dir_diduse_space(dd->dd_parent, DD_USED_CHILD,\n\t\t    -dsl_dir_phys(dd)->dd_used_bytes,\n\t\t    -dsl_dir_phys(dd)->dd_compressed_bytes,\n\t\t    -dsl_dir_phys(dd)->dd_uncompressed_bytes, tx);\n\t\tdsl_dir_diduse_space(newparent, DD_USED_CHILD,\n\t\t    dsl_dir_phys(dd)->dd_used_bytes,\n\t\t    dsl_dir_phys(dd)->dd_compressed_bytes,\n\t\t    dsl_dir_phys(dd)->dd_uncompressed_bytes, tx);\n\n\t\tif (dsl_dir_phys(dd)->dd_reserved >\n\t\t    dsl_dir_phys(dd)->dd_used_bytes) {\n\t\t\tuint64_t unused_rsrv = dsl_dir_phys(dd)->dd_reserved -\n\t\t\t    dsl_dir_phys(dd)->dd_used_bytes;\n\n\t\t\tdsl_dir_diduse_space(dd->dd_parent, DD_USED_CHILD_RSRV,\n\t\t\t    -unused_rsrv, 0, 0, tx);\n\t\t\tdsl_dir_diduse_space(newparent, DD_USED_CHILD_RSRV,\n\t\t\t    unused_rsrv, 0, 0, tx);\n\t\t}\n\t}\n\n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\n\t \n\tVERIFY0(zap_remove(mos,\n\t    dsl_dir_phys(dd->dd_parent)->dd_child_dir_zapobj,\n\t    dd->dd_myname, tx));\n\n\t(void) strlcpy(dd->dd_myname, mynewname,\n\t    sizeof (dd->dd_myname));\n\tdsl_dir_rele(dd->dd_parent, dd);\n\tdsl_dir_phys(dd)->dd_parent_obj = newparent->dd_object;\n\tVERIFY0(dsl_dir_hold_obj(dp,\n\t    newparent->dd_object, NULL, dd, &dd->dd_parent));\n\n\t \n\tVERIFY0(zap_add(mos, dsl_dir_phys(newparent)->dd_child_dir_zapobj,\n\t    dd->dd_myname, 8, 1, &dd->dd_object, tx));\n\n\t \n\tzfsvfs_update_fromname(ddra->ddra_oldname, ddra->ddra_newname);\n\tzvol_rename_minors(dp->dp_spa, ddra->ddra_oldname,\n\t    ddra->ddra_newname, B_TRUE);\n\n\tdsl_prop_notify_all(dd);\n\n\tdsl_dir_rele(newparent, FTAG);\n\tdsl_dir_rele(dd, FTAG);\n}\n\nint\ndsl_dir_rename(const char *oldname, const char *newname)\n{\n\tdsl_dir_rename_arg_t ddra;\n\n\tddra.ddra_oldname = oldname;\n\tddra.ddra_newname = newname;\n\tddra.ddra_cred = CRED();\n\tddra.ddra_proc = curproc;\n\n\treturn (dsl_sync_task(oldname,\n\t    dsl_dir_rename_check, dsl_dir_rename_sync, &ddra,\n\t    3, ZFS_SPACE_CHECK_RESERVED));\n}\n\nint\ndsl_dir_transfer_possible(dsl_dir_t *sdd, dsl_dir_t *tdd,\n    uint64_t fs_cnt, uint64_t ss_cnt, uint64_t space,\n    cred_t *cr, proc_t *proc)\n{\n\tdsl_dir_t *ancestor;\n\tint64_t adelta;\n\tuint64_t avail;\n\tint err;\n\n\tancestor = closest_common_ancestor(sdd, tdd);\n\tadelta = would_change(sdd, -space, ancestor);\n\tavail = dsl_dir_space_available(tdd, ancestor, adelta, FALSE);\n\tif (avail < space)\n\t\treturn (SET_ERROR(ENOSPC));\n\n\terr = dsl_fs_ss_limit_check(tdd, fs_cnt, ZFS_PROP_FILESYSTEM_LIMIT,\n\t    ancestor, cr, proc);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dsl_fs_ss_limit_check(tdd, ss_cnt, ZFS_PROP_SNAPSHOT_LIMIT,\n\t    ancestor, cr, proc);\n\tif (err != 0)\n\t\treturn (err);\n\n\treturn (0);\n}\n\ninode_timespec_t\ndsl_dir_snap_cmtime(dsl_dir_t *dd)\n{\n\tinode_timespec_t t;\n\n\tmutex_enter(&dd->dd_lock);\n\tt = dd->dd_snap_cmtime;\n\tmutex_exit(&dd->dd_lock);\n\n\treturn (t);\n}\n\nvoid\ndsl_dir_snap_cmtime_update(dsl_dir_t *dd, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tinode_timespec_t t;\n\tgethrestime(&t);\n\n\tmutex_enter(&dd->dd_lock);\n\tdd->dd_snap_cmtime = t;\n\tif (spa_feature_is_enabled(dp->dp_spa,\n\t    SPA_FEATURE_EXTENSIBLE_DATASET)) {\n\t\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\t\tuint64_t ddobj = dd->dd_object;\n\t\tdsl_dir_zapify(dd, tx);\n\t\tVERIFY0(zap_update(mos, ddobj,\n\t\t    DD_FIELD_SNAPSHOTS_CHANGED,\n\t\t    sizeof (uint64_t),\n\t\t    sizeof (inode_timespec_t) / sizeof (uint64_t),\n\t\t    &t, tx));\n\t}\n\tmutex_exit(&dd->dd_lock);\n}\n\nvoid\ndsl_dir_zapify(dsl_dir_t *dd, dmu_tx_t *tx)\n{\n\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\tdmu_object_zapify(mos, dd->dd_object, DMU_OT_DSL_DIR, tx);\n}\n\nboolean_t\ndsl_dir_is_zapified(dsl_dir_t *dd)\n{\n\tdmu_object_info_t doi;\n\n\tdmu_object_info_from_db(dd->dd_dbuf, &doi);\n\treturn (doi.doi_type == DMU_OTN_ZAP_METADATA);\n}\n\nvoid\ndsl_dir_livelist_open(dsl_dir_t *dd, uint64_t obj)\n{\n\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\tASSERT(spa_feature_is_active(dd->dd_pool->dp_spa,\n\t    SPA_FEATURE_LIVELIST));\n\tdsl_deadlist_open(&dd->dd_livelist, mos, obj);\n\tbplist_create(&dd->dd_pending_allocs);\n\tbplist_create(&dd->dd_pending_frees);\n}\n\nvoid\ndsl_dir_livelist_close(dsl_dir_t *dd)\n{\n\tdsl_deadlist_close(&dd->dd_livelist);\n\tbplist_destroy(&dd->dd_pending_allocs);\n\tbplist_destroy(&dd->dd_pending_frees);\n}\n\nvoid\ndsl_dir_remove_livelist(dsl_dir_t *dd, dmu_tx_t *tx, boolean_t total)\n{\n\tuint64_t obj;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tspa_t *spa = dp->dp_spa;\n\tlivelist_condense_entry_t to_condense = spa->spa_to_condense;\n\n\tif (!dsl_deadlist_is_open(&dd->dd_livelist))\n\t\treturn;\n\n\t \n\tzthr_t *ll_condense_thread = spa->spa_livelist_condense_zthr;\n\tif (ll_condense_thread != NULL &&\n\t    (to_condense.ds != NULL) && (to_condense.ds->ds_dir == dd)) {\n\t\t \n\t\tspa->spa_to_condense.cancelled = B_TRUE;\n\t\tzthr_wait_cycle_done(ll_condense_thread);\n\t\t \n\t\tif ((spa->spa_to_condense.ds != NULL) &&\n\t\t    !spa->spa_to_condense.syncing) {\n\t\t\tdmu_buf_rele(spa->spa_to_condense.ds->ds_dbuf,\n\t\t\t    spa);\n\t\t\tspa->spa_to_condense.ds = NULL;\n\t\t}\n\t}\n\n\tdsl_dir_livelist_close(dd);\n\tVERIFY0(zap_lookup(dp->dp_meta_objset, dd->dd_object,\n\t    DD_FIELD_LIVELIST, sizeof (uint64_t), 1, &obj));\n\tVERIFY0(zap_remove(dp->dp_meta_objset, dd->dd_object,\n\t    DD_FIELD_LIVELIST, tx));\n\tif (total) {\n\t\tdsl_deadlist_free(dp->dp_meta_objset, obj, tx);\n\t\tspa_feature_decr(spa, SPA_FEATURE_LIVELIST, tx);\n\t}\n}\n\nstatic int\ndsl_dir_activity_in_progress(dsl_dir_t *dd, dsl_dataset_t *ds,\n    zfs_wait_activity_t activity, boolean_t *in_progress)\n{\n\tint error = 0;\n\n\tASSERT(MUTEX_HELD(&dd->dd_activity_lock));\n\n\tswitch (activity) {\n\tcase ZFS_WAIT_DELETEQ: {\n#ifdef _KERNEL\n\t\tobjset_t *os;\n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\tmutex_enter(&os->os_user_ptr_lock);\n\t\tvoid *user = dmu_objset_get_user(os);\n\t\tmutex_exit(&os->os_user_ptr_lock);\n\t\tif (dmu_objset_type(os) != DMU_OST_ZFS ||\n\t\t    user == NULL || zfs_get_vfs_flag_unmounted(os)) {\n\t\t\t*in_progress = B_FALSE;\n\t\t\treturn (0);\n\t\t}\n\n\t\tuint64_t readonly = B_FALSE;\n\t\terror = zfs_get_temporary_prop(ds, ZFS_PROP_READONLY, &readonly,\n\t\t    NULL);\n\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\tif (readonly || !spa_writeable(dd->dd_pool->dp_spa)) {\n\t\t\t*in_progress = B_FALSE;\n\t\t\treturn (0);\n\t\t}\n\n\t\tuint64_t count, unlinked_obj;\n\t\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_UNLINKED_SET, 8, 1,\n\t\t    &unlinked_obj);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tbreak;\n\t\t}\n\t\terror = zap_count(os, unlinked_obj, &count);\n\n\t\tif (error == 0)\n\t\t\t*in_progress = (count != 0);\n\t\tbreak;\n#else\n\t\t \n\t\t(void) ds;\n\t\t*in_progress = B_FALSE;\n\t\tbreak;\n#endif\n\t}\n\tdefault:\n\t\tpanic(\"unrecognized value for activity %d\", activity);\n\t}\n\n\treturn (error);\n}\n\nint\ndsl_dir_wait(dsl_dir_t *dd, dsl_dataset_t *ds, zfs_wait_activity_t activity,\n    boolean_t *waited)\n{\n\tint error = 0;\n\tboolean_t in_progress;\n\tdsl_pool_t *dp = dd->dd_pool;\n\tfor (;;) {\n\t\tdsl_pool_config_enter(dp, FTAG);\n\t\terror = dsl_dir_activity_in_progress(dd, ds, activity,\n\t\t    &in_progress);\n\t\tdsl_pool_config_exit(dp, FTAG);\n\t\tif (error != 0 || !in_progress)\n\t\t\tbreak;\n\n\t\t*waited = B_TRUE;\n\n\t\tif (cv_wait_sig(&dd->dd_activity_cv, &dd->dd_activity_lock) ==\n\t\t    0 || dd->dd_activity_cancelled) {\n\t\t\terror = SET_ERROR(EINTR);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (error);\n}\n\nvoid\ndsl_dir_cancel_waiters(dsl_dir_t *dd)\n{\n\tmutex_enter(&dd->dd_activity_lock);\n\tdd->dd_activity_cancelled = B_TRUE;\n\tcv_broadcast(&dd->dd_activity_cv);\n\twhile (dd->dd_activity_waiters > 0)\n\t\tcv_wait(&dd->dd_activity_cv, &dd->dd_activity_lock);\n\tmutex_exit(&dd->dd_activity_lock);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dsl_dir_set_quota);\nEXPORT_SYMBOL(dsl_dir_set_reservation);\n#endif\n\n \nZFS_MODULE_PARAM(zfs, , zvol_enforce_quotas, INT, ZMOD_RW,\n\t\"Enable strict ZVOL quota enforcment\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}