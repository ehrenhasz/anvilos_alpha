{
  "module_name": "dsl_dataset.c",
  "hash_id": "5927b6dfc1c03bf179670febc4afc01cf468a1350e7df781f017669dc17d41f5",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_dataset.c",
  "human_readable_source": " \n\n \n\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/arc.h>\n#include <sys/zio.h>\n#include <sys/zap.h>\n#include <sys/zfeature.h>\n#include <sys/unique.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_onexit.h>\n#include <sys/zvol.h>\n#include <sys/dsl_scan.h>\n#include <sys/dsl_deadlist.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_userhold.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/policy.h>\n#include <sys/dmu_send.h>\n#include <sys/dmu_recv.h>\n#include <sys/zio_compress.h>\n#include <zfs_fletcher.h>\n#include <sys/zio_checksum.h>\n\n \n#ifdef _ILP32\nuint_t zfs_max_recordsize =  1 * 1024 * 1024;\n#else\nuint_t zfs_max_recordsize = 16 * 1024 * 1024;\n#endif\nstatic int zfs_allow_redacted_dataset_mount = 0;\n\nint zfs_snapshot_history_enabled = 1;\n\n#define\tSWITCH64(x, y) \\\n\t{ \\\n\t\tuint64_t __tmp = (x); \\\n\t\t(x) = (y); \\\n\t\t(y) = __tmp; \\\n\t}\n\n#define\tDS_REF_MAX\t(1ULL << 62)\n\nstatic void dsl_dataset_set_remap_deadlist_object(dsl_dataset_t *ds,\n    uint64_t obj, dmu_tx_t *tx);\nstatic void dsl_dataset_unset_remap_deadlist_object(dsl_dataset_t *ds,\n    dmu_tx_t *tx);\n\nstatic void unload_zfeature(dsl_dataset_t *ds, spa_feature_t f);\n\nextern uint_t spa_asize_inflation;\n\nstatic zil_header_t zero_zil;\n\n \nstatic int64_t\nparent_delta(dsl_dataset_t *ds, int64_t delta)\n{\n\tdsl_dataset_phys_t *ds_phys;\n\tuint64_t old_bytes, new_bytes;\n\n\tif (ds->ds_reserved == 0)\n\t\treturn (delta);\n\n\tds_phys = dsl_dataset_phys(ds);\n\told_bytes = MAX(ds_phys->ds_unique_bytes, ds->ds_reserved);\n\tnew_bytes = MAX(ds_phys->ds_unique_bytes + delta, ds->ds_reserved);\n\n\tASSERT3U(ABS((int64_t)(new_bytes - old_bytes)), <=, ABS(delta));\n\treturn (new_bytes - old_bytes);\n}\n\nvoid\ndsl_dataset_block_born(dsl_dataset_t *ds, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tint used = bp_get_dsize_sync(spa, bp);\n\tint compressed = BP_GET_PSIZE(bp);\n\tint uncompressed = BP_GET_UCSIZE(bp);\n\tint64_t delta;\n\tspa_feature_t f;\n\n\tdprintf_bp(bp, \"ds=%p\", ds);\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\t \n\tif (BP_IS_HOLE(bp) || BP_IS_REDACTED(bp))\n\t\treturn;\n\tASSERT(BP_GET_TYPE(bp) != DMU_OT_NONE);\n\tASSERT(DMU_OT_IS_VALID(BP_GET_TYPE(bp)));\n\tif (ds == NULL) {\n\t\tdsl_pool_mos_diduse_space(tx->tx_pool,\n\t\t    used, compressed, uncompressed);\n\t\treturn;\n\t}\n\n\tASSERT3U(bp->blk_birth, >, dsl_dataset_phys(ds)->ds_prev_snap_txg);\n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tmutex_enter(&ds->ds_lock);\n\tdelta = parent_delta(ds, used);\n\tdsl_dataset_phys(ds)->ds_referenced_bytes += used;\n\tdsl_dataset_phys(ds)->ds_compressed_bytes += compressed;\n\tdsl_dataset_phys(ds)->ds_uncompressed_bytes += uncompressed;\n\tdsl_dataset_phys(ds)->ds_unique_bytes += used;\n\n\tif (BP_GET_LSIZE(bp) > SPA_OLD_MAXBLOCKSIZE) {\n\t\tds->ds_feature_activation[SPA_FEATURE_LARGE_BLOCKS] =\n\t\t    (void *)B_TRUE;\n\t}\n\n\n\tf = zio_checksum_to_feature(BP_GET_CHECKSUM(bp));\n\tif (f != SPA_FEATURE_NONE) {\n\t\tASSERT3S(spa_feature_table[f].fi_type, ==,\n\t\t    ZFEATURE_TYPE_BOOLEAN);\n\t\tds->ds_feature_activation[f] = (void *)B_TRUE;\n\t}\n\n\tf = zio_compress_to_feature(BP_GET_COMPRESS(bp));\n\tif (f != SPA_FEATURE_NONE) {\n\t\tASSERT3S(spa_feature_table[f].fi_type, ==,\n\t\t    ZFEATURE_TYPE_BOOLEAN);\n\t\tds->ds_feature_activation[f] = (void *)B_TRUE;\n\t}\n\n\t \n\tif (dsl_deadlist_is_open(&ds->ds_dir->dd_livelist) &&\n\t    bp->blk_birth > ds->ds_dir->dd_origin_txg &&\n\t    !(BP_IS_EMBEDDED(bp))) {\n\t\tASSERT(dsl_dir_is_clone(ds->ds_dir));\n\t\tASSERT(spa_feature_is_enabled(spa,\n\t\t    SPA_FEATURE_LIVELIST));\n\t\tbplist_append(&ds->ds_dir->dd_pending_allocs, bp);\n\t}\n\n\tmutex_exit(&ds->ds_lock);\n\tdsl_dir_diduse_transfer_space(ds->ds_dir, delta,\n\t    compressed, uncompressed, used,\n\t    DD_USED_REFRSRV, DD_USED_HEAD, tx);\n}\n\n \nvoid\ndsl_dataset_block_remapped(dsl_dataset_t *ds, uint64_t vdev, uint64_t offset,\n    uint64_t size, uint64_t birth, dmu_tx_t *tx)\n{\n\tspa_t *spa = ds->ds_dir->dd_pool->dp_spa;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(birth <= tx->tx_txg);\n\tASSERT(!ds->ds_is_snapshot);\n\n\tif (birth > dsl_dataset_phys(ds)->ds_prev_snap_txg) {\n\t\tspa_vdev_indirect_mark_obsolete(spa, vdev, offset, size, tx);\n\t} else {\n\t\tblkptr_t fakebp;\n\t\tdva_t *dva = &fakebp.blk_dva[0];\n\n\t\tASSERT(ds != NULL);\n\n\t\tmutex_enter(&ds->ds_remap_deadlist_lock);\n\t\tif (!dsl_dataset_remap_deadlist_exists(ds)) {\n\t\t\tdsl_dataset_create_remap_deadlist(ds, tx);\n\t\t}\n\t\tmutex_exit(&ds->ds_remap_deadlist_lock);\n\n\t\tBP_ZERO(&fakebp);\n\t\tfakebp.blk_birth = birth;\n\t\tDVA_SET_VDEV(dva, vdev);\n\t\tDVA_SET_OFFSET(dva, offset);\n\t\tDVA_SET_ASIZE(dva, size);\n\t\tdsl_deadlist_insert(&ds->ds_remap_deadlist, &fakebp, B_FALSE,\n\t\t    tx);\n\t}\n}\n\nint\ndsl_dataset_block_kill(dsl_dataset_t *ds, const blkptr_t *bp, dmu_tx_t *tx,\n    boolean_t async)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\n\tint used = bp_get_dsize_sync(spa, bp);\n\tint compressed = BP_GET_PSIZE(bp);\n\tint uncompressed = BP_GET_UCSIZE(bp);\n\n\tif (BP_IS_HOLE(bp) || BP_IS_REDACTED(bp))\n\t\treturn (0);\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(bp->blk_birth <= tx->tx_txg);\n\n\tif (ds == NULL) {\n\t\tdsl_free(tx->tx_pool, tx->tx_txg, bp);\n\t\tdsl_pool_mos_diduse_space(tx->tx_pool,\n\t\t    -used, -compressed, -uncompressed);\n\t\treturn (used);\n\t}\n\tASSERT3P(tx->tx_pool, ==, ds->ds_dir->dd_pool);\n\n\tASSERT(!ds->ds_is_snapshot);\n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\n\t \n\tif (dsl_deadlist_is_open(&ds->ds_dir->dd_livelist) &&\n\t    bp->blk_birth > ds->ds_dir->dd_origin_txg &&\n\t    !(BP_IS_EMBEDDED(bp))) {\n\t\tASSERT(dsl_dir_is_clone(ds->ds_dir));\n\t\tASSERT(spa_feature_is_enabled(spa,\n\t\t    SPA_FEATURE_LIVELIST));\n\t\tbplist_append(&ds->ds_dir->dd_pending_frees, bp);\n\t}\n\n\tif (bp->blk_birth > dsl_dataset_phys(ds)->ds_prev_snap_txg) {\n\t\tint64_t delta;\n\n\t\tdprintf_bp(bp, \"freeing ds=%llu\", (u_longlong_t)ds->ds_object);\n\t\tdsl_free(tx->tx_pool, tx->tx_txg, bp);\n\n\t\tmutex_enter(&ds->ds_lock);\n\t\tASSERT(dsl_dataset_phys(ds)->ds_unique_bytes >= used ||\n\t\t    !DS_UNIQUE_IS_ACCURATE(ds));\n\t\tdelta = parent_delta(ds, -used);\n\t\tdsl_dataset_phys(ds)->ds_unique_bytes -= used;\n\t\tmutex_exit(&ds->ds_lock);\n\t\tdsl_dir_diduse_transfer_space(ds->ds_dir,\n\t\t    delta, -compressed, -uncompressed, -used,\n\t\t    DD_USED_REFRSRV, DD_USED_HEAD, tx);\n\t} else {\n\t\tdprintf_bp(bp, \"putting on dead list: %s\", \"\");\n\t\tif (async) {\n\t\t\t \n\t\t\tbplist_append(&ds->ds_pending_deadlist, bp);\n\t\t} else {\n\t\t\tdsl_deadlist_insert(&ds->ds_deadlist, bp, B_FALSE, tx);\n\t\t}\n\t\tASSERT3U(ds->ds_prev->ds_object, ==,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj);\n\t\tASSERT(dsl_dataset_phys(ds->ds_prev)->ds_num_children > 0);\n\t\t \n\t\tif (dsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj ==\n\t\t    ds->ds_object && bp->blk_birth >\n\t\t    dsl_dataset_phys(ds->ds_prev)->ds_prev_snap_txg) {\n\t\t\tdmu_buf_will_dirty(ds->ds_prev->ds_dbuf, tx);\n\t\t\tmutex_enter(&ds->ds_prev->ds_lock);\n\t\t\tdsl_dataset_phys(ds->ds_prev)->ds_unique_bytes += used;\n\t\t\tmutex_exit(&ds->ds_prev->ds_lock);\n\t\t}\n\t\tif (bp->blk_birth > ds->ds_dir->dd_origin_txg) {\n\t\t\tdsl_dir_transfer_space(ds->ds_dir, used,\n\t\t\t    DD_USED_HEAD, DD_USED_SNAP, tx);\n\t\t}\n\t}\n\n\tdsl_bookmark_block_killed(ds, bp, tx);\n\n\tmutex_enter(&ds->ds_lock);\n\tASSERT3U(dsl_dataset_phys(ds)->ds_referenced_bytes, >=, used);\n\tdsl_dataset_phys(ds)->ds_referenced_bytes -= used;\n\tASSERT3U(dsl_dataset_phys(ds)->ds_compressed_bytes, >=, compressed);\n\tdsl_dataset_phys(ds)->ds_compressed_bytes -= compressed;\n\tASSERT3U(dsl_dataset_phys(ds)->ds_uncompressed_bytes, >=, uncompressed);\n\tdsl_dataset_phys(ds)->ds_uncompressed_bytes -= uncompressed;\n\tmutex_exit(&ds->ds_lock);\n\n\treturn (used);\n}\n\nstruct feature_type_uint64_array_arg {\n\tuint64_t length;\n\tuint64_t *array;\n};\n\nstatic void\nunload_zfeature(dsl_dataset_t *ds, spa_feature_t f)\n{\n\tswitch (spa_feature_table[f].fi_type) {\n\tcase ZFEATURE_TYPE_BOOLEAN:\n\t\tbreak;\n\tcase ZFEATURE_TYPE_UINT64_ARRAY:\n\t{\n\t\tstruct feature_type_uint64_array_arg *ftuaa = ds->ds_feature[f];\n\t\tkmem_free(ftuaa->array, ftuaa->length * sizeof (uint64_t));\n\t\tkmem_free(ftuaa, sizeof (*ftuaa));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Invalid zfeature type %d\", spa_feature_table[f].fi_type);\n\t}\n}\n\nstatic int\nload_zfeature(objset_t *mos, dsl_dataset_t *ds, spa_feature_t f)\n{\n\tint err = 0;\n\tswitch (spa_feature_table[f].fi_type) {\n\tcase ZFEATURE_TYPE_BOOLEAN:\n\t\terr = zap_contains(mos, ds->ds_object,\n\t\t    spa_feature_table[f].fi_guid);\n\t\tif (err == 0) {\n\t\t\tds->ds_feature[f] = (void *)B_TRUE;\n\t\t} else {\n\t\t\tASSERT3U(err, ==, ENOENT);\n\t\t\terr = 0;\n\t\t}\n\t\tbreak;\n\tcase ZFEATURE_TYPE_UINT64_ARRAY:\n\t{\n\t\tuint64_t int_size, num_int;\n\t\tuint64_t *data;\n\t\terr = zap_length(mos, ds->ds_object,\n\t\t    spa_feature_table[f].fi_guid, &int_size, &num_int);\n\t\tif (err != 0) {\n\t\t\tASSERT3U(err, ==, ENOENT);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tASSERT3U(int_size, ==, sizeof (uint64_t));\n\t\tdata = kmem_alloc(int_size * num_int, KM_SLEEP);\n\t\tVERIFY0(zap_lookup(mos, ds->ds_object,\n\t\t    spa_feature_table[f].fi_guid, int_size, num_int, data));\n\t\tstruct feature_type_uint64_array_arg *ftuaa =\n\t\t    kmem_alloc(sizeof (*ftuaa), KM_SLEEP);\n\t\tftuaa->length = num_int;\n\t\tftuaa->array = data;\n\t\tds->ds_feature[f] = ftuaa;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Invalid zfeature type %d\", spa_feature_table[f].fi_type);\n\t}\n\treturn (err);\n}\n\n \nstatic void\ndsl_dataset_evict_sync(void *dbu)\n{\n\tdsl_dataset_t *ds = dbu;\n\n\tASSERT(ds->ds_owner == NULL);\n\n\tunique_remove(ds->ds_fsid_guid);\n}\n\nstatic void\ndsl_dataset_evict_async(void *dbu)\n{\n\tdsl_dataset_t *ds = dbu;\n\n\tASSERT(ds->ds_owner == NULL);\n\n\tds->ds_dbuf = NULL;\n\n\tif (ds->ds_objset != NULL)\n\t\tdmu_objset_evict(ds->ds_objset);\n\n\tif (ds->ds_prev) {\n\t\tdsl_dataset_rele(ds->ds_prev, ds);\n\t\tds->ds_prev = NULL;\n\t}\n\n\tdsl_bookmark_fini_ds(ds);\n\n\tbplist_destroy(&ds->ds_pending_deadlist);\n\tif (dsl_deadlist_is_open(&ds->ds_deadlist))\n\t\tdsl_deadlist_close(&ds->ds_deadlist);\n\tif (dsl_deadlist_is_open(&ds->ds_remap_deadlist))\n\t\tdsl_deadlist_close(&ds->ds_remap_deadlist);\n\tif (ds->ds_dir)\n\t\tdsl_dir_async_rele(ds->ds_dir, ds);\n\n\tASSERT(!list_link_active(&ds->ds_synced_link));\n\n\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\tif (dsl_dataset_feature_is_active(ds, f))\n\t\t\tunload_zfeature(ds, f);\n\t}\n\n\tlist_destroy(&ds->ds_prop_cbs);\n\tmutex_destroy(&ds->ds_lock);\n\tmutex_destroy(&ds->ds_opening_lock);\n\tmutex_destroy(&ds->ds_sendstream_lock);\n\tmutex_destroy(&ds->ds_remap_deadlist_lock);\n\tzfs_refcount_destroy(&ds->ds_longholds);\n\trrw_destroy(&ds->ds_bp_rwlock);\n\n\tkmem_free(ds, sizeof (dsl_dataset_t));\n}\n\nint\ndsl_dataset_get_snapname(dsl_dataset_t *ds)\n{\n\tdsl_dataset_phys_t *headphys;\n\tint err;\n\tdmu_buf_t *headdbuf;\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tif (ds->ds_snapname[0])\n\t\treturn (0);\n\tif (dsl_dataset_phys(ds)->ds_next_snap_obj == 0)\n\t\treturn (0);\n\n\terr = dmu_bonus_hold(mos, dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj,\n\t    FTAG, &headdbuf);\n\tif (err != 0)\n\t\treturn (err);\n\theadphys = headdbuf->db_data;\n\terr = zap_value_search(dp->dp_meta_objset,\n\t    headphys->ds_snapnames_zapobj, ds->ds_object, 0, ds->ds_snapname);\n\tif (err != 0 && zfs_recover == B_TRUE) {\n\t\terr = 0;\n\t\t(void) snprintf(ds->ds_snapname, sizeof (ds->ds_snapname),\n\t\t    \"SNAPOBJ=%llu-ERR=%d\",\n\t\t    (unsigned long long)ds->ds_object, err);\n\t}\n\tdmu_buf_rele(headdbuf, FTAG);\n\treturn (err);\n}\n\nint\ndsl_dataset_snap_lookup(dsl_dataset_t *ds, const char *name, uint64_t *value)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tuint64_t snapobj = dsl_dataset_phys(ds)->ds_snapnames_zapobj;\n\tmatchtype_t mt = 0;\n\tint err;\n\n\tif (dsl_dataset_phys(ds)->ds_flags & DS_FLAG_CI_DATASET)\n\t\tmt = MT_NORMALIZE;\n\n\terr = zap_lookup_norm(mos, snapobj, name, 8, 1,\n\t    value, mt, NULL, 0, NULL);\n\tif (err == ENOTSUP && (mt & MT_NORMALIZE))\n\t\terr = zap_lookup(mos, snapobj, name, 8, 1, value);\n\treturn (err);\n}\n\nint\ndsl_dataset_snap_remove(dsl_dataset_t *ds, const char *name, dmu_tx_t *tx,\n    boolean_t adj_cnt)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tuint64_t snapobj = dsl_dataset_phys(ds)->ds_snapnames_zapobj;\n\tmatchtype_t mt = 0;\n\tint err;\n\n\tdsl_dir_snap_cmtime_update(ds->ds_dir, tx);\n\n\tif (dsl_dataset_phys(ds)->ds_flags & DS_FLAG_CI_DATASET)\n\t\tmt = MT_NORMALIZE;\n\n\terr = zap_remove_norm(mos, snapobj, name, mt, tx);\n\tif (err == ENOTSUP && (mt & MT_NORMALIZE))\n\t\terr = zap_remove(mos, snapobj, name, tx);\n\n\tif (err == 0 && adj_cnt)\n\t\tdsl_fs_ss_count_adjust(ds->ds_dir, -1,\n\t\t    DD_FIELD_SNAPSHOT_COUNT, tx);\n\n\treturn (err);\n}\n\nboolean_t\ndsl_dataset_try_add_ref(dsl_pool_t *dp, dsl_dataset_t *ds, const void *tag)\n{\n\tdmu_buf_t *dbuf = ds->ds_dbuf;\n\tboolean_t result = B_FALSE;\n\n\tif (dbuf != NULL && dmu_buf_try_add_ref(dbuf, dp->dp_meta_objset,\n\t    ds->ds_object, DMU_BONUS_BLKID, tag)) {\n\n\t\tif (ds == dmu_buf_get_user(dbuf))\n\t\t\tresult = B_TRUE;\n\t\telse\n\t\t\tdmu_buf_rele(dbuf, tag);\n\t}\n\n\treturn (result);\n}\n\nint\ndsl_dataset_hold_obj(dsl_pool_t *dp, uint64_t dsobj, const void *tag,\n    dsl_dataset_t **dsp)\n{\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdmu_buf_t *dbuf;\n\tdsl_dataset_t *ds;\n\tint err;\n\tdmu_object_info_t doi;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\terr = dmu_bonus_hold(mos, dsobj, tag, &dbuf);\n\tif (err != 0)\n\t\treturn (err);\n\n\t \n\tdmu_object_info_from_db(dbuf, &doi);\n\tif (doi.doi_bonus_type != DMU_OT_DSL_DATASET) {\n\t\tdmu_buf_rele(dbuf, tag);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tds = dmu_buf_get_user(dbuf);\n\tif (ds == NULL) {\n\t\tdsl_dataset_t *winner = NULL;\n\n\t\tds = kmem_zalloc(sizeof (dsl_dataset_t), KM_SLEEP);\n\t\tds->ds_dbuf = dbuf;\n\t\tds->ds_object = dsobj;\n\t\tds->ds_is_snapshot = dsl_dataset_phys(ds)->ds_num_children != 0;\n\t\tlist_link_init(&ds->ds_synced_link);\n\n\t\terr = dsl_dir_hold_obj(dp, dsl_dataset_phys(ds)->ds_dir_obj,\n\t\t    NULL, ds, &ds->ds_dir);\n\t\tif (err != 0) {\n\t\t\tkmem_free(ds, sizeof (dsl_dataset_t));\n\t\t\tdmu_buf_rele(dbuf, tag);\n\t\t\treturn (err);\n\t\t}\n\n\t\tmutex_init(&ds->ds_lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tmutex_init(&ds->ds_opening_lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tmutex_init(&ds->ds_sendstream_lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tmutex_init(&ds->ds_remap_deadlist_lock,\n\t\t    NULL, MUTEX_DEFAULT, NULL);\n\t\trrw_init(&ds->ds_bp_rwlock, B_FALSE);\n\t\tzfs_refcount_create(&ds->ds_longholds);\n\n\t\tbplist_create(&ds->ds_pending_deadlist);\n\n\t\tlist_create(&ds->ds_sendstreams, sizeof (dmu_sendstatus_t),\n\t\t    offsetof(dmu_sendstatus_t, dss_link));\n\n\t\tlist_create(&ds->ds_prop_cbs, sizeof (dsl_prop_cb_record_t),\n\t\t    offsetof(dsl_prop_cb_record_t, cbr_ds_node));\n\n\t\tif (doi.doi_type == DMU_OTN_ZAP_METADATA) {\n\t\t\tspa_feature_t f;\n\n\t\t\tfor (f = 0; f < SPA_FEATURES; f++) {\n\t\t\t\tif (!(spa_feature_table[f].fi_flags &\n\t\t\t\t    ZFEATURE_FLAG_PER_DATASET))\n\t\t\t\t\tcontinue;\n\t\t\t\terr = load_zfeature(mos, ds, f);\n\t\t\t}\n\t\t}\n\n\t\tif (!ds->ds_is_snapshot) {\n\t\t\tds->ds_snapname[0] = '\\0';\n\t\t\tif (dsl_dataset_phys(ds)->ds_prev_snap_obj != 0) {\n\t\t\t\terr = dsl_dataset_hold_obj(dp,\n\t\t\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj,\n\t\t\t\t    ds, &ds->ds_prev);\n\t\t\t}\n\t\t\tif (err != 0)\n\t\t\t\tgoto after_dsl_bookmark_fini;\n\t\t\terr = dsl_bookmark_init_ds(ds);\n\t\t} else {\n\t\t\tif (zfs_flags & ZFS_DEBUG_SNAPNAMES)\n\t\t\t\terr = dsl_dataset_get_snapname(ds);\n\t\t\tif (err == 0 &&\n\t\t\t    dsl_dataset_phys(ds)->ds_userrefs_obj != 0) {\n\t\t\t\terr = zap_count(\n\t\t\t\t    ds->ds_dir->dd_pool->dp_meta_objset,\n\t\t\t\t    dsl_dataset_phys(ds)->ds_userrefs_obj,\n\t\t\t\t    &ds->ds_userrefs);\n\t\t\t}\n\t\t}\n\n\t\tif (err == 0 && !ds->ds_is_snapshot) {\n\t\t\terr = dsl_prop_get_int_ds(ds,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_REFRESERVATION),\n\t\t\t    &ds->ds_reserved);\n\t\t\tif (err == 0) {\n\t\t\t\terr = dsl_prop_get_int_ds(ds,\n\t\t\t\t    zfs_prop_to_name(ZFS_PROP_REFQUOTA),\n\t\t\t\t    &ds->ds_quota);\n\t\t\t}\n\t\t} else {\n\t\t\tds->ds_reserved = ds->ds_quota = 0;\n\t\t}\n\n\t\tif (err == 0 && ds->ds_dir->dd_crypto_obj != 0 &&\n\t\t    ds->ds_is_snapshot &&\n\t\t    zap_contains(mos, dsobj, DS_FIELD_IVSET_GUID) != 0) {\n\t\t\tdp->dp_spa->spa_errata =\n\t\t\t    ZPOOL_ERRATA_ZOL_8308_ENCRYPTION;\n\t\t}\n\n\t\tdsl_deadlist_open(&ds->ds_deadlist,\n\t\t    mos, dsl_dataset_phys(ds)->ds_deadlist_obj);\n\t\tuint64_t remap_deadlist_obj =\n\t\t    dsl_dataset_get_remap_deadlist_object(ds);\n\t\tif (remap_deadlist_obj != 0) {\n\t\t\tdsl_deadlist_open(&ds->ds_remap_deadlist, mos,\n\t\t\t    remap_deadlist_obj);\n\t\t}\n\n\t\tdmu_buf_init_user(&ds->ds_dbu, dsl_dataset_evict_sync,\n\t\t    dsl_dataset_evict_async, &ds->ds_dbuf);\n\t\tif (err == 0)\n\t\t\twinner = dmu_buf_set_user_ie(dbuf, &ds->ds_dbu);\n\n\t\tif (err != 0 || winner != NULL) {\n\t\t\tdsl_deadlist_close(&ds->ds_deadlist);\n\t\t\tif (dsl_deadlist_is_open(&ds->ds_remap_deadlist))\n\t\t\t\tdsl_deadlist_close(&ds->ds_remap_deadlist);\n\t\t\tdsl_bookmark_fini_ds(ds);\nafter_dsl_bookmark_fini:\n\t\t\tif (ds->ds_prev)\n\t\t\t\tdsl_dataset_rele(ds->ds_prev, ds);\n\t\t\tdsl_dir_rele(ds->ds_dir, ds);\n\t\t\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\t\t\tif (dsl_dataset_feature_is_active(ds, f))\n\t\t\t\t\tunload_zfeature(ds, f);\n\t\t\t}\n\n\t\t\tlist_destroy(&ds->ds_prop_cbs);\n\t\t\tlist_destroy(&ds->ds_sendstreams);\n\t\t\tbplist_destroy(&ds->ds_pending_deadlist);\n\t\t\tmutex_destroy(&ds->ds_lock);\n\t\t\tmutex_destroy(&ds->ds_opening_lock);\n\t\t\tmutex_destroy(&ds->ds_sendstream_lock);\n\t\t\tmutex_destroy(&ds->ds_remap_deadlist_lock);\n\t\t\tzfs_refcount_destroy(&ds->ds_longholds);\n\t\t\trrw_destroy(&ds->ds_bp_rwlock);\n\t\t\tkmem_free(ds, sizeof (dsl_dataset_t));\n\t\t\tif (err != 0) {\n\t\t\t\tdmu_buf_rele(dbuf, tag);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t\tds = winner;\n\t\t} else {\n\t\t\tds->ds_fsid_guid =\n\t\t\t    unique_insert(dsl_dataset_phys(ds)->ds_fsid_guid);\n\t\t\tif (ds->ds_fsid_guid !=\n\t\t\t    dsl_dataset_phys(ds)->ds_fsid_guid) {\n\t\t\t\tzfs_dbgmsg(\"ds_fsid_guid changed from \"\n\t\t\t\t    \"%llx to %llx for pool %s dataset id %llu\",\n\t\t\t\t    (long long)\n\t\t\t\t    dsl_dataset_phys(ds)->ds_fsid_guid,\n\t\t\t\t    (long long)ds->ds_fsid_guid,\n\t\t\t\t    spa_name(dp->dp_spa),\n\t\t\t\t    (u_longlong_t)dsobj);\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT3P(ds->ds_dbuf, ==, dbuf);\n\tASSERT3P(dsl_dataset_phys(ds), ==, dbuf->db_data);\n\tASSERT(dsl_dataset_phys(ds)->ds_prev_snap_obj != 0 ||\n\t    spa_version(dp->dp_spa) < SPA_VERSION_ORIGIN ||\n\t    dp->dp_origin_snap == NULL || ds == dp->dp_origin_snap);\n\t*dsp = ds;\n\n\treturn (0);\n}\n\nint\ndsl_dataset_create_key_mapping(dsl_dataset_t *ds)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\n\tif (dd->dd_crypto_obj == 0)\n\t\treturn (0);\n\n\treturn (spa_keystore_create_mapping(dd->dd_pool->dp_spa,\n\t    ds, ds, &ds->ds_key_mapping));\n}\n\nint\ndsl_dataset_hold_obj_flags(dsl_pool_t *dp, uint64_t dsobj,\n    ds_hold_flags_t flags, const void *tag, dsl_dataset_t **dsp)\n{\n\tint err;\n\n\terr = dsl_dataset_hold_obj(dp, dsobj, tag, dsp);\n\tif (err != 0)\n\t\treturn (err);\n\n\tASSERT3P(*dsp, !=, NULL);\n\n\tif (flags & DS_HOLD_FLAG_DECRYPT) {\n\t\terr = dsl_dataset_create_key_mapping(*dsp);\n\t\tif (err != 0)\n\t\t\tdsl_dataset_rele(*dsp, tag);\n\t}\n\n\treturn (err);\n}\n\nint\ndsl_dataset_hold_flags(dsl_pool_t *dp, const char *name, ds_hold_flags_t flags,\n    const void *tag, dsl_dataset_t **dsp)\n{\n\tdsl_dir_t *dd;\n\tconst char *snapname;\n\tuint64_t obj;\n\tint err = 0;\n\tdsl_dataset_t *ds;\n\n\terr = dsl_dir_hold(dp, name, FTAG, &dd, &snapname);\n\tif (err != 0)\n\t\treturn (err);\n\n\tASSERT(dsl_pool_config_held(dp));\n\tobj = dsl_dir_phys(dd)->dd_head_dataset_obj;\n\tif (obj != 0)\n\t\terr = dsl_dataset_hold_obj_flags(dp, obj, flags, tag, &ds);\n\telse\n\t\terr = SET_ERROR(ENOENT);\n\n\t \n\tif (err == 0 && snapname != NULL) {\n\t\tdsl_dataset_t *snap_ds;\n\n\t\tif (*snapname++ != '@') {\n\t\t\tdsl_dataset_rele_flags(ds, flags, tag);\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\n\t\tdprintf(\"looking for snapshot '%s'\\n\", snapname);\n\t\terr = dsl_dataset_snap_lookup(ds, snapname, &obj);\n\t\tif (err == 0) {\n\t\t\terr = dsl_dataset_hold_obj_flags(dp, obj, flags, tag,\n\t\t\t    &snap_ds);\n\t\t}\n\t\tdsl_dataset_rele_flags(ds, flags, tag);\n\n\t\tif (err == 0) {\n\t\t\tmutex_enter(&snap_ds->ds_lock);\n\t\t\tif (snap_ds->ds_snapname[0] == 0)\n\t\t\t\t(void) strlcpy(snap_ds->ds_snapname, snapname,\n\t\t\t\t    sizeof (snap_ds->ds_snapname));\n\t\t\tmutex_exit(&snap_ds->ds_lock);\n\t\t\tds = snap_ds;\n\t\t}\n\t}\n\tif (err == 0)\n\t\t*dsp = ds;\n\tdsl_dir_rele(dd, FTAG);\n\treturn (err);\n}\n\nint\ndsl_dataset_hold(dsl_pool_t *dp, const char *name, const void *tag,\n    dsl_dataset_t **dsp)\n{\n\treturn (dsl_dataset_hold_flags(dp, name, 0, tag, dsp));\n}\n\nstatic int\ndsl_dataset_own_obj_impl(dsl_pool_t *dp, uint64_t dsobj, ds_hold_flags_t flags,\n    const void *tag, boolean_t override, dsl_dataset_t **dsp)\n{\n\tint err = dsl_dataset_hold_obj_flags(dp, dsobj, flags, tag, dsp);\n\tif (err != 0)\n\t\treturn (err);\n\tif (!dsl_dataset_tryown(*dsp, tag, override)) {\n\t\tdsl_dataset_rele_flags(*dsp, flags, tag);\n\t\t*dsp = NULL;\n\t\treturn (SET_ERROR(EBUSY));\n\t}\n\treturn (0);\n}\n\n\nint\ndsl_dataset_own_obj(dsl_pool_t *dp, uint64_t dsobj, ds_hold_flags_t flags,\n    const void *tag, dsl_dataset_t **dsp)\n{\n\treturn (dsl_dataset_own_obj_impl(dp, dsobj, flags, tag, B_FALSE, dsp));\n}\n\nint\ndsl_dataset_own_obj_force(dsl_pool_t *dp, uint64_t dsobj,\n    ds_hold_flags_t flags, const void *tag, dsl_dataset_t **dsp)\n{\n\treturn (dsl_dataset_own_obj_impl(dp, dsobj, flags, tag, B_TRUE, dsp));\n}\n\nstatic int\ndsl_dataset_own_impl(dsl_pool_t *dp, const char *name, ds_hold_flags_t flags,\n    const void *tag, boolean_t override, dsl_dataset_t **dsp)\n{\n\tint err = dsl_dataset_hold_flags(dp, name, flags, tag, dsp);\n\tif (err != 0)\n\t\treturn (err);\n\tif (!dsl_dataset_tryown(*dsp, tag, override)) {\n\t\tdsl_dataset_rele_flags(*dsp, flags, tag);\n\t\treturn (SET_ERROR(EBUSY));\n\t}\n\treturn (0);\n}\n\nint\ndsl_dataset_own_force(dsl_pool_t *dp, const char *name, ds_hold_flags_t flags,\n    const void *tag, dsl_dataset_t **dsp)\n{\n\treturn (dsl_dataset_own_impl(dp, name, flags, tag, B_TRUE, dsp));\n}\n\nint\ndsl_dataset_own(dsl_pool_t *dp, const char *name, ds_hold_flags_t flags,\n    const void *tag, dsl_dataset_t **dsp)\n{\n\treturn (dsl_dataset_own_impl(dp, name, flags, tag, B_FALSE, dsp));\n}\n\n \nvoid\ndsl_dataset_long_hold(dsl_dataset_t *ds, const void *tag)\n{\n\tASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));\n\t(void) zfs_refcount_add(&ds->ds_longholds, tag);\n}\n\nvoid\ndsl_dataset_long_rele(dsl_dataset_t *ds, const void *tag)\n{\n\t(void) zfs_refcount_remove(&ds->ds_longholds, tag);\n}\n\n \nboolean_t\ndsl_dataset_long_held(dsl_dataset_t *ds)\n{\n\treturn (!zfs_refcount_is_zero(&ds->ds_longholds));\n}\n\nvoid\ndsl_dataset_name(dsl_dataset_t *ds, char *name)\n{\n\tif (ds == NULL) {\n\t\t(void) strlcpy(name, \"mos\", ZFS_MAX_DATASET_NAME_LEN);\n\t} else {\n\t\tdsl_dir_name(ds->ds_dir, name);\n\t\tVERIFY0(dsl_dataset_get_snapname(ds));\n\t\tif (ds->ds_snapname[0]) {\n\t\t\tVERIFY3U(strlcat(name, \"@\", ZFS_MAX_DATASET_NAME_LEN),\n\t\t\t    <, ZFS_MAX_DATASET_NAME_LEN);\n\t\t\t \n\t\t\tif (!MUTEX_HELD(&ds->ds_lock)) {\n\t\t\t\tmutex_enter(&ds->ds_lock);\n\t\t\t\tVERIFY3U(strlcat(name, ds->ds_snapname,\n\t\t\t\t    ZFS_MAX_DATASET_NAME_LEN), <,\n\t\t\t\t    ZFS_MAX_DATASET_NAME_LEN);\n\t\t\t\tmutex_exit(&ds->ds_lock);\n\t\t\t} else {\n\t\t\t\tVERIFY3U(strlcat(name, ds->ds_snapname,\n\t\t\t\t    ZFS_MAX_DATASET_NAME_LEN), <,\n\t\t\t\t    ZFS_MAX_DATASET_NAME_LEN);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\ndsl_dataset_namelen(dsl_dataset_t *ds)\n{\n\tVERIFY0(dsl_dataset_get_snapname(ds));\n\tmutex_enter(&ds->ds_lock);\n\tint len = strlen(ds->ds_snapname);\n\tmutex_exit(&ds->ds_lock);\n\t \n\tif (len > 0)\n\t\tlen++;\n\tlen += dsl_dir_namelen(ds->ds_dir);\n\treturn (len);\n}\n\nvoid\ndsl_dataset_rele(dsl_dataset_t *ds, const void *tag)\n{\n\tdmu_buf_rele(ds->ds_dbuf, tag);\n}\n\nvoid\ndsl_dataset_remove_key_mapping(dsl_dataset_t *ds)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\n\tif (dd == NULL || dd->dd_crypto_obj == 0)\n\t\treturn;\n\n\t(void) spa_keystore_remove_mapping(dd->dd_pool->dp_spa,\n\t    ds->ds_object, ds);\n}\n\nvoid\ndsl_dataset_rele_flags(dsl_dataset_t *ds, ds_hold_flags_t flags,\n    const void *tag)\n{\n\tif (flags & DS_HOLD_FLAG_DECRYPT)\n\t\tdsl_dataset_remove_key_mapping(ds);\n\n\tdsl_dataset_rele(ds, tag);\n}\n\nvoid\ndsl_dataset_disown(dsl_dataset_t *ds, ds_hold_flags_t flags, const void *tag)\n{\n\tASSERT3P(ds->ds_owner, ==, tag);\n\tASSERT(ds->ds_dbuf != NULL);\n\n\tmutex_enter(&ds->ds_lock);\n\tds->ds_owner = NULL;\n\tmutex_exit(&ds->ds_lock);\n\tdsl_dataset_long_rele(ds, tag);\n\tdsl_dataset_rele_flags(ds, flags, tag);\n}\n\nboolean_t\ndsl_dataset_tryown(dsl_dataset_t *ds, const void *tag, boolean_t override)\n{\n\tboolean_t gotit = FALSE;\n\n\tASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));\n\tmutex_enter(&ds->ds_lock);\n\tif (ds->ds_owner == NULL && (override || !(DS_IS_INCONSISTENT(ds) ||\n\t    (dsl_dataset_feature_is_active(ds,\n\t    SPA_FEATURE_REDACTED_DATASETS) &&\n\t    !zfs_allow_redacted_dataset_mount)))) {\n\t\tds->ds_owner = tag;\n\t\tdsl_dataset_long_hold(ds, tag);\n\t\tgotit = TRUE;\n\t}\n\tmutex_exit(&ds->ds_lock);\n\treturn (gotit);\n}\n\nboolean_t\ndsl_dataset_has_owner(dsl_dataset_t *ds)\n{\n\tboolean_t rv;\n\tmutex_enter(&ds->ds_lock);\n\trv = (ds->ds_owner != NULL);\n\tmutex_exit(&ds->ds_lock);\n\treturn (rv);\n}\n\nstatic boolean_t\nzfeature_active(spa_feature_t f, void *arg)\n{\n\tswitch (spa_feature_table[f].fi_type) {\n\tcase ZFEATURE_TYPE_BOOLEAN: {\n\t\tboolean_t val = (boolean_t)(uintptr_t)arg;\n\t\tASSERT(val == B_FALSE || val == B_TRUE);\n\t\treturn (val);\n\t}\n\tcase ZFEATURE_TYPE_UINT64_ARRAY:\n\t\t \n\t\treturn (arg != NULL);\n\tdefault:\n\t\tpanic(\"Invalid zfeature type %d\", spa_feature_table[f].fi_type);\n\t\treturn (B_FALSE);\n\t}\n}\n\nboolean_t\ndsl_dataset_feature_is_active(dsl_dataset_t *ds, spa_feature_t f)\n{\n\treturn (zfeature_active(f, ds->ds_feature[f]));\n}\n\n \nboolean_t\ndsl_dataset_get_uint64_array_feature(dsl_dataset_t *ds, spa_feature_t f,\n    uint64_t *outlength, uint64_t **outp)\n{\n\tVERIFY(spa_feature_table[f].fi_type & ZFEATURE_TYPE_UINT64_ARRAY);\n\tif (!dsl_dataset_feature_is_active(ds, f)) {\n\t\treturn (B_FALSE);\n\t}\n\tstruct feature_type_uint64_array_arg *ftuaa = ds->ds_feature[f];\n\t*outp = ftuaa->array;\n\t*outlength = ftuaa->length;\n\treturn (B_TRUE);\n}\n\nvoid\ndsl_dataset_activate_feature(uint64_t dsobj, spa_feature_t f, void *arg,\n    dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tobjset_t *mos = dmu_tx_pool(tx)->dp_meta_objset;\n\tuint64_t zero = 0;\n\n\tVERIFY(spa_feature_table[f].fi_flags & ZFEATURE_FLAG_PER_DATASET);\n\n\tspa_feature_incr(spa, f, tx);\n\tdmu_object_zapify(mos, dsobj, DMU_OT_DSL_DATASET, tx);\n\n\tswitch (spa_feature_table[f].fi_type) {\n\tcase ZFEATURE_TYPE_BOOLEAN:\n\t\tASSERT3S((boolean_t)(uintptr_t)arg, ==, B_TRUE);\n\t\tVERIFY0(zap_add(mos, dsobj, spa_feature_table[f].fi_guid,\n\t\t    sizeof (zero), 1, &zero, tx));\n\t\tbreak;\n\tcase ZFEATURE_TYPE_UINT64_ARRAY:\n\t{\n\t\tstruct feature_type_uint64_array_arg *ftuaa = arg;\n\t\tVERIFY0(zap_add(mos, dsobj, spa_feature_table[f].fi_guid,\n\t\t    sizeof (uint64_t), ftuaa->length, ftuaa->array, tx));\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpanic(\"Invalid zfeature type %d\", spa_feature_table[f].fi_type);\n\t}\n}\n\nstatic void\ndsl_dataset_deactivate_feature_impl(dsl_dataset_t *ds, spa_feature_t f,\n    dmu_tx_t *tx)\n{\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tobjset_t *mos = dmu_tx_pool(tx)->dp_meta_objset;\n\tuint64_t dsobj = ds->ds_object;\n\n\tVERIFY(spa_feature_table[f].fi_flags & ZFEATURE_FLAG_PER_DATASET);\n\n\tVERIFY0(zap_remove(mos, dsobj, spa_feature_table[f].fi_guid, tx));\n\tspa_feature_decr(spa, f, tx);\n\tds->ds_feature[f] = NULL;\n}\n\nvoid\ndsl_dataset_deactivate_feature(dsl_dataset_t *ds, spa_feature_t f, dmu_tx_t *tx)\n{\n\tunload_zfeature(ds, f);\n\tdsl_dataset_deactivate_feature_impl(ds, f, tx);\n}\n\nuint64_t\ndsl_dataset_create_sync_dd(dsl_dir_t *dd, dsl_dataset_t *origin,\n    dsl_crypto_params_t *dcp, uint64_t flags, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dd->dd_pool;\n\tdmu_buf_t *dbuf;\n\tdsl_dataset_phys_t *dsphys;\n\tuint64_t dsobj;\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tif (origin == NULL)\n\t\torigin = dp->dp_origin_snap;\n\n\tASSERT(origin == NULL || origin->ds_dir->dd_pool == dp);\n\tASSERT(origin == NULL || dsl_dataset_phys(origin)->ds_num_children > 0);\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dsl_dir_phys(dd)->dd_head_dataset_obj == 0);\n\n\tdsobj = dmu_object_alloc(mos, DMU_OT_DSL_DATASET, 0,\n\t    DMU_OT_DSL_DATASET, sizeof (dsl_dataset_phys_t), tx);\n\tVERIFY0(dmu_bonus_hold(mos, dsobj, FTAG, &dbuf));\n\tdmu_buf_will_dirty(dbuf, tx);\n\tdsphys = dbuf->db_data;\n\tmemset(dsphys, 0, sizeof (dsl_dataset_phys_t));\n\tdsphys->ds_dir_obj = dd->dd_object;\n\tdsphys->ds_flags = flags;\n\tdsphys->ds_fsid_guid = unique_create();\n\t(void) random_get_pseudo_bytes((void*)&dsphys->ds_guid,\n\t    sizeof (dsphys->ds_guid));\n\tdsphys->ds_snapnames_zapobj =\n\t    zap_create_norm(mos, U8_TEXTPREP_TOUPPER, DMU_OT_DSL_DS_SNAP_MAP,\n\t    DMU_OT_NONE, 0, tx);\n\tdsphys->ds_creation_time = gethrestime_sec();\n\tdsphys->ds_creation_txg = tx->tx_txg == TXG_INITIAL ? 1 : tx->tx_txg;\n\n\tif (origin == NULL) {\n\t\tdsphys->ds_deadlist_obj = dsl_deadlist_alloc(mos, tx);\n\t} else {\n\t\tdsl_dataset_t *ohds;  \n\n\t\tdsphys->ds_prev_snap_obj = origin->ds_object;\n\t\tdsphys->ds_prev_snap_txg =\n\t\t    dsl_dataset_phys(origin)->ds_creation_txg;\n\t\tdsphys->ds_referenced_bytes =\n\t\t    dsl_dataset_phys(origin)->ds_referenced_bytes;\n\t\tdsphys->ds_compressed_bytes =\n\t\t    dsl_dataset_phys(origin)->ds_compressed_bytes;\n\t\tdsphys->ds_uncompressed_bytes =\n\t\t    dsl_dataset_phys(origin)->ds_uncompressed_bytes;\n\t\trrw_enter(&origin->ds_bp_rwlock, RW_READER, FTAG);\n\t\tdsphys->ds_bp = dsl_dataset_phys(origin)->ds_bp;\n\t\trrw_exit(&origin->ds_bp_rwlock, FTAG);\n\n\t\t \n\t\tdsphys->ds_flags |= dsl_dataset_phys(origin)->ds_flags &\n\t\t    (DS_FLAG_INCONSISTENT | DS_FLAG_CI_DATASET);\n\n\t\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\t\tif (zfeature_active(f, origin->ds_feature[f])) {\n\t\t\t\tdsl_dataset_activate_feature(dsobj, f,\n\t\t\t\t    origin->ds_feature[f], tx);\n\t\t\t}\n\t\t}\n\n\t\tdmu_buf_will_dirty(origin->ds_dbuf, tx);\n\t\tdsl_dataset_phys(origin)->ds_num_children++;\n\n\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t    dsl_dir_phys(origin->ds_dir)->dd_head_dataset_obj,\n\t\t    FTAG, &ohds));\n\t\tdsphys->ds_deadlist_obj = dsl_deadlist_clone(&ohds->ds_deadlist,\n\t\t    dsphys->ds_prev_snap_txg, dsphys->ds_prev_snap_obj, tx);\n\t\tdsl_dataset_rele(ohds, FTAG);\n\n\t\tif (spa_version(dp->dp_spa) >= SPA_VERSION_NEXT_CLONES) {\n\t\t\tif (dsl_dataset_phys(origin)->ds_next_clones_obj == 0) {\n\t\t\t\tdsl_dataset_phys(origin)->ds_next_clones_obj =\n\t\t\t\t    zap_create(mos,\n\t\t\t\t    DMU_OT_NEXT_CLONES, DMU_OT_NONE, 0, tx);\n\t\t\t}\n\t\t\tVERIFY0(zap_add_int(mos,\n\t\t\t    dsl_dataset_phys(origin)->ds_next_clones_obj,\n\t\t\t    dsobj, tx));\n\t\t}\n\n\t\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\t\tdsl_dir_phys(dd)->dd_origin_obj = origin->ds_object;\n\t\tif (spa_version(dp->dp_spa) >= SPA_VERSION_DIR_CLONES) {\n\t\t\tif (dsl_dir_phys(origin->ds_dir)->dd_clones == 0) {\n\t\t\t\tdmu_buf_will_dirty(origin->ds_dir->dd_dbuf, tx);\n\t\t\t\tdsl_dir_phys(origin->ds_dir)->dd_clones =\n\t\t\t\t    zap_create(mos,\n\t\t\t\t    DMU_OT_DSL_CLONES, DMU_OT_NONE, 0, tx);\n\t\t\t}\n\t\t\tVERIFY0(zap_add_int(mos,\n\t\t\t    dsl_dir_phys(origin->ds_dir)->dd_clones,\n\t\t\t    dsobj, tx));\n\t\t}\n\t}\n\n\t \n\tdsl_dataset_create_crypt_sync(dsobj, dd, origin, dcp, tx);\n\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_UNIQUE_ACCURATE)\n\t\tdsphys->ds_flags |= DS_FLAG_UNIQUE_ACCURATE;\n\n\tdmu_buf_rele(dbuf, FTAG);\n\n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\tdsl_dir_phys(dd)->dd_head_dataset_obj = dsobj;\n\n\treturn (dsobj);\n}\n\nstatic void\ndsl_dataset_zero_zil(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tobjset_t *os;\n\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tif (memcmp(&os->os_zil_header, &zero_zil, sizeof (zero_zil)) != 0) {\n\t\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\t\tzio_t *zio;\n\n\t\tmemset(&os->os_zil_header, 0, sizeof (os->os_zil_header));\n\t\tif (os->os_encrypted)\n\t\t\tos->os_next_write_raw[tx->tx_txg & TXG_MASK] = B_TRUE;\n\n\t\tzio = zio_root(dp->dp_spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\t\tdsl_dataset_sync(ds, zio, tx);\n\t\tVERIFY0(zio_wait(zio));\n\t\tdsl_dataset_sync_done(ds, tx);\n\t}\n}\n\nuint64_t\ndsl_dataset_create_sync(dsl_dir_t *pdd, const char *lastname,\n    dsl_dataset_t *origin, uint64_t flags, cred_t *cr,\n    dsl_crypto_params_t *dcp, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = pdd->dd_pool;\n\tuint64_t dsobj, ddobj;\n\tdsl_dir_t *dd;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(lastname[0] != '@');\n\t \n\tif (origin != NULL)\n\t\tASSERT3P(origin, !=, dp->dp_origin_snap);\n\n\tddobj = dsl_dir_create_sync(dp, pdd, lastname, tx);\n\tVERIFY0(dsl_dir_hold_obj(dp, ddobj, lastname, FTAG, &dd));\n\n\tdsobj = dsl_dataset_create_sync_dd(dd, origin, dcp,\n\t    flags & ~DS_CREATE_FLAG_NODIRTY, tx);\n\n\tdsl_deleg_set_create_perms(dd, tx, cr);\n\n\t \n\tif (origin != NULL &&\n\t    spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_LIVELIST)) {\n\t\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\t\tdsl_dir_zapify(dd, tx);\n\t\tuint64_t obj = dsl_deadlist_alloc(mos, tx);\n\t\tVERIFY0(zap_add(mos, dd->dd_object, DD_FIELD_LIVELIST,\n\t\t    sizeof (uint64_t), 1, &obj, tx));\n\t\tspa_feature_incr(dp->dp_spa, SPA_FEATURE_LIVELIST, tx);\n\t}\n\n\t \n\tif (spa_feature_is_active(dp->dp_spa, SPA_FEATURE_FS_SS_LIMIT)) {\n\t\tuint64_t cnt = 0;\n\t\tobjset_t *os = dd->dd_pool->dp_meta_objset;\n\n\t\tdsl_dir_zapify(dd, tx);\n\t\tVERIFY0(zap_add(os, dd->dd_object, DD_FIELD_FILESYSTEM_COUNT,\n\t\t    sizeof (cnt), 1, &cnt, tx));\n\t\tVERIFY0(zap_add(os, dd->dd_object, DD_FIELD_SNAPSHOT_COUNT,\n\t\t    sizeof (cnt), 1, &cnt, tx));\n\t}\n\n\tdsl_dir_rele(dd, FTAG);\n\n\t \n\tif (origin != NULL && !(flags & DS_CREATE_FLAG_NODIRTY)) {\n\t\tdsl_dataset_t *ds;\n\n\t\tVERIFY0(dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds));\n\t\tdsl_dataset_zero_zil(ds, tx);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\n\treturn (dsobj);\n}\n\n \nvoid\ndsl_dataset_recalc_head_uniq(dsl_dataset_t *ds)\n{\n\tuint64_t mrs_used;\n\tuint64_t dlused, dlcomp, dluncomp;\n\n\tASSERT(!ds->ds_is_snapshot);\n\n\tif (dsl_dataset_phys(ds)->ds_prev_snap_obj != 0)\n\t\tmrs_used = dsl_dataset_phys(ds->ds_prev)->ds_referenced_bytes;\n\telse\n\t\tmrs_used = 0;\n\n\tdsl_deadlist_space(&ds->ds_deadlist, &dlused, &dlcomp, &dluncomp);\n\n\tASSERT3U(dlused, <=, mrs_used);\n\tdsl_dataset_phys(ds)->ds_unique_bytes =\n\t    dsl_dataset_phys(ds)->ds_referenced_bytes - (mrs_used - dlused);\n\n\tif (spa_version(ds->ds_dir->dd_pool->dp_spa) >=\n\t    SPA_VERSION_UNIQUE_ACCURATE)\n\t\tdsl_dataset_phys(ds)->ds_flags |= DS_FLAG_UNIQUE_ACCURATE;\n}\n\nvoid\ndsl_dataset_remove_from_next_clones(dsl_dataset_t *ds, uint64_t obj,\n    dmu_tx_t *tx)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tuint64_t count __maybe_unused;\n\tint err;\n\n\tASSERT(dsl_dataset_phys(ds)->ds_num_children >= 2);\n\terr = zap_remove_int(mos, dsl_dataset_phys(ds)->ds_next_clones_obj,\n\t    obj, tx);\n\t \n\tif (err != ENOENT)\n\t\tVERIFY0(err);\n\tASSERT0(zap_count(mos, dsl_dataset_phys(ds)->ds_next_clones_obj,\n\t    &count));\n\tASSERT3U(count, <=, dsl_dataset_phys(ds)->ds_num_children - 2);\n}\n\n\nblkptr_t *\ndsl_dataset_get_blkptr(dsl_dataset_t *ds)\n{\n\treturn (&dsl_dataset_phys(ds)->ds_bp);\n}\n\nspa_t *\ndsl_dataset_get_spa(dsl_dataset_t *ds)\n{\n\treturn (ds->ds_dir->dd_pool->dp_spa);\n}\n\nvoid\ndsl_dataset_dirty(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp;\n\n\tif (ds == NULL)  \n\t\treturn;\n\n\tASSERT(ds->ds_objset != NULL);\n\n\tif (dsl_dataset_phys(ds)->ds_next_snap_obj != 0)\n\t\tpanic(\"dirtying snapshot!\");\n\n\t \n\tASSERT3U(tx->tx_txg, >, dsl_dataset_phys(ds)->ds_prev_snap_txg);\n\n\tdp = ds->ds_dir->dd_pool;\n\tif (txg_list_add(&dp->dp_dirty_datasets, ds, tx->tx_txg)) {\n\t\tobjset_t *os = ds->ds_objset;\n\n\t\t \n\t\tdmu_buf_add_ref(ds->ds_dbuf, ds);\n\n\t\t \n\t\tif (ds->ds_dir->dd_crypto_obj != 0 &&\n\t\t    !os->os_raw_receive &&\n\t\t    !os->os_next_write_raw[tx->tx_txg & TXG_MASK]) {\n\t\t\tASSERT3P(ds->ds_key_mapping, !=, NULL);\n\t\t\tkey_mapping_add_ref(ds->ds_key_mapping, ds);\n\t\t}\n\t}\n}\n\nstatic int\ndsl_dataset_snapshot_reserve_space(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tuint64_t asize;\n\n\tif (!dmu_tx_is_syncing(tx))\n\t\treturn (0);\n\n\t \n\tASSERT(ds->ds_reserved == 0 || DS_UNIQUE_IS_ACCURATE(ds));\n\tasize = MIN(dsl_dataset_phys(ds)->ds_unique_bytes, ds->ds_reserved);\n\tif (asize > dsl_dir_space_available(ds->ds_dir, NULL, 0, TRUE))\n\t\treturn (SET_ERROR(ENOSPC));\n\n\t \n\tif (asize > 0)\n\t\tdsl_dir_willuse_space(ds->ds_dir, asize, tx);\n\n\treturn (0);\n}\n\nint\ndsl_dataset_snapshot_check_impl(dsl_dataset_t *ds, const char *snapname,\n    dmu_tx_t *tx, boolean_t recv, uint64_t cnt, cred_t *cr, proc_t *proc)\n{\n\tint error;\n\tuint64_t value;\n\n\tds->ds_trysnap_txg = tx->tx_txg;\n\n\tif (!dmu_tx_is_syncing(tx))\n\t\treturn (0);\n\n\t \n\tif (dsl_dataset_phys(ds)->ds_prev_snap_txg >= tx->tx_txg)\n\t\treturn (SET_ERROR(EAGAIN));\n\n\t \n\terror = dsl_dataset_snap_lookup(ds, snapname, &value);\n\tif (error == 0)\n\t\treturn (SET_ERROR(EEXIST));\n\tif (error != ENOENT)\n\t\treturn (error);\n\n\t \n\tif (!recv && DS_IS_INCONSISTENT(ds))\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tif (cnt != 0 && cr != NULL) {\n\t\terror = dsl_fs_ss_limit_check(ds->ds_dir, cnt,\n\t\t    ZFS_PROP_SNAPSHOT_LIMIT, NULL, cr, proc);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\terror = dsl_dataset_snapshot_reserve_space(ds, tx);\n\tif (error != 0)\n\t\treturn (error);\n\n\treturn (0);\n}\n\nint\ndsl_dataset_snapshot_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_snapshot_arg_t *ddsa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tnvpair_t *pair;\n\tint rv = 0;\n\n\t \n\tif (dmu_tx_is_syncing(tx)) {\n\t\tchar *nm;\n\t\tnvlist_t *cnt_track = NULL;\n\t\tcnt_track = fnvlist_alloc();\n\n\t\tnm = kmem_alloc(MAXPATHLEN, KM_SLEEP);\n\n\t\t \n\t\tfor (pair = nvlist_next_nvpair(ddsa->ddsa_snaps, NULL);\n\t\t    pair != NULL;\n\t\t    pair = nvlist_next_nvpair(ddsa->ddsa_snaps, pair)) {\n\t\t\tchar *pdelim;\n\t\t\tuint64_t val;\n\n\t\t\t(void) strlcpy(nm, nvpair_name(pair), MAXPATHLEN);\n\t\t\tpdelim = strchr(nm, '@');\n\t\t\tif (pdelim == NULL)\n\t\t\t\tcontinue;\n\t\t\t*pdelim = '\\0';\n\n\t\t\tdo {\n\t\t\t\tif (nvlist_lookup_uint64(cnt_track, nm,\n\t\t\t\t    &val) == 0) {\n\t\t\t\t\t \n\t\t\t\t\tfnvlist_add_uint64(cnt_track, nm,\n\t\t\t\t\t    val + 1);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tfnvlist_add_uint64(cnt_track, nm, 1);\n\t\t\t\t}\n\n\t\t\t\tpdelim = strrchr(nm, '/');\n\t\t\t\tif (pdelim != NULL)\n\t\t\t\t\t*pdelim = '\\0';\n\t\t\t} while (pdelim != NULL);\n\t\t}\n\n\t\tkmem_free(nm, MAXPATHLEN);\n\n\t\t \n\t\tfor (pair = nvlist_next_nvpair(cnt_track, NULL);\n\t\t    pair != NULL; pair = nvlist_next_nvpair(cnt_track, pair)) {\n\t\t\tint error = 0;\n\t\t\tconst char *name;\n\t\t\tuint64_t cnt = 0;\n\t\t\tdsl_dataset_t *ds;\n\n\t\t\tname = nvpair_name(pair);\n\t\t\tcnt = fnvpair_value_uint64(pair);\n\t\t\tASSERT(cnt > 0);\n\n\t\t\terror = dsl_dataset_hold(dp, name, FTAG, &ds);\n\t\t\tif (error == 0) {\n\t\t\t\terror = dsl_fs_ss_limit_check(ds->ds_dir, cnt,\n\t\t\t\t    ZFS_PROP_SNAPSHOT_LIMIT, NULL,\n\t\t\t\t    ddsa->ddsa_cr, ddsa->ddsa_proc);\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t}\n\n\t\t\tif (error != 0) {\n\t\t\t\tif (ddsa->ddsa_errors != NULL)\n\t\t\t\t\tfnvlist_add_int32(ddsa->ddsa_errors,\n\t\t\t\t\t    name, error);\n\t\t\t\trv = error;\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnvlist_free(cnt_track);\n\t}\n\n\tfor (pair = nvlist_next_nvpair(ddsa->ddsa_snaps, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(ddsa->ddsa_snaps, pair)) {\n\t\tint error = 0;\n\t\tdsl_dataset_t *ds;\n\t\tconst char *name, *atp = NULL;\n\t\tchar dsname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\tname = nvpair_name(pair);\n\t\tif (strlen(name) >= ZFS_MAX_DATASET_NAME_LEN)\n\t\t\terror = SET_ERROR(ENAMETOOLONG);\n\t\tif (error == 0) {\n\t\t\tatp = strchr(name, '@');\n\t\t\tif (atp == NULL)\n\t\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tif (error == 0)\n\t\t\t\t(void) strlcpy(dsname, name, atp - name + 1);\n\t\t}\n\t\tif (error == 0)\n\t\t\terror = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\t\tif (error == 0) {\n\t\t\t \n\t\t\terror = dsl_dataset_snapshot_check_impl(ds,\n\t\t\t    atp + 1, tx, B_FALSE, 0, NULL, NULL);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t}\n\n\t\tif (error != 0) {\n\t\t\tif (ddsa->ddsa_errors != NULL) {\n\t\t\t\tfnvlist_add_int32(ddsa->ddsa_errors,\n\t\t\t\t    name, error);\n\t\t\t}\n\t\t\trv = error;\n\t\t}\n\t}\n\n\treturn (rv);\n}\n\nvoid\ndsl_dataset_snapshot_sync_impl(dsl_dataset_t *ds, const char *snapname,\n    dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tdmu_buf_t *dbuf;\n\tdsl_dataset_phys_t *dsphys;\n\tuint64_t dsobj, crtxg;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tobjset_t *os __maybe_unused;\n\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\n\t \n\tASSERT(spa_version(dmu_tx_pool(tx)->dp_spa) >= SPA_VERSION_FAST_SNAP ||\n\t    dmu_objset_from_ds(ds, &os) != 0 ||\n\t    memcmp(&os->os_phys->os_zil_header, &zero_zil,\n\t    sizeof (zero_zil)) == 0);\n\n\t \n\tASSERT(!txg_list_member(&ds->ds_dir->dd_pool->dp_dirty_datasets,\n\t    ds, tx->tx_txg));\n\n\tdsl_fs_ss_count_adjust(ds->ds_dir, 1, DD_FIELD_SNAPSHOT_COUNT, tx);\n\n\t \n\tif (strcmp(snapname, ORIGIN_DIR_NAME) == 0)\n\t\tcrtxg = 1;\n\telse\n\t\tcrtxg = tx->tx_txg;\n\n\tdsobj = dmu_object_alloc(mos, DMU_OT_DSL_DATASET, 0,\n\t    DMU_OT_DSL_DATASET, sizeof (dsl_dataset_phys_t), tx);\n\tVERIFY0(dmu_bonus_hold(mos, dsobj, FTAG, &dbuf));\n\tdmu_buf_will_dirty(dbuf, tx);\n\tdsphys = dbuf->db_data;\n\tmemset(dsphys, 0, sizeof (dsl_dataset_phys_t));\n\tdsphys->ds_dir_obj = ds->ds_dir->dd_object;\n\tdsphys->ds_fsid_guid = unique_create();\n\t(void) random_get_pseudo_bytes((void*)&dsphys->ds_guid,\n\t    sizeof (dsphys->ds_guid));\n\tdsphys->ds_prev_snap_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\tdsphys->ds_prev_snap_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\tdsphys->ds_next_snap_obj = ds->ds_object;\n\tdsphys->ds_num_children = 1;\n\tdsphys->ds_creation_time = gethrestime_sec();\n\tdsphys->ds_creation_txg = crtxg;\n\tdsphys->ds_deadlist_obj = dsl_dataset_phys(ds)->ds_deadlist_obj;\n\tdsphys->ds_referenced_bytes = dsl_dataset_phys(ds)->ds_referenced_bytes;\n\tdsphys->ds_compressed_bytes = dsl_dataset_phys(ds)->ds_compressed_bytes;\n\tdsphys->ds_uncompressed_bytes =\n\t    dsl_dataset_phys(ds)->ds_uncompressed_bytes;\n\tdsphys->ds_flags = dsl_dataset_phys(ds)->ds_flags;\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tdsphys->ds_bp = dsl_dataset_phys(ds)->ds_bp;\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\tdmu_buf_rele(dbuf, FTAG);\n\n\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\tif (zfeature_active(f, ds->ds_feature[f])) {\n\t\t\tdsl_dataset_activate_feature(dsobj, f,\n\t\t\t    ds->ds_feature[f], tx);\n\t\t}\n\t}\n\n\tASSERT3U(ds->ds_prev != 0, ==,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_obj != 0);\n\tif (ds->ds_prev) {\n\t\tuint64_t next_clones_obj =\n\t\t    dsl_dataset_phys(ds->ds_prev)->ds_next_clones_obj;\n\t\tASSERT(dsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj ==\n\t\t    ds->ds_object ||\n\t\t    dsl_dataset_phys(ds->ds_prev)->ds_num_children > 1);\n\t\tif (dsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj ==\n\t\t    ds->ds_object) {\n\t\t\tdmu_buf_will_dirty(ds->ds_prev->ds_dbuf, tx);\n\t\t\tASSERT3U(dsl_dataset_phys(ds)->ds_prev_snap_txg, ==,\n\t\t\t    dsl_dataset_phys(ds->ds_prev)->ds_creation_txg);\n\t\t\tdsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj = dsobj;\n\t\t} else if (next_clones_obj != 0) {\n\t\t\tdsl_dataset_remove_from_next_clones(ds->ds_prev,\n\t\t\t    dsphys->ds_next_snap_obj, tx);\n\t\t\tVERIFY0(zap_add_int(mos,\n\t\t\t    next_clones_obj, dsobj, tx));\n\t\t}\n\t}\n\n\t \n\tif (ds->ds_reserved) {\n\t\tint64_t delta;\n\t\tASSERT(DS_UNIQUE_IS_ACCURATE(ds));\n\t\tdelta = MIN(dsl_dataset_phys(ds)->ds_unique_bytes,\n\t\t    ds->ds_reserved);\n\t\tdsl_dir_diduse_space(ds->ds_dir, DD_USED_REFRSRV,\n\t\t    delta, 0, 0, tx);\n\t}\n\n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tdsl_dataset_phys(ds)->ds_deadlist_obj =\n\t    dsl_deadlist_clone(&ds->ds_deadlist, UINT64_MAX,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, tx);\n\tdsl_deadlist_close(&ds->ds_deadlist);\n\tdsl_deadlist_open(&ds->ds_deadlist, mos,\n\t    dsl_dataset_phys(ds)->ds_deadlist_obj);\n\tdsl_deadlist_add_key(&ds->ds_deadlist,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg, tx);\n\tdsl_bookmark_snapshotted(ds, tx);\n\n\tif (dsl_dataset_remap_deadlist_exists(ds)) {\n\t\tuint64_t remap_deadlist_obj =\n\t\t    dsl_dataset_get_remap_deadlist_object(ds);\n\t\t \n\t\tdsl_dataset_unset_remap_deadlist_object(ds, tx);\n\t\tdsl_deadlist_close(&ds->ds_remap_deadlist);\n\n\t\tdmu_object_zapify(mos, dsobj, DMU_OT_DSL_DATASET, tx);\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_REMAP_DEADLIST,\n\t\t    sizeof (remap_deadlist_obj), 1, &remap_deadlist_obj, tx));\n\t}\n\n\t \n\tif (ds->ds_dir->dd_crypto_obj != 0 &&\n\t    spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_BOOKMARK_V2)) {\n\t\tuint64_t ivset_guid = unique_create();\n\n\t\tdmu_object_zapify(mos, dsobj, DMU_OT_DSL_DATASET, tx);\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_IVSET_GUID,\n\t\t    sizeof (ivset_guid), 1, &ivset_guid, tx));\n\t}\n\n\tASSERT3U(dsl_dataset_phys(ds)->ds_prev_snap_txg, <, tx->tx_txg);\n\tdsl_dataset_phys(ds)->ds_prev_snap_obj = dsobj;\n\tdsl_dataset_phys(ds)->ds_prev_snap_txg = crtxg;\n\tdsl_dataset_phys(ds)->ds_unique_bytes = 0;\n\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_UNIQUE_ACCURATE)\n\t\tdsl_dataset_phys(ds)->ds_flags |= DS_FLAG_UNIQUE_ACCURATE;\n\n\tVERIFY0(zap_add(mos, dsl_dataset_phys(ds)->ds_snapnames_zapobj,\n\t    snapname, 8, 1, &dsobj, tx));\n\n\tif (ds->ds_prev)\n\t\tdsl_dataset_rele(ds->ds_prev, ds);\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, ds, &ds->ds_prev));\n\n\tdsl_scan_ds_snapshotted(ds, tx);\n\n\tdsl_dir_snap_cmtime_update(ds->ds_dir, tx);\n\n\tif (zfs_snapshot_history_enabled)\n\t\tspa_history_log_internal_ds(ds->ds_prev, \"snapshot\", tx, \" \");\n}\n\nvoid\ndsl_dataset_snapshot_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_snapshot_arg_t *ddsa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tnvpair_t *pair;\n\n\tfor (pair = nvlist_next_nvpair(ddsa->ddsa_snaps, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(ddsa->ddsa_snaps, pair)) {\n\t\tdsl_dataset_t *ds;\n\t\tconst char *name, *atp;\n\t\tchar dsname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t\tname = nvpair_name(pair);\n\t\tatp = strchr(name, '@');\n\t\t(void) strlcpy(dsname, name, atp - name + 1);\n\t\tVERIFY0(dsl_dataset_hold(dp, dsname, FTAG, &ds));\n\n\t\tdsl_dataset_snapshot_sync_impl(ds, atp + 1, tx);\n\t\tif (ddsa->ddsa_props != NULL) {\n\t\t\tdsl_props_set_sync_impl(ds->ds_prev,\n\t\t\t    ZPROP_SRC_LOCAL, ddsa->ddsa_props, tx);\n\t\t}\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n}\n\n \nint\ndsl_dataset_snapshot(nvlist_t *snaps, nvlist_t *props, nvlist_t *errors)\n{\n\tdsl_dataset_snapshot_arg_t ddsa;\n\tnvpair_t *pair;\n\tboolean_t needsuspend;\n\tint error;\n\tspa_t *spa;\n\tconst char *firstname;\n\tnvlist_t *suspended = NULL;\n\n\tpair = nvlist_next_nvpair(snaps, NULL);\n\tif (pair == NULL)\n\t\treturn (0);\n\tfirstname = nvpair_name(pair);\n\n\terror = spa_open(firstname, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\tneedsuspend = (spa_version(spa) < SPA_VERSION_FAST_SNAP);\n\tspa_close(spa, FTAG);\n\n\tif (needsuspend) {\n\t\tsuspended = fnvlist_alloc();\n\t\tfor (pair = nvlist_next_nvpair(snaps, NULL); pair != NULL;\n\t\t    pair = nvlist_next_nvpair(snaps, pair)) {\n\t\t\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\tconst char *snapname = nvpair_name(pair);\n\t\t\tconst char *atp;\n\t\t\tvoid *cookie;\n\n\t\t\tatp = strchr(snapname, '@');\n\t\t\tif (atp == NULL) {\n\t\t\t\terror = SET_ERROR(EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(void) strlcpy(fsname, snapname, atp - snapname + 1);\n\n\t\t\terror = zil_suspend(fsname, &cookie);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t\tfnvlist_add_uint64(suspended, fsname,\n\t\t\t    (uintptr_t)cookie);\n\t\t}\n\t}\n\n\tddsa.ddsa_snaps = snaps;\n\tddsa.ddsa_props = props;\n\tddsa.ddsa_errors = errors;\n\tddsa.ddsa_cr = CRED();\n\tddsa.ddsa_proc = curproc;\n\n\tif (error == 0) {\n\t\terror = dsl_sync_task(firstname, dsl_dataset_snapshot_check,\n\t\t    dsl_dataset_snapshot_sync, &ddsa,\n\t\t    fnvlist_num_pairs(snaps) * 3, ZFS_SPACE_CHECK_NORMAL);\n\t}\n\n\tif (suspended != NULL) {\n\t\tfor (pair = nvlist_next_nvpair(suspended, NULL); pair != NULL;\n\t\t    pair = nvlist_next_nvpair(suspended, pair)) {\n\t\t\tzil_resume((void *)(uintptr_t)\n\t\t\t    fnvpair_value_uint64(pair));\n\t\t}\n\t\tfnvlist_free(suspended);\n\t}\n\n\tif (error == 0) {\n\t\tfor (pair = nvlist_next_nvpair(snaps, NULL); pair != NULL;\n\t\t    pair = nvlist_next_nvpair(snaps, pair)) {\n\t\t\tzvol_create_minor(nvpair_name(pair));\n\t\t}\n\t}\n\n\treturn (error);\n}\n\ntypedef struct dsl_dataset_snapshot_tmp_arg {\n\tconst char *ddsta_fsname;\n\tconst char *ddsta_snapname;\n\tminor_t ddsta_cleanup_minor;\n\tconst char *ddsta_htag;\n} dsl_dataset_snapshot_tmp_arg_t;\n\nstatic int\ndsl_dataset_snapshot_tmp_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_snapshot_tmp_arg_t *ddsta = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tint error;\n\n\terror = dsl_dataset_hold(dp, ddsta->ddsta_fsname, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\terror = dsl_dataset_snapshot_check_impl(ds, ddsta->ddsta_snapname,\n\t    tx, B_FALSE, 0, NULL, NULL);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (spa_version(dp->dp_spa) < SPA_VERSION_USERREFS) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terror = dsl_dataset_user_hold_check_one(NULL, ddsta->ddsta_htag,\n\t    B_TRUE, tx);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nstatic void\ndsl_dataset_snapshot_tmp_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_snapshot_tmp_arg_t *ddsta = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds = NULL;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddsta->ddsta_fsname, FTAG, &ds));\n\n\tdsl_dataset_snapshot_sync_impl(ds, ddsta->ddsta_snapname, tx);\n\tdsl_dataset_user_hold_sync_one(ds->ds_prev, ddsta->ddsta_htag,\n\t    ddsta->ddsta_cleanup_minor, gethrestime_sec(), tx);\n\tdsl_destroy_snapshot_sync_impl(ds->ds_prev, B_TRUE, tx);\n\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dataset_snapshot_tmp(const char *fsname, const char *snapname,\n    minor_t cleanup_minor, const char *htag)\n{\n\tdsl_dataset_snapshot_tmp_arg_t ddsta;\n\tint error;\n\tspa_t *spa;\n\tboolean_t needsuspend;\n\tvoid *cookie;\n\n\tddsta.ddsta_fsname = fsname;\n\tddsta.ddsta_snapname = snapname;\n\tddsta.ddsta_cleanup_minor = cleanup_minor;\n\tddsta.ddsta_htag = htag;\n\n\terror = spa_open(fsname, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\tneedsuspend = (spa_version(spa) < SPA_VERSION_FAST_SNAP);\n\tspa_close(spa, FTAG);\n\n\tif (needsuspend) {\n\t\terror = zil_suspend(fsname, &cookie);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\terror = dsl_sync_task(fsname, dsl_dataset_snapshot_tmp_check,\n\t    dsl_dataset_snapshot_tmp_sync, &ddsta, 3, ZFS_SPACE_CHECK_RESERVED);\n\n\tif (needsuspend)\n\t\tzil_resume(cookie);\n\treturn (error);\n}\n\nvoid\ndsl_dataset_sync(dsl_dataset_t *ds, zio_t *zio, dmu_tx_t *tx)\n{\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(ds->ds_objset != NULL);\n\tASSERT(dsl_dataset_phys(ds)->ds_next_snap_obj == 0);\n\n\t \n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tdsl_dataset_phys(ds)->ds_fsid_guid = ds->ds_fsid_guid;\n\n\tif (ds->ds_resume_bytes[tx->tx_txg & TXG_MASK] != 0) {\n\t\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset,\n\t\t    ds->ds_object, DS_FIELD_RESUME_OBJECT, 8, 1,\n\t\t    &ds->ds_resume_object[tx->tx_txg & TXG_MASK], tx));\n\t\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset,\n\t\t    ds->ds_object, DS_FIELD_RESUME_OFFSET, 8, 1,\n\t\t    &ds->ds_resume_offset[tx->tx_txg & TXG_MASK], tx));\n\t\tVERIFY0(zap_update(tx->tx_pool->dp_meta_objset,\n\t\t    ds->ds_object, DS_FIELD_RESUME_BYTES, 8, 1,\n\t\t    &ds->ds_resume_bytes[tx->tx_txg & TXG_MASK], tx));\n\t\tds->ds_resume_object[tx->tx_txg & TXG_MASK] = 0;\n\t\tds->ds_resume_offset[tx->tx_txg & TXG_MASK] = 0;\n\t\tds->ds_resume_bytes[tx->tx_txg & TXG_MASK] = 0;\n\t}\n\n\tdmu_objset_sync(ds->ds_objset, zio, tx);\n}\n\n \nstatic boolean_t\ndsl_livelist_should_disable(dsl_dataset_t *ds)\n{\n\tuint64_t used, referenced;\n\tint percent_shared;\n\n\tused = dsl_dir_get_usedds(ds->ds_dir);\n\treferenced = dsl_get_referenced(ds);\n\tif (referenced == 0)\n\t\treturn (B_FALSE);\n\tpercent_shared = (100 * (referenced - used)) / referenced;\n\tif (percent_shared <= zfs_livelist_min_percent_shared)\n\t\treturn (B_TRUE);\n\treturn (B_FALSE);\n}\n\n \nstatic boolean_t\ndsl_livelist_should_condense(dsl_deadlist_entry_t *first,\n    dsl_deadlist_entry_t *next)\n{\n\tuint64_t total_free = first->dle_bpobj.bpo_phys->bpo_num_freed +\n\t    next->dle_bpobj.bpo_phys->bpo_num_freed;\n\tuint64_t total_entries = first->dle_bpobj.bpo_phys->bpo_num_blkptrs +\n\t    next->dle_bpobj.bpo_phys->bpo_num_blkptrs;\n\tif ((total_entries - (2 * total_free)) < zfs_livelist_max_entries)\n\t\treturn (B_TRUE);\n\treturn (B_FALSE);\n}\n\ntypedef struct try_condense_arg {\n\tspa_t *spa;\n\tdsl_dataset_t *ds;\n} try_condense_arg_t;\n\n \nstatic int\ndsl_livelist_try_condense(void *arg, dsl_deadlist_entry_t *first)\n{\n\ttry_condense_arg_t *tca = arg;\n\tspa_t *spa = tca->spa;\n\tdsl_dataset_t *ds = tca->ds;\n\tdsl_deadlist_t *ll = &ds->ds_dir->dd_livelist;\n\tdsl_deadlist_entry_t *next;\n\n\t \n\tif (spa->spa_livelist_condense_zthr == NULL)\n\t\treturn (1);\n\n\t \n\tif (spa->spa_to_condense.ds != NULL)\n\t\treturn (1);\n\n\tnext = AVL_NEXT(&ll->dl_tree, &first->dle_node);\n\t \n\tif (next == NULL)\n\t\treturn (1);\n\n\t \n\tif (AVL_NEXT(&ll->dl_tree, &next->dle_node) == NULL)\n\t\treturn (1);\n\n\t \n\tif (!dsl_livelist_should_condense(first, next))\n\t\treturn (0);\n\n\t \n\tdmu_buf_add_ref(ds->ds_dbuf, spa);\n\n\tspa->spa_to_condense.ds = ds;\n\tspa->spa_to_condense.first = first;\n\tspa->spa_to_condense.next = next;\n\tspa->spa_to_condense.syncing = B_FALSE;\n\tspa->spa_to_condense.cancelled = B_FALSE;\n\n\tzthr_wakeup(spa->spa_livelist_condense_zthr);\n\treturn (1);\n}\n\nstatic void\ndsl_flush_pending_livelist(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\tspa_t *spa = ds->ds_dir->dd_pool->dp_spa;\n\tdsl_deadlist_entry_t *last = dsl_deadlist_last(&dd->dd_livelist);\n\n\t \n\tif (last == NULL) {\n\t\t \n\t\tdsl_deadlist_add_key(&dd->dd_livelist,\n\t\t    tx->tx_txg - 1, tx);\n\t} else if (spa_sync_pass(spa) == 1) {\n\t\t \n\t\tbpobj_t bpobj = last->dle_bpobj;\n\t\tuint64_t all = bpobj.bpo_phys->bpo_num_blkptrs;\n\t\tuint64_t free = bpobj.bpo_phys->bpo_num_freed;\n\t\tuint64_t alloc = all - free;\n\t\tif (alloc > zfs_livelist_max_entries) {\n\t\t\tdsl_deadlist_add_key(&dd->dd_livelist,\n\t\t\t    tx->tx_txg - 1, tx);\n\t\t}\n\t}\n\n\t \n\tbplist_iterate(&dd->dd_pending_allocs,\n\t    dsl_deadlist_insert_alloc_cb, &dd->dd_livelist, tx);\n\tbplist_iterate(&dd->dd_pending_frees,\n\t    dsl_deadlist_insert_free_cb, &dd->dd_livelist, tx);\n\n\t \n\ttry_condense_arg_t arg = {\n\t    .spa = spa,\n\t    .ds = ds\n\t};\n\tdsl_deadlist_iterate(&dd->dd_livelist, dsl_livelist_try_condense,\n\t    &arg);\n}\n\nvoid\ndsl_dataset_sync_done(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tobjset_t *os = ds->ds_objset;\n\n\tbplist_iterate(&ds->ds_pending_deadlist,\n\t    dsl_deadlist_insert_alloc_cb, &ds->ds_deadlist, tx);\n\n\tif (dsl_deadlist_is_open(&ds->ds_dir->dd_livelist)) {\n\t\tdsl_flush_pending_livelist(ds, tx);\n\t\tif (dsl_livelist_should_disable(ds)) {\n\t\t\tdsl_dir_remove_livelist(ds->ds_dir, tx, B_TRUE);\n\t\t}\n\t}\n\n\tdsl_bookmark_sync_done(ds, tx);\n\n\tmultilist_destroy(&os->os_synced_dnodes);\n\n\tif (os->os_encrypted)\n\t\tos->os_next_write_raw[tx->tx_txg & TXG_MASK] = B_FALSE;\n\telse\n\t\tASSERT0(os->os_next_write_raw[tx->tx_txg & TXG_MASK]);\n\n\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\tif (zfeature_active(f,\n\t\t    ds->ds_feature_activation[f])) {\n\t\t\tif (zfeature_active(f, ds->ds_feature[f]))\n\t\t\t\tcontinue;\n\t\t\tdsl_dataset_activate_feature(ds->ds_object, f,\n\t\t\t    ds->ds_feature_activation[f], tx);\n\t\t\tds->ds_feature[f] = ds->ds_feature_activation[f];\n\t\t}\n\t}\n\n\tASSERT(!dmu_objset_is_dirty(os, dmu_tx_get_txg(tx)));\n}\n\nint\nget_clones_stat_impl(dsl_dataset_t *ds, nvlist_t *val)\n{\n\tuint64_t count = 0;\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\n\tASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));\n\n\t \n\tif (dsl_dataset_phys(ds)->ds_next_clones_obj != 0) {\n\t\tVERIFY0(zap_count(mos, dsl_dataset_phys(ds)->ds_next_clones_obj,\n\t\t    &count));\n\t}\n\tif (count != dsl_dataset_phys(ds)->ds_num_children - 1) {\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\tfor (zap_cursor_init(&zc, mos,\n\t    dsl_dataset_phys(ds)->ds_next_clones_obj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tdsl_dataset_t *clone;\n\t\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\t\tVERIFY0(dsl_dataset_hold_obj(ds->ds_dir->dd_pool,\n\t\t    za.za_first_integer, FTAG, &clone));\n\t\tdsl_dir_name(clone->ds_dir, buf);\n\t\tfnvlist_add_boolean(val, buf);\n\t\tdsl_dataset_rele(clone, FTAG);\n\t}\n\tzap_cursor_fini(&zc);\n\treturn (0);\n}\n\nvoid\nget_clones_stat(dsl_dataset_t *ds, nvlist_t *nv)\n{\n\tnvlist_t *propval = fnvlist_alloc();\n\tnvlist_t *val = fnvlist_alloc();\n\n\tif (get_clones_stat_impl(ds, val) == 0) {\n\t\tfnvlist_add_nvlist(propval, ZPROP_VALUE, val);\n\t\tfnvlist_add_nvlist(nv, zfs_prop_to_name(ZFS_PROP_CLONES),\n\t\t    propval);\n\t}\n\n\tnvlist_free(val);\n\tnvlist_free(propval);\n}\n\nstatic char *\nget_receive_resume_token_impl(dsl_dataset_t *ds)\n{\n\tif (!dsl_dataset_has_resume_receive_state(ds))\n\t\treturn (NULL);\n\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tchar *str;\n\tvoid *packed;\n\tuint8_t *compressed;\n\tuint64_t val;\n\tnvlist_t *token_nv = fnvlist_alloc();\n\tsize_t packed_size, compressed_size;\n\n\tif (zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_FROMGUID, sizeof (val), 1, &val) == 0) {\n\t\tfnvlist_add_uint64(token_nv, \"fromguid\", val);\n\t}\n\tif (zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_OBJECT, sizeof (val), 1, &val) == 0) {\n\t\tfnvlist_add_uint64(token_nv, \"object\", val);\n\t}\n\tif (zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_OFFSET, sizeof (val), 1, &val) == 0) {\n\t\tfnvlist_add_uint64(token_nv, \"offset\", val);\n\t}\n\tif (zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_BYTES, sizeof (val), 1, &val) == 0) {\n\t\tfnvlist_add_uint64(token_nv, \"bytes\", val);\n\t}\n\tif (zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_TOGUID, sizeof (val), 1, &val) == 0) {\n\t\tfnvlist_add_uint64(token_nv, \"toguid\", val);\n\t}\n\tchar buf[MAXNAMELEN];\n\tif (zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_TONAME, 1, sizeof (buf), buf) == 0) {\n\t\tfnvlist_add_string(token_nv, \"toname\", buf);\n\t}\n\tif (zap_contains(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_LARGEBLOCK) == 0) {\n\t\tfnvlist_add_boolean(token_nv, \"largeblockok\");\n\t}\n\tif (zap_contains(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_EMBEDOK) == 0) {\n\t\tfnvlist_add_boolean(token_nv, \"embedok\");\n\t}\n\tif (zap_contains(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_COMPRESSOK) == 0) {\n\t\tfnvlist_add_boolean(token_nv, \"compressok\");\n\t}\n\tif (zap_contains(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_RAWOK) == 0) {\n\t\tfnvlist_add_boolean(token_nv, \"rawok\");\n\t}\n\tif (dsl_dataset_feature_is_active(ds,\n\t    SPA_FEATURE_REDACTED_DATASETS)) {\n\t\tuint64_t num_redact_snaps = 0;\n\t\tuint64_t *redact_snaps = NULL;\n\t\tVERIFY3B(dsl_dataset_get_uint64_array_feature(ds,\n\t\t    SPA_FEATURE_REDACTED_DATASETS, &num_redact_snaps,\n\t\t    &redact_snaps), ==, B_TRUE);\n\t\tfnvlist_add_uint64_array(token_nv, \"redact_snaps\",\n\t\t    redact_snaps, num_redact_snaps);\n\t}\n\tif (zap_contains(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_REDACT_BOOKMARK_SNAPS) == 0) {\n\t\tuint64_t num_redact_snaps = 0, int_size = 0;\n\t\tuint64_t *redact_snaps = NULL;\n\t\tVERIFY0(zap_length(dp->dp_meta_objset, ds->ds_object,\n\t\t    DS_FIELD_RESUME_REDACT_BOOKMARK_SNAPS, &int_size,\n\t\t    &num_redact_snaps));\n\t\tASSERT3U(int_size, ==, sizeof (uint64_t));\n\n\t\tredact_snaps = kmem_alloc(int_size * num_redact_snaps,\n\t\t    KM_SLEEP);\n\t\tVERIFY0(zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t\t    DS_FIELD_RESUME_REDACT_BOOKMARK_SNAPS, int_size,\n\t\t    num_redact_snaps, redact_snaps));\n\t\tfnvlist_add_uint64_array(token_nv, \"book_redact_snaps\",\n\t\t    redact_snaps, num_redact_snaps);\n\t\tkmem_free(redact_snaps, int_size * num_redact_snaps);\n\t}\n\tpacked = fnvlist_pack(token_nv, &packed_size);\n\tfnvlist_free(token_nv);\n\tcompressed = kmem_alloc(packed_size, KM_SLEEP);\n\n\tcompressed_size = gzip_compress(packed, compressed,\n\t    packed_size, packed_size, 6);\n\n\tzio_cksum_t cksum;\n\tfletcher_4_native_varsize(compressed, compressed_size, &cksum);\n\n\tsize_t alloc_size = compressed_size * 2 + 1;\n\tstr = kmem_alloc(alloc_size, KM_SLEEP);\n\tfor (int i = 0; i < compressed_size; i++) {\n\t\tsize_t offset = i * 2;\n\t\t(void) snprintf(str + offset, alloc_size - offset,\n\t    \"%02x\", compressed[i]);\n\t}\n\tstr[compressed_size * 2] = '\\0';\n\tchar *propval = kmem_asprintf(\"%u-%llx-%llx-%s\",\n\t    ZFS_SEND_RESUME_TOKEN_VERSION,\n\t    (longlong_t)cksum.zc_word[0],\n\t    (longlong_t)packed_size, str);\n\tkmem_free(packed, packed_size);\n\tkmem_free(str, alloc_size);\n\tkmem_free(compressed, packed_size);\n\treturn (propval);\n}\n\n \nchar *\nget_receive_resume_token(dsl_dataset_t *ds)\n{\n\t \n\tchar *token = get_receive_resume_token_impl(ds);\n\tif (token != NULL)\n\t\treturn (token);\n\t \n\t \n\tchar name[ZFS_MAX_DATASET_NAME_LEN + 6];\n\tdsl_dataset_t *recv_ds;\n\tdsl_dataset_name(ds, name);\n\tif (strlcat(name, \"/\", sizeof (name)) < sizeof (name) &&\n\t    strlcat(name, recv_clone_name, sizeof (name)) < sizeof (name) &&\n\t    dsl_dataset_hold(ds->ds_dir->dd_pool, name, FTAG, &recv_ds) == 0) {\n\t\ttoken = get_receive_resume_token_impl(recv_ds);\n\t\tdsl_dataset_rele(recv_ds, FTAG);\n\t}\n\treturn (token);\n}\n\nuint64_t\ndsl_get_refratio(dsl_dataset_t *ds)\n{\n\tuint64_t ratio = dsl_dataset_phys(ds)->ds_compressed_bytes == 0 ? 100 :\n\t    (dsl_dataset_phys(ds)->ds_uncompressed_bytes * 100 /\n\t    dsl_dataset_phys(ds)->ds_compressed_bytes);\n\treturn (ratio);\n}\n\nuint64_t\ndsl_get_logicalreferenced(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_phys(ds)->ds_uncompressed_bytes);\n}\n\nuint64_t\ndsl_get_compressratio(dsl_dataset_t *ds)\n{\n\tif (ds->ds_is_snapshot) {\n\t\treturn (dsl_get_refratio(ds));\n\t} else {\n\t\tdsl_dir_t *dd = ds->ds_dir;\n\t\tmutex_enter(&dd->dd_lock);\n\t\tuint64_t val = dsl_dir_get_compressratio(dd);\n\t\tmutex_exit(&dd->dd_lock);\n\t\treturn (val);\n\t}\n}\n\nuint64_t\ndsl_get_used(dsl_dataset_t *ds)\n{\n\tif (ds->ds_is_snapshot) {\n\t\treturn (dsl_dataset_phys(ds)->ds_unique_bytes);\n\t} else {\n\t\tdsl_dir_t *dd = ds->ds_dir;\n\t\tmutex_enter(&dd->dd_lock);\n\t\tuint64_t val = dsl_dir_get_used(dd);\n\t\tmutex_exit(&dd->dd_lock);\n\t\treturn (val);\n\t}\n}\n\nuint64_t\ndsl_get_creation(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_phys(ds)->ds_creation_time);\n}\n\nuint64_t\ndsl_get_creationtxg(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_phys(ds)->ds_creation_txg);\n}\n\nuint64_t\ndsl_get_refquota(dsl_dataset_t *ds)\n{\n\treturn (ds->ds_quota);\n}\n\nuint64_t\ndsl_get_refreservation(dsl_dataset_t *ds)\n{\n\treturn (ds->ds_reserved);\n}\n\nuint64_t\ndsl_get_guid(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_phys(ds)->ds_guid);\n}\n\nuint64_t\ndsl_get_unique(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_phys(ds)->ds_unique_bytes);\n}\n\nuint64_t\ndsl_get_objsetid(dsl_dataset_t *ds)\n{\n\treturn (ds->ds_object);\n}\n\nuint64_t\ndsl_get_userrefs(dsl_dataset_t *ds)\n{\n\treturn (ds->ds_userrefs);\n}\n\nuint64_t\ndsl_get_defer_destroy(dsl_dataset_t *ds)\n{\n\treturn (DS_IS_DEFER_DESTROY(ds) ? 1 : 0);\n}\n\nuint64_t\ndsl_get_referenced(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_phys(ds)->ds_referenced_bytes);\n}\n\nuint64_t\ndsl_get_numclones(dsl_dataset_t *ds)\n{\n\tASSERT(ds->ds_is_snapshot);\n\treturn (dsl_dataset_phys(ds)->ds_num_children - 1);\n}\n\nuint64_t\ndsl_get_inconsistent(dsl_dataset_t *ds)\n{\n\treturn ((dsl_dataset_phys(ds)->ds_flags & DS_FLAG_INCONSISTENT) ?\n\t    1 : 0);\n}\n\nuint64_t\ndsl_get_redacted(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_feature_is_active(ds,\n\t    SPA_FEATURE_REDACTED_DATASETS));\n}\n\nuint64_t\ndsl_get_available(dsl_dataset_t *ds)\n{\n\tuint64_t refdbytes = dsl_get_referenced(ds);\n\tuint64_t availbytes = dsl_dir_space_available(ds->ds_dir,\n\t    NULL, 0, TRUE);\n\tif (ds->ds_reserved > dsl_dataset_phys(ds)->ds_unique_bytes) {\n\t\tavailbytes +=\n\t\t    ds->ds_reserved - dsl_dataset_phys(ds)->ds_unique_bytes;\n\t}\n\tif (ds->ds_quota != 0) {\n\t\t \n\t\tif (refdbytes < ds->ds_quota) {\n\t\t\tavailbytes = MIN(availbytes,\n\t\t\t    ds->ds_quota - refdbytes);\n\t\t} else {\n\t\t\tavailbytes = 0;\n\t\t}\n\t}\n\treturn (availbytes);\n}\n\nint\ndsl_get_written(dsl_dataset_t *ds, uint64_t *written)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tdsl_dataset_t *prev;\n\tint err = dsl_dataset_hold_obj(dp,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, FTAG, &prev);\n\tif (err == 0) {\n\t\tuint64_t comp, uncomp;\n\t\terr = dsl_dataset_space_written(prev, ds, written,\n\t\t    &comp, &uncomp);\n\t\tdsl_dataset_rele(prev, FTAG);\n\t}\n\treturn (err);\n}\n\n \nint\ndsl_get_prev_snap(dsl_dataset_t *ds, char *snap)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tif (ds->ds_prev != NULL && ds->ds_prev != dp->dp_origin_snap) {\n\t\tdsl_dataset_name(ds->ds_prev, snap);\n\t\treturn (0);\n\t} else {\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n}\n\nvoid\ndsl_get_redact_snaps(dsl_dataset_t *ds, nvlist_t *propval)\n{\n\tuint64_t nsnaps;\n\tuint64_t *snaps;\n\tif (dsl_dataset_get_uint64_array_feature(ds,\n\t    SPA_FEATURE_REDACTED_DATASETS, &nsnaps, &snaps)) {\n\t\tfnvlist_add_uint64_array(propval, ZPROP_VALUE, snaps,\n\t\t    nsnaps);\n\t}\n}\n\n \nint\ndsl_get_mountpoint(dsl_dataset_t *ds, const char *dsname, char *value,\n    char *source)\n{\n\tint error;\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\n\t \n\terror = dsl_prop_get_ds(ds, zfs_prop_to_name(ZFS_PROP_MOUNTPOINT), 1,\n\t    ZAP_MAXVALUELEN, value, source);\n\tif (error != 0) {\n\t\treturn (error);\n\t}\n\n\t \n\tif (value[0] == '/') {\n\t\tchar *buf = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);\n\t\tchar *root = buf;\n\t\tconst char *relpath;\n\n\t\t \n\t\tif (strcmp(source, ZPROP_SOURCE_VAL_RECVD) == 0) {\n\t\t\trelpath = \"\";\n\t\t} else {\n\t\t\tASSERT0(strncmp(dsname, source, strlen(source)));\n\t\t\trelpath = dsname + strlen(source);\n\t\t\tif (relpath[0] == '/')\n\t\t\t\trelpath++;\n\t\t}\n\n\t\tspa_altroot(dp->dp_spa, root, ZAP_MAXVALUELEN);\n\n\t\t \n\t\tif (strcmp(root, \"/\") == 0)\n\t\t\troot++;\n\n\t\t \n\t\tchar *mnt = value;\n\t\tif (value[1] == '\\0' && (root[0] != '\\0' ||\n\t\t    relpath[0] != '\\0'))\n\t\t\tmnt = value + 1;\n\n\t\tmnt = kmem_strdup(mnt);\n\n\t\tif (relpath[0] == '\\0') {\n\t\t\t(void) snprintf(value, ZAP_MAXVALUELEN, \"%s%s\",\n\t\t\t    root, mnt);\n\t\t} else {\n\t\t\t(void) snprintf(value, ZAP_MAXVALUELEN, \"%s%s%s%s\",\n\t\t\t    root, mnt, relpath[0] == '@' ? \"\" : \"/\",\n\t\t\t    relpath);\n\t\t}\n\t\tkmem_free(buf, ZAP_MAXVALUELEN);\n\t\tkmem_strfree(mnt);\n\t}\n\n\treturn (0);\n}\n\nvoid\ndsl_dataset_stats(dsl_dataset_t *ds, nvlist_t *nv)\n{\n\tdsl_pool_t *dp __maybe_unused = ds->ds_dir->dd_pool;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_REFRATIO,\n\t    dsl_get_refratio(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_LOGICALREFERENCED,\n\t    dsl_get_logicalreferenced(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_COMPRESSRATIO,\n\t    dsl_get_compressratio(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USED,\n\t    dsl_get_used(ds));\n\n\tif (ds->ds_is_snapshot) {\n\t\tget_clones_stat(ds, nv);\n\t} else {\n\t\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\t\tif (dsl_get_prev_snap(ds, buf) == 0)\n\t\t\tdsl_prop_nvlist_add_string(nv, ZFS_PROP_PREV_SNAP,\n\t\t\t    buf);\n\t\tdsl_dir_stats(ds->ds_dir, nv);\n\t}\n\n\tnvlist_t *propval = fnvlist_alloc();\n\tdsl_get_redact_snaps(ds, propval);\n\tfnvlist_add_nvlist(nv, zfs_prop_to_name(ZFS_PROP_REDACT_SNAPS),\n\t    propval);\n\tnvlist_free(propval);\n\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_AVAILABLE,\n\t    dsl_get_available(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_REFERENCED,\n\t    dsl_get_referenced(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_CREATION,\n\t    dsl_get_creation(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_CREATETXG,\n\t    dsl_get_creationtxg(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_REFQUOTA,\n\t    dsl_get_refquota(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_REFRESERVATION,\n\t    dsl_get_refreservation(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_GUID,\n\t    dsl_get_guid(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_UNIQUE,\n\t    dsl_get_unique(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_OBJSETID,\n\t    dsl_get_objsetid(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_USERREFS,\n\t    dsl_get_userrefs(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_DEFER_DESTROY,\n\t    dsl_get_defer_destroy(ds));\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_SNAPSHOTS_CHANGED,\n\t    dsl_dir_snap_cmtime(ds->ds_dir).tv_sec);\n\tdsl_dataset_crypt_stats(ds, nv);\n\n\tif (dsl_dataset_phys(ds)->ds_prev_snap_obj != 0) {\n\t\tuint64_t written;\n\t\tif (dsl_get_written(ds, &written) == 0) {\n\t\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_WRITTEN,\n\t\t\t    written);\n\t\t}\n\t}\n\n\tif (!dsl_dataset_is_snapshot(ds)) {\n\t\tchar *token = get_receive_resume_token(ds);\n\t\tif (token != NULL) {\n\t\t\tdsl_prop_nvlist_add_string(nv,\n\t\t\t    ZFS_PROP_RECEIVE_RESUME_TOKEN, token);\n\t\t\tkmem_strfree(token);\n\t\t}\n\t}\n}\n\nvoid\ndsl_dataset_fast_stat(dsl_dataset_t *ds, dmu_objset_stats_t *stat)\n{\n\tdsl_pool_t *dp __maybe_unused = ds->ds_dir->dd_pool;\n\tASSERT(dsl_pool_config_held(dp));\n\n\tstat->dds_creation_txg = dsl_get_creationtxg(ds);\n\tstat->dds_inconsistent = dsl_get_inconsistent(ds);\n\tstat->dds_guid = dsl_get_guid(ds);\n\tstat->dds_redacted = dsl_get_redacted(ds);\n\tstat->dds_origin[0] = '\\0';\n\tif (ds->ds_is_snapshot) {\n\t\tstat->dds_is_snapshot = B_TRUE;\n\t\tstat->dds_num_clones = dsl_get_numclones(ds);\n\t} else {\n\t\tstat->dds_is_snapshot = B_FALSE;\n\t\tstat->dds_num_clones = 0;\n\n\t\tif (dsl_dir_is_clone(ds->ds_dir)) {\n\t\t\tdsl_dir_get_origin(ds->ds_dir, stat->dds_origin);\n\t\t}\n\t}\n}\n\nuint64_t\ndsl_dataset_fsid_guid(dsl_dataset_t *ds)\n{\n\treturn (ds->ds_fsid_guid);\n}\n\nvoid\ndsl_dataset_space(dsl_dataset_t *ds,\n    uint64_t *refdbytesp, uint64_t *availbytesp,\n    uint64_t *usedobjsp, uint64_t *availobjsp)\n{\n\t*refdbytesp = dsl_dataset_phys(ds)->ds_referenced_bytes;\n\t*availbytesp = dsl_dir_space_available(ds->ds_dir, NULL, 0, TRUE);\n\tif (ds->ds_reserved > dsl_dataset_phys(ds)->ds_unique_bytes)\n\t\t*availbytesp +=\n\t\t    ds->ds_reserved - dsl_dataset_phys(ds)->ds_unique_bytes;\n\tif (ds->ds_quota != 0) {\n\t\t \n\t\tif (*refdbytesp < ds->ds_quota)\n\t\t\t*availbytesp = MIN(*availbytesp,\n\t\t\t    ds->ds_quota - *refdbytesp);\n\t\telse\n\t\t\t*availbytesp = 0;\n\t}\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\t*usedobjsp = BP_GET_FILL(&dsl_dataset_phys(ds)->ds_bp);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\t*availobjsp = DN_MAX_OBJECT - *usedobjsp;\n}\n\nboolean_t\ndsl_dataset_modified_since_snap(dsl_dataset_t *ds, dsl_dataset_t *snap)\n{\n\tdsl_pool_t *dp __maybe_unused = ds->ds_dir->dd_pool;\n\tuint64_t birth;\n\n\tASSERT(dsl_pool_config_held(dp));\n\tif (snap == NULL)\n\t\treturn (B_FALSE);\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tbirth = dsl_dataset_get_blkptr(ds)->blk_birth;\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\tif (birth > dsl_dataset_phys(snap)->ds_creation_txg) {\n\t\tobjset_t *os, *os_snap;\n\t\t \n\t\tif (dmu_objset_from_ds(ds, &os) != 0)\n\t\t\treturn (B_TRUE);\n\t\tif (dmu_objset_from_ds(snap, &os_snap) != 0)\n\t\t\treturn (B_TRUE);\n\t\treturn (memcmp(&os->os_phys->os_meta_dnode,\n\t\t    &os_snap->os_phys->os_meta_dnode,\n\t\t    sizeof (os->os_phys->os_meta_dnode)) != 0);\n\t}\n\treturn (B_FALSE);\n}\n\nstatic int\ndsl_dataset_rename_snapshot_check_impl(dsl_pool_t *dp,\n    dsl_dataset_t *hds, void *arg)\n{\n\t(void) dp;\n\tdsl_dataset_rename_snapshot_arg_t *ddrsa = arg;\n\tint error;\n\tuint64_t val;\n\n\terror = dsl_dataset_snap_lookup(hds, ddrsa->ddrsa_oldsnapname, &val);\n\tif (error != 0) {\n\t\t \n\t\treturn (error == ENOENT ? 0 : error);\n\t}\n\n\t \n\terror = dsl_dataset_snap_lookup(hds, ddrsa->ddrsa_newsnapname, &val);\n\tif (error == 0)\n\t\terror = SET_ERROR(EEXIST);\n\telse if (error == ENOENT)\n\t\terror = 0;\n\n\t \n\tif (dsl_dir_namelen(hds->ds_dir) + 1 +\n\t    strlen(ddrsa->ddrsa_newsnapname) >= ZFS_MAX_DATASET_NAME_LEN)\n\t\terror = SET_ERROR(ENAMETOOLONG);\n\n\treturn (error);\n}\n\nint\ndsl_dataset_rename_snapshot_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_rename_snapshot_arg_t *ddrsa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *hds;\n\tint error;\n\n\terror = dsl_dataset_hold(dp, ddrsa->ddrsa_fsname, FTAG, &hds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (ddrsa->ddrsa_recursive) {\n\t\terror = dmu_objset_find_dp(dp, hds->ds_dir->dd_object,\n\t\t    dsl_dataset_rename_snapshot_check_impl, ddrsa,\n\t\t    DS_FIND_CHILDREN);\n\t} else {\n\t\terror = dsl_dataset_rename_snapshot_check_impl(dp, hds, ddrsa);\n\t}\n\tdsl_dataset_rele(hds, FTAG);\n\treturn (error);\n}\n\nstatic int\ndsl_dataset_rename_snapshot_sync_impl(dsl_pool_t *dp,\n    dsl_dataset_t *hds, void *arg)\n{\n\tdsl_dataset_rename_snapshot_arg_t *ddrsa = arg;\n\tdsl_dataset_t *ds;\n\tuint64_t val;\n\tdmu_tx_t *tx = ddrsa->ddrsa_tx;\n\tint error;\n\n\terror = dsl_dataset_snap_lookup(hds, ddrsa->ddrsa_oldsnapname, &val);\n\tASSERT(error == 0 || error == ENOENT);\n\tif (error == ENOENT) {\n\t\t \n\t\treturn (0);\n\t}\n\n\tVERIFY0(dsl_dataset_hold_obj(dp, val, FTAG, &ds));\n\n\t \n\tspa_history_log_internal_ds(ds, \"rename\", tx,\n\t    \"-> @%s\", ddrsa->ddrsa_newsnapname);\n\n\tVERIFY0(dsl_dataset_snap_remove(hds, ddrsa->ddrsa_oldsnapname, tx,\n\t    B_FALSE));\n\tmutex_enter(&ds->ds_lock);\n\t(void) strlcpy(ds->ds_snapname, ddrsa->ddrsa_newsnapname,\n\t    sizeof (ds->ds_snapname));\n\tmutex_exit(&ds->ds_lock);\n\tVERIFY0(zap_add(dp->dp_meta_objset,\n\t    dsl_dataset_phys(hds)->ds_snapnames_zapobj,\n\t    ds->ds_snapname, 8, 1, &ds->ds_object, tx));\n\tzvol_rename_minors(dp->dp_spa, ddrsa->ddrsa_oldsnapname,\n\t    ddrsa->ddrsa_newsnapname, B_TRUE);\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nvoid\ndsl_dataset_rename_snapshot_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_rename_snapshot_arg_t *ddrsa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *hds = NULL;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddrsa->ddrsa_fsname, FTAG, &hds));\n\tddrsa->ddrsa_tx = tx;\n\tif (ddrsa->ddrsa_recursive) {\n\t\tVERIFY0(dmu_objset_find_dp(dp, hds->ds_dir->dd_object,\n\t\t    dsl_dataset_rename_snapshot_sync_impl, ddrsa,\n\t\t    DS_FIND_CHILDREN));\n\t} else {\n\t\tVERIFY0(dsl_dataset_rename_snapshot_sync_impl(dp, hds, ddrsa));\n\t}\n\tdsl_dataset_rele(hds, FTAG);\n}\n\nint\ndsl_dataset_rename_snapshot(const char *fsname,\n    const char *oldsnapname, const char *newsnapname, boolean_t recursive)\n{\n\tdsl_dataset_rename_snapshot_arg_t ddrsa;\n\n\tddrsa.ddrsa_fsname = fsname;\n\tddrsa.ddrsa_oldsnapname = oldsnapname;\n\tddrsa.ddrsa_newsnapname = newsnapname;\n\tddrsa.ddrsa_recursive = recursive;\n\n\treturn (dsl_sync_task(fsname, dsl_dataset_rename_snapshot_check,\n\t    dsl_dataset_rename_snapshot_sync, &ddrsa,\n\t    1, ZFS_SPACE_CHECK_RESERVED));\n}\n\n \nstatic int\ndsl_dataset_handoff_check(dsl_dataset_t *ds, void *owner, dmu_tx_t *tx)\n{\n\tboolean_t held = B_FALSE;\n\n\tif (!dmu_tx_is_syncing(tx))\n\t\treturn (0);\n\n\tdsl_dir_t *dd = ds->ds_dir;\n\tmutex_enter(&dd->dd_activity_lock);\n\tuint64_t holds = zfs_refcount_count(&ds->ds_longholds) -\n\t    (owner != NULL ? 1 : 0);\n\t \n\tif (holds != dd->dd_activity_waiters)\n\t\theld = B_TRUE;\n\tmutex_exit(&dd->dd_activity_lock);\n\n\tif (held)\n\t\treturn (SET_ERROR(EBUSY));\n\n\treturn (0);\n}\n\nint\ndsl_dataset_rollback_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_rollback_arg_t *ddra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tint64_t unused_refres_delta;\n\tint error;\n\n\terror = dsl_dataset_hold(dp, ddra->ddra_fsname, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tif (ds->ds_is_snapshot) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (dsl_dataset_phys(ds)->ds_prev_snap_txg < TXG_INITIAL) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(ESRCH));\n\t}\n\n\t \n\tif (dmu_tx_is_syncing(tx) &&\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg >= tx->tx_txg) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EAGAIN));\n\t}\n\n\t \n\tif (ddra->ddra_tosnap != NULL) {\n\t\tdsl_dataset_t *snapds;\n\n\t\t \n\t\terror = dsl_dataset_hold(dp, ddra->ddra_tosnap, FTAG, &snapds);\n\t\tif (error != 0) {\n\t\t\t \n\t\t\tif (error == ENOENT || error == EXDEV)\n\t\t\t\terror = SET_ERROR(ESRCH);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\tASSERT(snapds->ds_is_snapshot);\n\n\t\t \n\t\tif (snapds != ds->ds_prev) {\n\t\t\t \n\t\t\tif (snapds->ds_dir == ds->ds_dir ||\n\t\t\t    (dsl_dir_is_clone(ds->ds_dir) &&\n\t\t\t    dsl_dir_phys(ds->ds_dir)->dd_origin_obj ==\n\t\t\t    snapds->ds_object)) {\n\t\t\t\terror = SET_ERROR(EEXIST);\n\t\t\t} else {\n\t\t\t\terror = SET_ERROR(ESRCH);\n\t\t\t}\n\t\t\tdsl_dataset_rele(snapds, FTAG);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\tdsl_dataset_rele(snapds, FTAG);\n\t}\n\n\t \n\tif (dsl_bookmark_latest_txg(ds) >\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EEXIST));\n\t}\n\n\terror = dsl_dataset_handoff_check(ds, ddra->ddra_owner, tx);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (ds->ds_quota != 0 &&\n\t    dsl_dataset_phys(ds->ds_prev)->ds_referenced_bytes > ds->ds_quota) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\t \n\tunused_refres_delta = (int64_t)MIN(ds->ds_reserved,\n\t    dsl_dataset_phys(ds)->ds_unique_bytes);\n\n\tif (unused_refres_delta > 0 &&\n\t    unused_refres_delta >\n\t    dsl_dir_space_available(ds->ds_dir, NULL, 0, TRUE)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(ENOSPC));\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nvoid\ndsl_dataset_rollback_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_rollback_arg_t *ddra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds, *clone;\n\tuint64_t cloneobj;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\n\tVERIFY0(dsl_dataset_hold(dp, ddra->ddra_fsname, FTAG, &ds));\n\n\tdsl_dataset_name(ds->ds_prev, namebuf);\n\tfnvlist_add_string(ddra->ddra_result, \"target\", namebuf);\n\n\tcloneobj = dsl_dataset_create_sync(ds->ds_dir, \"%rollback\",\n\t    ds->ds_prev, DS_CREATE_FLAG_NODIRTY, kcred, NULL, tx);\n\n\tVERIFY0(dsl_dataset_hold_obj(dp, cloneobj, FTAG, &clone));\n\n\tdsl_dataset_clone_swap_sync_impl(clone, ds, tx);\n\tdsl_dataset_zero_zil(ds, tx);\n\n\tdsl_destroy_head_sync_impl(clone, tx);\n\n\tdsl_dataset_rele(clone, FTAG);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\n \nint\ndsl_dataset_rollback(const char *fsname, const char *tosnap, void *owner,\n    nvlist_t *result)\n{\n\tdsl_dataset_rollback_arg_t ddra;\n\n\tddra.ddra_fsname = fsname;\n\tddra.ddra_tosnap = tosnap;\n\tddra.ddra_owner = owner;\n\tddra.ddra_result = result;\n\n\treturn (dsl_sync_task(fsname, dsl_dataset_rollback_check,\n\t    dsl_dataset_rollback_sync, &ddra,\n\t    1, ZFS_SPACE_CHECK_RESERVED));\n}\n\nstruct promotenode {\n\tlist_node_t link;\n\tdsl_dataset_t *ds;\n};\n\nstatic int snaplist_space(list_t *l, uint64_t mintxg, uint64_t *spacep);\nstatic int promote_hold(dsl_dataset_promote_arg_t *ddpa, dsl_pool_t *dp,\n    const void *tag);\nstatic void promote_rele(dsl_dataset_promote_arg_t *ddpa, const void *tag);\n\nint\ndsl_dataset_promote_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_promote_arg_t *ddpa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *hds;\n\tstruct promotenode *snap;\n\tint err;\n\tuint64_t unused;\n\tuint64_t ss_mv_cnt;\n\tsize_t max_snap_len;\n\tboolean_t conflicting_snaps;\n\n\terr = promote_hold(ddpa, dp, FTAG);\n\tif (err != 0)\n\t\treturn (err);\n\n\thds = ddpa->ddpa_clone;\n\tmax_snap_len = MAXNAMELEN - strlen(ddpa->ddpa_clonename) - 1;\n\n\tif (dsl_dataset_phys(hds)->ds_flags & DS_FLAG_NOPROMOTE) {\n\t\tpromote_rele(ddpa, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\tsnap = list_head(&ddpa->shared_snaps);\n\tif (snap == NULL) {\n\t\terr = SET_ERROR(ENOENT);\n\t\tgoto out;\n\t}\n\tdsl_dataset_t *const origin_ds = snap->ds;\n\n\t \n\terr = dsl_dataset_promote_crypt_check(hds->ds_dir, origin_ds->ds_dir);\n\tif (err != 0)\n\t\tgoto out;\n\n\t \n\tif (!dmu_tx_is_syncing(tx)) {\n\t\tpromote_rele(ddpa, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tsnap = list_tail(&ddpa->clone_snaps);\n\tASSERT(snap != NULL);\n\tASSERT3U(dsl_dataset_phys(snap->ds)->ds_prev_snap_obj, ==,\n\t    origin_ds->ds_object);\n\tdsl_deadlist_space_range(&snap->ds->ds_deadlist,\n\t    dsl_dataset_phys(origin_ds)->ds_prev_snap_txg, UINT64_MAX,\n\t    &ddpa->unique, &unused, &unused);\n\n\t \n\tconflicting_snaps = B_FALSE;\n\tss_mv_cnt = 0;\n\tddpa->used = dsl_dataset_phys(origin_ds)->ds_referenced_bytes;\n\tddpa->comp = dsl_dataset_phys(origin_ds)->ds_compressed_bytes;\n\tddpa->uncomp = dsl_dataset_phys(origin_ds)->ds_uncompressed_bytes;\n\tfor (snap = list_head(&ddpa->shared_snaps); snap;\n\t    snap = list_next(&ddpa->shared_snaps, snap)) {\n\t\tuint64_t val, dlused, dlcomp, dluncomp;\n\t\tdsl_dataset_t *ds = snap->ds;\n\n\t\tss_mv_cnt++;\n\n\t\t \n\t\tif (dsl_dataset_long_held(ds)) {\n\t\t\terr = SET_ERROR(EBUSY);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tVERIFY0(dsl_dataset_get_snapname(ds));\n\t\tif (strlen(ds->ds_snapname) >= max_snap_len) {\n\t\t\terr = SET_ERROR(ENAMETOOLONG);\n\t\t\tgoto out;\n\t\t}\n\t\terr = dsl_dataset_snap_lookup(hds, ds->ds_snapname, &val);\n\t\tif (err == 0) {\n\t\t\tfnvlist_add_boolean(ddpa->err_ds,\n\t\t\t    snap->ds->ds_snapname);\n\t\t\tconflicting_snaps = B_TRUE;\n\t\t} else if (err != ENOENT) {\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (dsl_dataset_phys(ds)->ds_prev_snap_obj == 0)\n\t\t\tcontinue;\n\n\t\tdsl_deadlist_space(&ds->ds_deadlist,\n\t\t    &dlused, &dlcomp, &dluncomp);\n\t\tddpa->used += dlused;\n\t\tddpa->comp += dlcomp;\n\t\tddpa->uncomp += dluncomp;\n\t}\n\n\t \n\tfor (dsl_bookmark_node_t *dbn = avl_first(&origin_ds->ds_bookmarks);\n\t    dbn != NULL && dbn->dbn_phys.zbm_creation_txg <=\n\t    dsl_dataset_phys(origin_ds)->ds_creation_txg;\n\t    dbn = AVL_NEXT(&origin_ds->ds_bookmarks, dbn)) {\n\t\tif (strlen(dbn->dbn_name) >= max_snap_len) {\n\t\t\terr = SET_ERROR(ENAMETOOLONG);\n\t\t\tgoto out;\n\t\t}\n\t\tzfs_bookmark_phys_t bm;\n\t\terr = dsl_bookmark_lookup_impl(ddpa->ddpa_clone,\n\t\t    dbn->dbn_name, &bm);\n\n\t\tif (err == 0) {\n\t\t\tfnvlist_add_boolean(ddpa->err_ds, dbn->dbn_name);\n\t\t\tconflicting_snaps = B_TRUE;\n\t\t} else if (err == ESRCH) {\n\t\t\terr = 0;\n\t\t}\n\t\tif (err != 0) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (conflicting_snaps) {\n\t\terr = SET_ERROR(EEXIST);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ddpa->origin_origin) {\n\t\tddpa->used -=\n\t\t    dsl_dataset_phys(ddpa->origin_origin)->ds_referenced_bytes;\n\t\tddpa->comp -=\n\t\t    dsl_dataset_phys(ddpa->origin_origin)->ds_compressed_bytes;\n\t\tddpa->uncomp -=\n\t\t    dsl_dataset_phys(ddpa->origin_origin)->\n\t\t    ds_uncompressed_bytes;\n\t}\n\n\t \n\terr = dsl_dir_transfer_possible(origin_ds->ds_dir, hds->ds_dir,\n\t    0, ss_mv_cnt, ddpa->used, ddpa->cr, ddpa->proc);\n\tif (err != 0)\n\t\tgoto out;\n\n\t \n\tif (dsl_dir_phys(hds->ds_dir)->dd_flags & DD_FLAG_USED_BREAKDOWN) {\n\t\tuint64_t space;\n\n\t\t \n\t\tsnap = list_head(&ddpa->origin_snaps);\n\t\tif (snap == NULL) {\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t\tgoto out;\n\t\t}\n\t\terr = snaplist_space(&ddpa->shared_snaps,\n\t\t    snap->ds->ds_dir->dd_origin_txg, &ddpa->cloneusedsnap);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\terr = snaplist_space(&ddpa->clone_snaps,\n\t\t    snap->ds->ds_dir->dd_origin_txg, &space);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t\tddpa->cloneusedsnap += space;\n\t}\n\tif (dsl_dir_phys(origin_ds->ds_dir)->dd_flags &\n\t    DD_FLAG_USED_BREAKDOWN) {\n\t\terr = snaplist_space(&ddpa->origin_snaps,\n\t\t    dsl_dataset_phys(origin_ds)->ds_creation_txg,\n\t\t    &ddpa->originusedsnap);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tpromote_rele(ddpa, FTAG);\n\treturn (err);\n}\n\nvoid\ndsl_dataset_promote_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_promote_arg_t *ddpa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *hds;\n\tstruct promotenode *snap;\n\tdsl_dataset_t *origin_ds;\n\tdsl_dataset_t *origin_head;\n\tdsl_dir_t *dd;\n\tdsl_dir_t *odd = NULL;\n\tuint64_t oldnext_obj;\n\tint64_t delta;\n\n\tASSERT(nvlist_empty(ddpa->err_ds));\n\n\tVERIFY0(promote_hold(ddpa, dp, FTAG));\n\thds = ddpa->ddpa_clone;\n\n\tASSERT0(dsl_dataset_phys(hds)->ds_flags & DS_FLAG_NOPROMOTE);\n\n\tsnap = list_head(&ddpa->shared_snaps);\n\torigin_ds = snap->ds;\n\tdd = hds->ds_dir;\n\n\tsnap = list_head(&ddpa->origin_snaps);\n\torigin_head = snap->ds;\n\n\t \n\tVERIFY0(dsl_dir_hold_obj(dp, origin_ds->ds_dir->dd_object,\n\t    NULL, FTAG, &odd));\n\n\tdsl_dataset_promote_crypt_sync(hds->ds_dir, odd, tx);\n\n\t \n\tdmu_buf_will_dirty(origin_ds->ds_dbuf, tx);\n\toldnext_obj = dsl_dataset_phys(origin_ds)->ds_next_snap_obj;\n\tsnap = list_tail(&ddpa->clone_snaps);\n\tASSERT3U(dsl_dataset_phys(snap->ds)->ds_prev_snap_obj, ==,\n\t    origin_ds->ds_object);\n\tdsl_dataset_phys(origin_ds)->ds_next_snap_obj = snap->ds->ds_object;\n\n\t \n\tif (dsl_dataset_phys(origin_ds)->ds_next_clones_obj) {\n\t\tdsl_dataset_remove_from_next_clones(origin_ds,\n\t\t    snap->ds->ds_object, tx);\n\t\tVERIFY0(zap_add_int(dp->dp_meta_objset,\n\t\t    dsl_dataset_phys(origin_ds)->ds_next_clones_obj,\n\t\t    oldnext_obj, tx));\n\t}\n\n\t \n\tdmu_buf_will_dirty(dd->dd_dbuf, tx);\n\tASSERT3U(dsl_dir_phys(dd)->dd_origin_obj, ==, origin_ds->ds_object);\n\tdsl_dir_phys(dd)->dd_origin_obj = dsl_dir_phys(odd)->dd_origin_obj;\n\tdd->dd_origin_txg = origin_head->ds_dir->dd_origin_txg;\n\tdmu_buf_will_dirty(odd->dd_dbuf, tx);\n\tdsl_dir_phys(odd)->dd_origin_obj = origin_ds->ds_object;\n\torigin_head->ds_dir->dd_origin_txg =\n\t    dsl_dataset_phys(origin_ds)->ds_creation_txg;\n\n\t \n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_DIR_CLONES) {\n\t\tVERIFY0(zap_remove_int(dp->dp_meta_objset,\n\t\t    dsl_dir_phys(odd)->dd_clones, hds->ds_object, tx));\n\t\tVERIFY0(zap_add_int(dp->dp_meta_objset,\n\t\t    dsl_dir_phys(ddpa->origin_origin->ds_dir)->dd_clones,\n\t\t    hds->ds_object, tx));\n\n\t\tVERIFY0(zap_remove_int(dp->dp_meta_objset,\n\t\t    dsl_dir_phys(ddpa->origin_origin->ds_dir)->dd_clones,\n\t\t    origin_head->ds_object, tx));\n\t\tif (dsl_dir_phys(dd)->dd_clones == 0) {\n\t\t\tdsl_dir_phys(dd)->dd_clones =\n\t\t\t    zap_create(dp->dp_meta_objset, DMU_OT_DSL_CLONES,\n\t\t\t    DMU_OT_NONE, 0, tx);\n\t\t}\n\t\tVERIFY0(zap_add_int(dp->dp_meta_objset,\n\t\t    dsl_dir_phys(dd)->dd_clones, origin_head->ds_object, tx));\n\t}\n\n\t \n\tdsl_bookmark_node_t *dbn_next;\n\tfor (dsl_bookmark_node_t *dbn = avl_first(&origin_head->ds_bookmarks);\n\t    dbn != NULL && dbn->dbn_phys.zbm_creation_txg <=\n\t    dsl_dataset_phys(origin_ds)->ds_creation_txg;\n\t    dbn = dbn_next) {\n\t\tdbn_next = AVL_NEXT(&origin_head->ds_bookmarks, dbn);\n\n\t\tavl_remove(&origin_head->ds_bookmarks, dbn);\n\t\tVERIFY0(zap_remove(dp->dp_meta_objset,\n\t\t    origin_head->ds_bookmarks_obj, dbn->dbn_name, tx));\n\n\t\tdsl_bookmark_node_add(hds, dbn, tx);\n\t}\n\n\tdsl_bookmark_next_changed(hds, origin_ds, tx);\n\n\t \n\tfor (snap = list_head(&ddpa->shared_snaps); snap;\n\t    snap = list_next(&ddpa->shared_snaps, snap)) {\n\t\tdsl_dataset_t *ds = snap->ds;\n\n\t\t \n\t\tif (ds->ds_objset) {\n\t\t\tdmu_objset_evict(ds->ds_objset);\n\t\t\tds->ds_objset = NULL;\n\t\t}\n\n\t\t \n\t\tVERIFY0(dsl_dataset_get_snapname(ds));\n\t\tVERIFY0(dsl_dataset_snap_remove(origin_head,\n\t\t    ds->ds_snapname, tx, B_TRUE));\n\t\tVERIFY0(zap_add(dp->dp_meta_objset,\n\t\t    dsl_dataset_phys(hds)->ds_snapnames_zapobj, ds->ds_snapname,\n\t\t    8, 1, &ds->ds_object, tx));\n\t\tdsl_fs_ss_count_adjust(hds->ds_dir, 1,\n\t\t    DD_FIELD_SNAPSHOT_COUNT, tx);\n\n\t\t \n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tASSERT3U(dsl_dataset_phys(ds)->ds_dir_obj, ==, odd->dd_object);\n\t\tdsl_dataset_phys(ds)->ds_dir_obj = dd->dd_object;\n\t\tASSERT3P(ds->ds_dir, ==, odd);\n\t\tdsl_dir_rele(ds->ds_dir, ds);\n\t\tVERIFY0(dsl_dir_hold_obj(dp, dd->dd_object,\n\t\t    NULL, ds, &ds->ds_dir));\n\n\t\t \n\t\tif (dsl_dataset_phys(ds)->ds_next_clones_obj &&\n\t\t    spa_version(dp->dp_spa) >= SPA_VERSION_DIR_CLONES) {\n\t\t\tzap_cursor_t zc;\n\t\t\tzap_attribute_t za;\n\n\t\t\tfor (zap_cursor_init(&zc, dp->dp_meta_objset,\n\t\t\t    dsl_dataset_phys(ds)->ds_next_clones_obj);\n\t\t\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t\t\t    zap_cursor_advance(&zc)) {\n\t\t\t\tdsl_dataset_t *cnds;\n\t\t\t\tuint64_t o;\n\n\t\t\t\tif (za.za_first_integer == oldnext_obj) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t\t\t    za.za_first_integer, FTAG, &cnds));\n\t\t\t\to = dsl_dir_phys(cnds->ds_dir)->\n\t\t\t\t    dd_head_dataset_obj;\n\n\t\t\t\tVERIFY0(zap_remove_int(dp->dp_meta_objset,\n\t\t\t\t    dsl_dir_phys(odd)->dd_clones, o, tx));\n\t\t\t\tVERIFY0(zap_add_int(dp->dp_meta_objset,\n\t\t\t\t    dsl_dir_phys(dd)->dd_clones, o, tx));\n\t\t\t\tdsl_dataset_rele(cnds, FTAG);\n\t\t\t}\n\t\t\tzap_cursor_fini(&zc);\n\t\t}\n\n\t\tASSERT(!dsl_prop_hascb(ds));\n\t}\n\n\t \n\n\tdelta = ddpa->cloneusedsnap -\n\t    dsl_dir_phys(dd)->dd_used_breakdown[DD_USED_SNAP];\n\tASSERT3S(delta, >=, 0);\n\tASSERT3U(ddpa->used, >=, delta);\n\tdsl_dir_diduse_space(dd, DD_USED_SNAP, delta, 0, 0, tx);\n\tdsl_dir_diduse_space(dd, DD_USED_HEAD,\n\t    ddpa->used - delta, ddpa->comp, ddpa->uncomp, tx);\n\n\tdelta = ddpa->originusedsnap -\n\t    dsl_dir_phys(odd)->dd_used_breakdown[DD_USED_SNAP];\n\tASSERT3S(delta, <=, 0);\n\tASSERT3U(ddpa->used, >=, -delta);\n\tdsl_dir_diduse_space(odd, DD_USED_SNAP, delta, 0, 0, tx);\n\tdsl_dir_diduse_space(odd, DD_USED_HEAD,\n\t    -ddpa->used - delta, -ddpa->comp, -ddpa->uncomp, tx);\n\n\tdsl_dataset_phys(origin_ds)->ds_unique_bytes = ddpa->unique;\n\n\t \n\tdsl_dir_remove_livelist(dd, tx, B_TRUE);\n\tdsl_dir_remove_livelist(odd, tx, B_TRUE);\n\n\t \n\tspa_history_log_internal_ds(hds, \"promote\", tx, \" \");\n\n\tdsl_dir_rele(odd, FTAG);\n\tpromote_rele(ddpa, FTAG);\n\n\t \n\tif (spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_HEAD_ERRLOG)) {\n\t\tuint64_t old_head = origin_head->ds_object;\n\t\tuint64_t new_head = hds->ds_object;\n\t\tspa_swap_errlog(dp->dp_spa, new_head, old_head, tx);\n\t}\n}\n\n \nstatic int\nsnaplist_make(dsl_pool_t *dp,\n    uint64_t first_obj, uint64_t last_obj, list_t *l, const void *tag)\n{\n\tuint64_t obj = last_obj;\n\n\tlist_create(l, sizeof (struct promotenode),\n\t    offsetof(struct promotenode, link));\n\n\twhile (obj != first_obj) {\n\t\tdsl_dataset_t *ds;\n\t\tstruct promotenode *snap;\n\t\tint err;\n\n\t\terr = dsl_dataset_hold_obj(dp, obj, tag, &ds);\n\t\tASSERT(err != ENOENT);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tif (first_obj == 0)\n\t\t\tfirst_obj = dsl_dir_phys(ds->ds_dir)->dd_origin_obj;\n\n\t\tsnap = kmem_alloc(sizeof (*snap), KM_SLEEP);\n\t\tsnap->ds = ds;\n\t\tlist_insert_tail(l, snap);\n\t\tobj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nsnaplist_space(list_t *l, uint64_t mintxg, uint64_t *spacep)\n{\n\tstruct promotenode *snap;\n\n\t*spacep = 0;\n\tfor (snap = list_head(l); snap; snap = list_next(l, snap)) {\n\t\tuint64_t used, comp, uncomp;\n\t\tdsl_deadlist_space_range(&snap->ds->ds_deadlist,\n\t\t    mintxg, UINT64_MAX, &used, &comp, &uncomp);\n\t\t*spacep += used;\n\t}\n\treturn (0);\n}\n\nstatic void\nsnaplist_destroy(list_t *l, const void *tag)\n{\n\tstruct promotenode *snap;\n\n\tif (l == NULL || !list_link_active(&l->list_head))\n\t\treturn;\n\n\twhile ((snap = list_remove_tail(l)) != NULL) {\n\t\tdsl_dataset_rele(snap->ds, tag);\n\t\tkmem_free(snap, sizeof (*snap));\n\t}\n\tlist_destroy(l);\n}\n\nstatic int\npromote_hold(dsl_dataset_promote_arg_t *ddpa, dsl_pool_t *dp, const void *tag)\n{\n\tint error;\n\tdsl_dir_t *dd;\n\tstruct promotenode *snap;\n\n\terror = dsl_dataset_hold(dp, ddpa->ddpa_clonename, tag,\n\t    &ddpa->ddpa_clone);\n\tif (error != 0)\n\t\treturn (error);\n\tdd = ddpa->ddpa_clone->ds_dir;\n\n\tif (ddpa->ddpa_clone->ds_is_snapshot ||\n\t    !dsl_dir_is_clone(dd)) {\n\t\tdsl_dataset_rele(ddpa->ddpa_clone, tag);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\terror = snaplist_make(dp, 0, dsl_dir_phys(dd)->dd_origin_obj,\n\t    &ddpa->shared_snaps, tag);\n\tif (error != 0)\n\t\tgoto out;\n\n\terror = snaplist_make(dp, 0, ddpa->ddpa_clone->ds_object,\n\t    &ddpa->clone_snaps, tag);\n\tif (error != 0)\n\t\tgoto out;\n\n\tsnap = list_head(&ddpa->shared_snaps);\n\tASSERT3U(snap->ds->ds_object, ==, dsl_dir_phys(dd)->dd_origin_obj);\n\terror = snaplist_make(dp, dsl_dir_phys(dd)->dd_origin_obj,\n\t    dsl_dir_phys(snap->ds->ds_dir)->dd_head_dataset_obj,\n\t    &ddpa->origin_snaps, tag);\n\tif (error != 0)\n\t\tgoto out;\n\n\tif (dsl_dir_phys(snap->ds->ds_dir)->dd_origin_obj != 0) {\n\t\terror = dsl_dataset_hold_obj(dp,\n\t\t    dsl_dir_phys(snap->ds->ds_dir)->dd_origin_obj,\n\t\t    tag, &ddpa->origin_origin);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\t}\nout:\n\tif (error != 0)\n\t\tpromote_rele(ddpa, tag);\n\treturn (error);\n}\n\nstatic void\npromote_rele(dsl_dataset_promote_arg_t *ddpa, const void *tag)\n{\n\tsnaplist_destroy(&ddpa->shared_snaps, tag);\n\tsnaplist_destroy(&ddpa->clone_snaps, tag);\n\tsnaplist_destroy(&ddpa->origin_snaps, tag);\n\tif (ddpa->origin_origin != NULL)\n\t\tdsl_dataset_rele(ddpa->origin_origin, tag);\n\tdsl_dataset_rele(ddpa->ddpa_clone, tag);\n}\n\n \nint\ndsl_dataset_promote(const char *name, char *conflsnap)\n{\n\tdsl_dataset_promote_arg_t ddpa = { 0 };\n\tuint64_t numsnaps;\n\tint error;\n\tnvpair_t *snap_pair;\n\tobjset_t *os;\n\n\t \n\terror = dmu_objset_hold(name, FTAG, &os);\n\tif (error != 0)\n\t\treturn (error);\n\terror = zap_count(dmu_objset_pool(os)->dp_meta_objset,\n\t    dsl_dataset_phys(dmu_objset_ds(os))->ds_snapnames_zapobj,\n\t    &numsnaps);\n\tdmu_objset_rele(os, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\tddpa.ddpa_clonename = name;\n\tddpa.err_ds = fnvlist_alloc();\n\tddpa.cr = CRED();\n\tddpa.proc = curproc;\n\n\terror = dsl_sync_task(name, dsl_dataset_promote_check,\n\t    dsl_dataset_promote_sync, &ddpa,\n\t    2 + numsnaps, ZFS_SPACE_CHECK_RESERVED);\n\n\t \n\tsnap_pair = nvlist_next_nvpair(ddpa.err_ds, NULL);\n\tif (snap_pair != NULL && conflsnap != NULL)\n\t\t(void) strlcpy(conflsnap, nvpair_name(snap_pair),\n\t\t    ZFS_MAX_DATASET_NAME_LEN);\n\n\tfnvlist_free(ddpa.err_ds);\n\treturn (error);\n}\n\nint\ndsl_dataset_clone_swap_check_impl(dsl_dataset_t *clone,\n    dsl_dataset_t *origin_head, boolean_t force, void *owner, dmu_tx_t *tx)\n{\n\t \n\tuint64_t refquota_slack = (uint64_t)DMU_MAX_ACCESS *\n\t    spa_asize_inflation;\n\tint64_t unused_refres_delta;\n\n\t \n\tif (clone->ds_is_snapshot ||\n\t    origin_head->ds_is_snapshot)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (!force && clone->ds_prev != origin_head->ds_prev)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (clone->ds_prev != NULL &&\n\t    clone->ds_prev != clone->ds_dir->dd_pool->dp_origin_snap &&\n\t    origin_head->ds_dir != clone->ds_prev->ds_dir)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (clone->ds_dir->dd_parent != origin_head->ds_dir)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (!force &&\n\t    dsl_dataset_modified_since_snap(origin_head, origin_head->ds_prev))\n\t\treturn (SET_ERROR(ETXTBSY));\n\n\t \n\tif (dsl_dataset_handoff_check(origin_head, owner, tx))\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tunused_refres_delta =\n\t    (int64_t)MIN(origin_head->ds_reserved,\n\t    dsl_dataset_phys(origin_head)->ds_unique_bytes) -\n\t    (int64_t)MIN(origin_head->ds_reserved,\n\t    dsl_dataset_phys(clone)->ds_unique_bytes);\n\n\tif (unused_refres_delta > 0 &&\n\t    unused_refres_delta >\n\t    dsl_dir_space_available(origin_head->ds_dir, NULL, 0, TRUE))\n\t\treturn (SET_ERROR(ENOSPC));\n\n\t \n\tif (origin_head->ds_quota != 0 &&\n\t    dsl_dataset_phys(clone)->ds_referenced_bytes >\n\t    origin_head->ds_quota + refquota_slack)\n\t\treturn (SET_ERROR(EDQUOT));\n\n\treturn (0);\n}\n\nstatic void\ndsl_dataset_swap_remap_deadlists(dsl_dataset_t *clone,\n    dsl_dataset_t *origin, dmu_tx_t *tx)\n{\n\tuint64_t clone_remap_dl_obj, origin_remap_dl_obj;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\tASSERT(dsl_pool_sync_context(dp));\n\n\tclone_remap_dl_obj = dsl_dataset_get_remap_deadlist_object(clone);\n\torigin_remap_dl_obj = dsl_dataset_get_remap_deadlist_object(origin);\n\n\tif (clone_remap_dl_obj != 0) {\n\t\tdsl_deadlist_close(&clone->ds_remap_deadlist);\n\t\tdsl_dataset_unset_remap_deadlist_object(clone, tx);\n\t}\n\tif (origin_remap_dl_obj != 0) {\n\t\tdsl_deadlist_close(&origin->ds_remap_deadlist);\n\t\tdsl_dataset_unset_remap_deadlist_object(origin, tx);\n\t}\n\n\tif (clone_remap_dl_obj != 0) {\n\t\tdsl_dataset_set_remap_deadlist_object(origin,\n\t\t    clone_remap_dl_obj, tx);\n\t\tdsl_deadlist_open(&origin->ds_remap_deadlist,\n\t\t    dp->dp_meta_objset, clone_remap_dl_obj);\n\t}\n\tif (origin_remap_dl_obj != 0) {\n\t\tdsl_dataset_set_remap_deadlist_object(clone,\n\t\t    origin_remap_dl_obj, tx);\n\t\tdsl_deadlist_open(&clone->ds_remap_deadlist,\n\t\t    dp->dp_meta_objset, origin_remap_dl_obj);\n\t}\n}\n\nvoid\ndsl_dataset_clone_swap_sync_impl(dsl_dataset_t *clone,\n    dsl_dataset_t *origin_head, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tint64_t unused_refres_delta;\n\n\tASSERT(clone->ds_reserved == 0);\n\t \n\tASSERT(origin_head->ds_quota == 0 ||\n\t    dsl_dataset_phys(clone)->ds_unique_bytes <= origin_head->ds_quota +\n\t    DMU_MAX_ACCESS * spa_asize_inflation);\n\tASSERT3P(clone->ds_prev, ==, origin_head->ds_prev);\n\n\tdsl_dir_cancel_waiters(origin_head->ds_dir);\n\n\t \n\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\tif (!(spa_feature_table[f].fi_flags &\n\t\t    ZFEATURE_FLAG_PER_DATASET)) {\n\t\t\tASSERT(!dsl_dataset_feature_is_active(clone, f));\n\t\t\tASSERT(!dsl_dataset_feature_is_active(origin_head, f));\n\t\t\tcontinue;\n\t\t}\n\n\t\tboolean_t clone_inuse = dsl_dataset_feature_is_active(clone, f);\n\t\tvoid *clone_feature = clone->ds_feature[f];\n\t\tboolean_t origin_head_inuse =\n\t\t    dsl_dataset_feature_is_active(origin_head, f);\n\t\tvoid *origin_head_feature = origin_head->ds_feature[f];\n\n\t\tif (clone_inuse)\n\t\t\tdsl_dataset_deactivate_feature_impl(clone, f, tx);\n\t\tif (origin_head_inuse)\n\t\t\tdsl_dataset_deactivate_feature_impl(origin_head, f, tx);\n\n\t\tif (clone_inuse) {\n\t\t\tdsl_dataset_activate_feature(origin_head->ds_object, f,\n\t\t\t    clone_feature, tx);\n\t\t\torigin_head->ds_feature[f] = clone_feature;\n\t\t}\n\t\tif (origin_head_inuse) {\n\t\t\tdsl_dataset_activate_feature(clone->ds_object, f,\n\t\t\t    origin_head_feature, tx);\n\t\t\tclone->ds_feature[f] = origin_head_feature;\n\t\t}\n\t}\n\n\tdmu_buf_will_dirty(clone->ds_dbuf, tx);\n\tdmu_buf_will_dirty(origin_head->ds_dbuf, tx);\n\n\tif (clone->ds_objset != NULL) {\n\t\tdmu_objset_evict(clone->ds_objset);\n\t\tclone->ds_objset = NULL;\n\t}\n\n\tif (origin_head->ds_objset != NULL) {\n\t\tdmu_objset_evict(origin_head->ds_objset);\n\t\torigin_head->ds_objset = NULL;\n\t}\n\n\tunused_refres_delta =\n\t    (int64_t)MIN(origin_head->ds_reserved,\n\t    dsl_dataset_phys(origin_head)->ds_unique_bytes) -\n\t    (int64_t)MIN(origin_head->ds_reserved,\n\t    dsl_dataset_phys(clone)->ds_unique_bytes);\n\n\t \n\t{\n\t\tdsl_dataset_t *origin = clone->ds_prev;\n\t\tuint64_t comp, uncomp;\n\n\t\tdmu_buf_will_dirty(origin->ds_dbuf, tx);\n\t\tdsl_deadlist_space_range(&clone->ds_deadlist,\n\t\t    dsl_dataset_phys(origin)->ds_prev_snap_txg, UINT64_MAX,\n\t\t    &dsl_dataset_phys(origin)->ds_unique_bytes, &comp, &uncomp);\n\t}\n\n\t \n\t{\n\t\trrw_enter(&clone->ds_bp_rwlock, RW_WRITER, FTAG);\n\t\trrw_enter(&origin_head->ds_bp_rwlock, RW_WRITER, FTAG);\n\t\tblkptr_t tmp;\n\t\ttmp = dsl_dataset_phys(origin_head)->ds_bp;\n\t\tdsl_dataset_phys(origin_head)->ds_bp =\n\t\t    dsl_dataset_phys(clone)->ds_bp;\n\t\tdsl_dataset_phys(clone)->ds_bp = tmp;\n\t\trrw_exit(&origin_head->ds_bp_rwlock, FTAG);\n\t\trrw_exit(&clone->ds_bp_rwlock, FTAG);\n\t}\n\n\t \n\t{\n\t\tint64_t dused, dcomp, duncomp;\n\t\tuint64_t cdl_used, cdl_comp, cdl_uncomp;\n\t\tuint64_t odl_used, odl_comp, odl_uncomp;\n\n\t\tASSERT3U(dsl_dir_phys(clone->ds_dir)->\n\t\t    dd_used_breakdown[DD_USED_SNAP], ==, 0);\n\n\t\tdsl_deadlist_space(&clone->ds_deadlist,\n\t\t    &cdl_used, &cdl_comp, &cdl_uncomp);\n\t\tdsl_deadlist_space(&origin_head->ds_deadlist,\n\t\t    &odl_used, &odl_comp, &odl_uncomp);\n\n\t\tdused = dsl_dataset_phys(clone)->ds_referenced_bytes +\n\t\t    cdl_used -\n\t\t    (dsl_dataset_phys(origin_head)->ds_referenced_bytes +\n\t\t    odl_used);\n\t\tdcomp = dsl_dataset_phys(clone)->ds_compressed_bytes +\n\t\t    cdl_comp -\n\t\t    (dsl_dataset_phys(origin_head)->ds_compressed_bytes +\n\t\t    odl_comp);\n\t\tduncomp = dsl_dataset_phys(clone)->ds_uncompressed_bytes +\n\t\t    cdl_uncomp -\n\t\t    (dsl_dataset_phys(origin_head)->ds_uncompressed_bytes +\n\t\t    odl_uncomp);\n\n\t\tdsl_dir_diduse_space(origin_head->ds_dir, DD_USED_HEAD,\n\t\t    dused, dcomp, duncomp, tx);\n\t\tdsl_dir_diduse_space(clone->ds_dir, DD_USED_HEAD,\n\t\t    -dused, -dcomp, -duncomp, tx);\n\n\t\t \n\t\tdsl_deadlist_space_range(&clone->ds_deadlist,\n\t\t    origin_head->ds_dir->dd_origin_txg, UINT64_MAX,\n\t\t    &cdl_used, &cdl_comp, &cdl_uncomp);\n\t\tdsl_deadlist_space_range(&origin_head->ds_deadlist,\n\t\t    origin_head->ds_dir->dd_origin_txg, UINT64_MAX,\n\t\t    &odl_used, &odl_comp, &odl_uncomp);\n\t\tdsl_dir_transfer_space(origin_head->ds_dir, cdl_used - odl_used,\n\t\t    DD_USED_HEAD, DD_USED_SNAP, tx);\n\t}\n\n\t \n\tSWITCH64(dsl_dataset_phys(origin_head)->ds_referenced_bytes,\n\t    dsl_dataset_phys(clone)->ds_referenced_bytes);\n\tSWITCH64(dsl_dataset_phys(origin_head)->ds_compressed_bytes,\n\t    dsl_dataset_phys(clone)->ds_compressed_bytes);\n\tSWITCH64(dsl_dataset_phys(origin_head)->ds_uncompressed_bytes,\n\t    dsl_dataset_phys(clone)->ds_uncompressed_bytes);\n\tSWITCH64(dsl_dataset_phys(origin_head)->ds_unique_bytes,\n\t    dsl_dataset_phys(clone)->ds_unique_bytes);\n\n\t \n\tdsl_dir_diduse_space(origin_head->ds_dir, DD_USED_REFRSRV,\n\t    unused_refres_delta, 0, 0, tx);\n\n\t \n\tdsl_deadlist_close(&clone->ds_deadlist);\n\tdsl_deadlist_close(&origin_head->ds_deadlist);\n\tSWITCH64(dsl_dataset_phys(origin_head)->ds_deadlist_obj,\n\t    dsl_dataset_phys(clone)->ds_deadlist_obj);\n\tdsl_deadlist_open(&clone->ds_deadlist, dp->dp_meta_objset,\n\t    dsl_dataset_phys(clone)->ds_deadlist_obj);\n\tdsl_deadlist_open(&origin_head->ds_deadlist, dp->dp_meta_objset,\n\t    dsl_dataset_phys(origin_head)->ds_deadlist_obj);\n\tdsl_dataset_swap_remap_deadlists(clone, origin_head, tx);\n\n\t \n\tdsl_bookmark_next_changed(origin_head, origin_head->ds_prev, tx);\n\n\tdsl_scan_ds_clone_swapped(origin_head, clone, tx);\n\n\t \n\tdsl_dir_remove_livelist(clone->ds_dir, tx, B_TRUE);\n\tdsl_dir_remove_livelist(origin_head->ds_dir, tx, B_TRUE);\n\n\tspa_history_log_internal_ds(clone, \"clone swap\", tx,\n\t    \"parent=%s\", origin_head->ds_dir->dd_myname);\n}\n\n \nint\ndsl_dsobj_to_dsname(char *pname, uint64_t obj, char *buf)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tint error;\n\n\terror = dsl_pool_hold(pname, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold_obj(dp, obj, FTAG, &ds);\n\tif (error == 0) {\n\t\tdsl_dataset_name(ds, buf);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\tdsl_pool_rele(dp, FTAG);\n\n\treturn (error);\n}\n\nint\ndsl_dataset_check_quota(dsl_dataset_t *ds, boolean_t check_quota,\n    uint64_t asize, uint64_t inflight, uint64_t *used, uint64_t *ref_rsrv)\n{\n\tint error = 0;\n\n\tASSERT3S(asize, >, 0);\n\n\t \n\t*ref_rsrv = 0;\n\n\tmutex_enter(&ds->ds_lock);\n\t \n\tif (ds->ds_reserved > dsl_dataset_phys(ds)->ds_unique_bytes) {\n\t\tASSERT3U(*used, >=,\n\t\t    ds->ds_reserved - dsl_dataset_phys(ds)->ds_unique_bytes);\n\t\t*used -=\n\t\t    (ds->ds_reserved - dsl_dataset_phys(ds)->ds_unique_bytes);\n\t\t*ref_rsrv =\n\t\t    asize - MIN(asize, parent_delta(ds, asize + inflight));\n\t}\n\n\tif (!check_quota || ds->ds_quota == 0) {\n\t\tmutex_exit(&ds->ds_lock);\n\t\treturn (0);\n\t}\n\t \n\tif (dsl_dataset_phys(ds)->ds_referenced_bytes + inflight >=\n\t    ds->ds_quota) {\n\t\tif (inflight > 0 ||\n\t\t    dsl_dataset_phys(ds)->ds_referenced_bytes < ds->ds_quota)\n\t\t\terror = SET_ERROR(ERESTART);\n\t\telse\n\t\t\terror = SET_ERROR(EDQUOT);\n\t}\n\tmutex_exit(&ds->ds_lock);\n\n\treturn (error);\n}\n\ntypedef struct dsl_dataset_set_qr_arg {\n\tconst char *ddsqra_name;\n\tzprop_source_t ddsqra_source;\n\tuint64_t ddsqra_value;\n} dsl_dataset_set_qr_arg_t;\n\n\nstatic int\ndsl_dataset_set_refquota_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tint error;\n\tuint64_t newval;\n\n\tif (spa_version(dp->dp_spa) < SPA_VERSION_REFQUOTA)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\terror = dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (ds->ds_is_snapshot) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\terror = dsl_prop_predict(ds->ds_dir,\n\t    zfs_prop_to_name(ZFS_PROP_REFQUOTA),\n\t    ddsqra->ddsqra_source, ddsqra->ddsqra_value, &newval);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (newval == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\tif (newval < dsl_dataset_phys(ds)->ds_referenced_bytes ||\n\t    newval < ds->ds_reserved) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(ENOSPC));\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nstatic void\ndsl_dataset_set_refquota_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds = NULL;\n\tuint64_t newval;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds));\n\n\tdsl_prop_set_sync_impl(ds,\n\t    zfs_prop_to_name(ZFS_PROP_REFQUOTA),\n\t    ddsqra->ddsqra_source, sizeof (ddsqra->ddsqra_value), 1,\n\t    &ddsqra->ddsqra_value, tx);\n\n\tVERIFY0(dsl_prop_get_int_ds(ds,\n\t    zfs_prop_to_name(ZFS_PROP_REFQUOTA), &newval));\n\n\tif (ds->ds_quota != newval) {\n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tds->ds_quota = newval;\n\t}\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dataset_set_refquota(const char *dsname, zprop_source_t source,\n    uint64_t refquota)\n{\n\tdsl_dataset_set_qr_arg_t ddsqra;\n\n\tddsqra.ddsqra_name = dsname;\n\tddsqra.ddsqra_source = source;\n\tddsqra.ddsqra_value = refquota;\n\n\treturn (dsl_sync_task(dsname, dsl_dataset_set_refquota_check,\n\t    dsl_dataset_set_refquota_sync, &ddsqra, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\nstatic int\ndsl_dataset_set_refreservation_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tint error;\n\tuint64_t newval, unique;\n\n\tif (spa_version(dp->dp_spa) < SPA_VERSION_REFRESERVATION)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\terror = dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (ds->ds_is_snapshot) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\terror = dsl_prop_predict(ds->ds_dir,\n\t    zfs_prop_to_name(ZFS_PROP_REFRESERVATION),\n\t    ddsqra->ddsqra_source, ddsqra->ddsqra_value, &newval);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (!dmu_tx_is_syncing(tx)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\tmutex_enter(&ds->ds_lock);\n\tif (!DS_UNIQUE_IS_ACCURATE(ds))\n\t\tdsl_dataset_recalc_head_uniq(ds);\n\tunique = dsl_dataset_phys(ds)->ds_unique_bytes;\n\tmutex_exit(&ds->ds_lock);\n\n\tif (MAX(unique, newval) > MAX(unique, ds->ds_reserved)) {\n\t\tuint64_t delta = MAX(unique, newval) -\n\t\t    MAX(unique, ds->ds_reserved);\n\n\t\tif (delta >\n\t\t    dsl_dir_space_available(ds->ds_dir, NULL, 0, B_TRUE) ||\n\t\t    (ds->ds_quota > 0 && newval > ds->ds_quota)) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (SET_ERROR(ENOSPC));\n\t\t}\n\t}\n\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nvoid\ndsl_dataset_set_refreservation_sync_impl(dsl_dataset_t *ds,\n    zprop_source_t source, uint64_t value, dmu_tx_t *tx)\n{\n\tuint64_t newval;\n\tuint64_t unique;\n\tint64_t delta;\n\n\tdsl_prop_set_sync_impl(ds, zfs_prop_to_name(ZFS_PROP_REFRESERVATION),\n\t    source, sizeof (value), 1, &value, tx);\n\n\tVERIFY0(dsl_prop_get_int_ds(ds,\n\t    zfs_prop_to_name(ZFS_PROP_REFRESERVATION), &newval));\n\n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tmutex_enter(&ds->ds_dir->dd_lock);\n\tmutex_enter(&ds->ds_lock);\n\tASSERT(DS_UNIQUE_IS_ACCURATE(ds));\n\tunique = dsl_dataset_phys(ds)->ds_unique_bytes;\n\tdelta = MAX(0, (int64_t)(newval - unique)) -\n\t    MAX(0, (int64_t)(ds->ds_reserved - unique));\n\tds->ds_reserved = newval;\n\tmutex_exit(&ds->ds_lock);\n\n\tdsl_dir_diduse_space(ds->ds_dir, DD_USED_REFRSRV, delta, 0, 0, tx);\n\tmutex_exit(&ds->ds_dir->dd_lock);\n}\n\nstatic void\ndsl_dataset_set_refreservation_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_set_qr_arg_t *ddsqra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds = NULL;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddsqra->ddsqra_name, FTAG, &ds));\n\tdsl_dataset_set_refreservation_sync_impl(ds,\n\t    ddsqra->ddsqra_source, ddsqra->ddsqra_value, tx);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dataset_set_refreservation(const char *dsname, zprop_source_t source,\n    uint64_t refreservation)\n{\n\tdsl_dataset_set_qr_arg_t ddsqra;\n\n\tddsqra.ddsqra_name = dsname;\n\tddsqra.ddsqra_source = source;\n\tddsqra.ddsqra_value = refreservation;\n\n\treturn (dsl_sync_task(dsname, dsl_dataset_set_refreservation_check,\n\t    dsl_dataset_set_refreservation_sync, &ddsqra, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\ntypedef struct dsl_dataset_set_compression_arg {\n\tconst char *ddsca_name;\n\tzprop_source_t ddsca_source;\n\tuint64_t ddsca_value;\n} dsl_dataset_set_compression_arg_t;\n\nstatic int\ndsl_dataset_set_compression_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_set_compression_arg_t *ddsca = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\tuint64_t compval = ZIO_COMPRESS_ALGO(ddsca->ddsca_value);\n\tspa_feature_t f = zio_compress_to_feature(compval);\n\n\tif (f == SPA_FEATURE_NONE)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (!spa_feature_is_enabled(dp->dp_spa, f))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\treturn (0);\n}\n\nstatic void\ndsl_dataset_set_compression_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_set_compression_arg_t *ddsca = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds = NULL;\n\n\tuint64_t compval = ZIO_COMPRESS_ALGO(ddsca->ddsca_value);\n\tspa_feature_t f = zio_compress_to_feature(compval);\n\tASSERT3S(f, !=, SPA_FEATURE_NONE);\n\tASSERT3S(spa_feature_table[f].fi_type, ==, ZFEATURE_TYPE_BOOLEAN);\n\n\tVERIFY0(dsl_dataset_hold(dp, ddsca->ddsca_name, FTAG, &ds));\n\tif (zfeature_active(f, ds->ds_feature[f]) != B_TRUE) {\n\t\tds->ds_feature_activation[f] = (void *)B_TRUE;\n\t\tdsl_dataset_activate_feature(ds->ds_object, f,\n\t\t    ds->ds_feature_activation[f], tx);\n\t\tds->ds_feature[f] = ds->ds_feature_activation[f];\n\t}\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_dataset_set_compression(const char *dsname, zprop_source_t source,\n    uint64_t compression)\n{\n\tdsl_dataset_set_compression_arg_t ddsca;\n\n\t \n\tif (ZIO_COMPRESS_ALGO(compression) != ZIO_COMPRESS_ZSTD)\n\t\treturn (0);\n\n\tddsca.ddsca_name = dsname;\n\tddsca.ddsca_source = source;\n\tddsca.ddsca_value = compression;\n\n\treturn (dsl_sync_task(dsname, dsl_dataset_set_compression_check,\n\t    dsl_dataset_set_compression_sync, &ddsca, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\n \nstatic int\ndsl_dataset_space_written_impl(zfs_bookmark_phys_t *bmp,\n    dsl_dataset_t *new, uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tint err = 0;\n\tdsl_pool_t *dp = new->ds_dir->dd_pool;\n\n\tASSERT(dsl_pool_config_held(dp));\n\tif (dsl_dataset_is_snapshot(new)) {\n\t\tASSERT3U(bmp->zbm_creation_txg, <,\n\t\t    dsl_dataset_phys(new)->ds_creation_txg);\n\t}\n\n\t*usedp = 0;\n\t*usedp += dsl_dataset_phys(new)->ds_referenced_bytes;\n\t*usedp -= bmp->zbm_referenced_bytes_refd;\n\n\t*compp = 0;\n\t*compp += dsl_dataset_phys(new)->ds_compressed_bytes;\n\t*compp -= bmp->zbm_compressed_bytes_refd;\n\n\t*uncompp = 0;\n\t*uncompp += dsl_dataset_phys(new)->ds_uncompressed_bytes;\n\t*uncompp -= bmp->zbm_uncompressed_bytes_refd;\n\n\tdsl_dataset_t *snap = new;\n\n\twhile (dsl_dataset_phys(snap)->ds_prev_snap_txg >\n\t    bmp->zbm_creation_txg) {\n\t\tuint64_t used, comp, uncomp;\n\n\t\tdsl_deadlist_space_range(&snap->ds_deadlist,\n\t\t    0, bmp->zbm_creation_txg,\n\t\t    &used, &comp, &uncomp);\n\t\t*usedp += used;\n\t\t*compp += comp;\n\t\t*uncompp += uncomp;\n\n\t\tuint64_t snapobj = dsl_dataset_phys(snap)->ds_prev_snap_obj;\n\t\tif (snap != new)\n\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\terr = dsl_dataset_hold_obj(dp, snapobj, FTAG, &snap);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (bmp->zbm_flags & ZBM_FLAG_HAS_FBN) {\n\t\t*usedp += bmp->zbm_referenced_freed_before_next_snap;\n\t\t*compp += bmp->zbm_compressed_freed_before_next_snap;\n\t\t*uncompp += bmp->zbm_uncompressed_freed_before_next_snap;\n\t} else {\n\t\tASSERT3U(dsl_dataset_phys(snap)->ds_prev_snap_txg, ==,\n\t\t    bmp->zbm_creation_txg);\n\t\tuint64_t used, comp, uncomp;\n\t\tdsl_deadlist_space(&snap->ds_deadlist, &used, &comp, &uncomp);\n\t\t*usedp += used;\n\t\t*compp += comp;\n\t\t*uncompp += uncomp;\n\t}\n\tif (snap != new)\n\t\tdsl_dataset_rele(snap, FTAG);\n\treturn (err);\n}\n\n \nint\ndsl_dataset_space_written_bookmark(zfs_bookmark_phys_t *bmp,\n    dsl_dataset_t *new, uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tif (!(bmp->zbm_flags & ZBM_FLAG_HAS_FBN))\n\t\treturn (SET_ERROR(ENOTSUP));\n\treturn (dsl_dataset_space_written_impl(bmp, new,\n\t    usedp, compp, uncompp));\n}\n\n \nint\ndsl_dataset_space_written(dsl_dataset_t *oldsnap, dsl_dataset_t *new,\n    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tif (!dsl_dataset_is_before(new, oldsnap, 0))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzfs_bookmark_phys_t zbm = { 0 };\n\tdsl_dataset_phys_t *dsp = dsl_dataset_phys(oldsnap);\n\tzbm.zbm_guid = dsp->ds_guid;\n\tzbm.zbm_creation_txg = dsp->ds_creation_txg;\n\tzbm.zbm_creation_time = dsp->ds_creation_time;\n\tzbm.zbm_referenced_bytes_refd = dsp->ds_referenced_bytes;\n\tzbm.zbm_compressed_bytes_refd = dsp->ds_compressed_bytes;\n\tzbm.zbm_uncompressed_bytes_refd = dsp->ds_uncompressed_bytes;\n\n\t \n\treturn (dsl_dataset_space_written_impl(&zbm, new,\n\t    usedp, compp, uncompp));\n}\n\n \nint\ndsl_dataset_space_wouldfree(dsl_dataset_t *firstsnap,\n    dsl_dataset_t *lastsnap,\n    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tint err = 0;\n\tuint64_t snapobj;\n\tdsl_pool_t *dp = firstsnap->ds_dir->dd_pool;\n\n\tASSERT(firstsnap->ds_is_snapshot);\n\tASSERT(lastsnap->ds_is_snapshot);\n\n\t \n\tif (firstsnap->ds_dir != lastsnap->ds_dir ||\n\t    dsl_dataset_phys(firstsnap)->ds_creation_txg >\n\t    dsl_dataset_phys(lastsnap)->ds_creation_txg)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t*usedp = *compp = *uncompp = 0;\n\n\tsnapobj = dsl_dataset_phys(lastsnap)->ds_next_snap_obj;\n\twhile (snapobj != firstsnap->ds_object) {\n\t\tdsl_dataset_t *ds;\n\t\tuint64_t used, comp, uncomp;\n\n\t\terr = dsl_dataset_hold_obj(dp, snapobj, FTAG, &ds);\n\t\tif (err != 0)\n\t\t\tbreak;\n\n\t\tdsl_deadlist_space_range(&ds->ds_deadlist,\n\t\t    dsl_dataset_phys(firstsnap)->ds_prev_snap_txg, UINT64_MAX,\n\t\t    &used, &comp, &uncomp);\n\t\t*usedp += used;\n\t\t*compp += comp;\n\t\t*uncompp += uncomp;\n\n\t\tsnapobj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t\tASSERT3U(snapobj, !=, 0);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\treturn (err);\n}\n\n \nboolean_t\ndsl_dataset_is_before(dsl_dataset_t *later, dsl_dataset_t *earlier,\n    uint64_t earlier_txg)\n{\n\tdsl_pool_t *dp = later->ds_dir->dd_pool;\n\tint error;\n\tboolean_t ret;\n\n\tASSERT(dsl_pool_config_held(dp));\n\tASSERT(earlier->ds_is_snapshot || earlier_txg != 0);\n\n\tif (earlier_txg == 0)\n\t\tearlier_txg = dsl_dataset_phys(earlier)->ds_creation_txg;\n\n\tif (later->ds_is_snapshot &&\n\t    earlier_txg >= dsl_dataset_phys(later)->ds_creation_txg)\n\t\treturn (B_FALSE);\n\n\tif (later->ds_dir == earlier->ds_dir)\n\t\treturn (B_TRUE);\n\n\t \n\tif (dsl_dir_phys(later->ds_dir)->dd_origin_obj == 0)\n\t\treturn (B_FALSE);\n\n\tdsl_dataset_t *origin;\n\terror = dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(later->ds_dir)->dd_origin_obj, FTAG, &origin);\n\tif (error != 0)\n\t\treturn (B_FALSE);\n\tif (dsl_dataset_phys(origin)->ds_creation_txg == earlier_txg &&\n\t    origin->ds_dir == earlier->ds_dir) {\n\t\tdsl_dataset_rele(origin, FTAG);\n\t\treturn (B_TRUE);\n\t}\n\tret = dsl_dataset_is_before(origin, earlier, earlier_txg);\n\tdsl_dataset_rele(origin, FTAG);\n\treturn (ret);\n}\n\nvoid\ndsl_dataset_zapify(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tdmu_object_zapify(mos, ds->ds_object, DMU_OT_DSL_DATASET, tx);\n}\n\nboolean_t\ndsl_dataset_is_zapified(dsl_dataset_t *ds)\n{\n\tdmu_object_info_t doi;\n\n\tdmu_object_info_from_db(ds->ds_dbuf, &doi);\n\treturn (doi.doi_type == DMU_OTN_ZAP_METADATA);\n}\n\nboolean_t\ndsl_dataset_has_resume_receive_state(dsl_dataset_t *ds)\n{\n\treturn (dsl_dataset_is_zapified(ds) &&\n\t    zap_contains(ds->ds_dir->dd_pool->dp_meta_objset,\n\t    ds->ds_object, DS_FIELD_RESUME_TOGUID) == 0);\n}\n\nuint64_t\ndsl_dataset_get_remap_deadlist_object(dsl_dataset_t *ds)\n{\n\tuint64_t remap_deadlist_obj;\n\tint err;\n\n\tif (!dsl_dataset_is_zapified(ds))\n\t\treturn (0);\n\n\terr = zap_lookup(ds->ds_dir->dd_pool->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_REMAP_DEADLIST, sizeof (remap_deadlist_obj), 1,\n\t    &remap_deadlist_obj);\n\n\tif (err != 0) {\n\t\tVERIFY3S(err, ==, ENOENT);\n\t\treturn (0);\n\t}\n\n\tASSERT(remap_deadlist_obj != 0);\n\treturn (remap_deadlist_obj);\n}\n\nboolean_t\ndsl_dataset_remap_deadlist_exists(dsl_dataset_t *ds)\n{\n\tEQUIV(dsl_deadlist_is_open(&ds->ds_remap_deadlist),\n\t    dsl_dataset_get_remap_deadlist_object(ds) != 0);\n\treturn (dsl_deadlist_is_open(&ds->ds_remap_deadlist));\n}\n\nstatic void\ndsl_dataset_set_remap_deadlist_object(dsl_dataset_t *ds, uint64_t obj,\n    dmu_tx_t *tx)\n{\n\tASSERT(obj != 0);\n\tdsl_dataset_zapify(ds, tx);\n\tVERIFY0(zap_add(ds->ds_dir->dd_pool->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_REMAP_DEADLIST, sizeof (obj), 1, &obj, tx));\n}\n\nstatic void\ndsl_dataset_unset_remap_deadlist_object(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tVERIFY0(zap_remove(ds->ds_dir->dd_pool->dp_meta_objset,\n\t    ds->ds_object, DS_FIELD_REMAP_DEADLIST, tx));\n}\n\nvoid\ndsl_dataset_destroy_remap_deadlist(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tuint64_t remap_deadlist_object;\n\tspa_t *spa = ds->ds_dir->dd_pool->dp_spa;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dsl_dataset_remap_deadlist_exists(ds));\n\n\tremap_deadlist_object = ds->ds_remap_deadlist.dl_object;\n\tdsl_deadlist_close(&ds->ds_remap_deadlist);\n\tdsl_deadlist_free(spa_meta_objset(spa), remap_deadlist_object, tx);\n\tdsl_dataset_unset_remap_deadlist_object(ds, tx);\n\tspa_feature_decr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n}\n\nvoid\ndsl_dataset_create_remap_deadlist(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tuint64_t remap_deadlist_obj;\n\tspa_t *spa = ds->ds_dir->dd_pool->dp_spa;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(MUTEX_HELD(&ds->ds_remap_deadlist_lock));\n\t \n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_DEVICE_REMOVAL));\n\n\tremap_deadlist_obj = dsl_deadlist_clone(\n\t    &ds->ds_deadlist, UINT64_MAX,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, tx);\n\tdsl_dataset_set_remap_deadlist_object(ds,\n\t    remap_deadlist_obj, tx);\n\tdsl_deadlist_open(&ds->ds_remap_deadlist, spa_meta_objset(spa),\n\t    remap_deadlist_obj);\n\tspa_feature_incr(spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n}\n\nvoid\ndsl_dataset_activate_redaction(dsl_dataset_t *ds, uint64_t *redact_snaps,\n    uint64_t num_redact_snaps, dmu_tx_t *tx)\n{\n\tuint64_t dsobj = ds->ds_object;\n\tstruct feature_type_uint64_array_arg *ftuaa =\n\t    kmem_zalloc(sizeof (*ftuaa), KM_SLEEP);\n\tftuaa->length = (int64_t)num_redact_snaps;\n\tif (num_redact_snaps > 0) {\n\t\tftuaa->array = kmem_alloc(num_redact_snaps * sizeof (uint64_t),\n\t\t    KM_SLEEP);\n\t\tmemcpy(ftuaa->array, redact_snaps, num_redact_snaps *\n\t\t    sizeof (uint64_t));\n\t}\n\tdsl_dataset_activate_feature(dsobj, SPA_FEATURE_REDACTED_DATASETS,\n\t    ftuaa, tx);\n\tds->ds_feature[SPA_FEATURE_REDACTED_DATASETS] = ftuaa;\n}\n\n \nint\ndsl_dataset_oldest_snapshot(spa_t *spa, uint64_t head_ds, uint64_t min_txg,\n    uint64_t *oldest_dsobj)\n{\n\tdsl_dataset_t *ds;\n\tdsl_pool_t *dp = spa->spa_dsl_pool;\n\n\tint error = dsl_dataset_hold_obj(dp, head_ds, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\tuint64_t prev_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\tuint64_t prev_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\n\twhile (prev_obj != 0 && min_txg < prev_obj_txg) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tif ((error = dsl_dataset_hold_obj(dp, prev_obj,\n\t\t    FTAG, &ds)) != 0)\n\t\t\treturn (error);\n\t\tprev_obj_txg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t\tprev_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t}\n\t*oldest_dsobj = ds->ds_object;\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nZFS_MODULE_PARAM(zfs, zfs_, max_recordsize, UINT, ZMOD_RW,\n\t\"Max allowed record size\");\n\nZFS_MODULE_PARAM(zfs, zfs_, allow_redacted_dataset_mount, INT, ZMOD_RW,\n\t\"Allow mounting of redacted datasets\");\n\nZFS_MODULE_PARAM(zfs, zfs_, snapshot_history_enabled, INT, ZMOD_RW,\n\t\"Include snapshot events in pool history/events\");\n\nEXPORT_SYMBOL(dsl_dataset_hold);\nEXPORT_SYMBOL(dsl_dataset_hold_flags);\nEXPORT_SYMBOL(dsl_dataset_hold_obj);\nEXPORT_SYMBOL(dsl_dataset_hold_obj_flags);\nEXPORT_SYMBOL(dsl_dataset_own);\nEXPORT_SYMBOL(dsl_dataset_own_obj);\nEXPORT_SYMBOL(dsl_dataset_name);\nEXPORT_SYMBOL(dsl_dataset_rele);\nEXPORT_SYMBOL(dsl_dataset_rele_flags);\nEXPORT_SYMBOL(dsl_dataset_disown);\nEXPORT_SYMBOL(dsl_dataset_tryown);\nEXPORT_SYMBOL(dsl_dataset_create_sync);\nEXPORT_SYMBOL(dsl_dataset_create_sync_dd);\nEXPORT_SYMBOL(dsl_dataset_snapshot_check);\nEXPORT_SYMBOL(dsl_dataset_snapshot_sync);\nEXPORT_SYMBOL(dsl_dataset_promote);\nEXPORT_SYMBOL(dsl_dataset_user_hold);\nEXPORT_SYMBOL(dsl_dataset_user_release);\nEXPORT_SYMBOL(dsl_dataset_get_holds);\nEXPORT_SYMBOL(dsl_dataset_get_blkptr);\nEXPORT_SYMBOL(dsl_dataset_get_spa);\nEXPORT_SYMBOL(dsl_dataset_modified_since_snap);\nEXPORT_SYMBOL(dsl_dataset_space_written);\nEXPORT_SYMBOL(dsl_dataset_space_wouldfree);\nEXPORT_SYMBOL(dsl_dataset_sync);\nEXPORT_SYMBOL(dsl_dataset_block_born);\nEXPORT_SYMBOL(dsl_dataset_block_kill);\nEXPORT_SYMBOL(dsl_dataset_dirty);\nEXPORT_SYMBOL(dsl_dataset_stats);\nEXPORT_SYMBOL(dsl_dataset_fast_stat);\nEXPORT_SYMBOL(dsl_dataset_space);\nEXPORT_SYMBOL(dsl_dataset_fsid_guid);\nEXPORT_SYMBOL(dsl_dsobj_to_dsname);\nEXPORT_SYMBOL(dsl_dataset_check_quota);\nEXPORT_SYMBOL(dsl_dataset_clone_swap_check_impl);\nEXPORT_SYMBOL(dsl_dataset_clone_swap_sync_impl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}