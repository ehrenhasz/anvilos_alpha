{
  "module_name": "zfeature.c",
  "hash_id": "451c7fe6a0fd25e0586c581f6792dbaf975de7b3d8ab9b60dd0f196c6cc75f6f",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfeature.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/zfeature.h>\n#include <sys/dmu.h>\n#include <sys/nvpair.h>\n#include <sys/zap.h>\n#include <sys/dmu_tx.h>\n#include \"zfeature_common.h\"\n#include <sys/spa_impl.h>\n\n \n\ntypedef enum {\n\tFEATURE_ACTION_INCR,\n\tFEATURE_ACTION_DECR,\n} feature_action_t;\n\n \nboolean_t\nspa_features_check(spa_t *spa, boolean_t for_write,\n    nvlist_t *unsup_feat, nvlist_t *enabled_feat)\n{\n\tobjset_t *os = spa->spa_meta_objset;\n\tboolean_t supported;\n\tzap_cursor_t *zc;\n\tzap_attribute_t *za;\n\tuint64_t obj = for_write ?\n\t    spa->spa_feat_for_write_obj : spa->spa_feat_for_read_obj;\n\tchar *buf;\n\n\tzc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\tbuf = kmem_alloc(MAXPATHLEN, KM_SLEEP);\n\n\tsupported = B_TRUE;\n\tfor (zap_cursor_init(zc, os, obj);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\t\tASSERT(za->za_integer_length == sizeof (uint64_t) &&\n\t\t    za->za_num_integers == 1);\n\n\t\tif (NULL != enabled_feat) {\n\t\t\tfnvlist_add_uint64(enabled_feat, za->za_name,\n\t\t\t    za->za_first_integer);\n\t\t}\n\n\t\tif (za->za_first_integer != 0 &&\n\t\t    !zfeature_is_supported(za->za_name)) {\n\t\t\tsupported = B_FALSE;\n\n\t\t\tif (NULL != unsup_feat) {\n\t\t\t\tconst char *desc = \"\";\n\n\t\t\t\tif (zap_lookup(os, spa->spa_feat_desc_obj,\n\t\t\t\t    za->za_name, 1, MAXPATHLEN, buf) == 0)\n\t\t\t\t\tdesc = buf;\n\n\t\t\t\tVERIFY(nvlist_add_string(unsup_feat,\n\t\t\t\t    za->za_name, desc) == 0);\n\t\t\t}\n\t\t}\n\t}\n\tzap_cursor_fini(zc);\n\n\tkmem_free(buf, MAXPATHLEN);\n\tkmem_free(za, sizeof (zap_attribute_t));\n\tkmem_free(zc, sizeof (zap_cursor_t));\n\n\treturn (supported);\n}\n\n \nint\nfeature_get_refcount(spa_t *spa, zfeature_info_t *feature, uint64_t *res)\n{\n\tASSERT(VALID_FEATURE_FID(feature->fi_feature));\n\tif (spa->spa_feat_refcount_cache[feature->fi_feature] ==\n\t    SPA_FEATURE_DISABLED) {\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\t*res = spa->spa_feat_refcount_cache[feature->fi_feature];\n\treturn (0);\n}\n\n \nint\nfeature_get_refcount_from_disk(spa_t *spa, zfeature_info_t *feature,\n    uint64_t *res)\n{\n\tint err;\n\tuint64_t refcount;\n\tuint64_t zapobj = (feature->fi_flags & ZFEATURE_FLAG_READONLY_COMPAT) ?\n\t    spa->spa_feat_for_write_obj : spa->spa_feat_for_read_obj;\n\n\t \n\tif (zapobj == 0)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\terr = zap_lookup(spa->spa_meta_objset, zapobj,\n\t    feature->fi_guid, sizeof (uint64_t), 1, &refcount);\n\tif (err != 0) {\n\t\tif (err == ENOENT)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\telse\n\t\t\treturn (err);\n\t}\n\t*res = refcount;\n\treturn (0);\n}\n\n\nstatic int\nfeature_get_enabled_txg(spa_t *spa, zfeature_info_t *feature, uint64_t *res)\n{\n\tuint64_t enabled_txg_obj __maybe_unused = spa->spa_feat_enabled_txg_obj;\n\n\tASSERT(zfeature_depends_on(feature->fi_feature,\n\t    SPA_FEATURE_ENABLED_TXG));\n\n\tif (!spa_feature_is_enabled(spa, feature->fi_feature)) {\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\tASSERT(enabled_txg_obj != 0);\n\n\tVERIFY0(zap_lookup(spa->spa_meta_objset, spa->spa_feat_enabled_txg_obj,\n\t    feature->fi_guid, sizeof (uint64_t), 1, res));\n\n\treturn (0);\n}\n\n \nvoid\nfeature_sync(spa_t *spa, zfeature_info_t *feature, uint64_t refcount,\n    dmu_tx_t *tx)\n{\n\tASSERT(VALID_FEATURE_OR_NONE(feature->fi_feature));\n\tuint64_t zapobj = (feature->fi_flags & ZFEATURE_FLAG_READONLY_COMPAT) ?\n\t    spa->spa_feat_for_write_obj : spa->spa_feat_for_read_obj;\n\tVERIFY0(zap_update(spa->spa_meta_objset, zapobj, feature->fi_guid,\n\t    sizeof (uint64_t), 1, &refcount, tx));\n\n\t \n\tif (feature->fi_feature != SPA_FEATURE_NONE) {\n\t\tuint64_t *refcount_cache =\n\t\t    &spa->spa_feat_refcount_cache[feature->fi_feature];\n\t\tVERIFY3U(*refcount_cache, ==,\n\t\t    atomic_swap_64(refcount_cache, refcount));\n\t}\n\n\tif (refcount == 0)\n\t\tspa_deactivate_mos_feature(spa, feature->fi_guid);\n\telse if (feature->fi_flags & ZFEATURE_FLAG_MOS)\n\t\tspa_activate_mos_feature(spa, feature->fi_guid, tx);\n}\n\n \nvoid\nfeature_enable_sync(spa_t *spa, zfeature_info_t *feature, dmu_tx_t *tx)\n{\n\tuint64_t initial_refcount =\n\t    (feature->fi_flags & ZFEATURE_FLAG_ACTIVATE_ON_ENABLE) ? 1 : 0;\n\tuint64_t zapobj = (feature->fi_flags & ZFEATURE_FLAG_READONLY_COMPAT) ?\n\t    spa->spa_feat_for_write_obj : spa->spa_feat_for_read_obj;\n\n\tASSERT(0 != zapobj);\n\tASSERT(zfeature_is_valid_guid(feature->fi_guid));\n\tASSERT3U(spa_version(spa), >=, SPA_VERSION_FEATURES);\n\n\t \n\tif (zap_contains(spa->spa_meta_objset, zapobj, feature->fi_guid) == 0)\n\t\treturn;\n\n\tfor (int i = 0; feature->fi_depends[i] != SPA_FEATURE_NONE; i++)\n\t\tspa_feature_enable(spa, feature->fi_depends[i], tx);\n\n\tVERIFY0(zap_update(spa->spa_meta_objset, spa->spa_feat_desc_obj,\n\t    feature->fi_guid, 1, strlen(feature->fi_desc) + 1,\n\t    feature->fi_desc, tx));\n\n\tfeature_sync(spa, feature, initial_refcount, tx);\n\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_ENABLED_TXG)) {\n\t\tuint64_t enabling_txg = dmu_tx_get_txg(tx);\n\n\t\tif (spa->spa_feat_enabled_txg_obj == 0ULL) {\n\t\t\tspa->spa_feat_enabled_txg_obj =\n\t\t\t    zap_create_link(spa->spa_meta_objset,\n\t\t\t    DMU_OTN_ZAP_METADATA, DMU_POOL_DIRECTORY_OBJECT,\n\t\t\t    DMU_POOL_FEATURE_ENABLED_TXG, tx);\n\t\t}\n\t\tspa_feature_incr(spa, SPA_FEATURE_ENABLED_TXG, tx);\n\n\t\tVERIFY0(zap_add(spa->spa_meta_objset,\n\t\t    spa->spa_feat_enabled_txg_obj, feature->fi_guid,\n\t\t    sizeof (uint64_t), 1, &enabling_txg, tx));\n\t}\n\n\t \n\tif (spa->spa_errata == ZPOOL_ERRATA_ZOL_8308_ENCRYPTION &&\n\t    spa_feature_is_enabled(spa, SPA_FEATURE_ENCRYPTION) &&\n\t    !spa_feature_is_active(spa, SPA_FEATURE_ENCRYPTION) &&\n\t    feature->fi_feature == SPA_FEATURE_BOOKMARK_V2)\n\t\tspa->spa_errata = 0;\n\n\t \n\tif (feature->fi_feature == SPA_FEATURE_HEAD_ERRLOG)\n\t\tspa_upgrade_errlog(spa, tx);\n}\n\nstatic void\nfeature_do_action(spa_t *spa, spa_feature_t fid, feature_action_t action,\n    dmu_tx_t *tx)\n{\n\tuint64_t refcount = 0;\n\tzfeature_info_t *feature = &spa_feature_table[fid];\n\tuint64_t zapobj __maybe_unused =\n\t    (feature->fi_flags & ZFEATURE_FLAG_READONLY_COMPAT) ?\n\t    spa->spa_feat_for_write_obj : spa->spa_feat_for_read_obj;\n\n\tASSERT(VALID_FEATURE_FID(fid));\n\tASSERT(0 != zapobj);\n\tASSERT(zfeature_is_valid_guid(feature->fi_guid));\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT3U(spa_version(spa), >=, SPA_VERSION_FEATURES);\n\n\tVERIFY3U(feature_get_refcount(spa, feature, &refcount), !=, ENOTSUP);\n\n\tswitch (action) {\n\tcase FEATURE_ACTION_INCR:\n\t\tVERIFY3U(refcount, !=, UINT64_MAX);\n\t\trefcount++;\n\t\tbreak;\n\tcase FEATURE_ACTION_DECR:\n\t\tVERIFY3U(refcount, !=, 0);\n\t\trefcount--;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tfeature_sync(spa, feature, refcount, tx);\n}\n\nvoid\nspa_feature_create_zap_objects(spa_t *spa, dmu_tx_t *tx)\n{\n\t \n\tASSERT((!spa->spa_sync_on && tx->tx_txg == TXG_INITIAL) ||\n\t    dsl_pool_sync_context(spa_get_dsl(spa)));\n\n\tspa->spa_feat_for_read_obj = zap_create_link(spa->spa_meta_objset,\n\t    DMU_OTN_ZAP_METADATA, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_FEATURES_FOR_READ, tx);\n\tspa->spa_feat_for_write_obj = zap_create_link(spa->spa_meta_objset,\n\t    DMU_OTN_ZAP_METADATA, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_FEATURES_FOR_WRITE, tx);\n\tspa->spa_feat_desc_obj = zap_create_link(spa->spa_meta_objset,\n\t    DMU_OTN_ZAP_METADATA, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_FEATURE_DESCRIPTIONS, tx);\n}\n\n \nvoid\nspa_feature_enable(spa_t *spa, spa_feature_t fid, dmu_tx_t *tx)\n{\n\tASSERT3U(spa_version(spa), >=, SPA_VERSION_FEATURES);\n\tASSERT(VALID_FEATURE_FID(fid));\n\tfeature_enable_sync(spa, &spa_feature_table[fid], tx);\n}\n\nvoid\nspa_feature_incr(spa_t *spa, spa_feature_t fid, dmu_tx_t *tx)\n{\n\tfeature_do_action(spa, fid, FEATURE_ACTION_INCR, tx);\n}\n\nvoid\nspa_feature_decr(spa_t *spa, spa_feature_t fid, dmu_tx_t *tx)\n{\n\tfeature_do_action(spa, fid, FEATURE_ACTION_DECR, tx);\n}\n\nboolean_t\nspa_feature_is_enabled(spa_t *spa, spa_feature_t fid)\n{\n\tint err;\n\tuint64_t refcount = 0;\n\n\tASSERT(VALID_FEATURE_FID(fid));\n\tif (spa_version(spa) < SPA_VERSION_FEATURES)\n\t\treturn (B_FALSE);\n\n\terr = feature_get_refcount(spa, &spa_feature_table[fid], &refcount);\n\tASSERT(err == 0 || err == ENOTSUP);\n\treturn (err == 0);\n}\n\nboolean_t\nspa_feature_is_active(spa_t *spa, spa_feature_t fid)\n{\n\tint err;\n\tuint64_t refcount = 0;\n\n\tASSERT(VALID_FEATURE_FID(fid));\n\tif (spa_version(spa) < SPA_VERSION_FEATURES)\n\t\treturn (B_FALSE);\n\n\terr = feature_get_refcount(spa, &spa_feature_table[fid], &refcount);\n\tASSERT(err == 0 || err == ENOTSUP);\n\treturn (err == 0 && refcount > 0);\n}\n\n \nboolean_t\nspa_feature_enabled_txg(spa_t *spa, spa_feature_t fid, uint64_t *txg)\n{\n\tint err;\n\n\tASSERT(VALID_FEATURE_FID(fid));\n\tif (spa_version(spa) < SPA_VERSION_FEATURES)\n\t\treturn (B_FALSE);\n\n\terr = feature_get_enabled_txg(spa, &spa_feature_table[fid], txg);\n\tASSERT(err == 0 || err == ENOTSUP);\n\n\treturn (err == 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}