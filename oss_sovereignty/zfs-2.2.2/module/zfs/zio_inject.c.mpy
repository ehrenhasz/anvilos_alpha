{
  "module_name": "zio_inject.c",
  "hash_id": "d332e274bc9e7aa079a936d8503bfc4a6328af07e74b014c96d3d56291d53db6",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zio_inject.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/arc.h>\n#include <sys/zio.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/vdev_impl.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dataset.h>\n#include <sys/fs/zfs.h>\n\nuint32_t zio_injection_enabled = 0;\n\n \ntypedef struct inject_handler {\n\tint\t\t\tzi_id;\n\tspa_t\t\t\t*zi_spa;\n\tzinject_record_t\tzi_record;\n\tuint64_t\t\t*zi_lanes;\n\tint\t\t\tzi_next_lane;\n\tlist_node_t\t\tzi_link;\n} inject_handler_t;\n\n \nstatic list_t inject_handlers;\n\n \nstatic krwlock_t inject_lock;\n\n \nstatic int inject_delay_count = 0;\n\n \nstatic kmutex_t inject_delay_mtx;\n\n \nstatic int inject_next_id = 1;\n\n \nstatic boolean_t\nfreq_triggered(uint32_t frequency)\n{\n\t \n\tif (frequency == 0)\n\t\treturn (B_TRUE);\n\n\t \n\tuint32_t maximum = (frequency <= 100) ? 100 : ZI_PERCENTAGE_MAX;\n\n\treturn (random_in_range(maximum) < frequency);\n}\n\n \nstatic boolean_t\nzio_match_handler(const zbookmark_phys_t *zb, uint64_t type, int dva,\n    zinject_record_t *record, int error)\n{\n\t \n\tif (zb->zb_objset == DMU_META_OBJSET &&\n\t    record->zi_objset == DMU_META_OBJSET &&\n\t    record->zi_object == DMU_META_DNODE_OBJECT) {\n\t\tif (record->zi_type == DMU_OT_NONE ||\n\t\t    type == record->zi_type)\n\t\t\treturn (freq_triggered(record->zi_freq));\n\t\telse\n\t\t\treturn (B_FALSE);\n\t}\n\n\t \n\tif (zb->zb_objset == record->zi_objset &&\n\t    zb->zb_object == record->zi_object &&\n\t    zb->zb_level == record->zi_level &&\n\t    zb->zb_blkid >= record->zi_start &&\n\t    zb->zb_blkid <= record->zi_end &&\n\t    (record->zi_dvas == 0 ||\n\t    (dva != ZI_NO_DVA && (record->zi_dvas & (1ULL << dva)))) &&\n\t    error == record->zi_error) {\n\t\treturn (freq_triggered(record->zi_freq));\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nvoid\nzio_handle_panic_injection(spa_t *spa, const char *tag, uint64_t type)\n{\n\tinject_handler_t *handler;\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\n\t\tif (spa != handler->zi_spa)\n\t\t\tcontinue;\n\n\t\tif (handler->zi_record.zi_type == type &&\n\t\t    strcmp(tag, handler->zi_record.zi_func) == 0)\n\t\t\tpanic(\"Panic requested in function %s\\n\", tag);\n\t}\n\n\trw_exit(&inject_lock);\n}\n\n \nint\nzio_handle_decrypt_injection(spa_t *spa, const zbookmark_phys_t *zb,\n    uint64_t type, int error)\n{\n\tint ret = 0;\n\tinject_handler_t *handler;\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\n\t\tif (spa != handler->zi_spa ||\n\t\t    handler->zi_record.zi_cmd != ZINJECT_DECRYPT_FAULT)\n\t\t\tcontinue;\n\n\t\tif (zio_match_handler(zb, type, ZI_NO_DVA,\n\t\t    &handler->zi_record, error)) {\n\t\t\tret = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trw_exit(&inject_lock);\n\treturn (ret);\n}\n\n \nstatic int\nzio_match_dva(zio_t *zio)\n{\n\tint i = ZI_NO_DVA;\n\n\tif (zio->io_bp != NULL && zio->io_vd != NULL &&\n\t    zio->io_child_type == ZIO_CHILD_VDEV) {\n\t\tfor (i = BP_GET_NDVAS(zio->io_bp) - 1; i >= 0; i--) {\n\t\t\tdva_t *dva = &zio->io_bp->blk_dva[i];\n\t\t\tuint64_t off = DVA_GET_OFFSET(dva);\n\t\t\tvdev_t *vd = vdev_lookup_top(zio->io_spa,\n\t\t\t    DVA_GET_VDEV(dva));\n\n\t\t\t \n\t\t\tif (zio->io_vd->vdev_ops->vdev_op_leaf)\n\t\t\t\toff += VDEV_LABEL_START_SIZE;\n\n\t\t\tif (zio->io_vd == vd && zio->io_offset == off)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (i);\n}\n\n\n \nint\nzio_handle_fault_injection(zio_t *zio, int error)\n{\n\tint ret = 0;\n\tinject_handler_t *handler;\n\n\t \n\tif (zio->io_logical == NULL)\n\t\treturn (0);\n\n\t \n\tif (zio->io_type != ZIO_TYPE_READ)\n\t\treturn (0);\n\n\t \n\tif (zio->io_priority == ZIO_PRIORITY_REBUILD && error == ECKSUM)\n\t\treturn (0);\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\t\tif (zio->io_spa != handler->zi_spa ||\n\t\t    handler->zi_record.zi_cmd != ZINJECT_DATA_FAULT)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (zio_match_handler(&zio->io_logical->io_bookmark,\n\t\t    zio->io_bp ? BP_GET_TYPE(zio->io_bp) : DMU_OT_NONE,\n\t\t    zio_match_dva(zio), &handler->zi_record, error)) {\n\t\t\tret = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trw_exit(&inject_lock);\n\n\treturn (ret);\n}\n\n \nint\nzio_handle_label_injection(zio_t *zio, int error)\n{\n\tinject_handler_t *handler;\n\tvdev_t *vd = zio->io_vd;\n\tuint64_t offset = zio->io_offset;\n\tint label;\n\tint ret = 0;\n\n\tif (offset >= VDEV_LABEL_START_SIZE &&\n\t    offset < vd->vdev_psize - VDEV_LABEL_END_SIZE)\n\t\treturn (0);\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\t\tuint64_t start = handler->zi_record.zi_start;\n\t\tuint64_t end = handler->zi_record.zi_end;\n\n\t\tif (handler->zi_record.zi_cmd != ZINJECT_LABEL_FAULT)\n\t\t\tcontinue;\n\n\t\t \n\t\tlabel = vdev_label_number(vd->vdev_psize, offset);\n\t\tstart = vdev_label_offset(vd->vdev_psize, label, start);\n\t\tend = vdev_label_offset(vd->vdev_psize, label, end);\n\n\t\tif (zio->io_vd->vdev_guid == handler->zi_record.zi_guid &&\n\t\t    (offset >= start && offset <= end)) {\n\t\t\tret = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\trw_exit(&inject_lock);\n\treturn (ret);\n}\n\nstatic int\nzio_inject_bitflip_cb(void *data, size_t len, void *private)\n{\n\tzio_t *zio = private;\n\tuint8_t *buffer = data;\n\tuint_t byte = random_in_range(len);\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\n\t \n\tbuffer[byte] ^= 1 << random_in_range(8);\n\n\treturn (1);\t \n}\n\nstatic int\nzio_handle_device_injection_impl(vdev_t *vd, zio_t *zio, int err1, int err2)\n{\n\tinject_handler_t *handler;\n\tint ret = 0;\n\n\t \n\tif (zio != NULL) {\n\t\tuint64_t offset = zio->io_offset;\n\n\t\tif (offset < VDEV_LABEL_START_SIZE ||\n\t\t    offset >= vd->vdev_psize - VDEV_LABEL_END_SIZE)\n\t\t\treturn (0);\n\t}\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\n\t\tif (handler->zi_record.zi_cmd != ZINJECT_DEVICE_FAULT)\n\t\t\tcontinue;\n\n\t\tif (vd->vdev_guid == handler->zi_record.zi_guid) {\n\t\t\tif (handler->zi_record.zi_failfast &&\n\t\t\t    (zio == NULL || (zio->io_flags &\n\t\t\t    (ZIO_FLAG_IO_RETRY | ZIO_FLAG_TRYHARD)))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (zio != NULL &&\n\t\t\t    handler->zi_record.zi_iotype != ZIO_TYPES &&\n\t\t\t    handler->zi_record.zi_iotype != zio->io_type)\n\t\t\t\tcontinue;\n\n\t\t\tif (handler->zi_record.zi_error == err1 ||\n\t\t\t    handler->zi_record.zi_error == err2) {\n\t\t\t\t \n\t\t\t\tif (!freq_triggered(handler->zi_record.zi_freq))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (err1 == ENXIO)\n\t\t\t\t\tvd->vdev_stat.vs_aux =\n\t\t\t\t\t    VDEV_AUX_OPEN_FAILED;\n\n\t\t\t\t \n\t\t\t\tif (!handler->zi_record.zi_failfast &&\n\t\t\t\t    zio != NULL)\n\t\t\t\t\tzio->io_flags |= ZIO_FLAG_IO_RETRY;\n\n\t\t\t\t \n\t\t\t\tif (handler->zi_record.zi_error == EILSEQ) {\n\t\t\t\t\tif (zio == NULL)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t \n\t\t\t\t\t(void) abd_iterate_func(zio->io_abd, 0,\n\t\t\t\t\t    zio->io_size, zio_inject_bitflip_cb,\n\t\t\t\t\t    zio);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = handler->zi_record.zi_error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handler->zi_record.zi_error == ENXIO) {\n\t\t\t\tret = SET_ERROR(EIO);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trw_exit(&inject_lock);\n\n\treturn (ret);\n}\n\nint\nzio_handle_device_injection(vdev_t *vd, zio_t *zio, int error)\n{\n\treturn (zio_handle_device_injection_impl(vd, zio, error, INT_MAX));\n}\n\nint\nzio_handle_device_injections(vdev_t *vd, zio_t *zio, int err1, int err2)\n{\n\treturn (zio_handle_device_injection_impl(vd, zio, err1, err2));\n}\n\n \nvoid\nzio_handle_ignored_writes(zio_t *zio)\n{\n\tinject_handler_t *handler;\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\n\t\t \n\t\tif (zio->io_spa != handler->zi_spa ||\n\t\t    handler->zi_record.zi_cmd != ZINJECT_IGNORED_WRITES)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (handler->zi_record.zi_timer == 0) {\n\t\t\tif (handler->zi_record.zi_duration > 0)\n\t\t\t\thandler->zi_record.zi_timer = ddi_get_lbolt64();\n\t\t\telse\n\t\t\t\thandler->zi_record.zi_timer = zio->io_txg;\n\t\t}\n\n\t\t \n\t\tif (random_in_range(100) < 60)\n\t\t\tzio->io_pipeline &= ~ZIO_VDEV_IO_STAGES;\n\t\tbreak;\n\t}\n\n\trw_exit(&inject_lock);\n}\n\nvoid\nspa_handle_ignored_writes(spa_t *spa)\n{\n\tinject_handler_t *handler;\n\n\tif (zio_injection_enabled == 0)\n\t\treturn;\n\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler)) {\n\n\t\tif (spa != handler->zi_spa ||\n\t\t    handler->zi_record.zi_cmd != ZINJECT_IGNORED_WRITES)\n\t\t\tcontinue;\n\n\t\tif (handler->zi_record.zi_duration > 0) {\n\t\t\tVERIFY(handler->zi_record.zi_timer == 0 ||\n\t\t\t    ddi_time_after64(\n\t\t\t    (int64_t)handler->zi_record.zi_timer +\n\t\t\t    handler->zi_record.zi_duration * hz,\n\t\t\t    ddi_get_lbolt64()));\n\t\t} else {\n\t\t\t \n\t\t\tVERIFY(handler->zi_record.zi_timer == 0 ||\n\t\t\t    handler->zi_record.zi_timer -\n\t\t\t    handler->zi_record.zi_duration >=\n\t\t\t    spa_syncing_txg(spa));\n\t\t}\n\t}\n\n\trw_exit(&inject_lock);\n}\n\nhrtime_t\nzio_handle_io_delay(zio_t *zio)\n{\n\tvdev_t *vd = zio->io_vd;\n\tinject_handler_t *min_handler = NULL;\n\thrtime_t min_target = 0;\n\n\trw_enter(&inject_lock, RW_READER);\n\n\t \n\tIMPLY(inject_delay_count > 0, zio_injection_enabled > 0);\n\tIMPLY(zio_injection_enabled == 0, inject_delay_count == 0);\n\n\t \n\tif (inject_delay_count == 0) {\n\t\trw_exit(&inject_lock);\n\t\treturn (0);\n\t}\n\n\t \n\tmutex_enter(&inject_delay_mtx);\n\n\tfor (inject_handler_t *handler = list_head(&inject_handlers);\n\t    handler != NULL; handler = list_next(&inject_handlers, handler)) {\n\t\tif (handler->zi_record.zi_cmd != ZINJECT_DELAY_IO)\n\t\t\tcontinue;\n\n\t\tif (!freq_triggered(handler->zi_record.zi_freq))\n\t\t\tcontinue;\n\n\t\tif (vd->vdev_guid != handler->zi_record.zi_guid)\n\t\t\tcontinue;\n\n\t\t \n\t\tASSERT3P(handler->zi_lanes, !=, NULL);\n\n\t\t \n\t\tASSERT3U(handler->zi_record.zi_nlanes, !=, 0);\n\n\t\tASSERT3U(handler->zi_record.zi_nlanes, >,\n\t\t    handler->zi_next_lane);\n\n\t\t \n\t\thrtime_t idle = handler->zi_record.zi_timer + gethrtime();\n\t\thrtime_t busy = handler->zi_record.zi_timer +\n\t\t    handler->zi_lanes[handler->zi_next_lane];\n\t\thrtime_t target = MAX(idle, busy);\n\n\t\tif (min_handler == NULL) {\n\t\t\tmin_handler = handler;\n\t\t\tmin_target = target;\n\t\t\tcontinue;\n\t\t}\n\n\t\tASSERT3P(min_handler, !=, NULL);\n\t\tASSERT3U(min_target, !=, 0);\n\n\t\t \n\n\t\tif (target < min_target) {\n\t\t\tmin_handler = handler;\n\t\t\tmin_target = target;\n\t\t}\n\t}\n\n\t \n\tif (min_handler != NULL) {\n\t\tASSERT3U(min_target, !=, 0);\n\t\tmin_handler->zi_lanes[min_handler->zi_next_lane] = min_target;\n\n\t\t \n\t\tmin_handler->zi_next_lane = (min_handler->zi_next_lane + 1) %\n\t\t    min_handler->zi_record.zi_nlanes;\n\t}\n\n\tmutex_exit(&inject_delay_mtx);\n\trw_exit(&inject_lock);\n\n\treturn (min_target);\n}\n\nstatic int\nzio_calculate_range(const char *pool, zinject_record_t *record)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tobjset_t *os = NULL;\n\tdnode_t *dn = NULL;\n\tint error;\n\n\t \n\terror = dsl_pool_hold(pool, FTAG, &dp);\n\tif (error)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold_obj(dp, record->zi_objset, FTAG, &ds);\n\tdsl_pool_rele(dp, FTAG);\n\tif (error)\n\t\treturn (error);\n\n\terror = dmu_objset_from_ds(ds, &os);\n\tdsl_dataset_rele(ds, FTAG);\n\tif (error)\n\t\treturn (error);\n\n\terror = dnode_hold(os, record->zi_object, FTAG, &dn);\n\tif (error)\n\t\treturn (error);\n\n\t \n\tif (record->zi_start != 0 || record->zi_end != -1ULL) {\n\t\trecord->zi_start >>= dn->dn_datablkshift;\n\t\trecord->zi_end >>= dn->dn_datablkshift;\n\t}\n\tif (record->zi_level > 0) {\n\t\tif (record->zi_level >= dn->dn_nlevels) {\n\t\t\tdnode_rele(dn, FTAG);\n\t\t\treturn (SET_ERROR(EDOM));\n\t\t}\n\n\t\tif (record->zi_start != 0 || record->zi_end != 0) {\n\t\t\tint shift = dn->dn_indblkshift - SPA_BLKPTRSHIFT;\n\n\t\t\tfor (int level = record->zi_level; level > 0; level--) {\n\t\t\t\trecord->zi_start >>= shift;\n\t\t\t\trecord->zi_end >>= shift;\n\t\t\t}\n\t\t}\n\t}\n\n\tdnode_rele(dn, FTAG);\n\treturn (0);\n}\n\n \nint\nzio_inject_fault(char *name, int flags, int *id, zinject_record_t *record)\n{\n\tinject_handler_t *handler;\n\tint error;\n\tspa_t *spa;\n\n\t \n\tif (flags & ZINJECT_UNLOAD_SPA)\n\t\tif ((error = spa_reset(name)) != 0)\n\t\t\treturn (error);\n\n\tif (record->zi_cmd == ZINJECT_DELAY_IO) {\n\t\t \n\t\tif (record->zi_timer == 0 || record->zi_nlanes == 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (record->zi_nlanes >= UINT16_MAX)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (flags & ZINJECT_CALC_RANGE) {\n\t\terror = zio_calculate_range(name, record);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\tif (!(flags & ZINJECT_NULL)) {\n\t\t \n\t\tif ((spa = spa_inject_addref(name)) == NULL)\n\t\t\treturn (SET_ERROR(ENOENT));\n\n\t\thandler = kmem_alloc(sizeof (inject_handler_t), KM_SLEEP);\n\n\t\thandler->zi_spa = spa;\n\t\thandler->zi_record = *record;\n\n\t\tif (handler->zi_record.zi_cmd == ZINJECT_DELAY_IO) {\n\t\t\thandler->zi_lanes = kmem_zalloc(\n\t\t\t    sizeof (*handler->zi_lanes) *\n\t\t\t    handler->zi_record.zi_nlanes, KM_SLEEP);\n\t\t\thandler->zi_next_lane = 0;\n\t\t} else {\n\t\t\thandler->zi_lanes = NULL;\n\t\t\thandler->zi_next_lane = 0;\n\t\t}\n\n\t\trw_enter(&inject_lock, RW_WRITER);\n\n\t\t \n\t\tif (handler->zi_record.zi_cmd == ZINJECT_DELAY_IO) {\n\t\t\tASSERT3S(inject_delay_count, >=, 0);\n\t\t\tinject_delay_count++;\n\t\t\tASSERT3S(inject_delay_count, >, 0);\n\t\t}\n\n\t\t*id = handler->zi_id = inject_next_id++;\n\t\tlist_insert_tail(&inject_handlers, handler);\n\t\tatomic_inc_32(&zio_injection_enabled);\n\n\t\trw_exit(&inject_lock);\n\t}\n\n\t \n\tif (flags & ZINJECT_FLUSH_ARC)\n\t\t \n\t\tarc_flush(NULL, FALSE);\n\n\treturn (0);\n}\n\n \nint\nzio_inject_list_next(int *id, char *name, size_t buflen,\n    zinject_record_t *record)\n{\n\tinject_handler_t *handler;\n\tint ret;\n\n\tmutex_enter(&spa_namespace_lock);\n\trw_enter(&inject_lock, RW_READER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler))\n\t\tif (handler->zi_id > *id)\n\t\t\tbreak;\n\n\tif (handler) {\n\t\t*record = handler->zi_record;\n\t\t*id = handler->zi_id;\n\t\t(void) strlcpy(name, spa_name(handler->zi_spa), buflen);\n\t\tret = 0;\n\t} else {\n\t\tret = SET_ERROR(ENOENT);\n\t}\n\n\trw_exit(&inject_lock);\n\tmutex_exit(&spa_namespace_lock);\n\n\treturn (ret);\n}\n\n \nint\nzio_clear_fault(int id)\n{\n\tinject_handler_t *handler;\n\n\trw_enter(&inject_lock, RW_WRITER);\n\n\tfor (handler = list_head(&inject_handlers); handler != NULL;\n\t    handler = list_next(&inject_handlers, handler))\n\t\tif (handler->zi_id == id)\n\t\t\tbreak;\n\n\tif (handler == NULL) {\n\t\trw_exit(&inject_lock);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tif (handler->zi_record.zi_cmd == ZINJECT_DELAY_IO) {\n\t\tASSERT3S(inject_delay_count, >, 0);\n\t\tinject_delay_count--;\n\t\tASSERT3S(inject_delay_count, >=, 0);\n\t}\n\n\tlist_remove(&inject_handlers, handler);\n\trw_exit(&inject_lock);\n\n\tif (handler->zi_record.zi_cmd == ZINJECT_DELAY_IO) {\n\t\tASSERT3P(handler->zi_lanes, !=, NULL);\n\t\tkmem_free(handler->zi_lanes, sizeof (*handler->zi_lanes) *\n\t\t    handler->zi_record.zi_nlanes);\n\t} else {\n\t\tASSERT3P(handler->zi_lanes, ==, NULL);\n\t}\n\n\tspa_inject_delref(handler->zi_spa);\n\tkmem_free(handler, sizeof (inject_handler_t));\n\tatomic_dec_32(&zio_injection_enabled);\n\n\treturn (0);\n}\n\nvoid\nzio_inject_init(void)\n{\n\trw_init(&inject_lock, NULL, RW_DEFAULT, NULL);\n\tmutex_init(&inject_delay_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&inject_handlers, sizeof (inject_handler_t),\n\t    offsetof(inject_handler_t, zi_link));\n}\n\nvoid\nzio_inject_fini(void)\n{\n\tlist_destroy(&inject_handlers);\n\tmutex_destroy(&inject_delay_mtx);\n\trw_destroy(&inject_lock);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zio_injection_enabled);\nEXPORT_SYMBOL(zio_inject_fault);\nEXPORT_SYMBOL(zio_inject_list_next);\nEXPORT_SYMBOL(zio_clear_fault);\nEXPORT_SYMBOL(zio_handle_fault_injection);\nEXPORT_SYMBOL(zio_handle_device_injection);\nEXPORT_SYMBOL(zio_handle_label_injection);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}