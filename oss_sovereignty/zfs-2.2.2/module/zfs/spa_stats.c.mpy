{
  "module_name": "spa_stats.c",
  "hash_id": "747b334049151e3cb4442e4b236927f6f664597d5106f74a7a31462f72985c0b",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/spa_stats.c",
  "human_readable_source": " \n\n#include <sys/zfs_context.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev_impl.h>\n#include <sys/spa.h>\n#include <zfs_comutil.h>\n\n \nstatic uint_t zfs_read_history = B_FALSE;\n\n \nstatic int zfs_read_history_hits = B_FALSE;\n\n \nstatic uint_t zfs_txg_history = 100;\n\n \nstatic uint_t zfs_multihost_history = B_FALSE;\n\n \n\n \ntypedef struct spa_read_history {\n\thrtime_t\tstart;\t\t \n\tuint64_t\tobjset;\t\t \n\tuint64_t\tobject;\t\t \n\tuint64_t\tlevel;\t\t \n\tuint64_t\tblkid;\t\t \n\tchar\t\torigin[24];\t \n\tuint32_t\taflags;\t\t \n\tpid_t\t\tpid;\t\t \n\tchar\t\tcomm[16];\t \n\tprocfs_list_node_t\tsrh_node;\n} spa_read_history_t;\n\nstatic int\nspa_read_history_show_header(struct seq_file *f)\n{\n\tseq_printf(f, \"%-8s %-16s %-8s %-8s %-8s %-8s %-8s \"\n\t    \"%-24s %-8s %-16s\\n\", \"UID\", \"start\", \"objset\", \"object\",\n\t    \"level\", \"blkid\", \"aflags\", \"origin\", \"pid\", \"process\");\n\n\treturn (0);\n}\n\nstatic int\nspa_read_history_show(struct seq_file *f, void *data)\n{\n\tspa_read_history_t *srh = (spa_read_history_t *)data;\n\n\tseq_printf(f, \"%-8llu %-16llu 0x%-6llx \"\n\t    \"%-8lli %-8lli %-8lli 0x%-6x %-24s %-8i %-16s\\n\",\n\t    (u_longlong_t)srh->srh_node.pln_id, srh->start,\n\t    (longlong_t)srh->objset, (longlong_t)srh->object,\n\t    (longlong_t)srh->level, (longlong_t)srh->blkid,\n\t    srh->aflags, srh->origin, srh->pid, srh->comm);\n\n\treturn (0);\n}\n\n \nstatic void\nspa_read_history_truncate(spa_history_list_t *shl, unsigned int size)\n{\n\tspa_read_history_t *srh;\n\twhile (shl->size > size) {\n\t\tsrh = list_remove_head(&shl->procfs_list.pl_list);\n\t\tASSERT3P(srh, !=, NULL);\n\t\tkmem_free(srh, sizeof (spa_read_history_t));\n\t\tshl->size--;\n\t}\n\n\tif (size == 0)\n\t\tASSERT(list_is_empty(&shl->procfs_list.pl_list));\n}\n\nstatic int\nspa_read_history_clear(procfs_list_t *procfs_list)\n{\n\tspa_history_list_t *shl = procfs_list->pl_private;\n\tmutex_enter(&procfs_list->pl_lock);\n\tspa_read_history_truncate(shl, 0);\n\tmutex_exit(&procfs_list->pl_lock);\n\treturn (0);\n}\n\nstatic void\nspa_read_history_init(spa_t *spa)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.read_history;\n\n\tshl->size = 0;\n\tshl->procfs_list.pl_private = shl;\n\tprocfs_list_install(\"zfs\",\n\t    spa_name(spa),\n\t    \"reads\",\n\t    0600,\n\t    &shl->procfs_list,\n\t    spa_read_history_show,\n\t    spa_read_history_show_header,\n\t    spa_read_history_clear,\n\t    offsetof(spa_read_history_t, srh_node));\n}\n\nstatic void\nspa_read_history_destroy(spa_t *spa)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.read_history;\n\tprocfs_list_uninstall(&shl->procfs_list);\n\tspa_read_history_truncate(shl, 0);\n\tprocfs_list_destroy(&shl->procfs_list);\n}\n\nvoid\nspa_read_history_add(spa_t *spa, const zbookmark_phys_t *zb, uint32_t aflags)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.read_history;\n\tspa_read_history_t *srh;\n\n\tASSERT3P(spa, !=, NULL);\n\tASSERT3P(zb,  !=, NULL);\n\n\tif (zfs_read_history == 0 && shl->size == 0)\n\t\treturn;\n\n\tif (zfs_read_history_hits == 0 && (aflags & ARC_FLAG_CACHED))\n\t\treturn;\n\n\tsrh = kmem_zalloc(sizeof (spa_read_history_t), KM_SLEEP);\n\tstrlcpy(srh->comm, getcomm(), sizeof (srh->comm));\n\tsrh->start  = gethrtime();\n\tsrh->objset = zb->zb_objset;\n\tsrh->object = zb->zb_object;\n\tsrh->level  = zb->zb_level;\n\tsrh->blkid  = zb->zb_blkid;\n\tsrh->aflags = aflags;\n\tsrh->pid    = getpid();\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\n\tprocfs_list_add(&shl->procfs_list, srh);\n\tshl->size++;\n\n\tspa_read_history_truncate(shl, zfs_read_history);\n\n\tmutex_exit(&shl->procfs_list.pl_lock);\n}\n\n \n\n \n\ntypedef struct spa_txg_history {\n\tuint64_t\ttxg;\t\t \n\ttxg_state_t\tstate;\t\t \n\tuint64_t\tnread;\t\t \n\tuint64_t\tnwritten;\t \n\tuint64_t\treads;\t\t \n\tuint64_t\twrites;\t\t \n\tuint64_t\tndirty;\t\t \n\thrtime_t\ttimes[TXG_STATE_COMMITTED];  \n\tprocfs_list_node_t\tsth_node;\n} spa_txg_history_t;\n\nstatic int\nspa_txg_history_show_header(struct seq_file *f)\n{\n\tseq_printf(f, \"%-8s %-16s %-5s %-12s %-12s %-12s \"\n\t    \"%-8s %-8s %-12s %-12s %-12s %-12s\\n\", \"txg\", \"birth\", \"state\",\n\t    \"ndirty\", \"nread\", \"nwritten\", \"reads\", \"writes\",\n\t    \"otime\", \"qtime\", \"wtime\", \"stime\");\n\treturn (0);\n}\n\nstatic int\nspa_txg_history_show(struct seq_file *f, void *data)\n{\n\tspa_txg_history_t *sth = (spa_txg_history_t *)data;\n\tuint64_t open = 0, quiesce = 0, wait = 0, sync = 0;\n\tchar state;\n\n\tswitch (sth->state) {\n\t\tcase TXG_STATE_BIRTH:\t\tstate = 'B';\tbreak;\n\t\tcase TXG_STATE_OPEN:\t\tstate = 'O';\tbreak;\n\t\tcase TXG_STATE_QUIESCED:\tstate = 'Q';\tbreak;\n\t\tcase TXG_STATE_WAIT_FOR_SYNC:\tstate = 'W';\tbreak;\n\t\tcase TXG_STATE_SYNCED:\t\tstate = 'S';\tbreak;\n\t\tcase TXG_STATE_COMMITTED:\tstate = 'C';\tbreak;\n\t\tdefault:\t\t\tstate = '?';\tbreak;\n\t}\n\n\tif (sth->times[TXG_STATE_OPEN])\n\t\topen = sth->times[TXG_STATE_OPEN] -\n\t\t    sth->times[TXG_STATE_BIRTH];\n\n\tif (sth->times[TXG_STATE_QUIESCED])\n\t\tquiesce = sth->times[TXG_STATE_QUIESCED] -\n\t\t    sth->times[TXG_STATE_OPEN];\n\n\tif (sth->times[TXG_STATE_WAIT_FOR_SYNC])\n\t\twait = sth->times[TXG_STATE_WAIT_FOR_SYNC] -\n\t\t    sth->times[TXG_STATE_QUIESCED];\n\n\tif (sth->times[TXG_STATE_SYNCED])\n\t\tsync = sth->times[TXG_STATE_SYNCED] -\n\t\t    sth->times[TXG_STATE_WAIT_FOR_SYNC];\n\n\tseq_printf(f, \"%-8llu %-16llu %-5c %-12llu \"\n\t    \"%-12llu %-12llu %-8llu %-8llu %-12llu %-12llu %-12llu %-12llu\\n\",\n\t    (longlong_t)sth->txg, sth->times[TXG_STATE_BIRTH], state,\n\t    (u_longlong_t)sth->ndirty,\n\t    (u_longlong_t)sth->nread, (u_longlong_t)sth->nwritten,\n\t    (u_longlong_t)sth->reads, (u_longlong_t)sth->writes,\n\t    (u_longlong_t)open, (u_longlong_t)quiesce, (u_longlong_t)wait,\n\t    (u_longlong_t)sync);\n\n\treturn (0);\n}\n\n \nstatic void\nspa_txg_history_truncate(spa_history_list_t *shl, unsigned int size)\n{\n\tspa_txg_history_t *sth;\n\twhile (shl->size > size) {\n\t\tsth = list_remove_head(&shl->procfs_list.pl_list);\n\t\tASSERT3P(sth, !=, NULL);\n\t\tkmem_free(sth, sizeof (spa_txg_history_t));\n\t\tshl->size--;\n\t}\n\n\tif (size == 0)\n\t\tASSERT(list_is_empty(&shl->procfs_list.pl_list));\n\n}\n\nstatic int\nspa_txg_history_clear(procfs_list_t *procfs_list)\n{\n\tspa_history_list_t *shl = procfs_list->pl_private;\n\tmutex_enter(&procfs_list->pl_lock);\n\tspa_txg_history_truncate(shl, 0);\n\tmutex_exit(&procfs_list->pl_lock);\n\treturn (0);\n}\n\nstatic void\nspa_txg_history_init(spa_t *spa)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.txg_history;\n\n\tshl->size = 0;\n\tshl->procfs_list.pl_private = shl;\n\tprocfs_list_install(\"zfs\",\n\t    spa_name(spa),\n\t    \"txgs\",\n\t    0644,\n\t    &shl->procfs_list,\n\t    spa_txg_history_show,\n\t    spa_txg_history_show_header,\n\t    spa_txg_history_clear,\n\t    offsetof(spa_txg_history_t, sth_node));\n}\n\nstatic void\nspa_txg_history_destroy(spa_t *spa)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.txg_history;\n\tprocfs_list_uninstall(&shl->procfs_list);\n\tspa_txg_history_truncate(shl, 0);\n\tprocfs_list_destroy(&shl->procfs_list);\n}\n\n \nvoid\nspa_txg_history_add(spa_t *spa, uint64_t txg, hrtime_t birth_time)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.txg_history;\n\tspa_txg_history_t *sth;\n\n\tif (zfs_txg_history == 0 && shl->size == 0)\n\t\treturn;\n\n\tsth = kmem_zalloc(sizeof (spa_txg_history_t), KM_SLEEP);\n\tsth->txg = txg;\n\tsth->state = TXG_STATE_OPEN;\n\tsth->times[TXG_STATE_BIRTH] = birth_time;\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\tprocfs_list_add(&shl->procfs_list, sth);\n\tshl->size++;\n\tspa_txg_history_truncate(shl, zfs_txg_history);\n\tmutex_exit(&shl->procfs_list.pl_lock);\n}\n\n \nint\nspa_txg_history_set(spa_t *spa, uint64_t txg, txg_state_t completed_state,\n    hrtime_t completed_time)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.txg_history;\n\tspa_txg_history_t *sth;\n\tint error = ENOENT;\n\n\tif (zfs_txg_history == 0)\n\t\treturn (0);\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\tfor (sth = list_tail(&shl->procfs_list.pl_list); sth != NULL;\n\t    sth = list_prev(&shl->procfs_list.pl_list, sth)) {\n\t\tif (sth->txg == txg) {\n\t\t\tsth->times[completed_state] = completed_time;\n\t\t\tsth->state++;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_exit(&shl->procfs_list.pl_lock);\n\n\treturn (error);\n}\n\n \nstatic int\nspa_txg_history_set_io(spa_t *spa, uint64_t txg, uint64_t nread,\n    uint64_t nwritten, uint64_t reads, uint64_t writes, uint64_t ndirty)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.txg_history;\n\tspa_txg_history_t *sth;\n\tint error = ENOENT;\n\n\tif (zfs_txg_history == 0)\n\t\treturn (0);\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\tfor (sth = list_tail(&shl->procfs_list.pl_list); sth != NULL;\n\t    sth = list_prev(&shl->procfs_list.pl_list, sth)) {\n\t\tif (sth->txg == txg) {\n\t\t\tsth->nread = nread;\n\t\t\tsth->nwritten = nwritten;\n\t\t\tsth->reads = reads;\n\t\t\tsth->writes = writes;\n\t\t\tsth->ndirty = ndirty;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_exit(&shl->procfs_list.pl_lock);\n\n\treturn (error);\n}\n\ntxg_stat_t *\nspa_txg_history_init_io(spa_t *spa, uint64_t txg, dsl_pool_t *dp)\n{\n\ttxg_stat_t *ts;\n\n\tif (zfs_txg_history == 0)\n\t\treturn (NULL);\n\n\tts = kmem_alloc(sizeof (txg_stat_t), KM_SLEEP);\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tvdev_get_stats(spa->spa_root_vdev, &ts->vs1);\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\tts->txg = txg;\n\tts->ndirty = dp->dp_dirty_pertxg[txg & TXG_MASK];\n\n\tspa_txg_history_set(spa, txg, TXG_STATE_WAIT_FOR_SYNC, gethrtime());\n\n\treturn (ts);\n}\n\nvoid\nspa_txg_history_fini_io(spa_t *spa, txg_stat_t *ts)\n{\n\tif (ts == NULL)\n\t\treturn;\n\n\tif (zfs_txg_history == 0) {\n\t\tkmem_free(ts, sizeof (txg_stat_t));\n\t\treturn;\n\t}\n\n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\tvdev_get_stats(spa->spa_root_vdev, &ts->vs2);\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\tspa_txg_history_set(spa, ts->txg, TXG_STATE_SYNCED, gethrtime());\n\tspa_txg_history_set_io(spa, ts->txg,\n\t    ts->vs2.vs_bytes[ZIO_TYPE_READ] - ts->vs1.vs_bytes[ZIO_TYPE_READ],\n\t    ts->vs2.vs_bytes[ZIO_TYPE_WRITE] - ts->vs1.vs_bytes[ZIO_TYPE_WRITE],\n\t    ts->vs2.vs_ops[ZIO_TYPE_READ] - ts->vs1.vs_ops[ZIO_TYPE_READ],\n\t    ts->vs2.vs_ops[ZIO_TYPE_WRITE] - ts->vs1.vs_ops[ZIO_TYPE_WRITE],\n\t    ts->ndirty);\n\n\tkmem_free(ts, sizeof (txg_stat_t));\n}\n\n \n\n \n\n \nstatic int\nspa_tx_assign_update(kstat_t *ksp, int rw)\n{\n\tspa_t *spa = ksp->ks_private;\n\tspa_history_kstat_t *shk = &spa->spa_stats.tx_assign_histogram;\n\tint i;\n\n\tif (rw == KSTAT_WRITE) {\n\t\tfor (i = 0; i < shk->count; i++)\n\t\t\t((kstat_named_t *)shk->priv)[i].value.ui64 = 0;\n\t}\n\n\tfor (i = shk->count; i > 0; i--)\n\t\tif (((kstat_named_t *)shk->priv)[i-1].value.ui64 != 0)\n\t\t\tbreak;\n\n\tksp->ks_ndata = i;\n\tksp->ks_data_size = i * sizeof (kstat_named_t);\n\n\treturn (0);\n}\n\nstatic void\nspa_tx_assign_init(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.tx_assign_histogram;\n\tchar *name;\n\tkstat_named_t *ks;\n\tkstat_t *ksp;\n\tint i;\n\n\tmutex_init(&shk->lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tshk->count = 42;  \n\tshk->size = shk->count * sizeof (kstat_named_t);\n\tshk->priv = kmem_alloc(shk->size, KM_SLEEP);\n\n\tname = kmem_asprintf(\"zfs/%s\", spa_name(spa));\n\n\tfor (i = 0; i < shk->count; i++) {\n\t\tks = &((kstat_named_t *)shk->priv)[i];\n\t\tks->data_type = KSTAT_DATA_UINT64;\n\t\tks->value.ui64 = 0;\n\t\t(void) snprintf(ks->name, KSTAT_STRLEN, \"%llu ns\",\n\t\t    (u_longlong_t)1 << i);\n\t}\n\n\tksp = kstat_create(name, 0, \"dmu_tx_assign\", \"misc\",\n\t    KSTAT_TYPE_NAMED, 0, KSTAT_FLAG_VIRTUAL);\n\tshk->kstat = ksp;\n\n\tif (ksp) {\n\t\tksp->ks_lock = &shk->lock;\n\t\tksp->ks_data = shk->priv;\n\t\tksp->ks_ndata = shk->count;\n\t\tksp->ks_data_size = shk->size;\n\t\tksp->ks_private = spa;\n\t\tksp->ks_update = spa_tx_assign_update;\n\t\tkstat_install(ksp);\n\t}\n\tkmem_strfree(name);\n}\n\nstatic void\nspa_tx_assign_destroy(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.tx_assign_histogram;\n\tkstat_t *ksp;\n\n\tksp = shk->kstat;\n\tif (ksp)\n\t\tkstat_delete(ksp);\n\n\tkmem_free(shk->priv, shk->size);\n\tmutex_destroy(&shk->lock);\n}\n\nvoid\nspa_tx_assign_add_nsecs(spa_t *spa, uint64_t nsecs)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.tx_assign_histogram;\n\tuint64_t idx = 0;\n\n\twhile (((1ULL << idx) < nsecs) && (idx < shk->size - 1))\n\t\tidx++;\n\n\tatomic_inc_64(&((kstat_named_t *)shk->priv)[idx].value.ui64);\n}\n\n \n\n \n\ntypedef struct spa_mmp_history {\n\tuint64_t\tmmp_node_id;\t \n\tuint64_t\ttxg;\t\t \n\tuint64_t\ttimestamp;\t \n\tuint64_t\tmmp_delay;\t \n\tuint64_t\tvdev_guid;\t \n\tchar\t\t*vdev_path;\n\tint\t\tvdev_label;\t \n\tint\t\tio_error;\t \n\thrtime_t\terror_start;\t \n\thrtime_t\tduration;\t \n\tprocfs_list_node_t\tsmh_node;\n} spa_mmp_history_t;\n\nstatic int\nspa_mmp_history_show_header(struct seq_file *f)\n{\n\tseq_printf(f, \"%-10s %-10s %-10s %-6s %-10s %-12s %-24s \"\n\t    \"%-10s %s\\n\", \"id\", \"txg\", \"timestamp\", \"error\", \"duration\",\n\t    \"mmp_delay\", \"vdev_guid\", \"vdev_label\", \"vdev_path\");\n\treturn (0);\n}\n\nstatic int\nspa_mmp_history_show(struct seq_file *f, void *data)\n{\n\tspa_mmp_history_t *smh = (spa_mmp_history_t *)data;\n\tchar skip_fmt[] = \"%-10llu %-10llu %10llu %#6llx %10lld %12llu %-24llu \"\n\t    \"%-10lld %s\\n\";\n\tchar write_fmt[] = \"%-10llu %-10llu %10llu %6lld %10lld %12llu %-24llu \"\n\t    \"%-10lld %s\\n\";\n\n\tseq_printf(f, (smh->error_start ? skip_fmt : write_fmt),\n\t    (u_longlong_t)smh->mmp_node_id, (u_longlong_t)smh->txg,\n\t    (u_longlong_t)smh->timestamp, (longlong_t)smh->io_error,\n\t    (longlong_t)smh->duration, (u_longlong_t)smh->mmp_delay,\n\t    (u_longlong_t)smh->vdev_guid, (u_longlong_t)smh->vdev_label,\n\t    (smh->vdev_path ? smh->vdev_path : \"-\"));\n\n\treturn (0);\n}\n\n \nstatic void\nspa_mmp_history_truncate(spa_history_list_t *shl, unsigned int size)\n{\n\tspa_mmp_history_t *smh;\n\twhile (shl->size > size) {\n\t\tsmh = list_remove_head(&shl->procfs_list.pl_list);\n\t\tif (smh->vdev_path)\n\t\t\tkmem_strfree(smh->vdev_path);\n\t\tkmem_free(smh, sizeof (spa_mmp_history_t));\n\t\tshl->size--;\n\t}\n\n\tif (size == 0)\n\t\tASSERT(list_is_empty(&shl->procfs_list.pl_list));\n\n}\n\nstatic int\nspa_mmp_history_clear(procfs_list_t *procfs_list)\n{\n\tspa_history_list_t *shl = procfs_list->pl_private;\n\tmutex_enter(&procfs_list->pl_lock);\n\tspa_mmp_history_truncate(shl, 0);\n\tmutex_exit(&procfs_list->pl_lock);\n\treturn (0);\n}\n\nstatic void\nspa_mmp_history_init(spa_t *spa)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.mmp_history;\n\n\tshl->size = 0;\n\n\tshl->procfs_list.pl_private = shl;\n\tprocfs_list_install(\"zfs\",\n\t    spa_name(spa),\n\t    \"multihost\",\n\t    0644,\n\t    &shl->procfs_list,\n\t    spa_mmp_history_show,\n\t    spa_mmp_history_show_header,\n\t    spa_mmp_history_clear,\n\t    offsetof(spa_mmp_history_t, smh_node));\n}\n\nstatic void\nspa_mmp_history_destroy(spa_t *spa)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.mmp_history;\n\tprocfs_list_uninstall(&shl->procfs_list);\n\tspa_mmp_history_truncate(shl, 0);\n\tprocfs_list_destroy(&shl->procfs_list);\n}\n\n \nint\nspa_mmp_history_set_skip(spa_t *spa, uint64_t mmp_node_id)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.mmp_history;\n\tspa_mmp_history_t *smh;\n\tint error = ENOENT;\n\n\tif (zfs_multihost_history == 0 && shl->size == 0)\n\t\treturn (0);\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\tfor (smh = list_tail(&shl->procfs_list.pl_list); smh != NULL;\n\t    smh = list_prev(&shl->procfs_list.pl_list, smh)) {\n\t\tif (smh->mmp_node_id == mmp_node_id) {\n\t\t\tASSERT3U(smh->io_error, !=, 0);\n\t\t\tsmh->duration = gethrtime() - smh->error_start;\n\t\t\tsmh->vdev_guid++;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_exit(&shl->procfs_list.pl_lock);\n\n\treturn (error);\n}\n\n \nint\nspa_mmp_history_set(spa_t *spa, uint64_t mmp_node_id, int io_error,\n    hrtime_t duration)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.mmp_history;\n\tspa_mmp_history_t *smh;\n\tint error = ENOENT;\n\n\tif (zfs_multihost_history == 0 && shl->size == 0)\n\t\treturn (0);\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\tfor (smh = list_tail(&shl->procfs_list.pl_list); smh != NULL;\n\t    smh = list_prev(&shl->procfs_list.pl_list, smh)) {\n\t\tif (smh->mmp_node_id == mmp_node_id) {\n\t\t\tASSERT(smh->io_error == 0);\n\t\t\tsmh->io_error = io_error;\n\t\t\tsmh->duration = duration;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_exit(&shl->procfs_list.pl_lock);\n\n\treturn (error);\n}\n\n \nvoid\nspa_mmp_history_add(spa_t *spa, uint64_t txg, uint64_t timestamp,\n    uint64_t mmp_delay, vdev_t *vd, int label, uint64_t mmp_node_id,\n    int error)\n{\n\tspa_history_list_t *shl = &spa->spa_stats.mmp_history;\n\tspa_mmp_history_t *smh;\n\n\tif (zfs_multihost_history == 0 && shl->size == 0)\n\t\treturn;\n\n\tsmh = kmem_zalloc(sizeof (spa_mmp_history_t), KM_SLEEP);\n\tsmh->txg = txg;\n\tsmh->timestamp = timestamp;\n\tsmh->mmp_delay = mmp_delay;\n\tif (vd) {\n\t\tsmh->vdev_guid = vd->vdev_guid;\n\t\tif (vd->vdev_path)\n\t\t\tsmh->vdev_path = kmem_strdup(vd->vdev_path);\n\t}\n\tsmh->vdev_label = label;\n\tsmh->mmp_node_id = mmp_node_id;\n\n\tif (error) {\n\t\tsmh->io_error = error;\n\t\tsmh->error_start = gethrtime();\n\t\tsmh->vdev_guid = 1;\n\t}\n\n\tmutex_enter(&shl->procfs_list.pl_lock);\n\tprocfs_list_add(&shl->procfs_list, smh);\n\tshl->size++;\n\tspa_mmp_history_truncate(shl, zfs_multihost_history);\n\tmutex_exit(&shl->procfs_list.pl_lock);\n}\n\nstatic void *\nspa_state_addr(kstat_t *ksp, loff_t n)\n{\n\tif (n == 0)\n\t\treturn (ksp->ks_private);\t \n\treturn (NULL);\n}\n\nstatic int\nspa_state_data(char *buf, size_t size, void *data)\n{\n\tspa_t *spa = (spa_t *)data;\n\t(void) snprintf(buf, size, \"%s\\n\", spa_state_to_name(spa));\n\treturn (0);\n}\n\n \nstatic void\nspa_state_init(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.state;\n\tchar *name;\n\tkstat_t *ksp;\n\n\tmutex_init(&shk->lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tname = kmem_asprintf(\"zfs/%s\", spa_name(spa));\n\tksp = kstat_create(name, 0, \"state\", \"misc\",\n\t    KSTAT_TYPE_RAW, 0, KSTAT_FLAG_VIRTUAL);\n\n\tshk->kstat = ksp;\n\tif (ksp) {\n\t\tksp->ks_lock = &shk->lock;\n\t\tksp->ks_data = NULL;\n\t\tksp->ks_private = spa;\n\t\tksp->ks_flags |= KSTAT_FLAG_NO_HEADERS;\n\t\tkstat_set_raw_ops(ksp, NULL, spa_state_data, spa_state_addr);\n\t\tkstat_install(ksp);\n\t}\n\n\tkmem_strfree(name);\n}\n\nstatic int\nspa_guid_data(char *buf, size_t size, void *data)\n{\n\tspa_t *spa = (spa_t *)data;\n\t(void) snprintf(buf, size, \"%llu\\n\", (u_longlong_t)spa_guid(spa));\n\treturn (0);\n}\n\nstatic void\nspa_guid_init(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.guid;\n\tchar *name;\n\tkstat_t *ksp;\n\n\tmutex_init(&shk->lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tname = kmem_asprintf(\"zfs/%s\", spa_name(spa));\n\n\tksp = kstat_create(name, 0, \"guid\", \"misc\",\n\t    KSTAT_TYPE_RAW, 0, KSTAT_FLAG_VIRTUAL);\n\n\tshk->kstat = ksp;\n\tif (ksp) {\n\t\tksp->ks_lock = &shk->lock;\n\t\tksp->ks_data = NULL;\n\t\tksp->ks_private = spa;\n\t\tksp->ks_flags |= KSTAT_FLAG_NO_HEADERS;\n\t\tkstat_set_raw_ops(ksp, NULL, spa_guid_data, spa_state_addr);\n\t\tkstat_install(ksp);\n\t}\n\n\tkmem_strfree(name);\n}\n\nstatic void\nspa_health_destroy(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.state;\n\tkstat_t *ksp = shk->kstat;\n\tif (ksp)\n\t\tkstat_delete(ksp);\n\n\tmutex_destroy(&shk->lock);\n}\n\nstatic void\nspa_guid_destroy(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.guid;\n\tkstat_t *ksp = shk->kstat;\n\tif (ksp)\n\t\tkstat_delete(ksp);\n\n\tmutex_destroy(&shk->lock);\n}\n\nstatic const spa_iostats_t spa_iostats_template = {\n\t{ \"trim_extents_written\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"trim_bytes_written\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"trim_extents_skipped\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"trim_bytes_skipped\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"trim_extents_failed\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"trim_bytes_failed\",\t\t\tKSTAT_DATA_UINT64 },\n\t{ \"autotrim_extents_written\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"autotrim_bytes_written\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"autotrim_extents_skipped\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"autotrim_bytes_skipped\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"autotrim_extents_failed\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"autotrim_bytes_failed\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"simple_trim_extents_written\",\tKSTAT_DATA_UINT64 },\n\t{ \"simple_trim_bytes_written\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"simple_trim_extents_skipped\",\tKSTAT_DATA_UINT64 },\n\t{ \"simple_trim_bytes_skipped\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"simple_trim_extents_failed\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"simple_trim_bytes_failed\",\t\tKSTAT_DATA_UINT64 },\n};\n\n#define\tSPA_IOSTATS_ADD(stat, val) \\\n    atomic_add_64(&iostats->stat.value.ui64, (val));\n\nvoid\nspa_iostats_trim_add(spa_t *spa, trim_type_t type,\n    uint64_t extents_written, uint64_t bytes_written,\n    uint64_t extents_skipped, uint64_t bytes_skipped,\n    uint64_t extents_failed, uint64_t bytes_failed)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.iostats;\n\tkstat_t *ksp = shk->kstat;\n\tspa_iostats_t *iostats;\n\n\tif (ksp == NULL)\n\t\treturn;\n\n\tiostats = ksp->ks_data;\n\tif (type == TRIM_TYPE_MANUAL) {\n\t\tSPA_IOSTATS_ADD(trim_extents_written, extents_written);\n\t\tSPA_IOSTATS_ADD(trim_bytes_written, bytes_written);\n\t\tSPA_IOSTATS_ADD(trim_extents_skipped, extents_skipped);\n\t\tSPA_IOSTATS_ADD(trim_bytes_skipped, bytes_skipped);\n\t\tSPA_IOSTATS_ADD(trim_extents_failed, extents_failed);\n\t\tSPA_IOSTATS_ADD(trim_bytes_failed, bytes_failed);\n\t} else if (type == TRIM_TYPE_AUTO) {\n\t\tSPA_IOSTATS_ADD(autotrim_extents_written, extents_written);\n\t\tSPA_IOSTATS_ADD(autotrim_bytes_written, bytes_written);\n\t\tSPA_IOSTATS_ADD(autotrim_extents_skipped, extents_skipped);\n\t\tSPA_IOSTATS_ADD(autotrim_bytes_skipped, bytes_skipped);\n\t\tSPA_IOSTATS_ADD(autotrim_extents_failed, extents_failed);\n\t\tSPA_IOSTATS_ADD(autotrim_bytes_failed, bytes_failed);\n\t} else {\n\t\tSPA_IOSTATS_ADD(simple_trim_extents_written, extents_written);\n\t\tSPA_IOSTATS_ADD(simple_trim_bytes_written, bytes_written);\n\t\tSPA_IOSTATS_ADD(simple_trim_extents_skipped, extents_skipped);\n\t\tSPA_IOSTATS_ADD(simple_trim_bytes_skipped, bytes_skipped);\n\t\tSPA_IOSTATS_ADD(simple_trim_extents_failed, extents_failed);\n\t\tSPA_IOSTATS_ADD(simple_trim_bytes_failed, bytes_failed);\n\t}\n}\n\nstatic int\nspa_iostats_update(kstat_t *ksp, int rw)\n{\n\tif (rw == KSTAT_WRITE) {\n\t\tmemcpy(ksp->ks_data, &spa_iostats_template,\n\t\t    sizeof (spa_iostats_t));\n\t}\n\n\treturn (0);\n}\n\nstatic void\nspa_iostats_init(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.iostats;\n\n\tmutex_init(&shk->lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tchar *name = kmem_asprintf(\"zfs/%s\", spa_name(spa));\n\tkstat_t *ksp = kstat_create(name, 0, \"iostats\", \"misc\",\n\t    KSTAT_TYPE_NAMED, sizeof (spa_iostats_t) / sizeof (kstat_named_t),\n\t    KSTAT_FLAG_VIRTUAL);\n\n\tshk->kstat = ksp;\n\tif (ksp) {\n\t\tint size = sizeof (spa_iostats_t);\n\t\tksp->ks_lock = &shk->lock;\n\t\tksp->ks_private = spa;\n\t\tksp->ks_update = spa_iostats_update;\n\t\tksp->ks_data = kmem_alloc(size, KM_SLEEP);\n\t\tmemcpy(ksp->ks_data, &spa_iostats_template, size);\n\t\tkstat_install(ksp);\n\t}\n\n\tkmem_strfree(name);\n}\n\nstatic void\nspa_iostats_destroy(spa_t *spa)\n{\n\tspa_history_kstat_t *shk = &spa->spa_stats.iostats;\n\tkstat_t *ksp = shk->kstat;\n\tif (ksp) {\n\t\tkmem_free(ksp->ks_data, sizeof (spa_iostats_t));\n\t\tkstat_delete(ksp);\n\t}\n\n\tmutex_destroy(&shk->lock);\n}\n\nvoid\nspa_stats_init(spa_t *spa)\n{\n\tspa_read_history_init(spa);\n\tspa_txg_history_init(spa);\n\tspa_tx_assign_init(spa);\n\tspa_mmp_history_init(spa);\n\tspa_state_init(spa);\n\tspa_guid_init(spa);\n\tspa_iostats_init(spa);\n}\n\nvoid\nspa_stats_destroy(spa_t *spa)\n{\n\tspa_iostats_destroy(spa);\n\tspa_health_destroy(spa);\n\tspa_tx_assign_destroy(spa);\n\tspa_txg_history_destroy(spa);\n\tspa_read_history_destroy(spa);\n\tspa_mmp_history_destroy(spa);\n\tspa_guid_destroy(spa);\n}\n\nZFS_MODULE_PARAM(zfs, zfs_, read_history, UINT, ZMOD_RW,\n\t\"Historical statistics for the last N reads\");\n\nZFS_MODULE_PARAM(zfs, zfs_, read_history_hits, INT, ZMOD_RW,\n\t\"Include cache hits in read history\");\n\nZFS_MODULE_PARAM(zfs_txg, zfs_txg_, history, UINT, ZMOD_RW,\n\t\"Historical statistics for the last N txgs\");\n\nZFS_MODULE_PARAM(zfs_multihost, zfs_multihost_, history, UINT, ZMOD_RW,\n\t\"Historical statistics for last N multihost writes\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}