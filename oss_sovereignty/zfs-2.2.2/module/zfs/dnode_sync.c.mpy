{
  "module_name": "dnode_sync.c",
  "hash_id": "b1f819f3d15fb381c411b1a315049a0188627b3ee10d31d2c6e2e83938b587bd",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dnode_sync.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/dmu.h>\n#include <sys/dmu_tx.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_recv.h>\n#include <sys/dsl_dataset.h>\n#include <sys/spa.h>\n#include <sys/range_tree.h>\n#include <sys/zfeature.h>\n\nstatic void\ndnode_increase_indirection(dnode_t *dn, dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db;\n\tint txgoff = tx->tx_txg & TXG_MASK;\n\tint nblkptr = dn->dn_phys->dn_nblkptr;\n\tint old_toplvl = dn->dn_phys->dn_nlevels - 1;\n\tint new_level = dn->dn_next_nlevels[txgoff];\n\tint i;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\n\t \n\tASSERT(dn->dn_phys->dn_type != DMU_OT_NONE);\n\tASSERT(new_level > 1 && dn->dn_phys->dn_nlevels > 0);\n\n\tdb = dbuf_hold_level(dn, dn->dn_phys->dn_nlevels, 0, FTAG);\n\tASSERT(db != NULL);\n\n\tdn->dn_phys->dn_nlevels = new_level;\n\tdprintf(\"os=%p obj=%llu, increase to %d\\n\", dn->dn_objset,\n\t    (u_longlong_t)dn->dn_object, dn->dn_phys->dn_nlevels);\n\n\t \n\tdmu_buf_impl_t *children[DN_MAX_NBLKPTR];\n\tASSERT3U(nblkptr, <=, DN_MAX_NBLKPTR);\n\tfor (i = 0; i < nblkptr; i++) {\n\t\tchildren[i] = dbuf_find(dn->dn_objset, dn->dn_object,\n\t\t    old_toplvl, i, NULL);\n\t}\n\n\t \n\t(void) dbuf_read(db, NULL, DB_RF_MUST_SUCCEED|DB_RF_HAVESTRUCT);\n\tif (dn->dn_dbuf != NULL)\n\t\trw_enter(&dn->dn_dbuf->db_rwlock, RW_WRITER);\n\trw_enter(&db->db_rwlock, RW_WRITER);\n\tASSERT(db->db.db_data);\n\tASSERT(arc_released(db->db_buf));\n\tASSERT3U(sizeof (blkptr_t) * nblkptr, <=, db->db.db_size);\n\tmemcpy(db->db.db_data, dn->dn_phys->dn_blkptr,\n\t    sizeof (blkptr_t) * nblkptr);\n\tarc_buf_freeze(db->db_buf);\n\n\t \n\tfor (i = 0; i < nblkptr; i++) {\n\t\tdmu_buf_impl_t *child = children[i];\n\n\t\tif (child == NULL)\n\t\t\tcontinue;\n#ifdef\tZFS_DEBUG\n\t\tDB_DNODE_ENTER(child);\n\t\tASSERT3P(DB_DNODE(child), ==, dn);\n\t\tDB_DNODE_EXIT(child);\n#endif\t \n\t\tif (child->db_parent && child->db_parent != dn->dn_dbuf) {\n\t\t\tASSERT(child->db_parent->db_level == db->db_level);\n\t\t\tASSERT(child->db_blkptr !=\n\t\t\t    &dn->dn_phys->dn_blkptr[child->db_blkid]);\n\t\t\tmutex_exit(&child->db_mtx);\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(child->db_parent == NULL ||\n\t\t    child->db_parent == dn->dn_dbuf);\n\n\t\tchild->db_parent = db;\n\t\tdbuf_add_ref(db, child);\n\t\tif (db->db.db_data)\n\t\t\tchild->db_blkptr = (blkptr_t *)db->db.db_data + i;\n\t\telse\n\t\t\tchild->db_blkptr = NULL;\n\t\tdprintf_dbuf_bp(child, child->db_blkptr,\n\t\t    \"changed db_blkptr to new indirect %s\", \"\");\n\n\t\tmutex_exit(&child->db_mtx);\n\t}\n\n\tmemset(dn->dn_phys->dn_blkptr, 0, sizeof (blkptr_t) * nblkptr);\n\n\trw_exit(&db->db_rwlock);\n\tif (dn->dn_dbuf != NULL)\n\t\trw_exit(&dn->dn_dbuf->db_rwlock);\n\n\tdbuf_rele(db, FTAG);\n\n\trw_exit(&dn->dn_struct_rwlock);\n}\n\nstatic void\nfree_blocks(dnode_t *dn, blkptr_t *bp, int num, dmu_tx_t *tx)\n{\n\tdsl_dataset_t *ds = dn->dn_objset->os_dsl_dataset;\n\tuint64_t bytesfreed = 0;\n\n\tdprintf(\"ds=%p obj=%llx num=%d\\n\", ds, (u_longlong_t)dn->dn_object,\n\t    num);\n\n\tfor (int i = 0; i < num; i++, bp++) {\n\t\tif (BP_IS_HOLE(bp))\n\t\t\tcontinue;\n\n\t\tbytesfreed += dsl_dataset_block_kill(ds, bp, tx, B_FALSE);\n\t\tASSERT3U(bytesfreed, <=, DN_USED_BYTES(dn->dn_phys));\n\n\t\t \n\n\t\tuint64_t lsize = BP_GET_LSIZE(bp);\n\t\tdmu_object_type_t type = BP_GET_TYPE(bp);\n\t\tuint64_t lvl = BP_GET_LEVEL(bp);\n\n\t\tmemset(bp, 0, sizeof (blkptr_t));\n\n\t\tif (spa_feature_is_active(dn->dn_objset->os_spa,\n\t\t    SPA_FEATURE_HOLE_BIRTH)) {\n\t\t\tBP_SET_LSIZE(bp, lsize);\n\t\t\tBP_SET_TYPE(bp, type);\n\t\t\tBP_SET_LEVEL(bp, lvl);\n\t\t\tBP_SET_BIRTH(bp, dmu_tx_get_txg(tx), 0);\n\t\t}\n\t}\n\tdnode_diduse_space(dn, -bytesfreed);\n}\n\n#ifdef ZFS_DEBUG\nstatic void\nfree_verify(dmu_buf_impl_t *db, uint64_t start, uint64_t end, dmu_tx_t *tx)\n{\n\tuint64_t off, num, i, j;\n\tunsigned int epbs;\n\tint err;\n\tuint64_t txg = tx->tx_txg;\n\tdnode_t *dn;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\tepbs = dn->dn_phys->dn_indblkshift - SPA_BLKPTRSHIFT;\n\toff = start - (db->db_blkid << epbs);\n\tnum = end - start + 1;\n\n\tASSERT3U(dn->dn_phys->dn_indblkshift, >=, SPA_BLKPTRSHIFT);\n\tASSERT3U(end + 1, >=, start);\n\tASSERT3U(start, >=, (db->db_blkid << epbs));\n\tASSERT3U(db->db_level, >, 0);\n\tASSERT3U(db->db.db_size, ==, 1 << dn->dn_phys->dn_indblkshift);\n\tASSERT3U(off+num, <=, db->db.db_size >> SPA_BLKPTRSHIFT);\n\tASSERT(db->db_blkptr != NULL);\n\n\tfor (i = off; i < off+num; i++) {\n\t\tuint64_t *buf;\n\t\tdmu_buf_impl_t *child;\n\t\tdbuf_dirty_record_t *dr;\n\n\t\tASSERT(db->db_level == 1);\n\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\terr = dbuf_hold_impl(dn, db->db_level - 1,\n\t\t    (db->db_blkid << epbs) + i, TRUE, FALSE, FTAG, &child);\n\t\trw_exit(&dn->dn_struct_rwlock);\n\t\tif (err == ENOENT)\n\t\t\tcontinue;\n\t\tASSERT(err == 0);\n\t\tASSERT(child->db_level == 0);\n\t\tdr = dbuf_find_dirty_eq(child, txg);\n\n\t\t \n\t\tif (dr) {\n\t\t\tbuf = dr->dt.dl.dr_data->b_data;\n\t\t\tfor (j = 0; j < child->db.db_size >> 3; j++) {\n\t\t\t\tif (buf[j] != 0) {\n\t\t\t\t\tpanic(\"freed data not zero: \"\n\t\t\t\t\t    \"child=%p i=%llu off=%llu \"\n\t\t\t\t\t    \"num=%llu\\n\",\n\t\t\t\t\t    (void *)child, (u_longlong_t)i,\n\t\t\t\t\t    (u_longlong_t)off,\n\t\t\t\t\t    (u_longlong_t)num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmutex_enter(&child->db_mtx);\n\t\tbuf = child->db.db_data;\n\t\tif (buf != NULL && child->db_state != DB_FILL &&\n\t\t    list_is_empty(&child->db_dirty_records)) {\n\t\t\tfor (j = 0; j < child->db.db_size >> 3; j++) {\n\t\t\t\tif (buf[j] != 0) {\n\t\t\t\t\tpanic(\"freed data not zero: \"\n\t\t\t\t\t    \"child=%p i=%llu off=%llu \"\n\t\t\t\t\t    \"num=%llu\\n\",\n\t\t\t\t\t    (void *)child, (u_longlong_t)i,\n\t\t\t\t\t    (u_longlong_t)off,\n\t\t\t\t\t    (u_longlong_t)num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmutex_exit(&child->db_mtx);\n\n\t\tdbuf_rele(child, FTAG);\n\t}\n\tDB_DNODE_EXIT(db);\n}\n#endif\n\n \nstatic void\nfree_children(dmu_buf_impl_t *db, uint64_t blkid, uint64_t nblks,\n    boolean_t free_indirects, dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tblkptr_t *bp;\n\tdmu_buf_impl_t *subdb;\n\tuint64_t start, end, dbstart, dbend;\n\tunsigned int epbs, shift, i;\n\n\t \n\tif (db->db_state != DB_CACHED)\n\t\t(void) dbuf_read(db, NULL, DB_RF_MUST_SUCCEED);\n\n\t \n\tdb_lock_type_t dblt = dmu_buf_lock_parent(db, RW_READER, FTAG);\n\tVERIFY(BP_GET_FILL(db->db_blkptr) == 0 || db->db_dirtycnt > 0);\n\tdmu_buf_unlock_parent(db, dblt, FTAG);\n\n\tdbuf_release_bp(db);\n\tbp = db->db.db_data;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\tepbs = dn->dn_phys->dn_indblkshift - SPA_BLKPTRSHIFT;\n\tASSERT3U(epbs, <, 31);\n\tshift = (db->db_level - 1) * epbs;\n\tdbstart = db->db_blkid << epbs;\n\tstart = blkid >> shift;\n\tif (dbstart < start) {\n\t\tbp += start - dbstart;\n\t} else {\n\t\tstart = dbstart;\n\t}\n\tdbend = ((db->db_blkid + 1) << epbs) - 1;\n\tend = (blkid + nblks - 1) >> shift;\n\tif (dbend <= end)\n\t\tend = dbend;\n\n\tASSERT3U(start, <=, end);\n\n\tif (db->db_level == 1) {\n\t\tFREE_VERIFY(db, start, end, tx);\n\t\trw_enter(&db->db_rwlock, RW_WRITER);\n\t\tfree_blocks(dn, bp, end - start + 1, tx);\n\t\trw_exit(&db->db_rwlock);\n\t} else {\n\t\tfor (uint64_t id = start; id <= end; id++, bp++) {\n\t\t\tif (BP_IS_HOLE(bp))\n\t\t\t\tcontinue;\n\t\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\t\tVERIFY0(dbuf_hold_impl(dn, db->db_level - 1,\n\t\t\t    id, TRUE, FALSE, FTAG, &subdb));\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\tASSERT3P(bp, ==, subdb->db_blkptr);\n\n\t\t\tfree_children(subdb, blkid, nblks, free_indirects, tx);\n\t\t\tdbuf_rele(subdb, FTAG);\n\t\t}\n\t}\n\n\tif (free_indirects) {\n\t\trw_enter(&db->db_rwlock, RW_WRITER);\n\t\tfor (i = 0, bp = db->db.db_data; i < 1 << epbs; i++, bp++)\n\t\t\tASSERT(BP_IS_HOLE(bp));\n\t\tmemset(db->db.db_data, 0, db->db.db_size);\n\t\tfree_blocks(dn, db->db_blkptr, 1, tx);\n\t\trw_exit(&db->db_rwlock);\n\t}\n\n\tDB_DNODE_EXIT(db);\n\tarc_buf_freeze(db->db_buf);\n}\n\n \nstatic void\ndnode_sync_free_range_impl(dnode_t *dn, uint64_t blkid, uint64_t nblks,\n    boolean_t free_indirects, dmu_tx_t *tx)\n{\n\tblkptr_t *bp = dn->dn_phys->dn_blkptr;\n\tint dnlevel = dn->dn_phys->dn_nlevels;\n\tboolean_t trunc = B_FALSE;\n\n\tif (blkid > dn->dn_phys->dn_maxblkid)\n\t\treturn;\n\n\tASSERT(dn->dn_phys->dn_maxblkid < UINT64_MAX);\n\tif (blkid + nblks > dn->dn_phys->dn_maxblkid) {\n\t\tnblks = dn->dn_phys->dn_maxblkid - blkid + 1;\n\t\ttrunc = B_TRUE;\n\t}\n\n\t \n\tif (dnlevel == 1) {\n\t\tif (blkid >= dn->dn_phys->dn_nblkptr) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tASSERT3U(blkid + nblks, <=, dn->dn_phys->dn_nblkptr);\n\t\tfree_blocks(dn, bp + blkid, nblks, tx);\n\t} else {\n\t\tint shift = (dnlevel - 1) *\n\t\t    (dn->dn_phys->dn_indblkshift - SPA_BLKPTRSHIFT);\n\t\tint start = blkid >> shift;\n\t\tint end = (blkid + nblks - 1) >> shift;\n\t\tdmu_buf_impl_t *db;\n\n\t\tASSERT(start < dn->dn_phys->dn_nblkptr);\n\t\tbp += start;\n\t\tfor (int i = start; i <= end; i++, bp++) {\n\t\t\tif (BP_IS_HOLE(bp))\n\t\t\t\tcontinue;\n\t\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\t\tVERIFY0(dbuf_hold_impl(dn, dnlevel - 1, i,\n\t\t\t    TRUE, FALSE, FTAG, &db));\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\tfree_children(db, blkid, nblks, free_indirects, tx);\n\t\t\tdbuf_rele(db, FTAG);\n\t\t}\n\t}\n\n\t \n\tif (trunc && !dn->dn_objset->os_raw_receive) {\n\t\tuint64_t off __maybe_unused;\n\t\tdn->dn_phys->dn_maxblkid = blkid == 0 ? 0 : blkid - 1;\n\n\t\toff = (dn->dn_phys->dn_maxblkid + 1) *\n\t\t    (dn->dn_phys->dn_datablkszsec << SPA_MINBLOCKSHIFT);\n\t\tASSERT(off < dn->dn_phys->dn_maxblkid ||\n\t\t    dn->dn_phys->dn_maxblkid == 0 ||\n\t\t    dnode_next_offset(dn, 0, &off, 1, 1, 0) != 0);\n\t}\n}\n\ntypedef struct dnode_sync_free_range_arg {\n\tdnode_t *dsfra_dnode;\n\tdmu_tx_t *dsfra_tx;\n\tboolean_t dsfra_free_indirects;\n} dnode_sync_free_range_arg_t;\n\nstatic void\ndnode_sync_free_range(void *arg, uint64_t blkid, uint64_t nblks)\n{\n\tdnode_sync_free_range_arg_t *dsfra = arg;\n\tdnode_t *dn = dsfra->dsfra_dnode;\n\n\tmutex_exit(&dn->dn_mtx);\n\tdnode_sync_free_range_impl(dn, blkid, nblks,\n\t    dsfra->dsfra_free_indirects, dsfra->dsfra_tx);\n\tmutex_enter(&dn->dn_mtx);\n}\n\n \nvoid\ndnode_evict_dbufs(dnode_t *dn)\n{\n\tdmu_buf_impl_t *db_marker;\n\tdmu_buf_impl_t *db, *db_next;\n\n\tdb_marker = kmem_alloc(sizeof (dmu_buf_impl_t), KM_SLEEP);\n\n\tmutex_enter(&dn->dn_dbufs_mtx);\n\tfor (db = avl_first(&dn->dn_dbufs); db != NULL; db = db_next) {\n\n#ifdef\tZFS_DEBUG\n\t\tDB_DNODE_ENTER(db);\n\t\tASSERT3P(DB_DNODE(db), ==, dn);\n\t\tDB_DNODE_EXIT(db);\n#endif\t \n\n\t\tmutex_enter(&db->db_mtx);\n\t\tif (db->db_state != DB_EVICTING &&\n\t\t    zfs_refcount_is_zero(&db->db_holds)) {\n\t\t\tdb_marker->db_level = db->db_level;\n\t\t\tdb_marker->db_blkid = db->db_blkid;\n\t\t\tdb_marker->db_state = DB_SEARCH;\n\t\t\tavl_insert_here(&dn->dn_dbufs, db_marker, db,\n\t\t\t    AVL_BEFORE);\n\n\t\t\t \n\t\t\tdbuf_destroy(db);\n\n\t\t\tdb_next = AVL_NEXT(&dn->dn_dbufs, db_marker);\n\t\t\tavl_remove(&dn->dn_dbufs, db_marker);\n\t\t} else {\n\t\t\tdb->db_pending_evict = TRUE;\n\t\t\tmutex_exit(&db->db_mtx);\n\t\t\tdb_next = AVL_NEXT(&dn->dn_dbufs, db);\n\t\t}\n\t}\n\tmutex_exit(&dn->dn_dbufs_mtx);\n\n\tkmem_free(db_marker, sizeof (dmu_buf_impl_t));\n\n\tdnode_evict_bonus(dn);\n}\n\nvoid\ndnode_evict_bonus(dnode_t *dn)\n{\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\tif (dn->dn_bonus != NULL) {\n\t\tif (zfs_refcount_is_zero(&dn->dn_bonus->db_holds)) {\n\t\t\tmutex_enter(&dn->dn_bonus->db_mtx);\n\t\t\tdbuf_destroy(dn->dn_bonus);\n\t\t\tdn->dn_bonus = NULL;\n\t\t} else {\n\t\t\tdn->dn_bonus->db_pending_evict = TRUE;\n\t\t}\n\t}\n\trw_exit(&dn->dn_struct_rwlock);\n}\n\nstatic void\ndnode_undirty_dbufs(list_t *list)\n{\n\tdbuf_dirty_record_t *dr;\n\n\twhile ((dr = list_head(list))) {\n\t\tdmu_buf_impl_t *db = dr->dr_dbuf;\n\t\tuint64_t txg = dr->dr_txg;\n\n\t\tif (db->db_level != 0)\n\t\t\tdnode_undirty_dbufs(&dr->dt.di.dr_children);\n\n\t\tmutex_enter(&db->db_mtx);\n\t\t \n\t\tlist_remove(list, dr);\n\t\tASSERT(list_head(&db->db_dirty_records) == dr);\n\t\tlist_remove_head(&db->db_dirty_records);\n\t\tASSERT(list_is_empty(&db->db_dirty_records));\n\t\tdb->db_dirtycnt -= 1;\n\t\tif (db->db_level == 0) {\n\t\t\tASSERT(db->db_blkid == DMU_BONUS_BLKID ||\n\t\t\t    dr->dt.dl.dr_data == db->db_buf);\n\t\t\tdbuf_unoverride(dr);\n\t\t} else {\n\t\t\tmutex_destroy(&dr->dt.di.dr_mtx);\n\t\t\tlist_destroy(&dr->dt.di.dr_children);\n\t\t}\n\t\tkmem_free(dr, sizeof (dbuf_dirty_record_t));\n\t\tdbuf_rele_and_unlock(db, (void *)(uintptr_t)txg, B_FALSE);\n\t}\n}\n\nstatic void\ndnode_sync_free(dnode_t *dn, dmu_tx_t *tx)\n{\n\tint txgoff = tx->tx_txg & TXG_MASK;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\t \n\tASSERT0(DN_USED_BYTES(dn->dn_phys));\n\tASSERT(BP_IS_HOLE(dn->dn_phys->dn_blkptr));\n\n\tdnode_undirty_dbufs(&dn->dn_dirty_records[txgoff]);\n\tdnode_evict_dbufs(dn);\n\n\t \n\n\t \n\tdn->dn_next_nlevels[txgoff] = 0;\n\tdn->dn_next_indblkshift[txgoff] = 0;\n\tdn->dn_next_blksz[txgoff] = 0;\n\tdn->dn_next_maxblkid[txgoff] = 0;\n\n\t \n\tASSERT(dn->dn_phys->dn_type != DMU_OT_NONE);\n\tASSERT(dn->dn_type != DMU_OT_NONE);\n\n\tASSERT(dn->dn_free_txg > 0);\n\tif (dn->dn_allocated_txg != dn->dn_free_txg)\n\t\tdmu_buf_will_dirty(&dn->dn_dbuf->db, tx);\n\tmemset(dn->dn_phys, 0, sizeof (dnode_phys_t) * dn->dn_num_slots);\n\tdnode_free_interior_slots(dn);\n\n\tmutex_enter(&dn->dn_mtx);\n\tdn->dn_type = DMU_OT_NONE;\n\tdn->dn_maxblkid = 0;\n\tdn->dn_allocated_txg = 0;\n\tdn->dn_free_txg = 0;\n\tdn->dn_have_spill = B_FALSE;\n\tdn->dn_num_slots = 1;\n\tmutex_exit(&dn->dn_mtx);\n\n\tASSERT(dn->dn_object != DMU_META_DNODE_OBJECT);\n\n\tdnode_rele(dn, (void *)(uintptr_t)tx->tx_txg);\n\t \n}\n\n \nvoid\ndnode_sync(dnode_t *dn, dmu_tx_t *tx)\n{\n\tobjset_t *os = dn->dn_objset;\n\tdnode_phys_t *dnp = dn->dn_phys;\n\tint txgoff = tx->tx_txg & TXG_MASK;\n\tlist_t *list = &dn->dn_dirty_records[txgoff];\n\tstatic const dnode_phys_t zerodn __maybe_unused = { 0 };\n\tboolean_t kill_spill = B_FALSE;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dnp->dn_type != DMU_OT_NONE || dn->dn_allocated_txg);\n\tASSERT(dnp->dn_type != DMU_OT_NONE ||\n\t    memcmp(dnp, &zerodn, DNODE_MIN_SIZE) == 0);\n\tDNODE_VERIFY(dn);\n\n\tASSERT(dn->dn_dbuf == NULL || arc_released(dn->dn_dbuf->db_buf));\n\n\t \n\tif (dmu_objset_userused_enabled(os) &&\n\t    !DMU_OBJECT_IS_SPECIAL(dn->dn_object) &&\n\t    (!os->os_encrypted || !dmu_objset_is_receiving(os))) {\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tdn->dn_oldused = DN_USED_BYTES(dn->dn_phys);\n\t\tdn->dn_oldflags = dn->dn_phys->dn_flags;\n\t\tdn->dn_phys->dn_flags |= DNODE_FLAG_USERUSED_ACCOUNTED;\n\t\tif (dmu_objset_userobjused_enabled(dn->dn_objset))\n\t\t\tdn->dn_phys->dn_flags |=\n\t\t\t    DNODE_FLAG_USEROBJUSED_ACCOUNTED;\n\t\tmutex_exit(&dn->dn_mtx);\n\t\tdmu_objset_userquota_get_ids(dn, B_FALSE, tx);\n\t} else if (!(os->os_encrypted && dmu_objset_is_receiving(os))) {\n\t\t \n\t\tASSERT(!(dn->dn_phys->dn_flags &\n\t\t    DNODE_FLAG_USERUSED_ACCOUNTED));\n\t\tASSERT(!(dn->dn_phys->dn_flags &\n\t\t    DNODE_FLAG_USEROBJUSED_ACCOUNTED));\n\t}\n\n\tmutex_enter(&dn->dn_mtx);\n\tif (dn->dn_allocated_txg == tx->tx_txg) {\n\t\t \n\t\tif (dnp->dn_type == DMU_OT_NONE) {\n\t\t\t \n\t\t\tdnp->dn_nlevels = 1;\n\t\t\tdnp->dn_nblkptr = dn->dn_nblkptr;\n\t\t}\n\n\t\tdnp->dn_type = dn->dn_type;\n\t\tdnp->dn_bonustype = dn->dn_bonustype;\n\t\tdnp->dn_bonuslen = dn->dn_bonuslen;\n\t}\n\n\tdnp->dn_extra_slots = dn->dn_num_slots - 1;\n\n\tASSERT(dnp->dn_nlevels > 1 ||\n\t    BP_IS_HOLE(&dnp->dn_blkptr[0]) ||\n\t    BP_IS_EMBEDDED(&dnp->dn_blkptr[0]) ||\n\t    BP_GET_LSIZE(&dnp->dn_blkptr[0]) ==\n\t    dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT);\n\tASSERT(dnp->dn_nlevels < 2 ||\n\t    BP_IS_HOLE(&dnp->dn_blkptr[0]) ||\n\t    BP_GET_LSIZE(&dnp->dn_blkptr[0]) == 1 << dnp->dn_indblkshift);\n\n\tif (dn->dn_next_type[txgoff] != 0) {\n\t\tdnp->dn_type = dn->dn_type;\n\t\tdn->dn_next_type[txgoff] = 0;\n\t}\n\n\tif (dn->dn_next_blksz[txgoff] != 0) {\n\t\tASSERT(P2PHASE(dn->dn_next_blksz[txgoff],\n\t\t    SPA_MINBLOCKSIZE) == 0);\n\t\tASSERT(BP_IS_HOLE(&dnp->dn_blkptr[0]) ||\n\t\t    dn->dn_maxblkid == 0 || list_head(list) != NULL ||\n\t\t    dn->dn_next_blksz[txgoff] >> SPA_MINBLOCKSHIFT ==\n\t\t    dnp->dn_datablkszsec ||\n\t\t    !range_tree_is_empty(dn->dn_free_ranges[txgoff]));\n\t\tdnp->dn_datablkszsec =\n\t\t    dn->dn_next_blksz[txgoff] >> SPA_MINBLOCKSHIFT;\n\t\tdn->dn_next_blksz[txgoff] = 0;\n\t}\n\n\tif (dn->dn_next_bonuslen[txgoff] != 0) {\n\t\tif (dn->dn_next_bonuslen[txgoff] == DN_ZERO_BONUSLEN)\n\t\t\tdnp->dn_bonuslen = 0;\n\t\telse\n\t\t\tdnp->dn_bonuslen = dn->dn_next_bonuslen[txgoff];\n\t\tASSERT(dnp->dn_bonuslen <=\n\t\t    DN_SLOTS_TO_BONUSLEN(dnp->dn_extra_slots + 1));\n\t\tdn->dn_next_bonuslen[txgoff] = 0;\n\t}\n\n\tif (dn->dn_next_bonustype[txgoff] != 0) {\n\t\tASSERT(DMU_OT_IS_VALID(dn->dn_next_bonustype[txgoff]));\n\t\tdnp->dn_bonustype = dn->dn_next_bonustype[txgoff];\n\t\tdn->dn_next_bonustype[txgoff] = 0;\n\t}\n\n\tboolean_t freeing_dnode = dn->dn_free_txg > 0 &&\n\t    dn->dn_free_txg <= tx->tx_txg;\n\n\t \n\tif (dn->dn_rm_spillblk[txgoff] || freeing_dnode) {\n\t\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR)\n\t\t\tkill_spill = B_TRUE;\n\t\tdn->dn_rm_spillblk[txgoff] = 0;\n\t}\n\n\tif (dn->dn_next_indblkshift[txgoff] != 0) {\n\t\tASSERT(dnp->dn_nlevels == 1);\n\t\tdnp->dn_indblkshift = dn->dn_next_indblkshift[txgoff];\n\t\tdn->dn_next_indblkshift[txgoff] = 0;\n\t}\n\n\t \n\tdnp->dn_checksum = dn->dn_checksum;\n\tdnp->dn_compress = dn->dn_compress;\n\n\tmutex_exit(&dn->dn_mtx);\n\n\tif (kill_spill) {\n\t\tfree_blocks(dn, DN_SPILL_BLKPTR(dn->dn_phys), 1, tx);\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tdnp->dn_flags &= ~DNODE_FLAG_SPILL_BLKPTR;\n\t\tmutex_exit(&dn->dn_mtx);\n\t}\n\n\t \n\tif (dn->dn_free_ranges[txgoff] != NULL) {\n\t\tdnode_sync_free_range_arg_t dsfra;\n\t\tdsfra.dsfra_dnode = dn;\n\t\tdsfra.dsfra_tx = tx;\n\t\tdsfra.dsfra_free_indirects = freeing_dnode;\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tif (freeing_dnode) {\n\t\t\tASSERT(range_tree_contains(dn->dn_free_ranges[txgoff],\n\t\t\t    0, dn->dn_maxblkid + 1));\n\t\t}\n\t\t \n\t\trange_tree_walk(dn->dn_free_ranges[txgoff],\n\t\t    dnode_sync_free_range, &dsfra);\n\t\trange_tree_vacate(dn->dn_free_ranges[txgoff], NULL, NULL);\n\t\trange_tree_destroy(dn->dn_free_ranges[txgoff]);\n\t\tdn->dn_free_ranges[txgoff] = NULL;\n\t\tmutex_exit(&dn->dn_mtx);\n\t}\n\n\tif (freeing_dnode) {\n\t\tdn->dn_objset->os_freed_dnodes++;\n\t\tdnode_sync_free(dn, tx);\n\t\treturn;\n\t}\n\n\tif (dn->dn_num_slots > DNODE_MIN_SLOTS) {\n\t\tdsl_dataset_t *ds = dn->dn_objset->os_dsl_dataset;\n\t\tmutex_enter(&ds->ds_lock);\n\t\tds->ds_feature_activation[SPA_FEATURE_LARGE_DNODE] =\n\t\t    (void *)B_TRUE;\n\t\tmutex_exit(&ds->ds_lock);\n\t}\n\n\tif (dn->dn_next_nlevels[txgoff]) {\n\t\tdnode_increase_indirection(dn, tx);\n\t\tdn->dn_next_nlevels[txgoff] = 0;\n\t}\n\n\t \n\tif (dn->dn_next_maxblkid[txgoff]) {\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tdnp->dn_maxblkid =\n\t\t    dn->dn_next_maxblkid[txgoff] & ~DMU_NEXT_MAXBLKID_SET;\n\t\tdn->dn_next_maxblkid[txgoff] = 0;\n\t\tmutex_exit(&dn->dn_mtx);\n\t}\n\n\tif (dn->dn_next_nblkptr[txgoff]) {\n\t\t \n\t\tASSERT(dn->dn_allocated_txg == tx->tx_txg);\n\t\tif (dn->dn_next_nblkptr[txgoff] > dnp->dn_nblkptr) {\n\t\t\t \n\t\t\tmemset(dnp->dn_blkptr + dnp->dn_nblkptr, 0,\n\t\t\t    sizeof (blkptr_t) *\n\t\t\t    (dn->dn_next_nblkptr[txgoff] - dnp->dn_nblkptr));\n#ifdef ZFS_DEBUG\n\t\t} else {\n\t\t\tint i;\n\t\t\tASSERT(dn->dn_next_nblkptr[txgoff] < dnp->dn_nblkptr);\n\t\t\t \n\t\t\tfor (i = 0; i < dnp->dn_nblkptr; i++) {\n\t\t\t\tif (i >= dn->dn_next_nblkptr[txgoff])\n\t\t\t\t\tASSERT(BP_IS_HOLE(&dnp->dn_blkptr[i]));\n\t\t\t}\n#endif\n\t\t}\n\t\tmutex_enter(&dn->dn_mtx);\n\t\tdnp->dn_nblkptr = dn->dn_next_nblkptr[txgoff];\n\t\tdn->dn_next_nblkptr[txgoff] = 0;\n\t\tmutex_exit(&dn->dn_mtx);\n\t}\n\n\tdbuf_sync_list(list, dn->dn_phys->dn_nlevels - 1, tx);\n\n\tif (!DMU_OBJECT_IS_SPECIAL(dn->dn_object)) {\n\t\tASSERT3P(list_head(list), ==, NULL);\n\t\tdnode_rele(dn, (void *)(uintptr_t)tx->tx_txg);\n\t}\n\n\tASSERT3U(dnp->dn_bonuslen, <=, DN_MAX_BONUS_LEN(dnp));\n\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}