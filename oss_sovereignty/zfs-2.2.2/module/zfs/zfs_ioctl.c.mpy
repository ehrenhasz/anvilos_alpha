{
  "module_name": "zfs_ioctl.c",
  "hash_id": "94fd93238b29ee4cf2b4dd00d8e0041e012ef77011a196ffe3e3bde0e1ec0ebc",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_ioctl.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n#include <sys/uio_impl.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/cmn_err.h>\n#include <sys/stat.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_quota.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n#include <sys/zap.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/dmu.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_deleg.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_redact.h>\n#include <sys/dmu_tx.h>\n#include <sys/sunddi.h>\n#include <sys/policy.h>\n#include <sys/zone.h>\n#include <sys/nvpair.h>\n#include <sys/pathname.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_onexit.h>\n#include <sys/zvol.h>\n#include <sys/dsl_scan.h>\n#include <sys/fm/util.h>\n#include <sys/dsl_crypt.h>\n#include <sys/rrwlock.h>\n#include <sys/zfs_file.h>\n\n#include <sys/dmu_recv.h>\n#include <sys/dmu_send.h>\n#include <sys/dmu_recv.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dsl_userhold.h>\n#include <sys/zfeature.h>\n#include <sys/zcp.h>\n#include <sys/zio_checksum.h>\n#include <sys/vdev_removal.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_initialize.h>\n#include <sys/vdev_trim.h>\n\n#include \"zfs_namecheck.h\"\n#include \"zfs_prop.h\"\n#include \"zfs_deleg.h\"\n#include \"zfs_comutil.h\"\n\n#include <sys/lua/lua.h>\n#include <sys/lua/lauxlib.h>\n#include <sys/zfs_ioctl_impl.h>\n\nkmutex_t zfsdev_state_lock;\nstatic zfsdev_state_t zfsdev_state_listhead;\n\n \nuint64_t zfs_max_nvlist_src_size = 0;\n\n \nstatic uint64_t zfs_history_output_max = 1024 * 1024;\n\nuint_t zfs_fsyncer_key;\nuint_t zfs_allow_log_key;\n\n \n#define\tDATA_TYPE_ANY\tDATA_TYPE_UNKNOWN\n\ntypedef struct zfs_ioc_vec {\n\tzfs_ioc_legacy_func_t\t*zvec_legacy_func;\n\tzfs_ioc_func_t\t\t*zvec_func;\n\tzfs_secpolicy_func_t\t*zvec_secpolicy;\n\tzfs_ioc_namecheck_t\tzvec_namecheck;\n\tboolean_t\t\tzvec_allow_log;\n\tzfs_ioc_poolcheck_t\tzvec_pool_check;\n\tboolean_t\t\tzvec_smush_outnvlist;\n\tconst char\t\t*zvec_name;\n\tconst zfs_ioc_key_t\t*zvec_nvl_keys;\n\tsize_t\t\t\tzvec_nvl_key_count;\n} zfs_ioc_vec_t;\n\n \nstatic const char *userquota_perms[] = {\n\tZFS_DELEG_PERM_USERUSED,\n\tZFS_DELEG_PERM_USERQUOTA,\n\tZFS_DELEG_PERM_GROUPUSED,\n\tZFS_DELEG_PERM_GROUPQUOTA,\n\tZFS_DELEG_PERM_USEROBJUSED,\n\tZFS_DELEG_PERM_USEROBJQUOTA,\n\tZFS_DELEG_PERM_GROUPOBJUSED,\n\tZFS_DELEG_PERM_GROUPOBJQUOTA,\n\tZFS_DELEG_PERM_PROJECTUSED,\n\tZFS_DELEG_PERM_PROJECTQUOTA,\n\tZFS_DELEG_PERM_PROJECTOBJUSED,\n\tZFS_DELEG_PERM_PROJECTOBJQUOTA,\n};\n\nstatic int zfs_ioc_userspace_upgrade(zfs_cmd_t *zc);\nstatic int zfs_ioc_id_quota_upgrade(zfs_cmd_t *zc);\nstatic int zfs_check_settable(const char *name, nvpair_t *property,\n    cred_t *cr);\nstatic int zfs_check_clearable(const char *dataset, nvlist_t *props,\n    nvlist_t **errors);\nstatic int zfs_fill_zplprops_root(uint64_t, nvlist_t *, nvlist_t *,\n    boolean_t *);\nint zfs_set_prop_nvlist(const char *, zprop_source_t, nvlist_t *, nvlist_t *);\nstatic int get_nvlist(uint64_t nvl, uint64_t size, int iflag, nvlist_t **nvp);\n\nstatic void\nhistory_str_free(char *buf)\n{\n\tkmem_free(buf, HIS_MAX_RECORD_LEN);\n}\n\nstatic char *\nhistory_str_get(zfs_cmd_t *zc)\n{\n\tchar *buf;\n\n\tif (zc->zc_history == 0)\n\t\treturn (NULL);\n\n\tbuf = kmem_alloc(HIS_MAX_RECORD_LEN, KM_SLEEP);\n\tif (copyinstr((void *)(uintptr_t)zc->zc_history,\n\t    buf, HIS_MAX_RECORD_LEN, NULL) != 0) {\n\t\thistory_str_free(buf);\n\t\treturn (NULL);\n\t}\n\n\tbuf[HIS_MAX_RECORD_LEN -1] = '\\0';\n\n\treturn (buf);\n}\n\n \nstatic int\nzfs_earlier_version(const char *name, int version)\n{\n\tspa_t *spa;\n\n\tif (spa_open(name, &spa, FTAG) == 0) {\n\t\tif (spa_version(spa) < version) {\n\t\t\tspa_close(spa, FTAG);\n\t\t\treturn (1);\n\t\t}\n\t\tspa_close(spa, FTAG);\n\t}\n\treturn (0);\n}\n\n \nstatic boolean_t\nzpl_earlier_version(const char *name, int version)\n{\n\tobjset_t *os;\n\tboolean_t rc = B_TRUE;\n\n\tif (dmu_objset_hold(name, FTAG, &os) == 0) {\n\t\tuint64_t zplversion;\n\n\t\tif (dmu_objset_type(os) != DMU_OST_ZFS) {\n\t\t\tdmu_objset_rele(os, FTAG);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t\t \n\t\tif (zfs_get_zplprop(os, ZFS_PROP_VERSION, &zplversion) == 0)\n\t\t\trc = zplversion < version;\n\t\tdmu_objset_rele(os, FTAG);\n\t}\n\treturn (rc);\n}\n\nstatic void\nzfs_log_history(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tchar *buf;\n\n\tif ((buf = history_str_get(zc)) == NULL)\n\t\treturn;\n\n\tif (spa_open(zc->zc_name, &spa, FTAG) == 0) {\n\t\tif (spa_version(spa) >= SPA_VERSION_ZPOOL_HISTORY)\n\t\t\t(void) spa_history_log(spa, buf);\n\t\tspa_close(spa, FTAG);\n\t}\n\thistory_str_free(buf);\n}\n\n \nstatic int\nzfs_secpolicy_none(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc, (void) innvl, (void) cr;\n\treturn (0);\n}\n\n \nstatic int\nzfs_secpolicy_read(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl, (void) cr;\n\tif (INGLOBALZONE(curproc) ||\n\t    zone_dataset_visible(zc->zc_name, NULL))\n\t\treturn (0);\n\n\treturn (SET_ERROR(ENOENT));\n}\n\nstatic int\nzfs_dozonecheck_impl(const char *dataset, uint64_t zoned, cred_t *cr)\n{\n\tint writable = 1;\n\n\t \n\tif (!INGLOBALZONE(curproc) &&\n\t    !zone_dataset_visible(dataset, &writable))\n\t\treturn (SET_ERROR(ENOENT));\n\n\tif (INGLOBALZONE(curproc)) {\n\t\t \n\t\tif (secpolicy_zfs(cr) && zoned)\n\t\t\treturn (SET_ERROR(EPERM));\n\t} else {\n\t\t \n\t\tif (!zoned)\n\t\t\treturn (SET_ERROR(EPERM));\n\n\t\t \n\t\tif (!writable)\n\t\t\treturn (SET_ERROR(EPERM));\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_dozonecheck(const char *dataset, cred_t *cr)\n{\n\tuint64_t zoned;\n\n\tif (dsl_prop_get_integer(dataset, zfs_prop_to_name(ZFS_PROP_ZONED),\n\t    &zoned, NULL))\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (zfs_dozonecheck_impl(dataset, zoned, cr));\n}\n\nstatic int\nzfs_dozonecheck_ds(const char *dataset, dsl_dataset_t *ds, cred_t *cr)\n{\n\tuint64_t zoned;\n\n\tif (dsl_prop_get_int_ds(ds, zfs_prop_to_name(ZFS_PROP_ZONED), &zoned))\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (zfs_dozonecheck_impl(dataset, zoned, cr));\n}\n\nstatic int\nzfs_secpolicy_write_perms_ds(const char *name, dsl_dataset_t *ds,\n    const char *perm, cred_t *cr)\n{\n\tint error;\n\n\terror = zfs_dozonecheck_ds(name, ds, cr);\n\tif (error == 0) {\n\t\terror = secpolicy_zfs(cr);\n\t\tif (error != 0)\n\t\t\terror = dsl_deleg_access_impl(ds, perm, cr);\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_write_perms(const char *name, const char *perm, cred_t *cr)\n{\n\tint error;\n\tdsl_dataset_t *ds;\n\tdsl_pool_t *dp;\n\n\t \n\tif (INGLOBALZONE(curproc) && secpolicy_zfs(cr) == 0)\n\t\treturn (0);\n\n\terror = dsl_pool_hold(name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, name, FTAG, &ds);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = zfs_secpolicy_write_perms_ds(name, ds, perm, cr);\n\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_set_slabel_policy(const char *name, const char *strval, cred_t *cr)\n{\n#ifdef HAVE_MLSLABEL\n\tchar\t\tds_hexsl[MAXNAMELEN];\n\tbslabel_t\tds_sl, new_sl;\n\tboolean_t\tnew_default = FALSE;\n\tuint64_t\tzoned;\n\tint\t\tneeded_priv = -1;\n\tint\t\terror;\n\n\t \n\terror = dsl_prop_get(name, zfs_prop_to_name(ZFS_PROP_MLSLABEL),\n\t    1, sizeof (ds_hexsl), &ds_hexsl, NULL);\n\tif (error != 0)\n\t\treturn (SET_ERROR(EPERM));\n\n\tif (strcasecmp(strval, ZFS_MLSLABEL_DEFAULT) == 0)\n\t\tnew_default = TRUE;\n\n\t \n\tif (!new_default && (hexstr_to_label(strval, &new_sl) != 0))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (!INGLOBALZONE(curproc)) {\n\t\tif (new_default || !blequal(&new_sl, CR_SL(CRED())))\n\t\t\treturn (SET_ERROR(EPERM));\n\t\treturn (0);\n\t}\n\n\t \n\tif (dsl_prop_get_integer(name,\n\t    zfs_prop_to_name(ZFS_PROP_ZONED), &zoned, NULL))\n\t\treturn (SET_ERROR(EPERM));\n\tif (!zoned) {\n\t\tif (zfs_check_global_label(name, strval) != 0)\n\t\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\tif (strcasecmp(ds_hexsl, ZFS_MLSLABEL_DEFAULT) != 0) {\n\t\tobjset_t *os;\n\t\tstatic const char *setsl_tag = \"setsl_tag\";\n\n\t\t \n\t\terror = dmu_objset_own(name, DMU_OST_ZFS, B_TRUE, B_TRUE,\n\t\t    setsl_tag, &os);\n\t\tif (error != 0)\n\t\t\treturn (SET_ERROR(EPERM));\n\n\t\tdmu_objset_disown(os, B_TRUE, setsl_tag);\n\n\t\tif (new_default) {\n\t\t\tneeded_priv = PRIV_FILE_DOWNGRADE_SL;\n\t\t\tgoto out_check;\n\t\t}\n\n\t\tif (hexstr_to_label(strval, &new_sl) != 0)\n\t\t\treturn (SET_ERROR(EPERM));\n\n\t\tif (blstrictdom(&ds_sl, &new_sl))\n\t\t\tneeded_priv = PRIV_FILE_DOWNGRADE_SL;\n\t\telse if (blstrictdom(&new_sl, &ds_sl))\n\t\t\tneeded_priv = PRIV_FILE_UPGRADE_SL;\n\t} else {\n\t\t \n\t\tif (!new_default)\n\t\t\tneeded_priv = PRIV_FILE_UPGRADE_SL;\n\t}\n\nout_check:\n\tif (needed_priv != -1)\n\t\treturn (PRIV_POLICY(cr, needed_priv, B_FALSE, EPERM, NULL));\n\treturn (0);\n#else\n\treturn (SET_ERROR(ENOTSUP));\n#endif  \n}\n\nstatic int\nzfs_secpolicy_setprop(const char *dsname, zfs_prop_t prop, nvpair_t *propval,\n    cred_t *cr)\n{\n\tconst char *strval;\n\n\t \n\tswitch (prop) {\n\tdefault:\n\t\tbreak;\n\tcase ZFS_PROP_ZONED:\n\t\t \n\t\tif (!INGLOBALZONE(curproc))\n\t\t\treturn (SET_ERROR(EPERM));\n\t\tbreak;\n\n\tcase ZFS_PROP_QUOTA:\n\tcase ZFS_PROP_FILESYSTEM_LIMIT:\n\tcase ZFS_PROP_SNAPSHOT_LIMIT:\n\t\tif (!INGLOBALZONE(curproc)) {\n\t\t\tuint64_t zoned;\n\t\t\tchar setpoint[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t \n\t\t\tif (dsl_prop_get_integer(dsname,\n\t\t\t    zfs_prop_to_name(ZFS_PROP_ZONED), &zoned, setpoint))\n\t\t\t\treturn (SET_ERROR(EPERM));\n\t\t\tif (!zoned || strlen(dsname) <= strlen(setpoint))\n\t\t\t\treturn (SET_ERROR(EPERM));\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_MLSLABEL:\n\t\tif (!is_system_labeled())\n\t\t\treturn (SET_ERROR(EPERM));\n\n\t\tif (nvpair_value_string(propval, &strval) == 0) {\n\t\t\tint err;\n\n\t\t\terr = zfs_set_slabel_policy(dsname, strval, CRED());\n\t\t\tif (err != 0)\n\t\t\t\treturn (err);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (zfs_secpolicy_write_perms(dsname, zfs_prop_to_name(prop), cr));\n}\n\nstatic int\nzfs_secpolicy_set_fsacl(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t \n\t(void) innvl;\n\treturn (zfs_dozonecheck(zc->zc_name, cr));\n}\n\nstatic int\nzfs_secpolicy_rollback(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_ROLLBACK, cr));\n}\n\nstatic int\nzfs_secpolicy_send(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tconst char *cp;\n\tint error;\n\n\t \n\tcp = strchr(zc->zc_name, '@');\n\tif (cp == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold_obj(dp, zc->zc_sendobj, FTAG, &ds);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tdsl_dataset_name(ds, zc->zc_name);\n\n\terror = zfs_secpolicy_write_perms_ds(zc->zc_name, ds,\n\t    ZFS_DELEG_PERM_SEND, cr);\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_send_new(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_SEND, cr));\n}\n\nstatic int\nzfs_secpolicy_share(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc, (void) innvl, (void) cr;\n\treturn (SET_ERROR(ENOTSUP));\n}\n\nstatic int\nzfs_secpolicy_smb_acl(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc, (void) innvl, (void) cr;\n\treturn (SET_ERROR(ENOTSUP));\n}\n\nstatic int\nzfs_get_parent(const char *datasetname, char *parent, int parentsize)\n{\n\tchar *cp;\n\n\t \n\t(void) strlcpy(parent, datasetname, parentsize);\n\tcp = strrchr(parent, '@');\n\tif (cp != NULL) {\n\t\tcp[0] = '\\0';\n\t} else {\n\t\tcp = strrchr(parent, '/');\n\t\tif (cp == NULL)\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\tcp[0] = '\\0';\n\t}\n\n\treturn (0);\n}\n\nint\nzfs_secpolicy_destroy_perms(const char *name, cred_t *cr)\n{\n\tint error;\n\n\tif ((error = zfs_secpolicy_write_perms(name,\n\t    ZFS_DELEG_PERM_MOUNT, cr)) != 0)\n\t\treturn (error);\n\n\treturn (zfs_secpolicy_write_perms(name, ZFS_DELEG_PERM_DESTROY, cr));\n}\n\nstatic int\nzfs_secpolicy_destroy(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\treturn (zfs_secpolicy_destroy_perms(zc->zc_name, cr));\n}\n\n \nstatic int\nzfs_secpolicy_destroy_snaps(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc;\n\tnvlist_t *snaps;\n\tnvpair_t *pair, *nextpair;\n\tint error = 0;\n\n\tsnaps = fnvlist_lookup_nvlist(innvl, \"snaps\");\n\n\tfor (pair = nvlist_next_nvpair(snaps, NULL); pair != NULL;\n\t    pair = nextpair) {\n\t\tnextpair = nvlist_next_nvpair(snaps, pair);\n\t\terror = zfs_secpolicy_destroy_perms(nvpair_name(pair), cr);\n\t\tif (error == ENOENT) {\n\t\t\t \n\t\t\tfnvlist_remove_nvpair(snaps, pair);\n\t\t\terror = 0;\n\t\t}\n\t\tif (error != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}\n\nint\nzfs_secpolicy_rename_perms(const char *from, const char *to, cred_t *cr)\n{\n\tchar\tparentname[ZFS_MAX_DATASET_NAME_LEN];\n\tint\terror;\n\n\tif ((error = zfs_secpolicy_write_perms(from,\n\t    ZFS_DELEG_PERM_RENAME, cr)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_secpolicy_write_perms(from,\n\t    ZFS_DELEG_PERM_MOUNT, cr)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_get_parent(to, parentname,\n\t    sizeof (parentname))) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_secpolicy_write_perms(parentname,\n\t    ZFS_DELEG_PERM_CREATE, cr)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_secpolicy_write_perms(parentname,\n\t    ZFS_DELEG_PERM_MOUNT, cr)) != 0)\n\t\treturn (error);\n\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_rename(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\treturn (zfs_secpolicy_rename_perms(zc->zc_name, zc->zc_value, cr));\n}\n\nstatic int\nzfs_secpolicy_promote(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *clone;\n\tint error;\n\n\terror = zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_PROMOTE, cr);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, zc->zc_name, FTAG, &clone);\n\n\tif (error == 0) {\n\t\tchar parentname[ZFS_MAX_DATASET_NAME_LEN];\n\t\tdsl_dataset_t *origin = NULL;\n\t\tdsl_dir_t *dd;\n\t\tdd = clone->ds_dir;\n\n\t\terror = dsl_dataset_hold_obj(dd->dd_pool,\n\t\t    dsl_dir_phys(dd)->dd_origin_obj, FTAG, &origin);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(clone, FTAG);\n\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\terror = zfs_secpolicy_write_perms_ds(zc->zc_name, clone,\n\t\t    ZFS_DELEG_PERM_MOUNT, cr);\n\n\t\tdsl_dataset_name(origin, parentname);\n\t\tif (error == 0) {\n\t\t\terror = zfs_secpolicy_write_perms_ds(parentname, origin,\n\t\t\t    ZFS_DELEG_PERM_PROMOTE, cr);\n\t\t}\n\t\tdsl_dataset_rele(clone, FTAG);\n\t\tdsl_dataset_rele(origin, FTAG);\n\t}\n\tdsl_pool_rele(dp, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_recv(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\tint error;\n\n\tif ((error = zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_RECEIVE, cr)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_MOUNT, cr)) != 0)\n\t\treturn (error);\n\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_CREATE, cr));\n}\n\nint\nzfs_secpolicy_snapshot_perms(const char *name, cred_t *cr)\n{\n\treturn (zfs_secpolicy_write_perms(name,\n\t    ZFS_DELEG_PERM_SNAPSHOT, cr));\n}\n\n \nstatic int\nzfs_secpolicy_snapshot(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc;\n\tnvlist_t *snaps;\n\tint error = 0;\n\tnvpair_t *pair;\n\n\tsnaps = fnvlist_lookup_nvlist(innvl, \"snaps\");\n\n\tfor (pair = nvlist_next_nvpair(snaps, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(snaps, pair)) {\n\t\tchar *name = (char *)nvpair_name(pair);\n\t\tchar *atp = strchr(name, '@');\n\n\t\tif (atp == NULL) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\t*atp = '\\0';\n\t\terror = zfs_secpolicy_snapshot_perms(name, cr);\n\t\t*atp = '@';\n\t\tif (error != 0)\n\t\t\tbreak;\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfs_secpolicy_bookmark(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc;\n\tint error = 0;\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(innvl, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(innvl, pair)) {\n\t\tchar *name = (char *)nvpair_name(pair);\n\t\tchar *hashp = strchr(name, '#');\n\n\t\tif (hashp == NULL) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\t*hashp = '\\0';\n\t\terror = zfs_secpolicy_write_perms(name,\n\t\t    ZFS_DELEG_PERM_BOOKMARK, cr);\n\t\t*hashp = '#';\n\t\tif (error != 0)\n\t\t\tbreak;\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_destroy_bookmarks(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc;\n\tnvpair_t *pair, *nextpair;\n\tint error = 0;\n\n\tfor (pair = nvlist_next_nvpair(innvl, NULL); pair != NULL;\n\t    pair = nextpair) {\n\t\tchar *name = (char *)nvpair_name(pair);\n\t\tchar *hashp = strchr(name, '#');\n\t\tnextpair = nvlist_next_nvpair(innvl, pair);\n\n\t\tif (hashp == NULL) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\n\t\t*hashp = '\\0';\n\t\terror = zfs_secpolicy_write_perms(name,\n\t\t    ZFS_DELEG_PERM_DESTROY, cr);\n\t\t*hashp = '#';\n\t\tif (error == ENOENT) {\n\t\t\t \n\t\t\tfnvlist_remove_nvpair(innvl, pair);\n\t\t\terror = 0;\n\t\t}\n\t\tif (error != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_log_history(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc, (void) innvl, (void) cr;\n\t \n\tif (tsd_get(zfs_allow_log_key) == NULL)\n\t\treturn (SET_ERROR(EPERM));\n\treturn (0);\n}\n\nstatic int\nzfs_secpolicy_create_clone(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\tchar\t\tparentname[ZFS_MAX_DATASET_NAME_LEN];\n\tint\t\terror;\n\tconst char\t*origin;\n\n\tif ((error = zfs_get_parent(zc->zc_name, parentname,\n\t    sizeof (parentname))) != 0)\n\t\treturn (error);\n\n\tif (nvlist_lookup_string(innvl, \"origin\", &origin) == 0 &&\n\t    (error = zfs_secpolicy_write_perms(origin,\n\t    ZFS_DELEG_PERM_CLONE, cr)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_secpolicy_write_perms(parentname,\n\t    ZFS_DELEG_PERM_CREATE, cr)) != 0)\n\t\treturn (error);\n\n\treturn (zfs_secpolicy_write_perms(parentname,\n\t    ZFS_DELEG_PERM_MOUNT, cr));\n}\n\n \nint\nzfs_secpolicy_config(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc, (void) innvl;\n\n\tif (secpolicy_sys_config(cr, B_FALSE) != 0)\n\t\treturn (SET_ERROR(EPERM));\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_secpolicy_diff(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\tint error;\n\n\tif (secpolicy_sys_config(cr, B_FALSE) == 0)\n\t\treturn (0);\n\n\terror = zfs_secpolicy_write_perms(zc->zc_name, ZFS_DELEG_PERM_DIFF, cr);\n\treturn (error);\n}\n\n \nstatic int\nzfs_secpolicy_inject(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc, (void) innvl;\n\treturn (secpolicy_zinject(cr));\n}\n\nstatic int\nzfs_secpolicy_inherit_prop(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\tzfs_prop_t prop = zfs_name_to_prop(zc->zc_value);\n\n\tif (prop == ZPROP_USERPROP) {\n\t\tif (!zfs_prop_user(zc->zc_value))\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t\t    ZFS_DELEG_PERM_USERPROP, cr));\n\t} else {\n\t\treturn (zfs_secpolicy_setprop(zc->zc_name, prop,\n\t\t    NULL, cr));\n\t}\n}\n\nstatic int\nzfs_secpolicy_userspace_one(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\tint err = zfs_secpolicy_read(zc, innvl, cr);\n\tif (err)\n\t\treturn (err);\n\n\tif (zc->zc_objset_type >= ZFS_NUM_USERQUOTA_PROPS)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zc->zc_value[0] == 0) {\n\t\t \n\t\tif (zc->zc_objset_type == ZFS_PROP_USERUSED ||\n\t\t    zc->zc_objset_type == ZFS_PROP_USERQUOTA ||\n\t\t    zc->zc_objset_type == ZFS_PROP_USEROBJUSED ||\n\t\t    zc->zc_objset_type == ZFS_PROP_USEROBJQUOTA) {\n\t\t\tif (zc->zc_guid == crgetuid(cr))\n\t\t\t\treturn (0);\n\t\t} else if (zc->zc_objset_type == ZFS_PROP_GROUPUSED ||\n\t\t    zc->zc_objset_type == ZFS_PROP_GROUPQUOTA ||\n\t\t    zc->zc_objset_type == ZFS_PROP_GROUPOBJUSED ||\n\t\t    zc->zc_objset_type == ZFS_PROP_GROUPOBJQUOTA) {\n\t\t\tif (groupmember(zc->zc_guid, cr))\n\t\t\t\treturn (0);\n\t\t}\n\t\t \n\t}\n\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    userquota_perms[zc->zc_objset_type], cr));\n}\n\nstatic int\nzfs_secpolicy_userspace_many(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\tint err = zfs_secpolicy_read(zc, innvl, cr);\n\tif (err)\n\t\treturn (err);\n\n\tif (zc->zc_objset_type >= ZFS_NUM_USERQUOTA_PROPS)\n\t\treturn (SET_ERROR(EINVAL));\n\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    userquota_perms[zc->zc_objset_type], cr));\n}\n\nstatic int\nzfs_secpolicy_userspace_upgrade(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) innvl;\n\treturn (zfs_secpolicy_setprop(zc->zc_name, ZFS_PROP_VERSION,\n\t    NULL, cr));\n}\n\nstatic int\nzfs_secpolicy_hold(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc;\n\tnvpair_t *pair;\n\tnvlist_t *holds;\n\tint error;\n\n\tholds = fnvlist_lookup_nvlist(innvl, \"holds\");\n\n\tfor (pair = nvlist_next_nvpair(holds, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(holds, pair)) {\n\t\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\t\terror = dmu_fsname(nvpair_name(pair), fsname);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t\terror = zfs_secpolicy_write_perms(fsname,\n\t\t    ZFS_DELEG_PERM_HOLD, cr);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_secpolicy_release(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t(void) zc;\n\tnvpair_t *pair;\n\tint error;\n\n\tfor (pair = nvlist_next_nvpair(innvl, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(innvl, pair)) {\n\t\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\t\terror = dmu_fsname(nvpair_name(pair), fsname);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t\terror = zfs_secpolicy_write_perms(fsname,\n\t\t    ZFS_DELEG_PERM_RELEASE, cr);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nzfs_secpolicy_tmp_snapshot(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\t \n\tint error;\n\n\tif (zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_DIFF, cr) == 0)\n\t\treturn (0);\n\n\terror = zfs_secpolicy_snapshot_perms(zc->zc_name, cr);\n\n\tif (innvl != NULL) {\n\t\tif (error == 0)\n\t\t\terror = zfs_secpolicy_hold(zc, innvl, cr);\n\t\tif (error == 0)\n\t\t\terror = zfs_secpolicy_release(zc, innvl, cr);\n\t\tif (error == 0)\n\t\t\terror = zfs_secpolicy_destroy(zc, innvl, cr);\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_secpolicy_load_key(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_LOAD_KEY, cr));\n}\n\nstatic int\nzfs_secpolicy_change_key(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)\n{\n\treturn (zfs_secpolicy_write_perms(zc->zc_name,\n\t    ZFS_DELEG_PERM_CHANGE_KEY, cr));\n}\n\n \nstatic int\nget_nvlist(uint64_t nvl, uint64_t size, int iflag, nvlist_t **nvp)\n{\n\tchar *packed;\n\tint error;\n\tnvlist_t *list = NULL;\n\n\t \n\tif (size == 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tpacked = vmem_alloc(size, KM_SLEEP);\n\n\tif (ddi_copyin((void *)(uintptr_t)nvl, packed, size, iflag) != 0) {\n\t\tvmem_free(packed, size);\n\t\treturn (SET_ERROR(EFAULT));\n\t}\n\n\tif ((error = nvlist_unpack(packed, size, &list, 0)) != 0) {\n\t\tvmem_free(packed, size);\n\t\treturn (error);\n\t}\n\n\tvmem_free(packed, size);\n\n\t*nvp = list;\n\treturn (0);\n}\n\n \nstatic int\nnvlist_smush(nvlist_t *errors, size_t max)\n{\n\tsize_t size;\n\n\tsize = fnvlist_size(errors);\n\n\tif (size > max) {\n\t\tnvpair_t *more_errors;\n\t\tint n = 0;\n\n\t\tif (max < 1024)\n\t\t\treturn (SET_ERROR(ENOMEM));\n\n\t\tfnvlist_add_int32(errors, ZPROP_N_MORE_ERRORS, 0);\n\t\tmore_errors = nvlist_prev_nvpair(errors, NULL);\n\n\t\tdo {\n\t\t\tnvpair_t *pair = nvlist_prev_nvpair(errors,\n\t\t\t    more_errors);\n\t\t\tfnvlist_remove_nvpair(errors, pair);\n\t\t\tn++;\n\t\t\tsize = fnvlist_size(errors);\n\t\t} while (size > max);\n\n\t\tfnvlist_remove_nvpair(errors, more_errors);\n\t\tfnvlist_add_int32(errors, ZPROP_N_MORE_ERRORS, n);\n\t\tASSERT3U(fnvlist_size(errors), <=, max);\n\t}\n\n\treturn (0);\n}\n\nstatic int\nput_nvlist(zfs_cmd_t *zc, nvlist_t *nvl)\n{\n\tchar *packed = NULL;\n\tint error = 0;\n\tsize_t size;\n\n\tsize = fnvlist_size(nvl);\n\n\tif (size > zc->zc_nvlist_dst_size) {\n\t\terror = SET_ERROR(ENOMEM);\n\t} else {\n\t\tpacked = fnvlist_pack(nvl, &size);\n\t\tif (ddi_copyout(packed, (void *)(uintptr_t)zc->zc_nvlist_dst,\n\t\t    size, zc->zc_iflags) != 0)\n\t\t\terror = SET_ERROR(EFAULT);\n\t\tfnvlist_pack_free(packed, size);\n\t}\n\n\tzc->zc_nvlist_dst_size = size;\n\tzc->zc_nvlist_dst_filled = B_TRUE;\n\treturn (error);\n}\n\nint\ngetzfsvfs_impl(objset_t *os, zfsvfs_t **zfvp)\n{\n\tint error = 0;\n\tif (dmu_objset_type(os) != DMU_OST_ZFS) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tmutex_enter(&os->os_user_ptr_lock);\n\t*zfvp = dmu_objset_get_user(os);\n\t \n\terror = zfs_vfs_ref(zfvp);\n\tmutex_exit(&os->os_user_ptr_lock);\n\treturn (error);\n}\n\nint\ngetzfsvfs(const char *dsname, zfsvfs_t **zfvp)\n{\n\tobjset_t *os;\n\tint error;\n\n\terror = dmu_objset_hold(dsname, FTAG, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = getzfsvfs_impl(os, zfvp);\n\tdmu_objset_rele(os, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfsvfs_hold(const char *name, const void *tag, zfsvfs_t **zfvp,\n    boolean_t writer)\n{\n\tint error = 0;\n\n\tif (getzfsvfs(name, zfvp) != 0)\n\t\terror = zfsvfs_create(name, B_FALSE, zfvp);\n\tif (error == 0) {\n\t\tif (writer)\n\t\t\tZFS_TEARDOWN_ENTER_WRITE(*zfvp, tag);\n\t\telse\n\t\t\tZFS_TEARDOWN_ENTER_READ(*zfvp, tag);\n\t\tif ((*zfvp)->z_unmounted) {\n\t\t\t \n\t\t\tZFS_TEARDOWN_EXIT(*zfvp, tag);\n\t\t\treturn (SET_ERROR(EBUSY));\n\t\t}\n\t}\n\treturn (error);\n}\n\nstatic void\nzfsvfs_rele(zfsvfs_t *zfsvfs, const void *tag)\n{\n\tZFS_TEARDOWN_EXIT(zfsvfs, tag);\n\n\tif (zfs_vfs_held(zfsvfs)) {\n\t\tzfs_vfs_rele(zfsvfs);\n\t} else {\n\t\tdmu_objset_disown(zfsvfs->z_os, B_TRUE, zfsvfs);\n\t\tzfsvfs_free(zfsvfs);\n\t}\n}\n\nstatic int\nzfs_ioc_pool_create(zfs_cmd_t *zc)\n{\n\tint error;\n\tnvlist_t *config, *props = NULL;\n\tnvlist_t *rootprops = NULL;\n\tnvlist_t *zplprops = NULL;\n\tdsl_crypto_params_t *dcp = NULL;\n\tconst char *spa_name = zc->zc_name;\n\tboolean_t unload_wkey = B_TRUE;\n\n\tif ((error = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &config)))\n\t\treturn (error);\n\n\tif (zc->zc_nvlist_src_size != 0 && (error =\n\t    get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &props))) {\n\t\tnvlist_free(config);\n\t\treturn (error);\n\t}\n\n\tif (props) {\n\t\tnvlist_t *nvl = NULL;\n\t\tnvlist_t *hidden_args = NULL;\n\t\tuint64_t version = SPA_VERSION;\n\t\tconst char *tname;\n\n\t\t(void) nvlist_lookup_uint64(props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_VERSION), &version);\n\t\tif (!SPA_VERSION_IS_SUPPORTED(version)) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tgoto pool_props_bad;\n\t\t}\n\t\t(void) nvlist_lookup_nvlist(props, ZPOOL_ROOTFS_PROPS, &nvl);\n\t\tif (nvl) {\n\t\t\terror = nvlist_dup(nvl, &rootprops, KM_SLEEP);\n\t\t\tif (error != 0)\n\t\t\t\tgoto pool_props_bad;\n\t\t\t(void) nvlist_remove_all(props, ZPOOL_ROOTFS_PROPS);\n\t\t}\n\n\t\t(void) nvlist_lookup_nvlist(props, ZPOOL_HIDDEN_ARGS,\n\t\t    &hidden_args);\n\t\terror = dsl_crypto_params_create_nvlist(DCP_CMD_NONE,\n\t\t    rootprops, hidden_args, &dcp);\n\t\tif (error != 0)\n\t\t\tgoto pool_props_bad;\n\t\t(void) nvlist_remove_all(props, ZPOOL_HIDDEN_ARGS);\n\n\t\tVERIFY(nvlist_alloc(&zplprops, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\t\terror = zfs_fill_zplprops_root(version, rootprops,\n\t\t    zplprops, NULL);\n\t\tif (error != 0)\n\t\t\tgoto pool_props_bad;\n\n\t\tif (nvlist_lookup_string(props,\n\t\t    zpool_prop_to_name(ZPOOL_PROP_TNAME), &tname) == 0)\n\t\t\tspa_name = tname;\n\t}\n\n\terror = spa_create(zc->zc_name, config, props, zplprops, dcp);\n\n\t \n\tif (!error && (error = zfs_set_prop_nvlist(spa_name,\n\t    ZPROP_SRC_LOCAL, rootprops, NULL)) != 0) {\n\t\t(void) spa_destroy(spa_name);\n\t\tunload_wkey = B_FALSE;  \n\t}\n\npool_props_bad:\n\tnvlist_free(rootprops);\n\tnvlist_free(zplprops);\n\tnvlist_free(config);\n\tnvlist_free(props);\n\tdsl_crypto_params_free(dcp, unload_wkey && !!error);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_destroy(zfs_cmd_t *zc)\n{\n\tint error;\n\tzfs_log_history(zc);\n\terror = spa_destroy(zc->zc_name);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_import(zfs_cmd_t *zc)\n{\n\tnvlist_t *config, *props = NULL;\n\tuint64_t guid;\n\tint error;\n\n\tif ((error = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &config)) != 0)\n\t\treturn (error);\n\n\tif (zc->zc_nvlist_src_size != 0 && (error =\n\t    get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &props))) {\n\t\tnvlist_free(config);\n\t\treturn (error);\n\t}\n\n\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID, &guid) != 0 ||\n\t    guid != zc->zc_guid)\n\t\terror = SET_ERROR(EINVAL);\n\telse\n\t\terror = spa_import(zc->zc_name, config, props, zc->zc_cookie);\n\n\tif (zc->zc_nvlist_dst != 0) {\n\t\tint err;\n\n\t\tif ((err = put_nvlist(zc, config)) != 0)\n\t\t\terror = err;\n\t}\n\n\tnvlist_free(config);\n\tnvlist_free(props);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_export(zfs_cmd_t *zc)\n{\n\tint error;\n\tboolean_t force = (boolean_t)zc->zc_cookie;\n\tboolean_t hardforce = (boolean_t)zc->zc_guid;\n\n\tzfs_log_history(zc);\n\terror = spa_export(zc->zc_name, NULL, force, hardforce);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_configs(zfs_cmd_t *zc)\n{\n\tnvlist_t *configs;\n\tint error;\n\n\terror = spa_all_configs(&zc->zc_cookie, &configs);\n\tif (error)\n\t\treturn (error);\n\n\terror = put_nvlist(zc, configs);\n\n\tnvlist_free(configs);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_pool_stats(zfs_cmd_t *zc)\n{\n\tnvlist_t *config;\n\tint error;\n\tint ret = 0;\n\n\terror = spa_get_stats(zc->zc_name, &config, zc->zc_value,\n\t    sizeof (zc->zc_value));\n\n\tif (config != NULL) {\n\t\tret = put_nvlist(zc, config);\n\t\tnvlist_free(config);\n\n\t\t \n\t\tzc->zc_cookie = error;\n\t} else {\n\t\tret = error;\n\t}\n\n\treturn (ret);\n}\n\n \nstatic int\nzfs_ioc_pool_tryimport(zfs_cmd_t *zc)\n{\n\tnvlist_t *tryconfig, *config = NULL;\n\tint error;\n\n\tif ((error = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &tryconfig)) != 0)\n\t\treturn (error);\n\n\tconfig = spa_tryimport(tryconfig);\n\n\tnvlist_free(tryconfig);\n\n\tif (config == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = put_nvlist(zc, config);\n\tnvlist_free(config);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_pool_scan(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\tif (zc->zc_flags >= POOL_SCRUB_FLAGS_END)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zc->zc_flags == POOL_SCRUB_PAUSE)\n\t\terror = spa_scrub_pause_resume(spa, POOL_SCRUB_PAUSE);\n\telse if (zc->zc_cookie == POOL_SCAN_NONE)\n\t\terror = spa_scan_stop(spa);\n\telse\n\t\terror = spa_scan(spa, zc->zc_cookie);\n\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_scrub[] = {\n\t{\"scan_type\",\t\tDATA_TYPE_UINT64,\t0},\n\t{\"scan_command\",\tDATA_TYPE_UINT64,\t0},\n};\n\nstatic int\nzfs_ioc_pool_scrub(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tspa_t *spa;\n\tint error;\n\tuint64_t scan_type, scan_cmd;\n\n\tif (nvlist_lookup_uint64(innvl, \"scan_type\", &scan_type) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (nvlist_lookup_uint64(innvl, \"scan_command\", &scan_cmd) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (scan_cmd >= POOL_SCRUB_FLAGS_END)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = spa_open(poolname, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (scan_cmd == POOL_SCRUB_PAUSE) {\n\t\terror = spa_scrub_pause_resume(spa, POOL_SCRUB_PAUSE);\n\t} else if (scan_type == POOL_SCAN_NONE) {\n\t\terror = spa_scan_stop(spa);\n\t} else {\n\t\terror = spa_scan(spa, scan_type);\n\t}\n\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_freeze(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\terror = spa_open(zc->zc_name, &spa, FTAG);\n\tif (error == 0) {\n\t\tspa_freeze(spa);\n\t\tspa_close(spa, FTAG);\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_upgrade(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zc->zc_cookie < spa_version(spa) ||\n\t    !SPA_VERSION_IS_SUPPORTED(zc->zc_cookie)) {\n\t\tspa_close(spa, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tspa_upgrade(spa, zc->zc_cookie);\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_get_history(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tchar *hist_buf;\n\tuint64_t size;\n\tint error;\n\n\tif ((size = zc->zc_history_len) == 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (spa_version(spa) < SPA_VERSION_ZPOOL_HISTORY) {\n\t\tspa_close(spa, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\thist_buf = vmem_alloc(size, KM_SLEEP);\n\tif ((error = spa_history_get(spa, &zc->zc_history_offset,\n\t    &zc->zc_history_len, hist_buf)) == 0) {\n\t\terror = ddi_copyout(hist_buf,\n\t\t    (void *)(uintptr_t)zc->zc_history,\n\t\t    zc->zc_history_len, zc->zc_iflags);\n\t}\n\n\tspa_close(spa, FTAG);\n\tvmem_free(hist_buf, size);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_reguid(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\terror = spa_open(zc->zc_name, &spa, FTAG);\n\tif (error == 0) {\n\t\terror = spa_change_guid(spa);\n\t\tspa_close(spa, FTAG);\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_dsobj_to_dsname(zfs_cmd_t *zc)\n{\n\treturn (dsl_dsobj_to_dsname(zc->zc_name, zc->zc_obj, zc->zc_value));\n}\n\n \nstatic int\nzfs_ioc_obj_to_path(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tint error;\n\n\t \n\tif ((error = dmu_objset_hold_flags(zc->zc_name, B_TRUE,\n\t    FTAG, &os)) != 0)\n\t\treturn (error);\n\tif (dmu_objset_type(os) != DMU_OST_ZFS) {\n\t\tdmu_objset_rele_flags(os, B_TRUE, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\terror = zfs_obj_to_path(os, zc->zc_obj, zc->zc_value,\n\t    sizeof (zc->zc_value));\n\tdmu_objset_rele_flags(os, B_TRUE, FTAG);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_obj_to_stats(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tint error;\n\n\t \n\tif ((error = dmu_objset_hold_flags(zc->zc_name, B_TRUE,\n\t    FTAG, &os)) != 0)\n\t\treturn (error);\n\tif (dmu_objset_type(os) != DMU_OST_ZFS) {\n\t\tdmu_objset_rele_flags(os, B_TRUE, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\terror = zfs_obj_to_stats(os, zc->zc_obj, &zc->zc_stat, zc->zc_value,\n\t    sizeof (zc->zc_value));\n\tdmu_objset_rele_flags(os, B_TRUE, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_add(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\tnvlist_t *config;\n\n\terror = spa_open(zc->zc_name, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &config);\n\tif (error == 0) {\n\t\terror = spa_vdev_add(spa, config);\n\t\tnvlist_free(config);\n\t}\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_vdev_remove(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\terror = spa_open(zc->zc_name, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\tif (zc->zc_cookie != 0) {\n\t\terror = spa_vdev_remove_cancel(spa);\n\t} else {\n\t\terror = spa_vdev_remove(spa, zc->zc_guid, B_FALSE);\n\t}\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_set_state(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\tvdev_state_t newstate = VDEV_STATE_UNKNOWN;\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\tswitch (zc->zc_cookie) {\n\tcase VDEV_STATE_ONLINE:\n\t\terror = vdev_online(spa, zc->zc_guid, zc->zc_obj, &newstate);\n\t\tbreak;\n\n\tcase VDEV_STATE_OFFLINE:\n\t\terror = vdev_offline(spa, zc->zc_guid, zc->zc_obj);\n\t\tbreak;\n\n\tcase VDEV_STATE_FAULTED:\n\t\tif (zc->zc_obj != VDEV_AUX_ERR_EXCEEDED &&\n\t\t    zc->zc_obj != VDEV_AUX_EXTERNAL &&\n\t\t    zc->zc_obj != VDEV_AUX_EXTERNAL_PERSIST)\n\t\t\tzc->zc_obj = VDEV_AUX_ERR_EXCEEDED;\n\n\t\terror = vdev_fault(spa, zc->zc_guid, zc->zc_obj);\n\t\tbreak;\n\n\tcase VDEV_STATE_DEGRADED:\n\t\tif (zc->zc_obj != VDEV_AUX_ERR_EXCEEDED &&\n\t\t    zc->zc_obj != VDEV_AUX_EXTERNAL)\n\t\t\tzc->zc_obj = VDEV_AUX_ERR_EXCEEDED;\n\n\t\terror = vdev_degrade(spa, zc->zc_guid, zc->zc_obj);\n\t\tbreak;\n\n\tcase VDEV_STATE_REMOVED:\n\t\terror = vdev_remove_wanted(spa, zc->zc_guid);\n\t\tbreak;\n\n\tdefault:\n\t\terror = SET_ERROR(EINVAL);\n\t}\n\tzc->zc_cookie = newstate;\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_attach(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tnvlist_t *config;\n\tint replacing = zc->zc_cookie;\n\tint rebuild = zc->zc_simple;\n\tint error;\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((error = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &config)) == 0) {\n\t\terror = spa_vdev_attach(spa, zc->zc_guid, config, replacing,\n\t\t    rebuild);\n\t\tnvlist_free(config);\n\t}\n\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_detach(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = spa_vdev_detach(spa, zc->zc_guid, 0, B_FALSE);\n\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_split(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tnvlist_t *config, *props = NULL;\n\tint error;\n\tboolean_t exp = !!(zc->zc_cookie & ZPOOL_EXPORT_AFTER_SPLIT);\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((error = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &config))) {\n\t\tspa_close(spa, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zc->zc_nvlist_src_size != 0 && (error =\n\t    get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &props))) {\n\t\tspa_close(spa, FTAG);\n\t\tnvlist_free(config);\n\t\treturn (error);\n\t}\n\n\terror = spa_vdev_split_mirror(spa, zc->zc_string, config, props, exp);\n\n\tspa_close(spa, FTAG);\n\n\tnvlist_free(config);\n\tnvlist_free(props);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_setpath(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tconst char *path = zc->zc_value;\n\tuint64_t guid = zc->zc_guid;\n\tint error;\n\n\terror = spa_open(zc->zc_name, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = spa_vdev_setpath(spa, guid, path);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_vdev_setfru(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tconst char *fru = zc->zc_value;\n\tuint64_t guid = zc->zc_guid;\n\tint error;\n\n\terror = spa_open(zc->zc_name, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = spa_vdev_setfru(spa, guid, fru);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_objset_stats_impl(zfs_cmd_t *zc, objset_t *os)\n{\n\tint error = 0;\n\tnvlist_t *nv;\n\n\tdmu_objset_fast_stat(os, &zc->zc_objset_stats);\n\n\tif (!zc->zc_simple && zc->zc_nvlist_dst != 0 &&\n\t    (error = dsl_prop_get_all(os, &nv)) == 0) {\n\t\tdmu_objset_stats(os, nv);\n\t\t \n\t\tif (!zc->zc_objset_stats.dds_inconsistent &&\n\t\t    dmu_objset_type(os) == DMU_OST_ZVOL) {\n\t\t\terror = zvol_get_stats(os, nv);\n\t\t\tif (error == EIO) {\n\t\t\t\tnvlist_free(nv);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tVERIFY0(error);\n\t\t}\n\t\tif (error == 0)\n\t\t\terror = put_nvlist(zc, nv);\n\t\tnvlist_free(nv);\n\t}\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_objset_stats(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tint error;\n\n\terror = dmu_objset_hold(zc->zc_name, FTAG, &os);\n\tif (error == 0) {\n\t\terror = zfs_ioc_objset_stats_impl(zc, os);\n\t\tdmu_objset_rele(os, FTAG);\n\t}\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_objset_recvd_props(zfs_cmd_t *zc)\n{\n\tint error = 0;\n\tnvlist_t *nv;\n\n\t \n\tif (!dsl_prop_get_hasrecvd(zc->zc_name))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (zc->zc_nvlist_dst != 0 &&\n\t    (error = dsl_prop_get_received(zc->zc_name, &nv)) == 0) {\n\t\terror = put_nvlist(zc, nv);\n\t\tnvlist_free(nv);\n\t}\n\n\treturn (error);\n}\n\nstatic int\nnvl_add_zplprop(objset_t *os, nvlist_t *props, zfs_prop_t prop)\n{\n\tuint64_t value;\n\tint error;\n\n\t \n\tif ((error = zfs_get_zplprop(os, prop, &value)) != 0)\n\t\treturn (error);\n\tVERIFY(nvlist_add_uint64(props, zfs_prop_to_name(prop), value) == 0);\n\treturn (0);\n}\n\n \nstatic int\nzfs_ioc_objset_zplprops(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tint err;\n\n\t \n\tif ((err = dmu_objset_hold(zc->zc_name, FTAG, &os)))\n\t\treturn (err);\n\n\tdmu_objset_fast_stat(os, &zc->zc_objset_stats);\n\n\t \n\tif (zc->zc_nvlist_dst != 0 &&\n\t    !zc->zc_objset_stats.dds_inconsistent &&\n\t    dmu_objset_type(os) == DMU_OST_ZFS) {\n\t\tnvlist_t *nv;\n\n\t\tVERIFY(nvlist_alloc(&nv, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\t\tif ((err = nvl_add_zplprop(os, nv, ZFS_PROP_VERSION)) == 0 &&\n\t\t    (err = nvl_add_zplprop(os, nv, ZFS_PROP_NORMALIZE)) == 0 &&\n\t\t    (err = nvl_add_zplprop(os, nv, ZFS_PROP_UTF8ONLY)) == 0 &&\n\t\t    (err = nvl_add_zplprop(os, nv, ZFS_PROP_CASE)) == 0)\n\t\t\terr = put_nvlist(zc, nv);\n\t\tnvlist_free(nv);\n\t} else {\n\t\terr = SET_ERROR(ENOENT);\n\t}\n\tdmu_objset_rele(os, FTAG);\n\treturn (err);\n}\n\n \nstatic int\nzfs_ioc_dataset_list_next(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tint error;\n\tchar *p;\n\tsize_t orig_len = strlen(zc->zc_name);\n\ntop:\n\tif ((error = dmu_objset_hold(zc->zc_name, FTAG, &os))) {\n\t\tif (error == ENOENT)\n\t\t\terror = SET_ERROR(ESRCH);\n\t\treturn (error);\n\t}\n\n\tp = strrchr(zc->zc_name, '/');\n\tif (p == NULL || p[1] != '\\0')\n\t\t(void) strlcat(zc->zc_name, \"/\", sizeof (zc->zc_name));\n\tp = zc->zc_name + strlen(zc->zc_name);\n\n\tdo {\n\t\terror = dmu_dir_list_next(os,\n\t\t    sizeof (zc->zc_name) - (p - zc->zc_name), p,\n\t\t    NULL, &zc->zc_cookie);\n\t\tif (error == ENOENT)\n\t\t\terror = SET_ERROR(ESRCH);\n\t} while (error == 0 && zfs_dataset_name_hidden(zc->zc_name));\n\tdmu_objset_rele(os, FTAG);\n\n\t \n\tif (error == 0 && strchr(zc->zc_name, '$') == NULL) {\n\t\terror = zfs_ioc_objset_stats(zc);  \n\t\tif (error == ENOENT) {\n\t\t\t \n\t\t\tzc->zc_name[orig_len] = '\\0';\n\t\t\tgoto top;\n\t\t}\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_snapshot_list_next(zfs_cmd_t *zc)\n{\n\tint error;\n\tobjset_t *os, *ossnap;\n\tdsl_dataset_t *ds;\n\tuint64_t min_txg = 0, max_txg = 0;\n\n\tif (zc->zc_nvlist_src_size != 0) {\n\t\tnvlist_t *props = NULL;\n\t\terror = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t\t    zc->zc_iflags, &props);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t\t(void) nvlist_lookup_uint64(props, SNAP_ITER_MIN_TXG,\n\t\t    &min_txg);\n\t\t(void) nvlist_lookup_uint64(props, SNAP_ITER_MAX_TXG,\n\t\t    &max_txg);\n\t\tnvlist_free(props);\n\t}\n\n\terror = dmu_objset_hold(zc->zc_name, FTAG, &os);\n\tif (error != 0) {\n\t\treturn (error == ENOENT ? SET_ERROR(ESRCH) : error);\n\t}\n\n\t \n\tif (strlcat(zc->zc_name, \"@\", sizeof (zc->zc_name)) >=\n\t    ZFS_MAX_DATASET_NAME_LEN) {\n\t\tdmu_objset_rele(os, FTAG);\n\t\treturn (SET_ERROR(ESRCH));\n\t}\n\n\twhile (error == 0) {\n\t\tif (issig(JUSTLOOKING) && issig(FORREAL)) {\n\t\t\terror = SET_ERROR(EINTR);\n\t\t\tbreak;\n\t\t}\n\n\t\terror = dmu_snapshot_list_next(os,\n\t\t    sizeof (zc->zc_name) - strlen(zc->zc_name),\n\t\t    zc->zc_name + strlen(zc->zc_name), &zc->zc_obj,\n\t\t    &zc->zc_cookie, NULL);\n\t\tif (error == ENOENT) {\n\t\t\terror = SET_ERROR(ESRCH);\n\t\t\tbreak;\n\t\t} else if (error != 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\terror = dsl_dataset_hold_obj(dmu_objset_pool(os), zc->zc_obj,\n\t\t    FTAG, &ds);\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\tif ((min_txg != 0 && dsl_get_creationtxg(ds) < min_txg) ||\n\t\t    (max_txg != 0 && dsl_get_creationtxg(ds) > max_txg)) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t \n\t\t\t*(strchr(zc->zc_name, '@') + 1) = '\\0';\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (zc->zc_simple) {\n\t\t\tdsl_dataset_fast_stat(ds, &zc->zc_objset_stats);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = dmu_objset_from_ds(ds, &ossnap)) != 0) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = zfs_ioc_objset_stats_impl(zc, ossnap)) != 0) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tbreak;\n\t\t}\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tbreak;\n\t}\n\n\tdmu_objset_rele(os, FTAG);\n\t \n\tif (error != 0)\n\t\t*strchr(zc->zc_name, '@') = '\\0';\n\treturn (error);\n}\n\nstatic int\nzfs_prop_set_userquota(const char *dsname, nvpair_t *pair)\n{\n\tconst char *propname = nvpair_name(pair);\n\tuint64_t *valary;\n\tunsigned int vallen;\n\tconst char *dash, *domain;\n\tzfs_userquota_prop_t type;\n\tuint64_t rid;\n\tuint64_t quota;\n\tzfsvfs_t *zfsvfs;\n\tint err;\n\n\tif (nvpair_type(pair) == DATA_TYPE_NVLIST) {\n\t\tnvlist_t *attrs;\n\t\tVERIFY(nvpair_value_nvlist(pair, &attrs) == 0);\n\t\tif (nvlist_lookup_nvpair(attrs, ZPROP_VALUE,\n\t\t    &pair) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif ((dash = strchr(propname, '-')) == NULL ||\n\t    nvpair_value_uint64_array(pair, &valary, &vallen) != 0 ||\n\t    vallen != 3)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tdomain = dash + 1;\n\ttype = valary[0];\n\trid = valary[1];\n\tquota = valary[2];\n\n\terr = zfsvfs_hold(dsname, FTAG, &zfsvfs, B_FALSE);\n\tif (err == 0) {\n\t\terr = zfs_set_userquota(zfsvfs, type, domain, rid, quota);\n\t\tzfsvfs_rele(zfsvfs, FTAG);\n\t}\n\n\treturn (err);\n}\n\n \nstatic int\nzfs_prop_set_special(const char *dsname, zprop_source_t source,\n    nvpair_t *pair)\n{\n\tconst char *propname = nvpair_name(pair);\n\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\tuint64_t intval = 0;\n\tconst char *strval = NULL;\n\tint err = -1;\n\n\tif (prop == ZPROP_USERPROP) {\n\t\tif (zfs_prop_userquota(propname))\n\t\t\treturn (zfs_prop_set_userquota(dsname, pair));\n\t\treturn (-1);\n\t}\n\n\tif (nvpair_type(pair) == DATA_TYPE_NVLIST) {\n\t\tnvlist_t *attrs;\n\t\tVERIFY(nvpair_value_nvlist(pair, &attrs) == 0);\n\t\tVERIFY(nvlist_lookup_nvpair(attrs, ZPROP_VALUE,\n\t\t    &pair) == 0);\n\t}\n\n\t \n\tif (zfs_prop_get_type(prop) == PROP_TYPE_STRING) {\n\t\tstrval = fnvpair_value_string(pair);\n\t} else {\n\t\tintval = fnvpair_value_uint64(pair);\n\t}\n\n\tswitch (prop) {\n\tcase ZFS_PROP_QUOTA:\n\t\terr = dsl_dir_set_quota(dsname, source, intval);\n\t\tbreak;\n\tcase ZFS_PROP_REFQUOTA:\n\t\terr = dsl_dataset_set_refquota(dsname, source, intval);\n\t\tbreak;\n\tcase ZFS_PROP_FILESYSTEM_LIMIT:\n\tcase ZFS_PROP_SNAPSHOT_LIMIT:\n\t\tif (intval == UINT64_MAX) {\n\t\t\t \n\t\t\terr = 0;\n\t\t} else {\n\t\t\terr = dsl_dir_activate_fs_ss_limit(dsname);\n\t\t}\n\t\t \n\t\tif (err == 0)\n\t\t\terr = -1;\n\t\tbreak;\n\tcase ZFS_PROP_KEYLOCATION:\n\t\terr = dsl_crypto_can_set_keylocation(dsname, strval);\n\n\t\t \n\t\tif (err == 0)\n\t\t\terr = -1;\n\t\tbreak;\n\tcase ZFS_PROP_RESERVATION:\n\t\terr = dsl_dir_set_reservation(dsname, source, intval);\n\t\tbreak;\n\tcase ZFS_PROP_REFRESERVATION:\n\t\terr = dsl_dataset_set_refreservation(dsname, source, intval);\n\t\tbreak;\n\tcase ZFS_PROP_COMPRESSION:\n\t\terr = dsl_dataset_set_compression(dsname, source, intval);\n\t\t \n\t\tif (err == 0)\n\t\t\terr = -1;\n\t\tbreak;\n\tcase ZFS_PROP_VOLSIZE:\n\t\terr = zvol_set_volsize(dsname, intval);\n\t\tbreak;\n\tcase ZFS_PROP_SNAPDEV:\n\t\terr = zvol_set_snapdev(dsname, source, intval);\n\t\tbreak;\n\tcase ZFS_PROP_VOLMODE:\n\t\terr = zvol_set_volmode(dsname, source, intval);\n\t\tbreak;\n\tcase ZFS_PROP_VERSION:\n\t{\n\t\tzfsvfs_t *zfsvfs;\n\n\t\tif ((err = zfsvfs_hold(dsname, FTAG, &zfsvfs, B_TRUE)) != 0)\n\t\t\tbreak;\n\n\t\terr = zfs_set_version(zfsvfs, intval);\n\t\tzfsvfs_rele(zfsvfs, FTAG);\n\n\t\tif (err == 0 && intval >= ZPL_VERSION_USERSPACE) {\n\t\t\tzfs_cmd_t *zc;\n\n\t\t\tzc = kmem_zalloc(sizeof (zfs_cmd_t), KM_SLEEP);\n\t\t\t(void) strlcpy(zc->zc_name, dsname,\n\t\t\t    sizeof (zc->zc_name));\n\t\t\t(void) zfs_ioc_userspace_upgrade(zc);\n\t\t\t(void) zfs_ioc_id_quota_upgrade(zc);\n\t\t\tkmem_free(zc, sizeof (zfs_cmd_t));\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -1;\n\t}\n\n\treturn (err);\n}\n\nstatic boolean_t\nzfs_is_namespace_prop(zfs_prop_t prop)\n{\n\tswitch (prop) {\n\n\tcase ZFS_PROP_ATIME:\n\tcase ZFS_PROP_RELATIME:\n\tcase ZFS_PROP_DEVICES:\n\tcase ZFS_PROP_EXEC:\n\tcase ZFS_PROP_SETUID:\n\tcase ZFS_PROP_READONLY:\n\tcase ZFS_PROP_XATTR:\n\tcase ZFS_PROP_NBMAND:\n\t\treturn (B_TRUE);\n\n\tdefault:\n\t\treturn (B_FALSE);\n\t}\n}\n\n \nint\nzfs_set_prop_nvlist(const char *dsname, zprop_source_t source, nvlist_t *nvl,\n    nvlist_t *errlist)\n{\n\tnvpair_t *pair;\n\tnvpair_t *propval;\n\tint rv = 0;\n\tint err;\n\tuint64_t intval;\n\tconst char *strval;\n\tboolean_t should_update_mount_cache = B_FALSE;\n\n\tnvlist_t *genericnvl = fnvlist_alloc();\n\tnvlist_t *retrynvl = fnvlist_alloc();\nretry:\n\tpair = NULL;\n\twhile ((pair = nvlist_next_nvpair(nvl, pair)) != NULL) {\n\t\tconst char *propname = nvpair_name(pair);\n\t\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\t\terr = 0;\n\n\t\t \n\t\tpropval = pair;\n\t\tif (nvpair_type(pair) == DATA_TYPE_NVLIST) {\n\t\t\tnvlist_t *attrs;\n\t\t\tattrs = fnvpair_value_nvlist(pair);\n\t\t\tif (nvlist_lookup_nvpair(attrs, ZPROP_VALUE,\n\t\t\t    &propval) != 0)\n\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t}\n\n\t\t \n\t\tif (err == 0 && source == ZPROP_SRC_INHERITED) {\n\t\t\t \n\t\t\tif (nvpair_type(propval) != DATA_TYPE_BOOLEAN)\n\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t} else if (err == 0 && prop == ZPROP_USERPROP) {\n\t\t\tif (zfs_prop_user(propname)) {\n\t\t\t\tif (nvpair_type(propval) != DATA_TYPE_STRING)\n\t\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t} else if (zfs_prop_userquota(propname)) {\n\t\t\t\tif (nvpair_type(propval) !=\n\t\t\t\t    DATA_TYPE_UINT64_ARRAY)\n\t\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t} else {\n\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t}\n\t\t} else if (err == 0) {\n\t\t\tif (nvpair_type(propval) == DATA_TYPE_STRING) {\n\t\t\t\tif (zfs_prop_get_type(prop) != PROP_TYPE_STRING)\n\t\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t} else if (nvpair_type(propval) == DATA_TYPE_UINT64) {\n\t\t\t\tconst char *unused;\n\n\t\t\t\tintval = fnvpair_value_uint64(propval);\n\n\t\t\t\tswitch (zfs_prop_get_type(prop)) {\n\t\t\t\tcase PROP_TYPE_NUMBER:\n\t\t\t\t\tbreak;\n\t\t\t\tcase PROP_TYPE_STRING:\n\t\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PROP_TYPE_INDEX:\n\t\t\t\t\tif (zfs_prop_index_to_string(prop,\n\t\t\t\t\t    intval, &unused) != 0)\n\t\t\t\t\t\terr =\n\t\t\t\t\t\t    SET_ERROR(ZFS_ERR_BADPROP);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmn_err(CE_PANIC,\n\t\t\t\t\t    \"unknown property type\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (err == 0)\n\t\t\terr = zfs_check_settable(dsname, pair, CRED());\n\n\t\tif (err == 0) {\n\t\t\tif (source == ZPROP_SRC_INHERITED)\n\t\t\t\terr = -1;  \n\t\t\telse\n\t\t\t\terr = zfs_prop_set_special(dsname, source,\n\t\t\t\t    pair);\n\t\t\tif (err == -1) {\n\t\t\t\t \n\t\t\t\terr = nvlist_add_nvpair(genericnvl, pair);\n\t\t\t} else if (err != 0 && nvl != retrynvl) {\n\t\t\t\t \n\t\t\t\terr = nvlist_add_nvpair(retrynvl, pair);\n\t\t\t}\n\t\t}\n\n\t\tif (err != 0) {\n\t\t\tif (errlist != NULL)\n\t\t\t\tfnvlist_add_int32(errlist, propname, err);\n\t\t\trv = err;\n\t\t}\n\n\t\tif (zfs_is_namespace_prop(prop))\n\t\t\tshould_update_mount_cache = B_TRUE;\n\t}\n\n\tif (nvl != retrynvl && !nvlist_empty(retrynvl)) {\n\t\tnvl = retrynvl;\n\t\tgoto retry;\n\t}\n\n\tif (nvlist_empty(genericnvl))\n\t\tgoto out;\n\n\t \n\terr = dsl_props_set(dsname, source, genericnvl);\n\tif (err == 0)\n\t\tgoto out;\n\n\t \n\tpair = NULL;\n\twhile ((pair = nvlist_next_nvpair(genericnvl, pair)) != NULL) {\n\t\tconst char *propname = nvpair_name(pair);\n\n\t\tpropval = pair;\n\t\tif (nvpair_type(pair) == DATA_TYPE_NVLIST) {\n\t\t\tnvlist_t *attrs;\n\t\t\tattrs = fnvpair_value_nvlist(pair);\n\t\t\tpropval = fnvlist_lookup_nvpair(attrs, ZPROP_VALUE);\n\t\t}\n\n\t\tif (nvpair_type(propval) == DATA_TYPE_STRING) {\n\t\t\tstrval = fnvpair_value_string(propval);\n\t\t\terr = dsl_prop_set_string(dsname, propname,\n\t\t\t    source, strval);\n\t\t} else if (nvpair_type(propval) == DATA_TYPE_BOOLEAN) {\n\t\t\terr = dsl_prop_inherit(dsname, propname, source);\n\t\t} else {\n\t\t\tintval = fnvpair_value_uint64(propval);\n\t\t\terr = dsl_prop_set_int(dsname, propname, source,\n\t\t\t    intval);\n\t\t}\n\n\t\tif (err != 0) {\n\t\t\tif (errlist != NULL) {\n\t\t\t\tfnvlist_add_int32(errlist, propname, err);\n\t\t\t}\n\t\t\trv = err;\n\t\t}\n\t}\n\nout:\n\tif (should_update_mount_cache)\n\t\tzfs_ioctl_update_mount_cache(dsname);\n\n\tnvlist_free(genericnvl);\n\tnvlist_free(retrynvl);\n\n\treturn (rv);\n}\n\n \nstatic int\nzfs_check_userprops(nvlist_t *nvl)\n{\n\tnvpair_t *pair = NULL;\n\n\twhile ((pair = nvlist_next_nvpair(nvl, pair)) != NULL) {\n\t\tconst char *propname = nvpair_name(pair);\n\n\t\tif (!zfs_prop_user(propname) ||\n\t\t    nvpair_type(pair) != DATA_TYPE_STRING)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif (strlen(propname) >= ZAP_MAXNAMELEN)\n\t\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\t\tif (strlen(fnvpair_value_string(pair)) >= ZAP_MAXVALUELEN)\n\t\t\treturn (SET_ERROR(E2BIG));\n\t}\n\treturn (0);\n}\n\nstatic void\nprops_skip(nvlist_t *props, nvlist_t *skipped, nvlist_t **newprops)\n{\n\tnvpair_t *pair;\n\n\tVERIFY(nvlist_alloc(newprops, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\tpair = NULL;\n\twhile ((pair = nvlist_next_nvpair(props, pair)) != NULL) {\n\t\tif (nvlist_exists(skipped, nvpair_name(pair)))\n\t\t\tcontinue;\n\n\t\tVERIFY(nvlist_add_nvpair(*newprops, pair) == 0);\n\t}\n}\n\nstatic int\nclear_received_props(const char *dsname, nvlist_t *props,\n    nvlist_t *skipped)\n{\n\tint err = 0;\n\tnvlist_t *cleared_props = NULL;\n\tprops_skip(props, skipped, &cleared_props);\n\tif (!nvlist_empty(cleared_props)) {\n\t\t \n\t\tzprop_source_t flags = (ZPROP_SRC_NONE |\n\t\t    (dsl_prop_get_hasrecvd(dsname) ? ZPROP_SRC_RECEIVED : 0));\n\t\terr = zfs_set_prop_nvlist(dsname, flags, cleared_props, NULL);\n\t}\n\tnvlist_free(cleared_props);\n\treturn (err);\n}\n\n \nstatic int\nzfs_ioc_set_prop(zfs_cmd_t *zc)\n{\n\tnvlist_t *nvl;\n\tboolean_t received = zc->zc_cookie;\n\tzprop_source_t source = (received ? ZPROP_SRC_RECEIVED :\n\t    ZPROP_SRC_LOCAL);\n\tnvlist_t *errors;\n\tint error;\n\n\tif ((error = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &nvl)) != 0)\n\t\treturn (error);\n\n\tif (received) {\n\t\tnvlist_t *origprops;\n\n\t\tif (dsl_prop_get_received(zc->zc_name, &origprops) == 0) {\n\t\t\t(void) clear_received_props(zc->zc_name,\n\t\t\t    origprops, nvl);\n\t\t\tnvlist_free(origprops);\n\t\t}\n\n\t\terror = dsl_prop_set_hasrecvd(zc->zc_name);\n\t}\n\n\terrors = fnvlist_alloc();\n\tif (error == 0)\n\t\terror = zfs_set_prop_nvlist(zc->zc_name, source, nvl, errors);\n\n\tif (zc->zc_nvlist_dst != 0 && errors != NULL) {\n\t\t(void) put_nvlist(zc, errors);\n\t}\n\n\tnvlist_free(errors);\n\tnvlist_free(nvl);\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_inherit_prop(zfs_cmd_t *zc)\n{\n\tconst char *propname = zc->zc_value;\n\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\tboolean_t received = zc->zc_cookie;\n\tzprop_source_t source = (received\n\t    ? ZPROP_SRC_NONE\t\t \n\t    : ZPROP_SRC_INHERITED);\t \n\tnvlist_t *dummy;\n\tnvpair_t *pair;\n\tzprop_type_t type;\n\tint err;\n\n\tif (!received) {\n\t\t \n\t\tif (prop != ZPROP_USERPROP && !zfs_prop_inheritable(prop))\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (prop == ZPROP_USERPROP) {\n\t\tif (!zfs_prop_user(propname))\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\ttype = PROP_TYPE_STRING;\n\t} else if (prop == ZFS_PROP_VOLSIZE || prop == ZFS_PROP_VERSION) {\n\t\treturn (SET_ERROR(EINVAL));\n\t} else {\n\t\ttype = zfs_prop_get_type(prop);\n\t}\n\n\t \n\tdummy = fnvlist_alloc();\n\n\tswitch (type) {\n\tcase PROP_TYPE_STRING:\n\t\tVERIFY(0 == nvlist_add_string(dummy, propname, \"\"));\n\t\tbreak;\n\tcase PROP_TYPE_NUMBER:\n\tcase PROP_TYPE_INDEX:\n\t\tVERIFY(0 == nvlist_add_uint64(dummy, propname, 0));\n\t\tbreak;\n\tdefault:\n\t\terr = SET_ERROR(EINVAL);\n\t\tgoto errout;\n\t}\n\n\tpair = nvlist_next_nvpair(dummy, NULL);\n\tif (pair == NULL) {\n\t\terr = SET_ERROR(EINVAL);\n\t} else {\n\t\terr = zfs_prop_set_special(zc->zc_name, source, pair);\n\t\tif (err == -1)  \n\t\t\terr = dsl_prop_inherit(zc->zc_name, zc->zc_value,\n\t\t\t    source);\n\t}\n\nerrout:\n\tnvlist_free(dummy);\n\treturn (err);\n}\n\nstatic int\nzfs_ioc_pool_set_props(zfs_cmd_t *zc)\n{\n\tnvlist_t *props;\n\tspa_t *spa;\n\tint error;\n\tnvpair_t *pair;\n\n\tif ((error = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &props)))\n\t\treturn (error);\n\n\t \n\tpair = nvlist_next_nvpair(props, NULL);\n\tif (pair != NULL && strcmp(nvpair_name(pair),\n\t    zpool_prop_to_name(ZPOOL_PROP_CACHEFILE)) == 0 &&\n\t    nvlist_next_nvpair(props, pair) == NULL) {\n\t\tmutex_enter(&spa_namespace_lock);\n\t\tif ((spa = spa_lookup(zc->zc_name)) != NULL) {\n\t\t\tspa_configfile_set(spa, props, B_FALSE);\n\t\t\tspa_write_cachefile(spa, B_FALSE, B_TRUE, B_FALSE);\n\t\t}\n\t\tmutex_exit(&spa_namespace_lock);\n\t\tif (spa != NULL) {\n\t\t\tnvlist_free(props);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0) {\n\t\tnvlist_free(props);\n\t\treturn (error);\n\t}\n\n\terror = spa_prop_set(spa, props);\n\n\tnvlist_free(props);\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_pool_get_props(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\tnvlist_t *nvp = NULL;\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0) {\n\t\t \n\t\tmutex_enter(&spa_namespace_lock);\n\t\tif ((spa = spa_lookup(zc->zc_name)) != NULL)\n\t\t\terror = spa_prop_get(spa, &nvp);\n\t\tmutex_exit(&spa_namespace_lock);\n\t} else {\n\t\terror = spa_prop_get(spa, &nvp);\n\t\tspa_close(spa, FTAG);\n\t}\n\n\tif (error == 0 && zc->zc_nvlist_dst != 0)\n\t\terror = put_nvlist(zc, nvp);\n\telse\n\t\terror = SET_ERROR(EFAULT);\n\n\tnvlist_free(nvp);\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_vdev_set_props[] = {\n\t{ZPOOL_VDEV_PROPS_SET_VDEV,\tDATA_TYPE_UINT64,\t0},\n\t{ZPOOL_VDEV_PROPS_SET_PROPS,\tDATA_TYPE_NVLIST,\t0}\n};\n\nstatic int\nzfs_ioc_vdev_set_props(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tspa_t *spa;\n\tint error;\n\tvdev_t *vd;\n\tuint64_t vdev_guid;\n\n\t \n\tif (nvlist_lookup_uint64(innvl, ZPOOL_VDEV_PROPS_SET_VDEV,\n\t    &vdev_guid) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (outnvl == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = spa_open(poolname, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tASSERT(spa_writeable(spa));\n\n\tif ((vd = spa_lookup_by_guid(spa, vdev_guid, B_TRUE)) == NULL) {\n\t\tspa_close(spa, FTAG);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\terror = vdev_prop_set(vd, innvl, outnvl);\n\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_vdev_get_props[] = {\n\t{ZPOOL_VDEV_PROPS_GET_VDEV,\tDATA_TYPE_UINT64,\t0},\n\t{ZPOOL_VDEV_PROPS_GET_PROPS,\tDATA_TYPE_NVLIST,\tZK_OPTIONAL}\n};\n\nstatic int\nzfs_ioc_vdev_get_props(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tspa_t *spa;\n\tint error;\n\tvdev_t *vd;\n\tuint64_t vdev_guid;\n\n\t \n\tif (nvlist_lookup_uint64(innvl, ZPOOL_VDEV_PROPS_GET_VDEV,\n\t    &vdev_guid) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (outnvl == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = spa_open(poolname, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((vd = spa_lookup_by_guid(spa, vdev_guid, B_TRUE)) == NULL) {\n\t\tspa_close(spa, FTAG);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\terror = vdev_prop_get(vd, innvl, outnvl);\n\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_set_fsacl(zfs_cmd_t *zc)\n{\n\tint error;\n\tnvlist_t *fsaclnv = NULL;\n\n\tif ((error = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &fsaclnv)) != 0)\n\t\treturn (error);\n\n\t \n\tif (zfs_deleg_verify_nvlist(fsaclnv) != 0) {\n\t\tnvlist_free(fsaclnv);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\n\terror = secpolicy_zfs(CRED());\n\tif (error != 0) {\n\t\tif (zc->zc_perm_action == B_FALSE) {\n\t\t\terror = dsl_deleg_can_allow(zc->zc_name,\n\t\t\t    fsaclnv, CRED());\n\t\t} else {\n\t\t\terror = dsl_deleg_can_unallow(zc->zc_name,\n\t\t\t    fsaclnv, CRED());\n\t\t}\n\t}\n\n\tif (error == 0)\n\t\terror = dsl_deleg_set(zc->zc_name, fsaclnv, zc->zc_perm_action);\n\n\tnvlist_free(fsaclnv);\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_get_fsacl(zfs_cmd_t *zc)\n{\n\tnvlist_t *nvp;\n\tint error;\n\n\tif ((error = dsl_deleg_get(zc->zc_name, &nvp)) == 0) {\n\t\terror = put_nvlist(zc, nvp);\n\t\tnvlist_free(nvp);\n\t}\n\n\treturn (error);\n}\n\nstatic void\nzfs_create_cb(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx)\n{\n\tzfs_creat_t *zct = arg;\n\n\tzfs_create_fs(os, cr, zct->zct_zplprops, tx);\n}\n\n#define\tZFS_PROP_UNDEFINED\t((uint64_t)-1)\n\n \nstatic int\nzfs_fill_zplprops_impl(objset_t *os, uint64_t zplver,\n    boolean_t fuids_ok, boolean_t sa_ok, nvlist_t *createprops,\n    nvlist_t *zplprops, boolean_t *is_ci)\n{\n\tuint64_t sense = ZFS_PROP_UNDEFINED;\n\tuint64_t norm = ZFS_PROP_UNDEFINED;\n\tuint64_t u8 = ZFS_PROP_UNDEFINED;\n\tint error;\n\n\tASSERT(zplprops != NULL);\n\n\t \n\tif (os != NULL && os->os_phys->os_type != DMU_OST_ZFS)\n\t\treturn (SET_ERROR(ZFS_ERR_WRONG_PARENT));\n\n\t \n\tif (createprops) {\n\t\t(void) nvlist_lookup_uint64(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_VERSION), &zplver);\n\t\t(void) nvlist_lookup_uint64(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_NORMALIZE), &norm);\n\t\t(void) nvlist_remove_all(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_NORMALIZE));\n\t\t(void) nvlist_lookup_uint64(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_UTF8ONLY), &u8);\n\t\t(void) nvlist_remove_all(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_UTF8ONLY));\n\t\t(void) nvlist_lookup_uint64(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_CASE), &sense);\n\t\t(void) nvlist_remove_all(createprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_CASE));\n\t}\n\n\t \n\tif ((zplver < ZPL_VERSION_INITIAL || zplver > ZPL_VERSION) ||\n\t    (zplver >= ZPL_VERSION_FUID && !fuids_ok) ||\n\t    (zplver >= ZPL_VERSION_SA && !sa_ok) ||\n\t    (zplver < ZPL_VERSION_NORMALIZATION &&\n\t    (norm != ZFS_PROP_UNDEFINED || u8 != ZFS_PROP_UNDEFINED ||\n\t    sense != ZFS_PROP_UNDEFINED)))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\t \n\tVERIFY(nvlist_add_uint64(zplprops,\n\t    zfs_prop_to_name(ZFS_PROP_VERSION), zplver) == 0);\n\n\tif (norm == ZFS_PROP_UNDEFINED &&\n\t    (error = zfs_get_zplprop(os, ZFS_PROP_NORMALIZE, &norm)) != 0)\n\t\treturn (error);\n\tVERIFY(nvlist_add_uint64(zplprops,\n\t    zfs_prop_to_name(ZFS_PROP_NORMALIZE), norm) == 0);\n\n\t \n\tif (norm)\n\t\tu8 = 1;\n\tif (u8 == ZFS_PROP_UNDEFINED &&\n\t    (error = zfs_get_zplprop(os, ZFS_PROP_UTF8ONLY, &u8)) != 0)\n\t\treturn (error);\n\tVERIFY(nvlist_add_uint64(zplprops,\n\t    zfs_prop_to_name(ZFS_PROP_UTF8ONLY), u8) == 0);\n\n\tif (sense == ZFS_PROP_UNDEFINED &&\n\t    (error = zfs_get_zplprop(os, ZFS_PROP_CASE, &sense)) != 0)\n\t\treturn (error);\n\tVERIFY(nvlist_add_uint64(zplprops,\n\t    zfs_prop_to_name(ZFS_PROP_CASE), sense) == 0);\n\n\tif (is_ci)\n\t\t*is_ci = (sense == ZFS_CASE_INSENSITIVE);\n\n\treturn (0);\n}\n\nstatic int\nzfs_fill_zplprops(const char *dataset, nvlist_t *createprops,\n    nvlist_t *zplprops, boolean_t *is_ci)\n{\n\tboolean_t fuids_ok, sa_ok;\n\tuint64_t zplver = ZPL_VERSION;\n\tobjset_t *os = NULL;\n\tchar parentname[ZFS_MAX_DATASET_NAME_LEN];\n\tspa_t *spa;\n\tuint64_t spa_vers;\n\tint error;\n\n\tzfs_get_parent(dataset, parentname, sizeof (parentname));\n\n\tif ((error = spa_open(dataset, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\tspa_vers = spa_version(spa);\n\tspa_close(spa, FTAG);\n\n\tzplver = zfs_zpl_version_map(spa_vers);\n\tfuids_ok = (zplver >= ZPL_VERSION_FUID);\n\tsa_ok = (zplver >= ZPL_VERSION_SA);\n\n\t \n\tif ((error = dmu_objset_hold(parentname, FTAG, &os)) != 0)\n\t\treturn (error);\n\n\terror = zfs_fill_zplprops_impl(os, zplver, fuids_ok, sa_ok, createprops,\n\t    zplprops, is_ci);\n\tdmu_objset_rele(os, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_fill_zplprops_root(uint64_t spa_vers, nvlist_t *createprops,\n    nvlist_t *zplprops, boolean_t *is_ci)\n{\n\tboolean_t fuids_ok;\n\tboolean_t sa_ok;\n\tuint64_t zplver = ZPL_VERSION;\n\tint error;\n\n\tzplver = zfs_zpl_version_map(spa_vers);\n\tfuids_ok = (zplver >= ZPL_VERSION_FUID);\n\tsa_ok = (zplver >= ZPL_VERSION_SA);\n\n\terror = zfs_fill_zplprops_impl(NULL, zplver, fuids_ok, sa_ok,\n\t    createprops, zplprops, is_ci);\n\treturn (error);\n}\n\n \n\nstatic const zfs_ioc_key_t zfs_keys_create[] = {\n\t{\"type\",\tDATA_TYPE_INT32,\t0},\n\t{\"props\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n\t{\"hidden_args\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_create(const char *fsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint error = 0;\n\tzfs_creat_t zct = { 0 };\n\tnvlist_t *nvprops = NULL;\n\tnvlist_t *hidden_args = NULL;\n\tvoid (*cbfunc)(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx);\n\tdmu_objset_type_t type;\n\tboolean_t is_insensitive = B_FALSE;\n\tdsl_crypto_params_t *dcp = NULL;\n\n\ttype = (dmu_objset_type_t)fnvlist_lookup_int32(innvl, \"type\");\n\t(void) nvlist_lookup_nvlist(innvl, \"props\", &nvprops);\n\t(void) nvlist_lookup_nvlist(innvl, ZPOOL_HIDDEN_ARGS, &hidden_args);\n\n\tswitch (type) {\n\tcase DMU_OST_ZFS:\n\t\tcbfunc = zfs_create_cb;\n\t\tbreak;\n\n\tcase DMU_OST_ZVOL:\n\t\tcbfunc = zvol_create_cb;\n\t\tbreak;\n\n\tdefault:\n\t\tcbfunc = NULL;\n\t\tbreak;\n\t}\n\tif (strchr(fsname, '@') ||\n\t    strchr(fsname, '%'))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzct.zct_props = nvprops;\n\n\tif (cbfunc == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (type == DMU_OST_ZVOL) {\n\t\tuint64_t volsize, volblocksize;\n\n\t\tif (nvprops == NULL)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\tif (nvlist_lookup_uint64(nvprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE), &volsize) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif ((error = nvlist_lookup_uint64(nvprops,\n\t\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE),\n\t\t    &volblocksize)) != 0 && error != ENOENT)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif (error != 0)\n\t\t\tvolblocksize = zfs_prop_default_numeric(\n\t\t\t    ZFS_PROP_VOLBLOCKSIZE);\n\n\t\tif ((error = zvol_check_volblocksize(fsname,\n\t\t    volblocksize)) != 0 ||\n\t\t    (error = zvol_check_volsize(volsize,\n\t\t    volblocksize)) != 0)\n\t\t\treturn (error);\n\t} else if (type == DMU_OST_ZFS) {\n\t\tint error;\n\n\t\t \n\t\tVERIFY(nvlist_alloc(&zct.zct_zplprops,\n\t\t    NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\t\terror = zfs_fill_zplprops(fsname, nvprops,\n\t\t    zct.zct_zplprops, &is_insensitive);\n\t\tif (error != 0) {\n\t\t\tnvlist_free(zct.zct_zplprops);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\terror = dsl_crypto_params_create_nvlist(DCP_CMD_NONE, nvprops,\n\t    hidden_args, &dcp);\n\tif (error != 0) {\n\t\tnvlist_free(zct.zct_zplprops);\n\t\treturn (error);\n\t}\n\n\terror = dmu_objset_create(fsname, type,\n\t    is_insensitive ? DS_FLAG_CI_DATASET : 0, dcp, cbfunc, &zct);\n\n\tnvlist_free(zct.zct_zplprops);\n\tdsl_crypto_params_free(dcp, !!error);\n\n\t \n\tif (error == 0) {\n\t\terror = zfs_set_prop_nvlist(fsname, ZPROP_SRC_LOCAL,\n\t\t    nvprops, outnvl);\n\t\tif (error != 0) {\n\t\t\tspa_t *spa;\n\t\t\tint error2;\n\n\t\t\t \n\t\t\terror2 = dsl_destroy_head(fsname);\n\t\t\twhile ((error2 == EBUSY) && (type == DMU_OST_ZVOL)) {\n\t\t\t\terror2 = spa_open(fsname, &spa, FTAG);\n\t\t\t\tif (error2 == 0) {\n\t\t\t\t\ttaskq_wait(spa->spa_zvol_taskq);\n\t\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\t}\n\t\t\t\terror2 = dsl_destroy_head(fsname);\n\t\t\t}\n\t\t}\n\t}\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_clone[] = {\n\t{\"origin\",\tDATA_TYPE_STRING,\t0},\n\t{\"props\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n\t{\"hidden_args\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_clone(const char *fsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint error = 0;\n\tnvlist_t *nvprops = NULL;\n\tconst char *origin_name;\n\n\torigin_name = fnvlist_lookup_string(innvl, \"origin\");\n\t(void) nvlist_lookup_nvlist(innvl, \"props\", &nvprops);\n\n\tif (strchr(fsname, '@') ||\n\t    strchr(fsname, '%'))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (dataset_namecheck(origin_name, NULL, NULL) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = dmu_objset_clone(fsname, origin_name);\n\n\t \n\tif (error == 0) {\n\t\terror = zfs_set_prop_nvlist(fsname, ZPROP_SRC_LOCAL,\n\t\t    nvprops, outnvl);\n\t\tif (error != 0)\n\t\t\t(void) dsl_destroy_head(fsname);\n\t}\n\treturn (error);\n}\n\nstatic const zfs_ioc_key_t zfs_keys_remap[] = {\n\t \n};\n\nstatic int\nzfs_ioc_remap(const char *fsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t \n\t(void) fsname, (void) innvl, (void) outnvl;\n\treturn (0);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_snapshot[] = {\n\t{\"snaps\",\tDATA_TYPE_NVLIST,\t0},\n\t{\"props\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_snapshot(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tnvlist_t *snaps;\n\tnvlist_t *props = NULL;\n\tint error, poollen;\n\tnvpair_t *pair;\n\n\t(void) nvlist_lookup_nvlist(innvl, \"props\", &props);\n\tif (!nvlist_empty(props) &&\n\t    zfs_earlier_version(poolname, SPA_VERSION_SNAP_PROPS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif ((error = zfs_check_userprops(props)) != 0)\n\t\treturn (error);\n\n\tsnaps = fnvlist_lookup_nvlist(innvl, \"snaps\");\n\tpoollen = strlen(poolname);\n\tfor (pair = nvlist_next_nvpair(snaps, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(snaps, pair)) {\n\t\tconst char *name = nvpair_name(pair);\n\t\tchar *cp = strchr(name, '@');\n\n\t\t \n\t\tif (cp == NULL ||\n\t\t    zfs_component_namecheck(cp + 1, NULL, NULL) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (strncmp(name, poolname, poollen) != 0 ||\n\t\t    (name[poollen] != '/' && name[poollen] != '@'))\n\t\t\treturn (SET_ERROR(EXDEV));\n\n\t\t \n\t\tif (!nvlist_empty(props)) {\n\t\t\t*cp = '\\0';\n\t\t\terror = zfs_secpolicy_write_perms(name,\n\t\t\t    ZFS_DELEG_PERM_USERPROP, CRED());\n\t\t\t*cp = '@';\n\t\t\tif (error != 0)\n\t\t\t\treturn (error);\n\t\t}\n\n\t\t \n\t\tfor (nvpair_t *pair2 = nvlist_next_nvpair(snaps, pair);\n\t\t    pair2 != NULL; pair2 = nvlist_next_nvpair(snaps, pair2)) {\n\t\t\tif (strncmp(name, nvpair_name(pair2), cp - name + 1)\n\t\t\t    == 0) {\n\t\t\t\treturn (SET_ERROR(EXDEV));\n\t\t\t}\n\t\t}\n\t}\n\n\terror = dsl_dataset_snapshot(snaps, props, outnvl);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_log_history[] = {\n\t{\"message\",\tDATA_TYPE_STRING,\t0},\n};\n\nstatic int\nzfs_ioc_log_history(const char *unused, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) unused, (void) outnvl;\n\tconst char *message;\n\tchar *poolname;\n\tspa_t *spa;\n\tint error;\n\n\t \n\tpoolname = tsd_get(zfs_allow_log_key);\n\tif (poolname == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\t(void) tsd_set(zfs_allow_log_key, NULL);\n\terror = spa_open(poolname, &spa, FTAG);\n\tkmem_strfree(poolname);\n\tif (error != 0)\n\t\treturn (error);\n\n\tmessage = fnvlist_lookup_string(innvl, \"message\");\n\n\tif (spa_version(spa) < SPA_VERSION_ZPOOL_HISTORY) {\n\t\tspa_close(spa, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\terror = spa_history_log(spa, message);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_set_bootenv[] = {\n\t{\"version\",\tDATA_TYPE_UINT64,\t0},\n\t{\"<keys>\",\tDATA_TYPE_ANY, ZK_OPTIONAL | ZK_WILDCARDLIST},\n};\n\nstatic int\nzfs_ioc_set_bootenv(const char *name, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint error;\n\tspa_t *spa;\n\n\tif ((error = spa_open(name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\tspa_vdev_state_enter(spa, SCL_ALL);\n\terror = vdev_label_write_bootenv(spa->spa_root_vdev, innvl);\n\t(void) spa_vdev_state_exit(spa, NULL, 0);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic const zfs_ioc_key_t zfs_keys_get_bootenv[] = {\n\t \n};\n\nstatic int\nzfs_ioc_get_bootenv(const char *name, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tspa_t *spa;\n\tint error;\n\n\tif ((error = spa_open(name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\tspa_vdev_state_enter(spa, SCL_ALL);\n\terror = vdev_label_read_bootenv(spa->spa_root_vdev, outnvl);\n\t(void) spa_vdev_state_exit(spa, NULL, 0);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\n \nvoid\nzfs_unmount_snap(const char *snapname)\n{\n\tif (strchr(snapname, '@') == NULL)\n\t\treturn;\n\n\t(void) zfsctl_snapshot_unmount(snapname, MNT_FORCE);\n}\n\nstatic int\nzfs_unmount_snap_cb(const char *snapname, void *arg)\n{\n\t(void) arg;\n\tzfs_unmount_snap(snapname);\n\treturn (0);\n}\n\n \nvoid\nzfs_destroy_unmount_origin(const char *fsname)\n{\n\tint error;\n\tobjset_t *os;\n\tdsl_dataset_t *ds;\n\n\terror = dmu_objset_hold(fsname, FTAG, &os);\n\tif (error != 0)\n\t\treturn;\n\tds = dmu_objset_ds(os);\n\tif (dsl_dir_is_clone(ds->ds_dir) && DS_IS_DEFER_DESTROY(ds->ds_prev)) {\n\t\tchar originname[ZFS_MAX_DATASET_NAME_LEN];\n\t\tdsl_dataset_name(ds->ds_prev, originname);\n\t\tdmu_objset_rele(os, FTAG);\n\t\tzfs_unmount_snap(originname);\n\t} else {\n\t\tdmu_objset_rele(os, FTAG);\n\t}\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_destroy_snaps[] = {\n\t{\"snaps\",\tDATA_TYPE_NVLIST,\t0},\n\t{\"defer\",\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_destroy_snaps(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint poollen;\n\tnvlist_t *snaps;\n\tnvpair_t *pair;\n\tboolean_t defer;\n\tspa_t *spa;\n\n\tsnaps = fnvlist_lookup_nvlist(innvl, \"snaps\");\n\tdefer = nvlist_exists(innvl, \"defer\");\n\n\tpoollen = strlen(poolname);\n\tfor (pair = nvlist_next_nvpair(snaps, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(snaps, pair)) {\n\t\tconst char *name = nvpair_name(pair);\n\n\t\t \n\t\tif (strncmp(name, poolname, poollen) != 0 ||\n\t\t    (name[poollen] != '/' && name[poollen] != '@'))\n\t\t\treturn (SET_ERROR(EXDEV));\n\n\t\tzfs_unmount_snap(nvpair_name(pair));\n\t\tif (spa_open(name, &spa, FTAG) == 0) {\n\t\t\tzvol_remove_minors(spa, name, B_TRUE);\n\t\t\tspa_close(spa, FTAG);\n\t\t}\n\t}\n\n\treturn (dsl_destroy_snapshots_nvl(snaps, defer, outnvl));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_bookmark[] = {\n\t{\"<bookmark>...\",\tDATA_TYPE_STRING,\tZK_WILDCARDLIST},\n};\n\nstatic int\nzfs_ioc_bookmark(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) poolname;\n\treturn (dsl_bookmark_create(innvl, outnvl));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_get_bookmarks[] = {\n\t{\"<property>...\", DATA_TYPE_BOOLEAN, ZK_WILDCARDLIST | ZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_get_bookmarks(const char *fsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\treturn (dsl_get_bookmarks(fsname, innvl, outnvl));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_get_bookmark_props[] = {\n\t \n};\n\nstatic int\nzfs_ioc_get_bookmark_props(const char *bookmark, nvlist_t *innvl,\n    nvlist_t *outnvl)\n{\n\t(void) innvl;\n\tchar fsname[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *bmname;\n\n\tbmname = strchr(bookmark, '#');\n\tif (bmname == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\tbmname++;\n\n\t(void) strlcpy(fsname, bookmark, sizeof (fsname));\n\t*(strchr(fsname, '#')) = '\\0';\n\n\treturn (dsl_get_bookmark_props(fsname, bmname, outnvl));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_destroy_bookmarks[] = {\n\t{\"<bookmark>...\",\tDATA_TYPE_BOOLEAN,\tZK_WILDCARDLIST},\n};\n\nstatic int\nzfs_ioc_destroy_bookmarks(const char *poolname, nvlist_t *innvl,\n    nvlist_t *outnvl)\n{\n\tint error, poollen;\n\n\tpoollen = strlen(poolname);\n\tfor (nvpair_t *pair = nvlist_next_nvpair(innvl, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(innvl, pair)) {\n\t\tconst char *name = nvpair_name(pair);\n\t\tconst char *cp = strchr(name, '#');\n\n\t\t \n\t\tif (cp == NULL ||\n\t\t    zfs_component_namecheck(cp + 1, NULL, NULL) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (strncmp(name, poolname, poollen) != 0 ||\n\t\t    (name[poollen] != '/' && name[poollen] != '#'))\n\t\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\terror = dsl_bookmark_destroy(innvl, outnvl);\n\treturn (error);\n}\n\nstatic const zfs_ioc_key_t zfs_keys_channel_program[] = {\n\t{\"program\",\tDATA_TYPE_STRING,\t\t0},\n\t{\"arg\",\t\tDATA_TYPE_ANY,\t\t\t0},\n\t{\"sync\",\tDATA_TYPE_BOOLEAN_VALUE,\tZK_OPTIONAL},\n\t{\"instrlimit\",\tDATA_TYPE_UINT64,\t\tZK_OPTIONAL},\n\t{\"memlimit\",\tDATA_TYPE_UINT64,\t\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_channel_program(const char *poolname, nvlist_t *innvl,\n    nvlist_t *outnvl)\n{\n\tconst char *program;\n\tuint64_t instrlimit, memlimit;\n\tboolean_t sync_flag;\n\tnvpair_t *nvarg = NULL;\n\n\tprogram = fnvlist_lookup_string(innvl, ZCP_ARG_PROGRAM);\n\tif (0 != nvlist_lookup_boolean_value(innvl, ZCP_ARG_SYNC, &sync_flag)) {\n\t\tsync_flag = B_TRUE;\n\t}\n\tif (0 != nvlist_lookup_uint64(innvl, ZCP_ARG_INSTRLIMIT, &instrlimit)) {\n\t\tinstrlimit = ZCP_DEFAULT_INSTRLIMIT;\n\t}\n\tif (0 != nvlist_lookup_uint64(innvl, ZCP_ARG_MEMLIMIT, &memlimit)) {\n\t\tmemlimit = ZCP_DEFAULT_MEMLIMIT;\n\t}\n\tnvarg = fnvlist_lookup_nvpair(innvl, ZCP_ARG_ARGLIST);\n\n\tif (instrlimit == 0 || instrlimit > zfs_lua_max_instrlimit)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (memlimit == 0 || memlimit > zfs_lua_max_memlimit)\n\t\treturn (SET_ERROR(EINVAL));\n\n\treturn (zcp_eval(poolname, program, sync_flag, instrlimit, memlimit,\n\t    nvarg, outnvl));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_checkpoint[] = {\n\t \n};\n\nstatic int\nzfs_ioc_pool_checkpoint(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) innvl, (void) outnvl;\n\treturn (spa_checkpoint(poolname));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_discard_checkpoint[] = {\n\t \n};\n\nstatic int\nzfs_ioc_pool_discard_checkpoint(const char *poolname, nvlist_t *innvl,\n    nvlist_t *outnvl)\n{\n\t(void) innvl, (void) outnvl;\n\treturn (spa_checkpoint_discard(poolname));\n}\n\n \nstatic int\nzfs_ioc_destroy(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tdmu_objset_type_t ost;\n\tint err;\n\n\terr = dmu_objset_hold(zc->zc_name, FTAG, &os);\n\tif (err != 0)\n\t\treturn (err);\n\tost = dmu_objset_type(os);\n\tdmu_objset_rele(os, FTAG);\n\n\tif (ost == DMU_OST_ZFS)\n\t\tzfs_unmount_snap(zc->zc_name);\n\n\tif (strchr(zc->zc_name, '@')) {\n\t\terr = dsl_destroy_snapshot(zc->zc_name, zc->zc_defer_destroy);\n\t} else {\n\t\terr = dsl_destroy_head(zc->zc_name);\n\t\tif (err == EEXIST) {\n\t\t\t \n\t\t\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN + 6];\n\n\t\t\tif (snprintf(namebuf, sizeof (namebuf), \"%s/%s\",\n\t\t\t    zc->zc_name, recv_clone_name) >=\n\t\t\t    sizeof (namebuf))\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t\t \n\t\t\terr = dsl_destroy_head(namebuf);\n\t\t\tif (err == 0)\n\t\t\t\terr = dsl_destroy_head(zc->zc_name);\n\t\t\telse if (err == ENOENT)\n\t\t\t\terr = SET_ERROR(EEXIST);\n\t\t}\n\t}\n\n\treturn (err);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_initialize[] = {\n\t{ZPOOL_INITIALIZE_COMMAND,\tDATA_TYPE_UINT64,\t0},\n\t{ZPOOL_INITIALIZE_VDEVS,\tDATA_TYPE_NVLIST,\t0}\n};\n\nstatic int\nzfs_ioc_pool_initialize(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tuint64_t cmd_type;\n\tif (nvlist_lookup_uint64(innvl, ZPOOL_INITIALIZE_COMMAND,\n\t    &cmd_type) != 0) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (!(cmd_type == POOL_INITIALIZE_CANCEL ||\n\t    cmd_type == POOL_INITIALIZE_START ||\n\t    cmd_type == POOL_INITIALIZE_SUSPEND ||\n\t    cmd_type == POOL_INITIALIZE_UNINIT)) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tnvlist_t *vdev_guids;\n\tif (nvlist_lookup_nvlist(innvl, ZPOOL_INITIALIZE_VDEVS,\n\t    &vdev_guids) != 0) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(vdev_guids, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(vdev_guids, pair)) {\n\t\tuint64_t vdev_guid;\n\t\tif (nvpair_value_uint64(pair, &vdev_guid) != 0) {\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t}\n\n\tspa_t *spa;\n\tint error = spa_open(poolname, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\tnvlist_t *vdev_errlist = fnvlist_alloc();\n\tint total_errors = spa_vdev_initialize(spa, vdev_guids, cmd_type,\n\t    vdev_errlist);\n\n\tif (fnvlist_size(vdev_errlist) > 0) {\n\t\tfnvlist_add_nvlist(outnvl, ZPOOL_INITIALIZE_VDEVS,\n\t\t    vdev_errlist);\n\t}\n\tfnvlist_free(vdev_errlist);\n\n\tspa_close(spa, FTAG);\n\treturn (total_errors > 0 ? SET_ERROR(EINVAL) : 0);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_trim[] = {\n\t{ZPOOL_TRIM_COMMAND,\tDATA_TYPE_UINT64,\t\t0},\n\t{ZPOOL_TRIM_VDEVS,\tDATA_TYPE_NVLIST,\t\t0},\n\t{ZPOOL_TRIM_RATE,\tDATA_TYPE_UINT64,\t\tZK_OPTIONAL},\n\t{ZPOOL_TRIM_SECURE,\tDATA_TYPE_BOOLEAN_VALUE,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_pool_trim(const char *poolname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tuint64_t cmd_type;\n\tif (nvlist_lookup_uint64(innvl, ZPOOL_TRIM_COMMAND, &cmd_type) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (!(cmd_type == POOL_TRIM_CANCEL ||\n\t    cmd_type == POOL_TRIM_START ||\n\t    cmd_type == POOL_TRIM_SUSPEND)) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tnvlist_t *vdev_guids;\n\tif (nvlist_lookup_nvlist(innvl, ZPOOL_TRIM_VDEVS, &vdev_guids) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(vdev_guids, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(vdev_guids, pair)) {\n\t\tuint64_t vdev_guid;\n\t\tif (nvpair_value_uint64(pair, &vdev_guid) != 0) {\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t}\n\n\t \n\tuint64_t rate;\n\tif (nvlist_lookup_uint64(innvl, ZPOOL_TRIM_RATE, &rate) != 0)\n\t\trate = 0;\n\n\t \n\tboolean_t secure;\n\tif (nvlist_lookup_boolean_value(innvl, ZPOOL_TRIM_SECURE,\n\t    &secure) != 0) {\n\t\tsecure = B_FALSE;\n\t}\n\n\tspa_t *spa;\n\tint error = spa_open(poolname, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\tnvlist_t *vdev_errlist = fnvlist_alloc();\n\tint total_errors = spa_vdev_trim(spa, vdev_guids, cmd_type,\n\t    rate, !!zfs_trim_metaslab_skip, secure, vdev_errlist);\n\n\tif (fnvlist_size(vdev_errlist) > 0)\n\t\tfnvlist_add_nvlist(outnvl, ZPOOL_TRIM_VDEVS, vdev_errlist);\n\n\tfnvlist_free(vdev_errlist);\n\n\tspa_close(spa, FTAG);\n\treturn (total_errors > 0 ? SET_ERROR(EINVAL) : 0);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_wait[] = {\n\t{ZPOOL_WAIT_ACTIVITY,\tDATA_TYPE_INT32,\t\t0},\n\t{ZPOOL_WAIT_TAG,\tDATA_TYPE_UINT64,\t\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_wait(const char *name, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint32_t activity;\n\tuint64_t tag;\n\tboolean_t waited;\n\tint error;\n\n\tif (nvlist_lookup_int32(innvl, ZPOOL_WAIT_ACTIVITY, &activity) != 0)\n\t\treturn (EINVAL);\n\n\tif (nvlist_lookup_uint64(innvl, ZPOOL_WAIT_TAG, &tag) == 0)\n\t\terror = spa_wait_tag(name, activity, tag, &waited);\n\telse\n\t\terror = spa_wait(name, activity, &waited);\n\n\tif (error == 0)\n\t\tfnvlist_add_boolean_value(outnvl, ZPOOL_WAIT_WAITED, waited);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_fs_wait[] = {\n\t{ZFS_WAIT_ACTIVITY,\tDATA_TYPE_INT32,\t\t0},\n};\n\nstatic int\nzfs_ioc_wait_fs(const char *name, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint32_t activity;\n\tboolean_t waited = B_FALSE;\n\tint error;\n\tdsl_pool_t *dp;\n\tdsl_dir_t *dd;\n\tdsl_dataset_t *ds;\n\n\tif (nvlist_lookup_int32(innvl, ZFS_WAIT_ACTIVITY, &activity) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (activity >= ZFS_WAIT_NUM_ACTIVITIES || activity < 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = dsl_pool_hold(name, FTAG, &dp)) != 0)\n\t\treturn (error);\n\n\tif ((error = dsl_dataset_hold(dp, name, FTAG, &ds)) != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tdd = ds->ds_dir;\n\tmutex_enter(&dd->dd_activity_lock);\n\tdd->dd_activity_waiters++;\n\n\t \n\tdsl_dataset_long_hold(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\terror = dsl_dir_wait(dd, ds, activity, &waited);\n\n\tdsl_dataset_long_rele(ds, FTAG);\n\tdd->dd_activity_waiters--;\n\tif (dd->dd_activity_waiters == 0)\n\t\tcv_signal(&dd->dd_activity_cv);\n\tmutex_exit(&dd->dd_activity_lock);\n\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (error == 0)\n\t\tfnvlist_add_boolean_value(outnvl, ZFS_WAIT_WAITED, waited);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_rollback[] = {\n\t{\"target\",\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_rollback(const char *fsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tzfsvfs_t *zfsvfs;\n\tzvol_state_handle_t *zv;\n\tconst char *target = NULL;\n\tint error;\n\n\t(void) nvlist_lookup_string(innvl, \"target\", &target);\n\tif (target != NULL) {\n\t\tconst char *cp = strchr(target, '@');\n\n\t\t \n\t\tif (cp == NULL ||\n\t\t    zfs_component_namecheck(cp + 1, NULL, NULL) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (getzfsvfs(fsname, &zfsvfs) == 0) {\n\t\tdsl_dataset_t *ds;\n\n\t\tds = dmu_objset_ds(zfsvfs->z_os);\n\t\terror = zfs_suspend_fs(zfsvfs);\n\t\tif (error == 0) {\n\t\t\tint resume_err;\n\n\t\t\terror = dsl_dataset_rollback(fsname, target, zfsvfs,\n\t\t\t    outnvl);\n\t\t\tresume_err = zfs_resume_fs(zfsvfs, ds);\n\t\t\terror = error ? error : resume_err;\n\t\t}\n\t\tzfs_vfs_rele(zfsvfs);\n\t} else if ((zv = zvol_suspend(fsname)) != NULL) {\n\t\terror = dsl_dataset_rollback(fsname, target, zvol_tag(zv),\n\t\t    outnvl);\n\t\tzvol_resume(zv);\n\t} else {\n\t\terror = dsl_dataset_rollback(fsname, target, NULL, outnvl);\n\t}\n\treturn (error);\n}\n\nstatic int\nrecursive_unmount(const char *fsname, void *arg)\n{\n\tconst char *snapname = arg;\n\tchar *fullname;\n\n\tfullname = kmem_asprintf(\"%s@%s\", fsname, snapname);\n\tzfs_unmount_snap(fullname);\n\tkmem_strfree(fullname);\n\n\treturn (0);\n}\n\n \n\nstatic const zfs_ioc_key_t zfs_keys_redact[] = {\n\t{\"bookname\",\t\tDATA_TYPE_STRING,\t0},\n\t{\"snapnv\",\t\tDATA_TYPE_NVLIST,\t0},\n};\n\nstatic int\nzfs_ioc_redact(const char *snapname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) outnvl;\n\tnvlist_t *redactnvl = NULL;\n\tconst char *redactbook = NULL;\n\n\tif (nvlist_lookup_nvlist(innvl, \"snapnv\", &redactnvl) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (fnvlist_num_pairs(redactnvl) == 0)\n\t\treturn (SET_ERROR(ENXIO));\n\tif (nvlist_lookup_string(innvl, \"bookname\", &redactbook) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\treturn (dmu_redact_snap(snapname, redactnvl, redactbook));\n}\n\n \nstatic int\nzfs_ioc_rename(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tdmu_objset_type_t ost;\n\tboolean_t recursive = zc->zc_cookie & 1;\n\tboolean_t nounmount = !!(zc->zc_cookie & 2);\n\tchar *at;\n\tint err;\n\n\t \n\tzc->zc_name[sizeof (zc->zc_name) - 1] = '\\0';\n\tzc->zc_value[sizeof (zc->zc_value) - 1] = '\\0';\n\tif (dataset_namecheck(zc->zc_name, NULL, NULL) != 0 ||\n\t    dataset_namecheck(zc->zc_value, NULL, NULL) != 0 ||\n\t    strchr(zc->zc_name, '%') || strchr(zc->zc_value, '%'))\n\t\treturn (SET_ERROR(EINVAL));\n\n\terr = dmu_objset_hold(zc->zc_name, FTAG, &os);\n\tif (err != 0)\n\t\treturn (err);\n\tost = dmu_objset_type(os);\n\tdmu_objset_rele(os, FTAG);\n\n\tat = strchr(zc->zc_name, '@');\n\tif (at != NULL) {\n\t\t \n\t\tint error;\n\n\t\tif (strncmp(zc->zc_name, zc->zc_value, at - zc->zc_name + 1))\n\t\t\treturn (SET_ERROR(EXDEV));\n\t\t*at = '\\0';\n\t\tif (ost == DMU_OST_ZFS && !nounmount) {\n\t\t\terror = dmu_objset_find(zc->zc_name,\n\t\t\t    recursive_unmount, at + 1,\n\t\t\t    recursive ? DS_FIND_CHILDREN : 0);\n\t\t\tif (error != 0) {\n\t\t\t\t*at = '@';\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\terror = dsl_dataset_rename_snapshot(zc->zc_name,\n\t\t    at + 1, strchr(zc->zc_value, '@') + 1, recursive);\n\t\t*at = '@';\n\n\t\treturn (error);\n\t} else {\n\t\treturn (dsl_dir_rename(zc->zc_name, zc->zc_value));\n\t}\n}\n\nstatic int\nzfs_check_settable(const char *dsname, nvpair_t *pair, cred_t *cr)\n{\n\tconst char *propname = nvpair_name(pair);\n\tboolean_t issnap = (strchr(dsname, '@') != NULL);\n\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\tuint64_t intval, compval;\n\tint err;\n\n\tif (prop == ZPROP_USERPROP) {\n\t\tif (zfs_prop_user(propname)) {\n\t\t\tif ((err = zfs_secpolicy_write_perms(dsname,\n\t\t\t    ZFS_DELEG_PERM_USERPROP, cr)))\n\t\t\t\treturn (err);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif (!issnap && zfs_prop_userquota(propname)) {\n\t\t\tconst char *perm = NULL;\n\t\t\tconst char *uq_prefix =\n\t\t\t    zfs_userquota_prop_prefixes[ZFS_PROP_USERQUOTA];\n\t\t\tconst char *gq_prefix =\n\t\t\t    zfs_userquota_prop_prefixes[ZFS_PROP_GROUPQUOTA];\n\t\t\tconst char *uiq_prefix =\n\t\t\t    zfs_userquota_prop_prefixes[ZFS_PROP_USEROBJQUOTA];\n\t\t\tconst char *giq_prefix =\n\t\t\t    zfs_userquota_prop_prefixes[ZFS_PROP_GROUPOBJQUOTA];\n\t\t\tconst char *pq_prefix =\n\t\t\t    zfs_userquota_prop_prefixes[ZFS_PROP_PROJECTQUOTA];\n\t\t\tconst char *piq_prefix = zfs_userquota_prop_prefixes[\\\n\t\t\t    ZFS_PROP_PROJECTOBJQUOTA];\n\n\t\t\tif (strncmp(propname, uq_prefix,\n\t\t\t    strlen(uq_prefix)) == 0) {\n\t\t\t\tperm = ZFS_DELEG_PERM_USERQUOTA;\n\t\t\t} else if (strncmp(propname, uiq_prefix,\n\t\t\t    strlen(uiq_prefix)) == 0) {\n\t\t\t\tperm = ZFS_DELEG_PERM_USEROBJQUOTA;\n\t\t\t} else if (strncmp(propname, gq_prefix,\n\t\t\t    strlen(gq_prefix)) == 0) {\n\t\t\t\tperm = ZFS_DELEG_PERM_GROUPQUOTA;\n\t\t\t} else if (strncmp(propname, giq_prefix,\n\t\t\t    strlen(giq_prefix)) == 0) {\n\t\t\t\tperm = ZFS_DELEG_PERM_GROUPOBJQUOTA;\n\t\t\t} else if (strncmp(propname, pq_prefix,\n\t\t\t    strlen(pq_prefix)) == 0) {\n\t\t\t\tperm = ZFS_DELEG_PERM_PROJECTQUOTA;\n\t\t\t} else if (strncmp(propname, piq_prefix,\n\t\t\t    strlen(piq_prefix)) == 0) {\n\t\t\t\tperm = ZFS_DELEG_PERM_PROJECTOBJQUOTA;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\n\t\t\tif ((err = zfs_secpolicy_write_perms(dsname, perm, cr)))\n\t\t\t\treturn (err);\n\t\t\treturn (0);\n\t\t}\n\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (issnap)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (nvpair_type(pair) == DATA_TYPE_NVLIST) {\n\t\t \n\t\tnvlist_t *attrs;\n\t\tVERIFY(nvpair_value_nvlist(pair, &attrs) == 0);\n\t\tVERIFY(nvlist_lookup_nvpair(attrs, ZPROP_VALUE,\n\t\t    &pair) == 0);\n\t}\n\n\t \n\tswitch (prop) {\n\tcase ZFS_PROP_COMPRESSION:\n\t\t \n\t\tif (nvpair_value_uint64(pair, &intval) == 0) {\n\t\t\tcompval = ZIO_COMPRESS_ALGO(intval);\n\t\t\tif (compval >= ZIO_COMPRESS_GZIP_1 &&\n\t\t\t    compval <= ZIO_COMPRESS_GZIP_9 &&\n\t\t\t    zfs_earlier_version(dsname,\n\t\t\t    SPA_VERSION_GZIP_COMPRESSION)) {\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t}\n\n\t\t\tif (compval == ZIO_COMPRESS_ZLE &&\n\t\t\t    zfs_earlier_version(dsname,\n\t\t\t    SPA_VERSION_ZLE_COMPRESSION))\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\n\t\t\tif (compval == ZIO_COMPRESS_LZ4) {\n\t\t\t\tspa_t *spa;\n\n\t\t\t\tif ((err = spa_open(dsname, &spa, FTAG)) != 0)\n\t\t\t\t\treturn (err);\n\n\t\t\t\tif (!spa_feature_is_enabled(spa,\n\t\t\t\t    SPA_FEATURE_LZ4_COMPRESS)) {\n\t\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t\t}\n\t\t\t\tspa_close(spa, FTAG);\n\t\t\t}\n\n\t\t\tif (compval == ZIO_COMPRESS_ZSTD) {\n\t\t\t\tspa_t *spa;\n\n\t\t\t\tif ((err = spa_open(dsname, &spa, FTAG)) != 0)\n\t\t\t\t\treturn (err);\n\n\t\t\t\tif (!spa_feature_is_enabled(spa,\n\t\t\t\t    SPA_FEATURE_ZSTD_COMPRESS)) {\n\t\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t\t}\n\t\t\t\tspa_close(spa, FTAG);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_COPIES:\n\t\tif (zfs_earlier_version(dsname, SPA_VERSION_DITTO_BLOCKS))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tbreak;\n\n\tcase ZFS_PROP_VOLBLOCKSIZE:\n\tcase ZFS_PROP_RECORDSIZE:\n\t\t \n\t\tif (nvpair_value_uint64(pair, &intval) == 0 &&\n\t\t    intval > SPA_OLD_MAXBLOCKSIZE) {\n\t\t\tspa_t *spa;\n\n\t\t\t \n\t\t\tif (intval > zfs_max_recordsize ||\n\t\t\t    intval > SPA_MAXBLOCKSIZE)\n\t\t\t\treturn (SET_ERROR(ERANGE));\n\n\t\t\tif ((err = spa_open(dsname, &spa, FTAG)) != 0)\n\t\t\t\treturn (err);\n\n\t\t\tif (!spa_feature_is_enabled(spa,\n\t\t\t    SPA_FEATURE_LARGE_BLOCKS)) {\n\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t}\n\t\t\tspa_close(spa, FTAG);\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_DNODESIZE:\n\t\t \n\t\tif (nvpair_value_uint64(pair, &intval) == 0 &&\n\t\t    intval != ZFS_DNSIZE_LEGACY) {\n\t\t\tspa_t *spa;\n\n\t\t\tif ((err = spa_open(dsname, &spa, FTAG)) != 0)\n\t\t\t\treturn (err);\n\n\t\t\tif (!spa_feature_is_enabled(spa,\n\t\t\t    SPA_FEATURE_LARGE_DNODE)) {\n\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t}\n\t\t\tspa_close(spa, FTAG);\n\t\t}\n\t\tbreak;\n\n\tcase ZFS_PROP_SPECIAL_SMALL_BLOCKS:\n\t\t \n\t\tbreak;\n\n\tcase ZFS_PROP_SHARESMB:\n\t\tif (zpl_earlier_version(dsname, ZPL_VERSION_FUID))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tbreak;\n\n\tcase ZFS_PROP_ACLINHERIT:\n\t\tif (nvpair_type(pair) == DATA_TYPE_UINT64 &&\n\t\t    nvpair_value_uint64(pair, &intval) == 0) {\n\t\t\tif (intval == ZFS_ACL_PASSTHROUGH_X &&\n\t\t\t    zfs_earlier_version(dsname,\n\t\t\t    SPA_VERSION_PASSTHROUGH_X))\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t}\n\t\tbreak;\n\tcase ZFS_PROP_CHECKSUM:\n\tcase ZFS_PROP_DEDUP:\n\t{\n\t\tspa_feature_t feature;\n\t\tspa_t *spa;\n\t\tint err;\n\n\t\t \n\t\tif (prop == ZFS_PROP_DEDUP &&\n\t\t    zfs_earlier_version(dsname, SPA_VERSION_DEDUP))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\n\t\tif (nvpair_type(pair) == DATA_TYPE_UINT64 &&\n\t\t    nvpair_value_uint64(pair, &intval) == 0) {\n\t\t\t \n\t\t\tfeature = zio_checksum_to_feature(\n\t\t\t    intval & ZIO_CHECKSUM_MASK);\n\t\t\tif (feature == SPA_FEATURE_NONE)\n\t\t\t\tbreak;\n\n\t\t\tif ((err = spa_open(dsname, &spa, FTAG)) != 0)\n\t\t\t\treturn (err);\n\n\t\t\tif (!spa_feature_is_enabled(spa, feature)) {\n\t\t\t\tspa_close(spa, FTAG);\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t}\n\t\t\tspa_close(spa, FTAG);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (zfs_secpolicy_setprop(dsname, prop, pair, CRED()));\n}\n\n \nstatic int\nzfs_check_clearable(const char *dataset, nvlist_t *props, nvlist_t **errlist)\n{\n\tzfs_cmd_t *zc;\n\tnvpair_t *pair, *next_pair;\n\tnvlist_t *errors;\n\tint err, rv = 0;\n\n\tif (props == NULL)\n\t\treturn (0);\n\n\tVERIFY(nvlist_alloc(&errors, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\tzc = kmem_alloc(sizeof (zfs_cmd_t), KM_SLEEP);\n\t(void) strlcpy(zc->zc_name, dataset, sizeof (zc->zc_name));\n\tpair = nvlist_next_nvpair(props, NULL);\n\twhile (pair != NULL) {\n\t\tnext_pair = nvlist_next_nvpair(props, pair);\n\n\t\t(void) strlcpy(zc->zc_value, nvpair_name(pair),\n\t\t    sizeof (zc->zc_value));\n\t\tif ((err = zfs_check_settable(dataset, pair, CRED())) != 0 ||\n\t\t    (err = zfs_secpolicy_inherit_prop(zc, NULL, CRED())) != 0) {\n\t\t\tVERIFY(nvlist_remove_nvpair(props, pair) == 0);\n\t\t\tVERIFY(nvlist_add_int32(errors,\n\t\t\t    zc->zc_value, err) == 0);\n\t\t}\n\t\tpair = next_pair;\n\t}\n\tkmem_free(zc, sizeof (zfs_cmd_t));\n\n\tif ((pair = nvlist_next_nvpair(errors, NULL)) == NULL) {\n\t\tnvlist_free(errors);\n\t\terrors = NULL;\n\t} else {\n\t\tVERIFY(nvpair_value_int32(pair, &rv) == 0);\n\t}\n\n\tif (errlist == NULL)\n\t\tnvlist_free(errors);\n\telse\n\t\t*errlist = errors;\n\n\treturn (rv);\n}\n\nstatic boolean_t\npropval_equals(nvpair_t *p1, nvpair_t *p2)\n{\n\tif (nvpair_type(p1) == DATA_TYPE_NVLIST) {\n\t\t \n\t\tnvlist_t *attrs;\n\t\tVERIFY(nvpair_value_nvlist(p1, &attrs) == 0);\n\t\tVERIFY(nvlist_lookup_nvpair(attrs, ZPROP_VALUE,\n\t\t    &p1) == 0);\n\t}\n\n\tif (nvpair_type(p2) == DATA_TYPE_NVLIST) {\n\t\tnvlist_t *attrs;\n\t\tVERIFY(nvpair_value_nvlist(p2, &attrs) == 0);\n\t\tVERIFY(nvlist_lookup_nvpair(attrs, ZPROP_VALUE,\n\t\t    &p2) == 0);\n\t}\n\n\tif (nvpair_type(p1) != nvpair_type(p2))\n\t\treturn (B_FALSE);\n\n\tif (nvpair_type(p1) == DATA_TYPE_STRING) {\n\t\tconst char *valstr1, *valstr2;\n\n\t\tVERIFY(nvpair_value_string(p1, &valstr1) == 0);\n\t\tVERIFY(nvpair_value_string(p2, &valstr2) == 0);\n\t\treturn (strcmp(valstr1, valstr2) == 0);\n\t} else {\n\t\tuint64_t intval1, intval2;\n\n\t\tVERIFY(nvpair_value_uint64(p1, &intval1) == 0);\n\t\tVERIFY(nvpair_value_uint64(p2, &intval2) == 0);\n\t\treturn (intval1 == intval2);\n\t}\n}\n\n \nstatic void\nprops_reduce(nvlist_t *props, nvlist_t *origprops)\n{\n\tnvpair_t *pair, *next_pair;\n\n\tif (origprops == NULL)\n\t\treturn;  \n\n\tpair = nvlist_next_nvpair(props, NULL);\n\twhile (pair != NULL) {\n\t\tconst char *propname = nvpair_name(pair);\n\t\tnvpair_t *match;\n\n\t\tnext_pair = nvlist_next_nvpair(props, pair);\n\n\t\tif ((nvlist_lookup_nvpair(origprops, propname,\n\t\t    &match) != 0) || !propval_equals(pair, match))\n\t\t\tgoto next;  \n\n\t\t \n\t\t(void) nvlist_remove_nvpair(origprops, match);\n\t\t \n\t\t(void) nvlist_remove_nvpair(props, pair);\nnext:\n\t\tpair = next_pair;\n\t}\n}\n\n \nstatic nvlist_t *\nextract_delay_props(nvlist_t *props)\n{\n\tnvlist_t *delayprops;\n\tnvpair_t *nvp, *tmp;\n\tstatic const zfs_prop_t delayable[] = {\n\t\tZFS_PROP_REFQUOTA,\n\t\tZFS_PROP_KEYLOCATION,\n\t\t \n\t\tZFS_PROP_SHARESMB,\n\t\t0\n\t};\n\tint i;\n\n\tVERIFY(nvlist_alloc(&delayprops, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\tfor (nvp = nvlist_next_nvpair(props, NULL); nvp != NULL;\n\t    nvp = nvlist_next_nvpair(props, nvp)) {\n\t\t \n\t\tfor (i = 0; delayable[i] != 0; i++) {\n\t\t\tif (strcmp(zfs_prop_to_name(delayable[i]),\n\t\t\t    nvpair_name(nvp)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delayable[i] != 0) {\n\t\t\ttmp = nvlist_prev_nvpair(props, nvp);\n\t\t\tVERIFY(nvlist_add_nvpair(delayprops, nvp) == 0);\n\t\t\tVERIFY(nvlist_remove_nvpair(props, nvp) == 0);\n\t\t\tnvp = tmp;\n\t\t}\n\t}\n\n\tif (nvlist_empty(delayprops)) {\n\t\tnvlist_free(delayprops);\n\t\tdelayprops = NULL;\n\t}\n\treturn (delayprops);\n}\n\nstatic void\nzfs_allow_log_destroy(void *arg)\n{\n\tchar *poolname = arg;\n\n\tif (poolname != NULL)\n\t\tkmem_strfree(poolname);\n}\n\n#ifdef\tZFS_DEBUG\nstatic boolean_t zfs_ioc_recv_inject_err;\n#endif\n\n \nstatic int\nzfs_ioc_recv_impl(char *tofs, char *tosnap, const char *origin,\n    nvlist_t *recvprops, nvlist_t *localprops, nvlist_t *hidden_args,\n    boolean_t force, boolean_t heal, boolean_t resumable, int input_fd,\n    dmu_replay_record_t *begin_record, uint64_t *read_bytes,\n    uint64_t *errflags, nvlist_t **errors)\n{\n\tdmu_recv_cookie_t drc;\n\tint error = 0;\n\tint props_error = 0;\n\toffset_t off, noff;\n\tnvlist_t *local_delayprops = NULL;\n\tnvlist_t *recv_delayprops = NULL;\n\tnvlist_t *inherited_delayprops = NULL;\n\tnvlist_t *origprops = NULL;  \n\tnvlist_t *origrecvd = NULL;  \n\tboolean_t first_recvd_props = B_FALSE;\n\tboolean_t tofs_was_redacted;\n\tzfs_file_t *input_fp;\n\n\t*read_bytes = 0;\n\t*errflags = 0;\n\t*errors = fnvlist_alloc();\n\toff = 0;\n\n\tif ((input_fp = zfs_file_get(input_fd)) == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\tnoff = off = zfs_file_off(input_fp);\n\terror = dmu_recv_begin(tofs, tosnap, begin_record, force, heal,\n\t    resumable, localprops, hidden_args, origin, &drc, input_fp,\n\t    &off);\n\tif (error != 0)\n\t\tgoto out;\n\ttofs_was_redacted = dsl_get_redacted(drc.drc_ds);\n\n\t \n\tif (recvprops != NULL && !drc.drc_newfs) {\n\t\tif (spa_version(dsl_dataset_get_spa(drc.drc_ds)) >=\n\t\t    SPA_VERSION_RECVD_PROPS &&\n\t\t    !dsl_prop_get_hasrecvd(tofs))\n\t\t\tfirst_recvd_props = B_TRUE;\n\n\t\t \n\t\tif (dsl_prop_get_received(tofs, &origrecvd) == 0) {\n\t\t\tnvlist_t *errlist = NULL;\n\t\t\t \n\t\t\tif (!first_recvd_props)\n\t\t\t\tprops_reduce(recvprops, origrecvd);\n\t\t\tif (zfs_check_clearable(tofs, origrecvd, &errlist) != 0)\n\t\t\t\t(void) nvlist_merge(*errors, errlist, 0);\n\t\t\tnvlist_free(errlist);\n\n\t\t\tif (clear_received_props(tofs, origrecvd,\n\t\t\t    first_recvd_props ? NULL : recvprops) != 0)\n\t\t\t\t*errflags |= ZPROP_ERR_NOCLEAR;\n\t\t} else {\n\t\t\t*errflags |= ZPROP_ERR_NOCLEAR;\n\t\t}\n\t}\n\n\t \n\tif (localprops != NULL && !drc.drc_newfs && !first_recvd_props) {\n\t\tobjset_t *os;\n\t\tif (dmu_objset_hold(tofs, FTAG, &os) == 0) {\n\t\t\tif (dsl_prop_get_all(os, &origprops) != 0) {\n\t\t\t\t*errflags |= ZPROP_ERR_NOCLEAR;\n\t\t\t}\n\t\t\tdmu_objset_rele(os, FTAG);\n\t\t} else {\n\t\t\t*errflags |= ZPROP_ERR_NOCLEAR;\n\t\t}\n\t}\n\n\tif (recvprops != NULL) {\n\t\tprops_error = dsl_prop_set_hasrecvd(tofs);\n\n\t\tif (props_error == 0) {\n\t\t\trecv_delayprops = extract_delay_props(recvprops);\n\t\t\t(void) zfs_set_prop_nvlist(tofs, ZPROP_SRC_RECEIVED,\n\t\t\t    recvprops, *errors);\n\t\t}\n\t}\n\n\tif (localprops != NULL) {\n\t\tnvlist_t *oprops = fnvlist_alloc();\n\t\tnvlist_t *xprops = fnvlist_alloc();\n\t\tnvpair_t *nvp = NULL;\n\n\t\twhile ((nvp = nvlist_next_nvpair(localprops, nvp)) != NULL) {\n\t\t\tif (nvpair_type(nvp) == DATA_TYPE_BOOLEAN) {\n\t\t\t\t \n\t\t\t\tconst char *name = nvpair_name(nvp);\n\t\t\t\tzfs_prop_t prop = zfs_name_to_prop(name);\n\t\t\t\tif (prop != ZPROP_USERPROP) {\n\t\t\t\t\tif (!zfs_prop_inheritable(prop))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (!zfs_prop_user(name))\n\t\t\t\t\tcontinue;\n\t\t\t\tfnvlist_add_boolean(xprops, name);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfnvlist_add_nvpair(oprops, nvp);\n\t\t\t}\n\t\t}\n\n\t\tlocal_delayprops = extract_delay_props(oprops);\n\t\t(void) zfs_set_prop_nvlist(tofs, ZPROP_SRC_LOCAL,\n\t\t    oprops, *errors);\n\t\tinherited_delayprops = extract_delay_props(xprops);\n\t\t(void) zfs_set_prop_nvlist(tofs, ZPROP_SRC_INHERITED,\n\t\t    xprops, *errors);\n\n\t\tnvlist_free(oprops);\n\t\tnvlist_free(xprops);\n\t}\n\n\terror = dmu_recv_stream(&drc, &off);\n\n\tif (error == 0) {\n\t\tzfsvfs_t *zfsvfs = NULL;\n\t\tzvol_state_handle_t *zv = NULL;\n\n\t\tif (getzfsvfs(tofs, &zfsvfs) == 0) {\n\t\t\t \n\t\t\tdsl_dataset_t *ds;\n\t\t\tint end_err;\n\t\t\tboolean_t stream_is_redacted = DMU_GET_FEATUREFLAGS(\n\t\t\t    begin_record->drr_u.drr_begin.\n\t\t\t    drr_versioninfo) & DMU_BACKUP_FEATURE_REDACTED;\n\n\t\t\tds = dmu_objset_ds(zfsvfs->z_os);\n\t\t\terror = zfs_suspend_fs(zfsvfs);\n\t\t\t \n\t\t\tend_err = dmu_recv_end(&drc, zfsvfs);\n\t\t\t \n\t\t\tif (error == 0 && !drc.drc_newfs &&\n\t\t\t    stream_is_redacted && !tofs_was_redacted) {\n\t\t\t\terror = zfs_end_fs(zfsvfs, ds);\n\t\t\t} else if (error == 0) {\n\t\t\t\terror = zfs_resume_fs(zfsvfs, ds);\n\t\t\t}\n\t\t\terror = error ? error : end_err;\n\t\t\tzfs_vfs_rele(zfsvfs);\n\t\t} else if ((zv = zvol_suspend(tofs)) != NULL) {\n\t\t\terror = dmu_recv_end(&drc, zvol_tag(zv));\n\t\t\tzvol_resume(zv);\n\t\t} else {\n\t\t\terror = dmu_recv_end(&drc, NULL);\n\t\t}\n\n\t\t \n\t\tif (recv_delayprops != NULL && error == 0) {\n\t\t\t(void) zfs_set_prop_nvlist(tofs, ZPROP_SRC_RECEIVED,\n\t\t\t    recv_delayprops, *errors);\n\t\t}\n\t\tif (local_delayprops != NULL && error == 0) {\n\t\t\t(void) zfs_set_prop_nvlist(tofs, ZPROP_SRC_LOCAL,\n\t\t\t    local_delayprops, *errors);\n\t\t}\n\t\tif (inherited_delayprops != NULL && error == 0) {\n\t\t\t(void) zfs_set_prop_nvlist(tofs, ZPROP_SRC_INHERITED,\n\t\t\t    inherited_delayprops, *errors);\n\t\t}\n\t}\n\n\t \n\tif (recv_delayprops != NULL) {\n\t\tASSERT(nvlist_merge(recvprops, recv_delayprops, 0) == 0);\n\t\tnvlist_free(recv_delayprops);\n\t}\n\tif (local_delayprops != NULL) {\n\t\tASSERT(nvlist_merge(localprops, local_delayprops, 0) == 0);\n\t\tnvlist_free(local_delayprops);\n\t}\n\tif (inherited_delayprops != NULL) {\n\t\tASSERT(nvlist_merge(localprops, inherited_delayprops, 0) == 0);\n\t\tnvlist_free(inherited_delayprops);\n\t}\n\t*read_bytes = off - noff;\n\n#ifdef\tZFS_DEBUG\n\tif (zfs_ioc_recv_inject_err) {\n\t\tzfs_ioc_recv_inject_err = B_FALSE;\n\t\terror = 1;\n\t}\n#endif\n\n\t \n\tif (error != 0 && recvprops != NULL && !drc.drc_newfs) {\n\t\tif (clear_received_props(tofs, recvprops, NULL) != 0) {\n\t\t\t \n\t\t\t*errflags |= ZPROP_ERR_NORESTORE;\n\t\t} else if (first_recvd_props) {\n\t\t\tdsl_prop_unset_hasrecvd(tofs);\n\t\t}\n\n\t\tif (origrecvd == NULL && !drc.drc_newfs) {\n\t\t\t \n\t\t\t*errflags |= ZPROP_ERR_NORESTORE;\n\t\t}\n\n\t\t \n\t\tif (origrecvd != NULL &&\n\t\t    zfs_set_prop_nvlist(tofs, (first_recvd_props ?\n\t\t    ZPROP_SRC_LOCAL : ZPROP_SRC_RECEIVED),\n\t\t    origrecvd, NULL) != 0) {\n\t\t\t \n\t\t\t*errflags |= ZPROP_ERR_NORESTORE;\n\t\t}\n\t}\n\tif (error != 0 && localprops != NULL && !drc.drc_newfs &&\n\t    !first_recvd_props) {\n\t\tnvlist_t *setprops;\n\t\tnvlist_t *inheritprops;\n\t\tnvpair_t *nvp;\n\n\t\tif (origprops == NULL) {\n\t\t\t \n\t\t\t*errflags |= ZPROP_ERR_NORESTORE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tsetprops = fnvlist_alloc();\n\t\tinheritprops = fnvlist_alloc();\n\t\tnvp = NULL;\n\t\twhile ((nvp = nvlist_next_nvpair(localprops, nvp)) != NULL) {\n\t\t\tconst char *name = nvpair_name(nvp);\n\t\t\tconst char *source;\n\t\t\tnvlist_t *attrs;\n\n\t\t\tif (!nvlist_exists(origprops, name)) {\n\t\t\t\t \n\t\t\t\tfnvlist_add_boolean(inheritprops, name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattrs = fnvlist_lookup_nvlist(origprops, name);\n\t\t\tsource = fnvlist_lookup_string(attrs, ZPROP_SOURCE);\n\n\t\t\t \n\t\t\tif (strcmp(source, ZPROP_SOURCE_VAL_RECVD) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(source, tofs) == 0) {\n\t\t\t\t \n\t\t\t\tfnvlist_add_nvlist(setprops, name, attrs);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfnvlist_add_boolean(inheritprops, name);\n\t\t\t}\n\t\t}\n\n\t\tif (zfs_set_prop_nvlist(tofs, ZPROP_SRC_LOCAL, setprops,\n\t\t    NULL) != 0)\n\t\t\t*errflags |= ZPROP_ERR_NORESTORE;\n\t\tif (zfs_set_prop_nvlist(tofs, ZPROP_SRC_INHERITED, inheritprops,\n\t\t    NULL) != 0)\n\t\t\t*errflags |= ZPROP_ERR_NORESTORE;\n\n\t\tnvlist_free(setprops);\n\t\tnvlist_free(inheritprops);\n\t}\nout:\n\tzfs_file_put(input_fp);\n\tnvlist_free(origrecvd);\n\tnvlist_free(origprops);\n\n\tif (error == 0)\n\t\terror = props_error;\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_recv(zfs_cmd_t *zc)\n{\n\tdmu_replay_record_t begin_record;\n\tnvlist_t *errors = NULL;\n\tnvlist_t *recvdprops = NULL;\n\tnvlist_t *localprops = NULL;\n\tconst char *origin = NULL;\n\tchar *tosnap;\n\tchar tofs[ZFS_MAX_DATASET_NAME_LEN];\n\tint error = 0;\n\n\tif (dataset_namecheck(zc->zc_value, NULL, NULL) != 0 ||\n\t    strchr(zc->zc_value, '@') == NULL ||\n\t    strchr(zc->zc_value, '%'))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t(void) strlcpy(tofs, zc->zc_value, sizeof (tofs));\n\ttosnap = strchr(tofs, '@');\n\t*tosnap++ = '\\0';\n\n\tif (zc->zc_nvlist_src != 0 &&\n\t    (error = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t    zc->zc_iflags, &recvdprops)) != 0)\n\t\treturn (error);\n\n\tif (zc->zc_nvlist_conf != 0 &&\n\t    (error = get_nvlist(zc->zc_nvlist_conf, zc->zc_nvlist_conf_size,\n\t    zc->zc_iflags, &localprops)) != 0)\n\t\treturn (error);\n\n\tif (zc->zc_string[0])\n\t\torigin = zc->zc_string;\n\n\tbegin_record.drr_type = DRR_BEGIN;\n\tbegin_record.drr_payloadlen = 0;\n\tbegin_record.drr_u.drr_begin = zc->zc_begin_record;\n\n\terror = zfs_ioc_recv_impl(tofs, tosnap, origin, recvdprops, localprops,\n\t    NULL, zc->zc_guid, B_FALSE, B_FALSE, zc->zc_cookie, &begin_record,\n\t    &zc->zc_cookie, &zc->zc_obj, &errors);\n\tnvlist_free(recvdprops);\n\tnvlist_free(localprops);\n\n\t \n\tif (zc->zc_nvlist_dst_size != 0 && errors != NULL &&\n\t    (nvlist_smush(errors, zc->zc_nvlist_dst_size) != 0 ||\n\t    put_nvlist(zc, errors) != 0)) {\n\t\t \n\t\terror = SET_ERROR(EINVAL);\n\t}\n\n\tnvlist_free(errors);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_recv_new[] = {\n\t{\"snapname\",\t\tDATA_TYPE_STRING,\t0},\n\t{\"props\",\t\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n\t{\"localprops\",\t\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n\t{\"origin\",\t\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n\t{\"begin_record\",\tDATA_TYPE_BYTE_ARRAY,\t0},\n\t{\"input_fd\",\t\tDATA_TYPE_INT32,\t0},\n\t{\"force\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"heal\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"resumable\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"cleanup_fd\",\t\tDATA_TYPE_INT32,\tZK_OPTIONAL},\n\t{\"action_handle\",\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n\t{\"hidden_args\",\t\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_recv_new(const char *fsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tdmu_replay_record_t *begin_record;\n\tuint_t begin_record_size;\n\tnvlist_t *errors = NULL;\n\tnvlist_t *recvprops = NULL;\n\tnvlist_t *localprops = NULL;\n\tnvlist_t *hidden_args = NULL;\n\tconst char *snapname;\n\tconst char *origin = NULL;\n\tchar *tosnap;\n\tchar tofs[ZFS_MAX_DATASET_NAME_LEN];\n\tboolean_t force;\n\tboolean_t heal;\n\tboolean_t resumable;\n\tuint64_t read_bytes = 0;\n\tuint64_t errflags = 0;\n\tint input_fd = -1;\n\tint error;\n\n\tsnapname = fnvlist_lookup_string(innvl, \"snapname\");\n\n\tif (dataset_namecheck(snapname, NULL, NULL) != 0 ||\n\t    strchr(snapname, '@') == NULL ||\n\t    strchr(snapname, '%'))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t(void) strlcpy(tofs, snapname, sizeof (tofs));\n\ttosnap = strchr(tofs, '@');\n\t*tosnap++ = '\\0';\n\n\terror = nvlist_lookup_string(innvl, \"origin\", &origin);\n\tif (error && error != ENOENT)\n\t\treturn (error);\n\n\terror = nvlist_lookup_byte_array(innvl, \"begin_record\",\n\t    (uchar_t **)&begin_record, &begin_record_size);\n\tif (error != 0 || begin_record_size != sizeof (*begin_record))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tinput_fd = fnvlist_lookup_int32(innvl, \"input_fd\");\n\n\tforce = nvlist_exists(innvl, \"force\");\n\theal = nvlist_exists(innvl, \"heal\");\n\tresumable = nvlist_exists(innvl, \"resumable\");\n\n\t \n\terror = nvlist_lookup_nvlist(innvl, \"props\", &recvprops);\n\tif (error && error != ENOENT)\n\t\treturn (error);\n\n\terror = nvlist_lookup_nvlist(innvl, \"localprops\", &localprops);\n\tif (error && error != ENOENT)\n\t\treturn (error);\n\n\terror = nvlist_lookup_nvlist(innvl, ZPOOL_HIDDEN_ARGS, &hidden_args);\n\tif (error && error != ENOENT)\n\t\treturn (error);\n\n\terror = zfs_ioc_recv_impl(tofs, tosnap, origin, recvprops, localprops,\n\t    hidden_args, force, heal, resumable, input_fd, begin_record,\n\t    &read_bytes, &errflags, &errors);\n\n\tfnvlist_add_uint64(outnvl, \"read_bytes\", read_bytes);\n\tfnvlist_add_uint64(outnvl, \"error_flags\", errflags);\n\tfnvlist_add_nvlist(outnvl, \"errors\", errors);\n\n\tnvlist_free(errors);\n\tnvlist_free(recvprops);\n\tnvlist_free(localprops);\n\n\treturn (error);\n}\n\ntypedef struct dump_bytes_io {\n\tzfs_file_t\t*dbi_fp;\n\tcaddr_t\t\tdbi_buf;\n\tint\t\tdbi_len;\n\tint\t\tdbi_err;\n} dump_bytes_io_t;\n\nstatic void\ndump_bytes_cb(void *arg)\n{\n\tdump_bytes_io_t *dbi = (dump_bytes_io_t *)arg;\n\tzfs_file_t *fp;\n\tcaddr_t buf;\n\n\tfp = dbi->dbi_fp;\n\tbuf = dbi->dbi_buf;\n\n\tdbi->dbi_err = zfs_file_write(fp, buf, dbi->dbi_len, NULL);\n}\n\nstatic int\ndump_bytes(objset_t *os, void *buf, int len, void *arg)\n{\n\tdump_bytes_io_t dbi;\n\n\tdbi.dbi_fp = arg;\n\tdbi.dbi_buf = buf;\n\tdbi.dbi_len = len;\n\n#if defined(HAVE_LARGE_STACKS)\n\tdump_bytes_cb(&dbi);\n#else\n\t \n\tspa_taskq_dispatch_sync(dmu_objset_spa(os), ZIO_TYPE_FREE,\n\t    ZIO_TASKQ_ISSUE, dump_bytes_cb, &dbi, TQ_SLEEP);\n#endif  \n\n\treturn (dbi.dbi_err);\n}\n\n \nstatic int\nzfs_ioc_send(zfs_cmd_t *zc)\n{\n\tint error;\n\toffset_t off;\n\tboolean_t estimate = (zc->zc_guid != 0);\n\tboolean_t embedok = (zc->zc_flags & 0x1);\n\tboolean_t large_block_ok = (zc->zc_flags & 0x2);\n\tboolean_t compressok = (zc->zc_flags & 0x4);\n\tboolean_t rawok = (zc->zc_flags & 0x8);\n\tboolean_t savedok = (zc->zc_flags & 0x10);\n\n\tif (zc->zc_obj != 0) {\n\t\tdsl_pool_t *dp;\n\t\tdsl_dataset_t *tosnap;\n\n\t\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\terror = dsl_dataset_hold_obj(dp, zc->zc_sendobj, FTAG, &tosnap);\n\t\tif (error != 0) {\n\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\tif (dsl_dir_is_clone(tosnap->ds_dir))\n\t\t\tzc->zc_fromobj =\n\t\t\t    dsl_dir_phys(tosnap->ds_dir)->dd_origin_obj;\n\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t}\n\n\tif (estimate) {\n\t\tdsl_pool_t *dp;\n\t\tdsl_dataset_t *tosnap;\n\t\tdsl_dataset_t *fromsnap = NULL;\n\n\t\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\terror = dsl_dataset_hold_obj(dp, zc->zc_sendobj,\n\t\t    FTAG, &tosnap);\n\t\tif (error != 0) {\n\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\tif (zc->zc_fromobj != 0) {\n\t\t\terror = dsl_dataset_hold_obj(dp, zc->zc_fromobj,\n\t\t\t    FTAG, &fromsnap);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\terror = dmu_send_estimate_fast(tosnap, fromsnap, NULL,\n\t\t    compressok || rawok, savedok, &zc->zc_objset_type);\n\n\t\tif (fromsnap != NULL)\n\t\t\tdsl_dataset_rele(fromsnap, FTAG);\n\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t} else {\n\t\tzfs_file_t *fp;\n\t\tdmu_send_outparams_t out = {0};\n\n\t\tif ((fp = zfs_file_get(zc->zc_cookie)) == NULL)\n\t\t\treturn (SET_ERROR(EBADF));\n\n\t\toff = zfs_file_off(fp);\n\t\tout.dso_outfunc = dump_bytes;\n\t\tout.dso_arg = fp;\n\t\tout.dso_dryrun = B_FALSE;\n\t\terror = dmu_send_obj(zc->zc_name, zc->zc_sendobj,\n\t\t    zc->zc_fromobj, embedok, large_block_ok, compressok,\n\t\t    rawok, savedok, zc->zc_cookie, &off, &out);\n\n\t\tzfs_file_put(fp);\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_send_progress(zfs_cmd_t *zc)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tdmu_sendstatus_t *dsp = NULL;\n\tint error;\n\n\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, zc->zc_name, FTAG, &ds);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tmutex_enter(&ds->ds_sendstream_lock);\n\n\t \n\n\tfor (dsp = list_head(&ds->ds_sendstreams); dsp != NULL;\n\t    dsp = list_next(&ds->ds_sendstreams, dsp)) {\n\t\tif (dsp->dss_outfd == zc->zc_cookie &&\n\t\t    zfs_proc_is_caller(dsp->dss_proc))\n\t\t\tbreak;\n\t}\n\n\tif (dsp != NULL) {\n\t\tzc->zc_cookie = atomic_cas_64((volatile uint64_t *)dsp->dss_off,\n\t\t    0, 0);\n\t\t \n\t\tzc->zc_objset_type = atomic_cas_64(&dsp->dss_blocks, 0, 0);\n\t} else {\n\t\terror = SET_ERROR(ENOENT);\n\t}\n\n\tmutex_exit(&ds->ds_sendstream_lock);\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_inject_fault(zfs_cmd_t *zc)\n{\n\tint id, error;\n\n\terror = zio_inject_fault(zc->zc_name, (int)zc->zc_guid, &id,\n\t    &zc->zc_inject_record);\n\n\tif (error == 0)\n\t\tzc->zc_guid = (uint64_t)id;\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_clear_fault(zfs_cmd_t *zc)\n{\n\treturn (zio_clear_fault((int)zc->zc_guid));\n}\n\nstatic int\nzfs_ioc_inject_list_next(zfs_cmd_t *zc)\n{\n\tint id = (int)zc->zc_guid;\n\tint error;\n\n\terror = zio_inject_list_next(&id, zc->zc_name, sizeof (zc->zc_name),\n\t    &zc->zc_inject_record);\n\n\tzc->zc_guid = id;\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_error_log(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tint error;\n\n\tif ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = spa_get_errlog(spa, (void *)(uintptr_t)zc->zc_nvlist_dst,\n\t    &zc->zc_nvlist_dst_size);\n\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_clear(zfs_cmd_t *zc)\n{\n\tspa_t *spa;\n\tvdev_t *vd;\n\tint error;\n\n\t \n\tmutex_enter(&spa_namespace_lock);\n\tspa = spa_lookup(zc->zc_name);\n\tif (spa == NULL) {\n\t\tmutex_exit(&spa_namespace_lock);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\tif (spa_get_log_state(spa) == SPA_LOG_MISSING) {\n\t\t \n\t\tspa_set_log_state(spa, SPA_LOG_CLEAR);\n\t}\n\tspa->spa_last_open_failed = 0;\n\tmutex_exit(&spa_namespace_lock);\n\n\tif (zc->zc_cookie & ZPOOL_NO_REWIND) {\n\t\terror = spa_open(zc->zc_name, &spa, FTAG);\n\t} else {\n\t\tnvlist_t *policy;\n\t\tnvlist_t *config = NULL;\n\n\t\tif (zc->zc_nvlist_src == 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif ((error = get_nvlist(zc->zc_nvlist_src,\n\t\t    zc->zc_nvlist_src_size, zc->zc_iflags, &policy)) == 0) {\n\t\t\terror = spa_open_rewind(zc->zc_name, &spa, FTAG,\n\t\t\t    policy, &config);\n\t\t\tif (config != NULL) {\n\t\t\t\tint err;\n\n\t\t\t\tif ((err = put_nvlist(zc, config)) != 0)\n\t\t\t\t\terror = err;\n\t\t\t\tnvlist_free(config);\n\t\t\t}\n\t\t\tnvlist_free(policy);\n\t\t}\n\t}\n\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tif (spa_multihost(spa) && spa_suspended(spa))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\n\tif (zc->zc_guid == 0) {\n\t\tvd = NULL;\n\t} else {\n\t\tvd = spa_lookup_by_guid(spa, zc->zc_guid, B_TRUE);\n\t\tif (vd == NULL) {\n\t\t\terror = SET_ERROR(ENODEV);\n\t\t\t(void) spa_vdev_state_exit(spa, NULL, error);\n\t\t\tspa_close(spa, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tvdev_clear(spa, vd);\n\n\t(void) spa_vdev_state_exit(spa, spa_suspended(spa) ?\n\t    NULL : spa->spa_root_vdev, 0);\n\n\t \n\tif (zio_resume(spa) != 0)\n\t\terror = SET_ERROR(EIO);\n\n\tspa_close(spa, FTAG);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_reopen[] = {\n\t{\"scrub_restart\",\tDATA_TYPE_BOOLEAN_VALUE,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_pool_reopen(const char *pool, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) outnvl;\n\tspa_t *spa;\n\tint error;\n\tboolean_t rc, scrub_restart = B_TRUE;\n\n\tif (innvl) {\n\t\terror = nvlist_lookup_boolean_value(innvl,\n\t\t    \"scrub_restart\", &rc);\n\t\tif (error == 0)\n\t\t\tscrub_restart = rc;\n\t}\n\n\terror = spa_open(pool, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\n\t \n\n\tspa->spa_scrub_reopen = (!scrub_restart &&\n\t    dsl_scan_scrubbing(spa->spa_dsl_pool));\n\tvdev_reopen(spa->spa_root_vdev);\n\tspa->spa_scrub_reopen = B_FALSE;\n\n\t(void) spa_vdev_state_exit(spa, NULL, 0);\n\tspa_close(spa, FTAG);\n\treturn (0);\n}\n\n \nstatic int\nzfs_ioc_promote(zfs_cmd_t *zc)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds, *ods;\n\tchar origin[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *cp;\n\tint error;\n\n\tzc->zc_name[sizeof (zc->zc_name) - 1] = '\\0';\n\tif (dataset_namecheck(zc->zc_name, NULL, NULL) != 0 ||\n\t    strchr(zc->zc_name, '%'))\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, zc->zc_name, FTAG, &ds);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (!dsl_dir_is_clone(ds->ds_dir)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\terror = dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(ds->ds_dir)->dd_origin_obj, FTAG, &ods);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\tdsl_dataset_name(ods, origin);\n\tdsl_dataset_rele(ods, FTAG);\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\n\t \n\tcp = strchr(origin, '@');\n\tif (cp)\n\t\t*cp = '\\0';\n\t(void) dmu_objset_find(origin,\n\t    zfs_unmount_snap_cb, NULL, DS_FIND_SNAPSHOTS);\n\treturn (dsl_dataset_promote(zc->zc_name, zc->zc_string));\n}\n\n \nstatic int\nzfs_ioc_userspace_one(zfs_cmd_t *zc)\n{\n\tzfsvfs_t *zfsvfs;\n\tint error;\n\n\tif (zc->zc_objset_type >= ZFS_NUM_USERQUOTA_PROPS)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = zfsvfs_hold(zc->zc_name, FTAG, &zfsvfs, B_FALSE);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_userspace_one(zfsvfs,\n\t    zc->zc_objset_type, zc->zc_value, zc->zc_guid, &zc->zc_cookie);\n\tzfsvfs_rele(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_userspace_many(zfs_cmd_t *zc)\n{\n\tzfsvfs_t *zfsvfs;\n\tint bufsize = zc->zc_nvlist_dst_size;\n\n\tif (bufsize <= 0)\n\t\treturn (SET_ERROR(ENOMEM));\n\n\tint error = zfsvfs_hold(zc->zc_name, FTAG, &zfsvfs, B_FALSE);\n\tif (error != 0)\n\t\treturn (error);\n\n\tvoid *buf = vmem_alloc(bufsize, KM_SLEEP);\n\n\terror = zfs_userspace_many(zfsvfs, zc->zc_objset_type, &zc->zc_cookie,\n\t    buf, &zc->zc_nvlist_dst_size);\n\n\tif (error == 0) {\n\t\terror = xcopyout(buf,\n\t\t    (void *)(uintptr_t)zc->zc_nvlist_dst,\n\t\t    zc->zc_nvlist_dst_size);\n\t}\n\tvmem_free(buf, bufsize);\n\tzfsvfs_rele(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_userspace_upgrade(zfs_cmd_t *zc)\n{\n\tint error = 0;\n\tzfsvfs_t *zfsvfs;\n\n\tif (getzfsvfs(zc->zc_name, &zfsvfs) == 0) {\n\t\tif (!dmu_objset_userused_enabled(zfsvfs->z_os)) {\n\t\t\t \n\t\t\tdsl_dataset_t *ds, *newds;\n\n\t\t\tds = dmu_objset_ds(zfsvfs->z_os);\n\t\t\terror = zfs_suspend_fs(zfsvfs);\n\t\t\tif (error == 0) {\n\t\t\t\tdmu_objset_refresh_ownership(ds, &newds,\n\t\t\t\t    B_TRUE, zfsvfs);\n\t\t\t\terror = zfs_resume_fs(zfsvfs, newds);\n\t\t\t}\n\t\t}\n\t\tif (error == 0) {\n\t\t\tmutex_enter(&zfsvfs->z_os->os_upgrade_lock);\n\t\t\tif (zfsvfs->z_os->os_upgrade_id == 0) {\n\t\t\t\t \n\t\t\t\tzfsvfs->z_os->os_upgrade_status = 0;\n\t\t\t\tmutex_exit(&zfsvfs->z_os->os_upgrade_lock);\n\n\t\t\t\tdsl_pool_config_enter(\n\t\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\t\tdmu_objset_userspace_upgrade(zfsvfs->z_os);\n\t\t\t\tdsl_pool_config_exit(\n\t\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\t} else {\n\t\t\t\tmutex_exit(&zfsvfs->z_os->os_upgrade_lock);\n\t\t\t}\n\n\t\t\ttaskq_wait_id(zfsvfs->z_os->os_spa->spa_upgrade_taskq,\n\t\t\t    zfsvfs->z_os->os_upgrade_id);\n\t\t\terror = zfsvfs->z_os->os_upgrade_status;\n\t\t}\n\t\tzfs_vfs_rele(zfsvfs);\n\t} else {\n\t\tobjset_t *os;\n\n\t\t \n\t\terror = dmu_objset_hold_flags(zc->zc_name, B_TRUE, FTAG, &os);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\tmutex_enter(&os->os_upgrade_lock);\n\t\tif (os->os_upgrade_id == 0) {\n\t\t\t \n\t\t\tos->os_upgrade_status = 0;\n\t\t\tmutex_exit(&os->os_upgrade_lock);\n\n\t\t\tdmu_objset_userspace_upgrade(os);\n\t\t} else {\n\t\t\tmutex_exit(&os->os_upgrade_lock);\n\t\t}\n\n\t\tdsl_pool_rele(dmu_objset_pool(os), FTAG);\n\n\t\ttaskq_wait_id(os->os_spa->spa_upgrade_taskq, os->os_upgrade_id);\n\t\terror = os->os_upgrade_status;\n\n\t\tdsl_dataset_rele_flags(dmu_objset_ds(os), DS_HOLD_FLAG_DECRYPT,\n\t\t    FTAG);\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_id_quota_upgrade(zfs_cmd_t *zc)\n{\n\tobjset_t *os;\n\tint error;\n\n\terror = dmu_objset_hold_flags(zc->zc_name, B_TRUE, FTAG, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (dmu_objset_userobjspace_upgradable(os) ||\n\t    dmu_objset_projectquota_upgradable(os)) {\n\t\tmutex_enter(&os->os_upgrade_lock);\n\t\tif (os->os_upgrade_id == 0) {\n\t\t\t \n\t\t\tos->os_upgrade_status = 0;\n\t\t\tmutex_exit(&os->os_upgrade_lock);\n\n\t\t\tdmu_objset_id_quota_upgrade(os);\n\t\t} else {\n\t\t\tmutex_exit(&os->os_upgrade_lock);\n\t\t}\n\n\t\tdsl_pool_rele(dmu_objset_pool(os), FTAG);\n\n\t\ttaskq_wait_id(os->os_spa->spa_upgrade_taskq, os->os_upgrade_id);\n\t\terror = os->os_upgrade_status;\n\t} else {\n\t\tdsl_pool_rele(dmu_objset_pool(os), FTAG);\n\t}\n\n\tdsl_dataset_rele_flags(dmu_objset_ds(os), DS_HOLD_FLAG_DECRYPT, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_share(zfs_cmd_t *zc)\n{\n\treturn (SET_ERROR(ENOSYS));\n}\n\n \nstatic int\nzfs_ioc_next_obj(zfs_cmd_t *zc)\n{\n\tobjset_t *os = NULL;\n\tint error;\n\n\terror = dmu_objset_hold(zc->zc_name, FTAG, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dmu_object_next(os, &zc->zc_obj, B_FALSE, 0);\n\n\tdmu_objset_rele(os, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_tmp_snapshot(zfs_cmd_t *zc)\n{\n\tchar *snap_name;\n\tchar *hold_name;\n\tminor_t minor;\n\n\tzfs_file_t *fp = zfs_onexit_fd_hold(zc->zc_cleanup_fd, &minor);\n\tif (fp == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\tsnap_name = kmem_asprintf(\"%s-%016llx\", zc->zc_value,\n\t    (u_longlong_t)ddi_get_lbolt64());\n\thold_name = kmem_asprintf(\"%%%s\", zc->zc_value);\n\n\tint error = dsl_dataset_snapshot_tmp(zc->zc_name, snap_name, minor,\n\t    hold_name);\n\tif (error == 0)\n\t\t(void) strlcpy(zc->zc_value, snap_name,\n\t\t    sizeof (zc->zc_value));\n\tkmem_strfree(snap_name);\n\tkmem_strfree(hold_name);\n\tzfs_onexit_fd_rele(fp);\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_diff(zfs_cmd_t *zc)\n{\n\tzfs_file_t *fp;\n\toffset_t off;\n\tint error;\n\n\tif ((fp = zfs_file_get(zc->zc_cookie)) == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\toff = zfs_file_off(fp);\n\terror = dmu_diff(zc->zc_name, zc->zc_value, fp, &off);\n\n\tzfs_file_put(fp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_smb_acl(zfs_cmd_t *zc)\n{\n\treturn (SET_ERROR(ENOTSUP));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_hold[] = {\n\t{\"holds\",\t\tDATA_TYPE_NVLIST,\t0},\n\t{\"cleanup_fd\",\t\tDATA_TYPE_INT32,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_hold(const char *pool, nvlist_t *args, nvlist_t *errlist)\n{\n\t(void) pool;\n\tnvpair_t *pair;\n\tnvlist_t *holds;\n\tint cleanup_fd = -1;\n\tint error;\n\tminor_t minor = 0;\n\tzfs_file_t *fp = NULL;\n\n\tholds = fnvlist_lookup_nvlist(args, \"holds\");\n\n\t \n\tfor (pair = nvlist_next_nvpair(holds, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(holds, pair)) {\n\t\tconst char *htag;\n\n\t\terror = nvpair_value_string(pair, &htag);\n\t\tif (error != 0)\n\t\t\treturn (SET_ERROR(error));\n\n\t\tif (strlen(htag) == 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (nvlist_lookup_int32(args, \"cleanup_fd\", &cleanup_fd) == 0) {\n\t\tfp = zfs_onexit_fd_hold(cleanup_fd, &minor);\n\t\tif (fp == NULL)\n\t\t\treturn (SET_ERROR(EBADF));\n\t}\n\n\terror = dsl_dataset_user_hold(holds, minor, errlist);\n\tif (fp != NULL) {\n\t\tASSERT3U(minor, !=, 0);\n\t\tzfs_onexit_fd_rele(fp);\n\t}\n\treturn (SET_ERROR(error));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_get_holds[] = {\n\t \n};\n\nstatic int\nzfs_ioc_get_holds(const char *snapname, nvlist_t *args, nvlist_t *outnvl)\n{\n\t(void) args;\n\treturn (dsl_dataset_get_holds(snapname, outnvl));\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_release[] = {\n\t{\"<snapname>...\",\tDATA_TYPE_NVLIST,\tZK_WILDCARDLIST},\n};\n\nstatic int\nzfs_ioc_release(const char *pool, nvlist_t *holds, nvlist_t *errlist)\n{\n\t(void) pool;\n\treturn (dsl_dataset_user_release(holds, errlist));\n}\n\n \nstatic int\nzfs_ioc_events_next(zfs_cmd_t *zc)\n{\n\tzfs_zevent_t *ze;\n\tnvlist_t *event = NULL;\n\tminor_t minor;\n\tuint64_t dropped = 0;\n\tint error;\n\n\tzfs_file_t *fp = zfs_zevent_fd_hold(zc->zc_cleanup_fd, &minor, &ze);\n\tif (fp == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\tdo {\n\t\terror = zfs_zevent_next(ze, &event,\n\t\t    &zc->zc_nvlist_dst_size, &dropped);\n\t\tif (event != NULL) {\n\t\t\tzc->zc_cookie = dropped;\n\t\t\terror = put_nvlist(zc, event);\n\t\t\tnvlist_free(event);\n\t\t}\n\n\t\tif (zc->zc_guid & ZEVENT_NONBLOCK)\n\t\t\tbreak;\n\n\t\tif ((error == 0) || (error != ENOENT))\n\t\t\tbreak;\n\n\t\terror = zfs_zevent_wait(ze);\n\t\tif (error != 0)\n\t\t\tbreak;\n\t} while (1);\n\n\tzfs_zevent_fd_rele(fp);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_events_clear(zfs_cmd_t *zc)\n{\n\tuint_t count;\n\n\tzfs_zevent_drain_all(&count);\n\tzc->zc_cookie = count;\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_ioc_events_seek(zfs_cmd_t *zc)\n{\n\tzfs_zevent_t *ze;\n\tminor_t minor;\n\tint error;\n\n\tzfs_file_t *fp = zfs_zevent_fd_hold(zc->zc_cleanup_fd, &minor, &ze);\n\tif (fp == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\terror = zfs_zevent_seek(ze, zc->zc_guid);\n\tzfs_zevent_fd_rele(fp);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ioc_space_written(zfs_cmd_t *zc)\n{\n\tint error;\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *new;\n\n\terror = dsl_pool_hold(zc->zc_name, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\terror = dsl_dataset_hold(dp, zc->zc_name, FTAG, &new);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\tif (strchr(zc->zc_value, '#') != NULL) {\n\t\tzfs_bookmark_phys_t bmp;\n\t\terror = dsl_bookmark_lookup(dp, zc->zc_value,\n\t\t    new, &bmp);\n\t\tif (error == 0) {\n\t\t\terror = dsl_dataset_space_written_bookmark(&bmp, new,\n\t\t\t    &zc->zc_cookie,\n\t\t\t    &zc->zc_objset_type, &zc->zc_perm_action);\n\t\t}\n\t} else {\n\t\tdsl_dataset_t *old;\n\t\terror = dsl_dataset_hold(dp, zc->zc_value, FTAG, &old);\n\n\t\tif (error == 0) {\n\t\t\terror = dsl_dataset_space_written(old, new,\n\t\t\t    &zc->zc_cookie,\n\t\t\t    &zc->zc_objset_type, &zc->zc_perm_action);\n\t\t\tdsl_dataset_rele(old, FTAG);\n\t\t}\n\t}\n\tdsl_dataset_rele(new, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_space_snaps[] = {\n\t{\"firstsnap\",\tDATA_TYPE_STRING,\t0},\n};\n\nstatic int\nzfs_ioc_space_snaps(const char *lastsnap, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tint error;\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *new, *old;\n\tconst char *firstsnap;\n\tuint64_t used, comp, uncomp;\n\n\tfirstsnap = fnvlist_lookup_string(innvl, \"firstsnap\");\n\n\terror = dsl_pool_hold(lastsnap, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, lastsnap, FTAG, &new);\n\tif (error == 0 && !new->ds_is_snapshot) {\n\t\tdsl_dataset_rele(new, FTAG);\n\t\terror = SET_ERROR(EINVAL);\n\t}\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\terror = dsl_dataset_hold(dp, firstsnap, FTAG, &old);\n\tif (error == 0 && !old->ds_is_snapshot) {\n\t\tdsl_dataset_rele(old, FTAG);\n\t\terror = SET_ERROR(EINVAL);\n\t}\n\tif (error != 0) {\n\t\tdsl_dataset_rele(new, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = dsl_dataset_space_wouldfree(old, new, &used, &comp, &uncomp);\n\tdsl_dataset_rele(old, FTAG);\n\tdsl_dataset_rele(new, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\tfnvlist_add_uint64(outnvl, \"used\", used);\n\tfnvlist_add_uint64(outnvl, \"compressed\", comp);\n\tfnvlist_add_uint64(outnvl, \"uncompressed\", uncomp);\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_send_new[] = {\n\t{\"fd\",\t\t\tDATA_TYPE_INT32,\t0},\n\t{\"fromsnap\",\t\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n\t{\"largeblockok\",\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"embedok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"compressok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"rawok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"savedok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"resume_object\",\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n\t{\"resume_offset\",\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n\t{\"redactbook\",\t\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_send_new(const char *snapname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) outnvl;\n\tint error;\n\toffset_t off;\n\tconst char *fromname = NULL;\n\tint fd;\n\tzfs_file_t *fp;\n\tboolean_t largeblockok;\n\tboolean_t embedok;\n\tboolean_t compressok;\n\tboolean_t rawok;\n\tboolean_t savedok;\n\tuint64_t resumeobj = 0;\n\tuint64_t resumeoff = 0;\n\tconst char *redactbook = NULL;\n\n\tfd = fnvlist_lookup_int32(innvl, \"fd\");\n\n\t(void) nvlist_lookup_string(innvl, \"fromsnap\", &fromname);\n\n\tlargeblockok = nvlist_exists(innvl, \"largeblockok\");\n\tembedok = nvlist_exists(innvl, \"embedok\");\n\tcompressok = nvlist_exists(innvl, \"compressok\");\n\trawok = nvlist_exists(innvl, \"rawok\");\n\tsavedok = nvlist_exists(innvl, \"savedok\");\n\n\t(void) nvlist_lookup_uint64(innvl, \"resume_object\", &resumeobj);\n\t(void) nvlist_lookup_uint64(innvl, \"resume_offset\", &resumeoff);\n\n\t(void) nvlist_lookup_string(innvl, \"redactbook\", &redactbook);\n\n\tif ((fp = zfs_file_get(fd)) == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\toff = zfs_file_off(fp);\n\n\tdmu_send_outparams_t out = {0};\n\tout.dso_outfunc = dump_bytes;\n\tout.dso_arg = fp;\n\tout.dso_dryrun = B_FALSE;\n\terror = dmu_send(snapname, fromname, embedok, largeblockok,\n\t    compressok, rawok, savedok, resumeobj, resumeoff,\n\t    redactbook, fd, &off, &out);\n\n\tzfs_file_put(fp);\n\treturn (error);\n}\n\nstatic int\nsend_space_sum(objset_t *os, void *buf, int len, void *arg)\n{\n\t(void) os, (void) buf;\n\tuint64_t *size = arg;\n\n\t*size += len;\n\treturn (0);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_send_space[] = {\n\t{\"from\",\t\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n\t{\"fromsnap\",\t\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n\t{\"largeblockok\",\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"embedok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"compressok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"rawok\",\t\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n\t{\"fd\",\t\t\tDATA_TYPE_INT32,\tZK_OPTIONAL},\n\t{\"redactbook\",\t\tDATA_TYPE_STRING,\tZK_OPTIONAL},\n\t{\"resume_object\",\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n\t{\"resume_offset\",\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n\t{\"bytes\",\t\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_send_space(const char *snapname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *tosnap;\n\tdsl_dataset_t *fromsnap = NULL;\n\tint error;\n\tconst char *fromname = NULL;\n\tconst char *redactlist_book = NULL;\n\tboolean_t largeblockok;\n\tboolean_t embedok;\n\tboolean_t compressok;\n\tboolean_t rawok;\n\tboolean_t savedok;\n\tuint64_t space = 0;\n\tboolean_t full_estimate = B_FALSE;\n\tuint64_t resumeobj = 0;\n\tuint64_t resumeoff = 0;\n\tuint64_t resume_bytes = 0;\n\tint32_t fd = -1;\n\tzfs_bookmark_phys_t zbm = {0};\n\n\terror = dsl_pool_hold(snapname, FTAG, &dp);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_dataset_hold(dp, snapname, FTAG, &tosnap);\n\tif (error != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (error);\n\t}\n\t(void) nvlist_lookup_int32(innvl, \"fd\", &fd);\n\n\tlargeblockok = nvlist_exists(innvl, \"largeblockok\");\n\tembedok = nvlist_exists(innvl, \"embedok\");\n\tcompressok = nvlist_exists(innvl, \"compressok\");\n\trawok = nvlist_exists(innvl, \"rawok\");\n\tsavedok = nvlist_exists(innvl, \"savedok\");\n\tboolean_t from = (nvlist_lookup_string(innvl, \"from\", &fromname) == 0);\n\tboolean_t altbook = (nvlist_lookup_string(innvl, \"redactbook\",\n\t    &redactlist_book) == 0);\n\n\t(void) nvlist_lookup_uint64(innvl, \"resume_object\", &resumeobj);\n\t(void) nvlist_lookup_uint64(innvl, \"resume_offset\", &resumeoff);\n\t(void) nvlist_lookup_uint64(innvl, \"bytes\", &resume_bytes);\n\n\tif (altbook) {\n\t\tfull_estimate = B_TRUE;\n\t} else if (from) {\n\t\tif (strchr(fromname, '#')) {\n\t\t\terror = dsl_bookmark_lookup(dp, fromname, tosnap, &zbm);\n\n\t\t\t \n\t\t\tif (error == EXDEV && zbm.zbm_redaction_obj != 0 &&\n\t\t\t    zbm.zbm_guid ==\n\t\t\t    dsl_dataset_phys(tosnap)->ds_guid)\n\t\t\t\terror = 0;\n\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tif (zbm.zbm_redaction_obj != 0 || !(zbm.zbm_flags &\n\t\t\t    ZBM_FLAG_HAS_FBN)) {\n\t\t\t\tfull_estimate = B_TRUE;\n\t\t\t}\n\t\t} else if (strchr(fromname, '@')) {\n\t\t\terror = dsl_dataset_hold(dp, fromname, FTAG, &fromsnap);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\n\t\t\tif (!dsl_dataset_is_before(tosnap, fromsnap, 0)) {\n\t\t\t\tfull_estimate = B_TRUE;\n\t\t\t\tdsl_dataset_rele(fromsnap, FTAG);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\t\tdsl_pool_rele(dp, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t}\n\n\tif (full_estimate) {\n\t\tdmu_send_outparams_t out = {0};\n\t\toffset_t off = 0;\n\t\tout.dso_outfunc = send_space_sum;\n\t\tout.dso_arg = &space;\n\t\tout.dso_dryrun = B_TRUE;\n\t\t \n\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t\terror = dmu_send(snapname, fromname, embedok, largeblockok,\n\t\t    compressok, rawok, savedok, resumeobj, resumeoff,\n\t\t    redactlist_book, fd, &off, &out);\n\t} else {\n\t\terror = dmu_send_estimate_fast(tosnap, fromsnap,\n\t\t    (from && strchr(fromname, '#') != NULL ? &zbm : NULL),\n\t\t    compressok || rawok, savedok, &space);\n\t\tspace -= resume_bytes;\n\t\tif (fromsnap != NULL)\n\t\t\tdsl_dataset_rele(fromsnap, FTAG);\n\t\tdsl_dataset_rele(tosnap, FTAG);\n\t\tdsl_pool_rele(dp, FTAG);\n\t}\n\n\tfnvlist_add_uint64(outnvl, \"space\", space);\n\n\treturn (error);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_pool_sync[] = {\n\t{\"force\",\tDATA_TYPE_BOOLEAN_VALUE,\t0},\n};\n\nstatic int\nzfs_ioc_pool_sync(const char *pool, nvlist_t *innvl, nvlist_t *onvl)\n{\n\t(void) onvl;\n\tint err;\n\tboolean_t rc, force = B_FALSE;\n\tspa_t *spa;\n\n\tif ((err = spa_open(pool, &spa, FTAG)) != 0)\n\t\treturn (err);\n\n\tif (innvl) {\n\t\terr = nvlist_lookup_boolean_value(innvl, \"force\", &rc);\n\t\tif (err == 0)\n\t\t\tforce = rc;\n\t}\n\n\tif (force) {\n\t\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_WRITER);\n\t\tvdev_config_dirty(spa->spa_root_vdev);\n\t\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\t}\n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\tspa_close(spa, FTAG);\n\n\treturn (0);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_load_key[] = {\n\t{\"hidden_args\",\tDATA_TYPE_NVLIST,\t0},\n\t{\"noop\",\tDATA_TYPE_BOOLEAN,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_load_key(const char *dsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) outnvl;\n\tint ret;\n\tdsl_crypto_params_t *dcp = NULL;\n\tnvlist_t *hidden_args;\n\tboolean_t noop = nvlist_exists(innvl, \"noop\");\n\n\tif (strchr(dsname, '@') != NULL || strchr(dsname, '%') != NULL) {\n\t\tret = SET_ERROR(EINVAL);\n\t\tgoto error;\n\t}\n\n\thidden_args = fnvlist_lookup_nvlist(innvl, ZPOOL_HIDDEN_ARGS);\n\n\tret = dsl_crypto_params_create_nvlist(DCP_CMD_NONE, NULL,\n\t    hidden_args, &dcp);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = spa_keystore_load_wkey(dsname, dcp, noop);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tdsl_crypto_params_free(dcp, noop);\n\n\treturn (0);\n\nerror:\n\tdsl_crypto_params_free(dcp, B_TRUE);\n\treturn (ret);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_unload_key[] = {\n\t \n};\n\nstatic int\nzfs_ioc_unload_key(const char *dsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) innvl, (void) outnvl;\n\tint ret = 0;\n\n\tif (strchr(dsname, '@') != NULL || strchr(dsname, '%') != NULL) {\n\t\tret = (SET_ERROR(EINVAL));\n\t\tgoto out;\n\t}\n\n\tret = spa_keystore_unload_wkey(dsname);\n\tif (ret != 0)\n\t\tgoto out;\n\nout:\n\treturn (ret);\n}\n\n \nstatic const zfs_ioc_key_t zfs_keys_change_key[] = {\n\t{\"crypt_cmd\",\tDATA_TYPE_UINT64,\tZK_OPTIONAL},\n\t{\"hidden_args\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n\t{\"props\",\tDATA_TYPE_NVLIST,\tZK_OPTIONAL},\n};\n\nstatic int\nzfs_ioc_change_key(const char *dsname, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\t(void) outnvl;\n\tint ret;\n\tuint64_t cmd = DCP_CMD_NONE;\n\tdsl_crypto_params_t *dcp = NULL;\n\tnvlist_t *args = NULL, *hidden_args = NULL;\n\n\tif (strchr(dsname, '@') != NULL || strchr(dsname, '%') != NULL) {\n\t\tret = (SET_ERROR(EINVAL));\n\t\tgoto error;\n\t}\n\n\t(void) nvlist_lookup_uint64(innvl, \"crypt_cmd\", &cmd);\n\t(void) nvlist_lookup_nvlist(innvl, \"props\", &args);\n\t(void) nvlist_lookup_nvlist(innvl, ZPOOL_HIDDEN_ARGS, &hidden_args);\n\n\tret = dsl_crypto_params_create_nvlist(cmd, args, hidden_args, &dcp);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = spa_keystore_change_key(dsname, dcp);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tdsl_crypto_params_free(dcp, B_FALSE);\n\n\treturn (0);\n\nerror:\n\tdsl_crypto_params_free(dcp, B_TRUE);\n\treturn (ret);\n}\n\nstatic zfs_ioc_vec_t zfs_ioc_vec[ZFS_IOC_LAST - ZFS_IOC_FIRST];\n\nstatic void\nzfs_ioctl_register_legacy(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func,\n    zfs_secpolicy_func_t *secpolicy, zfs_ioc_namecheck_t namecheck,\n    boolean_t log_history, zfs_ioc_poolcheck_t pool_check)\n{\n\tzfs_ioc_vec_t *vec = &zfs_ioc_vec[ioc - ZFS_IOC_FIRST];\n\n\tASSERT3U(ioc, >=, ZFS_IOC_FIRST);\n\tASSERT3U(ioc, <, ZFS_IOC_LAST);\n\tASSERT3P(vec->zvec_legacy_func, ==, NULL);\n\tASSERT3P(vec->zvec_func, ==, NULL);\n\n\tvec->zvec_legacy_func = func;\n\tvec->zvec_secpolicy = secpolicy;\n\tvec->zvec_namecheck = namecheck;\n\tvec->zvec_allow_log = log_history;\n\tvec->zvec_pool_check = pool_check;\n}\n\n \nvoid\nzfs_ioctl_register(const char *name, zfs_ioc_t ioc, zfs_ioc_func_t *func,\n    zfs_secpolicy_func_t *secpolicy, zfs_ioc_namecheck_t namecheck,\n    zfs_ioc_poolcheck_t pool_check, boolean_t smush_outnvlist,\n    boolean_t allow_log, const zfs_ioc_key_t *nvl_keys, size_t num_keys)\n{\n\tzfs_ioc_vec_t *vec = &zfs_ioc_vec[ioc - ZFS_IOC_FIRST];\n\n\tASSERT3U(ioc, >=, ZFS_IOC_FIRST);\n\tASSERT3U(ioc, <, ZFS_IOC_LAST);\n\tASSERT3P(vec->zvec_legacy_func, ==, NULL);\n\tASSERT3P(vec->zvec_func, ==, NULL);\n\n\t \n\tASSERT(!allow_log || namecheck != NO_NAME);\n\n\tvec->zvec_name = name;\n\tvec->zvec_func = func;\n\tvec->zvec_secpolicy = secpolicy;\n\tvec->zvec_namecheck = namecheck;\n\tvec->zvec_pool_check = pool_check;\n\tvec->zvec_smush_outnvlist = smush_outnvlist;\n\tvec->zvec_allow_log = allow_log;\n\tvec->zvec_nvl_keys = nvl_keys;\n\tvec->zvec_nvl_key_count = num_keys;\n}\n\nstatic void\nzfs_ioctl_register_pool(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func,\n    zfs_secpolicy_func_t *secpolicy, boolean_t log_history,\n    zfs_ioc_poolcheck_t pool_check)\n{\n\tzfs_ioctl_register_legacy(ioc, func, secpolicy,\n\t    POOL_NAME, log_history, pool_check);\n}\n\nvoid\nzfs_ioctl_register_dataset_nolog(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func,\n    zfs_secpolicy_func_t *secpolicy, zfs_ioc_poolcheck_t pool_check)\n{\n\tzfs_ioctl_register_legacy(ioc, func, secpolicy,\n\t    DATASET_NAME, B_FALSE, pool_check);\n}\n\nstatic void\nzfs_ioctl_register_pool_modify(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func)\n{\n\tzfs_ioctl_register_legacy(ioc, func, zfs_secpolicy_config,\n\t    POOL_NAME, B_TRUE, POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY);\n}\n\nstatic void\nzfs_ioctl_register_pool_meta(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func,\n    zfs_secpolicy_func_t *secpolicy)\n{\n\tzfs_ioctl_register_legacy(ioc, func, secpolicy,\n\t    NO_NAME, B_FALSE, POOL_CHECK_NONE);\n}\n\nstatic void\nzfs_ioctl_register_dataset_read_secpolicy(zfs_ioc_t ioc,\n    zfs_ioc_legacy_func_t *func, zfs_secpolicy_func_t *secpolicy)\n{\n\tzfs_ioctl_register_legacy(ioc, func, secpolicy,\n\t    DATASET_NAME, B_FALSE, POOL_CHECK_SUSPENDED);\n}\n\nstatic void\nzfs_ioctl_register_dataset_read(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func)\n{\n\tzfs_ioctl_register_dataset_read_secpolicy(ioc, func,\n\t    zfs_secpolicy_read);\n}\n\nstatic void\nzfs_ioctl_register_dataset_modify(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func,\n    zfs_secpolicy_func_t *secpolicy)\n{\n\tzfs_ioctl_register_legacy(ioc, func, secpolicy,\n\t    DATASET_NAME, B_TRUE, POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY);\n}\n\nstatic void\nzfs_ioctl_init(void)\n{\n\tzfs_ioctl_register(\"snapshot\", ZFS_IOC_SNAPSHOT,\n\t    zfs_ioc_snapshot, zfs_secpolicy_snapshot, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_snapshot, ARRAY_SIZE(zfs_keys_snapshot));\n\n\tzfs_ioctl_register(\"log_history\", ZFS_IOC_LOG_HISTORY,\n\t    zfs_ioc_log_history, zfs_secpolicy_log_history, NO_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_FALSE,\n\t    zfs_keys_log_history, ARRAY_SIZE(zfs_keys_log_history));\n\n\tzfs_ioctl_register(\"space_snaps\", ZFS_IOC_SPACE_SNAPS,\n\t    zfs_ioc_space_snaps, zfs_secpolicy_read, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_FALSE,\n\t    zfs_keys_space_snaps, ARRAY_SIZE(zfs_keys_space_snaps));\n\n\tzfs_ioctl_register(\"send\", ZFS_IOC_SEND_NEW,\n\t    zfs_ioc_send_new, zfs_secpolicy_send_new, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_FALSE,\n\t    zfs_keys_send_new, ARRAY_SIZE(zfs_keys_send_new));\n\n\tzfs_ioctl_register(\"send_space\", ZFS_IOC_SEND_SPACE,\n\t    zfs_ioc_send_space, zfs_secpolicy_read, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_FALSE,\n\t    zfs_keys_send_space, ARRAY_SIZE(zfs_keys_send_space));\n\n\tzfs_ioctl_register(\"create\", ZFS_IOC_CREATE,\n\t    zfs_ioc_create, zfs_secpolicy_create_clone, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_create, ARRAY_SIZE(zfs_keys_create));\n\n\tzfs_ioctl_register(\"clone\", ZFS_IOC_CLONE,\n\t    zfs_ioc_clone, zfs_secpolicy_create_clone, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_clone, ARRAY_SIZE(zfs_keys_clone));\n\n\tzfs_ioctl_register(\"remap\", ZFS_IOC_REMAP,\n\t    zfs_ioc_remap, zfs_secpolicy_none, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_TRUE,\n\t    zfs_keys_remap, ARRAY_SIZE(zfs_keys_remap));\n\n\tzfs_ioctl_register(\"destroy_snaps\", ZFS_IOC_DESTROY_SNAPS,\n\t    zfs_ioc_destroy_snaps, zfs_secpolicy_destroy_snaps, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_destroy_snaps, ARRAY_SIZE(zfs_keys_destroy_snaps));\n\n\tzfs_ioctl_register(\"hold\", ZFS_IOC_HOLD,\n\t    zfs_ioc_hold, zfs_secpolicy_hold, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_hold, ARRAY_SIZE(zfs_keys_hold));\n\tzfs_ioctl_register(\"release\", ZFS_IOC_RELEASE,\n\t    zfs_ioc_release, zfs_secpolicy_release, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_release, ARRAY_SIZE(zfs_keys_release));\n\n\tzfs_ioctl_register(\"get_holds\", ZFS_IOC_GET_HOLDS,\n\t    zfs_ioc_get_holds, zfs_secpolicy_read, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_FALSE,\n\t    zfs_keys_get_holds, ARRAY_SIZE(zfs_keys_get_holds));\n\n\tzfs_ioctl_register(\"rollback\", ZFS_IOC_ROLLBACK,\n\t    zfs_ioc_rollback, zfs_secpolicy_rollback, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_TRUE,\n\t    zfs_keys_rollback, ARRAY_SIZE(zfs_keys_rollback));\n\n\tzfs_ioctl_register(\"bookmark\", ZFS_IOC_BOOKMARK,\n\t    zfs_ioc_bookmark, zfs_secpolicy_bookmark, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_bookmark, ARRAY_SIZE(zfs_keys_bookmark));\n\n\tzfs_ioctl_register(\"get_bookmarks\", ZFS_IOC_GET_BOOKMARKS,\n\t    zfs_ioc_get_bookmarks, zfs_secpolicy_read, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_FALSE,\n\t    zfs_keys_get_bookmarks, ARRAY_SIZE(zfs_keys_get_bookmarks));\n\n\tzfs_ioctl_register(\"get_bookmark_props\", ZFS_IOC_GET_BOOKMARK_PROPS,\n\t    zfs_ioc_get_bookmark_props, zfs_secpolicy_read, ENTITY_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_FALSE, zfs_keys_get_bookmark_props,\n\t    ARRAY_SIZE(zfs_keys_get_bookmark_props));\n\n\tzfs_ioctl_register(\"destroy_bookmarks\", ZFS_IOC_DESTROY_BOOKMARKS,\n\t    zfs_ioc_destroy_bookmarks, zfs_secpolicy_destroy_bookmarks,\n\t    POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_destroy_bookmarks,\n\t    ARRAY_SIZE(zfs_keys_destroy_bookmarks));\n\n\tzfs_ioctl_register(\"receive\", ZFS_IOC_RECV_NEW,\n\t    zfs_ioc_recv_new, zfs_secpolicy_recv, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_recv_new, ARRAY_SIZE(zfs_keys_recv_new));\n\tzfs_ioctl_register(\"load-key\", ZFS_IOC_LOAD_KEY,\n\t    zfs_ioc_load_key, zfs_secpolicy_load_key,\n\t    DATASET_NAME, POOL_CHECK_SUSPENDED, B_TRUE, B_TRUE,\n\t    zfs_keys_load_key, ARRAY_SIZE(zfs_keys_load_key));\n\tzfs_ioctl_register(\"unload-key\", ZFS_IOC_UNLOAD_KEY,\n\t    zfs_ioc_unload_key, zfs_secpolicy_load_key,\n\t    DATASET_NAME, POOL_CHECK_SUSPENDED, B_TRUE, B_TRUE,\n\t    zfs_keys_unload_key, ARRAY_SIZE(zfs_keys_unload_key));\n\tzfs_ioctl_register(\"change-key\", ZFS_IOC_CHANGE_KEY,\n\t    zfs_ioc_change_key, zfs_secpolicy_change_key,\n\t    DATASET_NAME, POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY,\n\t    B_TRUE, B_TRUE, zfs_keys_change_key,\n\t    ARRAY_SIZE(zfs_keys_change_key));\n\n\tzfs_ioctl_register(\"sync\", ZFS_IOC_POOL_SYNC,\n\t    zfs_ioc_pool_sync, zfs_secpolicy_none, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_FALSE,\n\t    zfs_keys_pool_sync, ARRAY_SIZE(zfs_keys_pool_sync));\n\tzfs_ioctl_register(\"reopen\", ZFS_IOC_POOL_REOPEN, zfs_ioc_pool_reopen,\n\t    zfs_secpolicy_config, POOL_NAME, POOL_CHECK_SUSPENDED, B_TRUE,\n\t    B_TRUE, zfs_keys_pool_reopen, ARRAY_SIZE(zfs_keys_pool_reopen));\n\n\tzfs_ioctl_register(\"channel_program\", ZFS_IOC_CHANNEL_PROGRAM,\n\t    zfs_ioc_channel_program, zfs_secpolicy_config,\n\t    POOL_NAME, POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE,\n\t    B_TRUE, zfs_keys_channel_program,\n\t    ARRAY_SIZE(zfs_keys_channel_program));\n\n\tzfs_ioctl_register(\"redact\", ZFS_IOC_REDACT,\n\t    zfs_ioc_redact, zfs_secpolicy_config, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_redact, ARRAY_SIZE(zfs_keys_redact));\n\n\tzfs_ioctl_register(\"zpool_checkpoint\", ZFS_IOC_POOL_CHECKPOINT,\n\t    zfs_ioc_pool_checkpoint, zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_pool_checkpoint, ARRAY_SIZE(zfs_keys_pool_checkpoint));\n\n\tzfs_ioctl_register(\"zpool_discard_checkpoint\",\n\t    ZFS_IOC_POOL_DISCARD_CHECKPOINT, zfs_ioc_pool_discard_checkpoint,\n\t    zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_pool_discard_checkpoint,\n\t    ARRAY_SIZE(zfs_keys_pool_discard_checkpoint));\n\n\tzfs_ioctl_register(\"initialize\", ZFS_IOC_POOL_INITIALIZE,\n\t    zfs_ioc_pool_initialize, zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_pool_initialize, ARRAY_SIZE(zfs_keys_pool_initialize));\n\n\tzfs_ioctl_register(\"trim\", ZFS_IOC_POOL_TRIM,\n\t    zfs_ioc_pool_trim, zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_TRUE, B_TRUE,\n\t    zfs_keys_pool_trim, ARRAY_SIZE(zfs_keys_pool_trim));\n\n\tzfs_ioctl_register(\"wait\", ZFS_IOC_WAIT,\n\t    zfs_ioc_wait, zfs_secpolicy_none, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_FALSE,\n\t    zfs_keys_pool_wait, ARRAY_SIZE(zfs_keys_pool_wait));\n\n\tzfs_ioctl_register(\"wait_fs\", ZFS_IOC_WAIT_FS,\n\t    zfs_ioc_wait_fs, zfs_secpolicy_none, DATASET_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_FALSE,\n\t    zfs_keys_fs_wait, ARRAY_SIZE(zfs_keys_fs_wait));\n\n\tzfs_ioctl_register(\"set_bootenv\", ZFS_IOC_SET_BOOTENV,\n\t    zfs_ioc_set_bootenv, zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_TRUE,\n\t    zfs_keys_set_bootenv, ARRAY_SIZE(zfs_keys_set_bootenv));\n\n\tzfs_ioctl_register(\"get_bootenv\", ZFS_IOC_GET_BOOTENV,\n\t    zfs_ioc_get_bootenv, zfs_secpolicy_none, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED, B_FALSE, B_TRUE,\n\t    zfs_keys_get_bootenv, ARRAY_SIZE(zfs_keys_get_bootenv));\n\n\tzfs_ioctl_register(\"zpool_vdev_get_props\", ZFS_IOC_VDEV_GET_PROPS,\n\t    zfs_ioc_vdev_get_props, zfs_secpolicy_read, POOL_NAME,\n\t    POOL_CHECK_NONE, B_FALSE, B_FALSE, zfs_keys_vdev_get_props,\n\t    ARRAY_SIZE(zfs_keys_vdev_get_props));\n\n\tzfs_ioctl_register(\"zpool_vdev_set_props\", ZFS_IOC_VDEV_SET_PROPS,\n\t    zfs_ioc_vdev_set_props, zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY, B_FALSE, B_FALSE,\n\t    zfs_keys_vdev_set_props, ARRAY_SIZE(zfs_keys_vdev_set_props));\n\n\tzfs_ioctl_register(\"scrub\", ZFS_IOC_POOL_SCRUB,\n\t    zfs_ioc_pool_scrub, zfs_secpolicy_config, POOL_NAME,\n\t    POOL_CHECK_NONE, B_TRUE, B_TRUE,\n\t    zfs_keys_pool_scrub, ARRAY_SIZE(zfs_keys_pool_scrub));\n\n\t \n\n\tzfs_ioctl_register_legacy(ZFS_IOC_POOL_FREEZE, zfs_ioc_pool_freeze,\n\t    zfs_secpolicy_config, NO_NAME, B_FALSE, POOL_CHECK_READONLY);\n\n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_CREATE, zfs_ioc_pool_create,\n\t    zfs_secpolicy_config, B_TRUE, POOL_CHECK_NONE);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_POOL_SCAN,\n\t    zfs_ioc_pool_scan);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_POOL_UPGRADE,\n\t    zfs_ioc_pool_upgrade);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_ADD,\n\t    zfs_ioc_vdev_add);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_REMOVE,\n\t    zfs_ioc_vdev_remove);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_SET_STATE,\n\t    zfs_ioc_vdev_set_state);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_ATTACH,\n\t    zfs_ioc_vdev_attach);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_DETACH,\n\t    zfs_ioc_vdev_detach);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_SETPATH,\n\t    zfs_ioc_vdev_setpath);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_SETFRU,\n\t    zfs_ioc_vdev_setfru);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_POOL_SET_PROPS,\n\t    zfs_ioc_pool_set_props);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_VDEV_SPLIT,\n\t    zfs_ioc_vdev_split);\n\tzfs_ioctl_register_pool_modify(ZFS_IOC_POOL_REGUID,\n\t    zfs_ioc_pool_reguid);\n\n\tzfs_ioctl_register_pool_meta(ZFS_IOC_POOL_CONFIGS,\n\t    zfs_ioc_pool_configs, zfs_secpolicy_none);\n\tzfs_ioctl_register_pool_meta(ZFS_IOC_POOL_TRYIMPORT,\n\t    zfs_ioc_pool_tryimport, zfs_secpolicy_config);\n\tzfs_ioctl_register_pool_meta(ZFS_IOC_INJECT_FAULT,\n\t    zfs_ioc_inject_fault, zfs_secpolicy_inject);\n\tzfs_ioctl_register_pool_meta(ZFS_IOC_CLEAR_FAULT,\n\t    zfs_ioc_clear_fault, zfs_secpolicy_inject);\n\tzfs_ioctl_register_pool_meta(ZFS_IOC_INJECT_LIST_NEXT,\n\t    zfs_ioc_inject_list_next, zfs_secpolicy_inject);\n\n\t \n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_DESTROY, zfs_ioc_pool_destroy,\n\t    zfs_secpolicy_config, B_FALSE, POOL_CHECK_SUSPENDED);\n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_EXPORT, zfs_ioc_pool_export,\n\t    zfs_secpolicy_config, B_FALSE, POOL_CHECK_SUSPENDED);\n\n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_STATS, zfs_ioc_pool_stats,\n\t    zfs_secpolicy_read, B_FALSE, POOL_CHECK_NONE);\n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_GET_PROPS, zfs_ioc_pool_get_props,\n\t    zfs_secpolicy_read, B_FALSE, POOL_CHECK_NONE);\n\n\tzfs_ioctl_register_pool(ZFS_IOC_ERROR_LOG, zfs_ioc_error_log,\n\t    zfs_secpolicy_inject, B_FALSE, POOL_CHECK_SUSPENDED);\n\tzfs_ioctl_register_pool(ZFS_IOC_DSOBJ_TO_DSNAME,\n\t    zfs_ioc_dsobj_to_dsname,\n\t    zfs_secpolicy_diff, B_FALSE, POOL_CHECK_SUSPENDED);\n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_GET_HISTORY,\n\t    zfs_ioc_pool_get_history,\n\t    zfs_secpolicy_config, B_FALSE, POOL_CHECK_SUSPENDED);\n\n\tzfs_ioctl_register_pool(ZFS_IOC_POOL_IMPORT, zfs_ioc_pool_import,\n\t    zfs_secpolicy_config, B_TRUE, POOL_CHECK_NONE);\n\n\tzfs_ioctl_register_pool(ZFS_IOC_CLEAR, zfs_ioc_clear,\n\t    zfs_secpolicy_config, B_TRUE, POOL_CHECK_READONLY);\n\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_SPACE_WRITTEN,\n\t    zfs_ioc_space_written);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_OBJSET_RECVD_PROPS,\n\t    zfs_ioc_objset_recvd_props);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_NEXT_OBJ,\n\t    zfs_ioc_next_obj);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_GET_FSACL,\n\t    zfs_ioc_get_fsacl);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_OBJSET_STATS,\n\t    zfs_ioc_objset_stats);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_OBJSET_ZPLPROPS,\n\t    zfs_ioc_objset_zplprops);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_DATASET_LIST_NEXT,\n\t    zfs_ioc_dataset_list_next);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_SNAPSHOT_LIST_NEXT,\n\t    zfs_ioc_snapshot_list_next);\n\tzfs_ioctl_register_dataset_read(ZFS_IOC_SEND_PROGRESS,\n\t    zfs_ioc_send_progress);\n\n\tzfs_ioctl_register_dataset_read_secpolicy(ZFS_IOC_DIFF,\n\t    zfs_ioc_diff, zfs_secpolicy_diff);\n\tzfs_ioctl_register_dataset_read_secpolicy(ZFS_IOC_OBJ_TO_STATS,\n\t    zfs_ioc_obj_to_stats, zfs_secpolicy_diff);\n\tzfs_ioctl_register_dataset_read_secpolicy(ZFS_IOC_OBJ_TO_PATH,\n\t    zfs_ioc_obj_to_path, zfs_secpolicy_diff);\n\tzfs_ioctl_register_dataset_read_secpolicy(ZFS_IOC_USERSPACE_ONE,\n\t    zfs_ioc_userspace_one, zfs_secpolicy_userspace_one);\n\tzfs_ioctl_register_dataset_read_secpolicy(ZFS_IOC_USERSPACE_MANY,\n\t    zfs_ioc_userspace_many, zfs_secpolicy_userspace_many);\n\tzfs_ioctl_register_dataset_read_secpolicy(ZFS_IOC_SEND,\n\t    zfs_ioc_send, zfs_secpolicy_send);\n\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_SET_PROP, zfs_ioc_set_prop,\n\t    zfs_secpolicy_none);\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_DESTROY, zfs_ioc_destroy,\n\t    zfs_secpolicy_destroy);\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_RENAME, zfs_ioc_rename,\n\t    zfs_secpolicy_rename);\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_RECV, zfs_ioc_recv,\n\t    zfs_secpolicy_recv);\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_PROMOTE, zfs_ioc_promote,\n\t    zfs_secpolicy_promote);\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_INHERIT_PROP,\n\t    zfs_ioc_inherit_prop, zfs_secpolicy_inherit_prop);\n\tzfs_ioctl_register_dataset_modify(ZFS_IOC_SET_FSACL, zfs_ioc_set_fsacl,\n\t    zfs_secpolicy_set_fsacl);\n\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_SHARE, zfs_ioc_share,\n\t    zfs_secpolicy_share, POOL_CHECK_NONE);\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_SMB_ACL, zfs_ioc_smb_acl,\n\t    zfs_secpolicy_smb_acl, POOL_CHECK_NONE);\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_USERSPACE_UPGRADE,\n\t    zfs_ioc_userspace_upgrade, zfs_secpolicy_userspace_upgrade,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY);\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_TMP_SNAPSHOT,\n\t    zfs_ioc_tmp_snapshot, zfs_secpolicy_tmp_snapshot,\n\t    POOL_CHECK_SUSPENDED | POOL_CHECK_READONLY);\n\n\tzfs_ioctl_register_legacy(ZFS_IOC_EVENTS_NEXT, zfs_ioc_events_next,\n\t    zfs_secpolicy_config, NO_NAME, B_FALSE, POOL_CHECK_NONE);\n\tzfs_ioctl_register_legacy(ZFS_IOC_EVENTS_CLEAR, zfs_ioc_events_clear,\n\t    zfs_secpolicy_config, NO_NAME, B_FALSE, POOL_CHECK_NONE);\n\tzfs_ioctl_register_legacy(ZFS_IOC_EVENTS_SEEK, zfs_ioc_events_seek,\n\t    zfs_secpolicy_config, NO_NAME, B_FALSE, POOL_CHECK_NONE);\n\n\tzfs_ioctl_init_os();\n}\n\n \nstatic int\nzfs_check_input_nvpairs(nvlist_t *innvl, const zfs_ioc_vec_t *vec)\n{\n\tconst zfs_ioc_key_t *nvl_keys = vec->zvec_nvl_keys;\n\tboolean_t required_keys_found = B_FALSE;\n\n\t \n\tfor (nvpair_t *pair = nvlist_next_nvpair(innvl, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(innvl, pair)) {\n\t\tconst char *name = nvpair_name(pair);\n\t\tdata_type_t type = nvpair_type(pair);\n\t\tboolean_t identified = B_FALSE;\n\n\t\t \n\t\tfor (int k = 0; k < vec->zvec_nvl_key_count; k++) {\n\t\t\t \n\t\t\tif ((nvl_keys[k].zkey_flags & ZK_WILDCARDLIST) == 0 &&\n\t\t\t    strcmp(nvl_keys[k].zkey_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tidentified = B_TRUE;\n\n\t\t\tif (nvl_keys[k].zkey_type != DATA_TYPE_ANY &&\n\t\t\t    nvl_keys[k].zkey_type != type) {\n\t\t\t\treturn (SET_ERROR(ZFS_ERR_IOC_ARG_BADTYPE));\n\t\t\t}\n\n\t\t\tif (nvl_keys[k].zkey_flags & ZK_OPTIONAL)\n\t\t\t\tcontinue;\n\n\t\t\trequired_keys_found = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!identified &&\n\t\t    (strcmp(name, \"optional\") != 0 ||\n\t\t    type != DATA_TYPE_NVLIST)) {\n\t\t\treturn (SET_ERROR(ZFS_ERR_IOC_ARG_UNAVAIL));\n\t\t}\n\t}\n\n\t \n\tfor (int k = 0; k < vec->zvec_nvl_key_count; k++) {\n\t\tif (nvl_keys[k].zkey_flags & ZK_OPTIONAL)\n\t\t\tcontinue;\n\n\t\tif (nvl_keys[k].zkey_flags & ZK_WILDCARDLIST) {\n\t\t\t \n\t\t\tif (!required_keys_found)\n\t\t\t\treturn (SET_ERROR(ZFS_ERR_IOC_ARG_REQUIRED));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!nvlist_exists(innvl, nvl_keys[k].zkey_name))\n\t\t\treturn (SET_ERROR(ZFS_ERR_IOC_ARG_REQUIRED));\n\t}\n\n\treturn (0);\n}\n\nstatic int\npool_status_check(const char *name, zfs_ioc_namecheck_t type,\n    zfs_ioc_poolcheck_t check)\n{\n\tspa_t *spa;\n\tint error;\n\n\tASSERT(type == POOL_NAME || type == DATASET_NAME ||\n\t    type == ENTITY_NAME);\n\n\tif (check & POOL_CHECK_NONE)\n\t\treturn (0);\n\n\terror = spa_open(name, &spa, FTAG);\n\tif (error == 0) {\n\t\tif ((check & POOL_CHECK_SUSPENDED) && spa_suspended(spa))\n\t\t\terror = SET_ERROR(EAGAIN);\n\t\telse if ((check & POOL_CHECK_READONLY) && !spa_writeable(spa))\n\t\t\terror = SET_ERROR(EROFS);\n\t\tspa_close(spa, FTAG);\n\t}\n\treturn (error);\n}\n\nint\nzfsdev_getminor(zfs_file_t *fp, minor_t *minorp)\n{\n\tzfsdev_state_t *zs, *fpd;\n\n\tASSERT(!MUTEX_HELD(&zfsdev_state_lock));\n\n\tfpd = zfs_file_private(fp);\n\tif (fpd == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\tmutex_enter(&zfsdev_state_lock);\n\n\tfor (zs = &zfsdev_state_listhead; zs != NULL; zs = zs->zs_next) {\n\n\t\tif (zs->zs_minor == -1)\n\t\t\tcontinue;\n\n\t\tif (fpd == zs) {\n\t\t\t*minorp = fpd->zs_minor;\n\t\t\tmutex_exit(&zfsdev_state_lock);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tmutex_exit(&zfsdev_state_lock);\n\n\treturn (SET_ERROR(EBADF));\n}\n\nvoid *\nzfsdev_get_state(minor_t minor, enum zfsdev_state_type which)\n{\n\tzfsdev_state_t *zs;\n\n\tfor (zs = &zfsdev_state_listhead; zs != NULL; zs = zs->zs_next) {\n\t\tif (zs->zs_minor == minor) {\n\t\t\tmembar_consumer();\n\t\t\tswitch (which) {\n\t\t\tcase ZST_ONEXIT:\n\t\t\t\treturn (zs->zs_onexit);\n\t\t\tcase ZST_ZEVENT:\n\t\t\t\treturn (zs->zs_zevent);\n\t\t\tcase ZST_ALL:\n\t\t\t\treturn (zs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\n \nstatic minor_t\nzfsdev_minor_alloc(void)\n{\n\tstatic minor_t last_minor = 0;\n\tminor_t m;\n\n\tASSERT(MUTEX_HELD(&zfsdev_state_lock));\n\n\tfor (m = last_minor + 1; m != last_minor; m++) {\n\t\tif (m > ZFSDEV_MAX_MINOR)\n\t\t\tm = 1;\n\t\tif (zfsdev_get_state(m, ZST_ALL) == NULL) {\n\t\t\tlast_minor = m;\n\t\t\treturn (m);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nint\nzfsdev_state_init(void *priv)\n{\n\tzfsdev_state_t *zs, *zsprev = NULL;\n\tminor_t minor;\n\tboolean_t newzs = B_FALSE;\n\n\tASSERT(MUTEX_HELD(&zfsdev_state_lock));\n\n\tminor = zfsdev_minor_alloc();\n\tif (minor == 0)\n\t\treturn (SET_ERROR(ENXIO));\n\n\tfor (zs = &zfsdev_state_listhead; zs != NULL; zs = zs->zs_next) {\n\t\tif (zs->zs_minor == -1)\n\t\t\tbreak;\n\t\tzsprev = zs;\n\t}\n\n\tif (!zs) {\n\t\tzs = kmem_zalloc(sizeof (zfsdev_state_t), KM_SLEEP);\n\t\tnewzs = B_TRUE;\n\t}\n\n\tzfsdev_private_set_state(priv, zs);\n\n\tzfs_onexit_init((zfs_onexit_t **)&zs->zs_onexit);\n\tzfs_zevent_init((zfs_zevent_t **)&zs->zs_zevent);\n\n\t \n\tif (newzs) {\n\t\tzs->zs_minor = minor;\n\t\tmembar_producer();\n\t\tzsprev->zs_next = zs;\n\t} else {\n\t\tmembar_producer();\n\t\tzs->zs_minor = minor;\n\t}\n\n\treturn (0);\n}\n\nvoid\nzfsdev_state_destroy(void *priv)\n{\n\tzfsdev_state_t *zs = zfsdev_private_get_state(priv);\n\n\tASSERT(zs != NULL);\n\tASSERT3S(zs->zs_minor, >, 0);\n\n\t \n\tzfs_onexit_destroy(zs->zs_onexit);\n\tzfs_zevent_destroy(zs->zs_zevent);\n\tzs->zs_onexit = NULL;\n\tzs->zs_zevent = NULL;\n\tmembar_producer();\n\tzs->zs_minor = -1;\n}\n\nlong\nzfsdev_ioctl_common(uint_t vecnum, zfs_cmd_t *zc, int flag)\n{\n\tint error, cmd;\n\tconst zfs_ioc_vec_t *vec;\n\tchar *saved_poolname = NULL;\n\tuint64_t max_nvlist_src_size;\n\tsize_t saved_poolname_len = 0;\n\tnvlist_t *innvl = NULL;\n\tfstrans_cookie_t cookie;\n\thrtime_t start_time = gethrtime();\n\n\tcmd = vecnum;\n\terror = 0;\n\tif (vecnum >= sizeof (zfs_ioc_vec) / sizeof (zfs_ioc_vec[0]))\n\t\treturn (SET_ERROR(ZFS_ERR_IOC_CMD_UNAVAIL));\n\n\tvec = &zfs_ioc_vec[vecnum];\n\n\t \n\tif (vec->zvec_func == NULL && vec->zvec_legacy_func == NULL)\n\t\treturn (SET_ERROR(ZFS_ERR_IOC_CMD_UNAVAIL));\n\n\tzc->zc_iflags = flag & FKIOCTL;\n\tmax_nvlist_src_size = zfs_max_nvlist_src_size_os();\n\tif (zc->zc_nvlist_src_size > max_nvlist_src_size) {\n\t\t \n\t\terror = SET_ERROR(EINVAL);\t \n\n\t} else if (zc->zc_nvlist_src_size != 0) {\n\t\terror = get_nvlist(zc->zc_nvlist_src, zc->zc_nvlist_src_size,\n\t\t    zc->zc_iflags, &innvl);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tzc->zc_name[sizeof (zc->zc_name) - 1] = '\\0';\n\tswitch (vec->zvec_namecheck) {\n\tcase POOL_NAME:\n\t\tif (pool_namecheck(zc->zc_name, NULL, NULL) != 0)\n\t\t\terror = SET_ERROR(EINVAL);\n\t\telse\n\t\t\terror = pool_status_check(zc->zc_name,\n\t\t\t    vec->zvec_namecheck, vec->zvec_pool_check);\n\t\tbreak;\n\n\tcase DATASET_NAME:\n\t\tif (dataset_namecheck(zc->zc_name, NULL, NULL) != 0)\n\t\t\terror = SET_ERROR(EINVAL);\n\t\telse\n\t\t\terror = pool_status_check(zc->zc_name,\n\t\t\t    vec->zvec_namecheck, vec->zvec_pool_check);\n\t\tbreak;\n\n\tcase ENTITY_NAME:\n\t\tif (entity_namecheck(zc->zc_name, NULL, NULL) != 0) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t} else {\n\t\t\terror = pool_status_check(zc->zc_name,\n\t\t\t    vec->zvec_namecheck, vec->zvec_pool_check);\n\t\t}\n\t\tbreak;\n\n\tcase NO_NAME:\n\t\tbreak;\n\t}\n\t \n\tif (error == 0 && vec->zvec_func != NULL) {\n\t\terror = zfs_check_input_nvpairs(innvl, vec);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\t}\n\n\tif (error == 0) {\n\t\tcookie = spl_fstrans_mark();\n\t\terror = vec->zvec_secpolicy(zc, innvl, CRED());\n\t\tspl_fstrans_unmark(cookie);\n\t}\n\n\tif (error != 0)\n\t\tgoto out;\n\n\t \n\t \n\tsaved_poolname_len = strlen(zc->zc_name) + 1;\n\tsaved_poolname = kmem_alloc(saved_poolname_len, KM_SLEEP);\n\n\tstrlcpy(saved_poolname, zc->zc_name, saved_poolname_len);\n\tsaved_poolname[strcspn(saved_poolname, \"/@#\")] = '\\0';\n\n\tif (vec->zvec_func != NULL) {\n\t\tnvlist_t *outnvl;\n\t\tint puterror = 0;\n\t\tspa_t *spa;\n\t\tnvlist_t *lognv = NULL;\n\n\t\tASSERT(vec->zvec_legacy_func == NULL);\n\n\t\t \n\t\tif (vec->zvec_allow_log) {\n\t\t\tlognv = fnvlist_alloc();\n\t\t\tfnvlist_add_string(lognv, ZPOOL_HIST_IOCTL,\n\t\t\t    vec->zvec_name);\n\t\t\tif (!nvlist_empty(innvl)) {\n\t\t\t\tfnvlist_add_nvlist(lognv, ZPOOL_HIST_INPUT_NVL,\n\t\t\t\t    innvl);\n\t\t\t}\n\t\t}\n\n\t\toutnvl = fnvlist_alloc();\n\t\tcookie = spl_fstrans_mark();\n\t\terror = vec->zvec_func(zc->zc_name, innvl, outnvl);\n\t\tspl_fstrans_unmark(cookie);\n\n\t\t \n\t\tif ((error == 0 ||\n\t\t    (cmd == ZFS_IOC_CHANNEL_PROGRAM && error != EINVAL)) &&\n\t\t    vec->zvec_allow_log &&\n\t\t    spa_open(zc->zc_name, &spa, FTAG) == 0) {\n\t\t\tif (!nvlist_empty(outnvl)) {\n\t\t\t\tsize_t out_size = fnvlist_size(outnvl);\n\t\t\t\tif (out_size > zfs_history_output_max) {\n\t\t\t\t\tfnvlist_add_int64(lognv,\n\t\t\t\t\t    ZPOOL_HIST_OUTPUT_SIZE, out_size);\n\t\t\t\t} else {\n\t\t\t\t\tfnvlist_add_nvlist(lognv,\n\t\t\t\t\t    ZPOOL_HIST_OUTPUT_NVL, outnvl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (error != 0) {\n\t\t\t\tfnvlist_add_int64(lognv, ZPOOL_HIST_ERRNO,\n\t\t\t\t    error);\n\t\t\t}\n\t\t\tfnvlist_add_int64(lognv, ZPOOL_HIST_ELAPSED_NS,\n\t\t\t    gethrtime() - start_time);\n\t\t\t(void) spa_history_log_nvl(spa, lognv);\n\t\t\tspa_close(spa, FTAG);\n\t\t}\n\t\tfnvlist_free(lognv);\n\n\t\tif (!nvlist_empty(outnvl) || zc->zc_nvlist_dst_size != 0) {\n\t\t\tint smusherror = 0;\n\t\t\tif (vec->zvec_smush_outnvlist) {\n\t\t\t\tsmusherror = nvlist_smush(outnvl,\n\t\t\t\t    zc->zc_nvlist_dst_size);\n\t\t\t}\n\t\t\tif (smusherror == 0)\n\t\t\t\tputerror = put_nvlist(zc, outnvl);\n\t\t}\n\n\t\tif (puterror != 0)\n\t\t\terror = puterror;\n\n\t\tnvlist_free(outnvl);\n\t} else {\n\t\tcookie = spl_fstrans_mark();\n\t\terror = vec->zvec_legacy_func(zc);\n\t\tspl_fstrans_unmark(cookie);\n\t}\n\nout:\n\tnvlist_free(innvl);\n\tif (error == 0 && vec->zvec_allow_log) {\n\t\tchar *s = tsd_get(zfs_allow_log_key);\n\t\tif (s != NULL)\n\t\t\tkmem_strfree(s);\n\t\t(void) tsd_set(zfs_allow_log_key, kmem_strdup(saved_poolname));\n\t}\n\tif (saved_poolname != NULL)\n\t\tkmem_free(saved_poolname, saved_poolname_len);\n\n\treturn (error);\n}\n\nint\nzfs_kmod_init(void)\n{\n\tint error;\n\n\tif ((error = zvol_init()) != 0)\n\t\treturn (error);\n\n\tspa_init(SPA_MODE_READ | SPA_MODE_WRITE);\n\tzfs_init();\n\n\tzfs_ioctl_init();\n\n\tmutex_init(&zfsdev_state_lock, NULL, MUTEX_DEFAULT, NULL);\n\tzfsdev_state_listhead.zs_minor = -1;\n\n\tif ((error = zfsdev_attach()) != 0)\n\t\tgoto out;\n\n\ttsd_create(&zfs_fsyncer_key, NULL);\n\ttsd_create(&rrw_tsd_key, rrw_tsd_destroy);\n\ttsd_create(&zfs_allow_log_key, zfs_allow_log_destroy);\n\n\treturn (0);\nout:\n\tzfs_fini();\n\tspa_fini();\n\tzvol_fini();\n\n\treturn (error);\n}\n\nvoid\nzfs_kmod_fini(void)\n{\n\tzfsdev_state_t *zs, *zsnext = NULL;\n\n\tzfsdev_detach();\n\n\tmutex_destroy(&zfsdev_state_lock);\n\n\tfor (zs = &zfsdev_state_listhead; zs != NULL; zs = zsnext) {\n\t\tzsnext = zs->zs_next;\n\t\tif (zs->zs_onexit)\n\t\t\tzfs_onexit_destroy(zs->zs_onexit);\n\t\tif (zs->zs_zevent)\n\t\t\tzfs_zevent_destroy(zs->zs_zevent);\n\t\tif (zs != &zfsdev_state_listhead)\n\t\t\tkmem_free(zs, sizeof (zfsdev_state_t));\n\t}\n\n\tzfs_ereport_taskq_fini();\t \n\tzfs_fini();\n\tspa_fini();\n\tzvol_fini();\n\n\ttsd_destroy(&zfs_fsyncer_key);\n\ttsd_destroy(&rrw_tsd_key);\n\ttsd_destroy(&zfs_allow_log_key);\n}\n\nZFS_MODULE_PARAM(zfs, zfs_, max_nvlist_src_size, U64, ZMOD_RW,\n\t\"Maximum size in bytes allowed for src nvlist passed with ZFS ioctls\");\n\nZFS_MODULE_PARAM(zfs, zfs_, history_output_max, U64, ZMOD_RW,\n\t\"Maximum size in bytes of ZFS ioctl output that will be logged\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}