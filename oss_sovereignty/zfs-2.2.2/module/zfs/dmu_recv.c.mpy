{
  "module_name": "dmu_recv.c",
  "hash_id": "bb436d57c82393e291cb0bacc1f13d2daf0e297940e2d7f53a90981a9fe5767e",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu_recv.c",
  "human_readable_source": " \n \n\n#include <sys/arc.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_send.h>\n#include <sys/dmu_recv.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n#include <sys/zvol.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_znode.h>\n#include <zfs_fletcher.h>\n#include <sys/avl.h>\n#include <sys/ddt.h>\n#include <sys/zfs_onexit.h>\n#include <sys/dsl_destroy.h>\n#include <sys/blkptr.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/zfeature.h>\n#include <sys/bqueue.h>\n#include <sys/objlist.h>\n#ifdef _KERNEL\n#include <sys/zfs_vfsops.h>\n#endif\n#include <sys/zfs_file.h>\n\nstatic uint_t zfs_recv_queue_length = SPA_MAXBLOCKSIZE;\nstatic uint_t zfs_recv_queue_ff = 20;\nstatic uint_t zfs_recv_write_batch_size = 1024 * 1024;\nstatic int zfs_recv_best_effort_corrective = 0;\n\nstatic const void *const dmu_recv_tag = \"dmu_recv_tag\";\nconst char *const recv_clone_name = \"%recv\";\n\ntypedef enum {\n\tORNS_NO,\n\tORNS_YES,\n\tORNS_MAYBE\n} or_need_sync_t;\n\nstatic int receive_read_payload_and_next_header(dmu_recv_cookie_t *ra, int len,\n    void *buf);\n\nstruct receive_record_arg {\n\tdmu_replay_record_t header;\n\tvoid *payload;  \n\t \n\tabd_t *abd;\n\tint payload_size;\n\tuint64_t bytes_read;  \n\tboolean_t eos_marker;  \n\tbqueue_node_t node;\n};\n\nstruct receive_writer_arg {\n\tobjset_t *os;\n\tboolean_t byteswap;\n\tbqueue_t q;\n\n\t \n\tkmutex_t mutex;\n\tkcondvar_t cv;\n\tboolean_t done;\n\n\tint err;\n\tconst char *tofs;\n\tboolean_t heal;\n\tboolean_t resumable;\n\tboolean_t raw;    \n\tboolean_t spill;  \n\tboolean_t full;   \n\tuint64_t last_object;\n\tuint64_t last_offset;\n\tuint64_t max_object;  \n\tuint64_t bytes_read;  \n\n\tlist_t write_batch;\n\n\t \n\tboolean_t or_crypt_params_present;\n\tuint64_t or_firstobj;\n\tuint64_t or_numslots;\n\tuint8_t or_salt[ZIO_DATA_SALT_LEN];\n\tuint8_t or_iv[ZIO_DATA_IV_LEN];\n\tuint8_t or_mac[ZIO_DATA_MAC_LEN];\n\tboolean_t or_byteorder;\n\tzio_t *heal_pio;\n\n\t \n\tor_need_sync_t or_need_sync;\n};\n\ntypedef struct dmu_recv_begin_arg {\n\tconst char *drba_origin;\n\tdmu_recv_cookie_t *drba_cookie;\n\tcred_t *drba_cred;\n\tproc_t *drba_proc;\n\tdsl_crypto_params_t *drba_dcp;\n} dmu_recv_begin_arg_t;\n\nstatic void\nbyteswap_record(dmu_replay_record_t *drr)\n{\n#define\tDO64(X) (drr->drr_u.X = BSWAP_64(drr->drr_u.X))\n#define\tDO32(X) (drr->drr_u.X = BSWAP_32(drr->drr_u.X))\n\tdrr->drr_type = BSWAP_32(drr->drr_type);\n\tdrr->drr_payloadlen = BSWAP_32(drr->drr_payloadlen);\n\n\tswitch (drr->drr_type) {\n\tcase DRR_BEGIN:\n\t\tDO64(drr_begin.drr_magic);\n\t\tDO64(drr_begin.drr_versioninfo);\n\t\tDO64(drr_begin.drr_creation_time);\n\t\tDO32(drr_begin.drr_type);\n\t\tDO32(drr_begin.drr_flags);\n\t\tDO64(drr_begin.drr_toguid);\n\t\tDO64(drr_begin.drr_fromguid);\n\t\tbreak;\n\tcase DRR_OBJECT:\n\t\tDO64(drr_object.drr_object);\n\t\tDO32(drr_object.drr_type);\n\t\tDO32(drr_object.drr_bonustype);\n\t\tDO32(drr_object.drr_blksz);\n\t\tDO32(drr_object.drr_bonuslen);\n\t\tDO32(drr_object.drr_raw_bonuslen);\n\t\tDO64(drr_object.drr_toguid);\n\t\tDO64(drr_object.drr_maxblkid);\n\t\tbreak;\n\tcase DRR_FREEOBJECTS:\n\t\tDO64(drr_freeobjects.drr_firstobj);\n\t\tDO64(drr_freeobjects.drr_numobjs);\n\t\tDO64(drr_freeobjects.drr_toguid);\n\t\tbreak;\n\tcase DRR_WRITE:\n\t\tDO64(drr_write.drr_object);\n\t\tDO32(drr_write.drr_type);\n\t\tDO64(drr_write.drr_offset);\n\t\tDO64(drr_write.drr_logical_size);\n\t\tDO64(drr_write.drr_toguid);\n\t\tZIO_CHECKSUM_BSWAP(&drr->drr_u.drr_write.drr_key.ddk_cksum);\n\t\tDO64(drr_write.drr_key.ddk_prop);\n\t\tDO64(drr_write.drr_compressed_size);\n\t\tbreak;\n\tcase DRR_WRITE_EMBEDDED:\n\t\tDO64(drr_write_embedded.drr_object);\n\t\tDO64(drr_write_embedded.drr_offset);\n\t\tDO64(drr_write_embedded.drr_length);\n\t\tDO64(drr_write_embedded.drr_toguid);\n\t\tDO32(drr_write_embedded.drr_lsize);\n\t\tDO32(drr_write_embedded.drr_psize);\n\t\tbreak;\n\tcase DRR_FREE:\n\t\tDO64(drr_free.drr_object);\n\t\tDO64(drr_free.drr_offset);\n\t\tDO64(drr_free.drr_length);\n\t\tDO64(drr_free.drr_toguid);\n\t\tbreak;\n\tcase DRR_SPILL:\n\t\tDO64(drr_spill.drr_object);\n\t\tDO64(drr_spill.drr_length);\n\t\tDO64(drr_spill.drr_toguid);\n\t\tDO64(drr_spill.drr_compressed_size);\n\t\tDO32(drr_spill.drr_type);\n\t\tbreak;\n\tcase DRR_OBJECT_RANGE:\n\t\tDO64(drr_object_range.drr_firstobj);\n\t\tDO64(drr_object_range.drr_numslots);\n\t\tDO64(drr_object_range.drr_toguid);\n\t\tbreak;\n\tcase DRR_REDACT:\n\t\tDO64(drr_redact.drr_object);\n\t\tDO64(drr_redact.drr_offset);\n\t\tDO64(drr_redact.drr_length);\n\t\tDO64(drr_redact.drr_toguid);\n\t\tbreak;\n\tcase DRR_END:\n\t\tDO64(drr_end.drr_toguid);\n\t\tZIO_CHECKSUM_BSWAP(&drr->drr_u.drr_end.drr_checksum);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (drr->drr_type != DRR_BEGIN) {\n\t\tZIO_CHECKSUM_BSWAP(&drr->drr_u.drr_checksum.drr_checksum);\n\t}\n\n#undef DO64\n#undef DO32\n}\n\nstatic boolean_t\nredact_snaps_contains(uint64_t *snaps, uint64_t num_snaps, uint64_t guid)\n{\n\tfor (int i = 0; i < num_snaps; i++) {\n\t\tif (snaps[i] == guid)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic boolean_t\ncompatible_redact_snaps(uint64_t *origin_snaps, uint64_t origin_num_snaps,\n    uint64_t *redact_snaps, uint64_t num_redact_snaps)\n{\n\t \n\tif (num_redact_snaps > origin_num_snaps) {\n\t\treturn (B_FALSE);\n\t}\n\n\tfor (int i = 0; i < num_redact_snaps; i++) {\n\t\tif (!redact_snaps_contains(origin_snaps, origin_num_snaps,\n\t\t    redact_snaps[i])) {\n\t\t\treturn (B_FALSE);\n\t\t}\n\t}\n\treturn (B_TRUE);\n}\n\nstatic boolean_t\nredact_check(dmu_recv_begin_arg_t *drba, dsl_dataset_t *origin)\n{\n\tuint64_t *origin_snaps;\n\tuint64_t origin_num_snaps;\n\tdmu_recv_cookie_t *drc = drba->drba_cookie;\n\tstruct drr_begin *drrb = drc->drc_drrb;\n\tint featureflags = DMU_GET_FEATUREFLAGS(drrb->drr_versioninfo);\n\tint err = 0;\n\tboolean_t ret = B_TRUE;\n\tuint64_t *redact_snaps;\n\tuint_t numredactsnaps;\n\n\t \n\tif (drrb->drr_fromguid == 0)\n\t\treturn (ret);\n\n\tVERIFY(dsl_dataset_get_uint64_array_feature(origin,\n\t    SPA_FEATURE_REDACTED_DATASETS, &origin_num_snaps, &origin_snaps));\n\n\tif (nvlist_lookup_uint64_array(drc->drc_begin_nvl,\n\t    BEGINNV_REDACT_FROM_SNAPS, &redact_snaps, &numredactsnaps) ==\n\t    0) {\n\t\t \n\t\tif (!compatible_redact_snaps(origin_snaps, origin_num_snaps,\n\t\t    redact_snaps, numredactsnaps)) {\n\t\t\terr = EINVAL;\n\t\t}\n\t} else if (featureflags & DMU_BACKUP_FEATURE_REDACTED) {\n\t\t \n\t\terr = nvlist_lookup_uint64_array(drc->drc_begin_nvl,\n\t\t    BEGINNV_REDACT_SNAPS, &redact_snaps, &numredactsnaps);\n\n\t\tif (err != 0 || !compatible_redact_snaps(origin_snaps,\n\t\t    origin_num_snaps, redact_snaps, numredactsnaps)) {\n\t\t\terr = EINVAL;\n\t\t}\n\t} else if (!redact_snaps_contains(origin_snaps, origin_num_snaps,\n\t    drrb->drr_toguid)) {\n\t\t \n\t\terr = EINVAL;\n\t}\n\n\tif (err != 0)\n\t\tret = B_FALSE;\n\treturn (ret);\n}\n\n \nstatic int\nrecv_check_large_blocks(dsl_dataset_t *ds, uint64_t featureflags)\n{\n\tif (dsl_dataset_feature_is_active(ds, SPA_FEATURE_LARGE_BLOCKS) &&\n\t    !(featureflags & DMU_BACKUP_FEATURE_LARGE_BLOCKS))\n\t\treturn (SET_ERROR(ZFS_ERR_STREAM_LARGE_BLOCK_MISMATCH));\n\treturn (0);\n}\n\nstatic int\nrecv_begin_check_existing_impl(dmu_recv_begin_arg_t *drba, dsl_dataset_t *ds,\n    uint64_t fromguid, uint64_t featureflags)\n{\n\tuint64_t obj;\n\tuint64_t children;\n\tint error;\n\tdsl_dataset_t *snap;\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tboolean_t encrypted = ds->ds_dir->dd_crypto_obj != 0;\n\tboolean_t raw = (featureflags & DMU_BACKUP_FEATURE_RAW) != 0;\n\tboolean_t embed = (featureflags & DMU_BACKUP_FEATURE_EMBED_DATA) != 0;\n\n\t \n\terror = zap_lookup(dp->dp_meta_objset,\n\t    dsl_dir_phys(ds->ds_dir)->dd_child_dir_zapobj, recv_clone_name,\n\t    8, 1, &obj);\n\tif (error != ENOENT)\n\t\treturn (error == 0 ? SET_ERROR(EBUSY) : error);\n\n\t \n\tif (dsl_dataset_has_resume_receive_state(ds))\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\terror = zap_lookup(dp->dp_meta_objset,\n\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj,\n\t    drba->drba_cookie->drc_tosnap, 8, 1, &obj);\n\tif (drba->drba_cookie->drc_heal) {\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t} else if (error != ENOENT) {\n\t\treturn (error == 0 ? SET_ERROR(EEXIST) : error);\n\t}\n\n\t \n\terror = zap_count(dp->dp_meta_objset,\n\t    dsl_dir_phys(ds->ds_dir)->dd_child_dir_zapobj, &children);\n\tif (error != 0)\n\t\treturn (error);\n\tif (drba->drba_cookie->drc_drrb->drr_type != DMU_OST_ZFS &&\n\t    children > 0)\n\t\treturn (SET_ERROR(ZFS_ERR_WRONG_PARENT));\n\n\t \n\terror = dsl_fs_ss_limit_check(ds->ds_dir, 1, ZFS_PROP_SNAPSHOT_LIMIT,\n\t    NULL, drba->drba_cred, drba->drba_proc);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (drba->drba_cookie->drc_heal) {\n\t\t \n\t\tif (encrypted && embed)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (drba->drba_cookie->drc_force)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (encrypted && !raw) {\n\t\t\tif (spa_keystore_lookup_key(dp->dp_spa, ds->ds_object,\n\t\t\t    NULL, NULL) != 0)\n\t\t\t\treturn (SET_ERROR(EACCES));\n\t\t}\n\n\t\terror = dsl_dataset_hold_obj(dp, obj, FTAG, &snap);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\t \n\t\tif (zfs_recv_best_effort_corrective == 0 &&\n\t\t    drba->drba_cookie->drc_drrb->drr_toguid !=\n\t\t    dsl_dataset_phys(snap)->ds_guid) {\n\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t}\n\t\tdsl_dataset_rele(snap, FTAG);\n\t} else if (fromguid != 0) {\n\t\t \n\t\tuint64_t obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\n\t\t \n\t\tif (!encrypted && raw)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (encrypted && embed)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\twhile (obj != 0) {\n\t\t\terror = dsl_dataset_hold_obj(dp, obj, FTAG,\n\t\t\t    &snap);\n\t\t\tif (error != 0)\n\t\t\t\treturn (SET_ERROR(ENODEV));\n\t\t\tif (snap->ds_dir != ds->ds_dir) {\n\t\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\t\treturn (SET_ERROR(ENODEV));\n\t\t\t}\n\t\t\tif (dsl_dataset_phys(snap)->ds_guid == fromguid)\n\t\t\t\tbreak;\n\t\t\tobj = dsl_dataset_phys(snap)->ds_prev_snap_obj;\n\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t}\n\t\tif (obj == 0)\n\t\t\treturn (SET_ERROR(ENODEV));\n\n\t\tif (drba->drba_cookie->drc_force) {\n\t\t\tdrba->drba_cookie->drc_fromsnapobj = obj;\n\t\t} else {\n\t\t\t \n\t\t\tif (dsl_dataset_modified_since_snap(ds, snap) ||\n\t\t\t    (raw &&\n\t\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj !=\n\t\t\t    snap->ds_object)) {\n\t\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\t\treturn (SET_ERROR(ETXTBSY));\n\t\t\t}\n\t\t\tdrba->drba_cookie->drc_fromsnapobj =\n\t\t\t    ds->ds_prev->ds_object;\n\t\t}\n\n\t\tif (dsl_dataset_feature_is_active(snap,\n\t\t    SPA_FEATURE_REDACTED_DATASETS) && !redact_check(drba,\n\t\t    snap)) {\n\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\terror = recv_check_large_blocks(snap, featureflags);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\tdsl_dataset_rele(snap, FTAG);\n\t} else {\n\t\t \n\t\tif (!drba->drba_cookie->drc_force)\n\t\t\treturn (SET_ERROR(EEXIST));\n\n\t\t \n\t\tif ((!encrypted && raw) || encrypted)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (!raw) {\n\t\t\tboolean_t will_encrypt;\n\n\t\t\terror = dmu_objset_create_crypt_check(\n\t\t\t    ds->ds_dir->dd_parent, drba->drba_dcp,\n\t\t\t    &will_encrypt);\n\t\t\tif (error != 0)\n\t\t\t\treturn (error);\n\n\t\t\tif (will_encrypt && embed)\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nrecv_begin_check_feature_flags_impl(uint64_t featureflags, spa_t *spa)\n{\n\t \n\tif (!DMU_STREAM_SUPPORTED(featureflags)) {\n\t\treturn (SET_ERROR(ZFS_ERR_UNKNOWN_SEND_STREAM_FEATURE));\n\t}\n\n\t \n\tif ((featureflags & DMU_BACKUP_FEATURE_SA_SPILL) &&\n\t    spa_version(spa) < SPA_VERSION_SA)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\t \n\tif ((featureflags & DMU_BACKUP_FEATURE_LZ4) &&\n\t    !spa_feature_is_enabled(spa, SPA_FEATURE_LZ4_COMPRESS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif ((featureflags & DMU_BACKUP_FEATURE_ZSTD) &&\n\t    !spa_feature_is_enabled(spa, SPA_FEATURE_ZSTD_COMPRESS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif ((featureflags & DMU_BACKUP_FEATURE_EMBED_DATA) &&\n\t    !spa_feature_is_enabled(spa, SPA_FEATURE_EMBEDDED_DATA))\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif ((featureflags & DMU_BACKUP_FEATURE_LARGE_BLOCKS) &&\n\t    !spa_feature_is_enabled(spa, SPA_FEATURE_LARGE_BLOCKS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif ((featureflags & DMU_BACKUP_FEATURE_LARGE_DNODE) &&\n\t    !spa_feature_is_enabled(spa, SPA_FEATURE_LARGE_DNODE))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\t \n\tif ((featureflags & DMU_BACKUP_FEATURE_REDACTED) &&\n\t    !spa_feature_is_enabled(spa, SPA_FEATURE_REDACTED_DATASETS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\treturn (0);\n}\n\nstatic int\ndmu_recv_begin_check(void *arg, dmu_tx_t *tx)\n{\n\tdmu_recv_begin_arg_t *drba = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tstruct drr_begin *drrb = drba->drba_cookie->drc_drrb;\n\tuint64_t fromguid = drrb->drr_fromguid;\n\tint flags = drrb->drr_flags;\n\tds_hold_flags_t dsflags = DS_HOLD_FLAG_NONE;\n\tint error;\n\tuint64_t featureflags = drba->drba_cookie->drc_featureflags;\n\tdsl_dataset_t *ds;\n\tconst char *tofs = drba->drba_cookie->drc_tofs;\n\n\t \n\tASSERT3U(drrb->drr_magic, ==, DMU_BACKUP_MAGIC);\n\tASSERT(!(featureflags & DMU_BACKUP_FEATURE_RESUMING));\n\n\tif (DMU_GET_STREAM_HDRTYPE(drrb->drr_versioninfo) ==\n\t    DMU_COMPOUNDSTREAM ||\n\t    drrb->drr_type >= DMU_OST_NUMTYPES ||\n\t    ((flags & DRR_FLAG_CLONE) && drba->drba_origin == NULL))\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = recv_begin_check_feature_flags_impl(featureflags, dp->dp_spa);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tif (drba->drba_cookie->drc_resumable &&\n\t    !spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_EXTENSIBLE_DATASET))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\t \n\t\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_ENCRYPTION))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\n\t\t \n\t\tif (featureflags & DMU_BACKUP_FEATURE_EMBED_DATA)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (!(flags & DRR_FLAG_SPILL_BLOCK))\n\t\t\treturn (SET_ERROR(ZFS_ERR_SPILL_BLOCK_FLAG_MISSING));\n\t} else {\n\t\t \n\t\tif (drba->drba_dcp == NULL ||\n\t\t    drba->drba_dcp->cp_crypt != ZIO_CRYPT_OFF) {\n\t\t\tdsflags |= DS_HOLD_FLAG_DECRYPT;\n\t\t}\n\t}\n\n\terror = dsl_dataset_hold_flags(dp, tofs, dsflags, FTAG, &ds);\n\tif (error == 0) {\n\t\t \n\n\t\t \n\t\tif (flags & DRR_FLAG_CLONE || drba->drba_origin) {\n\t\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\terror = recv_begin_check_existing_impl(drba, ds, fromguid,\n\t\t    featureflags);\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t} else if (error == ENOENT) {\n\t\t \n\t\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\t\tobjset_t *os;\n\n\t\t \n\t\tif (drba->drba_cookie->drc_heal == B_TRUE)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\n\t\t \n\t\tif (fromguid != 0 && !((flags & DRR_FLAG_CLONE) ||\n\t\t    drba->drba_origin))\n\t\t\treturn (SET_ERROR(ENOENT));\n\n\t\t \n\t\tif (fromguid == 0 && drba->drba_origin != NULL &&\n\t\t    !(flags & DRR_FLAG_FREERECORDS))\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tASSERT3U(strlen(tofs), <, sizeof (buf));\n\t\t(void) strlcpy(buf, tofs, strrchr(tofs, '/') - tofs + 1);\n\t\terror = dsl_dataset_hold(dp, buf, FTAG, &ds);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\tif ((featureflags & DMU_BACKUP_FEATURE_RAW) == 0 &&\n\t\t    drba->drba_origin == NULL) {\n\t\t\tboolean_t will_encrypt;\n\n\t\t\t \n\t\t\terror = dmu_objset_create_crypt_check(ds->ds_dir,\n\t\t\t    drba->drba_dcp, &will_encrypt);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\n\t\t\tif (will_encrypt &&\n\t\t\t    (featureflags & DMU_BACKUP_FEATURE_EMBED_DATA)) {\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\terror = dsl_fs_ss_limit_check(ds->ds_dir, 1,\n\t\t    ZFS_PROP_FILESYSTEM_LIMIT, NULL,\n\t\t    drba->drba_cred, drba->drba_proc);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\terror = dsl_fs_ss_limit_check(ds->ds_dir, 1,\n\t\t    ZFS_PROP_SNAPSHOT_LIMIT, NULL,\n\t\t    drba->drba_cred, drba->drba_proc);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\t \n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\tif (dmu_objset_type(os) != DMU_OST_ZFS) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (SET_ERROR(ZFS_ERR_WRONG_PARENT));\n\t\t}\n\n\t\tif (drba->drba_origin != NULL) {\n\t\t\tdsl_dataset_t *origin;\n\t\t\terror = dsl_dataset_hold_flags(dp, drba->drba_origin,\n\t\t\t    dsflags, FTAG, &origin);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tif (!origin->ds_is_snapshot) {\n\t\t\t\tdsl_dataset_rele_flags(origin, dsflags, FTAG);\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\t\t\tif (dsl_dataset_phys(origin)->ds_guid != fromguid &&\n\t\t\t    fromguid != 0) {\n\t\t\t\tdsl_dataset_rele_flags(origin, dsflags, FTAG);\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (SET_ERROR(ENODEV));\n\t\t\t}\n\n\t\t\tif (origin->ds_dir->dd_crypto_obj != 0 &&\n\t\t\t    (featureflags & DMU_BACKUP_FEATURE_EMBED_DATA)) {\n\t\t\t\tdsl_dataset_rele_flags(origin, dsflags, FTAG);\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dsl_dataset_feature_is_active(origin,\n\t\t\t    SPA_FEATURE_REDACTED_DATASETS)) {\n\t\t\t\tif (!redact_check(drba, origin)) {\n\t\t\t\t\tdsl_dataset_rele_flags(origin, dsflags,\n\t\t\t\t\t    FTAG);\n\t\t\t\t\tdsl_dataset_rele_flags(ds, dsflags,\n\t\t\t\t\t    FTAG);\n\t\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terror = recv_check_large_blocks(ds, featureflags);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele_flags(origin, dsflags, FTAG);\n\t\t\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\n\t\t\tdsl_dataset_rele_flags(origin, dsflags, FTAG);\n\t\t}\n\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\terror = 0;\n\t}\n\treturn (error);\n}\n\nstatic void\ndmu_recv_begin_sync(void *arg, dmu_tx_t *tx)\n{\n\tdmu_recv_begin_arg_t *drba = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdmu_recv_cookie_t *drc = drba->drba_cookie;\n\tstruct drr_begin *drrb = drc->drc_drrb;\n\tconst char *tofs = drc->drc_tofs;\n\tuint64_t featureflags = drc->drc_featureflags;\n\tdsl_dataset_t *ds, *newds;\n\tobjset_t *os;\n\tuint64_t dsobj;\n\tds_hold_flags_t dsflags = DS_HOLD_FLAG_NONE;\n\tint error;\n\tuint64_t crflags = 0;\n\tdsl_crypto_params_t dummy_dcp = { 0 };\n\tdsl_crypto_params_t *dcp = drba->drba_dcp;\n\n\tif (drrb->drr_flags & DRR_FLAG_CI_DATA)\n\t\tcrflags |= DS_FLAG_CI_DATASET;\n\n\tif ((featureflags & DMU_BACKUP_FEATURE_RAW) == 0)\n\t\tdsflags |= DS_HOLD_FLAG_DECRYPT;\n\n\t \n\tif (dcp == NULL && drrb->drr_fromguid == 0 &&\n\t    drba->drba_origin == NULL) {\n\t\tASSERT3P(dcp, ==, NULL);\n\t\tdcp = &dummy_dcp;\n\n\t\tif (featureflags & DMU_BACKUP_FEATURE_RAW)\n\t\t\tdcp->cp_cmd = DCP_CMD_RAW_RECV;\n\t}\n\n\terror = dsl_dataset_hold_flags(dp, tofs, dsflags, FTAG, &ds);\n\tif (error == 0) {\n\t\t \n\t\tdsl_dataset_t *snap = NULL;\n\n\t\tif (drba->drba_cookie->drc_fromsnapobj != 0) {\n\t\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t\t    drba->drba_cookie->drc_fromsnapobj, FTAG, &snap));\n\t\t\tASSERT3P(dcp, ==, NULL);\n\t\t}\n\t\tif (drc->drc_heal) {\n\t\t\t \n\t\t\tVERIFY0(dsl_dataset_snap_lookup(ds, drc->drc_tosnap,\n\t\t\t    &dsobj));\n\t\t} else {\n\t\t\tdsobj = dsl_dataset_create_sync(ds->ds_dir,\n\t\t\t    recv_clone_name, snap, crflags, drba->drba_cred,\n\t\t\t    dcp, tx);\n\t\t}\n\t\tif (drba->drba_cookie->drc_fromsnapobj != 0)\n\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t} else {\n\t\tdsl_dir_t *dd;\n\t\tconst char *tail;\n\t\tdsl_dataset_t *origin = NULL;\n\n\t\tVERIFY0(dsl_dir_hold(dp, tofs, FTAG, &dd, &tail));\n\n\t\tif (drba->drba_origin != NULL) {\n\t\t\tVERIFY0(dsl_dataset_hold(dp, drba->drba_origin,\n\t\t\t    FTAG, &origin));\n\t\t\tASSERT3P(dcp, ==, NULL);\n\t\t}\n\n\t\t \n\t\tdsobj = dsl_dataset_create_sync(dd, strrchr(tofs, '/') + 1,\n\t\t    origin, crflags, drba->drba_cred, dcp, tx);\n\t\tif (origin != NULL)\n\t\t\tdsl_dataset_rele(origin, FTAG);\n\t\tdsl_dir_rele(dd, FTAG);\n\t\tdrc->drc_newfs = B_TRUE;\n\t}\n\tVERIFY0(dsl_dataset_own_obj_force(dp, dsobj, dsflags, dmu_recv_tag,\n\t    &newds));\n\tif (dsl_dataset_feature_is_active(newds,\n\t    SPA_FEATURE_REDACTED_DATASETS)) {\n\t\t \n\t\tdsl_dataset_deactivate_feature(newds,\n\t\t    SPA_FEATURE_REDACTED_DATASETS, tx);\n\t}\n\tVERIFY0(dmu_objset_from_ds(newds, &os));\n\n\tif (drc->drc_resumable) {\n\t\tdsl_dataset_zapify(newds, tx);\n\t\tif (drrb->drr_fromguid != 0) {\n\t\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_FROMGUID,\n\t\t\t    8, 1, &drrb->drr_fromguid, tx));\n\t\t}\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_TOGUID,\n\t\t    8, 1, &drrb->drr_toguid, tx));\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_TONAME,\n\t\t    1, strlen(drrb->drr_toname) + 1, drrb->drr_toname, tx));\n\t\tuint64_t one = 1;\n\t\tuint64_t zero = 0;\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_OBJECT,\n\t\t    8, 1, &one, tx));\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_OFFSET,\n\t\t    8, 1, &zero, tx));\n\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_BYTES,\n\t\t    8, 1, &zero, tx));\n\t\tif (featureflags & DMU_BACKUP_FEATURE_LARGE_BLOCKS) {\n\t\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_LARGEBLOCK,\n\t\t\t    8, 1, &one, tx));\n\t\t}\n\t\tif (featureflags & DMU_BACKUP_FEATURE_EMBED_DATA) {\n\t\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_EMBEDOK,\n\t\t\t    8, 1, &one, tx));\n\t\t}\n\t\tif (featureflags & DMU_BACKUP_FEATURE_COMPRESSED) {\n\t\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_COMPRESSOK,\n\t\t\t    8, 1, &one, tx));\n\t\t}\n\t\tif (featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\t\tVERIFY0(zap_add(mos, dsobj, DS_FIELD_RESUME_RAWOK,\n\t\t\t    8, 1, &one, tx));\n\t\t}\n\n\t\tuint64_t *redact_snaps;\n\t\tuint_t numredactsnaps;\n\t\tif (nvlist_lookup_uint64_array(drc->drc_begin_nvl,\n\t\t    BEGINNV_REDACT_FROM_SNAPS, &redact_snaps,\n\t\t    &numredactsnaps) == 0) {\n\t\t\tVERIFY0(zap_add(mos, dsobj,\n\t\t\t    DS_FIELD_RESUME_REDACT_BOOKMARK_SNAPS,\n\t\t\t    sizeof (*redact_snaps), numredactsnaps,\n\t\t\t    redact_snaps, tx));\n\t\t}\n\t}\n\n\t \n\tif (featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\tos->os_encrypted = B_TRUE;\n\t\tdrba->drba_cookie->drc_raw = B_TRUE;\n\t}\n\n\tif (featureflags & DMU_BACKUP_FEATURE_REDACTED) {\n\t\tuint64_t *redact_snaps;\n\t\tuint_t numredactsnaps;\n\t\tVERIFY0(nvlist_lookup_uint64_array(drc->drc_begin_nvl,\n\t\t    BEGINNV_REDACT_SNAPS, &redact_snaps, &numredactsnaps));\n\t\tdsl_dataset_activate_redaction(newds, redact_snaps,\n\t\t    numredactsnaps, tx);\n\t}\n\n\tdmu_buf_will_dirty(newds->ds_dbuf, tx);\n\tdsl_dataset_phys(newds)->ds_flags |= DS_FLAG_INCONSISTENT;\n\n\t \n\trrw_enter(&newds->ds_bp_rwlock, RW_READER, FTAG);\n\tif (BP_IS_HOLE(dsl_dataset_get_blkptr(newds)) &&\n\t    (featureflags & DMU_BACKUP_FEATURE_RAW) == 0 &&\n\t    !drc->drc_heal) {\n\t\t(void) dmu_objset_create_impl(dp->dp_spa,\n\t\t    newds, dsl_dataset_get_blkptr(newds), drrb->drr_type, tx);\n\t}\n\trrw_exit(&newds->ds_bp_rwlock, FTAG);\n\n\tdrba->drba_cookie->drc_ds = newds;\n\tdrba->drba_cookie->drc_os = os;\n\n\tspa_history_log_internal_ds(newds, \"receive\", tx, \" \");\n}\n\nstatic int\ndmu_recv_resume_begin_check(void *arg, dmu_tx_t *tx)\n{\n\tdmu_recv_begin_arg_t *drba = arg;\n\tdmu_recv_cookie_t *drc = drba->drba_cookie;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tstruct drr_begin *drrb = drc->drc_drrb;\n\tint error;\n\tds_hold_flags_t dsflags = DS_HOLD_FLAG_NONE;\n\tdsl_dataset_t *ds;\n\tconst char *tofs = drc->drc_tofs;\n\n\t \n\tASSERT3U(drrb->drr_magic, ==, DMU_BACKUP_MAGIC);\n\tASSERT(drc->drc_featureflags & DMU_BACKUP_FEATURE_RESUMING);\n\n\tif (DMU_GET_STREAM_HDRTYPE(drrb->drr_versioninfo) ==\n\t    DMU_COMPOUNDSTREAM ||\n\t    drrb->drr_type >= DMU_OST_NUMTYPES)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\terror = recv_begin_check_feature_flags_impl(drc->drc_featureflags,\n\t    dp->dp_spa);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tchar recvname[ZFS_MAX_DATASET_NAME_LEN + 6];\n\n\t(void) snprintf(recvname, sizeof (recvname), \"%s/%s\",\n\t    tofs, recv_clone_name);\n\n\tif (drc->drc_featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\t \n\t\tif (!(drrb->drr_flags & DRR_FLAG_SPILL_BLOCK))\n\t\t\treturn (SET_ERROR(ZFS_ERR_SPILL_BLOCK_FLAG_MISSING));\n\t} else {\n\t\tdsflags |= DS_HOLD_FLAG_DECRYPT;\n\t}\n\n\tboolean_t recvexist = B_TRUE;\n\tif (dsl_dataset_hold_flags(dp, recvname, dsflags, FTAG, &ds) != 0) {\n\t\t \n\t\trecvexist = B_FALSE;\n\t\terror = dsl_dataset_hold_flags(dp, tofs, dsflags, FTAG, &ds);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\t \n\tif (recvexist && drrb->drr_fromguid == 0 && !drc->drc_force) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(ZFS_ERR_RESUME_EXISTS));\n\t}\n\n\t \n\tif (!DS_IS_INCONSISTENT(ds)) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (!dsl_dataset_is_zapified(ds)) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tuint64_t val;\n\terror = zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_TOGUID, sizeof (val), 1, &val);\n\tif (error != 0 || drrb->drr_toguid != val) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (dsl_dataset_has_owner(ds)) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(EBUSY));\n\t}\n\n\t \n\tif (ds->ds_prev != NULL && ds->ds_prev->ds_dir == ds->ds_dir) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\n\t \n\tval = 0;\n\t(void) zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_RESUME_FROMGUID, sizeof (val), 1, &val);\n\tif (drrb->drr_fromguid != val) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (ds->ds_prev != NULL && drrb->drr_fromguid != 0)\n\t\tdrc->drc_fromsnapobj = ds->ds_prev->ds_object;\n\n\t \n\tif (drc->drc_featureflags & DMU_BACKUP_FEATURE_REDACTED) {\n\t\tuint64_t num_ds_redact_snaps;\n\t\tuint64_t *ds_redact_snaps;\n\n\t\tuint_t num_stream_redact_snaps;\n\t\tuint64_t *stream_redact_snaps;\n\n\t\tif (nvlist_lookup_uint64_array(drc->drc_begin_nvl,\n\t\t    BEGINNV_REDACT_SNAPS, &stream_redact_snaps,\n\t\t    &num_stream_redact_snaps) != 0) {\n\t\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tif (!dsl_dataset_get_uint64_array_feature(ds,\n\t\t    SPA_FEATURE_REDACTED_DATASETS, &num_ds_redact_snaps,\n\t\t    &ds_redact_snaps)) {\n\t\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tfor (int i = 0; i < num_ds_redact_snaps; i++) {\n\t\t\tif (!redact_snaps_contains(ds_redact_snaps,\n\t\t\t    num_ds_redact_snaps, stream_redact_snaps[i])) {\n\t\t\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\t\t}\n\t}\n\n\terror = recv_check_large_blocks(ds, drc->drc_featureflags);\n\tif (error != 0) {\n\t\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\t\treturn (error);\n\t}\n\n\tdsl_dataset_rele_flags(ds, dsflags, FTAG);\n\treturn (0);\n}\n\nstatic void\ndmu_recv_resume_begin_sync(void *arg, dmu_tx_t *tx)\n{\n\tdmu_recv_begin_arg_t *drba = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tconst char *tofs = drba->drba_cookie->drc_tofs;\n\tuint64_t featureflags = drba->drba_cookie->drc_featureflags;\n\tdsl_dataset_t *ds;\n\tds_hold_flags_t dsflags = DS_HOLD_FLAG_NONE;\n\t \n\tchar recvname[ZFS_MAX_DATASET_NAME_LEN + 6];\n\n\t(void) snprintf(recvname, sizeof (recvname), \"%s/%s\", tofs,\n\t    recv_clone_name);\n\n\tif (featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\tdrba->drba_cookie->drc_raw = B_TRUE;\n\t} else {\n\t\tdsflags |= DS_HOLD_FLAG_DECRYPT;\n\t}\n\n\tif (dsl_dataset_own_force(dp, recvname, dsflags, dmu_recv_tag, &ds)\n\t    != 0) {\n\t\t \n\t\tVERIFY0(dsl_dataset_own_force(dp, tofs, dsflags, dmu_recv_tag,\n\t\t    &ds));\n\t\tdrba->drba_cookie->drc_newfs = B_TRUE;\n\t}\n\n\tASSERT(DS_IS_INCONSISTENT(ds));\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tASSERT(!BP_IS_HOLE(dsl_dataset_get_blkptr(ds)) ||\n\t    drba->drba_cookie->drc_raw);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\n\tdrba->drba_cookie->drc_ds = ds;\n\tVERIFY0(dmu_objset_from_ds(ds, &drba->drba_cookie->drc_os));\n\tdrba->drba_cookie->drc_should_save = B_TRUE;\n\n\tspa_history_log_internal_ds(ds, \"resume receive\", tx, \" \");\n}\n\n \nint\ndmu_recv_begin(const char *tofs, const char *tosnap,\n    dmu_replay_record_t *drr_begin, boolean_t force, boolean_t heal,\n    boolean_t resumable, nvlist_t *localprops, nvlist_t *hidden_args,\n    const char *origin, dmu_recv_cookie_t *drc, zfs_file_t *fp,\n    offset_t *voffp)\n{\n\tdmu_recv_begin_arg_t drba = { 0 };\n\tint err = 0;\n\n\tmemset(drc, 0, sizeof (dmu_recv_cookie_t));\n\tdrc->drc_drr_begin = drr_begin;\n\tdrc->drc_drrb = &drr_begin->drr_u.drr_begin;\n\tdrc->drc_tosnap = tosnap;\n\tdrc->drc_tofs = tofs;\n\tdrc->drc_force = force;\n\tdrc->drc_heal = heal;\n\tdrc->drc_resumable = resumable;\n\tdrc->drc_cred = CRED();\n\tdrc->drc_proc = curproc;\n\tdrc->drc_clone = (origin != NULL);\n\n\tif (drc->drc_drrb->drr_magic == BSWAP_64(DMU_BACKUP_MAGIC)) {\n\t\tdrc->drc_byteswap = B_TRUE;\n\t\t(void) fletcher_4_incremental_byteswap(drr_begin,\n\t\t    sizeof (dmu_replay_record_t), &drc->drc_cksum);\n\t\tbyteswap_record(drr_begin);\n\t} else if (drc->drc_drrb->drr_magic == DMU_BACKUP_MAGIC) {\n\t\t(void) fletcher_4_incremental_native(drr_begin,\n\t\t    sizeof (dmu_replay_record_t), &drc->drc_cksum);\n\t} else {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tdrc->drc_fp = fp;\n\tdrc->drc_voff = *voffp;\n\tdrc->drc_featureflags =\n\t    DMU_GET_FEATUREFLAGS(drc->drc_drrb->drr_versioninfo);\n\n\tuint32_t payloadlen = drc->drc_drr_begin->drr_payloadlen;\n\n\t \n\tif (payloadlen > (MIN((1U << 28), arc_all_memory() / 4)))\n\t\treturn (E2BIG);\n\n\n\tif (payloadlen != 0) {\n\t\tvoid *payload = vmem_alloc(payloadlen, KM_SLEEP);\n\t\t \n\n\t\terr = receive_read_payload_and_next_header(drc, payloadlen,\n\t\t    payload);\n\t\tif (err != 0) {\n\t\t\tvmem_free(payload, payloadlen);\n\t\t\treturn (err);\n\t\t}\n\t\terr = nvlist_unpack(payload, payloadlen, &drc->drc_begin_nvl,\n\t\t    KM_SLEEP);\n\t\tvmem_free(payload, payloadlen);\n\t\tif (err != 0) {\n\t\t\tkmem_free(drc->drc_next_rrd,\n\t\t\t    sizeof (*drc->drc_next_rrd));\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\tif (drc->drc_drrb->drr_flags & DRR_FLAG_SPILL_BLOCK)\n\t\tdrc->drc_spill = B_TRUE;\n\n\tdrba.drba_origin = origin;\n\tdrba.drba_cookie = drc;\n\tdrba.drba_cred = CRED();\n\tdrba.drba_proc = curproc;\n\n\tif (drc->drc_featureflags & DMU_BACKUP_FEATURE_RESUMING) {\n\t\terr = dsl_sync_task(tofs,\n\t\t    dmu_recv_resume_begin_check, dmu_recv_resume_begin_sync,\n\t\t    &drba, 5, ZFS_SPACE_CHECK_NORMAL);\n\t} else {\n\t\t \n\t\tif ((DMU_GET_FEATUREFLAGS(drc->drc_drrb->drr_versioninfo) &\n\t\t    DMU_BACKUP_FEATURE_RAW) == 0 &&\n\t\t    origin == NULL && drc->drc_drrb->drr_fromguid == 0) {\n\t\t\terr = dsl_crypto_params_create_nvlist(DCP_CMD_NONE,\n\t\t\t    localprops, hidden_args, &drba.drba_dcp);\n\t\t}\n\n\t\tif (err == 0) {\n\t\t\terr = dsl_sync_task(tofs,\n\t\t\t    dmu_recv_begin_check, dmu_recv_begin_sync,\n\t\t\t    &drba, 5, ZFS_SPACE_CHECK_NORMAL);\n\t\t\tdsl_crypto_params_free(drba.drba_dcp, !!err);\n\t\t}\n\t}\n\n\tif (err != 0) {\n\t\tkmem_free(drc->drc_next_rrd, sizeof (*drc->drc_next_rrd));\n\t\tnvlist_free(drc->drc_begin_nvl);\n\t}\n\treturn (err);\n}\n\n \ntypedef struct cr_cb_data {\n\tuint64_t size;\n\tzbookmark_phys_t zb;\n\tspa_t *spa;\n} cr_cb_data_t;\n\nstatic void\ncorrective_read_done(zio_t *zio)\n{\n\tcr_cb_data_t *data = zio->io_private;\n\t \n\tif (zio->io_error == 0)\n\t\tspa_remove_error(data->spa, &data->zb, &zio->io_bp->blk_birth);\n\tkmem_free(data, sizeof (cr_cb_data_t));\n\tabd_free(zio->io_abd);\n}\n\n \nstatic int\ndo_corrective_recv(struct receive_writer_arg *rwa, struct drr_write *drrw,\n    struct receive_record_arg *rrd, blkptr_t *bp)\n{\n\tint err;\n\tzio_t *io;\n\tzbookmark_phys_t zb;\n\tdnode_t *dn;\n\tabd_t *abd = rrd->abd;\n\tzio_cksum_t bp_cksum = bp->blk_cksum;\n\tzio_flag_t flags = ZIO_FLAG_SPECULATIVE | ZIO_FLAG_DONT_RETRY |\n\t    ZIO_FLAG_CANFAIL;\n\n\tif (rwa->raw)\n\t\tflags |= ZIO_FLAG_RAW;\n\n\terr = dnode_hold(rwa->os, drrw->drr_object, FTAG, &dn);\n\tif (err != 0)\n\t\treturn (err);\n\tSET_BOOKMARK(&zb, dmu_objset_id(rwa->os), drrw->drr_object, 0,\n\t    dbuf_whichblock(dn, 0, drrw->drr_offset));\n\tdnode_rele(dn, FTAG);\n\n\tif (!rwa->raw && DRR_WRITE_COMPRESSED(drrw)) {\n\t\t \n\t\tabd_t *dabd = abd_alloc_linear(\n\t\t    drrw->drr_logical_size, B_FALSE);\n\t\terr = zio_decompress_data(drrw->drr_compressiontype,\n\t\t    abd, abd_to_buf(dabd), abd_get_size(abd),\n\t\t    abd_get_size(dabd), NULL);\n\n\t\tif (err != 0) {\n\t\t\tabd_free(dabd);\n\t\t\treturn (err);\n\t\t}\n\t\t \n\t\tabd_free(abd);\n\t\tabd = dabd;\n\t}\n\n\tif (!rwa->raw && BP_GET_COMPRESS(bp) != ZIO_COMPRESS_OFF) {\n\t\t \n\t\tabd_t *cabd = abd_alloc_linear(BP_GET_PSIZE(bp),\n\t\t    B_FALSE);\n\t\tvoid *buf = abd_to_buf(cabd);\n\t\tuint64_t csize = zio_compress_data(BP_GET_COMPRESS(bp),\n\t\t    abd, &buf, abd_get_size(abd),\n\t\t    rwa->os->os_complevel);\n\t\tabd_zero_off(cabd, csize, BP_GET_PSIZE(bp) - csize);\n\t\t \n\t\tabd_free(abd);\n\t\tabd = cabd;\n\t\tflags |= ZIO_FLAG_RAW_COMPRESS;\n\t}\n\n\t \n\tif (!rwa->raw && BP_USES_CRYPT(bp)) {\n\t\tdsl_dataset_t *ds;\n\t\tdsl_crypto_key_t *dck = NULL;\n\t\tuint8_t salt[ZIO_DATA_SALT_LEN];\n\t\tuint8_t iv[ZIO_DATA_IV_LEN];\n\t\tuint8_t mac[ZIO_DATA_MAC_LEN];\n\t\tboolean_t no_crypt = B_FALSE;\n\t\tdsl_pool_t *dp = dmu_objset_pool(rwa->os);\n\t\tabd_t *eabd = abd_alloc_linear(BP_GET_PSIZE(bp), B_FALSE);\n\n\t\tzio_crypt_decode_params_bp(bp, salt, iv);\n\t\tzio_crypt_decode_mac_bp(bp, mac);\n\n\t\tdsl_pool_config_enter(dp, FTAG);\n\t\terr = dsl_dataset_hold_flags(dp, rwa->tofs,\n\t\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds);\n\t\tif (err != 0) {\n\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\tabd_free(eabd);\n\t\t\treturn (SET_ERROR(EACCES));\n\t\t}\n\n\t\t \n\t\terr = spa_keystore_lookup_key(rwa->os->os_spa,\n\t\t    zb.zb_objset, FTAG, &dck);\n\t\tif (err != 0) {\n\t\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT,\n\t\t\t    FTAG);\n\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\tabd_free(eabd);\n\t\t\treturn (SET_ERROR(EACCES));\n\t\t}\n\n\t\terr = zio_do_crypt_abd(B_TRUE, &dck->dck_key,\n\t\t    BP_GET_TYPE(bp), BP_SHOULD_BYTESWAP(bp), salt, iv,\n\t\t    mac, abd_get_size(abd), abd, eabd, &no_crypt);\n\n\t\tspa_keystore_dsl_key_rele(rwa->os->os_spa, dck, FTAG);\n\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\tdsl_pool_config_exit(dp, FTAG);\n\n\t\tASSERT0(no_crypt);\n\t\tif (err != 0) {\n\t\t\tabd_free(eabd);\n\t\t\treturn (err);\n\t\t}\n\t\t \n\t\tabd_free(abd);\n\t\tabd = eabd;\n\n\t\t \n\t\tflags |= ZIO_FLAG_RAW_ENCRYPT;\n\t}\n\trrd->abd = abd;\n\n\tio = zio_rewrite(NULL, rwa->os->os_spa, bp->blk_birth, bp, abd,\n\t    BP_GET_PSIZE(bp), NULL, NULL, ZIO_PRIORITY_SYNC_WRITE, flags, &zb);\n\n\tASSERT(abd_get_size(abd) == BP_GET_LSIZE(bp) ||\n\t    abd_get_size(abd) == BP_GET_PSIZE(bp));\n\n\t \n\tzio_checksum_compute(io, BP_GET_CHECKSUM(bp), abd, abd_get_size(abd));\n\tif (!ZIO_CHECKSUM_EQUAL(bp_cksum, io->io_bp->blk_cksum)) {\n\t\tzio_destroy(io);\n\t\tif (zfs_recv_best_effort_corrective != 0)\n\t\t\treturn (0);\n\t\treturn (SET_ERROR(ECKSUM));\n\t}\n\n\t \n\terr = zio_wait(io);\n\tif (err == 0) {\n\t\tcr_cb_data_t *cb_data =\n\t\t    kmem_alloc(sizeof (cr_cb_data_t), KM_SLEEP);\n\t\tcb_data->spa = rwa->os->os_spa;\n\t\tcb_data->size = drrw->drr_logical_size;\n\t\tcb_data->zb = zb;\n\t\t \n\t\terr = zio_wait(zio_read(rwa->heal_pio, rwa->os->os_spa, bp,\n\t\t    abd_alloc_for_io(drrw->drr_logical_size, B_FALSE),\n\t\t    drrw->drr_logical_size, corrective_read_done,\n\t\t    cb_data, ZIO_PRIORITY_ASYNC_READ, flags, NULL));\n\t}\n\tif (err != 0 && zfs_recv_best_effort_corrective != 0)\n\t\terr = 0;\n\n\treturn (err);\n}\n\nstatic int\nreceive_read(dmu_recv_cookie_t *drc, int len, void *buf)\n{\n\tint done = 0;\n\n\t \n\tASSERT(len % 8 == 0 ||\n\t    (drc->drc_featureflags & DMU_BACKUP_FEATURE_RAW) != 0);\n\n\twhile (done < len) {\n\t\tssize_t resid = len - done;\n\t\tzfs_file_t *fp = drc->drc_fp;\n\t\tint err = zfs_file_read(fp, (char *)buf + done,\n\t\t    len - done, &resid);\n\t\tif (err == 0 && resid == len - done) {\n\t\t\t \n\t\t\terr = SET_ERROR(ZFS_ERR_STREAM_TRUNCATED);\n\t\t}\n\t\tdrc->drc_voff += len - done - resid;\n\t\tdone = len - resid;\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\tdrc->drc_bytes_read += len;\n\n\tASSERT3U(done, ==, len);\n\treturn (0);\n}\n\nstatic inline uint8_t\ndeduce_nblkptr(dmu_object_type_t bonus_type, uint64_t bonus_size)\n{\n\tif (bonus_type == DMU_OT_SA) {\n\t\treturn (1);\n\t} else {\n\t\treturn (1 +\n\t\t    ((DN_OLD_MAX_BONUSLEN -\n\t\t    MIN(DN_OLD_MAX_BONUSLEN, bonus_size)) >> SPA_BLKPTRSHIFT));\n\t}\n}\n\nstatic void\nsave_resume_state(struct receive_writer_arg *rwa,\n    uint64_t object, uint64_t offset, dmu_tx_t *tx)\n{\n\tint txgoff = dmu_tx_get_txg(tx) & TXG_MASK;\n\n\tif (!rwa->resumable)\n\t\treturn;\n\n\t \n\tASSERT(rwa->bytes_read != 0);\n\n\t \n\tASSERT(object != 0);\n\n\t \n\tASSERT3U(object, >=, rwa->os->os_dsl_dataset->ds_resume_object[txgoff]);\n\tASSERT(object != rwa->os->os_dsl_dataset->ds_resume_object[txgoff] ||\n\t    offset >= rwa->os->os_dsl_dataset->ds_resume_offset[txgoff]);\n\tASSERT3U(rwa->bytes_read, >=,\n\t    rwa->os->os_dsl_dataset->ds_resume_bytes[txgoff]);\n\n\trwa->os->os_dsl_dataset->ds_resume_object[txgoff] = object;\n\trwa->os->os_dsl_dataset->ds_resume_offset[txgoff] = offset;\n\trwa->os->os_dsl_dataset->ds_resume_bytes[txgoff] = rwa->bytes_read;\n}\n\nstatic int\nreceive_object_is_same_generation(objset_t *os, uint64_t object,\n    dmu_object_type_t old_bonus_type, dmu_object_type_t new_bonus_type,\n    const void *new_bonus, boolean_t *samegenp)\n{\n\tzfs_file_info_t zoi;\n\tint err;\n\n\tdmu_buf_t *old_bonus_dbuf;\n\terr = dmu_bonus_hold(os, object, FTAG, &old_bonus_dbuf);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dmu_get_file_info(os, old_bonus_type, old_bonus_dbuf->db_data,\n\t    &zoi);\n\tdmu_buf_rele(old_bonus_dbuf, FTAG);\n\tif (err != 0)\n\t\treturn (err);\n\tuint64_t old_gen = zoi.zfi_generation;\n\n\terr = dmu_get_file_info(os, new_bonus_type, new_bonus, &zoi);\n\tif (err != 0)\n\t\treturn (err);\n\tuint64_t new_gen = zoi.zfi_generation;\n\n\t*samegenp = (old_gen == new_gen);\n\treturn (0);\n}\n\nstatic int\nreceive_handle_existing_object(const struct receive_writer_arg *rwa,\n    const struct drr_object *drro, const dmu_object_info_t *doi,\n    const void *bonus_data,\n    uint64_t *object_to_hold, uint32_t *new_blksz)\n{\n\tuint32_t indblksz = drro->drr_indblkshift ?\n\t    1ULL << drro->drr_indblkshift : 0;\n\tint nblkptr = deduce_nblkptr(drro->drr_bonustype,\n\t    drro->drr_bonuslen);\n\tuint8_t dn_slots = drro->drr_dn_slots != 0 ?\n\t    drro->drr_dn_slots : DNODE_MIN_SLOTS;\n\tboolean_t do_free_range = B_FALSE;\n\tint err;\n\n\t*object_to_hold = drro->drr_object;\n\n\t \n\tif (rwa->raw && nblkptr != drro->drr_nblkptr)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (drro->drr_blksz != doi->doi_data_block_size) {\n\t\tif (rwa->raw) {\n\t\t\t \n\t\t\tdo_free_range = B_TRUE;\n\t\t} else if (rwa->full) {\n\t\t\t \n\t\t\tdo_free_range = B_TRUE;\n\t\t} else if (drro->drr_type !=\n\t\t    DMU_OT_PLAIN_FILE_CONTENTS ||\n\t\t    doi->doi_type != DMU_OT_PLAIN_FILE_CONTENTS) {\n\t\t\t \n\t\t\tdo_free_range = B_TRUE;\n\t\t} else if (doi->doi_max_offset <=\n\t\t    doi->doi_data_block_size) {\n\t\t\t \n\t\t\tdo_free_range = B_TRUE;\n\t\t} else {\n\t\t\tboolean_t is_same_gen;\n\t\t\terr = receive_object_is_same_generation(rwa->os,\n\t\t\t    drro->drr_object, doi->doi_bonus_type,\n\t\t\t    drro->drr_bonustype, bonus_data, &is_same_gen);\n\t\t\tif (err != 0)\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t\tif (is_same_gen) {\n\t\t\t\t \n\t\t\t\tif (drro->drr_blksz <=\n\t\t\t\t    doi->doi_data_block_size)\n\t\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t\t \n\t\t\t\t*new_blksz =\n\t\t\t\t    doi->doi_data_block_size;\n\t\t\t} else {\n\t\t\t\tdo_free_range = B_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (nblkptr < doi->doi_nblkptr)\n\t\tdo_free_range = B_TRUE;\n\n\t \n\tif (dn_slots != doi->doi_dnodesize >> DNODE_SHIFT)\n\t\tdo_free_range = B_TRUE;\n\n\t \n\tif (rwa->raw) {\n\t\tif (indblksz != doi->doi_metadata_block_size)\n\t\t\tdo_free_range = B_TRUE;\n\t\tif (drro->drr_nlevels < doi->doi_indirection)\n\t\t\tdo_free_range = B_TRUE;\n\t}\n\n\tif (do_free_range) {\n\t\terr = dmu_free_long_range(rwa->os, drro->drr_object,\n\t\t    0, DMU_OBJECT_END);\n\t\tif (err != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif ((rwa->raw && ((doi->doi_indirection > 1 &&\n\t    indblksz != doi->doi_metadata_block_size) ||\n\t    drro->drr_nlevels < doi->doi_indirection)) ||\n\t    dn_slots != doi->doi_dnodesize >> DNODE_SHIFT) {\n\t\terr = dmu_free_long_object(rwa->os, drro->drr_object);\n\t\tif (err != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\ttxg_wait_synced(dmu_objset_pool(rwa->os), 0);\n\t\t*object_to_hold = DMU_NEW_OBJECT;\n\t}\n\n\t \n\tif (rwa->raw && *object_to_hold != DMU_NEW_OBJECT && !do_free_range) {\n\t\terr = dmu_free_long_range(rwa->os, drro->drr_object,\n\t\t    (drro->drr_maxblkid + 1) * doi->doi_data_block_size,\n\t\t    DMU_OBJECT_END);\n\t\tif (err != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\treturn (0);\n}\n\nnoinline static int\nreceive_object(struct receive_writer_arg *rwa, struct drr_object *drro,\n    void *data)\n{\n\tdmu_object_info_t doi;\n\tdmu_tx_t *tx;\n\tint err;\n\tuint32_t new_blksz = drro->drr_blksz;\n\tuint8_t dn_slots = drro->drr_dn_slots != 0 ?\n\t    drro->drr_dn_slots : DNODE_MIN_SLOTS;\n\n\tif (drro->drr_type == DMU_OT_NONE ||\n\t    !DMU_OT_IS_VALID(drro->drr_type) ||\n\t    !DMU_OT_IS_VALID(drro->drr_bonustype) ||\n\t    drro->drr_checksumtype >= ZIO_CHECKSUM_FUNCTIONS ||\n\t    drro->drr_compress >= ZIO_COMPRESS_FUNCTIONS ||\n\t    P2PHASE(drro->drr_blksz, SPA_MINBLOCKSIZE) ||\n\t    drro->drr_blksz < SPA_MINBLOCKSIZE ||\n\t    drro->drr_blksz > spa_maxblocksize(dmu_objset_spa(rwa->os)) ||\n\t    drro->drr_bonuslen >\n\t    DN_BONUS_SIZE(spa_maxdnodesize(dmu_objset_spa(rwa->os))) ||\n\t    dn_slots >\n\t    (spa_maxdnodesize(dmu_objset_spa(rwa->os)) >> DNODE_SHIFT)) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (rwa->raw) {\n\t\t \n\t\tif (drro->drr_object < rwa->or_firstobj ||\n\t\t    drro->drr_object >= rwa->or_firstobj + rwa->or_numslots ||\n\t\t    drro->drr_raw_bonuslen < drro->drr_bonuslen ||\n\t\t    drro->drr_indblkshift > SPA_MAXBLOCKSHIFT ||\n\t\t    drro->drr_nlevels > DN_MAX_LEVELS ||\n\t\t    drro->drr_nblkptr > DN_MAX_NBLKPTR ||\n\t\t    DN_SLOTS_TO_BONUSLEN(dn_slots) <\n\t\t    drro->drr_raw_bonuslen)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t} else {\n\t\t \n\t\tif (((drro->drr_flags & ~(DRR_OBJECT_SPILL))) ||\n\t\t    (!rwa->spill && DRR_OBJECT_HAS_SPILL(drro->drr_flags))) {\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tif (drro->drr_raw_bonuslen != 0 || drro->drr_nblkptr != 0 ||\n\t\t    drro->drr_indblkshift != 0 || drro->drr_nlevels != 0) {\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t}\n\n\terr = dmu_object_info(rwa->os, drro->drr_object, &doi);\n\n\tif (err != 0 && err != ENOENT && err != EEXIST)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drro->drr_object > rwa->max_object)\n\t\trwa->max_object = drro->drr_object;\n\n\t \n\tuint64_t object_to_hold;\n\tif (err == 0) {\n\t\terr = receive_handle_existing_object(rwa, drro, &doi, data,\n\t\t    &object_to_hold, &new_blksz);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t} else if (err == EEXIST) {\n\t\t \n\t\ttxg_wait_synced(dmu_objset_pool(rwa->os), 0);\n\n\t\tif (dmu_object_info(rwa->os, drro->drr_object, NULL) != ENOENT)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tobject_to_hold = DMU_NEW_OBJECT;\n\t} else {\n\t\t \n\t\tif (rwa->or_need_sync == ORNS_YES)\n\t\t\ttxg_wait_synced(dmu_objset_pool(rwa->os), 0);\n\n\t\t \n\t\tobject_to_hold = DMU_NEW_OBJECT;\n\t}\n\n\t \n\trwa->or_need_sync = ORNS_NO;\n\n\t \n\tif (dn_slots > 1) {\n\t\tboolean_t need_sync = B_FALSE;\n\n\t\tfor (uint64_t slot = drro->drr_object + 1;\n\t\t    slot < drro->drr_object + dn_slots;\n\t\t    slot++) {\n\t\t\tdmu_object_info_t slot_doi;\n\n\t\t\terr = dmu_object_info(rwa->os, slot, &slot_doi);\n\t\t\tif (err == ENOENT || err == EEXIST)\n\t\t\t\tcontinue;\n\t\t\telse if (err != 0)\n\t\t\t\treturn (err);\n\n\t\t\terr = dmu_free_long_object(rwa->os, slot);\n\t\t\tif (err != 0)\n\t\t\t\treturn (err);\n\n\t\t\tneed_sync = B_TRUE;\n\t\t}\n\n\t\tif (need_sync)\n\t\t\ttxg_wait_synced(dmu_objset_pool(rwa->os), 0);\n\t}\n\n\ttx = dmu_tx_create(rwa->os);\n\tdmu_tx_hold_bonus(tx, object_to_hold);\n\tdmu_tx_hold_write(tx, object_to_hold, 0, 0);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err != 0) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (err);\n\t}\n\n\tif (object_to_hold == DMU_NEW_OBJECT) {\n\t\t \n\t\terr = dmu_object_claim_dnsize(rwa->os, drro->drr_object,\n\t\t    drro->drr_type, new_blksz,\n\t\t    drro->drr_bonustype, drro->drr_bonuslen,\n\t\t    dn_slots << DNODE_SHIFT, tx);\n\t} else if (drro->drr_type != doi.doi_type ||\n\t    new_blksz != doi.doi_data_block_size ||\n\t    drro->drr_bonustype != doi.doi_bonus_type ||\n\t    drro->drr_bonuslen != doi.doi_bonus_size) {\n\t\t \n\t\terr = dmu_object_reclaim_dnsize(rwa->os, drro->drr_object,\n\t\t    drro->drr_type, new_blksz,\n\t\t    drro->drr_bonustype, drro->drr_bonuslen,\n\t\t    dn_slots << DNODE_SHIFT, rwa->spill ?\n\t\t    DRR_OBJECT_HAS_SPILL(drro->drr_flags) : B_FALSE, tx);\n\t} else if (rwa->spill && !DRR_OBJECT_HAS_SPILL(drro->drr_flags)) {\n\t\t \n\t\terr = dmu_object_rm_spill(rwa->os, drro->drr_object, tx);\n\t}\n\n\tif (err != 0) {\n\t\tdmu_tx_commit(tx);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (rwa->or_crypt_params_present) {\n\t\t \n\t\tdmu_buf_t *db = NULL;\n\t\tuint64_t offset = rwa->or_firstobj * DNODE_MIN_SIZE;\n\n\t\terr = dmu_buf_hold_by_dnode(DMU_META_DNODE(rwa->os),\n\t\t    offset, FTAG, &db, DMU_READ_PREFETCH | DMU_READ_NO_DECRYPT);\n\t\tif (err != 0) {\n\t\t\tdmu_tx_commit(tx);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tdmu_buf_set_crypt_params(db, rwa->or_byteorder,\n\t\t    rwa->or_salt, rwa->or_iv, rwa->or_mac, tx);\n\n\t\tdmu_buf_rele(db, FTAG);\n\n\t\trwa->or_crypt_params_present = B_FALSE;\n\t}\n\n\tdmu_object_set_checksum(rwa->os, drro->drr_object,\n\t    drro->drr_checksumtype, tx);\n\tdmu_object_set_compress(rwa->os, drro->drr_object,\n\t    drro->drr_compress, tx);\n\n\t \n\tif (rwa->raw) {\n\t\t \n\t\tASSERT3U(new_blksz, ==, drro->drr_blksz);\n\t\tVERIFY0(dmu_object_set_blocksize(rwa->os, drro->drr_object,\n\t\t    drro->drr_blksz, drro->drr_indblkshift, tx));\n\t\tVERIFY0(dmu_object_set_nlevels(rwa->os, drro->drr_object,\n\t\t    drro->drr_nlevels, tx));\n\n\t\t \n\t\tVERIFY0(dmu_object_set_maxblkid(rwa->os, drro->drr_object,\n\t\t    drro->drr_maxblkid, tx));\n\t}\n\n\tif (data != NULL) {\n\t\tdmu_buf_t *db;\n\t\tdnode_t *dn;\n\t\tuint32_t flags = DMU_READ_NO_PREFETCH;\n\n\t\tif (rwa->raw)\n\t\t\tflags |= DMU_READ_NO_DECRYPT;\n\n\t\tVERIFY0(dnode_hold(rwa->os, drro->drr_object, FTAG, &dn));\n\t\tVERIFY0(dmu_bonus_hold_by_dnode(dn, FTAG, &db, flags));\n\n\t\tdmu_buf_will_dirty(db, tx);\n\n\t\tASSERT3U(db->db_size, >=, drro->drr_bonuslen);\n\t\tmemcpy(db->db_data, data, DRR_OBJECT_PAYLOAD_SIZE(drro));\n\n\t\t \n\t\tif (rwa->byteswap && !rwa->raw) {\n\t\t\tdmu_object_byteswap_t byteswap =\n\t\t\t    DMU_OT_BYTESWAP(drro->drr_bonustype);\n\t\t\tdmu_ot_byteswap[byteswap].ob_func(db->db_data,\n\t\t\t    DRR_OBJECT_PAYLOAD_SIZE(drro));\n\t\t}\n\t\tdmu_buf_rele(db, FTAG);\n\t\tdnode_rele(dn, FTAG);\n\t}\n\tdmu_tx_commit(tx);\n\n\treturn (0);\n}\n\nnoinline static int\nreceive_freeobjects(struct receive_writer_arg *rwa,\n    struct drr_freeobjects *drrfo)\n{\n\tuint64_t obj;\n\tint next_err = 0;\n\n\tif (drrfo->drr_firstobj + drrfo->drr_numobjs < drrfo->drr_firstobj)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tfor (obj = drrfo->drr_firstobj == 0 ? 1 : drrfo->drr_firstobj;\n\t    obj < drrfo->drr_firstobj + drrfo->drr_numobjs &&\n\t    obj < DN_MAX_OBJECT && next_err == 0;\n\t    next_err = dmu_object_next(rwa->os, &obj, FALSE, 0)) {\n\t\tdmu_object_info_t doi;\n\t\tint err;\n\n\t\terr = dmu_object_info(rwa->os, obj, &doi);\n\t\tif (err == ENOENT)\n\t\t\tcontinue;\n\t\telse if (err != 0)\n\t\t\treturn (err);\n\n\t\terr = dmu_free_long_object(rwa->os, obj);\n\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tif (rwa->or_need_sync == ORNS_MAYBE)\n\t\t\trwa->or_need_sync = ORNS_YES;\n\t}\n\tif (next_err != ESRCH)\n\t\treturn (next_err);\n\treturn (0);\n}\n\n \nstatic int\nflush_write_batch_impl(struct receive_writer_arg *rwa)\n{\n\tdnode_t *dn;\n\tint err;\n\n\tif (dnode_hold(rwa->os, rwa->last_object, FTAG, &dn) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tstruct receive_record_arg *last_rrd = list_tail(&rwa->write_batch);\n\tstruct drr_write *last_drrw = &last_rrd->header.drr_u.drr_write;\n\n\tstruct receive_record_arg *first_rrd = list_head(&rwa->write_batch);\n\tstruct drr_write *first_drrw = &first_rrd->header.drr_u.drr_write;\n\n\tASSERT3U(rwa->last_object, ==, last_drrw->drr_object);\n\tASSERT3U(rwa->last_offset, ==, last_drrw->drr_offset);\n\n\tdmu_tx_t *tx = dmu_tx_create(rwa->os);\n\tdmu_tx_hold_write_by_dnode(tx, dn, first_drrw->drr_offset,\n\t    last_drrw->drr_offset - first_drrw->drr_offset +\n\t    last_drrw->drr_logical_size);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err != 0) {\n\t\tdmu_tx_abort(tx);\n\t\tdnode_rele(dn, FTAG);\n\t\treturn (err);\n\t}\n\n\tstruct receive_record_arg *rrd;\n\twhile ((rrd = list_head(&rwa->write_batch)) != NULL) {\n\t\tstruct drr_write *drrw = &rrd->header.drr_u.drr_write;\n\t\tabd_t *abd = rrd->abd;\n\n\t\tASSERT3U(drrw->drr_object, ==, rwa->last_object);\n\n\t\tif (drrw->drr_logical_size != dn->dn_datablksz) {\n\t\t\t \n\t\t\tASSERT3U(drrw->drr_logical_size, >, dn->dn_datablksz);\n\t\t\tif (DRR_WRITE_COMPRESSED(drrw)) {\n\t\t\t\tabd_t *decomp_abd =\n\t\t\t\t    abd_alloc_linear(drrw->drr_logical_size,\n\t\t\t\t    B_FALSE);\n\n\t\t\t\terr = zio_decompress_data(\n\t\t\t\t    drrw->drr_compressiontype,\n\t\t\t\t    abd, abd_to_buf(decomp_abd),\n\t\t\t\t    abd_get_size(abd),\n\t\t\t\t    abd_get_size(decomp_abd), NULL);\n\n\t\t\t\tif (err == 0) {\n\t\t\t\t\tdmu_write_by_dnode(dn,\n\t\t\t\t\t    drrw->drr_offset,\n\t\t\t\t\t    drrw->drr_logical_size,\n\t\t\t\t\t    abd_to_buf(decomp_abd), tx);\n\t\t\t\t}\n\t\t\t\tabd_free(decomp_abd);\n\t\t\t} else {\n\t\t\t\tdmu_write_by_dnode(dn,\n\t\t\t\t    drrw->drr_offset,\n\t\t\t\t    drrw->drr_logical_size,\n\t\t\t\t    abd_to_buf(abd), tx);\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\tabd_free(abd);\n\t\t} else {\n\t\t\tzio_prop_t zp = {0};\n\t\t\tdmu_write_policy(rwa->os, dn, 0, 0, &zp);\n\n\t\t\tzio_flag_t zio_flags = 0;\n\n\t\t\tif (rwa->raw) {\n\t\t\t\tzp.zp_encrypt = B_TRUE;\n\t\t\t\tzp.zp_compress = drrw->drr_compressiontype;\n\t\t\t\tzp.zp_byteorder = ZFS_HOST_BYTEORDER ^\n\t\t\t\t    !!DRR_IS_RAW_BYTESWAPPED(drrw->drr_flags) ^\n\t\t\t\t    rwa->byteswap;\n\t\t\t\tmemcpy(zp.zp_salt, drrw->drr_salt,\n\t\t\t\t    ZIO_DATA_SALT_LEN);\n\t\t\t\tmemcpy(zp.zp_iv, drrw->drr_iv,\n\t\t\t\t    ZIO_DATA_IV_LEN);\n\t\t\t\tmemcpy(zp.zp_mac, drrw->drr_mac,\n\t\t\t\t    ZIO_DATA_MAC_LEN);\n\t\t\t\tif (DMU_OT_IS_ENCRYPTED(zp.zp_type)) {\n\t\t\t\t\tzp.zp_nopwrite = B_FALSE;\n\t\t\t\t\tzp.zp_copies = MIN(zp.zp_copies,\n\t\t\t\t\t    SPA_DVAS_PER_BP - 1);\n\t\t\t\t}\n\t\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\t\t\t} else if (DRR_WRITE_COMPRESSED(drrw)) {\n\t\t\t\tASSERT3U(drrw->drr_compressed_size, >, 0);\n\t\t\t\tASSERT3U(drrw->drr_logical_size, >=,\n\t\t\t\t    drrw->drr_compressed_size);\n\t\t\t\tzp.zp_compress = drrw->drr_compressiontype;\n\t\t\t\tzio_flags |= ZIO_FLAG_RAW_COMPRESS;\n\t\t\t} else if (rwa->byteswap) {\n\t\t\t\t \n\t\t\t\tdmu_object_byteswap_t byteswap =\n\t\t\t\t    DMU_OT_BYTESWAP(drrw->drr_type);\n\t\t\t\tdmu_ot_byteswap[byteswap].ob_func(\n\t\t\t\t    abd_to_buf(abd),\n\t\t\t\t    DRR_WRITE_PAYLOAD_SIZE(drrw));\n\t\t\t}\n\n\t\t\t \n\t\t\terr = dmu_lightweight_write_by_dnode(dn,\n\t\t\t    drrw->drr_offset, abd, &zp, zio_flags, tx);\n\t\t}\n\n\t\tif (err != 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsave_resume_state(rwa, drrw->drr_object, drrw->drr_offset, tx);\n\n\t\tlist_remove(&rwa->write_batch, rrd);\n\t\tkmem_free(rrd, sizeof (*rrd));\n\t}\n\n\tdmu_tx_commit(tx);\n\tdnode_rele(dn, FTAG);\n\treturn (err);\n}\n\nnoinline static int\nflush_write_batch(struct receive_writer_arg *rwa)\n{\n\tif (list_is_empty(&rwa->write_batch))\n\t\treturn (0);\n\tint err = rwa->err;\n\tif (err == 0)\n\t\terr = flush_write_batch_impl(rwa);\n\tif (err != 0) {\n\t\tstruct receive_record_arg *rrd;\n\t\twhile ((rrd = list_remove_head(&rwa->write_batch)) != NULL) {\n\t\t\tabd_free(rrd->abd);\n\t\t\tkmem_free(rrd, sizeof (*rrd));\n\t\t}\n\t}\n\tASSERT(list_is_empty(&rwa->write_batch));\n\treturn (err);\n}\n\nnoinline static int\nreceive_process_write_record(struct receive_writer_arg *rwa,\n    struct receive_record_arg *rrd)\n{\n\tint err = 0;\n\n\tASSERT3U(rrd->header.drr_type, ==, DRR_WRITE);\n\tstruct drr_write *drrw = &rrd->header.drr_u.drr_write;\n\n\tif (drrw->drr_offset + drrw->drr_logical_size < drrw->drr_offset ||\n\t    !DMU_OT_IS_VALID(drrw->drr_type))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (rwa->heal) {\n\t\tblkptr_t *bp;\n\t\tdmu_buf_t *dbp;\n\t\tdnode_t *dn;\n\t\tint flags = DB_RF_CANFAIL;\n\n\t\tif (rwa->raw)\n\t\t\tflags |= DB_RF_NO_DECRYPT;\n\n\t\tif (rwa->byteswap) {\n\t\t\tdmu_object_byteswap_t byteswap =\n\t\t\t    DMU_OT_BYTESWAP(drrw->drr_type);\n\t\t\tdmu_ot_byteswap[byteswap].ob_func(abd_to_buf(rrd->abd),\n\t\t\t    DRR_WRITE_PAYLOAD_SIZE(drrw));\n\t\t}\n\n\t\terr = dmu_buf_hold_noread(rwa->os, drrw->drr_object,\n\t\t    drrw->drr_offset, FTAG, &dbp);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\t \n\t\terr = dbuf_read((dmu_buf_impl_t *)dbp, NULL, flags);\n\t\t \n\t\tif (err != ECKSUM) {\n\t\t\tdmu_buf_rele(dbp, FTAG);\n\t\t\treturn (err);\n\t\t}\n\t\tdn = dmu_buf_dnode_enter(dbp);\n\t\t \n\t\tif (drrw->drr_logical_size !=\n\t\t    dn->dn_datablkszsec << SPA_MINBLOCKSHIFT) {\n\t\t\terr = ENOTSUP;\n\t\t\tdmu_buf_dnode_exit(dbp);\n\t\t\tdmu_buf_rele(dbp, FTAG);\n\t\t\treturn (err);\n\t\t}\n\t\t \n\t\tbp = dmu_buf_get_blkptr(dbp);\n\t\terr = do_corrective_recv(rwa, drrw, rrd, bp);\n\t\tdmu_buf_dnode_exit(dbp);\n\t\tdmu_buf_rele(dbp, FTAG);\n\t\treturn (err);\n\t}\n\n\t \n\tif (drrw->drr_object < rwa->last_object ||\n\t    (drrw->drr_object == rwa->last_object &&\n\t    drrw->drr_offset < rwa->last_offset)) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tstruct receive_record_arg *first_rrd = list_head(&rwa->write_batch);\n\tstruct drr_write *first_drrw = &first_rrd->header.drr_u.drr_write;\n\tuint64_t batch_size =\n\t    MIN(zfs_recv_write_batch_size, DMU_MAX_ACCESS / 2);\n\tif (first_rrd != NULL &&\n\t    (drrw->drr_object != first_drrw->drr_object ||\n\t    drrw->drr_offset >= first_drrw->drr_offset + batch_size)) {\n\t\terr = flush_write_batch(rwa);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\trwa->last_object = drrw->drr_object;\n\trwa->last_offset = drrw->drr_offset;\n\n\tif (rwa->last_object > rwa->max_object)\n\t\trwa->max_object = rwa->last_object;\n\n\tlist_insert_tail(&rwa->write_batch, rrd);\n\t \n\treturn (EAGAIN);\n}\n\nstatic int\nreceive_write_embedded(struct receive_writer_arg *rwa,\n    struct drr_write_embedded *drrwe, void *data)\n{\n\tdmu_tx_t *tx;\n\tint err;\n\n\tif (drrwe->drr_offset + drrwe->drr_length < drrwe->drr_offset)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drrwe->drr_psize > BPE_PAYLOAD_SIZE)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drrwe->drr_etype >= NUM_BP_EMBEDDED_TYPES)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (drrwe->drr_compression >= ZIO_COMPRESS_FUNCTIONS)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (rwa->raw)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drrwe->drr_object > rwa->max_object)\n\t\trwa->max_object = drrwe->drr_object;\n\n\ttx = dmu_tx_create(rwa->os);\n\n\tdmu_tx_hold_write(tx, drrwe->drr_object,\n\t    drrwe->drr_offset, drrwe->drr_length);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err != 0) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (err);\n\t}\n\n\tdmu_write_embedded(rwa->os, drrwe->drr_object,\n\t    drrwe->drr_offset, data, drrwe->drr_etype,\n\t    drrwe->drr_compression, drrwe->drr_lsize, drrwe->drr_psize,\n\t    rwa->byteswap ^ ZFS_HOST_BYTEORDER, tx);\n\n\t \n\tsave_resume_state(rwa, drrwe->drr_object, drrwe->drr_offset, tx);\n\tdmu_tx_commit(tx);\n\treturn (0);\n}\n\nstatic int\nreceive_spill(struct receive_writer_arg *rwa, struct drr_spill *drrs,\n    abd_t *abd)\n{\n\tdmu_buf_t *db, *db_spill;\n\tint err;\n\n\tif (drrs->drr_length < SPA_MINBLOCKSIZE ||\n\t    drrs->drr_length > spa_maxblocksize(dmu_objset_spa(rwa->os)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (rwa->spill && DRR_SPILL_IS_UNMODIFIED(drrs->drr_flags)) {\n\t\tabd_free(abd);\n\t\treturn (0);\n\t}\n\n\tif (rwa->raw) {\n\t\tif (!DMU_OT_IS_VALID(drrs->drr_type) ||\n\t\t    drrs->drr_compressiontype >= ZIO_COMPRESS_FUNCTIONS ||\n\t\t    drrs->drr_compressed_size == 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (dmu_object_info(rwa->os, drrs->drr_object, NULL) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drrs->drr_object > rwa->max_object)\n\t\trwa->max_object = drrs->drr_object;\n\n\tVERIFY0(dmu_bonus_hold(rwa->os, drrs->drr_object, FTAG, &db));\n\tif ((err = dmu_spill_hold_by_bonus(db, DMU_READ_NO_DECRYPT, FTAG,\n\t    &db_spill)) != 0) {\n\t\tdmu_buf_rele(db, FTAG);\n\t\treturn (err);\n\t}\n\n\tdmu_tx_t *tx = dmu_tx_create(rwa->os);\n\n\tdmu_tx_hold_spill(tx, db->db_object);\n\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err != 0) {\n\t\tdmu_buf_rele(db, FTAG);\n\t\tdmu_buf_rele(db_spill, FTAG);\n\t\tdmu_tx_abort(tx);\n\t\treturn (err);\n\t}\n\n\t \n\tif (db_spill->db_size != drrs->drr_length) {\n\t\tdmu_buf_will_fill(db_spill, tx);\n\t\tVERIFY0(dbuf_spill_set_blksz(db_spill,\n\t\t    drrs->drr_length, tx));\n\t}\n\n\tarc_buf_t *abuf;\n\tif (rwa->raw) {\n\t\tboolean_t byteorder = ZFS_HOST_BYTEORDER ^\n\t\t    !!DRR_IS_RAW_BYTESWAPPED(drrs->drr_flags) ^\n\t\t    rwa->byteswap;\n\n\t\tabuf = arc_loan_raw_buf(dmu_objset_spa(rwa->os),\n\t\t    drrs->drr_object, byteorder, drrs->drr_salt,\n\t\t    drrs->drr_iv, drrs->drr_mac, drrs->drr_type,\n\t\t    drrs->drr_compressed_size, drrs->drr_length,\n\t\t    drrs->drr_compressiontype, 0);\n\t} else {\n\t\tabuf = arc_loan_buf(dmu_objset_spa(rwa->os),\n\t\t    DMU_OT_IS_METADATA(drrs->drr_type),\n\t\t    drrs->drr_length);\n\t\tif (rwa->byteswap) {\n\t\t\tdmu_object_byteswap_t byteswap =\n\t\t\t    DMU_OT_BYTESWAP(drrs->drr_type);\n\t\t\tdmu_ot_byteswap[byteswap].ob_func(abd_to_buf(abd),\n\t\t\t    DRR_SPILL_PAYLOAD_SIZE(drrs));\n\t\t}\n\t}\n\n\tmemcpy(abuf->b_data, abd_to_buf(abd), DRR_SPILL_PAYLOAD_SIZE(drrs));\n\tabd_free(abd);\n\tdbuf_assign_arcbuf((dmu_buf_impl_t *)db_spill, abuf, tx);\n\n\tdmu_buf_rele(db, FTAG);\n\tdmu_buf_rele(db_spill, FTAG);\n\n\tdmu_tx_commit(tx);\n\treturn (0);\n}\n\nnoinline static int\nreceive_free(struct receive_writer_arg *rwa, struct drr_free *drrf)\n{\n\tint err;\n\n\tif (drrf->drr_length != -1ULL &&\n\t    drrf->drr_offset + drrf->drr_length < drrf->drr_offset)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (dmu_object_info(rwa->os, drrf->drr_object, NULL) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drrf->drr_object > rwa->max_object)\n\t\trwa->max_object = drrf->drr_object;\n\n\terr = dmu_free_long_range(rwa->os, drrf->drr_object,\n\t    drrf->drr_offset, drrf->drr_length);\n\n\treturn (err);\n}\n\nstatic int\nreceive_object_range(struct receive_writer_arg *rwa,\n    struct drr_object_range *drror)\n{\n\t \n\tboolean_t byteorder = ZFS_HOST_BYTEORDER ^ rwa->byteswap ^\n\t    !!DRR_IS_RAW_BYTESWAPPED(drror->drr_flags);\n\n\t \n\tif (drror->drr_numslots != DNODES_PER_BLOCK ||\n\t    P2PHASE(drror->drr_firstobj, DNODES_PER_BLOCK) != 0 ||\n\t    !rwa->raw)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (drror->drr_firstobj > rwa->max_object)\n\t\trwa->max_object = drror->drr_firstobj;\n\n\t \n\trwa->or_crypt_params_present = B_TRUE;\n\trwa->or_firstobj = drror->drr_firstobj;\n\trwa->or_numslots = drror->drr_numslots;\n\tmemcpy(rwa->or_salt, drror->drr_salt, ZIO_DATA_SALT_LEN);\n\tmemcpy(rwa->or_iv, drror->drr_iv, ZIO_DATA_IV_LEN);\n\tmemcpy(rwa->or_mac, drror->drr_mac, ZIO_DATA_MAC_LEN);\n\trwa->or_byteorder = byteorder;\n\n\trwa->or_need_sync = ORNS_MAYBE;\n\n\treturn (0);\n}\n\n \nnoinline static int\nreceive_redact(struct receive_writer_arg *rwa, struct drr_redact *drrr)\n{\n\tstruct drr_free drrf = {0};\n\tdrrf.drr_length = drrr->drr_length;\n\tdrrf.drr_object = drrr->drr_object;\n\tdrrf.drr_offset = drrr->drr_offset;\n\tdrrf.drr_toguid = drrr->drr_toguid;\n\treturn (receive_free(rwa, &drrf));\n}\n\n \nstatic void\ndmu_recv_cleanup_ds(dmu_recv_cookie_t *drc)\n{\n\tdsl_dataset_t *ds = drc->drc_ds;\n\tds_hold_flags_t dsflags;\n\n\tdsflags = (drc->drc_raw) ? DS_HOLD_FLAG_NONE : DS_HOLD_FLAG_DECRYPT;\n\t \n\ttxg_wait_synced(ds->ds_dir->dd_pool, 0);\n\tds->ds_objset->os_raw_receive = B_FALSE;\n\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tif (drc->drc_resumable && drc->drc_should_save &&\n\t    !BP_IS_HOLE(dsl_dataset_get_blkptr(ds))) {\n\t\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\t\tdsl_dataset_disown(ds, dsflags, dmu_recv_tag);\n\t} else {\n\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\t\tdsl_dataset_name(ds, name);\n\t\tdsl_dataset_disown(ds, dsflags, dmu_recv_tag);\n\t\tif (!drc->drc_heal)\n\t\t\t(void) dsl_destroy_head(name);\n\t}\n}\n\nstatic void\nreceive_cksum(dmu_recv_cookie_t *drc, int len, void *buf)\n{\n\tif (drc->drc_byteswap) {\n\t\t(void) fletcher_4_incremental_byteswap(buf, len,\n\t\t    &drc->drc_cksum);\n\t} else {\n\t\t(void) fletcher_4_incremental_native(buf, len, &drc->drc_cksum);\n\t}\n}\n\n \nstatic int\nreceive_read_payload_and_next_header(dmu_recv_cookie_t *drc, int len, void *buf)\n{\n\tint err;\n\n\tif (len != 0) {\n\t\tASSERT3U(len, <=, SPA_MAXBLOCKSIZE);\n\t\terr = receive_read(drc, len, buf);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t\treceive_cksum(drc, len, buf);\n\n\t\t \n\t\tif (drc->drc_rrd != NULL) {\n\t\t\tdrc->drc_rrd->payload = buf;\n\t\t\tdrc->drc_rrd->payload_size = len;\n\t\t\tdrc->drc_rrd->bytes_read = drc->drc_bytes_read;\n\t\t}\n\t} else {\n\t\tASSERT3P(buf, ==, NULL);\n\t}\n\n\tdrc->drc_prev_cksum = drc->drc_cksum;\n\n\tdrc->drc_next_rrd = kmem_zalloc(sizeof (*drc->drc_next_rrd), KM_SLEEP);\n\terr = receive_read(drc, sizeof (drc->drc_next_rrd->header),\n\t    &drc->drc_next_rrd->header);\n\tdrc->drc_next_rrd->bytes_read = drc->drc_bytes_read;\n\n\tif (err != 0) {\n\t\tkmem_free(drc->drc_next_rrd, sizeof (*drc->drc_next_rrd));\n\t\tdrc->drc_next_rrd = NULL;\n\t\treturn (err);\n\t}\n\tif (drc->drc_next_rrd->header.drr_type == DRR_BEGIN) {\n\t\tkmem_free(drc->drc_next_rrd, sizeof (*drc->drc_next_rrd));\n\t\tdrc->drc_next_rrd = NULL;\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tASSERT3U(offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum),\n\t    ==, sizeof (dmu_replay_record_t) - sizeof (zio_cksum_t));\n\treceive_cksum(drc,\n\t    offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum),\n\t    &drc->drc_next_rrd->header);\n\n\tzio_cksum_t cksum_orig =\n\t    drc->drc_next_rrd->header.drr_u.drr_checksum.drr_checksum;\n\tzio_cksum_t *cksump =\n\t    &drc->drc_next_rrd->header.drr_u.drr_checksum.drr_checksum;\n\n\tif (drc->drc_byteswap)\n\t\tbyteswap_record(&drc->drc_next_rrd->header);\n\n\tif ((!ZIO_CHECKSUM_IS_ZERO(cksump)) &&\n\t    !ZIO_CHECKSUM_EQUAL(drc->drc_cksum, *cksump)) {\n\t\tkmem_free(drc->drc_next_rrd, sizeof (*drc->drc_next_rrd));\n\t\tdrc->drc_next_rrd = NULL;\n\t\treturn (SET_ERROR(ECKSUM));\n\t}\n\n\treceive_cksum(drc, sizeof (cksum_orig), &cksum_orig);\n\n\treturn (0);\n}\n\n \nstatic void\nreceive_read_prefetch(dmu_recv_cookie_t *drc, uint64_t object, uint64_t offset,\n    uint64_t length)\n{\n\tif (!objlist_exists(drc->drc_ignore_objlist, object)) {\n\t\tdmu_prefetch(drc->drc_os, object, 1, offset, length,\n\t\t    ZIO_PRIORITY_SYNC_READ);\n\t}\n}\n\n \nstatic int\nreceive_read_record(dmu_recv_cookie_t *drc)\n{\n\tint err;\n\n\tswitch (drc->drc_rrd->header.drr_type) {\n\tcase DRR_OBJECT:\n\t{\n\t\tstruct drr_object *drro =\n\t\t    &drc->drc_rrd->header.drr_u.drr_object;\n\t\tuint32_t size = DRR_OBJECT_PAYLOAD_SIZE(drro);\n\t\tvoid *buf = NULL;\n\t\tdmu_object_info_t doi;\n\n\t\tif (size != 0)\n\t\t\tbuf = kmem_zalloc(size, KM_SLEEP);\n\n\t\terr = receive_read_payload_and_next_header(drc, size, buf);\n\t\tif (err != 0) {\n\t\t\tkmem_free(buf, size);\n\t\t\treturn (err);\n\t\t}\n\t\terr = dmu_object_info(drc->drc_os, drro->drr_object, &doi);\n\t\t \n\t\tif (err == ENOENT || err == EEXIST ||\n\t\t    (err == 0 && doi.doi_data_block_size != drro->drr_blksz)) {\n\t\t\tobjlist_insert(drc->drc_ignore_objlist,\n\t\t\t    drro->drr_object);\n\t\t\terr = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\tcase DRR_FREEOBJECTS:\n\t{\n\t\terr = receive_read_payload_and_next_header(drc, 0, NULL);\n\t\treturn (err);\n\t}\n\tcase DRR_WRITE:\n\t{\n\t\tstruct drr_write *drrw = &drc->drc_rrd->header.drr_u.drr_write;\n\t\tint size = DRR_WRITE_PAYLOAD_SIZE(drrw);\n\t\tabd_t *abd = abd_alloc_linear(size, B_FALSE);\n\t\terr = receive_read_payload_and_next_header(drc, size,\n\t\t    abd_to_buf(abd));\n\t\tif (err != 0) {\n\t\t\tabd_free(abd);\n\t\t\treturn (err);\n\t\t}\n\t\tdrc->drc_rrd->abd = abd;\n\t\treceive_read_prefetch(drc, drrw->drr_object, drrw->drr_offset,\n\t\t    drrw->drr_logical_size);\n\t\treturn (err);\n\t}\n\tcase DRR_WRITE_EMBEDDED:\n\t{\n\t\tstruct drr_write_embedded *drrwe =\n\t\t    &drc->drc_rrd->header.drr_u.drr_write_embedded;\n\t\tuint32_t size = P2ROUNDUP(drrwe->drr_psize, 8);\n\t\tvoid *buf = kmem_zalloc(size, KM_SLEEP);\n\n\t\terr = receive_read_payload_and_next_header(drc, size, buf);\n\t\tif (err != 0) {\n\t\t\tkmem_free(buf, size);\n\t\t\treturn (err);\n\t\t}\n\n\t\treceive_read_prefetch(drc, drrwe->drr_object, drrwe->drr_offset,\n\t\t    drrwe->drr_length);\n\t\treturn (err);\n\t}\n\tcase DRR_FREE:\n\tcase DRR_REDACT:\n\t{\n\t\t \n\t\terr = receive_read_payload_and_next_header(drc, 0, NULL);\n\t\treturn (err);\n\t}\n\tcase DRR_END:\n\t{\n\t\tstruct drr_end *drre = &drc->drc_rrd->header.drr_u.drr_end;\n\t\tif (!ZIO_CHECKSUM_EQUAL(drc->drc_prev_cksum,\n\t\t    drre->drr_checksum))\n\t\t\treturn (SET_ERROR(ECKSUM));\n\t\treturn (0);\n\t}\n\tcase DRR_SPILL:\n\t{\n\t\tstruct drr_spill *drrs = &drc->drc_rrd->header.drr_u.drr_spill;\n\t\tint size = DRR_SPILL_PAYLOAD_SIZE(drrs);\n\t\tabd_t *abd = abd_alloc_linear(size, B_FALSE);\n\t\terr = receive_read_payload_and_next_header(drc, size,\n\t\t    abd_to_buf(abd));\n\t\tif (err != 0)\n\t\t\tabd_free(abd);\n\t\telse\n\t\t\tdrc->drc_rrd->abd = abd;\n\t\treturn (err);\n\t}\n\tcase DRR_OBJECT_RANGE:\n\t{\n\t\terr = receive_read_payload_and_next_header(drc, 0, NULL);\n\t\treturn (err);\n\n\t}\n\tdefault:\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n}\n\n\n\nstatic void\ndprintf_drr(struct receive_record_arg *rrd, int err)\n{\n#ifdef ZFS_DEBUG\n\tswitch (rrd->header.drr_type) {\n\tcase DRR_OBJECT:\n\t{\n\t\tstruct drr_object *drro = &rrd->header.drr_u.drr_object;\n\t\tdprintf(\"drr_type = OBJECT obj = %llu type = %u \"\n\t\t    \"bonustype = %u blksz = %u bonuslen = %u cksumtype = %u \"\n\t\t    \"compress = %u dn_slots = %u err = %d\\n\",\n\t\t    (u_longlong_t)drro->drr_object, drro->drr_type,\n\t\t    drro->drr_bonustype, drro->drr_blksz, drro->drr_bonuslen,\n\t\t    drro->drr_checksumtype, drro->drr_compress,\n\t\t    drro->drr_dn_slots, err);\n\t\tbreak;\n\t}\n\tcase DRR_FREEOBJECTS:\n\t{\n\t\tstruct drr_freeobjects *drrfo =\n\t\t    &rrd->header.drr_u.drr_freeobjects;\n\t\tdprintf(\"drr_type = FREEOBJECTS firstobj = %llu \"\n\t\t    \"numobjs = %llu err = %d\\n\",\n\t\t    (u_longlong_t)drrfo->drr_firstobj,\n\t\t    (u_longlong_t)drrfo->drr_numobjs, err);\n\t\tbreak;\n\t}\n\tcase DRR_WRITE:\n\t{\n\t\tstruct drr_write *drrw = &rrd->header.drr_u.drr_write;\n\t\tdprintf(\"drr_type = WRITE obj = %llu type = %u offset = %llu \"\n\t\t    \"lsize = %llu cksumtype = %u flags = %u \"\n\t\t    \"compress = %u psize = %llu err = %d\\n\",\n\t\t    (u_longlong_t)drrw->drr_object, drrw->drr_type,\n\t\t    (u_longlong_t)drrw->drr_offset,\n\t\t    (u_longlong_t)drrw->drr_logical_size,\n\t\t    drrw->drr_checksumtype, drrw->drr_flags,\n\t\t    drrw->drr_compressiontype,\n\t\t    (u_longlong_t)drrw->drr_compressed_size, err);\n\t\tbreak;\n\t}\n\tcase DRR_WRITE_BYREF:\n\t{\n\t\tstruct drr_write_byref *drrwbr =\n\t\t    &rrd->header.drr_u.drr_write_byref;\n\t\tdprintf(\"drr_type = WRITE_BYREF obj = %llu offset = %llu \"\n\t\t    \"length = %llu toguid = %llx refguid = %llx \"\n\t\t    \"refobject = %llu refoffset = %llu cksumtype = %u \"\n\t\t    \"flags = %u err = %d\\n\",\n\t\t    (u_longlong_t)drrwbr->drr_object,\n\t\t    (u_longlong_t)drrwbr->drr_offset,\n\t\t    (u_longlong_t)drrwbr->drr_length,\n\t\t    (u_longlong_t)drrwbr->drr_toguid,\n\t\t    (u_longlong_t)drrwbr->drr_refguid,\n\t\t    (u_longlong_t)drrwbr->drr_refobject,\n\t\t    (u_longlong_t)drrwbr->drr_refoffset,\n\t\t    drrwbr->drr_checksumtype, drrwbr->drr_flags, err);\n\t\tbreak;\n\t}\n\tcase DRR_WRITE_EMBEDDED:\n\t{\n\t\tstruct drr_write_embedded *drrwe =\n\t\t    &rrd->header.drr_u.drr_write_embedded;\n\t\tdprintf(\"drr_type = WRITE_EMBEDDED obj = %llu offset = %llu \"\n\t\t    \"length = %llu compress = %u etype = %u lsize = %u \"\n\t\t    \"psize = %u err = %d\\n\",\n\t\t    (u_longlong_t)drrwe->drr_object,\n\t\t    (u_longlong_t)drrwe->drr_offset,\n\t\t    (u_longlong_t)drrwe->drr_length,\n\t\t    drrwe->drr_compression, drrwe->drr_etype,\n\t\t    drrwe->drr_lsize, drrwe->drr_psize, err);\n\t\tbreak;\n\t}\n\tcase DRR_FREE:\n\t{\n\t\tstruct drr_free *drrf = &rrd->header.drr_u.drr_free;\n\t\tdprintf(\"drr_type = FREE obj = %llu offset = %llu \"\n\t\t    \"length = %lld err = %d\\n\",\n\t\t    (u_longlong_t)drrf->drr_object,\n\t\t    (u_longlong_t)drrf->drr_offset,\n\t\t    (longlong_t)drrf->drr_length,\n\t\t    err);\n\t\tbreak;\n\t}\n\tcase DRR_SPILL:\n\t{\n\t\tstruct drr_spill *drrs = &rrd->header.drr_u.drr_spill;\n\t\tdprintf(\"drr_type = SPILL obj = %llu length = %llu \"\n\t\t    \"err = %d\\n\", (u_longlong_t)drrs->drr_object,\n\t\t    (u_longlong_t)drrs->drr_length, err);\n\t\tbreak;\n\t}\n\tcase DRR_OBJECT_RANGE:\n\t{\n\t\tstruct drr_object_range *drror =\n\t\t    &rrd->header.drr_u.drr_object_range;\n\t\tdprintf(\"drr_type = OBJECT_RANGE firstobj = %llu \"\n\t\t    \"numslots = %llu flags = %u err = %d\\n\",\n\t\t    (u_longlong_t)drror->drr_firstobj,\n\t\t    (u_longlong_t)drror->drr_numslots,\n\t\t    drror->drr_flags, err);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn;\n\t}\n#endif\n}\n\n \nstatic int\nreceive_process_record(struct receive_writer_arg *rwa,\n    struct receive_record_arg *rrd)\n{\n\tint err;\n\n\t \n\tASSERT3U(rrd->bytes_read, >=, rwa->bytes_read);\n\trwa->bytes_read = rrd->bytes_read;\n\n\t \n\tif (rwa->heal && rrd->header.drr_type != DRR_WRITE) {\n\t\tif (rrd->abd != NULL) {\n\t\t\tabd_free(rrd->abd);\n\t\t\trrd->abd = NULL;\n\t\t} else if (rrd->payload != NULL) {\n\t\t\tkmem_free(rrd->payload, rrd->payload_size);\n\t\t\trrd->payload = NULL;\n\t\t}\n\t\treturn (0);\n\t}\n\n\tif (!rwa->heal && rrd->header.drr_type != DRR_WRITE) {\n\t\terr = flush_write_batch(rwa);\n\t\tif (err != 0) {\n\t\t\tif (rrd->abd != NULL) {\n\t\t\t\tabd_free(rrd->abd);\n\t\t\t\trrd->abd = NULL;\n\t\t\t\trrd->payload = NULL;\n\t\t\t} else if (rrd->payload != NULL) {\n\t\t\t\tkmem_free(rrd->payload, rrd->payload_size);\n\t\t\t\trrd->payload = NULL;\n\t\t\t}\n\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\tswitch (rrd->header.drr_type) {\n\tcase DRR_OBJECT:\n\t{\n\t\tstruct drr_object *drro = &rrd->header.drr_u.drr_object;\n\t\terr = receive_object(rwa, drro, rrd->payload);\n\t\tkmem_free(rrd->payload, rrd->payload_size);\n\t\trrd->payload = NULL;\n\t\tbreak;\n\t}\n\tcase DRR_FREEOBJECTS:\n\t{\n\t\tstruct drr_freeobjects *drrfo =\n\t\t    &rrd->header.drr_u.drr_freeobjects;\n\t\terr = receive_freeobjects(rwa, drrfo);\n\t\tbreak;\n\t}\n\tcase DRR_WRITE:\n\t{\n\t\terr = receive_process_write_record(rwa, rrd);\n\t\tif (rwa->heal) {\n\t\t\t \n\t\t\tabd_free(rrd->abd);\n\t\t\trrd->abd = NULL;\n\t\t} else if (err != EAGAIN) {\n\t\t\t \n\t\t\tASSERT(err != 0);\n\t\t\tabd_free(rrd->abd);\n\t\t\trrd->abd = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase DRR_WRITE_EMBEDDED:\n\t{\n\t\tstruct drr_write_embedded *drrwe =\n\t\t    &rrd->header.drr_u.drr_write_embedded;\n\t\terr = receive_write_embedded(rwa, drrwe, rrd->payload);\n\t\tkmem_free(rrd->payload, rrd->payload_size);\n\t\trrd->payload = NULL;\n\t\tbreak;\n\t}\n\tcase DRR_FREE:\n\t{\n\t\tstruct drr_free *drrf = &rrd->header.drr_u.drr_free;\n\t\terr = receive_free(rwa, drrf);\n\t\tbreak;\n\t}\n\tcase DRR_SPILL:\n\t{\n\t\tstruct drr_spill *drrs = &rrd->header.drr_u.drr_spill;\n\t\terr = receive_spill(rwa, drrs, rrd->abd);\n\t\tif (err != 0)\n\t\t\tabd_free(rrd->abd);\n\t\trrd->abd = NULL;\n\t\trrd->payload = NULL;\n\t\tbreak;\n\t}\n\tcase DRR_OBJECT_RANGE:\n\t{\n\t\tstruct drr_object_range *drror =\n\t\t    &rrd->header.drr_u.drr_object_range;\n\t\terr = receive_object_range(rwa, drror);\n\t\tbreak;\n\t}\n\tcase DRR_REDACT:\n\t{\n\t\tstruct drr_redact *drrr = &rrd->header.drr_u.drr_redact;\n\t\terr = receive_redact(rwa, drrr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = (SET_ERROR(EINVAL));\n\t}\n\n\tif (err != 0)\n\t\tdprintf_drr(rrd, err);\n\n\treturn (err);\n}\n\n \nstatic __attribute__((noreturn)) void\nreceive_writer_thread(void *arg)\n{\n\tstruct receive_writer_arg *rwa = arg;\n\tstruct receive_record_arg *rrd;\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\n\tfor (rrd = bqueue_dequeue(&rwa->q); !rrd->eos_marker;\n\t    rrd = bqueue_dequeue(&rwa->q)) {\n\t\t \n\t\tint err = 0;\n\t\tif (rwa->err == 0) {\n\t\t\terr = receive_process_record(rwa, rrd);\n\t\t} else if (rrd->abd != NULL) {\n\t\t\tabd_free(rrd->abd);\n\t\t\trrd->abd = NULL;\n\t\t\trrd->payload = NULL;\n\t\t} else if (rrd->payload != NULL) {\n\t\t\tkmem_free(rrd->payload, rrd->payload_size);\n\t\t\trrd->payload = NULL;\n\t\t}\n\t\t \n\t\tif (err != EAGAIN || rwa->heal) {\n\t\t\tif (rwa->err == 0)\n\t\t\t\trwa->err = err;\n\t\t\tkmem_free(rrd, sizeof (*rrd));\n\t\t}\n\t}\n\tkmem_free(rrd, sizeof (*rrd));\n\n\tif (rwa->heal) {\n\t\tzio_wait(rwa->heal_pio);\n\t} else {\n\t\tint err = flush_write_batch(rwa);\n\t\tif (rwa->err == 0)\n\t\t\trwa->err = err;\n\t}\n\tmutex_enter(&rwa->mutex);\n\trwa->done = B_TRUE;\n\tcv_signal(&rwa->cv);\n\tmutex_exit(&rwa->mutex);\n\tspl_fstrans_unmark(cookie);\n\tthread_exit();\n}\n\nstatic int\nresume_check(dmu_recv_cookie_t *drc, nvlist_t *begin_nvl)\n{\n\tuint64_t val;\n\tobjset_t *mos = dmu_objset_pool(drc->drc_os)->dp_meta_objset;\n\tuint64_t dsobj = dmu_objset_id(drc->drc_os);\n\tuint64_t resume_obj, resume_off;\n\n\tif (nvlist_lookup_uint64(begin_nvl,\n\t    \"resume_object\", &resume_obj) != 0 ||\n\t    nvlist_lookup_uint64(begin_nvl,\n\t    \"resume_offset\", &resume_off) != 0) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tVERIFY0(zap_lookup(mos, dsobj,\n\t    DS_FIELD_RESUME_OBJECT, sizeof (val), 1, &val));\n\tif (resume_obj != val)\n\t\treturn (SET_ERROR(EINVAL));\n\tVERIFY0(zap_lookup(mos, dsobj,\n\t    DS_FIELD_RESUME_OFFSET, sizeof (val), 1, &val));\n\tif (resume_off != val)\n\t\treturn (SET_ERROR(EINVAL));\n\n\treturn (0);\n}\n\n \nint\ndmu_recv_stream(dmu_recv_cookie_t *drc, offset_t *voffp)\n{\n\tint err = 0;\n\tstruct receive_writer_arg *rwa = kmem_zalloc(sizeof (*rwa), KM_SLEEP);\n\n\tif (dsl_dataset_has_resume_receive_state(drc->drc_ds)) {\n\t\tuint64_t bytes = 0;\n\t\t(void) zap_lookup(drc->drc_ds->ds_dir->dd_pool->dp_meta_objset,\n\t\t    drc->drc_ds->ds_object, DS_FIELD_RESUME_BYTES,\n\t\t    sizeof (bytes), 1, &bytes);\n\t\tdrc->drc_bytes_read += bytes;\n\t}\n\n\tdrc->drc_ignore_objlist = objlist_create();\n\n\t \n\tASSERT3U(DMU_GET_STREAM_HDRTYPE(drc->drc_drrb->drr_versioninfo), ==,\n\t    DMU_SUBSTREAM);\n\tASSERT3U(drc->drc_drrb->drr_type, <, DMU_OST_NUMTYPES);\n\n\tASSERT(dsl_dataset_phys(drc->drc_ds)->ds_flags & DS_FLAG_INCONSISTENT);\n\tASSERT0(drc->drc_os->os_encrypted &&\n\t    (drc->drc_featureflags & DMU_BACKUP_FEATURE_EMBED_DATA));\n\n\t \n\tif (drc->drc_featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\tnvlist_t *keynvl = NULL;\n\n\t\tASSERT(drc->drc_os->os_encrypted);\n\t\tASSERT(drc->drc_raw);\n\n\t\terr = nvlist_lookup_nvlist(drc->drc_begin_nvl, \"crypt_keydata\",\n\t\t    &keynvl);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\tif (!drc->drc_heal) {\n\t\t\t \n\t\t\terr = dsl_crypto_recv_raw(spa_name(drc->drc_os->os_spa),\n\t\t\t    drc->drc_ds->ds_object, drc->drc_fromsnapobj,\n\t\t\t    drc->drc_drrb->drr_type, keynvl, drc->drc_newfs);\n\t\t\tif (err != 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdrc->drc_ivset_guid = 0;\n\t\t(void) nvlist_lookup_uint64(keynvl, \"to_ivset_guid\",\n\t\t    &drc->drc_ivset_guid);\n\n\t\tif (!drc->drc_newfs)\n\t\t\tdrc->drc_keynvl = fnvlist_dup(keynvl);\n\t}\n\n\tif (drc->drc_featureflags & DMU_BACKUP_FEATURE_RESUMING) {\n\t\terr = resume_check(drc, drc->drc_begin_nvl);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (drc->drc_drr_begin->drr_payloadlen == 0) {\n\t\terr = receive_read_payload_and_next_header(drc, 0, NULL);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tdrc->drc_should_save = B_TRUE;\n\n\t(void) bqueue_init(&rwa->q, zfs_recv_queue_ff,\n\t    MAX(zfs_recv_queue_length, 2 * zfs_max_recordsize),\n\t    offsetof(struct receive_record_arg, node));\n\tcv_init(&rwa->cv, NULL, CV_DEFAULT, NULL);\n\tmutex_init(&rwa->mutex, NULL, MUTEX_DEFAULT, NULL);\n\trwa->os = drc->drc_os;\n\trwa->byteswap = drc->drc_byteswap;\n\trwa->heal = drc->drc_heal;\n\trwa->tofs = drc->drc_tofs;\n\trwa->resumable = drc->drc_resumable;\n\trwa->raw = drc->drc_raw;\n\trwa->spill = drc->drc_spill;\n\trwa->full = (drc->drc_drr_begin->drr_u.drr_begin.drr_fromguid == 0);\n\trwa->os->os_raw_receive = drc->drc_raw;\n\tif (drc->drc_heal) {\n\t\trwa->heal_pio = zio_root(drc->drc_os->os_spa, NULL, NULL,\n\t\t    ZIO_FLAG_GODFATHER);\n\t}\n\tlist_create(&rwa->write_batch, sizeof (struct receive_record_arg),\n\t    offsetof(struct receive_record_arg, node.bqn_node));\n\n\t(void) thread_create(NULL, 0, receive_writer_thread, rwa, 0, curproc,\n\t    TS_RUN, minclsyspri);\n\t \n\twhile (rwa->err == 0) {\n\t\tif (issig(JUSTLOOKING) && issig(FORREAL)) {\n\t\t\terr = SET_ERROR(EINTR);\n\t\t\tbreak;\n\t\t}\n\n\t\tASSERT3P(drc->drc_rrd, ==, NULL);\n\t\tdrc->drc_rrd = drc->drc_next_rrd;\n\t\tdrc->drc_next_rrd = NULL;\n\t\t \n\t\terr = receive_read_record(drc);\n\n\t\tif (drc->drc_rrd->header.drr_type == DRR_END || err != 0) {\n\t\t\tkmem_free(drc->drc_rrd, sizeof (*drc->drc_rrd));\n\t\t\tdrc->drc_rrd = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbqueue_enqueue(&rwa->q, drc->drc_rrd,\n\t\t    sizeof (struct receive_record_arg) +\n\t\t    drc->drc_rrd->payload_size);\n\t\tdrc->drc_rrd = NULL;\n\t}\n\n\tASSERT3P(drc->drc_rrd, ==, NULL);\n\tdrc->drc_rrd = kmem_zalloc(sizeof (*drc->drc_rrd), KM_SLEEP);\n\tdrc->drc_rrd->eos_marker = B_TRUE;\n\tbqueue_enqueue_flush(&rwa->q, drc->drc_rrd, 1);\n\n\tmutex_enter(&rwa->mutex);\n\twhile (!rwa->done) {\n\t\t \n\t\t(void) cv_wait_sig(&rwa->cv, &rwa->mutex);\n\t}\n\tmutex_exit(&rwa->mutex);\n\n\t \n\tif (drc->drc_clone && drc->drc_drrb->drr_fromguid == 0) {\n\t\tuint64_t obj = rwa->max_object + 1;\n\t\tint free_err = 0;\n\t\tint next_err = 0;\n\n\t\twhile (next_err == 0) {\n\t\t\tfree_err = dmu_free_long_object(rwa->os, obj);\n\t\t\tif (free_err != 0 && free_err != ENOENT)\n\t\t\t\tbreak;\n\n\t\t\tnext_err = dmu_object_next(rwa->os, &obj, FALSE, 0);\n\t\t}\n\n\t\tif (err == 0) {\n\t\t\tif (free_err != 0 && free_err != ENOENT)\n\t\t\t\terr = free_err;\n\t\t\telse if (next_err != ESRCH)\n\t\t\t\terr = next_err;\n\t\t}\n\t}\n\n\tcv_destroy(&rwa->cv);\n\tmutex_destroy(&rwa->mutex);\n\tbqueue_destroy(&rwa->q);\n\tlist_destroy(&rwa->write_batch);\n\tif (err == 0)\n\t\terr = rwa->err;\n\nout:\n\t \n\tif (drc->drc_next_rrd != NULL)\n\t\tkmem_free(drc->drc_next_rrd, sizeof (*drc->drc_next_rrd));\n\n\t \n\tdrc->drc_os = NULL;\n\n\tkmem_free(rwa, sizeof (*rwa));\n\tnvlist_free(drc->drc_begin_nvl);\n\n\tif (err != 0) {\n\t\t \n\t\tdmu_recv_cleanup_ds(drc);\n\t\tnvlist_free(drc->drc_keynvl);\n\t}\n\n\tobjlist_destroy(drc->drc_ignore_objlist);\n\tdrc->drc_ignore_objlist = NULL;\n\t*voffp = drc->drc_voff;\n\treturn (err);\n}\n\nstatic int\ndmu_recv_end_check(void *arg, dmu_tx_t *tx)\n{\n\tdmu_recv_cookie_t *drc = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tint error;\n\n\tASSERT3P(drc->drc_ds->ds_owner, ==, dmu_recv_tag);\n\n\tif (drc->drc_heal) {\n\t\terror = 0;\n\t} else if (!drc->drc_newfs) {\n\t\tdsl_dataset_t *origin_head;\n\n\t\terror = dsl_dataset_hold(dp, drc->drc_tofs, FTAG, &origin_head);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t\tif (drc->drc_force) {\n\t\t\t \n\t\t\tuint64_t obj;\n\n\t\t\tobj = dsl_dataset_phys(origin_head)->ds_prev_snap_obj;\n\t\t\twhile (obj !=\n\t\t\t    dsl_dataset_phys(drc->drc_ds)->ds_prev_snap_obj) {\n\t\t\t\tdsl_dataset_t *snap;\n\t\t\t\terror = dsl_dataset_hold_obj(dp, obj, FTAG,\n\t\t\t\t    &snap);\n\t\t\t\tif (error != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (snap->ds_dir != origin_head->ds_dir)\n\t\t\t\t\terror = SET_ERROR(EINVAL);\n\t\t\t\tif (error == 0)  {\n\t\t\t\t\terror = dsl_destroy_snapshot_check_impl(\n\t\t\t\t\t    snap, B_FALSE);\n\t\t\t\t}\n\t\t\t\tobj = dsl_dataset_phys(snap)->ds_prev_snap_obj;\n\t\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\t\tif (error != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(origin_head, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t\tif (drc->drc_keynvl != NULL) {\n\t\t\terror = dsl_crypto_recv_raw_key_check(drc->drc_ds,\n\t\t\t    drc->drc_keynvl, tx);\n\t\t\tif (error != 0) {\n\t\t\t\tdsl_dataset_rele(origin_head, FTAG);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\terror = dsl_dataset_clone_swap_check_impl(drc->drc_ds,\n\t\t    origin_head, drc->drc_force, drc->drc_owner, tx);\n\t\tif (error != 0) {\n\t\t\tdsl_dataset_rele(origin_head, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\terror = dsl_dataset_snapshot_check_impl(origin_head,\n\t\t    drc->drc_tosnap, tx, B_TRUE, 1,\n\t\t    drc->drc_cred, drc->drc_proc);\n\t\tdsl_dataset_rele(origin_head, FTAG);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\terror = dsl_destroy_head_check_impl(drc->drc_ds, 1);\n\t} else {\n\t\terror = dsl_dataset_snapshot_check_impl(drc->drc_ds,\n\t\t    drc->drc_tosnap, tx, B_TRUE, 1,\n\t\t    drc->drc_cred, drc->drc_proc);\n\t}\n\treturn (error);\n}\n\nstatic void\ndmu_recv_end_sync(void *arg, dmu_tx_t *tx)\n{\n\tdmu_recv_cookie_t *drc = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tboolean_t encrypted = drc->drc_ds->ds_dir->dd_crypto_obj != 0;\n\tuint64_t newsnapobj = 0;\n\n\tspa_history_log_internal_ds(drc->drc_ds, \"finish receiving\",\n\t    tx, \"snap=%s\", drc->drc_tosnap);\n\tdrc->drc_ds->ds_objset->os_raw_receive = B_FALSE;\n\n\tif (drc->drc_heal) {\n\t\tif (drc->drc_keynvl != NULL) {\n\t\t\tnvlist_free(drc->drc_keynvl);\n\t\t\tdrc->drc_keynvl = NULL;\n\t\t}\n\t} else if (!drc->drc_newfs) {\n\t\tdsl_dataset_t *origin_head;\n\n\t\tVERIFY0(dsl_dataset_hold(dp, drc->drc_tofs, FTAG,\n\t\t    &origin_head));\n\n\t\tif (drc->drc_force) {\n\t\t\t \n\t\t\tuint64_t obj;\n\n\t\t\tobj = dsl_dataset_phys(origin_head)->ds_prev_snap_obj;\n\t\t\twhile (obj !=\n\t\t\t    dsl_dataset_phys(drc->drc_ds)->ds_prev_snap_obj) {\n\t\t\t\tdsl_dataset_t *snap;\n\t\t\t\tVERIFY0(dsl_dataset_hold_obj(dp, obj, FTAG,\n\t\t\t\t    &snap));\n\t\t\t\tASSERT3P(snap->ds_dir, ==, origin_head->ds_dir);\n\t\t\t\tobj = dsl_dataset_phys(snap)->ds_prev_snap_obj;\n\t\t\t\tdsl_destroy_snapshot_sync_impl(snap,\n\t\t\t\t    B_FALSE, tx);\n\t\t\t\tdsl_dataset_rele(snap, FTAG);\n\t\t\t}\n\t\t}\n\t\tif (drc->drc_keynvl != NULL) {\n\t\t\tdsl_crypto_recv_raw_key_sync(drc->drc_ds,\n\t\t\t    drc->drc_keynvl, tx);\n\t\t\tnvlist_free(drc->drc_keynvl);\n\t\t\tdrc->drc_keynvl = NULL;\n\t\t}\n\n\t\tVERIFY3P(drc->drc_ds->ds_prev, ==,\n\t\t    origin_head->ds_prev);\n\n\t\tdsl_dataset_clone_swap_sync_impl(drc->drc_ds,\n\t\t    origin_head, tx);\n\t\t \n\t\tdrc->drc_os = NULL;\n\n\t\tdsl_dataset_snapshot_sync_impl(origin_head,\n\t\t    drc->drc_tosnap, tx);\n\n\t\t \n\t\tdmu_buf_will_dirty(origin_head->ds_prev->ds_dbuf, tx);\n\t\tdsl_dataset_phys(origin_head->ds_prev)->ds_creation_time =\n\t\t    drc->drc_drrb->drr_creation_time;\n\t\tdsl_dataset_phys(origin_head->ds_prev)->ds_guid =\n\t\t    drc->drc_drrb->drr_toguid;\n\t\tdsl_dataset_phys(origin_head->ds_prev)->ds_flags &=\n\t\t    ~DS_FLAG_INCONSISTENT;\n\n\t\tdmu_buf_will_dirty(origin_head->ds_dbuf, tx);\n\t\tdsl_dataset_phys(origin_head)->ds_flags &=\n\t\t    ~DS_FLAG_INCONSISTENT;\n\n\t\tnewsnapobj =\n\t\t    dsl_dataset_phys(origin_head)->ds_prev_snap_obj;\n\n\t\tdsl_dataset_rele(origin_head, FTAG);\n\t\tdsl_destroy_head_sync_impl(drc->drc_ds, tx);\n\n\t\tif (drc->drc_owner != NULL)\n\t\t\tVERIFY3P(origin_head->ds_owner, ==, drc->drc_owner);\n\t} else {\n\t\tdsl_dataset_t *ds = drc->drc_ds;\n\n\t\tdsl_dataset_snapshot_sync_impl(ds, drc->drc_tosnap, tx);\n\n\t\t \n\t\tdmu_buf_will_dirty(ds->ds_prev->ds_dbuf, tx);\n\t\tdsl_dataset_phys(ds->ds_prev)->ds_creation_time =\n\t\t    drc->drc_drrb->drr_creation_time;\n\t\tdsl_dataset_phys(ds->ds_prev)->ds_guid =\n\t\t    drc->drc_drrb->drr_toguid;\n\t\tdsl_dataset_phys(ds->ds_prev)->ds_flags &=\n\t\t    ~DS_FLAG_INCONSISTENT;\n\n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tdsl_dataset_phys(ds)->ds_flags &= ~DS_FLAG_INCONSISTENT;\n\t\tif (dsl_dataset_has_resume_receive_state(ds)) {\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_FROMGUID, tx);\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_OBJECT, tx);\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_OFFSET, tx);\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_BYTES, tx);\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_TOGUID, tx);\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_TONAME, tx);\n\t\t\t(void) zap_remove(dp->dp_meta_objset, ds->ds_object,\n\t\t\t    DS_FIELD_RESUME_REDACT_BOOKMARK_SNAPS, tx);\n\t\t}\n\t\tnewsnapobj =\n\t\t    dsl_dataset_phys(drc->drc_ds)->ds_prev_snap_obj;\n\t}\n\n\t \n\tif (!drc->drc_heal && drc->drc_raw && drc->drc_ivset_guid != 0) {\n\t\tdmu_object_zapify(dp->dp_meta_objset, newsnapobj,\n\t\t    DMU_OT_DSL_DATASET, tx);\n\t\tVERIFY0(zap_update(dp->dp_meta_objset, newsnapobj,\n\t\t    DS_FIELD_IVSET_GUID, sizeof (uint64_t), 1,\n\t\t    &drc->drc_ivset_guid, tx));\n\t}\n\n\t \n\tif (!drc->drc_raw && encrypted) {\n\t\t(void) spa_keystore_remove_mapping(dmu_tx_pool(tx)->dp_spa,\n\t\t    drc->drc_ds->ds_object, drc->drc_ds);\n\t}\n\tdsl_dataset_disown(drc->drc_ds, 0, dmu_recv_tag);\n\tdrc->drc_ds = NULL;\n}\n\nstatic int dmu_recv_end_modified_blocks = 3;\n\nstatic int\ndmu_recv_existing_end(dmu_recv_cookie_t *drc)\n{\n#ifdef _KERNEL\n\t \n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tdsl_dataset_name(drc->drc_ds, name);\n\tzfs_destroy_unmount_origin(name);\n#endif\n\n\treturn (dsl_sync_task(drc->drc_tofs,\n\t    dmu_recv_end_check, dmu_recv_end_sync, drc,\n\t    dmu_recv_end_modified_blocks, ZFS_SPACE_CHECK_NORMAL));\n}\n\nstatic int\ndmu_recv_new_end(dmu_recv_cookie_t *drc)\n{\n\treturn (dsl_sync_task(drc->drc_tofs,\n\t    dmu_recv_end_check, dmu_recv_end_sync, drc,\n\t    dmu_recv_end_modified_blocks, ZFS_SPACE_CHECK_NORMAL));\n}\n\nint\ndmu_recv_end(dmu_recv_cookie_t *drc, void *owner)\n{\n\tint error;\n\n\tdrc->drc_owner = owner;\n\n\tif (drc->drc_newfs)\n\t\terror = dmu_recv_new_end(drc);\n\telse\n\t\terror = dmu_recv_existing_end(drc);\n\n\tif (error != 0) {\n\t\tdmu_recv_cleanup_ds(drc);\n\t\tnvlist_free(drc->drc_keynvl);\n\t} else if (!drc->drc_heal) {\n\t\tif (drc->drc_newfs) {\n\t\t\tzvol_create_minor(drc->drc_tofs);\n\t\t}\n\t\tchar *snapname = kmem_asprintf(\"%s@%s\",\n\t\t    drc->drc_tofs, drc->drc_tosnap);\n\t\tzvol_create_minor(snapname);\n\t\tkmem_strfree(snapname);\n\t}\n\treturn (error);\n}\n\n \nboolean_t\ndmu_objset_is_receiving(objset_t *os)\n{\n\treturn (os->os_dsl_dataset != NULL &&\n\t    os->os_dsl_dataset->ds_owner == dmu_recv_tag);\n}\n\nZFS_MODULE_PARAM(zfs_recv, zfs_recv_, queue_length, UINT, ZMOD_RW,\n\t\"Maximum receive queue length\");\n\nZFS_MODULE_PARAM(zfs_recv, zfs_recv_, queue_ff, UINT, ZMOD_RW,\n\t\"Receive queue fill fraction\");\n\nZFS_MODULE_PARAM(zfs_recv, zfs_recv_, write_batch_size, UINT, ZMOD_RW,\n\t\"Maximum amount of writes to batch into one transaction\");\n\nZFS_MODULE_PARAM(zfs_recv, zfs_recv_, best_effort_corrective, INT, ZMOD_RW,\n\t\"Ignore errors during corrective receive\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}