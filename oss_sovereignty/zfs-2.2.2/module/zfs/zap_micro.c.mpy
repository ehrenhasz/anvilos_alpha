{
  "module_name": "zap_micro.c",
  "hash_id": "8490d996d2502d2980fad310839613d9692f3eb8157af1d5c5c8a768c3f5fd80",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zap_micro.c",
  "human_readable_source": " \n\n \n\n#include <sys/zio.h>\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/zfs_context.h>\n#include <sys/zap.h>\n#include <sys/zap_impl.h>\n#include <sys/zap_leaf.h>\n#include <sys/btree.h>\n#include <sys/arc.h>\n#include <sys/dmu_objset.h>\n\n#ifdef _KERNEL\n#include <sys/sunddi.h>\n#endif\n\nint zap_micro_max_size = MZAP_MAX_BLKSZ;\n\nstatic int mzap_upgrade(zap_t **zapp,\n    const void *tag, dmu_tx_t *tx, zap_flags_t flags);\n\nuint64_t\nzap_getflags(zap_t *zap)\n{\n\tif (zap->zap_ismicro)\n\t\treturn (0);\n\treturn (zap_f_phys(zap)->zap_flags);\n}\n\nint\nzap_hashbits(zap_t *zap)\n{\n\tif (zap_getflags(zap) & ZAP_FLAG_HASH64)\n\t\treturn (48);\n\telse\n\t\treturn (28);\n}\n\nuint32_t\nzap_maxcd(zap_t *zap)\n{\n\tif (zap_getflags(zap) & ZAP_FLAG_HASH64)\n\t\treturn ((1<<16)-1);\n\telse\n\t\treturn (-1U);\n}\n\nstatic uint64_t\nzap_hash(zap_name_t *zn)\n{\n\tzap_t *zap = zn->zn_zap;\n\tuint64_t h = 0;\n\n\tif (zap_getflags(zap) & ZAP_FLAG_PRE_HASHED_KEY) {\n\t\tASSERT(zap_getflags(zap) & ZAP_FLAG_UINT64_KEY);\n\t\th = *(uint64_t *)zn->zn_key_orig;\n\t} else {\n\t\th = zap->zap_salt;\n\t\tASSERT(h != 0);\n\t\tASSERT(zfs_crc64_table[128] == ZFS_CRC64_POLY);\n\n\t\tif (zap_getflags(zap) & ZAP_FLAG_UINT64_KEY) {\n\t\t\tconst uint64_t *wp = zn->zn_key_norm;\n\n\t\t\tASSERT(zn->zn_key_intlen == 8);\n\t\t\tfor (int i = 0; i < zn->zn_key_norm_numints;\n\t\t\t    wp++, i++) {\n\t\t\t\tuint64_t word = *wp;\n\n\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\th = (h >> 8) ^\n\t\t\t\t\t    zfs_crc64_table[(h ^ word) & 0xFF];\n\t\t\t\t\tword >>= NBBY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst uint8_t *cp = zn->zn_key_norm;\n\n\t\t\t \n\t\t\tint len = zn->zn_key_norm_numints - 1;\n\n\t\t\tASSERT(zn->zn_key_intlen == 1);\n\t\t\tfor (int i = 0; i < len; cp++, i++) {\n\t\t\t\th = (h >> 8) ^\n\t\t\t\t    zfs_crc64_table[(h ^ *cp) & 0xFF];\n\t\t\t}\n\t\t}\n\t}\n\t \n\th &= ~((1ULL << (64 - zap_hashbits(zap))) - 1);\n\n\treturn (h);\n}\n\nstatic int\nzap_normalize(zap_t *zap, const char *name, char *namenorm, int normflags)\n{\n\tASSERT(!(zap_getflags(zap) & ZAP_FLAG_UINT64_KEY));\n\n\tsize_t inlen = strlen(name) + 1;\n\tsize_t outlen = ZAP_MAXNAMELEN;\n\n\tint err = 0;\n\t(void) u8_textprep_str((char *)name, &inlen, namenorm, &outlen,\n\t    normflags | U8_TEXTPREP_IGNORE_NULL | U8_TEXTPREP_IGNORE_INVALID,\n\t    U8_UNICODE_LATEST, &err);\n\n\treturn (err);\n}\n\nboolean_t\nzap_match(zap_name_t *zn, const char *matchname)\n{\n\tASSERT(!(zap_getflags(zn->zn_zap) & ZAP_FLAG_UINT64_KEY));\n\n\tif (zn->zn_matchtype & MT_NORMALIZE) {\n\t\tchar norm[ZAP_MAXNAMELEN];\n\n\t\tif (zap_normalize(zn->zn_zap, matchname, norm,\n\t\t    zn->zn_normflags) != 0)\n\t\t\treturn (B_FALSE);\n\n\t\treturn (strcmp(zn->zn_key_norm, norm) == 0);\n\t} else {\n\t\treturn (strcmp(zn->zn_key_orig, matchname) == 0);\n\t}\n}\n\nstatic zap_name_t *\nzap_name_alloc(zap_t *zap)\n{\n\tzap_name_t *zn = kmem_alloc(sizeof (zap_name_t), KM_SLEEP);\n\tzn->zn_zap = zap;\n\treturn (zn);\n}\n\nvoid\nzap_name_free(zap_name_t *zn)\n{\n\tkmem_free(zn, sizeof (zap_name_t));\n}\n\nstatic int\nzap_name_init_str(zap_name_t *zn, const char *key, matchtype_t mt)\n{\n\tzap_t *zap = zn->zn_zap;\n\n\tzn->zn_key_intlen = sizeof (*key);\n\tzn->zn_key_orig = key;\n\tzn->zn_key_orig_numints = strlen(zn->zn_key_orig) + 1;\n\tzn->zn_matchtype = mt;\n\tzn->zn_normflags = zap->zap_normflags;\n\n\t \n\tif (mt & MT_MATCH_CASE)\n\t\tzn->zn_normflags &= ~U8_TEXTPREP_TOUPPER;\n\n\tif (zap->zap_normflags) {\n\t\t \n\t\tif (zap_normalize(zap, key, zn->zn_normbuf,\n\t\t    zap->zap_normflags) != 0)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tzn->zn_key_norm = zn->zn_normbuf;\n\t\tzn->zn_key_norm_numints = strlen(zn->zn_key_norm) + 1;\n\t} else {\n\t\tif (mt != 0)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tzn->zn_key_norm = zn->zn_key_orig;\n\t\tzn->zn_key_norm_numints = zn->zn_key_orig_numints;\n\t}\n\n\tzn->zn_hash = zap_hash(zn);\n\n\tif (zap->zap_normflags != zn->zn_normflags) {\n\t\t \n\t\tif (zap_normalize(zap, key, zn->zn_normbuf,\n\t\t    zn->zn_normflags) != 0)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tzn->zn_key_norm_numints = strlen(zn->zn_key_norm) + 1;\n\t}\n\n\treturn (0);\n}\n\nzap_name_t *\nzap_name_alloc_str(zap_t *zap, const char *key, matchtype_t mt)\n{\n\tzap_name_t *zn = zap_name_alloc(zap);\n\tif (zap_name_init_str(zn, key, mt) != 0) {\n\t\tzap_name_free(zn);\n\t\treturn (NULL);\n\t}\n\treturn (zn);\n}\n\nstatic zap_name_t *\nzap_name_alloc_uint64(zap_t *zap, const uint64_t *key, int numints)\n{\n\tzap_name_t *zn = kmem_alloc(sizeof (zap_name_t), KM_SLEEP);\n\n\tASSERT(zap->zap_normflags == 0);\n\tzn->zn_zap = zap;\n\tzn->zn_key_intlen = sizeof (*key);\n\tzn->zn_key_orig = zn->zn_key_norm = key;\n\tzn->zn_key_orig_numints = zn->zn_key_norm_numints = numints;\n\tzn->zn_matchtype = 0;\n\n\tzn->zn_hash = zap_hash(zn);\n\treturn (zn);\n}\n\nstatic void\nmzap_byteswap(mzap_phys_t *buf, size_t size)\n{\n\tbuf->mz_block_type = BSWAP_64(buf->mz_block_type);\n\tbuf->mz_salt = BSWAP_64(buf->mz_salt);\n\tbuf->mz_normflags = BSWAP_64(buf->mz_normflags);\n\tint max = (size / MZAP_ENT_LEN) - 1;\n\tfor (int i = 0; i < max; i++) {\n\t\tbuf->mz_chunk[i].mze_value =\n\t\t    BSWAP_64(buf->mz_chunk[i].mze_value);\n\t\tbuf->mz_chunk[i].mze_cd =\n\t\t    BSWAP_32(buf->mz_chunk[i].mze_cd);\n\t}\n}\n\nvoid\nzap_byteswap(void *buf, size_t size)\n{\n\tuint64_t block_type = *(uint64_t *)buf;\n\n\tif (block_type == ZBT_MICRO || block_type == BSWAP_64(ZBT_MICRO)) {\n\t\t \n\t\tmzap_byteswap(buf, size);\n\t} else {\n\t\tfzap_byteswap(buf, size);\n\t}\n}\n\n__attribute__((always_inline)) inline\nstatic int\nmze_compare(const void *arg1, const void *arg2)\n{\n\tconst mzap_ent_t *mze1 = arg1;\n\tconst mzap_ent_t *mze2 = arg2;\n\n\treturn (TREE_CMP((uint64_t)(mze1->mze_hash) << 32 | mze1->mze_cd,\n\t    (uint64_t)(mze2->mze_hash) << 32 | mze2->mze_cd));\n}\n\nZFS_BTREE_FIND_IN_BUF_FUNC(mze_find_in_buf, mzap_ent_t,\n    mze_compare)\n\nstatic void\nmze_insert(zap_t *zap, uint16_t chunkid, uint64_t hash)\n{\n\tmzap_ent_t mze;\n\n\tASSERT(zap->zap_ismicro);\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\n\tmze.mze_chunkid = chunkid;\n\tASSERT0(hash & 0xffffffff);\n\tmze.mze_hash = hash >> 32;\n\tASSERT3U(MZE_PHYS(zap, &mze)->mze_cd, <=, 0xffff);\n\tmze.mze_cd = (uint16_t)MZE_PHYS(zap, &mze)->mze_cd;\n\tASSERT(MZE_PHYS(zap, &mze)->mze_name[0] != 0);\n\tzfs_btree_add(&zap->zap_m.zap_tree, &mze);\n}\n\nstatic mzap_ent_t *\nmze_find(zap_name_t *zn, zfs_btree_index_t *idx)\n{\n\tmzap_ent_t mze_tofind;\n\tmzap_ent_t *mze;\n\tzfs_btree_t *tree = &zn->zn_zap->zap_m.zap_tree;\n\n\tASSERT(zn->zn_zap->zap_ismicro);\n\tASSERT(RW_LOCK_HELD(&zn->zn_zap->zap_rwlock));\n\n\tASSERT0(zn->zn_hash & 0xffffffff);\n\tmze_tofind.mze_hash = zn->zn_hash >> 32;\n\tmze_tofind.mze_cd = 0;\n\n\tmze = zfs_btree_find(tree, &mze_tofind, idx);\n\tif (mze == NULL)\n\t\tmze = zfs_btree_next(tree, idx, idx);\n\tfor (; mze && mze->mze_hash == mze_tofind.mze_hash;\n\t    mze = zfs_btree_next(tree, idx, idx)) {\n\t\tASSERT3U(mze->mze_cd, ==, MZE_PHYS(zn->zn_zap, mze)->mze_cd);\n\t\tif (zap_match(zn, MZE_PHYS(zn->zn_zap, mze)->mze_name))\n\t\t\treturn (mze);\n\t}\n\n\treturn (NULL);\n}\n\nstatic uint32_t\nmze_find_unused_cd(zap_t *zap, uint64_t hash)\n{\n\tmzap_ent_t mze_tofind;\n\tzfs_btree_index_t idx;\n\tzfs_btree_t *tree = &zap->zap_m.zap_tree;\n\n\tASSERT(zap->zap_ismicro);\n\tASSERT(RW_LOCK_HELD(&zap->zap_rwlock));\n\n\tASSERT0(hash & 0xffffffff);\n\thash >>= 32;\n\tmze_tofind.mze_hash = hash;\n\tmze_tofind.mze_cd = 0;\n\n\tuint32_t cd = 0;\n\tfor (mzap_ent_t *mze = zfs_btree_find(tree, &mze_tofind, &idx);\n\t    mze && mze->mze_hash == hash;\n\t    mze = zfs_btree_next(tree, &idx, &idx)) {\n\t\tif (mze->mze_cd != cd)\n\t\t\tbreak;\n\t\tcd++;\n\t}\n\n\treturn (cd);\n}\n\n \n#define\tMZAP_ENT_CHUNKS\t(1 + ZAP_LEAF_ARRAY_NCHUNKS(MZAP_NAME_LEN) + \\\n\tZAP_LEAF_ARRAY_NCHUNKS(sizeof (uint64_t)))\n\n \nstatic boolean_t\nmze_canfit_fzap_leaf(zap_name_t *zn, uint64_t hash)\n{\n\tzap_t *zap = zn->zn_zap;\n\tmzap_ent_t mze_tofind;\n\tzfs_btree_index_t idx;\n\tzfs_btree_t *tree = &zap->zap_m.zap_tree;\n\tuint32_t mzap_ents = 0;\n\n\tASSERT0(hash & 0xffffffff);\n\thash >>= 32;\n\tmze_tofind.mze_hash = hash;\n\tmze_tofind.mze_cd = 0;\n\n\tfor (mzap_ent_t *mze = zfs_btree_find(tree, &mze_tofind, &idx);\n\t    mze && mze->mze_hash == hash;\n\t    mze = zfs_btree_next(tree, &idx, &idx)) {\n\t\tmzap_ents++;\n\t}\n\n\t \n\tmzap_ents++;\n\n\treturn (ZAP_LEAF_NUMCHUNKS_DEF > (mzap_ents * MZAP_ENT_CHUNKS));\n}\n\nstatic void\nmze_destroy(zap_t *zap)\n{\n\tzfs_btree_clear(&zap->zap_m.zap_tree);\n\tzfs_btree_destroy(&zap->zap_m.zap_tree);\n}\n\nstatic zap_t *\nmzap_open(objset_t *os, uint64_t obj, dmu_buf_t *db)\n{\n\tzap_t *winner;\n\tuint64_t *zap_hdr = (uint64_t *)db->db_data;\n\tuint64_t zap_block_type = zap_hdr[0];\n\tuint64_t zap_magic = zap_hdr[1];\n\n\tASSERT3U(MZAP_ENT_LEN, ==, sizeof (mzap_ent_phys_t));\n\n\tzap_t *zap = kmem_zalloc(sizeof (zap_t), KM_SLEEP);\n\trw_init(&zap->zap_rwlock, NULL, RW_DEFAULT, NULL);\n\trw_enter(&zap->zap_rwlock, RW_WRITER);\n\tzap->zap_objset = os;\n\tzap->zap_object = obj;\n\tzap->zap_dbuf = db;\n\n\tif (zap_block_type != ZBT_MICRO) {\n\t\tmutex_init(&zap->zap_f.zap_num_entries_mtx, 0, MUTEX_DEFAULT,\n\t\t    0);\n\t\tzap->zap_f.zap_block_shift = highbit64(db->db_size) - 1;\n\t\tif (zap_block_type != ZBT_HEADER || zap_magic != ZAP_MAGIC) {\n\t\t\twinner = NULL;\t \n\t\t\tgoto handle_winner;\n\t\t}\n\t} else {\n\t\tzap->zap_ismicro = TRUE;\n\t}\n\n\t \n\tdmu_buf_init_user(&zap->zap_dbu, zap_evict_sync, NULL, &zap->zap_dbuf);\n\twinner = dmu_buf_set_user(db, &zap->zap_dbu);\n\n\tif (winner != NULL)\n\t\tgoto handle_winner;\n\n\tif (zap->zap_ismicro) {\n\t\tzap->zap_salt = zap_m_phys(zap)->mz_salt;\n\t\tzap->zap_normflags = zap_m_phys(zap)->mz_normflags;\n\t\tzap->zap_m.zap_num_chunks = db->db_size / MZAP_ENT_LEN - 1;\n\n\t\t \n\t\tzfs_btree_create_custom(&zap->zap_m.zap_tree, mze_compare,\n\t\t    mze_find_in_buf, sizeof (mzap_ent_t), 512);\n\n\t\tzap_name_t *zn = zap_name_alloc(zap);\n\t\tfor (uint16_t i = 0; i < zap->zap_m.zap_num_chunks; i++) {\n\t\t\tmzap_ent_phys_t *mze =\n\t\t\t    &zap_m_phys(zap)->mz_chunk[i];\n\t\t\tif (mze->mze_name[0]) {\n\t\t\t\tzap->zap_m.zap_num_entries++;\n\t\t\t\tzap_name_init_str(zn, mze->mze_name, 0);\n\t\t\t\tmze_insert(zap, i, zn->zn_hash);\n\t\t\t}\n\t\t}\n\t\tzap_name_free(zn);\n\t} else {\n\t\tzap->zap_salt = zap_f_phys(zap)->zap_salt;\n\t\tzap->zap_normflags = zap_f_phys(zap)->zap_normflags;\n\n\t\tASSERT3U(sizeof (struct zap_leaf_header), ==,\n\t\t    2*ZAP_LEAF_CHUNKSIZE);\n\n\t\t \n\t\tASSERT3P(&ZAP_EMBEDDED_PTRTBL_ENT(zap, 0), >,\n\t\t    &zap_f_phys(zap)->zap_salt);\n\n\t\t \n\t\tASSERT3U((uintptr_t)&ZAP_EMBEDDED_PTRTBL_ENT(zap,\n\t\t    1<<ZAP_EMBEDDED_PTRTBL_SHIFT(zap)) -\n\t\t    (uintptr_t)zap_f_phys(zap), ==,\n\t\t    zap->zap_dbuf->db_size);\n\t}\n\trw_exit(&zap->zap_rwlock);\n\treturn (zap);\n\nhandle_winner:\n\trw_exit(&zap->zap_rwlock);\n\trw_destroy(&zap->zap_rwlock);\n\tif (!zap->zap_ismicro)\n\t\tmutex_destroy(&zap->zap_f.zap_num_entries_mtx);\n\tkmem_free(zap, sizeof (zap_t));\n\treturn (winner);\n}\n\n \nstatic int\nzap_lockdir_impl(dmu_buf_t *db, const void *tag, dmu_tx_t *tx,\n    krw_t lti, boolean_t fatreader, boolean_t adding, zap_t **zapp)\n{\n\tASSERT0(db->db_offset);\n\tobjset_t *os = dmu_buf_get_objset(db);\n\tuint64_t obj = db->db_object;\n\tdmu_object_info_t doi;\n\n\t*zapp = NULL;\n\n\tdmu_object_info_from_db(db, &doi);\n\tif (DMU_OT_BYTESWAP(doi.doi_type) != DMU_BSWAP_ZAP)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzap_t *zap = dmu_buf_get_user(db);\n\tif (zap == NULL) {\n\t\tzap = mzap_open(os, obj, db);\n\t\tif (zap == NULL) {\n\t\t\t \n\t\t\treturn (SET_ERROR(EIO));\n\t\t}\n\t}\n\n\t \n\tkrw_t lt = (!zap->zap_ismicro && fatreader) ? RW_READER : lti;\n\trw_enter(&zap->zap_rwlock, lt);\n\tif (lt != ((!zap->zap_ismicro && fatreader) ? RW_READER : lti)) {\n\t\t \n\t\tASSERT(lt == RW_WRITER);\n\t\tASSERT(RW_READER ==\n\t\t    ((!zap->zap_ismicro && fatreader) ? RW_READER : lti));\n\t\trw_downgrade(&zap->zap_rwlock);\n\t\tlt = RW_READER;\n\t}\n\n\tzap->zap_objset = os;\n\n\tif (lt == RW_WRITER)\n\t\tdmu_buf_will_dirty(db, tx);\n\n\tASSERT3P(zap->zap_dbuf, ==, db);\n\n\tASSERT(!zap->zap_ismicro ||\n\t    zap->zap_m.zap_num_entries <= zap->zap_m.zap_num_chunks);\n\tif (zap->zap_ismicro && tx && adding &&\n\t    zap->zap_m.zap_num_entries == zap->zap_m.zap_num_chunks) {\n\t\tuint64_t newsz = db->db_size + SPA_MINBLOCKSIZE;\n\t\tif (newsz > zap_micro_max_size) {\n\t\t\tdprintf(\"upgrading obj %llu: num_entries=%u\\n\",\n\t\t\t    (u_longlong_t)obj, zap->zap_m.zap_num_entries);\n\t\t\t*zapp = zap;\n\t\t\tint err = mzap_upgrade(zapp, tag, tx, 0);\n\t\t\tif (err != 0)\n\t\t\t\trw_exit(&zap->zap_rwlock);\n\t\t\treturn (err);\n\t\t}\n\t\tVERIFY0(dmu_object_set_blocksize(os, obj, newsz, 0, tx));\n\t\tzap->zap_m.zap_num_chunks =\n\t\t    db->db_size / MZAP_ENT_LEN - 1;\n\t}\n\n\t*zapp = zap;\n\treturn (0);\n}\n\nstatic int\nzap_lockdir_by_dnode(dnode_t *dn, dmu_tx_t *tx,\n    krw_t lti, boolean_t fatreader, boolean_t adding, const void *tag,\n    zap_t **zapp)\n{\n\tdmu_buf_t *db;\n\n\tint err = dmu_buf_hold_by_dnode(dn, 0, tag, &db, DMU_READ_NO_PREFETCH);\n\tif (err != 0) {\n\t\treturn (err);\n\t}\n#ifdef ZFS_DEBUG\n\t{\n\t\tdmu_object_info_t doi;\n\t\tdmu_object_info_from_db(db, &doi);\n\t\tASSERT3U(DMU_OT_BYTESWAP(doi.doi_type), ==, DMU_BSWAP_ZAP);\n\t}\n#endif\n\n\terr = zap_lockdir_impl(db, tag, tx, lti, fatreader, adding, zapp);\n\tif (err != 0) {\n\t\tdmu_buf_rele(db, tag);\n\t}\n\treturn (err);\n}\n\nint\nzap_lockdir(objset_t *os, uint64_t obj, dmu_tx_t *tx,\n    krw_t lti, boolean_t fatreader, boolean_t adding, const void *tag,\n    zap_t **zapp)\n{\n\tdmu_buf_t *db;\n\n\tint err = dmu_buf_hold(os, obj, 0, tag, &db, DMU_READ_NO_PREFETCH);\n\tif (err != 0)\n\t\treturn (err);\n#ifdef ZFS_DEBUG\n\t{\n\t\tdmu_object_info_t doi;\n\t\tdmu_object_info_from_db(db, &doi);\n\t\tASSERT3U(DMU_OT_BYTESWAP(doi.doi_type), ==, DMU_BSWAP_ZAP);\n\t}\n#endif\n\terr = zap_lockdir_impl(db, tag, tx, lti, fatreader, adding, zapp);\n\tif (err != 0)\n\t\tdmu_buf_rele(db, tag);\n\treturn (err);\n}\n\nvoid\nzap_unlockdir(zap_t *zap, const void *tag)\n{\n\trw_exit(&zap->zap_rwlock);\n\tdmu_buf_rele(zap->zap_dbuf, tag);\n}\n\nstatic int\nmzap_upgrade(zap_t **zapp, const void *tag, dmu_tx_t *tx, zap_flags_t flags)\n{\n\tint err = 0;\n\tzap_t *zap = *zapp;\n\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\n\tint sz = zap->zap_dbuf->db_size;\n\tmzap_phys_t *mzp = vmem_alloc(sz, KM_SLEEP);\n\tmemcpy(mzp, zap->zap_dbuf->db_data, sz);\n\tint nchunks = zap->zap_m.zap_num_chunks;\n\n\tif (!flags) {\n\t\terr = dmu_object_set_blocksize(zap->zap_objset, zap->zap_object,\n\t\t    1ULL << fzap_default_block_shift, 0, tx);\n\t\tif (err != 0) {\n\t\t\tvmem_free(mzp, sz);\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\tdprintf(\"upgrading obj=%llu with %u chunks\\n\",\n\t    (u_longlong_t)zap->zap_object, nchunks);\n\t \n\tmze_destroy(zap);\n\n\tfzap_upgrade(zap, tx, flags);\n\n\tzap_name_t *zn = zap_name_alloc(zap);\n\tfor (int i = 0; i < nchunks; i++) {\n\t\tmzap_ent_phys_t *mze = &mzp->mz_chunk[i];\n\t\tif (mze->mze_name[0] == 0)\n\t\t\tcontinue;\n\t\tdprintf(\"adding %s=%llu\\n\",\n\t\t    mze->mze_name, (u_longlong_t)mze->mze_value);\n\t\tzap_name_init_str(zn, mze->mze_name, 0);\n\t\t \n\t\tVERIFY0(fzap_add_cd(zn, 8, 1, &mze->mze_value, mze->mze_cd,\n\t\t    tag, tx));\n\t\tzap = zn->zn_zap;\t \n\t}\n\tzap_name_free(zn);\n\tvmem_free(mzp, sz);\n\t*zapp = zap;\n\treturn (0);\n}\n\n \nvoid\nmzap_create_impl(dnode_t *dn, int normflags, zap_flags_t flags, dmu_tx_t *tx)\n{\n\tdmu_buf_t *db;\n\n\tVERIFY0(dmu_buf_hold_by_dnode(dn, 0, FTAG, &db, DMU_READ_NO_PREFETCH));\n\n\tdmu_buf_will_dirty(db, tx);\n\tmzap_phys_t *zp = db->db_data;\n\tzp->mz_block_type = ZBT_MICRO;\n\tzp->mz_salt =\n\t    ((uintptr_t)db ^ (uintptr_t)tx ^ (dn->dn_object << 1)) | 1ULL;\n\tzp->mz_normflags = normflags;\n\n\tif (flags != 0) {\n\t\tzap_t *zap;\n\t\t \n\t\tVERIFY0(zap_lockdir_impl(db, FTAG, tx, RW_WRITER,\n\t\t    B_FALSE, B_FALSE, &zap));\n\t\tVERIFY0(mzap_upgrade(&zap, FTAG, tx, flags));\n\t\tzap_unlockdir(zap, FTAG);\n\t} else {\n\t\tdmu_buf_rele(db, FTAG);\n\t}\n}\n\nstatic uint64_t\nzap_create_impl(objset_t *os, int normflags, zap_flags_t flags,\n    dmu_object_type_t ot, int leaf_blockshift, int indirect_blockshift,\n    dmu_object_type_t bonustype, int bonuslen, int dnodesize,\n    dnode_t **allocated_dnode, const void *tag, dmu_tx_t *tx)\n{\n\tuint64_t obj;\n\n\tASSERT3U(DMU_OT_BYTESWAP(ot), ==, DMU_BSWAP_ZAP);\n\n\tif (allocated_dnode == NULL) {\n\t\tdnode_t *dn;\n\t\tobj = dmu_object_alloc_hold(os, ot, 1ULL << leaf_blockshift,\n\t\t    indirect_blockshift, bonustype, bonuslen, dnodesize,\n\t\t    &dn, FTAG, tx);\n\t\tmzap_create_impl(dn, normflags, flags, tx);\n\t\tdnode_rele(dn, FTAG);\n\t} else {\n\t\tobj = dmu_object_alloc_hold(os, ot, 1ULL << leaf_blockshift,\n\t\t    indirect_blockshift, bonustype, bonuslen, dnodesize,\n\t\t    allocated_dnode, tag, tx);\n\t\tmzap_create_impl(*allocated_dnode, normflags, flags, tx);\n\t}\n\n\treturn (obj);\n}\n\nint\nzap_create_claim(objset_t *os, uint64_t obj, dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx)\n{\n\treturn (zap_create_claim_dnsize(os, obj, ot, bonustype, bonuslen,\n\t    0, tx));\n}\n\nint\nzap_create_claim_dnsize(objset_t *os, uint64_t obj, dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, int dnodesize, dmu_tx_t *tx)\n{\n\treturn (zap_create_claim_norm_dnsize(os, obj,\n\t    0, ot, bonustype, bonuslen, dnodesize, tx));\n}\n\nint\nzap_create_claim_norm(objset_t *os, uint64_t obj, int normflags,\n    dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx)\n{\n\treturn (zap_create_claim_norm_dnsize(os, obj, normflags, ot, bonustype,\n\t    bonuslen, 0, tx));\n}\n\nint\nzap_create_claim_norm_dnsize(objset_t *os, uint64_t obj, int normflags,\n    dmu_object_type_t ot, dmu_object_type_t bonustype, int bonuslen,\n    int dnodesize, dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint error;\n\n\tASSERT3U(DMU_OT_BYTESWAP(ot), ==, DMU_BSWAP_ZAP);\n\terror = dmu_object_claim_dnsize(os, obj, ot, 0, bonustype, bonuslen,\n\t    dnodesize, tx);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dnode_hold(os, obj, FTAG, &dn);\n\tif (error != 0)\n\t\treturn (error);\n\n\tmzap_create_impl(dn, normflags, 0, tx);\n\n\tdnode_rele(dn, FTAG);\n\n\treturn (0);\n}\n\nuint64_t\nzap_create(objset_t *os, dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx)\n{\n\treturn (zap_create_norm(os, 0, ot, bonustype, bonuslen, tx));\n}\n\nuint64_t\nzap_create_dnsize(objset_t *os, dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, int dnodesize, dmu_tx_t *tx)\n{\n\treturn (zap_create_norm_dnsize(os, 0, ot, bonustype, bonuslen,\n\t    dnodesize, tx));\n}\n\nuint64_t\nzap_create_norm(objset_t *os, int normflags, dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx)\n{\n\treturn (zap_create_norm_dnsize(os, normflags, ot, bonustype, bonuslen,\n\t    0, tx));\n}\n\nuint64_t\nzap_create_norm_dnsize(objset_t *os, int normflags, dmu_object_type_t ot,\n    dmu_object_type_t bonustype, int bonuslen, int dnodesize, dmu_tx_t *tx)\n{\n\treturn (zap_create_impl(os, normflags, 0, ot, 0, 0,\n\t    bonustype, bonuslen, dnodesize, NULL, NULL, tx));\n}\n\nuint64_t\nzap_create_flags(objset_t *os, int normflags, zap_flags_t flags,\n    dmu_object_type_t ot, int leaf_blockshift, int indirect_blockshift,\n    dmu_object_type_t bonustype, int bonuslen, dmu_tx_t *tx)\n{\n\treturn (zap_create_flags_dnsize(os, normflags, flags, ot,\n\t    leaf_blockshift, indirect_blockshift, bonustype, bonuslen, 0, tx));\n}\n\nuint64_t\nzap_create_flags_dnsize(objset_t *os, int normflags, zap_flags_t flags,\n    dmu_object_type_t ot, int leaf_blockshift, int indirect_blockshift,\n    dmu_object_type_t bonustype, int bonuslen, int dnodesize, dmu_tx_t *tx)\n{\n\treturn (zap_create_impl(os, normflags, flags, ot, leaf_blockshift,\n\t    indirect_blockshift, bonustype, bonuslen, dnodesize, NULL, NULL,\n\t    tx));\n}\n\n \nuint64_t\nzap_create_hold(objset_t *os, int normflags, zap_flags_t flags,\n    dmu_object_type_t ot, int leaf_blockshift, int indirect_blockshift,\n    dmu_object_type_t bonustype, int bonuslen, int dnodesize,\n    dnode_t **allocated_dnode, const void *tag, dmu_tx_t *tx)\n{\n\treturn (zap_create_impl(os, normflags, flags, ot, leaf_blockshift,\n\t    indirect_blockshift, bonustype, bonuslen, dnodesize,\n\t    allocated_dnode, tag, tx));\n}\n\nint\nzap_destroy(objset_t *os, uint64_t zapobj, dmu_tx_t *tx)\n{\n\t \n\n\treturn (dmu_object_free(os, zapobj, tx));\n}\n\nvoid\nzap_evict_sync(void *dbu)\n{\n\tzap_t *zap = dbu;\n\n\trw_destroy(&zap->zap_rwlock);\n\n\tif (zap->zap_ismicro)\n\t\tmze_destroy(zap);\n\telse\n\t\tmutex_destroy(&zap->zap_f.zap_num_entries_mtx);\n\n\tkmem_free(zap, sizeof (zap_t));\n}\n\nint\nzap_count(objset_t *os, uint64_t zapobj, uint64_t *count)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tif (!zap->zap_ismicro) {\n\t\terr = fzap_count(zap, count);\n\t} else {\n\t\t*count = zap->zap_m.zap_num_entries;\n\t}\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\n \nstatic boolean_t\nmzap_normalization_conflict(zap_t *zap, zap_name_t *zn, mzap_ent_t *mze,\n    zfs_btree_index_t *idx)\n{\n\tboolean_t allocdzn = B_FALSE;\n\tmzap_ent_t *other;\n\tzfs_btree_index_t oidx;\n\n\tif (zap->zap_normflags == 0)\n\t\treturn (B_FALSE);\n\n\tfor (other = zfs_btree_prev(&zap->zap_m.zap_tree, idx, &oidx);\n\t    other && other->mze_hash == mze->mze_hash;\n\t    other = zfs_btree_prev(&zap->zap_m.zap_tree, &oidx, &oidx)) {\n\n\t\tif (zn == NULL) {\n\t\t\tzn = zap_name_alloc_str(zap,\n\t\t\t    MZE_PHYS(zap, mze)->mze_name, MT_NORMALIZE);\n\t\t\tallocdzn = B_TRUE;\n\t\t}\n\t\tif (zap_match(zn, MZE_PHYS(zap, other)->mze_name)) {\n\t\t\tif (allocdzn)\n\t\t\t\tzap_name_free(zn);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tfor (other = zfs_btree_next(&zap->zap_m.zap_tree, idx, &oidx);\n\t    other && other->mze_hash == mze->mze_hash;\n\t    other = zfs_btree_next(&zap->zap_m.zap_tree, &oidx, &oidx)) {\n\n\t\tif (zn == NULL) {\n\t\t\tzn = zap_name_alloc_str(zap,\n\t\t\t    MZE_PHYS(zap, mze)->mze_name, MT_NORMALIZE);\n\t\t\tallocdzn = B_TRUE;\n\t\t}\n\t\tif (zap_match(zn, MZE_PHYS(zap, other)->mze_name)) {\n\t\t\tif (allocdzn)\n\t\t\t\tzap_name_free(zn);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\tif (allocdzn)\n\t\tzap_name_free(zn);\n\treturn (B_FALSE);\n}\n\n \n\nint\nzap_lookup(objset_t *os, uint64_t zapobj, const char *name,\n    uint64_t integer_size, uint64_t num_integers, void *buf)\n{\n\treturn (zap_lookup_norm(os, zapobj, name, integer_size,\n\t    num_integers, buf, 0, NULL, 0, NULL));\n}\n\nstatic int\nzap_lookup_impl(zap_t *zap, const char *name,\n    uint64_t integer_size, uint64_t num_integers, void *buf,\n    matchtype_t mt, char *realname, int rn_len,\n    boolean_t *ncp)\n{\n\tint err = 0;\n\n\tzap_name_t *zn = zap_name_alloc_str(zap, name, mt);\n\tif (zn == NULL)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (!zap->zap_ismicro) {\n\t\terr = fzap_lookup(zn, integer_size, num_integers, buf,\n\t\t    realname, rn_len, ncp);\n\t} else {\n\t\tzfs_btree_index_t idx;\n\t\tmzap_ent_t *mze = mze_find(zn, &idx);\n\t\tif (mze == NULL) {\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t} else {\n\t\t\tif (num_integers < 1) {\n\t\t\t\terr = SET_ERROR(EOVERFLOW);\n\t\t\t} else if (integer_size != 8) {\n\t\t\t\terr = SET_ERROR(EINVAL);\n\t\t\t} else {\n\t\t\t\t*(uint64_t *)buf =\n\t\t\t\t    MZE_PHYS(zap, mze)->mze_value;\n\t\t\t\tif (realname != NULL)\n\t\t\t\t\t(void) strlcpy(realname,\n\t\t\t\t\t    MZE_PHYS(zap, mze)->mze_name,\n\t\t\t\t\t    rn_len);\n\t\t\t\tif (ncp) {\n\t\t\t\t\t*ncp = mzap_normalization_conflict(zap,\n\t\t\t\t\t    zn, mze, &idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tzap_name_free(zn);\n\treturn (err);\n}\n\nint\nzap_lookup_norm(objset_t *os, uint64_t zapobj, const char *name,\n    uint64_t integer_size, uint64_t num_integers, void *buf,\n    matchtype_t mt, char *realname, int rn_len,\n    boolean_t *ncp)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_lookup_impl(zap, name, integer_size,\n\t    num_integers, buf, mt, realname, rn_len, ncp);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_prefetch(objset_t *os, uint64_t zapobj, const char *name)\n{\n\tzap_t *zap;\n\tint err;\n\tzap_name_t *zn;\n\n\terr = zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err)\n\t\treturn (err);\n\tzn = zap_name_alloc_str(zap, name, 0);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\tfzap_prefetch(zn);\n\tzap_name_free(zn);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_lookup_by_dnode(dnode_t *dn, const char *name,\n    uint64_t integer_size, uint64_t num_integers, void *buf)\n{\n\treturn (zap_lookup_norm_by_dnode(dn, name, integer_size,\n\t    num_integers, buf, 0, NULL, 0, NULL));\n}\n\nint\nzap_lookup_norm_by_dnode(dnode_t *dn, const char *name,\n    uint64_t integer_size, uint64_t num_integers, void *buf,\n    matchtype_t mt, char *realname, int rn_len,\n    boolean_t *ncp)\n{\n\tzap_t *zap;\n\n\tint err = zap_lockdir_by_dnode(dn, NULL, RW_READER, TRUE, FALSE,\n\t    FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_lookup_impl(zap, name, integer_size,\n\t    num_integers, buf, mt, realname, rn_len, ncp);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_prefetch_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,\n    int key_numints)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_uint64(zap, key, key_numints);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\tfzap_prefetch(zn);\n\tzap_name_free(zn);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_lookup_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,\n    int key_numints, uint64_t integer_size, uint64_t num_integers, void *buf)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_uint64(zap, key, key_numints);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\terr = fzap_lookup(zn, integer_size, num_integers, buf,\n\t    NULL, 0, NULL);\n\tzap_name_free(zn);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_contains(objset_t *os, uint64_t zapobj, const char *name)\n{\n\tint err = zap_lookup_norm(os, zapobj, name, 0,\n\t    0, NULL, 0, NULL, 0, NULL);\n\tif (err == EOVERFLOW || err == EINVAL)\n\t\terr = 0;  \n\treturn (err);\n}\n\nint\nzap_length(objset_t *os, uint64_t zapobj, const char *name,\n    uint64_t *integer_size, uint64_t *num_integers)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_str(zap, name, 0);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\tif (!zap->zap_ismicro) {\n\t\terr = fzap_length(zn, integer_size, num_integers);\n\t} else {\n\t\tzfs_btree_index_t idx;\n\t\tmzap_ent_t *mze = mze_find(zn, &idx);\n\t\tif (mze == NULL) {\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t} else {\n\t\t\tif (integer_size)\n\t\t\t\t*integer_size = 8;\n\t\t\tif (num_integers)\n\t\t\t\t*num_integers = 1;\n\t\t}\n\t}\n\tzap_name_free(zn);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_length_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,\n    int key_numints, uint64_t *integer_size, uint64_t *num_integers)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_uint64(zap, key, key_numints);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terr = fzap_length(zn, integer_size, num_integers);\n\tzap_name_free(zn);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nstatic void\nmzap_addent(zap_name_t *zn, uint64_t value)\n{\n\tzap_t *zap = zn->zn_zap;\n\tuint16_t start = zap->zap_m.zap_alloc_next;\n\n\tASSERT(RW_WRITE_HELD(&zap->zap_rwlock));\n\n#ifdef ZFS_DEBUG\n\tfor (int i = 0; i < zap->zap_m.zap_num_chunks; i++) {\n\t\tmzap_ent_phys_t *mze = &zap_m_phys(zap)->mz_chunk[i];\n\t\tASSERT(strcmp(zn->zn_key_orig, mze->mze_name) != 0);\n\t}\n#endif\n\n\tuint32_t cd = mze_find_unused_cd(zap, zn->zn_hash);\n\t \n\tASSERT(cd < zap_maxcd(zap));\n\nagain:\n\tfor (uint16_t i = start; i < zap->zap_m.zap_num_chunks; i++) {\n\t\tmzap_ent_phys_t *mze = &zap_m_phys(zap)->mz_chunk[i];\n\t\tif (mze->mze_name[0] == 0) {\n\t\t\tmze->mze_value = value;\n\t\t\tmze->mze_cd = cd;\n\t\t\t(void) strlcpy(mze->mze_name, zn->zn_key_orig,\n\t\t\t    sizeof (mze->mze_name));\n\t\t\tzap->zap_m.zap_num_entries++;\n\t\t\tzap->zap_m.zap_alloc_next = i+1;\n\t\t\tif (zap->zap_m.zap_alloc_next ==\n\t\t\t    zap->zap_m.zap_num_chunks)\n\t\t\t\tzap->zap_m.zap_alloc_next = 0;\n\t\t\tmze_insert(zap, i, zn->zn_hash);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (start != 0) {\n\t\tstart = 0;\n\t\tgoto again;\n\t}\n\tcmn_err(CE_PANIC, \"out of entries!\");\n}\n\nstatic int\nzap_add_impl(zap_t *zap, const char *key,\n    int integer_size, uint64_t num_integers,\n    const void *val, dmu_tx_t *tx, const void *tag)\n{\n\tconst uint64_t *intval = val;\n\tint err = 0;\n\n\tzap_name_t *zn = zap_name_alloc_str(zap, key, 0);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, tag);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\tif (!zap->zap_ismicro) {\n\t\terr = fzap_add(zn, integer_size, num_integers, val, tag, tx);\n\t\tzap = zn->zn_zap;\t \n\t} else if (integer_size != 8 || num_integers != 1 ||\n\t    strlen(key) >= MZAP_NAME_LEN ||\n\t    !mze_canfit_fzap_leaf(zn, zn->zn_hash)) {\n\t\terr = mzap_upgrade(&zn->zn_zap, tag, tx, 0);\n\t\tif (err == 0) {\n\t\t\terr = fzap_add(zn, integer_size, num_integers, val,\n\t\t\t    tag, tx);\n\t\t}\n\t\tzap = zn->zn_zap;\t \n\t} else {\n\t\tzfs_btree_index_t idx;\n\t\tif (mze_find(zn, &idx) != NULL) {\n\t\t\terr = SET_ERROR(EEXIST);\n\t\t} else {\n\t\t\tmzap_addent(zn, *intval);\n\t\t}\n\t}\n\tASSERT(zap == zn->zn_zap);\n\tzap_name_free(zn);\n\tif (zap != NULL)\t \n\t\tzap_unlockdir(zap, tag);\n\treturn (err);\n}\n\nint\nzap_add(objset_t *os, uint64_t zapobj, const char *key,\n    int integer_size, uint64_t num_integers,\n    const void *val, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\tint err;\n\n\terr = zap_lockdir(os, zapobj, tx, RW_WRITER, TRUE, TRUE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_add_impl(zap, key, integer_size, num_integers, val, tx, FTAG);\n\t \n\treturn (err);\n}\n\nint\nzap_add_by_dnode(dnode_t *dn, const char *key,\n    int integer_size, uint64_t num_integers,\n    const void *val, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\tint err;\n\n\terr = zap_lockdir_by_dnode(dn, tx, RW_WRITER, TRUE, TRUE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zap_add_impl(zap, key, integer_size, num_integers, val, tx, FTAG);\n\t \n\treturn (err);\n}\n\nint\nzap_add_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,\n    int key_numints, int integer_size, uint64_t num_integers,\n    const void *val, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, tx, RW_WRITER, TRUE, TRUE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_uint64(zap, key, key_numints);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terr = fzap_add(zn, integer_size, num_integers, val, FTAG, tx);\n\tzap = zn->zn_zap;\t \n\tzap_name_free(zn);\n\tif (zap != NULL)\t \n\t\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_update(objset_t *os, uint64_t zapobj, const char *name,\n    int integer_size, uint64_t num_integers, const void *val, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\tconst uint64_t *intval = val;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, tx, RW_WRITER, TRUE, TRUE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_str(zap, name, 0);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\tif (!zap->zap_ismicro) {\n\t\terr = fzap_update(zn, integer_size, num_integers, val,\n\t\t    FTAG, tx);\n\t\tzap = zn->zn_zap;\t \n\t} else if (integer_size != 8 || num_integers != 1 ||\n\t    strlen(name) >= MZAP_NAME_LEN) {\n\t\tdprintf(\"upgrading obj %llu: intsz=%u numint=%llu name=%s\\n\",\n\t\t    (u_longlong_t)zapobj, integer_size,\n\t\t    (u_longlong_t)num_integers, name);\n\t\terr = mzap_upgrade(&zn->zn_zap, FTAG, tx, 0);\n\t\tif (err == 0) {\n\t\t\terr = fzap_update(zn, integer_size, num_integers,\n\t\t\t    val, FTAG, tx);\n\t\t}\n\t\tzap = zn->zn_zap;\t \n\t} else {\n\t\tzfs_btree_index_t idx;\n\t\tmzap_ent_t *mze = mze_find(zn, &idx);\n\t\tif (mze != NULL) {\n\t\t\tMZE_PHYS(zap, mze)->mze_value = *intval;\n\t\t} else {\n\t\t\tmzap_addent(zn, *intval);\n\t\t}\n\t}\n\tASSERT(zap == zn->zn_zap);\n\tzap_name_free(zn);\n\tif (zap != NULL)\t \n\t\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_update_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,\n    int key_numints,\n    int integer_size, uint64_t num_integers, const void *val, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, tx, RW_WRITER, TRUE, TRUE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_uint64(zap, key, key_numints);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terr = fzap_update(zn, integer_size, num_integers, val, FTAG, tx);\n\tzap = zn->zn_zap;\t \n\tzap_name_free(zn);\n\tif (zap != NULL)\t \n\t\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_remove(objset_t *os, uint64_t zapobj, const char *name, dmu_tx_t *tx)\n{\n\treturn (zap_remove_norm(os, zapobj, name, 0, tx));\n}\n\nstatic int\nzap_remove_impl(zap_t *zap, const char *name,\n    matchtype_t mt, dmu_tx_t *tx)\n{\n\tint err = 0;\n\n\tzap_name_t *zn = zap_name_alloc_str(zap, name, mt);\n\tif (zn == NULL)\n\t\treturn (SET_ERROR(ENOTSUP));\n\tif (!zap->zap_ismicro) {\n\t\terr = fzap_remove(zn, tx);\n\t} else {\n\t\tzfs_btree_index_t idx;\n\t\tmzap_ent_t *mze = mze_find(zn, &idx);\n\t\tif (mze == NULL) {\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t} else {\n\t\t\tzap->zap_m.zap_num_entries--;\n\t\t\tmemset(MZE_PHYS(zap, mze), 0, sizeof (mzap_ent_phys_t));\n\t\t\tzfs_btree_remove_idx(&zap->zap_m.zap_tree, &idx);\n\t\t}\n\t}\n\tzap_name_free(zn);\n\treturn (err);\n}\n\nint\nzap_remove_norm(objset_t *os, uint64_t zapobj, const char *name,\n    matchtype_t mt, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\tint err;\n\n\terr = zap_lockdir(os, zapobj, tx, RW_WRITER, TRUE, FALSE, FTAG, &zap);\n\tif (err)\n\t\treturn (err);\n\terr = zap_remove_impl(zap, name, mt, tx);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_remove_by_dnode(dnode_t *dn, const char *name, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\tint err;\n\n\terr = zap_lockdir_by_dnode(dn, tx, RW_WRITER, TRUE, FALSE, FTAG, &zap);\n\tif (err)\n\t\treturn (err);\n\terr = zap_remove_impl(zap, name, 0, tx);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\nint\nzap_remove_uint64(objset_t *os, uint64_t zapobj, const uint64_t *key,\n    int key_numints, dmu_tx_t *tx)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, tx, RW_WRITER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\tzap_name_t *zn = zap_name_alloc_uint64(zap, key, key_numints);\n\tif (zn == NULL) {\n\t\tzap_unlockdir(zap, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terr = fzap_remove(zn, tx);\n\tzap_name_free(zn);\n\tzap_unlockdir(zap, FTAG);\n\treturn (err);\n}\n\n \n\nstatic void\nzap_cursor_init_impl(zap_cursor_t *zc, objset_t *os, uint64_t zapobj,\n    uint64_t serialized, boolean_t prefetch)\n{\n\tzc->zc_objset = os;\n\tzc->zc_zap = NULL;\n\tzc->zc_leaf = NULL;\n\tzc->zc_zapobj = zapobj;\n\tzc->zc_serialized = serialized;\n\tzc->zc_hash = 0;\n\tzc->zc_cd = 0;\n\tzc->zc_prefetch = prefetch;\n}\nvoid\nzap_cursor_init_serialized(zap_cursor_t *zc, objset_t *os, uint64_t zapobj,\n    uint64_t serialized)\n{\n\tzap_cursor_init_impl(zc, os, zapobj, serialized, B_TRUE);\n}\n\n \nvoid\nzap_cursor_init(zap_cursor_t *zc, objset_t *os, uint64_t zapobj)\n{\n\tzap_cursor_init_impl(zc, os, zapobj, 0, B_TRUE);\n}\n\n \nvoid\nzap_cursor_init_noprefetch(zap_cursor_t *zc, objset_t *os, uint64_t zapobj)\n{\n\tzap_cursor_init_impl(zc, os, zapobj, 0, B_FALSE);\n}\n\nvoid\nzap_cursor_fini(zap_cursor_t *zc)\n{\n\tif (zc->zc_zap) {\n\t\trw_enter(&zc->zc_zap->zap_rwlock, RW_READER);\n\t\tzap_unlockdir(zc->zc_zap, NULL);\n\t\tzc->zc_zap = NULL;\n\t}\n\tif (zc->zc_leaf) {\n\t\trw_enter(&zc->zc_leaf->l_rwlock, RW_READER);\n\t\tzap_put_leaf(zc->zc_leaf);\n\t\tzc->zc_leaf = NULL;\n\t}\n\tzc->zc_objset = NULL;\n}\n\nuint64_t\nzap_cursor_serialize(zap_cursor_t *zc)\n{\n\tif (zc->zc_hash == -1ULL)\n\t\treturn (-1ULL);\n\tif (zc->zc_zap == NULL)\n\t\treturn (zc->zc_serialized);\n\tASSERT((zc->zc_hash & zap_maxcd(zc->zc_zap)) == 0);\n\tASSERT(zc->zc_cd < zap_maxcd(zc->zc_zap));\n\n\t \n\treturn ((zc->zc_hash >> (64 - zap_hashbits(zc->zc_zap))) |\n\t    ((uint64_t)zc->zc_cd << zap_hashbits(zc->zc_zap)));\n}\n\nint\nzap_cursor_retrieve(zap_cursor_t *zc, zap_attribute_t *za)\n{\n\tint err;\n\n\tif (zc->zc_hash == -1ULL)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tif (zc->zc_zap == NULL) {\n\t\tint hb;\n\t\terr = zap_lockdir(zc->zc_objset, zc->zc_zapobj, NULL,\n\t\t    RW_READER, TRUE, FALSE, NULL, &zc->zc_zap);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\t \n\t\tASSERT(zc->zc_hash == 0);\n\t\thb = zap_hashbits(zc->zc_zap);\n\t\tzc->zc_hash = zc->zc_serialized << (64 - hb);\n\t\tzc->zc_cd += zc->zc_serialized >> hb;\n\t\tif (zc->zc_cd >= zap_maxcd(zc->zc_zap))  \n\t\t\tzc->zc_cd = 0;\n\t} else {\n\t\trw_enter(&zc->zc_zap->zap_rwlock, RW_READER);\n\t}\n\tif (!zc->zc_zap->zap_ismicro) {\n\t\terr = fzap_cursor_retrieve(zc->zc_zap, zc, za);\n\t} else {\n\t\tzfs_btree_index_t idx;\n\t\tmzap_ent_t mze_tofind;\n\n\t\tmze_tofind.mze_hash = zc->zc_hash >> 32;\n\t\tmze_tofind.mze_cd = zc->zc_cd;\n\n\t\tmzap_ent_t *mze = zfs_btree_find(&zc->zc_zap->zap_m.zap_tree,\n\t\t    &mze_tofind, &idx);\n\t\tif (mze == NULL) {\n\t\t\tmze = zfs_btree_next(&zc->zc_zap->zap_m.zap_tree,\n\t\t\t    &idx, &idx);\n\t\t}\n\t\tif (mze) {\n\t\t\tmzap_ent_phys_t *mzep = MZE_PHYS(zc->zc_zap, mze);\n\t\t\tASSERT3U(mze->mze_cd, ==, mzep->mze_cd);\n\t\t\tza->za_normalization_conflict =\n\t\t\t    mzap_normalization_conflict(zc->zc_zap, NULL,\n\t\t\t    mze, &idx);\n\t\t\tza->za_integer_length = 8;\n\t\t\tza->za_num_integers = 1;\n\t\t\tza->za_first_integer = mzep->mze_value;\n\t\t\t(void) strlcpy(za->za_name, mzep->mze_name,\n\t\t\t    sizeof (za->za_name));\n\t\t\tzc->zc_hash = (uint64_t)mze->mze_hash << 32;\n\t\t\tzc->zc_cd = mze->mze_cd;\n\t\t\terr = 0;\n\t\t} else {\n\t\t\tzc->zc_hash = -1ULL;\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t}\n\t}\n\trw_exit(&zc->zc_zap->zap_rwlock);\n\treturn (err);\n}\n\nvoid\nzap_cursor_advance(zap_cursor_t *zc)\n{\n\tif (zc->zc_hash == -1ULL)\n\t\treturn;\n\tzc->zc_cd++;\n}\n\nint\nzap_get_stats(objset_t *os, uint64_t zapobj, zap_stats_t *zs)\n{\n\tzap_t *zap;\n\n\tint err =\n\t    zap_lockdir(os, zapobj, NULL, RW_READER, TRUE, FALSE, FTAG, &zap);\n\tif (err != 0)\n\t\treturn (err);\n\n\tmemset(zs, 0, sizeof (zap_stats_t));\n\n\tif (zap->zap_ismicro) {\n\t\tzs->zs_blocksize = zap->zap_dbuf->db_size;\n\t\tzs->zs_num_entries = zap->zap_m.zap_num_entries;\n\t\tzs->zs_num_blocks = 1;\n\t} else {\n\t\tfzap_get_stats(zap, zs);\n\t}\n\tzap_unlockdir(zap, FTAG);\n\treturn (0);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zap_create);\nEXPORT_SYMBOL(zap_create_dnsize);\nEXPORT_SYMBOL(zap_create_norm);\nEXPORT_SYMBOL(zap_create_norm_dnsize);\nEXPORT_SYMBOL(zap_create_flags);\nEXPORT_SYMBOL(zap_create_flags_dnsize);\nEXPORT_SYMBOL(zap_create_claim);\nEXPORT_SYMBOL(zap_create_claim_norm);\nEXPORT_SYMBOL(zap_create_claim_norm_dnsize);\nEXPORT_SYMBOL(zap_create_hold);\nEXPORT_SYMBOL(zap_destroy);\nEXPORT_SYMBOL(zap_lookup);\nEXPORT_SYMBOL(zap_lookup_by_dnode);\nEXPORT_SYMBOL(zap_lookup_norm);\nEXPORT_SYMBOL(zap_lookup_uint64);\nEXPORT_SYMBOL(zap_contains);\nEXPORT_SYMBOL(zap_prefetch);\nEXPORT_SYMBOL(zap_prefetch_uint64);\nEXPORT_SYMBOL(zap_add);\nEXPORT_SYMBOL(zap_add_by_dnode);\nEXPORT_SYMBOL(zap_add_uint64);\nEXPORT_SYMBOL(zap_update);\nEXPORT_SYMBOL(zap_update_uint64);\nEXPORT_SYMBOL(zap_length);\nEXPORT_SYMBOL(zap_length_uint64);\nEXPORT_SYMBOL(zap_remove);\nEXPORT_SYMBOL(zap_remove_by_dnode);\nEXPORT_SYMBOL(zap_remove_norm);\nEXPORT_SYMBOL(zap_remove_uint64);\nEXPORT_SYMBOL(zap_count);\nEXPORT_SYMBOL(zap_value_search);\nEXPORT_SYMBOL(zap_join);\nEXPORT_SYMBOL(zap_join_increment);\nEXPORT_SYMBOL(zap_add_int);\nEXPORT_SYMBOL(zap_remove_int);\nEXPORT_SYMBOL(zap_lookup_int);\nEXPORT_SYMBOL(zap_increment_int);\nEXPORT_SYMBOL(zap_add_int_key);\nEXPORT_SYMBOL(zap_lookup_int_key);\nEXPORT_SYMBOL(zap_increment);\nEXPORT_SYMBOL(zap_cursor_init);\nEXPORT_SYMBOL(zap_cursor_fini);\nEXPORT_SYMBOL(zap_cursor_retrieve);\nEXPORT_SYMBOL(zap_cursor_advance);\nEXPORT_SYMBOL(zap_cursor_serialize);\nEXPORT_SYMBOL(zap_cursor_init_serialized);\nEXPORT_SYMBOL(zap_get_stats);\n\n \nZFS_MODULE_PARAM(zfs, , zap_micro_max_size, INT, ZMOD_RW,\n\t\"Maximum micro ZAP size, before converting to a fat ZAP, in bytes\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}