{
  "module_name": "zvol.c",
  "hash_id": "24ac4bb25787ab2690dc9923a693398b3e66376912b93650a4e4ead29ea866ff",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zvol.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/dataset_kstats.h>\n#include <sys/dbuf.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_dir.h>\n#include <sys/zap.h>\n#include <sys/zfeature.h>\n#include <sys/zil_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/zio.h>\n#include <sys/zfs_rlock.h>\n#include <sys/spa_impl.h>\n#include <sys/zvol.h>\n#include <sys/zvol_impl.h>\n\nunsigned int zvol_inhibit_dev = 0;\nunsigned int zvol_volmode = ZFS_VOLMODE_GEOM;\n\nstruct hlist_head *zvol_htable;\nstatic list_t zvol_state_list;\nkrwlock_t zvol_state_lock;\n\ntypedef enum {\n\tZVOL_ASYNC_REMOVE_MINORS,\n\tZVOL_ASYNC_RENAME_MINORS,\n\tZVOL_ASYNC_SET_SNAPDEV,\n\tZVOL_ASYNC_SET_VOLMODE,\n\tZVOL_ASYNC_MAX\n} zvol_async_op_t;\n\ntypedef struct {\n\tzvol_async_op_t op;\n\tchar name1[MAXNAMELEN];\n\tchar name2[MAXNAMELEN];\n\tuint64_t value;\n} zvol_task_t;\n\nuint64_t\nzvol_name_hash(const char *name)\n{\n\tint i;\n\tuint64_t crc = -1ULL;\n\tconst uint8_t *p = (const uint8_t *)name;\n\tASSERT(zfs_crc64_table[128] == ZFS_CRC64_POLY);\n\tfor (i = 0; i < MAXNAMELEN - 1 && *p; i++, p++) {\n\t\tcrc = (crc >> 8) ^ zfs_crc64_table[(crc ^ (*p)) & 0xFF];\n\t}\n\treturn (crc);\n}\n\n \nzvol_state_t *\nzvol_find_by_name_hash(const char *name, uint64_t hash, int mode)\n{\n\tzvol_state_t *zv;\n\tstruct hlist_node *p = NULL;\n\n\trw_enter(&zvol_state_lock, RW_READER);\n\thlist_for_each(p, ZVOL_HT_HEAD(hash)) {\n\t\tzv = hlist_entry(p, zvol_state_t, zv_hlink);\n\t\tmutex_enter(&zv->zv_state_lock);\n\t\tif (zv->zv_hash == hash &&\n\t\t    strncmp(zv->zv_name, name, MAXNAMELEN) == 0) {\n\t\t\t \n\t\t\tif (mode != RW_NONE &&\n\t\t\t    !rw_tryenter(&zv->zv_suspend_lock, mode)) {\n\t\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\t\trw_enter(&zv->zv_suspend_lock, mode);\n\t\t\t\tmutex_enter(&zv->zv_state_lock);\n\t\t\t\t \n\t\t\t\tASSERT(zv->zv_hash == hash &&\n\t\t\t\t    strncmp(zv->zv_name, name, MAXNAMELEN)\n\t\t\t\t    == 0);\n\t\t\t}\n\t\t\trw_exit(&zvol_state_lock);\n\t\t\treturn (zv);\n\t\t}\n\t\tmutex_exit(&zv->zv_state_lock);\n\t}\n\trw_exit(&zvol_state_lock);\n\n\treturn (NULL);\n}\n\n \nstatic zvol_state_t *\nzvol_find_by_name(const char *name, int mode)\n{\n\treturn (zvol_find_by_name_hash(name, zvol_name_hash(name), mode));\n}\n\n \nvoid\nzvol_create_cb(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx)\n{\n\tzfs_creat_t *zct = arg;\n\tnvlist_t *nvprops = zct->zct_props;\n\tint error;\n\tuint64_t volblocksize, volsize;\n\n\tVERIFY(nvlist_lookup_uint64(nvprops,\n\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE), &volsize) == 0);\n\tif (nvlist_lookup_uint64(nvprops,\n\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE), &volblocksize) != 0)\n\t\tvolblocksize = zfs_prop_default_numeric(ZFS_PROP_VOLBLOCKSIZE);\n\n\t \n\tVERIFY(nvlist_remove_all(nvprops,\n\t    zfs_prop_to_name(ZFS_PROP_VOLSIZE)) == 0);\n\t(void) nvlist_remove_all(nvprops,\n\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE));\n\n\terror = dmu_object_claim(os, ZVOL_OBJ, DMU_OT_ZVOL, volblocksize,\n\t    DMU_OT_NONE, 0, tx);\n\tASSERT(error == 0);\n\n\terror = zap_create_claim(os, ZVOL_ZAP_OBJ, DMU_OT_ZVOL_PROP,\n\t    DMU_OT_NONE, 0, tx);\n\tASSERT(error == 0);\n\n\terror = zap_update(os, ZVOL_ZAP_OBJ, \"size\", 8, 1, &volsize, tx);\n\tASSERT(error == 0);\n}\n\n \nint\nzvol_get_stats(objset_t *os, nvlist_t *nv)\n{\n\tint error;\n\tdmu_object_info_t *doi;\n\tuint64_t val;\n\n\terror = zap_lookup(os, ZVOL_ZAP_OBJ, \"size\", 8, 1, &val);\n\tif (error)\n\t\treturn (SET_ERROR(error));\n\n\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_VOLSIZE, val);\n\tdoi = kmem_alloc(sizeof (dmu_object_info_t), KM_SLEEP);\n\terror = dmu_object_info(os, ZVOL_OBJ, doi);\n\n\tif (error == 0) {\n\t\tdsl_prop_nvlist_add_uint64(nv, ZFS_PROP_VOLBLOCKSIZE,\n\t\t    doi->doi_data_block_size);\n\t}\n\n\tkmem_free(doi, sizeof (dmu_object_info_t));\n\n\treturn (SET_ERROR(error));\n}\n\n \nint\nzvol_check_volsize(uint64_t volsize, uint64_t blocksize)\n{\n\tif (volsize == 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (volsize % blocksize != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n#ifdef _ILP32\n\tif (volsize - 1 > SPEC_MAXOFFSET_T)\n\t\treturn (SET_ERROR(EOVERFLOW));\n#endif\n\treturn (0);\n}\n\n \nstatic int\nzvol_update_volsize(uint64_t volsize, objset_t *os)\n{\n\tdmu_tx_t *tx;\n\tint error;\n\tuint64_t txg;\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_zap(tx, ZVOL_ZAP_OBJ, TRUE, NULL);\n\tdmu_tx_mark_netfree(tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (SET_ERROR(error));\n\t}\n\ttxg = dmu_tx_get_txg(tx);\n\n\terror = zap_update(os, ZVOL_ZAP_OBJ, \"size\", 8, 1,\n\t    &volsize, tx);\n\tdmu_tx_commit(tx);\n\n\ttxg_wait_synced(dmu_objset_pool(os), txg);\n\n\tif (error == 0)\n\t\terror = dmu_free_long_range(os,\n\t\t    ZVOL_OBJ, volsize, DMU_OBJECT_END);\n\n\treturn (error);\n}\n\n \nint\nzvol_set_volsize(const char *name, uint64_t volsize)\n{\n\tobjset_t *os = NULL;\n\tuint64_t readonly;\n\tint error;\n\tboolean_t owned = B_FALSE;\n\n\terror = dsl_prop_get_integer(name,\n\t    zfs_prop_to_name(ZFS_PROP_READONLY), &readonly, NULL);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\tif (readonly)\n\t\treturn (SET_ERROR(EROFS));\n\n\tzvol_state_t *zv = zvol_find_by_name(name, RW_READER);\n\n\tASSERT(zv == NULL || (MUTEX_HELD(&zv->zv_state_lock) &&\n\t    RW_READ_HELD(&zv->zv_suspend_lock)));\n\n\tif (zv == NULL || zv->zv_objset == NULL) {\n\t\tif (zv != NULL)\n\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\tif ((error = dmu_objset_own(name, DMU_OST_ZVOL, B_FALSE, B_TRUE,\n\t\t    FTAG, &os)) != 0) {\n\t\t\tif (zv != NULL)\n\t\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\treturn (SET_ERROR(error));\n\t\t}\n\t\towned = B_TRUE;\n\t\tif (zv != NULL)\n\t\t\tzv->zv_objset = os;\n\t} else {\n\t\tos = zv->zv_objset;\n\t}\n\n\tdmu_object_info_t *doi = kmem_alloc(sizeof (*doi), KM_SLEEP);\n\n\tif ((error = dmu_object_info(os, ZVOL_OBJ, doi)) ||\n\t    (error = zvol_check_volsize(volsize, doi->doi_data_block_size)))\n\t\tgoto out;\n\n\terror = zvol_update_volsize(volsize, os);\n\tif (error == 0 && zv != NULL) {\n\t\tzv->zv_volsize = volsize;\n\t\tzv->zv_changed = 1;\n\t}\nout:\n\tkmem_free(doi, sizeof (dmu_object_info_t));\n\n\tif (owned) {\n\t\tdmu_objset_disown(os, B_TRUE, FTAG);\n\t\tif (zv != NULL)\n\t\t\tzv->zv_objset = NULL;\n\t} else {\n\t\trw_exit(&zv->zv_suspend_lock);\n\t}\n\n\tif (zv != NULL)\n\t\tmutex_exit(&zv->zv_state_lock);\n\n\tif (error == 0 && zv != NULL)\n\t\tzvol_os_update_volsize(zv, volsize);\n\n\treturn (SET_ERROR(error));\n}\n\n \nint\nzvol_check_volblocksize(const char *name, uint64_t volblocksize)\n{\n\t \n\tif (volblocksize > SPA_OLD_MAXBLOCKSIZE) {\n\t\tspa_t *spa;\n\t\tint error;\n\n\t\tif ((error = spa_open(name, &spa, FTAG)) != 0)\n\t\t\treturn (error);\n\n\t\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_LARGE_BLOCKS)) {\n\t\t\tspa_close(spa, FTAG);\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t}\n\n\t\t \n\t\tif (volblocksize > zfs_max_recordsize)\n\t\t\treturn (SET_ERROR(EDOM));\n\n\t\tspa_close(spa, FTAG);\n\t}\n\n\tif (volblocksize < SPA_MINBLOCKSIZE ||\n\t    volblocksize > SPA_MAXBLOCKSIZE ||\n\t    !ISP2(volblocksize))\n\t\treturn (SET_ERROR(EDOM));\n\n\treturn (0);\n}\n\n \nstatic int\nzvol_replay_truncate(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzvol_state_t *zv = arg1;\n\tlr_truncate_t *lr = arg2;\n\tuint64_t offset, length;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\toffset = lr->lr_offset;\n\tlength = lr->lr_length;\n\n\tdmu_tx_t *tx = dmu_tx_create(zv->zv_objset);\n\tdmu_tx_mark_netfree(tx);\n\tint error = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error != 0) {\n\t\tdmu_tx_abort(tx);\n\t} else {\n\t\t(void) zil_replaying(zv->zv_zilog, tx);\n\t\tdmu_tx_commit(tx);\n\t\terror = dmu_free_long_range(zv->zv_objset, ZVOL_OBJ, offset,\n\t\t    length);\n\t}\n\n\treturn (error);\n}\n\n \nstatic int\nzvol_replay_write(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzvol_state_t *zv = arg1;\n\tlr_write_t *lr = arg2;\n\tobjset_t *os = zv->zv_objset;\n\tchar *data = (char *)(lr + 1);   \n\tuint64_t offset, length;\n\tdmu_tx_t *tx;\n\tint error;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\toffset = lr->lr_offset;\n\tlength = lr->lr_length;\n\n\t \n\tif (lr->lr_common.lrc_reclen == sizeof (lr_write_t)) {\n\t\tuint64_t blocksize = BP_GET_LSIZE(&lr->lr_blkptr);\n\t\tif (length < blocksize) {\n\t\t\toffset -= offset % blocksize;\n\t\t\tlength = blocksize;\n\t\t}\n\t}\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_write(tx, ZVOL_OBJ, offset, length);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t} else {\n\t\tdmu_write(os, ZVOL_OBJ, offset, length, data, tx);\n\t\t(void) zil_replaying(zv->zv_zilog, tx);\n\t\tdmu_tx_commit(tx);\n\t}\n\n\treturn (error);\n}\n\n \nstatic int\nzvol_replay_clone_range(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\tzvol_state_t *zv = arg1;\n\tobjset_t *os = zv->zv_objset;\n\tlr_clone_range_t *lr = arg2;\n\tblkptr_t *bp;\n\tdmu_tx_t *tx;\n\tspa_t *spa;\n\tuint_t ii;\n\tint error;\n\n\tdmu_objset_name(os, name);\n\tcmn_err(CE_WARN, \"ZFS dropping block cloning transaction for %s.\",\n\t    name);\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\ttx = dmu_tx_create(os);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (error);\n\t}\n\n\tspa = os->os_spa;\n\n\tfor (ii = 0; ii < lr->lr_nbps; ii++) {\n\t\tbp = &lr->lr_bps[ii];\n\n\t\tif (!BP_IS_HOLE(bp)) {\n\t\t\tzio_free(spa, dmu_tx_get_txg(tx), bp);\n\t\t}\n\t}\n\n\t(void) zil_replaying(zv->zv_zilog, tx);\n\tdmu_tx_commit(tx);\n\n\treturn (0);\n}\n\nstatic int\nzvol_replay_err(void *arg1, void *arg2, boolean_t byteswap)\n{\n\t(void) arg1, (void) arg2, (void) byteswap;\n\treturn (SET_ERROR(ENOTSUP));\n}\n\n \nzil_replay_func_t *const zvol_replay_vector[TX_MAX_TYPE] = {\n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_write,\t \n\tzvol_replay_truncate,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_err,\t \n\tzvol_replay_clone_range\t \n};\n\n \nstatic const ssize_t zvol_immediate_write_sz = 32768;\n\nvoid\nzvol_log_write(zvol_state_t *zv, dmu_tx_t *tx, uint64_t offset,\n    uint64_t size, int sync)\n{\n\tuint32_t blocksize = zv->zv_volblocksize;\n\tzilog_t *zilog = zv->zv_zilog;\n\titx_wr_state_t write_state;\n\tuint64_t sz = size;\n\n\tif (zil_replaying(zilog, tx))\n\t\treturn;\n\n\tif (zilog->zl_logbias == ZFS_LOGBIAS_THROUGHPUT)\n\t\twrite_state = WR_INDIRECT;\n\telse if (!spa_has_slogs(zilog->zl_spa) &&\n\t    size >= blocksize && blocksize > zvol_immediate_write_sz)\n\t\twrite_state = WR_INDIRECT;\n\telse if (sync)\n\t\twrite_state = WR_COPIED;\n\telse\n\t\twrite_state = WR_NEED_COPY;\n\n\twhile (size) {\n\t\titx_t *itx;\n\t\tlr_write_t *lr;\n\t\titx_wr_state_t wr_state = write_state;\n\t\tssize_t len = size;\n\n\t\tif (wr_state == WR_COPIED && size > zil_max_copied_data(zilog))\n\t\t\twr_state = WR_NEED_COPY;\n\t\telse if (wr_state == WR_INDIRECT)\n\t\t\tlen = MIN(blocksize - P2PHASE(offset, blocksize), size);\n\n\t\titx = zil_itx_create(TX_WRITE, sizeof (*lr) +\n\t\t    (wr_state == WR_COPIED ? len : 0));\n\t\tlr = (lr_write_t *)&itx->itx_lr;\n\t\tif (wr_state == WR_COPIED && dmu_read_by_dnode(zv->zv_dn,\n\t\t    offset, len, lr+1, DMU_READ_NO_PREFETCH) != 0) {\n\t\t\tzil_itx_destroy(itx);\n\t\t\titx = zil_itx_create(TX_WRITE, sizeof (*lr));\n\t\t\tlr = (lr_write_t *)&itx->itx_lr;\n\t\t\twr_state = WR_NEED_COPY;\n\t\t}\n\n\t\titx->itx_wr_state = wr_state;\n\t\tlr->lr_foid = ZVOL_OBJ;\n\t\tlr->lr_offset = offset;\n\t\tlr->lr_length = len;\n\t\tlr->lr_blkoff = 0;\n\t\tBP_ZERO(&lr->lr_blkptr);\n\n\t\titx->itx_private = zv;\n\t\titx->itx_sync = sync;\n\n\t\t(void) zil_itx_assign(zilog, itx, tx);\n\n\t\toffset += len;\n\t\tsize -= len;\n\t}\n\n\tif (write_state == WR_COPIED || write_state == WR_NEED_COPY) {\n\t\tdsl_pool_wrlog_count(zilog->zl_dmu_pool, sz, tx->tx_txg);\n\t}\n}\n\n \nvoid\nzvol_log_truncate(zvol_state_t *zv, dmu_tx_t *tx, uint64_t off, uint64_t len,\n    boolean_t sync)\n{\n\titx_t *itx;\n\tlr_truncate_t *lr;\n\tzilog_t *zilog = zv->zv_zilog;\n\n\tif (zil_replaying(zilog, tx))\n\t\treturn;\n\n\titx = zil_itx_create(TX_TRUNCATE, sizeof (*lr));\n\tlr = (lr_truncate_t *)&itx->itx_lr;\n\tlr->lr_foid = ZVOL_OBJ;\n\tlr->lr_offset = off;\n\tlr->lr_length = len;\n\n\titx->itx_sync = sync;\n\tzil_itx_assign(zilog, itx, tx);\n}\n\n\nstatic void\nzvol_get_done(zgd_t *zgd, int error)\n{\n\t(void) error;\n\tif (zgd->zgd_db)\n\t\tdmu_buf_rele(zgd->zgd_db, zgd);\n\n\tzfs_rangelock_exit(zgd->zgd_lr);\n\n\tkmem_free(zgd, sizeof (zgd_t));\n}\n\n \nint\nzvol_get_data(void *arg, uint64_t arg2, lr_write_t *lr, char *buf,\n    struct lwb *lwb, zio_t *zio)\n{\n\tzvol_state_t *zv = arg;\n\tuint64_t offset = lr->lr_offset;\n\tuint64_t size = lr->lr_length;\n\tdmu_buf_t *db;\n\tzgd_t *zgd;\n\tint error;\n\n\tASSERT3P(lwb, !=, NULL);\n\tASSERT3U(size, !=, 0);\n\n\tzgd = kmem_zalloc(sizeof (zgd_t), KM_SLEEP);\n\tzgd->zgd_lwb = lwb;\n\n\t \n\tif (buf != NULL) {  \n\t\tzgd->zgd_lr = zfs_rangelock_enter(&zv->zv_rangelock, offset,\n\t\t    size, RL_READER);\n\t\terror = dmu_read_by_dnode(zv->zv_dn, offset, size, buf,\n\t\t    DMU_READ_NO_PREFETCH);\n\t} else {  \n\t\tASSERT3P(zio, !=, NULL);\n\t\t \n\t\tsize = zv->zv_volblocksize;\n\t\toffset = P2ALIGN_TYPED(offset, size, uint64_t);\n\t\tzgd->zgd_lr = zfs_rangelock_enter(&zv->zv_rangelock, offset,\n\t\t    size, RL_READER);\n\t\terror = dmu_buf_hold_noread_by_dnode(zv->zv_dn, offset, zgd,\n\t\t    &db);\n\t\tif (error == 0) {\n\t\t\tblkptr_t *bp = &lr->lr_blkptr;\n\n\t\t\tzgd->zgd_db = db;\n\t\t\tzgd->zgd_bp = bp;\n\n\t\t\tASSERT(db != NULL);\n\t\t\tASSERT(db->db_offset == offset);\n\t\t\tASSERT(db->db_size == size);\n\n\t\t\terror = dmu_sync(zio, lr->lr_common.lrc_txg,\n\t\t\t    zvol_get_done, zgd);\n\n\t\t\tif (error == 0)\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\tzvol_get_done(zgd, error);\n\n\treturn (SET_ERROR(error));\n}\n\n \n\nvoid\nzvol_insert(zvol_state_t *zv)\n{\n\tASSERT(RW_WRITE_HELD(&zvol_state_lock));\n\tlist_insert_head(&zvol_state_list, zv);\n\thlist_add_head(&zv->zv_hlink, ZVOL_HT_HEAD(zv->zv_hash));\n}\n\n \nstatic void\nzvol_remove(zvol_state_t *zv)\n{\n\tASSERT(RW_WRITE_HELD(&zvol_state_lock));\n\tlist_remove(&zvol_state_list, zv);\n\thlist_del(&zv->zv_hlink);\n}\n\n \nstatic int\nzvol_setup_zv(zvol_state_t *zv)\n{\n\tuint64_t volsize;\n\tint error;\n\tuint64_t ro;\n\tobjset_t *os = zv->zv_objset;\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\tASSERT(RW_LOCK_HELD(&zv->zv_suspend_lock));\n\n\tzv->zv_zilog = NULL;\n\tzv->zv_flags &= ~ZVOL_WRITTEN_TO;\n\n\terror = dsl_prop_get_integer(zv->zv_name, \"readonly\", &ro, NULL);\n\tif (error)\n\t\treturn (SET_ERROR(error));\n\n\terror = zap_lookup(os, ZVOL_ZAP_OBJ, \"size\", 8, 1, &volsize);\n\tif (error)\n\t\treturn (SET_ERROR(error));\n\n\terror = dnode_hold(os, ZVOL_OBJ, zv, &zv->zv_dn);\n\tif (error)\n\t\treturn (SET_ERROR(error));\n\n\tzvol_os_set_capacity(zv, volsize >> 9);\n\tzv->zv_volsize = volsize;\n\n\tif (ro || dmu_objset_is_snapshot(os) ||\n\t    !spa_writeable(dmu_objset_spa(os))) {\n\t\tzvol_os_set_disk_ro(zv, 1);\n\t\tzv->zv_flags |= ZVOL_RDONLY;\n\t} else {\n\t\tzvol_os_set_disk_ro(zv, 0);\n\t\tzv->zv_flags &= ~ZVOL_RDONLY;\n\t}\n\treturn (0);\n}\n\n \nstatic void\nzvol_shutdown_zv(zvol_state_t *zv)\n{\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock) &&\n\t    RW_LOCK_HELD(&zv->zv_suspend_lock));\n\n\tif (zv->zv_flags & ZVOL_WRITTEN_TO) {\n\t\tASSERT(zv->zv_zilog != NULL);\n\t\tzil_close(zv->zv_zilog);\n\t}\n\n\tzv->zv_zilog = NULL;\n\n\tdnode_rele(zv->zv_dn, zv);\n\tzv->zv_dn = NULL;\n\n\t \n\tif (zv->zv_flags & ZVOL_WRITTEN_TO)\n\t\ttxg_wait_synced(dmu_objset_pool(zv->zv_objset), 0);\n\t(void) dmu_objset_evict_dbufs(zv->zv_objset);\n}\n\n \nvoid *\nzvol_tag(zvol_state_t *zv)\n{\n\tASSERT(RW_WRITE_HELD(&zv->zv_suspend_lock));\n\treturn (zv->zv_open_count > 0 ? zv : NULL);\n}\n\n \nzvol_state_t *\nzvol_suspend(const char *name)\n{\n\tzvol_state_t *zv;\n\n\tzv = zvol_find_by_name(name, RW_WRITER);\n\n\tif (zv == NULL)\n\t\treturn (NULL);\n\n\t \n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\tASSERT(RW_WRITE_HELD(&zv->zv_suspend_lock));\n\n\tatomic_inc(&zv->zv_suspend_ref);\n\n\tif (zv->zv_open_count > 0)\n\t\tzvol_shutdown_zv(zv);\n\n\t \n\tmutex_exit(&zv->zv_state_lock);\n\n\t \n\treturn (zv);\n}\n\nint\nzvol_resume(zvol_state_t *zv)\n{\n\tint error = 0;\n\n\tASSERT(RW_WRITE_HELD(&zv->zv_suspend_lock));\n\n\tmutex_enter(&zv->zv_state_lock);\n\n\tif (zv->zv_open_count > 0) {\n\t\tVERIFY0(dmu_objset_hold(zv->zv_name, zv, &zv->zv_objset));\n\t\tVERIFY3P(zv->zv_objset->os_dsl_dataset->ds_owner, ==, zv);\n\t\tVERIFY(dsl_dataset_long_held(zv->zv_objset->os_dsl_dataset));\n\t\tdmu_objset_rele(zv->zv_objset, zv);\n\n\t\terror = zvol_setup_zv(zv);\n\t}\n\n\tmutex_exit(&zv->zv_state_lock);\n\n\trw_exit(&zv->zv_suspend_lock);\n\t \n\tatomic_dec(&zv->zv_suspend_ref);\n\n\treturn (SET_ERROR(error));\n}\n\nint\nzvol_first_open(zvol_state_t *zv, boolean_t readonly)\n{\n\tobjset_t *os;\n\tint error;\n\n\tASSERT(RW_READ_HELD(&zv->zv_suspend_lock));\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\tASSERT(mutex_owned(&spa_namespace_lock));\n\n\tboolean_t ro = (readonly || (strchr(zv->zv_name, '@') != NULL));\n\terror = dmu_objset_own(zv->zv_name, DMU_OST_ZVOL, ro, B_TRUE, zv, &os);\n\tif (error)\n\t\treturn (SET_ERROR(error));\n\n\tzv->zv_objset = os;\n\n\terror = zvol_setup_zv(zv);\n\tif (error) {\n\t\tdmu_objset_disown(os, 1, zv);\n\t\tzv->zv_objset = NULL;\n\t}\n\n\treturn (error);\n}\n\nvoid\nzvol_last_close(zvol_state_t *zv)\n{\n\tASSERT(RW_READ_HELD(&zv->zv_suspend_lock));\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\tzvol_shutdown_zv(zv);\n\n\tdmu_objset_disown(zv->zv_objset, 1, zv);\n\tzv->zv_objset = NULL;\n}\n\ntypedef struct minors_job {\n\tlist_t *list;\n\tlist_node_t link;\n\t \n\tchar *name;\n\t \n\tint error;\n} minors_job_t;\n\n \nstatic void\nzvol_prefetch_minors_impl(void *arg)\n{\n\tminors_job_t *job = arg;\n\tchar *dsname = job->name;\n\tobjset_t *os = NULL;\n\n\tjob->error = dmu_objset_own(dsname, DMU_OST_ZVOL, B_TRUE, B_TRUE,\n\t    FTAG, &os);\n\tif (job->error == 0) {\n\t\tdmu_prefetch(os, ZVOL_OBJ, 0, 0, 0, ZIO_PRIORITY_SYNC_READ);\n\t\tdmu_objset_disown(os, B_TRUE, FTAG);\n\t}\n}\n\n \nstatic int\nzvol_create_snap_minor_cb(const char *dsname, void *arg)\n{\n\tminors_job_t *j = arg;\n\tlist_t *minors_list = j->list;\n\tconst char *name = j->name;\n\n\tASSERT0(MUTEX_HELD(&spa_namespace_lock));\n\n\t \n\tif (name && strcmp(dsname, name) == 0)\n\t\treturn (0);\n\n\t \n\tif (strchr(dsname, '@') == 0) {\n\t\tdprintf(\"zvol_create_snap_minor_cb(): \"\n\t\t    \"%s is not a snapshot name\\n\", dsname);\n\t} else {\n\t\tminors_job_t *job;\n\t\tchar *n = kmem_strdup(dsname);\n\t\tif (n == NULL)\n\t\t\treturn (0);\n\n\t\tjob = kmem_alloc(sizeof (minors_job_t), KM_SLEEP);\n\t\tjob->name = n;\n\t\tjob->list = minors_list;\n\t\tjob->error = 0;\n\t\tlist_insert_tail(minors_list, job);\n\t\t \n\t\ttaskq_dispatch(system_taskq, zvol_prefetch_minors_impl, job,\n\t\t    TQ_SLEEP);\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nzvol_add_clones(const char *dsname, list_t *minors_list)\n{\n\t \n\tdsl_dir_t *dd = NULL;\n\tdsl_pool_t *dp = NULL;\n\n\tif (dsl_pool_hold(dsname, FTAG, &dp) != 0)\n\t\treturn;\n\n\tif (!spa_feature_is_enabled(dp->dp_spa,\n\t    SPA_FEATURE_ENCRYPTION))\n\t\tgoto out;\n\n\tif (dsl_dir_hold(dp, dsname, FTAG, &dd, NULL) != 0)\n\t\tgoto out;\n\n\tif (dsl_dir_phys(dd)->dd_clones == 0)\n\t\tgoto out;\n\n\tzap_cursor_t *zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tzap_attribute_t *za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\n\tfor (zap_cursor_init(zc, mos, dsl_dir_phys(dd)->dd_clones);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\t\tdsl_dataset_t *clone;\n\t\tminors_job_t *job;\n\n\t\tif (dsl_dataset_hold_obj(dd->dd_pool,\n\t\t    za->za_first_integer, FTAG, &clone) == 0) {\n\n\t\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\tdsl_dataset_name(clone, name);\n\n\t\t\tchar *n = kmem_strdup(name);\n\t\t\tjob = kmem_alloc(sizeof (minors_job_t), KM_SLEEP);\n\t\t\tjob->name = n;\n\t\t\tjob->list = minors_list;\n\t\t\tjob->error = 0;\n\t\t\tlist_insert_tail(minors_list, job);\n\n\t\t\tdsl_dataset_rele(clone, FTAG);\n\t\t}\n\t}\n\tzap_cursor_fini(zc);\n\tkmem_free(za, sizeof (zap_attribute_t));\n\tkmem_free(zc, sizeof (zap_cursor_t));\n\nout:\n\tif (dd != NULL)\n\t\tdsl_dir_rele(dd, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n}\n\n \nstatic int\nzvol_create_minors_cb(const char *dsname, void *arg)\n{\n\tuint64_t snapdev;\n\tint error;\n\tlist_t *minors_list = arg;\n\n\tASSERT0(MUTEX_HELD(&spa_namespace_lock));\n\n\terror = dsl_prop_get_integer(dsname, \"snapdev\", &snapdev, NULL);\n\tif (error)\n\t\treturn (0);\n\n\t \n\tif (strchr(dsname, '@') == 0) {\n\t\tminors_job_t *job;\n\t\tchar *n = kmem_strdup(dsname);\n\t\tif (n == NULL)\n\t\t\treturn (0);\n\n\t\tjob = kmem_alloc(sizeof (minors_job_t), KM_SLEEP);\n\t\tjob->name = n;\n\t\tjob->list = minors_list;\n\t\tjob->error = 0;\n\t\tlist_insert_tail(minors_list, job);\n\t\t \n\t\ttaskq_dispatch(system_taskq, zvol_prefetch_minors_impl, job,\n\t\t    TQ_SLEEP);\n\n\t\tzvol_add_clones(dsname, minors_list);\n\n\t\tif (snapdev == ZFS_SNAPDEV_VISIBLE) {\n\t\t\t \n\t\t\t(void) dmu_objset_find(dsname,\n\t\t\t    zvol_create_snap_minor_cb, (void *)job,\n\t\t\t    DS_FIND_SNAPSHOTS);\n\t\t}\n\t} else {\n\t\tdprintf(\"zvol_create_minors_cb(): %s is not a zvol name\\n\",\n\t\t    dsname);\n\t}\n\n\treturn (0);\n}\n\n \nvoid\nzvol_create_minors_recursive(const char *name)\n{\n\tlist_t minors_list;\n\tminors_job_t *job;\n\n\tif (zvol_inhibit_dev)\n\t\treturn;\n\n\t \n\tlist_create(&minors_list, sizeof (minors_job_t),\n\t    offsetof(minors_job_t, link));\n\n\n\tif (strchr(name, '@') != NULL) {\n\t\tuint64_t snapdev;\n\n\t\tint error = dsl_prop_get_integer(name, \"snapdev\",\n\t\t    &snapdev, NULL);\n\n\t\tif (error == 0 && snapdev == ZFS_SNAPDEV_VISIBLE)\n\t\t\t(void) zvol_os_create_minor(name);\n\t} else {\n\t\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\t\t(void) dmu_objset_find(name, zvol_create_minors_cb,\n\t\t    &minors_list, DS_FIND_CHILDREN);\n\t\tspl_fstrans_unmark(cookie);\n\t}\n\n\ttaskq_wait_outstanding(system_taskq, 0);\n\n\t \n\twhile ((job = list_remove_head(&minors_list)) != NULL) {\n\t\tif (!job->error)\n\t\t\t(void) zvol_os_create_minor(job->name);\n\t\tkmem_strfree(job->name);\n\t\tkmem_free(job, sizeof (minors_job_t));\n\t}\n\n\tlist_destroy(&minors_list);\n}\n\nvoid\nzvol_create_minor(const char *name)\n{\n\t \n\n\tif (zvol_inhibit_dev)\n\t\treturn;\n\n\tif (strchr(name, '@') != NULL) {\n\t\tuint64_t snapdev;\n\n\t\tint error = dsl_prop_get_integer(name,\n\t\t    \"snapdev\", &snapdev, NULL);\n\n\t\tif (error == 0 && snapdev == ZFS_SNAPDEV_VISIBLE)\n\t\t\t(void) zvol_os_create_minor(name);\n\t} else {\n\t\t(void) zvol_os_create_minor(name);\n\t}\n}\n\n \n\nstatic void\nzvol_free_task(void *arg)\n{\n\tzvol_os_free(arg);\n}\n\nvoid\nzvol_remove_minors_impl(const char *name)\n{\n\tzvol_state_t *zv, *zv_next;\n\tint namelen = ((name) ? strlen(name) : 0);\n\ttaskqid_t t;\n\tlist_t free_list;\n\n\tif (zvol_inhibit_dev)\n\t\treturn;\n\n\tlist_create(&free_list, sizeof (zvol_state_t),\n\t    offsetof(zvol_state_t, zv_next));\n\n\trw_enter(&zvol_state_lock, RW_WRITER);\n\n\tfor (zv = list_head(&zvol_state_list); zv != NULL; zv = zv_next) {\n\t\tzv_next = list_next(&zvol_state_list, zv);\n\n\t\tmutex_enter(&zv->zv_state_lock);\n\t\tif (name == NULL || strcmp(zv->zv_name, name) == 0 ||\n\t\t    (strncmp(zv->zv_name, name, namelen) == 0 &&\n\t\t    (zv->zv_name[namelen] == '/' ||\n\t\t    zv->zv_name[namelen] == '@'))) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (zv->zv_open_count > 0 ||\n\t\t\t    atomic_read(&zv->zv_suspend_ref)) {\n\t\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tzvol_remove(zv);\n\n\t\t\t \n\t\t\tzvol_os_clear_private(zv);\n\n\t\t\t \n\t\t\tmutex_exit(&zv->zv_state_lock);\n\n\t\t\t \n\t\t\tt = taskq_dispatch(system_taskq, zvol_free_task, zv,\n\t\t\t    TQ_SLEEP);\n\t\t\tif (t == TASKQID_INVALID)\n\t\t\t\tlist_insert_head(&free_list, zv);\n\t\t} else {\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t}\n\t}\n\trw_exit(&zvol_state_lock);\n\n\t \n\twhile ((zv = list_remove_head(&free_list)) != NULL)\n\t\tzvol_os_free(zv);\n}\n\n \nstatic void\nzvol_remove_minor_impl(const char *name)\n{\n\tzvol_state_t *zv = NULL, *zv_next;\n\n\tif (zvol_inhibit_dev)\n\t\treturn;\n\n\trw_enter(&zvol_state_lock, RW_WRITER);\n\n\tfor (zv = list_head(&zvol_state_list); zv != NULL; zv = zv_next) {\n\t\tzv_next = list_next(&zvol_state_list, zv);\n\n\t\tmutex_enter(&zv->zv_state_lock);\n\t\tif (strcmp(zv->zv_name, name) == 0) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (zv->zv_open_count > 0 ||\n\t\t\t    atomic_read(&zv->zv_suspend_ref)) {\n\t\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tzvol_remove(zv);\n\n\t\t\tzvol_os_clear_private(zv);\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t}\n\t}\n\n\t \n\trw_exit(&zvol_state_lock);\n\n\tif (zv != NULL)\n\t\tzvol_os_free(zv);\n}\n\n \nstatic void\nzvol_rename_minors_impl(const char *oldname, const char *newname)\n{\n\tzvol_state_t *zv, *zv_next;\n\tint oldnamelen;\n\n\tif (zvol_inhibit_dev)\n\t\treturn;\n\n\toldnamelen = strlen(oldname);\n\n\trw_enter(&zvol_state_lock, RW_READER);\n\n\tfor (zv = list_head(&zvol_state_list); zv != NULL; zv = zv_next) {\n\t\tzv_next = list_next(&zvol_state_list, zv);\n\n\t\tmutex_enter(&zv->zv_state_lock);\n\n\t\tif (strcmp(zv->zv_name, oldname) == 0) {\n\t\t\tzvol_os_rename_minor(zv, newname);\n\t\t} else if (strncmp(zv->zv_name, oldname, oldnamelen) == 0 &&\n\t\t    (zv->zv_name[oldnamelen] == '/' ||\n\t\t    zv->zv_name[oldnamelen] == '@')) {\n\t\t\tchar *name = kmem_asprintf(\"%s%c%s\", newname,\n\t\t\t    zv->zv_name[oldnamelen],\n\t\t\t    zv->zv_name + oldnamelen + 1);\n\t\t\tzvol_os_rename_minor(zv, name);\n\t\t\tkmem_strfree(name);\n\t\t}\n\n\t\tmutex_exit(&zv->zv_state_lock);\n\t}\n\n\trw_exit(&zvol_state_lock);\n}\n\ntypedef struct zvol_snapdev_cb_arg {\n\tuint64_t snapdev;\n} zvol_snapdev_cb_arg_t;\n\nstatic int\nzvol_set_snapdev_cb(const char *dsname, void *param)\n{\n\tzvol_snapdev_cb_arg_t *arg = param;\n\n\tif (strchr(dsname, '@') == NULL)\n\t\treturn (0);\n\n\tswitch (arg->snapdev) {\n\t\tcase ZFS_SNAPDEV_VISIBLE:\n\t\t\t(void) zvol_os_create_minor(dsname);\n\t\t\tbreak;\n\t\tcase ZFS_SNAPDEV_HIDDEN:\n\t\t\t(void) zvol_remove_minor_impl(dsname);\n\t\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzvol_set_snapdev_impl(char *name, uint64_t snapdev)\n{\n\tzvol_snapdev_cb_arg_t arg = {snapdev};\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\t \n\tdmu_objset_find(name, zvol_set_snapdev_cb, &arg, DS_FIND_SNAPSHOTS);\n\tspl_fstrans_unmark(cookie);\n}\n\nstatic void\nzvol_set_volmode_impl(char *name, uint64_t volmode)\n{\n\tfstrans_cookie_t cookie;\n\tuint64_t old_volmode;\n\tzvol_state_t *zv;\n\n\tif (strchr(name, '@') != NULL)\n\t\treturn;\n\n\t \n\tzv = zvol_find_by_name(name, RW_NONE);\n\tif (zv == NULL && volmode == ZFS_VOLMODE_NONE)\n\t\t\treturn;\n\tif (zv != NULL) {\n\t\told_volmode = zv->zv_volmode;\n\t\tmutex_exit(&zv->zv_state_lock);\n\t\tif (old_volmode == volmode)\n\t\t\treturn;\n\t\tzvol_wait_close(zv);\n\t}\n\tcookie = spl_fstrans_mark();\n\tswitch (volmode) {\n\t\tcase ZFS_VOLMODE_NONE:\n\t\t\t(void) zvol_remove_minor_impl(name);\n\t\t\tbreak;\n\t\tcase ZFS_VOLMODE_GEOM:\n\t\tcase ZFS_VOLMODE_DEV:\n\t\t\t(void) zvol_remove_minor_impl(name);\n\t\t\t(void) zvol_os_create_minor(name);\n\t\t\tbreak;\n\t\tcase ZFS_VOLMODE_DEFAULT:\n\t\t\t(void) zvol_remove_minor_impl(name);\n\t\t\tif (zvol_volmode == ZFS_VOLMODE_NONE)\n\t\t\t\tbreak;\n\t\t\telse  \n\t\t\t\t(void) zvol_os_create_minor(name);\n\t\t\tbreak;\n\t}\n\tspl_fstrans_unmark(cookie);\n}\n\nstatic zvol_task_t *\nzvol_task_alloc(zvol_async_op_t op, const char *name1, const char *name2,\n    uint64_t value)\n{\n\tzvol_task_t *task;\n\n\t \n\tif (name1[0] == '$')\n\t\treturn (NULL);\n\n\ttask = kmem_zalloc(sizeof (zvol_task_t), KM_SLEEP);\n\ttask->op = op;\n\ttask->value = value;\n\n\tstrlcpy(task->name1, name1, MAXNAMELEN);\n\tif (name2 != NULL)\n\t\tstrlcpy(task->name2, name2, MAXNAMELEN);\n\n\treturn (task);\n}\n\nstatic void\nzvol_task_free(zvol_task_t *task)\n{\n\tkmem_free(task, sizeof (zvol_task_t));\n}\n\n \nstatic void\nzvol_task_cb(void *arg)\n{\n\tzvol_task_t *task = arg;\n\n\tswitch (task->op) {\n\tcase ZVOL_ASYNC_REMOVE_MINORS:\n\t\tzvol_remove_minors_impl(task->name1);\n\t\tbreak;\n\tcase ZVOL_ASYNC_RENAME_MINORS:\n\t\tzvol_rename_minors_impl(task->name1, task->name2);\n\t\tbreak;\n\tcase ZVOL_ASYNC_SET_SNAPDEV:\n\t\tzvol_set_snapdev_impl(task->name1, task->value);\n\t\tbreak;\n\tcase ZVOL_ASYNC_SET_VOLMODE:\n\t\tzvol_set_volmode_impl(task->name1, task->value);\n\t\tbreak;\n\tdefault:\n\t\tVERIFY(0);\n\t\tbreak;\n\t}\n\n\tzvol_task_free(task);\n}\n\ntypedef struct zvol_set_prop_int_arg {\n\tconst char *zsda_name;\n\tuint64_t zsda_value;\n\tzprop_source_t zsda_source;\n\tdmu_tx_t *zsda_tx;\n} zvol_set_prop_int_arg_t;\n\n \nstatic int\nzvol_set_snapdev_check(void *arg, dmu_tx_t *tx)\n{\n\tzvol_set_prop_int_arg_t *zsda = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd;\n\tint error;\n\n\terror = dsl_dir_hold(dp, zsda->zsda_name, FTAG, &dd, NULL);\n\tif (error != 0)\n\t\treturn (error);\n\n\tdsl_dir_rele(dd, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzvol_set_snapdev_sync_cb(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)\n{\n\t(void) arg;\n\tchar dsname[MAXNAMELEN];\n\tzvol_task_t *task;\n\tuint64_t snapdev;\n\n\tdsl_dataset_name(ds, dsname);\n\tif (dsl_prop_get_int_ds(ds, \"snapdev\", &snapdev) != 0)\n\t\treturn (0);\n\ttask = zvol_task_alloc(ZVOL_ASYNC_SET_SNAPDEV, dsname, NULL, snapdev);\n\tif (task == NULL)\n\t\treturn (0);\n\n\t(void) taskq_dispatch(dp->dp_spa->spa_zvol_taskq, zvol_task_cb,\n\t    task, TQ_SLEEP);\n\treturn (0);\n}\n\n \nstatic void\nzvol_set_snapdev_sync(void *arg, dmu_tx_t *tx)\n{\n\tzvol_set_prop_int_arg_t *zsda = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd;\n\tdsl_dataset_t *ds;\n\tint error;\n\n\tVERIFY0(dsl_dir_hold(dp, zsda->zsda_name, FTAG, &dd, NULL));\n\tzsda->zsda_tx = tx;\n\n\terror = dsl_dataset_hold(dp, zsda->zsda_name, FTAG, &ds);\n\tif (error == 0) {\n\t\tdsl_prop_set_sync_impl(ds, zfs_prop_to_name(ZFS_PROP_SNAPDEV),\n\t\t    zsda->zsda_source, sizeof (zsda->zsda_value), 1,\n\t\t    &zsda->zsda_value, zsda->zsda_tx);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\tdmu_objset_find_dp(dp, dd->dd_object, zvol_set_snapdev_sync_cb,\n\t    zsda, DS_FIND_CHILDREN);\n\n\tdsl_dir_rele(dd, FTAG);\n}\n\nint\nzvol_set_snapdev(const char *ddname, zprop_source_t source, uint64_t snapdev)\n{\n\tzvol_set_prop_int_arg_t zsda;\n\n\tzsda.zsda_name = ddname;\n\tzsda.zsda_source = source;\n\tzsda.zsda_value = snapdev;\n\n\treturn (dsl_sync_task(ddname, zvol_set_snapdev_check,\n\t    zvol_set_snapdev_sync, &zsda, 0, ZFS_SPACE_CHECK_NONE));\n}\n\n \nstatic int\nzvol_set_volmode_check(void *arg, dmu_tx_t *tx)\n{\n\tzvol_set_prop_int_arg_t *zsda = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd;\n\tint error;\n\n\terror = dsl_dir_hold(dp, zsda->zsda_name, FTAG, &dd, NULL);\n\tif (error != 0)\n\t\treturn (error);\n\n\tdsl_dir_rele(dd, FTAG);\n\n\treturn (error);\n}\n\nstatic int\nzvol_set_volmode_sync_cb(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)\n{\n\t(void) arg;\n\tchar dsname[MAXNAMELEN];\n\tzvol_task_t *task;\n\tuint64_t volmode;\n\n\tdsl_dataset_name(ds, dsname);\n\tif (dsl_prop_get_int_ds(ds, \"volmode\", &volmode) != 0)\n\t\treturn (0);\n\ttask = zvol_task_alloc(ZVOL_ASYNC_SET_VOLMODE, dsname, NULL, volmode);\n\tif (task == NULL)\n\t\treturn (0);\n\n\t(void) taskq_dispatch(dp->dp_spa->spa_zvol_taskq, zvol_task_cb,\n\t    task, TQ_SLEEP);\n\treturn (0);\n}\n\n \nstatic void\nzvol_set_volmode_sync(void *arg, dmu_tx_t *tx)\n{\n\tzvol_set_prop_int_arg_t *zsda = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dir_t *dd;\n\tdsl_dataset_t *ds;\n\tint error;\n\n\tVERIFY0(dsl_dir_hold(dp, zsda->zsda_name, FTAG, &dd, NULL));\n\tzsda->zsda_tx = tx;\n\n\terror = dsl_dataset_hold(dp, zsda->zsda_name, FTAG, &ds);\n\tif (error == 0) {\n\t\tdsl_prop_set_sync_impl(ds, zfs_prop_to_name(ZFS_PROP_VOLMODE),\n\t\t    zsda->zsda_source, sizeof (zsda->zsda_value), 1,\n\t\t    &zsda->zsda_value, zsda->zsda_tx);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\n\tdmu_objset_find_dp(dp, dd->dd_object, zvol_set_volmode_sync_cb,\n\t    zsda, DS_FIND_CHILDREN);\n\n\tdsl_dir_rele(dd, FTAG);\n}\n\nint\nzvol_set_volmode(const char *ddname, zprop_source_t source, uint64_t volmode)\n{\n\tzvol_set_prop_int_arg_t zsda;\n\n\tzsda.zsda_name = ddname;\n\tzsda.zsda_source = source;\n\tzsda.zsda_value = volmode;\n\n\treturn (dsl_sync_task(ddname, zvol_set_volmode_check,\n\t    zvol_set_volmode_sync, &zsda, 0, ZFS_SPACE_CHECK_NONE));\n}\n\nvoid\nzvol_remove_minors(spa_t *spa, const char *name, boolean_t async)\n{\n\tzvol_task_t *task;\n\ttaskqid_t id;\n\n\ttask = zvol_task_alloc(ZVOL_ASYNC_REMOVE_MINORS, name, NULL, ~0ULL);\n\tif (task == NULL)\n\t\treturn;\n\n\tid = taskq_dispatch(spa->spa_zvol_taskq, zvol_task_cb, task, TQ_SLEEP);\n\tif ((async == B_FALSE) && (id != TASKQID_INVALID))\n\t\ttaskq_wait_id(spa->spa_zvol_taskq, id);\n}\n\nvoid\nzvol_rename_minors(spa_t *spa, const char *name1, const char *name2,\n    boolean_t async)\n{\n\tzvol_task_t *task;\n\ttaskqid_t id;\n\n\ttask = zvol_task_alloc(ZVOL_ASYNC_RENAME_MINORS, name1, name2, ~0ULL);\n\tif (task == NULL)\n\t\treturn;\n\n\tid = taskq_dispatch(spa->spa_zvol_taskq, zvol_task_cb, task, TQ_SLEEP);\n\tif ((async == B_FALSE) && (id != TASKQID_INVALID))\n\t\ttaskq_wait_id(spa->spa_zvol_taskq, id);\n}\n\nboolean_t\nzvol_is_zvol(const char *name)\n{\n\n\treturn (zvol_os_is_zvol(name));\n}\n\nint\nzvol_init_impl(void)\n{\n\tint i;\n\n\tlist_create(&zvol_state_list, sizeof (zvol_state_t),\n\t    offsetof(zvol_state_t, zv_next));\n\trw_init(&zvol_state_lock, NULL, RW_DEFAULT, NULL);\n\n\tzvol_htable = kmem_alloc(ZVOL_HT_SIZE * sizeof (struct hlist_head),\n\t    KM_SLEEP);\n\tfor (i = 0; i < ZVOL_HT_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&zvol_htable[i]);\n\n\treturn (0);\n}\n\nvoid\nzvol_fini_impl(void)\n{\n\tzvol_remove_minors_impl(NULL);\n\n\t \n\ttaskq_wait_outstanding(system_taskq, 0);\n\n\tkmem_free(zvol_htable, ZVOL_HT_SIZE * sizeof (struct hlist_head));\n\tlist_destroy(&zvol_state_list);\n\trw_destroy(&zvol_state_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}