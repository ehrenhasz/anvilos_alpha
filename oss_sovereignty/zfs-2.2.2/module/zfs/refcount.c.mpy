{
  "module_name": "refcount.c",
  "hash_id": "3925ec697308f7efcd662c5a08f8dff0198c7d927ffdf486155f6f0fbafa8726",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/refcount.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/zfs_refcount.h>\n\n#ifdef\tZFS_DEBUG\n \nint reference_tracking_enable = B_FALSE;\nstatic uint_t reference_history = 3;  \n\nstatic kmem_cache_t *reference_cache;\n\nvoid\nzfs_refcount_init(void)\n{\n\treference_cache = kmem_cache_create(\"reference_cache\",\n\t    sizeof (reference_t), 0, NULL, NULL, NULL, NULL, NULL, 0);\n}\n\nvoid\nzfs_refcount_fini(void)\n{\n\tkmem_cache_destroy(reference_cache);\n}\n\nstatic int\nzfs_refcount_compare(const void *x1, const void *x2)\n{\n\tconst reference_t *r1 = (const reference_t *)x1;\n\tconst reference_t *r2 = (const reference_t *)x2;\n\n\tint cmp1 = TREE_CMP(r1->ref_holder, r2->ref_holder);\n\tint cmp2 = TREE_CMP(r1->ref_number, r2->ref_number);\n\tint cmp = cmp1 ? cmp1 : cmp2;\n\treturn ((cmp || r1->ref_search) ? cmp : TREE_PCMP(r1, r2));\n}\n\nvoid\nzfs_refcount_create(zfs_refcount_t *rc)\n{\n\tmutex_init(&rc->rc_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tavl_create(&rc->rc_tree, zfs_refcount_compare, sizeof (reference_t),\n\t    offsetof(reference_t, ref_link.a));\n\tlist_create(&rc->rc_removed, sizeof (reference_t),\n\t    offsetof(reference_t, ref_link.l));\n\trc->rc_count = 0;\n\trc->rc_removed_count = 0;\n\trc->rc_tracked = reference_tracking_enable;\n}\n\nvoid\nzfs_refcount_create_tracked(zfs_refcount_t *rc)\n{\n\tzfs_refcount_create(rc);\n\trc->rc_tracked = B_TRUE;\n}\n\nvoid\nzfs_refcount_create_untracked(zfs_refcount_t *rc)\n{\n\tzfs_refcount_create(rc);\n\trc->rc_tracked = B_FALSE;\n}\n\nvoid\nzfs_refcount_destroy_many(zfs_refcount_t *rc, uint64_t number)\n{\n\treference_t *ref;\n\tvoid *cookie = NULL;\n\n\tASSERT3U(rc->rc_count, ==, number);\n\twhile ((ref = avl_destroy_nodes(&rc->rc_tree, &cookie)) != NULL)\n\t\tkmem_cache_free(reference_cache, ref);\n\tavl_destroy(&rc->rc_tree);\n\n\twhile ((ref = list_remove_head(&rc->rc_removed)))\n\t\tkmem_cache_free(reference_cache, ref);\n\tlist_destroy(&rc->rc_removed);\n\tmutex_destroy(&rc->rc_mtx);\n}\n\nvoid\nzfs_refcount_destroy(zfs_refcount_t *rc)\n{\n\tzfs_refcount_destroy_many(rc, 0);\n}\n\nint\nzfs_refcount_is_zero(zfs_refcount_t *rc)\n{\n\treturn (zfs_refcount_count(rc) == 0);\n}\n\nint64_t\nzfs_refcount_count(zfs_refcount_t *rc)\n{\n\treturn (atomic_load_64(&rc->rc_count));\n}\n\nint64_t\nzfs_refcount_add_many(zfs_refcount_t *rc, uint64_t number, const void *holder)\n{\n\treference_t *ref;\n\tint64_t count;\n\n\tif (likely(!rc->rc_tracked)) {\n\t\tcount = atomic_add_64_nv(&(rc)->rc_count, number);\n\t\tASSERT3U(count, >=, number);\n\t\treturn (count);\n\t}\n\n\tref = kmem_cache_alloc(reference_cache, KM_SLEEP);\n\tref->ref_holder = holder;\n\tref->ref_number = number;\n\tref->ref_search = B_FALSE;\n\tmutex_enter(&rc->rc_mtx);\n\tavl_add(&rc->rc_tree, ref);\n\trc->rc_count += number;\n\tcount = rc->rc_count;\n\tmutex_exit(&rc->rc_mtx);\n\n\treturn (count);\n}\n\nint64_t\nzfs_refcount_add(zfs_refcount_t *rc, const void *holder)\n{\n\treturn (zfs_refcount_add_many(rc, 1, holder));\n}\n\nvoid\nzfs_refcount_add_few(zfs_refcount_t *rc, uint64_t number, const void *holder)\n{\n\tif (likely(!rc->rc_tracked))\n\t\t(void) zfs_refcount_add_many(rc, number, holder);\n\telse for (; number > 0; number--)\n\t\t(void) zfs_refcount_add(rc, holder);\n}\n\nint64_t\nzfs_refcount_remove_many(zfs_refcount_t *rc, uint64_t number,\n    const void *holder)\n{\n\treference_t *ref, s;\n\tint64_t count;\n\n\tif (likely(!rc->rc_tracked)) {\n\t\tcount = atomic_add_64_nv(&(rc)->rc_count, -number);\n\t\tASSERT3S(count, >=, 0);\n\t\treturn (count);\n\t}\n\n\ts.ref_holder = holder;\n\ts.ref_number = number;\n\ts.ref_search = B_TRUE;\n\tmutex_enter(&rc->rc_mtx);\n\tASSERT3U(rc->rc_count, >=, number);\n\tref = avl_find(&rc->rc_tree, &s, NULL);\n\tif (unlikely(ref == NULL)) {\n\t\tpanic(\"No such hold %p on refcount %llx\", holder,\n\t\t    (u_longlong_t)(uintptr_t)rc);\n\t\treturn (-1);\n\t}\n\tavl_remove(&rc->rc_tree, ref);\n\tif (reference_history > 0) {\n\t\tlist_insert_head(&rc->rc_removed, ref);\n\t\tif (rc->rc_removed_count >= reference_history) {\n\t\t\tref = list_remove_tail(&rc->rc_removed);\n\t\t\tkmem_cache_free(reference_cache, ref);\n\t\t} else {\n\t\t\trc->rc_removed_count++;\n\t\t}\n\t} else {\n\t\tkmem_cache_free(reference_cache, ref);\n\t}\n\trc->rc_count -= number;\n\tcount = rc->rc_count;\n\tmutex_exit(&rc->rc_mtx);\n\treturn (count);\n}\n\nint64_t\nzfs_refcount_remove(zfs_refcount_t *rc, const void *holder)\n{\n\treturn (zfs_refcount_remove_many(rc, 1, holder));\n}\n\nvoid\nzfs_refcount_remove_few(zfs_refcount_t *rc, uint64_t number, const void *holder)\n{\n\tif (likely(!rc->rc_tracked))\n\t\t(void) zfs_refcount_remove_many(rc, number, holder);\n\telse for (; number > 0; number--)\n\t\t(void) zfs_refcount_remove(rc, holder);\n}\n\nvoid\nzfs_refcount_transfer(zfs_refcount_t *dst, zfs_refcount_t *src)\n{\n\tavl_tree_t tree;\n\tlist_t removed;\n\treference_t *ref;\n\tvoid *cookie = NULL;\n\tuint64_t count;\n\tuint_t removed_count;\n\n\tavl_create(&tree, zfs_refcount_compare, sizeof (reference_t),\n\t    offsetof(reference_t, ref_link.a));\n\tlist_create(&removed, sizeof (reference_t),\n\t    offsetof(reference_t, ref_link.l));\n\n\tmutex_enter(&src->rc_mtx);\n\tcount = src->rc_count;\n\tremoved_count = src->rc_removed_count;\n\tsrc->rc_count = 0;\n\tsrc->rc_removed_count = 0;\n\tavl_swap(&tree, &src->rc_tree);\n\tlist_move_tail(&removed, &src->rc_removed);\n\tmutex_exit(&src->rc_mtx);\n\n\tmutex_enter(&dst->rc_mtx);\n\tdst->rc_count += count;\n\tdst->rc_removed_count += removed_count;\n\tif (avl_is_empty(&dst->rc_tree))\n\t\tavl_swap(&dst->rc_tree, &tree);\n\telse while ((ref = avl_destroy_nodes(&tree, &cookie)) != NULL)\n\t\tavl_add(&dst->rc_tree, ref);\n\tlist_move_tail(&dst->rc_removed, &removed);\n\tmutex_exit(&dst->rc_mtx);\n\n\tavl_destroy(&tree);\n\tlist_destroy(&removed);\n}\n\nvoid\nzfs_refcount_transfer_ownership_many(zfs_refcount_t *rc, uint64_t number,\n    const void *current_holder, const void *new_holder)\n{\n\treference_t *ref, s;\n\n\tif (likely(!rc->rc_tracked))\n\t\treturn;\n\n\ts.ref_holder = current_holder;\n\ts.ref_number = number;\n\ts.ref_search = B_TRUE;\n\tmutex_enter(&rc->rc_mtx);\n\tref = avl_find(&rc->rc_tree, &s, NULL);\n\tASSERT(ref);\n\tref->ref_holder = new_holder;\n\tavl_update(&rc->rc_tree, ref);\n\tmutex_exit(&rc->rc_mtx);\n}\n\nvoid\nzfs_refcount_transfer_ownership(zfs_refcount_t *rc, const void *current_holder,\n    const void *new_holder)\n{\n\treturn (zfs_refcount_transfer_ownership_many(rc, 1, current_holder,\n\t    new_holder));\n}\n\n \nboolean_t\nzfs_refcount_held(zfs_refcount_t *rc, const void *holder)\n{\n\treference_t *ref, s;\n\tavl_index_t idx;\n\tboolean_t res;\n\n\tif (likely(!rc->rc_tracked))\n\t\treturn (zfs_refcount_count(rc) > 0);\n\n\ts.ref_holder = holder;\n\ts.ref_number = 0;\n\ts.ref_search = B_TRUE;\n\tmutex_enter(&rc->rc_mtx);\n\tref = avl_find(&rc->rc_tree, &s, &idx);\n\tif (likely(ref == NULL))\n\t\tref = avl_nearest(&rc->rc_tree, idx, AVL_AFTER);\n\tres = ref && ref->ref_holder == holder;\n\tmutex_exit(&rc->rc_mtx);\n\treturn (res);\n}\n\n \nboolean_t\nzfs_refcount_not_held(zfs_refcount_t *rc, const void *holder)\n{\n\treference_t *ref, s;\n\tavl_index_t idx;\n\tboolean_t res;\n\n\tif (likely(!rc->rc_tracked))\n\t\treturn (B_TRUE);\n\n\tmutex_enter(&rc->rc_mtx);\n\ts.ref_holder = holder;\n\ts.ref_number = 0;\n\ts.ref_search = B_TRUE;\n\tref = avl_find(&rc->rc_tree, &s, &idx);\n\tif (likely(ref == NULL))\n\t\tref = avl_nearest(&rc->rc_tree, idx, AVL_AFTER);\n\tres = ref == NULL || ref->ref_holder != holder;\n\tmutex_exit(&rc->rc_mtx);\n\treturn (res);\n}\n\nEXPORT_SYMBOL(zfs_refcount_create);\nEXPORT_SYMBOL(zfs_refcount_destroy);\nEXPORT_SYMBOL(zfs_refcount_is_zero);\nEXPORT_SYMBOL(zfs_refcount_count);\nEXPORT_SYMBOL(zfs_refcount_add);\nEXPORT_SYMBOL(zfs_refcount_remove);\nEXPORT_SYMBOL(zfs_refcount_held);\n\n \nZFS_MODULE_PARAM(zfs, , reference_tracking_enable, INT, ZMOD_RW,\n\t\"Track reference holders to refcount_t objects\");\n\nZFS_MODULE_PARAM(zfs, , reference_history, UINT, ZMOD_RW,\n\t\"Maximum reference holders being tracked\");\n \n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}