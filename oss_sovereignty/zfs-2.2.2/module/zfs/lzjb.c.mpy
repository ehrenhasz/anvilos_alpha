{
  "module_name": "lzjb.c",
  "hash_id": "bce932129715974fe3e64d12cb14cfd2e6b19ff0f231c014ec7874b8268dde61",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/lzjb.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/zio_compress.h>\n\n#define\tMATCH_BITS\t6\n#define\tMATCH_MIN\t3\n#define\tMATCH_MAX\t((1 << MATCH_BITS) + (MATCH_MIN - 1))\n#define\tOFFSET_MASK\t((1 << (16 - MATCH_BITS)) - 1)\n#define\tLEMPEL_SIZE\t1024\n\nsize_t\nlzjb_compress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)\n{\n\t(void) n;\n\tuchar_t *src = s_start;\n\tuchar_t *dst = d_start;\n\tuchar_t *cpy;\n\tuchar_t *copymap = NULL;\n\tint copymask = 1 << (NBBY - 1);\n\tint mlen, offset, hash;\n\tuint16_t *hp;\n\tuint16_t *lempel;\n\n\tlempel = kmem_zalloc(LEMPEL_SIZE * sizeof (uint16_t), KM_SLEEP);\n\twhile (src < (uchar_t *)s_start + s_len) {\n\t\tif ((copymask <<= 1) == (1 << NBBY)) {\n\t\t\tif (dst >= (uchar_t *)d_start + d_len - 1 - 2 * NBBY) {\n\t\t\t\tkmem_free(lempel,\n\t\t\t\t    LEMPEL_SIZE*sizeof (uint16_t));\n\t\t\t\treturn (s_len);\n\t\t\t}\n\t\t\tcopymask = 1;\n\t\t\tcopymap = dst;\n\t\t\t*dst++ = 0;\n\t\t}\n\t\tif (src > (uchar_t *)s_start + s_len - MATCH_MAX) {\n\t\t\t*dst++ = *src++;\n\t\t\tcontinue;\n\t\t}\n\t\thash = (src[0] << 16) + (src[1] << 8) + src[2];\n\t\thash += hash >> 9;\n\t\thash += hash >> 5;\n\t\thp = &lempel[hash & (LEMPEL_SIZE - 1)];\n\t\toffset = (intptr_t)(src - *hp) & OFFSET_MASK;\n\t\t*hp = (uint16_t)(uintptr_t)src;\n\t\tcpy = src - offset;\n\t\tif (cpy >= (uchar_t *)s_start && cpy != src &&\n\t\t    src[0] == cpy[0] && src[1] == cpy[1] && src[2] == cpy[2]) {\n\t\t\t*copymap |= copymask;\n\t\t\tfor (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++)\n\t\t\t\tif (src[mlen] != cpy[mlen])\n\t\t\t\t\tbreak;\n\t\t\t*dst++ = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |\n\t\t\t    (offset >> NBBY);\n\t\t\t*dst++ = (uchar_t)offset;\n\t\t\tsrc += mlen;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t}\n\n\tkmem_free(lempel, LEMPEL_SIZE * sizeof (uint16_t));\n\treturn (dst - (uchar_t *)d_start);\n}\n\nint\nlzjb_decompress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)\n{\n\t(void) s_len, (void) n;\n\tuchar_t *src = s_start;\n\tuchar_t *dst = d_start;\n\tuchar_t *d_end = (uchar_t *)d_start + d_len;\n\tuchar_t *cpy;\n\tuchar_t copymap = 0;\n\tint copymask = 1 << (NBBY - 1);\n\n\twhile (dst < d_end) {\n\t\tif ((copymask <<= 1) == (1 << NBBY)) {\n\t\t\tcopymask = 1;\n\t\t\tcopymap = *src++;\n\t\t}\n\t\tif (copymap & copymask) {\n\t\t\tint mlen = (src[0] >> (NBBY - MATCH_BITS)) + MATCH_MIN;\n\t\t\tint offset = ((src[0] << NBBY) | src[1]) & OFFSET_MASK;\n\t\t\tsrc += 2;\n\t\t\tif ((cpy = dst - offset) < (uchar_t *)d_start)\n\t\t\t\treturn (-1);\n\t\t\twhile (--mlen >= 0 && dst < d_end)\n\t\t\t\t*dst++ = *cpy++;\n\t\t} else {\n\t\t\t*dst++ = *src++;\n\t\t}\n\t}\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}