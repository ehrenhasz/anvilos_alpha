{
  "module_name": "vdev_raidz.c",
  "hash_id": "85946b0ed0bae8f526e48b74f14e22c6e08dd13ca63c41da3c4b7f37e02d101b",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_raidz.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/vdev_impl.h>\n#include <sys/zio.h>\n#include <sys/zio_checksum.h>\n#include <sys/abd.h>\n#include <sys/fs/zfs.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/vdev_raidz.h>\n#include <sys/vdev_raidz_impl.h>\n#include <sys/vdev_draid.h>\n\n#ifdef ZFS_DEBUG\n#include <sys/vdev.h>\t \n#endif\n\n \n\n#define\tVDEV_RAIDZ_P\t\t0\n#define\tVDEV_RAIDZ_Q\t\t1\n#define\tVDEV_RAIDZ_R\t\t2\n\n#define\tVDEV_RAIDZ_MUL_2(x)\t(((x) << 1) ^ (((x) & 0x80) ? 0x1d : 0))\n#define\tVDEV_RAIDZ_MUL_4(x)\t(VDEV_RAIDZ_MUL_2(VDEV_RAIDZ_MUL_2(x)))\n\n \n#define\tVDEV_RAIDZ_64MUL_2(x, mask) \\\n{ \\\n\t(mask) = (x) & 0x8080808080808080ULL; \\\n\t(mask) = ((mask) << 1) - ((mask) >> 7); \\\n\t(x) = (((x) << 1) & 0xfefefefefefefefeULL) ^ \\\n\t    ((mask) & 0x1d1d1d1d1d1d1d1dULL); \\\n}\n\n#define\tVDEV_RAIDZ_64MUL_4(x, mask) \\\n{ \\\n\tVDEV_RAIDZ_64MUL_2((x), mask); \\\n\tVDEV_RAIDZ_64MUL_2((x), mask); \\\n}\n\nstatic void\nvdev_raidz_row_free(raidz_row_t *rr)\n{\n\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_size != 0)\n\t\t\tabd_free(rc->rc_abd);\n\t\tif (rc->rc_orig_data != NULL)\n\t\t\tabd_free(rc->rc_orig_data);\n\t}\n\n\tif (rr->rr_abd_empty != NULL)\n\t\tabd_free(rr->rr_abd_empty);\n\n\tkmem_free(rr, offsetof(raidz_row_t, rr_col[rr->rr_scols]));\n}\n\nvoid\nvdev_raidz_map_free(raidz_map_t *rm)\n{\n\tfor (int i = 0; i < rm->rm_nrows; i++)\n\t\tvdev_raidz_row_free(rm->rm_row[i]);\n\n\tkmem_free(rm, offsetof(raidz_map_t, rm_row[rm->rm_nrows]));\n}\n\nstatic void\nvdev_raidz_map_free_vsd(zio_t *zio)\n{\n\traidz_map_t *rm = zio->io_vsd;\n\n\tvdev_raidz_map_free(rm);\n}\n\nconst zio_vsd_ops_t vdev_raidz_vsd_ops = {\n\t.vsd_free = vdev_raidz_map_free_vsd,\n};\n\nstatic void\nvdev_raidz_map_alloc_write(zio_t *zio, raidz_map_t *rm, uint64_t ashift)\n{\n\tint c;\n\tint nwrapped = 0;\n\tuint64_t off = 0;\n\traidz_row_t *rr = rm->rm_row[0];\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_WRITE);\n\tASSERT3U(rm->rm_nrows, ==, 1);\n\n\t \n\tif (rm->rm_skipstart < rr->rr_firstdatacol) {\n\t\tASSERT0(rm->rm_skipstart);\n\t\tnwrapped = rm->rm_nskip;\n\t} else if (rr->rr_scols < (rm->rm_skipstart + rm->rm_nskip)) {\n\t\tnwrapped =\n\t\t    (rm->rm_skipstart + rm->rm_nskip) % rr->rr_scols;\n\t}\n\n\t \n\tint skipped = rr->rr_scols - rr->rr_cols;\n\n\t \n\tfor (c = 0; c < rr->rr_firstdatacol; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\t \n\t\tif (c < nwrapped) {\n\t\t\trc->rc_abd = abd_alloc_linear(\n\t\t\t    rc->rc_size + (1ULL << ashift), B_FALSE);\n\t\t\tabd_zero_off(rc->rc_abd, rc->rc_size, 1ULL << ashift);\n\t\t\tskipped++;\n\t\t} else {\n\t\t\trc->rc_abd = abd_alloc_linear(rc->rc_size, B_FALSE);\n\t\t}\n\t}\n\n\tfor (off = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tabd_t *abd = abd_get_offset_struct(&rc->rc_abdstruct,\n\t\t    zio->io_abd, off, rc->rc_size);\n\n\t\t \n\t\tif (c >= rm->rm_skipstart && skipped < rm->rm_nskip) {\n\t\t\trc->rc_abd = abd_alloc_gang();\n\t\t\tabd_gang_add(rc->rc_abd, abd, B_TRUE);\n\t\t\tabd_gang_add(rc->rc_abd,\n\t\t\t    abd_get_zeros(1ULL << ashift), B_TRUE);\n\t\t\tskipped++;\n\t\t} else {\n\t\t\trc->rc_abd = abd;\n\t\t}\n\t\toff += rc->rc_size;\n\t}\n\n\tASSERT3U(off, ==, zio->io_size);\n\tASSERT3S(skipped, ==, rm->rm_nskip);\n}\n\nstatic void\nvdev_raidz_map_alloc_read(zio_t *zio, raidz_map_t *rm)\n{\n\tint c;\n\traidz_row_t *rr = rm->rm_row[0];\n\n\tASSERT3U(rm->rm_nrows, ==, 1);\n\n\t \n\tfor (c = 0; c < rr->rr_firstdatacol; c++)\n\t\trr->rr_col[c].rc_abd =\n\t\t    abd_alloc_linear(rr->rr_col[c].rc_size, B_FALSE);\n\n\tfor (uint64_t off = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\trc->rc_abd = abd_get_offset_struct(&rc->rc_abdstruct,\n\t\t    zio->io_abd, off, rc->rc_size);\n\t\toff += rc->rc_size;\n\t}\n}\n\n \nnoinline raidz_map_t *\nvdev_raidz_map_alloc(zio_t *zio, uint64_t ashift, uint64_t dcols,\n    uint64_t nparity)\n{\n\traidz_row_t *rr;\n\t \n\tuint64_t b = zio->io_offset >> ashift;\n\t \n\tuint64_t s = zio->io_size >> ashift;\n\t \n\tuint64_t f = b % dcols;\n\t \n\tuint64_t o = (b / dcols) << ashift;\n\tuint64_t q, r, c, bc, col, acols, scols, coff, devidx, asize, tot;\n\n\traidz_map_t *rm =\n\t    kmem_zalloc(offsetof(raidz_map_t, rm_row[1]), KM_SLEEP);\n\trm->rm_nrows = 1;\n\n\t \n\tq = s / (dcols - nparity);\n\n\t \n\tr = s - q * (dcols - nparity);\n\n\t \n\tbc = (r == 0 ? 0 : r + nparity);\n\n\t \n\ttot = s + nparity * (q + (r == 0 ? 0 : 1));\n\n\t \n\tif (q == 0) {\n\t\t \n\t\tacols = bc;\n\t\tscols = MIN(dcols, roundup(bc, nparity + 1));\n\t} else {\n\t\tacols = dcols;\n\t\tscols = dcols;\n\t}\n\n\tASSERT3U(acols, <=, scols);\n\n\trr = kmem_alloc(offsetof(raidz_row_t, rr_col[scols]), KM_SLEEP);\n\trm->rm_row[0] = rr;\n\n\trr->rr_cols = acols;\n\trr->rr_scols = scols;\n\trr->rr_bigcols = bc;\n\trr->rr_missingdata = 0;\n\trr->rr_missingparity = 0;\n\trr->rr_firstdatacol = nparity;\n\trr->rr_abd_empty = NULL;\n\trr->rr_nempty = 0;\n#ifdef ZFS_DEBUG\n\trr->rr_offset = zio->io_offset;\n\trr->rr_size = zio->io_size;\n#endif\n\n\tasize = 0;\n\n\tfor (c = 0; c < scols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tcol = f + c;\n\t\tcoff = o;\n\t\tif (col >= dcols) {\n\t\t\tcol -= dcols;\n\t\t\tcoff += 1ULL << ashift;\n\t\t}\n\t\trc->rc_devidx = col;\n\t\trc->rc_offset = coff;\n\t\trc->rc_abd = NULL;\n\t\trc->rc_orig_data = NULL;\n\t\trc->rc_error = 0;\n\t\trc->rc_tried = 0;\n\t\trc->rc_skipped = 0;\n\t\trc->rc_force_repair = 0;\n\t\trc->rc_allow_repair = 1;\n\t\trc->rc_need_orig_restore = B_FALSE;\n\n\t\tif (c >= acols)\n\t\t\trc->rc_size = 0;\n\t\telse if (c < bc)\n\t\t\trc->rc_size = (q + 1) << ashift;\n\t\telse\n\t\t\trc->rc_size = q << ashift;\n\n\t\tasize += rc->rc_size;\n\t}\n\n\tASSERT3U(asize, ==, tot << ashift);\n\trm->rm_nskip = roundup(tot, nparity + 1) - tot;\n\trm->rm_skipstart = bc;\n\n\t \n\tASSERT(rr->rr_cols >= 2);\n\tASSERT(rr->rr_col[0].rc_size == rr->rr_col[1].rc_size);\n\n\tif (rr->rr_firstdatacol == 1 && (zio->io_offset & (1ULL << 20))) {\n\t\tdevidx = rr->rr_col[0].rc_devidx;\n\t\to = rr->rr_col[0].rc_offset;\n\t\trr->rr_col[0].rc_devidx = rr->rr_col[1].rc_devidx;\n\t\trr->rr_col[0].rc_offset = rr->rr_col[1].rc_offset;\n\t\trr->rr_col[1].rc_devidx = devidx;\n\t\trr->rr_col[1].rc_offset = o;\n\n\t\tif (rm->rm_skipstart == 0)\n\t\t\trm->rm_skipstart = 1;\n\t}\n\n\tif (zio->io_type == ZIO_TYPE_WRITE) {\n\t\tvdev_raidz_map_alloc_write(zio, rm, ashift);\n\t} else {\n\t\tvdev_raidz_map_alloc_read(zio, rm);\n\t}\n\n\t \n\trm->rm_ops = vdev_raidz_math_get_ops();\n\n\treturn (rm);\n}\n\nstruct pqr_struct {\n\tuint64_t *p;\n\tuint64_t *q;\n\tuint64_t *r;\n};\n\nstatic int\nvdev_raidz_p_func(void *buf, size_t size, void *private)\n{\n\tstruct pqr_struct *pqr = private;\n\tconst uint64_t *src = buf;\n\tint i, cnt = size / sizeof (src[0]);\n\n\tASSERT(pqr->p && !pqr->q && !pqr->r);\n\n\tfor (i = 0; i < cnt; i++, src++, pqr->p++)\n\t\t*pqr->p ^= *src;\n\n\treturn (0);\n}\n\nstatic int\nvdev_raidz_pq_func(void *buf, size_t size, void *private)\n{\n\tstruct pqr_struct *pqr = private;\n\tconst uint64_t *src = buf;\n\tuint64_t mask;\n\tint i, cnt = size / sizeof (src[0]);\n\n\tASSERT(pqr->p && pqr->q && !pqr->r);\n\n\tfor (i = 0; i < cnt; i++, src++, pqr->p++, pqr->q++) {\n\t\t*pqr->p ^= *src;\n\t\tVDEV_RAIDZ_64MUL_2(*pqr->q, mask);\n\t\t*pqr->q ^= *src;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nvdev_raidz_pqr_func(void *buf, size_t size, void *private)\n{\n\tstruct pqr_struct *pqr = private;\n\tconst uint64_t *src = buf;\n\tuint64_t mask;\n\tint i, cnt = size / sizeof (src[0]);\n\n\tASSERT(pqr->p && pqr->q && pqr->r);\n\n\tfor (i = 0; i < cnt; i++, src++, pqr->p++, pqr->q++, pqr->r++) {\n\t\t*pqr->p ^= *src;\n\t\tVDEV_RAIDZ_64MUL_2(*pqr->q, mask);\n\t\t*pqr->q ^= *src;\n\t\tVDEV_RAIDZ_64MUL_4(*pqr->r, mask);\n\t\t*pqr->r ^= *src;\n\t}\n\n\treturn (0);\n}\n\nstatic void\nvdev_raidz_generate_parity_p(raidz_row_t *rr)\n{\n\tuint64_t *p = abd_to_buf(rr->rr_col[VDEV_RAIDZ_P].rc_abd);\n\n\tfor (int c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\tabd_t *src = rr->rr_col[c].rc_abd;\n\n\t\tif (c == rr->rr_firstdatacol) {\n\t\t\tabd_copy_to_buf(p, src, rr->rr_col[c].rc_size);\n\t\t} else {\n\t\t\tstruct pqr_struct pqr = { p, NULL, NULL };\n\t\t\t(void) abd_iterate_func(src, 0, rr->rr_col[c].rc_size,\n\t\t\t    vdev_raidz_p_func, &pqr);\n\t\t}\n\t}\n}\n\nstatic void\nvdev_raidz_generate_parity_pq(raidz_row_t *rr)\n{\n\tuint64_t *p = abd_to_buf(rr->rr_col[VDEV_RAIDZ_P].rc_abd);\n\tuint64_t *q = abd_to_buf(rr->rr_col[VDEV_RAIDZ_Q].rc_abd);\n\tuint64_t pcnt = rr->rr_col[VDEV_RAIDZ_P].rc_size / sizeof (p[0]);\n\tASSERT(rr->rr_col[VDEV_RAIDZ_P].rc_size ==\n\t    rr->rr_col[VDEV_RAIDZ_Q].rc_size);\n\n\tfor (int c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\tabd_t *src = rr->rr_col[c].rc_abd;\n\n\t\tuint64_t ccnt = rr->rr_col[c].rc_size / sizeof (p[0]);\n\n\t\tif (c == rr->rr_firstdatacol) {\n\t\t\tASSERT(ccnt == pcnt || ccnt == 0);\n\t\t\tabd_copy_to_buf(p, src, rr->rr_col[c].rc_size);\n\t\t\t(void) memcpy(q, p, rr->rr_col[c].rc_size);\n\n\t\t\tfor (uint64_t i = ccnt; i < pcnt; i++) {\n\t\t\t\tp[i] = 0;\n\t\t\t\tq[i] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct pqr_struct pqr = { p, q, NULL };\n\n\t\t\tASSERT(ccnt <= pcnt);\n\t\t\t(void) abd_iterate_func(src, 0, rr->rr_col[c].rc_size,\n\t\t\t    vdev_raidz_pq_func, &pqr);\n\n\t\t\t \n\t\t\tuint64_t mask;\n\t\t\tfor (uint64_t i = ccnt; i < pcnt; i++) {\n\t\t\t\tVDEV_RAIDZ_64MUL_2(q[i], mask);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nvdev_raidz_generate_parity_pqr(raidz_row_t *rr)\n{\n\tuint64_t *p = abd_to_buf(rr->rr_col[VDEV_RAIDZ_P].rc_abd);\n\tuint64_t *q = abd_to_buf(rr->rr_col[VDEV_RAIDZ_Q].rc_abd);\n\tuint64_t *r = abd_to_buf(rr->rr_col[VDEV_RAIDZ_R].rc_abd);\n\tuint64_t pcnt = rr->rr_col[VDEV_RAIDZ_P].rc_size / sizeof (p[0]);\n\tASSERT(rr->rr_col[VDEV_RAIDZ_P].rc_size ==\n\t    rr->rr_col[VDEV_RAIDZ_Q].rc_size);\n\tASSERT(rr->rr_col[VDEV_RAIDZ_P].rc_size ==\n\t    rr->rr_col[VDEV_RAIDZ_R].rc_size);\n\n\tfor (int c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\tabd_t *src = rr->rr_col[c].rc_abd;\n\n\t\tuint64_t ccnt = rr->rr_col[c].rc_size / sizeof (p[0]);\n\n\t\tif (c == rr->rr_firstdatacol) {\n\t\t\tASSERT(ccnt == pcnt || ccnt == 0);\n\t\t\tabd_copy_to_buf(p, src, rr->rr_col[c].rc_size);\n\t\t\t(void) memcpy(q, p, rr->rr_col[c].rc_size);\n\t\t\t(void) memcpy(r, p, rr->rr_col[c].rc_size);\n\n\t\t\tfor (uint64_t i = ccnt; i < pcnt; i++) {\n\t\t\t\tp[i] = 0;\n\t\t\t\tq[i] = 0;\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct pqr_struct pqr = { p, q, r };\n\n\t\t\tASSERT(ccnt <= pcnt);\n\t\t\t(void) abd_iterate_func(src, 0, rr->rr_col[c].rc_size,\n\t\t\t    vdev_raidz_pqr_func, &pqr);\n\n\t\t\t \n\t\t\tuint64_t mask;\n\t\t\tfor (uint64_t i = ccnt; i < pcnt; i++) {\n\t\t\t\tVDEV_RAIDZ_64MUL_2(q[i], mask);\n\t\t\t\tVDEV_RAIDZ_64MUL_4(r[i], mask);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid\nvdev_raidz_generate_parity_row(raidz_map_t *rm, raidz_row_t *rr)\n{\n\tASSERT3U(rr->rr_cols, !=, 0);\n\n\t \n\tif (vdev_raidz_math_generate(rm, rr) != RAIDZ_ORIGINAL_IMPL)\n\t\treturn;\n\n\tswitch (rr->rr_firstdatacol) {\n\tcase 1:\n\t\tvdev_raidz_generate_parity_p(rr);\n\t\tbreak;\n\tcase 2:\n\t\tvdev_raidz_generate_parity_pq(rr);\n\t\tbreak;\n\tcase 3:\n\t\tvdev_raidz_generate_parity_pqr(rr);\n\t\tbreak;\n\tdefault:\n\t\tcmn_err(CE_PANIC, \"invalid RAID-Z configuration\");\n\t}\n}\n\nvoid\nvdev_raidz_generate_parity(raidz_map_t *rm)\n{\n\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\traidz_row_t *rr = rm->rm_row[i];\n\t\tvdev_raidz_generate_parity_row(rm, rr);\n\t}\n}\n\nstatic int\nvdev_raidz_reconst_p_func(void *dbuf, void *sbuf, size_t size, void *private)\n{\n\t(void) private;\n\tuint64_t *dst = dbuf;\n\tuint64_t *src = sbuf;\n\tint cnt = size / sizeof (src[0]);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tdst[i] ^= src[i];\n\t}\n\n\treturn (0);\n}\n\nstatic int\nvdev_raidz_reconst_q_pre_func(void *dbuf, void *sbuf, size_t size,\n    void *private)\n{\n\t(void) private;\n\tuint64_t *dst = dbuf;\n\tuint64_t *src = sbuf;\n\tuint64_t mask;\n\tint cnt = size / sizeof (dst[0]);\n\n\tfor (int i = 0; i < cnt; i++, dst++, src++) {\n\t\tVDEV_RAIDZ_64MUL_2(*dst, mask);\n\t\t*dst ^= *src;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nvdev_raidz_reconst_q_pre_tail_func(void *buf, size_t size, void *private)\n{\n\t(void) private;\n\tuint64_t *dst = buf;\n\tuint64_t mask;\n\tint cnt = size / sizeof (dst[0]);\n\n\tfor (int i = 0; i < cnt; i++, dst++) {\n\t\t \n\t\tVDEV_RAIDZ_64MUL_2(*dst, mask);\n\t}\n\n\treturn (0);\n}\n\nstruct reconst_q_struct {\n\tuint64_t *q;\n\tint exp;\n};\n\nstatic int\nvdev_raidz_reconst_q_post_func(void *buf, size_t size, void *private)\n{\n\tstruct reconst_q_struct *rq = private;\n\tuint64_t *dst = buf;\n\tint cnt = size / sizeof (dst[0]);\n\n\tfor (int i = 0; i < cnt; i++, dst++, rq->q++) {\n\t\tint j;\n\t\tuint8_t *b;\n\n\t\t*dst ^= *rq->q;\n\t\tfor (j = 0, b = (uint8_t *)dst; j < 8; j++, b++) {\n\t\t\t*b = vdev_raidz_exp2(*b, rq->exp);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstruct reconst_pq_struct {\n\tuint8_t *p;\n\tuint8_t *q;\n\tuint8_t *pxy;\n\tuint8_t *qxy;\n\tint aexp;\n\tint bexp;\n};\n\nstatic int\nvdev_raidz_reconst_pq_func(void *xbuf, void *ybuf, size_t size, void *private)\n{\n\tstruct reconst_pq_struct *rpq = private;\n\tuint8_t *xd = xbuf;\n\tuint8_t *yd = ybuf;\n\n\tfor (int i = 0; i < size;\n\t    i++, rpq->p++, rpq->q++, rpq->pxy++, rpq->qxy++, xd++, yd++) {\n\t\t*xd = vdev_raidz_exp2(*rpq->p ^ *rpq->pxy, rpq->aexp) ^\n\t\t    vdev_raidz_exp2(*rpq->q ^ *rpq->qxy, rpq->bexp);\n\t\t*yd = *rpq->p ^ *rpq->pxy ^ *xd;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nvdev_raidz_reconst_pq_tail_func(void *xbuf, size_t size, void *private)\n{\n\tstruct reconst_pq_struct *rpq = private;\n\tuint8_t *xd = xbuf;\n\n\tfor (int i = 0; i < size;\n\t    i++, rpq->p++, rpq->q++, rpq->pxy++, rpq->qxy++, xd++) {\n\t\t \n\t\t*xd = vdev_raidz_exp2(*rpq->p ^ *rpq->pxy, rpq->aexp) ^\n\t\t    vdev_raidz_exp2(*rpq->q ^ *rpq->qxy, rpq->bexp);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nvdev_raidz_reconstruct_p(raidz_row_t *rr, int *tgts, int ntgts)\n{\n\tint x = tgts[0];\n\tabd_t *dst, *src;\n\n\tASSERT3U(ntgts, ==, 1);\n\tASSERT3U(x, >=, rr->rr_firstdatacol);\n\tASSERT3U(x, <, rr->rr_cols);\n\n\tASSERT3U(rr->rr_col[x].rc_size, <=, rr->rr_col[VDEV_RAIDZ_P].rc_size);\n\n\tsrc = rr->rr_col[VDEV_RAIDZ_P].rc_abd;\n\tdst = rr->rr_col[x].rc_abd;\n\n\tabd_copy_from_buf(dst, abd_to_buf(src), rr->rr_col[x].rc_size);\n\n\tfor (int c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\tuint64_t size = MIN(rr->rr_col[x].rc_size,\n\t\t    rr->rr_col[c].rc_size);\n\n\t\tsrc = rr->rr_col[c].rc_abd;\n\n\t\tif (c == x)\n\t\t\tcontinue;\n\n\t\t(void) abd_iterate_func2(dst, src, 0, 0, size,\n\t\t    vdev_raidz_reconst_p_func, NULL);\n\t}\n}\n\nstatic void\nvdev_raidz_reconstruct_q(raidz_row_t *rr, int *tgts, int ntgts)\n{\n\tint x = tgts[0];\n\tint c, exp;\n\tabd_t *dst, *src;\n\n\tASSERT(ntgts == 1);\n\n\tASSERT(rr->rr_col[x].rc_size <= rr->rr_col[VDEV_RAIDZ_Q].rc_size);\n\n\tfor (c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\tuint64_t size = (c == x) ? 0 : MIN(rr->rr_col[x].rc_size,\n\t\t    rr->rr_col[c].rc_size);\n\n\t\tsrc = rr->rr_col[c].rc_abd;\n\t\tdst = rr->rr_col[x].rc_abd;\n\n\t\tif (c == rr->rr_firstdatacol) {\n\t\t\tabd_copy(dst, src, size);\n\t\t\tif (rr->rr_col[x].rc_size > size) {\n\t\t\t\tabd_zero_off(dst, size,\n\t\t\t\t    rr->rr_col[x].rc_size - size);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT3U(size, <=, rr->rr_col[x].rc_size);\n\t\t\t(void) abd_iterate_func2(dst, src, 0, 0, size,\n\t\t\t    vdev_raidz_reconst_q_pre_func, NULL);\n\t\t\t(void) abd_iterate_func(dst,\n\t\t\t    size, rr->rr_col[x].rc_size - size,\n\t\t\t    vdev_raidz_reconst_q_pre_tail_func, NULL);\n\t\t}\n\t}\n\n\tsrc = rr->rr_col[VDEV_RAIDZ_Q].rc_abd;\n\tdst = rr->rr_col[x].rc_abd;\n\texp = 255 - (rr->rr_cols - 1 - x);\n\n\tstruct reconst_q_struct rq = { abd_to_buf(src), exp };\n\t(void) abd_iterate_func(dst, 0, rr->rr_col[x].rc_size,\n\t    vdev_raidz_reconst_q_post_func, &rq);\n}\n\nstatic void\nvdev_raidz_reconstruct_pq(raidz_row_t *rr, int *tgts, int ntgts)\n{\n\tuint8_t *p, *q, *pxy, *qxy, tmp, a, b, aexp, bexp;\n\tabd_t *pdata, *qdata;\n\tuint64_t xsize, ysize;\n\tint x = tgts[0];\n\tint y = tgts[1];\n\tabd_t *xd, *yd;\n\n\tASSERT(ntgts == 2);\n\tASSERT(x < y);\n\tASSERT(x >= rr->rr_firstdatacol);\n\tASSERT(y < rr->rr_cols);\n\n\tASSERT(rr->rr_col[x].rc_size >= rr->rr_col[y].rc_size);\n\n\t \n\tpdata = rr->rr_col[VDEV_RAIDZ_P].rc_abd;\n\tqdata = rr->rr_col[VDEV_RAIDZ_Q].rc_abd;\n\txsize = rr->rr_col[x].rc_size;\n\tysize = rr->rr_col[y].rc_size;\n\n\trr->rr_col[VDEV_RAIDZ_P].rc_abd =\n\t    abd_alloc_linear(rr->rr_col[VDEV_RAIDZ_P].rc_size, B_TRUE);\n\trr->rr_col[VDEV_RAIDZ_Q].rc_abd =\n\t    abd_alloc_linear(rr->rr_col[VDEV_RAIDZ_Q].rc_size, B_TRUE);\n\trr->rr_col[x].rc_size = 0;\n\trr->rr_col[y].rc_size = 0;\n\n\tvdev_raidz_generate_parity_pq(rr);\n\n\trr->rr_col[x].rc_size = xsize;\n\trr->rr_col[y].rc_size = ysize;\n\n\tp = abd_to_buf(pdata);\n\tq = abd_to_buf(qdata);\n\tpxy = abd_to_buf(rr->rr_col[VDEV_RAIDZ_P].rc_abd);\n\tqxy = abd_to_buf(rr->rr_col[VDEV_RAIDZ_Q].rc_abd);\n\txd = rr->rr_col[x].rc_abd;\n\tyd = rr->rr_col[y].rc_abd;\n\n\t \n\n\ta = vdev_raidz_pow2[255 + x - y];\n\tb = vdev_raidz_pow2[255 - (rr->rr_cols - 1 - x)];\n\ttmp = 255 - vdev_raidz_log2[a ^ 1];\n\n\taexp = vdev_raidz_log2[vdev_raidz_exp2(a, tmp)];\n\tbexp = vdev_raidz_log2[vdev_raidz_exp2(b, tmp)];\n\n\tASSERT3U(xsize, >=, ysize);\n\tstruct reconst_pq_struct rpq = { p, q, pxy, qxy, aexp, bexp };\n\n\t(void) abd_iterate_func2(xd, yd, 0, 0, ysize,\n\t    vdev_raidz_reconst_pq_func, &rpq);\n\t(void) abd_iterate_func(xd, ysize, xsize - ysize,\n\t    vdev_raidz_reconst_pq_tail_func, &rpq);\n\n\tabd_free(rr->rr_col[VDEV_RAIDZ_P].rc_abd);\n\tabd_free(rr->rr_col[VDEV_RAIDZ_Q].rc_abd);\n\n\t \n\trr->rr_col[VDEV_RAIDZ_P].rc_abd = pdata;\n\trr->rr_col[VDEV_RAIDZ_Q].rc_abd = qdata;\n}\n\n \n\nstatic void\nvdev_raidz_matrix_init(raidz_row_t *rr, int n, int nmap, int *map,\n    uint8_t **rows)\n{\n\tint i, j;\n\tint pow;\n\n\tASSERT(n == rr->rr_cols - rr->rr_firstdatacol);\n\n\t \n\tfor (i = 0; i < nmap; i++) {\n\t\tASSERT3S(0, <=, map[i]);\n\t\tASSERT3S(map[i], <=, 2);\n\n\t\tpow = map[i] * n;\n\t\tif (pow > 255)\n\t\t\tpow -= 255;\n\t\tASSERT(pow <= 255);\n\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tpow -= map[i];\n\t\t\tif (pow < 0)\n\t\t\t\tpow += 255;\n\t\t\trows[i][j] = vdev_raidz_pow2[pow];\n\t\t}\n\t}\n}\n\nstatic void\nvdev_raidz_matrix_invert(raidz_row_t *rr, int n, int nmissing, int *missing,\n    uint8_t **rows, uint8_t **invrows, const uint8_t *used)\n{\n\tint i, j, ii, jj;\n\tuint8_t log;\n\n\t \n\tfor (i = 0; i < nmissing; i++) {\n\t\tASSERT3S(used[i], <, rr->rr_firstdatacol);\n\t}\n\tfor (; i < n; i++) {\n\t\tASSERT3S(used[i], >=, rr->rr_firstdatacol);\n\t}\n\n\t \n\tfor (i = 0; i < nmissing; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tinvrows[i][j] = (i == j) ? 1 : 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < nmissing; i++) {\n\t\tfor (j = nmissing; j < n; j++) {\n\t\t\tASSERT3U(used[j], >=, rr->rr_firstdatacol);\n\t\t\tjj = used[j] - rr->rr_firstdatacol;\n\t\t\tASSERT3S(jj, <, n);\n\t\t\tinvrows[i][j] = rows[i][jj];\n\t\t\trows[i][jj] = 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < nmissing; i++) {\n\t\tfor (j = 0; j < missing[i]; j++) {\n\t\t\tASSERT0(rows[i][j]);\n\t\t}\n\t\tASSERT3U(rows[i][missing[i]], !=, 0);\n\n\t\t \n\t\tlog = 255 - vdev_raidz_log2[rows[i][missing[i]]];\n\n\t\tfor (j = 0; j < n; j++) {\n\t\t\trows[i][j] = vdev_raidz_exp2(rows[i][j], log);\n\t\t\tinvrows[i][j] = vdev_raidz_exp2(invrows[i][j], log);\n\t\t}\n\n\t\tfor (ii = 0; ii < nmissing; ii++) {\n\t\t\tif (i == ii)\n\t\t\t\tcontinue;\n\n\t\t\tASSERT3U(rows[ii][missing[i]], !=, 0);\n\n\t\t\tlog = vdev_raidz_log2[rows[ii][missing[i]]];\n\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\trows[ii][j] ^=\n\t\t\t\t    vdev_raidz_exp2(rows[i][j], log);\n\t\t\t\tinvrows[ii][j] ^=\n\t\t\t\t    vdev_raidz_exp2(invrows[i][j], log);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < nmissing; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (j == missing[i]) {\n\t\t\t\tASSERT3U(rows[i][j], ==, 1);\n\t\t\t} else {\n\t\t\t\tASSERT0(rows[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nvdev_raidz_matrix_reconstruct(raidz_row_t *rr, int n, int nmissing,\n    int *missing, uint8_t **invrows, const uint8_t *used)\n{\n\tint i, j, x, cc, c;\n\tuint8_t *src;\n\tuint64_t ccount;\n\tuint8_t *dst[VDEV_RAIDZ_MAXPARITY] = { NULL };\n\tuint64_t dcount[VDEV_RAIDZ_MAXPARITY] = { 0 };\n\tuint8_t log = 0;\n\tuint8_t val;\n\tint ll;\n\tuint8_t *invlog[VDEV_RAIDZ_MAXPARITY];\n\tuint8_t *p, *pp;\n\tsize_t psize;\n\n\tpsize = sizeof (invlog[0][0]) * n * nmissing;\n\tp = kmem_alloc(psize, KM_SLEEP);\n\n\tfor (pp = p, i = 0; i < nmissing; i++) {\n\t\tinvlog[i] = pp;\n\t\tpp += n;\n\t}\n\n\tfor (i = 0; i < nmissing; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tASSERT3U(invrows[i][j], !=, 0);\n\t\t\tinvlog[i][j] = vdev_raidz_log2[invrows[i][j]];\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tc = used[i];\n\t\tASSERT3U(c, <, rr->rr_cols);\n\n\t\tccount = rr->rr_col[c].rc_size;\n\t\tASSERT(ccount >= rr->rr_col[missing[0]].rc_size || i > 0);\n\t\tif (ccount == 0)\n\t\t\tcontinue;\n\t\tsrc = abd_to_buf(rr->rr_col[c].rc_abd);\n\t\tfor (j = 0; j < nmissing; j++) {\n\t\t\tcc = missing[j] + rr->rr_firstdatacol;\n\t\t\tASSERT3U(cc, >=, rr->rr_firstdatacol);\n\t\t\tASSERT3U(cc, <, rr->rr_cols);\n\t\t\tASSERT3U(cc, !=, c);\n\n\t\t\tdcount[j] = rr->rr_col[cc].rc_size;\n\t\t\tif (dcount[j] != 0)\n\t\t\t\tdst[j] = abd_to_buf(rr->rr_col[cc].rc_abd);\n\t\t}\n\n\t\tfor (x = 0; x < ccount; x++, src++) {\n\t\t\tif (*src != 0)\n\t\t\t\tlog = vdev_raidz_log2[*src];\n\n\t\t\tfor (cc = 0; cc < nmissing; cc++) {\n\t\t\t\tif (x >= dcount[cc])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (*src == 0) {\n\t\t\t\t\tval = 0;\n\t\t\t\t} else {\n\t\t\t\t\tif ((ll = log + invlog[cc][i]) >= 255)\n\t\t\t\t\t\tll -= 255;\n\t\t\t\t\tval = vdev_raidz_pow2[ll];\n\t\t\t\t}\n\n\t\t\t\tif (i == 0)\n\t\t\t\t\tdst[cc][x] = val;\n\t\t\t\telse\n\t\t\t\t\tdst[cc][x] ^= val;\n\t\t\t}\n\t\t}\n\t}\n\n\tkmem_free(p, psize);\n}\n\nstatic void\nvdev_raidz_reconstruct_general(raidz_row_t *rr, int *tgts, int ntgts)\n{\n\tint n, i, c, t, tt;\n\tint nmissing_rows;\n\tint missing_rows[VDEV_RAIDZ_MAXPARITY];\n\tint parity_map[VDEV_RAIDZ_MAXPARITY];\n\tuint8_t *p, *pp;\n\tsize_t psize;\n\tuint8_t *rows[VDEV_RAIDZ_MAXPARITY];\n\tuint8_t *invrows[VDEV_RAIDZ_MAXPARITY];\n\tuint8_t *used;\n\n\tabd_t **bufs = NULL;\n\n\t \n\tfor (i = rr->rr_firstdatacol; i < rr->rr_cols; i++) {\n\t\tif (!abd_is_linear(rr->rr_col[i].rc_abd)) {\n\t\t\tbufs = kmem_alloc(rr->rr_cols * sizeof (abd_t *),\n\t\t\t    KM_PUSHPAGE);\n\n\t\t\tfor (c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\t\t\traidz_col_t *col = &rr->rr_col[c];\n\n\t\t\t\tbufs[c] = col->rc_abd;\n\t\t\t\tif (bufs[c] != NULL) {\n\t\t\t\t\tcol->rc_abd = abd_alloc_linear(\n\t\t\t\t\t    col->rc_size, B_TRUE);\n\t\t\t\t\tabd_copy(col->rc_abd, bufs[c],\n\t\t\t\t\t    col->rc_size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn = rr->rr_cols - rr->rr_firstdatacol;\n\n\t \n\tnmissing_rows = 0;\n\tfor (t = 0; t < ntgts; t++) {\n\t\tif (tgts[t] >= rr->rr_firstdatacol) {\n\t\t\tmissing_rows[nmissing_rows++] =\n\t\t\t    tgts[t] - rr->rr_firstdatacol;\n\t\t}\n\t}\n\n\t \n\tfor (tt = 0, c = 0, i = 0; i < nmissing_rows; c++) {\n\t\tASSERT(tt < ntgts);\n\t\tASSERT(c < rr->rr_firstdatacol);\n\n\t\t \n\t\tif (c == tgts[tt]) {\n\t\t\ttt++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tparity_map[i] = c;\n\t\ti++;\n\t}\n\n\tpsize = (sizeof (rows[0][0]) + sizeof (invrows[0][0])) *\n\t    nmissing_rows * n + sizeof (used[0]) * n;\n\tp = kmem_alloc(psize, KM_SLEEP);\n\n\tfor (pp = p, i = 0; i < nmissing_rows; i++) {\n\t\trows[i] = pp;\n\t\tpp += n;\n\t\tinvrows[i] = pp;\n\t\tpp += n;\n\t}\n\tused = pp;\n\n\tfor (i = 0; i < nmissing_rows; i++) {\n\t\tused[i] = parity_map[i];\n\t}\n\n\tfor (tt = 0, c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\tif (tt < nmissing_rows &&\n\t\t    c == missing_rows[tt] + rr->rr_firstdatacol) {\n\t\t\ttt++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tASSERT3S(i, <, n);\n\t\tused[i] = c;\n\t\ti++;\n\t}\n\n\t \n\tvdev_raidz_matrix_init(rr, n, nmissing_rows, parity_map, rows);\n\n\t \n\tvdev_raidz_matrix_invert(rr, n, nmissing_rows, missing_rows, rows,\n\t    invrows, used);\n\n\t \n\tvdev_raidz_matrix_reconstruct(rr, n, nmissing_rows, missing_rows,\n\t    invrows, used);\n\n\tkmem_free(p, psize);\n\n\t \n\tif (bufs) {\n\t\tfor (c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\t\traidz_col_t *col = &rr->rr_col[c];\n\n\t\t\tif (bufs[c] != NULL) {\n\t\t\t\tabd_copy(bufs[c], col->rc_abd, col->rc_size);\n\t\t\t\tabd_free(col->rc_abd);\n\t\t\t}\n\t\t\tcol->rc_abd = bufs[c];\n\t\t}\n\t\tkmem_free(bufs, rr->rr_cols * sizeof (abd_t *));\n\t}\n}\n\nstatic void\nvdev_raidz_reconstruct_row(raidz_map_t *rm, raidz_row_t *rr,\n    const int *t, int nt)\n{\n\tint tgts[VDEV_RAIDZ_MAXPARITY], *dt;\n\tint ntgts;\n\tint i, c, ret;\n\tint nbadparity, nbaddata;\n\tint parity_valid[VDEV_RAIDZ_MAXPARITY];\n\n\tnbadparity = rr->rr_firstdatacol;\n\tnbaddata = rr->rr_cols - nbadparity;\n\tntgts = 0;\n\tfor (i = 0, c = 0; c < rr->rr_cols; c++) {\n\t\tif (c < rr->rr_firstdatacol)\n\t\t\tparity_valid[c] = B_FALSE;\n\n\t\tif (i < nt && c == t[i]) {\n\t\t\ttgts[ntgts++] = c;\n\t\t\ti++;\n\t\t} else if (rr->rr_col[c].rc_error != 0) {\n\t\t\ttgts[ntgts++] = c;\n\t\t} else if (c >= rr->rr_firstdatacol) {\n\t\t\tnbaddata--;\n\t\t} else {\n\t\t\tparity_valid[c] = B_TRUE;\n\t\t\tnbadparity--;\n\t\t}\n\t}\n\n\tASSERT(ntgts >= nt);\n\tASSERT(nbaddata >= 0);\n\tASSERT(nbaddata + nbadparity == ntgts);\n\n\tdt = &tgts[nbadparity];\n\n\t \n\tret = vdev_raidz_math_reconstruct(rm, rr, parity_valid, dt, nbaddata);\n\tif (ret != RAIDZ_ORIGINAL_IMPL)\n\t\treturn;\n\n\t \n\tswitch (nbaddata) {\n\tcase 1:\n\t\tif (parity_valid[VDEV_RAIDZ_P]) {\n\t\t\tvdev_raidz_reconstruct_p(rr, dt, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tASSERT(rr->rr_firstdatacol > 1);\n\n\t\tif (parity_valid[VDEV_RAIDZ_Q]) {\n\t\t\tvdev_raidz_reconstruct_q(rr, dt, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tASSERT(rr->rr_firstdatacol > 2);\n\t\tbreak;\n\n\tcase 2:\n\t\tASSERT(rr->rr_firstdatacol > 1);\n\n\t\tif (parity_valid[VDEV_RAIDZ_P] &&\n\t\t    parity_valid[VDEV_RAIDZ_Q]) {\n\t\t\tvdev_raidz_reconstruct_pq(rr, dt, 2);\n\t\t\treturn;\n\t\t}\n\n\t\tASSERT(rr->rr_firstdatacol > 2);\n\n\t\tbreak;\n\t}\n\n\tvdev_raidz_reconstruct_general(rr, tgts, ntgts);\n}\n\nstatic int\nvdev_raidz_open(vdev_t *vd, uint64_t *asize, uint64_t *max_asize,\n    uint64_t *logical_ashift, uint64_t *physical_ashift)\n{\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\tuint64_t nparity = vdrz->vd_nparity;\n\tint c;\n\tint lasterror = 0;\n\tint numerrors = 0;\n\n\tASSERT(nparity > 0);\n\n\tif (nparity > VDEV_RAIDZ_MAXPARITY ||\n\t    vd->vdev_children < nparity + 1) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_BAD_LABEL;\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tvdev_open_children(vd);\n\n\tfor (c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (cvd->vdev_open_error != 0) {\n\t\t\tlasterror = cvd->vdev_open_error;\n\t\t\tnumerrors++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t*asize = MIN(*asize - 1, cvd->vdev_asize - 1) + 1;\n\t\t*max_asize = MIN(*max_asize - 1, cvd->vdev_max_asize - 1) + 1;\n\t\t*logical_ashift = MAX(*logical_ashift, cvd->vdev_ashift);\n\t}\n\tfor (c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (cvd->vdev_open_error != 0)\n\t\t\tcontinue;\n\t\t*physical_ashift = vdev_best_ashift(*logical_ashift,\n\t\t    *physical_ashift, cvd->vdev_physical_ashift);\n\t}\n\n\t*asize *= vd->vdev_children;\n\t*max_asize *= vd->vdev_children;\n\n\tif (numerrors > nparity) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_NO_REPLICAS;\n\t\treturn (lasterror);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nvdev_raidz_close(vdev_t *vd)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tif (vd->vdev_child[c] != NULL)\n\t\t\tvdev_close(vd->vdev_child[c]);\n\t}\n}\n\nstatic uint64_t\nvdev_raidz_asize(vdev_t *vd, uint64_t psize)\n{\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\tuint64_t asize;\n\tuint64_t ashift = vd->vdev_top->vdev_ashift;\n\tuint64_t cols = vdrz->vd_logical_width;\n\tuint64_t nparity = vdrz->vd_nparity;\n\n\tasize = ((psize - 1) >> ashift) + 1;\n\tasize += nparity * ((asize + cols - nparity - 1) / (cols - nparity));\n\tasize = roundup(asize, nparity + 1) << ashift;\n\n\treturn (asize);\n}\n\n \nstatic uint64_t\nvdev_raidz_min_asize(vdev_t *vd)\n{\n\treturn ((vd->vdev_min_asize + vd->vdev_children - 1) /\n\t    vd->vdev_children);\n}\n\nvoid\nvdev_raidz_child_done(zio_t *zio)\n{\n\traidz_col_t *rc = zio->io_private;\n\n\tASSERT3P(rc->rc_abd, !=, NULL);\n\trc->rc_error = zio->io_error;\n\trc->rc_tried = 1;\n\trc->rc_skipped = 0;\n}\n\nstatic void\nvdev_raidz_io_verify(vdev_t *vd, raidz_row_t *rr, int col)\n{\n#ifdef ZFS_DEBUG\n\tvdev_t *tvd = vd->vdev_top;\n\n\trange_seg64_t logical_rs, physical_rs, remain_rs;\n\tlogical_rs.rs_start = rr->rr_offset;\n\tlogical_rs.rs_end = logical_rs.rs_start +\n\t    vdev_raidz_asize(vd, rr->rr_size);\n\n\traidz_col_t *rc = &rr->rr_col[col];\n\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\n\tvdev_xlate(cvd, &logical_rs, &physical_rs, &remain_rs);\n\tASSERT(vdev_xlate_is_empty(&remain_rs));\n\tASSERT3U(rc->rc_offset, ==, physical_rs.rs_start);\n\tASSERT3U(rc->rc_offset, <, physical_rs.rs_end);\n\t \n\tif (physical_rs.rs_end > rc->rc_offset + rc->rc_size) {\n\t\tASSERT3U(physical_rs.rs_end, ==, rc->rc_offset +\n\t\t    rc->rc_size + (1 << tvd->vdev_ashift));\n\t} else {\n\t\tASSERT3U(physical_rs.rs_end, ==, rc->rc_offset + rc->rc_size);\n\t}\n#endif\n}\n\nstatic void\nvdev_raidz_io_start_write(zio_t *zio, raidz_row_t *rr, uint64_t ashift)\n{\n\tvdev_t *vd = zio->io_vd;\n\traidz_map_t *rm = zio->io_vsd;\n\n\tvdev_raidz_generate_parity_row(rm, rr);\n\n\tfor (int c = 0; c < rr->rr_scols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\n\t\t \n\t\tvdev_raidz_io_verify(vd, rr, c);\n\n\t\tif (rc->rc_size > 0) {\n\t\t\tASSERT3P(rc->rc_abd, !=, NULL);\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t    rc->rc_offset, rc->rc_abd,\n\t\t\t    abd_get_size(rc->rc_abd), zio->io_type,\n\t\t\t    zio->io_priority, 0, vdev_raidz_child_done, rc));\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3P(rc->rc_abd, ==, NULL);\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t    rc->rc_offset, NULL, 1ULL << ashift,\n\t\t\t    zio->io_type, zio->io_priority,\n\t\t\t    ZIO_FLAG_NODATA | ZIO_FLAG_OPTIONAL, NULL,\n\t\t\t    NULL));\n\t\t}\n\t}\n}\n\nstatic void\nvdev_raidz_io_start_read(zio_t *zio, raidz_row_t *rr)\n{\n\tvdev_t *vd = zio->io_vd;\n\n\t \n\tfor (int c = rr->rr_cols - 1; c >= 0; c--) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tif (rc->rc_size == 0)\n\t\t\tcontinue;\n\t\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\t\tif (!vdev_readable(cvd)) {\n\t\t\tif (c >= rr->rr_firstdatacol)\n\t\t\t\trr->rr_missingdata++;\n\t\t\telse\n\t\t\t\trr->rr_missingparity++;\n\t\t\trc->rc_error = SET_ERROR(ENXIO);\n\t\t\trc->rc_tried = 1;\t \n\t\t\trc->rc_skipped = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (vdev_dtl_contains(cvd, DTL_MISSING, zio->io_txg, 1)) {\n\t\t\tif (c >= rr->rr_firstdatacol)\n\t\t\t\trr->rr_missingdata++;\n\t\t\telse\n\t\t\t\trr->rr_missingparity++;\n\t\t\trc->rc_error = SET_ERROR(ESTALE);\n\t\t\trc->rc_skipped = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c >= rr->rr_firstdatacol || rr->rr_missingdata > 0 ||\n\t\t    (zio->io_flags & (ZIO_FLAG_SCRUB | ZIO_FLAG_RESILVER))) {\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t    rc->rc_offset, rc->rc_abd, rc->rc_size,\n\t\t\t    zio->io_type, zio->io_priority, 0,\n\t\t\t    vdev_raidz_child_done, rc));\n\t\t}\n\t}\n}\n\n \nstatic void\nvdev_raidz_io_start(zio_t *zio)\n{\n\tvdev_t *vd = zio->io_vd;\n\tvdev_t *tvd = vd->vdev_top;\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\n\traidz_map_t *rm = vdev_raidz_map_alloc(zio, tvd->vdev_ashift,\n\t    vdrz->vd_logical_width, vdrz->vd_nparity);\n\tzio->io_vsd = rm;\n\tzio->io_vsd_ops = &vdev_raidz_vsd_ops;\n\n\t \n\tASSERT3U(rm->rm_nrows, ==, 1);\n\traidz_row_t *rr = rm->rm_row[0];\n\n\tif (zio->io_type == ZIO_TYPE_WRITE) {\n\t\tvdev_raidz_io_start_write(zio, rr, tvd->vdev_ashift);\n\t} else {\n\t\tASSERT(zio->io_type == ZIO_TYPE_READ);\n\t\tvdev_raidz_io_start_read(zio, rr);\n\t}\n\n\tzio_execute(zio);\n}\n\n \nvoid\nvdev_raidz_checksum_error(zio_t *zio, raidz_col_t *rc, abd_t *bad_data)\n{\n\tvdev_t *vd = zio->io_vd->vdev_child[rc->rc_devidx];\n\n\tif (!(zio->io_flags & ZIO_FLAG_SPECULATIVE) &&\n\t    zio->io_priority != ZIO_PRIORITY_REBUILD) {\n\t\tzio_bad_cksum_t zbc;\n\t\traidz_map_t *rm = zio->io_vsd;\n\n\t\tzbc.zbc_has_cksum = 0;\n\t\tzbc.zbc_injected = rm->rm_ecksuminjected;\n\n\t\tmutex_enter(&vd->vdev_stat_lock);\n\t\tvd->vdev_stat.vs_checksum_errors++;\n\t\tmutex_exit(&vd->vdev_stat_lock);\n\t\t(void) zfs_ereport_post_checksum(zio->io_spa, vd,\n\t\t    &zio->io_bookmark, zio, rc->rc_offset, rc->rc_size,\n\t\t    rc->rc_abd, bad_data, &zbc);\n\t}\n}\n\n \nstatic int\nraidz_checksum_verify(zio_t *zio)\n{\n\tzio_bad_cksum_t zbc = {0};\n\traidz_map_t *rm = zio->io_vsd;\n\n\tint ret = zio_checksum_error(zio, &zbc);\n\tif (ret != 0 && zbc.zbc_injected != 0)\n\t\trm->rm_ecksuminjected = 1;\n\n\treturn (ret);\n}\n\n \nstatic int\nraidz_parity_verify(zio_t *zio, raidz_row_t *rr)\n{\n\tabd_t *orig[VDEV_RAIDZ_MAXPARITY];\n\tint c, ret = 0;\n\traidz_map_t *rm = zio->io_vsd;\n\traidz_col_t *rc;\n\n\tblkptr_t *bp = zio->io_bp;\n\tenum zio_checksum checksum = (bp == NULL ? zio->io_prop.zp_checksum :\n\t    (BP_IS_GANG(bp) ? ZIO_CHECKSUM_GANG_HEADER : BP_GET_CHECKSUM(bp)));\n\n\tif (checksum == ZIO_CHECKSUM_NOPARITY)\n\t\treturn (ret);\n\n\tfor (c = 0; c < rr->rr_firstdatacol; c++) {\n\t\trc = &rr->rr_col[c];\n\t\tif (!rc->rc_tried || rc->rc_error != 0)\n\t\t\tcontinue;\n\n\t\torig[c] = rc->rc_abd;\n\t\tASSERT3U(abd_get_size(rc->rc_abd), ==, rc->rc_size);\n\t\trc->rc_abd = abd_alloc_linear(rc->rc_size, B_FALSE);\n\t}\n\n\t \n\tif (rr->rr_nempty && rr->rr_abd_empty != NULL)\n\t\tret += vdev_draid_map_verify_empty(zio, rr);\n\n\t \n\tvdev_raidz_generate_parity_row(rm, rr);\n\n\tfor (c = 0; c < rr->rr_firstdatacol; c++) {\n\t\trc = &rr->rr_col[c];\n\n\t\tif (!rc->rc_tried || rc->rc_error != 0)\n\t\t\tcontinue;\n\n\t\tif (abd_cmp(orig[c], rc->rc_abd) != 0) {\n\t\t\tvdev_raidz_checksum_error(zio, rc, orig[c]);\n\t\t\trc->rc_error = SET_ERROR(ECKSUM);\n\t\t\tret++;\n\t\t}\n\t\tabd_free(orig[c]);\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nvdev_raidz_worst_error(raidz_row_t *rr)\n{\n\tint error = 0;\n\n\tfor (int c = 0; c < rr->rr_cols; c++)\n\t\terror = zio_worst_error(error, rr->rr_col[c].rc_error);\n\n\treturn (error);\n}\n\nstatic void\nvdev_raidz_io_done_verified(zio_t *zio, raidz_row_t *rr)\n{\n\tint unexpected_errors = 0;\n\tint parity_errors = 0;\n\tint parity_untried = 0;\n\tint data_errors = 0;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\n\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_error) {\n\t\t\tif (c < rr->rr_firstdatacol)\n\t\t\t\tparity_errors++;\n\t\t\telse\n\t\t\t\tdata_errors++;\n\n\t\t\tif (!rc->rc_skipped)\n\t\t\t\tunexpected_errors++;\n\t\t} else if (c < rr->rr_firstdatacol && !rc->rc_tried) {\n\t\t\tparity_untried++;\n\t\t}\n\n\t\tif (rc->rc_force_repair)\n\t\t\tunexpected_errors++;\n\t}\n\n\t \n\tif (parity_errors + parity_untried <\n\t    rr->rr_firstdatacol - data_errors ||\n\t    (zio->io_flags & ZIO_FLAG_RESILVER)) {\n\t\tint n = raidz_parity_verify(zio, rr);\n\t\tunexpected_errors += n;\n\t}\n\n\tif (zio->io_error == 0 && spa_writeable(zio->io_spa) &&\n\t    (unexpected_errors > 0 || (zio->io_flags & ZIO_FLAG_RESILVER))) {\n\t\t \n\t\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\t\tvdev_t *vd = zio->io_vd;\n\t\t\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\n\t\t\tif (!rc->rc_allow_repair) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!rc->rc_force_repair &&\n\t\t\t    (rc->rc_error == 0 || rc->rc_size == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t    rc->rc_offset, rc->rc_abd, rc->rc_size,\n\t\t\t    ZIO_TYPE_WRITE,\n\t\t\t    zio->io_priority == ZIO_PRIORITY_REBUILD ?\n\t\t\t    ZIO_PRIORITY_REBUILD : ZIO_PRIORITY_ASYNC_WRITE,\n\t\t\t    ZIO_FLAG_IO_REPAIR | (unexpected_errors ?\n\t\t\t    ZIO_FLAG_SELF_HEAL : 0), NULL, NULL));\n\t\t}\n\t}\n}\n\nstatic void\nraidz_restore_orig_data(raidz_map_t *rm)\n{\n\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\traidz_row_t *rr = rm->rm_row[i];\n\t\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\t\tif (rc->rc_need_orig_restore) {\n\t\t\t\tabd_copy(rc->rc_abd,\n\t\t\t\t    rc->rc_orig_data, rc->rc_size);\n\t\t\t\trc->rc_need_orig_restore = B_FALSE;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int\nraidz_reconstruct(zio_t *zio, int *ltgts, int ntgts, int nparity)\n{\n\traidz_map_t *rm = zio->io_vsd;\n\n\t \n\tfor (int r = 0; r < rm->rm_nrows; r++) {\n\t\traidz_row_t *rr = rm->rm_row[r];\n\t\tint my_tgts[VDEV_RAIDZ_MAXPARITY];  \n\t\tint t = 0;\n\t\tint dead = 0;\n\t\tint dead_data = 0;\n\n\t\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\t\tASSERT0(rc->rc_need_orig_restore);\n\t\t\tif (rc->rc_error != 0) {\n\t\t\t\tdead++;\n\t\t\t\tif (c >= nparity)\n\t\t\t\t\tdead_data++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rc->rc_size == 0)\n\t\t\t\tcontinue;\n\t\t\tfor (int lt = 0; lt < ntgts; lt++) {\n\t\t\t\tif (rc->rc_devidx == ltgts[lt]) {\n\t\t\t\t\tif (rc->rc_orig_data == NULL) {\n\t\t\t\t\t\trc->rc_orig_data =\n\t\t\t\t\t\t    abd_alloc_linear(\n\t\t\t\t\t\t    rc->rc_size, B_TRUE);\n\t\t\t\t\t\tabd_copy(rc->rc_orig_data,\n\t\t\t\t\t\t    rc->rc_abd, rc->rc_size);\n\t\t\t\t\t}\n\t\t\t\t\trc->rc_need_orig_restore = B_TRUE;\n\n\t\t\t\t\tdead++;\n\t\t\t\t\tif (c >= nparity)\n\t\t\t\t\t\tdead_data++;\n\t\t\t\t\tmy_tgts[t++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dead > nparity) {\n\t\t\t \n\t\t\traidz_restore_orig_data(rm);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tif (dead_data > 0)\n\t\t\tvdev_raidz_reconstruct_row(rm, rr, my_tgts, t);\n\t}\n\n\t \n\tif (raidz_checksum_verify(zio) == 0) {\n\n\t\t \n\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\traidz_row_t *rr = rm->rm_row[i];\n\n\t\t\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\t\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\t\t\tif (rc->rc_need_orig_restore) {\n\t\t\t\t\t \n\t\t\t\t\tif (rc->rc_error == 0 &&\n\t\t\t\t\t    c >= rr->rr_firstdatacol) {\n\t\t\t\t\t\tvdev_raidz_checksum_error(zio,\n\t\t\t\t\t\t    rc, rc->rc_orig_data);\n\t\t\t\t\t\trc->rc_error =\n\t\t\t\t\t\t    SET_ERROR(ECKSUM);\n\t\t\t\t\t}\n\t\t\t\t\trc->rc_need_orig_restore = B_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvdev_raidz_io_done_verified(zio, rr);\n\t\t}\n\n\t\tzio_checksum_verified(zio);\n\n\t\treturn (0);\n\t}\n\n\t \n\traidz_restore_orig_data(rm);\n\treturn (ECKSUM);\n}\n\n \nstatic int\nvdev_raidz_combrec(zio_t *zio)\n{\n\tint nparity = vdev_get_nparity(zio->io_vd);\n\traidz_map_t *rm = zio->io_vsd;\n\n\t \n\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\traidz_row_t *rr = rm->rm_row[i];\n\t\tint total_errors = 0;\n\n\t\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\t\tif (rr->rr_col[c].rc_error)\n\t\t\t\ttotal_errors++;\n\t\t}\n\n\t\tif (total_errors > nparity)\n\t\t\treturn (vdev_raidz_worst_error(rr));\n\t}\n\n\tfor (int num_failures = 1; num_failures <= nparity; num_failures++) {\n\t\tint tstore[VDEV_RAIDZ_MAXPARITY + 2];\n\t\tint *ltgts = &tstore[1];  \n\n\t\t \n\t\tint n = zio->io_vd->vdev_children;\n\n\t\tASSERT3U(num_failures, <=, nparity);\n\t\tASSERT3U(num_failures, <=, VDEV_RAIDZ_MAXPARITY);\n\n\t\t \n\t\tltgts[-1] = -1;\n\t\tfor (int i = 0; i < num_failures; i++) {\n\t\t\tltgts[i] = i;\n\t\t}\n\t\tltgts[num_failures] = n;\n\n\t\tfor (;;) {\n\t\t\tint err = raidz_reconstruct(zio, ltgts, num_failures,\n\t\t\t    nparity);\n\t\t\tif (err == EINVAL) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else if (err == 0)\n\t\t\t\treturn (0);\n\n\t\t\t \n\t\t\tfor (int t = 0; ; t++) {\n\t\t\t\tASSERT3U(t, <, num_failures);\n\t\t\t\tltgts[t]++;\n\t\t\t\tif (ltgts[t] == n) {\n\t\t\t\t\t \n\t\t\t\t\tASSERT3U(t, ==, num_failures - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tASSERT3U(ltgts[t], <, n);\n\t\t\t\tASSERT3U(ltgts[t], <=, ltgts[t + 1]);\n\n\t\t\t\t \n\t\t\t\tif (ltgts[t] != ltgts[t + 1])\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tltgts[t] = ltgts[t - 1] + 1;\n\t\t\t\tASSERT3U(ltgts[t], ==, t);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ltgts[num_failures - 1] == n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (ECKSUM);\n}\n\nvoid\nvdev_raidz_reconstruct(raidz_map_t *rm, const int *t, int nt)\n{\n\tfor (uint64_t row = 0; row < rm->rm_nrows; row++) {\n\t\traidz_row_t *rr = rm->rm_row[row];\n\t\tvdev_raidz_reconstruct_row(rm, rr, t, nt);\n\t}\n}\n\n \nstatic void\nvdev_raidz_io_done_write_impl(zio_t *zio, raidz_row_t *rr)\n{\n\tint total_errors = 0;\n\n\tASSERT3U(rr->rr_missingparity, <=, rr->rr_firstdatacol);\n\tASSERT3U(rr->rr_missingdata, <=, rr->rr_cols - rr->rr_firstdatacol);\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_WRITE);\n\n\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_error) {\n\t\t\tASSERT(rc->rc_error != ECKSUM);\t \n\n\t\t\ttotal_errors++;\n\t\t}\n\t}\n\n\t \n\tif (total_errors > rr->rr_firstdatacol) {\n\t\tzio->io_error = zio_worst_error(zio->io_error,\n\t\t    vdev_raidz_worst_error(rr));\n\t}\n}\n\nstatic void\nvdev_raidz_io_done_reconstruct_known_missing(zio_t *zio, raidz_map_t *rm,\n    raidz_row_t *rr)\n{\n\tint parity_errors = 0;\n\tint parity_untried = 0;\n\tint data_errors = 0;\n\tint total_errors = 0;\n\n\tASSERT3U(rr->rr_missingparity, <=, rr->rr_firstdatacol);\n\tASSERT3U(rr->rr_missingdata, <=, rr->rr_cols - rr->rr_firstdatacol);\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\n\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\t \n\t\tif (rc->rc_error == ECKSUM) {\n\t\t\tASSERT(zio->io_flags & ZIO_FLAG_SCRUB);\n\t\t\tvdev_raidz_checksum_error(zio, rc, rc->rc_abd);\n\t\t\trc->rc_force_repair = 1;\n\t\t\trc->rc_error = 0;\n\t\t}\n\n\t\tif (rc->rc_error) {\n\t\t\tif (c < rr->rr_firstdatacol)\n\t\t\t\tparity_errors++;\n\t\t\telse\n\t\t\t\tdata_errors++;\n\n\t\t\ttotal_errors++;\n\t\t} else if (c < rr->rr_firstdatacol && !rc->rc_tried) {\n\t\t\tparity_untried++;\n\t\t}\n\t}\n\n\t \n\tif (data_errors != 0 &&\n\t    total_errors <= rr->rr_firstdatacol - parity_untried) {\n\t\t \n\t\tASSERT(parity_untried == 0);\n\t\tASSERT(parity_errors < rr->rr_firstdatacol);\n\n\t\t \n\t\tint n = 0;\n\t\tint tgts[VDEV_RAIDZ_MAXPARITY];\n\t\tfor (int c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\t\tif (rc->rc_error != 0) {\n\t\t\t\tASSERT(n < VDEV_RAIDZ_MAXPARITY);\n\t\t\t\ttgts[n++] = c;\n\t\t\t}\n\t\t}\n\n\t\tASSERT(rr->rr_firstdatacol >= n);\n\n\t\tvdev_raidz_reconstruct_row(rm, rr, tgts, n);\n\t}\n}\n\n \nstatic int\nvdev_raidz_read_all(zio_t *zio, raidz_row_t *rr)\n{\n\tvdev_t *vd = zio->io_vd;\n\tint nread = 0;\n\n\trr->rr_missingdata = 0;\n\trr->rr_missingparity = 0;\n\n\t \n\tif (rr->rr_nempty && rr->rr_abd_empty == NULL)\n\t\tvdev_draid_map_alloc_empty(zio, rr);\n\n\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tif (rc->rc_tried || rc->rc_size == 0)\n\t\t\tcontinue;\n\n\t\tzio_nowait(zio_vdev_child_io(zio, NULL,\n\t\t    vd->vdev_child[rc->rc_devidx],\n\t\t    rc->rc_offset, rc->rc_abd, rc->rc_size,\n\t\t    zio->io_type, zio->io_priority, 0,\n\t\t    vdev_raidz_child_done, rc));\n\t\tnread++;\n\t}\n\treturn (nread);\n}\n\n \nstatic void\nvdev_raidz_io_done_unrecoverable(zio_t *zio)\n{\n\traidz_map_t *rm = zio->io_vsd;\n\n\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\traidz_row_t *rr = rm->rm_row[i];\n\n\t\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\t\tvdev_t *cvd = zio->io_vd->vdev_child[rc->rc_devidx];\n\n\t\t\tif (rc->rc_error != 0)\n\t\t\t\tcontinue;\n\n\t\t\tzio_bad_cksum_t zbc;\n\t\t\tzbc.zbc_has_cksum = 0;\n\t\t\tzbc.zbc_injected = rm->rm_ecksuminjected;\n\n\t\t\tmutex_enter(&cvd->vdev_stat_lock);\n\t\t\tcvd->vdev_stat.vs_checksum_errors++;\n\t\t\tmutex_exit(&cvd->vdev_stat_lock);\n\t\t\t(void) zfs_ereport_start_checksum(zio->io_spa,\n\t\t\t    cvd, &zio->io_bookmark, zio, rc->rc_offset,\n\t\t\t    rc->rc_size, &zbc);\n\t\t}\n\t}\n}\n\nvoid\nvdev_raidz_io_done(zio_t *zio)\n{\n\traidz_map_t *rm = zio->io_vsd;\n\n\tif (zio->io_type == ZIO_TYPE_WRITE) {\n\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\tvdev_raidz_io_done_write_impl(zio, rm->rm_row[i]);\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\traidz_row_t *rr = rm->rm_row[i];\n\t\t\tvdev_raidz_io_done_reconstruct_known_missing(zio,\n\t\t\t    rm, rr);\n\t\t}\n\n\t\tif (raidz_checksum_verify(zio) == 0) {\n\t\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\t\traidz_row_t *rr = rm->rm_row[i];\n\t\t\t\tvdev_raidz_io_done_verified(zio, rr);\n\t\t\t}\n\t\t\tzio_checksum_verified(zio);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3U(zio->io_priority, !=, ZIO_PRIORITY_REBUILD);\n\n\t\t\t \n\t\t\tint nread = 0;\n\t\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\t\tnread += vdev_raidz_read_all(zio,\n\t\t\t\t    rm->rm_row[i]);\n\t\t\t}\n\t\t\tif (nread != 0) {\n\t\t\t\t \n\t\t\t\tif (zio->io_stage != ZIO_STAGE_VDEV_IO_START)\n\t\t\t\t\tzio_vdev_io_redone(zio);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tzio->io_error = vdev_raidz_combrec(zio);\n\t\t\tif (zio->io_error == ECKSUM &&\n\t\t\t    !(zio->io_flags & ZIO_FLAG_SPECULATIVE)) {\n\t\t\t\tvdev_raidz_io_done_unrecoverable(zio);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nvdev_raidz_state_change(vdev_t *vd, int faulted, int degraded)\n{\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\tif (faulted > vdrz->vd_nparity)\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_NO_REPLICAS);\n\telse if (degraded + faulted != 0)\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_DEGRADED, VDEV_AUX_NONE);\n\telse\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_HEALTHY, VDEV_AUX_NONE);\n}\n\n \nstatic boolean_t\nvdev_raidz_need_resilver(vdev_t *vd, const dva_t *dva, size_t psize,\n    uint64_t phys_birth)\n{\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\tuint64_t dcols = vd->vdev_children;\n\tuint64_t nparity = vdrz->vd_nparity;\n\tuint64_t ashift = vd->vdev_top->vdev_ashift;\n\t \n\tuint64_t b = DVA_GET_OFFSET(dva) >> ashift;\n\t \n\tuint64_t s = ((psize - 1) >> ashift) + 1;\n\t \n\tuint64_t f = b % dcols;\n\n\t \n\tASSERT3U(phys_birth, !=, TXG_UNKNOWN);\n\n\tif (!vdev_dtl_contains(vd, DTL_PARTIAL, phys_birth, 1))\n\t\treturn (B_FALSE);\n\n\tif (s + nparity >= dcols)\n\t\treturn (B_TRUE);\n\n\tfor (uint64_t c = 0; c < s + nparity; c++) {\n\t\tuint64_t devidx = (f + c) % dcols;\n\t\tvdev_t *cvd = vd->vdev_child[devidx];\n\n\t\t \n\t\tif (!vdev_dtl_empty(cvd, DTL_PARTIAL))\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic void\nvdev_raidz_xlate(vdev_t *cvd, const range_seg64_t *logical_rs,\n    range_seg64_t *physical_rs, range_seg64_t *remain_rs)\n{\n\t(void) remain_rs;\n\n\tvdev_t *raidvd = cvd->vdev_parent;\n\tASSERT(raidvd->vdev_ops == &vdev_raidz_ops);\n\n\tuint64_t width = raidvd->vdev_children;\n\tuint64_t tgt_col = cvd->vdev_id;\n\tuint64_t ashift = raidvd->vdev_top->vdev_ashift;\n\n\t \n\tASSERT0(logical_rs->rs_start % (1 << ashift));\n\tASSERT0(logical_rs->rs_end % (1 << ashift));\n\tuint64_t b_start = logical_rs->rs_start >> ashift;\n\tuint64_t b_end = logical_rs->rs_end >> ashift;\n\n\tuint64_t start_row = 0;\n\tif (b_start > tgt_col)  \n\t\tstart_row = ((b_start - tgt_col - 1) / width) + 1;\n\n\tuint64_t end_row = 0;\n\tif (b_end > tgt_col)\n\t\tend_row = ((b_end - tgt_col - 1) / width) + 1;\n\n\tphysical_rs->rs_start = start_row << ashift;\n\tphysical_rs->rs_end = end_row << ashift;\n\n\tASSERT3U(physical_rs->rs_start, <=, logical_rs->rs_start);\n\tASSERT3U(physical_rs->rs_end - physical_rs->rs_start, <=,\n\t    logical_rs->rs_end - logical_rs->rs_start);\n}\n\n \nstatic int\nvdev_raidz_init(spa_t *spa, nvlist_t *nv, void **tsd)\n{\n\tvdev_raidz_t *vdrz;\n\tuint64_t nparity;\n\n\tuint_t children;\n\tnvlist_t **child;\n\tint error = nvlist_lookup_nvlist_array(nv,\n\t    ZPOOL_CONFIG_CHILDREN, &child, &children);\n\tif (error != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NPARITY, &nparity) == 0) {\n\t\tif (nparity == 0 || nparity > VDEV_RAIDZ_MAXPARITY)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tif (nparity > 1 && spa_version(spa) < SPA_VERSION_RAIDZ2)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\telse if (nparity > 2 && spa_version(spa) < SPA_VERSION_RAIDZ3)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t} else {\n\t\t \n\t\tif (spa_version(spa) >= SPA_VERSION_RAIDZ2)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\t \n\t\tnparity = 1;\n\t}\n\n\tvdrz = kmem_zalloc(sizeof (*vdrz), KM_SLEEP);\n\tvdrz->vd_logical_width = children;\n\tvdrz->vd_nparity = nparity;\n\n\t*tsd = vdrz;\n\n\treturn (0);\n}\n\nstatic void\nvdev_raidz_fini(vdev_t *vd)\n{\n\tkmem_free(vd->vdev_tsd, sizeof (vdev_raidz_t));\n}\n\n \nstatic void\nvdev_raidz_config_generate(vdev_t *vd, nvlist_t *nv)\n{\n\tASSERT3P(vd->vdev_ops, ==, &vdev_raidz_ops);\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\n\t \n\tASSERT(vdrz->vd_nparity == 1 ||\n\t    (vdrz->vd_nparity <= 2 &&\n\t    spa_version(vd->vdev_spa) >= SPA_VERSION_RAIDZ2) ||\n\t    (vdrz->vd_nparity <= 3 &&\n\t    spa_version(vd->vdev_spa) >= SPA_VERSION_RAIDZ3));\n\n\t \n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_NPARITY, vdrz->vd_nparity);\n}\n\nstatic uint64_t\nvdev_raidz_nparity(vdev_t *vd)\n{\n\tvdev_raidz_t *vdrz = vd->vdev_tsd;\n\treturn (vdrz->vd_nparity);\n}\n\nstatic uint64_t\nvdev_raidz_ndisks(vdev_t *vd)\n{\n\treturn (vd->vdev_children);\n}\n\nvdev_ops_t vdev_raidz_ops = {\n\t.vdev_op_init = vdev_raidz_init,\n\t.vdev_op_fini = vdev_raidz_fini,\n\t.vdev_op_open = vdev_raidz_open,\n\t.vdev_op_close = vdev_raidz_close,\n\t.vdev_op_asize = vdev_raidz_asize,\n\t.vdev_op_min_asize = vdev_raidz_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = vdev_raidz_io_start,\n\t.vdev_op_io_done = vdev_raidz_io_done,\n\t.vdev_op_state_change = vdev_raidz_state_change,\n\t.vdev_op_need_resilver = vdev_raidz_need_resilver,\n\t.vdev_op_hold = NULL,\n\t.vdev_op_rele = NULL,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = vdev_raidz_xlate,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = vdev_raidz_config_generate,\n\t.vdev_op_nparity = vdev_raidz_nparity,\n\t.vdev_op_ndisks = vdev_raidz_ndisks,\n\t.vdev_op_type = VDEV_TYPE_RAIDZ,\t \n\t.vdev_op_leaf = B_FALSE\t\t\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}