{
  "module_name": "dmu.c",
  "hash_id": "a52b0a4d4c26f7c60b71516489e0e679616bf2a1a7c2d6a595e2d711501e14ad",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu.c",
  "human_readable_source": " \n \n\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_prop.h>\n#include <sys/dmu_zfetch.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n#include <sys/zio_checksum.h>\n#include <sys/zio_compress.h>\n#include <sys/sa.h>\n#include <sys/zfeature.h>\n#include <sys/abd.h>\n#include <sys/brt.h>\n#include <sys/trace_zfs.h>\n#include <sys/zfs_racct.h>\n#include <sys/zfs_rlock.h>\n#ifdef _KERNEL\n#include <sys/vmsystm.h>\n#include <sys/zfs_znode.h>\n#endif\n\n \nstatic int zfs_nopwrite_enabled = 1;\n\n \nstatic uint_t zfs_per_txg_dirty_frees_percent = 30;\n\n \nstatic int zfs_dmu_offset_next_sync = 1;\n\n \n#ifdef _ILP32\nuint_t dmu_prefetch_max = 8 * 1024 * 1024;\n#else\nuint_t dmu_prefetch_max = 8 * SPA_MAXBLOCKSIZE;\n#endif\n\nconst dmu_object_type_info_t dmu_ot[DMU_OT_NUMTYPES] = {\n\t{DMU_BSWAP_UINT8,  TRUE,  FALSE, FALSE, \"unallocated\"\t\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"object directory\"\t},\n\t{DMU_BSWAP_UINT64, TRUE,  TRUE,  FALSE, \"object array\"\t\t},\n\t{DMU_BSWAP_UINT8,  TRUE,  FALSE, FALSE, \"packed nvlist\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"packed nvlist size\"\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"bpobj\"\t\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"bpobj header\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"SPA space map header\"\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"SPA space map\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, TRUE,  \"ZIL intent log\"\t},\n\t{DMU_BSWAP_DNODE,  TRUE,  FALSE, TRUE,  \"DMU dnode\"\t\t},\n\t{DMU_BSWAP_OBJSET, TRUE,  TRUE,  FALSE, \"DMU objset\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  TRUE,  FALSE, \"DSL directory\"\t\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL directory child map\"},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL dataset snap map\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL props\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  TRUE,  FALSE, \"DSL dataset\"\t\t},\n\t{DMU_BSWAP_ZNODE,  TRUE,  FALSE, FALSE, \"ZFS znode\"\t\t},\n\t{DMU_BSWAP_OLDACL, TRUE,  FALSE, TRUE,  \"ZFS V0 ACL\"\t\t},\n\t{DMU_BSWAP_UINT8,  FALSE, FALSE, TRUE,  \"ZFS plain file\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,  \"ZFS directory\"\t\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"ZFS master node\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,  \"ZFS delete queue\"\t},\n\t{DMU_BSWAP_UINT8,  FALSE, FALSE, TRUE,  \"zvol object\"\t\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"zvol prop\"\t\t},\n\t{DMU_BSWAP_UINT8,  FALSE, FALSE, TRUE,  \"other uint8[]\"\t\t},\n\t{DMU_BSWAP_UINT64, FALSE, FALSE, TRUE,  \"other uint64[]\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"other ZAP\"\t\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"persistent error log\"\t},\n\t{DMU_BSWAP_UINT8,  TRUE,  FALSE, FALSE, \"SPA history\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"SPA history offsets\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"Pool properties\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL permissions\"\t},\n\t{DMU_BSWAP_ACL,    TRUE,  FALSE, TRUE,  \"ZFS ACL\"\t\t},\n\t{DMU_BSWAP_UINT8,  TRUE,  FALSE, TRUE,  \"ZFS SYSACL\"\t\t},\n\t{DMU_BSWAP_UINT8,  TRUE,  FALSE, TRUE,  \"FUID table\"\t\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"FUID table size\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL dataset next clones\"},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"scan work queue\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,  \"ZFS user/group/project used\" },\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,  \"ZFS user/group/project quota\"},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"snapshot refcount tags\"},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"DDT ZAP algorithm\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"DDT statistics\"\t},\n\t{DMU_BSWAP_UINT8,  TRUE,  FALSE, TRUE,\t\"System attributes\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,\t\"SA master node\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,\t\"SA attr registration\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, TRUE,\t\"SA attr layouts\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  FALSE, FALSE, \"scan translations\"\t},\n\t{DMU_BSWAP_UINT8,  FALSE, FALSE, TRUE,  \"deduplicated block\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL deadlist map\"\t},\n\t{DMU_BSWAP_UINT64, TRUE,  TRUE,  FALSE, \"DSL deadlist map hdr\"\t},\n\t{DMU_BSWAP_ZAP,    TRUE,  TRUE,  FALSE, \"DSL dir clones\"\t},\n\t{DMU_BSWAP_UINT64, TRUE,  FALSE, FALSE, \"bpobj subobj\"\t\t}\n};\n\ndmu_object_byteswap_info_t dmu_ot_byteswap[DMU_BSWAP_NUMFUNCS] = {\n\t{\tbyteswap_uint8_array,\t\"uint8\"\t\t},\n\t{\tbyteswap_uint16_array,\t\"uint16\"\t},\n\t{\tbyteswap_uint32_array,\t\"uint32\"\t},\n\t{\tbyteswap_uint64_array,\t\"uint64\"\t},\n\t{\tzap_byteswap,\t\t\"zap\"\t\t},\n\t{\tdnode_buf_byteswap,\t\"dnode\"\t\t},\n\t{\tdmu_objset_byteswap,\t\"objset\"\t},\n\t{\tzfs_znode_byteswap,\t\"znode\"\t\t},\n\t{\tzfs_oldacl_byteswap,\t\"oldacl\"\t},\n\t{\tzfs_acl_byteswap,\t\"acl\"\t\t}\n};\n\nint\ndmu_buf_hold_noread_by_dnode(dnode_t *dn, uint64_t offset,\n    const void *tag, dmu_buf_t **dbp)\n{\n\tuint64_t blkid;\n\tdmu_buf_impl_t *db;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tblkid = dbuf_whichblock(dn, 0, offset);\n\tdb = dbuf_hold(dn, blkid, tag);\n\trw_exit(&dn->dn_struct_rwlock);\n\n\tif (db == NULL) {\n\t\t*dbp = NULL;\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t*dbp = &db->db;\n\treturn (0);\n}\n\nint\ndmu_buf_hold_noread(objset_t *os, uint64_t object, uint64_t offset,\n    const void *tag, dmu_buf_t **dbp)\n{\n\tdnode_t *dn;\n\tuint64_t blkid;\n\tdmu_buf_impl_t *db;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tblkid = dbuf_whichblock(dn, 0, offset);\n\tdb = dbuf_hold(dn, blkid, tag);\n\trw_exit(&dn->dn_struct_rwlock);\n\tdnode_rele(dn, FTAG);\n\n\tif (db == NULL) {\n\t\t*dbp = NULL;\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t*dbp = &db->db;\n\treturn (err);\n}\n\nint\ndmu_buf_hold_by_dnode(dnode_t *dn, uint64_t offset,\n    const void *tag, dmu_buf_t **dbp, int flags)\n{\n\tint err;\n\tint db_flags = DB_RF_CANFAIL;\n\n\tif (flags & DMU_READ_NO_PREFETCH)\n\t\tdb_flags |= DB_RF_NOPREFETCH;\n\tif (flags & DMU_READ_NO_DECRYPT)\n\t\tdb_flags |= DB_RF_NO_DECRYPT;\n\n\terr = dmu_buf_hold_noread_by_dnode(dn, offset, tag, dbp);\n\tif (err == 0) {\n\t\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)(*dbp);\n\t\terr = dbuf_read(db, NULL, db_flags);\n\t\tif (err != 0) {\n\t\t\tdbuf_rele(db, tag);\n\t\t\t*dbp = NULL;\n\t\t}\n\t}\n\n\treturn (err);\n}\n\nint\ndmu_buf_hold(objset_t *os, uint64_t object, uint64_t offset,\n    const void *tag, dmu_buf_t **dbp, int flags)\n{\n\tint err;\n\tint db_flags = DB_RF_CANFAIL;\n\n\tif (flags & DMU_READ_NO_PREFETCH)\n\t\tdb_flags |= DB_RF_NOPREFETCH;\n\tif (flags & DMU_READ_NO_DECRYPT)\n\t\tdb_flags |= DB_RF_NO_DECRYPT;\n\n\terr = dmu_buf_hold_noread(os, object, offset, tag, dbp);\n\tif (err == 0) {\n\t\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)(*dbp);\n\t\terr = dbuf_read(db, NULL, db_flags);\n\t\tif (err != 0) {\n\t\t\tdbuf_rele(db, tag);\n\t\t\t*dbp = NULL;\n\t\t}\n\t}\n\n\treturn (err);\n}\n\nint\ndmu_bonus_max(void)\n{\n\treturn (DN_OLD_MAX_BONUSLEN);\n}\n\nint\ndmu_set_bonus(dmu_buf_t *db_fake, int newsize, dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\tdnode_t *dn;\n\tint error;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\n\tif (dn->dn_bonus != db) {\n\t\terror = SET_ERROR(EINVAL);\n\t} else if (newsize < 0 || newsize > db_fake->db_size) {\n\t\terror = SET_ERROR(EINVAL);\n\t} else {\n\t\tdnode_setbonuslen(dn, newsize, tx);\n\t\terror = 0;\n\t}\n\n\tDB_DNODE_EXIT(db);\n\treturn (error);\n}\n\nint\ndmu_set_bonustype(dmu_buf_t *db_fake, dmu_object_type_t type, dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\tdnode_t *dn;\n\tint error;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\n\tif (!DMU_OT_IS_VALID(type)) {\n\t\terror = SET_ERROR(EINVAL);\n\t} else if (dn->dn_bonus != db) {\n\t\terror = SET_ERROR(EINVAL);\n\t} else {\n\t\tdnode_setbonus_type(dn, type, tx);\n\t\terror = 0;\n\t}\n\n\tDB_DNODE_EXIT(db);\n\treturn (error);\n}\n\ndmu_object_type_t\ndmu_get_bonustype(dmu_buf_t *db_fake)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\tdnode_t *dn;\n\tdmu_object_type_t type;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\ttype = dn->dn_bonustype;\n\tDB_DNODE_EXIT(db);\n\n\treturn (type);\n}\n\nint\ndmu_rm_spill(objset_t *os, uint64_t object, dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint error;\n\n\terror = dnode_hold(os, object, FTAG, &dn);\n\tdbuf_rm_spill(dn, tx);\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\tdnode_rm_spill(dn, tx);\n\trw_exit(&dn->dn_struct_rwlock);\n\tdnode_rele(dn, FTAG);\n\treturn (error);\n}\n\n \nint dmu_bonus_hold_by_dnode(dnode_t *dn, const void *tag, dmu_buf_t **dbp,\n    uint32_t flags)\n{\n\tdmu_buf_impl_t *db;\n\tint error;\n\tuint32_t db_flags = DB_RF_MUST_SUCCEED;\n\n\tif (flags & DMU_READ_NO_PREFETCH)\n\t\tdb_flags |= DB_RF_NOPREFETCH;\n\tif (flags & DMU_READ_NO_DECRYPT)\n\t\tdb_flags |= DB_RF_NO_DECRYPT;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tif (dn->dn_bonus == NULL) {\n\t\tif (!rw_tryupgrade(&dn->dn_struct_rwlock)) {\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\t\t}\n\t\tif (dn->dn_bonus == NULL)\n\t\t\tdbuf_create_bonus(dn);\n\t}\n\tdb = dn->dn_bonus;\n\n\t \n\tif (zfs_refcount_add(&db->db_holds, tag) == 1) {\n\t\tVERIFY(dnode_add_ref(dn, db));\n\t\tatomic_inc_32(&dn->dn_dbufs_count);\n\t}\n\n\t \n\trw_exit(&dn->dn_struct_rwlock);\n\n\terror = dbuf_read(db, NULL, db_flags);\n\tif (error) {\n\t\tdnode_evict_bonus(dn);\n\t\tdbuf_rele(db, tag);\n\t\t*dbp = NULL;\n\t\treturn (error);\n\t}\n\n\t*dbp = &db->db;\n\treturn (0);\n}\n\nint\ndmu_bonus_hold(objset_t *os, uint64_t object, const void *tag, dmu_buf_t **dbp)\n{\n\tdnode_t *dn;\n\tint error;\n\n\terror = dnode_hold(os, object, FTAG, &dn);\n\tif (error)\n\t\treturn (error);\n\n\terror = dmu_bonus_hold_by_dnode(dn, tag, dbp, DMU_READ_NO_PREFETCH);\n\tdnode_rele(dn, FTAG);\n\n\treturn (error);\n}\n\n \nint\ndmu_spill_hold_by_dnode(dnode_t *dn, uint32_t flags, const void *tag,\n    dmu_buf_t **dbp)\n{\n\tdmu_buf_impl_t *db = NULL;\n\tint err;\n\n\tif ((flags & DB_RF_HAVESTRUCT) == 0)\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\n\tdb = dbuf_hold(dn, DMU_SPILL_BLKID, tag);\n\n\tif ((flags & DB_RF_HAVESTRUCT) == 0)\n\t\trw_exit(&dn->dn_struct_rwlock);\n\n\tif (db == NULL) {\n\t\t*dbp = NULL;\n\t\treturn (SET_ERROR(EIO));\n\t}\n\terr = dbuf_read(db, NULL, flags);\n\tif (err == 0)\n\t\t*dbp = &db->db;\n\telse {\n\t\tdbuf_rele(db, tag);\n\t\t*dbp = NULL;\n\t}\n\treturn (err);\n}\n\nint\ndmu_spill_hold_existing(dmu_buf_t *bonus, const void *tag, dmu_buf_t **dbp)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)bonus;\n\tdnode_t *dn;\n\tint err;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\n\tif (spa_version(dn->dn_objset->os_spa) < SPA_VERSION_SA) {\n\t\terr = SET_ERROR(EINVAL);\n\t} else {\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\n\t\tif (!dn->dn_have_spill) {\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t} else {\n\t\t\terr = dmu_spill_hold_by_dnode(dn,\n\t\t\t    DB_RF_HAVESTRUCT | DB_RF_CANFAIL, tag, dbp);\n\t\t}\n\n\t\trw_exit(&dn->dn_struct_rwlock);\n\t}\n\n\tDB_DNODE_EXIT(db);\n\treturn (err);\n}\n\nint\ndmu_spill_hold_by_bonus(dmu_buf_t *bonus, uint32_t flags, const void *tag,\n    dmu_buf_t **dbp)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)bonus;\n\tdnode_t *dn;\n\tint err;\n\tuint32_t db_flags = DB_RF_CANFAIL;\n\n\tif (flags & DMU_READ_NO_DECRYPT)\n\t\tdb_flags |= DB_RF_NO_DECRYPT;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\terr = dmu_spill_hold_by_dnode(dn, db_flags, tag, dbp);\n\tDB_DNODE_EXIT(db);\n\n\treturn (err);\n}\n\n \nint\ndmu_buf_hold_array_by_dnode(dnode_t *dn, uint64_t offset, uint64_t length,\n    boolean_t read, const void *tag, int *numbufsp, dmu_buf_t ***dbpp,\n    uint32_t flags)\n{\n\tdmu_buf_t **dbp;\n\tzstream_t *zs = NULL;\n\tuint64_t blkid, nblks, i;\n\tuint32_t dbuf_flags;\n\tint err;\n\tzio_t *zio = NULL;\n\tboolean_t missed = B_FALSE;\n\n\tASSERT(!read || length <= DMU_MAX_ACCESS);\n\n\t \n\tdbuf_flags = DB_RF_CANFAIL | DB_RF_NEVERWAIT | DB_RF_HAVESTRUCT |\n\t    DB_RF_NOPREFETCH;\n\n\tif ((flags & DMU_READ_NO_DECRYPT) != 0)\n\t\tdbuf_flags |= DB_RF_NO_DECRYPT;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tif (dn->dn_datablkshift) {\n\t\tint blkshift = dn->dn_datablkshift;\n\t\tnblks = (P2ROUNDUP(offset + length, 1ULL << blkshift) -\n\t\t    P2ALIGN(offset, 1ULL << blkshift)) >> blkshift;\n\t} else {\n\t\tif (offset + length > dn->dn_datablksz) {\n\t\t\tzfs_panic_recover(\"zfs: accessing past end of object \"\n\t\t\t    \"%llx/%llx (size=%u access=%llu+%llu)\",\n\t\t\t    (longlong_t)dn->dn_objset->\n\t\t\t    os_dsl_dataset->ds_object,\n\t\t\t    (longlong_t)dn->dn_object, dn->dn_datablksz,\n\t\t\t    (longlong_t)offset, (longlong_t)length);\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\treturn (SET_ERROR(EIO));\n\t\t}\n\t\tnblks = 1;\n\t}\n\tdbp = kmem_zalloc(sizeof (dmu_buf_t *) * nblks, KM_SLEEP);\n\n\tif (read)\n\t\tzio = zio_root(dn->dn_objset->os_spa, NULL, NULL,\n\t\t    ZIO_FLAG_CANFAIL);\n\tblkid = dbuf_whichblock(dn, 0, offset);\n\tif ((flags & DMU_READ_NO_PREFETCH) == 0) {\n\t\t \n\t\tzs = dmu_zfetch_prepare(&dn->dn_zfetch, blkid, nblks, read,\n\t\t    B_TRUE);\n\t}\n\tfor (i = 0; i < nblks; i++) {\n\t\tdmu_buf_impl_t *db = dbuf_hold(dn, blkid + i, tag);\n\t\tif (db == NULL) {\n\t\t\tif (zs)\n\t\t\t\tdmu_zfetch_run(zs, missed, B_TRUE);\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\tdmu_buf_rele_array(dbp, nblks, tag);\n\t\t\tif (read)\n\t\t\t\tzio_nowait(zio);\n\t\t\treturn (SET_ERROR(EIO));\n\t\t}\n\n\t\t \n\t\tif (read) {\n\t\t\tif (i == nblks - 1 && blkid + i < dn->dn_maxblkid &&\n\t\t\t    offset + length < db->db.db_offset +\n\t\t\t    db->db.db_size) {\n\t\t\t\tif (offset <= db->db.db_offset)\n\t\t\t\t\tdbuf_flags |= DB_RF_PARTIAL_FIRST;\n\t\t\t\telse\n\t\t\t\t\tdbuf_flags |= DB_RF_PARTIAL_MORE;\n\t\t\t}\n\t\t\t(void) dbuf_read(db, zio, dbuf_flags);\n\t\t\tif (db->db_state != DB_CACHED)\n\t\t\t\tmissed = B_TRUE;\n\t\t}\n\t\tdbp[i] = &db->db;\n\t}\n\n\tif (!read)\n\t\tzfs_racct_write(length, nblks);\n\n\tif (zs)\n\t\tdmu_zfetch_run(zs, missed, B_TRUE);\n\trw_exit(&dn->dn_struct_rwlock);\n\n\tif (read) {\n\t\t \n\t\terr = zio_wait(zio);\n\t\tif (err) {\n\t\t\tdmu_buf_rele_array(dbp, nblks, tag);\n\t\t\treturn (err);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < nblks; i++) {\n\t\t\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)dbp[i];\n\t\t\tmutex_enter(&db->db_mtx);\n\t\t\twhile (db->db_state == DB_READ ||\n\t\t\t    db->db_state == DB_FILL)\n\t\t\t\tcv_wait(&db->db_changed, &db->db_mtx);\n\t\t\tif (db->db_state == DB_UNCACHED)\n\t\t\t\terr = SET_ERROR(EIO);\n\t\t\tmutex_exit(&db->db_mtx);\n\t\t\tif (err) {\n\t\t\t\tdmu_buf_rele_array(dbp, nblks, tag);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t}\n\t}\n\n\t*numbufsp = nblks;\n\t*dbpp = dbp;\n\treturn (0);\n}\n\nint\ndmu_buf_hold_array(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t length, int read, const void *tag, int *numbufsp,\n    dmu_buf_t ***dbpp)\n{\n\tdnode_t *dn;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\n\terr = dmu_buf_hold_array_by_dnode(dn, offset, length, read, tag,\n\t    numbufsp, dbpp, DMU_READ_PREFETCH);\n\n\tdnode_rele(dn, FTAG);\n\n\treturn (err);\n}\n\nint\ndmu_buf_hold_array_by_bonus(dmu_buf_t *db_fake, uint64_t offset,\n    uint64_t length, boolean_t read, const void *tag, int *numbufsp,\n    dmu_buf_t ***dbpp)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\tdnode_t *dn;\n\tint err;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\terr = dmu_buf_hold_array_by_dnode(dn, offset, length, read, tag,\n\t    numbufsp, dbpp, DMU_READ_PREFETCH);\n\tDB_DNODE_EXIT(db);\n\n\treturn (err);\n}\n\nvoid\ndmu_buf_rele_array(dmu_buf_t **dbp_fake, int numbufs, const void *tag)\n{\n\tint i;\n\tdmu_buf_impl_t **dbp = (dmu_buf_impl_t **)dbp_fake;\n\n\tif (numbufs == 0)\n\t\treturn;\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tif (dbp[i])\n\t\t\tdbuf_rele(dbp[i], tag);\n\t}\n\n\tkmem_free(dbp, sizeof (dmu_buf_t *) * numbufs);\n}\n\n \nvoid\ndmu_prefetch(objset_t *os, uint64_t object, int64_t level, uint64_t offset,\n    uint64_t len, zio_priority_t pri)\n{\n\tdnode_t *dn;\n\tuint64_t blkid;\n\tint nblks, err;\n\n\tif (len == 0) {   \n\t\tdn = DMU_META_DNODE(os);\n\n\t\tif (object == 0 || object >= DN_MAX_OBJECT)\n\t\t\treturn;\n\n\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\tblkid = dbuf_whichblock(dn, level,\n\t\t    object * sizeof (dnode_phys_t));\n\t\tdbuf_prefetch(dn, level, blkid, pri, 0);\n\t\trw_exit(&dn->dn_struct_rwlock);\n\t\treturn;\n\t}\n\n\t \n\tlen = MIN(len, dmu_prefetch_max);\n\n\t \n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err != 0)\n\t\treturn;\n\n\t \n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tif (level > 0 || dn->dn_datablkshift != 0) {\n\t\tnblks = dbuf_whichblock(dn, level, offset + len - 1) -\n\t\t    dbuf_whichblock(dn, level, offset) + 1;\n\t} else {\n\t\tnblks = (offset < dn->dn_datablksz);\n\t}\n\n\tif (nblks != 0) {\n\t\tblkid = dbuf_whichblock(dn, level, offset);\n\t\tfor (int i = 0; i < nblks; i++)\n\t\t\tdbuf_prefetch(dn, level, blkid + i, pri, 0);\n\t}\n\trw_exit(&dn->dn_struct_rwlock);\n\n\tdnode_rele(dn, FTAG);\n}\n\n \nstatic int\nget_next_chunk(dnode_t *dn, uint64_t *start, uint64_t minimum, uint64_t *l1blks)\n{\n\tuint64_t blks;\n\tuint64_t maxblks = DMU_MAX_ACCESS >> (dn->dn_indblkshift + 1);\n\t \n\tuint64_t iblkrange = (uint64_t)dn->dn_datablksz *\n\t    EPB(dn->dn_indblkshift, SPA_BLKPTRSHIFT);\n\n\tASSERT3U(minimum, <=, *start);\n\n\t \n\tuint64_t total_l1blks =\n\t    (roundup(*start, iblkrange) - (minimum / iblkrange * iblkrange)) /\n\t    iblkrange;\n\tif (total_l1blks <= maxblks) {\n\t\t*l1blks = total_l1blks;\n\t\t*start = minimum;\n\t\treturn (0);\n\t}\n\tASSERT(ISP2(iblkrange));\n\n\tfor (blks = 0; *start > minimum && blks < maxblks; blks++) {\n\t\tint err;\n\n\t\t \n\t\t(*start)--;\n\n\t\terr = dnode_next_offset(dn,\n\t\t    DNODE_FIND_BACKWARDS, start, 2, 1, 0);\n\n\t\t \n\t\tif (err == ESRCH) {\n\t\t\t*start = minimum;\n\t\t\tbreak;\n\t\t} else if (err != 0) {\n\t\t\t*l1blks = blks;\n\t\t\treturn (err);\n\t\t}\n\n\t\t \n\t\t*start = P2ALIGN(*start, iblkrange);\n\t}\n\tif (*start < minimum)\n\t\t*start = minimum;\n\t*l1blks = blks;\n\n\treturn (0);\n}\n\n \nstatic boolean_t\ndmu_objset_zfs_unmounting(objset_t *os)\n{\n#ifdef _KERNEL\n\tif (dmu_objset_type(os) == DMU_OST_ZFS)\n\t\treturn (zfs_get_vfs_flag_unmounted(os));\n#else\n\t(void) os;\n#endif\n\treturn (B_FALSE);\n}\n\nstatic int\ndmu_free_long_range_impl(objset_t *os, dnode_t *dn, uint64_t offset,\n    uint64_t length)\n{\n\tuint64_t object_size;\n\tint err;\n\tuint64_t dirty_frees_threshold;\n\tdsl_pool_t *dp = dmu_objset_pool(os);\n\n\tif (dn == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tobject_size = (dn->dn_maxblkid + 1) * dn->dn_datablksz;\n\tif (offset >= object_size)\n\t\treturn (0);\n\n\tif (zfs_per_txg_dirty_frees_percent <= 100)\n\t\tdirty_frees_threshold =\n\t\t    zfs_per_txg_dirty_frees_percent * zfs_dirty_data_max / 100;\n\telse\n\t\tdirty_frees_threshold = zfs_dirty_data_max / 20;\n\n\tif (length == DMU_OBJECT_END || offset + length > object_size)\n\t\tlength = object_size - offset;\n\n\twhile (length != 0) {\n\t\tuint64_t chunk_end, chunk_begin, chunk_len;\n\t\tuint64_t l1blks;\n\t\tdmu_tx_t *tx;\n\n\t\tif (dmu_objset_zfs_unmounting(dn->dn_objset))\n\t\t\treturn (SET_ERROR(EINTR));\n\n\t\tchunk_end = chunk_begin = offset + length;\n\n\t\t \n\t\terr = get_next_chunk(dn, &chunk_begin, offset, &l1blks);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tASSERT3U(chunk_begin, >=, offset);\n\t\tASSERT3U(chunk_begin, <=, chunk_end);\n\n\t\tchunk_len = chunk_end - chunk_begin;\n\n\t\ttx = dmu_tx_create(os);\n\t\tdmu_tx_hold_free(tx, dn->dn_object, chunk_begin, chunk_len);\n\n\t\t \n\t\tdmu_tx_mark_netfree(tx);\n\t\terr = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (err) {\n\t\t\tdmu_tx_abort(tx);\n\t\t\treturn (err);\n\t\t}\n\n\t\tuint64_t txg = dmu_tx_get_txg(tx);\n\n\t\tmutex_enter(&dp->dp_lock);\n\t\tuint64_t long_free_dirty =\n\t\t    dp->dp_long_free_dirty_pertxg[txg & TXG_MASK];\n\t\tmutex_exit(&dp->dp_lock);\n\n\t\t \n\t\tif (dirty_frees_threshold != 0 &&\n\t\t    long_free_dirty >= dirty_frees_threshold) {\n\t\t\tDMU_TX_STAT_BUMP(dmu_tx_dirty_frees_delay);\n\t\t\tdmu_tx_commit(tx);\n\t\t\ttxg_wait_open(dp, 0, B_TRUE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmutex_enter(&dp->dp_lock);\n\t\tdp->dp_long_free_dirty_pertxg[txg & TXG_MASK] +=\n\t\t    l1blks << dn->dn_indblkshift;\n\t\tmutex_exit(&dp->dp_lock);\n\t\tDTRACE_PROBE3(free__long__range,\n\t\t    uint64_t, long_free_dirty, uint64_t, chunk_len,\n\t\t    uint64_t, txg);\n\t\tdnode_free_range(dn, chunk_begin, chunk_len, tx);\n\n\t\tdmu_tx_commit(tx);\n\n\t\tlength -= chunk_len;\n\t}\n\treturn (0);\n}\n\nint\ndmu_free_long_range(objset_t *os, uint64_t object,\n    uint64_t offset, uint64_t length)\n{\n\tdnode_t *dn;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dmu_free_long_range_impl(os, dn, offset, length);\n\n\t \n\tif (err == 0 && offset == 0 && length == DMU_OBJECT_END)\n\t\tdn->dn_maxblkid = 0;\n\n\tdnode_rele(dn, FTAG);\n\treturn (err);\n}\n\nint\ndmu_free_long_object(objset_t *os, uint64_t object)\n{\n\tdmu_tx_t *tx;\n\tint err;\n\n\terr = dmu_free_long_range(os, object, 0, DMU_OBJECT_END);\n\tif (err != 0)\n\t\treturn (err);\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_bonus(tx, object);\n\tdmu_tx_hold_free(tx, object, 0, DMU_OBJECT_END);\n\tdmu_tx_mark_netfree(tx);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err == 0) {\n\t\terr = dmu_object_free(os, object, tx);\n\t\tdmu_tx_commit(tx);\n\t} else {\n\t\tdmu_tx_abort(tx);\n\t}\n\n\treturn (err);\n}\n\nint\ndmu_free_range(objset_t *os, uint64_t object, uint64_t offset,\n    uint64_t size, dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint err = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\tASSERT(offset < UINT64_MAX);\n\tASSERT(size == DMU_OBJECT_END || size <= UINT64_MAX - offset);\n\tdnode_free_range(dn, offset, size, tx);\n\tdnode_rele(dn, FTAG);\n\treturn (0);\n}\n\nstatic int\ndmu_read_impl(dnode_t *dn, uint64_t offset, uint64_t size,\n    void *buf, uint32_t flags)\n{\n\tdmu_buf_t **dbp;\n\tint numbufs, err = 0;\n\n\t \n\tif (dn->dn_maxblkid == 0) {\n\t\tuint64_t newsz = offset > dn->dn_datablksz ? 0 :\n\t\t    MIN(size, dn->dn_datablksz - offset);\n\t\tmemset((char *)buf + newsz, 0, size - newsz);\n\t\tsize = newsz;\n\t}\n\n\twhile (size > 0) {\n\t\tuint64_t mylen = MIN(size, DMU_MAX_ACCESS / 2);\n\t\tint i;\n\n\t\t \n\t\terr = dmu_buf_hold_array_by_dnode(dn, offset, mylen,\n\t\t    TRUE, FTAG, &numbufs, &dbp, flags);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < numbufs; i++) {\n\t\t\tuint64_t tocpy;\n\t\t\tint64_t bufoff;\n\t\t\tdmu_buf_t *db = dbp[i];\n\n\t\t\tASSERT(size > 0);\n\n\t\t\tbufoff = offset - db->db_offset;\n\t\t\ttocpy = MIN(db->db_size - bufoff, size);\n\n\t\t\t(void) memcpy(buf, (char *)db->db_data + bufoff, tocpy);\n\n\t\t\toffset += tocpy;\n\t\t\tsize -= tocpy;\n\t\t\tbuf = (char *)buf + tocpy;\n\t\t}\n\t\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\t}\n\treturn (err);\n}\n\nint\ndmu_read(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n    void *buf, uint32_t flags)\n{\n\tdnode_t *dn;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = dmu_read_impl(dn, offset, size, buf, flags);\n\tdnode_rele(dn, FTAG);\n\treturn (err);\n}\n\nint\ndmu_read_by_dnode(dnode_t *dn, uint64_t offset, uint64_t size, void *buf,\n    uint32_t flags)\n{\n\treturn (dmu_read_impl(dn, offset, size, buf, flags));\n}\n\nstatic void\ndmu_write_impl(dmu_buf_t **dbp, int numbufs, uint64_t offset, uint64_t size,\n    const void *buf, dmu_tx_t *tx)\n{\n\tint i;\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tuint64_t tocpy;\n\t\tint64_t bufoff;\n\t\tdmu_buf_t *db = dbp[i];\n\n\t\tASSERT(size > 0);\n\n\t\tbufoff = offset - db->db_offset;\n\t\ttocpy = MIN(db->db_size - bufoff, size);\n\n\t\tASSERT(i == 0 || i == numbufs-1 || tocpy == db->db_size);\n\n\t\tif (tocpy == db->db_size)\n\t\t\tdmu_buf_will_fill(db, tx);\n\t\telse\n\t\t\tdmu_buf_will_dirty(db, tx);\n\n\t\t(void) memcpy((char *)db->db_data + bufoff, buf, tocpy);\n\n\t\tif (tocpy == db->db_size)\n\t\t\tdmu_buf_fill_done(db, tx);\n\n\t\toffset += tocpy;\n\t\tsize -= tocpy;\n\t\tbuf = (char *)buf + tocpy;\n\t}\n}\n\nvoid\ndmu_write(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n    const void *buf, dmu_tx_t *tx)\n{\n\tdmu_buf_t **dbp;\n\tint numbufs;\n\n\tif (size == 0)\n\t\treturn;\n\n\tVERIFY0(dmu_buf_hold_array(os, object, offset, size,\n\t    FALSE, FTAG, &numbufs, &dbp));\n\tdmu_write_impl(dbp, numbufs, offset, size, buf, tx);\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n}\n\n \nvoid\ndmu_write_by_dnode(dnode_t *dn, uint64_t offset, uint64_t size,\n    const void *buf, dmu_tx_t *tx)\n{\n\tdmu_buf_t **dbp;\n\tint numbufs;\n\n\tif (size == 0)\n\t\treturn;\n\n\tVERIFY0(dmu_buf_hold_array_by_dnode(dn, offset, size,\n\t    FALSE, FTAG, &numbufs, &dbp, DMU_READ_PREFETCH));\n\tdmu_write_impl(dbp, numbufs, offset, size, buf, tx);\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n}\n\nvoid\ndmu_prealloc(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n    dmu_tx_t *tx)\n{\n\tdmu_buf_t **dbp;\n\tint numbufs, i;\n\n\tif (size == 0)\n\t\treturn;\n\n\tVERIFY(0 == dmu_buf_hold_array(os, object, offset, size,\n\t    FALSE, FTAG, &numbufs, &dbp));\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tdmu_buf_t *db = dbp[i];\n\n\t\tdmu_buf_will_not_fill(db, tx);\n\t}\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n}\n\nvoid\ndmu_write_embedded(objset_t *os, uint64_t object, uint64_t offset,\n    void *data, uint8_t etype, uint8_t comp, int uncompressed_size,\n    int compressed_size, int byteorder, dmu_tx_t *tx)\n{\n\tdmu_buf_t *db;\n\n\tASSERT3U(etype, <, NUM_BP_EMBEDDED_TYPES);\n\tASSERT3U(comp, <, ZIO_COMPRESS_FUNCTIONS);\n\tVERIFY0(dmu_buf_hold_noread(os, object, offset,\n\t    FTAG, &db));\n\n\tdmu_buf_write_embedded(db,\n\t    data, (bp_embedded_type_t)etype, (enum zio_compress)comp,\n\t    uncompressed_size, compressed_size, byteorder, tx);\n\n\tdmu_buf_rele(db, FTAG);\n}\n\nvoid\ndmu_redact(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n    dmu_tx_t *tx)\n{\n\tint numbufs, i;\n\tdmu_buf_t **dbp;\n\n\tVERIFY0(dmu_buf_hold_array(os, object, offset, size, FALSE, FTAG,\n\t    &numbufs, &dbp));\n\tfor (i = 0; i < numbufs; i++)\n\t\tdmu_buf_redact(dbp[i], tx);\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n}\n\n#ifdef _KERNEL\nint\ndmu_read_uio_dnode(dnode_t *dn, zfs_uio_t *uio, uint64_t size)\n{\n\tdmu_buf_t **dbp;\n\tint numbufs, i, err;\n\n\t \n\terr = dmu_buf_hold_array_by_dnode(dn, zfs_uio_offset(uio), size,\n\t    TRUE, FTAG, &numbufs, &dbp, 0);\n\tif (err)\n\t\treturn (err);\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tuint64_t tocpy;\n\t\tint64_t bufoff;\n\t\tdmu_buf_t *db = dbp[i];\n\n\t\tASSERT(size > 0);\n\n\t\tbufoff = zfs_uio_offset(uio) - db->db_offset;\n\t\ttocpy = MIN(db->db_size - bufoff, size);\n\n\t\terr = zfs_uio_fault_move((char *)db->db_data + bufoff, tocpy,\n\t\t    UIO_READ, uio);\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tsize -= tocpy;\n\t}\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\n\treturn (err);\n}\n\n \nint\ndmu_read_uio_dbuf(dmu_buf_t *zdb, zfs_uio_t *uio, uint64_t size)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)zdb;\n\tdnode_t *dn;\n\tint err;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\terr = dmu_read_uio_dnode(dn, uio, size);\n\tDB_DNODE_EXIT(db);\n\n\treturn (err);\n}\n\n \nint\ndmu_read_uio(objset_t *os, uint64_t object, zfs_uio_t *uio, uint64_t size)\n{\n\tdnode_t *dn;\n\tint err;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\n\terr = dmu_read_uio_dnode(dn, uio, size);\n\n\tdnode_rele(dn, FTAG);\n\n\treturn (err);\n}\n\nint\ndmu_write_uio_dnode(dnode_t *dn, zfs_uio_t *uio, uint64_t size, dmu_tx_t *tx)\n{\n\tdmu_buf_t **dbp;\n\tint numbufs;\n\tint err = 0;\n\tint i;\n\n\terr = dmu_buf_hold_array_by_dnode(dn, zfs_uio_offset(uio), size,\n\t    FALSE, FTAG, &numbufs, &dbp, DMU_READ_PREFETCH);\n\tif (err)\n\t\treturn (err);\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tuint64_t tocpy;\n\t\tint64_t bufoff;\n\t\tdmu_buf_t *db = dbp[i];\n\n\t\tASSERT(size > 0);\n\n\t\tbufoff = zfs_uio_offset(uio) - db->db_offset;\n\t\ttocpy = MIN(db->db_size - bufoff, size);\n\n\t\tASSERT(i == 0 || i == numbufs-1 || tocpy == db->db_size);\n\n\t\tif (tocpy == db->db_size)\n\t\t\tdmu_buf_will_fill(db, tx);\n\t\telse\n\t\t\tdmu_buf_will_dirty(db, tx);\n\n\t\t \n\t\terr = zfs_uio_fault_move((char *)db->db_data + bufoff,\n\t\t    tocpy, UIO_WRITE, uio);\n\n\t\tif (tocpy == db->db_size)\n\t\t\tdmu_buf_fill_done(db, tx);\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tsize -= tocpy;\n\t}\n\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\treturn (err);\n}\n\n \nint\ndmu_write_uio_dbuf(dmu_buf_t *zdb, zfs_uio_t *uio, uint64_t size,\n    dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)zdb;\n\tdnode_t *dn;\n\tint err;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\terr = dmu_write_uio_dnode(dn, uio, size, tx);\n\tDB_DNODE_EXIT(db);\n\n\treturn (err);\n}\n\n \nint\ndmu_write_uio(objset_t *os, uint64_t object, zfs_uio_t *uio, uint64_t size,\n    dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint err;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\n\terr = dmu_write_uio_dnode(dn, uio, size, tx);\n\n\tdnode_rele(dn, FTAG);\n\n\treturn (err);\n}\n#endif  \n\n \narc_buf_t *\ndmu_request_arcbuf(dmu_buf_t *handle, int size)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)handle;\n\n\treturn (arc_loan_buf(db->db_objset->os_spa, B_FALSE, size));\n}\n\n \nvoid\ndmu_return_arcbuf(arc_buf_t *buf)\n{\n\tarc_return_buf(buf, FTAG);\n\tarc_buf_destroy(buf, FTAG);\n}\n\n \nint\ndmu_lightweight_write_by_dnode(dnode_t *dn, uint64_t offset, abd_t *abd,\n    const zio_prop_t *zp, zio_flag_t flags, dmu_tx_t *tx)\n{\n\tdbuf_dirty_record_t *dr =\n\t    dbuf_dirty_lightweight(dn, dbuf_whichblock(dn, 0, offset), tx);\n\tif (dr == NULL)\n\t\treturn (SET_ERROR(EIO));\n\tdr->dt.dll.dr_abd = abd;\n\tdr->dt.dll.dr_props = *zp;\n\tdr->dt.dll.dr_flags = flags;\n\treturn (0);\n}\n\n \nint\ndmu_assign_arcbuf_by_dnode(dnode_t *dn, uint64_t offset, arc_buf_t *buf,\n    dmu_tx_t *tx)\n{\n\tdmu_buf_impl_t *db;\n\tobjset_t *os = dn->dn_objset;\n\tuint64_t object = dn->dn_object;\n\tuint32_t blksz = (uint32_t)arc_buf_lsize(buf);\n\tuint64_t blkid;\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tblkid = dbuf_whichblock(dn, 0, offset);\n\tdb = dbuf_hold(dn, blkid, FTAG);\n\tif (db == NULL)\n\t\treturn (SET_ERROR(EIO));\n\trw_exit(&dn->dn_struct_rwlock);\n\n\t \n\tif (offset == db->db.db_offset && blksz == db->db.db_size) {\n\t\tzfs_racct_write(blksz, 1);\n\t\tdbuf_assign_arcbuf(db, buf, tx);\n\t\tdbuf_rele(db, FTAG);\n\t} else {\n\t\t \n\t\tASSERT3U(arc_get_compression(buf), ==, ZIO_COMPRESS_OFF);\n\t\tASSERT(!(buf->b_flags & ARC_BUF_FLAG_COMPRESSED));\n\n\t\tdbuf_rele(db, FTAG);\n\t\tdmu_write(os, object, offset, blksz, buf->b_data, tx);\n\t\tdmu_return_arcbuf(buf);\n\t}\n\n\treturn (0);\n}\n\nint\ndmu_assign_arcbuf_by_dbuf(dmu_buf_t *handle, uint64_t offset, arc_buf_t *buf,\n    dmu_tx_t *tx)\n{\n\tint err;\n\tdmu_buf_impl_t *dbuf = (dmu_buf_impl_t *)handle;\n\n\tDB_DNODE_ENTER(dbuf);\n\terr = dmu_assign_arcbuf_by_dnode(DB_DNODE(dbuf), offset, buf, tx);\n\tDB_DNODE_EXIT(dbuf);\n\n\treturn (err);\n}\n\ntypedef struct {\n\tdbuf_dirty_record_t\t*dsa_dr;\n\tdmu_sync_cb_t\t\t*dsa_done;\n\tzgd_t\t\t\t*dsa_zgd;\n\tdmu_tx_t\t\t*dsa_tx;\n} dmu_sync_arg_t;\n\nstatic void\ndmu_sync_ready(zio_t *zio, arc_buf_t *buf, void *varg)\n{\n\t(void) buf;\n\tdmu_sync_arg_t *dsa = varg;\n\tdmu_buf_t *db = dsa->dsa_zgd->zgd_db;\n\tblkptr_t *bp = zio->io_bp;\n\n\tif (zio->io_error == 0) {\n\t\tif (BP_IS_HOLE(bp)) {\n\t\t\t \n\t\t\tBP_SET_LSIZE(bp, db->db_size);\n\t\t} else if (!BP_IS_EMBEDDED(bp)) {\n\t\t\tASSERT(BP_GET_LEVEL(bp) == 0);\n\t\t\tBP_SET_FILL(bp, 1);\n\t\t}\n\t}\n}\n\nstatic void\ndmu_sync_late_arrival_ready(zio_t *zio)\n{\n\tdmu_sync_ready(zio, NULL, zio->io_private);\n}\n\nstatic void\ndmu_sync_done(zio_t *zio, arc_buf_t *buf, void *varg)\n{\n\t(void) buf;\n\tdmu_sync_arg_t *dsa = varg;\n\tdbuf_dirty_record_t *dr = dsa->dsa_dr;\n\tdmu_buf_impl_t *db = dr->dr_dbuf;\n\tzgd_t *zgd = dsa->dsa_zgd;\n\n\t \n\tif (zio->io_error == 0) {\n\t\tzil_lwb_add_block(zgd->zgd_lwb, zgd->zgd_bp);\n\t}\n\n\tmutex_enter(&db->db_mtx);\n\tASSERT(dr->dt.dl.dr_override_state == DR_IN_DMU_SYNC);\n\tif (zio->io_error == 0) {\n\t\tdr->dt.dl.dr_nopwrite = !!(zio->io_flags & ZIO_FLAG_NOPWRITE);\n\t\tif (dr->dt.dl.dr_nopwrite) {\n\t\t\tblkptr_t *bp = zio->io_bp;\n\t\t\tblkptr_t *bp_orig = &zio->io_bp_orig;\n\t\t\tuint8_t chksum = BP_GET_CHECKSUM(bp_orig);\n\n\t\t\tASSERT(BP_EQUAL(bp, bp_orig));\n\t\t\tVERIFY(BP_EQUAL(bp, db->db_blkptr));\n\t\t\tASSERT(zio->io_prop.zp_compress != ZIO_COMPRESS_OFF);\n\t\t\tVERIFY(zio_checksum_table[chksum].ci_flags &\n\t\t\t    ZCHECKSUM_FLAG_NOPWRITE);\n\t\t}\n\t\tdr->dt.dl.dr_overridden_by = *zio->io_bp;\n\t\tdr->dt.dl.dr_override_state = DR_OVERRIDDEN;\n\t\tdr->dt.dl.dr_copies = zio->io_prop.zp_copies;\n\n\t\t \n\t\tif (BP_IS_HOLE(&dr->dt.dl.dr_overridden_by) &&\n\t\t    dr->dt.dl.dr_overridden_by.blk_birth == 0)\n\t\t\tBP_ZERO(&dr->dt.dl.dr_overridden_by);\n\t} else {\n\t\tdr->dt.dl.dr_override_state = DR_NOT_OVERRIDDEN;\n\t}\n\tcv_broadcast(&db->db_changed);\n\tmutex_exit(&db->db_mtx);\n\n\tdsa->dsa_done(dsa->dsa_zgd, zio->io_error);\n\n\tkmem_free(dsa, sizeof (*dsa));\n}\n\nstatic void\ndmu_sync_late_arrival_done(zio_t *zio)\n{\n\tblkptr_t *bp = zio->io_bp;\n\tdmu_sync_arg_t *dsa = zio->io_private;\n\tzgd_t *zgd = dsa->dsa_zgd;\n\n\tif (zio->io_error == 0) {\n\t\t \n\t\tzil_lwb_add_block(zgd->zgd_lwb, zgd->zgd_bp);\n\n\t\tif (!BP_IS_HOLE(bp)) {\n\t\t\tblkptr_t *bp_orig __maybe_unused = &zio->io_bp_orig;\n\t\t\tASSERT(!(zio->io_flags & ZIO_FLAG_NOPWRITE));\n\t\t\tASSERT(BP_IS_HOLE(bp_orig) || !BP_EQUAL(bp, bp_orig));\n\t\t\tASSERT(zio->io_bp->blk_birth == zio->io_txg);\n\t\t\tASSERT(zio->io_txg > spa_syncing_txg(zio->io_spa));\n\t\t\tzio_free(zio->io_spa, zio->io_txg, zio->io_bp);\n\t\t}\n\t}\n\n\tdmu_tx_commit(dsa->dsa_tx);\n\n\tdsa->dsa_done(dsa->dsa_zgd, zio->io_error);\n\n\tabd_free(zio->io_abd);\n\tkmem_free(dsa, sizeof (*dsa));\n}\n\nstatic int\ndmu_sync_late_arrival(zio_t *pio, objset_t *os, dmu_sync_cb_t *done, zgd_t *zgd,\n    zio_prop_t *zp, zbookmark_phys_t *zb)\n{\n\tdmu_sync_arg_t *dsa;\n\tdmu_tx_t *tx;\n\tint error;\n\n\terror = dbuf_read((dmu_buf_impl_t *)zgd->zgd_db, NULL,\n\t    DB_RF_CANFAIL | DB_RF_NOPREFETCH);\n\tif (error != 0)\n\t\treturn (error);\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_space(tx, zgd->zgd_db->db_size);\n\t \n\tif (dmu_tx_assign(tx, TXG_NOWAIT | TXG_NOTHROTTLE) != 0) {\n\t\tdmu_tx_abort(tx);\n\t\t \n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t \n\tzil_lwb_add_txg(zgd->zgd_lwb, dmu_tx_get_txg(tx));\n\n\tdsa = kmem_alloc(sizeof (dmu_sync_arg_t), KM_SLEEP);\n\tdsa->dsa_dr = NULL;\n\tdsa->dsa_done = done;\n\tdsa->dsa_zgd = zgd;\n\tdsa->dsa_tx = tx;\n\n\t \n\tzp->zp_nopwrite = B_FALSE;\n\n\tzio_nowait(zio_write(pio, os->os_spa, dmu_tx_get_txg(tx), zgd->zgd_bp,\n\t    abd_get_from_buf(zgd->zgd_db->db_data, zgd->zgd_db->db_size),\n\t    zgd->zgd_db->db_size, zgd->zgd_db->db_size, zp,\n\t    dmu_sync_late_arrival_ready, NULL, dmu_sync_late_arrival_done,\n\t    dsa, ZIO_PRIORITY_SYNC_WRITE, ZIO_FLAG_CANFAIL, zb));\n\n\treturn (0);\n}\n\n \nint\ndmu_sync(zio_t *pio, uint64_t txg, dmu_sync_cb_t *done, zgd_t *zgd)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)zgd->zgd_db;\n\tobjset_t *os = db->db_objset;\n\tdsl_dataset_t *ds = os->os_dsl_dataset;\n\tdbuf_dirty_record_t *dr, *dr_next;\n\tdmu_sync_arg_t *dsa;\n\tzbookmark_phys_t zb;\n\tzio_prop_t zp;\n\tdnode_t *dn;\n\n\tASSERT(pio != NULL);\n\tASSERT(txg != 0);\n\n\tSET_BOOKMARK(&zb, ds->ds_object,\n\t    db->db.db_object, db->db_level, db->db_blkid);\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\tdmu_write_policy(os, dn, db->db_level, WP_DMU_SYNC, &zp);\n\tDB_DNODE_EXIT(db);\n\n\t \n\tif (txg > spa_freeze_txg(os->os_spa))\n\t\treturn (dmu_sync_late_arrival(pio, os, done, zgd, &zp, &zb));\n\n\t \n\tmutex_enter(&db->db_mtx);\n\n\tif (txg <= spa_last_synced_txg(os->os_spa)) {\n\t\t \n\t\tmutex_exit(&db->db_mtx);\n\t\treturn (SET_ERROR(EEXIST));\n\t}\n\n\tif (txg <= spa_syncing_txg(os->os_spa)) {\n\t\t \n\t\tmutex_exit(&db->db_mtx);\n\t\treturn (dmu_sync_late_arrival(pio, os, done, zgd, &zp, &zb));\n\t}\n\n\tdr = dbuf_find_dirty_eq(db, txg);\n\n\tif (dr == NULL) {\n\t\t \n\t\tmutex_exit(&db->db_mtx);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tdr_next = list_next(&db->db_dirty_records, dr);\n\tASSERT(dr_next == NULL || dr_next->dr_txg < txg);\n\n\tif (db->db_blkptr != NULL) {\n\t\t \n\t\t*zgd->zgd_bp = *db->db_blkptr;\n\t}\n\n\t \n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\tif (dr_next != NULL || dnode_block_freed(dn, db->db_blkid))\n\t\tzp.zp_nopwrite = B_FALSE;\n\tDB_DNODE_EXIT(db);\n\n\tASSERT(dr->dr_txg == txg);\n\tif (dr->dt.dl.dr_override_state == DR_IN_DMU_SYNC ||\n\t    dr->dt.dl.dr_override_state == DR_OVERRIDDEN) {\n\t\t \n\t\tmutex_exit(&db->db_mtx);\n\t\treturn (SET_ERROR(EALREADY));\n\t}\n\n\tASSERT(dr->dt.dl.dr_override_state == DR_NOT_OVERRIDDEN);\n\tdr->dt.dl.dr_override_state = DR_IN_DMU_SYNC;\n\tmutex_exit(&db->db_mtx);\n\n\tdsa = kmem_alloc(sizeof (dmu_sync_arg_t), KM_SLEEP);\n\tdsa->dsa_dr = dr;\n\tdsa->dsa_done = done;\n\tdsa->dsa_zgd = zgd;\n\tdsa->dsa_tx = NULL;\n\n\tzio_nowait(arc_write(pio, os->os_spa, txg, zgd->zgd_bp,\n\t    dr->dt.dl.dr_data, !DBUF_IS_CACHEABLE(db), dbuf_is_l2cacheable(db),\n\t    &zp, dmu_sync_ready, NULL, dmu_sync_done, dsa,\n\t    ZIO_PRIORITY_SYNC_WRITE, ZIO_FLAG_CANFAIL, &zb));\n\n\treturn (0);\n}\n\nint\ndmu_object_set_nlevels(objset_t *os, uint64_t object, int nlevels, dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\terr = dnode_set_nlevels(dn, nlevels, tx);\n\tdnode_rele(dn, FTAG);\n\treturn (err);\n}\n\nint\ndmu_object_set_blocksize(objset_t *os, uint64_t object, uint64_t size, int ibs,\n    dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\terr = dnode_set_blksz(dn, size, ibs, tx);\n\tdnode_rele(dn, FTAG);\n\treturn (err);\n}\n\nint\ndmu_object_set_maxblkid(objset_t *os, uint64_t object, uint64_t maxblkid,\n    dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\tint err;\n\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\trw_enter(&dn->dn_struct_rwlock, RW_WRITER);\n\tdnode_new_blkid(dn, maxblkid, tx, B_FALSE, B_TRUE);\n\trw_exit(&dn->dn_struct_rwlock);\n\tdnode_rele(dn, FTAG);\n\treturn (0);\n}\n\nvoid\ndmu_object_set_checksum(objset_t *os, uint64_t object, uint8_t checksum,\n    dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\n\t \n\tASSERT3U(checksum, <, ZIO_CHECKSUM_LEGACY_FUNCTIONS);\n\n\tVERIFY0(dnode_hold(os, object, FTAG, &dn));\n\tASSERT3U(checksum, <, ZIO_CHECKSUM_FUNCTIONS);\n\tdn->dn_checksum = checksum;\n\tdnode_setdirty(dn, tx);\n\tdnode_rele(dn, FTAG);\n}\n\nvoid\ndmu_object_set_compress(objset_t *os, uint64_t object, uint8_t compress,\n    dmu_tx_t *tx)\n{\n\tdnode_t *dn;\n\n\t \n\tASSERT3U(compress, <, ZIO_COMPRESS_LEGACY_FUNCTIONS);\n\n\tVERIFY0(dnode_hold(os, object, FTAG, &dn));\n\tdn->dn_compress = compress;\n\tdnode_setdirty(dn, tx);\n\tdnode_rele(dn, FTAG);\n}\n\n \nstatic const int zfs_redundant_metadata_most_ditto_level = 2;\n\nvoid\ndmu_write_policy(objset_t *os, dnode_t *dn, int level, int wp, zio_prop_t *zp)\n{\n\tdmu_object_type_t type = dn ? dn->dn_type : DMU_OT_OBJSET;\n\tboolean_t ismd = (level > 0 || DMU_OT_IS_METADATA(type) ||\n\t    (wp & WP_SPILL));\n\tenum zio_checksum checksum = os->os_checksum;\n\tenum zio_compress compress = os->os_compress;\n\tuint8_t complevel = os->os_complevel;\n\tenum zio_checksum dedup_checksum = os->os_dedup_checksum;\n\tboolean_t dedup = B_FALSE;\n\tboolean_t nopwrite = B_FALSE;\n\tboolean_t dedup_verify = os->os_dedup_verify;\n\tboolean_t encrypt = B_FALSE;\n\tint copies = os->os_copies;\n\n\t \n\tif (ismd) {\n\t\t \n\t\tcompress = zio_compress_select(os->os_spa,\n\t\t    ZIO_COMPRESS_ON, ZIO_COMPRESS_ON);\n\n\t\t \n\t\tif (!(zio_checksum_table[checksum].ci_flags &\n\t\t    ZCHECKSUM_FLAG_METADATA) ||\n\t\t    (zio_checksum_table[checksum].ci_flags &\n\t\t    ZCHECKSUM_FLAG_EMBEDDED))\n\t\t\tchecksum = ZIO_CHECKSUM_FLETCHER_4;\n\n\t\tswitch (os->os_redundant_metadata) {\n\t\tcase ZFS_REDUNDANT_METADATA_ALL:\n\t\t\tcopies++;\n\t\t\tbreak;\n\t\tcase ZFS_REDUNDANT_METADATA_MOST:\n\t\t\tif (level >= zfs_redundant_metadata_most_ditto_level ||\n\t\t\t    DMU_OT_IS_METADATA(type) || (wp & WP_SPILL))\n\t\t\t\tcopies++;\n\t\t\tbreak;\n\t\tcase ZFS_REDUNDANT_METADATA_SOME:\n\t\t\tif (DMU_OT_IS_CRITICAL(type))\n\t\t\t\tcopies++;\n\t\t\tbreak;\n\t\tcase ZFS_REDUNDANT_METADATA_NONE:\n\t\t\tbreak;\n\t\t}\n\t} else if (wp & WP_NOFILL) {\n\t\tASSERT(level == 0);\n\n\t\t \n\t\tcompress = ZIO_COMPRESS_OFF;\n\t\tchecksum = ZIO_CHECKSUM_OFF;\n\t} else {\n\t\tcompress = zio_compress_select(os->os_spa, dn->dn_compress,\n\t\t    compress);\n\t\tcomplevel = zio_complevel_select(os->os_spa, compress,\n\t\t    complevel, complevel);\n\n\t\tchecksum = (dedup_checksum == ZIO_CHECKSUM_OFF) ?\n\t\t    zio_checksum_select(dn->dn_checksum, checksum) :\n\t\t    dedup_checksum;\n\n\t\t \n\t\tif (dedup_checksum != ZIO_CHECKSUM_OFF) {\n\t\t\tdedup = (wp & WP_DMU_SYNC) ? B_FALSE : B_TRUE;\n\t\t\tif (!(zio_checksum_table[checksum].ci_flags &\n\t\t\t    ZCHECKSUM_FLAG_DEDUP))\n\t\t\t\tdedup_verify = B_TRUE;\n\t\t}\n\n\t\t \n\t\tnopwrite = (!dedup && (zio_checksum_table[checksum].ci_flags &\n\t\t    ZCHECKSUM_FLAG_NOPWRITE) &&\n\t\t    compress != ZIO_COMPRESS_OFF && zfs_nopwrite_enabled);\n\t}\n\n\t \n\tif (os->os_encrypted && (wp & WP_NOFILL) == 0) {\n\t\tencrypt = B_TRUE;\n\n\t\tif (DMU_OT_IS_ENCRYPTED(type)) {\n\t\t\tcopies = MIN(copies, SPA_DVAS_PER_BP - 1);\n\t\t\tnopwrite = B_FALSE;\n\t\t} else {\n\t\t\tdedup = B_FALSE;\n\t\t}\n\n\t\tif (level <= 0 &&\n\t\t    (type == DMU_OT_DNODE || type == DMU_OT_OBJSET)) {\n\t\t\tcompress = ZIO_COMPRESS_EMPTY;\n\t\t}\n\t}\n\n\tzp->zp_compress = compress;\n\tzp->zp_complevel = complevel;\n\tzp->zp_checksum = checksum;\n\tzp->zp_type = (wp & WP_SPILL) ? dn->dn_bonustype : type;\n\tzp->zp_level = level;\n\tzp->zp_copies = MIN(copies, spa_max_replication(os->os_spa));\n\tzp->zp_dedup = dedup;\n\tzp->zp_dedup_verify = dedup && dedup_verify;\n\tzp->zp_nopwrite = nopwrite;\n\tzp->zp_encrypt = encrypt;\n\tzp->zp_byteorder = ZFS_HOST_BYTEORDER;\n\tmemset(zp->zp_salt, 0, ZIO_DATA_SALT_LEN);\n\tmemset(zp->zp_iv, 0, ZIO_DATA_IV_LEN);\n\tmemset(zp->zp_mac, 0, ZIO_DATA_MAC_LEN);\n\tzp->zp_zpl_smallblk = DMU_OT_IS_FILE(zp->zp_type) ?\n\t    os->os_zpl_special_smallblock : 0;\n\n\tASSERT3U(zp->zp_compress, !=, ZIO_COMPRESS_INHERIT);\n}\n\n \nint\ndmu_offset_next(objset_t *os, uint64_t object, boolean_t hole, uint64_t *off)\n{\n\tdnode_t *dn;\n\tint restarted = 0, err;\n\nrestart:\n\terr = dnode_hold(os, object, FTAG, &dn);\n\tif (err)\n\t\treturn (err);\n\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\n\tif (dnode_is_dirty(dn)) {\n\t\t \n\t\tif (zfs_dmu_offset_next_sync) {\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\tdnode_rele(dn, FTAG);\n\n\t\t\tif (restarted)\n\t\t\t\treturn (SET_ERROR(EBUSY));\n\n\t\t\ttxg_wait_synced(dmu_objset_pool(os), 0);\n\t\t\trestarted = 1;\n\t\t\tgoto restart;\n\t\t}\n\n\t\terr = SET_ERROR(EBUSY);\n\t} else {\n\t\terr = dnode_next_offset(dn, DNODE_FIND_HAVELOCK |\n\t\t    (hole ? DNODE_FIND_HOLE : 0), off, 1, 1, 0);\n\t}\n\n\trw_exit(&dn->dn_struct_rwlock);\n\tdnode_rele(dn, FTAG);\n\n\treturn (err);\n}\n\nint\ndmu_read_l0_bps(objset_t *os, uint64_t object, uint64_t offset, uint64_t length,\n    blkptr_t *bps, size_t *nbpsp)\n{\n\tdmu_buf_t **dbp, *dbuf;\n\tdmu_buf_impl_t *db;\n\tblkptr_t *bp;\n\tint error, numbufs;\n\n\terror = dmu_buf_hold_array(os, object, offset, length, FALSE, FTAG,\n\t    &numbufs, &dbp);\n\tif (error != 0) {\n\t\tif (error == ESRCH) {\n\t\t\terror = SET_ERROR(ENXIO);\n\t\t}\n\t\treturn (error);\n\t}\n\n\tASSERT3U(numbufs, <=, *nbpsp);\n\n\tfor (int i = 0; i < numbufs; i++) {\n\t\tdbuf = dbp[i];\n\t\tdb = (dmu_buf_impl_t *)dbuf;\n\n\t\tmutex_enter(&db->db_mtx);\n\n\t\tif (!list_is_empty(&db->db_dirty_records)) {\n\t\t\tdbuf_dirty_record_t *dr;\n\n\t\t\tdr = list_head(&db->db_dirty_records);\n\t\t\tif (dr->dt.dl.dr_brtwrite) {\n\t\t\t\t \n\t\t\t\tbp = &dr->dt.dl.dr_overridden_by;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmutex_exit(&db->db_mtx);\n\t\t\t\terror = SET_ERROR(EAGAIN);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tbp = db->db_blkptr;\n\t\t}\n\n\t\tmutex_exit(&db->db_mtx);\n\n\t\tif (bp == NULL) {\n\t\t\t \n\t\t\terror = SET_ERROR(EAGAIN);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (BP_IS_METADATA(bp) && !BP_IS_HOLE(bp)) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbps[i] = *bp;\n\t}\n\n\t*nbpsp = numbufs;\nout:\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\n\treturn (error);\n}\n\nint\ndmu_brt_clone(objset_t *os, uint64_t object, uint64_t offset, uint64_t length,\n    dmu_tx_t *tx, const blkptr_t *bps, size_t nbps)\n{\n\tspa_t *spa;\n\tdmu_buf_t **dbp, *dbuf;\n\tdmu_buf_impl_t *db;\n\tstruct dirty_leaf *dl;\n\tdbuf_dirty_record_t *dr;\n\tconst blkptr_t *bp;\n\tint error = 0, i, numbufs;\n\n\tspa = os->os_spa;\n\n\tVERIFY0(dmu_buf_hold_array(os, object, offset, length, FALSE, FTAG,\n\t    &numbufs, &dbp));\n\tASSERT3U(nbps, ==, numbufs);\n\n\t \n\tfor (i = 0; i < numbufs; i++) {\n\t\tdbuf = dbp[i];\n\t\tdb = (dmu_buf_impl_t *)dbuf;\n\t\tbp = &bps[i];\n\n\t\tASSERT0(db->db_level);\n\t\tASSERT(db->db_blkid != DMU_BONUS_BLKID);\n\t\tASSERT(db->db_blkid != DMU_SPILL_BLKID);\n\n\t\tif (!BP_IS_HOLE(bp) && BP_GET_LSIZE(bp) != dbuf->db_size) {\n\t\t\terror = SET_ERROR(EXDEV);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tdbuf = dbp[i];\n\t\tdb = (dmu_buf_impl_t *)dbuf;\n\t\tbp = &bps[i];\n\n\t\tASSERT0(db->db_level);\n\t\tASSERT(db->db_blkid != DMU_BONUS_BLKID);\n\t\tASSERT(db->db_blkid != DMU_SPILL_BLKID);\n\t\tASSERT(BP_IS_HOLE(bp) || dbuf->db_size == BP_GET_LSIZE(bp));\n\n\t\tdmu_buf_will_clone(dbuf, tx);\n\n\t\tmutex_enter(&db->db_mtx);\n\n\t\tdr = list_head(&db->db_dirty_records);\n\t\tVERIFY(dr != NULL);\n\t\tASSERT3U(dr->dr_txg, ==, tx->tx_txg);\n\t\tdl = &dr->dt.dl;\n\t\tdl->dr_overridden_by = *bp;\n\t\tdl->dr_brtwrite = B_TRUE;\n\t\tdl->dr_override_state = DR_OVERRIDDEN;\n\t\tif (BP_IS_HOLE(bp)) {\n\t\t\tdl->dr_overridden_by.blk_birth = 0;\n\t\t\tdl->dr_overridden_by.blk_phys_birth = 0;\n\t\t} else {\n\t\t\tdl->dr_overridden_by.blk_birth = dr->dr_txg;\n\t\t\tif (!BP_IS_EMBEDDED(bp)) {\n\t\t\t\tdl->dr_overridden_by.blk_phys_birth =\n\t\t\t\t    BP_PHYSICAL_BIRTH(bp);\n\t\t\t}\n\t\t}\n\n\t\tmutex_exit(&db->db_mtx);\n\n\t\t \n\t\tif (!BP_IS_HOLE(bp) && !BP_IS_EMBEDDED(bp)) {\n\t\t\tbrt_pending_add(spa, bp, tx);\n\t\t}\n\t}\nout:\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\n\treturn (error);\n}\n\nvoid\n__dmu_object_info_from_dnode(dnode_t *dn, dmu_object_info_t *doi)\n{\n\tdnode_phys_t *dnp = dn->dn_phys;\n\n\tdoi->doi_data_block_size = dn->dn_datablksz;\n\tdoi->doi_metadata_block_size = dn->dn_indblkshift ?\n\t    1ULL << dn->dn_indblkshift : 0;\n\tdoi->doi_type = dn->dn_type;\n\tdoi->doi_bonus_type = dn->dn_bonustype;\n\tdoi->doi_bonus_size = dn->dn_bonuslen;\n\tdoi->doi_dnodesize = dn->dn_num_slots << DNODE_SHIFT;\n\tdoi->doi_indirection = dn->dn_nlevels;\n\tdoi->doi_checksum = dn->dn_checksum;\n\tdoi->doi_compress = dn->dn_compress;\n\tdoi->doi_nblkptr = dn->dn_nblkptr;\n\tdoi->doi_physical_blocks_512 = (DN_USED_BYTES(dnp) + 256) >> 9;\n\tdoi->doi_max_offset = (dn->dn_maxblkid + 1) * dn->dn_datablksz;\n\tdoi->doi_fill_count = 0;\n\tfor (int i = 0; i < dnp->dn_nblkptr; i++)\n\t\tdoi->doi_fill_count += BP_GET_FILL(&dnp->dn_blkptr[i]);\n}\n\nvoid\ndmu_object_info_from_dnode(dnode_t *dn, dmu_object_info_t *doi)\n{\n\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\tmutex_enter(&dn->dn_mtx);\n\n\t__dmu_object_info_from_dnode(dn, doi);\n\n\tmutex_exit(&dn->dn_mtx);\n\trw_exit(&dn->dn_struct_rwlock);\n}\n\n \nint\ndmu_object_info(objset_t *os, uint64_t object, dmu_object_info_t *doi)\n{\n\tdnode_t *dn;\n\tint err = dnode_hold(os, object, FTAG, &dn);\n\n\tif (err)\n\t\treturn (err);\n\n\tif (doi != NULL)\n\t\tdmu_object_info_from_dnode(dn, doi);\n\n\tdnode_rele(dn, FTAG);\n\treturn (0);\n}\n\n \nvoid\ndmu_object_info_from_db(dmu_buf_t *db_fake, dmu_object_info_t *doi)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\n\tDB_DNODE_ENTER(db);\n\tdmu_object_info_from_dnode(DB_DNODE(db), doi);\n\tDB_DNODE_EXIT(db);\n}\n\n \nvoid\ndmu_object_size_from_db(dmu_buf_t *db_fake, uint32_t *blksize,\n    u_longlong_t *nblk512)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\tdnode_t *dn;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\n\t*blksize = dn->dn_datablksz;\n\t \n\t*nblk512 = ((DN_USED_BYTES(dn->dn_phys) + SPA_MINBLOCKSIZE/2) >>\n\t    SPA_MINBLOCKSHIFT) + dn->dn_num_slots;\n\tDB_DNODE_EXIT(db);\n}\n\nvoid\ndmu_object_dnsize_from_db(dmu_buf_t *db_fake, int *dnsize)\n{\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)db_fake;\n\tdnode_t *dn;\n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\t*dnsize = dn->dn_num_slots << DNODE_SHIFT;\n\tDB_DNODE_EXIT(db);\n}\n\nvoid\nbyteswap_uint64_array(void *vbuf, size_t size)\n{\n\tuint64_t *buf = vbuf;\n\tsize_t count = size >> 3;\n\tint i;\n\n\tASSERT((size & 7) == 0);\n\n\tfor (i = 0; i < count; i++)\n\t\tbuf[i] = BSWAP_64(buf[i]);\n}\n\nvoid\nbyteswap_uint32_array(void *vbuf, size_t size)\n{\n\tuint32_t *buf = vbuf;\n\tsize_t count = size >> 2;\n\tint i;\n\n\tASSERT((size & 3) == 0);\n\n\tfor (i = 0; i < count; i++)\n\t\tbuf[i] = BSWAP_32(buf[i]);\n}\n\nvoid\nbyteswap_uint16_array(void *vbuf, size_t size)\n{\n\tuint16_t *buf = vbuf;\n\tsize_t count = size >> 1;\n\tint i;\n\n\tASSERT((size & 1) == 0);\n\n\tfor (i = 0; i < count; i++)\n\t\tbuf[i] = BSWAP_16(buf[i]);\n}\n\nvoid\nbyteswap_uint8_array(void *vbuf, size_t size)\n{\n\t(void) vbuf, (void) size;\n}\n\nvoid\ndmu_init(void)\n{\n\tabd_init();\n\tzfs_dbgmsg_init();\n\tsa_cache_init();\n\tdmu_objset_init();\n\tdnode_init();\n\tzfetch_init();\n\tdmu_tx_init();\n\tl2arc_init();\n\tarc_init();\n\tdbuf_init();\n}\n\nvoid\ndmu_fini(void)\n{\n\tarc_fini();  \n\tl2arc_fini();\n\tdmu_tx_fini();\n\tzfetch_fini();\n\tdbuf_fini();\n\tdnode_fini();\n\tdmu_objset_fini();\n\tsa_cache_fini();\n\tzfs_dbgmsg_fini();\n\tabd_fini();\n}\n\nEXPORT_SYMBOL(dmu_bonus_hold);\nEXPORT_SYMBOL(dmu_bonus_hold_by_dnode);\nEXPORT_SYMBOL(dmu_buf_hold_array_by_bonus);\nEXPORT_SYMBOL(dmu_buf_rele_array);\nEXPORT_SYMBOL(dmu_prefetch);\nEXPORT_SYMBOL(dmu_free_range);\nEXPORT_SYMBOL(dmu_free_long_range);\nEXPORT_SYMBOL(dmu_free_long_object);\nEXPORT_SYMBOL(dmu_read);\nEXPORT_SYMBOL(dmu_read_by_dnode);\nEXPORT_SYMBOL(dmu_write);\nEXPORT_SYMBOL(dmu_write_by_dnode);\nEXPORT_SYMBOL(dmu_prealloc);\nEXPORT_SYMBOL(dmu_object_info);\nEXPORT_SYMBOL(dmu_object_info_from_dnode);\nEXPORT_SYMBOL(dmu_object_info_from_db);\nEXPORT_SYMBOL(dmu_object_size_from_db);\nEXPORT_SYMBOL(dmu_object_dnsize_from_db);\nEXPORT_SYMBOL(dmu_object_set_nlevels);\nEXPORT_SYMBOL(dmu_object_set_blocksize);\nEXPORT_SYMBOL(dmu_object_set_maxblkid);\nEXPORT_SYMBOL(dmu_object_set_checksum);\nEXPORT_SYMBOL(dmu_object_set_compress);\nEXPORT_SYMBOL(dmu_offset_next);\nEXPORT_SYMBOL(dmu_write_policy);\nEXPORT_SYMBOL(dmu_sync);\nEXPORT_SYMBOL(dmu_request_arcbuf);\nEXPORT_SYMBOL(dmu_return_arcbuf);\nEXPORT_SYMBOL(dmu_assign_arcbuf_by_dnode);\nEXPORT_SYMBOL(dmu_assign_arcbuf_by_dbuf);\nEXPORT_SYMBOL(dmu_buf_hold);\nEXPORT_SYMBOL(dmu_ot);\n\nZFS_MODULE_PARAM(zfs, zfs_, nopwrite_enabled, INT, ZMOD_RW,\n\t\"Enable NOP writes\");\n\nZFS_MODULE_PARAM(zfs, zfs_, per_txg_dirty_frees_percent, UINT, ZMOD_RW,\n\t\"Percentage of dirtied blocks from frees in one TXG\");\n\nZFS_MODULE_PARAM(zfs, zfs_, dmu_offset_next_sync, INT, ZMOD_RW,\n\t\"Enable forcing txg sync to find holes\");\n\n \nZFS_MODULE_PARAM(zfs, , dmu_prefetch_max, UINT, ZMOD_RW,\n\t\"Limit one prefetch call to this size\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}