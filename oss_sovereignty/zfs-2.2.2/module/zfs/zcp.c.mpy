{
  "module_name": "zcp.c",
  "hash_id": "4b17c4f3707c0778c8a184756fbaeeb38ef18a769520434c2df0cd60bd4935b4",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zcp.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/lua/lua.h>\n#include <sys/lua/lualib.h>\n#include <sys/lua/lauxlib.h>\n\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_dataset.h>\n#include <sys/zcp.h>\n#include <sys/zcp_iter.h>\n#include <sys/zcp_prop.h>\n#include <sys/zcp_global.h>\n#include <sys/zvol.h>\n\n#ifndef KM_NORMALPRI\n#define\tKM_NORMALPRI\t0\n#endif\n\n#define\tZCP_NVLIST_MAX_DEPTH 20\n\nstatic const uint64_t zfs_lua_check_instrlimit_interval = 100;\nuint64_t zfs_lua_max_instrlimit = ZCP_MAX_INSTRLIMIT;\nuint64_t zfs_lua_max_memlimit = ZCP_MAX_MEMLIMIT;\n\n \nstatic int zcp_nvpair_value_to_lua(lua_State *, nvpair_t *, char *, int);\nstatic int zcp_lua_to_nvlist_impl(lua_State *, int, nvlist_t *, const char *,\n    int);\n\n \nstatic int\nzcp_error_handler(lua_State *state)\n{\n\tconst char *msg;\n\n\tzcp_cleanup(state);\n\n\tVERIFY3U(1, ==, lua_gettop(state));\n\tmsg = lua_tostring(state, 1);\n\tluaL_traceback(state, state, msg, 1);\n\treturn (1);\n}\n\nint\nzcp_argerror(lua_State *state, int narg, const char *msg, ...)\n{\n\tva_list alist;\n\n\tva_start(alist, msg);\n\tconst char *buf = lua_pushvfstring(state, msg, alist);\n\tva_end(alist);\n\n\treturn (luaL_argerror(state, narg, buf));\n}\n\n \nzcp_cleanup_handler_t *\nzcp_register_cleanup(lua_State *state, zcp_cleanup_t cleanfunc, void *cleanarg)\n{\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\n\tzcp_cleanup_handler_t *zch = kmem_alloc(sizeof (*zch), KM_SLEEP);\n\tzch->zch_cleanup_func = cleanfunc;\n\tzch->zch_cleanup_arg = cleanarg;\n\tlist_insert_head(&ri->zri_cleanup_handlers, zch);\n\n\treturn (zch);\n}\n\nvoid\nzcp_deregister_cleanup(lua_State *state, zcp_cleanup_handler_t *zch)\n{\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\tlist_remove(&ri->zri_cleanup_handlers, zch);\n\tkmem_free(zch, sizeof (*zch));\n}\n\n \nvoid\nzcp_cleanup(lua_State *state)\n{\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\n\tfor (zcp_cleanup_handler_t *zch =\n\t    list_remove_head(&ri->zri_cleanup_handlers); zch != NULL;\n\t    zch = list_remove_head(&ri->zri_cleanup_handlers)) {\n\t\tzch->zch_cleanup_func(zch->zch_cleanup_arg);\n\t\tkmem_free(zch, sizeof (*zch));\n\t}\n}\n\n \nstatic nvlist_t *\nzcp_table_to_nvlist(lua_State *state, int index, int depth)\n{\n\tnvlist_t *nvl;\n\t \n\tVERIFY0(nvlist_alloc(&nvl, 0, KM_SLEEP));\n\n\t \n\tlua_pushnil(state);\n\tboolean_t saw_str_could_collide = B_FALSE;\n\twhile (lua_next(state, index) != 0) {\n\t\t \n\t\tint err = 0;\n\t\tchar buf[32];\n\t\tconst char *key = NULL;\n\t\tboolean_t key_could_collide = B_FALSE;\n\n\t\tswitch (lua_type(state, -2)) {\n\t\tcase LUA_TSTRING:\n\t\t\tkey = lua_tostring(state, -2);\n\n\t\t\t \n\t\t\tlong long tmp;\n\t\t\tint parselen;\n\t\t\tif ((sscanf(key, \"%lld%n\", &tmp, &parselen) > 0 &&\n\t\t\t    parselen == strlen(key)) ||\n\t\t\t    strcmp(key, \"true\") == 0 ||\n\t\t\t    strcmp(key, \"false\") == 0) {\n\t\t\t\tkey_could_collide = B_TRUE;\n\t\t\t\tsaw_str_could_collide = B_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LUA_TBOOLEAN:\n\t\t\tkey = (lua_toboolean(state, -2) == B_TRUE ?\n\t\t\t    \"true\" : \"false\");\n\t\t\tif (saw_str_could_collide) {\n\t\t\t\tkey_could_collide = B_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LUA_TNUMBER:\n\t\t\t(void) snprintf(buf, sizeof (buf), \"%lld\",\n\t\t\t    (longlong_t)lua_tonumber(state, -2));\n\n\t\t\tkey = buf;\n\t\t\tif (saw_str_could_collide) {\n\t\t\t\tkey_could_collide = B_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfnvlist_free(nvl);\n\t\t\t(void) lua_pushfstring(state, \"Invalid key \"\n\t\t\t    \"type '%s' in table\",\n\t\t\t    lua_typename(state, lua_type(state, -2)));\n\t\t\treturn (NULL);\n\t\t}\n\t\t \n\t\tif (key_could_collide && nvlist_exists(nvl, key)) {\n\t\t\tfnvlist_free(nvl);\n\t\t\t(void) lua_pushfstring(state, \"Collision of \"\n\t\t\t    \"key '%s' in table\", key);\n\t\t\treturn (NULL);\n\t\t}\n\t\t \n\t\tif (depth >= ZCP_NVLIST_MAX_DEPTH) {\n\t\t\tfnvlist_free(nvl);\n\t\t\t(void) lua_pushfstring(state, \"Maximum table \"\n\t\t\t    \"depth (%d) exceeded for table\",\n\t\t\t    ZCP_NVLIST_MAX_DEPTH);\n\t\t\treturn (NULL);\n\t\t}\n\t\terr = zcp_lua_to_nvlist_impl(state, -1, nvl, key,\n\t\t    depth + 1);\n\t\tif (err != 0) {\n\t\t\tfnvlist_free(nvl);\n\t\t\t \n\t\t\treturn (NULL);\n\t\t}\n\t\t \n\t\tlua_pop(state, 1);\n\t}\n\n\t \n\tnvl->nvl_nvflag |= NV_UNIQUE_NAME;\n\n\treturn (nvl);\n}\n\n \nstatic int\nzcp_lua_to_nvlist_impl(lua_State *state, int index, nvlist_t *nvl,\n    const char *key, int depth)\n{\n\t \n\tif (!lua_checkstack(state, 3)) {\n\t\t(void) lua_pushstring(state, \"Lua stack overflow\");\n\t\treturn (1);\n\t}\n\n\tindex = lua_absindex(state, index);\n\n\tswitch (lua_type(state, index)) {\n\tcase LUA_TNIL:\n\t\tfnvlist_add_boolean(nvl, key);\n\t\tbreak;\n\tcase LUA_TBOOLEAN:\n\t\tfnvlist_add_boolean_value(nvl, key,\n\t\t    lua_toboolean(state, index));\n\t\tbreak;\n\tcase LUA_TNUMBER:\n\t\tfnvlist_add_int64(nvl, key, lua_tonumber(state, index));\n\t\tbreak;\n\tcase LUA_TSTRING:\n\t\tfnvlist_add_string(nvl, key, lua_tostring(state, index));\n\t\tbreak;\n\tcase LUA_TTABLE: {\n\t\tnvlist_t *value_nvl = zcp_table_to_nvlist(state, index, depth);\n\t\tif (value_nvl == NULL)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tfnvlist_add_nvlist(nvl, key, value_nvl);\n\t\tfnvlist_free(value_nvl);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t(void) lua_pushfstring(state,\n\t\t    \"Invalid value type '%s' for key '%s'\",\n\t\t    lua_typename(state, lua_type(state, index)), key);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nzcp_lua_to_nvlist(lua_State *state, int index, nvlist_t *nvl, const char *key)\n{\n\t \n\tif (zcp_lua_to_nvlist_impl(state, index, nvl, key, 0) != 0)\n\t\t(void) lua_error(state);\n}\n\nstatic int\nzcp_lua_to_nvlist_helper(lua_State *state)\n{\n\tnvlist_t *nv = (nvlist_t *)lua_touserdata(state, 2);\n\tconst char *key = (const char *)lua_touserdata(state, 1);\n\tzcp_lua_to_nvlist(state, 3, nv, key);\n\treturn (0);\n}\n\nstatic void\nzcp_convert_return_values(lua_State *state, nvlist_t *nvl,\n    const char *key, int *result)\n{\n\tint err;\n\tVERIFY3U(1, ==, lua_gettop(state));\n\tlua_pushcfunction(state, zcp_lua_to_nvlist_helper);\n\tlua_pushlightuserdata(state, (char *)key);\n\tlua_pushlightuserdata(state, nvl);\n\tlua_pushvalue(state, 1);\n\tlua_remove(state, 1);\n\terr = lua_pcall(state, 3, 0, 0);  \n\tif (err != 0) {\n\t\tzcp_lua_to_nvlist(state, 1, nvl, ZCP_RET_ERROR);\n\t\t*result = SET_ERROR(ECHRNG);\n\t}\n}\n\n \nint\nzcp_nvlist_to_lua(lua_State *state, nvlist_t *nvl,\n    char *errbuf, int errbuf_len)\n{\n\tnvpair_t *pair;\n\tlua_newtable(state);\n\tboolean_t has_values = B_FALSE;\n\t \n\tfor (pair = nvlist_next_nvpair(nvl, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(nvl, pair)) {\n\t\tif (nvpair_type(pair) != DATA_TYPE_BOOLEAN) {\n\t\t\thas_values = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!has_values) {\n\t\tint i = 1;\n\t\tfor (pair = nvlist_next_nvpair(nvl, NULL);\n\t\t    pair != NULL; pair = nvlist_next_nvpair(nvl, pair)) {\n\t\t\t(void) lua_pushinteger(state, i);\n\t\t\t(void) lua_pushstring(state, nvpair_name(pair));\n\t\t\t(void) lua_settable(state, -3);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tfor (pair = nvlist_next_nvpair(nvl, NULL);\n\t\t    pair != NULL; pair = nvlist_next_nvpair(nvl, pair)) {\n\t\t\tint err = zcp_nvpair_value_to_lua(state, pair,\n\t\t\t    errbuf, errbuf_len);\n\t\t\tif (err != 0) {\n\t\t\t\tlua_pop(state, 1);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t\t(void) lua_setfield(state, -2, nvpair_name(pair));\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nstatic int\nzcp_nvpair_value_to_lua(lua_State *state, nvpair_t *pair,\n    char *errbuf, int errbuf_len)\n{\n\tint err = 0;\n\n\tif (pair == NULL) {\n\t\tlua_pushnil(state);\n\t\treturn (0);\n\t}\n\n\tswitch (nvpair_type(pair)) {\n\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\t(void) lua_pushboolean(state,\n\t\t    fnvpair_value_boolean_value(pair));\n\t\tbreak;\n\tcase DATA_TYPE_STRING:\n\t\t(void) lua_pushstring(state, fnvpair_value_string(pair));\n\t\tbreak;\n\tcase DATA_TYPE_INT64:\n\t\t(void) lua_pushinteger(state, fnvpair_value_int64(pair));\n\t\tbreak;\n\tcase DATA_TYPE_NVLIST:\n\t\terr = zcp_nvlist_to_lua(state,\n\t\t    fnvpair_value_nvlist(pair), errbuf, errbuf_len);\n\t\tbreak;\n\tcase DATA_TYPE_STRING_ARRAY: {\n\t\tconst char **strarr;\n\t\tuint_t nelem;\n\t\t(void) nvpair_value_string_array(pair, &strarr, &nelem);\n\t\tlua_newtable(state);\n\t\tfor (int i = 0; i < nelem; i++) {\n\t\t\t(void) lua_pushinteger(state, i + 1);\n\t\t\t(void) lua_pushstring(state, strarr[i]);\n\t\t\t(void) lua_settable(state, -3);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_TYPE_UINT64_ARRAY: {\n\t\tuint64_t *intarr;\n\t\tuint_t nelem;\n\t\t(void) nvpair_value_uint64_array(pair, &intarr, &nelem);\n\t\tlua_newtable(state);\n\t\tfor (int i = 0; i < nelem; i++) {\n\t\t\t(void) lua_pushinteger(state, i + 1);\n\t\t\t(void) lua_pushinteger(state, intarr[i]);\n\t\t\t(void) lua_settable(state, -3);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DATA_TYPE_INT64_ARRAY: {\n\t\tint64_t *intarr;\n\t\tuint_t nelem;\n\t\t(void) nvpair_value_int64_array(pair, &intarr, &nelem);\n\t\tlua_newtable(state);\n\t\tfor (int i = 0; i < nelem; i++) {\n\t\t\t(void) lua_pushinteger(state, i + 1);\n\t\t\t(void) lua_pushinteger(state, intarr[i]);\n\t\t\t(void) lua_settable(state, -3);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tif (errbuf != NULL) {\n\t\t\t(void) snprintf(errbuf, errbuf_len,\n\t\t\t    \"Unhandled nvpair type %d for key '%s'\",\n\t\t\t    nvpair_type(pair), nvpair_name(pair));\n\t\t}\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\t}\n\treturn (err);\n}\n\nint\nzcp_dataset_hold_error(lua_State *state, dsl_pool_t *dp, const char *dsname,\n    int error)\n{\n\tif (error == ENOENT) {\n\t\t(void) zcp_argerror(state, 1, \"no such dataset '%s'\", dsname);\n\t\treturn (0);  \n\t} else if (error == EXDEV) {\n\t\t(void) zcp_argerror(state, 1,\n\t\t    \"dataset '%s' is not in the target pool '%s'\",\n\t\t    dsname, spa_name(dp->dp_spa));\n\t\treturn (0);  \n\t} else if (error == EIO) {\n\t\t(void) luaL_error(state,\n\t\t    \"I/O error while accessing dataset '%s'\", dsname);\n\t\treturn (0);  \n\t} else if (error != 0) {\n\t\t(void) luaL_error(state,\n\t\t    \"unexpected error %d while accessing dataset '%s'\",\n\t\t    error, dsname);\n\t\treturn (0);  \n\t}\n\treturn (0);\n}\n\n \ndsl_dataset_t *\nzcp_dataset_hold(lua_State *state, dsl_pool_t *dp, const char *dsname,\n    const void *tag)\n{\n\tdsl_dataset_t *ds;\n\tint error = dsl_dataset_hold(dp, dsname, tag, &ds);\n\t(void) zcp_dataset_hold_error(state, dp, dsname, error);\n\treturn (ds);\n}\n\nstatic int zcp_debug(lua_State *);\nstatic const zcp_lib_info_t zcp_debug_info = {\n\t.name = \"debug\",\n\t.func = zcp_debug,\n\t.pargs = {\n\t    { .za_name = \"debug string\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_debug(lua_State *state)\n{\n\tconst char *dbgstring;\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\tconst zcp_lib_info_t *libinfo = &zcp_debug_info;\n\n\tzcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);\n\n\tdbgstring = lua_tostring(state, 1);\n\n\tzfs_dbgmsg(\"txg %lld ZCP: %s\", (longlong_t)ri->zri_tx->tx_txg,\n\t    dbgstring);\n\n\treturn (0);\n}\n\nstatic int zcp_exists(lua_State *);\nstatic const zcp_lib_info_t zcp_exists_info = {\n\t.name = \"exists\",\n\t.func = zcp_exists,\n\t.pargs = {\n\t    { .za_name = \"dataset\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_exists(lua_State *state)\n{\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\tdsl_pool_t *dp = ri->zri_pool;\n\tconst zcp_lib_info_t *libinfo = &zcp_exists_info;\n\n\tzcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);\n\n\tconst char *dsname = lua_tostring(state, 1);\n\n\tdsl_dataset_t *ds;\n\tint error = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\tif (error == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tlua_pushboolean(state, B_TRUE);\n\t} else if (error == ENOENT) {\n\t\tlua_pushboolean(state, B_FALSE);\n\t} else if (error == EXDEV) {\n\t\treturn (luaL_error(state, \"dataset '%s' is not in the \"\n\t\t    \"target pool\", dsname));\n\t} else if (error == EIO) {\n\t\treturn (luaL_error(state, \"I/O error opening dataset '%s'\",\n\t\t    dsname));\n\t} else if (error != 0) {\n\t\treturn (luaL_error(state, \"unexpected error %d\", error));\n\t}\n\n\treturn (1);\n}\n\n \nstatic void *\nzcp_lua_alloc(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n\tzcp_alloc_arg_t *allocargs = ud;\n\n\tif (nsize == 0) {\n\t\tif (ptr != NULL) {\n\t\t\tint64_t *allocbuf = (int64_t *)ptr - 1;\n\t\t\tint64_t allocsize = *allocbuf;\n\t\t\tASSERT3S(allocsize, >, 0);\n\t\t\tASSERT3S(allocargs->aa_alloc_remaining + allocsize, <=,\n\t\t\t    allocargs->aa_alloc_limit);\n\t\t\tallocargs->aa_alloc_remaining += allocsize;\n\t\t\tvmem_free(allocbuf, allocsize);\n\t\t}\n\t\treturn (NULL);\n\t} else if (ptr == NULL) {\n\t\tint64_t *allocbuf;\n\t\tint64_t allocsize = nsize + sizeof (int64_t);\n\n\t\tif (!allocargs->aa_must_succeed &&\n\t\t    (allocsize <= 0 ||\n\t\t    allocsize > allocargs->aa_alloc_remaining)) {\n\t\t\treturn (NULL);\n\t\t}\n\n\t\tallocbuf = vmem_alloc(allocsize, KM_SLEEP);\n\t\tallocargs->aa_alloc_remaining -= allocsize;\n\n\t\t*allocbuf = allocsize;\n\t\treturn (allocbuf + 1);\n\t} else if (nsize <= osize) {\n\t\t \n\t\treturn (ptr);\n\t} else {\n\t\tASSERT3U(nsize, >, osize);\n\n\t\tuint64_t *luabuf = zcp_lua_alloc(ud, NULL, 0, nsize);\n\t\tif (luabuf == NULL) {\n\t\t\treturn (NULL);\n\t\t}\n\t\t(void) memcpy(luabuf, ptr, osize);\n\t\tVERIFY3P(zcp_lua_alloc(ud, ptr, osize, 0), ==, NULL);\n\t\treturn (luabuf);\n\t}\n}\n\nstatic void\nzcp_lua_counthook(lua_State *state, lua_Debug *ar)\n{\n\t(void) ar;\n\tlua_getfield(state, LUA_REGISTRYINDEX, ZCP_RUN_INFO_KEY);\n\tzcp_run_info_t *ri = lua_touserdata(state, -1);\n\n\t \n\tif (ri->zri_canceled ||\n\t    (!ri->zri_sync && issig(JUSTLOOKING) && issig(FORREAL))) {\n\t\tri->zri_canceled = B_TRUE;\n\t\t(void) lua_pushstring(state, \"Channel program was canceled.\");\n\t\t(void) lua_error(state);\n\t\t \n\t}\n\n\t \n\tri->zri_curinstrs += zfs_lua_check_instrlimit_interval;\n\tif (ri->zri_maxinstrs != 0 && ri->zri_curinstrs > ri->zri_maxinstrs) {\n\t\tri->zri_timed_out = B_TRUE;\n\t\t(void) lua_pushstring(state,\n\t\t    \"Channel program timed out.\");\n\t\t(void) lua_error(state);\n\t\t \n\t}\n}\n\nstatic int\nzcp_panic_cb(lua_State *state)\n{\n\tpanic(\"unprotected error in call to Lua API (%s)\\n\",\n\t    lua_tostring(state, -1));\n\treturn (0);\n}\n\nstatic void\nzcp_eval_impl(dmu_tx_t *tx, zcp_run_info_t *ri)\n{\n\tint err;\n\tlua_State *state = ri->zri_state;\n\n\tVERIFY3U(3, ==, lua_gettop(state));\n\n\t \n\tri->zri_pool = dmu_tx_pool(tx);\n\tri->zri_tx = tx;\n\tlist_create(&ri->zri_cleanup_handlers, sizeof (zcp_cleanup_handler_t),\n\t    offsetof(zcp_cleanup_handler_t, zch_node));\n\n\t \n\tlua_pushlightuserdata(state, ri);\n\tlua_setfield(state, LUA_REGISTRYINDEX, ZCP_RUN_INFO_KEY);\n\tVERIFY3U(3, ==, lua_gettop(state));\n\n\t \n\t(void) lua_sethook(state, zcp_lua_counthook, LUA_MASKCOUNT,\n\t    zfs_lua_check_instrlimit_interval);\n\n\t \n\tri->zri_allocargs->aa_must_succeed = B_FALSE;\n\n\t \n\terr = lua_pcall(state, 1, LUA_MULTRET, 1);\n\n\t \n\tri->zri_allocargs->aa_must_succeed = B_TRUE;\n\n\t \n\tlist_destroy(&ri->zri_cleanup_handlers);\n\tlua_remove(state, 1);\n\n\tswitch (err) {\n\tcase LUA_OK: {\n\t\t \n\t\tint return_count = lua_gettop(state);\n\n\t\tif (return_count == 1) {\n\t\t\tri->zri_result = 0;\n\t\t\tzcp_convert_return_values(state, ri->zri_outnvl,\n\t\t\t    ZCP_RET_RETURN, &ri->zri_result);\n\t\t} else if (return_count > 1) {\n\t\t\tri->zri_result = SET_ERROR(ECHRNG);\n\t\t\tlua_settop(state, 0);\n\t\t\t(void) lua_pushfstring(state, \"Multiple return \"\n\t\t\t    \"values not supported\");\n\t\t\tzcp_convert_return_values(state, ri->zri_outnvl,\n\t\t\t    ZCP_RET_ERROR, &ri->zri_result);\n\t\t}\n\t\tbreak;\n\t}\n\tcase LUA_ERRRUN:\n\tcase LUA_ERRGCMM: {\n\t\t \n\t\tVERIFY3U(1, ==, lua_gettop(state));\n\t\tif (ri->zri_timed_out) {\n\t\t\tri->zri_result = SET_ERROR(ETIME);\n\t\t} else if (ri->zri_canceled) {\n\t\t\tri->zri_result = SET_ERROR(EINTR);\n\t\t} else {\n\t\t\tri->zri_result = SET_ERROR(ECHRNG);\n\t\t}\n\n\t\tzcp_convert_return_values(state, ri->zri_outnvl,\n\t\t    ZCP_RET_ERROR, &ri->zri_result);\n\n\t\tif (ri->zri_result == ETIME && ri->zri_outnvl != NULL) {\n\t\t\t(void) nvlist_add_uint64(ri->zri_outnvl,\n\t\t\t    ZCP_ARG_INSTRLIMIT, ri->zri_curinstrs);\n\t\t}\n\t\tbreak;\n\t}\n\tcase LUA_ERRERR: {\n\t\t \n\t\tVERIFY3U(1, ==, lua_gettop(state));\n\t\tif (ri->zri_timed_out) {\n\t\t\tri->zri_result = SET_ERROR(ETIME);\n\t\t} else if (ri->zri_canceled) {\n\t\t\tri->zri_result = SET_ERROR(EINTR);\n\t\t} else {\n\t\t\tri->zri_result = SET_ERROR(ECHRNG);\n\t\t}\n\n\t\tzcp_convert_return_values(state, ri->zri_outnvl,\n\t\t    ZCP_RET_ERROR, &ri->zri_result);\n\t\tbreak;\n\t}\n\tcase LUA_ERRMEM:\n\t\t \n\t\tri->zri_result = SET_ERROR(ENOSPC);\n\t\tbreak;\n\tdefault:\n\t\tVERIFY0(err);\n\t}\n}\n\nstatic void\nzcp_pool_error(zcp_run_info_t *ri, const char *poolname, int error)\n{\n\tri->zri_result = SET_ERROR(ECHRNG);\n\tlua_settop(ri->zri_state, 0);\n\t(void) lua_pushfstring(ri->zri_state, \"Could not open pool: %s \"\n\t    \"errno: %d\", poolname, error);\n\tzcp_convert_return_values(ri->zri_state, ri->zri_outnvl,\n\t    ZCP_RET_ERROR, &ri->zri_result);\n\n}\n\n \nstatic void\nzcp_eval_sig(void *arg, dmu_tx_t *tx)\n{\n\t(void) tx;\n\tzcp_run_info_t *ri = arg;\n\n\tri->zri_canceled = B_TRUE;\n}\n\nstatic void\nzcp_eval_sync(void *arg, dmu_tx_t *tx)\n{\n\tzcp_run_info_t *ri = arg;\n\n\t \n\tVERIFY3U(3, ==, lua_gettop(ri->zri_state));\n\n\tzcp_eval_impl(tx, ri);\n}\n\nstatic void\nzcp_eval_open(zcp_run_info_t *ri, const char *poolname)\n{\n\tint error;\n\tdsl_pool_t *dp;\n\tdmu_tx_t *tx;\n\n\t \n\tVERIFY3U(3, ==, lua_gettop(ri->zri_state));\n\n\terror = dsl_pool_hold(poolname, FTAG, &dp);\n\tif (error != 0) {\n\t\tzcp_pool_error(ri, poolname, error);\n\t\treturn;\n\t}\n\n\t \n\ttx = dmu_tx_create_dd(dp->dp_mos_dir);\n\n\tzcp_eval_impl(tx, ri);\n\n\tdmu_tx_abort(tx);\n\n\tdsl_pool_rele(dp, FTAG);\n}\n\nint\nzcp_eval(const char *poolname, const char *program, boolean_t sync,\n    uint64_t instrlimit, uint64_t memlimit, nvpair_t *nvarg, nvlist_t *outnvl)\n{\n\tint err;\n\tlua_State *state;\n\tzcp_run_info_t runinfo;\n\n\tif (instrlimit > zfs_lua_max_instrlimit)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (memlimit == 0 || memlimit > zfs_lua_max_memlimit)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzcp_alloc_arg_t allocargs = {\n\t\t.aa_must_succeed = B_TRUE,\n\t\t.aa_alloc_remaining = (int64_t)memlimit,\n\t\t.aa_alloc_limit = (int64_t)memlimit,\n\t};\n\n\t \n\tstate = lua_newstate(zcp_lua_alloc, &allocargs);\n\tVERIFY(state != NULL);\n\t(void) lua_atpanic(state, zcp_panic_cb);\n\n\t \n\tVERIFY3U(1, ==, luaopen_base(state));\n\tlua_pop(state, 1);\n\tVERIFY3U(1, ==, luaopen_coroutine(state));\n\tlua_setglobal(state, LUA_COLIBNAME);\n\tVERIFY0(lua_gettop(state));\n\tVERIFY3U(1, ==, luaopen_string(state));\n\tlua_setglobal(state, LUA_STRLIBNAME);\n\tVERIFY0(lua_gettop(state));\n\tVERIFY3U(1, ==, luaopen_table(state));\n\tlua_setglobal(state, LUA_TABLIBNAME);\n\tVERIFY0(lua_gettop(state));\n\n\t \n\tzcp_load_globals(state);\n\tVERIFY0(lua_gettop(state));\n\n\t \n\tlua_newtable(state);\n\tVERIFY3U(1, ==, zcp_load_list_lib(state));\n\tlua_setfield(state, -2, \"list\");\n\tVERIFY3U(1, ==, zcp_load_synctask_lib(state, B_FALSE));\n\tlua_setfield(state, -2, \"check\");\n\tVERIFY3U(1, ==, zcp_load_synctask_lib(state, B_TRUE));\n\tlua_setfield(state, -2, \"sync\");\n\tVERIFY3U(1, ==, zcp_load_get_lib(state));\n\tlua_pushcclosure(state, zcp_debug_info.func, 0);\n\tlua_setfield(state, -2, zcp_debug_info.name);\n\tlua_pushcclosure(state, zcp_exists_info.func, 0);\n\tlua_setfield(state, -2, zcp_exists_info.name);\n\tlua_setglobal(state, \"zfs\");\n\tVERIFY0(lua_gettop(state));\n\n\t \n\tlua_pushcfunction(state, zcp_error_handler);\n\tVERIFY3U(1, ==, lua_gettop(state));\n\n\t \n\terr = luaL_loadbufferx(state, program, strlen(program),\n\t    \"channel program\", \"t\");\n\tif (err == LUA_ERRSYNTAX) {\n\t\tfnvlist_add_string(outnvl, ZCP_RET_ERROR,\n\t\t    lua_tostring(state, -1));\n\t\tlua_close(state);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tVERIFY0(err);\n\tVERIFY3U(2, ==, lua_gettop(state));\n\n\t \n\tchar errmsg[128];\n\terr = zcp_nvpair_value_to_lua(state, nvarg,\n\t    errmsg, sizeof (errmsg));\n\tif (err != 0) {\n\t\tfnvlist_add_string(outnvl, ZCP_RET_ERROR, errmsg);\n\t\tlua_close(state);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tVERIFY3U(3, ==, lua_gettop(state));\n\n\truninfo.zri_state = state;\n\truninfo.zri_allocargs = &allocargs;\n\truninfo.zri_outnvl = outnvl;\n\truninfo.zri_result = 0;\n\truninfo.zri_cred = CRED();\n\truninfo.zri_proc = curproc;\n\truninfo.zri_timed_out = B_FALSE;\n\truninfo.zri_canceled = B_FALSE;\n\truninfo.zri_sync = sync;\n\truninfo.zri_space_used = 0;\n\truninfo.zri_curinstrs = 0;\n\truninfo.zri_maxinstrs = instrlimit;\n\truninfo.zri_new_zvols = fnvlist_alloc();\n\n\tif (sync) {\n\t\terr = dsl_sync_task_sig(poolname, NULL, zcp_eval_sync,\n\t\t    zcp_eval_sig, &runinfo, 0, ZFS_SPACE_CHECK_ZCP_EVAL);\n\t\tif (err != 0)\n\t\t\tzcp_pool_error(&runinfo, poolname, err);\n\t} else {\n\t\tzcp_eval_open(&runinfo, poolname);\n\t}\n\tlua_close(state);\n\n\t \n\tfor (nvpair_t *pair = nvlist_next_nvpair(runinfo.zri_new_zvols, NULL);\n\t    pair != NULL;\n\t    pair = nvlist_next_nvpair(runinfo.zri_new_zvols, pair)) {\n\t\tzvol_create_minor(nvpair_name(pair));\n\t}\n\tfnvlist_free(runinfo.zri_new_zvols);\n\n\treturn (runinfo.zri_result);\n}\n\n \nzcp_run_info_t *\nzcp_run_info(lua_State *state)\n{\n\tzcp_run_info_t *ri;\n\n\tlua_getfield(state, LUA_REGISTRYINDEX, ZCP_RUN_INFO_KEY);\n\tri = lua_touserdata(state, -1);\n\tlua_pop(state, 1);\n\treturn (ri);\n}\n\n \n\n \nstatic void\nzcp_args_error(lua_State *state, const char *fname, const zcp_arg_t *pargs,\n    const zcp_arg_t *kwargs, const char *fmt, ...)\n{\n\tint i;\n\tchar errmsg[512];\n\tsize_t len = sizeof (errmsg);\n\tsize_t msglen = 0;\n\tva_list argp;\n\n\tva_start(argp, fmt);\n\tVERIFY3U(len, >, vsnprintf(errmsg, len, fmt, argp));\n\tva_end(argp);\n\n\t \n\tmsglen = strlen(errmsg);\n\tmsglen += strlen(fname) + 4;  \n\tfor (i = 0; pargs[i].za_name != NULL; i++) {\n\t\tmsglen += strlen(pargs[i].za_name);\n\t\tmsglen += strlen(lua_typename(state, pargs[i].za_lua_type));\n\t\tif (pargs[i + 1].za_name != NULL || kwargs[0].za_name != NULL)\n\t\t\tmsglen += 5;  \n\t\telse\n\t\t\tmsglen += 4;  \n\t}\n\tfor (i = 0; kwargs[i].za_name != NULL; i++) {\n\t\tmsglen += strlen(kwargs[i].za_name);\n\t\tmsglen += strlen(lua_typename(state, kwargs[i].za_lua_type));\n\t\tif (kwargs[i + 1].za_name != NULL)\n\t\t\tmsglen += 4;  \n\t\telse\n\t\t\tmsglen += 3;  \n\t}\n\n\tif (msglen >= len)\n\t\t(void) luaL_error(state, errmsg);\n\n\tVERIFY3U(len, >, strlcat(errmsg, \": \", len));\n\tVERIFY3U(len, >, strlcat(errmsg, fname, len));\n\tVERIFY3U(len, >, strlcat(errmsg, \"{\", len));\n\tfor (i = 0; pargs[i].za_name != NULL; i++) {\n\t\tVERIFY3U(len, >, strlcat(errmsg, \"<\", len));\n\t\tVERIFY3U(len, >, strlcat(errmsg, pargs[i].za_name, len));\n\t\tVERIFY3U(len, >, strlcat(errmsg, \"(\", len));\n\t\tVERIFY3U(len, >, strlcat(errmsg,\n\t\t    lua_typename(state, pargs[i].za_lua_type), len));\n\t\tVERIFY3U(len, >, strlcat(errmsg, \")>\", len));\n\t\tif (pargs[i + 1].za_name != NULL || kwargs[0].za_name != NULL) {\n\t\t\tVERIFY3U(len, >, strlcat(errmsg, \", \", len));\n\t\t}\n\t}\n\tfor (i = 0; kwargs[i].za_name != NULL; i++) {\n\t\tVERIFY3U(len, >, strlcat(errmsg, kwargs[i].za_name, len));\n\t\tVERIFY3U(len, >, strlcat(errmsg, \"=(\", len));\n\t\tVERIFY3U(len, >, strlcat(errmsg,\n\t\t    lua_typename(state, kwargs[i].za_lua_type), len));\n\t\tVERIFY3U(len, >, strlcat(errmsg, \")\", len));\n\t\tif (kwargs[i + 1].za_name != NULL) {\n\t\t\tVERIFY3U(len, >, strlcat(errmsg, \", \", len));\n\t\t}\n\t}\n\tVERIFY3U(len, >, strlcat(errmsg, \"}\", len));\n\n\t(void) luaL_error(state, errmsg);\n\tpanic(\"unreachable code\");\n}\n\nstatic void\nzcp_parse_table_args(lua_State *state, const char *fname,\n    const zcp_arg_t *pargs, const zcp_arg_t *kwargs)\n{\n\tint i;\n\tint type;\n\n\tfor (i = 0; pargs[i].za_name != NULL; i++) {\n\t\t \n\t\tlua_pushinteger(state, i + 1);\n\t\tlua_gettable(state, 1);\n\n\t\ttype = lua_type(state, -1);\n\t\tif (type == LUA_TNIL) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"too few arguments\");\n\t\t\tpanic(\"unreachable code\");\n\t\t} else if (type != pargs[i].za_lua_type) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"arg %d wrong type (is '%s', expected '%s')\",\n\t\t\t    i + 1, lua_typename(state, type),\n\t\t\t    lua_typename(state, pargs[i].za_lua_type));\n\t\t\tpanic(\"unreachable code\");\n\t\t}\n\n\t\t \n\t\tlua_pushinteger(state, i + 1);\n\t\tlua_pushnil(state);\n\t\tlua_settable(state, 1);\n\t}\n\n\tfor (i = 0; kwargs[i].za_name != NULL; i++) {\n\t\t \n\t\tlua_getfield(state, 1, kwargs[i].za_name);\n\n\t\ttype = lua_type(state, -1);\n\t\tif (type != LUA_TNIL && type != kwargs[i].za_lua_type) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"kwarg '%s' wrong type (is '%s', expected '%s')\",\n\t\t\t    kwargs[i].za_name, lua_typename(state, type),\n\t\t\t    lua_typename(state, kwargs[i].za_lua_type));\n\t\t\tpanic(\"unreachable code\");\n\t\t}\n\n\t\t \n\t\tlua_pushnil(state);\n\t\tlua_setfield(state, 1, kwargs[i].za_name);\n\t}\n\n\t \n\tlua_pushnil(state);\n\tif (lua_next(state, 1)) {\n\t\tif (lua_isnumber(state, -2) && lua_tointeger(state, -2) > 0) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"too many positional arguments\");\n\t\t} else if (lua_isstring(state, -2)) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"invalid kwarg '%s'\", lua_tostring(state, -2));\n\t\t} else {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"kwarg keys must be strings\");\n\t\t}\n\t\tpanic(\"unreachable code\");\n\t}\n\n\tlua_remove(state, 1);\n}\n\nstatic void\nzcp_parse_pos_args(lua_State *state, const char *fname, const zcp_arg_t *pargs,\n    const zcp_arg_t *kwargs)\n{\n\tint i;\n\tint type;\n\n\tfor (i = 0; pargs[i].za_name != NULL; i++) {\n\t\ttype = lua_type(state, i + 1);\n\t\tif (type == LUA_TNONE) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"too few arguments\");\n\t\t\tpanic(\"unreachable code\");\n\t\t} else if (type != pargs[i].za_lua_type) {\n\t\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t\t    \"arg %d wrong type (is '%s', expected '%s')\",\n\t\t\t    i + 1, lua_typename(state, type),\n\t\t\t    lua_typename(state, pargs[i].za_lua_type));\n\t\t\tpanic(\"unreachable code\");\n\t\t}\n\t}\n\tif (lua_gettop(state) != i) {\n\t\tzcp_args_error(state, fname, pargs, kwargs,\n\t\t    \"too many positional arguments\");\n\t\tpanic(\"unreachable code\");\n\t}\n\n\tfor (i = 0; kwargs[i].za_name != NULL; i++) {\n\t\tlua_pushnil(state);\n\t}\n}\n\n \nvoid\nzcp_parse_args(lua_State *state, const char *fname, const zcp_arg_t *pargs,\n    const zcp_arg_t *kwargs)\n{\n\tif (lua_gettop(state) == 1 && lua_istable(state, 1)) {\n\t\tzcp_parse_table_args(state, fname, pargs, kwargs);\n\t} else {\n\t\tzcp_parse_pos_args(state, fname, pargs, kwargs);\n\t}\n}\n\nZFS_MODULE_PARAM(zfs_lua, zfs_lua_, max_instrlimit, U64, ZMOD_RW,\n\t\"Max instruction limit that can be specified for a channel program\");\n\nZFS_MODULE_PARAM(zfs_lua, zfs_lua_, max_memlimit, U64, ZMOD_RW,\n\t\"Max memory limit that can be specified for a channel program\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}