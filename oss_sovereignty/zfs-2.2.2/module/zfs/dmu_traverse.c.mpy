{
  "module_name": "dmu_traverse.c",
  "hash_id": "b5d89aeaa4d4d9f1d1815df6bded38b0bba31c00836fdb2003a3ff0ff24307e4",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu_traverse.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dnode.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zio.h>\n#include <sys/dmu_impl.h>\n#include <sys/sa.h>\n#include <sys/sa_impl.h>\n#include <sys/callb.h>\n#include <sys/zfeature.h>\n\nstatic int32_t zfs_pd_bytes_max = 50 * 1024 * 1024;\t \nstatic int32_t send_holes_without_birth_time = 1;\nstatic uint_t zfs_traverse_indirect_prefetch_limit = 32;\n\ntypedef struct prefetch_data {\n\tkmutex_t pd_mtx;\n\tkcondvar_t pd_cv;\n\tint32_t pd_bytes_fetched;\n\tint pd_flags;\n\tboolean_t pd_cancel;\n\tboolean_t pd_exited;\n\tzbookmark_phys_t pd_resume;\n} prefetch_data_t;\n\ntypedef struct traverse_data {\n\tspa_t *td_spa;\n\tuint64_t td_objset;\n\tblkptr_t *td_rootbp;\n\tuint64_t td_min_txg;\n\tzbookmark_phys_t *td_resume;\n\tint td_flags;\n\tprefetch_data_t *td_pfd;\n\tboolean_t td_paused;\n\tuint64_t td_hole_birth_enabled_txg;\n\tblkptr_cb_t *td_func;\n\tvoid *td_arg;\n\tboolean_t td_realloc_possible;\n} traverse_data_t;\n\nstatic int traverse_dnode(traverse_data_t *td, const blkptr_t *bp,\n    const dnode_phys_t *dnp, uint64_t objset, uint64_t object);\nstatic void prefetch_dnode_metadata(traverse_data_t *td, const dnode_phys_t *,\n    uint64_t objset, uint64_t object);\n\nstatic int\ntraverse_zil_block(zilog_t *zilog, const blkptr_t *bp, void *arg,\n    uint64_t claim_txg)\n{\n\ttraverse_data_t *td = arg;\n\tzbookmark_phys_t zb;\n\n\tif (BP_IS_HOLE(bp))\n\t\treturn (0);\n\n\tif (claim_txg == 0 && bp->blk_birth >= spa_min_claim_txg(td->td_spa))\n\t\treturn (-1);\n\n\tSET_BOOKMARK(&zb, td->td_objset, ZB_ZIL_OBJECT, ZB_ZIL_LEVEL,\n\t    bp->blk_cksum.zc_word[ZIL_ZC_SEQ]);\n\n\t(void) td->td_func(td->td_spa, zilog, bp, &zb, NULL, td->td_arg);\n\n\treturn (0);\n}\n\nstatic int\ntraverse_zil_record(zilog_t *zilog, const lr_t *lrc, void *arg,\n    uint64_t claim_txg)\n{\n\ttraverse_data_t *td = arg;\n\n\tif (lrc->lrc_txtype == TX_WRITE) {\n\t\tlr_write_t *lr = (lr_write_t *)lrc;\n\t\tblkptr_t *bp = &lr->lr_blkptr;\n\t\tzbookmark_phys_t zb;\n\n\t\tif (BP_IS_HOLE(bp))\n\t\t\treturn (0);\n\n\t\tif (claim_txg == 0 || bp->blk_birth < claim_txg)\n\t\t\treturn (0);\n\n\t\tASSERT3U(BP_GET_LSIZE(bp), !=, 0);\n\t\tSET_BOOKMARK(&zb, td->td_objset, lr->lr_foid,\n\t\t    ZB_ZIL_LEVEL, lr->lr_offset / BP_GET_LSIZE(bp));\n\n\t\t(void) td->td_func(td->td_spa, zilog, bp, &zb, NULL,\n\t\t    td->td_arg);\n\t}\n\treturn (0);\n}\n\nstatic void\ntraverse_zil(traverse_data_t *td, zil_header_t *zh)\n{\n\tuint64_t claim_txg = zh->zh_claim_txg;\n\n\t \n\tif (claim_txg == 0 && spa_writeable(td->td_spa))\n\t\treturn;\n\n\tzilog_t *zilog = zil_alloc(spa_get_dsl(td->td_spa)->dp_meta_objset, zh);\n\t(void) zil_parse(zilog, traverse_zil_block, traverse_zil_record, td,\n\t    claim_txg, !(td->td_flags & TRAVERSE_NO_DECRYPT));\n\tzil_free(zilog);\n}\n\ntypedef enum resume_skip {\n\tRESUME_SKIP_ALL,\n\tRESUME_SKIP_NONE,\n\tRESUME_SKIP_CHILDREN\n} resume_skip_t;\n\n \nstatic resume_skip_t\nresume_skip_check(const traverse_data_t *td, const dnode_phys_t *dnp,\n    const zbookmark_phys_t *zb)\n{\n\tif (td->td_resume != NULL) {\n\t\t \n\t\tif (zbookmark_subtree_completed(dnp, zb, td->td_resume))\n\t\t\treturn (RESUME_SKIP_ALL);\n\n\t\tif (memcmp(zb, td->td_resume, sizeof (*zb)) == 0) {\n\t\t\tif (td->td_flags & TRAVERSE_POST)\n\t\t\t\treturn (RESUME_SKIP_CHILDREN);\n\t\t}\n\t}\n\treturn (RESUME_SKIP_NONE);\n}\n\n \nstatic boolean_t\ntraverse_prefetch_metadata(traverse_data_t *td, const dnode_phys_t *dnp,\n    const blkptr_t *bp, const zbookmark_phys_t *zb)\n{\n\tarc_flags_t flags = ARC_FLAG_NOWAIT | ARC_FLAG_PREFETCH |\n\t    ARC_FLAG_PRESCIENT_PREFETCH;\n\tint zio_flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_SPECULATIVE;\n\n\tif (!(td->td_flags & TRAVERSE_PREFETCH_METADATA))\n\t\treturn (B_FALSE);\n\t \n\tif (resume_skip_check(td, dnp, zb) != RESUME_SKIP_NONE)\n\t\treturn (B_FALSE);\n\tif (BP_IS_HOLE(bp) || bp->blk_birth <= td->td_min_txg)\n\t\treturn (B_FALSE);\n\tif (BP_GET_LEVEL(bp) == 0 && BP_GET_TYPE(bp) != DMU_OT_DNODE)\n\t\treturn (B_FALSE);\n\tASSERT(!BP_IS_REDACTED(bp));\n\n\tif ((td->td_flags & TRAVERSE_NO_DECRYPT) && BP_IS_PROTECTED(bp))\n\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t(void) arc_read(NULL, td->td_spa, bp, NULL, NULL,\n\t    ZIO_PRIORITY_ASYNC_READ, zio_flags, &flags, zb);\n\treturn (B_TRUE);\n}\n\nstatic boolean_t\nprefetch_needed(prefetch_data_t *pfd, const blkptr_t *bp)\n{\n\tASSERT(pfd->pd_flags & TRAVERSE_PREFETCH_DATA);\n\tif (BP_IS_HOLE(bp) || BP_IS_EMBEDDED(bp) ||\n\t    BP_GET_TYPE(bp) == DMU_OT_INTENT_LOG || BP_IS_REDACTED(bp))\n\t\treturn (B_FALSE);\n\treturn (B_TRUE);\n}\n\nstatic int\ntraverse_visitbp(traverse_data_t *td, const dnode_phys_t *dnp,\n    const blkptr_t *bp, const zbookmark_phys_t *zb)\n{\n\tint err = 0;\n\tarc_buf_t *buf = NULL;\n\tprefetch_data_t *pd = td->td_pfd;\n\n\tswitch (resume_skip_check(td, dnp, zb)) {\n\tcase RESUME_SKIP_ALL:\n\t\treturn (0);\n\tcase RESUME_SKIP_CHILDREN:\n\t\tgoto post;\n\tcase RESUME_SKIP_NONE:\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\n\tif (bp->blk_birth == 0) {\n\t\t \n\t\tif (!send_holes_without_birth_time &&\n\t\t    (!td->td_realloc_possible ||\n\t\t    zb->zb_object == DMU_META_DNODE_OBJECT) &&\n\t\t    td->td_hole_birth_enabled_txg <= td->td_min_txg)\n\t\t\treturn (0);\n\t} else if (bp->blk_birth <= td->td_min_txg) {\n\t\treturn (0);\n\t}\n\n\tif (pd != NULL && !pd->pd_exited && prefetch_needed(pd, bp)) {\n\t\tuint64_t size = BP_GET_LSIZE(bp);\n\t\tmutex_enter(&pd->pd_mtx);\n\t\tASSERT(pd->pd_bytes_fetched >= 0);\n\t\twhile (pd->pd_bytes_fetched < size && !pd->pd_exited)\n\t\t\tcv_wait_sig(&pd->pd_cv, &pd->pd_mtx);\n\t\tpd->pd_bytes_fetched -= size;\n\t\tcv_broadcast(&pd->pd_cv);\n\t\tmutex_exit(&pd->pd_mtx);\n\t}\n\n\tif (BP_IS_HOLE(bp) || BP_IS_REDACTED(bp)) {\n\t\terr = td->td_func(td->td_spa, NULL, bp, zb, dnp, td->td_arg);\n\t\tif (err != 0)\n\t\t\tgoto post;\n\t\treturn (0);\n\t}\n\n\tif (td->td_flags & TRAVERSE_PRE) {\n\t\terr = td->td_func(td->td_spa, NULL, bp, zb, dnp,\n\t\t    td->td_arg);\n\t\tif (err == TRAVERSE_VISIT_NO_CHILDREN)\n\t\t\treturn (0);\n\t\tif (err != 0)\n\t\t\tgoto post;\n\t}\n\n\tif (BP_GET_LEVEL(bp) > 0) {\n\t\tuint32_t flags = ARC_FLAG_WAIT;\n\t\tint32_t i, ptidx, pidx;\n\t\tuint32_t prefetchlimit;\n\t\tint32_t epb = BP_GET_LSIZE(bp) >> SPA_BLKPTRSHIFT;\n\t\tzbookmark_phys_t *czb;\n\n\t\tASSERT(!BP_IS_PROTECTED(bp));\n\n\t\terr = arc_read(NULL, td->td_spa, bp, arc_getbuf_func, &buf,\n\t\t    ZIO_PRIORITY_ASYNC_READ, ZIO_FLAG_CANFAIL, &flags, zb);\n\t\tif (err != 0)\n\t\t\tgoto post;\n\n\t\tczb = kmem_alloc(sizeof (zbookmark_phys_t), KM_SLEEP);\n\n\t\t \n\t\tptidx = 0;\n\t\tpidx = 1;\n\t\tprefetchlimit = zfs_traverse_indirect_prefetch_limit;\n\t\tfor (i = 0; i < epb; i++) {\n\t\t\tif (prefetchlimit && i == ptidx) {\n\t\t\t\tASSERT3S(ptidx, <=, pidx);\n\t\t\t\tfor (uint32_t  prefetched = 0; pidx < epb &&\n\t\t\t\t    prefetched < prefetchlimit; pidx++) {\n\t\t\t\t\tSET_BOOKMARK(czb, zb->zb_objset,\n\t\t\t\t\t    zb->zb_object, zb->zb_level - 1,\n\t\t\t\t\t    zb->zb_blkid * epb + pidx);\n\t\t\t\t\tif (traverse_prefetch_metadata(td, dnp,\n\t\t\t\t\t    &((blkptr_t *)buf->b_data)[pidx],\n\t\t\t\t\t    czb) == B_TRUE) {\n\t\t\t\t\t\tprefetched++;\n\t\t\t\t\t\tif (prefetched ==\n\t\t\t\t\t\t    MAX(prefetchlimit / 2, 1))\n\t\t\t\t\t\t\tptidx = pidx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tSET_BOOKMARK(czb, zb->zb_objset, zb->zb_object,\n\t\t\t    zb->zb_level - 1,\n\t\t\t    zb->zb_blkid * epb + i);\n\t\t\terr = traverse_visitbp(td, dnp,\n\t\t\t    &((blkptr_t *)buf->b_data)[i], czb);\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tkmem_free(czb, sizeof (zbookmark_phys_t));\n\n\t} else if (BP_GET_TYPE(bp) == DMU_OT_DNODE) {\n\t\tuint32_t flags = ARC_FLAG_WAIT;\n\t\tuint32_t zio_flags = ZIO_FLAG_CANFAIL;\n\t\tint32_t i;\n\t\tint32_t epb = BP_GET_LSIZE(bp) >> DNODE_SHIFT;\n\t\tdnode_phys_t *child_dnp;\n\n\t\t \n\t\tif ((td->td_flags & TRAVERSE_NO_DECRYPT) && BP_IS_PROTECTED(bp))\n\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t\terr = arc_read(NULL, td->td_spa, bp, arc_getbuf_func, &buf,\n\t\t    ZIO_PRIORITY_ASYNC_READ, zio_flags, &flags, zb);\n\t\tif (err != 0)\n\t\t\tgoto post;\n\n\t\tchild_dnp = buf->b_data;\n\n\t\tfor (i = 0; i < epb; i += child_dnp[i].dn_extra_slots + 1) {\n\t\t\tprefetch_dnode_metadata(td, &child_dnp[i],\n\t\t\t    zb->zb_objset, zb->zb_blkid * epb + i);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < epb; i += child_dnp[i].dn_extra_slots + 1) {\n\t\t\terr = traverse_dnode(td, bp, &child_dnp[i],\n\t\t\t    zb->zb_objset, zb->zb_blkid * epb + i);\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (BP_GET_TYPE(bp) == DMU_OT_OBJSET) {\n\t\tuint32_t zio_flags = ZIO_FLAG_CANFAIL;\n\t\tarc_flags_t flags = ARC_FLAG_WAIT;\n\t\tobjset_phys_t *osp;\n\n\t\tif ((td->td_flags & TRAVERSE_NO_DECRYPT) && BP_IS_PROTECTED(bp))\n\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t\terr = arc_read(NULL, td->td_spa, bp, arc_getbuf_func, &buf,\n\t\t    ZIO_PRIORITY_ASYNC_READ, zio_flags, &flags, zb);\n\t\tif (err != 0)\n\t\t\tgoto post;\n\n\t\tosp = buf->b_data;\n\t\tprefetch_dnode_metadata(td, &osp->os_meta_dnode, zb->zb_objset,\n\t\t    DMU_META_DNODE_OBJECT);\n\t\t \n\t\tif (osp->os_meta_dnode.dn_maxblkid == 0)\n\t\t\ttd->td_realloc_possible = B_FALSE;\n\n\t\tif (OBJSET_BUF_HAS_USERUSED(buf)) {\n\t\t\tif (OBJSET_BUF_HAS_PROJECTUSED(buf))\n\t\t\t\tprefetch_dnode_metadata(td,\n\t\t\t\t    &osp->os_projectused_dnode,\n\t\t\t\t    zb->zb_objset, DMU_PROJECTUSED_OBJECT);\n\t\t\tprefetch_dnode_metadata(td, &osp->os_groupused_dnode,\n\t\t\t    zb->zb_objset, DMU_GROUPUSED_OBJECT);\n\t\t\tprefetch_dnode_metadata(td, &osp->os_userused_dnode,\n\t\t\t    zb->zb_objset, DMU_USERUSED_OBJECT);\n\t\t}\n\n\t\terr = traverse_dnode(td, bp, &osp->os_meta_dnode, zb->zb_objset,\n\t\t    DMU_META_DNODE_OBJECT);\n\t\tif (err == 0 && OBJSET_BUF_HAS_USERUSED(buf)) {\n\t\t\tif (OBJSET_BUF_HAS_PROJECTUSED(buf))\n\t\t\t\terr = traverse_dnode(td, bp,\n\t\t\t\t    &osp->os_projectused_dnode, zb->zb_objset,\n\t\t\t\t    DMU_PROJECTUSED_OBJECT);\n\t\t\tif (err == 0)\n\t\t\t\terr = traverse_dnode(td, bp,\n\t\t\t\t    &osp->os_groupused_dnode, zb->zb_objset,\n\t\t\t\t    DMU_GROUPUSED_OBJECT);\n\t\t\tif (err == 0)\n\t\t\t\terr = traverse_dnode(td, bp,\n\t\t\t\t    &osp->os_userused_dnode, zb->zb_objset,\n\t\t\t\t    DMU_USERUSED_OBJECT);\n\t\t}\n\t}\n\n\tif (buf)\n\t\tarc_buf_destroy(buf, &buf);\n\npost:\n\tif (err == 0 && (td->td_flags & TRAVERSE_POST))\n\t\terr = td->td_func(td->td_spa, NULL, bp, zb, dnp, td->td_arg);\n\n\tif ((td->td_flags & TRAVERSE_HARD) && (err == EIO || err == ECKSUM)) {\n\t\t \n\t\terr = 0;\n\t}\n\n\t \n\tif (td->td_resume != NULL && err != 0 && !td->td_paused) {\n\t\ttd->td_resume->zb_objset = zb->zb_objset;\n\t\ttd->td_resume->zb_object = zb->zb_object;\n\t\ttd->td_resume->zb_level = 0;\n\t\t \n\t\ttd->td_resume->zb_blkid = zb->zb_blkid;\n\t\tif (zb->zb_level > 0) {\n\t\t\ttd->td_resume->zb_blkid <<= zb->zb_level *\n\t\t\t    (dnp->dn_indblkshift - SPA_BLKPTRSHIFT);\n\t\t}\n\t\ttd->td_paused = B_TRUE;\n\t}\n\n\treturn (err);\n}\n\nstatic void\nprefetch_dnode_metadata(traverse_data_t *td, const dnode_phys_t *dnp,\n    uint64_t objset, uint64_t object)\n{\n\tint j;\n\tzbookmark_phys_t czb;\n\n\tfor (j = 0; j < dnp->dn_nblkptr; j++) {\n\t\tSET_BOOKMARK(&czb, objset, object, dnp->dn_nlevels - 1, j);\n\t\ttraverse_prefetch_metadata(td, dnp, &dnp->dn_blkptr[j], &czb);\n\t}\n\n\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\tSET_BOOKMARK(&czb, objset, object, 0, DMU_SPILL_BLKID);\n\t\ttraverse_prefetch_metadata(td, dnp, DN_SPILL_BLKPTR(dnp), &czb);\n\t}\n}\n\nstatic int\ntraverse_dnode(traverse_data_t *td, const blkptr_t *bp, const dnode_phys_t *dnp,\n    uint64_t objset, uint64_t object)\n{\n\tint j, err = 0;\n\tzbookmark_phys_t czb;\n\n\tif (object != DMU_META_DNODE_OBJECT && td->td_resume != NULL &&\n\t    object < td->td_resume->zb_object)\n\t\treturn (0);\n\n\tif (td->td_flags & TRAVERSE_PRE) {\n\t\tSET_BOOKMARK(&czb, objset, object, ZB_DNODE_LEVEL,\n\t\t    ZB_DNODE_BLKID);\n\t\terr = td->td_func(td->td_spa, NULL, bp, &czb, dnp,\n\t\t    td->td_arg);\n\t\tif (err == TRAVERSE_VISIT_NO_CHILDREN)\n\t\t\treturn (0);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\n\tfor (j = 0; j < dnp->dn_nblkptr; j++) {\n\t\tSET_BOOKMARK(&czb, objset, object, dnp->dn_nlevels - 1, j);\n\t\terr = traverse_visitbp(td, dnp, &dnp->dn_blkptr[j], &czb);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\n\tif (err == 0 && (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR)) {\n\t\tSET_BOOKMARK(&czb, objset, object, 0, DMU_SPILL_BLKID);\n\t\terr = traverse_visitbp(td, dnp, DN_SPILL_BLKPTR(dnp), &czb);\n\t}\n\n\tif (err == 0 && (td->td_flags & TRAVERSE_POST)) {\n\t\tSET_BOOKMARK(&czb, objset, object, ZB_DNODE_LEVEL,\n\t\t    ZB_DNODE_BLKID);\n\t\terr = td->td_func(td->td_spa, NULL, bp, &czb, dnp,\n\t\t    td->td_arg);\n\t\tif (err == TRAVERSE_VISIT_NO_CHILDREN)\n\t\t\treturn (0);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\t}\n\treturn (err);\n}\n\nstatic int\ntraverse_prefetcher(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)\n{\n\t(void) zilog, (void) dnp;\n\tprefetch_data_t *pfd = arg;\n\tint zio_flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_SPECULATIVE;\n\tarc_flags_t aflags = ARC_FLAG_NOWAIT | ARC_FLAG_PREFETCH |\n\t    ARC_FLAG_PRESCIENT_PREFETCH;\n\n\tASSERT(pfd->pd_bytes_fetched >= 0);\n\tif (zb->zb_level == ZB_DNODE_LEVEL)\n\t\treturn (0);\n\tif (pfd->pd_cancel)\n\t\treturn (SET_ERROR(EINTR));\n\n\tif (!prefetch_needed(pfd, bp))\n\t\treturn (0);\n\n\tmutex_enter(&pfd->pd_mtx);\n\twhile (!pfd->pd_cancel && pfd->pd_bytes_fetched >= zfs_pd_bytes_max)\n\t\tcv_wait_sig(&pfd->pd_cv, &pfd->pd_mtx);\n\tpfd->pd_bytes_fetched += BP_GET_LSIZE(bp);\n\tcv_broadcast(&pfd->pd_cv);\n\tmutex_exit(&pfd->pd_mtx);\n\n\tif ((pfd->pd_flags & TRAVERSE_NO_DECRYPT) && BP_IS_PROTECTED(bp))\n\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t(void) arc_read(NULL, spa, bp, NULL, NULL, ZIO_PRIORITY_ASYNC_READ,\n\t    zio_flags, &aflags, zb);\n\n\treturn (0);\n}\n\nstatic void\ntraverse_prefetch_thread(void *arg)\n{\n\ttraverse_data_t *td_main = arg;\n\ttraverse_data_t td = *td_main;\n\tzbookmark_phys_t czb;\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\n\ttd.td_func = traverse_prefetcher;\n\ttd.td_arg = td_main->td_pfd;\n\ttd.td_pfd = NULL;\n\ttd.td_resume = &td_main->td_pfd->pd_resume;\n\n\tSET_BOOKMARK(&czb, td.td_objset,\n\t    ZB_ROOT_OBJECT, ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\t(void) traverse_visitbp(&td, NULL, td.td_rootbp, &czb);\n\n\tmutex_enter(&td_main->td_pfd->pd_mtx);\n\ttd_main->td_pfd->pd_exited = B_TRUE;\n\tcv_broadcast(&td_main->td_pfd->pd_cv);\n\tmutex_exit(&td_main->td_pfd->pd_mtx);\n\tspl_fstrans_unmark(cookie);\n}\n\n \nstatic int\ntraverse_impl(spa_t *spa, dsl_dataset_t *ds, uint64_t objset, blkptr_t *rootbp,\n    uint64_t txg_start, zbookmark_phys_t *resume, int flags,\n    blkptr_cb_t func, void *arg)\n{\n\ttraverse_data_t *td;\n\tprefetch_data_t *pd;\n\tzbookmark_phys_t *czb;\n\tint err;\n\n\tASSERT(ds == NULL || objset == ds->ds_object);\n\tASSERT(!(flags & TRAVERSE_PRE) || !(flags & TRAVERSE_POST));\n\n\ttd = kmem_alloc(sizeof (traverse_data_t), KM_SLEEP);\n\tpd = kmem_zalloc(sizeof (prefetch_data_t), KM_SLEEP);\n\tczb = kmem_alloc(sizeof (zbookmark_phys_t), KM_SLEEP);\n\n\ttd->td_spa = spa;\n\ttd->td_objset = objset;\n\ttd->td_rootbp = rootbp;\n\ttd->td_min_txg = txg_start;\n\ttd->td_resume = resume;\n\ttd->td_func = func;\n\ttd->td_arg = arg;\n\ttd->td_pfd = pd;\n\ttd->td_flags = flags;\n\ttd->td_paused = B_FALSE;\n\ttd->td_realloc_possible = (txg_start == 0 ? B_FALSE : B_TRUE);\n\n\tif (spa_feature_is_active(spa, SPA_FEATURE_HOLE_BIRTH)) {\n\t\tVERIFY(spa_feature_enabled_txg(spa,\n\t\t    SPA_FEATURE_HOLE_BIRTH, &td->td_hole_birth_enabled_txg));\n\t} else {\n\t\ttd->td_hole_birth_enabled_txg = UINT64_MAX;\n\t}\n\n\tpd->pd_flags = flags;\n\tif (resume != NULL)\n\t\tpd->pd_resume = *resume;\n\tmutex_init(&pd->pd_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&pd->pd_cv, NULL, CV_DEFAULT, NULL);\n\n\tSET_BOOKMARK(czb, td->td_objset,\n\t    ZB_ROOT_OBJECT, ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\n\t \n\tif (ds != NULL && !ds->ds_is_snapshot && !BP_IS_HOLE(rootbp)) {\n\t\tzio_flag_t zio_flags = ZIO_FLAG_CANFAIL;\n\t\tuint32_t flags = ARC_FLAG_WAIT;\n\t\tobjset_phys_t *osp;\n\t\tarc_buf_t *buf;\n\t\tASSERT(!BP_IS_REDACTED(rootbp));\n\n\t\tif ((td->td_flags & TRAVERSE_NO_DECRYPT) &&\n\t\t    BP_IS_PROTECTED(rootbp))\n\t\t\tzio_flags |= ZIO_FLAG_RAW;\n\n\t\terr = arc_read(NULL, td->td_spa, rootbp, arc_getbuf_func,\n\t\t    &buf, ZIO_PRIORITY_ASYNC_READ, zio_flags, &flags, czb);\n\t\tif (err != 0) {\n\t\t\t \n\t\t\tif (!(td->td_flags & TRAVERSE_HARD) ||\n\t\t\t    !(td->td_flags & TRAVERSE_PRE))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tosp = buf->b_data;\n\t\t\ttraverse_zil(td, &osp->os_zil_header);\n\t\t\tarc_buf_destroy(buf, &buf);\n\t\t}\n\t}\n\n\tif (!(flags & TRAVERSE_PREFETCH_DATA) ||\n\t    taskq_dispatch(spa->spa_prefetch_taskq, traverse_prefetch_thread,\n\t    td, TQ_NOQUEUE) == TASKQID_INVALID)\n\t\tpd->pd_exited = B_TRUE;\n\n\terr = traverse_visitbp(td, NULL, rootbp, czb);\n\n\tmutex_enter(&pd->pd_mtx);\n\tpd->pd_cancel = B_TRUE;\n\tcv_broadcast(&pd->pd_cv);\n\twhile (!pd->pd_exited)\n\t\tcv_wait_sig(&pd->pd_cv, &pd->pd_mtx);\n\tmutex_exit(&pd->pd_mtx);\nout:\n\tmutex_destroy(&pd->pd_mtx);\n\tcv_destroy(&pd->pd_cv);\n\n\tkmem_free(czb, sizeof (zbookmark_phys_t));\n\tkmem_free(pd, sizeof (struct prefetch_data));\n\tkmem_free(td, sizeof (struct traverse_data));\n\n\treturn (err);\n}\n\n \nint\ntraverse_dataset_resume(dsl_dataset_t *ds, uint64_t txg_start,\n    zbookmark_phys_t *resume,\n    int flags, blkptr_cb_t func, void *arg)\n{\n\treturn (traverse_impl(ds->ds_dir->dd_pool->dp_spa, ds, ds->ds_object,\n\t    &dsl_dataset_phys(ds)->ds_bp, txg_start, resume, flags, func, arg));\n}\n\nint\ntraverse_dataset(dsl_dataset_t *ds, uint64_t txg_start,\n    int flags, blkptr_cb_t func, void *arg)\n{\n\treturn (traverse_dataset_resume(ds, txg_start, NULL, flags, func, arg));\n}\n\nint\ntraverse_dataset_destroyed(spa_t *spa, blkptr_t *blkptr,\n    uint64_t txg_start, zbookmark_phys_t *resume, int flags,\n    blkptr_cb_t func, void *arg)\n{\n\treturn (traverse_impl(spa, NULL, ZB_DESTROYED_OBJSET,\n\t    blkptr, txg_start, resume, flags, func, arg));\n}\n\n \nint\ntraverse_pool(spa_t *spa, uint64_t txg_start, int flags,\n    blkptr_cb_t func, void *arg)\n{\n\tint err;\n\tdsl_pool_t *dp = spa_get_dsl(spa);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tboolean_t hard = (flags & TRAVERSE_HARD);\n\n\t \n\terr = traverse_impl(spa, NULL, 0, spa_get_rootblkptr(spa),\n\t    txg_start, NULL, flags, func, arg);\n\tif (err != 0)\n\t\treturn (err);\n\n\t \n\tfor (uint64_t obj = 1; err == 0;\n\t    err = dmu_object_next(mos, &obj, B_FALSE, txg_start)) {\n\t\tdmu_object_info_t doi;\n\n\t\terr = dmu_object_info(mos, obj, &doi);\n\t\tif (err != 0) {\n\t\t\tif (hard)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (doi.doi_bonus_type == DMU_OT_DSL_DATASET) {\n\t\t\tdsl_dataset_t *ds;\n\t\t\tuint64_t txg = txg_start;\n\n\t\t\tdsl_pool_config_enter(dp, FTAG);\n\t\t\terr = dsl_dataset_hold_obj(dp, obj, FTAG, &ds);\n\t\t\tdsl_pool_config_exit(dp, FTAG);\n\t\t\tif (err != 0) {\n\t\t\t\tif (hard)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dsl_dataset_phys(ds)->ds_prev_snap_txg > txg)\n\t\t\t\ttxg = dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t\t\terr = traverse_dataset(ds, txg, flags, func, arg);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (err == ESRCH)\n\t\terr = 0;\n\treturn (err);\n}\n\nEXPORT_SYMBOL(traverse_dataset);\nEXPORT_SYMBOL(traverse_pool);\n\nZFS_MODULE_PARAM(zfs, zfs_, pd_bytes_max, INT, ZMOD_RW,\n\t\"Max number of bytes to prefetch\");\n\nZFS_MODULE_PARAM(zfs, zfs_, traverse_indirect_prefetch_limit, UINT, ZMOD_RW,\n\t\"Traverse prefetch number of blocks pointed by indirect block\");\n\n#if defined(_KERNEL)\nmodule_param_named(ignore_hole_birth, send_holes_without_birth_time, int, 0644);\nMODULE_PARM_DESC(ignore_hole_birth,\n\t\"Alias for send_holes_without_birth_time\");\n#endif\n\n \nZFS_MODULE_PARAM(zfs, , send_holes_without_birth_time, INT, ZMOD_RW,\n\t\"Ignore hole_birth txg for zfs send\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}