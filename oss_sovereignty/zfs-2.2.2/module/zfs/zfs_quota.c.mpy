{
  "module_name": "zfs_quota.c",
  "hash_id": "8e0a1e2ac487ee08d84a7d328c14a119c8ee257d8072ac0e263704c7b870b3a3",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_quota.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/avl.h>\n#include <sys/dmu_objset.h>\n#include <sys/sa.h>\n#include <sys/sa_impl.h>\n#include <sys/zap.h>\n#include <sys/zfs_project.h>\n#include <sys/zfs_quota.h>\n#include <sys/zfs_znode.h>\n\nint\nzpl_get_file_info(dmu_object_type_t bonustype, const void *data,\n    zfs_file_info_t *zoi)\n{\n\t \n\tif (bonustype != DMU_OT_ZNODE && bonustype != DMU_OT_SA)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tzoi->zfi_project = ZFS_DEFAULT_PROJID;\n\n\t \n\tif (data == NULL)\n\t\treturn (SET_ERROR(EEXIST));\n\n\tif (bonustype == DMU_OT_ZNODE) {\n\t\tconst znode_phys_t *znp = data;\n\t\tzoi->zfi_user = znp->zp_uid;\n\t\tzoi->zfi_group = znp->zp_gid;\n\t\tzoi->zfi_generation = znp->zp_gen;\n\t\treturn (0);\n\t}\n\n\tconst sa_hdr_phys_t *sap = data;\n\tif (sap->sa_magic == 0) {\n\t\t \n\t\tzoi->zfi_user = 0;\n\t\tzoi->zfi_group = 0;\n\t\tzoi->zfi_generation = 0;\n\t\treturn (0);\n\t}\n\n\tsa_hdr_phys_t sa = *sap;\n\tboolean_t swap = B_FALSE;\n\tif (sa.sa_magic == BSWAP_32(SA_MAGIC)) {\n\t\tsa.sa_magic = SA_MAGIC;\n\t\tsa.sa_layout_info = BSWAP_16(sa.sa_layout_info);\n\t\tswap = B_TRUE;\n\t}\n\tVERIFY3U(sa.sa_magic, ==, SA_MAGIC);\n\n\tint hdrsize = sa_hdrsize(&sa);\n\tVERIFY3U(hdrsize, >=, sizeof (sa_hdr_phys_t));\n\n\tuintptr_t data_after_hdr = (uintptr_t)data + hdrsize;\n\tzoi->zfi_user = *((uint64_t *)(data_after_hdr + SA_UID_OFFSET));\n\tzoi->zfi_group = *((uint64_t *)(data_after_hdr + SA_GID_OFFSET));\n\tzoi->zfi_generation = *((uint64_t *)(data_after_hdr + SA_GEN_OFFSET));\n\tuint64_t flags = *((uint64_t *)(data_after_hdr + SA_FLAGS_OFFSET));\n\tif (swap)\n\t\tflags = BSWAP_64(flags);\n\n\tif (flags & ZFS_PROJID) {\n\t\tzoi->zfi_project =\n\t\t    *((uint64_t *)(data_after_hdr + SA_PROJID_OFFSET));\n\t}\n\n\tif (swap) {\n\t\tzoi->zfi_user = BSWAP_64(zoi->zfi_user);\n\t\tzoi->zfi_group = BSWAP_64(zoi->zfi_group);\n\t\tzoi->zfi_project = BSWAP_64(zoi->zfi_project);\n\t\tzoi->zfi_generation = BSWAP_64(zoi->zfi_generation);\n\t}\n\treturn (0);\n}\n\nstatic void\nfuidstr_to_sid(zfsvfs_t *zfsvfs, const char *fuidstr,\n    char *domainbuf, int buflen, uid_t *ridp)\n{\n\tuint64_t fuid;\n\tconst char *domain;\n\n\tfuid = zfs_strtonum(fuidstr, NULL);\n\n\tdomain = zfs_fuid_find_by_idx(zfsvfs, FUID_INDEX(fuid));\n\tif (domain)\n\t\t(void) strlcpy(domainbuf, domain, buflen);\n\telse\n\t\tdomainbuf[0] = '\\0';\n\t*ridp = FUID_RID(fuid);\n}\n\nstatic uint64_t\nzfs_userquota_prop_to_obj(zfsvfs_t *zfsvfs, zfs_userquota_prop_t type)\n{\n\tswitch (type) {\n\tcase ZFS_PROP_USERUSED:\n\tcase ZFS_PROP_USEROBJUSED:\n\t\treturn (DMU_USERUSED_OBJECT);\n\tcase ZFS_PROP_GROUPUSED:\n\tcase ZFS_PROP_GROUPOBJUSED:\n\t\treturn (DMU_GROUPUSED_OBJECT);\n\tcase ZFS_PROP_PROJECTUSED:\n\tcase ZFS_PROP_PROJECTOBJUSED:\n\t\treturn (DMU_PROJECTUSED_OBJECT);\n\tcase ZFS_PROP_USERQUOTA:\n\t\treturn (zfsvfs->z_userquota_obj);\n\tcase ZFS_PROP_GROUPQUOTA:\n\t\treturn (zfsvfs->z_groupquota_obj);\n\tcase ZFS_PROP_USEROBJQUOTA:\n\t\treturn (zfsvfs->z_userobjquota_obj);\n\tcase ZFS_PROP_GROUPOBJQUOTA:\n\t\treturn (zfsvfs->z_groupobjquota_obj);\n\tcase ZFS_PROP_PROJECTQUOTA:\n\t\treturn (zfsvfs->z_projectquota_obj);\n\tcase ZFS_PROP_PROJECTOBJQUOTA:\n\t\treturn (zfsvfs->z_projectobjquota_obj);\n\tdefault:\n\t\treturn (ZFS_NO_OBJECT);\n\t}\n}\n\nint\nzfs_userspace_many(zfsvfs_t *zfsvfs, zfs_userquota_prop_t type,\n    uint64_t *cookiep, void *vbuf, uint64_t *bufsizep)\n{\n\tint error;\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tzfs_useracct_t *buf = vbuf;\n\tuint64_t obj;\n\tint offset = 0;\n\n\tif (!dmu_objset_userspace_present(zfsvfs->z_os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif ((type == ZFS_PROP_PROJECTQUOTA || type == ZFS_PROP_PROJECTUSED ||\n\t    type == ZFS_PROP_PROJECTOBJQUOTA ||\n\t    type == ZFS_PROP_PROJECTOBJUSED) &&\n\t    !dmu_objset_projectquota_present(zfsvfs->z_os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif ((type == ZFS_PROP_USEROBJUSED || type == ZFS_PROP_GROUPOBJUSED ||\n\t    type == ZFS_PROP_USEROBJQUOTA || type == ZFS_PROP_GROUPOBJQUOTA ||\n\t    type == ZFS_PROP_PROJECTOBJUSED ||\n\t    type == ZFS_PROP_PROJECTOBJQUOTA) &&\n\t    !dmu_objset_userobjspace_present(zfsvfs->z_os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tobj = zfs_userquota_prop_to_obj(zfsvfs, type);\n\tif (obj == ZFS_NO_OBJECT) {\n\t\t*bufsizep = 0;\n\t\treturn (0);\n\t}\n\n\tif (type == ZFS_PROP_USEROBJUSED || type == ZFS_PROP_GROUPOBJUSED ||\n\t    type == ZFS_PROP_PROJECTOBJUSED)\n\t\toffset = DMU_OBJACCT_PREFIX_LEN;\n\n\tfor (zap_cursor_init_serialized(&zc, zfsvfs->z_os, obj, *cookiep);\n\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tif ((uintptr_t)buf - (uintptr_t)vbuf + sizeof (zfs_useracct_t) >\n\t\t    *bufsizep)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((offset > 0) != (strncmp(za.za_name, DMU_OBJACCT_PREFIX,\n\t\t    DMU_OBJACCT_PREFIX_LEN) == 0))\n\t\t\tcontinue;\n\n\t\tfuidstr_to_sid(zfsvfs, za.za_name + offset,\n\t\t    buf->zu_domain, sizeof (buf->zu_domain), &buf->zu_rid);\n\n\t\tbuf->zu_space = za.za_first_integer;\n\t\tbuf++;\n\t}\n\tif (error == ENOENT)\n\t\terror = 0;\n\n\tASSERT3U((uintptr_t)buf - (uintptr_t)vbuf, <=, *bufsizep);\n\t*bufsizep = (uintptr_t)buf - (uintptr_t)vbuf;\n\t*cookiep = zap_cursor_serialize(&zc);\n\tzap_cursor_fini(&zc);\n\treturn (error);\n}\n\nint\nzfs_userspace_one(zfsvfs_t *zfsvfs, zfs_userquota_prop_t type,\n    const char *domain, uint64_t rid, uint64_t *valp)\n{\n\tchar buf[20 + DMU_OBJACCT_PREFIX_LEN];\n\tint offset = 0;\n\tint err;\n\tuint64_t obj;\n\n\t*valp = 0;\n\n\tif (!dmu_objset_userspace_present(zfsvfs->z_os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif ((type == ZFS_PROP_USEROBJUSED || type == ZFS_PROP_GROUPOBJUSED ||\n\t    type == ZFS_PROP_USEROBJQUOTA || type == ZFS_PROP_GROUPOBJQUOTA ||\n\t    type == ZFS_PROP_PROJECTOBJUSED ||\n\t    type == ZFS_PROP_PROJECTOBJQUOTA) &&\n\t    !dmu_objset_userobjspace_present(zfsvfs->z_os))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (type == ZFS_PROP_PROJECTQUOTA || type == ZFS_PROP_PROJECTUSED ||\n\t    type == ZFS_PROP_PROJECTOBJQUOTA ||\n\t    type == ZFS_PROP_PROJECTOBJUSED) {\n\t\tif (!dmu_objset_projectquota_present(zfsvfs->z_os))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tif (!zpl_is_valid_projid(rid))\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tobj = zfs_userquota_prop_to_obj(zfsvfs, type);\n\tif (obj == ZFS_NO_OBJECT)\n\t\treturn (0);\n\n\tif (type == ZFS_PROP_USEROBJUSED || type == ZFS_PROP_GROUPOBJUSED ||\n\t    type == ZFS_PROP_PROJECTOBJUSED) {\n\t\tstrlcpy(buf, DMU_OBJACCT_PREFIX, DMU_OBJACCT_PREFIX_LEN + 1);\n\t\toffset = DMU_OBJACCT_PREFIX_LEN;\n\t}\n\n\terr = zfs_id_to_fuidstr(zfsvfs, domain, rid, buf + offset,\n\t    sizeof (buf) - offset, B_FALSE);\n\tif (err)\n\t\treturn (err);\n\n\terr = zap_lookup(zfsvfs->z_os, obj, buf, 8, 1, valp);\n\tif (err == ENOENT)\n\t\terr = 0;\n\treturn (err);\n}\n\nint\nzfs_set_userquota(zfsvfs_t *zfsvfs, zfs_userquota_prop_t type,\n    const char *domain, uint64_t rid, uint64_t quota)\n{\n\tchar buf[32];\n\tint err;\n\tdmu_tx_t *tx;\n\tuint64_t *objp;\n\tboolean_t fuid_dirtied;\n\n\tif (zfsvfs->z_version < ZPL_VERSION_USERSPACE)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tswitch (type) {\n\tcase ZFS_PROP_USERQUOTA:\n\t\tobjp = &zfsvfs->z_userquota_obj;\n\t\tbreak;\n\tcase ZFS_PROP_GROUPQUOTA:\n\t\tobjp = &zfsvfs->z_groupquota_obj;\n\t\tbreak;\n\tcase ZFS_PROP_USEROBJQUOTA:\n\t\tobjp = &zfsvfs->z_userobjquota_obj;\n\t\tbreak;\n\tcase ZFS_PROP_GROUPOBJQUOTA:\n\t\tobjp = &zfsvfs->z_groupobjquota_obj;\n\t\tbreak;\n\tcase ZFS_PROP_PROJECTQUOTA:\n\t\tif (!dmu_objset_projectquota_enabled(zfsvfs->z_os))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tif (!zpl_is_valid_projid(rid))\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tobjp = &zfsvfs->z_projectquota_obj;\n\t\tbreak;\n\tcase ZFS_PROP_PROJECTOBJQUOTA:\n\t\tif (!dmu_objset_projectquota_enabled(zfsvfs->z_os))\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\tif (!zpl_is_valid_projid(rid))\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tobjp = &zfsvfs->z_projectobjquota_obj;\n\t\tbreak;\n\tdefault:\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\terr = zfs_id_to_fuidstr(zfsvfs, domain, rid, buf, sizeof (buf), B_TRUE);\n\tif (err)\n\t\treturn (err);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, *objp ? *objp : DMU_NEW_OBJECT, B_TRUE, NULL);\n\tif (*objp == 0) {\n\t\tdmu_tx_hold_zap(tx, MASTER_NODE_OBJ, B_TRUE,\n\t\t    zfs_userquota_prop_prefixes[type]);\n\t}\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (err);\n\t}\n\n\tmutex_enter(&zfsvfs->z_lock);\n\tif (*objp == 0) {\n\t\t*objp = zap_create(zfsvfs->z_os, DMU_OT_USERGROUP_QUOTA,\n\t\t    DMU_OT_NONE, 0, tx);\n\t\tVERIFY(0 == zap_add(zfsvfs->z_os, MASTER_NODE_OBJ,\n\t\t    zfs_userquota_prop_prefixes[type], 8, 1, objp, tx));\n\t}\n\tmutex_exit(&zfsvfs->z_lock);\n\n\tif (quota == 0) {\n\t\terr = zap_remove(zfsvfs->z_os, *objp, buf, tx);\n\t\tif (err == ENOENT)\n\t\t\terr = 0;\n\t} else {\n\t\terr = zap_update(zfsvfs->z_os, *objp, buf, 8, 1, &quota, tx);\n\t}\n\tASSERT(err == 0);\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\tdmu_tx_commit(tx);\n\treturn (err);\n}\n\nboolean_t\nzfs_id_overobjquota(zfsvfs_t *zfsvfs, uint64_t usedobj, uint64_t id)\n{\n\tchar buf[20 + DMU_OBJACCT_PREFIX_LEN];\n\tuint64_t used, quota, quotaobj;\n\tint err;\n\n\tif (!dmu_objset_userobjspace_present(zfsvfs->z_os)) {\n\t\tif (dmu_objset_userobjspace_upgradable(zfsvfs->z_os)) {\n\t\t\tdsl_pool_config_enter(\n\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\tdmu_objset_id_quota_upgrade(zfsvfs->z_os);\n\t\t\tdsl_pool_config_exit(\n\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t}\n\t\treturn (B_FALSE);\n\t}\n\n\tif (usedobj == DMU_PROJECTUSED_OBJECT) {\n\t\tif (!dmu_objset_projectquota_present(zfsvfs->z_os)) {\n\t\t\tif (dmu_objset_projectquota_upgradable(zfsvfs->z_os)) {\n\t\t\t\tdsl_pool_config_enter(\n\t\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\t\tdmu_objset_id_quota_upgrade(zfsvfs->z_os);\n\t\t\t\tdsl_pool_config_exit(\n\t\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\t}\n\t\t\treturn (B_FALSE);\n\t\t}\n\t\tquotaobj = zfsvfs->z_projectobjquota_obj;\n\t} else if (usedobj == DMU_USERUSED_OBJECT) {\n\t\tquotaobj = zfsvfs->z_userobjquota_obj;\n\t} else if (usedobj == DMU_GROUPUSED_OBJECT) {\n\t\tquotaobj = zfsvfs->z_groupobjquota_obj;\n\t} else {\n\t\treturn (B_FALSE);\n\t}\n\tif (quotaobj == 0 || zfsvfs->z_replay)\n\t\treturn (B_FALSE);\n\n\t(void) snprintf(buf, sizeof (buf), \"%llx\", (longlong_t)id);\n\terr = zap_lookup(zfsvfs->z_os, quotaobj, buf, 8, 1, &quota);\n\tif (err != 0)\n\t\treturn (B_FALSE);\n\n\t(void) snprintf(buf, sizeof (buf), DMU_OBJACCT_PREFIX \"%llx\",\n\t    (longlong_t)id);\n\terr = zap_lookup(zfsvfs->z_os, usedobj, buf, 8, 1, &used);\n\tif (err != 0)\n\t\treturn (B_FALSE);\n\treturn (used >= quota);\n}\n\nboolean_t\nzfs_id_overblockquota(zfsvfs_t *zfsvfs, uint64_t usedobj, uint64_t id)\n{\n\tchar buf[20];\n\tuint64_t used, quota, quotaobj;\n\tint err;\n\n\tif (usedobj == DMU_PROJECTUSED_OBJECT) {\n\t\tif (!dmu_objset_projectquota_present(zfsvfs->z_os)) {\n\t\t\tif (dmu_objset_projectquota_upgradable(zfsvfs->z_os)) {\n\t\t\t\tdsl_pool_config_enter(\n\t\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\t\tdmu_objset_id_quota_upgrade(zfsvfs->z_os);\n\t\t\t\tdsl_pool_config_exit(\n\t\t\t\t    dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\t\t}\n\t\t\treturn (B_FALSE);\n\t\t}\n\t\tquotaobj = zfsvfs->z_projectquota_obj;\n\t} else if (usedobj == DMU_USERUSED_OBJECT) {\n\t\tquotaobj = zfsvfs->z_userquota_obj;\n\t} else if (usedobj == DMU_GROUPUSED_OBJECT) {\n\t\tquotaobj = zfsvfs->z_groupquota_obj;\n\t} else {\n\t\treturn (B_FALSE);\n\t}\n\tif (quotaobj == 0 || zfsvfs->z_replay)\n\t\treturn (B_FALSE);\n\n\t(void) snprintf(buf, sizeof (buf), \"%llx\", (longlong_t)id);\n\terr = zap_lookup(zfsvfs->z_os, quotaobj, buf, 8, 1, &quota);\n\tif (err != 0)\n\t\treturn (B_FALSE);\n\n\terr = zap_lookup(zfsvfs->z_os, usedobj, buf, 8, 1, &used);\n\tif (err != 0)\n\t\treturn (B_FALSE);\n\treturn (used >= quota);\n}\n\nboolean_t\nzfs_id_overquota(zfsvfs_t *zfsvfs, uint64_t usedobj, uint64_t id)\n{\n\treturn (zfs_id_overblockquota(zfsvfs, usedobj, id) ||\n\t    zfs_id_overobjquota(zfsvfs, usedobj, id));\n}\n\nEXPORT_SYMBOL(zpl_get_file_info);\nEXPORT_SYMBOL(zfs_userspace_one);\nEXPORT_SYMBOL(zfs_userspace_many);\nEXPORT_SYMBOL(zfs_set_userquota);\nEXPORT_SYMBOL(zfs_id_overblockquota);\nEXPORT_SYMBOL(zfs_id_overobjquota);\nEXPORT_SYMBOL(zfs_id_overquota);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}