{
  "module_name": "dsl_pool.c",
  "hash_id": "cb3748fb40d0cca6d23823f3234895c7ced8020059a84fbcf651fcc751a66176",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_pool.c",
  "human_readable_source": " \n \n\n#include <sys/dsl_pool.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_scan.h>\n#include <sys/dnode.h>\n#include <sys/dmu_tx.h>\n#include <sys/dmu_objset.h>\n#include <sys/arc.h>\n#include <sys/zap.h>\n#include <sys/zio.h>\n#include <sys/zfs_context.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_znode.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev_impl.h>\n#include <sys/metaslab_impl.h>\n#include <sys/bptree.h>\n#include <sys/zfeature.h>\n#include <sys/zil_impl.h>\n#include <sys/dsl_userhold.h>\n#include <sys/trace_zfs.h>\n#include <sys/mmp.h>\n\n \n\n \nuint64_t zfs_dirty_data_max = 0;\nuint64_t zfs_dirty_data_max_max = 0;\nuint_t zfs_dirty_data_max_percent = 10;\nuint_t zfs_dirty_data_max_max_percent = 25;\n\n \nuint64_t zfs_wrlog_data_max = 0;\n\n \nstatic uint_t zfs_dirty_data_sync_percent = 20;\n\n \nuint_t zfs_delay_min_dirty_percent = 60;\n\n \nuint64_t zfs_delay_scale = 1000 * 1000 * 1000 / 2000;\n\n \nstatic int zfs_sync_taskq_batch_pct = 75;\n\n \nstatic int zfs_zil_clean_taskq_nthr_pct = 100;\nstatic int zfs_zil_clean_taskq_minalloc = 1024;\nstatic int zfs_zil_clean_taskq_maxalloc = 1024 * 1024;\n\nint\ndsl_pool_open_special_dir(dsl_pool_t *dp, const char *name, dsl_dir_t **ddp)\n{\n\tuint64_t obj;\n\tint err;\n\n\terr = zap_lookup(dp->dp_meta_objset,\n\t    dsl_dir_phys(dp->dp_root_dir)->dd_child_dir_zapobj,\n\t    name, sizeof (obj), 1, &obj);\n\tif (err)\n\t\treturn (err);\n\n\treturn (dsl_dir_hold_obj(dp, obj, name, dp, ddp));\n}\n\nstatic dsl_pool_t *\ndsl_pool_open_impl(spa_t *spa, uint64_t txg)\n{\n\tdsl_pool_t *dp;\n\tblkptr_t *bp = spa_get_rootblkptr(spa);\n\n\tdp = kmem_zalloc(sizeof (dsl_pool_t), KM_SLEEP);\n\tdp->dp_spa = spa;\n\tdp->dp_meta_rootbp = *bp;\n\trrw_init(&dp->dp_config_rwlock, B_TRUE);\n\ttxg_init(dp, txg);\n\tmmp_init(spa);\n\n\ttxg_list_create(&dp->dp_dirty_datasets, spa,\n\t    offsetof(dsl_dataset_t, ds_dirty_link));\n\ttxg_list_create(&dp->dp_dirty_zilogs, spa,\n\t    offsetof(zilog_t, zl_dirty_link));\n\ttxg_list_create(&dp->dp_dirty_dirs, spa,\n\t    offsetof(dsl_dir_t, dd_dirty_link));\n\ttxg_list_create(&dp->dp_sync_tasks, spa,\n\t    offsetof(dsl_sync_task_t, dst_node));\n\ttxg_list_create(&dp->dp_early_sync_tasks, spa,\n\t    offsetof(dsl_sync_task_t, dst_node));\n\n\tdp->dp_sync_taskq = taskq_create(\"dp_sync_taskq\",\n\t    zfs_sync_taskq_batch_pct, minclsyspri, 1, INT_MAX,\n\t    TASKQ_THREADS_CPU_PCT);\n\n\tdp->dp_zil_clean_taskq = taskq_create(\"dp_zil_clean_taskq\",\n\t    zfs_zil_clean_taskq_nthr_pct, minclsyspri,\n\t    zfs_zil_clean_taskq_minalloc,\n\t    zfs_zil_clean_taskq_maxalloc,\n\t    TASKQ_PREPOPULATE | TASKQ_THREADS_CPU_PCT);\n\n\tmutex_init(&dp->dp_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&dp->dp_spaceavail_cv, NULL, CV_DEFAULT, NULL);\n\n\taggsum_init(&dp->dp_wrlog_total, 0);\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\taggsum_init(&dp->dp_wrlog_pertxg[i], 0);\n\t}\n\n\tdp->dp_zrele_taskq = taskq_create(\"z_zrele\", 100, defclsyspri,\n\t    boot_ncpus * 8, INT_MAX, TASKQ_PREPOPULATE | TASKQ_DYNAMIC |\n\t    TASKQ_THREADS_CPU_PCT);\n\tdp->dp_unlinked_drain_taskq = taskq_create(\"z_unlinked_drain\",\n\t    100, defclsyspri, boot_ncpus, INT_MAX,\n\t    TASKQ_PREPOPULATE | TASKQ_DYNAMIC | TASKQ_THREADS_CPU_PCT);\n\n\treturn (dp);\n}\n\nint\ndsl_pool_init(spa_t *spa, uint64_t txg, dsl_pool_t **dpp)\n{\n\tint err;\n\tdsl_pool_t *dp = dsl_pool_open_impl(spa, txg);\n\n\t \n\t*dpp = dp;\n\n\terr = dmu_objset_open_impl(spa, NULL, &dp->dp_meta_rootbp,\n\t    &dp->dp_meta_objset);\n\tif (err != 0) {\n\t\tdsl_pool_close(dp);\n\t\t*dpp = NULL;\n\t}\n\n\treturn (err);\n}\n\nint\ndsl_pool_open(dsl_pool_t *dp)\n{\n\tint err;\n\tdsl_dir_t *dd;\n\tdsl_dataset_t *ds;\n\tuint64_t obj;\n\n\trrw_enter(&dp->dp_config_rwlock, RW_WRITER, FTAG);\n\terr = zap_lookup(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_ROOT_DATASET, sizeof (uint64_t), 1,\n\t    &dp->dp_root_dir_obj);\n\tif (err)\n\t\tgoto out;\n\n\terr = dsl_dir_hold_obj(dp, dp->dp_root_dir_obj,\n\t    NULL, dp, &dp->dp_root_dir);\n\tif (err)\n\t\tgoto out;\n\n\terr = dsl_pool_open_special_dir(dp, MOS_DIR_NAME, &dp->dp_mos_dir);\n\tif (err)\n\t\tgoto out;\n\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_ORIGIN) {\n\t\terr = dsl_pool_open_special_dir(dp, ORIGIN_DIR_NAME, &dd);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = dsl_dataset_hold_obj(dp,\n\t\t    dsl_dir_phys(dd)->dd_head_dataset_obj, FTAG, &ds);\n\t\tif (err == 0) {\n\t\t\terr = dsl_dataset_hold_obj(dp,\n\t\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, dp,\n\t\t\t    &dp->dp_origin_snap);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t}\n\t\tdsl_dir_rele(dd, dp);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (spa_version(dp->dp_spa) >= SPA_VERSION_DEADLISTS) {\n\t\terr = dsl_pool_open_special_dir(dp, FREE_DIR_NAME,\n\t\t    &dp->dp_free_dir);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = zap_lookup(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_FREE_BPOBJ, sizeof (uint64_t), 1, &obj);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tVERIFY0(bpobj_open(&dp->dp_free_bpobj,\n\t\t    dp->dp_meta_objset, obj));\n\t}\n\n\tif (spa_feature_is_active(dp->dp_spa, SPA_FEATURE_OBSOLETE_COUNTS)) {\n\t\terr = zap_lookup(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_OBSOLETE_BPOBJ, sizeof (uint64_t), 1, &obj);\n\t\tif (err == 0) {\n\t\t\tVERIFY0(bpobj_open(&dp->dp_obsolete_bpobj,\n\t\t\t    dp->dp_meta_objset, obj));\n\t\t} else if (err == ENOENT) {\n\t\t\t \n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\t(void) dsl_pool_open_special_dir(dp, LEAK_DIR_NAME,\n\t    &dp->dp_leak_dir);\n\n\tif (spa_feature_is_active(dp->dp_spa, SPA_FEATURE_ASYNC_DESTROY)) {\n\t\terr = zap_lookup(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_BPTREE_OBJ, sizeof (uint64_t), 1,\n\t\t    &dp->dp_bptree_obj);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\tif (spa_feature_is_active(dp->dp_spa, SPA_FEATURE_EMPTY_BPOBJ)) {\n\t\terr = zap_lookup(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_EMPTY_BPOBJ, sizeof (uint64_t), 1,\n\t\t    &dp->dp_empty_bpobj);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\terr = zap_lookup(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_TMP_USERREFS, sizeof (uint64_t), 1,\n\t    &dp->dp_tmp_userrefs_obj);\n\tif (err == ENOENT)\n\t\terr = 0;\n\tif (err)\n\t\tgoto out;\n\n\terr = dsl_scan_init(dp, dp->dp_tx.tx_open_txg);\n\nout:\n\trrw_exit(&dp->dp_config_rwlock, FTAG);\n\treturn (err);\n}\n\nvoid\ndsl_pool_close(dsl_pool_t *dp)\n{\n\t \n\tif (dp->dp_origin_snap != NULL)\n\t\tdsl_dataset_rele(dp->dp_origin_snap, dp);\n\tif (dp->dp_mos_dir != NULL)\n\t\tdsl_dir_rele(dp->dp_mos_dir, dp);\n\tif (dp->dp_free_dir != NULL)\n\t\tdsl_dir_rele(dp->dp_free_dir, dp);\n\tif (dp->dp_leak_dir != NULL)\n\t\tdsl_dir_rele(dp->dp_leak_dir, dp);\n\tif (dp->dp_root_dir != NULL)\n\t\tdsl_dir_rele(dp->dp_root_dir, dp);\n\n\tbpobj_close(&dp->dp_free_bpobj);\n\tbpobj_close(&dp->dp_obsolete_bpobj);\n\n\t \n\tif (dp->dp_meta_objset != NULL)\n\t\tdmu_objset_evict(dp->dp_meta_objset);\n\n\ttxg_list_destroy(&dp->dp_dirty_datasets);\n\ttxg_list_destroy(&dp->dp_dirty_zilogs);\n\ttxg_list_destroy(&dp->dp_sync_tasks);\n\ttxg_list_destroy(&dp->dp_early_sync_tasks);\n\ttxg_list_destroy(&dp->dp_dirty_dirs);\n\n\ttaskq_destroy(dp->dp_zil_clean_taskq);\n\ttaskq_destroy(dp->dp_sync_taskq);\n\n\t \n\tarc_flush(dp->dp_spa, FALSE);\n\n\tmmp_fini(dp->dp_spa);\n\ttxg_fini(dp);\n\tdsl_scan_fini(dp);\n\tdmu_buf_user_evict_wait();\n\n\trrw_destroy(&dp->dp_config_rwlock);\n\tmutex_destroy(&dp->dp_lock);\n\tcv_destroy(&dp->dp_spaceavail_cv);\n\n\tASSERT0(aggsum_value(&dp->dp_wrlog_total));\n\taggsum_fini(&dp->dp_wrlog_total);\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT0(aggsum_value(&dp->dp_wrlog_pertxg[i]));\n\t\taggsum_fini(&dp->dp_wrlog_pertxg[i]);\n\t}\n\n\ttaskq_destroy(dp->dp_unlinked_drain_taskq);\n\ttaskq_destroy(dp->dp_zrele_taskq);\n\tif (dp->dp_blkstats != NULL)\n\t\tvmem_free(dp->dp_blkstats, sizeof (zfs_all_blkstats_t));\n\tkmem_free(dp, sizeof (dsl_pool_t));\n}\n\nvoid\ndsl_pool_create_obsolete_bpobj(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tuint64_t obj;\n\t \n\tASSERT(spa_feature_is_active(dp->dp_spa, SPA_FEATURE_DEVICE_REMOVAL));\n\t \n\tobj = bpobj_alloc(dp->dp_meta_objset, SPA_OLD_MAXBLOCKSIZE, tx);\n\tVERIFY0(bpobj_open(&dp->dp_obsolete_bpobj, dp->dp_meta_objset, obj));\n\tVERIFY0(zap_add(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_OBSOLETE_BPOBJ, sizeof (uint64_t), 1, &obj, tx));\n\tspa_feature_incr(dp->dp_spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n}\n\nvoid\ndsl_pool_destroy_obsolete_bpobj(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tspa_feature_decr(dp->dp_spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\tVERIFY0(zap_remove(dp->dp_meta_objset,\n\t    DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_OBSOLETE_BPOBJ, tx));\n\tbpobj_free(dp->dp_meta_objset,\n\t    dp->dp_obsolete_bpobj.bpo_object, tx);\n\tbpobj_close(&dp->dp_obsolete_bpobj);\n}\n\ndsl_pool_t *\ndsl_pool_create(spa_t *spa, nvlist_t *zplprops __attribute__((unused)),\n    dsl_crypto_params_t *dcp, uint64_t txg)\n{\n\tint err;\n\tdsl_pool_t *dp = dsl_pool_open_impl(spa, txg);\n\tdmu_tx_t *tx = dmu_tx_create_assigned(dp, txg);\n#ifdef _KERNEL\n\tobjset_t *os;\n#else\n\tobjset_t *os __attribute__((unused));\n#endif\n\tdsl_dataset_t *ds;\n\tuint64_t obj;\n\n\trrw_enter(&dp->dp_config_rwlock, RW_WRITER, FTAG);\n\n\t \n\tdp->dp_meta_objset = dmu_objset_create_impl(spa,\n\t    NULL, &dp->dp_meta_rootbp, DMU_OST_META, tx);\n\tspa->spa_meta_objset = dp->dp_meta_objset;\n\n\t \n\terr = zap_create_claim(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_OT_OBJECT_DIRECTORY, DMU_OT_NONE, 0, tx);\n\tASSERT0(err);\n\n\t \n\tVERIFY0(dsl_scan_init(dp, txg));\n\n\t \n\tdp->dp_root_dir_obj = dsl_dir_create_sync(dp, NULL, NULL, tx);\n\tVERIFY0(dsl_dir_hold_obj(dp, dp->dp_root_dir_obj,\n\t    NULL, dp, &dp->dp_root_dir));\n\n\t \n\t(void) dsl_dir_create_sync(dp, dp->dp_root_dir, MOS_DIR_NAME, tx);\n\tVERIFY0(dsl_pool_open_special_dir(dp,\n\t    MOS_DIR_NAME, &dp->dp_mos_dir));\n\n\tif (spa_version(spa) >= SPA_VERSION_DEADLISTS) {\n\t\t \n\t\t(void) dsl_dir_create_sync(dp, dp->dp_root_dir,\n\t\t    FREE_DIR_NAME, tx);\n\t\tVERIFY0(dsl_pool_open_special_dir(dp,\n\t\t    FREE_DIR_NAME, &dp->dp_free_dir));\n\n\t\t \n\t\tobj = bpobj_alloc(dp->dp_meta_objset, SPA_OLD_MAXBLOCKSIZE, tx);\n\t\tVERIFY(zap_add(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_FREE_BPOBJ, sizeof (uint64_t), 1, &obj, tx) == 0);\n\t\tVERIFY0(bpobj_open(&dp->dp_free_bpobj,\n\t\t    dp->dp_meta_objset, obj));\n\t}\n\n\tif (spa_version(spa) >= SPA_VERSION_DSL_SCRUB)\n\t\tdsl_pool_create_origin(dp, tx);\n\n\t \n\tif (spa_version(spa) >= SPA_VERSION_FEATURES)\n\t\tspa_feature_create_zap_objects(spa, tx);\n\n\tif (dcp != NULL && dcp->cp_crypt != ZIO_CRYPT_OFF &&\n\t    dcp->cp_crypt != ZIO_CRYPT_INHERIT)\n\t\tspa_feature_enable(spa, SPA_FEATURE_ENCRYPTION, tx);\n\n\t \n\tobj = dsl_dataset_create_sync_dd(dp->dp_root_dir, NULL, dcp, 0, tx);\n\n\t \n\tVERIFY0(dsl_dataset_hold_obj_flags(dp, obj,\n\t    DS_HOLD_FLAG_DECRYPT, FTAG, &ds));\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tos = dmu_objset_create_impl(dp->dp_spa, ds,\n\t    dsl_dataset_get_blkptr(ds), DMU_OST_ZFS, tx);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n#ifdef _KERNEL\n\tzfs_create_fs(os, kcred, zplprops, tx);\n#endif\n\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\n\tdmu_tx_commit(tx);\n\n\trrw_exit(&dp->dp_config_rwlock, FTAG);\n\n\treturn (dp);\n}\n\n \nvoid\ndsl_pool_mos_diduse_space(dsl_pool_t *dp,\n    int64_t used, int64_t comp, int64_t uncomp)\n{\n\tASSERT3U(comp, ==, uncomp);  \n\tmutex_enter(&dp->dp_lock);\n\tdp->dp_mos_used_delta += used;\n\tdp->dp_mos_compressed_delta += comp;\n\tdp->dp_mos_uncompressed_delta += uncomp;\n\tmutex_exit(&dp->dp_lock);\n}\n\nstatic void\ndsl_pool_sync_mos(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tzio_t *zio = zio_root(dp->dp_spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\tdmu_objset_sync(dp->dp_meta_objset, zio, tx);\n\tVERIFY0(zio_wait(zio));\n\tdmu_objset_sync_done(dp->dp_meta_objset, tx);\n\ttaskq_wait(dp->dp_sync_taskq);\n\tmultilist_destroy(&dp->dp_meta_objset->os_synced_dnodes);\n\n\tdprintf_bp(&dp->dp_meta_rootbp, \"meta objset rootbp is %s\", \"\");\n\tspa_set_rootblkptr(dp->dp_spa, &dp->dp_meta_rootbp);\n}\n\nstatic void\ndsl_pool_dirty_delta(dsl_pool_t *dp, int64_t delta)\n{\n\tASSERT(MUTEX_HELD(&dp->dp_lock));\n\n\tif (delta < 0)\n\t\tASSERT3U(-delta, <=, dp->dp_dirty_total);\n\n\tdp->dp_dirty_total += delta;\n\n\t \n\tif (dp->dp_dirty_total < zfs_dirty_data_max)\n\t\tcv_signal(&dp->dp_spaceavail_cv);\n}\n\nvoid\ndsl_pool_wrlog_count(dsl_pool_t *dp, int64_t size, uint64_t txg)\n{\n\tASSERT3S(size, >=, 0);\n\n\taggsum_add(&dp->dp_wrlog_pertxg[txg & TXG_MASK], size);\n\taggsum_add(&dp->dp_wrlog_total, size);\n\n\t \n\tuint64_t sync_min =\n\t    zfs_wrlog_data_max * (zfs_dirty_data_sync_percent + 10) / 200;\n\tif (aggsum_compare(&dp->dp_wrlog_pertxg[txg & TXG_MASK], sync_min) > 0)\n\t\ttxg_kick(dp, txg);\n}\n\nboolean_t\ndsl_pool_need_wrlog_delay(dsl_pool_t *dp)\n{\n\tuint64_t delay_min_bytes =\n\t    zfs_wrlog_data_max * zfs_delay_min_dirty_percent / 100;\n\n\treturn (aggsum_compare(&dp->dp_wrlog_total, delay_min_bytes) > 0);\n}\n\nstatic void\ndsl_pool_wrlog_clear(dsl_pool_t *dp, uint64_t txg)\n{\n\tint64_t delta;\n\tdelta = -(int64_t)aggsum_value(&dp->dp_wrlog_pertxg[txg & TXG_MASK]);\n\taggsum_add(&dp->dp_wrlog_pertxg[txg & TXG_MASK], delta);\n\taggsum_add(&dp->dp_wrlog_total, delta);\n\t \n\t(void) aggsum_value(&dp->dp_wrlog_pertxg[txg & TXG_MASK]);\n\t(void) aggsum_value(&dp->dp_wrlog_total);\n}\n\n#ifdef ZFS_DEBUG\nstatic boolean_t\ndsl_early_sync_task_verify(dsl_pool_t *dp, uint64_t txg)\n{\n\tspa_t *spa = dp->dp_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *vd = rvd->vdev_child[c];\n\t\ttxg_list_t *tl = &vd->vdev_ms_list;\n\t\tmetaslab_t *ms;\n\n\t\tfor (ms = txg_list_head(tl, TXG_CLEAN(txg)); ms;\n\t\t    ms = txg_list_next(tl, ms, TXG_CLEAN(txg))) {\n\t\t\tVERIFY(range_tree_is_empty(ms->ms_freeing));\n\t\t\tVERIFY(range_tree_is_empty(ms->ms_checkpointing));\n\t\t}\n\t}\n\n\treturn (B_TRUE);\n}\n#else\n#define\tdsl_early_sync_task_verify(dp, txg) \\\n\t((void) sizeof (dp), (void) sizeof (txg), B_TRUE)\n#endif\n\nvoid\ndsl_pool_sync(dsl_pool_t *dp, uint64_t txg)\n{\n\tzio_t *zio;\n\tdmu_tx_t *tx;\n\tdsl_dir_t *dd;\n\tdsl_dataset_t *ds;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tlist_t synced_datasets;\n\n\tlist_create(&synced_datasets, sizeof (dsl_dataset_t),\n\t    offsetof(dsl_dataset_t, ds_synced_link));\n\n\ttx = dmu_tx_create_assigned(dp, txg);\n\n\t \n\tif (!txg_list_empty(&dp->dp_early_sync_tasks, txg)) {\n\t\tdsl_sync_task_t *dst;\n\n\t\tASSERT3U(spa_sync_pass(dp->dp_spa), ==, 1);\n\t\twhile ((dst =\n\t\t    txg_list_remove(&dp->dp_early_sync_tasks, txg)) != NULL) {\n\t\t\tASSERT(dsl_early_sync_task_verify(dp, txg));\n\t\t\tdsl_sync_task_sync(dst, tx);\n\t\t}\n\t\tASSERT(dsl_early_sync_task_verify(dp, txg));\n\t}\n\n\t \n\tzio = zio_root(dp->dp_spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\twhile ((ds = txg_list_remove(&dp->dp_dirty_datasets, txg)) != NULL) {\n\t\t \n\t\tASSERT(!list_link_active(&ds->ds_synced_link));\n\t\tlist_insert_tail(&synced_datasets, ds);\n\t\tdsl_dataset_sync(ds, zio, tx);\n\t}\n\tVERIFY0(zio_wait(zio));\n\n\t \n\tmutex_enter(&dp->dp_lock);\n\tASSERT(spa_sync_pass(dp->dp_spa) == 1 ||\n\t    dp->dp_long_free_dirty_pertxg[txg & TXG_MASK] == 0);\n\tdp->dp_long_free_dirty_pertxg[txg & TXG_MASK] = 0;\n\tmutex_exit(&dp->dp_lock);\n\n\t \n\tfor (ds = list_head(&synced_datasets); ds != NULL;\n\t    ds = list_next(&synced_datasets, ds)) {\n\t\tdmu_objset_sync_done(ds->ds_objset, tx);\n\t}\n\ttaskq_wait(dp->dp_sync_taskq);\n\n\t \n\tzio = zio_root(dp->dp_spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\twhile ((ds = txg_list_remove(&dp->dp_dirty_datasets, txg)) != NULL) {\n\t\tobjset_t *os = ds->ds_objset;\n\n\t\tASSERT(list_link_active(&ds->ds_synced_link));\n\t\tdmu_buf_rele(ds->ds_dbuf, ds);\n\t\tdsl_dataset_sync(ds, zio, tx);\n\n\t\t \n\t\tif (os->os_encrypted && !os->os_raw_receive &&\n\t\t    !os->os_next_write_raw[txg & TXG_MASK]) {\n\t\t\tASSERT3P(ds->ds_key_mapping, !=, NULL);\n\t\t\tkey_mapping_rele(dp->dp_spa, ds->ds_key_mapping, ds);\n\t\t}\n\t}\n\tVERIFY0(zio_wait(zio));\n\n\t \n\twhile ((ds = list_remove_head(&synced_datasets)) != NULL) {\n\t\tobjset_t *os = ds->ds_objset;\n\n\t\tif (os->os_encrypted && !os->os_raw_receive &&\n\t\t    !os->os_next_write_raw[txg & TXG_MASK]) {\n\t\t\tASSERT3P(ds->ds_key_mapping, !=, NULL);\n\t\t\tkey_mapping_rele(dp->dp_spa, ds->ds_key_mapping, ds);\n\t\t}\n\n\t\tdsl_dataset_sync_done(ds, tx);\n\t\tdmu_buf_rele(ds->ds_dbuf, ds);\n\t}\n\n\twhile ((dd = txg_list_remove(&dp->dp_dirty_dirs, txg)) != NULL) {\n\t\tdsl_dir_sync(dd, tx);\n\t}\n\n\t \n\tif (dp->dp_mos_used_delta != 0 || dp->dp_mos_compressed_delta != 0 ||\n\t    dp->dp_mos_uncompressed_delta != 0) {\n\t\tdsl_dir_diduse_space(dp->dp_mos_dir, DD_USED_HEAD,\n\t\t    dp->dp_mos_used_delta,\n\t\t    dp->dp_mos_compressed_delta,\n\t\t    dp->dp_mos_uncompressed_delta, tx);\n\t\tdp->dp_mos_used_delta = 0;\n\t\tdp->dp_mos_compressed_delta = 0;\n\t\tdp->dp_mos_uncompressed_delta = 0;\n\t}\n\n\tif (dmu_objset_is_dirty(mos, txg)) {\n\t\tdsl_pool_sync_mos(dp, tx);\n\t}\n\n\t \n\tdsl_pool_undirty_space(dp, dp->dp_dirty_pertxg[txg & TXG_MASK], txg);\n\n\t \n\tif (!txg_list_empty(&dp->dp_sync_tasks, txg)) {\n\t\tdsl_sync_task_t *dst;\n\t\t \n\t\tASSERT3U(spa_sync_pass(dp->dp_spa), ==, 1);\n\t\twhile ((dst = txg_list_remove(&dp->dp_sync_tasks, txg)) != NULL)\n\t\t\tdsl_sync_task_sync(dst, tx);\n\t}\n\n\tdmu_tx_commit(tx);\n\n\tDTRACE_PROBE2(dsl_pool_sync__done, dsl_pool_t *dp, dp, uint64_t, txg);\n}\n\nvoid\ndsl_pool_sync_done(dsl_pool_t *dp, uint64_t txg)\n{\n\tzilog_t *zilog;\n\n\twhile ((zilog = txg_list_head(&dp->dp_dirty_zilogs, txg))) {\n\t\tdsl_dataset_t *ds = dmu_objset_ds(zilog->zl_os);\n\t\t \n\t\tzil_clean(zilog, txg);\n\t\t(void) txg_list_remove_this(&dp->dp_dirty_zilogs, zilog, txg);\n\t\tASSERT(!dmu_objset_is_dirty(zilog->zl_os, txg));\n\t\tdmu_buf_rele(ds->ds_dbuf, zilog);\n\t}\n\n\tdsl_pool_wrlog_clear(dp, txg);\n\n\tASSERT(!dmu_objset_is_dirty(dp->dp_meta_objset, txg));\n}\n\n \nint\ndsl_pool_sync_context(dsl_pool_t *dp)\n{\n\treturn (curthread == dp->dp_tx.tx_sync_thread ||\n\t    spa_is_initializing(dp->dp_spa) ||\n\t    taskq_member(dp->dp_sync_taskq, curthread));\n}\n\n \nuint64_t\ndsl_pool_adjustedsize(dsl_pool_t *dp, zfs_space_check_t slop_policy)\n{\n\tspa_t *spa = dp->dp_spa;\n\tuint64_t space, resv, adjustedsize;\n\tuint64_t spa_deferred_frees =\n\t    spa->spa_deferred_bpobj.bpo_phys->bpo_bytes;\n\n\tspace = spa_get_dspace(spa)\n\t    - spa_get_checkpoint_space(spa) - spa_deferred_frees;\n\tresv = spa_get_slop_space(spa);\n\n\tswitch (slop_policy) {\n\tcase ZFS_SPACE_CHECK_NORMAL:\n\t\tbreak;\n\tcase ZFS_SPACE_CHECK_RESERVED:\n\t\tresv >>= 1;\n\t\tbreak;\n\tcase ZFS_SPACE_CHECK_EXTRA_RESERVED:\n\t\tresv >>= 2;\n\t\tbreak;\n\tcase ZFS_SPACE_CHECK_NONE:\n\t\tresv = 0;\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"invalid slop policy value: %d\", slop_policy);\n\t\tbreak;\n\t}\n\tadjustedsize = (space >= resv) ? (space - resv) : 0;\n\n\treturn (adjustedsize);\n}\n\nuint64_t\ndsl_pool_unreserved_space(dsl_pool_t *dp, zfs_space_check_t slop_policy)\n{\n\tuint64_t poolsize = dsl_pool_adjustedsize(dp, slop_policy);\n\tuint64_t deferred =\n\t    metaslab_class_get_deferred(spa_normal_class(dp->dp_spa));\n\tuint64_t quota = (poolsize >= deferred) ? (poolsize - deferred) : 0;\n\treturn (quota);\n}\n\nuint64_t\ndsl_pool_deferred_space(dsl_pool_t *dp)\n{\n\treturn (metaslab_class_get_deferred(spa_normal_class(dp->dp_spa)));\n}\n\nboolean_t\ndsl_pool_need_dirty_delay(dsl_pool_t *dp)\n{\n\tuint64_t delay_min_bytes =\n\t    zfs_dirty_data_max * zfs_delay_min_dirty_percent / 100;\n\n\t \n\treturn (dp->dp_dirty_total > delay_min_bytes);\n}\n\nstatic boolean_t\ndsl_pool_need_dirty_sync(dsl_pool_t *dp, uint64_t txg)\n{\n\tuint64_t dirty_min_bytes =\n\t    zfs_dirty_data_max * zfs_dirty_data_sync_percent / 100;\n\tuint64_t dirty = dp->dp_dirty_pertxg[txg & TXG_MASK];\n\n\treturn (dirty > dirty_min_bytes);\n}\n\nvoid\ndsl_pool_dirty_space(dsl_pool_t *dp, int64_t space, dmu_tx_t *tx)\n{\n\tif (space > 0) {\n\t\tmutex_enter(&dp->dp_lock);\n\t\tdp->dp_dirty_pertxg[tx->tx_txg & TXG_MASK] += space;\n\t\tdsl_pool_dirty_delta(dp, space);\n\t\tboolean_t needsync = !dmu_tx_is_syncing(tx) &&\n\t\t    dsl_pool_need_dirty_sync(dp, tx->tx_txg);\n\t\tmutex_exit(&dp->dp_lock);\n\n\t\tif (needsync)\n\t\t\ttxg_kick(dp, tx->tx_txg);\n\t}\n}\n\nvoid\ndsl_pool_undirty_space(dsl_pool_t *dp, int64_t space, uint64_t txg)\n{\n\tASSERT3S(space, >=, 0);\n\tif (space == 0)\n\t\treturn;\n\n\tmutex_enter(&dp->dp_lock);\n\tif (dp->dp_dirty_pertxg[txg & TXG_MASK] < space) {\n\t\t \n\t\tspace = dp->dp_dirty_pertxg[txg & TXG_MASK];\n\t}\n\tASSERT3U(dp->dp_dirty_pertxg[txg & TXG_MASK], >=, space);\n\tdp->dp_dirty_pertxg[txg & TXG_MASK] -= space;\n\tASSERT3U(dp->dp_dirty_total, >=, space);\n\tdsl_pool_dirty_delta(dp, -space);\n\tmutex_exit(&dp->dp_lock);\n}\n\nstatic int\nupgrade_clones_cb(dsl_pool_t *dp, dsl_dataset_t *hds, void *arg)\n{\n\tdmu_tx_t *tx = arg;\n\tdsl_dataset_t *ds, *prev = NULL;\n\tint err;\n\n\terr = dsl_dataset_hold_obj(dp, hds->ds_object, FTAG, &ds);\n\tif (err)\n\t\treturn (err);\n\n\twhile (dsl_dataset_phys(ds)->ds_prev_snap_obj != 0) {\n\t\terr = dsl_dataset_hold_obj(dp,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, FTAG, &prev);\n\t\tif (err) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (err);\n\t\t}\n\n\t\tif (dsl_dataset_phys(prev)->ds_next_snap_obj != ds->ds_object)\n\t\t\tbreak;\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\tds = prev;\n\t\tprev = NULL;\n\t}\n\n\tif (prev == NULL) {\n\t\tprev = dp->dp_origin_snap;\n\n\t\t \n\t\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\t\tASSERT0(dsl_dataset_phys(prev)->ds_bp.blk_birth);\n\t\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\n\t\t \n\t\tif (ds->ds_object == prev->ds_object) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (0);\n\t\t}\n\n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tdsl_dataset_phys(ds)->ds_prev_snap_obj = prev->ds_object;\n\t\tdsl_dataset_phys(ds)->ds_prev_snap_txg =\n\t\t    dsl_dataset_phys(prev)->ds_creation_txg;\n\n\t\tdmu_buf_will_dirty(ds->ds_dir->dd_dbuf, tx);\n\t\tdsl_dir_phys(ds->ds_dir)->dd_origin_obj = prev->ds_object;\n\n\t\tdmu_buf_will_dirty(prev->ds_dbuf, tx);\n\t\tdsl_dataset_phys(prev)->ds_num_children++;\n\n\t\tif (dsl_dataset_phys(ds)->ds_next_snap_obj == 0) {\n\t\t\tASSERT(ds->ds_prev == NULL);\n\t\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj,\n\t\t\t    ds, &ds->ds_prev));\n\t\t}\n\t}\n\n\tASSERT3U(dsl_dir_phys(ds->ds_dir)->dd_origin_obj, ==, prev->ds_object);\n\tASSERT3U(dsl_dataset_phys(ds)->ds_prev_snap_obj, ==, prev->ds_object);\n\n\tif (dsl_dataset_phys(prev)->ds_next_clones_obj == 0) {\n\t\tdmu_buf_will_dirty(prev->ds_dbuf, tx);\n\t\tdsl_dataset_phys(prev)->ds_next_clones_obj =\n\t\t    zap_create(dp->dp_meta_objset,\n\t\t    DMU_OT_NEXT_CLONES, DMU_OT_NONE, 0, tx);\n\t}\n\tVERIFY0(zap_add_int(dp->dp_meta_objset,\n\t    dsl_dataset_phys(prev)->ds_next_clones_obj, ds->ds_object, tx));\n\n\tdsl_dataset_rele(ds, FTAG);\n\tif (prev != dp->dp_origin_snap)\n\t\tdsl_dataset_rele(prev, FTAG);\n\treturn (0);\n}\n\nvoid\ndsl_pool_upgrade_clones(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dp->dp_origin_snap != NULL);\n\n\tVERIFY0(dmu_objset_find_dp(dp, dp->dp_root_dir_obj, upgrade_clones_cb,\n\t    tx, DS_FIND_CHILDREN | DS_FIND_SERIALIZE));\n}\n\nstatic int\nupgrade_dir_clones_cb(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)\n{\n\tdmu_tx_t *tx = arg;\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tif (dsl_dir_phys(ds->ds_dir)->dd_origin_obj != 0) {\n\t\tdsl_dataset_t *origin;\n\n\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t    dsl_dir_phys(ds->ds_dir)->dd_origin_obj, FTAG, &origin));\n\n\t\tif (dsl_dir_phys(origin->ds_dir)->dd_clones == 0) {\n\t\t\tdmu_buf_will_dirty(origin->ds_dir->dd_dbuf, tx);\n\t\t\tdsl_dir_phys(origin->ds_dir)->dd_clones =\n\t\t\t    zap_create(mos, DMU_OT_DSL_CLONES, DMU_OT_NONE,\n\t\t\t    0, tx);\n\t\t}\n\n\t\tVERIFY0(zap_add_int(dp->dp_meta_objset,\n\t\t    dsl_dir_phys(origin->ds_dir)->dd_clones,\n\t\t    ds->ds_object, tx));\n\n\t\tdsl_dataset_rele(origin, FTAG);\n\t}\n\treturn (0);\n}\n\nvoid\ndsl_pool_upgrade_dir_clones(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tuint64_t obj;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\t(void) dsl_dir_create_sync(dp, dp->dp_root_dir, FREE_DIR_NAME, tx);\n\tVERIFY0(dsl_pool_open_special_dir(dp,\n\t    FREE_DIR_NAME, &dp->dp_free_dir));\n\n\t \n\tobj = dmu_object_alloc(dp->dp_meta_objset, DMU_OT_BPOBJ,\n\t    SPA_OLD_MAXBLOCKSIZE, DMU_OT_BPOBJ_HDR, sizeof (bpobj_phys_t), tx);\n\tVERIFY0(zap_add(dp->dp_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_FREE_BPOBJ, sizeof (uint64_t), 1, &obj, tx));\n\tVERIFY0(bpobj_open(&dp->dp_free_bpobj, dp->dp_meta_objset, obj));\n\n\tVERIFY0(dmu_objset_find_dp(dp, dp->dp_root_dir_obj,\n\t    upgrade_dir_clones_cb, tx, DS_FIND_CHILDREN | DS_FIND_SERIALIZE));\n}\n\nvoid\ndsl_pool_create_origin(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tuint64_t dsobj;\n\tdsl_dataset_t *ds;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dp->dp_origin_snap == NULL);\n\tASSERT(rrw_held(&dp->dp_config_rwlock, RW_WRITER));\n\n\t \n\tdsobj = dsl_dataset_create_sync(dp->dp_root_dir, ORIGIN_DIR_NAME,\n\t    NULL, 0, kcred, NULL, tx);\n\tVERIFY0(dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds));\n\tdsl_dataset_snapshot_sync_impl(ds, ORIGIN_DIR_NAME, tx);\n\tVERIFY0(dsl_dataset_hold_obj(dp, dsl_dataset_phys(ds)->ds_prev_snap_obj,\n\t    dp, &dp->dp_origin_snap));\n\tdsl_dataset_rele(ds, FTAG);\n}\n\ntaskq_t *\ndsl_pool_zrele_taskq(dsl_pool_t *dp)\n{\n\treturn (dp->dp_zrele_taskq);\n}\n\ntaskq_t *\ndsl_pool_unlinked_drain_taskq(dsl_pool_t *dp)\n{\n\treturn (dp->dp_unlinked_drain_taskq);\n}\n\n \nvoid\ndsl_pool_clean_tmp_userrefs(dsl_pool_t *dp)\n{\n\tzap_attribute_t za;\n\tzap_cursor_t zc;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t zapobj = dp->dp_tmp_userrefs_obj;\n\tnvlist_t *holds;\n\n\tif (zapobj == 0)\n\t\treturn;\n\tASSERT(spa_version(dp->dp_spa) >= SPA_VERSION_USERREFS);\n\n\tholds = fnvlist_alloc();\n\n\tfor (zap_cursor_init(&zc, mos, zapobj);\n\t    zap_cursor_retrieve(&zc, &za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tchar *htag;\n\t\tnvlist_t *tags;\n\n\t\thtag = strchr(za.za_name, '-');\n\t\t*htag = '\\0';\n\t\t++htag;\n\t\tif (nvlist_lookup_nvlist(holds, za.za_name, &tags) != 0) {\n\t\t\ttags = fnvlist_alloc();\n\t\t\tfnvlist_add_boolean(tags, htag);\n\t\t\tfnvlist_add_nvlist(holds, za.za_name, tags);\n\t\t\tfnvlist_free(tags);\n\t\t} else {\n\t\t\tfnvlist_add_boolean(tags, htag);\n\t\t}\n\t}\n\tdsl_dataset_user_release_tmp(dp, holds);\n\tfnvlist_free(holds);\n\tzap_cursor_fini(&zc);\n}\n\n \nstatic void\ndsl_pool_user_hold_create_obj(dsl_pool_t *dp, dmu_tx_t *tx)\n{\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tASSERT(dp->dp_tmp_userrefs_obj == 0);\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tdp->dp_tmp_userrefs_obj = zap_create_link(mos, DMU_OT_USERREFS,\n\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_TMP_USERREFS, tx);\n}\n\nstatic int\ndsl_pool_user_hold_rele_impl(dsl_pool_t *dp, uint64_t dsobj,\n    const char *tag, uint64_t now, dmu_tx_t *tx, boolean_t holding)\n{\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t zapobj = dp->dp_tmp_userrefs_obj;\n\tchar *name;\n\tint error;\n\n\tASSERT(spa_version(dp->dp_spa) >= SPA_VERSION_USERREFS);\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\t \n\tif (zapobj == 0) {\n\t\tif (holding) {\n\t\t\tdsl_pool_user_hold_create_obj(dp, tx);\n\t\t\tzapobj = dp->dp_tmp_userrefs_obj;\n\t\t} else {\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\t}\n\n\tname = kmem_asprintf(\"%llx-%s\", (u_longlong_t)dsobj, tag);\n\tif (holding)\n\t\terror = zap_add(mos, zapobj, name, 8, 1, &now, tx);\n\telse\n\t\terror = zap_remove(mos, zapobj, name, tx);\n\tkmem_strfree(name);\n\n\treturn (error);\n}\n\n \nint\ndsl_pool_user_hold(dsl_pool_t *dp, uint64_t dsobj, const char *tag,\n    uint64_t now, dmu_tx_t *tx)\n{\n\treturn (dsl_pool_user_hold_rele_impl(dp, dsobj, tag, now, tx, B_TRUE));\n}\n\n \nint\ndsl_pool_user_release(dsl_pool_t *dp, uint64_t dsobj, const char *tag,\n    dmu_tx_t *tx)\n{\n\treturn (dsl_pool_user_hold_rele_impl(dp, dsobj, tag, 0,\n\t    tx, B_FALSE));\n}\n\n \n\nint\ndsl_pool_hold(const char *name, const void *tag, dsl_pool_t **dp)\n{\n\tspa_t *spa;\n\tint error;\n\n\terror = spa_open(name, &spa, tag);\n\tif (error == 0) {\n\t\t*dp = spa_get_dsl(spa);\n\t\tdsl_pool_config_enter(*dp, tag);\n\t}\n\treturn (error);\n}\n\nvoid\ndsl_pool_rele(dsl_pool_t *dp, const void *tag)\n{\n\tdsl_pool_config_exit(dp, tag);\n\tspa_close(dp->dp_spa, tag);\n}\n\nvoid\ndsl_pool_config_enter(dsl_pool_t *dp, const void *tag)\n{\n\t \n\tASSERT(!rrw_held(&dp->dp_config_rwlock, RW_READER));\n\trrw_enter(&dp->dp_config_rwlock, RW_READER, tag);\n}\n\nvoid\ndsl_pool_config_enter_prio(dsl_pool_t *dp, const void *tag)\n{\n\tASSERT(!rrw_held(&dp->dp_config_rwlock, RW_READER));\n\trrw_enter_read_prio(&dp->dp_config_rwlock, tag);\n}\n\nvoid\ndsl_pool_config_exit(dsl_pool_t *dp, const void *tag)\n{\n\trrw_exit(&dp->dp_config_rwlock, tag);\n}\n\nboolean_t\ndsl_pool_config_held(dsl_pool_t *dp)\n{\n\treturn (RRW_LOCK_HELD(&dp->dp_config_rwlock));\n}\n\nboolean_t\ndsl_pool_config_held_writer(dsl_pool_t *dp)\n{\n\treturn (RRW_WRITE_HELD(&dp->dp_config_rwlock));\n}\n\nEXPORT_SYMBOL(dsl_pool_config_enter);\nEXPORT_SYMBOL(dsl_pool_config_exit);\n\n \nZFS_MODULE_PARAM(zfs, zfs_, dirty_data_max_percent, UINT, ZMOD_RD,\n\t\"Max percent of RAM allowed to be dirty\");\n\n \nZFS_MODULE_PARAM(zfs, zfs_, dirty_data_max_max_percent, UINT, ZMOD_RD,\n\t\"zfs_dirty_data_max upper bound as % of RAM\");\n\nZFS_MODULE_PARAM(zfs, zfs_, delay_min_dirty_percent, UINT, ZMOD_RW,\n\t\"Transaction delay threshold\");\n\nZFS_MODULE_PARAM(zfs, zfs_, dirty_data_max, U64, ZMOD_RW,\n\t\"Determines the dirty space limit\");\n\nZFS_MODULE_PARAM(zfs, zfs_, wrlog_data_max, U64, ZMOD_RW,\n\t\"The size limit of write-transaction zil log data\");\n\n \nZFS_MODULE_PARAM(zfs, zfs_, dirty_data_max_max, U64, ZMOD_RD,\n\t\"zfs_dirty_data_max upper bound in bytes\");\n\nZFS_MODULE_PARAM(zfs, zfs_, dirty_data_sync_percent, UINT, ZMOD_RW,\n\t\"Dirty data txg sync threshold as a percentage of zfs_dirty_data_max\");\n\nZFS_MODULE_PARAM(zfs, zfs_, delay_scale, U64, ZMOD_RW,\n\t\"How quickly delay approaches infinity\");\n\nZFS_MODULE_PARAM(zfs, zfs_, sync_taskq_batch_pct, INT, ZMOD_RW,\n\t\"Max percent of CPUs that are used to sync dirty data\");\n\nZFS_MODULE_PARAM(zfs_zil, zfs_zil_, clean_taskq_nthr_pct, INT, ZMOD_RW,\n\t\"Max percent of CPUs that are used per dp_sync_taskq\");\n\nZFS_MODULE_PARAM(zfs_zil, zfs_zil_, clean_taskq_minalloc, INT, ZMOD_RW,\n\t\"Number of taskq entries that are pre-populated\");\n\nZFS_MODULE_PARAM(zfs_zil, zfs_zil_, clean_taskq_maxalloc, INT, ZMOD_RW,\n\t\"Max number of taskq entries that are cached\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}