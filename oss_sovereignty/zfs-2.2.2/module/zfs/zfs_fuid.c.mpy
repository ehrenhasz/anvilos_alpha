{
  "module_name": "zfs_fuid.c",
  "hash_id": "47bf8c35b347e2a0332f71c200d5c648140c82b5a42f5614b17ed45ffc43eb21",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_fuid.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/dmu.h>\n#include <sys/avl.h>\n#include <sys/zap.h>\n#include <sys/nvpair.h>\n#ifdef _KERNEL\n#include <sys/sid.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n#endif\n#include <sys/zfs_fuid.h>\n\n \n\n#define\tFUID_IDX\t\"fuid_idx\"\n#define\tFUID_DOMAIN\t\"fuid_domain\"\n#define\tFUID_OFFSET\t\"fuid_offset\"\n#define\tFUID_NVP_ARRAY\t\"fuid_nvlist\"\n\ntypedef struct fuid_domain {\n\tavl_node_t\tf_domnode;\n\tavl_node_t\tf_idxnode;\n\tksiddomain_t\t*f_ksid;\n\tuint64_t\tf_idx;\n} fuid_domain_t;\n\nstatic const char *const nulldomain = \"\";\n\n \nstatic int\nidx_compare(const void *arg1, const void *arg2)\n{\n\tconst fuid_domain_t *node1 = (const fuid_domain_t *)arg1;\n\tconst fuid_domain_t *node2 = (const fuid_domain_t *)arg2;\n\n\treturn (TREE_CMP(node1->f_idx, node2->f_idx));\n}\n\n \nstatic int\ndomain_compare(const void *arg1, const void *arg2)\n{\n\tconst fuid_domain_t *node1 = (const fuid_domain_t *)arg1;\n\tconst fuid_domain_t *node2 = (const fuid_domain_t *)arg2;\n\tint val;\n\n\tval = strcmp(node1->f_ksid->kd_name, node2->f_ksid->kd_name);\n\n\treturn (TREE_ISIGN(val));\n}\n\nvoid\nzfs_fuid_avl_tree_create(avl_tree_t *idx_tree, avl_tree_t *domain_tree)\n{\n\tavl_create(idx_tree, idx_compare,\n\t    sizeof (fuid_domain_t), offsetof(fuid_domain_t, f_idxnode));\n\tavl_create(domain_tree, domain_compare,\n\t    sizeof (fuid_domain_t), offsetof(fuid_domain_t, f_domnode));\n}\n\n \nuint64_t\nzfs_fuid_table_load(objset_t *os, uint64_t fuid_obj, avl_tree_t *idx_tree,\n    avl_tree_t *domain_tree)\n{\n\tdmu_buf_t *db;\n\tuint64_t fuid_size;\n\n\tASSERT(fuid_obj != 0);\n\tVERIFY(0 == dmu_bonus_hold(os, fuid_obj,\n\t    FTAG, &db));\n\tfuid_size = *(uint64_t *)db->db_data;\n\tdmu_buf_rele(db, FTAG);\n\n\tif (fuid_size)  {\n\t\tnvlist_t **fuidnvp;\n\t\tnvlist_t *nvp = NULL;\n\t\tuint_t count;\n\t\tchar *packed;\n\t\tint i;\n\n\t\tpacked = kmem_alloc(fuid_size, KM_SLEEP);\n\t\tVERIFY(dmu_read(os, fuid_obj, 0,\n\t\t    fuid_size, packed, DMU_READ_PREFETCH) == 0);\n\t\tVERIFY(nvlist_unpack(packed, fuid_size,\n\t\t    &nvp, 0) == 0);\n\t\tVERIFY(nvlist_lookup_nvlist_array(nvp, FUID_NVP_ARRAY,\n\t\t    &fuidnvp, &count) == 0);\n\n\t\tfor (i = 0; i != count; i++) {\n\t\t\tfuid_domain_t *domnode;\n\t\t\tconst char *domain;\n\t\t\tuint64_t idx;\n\n\t\t\tVERIFY(nvlist_lookup_string(fuidnvp[i], FUID_DOMAIN,\n\t\t\t    &domain) == 0);\n\t\t\tVERIFY(nvlist_lookup_uint64(fuidnvp[i], FUID_IDX,\n\t\t\t    &idx) == 0);\n\n\t\t\tdomnode = kmem_alloc(sizeof (fuid_domain_t), KM_SLEEP);\n\n\t\t\tdomnode->f_idx = idx;\n\t\t\tdomnode->f_ksid = ksid_lookupdomain(domain);\n\t\t\tavl_add(idx_tree, domnode);\n\t\t\tavl_add(domain_tree, domnode);\n\t\t}\n\t\tnvlist_free(nvp);\n\t\tkmem_free(packed, fuid_size);\n\t}\n\treturn (fuid_size);\n}\n\nvoid\nzfs_fuid_table_destroy(avl_tree_t *idx_tree, avl_tree_t *domain_tree)\n{\n\tfuid_domain_t *domnode;\n\tvoid *cookie;\n\n\tcookie = NULL;\n\twhile ((domnode = avl_destroy_nodes(domain_tree, &cookie)))\n\t\tksiddomain_rele(domnode->f_ksid);\n\n\tavl_destroy(domain_tree);\n\tcookie = NULL;\n\twhile ((domnode = avl_destroy_nodes(idx_tree, &cookie)))\n\t\tkmem_free(domnode, sizeof (fuid_domain_t));\n\tavl_destroy(idx_tree);\n}\n\nconst char *\nzfs_fuid_idx_domain(avl_tree_t *idx_tree, uint32_t idx)\n{\n\tfuid_domain_t searchnode, *findnode;\n\tavl_index_t loc;\n\n\tsearchnode.f_idx = idx;\n\n\tfindnode = avl_find(idx_tree, &searchnode, &loc);\n\n\treturn (findnode ? findnode->f_ksid->kd_name : nulldomain);\n}\n\n#ifdef _KERNEL\n \nstatic void\nzfs_fuid_init(zfsvfs_t *zfsvfs)\n{\n\trw_enter(&zfsvfs->z_fuid_lock, RW_WRITER);\n\n\tif (zfsvfs->z_fuid_loaded) {\n\t\trw_exit(&zfsvfs->z_fuid_lock);\n\t\treturn;\n\t}\n\n\tzfs_fuid_avl_tree_create(&zfsvfs->z_fuid_idx, &zfsvfs->z_fuid_domain);\n\n\t(void) zap_lookup(zfsvfs->z_os, MASTER_NODE_OBJ,\n\t    ZFS_FUID_TABLES, 8, 1, &zfsvfs->z_fuid_obj);\n\tif (zfsvfs->z_fuid_obj != 0) {\n\t\tzfsvfs->z_fuid_size = zfs_fuid_table_load(zfsvfs->z_os,\n\t\t    zfsvfs->z_fuid_obj, &zfsvfs->z_fuid_idx,\n\t\t    &zfsvfs->z_fuid_domain);\n\t}\n\n\tzfsvfs->z_fuid_loaded = B_TRUE;\n\trw_exit(&zfsvfs->z_fuid_lock);\n}\n\n \nvoid\nzfs_fuid_sync(zfsvfs_t *zfsvfs, dmu_tx_t *tx)\n{\n\tnvlist_t *nvp;\n\tnvlist_t **fuids;\n\tsize_t nvsize = 0;\n\tchar *packed;\n\tdmu_buf_t *db;\n\tfuid_domain_t *domnode;\n\tint numnodes;\n\tint i;\n\n\tif (!zfsvfs->z_fuid_dirty) {\n\t\treturn;\n\t}\n\n\trw_enter(&zfsvfs->z_fuid_lock, RW_WRITER);\n\n\t \n\tif (zfsvfs->z_fuid_obj == 0) {\n\t\tzfsvfs->z_fuid_obj = dmu_object_alloc(zfsvfs->z_os,\n\t\t    DMU_OT_FUID, 1 << 14, DMU_OT_FUID_SIZE,\n\t\t    sizeof (uint64_t), tx);\n\t\tVERIFY(zap_add(zfsvfs->z_os, MASTER_NODE_OBJ,\n\t\t    ZFS_FUID_TABLES, sizeof (uint64_t), 1,\n\t\t    &zfsvfs->z_fuid_obj, tx) == 0);\n\t}\n\n\tVERIFY(nvlist_alloc(&nvp, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\tnumnodes = avl_numnodes(&zfsvfs->z_fuid_idx);\n\tfuids = kmem_alloc(numnodes * sizeof (void *), KM_SLEEP);\n\tfor (i = 0, domnode = avl_first(&zfsvfs->z_fuid_domain); domnode; i++,\n\t    domnode = AVL_NEXT(&zfsvfs->z_fuid_domain, domnode)) {\n\t\tVERIFY(nvlist_alloc(&fuids[i], NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\t\tVERIFY(nvlist_add_uint64(fuids[i], FUID_IDX,\n\t\t    domnode->f_idx) == 0);\n\t\tVERIFY(nvlist_add_uint64(fuids[i], FUID_OFFSET, 0) == 0);\n\t\tVERIFY(nvlist_add_string(fuids[i], FUID_DOMAIN,\n\t\t    domnode->f_ksid->kd_name) == 0);\n\t}\n\tfnvlist_add_nvlist_array(nvp, FUID_NVP_ARRAY,\n\t    (const nvlist_t * const *)fuids, numnodes);\n\tfor (i = 0; i != numnodes; i++)\n\t\tnvlist_free(fuids[i]);\n\tkmem_free(fuids, numnodes * sizeof (void *));\n\tVERIFY(nvlist_size(nvp, &nvsize, NV_ENCODE_XDR) == 0);\n\tpacked = kmem_alloc(nvsize, KM_SLEEP);\n\tVERIFY(nvlist_pack(nvp, &packed, &nvsize,\n\t    NV_ENCODE_XDR, KM_SLEEP) == 0);\n\tnvlist_free(nvp);\n\tzfsvfs->z_fuid_size = nvsize;\n\tdmu_write(zfsvfs->z_os, zfsvfs->z_fuid_obj, 0,\n\t    zfsvfs->z_fuid_size, packed, tx);\n\tkmem_free(packed, zfsvfs->z_fuid_size);\n\tVERIFY(0 == dmu_bonus_hold(zfsvfs->z_os, zfsvfs->z_fuid_obj,\n\t    FTAG, &db));\n\tdmu_buf_will_dirty(db, tx);\n\t*(uint64_t *)db->db_data = zfsvfs->z_fuid_size;\n\tdmu_buf_rele(db, FTAG);\n\n\tzfsvfs->z_fuid_dirty = B_FALSE;\n\trw_exit(&zfsvfs->z_fuid_lock);\n}\n\n \nstatic int\nzfs_fuid_find_by_domain(zfsvfs_t *zfsvfs, const char *domain,\n    const char **retdomain, boolean_t addok)\n{\n\tfuid_domain_t searchnode, *findnode;\n\tavl_index_t loc;\n\tkrw_t rw = RW_READER;\n\n\t \n\tif (domain[0] == '\\0') {\n\t\tif (retdomain)\n\t\t\t*retdomain = nulldomain;\n\t\treturn (0);\n\t}\n\n\tsearchnode.f_ksid = ksid_lookupdomain(domain);\n\tif (retdomain)\n\t\t*retdomain = searchnode.f_ksid->kd_name;\n\tif (!zfsvfs->z_fuid_loaded)\n\t\tzfs_fuid_init(zfsvfs);\n\nretry:\n\trw_enter(&zfsvfs->z_fuid_lock, rw);\n\tfindnode = avl_find(&zfsvfs->z_fuid_domain, &searchnode, &loc);\n\n\tif (findnode) {\n\t\trw_exit(&zfsvfs->z_fuid_lock);\n\t\tksiddomain_rele(searchnode.f_ksid);\n\t\treturn (findnode->f_idx);\n\t} else if (addok) {\n\t\tfuid_domain_t *domnode;\n\t\tuint64_t retidx;\n\n\t\tif (rw == RW_READER && !rw_tryupgrade(&zfsvfs->z_fuid_lock)) {\n\t\t\trw_exit(&zfsvfs->z_fuid_lock);\n\t\t\trw = RW_WRITER;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tdomnode = kmem_alloc(sizeof (fuid_domain_t), KM_SLEEP);\n\t\tdomnode->f_ksid = searchnode.f_ksid;\n\n\t\tretidx = domnode->f_idx = avl_numnodes(&zfsvfs->z_fuid_idx) + 1;\n\n\t\tavl_add(&zfsvfs->z_fuid_domain, domnode);\n\t\tavl_add(&zfsvfs->z_fuid_idx, domnode);\n\t\tzfsvfs->z_fuid_dirty = B_TRUE;\n\t\trw_exit(&zfsvfs->z_fuid_lock);\n\t\treturn (retidx);\n\t} else {\n\t\trw_exit(&zfsvfs->z_fuid_lock);\n\t\treturn (-1);\n\t}\n}\n\n \nconst char *\nzfs_fuid_find_by_idx(zfsvfs_t *zfsvfs, uint32_t idx)\n{\n\tconst char *domain;\n\n\tif (idx == 0 || !zfsvfs->z_use_fuids)\n\t\treturn (NULL);\n\n\tif (!zfsvfs->z_fuid_loaded)\n\t\tzfs_fuid_init(zfsvfs);\n\n\trw_enter(&zfsvfs->z_fuid_lock, RW_READER);\n\n\tif (zfsvfs->z_fuid_obj || zfsvfs->z_fuid_dirty)\n\t\tdomain = zfs_fuid_idx_domain(&zfsvfs->z_fuid_idx, idx);\n\telse\n\t\tdomain = nulldomain;\n\trw_exit(&zfsvfs->z_fuid_lock);\n\n\tASSERT(domain);\n\treturn (domain);\n}\n\nvoid\nzfs_fuid_map_ids(znode_t *zp, cred_t *cr, uid_t *uidp, uid_t *gidp)\n{\n\t*uidp = zfs_fuid_map_id(ZTOZSB(zp), KUID_TO_SUID(ZTOUID(zp)),\n\t    cr, ZFS_OWNER);\n\t*gidp = zfs_fuid_map_id(ZTOZSB(zp), KGID_TO_SGID(ZTOGID(zp)),\n\t    cr, ZFS_GROUP);\n}\n\n#ifdef __FreeBSD__\nuid_t\nzfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n    cred_t *cr, zfs_fuid_type_t type)\n{\n\tuint32_t index = FUID_INDEX(fuid);\n\n\tif (index == 0)\n\t\treturn (fuid);\n\n\treturn (UID_NOBODY);\n}\n#elif defined(__linux__)\nuid_t\nzfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n    cred_t *cr, zfs_fuid_type_t type)\n{\n\t \n\treturn (fuid);\n}\n\n#else\nuid_t\nzfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n    cred_t *cr, zfs_fuid_type_t type)\n{\n\tuint32_t index = FUID_INDEX(fuid);\n\tconst char *domain;\n\tuid_t id;\n\n\tif (index == 0)\n\t\treturn (fuid);\n\n\tdomain = zfs_fuid_find_by_idx(zfsvfs, index);\n\tASSERT(domain != NULL);\n\n\tif (type == ZFS_OWNER || type == ZFS_ACE_USER) {\n\t\t(void) kidmap_getuidbysid(crgetzone(cr), domain,\n\t\t    FUID_RID(fuid), &id);\n\t} else {\n\t\t(void) kidmap_getgidbysid(crgetzone(cr), domain,\n\t\t    FUID_RID(fuid), &id);\n\t}\n\treturn (id);\n}\n#endif\n\n \nvoid\nzfs_fuid_node_add(zfs_fuid_info_t **fuidpp, const char *domain, uint32_t rid,\n    uint64_t idx, uint64_t id, zfs_fuid_type_t type)\n{\n\tzfs_fuid_t *fuid;\n\tzfs_fuid_domain_t *fuid_domain;\n\tzfs_fuid_info_t *fuidp;\n\tuint64_t fuididx;\n\tboolean_t found = B_FALSE;\n\n\tif (*fuidpp == NULL)\n\t\t*fuidpp = zfs_fuid_info_alloc();\n\n\tfuidp = *fuidpp;\n\t \n\n\tfor (fuididx = 1, fuid_domain = list_head(&fuidp->z_domains);\n\t    fuid_domain; fuid_domain = list_next(&fuidp->z_domains,\n\t    fuid_domain), fuididx++) {\n\t\tif (idx == fuid_domain->z_domidx) {\n\t\t\tfound = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tfuid_domain = kmem_alloc(sizeof (zfs_fuid_domain_t), KM_SLEEP);\n\t\tfuid_domain->z_domain = domain;\n\t\tfuid_domain->z_domidx = idx;\n\t\tlist_insert_tail(&fuidp->z_domains, fuid_domain);\n\t\tfuidp->z_domain_str_sz += strlen(domain) + 1;\n\t\tfuidp->z_domain_cnt++;\n\t}\n\n\tif (type == ZFS_ACE_USER || type == ZFS_ACE_GROUP) {\n\n\t\t \n\n\t\tfuid = kmem_alloc(sizeof (zfs_fuid_t), KM_SLEEP);\n\t\tfuid->z_id = id;\n\t\tfuid->z_domidx = idx;\n\t\tfuid->z_logfuid = FUID_ENCODE(fuididx, rid);\n\n\t\tlist_insert_tail(&fuidp->z_fuids, fuid);\n\t\tfuidp->z_fuid_cnt++;\n\t} else {\n\t\tif (type == ZFS_OWNER)\n\t\t\tfuidp->z_fuid_owner = FUID_ENCODE(fuididx, rid);\n\t\telse\n\t\t\tfuidp->z_fuid_group = FUID_ENCODE(fuididx, rid);\n\t}\n}\n\n#ifdef HAVE_KSID\n \nuint64_t\nzfs_fuid_create_cred(zfsvfs_t *zfsvfs, zfs_fuid_type_t type,\n    cred_t *cr, zfs_fuid_info_t **fuidp)\n{\n\tuint64_t\tidx;\n\tksid_t\t\t*ksid;\n\tuint32_t\trid;\n\tconst char\t*kdomain, *domain;\n\tuid_t\t\tid;\n\n\tVERIFY(type == ZFS_OWNER || type == ZFS_GROUP);\n\n\tksid = crgetsid(cr, (type == ZFS_OWNER) ? KSID_OWNER : KSID_GROUP);\n\n\tif (!zfsvfs->z_use_fuids || (ksid == NULL)) {\n\t\tid = (type == ZFS_OWNER) ? crgetuid(cr) : crgetgid(cr);\n\n\t\tif (IS_EPHEMERAL(id))\n\t\t\treturn ((type == ZFS_OWNER) ? UID_NOBODY : GID_NOBODY);\n\n\t\treturn ((uint64_t)id);\n\t}\n\n\t \n\tid = (type == ZFS_OWNER) ? ksid_getid(ksid) : crgetgid(cr);\n\n\tif (!IS_EPHEMERAL(id))\n\t\treturn ((uint64_t)id);\n\n\tif (type == ZFS_GROUP)\n\t\tid = ksid_getid(ksid);\n\n\trid = ksid_getrid(ksid);\n\tdomain = ksid_getdomain(ksid);\n\n\tidx = zfs_fuid_find_by_domain(zfsvfs, domain, &kdomain, B_TRUE);\n\n\tzfs_fuid_node_add(fuidp, kdomain, rid, idx, id, type);\n\n\treturn (FUID_ENCODE(idx, rid));\n}\n#endif  \n\n \nuint64_t\nzfs_fuid_create(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr,\n    zfs_fuid_type_t type, zfs_fuid_info_t **fuidpp)\n{\n#ifdef HAVE_KSID\n\tconst char *domain, *kdomain;\n\tuint32_t fuid_idx = FUID_INDEX(id);\n\tuint32_t rid = 0;\n\tidmap_stat status;\n\tuint64_t idx = UID_NOBODY;\n\tzfs_fuid_t *zfuid = NULL;\n\tzfs_fuid_info_t *fuidp = NULL;\n\n\t \n\n\tif (!zfsvfs->z_use_fuids || !IS_EPHEMERAL(id) || fuid_idx != 0)\n\t\treturn (id);\n\n\tif (zfsvfs->z_replay) {\n\t\tfuidp = zfsvfs->z_fuid_replay;\n\n\t\t \n\t\tif (fuidp == NULL)\n\t\t\treturn (UID_NOBODY);\n\n\t\tVERIFY3U(type, >=, ZFS_OWNER);\n\t\tVERIFY3U(type, <=, ZFS_ACE_GROUP);\n\n\t\tswitch (type) {\n\t\tcase ZFS_ACE_USER:\n\t\tcase ZFS_ACE_GROUP:\n\t\t\tzfuid = list_head(&fuidp->z_fuids);\n\t\t\trid = FUID_RID(zfuid->z_logfuid);\n\t\t\tidx = FUID_INDEX(zfuid->z_logfuid);\n\t\t\tbreak;\n\t\tcase ZFS_OWNER:\n\t\t\trid = FUID_RID(fuidp->z_fuid_owner);\n\t\t\tidx = FUID_INDEX(fuidp->z_fuid_owner);\n\t\t\tbreak;\n\t\tcase ZFS_GROUP:\n\t\t\trid = FUID_RID(fuidp->z_fuid_group);\n\t\t\tidx = FUID_INDEX(fuidp->z_fuid_group);\n\t\t\tbreak;\n\t\t}\n\t\tdomain = fuidp->z_domain_table[idx - 1];\n\t} else {\n\t\tif (type == ZFS_OWNER || type == ZFS_ACE_USER)\n\t\t\tstatus = kidmap_getsidbyuid(crgetzone(cr), id,\n\t\t\t    &domain, &rid);\n\t\telse\n\t\t\tstatus = kidmap_getsidbygid(crgetzone(cr), id,\n\t\t\t    &domain, &rid);\n\n\t\tif (status != 0) {\n\t\t\t \n\t\t\trid = UID_NOBODY;\n\t\t\tdomain = nulldomain;\n\t\t}\n\t}\n\n\tidx = zfs_fuid_find_by_domain(zfsvfs, domain, &kdomain, B_TRUE);\n\n\tif (!zfsvfs->z_replay)\n\t\tzfs_fuid_node_add(fuidpp, kdomain,\n\t\t    rid, idx, id, type);\n\telse if (zfuid != NULL) {\n\t\tlist_remove(&fuidp->z_fuids, zfuid);\n\t\tkmem_free(zfuid, sizeof (zfs_fuid_t));\n\t}\n\treturn (FUID_ENCODE(idx, rid));\n#else\n\t \n\treturn (id);\n#endif\n}\n\nvoid\nzfs_fuid_destroy(zfsvfs_t *zfsvfs)\n{\n\trw_enter(&zfsvfs->z_fuid_lock, RW_WRITER);\n\tif (!zfsvfs->z_fuid_loaded) {\n\t\trw_exit(&zfsvfs->z_fuid_lock);\n\t\treturn;\n\t}\n\tzfs_fuid_table_destroy(&zfsvfs->z_fuid_idx, &zfsvfs->z_fuid_domain);\n\trw_exit(&zfsvfs->z_fuid_lock);\n}\n\n \nzfs_fuid_info_t *\nzfs_fuid_info_alloc(void)\n{\n\tzfs_fuid_info_t *fuidp;\n\n\tfuidp = kmem_zalloc(sizeof (zfs_fuid_info_t), KM_SLEEP);\n\tlist_create(&fuidp->z_domains, sizeof (zfs_fuid_domain_t),\n\t    offsetof(zfs_fuid_domain_t, z_next));\n\tlist_create(&fuidp->z_fuids, sizeof (zfs_fuid_t),\n\t    offsetof(zfs_fuid_t, z_next));\n\treturn (fuidp);\n}\n\n \nvoid\nzfs_fuid_info_free(zfs_fuid_info_t *fuidp)\n{\n\tzfs_fuid_t *zfuid;\n\tzfs_fuid_domain_t *zdomain;\n\n\twhile ((zfuid = list_remove_head(&fuidp->z_fuids)) != NULL)\n\t\tkmem_free(zfuid, sizeof (zfs_fuid_t));\n\n\tif (fuidp->z_domain_table != NULL)\n\t\tkmem_free(fuidp->z_domain_table,\n\t\t    (sizeof (char *)) * fuidp->z_domain_cnt);\n\n\twhile ((zdomain = list_remove_head(&fuidp->z_domains)) != NULL)\n\t\tkmem_free(zdomain, sizeof (zfs_fuid_domain_t));\n\n\tkmem_free(fuidp, sizeof (zfs_fuid_info_t));\n}\n\n \nboolean_t\nzfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n\tuid_t\t\tgid;\n\n#ifdef illumos\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\tif (idx == 0) {\n\t\t\t\tif (id != IDMAP_WK_CREATOR_GROUP_GID &&\n\t\t\t\t    id == ksid_groups[i].ks_id) {\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *domain;\n\n\t\t\t\tdomain = zfs_fuid_find_by_idx(zfsvfs, idx);\n\t\t\t\tASSERT(domain != NULL);\n\n\t\t\t\tif (strcmp(domain,\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\n\t \n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n}\n\nvoid\nzfs_fuid_txhold(zfsvfs_t *zfsvfs, dmu_tx_t *tx)\n{\n\tif (zfsvfs->z_fuid_obj == 0) {\n\t\tdmu_tx_hold_bonus(tx, DMU_NEW_OBJECT);\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,\n\t\t    FUID_SIZE_ESTIMATE(zfsvfs));\n\t\tdmu_tx_hold_zap(tx, MASTER_NODE_OBJ, FALSE, NULL);\n\t} else {\n\t\tdmu_tx_hold_bonus(tx, zfsvfs->z_fuid_obj);\n\t\tdmu_tx_hold_write(tx, zfsvfs->z_fuid_obj, 0,\n\t\t    FUID_SIZE_ESTIMATE(zfsvfs));\n\t}\n}\n\n \nint\nzfs_id_to_fuidstr(zfsvfs_t *zfsvfs, const char *domain, uid_t rid,\n    char *buf, size_t len, boolean_t addok)\n{\n\tuint64_t fuid;\n\tint domainid = 0;\n\n\tif (domain && domain[0]) {\n\t\tdomainid = zfs_fuid_find_by_domain(zfsvfs, domain, NULL, addok);\n\t\tif (domainid == -1)\n\t\t\treturn (SET_ERROR(ENOENT));\n\t}\n\tfuid = FUID_ENCODE(domainid, rid);\n\t(void) snprintf(buf, len, \"%llx\", (longlong_t)fuid);\n\treturn (0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}