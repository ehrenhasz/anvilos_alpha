{
  "module_name": "vdev_raidz_math.c",
  "hash_id": "25413ed6848df61c1293fb3412754a8d62ad02cd5dd2d07763731eaf9c2af730",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_raidz_math.c",
  "human_readable_source": " \n \n\n#include <sys/simd.h>\n#include <sys/zfs_context.h>\n#include <sys/types.h>\n#include <sys/zio.h>\n#include <sys/debug.h>\n#include <sys/zfs_debug.h>\n#include <sys/vdev_raidz.h>\n#include <sys/vdev_raidz_impl.h>\n\n \nstatic const raidz_impl_ops_t vdev_raidz_original_impl = {\n\t.name = \"original\",\n\t.is_supported = raidz_will_scalar_work,\n};\n\n \nstatic raidz_impl_ops_t vdev_raidz_fastest_impl = {\n\t.name = \"fastest\"\n};\n\n \nstatic const raidz_impl_ops_t *const raidz_all_maths[] = {\n\t&vdev_raidz_original_impl,\n\t&vdev_raidz_scalar_impl,\n#if defined(__x86_64) && defined(HAVE_SSE2)\t \n\t&vdev_raidz_sse2_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_SSSE3)\t \n\t&vdev_raidz_ssse3_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX2)\t \n\t&vdev_raidz_avx2_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX512F)\t \n\t&vdev_raidz_avx512f_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX512BW)\t \n\t&vdev_raidz_avx512bw_impl,\n#endif\n#if defined(__aarch64__) && !defined(__FreeBSD__)\n\t&vdev_raidz_aarch64_neon_impl,\n\t&vdev_raidz_aarch64_neonx2_impl,\n#endif\n#if defined(__powerpc__) && defined(__altivec__)\n\t&vdev_raidz_powerpc_altivec_impl,\n#endif\n};\n\n \nstatic boolean_t raidz_math_initialized = B_FALSE;\n\n \n#define\tIMPL_FASTEST\t(UINT32_MAX)\n#define\tIMPL_CYCLE\t(UINT32_MAX - 1)\n#define\tIMPL_ORIGINAL\t(0)\n#define\tIMPL_SCALAR\t(1)\n\n#define\tRAIDZ_IMPL_READ(i)\t(*(volatile uint32_t *) &(i))\n\nstatic uint32_t zfs_vdev_raidz_impl = IMPL_SCALAR;\nstatic uint32_t user_sel_impl = IMPL_FASTEST;\n\n \nstatic size_t raidz_supp_impl_cnt = 0;\nstatic raidz_impl_ops_t *raidz_supp_impl[ARRAY_SIZE(raidz_all_maths)];\n\n#if defined(_KERNEL)\n \nstatic raidz_impl_kstat_t raidz_impl_kstats[ARRAY_SIZE(raidz_all_maths) + 1];\n\n \nstatic kstat_t *raidz_math_kstat = NULL;\n#endif\n\n \nconst raidz_impl_ops_t *\nvdev_raidz_math_get_ops(void)\n{\n\tif (!kfpu_allowed())\n\t\treturn (&vdev_raidz_scalar_impl);\n\n\traidz_impl_ops_t *ops = NULL;\n\tconst uint32_t impl = RAIDZ_IMPL_READ(zfs_vdev_raidz_impl);\n\n\tswitch (impl) {\n\tcase IMPL_FASTEST:\n\t\tASSERT(raidz_math_initialized);\n\t\tops = &vdev_raidz_fastest_impl;\n\t\tbreak;\n\tcase IMPL_CYCLE:\n\t\t \n\t\tASSERT(raidz_math_initialized);\n\t\tASSERT3U(raidz_supp_impl_cnt, >, 0);\n\t\tstatic size_t cycle_impl_idx = 0;\n\t\tsize_t idx = (++cycle_impl_idx) % raidz_supp_impl_cnt;\n\t\tops = raidz_supp_impl[idx];\n\t\tbreak;\n\tcase IMPL_ORIGINAL:\n\t\tops = (raidz_impl_ops_t *)&vdev_raidz_original_impl;\n\t\tbreak;\n\tcase IMPL_SCALAR:\n\t\tops = (raidz_impl_ops_t *)&vdev_raidz_scalar_impl;\n\t\tbreak;\n\tdefault:\n\t\tASSERT3U(impl, <, raidz_supp_impl_cnt);\n\t\tASSERT3U(raidz_supp_impl_cnt, >, 0);\n\t\tif (impl < ARRAY_SIZE(raidz_all_maths))\n\t\t\tops = raidz_supp_impl[impl];\n\t\tbreak;\n\t}\n\n\tASSERT3P(ops, !=, NULL);\n\n\treturn (ops);\n}\n\n \nint\nvdev_raidz_math_generate(raidz_map_t *rm, raidz_row_t *rr)\n{\n\traidz_gen_f gen_parity = NULL;\n\n\tswitch (raidz_parity(rm)) {\n\t\tcase 1:\n\t\t\tgen_parity = rm->rm_ops->gen[RAIDZ_GEN_P];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgen_parity = rm->rm_ops->gen[RAIDZ_GEN_PQ];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgen_parity = rm->rm_ops->gen[RAIDZ_GEN_PQR];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgen_parity = NULL;\n\t\t\tcmn_err(CE_PANIC, \"invalid RAID-Z configuration %llu\",\n\t\t\t    (u_longlong_t)raidz_parity(rm));\n\t\t\tbreak;\n\t}\n\n\t \n\tif (gen_parity == NULL)\n\t\treturn (RAIDZ_ORIGINAL_IMPL);\n\n\tgen_parity(rr);\n\n\treturn (0);\n}\n\nstatic raidz_rec_f\nreconstruct_fun_p_sel(raidz_map_t *rm, const int *parity_valid,\n    const int nbaddata)\n{\n\tif (nbaddata == 1 && parity_valid[CODE_P]) {\n\t\treturn (rm->rm_ops->rec[RAIDZ_REC_P]);\n\t}\n\treturn ((raidz_rec_f) NULL);\n}\n\nstatic raidz_rec_f\nreconstruct_fun_pq_sel(raidz_map_t *rm, const int *parity_valid,\n    const int nbaddata)\n{\n\tif (nbaddata == 1) {\n\t\tif (parity_valid[CODE_P]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_P]);\n\t\t} else if (parity_valid[CODE_Q]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_Q]);\n\t\t}\n\t} else if (nbaddata == 2 &&\n\t    parity_valid[CODE_P] && parity_valid[CODE_Q]) {\n\t\treturn (rm->rm_ops->rec[RAIDZ_REC_PQ]);\n\t}\n\treturn ((raidz_rec_f) NULL);\n}\n\nstatic raidz_rec_f\nreconstruct_fun_pqr_sel(raidz_map_t *rm, const int *parity_valid,\n    const int nbaddata)\n{\n\tif (nbaddata == 1) {\n\t\tif (parity_valid[CODE_P]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_P]);\n\t\t} else if (parity_valid[CODE_Q]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_Q]);\n\t\t} else if (parity_valid[CODE_R]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_R]);\n\t\t}\n\t} else if (nbaddata == 2) {\n\t\tif (parity_valid[CODE_P] && parity_valid[CODE_Q]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_PQ]);\n\t\t} else if (parity_valid[CODE_P] && parity_valid[CODE_R]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_PR]);\n\t\t} else if (parity_valid[CODE_Q] && parity_valid[CODE_R]) {\n\t\t\treturn (rm->rm_ops->rec[RAIDZ_REC_QR]);\n\t\t}\n\t} else if (nbaddata == 3 &&\n\t    parity_valid[CODE_P] && parity_valid[CODE_Q] &&\n\t    parity_valid[CODE_R]) {\n\t\treturn (rm->rm_ops->rec[RAIDZ_REC_PQR]);\n\t}\n\treturn ((raidz_rec_f) NULL);\n}\n\n \nint\nvdev_raidz_math_reconstruct(raidz_map_t *rm, raidz_row_t *rr,\n    const int *parity_valid, const int *dt, const int nbaddata)\n{\n\traidz_rec_f rec_fn = NULL;\n\n\tswitch (raidz_parity(rm)) {\n\tcase PARITY_P:\n\t\trec_fn = reconstruct_fun_p_sel(rm, parity_valid, nbaddata);\n\t\tbreak;\n\tcase PARITY_PQ:\n\t\trec_fn = reconstruct_fun_pq_sel(rm, parity_valid, nbaddata);\n\t\tbreak;\n\tcase PARITY_PQR:\n\t\trec_fn = reconstruct_fun_pqr_sel(rm, parity_valid, nbaddata);\n\t\tbreak;\n\tdefault:\n\t\tcmn_err(CE_PANIC, \"invalid RAID-Z configuration %llu\",\n\t\t    (u_longlong_t)raidz_parity(rm));\n\t\tbreak;\n\t}\n\n\tif (rec_fn == NULL)\n\t\treturn (RAIDZ_ORIGINAL_IMPL);\n\telse\n\t\treturn (rec_fn(rr, dt));\n}\n\nconst char *const raidz_gen_name[] = {\n\t\"gen_p\", \"gen_pq\", \"gen_pqr\"\n};\nconst char *const raidz_rec_name[] = {\n\t\"rec_p\", \"rec_q\", \"rec_r\",\n\t\"rec_pq\", \"rec_pr\", \"rec_qr\", \"rec_pqr\"\n};\n\n#if defined(_KERNEL)\n\n#define\tRAIDZ_KSTAT_LINE_LEN\t(17 + 10*12 + 1)\n\nstatic int\nraidz_math_kstat_headers(char *buf, size_t size)\n{\n\tASSERT3U(size, >=, RAIDZ_KSTAT_LINE_LEN);\n\n\tssize_t off = kmem_scnprintf(buf, size, \"%-17s\", \"implementation\");\n\n\tfor (int i = 0; i < ARRAY_SIZE(raidz_gen_name); i++)\n\t\toff += kmem_scnprintf(buf + off, size - off, \"%-16s\",\n\t\t    raidz_gen_name[i]);\n\n\tfor (int i = 0; i < ARRAY_SIZE(raidz_rec_name); i++)\n\t\toff += kmem_scnprintf(buf + off, size - off, \"%-16s\",\n\t\t    raidz_rec_name[i]);\n\n\t(void) kmem_scnprintf(buf + off, size - off, \"\\n\");\n\n\treturn (0);\n}\n\nstatic int\nraidz_math_kstat_data(char *buf, size_t size, void *data)\n{\n\traidz_impl_kstat_t *fstat = &raidz_impl_kstats[raidz_supp_impl_cnt];\n\traidz_impl_kstat_t *cstat = (raidz_impl_kstat_t *)data;\n\tssize_t off = 0;\n\tint i;\n\n\tASSERT3U(size, >=, RAIDZ_KSTAT_LINE_LEN);\n\n\tif (cstat == fstat) {\n\t\toff += kmem_scnprintf(buf + off, size - off, \"%-17s\",\n\t\t    \"fastest\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(raidz_gen_name); i++) {\n\t\t\tint id = fstat->gen[i];\n\t\t\toff += kmem_scnprintf(buf + off, size - off, \"%-16s\",\n\t\t\t    raidz_supp_impl[id]->name);\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(raidz_rec_name); i++) {\n\t\t\tint id = fstat->rec[i];\n\t\t\toff += kmem_scnprintf(buf + off, size - off, \"%-16s\",\n\t\t\t    raidz_supp_impl[id]->name);\n\t\t}\n\t} else {\n\t\tptrdiff_t id = cstat - raidz_impl_kstats;\n\n\t\toff += kmem_scnprintf(buf + off, size - off, \"%-17s\",\n\t\t    raidz_supp_impl[id]->name);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(raidz_gen_name); i++)\n\t\t\toff += kmem_scnprintf(buf + off, size - off, \"%-16llu\",\n\t\t\t    (u_longlong_t)cstat->gen[i]);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(raidz_rec_name); i++)\n\t\t\toff += kmem_scnprintf(buf + off, size - off, \"%-16llu\",\n\t\t\t    (u_longlong_t)cstat->rec[i]);\n\t}\n\n\t(void) kmem_scnprintf(buf + off, size - off, \"\\n\");\n\n\treturn (0);\n}\n\nstatic void *\nraidz_math_kstat_addr(kstat_t *ksp, loff_t n)\n{\n\tif (n <= raidz_supp_impl_cnt)\n\t\tksp->ks_private = (void *) (raidz_impl_kstats + n);\n\telse\n\t\tksp->ks_private = NULL;\n\n\treturn (ksp->ks_private);\n}\n\n#define\tBENCH_D_COLS\t(8ULL)\n#define\tBENCH_COLS\t(BENCH_D_COLS + PARITY_PQR)\n#define\tBENCH_ZIO_SIZE\t(1ULL << SPA_OLD_MAXBLOCKSHIFT)\t \n#define\tBENCH_NS\tMSEC2NSEC(1)\t\t\t \n\ntypedef void (*benchmark_fn)(raidz_map_t *rm, const int fn);\n\nstatic void\nbenchmark_gen_impl(raidz_map_t *rm, const int fn)\n{\n\t(void) fn;\n\tvdev_raidz_generate_parity(rm);\n}\n\nstatic void\nbenchmark_rec_impl(raidz_map_t *rm, const int fn)\n{\n\tstatic const int rec_tgt[7][3] = {\n\t\t{1, 2, 3},\t \n\t\t{0, 2, 3},\t \n\t\t{0, 1, 3},\t \n\t\t{2, 3, 4},\t \n\t\t{1, 3, 4},\t \n\t\t{0, 3, 4},\t \n\t\t{3, 4, 5}\t \n\t};\n\n\tvdev_raidz_reconstruct(rm, rec_tgt[fn], 3);\n}\n\n \nstatic void\nbenchmark_raidz_impl(raidz_map_t *bench_rm, const int fn, benchmark_fn bench_fn)\n{\n\tuint64_t run_cnt, speed, best_speed = 0;\n\thrtime_t t_start, t_diff;\n\traidz_impl_ops_t *curr_impl;\n\traidz_impl_kstat_t *fstat = &raidz_impl_kstats[raidz_supp_impl_cnt];\n\tint impl, i;\n\n\tfor (impl = 0; impl < raidz_supp_impl_cnt; impl++) {\n\t\t \n\t\tcurr_impl = raidz_supp_impl[impl];\n\t\tbench_rm->rm_ops = curr_impl;\n\n\t\trun_cnt = 0;\n\t\tt_start = gethrtime();\n\n\t\tdo {\n\t\t\tfor (i = 0; i < 5; i++, run_cnt++)\n\t\t\t\tbench_fn(bench_rm, fn);\n\n\t\t\tt_diff = gethrtime() - t_start;\n\t\t} while (t_diff < BENCH_NS);\n\n\t\tspeed = run_cnt * BENCH_ZIO_SIZE * NANOSEC;\n\t\tspeed /= (t_diff * BENCH_COLS);\n\n\t\tif (bench_fn == benchmark_gen_impl)\n\t\t\traidz_impl_kstats[impl].gen[fn] = speed;\n\t\telse\n\t\t\traidz_impl_kstats[impl].rec[fn] = speed;\n\n\t\t \n\t\tif (speed > best_speed) {\n\t\t\tbest_speed = speed;\n\n\t\t\tif (bench_fn == benchmark_gen_impl) {\n\t\t\t\tfstat->gen[fn] = impl;\n\t\t\t\tvdev_raidz_fastest_impl.gen[fn] =\n\t\t\t\t    curr_impl->gen[fn];\n\t\t\t} else {\n\t\t\t\tfstat->rec[fn] = impl;\n\t\t\t\tvdev_raidz_fastest_impl.rec[fn] =\n\t\t\t\t    curr_impl->rec[fn];\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\n \nstatic void\nbenchmark_raidz(void)\n{\n\traidz_impl_ops_t *curr_impl;\n\tint i, c;\n\n\t \n\tfor (i = 0, c = 0; i < ARRAY_SIZE(raidz_all_maths); i++) {\n\t\tcurr_impl = (raidz_impl_ops_t *)raidz_all_maths[i];\n\n\t\tif (curr_impl->init)\n\t\t\tcurr_impl->init();\n\n\t\tif (curr_impl->is_supported())\n\t\t\traidz_supp_impl[c++] = (raidz_impl_ops_t *)curr_impl;\n\t}\n\tmembar_producer();\t\t \n\traidz_supp_impl_cnt = c;\t \n\n#if defined(_KERNEL)\n\tabd_t *pabd;\n\tzio_t *bench_zio = NULL;\n\traidz_map_t *bench_rm = NULL;\n\tuint64_t bench_parity;\n\n\t \n\tbench_zio = kmem_zalloc(sizeof (zio_t), KM_SLEEP);\n\tbench_zio->io_offset = 0;\n\tbench_zio->io_size = BENCH_ZIO_SIZE;  \n\tbench_zio->io_abd = abd_alloc_linear(BENCH_ZIO_SIZE, B_TRUE);\n\tmemset(abd_to_buf(bench_zio->io_abd), 0xAA, BENCH_ZIO_SIZE);\n\n\t \n\tfor (int fn = 0; fn < RAIDZ_GEN_NUM; fn++) {\n\t\tbench_parity = fn + 1;\n\t\t \n\t\tbench_rm = vdev_raidz_map_alloc(bench_zio, SPA_MINBLOCKSHIFT,\n\t\t    BENCH_D_COLS + bench_parity, bench_parity);\n\n\t\tbenchmark_raidz_impl(bench_rm, fn, benchmark_gen_impl);\n\n\t\tvdev_raidz_map_free(bench_rm);\n\t}\n\n\t \n\tbench_rm = vdev_raidz_map_alloc(bench_zio, SPA_MINBLOCKSHIFT,\n\t    BENCH_COLS, PARITY_PQR);\n\n\t \n\tfor (c = 0; c < bench_rm->rm_row[0]->rr_firstdatacol; c++) {\n\t\tpabd = bench_rm->rm_row[0]->rr_col[c].rc_abd;\n\t\tmemset(abd_to_buf(pabd), 0xAA, abd_get_size(pabd));\n\t}\n\n\tfor (int fn = 0; fn < RAIDZ_REC_NUM; fn++)\n\t\tbenchmark_raidz_impl(bench_rm, fn, benchmark_rec_impl);\n\n\tvdev_raidz_map_free(bench_rm);\n\n\t \n\tabd_free(bench_zio->io_abd);\n\tkmem_free(bench_zio, sizeof (zio_t));\n#else\n\t \n\tmemcpy(&vdev_raidz_fastest_impl,\n\t    raidz_supp_impl[raidz_supp_impl_cnt - 1],\n\t    sizeof (vdev_raidz_fastest_impl));\n\tstrcpy(vdev_raidz_fastest_impl.name, \"fastest\");\n#endif  \n}\n\nvoid\nvdev_raidz_math_init(void)\n{\n\t \n\tbenchmark_raidz();\n\n#if defined(_KERNEL)\n\t \n\traidz_math_kstat = kstat_create(\"zfs\", 0, \"vdev_raidz_bench\", \"misc\",\n\t    KSTAT_TYPE_RAW, 0, KSTAT_FLAG_VIRTUAL);\n\tif (raidz_math_kstat != NULL) {\n\t\traidz_math_kstat->ks_data = NULL;\n\t\traidz_math_kstat->ks_ndata = UINT32_MAX;\n\t\tkstat_set_raw_ops(raidz_math_kstat,\n\t\t    raidz_math_kstat_headers,\n\t\t    raidz_math_kstat_data,\n\t\t    raidz_math_kstat_addr);\n\t\tkstat_install(raidz_math_kstat);\n\t}\n#endif\n\n\t \n\tatomic_swap_32(&zfs_vdev_raidz_impl, user_sel_impl);\n\traidz_math_initialized = B_TRUE;\n}\n\nvoid\nvdev_raidz_math_fini(void)\n{\n\traidz_impl_ops_t const *curr_impl;\n\n#if defined(_KERNEL)\n\tif (raidz_math_kstat != NULL) {\n\t\tkstat_delete(raidz_math_kstat);\n\t\traidz_math_kstat = NULL;\n\t}\n#endif\n\n\tfor (int i = 0; i < ARRAY_SIZE(raidz_all_maths); i++) {\n\t\tcurr_impl = raidz_all_maths[i];\n\t\tif (curr_impl->fini)\n\t\t\tcurr_impl->fini();\n\t}\n}\n\nstatic const struct {\n\tconst char *name;\n\tuint32_t sel;\n} math_impl_opts[] = {\n\t\t{ \"cycle\",\tIMPL_CYCLE },\n\t\t{ \"fastest\",\tIMPL_FASTEST },\n\t\t{ \"original\",\tIMPL_ORIGINAL },\n\t\t{ \"scalar\",\tIMPL_SCALAR }\n};\n\n \nint\nvdev_raidz_impl_set(const char *val)\n{\n\tint err = -EINVAL;\n\tchar req_name[RAIDZ_IMPL_NAME_MAX];\n\tuint32_t impl = RAIDZ_IMPL_READ(user_sel_impl);\n\tsize_t i;\n\n\t \n\ti = strnlen(val, RAIDZ_IMPL_NAME_MAX);\n\tif (i == 0 || i == RAIDZ_IMPL_NAME_MAX)\n\t\treturn (err);\n\n\tstrlcpy(req_name, val, RAIDZ_IMPL_NAME_MAX);\n\twhile (i > 0 && !!isspace(req_name[i-1]))\n\t\ti--;\n\treq_name[i] = '\\0';\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(math_impl_opts); i++) {\n\t\tif (strcmp(req_name, math_impl_opts[i].name) == 0) {\n\t\t\timpl = math_impl_opts[i].sel;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (err != 0 && raidz_math_initialized) {\n\t\t \n\t\tfor (i = 0; i < raidz_supp_impl_cnt; i++) {\n\t\t\tif (strcmp(req_name, raidz_supp_impl[i]->name) == 0) {\n\t\t\t\timpl = i;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err == 0) {\n\t\tif (raidz_math_initialized)\n\t\t\tatomic_swap_32(&zfs_vdev_raidz_impl, impl);\n\t\telse\n\t\t\tatomic_swap_32(&user_sel_impl, impl);\n\t}\n\n\treturn (err);\n}\n\n#if defined(_KERNEL) && defined(__linux__)\n\nstatic int\nzfs_vdev_raidz_impl_set(const char *val, zfs_kernel_param_t *kp)\n{\n\treturn (vdev_raidz_impl_set(val));\n}\n\nstatic int\nzfs_vdev_raidz_impl_get(char *buffer, zfs_kernel_param_t *kp)\n{\n\tint i, cnt = 0;\n\tchar *fmt;\n\tconst uint32_t impl = RAIDZ_IMPL_READ(zfs_vdev_raidz_impl);\n\n\tASSERT(raidz_math_initialized);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(math_impl_opts) - 2; i++) {\n\t\tfmt = (impl == math_impl_opts[i].sel) ? \"[%s] \" : \"%s \";\n\t\tcnt += kmem_scnprintf(buffer + cnt, PAGE_SIZE - cnt, fmt,\n\t\t    math_impl_opts[i].name);\n\t}\n\n\t \n\tfor (i = 0; i < raidz_supp_impl_cnt; i++) {\n\t\tfmt = (i == impl) ? \"[%s] \" : \"%s \";\n\t\tcnt += kmem_scnprintf(buffer + cnt, PAGE_SIZE - cnt, fmt,\n\t\t    raidz_supp_impl[i]->name);\n\t}\n\n\treturn (cnt);\n}\n\nmodule_param_call(zfs_vdev_raidz_impl, zfs_vdev_raidz_impl_set,\n    zfs_vdev_raidz_impl_get, NULL, 0644);\nMODULE_PARM_DESC(zfs_vdev_raidz_impl, \"Select raidz implementation.\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}