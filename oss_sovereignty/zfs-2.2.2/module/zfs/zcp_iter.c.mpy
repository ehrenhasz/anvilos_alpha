{
  "module_name": "zcp_iter.c",
  "hash_id": "50edecb8989dd16e2148ab59f827a4763d8214f3de6b3a9b670c230f9e7a8064",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zcp_iter.c",
  "human_readable_source": " \n\n \n\n#include <sys/lua/lua.h>\n#include <sys/lua/lauxlib.h>\n\n#include <sys/dmu.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_pool.h>\n#include <sys/dmu_tx.h>\n#include <sys/dmu_objset.h>\n#include <sys/zap.h>\n#include <sys/dsl_dir.h>\n#include <sys/zcp_prop.h>\n\n#include <sys/zcp.h>\n\n#include \"zfs_comutil.h\"\n\ntypedef int (zcp_list_func_t)(lua_State *);\ntypedef struct zcp_list_info {\n\tconst char *name;\n\tzcp_list_func_t *func;\n\tzcp_list_func_t *gc;\n\tconst zcp_arg_t pargs[4];\n\tconst zcp_arg_t kwargs[2];\n} zcp_list_info_t;\n\nstatic int\nzcp_clones_iter(lua_State *state)\n{\n\tint err;\n\tchar clonename[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t dsobj = lua_tonumber(state, lua_upvalueindex(1));\n\tuint64_t cursor = lua_tonumber(state, lua_upvalueindex(2));\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tdsl_dataset_t *ds, *clone;\n\tzap_attribute_t za;\n\tzap_cursor_t zc;\n\n\terr = dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds);\n\tif (err == ENOENT) {\n\t\treturn (0);\n\t} else if (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dsl_dataset_hold_obj(dsobj)\",\n\t\t    err));\n\t}\n\n\tif (dsl_dataset_phys(ds)->ds_next_clones_obj == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\tzap_cursor_init_serialized(&zc, dp->dp_meta_objset,\n\t    dsl_dataset_phys(ds)->ds_next_clones_obj, cursor);\n\tdsl_dataset_rele(ds, FTAG);\n\n\terr = zap_cursor_retrieve(&zc, &za);\n\tif (err != 0) {\n\t\tzap_cursor_fini(&zc);\n\t\tif (err != ENOENT) {\n\t\t\treturn (luaL_error(state,\n\t\t\t    \"unexpected error %d from zap_cursor_retrieve()\",\n\t\t\t    err));\n\t\t}\n\t\treturn (0);\n\t}\n\tzap_cursor_advance(&zc);\n\tcursor = zap_cursor_serialize(&zc);\n\tzap_cursor_fini(&zc);\n\n\terr = dsl_dataset_hold_obj(dp, za.za_first_integer, FTAG, &clone);\n\tif (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from \"\n\t\t    \"dsl_dataset_hold_obj(za_first_integer)\", err));\n\t}\n\n\tdsl_dir_name(clone->ds_dir, clonename);\n\tdsl_dataset_rele(clone, FTAG);\n\n\tlua_pushnumber(state, cursor);\n\tlua_replace(state, lua_upvalueindex(2));\n\n\t(void) lua_pushstring(state, clonename);\n\treturn (1);\n}\n\nstatic int zcp_clones_list(lua_State *);\nstatic const zcp_list_info_t zcp_clones_list_info = {\n\t.name = \"clones\",\n\t.func = zcp_clones_list,\n\t.gc = NULL,\n\t.pargs = {\n\t    { .za_name = \"snapshot\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_clones_list(lua_State *state)\n{\n\tconst char *snapname = lua_tostring(state, 1);\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\n\t \n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, snapname, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\tboolean_t issnap = ds->ds_is_snapshot;\n\tuint64_t cursor = 0;\n\tuint64_t dsobj = ds->ds_object;\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (!issnap) {\n\t\treturn (zcp_argerror(state, 1, \"%s is not a snapshot\",\n\t\t    snapname));\n\t}\n\n\tlua_pushnumber(state, dsobj);\n\tlua_pushnumber(state, cursor);\n\tlua_pushcclosure(state, &zcp_clones_iter, 2);\n\treturn (1);\n}\n\nstatic int\nzcp_snapshots_iter(lua_State *state)\n{\n\tint err;\n\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t dsobj = lua_tonumber(state, lua_upvalueindex(1));\n\tuint64_t cursor = lua_tonumber(state, lua_upvalueindex(2));\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tdsl_dataset_t *ds;\n\tobjset_t *os;\n\tchar *p;\n\n\terr = dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds);\n\tif (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dsl_dataset_hold_obj(dsobj)\",\n\t\t    err));\n\t}\n\n\tdsl_dataset_name(ds, snapname);\n\tVERIFY3U(sizeof (snapname), >,\n\t    strlcat(snapname, \"@\", sizeof (snapname)));\n\n\tp = strchr(snapname, '\\0');\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\terr = dmu_snapshot_list_next(os,\n\t    sizeof (snapname) - (p - snapname), p, NULL, &cursor, NULL);\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (err == ENOENT) {\n\t\treturn (0);\n\t} else if (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dmu_snapshot_list_next()\", err));\n\t}\n\n\tlua_pushnumber(state, cursor);\n\tlua_replace(state, lua_upvalueindex(2));\n\n\t(void) lua_pushstring(state, snapname);\n\treturn (1);\n}\n\nstatic int zcp_snapshots_list(lua_State *);\nstatic const zcp_list_info_t zcp_snapshots_list_info = {\n\t.name = \"snapshots\",\n\t.func = zcp_snapshots_list,\n\t.gc = NULL,\n\t.pargs = {\n\t    { .za_name = \"filesystem | volume\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_snapshots_list(lua_State *state)\n{\n\tconst char *fsname = lua_tostring(state, 1);\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tboolean_t issnap;\n\tuint64_t dsobj;\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, fsname, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\tissnap = ds->ds_is_snapshot;\n\tdsobj = ds->ds_object;\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (issnap) {\n\t\treturn (zcp_argerror(state, 1,\n\t\t    \"argument %s cannot be a snapshot\", fsname));\n\t}\n\n\tlua_pushnumber(state, dsobj);\n\tlua_pushnumber(state, 0);\n\tlua_pushcclosure(state, &zcp_snapshots_iter, 2);\n\treturn (1);\n}\n\nstatic int\nzcp_children_iter(lua_State *state)\n{\n\tint err;\n\tchar childname[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t dsobj = lua_tonumber(state, lua_upvalueindex(1));\n\tuint64_t cursor = lua_tonumber(state, lua_upvalueindex(2));\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\tdsl_pool_t *dp = ri->zri_pool;\n\tdsl_dataset_t *ds;\n\tobjset_t *os;\n\tchar *p;\n\n\terr = dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds);\n\tif (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dsl_dataset_hold_obj(dsobj)\",\n\t\t    err));\n\t}\n\n\tdsl_dataset_name(ds, childname);\n\tVERIFY3U(sizeof (childname), >,\n\t    strlcat(childname, \"/\", sizeof (childname)));\n\tp = strchr(childname, '\\0');\n\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tdo {\n\t\terr = dmu_dir_list_next(os,\n\t\t    sizeof (childname) - (p - childname), p, NULL, &cursor);\n\t} while (err == 0 && zfs_dataset_name_hidden(childname));\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (err == ENOENT) {\n\t\treturn (0);\n\t} else if (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dmu_dir_list_next()\",\n\t\t    err));\n\t}\n\n\tlua_pushnumber(state, cursor);\n\tlua_replace(state, lua_upvalueindex(2));\n\n\t(void) lua_pushstring(state, childname);\n\treturn (1);\n}\n\nstatic int zcp_children_list(lua_State *);\nstatic const zcp_list_info_t zcp_children_list_info = {\n\t.name = \"children\",\n\t.func = zcp_children_list,\n\t.gc = NULL,\n\t.pargs = {\n\t    { .za_name = \"filesystem | volume\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_children_list(lua_State *state)\n{\n\tconst char *fsname = lua_tostring(state, 1);\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tboolean_t issnap;\n\tuint64_t dsobj;\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, fsname, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\tissnap = ds->ds_is_snapshot;\n\tdsobj = ds->ds_object;\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (issnap) {\n\t\treturn (zcp_argerror(state, 1,\n\t\t    \"argument %s cannot be a snapshot\", fsname));\n\t}\n\n\tlua_pushnumber(state, dsobj);\n\tlua_pushnumber(state, 0);\n\tlua_pushcclosure(state, &zcp_children_iter, 2);\n\treturn (1);\n}\n\nstatic int\nzcp_user_props_list_gc(lua_State *state)\n{\n\tnvlist_t **props = lua_touserdata(state, 1);\n\tif (*props != NULL)\n\t\tfnvlist_free(*props);\n\treturn (0);\n}\n\nstatic int\nzcp_user_props_iter(lua_State *state)\n{\n\tconst char *source, *val;\n\tnvlist_t *nvprop;\n\tnvlist_t **props = lua_touserdata(state, lua_upvalueindex(1));\n\tnvpair_t *pair = lua_touserdata(state, lua_upvalueindex(2));\n\n\tdo {\n\t\tpair = nvlist_next_nvpair(*props, pair);\n\t\tif (pair == NULL) {\n\t\t\tfnvlist_free(*props);\n\t\t\t*props = NULL;\n\t\t\treturn (0);\n\t\t}\n\t} while (!zfs_prop_user(nvpair_name(pair)));\n\n\tlua_pushlightuserdata(state, pair);\n\tlua_replace(state, lua_upvalueindex(2));\n\n\tnvprop = fnvpair_value_nvlist(pair);\n\tval = fnvlist_lookup_string(nvprop, ZPROP_VALUE);\n\tsource = fnvlist_lookup_string(nvprop, ZPROP_SOURCE);\n\n\t(void) lua_pushstring(state, nvpair_name(pair));\n\t(void) lua_pushstring(state, val);\n\t(void) lua_pushstring(state, source);\n\treturn (3);\n}\n\nstatic int zcp_user_props_list(lua_State *);\nstatic const zcp_list_info_t zcp_user_props_list_info = {\n\t.name = \"user_properties\",\n\t.func = zcp_user_props_list,\n\t.gc = zcp_user_props_list_gc,\n\t.pargs = {\n\t    { .za_name = \"filesystem | snapshot | volume\",\n\t    .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\n \nstatic const zcp_list_info_t zcp_props_list_info = {\n\t.name = \"properties\",\n\t.func = zcp_user_props_list,\n\t.gc = zcp_user_props_list_gc,\n\t.pargs = {\n\t    { .za_name = \"filesystem | snapshot | volume\",\n\t    .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_user_props_list(lua_State *state)\n{\n\tconst char *dsname = lua_tostring(state, 1);\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tobjset_t *os;\n\tnvlist_t **props = lua_newuserdata(state, sizeof (nvlist_t *));\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, dsname, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tVERIFY0(dsl_prop_get_all(os, props));\n\tdsl_dataset_rele(ds, FTAG);\n\n\t \n\tluaL_getmetatable(state, zcp_user_props_list_info.name);\n\t(void) lua_setmetatable(state, -2);\n\n\tlua_pushlightuserdata(state, NULL);\n\tlua_pushcclosure(state, &zcp_user_props_iter, 2);\n\treturn (1);\n}\n\n\n \nstatic void\nzcp_dataset_system_props(dsl_dataset_t *ds, nvlist_t *nv)\n{\n\tfor (int prop = ZFS_PROP_TYPE; prop < ZFS_NUM_PROPS; prop++) {\n\t\t \n\t\tif (!zfs_prop_visible(prop))\n\t\t\tcontinue;\n\t\t \n\t\tif (!prop_valid_for_ds(ds, prop))\n\t\t\tcontinue;\n\t\tfnvlist_add_boolean(nv, zfs_prop_to_name(prop));\n\t}\n}\n\nstatic int zcp_system_props_list(lua_State *);\nstatic const zcp_list_info_t zcp_system_props_list_info = {\n\t.name = \"system_properties\",\n\t.func = zcp_system_props_list,\n\t.pargs = {\n\t    { .za_name = \"dataset\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\n \nstatic int\nzcp_system_props_list(lua_State *state)\n{\n\tint error;\n\tchar errbuf[128];\n\tconst char *dataset_name;\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tconst zcp_list_info_t *libinfo = &zcp_system_props_list_info;\n\tzcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);\n\tdataset_name = lua_tostring(state, 1);\n\tnvlist_t *nv = fnvlist_alloc();\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, dataset_name, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\t \n\tzcp_dataset_system_props(ds, nv);\n\tdsl_dataset_rele(ds, FTAG);\n\n\t \n\terror = zcp_nvlist_to_lua(state, nv, errbuf, sizeof (errbuf));\n\tnvlist_free(nv);\n\tif (error != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"Error returning nvlist: %s\", errbuf));\n\t}\n\treturn (1);\n}\n\nstatic int\nzcp_bookmarks_iter(lua_State *state)\n{\n\tchar ds_name[ZFS_MAX_DATASET_NAME_LEN];\n\tchar bookmark_name[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t dsobj = lua_tonumber(state, lua_upvalueindex(1));\n\tuint64_t cursor = lua_tonumber(state, lua_upvalueindex(2));\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tdsl_dataset_t *ds;\n\tzap_attribute_t za;\n\tzap_cursor_t zc;\n\n\tint err = dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds);\n\tif (err == ENOENT) {\n\t\treturn (0);\n\t} else if (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dsl_dataset_hold_obj(dsobj)\",\n\t\t    err));\n\t}\n\n\tif (!dsl_dataset_is_zapified(ds)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\terr = zap_lookup(dp->dp_meta_objset, ds->ds_object,\n\t    DS_FIELD_BOOKMARK_NAMES, sizeof (ds->ds_bookmarks_obj), 1,\n\t    &ds->ds_bookmarks_obj);\n\tif (err != 0 && err != ENOENT) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from zap_lookup()\", err));\n\t}\n\tif (ds->ds_bookmarks_obj == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tdsl_dataset_name(ds, ds_name);\n\n\tzap_cursor_init_serialized(&zc, ds->ds_dir->dd_pool->dp_meta_objset,\n\t    ds->ds_bookmarks_obj, cursor);\n\tdsl_dataset_rele(ds, FTAG);\n\n\terr = zap_cursor_retrieve(&zc, &za);\n\tif (err != 0) {\n\t\tzap_cursor_fini(&zc);\n\t\tif (err != ENOENT) {\n\t\t\treturn (luaL_error(state,\n\t\t\t    \"unexpected error %d from zap_cursor_retrieve()\",\n\t\t\t    err));\n\t\t}\n\t\treturn (0);\n\t}\n\tzap_cursor_advance(&zc);\n\tcursor = zap_cursor_serialize(&zc);\n\tzap_cursor_fini(&zc);\n\n\t \n\tint n = snprintf(bookmark_name, ZFS_MAX_DATASET_NAME_LEN, \"%s#%s\",\n\t    ds_name, za.za_name);\n\tif (n >= ZFS_MAX_DATASET_NAME_LEN) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from snprintf()\", ENAMETOOLONG));\n\t}\n\n\tlua_pushnumber(state, cursor);\n\tlua_replace(state, lua_upvalueindex(2));\n\n\t(void) lua_pushstring(state, bookmark_name);\n\treturn (1);\n}\n\nstatic int zcp_bookmarks_list(lua_State *);\nstatic const zcp_list_info_t zcp_bookmarks_list_info = {\n\t.name = \"bookmarks\",\n\t.func = zcp_bookmarks_list,\n\t.pargs = {\n\t    { .za_name = \"dataset\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_bookmarks_list(lua_State *state)\n{\n\tconst char *dsname = lua_tostring(state, 1);\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, dsname, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\tboolean_t issnap = ds->ds_is_snapshot;\n\tuint64_t dsobj = ds->ds_object;\n\tuint64_t cursor = 0;\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (issnap) {\n\t\treturn (zcp_argerror(state, 1, \"%s is a snapshot\", dsname));\n\t}\n\n\tlua_pushnumber(state, dsobj);\n\tlua_pushnumber(state, cursor);\n\tlua_pushcclosure(state, &zcp_bookmarks_iter, 2);\n\treturn (1);\n}\n\nstatic int\nzcp_holds_iter(lua_State *state)\n{\n\tuint64_t dsobj = lua_tonumber(state, lua_upvalueindex(1));\n\tuint64_t cursor = lua_tonumber(state, lua_upvalueindex(2));\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tdsl_dataset_t *ds;\n\tzap_attribute_t za;\n\tzap_cursor_t zc;\n\n\tint err = dsl_dataset_hold_obj(dp, dsobj, FTAG, &ds);\n\tif (err == ENOENT) {\n\t\treturn (0);\n\t} else if (err != 0) {\n\t\treturn (luaL_error(state,\n\t\t    \"unexpected error %d from dsl_dataset_hold_obj(dsobj)\",\n\t\t    err));\n\t}\n\n\tif (dsl_dataset_phys(ds)->ds_userrefs_obj == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\tzap_cursor_init_serialized(&zc, ds->ds_dir->dd_pool->dp_meta_objset,\n\t    dsl_dataset_phys(ds)->ds_userrefs_obj, cursor);\n\tdsl_dataset_rele(ds, FTAG);\n\n\terr = zap_cursor_retrieve(&zc, &za);\n\tif (err != 0) {\n\t\tzap_cursor_fini(&zc);\n\t\tif (err != ENOENT) {\n\t\t\treturn (luaL_error(state,\n\t\t\t    \"unexpected error %d from zap_cursor_retrieve()\",\n\t\t\t    err));\n\t\t}\n\t\treturn (0);\n\t}\n\tzap_cursor_advance(&zc);\n\tcursor = zap_cursor_serialize(&zc);\n\tzap_cursor_fini(&zc);\n\n\tlua_pushnumber(state, cursor);\n\tlua_replace(state, lua_upvalueindex(2));\n\n\t(void) lua_pushstring(state, za.za_name);\n\t(void) lua_pushnumber(state, za.za_first_integer);\n\treturn (2);\n}\n\nstatic int zcp_holds_list(lua_State *);\nstatic const zcp_list_info_t zcp_holds_list_info = {\n\t.name = \"holds\",\n\t.func = zcp_holds_list,\n\t.gc = NULL,\n\t.pargs = {\n\t    { .za_name = \"snapshot\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\n \nstatic int\nzcp_holds_list(lua_State *state)\n{\n\tconst char *snapname = lua_tostring(state, 1);\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, snapname, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\tboolean_t issnap = ds->ds_is_snapshot;\n\tuint64_t dsobj = ds->ds_object;\n\tuint64_t cursor = 0;\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (!issnap) {\n\t\treturn (zcp_argerror(state, 1, \"%s is not a snapshot\",\n\t\t    snapname));\n\t}\n\n\tlua_pushnumber(state, dsobj);\n\tlua_pushnumber(state, cursor);\n\tlua_pushcclosure(state, &zcp_holds_iter, 2);\n\treturn (1);\n}\n\nstatic int\nzcp_list_func(lua_State *state)\n{\n\tzcp_list_info_t *info = lua_touserdata(state, lua_upvalueindex(1));\n\n\tzcp_parse_args(state, info->name, info->pargs, info->kwargs);\n\n\treturn (info->func(state));\n}\n\nint\nzcp_load_list_lib(lua_State *state)\n{\n\tconst zcp_list_info_t *zcp_list_funcs[] = {\n\t\t&zcp_children_list_info,\n\t\t&zcp_snapshots_list_info,\n\t\t&zcp_user_props_list_info,\n\t\t&zcp_props_list_info,\n\t\t&zcp_clones_list_info,\n\t\t&zcp_system_props_list_info,\n\t\t&zcp_bookmarks_list_info,\n\t\t&zcp_holds_list_info,\n\t\tNULL\n\t};\n\n\tlua_newtable(state);\n\n\tfor (int i = 0; zcp_list_funcs[i] != NULL; i++) {\n\t\tconst zcp_list_info_t *info = zcp_list_funcs[i];\n\n\t\tif (info->gc != NULL) {\n\t\t\t \n\t\t\t(void) luaL_newmetatable(state, info->name);\n\t\t\t(void) lua_pushstring(state, \"__gc\");\n\t\t\tlua_pushcfunction(state, info->gc);\n\t\t\tlua_settable(state, -3);\n\t\t\tlua_pop(state, 1);\n\t\t}\n\n\t\tlua_pushlightuserdata(state, (void *)(uintptr_t)info);\n\t\tlua_pushcclosure(state, &zcp_list_func, 1);\n\t\tlua_setfield(state, -2, info->name);\n\t}\n\n\treturn (1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}