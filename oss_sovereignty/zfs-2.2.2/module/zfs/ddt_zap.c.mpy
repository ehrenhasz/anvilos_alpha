{
  "module_name": "ddt_zap.c",
  "hash_id": "faf96ccf50f1545147c007da1cad4a87b3072ec2ce6ea41428a4a3ca594b421c",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/ddt_zap.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/zio.h>\n#include <sys/ddt.h>\n#include <sys/zap.h>\n#include <sys/dmu_tx.h>\n\nstatic unsigned int ddt_zap_default_bs = 15;\nstatic unsigned int ddt_zap_default_ibs = 15;\n\nstatic int\nddt_zap_create(objset_t *os, uint64_t *objectp, dmu_tx_t *tx, boolean_t prehash)\n{\n\tzap_flags_t flags = ZAP_FLAG_HASH64 | ZAP_FLAG_UINT64_KEY;\n\n\tif (prehash)\n\t\tflags |= ZAP_FLAG_PRE_HASHED_KEY;\n\n\t*objectp = zap_create_flags(os, 0, flags, DMU_OT_DDT_ZAP,\n\t    ddt_zap_default_bs, ddt_zap_default_ibs,\n\t    DMU_OT_NONE, 0, tx);\n\n\treturn (*objectp == 0 ? SET_ERROR(ENOTSUP) : 0);\n}\n\nstatic int\nddt_zap_destroy(objset_t *os, uint64_t object, dmu_tx_t *tx)\n{\n\treturn (zap_destroy(os, object, tx));\n}\n\nstatic int\nddt_zap_lookup(objset_t *os, uint64_t object, ddt_entry_t *dde)\n{\n\tuchar_t *cbuf;\n\tuint64_t one, csize;\n\tint error;\n\n\tcbuf = kmem_alloc(sizeof (dde->dde_phys) + 1, KM_SLEEP);\n\n\terror = zap_length_uint64(os, object, (uint64_t *)&dde->dde_key,\n\t    DDT_KEY_WORDS, &one, &csize);\n\tif (error)\n\t\tgoto out;\n\n\tASSERT(one == 1);\n\tASSERT(csize <= (sizeof (dde->dde_phys) + 1));\n\n\terror = zap_lookup_uint64(os, object, (uint64_t *)&dde->dde_key,\n\t    DDT_KEY_WORDS, 1, csize, cbuf);\n\tif (error)\n\t\tgoto out;\n\n\tddt_decompress(cbuf, dde->dde_phys, csize, sizeof (dde->dde_phys));\nout:\n\tkmem_free(cbuf, sizeof (dde->dde_phys) + 1);\n\n\treturn (error);\n}\n\nstatic void\nddt_zap_prefetch(objset_t *os, uint64_t object, ddt_entry_t *dde)\n{\n\t(void) zap_prefetch_uint64(os, object, (uint64_t *)&dde->dde_key,\n\t    DDT_KEY_WORDS);\n}\n\nstatic int\nddt_zap_update(objset_t *os, uint64_t object, ddt_entry_t *dde, dmu_tx_t *tx)\n{\n\tuchar_t cbuf[sizeof (dde->dde_phys) + 1];\n\tuint64_t csize;\n\n\tcsize = ddt_compress(dde->dde_phys, cbuf,\n\t    sizeof (dde->dde_phys), sizeof (cbuf));\n\n\treturn (zap_update_uint64(os, object, (uint64_t *)&dde->dde_key,\n\t    DDT_KEY_WORDS, 1, csize, cbuf, tx));\n}\n\nstatic int\nddt_zap_remove(objset_t *os, uint64_t object, ddt_entry_t *dde, dmu_tx_t *tx)\n{\n\treturn (zap_remove_uint64(os, object, (uint64_t *)&dde->dde_key,\n\t    DDT_KEY_WORDS, tx));\n}\n\nstatic int\nddt_zap_walk(objset_t *os, uint64_t object, ddt_entry_t *dde, uint64_t *walk)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tint error;\n\n\tif (*walk == 0) {\n\t\t \n\t\tzap_cursor_init_noprefetch(&zc, os, object);\n\t} else {\n\t\tzap_cursor_init_serialized(&zc, os, object, *walk);\n\t}\n\tif ((error = zap_cursor_retrieve(&zc, &za)) == 0) {\n\t\tuchar_t cbuf[sizeof (dde->dde_phys) + 1];\n\t\tuint64_t csize = za.za_num_integers;\n\t\tASSERT(za.za_integer_length == 1);\n\t\terror = zap_lookup_uint64(os, object, (uint64_t *)za.za_name,\n\t\t    DDT_KEY_WORDS, 1, csize, cbuf);\n\t\tASSERT(error == 0);\n\t\tif (error == 0) {\n\t\t\tddt_decompress(cbuf, dde->dde_phys, csize,\n\t\t\t    sizeof (dde->dde_phys));\n\t\t\tdde->dde_key = *(ddt_key_t *)za.za_name;\n\t\t}\n\t\tzap_cursor_advance(&zc);\n\t\t*walk = zap_cursor_serialize(&zc);\n\t}\n\tzap_cursor_fini(&zc);\n\treturn (error);\n}\n\nstatic int\nddt_zap_count(objset_t *os, uint64_t object, uint64_t *count)\n{\n\treturn (zap_count(os, object, count));\n}\n\nconst ddt_ops_t ddt_zap_ops = {\n\t\"zap\",\n\tddt_zap_create,\n\tddt_zap_destroy,\n\tddt_zap_lookup,\n\tddt_zap_prefetch,\n\tddt_zap_update,\n\tddt_zap_remove,\n\tddt_zap_walk,\n\tddt_zap_count,\n};\n\n \nZFS_MODULE_PARAM(zfs_dedup, , ddt_zap_default_bs, UINT, ZMOD_RW,\n\t\"DDT ZAP leaf blockshift\");\nZFS_MODULE_PARAM(zfs_dedup, , ddt_zap_default_ibs, UINT, ZMOD_RW,\n\t\"DDT ZAP indirect blockshift\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}