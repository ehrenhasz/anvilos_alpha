{
  "module_name": "lz4_zfs.c",
  "hash_id": "abc6870026a13874acfbe746a2c6059fea15f84689de072d8f63811918e2f7f3",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/lz4_zfs.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/zio_compress.h>\n\nstatic int real_LZ4_compress(const char *source, char *dest, int isize,\n    int osize);\nstatic int LZ4_compressCtx(void *ctx, const char *source, char *dest,\n    int isize, int osize);\nstatic int LZ4_compress64kCtx(void *ctx, const char *source, char *dest,\n    int isize, int osize);\n\n \nint LZ4_uncompress_unknownOutputSize(const char *source, char *dest,\n    int isize, int maxOutputSize);\n\nstatic kmem_cache_t *lz4_cache;\n\nsize_t\nlz4_compress_zfs(void *s_start, void *d_start, size_t s_len,\n    size_t d_len, int n)\n{\n\t(void) n;\n\tuint32_t bufsiz;\n\tchar *dest = d_start;\n\n\tASSERT(d_len >= sizeof (bufsiz));\n\n\tbufsiz = real_LZ4_compress(s_start, &dest[sizeof (bufsiz)], s_len,\n\t    d_len - sizeof (bufsiz));\n\n\t \n\tif (bufsiz == 0)\n\t\treturn (s_len);\n\n\t \n\t*(uint32_t *)dest = BE_32(bufsiz);\n\n\treturn (bufsiz + sizeof (bufsiz));\n}\n\nint\nlz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,\n    size_t d_len, int n)\n{\n\t(void) n;\n\tconst char *src = s_start;\n\tuint32_t bufsiz = BE_IN32(src);\n\n\t \n\tif (bufsiz + sizeof (bufsiz) > s_len)\n\t\treturn (1);\n\n\t \n\treturn (LZ4_uncompress_unknownOutputSize(&src[sizeof (bufsiz)],\n\t    d_start, bufsiz, d_len) < 0);\n}\n\n \n\n \n\n \n#define\tCOMPRESSIONLEVEL 12\n\n \n#define\tNOTCOMPRESSIBLE_CONFIRMATION 6\n\n \n \n\n \n\n \n#if defined(_LP64)\n#define\tLZ4_ARCH64 1\n#else\n#define\tLZ4_ARCH64 0\n#endif\n\n \n#if defined(_ZFS_BIG_ENDIAN)\n#define\tLZ4_BIG_ENDIAN 1\n#else\n \n#undef LZ4_BIG_ENDIAN\n#endif\n\n \n#if defined(__ARM_FEATURE_UNALIGNED)\n#define\tLZ4_FORCE_UNALIGNED_ACCESS 1\n#endif\n\n \n#undef\tLZ4_FORCE_SW_BITCOUNT\n#if defined(__sparc)\n#define\tLZ4_FORCE_SW_BITCOUNT\n#endif\n\n \n \n#define\trestrict\n\n \n#ifdef GCC_VERSION\n#undef GCC_VERSION\n#endif\n\n#define\tGCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n\n#if (GCC_VERSION >= 302) || (__INTEL_COMPILER >= 800) || defined(__clang__)\n#define\texpect(expr, value)    (__builtin_expect((expr), (value)))\n#else\n#define\texpect(expr, value)    (expr)\n#endif\n\n#ifndef likely\n#define\tlikely(expr)\texpect((expr) != 0, 1)\n#endif\n\n#ifndef unlikely\n#define\tunlikely(expr)\texpect((expr) != 0, 0)\n#endif\n\n#define\tlz4_bswap16(x) ((unsigned short int) ((((x) >> 8) & 0xffu) | \\\n\t(((x) & 0xffu) << 8)))\n\n \n#define\tBYTE\tuint8_t\n#define\tU16\tuint16_t\n#define\tU32\tuint32_t\n#define\tS32\tint32_t\n#define\tU64\tuint64_t\n\n#ifndef LZ4_FORCE_UNALIGNED_ACCESS\n#pragma pack(1)\n#endif\n\ntypedef struct _U16_S {\n\tU16 v;\n} U16_S;\ntypedef struct _U32_S {\n\tU32 v;\n} U32_S;\ntypedef struct _U64_S {\n\tU64 v;\n} U64_S;\n\n#ifndef LZ4_FORCE_UNALIGNED_ACCESS\n#pragma pack()\n#endif\n\n#define\tA64(x) (((U64_S *)(x))->v)\n#define\tA32(x) (((U32_S *)(x))->v)\n#define\tA16(x) (((U16_S *)(x))->v)\n\n \n#define\tMINMATCH 4\n\n#define\tHASH_LOG COMPRESSIONLEVEL\n#define\tHASHTABLESIZE (1 << HASH_LOG)\n#define\tHASH_MASK (HASHTABLESIZE - 1)\n\n#define\tSKIPSTRENGTH (NOTCOMPRESSIBLE_CONFIRMATION > 2 ? \\\n\tNOTCOMPRESSIBLE_CONFIRMATION : 2)\n\n#define\tCOPYLENGTH 8\n#define\tLASTLITERALS 5\n#define\tMFLIMIT (COPYLENGTH + MINMATCH)\n#define\tMINLENGTH (MFLIMIT + 1)\n\n#define\tMAXD_LOG 16\n#define\tMAX_DISTANCE ((1 << MAXD_LOG) - 1)\n\n#define\tML_BITS 4\n#define\tML_MASK ((1U<<ML_BITS)-1)\n#define\tRUN_BITS (8-ML_BITS)\n#define\tRUN_MASK ((1U<<RUN_BITS)-1)\n\n\n \n#if LZ4_ARCH64\n#define\tSTEPSIZE 8\n#define\tUARCH U64\n#define\tAARCH A64\n#define\tLZ4_COPYSTEP(s, d)\tA64(d) = A64(s); d += 8; s += 8;\n#define\tLZ4_COPYPACKET(s, d)\tLZ4_COPYSTEP(s, d)\n#define\tLZ4_SECURECOPY(s, d, e)\tif (d < e) LZ4_WILDCOPY(s, d, e)\n#define\tHTYPE U32\n#define\tINITBASE(base)\t\tconst BYTE* const base = ip\n#else  \n#define\tSTEPSIZE 4\n#define\tUARCH U32\n#define\tAARCH A32\n#define\tLZ4_COPYSTEP(s, d)\tA32(d) = A32(s); d += 4; s += 4;\n#define\tLZ4_COPYPACKET(s, d)\tLZ4_COPYSTEP(s, d); LZ4_COPYSTEP(s, d);\n#define\tLZ4_SECURECOPY\t\tLZ4_WILDCOPY\n#define\tHTYPE const BYTE *\n#define\tINITBASE(base)\t\tconst int base = 0\n#endif  \n\n#if (defined(LZ4_BIG_ENDIAN) && !defined(BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE))\n#define\tLZ4_READ_LITTLEENDIAN_16(d, s, p) \\\n\t{ U16 v = A16(p); v = lz4_bswap16(v); d = (s) - v; }\n#define\tLZ4_WRITE_LITTLEENDIAN_16(p, i) \\\n\t{ U16 v = (U16)(i); v = lz4_bswap16(v); A16(p) = v; p += 2; }\n#else\n#define\tLZ4_READ_LITTLEENDIAN_16(d, s, p) { d = (s) - A16(p); }\n#define\tLZ4_WRITE_LITTLEENDIAN_16(p, v)  { A16(p) = v; p += 2; }\n#endif\n\n\n \nstruct refTables {\n\tHTYPE hashTable[HASHTABLESIZE];\n};\n\n\n \n#define\tLZ4_HASH_FUNCTION(i) (((i) * 2654435761U) >> ((MINMATCH * 8) - \\\n\tHASH_LOG))\n#define\tLZ4_HASH_VALUE(p) LZ4_HASH_FUNCTION(A32(p))\n#define\tLZ4_WILDCOPY(s, d, e) do { LZ4_COPYPACKET(s, d) } while (d < e);\n#define\tLZ4_BLINDCOPY(s, d, l) { BYTE* e = (d) + l; LZ4_WILDCOPY(s, d, e); \\\n\td = e; }\n\n\n \n#if LZ4_ARCH64\n\nstatic inline int\nLZ4_NbCommonBytes(register U64 val)\n{\n#if defined(LZ4_BIG_ENDIAN)\n#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \\\n\t!defined(LZ4_FORCE_SW_BITCOUNT)\n\treturn (__builtin_clzll(val) >> 3);\n#else\n\tint r;\n\tif (!(val >> 32)) {\n\t\tr = 4;\n\t} else {\n\t\tr = 0;\n\t\tval >>= 32;\n\t}\n\tif (!(val >> 16)) {\n\t\tr += 2;\n\t\tval >>= 8;\n\t} else {\n\t\tval >>= 24;\n\t}\n\tr += (!val);\n\treturn (r);\n#endif\n#else\n#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \\\n\t!defined(LZ4_FORCE_SW_BITCOUNT)\n\treturn (__builtin_ctzll(val) >> 3);\n#else\n\tstatic const int DeBruijnBytePos[64] =\n\t    { 0, 0, 0, 0, 0, 1, 1, 2, 0, 3, 1, 3, 1, 4, 2, 7, 0, 2, 3, 6, 1, 5,\n\t\t3, 5, 1, 3, 4, 4, 2, 5, 6, 7, 7, 0, 1, 2, 3, 3, 4, 6, 2, 6, 5,\n\t\t5, 3, 4, 5, 6, 7, 1, 2, 4, 6, 4,\n\t\t4, 5, 7, 2, 6, 5, 7, 6, 7, 7\n\t};\n\treturn DeBruijnBytePos[((U64) ((val & -val) * 0x0218A392CDABBD3F)) >>\n\t    58];\n#endif\n#endif\n}\n\n#else\n\nstatic inline int\nLZ4_NbCommonBytes(register U32 val)\n{\n#if defined(LZ4_BIG_ENDIAN)\n#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \\\n\t!defined(LZ4_FORCE_SW_BITCOUNT)\n\treturn (__builtin_clz(val) >> 3);\n#else\n\tint r;\n\tif (!(val >> 16)) {\n\t\tr = 2;\n\t\tval >>= 8;\n\t} else {\n\t\tr = 0;\n\t\tval >>= 24;\n\t}\n\tr += (!val);\n\treturn (r);\n#endif\n#else\n#if defined(__GNUC__) && (GCC_VERSION >= 304) && \\\n\t!defined(LZ4_FORCE_SW_BITCOUNT)\n\treturn (__builtin_ctz(val) >> 3);\n#else\n\tstatic const int DeBruijnBytePos[32] = {\n\t\t0, 0, 3, 0, 3, 1, 3, 0,\n\t\t3, 2, 2, 1, 3, 2, 0, 1,\n\t\t3, 3, 1, 2, 2, 2, 2, 0,\n\t\t3, 1, 2, 0, 1, 0, 1, 1\n\t};\n\treturn DeBruijnBytePos[((U32) ((val & -(S32) val) * 0x077CB531U)) >>\n\t    27];\n#endif\n#endif\n}\n\n#endif\n\n \n\nstatic int\nLZ4_compressCtx(void *ctx, const char *source, char *dest, int isize,\n    int osize)\n{\n\tstruct refTables *srt = (struct refTables *)ctx;\n\tHTYPE *HashTable = (HTYPE *) (srt->hashTable);\n\n\tconst BYTE *ip = (BYTE *) source;\n\tINITBASE(base);\n\tconst BYTE *anchor = ip;\n\tconst BYTE *const iend = ip + isize;\n\tconst BYTE *const oend = (BYTE *) dest + osize;\n\tconst BYTE *const mflimit = iend - MFLIMIT;\n#define\tmatchlimit (iend - LASTLITERALS)\n\n\tBYTE *op = (BYTE *) dest;\n\n\tint len, length;\n\tconst int skipStrength = SKIPSTRENGTH;\n\tU32 forwardH;\n\n\n\t \n\tif (isize < MINLENGTH)\n\t\tgoto _last_literals;\n\n\t \n\tHashTable[LZ4_HASH_VALUE(ip)] = ip - base;\n\tip++;\n\tforwardH = LZ4_HASH_VALUE(ip);\n\n\t \n\tfor (;;) {\n\t\tint findMatchAttempts = (1U << skipStrength) + 3;\n\t\tconst BYTE *forwardIp = ip;\n\t\tconst BYTE *ref;\n\t\tBYTE *token;\n\n\t\t \n\t\tdo {\n\t\t\tU32 h = forwardH;\n\t\t\tint step = findMatchAttempts++ >> skipStrength;\n\t\t\tip = forwardIp;\n\t\t\tforwardIp = ip + step;\n\n\t\t\tif (unlikely(forwardIp > mflimit)) {\n\t\t\t\tgoto _last_literals;\n\t\t\t}\n\n\t\t\tforwardH = LZ4_HASH_VALUE(forwardIp);\n\t\t\tref = base + HashTable[h];\n\t\t\tHashTable[h] = ip - base;\n\n\t\t} while ((ref < ip - MAX_DISTANCE) || (A32(ref) != A32(ip)));\n\n\t\t \n\t\twhile ((ip > anchor) && (ref > (BYTE *) source) &&\n\t\t    unlikely(ip[-1] == ref[-1])) {\n\t\t\tip--;\n\t\t\tref--;\n\t\t}\n\n\t\t \n\t\tlength = ip - anchor;\n\t\ttoken = op++;\n\n\t\t \n\t\tif (unlikely(op + length + (2 + 1 + LASTLITERALS) +\n\t\t    (length >> 8) > oend))\n\t\t\treturn (0);\n\n\t\tif (length >= (int)RUN_MASK) {\n\t\t\t*token = (RUN_MASK << ML_BITS);\n\t\t\tlen = length - RUN_MASK;\n\t\t\tfor (; len > 254; len -= 255)\n\t\t\t\t*op++ = 255;\n\t\t\t*op++ = (BYTE)len;\n\t\t} else\n\t\t\t*token = (length << ML_BITS);\n\n\t\t \n\t\tLZ4_BLINDCOPY(anchor, op, length);\n\n\t\t_next_match:\n\t\t \n\t\tLZ4_WRITE_LITTLEENDIAN_16(op, ip - ref);\n\n\t\t \n\t\tip += MINMATCH;\n\t\tref += MINMATCH;\t \n\t\tanchor = ip;\n\t\twhile (likely(ip < matchlimit - (STEPSIZE - 1))) {\n\t\t\tUARCH diff = AARCH(ref) ^ AARCH(ip);\n\t\t\tif (!diff) {\n\t\t\t\tip += STEPSIZE;\n\t\t\t\tref += STEPSIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tip += LZ4_NbCommonBytes(diff);\n\t\t\tgoto _endCount;\n\t\t}\n#if LZ4_ARCH64\n\t\tif ((ip < (matchlimit - 3)) && (A32(ref) == A32(ip))) {\n\t\t\tip += 4;\n\t\t\tref += 4;\n\t\t}\n#endif\n\t\tif ((ip < (matchlimit - 1)) && (A16(ref) == A16(ip))) {\n\t\t\tip += 2;\n\t\t\tref += 2;\n\t\t}\n\t\tif ((ip < matchlimit) && (*ref == *ip))\n\t\t\tip++;\n\t\t_endCount:\n\n\t\t \n\t\tlen = (ip - anchor);\n\t\t \n\t\tif (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))\n\t\t\treturn (0);\n\t\tif (len >= (int)ML_MASK) {\n\t\t\t*token += ML_MASK;\n\t\t\tlen -= ML_MASK;\n\t\t\tfor (; len > 509; len -= 510) {\n\t\t\t\t*op++ = 255;\n\t\t\t\t*op++ = 255;\n\t\t\t}\n\t\t\tif (len > 254) {\n\t\t\t\tlen -= 255;\n\t\t\t\t*op++ = 255;\n\t\t\t}\n\t\t\t*op++ = (BYTE)len;\n\t\t} else\n\t\t\t*token += len;\n\n\t\t \n\t\tif (ip > mflimit) {\n\t\t\tanchor = ip;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tHashTable[LZ4_HASH_VALUE(ip - 2)] = ip - 2 - base;\n\n\t\t \n\t\tref = base + HashTable[LZ4_HASH_VALUE(ip)];\n\t\tHashTable[LZ4_HASH_VALUE(ip)] = ip - base;\n\t\tif ((ref > ip - (MAX_DISTANCE + 1)) && (A32(ref) == A32(ip))) {\n\t\t\ttoken = op++;\n\t\t\t*token = 0;\n\t\t\tgoto _next_match;\n\t\t}\n\t\t \n\t\tanchor = ip++;\n\t\tforwardH = LZ4_HASH_VALUE(ip);\n\t}\n\n\t_last_literals:\n\t \n\t{\n\t\tint lastRun = iend - anchor;\n\t\tif (op + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) >\n\t\t    oend)\n\t\t\treturn (0);\n\t\tif (lastRun >= (int)RUN_MASK) {\n\t\t\t*op++ = (RUN_MASK << ML_BITS);\n\t\t\tlastRun -= RUN_MASK;\n\t\t\tfor (; lastRun > 254; lastRun -= 255) {\n\t\t\t\t*op++ = 255;\n\t\t\t}\n\t\t\t*op++ = (BYTE)lastRun;\n\t\t} else\n\t\t\t*op++ = (lastRun << ML_BITS);\n\t\t(void) memcpy(op, anchor, iend - anchor);\n\t\top += iend - anchor;\n\t}\n\n\t \n\treturn (int)(((char *)op) - dest);\n}\n\n\n\n \n#define\tLZ4_64KLIMIT ((1 << 16) + (MFLIMIT - 1))\n#define\tHASHLOG64K (HASH_LOG + 1)\n#define\tHASH64KTABLESIZE (1U << HASHLOG64K)\n#define\tLZ4_HASH64K_FUNCTION(i)\t(((i) * 2654435761U) >> ((MINMATCH*8) - \\\n\tHASHLOG64K))\n#define\tLZ4_HASH64K_VALUE(p)\tLZ4_HASH64K_FUNCTION(A32(p))\n\nstatic int\nLZ4_compress64kCtx(void *ctx, const char *source, char *dest, int isize,\n    int osize)\n{\n\tstruct refTables *srt = (struct refTables *)ctx;\n\tU16 *HashTable = (U16 *) (srt->hashTable);\n\n\tconst BYTE *ip = (BYTE *) source;\n\tconst BYTE *anchor = ip;\n\tconst BYTE *const base = ip;\n\tconst BYTE *const iend = ip + isize;\n\tconst BYTE *const oend = (BYTE *) dest + osize;\n\tconst BYTE *const mflimit = iend - MFLIMIT;\n#define\tmatchlimit (iend - LASTLITERALS)\n\n\tBYTE *op = (BYTE *) dest;\n\n\tint len, length;\n\tconst int skipStrength = SKIPSTRENGTH;\n\tU32 forwardH;\n\n\t \n\tif (isize < MINLENGTH)\n\t\tgoto _last_literals;\n\n\t \n\tip++;\n\tforwardH = LZ4_HASH64K_VALUE(ip);\n\n\t \n\tfor (;;) {\n\t\tint findMatchAttempts = (1U << skipStrength) + 3;\n\t\tconst BYTE *forwardIp = ip;\n\t\tconst BYTE *ref;\n\t\tBYTE *token;\n\n\t\t \n\t\tdo {\n\t\t\tU32 h = forwardH;\n\t\t\tint step = findMatchAttempts++ >> skipStrength;\n\t\t\tip = forwardIp;\n\t\t\tforwardIp = ip + step;\n\n\t\t\tif (forwardIp > mflimit) {\n\t\t\t\tgoto _last_literals;\n\t\t\t}\n\n\t\t\tforwardH = LZ4_HASH64K_VALUE(forwardIp);\n\t\t\tref = base + HashTable[h];\n\t\t\tHashTable[h] = ip - base;\n\n\t\t} while (A32(ref) != A32(ip));\n\n\t\t \n\t\twhile ((ip > anchor) && (ref > (BYTE *) source) &&\n\t\t    (ip[-1] == ref[-1])) {\n\t\t\tip--;\n\t\t\tref--;\n\t\t}\n\n\t\t \n\t\tlength = ip - anchor;\n\t\ttoken = op++;\n\n\t\t \n\t\tif (unlikely(op + length + (2 + 1 + LASTLITERALS) +\n\t\t    (length >> 8) > oend))\n\t\t\treturn (0);\n\n\t\tif (length >= (int)RUN_MASK) {\n\t\t\t*token = (RUN_MASK << ML_BITS);\n\t\t\tlen = length - RUN_MASK;\n\t\t\tfor (; len > 254; len -= 255)\n\t\t\t\t*op++ = 255;\n\t\t\t*op++ = (BYTE)len;\n\t\t} else\n\t\t\t*token = (length << ML_BITS);\n\n\t\t \n\t\tLZ4_BLINDCOPY(anchor, op, length);\n\n\t\t_next_match:\n\t\t \n\t\tLZ4_WRITE_LITTLEENDIAN_16(op, ip - ref);\n\n\t\t \n\t\tip += MINMATCH;\n\t\tref += MINMATCH;\t \n\t\tanchor = ip;\n\t\twhile (ip < matchlimit - (STEPSIZE - 1)) {\n\t\t\tUARCH diff = AARCH(ref) ^ AARCH(ip);\n\t\t\tif (!diff) {\n\t\t\t\tip += STEPSIZE;\n\t\t\t\tref += STEPSIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tip += LZ4_NbCommonBytes(diff);\n\t\t\tgoto _endCount;\n\t\t}\n#if LZ4_ARCH64\n\t\tif ((ip < (matchlimit - 3)) && (A32(ref) == A32(ip))) {\n\t\t\tip += 4;\n\t\t\tref += 4;\n\t\t}\n#endif\n\t\tif ((ip < (matchlimit - 1)) && (A16(ref) == A16(ip))) {\n\t\t\tip += 2;\n\t\t\tref += 2;\n\t\t}\n\t\tif ((ip < matchlimit) && (*ref == *ip))\n\t\t\tip++;\n\t\t_endCount:\n\n\t\t \n\t\tlen = (ip - anchor);\n\t\t \n\t\tif (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))\n\t\t\treturn (0);\n\t\tif (len >= (int)ML_MASK) {\n\t\t\t*token += ML_MASK;\n\t\t\tlen -= ML_MASK;\n\t\t\tfor (; len > 509; len -= 510) {\n\t\t\t\t*op++ = 255;\n\t\t\t\t*op++ = 255;\n\t\t\t}\n\t\t\tif (len > 254) {\n\t\t\t\tlen -= 255;\n\t\t\t\t*op++ = 255;\n\t\t\t}\n\t\t\t*op++ = (BYTE)len;\n\t\t} else\n\t\t\t*token += len;\n\n\t\t \n\t\tif (ip > mflimit) {\n\t\t\tanchor = ip;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tHashTable[LZ4_HASH64K_VALUE(ip - 2)] = ip - 2 - base;\n\n\t\t \n\t\tref = base + HashTable[LZ4_HASH64K_VALUE(ip)];\n\t\tHashTable[LZ4_HASH64K_VALUE(ip)] = ip - base;\n\t\tif (A32(ref) == A32(ip)) {\n\t\t\ttoken = op++;\n\t\t\t*token = 0;\n\t\t\tgoto _next_match;\n\t\t}\n\t\t \n\t\tanchor = ip++;\n\t\tforwardH = LZ4_HASH64K_VALUE(ip);\n\t}\n\n\t_last_literals:\n\t \n\t{\n\t\tint lastRun = iend - anchor;\n\t\tif (op + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) >\n\t\t    oend)\n\t\t\treturn (0);\n\t\tif (lastRun >= (int)RUN_MASK) {\n\t\t\t*op++ = (RUN_MASK << ML_BITS);\n\t\t\tlastRun -= RUN_MASK;\n\t\t\tfor (; lastRun > 254; lastRun -= 255)\n\t\t\t\t*op++ = 255;\n\t\t\t*op++ = (BYTE)lastRun;\n\t\t} else\n\t\t\t*op++ = (lastRun << ML_BITS);\n\t\t(void) memcpy(op, anchor, iend - anchor);\n\t\top += iend - anchor;\n\t}\n\n\t \n\treturn (int)(((char *)op) - dest);\n}\n\nstatic int\nreal_LZ4_compress(const char *source, char *dest, int isize, int osize)\n{\n\tvoid *ctx;\n\tint result;\n\n\tASSERT(lz4_cache != NULL);\n\tctx = kmem_cache_alloc(lz4_cache, KM_SLEEP);\n\n\t \n\tif (ctx == NULL)\n\t\treturn (0);\n\n\tmemset(ctx, 0, sizeof (struct refTables));\n\n\tif (isize < LZ4_64KLIMIT)\n\t\tresult = LZ4_compress64kCtx(ctx, source, dest, isize, osize);\n\telse\n\t\tresult = LZ4_compressCtx(ctx, source, dest, isize, osize);\n\n\tkmem_cache_free(lz4_cache, ctx);\n\treturn (result);\n}\n\nvoid\nlz4_init(void)\n{\n\tlz4_cache = kmem_cache_create(\"lz4_cache\",\n\t    sizeof (struct refTables), 0, NULL, NULL, NULL, NULL, NULL, 0);\n}\n\nvoid\nlz4_fini(void)\n{\n\tif (lz4_cache) {\n\t\tkmem_cache_destroy(lz4_cache);\n\t\tlz4_cache = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}