{
  "module_name": "vdev_indirect_mapping.c",
  "hash_id": "761cf4461dad5d8a02b767ba0416bbdae7c154c3f50f4ef0ec3f14fade33bc46",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_indirect_mapping.c",
  "human_readable_source": " \n\n \n\n#include <sys/dmu_tx.h>\n#include <sys/dsl_pool.h>\n#include <sys/spa.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_indirect_mapping.h>\n#include <sys/zfeature.h>\n#include <sys/dmu_objset.h>\n\n#ifdef ZFS_DEBUG\nstatic boolean_t\nvdev_indirect_mapping_verify(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vim != NULL);\n\n\tASSERT(vim->vim_object != 0);\n\tASSERT(vim->vim_objset != NULL);\n\tASSERT(vim->vim_phys != NULL);\n\tASSERT(vim->vim_dbuf != NULL);\n\n\tEQUIV(vim->vim_phys->vimp_num_entries > 0,\n\t    vim->vim_entries != NULL);\n\tif (vim->vim_phys->vimp_num_entries > 0) {\n\t\tvdev_indirect_mapping_entry_phys_t *last_entry __maybe_unused =\n\t\t    &vim->vim_entries[vim->vim_phys->vimp_num_entries - 1];\n\t\tuint64_t offset __maybe_unused =\n\t\t    DVA_MAPPING_GET_SRC_OFFSET(last_entry);\n\t\tuint64_t size __maybe_unused =\n\t\t    DVA_GET_ASIZE(&last_entry->vimep_dst);\n\n\t\tASSERT3U(vim->vim_phys->vimp_max_offset, >=, offset + size);\n\t}\n\tif (vim->vim_havecounts) {\n\t\tASSERT(vim->vim_phys->vimp_counts_object != 0);\n\t}\n\n\treturn (B_TRUE);\n}\n#else\n#define\tvdev_indirect_mapping_verify(vim) ((void) sizeof (vim), B_TRUE)\n#endif\n\nuint64_t\nvdev_indirect_mapping_num_entries(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\treturn (vim->vim_phys->vimp_num_entries);\n}\n\nuint64_t\nvdev_indirect_mapping_max_offset(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\treturn (vim->vim_phys->vimp_max_offset);\n}\n\nuint64_t\nvdev_indirect_mapping_object(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\treturn (vim->vim_object);\n}\n\nuint64_t\nvdev_indirect_mapping_bytes_mapped(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\treturn (vim->vim_phys->vimp_bytes_mapped);\n}\n\n \nuint64_t\nvdev_indirect_mapping_size(vdev_indirect_mapping_t *vim)\n{\n\treturn (vim->vim_phys->vimp_num_entries * sizeof (*vim->vim_entries));\n}\n\n \nstatic int\ndva_mapping_overlap_compare(const void *v_key, const void *v_array_elem)\n{\n\tconst uint64_t * const key = v_key;\n\tconst vdev_indirect_mapping_entry_phys_t * const array_elem =\n\t    v_array_elem;\n\tuint64_t src_offset = DVA_MAPPING_GET_SRC_OFFSET(array_elem);\n\n\tif (*key < src_offset) {\n\t\treturn (-1);\n\t} else if (*key < src_offset + DVA_GET_ASIZE(&array_elem->vimep_dst)) {\n\t\treturn (0);\n\t} else {\n\t\treturn (1);\n\t}\n}\n\n \nstatic vdev_indirect_mapping_entry_phys_t *\nvdev_indirect_mapping_entry_for_offset_impl(vdev_indirect_mapping_t *vim,\n    uint64_t offset, boolean_t next_if_missing)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\tASSERT(vim->vim_phys->vimp_num_entries > 0);\n\n\tvdev_indirect_mapping_entry_phys_t *entry = NULL;\n\n\tuint64_t last = vim->vim_phys->vimp_num_entries - 1;\n\tuint64_t base = 0;\n\n\t \n\tuint64_t mid;\n\tint result;\n\n\twhile (last >= base) {\n\t\tmid = base + ((last - base) >> 1);\n\n\t\tresult = dva_mapping_overlap_compare(&offset,\n\t\t    &vim->vim_entries[mid]);\n\n\t\tif (result == 0) {\n\t\t\tentry = &vim->vim_entries[mid];\n\t\t\tbreak;\n\t\t} else if (result < 0) {\n\t\t\tlast = mid - 1;\n\t\t} else {\n\t\t\tbase = mid + 1;\n\t\t}\n\t}\n\n\tif (entry == NULL && next_if_missing) {\n\t\tASSERT3U(base, ==, last + 1);\n\t\tASSERT(mid == base || mid == last);\n\t\tASSERT3S(result, !=, 0);\n\n\t\t \n\n\t\tuint64_t index;\n\t\tif (result < 0)\n\t\t\tindex = mid;\n\t\telse\n\t\t\tindex = mid + 1;\n\n\t\tASSERT3U(index, <=, vim->vim_phys->vimp_num_entries);\n\n\t\tif (index == vim->vim_phys->vimp_num_entries) {\n\t\t\t \n\n\t\t\tASSERT3S(dva_mapping_overlap_compare(&offset,\n\t\t\t    &vim->vim_entries[index - 1]), >, 0);\n\n\t\t\treturn (NULL);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3S(dva_mapping_overlap_compare(&offset,\n\t\t\t    &vim->vim_entries[index]), <, 0);\n\t\t\tIMPLY(index >= 1, dva_mapping_overlap_compare(&offset,\n\t\t\t    &vim->vim_entries[index - 1]) > 0);\n\n\t\t\treturn (&vim->vim_entries[index]);\n\t\t}\n\t} else {\n\t\treturn (entry);\n\t}\n}\n\nvdev_indirect_mapping_entry_phys_t *\nvdev_indirect_mapping_entry_for_offset(vdev_indirect_mapping_t *vim,\n    uint64_t offset)\n{\n\treturn (vdev_indirect_mapping_entry_for_offset_impl(vim, offset,\n\t    B_FALSE));\n}\n\nvdev_indirect_mapping_entry_phys_t *\nvdev_indirect_mapping_entry_for_offset_or_next(vdev_indirect_mapping_t *vim,\n    uint64_t offset)\n{\n\treturn (vdev_indirect_mapping_entry_for_offset_impl(vim, offset,\n\t    B_TRUE));\n}\n\nvoid\nvdev_indirect_mapping_close(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\tif (vim->vim_phys->vimp_num_entries > 0) {\n\t\tuint64_t map_size = vdev_indirect_mapping_size(vim);\n\t\tvmem_free(vim->vim_entries, map_size);\n\t\tvim->vim_entries = NULL;\n\t}\n\n\tdmu_buf_rele(vim->vim_dbuf, vim);\n\n\tvim->vim_objset = NULL;\n\tvim->vim_object = 0;\n\tvim->vim_dbuf = NULL;\n\tvim->vim_phys = NULL;\n\n\tkmem_free(vim, sizeof (*vim));\n}\n\nuint64_t\nvdev_indirect_mapping_alloc(objset_t *os, dmu_tx_t *tx)\n{\n\tuint64_t object;\n\tASSERT(dmu_tx_is_syncing(tx));\n\tuint64_t bonus_size = VDEV_INDIRECT_MAPPING_SIZE_V0;\n\n\tif (spa_feature_is_enabled(os->os_spa, SPA_FEATURE_OBSOLETE_COUNTS)) {\n\t\tbonus_size = sizeof (vdev_indirect_mapping_phys_t);\n\t}\n\n\tobject = dmu_object_alloc(os,\n\t    DMU_OTN_UINT64_METADATA, SPA_OLD_MAXBLOCKSIZE,\n\t    DMU_OTN_UINT64_METADATA, bonus_size,\n\t    tx);\n\n\tif (spa_feature_is_enabled(os->os_spa, SPA_FEATURE_OBSOLETE_COUNTS)) {\n\t\tdmu_buf_t *dbuf;\n\t\tvdev_indirect_mapping_phys_t *vimp;\n\n\t\tVERIFY0(dmu_bonus_hold(os, object, FTAG, &dbuf));\n\t\tdmu_buf_will_dirty(dbuf, tx);\n\t\tvimp = dbuf->db_data;\n\t\tvimp->vimp_counts_object = dmu_object_alloc(os,\n\t\t    DMU_OTN_UINT32_METADATA, SPA_OLD_MAXBLOCKSIZE,\n\t\t    DMU_OT_NONE, 0, tx);\n\t\tspa_feature_incr(os->os_spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\t\tdmu_buf_rele(dbuf, FTAG);\n\t}\n\n\treturn (object);\n}\n\n\nvdev_indirect_mapping_t *\nvdev_indirect_mapping_open(objset_t *os, uint64_t mapping_object)\n{\n\tvdev_indirect_mapping_t *vim = kmem_zalloc(sizeof (*vim), KM_SLEEP);\n\tdmu_object_info_t doi;\n\tVERIFY0(dmu_object_info(os, mapping_object, &doi));\n\n\tvim->vim_objset = os;\n\tvim->vim_object = mapping_object;\n\n\tVERIFY0(dmu_bonus_hold(os, vim->vim_object, vim,\n\t    &vim->vim_dbuf));\n\tvim->vim_phys = vim->vim_dbuf->db_data;\n\n\tvim->vim_havecounts =\n\t    (doi.doi_bonus_size > VDEV_INDIRECT_MAPPING_SIZE_V0);\n\n\tif (vim->vim_phys->vimp_num_entries > 0) {\n\t\tuint64_t map_size = vdev_indirect_mapping_size(vim);\n\t\tvim->vim_entries = vmem_alloc(map_size, KM_SLEEP);\n\t\tVERIFY0(dmu_read(os, vim->vim_object, 0, map_size,\n\t\t    vim->vim_entries, DMU_READ_PREFETCH));\n\t}\n\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\treturn (vim);\n}\n\nvoid\nvdev_indirect_mapping_free(objset_t *os, uint64_t object, dmu_tx_t *tx)\n{\n\tvdev_indirect_mapping_t *vim = vdev_indirect_mapping_open(os, object);\n\tif (vim->vim_havecounts) {\n\t\tVERIFY0(dmu_object_free(os, vim->vim_phys->vimp_counts_object,\n\t\t    tx));\n\t\tspa_feature_decr(os->os_spa, SPA_FEATURE_OBSOLETE_COUNTS, tx);\n\t}\n\tvdev_indirect_mapping_close(vim);\n\n\tVERIFY0(dmu_object_free(os, object, tx));\n}\n\n \nvoid\nvdev_indirect_mapping_add_entries(vdev_indirect_mapping_t *vim,\n    list_t *list, dmu_tx_t *tx)\n{\n\tvdev_indirect_mapping_entry_phys_t *mapbuf;\n\tuint64_t old_size;\n\tuint32_t *countbuf = NULL;\n\tvdev_indirect_mapping_entry_phys_t *old_entries;\n\tuint64_t old_count;\n\tuint64_t entries_written = 0;\n\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dsl_pool_sync_context(dmu_tx_pool(tx)));\n\tASSERT(!list_is_empty(list));\n\n\told_size = vdev_indirect_mapping_size(vim);\n\told_entries = vim->vim_entries;\n\told_count = vim->vim_phys->vimp_num_entries;\n\n\tdmu_buf_will_dirty(vim->vim_dbuf, tx);\n\n\tmapbuf = vmem_alloc(SPA_OLD_MAXBLOCKSIZE, KM_SLEEP);\n\tif (vim->vim_havecounts) {\n\t\tcountbuf = vmem_alloc(SPA_OLD_MAXBLOCKSIZE, KM_SLEEP);\n\t\tASSERT(spa_feature_is_active(vim->vim_objset->os_spa,\n\t\t    SPA_FEATURE_OBSOLETE_COUNTS));\n\t}\n\twhile (!list_is_empty(list)) {\n\t\tuint64_t i;\n\t\t \n\t\tfor (i = 0; i < SPA_OLD_MAXBLOCKSIZE / sizeof (*mapbuf); i++) {\n\t\t\tvdev_indirect_mapping_entry_t *entry =\n\t\t\t    list_remove_head(list);\n\t\t\tif (entry == NULL)\n\t\t\t\tbreak;\n\n\t\t\tuint64_t size =\n\t\t\t    DVA_GET_ASIZE(&entry->vime_mapping.vimep_dst);\n\t\t\tuint64_t src_offset =\n\t\t\t    DVA_MAPPING_GET_SRC_OFFSET(&entry->vime_mapping);\n\n\t\t\t \n\t\t\tASSERT3U(entry->vime_obsolete_count, <, size);\n\t\t\tIMPLY(entry->vime_obsolete_count != 0,\n\t\t\t    vim->vim_havecounts);\n\n\t\t\tmapbuf[i] = entry->vime_mapping;\n\t\t\tif (vim->vim_havecounts)\n\t\t\t\tcountbuf[i] = entry->vime_obsolete_count;\n\n\t\t\tvim->vim_phys->vimp_bytes_mapped += size;\n\t\t\tASSERT3U(src_offset, >=,\n\t\t\t    vim->vim_phys->vimp_max_offset);\n\t\t\tvim->vim_phys->vimp_max_offset = src_offset + size;\n\n\t\t\tentries_written++;\n\n\t\t\tvmem_free(entry, sizeof (*entry));\n\t\t}\n\t\tdmu_write(vim->vim_objset, vim->vim_object,\n\t\t    vim->vim_phys->vimp_num_entries * sizeof (*mapbuf),\n\t\t    i * sizeof (*mapbuf),\n\t\t    mapbuf, tx);\n\t\tif (vim->vim_havecounts) {\n\t\t\tdmu_write(vim->vim_objset,\n\t\t\t    vim->vim_phys->vimp_counts_object,\n\t\t\t    vim->vim_phys->vimp_num_entries *\n\t\t\t    sizeof (*countbuf),\n\t\t\t    i * sizeof (*countbuf), countbuf, tx);\n\t\t}\n\t\tvim->vim_phys->vimp_num_entries += i;\n\t}\n\tvmem_free(mapbuf, SPA_OLD_MAXBLOCKSIZE);\n\tif (vim->vim_havecounts)\n\t\tvmem_free(countbuf, SPA_OLD_MAXBLOCKSIZE);\n\n\t \n\tuint64_t new_size = vdev_indirect_mapping_size(vim);\n\tASSERT3U(new_size, >, old_size);\n\tASSERT3U(new_size - old_size, ==,\n\t    entries_written * sizeof (vdev_indirect_mapping_entry_phys_t));\n\tvim->vim_entries = vmem_alloc(new_size, KM_SLEEP);\n\tif (old_size > 0) {\n\t\tmemcpy(vim->vim_entries, old_entries, old_size);\n\t\tvmem_free(old_entries, old_size);\n\t}\n\tVERIFY0(dmu_read(vim->vim_objset, vim->vim_object, old_size,\n\t    new_size - old_size, &vim->vim_entries[old_count],\n\t    DMU_READ_PREFETCH));\n\n\tzfs_dbgmsg(\"txg %llu: wrote %llu entries to \"\n\t    \"indirect mapping obj %llu; max offset=0x%llx\",\n\t    (u_longlong_t)dmu_tx_get_txg(tx),\n\t    (u_longlong_t)entries_written,\n\t    (u_longlong_t)vim->vim_object,\n\t    (u_longlong_t)vim->vim_phys->vimp_max_offset);\n}\n\n \nvoid\nvdev_indirect_mapping_increment_obsolete_count(vdev_indirect_mapping_t *vim,\n    uint64_t offset, uint64_t length, uint32_t *counts)\n{\n\tvdev_indirect_mapping_entry_phys_t *mapping;\n\tuint64_t index;\n\n\tmapping = vdev_indirect_mapping_entry_for_offset(vim,  offset);\n\n\tASSERT(length > 0);\n\tASSERT3P(mapping, !=, NULL);\n\n\tindex = mapping - vim->vim_entries;\n\n\twhile (length > 0) {\n\t\tASSERT3U(index, <, vdev_indirect_mapping_num_entries(vim));\n\n\t\tuint64_t size = DVA_GET_ASIZE(&mapping->vimep_dst);\n\t\tuint64_t inner_offset = offset -\n\t\t    DVA_MAPPING_GET_SRC_OFFSET(mapping);\n\t\tVERIFY3U(inner_offset, <, size);\n\t\tuint64_t inner_size = MIN(length, size - inner_offset);\n\n\t\tVERIFY3U(counts[index] + inner_size, <=, size);\n\t\tcounts[index] += inner_size;\n\n\t\toffset += inner_size;\n\t\tlength -= inner_size;\n\t\tmapping++;\n\t\tindex++;\n\t}\n}\n\ntypedef struct load_obsolete_space_map_arg {\n\tvdev_indirect_mapping_t\t*losma_vim;\n\tuint32_t\t\t*losma_counts;\n} load_obsolete_space_map_arg_t;\n\nstatic int\nload_obsolete_sm_callback(space_map_entry_t *sme, void *arg)\n{\n\tload_obsolete_space_map_arg_t *losma = arg;\n\tASSERT3S(sme->sme_type, ==, SM_ALLOC);\n\n\tvdev_indirect_mapping_increment_obsolete_count(losma->losma_vim,\n\t    sme->sme_offset, sme->sme_run, losma->losma_counts);\n\n\treturn (0);\n}\n\n \nvoid\nvdev_indirect_mapping_load_obsolete_spacemap(vdev_indirect_mapping_t *vim,\n    uint32_t *counts, space_map_t *obsolete_space_sm)\n{\n\tload_obsolete_space_map_arg_t losma;\n\tlosma.losma_counts = counts;\n\tlosma.losma_vim = vim;\n\tVERIFY0(space_map_iterate(obsolete_space_sm,\n\t    space_map_length(obsolete_space_sm),\n\t    load_obsolete_sm_callback, &losma));\n}\n\n \nuint32_t *\nvdev_indirect_mapping_load_obsolete_counts(vdev_indirect_mapping_t *vim)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\tuint64_t counts_size =\n\t    vim->vim_phys->vimp_num_entries * sizeof (uint32_t);\n\tuint32_t *counts = vmem_alloc(counts_size, KM_SLEEP);\n\tif (vim->vim_havecounts) {\n\t\tVERIFY0(dmu_read(vim->vim_objset,\n\t\t    vim->vim_phys->vimp_counts_object,\n\t\t    0, counts_size,\n\t\t    counts, DMU_READ_PREFETCH));\n\t} else {\n\t\tmemset(counts, 0, counts_size);\n\t}\n\treturn (counts);\n}\n\nextern void\nvdev_indirect_mapping_free_obsolete_counts(vdev_indirect_mapping_t *vim,\n    uint32_t *counts)\n{\n\tASSERT(vdev_indirect_mapping_verify(vim));\n\n\tvmem_free(counts, vim->vim_phys->vimp_num_entries * sizeof (uint32_t));\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(vdev_indirect_mapping_add_entries);\nEXPORT_SYMBOL(vdev_indirect_mapping_alloc);\nEXPORT_SYMBOL(vdev_indirect_mapping_bytes_mapped);\nEXPORT_SYMBOL(vdev_indirect_mapping_close);\nEXPORT_SYMBOL(vdev_indirect_mapping_entry_for_offset);\nEXPORT_SYMBOL(vdev_indirect_mapping_entry_for_offset_or_next);\nEXPORT_SYMBOL(vdev_indirect_mapping_free);\nEXPORT_SYMBOL(vdev_indirect_mapping_free_obsolete_counts);\nEXPORT_SYMBOL(vdev_indirect_mapping_increment_obsolete_count);\nEXPORT_SYMBOL(vdev_indirect_mapping_load_obsolete_counts);\nEXPORT_SYMBOL(vdev_indirect_mapping_load_obsolete_spacemap);\nEXPORT_SYMBOL(vdev_indirect_mapping_max_offset);\nEXPORT_SYMBOL(vdev_indirect_mapping_num_entries);\nEXPORT_SYMBOL(vdev_indirect_mapping_object);\nEXPORT_SYMBOL(vdev_indirect_mapping_open);\nEXPORT_SYMBOL(vdev_indirect_mapping_size);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}