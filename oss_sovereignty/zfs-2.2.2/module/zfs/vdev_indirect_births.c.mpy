{
  "module_name": "vdev_indirect_births.c",
  "hash_id": "c19633df9da77b7d835b0463af98b3be83e042264c46a8c642239ceb7aab0f1b",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_indirect_births.c",
  "human_readable_source": " \n\n \n\n#include <sys/dmu_tx.h>\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/dsl_pool.h>\n#include <sys/vdev_indirect_births.h>\n\n#ifdef ZFS_DEBUG\nstatic boolean_t\nvdev_indirect_births_verify(vdev_indirect_births_t *vib)\n{\n\tASSERT(vib != NULL);\n\n\tASSERT(vib->vib_object != 0);\n\tASSERT(vib->vib_objset != NULL);\n\tASSERT(vib->vib_phys != NULL);\n\tASSERT(vib->vib_dbuf != NULL);\n\n\tEQUIV(vib->vib_phys->vib_count > 0, vib->vib_entries != NULL);\n\n\treturn (B_TRUE);\n}\n#else\n#define\tvdev_indirect_births_verify(vib) ((void) sizeof (vib), B_TRUE)\n#endif\n\nuint64_t\nvdev_indirect_births_count(vdev_indirect_births_t *vib)\n{\n\tASSERT(vdev_indirect_births_verify(vib));\n\n\treturn (vib->vib_phys->vib_count);\n}\n\nuint64_t\nvdev_indirect_births_object(vdev_indirect_births_t *vib)\n{\n\tASSERT(vdev_indirect_births_verify(vib));\n\n\treturn (vib->vib_object);\n}\n\nstatic uint64_t\nvdev_indirect_births_size_impl(vdev_indirect_births_t *vib)\n{\n\treturn (vib->vib_phys->vib_count * sizeof (*vib->vib_entries));\n}\n\nvoid\nvdev_indirect_births_close(vdev_indirect_births_t *vib)\n{\n\tASSERT(vdev_indirect_births_verify(vib));\n\n\tif (vib->vib_phys->vib_count > 0) {\n\t\tuint64_t births_size = vdev_indirect_births_size_impl(vib);\n\n\t\tvmem_free(vib->vib_entries, births_size);\n\t\tvib->vib_entries = NULL;\n\t}\n\n\tdmu_buf_rele(vib->vib_dbuf, vib);\n\n\tvib->vib_objset = NULL;\n\tvib->vib_object = 0;\n\tvib->vib_dbuf = NULL;\n\tvib->vib_phys = NULL;\n\n\tkmem_free(vib, sizeof (*vib));\n}\n\nuint64_t\nvdev_indirect_births_alloc(objset_t *os, dmu_tx_t *tx)\n{\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\treturn (dmu_object_alloc(os,\n\t    DMU_OTN_UINT64_METADATA, SPA_OLD_MAXBLOCKSIZE,\n\t    DMU_OTN_UINT64_METADATA, sizeof (vdev_indirect_birth_phys_t),\n\t    tx));\n}\n\nvdev_indirect_births_t *\nvdev_indirect_births_open(objset_t *os, uint64_t births_object)\n{\n\tvdev_indirect_births_t *vib = kmem_zalloc(sizeof (*vib), KM_SLEEP);\n\n\tvib->vib_objset = os;\n\tvib->vib_object = births_object;\n\n\tVERIFY0(dmu_bonus_hold(os, vib->vib_object, vib, &vib->vib_dbuf));\n\tvib->vib_phys = vib->vib_dbuf->db_data;\n\n\tif (vib->vib_phys->vib_count > 0) {\n\t\tuint64_t births_size = vdev_indirect_births_size_impl(vib);\n\t\tvib->vib_entries = vmem_alloc(births_size, KM_SLEEP);\n\t\tVERIFY0(dmu_read(vib->vib_objset, vib->vib_object, 0,\n\t\t    births_size, vib->vib_entries, DMU_READ_PREFETCH));\n\t}\n\n\tASSERT(vdev_indirect_births_verify(vib));\n\n\treturn (vib);\n}\n\nvoid\nvdev_indirect_births_free(objset_t *os, uint64_t object, dmu_tx_t *tx)\n{\n\tVERIFY0(dmu_object_free(os, object, tx));\n}\n\nvoid\nvdev_indirect_births_add_entry(vdev_indirect_births_t *vib,\n    uint64_t max_offset, uint64_t txg, dmu_tx_t *tx)\n{\n\tvdev_indirect_birth_entry_phys_t vibe;\n\tuint64_t old_size;\n\tuint64_t new_size;\n\tvdev_indirect_birth_entry_phys_t *new_entries;\n\n\tASSERT(dmu_tx_is_syncing(tx));\n\tASSERT(dsl_pool_sync_context(dmu_tx_pool(tx)));\n\tASSERT(vdev_indirect_births_verify(vib));\n\n\tdmu_buf_will_dirty(vib->vib_dbuf, tx);\n\n\tvibe.vibe_offset = max_offset;\n\tvibe.vibe_phys_birth_txg = txg;\n\n\told_size = vdev_indirect_births_size_impl(vib);\n\tdmu_write(vib->vib_objset, vib->vib_object, old_size, sizeof (vibe),\n\t    &vibe, tx);\n\tvib->vib_phys->vib_count++;\n\tnew_size = vdev_indirect_births_size_impl(vib);\n\n\tnew_entries = vmem_alloc(new_size, KM_SLEEP);\n\tif (old_size > 0) {\n\t\tmemcpy(new_entries, vib->vib_entries, old_size);\n\t\tvmem_free(vib->vib_entries, old_size);\n\t}\n\tnew_entries[vib->vib_phys->vib_count - 1] = vibe;\n\tvib->vib_entries = new_entries;\n}\n\nuint64_t\nvdev_indirect_births_last_entry_txg(vdev_indirect_births_t *vib)\n{\n\tASSERT(vdev_indirect_births_verify(vib));\n\tASSERT(vib->vib_phys->vib_count > 0);\n\n\tvdev_indirect_birth_entry_phys_t *last =\n\t    &vib->vib_entries[vib->vib_phys->vib_count - 1];\n\treturn (last->vibe_phys_birth_txg);\n}\n\n \nuint64_t\nvdev_indirect_births_physbirth(vdev_indirect_births_t *vib, uint64_t offset,\n    uint64_t asize)\n{\n\tvdev_indirect_birth_entry_phys_t *base;\n\tvdev_indirect_birth_entry_phys_t *last;\n\n\tASSERT(vdev_indirect_births_verify(vib));\n\tASSERT(vib->vib_phys->vib_count > 0);\n\n\tbase = vib->vib_entries;\n\tlast = base + vib->vib_phys->vib_count - 1;\n\n\tASSERT3U(offset, <, last->vibe_offset);\n\n\twhile (last >= base) {\n\t\tvdev_indirect_birth_entry_phys_t *p =\n\t\t    base + ((last - base) / 2);\n\t\tif (offset >= p->vibe_offset) {\n\t\t\tbase = p + 1;\n\t\t} else if (p == vib->vib_entries ||\n\t\t    offset >= (p - 1)->vibe_offset) {\n\t\t\tASSERT3U(offset + asize, <=, p->vibe_offset);\n\t\t\treturn (p->vibe_phys_birth_txg);\n\t\t} else {\n\t\t\tlast = p - 1;\n\t\t}\n\t}\n\tASSERT(!\"offset not found\");\n\treturn (-1);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(vdev_indirect_births_add_entry);\nEXPORT_SYMBOL(vdev_indirect_births_alloc);\nEXPORT_SYMBOL(vdev_indirect_births_close);\nEXPORT_SYMBOL(vdev_indirect_births_count);\nEXPORT_SYMBOL(vdev_indirect_births_free);\nEXPORT_SYMBOL(vdev_indirect_births_last_entry_txg);\nEXPORT_SYMBOL(vdev_indirect_births_object);\nEXPORT_SYMBOL(vdev_indirect_births_open);\nEXPORT_SYMBOL(vdev_indirect_births_physbirth);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}