{
  "module_name": "sa.c",
  "hash_id": "7b75a09366cacddac5b68983348ae84937c027ed5d2c0265fb42332a6a90b360",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/sa.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zap.h>\n#include <sys/sa.h>\n#include <sys/sunddi.h>\n#include <sys/sa_impl.h>\n#include <sys/errno.h>\n#include <sys/zfs_context.h>\n\n#ifdef _KERNEL\n#include <sys/zfs_znode.h>\n#endif\n\n \n\ntypedef void (sa_iterfunc_t)(void *hdr, void *addr, sa_attr_type_t,\n    uint16_t length, int length_idx, boolean_t, void *userp);\n\nstatic int sa_build_index(sa_handle_t *hdl, sa_buf_type_t buftype);\nstatic void sa_idx_tab_hold(objset_t *os, sa_idx_tab_t *idx_tab);\nstatic sa_idx_tab_t *sa_find_idx_tab(objset_t *os, dmu_object_type_t bonustype,\n    sa_hdr_phys_t *hdr);\nstatic void sa_idx_tab_rele(objset_t *os, void *arg);\nstatic void sa_copy_data(sa_data_locator_t *func, void *start, void *target,\n    int buflen);\nstatic int sa_modify_attrs(sa_handle_t *hdl, sa_attr_type_t newattr,\n    sa_data_op_t action, sa_data_locator_t *locator, void *datastart,\n    uint16_t buflen, dmu_tx_t *tx);\n\nstatic arc_byteswap_func_t sa_bswap_table[] = {\n\tbyteswap_uint64_array,\n\tbyteswap_uint32_array,\n\tbyteswap_uint16_array,\n\tbyteswap_uint8_array,\n\tzfs_acl_byteswap,\n};\n\n#ifdef HAVE_EFFICIENT_UNALIGNED_ACCESS\n#define\tSA_COPY_DATA(f, s, t, l)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (f == NULL) {\t\t\t\t\t\\\n\t\tif (l == 8) {\t\t\t\t\t\\\n\t\t\t*(uint64_t *)t = *(uint64_t *)s;\t\\\n\t\t} else if (l == 16) {\t\t\t\t\\\n\t\t\t*(uint64_t *)t = *(uint64_t *)s;\t\\\n\t\t\t*(uint64_t *)((uintptr_t)t + 8) =\t\\\n\t\t\t    *(uint64_t *)((uintptr_t)s + 8);\t\\\n\t\t} else {\t\t\t\t\t\\\n\t\t\tmemcpy(t, s, l);\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\\\n\t\tsa_copy_data(f, s, t, l);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n#else\n#define\tSA_COPY_DATA(f, s, t, l)\tsa_copy_data(f, s, t, l)\n#endif\n\n \nstatic const sa_attr_reg_t sa_legacy_attrs[] = {\n\t{\"ZPL_ATIME\", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 0},\n\t{\"ZPL_MTIME\", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 1},\n\t{\"ZPL_CTIME\", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 2},\n\t{\"ZPL_CRTIME\", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 3},\n\t{\"ZPL_GEN\", sizeof (uint64_t), SA_UINT64_ARRAY, 4},\n\t{\"ZPL_MODE\", sizeof (uint64_t), SA_UINT64_ARRAY, 5},\n\t{\"ZPL_SIZE\", sizeof (uint64_t), SA_UINT64_ARRAY, 6},\n\t{\"ZPL_PARENT\", sizeof (uint64_t), SA_UINT64_ARRAY, 7},\n\t{\"ZPL_LINKS\", sizeof (uint64_t), SA_UINT64_ARRAY, 8},\n\t{\"ZPL_XATTR\", sizeof (uint64_t), SA_UINT64_ARRAY, 9},\n\t{\"ZPL_RDEV\", sizeof (uint64_t), SA_UINT64_ARRAY, 10},\n\t{\"ZPL_FLAGS\", sizeof (uint64_t), SA_UINT64_ARRAY, 11},\n\t{\"ZPL_UID\", sizeof (uint64_t), SA_UINT64_ARRAY, 12},\n\t{\"ZPL_GID\", sizeof (uint64_t), SA_UINT64_ARRAY, 13},\n\t{\"ZPL_PAD\", sizeof (uint64_t) * 4, SA_UINT64_ARRAY, 14},\n\t{\"ZPL_ZNODE_ACL\", 88, SA_UINT8_ARRAY, 15},\n};\n\n \nstatic const sa_attr_type_t sa_legacy_zpl_layout[] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n};\n\n \nstatic const sa_attr_type_t sa_dummy_zpl_layout[] = { 0 };\n\nstatic const size_t sa_legacy_attr_count = ARRAY_SIZE(sa_legacy_attrs);\nstatic kmem_cache_t *sa_cache = NULL;\n\nstatic int\nsa_cache_constructor(void *buf, void *unused, int kmflag)\n{\n\t(void) unused, (void) kmflag;\n\tsa_handle_t *hdl = buf;\n\n\tmutex_init(&hdl->sa_lock, NULL, MUTEX_DEFAULT, NULL);\n\treturn (0);\n}\n\nstatic void\nsa_cache_destructor(void *buf, void *unused)\n{\n\t(void) unused;\n\tsa_handle_t *hdl = buf;\n\tmutex_destroy(&hdl->sa_lock);\n}\n\nvoid\nsa_cache_init(void)\n{\n\tsa_cache = kmem_cache_create(\"sa_cache\",\n\t    sizeof (sa_handle_t), 0, sa_cache_constructor,\n\t    sa_cache_destructor, NULL, NULL, NULL, 0);\n}\n\nvoid\nsa_cache_fini(void)\n{\n\tif (sa_cache)\n\t\tkmem_cache_destroy(sa_cache);\n}\n\nstatic int\nlayout_num_compare(const void *arg1, const void *arg2)\n{\n\tconst sa_lot_t *node1 = (const sa_lot_t *)arg1;\n\tconst sa_lot_t *node2 = (const sa_lot_t *)arg2;\n\n\treturn (TREE_CMP(node1->lot_num, node2->lot_num));\n}\n\nstatic int\nlayout_hash_compare(const void *arg1, const void *arg2)\n{\n\tconst sa_lot_t *node1 = (const sa_lot_t *)arg1;\n\tconst sa_lot_t *node2 = (const sa_lot_t *)arg2;\n\n\tint cmp = TREE_CMP(node1->lot_hash, node2->lot_hash);\n\tif (likely(cmp))\n\t\treturn (cmp);\n\n\treturn (TREE_CMP(node1->lot_instance, node2->lot_instance));\n}\n\nstatic boolean_t\nsa_layout_equal(sa_lot_t *tbf, sa_attr_type_t *attrs, int count)\n{\n\tint i;\n\n\tif (count != tbf->lot_attr_count)\n\t\treturn (1);\n\n\tfor (i = 0; i != count; i++) {\n\t\tif (attrs[i] != tbf->lot_attrs[i])\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\n#define\tSA_ATTR_HASH(attr) (zfs_crc64_table[(-1ULL ^ attr) & 0xFF])\n\nstatic uint64_t\nsa_layout_info_hash(const sa_attr_type_t *attrs, int attr_count)\n{\n\tuint64_t crc = -1ULL;\n\n\tfor (int i = 0; i != attr_count; i++)\n\t\tcrc ^= SA_ATTR_HASH(attrs[i]);\n\n\treturn (crc);\n}\n\nstatic int\nsa_get_spill(sa_handle_t *hdl)\n{\n\tint rc;\n\tif (hdl->sa_spill == NULL) {\n\t\tif ((rc = dmu_spill_hold_existing(hdl->sa_bonus, NULL,\n\t\t    &hdl->sa_spill)) == 0)\n\t\t\tVERIFY(0 == sa_build_index(hdl, SA_SPILL));\n\t} else {\n\t\trc = 0;\n\t}\n\n\treturn (rc);\n}\n\n \nstatic int\nsa_attr_op(sa_handle_t *hdl, sa_bulk_attr_t *bulk, int count,\n    sa_data_op_t data_op, dmu_tx_t *tx)\n{\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\tint i;\n\tint error = 0;\n\tsa_buf_type_t buftypes;\n\n\tbuftypes = 0;\n\n\tASSERT(count > 0);\n\tfor (i = 0; i != count; i++) {\n\t\tASSERT(bulk[i].sa_attr <= hdl->sa_os->os_sa->sa_num_attrs);\n\n\t\tbulk[i].sa_addr = NULL;\n\t\t \n\n\t\tif (hdl->sa_bonus_tab && TOC_ATTR_PRESENT(\n\t\t    hdl->sa_bonus_tab->sa_idx_tab[bulk[i].sa_attr])) {\n\t\t\tSA_ATTR_INFO(sa, hdl->sa_bonus_tab,\n\t\t\t    SA_GET_HDR(hdl, SA_BONUS),\n\t\t\t    bulk[i].sa_attr, bulk[i], SA_BONUS, hdl);\n\t\t\tif (tx && !(buftypes & SA_BONUS)) {\n\t\t\t\tdmu_buf_will_dirty(hdl->sa_bonus, tx);\n\t\t\t\tbuftypes |= SA_BONUS;\n\t\t\t}\n\t\t}\n\t\tif (bulk[i].sa_addr == NULL &&\n\t\t    ((error = sa_get_spill(hdl)) == 0)) {\n\t\t\tif (TOC_ATTR_PRESENT(\n\t\t\t    hdl->sa_spill_tab->sa_idx_tab[bulk[i].sa_attr])) {\n\t\t\t\tSA_ATTR_INFO(sa, hdl->sa_spill_tab,\n\t\t\t\t    SA_GET_HDR(hdl, SA_SPILL),\n\t\t\t\t    bulk[i].sa_attr, bulk[i], SA_SPILL, hdl);\n\t\t\t\tif (tx && !(buftypes & SA_SPILL) &&\n\t\t\t\t    bulk[i].sa_size == bulk[i].sa_length) {\n\t\t\t\t\tdmu_buf_will_dirty(hdl->sa_spill, tx);\n\t\t\t\t\tbuftypes |= SA_SPILL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (error && error != ENOENT) {\n\t\t\treturn ((error == ECKSUM) ? EIO : error);\n\t\t}\n\n\t\tswitch (data_op) {\n\t\tcase SA_LOOKUP:\n\t\t\tif (bulk[i].sa_addr == NULL)\n\t\t\t\treturn (SET_ERROR(ENOENT));\n\t\t\tif (bulk[i].sa_data) {\n\t\t\t\tSA_COPY_DATA(bulk[i].sa_data_func,\n\t\t\t\t    bulk[i].sa_addr, bulk[i].sa_data,\n\t\t\t\t    bulk[i].sa_size);\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase SA_UPDATE:\n\t\t\t \n\t\t\tif (bulk[i].sa_addr &&\n\t\t\t    bulk[i].sa_size == bulk[i].sa_length) {\n\t\t\t\tSA_COPY_DATA(bulk[i].sa_data_func,\n\t\t\t\t    bulk[i].sa_data, bulk[i].sa_addr,\n\t\t\t\t    bulk[i].sa_length);\n\t\t\t\tcontinue;\n\t\t\t} else if (bulk[i].sa_addr) {  \n\t\t\t\terror = sa_modify_attrs(hdl, bulk[i].sa_attr,\n\t\t\t\t    SA_REPLACE, bulk[i].sa_data_func,\n\t\t\t\t    bulk[i].sa_data, bulk[i].sa_length, tx);\n\t\t\t} else {  \n\t\t\t\terror = sa_modify_attrs(hdl, bulk[i].sa_attr,\n\t\t\t\t    SA_ADD, bulk[i].sa_data_func,\n\t\t\t\t    bulk[i].sa_data, bulk[i].sa_length, tx);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (error);\n}\n\nstatic sa_lot_t *\nsa_add_layout_entry(objset_t *os, const sa_attr_type_t *attrs, int attr_count,\n    uint64_t lot_num, uint64_t hash, boolean_t zapadd, dmu_tx_t *tx)\n{\n\tsa_os_t *sa = os->os_sa;\n\tsa_lot_t *tb, *findtb;\n\tint i;\n\tavl_index_t loc;\n\n\tASSERT(MUTEX_HELD(&sa->sa_lock));\n\ttb = kmem_zalloc(sizeof (sa_lot_t), KM_SLEEP);\n\ttb->lot_attr_count = attr_count;\n\ttb->lot_attrs = kmem_alloc(sizeof (sa_attr_type_t) * attr_count,\n\t    KM_SLEEP);\n\tmemcpy(tb->lot_attrs, attrs, sizeof (sa_attr_type_t) * attr_count);\n\ttb->lot_num = lot_num;\n\ttb->lot_hash = hash;\n\ttb->lot_instance = 0;\n\n\tif (zapadd) {\n\t\tchar attr_name[8];\n\n\t\tif (sa->sa_layout_attr_obj == 0) {\n\t\t\tsa->sa_layout_attr_obj = zap_create_link(os,\n\t\t\t    DMU_OT_SA_ATTR_LAYOUTS,\n\t\t\t    sa->sa_master_obj, SA_LAYOUTS, tx);\n\t\t}\n\n\t\t(void) snprintf(attr_name, sizeof (attr_name),\n\t\t    \"%d\", (int)lot_num);\n\t\tVERIFY(0 == zap_update(os, os->os_sa->sa_layout_attr_obj,\n\t\t    attr_name, 2, attr_count, attrs, tx));\n\t}\n\n\tlist_create(&tb->lot_idx_tab, sizeof (sa_idx_tab_t),\n\t    offsetof(sa_idx_tab_t, sa_next));\n\n\tfor (i = 0; i != attr_count; i++) {\n\t\tif (sa->sa_attr_table[tb->lot_attrs[i]].sa_length == 0)\n\t\t\ttb->lot_var_sizes++;\n\t}\n\n\tavl_add(&sa->sa_layout_num_tree, tb);\n\n\t \n\tif ((findtb = avl_find(&sa->sa_layout_hash_tree, tb, &loc)) != NULL) {\n\t\tfor (; findtb && findtb->lot_hash == hash;\n\t\t    findtb = AVL_NEXT(&sa->sa_layout_hash_tree, findtb)) {\n\t\t\tif (findtb->lot_instance != tb->lot_instance)\n\t\t\t\tbreak;\n\t\t\ttb->lot_instance++;\n\t\t}\n\t}\n\tavl_add(&sa->sa_layout_hash_tree, tb);\n\treturn (tb);\n}\n\nstatic void\nsa_find_layout(objset_t *os, uint64_t hash, sa_attr_type_t *attrs,\n    int count, dmu_tx_t *tx, sa_lot_t **lot)\n{\n\tsa_lot_t *tb, tbsearch;\n\tavl_index_t loc;\n\tsa_os_t *sa = os->os_sa;\n\tboolean_t found = B_FALSE;\n\n\tmutex_enter(&sa->sa_lock);\n\ttbsearch.lot_hash = hash;\n\ttbsearch.lot_instance = 0;\n\ttb = avl_find(&sa->sa_layout_hash_tree, &tbsearch, &loc);\n\tif (tb) {\n\t\tfor (; tb && tb->lot_hash == hash;\n\t\t    tb = AVL_NEXT(&sa->sa_layout_hash_tree, tb)) {\n\t\t\tif (sa_layout_equal(tb, attrs, count) == 0) {\n\t\t\t\tfound = B_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!found) {\n\t\ttb = sa_add_layout_entry(os, attrs, count,\n\t\t    avl_numnodes(&sa->sa_layout_num_tree), hash, B_TRUE, tx);\n\t}\n\tmutex_exit(&sa->sa_lock);\n\t*lot = tb;\n}\n\nstatic int\nsa_resize_spill(sa_handle_t *hdl, uint32_t size, dmu_tx_t *tx)\n{\n\tint error;\n\tuint32_t blocksize;\n\n\tif (size == 0) {\n\t\tblocksize = SPA_MINBLOCKSIZE;\n\t} else if (size > SPA_OLD_MAXBLOCKSIZE) {\n\t\tASSERT(0);\n\t\treturn (SET_ERROR(EFBIG));\n\t} else {\n\t\tblocksize = P2ROUNDUP_TYPED(size, SPA_MINBLOCKSIZE, uint32_t);\n\t}\n\n\terror = dbuf_spill_set_blksz(hdl->sa_spill, blocksize, tx);\n\tASSERT(error == 0);\n\treturn (error);\n}\n\nstatic void\nsa_copy_data(sa_data_locator_t *func, void *datastart, void *target, int buflen)\n{\n\tif (func == NULL) {\n\t\tmemcpy(target, datastart, buflen);\n\t} else {\n\t\tboolean_t start;\n\t\tint bytes;\n\t\tvoid *dataptr;\n\t\tvoid *saptr = target;\n\t\tuint32_t length;\n\n\t\tstart = B_TRUE;\n\t\tbytes = 0;\n\t\twhile (bytes < buflen) {\n\t\t\tfunc(&dataptr, &length, buflen, start, datastart);\n\t\t\tmemcpy(saptr, dataptr, length);\n\t\t\tsaptr = (void *)((caddr_t)saptr + length);\n\t\t\tbytes += length;\n\t\t\tstart = B_FALSE;\n\t\t}\n\t}\n}\n\n \nstatic int\nsa_find_sizes(sa_os_t *sa, sa_bulk_attr_t *attr_desc, int attr_count,\n    dmu_buf_t *db, sa_buf_type_t buftype, int full_space, int *index,\n    int *total, boolean_t *will_spill)\n{\n\tint var_size_count = 0;\n\tint i;\n\tint hdrsize;\n\tint extra_hdrsize;\n\n\tif (buftype == SA_BONUS && sa->sa_force_spill) {\n\t\t*total = 0;\n\t\t*index = 0;\n\t\t*will_spill = B_TRUE;\n\t\treturn (0);\n\t}\n\n\t*index = -1;\n\t*total = 0;\n\t*will_spill = B_FALSE;\n\n\textra_hdrsize = 0;\n\thdrsize = (SA_BONUSTYPE_FROM_DB(db) == DMU_OT_ZNODE) ? 0 :\n\t    sizeof (sa_hdr_phys_t);\n\n\tASSERT(IS_P2ALIGNED(full_space, 8));\n\n\tfor (i = 0; i != attr_count; i++) {\n\t\tboolean_t is_var_sz, might_spill_here;\n\t\tint tmp_hdrsize;\n\n\t\t*total = P2ROUNDUP(*total, 8);\n\t\t*total += attr_desc[i].sa_length;\n\t\tif (*will_spill)\n\t\t\tcontinue;\n\n\t\tis_var_sz = (SA_REGISTERED_LEN(sa, attr_desc[i].sa_attr) == 0);\n\t\tif (is_var_sz)\n\t\t\tvar_size_count++;\n\n\t\t \n\t\ttmp_hdrsize = hdrsize + ((is_var_sz && var_size_count > 1) ?\n\t\t    sizeof (uint16_t) : 0);\n\n\t\t \n\t\tmight_spill_here =\n\t\t    buftype == SA_BONUS && *index == -1 &&\n\t\t    (*total + P2ROUNDUP(tmp_hdrsize, 8)) >\n\t\t    (full_space - sizeof (blkptr_t));\n\n\t\tif (is_var_sz && var_size_count > 1) {\n\t\t\tif (buftype == SA_SPILL ||\n\t\t\t    tmp_hdrsize + *total < full_space) {\n\t\t\t\t \n\t\t\t\thdrsize = tmp_hdrsize;\n\t\t\t\tif (*index != -1 || might_spill_here)\n\t\t\t\t\textra_hdrsize += sizeof (uint16_t);\n\t\t\t} else {\n\t\t\t\tASSERT(buftype == SA_BONUS);\n\t\t\t\tif (*index == -1)\n\t\t\t\t\t*index = i;\n\t\t\t\t*will_spill = B_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (might_spill_here)\n\t\t\t*index = i;\n\n\t\tif ((*total + P2ROUNDUP(hdrsize, 8)) > full_space &&\n\t\t    buftype == SA_BONUS)\n\t\t\t*will_spill = B_TRUE;\n\t}\n\n\tif (*will_spill)\n\t\thdrsize -= extra_hdrsize;\n\n\thdrsize = P2ROUNDUP(hdrsize, 8);\n\treturn (hdrsize);\n}\n\n#define\tBUF_SPACE_NEEDED(total, header) (total + header)\n\n \nstatic int\nsa_build_layouts(sa_handle_t *hdl, sa_bulk_attr_t *attr_desc, int attr_count,\n    dmu_tx_t *tx)\n{\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\tuint64_t hash;\n\tsa_buf_type_t buftype;\n\tsa_hdr_phys_t *sahdr;\n\tvoid *data_start;\n\tsa_attr_type_t *attrs, *attrs_start;\n\tint i, lot_count;\n\tint dnodesize;\n\tint spill_idx;\n\tint hdrsize;\n\tint spillhdrsize = 0;\n\tint used;\n\tdmu_object_type_t bonustype;\n\tsa_lot_t *lot;\n\tint len_idx;\n\tint spill_used;\n\tint bonuslen;\n\tboolean_t spilling;\n\n\tdmu_buf_will_dirty(hdl->sa_bonus, tx);\n\tbonustype = SA_BONUSTYPE_FROM_DB(hdl->sa_bonus);\n\tdmu_object_dnsize_from_db(hdl->sa_bonus, &dnodesize);\n\tbonuslen = DN_BONUS_SIZE(dnodesize);\n\n\t \n\thdrsize = sa_find_sizes(sa, attr_desc, attr_count, hdl->sa_bonus,\n\t    SA_BONUS, bonuslen, &spill_idx, &used, &spilling);\n\n\tif (used > SPA_OLD_MAXBLOCKSIZE)\n\t\treturn (SET_ERROR(EFBIG));\n\n\tVERIFY0(dmu_set_bonus(hdl->sa_bonus, spilling ?\n\t    MIN(bonuslen - sizeof (blkptr_t), used + hdrsize) :\n\t    used + hdrsize, tx));\n\n\tASSERT((bonustype == DMU_OT_ZNODE && spilling == 0) ||\n\t    bonustype == DMU_OT_SA);\n\n\t \n\tif (spilling) {\n\t\tboolean_t dummy;\n\n\t\tif (hdl->sa_spill == NULL) {\n\t\t\tVERIFY(dmu_spill_hold_by_bonus(hdl->sa_bonus, 0, NULL,\n\t\t\t    &hdl->sa_spill) == 0);\n\t\t}\n\t\tdmu_buf_will_dirty(hdl->sa_spill, tx);\n\n\t\tspillhdrsize = sa_find_sizes(sa, &attr_desc[spill_idx],\n\t\t    attr_count - spill_idx, hdl->sa_spill, SA_SPILL,\n\t\t    hdl->sa_spill->db_size, &i, &spill_used, &dummy);\n\n\t\tif (spill_used > SPA_OLD_MAXBLOCKSIZE)\n\t\t\treturn (SET_ERROR(EFBIG));\n\n\t\tif (BUF_SPACE_NEEDED(spill_used, spillhdrsize) >\n\t\t    hdl->sa_spill->db_size)\n\t\t\tVERIFY(0 == sa_resize_spill(hdl,\n\t\t\t    BUF_SPACE_NEEDED(spill_used, spillhdrsize), tx));\n\t}\n\n\t \n\tdata_start = (void *)((uintptr_t)hdl->sa_bonus->db_data + hdrsize);\n\tsahdr = (sa_hdr_phys_t *)hdl->sa_bonus->db_data;\n\tbuftype = SA_BONUS;\n\n\tattrs_start = attrs = kmem_alloc(sizeof (sa_attr_type_t) * attr_count,\n\t    KM_SLEEP);\n\tlot_count = 0;\n\n\tfor (i = 0, len_idx = 0, hash = -1ULL; i != attr_count; i++) {\n\t\tuint16_t length;\n\n\t\tASSERT(IS_P2ALIGNED(data_start, 8));\n\t\tattrs[i] = attr_desc[i].sa_attr;\n\t\tlength = SA_REGISTERED_LEN(sa, attrs[i]);\n\t\tif (length == 0)\n\t\t\tlength = attr_desc[i].sa_length;\n\n\t\tif (spilling && i == spill_idx) {  \n\t\t\tVERIFY(bonustype == DMU_OT_SA);\n\t\t\tif (buftype == SA_BONUS && !sa->sa_force_spill) {\n\t\t\t\tsa_find_layout(hdl->sa_os, hash, attrs_start,\n\t\t\t\t    lot_count, tx, &lot);\n\t\t\t\tSA_SET_HDR(sahdr, lot->lot_num, hdrsize);\n\t\t\t}\n\n\t\t\tbuftype = SA_SPILL;\n\t\t\thash = -1ULL;\n\t\t\tlen_idx = 0;\n\n\t\t\tsahdr = (sa_hdr_phys_t *)hdl->sa_spill->db_data;\n\t\t\tsahdr->sa_magic = SA_MAGIC;\n\t\t\tdata_start = (void *)((uintptr_t)sahdr +\n\t\t\t    spillhdrsize);\n\t\t\tattrs_start = &attrs[i];\n\t\t\tlot_count = 0;\n\t\t}\n\t\thash ^= SA_ATTR_HASH(attrs[i]);\n\t\tattr_desc[i].sa_addr = data_start;\n\t\tattr_desc[i].sa_size = length;\n\t\tSA_COPY_DATA(attr_desc[i].sa_data_func, attr_desc[i].sa_data,\n\t\t    data_start, length);\n\t\tif (sa->sa_attr_table[attrs[i]].sa_length == 0) {\n\t\t\tsahdr->sa_lengths[len_idx++] = length;\n\t\t}\n\t\tdata_start = (void *)P2ROUNDUP(((uintptr_t)data_start +\n\t\t    length), 8);\n\t\tlot_count++;\n\t}\n\n\tsa_find_layout(hdl->sa_os, hash, attrs_start, lot_count, tx, &lot);\n\n\t \n\tVERIFY((bonustype == DMU_OT_ZNODE && lot->lot_num == 0) ||\n\t    (bonustype == DMU_OT_SA && lot->lot_num > 1));\n\n\tif (bonustype == DMU_OT_SA) {\n\t\tSA_SET_HDR(sahdr, lot->lot_num,\n\t\t    buftype == SA_BONUS ? hdrsize : spillhdrsize);\n\t}\n\n\tkmem_free(attrs, sizeof (sa_attr_type_t) * attr_count);\n\tif (hdl->sa_bonus_tab) {\n\t\tsa_idx_tab_rele(hdl->sa_os, hdl->sa_bonus_tab);\n\t\thdl->sa_bonus_tab = NULL;\n\t}\n\tif (!sa->sa_force_spill)\n\t\tVERIFY(0 == sa_build_index(hdl, SA_BONUS));\n\tif (hdl->sa_spill) {\n\t\tsa_idx_tab_rele(hdl->sa_os, hdl->sa_spill_tab);\n\t\tif (!spilling) {\n\t\t\t \n\t\t\tdmu_buf_rele(hdl->sa_spill, NULL);\n\t\t\thdl->sa_spill = NULL;\n\t\t\thdl->sa_spill_tab = NULL;\n\t\t\tVERIFY(0 == dmu_rm_spill(hdl->sa_os,\n\t\t\t    sa_handle_object(hdl), tx));\n\t\t} else {\n\t\t\tVERIFY(0 == sa_build_index(hdl, SA_SPILL));\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic void\nsa_free_attr_table(sa_os_t *sa)\n{\n\tint i;\n\n\tif (sa->sa_attr_table == NULL)\n\t\treturn;\n\n\tfor (i = 0; i != sa->sa_num_attrs; i++) {\n\t\tif (sa->sa_attr_table[i].sa_name)\n\t\t\tkmem_free(sa->sa_attr_table[i].sa_name,\n\t\t\t    strlen(sa->sa_attr_table[i].sa_name) + 1);\n\t}\n\n\tkmem_free(sa->sa_attr_table,\n\t    sizeof (sa_attr_table_t) * sa->sa_num_attrs);\n\n\tsa->sa_attr_table = NULL;\n}\n\nstatic int\nsa_attr_table_setup(objset_t *os, const sa_attr_reg_t *reg_attrs, int count)\n{\n\tsa_os_t *sa = os->os_sa;\n\tuint64_t sa_attr_count = 0;\n\tuint64_t sa_reg_count = 0;\n\tint error = 0;\n\tuint64_t attr_value;\n\tsa_attr_table_t *tb;\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tint registered_count = 0;\n\tint i;\n\tdmu_objset_type_t ostype = dmu_objset_type(os);\n\n\tsa->sa_user_table =\n\t    kmem_zalloc(count * sizeof (sa_attr_type_t), KM_SLEEP);\n\tsa->sa_user_table_sz = count * sizeof (sa_attr_type_t);\n\n\tif (sa->sa_reg_attr_obj != 0) {\n\t\terror = zap_count(os, sa->sa_reg_attr_obj,\n\t\t    &sa_attr_count);\n\n\t\t \n\t\tif (error || (error == 0 && sa_attr_count == 0)) {\n\t\t\tif (error == 0)\n\t\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tgoto bail;\n\t\t}\n\t\tsa_reg_count = sa_attr_count;\n\t}\n\n\tif (ostype == DMU_OST_ZFS && sa_attr_count == 0)\n\t\tsa_attr_count += sa_legacy_attr_count;\n\n\t \n\tfor (i = 0; i != count; i++) {\n\t\tboolean_t found = B_FALSE;\n\t\tint j;\n\n\t\tif (ostype == DMU_OST_ZFS) {\n\t\t\tfor (j = 0; j != sa_legacy_attr_count; j++) {\n\t\t\t\tif (strcmp(reg_attrs[i].sa_name,\n\t\t\t\t    sa_legacy_attrs[j].sa_name) == 0) {\n\t\t\t\t\tsa->sa_user_table[i] =\n\t\t\t\t\t    sa_legacy_attrs[j].sa_attr;\n\t\t\t\t\tfound = B_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tif (sa->sa_reg_attr_obj)\n\t\t\terror = zap_lookup(os, sa->sa_reg_attr_obj,\n\t\t\t    reg_attrs[i].sa_name, 8, 1, &attr_value);\n\t\telse\n\t\t\terror = SET_ERROR(ENOENT);\n\t\tswitch (error) {\n\t\tcase ENOENT:\n\t\t\tsa->sa_user_table[i] = (sa_attr_type_t)sa_attr_count;\n\t\t\tsa_attr_count++;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tsa->sa_user_table[i] = ATTR_NUM(attr_value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tsa->sa_num_attrs = sa_attr_count;\n\ttb = sa->sa_attr_table =\n\t    kmem_zalloc(sizeof (sa_attr_table_t) * sa_attr_count, KM_SLEEP);\n\n\t \n\n\tif (sa->sa_reg_attr_obj) {\n\t\tfor (zap_cursor_init(&zc, os, sa->sa_reg_attr_obj);\n\t\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t\t    zap_cursor_advance(&zc)) {\n\t\t\tuint64_t value;\n\t\t\tvalue  = za.za_first_integer;\n\n\t\t\tregistered_count++;\n\t\t\ttb[ATTR_NUM(value)].sa_attr = ATTR_NUM(value);\n\t\t\ttb[ATTR_NUM(value)].sa_length = ATTR_LENGTH(value);\n\t\t\ttb[ATTR_NUM(value)].sa_byteswap = ATTR_BSWAP(value);\n\t\t\ttb[ATTR_NUM(value)].sa_registered = B_TRUE;\n\n\t\t\tif (tb[ATTR_NUM(value)].sa_name) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttb[ATTR_NUM(value)].sa_name =\n\t\t\t    kmem_zalloc(strlen(za.za_name) +1, KM_SLEEP);\n\t\t\t(void) strlcpy(tb[ATTR_NUM(value)].sa_name, za.za_name,\n\t\t\t    strlen(za.za_name) +1);\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\t\t \n\t\tif (registered_count != sa_reg_count) {\n\t\t\tASSERT(error != 0);\n\t\t\tgoto bail;\n\t\t}\n\n\t}\n\n\tif (ostype == DMU_OST_ZFS) {\n\t\tfor (i = 0; i != sa_legacy_attr_count; i++) {\n\t\t\tif (tb[i].sa_name)\n\t\t\t\tcontinue;\n\t\t\ttb[i].sa_attr = sa_legacy_attrs[i].sa_attr;\n\t\t\ttb[i].sa_length = sa_legacy_attrs[i].sa_length;\n\t\t\ttb[i].sa_byteswap = sa_legacy_attrs[i].sa_byteswap;\n\t\t\ttb[i].sa_registered = B_FALSE;\n\t\t\ttb[i].sa_name =\n\t\t\t    kmem_zalloc(strlen(sa_legacy_attrs[i].sa_name) +1,\n\t\t\t    KM_SLEEP);\n\t\t\t(void) strlcpy(tb[i].sa_name,\n\t\t\t    sa_legacy_attrs[i].sa_name,\n\t\t\t    strlen(sa_legacy_attrs[i].sa_name) + 1);\n\t\t}\n\t}\n\n\tfor (i = 0; i != count; i++) {\n\t\tsa_attr_type_t attr_id;\n\n\t\tattr_id = sa->sa_user_table[i];\n\t\tif (tb[attr_id].sa_name)\n\t\t\tcontinue;\n\n\t\ttb[attr_id].sa_length = reg_attrs[i].sa_length;\n\t\ttb[attr_id].sa_byteswap = reg_attrs[i].sa_byteswap;\n\t\ttb[attr_id].sa_attr = attr_id;\n\t\ttb[attr_id].sa_name =\n\t\t    kmem_zalloc(strlen(reg_attrs[i].sa_name) + 1, KM_SLEEP);\n\t\t(void) strlcpy(tb[attr_id].sa_name, reg_attrs[i].sa_name,\n\t\t    strlen(reg_attrs[i].sa_name) + 1);\n\t}\n\n\tsa->sa_need_attr_registration =\n\t    (sa_attr_count != registered_count);\n\n\treturn (0);\nbail:\n\tkmem_free(sa->sa_user_table, count * sizeof (sa_attr_type_t));\n\tsa->sa_user_table = NULL;\n\tsa_free_attr_table(sa);\n\tASSERT(error != 0);\n\treturn (error);\n}\n\nint\nsa_setup(objset_t *os, uint64_t sa_obj, const sa_attr_reg_t *reg_attrs,\n    int count, sa_attr_type_t **user_table)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tsa_os_t *sa;\n\tdmu_objset_type_t ostype = dmu_objset_type(os);\n\tsa_attr_type_t *tb;\n\tint error;\n\n\tmutex_enter(&os->os_user_ptr_lock);\n\tif (os->os_sa) {\n\t\tmutex_enter(&os->os_sa->sa_lock);\n\t\tmutex_exit(&os->os_user_ptr_lock);\n\t\ttb = os->os_sa->sa_user_table;\n\t\tmutex_exit(&os->os_sa->sa_lock);\n\t\t*user_table = tb;\n\t\treturn (0);\n\t}\n\n\tsa = kmem_zalloc(sizeof (sa_os_t), KM_SLEEP);\n\tmutex_init(&sa->sa_lock, NULL, MUTEX_NOLOCKDEP, NULL);\n\tsa->sa_master_obj = sa_obj;\n\n\tos->os_sa = sa;\n\tmutex_enter(&sa->sa_lock);\n\tmutex_exit(&os->os_user_ptr_lock);\n\tavl_create(&sa->sa_layout_num_tree, layout_num_compare,\n\t    sizeof (sa_lot_t), offsetof(sa_lot_t, lot_num_node));\n\tavl_create(&sa->sa_layout_hash_tree, layout_hash_compare,\n\t    sizeof (sa_lot_t), offsetof(sa_lot_t, lot_hash_node));\n\n\tif (sa_obj) {\n\t\terror = zap_lookup(os, sa_obj, SA_LAYOUTS,\n\t\t    8, 1, &sa->sa_layout_attr_obj);\n\t\tif (error != 0 && error != ENOENT)\n\t\t\tgoto fail;\n\t\terror = zap_lookup(os, sa_obj, SA_REGISTRY,\n\t\t    8, 1, &sa->sa_reg_attr_obj);\n\t\tif (error != 0 && error != ENOENT)\n\t\t\tgoto fail;\n\t}\n\n\tif ((error = sa_attr_table_setup(os, reg_attrs, count)) != 0)\n\t\tgoto fail;\n\n\tif (sa->sa_layout_attr_obj != 0) {\n\t\tuint64_t layout_count;\n\n\t\terror = zap_count(os, sa->sa_layout_attr_obj,\n\t\t    &layout_count);\n\n\t\t \n\t\tif (error || (error == 0 && layout_count == 0)) {\n\t\t\tif (error == 0)\n\t\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (zap_cursor_init(&zc, os, sa->sa_layout_attr_obj);\n\t\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t\t    zap_cursor_advance(&zc)) {\n\t\t\tsa_attr_type_t *lot_attrs;\n\t\t\tuint64_t lot_num;\n\n\t\t\tlot_attrs = kmem_zalloc(sizeof (sa_attr_type_t) *\n\t\t\t    za.za_num_integers, KM_SLEEP);\n\n\t\t\tif ((error = (zap_lookup(os, sa->sa_layout_attr_obj,\n\t\t\t    za.za_name, 2, za.za_num_integers,\n\t\t\t    lot_attrs))) != 0) {\n\t\t\t\tkmem_free(lot_attrs, sizeof (sa_attr_type_t) *\n\t\t\t\t    za.za_num_integers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVERIFY0(ddi_strtoull(za.za_name, NULL, 10,\n\t\t\t    (unsigned long long *)&lot_num));\n\n\t\t\t(void) sa_add_layout_entry(os, lot_attrs,\n\t\t\t    za.za_num_integers, lot_num,\n\t\t\t    sa_layout_info_hash(lot_attrs,\n\t\t\t    za.za_num_integers), B_FALSE, NULL);\n\t\t\tkmem_free(lot_attrs, sizeof (sa_attr_type_t) *\n\t\t\t    za.za_num_integers);\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\n\t\t \n\t\tif (avl_numnodes(&sa->sa_layout_num_tree) != layout_count) {\n\t\t\tASSERT(error != 0);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (ostype == DMU_OST_ZFS) {\n\t\t(void) sa_add_layout_entry(os, sa_legacy_zpl_layout,\n\t\t    sa_legacy_attr_count, 0,\n\t\t    sa_layout_info_hash(sa_legacy_zpl_layout,\n\t\t    sa_legacy_attr_count), B_FALSE, NULL);\n\n\t\t(void) sa_add_layout_entry(os, sa_dummy_zpl_layout, 0, 1,\n\t\t    0, B_FALSE, NULL);\n\t}\n\t*user_table = os->os_sa->sa_user_table;\n\tmutex_exit(&sa->sa_lock);\n\treturn (0);\nfail:\n\tos->os_sa = NULL;\n\tsa_free_attr_table(sa);\n\tif (sa->sa_user_table)\n\t\tkmem_free(sa->sa_user_table, sa->sa_user_table_sz);\n\tmutex_exit(&sa->sa_lock);\n\tavl_destroy(&sa->sa_layout_hash_tree);\n\tavl_destroy(&sa->sa_layout_num_tree);\n\tmutex_destroy(&sa->sa_lock);\n\tkmem_free(sa, sizeof (sa_os_t));\n\treturn ((error == ECKSUM) ? EIO : error);\n}\n\nvoid\nsa_tear_down(objset_t *os)\n{\n\tsa_os_t *sa = os->os_sa;\n\tsa_lot_t *layout;\n\tvoid *cookie;\n\n\tkmem_free(sa->sa_user_table, sa->sa_user_table_sz);\n\n\t \n\n\tsa_free_attr_table(sa);\n\n\tcookie = NULL;\n\twhile ((layout =\n\t    avl_destroy_nodes(&sa->sa_layout_hash_tree, &cookie))) {\n\t\tsa_idx_tab_t *tab;\n\t\twhile ((tab = list_head(&layout->lot_idx_tab))) {\n\t\t\tASSERT(zfs_refcount_count(&tab->sa_refcount));\n\t\t\tsa_idx_tab_rele(os, tab);\n\t\t}\n\t}\n\n\tcookie = NULL;\n\twhile ((layout = avl_destroy_nodes(&sa->sa_layout_num_tree, &cookie))) {\n\t\tkmem_free(layout->lot_attrs,\n\t\t    sizeof (sa_attr_type_t) * layout->lot_attr_count);\n\t\tkmem_free(layout, sizeof (sa_lot_t));\n\t}\n\n\tavl_destroy(&sa->sa_layout_hash_tree);\n\tavl_destroy(&sa->sa_layout_num_tree);\n\tmutex_destroy(&sa->sa_lock);\n\n\tkmem_free(sa, sizeof (sa_os_t));\n\tos->os_sa = NULL;\n}\n\nstatic void\nsa_build_idx_tab(void *hdr, void *attr_addr, sa_attr_type_t attr,\n    uint16_t length, int length_idx, boolean_t var_length, void *userp)\n{\n\tsa_idx_tab_t *idx_tab = userp;\n\n\tif (var_length) {\n\t\tASSERT(idx_tab->sa_variable_lengths);\n\t\tidx_tab->sa_variable_lengths[length_idx] = length;\n\t}\n\tTOC_ATTR_ENCODE(idx_tab->sa_idx_tab[attr], length_idx,\n\t    (uint32_t)((uintptr_t)attr_addr - (uintptr_t)hdr));\n}\n\nstatic void\nsa_attr_iter(objset_t *os, sa_hdr_phys_t *hdr, dmu_object_type_t type,\n    sa_iterfunc_t func, sa_lot_t *tab, void *userp)\n{\n\tvoid *data_start;\n\tsa_lot_t *tb = tab;\n\tsa_lot_t search;\n\tavl_index_t loc;\n\tsa_os_t *sa = os->os_sa;\n\tint i;\n\tuint16_t *length_start = NULL;\n\tuint8_t length_idx = 0;\n\n\tif (tab == NULL) {\n\t\tsearch.lot_num = SA_LAYOUT_NUM(hdr, type);\n\t\ttb = avl_find(&sa->sa_layout_num_tree, &search, &loc);\n\t\tASSERT(tb);\n\t}\n\n\tif (IS_SA_BONUSTYPE(type)) {\n\t\tdata_start = (void *)P2ROUNDUP(((uintptr_t)hdr +\n\t\t    offsetof(sa_hdr_phys_t, sa_lengths) +\n\t\t    (sizeof (uint16_t) * tb->lot_var_sizes)), 8);\n\t\tlength_start = hdr->sa_lengths;\n\t} else {\n\t\tdata_start = hdr;\n\t}\n\n\tfor (i = 0; i != tb->lot_attr_count; i++) {\n\t\tint attr_length, reg_length;\n\t\tuint8_t idx_len;\n\n\t\treg_length = sa->sa_attr_table[tb->lot_attrs[i]].sa_length;\n\t\tIMPLY(reg_length == 0, IS_SA_BONUSTYPE(type));\n\t\tif (reg_length) {\n\t\t\tattr_length = reg_length;\n\t\t\tidx_len = 0;\n\t\t} else {\n\t\t\tattr_length = length_start[length_idx];\n\t\t\tidx_len = length_idx++;\n\t\t}\n\n\t\tfunc(hdr, data_start, tb->lot_attrs[i], attr_length,\n\t\t    idx_len, reg_length == 0 ? B_TRUE : B_FALSE, userp);\n\n\t\tdata_start = (void *)P2ROUNDUP(((uintptr_t)data_start +\n\t\t    attr_length), 8);\n\t}\n}\n\nstatic void\nsa_byteswap_cb(void *hdr, void *attr_addr, sa_attr_type_t attr,\n    uint16_t length, int length_idx, boolean_t variable_length, void *userp)\n{\n\t(void) hdr, (void) length_idx, (void) variable_length;\n\tsa_handle_t *hdl = userp;\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\n\tsa_bswap_table[sa->sa_attr_table[attr].sa_byteswap](attr_addr, length);\n}\n\nstatic void\nsa_byteswap(sa_handle_t *hdl, sa_buf_type_t buftype)\n{\n\tsa_hdr_phys_t *sa_hdr_phys = SA_GET_HDR(hdl, buftype);\n\tdmu_buf_impl_t *db;\n\tint num_lengths = 1;\n\tint i;\n\tsa_os_t *sa __maybe_unused = hdl->sa_os->os_sa;\n\n\tASSERT(MUTEX_HELD(&sa->sa_lock));\n\tif (sa_hdr_phys->sa_magic == SA_MAGIC)\n\t\treturn;\n\n\tdb = SA_GET_DB(hdl, buftype);\n\n\tif (buftype == SA_SPILL) {\n\t\tarc_release(db->db_buf, NULL);\n\t\tarc_buf_thaw(db->db_buf);\n\t}\n\n\tsa_hdr_phys->sa_magic = BSWAP_32(sa_hdr_phys->sa_magic);\n\tsa_hdr_phys->sa_layout_info = BSWAP_16(sa_hdr_phys->sa_layout_info);\n\n\t \n\tif (SA_HDR_SIZE(sa_hdr_phys) > 8)\n\t\tnum_lengths += (SA_HDR_SIZE(sa_hdr_phys) - 8) >> 1;\n\tfor (i = 0; i != num_lengths; i++)\n\t\tsa_hdr_phys->sa_lengths[i] =\n\t\t    BSWAP_16(sa_hdr_phys->sa_lengths[i]);\n\n\tsa_attr_iter(hdl->sa_os, sa_hdr_phys, DMU_OT_SA,\n\t    sa_byteswap_cb, NULL, hdl);\n\n\tif (buftype == SA_SPILL)\n\t\tarc_buf_freeze(((dmu_buf_impl_t *)hdl->sa_spill)->db_buf);\n}\n\nstatic int\nsa_build_index(sa_handle_t *hdl, sa_buf_type_t buftype)\n{\n\tsa_hdr_phys_t *sa_hdr_phys;\n\tdmu_buf_impl_t *db = SA_GET_DB(hdl, buftype);\n\tdmu_object_type_t bonustype = SA_BONUSTYPE_FROM_DB(db);\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\tsa_idx_tab_t *idx_tab;\n\n\tsa_hdr_phys = SA_GET_HDR(hdl, buftype);\n\n\tmutex_enter(&sa->sa_lock);\n\n\t \n\n\t \n\tif (IS_SA_BONUSTYPE(bonustype) && sa_hdr_phys->sa_magic != SA_MAGIC &&\n\t    sa_hdr_phys->sa_magic != 0) {\n\t\tif (BSWAP_32(sa_hdr_phys->sa_magic) != SA_MAGIC) {\n\t\t\tmutex_exit(&sa->sa_lock);\n\t\t\tzfs_dbgmsg(\"Buffer Header: %x != SA_MAGIC:%x \"\n\t\t\t    \"object=%#llx\\n\", sa_hdr_phys->sa_magic, SA_MAGIC,\n\t\t\t    (u_longlong_t)db->db.db_object);\n\t\t\treturn (SET_ERROR(EIO));\n\t\t}\n\t\tsa_byteswap(hdl, buftype);\n\t}\n\n\tidx_tab = sa_find_idx_tab(hdl->sa_os, bonustype, sa_hdr_phys);\n\n\tif (buftype == SA_BONUS)\n\t\thdl->sa_bonus_tab = idx_tab;\n\telse\n\t\thdl->sa_spill_tab = idx_tab;\n\n\tmutex_exit(&sa->sa_lock);\n\treturn (0);\n}\n\nstatic void\nsa_evict_sync(void *dbu)\n{\n\t(void) dbu;\n\tpanic(\"evicting sa dbuf\\n\");\n}\n\nstatic void\nsa_idx_tab_rele(objset_t *os, void *arg)\n{\n\tsa_os_t *sa = os->os_sa;\n\tsa_idx_tab_t *idx_tab = arg;\n\n\tif (idx_tab == NULL)\n\t\treturn;\n\n\tmutex_enter(&sa->sa_lock);\n\tif (zfs_refcount_remove(&idx_tab->sa_refcount, NULL) == 0) {\n\t\tlist_remove(&idx_tab->sa_layout->lot_idx_tab, idx_tab);\n\t\tif (idx_tab->sa_variable_lengths)\n\t\t\tkmem_free(idx_tab->sa_variable_lengths,\n\t\t\t    sizeof (uint16_t) *\n\t\t\t    idx_tab->sa_layout->lot_var_sizes);\n\t\tzfs_refcount_destroy(&idx_tab->sa_refcount);\n\t\tkmem_free(idx_tab->sa_idx_tab,\n\t\t    sizeof (uint32_t) * sa->sa_num_attrs);\n\t\tkmem_free(idx_tab, sizeof (sa_idx_tab_t));\n\t}\n\tmutex_exit(&sa->sa_lock);\n}\n\nstatic void\nsa_idx_tab_hold(objset_t *os, sa_idx_tab_t *idx_tab)\n{\n\tsa_os_t *sa __maybe_unused = os->os_sa;\n\n\tASSERT(MUTEX_HELD(&sa->sa_lock));\n\t(void) zfs_refcount_add(&idx_tab->sa_refcount, NULL);\n}\n\nvoid\nsa_spill_rele(sa_handle_t *hdl)\n{\n\tmutex_enter(&hdl->sa_lock);\n\tif (hdl->sa_spill) {\n\t\tsa_idx_tab_rele(hdl->sa_os, hdl->sa_spill_tab);\n\t\tdmu_buf_rele(hdl->sa_spill, NULL);\n\t\thdl->sa_spill = NULL;\n\t\thdl->sa_spill_tab = NULL;\n\t}\n\tmutex_exit(&hdl->sa_lock);\n}\n\nvoid\nsa_handle_destroy(sa_handle_t *hdl)\n{\n\tdmu_buf_t *db = hdl->sa_bonus;\n\n\tmutex_enter(&hdl->sa_lock);\n\t(void) dmu_buf_remove_user(db, &hdl->sa_dbu);\n\n\tif (hdl->sa_bonus_tab)\n\t\tsa_idx_tab_rele(hdl->sa_os, hdl->sa_bonus_tab);\n\n\tif (hdl->sa_spill_tab)\n\t\tsa_idx_tab_rele(hdl->sa_os, hdl->sa_spill_tab);\n\n\tdmu_buf_rele(hdl->sa_bonus, NULL);\n\n\tif (hdl->sa_spill)\n\t\tdmu_buf_rele(hdl->sa_spill, NULL);\n\tmutex_exit(&hdl->sa_lock);\n\n\tkmem_cache_free(sa_cache, hdl);\n}\n\nint\nsa_handle_get_from_db(objset_t *os, dmu_buf_t *db, void *userp,\n    sa_handle_type_t hdl_type, sa_handle_t **handlepp)\n{\n\tint error = 0;\n\tsa_handle_t *handle = NULL;\n#ifdef ZFS_DEBUG\n\tdmu_object_info_t doi;\n\n\tdmu_object_info_from_db(db, &doi);\n\tASSERT(doi.doi_bonus_type == DMU_OT_SA ||\n\t    doi.doi_bonus_type == DMU_OT_ZNODE);\n#endif\n\t \n\t \n\n\tif (hdl_type == SA_HDL_SHARED)\n\t\thandle = dmu_buf_get_user(db);\n\n\tif (handle == NULL) {\n\t\tsa_handle_t *winner = NULL;\n\n\t\thandle = kmem_cache_alloc(sa_cache, KM_SLEEP);\n\t\thandle->sa_dbu.dbu_evict_func_sync = NULL;\n\t\thandle->sa_dbu.dbu_evict_func_async = NULL;\n\t\thandle->sa_userp = userp;\n\t\thandle->sa_bonus = db;\n\t\thandle->sa_os = os;\n\t\thandle->sa_spill = NULL;\n\t\thandle->sa_bonus_tab = NULL;\n\t\thandle->sa_spill_tab = NULL;\n\n\t\terror = sa_build_index(handle, SA_BONUS);\n\n\t\tif (hdl_type == SA_HDL_SHARED) {\n\t\t\tdmu_buf_init_user(&handle->sa_dbu, sa_evict_sync, NULL,\n\t\t\t    NULL);\n\t\t\twinner = dmu_buf_set_user_ie(db, &handle->sa_dbu);\n\t\t}\n\n\t\tif (winner != NULL) {\n\t\t\tkmem_cache_free(sa_cache, handle);\n\t\t\thandle = winner;\n\t\t}\n\t}\n\t*handlepp = handle;\n\n\treturn (error);\n}\n\nint\nsa_handle_get(objset_t *objset, uint64_t objid, void *userp,\n    sa_handle_type_t hdl_type, sa_handle_t **handlepp)\n{\n\tdmu_buf_t *db;\n\tint error;\n\n\tif ((error = dmu_bonus_hold(objset, objid, NULL, &db)))\n\t\treturn (error);\n\n\treturn (sa_handle_get_from_db(objset, db, userp, hdl_type,\n\t    handlepp));\n}\n\nint\nsa_buf_hold(objset_t *objset, uint64_t obj_num, const void *tag, dmu_buf_t **db)\n{\n\treturn (dmu_bonus_hold(objset, obj_num, tag, db));\n}\n\nvoid\nsa_buf_rele(dmu_buf_t *db, const void *tag)\n{\n\tdmu_buf_rele(db, tag);\n}\n\nstatic int\nsa_lookup_impl(sa_handle_t *hdl, sa_bulk_attr_t *bulk, int count)\n{\n\tASSERT(hdl);\n\tASSERT(MUTEX_HELD(&hdl->sa_lock));\n\treturn (sa_attr_op(hdl, bulk, count, SA_LOOKUP, NULL));\n}\n\nstatic int\nsa_lookup_locked(sa_handle_t *hdl, sa_attr_type_t attr, void *buf,\n    uint32_t buflen)\n{\n\tint error;\n\tsa_bulk_attr_t bulk;\n\n\tVERIFY3U(buflen, <=, SA_ATTR_MAX_LEN);\n\n\tbulk.sa_attr = attr;\n\tbulk.sa_data = buf;\n\tbulk.sa_length = buflen;\n\tbulk.sa_data_func = NULL;\n\n\tASSERT(hdl);\n\terror = sa_lookup_impl(hdl, &bulk, 1);\n\treturn (error);\n}\n\nint\nsa_lookup(sa_handle_t *hdl, sa_attr_type_t attr, void *buf, uint32_t buflen)\n{\n\tint error;\n\n\tmutex_enter(&hdl->sa_lock);\n\terror = sa_lookup_locked(hdl, attr, buf, buflen);\n\tmutex_exit(&hdl->sa_lock);\n\n\treturn (error);\n}\n\n#ifdef _KERNEL\nint\nsa_lookup_uio(sa_handle_t *hdl, sa_attr_type_t attr, zfs_uio_t *uio)\n{\n\tint error;\n\tsa_bulk_attr_t bulk;\n\n\tbulk.sa_data = NULL;\n\tbulk.sa_attr = attr;\n\tbulk.sa_data_func = NULL;\n\n\tASSERT(hdl);\n\n\tmutex_enter(&hdl->sa_lock);\n\tif ((error = sa_attr_op(hdl, &bulk, 1, SA_LOOKUP, NULL)) == 0) {\n\t\terror = zfs_uiomove((void *)bulk.sa_addr, MIN(bulk.sa_size,\n\t\t    zfs_uio_resid(uio)), UIO_READ, uio);\n\t}\n\tmutex_exit(&hdl->sa_lock);\n\treturn (error);\n}\n\n \nint\nsa_add_projid(sa_handle_t *hdl, dmu_tx_t *tx, uint64_t projid)\n{\n\tznode_t *zp = sa_get_userdata(hdl);\n\tdmu_buf_t *db = sa_get_db(hdl);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint count = 0, err = 0;\n\tsa_bulk_attr_t *bulk, *attrs;\n\tzfs_acl_locator_cb_t locate = { 0 };\n\tuint64_t uid, gid, mode, rdev, xattr = 0, parent, gen, links;\n\tuint64_t crtime[2], mtime[2], ctime[2], atime[2];\n\tzfs_acl_phys_t znode_acl = { 0 };\n\tchar scanstamp[AV_SCANSTAMP_SZ];\n\n\tif (zp->z_acl_cached == NULL) {\n\t\tzfs_acl_t *aclp;\n\n\t\tmutex_enter(&zp->z_acl_lock);\n\t\terr = zfs_acl_node_read(zp, B_FALSE, &aclp, B_FALSE);\n\t\tmutex_exit(&zp->z_acl_lock);\n\t\tif (err != 0 && err != ENOENT)\n\t\t\treturn (err);\n\t}\n\n\tbulk = kmem_zalloc(sizeof (sa_bulk_attr_t) * ZPL_END, KM_SLEEP);\n\tattrs = kmem_zalloc(sizeof (sa_bulk_attr_t) * ZPL_END, KM_SLEEP);\n\tmutex_enter(&hdl->sa_lock);\n\tmutex_enter(&zp->z_lock);\n\n\terr = sa_lookup_locked(hdl, SA_ZPL_PROJID(zfsvfs), &projid,\n\t    sizeof (uint64_t));\n\tif (unlikely(err == 0))\n\t\t \n\t\terr = EEXIST;\n\tif (err != ENOENT)\n\t\tgoto out;\n\n\t \n\tif (zp->z_is_sa) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t\t    &mode, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GEN(zfsvfs), NULL,\n\t\t    &gen, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t\t    &uid, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL,\n\t\t    &gid, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PARENT(zfsvfs), NULL,\n\t\t    &parent, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t\t    &atime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t\t    &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CRTIME(zfsvfs), NULL,\n\t\t    &crtime, 16);\n\t\tif (Z_ISBLK(ZTOTYPE(zp)) || Z_ISCHR(ZTOTYPE(zp)))\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_RDEV(zfsvfs), NULL,\n\t\t\t    &rdev, 8);\n\t} else {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t\t    &atime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t\t    &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CRTIME(zfsvfs), NULL,\n\t\t    &crtime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GEN(zfsvfs), NULL,\n\t\t    &gen, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t\t    &mode, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PARENT(zfsvfs), NULL,\n\t\t    &parent, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_XATTR(zfsvfs), NULL,\n\t\t    &xattr, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_RDEV(zfsvfs), NULL,\n\t\t    &rdev, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t\t    &uid, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL,\n\t\t    &gid, 8);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ZNODE_ACL(zfsvfs), NULL,\n\t\t    &znode_acl, 88);\n\t}\n\terr = sa_bulk_lookup_locked(hdl, bulk, count);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = sa_lookup_locked(hdl, SA_ZPL_XATTR(zfsvfs), &xattr, 8);\n\tif (err != 0 && err != ENOENT)\n\t\tgoto out;\n\n\tzp->z_projid = projid;\n\tzp->z_pflags |= ZFS_PROJID;\n\tlinks = ZTONLNK(zp);\n\tcount = 0;\n\terr = 0;\n\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_MODE(zfsvfs), NULL, &mode, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_GEN(zfsvfs), NULL, &gen, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_UID(zfsvfs), NULL, &uid, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_GID(zfsvfs), NULL, &gid, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_PARENT(zfsvfs), NULL, &parent, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_ATIME(zfsvfs), NULL, &atime, 16);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_CRTIME(zfsvfs), NULL,\n\t    &crtime, 16);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_LINKS(zfsvfs), NULL, &links, 8);\n\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_PROJID(zfsvfs), NULL, &projid, 8);\n\n\tif (Z_ISBLK(ZTOTYPE(zp)) || Z_ISCHR(ZTOTYPE(zp)))\n\t\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_RDEV(zfsvfs), NULL,\n\t\t    &rdev, 8);\n\n\tif (zp->z_acl_cached != NULL) {\n\t\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_DACL_COUNT(zfsvfs), NULL,\n\t\t    &zp->z_acl_cached->z_acl_count, 8);\n\t\tif (zp->z_acl_cached->z_version < ZFS_ACL_VERSION_FUID)\n\t\t\tzfs_acl_xform(zp, zp->z_acl_cached, CRED());\n\t\tlocate.cb_aclp = zp->z_acl_cached;\n\t\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_DACL_ACES(zfsvfs),\n\t\t    zfs_acl_data_locator, &locate,\n\t\t    zp->z_acl_cached->z_acl_bytes);\n\t}\n\n\tif (xattr)\n\t\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_XATTR(zfsvfs), NULL,\n\t\t    &xattr, 8);\n\n\tif (zp->z_pflags & ZFS_BONUS_SCANSTAMP) {\n\t\tmemcpy(scanstamp,\n\t\t    (caddr_t)db->db_data + ZFS_OLD_ZNODE_PHYS_SIZE,\n\t\t    AV_SCANSTAMP_SZ);\n\t\tSA_ADD_BULK_ATTR(attrs, count, SA_ZPL_SCANSTAMP(zfsvfs), NULL,\n\t\t    scanstamp, AV_SCANSTAMP_SZ);\n\t\tzp->z_pflags &= ~ZFS_BONUS_SCANSTAMP;\n\t}\n\n\tVERIFY(dmu_set_bonustype(db, DMU_OT_SA, tx) == 0);\n\tVERIFY(sa_replace_all_by_template_locked(hdl, attrs, count, tx) == 0);\n\tif (znode_acl.z_acl_extern_obj) {\n\t\tVERIFY(0 == dmu_object_free(zfsvfs->z_os,\n\t\t    znode_acl.z_acl_extern_obj, tx));\n\t}\n\n\tzp->z_is_sa = B_TRUE;\n\nout:\n\tmutex_exit(&zp->z_lock);\n\tmutex_exit(&hdl->sa_lock);\n\tkmem_free(attrs, sizeof (sa_bulk_attr_t) * ZPL_END);\n\tkmem_free(bulk, sizeof (sa_bulk_attr_t) * ZPL_END);\n\treturn (err);\n}\n#endif\n\nstatic sa_idx_tab_t *\nsa_find_idx_tab(objset_t *os, dmu_object_type_t bonustype, sa_hdr_phys_t *hdr)\n{\n\tsa_idx_tab_t *idx_tab;\n\tsa_os_t *sa = os->os_sa;\n\tsa_lot_t *tb, search;\n\tavl_index_t loc;\n\n\t \n\n\tsearch.lot_num = SA_LAYOUT_NUM(hdr, bonustype);\n\n\ttb = avl_find(&sa->sa_layout_num_tree, &search, &loc);\n\n\t \n\tASSERT(tb);\n\tASSERT((IS_SA_BONUSTYPE(bonustype) &&\n\t    SA_HDR_SIZE_MATCH_LAYOUT(hdr, tb)) || !IS_SA_BONUSTYPE(bonustype) ||\n\t    (IS_SA_BONUSTYPE(bonustype) && hdr->sa_layout_info == 0));\n\n\t \n\n\tfor (idx_tab = list_head(&tb->lot_idx_tab); idx_tab;\n\t    idx_tab = list_next(&tb->lot_idx_tab, idx_tab)) {\n\t\tboolean_t valid_idx = B_TRUE;\n\t\tint i;\n\n\t\tif (tb->lot_var_sizes != 0 &&\n\t\t    idx_tab->sa_variable_lengths != NULL) {\n\t\t\tfor (i = 0; i != tb->lot_var_sizes; i++) {\n\t\t\t\tif (hdr->sa_lengths[i] !=\n\t\t\t\t    idx_tab->sa_variable_lengths[i]) {\n\t\t\t\t\tvalid_idx = B_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (valid_idx) {\n\t\t\tsa_idx_tab_hold(os, idx_tab);\n\t\t\treturn (idx_tab);\n\t\t}\n\t}\n\n\t \n\tidx_tab = kmem_zalloc(sizeof (sa_idx_tab_t), KM_SLEEP);\n\tidx_tab->sa_idx_tab =\n\t    kmem_zalloc(sizeof (uint32_t) * sa->sa_num_attrs, KM_SLEEP);\n\tidx_tab->sa_layout = tb;\n\tzfs_refcount_create(&idx_tab->sa_refcount);\n\tif (tb->lot_var_sizes)\n\t\tidx_tab->sa_variable_lengths = kmem_alloc(sizeof (uint16_t) *\n\t\t    tb->lot_var_sizes, KM_SLEEP);\n\n\tsa_attr_iter(os, hdr, bonustype, sa_build_idx_tab,\n\t    tb, idx_tab);\n\tsa_idx_tab_hold(os, idx_tab);    \n\tsa_idx_tab_hold(os, idx_tab);\t \n\tlist_insert_tail(&tb->lot_idx_tab, idx_tab);\n\treturn (idx_tab);\n}\n\nvoid\nsa_default_locator(void **dataptr, uint32_t *len, uint32_t total_len,\n    boolean_t start, void *userdata)\n{\n\tASSERT(start);\n\n\t*dataptr = userdata;\n\t*len = total_len;\n}\n\nstatic void\nsa_attr_register_sync(sa_handle_t *hdl, dmu_tx_t *tx)\n{\n\tuint64_t attr_value = 0;\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\tsa_attr_table_t *tb = sa->sa_attr_table;\n\tint i;\n\n\tmutex_enter(&sa->sa_lock);\n\n\tif (!sa->sa_need_attr_registration || sa->sa_master_obj == 0) {\n\t\tmutex_exit(&sa->sa_lock);\n\t\treturn;\n\t}\n\n\tif (sa->sa_reg_attr_obj == 0) {\n\t\tsa->sa_reg_attr_obj = zap_create_link(hdl->sa_os,\n\t\t    DMU_OT_SA_ATTR_REGISTRATION,\n\t\t    sa->sa_master_obj, SA_REGISTRY, tx);\n\t}\n\tfor (i = 0; i != sa->sa_num_attrs; i++) {\n\t\tif (sa->sa_attr_table[i].sa_registered)\n\t\t\tcontinue;\n\t\tATTR_ENCODE(attr_value, tb[i].sa_attr, tb[i].sa_length,\n\t\t    tb[i].sa_byteswap);\n\t\tVERIFY(0 == zap_update(hdl->sa_os, sa->sa_reg_attr_obj,\n\t\t    tb[i].sa_name, 8, 1, &attr_value, tx));\n\t\ttb[i].sa_registered = B_TRUE;\n\t}\n\tsa->sa_need_attr_registration = B_FALSE;\n\tmutex_exit(&sa->sa_lock);\n}\n\n \nint\nsa_replace_all_by_template_locked(sa_handle_t *hdl, sa_bulk_attr_t *attr_desc,\n    int attr_count, dmu_tx_t *tx)\n{\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\n\tif (sa->sa_need_attr_registration)\n\t\tsa_attr_register_sync(hdl, tx);\n\treturn (sa_build_layouts(hdl, attr_desc, attr_count, tx));\n}\n\nint\nsa_replace_all_by_template(sa_handle_t *hdl, sa_bulk_attr_t *attr_desc,\n    int attr_count, dmu_tx_t *tx)\n{\n\tint error;\n\n\tmutex_enter(&hdl->sa_lock);\n\terror = sa_replace_all_by_template_locked(hdl, attr_desc,\n\t    attr_count, tx);\n\tmutex_exit(&hdl->sa_lock);\n\treturn (error);\n}\n\n \nstatic int\nsa_modify_attrs(sa_handle_t *hdl, sa_attr_type_t newattr,\n    sa_data_op_t action, sa_data_locator_t *locator, void *datastart,\n    uint16_t buflen, dmu_tx_t *tx)\n{\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)hdl->sa_bonus;\n\tdnode_t *dn;\n\tsa_bulk_attr_t *attr_desc;\n\tvoid *old_data[2];\n\tint bonus_attr_count = 0;\n\tint bonus_data_size = 0;\n\tint spill_data_size = 0;\n\tint spill_attr_count = 0;\n\tint error;\n\tuint16_t length, reg_length;\n\tint i, j, k, length_idx;\n\tsa_hdr_phys_t *hdr;\n\tsa_idx_tab_t *idx_tab;\n\tint attr_count;\n\tint count;\n\n\tASSERT(MUTEX_HELD(&hdl->sa_lock));\n\n\t \n\n\tDB_DNODE_ENTER(db);\n\tdn = DB_DNODE(db);\n\tif (dn->dn_bonuslen != 0) {\n\t\tbonus_data_size = hdl->sa_bonus->db_size;\n\t\told_data[0] = kmem_alloc(bonus_data_size, KM_SLEEP);\n\t\tmemcpy(old_data[0], hdl->sa_bonus->db_data,\n\t\t    hdl->sa_bonus->db_size);\n\t\tbonus_attr_count = hdl->sa_bonus_tab->sa_layout->lot_attr_count;\n\t} else {\n\t\told_data[0] = NULL;\n\t}\n\tDB_DNODE_EXIT(db);\n\n\t \n\n\tif ((error = sa_get_spill(hdl)) == 0) {\n\t\tspill_data_size = hdl->sa_spill->db_size;\n\t\told_data[1] = vmem_alloc(spill_data_size, KM_SLEEP);\n\t\tmemcpy(old_data[1], hdl->sa_spill->db_data,\n\t\t    hdl->sa_spill->db_size);\n\t\tspill_attr_count =\n\t\t    hdl->sa_spill_tab->sa_layout->lot_attr_count;\n\t} else if (error && error != ENOENT) {\n\t\tif (old_data[0])\n\t\t\tkmem_free(old_data[0], bonus_data_size);\n\t\treturn (error);\n\t} else {\n\t\told_data[1] = NULL;\n\t}\n\n\t \n\n\tattr_count = bonus_attr_count + spill_attr_count;\n\tif (action == SA_ADD)\n\t\tattr_count++;\n\telse if (action == SA_REMOVE)\n\t\tattr_count--;\n\n\tattr_desc = kmem_zalloc(sizeof (sa_bulk_attr_t) * attr_count, KM_SLEEP);\n\n\t \n\tk = j = 0;\n\tcount = bonus_attr_count;\n\thdr = SA_GET_HDR(hdl, SA_BONUS);\n\tidx_tab = SA_IDX_TAB_GET(hdl, SA_BONUS);\n\tfor (; ; k++) {\n\t\t \n\t\tfor (i = 0, length_idx = 0; i != count; i++) {\n\t\t\tsa_attr_type_t attr;\n\n\t\t\tattr = idx_tab->sa_layout->lot_attrs[i];\n\t\t\treg_length = SA_REGISTERED_LEN(sa, attr);\n\t\t\tif (reg_length == 0) {\n\t\t\t\tlength = hdr->sa_lengths[length_idx];\n\t\t\t\tlength_idx++;\n\t\t\t} else {\n\t\t\t\tlength = reg_length;\n\t\t\t}\n\t\t\tif (attr == newattr) {\n\t\t\t\t \n\t\t\t\tif (action == SA_REMOVE)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tASSERT3S(action, ==, SA_REPLACE);\n\n\t\t\t\t \n\t\t\t\tASSERT3U(reg_length, ==, 0);\n\t\t\t\tASSERT3U(length, !=, buflen);\n\t\t\t\tSA_ADD_BULK_ATTR(attr_desc, j, attr,\n\t\t\t\t    locator, datastart, buflen);\n\t\t\t} else {\n\t\t\t\tSA_ADD_BULK_ATTR(attr_desc, j, attr,\n\t\t\t\t    NULL, (void *)\n\t\t\t\t    (TOC_OFF(idx_tab->sa_idx_tab[attr]) +\n\t\t\t\t    (uintptr_t)old_data[k]), length);\n\t\t\t}\n\t\t}\n\t\tif (k == 0 && hdl->sa_spill) {\n\t\t\thdr = SA_GET_HDR(hdl, SA_SPILL);\n\t\t\tidx_tab = SA_IDX_TAB_GET(hdl, SA_SPILL);\n\t\t\tcount = spill_attr_count;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (action == SA_ADD) {\n\t\treg_length = SA_REGISTERED_LEN(sa, newattr);\n\t\tIMPLY(reg_length != 0, reg_length == buflen);\n\t\tSA_ADD_BULK_ATTR(attr_desc, j, newattr, locator,\n\t\t    datastart, buflen);\n\t}\n\tASSERT3U(j, ==, attr_count);\n\n\terror = sa_build_layouts(hdl, attr_desc, attr_count, tx);\n\n\tif (old_data[0])\n\t\tkmem_free(old_data[0], bonus_data_size);\n\tif (old_data[1])\n\t\tvmem_free(old_data[1], spill_data_size);\n\tkmem_free(attr_desc, sizeof (sa_bulk_attr_t) * attr_count);\n\n\treturn (error);\n}\n\nstatic int\nsa_bulk_update_impl(sa_handle_t *hdl, sa_bulk_attr_t *bulk, int count,\n    dmu_tx_t *tx)\n{\n\tint error;\n\tsa_os_t *sa = hdl->sa_os->os_sa;\n\tdmu_object_type_t bonustype;\n\tdmu_buf_t *saved_spill;\n\n\tASSERT(hdl);\n\tASSERT(MUTEX_HELD(&hdl->sa_lock));\n\n\tbonustype = SA_BONUSTYPE_FROM_DB(SA_GET_DB(hdl, SA_BONUS));\n\tsaved_spill = hdl->sa_spill;\n\n\t \n\tif (sa->sa_need_attr_registration)\n\t\tsa_attr_register_sync(hdl, tx);\n\n\terror = sa_attr_op(hdl, bulk, count, SA_UPDATE, tx);\n\tif (error == 0 && !IS_SA_BONUSTYPE(bonustype) && sa->sa_update_cb)\n\t\tsa->sa_update_cb(hdl, tx);\n\n\t \n\tif (!saved_spill && hdl->sa_spill) {\n\t\tif (hdl->sa_spill_tab) {\n\t\t\tsa_idx_tab_rele(hdl->sa_os, hdl->sa_spill_tab);\n\t\t\thdl->sa_spill_tab = NULL;\n\t\t}\n\n\t\tdmu_buf_rele(hdl->sa_spill, NULL);\n\t\thdl->sa_spill = NULL;\n\t}\n\n\treturn (error);\n}\n\n \nint\nsa_update(sa_handle_t *hdl, sa_attr_type_t type,\n    void *buf, uint32_t buflen, dmu_tx_t *tx)\n{\n\tint error;\n\tsa_bulk_attr_t bulk;\n\n\tVERIFY3U(buflen, <=, SA_ATTR_MAX_LEN);\n\n\tbulk.sa_attr = type;\n\tbulk.sa_data_func = NULL;\n\tbulk.sa_length = buflen;\n\tbulk.sa_data = buf;\n\n\tmutex_enter(&hdl->sa_lock);\n\terror = sa_bulk_update_impl(hdl, &bulk, 1, tx);\n\tmutex_exit(&hdl->sa_lock);\n\treturn (error);\n}\n\n \n\nint\nsa_size(sa_handle_t *hdl, sa_attr_type_t attr, int *size)\n{\n\tsa_bulk_attr_t bulk;\n\tint error;\n\n\tbulk.sa_data = NULL;\n\tbulk.sa_attr = attr;\n\tbulk.sa_data_func = NULL;\n\n\tASSERT(hdl);\n\tmutex_enter(&hdl->sa_lock);\n\tif ((error = sa_attr_op(hdl, &bulk, 1, SA_LOOKUP, NULL)) != 0) {\n\t\tmutex_exit(&hdl->sa_lock);\n\t\treturn (error);\n\t}\n\t*size = bulk.sa_size;\n\n\tmutex_exit(&hdl->sa_lock);\n\treturn (0);\n}\n\nint\nsa_bulk_lookup_locked(sa_handle_t *hdl, sa_bulk_attr_t *attrs, int count)\n{\n\tASSERT(hdl);\n\tASSERT(MUTEX_HELD(&hdl->sa_lock));\n\treturn (sa_lookup_impl(hdl, attrs, count));\n}\n\nint\nsa_bulk_lookup(sa_handle_t *hdl, sa_bulk_attr_t *attrs, int count)\n{\n\tint error;\n\n\tASSERT(hdl);\n\tmutex_enter(&hdl->sa_lock);\n\terror = sa_bulk_lookup_locked(hdl, attrs, count);\n\tmutex_exit(&hdl->sa_lock);\n\treturn (error);\n}\n\nint\nsa_bulk_update(sa_handle_t *hdl, sa_bulk_attr_t *attrs, int count, dmu_tx_t *tx)\n{\n\tint error;\n\n\tASSERT(hdl);\n\tmutex_enter(&hdl->sa_lock);\n\terror = sa_bulk_update_impl(hdl, attrs, count, tx);\n\tmutex_exit(&hdl->sa_lock);\n\treturn (error);\n}\n\nint\nsa_remove(sa_handle_t *hdl, sa_attr_type_t attr, dmu_tx_t *tx)\n{\n\tint error;\n\n\tmutex_enter(&hdl->sa_lock);\n\terror = sa_modify_attrs(hdl, attr, SA_REMOVE, NULL,\n\t    NULL, 0, tx);\n\tmutex_exit(&hdl->sa_lock);\n\treturn (error);\n}\n\nvoid\nsa_object_info(sa_handle_t *hdl, dmu_object_info_t *doi)\n{\n\tdmu_object_info_from_db(hdl->sa_bonus, doi);\n}\n\nvoid\nsa_object_size(sa_handle_t *hdl, uint32_t *blksize, u_longlong_t *nblocks)\n{\n\tdmu_object_size_from_db(hdl->sa_bonus,\n\t    blksize, nblocks);\n}\n\nvoid\nsa_set_userp(sa_handle_t *hdl, void *ptr)\n{\n\thdl->sa_userp = ptr;\n}\n\ndmu_buf_t *\nsa_get_db(sa_handle_t *hdl)\n{\n\treturn (hdl->sa_bonus);\n}\n\nvoid *\nsa_get_userdata(sa_handle_t *hdl)\n{\n\treturn (hdl->sa_userp);\n}\n\nvoid\nsa_register_update_callback_locked(objset_t *os, sa_update_cb_t *func)\n{\n\tASSERT(MUTEX_HELD(&os->os_sa->sa_lock));\n\tos->os_sa->sa_update_cb = func;\n}\n\nvoid\nsa_register_update_callback(objset_t *os, sa_update_cb_t *func)\n{\n\n\tmutex_enter(&os->os_sa->sa_lock);\n\tsa_register_update_callback_locked(os, func);\n\tmutex_exit(&os->os_sa->sa_lock);\n}\n\nuint64_t\nsa_handle_object(sa_handle_t *hdl)\n{\n\treturn (hdl->sa_bonus->db_object);\n}\n\nboolean_t\nsa_enabled(objset_t *os)\n{\n\treturn (os->os_sa == NULL);\n}\n\nint\nsa_set_sa_object(objset_t *os, uint64_t sa_object)\n{\n\tsa_os_t *sa = os->os_sa;\n\n\tif (sa->sa_master_obj)\n\t\treturn (1);\n\n\tsa->sa_master_obj = sa_object;\n\n\treturn (0);\n}\n\nint\nsa_hdrsize(void *arg)\n{\n\tsa_hdr_phys_t *hdr = arg;\n\n\treturn (SA_HDR_SIZE(hdr));\n}\n\nvoid\nsa_handle_lock(sa_handle_t *hdl)\n{\n\tASSERT(hdl);\n\tmutex_enter(&hdl->sa_lock);\n}\n\nvoid\nsa_handle_unlock(sa_handle_t *hdl)\n{\n\tASSERT(hdl);\n\tmutex_exit(&hdl->sa_lock);\n}\n\n#ifdef _KERNEL\nEXPORT_SYMBOL(sa_handle_get);\nEXPORT_SYMBOL(sa_handle_get_from_db);\nEXPORT_SYMBOL(sa_handle_destroy);\nEXPORT_SYMBOL(sa_buf_hold);\nEXPORT_SYMBOL(sa_buf_rele);\nEXPORT_SYMBOL(sa_spill_rele);\nEXPORT_SYMBOL(sa_lookup);\nEXPORT_SYMBOL(sa_update);\nEXPORT_SYMBOL(sa_remove);\nEXPORT_SYMBOL(sa_bulk_lookup);\nEXPORT_SYMBOL(sa_bulk_lookup_locked);\nEXPORT_SYMBOL(sa_bulk_update);\nEXPORT_SYMBOL(sa_size);\nEXPORT_SYMBOL(sa_object_info);\nEXPORT_SYMBOL(sa_object_size);\nEXPORT_SYMBOL(sa_get_userdata);\nEXPORT_SYMBOL(sa_set_userp);\nEXPORT_SYMBOL(sa_get_db);\nEXPORT_SYMBOL(sa_handle_object);\nEXPORT_SYMBOL(sa_register_update_callback);\nEXPORT_SYMBOL(sa_setup);\nEXPORT_SYMBOL(sa_replace_all_by_template);\nEXPORT_SYMBOL(sa_replace_all_by_template_locked);\nEXPORT_SYMBOL(sa_enabled);\nEXPORT_SYMBOL(sa_cache_init);\nEXPORT_SYMBOL(sa_cache_fini);\nEXPORT_SYMBOL(sa_set_sa_object);\nEXPORT_SYMBOL(sa_hdrsize);\nEXPORT_SYMBOL(sa_handle_lock);\nEXPORT_SYMBOL(sa_handle_unlock);\nEXPORT_SYMBOL(sa_lookup_uio);\nEXPORT_SYMBOL(sa_add_projid);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}