{
  "module_name": "zio_checksum.c",
  "hash_id": "04d95dc82ac4bce5d4894e1f78b41b59aa6389dabfbd376b5c337e847fd64dc1",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zio_checksum.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zio.h>\n#include <sys/zio_checksum.h>\n#include <sys/zil.h>\n#include <sys/abd.h>\n#include <zfs_fletcher.h>\n\n \n\nstatic void\nabd_checksum_off(abd_t *abd, uint64_t size,\n    const void *ctx_template, zio_cksum_t *zcp)\n{\n\t(void) abd, (void) size, (void) ctx_template;\n\tZIO_SET_CHECKSUM(zcp, 0, 0, 0, 0);\n}\n\nstatic void\nabd_fletcher_2_native(abd_t *abd, uint64_t size,\n    const void *ctx_template, zio_cksum_t *zcp)\n{\n\t(void) ctx_template;\n\tfletcher_init(zcp);\n\t(void) abd_iterate_func(abd, 0, size,\n\t    fletcher_2_incremental_native, zcp);\n}\n\nstatic void\nabd_fletcher_2_byteswap(abd_t *abd, uint64_t size,\n    const void *ctx_template, zio_cksum_t *zcp)\n{\n\t(void) ctx_template;\n\tfletcher_init(zcp);\n\t(void) abd_iterate_func(abd, 0, size,\n\t    fletcher_2_incremental_byteswap, zcp);\n}\n\nstatic inline void\nabd_fletcher_4_impl(abd_t *abd, uint64_t size, zio_abd_checksum_data_t *acdp)\n{\n\tfletcher_4_abd_ops.acf_init(acdp);\n\tabd_iterate_func(abd, 0, size, fletcher_4_abd_ops.acf_iter, acdp);\n\tfletcher_4_abd_ops.acf_fini(acdp);\n}\n\nvoid\nabd_fletcher_4_native(abd_t *abd, uint64_t size,\n    const void *ctx_template, zio_cksum_t *zcp)\n{\n\t(void) ctx_template;\n\tfletcher_4_ctx_t ctx;\n\n\tzio_abd_checksum_data_t acd = {\n\t\t.acd_byteorder\t= ZIO_CHECKSUM_NATIVE,\n\t\t.acd_zcp \t= zcp,\n\t\t.acd_ctx\t= &ctx\n\t};\n\n\tabd_fletcher_4_impl(abd, size, &acd);\n\n}\n\nvoid\nabd_fletcher_4_byteswap(abd_t *abd, uint64_t size,\n    const void *ctx_template, zio_cksum_t *zcp)\n{\n\t(void) ctx_template;\n\tfletcher_4_ctx_t ctx;\n\n\tzio_abd_checksum_data_t acd = {\n\t\t.acd_byteorder\t= ZIO_CHECKSUM_BYTESWAP,\n\t\t.acd_zcp \t= zcp,\n\t\t.acd_ctx\t= &ctx\n\t};\n\n\tabd_fletcher_4_impl(abd, size, &acd);\n}\n\nzio_checksum_info_t zio_checksum_table[ZIO_CHECKSUM_FUNCTIONS] = {\n\t{{NULL, NULL}, NULL, NULL, 0, \"inherit\"},\n\t{{NULL, NULL}, NULL, NULL, 0, \"on\"},\n\t{{abd_checksum_off,\t\tabd_checksum_off},\n\t    NULL, NULL, 0, \"off\"},\n\t{{abd_checksum_sha256,\t\tabd_checksum_sha256},\n\t    NULL, NULL, ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_EMBEDDED,\n\t    \"label\"},\n\t{{abd_checksum_sha256,\t\tabd_checksum_sha256},\n\t    NULL, NULL, ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_EMBEDDED,\n\t    \"gang_header\"},\n\t{{abd_fletcher_2_native,\tabd_fletcher_2_byteswap},\n\t    NULL, NULL, ZCHECKSUM_FLAG_EMBEDDED, \"zilog\"},\n\t{{abd_fletcher_2_native,\tabd_fletcher_2_byteswap},\n\t    NULL, NULL, 0, \"fletcher2\"},\n\t{{abd_fletcher_4_native,\tabd_fletcher_4_byteswap},\n\t    NULL, NULL, ZCHECKSUM_FLAG_METADATA, \"fletcher4\"},\n\t{{abd_checksum_sha256,\t\tabd_checksum_sha256},\n\t    NULL, NULL, ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_DEDUP |\n\t    ZCHECKSUM_FLAG_NOPWRITE, \"sha256\"},\n\t{{abd_fletcher_4_native,\tabd_fletcher_4_byteswap},\n\t    NULL, NULL, ZCHECKSUM_FLAG_EMBEDDED, \"zilog2\"},\n\t{{abd_checksum_off,\t\tabd_checksum_off},\n\t    NULL, NULL, 0, \"noparity\"},\n\t{{abd_checksum_sha512_native,\tabd_checksum_sha512_byteswap},\n\t    NULL, NULL, ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_DEDUP |\n\t    ZCHECKSUM_FLAG_NOPWRITE, \"sha512\"},\n\t{{abd_checksum_skein_native,\tabd_checksum_skein_byteswap},\n\t    abd_checksum_skein_tmpl_init, abd_checksum_skein_tmpl_free,\n\t    ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_DEDUP |\n\t    ZCHECKSUM_FLAG_SALTED | ZCHECKSUM_FLAG_NOPWRITE, \"skein\"},\n\t{{abd_checksum_edonr_native,\tabd_checksum_edonr_byteswap},\n\t    abd_checksum_edonr_tmpl_init, abd_checksum_edonr_tmpl_free,\n\t    ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_SALTED |\n\t    ZCHECKSUM_FLAG_NOPWRITE, \"edonr\"},\n\t{{abd_checksum_blake3_native,\tabd_checksum_blake3_byteswap},\n\t    abd_checksum_blake3_tmpl_init, abd_checksum_blake3_tmpl_free,\n\t    ZCHECKSUM_FLAG_METADATA | ZCHECKSUM_FLAG_DEDUP |\n\t    ZCHECKSUM_FLAG_SALTED | ZCHECKSUM_FLAG_NOPWRITE, \"blake3\"},\n};\n\n \nspa_feature_t\nzio_checksum_to_feature(enum zio_checksum cksum)\n{\n\tVERIFY((cksum & ~ZIO_CHECKSUM_MASK) == 0);\n\n\tswitch (cksum) {\n\tcase ZIO_CHECKSUM_BLAKE3:\n\t\treturn (SPA_FEATURE_BLAKE3);\n\tcase ZIO_CHECKSUM_SHA512:\n\t\treturn (SPA_FEATURE_SHA512);\n\tcase ZIO_CHECKSUM_SKEIN:\n\t\treturn (SPA_FEATURE_SKEIN);\n\tcase ZIO_CHECKSUM_EDONR:\n\t\treturn (SPA_FEATURE_EDONR);\n\tdefault:\n\t\treturn (SPA_FEATURE_NONE);\n\t}\n}\n\nenum zio_checksum\nzio_checksum_select(enum zio_checksum child, enum zio_checksum parent)\n{\n\tASSERT(child < ZIO_CHECKSUM_FUNCTIONS);\n\tASSERT(parent < ZIO_CHECKSUM_FUNCTIONS);\n\tASSERT(parent != ZIO_CHECKSUM_INHERIT && parent != ZIO_CHECKSUM_ON);\n\n\tif (child == ZIO_CHECKSUM_INHERIT)\n\t\treturn (parent);\n\n\tif (child == ZIO_CHECKSUM_ON)\n\t\treturn (ZIO_CHECKSUM_ON_VALUE);\n\n\treturn (child);\n}\n\nenum zio_checksum\nzio_checksum_dedup_select(spa_t *spa, enum zio_checksum child,\n    enum zio_checksum parent)\n{\n\tASSERT((child & ZIO_CHECKSUM_MASK) < ZIO_CHECKSUM_FUNCTIONS);\n\tASSERT((parent & ZIO_CHECKSUM_MASK) < ZIO_CHECKSUM_FUNCTIONS);\n\tASSERT(parent != ZIO_CHECKSUM_INHERIT && parent != ZIO_CHECKSUM_ON);\n\n\tif (child == ZIO_CHECKSUM_INHERIT)\n\t\treturn (parent);\n\n\tif (child == ZIO_CHECKSUM_ON)\n\t\treturn (spa_dedup_checksum(spa));\n\n\tif (child == (ZIO_CHECKSUM_ON | ZIO_CHECKSUM_VERIFY))\n\t\treturn (spa_dedup_checksum(spa) | ZIO_CHECKSUM_VERIFY);\n\n\tASSERT((zio_checksum_table[child & ZIO_CHECKSUM_MASK].ci_flags &\n\t    ZCHECKSUM_FLAG_DEDUP) ||\n\t    (child & ZIO_CHECKSUM_VERIFY) || child == ZIO_CHECKSUM_OFF);\n\n\treturn (child);\n}\n\n \nstatic void\nzio_checksum_gang_verifier(zio_cksum_t *zcp, const blkptr_t *bp)\n{\n\tconst dva_t *dva = BP_IDENTITY(bp);\n\tuint64_t txg = BP_PHYSICAL_BIRTH(bp);\n\n\tASSERT(BP_IS_GANG(bp));\n\n\tZIO_SET_CHECKSUM(zcp, DVA_GET_VDEV(dva), DVA_GET_OFFSET(dva), txg, 0);\n}\n\n \nstatic void\nzio_checksum_label_verifier(zio_cksum_t *zcp, uint64_t offset)\n{\n\tZIO_SET_CHECKSUM(zcp, offset, 0, 0, 0);\n}\n\n \nstatic void\nzio_checksum_template_init(enum zio_checksum checksum, spa_t *spa)\n{\n\tzio_checksum_info_t *ci = &zio_checksum_table[checksum];\n\n\tif (ci->ci_tmpl_init == NULL)\n\t\treturn;\n\tif (spa->spa_cksum_tmpls[checksum] != NULL)\n\t\treturn;\n\n\tVERIFY(ci->ci_tmpl_free != NULL);\n\tmutex_enter(&spa->spa_cksum_tmpls_lock);\n\tif (spa->spa_cksum_tmpls[checksum] == NULL) {\n\t\tspa->spa_cksum_tmpls[checksum] =\n\t\t    ci->ci_tmpl_init(&spa->spa_cksum_salt);\n\t\tVERIFY(spa->spa_cksum_tmpls[checksum] != NULL);\n\t}\n\tmutex_exit(&spa->spa_cksum_tmpls_lock);\n}\n\n \nstatic void\nzio_checksum_handle_crypt(zio_cksum_t *cksum, zio_cksum_t *saved, boolean_t xor)\n{\n\t \n\tif (xor) {\n\t\tcksum->zc_word[0] ^= cksum->zc_word[2];\n\t\tcksum->zc_word[1] ^= cksum->zc_word[3];\n\t}\n\n\tcksum->zc_word[2] = saved->zc_word[2];\n\tcksum->zc_word[3] = saved->zc_word[3];\n}\n\n \nvoid\nzio_checksum_compute(zio_t *zio, enum zio_checksum checksum,\n    abd_t *abd, uint64_t size)\n{\n\tstatic const uint64_t zec_magic = ZEC_MAGIC;\n\tblkptr_t *bp = zio->io_bp;\n\tuint64_t offset = zio->io_offset;\n\tzio_checksum_info_t *ci = &zio_checksum_table[checksum];\n\tzio_cksum_t cksum, saved;\n\tspa_t *spa = zio->io_spa;\n\tboolean_t insecure = (ci->ci_flags & ZCHECKSUM_FLAG_DEDUP) == 0;\n\n\tASSERT((uint_t)checksum < ZIO_CHECKSUM_FUNCTIONS);\n\tASSERT(ci->ci_func[0] != NULL);\n\n\tzio_checksum_template_init(checksum, spa);\n\n\tif (ci->ci_flags & ZCHECKSUM_FLAG_EMBEDDED) {\n\t\tzio_eck_t eck;\n\t\tsize_t eck_offset;\n\n\t\tmemset(&saved, 0, sizeof (zio_cksum_t));\n\n\t\tif (checksum == ZIO_CHECKSUM_ZILOG2) {\n\t\t\tzil_chain_t zilc;\n\t\t\tabd_copy_to_buf(&zilc, abd, sizeof (zil_chain_t));\n\n\t\t\tsize = P2ROUNDUP_TYPED(zilc.zc_nused, ZIL_MIN_BLKSZ,\n\t\t\t    uint64_t);\n\t\t\teck = zilc.zc_eck;\n\t\t\teck_offset = offsetof(zil_chain_t, zc_eck);\n\t\t} else {\n\t\t\teck_offset = size - sizeof (zio_eck_t);\n\t\t\tabd_copy_to_buf_off(&eck, abd, eck_offset,\n\t\t\t    sizeof (zio_eck_t));\n\t\t}\n\n\t\tif (checksum == ZIO_CHECKSUM_GANG_HEADER) {\n\t\t\tzio_checksum_gang_verifier(&eck.zec_cksum, bp);\n\t\t} else if (checksum == ZIO_CHECKSUM_LABEL) {\n\t\t\tzio_checksum_label_verifier(&eck.zec_cksum, offset);\n\t\t} else {\n\t\t\tsaved = eck.zec_cksum;\n\t\t\teck.zec_cksum = bp->blk_cksum;\n\t\t}\n\n\t\tabd_copy_from_buf_off(abd, &zec_magic,\n\t\t    eck_offset + offsetof(zio_eck_t, zec_magic),\n\t\t    sizeof (zec_magic));\n\t\tabd_copy_from_buf_off(abd, &eck.zec_cksum,\n\t\t    eck_offset + offsetof(zio_eck_t, zec_cksum),\n\t\t    sizeof (zio_cksum_t));\n\n\t\tci->ci_func[0](abd, size, spa->spa_cksum_tmpls[checksum],\n\t\t    &cksum);\n\t\tif (bp != NULL && BP_USES_CRYPT(bp) &&\n\t\t    BP_GET_TYPE(bp) != DMU_OT_OBJSET)\n\t\t\tzio_checksum_handle_crypt(&cksum, &saved, insecure);\n\n\t\tabd_copy_from_buf_off(abd, &cksum,\n\t\t    eck_offset + offsetof(zio_eck_t, zec_cksum),\n\t\t    sizeof (zio_cksum_t));\n\t} else {\n\t\tsaved = bp->blk_cksum;\n\t\tci->ci_func[0](abd, size, spa->spa_cksum_tmpls[checksum],\n\t\t    &cksum);\n\t\tif (BP_USES_CRYPT(bp) && BP_GET_TYPE(bp) != DMU_OT_OBJSET)\n\t\t\tzio_checksum_handle_crypt(&cksum, &saved, insecure);\n\t\tbp->blk_cksum = cksum;\n\t}\n}\n\nint\nzio_checksum_error_impl(spa_t *spa, const blkptr_t *bp,\n    enum zio_checksum checksum, abd_t *abd, uint64_t size, uint64_t offset,\n    zio_bad_cksum_t *info)\n{\n\tzio_checksum_info_t *ci = &zio_checksum_table[checksum];\n\tzio_cksum_t actual_cksum, expected_cksum;\n\tzio_eck_t eck;\n\tint byteswap;\n\n\tif (checksum >= ZIO_CHECKSUM_FUNCTIONS || ci->ci_func[0] == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzio_checksum_template_init(checksum, spa);\n\n\tIMPLY(bp == NULL, ci->ci_flags & ZCHECKSUM_FLAG_EMBEDDED);\n\tIMPLY(bp == NULL, checksum == ZIO_CHECKSUM_LABEL);\n\n\tif (ci->ci_flags & ZCHECKSUM_FLAG_EMBEDDED) {\n\t\tzio_cksum_t verifier;\n\t\tsize_t eck_offset;\n\n\t\tif (checksum == ZIO_CHECKSUM_ZILOG2) {\n\t\t\tzil_chain_t zilc;\n\t\t\tuint64_t nused;\n\n\t\t\tabd_copy_to_buf(&zilc, abd, sizeof (zil_chain_t));\n\n\t\t\teck = zilc.zc_eck;\n\t\t\teck_offset = offsetof(zil_chain_t, zc_eck) +\n\t\t\t    offsetof(zio_eck_t, zec_cksum);\n\n\t\t\tif (eck.zec_magic == ZEC_MAGIC) {\n\t\t\t\tnused = zilc.zc_nused;\n\t\t\t} else if (eck.zec_magic == BSWAP_64(ZEC_MAGIC)) {\n\t\t\t\tnused = BSWAP_64(zilc.zc_nused);\n\t\t\t} else {\n\t\t\t\treturn (SET_ERROR(ECKSUM));\n\t\t\t}\n\n\t\t\tif (nused > size) {\n\t\t\t\treturn (SET_ERROR(ECKSUM));\n\t\t\t}\n\n\t\t\tsize = P2ROUNDUP_TYPED(nused, ZIL_MIN_BLKSZ, uint64_t);\n\t\t} else {\n\t\t\teck_offset = size - sizeof (zio_eck_t);\n\t\t\tabd_copy_to_buf_off(&eck, abd, eck_offset,\n\t\t\t    sizeof (zio_eck_t));\n\t\t\teck_offset += offsetof(zio_eck_t, zec_cksum);\n\t\t}\n\n\t\tif (checksum == ZIO_CHECKSUM_GANG_HEADER)\n\t\t\tzio_checksum_gang_verifier(&verifier, bp);\n\t\telse if (checksum == ZIO_CHECKSUM_LABEL)\n\t\t\tzio_checksum_label_verifier(&verifier, offset);\n\t\telse\n\t\t\tverifier = bp->blk_cksum;\n\n\t\tbyteswap = (eck.zec_magic == BSWAP_64(ZEC_MAGIC));\n\n\t\tif (byteswap)\n\t\t\tbyteswap_uint64_array(&verifier, sizeof (zio_cksum_t));\n\n\t\texpected_cksum = eck.zec_cksum;\n\n\t\tabd_copy_from_buf_off(abd, &verifier, eck_offset,\n\t\t    sizeof (zio_cksum_t));\n\n\t\tci->ci_func[byteswap](abd, size,\n\t\t    spa->spa_cksum_tmpls[checksum], &actual_cksum);\n\n\t\tabd_copy_from_buf_off(abd, &expected_cksum, eck_offset,\n\t\t    sizeof (zio_cksum_t));\n\n\t\tif (byteswap) {\n\t\t\tbyteswap_uint64_array(&expected_cksum,\n\t\t\t    sizeof (zio_cksum_t));\n\t\t}\n\t} else {\n\t\tbyteswap = BP_SHOULD_BYTESWAP(bp);\n\t\texpected_cksum = bp->blk_cksum;\n\t\tci->ci_func[byteswap](abd, size,\n\t\t    spa->spa_cksum_tmpls[checksum], &actual_cksum);\n\t}\n\n\t \n\tif (bp != NULL && BP_USES_CRYPT(bp) &&\n\t    BP_GET_TYPE(bp) != DMU_OT_OBJSET) {\n\t\tif (!(ci->ci_flags & ZCHECKSUM_FLAG_DEDUP)) {\n\t\t\tactual_cksum.zc_word[0] ^= actual_cksum.zc_word[2];\n\t\t\tactual_cksum.zc_word[1] ^= actual_cksum.zc_word[3];\n\t\t}\n\n\t\tactual_cksum.zc_word[2] = 0;\n\t\tactual_cksum.zc_word[3] = 0;\n\t\texpected_cksum.zc_word[2] = 0;\n\t\texpected_cksum.zc_word[3] = 0;\n\t}\n\n\tif (info != NULL) {\n\t\tinfo->zbc_checksum_name = ci->ci_name;\n\t\tinfo->zbc_byteswapped = byteswap;\n\t\tinfo->zbc_injected = 0;\n\t\tinfo->zbc_has_cksum = 1;\n\t}\n\n\tif (!ZIO_CHECKSUM_EQUAL(actual_cksum, expected_cksum))\n\t\treturn (SET_ERROR(ECKSUM));\n\n\treturn (0);\n}\n\nint\nzio_checksum_error(zio_t *zio, zio_bad_cksum_t *info)\n{\n\tblkptr_t *bp = zio->io_bp;\n\tuint_t checksum = (bp == NULL ? zio->io_prop.zp_checksum :\n\t    (BP_IS_GANG(bp) ? ZIO_CHECKSUM_GANG_HEADER : BP_GET_CHECKSUM(bp)));\n\tint error;\n\tuint64_t size = (bp == NULL ? zio->io_size :\n\t    (BP_IS_GANG(bp) ? SPA_GANGBLOCKSIZE : BP_GET_PSIZE(bp)));\n\tuint64_t offset = zio->io_offset;\n\tabd_t *data = zio->io_abd;\n\tspa_t *spa = zio->io_spa;\n\n\terror = zio_checksum_error_impl(spa, bp, checksum, data, size,\n\t    offset, info);\n\n\tif (zio_injection_enabled && error == 0 && zio->io_error == 0) {\n\t\terror = zio_handle_fault_injection(zio, ECKSUM);\n\t\tif (error != 0)\n\t\t\tinfo->zbc_injected = 1;\n\t}\n\n\treturn (error);\n}\n\n \nvoid\nzio_checksum_templates_free(spa_t *spa)\n{\n\tfor (enum zio_checksum checksum = 0;\n\t    checksum < ZIO_CHECKSUM_FUNCTIONS; checksum++) {\n\t\tif (spa->spa_cksum_tmpls[checksum] != NULL) {\n\t\t\tzio_checksum_info_t *ci = &zio_checksum_table[checksum];\n\n\t\t\tVERIFY(ci->ci_tmpl_free != NULL);\n\t\t\tci->ci_tmpl_free(spa->spa_cksum_tmpls[checksum]);\n\t\t\tspa->spa_cksum_tmpls[checksum] = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}