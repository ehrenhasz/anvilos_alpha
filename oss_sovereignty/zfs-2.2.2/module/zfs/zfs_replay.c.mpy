{
  "module_name": "zfs_replay.c",
  "hash_id": "2910436541e5ac2437454d9b4c3819071399e2ce084d143eebf811c7edf9c75d",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_replay.c",
  "human_readable_source": " \n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/cmn_err.h>\n#include <sys/kmem.h>\n#include <sys/thread.h>\n#include <sys/file.h>\n#include <sys/fcntl.h>\n#include <sys/vfs.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_fuid.h>\n#include <sys/zfs_vnops.h>\n#include <sys/spa.h>\n#include <sys/zil.h>\n#include <sys/byteorder.h>\n#include <sys/stat.h>\n#include <sys/acl.h>\n#include <sys/atomic.h>\n#include <sys/cred.h>\n#include <sys/zpl.h>\n#include <sys/dmu_objset.h>\n#include <sys/zfeature.h>\n\n \n\n \n\nstatic void\nzfs_init_vattr(vattr_t *vap, uint64_t mask, uint64_t mode,\n    uint64_t uid, uint64_t gid, uint64_t rdev, uint64_t nodeid)\n{\n\tmemset(vap, 0, sizeof (*vap));\n\tvap->va_mask = (uint_t)mask;\n\tvap->va_mode = mode;\n#if defined(__FreeBSD__) || defined(__APPLE__)\n\tvap->va_type = IFTOVT(mode);\n#endif\n\tvap->va_uid = (uid_t)(IS_EPHEMERAL(uid)) ? -1 : uid;\n\tvap->va_gid = (gid_t)(IS_EPHEMERAL(gid)) ? -1 : gid;\n\tvap->va_rdev = zfs_cmpldev(rdev);\n\tvap->va_nodeid = nodeid;\n}\n\nstatic int\nzfs_replay_error(void *arg1, void *arg2, boolean_t byteswap)\n{\n\t(void) arg1, (void) arg2, (void) byteswap;\n\treturn (SET_ERROR(ENOTSUP));\n}\n\nstatic void\nzfs_replay_xvattr(lr_attr_t *lrattr, xvattr_t *xvap)\n{\n\txoptattr_t *xoap = NULL;\n\tuint64_t *attrs;\n\tuint64_t *crtime;\n\tuint32_t *bitmap;\n\tvoid *scanstamp;\n\tint i;\n\n\txvap->xva_vattr.va_mask |= ATTR_XVATTR;\n\tif ((xoap = xva_getxoptattr(xvap)) == NULL) {\n\t\txvap->xva_vattr.va_mask &= ~ATTR_XVATTR;  \n\t\treturn;\n\t}\n\n\tASSERT(lrattr->lr_attr_masksize == xvap->xva_mapsize);\n\n\tbitmap = &lrattr->lr_attr_bitmap;\n\tfor (i = 0; i != lrattr->lr_attr_masksize; i++, bitmap++)\n\t\txvap->xva_reqattrmap[i] = *bitmap;\n\n\tattrs = (uint64_t *)(lrattr + lrattr->lr_attr_masksize - 1);\n\tcrtime = attrs + 1;\n\tscanstamp = (caddr_t)(crtime + 2);\n\n\tif (XVA_ISSET_REQ(xvap, XAT_HIDDEN))\n\t\txoap->xoa_hidden = ((*attrs & XAT0_HIDDEN) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_SYSTEM))\n\t\txoap->xoa_system = ((*attrs & XAT0_SYSTEM) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_ARCHIVE))\n\t\txoap->xoa_archive = ((*attrs & XAT0_ARCHIVE) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_READONLY))\n\t\txoap->xoa_readonly = ((*attrs & XAT0_READONLY) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE))\n\t\txoap->xoa_immutable = ((*attrs & XAT0_IMMUTABLE) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK))\n\t\txoap->xoa_nounlink = ((*attrs & XAT0_NOUNLINK) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY))\n\t\txoap->xoa_appendonly = ((*attrs & XAT0_APPENDONLY) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP))\n\t\txoap->xoa_nodump = ((*attrs & XAT0_NODUMP) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_OPAQUE))\n\t\txoap->xoa_opaque = ((*attrs & XAT0_OPAQUE) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED))\n\t\txoap->xoa_av_modified = ((*attrs & XAT0_AV_MODIFIED) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED))\n\t\txoap->xoa_av_quarantined =\n\t\t    ((*attrs & XAT0_AV_QUARANTINED) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_CREATETIME))\n\t\tZFS_TIME_DECODE(&xoap->xoa_createtime, crtime);\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP)) {\n\t\tASSERT(!XVA_ISSET_REQ(xvap, XAT_PROJID));\n\n\t\tmemcpy(xoap->xoa_av_scanstamp, scanstamp, AV_SCANSTAMP_SZ);\n\t} else if (XVA_ISSET_REQ(xvap, XAT_PROJID)) {\n\t\t \n\t\tmemcpy(&xoap->xoa_projid, scanstamp, sizeof (uint64_t));\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE))\n\t\txoap->xoa_reparse = ((*attrs & XAT0_REPARSE) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_OFFLINE))\n\t\txoap->xoa_offline = ((*attrs & XAT0_OFFLINE) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_SPARSE))\n\t\txoap->xoa_sparse = ((*attrs & XAT0_SPARSE) != 0);\n\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT))\n\t\txoap->xoa_projinherit = ((*attrs & XAT0_PROJINHERIT) != 0);\n}\n\nstatic int\nzfs_replay_domain_cnt(uint64_t uid, uint64_t gid)\n{\n\tuint64_t uid_idx;\n\tuint64_t gid_idx;\n\tint domcnt = 0;\n\n\tuid_idx = FUID_INDEX(uid);\n\tgid_idx = FUID_INDEX(gid);\n\tif (uid_idx)\n\t\tdomcnt++;\n\tif (gid_idx > 0 && gid_idx != uid_idx)\n\t\tdomcnt++;\n\n\treturn (domcnt);\n}\n\nstatic void *\nzfs_replay_fuid_domain_common(zfs_fuid_info_t *fuid_infop, void *start,\n    int domcnt)\n{\n\tint i;\n\n\tfor (i = 0; i != domcnt; i++) {\n\t\tfuid_infop->z_domain_table[i] = start;\n\t\tstart = (caddr_t)start + strlen(start) + 1;\n\t}\n\n\treturn (start);\n}\n\n \nstatic void\nzfs_replay_fuid_ugid(zfs_fuid_info_t *fuid_infop, uint64_t uid, uint64_t gid)\n{\n\t \n\tif (IS_EPHEMERAL(uid))\n\t\tfuid_infop->z_fuid_owner = uid;\n\n\tif (IS_EPHEMERAL(gid))\n\t\tfuid_infop->z_fuid_group = gid;\n}\n\n \nstatic zfs_fuid_info_t *\nzfs_replay_fuid_domain(void *buf, void **end, uint64_t uid, uint64_t gid)\n{\n\tint domcnt;\n\n\tzfs_fuid_info_t *fuid_infop;\n\n\tfuid_infop = zfs_fuid_info_alloc();\n\n\tdomcnt = zfs_replay_domain_cnt(uid, gid);\n\n\tif (domcnt == 0)\n\t\treturn (fuid_infop);\n\n\tfuid_infop->z_domain_table =\n\t    kmem_zalloc(domcnt * sizeof (char *), KM_SLEEP);\n\n\tzfs_replay_fuid_ugid(fuid_infop, uid, gid);\n\n\tfuid_infop->z_domain_cnt = domcnt;\n\t*end = zfs_replay_fuid_domain_common(fuid_infop, buf, domcnt);\n\treturn (fuid_infop);\n}\n\n \nstatic zfs_fuid_info_t *\nzfs_replay_fuids(void *start, void **end, int idcnt, int domcnt, uint64_t uid,\n    uint64_t gid)\n{\n\tuint64_t *log_fuid = (uint64_t *)start;\n\tzfs_fuid_info_t *fuid_infop;\n\tint i;\n\n\tfuid_infop = zfs_fuid_info_alloc();\n\tfuid_infop->z_domain_cnt = domcnt;\n\n\tfuid_infop->z_domain_table =\n\t    kmem_zalloc(domcnt * sizeof (char *), KM_SLEEP);\n\n\tfor (i = 0; i != idcnt; i++) {\n\t\tzfs_fuid_t *zfuid;\n\n\t\tzfuid = kmem_alloc(sizeof (zfs_fuid_t), KM_SLEEP);\n\t\tzfuid->z_logfuid = *log_fuid;\n\t\tzfuid->z_id = -1;\n\t\tzfuid->z_domidx = 0;\n\t\tlist_insert_tail(&fuid_infop->z_fuids, zfuid);\n\t\tlog_fuid++;\n\t}\n\n\tzfs_replay_fuid_ugid(fuid_infop, uid, gid);\n\n\t*end = zfs_replay_fuid_domain_common(fuid_infop, log_fuid, domcnt);\n\treturn (fuid_infop);\n}\n\nstatic void\nzfs_replay_swap_attrs(lr_attr_t *lrattr)\n{\n\t \n\tbyteswap_uint32_array(lrattr, sizeof (*lrattr));\n\t \n\tbyteswap_uint32_array(lrattr + 1, (lrattr->lr_attr_masksize - 1) *\n\t    sizeof (uint32_t));\n\t \n\tbyteswap_uint64_array((caddr_t)(lrattr + 1) + (sizeof (uint32_t) *\n\t    (lrattr->lr_attr_masksize - 1)), 3 * sizeof (uint64_t));\n}\n\n \nstatic int\nzfs_replay_create_acl(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_acl_create_t *lracl = arg2;\n\tchar *name = NULL;\t\t \n\tlr_create_t *lr = (lr_create_t *)lracl;\n\tznode_t *dzp;\n\tznode_t *zp;\n\txvattr_t xva;\n\tint vflg = 0;\n\tvsecattr_t vsec = { 0 };\n\tlr_attr_t *lrattr;\n\tvoid *aclstart;\n\tvoid *fuidstart;\n\tsize_t xvatlen = 0;\n\tuint64_t txtype;\n\tuint64_t objid;\n\tuint64_t dnodesize;\n\tint error;\n\n\ttxtype = (lr->lr_common.lrc_txtype & ~TX_CI);\n\tif (byteswap) {\n\t\tbyteswap_uint64_array(lracl, sizeof (*lracl));\n\t\tif (txtype == TX_CREATE_ACL_ATTR ||\n\t\t    txtype == TX_MKDIR_ACL_ATTR) {\n\t\t\tlrattr = (lr_attr_t *)(caddr_t)(lracl + 1);\n\t\t\tzfs_replay_swap_attrs(lrattr);\n\t\t\txvatlen = ZIL_XVAT_SIZE(lrattr->lr_attr_masksize);\n\t\t}\n\n\t\taclstart = (caddr_t)(lracl + 1) + xvatlen;\n\t\tzfs_ace_byteswap(aclstart, lracl->lr_acl_bytes, B_FALSE);\n\t\t \n\t\tif (lracl->lr_fuidcnt) {\n\t\t\tbyteswap_uint64_array((caddr_t)aclstart +\n\t\t\t    ZIL_ACE_LENGTH(lracl->lr_acl_bytes),\n\t\t\t    lracl->lr_fuidcnt * sizeof (uint64_t));\n\t\t}\n\t}\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_doid, &dzp)) != 0)\n\t\treturn (error);\n\n\tobjid = LR_FOID_GET_OBJ(lr->lr_foid);\n\tdnodesize = LR_FOID_GET_SLOTS(lr->lr_foid) << DNODE_SHIFT;\n\n\txva_init(&xva);\n\tzfs_init_vattr(&xva.xva_vattr, ATTR_MODE | ATTR_UID | ATTR_GID,\n\t    lr->lr_mode, lr->lr_uid, lr->lr_gid, lr->lr_rdev, objid);\n\n\t \n\tZFS_TIME_DECODE(&xva.xva_vattr.va_ctime, lr->lr_crtime);\n\txva.xva_vattr.va_nblocks = lr->lr_gen;\n\txva.xva_vattr.va_fsid = dnodesize;\n\n\terror = dnode_try_claim(zfsvfs->z_os, objid, dnodesize >> DNODE_SHIFT);\n\tif (error)\n\t\tgoto bail;\n\n\tif (lr->lr_common.lrc_txtype & TX_CI)\n\t\tvflg |= FIGNORECASE;\n\tswitch (txtype) {\n\tcase TX_CREATE_ACL:\n\t\taclstart = (caddr_t)(lracl + 1);\n\t\tfuidstart = (caddr_t)aclstart +\n\t\t    ZIL_ACE_LENGTH(lracl->lr_acl_bytes);\n\t\tzfsvfs->z_fuid_replay = zfs_replay_fuids(fuidstart,\n\t\t    (void *)&name, lracl->lr_fuidcnt, lracl->lr_domcnt,\n\t\t    lr->lr_uid, lr->lr_gid);\n\t\tzfs_fallthrough;\n\tcase TX_CREATE_ACL_ATTR:\n\t\tif (name == NULL) {\n\t\t\tlrattr = (lr_attr_t *)(caddr_t)(lracl + 1);\n\t\t\txvatlen = ZIL_XVAT_SIZE(lrattr->lr_attr_masksize);\n\t\t\txva.xva_vattr.va_mask |= ATTR_XVATTR;\n\t\t\tzfs_replay_xvattr(lrattr, &xva);\n\t\t}\n\t\tvsec.vsa_mask = VSA_ACE | VSA_ACE_ACLFLAGS;\n\t\tvsec.vsa_aclentp = (caddr_t)(lracl + 1) + xvatlen;\n\t\tvsec.vsa_aclcnt = lracl->lr_aclcnt;\n\t\tvsec.vsa_aclentsz = lracl->lr_acl_bytes;\n\t\tvsec.vsa_aclflags = lracl->lr_acl_flags;\n\t\tif (zfsvfs->z_fuid_replay == NULL) {\n\t\t\tfuidstart = (caddr_t)(lracl + 1) + xvatlen +\n\t\t\t    ZIL_ACE_LENGTH(lracl->lr_acl_bytes);\n\t\t\tzfsvfs->z_fuid_replay =\n\t\t\t    zfs_replay_fuids(fuidstart,\n\t\t\t    (void *)&name, lracl->lr_fuidcnt, lracl->lr_domcnt,\n\t\t\t    lr->lr_uid, lr->lr_gid);\n\t\t}\n\n#if defined(__linux__)\n\t\terror = zfs_create(dzp, name, &xva.xva_vattr,\n\t\t    0, 0, &zp, kcred, vflg, &vsec, zfs_init_idmap);\n#else\n\t\terror = zfs_create(dzp, name, &xva.xva_vattr,\n\t\t    0, 0, &zp, kcred, vflg, &vsec, NULL);\n#endif\n\t\tbreak;\n\tcase TX_MKDIR_ACL:\n\t\taclstart = (caddr_t)(lracl + 1);\n\t\tfuidstart = (caddr_t)aclstart +\n\t\t    ZIL_ACE_LENGTH(lracl->lr_acl_bytes);\n\t\tzfsvfs->z_fuid_replay = zfs_replay_fuids(fuidstart,\n\t\t    (void *)&name, lracl->lr_fuidcnt, lracl->lr_domcnt,\n\t\t    lr->lr_uid, lr->lr_gid);\n\t\tzfs_fallthrough;\n\tcase TX_MKDIR_ACL_ATTR:\n\t\tif (name == NULL) {\n\t\t\tlrattr = (lr_attr_t *)(caddr_t)(lracl + 1);\n\t\t\txvatlen = ZIL_XVAT_SIZE(lrattr->lr_attr_masksize);\n\t\t\tzfs_replay_xvattr(lrattr, &xva);\n\t\t}\n\t\tvsec.vsa_mask = VSA_ACE | VSA_ACE_ACLFLAGS;\n\t\tvsec.vsa_aclentp = (caddr_t)(lracl + 1) + xvatlen;\n\t\tvsec.vsa_aclcnt = lracl->lr_aclcnt;\n\t\tvsec.vsa_aclentsz = lracl->lr_acl_bytes;\n\t\tvsec.vsa_aclflags = lracl->lr_acl_flags;\n\t\tif (zfsvfs->z_fuid_replay == NULL) {\n\t\t\tfuidstart = (caddr_t)(lracl + 1) + xvatlen +\n\t\t\t    ZIL_ACE_LENGTH(lracl->lr_acl_bytes);\n\t\t\tzfsvfs->z_fuid_replay =\n\t\t\t    zfs_replay_fuids(fuidstart,\n\t\t\t    (void *)&name, lracl->lr_fuidcnt, lracl->lr_domcnt,\n\t\t\t    lr->lr_uid, lr->lr_gid);\n\t\t}\n#if defined(__linux__)\n\t\terror = zfs_mkdir(dzp, name, &xva.xva_vattr,\n\t\t    &zp, kcred, vflg, &vsec, zfs_init_idmap);\n#else\n\t\terror = zfs_mkdir(dzp, name, &xva.xva_vattr,\n\t\t    &zp, kcred, vflg, &vsec, NULL);\n#endif\n\t\tbreak;\n\tdefault:\n\t\terror = SET_ERROR(ENOTSUP);\n\t}\n\nbail:\n\tif (error == 0 && zp != NULL) {\n#ifdef __FreeBSD__\n\t\tVOP_UNLOCK1(ZTOV(zp));\n#endif\n\t\tzrele(zp);\n\t}\n\tzrele(dzp);\n\n\tif (zfsvfs->z_fuid_replay)\n\t\tzfs_fuid_info_free(zfsvfs->z_fuid_replay);\n\tzfsvfs->z_fuid_replay = NULL;\n\n\treturn (error);\n}\n\nstatic int\nzfs_replay_create(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_create_t *lr = arg2;\n\tchar *name = NULL;\t\t \n\tchar *link;\t\t\t \n\tznode_t *dzp;\n\tznode_t *zp = NULL;\n\txvattr_t xva;\n\tint vflg = 0;\n\tsize_t lrsize = sizeof (lr_create_t);\n\tlr_attr_t *lrattr;\n\tvoid *start;\n\tsize_t xvatlen;\n\tuint64_t txtype;\n\tuint64_t objid;\n\tuint64_t dnodesize;\n\tint error;\n\n\ttxtype = (lr->lr_common.lrc_txtype & ~TX_CI);\n\tif (byteswap) {\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\t\tif (txtype == TX_CREATE_ATTR || txtype == TX_MKDIR_ATTR)\n\t\t\tzfs_replay_swap_attrs((lr_attr_t *)(lr + 1));\n\t}\n\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_doid, &dzp)) != 0)\n\t\treturn (error);\n\n\tobjid = LR_FOID_GET_OBJ(lr->lr_foid);\n\tdnodesize = LR_FOID_GET_SLOTS(lr->lr_foid) << DNODE_SHIFT;\n\n\txva_init(&xva);\n\tzfs_init_vattr(&xva.xva_vattr, ATTR_MODE | ATTR_UID | ATTR_GID,\n\t    lr->lr_mode, lr->lr_uid, lr->lr_gid, lr->lr_rdev, objid);\n\n\t \n\tZFS_TIME_DECODE(&xva.xva_vattr.va_ctime, lr->lr_crtime);\n\txva.xva_vattr.va_nblocks = lr->lr_gen;\n\txva.xva_vattr.va_fsid = dnodesize;\n\n\terror = dnode_try_claim(zfsvfs->z_os, objid, dnodesize >> DNODE_SHIFT);\n\tif (error)\n\t\tgoto out;\n\n\tif (lr->lr_common.lrc_txtype & TX_CI)\n\t\tvflg |= FIGNORECASE;\n\n\t \n\tif (txtype != TX_SYMLINK &&\n\t    txtype != TX_MKDIR_ATTR &&\n\t    txtype != TX_CREATE_ATTR) {\n\t\tstart = (lr + 1);\n\t\tzfsvfs->z_fuid_replay =\n\t\t    zfs_replay_fuid_domain(start, &start,\n\t\t    lr->lr_uid, lr->lr_gid);\n\t}\n\n\tswitch (txtype) {\n\tcase TX_CREATE_ATTR:\n\t\tlrattr = (lr_attr_t *)(caddr_t)(lr + 1);\n\t\txvatlen = ZIL_XVAT_SIZE(lrattr->lr_attr_masksize);\n\t\tzfs_replay_xvattr((lr_attr_t *)((caddr_t)lr + lrsize), &xva);\n\t\tstart = (caddr_t)(lr + 1) + xvatlen;\n\t\tzfsvfs->z_fuid_replay =\n\t\t    zfs_replay_fuid_domain(start, &start,\n\t\t    lr->lr_uid, lr->lr_gid);\n\t\tname = (char *)start;\n\t\tzfs_fallthrough;\n\n\tcase TX_CREATE:\n\t\tif (name == NULL)\n\t\t\tname = (char *)start;\n\n#if defined(__linux__)\n\t\terror = zfs_create(dzp, name, &xva.xva_vattr,\n\t\t    0, 0, &zp, kcred, vflg, NULL, zfs_init_idmap);\n#else\n\t\terror = zfs_create(dzp, name, &xva.xva_vattr,\n\t\t    0, 0, &zp, kcred, vflg, NULL, NULL);\n#endif\n\t\tbreak;\n\tcase TX_MKDIR_ATTR:\n\t\tlrattr = (lr_attr_t *)(caddr_t)(lr + 1);\n\t\txvatlen = ZIL_XVAT_SIZE(lrattr->lr_attr_masksize);\n\t\tzfs_replay_xvattr((lr_attr_t *)((caddr_t)lr + lrsize), &xva);\n\t\tstart = (caddr_t)(lr + 1) + xvatlen;\n\t\tzfsvfs->z_fuid_replay =\n\t\t    zfs_replay_fuid_domain(start, &start,\n\t\t    lr->lr_uid, lr->lr_gid);\n\t\tname = (char *)start;\n\t\tzfs_fallthrough;\n\n\tcase TX_MKDIR:\n\t\tif (name == NULL)\n\t\t\tname = (char *)(lr + 1);\n\n#if defined(__linux__)\n\t\terror = zfs_mkdir(dzp, name, &xva.xva_vattr,\n\t\t    &zp, kcred, vflg, NULL, zfs_init_idmap);\n#else\n\t\terror = zfs_mkdir(dzp, name, &xva.xva_vattr,\n\t\t    &zp, kcred, vflg, NULL, NULL);\n#endif\n\n\t\tbreak;\n\tcase TX_MKXATTR:\n\t\terror = zfs_make_xattrdir(dzp, &xva.xva_vattr, &zp, kcred);\n\t\tbreak;\n\tcase TX_SYMLINK:\n\t\tname = (char *)(lr + 1);\n\t\tlink = name + strlen(name) + 1;\n#if defined(__linux__)\n\t\terror = zfs_symlink(dzp, name, &xva.xva_vattr,\n\t\t    link, &zp, kcred, vflg, zfs_init_idmap);\n#else\n\t\terror = zfs_symlink(dzp, name, &xva.xva_vattr,\n\t\t    link, &zp, kcred, vflg, NULL);\n#endif\n\t\tbreak;\n\tdefault:\n\t\terror = SET_ERROR(ENOTSUP);\n\t}\n\nout:\n\tif (error == 0 && zp != NULL) {\n#ifdef __FreeBSD__\n\t\tVOP_UNLOCK1(ZTOV(zp));\n#endif\n\t\tzrele(zp);\n\t}\n\tzrele(dzp);\n\n\tif (zfsvfs->z_fuid_replay)\n\t\tzfs_fuid_info_free(zfsvfs->z_fuid_replay);\n\tzfsvfs->z_fuid_replay = NULL;\n\treturn (error);\n}\n\nstatic int\nzfs_replay_remove(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_remove_t *lr = arg2;\n\tchar *name = (char *)(lr + 1);\t \n\tznode_t *dzp;\n\tint error;\n\tint vflg = 0;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_doid, &dzp)) != 0)\n\t\treturn (error);\n\n\tif (lr->lr_common.lrc_txtype & TX_CI)\n\t\tvflg |= FIGNORECASE;\n\n\tswitch ((int)lr->lr_common.lrc_txtype) {\n\tcase TX_REMOVE:\n\t\terror = zfs_remove(dzp, name, kcred, vflg);\n\t\tbreak;\n\tcase TX_RMDIR:\n\t\terror = zfs_rmdir(dzp, name, NULL, kcred, vflg);\n\t\tbreak;\n\tdefault:\n\t\terror = SET_ERROR(ENOTSUP);\n\t}\n\n\tzrele(dzp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_replay_link(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_link_t *lr = arg2;\n\tchar *name = (char *)(lr + 1);\t \n\tznode_t *dzp, *zp;\n\tint error;\n\tint vflg = 0;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_doid, &dzp)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_link_obj, &zp)) != 0) {\n\t\tzrele(dzp);\n\t\treturn (error);\n\t}\n\n\tif (lr->lr_common.lrc_txtype & TX_CI)\n\t\tvflg |= FIGNORECASE;\n\n\terror = zfs_link(dzp, zp, name, kcred, vflg);\n\tzrele(zp);\n\tzrele(dzp);\n\n\treturn (error);\n}\n\nstatic int\ndo_zfs_replay_rename(zfsvfs_t *zfsvfs, lr_rename_t *lr, char *sname,\n    char *tname, uint64_t rflags, vattr_t *wo_vap)\n{\n\tznode_t *sdzp, *tdzp;\n\tint error, vflg = 0;\n\n\t \n#ifdef __linux__\n\tVERIFY0(rflags & ~(RENAME_EXCHANGE | RENAME_WHITEOUT));\n\n\t \n\tVERIFY_EQUIV(rflags & RENAME_WHITEOUT, wo_vap != NULL);\n#else\n\tVERIFY0(rflags);\n#endif\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_sdoid, &sdzp)) != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_tdoid, &tdzp)) != 0) {\n\t\tzrele(sdzp);\n\t\treturn (error);\n\t}\n\n\tif (lr->lr_common.lrc_txtype & TX_CI)\n\t\tvflg |= FIGNORECASE;\n\n#if defined(__linux__)\n\terror = zfs_rename(sdzp, sname, tdzp, tname, kcred, vflg, rflags,\n\t    wo_vap, zfs_init_idmap);\n#else\n\terror = zfs_rename(sdzp, sname, tdzp, tname, kcred, vflg, rflags,\n\t    wo_vap, NULL);\n#endif\n\n\tzrele(tdzp);\n\tzrele(sdzp);\n\treturn (error);\n}\n\nstatic int\nzfs_replay_rename(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_rename_t *lr = arg2;\n\tchar *sname = (char *)(lr + 1);\t \n\tchar *tname = sname + strlen(sname) + 1;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\treturn (do_zfs_replay_rename(zfsvfs, lr, sname, tname, 0, NULL));\n}\n\nstatic int\nzfs_replay_rename_exchange(void *arg1, void *arg2, boolean_t byteswap)\n{\n#ifdef __linux__\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_rename_t *lr = arg2;\n\tchar *sname = (char *)(lr + 1);\t \n\tchar *tname = sname + strlen(sname) + 1;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\treturn (do_zfs_replay_rename(zfsvfs, lr, sname, tname, RENAME_EXCHANGE,\n\t    NULL));\n#else\n\treturn (SET_ERROR(ENOTSUP));\n#endif\n}\n\nstatic int\nzfs_replay_rename_whiteout(void *arg1, void *arg2, boolean_t byteswap)\n{\n#ifdef __linux__\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_rename_whiteout_t *lr = arg2;\n\tint error;\n\t \n\tchar *sname = (char *)(lr + 1);\n\tchar *tname = sname + strlen(sname) + 1;\n\t \n\txvattr_t xva;\n\tuint64_t objid;\n\tuint64_t dnodesize;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tobjid = LR_FOID_GET_OBJ(lr->lr_wfoid);\n\tdnodesize = LR_FOID_GET_SLOTS(lr->lr_wfoid) << DNODE_SHIFT;\n\n\txva_init(&xva);\n\tzfs_init_vattr(&xva.xva_vattr, ATTR_MODE | ATTR_UID | ATTR_GID,\n\t    lr->lr_wmode, lr->lr_wuid, lr->lr_wgid, lr->lr_wrdev, objid);\n\n\t \n\tZFS_TIME_DECODE(&xva.xva_vattr.va_ctime, lr->lr_wcrtime);\n\txva.xva_vattr.va_nblocks = lr->lr_wgen;\n\txva.xva_vattr.va_fsid = dnodesize;\n\n\terror = dnode_try_claim(zfsvfs->z_os, objid, dnodesize >> DNODE_SHIFT);\n\tif (error)\n\t\treturn (error);\n\n\treturn (do_zfs_replay_rename(zfsvfs, &lr->lr_rename, sname, tname,\n\t    RENAME_WHITEOUT, &xva.xva_vattr));\n#else\n\treturn (SET_ERROR(ENOTSUP));\n#endif\n}\n\nstatic int\nzfs_replay_write(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_write_t *lr = arg2;\n\tchar *data = (char *)(lr + 1);\t \n\tznode_t\t*zp;\n\tint error;\n\tuint64_t eod, offset, length;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0) {\n\t\t \n\t\tif (error == ENOENT)\n\t\t\terror = 0;\n\t\treturn (error);\n\t}\n\n\toffset = lr->lr_offset;\n\tlength = lr->lr_length;\n\teod = offset + length;\t \n\n\t \n\n\tzfsvfs->z_replay_eof = 0;  \n\n\t \n\tif (lr->lr_common.lrc_reclen == sizeof (lr_write_t)) {\n\t\tuint64_t blocksize = BP_GET_LSIZE(&lr->lr_blkptr);\n\t\tif (length < blocksize) {\n\t\t\toffset -= offset % blocksize;\n\t\t\tlength = blocksize;\n\t\t}\n\t\tif (zp->z_size < eod)\n\t\t\tzfsvfs->z_replay_eof = eod;\n\t}\n\terror = zfs_write_simple(zp, data, length, offset, NULL);\n\tzrele(zp);\n\tzfsvfs->z_replay_eof = 0;\t \n\n\treturn (error);\n}\n\n \nstatic int\nzfs_replay_write2(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_write_t *lr = arg2;\n\tznode_t\t*zp;\n\tint error;\n\tuint64_t end;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0)\n\t\treturn (error);\n\ntop:\n\tend = lr->lr_offset + lr->lr_length;\n\tif (end > zp->z_size) {\n\t\tdmu_tx_t *tx = dmu_tx_create(zfsvfs->z_os);\n\n\t\tzp->z_size = end;\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tzrele(zp);\n\t\t\tif (error == ERESTART) {\n\t\t\t\tdmu_tx_wait(tx);\n\t\t\t\tdmu_tx_abort(tx);\n\t\t\t\tgoto top;\n\t\t\t}\n\t\t\tdmu_tx_abort(tx);\n\t\t\treturn (error);\n\t\t}\n\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_SIZE(zfsvfs),\n\t\t    (void *)&zp->z_size, sizeof (uint64_t), tx);\n\n\t\t \n\t\t(void) zil_replaying(zfsvfs->z_log, tx);\n\n\t\tdmu_tx_commit(tx);\n\t}\n\n\tzrele(zp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_replay_truncate(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_truncate_t *lr = arg2;\n\tznode_t *zp;\n\tflock64_t fl = {0};\n\tint error;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0)\n\t\treturn (error);\n\n\tfl.l_type = F_WRLCK;\n\tfl.l_whence = SEEK_SET;\n\tfl.l_start = lr->lr_offset;\n\tfl.l_len = lr->lr_length;\n\n\terror = zfs_space(zp, F_FREESP, &fl, O_RDWR | O_LARGEFILE,\n\t    lr->lr_offset, kcred);\n\n\tzrele(zp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_replay_setattr(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_setattr_t *lr = arg2;\n\tznode_t *zp;\n\txvattr_t xva;\n\tvattr_t *vap = &xva.xva_vattr;\n\tint error;\n\tvoid *start;\n\n\txva_init(&xva);\n\tif (byteswap) {\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\t\tif ((lr->lr_mask & ATTR_XVATTR) &&\n\t\t    zfsvfs->z_version >= ZPL_VERSION_INITIAL)\n\t\t\tzfs_replay_swap_attrs((lr_attr_t *)(lr + 1));\n\t}\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0)\n\t\treturn (error);\n\n\tzfs_init_vattr(vap, lr->lr_mask, lr->lr_mode,\n\t    lr->lr_uid, lr->lr_gid, 0, lr->lr_foid);\n\n\tvap->va_size = lr->lr_size;\n\tZFS_TIME_DECODE(&vap->va_atime, lr->lr_atime);\n\tZFS_TIME_DECODE(&vap->va_mtime, lr->lr_mtime);\n\tgethrestime(&vap->va_ctime);\n\tvap->va_mask |= ATTR_CTIME;\n\n\t \n\n\tstart = (lr_setattr_t *)(lr + 1);\n\tif (vap->va_mask & ATTR_XVATTR) {\n\t\tzfs_replay_xvattr((lr_attr_t *)start, &xva);\n\t\tstart = (caddr_t)start +\n\t\t    ZIL_XVAT_SIZE(((lr_attr_t *)start)->lr_attr_masksize);\n\t} else\n\t\txva.xva_vattr.va_mask &= ~ATTR_XVATTR;\n\n\tzfsvfs->z_fuid_replay = zfs_replay_fuid_domain(start, &start,\n\t    lr->lr_uid, lr->lr_gid);\n\n#if defined(__linux__)\n\terror = zfs_setattr(zp, vap, 0, kcred, zfs_init_idmap);\n#else\n\terror = zfs_setattr(zp, vap, 0, kcred, NULL);\n#endif\n\n\tzfs_fuid_info_free(zfsvfs->z_fuid_replay);\n\tzfsvfs->z_fuid_replay = NULL;\n\tzrele(zp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_replay_setsaxattr(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_setsaxattr_t *lr = arg2;\n\tznode_t *zp;\n\tnvlist_t *nvl;\n\tsize_t sa_size;\n\tchar *name;\n\tchar *value;\n\tsize_t size;\n\tint error = 0;\n\n\tASSERT(spa_feature_is_active(zfsvfs->z_os->os_spa,\n\t    SPA_FEATURE_ZILSAXATTR));\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0)\n\t\treturn (error);\n\n\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\tmutex_enter(&zp->z_lock);\n\tif (zp->z_xattr_cached == NULL)\n\t\terror = zfs_sa_get_xattr(zp);\n\tmutex_exit(&zp->z_lock);\n\n\tif (error)\n\t\tgoto out;\n\n\tASSERT(zp->z_xattr_cached);\n\tnvl = zp->z_xattr_cached;\n\n\t \n\tsize = lr->lr_size;\n\tname = (char *)(lr + 1);\n\tif (size == 0) {\n\t\tvalue = NULL;\n\t\terror = nvlist_remove(nvl, name, DATA_TYPE_BYTE_ARRAY);\n\t} else {\n\t\tvalue = name + strlen(name) + 1;\n\t\t \n\t\tif (size > DXATTR_MAX_ENTRY_SIZE) {\n\t\t\terror = SET_ERROR(EFBIG);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terror = nvlist_size(nvl, &sa_size, NV_ENCODE_XDR);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (sa_size > DXATTR_MAX_SA_SIZE) {\n\t\t\terror = SET_ERROR(EFBIG);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = nvlist_add_byte_array(nvl, name, (uchar_t *)value,\n\t\t    size);\n\t}\n\n\t \n\tif (error == 0)\n\t\terror = zfs_sa_set_xattr(zp, name, value, size);\n\n\tif (error) {\n\t\tnvlist_free(nvl);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\nout:\n\trw_exit(&zp->z_xattr_lock);\n\tzrele(zp);\n\treturn (error);\n}\n\nstatic int\nzfs_replay_acl_v0(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_acl_v0_t *lr = arg2;\n\tace_t *ace = (ace_t *)(lr + 1);\t \n\tvsecattr_t vsa = {0};\n\tznode_t *zp;\n\tint error;\n\n\tif (byteswap) {\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\t\tzfs_oldace_byteswap(ace, lr->lr_aclcnt);\n\t}\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0)\n\t\treturn (error);\n\n\tvsa.vsa_mask = VSA_ACE | VSA_ACECNT;\n\tvsa.vsa_aclcnt = lr->lr_aclcnt;\n\tvsa.vsa_aclentsz = sizeof (ace_t) * vsa.vsa_aclcnt;\n\tvsa.vsa_aclflags = 0;\n\tvsa.vsa_aclentp = ace;\n\n\terror = zfs_setsecattr(zp, &vsa, 0, kcred);\n\n\tzrele(zp);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_replay_acl(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_acl_t *lr = arg2;\n\tace_t *ace = (ace_t *)(lr + 1);\n\tvsecattr_t vsa = {0};\n\tznode_t *zp;\n\tint error;\n\n\tif (byteswap) {\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\t\tzfs_ace_byteswap(ace, lr->lr_acl_bytes, B_FALSE);\n\t\tif (lr->lr_fuidcnt) {\n\t\t\tbyteswap_uint64_array((caddr_t)ace +\n\t\t\t    ZIL_ACE_LENGTH(lr->lr_acl_bytes),\n\t\t\t    lr->lr_fuidcnt * sizeof (uint64_t));\n\t\t}\n\t}\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0)\n\t\treturn (error);\n\n\tvsa.vsa_mask = VSA_ACE | VSA_ACECNT | VSA_ACE_ACLFLAGS;\n\tvsa.vsa_aclcnt = lr->lr_aclcnt;\n\tvsa.vsa_aclentp = ace;\n\tvsa.vsa_aclentsz = lr->lr_acl_bytes;\n\tvsa.vsa_aclflags = lr->lr_acl_flags;\n\n\tif (lr->lr_fuidcnt) {\n\t\tvoid *fuidstart = (caddr_t)ace +\n\t\t    ZIL_ACE_LENGTH(lr->lr_acl_bytes);\n\n\t\tzfsvfs->z_fuid_replay =\n\t\t    zfs_replay_fuids(fuidstart, &fuidstart,\n\t\t    lr->lr_fuidcnt, lr->lr_domcnt, 0, 0);\n\t}\n\n\terror = zfs_setsecattr(zp, &vsa, 0, kcred);\n\n\tif (zfsvfs->z_fuid_replay)\n\t\tzfs_fuid_info_free(zfsvfs->z_fuid_replay);\n\n\tzfsvfs->z_fuid_replay = NULL;\n\tzrele(zp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_replay_clone_range(void *arg1, void *arg2, boolean_t byteswap)\n{\n\tzfsvfs_t *zfsvfs = arg1;\n\tlr_clone_range_t *lr = arg2;\n\tznode_t *zp;\n\tint error;\n\n\tif (byteswap)\n\t\tbyteswap_uint64_array(lr, sizeof (*lr));\n\n\tif ((error = zfs_zget(zfsvfs, lr->lr_foid, &zp)) != 0) {\n\t\t \n\t\tif (error == ENOENT)\n\t\t\terror = 0;\n\t\treturn (error);\n\t}\n\n\terror = zfs_clone_range_replay(zp, lr->lr_offset, lr->lr_length,\n\t    lr->lr_blksz, lr->lr_bps, lr->lr_nbps);\n\n\tzrele(zp);\n\treturn (error);\n}\n\n \nzil_replay_func_t *const zfs_replay_vector[TX_MAX_TYPE] = {\n\tzfs_replay_error,\t \n\tzfs_replay_create,\t \n\tzfs_replay_create,\t \n\tzfs_replay_create,\t \n\tzfs_replay_create,\t \n\tzfs_replay_remove,\t \n\tzfs_replay_remove,\t \n\tzfs_replay_link,\t \n\tzfs_replay_rename,\t \n\tzfs_replay_write,\t \n\tzfs_replay_truncate,\t \n\tzfs_replay_setattr,\t \n\tzfs_replay_acl_v0,\t \n\tzfs_replay_acl,\t\t \n\tzfs_replay_create_acl,\t \n\tzfs_replay_create,\t \n\tzfs_replay_create_acl,\t \n\tzfs_replay_create_acl,\t \n\tzfs_replay_create,\t \n\tzfs_replay_create_acl,\t \n\tzfs_replay_write2,\t \n\tzfs_replay_setsaxattr,\t \n\tzfs_replay_rename_exchange,\t \n\tzfs_replay_rename_whiteout,\t \n\tzfs_replay_clone_range,\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}