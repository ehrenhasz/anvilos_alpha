{
  "module_name": "bptree.c",
  "hash_id": "d22280332105c94fca87f18dfea0fa21c435c907d7f55dda75b1124145369a90",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/bptree.c",
  "human_readable_source": " \n\n \n\n#include <sys/arc.h>\n#include <sys/bptree.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dnode.h>\n#include <sys/spa.h>\n\n \n\nstruct bptree_args {\n\tbptree_phys_t *ba_phys;\t \n\tboolean_t ba_free;\t \n\n\tbptree_itor_t *ba_func;\t \n\tvoid *ba_arg;\t\t \n\tdmu_tx_t *ba_tx;\t \n} bptree_args_t;\n\nuint64_t\nbptree_alloc(objset_t *os, dmu_tx_t *tx)\n{\n\tuint64_t obj;\n\tdmu_buf_t *db;\n\tbptree_phys_t *bt;\n\n\tobj = dmu_object_alloc(os, DMU_OTN_UINT64_METADATA,\n\t    SPA_OLD_MAXBLOCKSIZE, DMU_OTN_UINT64_METADATA,\n\t    sizeof (bptree_phys_t), tx);\n\n\t \n\tVERIFY3U(0, ==, dmu_bonus_hold(os, obj, FTAG, &db));\n\tdmu_buf_will_dirty(db, tx);\n\tbt = db->db_data;\n\tbt->bt_begin = 0;\n\tbt->bt_end = 0;\n\tbt->bt_bytes = 0;\n\tbt->bt_comp = 0;\n\tbt->bt_uncomp = 0;\n\tdmu_buf_rele(db, FTAG);\n\n\treturn (obj);\n}\n\nint\nbptree_free(objset_t *os, uint64_t obj, dmu_tx_t *tx)\n{\n\tdmu_buf_t *db;\n\tbptree_phys_t *bt;\n\n\tVERIFY3U(0, ==, dmu_bonus_hold(os, obj, FTAG, &db));\n\tbt = db->db_data;\n\tASSERT3U(bt->bt_begin, ==, bt->bt_end);\n\tASSERT0(bt->bt_bytes);\n\tASSERT0(bt->bt_comp);\n\tASSERT0(bt->bt_uncomp);\n\tdmu_buf_rele(db, FTAG);\n\n\treturn (dmu_object_free(os, obj, tx));\n}\n\nboolean_t\nbptree_is_empty(objset_t *os, uint64_t obj)\n{\n\tdmu_buf_t *db;\n\tbptree_phys_t *bt;\n\tboolean_t rv;\n\n\tVERIFY0(dmu_bonus_hold(os, obj, FTAG, &db));\n\tbt = db->db_data;\n\trv = (bt->bt_begin == bt->bt_end);\n\tdmu_buf_rele(db, FTAG);\n\treturn (rv);\n}\n\nvoid\nbptree_add(objset_t *os, uint64_t obj, blkptr_t *bp, uint64_t birth_txg,\n    uint64_t bytes, uint64_t comp, uint64_t uncomp, dmu_tx_t *tx)\n{\n\tdmu_buf_t *db;\n\tbptree_phys_t *bt;\n\tbptree_entry_phys_t *bte;\n\n\t \n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tVERIFY3U(0, ==, dmu_bonus_hold(os, obj, FTAG, &db));\n\tbt = db->db_data;\n\n\tbte = kmem_zalloc(sizeof (*bte), KM_SLEEP);\n\tbte->be_birth_txg = birth_txg;\n\tbte->be_bp = *bp;\n\tdmu_write(os, obj, bt->bt_end * sizeof (*bte), sizeof (*bte), bte, tx);\n\tkmem_free(bte, sizeof (*bte));\n\n\tdmu_buf_will_dirty(db, tx);\n\tbt->bt_end++;\n\tbt->bt_bytes += bytes;\n\tbt->bt_comp += comp;\n\tbt->bt_uncomp += uncomp;\n\tdmu_buf_rele(db, FTAG);\n}\n\nstatic int\nbptree_visit_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)\n{\n\t(void) zilog, (void) dnp;\n\tint err;\n\tstruct bptree_args *ba = arg;\n\n\tif (zb->zb_level == ZB_DNODE_LEVEL || BP_IS_HOLE(bp) ||\n\t    BP_IS_REDACTED(bp))\n\t\treturn (0);\n\n\terr = ba->ba_func(ba->ba_arg, bp, ba->ba_tx);\n\tif (err == 0 && ba->ba_free) {\n\t\tba->ba_phys->bt_bytes -= bp_get_dsize_sync(spa, bp);\n\t\tba->ba_phys->bt_comp -= BP_GET_PSIZE(bp);\n\t\tba->ba_phys->bt_uncomp -= BP_GET_UCSIZE(bp);\n\t}\n\treturn (err);\n}\n\n \nint\nbptree_iterate(objset_t *os, uint64_t obj, boolean_t free, bptree_itor_t func,\n    void *arg, dmu_tx_t *tx)\n{\n\tboolean_t ioerr = B_FALSE;\n\tint err;\n\tuint64_t i;\n\tdmu_buf_t *db;\n\tstruct bptree_args ba;\n\n\tASSERT(!free || dmu_tx_is_syncing(tx));\n\n\terr = dmu_bonus_hold(os, obj, FTAG, &db);\n\tif (err != 0)\n\t\treturn (err);\n\n\tif (free)\n\t\tdmu_buf_will_dirty(db, tx);\n\n\tba.ba_phys = db->db_data;\n\tba.ba_free = free;\n\tba.ba_func = func;\n\tba.ba_arg = arg;\n\tba.ba_tx = tx;\n\n\terr = 0;\n\tfor (i = ba.ba_phys->bt_begin; i < ba.ba_phys->bt_end; i++) {\n\t\tbptree_entry_phys_t bte;\n\t\tint flags = TRAVERSE_PREFETCH_METADATA | TRAVERSE_POST |\n\t\t    TRAVERSE_NO_DECRYPT;\n\n\t\terr = dmu_read(os, obj, i * sizeof (bte), sizeof (bte),\n\t\t    &bte, DMU_READ_NO_PREFETCH);\n\t\tif (err != 0)\n\t\t\tbreak;\n\n\t\tif (zfs_free_leak_on_eio)\n\t\t\tflags |= TRAVERSE_HARD;\n\t\tzfs_dbgmsg(\"bptree index %lld: traversing from min_txg=%lld \"\n\t\t    \"bookmark %lld/%lld/%lld/%lld\",\n\t\t    (longlong_t)i,\n\t\t    (longlong_t)bte.be_birth_txg,\n\t\t    (longlong_t)bte.be_zb.zb_objset,\n\t\t    (longlong_t)bte.be_zb.zb_object,\n\t\t    (longlong_t)bte.be_zb.zb_level,\n\t\t    (longlong_t)bte.be_zb.zb_blkid);\n\t\terr = traverse_dataset_destroyed(os->os_spa, &bte.be_bp,\n\t\t    bte.be_birth_txg, &bte.be_zb, flags,\n\t\t    bptree_visit_cb, &ba);\n\t\tif (free) {\n\t\t\t \n\t\t\tif (err != 0) {\n\t\t\t\t \n\t\t\t\tASSERT3U(bte.be_zb.zb_objset, ==,\n\t\t\t\t    ZB_DESTROYED_OBJSET);\n\t\t\t\tASSERT0(bte.be_zb.zb_level);\n\t\t\t\tdmu_write(os, obj, i * sizeof (bte),\n\t\t\t\t    sizeof (bte), &bte, tx);\n\t\t\t\tif (err == EIO || err == ECKSUM ||\n\t\t\t\t    err == ENXIO) {\n\t\t\t\t\t \n\t\t\t\t\terr = 0;\n\t\t\t\t\tioerr = B_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (ioerr) {\n\t\t\t\t \n\t\t\t\tbte.be_birth_txg = UINT64_MAX;\n\t\t\t\tdmu_write(os, obj, i * sizeof (bte),\n\t\t\t\t    sizeof (bte), &bte, tx);\n\t\t\t}\n\n\t\t\tif (!ioerr) {\n\t\t\t\tba.ba_phys->bt_begin++;\n\t\t\t\t(void) dmu_free_range(os, obj,\n\t\t\t\t    i * sizeof (bte), sizeof (bte), tx);\n\t\t\t}\n\t\t} else if (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tASSERT(!free || err != 0 || ioerr ||\n\t    ba.ba_phys->bt_begin == ba.ba_phys->bt_end);\n\n\t \n\tif (ba.ba_phys->bt_begin == ba.ba_phys->bt_end) {\n\t\tif (zfs_free_leak_on_eio) {\n\t\t\tba.ba_phys->bt_bytes = 0;\n\t\t\tba.ba_phys->bt_comp = 0;\n\t\t\tba.ba_phys->bt_uncomp = 0;\n\t\t}\n\n\t\tASSERT0(ba.ba_phys->bt_bytes);\n\t\tASSERT0(ba.ba_phys->bt_comp);\n\t\tASSERT0(ba.ba_phys->bt_uncomp);\n\t}\n\n\tdmu_buf_rele(db, FTAG);\n\n\treturn (err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}