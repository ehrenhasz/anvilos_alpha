{
  "module_name": "zfs_vnops.c",
  "hash_id": "bd8a3634aa112fdee5533c122242e8be203a16c7a855ac76e449f4f5f9ad7121",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_vnops.c",
  "human_readable_source": " \n\n \n\n \n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/sysmacros.h>\n#include <sys/vfs.h>\n#include <sys/uio_impl.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/kmem.h>\n#include <sys/cmn_err.h>\n#include <sys/errno.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/fs/zfs.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/spa.h>\n#include <sys/txg.h>\n#include <sys/dbuf.h>\n#include <sys/policy.h>\n#include <sys/zfeature.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_quota.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n\n\nstatic ulong_t zfs_fsync_sync_cnt = 4;\n\nint\nzfs_fsync(znode_t *zp, int syncflag, cred_t *cr)\n{\n\tint error = 0;\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\n\t(void) tsd_set(zfs_fsyncer_key, (void *)(uintptr_t)zfs_fsync_sync_cnt);\n\n\tif (zfsvfs->z_os->os_sync != ZFS_SYNC_DISABLED) {\n\t\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\t\tgoto out;\n\t\tatomic_inc_32(&zp->z_sync_writes_cnt);\n\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\t\tatomic_dec_32(&zp->z_sync_writes_cnt);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t}\nout:\n\ttsd_set(zfs_fsyncer_key, NULL);\n\n\treturn (error);\n}\n\n\n#if defined(SEEK_HOLE) && defined(SEEK_DATA)\n \nstatic int\nzfs_holey_common(znode_t *zp, ulong_t cmd, loff_t *off)\n{\n\tzfs_locked_range_t *lr;\n\tuint64_t noff = (uint64_t)*off;  \n\tuint64_t file_sz;\n\tint error;\n\tboolean_t hole;\n\n\tfile_sz = zp->z_size;\n\tif (noff >= file_sz)  {\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\tif (cmd == F_SEEK_HOLE)\n\t\thole = B_TRUE;\n\telse\n\t\thole = B_FALSE;\n\n\t \n\tif (zn_has_cached_data(zp, 0, file_sz - 1))\n\t\tzn_flush_cached_data(zp, B_FALSE);\n\n\tlr = zfs_rangelock_enter(&zp->z_rangelock, 0, UINT64_MAX, RL_READER);\n\terror = dmu_offset_next(ZTOZSB(zp)->z_os, zp->z_id, hole, &noff);\n\tzfs_rangelock_exit(lr);\n\n\tif (error == ESRCH)\n\t\treturn (SET_ERROR(ENXIO));\n\n\t \n\tif (error == EBUSY) {\n\t\tif (hole)\n\t\t\t*off = file_sz;\n\n\t\treturn (0);\n\t}\n\n\t \n\tif (noff > file_sz) {\n\t\tASSERT(hole);\n\t\tnoff = file_sz;\n\t}\n\n\tif (noff < *off)\n\t\treturn (error);\n\t*off = noff;\n\treturn (error);\n}\n\nint\nzfs_holey(znode_t *zp, ulong_t cmd, loff_t *off)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = zfs_holey_common(zp, cmd, off);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n#endif  \n\nint\nzfs_access(znode_t *zp, int mode, int flag, cred_t *cr)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (flag & V_ACE_MASK)\n#if defined(__linux__)\n\t\terror = zfs_zaccess(zp, mode, flag, B_FALSE, cr,\n\t\t    zfs_init_idmap);\n#else\n\t\terror = zfs_zaccess(zp, mode, flag, B_FALSE, cr,\n\t\t    NULL);\n#endif\n\telse\n#if defined(__linux__)\n\t\terror = zfs_zaccess_rwx(zp, mode, flag, cr, zfs_init_idmap);\n#else\n\t\terror = zfs_zaccess_rwx(zp, mode, flag, cr, NULL);\n#endif\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nstatic uint64_t zfs_vnops_read_chunk_size = 1024 * 1024;  \n\n \nint\nzfs_read(struct znode *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)\n{\n\t(void) cr;\n\tint error = 0;\n\tboolean_t frsync = B_FALSE;\n\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zp->z_pflags & ZFS_AV_QUARANTINED) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EACCES));\n\t}\n\n\t \n\tif (Z_ISDIR(ZTOTYPE(zp))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EISDIR));\n\t}\n\n\t \n\tif (zfs_uio_offset(uio) < (offset_t)0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (zfs_uio_resid(uio) == 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n#ifdef FRSYNC\n\t \n\tfrsync = !!(ioflag & FRSYNC);\n#endif\n\tif (zfsvfs->z_log &&\n\t    (frsync || zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS))\n\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\n\t \n\tzfs_locked_range_t *lr = zfs_rangelock_enter(&zp->z_rangelock,\n\t    zfs_uio_offset(uio), zfs_uio_resid(uio), RL_READER);\n\n\t \n\tif (zfs_uio_offset(uio) >= zp->z_size) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tASSERT(zfs_uio_offset(uio) < zp->z_size);\n#if defined(__linux__)\n\tssize_t start_offset = zfs_uio_offset(uio);\n#endif\n\tssize_t n = MIN(zfs_uio_resid(uio), zp->z_size - zfs_uio_offset(uio));\n\tssize_t start_resid = n;\n\n\twhile (n > 0) {\n\t\tssize_t nbytes = MIN(n, zfs_vnops_read_chunk_size -\n\t\t    P2PHASE(zfs_uio_offset(uio), zfs_vnops_read_chunk_size));\n#ifdef UIO_NOCOPY\n\t\tif (zfs_uio_segflg(uio) == UIO_NOCOPY)\n\t\t\terror = mappedread_sf(zp, nbytes, uio);\n\t\telse\n#endif\n\t\tif (zn_has_cached_data(zp, zfs_uio_offset(uio),\n\t\t    zfs_uio_offset(uio) + nbytes - 1) && !(ioflag & O_DIRECT)) {\n\t\t\terror = mappedread(zp, nbytes, uio);\n\t\t} else {\n\t\t\terror = dmu_read_uio_dbuf(sa_get_db(zp->z_sa_hdl),\n\t\t\t    uio, nbytes);\n\t\t}\n\n\t\tif (error) {\n\t\t\t \n\t\t\tif (error == ECKSUM)\n\t\t\t\terror = SET_ERROR(EIO);\n\n#if defined(__linux__)\n\t\t\t \n\t\t\tif (error == EFAULT &&\n\t\t\t    (zfs_uio_offset(uio) - start_offset) != 0)\n\t\t\t\terror = 0;\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\tn -= nbytes;\n\t}\n\n\tint64_t nread = start_resid - n;\n\tdataset_kstats_update_read_kstats(&zfsvfs->z_kstat, nread);\n\ttask_io_account_read(nread);\nout:\n\tzfs_rangelock_exit(lr);\n\n\tZFS_ACCESSTIME_STAMP(zfsvfs, zp);\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nstatic void\nzfs_clear_setid_bits_if_necessary(zfsvfs_t *zfsvfs, znode_t *zp, cred_t *cr,\n    uint64_t *clear_setid_bits_txgp, dmu_tx_t *tx)\n{\n\tzilog_t *zilog = zfsvfs->z_log;\n\tconst uint64_t uid = KUID_TO_SUID(ZTOUID(zp));\n\n\tASSERT(clear_setid_bits_txgp != NULL);\n\tASSERT(tx != NULL);\n\n\t \n\tmutex_enter(&zp->z_acl_lock);\n\tif ((zp->z_mode & (S_IXUSR | (S_IXUSR >> 3) | (S_IXUSR >> 6))) != 0 &&\n\t    (zp->z_mode & (S_ISUID | S_ISGID)) != 0 &&\n\t    secpolicy_vnode_setid_retain(zp, cr,\n\t    ((zp->z_mode & S_ISUID) != 0 && uid == 0)) != 0) {\n\t\tuint64_t newmode;\n\n\t\tzp->z_mode &= ~(S_ISUID | S_ISGID);\n\t\tnewmode = zp->z_mode;\n\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_MODE(zfsvfs),\n\t\t    (void *)&newmode, sizeof (uint64_t), tx);\n\n\t\tmutex_exit(&zp->z_acl_lock);\n\n\t\t \n\t\tif (*clear_setid_bits_txgp != dmu_tx_get_txg(tx)) {\n\t\t\tvattr_t va = {0};\n\n\t\t\tva.va_mask = ATTR_MODE;\n\t\t\tva.va_nodeid = zp->z_id;\n\t\t\tva.va_mode = newmode;\n\t\t\tzfs_log_setattr(zilog, tx, TX_SETATTR, zp, &va,\n\t\t\t    ATTR_MODE, NULL);\n\t\t\t*clear_setid_bits_txgp = dmu_tx_get_txg(tx);\n\t\t}\n\t} else {\n\t\tmutex_exit(&zp->z_acl_lock);\n\t}\n}\n\n \nint\nzfs_write(znode_t *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)\n{\n\tint error = 0, error1;\n\tssize_t start_resid = zfs_uio_resid(uio);\n\tuint64_t clear_setid_bits_txg = 0;\n\n\t \n\tssize_t n = start_resid;\n\tif (n == 0)\n\t\treturn (0);\n\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tsa_bulk_attr_t bulk[4];\n\tint count = 0;\n\tuint64_t mtime[2], ctime[2];\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, 8);\n\n\t \n\tif (zfs_is_readonly(zfsvfs)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\tif ((zp->z_pflags & ZFS_IMMUTABLE) ||\n\t    ((zp->z_pflags & ZFS_APPENDONLY) && !(ioflag & O_APPEND) &&\n\t    (zfs_uio_offset(uio) < zp->z_size))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\toffset_t woff = ioflag & O_APPEND ? zp->z_size : zfs_uio_offset(uio);\n\tif (woff < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tssize_t pfbytes = MIN(n, DMU_MAX_ACCESS >> 1);\n\tif (zfs_uio_prefaultpages(pfbytes, uio)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EFAULT));\n\t}\n\n\t \n\tzfs_locked_range_t *lr;\n\tif (ioflag & O_APPEND) {\n\t\t \n\t\tlr = zfs_rangelock_enter(&zp->z_rangelock, 0, n, RL_APPEND);\n\t\twoff = lr->lr_offset;\n\t\tif (lr->lr_length == UINT64_MAX) {\n\t\t\t \n\t\t\twoff = zp->z_size;\n\t\t}\n\t\tzfs_uio_setoffset(uio, woff);\n\t} else {\n\t\t \n\t\tlr = zfs_rangelock_enter(&zp->z_rangelock, woff, n, RL_WRITER);\n\t}\n\n\tif (zn_rlimit_fsize_uio(zp, uio)) {\n\t\tzfs_rangelock_exit(lr);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EFBIG));\n\t}\n\n\tconst rlim64_t limit = MAXOFFSET_T;\n\n\tif (woff >= limit) {\n\t\tzfs_rangelock_exit(lr);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EFBIG));\n\t}\n\n\tif (n > limit - woff)\n\t\tn = limit - woff;\n\n\tuint64_t end_size = MAX(zp->z_size, woff + n);\n\tzilog_t *zilog = zfsvfs->z_log;\n\n\tconst uint64_t uid = KUID_TO_SUID(ZTOUID(zp));\n\tconst uint64_t gid = KGID_TO_SGID(ZTOGID(zp));\n\tconst uint64_t projid = zp->z_projid;\n\n\t \n\twhile (n > 0) {\n\t\twoff = zfs_uio_offset(uio);\n\n\t\tif (zfs_id_overblockquota(zfsvfs, DMU_USERUSED_OBJECT, uid) ||\n\t\t    zfs_id_overblockquota(zfsvfs, DMU_GROUPUSED_OBJECT, gid) ||\n\t\t    (projid != ZFS_DEFAULT_PROJID &&\n\t\t    zfs_id_overblockquota(zfsvfs, DMU_PROJECTUSED_OBJECT,\n\t\t    projid))) {\n\t\t\terror = SET_ERROR(EDQUOT);\n\t\t\tbreak;\n\t\t}\n\n\t\tuint64_t blksz;\n\t\tif (lr->lr_length == UINT64_MAX && zp->z_size <= zp->z_blksz) {\n\t\t\tif (zp->z_blksz > zfsvfs->z_max_blksz &&\n\t\t\t    !ISP2(zp->z_blksz)) {\n\t\t\t\t \n\t\t\t\tblksz = 1 << highbit64(zp->z_blksz);\n\t\t\t} else {\n\t\t\t\tblksz = zfsvfs->z_max_blksz;\n\t\t\t}\n\t\t\tblksz = MIN(blksz, P2ROUNDUP(end_size,\n\t\t\t    SPA_MINBLOCKSIZE));\n\t\t\tblksz = MAX(blksz, zp->z_blksz);\n\t\t} else {\n\t\t\tblksz = zp->z_blksz;\n\t\t}\n\n\t\tarc_buf_t *abuf = NULL;\n\t\tssize_t nbytes = n;\n\t\tif (n >= blksz && woff >= zp->z_size &&\n\t\t    P2PHASE(woff, blksz) == 0 &&\n\t\t    (blksz >= SPA_OLD_MAXBLOCKSIZE || n < 4 * blksz)) {\n\t\t\t \n\t\t\tabuf = dmu_request_arcbuf(sa_get_db(zp->z_sa_hdl),\n\t\t\t    blksz);\n\t\t\tASSERT(abuf != NULL);\n\t\t\tASSERT(arc_buf_size(abuf) == blksz);\n\t\t\tif ((error = zfs_uiocopy(abuf->b_data, blksz,\n\t\t\t    UIO_WRITE, uio, &nbytes))) {\n\t\t\t\tdmu_return_arcbuf(abuf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tASSERT3S(nbytes, ==, blksz);\n\t\t} else {\n\t\t\tnbytes = MIN(n, (DMU_MAX_ACCESS >> 1) -\n\t\t\t    P2PHASE(woff, blksz));\n\t\t\tif (pfbytes < nbytes) {\n\t\t\t\tif (zfs_uio_prefaultpages(nbytes, uio)) {\n\t\t\t\t\terror = SET_ERROR(EFAULT);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpfbytes = nbytes;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdmu_tx_t *tx = dmu_tx_create(zfsvfs->z_os);\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t\tdmu_buf_impl_t *db = (dmu_buf_impl_t *)sa_get_db(zp->z_sa_hdl);\n\t\tDB_DNODE_ENTER(db);\n\t\tdmu_tx_hold_write_by_dnode(tx, DB_DNODE(db), woff, nbytes);\n\t\tDB_DNODE_EXIT(db);\n\t\tzfs_sa_upgrade_txholds(tx, zp);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tdmu_tx_abort(tx);\n\t\t\tif (abuf != NULL)\n\t\t\t\tdmu_return_arcbuf(abuf);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (lr->lr_length == UINT64_MAX) {\n\t\t\tzfs_grow_blocksize(zp, blksz, tx);\n\t\t\tzfs_rangelock_reduce(lr, woff, n);\n\t\t}\n\n\t\tssize_t tx_bytes;\n\t\tif (abuf == NULL) {\n\t\t\ttx_bytes = zfs_uio_resid(uio);\n\t\t\tzfs_uio_fault_disable(uio, B_TRUE);\n\t\t\terror = dmu_write_uio_dbuf(sa_get_db(zp->z_sa_hdl),\n\t\t\t    uio, nbytes, tx);\n\t\t\tzfs_uio_fault_disable(uio, B_FALSE);\n#ifdef __linux__\n\t\t\tif (error == EFAULT) {\n\t\t\t\tzfs_clear_setid_bits_if_necessary(zfsvfs, zp,\n\t\t\t\t    cr, &clear_setid_bits_txg, tx);\n\t\t\t\tdmu_tx_commit(tx);\n\t\t\t\t \n\t\t\t\tn -= tx_bytes - zfs_uio_resid(uio);\n\t\t\t\tpfbytes -= tx_bytes - zfs_uio_resid(uio);\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\t \n\t\t\tif (error != 0 && error != EFAULT) {\n\t\t\t\tzfs_clear_setid_bits_if_necessary(zfsvfs, zp,\n\t\t\t\t    cr, &clear_setid_bits_txg, tx);\n\t\t\t\tdmu_tx_commit(tx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx_bytes -= zfs_uio_resid(uio);\n\t\t} else {\n\t\t\t \n\t\t\terror = dmu_assign_arcbuf_by_dbuf(\n\t\t\t    sa_get_db(zp->z_sa_hdl), woff, abuf, tx);\n\t\t\tif (error != 0) {\n\t\t\t\t \n\t\t\t\tzfs_clear_setid_bits_if_necessary(zfsvfs, zp,\n\t\t\t\t    cr, &clear_setid_bits_txg, tx);\n\t\t\t\tdmu_return_arcbuf(abuf);\n\t\t\t\tdmu_tx_commit(tx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tASSERT3S(nbytes, <=, zfs_uio_resid(uio));\n\t\t\tzfs_uioskip(uio, nbytes);\n\t\t\ttx_bytes = nbytes;\n\t\t}\n\t\tif (tx_bytes &&\n\t\t    zn_has_cached_data(zp, woff, woff + tx_bytes - 1) &&\n\t\t    !(ioflag & O_DIRECT)) {\n\t\t\tupdate_pages(zp, woff, tx_bytes, zfsvfs->z_os);\n\t\t}\n\n\t\t \n\t\tif (tx_bytes == 0) {\n\t\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_SIZE(zfsvfs),\n\t\t\t    (void *)&zp->z_size, sizeof (uint64_t), tx);\n\t\t\tdmu_tx_commit(tx);\n\t\t\tASSERT(error != 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tzfs_clear_setid_bits_if_necessary(zfsvfs, zp, cr,\n\t\t    &clear_setid_bits_txg, tx);\n\n\t\tzfs_tstamp_update_setup(zp, CONTENT_MODIFIED, mtime, ctime);\n\n\t\t \n\t\twhile ((end_size = zp->z_size) < zfs_uio_offset(uio)) {\n\t\t\t(void) atomic_cas_64(&zp->z_size, end_size,\n\t\t\t    zfs_uio_offset(uio));\n\t\t\tASSERT(error == 0 || error == EFAULT);\n\t\t}\n\t\t \n\t\tif (zfsvfs->z_replay && zfsvfs->z_replay_eof != 0)\n\t\t\tzp->z_size = zfsvfs->z_replay_eof;\n\n\t\terror1 = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\t\tif (error1 != 0)\n\t\t\t \n\t\t\terror = error1;\n\n\t\t \n\t\tzfs_log_write(zilog, tx, TX_WRITE, zp, woff, tx_bytes, ioflag,\n\t\t    NULL, NULL);\n\n\t\tdmu_tx_commit(tx);\n\n\t\tif (error != 0)\n\t\t\tbreak;\n\t\tASSERT3S(tx_bytes, ==, nbytes);\n\t\tn -= nbytes;\n\t\tpfbytes -= nbytes;\n\t}\n\n\tzfs_znode_update_vfs(zp);\n\tzfs_rangelock_exit(lr);\n\n\t \n\tif (zfsvfs->z_replay || zfs_uio_resid(uio) == start_resid ||\n\t    error == EFAULT) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (ioflag & (O_SYNC | O_DSYNC) ||\n\t    zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, zp->z_id);\n\n\tconst int64_t nwritten = start_resid - zfs_uio_resid(uio);\n\tdataset_kstats_update_write_kstats(&zfsvfs->z_kstat, nwritten);\n\ttask_io_account_write(nwritten);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nint\nzfs_getsecattr(znode_t *zp, vsecattr_t *vsecp, int flag, cred_t *cr)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\tboolean_t skipaclchk = (flag & ATTR_NOACLCHECK) ? B_TRUE : B_FALSE;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\terror = zfs_getacl(zp, vsecp, skipaclchk, cr);\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\nint\nzfs_setsecattr(znode_t *zp, vsecattr_t *vsecp, int flag, cred_t *cr)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\tboolean_t skipaclchk = (flag & ATTR_NOACLCHECK) ? B_TRUE : B_FALSE;\n\tzilog_t\t*zilog = zfsvfs->z_log;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = zfs_setacl(zp, vsecp, skipaclchk, cr);\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n#ifdef ZFS_DEBUG\nstatic int zil_fault_io = 0;\n#endif\n\nstatic void zfs_get_done(zgd_t *zgd, int error);\n\n \nint\nzfs_get_data(void *arg, uint64_t gen, lr_write_t *lr, char *buf,\n    struct lwb *lwb, zio_t *zio)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tobjset_t *os = zfsvfs->z_os;\n\tznode_t *zp;\n\tuint64_t object = lr->lr_foid;\n\tuint64_t offset = lr->lr_offset;\n\tuint64_t size = lr->lr_length;\n\tdmu_buf_t *db;\n\tzgd_t *zgd;\n\tint error = 0;\n\tuint64_t zp_gen;\n\n\tASSERT3P(lwb, !=, NULL);\n\tASSERT3U(size, !=, 0);\n\n\t \n\tif (zfs_zget(zfsvfs, object, &zp) != 0)\n\t\treturn (SET_ERROR(ENOENT));\n\tif (zp->z_unlinked) {\n\t\t \n\t\tzfs_zrele_async(zp);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\t \n\tif (sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(zfsvfs), &zp_gen,\n\t    sizeof (zp_gen)) != 0) {\n\t\tzfs_zrele_async(zp);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\tif (zp_gen != gen) {\n\t\tzfs_zrele_async(zp);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tzgd = kmem_zalloc(sizeof (zgd_t), KM_SLEEP);\n\tzgd->zgd_lwb = lwb;\n\tzgd->zgd_private = zp;\n\n\t \n\tif (buf != NULL) {  \n\t\tzgd->zgd_lr = zfs_rangelock_enter(&zp->z_rangelock,\n\t\t    offset, size, RL_READER);\n\t\t \n\t\tif (offset >= zp->z_size) {\n\t\t\terror = SET_ERROR(ENOENT);\n\t\t} else {\n\t\t\terror = dmu_read(os, object, offset, size, buf,\n\t\t\t    DMU_READ_NO_PREFETCH);\n\t\t}\n\t\tASSERT(error == 0 || error == ENOENT);\n\t} else {  \n\t\tASSERT3P(zio, !=, NULL);\n\t\t \n\t\tfor (;;) {\n\t\t\tuint64_t blkoff;\n\t\t\tsize = zp->z_blksz;\n\t\t\tblkoff = ISP2(size) ? P2PHASE(offset, size) : offset;\n\t\t\toffset -= blkoff;\n\t\t\tzgd->zgd_lr = zfs_rangelock_enter(&zp->z_rangelock,\n\t\t\t    offset, size, RL_READER);\n\t\t\tif (zp->z_blksz == size)\n\t\t\t\tbreak;\n\t\t\toffset += blkoff;\n\t\t\tzfs_rangelock_exit(zgd->zgd_lr);\n\t\t}\n\t\t \n\t\tif (lr->lr_offset >= zp->z_size)\n\t\t\terror = SET_ERROR(ENOENT);\n#ifdef ZFS_DEBUG\n\t\tif (zil_fault_io) {\n\t\t\terror = SET_ERROR(EIO);\n\t\t\tzil_fault_io = 0;\n\t\t}\n#endif\n\t\tif (error == 0)\n\t\t\terror = dmu_buf_hold_noread(os, object, offset, zgd,\n\t\t\t    &db);\n\n\t\tif (error == 0) {\n\t\t\tblkptr_t *bp = &lr->lr_blkptr;\n\n\t\t\tzgd->zgd_db = db;\n\t\t\tzgd->zgd_bp = bp;\n\n\t\t\tASSERT(db->db_offset == offset);\n\t\t\tASSERT(db->db_size == size);\n\n\t\t\terror = dmu_sync(zio, lr->lr_common.lrc_txg,\n\t\t\t    zfs_get_done, zgd);\n\t\t\tASSERT(error || lr->lr_length <= size);\n\n\t\t\t \n\t\t\tif (error == 0)\n\t\t\t\treturn (0);\n\n\t\t\tif (error == EALREADY) {\n\t\t\t\tlr->lr_common.lrc_txtype = TX_WRITE2;\n\t\t\t\t \n\t\t\t\tzgd->zgd_bp = NULL;\n\t\t\t\tBP_ZERO(bp);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tzfs_get_done(zgd, error);\n\n\treturn (error);\n}\n\n\nstatic void\nzfs_get_done(zgd_t *zgd, int error)\n{\n\t(void) error;\n\tznode_t *zp = zgd->zgd_private;\n\n\tif (zgd->zgd_db)\n\t\tdmu_buf_rele(zgd->zgd_db, zgd);\n\n\tzfs_rangelock_exit(zgd->zgd_lr);\n\n\t \n\tzfs_zrele_async(zp);\n\n\tkmem_free(zgd, sizeof (zgd_t));\n}\n\nstatic int\nzfs_enter_two(zfsvfs_t *zfsvfs1, zfsvfs_t *zfsvfs2, const char *tag)\n{\n\tint error;\n\n\t \n\tif (zfsvfs1 > zfsvfs2) {\n\t\tzfsvfs_t *tmpzfsvfs;\n\n\t\ttmpzfsvfs = zfsvfs2;\n\t\tzfsvfs2 = zfsvfs1;\n\t\tzfsvfs1 = tmpzfsvfs;\n\t}\n\n\terror = zfs_enter(zfsvfs1, tag);\n\tif (error != 0)\n\t\treturn (error);\n\tif (zfsvfs1 != zfsvfs2) {\n\t\terror = zfs_enter(zfsvfs2, tag);\n\t\tif (error != 0) {\n\t\t\tzfs_exit(zfsvfs1, tag);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzfs_exit_two(zfsvfs_t *zfsvfs1, zfsvfs_t *zfsvfs2, const char *tag)\n{\n\n\tzfs_exit(zfsvfs1, tag);\n\tif (zfsvfs1 != zfsvfs2)\n\t\tzfs_exit(zfsvfs2, tag);\n}\n\n \nint\nzfs_clone_range(znode_t *inzp, uint64_t *inoffp, znode_t *outzp,\n    uint64_t *outoffp, uint64_t *lenp, cred_t *cr)\n{\n\tzfsvfs_t\t*inzfsvfs, *outzfsvfs;\n\tobjset_t\t*inos, *outos;\n\tzfs_locked_range_t *inlr, *outlr;\n\tdmu_buf_impl_t\t*db;\n\tdmu_tx_t\t*tx;\n\tzilog_t\t\t*zilog;\n\tuint64_t\tinoff, outoff, len, done;\n\tuint64_t\toutsize, size;\n\tint\t\terror;\n\tint\t\tcount = 0;\n\tsa_bulk_attr_t\tbulk[3];\n\tuint64_t\tmtime[2], ctime[2];\n\tuint64_t\tuid, gid, projid;\n\tblkptr_t\t*bps;\n\tsize_t\t\tmaxblocks, nbps;\n\tuint_t\t\tinblksz;\n\tuint64_t\tclear_setid_bits_txg = 0;\n\n\tinoff = *inoffp;\n\toutoff = *outoffp;\n\tlen = *lenp;\n\tdone = 0;\n\n\tinzfsvfs = ZTOZSB(inzp);\n\toutzfsvfs = ZTOZSB(outzp);\n\n\t \n\terror = zfs_enter_two(inzfsvfs, outzfsvfs, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\tinos = inzfsvfs->z_os;\n\toutos = outzfsvfs->z_os;\n\n\t \n\tif (dmu_objset_spa(inos) != dmu_objset_spa(outos)) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\t \n\tif (!spa_feature_is_enabled(dmu_objset_spa(outos),\n\t    SPA_FEATURE_BLOCK_CLONING)) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t}\n\n\tASSERT(!outzfsvfs->z_replay);\n\n\t \n\tif (inos->os_encrypted != outos->os_encrypted) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\terror = zfs_verify_zp(inzp);\n\tif (error == 0)\n\t\terror = zfs_verify_zp(outzp);\n\tif (error != 0) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (inzp->z_pflags & ZFS_AV_QUARANTINED) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (SET_ERROR(EACCES));\n\t}\n\n\tif (inoff >= inzp->z_size) {\n\t\t*lenp = 0;\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\tif (len > inzp->z_size - inoff) {\n\t\tlen = inzp->z_size - inoff;\n\t}\n\tif (len == 0) {\n\t\t*lenp = 0;\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tif (zfs_is_readonly(outzfsvfs)) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\tif ((outzp->z_pflags & ZFS_IMMUTABLE) != 0) {\n\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\tif (inzp == outzp) {\n\t\tif (inoff < outoff + len && outoff < inoff + len) {\n\t\t\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t}\n\n\t \n\tif (inzp < outzp || (inzp == outzp && inoff < outoff)) {\n\t\tinlr = zfs_rangelock_enter(&inzp->z_rangelock, inoff, len,\n\t\t    RL_READER);\n\t\toutlr = zfs_rangelock_enter(&outzp->z_rangelock, outoff, len,\n\t\t    RL_WRITER);\n\t} else {\n\t\toutlr = zfs_rangelock_enter(&outzp->z_rangelock, outoff, len,\n\t\t    RL_WRITER);\n\t\tinlr = zfs_rangelock_enter(&inzp->z_rangelock, inoff, len,\n\t\t    RL_READER);\n\t}\n\n\tinblksz = inzp->z_blksz;\n\n\t \n\tif (inblksz != outzp->z_blksz && (outzp->z_size > outzp->z_blksz ||\n\t    outzp->z_size > inblksz)) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (outoff != 0 && !ISP2(inblksz)) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif ((inoff % inblksz) != 0 || (outoff % inblksz) != 0) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto unlock;\n\t}\n\t \n\tif ((len % inblksz) != 0 &&\n\t    (len < inzp->z_size - inoff || len < outzp->z_size - outoff)) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (len <= inblksz && inblksz < outzfsvfs->z_max_blksz &&\n\t    outzp->z_size <= inblksz && outoff + len > inblksz) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto unlock;\n\t}\n\n\terror = zn_rlimit_fsize(outoff + len);\n\tif (error != 0) {\n\t\tgoto unlock;\n\t}\n\n\tif (inoff >= MAXOFFSET_T || outoff >= MAXOFFSET_T) {\n\t\terror = SET_ERROR(EFBIG);\n\t\tgoto unlock;\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(outzfsvfs), NULL,\n\t    &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(outzfsvfs), NULL,\n\t    &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(outzfsvfs), NULL,\n\t    &outzp->z_size, 8);\n\n\tzilog = outzfsvfs->z_log;\n\tmaxblocks = zil_max_log_data(zilog, sizeof (lr_clone_range_t)) /\n\t    sizeof (bps[0]);\n\n\tuid = KUID_TO_SUID(ZTOUID(outzp));\n\tgid = KGID_TO_SGID(ZTOGID(outzp));\n\tprojid = outzp->z_projid;\n\n\tbps = vmem_alloc(sizeof (bps[0]) * maxblocks, KM_SLEEP);\n\n\t \n\twhile (len > 0) {\n\t\tsize = MIN(inblksz * maxblocks, len);\n\n\t\tif (zfs_id_overblockquota(outzfsvfs, DMU_USERUSED_OBJECT,\n\t\t    uid) ||\n\t\t    zfs_id_overblockquota(outzfsvfs, DMU_GROUPUSED_OBJECT,\n\t\t    gid) ||\n\t\t    (projid != ZFS_DEFAULT_PROJID &&\n\t\t    zfs_id_overblockquota(outzfsvfs, DMU_PROJECTUSED_OBJECT,\n\t\t    projid))) {\n\t\t\terror = SET_ERROR(EDQUOT);\n\t\t\tbreak;\n\t\t}\n\n\t\tnbps = maxblocks;\n\t\terror = dmu_read_l0_bps(inos, inzp->z_id, inoff, size, bps,\n\t\t    &nbps);\n\t\tif (error != 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (BP_IS_PROTECTED(&bps[0])) {\n\t\t\tif (inzfsvfs != outzfsvfs) {\n\t\t\t\terror = SET_ERROR(EXDEV);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttx = dmu_tx_create(outos);\n\t\tdmu_tx_hold_sa(tx, outzp->z_sa_hdl, B_FALSE);\n\t\tdb = (dmu_buf_impl_t *)sa_get_db(outzp->z_sa_hdl);\n\t\tDB_DNODE_ENTER(db);\n\t\tdmu_tx_hold_clone_by_dnode(tx, DB_DNODE(db), outoff, size);\n\t\tDB_DNODE_EXIT(db);\n\t\tzfs_sa_upgrade_txholds(tx, outzp);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error != 0) {\n\t\t\tdmu_tx_abort(tx);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (outlr->lr_length == UINT64_MAX) {\n\t\t\tzfs_grow_blocksize(outzp, inblksz, tx);\n\t\t\t \n\t\t\tzfs_rangelock_reduce(outlr, outoff,\n\t\t\t    ((len - 1) / inblksz + 1) * inblksz);\n\t\t}\n\n\t\terror = dmu_brt_clone(outos, outzp->z_id, outoff, size, tx,\n\t\t    bps, nbps);\n\t\tif (error != 0) {\n\t\t\tdmu_tx_commit(tx);\n\t\t\tbreak;\n\t\t}\n\n\t\tzfs_clear_setid_bits_if_necessary(outzfsvfs, outzp, cr,\n\t\t    &clear_setid_bits_txg, tx);\n\n\t\tzfs_tstamp_update_setup(outzp, CONTENT_MODIFIED, mtime, ctime);\n\n\t\t \n\t\twhile ((outsize = outzp->z_size) < outoff + size) {\n\t\t\t(void) atomic_cas_64(&outzp->z_size, outsize,\n\t\t\t    outoff + size);\n\t\t}\n\n\t\terror = sa_bulk_update(outzp->z_sa_hdl, bulk, count, tx);\n\n\t\tzfs_log_clone_range(zilog, tx, TX_CLONE_RANGE, outzp, outoff,\n\t\t    size, inblksz, bps, nbps);\n\n\t\tdmu_tx_commit(tx);\n\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\tinoff += size;\n\t\toutoff += size;\n\t\tlen -= size;\n\t\tdone += size;\n\t}\n\n\tvmem_free(bps, sizeof (bps[0]) * maxblocks);\n\tzfs_znode_update_vfs(outzp);\n\nunlock:\n\tzfs_rangelock_exit(outlr);\n\tzfs_rangelock_exit(inlr);\n\n\tif (done > 0) {\n\t\t \n\t\terror = 0;\n\n\t\tZFS_ACCESSTIME_STAMP(inzfsvfs, inzp);\n\n\t\tif (outos->os_sync == ZFS_SYNC_ALWAYS) {\n\t\t\tzil_commit(zilog, outzp->z_id);\n\t\t}\n\n\t\t*inoffp += done;\n\t\t*outoffp += done;\n\t\t*lenp = done;\n\t} else {\n\t\t \n\t\tASSERT3S(error, !=, 0);\n\t}\n\n\tzfs_exit_two(inzfsvfs, outzfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfs_clone_range_replay(znode_t *zp, uint64_t off, uint64_t len, uint64_t blksz,\n    const blkptr_t *bps, size_t nbps)\n{\n\tzfsvfs_t\t*zfsvfs;\n\tdmu_buf_impl_t\t*db;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tint\t\tcount = 0;\n\tsa_bulk_attr_t\tbulk[3];\n\tuint64_t\tmtime[2], ctime[2];\n\n\tASSERT3U(off, <, MAXOFFSET_T);\n\tASSERT3U(len, >, 0);\n\tASSERT3U(nbps, >, 0);\n\n\tzfsvfs = ZTOZSB(zp);\n\n\tASSERT(spa_feature_is_enabled(dmu_objset_spa(zfsvfs->z_os),\n\t    SPA_FEATURE_BLOCK_CLONING));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tASSERT(zfsvfs->z_replay);\n\tASSERT(!zfs_is_readonly(zfsvfs));\n\n\tif ((off % blksz) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, 8);\n\n\t \n\ttx = dmu_tx_create(zfsvfs->z_os);\n\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tdb = (dmu_buf_impl_t *)sa_get_db(zp->z_sa_hdl);\n\tDB_DNODE_ENTER(db);\n\tdmu_tx_hold_clone_by_dnode(tx, DB_DNODE(db), off, len);\n\tDB_DNODE_EXIT(db);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error != 0) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zp->z_blksz < blksz)\n\t\tzfs_grow_blocksize(zp, blksz, tx);\n\n\tdmu_brt_clone(zfsvfs->z_os, zp->z_id, off, len, tx, bps, nbps);\n\n\tzfs_tstamp_update_setup(zp, CONTENT_MODIFIED, mtime, ctime);\n\n\tif (zp->z_size < off + len)\n\t\tzp->z_size = off + len;\n\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\n\t \n\tVERIFY(zil_replaying(zfsvfs->z_log, tx));\n\n\tdmu_tx_commit(tx);\n\n\tzfs_znode_update_vfs(zp);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\nEXPORT_SYMBOL(zfs_access);\nEXPORT_SYMBOL(zfs_fsync);\nEXPORT_SYMBOL(zfs_holey);\nEXPORT_SYMBOL(zfs_read);\nEXPORT_SYMBOL(zfs_write);\nEXPORT_SYMBOL(zfs_getsecattr);\nEXPORT_SYMBOL(zfs_setsecattr);\nEXPORT_SYMBOL(zfs_clone_range);\nEXPORT_SYMBOL(zfs_clone_range_replay);\n\nZFS_MODULE_PARAM(zfs_vnops, zfs_vnops_, read_chunk_size, U64, ZMOD_RW,\n\t\"Bytes to read per chunk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}