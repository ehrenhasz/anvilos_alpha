{
  "module_name": "vdev_raidz_math_impl.h",
  "hash_id": "1494f2cb23b90c51580ec1842d48a9fde988c2216d8c9842838ece9919fb05a7",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_raidz_math_impl.h",
  "human_readable_source": " \n \n\n#ifndef _VDEV_RAIDZ_MATH_IMPL_H\n#define\t_VDEV_RAIDZ_MATH_IMPL_H\n\n#include <sys/types.h>\n#include <sys/vdev_raidz_impl.h>\n\n#define\traidz_inline inline __attribute__((always_inline))\n#ifndef noinline\n#define\tnoinline __attribute__((noinline))\n#endif\n\n \nstatic noinline void\nraidz_rec_q_coeff(const raidz_row_t *rr, const int *tgtidx, unsigned *coeff)\n{\n\tconst unsigned ncols = rr->rr_cols;\n\tconst unsigned x = tgtidx[TARGET_X];\n\n\tcoeff[MUL_Q_X] = gf_exp2(255 - (ncols - x - 1));\n}\n\nstatic noinline void\nraidz_rec_r_coeff(const raidz_row_t *rr, const int *tgtidx, unsigned *coeff)\n{\n\tconst unsigned ncols = rr->rr_cols;\n\tconst unsigned x = tgtidx[TARGET_X];\n\n\tcoeff[MUL_R_X] = gf_exp4(255 - (ncols - x - 1));\n}\n\nstatic noinline void\nraidz_rec_pq_coeff(const raidz_row_t *rr, const int *tgtidx, unsigned *coeff)\n{\n\tconst unsigned ncols = rr->rr_cols;\n\tconst unsigned x = tgtidx[TARGET_X];\n\tconst unsigned y = tgtidx[TARGET_Y];\n\tgf_t a, b, e;\n\n\ta = gf_exp2(x + 255 - y);\n\tb = gf_exp2(255 - (ncols - x - 1));\n\te = a ^ 0x01;\n\n\tcoeff[MUL_PQ_X] = gf_div(a, e);\n\tcoeff[MUL_PQ_Y] = gf_div(b, e);\n}\n\nstatic noinline void\nraidz_rec_pr_coeff(const raidz_row_t *rr, const int *tgtidx, unsigned *coeff)\n{\n\tconst unsigned ncols = rr->rr_cols;\n\tconst unsigned x = tgtidx[TARGET_X];\n\tconst unsigned y = tgtidx[TARGET_Y];\n\n\tgf_t a, b, e;\n\n\ta = gf_exp4(x + 255 - y);\n\tb = gf_exp4(255 - (ncols - x - 1));\n\te = a ^ 0x01;\n\n\tcoeff[MUL_PR_X] = gf_div(a, e);\n\tcoeff[MUL_PR_Y] = gf_div(b, e);\n}\n\nstatic noinline void\nraidz_rec_qr_coeff(const raidz_row_t *rr, const int *tgtidx, unsigned *coeff)\n{\n\tconst unsigned ncols = rr->rr_cols;\n\tconst unsigned x = tgtidx[TARGET_X];\n\tconst unsigned y = tgtidx[TARGET_Y];\n\n\tgf_t nx, ny, nxxy, nxyy, d;\n\n\tnx = gf_exp2(ncols - x - 1);\n\tny = gf_exp2(ncols - y - 1);\n\tnxxy = gf_mul(gf_mul(nx, nx), ny);\n\tnxyy = gf_mul(gf_mul(nx, ny), ny);\n\td = nxxy ^ nxyy;\n\n\tcoeff[MUL_QR_XQ] = ny;\n\tcoeff[MUL_QR_X]\t= gf_div(ny, d);\n\tcoeff[MUL_QR_YQ] = nx;\n\tcoeff[MUL_QR_Y]\t= gf_div(nx, d);\n}\n\nstatic noinline void\nraidz_rec_pqr_coeff(const raidz_row_t *rr, const int *tgtidx, unsigned *coeff)\n{\n\tconst unsigned ncols = rr->rr_cols;\n\tconst unsigned x = tgtidx[TARGET_X];\n\tconst unsigned y = tgtidx[TARGET_Y];\n\tconst unsigned z = tgtidx[TARGET_Z];\n\n\tgf_t nx, ny, nz, nxx, nyy, nzz, nyyz, nyzz, xd, yd;\n\n\tnx = gf_exp2(ncols - x - 1);\n\tny = gf_exp2(ncols - y - 1);\n\tnz = gf_exp2(ncols - z - 1);\n\n\tnxx = gf_exp4(ncols - x - 1);\n\tnyy = gf_exp4(ncols - y - 1);\n\tnzz = gf_exp4(ncols - z - 1);\n\n\tnyyz = gf_mul(gf_mul(ny, nz), ny);\n\tnyzz = gf_mul(nzz, ny);\n\n\txd = gf_mul(nxx, ny) ^ gf_mul(nx, nyy) ^ nyyz ^\n\t    gf_mul(nxx, nz) ^ gf_mul(nzz, nx) ^  nyzz;\n\n\tyd = gf_inv(ny ^ nz);\n\n\tcoeff[MUL_PQR_XP] = gf_div(nyyz ^ nyzz, xd);\n\tcoeff[MUL_PQR_XQ] = gf_div(nyy ^ nzz, xd);\n\tcoeff[MUL_PQR_XR] = gf_div(ny ^ nz, xd);\n\tcoeff[MUL_PQR_YU] = nx;\n\tcoeff[MUL_PQR_YP] = gf_mul(nz, yd);\n\tcoeff[MUL_PQR_YQ] = yd;\n}\n\n \nstatic int\nraidz_zero_abd_cb(void *dc, size_t dsize, void *private)\n{\n\tv_t *dst = (v_t *)dc;\n\tsize_t i;\n\n\tZERO_DEFINE();\n\n\t(void) private;  \n\n\tZERO(ZERO_D);\n\n\tfor (i = 0; i < dsize / sizeof (v_t); i += (2 * ZERO_STRIDE)) {\n\t\tSTORE(dst + i, ZERO_D);\n\t\tSTORE(dst + i + ZERO_STRIDE, ZERO_D);\n\t}\n\n\treturn (0);\n}\n\n#define\traidz_zero(dabd, size)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tabd_iterate_func(dabd, 0, size, raidz_zero_abd_cb, NULL);\t\\\n}\n\n \nstatic int\nraidz_copy_abd_cb(void *dc, void *sc, size_t size, void *private)\n{\n\tv_t *dst = (v_t *)dc;\n\tconst v_t *src = (v_t *)sc;\n\tsize_t i;\n\n\tCOPY_DEFINE();\n\n\t(void) private;  \n\n\tfor (i = 0; i < size / sizeof (v_t); i += (2 * COPY_STRIDE)) {\n\t\tLOAD(src + i, COPY_D);\n\t\tSTORE(dst + i, COPY_D);\n\n\t\tLOAD(src + i + COPY_STRIDE, COPY_D);\n\t\tSTORE(dst + i + COPY_STRIDE, COPY_D);\n\t}\n\n\treturn (0);\n}\n\n\n#define\traidz_copy(dabd, sabd, size)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tabd_iterate_func2(dabd, sabd, 0, 0, size, raidz_copy_abd_cb, NULL);\\\n}\n\n \nstatic int\nraidz_add_abd_cb(void *dc, void *sc, size_t size, void *private)\n{\n\tv_t *dst = (v_t *)dc;\n\tconst v_t *src = (v_t *)sc;\n\tsize_t i;\n\n\tADD_DEFINE();\n\n\t(void) private;  \n\n\tfor (i = 0; i < size / sizeof (v_t); i += (2 * ADD_STRIDE)) {\n\t\tLOAD(dst + i, ADD_D);\n\t\tXOR_ACC(src + i, ADD_D);\n\t\tSTORE(dst + i, ADD_D);\n\n\t\tLOAD(dst + i + ADD_STRIDE, ADD_D);\n\t\tXOR_ACC(src + i + ADD_STRIDE, ADD_D);\n\t\tSTORE(dst + i + ADD_STRIDE, ADD_D);\n\t}\n\n\treturn (0);\n}\n\n#define\traidz_add(dabd, sabd, size)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tabd_iterate_func2(dabd, sabd, 0, 0, size, raidz_add_abd_cb, NULL);\\\n}\n\n \nstatic int\nraidz_mul_abd_cb(void *dc, size_t size, void *private)\n{\n\tconst unsigned mul = *((unsigned *)private);\n\tv_t *d = (v_t *)dc;\n\tsize_t i;\n\n\tMUL_DEFINE();\n\n\tfor (i = 0; i < size / sizeof (v_t); i += (2 * MUL_STRIDE)) {\n\t\tLOAD(d + i, MUL_D);\n\t\tMUL(mul, MUL_D);\n\t\tSTORE(d + i, MUL_D);\n\n\t\tLOAD(d + i + MUL_STRIDE, MUL_D);\n\t\tMUL(mul, MUL_D);\n\t\tSTORE(d + i + MUL_STRIDE, MUL_D);\n\t}\n\n\treturn (0);\n}\n\n\n \n#define\tP_D_SYNDROME(D, T, t)\t\t\\\n{\t\t\t\t\t\\\n\tLOAD((t), T);\t\t\t\\\n\tXOR(D, T);\t\t\t\\\n\tSTORE((t), T);\t\t\t\\\n}\n\n#define\tQ_D_SYNDROME(D, T, t)\t\t\\\n{\t\t\t\t\t\\\n\tLOAD((t), T);\t\t\t\\\n\tMUL2(T);\t\t\t\\\n\tXOR(D, T);\t\t\t\\\n\tSTORE((t), T);\t\t\t\\\n}\n\n#define\tQ_SYNDROME(T, t)\t\t\\\n{\t\t\t\t\t\\\n\tLOAD((t), T);\t\t\t\\\n\tMUL2(T);\t\t\t\\\n\tSTORE((t), T);\t\t\t\\\n}\n\n#define\tR_D_SYNDROME(D, T, t)\t\t\\\n{\t\t\t\t\t\\\n\tLOAD((t), T);\t\t\t\\\n\tMUL4(T);\t\t\t\\\n\tXOR(D, T);\t\t\t\\\n\tSTORE((t), T);\t\t\t\\\n}\n\n#define\tR_SYNDROME(T, t)\t\t\\\n{\t\t\t\t\t\\\n\tLOAD((t), T);\t\t\t\\\n\tMUL4(T);\t\t\t\\\n\tSTORE((t), T);\t\t\t\\\n}\n\n\n \n\n \nstatic raidz_inline void\nraidz_generate_p_impl(raidz_row_t * const rr)\n{\n\tsize_t c;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t psize = rr->rr_col[CODE_P].rc_size;\n\tabd_t *pabd = rr->rr_col[CODE_P].rc_abd;\n\tsize_t size;\n\tabd_t *dabd;\n\n\traidz_math_begin();\n\n\t \n\traidz_copy(pabd, rr->rr_col[1].rc_abd, psize);\n\n\tfor (c = 2; c < ncols; c++) {\n\t\tdabd = rr->rr_col[c].rc_abd;\n\t\tsize = rr->rr_col[c].rc_size;\n\n\t\t \n\t\traidz_add(pabd, dabd, size);\n\t}\n\n\traidz_math_end();\n}\n\n\n \nstatic void\nraidz_gen_pq_add(void **c, const void *dc, const size_t csize,\n    const size_t dsize)\n{\n\tv_t *p = (v_t *)c[0];\n\tv_t *q = (v_t *)c[1];\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\tconst v_t * const qend = q + (csize / sizeof (v_t));\n\n\tGEN_PQ_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += GEN_PQ_STRIDE, p += GEN_PQ_STRIDE,\n\t    q += GEN_PQ_STRIDE) {\n\t\tLOAD(d, GEN_PQ_D);\n\t\tP_D_SYNDROME(GEN_PQ_D, GEN_PQ_C, p);\n\t\tQ_D_SYNDROME(GEN_PQ_D, GEN_PQ_C, q);\n\t}\n\tfor (; q < qend; q += GEN_PQ_STRIDE) {\n\t\tQ_SYNDROME(GEN_PQ_C, q);\n\t}\n}\n\n\n \nstatic raidz_inline void\nraidz_generate_pq_impl(raidz_row_t * const rr)\n{\n\tsize_t c;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t csize = rr->rr_col[CODE_P].rc_size;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tabd_t *cabds[] = {\n\t\trr->rr_col[CODE_P].rc_abd,\n\t\trr->rr_col[CODE_Q].rc_abd\n\t};\n\n\traidz_math_begin();\n\n\traidz_copy(cabds[CODE_P], rr->rr_col[2].rc_abd, csize);\n\traidz_copy(cabds[CODE_Q], rr->rr_col[2].rc_abd, csize);\n\n\tfor (c = 3; c < ncols; c++) {\n\t\tdabd = rr->rr_col[c].rc_abd;\n\t\tdsize = rr->rr_col[c].rc_size;\n\n\t\tabd_raidz_gen_iterate(cabds, dabd, csize, dsize, 2,\n\t\t    raidz_gen_pq_add);\n\t}\n\n\traidz_math_end();\n}\n\n\n \nstatic void\nraidz_gen_pqr_add(void **c, const void *dc, const size_t csize,\n    const size_t dsize)\n{\n\tv_t *p = (v_t *)c[CODE_P];\n\tv_t *q = (v_t *)c[CODE_Q];\n\tv_t *r = (v_t *)c[CODE_R];\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\tconst v_t * const qend = q + (csize / sizeof (v_t));\n\n\tGEN_PQR_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += GEN_PQR_STRIDE, p += GEN_PQR_STRIDE,\n\t    q += GEN_PQR_STRIDE, r += GEN_PQR_STRIDE) {\n\t\tLOAD(d, GEN_PQR_D);\n\t\tP_D_SYNDROME(GEN_PQR_D, GEN_PQR_C, p);\n\t\tQ_D_SYNDROME(GEN_PQR_D, GEN_PQR_C, q);\n\t\tR_D_SYNDROME(GEN_PQR_D, GEN_PQR_C, r);\n\t}\n\tfor (; q < qend; q += GEN_PQR_STRIDE, r += GEN_PQR_STRIDE) {\n\t\tQ_SYNDROME(GEN_PQR_C, q);\n\t\tR_SYNDROME(GEN_PQR_C, r);\n\t}\n}\n\n\n \nstatic raidz_inline void\nraidz_generate_pqr_impl(raidz_row_t * const rr)\n{\n\tsize_t c;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t csize = rr->rr_col[CODE_P].rc_size;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tabd_t *cabds[] = {\n\t\trr->rr_col[CODE_P].rc_abd,\n\t\trr->rr_col[CODE_Q].rc_abd,\n\t\trr->rr_col[CODE_R].rc_abd\n\t};\n\n\traidz_math_begin();\n\n\traidz_copy(cabds[CODE_P], rr->rr_col[3].rc_abd, csize);\n\traidz_copy(cabds[CODE_Q], rr->rr_col[3].rc_abd, csize);\n\traidz_copy(cabds[CODE_R], rr->rr_col[3].rc_abd, csize);\n\n\tfor (c = 4; c < ncols; c++) {\n\t\tdabd = rr->rr_col[c].rc_abd;\n\t\tdsize = rr->rr_col[c].rc_size;\n\n\t\tabd_raidz_gen_iterate(cabds, dabd, csize, dsize, 3,\n\t\t    raidz_gen_pqr_add);\n\t}\n\n\traidz_math_end();\n}\n\n\n \n\n\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_p_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[TARGET_X];\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tsize_t size;\n\tabd_t *dabd;\n\n\tif (xabd == NULL)\n\t\treturn (1 << CODE_P);\n\n\traidz_math_begin();\n\n\t \n\traidz_copy(xabd, rr->rr_col[CODE_P].rc_abd, xsize);\n\n\t \n\tfor (c = firstdc; c < ncols; c++) {\n\t\tif (c == x)\n\t\t\tcontinue;\n\n\t\tdabd = rr->rr_col[c].rc_abd;\n\t\tsize = MIN(rr->rr_col[c].rc_size, xsize);\n\n\t\traidz_add(xabd, dabd, size);\n\t}\n\n\traidz_math_end();\n\n\treturn (1 << CODE_P);\n}\n\n\n \nstatic void\nraidz_syn_q_abd(void **xc, const void *dc, const size_t xsize,\n    const size_t dsize)\n{\n\tv_t *x = (v_t *)xc[TARGET_X];\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\tconst v_t * const xend = x + (xsize / sizeof (v_t));\n\n\tSYN_Q_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += SYN_STRIDE, x += SYN_STRIDE) {\n\t\tLOAD(d, SYN_Q_D);\n\t\tQ_D_SYNDROME(SYN_Q_D, SYN_Q_X, x);\n\t}\n\tfor (; x < xend; x += SYN_STRIDE) {\n\t\tQ_SYNDROME(SYN_Q_X, x);\n\t}\n}\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_q_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[TARGET_X];\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tabd_t *tabds[] = { xabd };\n\n\tif (xabd == NULL)\n\t\treturn (1 << CODE_Q);\n\n\tunsigned coeff[MUL_CNT];\n\traidz_rec_q_coeff(rr, tgtidx, coeff);\n\n\traidz_math_begin();\n\n\t \n\tif (firstdc != x) {\n\t\traidz_copy(xabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t} else {\n\t\traidz_zero(xabd, xsize);\n\t}\n\n\t \n\tfor (c = firstdc+1; c < ncols; c++) {\n\t\tif (c == x) {\n\t\t\tdabd = NULL;\n\t\t\tdsize = 0;\n\t\t} else {\n\t\t\tdabd = rr->rr_col[c].rc_abd;\n\t\t\tdsize = rr->rr_col[c].rc_size;\n\t\t}\n\n\t\tabd_raidz_gen_iterate(tabds, dabd, xsize, dsize, 1,\n\t\t    raidz_syn_q_abd);\n\t}\n\n\t \n\traidz_add(xabd, rr->rr_col[CODE_Q].rc_abd, xsize);\n\n\t \n\tabd_iterate_func(xabd, 0, xsize, raidz_mul_abd_cb, (void*) coeff);\n\n\traidz_math_end();\n\n\treturn (1 << CODE_Q);\n}\n\n\n \nstatic void\nraidz_syn_r_abd(void **xc, const void *dc, const size_t tsize,\n    const size_t dsize)\n{\n\tv_t *x = (v_t *)xc[TARGET_X];\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\tconst v_t * const xend = x + (tsize / sizeof (v_t));\n\n\tSYN_R_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += SYN_STRIDE, x += SYN_STRIDE) {\n\t\tLOAD(d, SYN_R_D);\n\t\tR_D_SYNDROME(SYN_R_D, SYN_R_X, x);\n\t}\n\tfor (; x < xend; x += SYN_STRIDE) {\n\t\tR_SYNDROME(SYN_R_X, x);\n\t}\n}\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_r_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[TARGET_X];\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tabd_t *tabds[] = { xabd };\n\n\tif (xabd == NULL)\n\t\treturn (1 << CODE_R);\n\n\tunsigned coeff[MUL_CNT];\n\traidz_rec_r_coeff(rr, tgtidx, coeff);\n\n\traidz_math_begin();\n\n\t \n\tif (firstdc != x) {\n\t\traidz_copy(xabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t} else {\n\t\traidz_zero(xabd, xsize);\n\t}\n\n\n\t \n\tfor (c = firstdc+1; c < ncols; c++) {\n\t\tif (c == x) {\n\t\t\tdabd = NULL;\n\t\t\tdsize = 0;\n\t\t} else {\n\t\t\tdabd = rr->rr_col[c].rc_abd;\n\t\t\tdsize = rr->rr_col[c].rc_size;\n\t\t}\n\n\t\tabd_raidz_gen_iterate(tabds, dabd, xsize, dsize, 1,\n\t\t    raidz_syn_r_abd);\n\t}\n\n\t \n\traidz_add(xabd, rr->rr_col[CODE_R].rc_abd, xsize);\n\n\t \n\tabd_iterate_func(xabd, 0, xsize, raidz_mul_abd_cb, (void *)coeff);\n\n\traidz_math_end();\n\n\treturn (1 << CODE_R);\n}\n\n\n \nstatic void\nraidz_syn_pq_abd(void **tc, const void *dc, const size_t tsize,\n    const size_t dsize)\n{\n\tv_t *x = (v_t *)tc[TARGET_X];\n\tv_t *y = (v_t *)tc[TARGET_Y];\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\tconst v_t * const yend = y + (tsize / sizeof (v_t));\n\n\tSYN_PQ_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += SYN_STRIDE, x += SYN_STRIDE, y += SYN_STRIDE) {\n\t\tLOAD(d, SYN_PQ_D);\n\t\tP_D_SYNDROME(SYN_PQ_D, SYN_PQ_X, x);\n\t\tQ_D_SYNDROME(SYN_PQ_D, SYN_PQ_X, y);\n\t}\n\tfor (; y < yend; y += SYN_STRIDE) {\n\t\tQ_SYNDROME(SYN_PQ_X, y);\n\t}\n}\n\n \nstatic void\nraidz_rec_pq_abd(void **tc, const size_t tsize, void **c,\n    const unsigned *mul)\n{\n\tv_t *x = (v_t *)tc[TARGET_X];\n\tv_t *y = (v_t *)tc[TARGET_Y];\n\tconst v_t * const xend = x + (tsize / sizeof (v_t));\n\tconst v_t *p = (v_t *)c[CODE_P];\n\tconst v_t *q = (v_t *)c[CODE_Q];\n\n\tREC_PQ_DEFINE();\n\n\tfor (; x < xend; x += REC_PQ_STRIDE, y += REC_PQ_STRIDE,\n\t    p += REC_PQ_STRIDE, q += REC_PQ_STRIDE) {\n\t\tLOAD(x, REC_PQ_X);\n\t\tLOAD(y, REC_PQ_Y);\n\n\t\tXOR_ACC(p, REC_PQ_X);\n\t\tXOR_ACC(q, REC_PQ_Y);\n\n\t\t \n\t\tCOPY(REC_PQ_X,  REC_PQ_T);\n\n\t\t \n\t\tMUL(mul[MUL_PQ_X], REC_PQ_X);\n\t\tMUL(mul[MUL_PQ_Y], REC_PQ_Y);\n\t\tXOR(REC_PQ_Y,  REC_PQ_X);\n\t\tSTORE(x, REC_PQ_X);\n\n\t\t \n\t\tXOR(REC_PQ_T,  REC_PQ_X);\n\t\tSTORE(y, REC_PQ_X);\n\t}\n}\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_pq_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[TARGET_X];\n\tconst size_t y = tgtidx[TARGET_Y];\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tconst size_t ysize = rr->rr_col[y].rc_size;\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tabd_t *yabd = rr->rr_col[y].rc_abd;\n\tabd_t *tabds[2] = { xabd, yabd };\n\tabd_t *cabds[] = {\n\t\trr->rr_col[CODE_P].rc_abd,\n\t\trr->rr_col[CODE_Q].rc_abd\n\t};\n\n\tif (xabd == NULL)\n\t\treturn ((1 << CODE_P) | (1 << CODE_Q));\n\n\tunsigned coeff[MUL_CNT];\n\traidz_rec_pq_coeff(rr, tgtidx, coeff);\n\n\t \n\tif (ysize < xsize) {\n\t\tyabd = abd_alloc(xsize, B_FALSE);\n\t\ttabds[1] = yabd;\n\t}\n\n\traidz_math_begin();\n\n\t \n\tif (firstdc != x) {\n\t\traidz_copy(xabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t\traidz_copy(yabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t} else {\n\t\traidz_zero(xabd, xsize);\n\t\traidz_zero(yabd, xsize);\n\t}\n\n\t \n\tfor (c = firstdc+1; c < ncols; c++) {\n\t\tif (c == x || c == y) {\n\t\t\tdabd = NULL;\n\t\t\tdsize = 0;\n\t\t} else {\n\t\t\tdabd = rr->rr_col[c].rc_abd;\n\t\t\tdsize = rr->rr_col[c].rc_size;\n\t\t}\n\n\t\tabd_raidz_gen_iterate(tabds, dabd, xsize, dsize, 2,\n\t\t    raidz_syn_pq_abd);\n\t}\n\n\tabd_raidz_rec_iterate(cabds, tabds, xsize, 2, raidz_rec_pq_abd, coeff);\n\n\t \n\tif (ysize < xsize)\n\t\traidz_copy(rr->rr_col[y].rc_abd, yabd, ysize);\n\n\traidz_math_end();\n\n\tif (ysize < xsize)\n\t\tabd_free(yabd);\n\n\treturn ((1 << CODE_P) | (1 << CODE_Q));\n}\n\n\n \nstatic void\nraidz_syn_pr_abd(void **c, const void *dc, const size_t tsize,\n    const size_t dsize)\n{\n\tv_t *x = (v_t *)c[TARGET_X];\n\tv_t *y = (v_t *)c[TARGET_Y];\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\tconst v_t * const yend = y + (tsize / sizeof (v_t));\n\n\tSYN_PR_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += SYN_STRIDE, x += SYN_STRIDE, y += SYN_STRIDE) {\n\t\tLOAD(d, SYN_PR_D);\n\t\tP_D_SYNDROME(SYN_PR_D, SYN_PR_X, x);\n\t\tR_D_SYNDROME(SYN_PR_D, SYN_PR_X, y);\n\t}\n\tfor (; y < yend; y += SYN_STRIDE) {\n\t\tR_SYNDROME(SYN_PR_X, y);\n\t}\n}\n\n \nstatic void\nraidz_rec_pr_abd(void **t, const size_t tsize, void **c,\n    const unsigned *mul)\n{\n\tv_t *x = (v_t *)t[TARGET_X];\n\tv_t *y = (v_t *)t[TARGET_Y];\n\tconst v_t * const xend = x + (tsize / sizeof (v_t));\n\tconst v_t *p = (v_t *)c[CODE_P];\n\tconst v_t *q = (v_t *)c[CODE_Q];\n\n\tREC_PR_DEFINE();\n\n\tfor (; x < xend; x += REC_PR_STRIDE, y += REC_PR_STRIDE,\n\t    p += REC_PR_STRIDE, q += REC_PR_STRIDE) {\n\t\tLOAD(x, REC_PR_X);\n\t\tLOAD(y, REC_PR_Y);\n\t\tXOR_ACC(p, REC_PR_X);\n\t\tXOR_ACC(q, REC_PR_Y);\n\n\t\t \n\t\tCOPY(REC_PR_X,  REC_PR_T);\n\n\t\t \n\t\tMUL(mul[MUL_PR_X], REC_PR_X);\n\t\tMUL(mul[MUL_PR_Y], REC_PR_Y);\n\t\tXOR(REC_PR_Y,  REC_PR_X);\n\t\tSTORE(x, REC_PR_X);\n\n\t\t \n\t\tXOR(REC_PR_T,  REC_PR_X);\n\t\tSTORE(y, REC_PR_X);\n\t}\n}\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_pr_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[0];\n\tconst size_t y = tgtidx[1];\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tconst size_t ysize = rr->rr_col[y].rc_size;\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tabd_t *yabd = rr->rr_col[y].rc_abd;\n\tabd_t *tabds[2] = { xabd, yabd };\n\tabd_t *cabds[] = {\n\t\trr->rr_col[CODE_P].rc_abd,\n\t\trr->rr_col[CODE_R].rc_abd\n\t};\n\n\tif (xabd == NULL)\n\t\treturn ((1 << CODE_P) | (1 << CODE_R));\n\n\tunsigned coeff[MUL_CNT];\n\traidz_rec_pr_coeff(rr, tgtidx, coeff);\n\n\t \n\tif (ysize < xsize) {\n\t\tyabd = abd_alloc(xsize, B_FALSE);\n\t\ttabds[1] = yabd;\n\t}\n\n\traidz_math_begin();\n\n\t \n\tif (firstdc != x) {\n\t\traidz_copy(xabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t\traidz_copy(yabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t} else {\n\t\traidz_zero(xabd, xsize);\n\t\traidz_zero(yabd, xsize);\n\t}\n\n\t \n\tfor (c = firstdc+1; c < ncols; c++) {\n\t\tif (c == x || c == y) {\n\t\t\tdabd = NULL;\n\t\t\tdsize = 0;\n\t\t} else {\n\t\t\tdabd = rr->rr_col[c].rc_abd;\n\t\t\tdsize = rr->rr_col[c].rc_size;\n\t\t}\n\n\t\tabd_raidz_gen_iterate(tabds, dabd, xsize, dsize, 2,\n\t\t    raidz_syn_pr_abd);\n\t}\n\n\tabd_raidz_rec_iterate(cabds, tabds, xsize, 2, raidz_rec_pr_abd, coeff);\n\n\t \n\tif (ysize < xsize)\n\t\traidz_copy(rr->rr_col[y].rc_abd, yabd, ysize);\n\n\traidz_math_end();\n\n\tif (ysize < xsize)\n\t\tabd_free(yabd);\n\n\treturn ((1 << CODE_P) | (1 << CODE_R));\n}\n\n\n \nstatic void\nraidz_syn_qr_abd(void **c, const void *dc, const size_t tsize,\n    const size_t dsize)\n{\n\tv_t *x = (v_t *)c[TARGET_X];\n\tv_t *y = (v_t *)c[TARGET_Y];\n\tconst v_t * const xend = x + (tsize / sizeof (v_t));\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\n\tSYN_QR_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend; d += SYN_STRIDE, x += SYN_STRIDE, y += SYN_STRIDE) {\n\t\tLOAD(d, SYN_PQ_D);\n\t\tQ_D_SYNDROME(SYN_QR_D, SYN_QR_X, x);\n\t\tR_D_SYNDROME(SYN_QR_D, SYN_QR_X, y);\n\t}\n\tfor (; x < xend; x += SYN_STRIDE, y += SYN_STRIDE) {\n\t\tQ_SYNDROME(SYN_QR_X, x);\n\t\tR_SYNDROME(SYN_QR_X, y);\n\t}\n}\n\n\n \nstatic void\nraidz_rec_qr_abd(void **t, const size_t tsize, void **c,\n    const unsigned *mul)\n{\n\tv_t *x = (v_t *)t[TARGET_X];\n\tv_t *y = (v_t *)t[TARGET_Y];\n\tconst v_t * const xend = x + (tsize / sizeof (v_t));\n\tconst v_t *p = (v_t *)c[CODE_P];\n\tconst v_t *q = (v_t *)c[CODE_Q];\n\n\tREC_QR_DEFINE();\n\n\tfor (; x < xend; x += REC_QR_STRIDE, y += REC_QR_STRIDE,\n\t    p += REC_QR_STRIDE, q += REC_QR_STRIDE) {\n\t\tLOAD(x, REC_QR_X);\n\t\tLOAD(y, REC_QR_Y);\n\n\t\tXOR_ACC(p, REC_QR_X);\n\t\tXOR_ACC(q, REC_QR_Y);\n\n\t\t \n\t\tCOPY(REC_QR_X,  REC_QR_T);\n\n\t\t \n\t\tMUL(mul[MUL_QR_XQ], REC_QR_X);\t \n\t\tXOR(REC_QR_Y, REC_QR_X);\t \n\t\tMUL(mul[MUL_QR_X], REC_QR_X);\t \n\t\tSTORE(x, REC_QR_X);\n\n\t\t \n\t\tMUL(mul[MUL_QR_YQ], REC_QR_T);\t \n\t\tXOR(REC_QR_Y, REC_QR_T);\t \n\t\tMUL(mul[MUL_QR_Y], REC_QR_T);\t \n\t\tSTORE(y, REC_QR_T);\n\t}\n}\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_qr_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[TARGET_X];\n\tconst size_t y = tgtidx[TARGET_Y];\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tconst size_t ysize = rr->rr_col[y].rc_size;\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tabd_t *yabd = rr->rr_col[y].rc_abd;\n\tabd_t *tabds[2] = { xabd, yabd };\n\tabd_t *cabds[] = {\n\t\trr->rr_col[CODE_Q].rc_abd,\n\t\trr->rr_col[CODE_R].rc_abd\n\t};\n\n\tif (xabd == NULL)\n\t\treturn ((1 << CODE_Q) | (1 << CODE_R));\n\n\tunsigned coeff[MUL_CNT];\n\traidz_rec_qr_coeff(rr, tgtidx, coeff);\n\n\t \n\tif (ysize < xsize) {\n\t\tyabd = abd_alloc(xsize, B_FALSE);\n\t\ttabds[1] = yabd;\n\t}\n\n\traidz_math_begin();\n\n\t \n\tif (firstdc != x) {\n\t\traidz_copy(xabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t\traidz_copy(yabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t} else {\n\t\traidz_zero(xabd, xsize);\n\t\traidz_zero(yabd, xsize);\n\t}\n\n\t \n\tfor (c = firstdc+1; c < ncols; c++) {\n\t\tif (c == x || c == y) {\n\t\t\tdabd = NULL;\n\t\t\tdsize = 0;\n\t\t} else {\n\t\t\tdabd = rr->rr_col[c].rc_abd;\n\t\t\tdsize = rr->rr_col[c].rc_size;\n\t\t}\n\n\t\tabd_raidz_gen_iterate(tabds, dabd, xsize, dsize, 2,\n\t\t    raidz_syn_qr_abd);\n\t}\n\n\tabd_raidz_rec_iterate(cabds, tabds, xsize, 2, raidz_rec_qr_abd, coeff);\n\n\t \n\tif (ysize < xsize)\n\t\traidz_copy(rr->rr_col[y].rc_abd, yabd, ysize);\n\n\traidz_math_end();\n\n\tif (ysize < xsize)\n\t\tabd_free(yabd);\n\n\n\treturn ((1 << CODE_Q) | (1 << CODE_R));\n}\n\n\n \nstatic void\nraidz_syn_pqr_abd(void **c, const void *dc, const size_t tsize,\n    const size_t dsize)\n{\n\tv_t *x = (v_t *)c[TARGET_X];\n\tv_t *y = (v_t *)c[TARGET_Y];\n\tv_t *z = (v_t *)c[TARGET_Z];\n\tconst v_t * const yend = y + (tsize / sizeof (v_t));\n\tconst v_t *d = (const v_t *)dc;\n\tconst v_t * const dend = d + (dsize / sizeof (v_t));\n\n\tSYN_PQR_DEFINE();\n\n\tMUL2_SETUP();\n\n\tfor (; d < dend;  d += SYN_STRIDE, x += SYN_STRIDE, y += SYN_STRIDE,\n\t    z += SYN_STRIDE) {\n\t\tLOAD(d, SYN_PQR_D);\n\t\tP_D_SYNDROME(SYN_PQR_D, SYN_PQR_X, x)\n\t\tQ_D_SYNDROME(SYN_PQR_D, SYN_PQR_X, y);\n\t\tR_D_SYNDROME(SYN_PQR_D, SYN_PQR_X, z);\n\t}\n\tfor (; y < yend; y += SYN_STRIDE, z += SYN_STRIDE) {\n\t\tQ_SYNDROME(SYN_PQR_X, y);\n\t\tR_SYNDROME(SYN_PQR_X, z);\n\t}\n}\n\n\n \nstatic void\nraidz_rec_pqr_abd(void **t, const size_t tsize, void **c,\n    const unsigned * const mul)\n{\n\tv_t *x = (v_t *)t[TARGET_X];\n\tv_t *y = (v_t *)t[TARGET_Y];\n\tv_t *z = (v_t *)t[TARGET_Z];\n\tconst v_t * const xend = x + (tsize / sizeof (v_t));\n\tconst v_t *p = (v_t *)c[CODE_P];\n\tconst v_t *q = (v_t *)c[CODE_Q];\n\tconst v_t *r = (v_t *)c[CODE_R];\n\n\tREC_PQR_DEFINE();\n\n\tfor (; x < xend; x += REC_PQR_STRIDE, y += REC_PQR_STRIDE,\n\t    z += REC_PQR_STRIDE, p += REC_PQR_STRIDE, q += REC_PQR_STRIDE,\n\t    r += REC_PQR_STRIDE) {\n\t\tLOAD(x, REC_PQR_X);\n\t\tLOAD(y, REC_PQR_Y);\n\t\tLOAD(z, REC_PQR_Z);\n\n\t\tXOR_ACC(p, REC_PQR_X);\n\t\tXOR_ACC(q, REC_PQR_Y);\n\t\tXOR_ACC(r, REC_PQR_Z);\n\n\t\t \n\t\tCOPY(REC_PQR_X, REC_PQR_XS);\n\t\tCOPY(REC_PQR_Y, REC_PQR_YS);\n\n\t\t \n\t\tMUL(mul[MUL_PQR_XP], REC_PQR_X);\t \n\t\tMUL(mul[MUL_PQR_XQ], REC_PQR_Y);\t \n\t\tXOR(REC_PQR_Y, REC_PQR_X);\n\t\tMUL(mul[MUL_PQR_XR], REC_PQR_Z);\t \n\t\tXOR(REC_PQR_Z, REC_PQR_X);\t\t \n\t\tSTORE(x, REC_PQR_X);\n\n\t\t \n\t\tXOR(REC_PQR_X, REC_PQR_XS); \t\t \n\t\tMUL(mul[MUL_PQR_YU], REC_PQR_X);  \t \n\t\tXOR(REC_PQR_X, REC_PQR_YS); \t\t \n\t\tCOPY(REC_PQR_XS, REC_PQR_X);\t\t \n\t\tMUL(mul[MUL_PQR_YP], REC_PQR_X);\t \n\t\tMUL(mul[MUL_PQR_YQ], REC_PQR_YS);\t \n\t\tXOR(REC_PQR_X, REC_PQR_YS); \t\t \n\t\tSTORE(y, REC_PQR_YS);\n\n\t\t \n\t\tXOR(REC_PQR_XS, REC_PQR_YS);\t\t \n\t\tSTORE(z, REC_PQR_YS);\n\t}\n}\n\n\n \nstatic raidz_inline int\nraidz_reconstruct_pqr_impl(raidz_row_t *rr, const int *tgtidx)\n{\n\tsize_t c;\n\tsize_t dsize;\n\tabd_t *dabd;\n\tconst size_t firstdc = rr->rr_firstdatacol;\n\tconst size_t ncols = rr->rr_cols;\n\tconst size_t x = tgtidx[TARGET_X];\n\tconst size_t y = tgtidx[TARGET_Y];\n\tconst size_t z = tgtidx[TARGET_Z];\n\tconst size_t xsize = rr->rr_col[x].rc_size;\n\tconst size_t ysize = rr->rr_col[y].rc_size;\n\tconst size_t zsize = rr->rr_col[z].rc_size;\n\tabd_t *xabd = rr->rr_col[x].rc_abd;\n\tabd_t *yabd = rr->rr_col[y].rc_abd;\n\tabd_t *zabd = rr->rr_col[z].rc_abd;\n\tabd_t *tabds[] = { xabd, yabd, zabd };\n\tabd_t *cabds[] = {\n\t\trr->rr_col[CODE_P].rc_abd,\n\t\trr->rr_col[CODE_Q].rc_abd,\n\t\trr->rr_col[CODE_R].rc_abd\n\t};\n\n\tif (xabd == NULL)\n\t\treturn ((1 << CODE_P) | (1 << CODE_Q) | (1 << CODE_R));\n\n\tunsigned coeff[MUL_CNT];\n\traidz_rec_pqr_coeff(rr, tgtidx, coeff);\n\n\t \n\tif (ysize < xsize) {\n\t\tyabd = abd_alloc(xsize, B_FALSE);\n\t\ttabds[1] = yabd;\n\t}\n\tif (zsize < xsize) {\n\t\tzabd = abd_alloc(xsize, B_FALSE);\n\t\ttabds[2] = zabd;\n\t}\n\n\traidz_math_begin();\n\n\t \n\tif (firstdc != x) {\n\t\traidz_copy(xabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t\traidz_copy(yabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t\traidz_copy(zabd, rr->rr_col[firstdc].rc_abd, xsize);\n\t} else {\n\t\traidz_zero(xabd, xsize);\n\t\traidz_zero(yabd, xsize);\n\t\traidz_zero(zabd, xsize);\n\t}\n\n\t \n\tfor (c = firstdc+1; c < ncols; c++) {\n\t\tif (c == x || c == y || c == z) {\n\t\t\tdabd = NULL;\n\t\t\tdsize = 0;\n\t\t} else {\n\t\t\tdabd = rr->rr_col[c].rc_abd;\n\t\t\tdsize = rr->rr_col[c].rc_size;\n\t\t}\n\n\t\tabd_raidz_gen_iterate(tabds, dabd, xsize, dsize, 3,\n\t\t    raidz_syn_pqr_abd);\n\t}\n\n\tabd_raidz_rec_iterate(cabds, tabds, xsize, 3, raidz_rec_pqr_abd, coeff);\n\n\t \n\tif (ysize < xsize)\n\t\traidz_copy(rr->rr_col[y].rc_abd, yabd, ysize);\n\tif (zsize < xsize)\n\t\traidz_copy(rr->rr_col[z].rc_abd, zabd, zsize);\n\n\traidz_math_end();\n\n\tif (ysize < xsize)\n\t\tabd_free(yabd);\n\tif (zsize < xsize)\n\t\tabd_free(zabd);\n\n\treturn ((1 << CODE_P) | (1 << CODE_Q) | (1 << CODE_R));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}