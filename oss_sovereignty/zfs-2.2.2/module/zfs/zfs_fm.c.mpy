{
  "module_name": "zfs_fm.c",
  "hash_id": "56ae064c5f46f928e9a4a95d729758da6180c3886b4d0ebced7522322caeed70",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zfs_fm.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/zio.h>\n#include <sys/zio_checksum.h>\n\n#include <sys/fm/fs/zfs.h>\n#include <sys/fm/protocol.h>\n#include <sys/fm/util.h>\n#include <sys/sysevent.h>\n\n \n\n#ifdef _KERNEL\n \nstatic list_t recent_events_list;\nstatic avl_tree_t recent_events_tree;\nstatic kmutex_t recent_events_lock;\nstatic taskqid_t recent_events_cleaner_tqid;\n\n \nstatic unsigned int zfs_zevent_retain_max = 2000;\n\n \nstatic unsigned int zfs_zevent_retain_expire_secs = 900;\n\ntypedef enum zfs_subclass {\n\tZSC_IO,\n\tZSC_DATA,\n\tZSC_CHECKSUM\n} zfs_subclass_t;\n\ntypedef struct {\n\t \n\tuint64_t\tre_pool_guid;\n\tuint64_t\tre_vdev_guid;\n\tint\t\tre_io_error;\n\tuint64_t\tre_io_size;\n\tuint64_t\tre_io_offset;\n\tzfs_subclass_t\tre_subclass;\n\tzio_priority_t\tre_io_priority;\n\n\t \n\tzbookmark_phys_t re_io_bookmark;\n\n\t \n\tavl_node_t\tre_tree_link;\n\tlist_node_t\tre_list_link;\n\tuint64_t\tre_timestamp;\n} recent_events_node_t;\n\nstatic int\nrecent_events_compare(const void *a, const void *b)\n{\n\tconst recent_events_node_t *node1 = a;\n\tconst recent_events_node_t *node2 = b;\n\tint cmp;\n\n\t \n\tif ((cmp = TREE_CMP(node1->re_subclass, node2->re_subclass)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(node1->re_pool_guid, node2->re_pool_guid)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(node1->re_vdev_guid, node2->re_vdev_guid)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(node1->re_io_error, node2->re_io_error)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(node1->re_io_priority, node2->re_io_priority)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(node1->re_io_size, node2->re_io_size)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(node1->re_io_offset, node2->re_io_offset)) != 0)\n\t\treturn (cmp);\n\n\tconst zbookmark_phys_t *zb1 = &node1->re_io_bookmark;\n\tconst zbookmark_phys_t *zb2 = &node2->re_io_bookmark;\n\n\tif ((cmp = TREE_CMP(zb1->zb_objset, zb2->zb_objset)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(zb1->zb_object, zb2->zb_object)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(zb1->zb_level, zb2->zb_level)) != 0)\n\t\treturn (cmp);\n\tif ((cmp = TREE_CMP(zb1->zb_blkid, zb2->zb_blkid)) != 0)\n\t\treturn (cmp);\n\n\treturn (0);\n}\n\n \nstatic uint64_t\nvdev_prop_get_inherited(vdev_t *vd, vdev_prop_t prop)\n{\n\tuint64_t propdef, propval;\n\n\tpropdef = vdev_prop_default_numeric(prop);\n\tswitch (prop) {\n\t\tcase VDEV_PROP_CHECKSUM_N:\n\t\t\tpropval = vd->vdev_checksum_n;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_CHECKSUM_T:\n\t\t\tpropval = vd->vdev_checksum_t;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_IO_N:\n\t\t\tpropval = vd->vdev_io_n;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_IO_T:\n\t\t\tpropval = vd->vdev_io_t;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpropval = propdef;\n\t\t\tbreak;\n\t}\n\n\tif (propval != propdef)\n\t\treturn (propval);\n\n\tif (vd->vdev_parent == NULL)\n\t\treturn (propdef);\n\n\treturn (vdev_prop_get_inherited(vd->vdev_parent, prop));\n}\n\nstatic void zfs_ereport_schedule_cleaner(void);\n\n \nstatic void\nzfs_ereport_cleaner(void *arg)\n{\n\trecent_events_node_t *entry;\n\tuint64_t now = gethrtime();\n\n\t \n\tmutex_enter(&recent_events_lock);\n\twhile ((entry = list_tail(&recent_events_list)) != NULL) {\n\t\tuint64_t age = NSEC2SEC(now - entry->re_timestamp);\n\t\tif (age <= zfs_zevent_retain_expire_secs)\n\t\t\tbreak;\n\n\t\t \n\t\tavl_remove(&recent_events_tree, entry);\n\t\tlist_remove(&recent_events_list, entry);\n\t\tkmem_free(entry, sizeof (*entry));\n\t}\n\n\t \n\trecent_events_cleaner_tqid = 0;\n\tif (!list_is_empty(&recent_events_list))\n\t\tzfs_ereport_schedule_cleaner();\n\n\tmutex_exit(&recent_events_lock);\n}\n\nstatic void\nzfs_ereport_schedule_cleaner(void)\n{\n\tASSERT(MUTEX_HELD(&recent_events_lock));\n\n\tuint64_t timeout = SEC2NSEC(zfs_zevent_retain_expire_secs + 1);\n\n\trecent_events_cleaner_tqid = taskq_dispatch_delay(\n\t    system_delay_taskq, zfs_ereport_cleaner, NULL, TQ_SLEEP,\n\t    ddi_get_lbolt() + NSEC_TO_TICK(timeout));\n}\n\n \nvoid\nzfs_ereport_clear(spa_t *spa, vdev_t *vd)\n{\n\tuint64_t vdev_guid, pool_guid;\n\n\tASSERT(vd != NULL || spa != NULL);\n\tif (vd == NULL) {\n\t\tvdev_guid = 0;\n\t\tpool_guid = spa_guid(spa);\n\t} else {\n\t\tvdev_guid = vd->vdev_guid;\n\t\tpool_guid = 0;\n\t}\n\n\tmutex_enter(&recent_events_lock);\n\n\trecent_events_node_t *next = list_head(&recent_events_list);\n\twhile (next != NULL) {\n\t\trecent_events_node_t *entry = next;\n\n\t\tnext = list_next(&recent_events_list, next);\n\n\t\tif (entry->re_vdev_guid == vdev_guid ||\n\t\t    entry->re_pool_guid == pool_guid) {\n\t\t\tavl_remove(&recent_events_tree, entry);\n\t\t\tlist_remove(&recent_events_list, entry);\n\t\t\tkmem_free(entry, sizeof (*entry));\n\t\t}\n\t}\n\n\tmutex_exit(&recent_events_lock);\n}\n\n \nstatic boolean_t\nzfs_ereport_is_duplicate(const char *subclass, spa_t *spa, vdev_t *vd,\n    const zbookmark_phys_t *zb, zio_t *zio, uint64_t offset, uint64_t size)\n{\n\trecent_events_node_t search = {0}, *entry;\n\n\tif (vd == NULL || zio == NULL)\n\t\treturn (B_FALSE);\n\n\tif (zfs_zevent_retain_max == 0)\n\t\treturn (B_FALSE);\n\n\tif (strcmp(subclass, FM_EREPORT_ZFS_IO) == 0)\n\t\tsearch.re_subclass = ZSC_IO;\n\telse if (strcmp(subclass, FM_EREPORT_ZFS_DATA) == 0)\n\t\tsearch.re_subclass = ZSC_DATA;\n\telse if (strcmp(subclass, FM_EREPORT_ZFS_CHECKSUM) == 0)\n\t\tsearch.re_subclass = ZSC_CHECKSUM;\n\telse\n\t\treturn (B_FALSE);\n\n\tsearch.re_pool_guid = spa_guid(spa);\n\tsearch.re_vdev_guid = vd->vdev_guid;\n\tsearch.re_io_error = zio->io_error;\n\tsearch.re_io_priority = zio->io_priority;\n\t \n\tif (size) {\n\t\tsearch.re_io_size = size;\n\t\tsearch.re_io_offset = offset;\n\t} else {\n\t\tsearch.re_io_size = zio->io_size;\n\t\tsearch.re_io_offset = zio->io_offset;\n\t}\n\n\t \n\tif (zb != NULL) {\n\t\tsearch.re_io_bookmark.zb_objset = zb->zb_objset;\n\t\tsearch.re_io_bookmark.zb_object = zb->zb_object;\n\t\tsearch.re_io_bookmark.zb_level = zb->zb_level;\n\t\tsearch.re_io_bookmark.zb_blkid = zb->zb_blkid;\n\t}\n\n\tuint64_t now = gethrtime();\n\n\tmutex_enter(&recent_events_lock);\n\n\t \n\tentry = avl_find(&recent_events_tree, &search, NULL);\n\tif (entry != NULL) {\n\t\tuint64_t age = NSEC2SEC(now - entry->re_timestamp);\n\n\t\t \n\t\tlist_remove(&recent_events_list, entry);\n\t\tlist_insert_head(&recent_events_list, entry);\n\t\tentry->re_timestamp = now;\n\n\t\tzfs_zevent_track_duplicate();\n\t\tmutex_exit(&recent_events_lock);\n\n\t\treturn (age <= zfs_zevent_retain_expire_secs);\n\t}\n\n\tif (avl_numnodes(&recent_events_tree) >= zfs_zevent_retain_max) {\n\t\t \n\t\tentry = list_tail(&recent_events_list);\n\t\tASSERT(entry != NULL);\n\t\tlist_remove(&recent_events_list, entry);\n\t\tavl_remove(&recent_events_tree, entry);\n\t} else {\n\t\tentry = kmem_alloc(sizeof (recent_events_node_t), KM_SLEEP);\n\t}\n\n\t \n\t*entry = search;\n\tavl_add(&recent_events_tree, entry);\n\tlist_insert_head(&recent_events_list, entry);\n\tentry->re_timestamp = now;\n\n\t \n\tif (recent_events_cleaner_tqid == 0)\n\t\tzfs_ereport_schedule_cleaner();\n\n\tmutex_exit(&recent_events_lock);\n\treturn (B_FALSE);\n}\n\nvoid\nzfs_zevent_post_cb(nvlist_t *nvl, nvlist_t *detector)\n{\n\tif (nvl)\n\t\tfm_nvlist_destroy(nvl, FM_NVA_FREE);\n\n\tif (detector)\n\t\tfm_nvlist_destroy(detector, FM_NVA_FREE);\n}\n\n \nstatic int\nzfs_is_ratelimiting_event(const char *subclass, vdev_t *vd)\n{\n\tint rc = 0;\n\t \n\tif (strcmp(subclass, FM_EREPORT_ZFS_DELAY) == 0) {\n\t\trc = !zfs_ratelimit(&vd->vdev_delay_rl);\n\t} else if (strcmp(subclass, FM_EREPORT_ZFS_DEADMAN) == 0) {\n\t\trc = !zfs_ratelimit(&vd->vdev_deadman_rl);\n\t} else if (strcmp(subclass, FM_EREPORT_ZFS_CHECKSUM) == 0) {\n\t\trc = !zfs_ratelimit(&vd->vdev_checksum_rl);\n\t}\n\n\tif (rc)\t{\n\t\t \n\t\tfm_erpt_dropped_increment();\n\t}\n\n\treturn (rc);\n}\n\n \nstatic boolean_t\nzfs_ereport_start(nvlist_t **ereport_out, nvlist_t **detector_out,\n    const char *subclass, spa_t *spa, vdev_t *vd, const zbookmark_phys_t *zb,\n    zio_t *zio, uint64_t stateoroffset, uint64_t size)\n{\n\tnvlist_t *ereport, *detector;\n\n\tuint64_t ena;\n\tchar class[64];\n\n\tif ((ereport = fm_nvlist_create(NULL)) == NULL)\n\t\treturn (B_FALSE);\n\n\tif ((detector = fm_nvlist_create(NULL)) == NULL) {\n\t\tfm_nvlist_destroy(ereport, FM_NVA_FREE);\n\t\treturn (B_FALSE);\n\t}\n\n\t \n\tmutex_enter(&spa->spa_errlist_lock);\n\n\t \n\tif (spa_load_state(spa) != SPA_LOAD_NONE) {\n\t\tif (spa->spa_ena == 0)\n\t\t\tspa->spa_ena = fm_ena_generate(0, FM_ENA_FMT1);\n\t\tena = spa->spa_ena;\n\t} else if (zio != NULL && zio->io_logical != NULL) {\n\t\tif (zio->io_logical->io_ena == 0)\n\t\t\tzio->io_logical->io_ena =\n\t\t\t    fm_ena_generate(0, FM_ENA_FMT1);\n\t\tena = zio->io_logical->io_ena;\n\t} else {\n\t\tena = fm_ena_generate(0, FM_ENA_FMT1);\n\t}\n\n\t \n\t(void) snprintf(class, sizeof (class), \"%s.%s\",\n\t    ZFS_ERROR_CLASS, subclass);\n\n\tfm_fmri_zfs_set(detector, FM_ZFS_SCHEME_VERSION, spa_guid(spa),\n\t    vd != NULL ? vd->vdev_guid : 0);\n\n\tfm_ereport_set(ereport, FM_EREPORT_VERSION, class, ena, detector, NULL);\n\n\t \n\n\t \n\tfm_payload_set(ereport,\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL, DATA_TYPE_STRING, spa_name(spa),\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_GUID, DATA_TYPE_UINT64, spa_guid(spa),\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_STATE, DATA_TYPE_UINT64,\n\t    (uint64_t)spa_state(spa),\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_CONTEXT, DATA_TYPE_INT32,\n\t    (int32_t)spa_load_state(spa), NULL);\n\n\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_POOL_FAILMODE,\n\t    DATA_TYPE_STRING,\n\t    spa_get_failmode(spa) == ZIO_FAILURE_MODE_WAIT ?\n\t    FM_EREPORT_FAILMODE_WAIT :\n\t    spa_get_failmode(spa) == ZIO_FAILURE_MODE_CONTINUE ?\n\t    FM_EREPORT_FAILMODE_CONTINUE : FM_EREPORT_FAILMODE_PANIC,\n\t    NULL);\n\n\tif (vd != NULL) {\n\t\tvdev_t *pvd = vd->vdev_parent;\n\t\tvdev_queue_t *vq = &vd->vdev_queue;\n\t\tvdev_stat_t *vs = &vd->vdev_stat;\n\t\tvdev_t *spare_vd;\n\t\tuint64_t *spare_guids;\n\t\tchar **spare_paths;\n\t\tint i, spare_count;\n\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID,\n\t\t    DATA_TYPE_UINT64, vd->vdev_guid,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE,\n\t\t    DATA_TYPE_STRING, vd->vdev_ops->vdev_op_type, NULL);\n\t\tif (vd->vdev_path != NULL)\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_PATH,\n\t\t\t    DATA_TYPE_STRING, vd->vdev_path, NULL);\n\t\tif (vd->vdev_devid != NULL)\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_DEVID,\n\t\t\t    DATA_TYPE_STRING, vd->vdev_devid, NULL);\n\t\tif (vd->vdev_fru != NULL)\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_FRU,\n\t\t\t    DATA_TYPE_STRING, vd->vdev_fru, NULL);\n\t\tif (vd->vdev_enc_sysfs_path != NULL)\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_ENC_SYSFS_PATH,\n\t\t\t    DATA_TYPE_STRING, vd->vdev_enc_sysfs_path, NULL);\n\t\tif (vd->vdev_ashift)\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_ASHIFT,\n\t\t\t    DATA_TYPE_UINT64, vd->vdev_ashift, NULL);\n\n\t\tif (vq != NULL) {\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_COMP_TS,\n\t\t\t    DATA_TYPE_UINT64, vq->vq_io_complete_ts, NULL);\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_DELTA_TS,\n\t\t\t    DATA_TYPE_UINT64, vq->vq_io_delta_ts, NULL);\n\t\t}\n\n\t\tif (vs != NULL) {\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_READ_ERRORS,\n\t\t\t    DATA_TYPE_UINT64, vs->vs_read_errors,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_WRITE_ERRORS,\n\t\t\t    DATA_TYPE_UINT64, vs->vs_write_errors,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_CKSUM_ERRORS,\n\t\t\t    DATA_TYPE_UINT64, vs->vs_checksum_errors,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_DELAYS,\n\t\t\t    DATA_TYPE_UINT64, vs->vs_slow_ios,\n\t\t\t    NULL);\n\t\t}\n\n\t\tif (pvd != NULL) {\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_PARENT_GUID,\n\t\t\t    DATA_TYPE_UINT64, pvd->vdev_guid,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_PARENT_TYPE,\n\t\t\t    DATA_TYPE_STRING, pvd->vdev_ops->vdev_op_type,\n\t\t\t    NULL);\n\t\t\tif (pvd->vdev_path)\n\t\t\t\tfm_payload_set(ereport,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_PARENT_PATH,\n\t\t\t\t    DATA_TYPE_STRING, pvd->vdev_path, NULL);\n\t\t\tif (pvd->vdev_devid)\n\t\t\t\tfm_payload_set(ereport,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_PARENT_DEVID,\n\t\t\t\t    DATA_TYPE_STRING, pvd->vdev_devid, NULL);\n\t\t}\n\n\t\tspare_count = spa->spa_spares.sav_count;\n\t\tspare_paths = kmem_zalloc(sizeof (char *) * spare_count,\n\t\t    KM_SLEEP);\n\t\tspare_guids = kmem_zalloc(sizeof (uint64_t) * spare_count,\n\t\t    KM_SLEEP);\n\n\t\tfor (i = 0; i < spare_count; i++) {\n\t\t\tspare_vd = spa->spa_spares.sav_vdevs[i];\n\t\t\tif (spare_vd) {\n\t\t\t\tspare_paths[i] = spare_vd->vdev_path;\n\t\t\t\tspare_guids[i] = spare_vd->vdev_guid;\n\t\t\t}\n\t\t}\n\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_VDEV_SPARE_PATHS,\n\t\t    DATA_TYPE_STRING_ARRAY, spare_count, spare_paths,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_SPARE_GUIDS,\n\t\t    DATA_TYPE_UINT64_ARRAY, spare_count, spare_guids, NULL);\n\n\t\tkmem_free(spare_guids, sizeof (uint64_t) * spare_count);\n\t\tkmem_free(spare_paths, sizeof (char *) * spare_count);\n\t}\n\n\tif (zio != NULL) {\n\t\t \n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_ERR,\n\t\t    DATA_TYPE_INT32, zio->io_error, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_FLAGS,\n\t\t    DATA_TYPE_INT32, zio->io_flags, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_STAGE,\n\t\t    DATA_TYPE_UINT32, zio->io_stage, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_PIPELINE,\n\t\t    DATA_TYPE_UINT32, zio->io_pipeline, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_DELAY,\n\t\t    DATA_TYPE_UINT64, zio->io_delay, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_TIMESTAMP,\n\t\t    DATA_TYPE_UINT64, zio->io_timestamp, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_DELTA,\n\t\t    DATA_TYPE_UINT64, zio->io_delta, NULL);\n\t\tfm_payload_set(ereport, FM_EREPORT_PAYLOAD_ZFS_ZIO_PRIORITY,\n\t\t    DATA_TYPE_UINT32, zio->io_priority, NULL);\n\n\t\t \n\t\tif (vd != NULL) {\n\t\t\tif (size)\n\t\t\t\tfm_payload_set(ereport,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_OFFSET,\n\t\t\t\t    DATA_TYPE_UINT64, stateoroffset,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_SIZE,\n\t\t\t\t    DATA_TYPE_UINT64, size, NULL);\n\t\t\telse\n\t\t\t\tfm_payload_set(ereport,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_OFFSET,\n\t\t\t\t    DATA_TYPE_UINT64, zio->io_offset,\n\t\t\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_SIZE,\n\t\t\t\t    DATA_TYPE_UINT64, zio->io_size, NULL);\n\t\t}\n\t} else if (vd != NULL) {\n\t\t \n\t\tfm_payload_set(ereport,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_PREV_STATE,\n\t\t    DATA_TYPE_UINT64, stateoroffset, NULL);\n\t}\n\n\t \n\tif (zb != NULL && (zio == NULL || zio->io_logical != NULL)) {\n\t\tfm_payload_set(ereport,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_OBJSET,\n\t\t    DATA_TYPE_UINT64, zb->zb_objset,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_OBJECT,\n\t\t    DATA_TYPE_UINT64, zb->zb_object,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_LEVEL,\n\t\t    DATA_TYPE_INT64, zb->zb_level,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_ZIO_BLKID,\n\t\t    DATA_TYPE_UINT64, zb->zb_blkid, NULL);\n\t}\n\n\t \n\tif (vd != NULL && strcmp(subclass, FM_EREPORT_ZFS_CHECKSUM) == 0) {\n\t\tuint64_t cksum_n, cksum_t;\n\n\t\tcksum_n = vdev_prop_get_inherited(vd, VDEV_PROP_CHECKSUM_N);\n\t\tif (cksum_n != vdev_prop_default_numeric(VDEV_PROP_CHECKSUM_N))\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_CKSUM_N,\n\t\t\t    DATA_TYPE_UINT64,\n\t\t\t    cksum_n,\n\t\t\t    NULL);\n\n\t\tcksum_t = vdev_prop_get_inherited(vd, VDEV_PROP_CHECKSUM_T);\n\t\tif (cksum_t != vdev_prop_default_numeric(VDEV_PROP_CHECKSUM_T))\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_CKSUM_T,\n\t\t\t    DATA_TYPE_UINT64,\n\t\t\t    cksum_t,\n\t\t\t    NULL);\n\t}\n\n\tif (vd != NULL && strcmp(subclass, FM_EREPORT_ZFS_IO) == 0) {\n\t\tuint64_t io_n, io_t;\n\n\t\tio_n = vdev_prop_get_inherited(vd, VDEV_PROP_IO_N);\n\t\tif (io_n != vdev_prop_default_numeric(VDEV_PROP_IO_N))\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_IO_N,\n\t\t\t    DATA_TYPE_UINT64,\n\t\t\t    io_n,\n\t\t\t    NULL);\n\n\t\tio_t = vdev_prop_get_inherited(vd, VDEV_PROP_IO_T);\n\t\tif (io_t != vdev_prop_default_numeric(VDEV_PROP_IO_T))\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_IO_T,\n\t\t\t    DATA_TYPE_UINT64,\n\t\t\t    io_t,\n\t\t\t    NULL);\n\t}\n\n\tmutex_exit(&spa->spa_errlist_lock);\n\n\t*ereport_out = ereport;\n\t*detector_out = detector;\n\treturn (B_TRUE);\n}\n\n \n#define\tZFM_MAX_INLINE\t\t(128 / sizeof (uint64_t))\n\n#define\tMAX_RANGES\t\t16\n\ntypedef struct zfs_ecksum_info {\n\t \n\tuint64_t zei_bits_set[ZFM_MAX_INLINE];\n\tuint64_t zei_bits_cleared[ZFM_MAX_INLINE];\n\n\t \n\tuint32_t zei_range_sets[MAX_RANGES];\n\tuint32_t zei_range_clears[MAX_RANGES];\n\n\tstruct zei_ranges {\n\t\tuint32_t\tzr_start;\n\t\tuint32_t\tzr_end;\n\t} zei_ranges[MAX_RANGES];\n\n\tsize_t\tzei_range_count;\n\tuint32_t zei_mingap;\n\tuint32_t zei_allowed_mingap;\n\n} zfs_ecksum_info_t;\n\nstatic void\nupdate_bad_bits(uint64_t value_arg, uint32_t *count)\n{\n\tsize_t i;\n\tsize_t bits = 0;\n\tuint64_t value = BE_64(value_arg);\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\tif (value & (1ull << i))\n\t\t\t++bits;\n\t}\n\t \n\t*count += bits;\n}\n\n \nstatic void\nzei_shrink_ranges(zfs_ecksum_info_t *eip)\n{\n\tuint32_t mingap = UINT32_MAX;\n\tuint32_t new_allowed_gap = eip->zei_mingap + 1;\n\n\tsize_t idx, output;\n\tsize_t max = eip->zei_range_count;\n\n\tstruct zei_ranges *r = eip->zei_ranges;\n\n\tASSERT3U(eip->zei_range_count, >, 0);\n\tASSERT3U(eip->zei_range_count, <=, MAX_RANGES);\n\n\toutput = idx = 0;\n\twhile (idx < max - 1) {\n\t\tuint32_t start = r[idx].zr_start;\n\t\tuint32_t end = r[idx].zr_end;\n\n\t\twhile (idx < max - 1) {\n\t\t\tidx++;\n\n\t\t\tuint32_t nstart = r[idx].zr_start;\n\t\t\tuint32_t nend = r[idx].zr_end;\n\n\t\t\tuint32_t gap = nstart - end;\n\t\t\tif (gap < new_allowed_gap) {\n\t\t\t\tend = nend;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (gap < mingap)\n\t\t\t\tmingap = gap;\n\t\t\tbreak;\n\t\t}\n\t\tr[output].zr_start = start;\n\t\tr[output].zr_end = end;\n\t\toutput++;\n\t}\n\tASSERT3U(output, <, eip->zei_range_count);\n\teip->zei_range_count = output;\n\teip->zei_mingap = mingap;\n\teip->zei_allowed_mingap = new_allowed_gap;\n}\n\nstatic void\nzei_add_range(zfs_ecksum_info_t *eip, int start, int end)\n{\n\tstruct zei_ranges *r = eip->zei_ranges;\n\tsize_t count = eip->zei_range_count;\n\n\tif (count >= MAX_RANGES) {\n\t\tzei_shrink_ranges(eip);\n\t\tcount = eip->zei_range_count;\n\t}\n\tif (count == 0) {\n\t\teip->zei_mingap = UINT32_MAX;\n\t\teip->zei_allowed_mingap = 1;\n\t} else {\n\t\tint gap = start - r[count - 1].zr_end;\n\n\t\tif (gap < eip->zei_allowed_mingap) {\n\t\t\tr[count - 1].zr_end = end;\n\t\t\treturn;\n\t\t}\n\t\tif (gap < eip->zei_mingap)\n\t\t\teip->zei_mingap = gap;\n\t}\n\tr[count].zr_start = start;\n\tr[count].zr_end = end;\n\teip->zei_range_count++;\n}\n\nstatic size_t\nzei_range_total_size(zfs_ecksum_info_t *eip)\n{\n\tstruct zei_ranges *r = eip->zei_ranges;\n\tsize_t count = eip->zei_range_count;\n\tsize_t result = 0;\n\tsize_t idx;\n\n\tfor (idx = 0; idx < count; idx++)\n\t\tresult += (r[idx].zr_end - r[idx].zr_start);\n\n\treturn (result);\n}\n\nstatic zfs_ecksum_info_t *\nannotate_ecksum(nvlist_t *ereport, zio_bad_cksum_t *info,\n    const abd_t *goodabd, const abd_t *badabd, size_t size,\n    boolean_t drop_if_identical)\n{\n\tconst uint64_t *good;\n\tconst uint64_t *bad;\n\n\tsize_t nui64s = size / sizeof (uint64_t);\n\n\tsize_t inline_size;\n\tint no_inline = 0;\n\tsize_t idx;\n\tsize_t range;\n\n\tsize_t offset = 0;\n\tssize_t start = -1;\n\n\tzfs_ecksum_info_t *eip = kmem_zalloc(sizeof (*eip), KM_SLEEP);\n\n\t \n\tif (info != NULL && info->zbc_injected)\n\t\treturn (eip);\n\n\tif (info != NULL && info->zbc_has_cksum) {\n\t\tfm_payload_set(ereport,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_CKSUM_ALGO,\n\t\t    DATA_TYPE_STRING,\n\t\t    info->zbc_checksum_name,\n\t\t    NULL);\n\n\t\tif (info->zbc_byteswapped) {\n\t\t\tfm_payload_set(ereport,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_CKSUM_BYTESWAP,\n\t\t\t    DATA_TYPE_BOOLEAN, 1,\n\t\t\t    NULL);\n\t\t}\n\t}\n\n\tif (badabd == NULL || goodabd == NULL)\n\t\treturn (eip);\n\n\tASSERT3U(nui64s, <=, UINT32_MAX);\n\tASSERT3U(size, ==, nui64s * sizeof (uint64_t));\n\tASSERT3U(size, <=, SPA_MAXBLOCKSIZE);\n\tASSERT3U(size, <=, UINT32_MAX);\n\n\tgood = (const uint64_t *) abd_borrow_buf_copy((abd_t *)goodabd, size);\n\tbad = (const uint64_t *) abd_borrow_buf_copy((abd_t *)badabd, size);\n\n\t \n\tfor (idx = 0; idx < nui64s; idx++) {\n\t\tif (good[idx] == bad[idx]) {\n\t\t\tif (start == -1)\n\t\t\t\tcontinue;\n\n\t\t\tzei_add_range(eip, start, idx);\n\t\t\tstart = -1;\n\t\t} else {\n\t\t\tif (start != -1)\n\t\t\t\tcontinue;\n\n\t\t\tstart = idx;\n\t\t}\n\t}\n\tif (start != -1)\n\t\tzei_add_range(eip, start, idx);\n\n\t \n\tinline_size = zei_range_total_size(eip);\n\tif (inline_size > ZFM_MAX_INLINE)\n\t\tno_inline = 1;\n\n\t \n\tif (inline_size == 0 && drop_if_identical) {\n\t\tkmem_free(eip, sizeof (*eip));\n\t\tabd_return_buf((abd_t *)goodabd, (void *)good, size);\n\t\tabd_return_buf((abd_t *)badabd, (void *)bad, size);\n\t\treturn (NULL);\n\t}\n\n\t \n\tfor (range = 0; range < eip->zei_range_count; range++) {\n\t\tsize_t start = eip->zei_ranges[range].zr_start;\n\t\tsize_t end = eip->zei_ranges[range].zr_end;\n\n\t\tfor (idx = start; idx < end; idx++) {\n\t\t\tuint64_t set, cleared;\n\n\t\t\t \n\t\t\tset = ((~good[idx]) & bad[idx]);\n\t\t\t \n\t\t\tcleared = (good[idx] & (~bad[idx]));\n\n\t\t\tif (!no_inline) {\n\t\t\t\tASSERT3U(offset, <, inline_size);\n\t\t\t\teip->zei_bits_set[offset] = set;\n\t\t\t\teip->zei_bits_cleared[offset] = cleared;\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tupdate_bad_bits(set, &eip->zei_range_sets[range]);\n\t\t\tupdate_bad_bits(cleared, &eip->zei_range_clears[range]);\n\t\t}\n\n\t\t \n\t\teip->zei_ranges[range].zr_start\t*= sizeof (uint64_t);\n\t\teip->zei_ranges[range].zr_end\t*= sizeof (uint64_t);\n\t}\n\n\tabd_return_buf((abd_t *)goodabd, (void *)good, size);\n\tabd_return_buf((abd_t *)badabd, (void *)bad, size);\n\n\teip->zei_allowed_mingap\t*= sizeof (uint64_t);\n\tinline_size\t\t*= sizeof (uint64_t);\n\n\t \n\tfm_payload_set(ereport,\n\t    FM_EREPORT_PAYLOAD_ZFS_BAD_OFFSET_RANGES,\n\t    DATA_TYPE_UINT32_ARRAY, 2 * eip->zei_range_count,\n\t    (uint32_t *)eip->zei_ranges,\n\t    FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_MIN_GAP,\n\t    DATA_TYPE_UINT32, eip->zei_allowed_mingap,\n\t    FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_SETS,\n\t    DATA_TYPE_UINT32_ARRAY, eip->zei_range_count, eip->zei_range_sets,\n\t    FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_CLEARS,\n\t    DATA_TYPE_UINT32_ARRAY, eip->zei_range_count, eip->zei_range_clears,\n\t    NULL);\n\n\tif (!no_inline) {\n\t\tfm_payload_set(ereport,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_BAD_SET_BITS,\n\t\t    DATA_TYPE_UINT8_ARRAY,\n\t\t    inline_size, (uint8_t *)eip->zei_bits_set,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_BAD_CLEARED_BITS,\n\t\t    DATA_TYPE_UINT8_ARRAY,\n\t\t    inline_size, (uint8_t *)eip->zei_bits_cleared,\n\t\t    NULL);\n\t}\n\treturn (eip);\n}\n#else\nvoid\nzfs_ereport_clear(spa_t *spa, vdev_t *vd)\n{\n\t(void) spa, (void) vd;\n}\n#endif\n\n \nboolean_t\nzfs_ereport_is_valid(const char *subclass, spa_t *spa, vdev_t *vd, zio_t *zio)\n{\n#ifdef _KERNEL\n\t \n\tif (spa_load_state(spa) == SPA_LOAD_TRYIMPORT ||\n\t    spa_load_state(spa) == SPA_LOAD_RECOVER)\n\t\treturn (B_FALSE);\n\n\t \n\tif (spa_load_state(spa) != SPA_LOAD_NONE &&\n\t    spa->spa_last_open_failed)\n\t\treturn (B_FALSE);\n\n\tif (zio != NULL) {\n\t\t \n\t\tif (zio->io_type != ZIO_TYPE_READ &&\n\t\t    zio->io_type != ZIO_TYPE_WRITE)\n\t\t\treturn (B_FALSE);\n\n\t\tif (vd != NULL) {\n\t\t\t \n\t\t\tif (zio->io_vd == vd && !vdev_accessible(vd, zio))\n\t\t\t\treturn (B_FALSE);\n\n\t\t\t \n\t\t\tif (zio->io_type == ZIO_TYPE_READ &&\n\t\t\t    zio->io_error == ECKSUM &&\n\t\t\t    vd->vdev_ops->vdev_op_leaf &&\n\t\t\t    vdev_dtl_contains(vd, DTL_MISSING, zio->io_txg, 1))\n\t\t\t\treturn (B_FALSE);\n\t\t}\n\t}\n\n\t \n\tif (vd != NULL &&\n\t    strcmp(subclass, FM_EREPORT_ZFS_PROBE_FAILURE) == 0 &&\n\t    (vd->vdev_remove_wanted || vd->vdev_state == VDEV_STATE_REMOVED))\n\t\treturn (B_FALSE);\n\n\t \n\tif ((strcmp(subclass, FM_EREPORT_ZFS_DELAY) == 0) &&\n\t    (zio != NULL) && (!zio->io_timestamp)) {\n\t\treturn (B_FALSE);\n\t}\n#else\n\t(void) subclass, (void) spa, (void) vd, (void) zio;\n#endif\n\treturn (B_TRUE);\n}\n\n \nint\nzfs_ereport_post(const char *subclass, spa_t *spa, vdev_t *vd,\n    const zbookmark_phys_t *zb, zio_t *zio, uint64_t state)\n{\n\tint rc = 0;\n#ifdef _KERNEL\n\tnvlist_t *ereport = NULL;\n\tnvlist_t *detector = NULL;\n\n\tif (!zfs_ereport_is_valid(subclass, spa, vd, zio))\n\t\treturn (EINVAL);\n\n\tif (zfs_ereport_is_duplicate(subclass, spa, vd, zb, zio, 0, 0))\n\t\treturn (SET_ERROR(EALREADY));\n\n\tif (zfs_is_ratelimiting_event(subclass, vd))\n\t\treturn (SET_ERROR(EBUSY));\n\n\tif (!zfs_ereport_start(&ereport, &detector, subclass, spa, vd,\n\t    zb, zio, state, 0))\n\t\treturn (SET_ERROR(EINVAL));\t \n\n\tif (ereport == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\trc = zfs_zevent_post(ereport, detector, zfs_zevent_post_cb);\n#else\n\t(void) subclass, (void) spa, (void) vd, (void) zb, (void) zio,\n\t    (void) state;\n#endif\n\treturn (rc);\n}\n\n \nint\nzfs_ereport_start_checksum(spa_t *spa, vdev_t *vd, const zbookmark_phys_t *zb,\n    struct zio *zio, uint64_t offset, uint64_t length, zio_bad_cksum_t *info)\n{\n\tzio_cksum_report_t *report;\n\n#ifdef _KERNEL\n\tif (!zfs_ereport_is_valid(FM_EREPORT_ZFS_CHECKSUM, spa, vd, zio))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zfs_ereport_is_duplicate(FM_EREPORT_ZFS_CHECKSUM, spa, vd, zb, zio,\n\t    offset, length))\n\t\treturn (SET_ERROR(EALREADY));\n\n\tif (zfs_is_ratelimiting_event(FM_EREPORT_ZFS_CHECKSUM, vd))\n\t\treturn (SET_ERROR(EBUSY));\n#else\n\t(void) zb, (void) offset;\n#endif\n\n\treport = kmem_zalloc(sizeof (*report), KM_SLEEP);\n\n\tzio_vsd_default_cksum_report(zio, report);\n\n\t \n\tif (info != NULL) {\n\t\treport->zcr_ckinfo = kmem_zalloc(sizeof (*info), KM_SLEEP);\n\t\tmemcpy(report->zcr_ckinfo, info, sizeof (*info));\n\t}\n\n\treport->zcr_sector = 1ULL << vd->vdev_top->vdev_ashift;\n\treport->zcr_align =\n\t    vdev_psize_to_asize(vd->vdev_top, report->zcr_sector);\n\treport->zcr_length = length;\n\n#ifdef _KERNEL\n\t(void) zfs_ereport_start(&report->zcr_ereport, &report->zcr_detector,\n\t    FM_EREPORT_ZFS_CHECKSUM, spa, vd, zb, zio, offset, length);\n\n\tif (report->zcr_ereport == NULL) {\n\t\tzfs_ereport_free_checksum(report);\n\t\treturn (0);\n\t}\n#endif\n\n\tmutex_enter(&spa->spa_errlist_lock);\n\treport->zcr_next = zio->io_logical->io_cksum_report;\n\tzio->io_logical->io_cksum_report = report;\n\tmutex_exit(&spa->spa_errlist_lock);\n\treturn (0);\n}\n\nvoid\nzfs_ereport_finish_checksum(zio_cksum_report_t *report, const abd_t *good_data,\n    const abd_t *bad_data, boolean_t drop_if_identical)\n{\n#ifdef _KERNEL\n\tzfs_ecksum_info_t *info;\n\n\tinfo = annotate_ecksum(report->zcr_ereport, report->zcr_ckinfo,\n\t    good_data, bad_data, report->zcr_length, drop_if_identical);\n\tif (info != NULL)\n\t\tzfs_zevent_post(report->zcr_ereport,\n\t\t    report->zcr_detector, zfs_zevent_post_cb);\n\telse\n\t\tzfs_zevent_post_cb(report->zcr_ereport, report->zcr_detector);\n\n\treport->zcr_ereport = report->zcr_detector = NULL;\n\tif (info != NULL)\n\t\tkmem_free(info, sizeof (*info));\n#else\n\t(void) report, (void) good_data, (void) bad_data,\n\t    (void) drop_if_identical;\n#endif\n}\n\nvoid\nzfs_ereport_free_checksum(zio_cksum_report_t *rpt)\n{\n#ifdef _KERNEL\n\tif (rpt->zcr_ereport != NULL) {\n\t\tfm_nvlist_destroy(rpt->zcr_ereport,\n\t\t    FM_NVA_FREE);\n\t\tfm_nvlist_destroy(rpt->zcr_detector,\n\t\t    FM_NVA_FREE);\n\t}\n#endif\n\trpt->zcr_free(rpt->zcr_cbdata, rpt->zcr_cbinfo);\n\n\tif (rpt->zcr_ckinfo != NULL)\n\t\tkmem_free(rpt->zcr_ckinfo, sizeof (*rpt->zcr_ckinfo));\n\n\tkmem_free(rpt, sizeof (*rpt));\n}\n\n \nint\nzfs_ereport_post_checksum(spa_t *spa, vdev_t *vd, const zbookmark_phys_t *zb,\n    struct zio *zio, uint64_t offset, uint64_t length,\n    const abd_t *good_data, const abd_t *bad_data, zio_bad_cksum_t *zbc)\n{\n\tint rc = 0;\n#ifdef _KERNEL\n\tnvlist_t *ereport = NULL;\n\tnvlist_t *detector = NULL;\n\tzfs_ecksum_info_t *info;\n\n\tif (!zfs_ereport_is_valid(FM_EREPORT_ZFS_CHECKSUM, spa, vd, zio))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zfs_ereport_is_duplicate(FM_EREPORT_ZFS_CHECKSUM, spa, vd, zb, zio,\n\t    offset, length))\n\t\treturn (SET_ERROR(EALREADY));\n\n\tif (zfs_is_ratelimiting_event(FM_EREPORT_ZFS_CHECKSUM, vd))\n\t\treturn (SET_ERROR(EBUSY));\n\n\tif (!zfs_ereport_start(&ereport, &detector, FM_EREPORT_ZFS_CHECKSUM,\n\t    spa, vd, zb, zio, offset, length) || (ereport == NULL)) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tinfo = annotate_ecksum(ereport, zbc, good_data, bad_data, length,\n\t    B_FALSE);\n\n\tif (info != NULL) {\n\t\trc = zfs_zevent_post(ereport, detector, zfs_zevent_post_cb);\n\t\tkmem_free(info, sizeof (*info));\n\t}\n#else\n\t(void) spa, (void) vd, (void) zb, (void) zio, (void) offset,\n\t    (void) length, (void) good_data, (void) bad_data, (void) zbc;\n#endif\n\treturn (rc);\n}\n\n \nnvlist_t *\nzfs_event_create(spa_t *spa, vdev_t *vd, const char *type, const char *name,\n    nvlist_t *aux)\n{\n\tnvlist_t *resource = NULL;\n#ifdef _KERNEL\n\tchar class[64];\n\n\tif (spa_load_state(spa) == SPA_LOAD_TRYIMPORT)\n\t\treturn (NULL);\n\n\tif ((resource = fm_nvlist_create(NULL)) == NULL)\n\t\treturn (NULL);\n\n\t(void) snprintf(class, sizeof (class), \"%s.%s.%s\", type,\n\t    ZFS_ERROR_CLASS, name);\n\tVERIFY0(nvlist_add_uint8(resource, FM_VERSION, FM_RSRC_VERSION));\n\tVERIFY0(nvlist_add_string(resource, FM_CLASS, class));\n\tVERIFY0(nvlist_add_string(resource,\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL, spa_name(spa)));\n\tVERIFY0(nvlist_add_uint64(resource,\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_GUID, spa_guid(spa)));\n\tVERIFY0(nvlist_add_uint64(resource,\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_STATE, spa_state(spa)));\n\tVERIFY0(nvlist_add_int32(resource,\n\t    FM_EREPORT_PAYLOAD_ZFS_POOL_CONTEXT, spa_load_state(spa)));\n\n\tif (vd) {\n\t\tVERIFY0(nvlist_add_uint64(resource,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID, vd->vdev_guid));\n\t\tVERIFY0(nvlist_add_uint64(resource,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_STATE, vd->vdev_state));\n\t\tif (vd->vdev_path != NULL)\n\t\t\tVERIFY0(nvlist_add_string(resource,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_PATH, vd->vdev_path));\n\t\tif (vd->vdev_devid != NULL)\n\t\t\tVERIFY0(nvlist_add_string(resource,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_DEVID, vd->vdev_devid));\n\t\tif (vd->vdev_fru != NULL)\n\t\t\tVERIFY0(nvlist_add_string(resource,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_FRU, vd->vdev_fru));\n\t\tif (vd->vdev_enc_sysfs_path != NULL)\n\t\t\tVERIFY0(nvlist_add_string(resource,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_ENC_SYSFS_PATH,\n\t\t\t    vd->vdev_enc_sysfs_path));\n\t}\n\n\t \n\tif (aux) {\n\t\tnvpair_t *elem = NULL;\n\n\t\twhile ((elem = nvlist_next_nvpair(aux, elem)) != NULL)\n\t\t\t(void) nvlist_add_nvpair(resource, elem);\n\t}\n#else\n\t(void) spa, (void) vd, (void) type, (void) name, (void) aux;\n#endif\n\treturn (resource);\n}\n\nstatic void\nzfs_post_common(spa_t *spa, vdev_t *vd, const char *type, const char *name,\n    nvlist_t *aux)\n{\n#ifdef _KERNEL\n\tnvlist_t *resource;\n\n\tresource = zfs_event_create(spa, vd, type, name, aux);\n\tif (resource)\n\t\tzfs_zevent_post(resource, NULL, zfs_zevent_post_cb);\n#else\n\t(void) spa, (void) vd, (void) type, (void) name, (void) aux;\n#endif\n}\n\n \nvoid\nzfs_post_remove(spa_t *spa, vdev_t *vd)\n{\n\tzfs_post_common(spa, vd, FM_RSRC_CLASS, FM_RESOURCE_REMOVED, NULL);\n}\n\n \nvoid\nzfs_post_autoreplace(spa_t *spa, vdev_t *vd)\n{\n\tzfs_post_common(spa, vd, FM_RSRC_CLASS, FM_RESOURCE_AUTOREPLACE, NULL);\n}\n\n \nvoid\nzfs_post_state_change(spa_t *spa, vdev_t *vd, uint64_t laststate)\n{\n#ifdef _KERNEL\n\tnvlist_t *aux;\n\n\t \n\taux = fm_nvlist_create(NULL);\n\tif (vd && aux) {\n\t\tif (vd->vdev_physpath) {\n\t\t\tfnvlist_add_string(aux,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_PHYSPATH,\n\t\t\t    vd->vdev_physpath);\n\t\t}\n\t\tif (vd->vdev_enc_sysfs_path) {\n\t\t\tfnvlist_add_string(aux,\n\t\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_ENC_SYSFS_PATH,\n\t\t\t    vd->vdev_enc_sysfs_path);\n\t\t}\n\n\t\tfnvlist_add_uint64(aux,\n\t\t    FM_EREPORT_PAYLOAD_ZFS_VDEV_LASTSTATE, laststate);\n\t}\n\n\tzfs_post_common(spa, vd, FM_RSRC_CLASS, FM_RESOURCE_STATECHANGE,\n\t    aux);\n\n\tif (aux)\n\t\tfm_nvlist_destroy(aux, FM_NVA_FREE);\n#else\n\t(void) spa, (void) vd, (void) laststate;\n#endif\n}\n\n#ifdef _KERNEL\nvoid\nzfs_ereport_init(void)\n{\n\tmutex_init(&recent_events_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&recent_events_list, sizeof (recent_events_node_t),\n\t    offsetof(recent_events_node_t, re_list_link));\n\tavl_create(&recent_events_tree,  recent_events_compare,\n\t    sizeof (recent_events_node_t), offsetof(recent_events_node_t,\n\t    re_tree_link));\n}\n\n \nvoid\nzfs_ereport_taskq_fini(void)\n{\n\tmutex_enter(&recent_events_lock);\n\tif (recent_events_cleaner_tqid != 0) {\n\t\ttaskq_cancel_id(system_delay_taskq, recent_events_cleaner_tqid);\n\t\trecent_events_cleaner_tqid = 0;\n\t}\n\tmutex_exit(&recent_events_lock);\n}\n\nvoid\nzfs_ereport_fini(void)\n{\n\trecent_events_node_t *entry;\n\n\twhile ((entry = list_remove_head(&recent_events_list)) != NULL) {\n\t\tavl_remove(&recent_events_tree, entry);\n\t\tkmem_free(entry, sizeof (*entry));\n\t}\n\tavl_destroy(&recent_events_tree);\n\tlist_destroy(&recent_events_list);\n\tmutex_destroy(&recent_events_lock);\n}\n\nvoid\nzfs_ereport_snapshot_post(const char *subclass, spa_t *spa, const char *name)\n{\n\tnvlist_t *aux;\n\n\taux = fm_nvlist_create(NULL);\n\tfnvlist_add_string(aux, FM_EREPORT_PAYLOAD_ZFS_SNAPSHOT_NAME, name);\n\n\tzfs_post_common(spa, NULL, FM_RSRC_CLASS, subclass, aux);\n\tfm_nvlist_destroy(aux, FM_NVA_FREE);\n}\n\n \nvoid\nzfs_ereport_zvol_post(const char *subclass, const char *name,\n    const char *dev_name, const char *raw_name)\n{\n\tnvlist_t *aux;\n\tchar *r;\n\n\tboolean_t locked = mutex_owned(&spa_namespace_lock);\n\tif (!locked) mutex_enter(&spa_namespace_lock);\n\tspa_t *spa = spa_lookup(name);\n\tif (!locked) mutex_exit(&spa_namespace_lock);\n\n\tif (spa == NULL)\n\t\treturn;\n\n\taux = fm_nvlist_create(NULL);\n\tfnvlist_add_string(aux, FM_EREPORT_PAYLOAD_ZFS_DEVICE_NAME, dev_name);\n\tfnvlist_add_string(aux, FM_EREPORT_PAYLOAD_ZFS_RAW_DEVICE_NAME,\n\t    raw_name);\n\tr = strchr(name, '/');\n\tif (r && r[1])\n\t\tfnvlist_add_string(aux, FM_EREPORT_PAYLOAD_ZFS_VOLUME, &r[1]);\n\n\tzfs_post_common(spa, NULL, FM_RSRC_CLASS, subclass, aux);\n\tfm_nvlist_destroy(aux, FM_NVA_FREE);\n}\n\nEXPORT_SYMBOL(zfs_ereport_post);\nEXPORT_SYMBOL(zfs_ereport_is_valid);\nEXPORT_SYMBOL(zfs_ereport_post_checksum);\nEXPORT_SYMBOL(zfs_post_remove);\nEXPORT_SYMBOL(zfs_post_autoreplace);\nEXPORT_SYMBOL(zfs_post_state_change);\n\nZFS_MODULE_PARAM(zfs_zevent, zfs_zevent_, retain_max, UINT, ZMOD_RW,\n\t\"Maximum recent zevents records to retain for duplicate checking\");\nZFS_MODULE_PARAM(zfs_zevent, zfs_zevent_, retain_expire_secs, UINT, ZMOD_RW,\n\t\"Expiration time for recent zevents records\");\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}