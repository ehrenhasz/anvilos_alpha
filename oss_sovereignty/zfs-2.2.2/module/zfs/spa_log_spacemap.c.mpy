{
  "module_name": "spa_log_spacemap.c",
  "hash_id": "1609d71d8f1a54a22a6c4f365f8bd57a95a659ff2e3a01ec3cadffe18d90f74a",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/spa_log_spacemap.c",
  "human_readable_source": " \n\n \n\n#include <sys/dmu_objset.h>\n#include <sys/metaslab.h>\n#include <sys/metaslab_impl.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/spa_log_spacemap.h>\n#include <sys/vdev_impl.h>\n#include <sys/zap.h>\n\n \n\n \nstatic const unsigned long zfs_log_sm_blksz = 1ULL << 17;\n\n \nstatic uint64_t zfs_unflushed_max_mem_ppm = 1000;\n\n \nstatic uint64_t zfs_unflushed_max_mem_amt = 1ULL << 30;\n\n \nstatic uint_t zfs_unflushed_log_block_pct = 400;\n\n \nstatic uint64_t zfs_unflushed_log_block_min = 1000;\n\n \nstatic uint64_t zfs_unflushed_log_block_max = (1ULL << 17);\n\n \nstatic uint64_t zfs_unflushed_log_txg_max = 1000;\n\n \nstatic uint64_t zfs_max_logsm_summary_length = 10;\n\n \nstatic uint64_t zfs_min_metaslabs_to_flush = 1;\n\n \nstatic uint64_t zfs_max_log_walking = 5;\n\n \nint zfs_keep_log_spacemaps_at_export = 0;\n\nstatic uint64_t\nspa_estimate_incoming_log_blocks(spa_t *spa)\n{\n\tASSERT3U(spa_sync_pass(spa), ==, 1);\n\tuint64_t steps = 0, sum = 0;\n\tfor (spa_log_sm_t *sls = avl_last(&spa->spa_sm_logs_by_txg);\n\t    sls != NULL && steps < zfs_max_log_walking;\n\t    sls = AVL_PREV(&spa->spa_sm_logs_by_txg, sls)) {\n\t\tif (sls->sls_txg == spa_syncing_txg(spa)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tsum += sls->sls_nblocks;\n\t\tsteps++;\n\t}\n\treturn ((steps > 0) ? DIV_ROUND_UP(sum, steps) : 0);\n}\n\nuint64_t\nspa_log_sm_blocklimit(spa_t *spa)\n{\n\treturn (spa->spa_unflushed_stats.sus_blocklimit);\n}\n\nvoid\nspa_log_sm_set_blocklimit(spa_t *spa)\n{\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP)) {\n\t\tASSERT0(spa_log_sm_blocklimit(spa));\n\t\treturn;\n\t}\n\n\tuint64_t msdcount = 0;\n\tfor (log_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\t    e; e = list_next(&spa->spa_log_summary, e))\n\t\tmsdcount += e->lse_msdcount;\n\n\tuint64_t limit = msdcount * zfs_unflushed_log_block_pct / 100;\n\tspa->spa_unflushed_stats.sus_blocklimit = MIN(MAX(limit,\n\t    zfs_unflushed_log_block_min), zfs_unflushed_log_block_max);\n}\n\nuint64_t\nspa_log_sm_nblocks(spa_t *spa)\n{\n\treturn (spa->spa_unflushed_stats.sus_nblocks);\n}\n\n \nstatic void\nspa_log_summary_verify_counts(spa_t *spa)\n{\n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP));\n\n\tif ((zfs_flags & ZFS_DEBUG_LOG_SPACEMAP) == 0)\n\t\treturn;\n\n\tuint64_t ms_in_avl = avl_numnodes(&spa->spa_metaslabs_by_flushed);\n\n\tuint64_t ms_in_summary = 0, blk_in_summary = 0;\n\tfor (log_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\t    e; e = list_next(&spa->spa_log_summary, e)) {\n\t\tms_in_summary += e->lse_mscount;\n\t\tblk_in_summary += e->lse_blkcount;\n\t}\n\n\tuint64_t ms_in_logs = 0, blk_in_logs = 0;\n\tfor (spa_log_sm_t *sls = avl_first(&spa->spa_sm_logs_by_txg);\n\t    sls; sls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls)) {\n\t\tms_in_logs += sls->sls_mscount;\n\t\tblk_in_logs += sls->sls_nblocks;\n\t}\n\n\tVERIFY3U(ms_in_logs, ==, ms_in_summary);\n\tVERIFY3U(ms_in_logs, ==, ms_in_avl);\n\tVERIFY3U(blk_in_logs, ==, blk_in_summary);\n\tVERIFY3U(blk_in_logs, ==, spa_log_sm_nblocks(spa));\n}\n\nstatic boolean_t\nsummary_entry_is_full(spa_t *spa, log_summary_entry_t *e, uint64_t txg)\n{\n\tif (e->lse_end == txg)\n\t\treturn (0);\n\tif (e->lse_txgcount >= DIV_ROUND_UP(zfs_unflushed_log_txg_max,\n\t    zfs_max_logsm_summary_length))\n\t\treturn (1);\n\tuint64_t blocks_per_row = MAX(1,\n\t    DIV_ROUND_UP(spa_log_sm_blocklimit(spa),\n\t    zfs_max_logsm_summary_length));\n\treturn (blocks_per_row <= e->lse_blkcount);\n}\n\n \nvoid\nspa_log_summary_decrement_mscount(spa_t *spa, uint64_t txg, boolean_t dirty)\n{\n\t \n\tif (!spa_writeable(spa))\n\t\treturn;\n\n\tlog_summary_entry_t *target = NULL;\n\tfor (log_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\t    e != NULL; e = list_next(&spa->spa_log_summary, e)) {\n\t\tif (e->lse_start > txg)\n\t\t\tbreak;\n\t\ttarget = e;\n\t}\n\n\tif (target == NULL || target->lse_mscount == 0) {\n\t\t \n\t\tVERIFY3S(spa_load_state(spa), ==, SPA_LOAD_ERROR);\n\t\treturn;\n\t}\n\n\ttarget->lse_mscount--;\n\tif (dirty)\n\t\ttarget->lse_msdcount--;\n}\n\n \nvoid\nspa_log_summary_decrement_blkcount(spa_t *spa, uint64_t blocks_gone)\n{\n\tlog_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\tASSERT3P(e, !=, NULL);\n\tif (e->lse_txgcount > 0)\n\t\te->lse_txgcount--;\n\tfor (; e != NULL; e = list_head(&spa->spa_log_summary)) {\n\t\tif (e->lse_blkcount > blocks_gone) {\n\t\t\te->lse_blkcount -= blocks_gone;\n\t\t\tblocks_gone = 0;\n\t\t\tbreak;\n\t\t} else if (e->lse_mscount == 0) {\n\t\t\t \n\t\t\tblocks_gone -= e->lse_blkcount;\n\t\t\tlist_remove(&spa->spa_log_summary, e);\n\t\t\tkmem_free(e, sizeof (log_summary_entry_t));\n\t\t} else {\n\t\t\t \n\t\t\tVERIFY3U(blocks_gone, ==, e->lse_blkcount);\n\n\t\t\t \n\t\t\tVERIFY3P(e, ==, list_tail(&spa->spa_log_summary));\n\t\t\tASSERT3P(e, ==, list_head(&spa->spa_log_summary));\n\n\t\t\tblocks_gone = e->lse_blkcount = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tASSERT0(blocks_gone);\n}\n\nvoid\nspa_log_sm_decrement_mscount(spa_t *spa, uint64_t txg)\n{\n\tspa_log_sm_t target = { .sls_txg = txg };\n\tspa_log_sm_t *sls = avl_find(&spa->spa_sm_logs_by_txg,\n\t    &target, NULL);\n\n\tif (sls == NULL) {\n\t\t \n\t\tVERIFY3S(spa_load_state(spa), ==, SPA_LOAD_ERROR);\n\t\treturn;\n\t}\n\n\tASSERT(sls->sls_mscount > 0);\n\tsls->sls_mscount--;\n}\n\nvoid\nspa_log_sm_increment_current_mscount(spa_t *spa)\n{\n\tspa_log_sm_t *last_sls = avl_last(&spa->spa_sm_logs_by_txg);\n\tASSERT3U(last_sls->sls_txg, ==, spa_syncing_txg(spa));\n\tlast_sls->sls_mscount++;\n}\n\nstatic void\nsummary_add_data(spa_t *spa, uint64_t txg, uint64_t metaslabs_flushed,\n    uint64_t metaslabs_dirty, uint64_t nblocks)\n{\n\tlog_summary_entry_t *e = list_tail(&spa->spa_log_summary);\n\n\tif (e == NULL || summary_entry_is_full(spa, e, txg)) {\n\t\te = kmem_zalloc(sizeof (log_summary_entry_t), KM_SLEEP);\n\t\te->lse_start = e->lse_end = txg;\n\t\te->lse_txgcount = 1;\n\t\tlist_insert_tail(&spa->spa_log_summary, e);\n\t}\n\n\tASSERT3U(e->lse_start, <=, txg);\n\tif (e->lse_end < txg) {\n\t\te->lse_end = txg;\n\t\te->lse_txgcount++;\n\t}\n\te->lse_mscount += metaslabs_flushed;\n\te->lse_msdcount += metaslabs_dirty;\n\te->lse_blkcount += nblocks;\n}\n\nstatic void\nspa_log_summary_add_incoming_blocks(spa_t *spa, uint64_t nblocks)\n{\n\tsummary_add_data(spa, spa_syncing_txg(spa), 0, 0, nblocks);\n}\n\nvoid\nspa_log_summary_add_flushed_metaslab(spa_t *spa, boolean_t dirty)\n{\n\tsummary_add_data(spa, spa_syncing_txg(spa), 1, dirty ? 1 : 0, 0);\n}\n\nvoid\nspa_log_summary_dirty_flushed_metaslab(spa_t *spa, uint64_t txg)\n{\n\tlog_summary_entry_t *target = NULL;\n\tfor (log_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\t    e != NULL; e = list_next(&spa->spa_log_summary, e)) {\n\t\tif (e->lse_start > txg)\n\t\t\tbreak;\n\t\ttarget = e;\n\t}\n\tASSERT3P(target, !=, NULL);\n\tASSERT3U(target->lse_mscount, !=, 0);\n\ttarget->lse_msdcount++;\n}\n\n \nstatic uint64_t\nspa_estimate_metaslabs_to_flush(spa_t *spa)\n{\n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP));\n\tASSERT3U(spa_sync_pass(spa), ==, 1);\n\tASSERT(spa_log_sm_blocklimit(spa) != 0);\n\n\t \n\tuint64_t incoming = spa_estimate_incoming_log_blocks(spa);\n\n\t \n\tuint64_t txgs_in_future = 1;\n\n\t \n\tint64_t available_blocks =\n\t    spa_log_sm_blocklimit(spa) - spa_log_sm_nblocks(spa) - incoming;\n\n\tint64_t available_txgs = zfs_unflushed_log_txg_max;\n\tfor (log_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\t    e; e = list_next(&spa->spa_log_summary, e))\n\t\tavailable_txgs -= e->lse_txgcount;\n\n\t \n\tuint64_t total_flushes = 0;\n\n\t \n\tuint64_t max_flushes_pertxg = zfs_min_metaslabs_to_flush;\n\n\t \n\tfor (log_summary_entry_t *e = list_head(&spa->spa_log_summary);\n\t    e; e = list_next(&spa->spa_log_summary, e)) {\n\n\t\t \n\t\tif (available_blocks >= 0 && available_txgs >= 0) {\n\t\t\tuint64_t skip_txgs = (incoming == 0) ?\n\t\t\t    available_txgs + 1 : MIN(available_txgs + 1,\n\t\t\t    (available_blocks / incoming) + 1);\n\t\t\tavailable_blocks -= (skip_txgs * incoming);\n\t\t\tavailable_txgs -= skip_txgs;\n\t\t\ttxgs_in_future += skip_txgs;\n\t\t\tASSERT3S(available_blocks, >=, -incoming);\n\t\t\tASSERT3S(available_txgs, >=, -1);\n\t\t}\n\n\t\t \n\t\tASSERT(available_blocks < 0 || available_txgs < 0);\n\t\tavailable_blocks += e->lse_blkcount;\n\t\tavailable_txgs += e->lse_txgcount;\n\t\ttotal_flushes += e->lse_msdcount;\n\n\t\t \n\t\tmax_flushes_pertxg = MAX(max_flushes_pertxg,\n\t\t    DIV_ROUND_UP(total_flushes, txgs_in_future));\n\t}\n\treturn (max_flushes_pertxg);\n}\n\nuint64_t\nspa_log_sm_memused(spa_t *spa)\n{\n\treturn (spa->spa_unflushed_stats.sus_memused);\n}\n\nstatic boolean_t\nspa_log_exceeds_memlimit(spa_t *spa)\n{\n\tif (spa_log_sm_memused(spa) > zfs_unflushed_max_mem_amt)\n\t\treturn (B_TRUE);\n\n\tuint64_t system_mem_allowed = ((physmem * PAGESIZE) *\n\t    zfs_unflushed_max_mem_ppm) / 1000000;\n\tif (spa_log_sm_memused(spa) > system_mem_allowed)\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\nboolean_t\nspa_flush_all_logs_requested(spa_t *spa)\n{\n\treturn (spa->spa_log_flushall_txg != 0);\n}\n\nvoid\nspa_flush_metaslabs(spa_t *spa, dmu_tx_t *tx)\n{\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\n\tif (spa_sync_pass(spa) != 1)\n\t\treturn;\n\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP))\n\t\treturn;\n\n\t \n\tif (avl_numnodes(&spa->spa_metaslabs_by_flushed) == 0)\n\t\treturn;\n\n\t \n\tif (spa->spa_uberblock.ub_rootbp.blk_birth < txg &&\n\t    !dmu_objset_is_dirty(spa_meta_objset(spa), txg) &&\n\t    !spa_flush_all_logs_requested(spa))\n\t\treturn;\n\n\t \n\tspa_generate_syncing_log_sm(spa, tx);\n\n\t \n\tuint64_t want_to_flush;\n\tif (spa_flush_all_logs_requested(spa)) {\n\t\tASSERT3S(spa_state(spa), ==, POOL_STATE_EXPORTED);\n\t\twant_to_flush = UINT64_MAX;\n\t} else {\n\t\twant_to_flush = spa_estimate_metaslabs_to_flush(spa);\n\t}\n\n\t \n\tuint64_t visited = 0;\n\n\t \n\tmetaslab_t *next = NULL;\n\tfor (metaslab_t *curr = avl_first(&spa->spa_metaslabs_by_flushed);\n\t    curr != NULL; curr = next) {\n\t\tnext = AVL_NEXT(&spa->spa_metaslabs_by_flushed, curr);\n\n\t\t \n\t\tif (metaslab_unflushed_txg(curr) == txg)\n\t\t\tbreak;\n\n\t\t \n\t\tif (want_to_flush == 0 && !spa_log_exceeds_memlimit(spa))\n\t\t\tbreak;\n\n\t\tif (metaslab_unflushed_dirty(curr)) {\n\t\t\tmutex_enter(&curr->ms_sync_lock);\n\t\t\tmutex_enter(&curr->ms_lock);\n\t\t\tmetaslab_flush(curr, tx);\n\t\t\tmutex_exit(&curr->ms_lock);\n\t\t\tmutex_exit(&curr->ms_sync_lock);\n\t\t\tif (want_to_flush > 0)\n\t\t\t\twant_to_flush--;\n\t\t} else\n\t\t\tmetaslab_unflushed_bump(curr, tx, B_FALSE);\n\n\t\tvisited++;\n\t}\n\tASSERT3U(avl_numnodes(&spa->spa_metaslabs_by_flushed), >=, visited);\n\n\tspa_log_sm_set_blocklimit(spa);\n}\n\n \nvoid\nspa_sync_close_syncing_log_sm(spa_t *spa)\n{\n\tif (spa_syncing_log_sm(spa) == NULL)\n\t\treturn;\n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_LOG_SPACEMAP));\n\n\tspa_log_sm_t *sls = avl_last(&spa->spa_sm_logs_by_txg);\n\tASSERT3U(sls->sls_txg, ==, spa_syncing_txg(spa));\n\n\tsls->sls_nblocks = space_map_nblocks(spa_syncing_log_sm(spa));\n\tspa->spa_unflushed_stats.sus_nblocks += sls->sls_nblocks;\n\n\t \n\tASSERT(sls->sls_nblocks != 0);\n\n\tspa_log_summary_add_incoming_blocks(spa, sls->sls_nblocks);\n\tspa_log_summary_verify_counts(spa);\n\n\tspace_map_close(spa->spa_syncing_log_sm);\n\tspa->spa_syncing_log_sm = NULL;\n\n\t \n\tif (spa_flush_all_logs_requested(spa)) {\n\t\tASSERT3S(spa_state(spa), ==, POOL_STATE_EXPORTED);\n\t\tspa->spa_log_flushall_txg = 0;\n\t}\n}\n\nvoid\nspa_cleanup_old_sm_logs(spa_t *spa, dmu_tx_t *tx)\n{\n\tobjset_t *mos = spa_meta_objset(spa);\n\n\tuint64_t spacemap_zap;\n\tint error = zap_lookup(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_LOG_SPACEMAP_ZAP, sizeof (spacemap_zap), 1, &spacemap_zap);\n\tif (error == ENOENT) {\n\t\tASSERT(avl_is_empty(&spa->spa_sm_logs_by_txg));\n\t\treturn;\n\t}\n\tVERIFY0(error);\n\n\tmetaslab_t *oldest = avl_first(&spa->spa_metaslabs_by_flushed);\n\tuint64_t oldest_flushed_txg = metaslab_unflushed_txg(oldest);\n\n\t \n\tfor (spa_log_sm_t *sls = avl_first(&spa->spa_sm_logs_by_txg);\n\t    sls && sls->sls_txg < oldest_flushed_txg;\n\t    sls = avl_first(&spa->spa_sm_logs_by_txg)) {\n\t\tASSERT0(sls->sls_mscount);\n\t\tavl_remove(&spa->spa_sm_logs_by_txg, sls);\n\t\tspace_map_free_obj(mos, sls->sls_sm_obj, tx);\n\t\tVERIFY0(zap_remove_int(mos, spacemap_zap, sls->sls_txg, tx));\n\t\tspa_log_summary_decrement_blkcount(spa, sls->sls_nblocks);\n\t\tspa->spa_unflushed_stats.sus_nblocks -= sls->sls_nblocks;\n\t\tkmem_free(sls, sizeof (spa_log_sm_t));\n\t}\n}\n\nstatic spa_log_sm_t *\nspa_log_sm_alloc(uint64_t sm_obj, uint64_t txg)\n{\n\tspa_log_sm_t *sls = kmem_zalloc(sizeof (*sls), KM_SLEEP);\n\tsls->sls_sm_obj = sm_obj;\n\tsls->sls_txg = txg;\n\treturn (sls);\n}\n\nvoid\nspa_generate_syncing_log_sm(spa_t *spa, dmu_tx_t *tx)\n{\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tobjset_t *mos = spa_meta_objset(spa);\n\n\tif (spa_syncing_log_sm(spa) != NULL)\n\t\treturn;\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_LOG_SPACEMAP))\n\t\treturn;\n\n\tuint64_t spacemap_zap;\n\tint error = zap_lookup(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_LOG_SPACEMAP_ZAP, sizeof (spacemap_zap), 1, &spacemap_zap);\n\tif (error == ENOENT) {\n\t\tASSERT(avl_is_empty(&spa->spa_sm_logs_by_txg));\n\n\t\terror = 0;\n\t\tspacemap_zap = zap_create(mos,\n\t\t    DMU_OTN_ZAP_METADATA, DMU_OT_NONE, 0, tx);\n\t\tVERIFY0(zap_add(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_LOG_SPACEMAP_ZAP, sizeof (spacemap_zap), 1,\n\t\t    &spacemap_zap, tx));\n\t\tspa_feature_incr(spa, SPA_FEATURE_LOG_SPACEMAP, tx);\n\t}\n\tVERIFY0(error);\n\n\tuint64_t sm_obj;\n\tASSERT3U(zap_lookup_int_key(mos, spacemap_zap, txg, &sm_obj),\n\t    ==, ENOENT);\n\tsm_obj = space_map_alloc(mos, zfs_log_sm_blksz, tx);\n\tVERIFY0(zap_add_int_key(mos, spacemap_zap, txg, sm_obj, tx));\n\tavl_add(&spa->spa_sm_logs_by_txg, spa_log_sm_alloc(sm_obj, txg));\n\n\t \n\tVERIFY0(space_map_open(&spa->spa_syncing_log_sm, mos, sm_obj,\n\t    0, UINT64_MAX, SPA_MINBLOCKSHIFT));\n\n\tspa_log_sm_set_blocklimit(spa);\n}\n\n \nstatic int\nspa_ld_log_sm_metadata(spa_t *spa)\n{\n\tint error;\n\tuint64_t spacemap_zap;\n\n\tASSERT(avl_is_empty(&spa->spa_sm_logs_by_txg));\n\n\terror = zap_lookup(spa_meta_objset(spa), DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_LOG_SPACEMAP_ZAP, sizeof (spacemap_zap), 1, &spacemap_zap);\n\tif (error == ENOENT) {\n\t\t \n\t\treturn (0);\n\t} else if (error != 0) {\n\t\tspa_load_failed(spa, \"spa_ld_log_sm_metadata(): failed at \"\n\t\t    \"zap_lookup(DMU_POOL_DIRECTORY_OBJECT) [error %d]\",\n\t\t    error);\n\t\treturn (error);\n\t}\n\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tfor (zap_cursor_init(&zc, spa_meta_objset(spa), spacemap_zap);\n\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tuint64_t log_txg = zfs_strtonum(za.za_name, NULL);\n\t\tspa_log_sm_t *sls =\n\t\t    spa_log_sm_alloc(za.za_first_integer, log_txg);\n\t\tavl_add(&spa->spa_sm_logs_by_txg, sls);\n\t}\n\tzap_cursor_fini(&zc);\n\tif (error != ENOENT) {\n\t\tspa_load_failed(spa, \"spa_ld_log_sm_metadata(): failed at \"\n\t\t    \"zap_cursor_retrieve(spacemap_zap) [error %d]\",\n\t\t    error);\n\t\treturn (error);\n\t}\n\n\tfor (metaslab_t *m = avl_first(&spa->spa_metaslabs_by_flushed);\n\t    m; m = AVL_NEXT(&spa->spa_metaslabs_by_flushed, m)) {\n\t\tspa_log_sm_t target = { .sls_txg = metaslab_unflushed_txg(m) };\n\t\tspa_log_sm_t *sls = avl_find(&spa->spa_sm_logs_by_txg,\n\t\t    &target, NULL);\n\n\t\t \n\t\tASSERT(sls != NULL);\n\t\tif (sls == NULL) {\n\t\t\tspa_load_failed(spa, \"spa_ld_log_sm_metadata(): bug \"\n\t\t\t    \"encountered: could not find log spacemap for \"\n\t\t\t    \"TXG %llu [error %d]\",\n\t\t\t    (u_longlong_t)metaslab_unflushed_txg(m), ENOENT);\n\t\t\treturn (ENOENT);\n\t\t}\n\t\tsls->sls_mscount++;\n\t}\n\n\treturn (0);\n}\n\ntypedef struct spa_ld_log_sm_arg {\n\tspa_t *slls_spa;\n\tuint64_t slls_txg;\n} spa_ld_log_sm_arg_t;\n\nstatic int\nspa_ld_log_sm_cb(space_map_entry_t *sme, void *arg)\n{\n\tuint64_t offset = sme->sme_offset;\n\tuint64_t size = sme->sme_run;\n\tuint32_t vdev_id = sme->sme_vdev;\n\n\tspa_ld_log_sm_arg_t *slls = arg;\n\tspa_t *spa = slls->slls_spa;\n\n\tvdev_t *vd = vdev_lookup_top(spa, vdev_id);\n\n\t \n\tif (!vdev_is_concrete(vd))\n\t\treturn (0);\n\n\tmetaslab_t *ms = vd->vdev_ms[offset >> vd->vdev_ms_shift];\n\tASSERT(!ms->ms_loaded);\n\n\t \n\tif (slls->slls_txg < metaslab_unflushed_txg(ms))\n\t\treturn (0);\n\n\tswitch (sme->sme_type) {\n\tcase SM_ALLOC:\n\t\trange_tree_remove_xor_add_segment(offset, offset + size,\n\t\t    ms->ms_unflushed_frees, ms->ms_unflushed_allocs);\n\t\tbreak;\n\tcase SM_FREE:\n\t\trange_tree_remove_xor_add_segment(offset, offset + size,\n\t\t    ms->ms_unflushed_allocs, ms->ms_unflushed_frees);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"invalid maptype_t\");\n\t\tbreak;\n\t}\n\tif (!metaslab_unflushed_dirty(ms)) {\n\t\tmetaslab_set_unflushed_dirty(ms, B_TRUE);\n\t\tspa_log_summary_dirty_flushed_metaslab(spa,\n\t\t    metaslab_unflushed_txg(ms));\n\t}\n\treturn (0);\n}\n\nstatic int\nspa_ld_log_sm_data(spa_t *spa)\n{\n\tspa_log_sm_t *sls, *psls;\n\tint error = 0;\n\n\t \n\tif (!spa_writeable(spa))\n\t\treturn (0);\n\n\tASSERT0(spa->spa_unflushed_stats.sus_nblocks);\n\tASSERT0(spa->spa_unflushed_stats.sus_memused);\n\n\thrtime_t read_logs_starttime = gethrtime();\n\n\t \n\tfor (sls = avl_first(&spa->spa_sm_logs_by_txg); sls;\n\t    sls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls)) {\n\t\tdmu_prefetch(spa_meta_objset(spa), sls->sls_sm_obj,\n\t\t    0, 0, 0, ZIO_PRIORITY_SYNC_READ);\n\t}\n\n\tuint_t pn = 0;\n\tuint64_t ps = 0;\n\tpsls = sls = avl_first(&spa->spa_sm_logs_by_txg);\n\twhile (sls != NULL) {\n\t\t \n\t\tif (psls != NULL && pn < 16 &&\n\t\t    (pn < 2 || ps < 2 * dmu_prefetch_max)) {\n\t\t\terror = space_map_open(&psls->sls_sm,\n\t\t\t    spa_meta_objset(spa), psls->sls_sm_obj, 0,\n\t\t\t    UINT64_MAX, SPA_MINBLOCKSHIFT);\n\t\t\tif (error != 0) {\n\t\t\t\tspa_load_failed(spa, \"spa_ld_log_sm_data(): \"\n\t\t\t\t    \"failed at space_map_open(obj=%llu) \"\n\t\t\t\t    \"[error %d]\",\n\t\t\t\t    (u_longlong_t)sls->sls_sm_obj, error);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdmu_prefetch(spa_meta_objset(spa), psls->sls_sm_obj,\n\t\t\t    0, 0, space_map_length(psls->sls_sm),\n\t\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t\t\tpn++;\n\t\t\tps += space_map_length(psls->sls_sm);\n\t\t\tpsls = AVL_NEXT(&spa->spa_sm_logs_by_txg, psls);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tkpreempt(KPREEMPT_SYNC);\n\t\tASSERT0(sls->sls_nblocks);\n\t\tsls->sls_nblocks = space_map_nblocks(sls->sls_sm);\n\t\tspa->spa_unflushed_stats.sus_nblocks += sls->sls_nblocks;\n\t\tsummary_add_data(spa, sls->sls_txg,\n\t\t    sls->sls_mscount, 0, sls->sls_nblocks);\n\n\t\tstruct spa_ld_log_sm_arg vla = {\n\t\t\t.slls_spa = spa,\n\t\t\t.slls_txg = sls->sls_txg\n\t\t};\n\t\terror = space_map_iterate(sls->sls_sm,\n\t\t    space_map_length(sls->sls_sm), spa_ld_log_sm_cb, &vla);\n\t\tif (error != 0) {\n\t\t\tspa_load_failed(spa, \"spa_ld_log_sm_data(): failed \"\n\t\t\t    \"at space_map_iterate(obj=%llu) [error %d]\",\n\t\t\t    (u_longlong_t)sls->sls_sm_obj, error);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpn--;\n\t\tps -= space_map_length(sls->sls_sm);\n\t\tspace_map_close(sls->sls_sm);\n\t\tsls->sls_sm = NULL;\n\t\tsls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls);\n\n\t\t \n\t\tspa_log_sm_set_blocklimit(spa);\n\t}\n\n\thrtime_t read_logs_endtime = gethrtime();\n\tspa_load_note(spa,\n\t    \"read %llu log space maps (%llu total blocks - blksz = %llu bytes) \"\n\t    \"in %lld ms\", (u_longlong_t)avl_numnodes(&spa->spa_sm_logs_by_txg),\n\t    (u_longlong_t)spa_log_sm_nblocks(spa),\n\t    (u_longlong_t)zfs_log_sm_blksz,\n\t    (longlong_t)((read_logs_endtime - read_logs_starttime) / 1000000));\n\nout:\n\tif (error != 0) {\n\t\tfor (spa_log_sm_t *sls = avl_first(&spa->spa_sm_logs_by_txg);\n\t\t    sls; sls = AVL_NEXT(&spa->spa_sm_logs_by_txg, sls)) {\n\t\t\tif (sls->sls_sm) {\n\t\t\t\tspace_map_close(sls->sls_sm);\n\t\t\t\tsls->sls_sm = NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT0(pn);\n\t\tASSERT0(ps);\n\t}\n\t \n\tfor (metaslab_t *m = avl_first(&spa->spa_metaslabs_by_flushed);\n\t    m != NULL; m = AVL_NEXT(&spa->spa_metaslabs_by_flushed, m)) {\n\t\tmutex_enter(&m->ms_lock);\n\t\tm->ms_allocated_space = space_map_allocated(m->ms_sm) +\n\t\t    range_tree_space(m->ms_unflushed_allocs) -\n\t\t    range_tree_space(m->ms_unflushed_frees);\n\n\t\tvdev_t *vd = m->ms_group->mg_vd;\n\t\tmetaslab_space_update(vd, m->ms_group->mg_class,\n\t\t    range_tree_space(m->ms_unflushed_allocs), 0, 0);\n\t\tmetaslab_space_update(vd, m->ms_group->mg_class,\n\t\t    -range_tree_space(m->ms_unflushed_frees), 0, 0);\n\n\t\tASSERT0(m->ms_weight & METASLAB_ACTIVE_MASK);\n\t\tmetaslab_recalculate_weight_and_sort(m);\n\n\t\tspa->spa_unflushed_stats.sus_memused +=\n\t\t    metaslab_unflushed_changes_memused(m);\n\n\t\tif (metaslab_debug_load && m->ms_sm != NULL) {\n\t\t\tVERIFY0(metaslab_load(m));\n\t\t\tmetaslab_set_selected_txg(m, 0);\n\t\t}\n\t\tmutex_exit(&m->ms_lock);\n\t}\n\n\treturn (error);\n}\n\nstatic int\nspa_ld_unflushed_txgs(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tobjset_t *mos = spa_meta_objset(spa);\n\n\tif (vd->vdev_top_zap == 0)\n\t\treturn (0);\n\n\tuint64_t object = 0;\n\tint error = zap_lookup(mos, vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_MS_UNFLUSHED_PHYS_TXGS,\n\t    sizeof (uint64_t), 1, &object);\n\tif (error == ENOENT)\n\t\treturn (0);\n\telse if (error != 0) {\n\t\tspa_load_failed(spa, \"spa_ld_unflushed_txgs(): failed at \"\n\t\t    \"zap_lookup(vdev_top_zap=%llu) [error %d]\",\n\t\t    (u_longlong_t)vd->vdev_top_zap, error);\n\t\treturn (error);\n\t}\n\n\tfor (uint64_t m = 0; m < vd->vdev_ms_count; m++) {\n\t\tmetaslab_t *ms = vd->vdev_ms[m];\n\t\tASSERT(ms != NULL);\n\n\t\tmetaslab_unflushed_phys_t entry;\n\t\tuint64_t entry_size = sizeof (entry);\n\t\tuint64_t entry_offset = ms->ms_id * entry_size;\n\n\t\terror = dmu_read(mos, object,\n\t\t    entry_offset, entry_size, &entry, 0);\n\t\tif (error != 0) {\n\t\t\tspa_load_failed(spa, \"spa_ld_unflushed_txgs(): \"\n\t\t\t    \"failed at dmu_read(obj=%llu) [error %d]\",\n\t\t\t    (u_longlong_t)object, error);\n\t\t\treturn (error);\n\t\t}\n\n\t\tms->ms_unflushed_txg = entry.msp_unflushed_txg;\n\t\tms->ms_unflushed_dirty = B_FALSE;\n\t\tASSERT(range_tree_is_empty(ms->ms_unflushed_allocs));\n\t\tASSERT(range_tree_is_empty(ms->ms_unflushed_frees));\n\t\tif (ms->ms_unflushed_txg != 0) {\n\t\t\tmutex_enter(&spa->spa_flushed_ms_lock);\n\t\t\tavl_add(&spa->spa_metaslabs_by_flushed, ms);\n\t\t\tmutex_exit(&spa->spa_flushed_ms_lock);\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nint\nspa_ld_log_spacemaps(spa_t *spa)\n{\n\tint error;\n\n\tspa_log_sm_set_blocklimit(spa);\n\n\tfor (uint64_t c = 0; c < spa->spa_root_vdev->vdev_children; c++) {\n\t\tvdev_t *vd = spa->spa_root_vdev->vdev_child[c];\n\t\terror = spa_ld_unflushed_txgs(vd);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\terror = spa_ld_log_sm_metadata(spa);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\tspa_config_enter(spa, SCL_CONFIG, FTAG, RW_READER);\n\terror = spa_ld_log_sm_data(spa);\n\tspa_config_exit(spa, SCL_CONFIG, FTAG);\n\n\treturn (error);\n}\n\n \nZFS_MODULE_PARAM(zfs, zfs_, unflushed_max_mem_amt, U64, ZMOD_RW,\n\t\"Specific hard-limit in memory that ZFS allows to be used for \"\n\t\"unflushed changes\");\n\nZFS_MODULE_PARAM(zfs, zfs_, unflushed_max_mem_ppm, U64, ZMOD_RW,\n\t\"Percentage of the overall system memory that ZFS allows to be \"\n\t\"used for unflushed changes (value is calculated over 1000000 for \"\n\t\"finer granularity)\");\n\nZFS_MODULE_PARAM(zfs, zfs_, unflushed_log_block_max, U64, ZMOD_RW,\n\t\"Hard limit (upper-bound) in the size of the space map log \"\n\t\"in terms of blocks.\");\n\nZFS_MODULE_PARAM(zfs, zfs_, unflushed_log_block_min, U64, ZMOD_RW,\n\t\"Lower-bound limit for the maximum amount of blocks allowed in \"\n\t\"log spacemap (see zfs_unflushed_log_block_max)\");\n\nZFS_MODULE_PARAM(zfs, zfs_, unflushed_log_txg_max, U64, ZMOD_RW,\n    \"Hard limit (upper-bound) in the size of the space map log \"\n    \"in terms of dirty TXGs.\");\n\nZFS_MODULE_PARAM(zfs, zfs_, unflushed_log_block_pct, UINT, ZMOD_RW,\n\t\"Tunable used to determine the number of blocks that can be used for \"\n\t\"the spacemap log, expressed as a percentage of the total number of \"\n\t\"metaslabs in the pool (e.g. 400 means the number of log blocks is \"\n\t\"capped at 4 times the number of metaslabs)\");\n\nZFS_MODULE_PARAM(zfs, zfs_, max_log_walking, U64, ZMOD_RW,\n\t\"The number of past TXGs that the flushing algorithm of the log \"\n\t\"spacemap feature uses to estimate incoming log blocks\");\n\nZFS_MODULE_PARAM(zfs, zfs_, keep_log_spacemaps_at_export, INT, ZMOD_RW,\n\t\"Prevent the log spacemaps from being flushed and destroyed \"\n\t\"during pool export/destroy\");\n \n\nZFS_MODULE_PARAM(zfs, zfs_, max_logsm_summary_length, U64, ZMOD_RW,\n\t\"Maximum number of rows allowed in the summary of the spacemap log\");\n\nZFS_MODULE_PARAM(zfs, zfs_, min_metaslabs_to_flush, U64, ZMOD_RW,\n\t\"Minimum number of metaslabs to flush per dirty TXG\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}