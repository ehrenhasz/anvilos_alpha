{
  "module_name": "vdev_label.c",
  "hash_id": "f6d080078d9254a0afefda97863dc0329743ed7ac593045b6e0ef10207fe09c5",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_label.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/dmu.h>\n#include <sys/zap.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_draid.h>\n#include <sys/uberblock_impl.h>\n#include <sys/metaslab.h>\n#include <sys/metaslab_impl.h>\n#include <sys/zio.h>\n#include <sys/dsl_scan.h>\n#include <sys/abd.h>\n#include <sys/fs/zfs.h>\n#include <sys/byteorder.h>\n#include <sys/zfs_bootenv.h>\n\n \nuint64_t\nvdev_label_offset(uint64_t psize, int l, uint64_t offset)\n{\n\tASSERT(offset < sizeof (vdev_label_t));\n\tASSERT(P2PHASE_TYPED(psize, sizeof (vdev_label_t), uint64_t) == 0);\n\n\treturn (offset + l * sizeof (vdev_label_t) + (l < VDEV_LABELS / 2 ?\n\t    0 : psize - VDEV_LABELS * sizeof (vdev_label_t)));\n}\n\n \nint\nvdev_label_number(uint64_t psize, uint64_t offset)\n{\n\tint l;\n\n\tif (offset >= psize - VDEV_LABEL_END_SIZE) {\n\t\toffset -= psize - VDEV_LABEL_END_SIZE;\n\t\toffset += (VDEV_LABELS / 2) * sizeof (vdev_label_t);\n\t}\n\tl = offset / sizeof (vdev_label_t);\n\treturn (l < VDEV_LABELS ? l : -1);\n}\n\nstatic void\nvdev_label_read(zio_t *zio, vdev_t *vd, int l, abd_t *buf, uint64_t offset,\n    uint64_t size, zio_done_func_t *done, void *private, int flags)\n{\n\tASSERT(\n\t    spa_config_held(zio->io_spa, SCL_STATE, RW_READER) == SCL_STATE ||\n\t    spa_config_held(zio->io_spa, SCL_STATE, RW_WRITER) == SCL_STATE);\n\tASSERT(flags & ZIO_FLAG_CONFIG_WRITER);\n\n\tzio_nowait(zio_read_phys(zio, vd,\n\t    vdev_label_offset(vd->vdev_psize, l, offset),\n\t    size, buf, ZIO_CHECKSUM_LABEL, done, private,\n\t    ZIO_PRIORITY_SYNC_READ, flags, B_TRUE));\n}\n\nvoid\nvdev_label_write(zio_t *zio, vdev_t *vd, int l, abd_t *buf, uint64_t offset,\n    uint64_t size, zio_done_func_t *done, void *private, int flags)\n{\n\tASSERT(\n\t    spa_config_held(zio->io_spa, SCL_STATE, RW_READER) == SCL_STATE ||\n\t    spa_config_held(zio->io_spa, SCL_STATE, RW_WRITER) == SCL_STATE);\n\tASSERT(flags & ZIO_FLAG_CONFIG_WRITER);\n\n\tzio_nowait(zio_write_phys(zio, vd,\n\t    vdev_label_offset(vd->vdev_psize, l, offset),\n\t    size, buf, ZIO_CHECKSUM_LABEL, done, private,\n\t    ZIO_PRIORITY_SYNC_WRITE, flags, B_TRUE));\n}\n\n \nvoid\nvdev_config_generate_stats(vdev_t *vd, nvlist_t *nv)\n{\n\tnvlist_t *nvx;\n\tvdev_stat_t *vs;\n\tvdev_stat_ex_t *vsx;\n\n\tvs = kmem_alloc(sizeof (*vs), KM_SLEEP);\n\tvsx = kmem_alloc(sizeof (*vsx), KM_SLEEP);\n\n\tvdev_get_stats_ex(vd, vs, vsx);\n\tfnvlist_add_uint64_array(nv, ZPOOL_CONFIG_VDEV_STATS,\n\t    (uint64_t *)vs, sizeof (*vs) / sizeof (uint64_t));\n\n\t \n\tnvx = fnvlist_alloc();\n\n\t \n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_SYNC_READ]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SYNC_W_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_SYNC_WRITE]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_ASYNC_R_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_ASYNC_READ]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_ASYNC_W_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_ASYNC_WRITE]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SCRUB_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_SCRUB]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_TRIM_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_TRIM]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_REBUILD_ACTIVE_QUEUE,\n\t    vsx->vsx_active_queue[ZIO_PRIORITY_REBUILD]);\n\n\t \n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SYNC_R_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_SYNC_READ]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SYNC_W_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_SYNC_WRITE]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_ASYNC_R_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_ASYNC_READ]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_ASYNC_W_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_ASYNC_WRITE]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SCRUB_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_SCRUB]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_TRIM_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_TRIM]);\n\n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_REBUILD_PEND_QUEUE,\n\t    vsx->vsx_pend_queue[ZIO_PRIORITY_REBUILD]);\n\n\t \n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_TOT_R_LAT_HISTO,\n\t    vsx->vsx_total_histo[ZIO_TYPE_READ],\n\t    ARRAY_SIZE(vsx->vsx_total_histo[ZIO_TYPE_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_TOT_W_LAT_HISTO,\n\t    vsx->vsx_total_histo[ZIO_TYPE_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_total_histo[ZIO_TYPE_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_DISK_R_LAT_HISTO,\n\t    vsx->vsx_disk_histo[ZIO_TYPE_READ],\n\t    ARRAY_SIZE(vsx->vsx_disk_histo[ZIO_TYPE_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_DISK_W_LAT_HISTO,\n\t    vsx->vsx_disk_histo[ZIO_TYPE_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_disk_histo[ZIO_TYPE_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SYNC_R_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_SYNC_READ],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_SYNC_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SYNC_W_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_SYNC_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_SYNC_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_ASYNC_R_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_ASYNC_READ],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_ASYNC_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_ASYNC_W_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_ASYNC_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_ASYNC_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SCRUB_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_SCRUB],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_SCRUB]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_TRIM_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_TRIM],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_TRIM]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_REBUILD_LAT_HISTO,\n\t    vsx->vsx_queue_histo[ZIO_PRIORITY_REBUILD],\n\t    ARRAY_SIZE(vsx->vsx_queue_histo[ZIO_PRIORITY_REBUILD]));\n\n\t \n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SYNC_IND_R_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_SYNC_READ],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_SYNC_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SYNC_IND_W_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_SYNC_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_SYNC_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_ASYNC_IND_R_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_ASYNC_READ],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_ASYNC_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_ASYNC_IND_W_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_ASYNC_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_ASYNC_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_IND_SCRUB_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_SCRUB],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_SCRUB]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_IND_TRIM_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_TRIM],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_TRIM]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_IND_REBUILD_HISTO,\n\t    vsx->vsx_ind_histo[ZIO_PRIORITY_REBUILD],\n\t    ARRAY_SIZE(vsx->vsx_ind_histo[ZIO_PRIORITY_REBUILD]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SYNC_AGG_R_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_SYNC_READ],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_SYNC_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_SYNC_AGG_W_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_SYNC_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_SYNC_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_ASYNC_AGG_R_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_ASYNC_READ],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_ASYNC_READ]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_ASYNC_AGG_W_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_ASYNC_WRITE],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_ASYNC_WRITE]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_AGG_SCRUB_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_SCRUB],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_SCRUB]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_AGG_TRIM_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_TRIM],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_TRIM]));\n\n\tfnvlist_add_uint64_array(nvx, ZPOOL_CONFIG_VDEV_AGG_REBUILD_HISTO,\n\t    vsx->vsx_agg_histo[ZIO_PRIORITY_REBUILD],\n\t    ARRAY_SIZE(vsx->vsx_agg_histo[ZIO_PRIORITY_REBUILD]));\n\n\t \n\tfnvlist_add_uint64(nvx, ZPOOL_CONFIG_VDEV_SLOW_IOS, vs->vs_slow_ios);\n\n\t \n\tfnvlist_add_nvlist(nv, ZPOOL_CONFIG_VDEV_STATS_EX, nvx);\n\n\tfnvlist_free(nvx);\n\tkmem_free(vs, sizeof (*vs));\n\tkmem_free(vsx, sizeof (*vsx));\n}\n\nstatic void\nroot_vdev_actions_getprogress(vdev_t *vd, nvlist_t *nvl)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tif (vd != spa->spa_root_vdev)\n\t\treturn;\n\n\t \n\tpool_scan_stat_t ps;\n\tif (spa_scan_get_stats(spa, &ps) == 0) {\n\t\tfnvlist_add_uint64_array(nvl,\n\t\t    ZPOOL_CONFIG_SCAN_STATS, (uint64_t *)&ps,\n\t\t    sizeof (pool_scan_stat_t) / sizeof (uint64_t));\n\t}\n\n\tpool_removal_stat_t prs;\n\tif (spa_removal_get_stats(spa, &prs) == 0) {\n\t\tfnvlist_add_uint64_array(nvl,\n\t\t    ZPOOL_CONFIG_REMOVAL_STATS, (uint64_t *)&prs,\n\t\t    sizeof (prs) / sizeof (uint64_t));\n\t}\n\n\tpool_checkpoint_stat_t pcs;\n\tif (spa_checkpoint_get_stats(spa, &pcs) == 0) {\n\t\tfnvlist_add_uint64_array(nvl,\n\t\t    ZPOOL_CONFIG_CHECKPOINT_STATS, (uint64_t *)&pcs,\n\t\t    sizeof (pcs) / sizeof (uint64_t));\n\t}\n}\n\nstatic void\ntop_vdev_actions_getprogress(vdev_t *vd, nvlist_t *nvl)\n{\n\tif (vd == vd->vdev_top) {\n\t\tvdev_rebuild_stat_t vrs;\n\t\tif (vdev_rebuild_get_stats(vd, &vrs) == 0) {\n\t\t\tfnvlist_add_uint64_array(nvl,\n\t\t\t    ZPOOL_CONFIG_REBUILD_STATS, (uint64_t *)&vrs,\n\t\t\t    sizeof (vrs) / sizeof (uint64_t));\n\t\t}\n\t}\n}\n\n \nnvlist_t *\nvdev_config_generate(spa_t *spa, vdev_t *vd, boolean_t getstats,\n    vdev_config_flag_t flags)\n{\n\tnvlist_t *nv = NULL;\n\tvdev_indirect_config_t *vic = &vd->vdev_indirect_config;\n\n\tnv = fnvlist_alloc();\n\n\tfnvlist_add_string(nv, ZPOOL_CONFIG_TYPE, vd->vdev_ops->vdev_op_type);\n\tif (!(flags & (VDEV_CONFIG_SPARE | VDEV_CONFIG_L2CACHE)))\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_ID, vd->vdev_id);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_GUID, vd->vdev_guid);\n\n\tif (vd->vdev_path != NULL)\n\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_PATH, vd->vdev_path);\n\n\tif (vd->vdev_devid != NULL)\n\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_DEVID, vd->vdev_devid);\n\n\tif (vd->vdev_physpath != NULL)\n\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_PHYS_PATH,\n\t\t    vd->vdev_physpath);\n\n\tif (vd->vdev_enc_sysfs_path != NULL)\n\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH,\n\t\t    vd->vdev_enc_sysfs_path);\n\n\tif (vd->vdev_fru != NULL)\n\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_FRU, vd->vdev_fru);\n\n\tif (vd->vdev_ops->vdev_op_config_generate != NULL)\n\t\tvd->vdev_ops->vdev_op_config_generate(vd, nv);\n\n\tif (vd->vdev_wholedisk != -1ULL) {\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_WHOLE_DISK,\n\t\t    vd->vdev_wholedisk);\n\t}\n\n\tif (vd->vdev_not_present && !(flags & VDEV_CONFIG_MISSING))\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_NOT_PRESENT, 1);\n\n\tif (vd->vdev_isspare)\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_IS_SPARE, 1);\n\n\tif (flags & VDEV_CONFIG_L2CACHE)\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_ASHIFT, vd->vdev_ashift);\n\n\tif (!(flags & (VDEV_CONFIG_SPARE | VDEV_CONFIG_L2CACHE)) &&\n\t    vd == vd->vdev_top) {\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_METASLAB_ARRAY,\n\t\t    vd->vdev_ms_array);\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_METASLAB_SHIFT,\n\t\t    vd->vdev_ms_shift);\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_ASHIFT, vd->vdev_ashift);\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_ASIZE,\n\t\t    vd->vdev_asize);\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_IS_LOG, vd->vdev_islog);\n\t\tif (vd->vdev_noalloc) {\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_NONALLOCATING,\n\t\t\t    vd->vdev_noalloc);\n\t\t}\n\n\t\t \n\t\tif (vd->vdev_removing && !vd->vdev_islog) {\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_REMOVING,\n\t\t\t    vd->vdev_removing);\n\t\t}\n\n\t\t \n\t\tif (getstats && vd->vdev_alloc_bias != VDEV_BIAS_NONE) {\n\t\t\tconst char *bias = NULL;\n\n\t\t\tswitch (vd->vdev_alloc_bias) {\n\t\t\tcase VDEV_BIAS_LOG:\n\t\t\t\tbias = VDEV_ALLOC_BIAS_LOG;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_BIAS_SPECIAL:\n\t\t\t\tbias = VDEV_ALLOC_BIAS_SPECIAL;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_BIAS_DEDUP:\n\t\t\t\tbias = VDEV_ALLOC_BIAS_DEDUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tASSERT3U(vd->vdev_alloc_bias, ==,\n\t\t\t\t    VDEV_BIAS_NONE);\n\t\t\t}\n\t\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t\t    bias);\n\t\t}\n\t}\n\n\tif (vd->vdev_dtl_sm != NULL) {\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DTL,\n\t\t    space_map_object(vd->vdev_dtl_sm));\n\t}\n\n\tif (vic->vic_mapping_object != 0) {\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_INDIRECT_OBJECT,\n\t\t    vic->vic_mapping_object);\n\t}\n\n\tif (vic->vic_births_object != 0) {\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_INDIRECT_BIRTHS,\n\t\t    vic->vic_births_object);\n\t}\n\n\tif (vic->vic_prev_indirect_vdev != UINT64_MAX) {\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_PREV_INDIRECT_VDEV,\n\t\t    vic->vic_prev_indirect_vdev);\n\t}\n\n\tif (vd->vdev_crtxg)\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_CREATE_TXG, vd->vdev_crtxg);\n\n\tif (vd->vdev_expansion_time)\n\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_EXPANSION_TIME,\n\t\t    vd->vdev_expansion_time);\n\n\tif (flags & VDEV_CONFIG_MOS) {\n\t\tif (vd->vdev_leaf_zap != 0) {\n\t\t\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_VDEV_LEAF_ZAP,\n\t\t\t    vd->vdev_leaf_zap);\n\t\t}\n\n\t\tif (vd->vdev_top_zap != 0) {\n\t\t\tASSERT(vd == vd->vdev_top);\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_VDEV_TOP_ZAP,\n\t\t\t    vd->vdev_top_zap);\n\t\t}\n\n\t\tif (vd->vdev_ops == &vdev_root_ops && vd->vdev_root_zap != 0 &&\n\t\t    spa_feature_is_active(vd->vdev_spa, SPA_FEATURE_AVZ_V2)) {\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_VDEV_ROOT_ZAP,\n\t\t\t    vd->vdev_root_zap);\n\t\t}\n\n\t\tif (vd->vdev_resilver_deferred) {\n\t\t\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\t\t\tASSERT(spa->spa_resilver_deferred);\n\t\t\tfnvlist_add_boolean(nv, ZPOOL_CONFIG_RESILVER_DEFER);\n\t\t}\n\t}\n\n\tif (getstats) {\n\t\tvdev_config_generate_stats(vd, nv);\n\n\t\troot_vdev_actions_getprogress(vd, nv);\n\t\ttop_vdev_actions_getprogress(vd, nv);\n\n\t\t \n\t\trw_enter(&vd->vdev_indirect_rwlock, RW_READER);\n\t\tif (vd->vdev_indirect_mapping != NULL) {\n\t\t\tASSERT(vd->vdev_indirect_births != NULL);\n\t\t\tvdev_indirect_mapping_t *vim =\n\t\t\t    vd->vdev_indirect_mapping;\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_INDIRECT_SIZE,\n\t\t\t    vdev_indirect_mapping_size(vim));\n\t\t}\n\t\trw_exit(&vd->vdev_indirect_rwlock);\n\t\tif (vd->vdev_mg != NULL &&\n\t\t    vd->vdev_mg->mg_fragmentation != ZFS_FRAG_INVALID) {\n\t\t\t \n\t\t\tuint64_t seg_count = 0;\n\t\t\tuint64_t to_alloc = vd->vdev_stat.vs_alloc;\n\n\t\t\t \n\t\t\tfor (int i = 0; i < RANGE_TREE_HISTOGRAM_SIZE; i++) {\n\t\t\t\tif (i + 1 < highbit64(vdev_removal_max_span)\n\t\t\t\t    - 1) {\n\t\t\t\t\tto_alloc +=\n\t\t\t\t\t    vd->vdev_mg->mg_histogram[i] <<\n\t\t\t\t\t    (i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tseg_count +=\n\t\t\t\t\t    vd->vdev_mg->mg_histogram[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tseg_count += to_alloc / spa_remove_max_segment(spa);\n\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_INDIRECT_SIZE,\n\t\t\t    seg_count *\n\t\t\t    sizeof (vdev_indirect_mapping_entry_phys_t));\n\t\t}\n\t}\n\n\tif (!vd->vdev_ops->vdev_op_leaf) {\n\t\tnvlist_t **child;\n\t\tuint64_t c;\n\n\t\tASSERT(!vd->vdev_ishole);\n\n\t\tchild = kmem_alloc(vd->vdev_children * sizeof (nvlist_t *),\n\t\t    KM_SLEEP);\n\n\t\tfor (c = 0; c < vd->vdev_children; c++) {\n\t\t\tchild[c] = vdev_config_generate(spa, vd->vdev_child[c],\n\t\t\t    getstats, flags);\n\t\t}\n\n\t\tfnvlist_add_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t\t    (const nvlist_t * const *)child, vd->vdev_children);\n\n\t\tfor (c = 0; c < vd->vdev_children; c++)\n\t\t\tnvlist_free(child[c]);\n\n\t\tkmem_free(child, vd->vdev_children * sizeof (nvlist_t *));\n\n\t} else {\n\t\tconst char *aux = NULL;\n\n\t\tif (vd->vdev_offline && !vd->vdev_tmpoffline)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_OFFLINE, B_TRUE);\n\t\tif (vd->vdev_resilver_txg != 0)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_RESILVER_TXG,\n\t\t\t    vd->vdev_resilver_txg);\n\t\tif (vd->vdev_rebuild_txg != 0)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_REBUILD_TXG,\n\t\t\t    vd->vdev_rebuild_txg);\n\t\tif (vd->vdev_faulted)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_FAULTED, B_TRUE);\n\t\tif (vd->vdev_degraded)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DEGRADED, B_TRUE);\n\t\tif (vd->vdev_removed)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_REMOVED, B_TRUE);\n\t\tif (vd->vdev_unspare)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_UNSPARE, B_TRUE);\n\t\tif (vd->vdev_ishole)\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_IS_HOLE, B_TRUE);\n\n\t\t \n\t\tswitch (vd->vdev_stat.vs_aux) {\n\t\tcase VDEV_AUX_ERR_EXCEEDED:\n\t\t\taux = \"err_exceeded\";\n\t\t\tbreak;\n\n\t\tcase VDEV_AUX_EXTERNAL:\n\t\t\taux = \"external\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (aux != NULL && !vd->vdev_tmpoffline) {\n\t\t\tfnvlist_add_string(nv, ZPOOL_CONFIG_AUX_STATE, aux);\n\t\t} else {\n\t\t\t \n\t\t\tif (nvlist_exists(nv, ZPOOL_CONFIG_AUX_STATE))\n\t\t\t\tnvlist_remove_all(nv, ZPOOL_CONFIG_AUX_STATE);\n\t\t}\n\n\t\tif (vd->vdev_splitting && vd->vdev_orig_guid != 0LL) {\n\t\t\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_ORIG_GUID,\n\t\t\t    vd->vdev_orig_guid);\n\t\t}\n\t}\n\n\treturn (nv);\n}\n\n \nvoid\nvdev_top_config_generate(spa_t *spa, nvlist_t *config)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tuint64_t *array;\n\tuint_t c, idx;\n\n\tarray = kmem_alloc(rvd->vdev_children * sizeof (uint64_t), KM_SLEEP);\n\n\tfor (c = 0, idx = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *tvd = rvd->vdev_child[c];\n\n\t\tif (tvd->vdev_ishole) {\n\t\t\tarray[idx++] = c;\n\t\t}\n\t}\n\n\tif (idx) {\n\t\tVERIFY(nvlist_add_uint64_array(config, ZPOOL_CONFIG_HOLE_ARRAY,\n\t\t    array, idx) == 0);\n\t}\n\n\tVERIFY(nvlist_add_uint64(config, ZPOOL_CONFIG_VDEV_CHILDREN,\n\t    rvd->vdev_children) == 0);\n\n\tkmem_free(array, rvd->vdev_children * sizeof (uint64_t));\n}\n\n \nnvlist_t *\nvdev_label_read_config(vdev_t *vd, uint64_t txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tnvlist_t *config = NULL;\n\tvdev_phys_t *vp[VDEV_LABELS];\n\tabd_t *vp_abd[VDEV_LABELS];\n\tzio_t *zio[VDEV_LABELS];\n\tuint64_t best_txg = 0;\n\tuint64_t label_txg = 0;\n\tint error = 0;\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL |\n\t    ZIO_FLAG_SPECULATIVE;\n\n\tASSERT(vd->vdev_validate_thread == curthread ||\n\t    spa_config_held(spa, SCL_STATE_ALL, RW_WRITER) == SCL_STATE_ALL);\n\n\tif (!vdev_readable(vd))\n\t\treturn (NULL);\n\n\t \n\tif (vd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn (vdev_draid_read_config_spare(vd));\n\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tvp_abd[l] = abd_alloc_linear(sizeof (vdev_phys_t), B_TRUE);\n\t\tvp[l] = abd_to_buf(vp_abd[l]);\n\t}\n\nretry:\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tzio[l] = zio_root(spa, NULL, NULL, flags);\n\n\t\tvdev_label_read(zio[l], vd, l, vp_abd[l],\n\t\t    offsetof(vdev_label_t, vl_vdev_phys), sizeof (vdev_phys_t),\n\t\t    NULL, NULL, flags);\n\t}\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tnvlist_t *label = NULL;\n\n\t\tif (zio_wait(zio[l]) == 0 &&\n\t\t    nvlist_unpack(vp[l]->vp_nvlist, sizeof (vp[l]->vp_nvlist),\n\t\t    &label, 0) == 0) {\n\t\t\t \n\t\t\terror = nvlist_lookup_uint64(label,\n\t\t\t    ZPOOL_CONFIG_POOL_TXG, &label_txg);\n\t\t\tif ((error || label_txg == 0) && !config) {\n\t\t\t\tconfig = label;\n\t\t\t\tfor (l++; l < VDEV_LABELS; l++)\n\t\t\t\t\tzio_wait(zio[l]);\n\t\t\t\tbreak;\n\t\t\t} else if (label_txg <= txg && label_txg > best_txg) {\n\t\t\t\tbest_txg = label_txg;\n\t\t\t\tnvlist_free(config);\n\t\t\t\tconfig = fnvlist_dup(label);\n\t\t\t}\n\t\t}\n\n\t\tif (label != NULL) {\n\t\t\tnvlist_free(label);\n\t\t\tlabel = NULL;\n\t\t}\n\t}\n\n\tif (config == NULL && !(flags & ZIO_FLAG_TRYHARD)) {\n\t\tflags |= ZIO_FLAG_TRYHARD;\n\t\tgoto retry;\n\t}\n\n\t \n\tif (config == NULL && label_txg != 0) {\n\t\tvdev_dbgmsg(vd, \"label discarded as txg is too large \"\n\t\t    \"(%llu > %llu)\", (u_longlong_t)label_txg,\n\t\t    (u_longlong_t)txg);\n\t}\n\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tabd_free(vp_abd[l]);\n\t}\n\n\treturn (config);\n}\n\n \nstatic boolean_t\nvdev_inuse(vdev_t *vd, uint64_t crtxg, vdev_labeltype_t reason,\n    uint64_t *spare_guid, uint64_t *l2cache_guid)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tuint64_t state, pool_guid, device_guid, txg, spare_pool;\n\tuint64_t vdtxg = 0;\n\tnvlist_t *label;\n\n\tif (spare_guid)\n\t\t*spare_guid = 0ULL;\n\tif (l2cache_guid)\n\t\t*l2cache_guid = 0ULL;\n\n\t \n\tif ((label = vdev_label_read_config(vd, -1ULL)) == NULL)\n\t\treturn (B_FALSE);\n\n\t(void) nvlist_lookup_uint64(label, ZPOOL_CONFIG_CREATE_TXG,\n\t    &vdtxg);\n\n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_STATE,\n\t    &state) != 0 ||\n\t    nvlist_lookup_uint64(label, ZPOOL_CONFIG_GUID,\n\t    &device_guid) != 0) {\n\t\tnvlist_free(label);\n\t\treturn (B_FALSE);\n\t}\n\n\tif (state != POOL_STATE_SPARE && state != POOL_STATE_L2CACHE &&\n\t    (nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_GUID,\n\t    &pool_guid) != 0 ||\n\t    nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_TXG,\n\t    &txg) != 0)) {\n\t\tnvlist_free(label);\n\t\treturn (B_FALSE);\n\t}\n\n\tnvlist_free(label);\n\n\t \n\tif (state != POOL_STATE_SPARE && state != POOL_STATE_L2CACHE &&\n\t    !spa_guid_exists(pool_guid, device_guid) &&\n\t    !spa_spare_exists(device_guid, NULL, NULL) &&\n\t    !spa_l2cache_exists(device_guid, NULL))\n\t\treturn (B_FALSE);\n\n\t \n\tif (state != POOL_STATE_SPARE && state != POOL_STATE_L2CACHE &&\n\t    txg == 0 && vdtxg == crtxg)\n\t\treturn (B_TRUE);\n\n\t \n\tif (spa_spare_exists(device_guid, &spare_pool, NULL) ||\n\t    spa_has_spare(spa, device_guid)) {\n\t\tif (spare_guid)\n\t\t\t*spare_guid = device_guid;\n\n\t\tswitch (reason) {\n\t\tcase VDEV_LABEL_CREATE:\n\t\t\treturn (B_TRUE);\n\n\t\tcase VDEV_LABEL_REPLACE:\n\t\t\treturn (!spa_has_spare(spa, device_guid) ||\n\t\t\t    spare_pool != 0ULL);\n\n\t\tcase VDEV_LABEL_SPARE:\n\t\t\treturn (spa_has_spare(spa, device_guid));\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (spa_l2cache_exists(device_guid, NULL) ||\n\t    spa_has_l2cache(spa, device_guid)) {\n\t\tif (l2cache_guid)\n\t\t\t*l2cache_guid = device_guid;\n\n\t\tswitch (reason) {\n\t\tcase VDEV_LABEL_CREATE:\n\t\t\treturn (B_TRUE);\n\n\t\tcase VDEV_LABEL_REPLACE:\n\t\t\treturn (!spa_has_l2cache(spa, device_guid));\n\n\t\tcase VDEV_LABEL_L2CACHE:\n\t\t\treturn (spa_has_l2cache(spa, device_guid));\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (state != POOL_STATE_SPARE && state != POOL_STATE_L2CACHE &&\n\t    (spa = spa_by_guid(pool_guid, device_guid)) != NULL &&\n\t    spa_mode(spa) == SPA_MODE_READ)\n\t\tstate = POOL_STATE_ACTIVE;\n\n\t \n\treturn (state == POOL_STATE_ACTIVE);\n}\n\n \nint\nvdev_label_init(vdev_t *vd, uint64_t crtxg, vdev_labeltype_t reason)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tnvlist_t *label;\n\tvdev_phys_t *vp;\n\tabd_t *vp_abd;\n\tabd_t *bootenv;\n\tuberblock_t *ub;\n\tabd_t *ub_abd;\n\tzio_t *zio;\n\tchar *buf;\n\tsize_t buflen;\n\tint error;\n\tuint64_t spare_guid = 0, l2cache_guid = 0;\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL;\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tif ((error = vdev_label_init(vd->vdev_child[c],\n\t\t    crtxg, reason)) != 0)\n\t\t\treturn (error);\n\n\t \n\tvd->vdev_crtxg = crtxg;\n\n\tif (!vd->vdev_ops->vdev_op_leaf || !spa_writeable(spa))\n\t\treturn (0);\n\n\t \n\tif (vdev_is_dead(vd))\n\t\treturn (SET_ERROR(EIO));\n\n\t \n\tif (reason != VDEV_LABEL_REMOVE && reason != VDEV_LABEL_SPLIT &&\n\t    vdev_inuse(vd, crtxg, reason, &spare_guid, &l2cache_guid))\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tif (reason != VDEV_LABEL_REMOVE && reason != VDEV_LABEL_L2CACHE &&\n\t    spare_guid != 0ULL) {\n\t\tuint64_t guid_delta = spare_guid - vd->vdev_guid;\n\n\t\tvd->vdev_guid += guid_delta;\n\n\t\tfor (vdev_t *pvd = vd; pvd != NULL; pvd = pvd->vdev_parent)\n\t\t\tpvd->vdev_guid_sum += guid_delta;\n\n\t\t \n\t\tif (reason == VDEV_LABEL_SPARE)\n\t\t\treturn (0);\n\t\tASSERT(reason == VDEV_LABEL_REPLACE ||\n\t\t    reason == VDEV_LABEL_SPLIT);\n\t}\n\n\tif (reason != VDEV_LABEL_REMOVE && reason != VDEV_LABEL_SPARE &&\n\t    l2cache_guid != 0ULL) {\n\t\tuint64_t guid_delta = l2cache_guid - vd->vdev_guid;\n\n\t\tvd->vdev_guid += guid_delta;\n\n\t\tfor (vdev_t *pvd = vd; pvd != NULL; pvd = pvd->vdev_parent)\n\t\t\tpvd->vdev_guid_sum += guid_delta;\n\n\t\t \n\t\tif (reason == VDEV_LABEL_L2CACHE)\n\t\t\treturn (0);\n\t\tASSERT(reason == VDEV_LABEL_REPLACE);\n\t}\n\n\t \n\tvp_abd = abd_alloc_linear(sizeof (vdev_phys_t), B_TRUE);\n\tabd_zero(vp_abd, sizeof (vdev_phys_t));\n\tvp = abd_to_buf(vp_abd);\n\n\t \n\tif (reason == VDEV_LABEL_SPARE ||\n\t    (reason == VDEV_LABEL_REMOVE && vd->vdev_isspare)) {\n\t\t \n\t\tVERIFY(nvlist_alloc(&label, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_VERSION,\n\t\t    spa_version(spa)) == 0);\n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_POOL_STATE,\n\t\t    POOL_STATE_SPARE) == 0);\n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_GUID,\n\t\t    vd->vdev_guid) == 0);\n\t} else if (reason == VDEV_LABEL_L2CACHE ||\n\t    (reason == VDEV_LABEL_REMOVE && vd->vdev_isl2cache)) {\n\t\t \n\t\tVERIFY(nvlist_alloc(&label, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_VERSION,\n\t\t    spa_version(spa)) == 0);\n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_POOL_STATE,\n\t\t    POOL_STATE_L2CACHE) == 0);\n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_GUID,\n\t\t    vd->vdev_guid) == 0);\n\n\t\t \n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_ASHIFT,\n\t\t    vd->vdev_ashift) == 0);\n\t} else {\n\t\tuint64_t txg = 0ULL;\n\n\t\tif (reason == VDEV_LABEL_SPLIT)\n\t\t\ttxg = spa->spa_uberblock.ub_txg;\n\t\tlabel = spa_config_generate(spa, vd, txg, B_FALSE);\n\n\t\t \n\t\tVERIFY(nvlist_add_uint64(label, ZPOOL_CONFIG_CREATE_TXG,\n\t\t    crtxg) == 0);\n\t}\n\n\tbuf = vp->vp_nvlist;\n\tbuflen = sizeof (vp->vp_nvlist);\n\n\terror = nvlist_pack(label, &buf, &buflen, NV_ENCODE_XDR, KM_SLEEP);\n\tif (error != 0) {\n\t\tnvlist_free(label);\n\t\tabd_free(vp_abd);\n\t\t \n\t\treturn (SET_ERROR(error == EFAULT ? ENAMETOOLONG : EINVAL));\n\t}\n\n\t \n\tub_abd = abd_alloc_linear(VDEV_UBERBLOCK_RING, B_TRUE);\n\tabd_zero(ub_abd, VDEV_UBERBLOCK_RING);\n\tabd_copy_from_buf(ub_abd, &spa->spa_uberblock, sizeof (uberblock_t));\n\tub = abd_to_buf(ub_abd);\n\tub->ub_txg = 0;\n\n\t \n\tbootenv = abd_alloc_for_io(VDEV_PAD_SIZE, B_TRUE);\n\tabd_zero(bootenv, VDEV_PAD_SIZE);\n\n\t \nretry:\n\tzio = zio_root(spa, NULL, NULL, flags);\n\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\n\t\tvdev_label_write(zio, vd, l, vp_abd,\n\t\t    offsetof(vdev_label_t, vl_vdev_phys),\n\t\t    sizeof (vdev_phys_t), NULL, NULL, flags);\n\n\t\t \n\t\tvdev_label_write(zio, vd, l, bootenv,\n\t\t    offsetof(vdev_label_t, vl_be),\n\t\t    VDEV_PAD_SIZE, NULL, NULL, flags);\n\n\t\tvdev_label_write(zio, vd, l, ub_abd,\n\t\t    offsetof(vdev_label_t, vl_uberblock),\n\t\t    VDEV_UBERBLOCK_RING, NULL, NULL, flags);\n\t}\n\n\terror = zio_wait(zio);\n\n\tif (error != 0 && !(flags & ZIO_FLAG_TRYHARD)) {\n\t\tflags |= ZIO_FLAG_TRYHARD;\n\t\tgoto retry;\n\t}\n\n\tnvlist_free(label);\n\tabd_free(bootenv);\n\tabd_free(ub_abd);\n\tabd_free(vp_abd);\n\n\t \n\tif (error == 0 && !vd->vdev_isspare &&\n\t    (reason == VDEV_LABEL_SPARE ||\n\t    spa_spare_exists(vd->vdev_guid, NULL, NULL)))\n\t\tspa_spare_add(vd);\n\n\tif (error == 0 && !vd->vdev_isl2cache &&\n\t    (reason == VDEV_LABEL_L2CACHE ||\n\t    spa_l2cache_exists(vd->vdev_guid, NULL)))\n\t\tspa_l2cache_add(vd);\n\n\treturn (error);\n}\n\n \nstatic void\nvdev_label_read_bootenv_done(zio_t *zio)\n{\n\tzio_t *rio = zio->io_private;\n\tabd_t **cbp = rio->io_private;\n\n\tASSERT3U(zio->io_size, ==, VDEV_PAD_SIZE);\n\n\tif (zio->io_error == 0) {\n\t\tmutex_enter(&rio->io_lock);\n\t\tif (*cbp == NULL) {\n\t\t\t \n\t\t\t*cbp = zio->io_abd;\n\t\t} else {\n\t\t\tabd_free(zio->io_abd);\n\t\t}\n\t\tmutex_exit(&rio->io_lock);\n\t} else {\n\t\tabd_free(zio->io_abd);\n\t}\n}\n\nstatic void\nvdev_label_read_bootenv_impl(zio_t *zio, vdev_t *vd, int flags)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_label_read_bootenv_impl(zio, vd->vdev_child[c], flags);\n\n\t \n\tif (vd->vdev_ops->vdev_op_leaf && vdev_readable(vd)) {\n\t\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\t\tvdev_label_read(zio, vd, l,\n\t\t\t    abd_alloc_linear(VDEV_PAD_SIZE, B_FALSE),\n\t\t\t    offsetof(vdev_label_t, vl_be), VDEV_PAD_SIZE,\n\t\t\t    vdev_label_read_bootenv_done, zio, flags);\n\t\t}\n\t}\n}\n\nint\nvdev_label_read_bootenv(vdev_t *rvd, nvlist_t *bootenv)\n{\n\tnvlist_t *config;\n\tspa_t *spa = rvd->vdev_spa;\n\tabd_t *abd = NULL;\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL |\n\t    ZIO_FLAG_SPECULATIVE | ZIO_FLAG_TRYHARD;\n\n\tASSERT(bootenv);\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tzio_t *zio = zio_root(spa, NULL, &abd, flags);\n\tvdev_label_read_bootenv_impl(zio, rvd, flags);\n\tint err = zio_wait(zio);\n\n\tif (abd != NULL) {\n\t\tchar *buf;\n\t\tvdev_boot_envblock_t *vbe = abd_to_buf(abd);\n\n\t\tvbe->vbe_version = ntohll(vbe->vbe_version);\n\t\tswitch (vbe->vbe_version) {\n\t\tcase VB_RAW:\n\t\t\t \n\t\t\tfnvlist_add_uint64(bootenv, BOOTENV_VERSION, VB_RAW);\n\t\t\tvbe->vbe_bootenv[sizeof (vbe->vbe_bootenv) - 1] = '\\0';\n\t\t\tfnvlist_add_string(bootenv, GRUB_ENVMAP,\n\t\t\t    vbe->vbe_bootenv);\n\t\t\tbreak;\n\n\t\tcase VB_NVLIST:\n\t\t\terr = nvlist_unpack(vbe->vbe_bootenv,\n\t\t\t    sizeof (vbe->vbe_bootenv), &config, 0);\n\t\t\tif (err == 0) {\n\t\t\t\tfnvlist_merge(bootenv, config);\n\t\t\t\tnvlist_free(config);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzfs_fallthrough;\n\t\tdefault:\n\t\t\t \n\t\t\tbuf = abd_to_buf(abd);\n\t\t\tif (*buf == '\\0') {\n\t\t\t\tfnvlist_add_uint64(bootenv, BOOTENV_VERSION,\n\t\t\t\t    VB_NVLIST);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfnvlist_add_string(bootenv, FREEBSD_BOOTONCE, buf);\n\t\t}\n\n\t\t \n\t\tabd_free(abd);\n\t\t \n\t\treturn (0);\n\t}\n\treturn (err);\n}\n\nint\nvdev_label_write_bootenv(vdev_t *vd, nvlist_t *env)\n{\n\tzio_t *zio;\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_boot_envblock_t *bootenv;\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL;\n\tint error;\n\tsize_t nvsize;\n\tchar *nvbuf;\n\tconst char *tmp;\n\n\terror = nvlist_size(env, &nvsize, NV_ENCODE_XDR);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\tif (nvsize >= sizeof (bootenv->vbe_bootenv)) {\n\t\treturn (SET_ERROR(E2BIG));\n\t}\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\terror = ENXIO;\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tint child_err;\n\n\t\tchild_err = vdev_label_write_bootenv(vd->vdev_child[c], env);\n\t\t \n\t\tif (child_err == 0)\n\t\t\terror = child_err;\n\t}\n\n\tif (!vd->vdev_ops->vdev_op_leaf || vdev_is_dead(vd) ||\n\t    !vdev_writeable(vd)) {\n\t\treturn (error);\n\t}\n\tASSERT3U(sizeof (*bootenv), ==, VDEV_PAD_SIZE);\n\tabd_t *abd = abd_alloc_for_io(VDEV_PAD_SIZE, B_TRUE);\n\tabd_zero(abd, VDEV_PAD_SIZE);\n\n\tbootenv = abd_borrow_buf_copy(abd, VDEV_PAD_SIZE);\n\tnvbuf = bootenv->vbe_bootenv;\n\tnvsize = sizeof (bootenv->vbe_bootenv);\n\n\tbootenv->vbe_version = fnvlist_lookup_uint64(env, BOOTENV_VERSION);\n\tswitch (bootenv->vbe_version) {\n\tcase VB_RAW:\n\t\tif (nvlist_lookup_string(env, GRUB_ENVMAP, &tmp) == 0) {\n\t\t\t(void) strlcpy(bootenv->vbe_bootenv, tmp, nvsize);\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\n\tcase VB_NVLIST:\n\t\terror = nvlist_pack(env, &nvbuf, &nvsize, NV_ENCODE_XDR,\n\t\t    KM_SLEEP);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tif (error == 0) {\n\t\tbootenv->vbe_version = htonll(bootenv->vbe_version);\n\t\tabd_return_buf_copy(abd, bootenv, VDEV_PAD_SIZE);\n\t} else {\n\t\tabd_free(abd);\n\t\treturn (SET_ERROR(error));\n\t}\n\nretry:\n\tzio = zio_root(spa, NULL, NULL, flags);\n\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\tvdev_label_write(zio, vd, l, abd,\n\t\t    offsetof(vdev_label_t, vl_be),\n\t\t    VDEV_PAD_SIZE, NULL, NULL, flags);\n\t}\n\n\terror = zio_wait(zio);\n\tif (error != 0 && !(flags & ZIO_FLAG_TRYHARD)) {\n\t\tflags |= ZIO_FLAG_TRYHARD;\n\t\tgoto retry;\n\t}\n\n\tabd_free(abd);\n\treturn (error);\n}\n\n \n\n \nstatic int\nvdev_uberblock_compare(const uberblock_t *ub1, const uberblock_t *ub2)\n{\n\tint cmp = TREE_CMP(ub1->ub_txg, ub2->ub_txg);\n\n\tif (likely(cmp))\n\t\treturn (cmp);\n\n\tcmp = TREE_CMP(ub1->ub_timestamp, ub2->ub_timestamp);\n\tif (likely(cmp))\n\t\treturn (cmp);\n\n\t \n\tunsigned int seq1 = 0;\n\tunsigned int seq2 = 0;\n\n\tif (MMP_VALID(ub1) && MMP_SEQ_VALID(ub1))\n\t\tseq1 = MMP_SEQ(ub1);\n\n\tif (MMP_VALID(ub2) && MMP_SEQ_VALID(ub2))\n\t\tseq2 = MMP_SEQ(ub2);\n\n\treturn (TREE_CMP(seq1, seq2));\n}\n\nstruct ubl_cbdata {\n\tuberblock_t\t*ubl_ubbest;\t \n\tvdev_t\t\t*ubl_vd;\t \n};\n\nstatic void\nvdev_uberblock_load_done(zio_t *zio)\n{\n\tvdev_t *vd = zio->io_vd;\n\tspa_t *spa = zio->io_spa;\n\tzio_t *rio = zio->io_private;\n\tuberblock_t *ub = abd_to_buf(zio->io_abd);\n\tstruct ubl_cbdata *cbp = rio->io_private;\n\n\tASSERT3U(zio->io_size, ==, VDEV_UBERBLOCK_SIZE(vd));\n\n\tif (zio->io_error == 0 && uberblock_verify(ub) == 0) {\n\t\tmutex_enter(&rio->io_lock);\n\t\tif (ub->ub_txg <= spa->spa_load_max_txg &&\n\t\t    vdev_uberblock_compare(ub, cbp->ubl_ubbest) > 0) {\n\t\t\t \n\t\t\t*cbp->ubl_ubbest = *ub;\n\t\t\tcbp->ubl_vd = vd;\n\t\t}\n\t\tmutex_exit(&rio->io_lock);\n\t}\n\n\tabd_free(zio->io_abd);\n}\n\nstatic void\nvdev_uberblock_load_impl(zio_t *zio, vdev_t *vd, int flags,\n    struct ubl_cbdata *cbp)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_uberblock_load_impl(zio, vd->vdev_child[c], flags, cbp);\n\n\tif (vd->vdev_ops->vdev_op_leaf && vdev_readable(vd) &&\n\t    vd->vdev_ops != &vdev_draid_spare_ops) {\n\t\tfor (int l = 0; l < VDEV_LABELS; l++) {\n\t\t\tfor (int n = 0; n < VDEV_UBERBLOCK_COUNT(vd); n++) {\n\t\t\t\tvdev_label_read(zio, vd, l,\n\t\t\t\t    abd_alloc_linear(VDEV_UBERBLOCK_SIZE(vd),\n\t\t\t\t    B_TRUE), VDEV_UBERBLOCK_OFFSET(vd, n),\n\t\t\t\t    VDEV_UBERBLOCK_SIZE(vd),\n\t\t\t\t    vdev_uberblock_load_done, zio, flags);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid\nvdev_uberblock_load(vdev_t *rvd, uberblock_t *ub, nvlist_t **config)\n{\n\tzio_t *zio;\n\tspa_t *spa = rvd->vdev_spa;\n\tstruct ubl_cbdata cb;\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL |\n\t    ZIO_FLAG_SPECULATIVE | ZIO_FLAG_TRYHARD;\n\n\tASSERT(ub);\n\tASSERT(config);\n\n\tmemset(ub, 0, sizeof (uberblock_t));\n\t*config = NULL;\n\n\tcb.ubl_ubbest = ub;\n\tcb.ubl_vd = NULL;\n\n\tspa_config_enter(spa, SCL_ALL, FTAG, RW_WRITER);\n\tzio = zio_root(spa, NULL, &cb, flags);\n\tvdev_uberblock_load_impl(zio, rvd, flags, &cb);\n\t(void) zio_wait(zio);\n\n\t \n\tif (cb.ubl_vd != NULL) {\n\t\tvdev_dbgmsg(cb.ubl_vd, \"best uberblock found for spa %s. \"\n\t\t    \"txg %llu\", spa->spa_name, (u_longlong_t)ub->ub_txg);\n\n\t\t*config = vdev_label_read_config(cb.ubl_vd, ub->ub_txg);\n\t\tif (*config == NULL && spa->spa_extreme_rewind) {\n\t\t\tvdev_dbgmsg(cb.ubl_vd, \"failed to read label config. \"\n\t\t\t    \"Trying again without txg restrictions.\");\n\t\t\t*config = vdev_label_read_config(cb.ubl_vd, UINT64_MAX);\n\t\t}\n\t\tif (*config == NULL) {\n\t\t\tvdev_dbgmsg(cb.ubl_vd, \"failed to read label config\");\n\t\t}\n\t}\n\tspa_config_exit(spa, SCL_ALL, FTAG);\n}\n\n \n\nstatic void\nvdev_copy_uberblocks(vdev_t *vd)\n{\n\tabd_t *ub_abd;\n\tzio_t *write_zio;\n\tint locks = (SCL_L2ARC | SCL_ZIO);\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL |\n\t    ZIO_FLAG_SPECULATIVE;\n\n\tASSERT(spa_config_held(vd->vdev_spa, SCL_STATE, RW_READER) ==\n\t    SCL_STATE);\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\t \n\tif (vd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn;\n\n\tspa_config_enter(vd->vdev_spa, locks, FTAG, RW_READER);\n\n\tub_abd = abd_alloc_linear(VDEV_UBERBLOCK_SIZE(vd), B_TRUE);\n\n\twrite_zio = zio_root(vd->vdev_spa, NULL, NULL, flags);\n\tfor (int n = 0; n < VDEV_UBERBLOCK_COUNT(vd); n++) {\n\t\tconst int src_label = 0;\n\t\tzio_t *zio;\n\n\t\tzio = zio_root(vd->vdev_spa, NULL, NULL, flags);\n\t\tvdev_label_read(zio, vd, src_label, ub_abd,\n\t\t    VDEV_UBERBLOCK_OFFSET(vd, n), VDEV_UBERBLOCK_SIZE(vd),\n\t\t    NULL, NULL, flags);\n\n\t\tif (zio_wait(zio) || uberblock_verify(abd_to_buf(ub_abd)))\n\t\t\tabd_zero(ub_abd, VDEV_UBERBLOCK_SIZE(vd));\n\n\t\tfor (int l = 2; l < VDEV_LABELS; l++)\n\t\t\tvdev_label_write(write_zio, vd, l, ub_abd,\n\t\t\t    VDEV_UBERBLOCK_OFFSET(vd, n),\n\t\t\t    VDEV_UBERBLOCK_SIZE(vd), NULL, NULL,\n\t\t\t    flags | ZIO_FLAG_DONT_PROPAGATE);\n\t}\n\t(void) zio_wait(write_zio);\n\n\tspa_config_exit(vd->vdev_spa, locks, FTAG);\n\n\tabd_free(ub_abd);\n}\n\n \nstatic void\nvdev_uberblock_sync_done(zio_t *zio)\n{\n\tuint64_t *good_writes = zio->io_private;\n\n\tif (zio->io_error == 0 && zio->io_vd->vdev_top->vdev_ms_array != 0)\n\t\tatomic_inc_64(good_writes);\n}\n\n \nstatic void\nvdev_uberblock_sync(zio_t *zio, uint64_t *good_writes,\n    uberblock_t *ub, vdev_t *vd, int flags)\n{\n\tfor (uint64_t c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_uberblock_sync(zio, good_writes,\n\t\t    ub, vd->vdev_child[c], flags);\n\t}\n\n\tif (!vd->vdev_ops->vdev_op_leaf)\n\t\treturn;\n\n\tif (!vdev_writeable(vd))\n\t\treturn;\n\n\t \n\tif (vd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn;\n\n\t \n\tif (vd->vdev_state == VDEV_STATE_HEALTHY &&\n\t    vd->vdev_copy_uberblocks == B_TRUE) {\n\t\tvdev_copy_uberblocks(vd);\n\t\tvd->vdev_copy_uberblocks = B_FALSE;\n\t}\n\n\tint m = spa_multihost(vd->vdev_spa) ? MMP_BLOCKS_PER_LABEL : 0;\n\tint n = ub->ub_txg % (VDEV_UBERBLOCK_COUNT(vd) - m);\n\n\t \n\tabd_t *ub_abd = abd_alloc_for_io(VDEV_UBERBLOCK_SIZE(vd), B_TRUE);\n\tabd_zero(ub_abd, VDEV_UBERBLOCK_SIZE(vd));\n\tabd_copy_from_buf(ub_abd, ub, sizeof (uberblock_t));\n\n\tfor (int l = 0; l < VDEV_LABELS; l++)\n\t\tvdev_label_write(zio, vd, l, ub_abd,\n\t\t    VDEV_UBERBLOCK_OFFSET(vd, n), VDEV_UBERBLOCK_SIZE(vd),\n\t\t    vdev_uberblock_sync_done, good_writes,\n\t\t    flags | ZIO_FLAG_DONT_PROPAGATE);\n\n\tabd_free(ub_abd);\n}\n\n \nstatic int\nvdev_uberblock_sync_list(vdev_t **svd, int svdcount, uberblock_t *ub, int flags)\n{\n\tspa_t *spa = svd[0]->vdev_spa;\n\tzio_t *zio;\n\tuint64_t good_writes = 0;\n\n\tzio = zio_root(spa, NULL, NULL, flags);\n\n\tfor (int v = 0; v < svdcount; v++)\n\t\tvdev_uberblock_sync(zio, &good_writes, ub, svd[v], flags);\n\n\t(void) zio_wait(zio);\n\n\t \n\tzio = zio_root(spa, NULL, NULL, flags);\n\n\tfor (int v = 0; v < svdcount; v++) {\n\t\tif (vdev_writeable(svd[v])) {\n\t\t\tzio_flush(zio, svd[v]);\n\t\t}\n\t}\n\n\t(void) zio_wait(zio);\n\n\treturn (good_writes >= 1 ? 0 : EIO);\n}\n\n \nstatic void\nvdev_label_sync_done(zio_t *zio)\n{\n\tuint64_t *good_writes = zio->io_private;\n\n\tif (zio->io_error == 0)\n\t\tatomic_inc_64(good_writes);\n}\n\n \nstatic void\nvdev_label_sync_top_done(zio_t *zio)\n{\n\tuint64_t *good_writes = zio->io_private;\n\n\tif (*good_writes == 0)\n\t\tzio->io_error = SET_ERROR(EIO);\n\n\tkmem_free(good_writes, sizeof (uint64_t));\n}\n\n \nstatic void\nvdev_label_sync_ignore_done(zio_t *zio)\n{\n\tkmem_free(zio->io_private, sizeof (uint64_t));\n}\n\n \nstatic void\nvdev_label_sync(zio_t *zio, uint64_t *good_writes,\n    vdev_t *vd, int l, uint64_t txg, int flags)\n{\n\tnvlist_t *label;\n\tvdev_phys_t *vp;\n\tabd_t *vp_abd;\n\tchar *buf;\n\tsize_t buflen;\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_label_sync(zio, good_writes,\n\t\t    vd->vdev_child[c], l, txg, flags);\n\t}\n\n\tif (!vd->vdev_ops->vdev_op_leaf)\n\t\treturn;\n\n\tif (!vdev_writeable(vd))\n\t\treturn;\n\n\t \n\tif (vd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn;\n\n\t \n\tlabel = spa_config_generate(vd->vdev_spa, vd, txg, B_FALSE);\n\n\tvp_abd = abd_alloc_linear(sizeof (vdev_phys_t), B_TRUE);\n\tabd_zero(vp_abd, sizeof (vdev_phys_t));\n\tvp = abd_to_buf(vp_abd);\n\n\tbuf = vp->vp_nvlist;\n\tbuflen = sizeof (vp->vp_nvlist);\n\n\tif (!nvlist_pack(label, &buf, &buflen, NV_ENCODE_XDR, KM_SLEEP)) {\n\t\tfor (; l < VDEV_LABELS; l += 2) {\n\t\t\tvdev_label_write(zio, vd, l, vp_abd,\n\t\t\t    offsetof(vdev_label_t, vl_vdev_phys),\n\t\t\t    sizeof (vdev_phys_t),\n\t\t\t    vdev_label_sync_done, good_writes,\n\t\t\t    flags | ZIO_FLAG_DONT_PROPAGATE);\n\t\t}\n\t}\n\n\tabd_free(vp_abd);\n\tnvlist_free(label);\n}\n\nstatic int\nvdev_label_sync_list(spa_t *spa, int l, uint64_t txg, int flags)\n{\n\tlist_t *dl = &spa->spa_config_dirty_list;\n\tvdev_t *vd;\n\tzio_t *zio;\n\tint error;\n\n\t \n\tzio = zio_root(spa, NULL, NULL, flags);\n\n\tfor (vd = list_head(dl); vd != NULL; vd = list_next(dl, vd)) {\n\t\tuint64_t *good_writes;\n\n\t\tASSERT(!vd->vdev_ishole);\n\n\t\tgood_writes = kmem_zalloc(sizeof (uint64_t), KM_SLEEP);\n\t\tzio_t *vio = zio_null(zio, spa, NULL,\n\t\t    (vd->vdev_islog || vd->vdev_aux != NULL) ?\n\t\t    vdev_label_sync_ignore_done : vdev_label_sync_top_done,\n\t\t    good_writes, flags);\n\t\tvdev_label_sync(vio, good_writes, vd, l, txg, flags);\n\t\tzio_nowait(vio);\n\t}\n\n\terror = zio_wait(zio);\n\n\t \n\tzio = zio_root(spa, NULL, NULL, flags);\n\n\tfor (vd = list_head(dl); vd != NULL; vd = list_next(dl, vd))\n\t\tzio_flush(zio, vd);\n\n\t(void) zio_wait(zio);\n\n\treturn (error);\n}\n\n \nint\nvdev_config_sync(vdev_t **svd, int svdcount, uint64_t txg)\n{\n\tspa_t *spa = svd[0]->vdev_spa;\n\tuberblock_t *ub = &spa->spa_uberblock;\n\tint error = 0;\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL;\n\n\tASSERT(svdcount != 0);\nretry:\n\t \n\tif (error != 0) {\n\t\tif ((flags & ZIO_FLAG_TRYHARD) != 0)\n\t\t\treturn (error);\n\t\tflags |= ZIO_FLAG_TRYHARD;\n\t}\n\n\tASSERT(ub->ub_txg <= txg);\n\n\t \n\tif (ub->ub_txg < txg) {\n\t\tboolean_t changed = uberblock_update(ub, spa->spa_root_vdev,\n\t\t    txg, spa->spa_mmp.mmp_delay);\n\n\t\tif (!changed && list_is_empty(&spa->spa_config_dirty_list))\n\t\t\treturn (0);\n\t}\n\n\tif (txg > spa_freeze_txg(spa))\n\t\treturn (0);\n\n\tASSERT(txg <= spa->spa_final_txg);\n\n\t \n\tzio_t *zio = zio_root(spa, NULL, NULL, flags);\n\n\tfor (vdev_t *vd =\n\t    txg_list_head(&spa->spa_vdev_txg_list, TXG_CLEAN(txg)); vd != NULL;\n\t    vd = txg_list_next(&spa->spa_vdev_txg_list, vd, TXG_CLEAN(txg)))\n\t\tzio_flush(zio, vd);\n\n\t(void) zio_wait(zio);\n\n\t \n\tif ((error = vdev_label_sync_list(spa, 0, txg, flags)) != 0) {\n\t\tif ((flags & ZIO_FLAG_TRYHARD) != 0) {\n\t\t\tzfs_dbgmsg(\"vdev_label_sync_list() returned error %d \"\n\t\t\t    \"for pool '%s' when syncing out the even labels \"\n\t\t\t    \"of dirty vdevs\", error, spa_name(spa));\n\t\t}\n\t\tgoto retry;\n\t}\n\n\t \n\tif ((error = vdev_uberblock_sync_list(svd, svdcount, ub, flags)) != 0) {\n\t\tif ((flags & ZIO_FLAG_TRYHARD) != 0) {\n\t\t\tzfs_dbgmsg(\"vdev_uberblock_sync_list() returned error \"\n\t\t\t    \"%d for pool '%s'\", error, spa_name(spa));\n\t\t}\n\t\tgoto retry;\n\t}\n\n\tif (spa_multihost(spa))\n\t\tmmp_update_uberblock(spa, ub);\n\n\t \n\tif ((error = vdev_label_sync_list(spa, 1, txg, flags)) != 0) {\n\t\tif ((flags & ZIO_FLAG_TRYHARD) != 0) {\n\t\t\tzfs_dbgmsg(\"vdev_label_sync_list() returned error %d \"\n\t\t\t    \"for pool '%s' when syncing out the odd labels of \"\n\t\t\t    \"dirty vdevs\", error, spa_name(spa));\n\t\t}\n\t\tgoto retry;\n\t}\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}