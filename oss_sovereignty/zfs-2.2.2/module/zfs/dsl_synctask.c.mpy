{
  "module_name": "dsl_synctask.c",
  "hash_id": "309509b91695285c553b8abe6cce27d8246e533155b2e4ab34a6e0132e820f90",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_synctask.c",
  "human_readable_source": " \n \n\n#include <sys/dmu.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_synctask.h>\n#include <sys/metaslab.h>\n\n#define\tDST_AVG_BLKSHIFT 14\n\nstatic int\ndsl_null_checkfunc(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg, (void) tx;\n\treturn (0);\n}\n\nstatic int\ndsl_sync_task_common(const char *pool, dsl_checkfunc_t *checkfunc,\n    dsl_syncfunc_t *syncfunc, dsl_sigfunc_t *sigfunc, void *arg,\n    int blocks_modified, zfs_space_check_t space_check, boolean_t early)\n{\n\tspa_t *spa;\n\tdmu_tx_t *tx;\n\tint err;\n\tdsl_sync_task_t dst = { { { NULL } } };\n\tdsl_pool_t *dp;\n\n\terr = spa_open(pool, &spa, FTAG);\n\tif (err != 0)\n\t\treturn (err);\n\tdp = spa_get_dsl(spa);\n\ntop:\n\ttx = dmu_tx_create_dd(dp->dp_mos_dir);\n\tVERIFY0(dmu_tx_assign(tx, TXG_WAIT));\n\n\tdst.dst_pool = dp;\n\tdst.dst_txg = dmu_tx_get_txg(tx);\n\tdst.dst_space = blocks_modified << DST_AVG_BLKSHIFT;\n\tdst.dst_space_check = space_check;\n\tdst.dst_checkfunc = checkfunc != NULL ? checkfunc : dsl_null_checkfunc;\n\tdst.dst_syncfunc = syncfunc;\n\tdst.dst_arg = arg;\n\tdst.dst_error = 0;\n\tdst.dst_nowaiter = B_FALSE;\n\n\tdsl_pool_config_enter(dp, FTAG);\n\terr = dst.dst_checkfunc(arg, tx);\n\tdsl_pool_config_exit(dp, FTAG);\n\n\tif (err != 0) {\n\t\tdmu_tx_commit(tx);\n\t\tspa_close(spa, FTAG);\n\t\treturn (err);\n\t}\n\n\ttxg_list_t *task_list = (early) ?\n\t    &dp->dp_early_sync_tasks : &dp->dp_sync_tasks;\n\tVERIFY(txg_list_add_tail(task_list, &dst, dst.dst_txg));\n\n\tdmu_tx_commit(tx);\n\n\tif (sigfunc != NULL && txg_wait_synced_sig(dp, dst.dst_txg)) {\n\t\t \n\t\tsigfunc(arg, tx);\n\t\tsigfunc = NULL;\t \n\t}\n\ttxg_wait_synced(dp, dst.dst_txg);\n\n\tif (dst.dst_error == EAGAIN) {\n\t\ttxg_wait_synced(dp, dst.dst_txg + TXG_DEFER_SIZE);\n\t\tgoto top;\n\t}\n\n\tspa_close(spa, FTAG);\n\treturn (dst.dst_error);\n}\n\n \nint\ndsl_sync_task(const char *pool, dsl_checkfunc_t *checkfunc,\n    dsl_syncfunc_t *syncfunc, void *arg,\n    int blocks_modified, zfs_space_check_t space_check)\n{\n\treturn (dsl_sync_task_common(pool, checkfunc, syncfunc, NULL, arg,\n\t    blocks_modified, space_check, B_FALSE));\n}\n\n \nint\ndsl_early_sync_task(const char *pool, dsl_checkfunc_t *checkfunc,\n    dsl_syncfunc_t *syncfunc, void *arg,\n    int blocks_modified, zfs_space_check_t space_check)\n{\n\treturn (dsl_sync_task_common(pool, checkfunc, syncfunc, NULL, arg,\n\t    blocks_modified, space_check, B_TRUE));\n}\n\n \nint\ndsl_sync_task_sig(const char *pool, dsl_checkfunc_t *checkfunc,\n    dsl_syncfunc_t *syncfunc, dsl_sigfunc_t *sigfunc, void *arg,\n    int blocks_modified, zfs_space_check_t space_check)\n{\n\treturn (dsl_sync_task_common(pool, checkfunc, syncfunc, sigfunc, arg,\n\t    blocks_modified, space_check, B_FALSE));\n}\n\nstatic void\ndsl_sync_task_nowait_common(dsl_pool_t *dp, dsl_syncfunc_t *syncfunc, void *arg,\n    dmu_tx_t *tx, boolean_t early)\n{\n\tdsl_sync_task_t *dst = kmem_zalloc(sizeof (*dst), KM_SLEEP);\n\n\tdst->dst_pool = dp;\n\tdst->dst_txg = dmu_tx_get_txg(tx);\n\tdst->dst_space_check = ZFS_SPACE_CHECK_NONE;\n\tdst->dst_checkfunc = dsl_null_checkfunc;\n\tdst->dst_syncfunc = syncfunc;\n\tdst->dst_arg = arg;\n\tdst->dst_error = 0;\n\tdst->dst_nowaiter = B_TRUE;\n\n\ttxg_list_t *task_list = (early) ?\n\t    &dp->dp_early_sync_tasks : &dp->dp_sync_tasks;\n\tVERIFY(txg_list_add_tail(task_list, dst, dst->dst_txg));\n}\n\nvoid\ndsl_sync_task_nowait(dsl_pool_t *dp, dsl_syncfunc_t *syncfunc, void *arg,\n    dmu_tx_t *tx)\n{\n\tdsl_sync_task_nowait_common(dp, syncfunc, arg, tx, B_FALSE);\n}\n\nvoid\ndsl_early_sync_task_nowait(dsl_pool_t *dp, dsl_syncfunc_t *syncfunc, void *arg,\n    dmu_tx_t *tx)\n{\n\tdsl_sync_task_nowait_common(dp, syncfunc, arg, tx, B_TRUE);\n}\n\n \nvoid\ndsl_sync_task_sync(dsl_sync_task_t *dst, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dst->dst_pool;\n\n\tASSERT0(dst->dst_error);\n\n\t \n\tif (dst->dst_space_check != ZFS_SPACE_CHECK_NONE) {\n\t\tuint64_t quota = dsl_pool_unreserved_space(dp,\n\t\t    dst->dst_space_check);\n\t\tuint64_t used = dsl_dir_phys(dp->dp_root_dir)->dd_used_bytes;\n\n\t\t \n\t\tif (used + dst->dst_space * 3 > quota) {\n\t\t\tdst->dst_error = SET_ERROR(ENOSPC);\n\t\t\tif (dst->dst_nowaiter)\n\t\t\t\tkmem_free(dst, sizeof (*dst));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\trrw_enter(&dp->dp_config_rwlock, RW_WRITER, FTAG);\n\tdst->dst_error = dst->dst_checkfunc(dst->dst_arg, tx);\n\tif (dst->dst_error == 0)\n\t\tdst->dst_syncfunc(dst->dst_arg, tx);\n\trrw_exit(&dp->dp_config_rwlock, FTAG);\n\tif (dst->dst_nowaiter)\n\t\tkmem_free(dst, sizeof (*dst));\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dsl_sync_task);\nEXPORT_SYMBOL(dsl_sync_task_nowait);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}