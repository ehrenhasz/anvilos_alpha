{
  "module_name": "dmu_redact.c",
  "hash_id": "40cfa73df86e024187178ff40e7ce06c46aedfddff758784ca6326975a550218",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu_redact.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/txg.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dmu_redact.h>\n#include <sys/bqueue.h>\n#include <sys/objlist.h>\n#include <sys/dmu_tx.h>\n#ifdef _KERNEL\n#include <sys/zfs_vfsops.h>\n#include <sys/zap.h>\n#include <sys/zfs_znode.h>\n#endif\n\n \nstatic const int redact_sync_bufsize = 1024;\n\n \nstatic const uint64_t redaction_list_update_interval_ns =\n    1000 * 1000 * 1000ULL;  \n\n \nstatic const int zfs_redact_queue_length = 1024 * 1024;\n\n \nstatic const uint64_t zfs_redact_queue_ff = 20;\n\nstruct redact_record {\n\tbqueue_node_t\t\tln;\n\tboolean_t\t\teos_marker;  \n\tuint64_t\t\tstart_object;\n\tuint64_t\t\tstart_blkid;\n\tuint64_t\t\tend_object;\n\tuint64_t\t\tend_blkid;\n\tuint8_t\t\t\tindblkshift;\n\tuint32_t\t\tdatablksz;\n};\n\nstruct redact_thread_arg {\n\tbqueue_t\tq;\n\tobjset_t\t*os;\t\t \n\tdsl_dataset_t\t*ds;\t\t \n\tstruct redact_record *current_record;\n\tint\t\terror_code;\n\tboolean_t\tcancel;\n\tzbookmark_phys_t resume;\n\tobjlist_t\t*deleted_objs;\n\tuint64_t\t*num_blocks_visited;\n\tuint64_t\tignore_object;\t \n\tuint64_t\ttxg;  \n};\n\n \nstruct redact_node {\n\tavl_node_t\t\t\tavl_node_start;\n\tavl_node_t\t\t\tavl_node_end;\n\tstruct redact_record\t\t*record;\n\tstruct redact_thread_arg\t*rt_arg;\n\tuint32_t\t\t\tthread_num;\n};\n\nstruct merge_data {\n\tlist_t\t\t\t\tmd_redact_block_pending;\n\tredact_block_phys_t\t\tmd_coalesce_block;\n\tuint64_t\t\t\tmd_last_time;\n\tredact_block_phys_t\t\tmd_furthest[TXG_SIZE];\n\t \n\tlist_t\t\t\t\tmd_blocks[TXG_SIZE];\n\tboolean_t\t\t\tmd_synctask_txg[TXG_SIZE];\n\tuint64_t\t\t\tmd_latest_synctask_txg;\n\tredaction_list_t\t\t*md_redaction_list;\n};\n\n \nstruct redact_block_list_node {\n\tredact_block_phys_t\tblock;\n\tlist_node_t\t\tnode;\n};\n\n \nstatic void\nrecord_merge_enqueue(bqueue_t *q, struct redact_record **build,\n    struct redact_record *new)\n{\n\tif (new->eos_marker) {\n\t\tif (*build != NULL)\n\t\t\tbqueue_enqueue(q, *build, sizeof (**build));\n\t\tbqueue_enqueue_flush(q, new, sizeof (*new));\n\t\treturn;\n\t}\n\tif (*build == NULL) {\n\t\t*build = new;\n\t\treturn;\n\t}\n\tstruct redact_record *curbuild = *build;\n\tif ((curbuild->end_object == new->start_object &&\n\t    curbuild->end_blkid + 1 == new->start_blkid &&\n\t    curbuild->end_blkid != UINT64_MAX) ||\n\t    (curbuild->end_object + 1 == new->start_object &&\n\t    curbuild->end_blkid == UINT64_MAX && new->start_blkid == 0)) {\n\t\tcurbuild->end_object = new->end_object;\n\t\tcurbuild->end_blkid = new->end_blkid;\n\t\tkmem_free(new, sizeof (*new));\n\t} else {\n\t\tbqueue_enqueue(q, curbuild, sizeof (*curbuild));\n\t\t*build = new;\n\t}\n}\n#ifdef _KERNEL\nstruct objnode {\n\tavl_node_t node;\n\tuint64_t obj;\n};\n\nstatic int\nobjnode_compare(const void *o1, const void *o2)\n{\n\tconst struct objnode *obj1 = o1;\n\tconst struct objnode *obj2 = o2;\n\tif (obj1->obj < obj2->obj)\n\t\treturn (-1);\n\tif (obj1->obj > obj2->obj)\n\t\treturn (1);\n\treturn (0);\n}\n\n\nstatic objlist_t *\nzfs_get_deleteq(objset_t *os)\n{\n\tobjlist_t *deleteq_objlist = objlist_create();\n\tuint64_t deleteq_obj;\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tdmu_object_info_t doi;\n\n\tASSERT3U(os->os_phys->os_type, ==, DMU_OST_ZFS);\n\tVERIFY0(dmu_object_info(os, MASTER_NODE_OBJ, &doi));\n\tASSERT3U(doi.doi_type, ==, DMU_OT_MASTER_NODE);\n\n\tVERIFY0(zap_lookup(os, MASTER_NODE_OBJ,\n\t    ZFS_UNLINKED_SET, sizeof (uint64_t), 1, &deleteq_obj));\n\n\t \n\tavl_tree_t at;\n\tavl_create(&at, objnode_compare, sizeof (struct objnode),\n\t    offsetof(struct objnode, node));\n\n\tfor (zap_cursor_init(&zc, os, deleteq_obj);\n\t    zap_cursor_retrieve(&zc, &za) == 0; zap_cursor_advance(&zc)) {\n\t\tstruct objnode *obj = kmem_zalloc(sizeof (*obj), KM_SLEEP);\n\t\tobj->obj = za.za_first_integer;\n\t\tavl_add(&at, obj);\n\t}\n\tzap_cursor_fini(&zc);\n\n\tstruct objnode *next, *found = avl_first(&at);\n\twhile (found != NULL) {\n\t\tnext = AVL_NEXT(&at, found);\n\t\tobjlist_insert(deleteq_objlist, found->obj);\n\t\tfound = next;\n\t}\n\n\tvoid *cookie = NULL;\n\twhile ((found = avl_destroy_nodes(&at, &cookie)) != NULL)\n\t\tkmem_free(found, sizeof (*found));\n\tavl_destroy(&at);\n\treturn (deleteq_objlist);\n}\n#endif\n\n \nstatic int\nredact_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const struct dnode_phys *dnp, void *arg)\n{\n\t(void) spa, (void) zilog;\n\tstruct redact_thread_arg *rta = arg;\n\tstruct redact_record *record;\n\n\tASSERT(zb->zb_object == DMU_META_DNODE_OBJECT ||\n\t    zb->zb_object >= rta->resume.zb_object);\n\n\tif (rta->cancel)\n\t\treturn (SET_ERROR(EINTR));\n\n\tif (rta->ignore_object == zb->zb_object)\n\t\treturn (0);\n\n\t \n\tif (zb->zb_level == ZB_DNODE_LEVEL) {\n\t\tASSERT3U(zb->zb_level, ==, ZB_DNODE_LEVEL);\n\n\t\tif (zb->zb_object == 0)\n\t\t\treturn (0);\n\n\t\t \n\t\tif (dnp->dn_type == DMU_OT_NONE ||\n\t\t    objlist_exists(rta->deleted_objs, zb->zb_object)) {\n\t\t\trta->ignore_object = zb->zb_object;\n\t\t\trecord = kmem_zalloc(sizeof (struct redact_record),\n\t\t\t    KM_SLEEP);\n\n\t\t\trecord->eos_marker = B_FALSE;\n\t\t\trecord->start_object = record->end_object =\n\t\t\t    zb->zb_object;\n\t\t\trecord->start_blkid = 0;\n\t\t\trecord->end_blkid = UINT64_MAX;\n\t\t\trecord_merge_enqueue(&rta->q,\n\t\t\t    &rta->current_record, record);\n\t\t}\n\t\treturn (0);\n\t} else if (zb->zb_level < 0) {\n\t\treturn (0);\n\t} else if (zb->zb_level > 0 && !BP_IS_HOLE(bp)) {\n\t\t \n\t\treturn (0);\n\t}\n\n\t \n\trecord = kmem_zalloc(sizeof (struct redact_record), KM_SLEEP);\n\trecord->eos_marker = B_FALSE;\n\n\trecord->start_object = record->end_object = zb->zb_object;\n\tif (BP_IS_HOLE(bp)) {\n\t\trecord->start_blkid = zb->zb_blkid *\n\t\t    bp_span_in_blocks(dnp->dn_indblkshift, zb->zb_level);\n\n\t\trecord->end_blkid = ((zb->zb_blkid + 1) *\n\t\t    bp_span_in_blocks(dnp->dn_indblkshift, zb->zb_level)) - 1;\n\n\t\tif (zb->zb_object == DMU_META_DNODE_OBJECT) {\n\t\t\trecord->start_object = record->start_blkid *\n\t\t\t    ((SPA_MINBLOCKSIZE * dnp->dn_datablkszsec) /\n\t\t\t    sizeof (dnode_phys_t));\n\t\t\trecord->start_blkid = 0;\n\t\t\trecord->end_object = ((record->end_blkid +\n\t\t\t    1) * ((SPA_MINBLOCKSIZE * dnp->dn_datablkszsec) /\n\t\t\t    sizeof (dnode_phys_t))) - 1;\n\t\t\trecord->end_blkid = UINT64_MAX;\n\t\t}\n\t} else if (zb->zb_level != 0 ||\n\t    zb->zb_object == DMU_META_DNODE_OBJECT) {\n\t\tkmem_free(record, sizeof (*record));\n\t\treturn (0);\n\t} else {\n\t\trecord->start_blkid = record->end_blkid = zb->zb_blkid;\n\t}\n\trecord->indblkshift = dnp->dn_indblkshift;\n\trecord->datablksz = dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT;\n\trecord_merge_enqueue(&rta->q, &rta->current_record, record);\n\n\treturn (0);\n}\n\nstatic __attribute__((noreturn)) void\nredact_traverse_thread(void *arg)\n{\n\tstruct redact_thread_arg *rt_arg = arg;\n\tint err;\n\tstruct redact_record *data;\n#ifdef _KERNEL\n\tif (rt_arg->os->os_phys->os_type == DMU_OST_ZFS)\n\t\trt_arg->deleted_objs = zfs_get_deleteq(rt_arg->os);\n\telse\n\t\trt_arg->deleted_objs = objlist_create();\n#else\n\trt_arg->deleted_objs = objlist_create();\n#endif\n\n\terr = traverse_dataset_resume(rt_arg->ds, rt_arg->txg,\n\t    &rt_arg->resume, TRAVERSE_PRE | TRAVERSE_PREFETCH_METADATA,\n\t    redact_cb, rt_arg);\n\n\tif (err != EINTR)\n\t\trt_arg->error_code = err;\n\tobjlist_destroy(rt_arg->deleted_objs);\n\tdata = kmem_zalloc(sizeof (*data), KM_SLEEP);\n\tdata->eos_marker = B_TRUE;\n\trecord_merge_enqueue(&rt_arg->q, &rt_arg->current_record, data);\n\tthread_exit();\n}\n\nstatic inline void\ncreate_zbookmark_from_obj_off(zbookmark_phys_t *zb, uint64_t object,\n    uint64_t blkid)\n{\n\tzb->zb_object = object;\n\tzb->zb_level = 0;\n\tzb->zb_blkid = blkid;\n}\n\n \nstatic int\nredact_range_compare(uint64_t obj1, uint64_t off1, uint32_t dbss1,\n    uint64_t obj2, uint64_t off2, uint32_t dbss2)\n{\n\tzbookmark_phys_t z1, z2;\n\tcreate_zbookmark_from_obj_off(&z1, obj1, off1);\n\tcreate_zbookmark_from_obj_off(&z2, obj2, off2);\n\n\treturn (zbookmark_compare(dbss1 >> SPA_MINBLOCKSHIFT, 0,\n\t    dbss2 >> SPA_MINBLOCKSHIFT, 0, &z1, &z2));\n}\n\n \nstatic int\nredact_node_compare_start(const void *arg1, const void *arg2)\n{\n\tconst struct redact_node *rn1 = arg1;\n\tconst struct redact_node *rn2 = arg2;\n\tconst struct redact_record *rr1 = rn1->record;\n\tconst struct redact_record *rr2 = rn2->record;\n\tif (rr1->eos_marker)\n\t\treturn (1);\n\tif (rr2->eos_marker)\n\t\treturn (-1);\n\n\tint cmp = redact_range_compare(rr1->start_object, rr1->start_blkid,\n\t    rr1->datablksz, rr2->start_object, rr2->start_blkid,\n\t    rr2->datablksz);\n\tif (cmp == 0)\n\t\tcmp = (rn1->thread_num < rn2->thread_num ? -1 : 1);\n\treturn (cmp);\n}\n\n \nstatic int\nredact_node_compare_end(const void *arg1, const void *arg2)\n{\n\tconst struct redact_node *rn1 = arg1;\n\tconst struct redact_node *rn2 = arg2;\n\tconst struct redact_record *srr1 = rn1->record;\n\tconst struct redact_record *srr2 = rn2->record;\n\tif (srr1->eos_marker)\n\t\treturn (1);\n\tif (srr2->eos_marker)\n\t\treturn (-1);\n\n\tint cmp = redact_range_compare(srr1->end_object, srr1->end_blkid,\n\t    srr1->datablksz, srr2->end_object, srr2->end_blkid,\n\t    srr2->datablksz);\n\tif (cmp == 0)\n\t\tcmp = (rn1->thread_num < rn2->thread_num ? -1 : 1);\n\treturn (cmp);\n}\n\n \nstatic boolean_t\nredact_record_before(const struct redact_record *from,\n    const struct redact_record *to)\n{\n\tif (from->eos_marker == B_TRUE)\n\t\treturn (B_FALSE);\n\telse if (to->eos_marker == B_TRUE)\n\t\treturn (B_TRUE);\n\treturn (redact_range_compare(from->start_object, from->start_blkid,\n\t    from->datablksz, to->end_object, to->end_blkid,\n\t    to->datablksz) <= 0);\n}\n\n \nstatic struct redact_record *\nget_next_redact_record(bqueue_t *bq, struct redact_record *prev)\n{\n\tstruct redact_record *next = bqueue_dequeue(bq);\n\tASSERT(redact_record_before(prev, next));\n\tkmem_free(prev, sizeof (*prev));\n\treturn (next);\n}\n\n \nstatic int\nupdate_avl_trees(avl_tree_t *start_tree, avl_tree_t *end_tree,\n    struct redact_node *redact_node)\n{\n\tavl_remove(start_tree, redact_node);\n\tavl_remove(end_tree, redact_node);\n\tredact_node->record = get_next_redact_record(&redact_node->rt_arg->q,\n\t    redact_node->record);\n\tavl_add(end_tree, redact_node);\n\tavl_add(start_tree, redact_node);\n\treturn (redact_node->rt_arg->error_code);\n}\n\n \nstatic void\nredaction_list_update_sync(void *arg, dmu_tx_t *tx)\n{\n\tstruct merge_data *md = arg;\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tlist_t *list = &md->md_blocks[txg & TXG_MASK];\n\tredact_block_phys_t *furthest_visited =\n\t    &md->md_furthest[txg & TXG_MASK];\n\tobjset_t *mos = tx->tx_pool->dp_meta_objset;\n\tredaction_list_t *rl = md->md_redaction_list;\n\tint bufsize = redact_sync_bufsize;\n\tredact_block_phys_t *buf = kmem_alloc(bufsize * sizeof (*buf),\n\t    KM_SLEEP);\n\tint index = 0;\n\n\tdmu_buf_will_dirty(rl->rl_dbuf, tx);\n\n\tfor (struct redact_block_list_node *rbln = list_remove_head(list);\n\t    rbln != NULL; rbln = list_remove_head(list)) {\n\t\tASSERT3U(rbln->block.rbp_object, <=,\n\t\t    furthest_visited->rbp_object);\n\t\tASSERT(rbln->block.rbp_object < furthest_visited->rbp_object ||\n\t\t    rbln->block.rbp_blkid <= furthest_visited->rbp_blkid);\n\t\tbuf[index] = rbln->block;\n\t\tindex++;\n\t\tif (index == bufsize) {\n\t\t\tdmu_write(mos, rl->rl_object,\n\t\t\t    rl->rl_phys->rlp_num_entries * sizeof (*buf),\n\t\t\t    bufsize * sizeof (*buf), buf, tx);\n\t\t\trl->rl_phys->rlp_num_entries += bufsize;\n\t\t\tindex = 0;\n\t\t}\n\t\tkmem_free(rbln, sizeof (*rbln));\n\t}\n\tif (index > 0) {\n\t\tdmu_write(mos, rl->rl_object, rl->rl_phys->rlp_num_entries *\n\t\t    sizeof (*buf), index * sizeof (*buf), buf, tx);\n\t\trl->rl_phys->rlp_num_entries += index;\n\t}\n\tkmem_free(buf, bufsize * sizeof (*buf));\n\n\tmd->md_synctask_txg[txg & TXG_MASK] = B_FALSE;\n\trl->rl_phys->rlp_last_object = furthest_visited->rbp_object;\n\trl->rl_phys->rlp_last_blkid = furthest_visited->rbp_blkid;\n}\n\nstatic void\ncommit_rl_updates(objset_t *os, struct merge_data *md, uint64_t object,\n    uint64_t blkid)\n{\n\tdmu_tx_t *tx = dmu_tx_create_dd(spa_get_dsl(os->os_spa)->dp_mos_dir);\n\tdmu_tx_hold_space(tx, sizeof (struct redact_block_list_node));\n\tVERIFY0(dmu_tx_assign(tx, TXG_WAIT));\n\tuint64_t txg = dmu_tx_get_txg(tx);\n\tif (!md->md_synctask_txg[txg & TXG_MASK]) {\n\t\tdsl_sync_task_nowait(dmu_tx_pool(tx),\n\t\t    redaction_list_update_sync, md, tx);\n\t\tmd->md_synctask_txg[txg & TXG_MASK] = B_TRUE;\n\t\tmd->md_latest_synctask_txg = txg;\n\t}\n\tmd->md_furthest[txg & TXG_MASK].rbp_object = object;\n\tmd->md_furthest[txg & TXG_MASK].rbp_blkid = blkid;\n\tlist_move_tail(&md->md_blocks[txg & TXG_MASK],\n\t    &md->md_redact_block_pending);\n\tdmu_tx_commit(tx);\n\tmd->md_last_time = gethrtime();\n}\n\n \nstatic void\nupdate_redaction_list(struct merge_data *md, objset_t *os,\n    uint64_t object, uint64_t blkid, uint64_t endblkid, uint32_t blksz)\n{\n\tboolean_t enqueue = B_FALSE;\n\tredact_block_phys_t cur = {0};\n\tuint64_t count = endblkid - blkid + 1;\n\twhile (count > REDACT_BLOCK_MAX_COUNT) {\n\t\tupdate_redaction_list(md, os, object, blkid,\n\t\t    blkid + REDACT_BLOCK_MAX_COUNT - 1, blksz);\n\t\tblkid += REDACT_BLOCK_MAX_COUNT;\n\t\tcount -= REDACT_BLOCK_MAX_COUNT;\n\t}\n\tredact_block_phys_t *coalesce = &md->md_coalesce_block;\n\tboolean_t new;\n\tif (coalesce->rbp_size_count == 0) {\n\t\tnew = B_TRUE;\n\t\tenqueue = B_FALSE;\n\t} else  {\n\t\tuint64_t old_count = redact_block_get_count(coalesce);\n\t\tif (coalesce->rbp_object == object &&\n\t\t    coalesce->rbp_blkid + old_count == blkid &&\n\t\t    old_count + count <= REDACT_BLOCK_MAX_COUNT) {\n\t\t\tASSERT3U(redact_block_get_size(coalesce), ==, blksz);\n\t\t\tredact_block_set_count(coalesce, old_count + count);\n\t\t\tnew = B_FALSE;\n\t\t\tenqueue = B_FALSE;\n\t\t} else {\n\t\t\tnew = B_TRUE;\n\t\t\tenqueue = B_TRUE;\n\t\t}\n\t}\n\n\tif (new) {\n\t\tcur = *coalesce;\n\t\tcoalesce->rbp_blkid = blkid;\n\t\tcoalesce->rbp_object = object;\n\n\t\tredact_block_set_count(coalesce, count);\n\t\tredact_block_set_size(coalesce, blksz);\n\t}\n\n\tif (enqueue && redact_block_get_size(&cur) != 0) {\n\t\tstruct redact_block_list_node *rbln =\n\t\t    kmem_alloc(sizeof (struct redact_block_list_node),\n\t\t    KM_SLEEP);\n\t\trbln->block = cur;\n\t\tlist_insert_tail(&md->md_redact_block_pending, rbln);\n\t}\n\n\tif (gethrtime() > md->md_last_time +\n\t    redaction_list_update_interval_ns) {\n\t\tcommit_rl_updates(os, md, object, blkid);\n\t}\n}\n\n \nstatic int\nperform_thread_merge(bqueue_t *q, uint32_t num_threads,\n    struct redact_thread_arg *thread_args, boolean_t *cancel)\n{\n\tstruct redact_node *redact_nodes = NULL;\n\tavl_tree_t start_tree, end_tree;\n\tstruct redact_record *record;\n\tstruct redact_record *current_record = NULL;\n\tint err = 0;\n\tstruct merge_data md = { {0} };\n\tlist_create(&md.md_redact_block_pending,\n\t    sizeof (struct redact_block_list_node),\n\t    offsetof(struct redact_block_list_node, node));\n\n\t \n\tif (num_threads == 0) {\n\t\trecord = kmem_zalloc(sizeof (struct redact_record),\n\t\t    KM_SLEEP);\n\t\t\n\t\trecord->start_object = 1;\n\t\trecord->start_blkid = 0;\n\t\trecord->end_object = record->end_blkid = UINT64_MAX;\n\t\tbqueue_enqueue(q, record, sizeof (*record));\n\t\treturn (0);\n\t}\n\tredact_nodes = kmem_zalloc(num_threads *\n\t    sizeof (*redact_nodes), KM_SLEEP);\n\n\tavl_create(&start_tree, redact_node_compare_start,\n\t    sizeof (struct redact_node),\n\t    offsetof(struct redact_node, avl_node_start));\n\tavl_create(&end_tree, redact_node_compare_end,\n\t    sizeof (struct redact_node),\n\t    offsetof(struct redact_node, avl_node_end));\n\n\tfor (int i = 0; i < num_threads; i++) {\n\t\tstruct redact_node *node = &redact_nodes[i];\n\t\tstruct redact_thread_arg *targ = &thread_args[i];\n\t\tnode->record = bqueue_dequeue(&targ->q);\n\t\tnode->rt_arg = targ;\n\t\tnode->thread_num = i;\n\t\tavl_add(&start_tree, node);\n\t\tavl_add(&end_tree, node);\n\t}\n\n\t \n\twhile (err == 0 && !((struct redact_node *)avl_first(&end_tree))->\n\t    record->eos_marker) {\n\t\tif (*cancel) {\n\t\t\terr = EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tstruct redact_node *last_start = avl_last(&start_tree);\n\t\tstruct redact_node *first_end = avl_first(&end_tree);\n\n\t\t \n\t\tif (redact_record_before(last_start->record,\n\t\t    first_end->record)) {\n\t\t\trecord = kmem_zalloc(sizeof (struct redact_record),\n\t\t\t    KM_SLEEP);\n\t\t\t*record = *first_end->record;\n\t\t\trecord->start_object = last_start->record->start_object;\n\t\t\trecord->start_blkid = last_start->record->start_blkid;\n\t\t\trecord_merge_enqueue(q, &current_record,\n\t\t\t    record);\n\t\t}\n\t\terr = update_avl_trees(&start_tree, &end_tree, first_end);\n\t}\n\n\t \n\tfor (int i = 0; i < num_threads; i++) {\n\t\tif (err != 0) {\n\t\t\tthread_args[i].cancel = B_TRUE;\n\t\t\twhile (!redact_nodes[i].record->eos_marker) {\n\t\t\t\t(void) update_avl_trees(&start_tree, &end_tree,\n\t\t\t\t    &redact_nodes[i]);\n\t\t\t}\n\t\t}\n\t\tavl_remove(&start_tree, &redact_nodes[i]);\n\t\tavl_remove(&end_tree, &redact_nodes[i]);\n\t\tkmem_free(redact_nodes[i].record,\n\t\t    sizeof (struct redact_record));\n\t\tbqueue_destroy(&thread_args[i].q);\n\t}\n\n\tavl_destroy(&start_tree);\n\tavl_destroy(&end_tree);\n\tkmem_free(redact_nodes, num_threads * sizeof (*redact_nodes));\n\tif (current_record != NULL)\n\t\tbqueue_enqueue(q, current_record, sizeof (*current_record));\n\treturn (err);\n}\n\nstruct redact_merge_thread_arg {\n\tbqueue_t q;\n\tspa_t *spa;\n\tint numsnaps;\n\tstruct redact_thread_arg *thr_args;\n\tboolean_t cancel;\n\tint error_code;\n};\n\nstatic __attribute__((noreturn)) void\nredact_merge_thread(void *arg)\n{\n\tstruct redact_merge_thread_arg *rmta = arg;\n\trmta->error_code = perform_thread_merge(&rmta->q,\n\t    rmta->numsnaps, rmta->thr_args, &rmta->cancel);\n\tstruct redact_record *rec = kmem_zalloc(sizeof (*rec), KM_SLEEP);\n\trec->eos_marker = B_TRUE;\n\tbqueue_enqueue_flush(&rmta->q, rec, 1);\n\tthread_exit();\n}\n\n \nstatic int\nhold_next_object(objset_t *os, struct redact_record *rec, const void *tag,\n    uint64_t *object, dnode_t **dn)\n{\n\tint err = 0;\n\tif (*dn != NULL)\n\t\tdnode_rele(*dn, tag);\n\t*dn = NULL;\n\tif (*object < rec->start_object) {\n\t\t*object = rec->start_object - 1;\n\t}\n\terr = dmu_object_next(os, object, B_FALSE, 0);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = dnode_hold(os, *object, tag, dn);\n\twhile (err == 0 && (*object < rec->start_object ||\n\t    DMU_OT_IS_METADATA((*dn)->dn_type))) {\n\t\tdnode_rele(*dn, tag);\n\t\t*dn = NULL;\n\t\terr = dmu_object_next(os, object, B_FALSE, 0);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t\terr = dnode_hold(os, *object, tag, dn);\n\t}\n\treturn (err);\n}\n\nstatic int\nperform_redaction(objset_t *os, redaction_list_t *rl,\n    struct redact_merge_thread_arg *rmta)\n{\n\tint err = 0;\n\tbqueue_t *q = &rmta->q;\n\tstruct redact_record *rec = NULL;\n\tstruct merge_data md = { {0} };\n\n\tlist_create(&md.md_redact_block_pending,\n\t    sizeof (struct redact_block_list_node),\n\t    offsetof(struct redact_block_list_node, node));\n\tmd.md_redaction_list = rl;\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tlist_create(&md.md_blocks[i],\n\t\t    sizeof (struct redact_block_list_node),\n\t\t    offsetof(struct redact_block_list_node, node));\n\t}\n\tdnode_t *dn = NULL;\n\tuint64_t prev_obj = 0;\n\tfor (rec = bqueue_dequeue(q); !rec->eos_marker && err == 0;\n\t    rec = get_next_redact_record(q, rec)) {\n\t\tASSERT3U(rec->start_object, !=, 0);\n\t\tuint64_t object;\n\t\tif (prev_obj != rec->start_object) {\n\t\t\tobject = rec->start_object - 1;\n\t\t\terr = hold_next_object(os, rec, FTAG, &object, &dn);\n\t\t} else {\n\t\t\tobject = prev_obj;\n\t\t}\n\t\twhile (err == 0 && object <= rec->end_object) {\n\t\t\tif (issig(JUSTLOOKING) && issig(FORREAL)) {\n\t\t\t\terr = EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tuint64_t startblkid;\n\t\t\tuint64_t endblkid;\n\t\t\tuint64_t maxblkid = dn->dn_phys->dn_maxblkid;\n\n\t\t\tif (rec->start_object < object)\n\t\t\t\tstartblkid = 0;\n\t\t\telse if (rec->start_blkid > maxblkid)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tstartblkid = rec->start_blkid;\n\n\t\t\tif (rec->end_object > object || rec->end_blkid >\n\t\t\t    maxblkid) {\n\t\t\t\tendblkid = maxblkid;\n\t\t\t} else {\n\t\t\t\tendblkid = rec->end_blkid;\n\t\t\t}\n\t\t\tupdate_redaction_list(&md, os, object, startblkid,\n\t\t\t    endblkid, dn->dn_datablksz);\n\n\t\t\tif (object == rec->end_object)\n\t\t\t\tbreak;\n\t\t\terr = hold_next_object(os, rec, FTAG, &object, &dn);\n\t\t}\n\t\tif (err == ESRCH)\n\t\t\terr = 0;\n\t\tif (dn != NULL)\n\t\t\tprev_obj = object;\n\t}\n\tif (err == 0 && dn != NULL)\n\t\tdnode_rele(dn, FTAG);\n\n\tif (err == ESRCH)\n\t\terr = 0;\n\trmta->cancel = B_TRUE;\n\twhile (!rec->eos_marker)\n\t\trec = get_next_redact_record(q, rec);\n\tkmem_free(rec, sizeof (*rec));\n\n\t \n\tif (err == 0 && md.md_coalesce_block.rbp_size_count != 0) {\n\t\tstruct redact_block_list_node *rbln =\n\t\t    kmem_alloc(sizeof (struct redact_block_list_node),\n\t\t    KM_SLEEP);\n\t\trbln->block = md.md_coalesce_block;\n\t\tlist_insert_tail(&md.md_redact_block_pending, rbln);\n\t}\n\tcommit_rl_updates(os, &md, UINT64_MAX, UINT64_MAX);\n\n\t \n\tdsl_pool_t *dp = spa_get_dsl(os->os_spa);\n\tif (md.md_latest_synctask_txg != 0)\n\t\ttxg_wait_synced(dp, md.md_latest_synctask_txg);\n\tfor (int i = 0; i < TXG_SIZE; i++)\n\t\tlist_destroy(&md.md_blocks[i]);\n\treturn (err);\n}\n\nstatic boolean_t\nredact_snaps_contains(uint64_t *snaps, uint64_t num_snaps, uint64_t guid)\n{\n\tfor (int i = 0; i < num_snaps; i++) {\n\t\tif (snaps[i] == guid)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\nint\ndmu_redact_snap(const char *snapname, nvlist_t *redactnvl,\n    const char *redactbook)\n{\n\tint err = 0;\n\tdsl_pool_t *dp = NULL;\n\tdsl_dataset_t *ds = NULL;\n\tint numsnaps = 0;\n\tobjset_t *os;\n\tstruct redact_thread_arg *args = NULL;\n\tredaction_list_t *new_rl = NULL;\n\tchar *newredactbook;\n\n\tif ((err = dsl_pool_hold(snapname, FTAG, &dp)) != 0)\n\t\treturn (err);\n\n\tnewredactbook = kmem_zalloc(sizeof (char) * ZFS_MAX_DATASET_NAME_LEN,\n\t    KM_SLEEP);\n\n\tif ((err = dsl_dataset_hold_flags(dp, snapname, DS_HOLD_FLAG_DECRYPT,\n\t    FTAG, &ds)) != 0) {\n\t\tgoto out;\n\t}\n\tdsl_dataset_long_hold(ds, FTAG);\n\tif (!ds->ds_is_snapshot || dmu_objset_from_ds(ds, &os) != 0) {\n\t\terr = EINVAL;\n\t\tgoto out;\n\t}\n\tif (dsl_dataset_feature_is_active(ds, SPA_FEATURE_REDACTED_DATASETS)) {\n\t\terr = EALREADY;\n\t\tgoto out;\n\t}\n\n\tnumsnaps = fnvlist_num_pairs(redactnvl);\n\tif (numsnaps > 0)\n\t\targs = kmem_zalloc(numsnaps * sizeof (*args), KM_SLEEP);\n\n\tnvpair_t *pair = NULL;\n\tfor (int i = 0; i < numsnaps; i++) {\n\t\tpair = nvlist_next_nvpair(redactnvl, pair);\n\t\tconst char *name = nvpair_name(pair);\n\t\tstruct redact_thread_arg *rta = &args[i];\n\t\terr = dsl_dataset_hold_flags(dp, name, DS_HOLD_FLAG_DECRYPT,\n\t\t    FTAG, &rta->ds);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t\t \n\t\tdsl_dataset_long_hold(rta->ds, FTAG);\n\n\t\terr = dmu_objset_from_ds(rta->ds, &rta->os);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t\tif (!dsl_dataset_is_before(rta->ds, ds, 0)) {\n\t\t\terr = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (dsl_dataset_feature_is_active(rta->ds,\n\t\t    SPA_FEATURE_REDACTED_DATASETS)) {\n\t\t\terr = EALREADY;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\tif (err != 0)\n\t\tgoto out;\n\tVERIFY3P(nvlist_next_nvpair(redactnvl, pair), ==, NULL);\n\n\tboolean_t resuming = B_FALSE;\n\tzfs_bookmark_phys_t bookmark;\n\n\t(void) strlcpy(newredactbook, snapname, ZFS_MAX_DATASET_NAME_LEN);\n\tchar *c = strchr(newredactbook, '@');\n\tASSERT3P(c, !=, NULL);\n\tint n = snprintf(c, ZFS_MAX_DATASET_NAME_LEN - (c - newredactbook),\n\t    \"#%s\", redactbook);\n\tif (n >= ZFS_MAX_DATASET_NAME_LEN - (c - newredactbook)) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\tkmem_free(newredactbook,\n\t\t    sizeof (char) * ZFS_MAX_DATASET_NAME_LEN);\n\t\tif (args != NULL)\n\t\t\tkmem_free(args, numsnaps * sizeof (*args));\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t}\n\terr = dsl_bookmark_lookup(dp, newredactbook, NULL, &bookmark);\n\tif (err == 0) {\n\t\tresuming = B_TRUE;\n\t\tif (bookmark.zbm_redaction_obj == 0) {\n\t\t\terr = EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\terr = dsl_redaction_list_hold_obj(dp,\n\t\t    bookmark.zbm_redaction_obj, FTAG, &new_rl);\n\t\tif (err != 0) {\n\t\t\terr = EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tdsl_redaction_list_long_hold(dp, new_rl, FTAG);\n\t\tif (new_rl->rl_phys->rlp_num_snaps != numsnaps) {\n\t\t\terr = ESRCH;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (int i = 0; i < numsnaps; i++) {\n\t\t\tstruct redact_thread_arg *rta = &args[i];\n\t\t\tif (!redact_snaps_contains(new_rl->rl_phys->rlp_snaps,\n\t\t\t    new_rl->rl_phys->rlp_num_snaps,\n\t\t\t    dsl_dataset_phys(rta->ds)->ds_guid)) {\n\t\t\t\terr = ESRCH;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (new_rl->rl_phys->rlp_last_blkid == UINT64_MAX &&\n\t\t    new_rl->rl_phys->rlp_last_object == UINT64_MAX) {\n\t\t\terr = EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\tdsl_pool_rele(dp, FTAG);\n\t\tdp = NULL;\n\t} else {\n\t\tuint64_t *guids = NULL;\n\t\tif (numsnaps > 0) {\n\t\t\tguids = kmem_zalloc(numsnaps * sizeof (uint64_t),\n\t\t\t    KM_SLEEP);\n\t\t}\n\t\tfor (int i = 0; i < numsnaps; i++) {\n\t\t\tstruct redact_thread_arg *rta = &args[i];\n\t\t\tguids[i] = dsl_dataset_phys(rta->ds)->ds_guid;\n\t\t}\n\n\t\tdsl_pool_rele(dp, FTAG);\n\t\tdp = NULL;\n\t\terr = dsl_bookmark_create_redacted(newredactbook, snapname,\n\t\t    numsnaps, guids, FTAG, &new_rl);\n\t\tkmem_free(guids, numsnaps * sizeof (uint64_t));\n\t\tif (err != 0) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < numsnaps; i++) {\n\t\tstruct redact_thread_arg *rta = &args[i];\n\t\t(void) bqueue_init(&rta->q, zfs_redact_queue_ff,\n\t\t    zfs_redact_queue_length,\n\t\t    offsetof(struct redact_record, ln));\n\t\tif (resuming) {\n\t\t\trta->resume.zb_blkid =\n\t\t\t    new_rl->rl_phys->rlp_last_blkid;\n\t\t\trta->resume.zb_object =\n\t\t\t    new_rl->rl_phys->rlp_last_object;\n\t\t}\n\t\trta->txg = dsl_dataset_phys(ds)->ds_creation_txg;\n\t\t(void) thread_create(NULL, 0, redact_traverse_thread, rta,\n\t\t    0, curproc, TS_RUN, minclsyspri);\n\t}\n\n\tstruct redact_merge_thread_arg *rmta;\n\trmta = kmem_zalloc(sizeof (struct redact_merge_thread_arg), KM_SLEEP);\n\n\t(void) bqueue_init(&rmta->q, zfs_redact_queue_ff,\n\t    zfs_redact_queue_length, offsetof(struct redact_record, ln));\n\trmta->numsnaps = numsnaps;\n\trmta->spa = os->os_spa;\n\trmta->thr_args = args;\n\t(void) thread_create(NULL, 0, redact_merge_thread, rmta, 0, curproc,\n\t    TS_RUN, minclsyspri);\n\terr = perform_redaction(os, new_rl, rmta);\n\tbqueue_destroy(&rmta->q);\n\tkmem_free(rmta, sizeof (struct redact_merge_thread_arg));\n\nout:\n\tkmem_free(newredactbook, sizeof (char) * ZFS_MAX_DATASET_NAME_LEN);\n\n\tif (new_rl != NULL) {\n\t\tdsl_redaction_list_long_rele(new_rl, FTAG);\n\t\tdsl_redaction_list_rele(new_rl, FTAG);\n\t}\n\tfor (int i = 0; i < numsnaps; i++) {\n\t\tstruct redact_thread_arg *rta = &args[i];\n\t\t \n\t\tif (rta->ds != NULL) {\n\t\t\tdsl_dataset_long_rele(rta->ds, FTAG);\n\t\t\tdsl_dataset_rele_flags(rta->ds,\n\t\t\t    DS_HOLD_FLAG_DECRYPT, FTAG);\n\t\t}\n\t}\n\n\tif (args != NULL)\n\t\tkmem_free(args, numsnaps * sizeof (*args));\n\tif (dp != NULL)\n\t\tdsl_pool_rele(dp, FTAG);\n\tif (ds != NULL) {\n\t\tdsl_dataset_long_rele(ds, FTAG);\n\t\tdsl_dataset_rele_flags(ds, DS_HOLD_FLAG_DECRYPT, FTAG);\n\t}\n\treturn (SET_ERROR(err));\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}