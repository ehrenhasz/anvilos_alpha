{
  "module_name": "vdev_draid.c",
  "hash_id": "d1e5bf11e6623903871ff160f5fcadbf826a6462f6a5d5e98ca3c70dd9a4d535",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev_draid.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_draid.h>\n#include <sys/vdev_raidz.h>\n#include <sys/vdev_rebuild.h>\n#include <sys/abd.h>\n#include <sys/zio.h>\n#include <sys/nvpair.h>\n#include <sys/zio_checksum.h>\n#include <sys/fs/zfs.h>\n#include <sys/fm/fs/zfs.h>\n#include <zfs_fletcher.h>\n\n#ifdef ZFS_DEBUG\n#include <sys/vdev.h>\t \n#endif\n\n \nstatic const draid_map_t draid_maps[VDEV_DRAID_MAX_MAPS] = {\n\t{   2, 256, 0x89ef3dabbcc7de37, 0x00000000433d433d },\t \n\t{   3, 256, 0x89a57f3de98121b4, 0x00000000bcd8b7b5 },\t \n\t{   4, 256, 0xc9ea9ec82340c885, 0x00000001819d7c69 },\t \n\t{   5, 256, 0xf46733b7f4d47dfd, 0x00000002a1648d74 },\t \n\t{   6, 256, 0x88c3c62d8585b362, 0x00000003d3b0c2c4 },\t \n\t{   7, 256, 0x3a65d809b4d1b9d5, 0x000000055c4183ee },\t \n\t{   8, 256, 0xe98930e3c5d2e90a, 0x00000006edfb0329 },\t \n\t{   9, 256, 0x5a5430036b982ccb, 0x00000008ceaf6934 },\t \n\t{  10, 256, 0x92bf389e9eadac74, 0x0000000b26668c09 },\t \n\t{  11, 256, 0x74ccebf1dcf3ae80, 0x0000000dd691358c },\t \n\t{  12, 256, 0x8847e41a1a9f5671, 0x00000010a0c63c8e },\t \n\t{  13, 256, 0x7481b56debf0e637, 0x0000001424121fe4 },\t \n\t{  14, 256, 0x559b8c44065f8967, 0x00000016ab2ff079 },\t \n\t{  15, 256, 0x34c49545a2ee7f01, 0x0000001a6028efd6 },\t \n\t{  16, 256, 0xb85f4fa81a7698f7, 0x0000001e95ff5e66 },\t \n\t{  17, 256, 0x6353e47b7e47aba0, 0x00000021a81fa0fe },\t \n\t{  18, 256, 0xaa549746b1cbb81c, 0x00000026f02494c9 },\t \n\t{  19, 256, 0x892e343f2f31d690, 0x00000029eb392835 },\t \n\t{  20, 256, 0x76914824db98cc3f, 0x0000003004f31a7c },\t \n\t{  21, 256, 0x4b3cbabf9cfb1d0f, 0x00000036363a2408 },\t \n\t{  22, 256, 0xf45c77abb4f035d4, 0x00000038dd0f3e84 },\t \n\t{  23, 256, 0x5e18bd7f3fd4baf4, 0x0000003f0660391f },\t \n\t{  24, 256, 0xa7b3a4d285d6503b, 0x000000443dfc9ff6 },\t \n\t{  25, 256, 0x56ac7dd967521f5a, 0x0000004b03a87eb7 },\t \n\t{  26, 256, 0x3a42dfda4eb880f7, 0x000000522c719bba },\t \n\t{  27, 256, 0xd200d2fc6b54bf60, 0x0000005760b4fdf5 },\t \n\t{  28, 256, 0xc52605bbd486c546, 0x0000005e00d8f74c },\t \n\t{  29, 256, 0xc761779e63cd762f, 0x00000067be3cd85c },\t \n\t{  30, 256, 0xca577b1e07f85ca5, 0x0000006f5517f3e4 },\t \n\t{  31, 256, 0xfd50a593c518b3d4, 0x0000007370e7778f },\t \n\t{  32, 512, 0xc6c87ba5b042650b, 0x000000f7eb08a156 },\t \n\t{  33, 512, 0xc3880d0c9d458304, 0x0000010734b5d160 },\t \n\t{  34, 512, 0xe920927e4d8b2c97, 0x00000118c1edbce0 },\t \n\t{  35, 512, 0x8da7fcda87bde316, 0x0000012a3e9f9110 },\t \n\t{  36, 512, 0xcf09937491514a29, 0x0000013bd6a24bef },\t \n\t{  37, 512, 0x9b5abbf345cbd7cc, 0x0000014b9d90fac3 },\t \n\t{  38, 512, 0x506312a44668d6a9, 0x0000015e1b5f6148 },\t \n\t{  39, 512, 0x71659ede62b4755f, 0x00000173ef029bcd },\t \n\t{  40, 512, 0xa7fde73fb74cf2d7, 0x000001866fb72748 },\t \n\t{  41, 512, 0x19e8b461a1dea1d3, 0x000001a046f76b23 },\t \n\t{  42, 512, 0x031c9b868cc3e976, 0x000001afa64c49d3 },\t \n\t{  43, 512, 0xbaa5125faa781854, 0x000001c76789e278 },\t \n\t{  44, 512, 0x4ed55052550d721b, 0x000001d800ccd8eb },\t \n\t{  45, 512, 0x0fd63ddbdff90677, 0x000001f08ad59ed2 },\t \n\t{  46, 512, 0x36d66546de7fdd6f, 0x000002016f09574b },\t \n\t{  47, 512, 0x99f997e7eafb69d7, 0x0000021e42e47cb6 },\t \n\t{  48, 512, 0xbecd9c2571312c5d, 0x000002320fe2872b },\t \n\t{  49, 512, 0xd97371329e488a32, 0x0000024cd73f2ca7 },\t \n\t{  50, 512, 0x30e9b136670749ee, 0x000002681c83b0e0 },\t \n\t{  51, 512, 0x11ad6bc8f47aaeb4, 0x0000027e9261b5d5 },\t \n\t{  52, 512, 0x68e445300af432c1, 0x0000029aa0eb7dbf },\t \n\t{  53, 512, 0x910fb561657ea98c, 0x000002b3dca04853 },\t \n\t{  54, 512, 0xd619693d8ce5e7a5, 0x000002cc280e9c97 },\t \n\t{  55, 512, 0x24e281f564dbb60a, 0x000002e9fa842713 },\t \n\t{  56, 512, 0x947a7d3bdaab44c5, 0x000003046680f72e },\t \n\t{  57, 512, 0x2d44fec9c093e0de, 0x00000324198ba810 },\t \n\t{  58, 512, 0x87743c272d29bb4c, 0x0000033ec48c9ac9 },\t \n\t{  59, 512, 0x96aa3b6f67f5d923, 0x0000034faead902c },\t \n\t{  60, 512, 0x94a4f1faf520b0d3, 0x0000037d713ab005 },\t \n\t{  61, 512, 0xb13ed3a272f711a2, 0x00000397368f3cbd },\t \n\t{  62, 512, 0x3b1b11805fa4a64a, 0x000003b8a5e2840c },\t \n\t{  63, 512, 0x4c74caad9172ba71, 0x000003d4be280290 },\t \n\t{  64, 512, 0x035ff643923dd29e, 0x000003fad6c355e1 },\t \n\t{  65, 512, 0x768e9171b11abd3c, 0x0000040eb07fed20 },\t \n\t{  66, 512, 0x75880e6f78a13ddd, 0x000004433d6acf14 },\t \n\t{  67, 512, 0x910b9714f698a877, 0x00000451ea65d5db },\t \n\t{  68, 512, 0x87f5db6f9fdcf5c7, 0x000004732169e3f7 },\t \n\t{  69, 512, 0x836d4968fbaa3706, 0x000004954068a380 },\t \n\t{  70, 512, 0xc567d73a036421ab, 0x000004bd7cb7bd3d },\t \n\t{  71, 512, 0x619df40f240b8fed, 0x000004e376c2e972 },\t \n\t{  72, 512, 0x42763a680d5bed8e, 0x000005084275c680 },\t \n\t{  73, 512, 0x5866f064b3230431, 0x0000052906f2c9ab },\t \n\t{  74, 512, 0x9fa08548b1621a44, 0x0000054708019247 },\t \n\t{  75, 512, 0xb6053078ce0fc303, 0x00000572cc5c72b0 },\t \n\t{  76, 512, 0x4a7aad7bf3890923, 0x0000058e987bc8e9 },\t \n\t{  77, 512, 0xe165613fd75b5a53, 0x000005c20473a211 },\t \n\t{  78, 512, 0x3ff154ac878163a6, 0x000005d659194bf3 },\t \n\t{  79, 512, 0x24b93ade0aa8a532, 0x0000060a201c4f8e },\t \n\t{  80, 512, 0xc18e2d14cd9bb554, 0x0000062c55cfe48c },\t \n\t{  81, 512, 0x98cc78302feb58b6, 0x0000066656a07194 },\t \n\t{  82, 512, 0xc6c5fd5a2abc0543, 0x0000067cff94fbf8 },\t \n\t{  83, 512, 0xa7962f514acbba21, 0x000006ab7b5afa2e },\t \n\t{  84, 512, 0xba02545069ddc6dc, 0x000006d19861364f },\t \n\t{  85, 512, 0x447c73192c35073e, 0x000006fce315ce35 },\t \n\t{  86, 512, 0x48beef9e2d42b0c2, 0x00000720a8e38b6b },\t \n\t{  87, 512, 0x4874cf98541a35e0, 0x00000758382a2273 },\t \n\t{  88, 512, 0xad4cf8333a31127a, 0x00000781e1651b1b },\t \n\t{  89, 512, 0x47ae4859d57888c1, 0x000007b27edbe5bc },\t \n\t{  90, 512, 0x06f7723cfe5d1891, 0x000007dc2a96d8eb },\t \n\t{  91, 512, 0xd4e44218d660576d, 0x0000080ac46f02d5 },\t \n\t{  92, 512, 0x7066702b0d5be1f2, 0x00000832c96d154e },\t \n\t{  93, 512, 0x011209b4f9e11fb9, 0x0000085eefda104c },\t \n\t{  94, 512, 0x47ffba30a0b35708, 0x00000899badc32dc },\t \n\t{  95, 512, 0x1a95a6ac4538aaa8, 0x000008b6b69a42b2 },\t \n\t{  96, 512, 0xbda2b239bb2008eb, 0x000008f22d2de38a },\t \n\t{  97, 512, 0x7ffa0bea90355c6c, 0x0000092e5b23b816 },\t \n\t{  98, 512, 0x1d56ba34be426795, 0x0000094f482e5d1b },\t \n\t{  99, 512, 0x0aa89d45c502e93d, 0x00000977d94a98ce },\t \n\t{ 100, 512, 0x54369449f6857774, 0x000009c06c9b34cc },\t \n\t{ 101, 512, 0xf7d4dd8445b46765, 0x000009e5dc542259 },\t \n\t{ 102, 512, 0xfa8866312f169469, 0x00000a16b54eae93 },\t \n\t{ 103, 512, 0xd8a5aea08aef3ff9, 0x00000a381d2cbfe7 },\t \n\t{ 104, 512, 0x66bcd2c3d5f9ef0e, 0x00000a8191817be7 },\t \n\t{ 105, 512, 0x3fb13a47a012ec81, 0x00000ab562b9a254 },\t \n\t{ 106, 512, 0x43100f01c9e5e3ca, 0x00000aeee84c185f },\t \n\t{ 107, 512, 0xca09c50ccee2d054, 0x00000b1c359c047d },\t \n\t{ 108, 512, 0xd7176732ac503f9b, 0x00000b578bc52a73 },\t \n\t{ 109, 512, 0xed206e51f8d9422d, 0x00000b8083e0d960 },\t \n\t{ 110, 512, 0x17ead5dc6ba0dcd6, 0x00000bcfb1a32ca8 },\t \n\t{ 111, 512, 0x5f1dc21e38a969eb, 0x00000c0171becdd6 },\t \n\t{ 112, 512, 0xddaa973de33ec528, 0x00000c3edaba4b95 },\t \n\t{ 113, 512, 0x2a5eccd7735a3630, 0x00000c630664e7df },\t \n\t{ 114, 512, 0xafcccee5c0b71446, 0x00000cb65392f6e4 },\t \n\t{ 115, 512, 0x8fa30c5e7b147e27, 0x00000cd4db391e55 },\t \n\t{ 116, 512, 0x5afe0711fdfafd82, 0x00000d08cb4ec35d },\t \n\t{ 117, 512, 0x533a6090238afd4c, 0x00000d336f115d1b },\t \n\t{ 118, 512, 0x90cf11b595e39a84, 0x00000d8e041c2048 },\t \n\t{ 119, 512, 0x0d61a3b809444009, 0x00000dcb798afe35 },\t \n\t{ 120, 512, 0x7f34da0f54b0d114, 0x00000df3922664e1 },\t \n\t{ 121, 512, 0xa52258d5b72f6551, 0x00000e4d37a9872d },\t \n\t{ 122, 512, 0xc1de54d7672878db, 0x00000e6583a94cf6 },\t \n\t{ 123, 512, 0x1d03354316a414ab, 0x00000ebffc50308d },\t \n\t{ 124, 512, 0xcebdcc377665412c, 0x00000edee1997cea },\t \n\t{ 125, 512, 0x4ddd4c04b1a12344, 0x00000f21d64b373f },\t \n\t{ 126, 512, 0x64fc8f94e3973658, 0x00000f8f87a8896b },\t \n\t{ 127, 512, 0x68765f78034a334e, 0x00000fb8fe62197e },\t \n\t{ 128, 512, 0xaf36b871a303e816, 0x00000fec6f3afb1e },\t \n\t{ 129, 512, 0x2a4cbf73866c3a28, 0x00001027febfe4e5 },\t \n\t{ 130, 512, 0x9cb128aacdcd3b2f, 0x0000106aa8ac569d },\t \n\t{ 131, 512, 0x5511d41c55869124, 0x000010bbd755ddf1 },\t \n\t{ 132, 512, 0x42f92461937f284a, 0x000010fb8bceb3b5 },\t \n\t{ 133, 512, 0xe2d89a1cf6f1f287, 0x0000114cf5331e34 },\t \n\t{ 134, 512, 0xdc631a038956200e, 0x0000116428d2adc5 },\t \n\t{ 135, 512, 0xb2e5ac222cd236be, 0x000011ca88e4d4d2 },\t \n\t{ 136, 512, 0xbc7d8236655d88e7, 0x000011e39cb94e66 },\t \n\t{ 137, 512, 0x073e02d88d2d8e75, 0x0000123136c7933c },\t \n\t{ 138, 512, 0x3ddb9c3873166be0, 0x00001280e4ec6d52 },\t \n\t{ 139, 512, 0x7d3b1a845420e1b5, 0x000012c2e7cd6a44 },\t \n\t{ 140, 512, 0x60102308aa7b2a6c, 0x000012fc490e6c7d },\t \n\t{ 141, 512, 0xdb22bb2f9eb894aa, 0x00001343f5a85a1a },\t \n\t{ 142, 512, 0xd853f879a13b1606, 0x000013bb7d5f9048 },\t \n\t{ 143, 512, 0x001620a03f804b1d, 0x000013e74cc794fd },\t \n\t{ 144, 512, 0xfdb52dda76fbf667, 0x00001442d2f22480 },\t \n\t{ 145, 512, 0xa9160110f66e24ff, 0x0000144b899f9dbb },\t \n\t{ 146, 512, 0x77306a30379ae03b, 0x000014cb98eb1f81 },\t \n\t{ 147, 512, 0x14f5985d2752319d, 0x000014feab821fc9 },\t \n\t{ 148, 512, 0xa4b8ff11de7863f8, 0x0000154a0e60b9c9 },\t \n\t{ 149, 512, 0x44b345426455c1b3, 0x000015999c3c569c },\t \n\t{ 150, 512, 0x272677826049b46c, 0x000015c9697f4b92 },\t \n\t{ 151, 512, 0x2f9216e2cd74fe40, 0x0000162b1f7bbd39 },\t \n\t{ 152, 512, 0x706ae3e763ad8771, 0x00001661371c55e1 },\t \n\t{ 153, 512, 0xf7fd345307c2480e, 0x000016e251f28b6a },\t \n\t{ 154, 512, 0x6e94e3d26b3139eb, 0x000016f2429bb8c6 },\t \n\t{ 155, 512, 0x5458bbfbb781fcba, 0x0000173efdeca1b9 },\t \n\t{ 156, 512, 0xa80e2afeccd93b33, 0x000017bfdcb78adc },\t \n\t{ 157, 512, 0x1e4ccbb22796cf9d, 0x00001826fdcc39c9 },\t \n\t{ 158, 512, 0x8fba4b676aaa3663, 0x00001841a1379480 },\t \n\t{ 159, 512, 0xf82b843814b315fa, 0x000018886e19b8a3 },\t \n\t{ 160, 512, 0x7f21e920ecf753a3, 0x0000191812ca0ea7 },\t \n\t{ 161, 512, 0x48bb8ea2c4caa620, 0x0000192f310faccf },\t \n\t{ 162, 512, 0x5cdb652b4952c91b, 0x0000199e1d7437c7 },\t \n\t{ 163, 512, 0x6ac1ba6f78c06cd4, 0x000019cd11f82c70 },\t \n\t{ 164, 512, 0x9faf5f9ca2669a56, 0x00001a18d5431f6a },\t \n\t{ 165, 512, 0xaa57e9383eb01194, 0x00001a9e7d253d85 },\t \n\t{ 166, 512, 0x896967bf495c34d2, 0x00001afb8319b9fc },\t \n\t{ 167, 512, 0xdfad5f05de225f1b, 0x00001b3a59c3093b },\t \n\t{ 168, 512, 0xfd299a99f9f2abdd, 0x00001bb6f1a10799 },\t \n\t{ 169, 512, 0xdda239e798fe9fd4, 0x00001bfae0c9692d },\t \n\t{ 170, 512, 0x5fca670414a32c3e, 0x00001c22129dbcff },\t \n\t{ 171, 512, 0x1bb8934314b087de, 0x00001c955db36cd0 },\t \n\t{ 172, 512, 0xd96394b4b082200d, 0x00001cfc8619b7e6 },\t \n\t{ 173, 512, 0xb612a7735b1c8cbc, 0x00001d303acdd585 },\t \n\t{ 174, 512, 0x28e7430fe5875fe1, 0x00001d7ed5b3697d },\t \n\t{ 175, 512, 0x5038e89efdd981b9, 0x00001dc40ec35c59 },\t \n\t{ 176, 512, 0x075fd78f1d14db7c, 0x00001e31c83b4a2b },\t \n\t{ 177, 512, 0xc50fafdb5021be15, 0x00001e7cdac82fbc },\t \n\t{ 178, 512, 0xe6dc7572ce7b91c7, 0x00001edd8bb454fc },\t \n\t{ 179, 512, 0x21f7843e7beda537, 0x00001f3a8e019d6c },\t \n\t{ 180, 512, 0xc83385e20b43ec82, 0x00001f70735ec137 },\t \n\t{ 181, 512, 0xca818217dddb21fd, 0x0000201ca44c5a3c },\t \n\t{ 182, 512, 0xe6035defea48f933, 0x00002038e3346658 },\t \n\t{ 183, 512, 0x47262a4f953dac5a, 0x000020c2e554314e },\t \n\t{ 184, 512, 0xe24c7246260873ea, 0x000021197e618d64 },\t \n\t{ 185, 512, 0xeef6b57c9b58e9e1, 0x0000217ea48ecddc },\t \n\t{ 186, 512, 0x2becd3346e386142, 0x000021c496d4a5f9 },\t \n\t{ 187, 512, 0x63c6207bdf3b40a3, 0x0000220e0f2eec0c },\t \n\t{ 188, 512, 0x3056ce8989767d4b, 0x0000228eb76cd137 },\t \n\t{ 189, 512, 0x91af61c307cee780, 0x000022e17e2ea501 },\t \n\t{ 190, 512, 0xda359da225f6d54f, 0x00002358a2debc19 },\t \n\t{ 191, 512, 0x0a5f7a2a55607ba0, 0x0000238a79dac18c },\t \n\t{ 192, 512, 0x27bb75bf5224638a, 0x00002403a58e2351 },\t \n\t{ 193, 512, 0x1ebfdb94630f5d0f, 0x00002492a10cb339 },\t \n\t{ 194, 512, 0x6eae5e51d9c5f6fb, 0x000024ce4bf98715 },\t \n\t{ 195, 512, 0x08d903b4daedc2e0, 0x0000250d1e15886c },\t \n\t{ 196, 512, 0xc722a2f7fa7cd686, 0x0000258a99ed0c9e },\t \n\t{ 197, 512, 0x8f71faf0e54e361d, 0x000025dee11976f5 },\t \n\t{ 198, 512, 0x87f64695c91a54e7, 0x0000264e00a43da0 },\t \n\t{ 199, 512, 0xc719cbac2c336b92, 0x000026d327277ac1 },\t \n\t{ 200, 512, 0xe7e647afaf771ade, 0x000027523a5c44bf },\t \n\t{ 201, 512, 0x12d4b5c38ce8c946, 0x0000273898432545 },\t \n\t{ 202, 512, 0xf2e0cd4067bdc94a, 0x000027e47bb2c935 },\t \n\t{ 203, 512, 0x21b79f14d6d947d3, 0x0000281e64977f0d },\t \n\t{ 204, 512, 0x515093f952f18cd6, 0x0000289691a473fd },\t \n\t{ 205, 512, 0xd47b160a1b1022c8, 0x00002903e8b52411 },\t \n\t{ 206, 512, 0xc02fc96684715a16, 0x0000297515608601 },\t \n\t{ 207, 512, 0xef51e68efba72ed0, 0x000029ef73604804 },\t \n\t{ 208, 512, 0x9e3be6e5448b4f33, 0x00002a2846ed074b },\t \n\t{ 209, 512, 0x81d446c6d5fec063, 0x00002a92ca693455 },\t \n\t{ 210, 512, 0xff215de8224e57d5, 0x00002b2271fe3729 },\t \n\t{ 211, 512, 0xe2524d9ba8f69796, 0x00002b64b99c3ba2 },\t \n\t{ 212, 512, 0xf6b28e26097b7e4b, 0x00002bd768b6e068 },\t \n\t{ 213, 512, 0x893a487f30ce1644, 0x00002c67f722b4b2 },\t \n\t{ 214, 512, 0x386566c3fc9871df, 0x00002cc1cf8b4037 },\t \n\t{ 215, 512, 0x1e0ed78edf1f558a, 0x00002d3948d36c7f },\t \n\t{ 216, 512, 0xe3bc20c31e61f113, 0x00002d6d6b12e025 },\t \n\t{ 217, 512, 0xd6c3ad2e23021882, 0x00002deff7572241 },\t \n\t{ 218, 512, 0xb4a9f95cf0f69c5a, 0x00002e67d537aa36 },\t \n\t{ 219, 512, 0x6e98ed6f6c38e82f, 0x00002e9720626789 },\t \n\t{ 220, 512, 0x2e01edba33fddac7, 0x00002f407c6b0198 },\t \n\t{ 221, 512, 0x559d02e1f5f57ccc, 0x00002fb6a5ab4f24 },\t \n\t{ 222, 512, 0xac18f5a916adcd8e, 0x0000304ae1c5c57e },\t \n\t{ 223, 512, 0x15789fbaddb86f4b, 0x0000306f6e019c78 },\t \n\t{ 224, 512, 0xf4a9c36d5bc4c408, 0x000030da40434213 },\t \n\t{ 225, 512, 0xf640f90fd2727f44, 0x00003189ed37b90c },\t \n\t{ 226, 512, 0xb5313d390d61884a, 0x000031e152616b37 },\t \n\t{ 227, 512, 0x4bae6b3ce9160939, 0x0000321f40aeac42 },\t \n\t{ 228, 512, 0x838c34480f1a66a1, 0x000032f389c0f78e },\t \n\t{ 229, 512, 0xb1c4a52c8e3d6060, 0x0000330062a40284 },\t \n\t{ 230, 512, 0xe0f1110c6d0ed822, 0x0000338be435644f },\t \n\t{ 231, 512, 0x9f1a8ccdcea68d4b, 0x000034045a4e97e1 },\t \n\t{ 232, 512, 0x3261ed62223f3099, 0x000034702cfc401c },\t \n\t{ 233, 512, 0xf2191e2311022d65, 0x00003509dd19c9fc },\t \n\t{ 234, 512, 0xf102a395c2033abc, 0x000035654dc96fae },\t \n\t{ 235, 512, 0x11fe378f027906b6, 0x000035b5193b0264 },\t \n\t{ 236, 512, 0xf777f2c026b337aa, 0x000036704f5d9297 },\t \n\t{ 237, 512, 0x1b04e9c2ee143f32, 0x000036dfbb7af218 },\t \n\t{ 238, 512, 0x2fcec95266f9352c, 0x00003785c8df24a9 },\t \n\t{ 239, 512, 0xfe2b0e47e427dd85, 0x000037cbdf5da729 },\t \n\t{ 240, 512, 0x72b49bf2225f6c6d, 0x0000382227c15855 },\t \n\t{ 241, 512, 0x50486b43df7df9c7, 0x0000389b88be6453 },\t \n\t{ 242, 512, 0x5192a3e53181c8ab, 0x000038ddf3d67263 },\t \n\t{ 243, 512, 0xe9f5d8365296fd5e, 0x0000399f1c6c9e9c },\t \n\t{ 244, 512, 0xc740263f0301efa8, 0x00003a147146512d },\t \n\t{ 245, 512, 0x23cd0f2b5671e67d, 0x00003ab10bcc0d9d },\t \n\t{ 246, 512, 0x002ccc7e5cd41390, 0x00003ad6cd14a6c0 },\t \n\t{ 247, 512, 0x9aafb3c02544b31b, 0x00003b8cb8779fb0 },\t \n\t{ 248, 512, 0x72ba07a78b121999, 0x00003c24142a5a3f },\t \n\t{ 249, 512, 0x3d784aa58edfc7b4, 0x00003cd084817d99 },\t \n\t{ 250, 512, 0xaab750424d8004af, 0x00003d506a8e098e },\t \n\t{ 251, 512, 0x84403fcf8e6b5ca2, 0x00003d4c54c2aec4 },\t \n\t{ 252, 512, 0x71eb7455ec98e207, 0x00003e655715cf2c },\t \n\t{ 253, 512, 0xd752b4f19301595b, 0x00003ecd7b2ca5ac },\t \n\t{ 254, 512, 0xc4674129750499de, 0x00003e99e86d3e95 },\t \n\t{ 255, 512, 0x9772baff5cd12ef5, 0x00003f895c019841 },\t \n};\n\n \nstatic int\nverify_perms(uint8_t *perms, uint64_t children, uint64_t nperms,\n    uint64_t checksum)\n{\n\tint countssz = sizeof (uint16_t) * children;\n\tuint16_t *counts = kmem_zalloc(countssz, KM_SLEEP);\n\n\tfor (int i = 0; i < nperms; i++) {\n\t\tfor (int j = 0; j < children; j++) {\n\t\t\tuint8_t val = perms[(i * children) + j];\n\n\t\t\tif (val >= children || counts[val] != i) {\n\t\t\t\tkmem_free(counts, countssz);\n\t\t\t\treturn (EINVAL);\n\t\t\t}\n\n\t\t\tcounts[val]++;\n\t\t}\n\t}\n\n\tif (checksum != 0) {\n\t\tint permssz = sizeof (uint8_t) * children * nperms;\n\t\tzio_cksum_t cksum;\n\n\t\tfletcher_4_native_varsize(perms, permssz, &cksum);\n\n\t\tif (checksum != cksum.zc_word[0]) {\n\t\t\tkmem_free(counts, countssz);\n\t\t\treturn (ECKSUM);\n\t\t}\n\t}\n\n\tkmem_free(counts, countssz);\n\n\treturn (0);\n}\n\n \nint\nvdev_draid_generate_perms(const draid_map_t *map, uint8_t **permsp)\n{\n\tVERIFY3U(map->dm_children, >=, VDEV_DRAID_MIN_CHILDREN);\n\tVERIFY3U(map->dm_children, <=, VDEV_DRAID_MAX_CHILDREN);\n\tVERIFY3U(map->dm_seed, !=, 0);\n\tVERIFY3U(map->dm_nperms, !=, 0);\n\tVERIFY3P(map->dm_perms, ==, NULL);\n\n#ifdef _KERNEL\n\t \n\tVERIFY3U(map->dm_checksum, !=, 0);\n#endif\n\tuint64_t children = map->dm_children;\n\tuint64_t nperms = map->dm_nperms;\n\tint rowsz = sizeof (uint8_t) * children;\n\tint permssz = rowsz * nperms;\n\tuint8_t *perms;\n\n\t \n\tperms = vmem_alloc(permssz, KM_SLEEP);\n\n\t \n\tuint8_t *initial_row = kmem_alloc(rowsz, KM_SLEEP);\n\tfor (int i = 0; i < children; i++)\n\t\tinitial_row[i] = i;\n\n\tuint64_t draid_seed[2] = { VDEV_DRAID_SEED, map->dm_seed };\n\tuint8_t *current_row, *previous_row = initial_row;\n\n\t \n\tfor (int i = 0; i < nperms; i++) {\n\t\tcurrent_row = &perms[i * children];\n\t\tmemcpy(current_row, previous_row, rowsz);\n\n\t\tfor (int j = children - 1; j > 0; j--) {\n\t\t\tuint64_t k = vdev_draid_rand(draid_seed) % (j + 1);\n\t\t\tuint8_t val = current_row[j];\n\t\t\tcurrent_row[j] = current_row[k];\n\t\t\tcurrent_row[k] = val;\n\t\t}\n\n\t\tprevious_row = current_row;\n\t}\n\n\tkmem_free(initial_row, rowsz);\n\n\tint error = verify_perms(perms, children, nperms, map->dm_checksum);\n\tif (error) {\n\t\tvmem_free(perms, permssz);\n\t\treturn (error);\n\t}\n\n\t*permsp = perms;\n\n\treturn (0);\n}\n\n \nint\nvdev_draid_lookup_map(uint64_t children, const draid_map_t **mapp)\n{\n\tfor (int i = 0; i < VDEV_DRAID_MAX_MAPS; i++) {\n\t\tif (draid_maps[i].dm_children == children) {\n\t\t\t*mapp = &draid_maps[i];\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (ENOENT);\n}\n\n \nstatic void\nvdev_draid_get_perm(vdev_draid_config_t *vdc, uint64_t pindex,\n    uint8_t **base, uint64_t *iter)\n{\n\tuint64_t ncols = vdc->vdc_children;\n\tuint64_t poff = pindex % (vdc->vdc_nperms * ncols);\n\n\t*base = vdc->vdc_perms + (poff / ncols) * ncols;\n\t*iter = poff % ncols;\n}\n\nstatic inline uint64_t\nvdev_draid_permute_id(vdev_draid_config_t *vdc,\n    uint8_t *base, uint64_t iter, uint64_t index)\n{\n\treturn ((base[index] + iter) % vdc->vdc_children);\n}\n\n \nstatic uint64_t\nvdev_draid_asize(vdev_t *vd, uint64_t psize)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\tuint64_t ashift = vd->vdev_ashift;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\tuint64_t rows = ((psize - 1) / (vdc->vdc_ndata << ashift)) + 1;\n\tuint64_t asize = (rows * vdc->vdc_groupwidth) << ashift;\n\n\tASSERT3U(asize, !=, 0);\n\tASSERT3U(asize % (vdc->vdc_groupwidth), ==, 0);\n\n\treturn (asize);\n}\n\n \nuint64_t\nvdev_draid_asize_to_psize(vdev_t *vd, uint64_t asize)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT0(asize % vdc->vdc_groupwidth);\n\n\treturn ((asize / vdc->vdc_groupwidth) * vdc->vdc_ndata);\n}\n\n \nstatic uint64_t\nvdev_draid_offset_to_group(vdev_t *vd, uint64_t offset)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\treturn (offset / vdc->vdc_groupsz);\n}\n\n \nstatic uint64_t\nvdev_draid_group_to_offset(vdev_t *vd, uint64_t group)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\treturn (group * vdc->vdc_groupsz);\n}\n\n \nstatic void\nvdev_draid_map_alloc_write(zio_t *zio, uint64_t abd_offset, raidz_row_t *rr)\n{\n\tuint64_t skip_size = 1ULL << zio->io_vd->vdev_top->vdev_ashift;\n\tuint64_t parity_size = rr->rr_col[0].rc_size;\n\tuint64_t abd_off = abd_offset;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_WRITE);\n\tASSERT3U(parity_size, ==, abd_get_size(rr->rr_col[0].rc_abd));\n\n\tfor (uint64_t c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_size == 0) {\n\t\t\t \n\t\t\tASSERT3U(skip_size, ==, parity_size);\n\t\t\trc->rc_abd = abd_get_zeros(skip_size);\n\t\t} else if (rc->rc_size == parity_size) {\n\t\t\t \n\t\t\trc->rc_abd = abd_get_offset_struct(&rc->rc_abdstruct,\n\t\t\t    zio->io_abd, abd_off, rc->rc_size);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3U(rc->rc_size + skip_size, ==, parity_size);\n\t\t\trc->rc_abd = abd_alloc_gang();\n\t\t\tabd_gang_add(rc->rc_abd, abd_get_offset_size(\n\t\t\t    zio->io_abd, abd_off, rc->rc_size), B_TRUE);\n\t\t\tabd_gang_add(rc->rc_abd, abd_get_zeros(skip_size),\n\t\t\t    B_TRUE);\n\t\t}\n\n\t\tASSERT3U(abd_get_size(rc->rc_abd), ==, parity_size);\n\n\t\tabd_off += rc->rc_size;\n\t\trc->rc_size = parity_size;\n\t}\n\n\tIMPLY(abd_offset != 0, abd_off == zio->io_size);\n}\n\n \nstatic void\nvdev_draid_map_alloc_scrub(zio_t *zio, uint64_t abd_offset, raidz_row_t *rr)\n{\n\tuint64_t skip_size = 1ULL << zio->io_vd->vdev_top->vdev_ashift;\n\tuint64_t parity_size = rr->rr_col[0].rc_size;\n\tuint64_t abd_off = abd_offset;\n\tuint64_t skip_off = 0;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\tASSERT3P(rr->rr_abd_empty, ==, NULL);\n\n\tif (rr->rr_nempty > 0) {\n\t\trr->rr_abd_empty = abd_alloc_linear(rr->rr_nempty * skip_size,\n\t\t    B_FALSE);\n\t}\n\n\tfor (uint64_t c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_size == 0) {\n\t\t\t \n\t\t\tASSERT3U(skip_size, ==, parity_size);\n\t\t\tASSERT3U(rr->rr_nempty, !=, 0);\n\t\t\trc->rc_abd = abd_get_offset_size(rr->rr_abd_empty,\n\t\t\t    skip_off, skip_size);\n\t\t\tskip_off += skip_size;\n\t\t} else if (rc->rc_size == parity_size) {\n\t\t\t \n\t\t\trc->rc_abd = abd_get_offset_struct(&rc->rc_abdstruct,\n\t\t\t    zio->io_abd, abd_off, rc->rc_size);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3U(rc->rc_size + skip_size, ==, parity_size);\n\t\t\tASSERT3U(rr->rr_nempty, !=, 0);\n\t\t\trc->rc_abd = abd_alloc_gang();\n\t\t\tabd_gang_add(rc->rc_abd, abd_get_offset_size(\n\t\t\t    zio->io_abd, abd_off, rc->rc_size), B_TRUE);\n\t\t\tabd_gang_add(rc->rc_abd, abd_get_offset_size(\n\t\t\t    rr->rr_abd_empty, skip_off, skip_size), B_TRUE);\n\t\t\tskip_off += skip_size;\n\t\t}\n\n\t\tuint64_t abd_size = abd_get_size(rc->rc_abd);\n\t\tASSERT3U(abd_size, ==, abd_get_size(rr->rr_col[0].rc_abd));\n\n\t\t \n\t\tabd_off += rc->rc_size;\n\t\trc->rc_size = abd_size;\n\t}\n\n\tIMPLY(abd_offset != 0, abd_off == zio->io_size);\n\tASSERT3U(skip_off, ==, rr->rr_nempty * skip_size);\n}\n\n \nstatic void\nvdev_draid_map_alloc_read(zio_t *zio, uint64_t abd_offset, raidz_row_t *rr)\n{\n\tuint64_t abd_off = abd_offset;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\n\tfor (uint64_t c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_size > 0) {\n\t\t\trc->rc_abd = abd_get_offset_struct(&rc->rc_abdstruct,\n\t\t\t    zio->io_abd, abd_off, rc->rc_size);\n\t\t\tabd_off += rc->rc_size;\n\t\t}\n\t}\n\n\tIMPLY(abd_offset != 0, abd_off == zio->io_size);\n}\n\n \nvoid\nvdev_draid_map_alloc_empty(zio_t *zio, raidz_row_t *rr)\n{\n\tuint64_t skip_size = 1ULL << zio->io_vd->vdev_top->vdev_ashift;\n\tuint64_t parity_size = rr->rr_col[0].rc_size;\n\tuint64_t skip_off = 0;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\tASSERT3P(rr->rr_abd_empty, ==, NULL);\n\n\tif (rr->rr_nempty > 0) {\n\t\trr->rr_abd_empty = abd_alloc_linear(rr->rr_nempty * skip_size,\n\t\t    B_FALSE);\n\t}\n\n\tfor (uint64_t c = rr->rr_firstdatacol; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tif (rc->rc_size == 0) {\n\t\t\t \n\t\t\tASSERT3U(skip_size, ==, parity_size);\n\t\t\tASSERT3U(rr->rr_nempty, !=, 0);\n\t\t\tASSERT3P(rc->rc_abd, ==, NULL);\n\t\t\trc->rc_abd = abd_get_offset_size(rr->rr_abd_empty,\n\t\t\t    skip_off, skip_size);\n\t\t\tskip_off += skip_size;\n\t\t} else if (rc->rc_size == parity_size) {\n\t\t\t \n\t\t\tASSERT3P(rc->rc_abd, !=, NULL);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3U(rc->rc_size + skip_size, ==, parity_size);\n\t\t\tASSERT3U(rr->rr_nempty, !=, 0);\n\t\t\tASSERT3P(rc->rc_abd, !=, NULL);\n\t\t\tASSERT(!abd_is_gang(rc->rc_abd));\n\t\t\tabd_t *read_abd = rc->rc_abd;\n\t\t\trc->rc_abd = abd_alloc_gang();\n\t\t\tabd_gang_add(rc->rc_abd, read_abd, B_TRUE);\n\t\t\tabd_gang_add(rc->rc_abd, abd_get_offset_size(\n\t\t\t    rr->rr_abd_empty, skip_off, skip_size), B_TRUE);\n\t\t\tskip_off += skip_size;\n\t\t\trc->rc_tried = 0;\n\t\t}\n\n\t\t \n\t\trc->rc_size = parity_size;\n\t}\n\n\tASSERT3U(skip_off, ==, rr->rr_nempty * skip_size);\n}\n\n \nint\nvdev_draid_map_verify_empty(zio_t *zio, raidz_row_t *rr)\n{\n\tuint64_t skip_size = 1ULL << zio->io_vd->vdev_top->vdev_ashift;\n\tuint64_t parity_size = rr->rr_col[0].rc_size;\n\tuint64_t skip_off = parity_size - skip_size;\n\tuint64_t empty_off = 0;\n\tint ret = 0;\n\n\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\tASSERT3P(rr->rr_abd_empty, !=, NULL);\n\tASSERT3U(rr->rr_bigcols, >, 0);\n\n\tvoid *zero_buf = kmem_zalloc(skip_size, KM_SLEEP);\n\n\tfor (int c = rr->rr_bigcols; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\tASSERT3P(rc->rc_abd, !=, NULL);\n\t\tASSERT3U(rc->rc_size, ==, parity_size);\n\n\t\tif (abd_cmp_buf_off(rc->rc_abd, zero_buf, skip_off,\n\t\t    skip_size) != 0) {\n\t\t\tvdev_raidz_checksum_error(zio, rc, rc->rc_abd);\n\t\t\tabd_zero_off(rc->rc_abd, skip_off, skip_size);\n\t\t\trc->rc_error = SET_ERROR(ECKSUM);\n\t\t\tret++;\n\t\t}\n\n\t\tempty_off += skip_size;\n\t}\n\n\tASSERT3U(empty_off, ==, abd_get_size(rr->rr_abd_empty));\n\n\tkmem_free(zero_buf, skip_size);\n\n\treturn (ret);\n}\n\n \nstatic uint64_t\nvdev_draid_logical_to_physical(vdev_t *vd, uint64_t logical_offset,\n    uint64_t *perm, uint64_t *start)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\t \n\tuint64_t ashift = vd->vdev_top->vdev_ashift;\n\tuint64_t b_offset = logical_offset >> ashift;\n\n\t \n\tuint64_t rowheight_sectors = VDEV_DRAID_ROWHEIGHT >> ashift;\n\n\t \n\tuint64_t groupwidth = vdc->vdc_groupwidth;\n\tuint64_t ngroups = vdc->vdc_ngroups;\n\tuint64_t ndisks = vdc->vdc_ndisks;\n\n\t \n\tuint64_t group = logical_offset / vdc->vdc_groupsz;\n\tuint64_t groupstart = (group * groupwidth) % ndisks;\n\tASSERT3U(groupstart + groupwidth, <=, ndisks + groupstart);\n\t*start = groupstart;\n\n\t \n\tb_offset = b_offset % (rowheight_sectors * groupwidth);\n\tASSERT0(b_offset % groupwidth);\n\n\t \n\t*perm = group / ngroups;\n\tuint64_t row = (*perm * ((groupwidth * ngroups) / ndisks)) +\n\t    (((group % ngroups) * groupwidth) / ndisks);\n\n\treturn (((rowheight_sectors * row) +\n\t    (b_offset / groupwidth)) << ashift);\n}\n\nstatic uint64_t\nvdev_draid_map_alloc_row(zio_t *zio, raidz_row_t **rrp, uint64_t io_offset,\n    uint64_t abd_offset, uint64_t abd_size)\n{\n\tvdev_t *vd = zio->io_vd;\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\tuint64_t ashift = vd->vdev_top->vdev_ashift;\n\tuint64_t io_size = abd_size;\n\tuint64_t io_asize = vdev_draid_asize(vd, io_size);\n\tuint64_t group = vdev_draid_offset_to_group(vd, io_offset);\n\tuint64_t start_offset = vdev_draid_group_to_offset(vd, group + 1);\n\n\t \n\tif (io_offset + io_asize > start_offset) {\n\t\tio_size = vdev_draid_asize_to_psize(vd,\n\t\t    start_offset - io_offset);\n\t}\n\n\t \n\tIMPLY(abd_offset == 0 && io_size < zio->io_size,\n\t    (io_asize >> ashift) % vdc->vdc_groupwidth == 0);\n\tIMPLY(abd_offset != 0,\n\t    vdev_draid_group_to_offset(vd, group) == io_offset);\n\n\t \n\tuint64_t groupstart, perm;\n\tuint64_t physical_offset = vdev_draid_logical_to_physical(vd,\n\t    io_offset, &perm, &groupstart);\n\n\t \n\tuint64_t ndisks = vdc->vdc_ndisks;\n\tuint64_t groupwidth = vdc->vdc_groupwidth;\n\tuint64_t wrap = groupwidth;\n\n\tif (groupstart + groupwidth > ndisks)\n\t\twrap = ndisks - groupstart;\n\n\t \n\tconst uint64_t psize = io_size >> ashift;\n\n\t \n\tuint64_t q = psize / vdc->vdc_ndata;\n\n\t \n\tuint64_t r = psize - q * vdc->vdc_ndata;\n\n\t \n\tuint64_t bc = (r == 0 ? 0 : r + vdc->vdc_nparity);\n\tASSERT3U(bc, <, groupwidth);\n\n\t \n\tuint64_t tot = psize + (vdc->vdc_nparity * (q + (r == 0 ? 0 : 1)));\n\n\tASSERT3U(vdc->vdc_nparity, >, 0);\n\n\traidz_row_t *rr;\n\trr = kmem_alloc(offsetof(raidz_row_t, rr_col[groupwidth]), KM_SLEEP);\n\trr->rr_cols = groupwidth;\n\trr->rr_scols = groupwidth;\n\trr->rr_bigcols = bc;\n\trr->rr_missingdata = 0;\n\trr->rr_missingparity = 0;\n\trr->rr_firstdatacol = vdc->vdc_nparity;\n\trr->rr_abd_empty = NULL;\n#ifdef ZFS_DEBUG\n\trr->rr_offset = io_offset;\n\trr->rr_size = io_size;\n#endif\n\t*rrp = rr;\n\n\tuint8_t *base;\n\tuint64_t iter, asize = 0;\n\tvdev_draid_get_perm(vdc, perm, &base, &iter);\n\tfor (uint64_t i = 0; i < groupwidth; i++) {\n\t\traidz_col_t *rc = &rr->rr_col[i];\n\t\tuint64_t c = (groupstart + i) % ndisks;\n\n\t\t \n\t\tif (i == wrap)\n\t\t\tphysical_offset += VDEV_DRAID_ROWHEIGHT;\n\n\t\trc->rc_devidx = vdev_draid_permute_id(vdc, base, iter, c);\n\t\trc->rc_offset = physical_offset;\n\t\trc->rc_abd = NULL;\n\t\trc->rc_orig_data = NULL;\n\t\trc->rc_error = 0;\n\t\trc->rc_tried = 0;\n\t\trc->rc_skipped = 0;\n\t\trc->rc_force_repair = 0;\n\t\trc->rc_allow_repair = 1;\n\t\trc->rc_need_orig_restore = B_FALSE;\n\n\t\tif (q == 0 && i >= bc)\n\t\t\trc->rc_size = 0;\n\t\telse if (i < bc)\n\t\t\trc->rc_size = (q + 1) << ashift;\n\t\telse\n\t\t\trc->rc_size = q << ashift;\n\n\t\tasize += rc->rc_size;\n\t}\n\n\tASSERT3U(asize, ==, tot << ashift);\n\trr->rr_nempty = roundup(tot, groupwidth) - tot;\n\tIMPLY(bc > 0, rr->rr_nempty == groupwidth - bc);\n\n\t \n\tfor (uint64_t c = 0; c < rr->rr_firstdatacol; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\trc->rc_abd = abd_alloc_linear(rc->rc_size, B_FALSE);\n\t}\n\n\t \n\tif (zio->io_type == ZIO_TYPE_WRITE) {\n\t\tvdev_draid_map_alloc_write(zio, abd_offset, rr);\n\t} else if ((rr->rr_nempty > 0) &&\n\t    (zio->io_flags & (ZIO_FLAG_SCRUB | ZIO_FLAG_RESILVER))) {\n\t\tvdev_draid_map_alloc_scrub(zio, abd_offset, rr);\n\t} else {\n\t\tASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);\n\t\tvdev_draid_map_alloc_read(zio, abd_offset, rr);\n\t}\n\n\treturn (io_size);\n}\n\n \nstatic raidz_map_t *\nvdev_draid_map_alloc(zio_t *zio)\n{\n\traidz_row_t *rr[2];\n\tuint64_t abd_offset = 0;\n\tuint64_t abd_size = zio->io_size;\n\tuint64_t io_offset = zio->io_offset;\n\tuint64_t size;\n\tint nrows = 1;\n\n\tsize = vdev_draid_map_alloc_row(zio, &rr[0], io_offset,\n\t    abd_offset, abd_size);\n\tif (size < abd_size) {\n\t\tvdev_t *vd = zio->io_vd;\n\n\t\tio_offset += vdev_draid_asize(vd, size);\n\t\tabd_offset += size;\n\t\tabd_size -= size;\n\t\tnrows++;\n\n\t\tASSERT3U(io_offset, ==, vdev_draid_group_to_offset(\n\t\t    vd, vdev_draid_offset_to_group(vd, io_offset)));\n\t\tASSERT3U(abd_offset, <, zio->io_size);\n\t\tASSERT3U(abd_size, !=, 0);\n\n\t\tsize = vdev_draid_map_alloc_row(zio, &rr[1],\n\t\t    io_offset, abd_offset, abd_size);\n\t\tVERIFY3U(size, ==, abd_size);\n\t}\n\n\traidz_map_t *rm;\n\trm = kmem_zalloc(offsetof(raidz_map_t, rm_row[nrows]), KM_SLEEP);\n\trm->rm_ops = vdev_raidz_math_get_ops();\n\trm->rm_nrows = nrows;\n\trm->rm_row[0] = rr[0];\n\tif (nrows == 2)\n\t\trm->rm_row[1] = rr[1];\n\n\treturn (rm);\n}\n\n \nstatic uint64_t\nvdev_draid_get_astart(vdev_t *vd, const uint64_t start)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\treturn (roundup(start, vdc->vdc_groupwidth << vd->vdev_ashift));\n}\n\n \nstatic uint64_t\nvdev_draid_min_asize(vdev_t *vd)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\treturn (VDEV_DRAID_REFLOW_RESERVE +\n\t    (vd->vdev_min_asize + vdc->vdc_ndisks - 1) / (vdc->vdc_ndisks));\n}\n\n \nstatic uint64_t\nvdev_draid_min_alloc(vdev_t *vd)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\treturn (vdc->vdc_ndata << vd->vdev_ashift);\n}\n\n \nboolean_t\nvdev_draid_missing(vdev_t *vd, uint64_t physical_offset, uint64_t txg,\n    uint64_t size)\n{\n\tif (vd->vdev_ops == &vdev_spare_ops ||\n\t    vd->vdev_ops == &vdev_replacing_ops) {\n\t\t \n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\t\tif (!vdev_readable(cvd))\n\t\t\t\tcontinue;\n\n\t\t\tif (!vdev_draid_missing(cvd, physical_offset,\n\t\t\t    txg, size))\n\t\t\t\treturn (B_FALSE);\n\t\t}\n\n\t\treturn (B_TRUE);\n\t}\n\n\tif (vd->vdev_ops == &vdev_draid_spare_ops) {\n\t\t \n\t\tif (vd->vdev_rebuild_txg != 0)\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vdev_dtl_contains(vd, DTL_MISSING, txg, size))\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tvd = vdev_draid_spare_get_child(vd, physical_offset);\n\t\tif (vd == NULL)\n\t\t\treturn (B_TRUE);\n\n\t\treturn (vdev_draid_missing(vd, physical_offset,\n\t\t    txg, size));\n\t}\n\n\treturn (vdev_dtl_contains(vd, DTL_MISSING, txg, size));\n}\n\n \nstatic boolean_t\nvdev_draid_partial(vdev_t *vd, uint64_t physical_offset, uint64_t txg,\n    uint64_t size)\n{\n\tif (vd->vdev_ops == &vdev_spare_ops ||\n\t    vd->vdev_ops == &vdev_replacing_ops) {\n\t\t \n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\t\tif (!vdev_readable(cvd))\n\t\t\t\tcontinue;\n\n\t\t\tif (vdev_draid_partial(cvd, physical_offset, txg, size))\n\t\t\t\treturn (B_TRUE);\n\t\t}\n\n\t\treturn (B_FALSE);\n\t}\n\n\tif (vd->vdev_ops == &vdev_draid_spare_ops) {\n\t\t \n\t\tif (vd->vdev_rebuild_txg != 0)\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vdev_dtl_contains(vd, DTL_MISSING, txg, size))\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tvd = vdev_draid_spare_get_child(vd, physical_offset);\n\t\tif (vd == NULL)\n\t\t\treturn (B_TRUE);\n\n\t\treturn (vdev_draid_partial(vd, physical_offset, txg, size));\n\t}\n\n\treturn (vdev_dtl_contains(vd, DTL_MISSING, txg, size));\n}\n\n \nboolean_t\nvdev_draid_readable(vdev_t *vd, uint64_t physical_offset)\n{\n\tif (vd->vdev_ops == &vdev_draid_spare_ops) {\n\t\tvd = vdev_draid_spare_get_child(vd, physical_offset);\n\t\tif (vd == NULL)\n\t\t\treturn (B_FALSE);\n\t}\n\n\tif (vd->vdev_ops == &vdev_spare_ops ||\n\t    vd->vdev_ops == &vdev_replacing_ops) {\n\n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\t\tif (!vdev_readable(cvd))\n\t\t\t\tcontinue;\n\n\t\t\tif (vdev_draid_readable(cvd, physical_offset))\n\t\t\t\treturn (B_TRUE);\n\t\t}\n\n\t\treturn (B_FALSE);\n\t}\n\n\treturn (vdev_readable(vd));\n}\n\n \nstatic vdev_t *\nvdev_draid_find_spare(vdev_t *vd)\n{\n\tif (vd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn (vd);\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *svd = vdev_draid_find_spare(vd->vdev_child[c]);\n\t\tif (svd != NULL)\n\t\t\treturn (svd);\n\t}\n\n\treturn (NULL);\n}\n\n \nstatic boolean_t\nvdev_draid_faulted(vdev_t *vd, uint64_t physical_offset)\n{\n\tif (vd->vdev_ops == &vdev_draid_spare_ops) {\n\t\tvd = vdev_draid_spare_get_child(vd, physical_offset);\n\t\tif (vd == NULL)\n\t\t\treturn (B_FALSE);\n\n\t\t \n\t\tvd = vd->vdev_parent;\n\t}\n\n\treturn (vd->vdev_ops == &vdev_replacing_ops ||\n\t    vd->vdev_ops == &vdev_spare_ops);\n}\n\n \nstatic boolean_t\nvdev_draid_group_degraded(vdev_t *vd, uint64_t offset)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\tASSERT3U(vdev_draid_get_astart(vd, offset), ==, offset);\n\n\tuint64_t groupstart, perm;\n\tuint64_t physical_offset = vdev_draid_logical_to_physical(vd,\n\t    offset, &perm, &groupstart);\n\n\tuint8_t *base;\n\tuint64_t iter;\n\tvdev_draid_get_perm(vdc, perm, &base, &iter);\n\n\tfor (uint64_t i = 0; i < vdc->vdc_groupwidth; i++) {\n\t\tuint64_t c = (groupstart + i) % vdc->vdc_ndisks;\n\t\tuint64_t cid = vdev_draid_permute_id(vdc, base, iter, c);\n\t\tvdev_t *cvd = vd->vdev_child[cid];\n\n\t\t \n\t\tif (vdev_draid_faulted(cvd, physical_offset))\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vdev_draid_find_spare(cvd) != NULL)\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic boolean_t\nvdev_draid_group_missing(vdev_t *vd, uint64_t offset, uint64_t txg,\n    uint64_t size)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\tASSERT3U(vdev_draid_get_astart(vd, offset), ==, offset);\n\n\tuint64_t groupstart, perm;\n\tuint64_t physical_offset = vdev_draid_logical_to_physical(vd,\n\t    offset, &perm, &groupstart);\n\n\tuint8_t *base;\n\tuint64_t iter;\n\tvdev_draid_get_perm(vdc, perm, &base, &iter);\n\n\tfor (uint64_t i = 0; i < vdc->vdc_groupwidth; i++) {\n\t\tuint64_t c = (groupstart + i) % vdc->vdc_ndisks;\n\t\tuint64_t cid = vdev_draid_permute_id(vdc, base, iter, c);\n\t\tvdev_t *cvd = vd->vdev_child[cid];\n\n\t\t \n\t\tif (vdev_draid_partial(cvd, physical_offset, txg, size))\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vdev_draid_find_spare(cvd) != NULL)\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic void\nvdev_draid_calculate_asize(vdev_t *vd, uint64_t *asizep, uint64_t *max_asizep,\n    uint64_t *logical_ashiftp, uint64_t *physical_ashiftp)\n{\n\tuint64_t logical_ashift = 0, physical_ashift = 0;\n\tuint64_t asize = 0, max_asize = 0;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (cvd->vdev_ops == &vdev_draid_spare_ops)\n\t\t\tcontinue;\n\n\t\tasize = MIN(asize - 1, cvd->vdev_asize - 1) + 1;\n\t\tmax_asize = MIN(max_asize - 1, cvd->vdev_max_asize - 1) + 1;\n\t\tlogical_ashift = MAX(logical_ashift, cvd->vdev_ashift);\n\t}\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (cvd->vdev_ops == &vdev_draid_spare_ops)\n\t\t\tcontinue;\n\t\tphysical_ashift = vdev_best_ashift(logical_ashift,\n\t\t    physical_ashift, cvd->vdev_physical_ashift);\n\t}\n\n\t*asizep = asize;\n\t*max_asizep = max_asize;\n\t*logical_ashiftp = logical_ashift;\n\t*physical_ashiftp = physical_ashift;\n}\n\n \nstatic boolean_t\nvdev_draid_open_spares(vdev_t *vd)\n{\n\treturn (vd->vdev_ops == &vdev_draid_spare_ops ||\n\t    vd->vdev_ops == &vdev_replacing_ops ||\n\t    vd->vdev_ops == &vdev_spare_ops);\n}\n\n \nstatic boolean_t\nvdev_draid_open_children(vdev_t *vd)\n{\n\treturn (!vdev_draid_open_spares(vd));\n}\n\n \nstatic int\nvdev_draid_open(vdev_t *vd, uint64_t *asize, uint64_t *max_asize,\n    uint64_t *logical_ashift, uint64_t *physical_ashift)\n{\n\tvdev_draid_config_t *vdc =  vd->vdev_tsd;\n\tuint64_t nparity = vdc->vdc_nparity;\n\tint open_errors = 0;\n\n\tif (nparity > VDEV_DRAID_MAXPARITY ||\n\t    vd->vdev_children < nparity + 1) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_BAD_LABEL;\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tvdev_open_children_subset(vd, vdev_draid_open_children);\n\tvdev_open_children_subset(vd, vdev_draid_open_spares);\n\n\t \n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tif (vd->vdev_child[c]->vdev_open_error != 0) {\n\t\t\tif ((++open_errors) > nparity) {\n\t\t\t\tvd->vdev_stat.vs_aux = VDEV_AUX_NO_REPLICAS;\n\t\t\t\treturn (SET_ERROR(ENXIO));\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tuint64_t child_asize, child_max_asize;\n\tvdev_draid_calculate_asize(vd, &child_asize, &child_max_asize,\n\t    logical_ashift, physical_ashift);\n\n\t \n\tif (child_asize < VDEV_DRAID_REFLOW_RESERVE ||\n\t    child_max_asize < VDEV_DRAID_REFLOW_RESERVE) {\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\tchild_asize = ((child_asize - VDEV_DRAID_REFLOW_RESERVE) /\n\t    VDEV_DRAID_ROWHEIGHT) * VDEV_DRAID_ROWHEIGHT;\n\tchild_max_asize = ((child_max_asize - VDEV_DRAID_REFLOW_RESERVE) /\n\t    VDEV_DRAID_ROWHEIGHT) * VDEV_DRAID_ROWHEIGHT;\n\n\t*asize = (((child_asize * vdc->vdc_ndisks) / vdc->vdc_groupsz) *\n\t    vdc->vdc_groupsz);\n\t*max_asize = (((child_max_asize * vdc->vdc_ndisks) / vdc->vdc_groupsz) *\n\t    vdc->vdc_groupsz);\n\n\treturn (0);\n}\n\n \nstatic void\nvdev_draid_close(vdev_t *vd)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tif (vd->vdev_child[c] != NULL)\n\t\t\tvdev_close(vd->vdev_child[c]);\n\t}\n}\n\n \nstatic uint64_t\nvdev_draid_rebuild_asize(vdev_t *vd, uint64_t start, uint64_t asize,\n    uint64_t max_segment)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\tuint64_t ashift = vd->vdev_ashift;\n\tuint64_t ndata = vdc->vdc_ndata;\n\tuint64_t psize = MIN(P2ROUNDUP(max_segment * ndata, 1 << ashift),\n\t    SPA_MAXBLOCKSIZE);\n\n\tASSERT3U(vdev_draid_get_astart(vd, start), ==, start);\n\tASSERT3U(asize % (vdc->vdc_groupwidth << ashift), ==, 0);\n\n\t \n\tpsize = (((psize >> ashift) / ndata) * ndata) << ashift;\n\tuint64_t chunk_size = MIN(asize, vdev_psize_to_asize(vd, psize));\n\n\t \n\tuint64_t group = vdev_draid_offset_to_group(vd, start);\n\tuint64_t left = vdev_draid_group_to_offset(vd, group + 1) - start;\n\tchunk_size = MIN(chunk_size, left);\n\n\tASSERT3U(chunk_size % (vdc->vdc_groupwidth << ashift), ==, 0);\n\tASSERT3U(vdev_draid_offset_to_group(vd, start), ==,\n\t    vdev_draid_offset_to_group(vd, start + chunk_size - 1));\n\n\treturn (chunk_size);\n}\n\n \nstatic void\nvdev_draid_metaslab_init(vdev_t *vd, uint64_t *ms_start, uint64_t *ms_size)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\n\tuint64_t sz = vdc->vdc_groupwidth << vd->vdev_ashift;\n\tuint64_t astart = vdev_draid_get_astart(vd, *ms_start);\n\tuint64_t asize = ((*ms_size - (astart - *ms_start)) / sz) * sz;\n\n\t*ms_start = astart;\n\t*ms_size = asize;\n\n\tASSERT0(*ms_start % sz);\n\tASSERT0(*ms_size % sz);\n}\n\n \nint\nvdev_draid_spare_create(nvlist_t *nvroot, vdev_t *vd, uint64_t *ndraidp,\n    uint64_t next_vdev_id)\n{\n\tuint64_t draid_nspares = 0;\n\tuint64_t ndraid = 0;\n\tint error;\n\n\tfor (uint64_t i = 0; i < vd->vdev_children; i++) {\n\t\tvdev_t *cvd = vd->vdev_child[i];\n\n\t\tif (cvd->vdev_ops == &vdev_draid_ops) {\n\t\t\tvdev_draid_config_t *vdc = cvd->vdev_tsd;\n\t\t\tdraid_nspares += vdc->vdc_nspares;\n\t\t\tndraid++;\n\t\t}\n\t}\n\n\tif (draid_nspares == 0) {\n\t\t*ndraidp = ndraid;\n\t\treturn (0);\n\t}\n\n\tnvlist_t **old_spares, **new_spares;\n\tuint_t old_nspares;\n\terror = nvlist_lookup_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t    &old_spares, &old_nspares);\n\tif (error)\n\t\told_nspares = 0;\n\n\t \n\tnew_spares = kmem_alloc(sizeof (nvlist_t *) *\n\t    (draid_nspares + old_nspares), KM_SLEEP);\n\tfor (uint_t i = 0; i < old_nspares; i++)\n\t\tnew_spares[i] = fnvlist_dup(old_spares[i]);\n\n\t \n\tuint64_t n = old_nspares;\n\tfor (uint64_t vdev_id = 0; vdev_id < vd->vdev_children; vdev_id++) {\n\t\tvdev_t *cvd = vd->vdev_child[vdev_id];\n\t\tchar path[64];\n\n\t\tif (cvd->vdev_ops != &vdev_draid_ops)\n\t\t\tcontinue;\n\n\t\tvdev_draid_config_t *vdc = cvd->vdev_tsd;\n\t\tuint64_t nspares = vdc->vdc_nspares;\n\t\tuint64_t nparity = vdc->vdc_nparity;\n\n\t\tfor (uint64_t spare_id = 0; spare_id < nspares; spare_id++) {\n\t\t\tmemset(path, 0, sizeof (path));\n\t\t\t(void) snprintf(path, sizeof (path) - 1,\n\t\t\t    \"%s%llu-%llu-%llu\", VDEV_TYPE_DRAID,\n\t\t\t    (u_longlong_t)nparity,\n\t\t\t    (u_longlong_t)next_vdev_id + vdev_id,\n\t\t\t    (u_longlong_t)spare_id);\n\n\t\t\tnvlist_t *spare = fnvlist_alloc();\n\t\t\tfnvlist_add_string(spare, ZPOOL_CONFIG_PATH, path);\n\t\t\tfnvlist_add_string(spare, ZPOOL_CONFIG_TYPE,\n\t\t\t    VDEV_TYPE_DRAID_SPARE);\n\t\t\tfnvlist_add_uint64(spare, ZPOOL_CONFIG_TOP_GUID,\n\t\t\t    cvd->vdev_guid);\n\t\t\tfnvlist_add_uint64(spare, ZPOOL_CONFIG_SPARE_ID,\n\t\t\t    spare_id);\n\t\t\tfnvlist_add_uint64(spare, ZPOOL_CONFIG_IS_LOG, 0);\n\t\t\tfnvlist_add_uint64(spare, ZPOOL_CONFIG_IS_SPARE, 1);\n\t\t\tfnvlist_add_uint64(spare, ZPOOL_CONFIG_WHOLE_DISK, 1);\n\t\t\tfnvlist_add_uint64(spare, ZPOOL_CONFIG_ASHIFT,\n\t\t\t    cvd->vdev_ashift);\n\n\t\t\tnew_spares[n] = spare;\n\t\t\tn++;\n\t\t}\n\t}\n\n\tif (n > 0) {\n\t\t(void) nvlist_remove_all(nvroot, ZPOOL_CONFIG_SPARES);\n\t\tfnvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_SPARES,\n\t\t    (const nvlist_t **)new_spares, n);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tnvlist_free(new_spares[i]);\n\n\tkmem_free(new_spares, sizeof (*new_spares) * n);\n\t*ndraidp = ndraid;\n\n\treturn (0);\n}\n\n \nstatic boolean_t\nvdev_draid_need_resilver(vdev_t *vd, const dva_t *dva, size_t psize,\n    uint64_t phys_birth)\n{\n\tuint64_t offset = DVA_GET_OFFSET(dva);\n\tuint64_t asize = vdev_draid_asize(vd, psize);\n\n\tif (phys_birth == TXG_UNKNOWN) {\n\t\t \n\t\tASSERT3U(vdev_draid_offset_to_group(vd, offset), ==,\n\t\t    vdev_draid_offset_to_group(vd, offset + asize - 1));\n\n\t\treturn (vdev_draid_group_degraded(vd, offset));\n\t} else {\n\t\t \n\t\tif (!vdev_dtl_contains(vd, DTL_PARTIAL, phys_birth, 1))\n\t\t\treturn (B_FALSE);\n\n\t\tif (vdev_draid_group_missing(vd, offset, phys_birth, 1))\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vdev_draid_offset_to_group(vd, offset) !=\n\t\t    vdev_draid_offset_to_group(vd, offset + asize - 1)) {\n\t\t\tif (vdev_draid_group_missing(vd,\n\t\t\t    offset + asize, phys_birth, 1))\n\t\t\t\treturn (B_TRUE);\n\t\t}\n\n\t\treturn (B_FALSE);\n\t}\n}\n\nstatic boolean_t\nvdev_draid_rebuilding(vdev_t *vd)\n{\n\tif (vd->vdev_ops->vdev_op_leaf && vd->vdev_rebuild_txg)\n\t\treturn (B_TRUE);\n\n\tfor (int i = 0; i < vd->vdev_children; i++) {\n\t\tif (vdev_draid_rebuilding(vd->vdev_child[i])) {\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\treturn (B_FALSE);\n}\n\nstatic void\nvdev_draid_io_verify(vdev_t *vd, raidz_row_t *rr, int col)\n{\n#ifdef ZFS_DEBUG\n\trange_seg64_t logical_rs, physical_rs, remain_rs;\n\tlogical_rs.rs_start = rr->rr_offset;\n\tlogical_rs.rs_end = logical_rs.rs_start +\n\t    vdev_draid_asize(vd, rr->rr_size);\n\n\traidz_col_t *rc = &rr->rr_col[col];\n\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\n\tvdev_xlate(cvd, &logical_rs, &physical_rs, &remain_rs);\n\tASSERT(vdev_xlate_is_empty(&remain_rs));\n\tASSERT3U(rc->rc_offset, ==, physical_rs.rs_start);\n\tASSERT3U(rc->rc_offset, <, physical_rs.rs_end);\n\tASSERT3U(rc->rc_offset + rc->rc_size, ==, physical_rs.rs_end);\n#endif\n}\n\n \nstatic void\nvdev_draid_io_start_write(zio_t *zio, raidz_row_t *rr)\n{\n\tvdev_t *vd = zio->io_vd;\n\traidz_map_t *rm = zio->io_vsd;\n\n\tvdev_raidz_generate_parity_row(rm, rr);\n\n\tfor (int c = 0; c < rr->rr_cols; c++) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\n\t\t \n\t\tASSERT3U(rc->rc_size, !=, 0);\n\n\t\t \n\t\tvdev_draid_io_verify(vd, rr, c);\n\n\t\tzio_nowait(zio_vdev_child_io(zio, NULL,\n\t\t    vd->vdev_child[rc->rc_devidx], rc->rc_offset,\n\t\t    rc->rc_abd, rc->rc_size, zio->io_type, zio->io_priority,\n\t\t    0, vdev_raidz_child_done, rc));\n\t}\n}\n\n \nstatic void\nvdev_draid_io_start_read(zio_t *zio, raidz_row_t *rr)\n{\n\tvdev_t *vd = zio->io_vd;\n\n\t \n\tIMPLY(zio->io_priority == ZIO_PRIORITY_REBUILD, rr->rr_nempty == 0);\n\n\t \n\tfor (int c = rr->rr_cols - 1; c >= 0; c--) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\n\t\tif (!vdev_draid_readable(cvd, rc->rc_offset)) {\n\t\t\tif (c >= rr->rr_firstdatacol)\n\t\t\t\trr->rr_missingdata++;\n\t\t\telse\n\t\t\t\trr->rr_missingparity++;\n\t\t\trc->rc_error = SET_ERROR(ENXIO);\n\t\t\trc->rc_tried = 1;\n\t\t\trc->rc_skipped = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (vdev_draid_missing(cvd, rc->rc_offset, zio->io_txg, 1)) {\n\t\t\tif (c >= rr->rr_firstdatacol)\n\t\t\t\trr->rr_missingdata++;\n\t\t\telse\n\t\t\t\trr->rr_missingparity++;\n\t\t\trc->rc_error = SET_ERROR(ESTALE);\n\t\t\trc->rc_skipped = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (rc->rc_size == 0) {\n\t\t\trc->rc_skipped = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (zio->io_flags & ZIO_FLAG_RESILVER) {\n\t\t\tvdev_t *svd;\n\n\t\t\t \n\t\t\tif (zio->io_priority == ZIO_PRIORITY_REBUILD) {\n\t\t\t\tif (vdev_draid_rebuilding(cvd)) {\n\t\t\t\t\tif (c >= rr->rr_firstdatacol)\n\t\t\t\t\t\trr->rr_missingdata++;\n\t\t\t\t\telse\n\t\t\t\t\t\trr->rr_missingparity++;\n\t\t\t\t\trc->rc_error = SET_ERROR(ESTALE);\n\t\t\t\t\trc->rc_skipped = 1;\n\t\t\t\t\trc->rc_allow_repair = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\trc->rc_allow_repair = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc->rc_allow_repair = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((svd = vdev_draid_find_spare(cvd)) != NULL) {\n\t\t\t\tsvd = vdev_draid_spare_get_child(svd,\n\t\t\t\t    rc->rc_offset);\n\t\t\t\tif (svd && (svd->vdev_ops == &vdev_spare_ops ||\n\t\t\t\t    svd->vdev_ops == &vdev_replacing_ops)) {\n\t\t\t\t\trc->rc_force_repair = 1;\n\n\t\t\t\t\tif (vdev_draid_rebuilding(svd))\n\t\t\t\t\t\trc->rc_allow_repair = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((cvd->vdev_ops == &vdev_spare_ops ||\n\t\t\t    cvd->vdev_ops == &vdev_replacing_ops) &&\n\t\t\t    vdev_draid_rebuilding(cvd)) {\n\t\t\t\trc->rc_force_repair = 1;\n\t\t\t\trc->rc_allow_repair = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((rr->rr_missingdata > 0 || rr->rr_missingparity > 0) &&\n\t    rr->rr_nempty > 0 && rr->rr_abd_empty == NULL) {\n\t\tvdev_draid_map_alloc_empty(zio, rr);\n\t}\n\n\tfor (int c = rr->rr_cols - 1; c >= 0; c--) {\n\t\traidz_col_t *rc = &rr->rr_col[c];\n\t\tvdev_t *cvd = vd->vdev_child[rc->rc_devidx];\n\n\t\tif (rc->rc_error || rc->rc_size == 0)\n\t\t\tcontinue;\n\n\t\tif (c >= rr->rr_firstdatacol || rr->rr_missingdata > 0 ||\n\t\t    (zio->io_flags & (ZIO_FLAG_SCRUB | ZIO_FLAG_RESILVER))) {\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t    rc->rc_offset, rc->rc_abd, rc->rc_size,\n\t\t\t    zio->io_type, zio->io_priority, 0,\n\t\t\t    vdev_raidz_child_done, rc));\n\t\t}\n\t}\n}\n\n \nstatic void\nvdev_draid_io_start(zio_t *zio)\n{\n\tvdev_t *vd __maybe_unused = zio->io_vd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\tASSERT3U(zio->io_offset, ==, vdev_draid_get_astart(vd, zio->io_offset));\n\n\traidz_map_t *rm = vdev_draid_map_alloc(zio);\n\tzio->io_vsd = rm;\n\tzio->io_vsd_ops = &vdev_raidz_vsd_ops;\n\n\tif (zio->io_type == ZIO_TYPE_WRITE) {\n\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\tvdev_draid_io_start_write(zio, rm->rm_row[i]);\n\t\t}\n\t} else {\n\t\tASSERT(zio->io_type == ZIO_TYPE_READ);\n\n\t\tfor (int i = 0; i < rm->rm_nrows; i++) {\n\t\t\tvdev_draid_io_start_read(zio, rm->rm_row[i]);\n\t\t}\n\t}\n\n\tzio_execute(zio);\n}\n\n \nstatic void\nvdev_draid_io_done(zio_t *zio)\n{\n\tvdev_raidz_io_done(zio);\n}\n\nstatic void\nvdev_draid_state_change(vdev_t *vd, int faulted, int degraded)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\tASSERT(vd->vdev_ops == &vdev_draid_ops);\n\n\tif (faulted > vdc->vdc_nparity)\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_NO_REPLICAS);\n\telse if (degraded + faulted != 0)\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_DEGRADED, VDEV_AUX_NONE);\n\telse\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_HEALTHY, VDEV_AUX_NONE);\n}\n\nstatic void\nvdev_draid_xlate(vdev_t *cvd, const range_seg64_t *logical_rs,\n    range_seg64_t *physical_rs, range_seg64_t *remain_rs)\n{\n\tvdev_t *raidvd = cvd->vdev_parent;\n\tASSERT(raidvd->vdev_ops == &vdev_draid_ops);\n\n\tvdev_draid_config_t *vdc = raidvd->vdev_tsd;\n\tuint64_t ashift = raidvd->vdev_top->vdev_ashift;\n\n\t \n\tASSERT0(logical_rs->rs_start % (1 << ashift));\n\tASSERT0(logical_rs->rs_end % (1 << ashift));\n\n\tuint64_t logical_start = logical_rs->rs_start;\n\tuint64_t logical_end = logical_rs->rs_end;\n\n\t \n\tuint64_t astart = vdev_draid_get_astart(raidvd, logical_start);\n\tif (astart != logical_start) {\n\t\tphysical_rs->rs_start = logical_start;\n\t\tphysical_rs->rs_end = logical_start;\n\t\tremain_rs->rs_start = MIN(astart, logical_end);\n\t\tremain_rs->rs_end = logical_end;\n\t\treturn;\n\t}\n\n\t \n\tuint64_t group = vdev_draid_offset_to_group(raidvd, logical_start);\n\tuint64_t nextstart = vdev_draid_group_to_offset(raidvd, group + 1);\n\tif (logical_end > nextstart)\n\t\tlogical_end = nextstart;\n\n\t \n\tuint64_t perm, groupstart;\n\tuint64_t start = vdev_draid_logical_to_physical(raidvd,\n\t    logical_start, &perm, &groupstart);\n\tuint64_t end = start;\n\n\tuint8_t *base;\n\tuint64_t iter, id;\n\tvdev_draid_get_perm(vdc, perm, &base, &iter);\n\n\t \n\tfor (uint64_t i = 0; i < vdc->vdc_groupwidth; i++) {\n\t\tuint64_t c = (groupstart + i) % vdc->vdc_ndisks;\n\n\t\tif (c == 0 && i != 0) {\n\t\t\t \n\t\t\tstart += VDEV_DRAID_ROWHEIGHT;\n\t\t\tend = start;\n\t\t}\n\n\t\tid = vdev_draid_permute_id(vdc, base, iter, c);\n\t\tif (id == cvd->vdev_id) {\n\t\t\tuint64_t b_size = (logical_end >> ashift) -\n\t\t\t    (logical_start >> ashift);\n\t\t\tASSERT3U(b_size, >, 0);\n\t\t\tend = start + ((((b_size - 1) /\n\t\t\t    vdc->vdc_groupwidth) + 1) << ashift);\n\t\t\tbreak;\n\t\t}\n\t}\n\tphysical_rs->rs_start = start;\n\tphysical_rs->rs_end = end;\n\n\t \n\tremain_rs->rs_start = logical_end;\n\tremain_rs->rs_end = logical_rs->rs_end;\n\n\tASSERT3U(physical_rs->rs_start, <=, logical_start);\n\tASSERT3U(physical_rs->rs_end - physical_rs->rs_start, <=,\n\t    logical_end - logical_start);\n}\n\n \nstatic void\nvdev_draid_config_generate(vdev_t *vd, nvlist_t *nv)\n{\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_ops);\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_NPARITY, vdc->vdc_nparity);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DRAID_NDATA, vdc->vdc_ndata);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DRAID_NSPARES, vdc->vdc_nspares);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_DRAID_NGROUPS, vdc->vdc_ngroups);\n}\n\n \nstatic int\nvdev_draid_init(spa_t *spa, nvlist_t *nv, void **tsd)\n{\n\t(void) spa;\n\tuint64_t ndata, nparity, nspares, ngroups;\n\tint error;\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_DRAID_NDATA, &ndata))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NPARITY, &nparity) ||\n\t    nparity == 0 || nparity > VDEV_DRAID_MAXPARITY) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tuint_t children;\n\tnvlist_t **child;\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0 || children == 0 ||\n\t    children > VDEV_DRAID_MAX_CHILDREN) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_DRAID_NSPARES, &nspares) ||\n\t    nspares > 100 || nspares > (children - (ndata + nparity))) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_DRAID_NGROUPS, &ngroups) ||\n\t    ngroups == 0 || ngroups > VDEV_DRAID_MAX_CHILDREN) {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (children < (ndata + nparity + nspares))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tvdev_draid_config_t *vdc;\n\tconst draid_map_t *map;\n\n\terror = vdev_draid_lookup_map(children, &map);\n\tif (error)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tvdc = kmem_zalloc(sizeof (*vdc), KM_SLEEP);\n\tvdc->vdc_ndata = ndata;\n\tvdc->vdc_nparity = nparity;\n\tvdc->vdc_nspares = nspares;\n\tvdc->vdc_children = children;\n\tvdc->vdc_ngroups = ngroups;\n\tvdc->vdc_nperms = map->dm_nperms;\n\n\terror = vdev_draid_generate_perms(map, &vdc->vdc_perms);\n\tif (error) {\n\t\tkmem_free(vdc, sizeof (*vdc));\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tvdc->vdc_groupwidth = vdc->vdc_ndata + vdc->vdc_nparity;\n\tvdc->vdc_ndisks = vdc->vdc_children - vdc->vdc_nspares;\n\tvdc->vdc_groupsz = vdc->vdc_groupwidth * VDEV_DRAID_ROWHEIGHT;\n\tvdc->vdc_devslicesz = (vdc->vdc_groupsz * vdc->vdc_ngroups) /\n\t    vdc->vdc_ndisks;\n\n\tASSERT3U(vdc->vdc_groupwidth, >=, 2);\n\tASSERT3U(vdc->vdc_groupwidth, <=, vdc->vdc_ndisks);\n\tASSERT3U(vdc->vdc_groupsz, >=, 2 * VDEV_DRAID_ROWHEIGHT);\n\tASSERT3U(vdc->vdc_devslicesz, >=, VDEV_DRAID_ROWHEIGHT);\n\tASSERT3U(vdc->vdc_devslicesz % VDEV_DRAID_ROWHEIGHT, ==, 0);\n\tASSERT3U((vdc->vdc_groupwidth * vdc->vdc_ngroups) %\n\t    vdc->vdc_ndisks, ==, 0);\n\n\t*tsd = vdc;\n\n\treturn (0);\n}\n\nstatic void\nvdev_draid_fini(vdev_t *vd)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\tvmem_free(vdc->vdc_perms, sizeof (uint8_t) *\n\t    vdc->vdc_children * vdc->vdc_nperms);\n\tkmem_free(vdc, sizeof (*vdc));\n}\n\nstatic uint64_t\nvdev_draid_nparity(vdev_t *vd)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\treturn (vdc->vdc_nparity);\n}\n\nstatic uint64_t\nvdev_draid_ndisks(vdev_t *vd)\n{\n\tvdev_draid_config_t *vdc = vd->vdev_tsd;\n\n\treturn (vdc->vdc_ndisks);\n}\n\nvdev_ops_t vdev_draid_ops = {\n\t.vdev_op_init = vdev_draid_init,\n\t.vdev_op_fini = vdev_draid_fini,\n\t.vdev_op_open = vdev_draid_open,\n\t.vdev_op_close = vdev_draid_close,\n\t.vdev_op_asize = vdev_draid_asize,\n\t.vdev_op_min_asize = vdev_draid_min_asize,\n\t.vdev_op_min_alloc = vdev_draid_min_alloc,\n\t.vdev_op_io_start = vdev_draid_io_start,\n\t.vdev_op_io_done = vdev_draid_io_done,\n\t.vdev_op_state_change = vdev_draid_state_change,\n\t.vdev_op_need_resilver = vdev_draid_need_resilver,\n\t.vdev_op_hold = NULL,\n\t.vdev_op_rele = NULL,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = vdev_draid_xlate,\n\t.vdev_op_rebuild_asize = vdev_draid_rebuild_asize,\n\t.vdev_op_metaslab_init = vdev_draid_metaslab_init,\n\t.vdev_op_config_generate = vdev_draid_config_generate,\n\t.vdev_op_nparity = vdev_draid_nparity,\n\t.vdev_op_ndisks = vdev_draid_ndisks,\n\t.vdev_op_type = VDEV_TYPE_DRAID,\n\t.vdev_op_leaf = B_FALSE,\n};\n\n\n \n\n \ntypedef struct {\n\tvdev_t *vds_draid_vdev;\t\t \n\tuint64_t vds_top_guid;\t\t \n\tuint64_t vds_spare_id;\t\t \n} vdev_draid_spare_t;\n\n \nvdev_t *\nvdev_draid_spare_get_parent(vdev_t *vd)\n{\n\tvdev_draid_spare_t *vds = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_spare_ops);\n\n\tif (vds->vds_draid_vdev != NULL)\n\t\treturn (vds->vds_draid_vdev);\n\n\treturn (vdev_lookup_by_guid(vd->vdev_spa->spa_root_vdev,\n\t    vds->vds_top_guid));\n}\n\n \nstatic boolean_t\nvdev_draid_spare_is_active(vdev_t *vd)\n{\n\tvdev_t *pvd = vd->vdev_parent;\n\n\tif (pvd != NULL && (pvd->vdev_ops == &vdev_spare_ops ||\n\t    pvd->vdev_ops == &vdev_replacing_ops ||\n\t    pvd->vdev_ops == &vdev_draid_ops)) {\n\t\treturn (B_TRUE);\n\t} else {\n\t\treturn (B_FALSE);\n\t}\n}\n\n \nvdev_t *\nvdev_draid_spare_get_child(vdev_t *vd, uint64_t physical_offset)\n{\n\tvdev_draid_spare_t *vds = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_spare_ops);\n\n\t \n\tif (vds->vds_draid_vdev == NULL)\n\t\treturn (NULL);\n\n\tvdev_t *tvd = vds->vds_draid_vdev;\n\tvdev_draid_config_t *vdc = tvd->vdev_tsd;\n\n\tASSERT3P(tvd->vdev_ops, ==, &vdev_draid_ops);\n\tASSERT3U(vds->vds_spare_id, <, vdc->vdc_nspares);\n\n\tuint8_t *base;\n\tuint64_t iter;\n\tuint64_t perm = physical_offset / vdc->vdc_devslicesz;\n\n\tvdev_draid_get_perm(vdc, perm, &base, &iter);\n\n\tuint64_t cid = vdev_draid_permute_id(vdc, base, iter,\n\t    (tvd->vdev_children - 1) - vds->vds_spare_id);\n\tvdev_t *cvd = tvd->vdev_child[cid];\n\n\tif (cvd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn (vdev_draid_spare_get_child(cvd, physical_offset));\n\n\treturn (cvd);\n}\n\nstatic void\nvdev_draid_spare_close(vdev_t *vd)\n{\n\tvdev_draid_spare_t *vds = vd->vdev_tsd;\n\tvds->vds_draid_vdev = NULL;\n}\n\n \nstatic int\nvdev_draid_spare_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,\n    uint64_t *logical_ashift, uint64_t *physical_ashift)\n{\n\tvdev_draid_spare_t *vds = vd->vdev_tsd;\n\tvdev_t *rvd = vd->vdev_spa->spa_root_vdev;\n\tuint64_t asize, max_asize;\n\n\tvdev_t *tvd = vdev_lookup_by_guid(rvd, vds->vds_top_guid);\n\tif (tvd == NULL) {\n\t\t \n\t\tif (vd->vdev_parent == NULL) {\n\t\t\t*psize = *max_psize = SPA_MINDEVSIZE;\n\t\t\t*logical_ashift = *physical_ashift = ASHIFT_MIN;\n\t\t\treturn (0);\n\t\t}\n\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tvdev_draid_config_t *vdc = tvd->vdev_tsd;\n\tif (tvd->vdev_ops != &vdev_draid_ops || vdc == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (vds->vds_spare_id >= vdc->vdc_nspares)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tvdev_draid_calculate_asize(tvd, &asize, &max_asize,\n\t    logical_ashift, physical_ashift);\n\n\t*psize = asize + VDEV_LABEL_START_SIZE + VDEV_LABEL_END_SIZE;\n\t*max_psize = max_asize + VDEV_LABEL_START_SIZE + VDEV_LABEL_END_SIZE;\n\n\tvds->vds_draid_vdev = tvd;\n\n\treturn (0);\n}\n\n \nstatic void\nvdev_draid_spare_child_done(zio_t *zio)\n{\n\tzio_t *pio = zio->io_private;\n\n\t \n\tif (!vdev_writeable(zio->io_vd))\n\t\treturn;\n\n\tif (pio->io_error == 0)\n\t\tpio->io_error = zio->io_error;\n}\n\n \nnvlist_t *\nvdev_draid_read_config_spare(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tspa_aux_vdev_t *sav = &spa->spa_spares;\n\tuint64_t guid = vd->vdev_guid;\n\n\tnvlist_t *nv = fnvlist_alloc();\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_IS_SPARE, 1);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_CREATE_TXG, vd->vdev_crtxg);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_VERSION, spa_version(spa));\n\tfnvlist_add_string(nv, ZPOOL_CONFIG_POOL_NAME, spa_name(spa));\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_POOL_GUID, spa_guid(spa));\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_POOL_TXG, spa->spa_config_txg);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_TOP_GUID, vd->vdev_top->vdev_guid);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_POOL_STATE,\n\t    vdev_draid_spare_is_active(vd) ?\n\t    POOL_STATE_ACTIVE : POOL_STATE_SPARE);\n\n\t \n\tfor (int i = 0; i < sav->sav_count; i++) {\n\t\tif (sav->sav_vdevs[i]->vdev_ops == &vdev_draid_spare_ops &&\n\t\t    strcmp(sav->sav_vdevs[i]->vdev_path, vd->vdev_path) == 0) {\n\t\t\tguid = sav->sav_vdevs[i]->vdev_guid;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_GUID, guid);\n\n\treturn (nv);\n}\n\n \nstatic int\nvdev_draid_spare_ioctl(zio_t *zio)\n{\n\tvdev_t *vd = zio->io_vd;\n\tint error = 0;\n\n\tif (zio->io_cmd == DKIOCFLUSHWRITECACHE) {\n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL,\n\t\t\t    vd->vdev_child[c], zio->io_offset, zio->io_abd,\n\t\t\t    zio->io_size, zio->io_type, zio->io_priority, 0,\n\t\t\t    vdev_draid_spare_child_done, zio));\n\t\t}\n\t} else {\n\t\terror = SET_ERROR(ENOTSUP);\n\t}\n\n\treturn (error);\n}\n\n \nstatic void\nvdev_draid_spare_io_start(zio_t *zio)\n{\n\tvdev_t *cvd = NULL, *vd = zio->io_vd;\n\tvdev_draid_spare_t *vds = vd->vdev_tsd;\n\tuint64_t offset = zio->io_offset - VDEV_LABEL_START_SIZE;\n\n\t \n\tif (vds == NULL) {\n\t\tzio->io_error = ENXIO;\n\t\tzio_interrupt(zio);\n\t\treturn;\n\t}\n\n\tswitch (zio->io_type) {\n\tcase ZIO_TYPE_IOCTL:\n\t\tzio->io_error = vdev_draid_spare_ioctl(zio);\n\t\tbreak;\n\n\tcase ZIO_TYPE_WRITE:\n\t\tif (VDEV_OFFSET_IS_LABEL(vd, zio->io_offset)) {\n\t\t\t \n\t\t\tif (zio->io_flags & ZIO_FLAG_PROBE ||\n\t\t\t    zio->io_flags & ZIO_FLAG_CONFIG_WRITER) {\n\t\t\t\tzio->io_error = 0;\n\t\t\t} else {\n\t\t\t\tzio->io_error = SET_ERROR(EIO);\n\t\t\t}\n\t\t} else {\n\t\t\tcvd = vdev_draid_spare_get_child(vd, offset);\n\n\t\t\tif (cvd == NULL) {\n\t\t\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\t\t} else {\n\t\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t\t    offset, zio->io_abd, zio->io_size,\n\t\t\t\t    zio->io_type, zio->io_priority, 0,\n\t\t\t\t    vdev_draid_spare_child_done, zio));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ZIO_TYPE_READ:\n\t\tif (VDEV_OFFSET_IS_LABEL(vd, zio->io_offset)) {\n\t\t\t \n\t\t\tif (zio->io_flags & ZIO_FLAG_PROBE) {\n\t\t\t\tzio->io_error = 0;\n\t\t\t} else {\n\t\t\t\tzio->io_error = SET_ERROR(EIO);\n\t\t\t}\n\t\t} else {\n\t\t\tcvd = vdev_draid_spare_get_child(vd, offset);\n\n\t\t\tif (cvd == NULL || !vdev_readable(cvd)) {\n\t\t\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\t\t} else {\n\t\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t\t    offset, zio->io_abd, zio->io_size,\n\t\t\t\t    zio->io_type, zio->io_priority, 0,\n\t\t\t\t    vdev_draid_spare_child_done, zio));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ZIO_TYPE_TRIM:\n\t\t \n\t\tASSERT0(VDEV_OFFSET_IS_LABEL(vd, zio->io_offset));\n\n\t\tcvd = vdev_draid_spare_get_child(vd, offset);\n\n\t\tif (cvd == NULL || !cvd->vdev_has_trim) {\n\t\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\t} else {\n\t\t\tzio_nowait(zio_vdev_child_io(zio, NULL, cvd,\n\t\t\t    offset, zio->io_abd, zio->io_size,\n\t\t\t    zio->io_type, zio->io_priority, 0,\n\t\t\t    vdev_draid_spare_child_done, zio));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tzio->io_error = SET_ERROR(ENOTSUP);\n\t\tbreak;\n\t}\n\n\tzio_execute(zio);\n}\n\nstatic void\nvdev_draid_spare_io_done(zio_t *zio)\n{\n\t(void) zio;\n}\n\n \nstatic int\nvdev_draid_spare_lookup(spa_t *spa, nvlist_t *nv, uint64_t *top_guidp,\n    uint64_t *spare_idp)\n{\n\tnvlist_t **spares;\n\tuint_t nspares;\n\tint error;\n\n\tif ((spa->spa_spares.sav_config == NULL) ||\n\t    (nvlist_lookup_nvlist_array(spa->spa_spares.sav_config,\n\t    ZPOOL_CONFIG_SPARES, &spares, &nspares) != 0)) {\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tconst char *spare_name;\n\terror = nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &spare_name);\n\tif (error != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tfor (int i = 0; i < nspares; i++) {\n\t\tnvlist_t *spare = spares[i];\n\t\tuint64_t top_guid, spare_id;\n\t\tconst char *type, *path;\n\n\t\t \n\t\terror = nvlist_lookup_string(spare, ZPOOL_CONFIG_TYPE, &type);\n\t\tif (error != 0 || strcmp(type, VDEV_TYPE_DRAID_SPARE) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\terror = nvlist_lookup_string(spare, ZPOOL_CONFIG_PATH, &path);\n\t\tif (error != 0 || strcmp(path, spare_name) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\terror = nvlist_lookup_uint64(spare,\n\t\t    ZPOOL_CONFIG_TOP_GUID, &top_guid);\n\t\tif (error == 0) {\n\t\t\terror = nvlist_lookup_uint64(spare,\n\t\t\t    ZPOOL_CONFIG_SPARE_ID, &spare_id);\n\t\t}\n\n\t\tif (error != 0) {\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t} else {\n\t\t\t*top_guidp = top_guid;\n\t\t\t*spare_idp = spare_id;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (SET_ERROR(ENOENT));\n}\n\n \nstatic int\nvdev_draid_spare_init(spa_t *spa, nvlist_t *nv, void **tsd)\n{\n\tvdev_draid_spare_t *vds;\n\tuint64_t top_guid = 0;\n\tuint64_t spare_id;\n\n\t \n\tif (vdev_draid_spare_lookup(spa, nv, &top_guid, &spare_id) != 0) {\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_TOP_GUID,\n\t\t    &top_guid) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_SPARE_ID,\n\t\t    &spare_id) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tvds = kmem_alloc(sizeof (vdev_draid_spare_t), KM_SLEEP);\n\tvds->vds_draid_vdev = NULL;\n\tvds->vds_top_guid = top_guid;\n\tvds->vds_spare_id = spare_id;\n\n\t*tsd = vds;\n\n\treturn (0);\n}\n\nstatic void\nvdev_draid_spare_fini(vdev_t *vd)\n{\n\tkmem_free(vd->vdev_tsd, sizeof (vdev_draid_spare_t));\n}\n\nstatic void\nvdev_draid_spare_config_generate(vdev_t *vd, nvlist_t *nv)\n{\n\tvdev_draid_spare_t *vds = vd->vdev_tsd;\n\n\tASSERT3P(vd->vdev_ops, ==, &vdev_draid_spare_ops);\n\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_TOP_GUID, vds->vds_top_guid);\n\tfnvlist_add_uint64(nv, ZPOOL_CONFIG_SPARE_ID, vds->vds_spare_id);\n}\n\nvdev_ops_t vdev_draid_spare_ops = {\n\t.vdev_op_init = vdev_draid_spare_init,\n\t.vdev_op_fini = vdev_draid_spare_fini,\n\t.vdev_op_open = vdev_draid_spare_open,\n\t.vdev_op_close = vdev_draid_spare_close,\n\t.vdev_op_asize = vdev_default_asize,\n\t.vdev_op_min_asize = vdev_default_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = vdev_draid_spare_io_start,\n\t.vdev_op_io_done = vdev_draid_spare_io_done,\n\t.vdev_op_state_change = NULL,\n\t.vdev_op_need_resilver = NULL,\n\t.vdev_op_hold = NULL,\n\t.vdev_op_rele = NULL,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = vdev_default_xlate,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = vdev_draid_spare_config_generate,\n\t.vdev_op_nparity = NULL,\n\t.vdev_op_ndisks = NULL,\n\t.vdev_op_type = VDEV_TYPE_DRAID_SPARE,\n\t.vdev_op_leaf = B_TRUE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}