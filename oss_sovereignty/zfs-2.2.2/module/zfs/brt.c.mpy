{
  "module_name": "brt.c",
  "hash_id": "a41c18667fa66c4ee24eec38934cda7760e513e8aca0fd1c26bb679798e1bb6a",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/brt.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zio.h>\n#include <sys/brt.h>\n#include <sys/brt_impl.h>\n#include <sys/ddt.h>\n#include <sys/bitmap.h>\n#include <sys/zap.h>\n#include <sys/dmu_tx.h>\n#include <sys/arc.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_scan.h>\n#include <sys/vdev_impl.h>\n#include <sys/kstat.h>\n#include <sys/wmsum.h>\n\n \n\nstatic kmem_cache_t *brt_entry_cache;\nstatic kmem_cache_t *brt_pending_entry_cache;\n\n \nint zfs_brt_prefetch = 1;\n\n#ifdef ZFS_DEBUG\n#define\tBRT_DEBUG(...)\tdo {\t\t\t\t\t\t\\\n\tif ((zfs_flags & ZFS_DEBUG_BRT) != 0) {\t\t\t\t\\\n\t\t__dprintf(B_TRUE, __FILE__, __func__, __LINE__, __VA_ARGS__); \\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n#else\n#define\tBRT_DEBUG(...)\tdo { } while (0)\n#endif\n\nint brt_zap_leaf_blockshift = 12;\nint brt_zap_indirect_blockshift = 12;\n\nstatic kstat_t\t*brt_ksp;\n\ntypedef struct brt_stats {\n\tkstat_named_t brt_addref_entry_in_memory;\n\tkstat_named_t brt_addref_entry_not_on_disk;\n\tkstat_named_t brt_addref_entry_on_disk;\n\tkstat_named_t brt_addref_entry_read_lost_race;\n\tkstat_named_t brt_decref_entry_in_memory;\n\tkstat_named_t brt_decref_entry_loaded_from_disk;\n\tkstat_named_t brt_decref_entry_not_in_memory;\n\tkstat_named_t brt_decref_entry_not_on_disk;\n\tkstat_named_t brt_decref_entry_read_lost_race;\n\tkstat_named_t brt_decref_entry_still_referenced;\n\tkstat_named_t brt_decref_free_data_later;\n\tkstat_named_t brt_decref_free_data_now;\n\tkstat_named_t brt_decref_no_entry;\n} brt_stats_t;\n\nstatic brt_stats_t brt_stats = {\n\t{ \"addref_entry_in_memory\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"addref_entry_not_on_disk\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"addref_entry_on_disk\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"addref_entry_read_lost_race\",\tKSTAT_DATA_UINT64 },\n\t{ \"decref_entry_in_memory\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"decref_entry_loaded_from_disk\",\tKSTAT_DATA_UINT64 },\n\t{ \"decref_entry_not_in_memory\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"decref_entry_not_on_disk\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"decref_entry_read_lost_race\",\tKSTAT_DATA_UINT64 },\n\t{ \"decref_entry_still_referenced\",\tKSTAT_DATA_UINT64 },\n\t{ \"decref_free_data_later\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"decref_free_data_now\",\t\tKSTAT_DATA_UINT64 },\n\t{ \"decref_no_entry\",\t\t\tKSTAT_DATA_UINT64 }\n};\n\nstruct {\n\twmsum_t brt_addref_entry_in_memory;\n\twmsum_t brt_addref_entry_not_on_disk;\n\twmsum_t brt_addref_entry_on_disk;\n\twmsum_t brt_addref_entry_read_lost_race;\n\twmsum_t brt_decref_entry_in_memory;\n\twmsum_t brt_decref_entry_loaded_from_disk;\n\twmsum_t brt_decref_entry_not_in_memory;\n\twmsum_t brt_decref_entry_not_on_disk;\n\twmsum_t brt_decref_entry_read_lost_race;\n\twmsum_t brt_decref_entry_still_referenced;\n\twmsum_t brt_decref_free_data_later;\n\twmsum_t brt_decref_free_data_now;\n\twmsum_t brt_decref_no_entry;\n} brt_sums;\n\n#define\tBRTSTAT_BUMP(stat)\twmsum_add(&brt_sums.stat, 1)\n\nstatic int brt_entry_compare(const void *x1, const void *x2);\nstatic int brt_pending_entry_compare(const void *x1, const void *x2);\n\nstatic void\nbrt_rlock(brt_t *brt)\n{\n\trw_enter(&brt->brt_lock, RW_READER);\n}\n\nstatic void\nbrt_wlock(brt_t *brt)\n{\n\trw_enter(&brt->brt_lock, RW_WRITER);\n}\n\nstatic void\nbrt_unlock(brt_t *brt)\n{\n\trw_exit(&brt->brt_lock);\n}\n\nstatic uint16_t\nbrt_vdev_entcount_get(const brt_vdev_t *brtvd, uint64_t idx)\n{\n\n\tASSERT3U(idx, <, brtvd->bv_size);\n\n\tif (brtvd->bv_need_byteswap) {\n\t\treturn (BSWAP_16(brtvd->bv_entcount[idx]));\n\t} else {\n\t\treturn (brtvd->bv_entcount[idx]);\n\t}\n}\n\nstatic void\nbrt_vdev_entcount_set(brt_vdev_t *brtvd, uint64_t idx, uint16_t entcnt)\n{\n\n\tASSERT3U(idx, <, brtvd->bv_size);\n\n\tif (brtvd->bv_need_byteswap) {\n\t\tbrtvd->bv_entcount[idx] = BSWAP_16(entcnt);\n\t} else {\n\t\tbrtvd->bv_entcount[idx] = entcnt;\n\t}\n}\n\nstatic void\nbrt_vdev_entcount_inc(brt_vdev_t *brtvd, uint64_t idx)\n{\n\tuint16_t entcnt;\n\n\tASSERT3U(idx, <, brtvd->bv_size);\n\n\tentcnt = brt_vdev_entcount_get(brtvd, idx);\n\tASSERT(entcnt < UINT16_MAX);\n\n\tbrt_vdev_entcount_set(brtvd, idx, entcnt + 1);\n}\n\nstatic void\nbrt_vdev_entcount_dec(brt_vdev_t *brtvd, uint64_t idx)\n{\n\tuint16_t entcnt;\n\n\tASSERT3U(idx, <, brtvd->bv_size);\n\n\tentcnt = brt_vdev_entcount_get(brtvd, idx);\n\tASSERT(entcnt > 0);\n\n\tbrt_vdev_entcount_set(brtvd, idx, entcnt - 1);\n}\n\n#ifdef ZFS_DEBUG\nstatic void\nbrt_vdev_dump(brt_t *brt)\n{\n\tbrt_vdev_t *brtvd;\n\tuint64_t vdevid;\n\n\tif ((zfs_flags & ZFS_DEBUG_BRT) == 0) {\n\t\treturn;\n\t}\n\n\tif (brt->brt_nvdevs == 0) {\n\t\tzfs_dbgmsg(\"BRT empty\");\n\t\treturn;\n\t}\n\n\tzfs_dbgmsg(\"BRT vdev dump:\");\n\tfor (vdevid = 0; vdevid < brt->brt_nvdevs; vdevid++) {\n\t\tuint64_t idx;\n\n\t\tbrtvd = &brt->brt_vdevs[vdevid];\n\t\tzfs_dbgmsg(\"  vdevid=%llu/%llu meta_dirty=%d entcount_dirty=%d \"\n\t\t    \"size=%llu totalcount=%llu nblocks=%llu bitmapsize=%zu\\n\",\n\t\t    (u_longlong_t)vdevid, (u_longlong_t)brtvd->bv_vdevid,\n\t\t    brtvd->bv_meta_dirty, brtvd->bv_entcount_dirty,\n\t\t    (u_longlong_t)brtvd->bv_size,\n\t\t    (u_longlong_t)brtvd->bv_totalcount,\n\t\t    (u_longlong_t)brtvd->bv_nblocks,\n\t\t    (size_t)BT_SIZEOFMAP(brtvd->bv_nblocks));\n\t\tif (brtvd->bv_totalcount > 0) {\n\t\t\tzfs_dbgmsg(\"    entcounts:\");\n\t\t\tfor (idx = 0; idx < brtvd->bv_size; idx++) {\n\t\t\t\tif (brt_vdev_entcount_get(brtvd, idx) > 0) {\n\t\t\t\t\tzfs_dbgmsg(\"      [%04llu] %hu\",\n\t\t\t\t\t    (u_longlong_t)idx,\n\t\t\t\t\t    brt_vdev_entcount_get(brtvd, idx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (brtvd->bv_entcount_dirty) {\n\t\t\tchar *bitmap;\n\n\t\t\tbitmap = kmem_alloc(brtvd->bv_nblocks + 1, KM_SLEEP);\n\t\t\tfor (idx = 0; idx < brtvd->bv_nblocks; idx++) {\n\t\t\t\tbitmap[idx] =\n\t\t\t\t    BT_TEST(brtvd->bv_bitmap, idx) ? 'x' : '.';\n\t\t\t}\n\t\t\tbitmap[idx] = '\\0';\n\t\t\tzfs_dbgmsg(\"    bitmap: %s\", bitmap);\n\t\t\tkmem_free(bitmap, brtvd->bv_nblocks + 1);\n\t\t}\n\t}\n}\n#endif\n\nstatic brt_vdev_t *\nbrt_vdev(brt_t *brt, uint64_t vdevid)\n{\n\tbrt_vdev_t *brtvd;\n\n\tASSERT(RW_LOCK_HELD(&brt->brt_lock));\n\n\tif (vdevid < brt->brt_nvdevs) {\n\t\tbrtvd = &brt->brt_vdevs[vdevid];\n\t} else {\n\t\tbrtvd = NULL;\n\t}\n\n\treturn (brtvd);\n}\n\nstatic void\nbrt_vdev_create(brt_t *brt, brt_vdev_t *brtvd, dmu_tx_t *tx)\n{\n\tchar name[64];\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tASSERT0(brtvd->bv_mos_brtvdev);\n\tASSERT0(brtvd->bv_mos_entries);\n\tASSERT(brtvd->bv_entcount != NULL);\n\tASSERT(brtvd->bv_size > 0);\n\tASSERT(brtvd->bv_bitmap != NULL);\n\tASSERT(brtvd->bv_nblocks > 0);\n\n\tbrtvd->bv_mos_entries = zap_create_flags(brt->brt_mos, 0,\n\t    ZAP_FLAG_HASH64 | ZAP_FLAG_UINT64_KEY, DMU_OTN_ZAP_METADATA,\n\t    brt_zap_leaf_blockshift, brt_zap_indirect_blockshift, DMU_OT_NONE,\n\t    0, tx);\n\tVERIFY(brtvd->bv_mos_entries != 0);\n\tBRT_DEBUG(\"MOS entries created, object=%llu\",\n\t    (u_longlong_t)brtvd->bv_mos_entries);\n\n\t \n\tbrtvd->bv_mos_brtvdev = dmu_object_alloc(brt->brt_mos,\n\t    DMU_OTN_UINT64_METADATA, BRT_BLOCKSIZE,\n\t    DMU_OTN_UINT64_METADATA, sizeof (brt_vdev_phys_t), tx);\n\tVERIFY(brtvd->bv_mos_brtvdev != 0);\n\tBRT_DEBUG(\"MOS BRT VDEV created, object=%llu\",\n\t    (u_longlong_t)brtvd->bv_mos_brtvdev);\n\n\tsnprintf(name, sizeof (name), \"%s%llu\", BRT_OBJECT_VDEV_PREFIX,\n\t    (u_longlong_t)brtvd->bv_vdevid);\n\tVERIFY0(zap_add(brt->brt_mos, DMU_POOL_DIRECTORY_OBJECT, name,\n\t    sizeof (uint64_t), 1, &brtvd->bv_mos_brtvdev, tx));\n\tBRT_DEBUG(\"Pool directory object created, object=%s\", name);\n\n\tspa_feature_incr(brt->brt_spa, SPA_FEATURE_BLOCK_CLONING, tx);\n}\n\nstatic void\nbrt_vdev_realloc(brt_t *brt, brt_vdev_t *brtvd)\n{\n\tvdev_t *vd;\n\tuint16_t *entcount;\n\tulong_t *bitmap;\n\tuint64_t nblocks, size;\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\n\tspa_config_enter(brt->brt_spa, SCL_VDEV, FTAG, RW_READER);\n\tvd = vdev_lookup_top(brt->brt_spa, brtvd->bv_vdevid);\n\tsize = (vdev_get_min_asize(vd) - 1) / brt->brt_rangesize + 1;\n\tspa_config_exit(brt->brt_spa, SCL_VDEV, FTAG);\n\n\tentcount = vmem_zalloc(sizeof (entcount[0]) * size, KM_SLEEP);\n\tnblocks = BRT_RANGESIZE_TO_NBLOCKS(size);\n\tbitmap = kmem_zalloc(BT_SIZEOFMAP(nblocks), KM_SLEEP);\n\n\tif (!brtvd->bv_initiated) {\n\t\tASSERT0(brtvd->bv_size);\n\t\tASSERT(brtvd->bv_entcount == NULL);\n\t\tASSERT(brtvd->bv_bitmap == NULL);\n\t\tASSERT0(brtvd->bv_nblocks);\n\n\t\tavl_create(&brtvd->bv_tree, brt_entry_compare,\n\t\t    sizeof (brt_entry_t), offsetof(brt_entry_t, bre_node));\n\t} else {\n\t\tASSERT(brtvd->bv_size > 0);\n\t\tASSERT(brtvd->bv_entcount != NULL);\n\t\tASSERT(brtvd->bv_bitmap != NULL);\n\t\tASSERT(brtvd->bv_nblocks > 0);\n\t\t \n\t\tASSERT3U(brtvd->bv_size, <=, size);\n\n\t\tmemcpy(entcount, brtvd->bv_entcount,\n\t\t    sizeof (entcount[0]) * MIN(size, brtvd->bv_size));\n\t\tmemcpy(bitmap, brtvd->bv_bitmap, MIN(BT_SIZEOFMAP(nblocks),\n\t\t    BT_SIZEOFMAP(brtvd->bv_nblocks)));\n\t\tvmem_free(brtvd->bv_entcount,\n\t\t    sizeof (entcount[0]) * brtvd->bv_size);\n\t\tkmem_free(brtvd->bv_bitmap, BT_SIZEOFMAP(brtvd->bv_nblocks));\n\t}\n\n\tbrtvd->bv_size = size;\n\tbrtvd->bv_entcount = entcount;\n\tbrtvd->bv_bitmap = bitmap;\n\tbrtvd->bv_nblocks = nblocks;\n\tif (!brtvd->bv_initiated) {\n\t\tbrtvd->bv_need_byteswap = FALSE;\n\t\tbrtvd->bv_initiated = TRUE;\n\t\tBRT_DEBUG(\"BRT VDEV %llu initiated.\",\n\t\t    (u_longlong_t)brtvd->bv_vdevid);\n\t}\n}\n\nstatic void\nbrt_vdev_load(brt_t *brt, brt_vdev_t *brtvd)\n{\n\tchar name[64];\n\tdmu_buf_t *db;\n\tbrt_vdev_phys_t *bvphys;\n\tint error;\n\n\tsnprintf(name, sizeof (name), \"%s%llu\", BRT_OBJECT_VDEV_PREFIX,\n\t    (u_longlong_t)brtvd->bv_vdevid);\n\terror = zap_lookup(brt->brt_mos, DMU_POOL_DIRECTORY_OBJECT, name,\n\t    sizeof (uint64_t), 1, &brtvd->bv_mos_brtvdev);\n\tif (error != 0)\n\t\treturn;\n\tASSERT(brtvd->bv_mos_brtvdev != 0);\n\n\terror = dmu_bonus_hold(brt->brt_mos, brtvd->bv_mos_brtvdev, FTAG, &db);\n\tASSERT0(error);\n\tif (error != 0)\n\t\treturn;\n\n\tbvphys = db->db_data;\n\tif (brt->brt_rangesize == 0) {\n\t\tbrt->brt_rangesize = bvphys->bvp_rangesize;\n\t} else {\n\t\tASSERT3U(brt->brt_rangesize, ==, bvphys->bvp_rangesize);\n\t}\n\n\tASSERT(!brtvd->bv_initiated);\n\tbrt_vdev_realloc(brt, brtvd);\n\n\t \n\tASSERT3U(bvphys->bvp_size, <=, brtvd->bv_size);\n\n\t \n\terror = dmu_read(brt->brt_mos, brtvd->bv_mos_brtvdev, 0,\n\t    MIN(brtvd->bv_size, bvphys->bvp_size) * sizeof (uint16_t),\n\t    brtvd->bv_entcount, DMU_READ_NO_PREFETCH);\n\tASSERT0(error);\n\n\tbrtvd->bv_mos_entries = bvphys->bvp_mos_entries;\n\tASSERT(brtvd->bv_mos_entries != 0);\n\tbrtvd->bv_need_byteswap =\n\t    (bvphys->bvp_byteorder != BRT_NATIVE_BYTEORDER);\n\tbrtvd->bv_totalcount = bvphys->bvp_totalcount;\n\tbrtvd->bv_usedspace = bvphys->bvp_usedspace;\n\tbrtvd->bv_savedspace = bvphys->bvp_savedspace;\n\tbrt->brt_usedspace += brtvd->bv_usedspace;\n\tbrt->brt_savedspace += brtvd->bv_savedspace;\n\n\tdmu_buf_rele(db, FTAG);\n\n\tBRT_DEBUG(\"MOS BRT VDEV %s loaded: mos_brtvdev=%llu, mos_entries=%llu\",\n\t    name, (u_longlong_t)brtvd->bv_mos_brtvdev,\n\t    (u_longlong_t)brtvd->bv_mos_entries);\n}\n\nstatic void\nbrt_vdev_dealloc(brt_t *brt, brt_vdev_t *brtvd)\n{\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tASSERT(brtvd->bv_initiated);\n\n\tvmem_free(brtvd->bv_entcount, sizeof (uint16_t) * brtvd->bv_size);\n\tbrtvd->bv_entcount = NULL;\n\tkmem_free(brtvd->bv_bitmap, BT_SIZEOFMAP(brtvd->bv_nblocks));\n\tbrtvd->bv_bitmap = NULL;\n\tASSERT0(avl_numnodes(&brtvd->bv_tree));\n\tavl_destroy(&brtvd->bv_tree);\n\n\tbrtvd->bv_size = 0;\n\tbrtvd->bv_nblocks = 0;\n\n\tbrtvd->bv_initiated = FALSE;\n\tBRT_DEBUG(\"BRT VDEV %llu deallocated.\", (u_longlong_t)brtvd->bv_vdevid);\n}\n\nstatic void\nbrt_vdev_destroy(brt_t *brt, brt_vdev_t *brtvd, dmu_tx_t *tx)\n{\n\tchar name[64];\n\tuint64_t count;\n\tdmu_buf_t *db;\n\tbrt_vdev_phys_t *bvphys;\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tASSERT(brtvd->bv_mos_brtvdev != 0);\n\tASSERT(brtvd->bv_mos_entries != 0);\n\n\tVERIFY0(zap_count(brt->brt_mos, brtvd->bv_mos_entries, &count));\n\tVERIFY0(count);\n\tVERIFY0(zap_destroy(brt->brt_mos, brtvd->bv_mos_entries, tx));\n\tBRT_DEBUG(\"MOS entries destroyed, object=%llu\",\n\t    (u_longlong_t)brtvd->bv_mos_entries);\n\tbrtvd->bv_mos_entries = 0;\n\n\tVERIFY0(dmu_bonus_hold(brt->brt_mos, brtvd->bv_mos_brtvdev, FTAG, &db));\n\tbvphys = db->db_data;\n\tASSERT0(bvphys->bvp_totalcount);\n\tASSERT0(bvphys->bvp_usedspace);\n\tASSERT0(bvphys->bvp_savedspace);\n\tdmu_buf_rele(db, FTAG);\n\n\tVERIFY0(dmu_object_free(brt->brt_mos, brtvd->bv_mos_brtvdev, tx));\n\tBRT_DEBUG(\"MOS BRT VDEV destroyed, object=%llu\",\n\t    (u_longlong_t)brtvd->bv_mos_brtvdev);\n\tbrtvd->bv_mos_brtvdev = 0;\n\n\tsnprintf(name, sizeof (name), \"%s%llu\", BRT_OBJECT_VDEV_PREFIX,\n\t    (u_longlong_t)brtvd->bv_vdevid);\n\tVERIFY0(zap_remove(brt->brt_mos, DMU_POOL_DIRECTORY_OBJECT, name, tx));\n\tBRT_DEBUG(\"Pool directory object removed, object=%s\", name);\n\n\tbrt_vdev_dealloc(brt, brtvd);\n\n\tspa_feature_decr(brt->brt_spa, SPA_FEATURE_BLOCK_CLONING, tx);\n}\n\nstatic void\nbrt_vdevs_expand(brt_t *brt, uint64_t nvdevs)\n{\n\tbrt_vdev_t *brtvd, *vdevs;\n\tuint64_t vdevid;\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tASSERT3U(nvdevs, >, brt->brt_nvdevs);\n\n\tvdevs = kmem_zalloc(sizeof (vdevs[0]) * nvdevs, KM_SLEEP);\n\tif (brt->brt_nvdevs > 0) {\n\t\tASSERT(brt->brt_vdevs != NULL);\n\n\t\tmemcpy(vdevs, brt->brt_vdevs,\n\t\t    sizeof (brt_vdev_t) * brt->brt_nvdevs);\n\t\tkmem_free(brt->brt_vdevs,\n\t\t    sizeof (brt_vdev_t) * brt->brt_nvdevs);\n\t}\n\tfor (vdevid = brt->brt_nvdevs; vdevid < nvdevs; vdevid++) {\n\t\tbrtvd = &vdevs[vdevid];\n\n\t\tbrtvd->bv_vdevid = vdevid;\n\t\tbrtvd->bv_initiated = FALSE;\n\t}\n\n\tBRT_DEBUG(\"BRT VDEVs expanded from %llu to %llu.\",\n\t    (u_longlong_t)brt->brt_nvdevs, (u_longlong_t)nvdevs);\n\n\tbrt->brt_vdevs = vdevs;\n\tbrt->brt_nvdevs = nvdevs;\n}\n\nstatic boolean_t\nbrt_vdev_lookup(brt_t *brt, brt_vdev_t *brtvd, const brt_entry_t *bre)\n{\n\tuint64_t idx;\n\n\tASSERT(RW_LOCK_HELD(&brt->brt_lock));\n\n\tidx = bre->bre_offset / brt->brt_rangesize;\n\tif (brtvd->bv_entcount != NULL && idx < brtvd->bv_size) {\n\t\t \n\t\treturn (brt_vdev_entcount_get(brtvd, idx) > 0);\n\t}\n\n\treturn (FALSE);\n}\n\nstatic void\nbrt_vdev_addref(brt_t *brt, brt_vdev_t *brtvd, const brt_entry_t *bre,\n    uint64_t dsize)\n{\n\tuint64_t idx;\n\n\tASSERT(RW_LOCK_HELD(&brt->brt_lock));\n\tASSERT(brtvd != NULL);\n\tASSERT(brtvd->bv_entcount != NULL);\n\n\tbrt->brt_savedspace += dsize;\n\tbrtvd->bv_savedspace += dsize;\n\tbrtvd->bv_meta_dirty = TRUE;\n\n\tif (bre->bre_refcount > 1) {\n\t\treturn;\n\t}\n\n\tbrt->brt_usedspace += dsize;\n\tbrtvd->bv_usedspace += dsize;\n\n\tidx = bre->bre_offset / brt->brt_rangesize;\n\tif (idx >= brtvd->bv_size) {\n\t\t \n\t\tbrt_vdev_realloc(brt, brtvd);\n\t}\n\n\tASSERT3U(idx, <, brtvd->bv_size);\n\n\tbrtvd->bv_totalcount++;\n\tbrt_vdev_entcount_inc(brtvd, idx);\n\tbrtvd->bv_entcount_dirty = TRUE;\n\tidx = idx / BRT_BLOCKSIZE / 8;\n\tBT_SET(brtvd->bv_bitmap, idx);\n\n#ifdef ZFS_DEBUG\n\tbrt_vdev_dump(brt);\n#endif\n}\n\nstatic void\nbrt_vdev_decref(brt_t *brt, brt_vdev_t *brtvd, const brt_entry_t *bre,\n    uint64_t dsize)\n{\n\tuint64_t idx;\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tASSERT(brtvd != NULL);\n\tASSERT(brtvd->bv_entcount != NULL);\n\n\tbrt->brt_savedspace -= dsize;\n\tbrtvd->bv_savedspace -= dsize;\n\tbrtvd->bv_meta_dirty = TRUE;\n\n\tif (bre->bre_refcount > 0) {\n\t\treturn;\n\t}\n\n\tbrt->brt_usedspace -= dsize;\n\tbrtvd->bv_usedspace -= dsize;\n\n\tidx = bre->bre_offset / brt->brt_rangesize;\n\tASSERT3U(idx, <, brtvd->bv_size);\n\n\tASSERT(brtvd->bv_totalcount > 0);\n\tbrtvd->bv_totalcount--;\n\tbrt_vdev_entcount_dec(brtvd, idx);\n\tbrtvd->bv_entcount_dirty = TRUE;\n\tidx = idx / BRT_BLOCKSIZE / 8;\n\tBT_SET(brtvd->bv_bitmap, idx);\n\n#ifdef ZFS_DEBUG\n\tbrt_vdev_dump(brt);\n#endif\n}\n\nstatic void\nbrt_vdev_sync(brt_t *brt, brt_vdev_t *brtvd, dmu_tx_t *tx)\n{\n\tdmu_buf_t *db;\n\tbrt_vdev_phys_t *bvphys;\n\n\tASSERT(brtvd->bv_meta_dirty);\n\tASSERT(brtvd->bv_mos_brtvdev != 0);\n\tASSERT(dmu_tx_is_syncing(tx));\n\n\tVERIFY0(dmu_bonus_hold(brt->brt_mos, brtvd->bv_mos_brtvdev, FTAG, &db));\n\n\tif (brtvd->bv_entcount_dirty) {\n\t\t \n\t\tdmu_write(brt->brt_mos, brtvd->bv_mos_brtvdev, 0,\n\t\t    brtvd->bv_size * sizeof (brtvd->bv_entcount[0]),\n\t\t    brtvd->bv_entcount, tx);\n\t\tmemset(brtvd->bv_bitmap, 0, BT_SIZEOFMAP(brtvd->bv_nblocks));\n\t\tbrtvd->bv_entcount_dirty = FALSE;\n\t}\n\n\tdmu_buf_will_dirty(db, tx);\n\tbvphys = db->db_data;\n\tbvphys->bvp_mos_entries = brtvd->bv_mos_entries;\n\tbvphys->bvp_size = brtvd->bv_size;\n\tif (brtvd->bv_need_byteswap) {\n\t\tbvphys->bvp_byteorder = BRT_NON_NATIVE_BYTEORDER;\n\t} else {\n\t\tbvphys->bvp_byteorder = BRT_NATIVE_BYTEORDER;\n\t}\n\tbvphys->bvp_totalcount = brtvd->bv_totalcount;\n\tbvphys->bvp_rangesize = brt->brt_rangesize;\n\tbvphys->bvp_usedspace = brtvd->bv_usedspace;\n\tbvphys->bvp_savedspace = brtvd->bv_savedspace;\n\tdmu_buf_rele(db, FTAG);\n\n\tbrtvd->bv_meta_dirty = FALSE;\n}\n\nstatic void\nbrt_vdevs_alloc(brt_t *brt, boolean_t load)\n{\n\tbrt_vdev_t *brtvd;\n\tuint64_t vdevid;\n\n\tbrt_wlock(brt);\n\n\tbrt_vdevs_expand(brt, brt->brt_spa->spa_root_vdev->vdev_children);\n\n\tif (load) {\n\t\tfor (vdevid = 0; vdevid < brt->brt_nvdevs; vdevid++) {\n\t\t\tbrtvd = &brt->brt_vdevs[vdevid];\n\t\t\tASSERT(brtvd->bv_entcount == NULL);\n\n\t\t\tbrt_vdev_load(brt, brtvd);\n\t\t}\n\t}\n\n\tif (brt->brt_rangesize == 0) {\n\t\tbrt->brt_rangesize = BRT_RANGESIZE;\n\t}\n\n\tbrt_unlock(brt);\n}\n\nstatic void\nbrt_vdevs_free(brt_t *brt)\n{\n\tbrt_vdev_t *brtvd;\n\tuint64_t vdevid;\n\n\tbrt_wlock(brt);\n\n\tfor (vdevid = 0; vdevid < brt->brt_nvdevs; vdevid++) {\n\t\tbrtvd = &brt->brt_vdevs[vdevid];\n\t\tif (brtvd->bv_initiated)\n\t\t\tbrt_vdev_dealloc(brt, brtvd);\n\t}\n\tkmem_free(brt->brt_vdevs, sizeof (brt_vdev_t) * brt->brt_nvdevs);\n\n\tbrt_unlock(brt);\n}\n\nstatic void\nbrt_entry_fill(const blkptr_t *bp, brt_entry_t *bre, uint64_t *vdevidp)\n{\n\n\tbre->bre_offset = DVA_GET_OFFSET(&bp->blk_dva[0]);\n\tbre->bre_refcount = 0;\n\n\t*vdevidp = DVA_GET_VDEV(&bp->blk_dva[0]);\n}\n\nstatic int\nbrt_entry_compare(const void *x1, const void *x2)\n{\n\tconst brt_entry_t *bre1 = x1;\n\tconst brt_entry_t *bre2 = x2;\n\n\treturn (TREE_CMP(bre1->bre_offset, bre2->bre_offset));\n}\n\nstatic int\nbrt_entry_lookup(brt_t *brt, brt_vdev_t *brtvd, brt_entry_t *bre)\n{\n\tuint64_t mos_entries;\n\tuint64_t one, physsize;\n\tint error;\n\n\tASSERT(RW_LOCK_HELD(&brt->brt_lock));\n\n\tif (!brt_vdev_lookup(brt, brtvd, bre))\n\t\treturn (SET_ERROR(ENOENT));\n\n\t \n\tmos_entries = brtvd->bv_mos_entries;\n\tif (mos_entries == 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tbrt_unlock(brt);\n\n\terror = zap_length_uint64(brt->brt_mos, mos_entries, &bre->bre_offset,\n\t    BRT_KEY_WORDS, &one, &physsize);\n\tif (error == 0) {\n\t\tASSERT3U(one, ==, 1);\n\t\tASSERT3U(physsize, ==, sizeof (bre->bre_refcount));\n\n\t\terror = zap_lookup_uint64(brt->brt_mos, mos_entries,\n\t\t    &bre->bre_offset, BRT_KEY_WORDS, 1,\n\t\t    sizeof (bre->bre_refcount), &bre->bre_refcount);\n\t\tBRT_DEBUG(\"ZAP lookup: object=%llu vdev=%llu offset=%llu \"\n\t\t    \"count=%llu error=%d\", (u_longlong_t)mos_entries,\n\t\t    (u_longlong_t)brtvd->bv_vdevid,\n\t\t    (u_longlong_t)bre->bre_offset,\n\t\t    error == 0 ? (u_longlong_t)bre->bre_refcount : 0, error);\n\t}\n\n\tbrt_wlock(brt);\n\n\treturn (error);\n}\n\nstatic void\nbrt_entry_prefetch(brt_t *brt, uint64_t vdevid, brt_entry_t *bre)\n{\n\tbrt_vdev_t *brtvd;\n\tuint64_t mos_entries = 0;\n\n\tbrt_rlock(brt);\n\tbrtvd = brt_vdev(brt, vdevid);\n\tif (brtvd != NULL)\n\t\tmos_entries = brtvd->bv_mos_entries;\n\tbrt_unlock(brt);\n\n\tif (mos_entries == 0)\n\t\treturn;\n\n\tBRT_DEBUG(\"ZAP prefetch: object=%llu vdev=%llu offset=%llu\",\n\t    (u_longlong_t)mos_entries, (u_longlong_t)vdevid,\n\t    (u_longlong_t)bre->bre_offset);\n\t(void) zap_prefetch_uint64(brt->brt_mos, mos_entries,\n\t    (uint64_t *)&bre->bre_offset, BRT_KEY_WORDS);\n}\n\nstatic int\nbrt_entry_update(brt_t *brt, brt_vdev_t *brtvd, brt_entry_t *bre, dmu_tx_t *tx)\n{\n\tint error;\n\n\tASSERT(RW_LOCK_HELD(&brt->brt_lock));\n\tASSERT(brtvd->bv_mos_entries != 0);\n\tASSERT(bre->bre_refcount > 0);\n\n\terror = zap_update_uint64(brt->brt_mos, brtvd->bv_mos_entries,\n\t    (uint64_t *)&bre->bre_offset, BRT_KEY_WORDS, 1,\n\t    sizeof (bre->bre_refcount), &bre->bre_refcount, tx);\n\tBRT_DEBUG(\"ZAP update: object=%llu vdev=%llu offset=%llu count=%llu \"\n\t    \"error=%d\", (u_longlong_t)brtvd->bv_mos_entries,\n\t    (u_longlong_t)brtvd->bv_vdevid, (u_longlong_t)bre->bre_offset,\n\t    (u_longlong_t)bre->bre_refcount, error);\n\n\treturn (error);\n}\n\nstatic int\nbrt_entry_remove(brt_t *brt, brt_vdev_t *brtvd, brt_entry_t *bre, dmu_tx_t *tx)\n{\n\tint error;\n\n\tASSERT(RW_LOCK_HELD(&brt->brt_lock));\n\tASSERT(brtvd->bv_mos_entries != 0);\n\tASSERT0(bre->bre_refcount);\n\n\terror = zap_remove_uint64(brt->brt_mos, brtvd->bv_mos_entries,\n\t    (uint64_t *)&bre->bre_offset, BRT_KEY_WORDS, tx);\n\tBRT_DEBUG(\"ZAP remove: object=%llu vdev=%llu offset=%llu count=%llu \"\n\t    \"error=%d\", (u_longlong_t)brtvd->bv_mos_entries,\n\t    (u_longlong_t)brtvd->bv_vdevid, (u_longlong_t)bre->bre_offset,\n\t    (u_longlong_t)bre->bre_refcount, error);\n\n\treturn (error);\n}\n\n \nboolean_t\nbrt_maybe_exists(spa_t *spa, const blkptr_t *bp)\n{\n\tbrt_t *brt = spa->spa_brt;\n\tbrt_vdev_t *brtvd;\n\tbrt_entry_t bre_search;\n\tboolean_t mayexists = FALSE;\n\tuint64_t vdevid;\n\n\tbrt_entry_fill(bp, &bre_search, &vdevid);\n\n\tbrt_rlock(brt);\n\n\tbrtvd = brt_vdev(brt, vdevid);\n\tif (brtvd != NULL && brtvd->bv_initiated) {\n\t\tif (!avl_is_empty(&brtvd->bv_tree) ||\n\t\t    brt_vdev_lookup(brt, brtvd, &bre_search)) {\n\t\t\tmayexists = TRUE;\n\t\t}\n\t}\n\n\tbrt_unlock(brt);\n\n\treturn (mayexists);\n}\n\nuint64_t\nbrt_get_dspace(spa_t *spa)\n{\n\tbrt_t *brt = spa->spa_brt;\n\n\tif (brt == NULL)\n\t\treturn (0);\n\n\treturn (brt->brt_savedspace);\n}\n\nuint64_t\nbrt_get_used(spa_t *spa)\n{\n\tbrt_t *brt = spa->spa_brt;\n\n\tif (brt == NULL)\n\t\treturn (0);\n\n\treturn (brt->brt_usedspace);\n}\n\nuint64_t\nbrt_get_saved(spa_t *spa)\n{\n\tbrt_t *brt = spa->spa_brt;\n\n\tif (brt == NULL)\n\t\treturn (0);\n\n\treturn (brt->brt_savedspace);\n}\n\nuint64_t\nbrt_get_ratio(spa_t *spa)\n{\n\tbrt_t *brt = spa->spa_brt;\n\n\tif (brt->brt_usedspace == 0)\n\t\treturn (100);\n\n\treturn ((brt->brt_usedspace + brt->brt_savedspace) * 100 /\n\t    brt->brt_usedspace);\n}\n\nstatic int\nbrt_kstats_update(kstat_t *ksp, int rw)\n{\n\tbrt_stats_t *bs = ksp->ks_data;\n\n\tif (rw == KSTAT_WRITE)\n\t\treturn (EACCES);\n\n\tbs->brt_addref_entry_in_memory.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_addref_entry_in_memory);\n\tbs->brt_addref_entry_not_on_disk.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_addref_entry_not_on_disk);\n\tbs->brt_addref_entry_on_disk.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_addref_entry_on_disk);\n\tbs->brt_addref_entry_read_lost_race.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_addref_entry_read_lost_race);\n\tbs->brt_decref_entry_in_memory.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_entry_in_memory);\n\tbs->brt_decref_entry_loaded_from_disk.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_entry_loaded_from_disk);\n\tbs->brt_decref_entry_not_in_memory.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_entry_not_in_memory);\n\tbs->brt_decref_entry_not_on_disk.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_entry_not_on_disk);\n\tbs->brt_decref_entry_read_lost_race.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_entry_read_lost_race);\n\tbs->brt_decref_entry_still_referenced.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_entry_still_referenced);\n\tbs->brt_decref_free_data_later.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_free_data_later);\n\tbs->brt_decref_free_data_now.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_free_data_now);\n\tbs->brt_decref_no_entry.value.ui64 =\n\t    wmsum_value(&brt_sums.brt_decref_no_entry);\n\n\treturn (0);\n}\n\nstatic void\nbrt_stat_init(void)\n{\n\n\twmsum_init(&brt_sums.brt_addref_entry_in_memory, 0);\n\twmsum_init(&brt_sums.brt_addref_entry_not_on_disk, 0);\n\twmsum_init(&brt_sums.brt_addref_entry_on_disk, 0);\n\twmsum_init(&brt_sums.brt_addref_entry_read_lost_race, 0);\n\twmsum_init(&brt_sums.brt_decref_entry_in_memory, 0);\n\twmsum_init(&brt_sums.brt_decref_entry_loaded_from_disk, 0);\n\twmsum_init(&brt_sums.brt_decref_entry_not_in_memory, 0);\n\twmsum_init(&brt_sums.brt_decref_entry_not_on_disk, 0);\n\twmsum_init(&brt_sums.brt_decref_entry_read_lost_race, 0);\n\twmsum_init(&brt_sums.brt_decref_entry_still_referenced, 0);\n\twmsum_init(&brt_sums.brt_decref_free_data_later, 0);\n\twmsum_init(&brt_sums.brt_decref_free_data_now, 0);\n\twmsum_init(&brt_sums.brt_decref_no_entry, 0);\n\n\tbrt_ksp = kstat_create(\"zfs\", 0, \"brtstats\", \"misc\", KSTAT_TYPE_NAMED,\n\t    sizeof (brt_stats) / sizeof (kstat_named_t), KSTAT_FLAG_VIRTUAL);\n\tif (brt_ksp != NULL) {\n\t\tbrt_ksp->ks_data = &brt_stats;\n\t\tbrt_ksp->ks_update = brt_kstats_update;\n\t\tkstat_install(brt_ksp);\n\t}\n}\n\nstatic void\nbrt_stat_fini(void)\n{\n\tif (brt_ksp != NULL) {\n\t\tkstat_delete(brt_ksp);\n\t\tbrt_ksp = NULL;\n\t}\n\n\twmsum_fini(&brt_sums.brt_addref_entry_in_memory);\n\twmsum_fini(&brt_sums.brt_addref_entry_not_on_disk);\n\twmsum_fini(&brt_sums.brt_addref_entry_on_disk);\n\twmsum_fini(&brt_sums.brt_addref_entry_read_lost_race);\n\twmsum_fini(&brt_sums.brt_decref_entry_in_memory);\n\twmsum_fini(&brt_sums.brt_decref_entry_loaded_from_disk);\n\twmsum_fini(&brt_sums.brt_decref_entry_not_in_memory);\n\twmsum_fini(&brt_sums.brt_decref_entry_not_on_disk);\n\twmsum_fini(&brt_sums.brt_decref_entry_read_lost_race);\n\twmsum_fini(&brt_sums.brt_decref_entry_still_referenced);\n\twmsum_fini(&brt_sums.brt_decref_free_data_later);\n\twmsum_fini(&brt_sums.brt_decref_free_data_now);\n\twmsum_fini(&brt_sums.brt_decref_no_entry);\n}\n\nvoid\nbrt_init(void)\n{\n\tbrt_entry_cache = kmem_cache_create(\"brt_entry_cache\",\n\t    sizeof (brt_entry_t), 0, NULL, NULL, NULL, NULL, NULL, 0);\n\tbrt_pending_entry_cache = kmem_cache_create(\"brt_pending_entry_cache\",\n\t    sizeof (brt_pending_entry_t), 0, NULL, NULL, NULL, NULL, NULL, 0);\n\n\tbrt_stat_init();\n}\n\nvoid\nbrt_fini(void)\n{\n\tbrt_stat_fini();\n\n\tkmem_cache_destroy(brt_entry_cache);\n\tkmem_cache_destroy(brt_pending_entry_cache);\n}\n\nstatic brt_entry_t *\nbrt_entry_alloc(const brt_entry_t *bre_init)\n{\n\tbrt_entry_t *bre;\n\n\tbre = kmem_cache_alloc(brt_entry_cache, KM_SLEEP);\n\tbre->bre_offset = bre_init->bre_offset;\n\tbre->bre_refcount = bre_init->bre_refcount;\n\n\treturn (bre);\n}\n\nstatic void\nbrt_entry_free(brt_entry_t *bre)\n{\n\n\tkmem_cache_free(brt_entry_cache, bre);\n}\n\nstatic void\nbrt_entry_addref(brt_t *brt, const blkptr_t *bp)\n{\n\tbrt_vdev_t *brtvd;\n\tbrt_entry_t *bre, *racebre;\n\tbrt_entry_t bre_search;\n\tavl_index_t where;\n\tuint64_t vdevid;\n\tint error;\n\n\tASSERT(!RW_WRITE_HELD(&brt->brt_lock));\n\n\tbrt_entry_fill(bp, &bre_search, &vdevid);\n\n\tbrt_wlock(brt);\n\n\tbrtvd = brt_vdev(brt, vdevid);\n\tif (brtvd == NULL) {\n\t\tASSERT3U(vdevid, >=, brt->brt_nvdevs);\n\n\t\t \n\t\tbrt_vdevs_expand(brt, vdevid + 1);\n\t\tbrtvd = brt_vdev(brt, vdevid);\n\t}\n\tASSERT(brtvd != NULL);\n\tif (!brtvd->bv_initiated)\n\t\tbrt_vdev_realloc(brt, brtvd);\n\n\tbre = avl_find(&brtvd->bv_tree, &bre_search, NULL);\n\tif (bre != NULL) {\n\t\tBRTSTAT_BUMP(brt_addref_entry_in_memory);\n\t} else {\n\t\t \n\t\terror = brt_entry_lookup(brt, brtvd, &bre_search);\n\t\t \n\t\tASSERT(error == 0 || error == ENOENT);\n\t\tif (error == 0)\n\t\t\tBRTSTAT_BUMP(brt_addref_entry_on_disk);\n\t\telse\n\t\t\tBRTSTAT_BUMP(brt_addref_entry_not_on_disk);\n\t\t \n\t\tbrtvd = brt_vdev(brt, vdevid);\n\t\tASSERT(brtvd != NULL);\n\n\t\tracebre = avl_find(&brtvd->bv_tree, &bre_search, &where);\n\t\tif (racebre == NULL) {\n\t\t\tbre = brt_entry_alloc(&bre_search);\n\t\t\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\t\t\tavl_insert(&brtvd->bv_tree, bre, where);\n\t\t\tbrt->brt_nentries++;\n\t\t} else {\n\t\t\t \n\t\t\tBRTSTAT_BUMP(brt_addref_entry_read_lost_race);\n\t\t\tbre = racebre;\n\t\t}\n\t}\n\tbre->bre_refcount++;\n\tbrt_vdev_addref(brt, brtvd, bre, bp_get_dsize(brt->brt_spa, bp));\n\n\tbrt_unlock(brt);\n}\n\n \nboolean_t\nbrt_entry_decref(spa_t *spa, const blkptr_t *bp)\n{\n\tbrt_t *brt = spa->spa_brt;\n\tbrt_vdev_t *brtvd;\n\tbrt_entry_t *bre, *racebre;\n\tbrt_entry_t bre_search;\n\tavl_index_t where;\n\tuint64_t vdevid;\n\tint error;\n\n\tbrt_entry_fill(bp, &bre_search, &vdevid);\n\n\tbrt_wlock(brt);\n\n\tbrtvd = brt_vdev(brt, vdevid);\n\tASSERT(brtvd != NULL);\n\n\tbre = avl_find(&brtvd->bv_tree, &bre_search, NULL);\n\tif (bre != NULL) {\n\t\tBRTSTAT_BUMP(brt_decref_entry_in_memory);\n\t\tgoto out;\n\t} else {\n\t\tBRTSTAT_BUMP(brt_decref_entry_not_in_memory);\n\t}\n\n\t \n\terror = brt_entry_lookup(brt, brtvd, &bre_search);\n\t \n\tASSERT(error == 0 || error == ENOENT);\n\t \n\tbrtvd = brt_vdev(brt, vdevid);\n\tASSERT(brtvd != NULL);\n\n\tif (error == ENOENT) {\n\t\tBRTSTAT_BUMP(brt_decref_entry_not_on_disk);\n\t\tbre = NULL;\n\t\tgoto out;\n\t}\n\n\tracebre = avl_find(&brtvd->bv_tree, &bre_search, &where);\n\tif (racebre != NULL) {\n\t\t \n\t\tBRTSTAT_BUMP(brt_decref_entry_read_lost_race);\n\t\tbre = racebre;\n\t\tgoto out;\n\t}\n\n\tBRTSTAT_BUMP(brt_decref_entry_loaded_from_disk);\n\tbre = brt_entry_alloc(&bre_search);\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tavl_insert(&brtvd->bv_tree, bre, where);\n\tbrt->brt_nentries++;\n\nout:\n\tif (bre == NULL) {\n\t\t \n\t\tbrt_unlock(brt);\n\t\tBRTSTAT_BUMP(brt_decref_no_entry);\n\t\treturn (B_TRUE);\n\t}\n\tif (bre->bre_refcount == 0) {\n\t\tbrt_unlock(brt);\n\t\tBRTSTAT_BUMP(brt_decref_free_data_now);\n\t\treturn (B_TRUE);\n\t}\n\n\tASSERT(bre->bre_refcount > 0);\n\tbre->bre_refcount--;\n\tif (bre->bre_refcount == 0)\n\t\tBRTSTAT_BUMP(brt_decref_free_data_later);\n\telse\n\t\tBRTSTAT_BUMP(brt_decref_entry_still_referenced);\n\tbrt_vdev_decref(brt, brtvd, bre, bp_get_dsize(brt->brt_spa, bp));\n\n\tbrt_unlock(brt);\n\n\treturn (B_FALSE);\n}\n\nuint64_t\nbrt_entry_get_refcount(spa_t *spa, const blkptr_t *bp)\n{\n\tbrt_t *brt = spa->spa_brt;\n\tbrt_vdev_t *brtvd;\n\tbrt_entry_t bre_search, *bre;\n\tuint64_t vdevid, refcnt;\n\tint error;\n\n\tbrt_entry_fill(bp, &bre_search, &vdevid);\n\n\tbrt_rlock(brt);\n\n\tbrtvd = brt_vdev(brt, vdevid);\n\tASSERT(brtvd != NULL);\n\n\tbre = avl_find(&brtvd->bv_tree, &bre_search, NULL);\n\tif (bre == NULL) {\n\t\terror = brt_entry_lookup(brt, brtvd, &bre_search);\n\t\tASSERT(error == 0 || error == ENOENT);\n\t\tif (error == ENOENT)\n\t\t\trefcnt = 0;\n\t\telse\n\t\t\trefcnt = bre_search.bre_refcount;\n\t} else\n\t\trefcnt = bre->bre_refcount;\n\n\tbrt_unlock(brt);\n\treturn (refcnt);\n}\n\nstatic void\nbrt_prefetch(brt_t *brt, const blkptr_t *bp)\n{\n\tbrt_entry_t bre;\n\tuint64_t vdevid;\n\n\tASSERT(bp != NULL);\n\n\tif (!zfs_brt_prefetch)\n\t\treturn;\n\n\tbrt_entry_fill(bp, &bre, &vdevid);\n\n\tbrt_entry_prefetch(brt, vdevid, &bre);\n}\n\nstatic int\nbrt_pending_entry_compare(const void *x1, const void *x2)\n{\n\tconst brt_pending_entry_t *bpe1 = x1, *bpe2 = x2;\n\tconst blkptr_t *bp1 = &bpe1->bpe_bp, *bp2 = &bpe2->bpe_bp;\n\tint cmp;\n\n\tcmp = TREE_CMP(BP_PHYSICAL_BIRTH(bp1), BP_PHYSICAL_BIRTH(bp2));\n\tif (cmp == 0) {\n\t\tcmp = TREE_CMP(DVA_GET_VDEV(&bp1->blk_dva[0]),\n\t\t    DVA_GET_VDEV(&bp2->blk_dva[0]));\n\t\tif (cmp == 0) {\n\t\t\tcmp = TREE_CMP(DVA_GET_OFFSET(&bp1->blk_dva[0]),\n\t\t\t    DVA_GET_OFFSET(&bp2->blk_dva[0]));\n\t\t}\n\t}\n\n\treturn (cmp);\n}\n\nvoid\nbrt_pending_add(spa_t *spa, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\tbrt_t *brt;\n\tavl_tree_t *pending_tree;\n\tkmutex_t *pending_lock;\n\tbrt_pending_entry_t *bpe, *newbpe;\n\tavl_index_t where;\n\tuint64_t txg;\n\n\tbrt = spa->spa_brt;\n\ttxg = dmu_tx_get_txg(tx);\n\tASSERT3U(txg, !=, 0);\n\tpending_tree = &brt->brt_pending_tree[txg & TXG_MASK];\n\tpending_lock = &brt->brt_pending_lock[txg & TXG_MASK];\n\n\tnewbpe = kmem_cache_alloc(brt_pending_entry_cache, KM_SLEEP);\n\tnewbpe->bpe_bp = *bp;\n\tnewbpe->bpe_count = 1;\n\n\tmutex_enter(pending_lock);\n\n\tbpe = avl_find(pending_tree, newbpe, &where);\n\tif (bpe == NULL) {\n\t\tavl_insert(pending_tree, newbpe, where);\n\t\tnewbpe = NULL;\n\t} else {\n\t\tbpe->bpe_count++;\n\t}\n\n\tmutex_exit(pending_lock);\n\n\tif (newbpe != NULL) {\n\t\tASSERT(bpe != NULL);\n\t\tASSERT(bpe != newbpe);\n\t\tkmem_cache_free(brt_pending_entry_cache, newbpe);\n\t} else {\n\t\tASSERT(bpe == NULL);\n\t}\n\n\t \n\tbrt_prefetch(brt, bp);\n}\n\nvoid\nbrt_pending_remove(spa_t *spa, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\tbrt_t *brt;\n\tavl_tree_t *pending_tree;\n\tkmutex_t *pending_lock;\n\tbrt_pending_entry_t *bpe, bpe_search;\n\tuint64_t txg;\n\n\tbrt = spa->spa_brt;\n\ttxg = dmu_tx_get_txg(tx);\n\tASSERT3U(txg, !=, 0);\n\tpending_tree = &brt->brt_pending_tree[txg & TXG_MASK];\n\tpending_lock = &brt->brt_pending_lock[txg & TXG_MASK];\n\n\tbpe_search.bpe_bp = *bp;\n\n\tmutex_enter(pending_lock);\n\n\tbpe = avl_find(pending_tree, &bpe_search, NULL);\n\t \n\tif (bpe != NULL) {\n\t\tASSERT(bpe->bpe_count > 0);\n\n\t\tbpe->bpe_count--;\n\t\tif (bpe->bpe_count == 0) {\n\t\t\tavl_remove(pending_tree, bpe);\n\t\t\tkmem_cache_free(brt_pending_entry_cache, bpe);\n\t\t}\n\t}\n\n\tmutex_exit(pending_lock);\n}\n\nvoid\nbrt_pending_apply(spa_t *spa, uint64_t txg)\n{\n\tbrt_t *brt;\n\tbrt_pending_entry_t *bpe;\n\tavl_tree_t *pending_tree;\n\tkmutex_t *pending_lock;\n\tvoid *c;\n\n\tASSERT3U(txg, !=, 0);\n\n\tbrt = spa->spa_brt;\n\tpending_tree = &brt->brt_pending_tree[txg & TXG_MASK];\n\tpending_lock = &brt->brt_pending_lock[txg & TXG_MASK];\n\n\tmutex_enter(pending_lock);\n\n\tc = NULL;\n\twhile ((bpe = avl_destroy_nodes(pending_tree, &c)) != NULL) {\n\t\tboolean_t added_to_ddt;\n\n\t\tmutex_exit(pending_lock);\n\n\t\tfor (int i = 0; i < bpe->bpe_count; i++) {\n\t\t\t \n\t\t\tif (BP_GET_DEDUP(&bpe->bpe_bp)) {\n\t\t\t\tadded_to_ddt = ddt_addref(spa, &bpe->bpe_bp);\n\t\t\t} else {\n\t\t\t\tadded_to_ddt = B_FALSE;\n\t\t\t}\n\t\t\tif (!added_to_ddt)\n\t\t\t\tbrt_entry_addref(brt, &bpe->bpe_bp);\n\t\t}\n\n\t\tkmem_cache_free(brt_pending_entry_cache, bpe);\n\t\tmutex_enter(pending_lock);\n\t}\n\n\tmutex_exit(pending_lock);\n}\n\nstatic void\nbrt_sync_entry(brt_t *brt, brt_vdev_t *brtvd, brt_entry_t *bre, dmu_tx_t *tx)\n{\n\n\tASSERT(RW_WRITE_HELD(&brt->brt_lock));\n\tASSERT(brtvd->bv_mos_entries != 0);\n\n\tif (bre->bre_refcount == 0) {\n\t\tint error;\n\n\t\terror = brt_entry_remove(brt, brtvd, bre, tx);\n\t\tASSERT(error == 0 || error == ENOENT);\n\t\t \n\t\tASSERT(brt_entry_lookup(brt, brtvd, bre) == ENOENT);\n\t} else {\n\t\tVERIFY0(brt_entry_update(brt, brtvd, bre, tx));\n\t}\n}\n\nstatic void\nbrt_sync_table(brt_t *brt, dmu_tx_t *tx)\n{\n\tbrt_vdev_t *brtvd;\n\tbrt_entry_t *bre;\n\tuint64_t vdevid;\n\tvoid *c;\n\n\tbrt_wlock(brt);\n\n\tfor (vdevid = 0; vdevid < brt->brt_nvdevs; vdevid++) {\n\t\tbrtvd = &brt->brt_vdevs[vdevid];\n\n\t\tif (!brtvd->bv_initiated)\n\t\t\tcontinue;\n\n\t\tif (!brtvd->bv_meta_dirty) {\n\t\t\tASSERT(!brtvd->bv_entcount_dirty);\n\t\t\tASSERT0(avl_numnodes(&brtvd->bv_tree));\n\t\t\tcontinue;\n\t\t}\n\n\t\tASSERT(!brtvd->bv_entcount_dirty ||\n\t\t    avl_numnodes(&brtvd->bv_tree) != 0);\n\n\t\tif (brtvd->bv_mos_brtvdev == 0)\n\t\t\tbrt_vdev_create(brt, brtvd, tx);\n\n\t\tc = NULL;\n\t\twhile ((bre = avl_destroy_nodes(&brtvd->bv_tree, &c)) != NULL) {\n\t\t\tbrt_sync_entry(brt, brtvd, bre, tx);\n\t\t\tbrt_entry_free(bre);\n\t\t\tASSERT(brt->brt_nentries > 0);\n\t\t\tbrt->brt_nentries--;\n\t\t}\n\n\t\tbrt_vdev_sync(brt, brtvd, tx);\n\n\t\tif (brtvd->bv_totalcount == 0)\n\t\t\tbrt_vdev_destroy(brt, brtvd, tx);\n\t}\n\n\tASSERT0(brt->brt_nentries);\n\n\tbrt_unlock(brt);\n}\n\nvoid\nbrt_sync(spa_t *spa, uint64_t txg)\n{\n\tdmu_tx_t *tx;\n\tbrt_t *brt;\n\n\tASSERT(spa_syncing_txg(spa) == txg);\n\n\tbrt = spa->spa_brt;\n\tbrt_rlock(brt);\n\tif (brt->brt_nentries == 0) {\n\t\t \n\t\tbrt_unlock(brt);\n\t\treturn;\n\t}\n\tbrt_unlock(brt);\n\n\ttx = dmu_tx_create_assigned(spa->spa_dsl_pool, txg);\n\n\tbrt_sync_table(brt, tx);\n\n\tdmu_tx_commit(tx);\n}\n\nstatic void\nbrt_table_alloc(brt_t *brt)\n{\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tavl_create(&brt->brt_pending_tree[i],\n\t\t    brt_pending_entry_compare,\n\t\t    sizeof (brt_pending_entry_t),\n\t\t    offsetof(brt_pending_entry_t, bpe_node));\n\t\tmutex_init(&brt->brt_pending_lock[i], NULL, MUTEX_DEFAULT,\n\t\t    NULL);\n\t}\n}\n\nstatic void\nbrt_table_free(brt_t *brt)\n{\n\n\tfor (int i = 0; i < TXG_SIZE; i++) {\n\t\tASSERT(avl_is_empty(&brt->brt_pending_tree[i]));\n\n\t\tavl_destroy(&brt->brt_pending_tree[i]);\n\t\tmutex_destroy(&brt->brt_pending_lock[i]);\n\t}\n}\n\nstatic void\nbrt_alloc(spa_t *spa)\n{\n\tbrt_t *brt;\n\n\tASSERT(spa->spa_brt == NULL);\n\n\tbrt = kmem_zalloc(sizeof (*brt), KM_SLEEP);\n\trw_init(&brt->brt_lock, NULL, RW_DEFAULT, NULL);\n\tbrt->brt_spa = spa;\n\tbrt->brt_rangesize = 0;\n\tbrt->brt_nentries = 0;\n\tbrt->brt_vdevs = NULL;\n\tbrt->brt_nvdevs = 0;\n\tbrt_table_alloc(brt);\n\n\tspa->spa_brt = brt;\n}\n\nvoid\nbrt_create(spa_t *spa)\n{\n\n\tbrt_alloc(spa);\n\tbrt_vdevs_alloc(spa->spa_brt, B_FALSE);\n}\n\nint\nbrt_load(spa_t *spa)\n{\n\n\tbrt_alloc(spa);\n\tbrt_vdevs_alloc(spa->spa_brt, B_TRUE);\n\n\treturn (0);\n}\n\nvoid\nbrt_unload(spa_t *spa)\n{\n\tbrt_t *brt = spa->spa_brt;\n\n\tif (brt == NULL)\n\t\treturn;\n\n\tbrt_vdevs_free(brt);\n\tbrt_table_free(brt);\n\trw_destroy(&brt->brt_lock);\n\tkmem_free(brt, sizeof (*brt));\n\tspa->spa_brt = NULL;\n}\n\n \nZFS_MODULE_PARAM(zfs_brt, zfs_brt_, prefetch, INT, ZMOD_RW,\n    \"Enable prefetching of BRT entries\");\n#ifdef ZFS_BRT_DEBUG\nZFS_MODULE_PARAM(zfs_brt, zfs_brt_, debug, INT, ZMOD_RW, \"BRT debug\");\n#endif\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}