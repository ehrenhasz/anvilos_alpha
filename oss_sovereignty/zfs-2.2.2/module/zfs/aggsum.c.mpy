{
  "module_name": "aggsum.c",
  "hash_id": "eb9c46bc6b858c367ee08da80edfb628194e9489351c3072d15bda796c8698e1",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/aggsum.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/aggsum.h>\n\n \n\n \nstatic uint_t aggsum_borrow_shift = 4;\n\nvoid\naggsum_init(aggsum_t *as, uint64_t value)\n{\n\tmemset(as, 0, sizeof (*as));\n\tas->as_lower_bound = as->as_upper_bound = value;\n\tmutex_init(&as->as_lock, NULL, MUTEX_DEFAULT, NULL);\n\t \n\tas->as_bucketshift = highbit64(boot_ncpus / 6) / 2;\n\tas->as_numbuckets = ((boot_ncpus - 1) >> as->as_bucketshift) + 1;\n\tas->as_buckets = kmem_zalloc(as->as_numbuckets *\n\t    sizeof (aggsum_bucket_t), KM_SLEEP);\n\tfor (int i = 0; i < as->as_numbuckets; i++) {\n\t\tmutex_init(&as->as_buckets[i].asc_lock,\n\t\t    NULL, MUTEX_DEFAULT, NULL);\n\t}\n}\n\nvoid\naggsum_fini(aggsum_t *as)\n{\n\tfor (int i = 0; i < as->as_numbuckets; i++)\n\t\tmutex_destroy(&as->as_buckets[i].asc_lock);\n\tkmem_free(as->as_buckets, as->as_numbuckets * sizeof (aggsum_bucket_t));\n\tmutex_destroy(&as->as_lock);\n}\n\nint64_t\naggsum_lower_bound(aggsum_t *as)\n{\n\treturn (atomic_load_64((volatile uint64_t *)&as->as_lower_bound));\n}\n\nuint64_t\naggsum_upper_bound(aggsum_t *as)\n{\n\treturn (atomic_load_64(&as->as_upper_bound));\n}\n\nuint64_t\naggsum_value(aggsum_t *as)\n{\n\tint64_t lb;\n\tuint64_t ub;\n\n\tmutex_enter(&as->as_lock);\n\tlb = as->as_lower_bound;\n\tub = as->as_upper_bound;\n\tif (lb == ub) {\n\t\tfor (int i = 0; i < as->as_numbuckets; i++) {\n\t\t\tASSERT0(as->as_buckets[i].asc_delta);\n\t\t\tASSERT0(as->as_buckets[i].asc_borrowed);\n\t\t}\n\t\tmutex_exit(&as->as_lock);\n\t\treturn (lb);\n\t}\n\tfor (int i = 0; i < as->as_numbuckets; i++) {\n\t\tstruct aggsum_bucket *asb = &as->as_buckets[i];\n\t\tif (asb->asc_borrowed == 0)\n\t\t\tcontinue;\n\t\tmutex_enter(&asb->asc_lock);\n\t\tlb += asb->asc_delta + asb->asc_borrowed;\n\t\tub += asb->asc_delta - asb->asc_borrowed;\n\t\tasb->asc_delta = 0;\n\t\tasb->asc_borrowed = 0;\n\t\tmutex_exit(&asb->asc_lock);\n\t}\n\tASSERT3U(lb, ==, ub);\n\tatomic_store_64((volatile uint64_t *)&as->as_lower_bound, lb);\n\tatomic_store_64(&as->as_upper_bound, lb);\n\tmutex_exit(&as->as_lock);\n\n\treturn (lb);\n}\n\nvoid\naggsum_add(aggsum_t *as, int64_t delta)\n{\n\tstruct aggsum_bucket *asb;\n\tint64_t borrow;\n\n\tasb = &as->as_buckets[(CPU_SEQID_UNSTABLE >> as->as_bucketshift) %\n\t    as->as_numbuckets];\n\n\t \n\tmutex_enter(&asb->asc_lock);\n\tif (asb->asc_delta + delta <= (int64_t)asb->asc_borrowed &&\n\t    asb->asc_delta + delta >= -(int64_t)asb->asc_borrowed) {\n\t\tasb->asc_delta += delta;\n\t\tmutex_exit(&asb->asc_lock);\n\t\treturn;\n\t}\n\tmutex_exit(&asb->asc_lock);\n\n\t \n\tborrow = (delta < 0 ? -delta : delta);\n\tborrow <<= aggsum_borrow_shift + as->as_bucketshift;\n\tmutex_enter(&as->as_lock);\n\tif (borrow >= asb->asc_borrowed)\n\t\tborrow -= asb->asc_borrowed;\n\telse\n\t\tborrow = (borrow - (int64_t)asb->asc_borrowed) / 4;\n\tmutex_enter(&asb->asc_lock);\n\tdelta += asb->asc_delta;\n\tasb->asc_delta = 0;\n\tasb->asc_borrowed += borrow;\n\tmutex_exit(&asb->asc_lock);\n\tatomic_store_64((volatile uint64_t *)&as->as_lower_bound,\n\t    as->as_lower_bound + delta - borrow);\n\tatomic_store_64(&as->as_upper_bound,\n\t    as->as_upper_bound + delta + borrow);\n\tmutex_exit(&as->as_lock);\n}\n\n \nint\naggsum_compare(aggsum_t *as, uint64_t target)\n{\n\tint64_t lb;\n\tuint64_t ub;\n\tint i;\n\n\tif (atomic_load_64(&as->as_upper_bound) < target)\n\t\treturn (-1);\n\tlb = atomic_load_64((volatile uint64_t *)&as->as_lower_bound);\n\tif (lb > 0 && (uint64_t)lb > target)\n\t\treturn (1);\n\tmutex_enter(&as->as_lock);\n\tlb = as->as_lower_bound;\n\tub = as->as_upper_bound;\n\tfor (i = 0; i < as->as_numbuckets; i++) {\n\t\tstruct aggsum_bucket *asb = &as->as_buckets[i];\n\t\tif (asb->asc_borrowed == 0)\n\t\t\tcontinue;\n\t\tmutex_enter(&asb->asc_lock);\n\t\tlb += asb->asc_delta + asb->asc_borrowed;\n\t\tub += asb->asc_delta - asb->asc_borrowed;\n\t\tasb->asc_delta = 0;\n\t\tasb->asc_borrowed = 0;\n\t\tmutex_exit(&asb->asc_lock);\n\t\tif (ub < target || (lb > 0 && (uint64_t)lb > target))\n\t\t\tbreak;\n\t}\n\tif (i >= as->as_numbuckets)\n\t\tASSERT3U(lb, ==, ub);\n\tatomic_store_64((volatile uint64_t *)&as->as_lower_bound, lb);\n\tatomic_store_64(&as->as_upper_bound, ub);\n\tmutex_exit(&as->as_lock);\n\treturn (ub < target ? -1 : (uint64_t)lb > target ? 1 : 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}