{
  "module_name": "dsl_bookmark.c",
  "hash_id": "f4ef3065dec4a04e4b8fd66886a6a1170d06e5f49cb970c1908cab824b92a5cc",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_bookmark.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/arc.h>\n#include <sys/zap.h>\n#include <sys/zfeature.h>\n#include <sys/spa.h>\n#include <sys/dsl_bookmark.h>\n#include <zfs_namecheck.h>\n#include <sys/dmu_send.h>\n\nstatic int\ndsl_bookmark_hold_ds(dsl_pool_t *dp, const char *fullname,\n    dsl_dataset_t **dsp, const void *tag, char **shortnamep)\n{\n\tchar buf[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *hashp;\n\n\tif (strlen(fullname) >= ZFS_MAX_DATASET_NAME_LEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\thashp = strchr(fullname, '#');\n\tif (hashp == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t*shortnamep = hashp + 1;\n\tif (zfs_component_namecheck(*shortnamep, NULL, NULL))\n\t\treturn (SET_ERROR(EINVAL));\n\t(void) strlcpy(buf, fullname, hashp - fullname + 1);\n\treturn (dsl_dataset_hold(dp, buf, tag, dsp));\n}\n\n \nint\ndsl_bookmark_lookup_impl(dsl_dataset_t *ds, const char *shortname,\n    zfs_bookmark_phys_t *bmark_phys)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tuint64_t bmark_zapobj = ds->ds_bookmarks_obj;\n\tmatchtype_t mt = 0;\n\tint err;\n\n\tif (bmark_zapobj == 0)\n\t\treturn (SET_ERROR(ESRCH));\n\n\tif (dsl_dataset_phys(ds)->ds_flags & DS_FLAG_CI_DATASET)\n\t\tmt = MT_NORMALIZE;\n\n\t \n\tmemset(bmark_phys, 0, sizeof (*bmark_phys));\n\n\terr = zap_lookup_norm(mos, bmark_zapobj, shortname, sizeof (uint64_t),\n\t    sizeof (*bmark_phys) / sizeof (uint64_t), bmark_phys, mt, NULL, 0,\n\t    NULL);\n\n\treturn (err == ENOENT ? SET_ERROR(ESRCH) : err);\n}\n\n \nint\ndsl_bookmark_lookup(dsl_pool_t *dp, const char *fullname,\n    dsl_dataset_t *later_ds, zfs_bookmark_phys_t *bmp)\n{\n\tchar *shortname;\n\tdsl_dataset_t *ds;\n\tint error;\n\n\terror = dsl_bookmark_hold_ds(dp, fullname, &ds, FTAG, &shortname);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_bookmark_lookup_impl(ds, shortname, bmp);\n\tif (error == 0 && later_ds != NULL) {\n\t\tif (!dsl_dataset_is_before(later_ds, ds, bmp->zbm_creation_txg))\n\t\t\terror = SET_ERROR(EXDEV);\n\t}\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (error);\n}\n\n \nstatic int\ndsl_bookmark_create_nvl_validate_pair(const char *bmark, const char *source)\n{\n\tif (bookmark_namecheck(bmark, NULL, NULL) != 0)\n\t\treturn (-1);\n\n\tint is_bmark, is_snap;\n\tis_bmark = bookmark_namecheck(source, NULL, NULL) == 0;\n\tis_snap = snapshot_namecheck(source, NULL, NULL) == 0;\n\tif (!is_bmark && !is_snap)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n \nint\ndsl_bookmark_create_nvl_validate(nvlist_t *bmarks)\n{\n\tconst char *first = NULL;\n\tsize_t first_len = 0;\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(bmarks, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(bmarks, pair)) {\n\n\t\tconst char *bmark = nvpair_name(pair);\n\t\tconst char *source;\n\n\t\t \n\t\tif (nvpair_value_string(pair, &source) != 0)\n\t\t\treturn (-1);\n\t\tif (dsl_bookmark_create_nvl_validate_pair(bmark, source) != 0)\n\t\t\treturn (-1);\n\n\t\t \n\t\tif (first == NULL) {\n\t\t\tconst char *cp = strpbrk(bmark, \"/#\");\n\t\t\tif (cp == NULL)\n\t\t\t\treturn (-1);\n\t\t\tfirst = bmark;\n\t\t\tfirst_len = cp - bmark;\n\t\t}\n\t\tif (strncmp(first, bmark, first_len) != 0)\n\t\t\treturn (-1);\n\t\tswitch (*(bmark + first_len)) {\n\t\t\tcase '/':  \n\t\t\tcase '#':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\tfor (nvpair_t *pair2 = nvlist_next_nvpair(bmarks, pair);\n\t\t    pair2 != NULL; pair2 = nvlist_next_nvpair(bmarks, pair2)) {\n\t\t\tif (strcmp(nvpair_name(pair), nvpair_name(pair2)) == 0)\n\t\t\t\treturn (-1);\n\t\t}\n\n\t}\n\treturn (0);\n}\n\n \nstatic int\ndsl_bookmark_create_check_impl(dsl_pool_t *dp,\n    const char *newbm, const char *source)\n{\n\tASSERT0(dsl_bookmark_create_nvl_validate_pair(newbm, source));\n\t \n\n\tint error;\n\tdsl_dataset_t *newbm_ds;\n\tchar *newbm_short;\n\tzfs_bookmark_phys_t bmark_phys;\n\n\terror = dsl_bookmark_hold_ds(dp, newbm, &newbm_ds, FTAG, &newbm_short);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\terror = dsl_bookmark_lookup_impl(newbm_ds, newbm_short, &bmark_phys);\n\tswitch (error) {\n\tcase ESRCH:\n\t\t \n\t\tbreak;\n\tcase 0:\n\t\terror = SET_ERROR(EEXIST);\n\t\tgoto eholdnewbmds;\n\tdefault:\n\t\t \n\t\tgoto eholdnewbmds;\n\t}\n\n\t \n\tif (strchr(source, '@') != NULL) {\n\t\tdsl_dataset_t *source_snap_ds;\n\t\tASSERT3S(snapshot_namecheck(source, NULL, NULL), ==, 0);\n\t\terror = dsl_dataset_hold(dp, source, FTAG, &source_snap_ds);\n\t\tif (error == 0) {\n\t\t\tVERIFY(source_snap_ds->ds_is_snapshot);\n\t\t\t \n\t\t\tif (!dsl_dataset_is_before(newbm_ds, source_snap_ds, 0))\n\t\t\t\terror = SET_ERROR(\n\t\t\t\t    ZFS_ERR_BOOKMARK_SOURCE_NOT_ANCESTOR);\n\t\t\tdsl_dataset_rele(source_snap_ds, FTAG);\n\t\t}\n\t} else if (strchr(source, '#') != NULL) {\n\t\tzfs_bookmark_phys_t source_phys;\n\t\tASSERT3S(bookmark_namecheck(source, NULL, NULL), ==, 0);\n\t\t \n\t\terror = dsl_bookmark_lookup(dp, source, newbm_ds, &source_phys);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;  \n\t\tcase EXDEV:\n\t\t\terror = SET_ERROR(ZFS_ERR_BOOKMARK_SOURCE_NOT_ANCESTOR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tpanic(\"unreachable code: %s\", source);\n\t}\n\neholdnewbmds:\n\tdsl_dataset_rele(newbm_ds, FTAG);\n\treturn (error);\n}\n\nint\ndsl_bookmark_create_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_bookmark_create_arg_t *dbca = arg;\n\tint rv = 0;\n\tint schema_err = 0;\n\tASSERT3P(dbca, !=, NULL);\n\tASSERT3P(dbca->dbca_bmarks, !=, NULL);\n\t \n\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_BOOKMARKS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (dsl_bookmark_create_nvl_validate(dbca->dbca_bmarks) != 0)\n\t\trv = schema_err = SET_ERROR(EINVAL);\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dbca->dbca_bmarks, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(dbca->dbca_bmarks, pair)) {\n\t\tconst char *new = nvpair_name(pair);\n\n\t\tint error = schema_err;\n\t\tif (error == 0) {\n\t\t\tconst char *source = fnvpair_value_string(pair);\n\t\t\terror = dsl_bookmark_create_check_impl(dp, new, source);\n\t\t\tif (error != 0)\n\t\t\t\terror = SET_ERROR(error);\n\t\t}\n\n\t\tif (error != 0) {\n\t\t\trv = error;\n\t\t\tif (dbca->dbca_errors != NULL)\n\t\t\t\tfnvlist_add_int32(dbca->dbca_errors,\n\t\t\t\t    new, error);\n\t\t}\n\t}\n\n\treturn (rv);\n}\n\nstatic dsl_bookmark_node_t *\ndsl_bookmark_node_alloc(char *shortname)\n{\n\tdsl_bookmark_node_t *dbn = kmem_alloc(sizeof (*dbn), KM_SLEEP);\n\tdbn->dbn_name = spa_strdup(shortname);\n\tdbn->dbn_dirty = B_FALSE;\n\tmutex_init(&dbn->dbn_lock, NULL, MUTEX_DEFAULT, NULL);\n\treturn (dbn);\n}\n\n \nstatic void\ndsl_bookmark_set_phys(zfs_bookmark_phys_t *zbm, dsl_dataset_t *snap)\n{\n\tspa_t *spa = dsl_dataset_get_spa(snap);\n\tobjset_t *mos = spa_get_dsl(spa)->dp_meta_objset;\n\tdsl_dataset_phys_t *dsp = dsl_dataset_phys(snap);\n\n\tmemset(zbm, 0, sizeof (zfs_bookmark_phys_t));\n\tzbm->zbm_guid = dsp->ds_guid;\n\tzbm->zbm_creation_txg = dsp->ds_creation_txg;\n\tzbm->zbm_creation_time = dsp->ds_creation_time;\n\tzbm->zbm_redaction_obj = 0;\n\n\t \n\tif (snap->ds_dir->dd_crypto_obj != 0 &&\n\t    spa_feature_is_enabled(spa, SPA_FEATURE_BOOKMARK_V2)) {\n\t\t(void) zap_lookup(mos, snap->ds_object,\n\t\t    DS_FIELD_IVSET_GUID, sizeof (uint64_t), 1,\n\t\t    &zbm->zbm_ivset_guid);\n\t}\n\n\tif (spa_feature_is_enabled(spa, SPA_FEATURE_BOOKMARK_WRITTEN)) {\n\t\tzbm->zbm_flags = ZBM_FLAG_SNAPSHOT_EXISTS | ZBM_FLAG_HAS_FBN;\n\t\tzbm->zbm_referenced_bytes_refd = dsp->ds_referenced_bytes;\n\t\tzbm->zbm_compressed_bytes_refd = dsp->ds_compressed_bytes;\n\t\tzbm->zbm_uncompressed_bytes_refd = dsp->ds_uncompressed_bytes;\n\n\t\tdsl_dataset_t *nextds;\n\t\tVERIFY0(dsl_dataset_hold_obj(snap->ds_dir->dd_pool,\n\t\t    dsp->ds_next_snap_obj, FTAG, &nextds));\n\t\tdsl_deadlist_space(&nextds->ds_deadlist,\n\t\t    &zbm->zbm_referenced_freed_before_next_snap,\n\t\t    &zbm->zbm_compressed_freed_before_next_snap,\n\t\t    &zbm->zbm_uncompressed_freed_before_next_snap);\n\t\tdsl_dataset_rele(nextds, FTAG);\n\t}\n}\n\n \nvoid\ndsl_bookmark_node_add(dsl_dataset_t *hds, dsl_bookmark_node_t *dbn,\n    dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tif (hds->ds_bookmarks_obj == 0) {\n\t\thds->ds_bookmarks_obj = zap_create_norm(mos,\n\t\t    U8_TEXTPREP_TOUPPER, DMU_OTN_ZAP_METADATA, DMU_OT_NONE, 0,\n\t\t    tx);\n\t\tspa_feature_incr(dp->dp_spa, SPA_FEATURE_BOOKMARKS, tx);\n\n\t\tdsl_dataset_zapify(hds, tx);\n\t\tVERIFY0(zap_add(mos, hds->ds_object,\n\t\t    DS_FIELD_BOOKMARK_NAMES,\n\t\t    sizeof (hds->ds_bookmarks_obj), 1,\n\t\t    &hds->ds_bookmarks_obj, tx));\n\t}\n\n\tavl_add(&hds->ds_bookmarks, dbn);\n\n\t \n\tuint64_t bookmark_phys_size = BOOKMARK_PHYS_SIZE_V1;\n\tif (spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_BOOKMARK_V2) &&\n\t    (dbn->dbn_phys.zbm_ivset_guid != 0 || dbn->dbn_phys.zbm_flags &\n\t    ZBM_FLAG_HAS_FBN || dbn->dbn_phys.zbm_redaction_obj != 0)) {\n\t\tbookmark_phys_size = BOOKMARK_PHYS_SIZE_V2;\n\t\tspa_feature_incr(dp->dp_spa, SPA_FEATURE_BOOKMARK_V2, tx);\n\t}\n\n\tzfs_bookmark_phys_t zero_phys = { 0 };\n\tASSERT0(memcmp(((char *)&dbn->dbn_phys) + bookmark_phys_size,\n\t    &zero_phys, sizeof (zfs_bookmark_phys_t) - bookmark_phys_size));\n\n\tVERIFY0(zap_add(mos, hds->ds_bookmarks_obj, dbn->dbn_name,\n\t    sizeof (uint64_t), bookmark_phys_size / sizeof (uint64_t),\n\t    &dbn->dbn_phys, tx));\n}\n\n \nstatic void\ndsl_bookmark_create_sync_impl_snap(const char *bookmark, const char *snapshot,\n    dmu_tx_t *tx, uint64_t num_redact_snaps, uint64_t *redact_snaps,\n    const void *tag, redaction_list_t **redaction_list)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdsl_dataset_t *snapds, *bmark_fs;\n\tchar *shortname;\n\tboolean_t bookmark_redacted;\n\tuint64_t *dsredactsnaps;\n\tuint64_t dsnumsnaps;\n\n\tVERIFY0(dsl_dataset_hold(dp, snapshot, FTAG, &snapds));\n\tVERIFY0(dsl_bookmark_hold_ds(dp, bookmark, &bmark_fs, FTAG,\n\t    &shortname));\n\n\tdsl_bookmark_node_t *dbn = dsl_bookmark_node_alloc(shortname);\n\tdsl_bookmark_set_phys(&dbn->dbn_phys, snapds);\n\n\tbookmark_redacted = dsl_dataset_get_uint64_array_feature(snapds,\n\t    SPA_FEATURE_REDACTED_DATASETS, &dsnumsnaps, &dsredactsnaps);\n\tif (redaction_list != NULL || bookmark_redacted) {\n\t\tredaction_list_t *local_rl;\n\t\tif (bookmark_redacted) {\n\t\t\tredact_snaps = dsredactsnaps;\n\t\t\tnum_redact_snaps = dsnumsnaps;\n\t\t}\n\t\tdbn->dbn_phys.zbm_redaction_obj = dmu_object_alloc(mos,\n\t\t    DMU_OTN_UINT64_METADATA, SPA_OLD_MAXBLOCKSIZE,\n\t\t    DMU_OTN_UINT64_METADATA, sizeof (redaction_list_phys_t) +\n\t\t    num_redact_snaps * sizeof (uint64_t), tx);\n\t\tspa_feature_incr(dp->dp_spa,\n\t\t    SPA_FEATURE_REDACTION_BOOKMARKS, tx);\n\n\t\tVERIFY0(dsl_redaction_list_hold_obj(dp,\n\t\t    dbn->dbn_phys.zbm_redaction_obj, tag, &local_rl));\n\t\tdsl_redaction_list_long_hold(dp, local_rl, tag);\n\n\t\tASSERT3U((local_rl)->rl_dbuf->db_size, >=,\n\t\t    sizeof (redaction_list_phys_t) + num_redact_snaps *\n\t\t    sizeof (uint64_t));\n\t\tdmu_buf_will_dirty(local_rl->rl_dbuf, tx);\n\t\tmemcpy(local_rl->rl_phys->rlp_snaps, redact_snaps,\n\t\t    sizeof (uint64_t) * num_redact_snaps);\n\t\tlocal_rl->rl_phys->rlp_num_snaps = num_redact_snaps;\n\t\tif (bookmark_redacted) {\n\t\t\tASSERT3P(redaction_list, ==, NULL);\n\t\t\tlocal_rl->rl_phys->rlp_last_blkid = UINT64_MAX;\n\t\t\tlocal_rl->rl_phys->rlp_last_object = UINT64_MAX;\n\t\t\tdsl_redaction_list_long_rele(local_rl, tag);\n\t\t\tdsl_redaction_list_rele(local_rl, tag);\n\t\t} else {\n\t\t\t*redaction_list = local_rl;\n\t\t}\n\t}\n\n\tif (dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN) {\n\t\tspa_feature_incr(dp->dp_spa,\n\t\t    SPA_FEATURE_BOOKMARK_WRITTEN, tx);\n\t}\n\n\tdsl_bookmark_node_add(bmark_fs, dbn, tx);\n\n\tspa_history_log_internal_ds(bmark_fs, \"bookmark\", tx,\n\t    \"name=%s creation_txg=%llu target_snap=%llu redact_obj=%llu\",\n\t    shortname, (longlong_t)dbn->dbn_phys.zbm_creation_txg,\n\t    (longlong_t)snapds->ds_object,\n\t    (longlong_t)dbn->dbn_phys.zbm_redaction_obj);\n\n\tdsl_dataset_rele(bmark_fs, FTAG);\n\tdsl_dataset_rele(snapds, FTAG);\n}\n\n\nstatic void\ndsl_bookmark_create_sync_impl_book(\n    const char *new_name, const char *source_name, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *bmark_fs_source, *bmark_fs_new;\n\tchar *source_shortname, *new_shortname;\n\tzfs_bookmark_phys_t source_phys;\n\n\tVERIFY0(dsl_bookmark_hold_ds(dp, source_name, &bmark_fs_source, FTAG,\n\t    &source_shortname));\n\tVERIFY0(dsl_bookmark_hold_ds(dp, new_name, &bmark_fs_new, FTAG,\n\t    &new_shortname));\n\n\t \n\n\tVERIFY0(dsl_bookmark_lookup_impl(bmark_fs_source, source_shortname,\n\t    &source_phys));\n\tdsl_bookmark_node_t *new_dbn = dsl_bookmark_node_alloc(new_shortname);\n\n\tmemcpy(&new_dbn->dbn_phys, &source_phys, sizeof (source_phys));\n\tnew_dbn->dbn_phys.zbm_redaction_obj = 0;\n\n\t \n\tif (new_dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN) {\n\t\tspa_feature_incr(dp->dp_spa,\n\t\t    SPA_FEATURE_BOOKMARK_WRITTEN, tx);\n\t}\n\t \n\t \n\n\t \n\tdsl_bookmark_node_add(bmark_fs_new, new_dbn, tx);\n\n\tspa_history_log_internal_ds(bmark_fs_source, \"bookmark\", tx,\n\t    \"name=%s creation_txg=%llu source_guid=%llu\",\n\t    new_shortname, (longlong_t)new_dbn->dbn_phys.zbm_creation_txg,\n\t    (longlong_t)source_phys.zbm_guid);\n\n\tdsl_dataset_rele(bmark_fs_source, FTAG);\n\tdsl_dataset_rele(bmark_fs_new, FTAG);\n}\n\nvoid\ndsl_bookmark_create_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_bookmark_create_arg_t *dbca = arg;\n\n\tASSERT(spa_feature_is_enabled(dmu_tx_pool(tx)->dp_spa,\n\t    SPA_FEATURE_BOOKMARKS));\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dbca->dbca_bmarks, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(dbca->dbca_bmarks, pair)) {\n\n\t\tconst char *new = nvpair_name(pair);\n\t\tconst char *source = fnvpair_value_string(pair);\n\n\t\tif (strchr(source, '@') != NULL) {\n\t\t\tdsl_bookmark_create_sync_impl_snap(new, source, tx,\n\t\t\t    0, NULL, NULL, NULL);\n\t\t} else if (strchr(source, '#') != NULL) {\n\t\t\tdsl_bookmark_create_sync_impl_book(new, source, tx);\n\t\t} else {\n\t\t\tpanic(\"unreachable code\");\n\t\t}\n\n\t}\n}\n\n \nint\ndsl_bookmark_create(nvlist_t *bmarks, nvlist_t *errors)\n{\n\tnvpair_t *pair;\n\tdsl_bookmark_create_arg_t dbca;\n\n\tpair = nvlist_next_nvpair(bmarks, NULL);\n\tif (pair == NULL)\n\t\treturn (0);\n\n\tdbca.dbca_bmarks = bmarks;\n\tdbca.dbca_errors = errors;\n\n\treturn (dsl_sync_task(nvpair_name(pair), dsl_bookmark_create_check,\n\t    dsl_bookmark_create_sync, &dbca,\n\t    fnvlist_num_pairs(bmarks), ZFS_SPACE_CHECK_NORMAL));\n}\n\nstatic int\ndsl_bookmark_create_redacted_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_bookmark_create_redacted_arg_t *dbcra = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tint rv = 0;\n\n\tif (!spa_feature_is_enabled(dp->dp_spa,\n\t    SPA_FEATURE_REDACTION_BOOKMARKS))\n\t\treturn (SET_ERROR(ENOTSUP));\n\t \n\tif (dbcra->dbcra_numsnaps > (dmu_bonus_max() -\n\t    sizeof (redaction_list_phys_t)) / sizeof (uint64_t))\n\t\treturn (SET_ERROR(E2BIG));\n\n\tif (dsl_bookmark_create_nvl_validate_pair(\n\t    dbcra->dbcra_bmark, dbcra->dbcra_snap) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\trv = dsl_bookmark_create_check_impl(dp,\n\t    dbcra->dbcra_bmark, dbcra->dbcra_snap);\n\treturn (rv);\n}\n\nstatic void\ndsl_bookmark_create_redacted_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_bookmark_create_redacted_arg_t *dbcra = arg;\n\tdsl_bookmark_create_sync_impl_snap(dbcra->dbcra_bmark,\n\t    dbcra->dbcra_snap, tx, dbcra->dbcra_numsnaps, dbcra->dbcra_snaps,\n\t    dbcra->dbcra_tag, dbcra->dbcra_rl);\n}\n\nint\ndsl_bookmark_create_redacted(const char *bookmark, const char *snapshot,\n    uint64_t numsnaps, uint64_t *snapguids, const void *tag,\n    redaction_list_t **rl)\n{\n\tdsl_bookmark_create_redacted_arg_t dbcra;\n\n\tdbcra.dbcra_bmark = bookmark;\n\tdbcra.dbcra_snap = snapshot;\n\tdbcra.dbcra_rl = rl;\n\tdbcra.dbcra_numsnaps = numsnaps;\n\tdbcra.dbcra_snaps = snapguids;\n\tdbcra.dbcra_tag = tag;\n\n\treturn (dsl_sync_task(bookmark, dsl_bookmark_create_redacted_check,\n\t    dsl_bookmark_create_redacted_sync, &dbcra, 5,\n\t    ZFS_SPACE_CHECK_NORMAL));\n}\n\n \nstatic void\ndsl_bookmark_fetch_props(dsl_pool_t *dp, zfs_bookmark_phys_t *bmark_phys,\n    nvlist_t *props, nvlist_t *out_props)\n{\n\tASSERT3P(dp, !=, NULL);\n\tASSERT3P(bmark_phys, !=, NULL);\n\tASSERT3P(out_props, !=, NULL);\n\tASSERT(RRW_LOCK_HELD(&dp->dp_config_rwlock));\n\n\tif (props == NULL || nvlist_exists(props,\n\t    zfs_prop_to_name(ZFS_PROP_GUID))) {\n\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t    ZFS_PROP_GUID, bmark_phys->zbm_guid);\n\t}\n\tif (props == NULL || nvlist_exists(props,\n\t    zfs_prop_to_name(ZFS_PROP_CREATETXG))) {\n\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t    ZFS_PROP_CREATETXG, bmark_phys->zbm_creation_txg);\n\t}\n\tif (props == NULL || nvlist_exists(props,\n\t    zfs_prop_to_name(ZFS_PROP_CREATION))) {\n\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t    ZFS_PROP_CREATION, bmark_phys->zbm_creation_time);\n\t}\n\tif (props == NULL || nvlist_exists(props,\n\t    zfs_prop_to_name(ZFS_PROP_IVSET_GUID))) {\n\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t    ZFS_PROP_IVSET_GUID, bmark_phys->zbm_ivset_guid);\n\t}\n\tif (bmark_phys->zbm_flags & ZBM_FLAG_HAS_FBN) {\n\t\tif (props == NULL || nvlist_exists(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_REFERENCED))) {\n\t\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t\t    ZFS_PROP_REFERENCED,\n\t\t\t    bmark_phys->zbm_referenced_bytes_refd);\n\t\t}\n\t\tif (props == NULL || nvlist_exists(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_LOGICALREFERENCED))) {\n\t\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t\t    ZFS_PROP_LOGICALREFERENCED,\n\t\t\t    bmark_phys->zbm_uncompressed_bytes_refd);\n\t\t}\n\t\tif (props == NULL || nvlist_exists(props,\n\t\t    zfs_prop_to_name(ZFS_PROP_REFRATIO))) {\n\t\t\tuint64_t ratio =\n\t\t\t    bmark_phys->zbm_compressed_bytes_refd == 0 ? 100 :\n\t\t\t    bmark_phys->zbm_uncompressed_bytes_refd * 100 /\n\t\t\t    bmark_phys->zbm_compressed_bytes_refd;\n\t\t\tdsl_prop_nvlist_add_uint64(out_props,\n\t\t\t    ZFS_PROP_REFRATIO, ratio);\n\t\t}\n\t}\n\n\tif ((props == NULL || nvlist_exists(props, \"redact_snaps\") ||\n\t    nvlist_exists(props, \"redact_complete\")) &&\n\t    bmark_phys->zbm_redaction_obj != 0) {\n\t\tredaction_list_t *rl;\n\t\tint err = dsl_redaction_list_hold_obj(dp,\n\t\t    bmark_phys->zbm_redaction_obj, FTAG, &rl);\n\t\tif (err == 0) {\n\t\t\tif (nvlist_exists(props, \"redact_snaps\")) {\n\t\t\t\tnvlist_t *nvl;\n\t\t\t\tnvl = fnvlist_alloc();\n\t\t\t\tfnvlist_add_uint64_array(nvl, ZPROP_VALUE,\n\t\t\t\t    rl->rl_phys->rlp_snaps,\n\t\t\t\t    rl->rl_phys->rlp_num_snaps);\n\t\t\t\tfnvlist_add_nvlist(out_props, \"redact_snaps\",\n\t\t\t\t    nvl);\n\t\t\t\tnvlist_free(nvl);\n\t\t\t}\n\t\t\tif (nvlist_exists(props, \"redact_complete\")) {\n\t\t\t\tnvlist_t *nvl;\n\t\t\t\tnvl = fnvlist_alloc();\n\t\t\t\tfnvlist_add_boolean_value(nvl, ZPROP_VALUE,\n\t\t\t\t    rl->rl_phys->rlp_last_blkid == UINT64_MAX &&\n\t\t\t\t    rl->rl_phys->rlp_last_object == UINT64_MAX);\n\t\t\t\tfnvlist_add_nvlist(out_props, \"redact_complete\",\n\t\t\t\t    nvl);\n\t\t\t\tnvlist_free(nvl);\n\t\t\t}\n\t\t\tdsl_redaction_list_rele(rl, FTAG);\n\t\t}\n\t}\n}\n\nint\ndsl_get_bookmarks_impl(dsl_dataset_t *ds, nvlist_t *props, nvlist_t *outnvl)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\tif (dsl_dataset_is_snapshot(ds))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tfor (dsl_bookmark_node_t *dbn = avl_first(&ds->ds_bookmarks);\n\t    dbn != NULL; dbn = AVL_NEXT(&ds->ds_bookmarks, dbn)) {\n\t\tnvlist_t *out_props = fnvlist_alloc();\n\n\t\tdsl_bookmark_fetch_props(dp, &dbn->dbn_phys, props, out_props);\n\n\t\tfnvlist_add_nvlist(outnvl, dbn->dbn_name, out_props);\n\t\tfnvlist_free(out_props);\n\t}\n\treturn (0);\n}\n\n \nstatic int\ndsl_bookmark_compare(const void *l, const void *r)\n{\n\tconst dsl_bookmark_node_t *ldbn = l;\n\tconst dsl_bookmark_node_t *rdbn = r;\n\n\tint64_t cmp = TREE_CMP(ldbn->dbn_phys.zbm_creation_txg,\n\t    rdbn->dbn_phys.zbm_creation_txg);\n\tif (likely(cmp))\n\t\treturn (cmp);\n\tcmp = TREE_CMP((ldbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN),\n\t    (rdbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN));\n\tif (likely(cmp))\n\t\treturn (cmp);\n\tcmp = strcmp(ldbn->dbn_name, rdbn->dbn_name);\n\treturn (TREE_ISIGN(cmp));\n}\n\n \nint\ndsl_bookmark_init_ds(dsl_dataset_t *ds)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tASSERT(!ds->ds_is_snapshot);\n\n\tavl_create(&ds->ds_bookmarks, dsl_bookmark_compare,\n\t    sizeof (dsl_bookmark_node_t),\n\t    offsetof(dsl_bookmark_node_t, dbn_node));\n\n\tif (!dsl_dataset_is_zapified(ds))\n\t\treturn (0);\n\n\tint zaperr = zap_lookup(mos, ds->ds_object, DS_FIELD_BOOKMARK_NAMES,\n\t    sizeof (ds->ds_bookmarks_obj), 1, &ds->ds_bookmarks_obj);\n\tif (zaperr == ENOENT)\n\t\treturn (0);\n\tif (zaperr != 0)\n\t\treturn (zaperr);\n\n\tif (ds->ds_bookmarks_obj == 0)\n\t\treturn (0);\n\n\tint err = 0;\n\tzap_cursor_t zc;\n\tzap_attribute_t attr;\n\n\tfor (zap_cursor_init(&zc, mos, ds->ds_bookmarks_obj);\n\t    (err = zap_cursor_retrieve(&zc, &attr)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tdsl_bookmark_node_t *dbn =\n\t\t    dsl_bookmark_node_alloc(attr.za_name);\n\n\t\terr = dsl_bookmark_lookup_impl(ds,\n\t\t    dbn->dbn_name, &dbn->dbn_phys);\n\t\tASSERT3U(err, !=, ENOENT);\n\t\tif (err != 0) {\n\t\t\tkmem_free(dbn, sizeof (*dbn));\n\t\t\tbreak;\n\t\t}\n\t\tavl_add(&ds->ds_bookmarks, dbn);\n\t}\n\tzap_cursor_fini(&zc);\n\tif (err == ENOENT)\n\t\terr = 0;\n\treturn (err);\n}\n\nvoid\ndsl_bookmark_fini_ds(dsl_dataset_t *ds)\n{\n\tvoid *cookie = NULL;\n\tdsl_bookmark_node_t *dbn;\n\n\tif (ds->ds_is_snapshot)\n\t\treturn;\n\n\twhile ((dbn = avl_destroy_nodes(&ds->ds_bookmarks, &cookie)) != NULL) {\n\t\tspa_strfree(dbn->dbn_name);\n\t\tmutex_destroy(&dbn->dbn_lock);\n\t\tkmem_free(dbn, sizeof (*dbn));\n\t}\n\tavl_destroy(&ds->ds_bookmarks);\n}\n\n \nint\ndsl_get_bookmarks(const char *dsname, nvlist_t *props, nvlist_t *outnvl)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tint err;\n\n\terr = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (err);\n\t}\n\n\terr = dsl_get_bookmarks_impl(ds, props, outnvl);\n\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (err);\n}\n\n \nint\ndsl_get_bookmark_props(const char *dsname, const char *bmname, nvlist_t *props)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tzfs_bookmark_phys_t bmark_phys = { 0 };\n\tint err;\n\n\terr = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (err);\n\t}\n\n\terr = dsl_bookmark_lookup_impl(ds, bmname, &bmark_phys);\n\tif (err != 0)\n\t\tgoto out;\n\n\tdsl_bookmark_fetch_props(dp, &bmark_phys, NULL, props);\nout:\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (err);\n}\n\ntypedef struct dsl_bookmark_destroy_arg {\n\tnvlist_t *dbda_bmarks;\n\tnvlist_t *dbda_success;\n\tnvlist_t *dbda_errors;\n} dsl_bookmark_destroy_arg_t;\n\nstatic void\ndsl_bookmark_destroy_sync_impl(dsl_dataset_t *ds, const char *name,\n    dmu_tx_t *tx)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tuint64_t bmark_zapobj = ds->ds_bookmarks_obj;\n\tmatchtype_t mt = 0;\n\tuint64_t int_size, num_ints;\n\t \n\tdsl_bookmark_node_t search = { 0 };\n\tchar realname[ZFS_MAX_DATASET_NAME_LEN];\n\n\t \n\n\tif (dsl_dataset_phys(ds)->ds_flags & DS_FLAG_CI_DATASET)\n\t\tmt = MT_NORMALIZE;\n\n\tVERIFY0(zap_length(mos, bmark_zapobj, name, &int_size, &num_ints));\n\n\tASSERT3U(int_size, ==, sizeof (uint64_t));\n\n\tif (num_ints * int_size > BOOKMARK_PHYS_SIZE_V1) {\n\t\tspa_feature_decr(dmu_objset_spa(mos),\n\t\t    SPA_FEATURE_BOOKMARK_V2, tx);\n\t}\n\tVERIFY0(zap_lookup_norm(mos, bmark_zapobj, name, sizeof (uint64_t),\n\t    num_ints, &search.dbn_phys, mt, realname, sizeof (realname), NULL));\n\n\tsearch.dbn_name = realname;\n\tdsl_bookmark_node_t *dbn = avl_find(&ds->ds_bookmarks, &search, NULL);\n\tASSERT(dbn != NULL);\n\n\tif (dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN) {\n\t\t \n\n\t\tdsl_bookmark_node_t *dbn_prev =\n\t\t    AVL_PREV(&ds->ds_bookmarks, dbn);\n\t\tdsl_bookmark_node_t *dbn_next =\n\t\t    AVL_NEXT(&ds->ds_bookmarks, dbn);\n\n\t\tboolean_t more_bookmarks_at_this_txg =\n\t\t    (dbn_prev != NULL && dbn_prev->dbn_phys.zbm_creation_txg ==\n\t\t    dbn->dbn_phys.zbm_creation_txg &&\n\t\t    (dbn_prev->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN)) ||\n\t\t    (dbn_next != NULL && dbn_next->dbn_phys.zbm_creation_txg ==\n\t\t    dbn->dbn_phys.zbm_creation_txg &&\n\t\t    (dbn_next->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN));\n\n\t\tif (!(dbn->dbn_phys.zbm_flags & ZBM_FLAG_SNAPSHOT_EXISTS) &&\n\t\t    !more_bookmarks_at_this_txg &&\n\t\t    dbn->dbn_phys.zbm_creation_txg <\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_txg) {\n\t\t\tdsl_dir_remove_clones_key(ds->ds_dir,\n\t\t\t    dbn->dbn_phys.zbm_creation_txg, tx);\n\t\t\tdsl_deadlist_remove_key(&ds->ds_deadlist,\n\t\t\t    dbn->dbn_phys.zbm_creation_txg, tx);\n\t\t}\n\n\t\tspa_feature_decr(dmu_objset_spa(mos),\n\t\t    SPA_FEATURE_BOOKMARK_WRITTEN, tx);\n\t}\n\n\tif (dbn->dbn_phys.zbm_redaction_obj != 0) {\n\t\tVERIFY0(dmu_object_free(mos,\n\t\t    dbn->dbn_phys.zbm_redaction_obj, tx));\n\t\tspa_feature_decr(dmu_objset_spa(mos),\n\t\t    SPA_FEATURE_REDACTION_BOOKMARKS, tx);\n\t}\n\n\tavl_remove(&ds->ds_bookmarks, dbn);\n\tspa_strfree(dbn->dbn_name);\n\tmutex_destroy(&dbn->dbn_lock);\n\tkmem_free(dbn, sizeof (*dbn));\n\n\tVERIFY0(zap_remove_norm(mos, bmark_zapobj, name, mt, tx));\n}\n\nstatic int\ndsl_bookmark_destroy_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_bookmark_destroy_arg_t *dbda = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tint rv = 0;\n\n\tASSERT(nvlist_empty(dbda->dbda_success));\n\tASSERT(nvlist_empty(dbda->dbda_errors));\n\n\tif (!spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_BOOKMARKS))\n\t\treturn (0);\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dbda->dbda_bmarks, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(dbda->dbda_bmarks, pair)) {\n\t\tconst char *fullname = nvpair_name(pair);\n\t\tdsl_dataset_t *ds;\n\t\tzfs_bookmark_phys_t bm;\n\t\tint error;\n\t\tchar *shortname;\n\n\t\terror = dsl_bookmark_hold_ds(dp, fullname, &ds,\n\t\t    FTAG, &shortname);\n\t\tif (error == ENOENT) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (error == 0) {\n\t\t\terror = dsl_bookmark_lookup_impl(ds, shortname, &bm);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\tif (error == ESRCH) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error == 0 && bm.zbm_redaction_obj != 0) {\n\t\t\t\tredaction_list_t *rl = NULL;\n\t\t\t\terror = dsl_redaction_list_hold_obj(tx->tx_pool,\n\t\t\t\t    bm.zbm_redaction_obj, FTAG, &rl);\n\t\t\t\tif (error == ENOENT) {\n\t\t\t\t\terror = 0;\n\t\t\t\t} else if (error == 0 &&\n\t\t\t\t    dsl_redaction_list_long_held(rl)) {\n\t\t\t\t\terror = SET_ERROR(EBUSY);\n\t\t\t\t}\n\t\t\t\tif (rl != NULL) {\n\t\t\t\t\tdsl_redaction_list_rele(rl, FTAG);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (error == 0) {\n\t\t\tif (dmu_tx_is_syncing(tx)) {\n\t\t\t\tfnvlist_add_boolean(dbda->dbda_success,\n\t\t\t\t    fullname);\n\t\t\t}\n\t\t} else {\n\t\t\tfnvlist_add_int32(dbda->dbda_errors, fullname, error);\n\t\t\trv = error;\n\t\t}\n\t}\n\treturn (rv);\n}\n\nstatic void\ndsl_bookmark_destroy_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_bookmark_destroy_arg_t *dbda = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dbda->dbda_success, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(dbda->dbda_success, pair)) {\n\t\tdsl_dataset_t *ds;\n\t\tchar *shortname;\n\t\tuint64_t zap_cnt;\n\n\t\tVERIFY0(dsl_bookmark_hold_ds(dp, nvpair_name(pair),\n\t\t    &ds, FTAG, &shortname));\n\t\tdsl_bookmark_destroy_sync_impl(ds, shortname, tx);\n\n\t\t \n\t\tVERIFY0(zap_count(mos, ds->ds_bookmarks_obj, &zap_cnt));\n\t\tif (zap_cnt == 0) {\n\t\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\t\tVERIFY0(zap_destroy(mos, ds->ds_bookmarks_obj, tx));\n\t\t\tds->ds_bookmarks_obj = 0;\n\t\t\tspa_feature_decr(dp->dp_spa, SPA_FEATURE_BOOKMARKS, tx);\n\t\t\tVERIFY0(zap_remove(mos, ds->ds_object,\n\t\t\t    DS_FIELD_BOOKMARK_NAMES, tx));\n\t\t}\n\n\t\tspa_history_log_internal_ds(ds, \"remove bookmark\", tx,\n\t\t    \"name=%s\", shortname);\n\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n}\n\n \nint\ndsl_bookmark_destroy(nvlist_t *bmarks, nvlist_t *errors)\n{\n\tint rv;\n\tdsl_bookmark_destroy_arg_t dbda;\n\tnvpair_t *pair = nvlist_next_nvpair(bmarks, NULL);\n\tif (pair == NULL)\n\t\treturn (0);\n\n\tdbda.dbda_bmarks = bmarks;\n\tdbda.dbda_errors = errors;\n\tdbda.dbda_success = fnvlist_alloc();\n\n\trv = dsl_sync_task(nvpair_name(pair), dsl_bookmark_destroy_check,\n\t    dsl_bookmark_destroy_sync, &dbda, fnvlist_num_pairs(bmarks),\n\t    ZFS_SPACE_CHECK_RESERVED);\n\tfnvlist_free(dbda.dbda_success);\n\treturn (rv);\n}\n\n \nboolean_t\ndsl_redaction_list_long_held(redaction_list_t *rl)\n{\n\treturn (!zfs_refcount_is_zero(&rl->rl_longholds));\n}\n\nvoid\ndsl_redaction_list_long_hold(dsl_pool_t *dp, redaction_list_t *rl,\n    const void *tag)\n{\n\tASSERT(dsl_pool_config_held(dp));\n\t(void) zfs_refcount_add(&rl->rl_longholds, tag);\n}\n\nvoid\ndsl_redaction_list_long_rele(redaction_list_t *rl, const void *tag)\n{\n\t(void) zfs_refcount_remove(&rl->rl_longholds, tag);\n}\n\nstatic void\nredaction_list_evict_sync(void *rlu)\n{\n\tredaction_list_t *rl = rlu;\n\tzfs_refcount_destroy(&rl->rl_longholds);\n\n\tkmem_free(rl, sizeof (redaction_list_t));\n}\n\nvoid\ndsl_redaction_list_rele(redaction_list_t *rl, const void *tag)\n{\n\tdmu_buf_rele(rl->rl_dbuf, tag);\n}\n\nint\ndsl_redaction_list_hold_obj(dsl_pool_t *dp, uint64_t rlobj, const void *tag,\n    redaction_list_t **rlp)\n{\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdmu_buf_t *dbuf;\n\tredaction_list_t *rl;\n\tint err;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\terr = dmu_bonus_hold(mos, rlobj, tag, &dbuf);\n\tif (err != 0)\n\t\treturn (err);\n\n\trl = dmu_buf_get_user(dbuf);\n\tif (rl == NULL) {\n\t\tredaction_list_t *winner = NULL;\n\n\t\trl = kmem_zalloc(sizeof (redaction_list_t), KM_SLEEP);\n\t\trl->rl_dbuf = dbuf;\n\t\trl->rl_object = rlobj;\n\t\trl->rl_phys = dbuf->db_data;\n\t\trl->rl_mos = dp->dp_meta_objset;\n\t\tzfs_refcount_create(&rl->rl_longholds);\n\t\tdmu_buf_init_user(&rl->rl_dbu, redaction_list_evict_sync, NULL,\n\t\t    &rl->rl_dbuf);\n\t\tif ((winner = dmu_buf_set_user_ie(dbuf, &rl->rl_dbu)) != NULL) {\n\t\t\tkmem_free(rl, sizeof (*rl));\n\t\t\trl = winner;\n\t\t}\n\t}\n\t*rlp = rl;\n\treturn (0);\n}\n\n \nboolean_t\ndsl_bookmark_ds_destroyed(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\n\tdsl_dataset_t *head, *next;\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj, FTAG, &head));\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dataset_phys(ds)->ds_next_snap_obj, FTAG, &next));\n\n\t \n\tdsl_bookmark_node_t search = { 0 };\n\tavl_index_t idx;\n\tsearch.dbn_phys.zbm_creation_txg =\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\tsearch.dbn_phys.zbm_flags = ZBM_FLAG_HAS_FBN;\n\t \n\tsearch.dbn_name = (char *)\"\";\n\tVERIFY3P(avl_find(&head->ds_bookmarks, &search, &idx), ==, NULL);\n\tdsl_bookmark_node_t *dbn =\n\t    avl_nearest(&head->ds_bookmarks, idx, AVL_AFTER);\n\n\t \n\tfor (; dbn != NULL && dbn->dbn_phys.zbm_creation_txg <\n\t    dsl_dataset_phys(ds)->ds_creation_txg;\n\t    dbn = AVL_NEXT(&head->ds_bookmarks, dbn)) {\n\t\tif (!(dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN))\n\t\t\tcontinue;\n\t\t \n\t\tuint64_t referenced, compressed, uncompressed;\n\t\tdsl_deadlist_space_range(&next->ds_deadlist,\n\t\t    0, dbn->dbn_phys.zbm_creation_txg,\n\t\t    &referenced, &compressed, &uncompressed);\n\t\tdbn->dbn_phys.zbm_referenced_freed_before_next_snap +=\n\t\t    referenced;\n\t\tdbn->dbn_phys.zbm_compressed_freed_before_next_snap +=\n\t\t    compressed;\n\t\tdbn->dbn_phys.zbm_uncompressed_freed_before_next_snap +=\n\t\t    uncompressed;\n\t\tVERIFY0(zap_update(dp->dp_meta_objset, head->ds_bookmarks_obj,\n\t\t    dbn->dbn_name, sizeof (uint64_t),\n\t\t    sizeof (zfs_bookmark_phys_t) / sizeof (uint64_t),\n\t\t    &dbn->dbn_phys, tx));\n\t}\n\tdsl_dataset_rele(next, FTAG);\n\n\t \n\tboolean_t rv = B_FALSE;\n\tfor (; dbn != NULL && dbn->dbn_phys.zbm_creation_txg ==\n\t    dsl_dataset_phys(ds)->ds_creation_txg;\n\t    dbn = AVL_NEXT(&head->ds_bookmarks, dbn)) {\n\t\tif (!(dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN)) {\n\t\t\tASSERT(!(dbn->dbn_phys.zbm_flags &\n\t\t\t    ZBM_FLAG_SNAPSHOT_EXISTS));\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(dbn->dbn_phys.zbm_flags & ZBM_FLAG_SNAPSHOT_EXISTS);\n\t\tdbn->dbn_phys.zbm_flags &= ~ZBM_FLAG_SNAPSHOT_EXISTS;\n\t\tVERIFY0(zap_update(dp->dp_meta_objset, head->ds_bookmarks_obj,\n\t\t    dbn->dbn_name, sizeof (uint64_t),\n\t\t    sizeof (zfs_bookmark_phys_t) / sizeof (uint64_t),\n\t\t    &dbn->dbn_phys, tx));\n\t\trv = B_TRUE;\n\t}\n\tdsl_dataset_rele(head, FTAG);\n\treturn (rv);\n}\n\n \nvoid\ndsl_bookmark_snapshotted(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tuint64_t last_key_added = UINT64_MAX;\n\tfor (dsl_bookmark_node_t *dbn = avl_last(&ds->ds_bookmarks);\n\t    dbn != NULL && dbn->dbn_phys.zbm_creation_txg >\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t    dbn = AVL_PREV(&ds->ds_bookmarks, dbn)) {\n\t\tuint64_t creation_txg = dbn->dbn_phys.zbm_creation_txg;\n\t\tASSERT3U(creation_txg, <=, last_key_added);\n\t\t \n\t\tif ((dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN) &&\n\t\t    creation_txg != last_key_added) {\n\t\t\tdsl_deadlist_add_key(&ds->ds_deadlist,\n\t\t\t    creation_txg, tx);\n\t\t\tlast_key_added = creation_txg;\n\t\t}\n\t}\n}\n\n \nvoid\ndsl_bookmark_next_changed(dsl_dataset_t *head, dsl_dataset_t *origin,\n    dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\t \n\tdsl_bookmark_node_t search = { 0 };\n\tavl_index_t idx;\n\tsearch.dbn_phys.zbm_creation_txg =\n\t    dsl_dataset_phys(origin)->ds_creation_txg;\n\tsearch.dbn_phys.zbm_flags = ZBM_FLAG_HAS_FBN;\n\t \n\tsearch.dbn_name = (char *)\"\";\n\tVERIFY3P(avl_find(&head->ds_bookmarks, &search, &idx), ==, NULL);\n\tdsl_bookmark_node_t *dbn =\n\t    avl_nearest(&head->ds_bookmarks, idx, AVL_AFTER);\n\n\t \n\tfor (; dbn != NULL && dbn->dbn_phys.zbm_creation_txg ==\n\t    dsl_dataset_phys(origin)->ds_creation_txg &&\n\t    (dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN);\n\t    dbn = AVL_NEXT(&head->ds_bookmarks, dbn)) {\n\n\t\t \n\t\tASSERT3U(dbn->dbn_phys.zbm_guid, ==,\n\t\t    dsl_dataset_phys(origin)->ds_guid);\n\t\tASSERT3U(dbn->dbn_phys.zbm_referenced_bytes_refd, ==,\n\t\t    dsl_dataset_phys(origin)->ds_referenced_bytes);\n\t\tASSERT(dbn->dbn_phys.zbm_flags &\n\t\t    ZBM_FLAG_SNAPSHOT_EXISTS);\n\t\t \n\t\tuint64_t redaction_obj =\n\t\t    dbn->dbn_phys.zbm_redaction_obj;\n\t\tdsl_bookmark_set_phys(&dbn->dbn_phys, origin);\n\t\tdbn->dbn_phys.zbm_redaction_obj = redaction_obj;\n\n\t\tVERIFY0(zap_update(dp->dp_meta_objset, head->ds_bookmarks_obj,\n\t\t    dbn->dbn_name, sizeof (uint64_t),\n\t\t    sizeof (zfs_bookmark_phys_t) / sizeof (uint64_t),\n\t\t    &dbn->dbn_phys, tx));\n\t}\n}\n\n \nvoid\ndsl_bookmark_block_killed(dsl_dataset_t *ds, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\t(void) tx;\n\n\t \n\tfor (dsl_bookmark_node_t *dbn = avl_last(&ds->ds_bookmarks);\n\t    dbn != NULL && dbn->dbn_phys.zbm_creation_txg >=\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t    dbn = AVL_PREV(&ds->ds_bookmarks, dbn)) {\n\t\t \n\t\tif (bp->blk_birth <= dbn->dbn_phys.zbm_creation_txg &&\n\t\t    (dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN)) {\n\t\t\tmutex_enter(&dbn->dbn_lock);\n\t\t\tdbn->dbn_phys.zbm_referenced_freed_before_next_snap +=\n\t\t\t    bp_get_dsize_sync(dsl_dataset_get_spa(ds), bp);\n\t\t\tdbn->dbn_phys.zbm_compressed_freed_before_next_snap +=\n\t\t\t    BP_GET_PSIZE(bp);\n\t\t\tdbn->dbn_phys.zbm_uncompressed_freed_before_next_snap +=\n\t\t\t    BP_GET_UCSIZE(bp);\n\t\t\t \n\t\t\tdbn->dbn_dirty = B_TRUE;\n\t\t\tmutex_exit(&dbn->dbn_lock);\n\t\t}\n\t}\n}\n\nvoid\ndsl_bookmark_sync_done(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\tif (dsl_dataset_is_snapshot(ds))\n\t\treturn;\n\n\t \n\tfor (dsl_bookmark_node_t *dbn = avl_last(&ds->ds_bookmarks);\n\t    dbn != NULL && dbn->dbn_phys.zbm_creation_txg >=\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\t    dbn = AVL_PREV(&ds->ds_bookmarks, dbn)) {\n\t\tif (dbn->dbn_dirty) {\n\t\t\t \n\t\t\tASSERT(dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN);\n\t\t\tVERIFY0(zap_update(dp->dp_meta_objset,\n\t\t\t    ds->ds_bookmarks_obj,\n\t\t\t    dbn->dbn_name, sizeof (uint64_t),\n\t\t\t    sizeof (zfs_bookmark_phys_t) / sizeof (uint64_t),\n\t\t\t    &dbn->dbn_phys, tx));\n\t\t\tdbn->dbn_dirty = B_FALSE;\n\t\t}\n\t}\n#ifdef ZFS_DEBUG\n\tfor (dsl_bookmark_node_t *dbn = avl_first(&ds->ds_bookmarks);\n\t    dbn != NULL; dbn = AVL_NEXT(&ds->ds_bookmarks, dbn)) {\n\t\tASSERT(!dbn->dbn_dirty);\n\t}\n#endif\n}\n\n \nuint64_t\ndsl_bookmark_latest_txg(dsl_dataset_t *ds)\n{\n\tASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));\n\tdsl_bookmark_node_t *dbn = avl_last(&ds->ds_bookmarks);\n\tif (dbn == NULL)\n\t\treturn (0);\n\treturn (dbn->dbn_phys.zbm_creation_txg);\n}\n\n \nstatic int\nredact_block_zb_compare(redact_block_phys_t *first,\n    zbookmark_phys_t *second)\n{\n\t \n\tif (first->rbp_object < second->zb_object ||\n\t    (first->rbp_object == second->zb_object &&\n\t    first->rbp_blkid + (redact_block_get_count(first) - 1) <\n\t    second->zb_blkid)) {\n\t\treturn (-1);\n\t}\n\n\t \n\tif (first->rbp_object > second->zb_object ||\n\t    (first->rbp_object == second->zb_object &&\n\t    first->rbp_blkid > second->zb_blkid)) {\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}\n\n \nint\ndsl_redaction_list_traverse(redaction_list_t *rl, zbookmark_phys_t *resume,\n    rl_traverse_callback_t cb, void *arg)\n{\n\tobjset_t *mos = rl->rl_mos;\n\tint err = 0;\n\n\tif (rl->rl_phys->rlp_last_object != UINT64_MAX ||\n\t    rl->rl_phys->rlp_last_blkid != UINT64_MAX) {\n\t\t \n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (ZB_IS_ZERO(resume))\n\t\tresume = NULL;\n\n\t \n\tuint64_t maxidx = rl->rl_phys->rlp_num_entries - 1;\n\tuint64_t minidx = 0;\n\twhile (resume != NULL && maxidx > minidx) {\n\t\tredact_block_phys_t rbp = { 0 };\n\t\tASSERT3U(maxidx, >, minidx);\n\t\tuint64_t mididx = minidx + ((maxidx - minidx) / 2);\n\t\terr = dmu_read(mos, rl->rl_object, mididx * sizeof (rbp),\n\t\t    sizeof (rbp), &rbp, DMU_READ_NO_PREFETCH);\n\t\tif (err != 0)\n\t\t\tbreak;\n\n\t\tint cmp = redact_block_zb_compare(&rbp, resume);\n\n\t\tif (cmp == 0) {\n\t\t\tminidx = mididx;\n\t\t\tbreak;\n\t\t} else if (cmp > 0) {\n\t\t\tmaxidx =\n\t\t\t    (mididx == minidx ? minidx : mididx - 1);\n\t\t} else {\n\t\t\tminidx = mididx + 1;\n\t\t}\n\t}\n\n\tunsigned int bufsize = SPA_OLD_MAXBLOCKSIZE;\n\tredact_block_phys_t *buf = zio_data_buf_alloc(bufsize);\n\n\tunsigned int entries_per_buf = bufsize / sizeof (redact_block_phys_t);\n\tuint64_t start_block = minidx / entries_per_buf;\n\terr = dmu_read(mos, rl->rl_object, start_block * bufsize, bufsize, buf,\n\t    DMU_READ_PREFETCH);\n\n\tfor (uint64_t curidx = minidx;\n\t    err == 0 && curidx < rl->rl_phys->rlp_num_entries;\n\t    curidx++) {\n\t\t \n\t\tif (curidx % entries_per_buf == 0) {\n\t\t\terr = dmu_read(mos, rl->rl_object, curidx *\n\t\t\t    sizeof (*buf), bufsize, buf,\n\t\t\t    DMU_READ_PREFETCH);\n\t\t\tif (err != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tredact_block_phys_t *rb = &buf[curidx % entries_per_buf];\n\t\t \n\t\tif (resume != NULL) {\n\t\t\t \n\t\t\tif (redact_block_zb_compare(rb, resume) < 0) {\n\t\t\t\tASSERT3U(curidx, ==, minidx);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (resume->zb_object == rb->rbp_object &&\n\t\t\t\t    resume->zb_blkid > rb->rbp_blkid) {\n\t\t\t\t\tuint64_t diff = resume->zb_blkid -\n\t\t\t\t\t    rb->rbp_blkid;\n\t\t\t\t\trb->rbp_blkid = resume->zb_blkid;\n\t\t\t\t\tredact_block_set_count(rb,\n\t\t\t\t\t    redact_block_get_count(rb) - diff);\n\t\t\t\t}\n\t\t\t\tresume = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (cb(rb, arg) != 0) {\n\t\t\terr = EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tzio_data_buf_free(buf, bufsize);\n\treturn (err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}