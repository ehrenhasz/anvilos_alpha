{
  "module_name": "vdev.c",
  "hash_id": "f54cccc3af7376a2cb84f1e162eb7ba79715653e8eb2ac9c980e59ebff57c2d1",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/vdev.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/bpobj.h>\n#include <sys/dmu.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_dir.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_rebuild.h>\n#include <sys/vdev_draid.h>\n#include <sys/uberblock_impl.h>\n#include <sys/metaslab.h>\n#include <sys/metaslab_impl.h>\n#include <sys/space_map.h>\n#include <sys/space_reftree.h>\n#include <sys/zio.h>\n#include <sys/zap.h>\n#include <sys/fs/zfs.h>\n#include <sys/arc.h>\n#include <sys/zil.h>\n#include <sys/dsl_scan.h>\n#include <sys/vdev_raidz.h>\n#include <sys/abd.h>\n#include <sys/vdev_initialize.h>\n#include <sys/vdev_trim.h>\n#include <sys/zvol.h>\n#include <sys/zfs_ratelimit.h>\n#include \"zfs_prop.h\"\n\n \nstatic uint_t zfs_embedded_slog_min_ms = 64;\n\n \nstatic uint_t zfs_vdev_default_ms_count = 200;\n\n \nstatic uint_t zfs_vdev_min_ms_count = 16;\n\n \nstatic uint_t zfs_vdev_ms_count_limit = 1ULL << 17;\n\n \nstatic uint_t zfs_vdev_default_ms_shift = 29;\n\n \nstatic uint_t zfs_vdev_max_ms_shift = 34;\n\nint vdev_validate_skip = B_FALSE;\n\n \nint zfs_vdev_dtl_sm_blksz = (1 << 12);\n\n \nstatic unsigned int zfs_slow_io_events_per_second = 20;\n\n \nstatic unsigned int zfs_checksum_events_per_second = 20;\n\n \nstatic int zfs_scan_ignore_errors = 0;\n\n \nint zfs_vdev_standard_sm_blksz = (1 << 17);\n\n \nint zfs_nocacheflush = 0;\n\n \nuint_t zfs_vdev_max_auto_ashift = 14;\nuint_t zfs_vdev_min_auto_ashift = ASHIFT_MIN;\n\nvoid\nvdev_dbgmsg(vdev_t *vd, const char *fmt, ...)\n{\n\tva_list adx;\n\tchar buf[256];\n\n\tva_start(adx, fmt);\n\t(void) vsnprintf(buf, sizeof (buf), fmt, adx);\n\tva_end(adx);\n\n\tif (vd->vdev_path != NULL) {\n\t\tzfs_dbgmsg(\"%s vdev '%s': %s\", vd->vdev_ops->vdev_op_type,\n\t\t    vd->vdev_path, buf);\n\t} else {\n\t\tzfs_dbgmsg(\"%s-%llu vdev (guid %llu): %s\",\n\t\t    vd->vdev_ops->vdev_op_type,\n\t\t    (u_longlong_t)vd->vdev_id,\n\t\t    (u_longlong_t)vd->vdev_guid, buf);\n\t}\n}\n\nvoid\nvdev_dbgmsg_print_tree(vdev_t *vd, int indent)\n{\n\tchar state[20];\n\n\tif (vd->vdev_ishole || vd->vdev_ops == &vdev_missing_ops) {\n\t\tzfs_dbgmsg(\"%*svdev %llu: %s\", indent, \"\",\n\t\t    (u_longlong_t)vd->vdev_id,\n\t\t    vd->vdev_ops->vdev_op_type);\n\t\treturn;\n\t}\n\n\tswitch (vd->vdev_state) {\n\tcase VDEV_STATE_UNKNOWN:\n\t\t(void) snprintf(state, sizeof (state), \"unknown\");\n\t\tbreak;\n\tcase VDEV_STATE_CLOSED:\n\t\t(void) snprintf(state, sizeof (state), \"closed\");\n\t\tbreak;\n\tcase VDEV_STATE_OFFLINE:\n\t\t(void) snprintf(state, sizeof (state), \"offline\");\n\t\tbreak;\n\tcase VDEV_STATE_REMOVED:\n\t\t(void) snprintf(state, sizeof (state), \"removed\");\n\t\tbreak;\n\tcase VDEV_STATE_CANT_OPEN:\n\t\t(void) snprintf(state, sizeof (state), \"can't open\");\n\t\tbreak;\n\tcase VDEV_STATE_FAULTED:\n\t\t(void) snprintf(state, sizeof (state), \"faulted\");\n\t\tbreak;\n\tcase VDEV_STATE_DEGRADED:\n\t\t(void) snprintf(state, sizeof (state), \"degraded\");\n\t\tbreak;\n\tcase VDEV_STATE_HEALTHY:\n\t\t(void) snprintf(state, sizeof (state), \"healthy\");\n\t\tbreak;\n\tdefault:\n\t\t(void) snprintf(state, sizeof (state), \"<state %u>\",\n\t\t    (uint_t)vd->vdev_state);\n\t}\n\n\tzfs_dbgmsg(\"%*svdev %u: %s%s, guid: %llu, path: %s, %s\", indent,\n\t    \"\", (int)vd->vdev_id, vd->vdev_ops->vdev_op_type,\n\t    vd->vdev_islog ? \" (log)\" : \"\",\n\t    (u_longlong_t)vd->vdev_guid,\n\t    vd->vdev_path ? vd->vdev_path : \"N/A\", state);\n\n\tfor (uint64_t i = 0; i < vd->vdev_children; i++)\n\t\tvdev_dbgmsg_print_tree(vd->vdev_child[i], indent + 2);\n}\n\n \n\nstatic vdev_ops_t *const vdev_ops_table[] = {\n\t&vdev_root_ops,\n\t&vdev_raidz_ops,\n\t&vdev_draid_ops,\n\t&vdev_draid_spare_ops,\n\t&vdev_mirror_ops,\n\t&vdev_replacing_ops,\n\t&vdev_spare_ops,\n\t&vdev_disk_ops,\n\t&vdev_file_ops,\n\t&vdev_missing_ops,\n\t&vdev_hole_ops,\n\t&vdev_indirect_ops,\n\tNULL\n};\n\n \nstatic vdev_ops_t *\nvdev_getops(const char *type)\n{\n\tvdev_ops_t *ops, *const *opspp;\n\n\tfor (opspp = vdev_ops_table; (ops = *opspp) != NULL; opspp++)\n\t\tif (strcmp(ops->vdev_op_type, type) == 0)\n\t\t\tbreak;\n\n\treturn (ops);\n}\n\n \nmetaslab_group_t *\nvdev_get_mg(vdev_t *vd, metaslab_class_t *mc)\n{\n\tif (mc == spa_embedded_log_class(vd->vdev_spa) &&\n\t    vd->vdev_log_mg != NULL)\n\t\treturn (vd->vdev_log_mg);\n\telse\n\t\treturn (vd->vdev_mg);\n}\n\nvoid\nvdev_default_xlate(vdev_t *vd, const range_seg64_t *logical_rs,\n    range_seg64_t *physical_rs, range_seg64_t *remain_rs)\n{\n\t(void) vd, (void) remain_rs;\n\n\tphysical_rs->rs_start = logical_rs->rs_start;\n\tphysical_rs->rs_end = logical_rs->rs_end;\n}\n\n \nstatic vdev_alloc_bias_t\nvdev_derive_alloc_bias(const char *bias)\n{\n\tvdev_alloc_bias_t alloc_bias = VDEV_BIAS_NONE;\n\n\tif (strcmp(bias, VDEV_ALLOC_BIAS_LOG) == 0)\n\t\talloc_bias = VDEV_BIAS_LOG;\n\telse if (strcmp(bias, VDEV_ALLOC_BIAS_SPECIAL) == 0)\n\t\talloc_bias = VDEV_BIAS_SPECIAL;\n\telse if (strcmp(bias, VDEV_ALLOC_BIAS_DEDUP) == 0)\n\t\talloc_bias = VDEV_BIAS_DEDUP;\n\n\treturn (alloc_bias);\n}\n\n \nuint64_t\nvdev_default_asize(vdev_t *vd, uint64_t psize)\n{\n\tuint64_t asize = P2ROUNDUP(psize, 1ULL << vd->vdev_top->vdev_ashift);\n\tuint64_t csize;\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tcsize = vdev_psize_to_asize(vd->vdev_child[c], psize);\n\t\tasize = MAX(asize, csize);\n\t}\n\n\treturn (asize);\n}\n\nuint64_t\nvdev_default_min_asize(vdev_t *vd)\n{\n\treturn (vd->vdev_min_asize);\n}\n\n \nuint64_t\nvdev_get_min_asize(vdev_t *vd)\n{\n\tvdev_t *pvd = vd->vdev_parent;\n\n\t \n\tif (pvd == NULL)\n\t\treturn (vd->vdev_asize);\n\n\t \n\tif (vd == vd->vdev_top)\n\t\treturn (P2ALIGN(vd->vdev_asize, 1ULL << vd->vdev_ms_shift));\n\n\treturn (pvd->vdev_ops->vdev_op_min_asize(pvd));\n}\n\nvoid\nvdev_set_min_asize(vdev_t *vd)\n{\n\tvd->vdev_min_asize = vdev_get_min_asize(vd);\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_set_min_asize(vd->vdev_child[c]);\n}\n\n \nuint64_t\nvdev_get_min_alloc(vdev_t *vd)\n{\n\tuint64_t min_alloc = 1ULL << vd->vdev_ashift;\n\n\tif (vd->vdev_ops->vdev_op_min_alloc != NULL)\n\t\tmin_alloc = vd->vdev_ops->vdev_op_min_alloc(vd);\n\n\treturn (min_alloc);\n}\n\n \nuint64_t\nvdev_get_nparity(vdev_t *vd)\n{\n\tuint64_t nparity = 0;\n\n\tif (vd->vdev_ops->vdev_op_nparity != NULL)\n\t\tnparity = vd->vdev_ops->vdev_op_nparity(vd);\n\n\treturn (nparity);\n}\n\nstatic int\nvdev_prop_get_int(vdev_t *vd, vdev_prop_t prop, uint64_t *value)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tuint64_t objid;\n\tint err;\n\n\tif (vd->vdev_root_zap != 0) {\n\t\tobjid = vd->vdev_root_zap;\n\t} else if (vd->vdev_top_zap != 0) {\n\t\tobjid = vd->vdev_top_zap;\n\t} else if (vd->vdev_leaf_zap != 0) {\n\t\tobjid = vd->vdev_leaf_zap;\n\t} else {\n\t\treturn (EINVAL);\n\t}\n\n\terr = zap_lookup(mos, objid, vdev_prop_to_name(prop),\n\t    sizeof (uint64_t), 1, value);\n\n\tif (err == ENOENT)\n\t\t*value = vdev_prop_default_numeric(prop);\n\n\treturn (err);\n}\n\n \nuint64_t\nvdev_get_ndisks(vdev_t *vd)\n{\n\tuint64_t ndisks = 1;\n\n\tif (vd->vdev_ops->vdev_op_ndisks != NULL)\n\t\tndisks = vd->vdev_ops->vdev_op_ndisks(vd);\n\n\treturn (ndisks);\n}\n\nvdev_t *\nvdev_lookup_top(spa_t *spa, uint64_t vdev)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_READER) != 0);\n\n\tif (vdev < rvd->vdev_children) {\n\t\tASSERT(rvd->vdev_child[vdev] != NULL);\n\t\treturn (rvd->vdev_child[vdev]);\n\t}\n\n\treturn (NULL);\n}\n\nvdev_t *\nvdev_lookup_by_guid(vdev_t *vd, uint64_t guid)\n{\n\tvdev_t *mvd;\n\n\tif (vd->vdev_guid == guid)\n\t\treturn (vd);\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tif ((mvd = vdev_lookup_by_guid(vd->vdev_child[c], guid)) !=\n\t\t    NULL)\n\t\t\treturn (mvd);\n\n\treturn (NULL);\n}\n\nstatic int\nvdev_count_leaves_impl(vdev_t *vd)\n{\n\tint n = 0;\n\n\tif (vd->vdev_ops->vdev_op_leaf)\n\t\treturn (1);\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tn += vdev_count_leaves_impl(vd->vdev_child[c]);\n\n\treturn (n);\n}\n\nint\nvdev_count_leaves(spa_t *spa)\n{\n\tint rc;\n\n\tspa_config_enter(spa, SCL_VDEV, FTAG, RW_READER);\n\trc = vdev_count_leaves_impl(spa->spa_root_vdev);\n\tspa_config_exit(spa, SCL_VDEV, FTAG);\n\n\treturn (rc);\n}\n\nvoid\nvdev_add_child(vdev_t *pvd, vdev_t *cvd)\n{\n\tsize_t oldsize, newsize;\n\tuint64_t id = cvd->vdev_id;\n\tvdev_t **newchild;\n\n\tASSERT(spa_config_held(cvd->vdev_spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\tASSERT(cvd->vdev_parent == NULL);\n\n\tcvd->vdev_parent = pvd;\n\n\tif (pvd == NULL)\n\t\treturn;\n\n\tASSERT(id >= pvd->vdev_children || pvd->vdev_child[id] == NULL);\n\n\toldsize = pvd->vdev_children * sizeof (vdev_t *);\n\tpvd->vdev_children = MAX(pvd->vdev_children, id + 1);\n\tnewsize = pvd->vdev_children * sizeof (vdev_t *);\n\n\tnewchild = kmem_alloc(newsize, KM_SLEEP);\n\tif (pvd->vdev_child != NULL) {\n\t\tmemcpy(newchild, pvd->vdev_child, oldsize);\n\t\tkmem_free(pvd->vdev_child, oldsize);\n\t}\n\n\tpvd->vdev_child = newchild;\n\tpvd->vdev_child[id] = cvd;\n\n\tcvd->vdev_top = (pvd->vdev_top ? pvd->vdev_top: cvd);\n\tASSERT(cvd->vdev_top->vdev_parent->vdev_parent == NULL);\n\n\t \n\tfor (; pvd != NULL; pvd = pvd->vdev_parent)\n\t\tpvd->vdev_guid_sum += cvd->vdev_guid_sum;\n\n\tif (cvd->vdev_ops->vdev_op_leaf) {\n\t\tlist_insert_head(&cvd->vdev_spa->spa_leaf_list, cvd);\n\t\tcvd->vdev_spa->spa_leaf_list_gen++;\n\t}\n}\n\nvoid\nvdev_remove_child(vdev_t *pvd, vdev_t *cvd)\n{\n\tint c;\n\tuint_t id = cvd->vdev_id;\n\n\tASSERT(cvd->vdev_parent == pvd);\n\n\tif (pvd == NULL)\n\t\treturn;\n\n\tASSERT(id < pvd->vdev_children);\n\tASSERT(pvd->vdev_child[id] == cvd);\n\n\tpvd->vdev_child[id] = NULL;\n\tcvd->vdev_parent = NULL;\n\n\tfor (c = 0; c < pvd->vdev_children; c++)\n\t\tif (pvd->vdev_child[c])\n\t\t\tbreak;\n\n\tif (c == pvd->vdev_children) {\n\t\tkmem_free(pvd->vdev_child, c * sizeof (vdev_t *));\n\t\tpvd->vdev_child = NULL;\n\t\tpvd->vdev_children = 0;\n\t}\n\n\tif (cvd->vdev_ops->vdev_op_leaf) {\n\t\tspa_t *spa = cvd->vdev_spa;\n\t\tlist_remove(&spa->spa_leaf_list, cvd);\n\t\tspa->spa_leaf_list_gen++;\n\t}\n\n\t \n\tfor (; pvd != NULL; pvd = pvd->vdev_parent)\n\t\tpvd->vdev_guid_sum -= cvd->vdev_guid_sum;\n}\n\n \nvoid\nvdev_compact_children(vdev_t *pvd)\n{\n\tvdev_t **newchild, *cvd;\n\tint oldc = pvd->vdev_children;\n\tint newc;\n\n\tASSERT(spa_config_held(pvd->vdev_spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tif (oldc == 0)\n\t\treturn;\n\n\tfor (int c = newc = 0; c < oldc; c++)\n\t\tif (pvd->vdev_child[c])\n\t\t\tnewc++;\n\n\tif (newc > 0) {\n\t\tnewchild = kmem_zalloc(newc * sizeof (vdev_t *), KM_SLEEP);\n\n\t\tfor (int c = newc = 0; c < oldc; c++) {\n\t\t\tif ((cvd = pvd->vdev_child[c]) != NULL) {\n\t\t\t\tnewchild[newc] = cvd;\n\t\t\t\tcvd->vdev_id = newc++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnewchild = NULL;\n\t}\n\n\tkmem_free(pvd->vdev_child, oldc * sizeof (vdev_t *));\n\tpvd->vdev_child = newchild;\n\tpvd->vdev_children = newc;\n}\n\n \nvdev_t *\nvdev_alloc_common(spa_t *spa, uint_t id, uint64_t guid, vdev_ops_t *ops)\n{\n\tvdev_t *vd;\n\tvdev_indirect_config_t *vic;\n\n\tvd = kmem_zalloc(sizeof (vdev_t), KM_SLEEP);\n\tvic = &vd->vdev_indirect_config;\n\n\tif (spa->spa_root_vdev == NULL) {\n\t\tASSERT(ops == &vdev_root_ops);\n\t\tspa->spa_root_vdev = vd;\n\t\tspa->spa_load_guid = spa_generate_guid(NULL);\n\t}\n\n\tif (guid == 0 && ops != &vdev_hole_ops) {\n\t\tif (spa->spa_root_vdev == vd) {\n\t\t\t \n\t\t\tguid = spa_generate_guid(NULL);\n\t\t} else {\n\t\t\t \n\t\t\tguid = spa_generate_guid(spa);\n\t\t}\n\t\tASSERT(!spa_guid_exists(spa_guid(spa), guid));\n\t}\n\n\tvd->vdev_spa = spa;\n\tvd->vdev_id = id;\n\tvd->vdev_guid = guid;\n\tvd->vdev_guid_sum = guid;\n\tvd->vdev_ops = ops;\n\tvd->vdev_state = VDEV_STATE_CLOSED;\n\tvd->vdev_ishole = (ops == &vdev_hole_ops);\n\tvic->vic_prev_indirect_vdev = UINT64_MAX;\n\n\trw_init(&vd->vdev_indirect_rwlock, NULL, RW_DEFAULT, NULL);\n\tmutex_init(&vd->vdev_obsolete_lock, NULL, MUTEX_DEFAULT, NULL);\n\tvd->vdev_obsolete_segments = range_tree_create(NULL, RANGE_SEG64, NULL,\n\t    0, 0);\n\n\t \n\tzfs_ratelimit_init(&vd->vdev_delay_rl, &zfs_slow_io_events_per_second,\n\t    1);\n\tzfs_ratelimit_init(&vd->vdev_deadman_rl, &zfs_slow_io_events_per_second,\n\t    1);\n\tzfs_ratelimit_init(&vd->vdev_checksum_rl,\n\t    &zfs_checksum_events_per_second, 1);\n\n\t \n\tvd->vdev_checksum_n = vdev_prop_default_numeric(VDEV_PROP_CHECKSUM_N);\n\tvd->vdev_checksum_t = vdev_prop_default_numeric(VDEV_PROP_CHECKSUM_T);\n\tvd->vdev_io_n = vdev_prop_default_numeric(VDEV_PROP_IO_N);\n\tvd->vdev_io_t = vdev_prop_default_numeric(VDEV_PROP_IO_T);\n\n\tlist_link_init(&vd->vdev_config_dirty_node);\n\tlist_link_init(&vd->vdev_state_dirty_node);\n\tlist_link_init(&vd->vdev_initialize_node);\n\tlist_link_init(&vd->vdev_leaf_node);\n\tlist_link_init(&vd->vdev_trim_node);\n\n\tmutex_init(&vd->vdev_dtl_lock, NULL, MUTEX_NOLOCKDEP, NULL);\n\tmutex_init(&vd->vdev_stat_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&vd->vdev_probe_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&vd->vdev_scan_io_queue_lock, NULL, MUTEX_DEFAULT, NULL);\n\n\tmutex_init(&vd->vdev_initialize_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&vd->vdev_initialize_io_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&vd->vdev_initialize_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&vd->vdev_initialize_io_cv, NULL, CV_DEFAULT, NULL);\n\n\tmutex_init(&vd->vdev_trim_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&vd->vdev_autotrim_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&vd->vdev_trim_io_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&vd->vdev_trim_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&vd->vdev_autotrim_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&vd->vdev_autotrim_kick_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&vd->vdev_trim_io_cv, NULL, CV_DEFAULT, NULL);\n\n\tmutex_init(&vd->vdev_rebuild_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&vd->vdev_rebuild_cv, NULL, CV_DEFAULT, NULL);\n\n\tfor (int t = 0; t < DTL_TYPES; t++) {\n\t\tvd->vdev_dtl[t] = range_tree_create(NULL, RANGE_SEG64, NULL, 0,\n\t\t    0);\n\t}\n\n\ttxg_list_create(&vd->vdev_ms_list, spa,\n\t    offsetof(struct metaslab, ms_txg_node));\n\ttxg_list_create(&vd->vdev_dtl_list, spa,\n\t    offsetof(struct vdev, vdev_dtl_node));\n\tvd->vdev_stat.vs_timestamp = gethrtime();\n\tvdev_queue_init(vd);\n\n\treturn (vd);\n}\n\n \nint\nvdev_alloc(spa_t *spa, vdev_t **vdp, nvlist_t *nv, vdev_t *parent, uint_t id,\n    int alloctype)\n{\n\tvdev_ops_t *ops;\n\tconst char *type;\n\tuint64_t guid = 0, islog;\n\tvdev_t *vd;\n\tvdev_indirect_config_t *vic;\n\tconst char *tmp = NULL;\n\tint rc;\n\tvdev_alloc_bias_t alloc_bias = VDEV_BIAS_NONE;\n\tboolean_t top_level = (parent && !parent->vdev_parent);\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_TYPE, &type) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((ops = vdev_getops(type)) == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (alloctype == VDEV_ALLOC_LOAD) {\n\t\tuint64_t label_id;\n\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_ID, &label_id) ||\n\t\t    label_id != id)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t} else if (alloctype == VDEV_ALLOC_SPARE) {\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t} else if (alloctype == VDEV_ALLOC_L2CACHE) {\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t} else if (alloctype == VDEV_ALLOC_ROOTPOOL) {\n\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_GUID, &guid) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (ops != &vdev_root_ops && spa->spa_root_vdev == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tislog = 0;\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_IS_LOG, &islog);\n\tif (islog && spa_version(spa) < SPA_VERSION_SLOGS)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (ops == &vdev_hole_ops && spa_version(spa) < SPA_VERSION_HOLES)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (top_level && alloctype == VDEV_ALLOC_ADD) {\n\t\tconst char *bias;\n\n\t\t \n\t\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t    &bias) == 0) {\n\t\t\talloc_bias = vdev_derive_alloc_bias(bias);\n\n\t\t\t \n\t\t\tif (spa->spa_load_state != SPA_LOAD_CREATE &&\n\t\t\t    !spa_feature_is_enabled(spa,\n\t\t\t    SPA_FEATURE_ALLOCATION_CLASSES)) {\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ops == &vdev_draid_ops &&\n\t\t    spa->spa_load_state != SPA_LOAD_CREATE &&\n\t\t    !spa_feature_is_enabled(spa, SPA_FEATURE_DRAID)) {\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t}\n\t}\n\n\t \n\tvoid *tsd = NULL;\n\tif (ops->vdev_op_init != NULL) {\n\t\trc = ops->vdev_op_init(spa, nv, &tsd);\n\t\tif (rc != 0) {\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\tvd = vdev_alloc_common(spa, id, guid, ops);\n\tvd->vdev_tsd = tsd;\n\tvd->vdev_islog = islog;\n\n\tif (top_level && alloc_bias != VDEV_BIAS_NONE)\n\t\tvd->vdev_alloc_bias = alloc_bias;\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &tmp) == 0)\n\t\tvd->vdev_path = spa_strdup(tmp);\n\n\t \n\trc = nvlist_lookup_string(nv, ZPOOL_CONFIG_AUX_STATE, &tmp);\n\tif (rc == 0 && tmp != NULL && strcmp(tmp, \"external\") == 0) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_EXTERNAL;\n\t\tvd->vdev_faulted = 1;\n\t\tvd->vdev_label_aux = VDEV_AUX_EXTERNAL;\n\t}\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_DEVID, &tmp) == 0)\n\t\tvd->vdev_devid = spa_strdup(tmp);\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_PHYS_PATH, &tmp) == 0)\n\t\tvd->vdev_physpath = spa_strdup(tmp);\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_VDEV_ENC_SYSFS_PATH,\n\t    &tmp) == 0)\n\t\tvd->vdev_enc_sysfs_path = spa_strdup(tmp);\n\n\tif (nvlist_lookup_string(nv, ZPOOL_CONFIG_FRU, &tmp) == 0)\n\t\tvd->vdev_fru = spa_strdup(tmp);\n\n\t \n\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_WHOLE_DISK,\n\t    &vd->vdev_wholedisk) != 0)\n\t\tvd->vdev_wholedisk = -1ULL;\n\n\tvic = &vd->vdev_indirect_config;\n\n\tASSERT0(vic->vic_mapping_object);\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_INDIRECT_OBJECT,\n\t    &vic->vic_mapping_object);\n\tASSERT0(vic->vic_births_object);\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_INDIRECT_BIRTHS,\n\t    &vic->vic_births_object);\n\tASSERT3U(vic->vic_prev_indirect_vdev, ==, UINT64_MAX);\n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_PREV_INDIRECT_VDEV,\n\t    &vic->vic_prev_indirect_vdev);\n\n\t \n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NOT_PRESENT,\n\t    &vd->vdev_not_present);\n\n\t \n\tif (alloctype != VDEV_ALLOC_ATTACH) {\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_ASHIFT,\n\t\t    &vd->vdev_ashift);\n\t} else {\n\t\tvd->vdev_attaching = B_TRUE;\n\t}\n\n\t \n\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_CREATE_TXG,\n\t    &vd->vdev_crtxg);\n\n\tif (vd->vdev_ops == &vdev_root_ops &&\n\t    (alloctype == VDEV_ALLOC_LOAD ||\n\t    alloctype == VDEV_ALLOC_SPLIT ||\n\t    alloctype == VDEV_ALLOC_ROOTPOOL)) {\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_VDEV_ROOT_ZAP,\n\t\t    &vd->vdev_root_zap);\n\t}\n\n\t \n\tif (top_level &&\n\t    (alloctype == VDEV_ALLOC_LOAD || alloctype == VDEV_ALLOC_SPLIT)) {\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_METASLAB_ARRAY,\n\t\t    &vd->vdev_ms_array);\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_METASLAB_SHIFT,\n\t\t    &vd->vdev_ms_shift);\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_ASIZE,\n\t\t    &vd->vdev_asize);\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_NONALLOCATING,\n\t\t    &vd->vdev_noalloc);\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_REMOVING,\n\t\t    &vd->vdev_removing);\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_VDEV_TOP_ZAP,\n\t\t    &vd->vdev_top_zap);\n\t} else {\n\t\tASSERT0(vd->vdev_top_zap);\n\t}\n\n\tif (top_level && alloctype != VDEV_ALLOC_ATTACH) {\n\t\tASSERT(alloctype == VDEV_ALLOC_LOAD ||\n\t\t    alloctype == VDEV_ALLOC_ADD ||\n\t\t    alloctype == VDEV_ALLOC_SPLIT ||\n\t\t    alloctype == VDEV_ALLOC_ROOTPOOL);\n\t\t \n\t}\n\n\tif (vd->vdev_ops->vdev_op_leaf &&\n\t    (alloctype == VDEV_ALLOC_LOAD || alloctype == VDEV_ALLOC_SPLIT)) {\n\t\t(void) nvlist_lookup_uint64(nv,\n\t\t    ZPOOL_CONFIG_VDEV_LEAF_ZAP, &vd->vdev_leaf_zap);\n\t} else {\n\t\tASSERT0(vd->vdev_leaf_zap);\n\t}\n\n\t \n\n\tif (vd->vdev_ops->vdev_op_leaf &&\n\t    (alloctype == VDEV_ALLOC_LOAD || alloctype == VDEV_ALLOC_L2CACHE ||\n\t    alloctype == VDEV_ALLOC_ROOTPOOL)) {\n\t\tif (alloctype == VDEV_ALLOC_LOAD) {\n\t\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_DTL,\n\t\t\t    &vd->vdev_dtl_object);\n\t\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_UNSPARE,\n\t\t\t    &vd->vdev_unspare);\n\t\t}\n\n\t\tif (alloctype == VDEV_ALLOC_ROOTPOOL) {\n\t\t\tuint64_t spare = 0;\n\n\t\t\tif (nvlist_lookup_uint64(nv, ZPOOL_CONFIG_IS_SPARE,\n\t\t\t    &spare) == 0 && spare)\n\t\t\t\tspa_spare_add(vd);\n\t\t}\n\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_OFFLINE,\n\t\t    &vd->vdev_offline);\n\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_RESILVER_TXG,\n\t\t    &vd->vdev_resilver_txg);\n\n\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_REBUILD_TXG,\n\t\t    &vd->vdev_rebuild_txg);\n\n\t\tif (nvlist_exists(nv, ZPOOL_CONFIG_RESILVER_DEFER))\n\t\t\tvdev_defer_resilver(vd);\n\n\t\t \n\t\tif (spa_load_state(spa) == SPA_LOAD_OPEN ||\n\t\t    spa_load_state(spa) == SPA_LOAD_IMPORT) {\n\t\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_FAULTED,\n\t\t\t    &vd->vdev_faulted);\n\t\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_DEGRADED,\n\t\t\t    &vd->vdev_degraded);\n\t\t\t(void) nvlist_lookup_uint64(nv, ZPOOL_CONFIG_REMOVED,\n\t\t\t    &vd->vdev_removed);\n\n\t\t\tif (vd->vdev_faulted || vd->vdev_degraded) {\n\t\t\t\tconst char *aux;\n\n\t\t\t\tvd->vdev_label_aux =\n\t\t\t\t    VDEV_AUX_ERR_EXCEEDED;\n\t\t\t\tif (nvlist_lookup_string(nv,\n\t\t\t\t    ZPOOL_CONFIG_AUX_STATE, &aux) == 0 &&\n\t\t\t\t    strcmp(aux, \"external\") == 0)\n\t\t\t\t\tvd->vdev_label_aux = VDEV_AUX_EXTERNAL;\n\t\t\t\telse\n\t\t\t\t\tvd->vdev_faulted = 0ULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tvdev_add_child(parent, vd);\n\n\t*vdp = vd;\n\n\treturn (0);\n}\n\nvoid\nvdev_free(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT3P(vd->vdev_initialize_thread, ==, NULL);\n\tASSERT3P(vd->vdev_trim_thread, ==, NULL);\n\tASSERT3P(vd->vdev_autotrim_thread, ==, NULL);\n\tASSERT3P(vd->vdev_rebuild_thread, ==, NULL);\n\n\t \n\tif (vd->vdev_scan_io_queue != NULL) {\n\t\tmutex_enter(&vd->vdev_scan_io_queue_lock);\n\t\tdsl_scan_io_queue_destroy(vd->vdev_scan_io_queue);\n\t\tvd->vdev_scan_io_queue = NULL;\n\t\tmutex_exit(&vd->vdev_scan_io_queue_lock);\n\t}\n\n\t \n\tvdev_close(vd);\n\n\tASSERT(!list_link_active(&vd->vdev_config_dirty_node));\n\tASSERT(!list_link_active(&vd->vdev_state_dirty_node));\n\n\t \n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_free(vd->vdev_child[c]);\n\n\tASSERT(vd->vdev_child == NULL);\n\tASSERT(vd->vdev_guid_sum == vd->vdev_guid);\n\n\tif (vd->vdev_ops->vdev_op_fini != NULL)\n\t\tvd->vdev_ops->vdev_op_fini(vd);\n\n\t \n\tif (vd->vdev_mg != NULL) {\n\t\tvdev_metaslab_fini(vd);\n\t\tmetaslab_group_destroy(vd->vdev_mg);\n\t\tvd->vdev_mg = NULL;\n\t}\n\tif (vd->vdev_log_mg != NULL) {\n\t\tASSERT0(vd->vdev_ms_count);\n\t\tmetaslab_group_destroy(vd->vdev_log_mg);\n\t\tvd->vdev_log_mg = NULL;\n\t}\n\n\tASSERT0(vd->vdev_stat.vs_space);\n\tASSERT0(vd->vdev_stat.vs_dspace);\n\tASSERT0(vd->vdev_stat.vs_alloc);\n\n\t \n\tvdev_remove_child(vd->vdev_parent, vd);\n\n\tASSERT(vd->vdev_parent == NULL);\n\tASSERT(!list_link_active(&vd->vdev_leaf_node));\n\n\t \n\tvdev_queue_fini(vd);\n\n\tif (vd->vdev_path)\n\t\tspa_strfree(vd->vdev_path);\n\tif (vd->vdev_devid)\n\t\tspa_strfree(vd->vdev_devid);\n\tif (vd->vdev_physpath)\n\t\tspa_strfree(vd->vdev_physpath);\n\n\tif (vd->vdev_enc_sysfs_path)\n\t\tspa_strfree(vd->vdev_enc_sysfs_path);\n\n\tif (vd->vdev_fru)\n\t\tspa_strfree(vd->vdev_fru);\n\n\tif (vd->vdev_isspare)\n\t\tspa_spare_remove(vd);\n\tif (vd->vdev_isl2cache)\n\t\tspa_l2cache_remove(vd);\n\n\ttxg_list_destroy(&vd->vdev_ms_list);\n\ttxg_list_destroy(&vd->vdev_dtl_list);\n\n\tmutex_enter(&vd->vdev_dtl_lock);\n\tspace_map_close(vd->vdev_dtl_sm);\n\tfor (int t = 0; t < DTL_TYPES; t++) {\n\t\trange_tree_vacate(vd->vdev_dtl[t], NULL, NULL);\n\t\trange_tree_destroy(vd->vdev_dtl[t]);\n\t}\n\tmutex_exit(&vd->vdev_dtl_lock);\n\n\tEQUIV(vd->vdev_indirect_births != NULL,\n\t    vd->vdev_indirect_mapping != NULL);\n\tif (vd->vdev_indirect_births != NULL) {\n\t\tvdev_indirect_mapping_close(vd->vdev_indirect_mapping);\n\t\tvdev_indirect_births_close(vd->vdev_indirect_births);\n\t}\n\n\tif (vd->vdev_obsolete_sm != NULL) {\n\t\tASSERT(vd->vdev_removing ||\n\t\t    vd->vdev_ops == &vdev_indirect_ops);\n\t\tspace_map_close(vd->vdev_obsolete_sm);\n\t\tvd->vdev_obsolete_sm = NULL;\n\t}\n\trange_tree_destroy(vd->vdev_obsolete_segments);\n\trw_destroy(&vd->vdev_indirect_rwlock);\n\tmutex_destroy(&vd->vdev_obsolete_lock);\n\n\tmutex_destroy(&vd->vdev_dtl_lock);\n\tmutex_destroy(&vd->vdev_stat_lock);\n\tmutex_destroy(&vd->vdev_probe_lock);\n\tmutex_destroy(&vd->vdev_scan_io_queue_lock);\n\n\tmutex_destroy(&vd->vdev_initialize_lock);\n\tmutex_destroy(&vd->vdev_initialize_io_lock);\n\tcv_destroy(&vd->vdev_initialize_io_cv);\n\tcv_destroy(&vd->vdev_initialize_cv);\n\n\tmutex_destroy(&vd->vdev_trim_lock);\n\tmutex_destroy(&vd->vdev_autotrim_lock);\n\tmutex_destroy(&vd->vdev_trim_io_lock);\n\tcv_destroy(&vd->vdev_trim_cv);\n\tcv_destroy(&vd->vdev_autotrim_cv);\n\tcv_destroy(&vd->vdev_autotrim_kick_cv);\n\tcv_destroy(&vd->vdev_trim_io_cv);\n\n\tmutex_destroy(&vd->vdev_rebuild_lock);\n\tcv_destroy(&vd->vdev_rebuild_cv);\n\n\tzfs_ratelimit_fini(&vd->vdev_delay_rl);\n\tzfs_ratelimit_fini(&vd->vdev_deadman_rl);\n\tzfs_ratelimit_fini(&vd->vdev_checksum_rl);\n\n\tif (vd == spa->spa_root_vdev)\n\t\tspa->spa_root_vdev = NULL;\n\n\tkmem_free(vd, sizeof (vdev_t));\n}\n\n \nstatic void\nvdev_top_transfer(vdev_t *svd, vdev_t *tvd)\n{\n\tspa_t *spa = svd->vdev_spa;\n\tmetaslab_t *msp;\n\tvdev_t *vd;\n\tint t;\n\n\tASSERT(tvd == tvd->vdev_top);\n\n\ttvd->vdev_ms_array = svd->vdev_ms_array;\n\ttvd->vdev_ms_shift = svd->vdev_ms_shift;\n\ttvd->vdev_ms_count = svd->vdev_ms_count;\n\ttvd->vdev_top_zap = svd->vdev_top_zap;\n\n\tsvd->vdev_ms_array = 0;\n\tsvd->vdev_ms_shift = 0;\n\tsvd->vdev_ms_count = 0;\n\tsvd->vdev_top_zap = 0;\n\n\tif (tvd->vdev_mg)\n\t\tASSERT3P(tvd->vdev_mg, ==, svd->vdev_mg);\n\tif (tvd->vdev_log_mg)\n\t\tASSERT3P(tvd->vdev_log_mg, ==, svd->vdev_log_mg);\n\ttvd->vdev_mg = svd->vdev_mg;\n\ttvd->vdev_log_mg = svd->vdev_log_mg;\n\ttvd->vdev_ms = svd->vdev_ms;\n\n\tsvd->vdev_mg = NULL;\n\tsvd->vdev_log_mg = NULL;\n\tsvd->vdev_ms = NULL;\n\n\tif (tvd->vdev_mg != NULL)\n\t\ttvd->vdev_mg->mg_vd = tvd;\n\tif (tvd->vdev_log_mg != NULL)\n\t\ttvd->vdev_log_mg->mg_vd = tvd;\n\n\ttvd->vdev_checkpoint_sm = svd->vdev_checkpoint_sm;\n\tsvd->vdev_checkpoint_sm = NULL;\n\n\ttvd->vdev_alloc_bias = svd->vdev_alloc_bias;\n\tsvd->vdev_alloc_bias = VDEV_BIAS_NONE;\n\n\ttvd->vdev_stat.vs_alloc = svd->vdev_stat.vs_alloc;\n\ttvd->vdev_stat.vs_space = svd->vdev_stat.vs_space;\n\ttvd->vdev_stat.vs_dspace = svd->vdev_stat.vs_dspace;\n\n\tsvd->vdev_stat.vs_alloc = 0;\n\tsvd->vdev_stat.vs_space = 0;\n\tsvd->vdev_stat.vs_dspace = 0;\n\n\t \n\tASSERT0(tvd->vdev_indirect_config.vic_births_object);\n\tASSERT0(tvd->vdev_indirect_config.vic_mapping_object);\n\tASSERT3U(tvd->vdev_indirect_config.vic_prev_indirect_vdev, ==, -1ULL);\n\tASSERT3P(tvd->vdev_indirect_mapping, ==, NULL);\n\tASSERT3P(tvd->vdev_indirect_births, ==, NULL);\n\tASSERT3P(tvd->vdev_obsolete_sm, ==, NULL);\n\tASSERT0(tvd->vdev_noalloc);\n\tASSERT0(tvd->vdev_removing);\n\tASSERT0(tvd->vdev_rebuilding);\n\ttvd->vdev_noalloc = svd->vdev_noalloc;\n\ttvd->vdev_removing = svd->vdev_removing;\n\ttvd->vdev_rebuilding = svd->vdev_rebuilding;\n\ttvd->vdev_rebuild_config = svd->vdev_rebuild_config;\n\ttvd->vdev_indirect_config = svd->vdev_indirect_config;\n\ttvd->vdev_indirect_mapping = svd->vdev_indirect_mapping;\n\ttvd->vdev_indirect_births = svd->vdev_indirect_births;\n\trange_tree_swap(&svd->vdev_obsolete_segments,\n\t    &tvd->vdev_obsolete_segments);\n\ttvd->vdev_obsolete_sm = svd->vdev_obsolete_sm;\n\tsvd->vdev_indirect_config.vic_mapping_object = 0;\n\tsvd->vdev_indirect_config.vic_births_object = 0;\n\tsvd->vdev_indirect_config.vic_prev_indirect_vdev = -1ULL;\n\tsvd->vdev_indirect_mapping = NULL;\n\tsvd->vdev_indirect_births = NULL;\n\tsvd->vdev_obsolete_sm = NULL;\n\tsvd->vdev_noalloc = 0;\n\tsvd->vdev_removing = 0;\n\tsvd->vdev_rebuilding = 0;\n\n\tfor (t = 0; t < TXG_SIZE; t++) {\n\t\twhile ((msp = txg_list_remove(&svd->vdev_ms_list, t)) != NULL)\n\t\t\t(void) txg_list_add(&tvd->vdev_ms_list, msp, t);\n\t\twhile ((vd = txg_list_remove(&svd->vdev_dtl_list, t)) != NULL)\n\t\t\t(void) txg_list_add(&tvd->vdev_dtl_list, vd, t);\n\t\tif (txg_list_remove_this(&spa->spa_vdev_txg_list, svd, t))\n\t\t\t(void) txg_list_add(&spa->spa_vdev_txg_list, tvd, t);\n\t}\n\n\tif (list_link_active(&svd->vdev_config_dirty_node)) {\n\t\tvdev_config_clean(svd);\n\t\tvdev_config_dirty(tvd);\n\t}\n\n\tif (list_link_active(&svd->vdev_state_dirty_node)) {\n\t\tvdev_state_clean(svd);\n\t\tvdev_state_dirty(tvd);\n\t}\n\n\ttvd->vdev_deflate_ratio = svd->vdev_deflate_ratio;\n\tsvd->vdev_deflate_ratio = 0;\n\n\ttvd->vdev_islog = svd->vdev_islog;\n\tsvd->vdev_islog = 0;\n\n\tdsl_scan_io_queue_vdev_xfer(svd, tvd);\n}\n\nstatic void\nvdev_top_update(vdev_t *tvd, vdev_t *vd)\n{\n\tif (vd == NULL)\n\t\treturn;\n\n\tvd->vdev_top = tvd;\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_top_update(tvd, vd->vdev_child[c]);\n}\n\n \nvdev_t *\nvdev_add_parent(vdev_t *cvd, vdev_ops_t *ops)\n{\n\tspa_t *spa = cvd->vdev_spa;\n\tvdev_t *pvd = cvd->vdev_parent;\n\tvdev_t *mvd;\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tmvd = vdev_alloc_common(spa, cvd->vdev_id, 0, ops);\n\n\tmvd->vdev_asize = cvd->vdev_asize;\n\tmvd->vdev_min_asize = cvd->vdev_min_asize;\n\tmvd->vdev_max_asize = cvd->vdev_max_asize;\n\tmvd->vdev_psize = cvd->vdev_psize;\n\tmvd->vdev_ashift = cvd->vdev_ashift;\n\tmvd->vdev_logical_ashift = cvd->vdev_logical_ashift;\n\tmvd->vdev_physical_ashift = cvd->vdev_physical_ashift;\n\tmvd->vdev_state = cvd->vdev_state;\n\tmvd->vdev_crtxg = cvd->vdev_crtxg;\n\n\tvdev_remove_child(pvd, cvd);\n\tvdev_add_child(pvd, mvd);\n\tcvd->vdev_id = mvd->vdev_children;\n\tvdev_add_child(mvd, cvd);\n\tvdev_top_update(cvd->vdev_top, cvd->vdev_top);\n\n\tif (mvd == mvd->vdev_top)\n\t\tvdev_top_transfer(cvd, mvd);\n\n\treturn (mvd);\n}\n\n \nvoid\nvdev_remove_parent(vdev_t *cvd)\n{\n\tvdev_t *mvd = cvd->vdev_parent;\n\tvdev_t *pvd = mvd->vdev_parent;\n\n\tASSERT(spa_config_held(cvd->vdev_spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\n\tASSERT(mvd->vdev_children == 1);\n\tASSERT(mvd->vdev_ops == &vdev_mirror_ops ||\n\t    mvd->vdev_ops == &vdev_replacing_ops ||\n\t    mvd->vdev_ops == &vdev_spare_ops);\n\tcvd->vdev_ashift = mvd->vdev_ashift;\n\tcvd->vdev_logical_ashift = mvd->vdev_logical_ashift;\n\tcvd->vdev_physical_ashift = mvd->vdev_physical_ashift;\n\tvdev_remove_child(mvd, cvd);\n\tvdev_remove_child(pvd, mvd);\n\n\t \n\tif (mvd->vdev_top == mvd) {\n\t\tuint64_t guid_delta = mvd->vdev_guid - cvd->vdev_guid;\n\t\tcvd->vdev_orig_guid = cvd->vdev_guid;\n\t\tcvd->vdev_guid += guid_delta;\n\t\tcvd->vdev_guid_sum += guid_delta;\n\n\t\t \n\t\tif (!cvd->vdev_spa->spa_autoexpand)\n\t\t\tcvd->vdev_asize = mvd->vdev_asize;\n\t}\n\tcvd->vdev_id = mvd->vdev_id;\n\tvdev_add_child(pvd, cvd);\n\tvdev_top_update(cvd->vdev_top, cvd->vdev_top);\n\n\tif (cvd == cvd->vdev_top)\n\t\tvdev_top_transfer(mvd, cvd);\n\n\tASSERT(mvd->vdev_children == 0);\n\tvdev_free(mvd);\n}\n\n \nstatic uint64_t\nvdev_gcd(uint64_t a, uint64_t b)\n{\n\twhile (b != 0) {\n\t\tuint64_t t = b;\n\t\tb = a % b;\n\t\ta = t;\n\t}\n\treturn (a);\n}\n\n \nstatic void\nvdev_spa_set_alloc(spa_t *spa, uint64_t min_alloc)\n{\n\tif (min_alloc < spa->spa_min_alloc)\n\t\tspa->spa_min_alloc = min_alloc;\n\tif (spa->spa_gcd_alloc == INT_MAX) {\n\t\tspa->spa_gcd_alloc = min_alloc;\n\t} else {\n\t\tspa->spa_gcd_alloc = vdev_gcd(min_alloc,\n\t\t    spa->spa_gcd_alloc);\n\t}\n}\n\nvoid\nvdev_metaslab_group_create(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\t \n\tif (vd->vdev_mg == NULL) {\n\t\tmetaslab_class_t *mc;\n\n\t\tif (vd->vdev_islog && vd->vdev_alloc_bias == VDEV_BIAS_NONE)\n\t\t\tvd->vdev_alloc_bias = VDEV_BIAS_LOG;\n\n\t\tASSERT3U(vd->vdev_islog, ==,\n\t\t    (vd->vdev_alloc_bias == VDEV_BIAS_LOG));\n\n\t\tswitch (vd->vdev_alloc_bias) {\n\t\tcase VDEV_BIAS_LOG:\n\t\t\tmc = spa_log_class(spa);\n\t\t\tbreak;\n\t\tcase VDEV_BIAS_SPECIAL:\n\t\t\tmc = spa_special_class(spa);\n\t\t\tbreak;\n\t\tcase VDEV_BIAS_DEDUP:\n\t\t\tmc = spa_dedup_class(spa);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmc = spa_normal_class(spa);\n\t\t}\n\n\t\tvd->vdev_mg = metaslab_group_create(mc, vd,\n\t\t    spa->spa_alloc_count);\n\n\t\tif (!vd->vdev_islog) {\n\t\t\tvd->vdev_log_mg = metaslab_group_create(\n\t\t\t    spa_embedded_log_class(spa), vd, 1);\n\t\t}\n\n\t\t \n\t\tif (vd->vdev_top == vd && vd->vdev_ashift != 0 &&\n\t\t    mc == spa_normal_class(spa) && vd->vdev_aux == NULL) {\n\t\t\tif (vd->vdev_ashift > spa->spa_max_ashift)\n\t\t\t\tspa->spa_max_ashift = vd->vdev_ashift;\n\t\t\tif (vd->vdev_ashift < spa->spa_min_ashift)\n\t\t\t\tspa->spa_min_ashift = vd->vdev_ashift;\n\n\t\t\tuint64_t min_alloc = vdev_get_min_alloc(vd);\n\t\t\tvdev_spa_set_alloc(spa, min_alloc);\n\t\t}\n\t}\n}\n\nint\nvdev_metaslab_init(vdev_t *vd, uint64_t txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tuint64_t oldc = vd->vdev_ms_count;\n\tuint64_t newc = vd->vdev_asize >> vd->vdev_ms_shift;\n\tmetaslab_t **mspp;\n\tint error;\n\tboolean_t expanding = (oldc != 0);\n\n\tASSERT(txg == 0 || spa_config_held(spa, SCL_ALLOC, RW_WRITER));\n\n\t \n\tif (vd->vdev_ms_shift == 0)\n\t\treturn (0);\n\n\tASSERT(!vd->vdev_ishole);\n\n\tASSERT(oldc <= newc);\n\n\tmspp = vmem_zalloc(newc * sizeof (*mspp), KM_SLEEP);\n\n\tif (expanding) {\n\t\tmemcpy(mspp, vd->vdev_ms, oldc * sizeof (*mspp));\n\t\tvmem_free(vd->vdev_ms, oldc * sizeof (*mspp));\n\t}\n\n\tvd->vdev_ms = mspp;\n\tvd->vdev_ms_count = newc;\n\n\tfor (uint64_t m = oldc; m < newc; m++) {\n\t\tuint64_t object = 0;\n\t\t \n\t\tif (txg == 0 && vd->vdev_ms_array != 0) {\n\t\t\terror = dmu_read(spa->spa_meta_objset,\n\t\t\t    vd->vdev_ms_array,\n\t\t\t    m * sizeof (uint64_t), sizeof (uint64_t), &object,\n\t\t\t    DMU_READ_PREFETCH);\n\t\t\tif (error != 0) {\n\t\t\t\tvdev_dbgmsg(vd, \"unable to read the metaslab \"\n\t\t\t\t    \"array [error=%d]\", error);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\terror = metaslab_init(vd->vdev_mg, m, object, txg,\n\t\t    &(vd->vdev_ms[m]));\n\t\tif (error != 0) {\n\t\t\tvdev_dbgmsg(vd, \"metaslab_init failed [error=%d]\",\n\t\t\t    error);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t \n\tif (vd->vdev_mg->mg_class == spa_normal_class(spa) &&\n\t    vd->vdev_ms_count > zfs_embedded_slog_min_ms &&\n\t    avl_is_empty(&vd->vdev_log_mg->mg_metaslab_tree)) {\n\t\tuint64_t slog_msid = 0;\n\t\tuint64_t smallest = UINT64_MAX;\n\n\t\t \n\t\tfor (uint64_t m = oldc; m < newc; m++) {\n\t\t\tuint64_t alloc =\n\t\t\t    space_map_allocated(vd->vdev_ms[m]->ms_sm);\n\t\t\tif (alloc < smallest) {\n\t\t\t\tslog_msid = m;\n\t\t\t\tsmallest = alloc;\n\t\t\t}\n\t\t}\n\t\tmetaslab_t *slog_ms = vd->vdev_ms[slog_msid];\n\t\t \n\t\tif (txg != 0) {\n\t\t\t(void) txg_list_remove_this(&vd->vdev_ms_list,\n\t\t\t    slog_ms, txg);\n\t\t}\n\t\tuint64_t sm_obj = space_map_object(slog_ms->ms_sm);\n\t\tmetaslab_fini(slog_ms);\n\t\tVERIFY0(metaslab_init(vd->vdev_log_mg, slog_msid, sm_obj, txg,\n\t\t    &vd->vdev_ms[slog_msid]));\n\t}\n\n\tif (txg == 0)\n\t\tspa_config_enter(spa, SCL_ALLOC, FTAG, RW_WRITER);\n\n\t \n\tif (vd->vdev_noalloc) {\n\t\t \n\t\tspa->spa_nonallocating_dspace += spa_deflate(spa) ?\n\t\t    vd->vdev_stat.vs_dspace : vd->vdev_stat.vs_space;\n\t} else if (!expanding) {\n\t\tmetaslab_group_activate(vd->vdev_mg);\n\t\tif (vd->vdev_log_mg != NULL)\n\t\t\tmetaslab_group_activate(vd->vdev_log_mg);\n\t}\n\n\tif (txg == 0)\n\t\tspa_config_exit(spa, SCL_ALLOC, FTAG);\n\n\treturn (0);\n}\n\nvoid\nvdev_metaslab_fini(vdev_t *vd)\n{\n\tif (vd->vdev_checkpoint_sm != NULL) {\n\t\tASSERT(spa_feature_is_active(vd->vdev_spa,\n\t\t    SPA_FEATURE_POOL_CHECKPOINT));\n\t\tspace_map_close(vd->vdev_checkpoint_sm);\n\t\t \n\t\tvd->vdev_checkpoint_sm = NULL;\n\t}\n\n\tif (vd->vdev_ms != NULL) {\n\t\tmetaslab_group_t *mg = vd->vdev_mg;\n\n\t\tmetaslab_group_passivate(mg);\n\t\tif (vd->vdev_log_mg != NULL) {\n\t\t\tASSERT(!vd->vdev_islog);\n\t\t\tmetaslab_group_passivate(vd->vdev_log_mg);\n\t\t}\n\n\t\tuint64_t count = vd->vdev_ms_count;\n\t\tfor (uint64_t m = 0; m < count; m++) {\n\t\t\tmetaslab_t *msp = vd->vdev_ms[m];\n\t\t\tif (msp != NULL)\n\t\t\t\tmetaslab_fini(msp);\n\t\t}\n\t\tvmem_free(vd->vdev_ms, count * sizeof (metaslab_t *));\n\t\tvd->vdev_ms = NULL;\n\t\tvd->vdev_ms_count = 0;\n\n\t\tfor (int i = 0; i < RANGE_TREE_HISTOGRAM_SIZE; i++) {\n\t\t\tASSERT0(mg->mg_histogram[i]);\n\t\t\tif (vd->vdev_log_mg != NULL)\n\t\t\t\tASSERT0(vd->vdev_log_mg->mg_histogram[i]);\n\t\t}\n\t}\n\tASSERT0(vd->vdev_ms_count);\n}\n\ntypedef struct vdev_probe_stats {\n\tboolean_t\tvps_readable;\n\tboolean_t\tvps_writeable;\n\tint\t\tvps_flags;\n} vdev_probe_stats_t;\n\nstatic void\nvdev_probe_done(zio_t *zio)\n{\n\tspa_t *spa = zio->io_spa;\n\tvdev_t *vd = zio->io_vd;\n\tvdev_probe_stats_t *vps = zio->io_private;\n\n\tASSERT(vd->vdev_probe_zio != NULL);\n\n\tif (zio->io_type == ZIO_TYPE_READ) {\n\t\tif (zio->io_error == 0)\n\t\t\tvps->vps_readable = 1;\n\t\tif (zio->io_error == 0 && spa_writeable(spa)) {\n\t\t\tzio_nowait(zio_write_phys(vd->vdev_probe_zio, vd,\n\t\t\t    zio->io_offset, zio->io_size, zio->io_abd,\n\t\t\t    ZIO_CHECKSUM_OFF, vdev_probe_done, vps,\n\t\t\t    ZIO_PRIORITY_SYNC_WRITE, vps->vps_flags, B_TRUE));\n\t\t} else {\n\t\t\tabd_free(zio->io_abd);\n\t\t}\n\t} else if (zio->io_type == ZIO_TYPE_WRITE) {\n\t\tif (zio->io_error == 0)\n\t\t\tvps->vps_writeable = 1;\n\t\tabd_free(zio->io_abd);\n\t} else if (zio->io_type == ZIO_TYPE_NULL) {\n\t\tzio_t *pio;\n\t\tzio_link_t *zl;\n\n\t\tvd->vdev_cant_read |= !vps->vps_readable;\n\t\tvd->vdev_cant_write |= !vps->vps_writeable;\n\n\t\tif (vdev_readable(vd) &&\n\t\t    (vdev_writeable(vd) || !spa_writeable(spa))) {\n\t\t\tzio->io_error = 0;\n\t\t} else {\n\t\t\tASSERT(zio->io_error != 0);\n\t\t\tvdev_dbgmsg(vd, \"failed probe\");\n\t\t\t(void) zfs_ereport_post(FM_EREPORT_ZFS_PROBE_FAILURE,\n\t\t\t    spa, vd, NULL, NULL, 0);\n\t\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\t}\n\n\t\tmutex_enter(&vd->vdev_probe_lock);\n\t\tASSERT(vd->vdev_probe_zio == zio);\n\t\tvd->vdev_probe_zio = NULL;\n\t\tmutex_exit(&vd->vdev_probe_lock);\n\n\t\tzl = NULL;\n\t\twhile ((pio = zio_walk_parents(zio, &zl)) != NULL)\n\t\t\tif (!vdev_accessible(vd, pio))\n\t\t\t\tpio->io_error = SET_ERROR(ENXIO);\n\n\t\tkmem_free(vps, sizeof (*vps));\n\t}\n}\n\n \nzio_t *\nvdev_probe(vdev_t *vd, zio_t *zio)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_probe_stats_t *vps = NULL;\n\tzio_t *pio;\n\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\t \n\tif (zio && (zio->io_flags & ZIO_FLAG_PROBE))\n\t\treturn (NULL);\n\n\t \n\tmutex_enter(&vd->vdev_probe_lock);\n\n\tif ((pio = vd->vdev_probe_zio) == NULL) {\n\t\tvps = kmem_zalloc(sizeof (*vps), KM_SLEEP);\n\n\t\tvps->vps_flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_PROBE |\n\t\t    ZIO_FLAG_DONT_AGGREGATE | ZIO_FLAG_TRYHARD;\n\n\t\tif (spa_config_held(spa, SCL_ZIO, RW_WRITER)) {\n\t\t\t \n\t\t\tvps->vps_flags |= ZIO_FLAG_CONFIG_WRITER;\n\t\t\tvd->vdev_cant_read = B_FALSE;\n\t\t\tvd->vdev_cant_write = B_FALSE;\n\t\t}\n\n\t\tvd->vdev_probe_zio = pio = zio_null(NULL, spa, vd,\n\t\t    vdev_probe_done, vps,\n\t\t    vps->vps_flags | ZIO_FLAG_DONT_PROPAGATE);\n\n\t\t \n\t\tif (zio != NULL) {\n\t\t\tvd->vdev_probe_wanted = B_TRUE;\n\t\t\tspa_async_request(spa, SPA_ASYNC_PROBE);\n\t\t}\n\t}\n\n\tif (zio != NULL)\n\t\tzio_add_child(zio, pio);\n\n\tmutex_exit(&vd->vdev_probe_lock);\n\n\tif (vps == NULL) {\n\t\tASSERT(zio != NULL);\n\t\treturn (NULL);\n\t}\n\n\tfor (int l = 1; l < VDEV_LABELS; l++) {\n\t\tzio_nowait(zio_read_phys(pio, vd,\n\t\t    vdev_label_offset(vd->vdev_psize, l,\n\t\t    offsetof(vdev_label_t, vl_be)), VDEV_PAD_SIZE,\n\t\t    abd_alloc_for_io(VDEV_PAD_SIZE, B_TRUE),\n\t\t    ZIO_CHECKSUM_OFF, vdev_probe_done, vps,\n\t\t    ZIO_PRIORITY_SYNC_READ, vps->vps_flags, B_TRUE));\n\t}\n\n\tif (zio == NULL)\n\t\treturn (pio);\n\n\tzio_nowait(pio);\n\treturn (NULL);\n}\n\nstatic void\nvdev_load_child(void *arg)\n{\n\tvdev_t *vd = arg;\n\n\tvd->vdev_load_error = vdev_load(vd);\n}\n\nstatic void\nvdev_open_child(void *arg)\n{\n\tvdev_t *vd = arg;\n\n\tvd->vdev_open_thread = curthread;\n\tvd->vdev_open_error = vdev_open(vd);\n\tvd->vdev_open_thread = NULL;\n}\n\nstatic boolean_t\nvdev_uses_zvols(vdev_t *vd)\n{\n#ifdef _KERNEL\n\tif (zvol_is_zvol(vd->vdev_path))\n\t\treturn (B_TRUE);\n#endif\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tif (vdev_uses_zvols(vd->vdev_child[c]))\n\t\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\n \nstatic boolean_t\nvdev_default_open_children_func(vdev_t *vd)\n{\n\t(void) vd;\n\treturn (B_TRUE);\n}\n\n \nstatic void\nvdev_open_children_impl(vdev_t *vd, vdev_open_children_func_t *open_func)\n{\n\tint children = vd->vdev_children;\n\n\ttaskq_t *tq = taskq_create(\"vdev_open\", children, minclsyspri,\n\t    children, children, TASKQ_PREPOPULATE);\n\tvd->vdev_nonrot = B_TRUE;\n\n\tfor (int c = 0; c < children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (open_func(cvd) == B_FALSE)\n\t\t\tcontinue;\n\n\t\tif (tq == NULL || vdev_uses_zvols(vd)) {\n\t\t\tcvd->vdev_open_error = vdev_open(cvd);\n\t\t} else {\n\t\t\tVERIFY(taskq_dispatch(tq, vdev_open_child,\n\t\t\t    cvd, TQ_SLEEP) != TASKQID_INVALID);\n\t\t}\n\n\t\tvd->vdev_nonrot &= cvd->vdev_nonrot;\n\t}\n\n\tif (tq != NULL) {\n\t\ttaskq_wait(tq);\n\t\ttaskq_destroy(tq);\n\t}\n}\n\n \nvoid\nvdev_open_children(vdev_t *vd)\n{\n\tvdev_open_children_impl(vd, vdev_default_open_children_func);\n}\n\n \nvoid\nvdev_open_children_subset(vdev_t *vd, vdev_open_children_func_t *open_func)\n{\n\tvdev_open_children_impl(vd, open_func);\n}\n\n \nstatic void\nvdev_set_deflate_ratio(vdev_t *vd)\n{\n\tif (vd == vd->vdev_top && !vd->vdev_ishole && vd->vdev_ashift != 0) {\n\t\tvd->vdev_deflate_ratio = (1 << 17) /\n\t\t    (vdev_psize_to_asize(vd, 1 << 17) >> SPA_MINBLOCKSHIFT);\n\t}\n}\n\n \nuint64_t\nvdev_best_ashift(uint64_t logical, uint64_t a, uint64_t b)\n{\n\tif (a > logical && a <= zfs_vdev_max_auto_ashift) {\n\t\tif (b <= logical || b > zfs_vdev_max_auto_ashift)\n\t\t\treturn (a);\n\t\telse\n\t\t\treturn (MAX(a, b));\n\t} else if (b <= logical || b > zfs_vdev_max_auto_ashift)\n\t\treturn (MAX(a, b));\n\treturn (b);\n}\n\n \nstatic void\nvdev_ashift_optimize(vdev_t *vd)\n{\n\tASSERT(vd == vd->vdev_top);\n\n\tif (vd->vdev_ashift < vd->vdev_physical_ashift &&\n\t    vd->vdev_physical_ashift <= zfs_vdev_max_auto_ashift) {\n\t\tvd->vdev_ashift = MIN(\n\t\t    MAX(zfs_vdev_max_auto_ashift, vd->vdev_ashift),\n\t\t    MAX(zfs_vdev_min_auto_ashift,\n\t\t    vd->vdev_physical_ashift));\n\t} else {\n\t\t \n\t\tvd->vdev_ashift = MAX(zfs_vdev_min_auto_ashift,\n\t\t    vd->vdev_ashift);\n\t}\n}\n\n \nint\nvdev_open(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tint error;\n\tuint64_t osize = 0;\n\tuint64_t max_osize = 0;\n\tuint64_t asize, max_asize, psize;\n\tuint64_t logical_ashift = 0;\n\tuint64_t physical_ashift = 0;\n\n\tASSERT(vd->vdev_open_thread == curthread ||\n\t    spa_config_held(spa, SCL_STATE_ALL, RW_WRITER) == SCL_STATE_ALL);\n\tASSERT(vd->vdev_state == VDEV_STATE_CLOSED ||\n\t    vd->vdev_state == VDEV_STATE_CANT_OPEN ||\n\t    vd->vdev_state == VDEV_STATE_OFFLINE);\n\n\tvd->vdev_stat.vs_aux = VDEV_AUX_NONE;\n\tvd->vdev_cant_read = B_FALSE;\n\tvd->vdev_cant_write = B_FALSE;\n\tvd->vdev_min_asize = vdev_get_min_asize(vd);\n\n\t \n\tif (!vd->vdev_removed && vd->vdev_faulted) {\n\t\tASSERT(vd->vdev_children == 0);\n\t\tASSERT(vd->vdev_label_aux == VDEV_AUX_ERR_EXCEEDED ||\n\t\t    vd->vdev_label_aux == VDEV_AUX_EXTERNAL);\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_FAULTED,\n\t\t    vd->vdev_label_aux);\n\t\treturn (SET_ERROR(ENXIO));\n\t} else if (vd->vdev_offline) {\n\t\tASSERT(vd->vdev_children == 0);\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_OFFLINE, VDEV_AUX_NONE);\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\terror = vd->vdev_ops->vdev_op_open(vd, &osize, &max_osize,\n\t    &logical_ashift, &physical_ashift);\n\n\t \n\tif (error == ENOENT && vd->vdev_removed) {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_REMOVED,\n\t\t    VDEV_AUX_NONE);\n\t\treturn (error);\n\t}\n\n\t \n\tif (osize > max_osize) {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_OPEN_FAILED);\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\t \n\tvd->vdev_reopening = B_FALSE;\n\tif (zio_injection_enabled && error == 0)\n\t\terror = zio_handle_device_injection(vd, NULL, SET_ERROR(ENXIO));\n\n\tif (error) {\n\t\tif (vd->vdev_removed &&\n\t\t    vd->vdev_stat.vs_aux != VDEV_AUX_OPEN_FAILED)\n\t\t\tvd->vdev_removed = B_FALSE;\n\n\t\tif (vd->vdev_stat.vs_aux == VDEV_AUX_CHILDREN_OFFLINE) {\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_OFFLINE,\n\t\t\t    vd->vdev_stat.vs_aux);\n\t\t} else {\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t\t    vd->vdev_stat.vs_aux);\n\t\t}\n\t\treturn (error);\n\t}\n\n\tvd->vdev_removed = B_FALSE;\n\n\t \n\tif (vd->vdev_faulted) {\n\t\tASSERT(vd->vdev_children == 0);\n\t\tASSERT(vd->vdev_label_aux == VDEV_AUX_ERR_EXCEEDED ||\n\t\t    vd->vdev_label_aux == VDEV_AUX_EXTERNAL);\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_FAULTED,\n\t\t    vd->vdev_label_aux);\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\tif (vd->vdev_degraded) {\n\t\tASSERT(vd->vdev_children == 0);\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_DEGRADED,\n\t\t    VDEV_AUX_ERR_EXCEEDED);\n\t} else {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_HEALTHY, 0);\n\t}\n\n\t \n\tif (vd->vdev_ishole || vd->vdev_ops == &vdev_missing_ops)\n\t\treturn (0);\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tif (vd->vdev_child[c]->vdev_state != VDEV_STATE_HEALTHY) {\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_DEGRADED,\n\t\t\t    VDEV_AUX_NONE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tosize = P2ALIGN(osize, (uint64_t)sizeof (vdev_label_t));\n\tmax_osize = P2ALIGN(max_osize, (uint64_t)sizeof (vdev_label_t));\n\n\tif (vd->vdev_children == 0) {\n\t\tif (osize < SPA_MINDEVSIZE) {\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_TOO_SMALL);\n\t\t\treturn (SET_ERROR(EOVERFLOW));\n\t\t}\n\t\tpsize = osize;\n\t\tasize = osize - (VDEV_LABEL_START_SIZE + VDEV_LABEL_END_SIZE);\n\t\tmax_asize = max_osize - (VDEV_LABEL_START_SIZE +\n\t\t    VDEV_LABEL_END_SIZE);\n\t} else {\n\t\tif (vd->vdev_parent != NULL && osize < SPA_MINDEVSIZE -\n\t\t    (VDEV_LABEL_START_SIZE + VDEV_LABEL_END_SIZE)) {\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_TOO_SMALL);\n\t\t\treturn (SET_ERROR(EOVERFLOW));\n\t\t}\n\t\tpsize = 0;\n\t\tasize = osize;\n\t\tmax_asize = max_osize;\n\t}\n\n\t \n\tif ((psize > vd->vdev_psize) && (vd->vdev_psize != 0))\n\t\tvd->vdev_copy_uberblocks = B_TRUE;\n\n\tvd->vdev_psize = psize;\n\n\t \n\tif (asize < vd->vdev_min_asize) {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_BAD_LABEL);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tvd->vdev_physical_ashift =\n\t    MAX(physical_ashift, vd->vdev_physical_ashift);\n\tvd->vdev_logical_ashift = MAX(logical_ashift,\n\t    vd->vdev_logical_ashift);\n\n\tif (vd->vdev_asize == 0) {\n\t\t \n\t\tvd->vdev_asize = asize;\n\t\tvd->vdev_max_asize = max_asize;\n\n\t\t \n\t\tif (vd->vdev_ashift == 0) {\n\t\t\tvd->vdev_ashift = vd->vdev_logical_ashift;\n\n\t\t\tif (vd->vdev_logical_ashift > ASHIFT_MAX) {\n\t\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t\t\t    VDEV_AUX_ASHIFT_TOO_BIG);\n\t\t\t\treturn (SET_ERROR(EDOM));\n\t\t\t}\n\n\t\t\tif (vd->vdev_top == vd && vd->vdev_attaching == B_FALSE)\n\t\t\t\tvdev_ashift_optimize(vd);\n\t\t\tvd->vdev_attaching = B_FALSE;\n\t\t}\n\t\tif (vd->vdev_ashift != 0 && (vd->vdev_ashift < ASHIFT_MIN ||\n\t\t    vd->vdev_ashift > ASHIFT_MAX)) {\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_BAD_ASHIFT);\n\t\t\treturn (SET_ERROR(EDOM));\n\t\t}\n\t} else {\n\t\t \n\t\tif (vd->vdev_ashift > vd->vdev_top->vdev_ashift &&\n\t\t    vd->vdev_ops->vdev_op_leaf) {\n\t\t\t(void) zfs_ereport_post(\n\t\t\t    FM_EREPORT_ZFS_DEVICE_BAD_ASHIFT,\n\t\t\t    spa, vd, NULL, NULL, 0);\n\t\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_BAD_LABEL);\n\t\t\treturn (SET_ERROR(EDOM));\n\t\t}\n\t\tvd->vdev_max_asize = max_asize;\n\t}\n\n\t \n\tif (vd->vdev_state == VDEV_STATE_HEALTHY &&\n\t    ((asize > vd->vdev_asize &&\n\t    (vd->vdev_expanding || spa->spa_autoexpand)) ||\n\t    (asize < vd->vdev_asize)))\n\t\tvd->vdev_asize = asize;\n\n\tvdev_set_min_asize(vd);\n\n\t \n\tif (vd->vdev_ops->vdev_op_leaf &&\n\t    (error = zio_wait(vdev_probe(vd, NULL))) != 0) {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_FAULTED,\n\t\t    VDEV_AUX_ERR_EXCEEDED);\n\t\treturn (error);\n\t}\n\n\t \n\tif (vd->vdev_top == vd && vd->vdev_ashift != 0 &&\n\t    vd->vdev_islog == 0 && vd->vdev_aux == NULL) {\n\t\tuint64_t min_alloc = vdev_get_min_alloc(vd);\n\t\tvdev_spa_set_alloc(spa, min_alloc);\n\t}\n\n\t \n\tif (vd->vdev_ops->vdev_op_leaf && !spa->spa_scrub_reopen)\n\t\tdsl_scan_assess_vdev(spa->spa_dsl_pool, vd);\n\n\treturn (0);\n}\n\nstatic void\nvdev_validate_child(void *arg)\n{\n\tvdev_t *vd = arg;\n\n\tvd->vdev_validate_thread = curthread;\n\tvd->vdev_validate_error = vdev_validate(vd);\n\tvd->vdev_validate_thread = NULL;\n}\n\n \nint\nvdev_validate(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\ttaskq_t *tq = NULL;\n\tnvlist_t *label;\n\tuint64_t guid = 0, aux_guid = 0, top_guid;\n\tuint64_t state;\n\tnvlist_t *nvl;\n\tuint64_t txg;\n\tint children = vd->vdev_children;\n\n\tif (vdev_validate_skip)\n\t\treturn (0);\n\n\tif (children > 0) {\n\t\ttq = taskq_create(\"vdev_validate\", children, minclsyspri,\n\t\t    children, children, TASKQ_PREPOPULATE);\n\t}\n\n\tfor (uint64_t c = 0; c < children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (tq == NULL || vdev_uses_zvols(cvd)) {\n\t\t\tvdev_validate_child(cvd);\n\t\t} else {\n\t\t\tVERIFY(taskq_dispatch(tq, vdev_validate_child, cvd,\n\t\t\t    TQ_SLEEP) != TASKQID_INVALID);\n\t\t}\n\t}\n\tif (tq != NULL) {\n\t\ttaskq_wait(tq);\n\t\ttaskq_destroy(tq);\n\t}\n\tfor (int c = 0; c < children; c++) {\n\t\tint error = vd->vdev_child[c]->vdev_validate_error;\n\n\t\tif (error != 0)\n\t\t\treturn (SET_ERROR(EBADF));\n\t}\n\n\n\t \n\tif (!vd->vdev_ops->vdev_op_leaf || !vdev_readable(vd))\n\t\treturn (0);\n\n\t \n\tif (spa->spa_extreme_rewind || spa_last_synced_txg(spa) == 0 ||\n\t    spa_config_held(spa, SCL_CONFIG, RW_WRITER) != SCL_CONFIG)\n\t\ttxg = UINT64_MAX;\n\telse\n\t\ttxg = spa_last_synced_txg(spa);\n\n\tif ((label = vdev_label_read_config(vd, txg)) == NULL) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_BAD_LABEL);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: failed reading config for \"\n\t\t    \"txg %llu\", (u_longlong_t)txg);\n\t\treturn (0);\n\t}\n\n\t \n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_SPLIT_GUID,\n\t    &aux_guid) == 0 && aux_guid == spa_guid(spa)) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_SPLIT_POOL);\n\t\tnvlist_free(label);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: vdev split into other pool\");\n\t\treturn (0);\n\t}\n\n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_GUID, &guid) != 0) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tnvlist_free(label);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: '%s' missing from label\",\n\t\t    ZPOOL_CONFIG_POOL_GUID);\n\t\treturn (0);\n\t}\n\n\t \n\tif (spa->spa_trust_config && guid != spa_guid(spa)) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tnvlist_free(label);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: vdev label pool_guid doesn't \"\n\t\t    \"match config (%llu != %llu)\", (u_longlong_t)guid,\n\t\t    (u_longlong_t)spa_guid(spa));\n\t\treturn (0);\n\t}\n\n\tif (nvlist_lookup_nvlist(label, ZPOOL_CONFIG_VDEV_TREE, &nvl)\n\t    != 0 || nvlist_lookup_uint64(nvl, ZPOOL_CONFIG_ORIG_GUID,\n\t    &aux_guid) != 0)\n\t\taux_guid = 0;\n\n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_GUID, &guid) != 0) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tnvlist_free(label);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: '%s' missing from label\",\n\t\t    ZPOOL_CONFIG_GUID);\n\t\treturn (0);\n\t}\n\n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_TOP_GUID, &top_guid)\n\t    != 0) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tnvlist_free(label);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: '%s' missing from label\",\n\t\t    ZPOOL_CONFIG_TOP_GUID);\n\t\treturn (0);\n\t}\n\n\t \n\tif (vd->vdev_guid != guid && vd->vdev_guid != aux_guid) {\n\t\tboolean_t mismatch = B_FALSE;\n\t\tif (spa->spa_trust_config && !spa->spa_extreme_rewind) {\n\t\t\tif (vd != vd->vdev_top || vd->vdev_guid != top_guid)\n\t\t\t\tmismatch = B_TRUE;\n\t\t} else {\n\t\t\tif (vd->vdev_guid != top_guid &&\n\t\t\t    vd->vdev_top->vdev_guid != guid)\n\t\t\t\tmismatch = B_TRUE;\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\t\tnvlist_free(label);\n\t\t\tvdev_dbgmsg(vd, \"vdev_validate: config guid \"\n\t\t\t    \"doesn't match label guid\");\n\t\t\tvdev_dbgmsg(vd, \"CONFIG: guid %llu, top_guid %llu\",\n\t\t\t    (u_longlong_t)vd->vdev_guid,\n\t\t\t    (u_longlong_t)vd->vdev_top->vdev_guid);\n\t\t\tvdev_dbgmsg(vd, \"LABEL: guid %llu, top_guid %llu, \"\n\t\t\t    \"aux_guid %llu\", (u_longlong_t)guid,\n\t\t\t    (u_longlong_t)top_guid, (u_longlong_t)aux_guid);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_STATE,\n\t    &state) != 0) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tnvlist_free(label);\n\t\tvdev_dbgmsg(vd, \"vdev_validate: '%s' missing from label\",\n\t\t    ZPOOL_CONFIG_POOL_STATE);\n\t\treturn (0);\n\t}\n\n\tnvlist_free(label);\n\n\t \n\tif (!(spa->spa_import_flags & ZFS_IMPORT_VERBATIM) &&\n\t    spa_load_state(spa) == SPA_LOAD_OPEN &&\n\t    state != POOL_STATE_ACTIVE) {\n\t\tvdev_dbgmsg(vd, \"vdev_validate: invalid pool state (%llu) \"\n\t\t    \"for spa %s\", (u_longlong_t)state, spa->spa_name);\n\t\treturn (SET_ERROR(EBADF));\n\t}\n\n\t \n\tif (vd->vdev_not_present)\n\t\tvd->vdev_not_present = 0;\n\n\treturn (0);\n}\n\nstatic void\nvdev_copy_path_impl(vdev_t *svd, vdev_t *dvd)\n{\n\tchar *old, *new;\n\tif (svd->vdev_path != NULL && dvd->vdev_path != NULL) {\n\t\tif (strcmp(svd->vdev_path, dvd->vdev_path) != 0) {\n\t\t\tzfs_dbgmsg(\"vdev_copy_path: vdev %llu: path changed \"\n\t\t\t    \"from '%s' to '%s'\", (u_longlong_t)dvd->vdev_guid,\n\t\t\t    dvd->vdev_path, svd->vdev_path);\n\t\t\tspa_strfree(dvd->vdev_path);\n\t\t\tdvd->vdev_path = spa_strdup(svd->vdev_path);\n\t\t}\n\t} else if (svd->vdev_path != NULL) {\n\t\tdvd->vdev_path = spa_strdup(svd->vdev_path);\n\t\tzfs_dbgmsg(\"vdev_copy_path: vdev %llu: path set to '%s'\",\n\t\t    (u_longlong_t)dvd->vdev_guid, dvd->vdev_path);\n\t}\n\n\t \n\told = dvd->vdev_enc_sysfs_path;\n\tnew = svd->vdev_enc_sysfs_path;\n\tif ((old != NULL && new == NULL) ||\n\t    (old == NULL && new != NULL) ||\n\t    ((old != NULL && new != NULL) && strcmp(new, old) != 0)) {\n\t\tzfs_dbgmsg(\"vdev_copy_path: vdev %llu: vdev_enc_sysfs_path \"\n\t\t    \"changed from '%s' to '%s'\", (u_longlong_t)dvd->vdev_guid,\n\t\t    old, new);\n\n\t\tif (dvd->vdev_enc_sysfs_path)\n\t\t\tspa_strfree(dvd->vdev_enc_sysfs_path);\n\n\t\tif (svd->vdev_enc_sysfs_path) {\n\t\t\tdvd->vdev_enc_sysfs_path = spa_strdup(\n\t\t\t    svd->vdev_enc_sysfs_path);\n\t\t} else {\n\t\t\tdvd->vdev_enc_sysfs_path = NULL;\n\t\t}\n\t}\n}\n\n \nint\nvdev_copy_path_strict(vdev_t *svd, vdev_t *dvd)\n{\n\tif ((svd->vdev_ops == &vdev_missing_ops) ||\n\t    (svd->vdev_ishole && dvd->vdev_ishole) ||\n\t    (dvd->vdev_ops == &vdev_indirect_ops))\n\t\treturn (0);\n\n\tif (svd->vdev_ops != dvd->vdev_ops) {\n\t\tvdev_dbgmsg(svd, \"vdev_copy_path: vdev type mismatch: %s != %s\",\n\t\t    svd->vdev_ops->vdev_op_type, dvd->vdev_ops->vdev_op_type);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (svd->vdev_guid != dvd->vdev_guid) {\n\t\tvdev_dbgmsg(svd, \"vdev_copy_path: guids mismatch (%llu != \"\n\t\t    \"%llu)\", (u_longlong_t)svd->vdev_guid,\n\t\t    (u_longlong_t)dvd->vdev_guid);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (svd->vdev_children != dvd->vdev_children) {\n\t\tvdev_dbgmsg(svd, \"vdev_copy_path: children count mismatch: \"\n\t\t    \"%llu != %llu\", (u_longlong_t)svd->vdev_children,\n\t\t    (u_longlong_t)dvd->vdev_children);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tfor (uint64_t i = 0; i < svd->vdev_children; i++) {\n\t\tint error = vdev_copy_path_strict(svd->vdev_child[i],\n\t\t    dvd->vdev_child[i]);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\tif (svd->vdev_ops->vdev_op_leaf)\n\t\tvdev_copy_path_impl(svd, dvd);\n\n\treturn (0);\n}\n\nstatic void\nvdev_copy_path_search(vdev_t *stvd, vdev_t *dvd)\n{\n\tASSERT(stvd->vdev_top == stvd);\n\tASSERT3U(stvd->vdev_id, ==, dvd->vdev_top->vdev_id);\n\n\tfor (uint64_t i = 0; i < dvd->vdev_children; i++) {\n\t\tvdev_copy_path_search(stvd, dvd->vdev_child[i]);\n\t}\n\n\tif (!dvd->vdev_ops->vdev_op_leaf || !vdev_is_concrete(dvd))\n\t\treturn;\n\n\t \n\tvdev_t *vd = vdev_lookup_by_guid(stvd, dvd->vdev_guid);\n\n\tif (vd == NULL || vd->vdev_ops != dvd->vdev_ops)\n\t\treturn;\n\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\tvdev_copy_path_impl(vd, dvd);\n}\n\n \nvoid\nvdev_copy_path_relaxed(vdev_t *srvd, vdev_t *drvd)\n{\n\tuint64_t children = MIN(srvd->vdev_children, drvd->vdev_children);\n\tASSERT(srvd->vdev_ops == &vdev_root_ops);\n\tASSERT(drvd->vdev_ops == &vdev_root_ops);\n\n\tfor (uint64_t i = 0; i < children; i++) {\n\t\tvdev_copy_path_search(srvd->vdev_child[i],\n\t\t    drvd->vdev_child[i]);\n\t}\n}\n\n \nvoid\nvdev_close(vdev_t *vd)\n{\n\tvdev_t *pvd = vd->vdev_parent;\n\tspa_t *spa __maybe_unused = vd->vdev_spa;\n\n\tASSERT(vd != NULL);\n\tASSERT(vd->vdev_open_thread == curthread ||\n\t    spa_config_held(spa, SCL_STATE_ALL, RW_WRITER) == SCL_STATE_ALL);\n\n\t \n\tif (pvd != NULL && pvd->vdev_reopening)\n\t\tvd->vdev_reopening = (pvd->vdev_reopening && !vd->vdev_offline);\n\n\tvd->vdev_ops->vdev_op_close(vd);\n\n\t \n\tvd->vdev_prevstate = vd->vdev_state;\n\n\tif (vd->vdev_offline)\n\t\tvd->vdev_state = VDEV_STATE_OFFLINE;\n\telse\n\t\tvd->vdev_state = VDEV_STATE_CLOSED;\n\tvd->vdev_stat.vs_aux = VDEV_AUX_NONE;\n}\n\nvoid\nvdev_hold(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(spa_is_root(spa));\n\tif (spa->spa_state == POOL_STATE_UNINITIALIZED)\n\t\treturn;\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_hold(vd->vdev_child[c]);\n\n\tif (vd->vdev_ops->vdev_op_leaf && vd->vdev_ops->vdev_op_hold != NULL)\n\t\tvd->vdev_ops->vdev_op_hold(vd);\n}\n\nvoid\nvdev_rele(vdev_t *vd)\n{\n\tASSERT(spa_is_root(vd->vdev_spa));\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_rele(vd->vdev_child[c]);\n\n\tif (vd->vdev_ops->vdev_op_leaf && vd->vdev_ops->vdev_op_rele != NULL)\n\t\tvd->vdev_ops->vdev_op_rele(vd);\n}\n\n \nvoid\nvdev_reopen(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(spa_config_held(spa, SCL_STATE_ALL, RW_WRITER) == SCL_STATE_ALL);\n\n\t \n\tvd->vdev_reopening = !vd->vdev_offline;\n\tvdev_close(vd);\n\t(void) vdev_open(vd);\n\n\t \n\tif (vd->vdev_aux) {\n\t\t(void) vdev_validate_aux(vd);\n\t\tif (vdev_readable(vd) && vdev_writeable(vd) &&\n\t\t    vd->vdev_aux == &spa->spa_l2cache) {\n\t\t\t \n\t\t\tif (l2arc_vdev_present(vd)) {\n\t\t\t\tl2arc_rebuild_vdev(vd, B_TRUE);\n\t\t\t} else {\n\t\t\t\tl2arc_add_vdev(spa, vd);\n\t\t\t}\n\t\t\tspa_async_request(spa, SPA_ASYNC_L2CACHE_REBUILD);\n\t\t\tspa_async_request(spa, SPA_ASYNC_L2CACHE_TRIM);\n\t\t}\n\t} else {\n\t\t(void) vdev_validate(vd);\n\t}\n\n\t \n\tif (!vdev_resilver_needed(spa->spa_root_vdev, NULL, NULL) &&\n\t    spa->spa_async_tasks & SPA_ASYNC_RESILVER) {\n\t\tmutex_enter(&spa->spa_async_lock);\n\t\tspa->spa_async_tasks &= ~SPA_ASYNC_RESILVER;\n\t\tmutex_exit(&spa->spa_async_lock);\n\t}\n\n\t \n\tvdev_propagate_state(vd);\n}\n\nint\nvdev_create(vdev_t *vd, uint64_t txg, boolean_t isreplacing)\n{\n\tint error;\n\n\t \n\terror = vdev_open(vd);\n\n\tif (error || vd->vdev_state != VDEV_STATE_HEALTHY) {\n\t\tvdev_close(vd);\n\t\treturn (error ? error : SET_ERROR(ENXIO));\n\t}\n\n\t \n\tif ((error = vdev_dtl_load(vd)) != 0 ||\n\t    (error = vdev_label_init(vd, txg, isreplacing ?\n\t    VDEV_LABEL_REPLACE : VDEV_LABEL_CREATE)) != 0) {\n\t\tvdev_close(vd);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}\n\nvoid\nvdev_metaslab_set_size(vdev_t *vd)\n{\n\tuint64_t asize = vd->vdev_asize;\n\tuint64_t ms_count = asize >> zfs_vdev_default_ms_shift;\n\tuint64_t ms_shift;\n\n\t \n\n\tif (ms_count < zfs_vdev_min_ms_count)\n\t\tms_shift = highbit64(asize / zfs_vdev_min_ms_count);\n\telse if (ms_count > zfs_vdev_default_ms_count)\n\t\tms_shift = highbit64(asize / zfs_vdev_default_ms_count);\n\telse\n\t\tms_shift = zfs_vdev_default_ms_shift;\n\n\tif (ms_shift < SPA_MAXBLOCKSHIFT) {\n\t\tms_shift = SPA_MAXBLOCKSHIFT;\n\t} else if (ms_shift > zfs_vdev_max_ms_shift) {\n\t\tms_shift = zfs_vdev_max_ms_shift;\n\t\t \n\t\tif ((asize >> ms_shift) > zfs_vdev_ms_count_limit)\n\t\t\tms_shift = highbit64(asize / zfs_vdev_ms_count_limit);\n\t}\n\n\tvd->vdev_ms_shift = ms_shift;\n\tASSERT3U(vd->vdev_ms_shift, >=, SPA_MAXBLOCKSHIFT);\n}\n\nvoid\nvdev_dirty(vdev_t *vd, int flags, void *arg, uint64_t txg)\n{\n\tASSERT(vd == vd->vdev_top);\n\t \n\tASSERT(vdev_is_concrete(vd) || flags == 0);\n\tASSERT(ISP2(flags));\n\tASSERT(spa_writeable(vd->vdev_spa));\n\n\tif (flags & VDD_METASLAB)\n\t\t(void) txg_list_add(&vd->vdev_ms_list, arg, txg);\n\n\tif (flags & VDD_DTL)\n\t\t(void) txg_list_add(&vd->vdev_dtl_list, arg, txg);\n\n\t(void) txg_list_add(&vd->vdev_spa->spa_vdev_txg_list, vd, txg);\n}\n\nvoid\nvdev_dirty_leaves(vdev_t *vd, int flags, uint64_t txg)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_dirty_leaves(vd->vdev_child[c], flags, txg);\n\n\tif (vd->vdev_ops->vdev_op_leaf)\n\t\tvdev_dirty(vd->vdev_top, flags, vd, txg);\n}\n\n \nvoid\nvdev_dtl_dirty(vdev_t *vd, vdev_dtl_type_t t, uint64_t txg, uint64_t size)\n{\n\trange_tree_t *rt = vd->vdev_dtl[t];\n\n\tASSERT(t < DTL_TYPES);\n\tASSERT(vd != vd->vdev_spa->spa_root_vdev);\n\tASSERT(spa_writeable(vd->vdev_spa));\n\n\tmutex_enter(&vd->vdev_dtl_lock);\n\tif (!range_tree_contains(rt, txg, size))\n\t\trange_tree_add(rt, txg, size);\n\tmutex_exit(&vd->vdev_dtl_lock);\n}\n\nboolean_t\nvdev_dtl_contains(vdev_t *vd, vdev_dtl_type_t t, uint64_t txg, uint64_t size)\n{\n\trange_tree_t *rt = vd->vdev_dtl[t];\n\tboolean_t dirty = B_FALSE;\n\n\tASSERT(t < DTL_TYPES);\n\tASSERT(vd != vd->vdev_spa->spa_root_vdev);\n\n\t \n\tmutex_enter(&vd->vdev_dtl_lock);\n\tif (!range_tree_is_empty(rt))\n\t\tdirty = range_tree_contains(rt, txg, size);\n\tmutex_exit(&vd->vdev_dtl_lock);\n\n\treturn (dirty);\n}\n\nboolean_t\nvdev_dtl_empty(vdev_t *vd, vdev_dtl_type_t t)\n{\n\trange_tree_t *rt = vd->vdev_dtl[t];\n\tboolean_t empty;\n\n\tmutex_enter(&vd->vdev_dtl_lock);\n\tempty = range_tree_is_empty(rt);\n\tmutex_exit(&vd->vdev_dtl_lock);\n\n\treturn (empty);\n}\n\n \nboolean_t\nvdev_default_need_resilver(vdev_t *vd, const dva_t *dva, size_t psize,\n    uint64_t phys_birth)\n{\n\t(void) dva, (void) psize;\n\n\t \n\tif (phys_birth == TXG_UNKNOWN)\n\t\treturn (B_TRUE);\n\n\treturn (vdev_dtl_contains(vd, DTL_PARTIAL, phys_birth, 1));\n}\n\n \nboolean_t\nvdev_dtl_need_resilver(vdev_t *vd, const dva_t *dva, size_t psize,\n    uint64_t phys_birth)\n{\n\tASSERT(vd != vd->vdev_spa->spa_root_vdev);\n\n\tif (vd->vdev_ops->vdev_op_need_resilver == NULL ||\n\t    vd->vdev_ops->vdev_op_leaf)\n\t\treturn (B_TRUE);\n\n\treturn (vd->vdev_ops->vdev_op_need_resilver(vd, dva, psize,\n\t    phys_birth));\n}\n\n \nstatic uint64_t\nvdev_dtl_min(vdev_t *vd)\n{\n\tASSERT(MUTEX_HELD(&vd->vdev_dtl_lock));\n\tASSERT3U(range_tree_space(vd->vdev_dtl[DTL_MISSING]), !=, 0);\n\tASSERT0(vd->vdev_children);\n\n\treturn (range_tree_min(vd->vdev_dtl[DTL_MISSING]) - 1);\n}\n\n \nstatic uint64_t\nvdev_dtl_max(vdev_t *vd)\n{\n\tASSERT(MUTEX_HELD(&vd->vdev_dtl_lock));\n\tASSERT3U(range_tree_space(vd->vdev_dtl[DTL_MISSING]), !=, 0);\n\tASSERT0(vd->vdev_children);\n\n\treturn (range_tree_max(vd->vdev_dtl[DTL_MISSING]));\n}\n\n \nstatic boolean_t\nvdev_dtl_should_excise(vdev_t *vd, boolean_t rebuild_done)\n{\n\tASSERT0(vd->vdev_children);\n\n\tif (vd->vdev_state < VDEV_STATE_DEGRADED)\n\t\treturn (B_FALSE);\n\n\tif (vd->vdev_resilver_deferred)\n\t\treturn (B_FALSE);\n\n\tif (range_tree_is_empty(vd->vdev_dtl[DTL_MISSING]))\n\t\treturn (B_TRUE);\n\n\tif (rebuild_done) {\n\t\tvdev_rebuild_t *vr = &vd->vdev_top->vdev_rebuild_config;\n\t\tvdev_rebuild_phys_t *vrp = &vr->vr_rebuild_phys;\n\n\t\t \n\t\tif (vd->vdev_rebuild_txg == 0)\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vrp->vrp_rebuild_state == VDEV_REBUILD_COMPLETE &&\n\t\t    vdev_dtl_max(vd) <= vrp->vrp_max_txg) {\n\t\t\tASSERT3U(vrp->vrp_min_txg, <=, vdev_dtl_min(vd));\n\t\t\tASSERT3U(vrp->vrp_min_txg, <, vd->vdev_rebuild_txg);\n\t\t\tASSERT3U(vd->vdev_rebuild_txg, <=, vrp->vrp_max_txg);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t} else {\n\t\tdsl_scan_t *scn = vd->vdev_spa->spa_dsl_pool->dp_scan;\n\t\tdsl_scan_phys_t *scnp __maybe_unused = &scn->scn_phys;\n\n\t\t \n\t\tif (vd->vdev_resilver_txg == 0)\n\t\t\treturn (B_TRUE);\n\n\t\t \n\t\tif (vdev_dtl_max(vd) <= scn->scn_phys.scn_max_txg) {\n\t\t\tASSERT3U(scnp->scn_min_txg, <=, vdev_dtl_min(vd));\n\t\t\tASSERT3U(scnp->scn_min_txg, <, vd->vdev_resilver_txg);\n\t\t\tASSERT3U(vd->vdev_resilver_txg, <=, scnp->scn_max_txg);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nvoid\nvdev_dtl_reassess(vdev_t *vd, uint64_t txg, uint64_t scrub_txg,\n    boolean_t scrub_done, boolean_t rebuild_done)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tavl_tree_t reftree;\n\tint minref;\n\n\tASSERT(spa_config_held(spa, SCL_ALL, RW_READER) != 0);\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_dtl_reassess(vd->vdev_child[c], txg,\n\t\t    scrub_txg, scrub_done, rebuild_done);\n\n\tif (vd == spa->spa_root_vdev || !vdev_is_concrete(vd) || vd->vdev_aux)\n\t\treturn;\n\n\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\tdsl_scan_t *scn = spa->spa_dsl_pool->dp_scan;\n\t\tvdev_rebuild_t *vr = &vd->vdev_top->vdev_rebuild_config;\n\t\tboolean_t check_excise = B_FALSE;\n\t\tboolean_t wasempty = B_TRUE;\n\n\t\tmutex_enter(&vd->vdev_dtl_lock);\n\n\t\t \n\t\tif (zfs_scan_ignore_errors) {\n\t\t\tif (scn != NULL)\n\t\t\t\tscn->scn_phys.scn_errors = 0;\n\t\t\tif (vr != NULL)\n\t\t\t\tvr->vr_rebuild_phys.vrp_errors = 0;\n\t\t}\n\n\t\tif (scrub_txg != 0 &&\n\t\t    !range_tree_is_empty(vd->vdev_dtl[DTL_MISSING])) {\n\t\t\twasempty = B_FALSE;\n\t\t\tzfs_dbgmsg(\"guid:%llu txg:%llu scrub:%llu started:%d \"\n\t\t\t    \"dtl:%llu/%llu errors:%llu\",\n\t\t\t    (u_longlong_t)vd->vdev_guid, (u_longlong_t)txg,\n\t\t\t    (u_longlong_t)scrub_txg, spa->spa_scrub_started,\n\t\t\t    (u_longlong_t)vdev_dtl_min(vd),\n\t\t\t    (u_longlong_t)vdev_dtl_max(vd),\n\t\t\t    (u_longlong_t)(scn ? scn->scn_phys.scn_errors : 0));\n\t\t}\n\n\t\t \n\t\tif (rebuild_done &&\n\t\t    vr != NULL && vr->vr_rebuild_phys.vrp_errors == 0) {\n\t\t\tcheck_excise = B_TRUE;\n\t\t} else {\n\t\t\tif (spa->spa_scrub_started ||\n\t\t\t    (scn != NULL && scn->scn_phys.scn_errors == 0)) {\n\t\t\t\tcheck_excise = B_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (scrub_txg && check_excise &&\n\t\t    vdev_dtl_should_excise(vd, rebuild_done)) {\n\t\t\t \n\t\t\tspace_reftree_create(&reftree);\n\t\t\tspace_reftree_add_map(&reftree,\n\t\t\t    vd->vdev_dtl[DTL_MISSING], 1);\n\t\t\tspace_reftree_add_seg(&reftree, 0, scrub_txg, -1);\n\t\t\tspace_reftree_add_map(&reftree,\n\t\t\t    vd->vdev_dtl[DTL_SCRUB], 2);\n\t\t\tspace_reftree_generate_map(&reftree,\n\t\t\t    vd->vdev_dtl[DTL_MISSING], 1);\n\t\t\tspace_reftree_destroy(&reftree);\n\n\t\t\tif (!range_tree_is_empty(vd->vdev_dtl[DTL_MISSING])) {\n\t\t\t\tzfs_dbgmsg(\"update DTL_MISSING:%llu/%llu\",\n\t\t\t\t    (u_longlong_t)vdev_dtl_min(vd),\n\t\t\t\t    (u_longlong_t)vdev_dtl_max(vd));\n\t\t\t} else if (!wasempty) {\n\t\t\t\tzfs_dbgmsg(\"DTL_MISSING is now empty\");\n\t\t\t}\n\t\t}\n\t\trange_tree_vacate(vd->vdev_dtl[DTL_PARTIAL], NULL, NULL);\n\t\trange_tree_walk(vd->vdev_dtl[DTL_MISSING],\n\t\t    range_tree_add, vd->vdev_dtl[DTL_PARTIAL]);\n\t\tif (scrub_done)\n\t\t\trange_tree_vacate(vd->vdev_dtl[DTL_SCRUB], NULL, NULL);\n\t\trange_tree_vacate(vd->vdev_dtl[DTL_OUTAGE], NULL, NULL);\n\t\tif (!vdev_readable(vd))\n\t\t\trange_tree_add(vd->vdev_dtl[DTL_OUTAGE], 0, -1ULL);\n\t\telse\n\t\t\trange_tree_walk(vd->vdev_dtl[DTL_MISSING],\n\t\t\t    range_tree_add, vd->vdev_dtl[DTL_OUTAGE]);\n\n\t\t \n\t\tif (txg != 0 &&\n\t\t    range_tree_is_empty(vd->vdev_dtl[DTL_MISSING]) &&\n\t\t    range_tree_is_empty(vd->vdev_dtl[DTL_OUTAGE])) {\n\t\t\tif (vd->vdev_rebuild_txg != 0) {\n\t\t\t\tvd->vdev_rebuild_txg = 0;\n\t\t\t\tvdev_config_dirty(vd->vdev_top);\n\t\t\t} else if (vd->vdev_resilver_txg != 0) {\n\t\t\t\tvd->vdev_resilver_txg = 0;\n\t\t\t\tvdev_config_dirty(vd->vdev_top);\n\t\t\t}\n\t\t}\n\n\t\tmutex_exit(&vd->vdev_dtl_lock);\n\n\t\tif (txg != 0)\n\t\t\tvdev_dirty(vd->vdev_top, VDD_DTL, vd, txg);\n\t\treturn;\n\t}\n\n\tmutex_enter(&vd->vdev_dtl_lock);\n\tfor (int t = 0; t < DTL_TYPES; t++) {\n\t\t \n\t\tint s = (t == DTL_MISSING) ? DTL_OUTAGE: t;\n\t\tif (t == DTL_SCRUB)\n\t\t\tcontinue;\t\t\t \n\t\tif (t == DTL_PARTIAL)\n\t\t\tminref = 1;\t\t\t \n\t\telse if (vdev_get_nparity(vd) != 0)\n\t\t\tminref = vdev_get_nparity(vd) + 1;  \n\t\telse\n\t\t\tminref = vd->vdev_children;\t \n\t\tspace_reftree_create(&reftree);\n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tvdev_t *cvd = vd->vdev_child[c];\n\t\t\tmutex_enter(&cvd->vdev_dtl_lock);\n\t\t\tspace_reftree_add_map(&reftree, cvd->vdev_dtl[s], 1);\n\t\t\tmutex_exit(&cvd->vdev_dtl_lock);\n\t\t}\n\t\tspace_reftree_generate_map(&reftree, vd->vdev_dtl[t], minref);\n\t\tspace_reftree_destroy(&reftree);\n\t}\n\tmutex_exit(&vd->vdev_dtl_lock);\n}\n\n \nvoid\nvdev_post_kobj_evt(vdev_t *vd)\n{\n\tif (vd->vdev_ops->vdev_op_kobj_evt_post &&\n\t    vd->vdev_kobj_flag == B_FALSE) {\n\t\tvd->vdev_kobj_flag = B_TRUE;\n\t\tvd->vdev_ops->vdev_op_kobj_evt_post(vd);\n\t}\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_post_kobj_evt(vd->vdev_child[c]);\n}\n\n \nvoid\nvdev_clear_kobj_evt(vdev_t *vd)\n{\n\tvd->vdev_kobj_flag = B_FALSE;\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_clear_kobj_evt(vd->vdev_child[c]);\n}\n\nint\nvdev_dtl_load(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tobjset_t *mos = spa->spa_meta_objset;\n\trange_tree_t *rt;\n\tint error = 0;\n\n\tif (vd->vdev_ops->vdev_op_leaf && vd->vdev_dtl_object != 0) {\n\t\tASSERT(vdev_is_concrete(vd));\n\n\t\t \n\t\tif (spa->spa_mode == SPA_MODE_READ && !spa->spa_read_spacemaps)\n\t\t\treturn (0);\n\n\t\terror = space_map_open(&vd->vdev_dtl_sm, mos,\n\t\t    vd->vdev_dtl_object, 0, -1ULL, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tASSERT(vd->vdev_dtl_sm != NULL);\n\n\t\trt = range_tree_create(NULL, RANGE_SEG64, NULL, 0, 0);\n\t\terror = space_map_load(vd->vdev_dtl_sm, rt, SM_ALLOC);\n\t\tif (error == 0) {\n\t\t\tmutex_enter(&vd->vdev_dtl_lock);\n\t\t\trange_tree_walk(rt, range_tree_add,\n\t\t\t    vd->vdev_dtl[DTL_MISSING]);\n\t\t\tmutex_exit(&vd->vdev_dtl_lock);\n\t\t}\n\n\t\trange_tree_vacate(rt, NULL, NULL);\n\t\trange_tree_destroy(rt);\n\n\t\treturn (error);\n\t}\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\terror = vdev_dtl_load(vd->vdev_child[c]);\n\t\tif (error != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}\n\nstatic void\nvdev_zap_allocation_data(vdev_t *vd, dmu_tx_t *tx)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tvdev_alloc_bias_t alloc_bias = vd->vdev_alloc_bias;\n\tconst char *string;\n\n\tASSERT(alloc_bias != VDEV_BIAS_NONE);\n\n\tstring =\n\t    (alloc_bias == VDEV_BIAS_LOG) ? VDEV_ALLOC_BIAS_LOG :\n\t    (alloc_bias == VDEV_BIAS_SPECIAL) ? VDEV_ALLOC_BIAS_SPECIAL :\n\t    (alloc_bias == VDEV_BIAS_DEDUP) ? VDEV_ALLOC_BIAS_DEDUP : NULL;\n\n\tASSERT(string != NULL);\n\tVERIFY0(zap_add(mos, vd->vdev_top_zap, VDEV_TOP_ZAP_ALLOCATION_BIAS,\n\t    1, strlen(string) + 1, string, tx));\n\n\tif (alloc_bias == VDEV_BIAS_SPECIAL || alloc_bias == VDEV_BIAS_DEDUP) {\n\t\tspa_activate_allocation_classes(spa, tx);\n\t}\n}\n\nvoid\nvdev_destroy_unlink_zap(vdev_t *vd, uint64_t zapobj, dmu_tx_t *tx)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tVERIFY0(zap_destroy(spa->spa_meta_objset, zapobj, tx));\n\tVERIFY0(zap_remove_int(spa->spa_meta_objset, spa->spa_all_vdev_zaps,\n\t    zapobj, tx));\n}\n\nuint64_t\nvdev_create_link_zap(vdev_t *vd, dmu_tx_t *tx)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tuint64_t zap = zap_create(spa->spa_meta_objset, DMU_OTN_ZAP_METADATA,\n\t    DMU_OT_NONE, 0, tx);\n\n\tASSERT(zap != 0);\n\tVERIFY0(zap_add_int(spa->spa_meta_objset, spa->spa_all_vdev_zaps,\n\t    zap, tx));\n\n\treturn (zap);\n}\n\nvoid\nvdev_construct_zaps(vdev_t *vd, dmu_tx_t *tx)\n{\n\tif (vd->vdev_ops != &vdev_hole_ops &&\n\t    vd->vdev_ops != &vdev_missing_ops &&\n\t    vd->vdev_ops != &vdev_root_ops &&\n\t    !vd->vdev_top->vdev_removing) {\n\t\tif (vd->vdev_ops->vdev_op_leaf && vd->vdev_leaf_zap == 0) {\n\t\t\tvd->vdev_leaf_zap = vdev_create_link_zap(vd, tx);\n\t\t}\n\t\tif (vd == vd->vdev_top && vd->vdev_top_zap == 0) {\n\t\t\tvd->vdev_top_zap = vdev_create_link_zap(vd, tx);\n\t\t\tif (vd->vdev_alloc_bias != VDEV_BIAS_NONE)\n\t\t\t\tvdev_zap_allocation_data(vd, tx);\n\t\t}\n\t}\n\tif (vd->vdev_ops == &vdev_root_ops && vd->vdev_root_zap == 0 &&\n\t    spa_feature_is_enabled(vd->vdev_spa, SPA_FEATURE_AVZ_V2)) {\n\t\tif (!spa_feature_is_active(vd->vdev_spa, SPA_FEATURE_AVZ_V2))\n\t\t\tspa_feature_incr(vd->vdev_spa, SPA_FEATURE_AVZ_V2, tx);\n\t\tvd->vdev_root_zap = vdev_create_link_zap(vd, tx);\n\t}\n\n\tfor (uint64_t i = 0; i < vd->vdev_children; i++) {\n\t\tvdev_construct_zaps(vd->vdev_child[i], tx);\n\t}\n}\n\nstatic void\nvdev_dtl_sync(vdev_t *vd, uint64_t txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\trange_tree_t *rt = vd->vdev_dtl[DTL_MISSING];\n\tobjset_t *mos = spa->spa_meta_objset;\n\trange_tree_t *rtsync;\n\tdmu_tx_t *tx;\n\tuint64_t object = space_map_object(vd->vdev_dtl_sm);\n\n\tASSERT(vdev_is_concrete(vd));\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\ttx = dmu_tx_create_assigned(spa->spa_dsl_pool, txg);\n\n\tif (vd->vdev_detached || vd->vdev_top->vdev_removing) {\n\t\tmutex_enter(&vd->vdev_dtl_lock);\n\t\tspace_map_free(vd->vdev_dtl_sm, tx);\n\t\tspace_map_close(vd->vdev_dtl_sm);\n\t\tvd->vdev_dtl_sm = NULL;\n\t\tmutex_exit(&vd->vdev_dtl_lock);\n\n\t\t \n\t\tif (vd->vdev_leaf_zap != 0 && (vd->vdev_detached ||\n\t\t    vd->vdev_top->vdev_islog)) {\n\t\t\tvdev_destroy_unlink_zap(vd, vd->vdev_leaf_zap, tx);\n\t\t\tvd->vdev_leaf_zap = 0;\n\t\t}\n\n\t\tdmu_tx_commit(tx);\n\t\treturn;\n\t}\n\n\tif (vd->vdev_dtl_sm == NULL) {\n\t\tuint64_t new_object;\n\n\t\tnew_object = space_map_alloc(mos, zfs_vdev_dtl_sm_blksz, tx);\n\t\tVERIFY3U(new_object, !=, 0);\n\n\t\tVERIFY0(space_map_open(&vd->vdev_dtl_sm, mos, new_object,\n\t\t    0, -1ULL, 0));\n\t\tASSERT(vd->vdev_dtl_sm != NULL);\n\t}\n\n\trtsync = range_tree_create(NULL, RANGE_SEG64, NULL, 0, 0);\n\n\tmutex_enter(&vd->vdev_dtl_lock);\n\trange_tree_walk(rt, range_tree_add, rtsync);\n\tmutex_exit(&vd->vdev_dtl_lock);\n\n\tspace_map_truncate(vd->vdev_dtl_sm, zfs_vdev_dtl_sm_blksz, tx);\n\tspace_map_write(vd->vdev_dtl_sm, rtsync, SM_ALLOC, SM_NO_VDEVID, tx);\n\trange_tree_vacate(rtsync, NULL, NULL);\n\n\trange_tree_destroy(rtsync);\n\n\t \n\tif (object != space_map_object(vd->vdev_dtl_sm)) {\n\t\tvdev_dbgmsg(vd, \"txg %llu, spa %s, DTL old object %llu, \"\n\t\t    \"new object %llu\", (u_longlong_t)txg, spa_name(spa),\n\t\t    (u_longlong_t)object,\n\t\t    (u_longlong_t)space_map_object(vd->vdev_dtl_sm));\n\t\tvdev_config_dirty(vd->vdev_top);\n\t}\n\n\tdmu_tx_commit(tx);\n}\n\n \nboolean_t\nvdev_dtl_required(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *tvd = vd->vdev_top;\n\tuint8_t cant_read = vd->vdev_cant_read;\n\tboolean_t required;\n\n\tASSERT(spa_config_held(spa, SCL_STATE_ALL, RW_WRITER) == SCL_STATE_ALL);\n\n\tif (vd == spa->spa_root_vdev || vd == tvd)\n\t\treturn (B_TRUE);\n\n\t \n\tvd->vdev_cant_read = B_TRUE;\n\tvdev_dtl_reassess(tvd, 0, 0, B_FALSE, B_FALSE);\n\trequired = !vdev_dtl_empty(tvd, DTL_OUTAGE);\n\tvd->vdev_cant_read = cant_read;\n\tvdev_dtl_reassess(tvd, 0, 0, B_FALSE, B_FALSE);\n\n\tif (!required && zio_injection_enabled) {\n\t\trequired = !!zio_handle_device_injection(vd, NULL,\n\t\t    SET_ERROR(ECHILD));\n\t}\n\n\treturn (required);\n}\n\n \nboolean_t\nvdev_resilver_needed(vdev_t *vd, uint64_t *minp, uint64_t *maxp)\n{\n\tboolean_t needed = B_FALSE;\n\tuint64_t thismin = UINT64_MAX;\n\tuint64_t thismax = 0;\n\n\tif (vd->vdev_children == 0) {\n\t\tmutex_enter(&vd->vdev_dtl_lock);\n\t\tif (!range_tree_is_empty(vd->vdev_dtl[DTL_MISSING]) &&\n\t\t    vdev_writeable(vd)) {\n\n\t\t\tthismin = vdev_dtl_min(vd);\n\t\t\tthismax = vdev_dtl_max(vd);\n\t\t\tneeded = B_TRUE;\n\t\t}\n\t\tmutex_exit(&vd->vdev_dtl_lock);\n\t} else {\n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tvdev_t *cvd = vd->vdev_child[c];\n\t\t\tuint64_t cmin, cmax;\n\n\t\t\tif (vdev_resilver_needed(cvd, &cmin, &cmax)) {\n\t\t\t\tthismin = MIN(thismin, cmin);\n\t\t\t\tthismax = MAX(thismax, cmax);\n\t\t\t\tneeded = B_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needed && minp) {\n\t\t*minp = thismin;\n\t\t*maxp = thismax;\n\t}\n\treturn (needed);\n}\n\n \nint\nvdev_checkpoint_sm_object(vdev_t *vd, uint64_t *sm_obj)\n{\n\tASSERT0(spa_config_held(vd->vdev_spa, SCL_ALL, RW_WRITER));\n\n\tif (vd->vdev_top_zap == 0) {\n\t\t*sm_obj = 0;\n\t\treturn (0);\n\t}\n\n\tint error = zap_lookup(spa_meta_objset(vd->vdev_spa), vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_POOL_CHECKPOINT_SM, sizeof (uint64_t), 1, sm_obj);\n\tif (error == ENOENT) {\n\t\t*sm_obj = 0;\n\t\terror = 0;\n\t}\n\n\treturn (error);\n}\n\nint\nvdev_load(vdev_t *vd)\n{\n\tint children = vd->vdev_children;\n\tint error = 0;\n\ttaskq_t *tq = NULL;\n\n\t \n\tif (vd->vdev_ops == &vdev_root_ops && vd->vdev_children > 0) {\n\t\ttq = taskq_create(\"vdev_load\", children, minclsyspri,\n\t\t    children, children, TASKQ_PREPOPULATE);\n\t}\n\n\t \n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tif (tq == NULL || vdev_uses_zvols(cvd)) {\n\t\t\tcvd->vdev_load_error = vdev_load(cvd);\n\t\t} else {\n\t\t\tVERIFY(taskq_dispatch(tq, vdev_load_child,\n\t\t\t    cvd, TQ_SLEEP) != TASKQID_INVALID);\n\t\t}\n\t}\n\n\tif (tq != NULL) {\n\t\ttaskq_wait(tq);\n\t\ttaskq_destroy(tq);\n\t}\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tint error = vd->vdev_child[c]->vdev_load_error;\n\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\tvdev_set_deflate_ratio(vd);\n\n\t \n\tif (vd == vd->vdev_top && vd->vdev_top_zap != 0) {\n\t\tspa_t *spa = vd->vdev_spa;\n\t\tchar bias_str[64];\n\n\t\terror = zap_lookup(spa->spa_meta_objset, vd->vdev_top_zap,\n\t\t    VDEV_TOP_ZAP_ALLOCATION_BIAS, 1, sizeof (bias_str),\n\t\t    bias_str);\n\t\tif (error == 0) {\n\t\t\tASSERT(vd->vdev_alloc_bias == VDEV_BIAS_NONE);\n\t\t\tvd->vdev_alloc_bias = vdev_derive_alloc_bias(bias_str);\n\t\t} else if (error != ENOENT) {\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: zap_lookup(top_zap=%llu) \"\n\t\t\t    \"failed [error=%d]\",\n\t\t\t    (u_longlong_t)vd->vdev_top_zap, error);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (vd == vd->vdev_top && vd->vdev_top_zap != 0) {\n\t\tspa_t *spa = vd->vdev_spa;\n\t\tuint64_t failfast;\n\n\t\terror = zap_lookup(spa->spa_meta_objset, vd->vdev_top_zap,\n\t\t    vdev_prop_to_name(VDEV_PROP_FAILFAST), sizeof (failfast),\n\t\t    1, &failfast);\n\t\tif (error == 0) {\n\t\t\tvd->vdev_failfast = failfast & 1;\n\t\t} else if (error == ENOENT) {\n\t\t\tvd->vdev_failfast = vdev_prop_default_numeric(\n\t\t\t    VDEV_PROP_FAILFAST);\n\t\t} else {\n\t\t\tvdev_dbgmsg(vd,\n\t\t\t    \"vdev_load: zap_lookup(top_zap=%llu) \"\n\t\t\t    \"failed [error=%d]\",\n\t\t\t    (u_longlong_t)vd->vdev_top_zap, error);\n\t\t}\n\t}\n\n\t \n\tif (vd == vd->vdev_top && vd->vdev_top_zap != 0) {\n\t\terror = vdev_rebuild_load(vd);\n\t\tif (error && error != ENOTSUP) {\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: vdev_rebuild_load \"\n\t\t\t    \"failed [error=%d]\", error);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (vd->vdev_top_zap != 0 || vd->vdev_leaf_zap != 0) {\n\t\tuint64_t zapobj;\n\n\t\tif (vd->vdev_top_zap != 0)\n\t\t\tzapobj = vd->vdev_top_zap;\n\t\telse\n\t\t\tzapobj = vd->vdev_leaf_zap;\n\n\t\terror = vdev_prop_get_int(vd, VDEV_PROP_CHECKSUM_N,\n\t\t    &vd->vdev_checksum_n);\n\t\tif (error && error != ENOENT)\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: zap_lookup(zap=%llu) \"\n\t\t\t    \"failed [error=%d]\", (u_longlong_t)zapobj, error);\n\n\t\terror = vdev_prop_get_int(vd, VDEV_PROP_CHECKSUM_T,\n\t\t    &vd->vdev_checksum_t);\n\t\tif (error && error != ENOENT)\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: zap_lookup(zap=%llu) \"\n\t\t\t    \"failed [error=%d]\", (u_longlong_t)zapobj, error);\n\n\t\terror = vdev_prop_get_int(vd, VDEV_PROP_IO_N,\n\t\t    &vd->vdev_io_n);\n\t\tif (error && error != ENOENT)\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: zap_lookup(zap=%llu) \"\n\t\t\t    \"failed [error=%d]\", (u_longlong_t)zapobj, error);\n\n\t\terror = vdev_prop_get_int(vd, VDEV_PROP_IO_T,\n\t\t    &vd->vdev_io_t);\n\t\tif (error && error != ENOENT)\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: zap_lookup(zap=%llu) \"\n\t\t\t    \"failed [error=%d]\", (u_longlong_t)zapobj, error);\n\t}\n\n\t \n\tif (vd == vd->vdev_top && vdev_is_concrete(vd)) {\n\t\tvdev_metaslab_group_create(vd);\n\n\t\tif (vd->vdev_ashift == 0 || vd->vdev_asize == 0) {\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: invalid size. ashift=%llu, \"\n\t\t\t    \"asize=%llu\", (u_longlong_t)vd->vdev_ashift,\n\t\t\t    (u_longlong_t)vd->vdev_asize);\n\t\t\treturn (SET_ERROR(ENXIO));\n\t\t}\n\n\t\terror = vdev_metaslab_init(vd, 0);\n\t\tif (error != 0) {\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: metaslab_init failed \"\n\t\t\t    \"[error=%d]\", error);\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\t\treturn (error);\n\t\t}\n\n\t\tuint64_t checkpoint_sm_obj;\n\t\terror = vdev_checkpoint_sm_object(vd, &checkpoint_sm_obj);\n\t\tif (error == 0 && checkpoint_sm_obj != 0) {\n\t\t\tobjset_t *mos = spa_meta_objset(vd->vdev_spa);\n\t\t\tASSERT(vd->vdev_asize != 0);\n\t\t\tASSERT3P(vd->vdev_checkpoint_sm, ==, NULL);\n\n\t\t\terror = space_map_open(&vd->vdev_checkpoint_sm,\n\t\t\t    mos, checkpoint_sm_obj, 0, vd->vdev_asize,\n\t\t\t    vd->vdev_ashift);\n\t\t\tif (error != 0) {\n\t\t\t\tvdev_dbgmsg(vd, \"vdev_load: space_map_open \"\n\t\t\t\t    \"failed for checkpoint spacemap (obj %llu) \"\n\t\t\t\t    \"[error=%d]\",\n\t\t\t\t    (u_longlong_t)checkpoint_sm_obj, error);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\tASSERT3P(vd->vdev_checkpoint_sm, !=, NULL);\n\n\t\t\t \n\t\t\tvd->vdev_stat.vs_checkpoint_space =\n\t\t\t    -space_map_allocated(vd->vdev_checkpoint_sm);\n\t\t\tvd->vdev_spa->spa_checkpoint_info.sci_dspace +=\n\t\t\t    vd->vdev_stat.vs_checkpoint_space;\n\t\t} else if (error != 0) {\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: failed to retrieve \"\n\t\t\t    \"checkpoint space map object from vdev ZAP \"\n\t\t\t    \"[error=%d]\", error);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t \n\tif (vd->vdev_ops->vdev_op_leaf && (error = vdev_dtl_load(vd)) != 0) {\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tvdev_dbgmsg(vd, \"vdev_load: vdev_dtl_load failed \"\n\t\t    \"[error=%d]\", error);\n\t\treturn (error);\n\t}\n\n\tuint64_t obsolete_sm_object;\n\terror = vdev_obsolete_sm_object(vd, &obsolete_sm_object);\n\tif (error == 0 && obsolete_sm_object != 0) {\n\t\tobjset_t *mos = vd->vdev_spa->spa_meta_objset;\n\t\tASSERT(vd->vdev_asize != 0);\n\t\tASSERT3P(vd->vdev_obsolete_sm, ==, NULL);\n\n\t\tif ((error = space_map_open(&vd->vdev_obsolete_sm, mos,\n\t\t    obsolete_sm_object, 0, vd->vdev_asize, 0))) {\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\t\tvdev_dbgmsg(vd, \"vdev_load: space_map_open failed for \"\n\t\t\t    \"obsolete spacemap (obj %llu) [error=%d]\",\n\t\t\t    (u_longlong_t)obsolete_sm_object, error);\n\t\t\treturn (error);\n\t\t}\n\t} else if (error != 0) {\n\t\tvdev_dbgmsg(vd, \"vdev_load: failed to retrieve obsolete \"\n\t\t    \"space map object from vdev ZAP [error=%d]\", error);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}\n\n \nint\nvdev_validate_aux(vdev_t *vd)\n{\n\tnvlist_t *label;\n\tuint64_t guid, version;\n\tuint64_t state;\n\n\tif (!vdev_readable(vd))\n\t\treturn (0);\n\n\tif ((label = vdev_label_read_config(vd, -1ULL)) == NULL) {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\treturn (-1);\n\t}\n\n\tif (nvlist_lookup_uint64(label, ZPOOL_CONFIG_VERSION, &version) != 0 ||\n\t    !SPA_VERSION_IS_SUPPORTED(version) ||\n\t    nvlist_lookup_uint64(label, ZPOOL_CONFIG_GUID, &guid) != 0 ||\n\t    guid != vd->vdev_guid ||\n\t    nvlist_lookup_uint64(label, ZPOOL_CONFIG_POOL_STATE, &state) != 0) {\n\t\tvdev_set_state(vd, B_TRUE, VDEV_STATE_CANT_OPEN,\n\t\t    VDEV_AUX_CORRUPT_DATA);\n\t\tnvlist_free(label);\n\t\treturn (-1);\n\t}\n\n\t \n\tnvlist_free(label);\n\treturn (0);\n}\n\nstatic void\nvdev_destroy_ms_flush_data(vdev_t *vd, dmu_tx_t *tx)\n{\n\tobjset_t *mos = spa_meta_objset(vd->vdev_spa);\n\n\tif (vd->vdev_top_zap == 0)\n\t\treturn;\n\n\tuint64_t object = 0;\n\tint err = zap_lookup(mos, vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_MS_UNFLUSHED_PHYS_TXGS, sizeof (uint64_t), 1, &object);\n\tif (err == ENOENT)\n\t\treturn;\n\tVERIFY0(err);\n\n\tVERIFY0(dmu_object_free(mos, object, tx));\n\tVERIFY0(zap_remove(mos, vd->vdev_top_zap,\n\t    VDEV_TOP_ZAP_MS_UNFLUSHED_PHYS_TXGS, tx));\n}\n\n \nvoid\nvdev_destroy_spacemaps(vdev_t *vd, dmu_tx_t *tx)\n{\n\tif (vd->vdev_ms_array == 0)\n\t\treturn;\n\n\tobjset_t *mos = vd->vdev_spa->spa_meta_objset;\n\tuint64_t array_count = vd->vdev_asize >> vd->vdev_ms_shift;\n\tsize_t array_bytes = array_count * sizeof (uint64_t);\n\tuint64_t *smobj_array = kmem_alloc(array_bytes, KM_SLEEP);\n\tVERIFY0(dmu_read(mos, vd->vdev_ms_array, 0,\n\t    array_bytes, smobj_array, 0));\n\n\tfor (uint64_t i = 0; i < array_count; i++) {\n\t\tuint64_t smobj = smobj_array[i];\n\t\tif (smobj == 0)\n\t\t\tcontinue;\n\n\t\tspace_map_free_obj(mos, smobj, tx);\n\t}\n\n\tkmem_free(smobj_array, array_bytes);\n\tVERIFY0(dmu_object_free(mos, vd->vdev_ms_array, tx));\n\tvdev_destroy_ms_flush_data(vd, tx);\n\tvd->vdev_ms_array = 0;\n}\n\nstatic void\nvdev_remove_empty_log(vdev_t *vd, uint64_t txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(vd->vdev_islog);\n\tASSERT(vd == vd->vdev_top);\n\tASSERT3U(txg, ==, spa_syncing_txg(spa));\n\n\tdmu_tx_t *tx = dmu_tx_create_assigned(spa_get_dsl(spa), txg);\n\n\tvdev_destroy_spacemaps(vd, tx);\n\tif (vd->vdev_top_zap != 0) {\n\t\tvdev_destroy_unlink_zap(vd, vd->vdev_top_zap, tx);\n\t\tvd->vdev_top_zap = 0;\n\t}\n\n\tdmu_tx_commit(tx);\n}\n\nvoid\nvdev_sync_done(vdev_t *vd, uint64_t txg)\n{\n\tmetaslab_t *msp;\n\tboolean_t reassess = !txg_list_empty(&vd->vdev_ms_list, TXG_CLEAN(txg));\n\n\tASSERT(vdev_is_concrete(vd));\n\n\twhile ((msp = txg_list_remove(&vd->vdev_ms_list, TXG_CLEAN(txg)))\n\t    != NULL)\n\t\tmetaslab_sync_done(msp, txg);\n\n\tif (reassess) {\n\t\tmetaslab_sync_reassess(vd->vdev_mg);\n\t\tif (vd->vdev_log_mg != NULL)\n\t\t\tmetaslab_sync_reassess(vd->vdev_log_mg);\n\t}\n}\n\nvoid\nvdev_sync(vdev_t *vd, uint64_t txg)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *lvd;\n\tmetaslab_t *msp;\n\n\tASSERT3U(txg, ==, spa->spa_syncing_txg);\n\tdmu_tx_t *tx = dmu_tx_create_assigned(spa->spa_dsl_pool, txg);\n\tif (range_tree_space(vd->vdev_obsolete_segments) > 0) {\n\t\tASSERT(vd->vdev_removing ||\n\t\t    vd->vdev_ops == &vdev_indirect_ops);\n\n\t\tvdev_indirect_sync_obsolete(vd, tx);\n\n\t\t \n\t\tif (vd->vdev_ops == &vdev_indirect_ops) {\n\t\t\tASSERT(txg_list_empty(&vd->vdev_ms_list, txg));\n\t\t\tASSERT(txg_list_empty(&vd->vdev_dtl_list, txg));\n\t\t\tdmu_tx_commit(tx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tASSERT(vdev_is_concrete(vd));\n\n\tif (vd->vdev_ms_array == 0 && vd->vdev_ms_shift != 0 &&\n\t    !vd->vdev_removing) {\n\t\tASSERT(vd == vd->vdev_top);\n\t\tASSERT0(vd->vdev_indirect_config.vic_mapping_object);\n\t\tvd->vdev_ms_array = dmu_object_alloc(spa->spa_meta_objset,\n\t\t    DMU_OT_OBJECT_ARRAY, 0, DMU_OT_NONE, 0, tx);\n\t\tASSERT(vd->vdev_ms_array != 0);\n\t\tvdev_config_dirty(vd);\n\t}\n\n\twhile ((msp = txg_list_remove(&vd->vdev_ms_list, txg)) != NULL) {\n\t\tmetaslab_sync(msp, txg);\n\t\t(void) txg_list_add(&vd->vdev_ms_list, msp, TXG_CLEAN(txg));\n\t}\n\n\twhile ((lvd = txg_list_remove(&vd->vdev_dtl_list, txg)) != NULL)\n\t\tvdev_dtl_sync(lvd, txg);\n\n\t \n\tif (vd->vdev_islog && vd->vdev_stat.vs_alloc == 0 && vd->vdev_removing)\n\t\tvdev_remove_empty_log(vd, txg);\n\n\t(void) txg_list_add(&spa->spa_vdev_txg_list, vd, TXG_CLEAN(txg));\n\tdmu_tx_commit(tx);\n}\n\nuint64_t\nvdev_psize_to_asize(vdev_t *vd, uint64_t psize)\n{\n\treturn (vd->vdev_ops->vdev_op_asize(vd, psize));\n}\n\n \nint\nvdev_fault(spa_t *spa, uint64_t guid, vdev_aux_t aux)\n{\n\tvdev_t *vd, *tvd;\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\n\tif ((vd = spa_lookup_by_guid(spa, guid, B_TRUE)) == NULL)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENODEV)));\n\n\tif (!vd->vdev_ops->vdev_op_leaf)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENOTSUP)));\n\n\ttvd = vd->vdev_top;\n\n\t \n\tif (aux == VDEV_AUX_EXTERNAL_PERSIST) {\n\t\t \n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_EXTERNAL;\n\t\tvd->vdev_tmpoffline = B_FALSE;\n\t\taux = VDEV_AUX_EXTERNAL;\n\t} else {\n\t\tvd->vdev_tmpoffline = B_TRUE;\n\t}\n\n\t \n\tvd->vdev_label_aux = aux;\n\n\t \n\tvd->vdev_delayed_close = B_FALSE;\n\tvd->vdev_faulted = 1ULL;\n\tvd->vdev_degraded = 0ULL;\n\tvdev_set_state(vd, B_FALSE, VDEV_STATE_FAULTED, aux);\n\n\t \n\tif (!tvd->vdev_islog && vd->vdev_aux == NULL && vdev_dtl_required(vd)) {\n\t\tvd->vdev_degraded = 1ULL;\n\t\tvd->vdev_faulted = 0ULL;\n\n\t\t \n\t\tvdev_reopen(tvd);\n\n\t\tif (vdev_readable(vd))\n\t\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_DEGRADED, aux);\n\t}\n\n\treturn (spa_vdev_state_exit(spa, vd, 0));\n}\n\n \nint\nvdev_degrade(spa_t *spa, uint64_t guid, vdev_aux_t aux)\n{\n\tvdev_t *vd;\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\n\tif ((vd = spa_lookup_by_guid(spa, guid, B_TRUE)) == NULL)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENODEV)));\n\n\tif (!vd->vdev_ops->vdev_op_leaf)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENOTSUP)));\n\n\t \n\tif (vd->vdev_faulted || vd->vdev_degraded)\n\t\treturn (spa_vdev_state_exit(spa, NULL, 0));\n\n\tvd->vdev_degraded = 1ULL;\n\tif (!vdev_is_dead(vd))\n\t\tvdev_set_state(vd, B_FALSE, VDEV_STATE_DEGRADED,\n\t\t    aux);\n\n\treturn (spa_vdev_state_exit(spa, vd, 0));\n}\n\nint\nvdev_remove_wanted(spa_t *spa, uint64_t guid)\n{\n\tvdev_t *vd;\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\n\tif ((vd = spa_lookup_by_guid(spa, guid, B_TRUE)) == NULL)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENODEV)));\n\n\t \n\tif (vd->vdev_removed || vd->vdev_expanding)\n\t\treturn (spa_vdev_state_exit(spa, NULL, 0));\n\n\t \n\tif (vd->vdev_ops->vdev_op_leaf && !zio_wait(vdev_probe(vd, NULL)))\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(EEXIST)));\n\n\tvd->vdev_remove_wanted = B_TRUE;\n\tspa_async_request(spa, SPA_ASYNC_REMOVE);\n\n\treturn (spa_vdev_state_exit(spa, vd, 0));\n}\n\n\n \nint\nvdev_online(spa_t *spa, uint64_t guid, uint64_t flags, vdev_state_t *newstate)\n{\n\tvdev_t *vd, *tvd, *pvd, *rvd = spa->spa_root_vdev;\n\tboolean_t wasoffline;\n\tvdev_state_t oldstate;\n\n\tspa_vdev_state_enter(spa, SCL_NONE);\n\n\tif ((vd = spa_lookup_by_guid(spa, guid, B_TRUE)) == NULL)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENODEV)));\n\n\tif (!vd->vdev_ops->vdev_op_leaf)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENOTSUP)));\n\n\twasoffline = (vd->vdev_offline || vd->vdev_tmpoffline);\n\toldstate = vd->vdev_state;\n\n\ttvd = vd->vdev_top;\n\tvd->vdev_offline = B_FALSE;\n\tvd->vdev_tmpoffline = B_FALSE;\n\tvd->vdev_checkremove = !!(flags & ZFS_ONLINE_CHECKREMOVE);\n\tvd->vdev_forcefault = !!(flags & ZFS_ONLINE_FORCEFAULT);\n\n\t \n\tif (!vd->vdev_aux) {\n\t\tfor (pvd = vd; pvd != rvd; pvd = pvd->vdev_parent)\n\t\t\tpvd->vdev_expanding = !!((flags & ZFS_ONLINE_EXPAND) ||\n\t\t\t    spa->spa_autoexpand);\n\t\tvd->vdev_expansion_time = gethrestime_sec();\n\t}\n\n\tvdev_reopen(tvd);\n\tvd->vdev_checkremove = vd->vdev_forcefault = B_FALSE;\n\n\tif (!vd->vdev_aux) {\n\t\tfor (pvd = vd; pvd != rvd; pvd = pvd->vdev_parent)\n\t\t\tpvd->vdev_expanding = B_FALSE;\n\t}\n\n\tif (newstate)\n\t\t*newstate = vd->vdev_state;\n\tif ((flags & ZFS_ONLINE_UNSPARE) &&\n\t    !vdev_is_dead(vd) && vd->vdev_parent &&\n\t    vd->vdev_parent->vdev_ops == &vdev_spare_ops &&\n\t    vd->vdev_parent->vdev_child[0] == vd)\n\t\tvd->vdev_unspare = B_TRUE;\n\n\tif ((flags & ZFS_ONLINE_EXPAND) || spa->spa_autoexpand) {\n\n\t\t \n\t\tif (vd->vdev_aux)\n\t\t\treturn (spa_vdev_state_exit(spa, vd, ENOTSUP));\n\t\tspa->spa_ccw_fail_time = 0;\n\t\tspa_async_request(spa, SPA_ASYNC_CONFIG_UPDATE);\n\t}\n\n\t \n\tmutex_enter(&vd->vdev_initialize_lock);\n\tif (vdev_writeable(vd) &&\n\t    vd->vdev_initialize_thread == NULL &&\n\t    vd->vdev_initialize_state == VDEV_INITIALIZE_ACTIVE) {\n\t\t(void) vdev_initialize(vd);\n\t}\n\tmutex_exit(&vd->vdev_initialize_lock);\n\n\t \n\tmutex_enter(&vd->vdev_trim_lock);\n\tif (vdev_writeable(vd) && !vd->vdev_isl2cache &&\n\t    vd->vdev_trim_thread == NULL &&\n\t    vd->vdev_trim_state == VDEV_TRIM_ACTIVE) {\n\t\t(void) vdev_trim(vd, vd->vdev_trim_rate, vd->vdev_trim_partial,\n\t\t    vd->vdev_trim_secure);\n\t}\n\tmutex_exit(&vd->vdev_trim_lock);\n\n\tif (wasoffline ||\n\t    (oldstate < VDEV_STATE_DEGRADED &&\n\t    vd->vdev_state >= VDEV_STATE_DEGRADED)) {\n\t\tspa_event_notify(spa, vd, NULL, ESC_ZFS_VDEV_ONLINE);\n\n\t\t \n\t\tif (vd->vdev_unspare &&\n\t\t    !dsl_scan_resilvering(spa->spa_dsl_pool) &&\n\t\t    !dsl_scan_resilver_scheduled(spa->spa_dsl_pool) &&\n\t\t    !vdev_rebuild_active(tvd))\n\t\t\tspa_async_request(spa, SPA_ASYNC_DETACH_SPARE);\n\t}\n\treturn (spa_vdev_state_exit(spa, vd, 0));\n}\n\nstatic int\nvdev_offline_locked(spa_t *spa, uint64_t guid, uint64_t flags)\n{\n\tvdev_t *vd, *tvd;\n\tint error = 0;\n\tuint64_t generation;\n\tmetaslab_group_t *mg;\n\ntop:\n\tspa_vdev_state_enter(spa, SCL_ALLOC);\n\n\tif ((vd = spa_lookup_by_guid(spa, guid, B_TRUE)) == NULL)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENODEV)));\n\n\tif (!vd->vdev_ops->vdev_op_leaf)\n\t\treturn (spa_vdev_state_exit(spa, NULL, SET_ERROR(ENOTSUP)));\n\n\tif (vd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn (spa_vdev_state_exit(spa, NULL, ENOTSUP));\n\n\ttvd = vd->vdev_top;\n\tmg = tvd->vdev_mg;\n\tgeneration = spa->spa_config_generation + 1;\n\n\t \n\tif (!vd->vdev_offline) {\n\t\t \n\t\tif (!tvd->vdev_islog && vd->vdev_aux == NULL &&\n\t\t    vdev_dtl_required(vd))\n\t\t\treturn (spa_vdev_state_exit(spa, NULL,\n\t\t\t    SET_ERROR(EBUSY)));\n\n\t\t \n\t\tif (tvd->vdev_islog && mg != NULL) {\n\t\t\t \n\t\t\tASSERT3P(tvd->vdev_log_mg, ==, NULL);\n\t\t\tmetaslab_group_passivate(mg);\n\t\t\t(void) spa_vdev_state_exit(spa, vd, 0);\n\n\t\t\terror = spa_reset_logs(spa);\n\n\t\t\t \n\t\t\tif (error == 0 &&\n\t\t\t    tvd->vdev_checkpoint_sm != NULL) {\n\t\t\t\tASSERT3U(space_map_allocated(\n\t\t\t\t    tvd->vdev_checkpoint_sm), !=, 0);\n\t\t\t\terror = ZFS_ERR_CHECKPOINT_EXISTS;\n\t\t\t}\n\n\t\t\tspa_vdev_state_enter(spa, SCL_ALLOC);\n\n\t\t\t \n\t\t\tif (error || generation != spa->spa_config_generation) {\n\t\t\t\tmetaslab_group_activate(mg);\n\t\t\t\tif (error)\n\t\t\t\t\treturn (spa_vdev_state_exit(spa,\n\t\t\t\t\t    vd, error));\n\t\t\t\t(void) spa_vdev_state_exit(spa, vd, 0);\n\t\t\t\tgoto top;\n\t\t\t}\n\t\t\tASSERT0(tvd->vdev_stat.vs_alloc);\n\t\t}\n\n\t\t \n\t\tvd->vdev_offline = B_TRUE;\n\t\tvdev_reopen(tvd);\n\n\t\tif (!tvd->vdev_islog && vd->vdev_aux == NULL &&\n\t\t    vdev_is_dead(tvd)) {\n\t\t\tvd->vdev_offline = B_FALSE;\n\t\t\tvdev_reopen(tvd);\n\t\t\treturn (spa_vdev_state_exit(spa, NULL,\n\t\t\t    SET_ERROR(EBUSY)));\n\t\t}\n\n\t\t \n\t\tif (tvd->vdev_islog && mg != NULL)\n\t\t\tmetaslab_group_activate(mg);\n\t}\n\n\tvd->vdev_tmpoffline = !!(flags & ZFS_OFFLINE_TEMPORARY);\n\n\treturn (spa_vdev_state_exit(spa, vd, 0));\n}\n\nint\nvdev_offline(spa_t *spa, uint64_t guid, uint64_t flags)\n{\n\tint error;\n\n\tmutex_enter(&spa->spa_vdev_top_lock);\n\terror = vdev_offline_locked(spa, guid, flags);\n\tmutex_exit(&spa->spa_vdev_top_lock);\n\n\treturn (error);\n}\n\n \nvoid\nvdev_clear(spa_t *spa, vdev_t *vd)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tASSERT(spa_config_held(spa, SCL_STATE_ALL, RW_WRITER) == SCL_STATE_ALL);\n\n\tif (vd == NULL)\n\t\tvd = rvd;\n\n\tvd->vdev_stat.vs_read_errors = 0;\n\tvd->vdev_stat.vs_write_errors = 0;\n\tvd->vdev_stat.vs_checksum_errors = 0;\n\tvd->vdev_stat.vs_slow_ios = 0;\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_clear(spa, vd->vdev_child[c]);\n\n\t \n\tif (!vdev_is_concrete(vd) || vd->vdev_removed)\n\t\treturn;\n\n\t \n\tif (vd->vdev_faulted || vd->vdev_degraded ||\n\t    !vdev_readable(vd) || !vdev_writeable(vd)) {\n\t\t \n\t\tvd->vdev_forcefault = B_TRUE;\n\n\t\tvd->vdev_faulted = vd->vdev_degraded = 0ULL;\n\t\tvd->vdev_cant_read = B_FALSE;\n\t\tvd->vdev_cant_write = B_FALSE;\n\t\tvd->vdev_stat.vs_aux = 0;\n\n\t\tvdev_reopen(vd == rvd ? rvd : vd->vdev_top);\n\n\t\tvd->vdev_forcefault = B_FALSE;\n\n\t\tif (vd != rvd && vdev_writeable(vd->vdev_top))\n\t\t\tvdev_state_dirty(vd->vdev_top);\n\n\t\t \n\t\tif (vd->vdev_aux == NULL && !vdev_is_dead(vd) &&\n\t\t    !dsl_scan_resilvering(spa->spa_dsl_pool) &&\n\t\t    !dsl_scan_resilver_scheduled(spa->spa_dsl_pool))\n\t\t\tspa_async_request(spa, SPA_ASYNC_RESILVER_DONE);\n\n\t\tspa_event_notify(spa, vd, NULL, ESC_ZFS_VDEV_CLEAR);\n\t}\n\n\t \n\tif (!vdev_is_dead(vd) && vd->vdev_parent != NULL &&\n\t    vd->vdev_parent->vdev_ops == &vdev_spare_ops &&\n\t    vd->vdev_parent->vdev_child[0] == vd)\n\t\tvd->vdev_unspare = B_TRUE;\n\n\t \n\tzfs_ereport_clear(spa, vd);\n}\n\nboolean_t\nvdev_is_dead(vdev_t *vd)\n{\n\t \n\treturn (vd->vdev_state < VDEV_STATE_DEGRADED ||\n\t    vd->vdev_ops == &vdev_hole_ops ||\n\t    vd->vdev_ops == &vdev_missing_ops);\n}\n\nboolean_t\nvdev_readable(vdev_t *vd)\n{\n\treturn (!vdev_is_dead(vd) && !vd->vdev_cant_read);\n}\n\nboolean_t\nvdev_writeable(vdev_t *vd)\n{\n\treturn (!vdev_is_dead(vd) && !vd->vdev_cant_write &&\n\t    vdev_is_concrete(vd));\n}\n\nboolean_t\nvdev_allocatable(vdev_t *vd)\n{\n\tuint64_t state = vd->vdev_state;\n\n\t \n\treturn (!(state < VDEV_STATE_DEGRADED && state != VDEV_STATE_CLOSED) &&\n\t    !vd->vdev_cant_write && vdev_is_concrete(vd) &&\n\t    vd->vdev_mg->mg_initialized);\n}\n\nboolean_t\nvdev_accessible(vdev_t *vd, zio_t *zio)\n{\n\tASSERT(zio->io_vd == vd);\n\n\tif (vdev_is_dead(vd) || vd->vdev_remove_wanted)\n\t\treturn (B_FALSE);\n\n\tif (zio->io_type == ZIO_TYPE_READ)\n\t\treturn (!vd->vdev_cant_read);\n\n\tif (zio->io_type == ZIO_TYPE_WRITE)\n\t\treturn (!vd->vdev_cant_write);\n\n\treturn (B_TRUE);\n}\n\nstatic void\nvdev_get_child_stat(vdev_t *cvd, vdev_stat_t *vs, vdev_stat_t *cvs)\n{\n\t \n\tif (cvd->vdev_ops == &vdev_draid_spare_ops)\n\t\treturn;\n\n\tfor (int t = 0; t < VS_ZIO_TYPES; t++) {\n\t\tvs->vs_ops[t] += cvs->vs_ops[t];\n\t\tvs->vs_bytes[t] += cvs->vs_bytes[t];\n\t}\n\n\tcvs->vs_scan_removing = cvd->vdev_removing;\n}\n\n \nstatic void\nvdev_get_child_stat_ex(vdev_t *cvd, vdev_stat_ex_t *vsx, vdev_stat_ex_t *cvsx)\n{\n\t(void) cvd;\n\n\tint t, b;\n\tfor (t = 0; t < ZIO_TYPES; t++) {\n\t\tfor (b = 0; b < ARRAY_SIZE(vsx->vsx_disk_histo[0]); b++)\n\t\t\tvsx->vsx_disk_histo[t][b] += cvsx->vsx_disk_histo[t][b];\n\n\t\tfor (b = 0; b < ARRAY_SIZE(vsx->vsx_total_histo[0]); b++) {\n\t\t\tvsx->vsx_total_histo[t][b] +=\n\t\t\t    cvsx->vsx_total_histo[t][b];\n\t\t}\n\t}\n\n\tfor (t = 0; t < ZIO_PRIORITY_NUM_QUEUEABLE; t++) {\n\t\tfor (b = 0; b < ARRAY_SIZE(vsx->vsx_queue_histo[0]); b++) {\n\t\t\tvsx->vsx_queue_histo[t][b] +=\n\t\t\t    cvsx->vsx_queue_histo[t][b];\n\t\t}\n\t\tvsx->vsx_active_queue[t] += cvsx->vsx_active_queue[t];\n\t\tvsx->vsx_pend_queue[t] += cvsx->vsx_pend_queue[t];\n\n\t\tfor (b = 0; b < ARRAY_SIZE(vsx->vsx_ind_histo[0]); b++)\n\t\t\tvsx->vsx_ind_histo[t][b] += cvsx->vsx_ind_histo[t][b];\n\n\t\tfor (b = 0; b < ARRAY_SIZE(vsx->vsx_agg_histo[0]); b++)\n\t\t\tvsx->vsx_agg_histo[t][b] += cvsx->vsx_agg_histo[t][b];\n\t}\n\n}\n\nboolean_t\nvdev_is_spacemap_addressable(vdev_t *vd)\n{\n\tif (spa_feature_is_active(vd->vdev_spa, SPA_FEATURE_SPACEMAP_V2))\n\t\treturn (B_TRUE);\n\n\t \n\tuint64_t shift = vd->vdev_ashift + SM_OFFSET_BITS;\n\n\tif (shift >= 63)  \n\t\treturn (B_TRUE);\n\n\treturn (vd->vdev_asize < (1ULL << shift));\n}\n\n \nstatic void\nvdev_get_stats_ex_impl(vdev_t *vd, vdev_stat_t *vs, vdev_stat_ex_t *vsx)\n{\n\tint t;\n\t \n\tif (!vd->vdev_ops->vdev_op_leaf) {\n\t\tif (vs) {\n\t\t\tmemset(vs->vs_ops, 0, sizeof (vs->vs_ops));\n\t\t\tmemset(vs->vs_bytes, 0, sizeof (vs->vs_bytes));\n\t\t}\n\t\tif (vsx)\n\t\t\tmemset(vsx, 0, sizeof (*vsx));\n\n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tvdev_t *cvd = vd->vdev_child[c];\n\t\t\tvdev_stat_t *cvs = &cvd->vdev_stat;\n\t\t\tvdev_stat_ex_t *cvsx = &cvd->vdev_stat_ex;\n\n\t\t\tvdev_get_stats_ex_impl(cvd, cvs, cvsx);\n\t\t\tif (vs)\n\t\t\t\tvdev_get_child_stat(cvd, vs, cvs);\n\t\t\tif (vsx)\n\t\t\t\tvdev_get_child_stat_ex(cvd, vsx, cvsx);\n\t\t}\n\t} else {\n\t\t \n\t\tif (!vsx)\n\t\t\treturn;\n\n\t\tmemcpy(vsx, &vd->vdev_stat_ex, sizeof (vd->vdev_stat_ex));\n\n\t\tfor (t = 0; t < ZIO_PRIORITY_NUM_QUEUEABLE; t++) {\n\t\t\tvsx->vsx_active_queue[t] = vd->vdev_queue.vq_cactive[t];\n\t\t\tvsx->vsx_pend_queue[t] = vdev_queue_class_length(vd, t);\n\t\t}\n\t}\n}\n\nvoid\nvdev_get_stats_ex(vdev_t *vd, vdev_stat_t *vs, vdev_stat_ex_t *vsx)\n{\n\tvdev_t *tvd = vd->vdev_top;\n\tmutex_enter(&vd->vdev_stat_lock);\n\tif (vs) {\n\t\tmemcpy(vs, &vd->vdev_stat, sizeof (*vs));\n\t\tvs->vs_timestamp = gethrtime() - vs->vs_timestamp;\n\t\tvs->vs_state = vd->vdev_state;\n\t\tvs->vs_rsize = vdev_get_min_asize(vd);\n\n\t\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\t\tvs->vs_pspace = vd->vdev_psize;\n\t\t\tvs->vs_rsize += VDEV_LABEL_START_SIZE +\n\t\t\t    VDEV_LABEL_END_SIZE;\n\t\t\t \n\t\t\tvs->vs_initialize_bytes_done =\n\t\t\t    vd->vdev_initialize_bytes_done;\n\t\t\tvs->vs_initialize_bytes_est =\n\t\t\t    vd->vdev_initialize_bytes_est;\n\t\t\tvs->vs_initialize_state = vd->vdev_initialize_state;\n\t\t\tvs->vs_initialize_action_time =\n\t\t\t    vd->vdev_initialize_action_time;\n\n\t\t\t \n\t\t\tvs->vs_trim_notsup = !vd->vdev_has_trim;\n\t\t\tvs->vs_trim_bytes_done = vd->vdev_trim_bytes_done;\n\t\t\tvs->vs_trim_bytes_est = vd->vdev_trim_bytes_est;\n\t\t\tvs->vs_trim_state = vd->vdev_trim_state;\n\t\t\tvs->vs_trim_action_time = vd->vdev_trim_action_time;\n\n\t\t\t \n\t\t\tvs->vs_resilver_deferred = vd->vdev_resilver_deferred;\n\t\t}\n\n\t\t \n\t\tif (vd->vdev_aux == NULL && tvd != NULL) {\n\t\t\tvs->vs_esize = P2ALIGN(\n\t\t\t    vd->vdev_max_asize - vd->vdev_asize,\n\t\t\t    1ULL << tvd->vdev_ms_shift);\n\t\t}\n\n\t\tvs->vs_configured_ashift = vd->vdev_top != NULL\n\t\t    ? vd->vdev_top->vdev_ashift : vd->vdev_ashift;\n\t\tvs->vs_logical_ashift = vd->vdev_logical_ashift;\n\t\tif (vd->vdev_physical_ashift <= ASHIFT_MAX)\n\t\t\tvs->vs_physical_ashift = vd->vdev_physical_ashift;\n\t\telse\n\t\t\tvs->vs_physical_ashift = 0;\n\n\t\t \n\t\tif (vd->vdev_aux == NULL && vd == vd->vdev_top &&\n\t\t    vdev_is_concrete(vd)) {\n\t\t\t \n\t\t\tvs->vs_fragmentation = (vd->vdev_mg != NULL) ?\n\t\t\t    vd->vdev_mg->mg_fragmentation : 0;\n\t\t}\n\t\tvs->vs_noalloc = MAX(vd->vdev_noalloc,\n\t\t    tvd ? tvd->vdev_noalloc : 0);\n\t}\n\n\tvdev_get_stats_ex_impl(vd, vs, vsx);\n\tmutex_exit(&vd->vdev_stat_lock);\n}\n\nvoid\nvdev_get_stats(vdev_t *vd, vdev_stat_t *vs)\n{\n\treturn (vdev_get_stats_ex(vd, vs, NULL));\n}\n\nvoid\nvdev_clear_stats(vdev_t *vd)\n{\n\tmutex_enter(&vd->vdev_stat_lock);\n\tvd->vdev_stat.vs_space = 0;\n\tvd->vdev_stat.vs_dspace = 0;\n\tvd->vdev_stat.vs_alloc = 0;\n\tmutex_exit(&vd->vdev_stat_lock);\n}\n\nvoid\nvdev_scan_stat_init(vdev_t *vd)\n{\n\tvdev_stat_t *vs = &vd->vdev_stat;\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tvdev_scan_stat_init(vd->vdev_child[c]);\n\n\tmutex_enter(&vd->vdev_stat_lock);\n\tvs->vs_scan_processed = 0;\n\tmutex_exit(&vd->vdev_stat_lock);\n}\n\nvoid\nvdev_stat_update(zio_t *zio, uint64_t psize)\n{\n\tspa_t *spa = zio->io_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tvdev_t *vd = zio->io_vd ? zio->io_vd : rvd;\n\tvdev_t *pvd;\n\tuint64_t txg = zio->io_txg;\n \n#ifdef __SANITIZE_ADDRESS__\n\tvdev_stat_t *vs = vd ? &vd->vdev_stat : NULL;\n\tvdev_stat_ex_t *vsx = vd ? &vd->vdev_stat_ex : NULL;\n#else\n\tvdev_stat_t *vs = &vd->vdev_stat;\n\tvdev_stat_ex_t *vsx = &vd->vdev_stat_ex;\n#endif\n\tzio_type_t type = zio->io_type;\n\tint flags = zio->io_flags;\n\n\t \n\tif (zio->io_gang_tree)\n\t\treturn;\n\n\tif (zio->io_error == 0) {\n\t\t \n\t\tif (vd == rvd)\n\t\t\treturn;\n\n\t\tASSERT(vd == zio->io_vd);\n\n\t\tif (flags & ZIO_FLAG_IO_BYPASS)\n\t\t\treturn;\n\n\t\tmutex_enter(&vd->vdev_stat_lock);\n\n\t\tif (flags & ZIO_FLAG_IO_REPAIR) {\n\t\t\t \n\t\t\tif (flags & ZIO_FLAG_SCAN_THREAD) {\n\t\t\t\tdsl_scan_t *scn = spa->spa_dsl_pool->dp_scan;\n\t\t\t\tdsl_scan_phys_t *scn_phys = &scn->scn_phys;\n\t\t\t\tuint64_t *processed = &scn_phys->scn_processed;\n\n\t\t\t\tif (vd->vdev_ops->vdev_op_leaf)\n\t\t\t\t\tatomic_add_64(processed, psize);\n\t\t\t\tvs->vs_scan_processed += psize;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (zio->io_priority == ZIO_PRIORITY_REBUILD) {\n\t\t\t\tvdev_t *tvd = vd->vdev_top;\n\t\t\t\tvdev_rebuild_t *vr = &tvd->vdev_rebuild_config;\n\t\t\t\tvdev_rebuild_phys_t *vrp = &vr->vr_rebuild_phys;\n\t\t\t\tuint64_t *rebuilt = &vrp->vrp_bytes_rebuilt;\n\n\t\t\t\tif (vd->vdev_ops->vdev_op_leaf &&\n\t\t\t\t    vd->vdev_ops != &vdev_draid_spare_ops) {\n\t\t\t\t\tatomic_add_64(rebuilt, psize);\n\t\t\t\t}\n\t\t\t\tvs->vs_rebuild_processed += psize;\n\t\t\t}\n\n\t\t\tif (flags & ZIO_FLAG_SELF_HEAL)\n\t\t\t\tvs->vs_self_healed += psize;\n\t\t}\n\n\t\t \n\t\tif (vd->vdev_ops->vdev_op_leaf &&\n\t\t    (zio->io_priority < ZIO_PRIORITY_NUM_QUEUEABLE)) {\n\t\t\tzio_type_t vs_type = type;\n\t\t\tzio_priority_t priority = zio->io_priority;\n\n\t\t\t \n\t\t\tif (type == ZIO_TYPE_TRIM)\n\t\t\t\tvs_type = ZIO_TYPE_IOCTL;\n\n\t\t\t \n\t\t\tif (priority == ZIO_PRIORITY_INITIALIZING) {\n\t\t\t\tASSERT3U(type, ==, ZIO_TYPE_WRITE);\n\t\t\t\tpriority = ZIO_PRIORITY_ASYNC_WRITE;\n\t\t\t} else if (priority == ZIO_PRIORITY_REMOVAL) {\n\t\t\t\tpriority = ((type == ZIO_TYPE_WRITE) ?\n\t\t\t\t    ZIO_PRIORITY_ASYNC_WRITE :\n\t\t\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t\t\t}\n\n\t\t\tvs->vs_ops[vs_type]++;\n\t\t\tvs->vs_bytes[vs_type] += psize;\n\n\t\t\tif (flags & ZIO_FLAG_DELEGATED) {\n\t\t\t\tvsx->vsx_agg_histo[priority]\n\t\t\t\t    [RQ_HISTO(zio->io_size)]++;\n\t\t\t} else {\n\t\t\t\tvsx->vsx_ind_histo[priority]\n\t\t\t\t    [RQ_HISTO(zio->io_size)]++;\n\t\t\t}\n\n\t\t\tif (zio->io_delta && zio->io_delay) {\n\t\t\t\tvsx->vsx_queue_histo[priority]\n\t\t\t\t    [L_HISTO(zio->io_delta - zio->io_delay)]++;\n\t\t\t\tvsx->vsx_disk_histo[type]\n\t\t\t\t    [L_HISTO(zio->io_delay)]++;\n\t\t\t\tvsx->vsx_total_histo[type]\n\t\t\t\t    [L_HISTO(zio->io_delta)]++;\n\t\t\t}\n\t\t}\n\n\t\tmutex_exit(&vd->vdev_stat_lock);\n\t\treturn;\n\t}\n\n\tif (flags & ZIO_FLAG_SPECULATIVE)\n\t\treturn;\n\n\t \n\tif (zio->io_error == EIO &&\n\t    !(zio->io_flags & ZIO_FLAG_IO_RETRY))\n\t\treturn;\n\n\t \n\tif (zio->io_vd == NULL && (zio->io_flags & ZIO_FLAG_DONT_PROPAGATE))\n\t\treturn;\n\n\tif (type == ZIO_TYPE_WRITE && txg != 0 &&\n\t    (!(flags & ZIO_FLAG_IO_REPAIR) ||\n\t    (flags & ZIO_FLAG_SCAN_THREAD) ||\n\t    spa->spa_claiming)) {\n\t\t \n\t\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\t\tuint64_t commit_txg = txg;\n\t\t\tif (flags & ZIO_FLAG_SCAN_THREAD) {\n\t\t\t\tASSERT(flags & ZIO_FLAG_IO_REPAIR);\n\t\t\t\tASSERT(spa_sync_pass(spa) == 1);\n\t\t\t\tvdev_dtl_dirty(vd, DTL_SCRUB, txg, 1);\n\t\t\t\tcommit_txg = spa_syncing_txg(spa);\n\t\t\t} else if (spa->spa_claiming) {\n\t\t\t\tASSERT(flags & ZIO_FLAG_IO_REPAIR);\n\t\t\t\tcommit_txg = spa_first_txg(spa);\n\t\t\t}\n\t\t\tASSERT(commit_txg >= spa_syncing_txg(spa));\n\t\t\tif (vdev_dtl_contains(vd, DTL_MISSING, txg, 1))\n\t\t\t\treturn;\n\t\t\tfor (pvd = vd; pvd != rvd; pvd = pvd->vdev_parent)\n\t\t\t\tvdev_dtl_dirty(pvd, DTL_PARTIAL, txg, 1);\n\t\t\tvdev_dirty(vd->vdev_top, VDD_DTL, vd, commit_txg);\n\t\t}\n\t\tif (vd != rvd)\n\t\t\tvdev_dtl_dirty(vd, DTL_MISSING, txg, 1);\n\t}\n}\n\nint64_t\nvdev_deflated_space(vdev_t *vd, int64_t space)\n{\n\tASSERT((space & (SPA_MINBLOCKSIZE-1)) == 0);\n\tASSERT(vd->vdev_deflate_ratio != 0 || vd->vdev_isl2cache);\n\n\treturn ((space >> SPA_MINBLOCKSHIFT) * vd->vdev_deflate_ratio);\n}\n\n \nvoid\nvdev_space_update(vdev_t *vd, int64_t alloc_delta, int64_t defer_delta,\n    int64_t space_delta)\n{\n\t(void) defer_delta;\n\tint64_t dspace_delta;\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tASSERT(vd == vd->vdev_top);\n\n\t \n\tdspace_delta = vdev_deflated_space(vd, space_delta);\n\n\tmutex_enter(&vd->vdev_stat_lock);\n\t \n\tif (alloc_delta < 0) {\n\t\tASSERT3U(vd->vdev_stat.vs_alloc, >=, -alloc_delta);\n\t}\n\n\tvd->vdev_stat.vs_alloc += alloc_delta;\n\tvd->vdev_stat.vs_space += space_delta;\n\tvd->vdev_stat.vs_dspace += dspace_delta;\n\tmutex_exit(&vd->vdev_stat_lock);\n\n\t \n\tif (vd->vdev_mg != NULL && !vd->vdev_islog) {\n\t\tASSERT(!vd->vdev_isl2cache);\n\t\tmutex_enter(&rvd->vdev_stat_lock);\n\t\trvd->vdev_stat.vs_alloc += alloc_delta;\n\t\trvd->vdev_stat.vs_space += space_delta;\n\t\trvd->vdev_stat.vs_dspace += dspace_delta;\n\t\tmutex_exit(&rvd->vdev_stat_lock);\n\t}\n\t \n}\n\n \nvoid\nvdev_config_dirty(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tint c;\n\n\tASSERT(spa_writeable(spa));\n\n\t \n\tif (vd->vdev_aux != NULL) {\n\t\tspa_aux_vdev_t *sav = vd->vdev_aux;\n\t\tnvlist_t **aux;\n\t\tuint_t naux;\n\n\t\tfor (c = 0; c < sav->sav_count; c++) {\n\t\t\tif (sav->sav_vdevs[c] == vd)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (c == sav->sav_count) {\n\t\t\t \n\t\t\tASSERT(sav->sav_sync == B_TRUE);\n\t\t\treturn;\n\t\t}\n\n\t\tsav->sav_sync = B_TRUE;\n\n\t\tif (nvlist_lookup_nvlist_array(sav->sav_config,\n\t\t    ZPOOL_CONFIG_L2CACHE, &aux, &naux) != 0) {\n\t\t\tVERIFY(nvlist_lookup_nvlist_array(sav->sav_config,\n\t\t\t    ZPOOL_CONFIG_SPARES, &aux, &naux) == 0);\n\t\t}\n\n\t\tASSERT(c < naux);\n\n\t\t \n\t\tnvlist_free(aux[c]);\n\t\taux[c] = vdev_config_generate(spa, vd, B_TRUE, 0);\n\n\t\treturn;\n\t}\n\n\t \n\tASSERT(spa_config_held(spa, SCL_CONFIG, RW_WRITER) ||\n\t    (dsl_pool_sync_context(spa_get_dsl(spa)) &&\n\t    spa_config_held(spa, SCL_CONFIG, RW_READER)));\n\n\tif (vd == rvd) {\n\t\tfor (c = 0; c < rvd->vdev_children; c++)\n\t\t\tvdev_config_dirty(rvd->vdev_child[c]);\n\t} else {\n\t\tASSERT(vd == vd->vdev_top);\n\n\t\tif (!list_link_active(&vd->vdev_config_dirty_node) &&\n\t\t    vdev_is_concrete(vd)) {\n\t\t\tlist_insert_head(&spa->spa_config_dirty_list, vd);\n\t\t}\n\t}\n}\n\nvoid\nvdev_config_clean(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(spa_config_held(spa, SCL_CONFIG, RW_WRITER) ||\n\t    (dsl_pool_sync_context(spa_get_dsl(spa)) &&\n\t    spa_config_held(spa, SCL_CONFIG, RW_READER)));\n\n\tASSERT(list_link_active(&vd->vdev_config_dirty_node));\n\tlist_remove(&spa->spa_config_dirty_list, vd);\n}\n\n \nvoid\nvdev_state_dirty(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(spa_writeable(spa));\n\tASSERT(vd == vd->vdev_top);\n\n\t \n\tASSERT(spa_config_held(spa, SCL_STATE, RW_WRITER) ||\n\t    (dsl_pool_sync_context(spa_get_dsl(spa)) &&\n\t    spa_config_held(spa, SCL_STATE, RW_READER)));\n\n\tif (!list_link_active(&vd->vdev_state_dirty_node) &&\n\t    vdev_is_concrete(vd))\n\t\tlist_insert_head(&spa->spa_state_dirty_list, vd);\n}\n\nvoid\nvdev_state_clean(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\n\tASSERT(spa_config_held(spa, SCL_STATE, RW_WRITER) ||\n\t    (dsl_pool_sync_context(spa_get_dsl(spa)) &&\n\t    spa_config_held(spa, SCL_STATE, RW_READER)));\n\n\tASSERT(list_link_active(&vd->vdev_state_dirty_node));\n\tlist_remove(&spa->spa_state_dirty_list, vd);\n}\n\n \nvoid\nvdev_propagate_state(vdev_t *vd)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tint degraded = 0, faulted = 0;\n\tint corrupted = 0;\n\tvdev_t *child;\n\n\tif (vd->vdev_children > 0) {\n\t\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\t\tchild = vd->vdev_child[c];\n\n\t\t\t \n\t\t\tif (!vdev_is_concrete(child))\n\t\t\t\tcontinue;\n\n\t\t\tif (!vdev_readable(child) ||\n\t\t\t    (!vdev_writeable(child) && spa_writeable(spa))) {\n\t\t\t\t \n\t\t\t\tif (child->vdev_islog && vd == rvd)\n\t\t\t\t\tdegraded++;\n\t\t\t\telse\n\t\t\t\t\tfaulted++;\n\t\t\t} else if (child->vdev_state <= VDEV_STATE_DEGRADED) {\n\t\t\t\tdegraded++;\n\t\t\t}\n\n\t\t\tif (child->vdev_stat.vs_aux == VDEV_AUX_CORRUPT_DATA)\n\t\t\t\tcorrupted++;\n\t\t}\n\n\t\tvd->vdev_ops->vdev_op_state_change(vd, faulted, degraded);\n\n\t\t \n\t\tif (corrupted && vd == rvd &&\n\t\t    rvd->vdev_state == VDEV_STATE_CANT_OPEN)\n\t\t\tvdev_set_state(rvd, B_FALSE, VDEV_STATE_CANT_OPEN,\n\t\t\t    VDEV_AUX_CORRUPT_DATA);\n\t}\n\n\tif (vd->vdev_parent)\n\t\tvdev_propagate_state(vd->vdev_parent);\n}\n\n \nvoid\nvdev_set_state(vdev_t *vd, boolean_t isopen, vdev_state_t state, vdev_aux_t aux)\n{\n\tuint64_t save_state;\n\tspa_t *spa = vd->vdev_spa;\n\n\tif (state == vd->vdev_state) {\n\t\t \n\t\tif (vd->vdev_ops->vdev_op_leaf &&\n\t\t    (state == VDEV_STATE_OFFLINE) &&\n\t\t    (vd->vdev_prevstate >= VDEV_STATE_FAULTED)) {\n\t\t\t \n\t\t\tzfs_post_state_change(spa, vd, vd->vdev_prevstate);\n\t\t}\n\t\tvd->vdev_stat.vs_aux = aux;\n\t\treturn;\n\t}\n\n\tsave_state = vd->vdev_state;\n\n\tvd->vdev_state = state;\n\tvd->vdev_stat.vs_aux = aux;\n\n\t \n\tif (!vd->vdev_delayed_close && vdev_is_dead(vd) &&\n\t    vd->vdev_ops->vdev_op_leaf)\n\t\tvd->vdev_ops->vdev_op_close(vd);\n\n\tif (vd->vdev_removed &&\n\t    state == VDEV_STATE_CANT_OPEN &&\n\t    (aux == VDEV_AUX_OPEN_FAILED || vd->vdev_checkremove)) {\n\t\t \n\t\tvd->vdev_state = VDEV_STATE_REMOVED;\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_NONE;\n\t} else if (state == VDEV_STATE_REMOVED) {\n\t\tvd->vdev_removed = B_TRUE;\n\t} else if (state == VDEV_STATE_CANT_OPEN) {\n\t\t \n\t\tif ((spa_load_state(spa) == SPA_LOAD_IMPORT ||\n\t\t    spa_load_state(spa) == SPA_LOAD_RECOVER) &&\n\t\t    vd->vdev_ops->vdev_op_leaf)\n\t\t\tvd->vdev_not_present = 1;\n\n\t\t \n\t\tif ((vd->vdev_prevstate != state || vd->vdev_forcefault) &&\n\t\t    !vd->vdev_not_present && !vd->vdev_checkremove &&\n\t\t    vd != spa->spa_root_vdev) {\n\t\t\tconst char *class;\n\n\t\t\tswitch (aux) {\n\t\t\tcase VDEV_AUX_OPEN_FAILED:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_OPEN_FAILED;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_AUX_CORRUPT_DATA:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_CORRUPT_DATA;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_AUX_NO_REPLICAS:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_NO_REPLICAS;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_AUX_BAD_GUID_SUM:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_BAD_GUID_SUM;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_AUX_TOO_SMALL:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_TOO_SMALL;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_AUX_BAD_LABEL:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_BAD_LABEL;\n\t\t\t\tbreak;\n\t\t\tcase VDEV_AUX_BAD_ASHIFT:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_BAD_ASHIFT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tclass = FM_EREPORT_ZFS_DEVICE_UNKNOWN;\n\t\t\t}\n\n\t\t\t(void) zfs_ereport_post(class, spa, vd, NULL, NULL,\n\t\t\t    save_state);\n\t\t}\n\n\t\t \n\t\tvd->vdev_removed = B_FALSE;\n\t} else {\n\t\tvd->vdev_removed = B_FALSE;\n\t}\n\n\t \n\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\t \n\t\tif ((vd->vdev_prevstate != VDEV_STATE_UNKNOWN) &&\n\t\t    (vd->vdev_prevstate != vd->vdev_state) &&\n\t\t    (save_state <= VDEV_STATE_CLOSED))\n\t\t\tsave_state = vd->vdev_prevstate;\n\n\t\t \n\t\tif (save_state > VDEV_STATE_CLOSED)\n\t\t\tzfs_post_state_change(spa, vd, save_state);\n\t}\n\n\tif (!isopen && vd->vdev_parent)\n\t\tvdev_propagate_state(vd->vdev_parent);\n}\n\nboolean_t\nvdev_children_are_offline(vdev_t *vd)\n{\n\tASSERT(!vd->vdev_ops->vdev_op_leaf);\n\n\tfor (uint64_t i = 0; i < vd->vdev_children; i++) {\n\t\tif (vd->vdev_child[i]->vdev_state != VDEV_STATE_OFFLINE)\n\t\t\treturn (B_FALSE);\n\t}\n\n\treturn (B_TRUE);\n}\n\n \nboolean_t\nvdev_is_bootable(vdev_t *vd)\n{\n\tif (!vd->vdev_ops->vdev_op_leaf) {\n\t\tconst char *vdev_type = vd->vdev_ops->vdev_op_type;\n\n\t\tif (strcmp(vdev_type, VDEV_TYPE_MISSING) == 0)\n\t\t\treturn (B_FALSE);\n\t}\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tif (!vdev_is_bootable(vd->vdev_child[c]))\n\t\t\treturn (B_FALSE);\n\t}\n\treturn (B_TRUE);\n}\n\nboolean_t\nvdev_is_concrete(vdev_t *vd)\n{\n\tvdev_ops_t *ops = vd->vdev_ops;\n\tif (ops == &vdev_indirect_ops || ops == &vdev_hole_ops ||\n\t    ops == &vdev_missing_ops || ops == &vdev_root_ops) {\n\t\treturn (B_FALSE);\n\t} else {\n\t\treturn (B_TRUE);\n\t}\n}\n\n \nboolean_t\nvdev_log_state_valid(vdev_t *vd)\n{\n\tif (vd->vdev_ops->vdev_op_leaf && !vd->vdev_faulted &&\n\t    !vd->vdev_removed)\n\t\treturn (B_TRUE);\n\n\tfor (int c = 0; c < vd->vdev_children; c++)\n\t\tif (vdev_log_state_valid(vd->vdev_child[c]))\n\t\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\n \nvoid\nvdev_expand(vdev_t *vd, uint64_t txg)\n{\n\tASSERT(vd->vdev_top == vd);\n\tASSERT(spa_config_held(vd->vdev_spa, SCL_ALL, RW_WRITER) == SCL_ALL);\n\tASSERT(vdev_is_concrete(vd));\n\n\tvdev_set_deflate_ratio(vd);\n\n\tif ((vd->vdev_asize >> vd->vdev_ms_shift) > vd->vdev_ms_count &&\n\t    vdev_is_concrete(vd)) {\n\t\tvdev_metaslab_group_create(vd);\n\t\tVERIFY(vdev_metaslab_init(vd, txg) == 0);\n\t\tvdev_config_dirty(vd);\n\t}\n}\n\n \nvoid\nvdev_split(vdev_t *vd)\n{\n\tvdev_t *cvd, *pvd = vd->vdev_parent;\n\n\tVERIFY3U(pvd->vdev_children, >, 1);\n\n\tvdev_remove_child(pvd, vd);\n\tvdev_compact_children(pvd);\n\n\tASSERT3P(pvd->vdev_child, !=, NULL);\n\n\tcvd = pvd->vdev_child[0];\n\tif (pvd->vdev_children == 1) {\n\t\tvdev_remove_parent(cvd);\n\t\tcvd->vdev_splitting = B_TRUE;\n\t}\n\tvdev_propagate_state(cvd);\n}\n\nvoid\nvdev_deadman(vdev_t *vd, const char *tag)\n{\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\n\t\tvdev_deadman(cvd, tag);\n\t}\n\n\tif (vd->vdev_ops->vdev_op_leaf) {\n\t\tvdev_queue_t *vq = &vd->vdev_queue;\n\n\t\tmutex_enter(&vq->vq_lock);\n\t\tif (vq->vq_active > 0) {\n\t\t\tspa_t *spa = vd->vdev_spa;\n\t\t\tzio_t *fio;\n\t\t\tuint64_t delta;\n\n\t\t\tzfs_dbgmsg(\"slow vdev: %s has %u active IOs\",\n\t\t\t    vd->vdev_path, vq->vq_active);\n\n\t\t\t \n\t\t\tfio = list_head(&vq->vq_active_list);\n\t\t\tdelta = gethrtime() - fio->io_timestamp;\n\t\t\tif (delta > spa_deadman_synctime(spa))\n\t\t\t\tzio_deadman(fio, tag);\n\t\t}\n\t\tmutex_exit(&vq->vq_lock);\n\t}\n}\n\nvoid\nvdev_defer_resilver(vdev_t *vd)\n{\n\tASSERT(vd->vdev_ops->vdev_op_leaf);\n\n\tvd->vdev_resilver_deferred = B_TRUE;\n\tvd->vdev_spa->spa_resilver_deferred = B_TRUE;\n}\n\n \nboolean_t\nvdev_clear_resilver_deferred(vdev_t *vd, dmu_tx_t *tx)\n{\n\tboolean_t resilver_needed = B_FALSE;\n\tspa_t *spa = vd->vdev_spa;\n\n\tfor (int c = 0; c < vd->vdev_children; c++) {\n\t\tvdev_t *cvd = vd->vdev_child[c];\n\t\tresilver_needed |= vdev_clear_resilver_deferred(cvd, tx);\n\t}\n\n\tif (vd == spa->spa_root_vdev &&\n\t    spa_feature_is_active(spa, SPA_FEATURE_RESILVER_DEFER)) {\n\t\tspa_feature_decr(spa, SPA_FEATURE_RESILVER_DEFER, tx);\n\t\tvdev_config_dirty(vd);\n\t\tspa->spa_resilver_deferred = B_FALSE;\n\t\treturn (resilver_needed);\n\t}\n\n\tif (!vdev_is_concrete(vd) || vd->vdev_aux ||\n\t    !vd->vdev_ops->vdev_op_leaf)\n\t\treturn (resilver_needed);\n\n\tvd->vdev_resilver_deferred = B_FALSE;\n\n\treturn (!vdev_is_dead(vd) && !vd->vdev_offline &&\n\t    vdev_resilver_needed(vd, NULL, NULL));\n}\n\nboolean_t\nvdev_xlate_is_empty(range_seg64_t *rs)\n{\n\treturn (rs->rs_start == rs->rs_end);\n}\n\n \nvoid\nvdev_xlate(vdev_t *vd, const range_seg64_t *logical_rs,\n    range_seg64_t *physical_rs, range_seg64_t *remain_rs)\n{\n\t \n\tif (vd != vd->vdev_top) {\n\t\tvdev_xlate(vd->vdev_parent, logical_rs, physical_rs,\n\t\t    remain_rs);\n\t} else {\n\t\t \n\t\tphysical_rs->rs_start = logical_rs->rs_start;\n\t\tphysical_rs->rs_end = logical_rs->rs_end;\n\n\t\tremain_rs->rs_start = logical_rs->rs_start;\n\t\tremain_rs->rs_end = logical_rs->rs_start;\n\n\t\treturn;\n\t}\n\n\tvdev_t *pvd = vd->vdev_parent;\n\tASSERT3P(pvd, !=, NULL);\n\tASSERT3P(pvd->vdev_ops->vdev_op_xlate, !=, NULL);\n\n\t \n\trange_seg64_t intermediate = { 0 };\n\tpvd->vdev_ops->vdev_op_xlate(vd, physical_rs, &intermediate, remain_rs);\n\n\tphysical_rs->rs_start = intermediate.rs_start;\n\tphysical_rs->rs_end = intermediate.rs_end;\n}\n\nvoid\nvdev_xlate_walk(vdev_t *vd, const range_seg64_t *logical_rs,\n    vdev_xlate_func_t *func, void *arg)\n{\n\trange_seg64_t iter_rs = *logical_rs;\n\trange_seg64_t physical_rs;\n\trange_seg64_t remain_rs;\n\n\twhile (!vdev_xlate_is_empty(&iter_rs)) {\n\n\t\tvdev_xlate(vd, &iter_rs, &physical_rs, &remain_rs);\n\n\t\t \n\t\tif (!vdev_xlate_is_empty(&physical_rs))\n\t\t\tfunc(arg, &physical_rs);\n\n\t\titer_rs = remain_rs;\n\t}\n}\n\nstatic char *\nvdev_name(vdev_t *vd, char *buf, int buflen)\n{\n\tif (vd->vdev_path == NULL) {\n\t\tif (strcmp(vd->vdev_ops->vdev_op_type, \"root\") == 0) {\n\t\t\tstrlcpy(buf, vd->vdev_spa->spa_name, buflen);\n\t\t} else if (!vd->vdev_ops->vdev_op_leaf) {\n\t\t\tsnprintf(buf, buflen, \"%s-%llu\",\n\t\t\t    vd->vdev_ops->vdev_op_type,\n\t\t\t    (u_longlong_t)vd->vdev_id);\n\t\t}\n\t} else {\n\t\tstrlcpy(buf, vd->vdev_path, buflen);\n\t}\n\treturn (buf);\n}\n\n \nboolean_t\nvdev_replace_in_progress(vdev_t *vdev)\n{\n\tASSERT(spa_config_held(vdev->vdev_spa, SCL_ALL, RW_READER) != 0);\n\n\tif (vdev->vdev_ops == &vdev_replacing_ops)\n\t\treturn (B_TRUE);\n\n\t \n\tif (vdev->vdev_ops == &vdev_spare_ops && (vdev->vdev_children > 2 ||\n\t    !vdev_dtl_empty(vdev->vdev_child[1], DTL_MISSING)))\n\t\treturn (B_TRUE);\n\n\tfor (int i = 0; i < vdev->vdev_children; i++) {\n\t\tif (vdev_replace_in_progress(vdev->vdev_child[i]))\n\t\t\treturn (B_TRUE);\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nstatic void\nvdev_prop_add_list(nvlist_t *nvl, const char *propname, const char *strval,\n    uint64_t intval, zprop_source_t src)\n{\n\tnvlist_t *propval;\n\n\tpropval = fnvlist_alloc();\n\tfnvlist_add_uint64(propval, ZPROP_SOURCE, src);\n\n\tif (strval != NULL)\n\t\tfnvlist_add_string(propval, ZPROP_VALUE, strval);\n\telse\n\t\tfnvlist_add_uint64(propval, ZPROP_VALUE, intval);\n\n\tfnvlist_add_nvlist(nvl, propname, propval);\n\tnvlist_free(propval);\n}\n\nstatic void\nvdev_props_set_sync(void *arg, dmu_tx_t *tx)\n{\n\tvdev_t *vd;\n\tnvlist_t *nvp = arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tnvpair_t *elem = NULL;\n\tuint64_t vdev_guid;\n\tuint64_t objid;\n\tnvlist_t *nvprops;\n\n\tvdev_guid = fnvlist_lookup_uint64(nvp, ZPOOL_VDEV_PROPS_SET_VDEV);\n\tnvprops = fnvlist_lookup_nvlist(nvp, ZPOOL_VDEV_PROPS_SET_PROPS);\n\tvd = spa_lookup_by_guid(spa, vdev_guid, B_TRUE);\n\n\t \n\tif (vd == NULL)\n\t\treturn;\n\n\t \n\tif (vd->vdev_root_zap != 0) {\n\t\tobjid = vd->vdev_root_zap;\n\t} else if (vd->vdev_top_zap != 0) {\n\t\tobjid = vd->vdev_top_zap;\n\t} else if (vd->vdev_leaf_zap != 0) {\n\t\tobjid = vd->vdev_leaf_zap;\n\t} else {\n\t\tpanic(\"unexpected vdev type\");\n\t}\n\n\tmutex_enter(&spa->spa_props_lock);\n\n\twhile ((elem = nvlist_next_nvpair(nvprops, elem)) != NULL) {\n\t\tuint64_t intval;\n\t\tconst char *strval;\n\t\tvdev_prop_t prop;\n\t\tconst char *propname = nvpair_name(elem);\n\t\tzprop_type_t proptype;\n\n\t\tswitch (prop = vdev_name_to_prop(propname)) {\n\t\tcase VDEV_PROP_USERPROP:\n\t\t\tif (vdev_prop_user(propname)) {\n\t\t\t\tstrval = fnvpair_value_string(elem);\n\t\t\t\tif (strlen(strval) == 0) {\n\t\t\t\t\t \n\t\t\t\t\t(void) zap_remove(mos, objid, propname,\n\t\t\t\t\t    tx);\n\t\t\t\t} else {\n\t\t\t\t\tVERIFY0(zap_update(mos, objid, propname,\n\t\t\t\t\t    1, strlen(strval) + 1, strval, tx));\n\t\t\t\t}\n\t\t\t\tspa_history_log_internal(spa, \"vdev set\", tx,\n\t\t\t\t    \"vdev_guid=%llu: %s=%s\",\n\t\t\t\t    (u_longlong_t)vdev_guid, nvpair_name(elem),\n\t\t\t\t    strval);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tpropname = vdev_prop_to_name(prop);\n\t\t\tproptype = vdev_prop_get_type(prop);\n\n\t\t\tif (nvpair_type(elem) == DATA_TYPE_STRING) {\n\t\t\t\tASSERT(proptype == PROP_TYPE_STRING);\n\t\t\t\tstrval = fnvpair_value_string(elem);\n\t\t\t\tVERIFY0(zap_update(mos, objid, propname,\n\t\t\t\t    1, strlen(strval) + 1, strval, tx));\n\t\t\t\tspa_history_log_internal(spa, \"vdev set\", tx,\n\t\t\t\t    \"vdev_guid=%llu: %s=%s\",\n\t\t\t\t    (u_longlong_t)vdev_guid, nvpair_name(elem),\n\t\t\t\t    strval);\n\t\t\t} else if (nvpair_type(elem) == DATA_TYPE_UINT64) {\n\t\t\t\tintval = fnvpair_value_uint64(elem);\n\n\t\t\t\tif (proptype == PROP_TYPE_INDEX) {\n\t\t\t\t\tconst char *unused;\n\t\t\t\t\tVERIFY0(vdev_prop_index_to_string(\n\t\t\t\t\t    prop, intval, &unused));\n\t\t\t\t}\n\t\t\t\tVERIFY0(zap_update(mos, objid, propname,\n\t\t\t\t    sizeof (uint64_t), 1, &intval, tx));\n\t\t\t\tspa_history_log_internal(spa, \"vdev set\", tx,\n\t\t\t\t    \"vdev_guid=%llu: %s=%lld\",\n\t\t\t\t    (u_longlong_t)vdev_guid,\n\t\t\t\t    nvpair_name(elem), (longlong_t)intval);\n\t\t\t} else {\n\t\t\t\tpanic(\"invalid vdev property type %u\",\n\t\t\t\t    nvpair_type(elem));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tmutex_exit(&spa->spa_props_lock);\n}\n\nint\nvdev_prop_set(vdev_t *vd, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tnvpair_t *elem = NULL;\n\tuint64_t vdev_guid;\n\tnvlist_t *nvprops;\n\tint error = 0;\n\n\tASSERT(vd != NULL);\n\n\t \n\tif (vd->vdev_root_zap == 0 &&\n\t    vd->vdev_top_zap == 0 &&\n\t    vd->vdev_leaf_zap == 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (nvlist_lookup_uint64(innvl, ZPOOL_VDEV_PROPS_SET_VDEV,\n\t    &vdev_guid) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (nvlist_lookup_nvlist(innvl, ZPOOL_VDEV_PROPS_SET_PROPS,\n\t    &nvprops) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((vd = spa_lookup_by_guid(spa, vdev_guid, B_TRUE)) == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\twhile ((elem = nvlist_next_nvpair(nvprops, elem)) != NULL) {\n\t\tconst char *propname = nvpair_name(elem);\n\t\tvdev_prop_t prop = vdev_name_to_prop(propname);\n\t\tuint64_t intval = 0;\n\t\tconst char *strval = NULL;\n\n\t\tif (prop == VDEV_PROP_USERPROP && !vdev_prop_user(propname)) {\n\t\t\terror = EINVAL;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (vdev_prop_readonly(prop)) {\n\t\t\terror = EROFS;\n\t\t\tgoto end;\n\t\t}\n\n\t\t \n\t\tswitch (prop) {\n\t\tcase VDEV_PROP_PATH:\n\t\t\tif (vd->vdev_path == NULL) {\n\t\t\t\terror = EROFS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nvpair_value_string(elem, &strval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (strncmp(strval, \"/dev/\", 5)) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terror = spa_vdev_setpath(spa, vdev_guid, strval);\n\t\t\tbreak;\n\t\tcase VDEV_PROP_ALLOCATING:\n\t\t\tif (nvpair_value_uint64(elem, &intval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (intval != vd->vdev_noalloc)\n\t\t\t\tbreak;\n\t\t\tif (intval == 0)\n\t\t\t\terror = spa_vdev_noalloc(spa, vdev_guid);\n\t\t\telse\n\t\t\t\terror = spa_vdev_alloc(spa, vdev_guid);\n\t\t\tbreak;\n\t\tcase VDEV_PROP_FAILFAST:\n\t\t\tif (nvpair_value_uint64(elem, &intval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvd->vdev_failfast = intval & 1;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_CHECKSUM_N:\n\t\t\tif (nvpair_value_uint64(elem, &intval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvd->vdev_checksum_n = intval;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_CHECKSUM_T:\n\t\t\tif (nvpair_value_uint64(elem, &intval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvd->vdev_checksum_t = intval;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_IO_N:\n\t\t\tif (nvpair_value_uint64(elem, &intval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvd->vdev_io_n = intval;\n\t\t\tbreak;\n\t\tcase VDEV_PROP_IO_T:\n\t\t\tif (nvpair_value_uint64(elem, &intval) != 0) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvd->vdev_io_t = intval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\nend:\n\t\tif (error != 0) {\n\t\t\tintval = error;\n\t\t\tvdev_prop_add_list(outnvl, propname, strval, intval, 0);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\treturn (dsl_sync_task(spa->spa_name, NULL, vdev_props_set_sync,\n\t    innvl, 6, ZFS_SPACE_CHECK_EXTRA_RESERVED));\n}\n\nint\nvdev_prop_get(vdev_t *vd, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tspa_t *spa = vd->vdev_spa;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tint err = 0;\n\tuint64_t objid;\n\tuint64_t vdev_guid;\n\tnvpair_t *elem = NULL;\n\tnvlist_t *nvprops = NULL;\n\tuint64_t intval = 0;\n\tchar *strval = NULL;\n\tconst char *propname = NULL;\n\tvdev_prop_t prop;\n\n\tASSERT(vd != NULL);\n\tASSERT(mos != NULL);\n\n\tif (nvlist_lookup_uint64(innvl, ZPOOL_VDEV_PROPS_GET_VDEV,\n\t    &vdev_guid) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tnvlist_lookup_nvlist(innvl, ZPOOL_VDEV_PROPS_GET_PROPS, &nvprops);\n\n\tif (vd->vdev_root_zap != 0) {\n\t\tobjid = vd->vdev_root_zap;\n\t} else if (vd->vdev_top_zap != 0) {\n\t\tobjid = vd->vdev_top_zap;\n\t} else if (vd->vdev_leaf_zap != 0) {\n\t\tobjid = vd->vdev_leaf_zap;\n\t} else {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tASSERT(objid != 0);\n\n\tmutex_enter(&spa->spa_props_lock);\n\n\tif (nvprops != NULL) {\n\t\tchar namebuf[64] = { 0 };\n\n\t\twhile ((elem = nvlist_next_nvpair(nvprops, elem)) != NULL) {\n\t\t\tintval = 0;\n\t\t\tstrval = NULL;\n\t\t\tpropname = nvpair_name(elem);\n\t\t\tprop = vdev_name_to_prop(propname);\n\t\t\tzprop_source_t src = ZPROP_SRC_DEFAULT;\n\t\t\tuint64_t integer_size, num_integers;\n\n\t\t\tswitch (prop) {\n\t\t\t \n\t\t\tcase VDEV_PROP_NAME:\n\t\t\t\tstrval = vdev_name(vd, namebuf,\n\t\t\t\t    sizeof (namebuf));\n\t\t\t\tif (strval == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tvdev_prop_add_list(outnvl, propname, strval, 0,\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_CAPACITY:\n\t\t\t\t \n\t\t\t\tintval = (vd->vdev_stat.vs_dspace == 0) ? 0 :\n\t\t\t\t    (vd->vdev_stat.vs_alloc * 100 /\n\t\t\t\t    vd->vdev_stat.vs_dspace);\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    intval, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_STATE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_state, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_GUID:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_guid, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_ASIZE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_asize, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_PSIZE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_psize, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_ASHIFT:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_ashift, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_SIZE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_dspace, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_FREE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_dspace -\n\t\t\t\t    vd->vdev_stat.vs_alloc, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_ALLOCATED:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_alloc, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_EXPANDSZ:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_esize, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_FRAGMENTATION:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_fragmentation,\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_PARITY:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vdev_get_nparity(vd), ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_PATH:\n\t\t\t\tif (vd->vdev_path == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t    vd->vdev_path, 0, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_DEVID:\n\t\t\t\tif (vd->vdev_devid == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t    vd->vdev_devid, 0, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_PHYS_PATH:\n\t\t\t\tif (vd->vdev_physpath == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t    vd->vdev_physpath, 0, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_ENC_PATH:\n\t\t\t\tif (vd->vdev_enc_sysfs_path == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t    vd->vdev_enc_sysfs_path, 0, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_FRU:\n\t\t\t\tif (vd->vdev_fru == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t    vd->vdev_fru, 0, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_PARENT:\n\t\t\t\tif (vd->vdev_parent != NULL) {\n\t\t\t\t\tstrval = vdev_name(vd->vdev_parent,\n\t\t\t\t\t    namebuf, sizeof (namebuf));\n\t\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t\t    strval, 0, ZPROP_SRC_NONE);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_CHILDREN:\n\t\t\t\tif (vd->vdev_children > 0)\n\t\t\t\t\tstrval = kmem_zalloc(ZAP_MAXVALUELEN,\n\t\t\t\t\t    KM_SLEEP);\n\t\t\t\tfor (uint64_t i = 0; i < vd->vdev_children;\n\t\t\t\t    i++) {\n\t\t\t\t\tconst char *vname;\n\n\t\t\t\t\tvname = vdev_name(vd->vdev_child[i],\n\t\t\t\t\t    namebuf, sizeof (namebuf));\n\t\t\t\t\tif (vname == NULL)\n\t\t\t\t\t\tvname = \"(unknown)\";\n\t\t\t\t\tif (strlen(strval) > 0)\n\t\t\t\t\t\tstrlcat(strval, \",\",\n\t\t\t\t\t\t    ZAP_MAXVALUELEN);\n\t\t\t\t\tstrlcat(strval, vname, ZAP_MAXVALUELEN);\n\t\t\t\t}\n\t\t\t\tif (strval != NULL) {\n\t\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t\t    strval, 0, ZPROP_SRC_NONE);\n\t\t\t\t\tkmem_free(strval, ZAP_MAXVALUELEN);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_NUMCHILDREN:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_children, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_READ_ERRORS:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_read_errors,\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_WRITE_ERRORS:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_write_errors,\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_CHECKSUM_ERRORS:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_checksum_errors,\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_INITIALIZE_ERRORS:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_initialize_errors,\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_OPS_NULL:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_ops[ZIO_TYPE_NULL],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_OPS_READ:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_ops[ZIO_TYPE_READ],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_OPS_WRITE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_ops[ZIO_TYPE_WRITE],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_OPS_FREE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_ops[ZIO_TYPE_FREE],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_OPS_CLAIM:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_ops[ZIO_TYPE_CLAIM],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_OPS_TRIM:\n\t\t\t\t \n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_ops[ZIO_TYPE_IOCTL],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_BYTES_NULL:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_bytes[ZIO_TYPE_NULL],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_BYTES_READ:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_bytes[ZIO_TYPE_READ],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_BYTES_WRITE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_bytes[ZIO_TYPE_WRITE],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_BYTES_FREE:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_bytes[ZIO_TYPE_FREE],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_BYTES_CLAIM:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_bytes[ZIO_TYPE_CLAIM],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_BYTES_TRIM:\n\t\t\t\t \n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_stat.vs_bytes[ZIO_TYPE_IOCTL],\n\t\t\t\t    ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\tcase VDEV_PROP_REMOVING:\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    vd->vdev_removing, ZPROP_SRC_NONE);\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tcase VDEV_PROP_ALLOCATING:\n\t\t\t\t \n\t\t\t\tif (vd->vdev_mg == NULL &&\n\t\t\t\t    vd->vdev_top != NULL) {\n\t\t\t\t\tsrc = ZPROP_SRC_NONE;\n\t\t\t\t\tintval = ZPROP_BOOLEAN_NA;\n\t\t\t\t} else {\n\t\t\t\t\terr = vdev_prop_get_int(vd, prop,\n\t\t\t\t\t    &intval);\n\t\t\t\t\tif (err && err != ENOENT)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (intval ==\n\t\t\t\t\t    vdev_prop_default_numeric(prop))\n\t\t\t\t\t\tsrc = ZPROP_SRC_DEFAULT;\n\t\t\t\t\telse\n\t\t\t\t\t\tsrc = ZPROP_SRC_LOCAL;\n\t\t\t\t}\n\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    intval, src);\n\t\t\t\tbreak;\n\t\t\tcase VDEV_PROP_FAILFAST:\n\t\t\t\tsrc = ZPROP_SRC_LOCAL;\n\t\t\t\tstrval = NULL;\n\n\t\t\t\terr = zap_lookup(mos, objid, nvpair_name(elem),\n\t\t\t\t    sizeof (uint64_t), 1, &intval);\n\t\t\t\tif (err == ENOENT) {\n\t\t\t\t\tintval = vdev_prop_default_numeric(\n\t\t\t\t\t    prop);\n\t\t\t\t\terr = 0;\n\t\t\t\t} else if (err) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (intval == vdev_prop_default_numeric(prop))\n\t\t\t\t\tsrc = ZPROP_SRC_DEFAULT;\n\n\t\t\t\tvdev_prop_add_list(outnvl, propname, strval,\n\t\t\t\t    intval, src);\n\t\t\t\tbreak;\n\t\t\tcase VDEV_PROP_CHECKSUM_N:\n\t\t\tcase VDEV_PROP_CHECKSUM_T:\n\t\t\tcase VDEV_PROP_IO_N:\n\t\t\tcase VDEV_PROP_IO_T:\n\t\t\t\terr = vdev_prop_get_int(vd, prop, &intval);\n\t\t\t\tif (err && err != ENOENT)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (intval == vdev_prop_default_numeric(prop))\n\t\t\t\t\tsrc = ZPROP_SRC_DEFAULT;\n\t\t\t\telse\n\t\t\t\t\tsrc = ZPROP_SRC_LOCAL;\n\n\t\t\t\tvdev_prop_add_list(outnvl, propname, NULL,\n\t\t\t\t    intval, src);\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase VDEV_PROP_COMMENT:\n\t\t\t\t \n\t\t\t\t \n\t\t\tcase VDEV_PROP_USERPROP:\n\t\t\t\t \n\t\t\t\tsrc = ZPROP_SRC_LOCAL;\n\n\t\t\t\terr = zap_length(mos, objid, nvpair_name(elem),\n\t\t\t\t    &integer_size, &num_integers);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\n\t\t\t\tswitch (integer_size) {\n\t\t\t\tcase 8:\n\t\t\t\t\t \n\t\t\t\t\terr = EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t \n\t\t\t\t\tstrval = kmem_alloc(num_integers,\n\t\t\t\t\t    KM_SLEEP);\n\t\t\t\t\terr = zap_lookup(mos, objid,\n\t\t\t\t\t    nvpair_name(elem), 1,\n\t\t\t\t\t    num_integers, strval);\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tkmem_free(strval,\n\t\t\t\t\t\t    num_integers);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvdev_prop_add_list(outnvl, propname,\n\t\t\t\t\t    strval, 0, src);\n\t\t\t\t\tkmem_free(strval, num_integers);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tzap_cursor_t zc;\n\t\tzap_attribute_t za;\n\t\tfor (zap_cursor_init(&zc, mos, objid);\n\t\t    (err = zap_cursor_retrieve(&zc, &za)) == 0;\n\t\t    zap_cursor_advance(&zc)) {\n\t\t\tintval = 0;\n\t\t\tstrval = NULL;\n\t\t\tzprop_source_t src = ZPROP_SRC_DEFAULT;\n\t\t\tpropname = za.za_name;\n\n\t\t\tswitch (za.za_integer_length) {\n\t\t\tcase 8:\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tstrval = kmem_alloc(za.za_num_integers,\n\t\t\t\t    KM_SLEEP);\n\t\t\t\terr = zap_lookup(mos, objid, za.za_name, 1,\n\t\t\t\t    za.za_num_integers, strval);\n\t\t\t\tif (err) {\n\t\t\t\t\tkmem_free(strval, za.za_num_integers);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvdev_prop_add_list(outnvl, propname, strval, 0,\n\t\t\t\t    src);\n\t\t\t\tkmem_free(strval, za.za_num_integers);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\t}\n\n\tmutex_exit(&spa->spa_props_lock);\n\tif (err && err != ENOENT) {\n\t\treturn (err);\n\t}\n\n\treturn (0);\n}\n\nEXPORT_SYMBOL(vdev_fault);\nEXPORT_SYMBOL(vdev_degrade);\nEXPORT_SYMBOL(vdev_online);\nEXPORT_SYMBOL(vdev_offline);\nEXPORT_SYMBOL(vdev_clear);\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_vdev_, default_ms_count, UINT, ZMOD_RW,\n\t\"Target number of metaslabs per top-level vdev\");\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_vdev_, default_ms_shift, UINT, ZMOD_RW,\n\t\"Default lower limit for metaslab size\");\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_vdev_, max_ms_shift, UINT, ZMOD_RW,\n\t\"Default upper limit for metaslab size\");\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_vdev_, min_ms_count, UINT, ZMOD_RW,\n\t\"Minimum number of metaslabs per top-level vdev\");\n\nZFS_MODULE_PARAM(zfs_vdev, zfs_vdev_, ms_count_limit, UINT, ZMOD_RW,\n\t\"Practical upper limit of total metaslabs per top-level vdev\");\n\nZFS_MODULE_PARAM(zfs, zfs_, slow_io_events_per_second, UINT, ZMOD_RW,\n\t\"Rate limit slow IO (delay) events to this many per second\");\n\n \nZFS_MODULE_PARAM(zfs, zfs_, checksum_events_per_second, UINT, ZMOD_RW,\n\t\"Rate limit checksum events to this many checksum errors per second \"\n\t\"(do not set below ZED threshold).\");\n \n\nZFS_MODULE_PARAM(zfs, zfs_, scan_ignore_errors, INT, ZMOD_RW,\n\t\"Ignore errors during resilver/scrub\");\n\nZFS_MODULE_PARAM(zfs_vdev, vdev_, validate_skip, INT, ZMOD_RW,\n\t\"Bypass vdev_validate()\");\n\nZFS_MODULE_PARAM(zfs, zfs_, nocacheflush, INT, ZMOD_RW,\n\t\"Disable cache flushes\");\n\nZFS_MODULE_PARAM(zfs, zfs_, embedded_slog_min_ms, UINT, ZMOD_RW,\n\t\"Minimum number of metaslabs required to dedicate one for log blocks\");\n\n \nZFS_MODULE_PARAM_CALL(zfs_vdev, zfs_vdev_, min_auto_ashift,\n\tparam_set_min_auto_ashift, param_get_uint, ZMOD_RW,\n\t\"Minimum ashift used when creating new top-level vdevs\");\n\nZFS_MODULE_PARAM_CALL(zfs_vdev, zfs_vdev_, max_auto_ashift,\n\tparam_set_max_auto_ashift, param_get_uint, ZMOD_RW,\n\t\"Maximum ashift used when optimizing for logical -> physical sector \"\n\t\"size on new top-level vdevs\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}