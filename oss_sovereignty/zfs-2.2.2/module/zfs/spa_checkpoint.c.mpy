{
  "module_name": "spa_checkpoint.c",
  "hash_id": "8e5753992c4ff135501f90ff1ccb6bbd29e20b975148592cf97aa971bfc176e3",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/spa_checkpoint.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/dmu_tx.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_synctask.h>\n#include <sys/metaslab_impl.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/spa_checkpoint.h>\n#include <sys/vdev_impl.h>\n#include <sys/zap.h>\n#include <sys/zfeature.h>\n\n \nstatic uint64_t zfs_spa_discard_memory_limit = 16 * 1024 * 1024;\n\nint\nspa_checkpoint_get_stats(spa_t *spa, pool_checkpoint_stat_t *pcs)\n{\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))\n\t\treturn (SET_ERROR(ZFS_ERR_NO_CHECKPOINT));\n\n\tmemset(pcs, 0, sizeof (pool_checkpoint_stat_t));\n\n\tint error = zap_contains(spa_meta_objset(spa),\n\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_ZPOOL_CHECKPOINT);\n\tASSERT(error == 0 || error == ENOENT);\n\n\tif (error == ENOENT)\n\t\tpcs->pcs_state = CS_CHECKPOINT_DISCARDING;\n\telse\n\t\tpcs->pcs_state = CS_CHECKPOINT_EXISTS;\n\n\tpcs->pcs_space = spa->spa_checkpoint_info.sci_dspace;\n\tpcs->pcs_start_time = spa->spa_checkpoint_info.sci_timestamp;\n\n\treturn (0);\n}\n\nstatic void\nspa_checkpoint_discard_complete_sync(void *arg, dmu_tx_t *tx)\n{\n\tspa_t *spa = arg;\n\n\tspa->spa_checkpoint_info.sci_timestamp = 0;\n\n\tspa_feature_decr(spa, SPA_FEATURE_POOL_CHECKPOINT, tx);\n\tspa_notify_waiters(spa);\n\n\tspa_history_log_internal(spa, \"spa discard checkpoint\", tx,\n\t    \"finished discarding checkpointed state from the pool\");\n}\n\ntypedef struct spa_checkpoint_discard_sync_callback_arg {\n\tvdev_t *sdc_vd;\n\tuint64_t sdc_txg;\n\tuint64_t sdc_entry_limit;\n} spa_checkpoint_discard_sync_callback_arg_t;\n\nstatic int\nspa_checkpoint_discard_sync_callback(space_map_entry_t *sme, void *arg)\n{\n\tspa_checkpoint_discard_sync_callback_arg_t *sdc = arg;\n\tvdev_t *vd = sdc->sdc_vd;\n\tmetaslab_t *ms = vd->vdev_ms[sme->sme_offset >> vd->vdev_ms_shift];\n\tuint64_t end = sme->sme_offset + sme->sme_run;\n\n\tif (sdc->sdc_entry_limit == 0)\n\t\treturn (SET_ERROR(EINTR));\n\n\t \n\tVERIFY3U(sme->sme_type, ==, SM_FREE);\n\tVERIFY3U(sme->sme_offset, >=, ms->ms_start);\n\tVERIFY3U(end, <=, ms->ms_start + ms->ms_size);\n\n\t \n\tmutex_enter(&ms->ms_lock);\n\tif (range_tree_is_empty(ms->ms_freeing))\n\t\tvdev_dirty(vd, VDD_METASLAB, ms, sdc->sdc_txg);\n\trange_tree_add(ms->ms_freeing, sme->sme_offset, sme->sme_run);\n\tmutex_exit(&ms->ms_lock);\n\n\tASSERT3U(vd->vdev_spa->spa_checkpoint_info.sci_dspace, >=,\n\t    sme->sme_run);\n\tASSERT3U(vd->vdev_stat.vs_checkpoint_space, >=, sme->sme_run);\n\n\tvd->vdev_spa->spa_checkpoint_info.sci_dspace -= sme->sme_run;\n\tvd->vdev_stat.vs_checkpoint_space -= sme->sme_run;\n\tsdc->sdc_entry_limit--;\n\n\treturn (0);\n}\n\n#ifdef ZFS_DEBUG\nstatic void\nspa_checkpoint_accounting_verify(spa_t *spa)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tuint64_t ckpoint_sm_space_sum = 0;\n\tuint64_t vs_ckpoint_space_sum = 0;\n\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *vd = rvd->vdev_child[c];\n\n\t\tif (vd->vdev_checkpoint_sm != NULL) {\n\t\t\tckpoint_sm_space_sum +=\n\t\t\t    -space_map_allocated(vd->vdev_checkpoint_sm);\n\t\t\tvs_ckpoint_space_sum +=\n\t\t\t    vd->vdev_stat.vs_checkpoint_space;\n\t\t\tASSERT3U(ckpoint_sm_space_sum, ==,\n\t\t\t    vs_ckpoint_space_sum);\n\t\t} else {\n\t\t\tASSERT0(vd->vdev_stat.vs_checkpoint_space);\n\t\t}\n\t}\n\tASSERT3U(spa->spa_checkpoint_info.sci_dspace, ==, ckpoint_sm_space_sum);\n}\n#endif\n\nstatic void\nspa_checkpoint_discard_thread_sync(void *arg, dmu_tx_t *tx)\n{\n\tvdev_t *vd = arg;\n\tint error;\n\n\t \n\tuint64_t max_entry_limit =\n\t    (zfs_spa_discard_memory_limit / (2 * sizeof (uint64_t))) >> 1;\n\n\t \n\tspa_checkpoint_discard_sync_callback_arg_t sdc;\n\tsdc.sdc_vd = vd;\n\tsdc.sdc_txg = tx->tx_txg;\n\tsdc.sdc_entry_limit = max_entry_limit;\n\n\tuint64_t words_before =\n\t    space_map_length(vd->vdev_checkpoint_sm) / sizeof (uint64_t);\n\n\terror = space_map_incremental_destroy(vd->vdev_checkpoint_sm,\n\t    spa_checkpoint_discard_sync_callback, &sdc, tx);\n\n\tuint64_t words_after =\n\t    space_map_length(vd->vdev_checkpoint_sm) / sizeof (uint64_t);\n\n#ifdef ZFS_DEBUG\n\tspa_checkpoint_accounting_verify(vd->vdev_spa);\n#endif\n\n\tzfs_dbgmsg(\"discarding checkpoint: txg %llu, vdev id %lld, \"\n\t    \"deleted %llu words - %llu words are left\",\n\t    (u_longlong_t)tx->tx_txg, (longlong_t)vd->vdev_id,\n\t    (u_longlong_t)(words_before - words_after),\n\t    (u_longlong_t)words_after);\n\n\tif (error != EINTR) {\n\t\tif (error != 0) {\n\t\t\tzfs_panic_recover(\"zfs: error %lld was returned \"\n\t\t\t    \"while incrementally destroying the checkpoint \"\n\t\t\t    \"space map of vdev %llu\\n\",\n\t\t\t    (longlong_t)error, vd->vdev_id);\n\t\t}\n\t\tASSERT0(words_after);\n\t\tASSERT0(space_map_allocated(vd->vdev_checkpoint_sm));\n\t\tASSERT0(space_map_length(vd->vdev_checkpoint_sm));\n\n\t\tspace_map_free(vd->vdev_checkpoint_sm, tx);\n\t\tspace_map_close(vd->vdev_checkpoint_sm);\n\t\tvd->vdev_checkpoint_sm = NULL;\n\n\t\tVERIFY0(zap_remove(spa_meta_objset(vd->vdev_spa),\n\t\t    vd->vdev_top_zap, VDEV_TOP_ZAP_POOL_CHECKPOINT_SM, tx));\n\t}\n}\n\nstatic boolean_t\nspa_checkpoint_discard_is_done(spa_t *spa)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tASSERT(!spa_has_checkpoint(spa));\n\tASSERT(spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT));\n\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tif (rvd->vdev_child[c]->vdev_checkpoint_sm != NULL)\n\t\t\treturn (B_FALSE);\n\t\tASSERT0(rvd->vdev_child[c]->vdev_stat.vs_checkpoint_space);\n\t}\n\n\treturn (B_TRUE);\n}\n\nboolean_t\nspa_checkpoint_discard_thread_check(void *arg, zthr_t *zthr)\n{\n\t(void) zthr;\n\tspa_t *spa = arg;\n\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))\n\t\treturn (B_FALSE);\n\n\tif (spa_has_checkpoint(spa))\n\t\treturn (B_FALSE);\n\n\treturn (B_TRUE);\n}\n\nvoid\nspa_checkpoint_discard_thread(void *arg, zthr_t *zthr)\n{\n\tspa_t *spa = arg;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\n\tfor (uint64_t c = 0; c < rvd->vdev_children; c++) {\n\t\tvdev_t *vd = rvd->vdev_child[c];\n\n\t\twhile (vd->vdev_checkpoint_sm != NULL) {\n\t\t\tspace_map_t *checkpoint_sm = vd->vdev_checkpoint_sm;\n\t\t\tint numbufs;\n\t\t\tdmu_buf_t **dbp;\n\n\t\t\tif (zthr_iscancelled(zthr))\n\t\t\t\treturn;\n\n\t\t\tASSERT3P(vd->vdev_ops, !=, &vdev_indirect_ops);\n\n\t\t\tuint64_t size = MIN(space_map_length(checkpoint_sm),\n\t\t\t    zfs_spa_discard_memory_limit);\n\t\t\tuint64_t offset =\n\t\t\t    space_map_length(checkpoint_sm) - size;\n\n\t\t\t \n\t\t\tint error = dmu_buf_hold_array_by_bonus(\n\t\t\t    checkpoint_sm->sm_dbuf, offset, size,\n\t\t\t    B_TRUE, FTAG, &numbufs, &dbp);\n\t\t\tif (error != 0) {\n\t\t\t\tzfs_panic_recover(\"zfs: error %d was returned \"\n\t\t\t\t    \"while prefetching checkpoint space map \"\n\t\t\t\t    \"entries of vdev %llu\\n\",\n\t\t\t\t    error, vd->vdev_id);\n\t\t\t}\n\n\t\t\tVERIFY0(dsl_sync_task(spa->spa_name, NULL,\n\t\t\t    spa_checkpoint_discard_thread_sync, vd,\n\t\t\t    0, ZFS_SPACE_CHECK_NONE));\n\n\t\t\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\t\t}\n\t}\n\n\tVERIFY(spa_checkpoint_discard_is_done(spa));\n\tVERIFY0(spa->spa_checkpoint_info.sci_dspace);\n\tVERIFY0(dsl_sync_task(spa->spa_name, NULL,\n\t    spa_checkpoint_discard_complete_sync, spa,\n\t    0, ZFS_SPACE_CHECK_NONE));\n}\n\n\nstatic int\nspa_checkpoint_check(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\n\tif (!spa_feature_is_enabled(spa, SPA_FEATURE_POOL_CHECKPOINT))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (!spa_top_vdevs_spacemap_addressable(spa))\n\t\treturn (SET_ERROR(ZFS_ERR_VDEV_TOO_BIG));\n\n\tif (spa->spa_removing_phys.sr_state == DSS_SCANNING)\n\t\treturn (SET_ERROR(ZFS_ERR_DEVRM_IN_PROGRESS));\n\n\tif (spa->spa_checkpoint_txg != 0)\n\t\treturn (SET_ERROR(ZFS_ERR_CHECKPOINT_EXISTS));\n\n\tif (spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))\n\t\treturn (SET_ERROR(ZFS_ERR_DISCARDING_CHECKPOINT));\n\n\treturn (0);\n}\n\nstatic void\nspa_checkpoint_sync(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tspa_t *spa = dp->dp_spa;\n\tuberblock_t checkpoint = spa->spa_ubsync;\n\n\t \n\tASSERT3U(zap_contains(spa_meta_objset(spa), DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_ZPOOL_CHECKPOINT), ==, ENOENT);\n\n\tASSERT0(spa->spa_checkpoint_info.sci_timestamp);\n\tASSERT0(spa->spa_checkpoint_info.sci_dspace);\n\n\t \n\tASSERT3U(checkpoint.ub_txg, ==, spa->spa_syncing_txg - 1);\n\n\t \n\tspa->spa_checkpoint_txg = checkpoint.ub_txg;\n\tspa->spa_checkpoint_info.sci_timestamp = checkpoint.ub_timestamp;\n\n\tcheckpoint.ub_checkpoint_txg = checkpoint.ub_txg;\n\tVERIFY0(zap_add(spa->spa_dsl_pool->dp_meta_objset,\n\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_ZPOOL_CHECKPOINT,\n\t    sizeof (uint64_t), sizeof (uberblock_t) / sizeof (uint64_t),\n\t    &checkpoint, tx));\n\n\t \n\tspa_feature_incr(spa, SPA_FEATURE_POOL_CHECKPOINT, tx);\n\n\tspa_history_log_internal(spa, \"spa checkpoint\", tx,\n\t    \"checkpointed uberblock txg=%llu\", (u_longlong_t)checkpoint.ub_txg);\n}\n\n \nint\nspa_checkpoint(const char *pool)\n{\n\tint error;\n\tspa_t *spa;\n\n\terror = spa_open(pool, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\tmutex_enter(&spa->spa_vdev_top_lock);\n\n\t \n\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\t \n\terror = dsl_early_sync_task(pool, spa_checkpoint_check,\n\t    spa_checkpoint_sync, NULL, 0, ZFS_SPACE_CHECK_NORMAL);\n\n\tmutex_exit(&spa->spa_vdev_top_lock);\n\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\nstatic int\nspa_checkpoint_discard_check(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\n\tif (!spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))\n\t\treturn (SET_ERROR(ZFS_ERR_NO_CHECKPOINT));\n\n\tif (spa->spa_checkpoint_txg == 0)\n\t\treturn (SET_ERROR(ZFS_ERR_DISCARDING_CHECKPOINT));\n\n\tVERIFY0(zap_contains(spa_meta_objset(spa),\n\t    DMU_POOL_DIRECTORY_OBJECT, DMU_POOL_ZPOOL_CHECKPOINT));\n\n\treturn (0);\n}\n\nstatic void\nspa_checkpoint_discard_sync(void *arg, dmu_tx_t *tx)\n{\n\t(void) arg;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\n\tVERIFY0(zap_remove(spa_meta_objset(spa), DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_ZPOOL_CHECKPOINT, tx));\n\n\tspa->spa_checkpoint_txg = 0;\n\n\tzthr_wakeup(spa->spa_checkpoint_discard_zthr);\n\n\tspa_history_log_internal(spa, \"spa discard checkpoint\", tx,\n\t    \"started discarding checkpointed state from the pool\");\n}\n\n \nint\nspa_checkpoint_discard(const char *pool)\n{\n\t \n\treturn (dsl_early_sync_task(pool, spa_checkpoint_discard_check,\n\t    spa_checkpoint_discard_sync, NULL, 0,\n\t    ZFS_SPACE_CHECK_DISCARD_CHECKPOINT));\n}\n\nEXPORT_SYMBOL(spa_checkpoint_get_stats);\nEXPORT_SYMBOL(spa_checkpoint_discard_thread);\nEXPORT_SYMBOL(spa_checkpoint_discard_thread_check);\n\n \nZFS_MODULE_PARAM(zfs_spa, zfs_spa_, discard_memory_limit, U64, ZMOD_RW,\n\t\"Limit for memory used in prefetching the checkpoint space map done \"\n\t\"on each vdev while discarding the checkpoint\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}