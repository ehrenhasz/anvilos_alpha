{
  "module_name": "dsl_prop.c",
  "hash_id": "ead76463f1d388513ec19b6350d4dd336dd39ab566a1cf3964aaa4efe75d06ce",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_prop.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/spa.h>\n#include <sys/zap.h>\n#include <sys/fs/zfs.h>\n\n#include \"zfs_prop.h\"\n\n#define\tZPROP_INHERIT_SUFFIX \"$inherit\"\n#define\tZPROP_RECVD_SUFFIX \"$recvd\"\n#define\tZPROP_IUV_SUFFIX \"$iuv\"\n\nstatic int\ndodefault(zfs_prop_t prop, int intsz, int numints, void *buf)\n{\n\t \n\tif (prop == ZPROP_INVAL ||\n\t    (zfs_prop_readonly(prop) && !zfs_prop_setonce(prop)))\n\t\treturn (SET_ERROR(ENOENT));\n\n\tif (zfs_prop_get_type(prop) == PROP_TYPE_STRING) {\n\t\tif (intsz != 1)\n\t\t\treturn (SET_ERROR(EOVERFLOW));\n\t\t(void) strlcpy(buf, zfs_prop_default_string(prop),\n\t\t    numints);\n\t} else {\n\t\tif (intsz != 8 || numints < 1)\n\t\t\treturn (SET_ERROR(EOVERFLOW));\n\n\t\t*(uint64_t *)buf = zfs_prop_default_numeric(prop);\n\t}\n\n\treturn (0);\n}\n\nstatic int\ndsl_prop_known_index(zfs_prop_t prop, uint64_t value)\n{\n\tconst char *str = NULL;\n\tif (prop != ZPROP_CONT && prop != ZPROP_INVAL &&\n\t    zfs_prop_get_type(prop) == PROP_TYPE_INDEX)\n\t\treturn (!zfs_prop_index_to_string(prop, value, &str));\n\n\treturn (-1);\n}\n\nint\ndsl_prop_get_dd(dsl_dir_t *dd, const char *propname,\n    int intsz, int numints, void *buf, char *setpoint, boolean_t snapshot)\n{\n\tint err;\n\tdsl_dir_t *target = dd;\n\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\tzfs_prop_t prop;\n\tboolean_t inheritable;\n\tboolean_t inheriting = B_FALSE;\n\tchar *inheritstr;\n\tchar *recvdstr;\n\tchar *iuvstr;\n\n\tASSERT(dsl_pool_config_held(dd->dd_pool));\n\n\tif (setpoint)\n\t\tsetpoint[0] = '\\0';\n\n\tprop = zfs_name_to_prop(propname);\n\tinheritable = (prop == ZPROP_USERPROP || zfs_prop_inheritable(prop));\n\tinheritstr = kmem_asprintf(\"%s%s\", propname, ZPROP_INHERIT_SUFFIX);\n\trecvdstr = kmem_asprintf(\"%s%s\", propname, ZPROP_RECVD_SUFFIX);\n\tiuvstr = kmem_asprintf(\"%s%s\", propname, ZPROP_IUV_SUFFIX);\n\n\t \n\tfor (; dd != NULL; dd = dd->dd_parent) {\n\t\tif (dd != target || snapshot) {\n\t\t\tif (!inheritable) {\n\t\t\t\terr = SET_ERROR(ENOENT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinheriting = B_TRUE;\n\t\t}\n\n\t\t \n\t\terr = zap_lookup(mos, dsl_dir_phys(dd)->dd_props_zapobj,\n\t\t    iuvstr, intsz, numints, buf);\n\t\tif (err == 0 && dsl_prop_known_index(prop,\n\t\t    *(uint64_t *)buf) != 1)\n\t\t\terr = ENOENT;\n\t\tif (err != ENOENT) {\n\t\t\tif (setpoint != NULL && err == 0)\n\t\t\t\tdsl_dir_name(dd, setpoint);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = zap_lookup(mos, dsl_dir_phys(dd)->dd_props_zapobj,\n\t\t    propname, intsz, numints, buf);\n\t\tif (err != ENOENT) {\n\t\t\tif (setpoint != NULL && err == 0)\n\t\t\t\tdsl_dir_name(dd, setpoint);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = zap_contains(mos, dsl_dir_phys(dd)->dd_props_zapobj,\n\t\t    inheritstr);\n\t\tif (err != 0 && err != ENOENT)\n\t\t\tbreak;\n\n\t\tif (err == ENOENT) {\n\t\t\t \n\t\t\terr = zap_lookup(mos, dsl_dir_phys(dd)->dd_props_zapobj,\n\t\t\t    recvdstr, intsz, numints, buf);\n\t\t\tif (err != ENOENT) {\n\t\t\t\tif (setpoint != NULL && err == 0) {\n\t\t\t\t\tif (inheriting) {\n\t\t\t\t\t\tdsl_dir_name(dd, setpoint);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(void) strlcpy(setpoint,\n\t\t\t\t\t\t    ZPROP_SOURCE_VAL_RECVD,\n\t\t\t\t\t\t    MAXNAMELEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\terr = SET_ERROR(ENOENT);\n\t}\n\n\tif (err == ENOENT)\n\t\terr = dodefault(prop, intsz, numints, buf);\n\n\tkmem_strfree(inheritstr);\n\tkmem_strfree(recvdstr);\n\tkmem_strfree(iuvstr);\n\n\treturn (err);\n}\n\nint\ndsl_prop_get_ds(dsl_dataset_t *ds, const char *propname,\n    int intsz, int numints, void *buf, char *setpoint)\n{\n\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\tboolean_t inheritable;\n\tuint64_t zapobj;\n\n\tASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));\n\tinheritable = (prop == ZPROP_USERPROP || zfs_prop_inheritable(prop));\n\tzapobj = dsl_dataset_phys(ds)->ds_props_obj;\n\n\tif (zapobj != 0) {\n\t\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\t\tint err;\n\n\t\tASSERT(ds->ds_is_snapshot);\n\n\t\t \n\t\terr = zap_lookup(mos, zapobj, propname, intsz, numints, buf);\n\t\tif (err != ENOENT) {\n\t\t\tif (setpoint != NULL && err == 0)\n\t\t\t\tdsl_dataset_name(ds, setpoint);\n\t\t\treturn (err);\n\t\t}\n\n\t\t \n\t\tif (inheritable) {\n\t\t\tchar *inheritstr = kmem_asprintf(\"%s%s\", propname,\n\t\t\t    ZPROP_INHERIT_SUFFIX);\n\t\t\terr = zap_contains(mos, zapobj, inheritstr);\n\t\t\tkmem_strfree(inheritstr);\n\t\t\tif (err != 0 && err != ENOENT)\n\t\t\t\treturn (err);\n\t\t}\n\n\t\tif (err == ENOENT) {\n\t\t\t \n\t\t\tchar *recvdstr = kmem_asprintf(\"%s%s\", propname,\n\t\t\t    ZPROP_RECVD_SUFFIX);\n\t\t\terr = zap_lookup(mos, zapobj, recvdstr,\n\t\t\t    intsz, numints, buf);\n\t\t\tkmem_strfree(recvdstr);\n\t\t\tif (err != ENOENT) {\n\t\t\t\tif (setpoint != NULL && err == 0)\n\t\t\t\t\t(void) strlcpy(setpoint,\n\t\t\t\t\t    ZPROP_SOURCE_VAL_RECVD,\n\t\t\t\t\t    MAXNAMELEN);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (dsl_prop_get_dd(ds->ds_dir, propname,\n\t    intsz, numints, buf, setpoint, ds->ds_is_snapshot));\n}\n\nstatic dsl_prop_record_t *\ndsl_prop_record_find(dsl_dir_t *dd, const char *propname)\n{\n\tdsl_prop_record_t *pr = NULL;\n\n\tASSERT(MUTEX_HELD(&dd->dd_lock));\n\n\tfor (pr = list_head(&dd->dd_props);\n\t    pr != NULL; pr = list_next(&dd->dd_props, pr)) {\n\t\tif (strcmp(pr->pr_propname, propname) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn (pr);\n}\n\nstatic dsl_prop_record_t *\ndsl_prop_record_create(dsl_dir_t *dd, const char *propname)\n{\n\tdsl_prop_record_t *pr;\n\n\tASSERT(MUTEX_HELD(&dd->dd_lock));\n\n\tpr = kmem_alloc(sizeof (dsl_prop_record_t), KM_SLEEP);\n\tpr->pr_propname = spa_strdup(propname);\n\tlist_create(&pr->pr_cbs, sizeof (dsl_prop_cb_record_t),\n\t    offsetof(dsl_prop_cb_record_t, cbr_pr_node));\n\tlist_insert_head(&dd->dd_props, pr);\n\n\treturn (pr);\n}\n\nvoid\ndsl_prop_init(dsl_dir_t *dd)\n{\n\tlist_create(&dd->dd_props, sizeof (dsl_prop_record_t),\n\t    offsetof(dsl_prop_record_t, pr_node));\n}\n\nvoid\ndsl_prop_fini(dsl_dir_t *dd)\n{\n\tdsl_prop_record_t *pr;\n\n\twhile ((pr = list_remove_head(&dd->dd_props)) != NULL) {\n\t\tlist_destroy(&pr->pr_cbs);\n\t\tspa_strfree((char *)pr->pr_propname);\n\t\tkmem_free(pr, sizeof (dsl_prop_record_t));\n\t}\n\tlist_destroy(&dd->dd_props);\n}\n\n \nint\ndsl_prop_register(dsl_dataset_t *ds, const char *propname,\n    dsl_prop_changed_cb_t *callback, void *cbarg)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\tuint64_t value;\n\tdsl_prop_record_t *pr;\n\tdsl_prop_cb_record_t *cbr;\n\tint err;\n\tdsl_pool_t *dp __maybe_unused = dd->dd_pool;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\terr = dsl_prop_get_int_ds(ds, propname, &value);\n\tif (err != 0)\n\t\treturn (err);\n\n\tcbr = kmem_alloc(sizeof (dsl_prop_cb_record_t), KM_SLEEP);\n\tcbr->cbr_ds = ds;\n\tcbr->cbr_func = callback;\n\tcbr->cbr_arg = cbarg;\n\n\tmutex_enter(&dd->dd_lock);\n\tpr = dsl_prop_record_find(dd, propname);\n\tif (pr == NULL)\n\t\tpr = dsl_prop_record_create(dd, propname);\n\tcbr->cbr_pr = pr;\n\tlist_insert_head(&pr->pr_cbs, cbr);\n\tlist_insert_head(&ds->ds_prop_cbs, cbr);\n\tmutex_exit(&dd->dd_lock);\n\n\tcbr->cbr_func(cbr->cbr_arg, value);\n\treturn (0);\n}\n\nint\ndsl_prop_get(const char *dsname, const char *propname,\n    int intsz, int numints, void *buf, char *setpoint)\n{\n\tobjset_t *os;\n\tint error;\n\n\terror = dmu_objset_hold(dsname, FTAG, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_prop_get_ds(dmu_objset_ds(os), propname,\n\t    intsz, numints, buf, setpoint);\n\n\tdmu_objset_rele(os, FTAG);\n\treturn (error);\n}\n\n \nint\ndsl_prop_get_integer(const char *ddname, const char *propname,\n    uint64_t *valuep, char *setpoint)\n{\n\treturn (dsl_prop_get(ddname, propname, 8, 1, valuep, setpoint));\n}\n\nint\ndsl_prop_get_int_ds(dsl_dataset_t *ds, const char *propname,\n    uint64_t *valuep)\n{\n\treturn (dsl_prop_get_ds(ds, propname, 8, 1, valuep, NULL));\n}\n\n \nint\ndsl_prop_predict(dsl_dir_t *dd, const char *propname,\n    zprop_source_t source, uint64_t value, uint64_t *newvalp)\n{\n\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\tobjset_t *mos;\n\tuint64_t zapobj;\n\tuint64_t version;\n\tchar *recvdstr;\n\tint err = 0;\n\n\tswitch (prop) {\n\tcase ZFS_PROP_QUOTA:\n\tcase ZFS_PROP_RESERVATION:\n\tcase ZFS_PROP_REFQUOTA:\n\tcase ZFS_PROP_REFRESERVATION:\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\n\tmos = dd->dd_pool->dp_meta_objset;\n\tzapobj = dsl_dir_phys(dd)->dd_props_zapobj;\n\trecvdstr = kmem_asprintf(\"%s%s\", propname, ZPROP_RECVD_SUFFIX);\n\n\tversion = spa_version(dd->dd_pool->dp_spa);\n\tif (version < SPA_VERSION_RECVD_PROPS) {\n\t\tif (source & ZPROP_SRC_NONE)\n\t\t\tsource = ZPROP_SRC_NONE;\n\t\telse if (source & ZPROP_SRC_RECEIVED)\n\t\t\tsource = ZPROP_SRC_LOCAL;\n\t}\n\n\tswitch ((int)source) {\n\tcase ZPROP_SRC_NONE:\n\t\t \n\t\terr = zap_lookup(mos, zapobj, recvdstr, 8, 1, newvalp);\n\t\tif (err == ENOENT)\n\t\t\t*newvalp = 0;\n\t\tbreak;\n\tcase ZPROP_SRC_LOCAL:\n\t\t*newvalp = value;\n\t\tbreak;\n\tcase ZPROP_SRC_RECEIVED:\n\t\t \n\t\terr = zap_lookup(mos, zapobj, propname, 8, 1, newvalp);\n\t\tif (err == ENOENT)\n\t\t\t*newvalp = value;\n\t\tbreak;\n\tcase (ZPROP_SRC_NONE | ZPROP_SRC_RECEIVED):\n\t\t \n\t\terr = zap_lookup(mos, zapobj, propname, 8, 1, newvalp);\n\t\tif (err == ENOENT)\n\t\t\t*newvalp = 0;\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unexpected property source: %d\", source);\n\t}\n\n\tkmem_strfree(recvdstr);\n\n\tif (err == ENOENT)\n\t\treturn (0);\n\n\treturn (err);\n}\n\n \nint\ndsl_prop_unregister(dsl_dataset_t *ds, const char *propname,\n    dsl_prop_changed_cb_t *callback, void *cbarg)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\tdsl_prop_cb_record_t *cbr;\n\n\tmutex_enter(&dd->dd_lock);\n\tfor (cbr = list_head(&ds->ds_prop_cbs);\n\t    cbr; cbr = list_next(&ds->ds_prop_cbs, cbr)) {\n\t\tif (cbr->cbr_ds == ds &&\n\t\t    cbr->cbr_func == callback &&\n\t\t    cbr->cbr_arg == cbarg &&\n\t\t    strcmp(cbr->cbr_pr->pr_propname, propname) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (cbr == NULL) {\n\t\tmutex_exit(&dd->dd_lock);\n\t\treturn (SET_ERROR(ENOMSG));\n\t}\n\n\tlist_remove(&ds->ds_prop_cbs, cbr);\n\tlist_remove(&cbr->cbr_pr->pr_cbs, cbr);\n\tmutex_exit(&dd->dd_lock);\n\tkmem_free(cbr, sizeof (dsl_prop_cb_record_t));\n\n\treturn (0);\n}\n\n \nvoid\ndsl_prop_unregister_all(dsl_dataset_t *ds, void *cbarg)\n{\n\tdsl_prop_cb_record_t *cbr, *next_cbr;\n\n\tdsl_dir_t *dd = ds->ds_dir;\n\n\tmutex_enter(&dd->dd_lock);\n\tnext_cbr = list_head(&ds->ds_prop_cbs);\n\twhile (next_cbr != NULL) {\n\t\tcbr = next_cbr;\n\t\tnext_cbr = list_next(&ds->ds_prop_cbs, cbr);\n\t\tif (cbr->cbr_arg == cbarg) {\n\t\t\tlist_remove(&ds->ds_prop_cbs, cbr);\n\t\t\tlist_remove(&cbr->cbr_pr->pr_cbs, cbr);\n\t\t\tkmem_free(cbr, sizeof (dsl_prop_cb_record_t));\n\t\t}\n\t}\n\tmutex_exit(&dd->dd_lock);\n}\n\nboolean_t\ndsl_prop_hascb(dsl_dataset_t *ds)\n{\n\treturn (!list_is_empty(&ds->ds_prop_cbs));\n}\n\nstatic int\ndsl_prop_notify_all_cb(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)\n{\n\t(void) arg;\n\tdsl_dir_t *dd = ds->ds_dir;\n\tdsl_prop_record_t *pr;\n\tdsl_prop_cb_record_t *cbr;\n\n\tmutex_enter(&dd->dd_lock);\n\tfor (pr = list_head(&dd->dd_props);\n\t    pr; pr = list_next(&dd->dd_props, pr)) {\n\t\tfor (cbr = list_head(&pr->pr_cbs); cbr;\n\t\t    cbr = list_next(&pr->pr_cbs, cbr)) {\n\t\t\tuint64_t value;\n\n\t\t\t \n\t\t\tif (ds != cbr->cbr_ds &&\n\t\t\t    !dsl_dataset_try_add_ref(dp, cbr->cbr_ds, FTAG))\n\t\t\t\tcontinue;\n\n\t\t\tif (dsl_prop_get_ds(cbr->cbr_ds,\n\t\t\t    cbr->cbr_pr->pr_propname, sizeof (value), 1,\n\t\t\t    &value, NULL) == 0)\n\t\t\t\tcbr->cbr_func(cbr->cbr_arg, value);\n\n\t\t\tif (ds != cbr->cbr_ds)\n\t\t\t\tdsl_dataset_rele(cbr->cbr_ds, FTAG);\n\t\t}\n\t}\n\tmutex_exit(&dd->dd_lock);\n\n\treturn (0);\n}\n\n \nvoid\ndsl_prop_notify_all(dsl_dir_t *dd)\n{\n\tdsl_pool_t *dp = dd->dd_pool;\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\t(void) dmu_objset_find_dp(dp, dd->dd_object, dsl_prop_notify_all_cb,\n\t    NULL, DS_FIND_CHILDREN);\n}\n\nstatic void\ndsl_prop_changed_notify(dsl_pool_t *dp, uint64_t ddobj,\n    const char *propname, uint64_t value, int first)\n{\n\tdsl_dir_t *dd;\n\tdsl_prop_record_t *pr;\n\tdsl_prop_cb_record_t *cbr;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tzap_cursor_t zc;\n\tzap_attribute_t *za;\n\tint err;\n\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\terr = dsl_dir_hold_obj(dp, ddobj, NULL, FTAG, &dd);\n\tif (err)\n\t\treturn;\n\n\tif (!first) {\n\t\t \n\t\terr = zap_contains(mos, dsl_dir_phys(dd)->dd_props_zapobj,\n\t\t    propname);\n\t\tif (err == 0) {\n\t\t\tdsl_dir_rele(dd, FTAG);\n\t\t\treturn;\n\t\t}\n\t\tASSERT3U(err, ==, ENOENT);\n\t}\n\n\tmutex_enter(&dd->dd_lock);\n\tpr = dsl_prop_record_find(dd, propname);\n\tif (pr != NULL) {\n\t\tfor (cbr = list_head(&pr->pr_cbs); cbr;\n\t\t    cbr = list_next(&pr->pr_cbs, cbr)) {\n\t\t\tuint64_t propobj;\n\n\t\t\t \n\t\t\tif (!dsl_dataset_try_add_ref(dp, cbr->cbr_ds, FTAG))\n\t\t\t\tcontinue;\n\n\t\t\tpropobj = dsl_dataset_phys(cbr->cbr_ds)->ds_props_obj;\n\n\t\t\t \n\t\t\tif (propobj == 0 ||\n\t\t\t    zap_contains(mos, propobj, propname) != 0)\n\t\t\t\tcbr->cbr_func(cbr->cbr_arg, value);\n\n\t\t\tdsl_dataset_rele(cbr->cbr_ds, FTAG);\n\t\t}\n\t}\n\tmutex_exit(&dd->dd_lock);\n\n\tza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\tfor (zap_cursor_init(&zc, mos,\n\t    dsl_dir_phys(dd)->dd_child_dir_zapobj);\n\t    zap_cursor_retrieve(&zc, za) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tdsl_prop_changed_notify(dp, za->za_first_integer,\n\t\t    propname, value, FALSE);\n\t}\n\tkmem_free(za, sizeof (zap_attribute_t));\n\tzap_cursor_fini(&zc);\n\tdsl_dir_rele(dd, FTAG);\n}\n\n\n \nstatic void\ndsl_prop_set_iuv(objset_t *mos, uint64_t zapobj, const char *propname,\n    int intsz, int numints, const void *value, dmu_tx_t *tx)\n{\n\tchar *iuvstr = kmem_asprintf(\"%s%s\", propname, ZPROP_IUV_SUFFIX);\n\tboolean_t iuv = B_FALSE;\n\tzfs_prop_t prop = zfs_name_to_prop(propname);\n\n\tswitch (prop) {\n\tcase ZFS_PROP_REDUNDANT_METADATA:\n\t\tif (*(uint64_t *)value == ZFS_REDUNDANT_METADATA_SOME ||\n\t\t    *(uint64_t *)value == ZFS_REDUNDANT_METADATA_NONE)\n\t\t\tiuv = B_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (iuv) {\n\t\tVERIFY0(zap_update(mos, zapobj, iuvstr, intsz, numints,\n\t\t    value, tx));\n\t\tuint64_t val = zfs_prop_default_numeric(prop);\n\t\tVERIFY0(zap_update(mos, zapobj, propname, intsz, numints,\n\t\t    &val, tx));\n\t} else {\n\t\tzap_remove(mos, zapobj, iuvstr, tx);\n\t}\n\tkmem_strfree(iuvstr);\n}\n\nvoid\ndsl_prop_set_sync_impl(dsl_dataset_t *ds, const char *propname,\n    zprop_source_t source, int intsz, int numints, const void *value,\n    dmu_tx_t *tx)\n{\n\tobjset_t *mos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tuint64_t zapobj, intval, dummy, count;\n\tint isint;\n\tchar valbuf[32];\n\tconst char *valstr = NULL;\n\tchar *inheritstr;\n\tchar *recvdstr;\n\tchar *iuvstr;\n\tchar *tbuf = NULL;\n\tint err;\n\tuint64_t version = spa_version(ds->ds_dir->dd_pool->dp_spa);\n\n\tisint = (dodefault(zfs_name_to_prop(propname), 8, 1, &intval) == 0);\n\n\tif (ds->ds_is_snapshot) {\n\t\tASSERT(version >= SPA_VERSION_SNAP_PROPS);\n\t\tif (dsl_dataset_phys(ds)->ds_props_obj == 0 &&\n\t\t    (source & ZPROP_SRC_NONE) == 0) {\n\t\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\t\tdsl_dataset_phys(ds)->ds_props_obj =\n\t\t\t    zap_create(mos,\n\t\t\t    DMU_OT_DSL_PROPS, DMU_OT_NONE, 0, tx);\n\t\t}\n\t\tzapobj = dsl_dataset_phys(ds)->ds_props_obj;\n\t} else {\n\t\tzapobj = dsl_dir_phys(ds->ds_dir)->dd_props_zapobj;\n\t}\n\n\t \n\tif (zapobj == 0)\n\t\treturn;\n\n\tif (version < SPA_VERSION_RECVD_PROPS) {\n\t\tif (source & ZPROP_SRC_NONE)\n\t\t\tsource = ZPROP_SRC_NONE;\n\t\telse if (source & ZPROP_SRC_RECEIVED)\n\t\t\tsource = ZPROP_SRC_LOCAL;\n\t}\n\n\tinheritstr = kmem_asprintf(\"%s%s\", propname, ZPROP_INHERIT_SUFFIX);\n\trecvdstr = kmem_asprintf(\"%s%s\", propname, ZPROP_RECVD_SUFFIX);\n\tiuvstr = kmem_asprintf(\"%s%s\", propname, ZPROP_IUV_SUFFIX);\n\n\tswitch ((int)source) {\n\tcase ZPROP_SRC_NONE:\n\t\t \n\t\terr = zap_remove(mos, zapobj, propname, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\terr = zap_remove(mos, zapobj, inheritstr, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\tbreak;\n\tcase ZPROP_SRC_LOCAL:\n\t\t \n\t\terr = zap_remove(mos, zapobj, inheritstr, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\tVERIFY0(zap_update(mos, zapobj, propname,\n\t\t    intsz, numints, value, tx));\n\t\t(void) dsl_prop_set_iuv(mos, zapobj, propname, intsz,\n\t\t    numints, value, tx);\n\t\tbreak;\n\tcase ZPROP_SRC_INHERITED:\n\t\t \n\t\terr = zap_remove(mos, zapobj, propname, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\terr = zap_remove(mos, zapobj, iuvstr, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\tif (version >= SPA_VERSION_RECVD_PROPS &&\n\t\t    dsl_prop_get_int_ds(ds, ZPROP_HAS_RECVD, &dummy) == 0) {\n\t\t\tdummy = 0;\n\t\t\tVERIFY0(zap_update(mos, zapobj, inheritstr,\n\t\t\t    8, 1, &dummy, tx));\n\t\t}\n\t\tbreak;\n\tcase ZPROP_SRC_RECEIVED:\n\t\t \n\t\terr = zap_update(mos, zapobj, recvdstr,\n\t\t    intsz, numints, value, tx);\n\t\tASSERT(err == 0);\n\t\tbreak;\n\tcase (ZPROP_SRC_NONE | ZPROP_SRC_LOCAL | ZPROP_SRC_RECEIVED):\n\t\t \n\t\terr = zap_remove(mos, zapobj, propname, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\terr = zap_remove(mos, zapobj, inheritstr, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\tzfs_fallthrough;\n\tcase (ZPROP_SRC_NONE | ZPROP_SRC_RECEIVED):\n\t\t \n\t\terr = zap_remove(mos, zapobj, recvdstr, tx);\n\t\tASSERT(err == 0 || err == ENOENT);\n\t\tbreak;\n\tdefault:\n\t\tcmn_err(CE_PANIC, \"unexpected property source: %d\", source);\n\t}\n\n\tkmem_strfree(inheritstr);\n\tkmem_strfree(recvdstr);\n\tkmem_strfree(iuvstr);\n\n\t \n\tif (ds->ds_is_snapshot &&\n\t    zap_count(mos, zapobj, &count) == 0 && count == 0) {\n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tdsl_dataset_phys(ds)->ds_props_obj = 0;\n\t\tzap_destroy(mos, zapobj, tx);\n\t}\n\n\tif (isint) {\n\t\tVERIFY0(dsl_prop_get_int_ds(ds, propname, &intval));\n\n\t\tif (ds->ds_is_snapshot) {\n\t\t\tdsl_prop_cb_record_t *cbr;\n\t\t\t \n\t\t\tmutex_enter(&ds->ds_dir->dd_lock);\n\t\t\tfor (cbr = list_head(&ds->ds_prop_cbs); cbr;\n\t\t\t    cbr = list_next(&ds->ds_prop_cbs, cbr)) {\n\t\t\t\tif (strcmp(cbr->cbr_pr->pr_propname,\n\t\t\t\t    propname) == 0)\n\t\t\t\t\tcbr->cbr_func(cbr->cbr_arg, intval);\n\t\t\t}\n\t\t\tmutex_exit(&ds->ds_dir->dd_lock);\n\t\t} else {\n\t\t\tdsl_prop_changed_notify(ds->ds_dir->dd_pool,\n\t\t\t    ds->ds_dir->dd_object, propname, intval, TRUE);\n\t\t}\n\n\t\t(void) snprintf(valbuf, sizeof (valbuf),\n\t\t    \"%lld\", (longlong_t)intval);\n\t\tvalstr = valbuf;\n\t} else {\n\t\tif (source == ZPROP_SRC_LOCAL) {\n\t\t\tvalstr = value;\n\t\t} else {\n\t\t\ttbuf = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);\n\t\t\tif (dsl_prop_get_ds(ds, propname, 1,\n\t\t\t    ZAP_MAXVALUELEN, tbuf, NULL) == 0)\n\t\t\t\tvalstr = tbuf;\n\t\t}\n\t}\n\n\tspa_history_log_internal_ds(ds, (source == ZPROP_SRC_NONE ||\n\t    source == ZPROP_SRC_INHERITED) ? \"inherit\" : \"set\", tx,\n\t    \"%s=%s\", propname, (valstr == NULL ? \"\" : valstr));\n\n\tif (tbuf != NULL)\n\t\tkmem_free(tbuf, ZAP_MAXVALUELEN);\n}\n\nint\ndsl_prop_set_int(const char *dsname, const char *propname,\n    zprop_source_t source, uint64_t value)\n{\n\tnvlist_t *nvl = fnvlist_alloc();\n\tint error;\n\n\tfnvlist_add_uint64(nvl, propname, value);\n\terror = dsl_props_set(dsname, source, nvl);\n\tfnvlist_free(nvl);\n\treturn (error);\n}\n\nint\ndsl_prop_set_string(const char *dsname, const char *propname,\n    zprop_source_t source, const char *value)\n{\n\tnvlist_t *nvl = fnvlist_alloc();\n\tint error;\n\n\tfnvlist_add_string(nvl, propname, value);\n\terror = dsl_props_set(dsname, source, nvl);\n\tfnvlist_free(nvl);\n\treturn (error);\n}\n\nint\ndsl_prop_inherit(const char *dsname, const char *propname,\n    zprop_source_t source)\n{\n\tnvlist_t *nvl = fnvlist_alloc();\n\tint error;\n\n\tfnvlist_add_boolean(nvl, propname);\n\terror = dsl_props_set(dsname, source, nvl);\n\tfnvlist_free(nvl);\n\treturn (error);\n}\n\nint\ndsl_props_set_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_props_set_arg_t *dpsa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tuint64_t version;\n\tnvpair_t *elem = NULL;\n\tint err;\n\n\terr = dsl_dataset_hold(dp, dpsa->dpsa_dsname, FTAG, &ds);\n\tif (err != 0)\n\t\treturn (err);\n\n\tversion = spa_version(ds->ds_dir->dd_pool->dp_spa);\n\twhile ((elem = nvlist_next_nvpair(dpsa->dpsa_props, elem)) != NULL) {\n\t\tif (strlen(nvpair_name(elem)) >= ZAP_MAXNAMELEN) {\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t\t}\n\t\tif (nvpair_type(elem) == DATA_TYPE_STRING) {\n\t\t\tconst char *valstr = fnvpair_value_string(elem);\n\t\t\tif (strlen(valstr) >= (version <\n\t\t\t    SPA_VERSION_STMF_PROP ?\n\t\t\t    ZAP_OLDMAXVALUELEN : ZAP_MAXVALUELEN)) {\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\treturn (SET_ERROR(E2BIG));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ds->ds_is_snapshot && version < SPA_VERSION_SNAP_PROPS) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (0);\n}\n\nvoid\ndsl_props_set_sync_impl(dsl_dataset_t *ds, zprop_source_t source,\n    nvlist_t *props, dmu_tx_t *tx)\n{\n\tnvpair_t *elem = NULL;\n\n\twhile ((elem = nvlist_next_nvpair(props, elem)) != NULL) {\n\t\tnvpair_t *pair = elem;\n\t\tconst char *name = nvpair_name(pair);\n\n\t\tif (nvpair_type(pair) == DATA_TYPE_NVLIST) {\n\t\t\t \n\t\t\tnvlist_t *attrs = fnvpair_value_nvlist(pair);\n\t\t\tpair = fnvlist_lookup_nvpair(attrs, ZPROP_VALUE);\n\t\t}\n\n\t\tif (nvpair_type(pair) == DATA_TYPE_STRING) {\n\t\t\tconst char *value = fnvpair_value_string(pair);\n\t\t\tdsl_prop_set_sync_impl(ds, name,\n\t\t\t    source, 1, strlen(value) + 1, value, tx);\n\t\t} else if (nvpair_type(pair) == DATA_TYPE_UINT64) {\n\t\t\tuint64_t intval = fnvpair_value_uint64(pair);\n\t\t\tdsl_prop_set_sync_impl(ds, name,\n\t\t\t    source, sizeof (intval), 1, &intval, tx);\n\t\t} else if (nvpair_type(pair) == DATA_TYPE_BOOLEAN) {\n\t\t\tdsl_prop_set_sync_impl(ds, name,\n\t\t\t    source, 0, 0, NULL, tx);\n\t\t} else {\n\t\t\tpanic(\"invalid nvpair type\");\n\t\t}\n\t}\n}\n\nvoid\ndsl_props_set_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_props_set_arg_t *dpsa = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\n\tVERIFY0(dsl_dataset_hold(dp, dpsa->dpsa_dsname, FTAG, &ds));\n\tdsl_props_set_sync_impl(ds, dpsa->dpsa_source, dpsa->dpsa_props, tx);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\n \nint\ndsl_props_set(const char *dsname, zprop_source_t source, nvlist_t *props)\n{\n\tdsl_props_set_arg_t dpsa;\n\tint nblks = 0;\n\n\tdpsa.dpsa_dsname = dsname;\n\tdpsa.dpsa_source = source;\n\tdpsa.dpsa_props = props;\n\n\t \n\tif ((source & ZPROP_SRC_NONE) == 0)\n\t\tnblks = 2 * fnvlist_num_pairs(props);\n\n\treturn (dsl_sync_task(dsname, dsl_props_set_check, dsl_props_set_sync,\n\t    &dpsa, nblks, ZFS_SPACE_CHECK_RESERVED));\n}\n\ntypedef enum dsl_prop_getflags {\n\tDSL_PROP_GET_INHERITING = 0x1,\t \n\tDSL_PROP_GET_SNAPSHOT = 0x2,\t \n\tDSL_PROP_GET_LOCAL = 0x4,\t \n\tDSL_PROP_GET_RECEIVED = 0x8,\t \n} dsl_prop_getflags_t;\n\nstatic int\ndsl_prop_get_all_impl(objset_t *mos, uint64_t propobj,\n    const char *setpoint, dsl_prop_getflags_t flags, nvlist_t *nv)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tint err = 0;\n\n\tfor (zap_cursor_init(&zc, mos, propobj);\n\t    (err = zap_cursor_retrieve(&zc, &za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tnvlist_t *propval;\n\t\tzfs_prop_t prop;\n\t\tchar buf[ZAP_MAXNAMELEN];\n\t\tchar *valstr;\n\t\tconst char *suffix;\n\t\tconst char *propname;\n\t\tconst char *source;\n\n\t\tsuffix = strchr(za.za_name, '$');\n\n\t\tif (suffix == NULL) {\n\t\t\t \n\t\t\tif (flags & DSL_PROP_GET_RECEIVED)\n\t\t\t\tcontinue;\n\n\t\t\tpropname = za.za_name;\n\t\t\tsource = setpoint;\n\n\t\t\t \n\t\t\tvalstr = kmem_asprintf(\"%s%s\", propname,\n\t\t\t    ZPROP_IUV_SUFFIX);\n\t\t\terr = zap_contains(mos, propobj, valstr);\n\t\t\tkmem_strfree(valstr);\n\t\t\tif (err == 0)\n\t\t\t\tcontinue;\n\t\t} else if (strcmp(suffix, ZPROP_INHERIT_SUFFIX) == 0) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else if (strcmp(suffix, ZPROP_RECVD_SUFFIX) == 0) {\n\t\t\tif (flags & DSL_PROP_GET_LOCAL)\n\t\t\t\tcontinue;\n\n\t\t\t(void) strlcpy(buf, za.za_name,\n\t\t\t    MIN(sizeof (buf), suffix - za.za_name + 1));\n\t\t\tpropname = buf;\n\n\t\t\tif (!(flags & DSL_PROP_GET_RECEIVED)) {\n\t\t\t\t \n\t\t\t\terr = zap_contains(mos, propobj, propname);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (err != ENOENT)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tvalstr = kmem_asprintf(\"%s%s\", propname,\n\t\t\t\t    ZPROP_INHERIT_SUFFIX);\n\t\t\t\terr = zap_contains(mos, propobj, valstr);\n\t\t\t\tkmem_strfree(valstr);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (err != ENOENT)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsource = ((flags & DSL_PROP_GET_INHERITING) ?\n\t\t\t    setpoint : ZPROP_SOURCE_VAL_RECVD);\n\t\t} else if (strcmp(suffix, ZPROP_IUV_SUFFIX) == 0) {\n\t\t\t(void) strlcpy(buf, za.za_name,\n\t\t\t    MIN(sizeof (buf), suffix - za.za_name + 1));\n\t\t\tpropname = buf;\n\t\t\tsource = setpoint;\n\t\t\tprop = zfs_name_to_prop(propname);\n\n\t\t\tif (dsl_prop_known_index(prop,\n\t\t\t    za.za_first_integer) != 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tprop = zfs_name_to_prop(propname);\n\n\t\t \n\t\tif ((flags & DSL_PROP_GET_INHERITING) &&\n\t\t    prop != ZPROP_USERPROP && !zfs_prop_inheritable(prop))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((flags & DSL_PROP_GET_SNAPSHOT) && prop != ZPROP_USERPROP &&\n\t\t    !zfs_prop_valid_for_type(prop, ZFS_TYPE_SNAPSHOT, B_FALSE))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (nvlist_exists(nv, propname))\n\t\t\tcontinue;\n\n\t\tVERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\t\tif (za.za_integer_length == 1) {\n\t\t\t \n\t\t\tchar *tmp = kmem_alloc(za.za_num_integers,\n\t\t\t    KM_SLEEP);\n\t\t\terr = zap_lookup(mos, propobj,\n\t\t\t    za.za_name, 1, za.za_num_integers, tmp);\n\t\t\tif (err != 0) {\n\t\t\t\tkmem_free(tmp, za.za_num_integers);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVERIFY(nvlist_add_string(propval, ZPROP_VALUE,\n\t\t\t    tmp) == 0);\n\t\t\tkmem_free(tmp, za.za_num_integers);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT(za.za_integer_length == 8);\n\t\t\t(void) nvlist_add_uint64(propval, ZPROP_VALUE,\n\t\t\t    za.za_first_integer);\n\t\t}\n\n\t\tVERIFY(nvlist_add_string(propval, ZPROP_SOURCE, source) == 0);\n\t\tVERIFY(nvlist_add_nvlist(nv, propname, propval) == 0);\n\t\tnvlist_free(propval);\n\t}\n\tzap_cursor_fini(&zc);\n\tif (err == ENOENT)\n\t\terr = 0;\n\treturn (err);\n}\n\n \nstatic int\ndsl_prop_get_all_ds(dsl_dataset_t *ds, nvlist_t **nvp,\n    dsl_prop_getflags_t flags)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\tdsl_pool_t *dp = dd->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tint err = 0;\n\tchar setpoint[ZFS_MAX_DATASET_NAME_LEN];\n\n\tVERIFY(nvlist_alloc(nvp, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\n\tif (ds->ds_is_snapshot)\n\t\tflags |= DSL_PROP_GET_SNAPSHOT;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\tif (dsl_dataset_phys(ds)->ds_props_obj != 0) {\n\t\tASSERT(flags & DSL_PROP_GET_SNAPSHOT);\n\t\tdsl_dataset_name(ds, setpoint);\n\t\terr = dsl_prop_get_all_impl(mos,\n\t\t    dsl_dataset_phys(ds)->ds_props_obj, setpoint, flags, *nvp);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (; dd != NULL; dd = dd->dd_parent) {\n\t\tif (dd != ds->ds_dir || (flags & DSL_PROP_GET_SNAPSHOT)) {\n\t\t\tif (flags & (DSL_PROP_GET_LOCAL |\n\t\t\t    DSL_PROP_GET_RECEIVED))\n\t\t\t\tbreak;\n\t\t\tflags |= DSL_PROP_GET_INHERITING;\n\t\t}\n\t\tdsl_dir_name(dd, setpoint);\n\t\terr = dsl_prop_get_all_impl(mos,\n\t\t    dsl_dir_phys(dd)->dd_props_zapobj, setpoint, flags, *nvp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout:\n\tif (err) {\n\t\tnvlist_free(*nvp);\n\t\t*nvp = NULL;\n\t}\n\treturn (err);\n}\n\nboolean_t\ndsl_prop_get_hasrecvd(const char *dsname)\n{\n\tuint64_t dummy;\n\n\treturn (0 ==\n\t    dsl_prop_get_integer(dsname, ZPROP_HAS_RECVD, &dummy, NULL));\n}\n\nstatic int\ndsl_prop_set_hasrecvd_impl(const char *dsname, zprop_source_t source)\n{\n\tuint64_t version;\n\tspa_t *spa;\n\tint error = 0;\n\n\tVERIFY0(spa_open(dsname, &spa, FTAG));\n\tversion = spa_version(spa);\n\tspa_close(spa, FTAG);\n\n\tif (version >= SPA_VERSION_RECVD_PROPS)\n\t\terror = dsl_prop_set_int(dsname, ZPROP_HAS_RECVD, source, 0);\n\treturn (error);\n}\n\n \nint\ndsl_prop_set_hasrecvd(const char *dsname)\n{\n\tint error = 0;\n\tif (!dsl_prop_get_hasrecvd(dsname))\n\t\terror = dsl_prop_set_hasrecvd_impl(dsname, ZPROP_SRC_LOCAL);\n\treturn (error);\n}\n\nvoid\ndsl_prop_unset_hasrecvd(const char *dsname)\n{\n\tVERIFY0(dsl_prop_set_hasrecvd_impl(dsname, ZPROP_SRC_NONE));\n}\n\nint\ndsl_prop_get_all(objset_t *os, nvlist_t **nvp)\n{\n\treturn (dsl_prop_get_all_ds(os->os_dsl_dataset, nvp, 0));\n}\n\nint\ndsl_prop_get_received(const char *dsname, nvlist_t **nvp)\n{\n\tobjset_t *os;\n\tint error;\n\n\t \n\tdsl_prop_getflags_t flags = (dsl_prop_get_hasrecvd(dsname) ?\n\t    DSL_PROP_GET_RECEIVED : DSL_PROP_GET_LOCAL);\n\n\terror = dmu_objset_hold(dsname, FTAG, &os);\n\tif (error != 0)\n\t\treturn (error);\n\terror = dsl_prop_get_all_ds(os->os_dsl_dataset, nvp, flags);\n\tdmu_objset_rele(os, FTAG);\n\treturn (error);\n}\n\nvoid\ndsl_prop_nvlist_add_uint64(nvlist_t *nv, zfs_prop_t prop, uint64_t value)\n{\n\tnvlist_t *propval;\n\tconst char *propname = zfs_prop_to_name(prop);\n\tuint64_t default_value;\n\n\tif (nvlist_lookup_nvlist(nv, propname, &propval) == 0) {\n\t\tVERIFY(nvlist_add_uint64(propval, ZPROP_VALUE, value) == 0);\n\t\treturn;\n\t}\n\n\tVERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\tVERIFY(nvlist_add_uint64(propval, ZPROP_VALUE, value) == 0);\n\t \n\tif (dodefault(prop, 8, 1, &default_value) == 0 &&\n\t    value == default_value) {\n\t\tVERIFY(nvlist_add_string(propval, ZPROP_SOURCE, \"\") == 0);\n\t}\n\tVERIFY(nvlist_add_nvlist(nv, propname, propval) == 0);\n\tnvlist_free(propval);\n}\n\nvoid\ndsl_prop_nvlist_add_string(nvlist_t *nv, zfs_prop_t prop, const char *value)\n{\n\tnvlist_t *propval;\n\tconst char *propname = zfs_prop_to_name(prop);\n\n\tif (nvlist_lookup_nvlist(nv, propname, &propval) == 0) {\n\t\tVERIFY(nvlist_add_string(propval, ZPROP_VALUE, value) == 0);\n\t\treturn;\n\t}\n\n\tVERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);\n\tVERIFY(nvlist_add_string(propval, ZPROP_VALUE, value) == 0);\n\tVERIFY(nvlist_add_nvlist(nv, propname, propval) == 0);\n\tnvlist_free(propval);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dsl_prop_register);\nEXPORT_SYMBOL(dsl_prop_unregister);\nEXPORT_SYMBOL(dsl_prop_unregister_all);\nEXPORT_SYMBOL(dsl_prop_get);\nEXPORT_SYMBOL(dsl_prop_get_integer);\nEXPORT_SYMBOL(dsl_prop_get_all);\nEXPORT_SYMBOL(dsl_prop_get_received);\nEXPORT_SYMBOL(dsl_prop_get_ds);\nEXPORT_SYMBOL(dsl_prop_get_int_ds);\nEXPORT_SYMBOL(dsl_prop_get_dd);\nEXPORT_SYMBOL(dsl_props_set);\nEXPORT_SYMBOL(dsl_prop_set_int);\nEXPORT_SYMBOL(dsl_prop_set_string);\nEXPORT_SYMBOL(dsl_prop_inherit);\nEXPORT_SYMBOL(dsl_prop_predict);\nEXPORT_SYMBOL(dsl_prop_nvlist_add_uint64);\nEXPORT_SYMBOL(dsl_prop_nvlist_add_string);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}