{
  "module_name": "dsl_destroy.c",
  "hash_id": "7938726f10479e00e981c001e7289e50dfcca493eda63efab829a67836224ac8",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_destroy.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/dsl_userhold.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_dir.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_scan.h>\n#include <sys/dmu_objset.h>\n#include <sys/zap.h>\n#include <sys/zfeature.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/dsl_deleg.h>\n#include <sys/dmu_impl.h>\n#include <sys/zvol.h>\n#include <sys/zcp.h>\n#include <sys/dsl_deadlist.h>\n#include <sys/zthr.h>\n#include <sys/spa_impl.h>\n\nextern int zfs_snapshot_history_enabled;\n\nint\ndsl_destroy_snapshot_check_impl(dsl_dataset_t *ds, boolean_t defer)\n{\n\tif (!ds->ds_is_snapshot)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (dsl_dataset_long_held(ds))\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tif (defer) {\n\t\tif (spa_version(ds->ds_dir->dd_pool->dp_spa) <\n\t\t    SPA_VERSION_USERREFS)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\treturn (0);\n\t}\n\n\t \n\tif (ds->ds_userrefs > 0)\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\tif (dsl_dataset_phys(ds)->ds_num_children > 1)\n\t\treturn (SET_ERROR(EEXIST));\n\n\treturn (0);\n}\n\nint\ndsl_destroy_snapshot_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_destroy_snapshot_arg_t *ddsa = arg;\n\tconst char *dsname = ddsa->ddsa_name;\n\tboolean_t defer = ddsa->ddsa_defer;\n\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tint error = 0;\n\tdsl_dataset_t *ds;\n\n\terror = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\n\t \n\tif (error == ENOENT)\n\t\treturn (0);\n\n\tif (error == 0) {\n\t\terror = dsl_destroy_snapshot_check_impl(ds, defer);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\n\treturn (error);\n}\n\nstruct process_old_arg {\n\tdsl_dataset_t *ds;\n\tdsl_dataset_t *ds_prev;\n\tboolean_t after_branch_point;\n\tzio_t *pio;\n\tuint64_t used, comp, uncomp;\n};\n\nstatic int\nprocess_old_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed, dmu_tx_t *tx)\n{\n\tstruct process_old_arg *poa = arg;\n\tdsl_pool_t *dp = poa->ds->ds_dir->dd_pool;\n\n\tASSERT(!BP_IS_HOLE(bp));\n\n\tif (bp->blk_birth <= dsl_dataset_phys(poa->ds)->ds_prev_snap_txg) {\n\t\tdsl_deadlist_insert(&poa->ds->ds_deadlist, bp, bp_freed, tx);\n\t\tif (poa->ds_prev && !poa->after_branch_point &&\n\t\t    bp->blk_birth >\n\t\t    dsl_dataset_phys(poa->ds_prev)->ds_prev_snap_txg) {\n\t\t\tdsl_dataset_phys(poa->ds_prev)->ds_unique_bytes +=\n\t\t\t    bp_get_dsize_sync(dp->dp_spa, bp);\n\t\t}\n\t} else {\n\t\tpoa->used += bp_get_dsize_sync(dp->dp_spa, bp);\n\t\tpoa->comp += BP_GET_PSIZE(bp);\n\t\tpoa->uncomp += BP_GET_UCSIZE(bp);\n\t\tdsl_free_sync(poa->pio, dp, tx->tx_txg, bp);\n\t}\n\treturn (0);\n}\n\nstatic void\nprocess_old_deadlist(dsl_dataset_t *ds, dsl_dataset_t *ds_prev,\n    dsl_dataset_t *ds_next, boolean_t after_branch_point, dmu_tx_t *tx)\n{\n\tstruct process_old_arg poa = { 0 };\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t deadlist_obj;\n\n\tASSERT(ds->ds_deadlist.dl_oldfmt);\n\tASSERT(ds_next->ds_deadlist.dl_oldfmt);\n\n\tpoa.ds = ds;\n\tpoa.ds_prev = ds_prev;\n\tpoa.after_branch_point = after_branch_point;\n\tpoa.pio = zio_root(dp->dp_spa, NULL, NULL, ZIO_FLAG_MUSTSUCCEED);\n\tVERIFY0(bpobj_iterate(&ds_next->ds_deadlist.dl_bpobj,\n\t    process_old_cb, &poa, tx));\n\tVERIFY0(zio_wait(poa.pio));\n\tASSERT3U(poa.used, ==, dsl_dataset_phys(ds)->ds_unique_bytes);\n\n\t \n\tdsl_dir_diduse_space(ds->ds_dir, DD_USED_SNAP,\n\t    -poa.used, -poa.comp, -poa.uncomp, tx);\n\n\t \n\tdsl_deadlist_close(&ds->ds_deadlist);\n\tdsl_deadlist_close(&ds_next->ds_deadlist);\n\tdeadlist_obj = dsl_dataset_phys(ds)->ds_deadlist_obj;\n\tdsl_dataset_phys(ds)->ds_deadlist_obj =\n\t    dsl_dataset_phys(ds_next)->ds_deadlist_obj;\n\tdsl_dataset_phys(ds_next)->ds_deadlist_obj = deadlist_obj;\n\tdsl_deadlist_open(&ds->ds_deadlist, mos,\n\t    dsl_dataset_phys(ds)->ds_deadlist_obj);\n\tdsl_deadlist_open(&ds_next->ds_deadlist, mos,\n\t    dsl_dataset_phys(ds_next)->ds_deadlist_obj);\n}\n\ntypedef struct remaining_clones_key {\n\tdsl_dataset_t *rck_clone;\n\tlist_node_t rck_node;\n} remaining_clones_key_t;\n\nstatic remaining_clones_key_t *\nrck_alloc(dsl_dataset_t *clone)\n{\n\tremaining_clones_key_t *rck = kmem_alloc(sizeof (*rck), KM_SLEEP);\n\trck->rck_clone = clone;\n\treturn (rck);\n}\n\nstatic void\ndsl_dir_remove_clones_key_impl(dsl_dir_t *dd, uint64_t mintxg, dmu_tx_t *tx,\n    list_t *stack, const void *tag)\n{\n\tobjset_t *mos = dd->dd_pool->dp_meta_objset;\n\n\t \n\tif (dsl_dir_phys(dd)->dd_clones == 0)\n\t\treturn;\n\n\tzap_cursor_t *zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);\n\tzap_attribute_t *za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\n\tfor (zap_cursor_init(zc, mos, dsl_dir_phys(dd)->dd_clones);\n\t    zap_cursor_retrieve(zc, za) == 0;\n\t    zap_cursor_advance(zc)) {\n\t\tdsl_dataset_t *clone;\n\n\t\tVERIFY0(dsl_dataset_hold_obj(dd->dd_pool,\n\t\t    za->za_first_integer, tag, &clone));\n\n\t\tif (clone->ds_dir->dd_origin_txg > mintxg) {\n\t\t\tdsl_deadlist_remove_key(&clone->ds_deadlist,\n\t\t\t    mintxg, tx);\n\n\t\t\tif (dsl_dataset_remap_deadlist_exists(clone)) {\n\t\t\t\tdsl_deadlist_remove_key(\n\t\t\t\t    &clone->ds_remap_deadlist, mintxg, tx);\n\t\t\t}\n\n\t\t\tlist_insert_head(stack, rck_alloc(clone));\n\t\t} else {\n\t\t\tdsl_dataset_rele(clone, tag);\n\t\t}\n\t}\n\tzap_cursor_fini(zc);\n\n\tkmem_free(za, sizeof (zap_attribute_t));\n\tkmem_free(zc, sizeof (zap_cursor_t));\n}\n\nvoid\ndsl_dir_remove_clones_key(dsl_dir_t *top_dd, uint64_t mintxg, dmu_tx_t *tx)\n{\n\tlist_t stack;\n\n\tlist_create(&stack, sizeof (remaining_clones_key_t),\n\t    offsetof(remaining_clones_key_t, rck_node));\n\n\tdsl_dir_remove_clones_key_impl(top_dd, mintxg, tx, &stack, FTAG);\n\tfor (remaining_clones_key_t *rck = list_remove_head(&stack);\n\t    rck != NULL; rck = list_remove_head(&stack)) {\n\t\tdsl_dataset_t *clone = rck->rck_clone;\n\t\tdsl_dir_t *clone_dir = clone->ds_dir;\n\n\t\tkmem_free(rck, sizeof (*rck));\n\n\t\tdsl_dir_remove_clones_key_impl(clone_dir, mintxg, tx,\n\t\t    &stack, FTAG);\n\t\tdsl_dataset_rele(clone, FTAG);\n\t}\n\n\tlist_destroy(&stack);\n}\n\nstatic void\ndsl_destroy_snapshot_handle_remaps(dsl_dataset_t *ds, dsl_dataset_t *ds_next,\n    dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\n\t \n\tif (dsl_dataset_remap_deadlist_exists(ds_next)) {\n\t\tif (!bpobj_is_open(&dp->dp_obsolete_bpobj))\n\t\t\tdsl_pool_create_obsolete_bpobj(dp, tx);\n\n\t\tdsl_deadlist_move_bpobj(&ds_next->ds_remap_deadlist,\n\t\t    &dp->dp_obsolete_bpobj,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_txg, tx);\n\t}\n\n\t \n\tif (dsl_dataset_remap_deadlist_exists(ds)) {\n\t\tuint64_t remap_deadlist_object =\n\t\t    dsl_dataset_get_remap_deadlist_object(ds);\n\t\tASSERT(remap_deadlist_object != 0);\n\n\t\tmutex_enter(&ds_next->ds_remap_deadlist_lock);\n\t\tif (!dsl_dataset_remap_deadlist_exists(ds_next))\n\t\t\tdsl_dataset_create_remap_deadlist(ds_next, tx);\n\t\tmutex_exit(&ds_next->ds_remap_deadlist_lock);\n\n\t\tdsl_deadlist_merge(&ds_next->ds_remap_deadlist,\n\t\t    remap_deadlist_object, tx);\n\t\tdsl_dataset_destroy_remap_deadlist(ds, tx);\n\t}\n}\n\nvoid\ndsl_destroy_snapshot_sync_impl(dsl_dataset_t *ds, boolean_t defer, dmu_tx_t *tx)\n{\n\tint after_branch_point = FALSE;\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdsl_dataset_t *ds_prev = NULL;\n\tuint64_t obj;\n\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tASSERT3U(dsl_dataset_phys(ds)->ds_bp.blk_birth, <=, tx->tx_txg);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\tASSERT(zfs_refcount_is_zero(&ds->ds_longholds));\n\n\tif (defer &&\n\t    (ds->ds_userrefs > 0 ||\n\t    dsl_dataset_phys(ds)->ds_num_children > 1)) {\n\t\tASSERT(spa_version(dp->dp_spa) >= SPA_VERSION_USERREFS);\n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tdsl_dataset_phys(ds)->ds_flags |= DS_FLAG_DEFER_DESTROY;\n\t\tif (zfs_snapshot_history_enabled) {\n\t\t\tspa_history_log_internal_ds(ds, \"defer_destroy\", tx,\n\t\t\t    \" \");\n\t\t}\n\t\treturn;\n\t}\n\n\tASSERT3U(dsl_dataset_phys(ds)->ds_num_children, <=, 1);\n\n\tif (zfs_snapshot_history_enabled) {\n\t\t \n\t\tspa_history_log_internal_ds(ds, \"destroy\", tx, \" \");\n\t}\n\n\tdsl_scan_ds_destroyed(ds, tx);\n\n\tobj = ds->ds_object;\n\n\tboolean_t book_exists = dsl_bookmark_ds_destroyed(ds, tx);\n\n\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\tif (dsl_dataset_feature_is_active(ds, f))\n\t\t\tdsl_dataset_deactivate_feature(ds, f, tx);\n\t}\n\tif (dsl_dataset_phys(ds)->ds_prev_snap_obj != 0) {\n\t\tASSERT3P(ds->ds_prev, ==, NULL);\n\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj, FTAG, &ds_prev));\n\t\tafter_branch_point =\n\t\t    (dsl_dataset_phys(ds_prev)->ds_next_snap_obj != obj);\n\n\t\tdmu_buf_will_dirty(ds_prev->ds_dbuf, tx);\n\t\tif (after_branch_point &&\n\t\t    dsl_dataset_phys(ds_prev)->ds_next_clones_obj != 0) {\n\t\t\tdsl_dataset_remove_from_next_clones(ds_prev, obj, tx);\n\t\t\tif (dsl_dataset_phys(ds)->ds_next_snap_obj != 0) {\n\t\t\t\tVERIFY0(zap_add_int(mos,\n\t\t\t\t    dsl_dataset_phys(ds_prev)->\n\t\t\t\t    ds_next_clones_obj,\n\t\t\t\t    dsl_dataset_phys(ds)->ds_next_snap_obj,\n\t\t\t\t    tx));\n\t\t\t}\n\t\t}\n\t\tif (!after_branch_point) {\n\t\t\tdsl_dataset_phys(ds_prev)->ds_next_snap_obj =\n\t\t\t    dsl_dataset_phys(ds)->ds_next_snap_obj;\n\t\t}\n\t}\n\n\tdsl_dataset_t *ds_next;\n\tuint64_t old_unique;\n\tuint64_t used = 0, comp = 0, uncomp = 0;\n\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dataset_phys(ds)->ds_next_snap_obj, FTAG, &ds_next));\n\tASSERT3U(dsl_dataset_phys(ds_next)->ds_prev_snap_obj, ==, obj);\n\n\told_unique = dsl_dataset_phys(ds_next)->ds_unique_bytes;\n\n\tdmu_buf_will_dirty(ds_next->ds_dbuf, tx);\n\tdsl_dataset_phys(ds_next)->ds_prev_snap_obj =\n\t    dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\tdsl_dataset_phys(ds_next)->ds_prev_snap_txg =\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg;\n\tASSERT3U(dsl_dataset_phys(ds)->ds_prev_snap_txg, ==,\n\t    ds_prev ? dsl_dataset_phys(ds_prev)->ds_creation_txg : 0);\n\n\tif (ds_next->ds_deadlist.dl_oldfmt) {\n\t\tprocess_old_deadlist(ds, ds_prev, ds_next,\n\t\t    after_branch_point, tx);\n\t} else {\n\t\t \n\t\tif (ds_prev && !after_branch_point) {\n\t\t\tdsl_deadlist_space_range(&ds_next->ds_deadlist,\n\t\t\t    dsl_dataset_phys(ds_prev)->ds_prev_snap_txg,\n\t\t\t    dsl_dataset_phys(ds)->ds_prev_snap_txg,\n\t\t\t    &used, &comp, &uncomp);\n\t\t\tdsl_dataset_phys(ds_prev)->ds_unique_bytes += used;\n\t\t}\n\n\t\t \n\t\tdsl_deadlist_space_range(&ds_next->ds_deadlist,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_txg, UINT64_MAX,\n\t\t    &used, &comp, &uncomp);\n\t\tdsl_dir_diduse_space(ds->ds_dir, DD_USED_SNAP,\n\t\t    -used, -comp, -uncomp, tx);\n\n\t\t \n\t\tdsl_deadlist_move_bpobj(&ds_next->ds_deadlist,\n\t\t    &dp->dp_free_bpobj, dsl_dataset_phys(ds)->ds_prev_snap_txg,\n\t\t    tx);\n\t\tdsl_dir_diduse_space(tx->tx_pool->dp_free_dir,\n\t\t    DD_USED_HEAD, used, comp, uncomp, tx);\n\n\t\t \n\t\tdsl_deadlist_merge(&ds_next->ds_deadlist,\n\t\t    dsl_dataset_phys(ds)->ds_deadlist_obj, tx);\n\n\t\t \n\t\tdsl_deadlist_discard_tree(&ds_next->ds_deadlist);\n\t}\n\n\tdsl_deadlist_close(&ds->ds_deadlist);\n\tdsl_deadlist_free(mos, dsl_dataset_phys(ds)->ds_deadlist_obj, tx);\n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tdsl_dataset_phys(ds)->ds_deadlist_obj = 0;\n\n\tdsl_destroy_snapshot_handle_remaps(ds, ds_next, tx);\n\n\tif (!book_exists) {\n\t\t \n\t\tdsl_dir_remove_clones_key(ds->ds_dir,\n\t\t    dsl_dataset_phys(ds)->ds_creation_txg, tx);\n\t}\n\n\tif (ds_next->ds_is_snapshot) {\n\t\tdsl_dataset_t *ds_nextnext;\n\n\t\t \n\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t    dsl_dataset_phys(ds_next)->ds_next_snap_obj,\n\t\t    FTAG, &ds_nextnext));\n\t\tdsl_deadlist_space_range(&ds_nextnext->ds_deadlist,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_txg,\n\t\t    dsl_dataset_phys(ds)->ds_creation_txg,\n\t\t    &used, &comp, &uncomp);\n\t\tdsl_dataset_phys(ds_next)->ds_unique_bytes += used;\n\t\tdsl_dataset_rele(ds_nextnext, FTAG);\n\t\tASSERT3P(ds_next->ds_prev, ==, NULL);\n\n\t\t \n\t\tdsl_dataset_t *hds;\n\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t    dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj,\n\t\t    FTAG, &hds));\n\t\tif (!book_exists) {\n\t\t\t \n\t\t\tdsl_deadlist_remove_key(&hds->ds_deadlist,\n\t\t\t    dsl_dataset_phys(ds)->ds_creation_txg, tx);\n\t\t}\n\t\tif (dsl_dataset_remap_deadlist_exists(hds)) {\n\t\t\tdsl_deadlist_remove_key(&hds->ds_remap_deadlist,\n\t\t\t    dsl_dataset_phys(ds)->ds_creation_txg, tx);\n\t\t}\n\t\tdsl_dataset_rele(hds, FTAG);\n\n\t} else {\n\t\tASSERT3P(ds_next->ds_prev, ==, ds);\n\t\tdsl_dataset_rele(ds_next->ds_prev, ds_next);\n\t\tds_next->ds_prev = NULL;\n\t\tif (ds_prev) {\n\t\t\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t\t\t    dsl_dataset_phys(ds)->ds_prev_snap_obj,\n\t\t\t    ds_next, &ds_next->ds_prev));\n\t\t}\n\n\t\tdsl_dataset_recalc_head_uniq(ds_next);\n\n\t\t \n\t\tif (old_unique < ds_next->ds_reserved) {\n\t\t\tint64_t mrsdelta;\n\t\t\tuint64_t new_unique =\n\t\t\t    dsl_dataset_phys(ds_next)->ds_unique_bytes;\n\n\t\t\tASSERT(old_unique <= new_unique);\n\t\t\tmrsdelta = MIN(new_unique - old_unique,\n\t\t\t    ds_next->ds_reserved - old_unique);\n\t\t\tdsl_dir_diduse_space(ds->ds_dir,\n\t\t\t    DD_USED_REFRSRV, -mrsdelta, 0, 0, tx);\n\t\t}\n\t}\n\tdsl_dataset_rele(ds_next, FTAG);\n\n\t \n\tif (ds->ds_objset) {\n\t\tdmu_objset_evict(ds->ds_objset);\n\t\tds->ds_objset = NULL;\n\t}\n\n\t \n\tdsl_dataset_t *ds_head;\n\tASSERT(dsl_dataset_phys(ds)->ds_snapnames_zapobj == 0);\n\tVERIFY0(dsl_dataset_hold_obj(dp,\n\t    dsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj, FTAG, &ds_head));\n\tVERIFY0(dsl_dataset_get_snapname(ds));\n#ifdef ZFS_DEBUG\n\t{\n\t\tuint64_t val;\n\t\tint err;\n\n\t\terr = dsl_dataset_snap_lookup(ds_head,\n\t\t    ds->ds_snapname, &val);\n\t\tASSERT0(err);\n\t\tASSERT3U(val, ==, obj);\n\t}\n#endif\n\tVERIFY0(dsl_dataset_snap_remove(ds_head, ds->ds_snapname, tx, B_TRUE));\n\tdsl_dataset_rele(ds_head, FTAG);\n\n\tif (ds_prev != NULL)\n\t\tdsl_dataset_rele(ds_prev, FTAG);\n\n\tspa_prop_clear_bootfs(dp->dp_spa, ds->ds_object, tx);\n\n\tif (dsl_dataset_phys(ds)->ds_next_clones_obj != 0) {\n\t\tuint64_t count __maybe_unused;\n\t\tASSERT0(zap_count(mos,\n\t\t    dsl_dataset_phys(ds)->ds_next_clones_obj, &count) &&\n\t\t    count == 0);\n\t\tVERIFY0(dmu_object_free(mos,\n\t\t    dsl_dataset_phys(ds)->ds_next_clones_obj, tx));\n\t}\n\tif (dsl_dataset_phys(ds)->ds_props_obj != 0)\n\t\tVERIFY0(zap_destroy(mos, dsl_dataset_phys(ds)->ds_props_obj,\n\t\t    tx));\n\tif (dsl_dataset_phys(ds)->ds_userrefs_obj != 0)\n\t\tVERIFY0(zap_destroy(mos, dsl_dataset_phys(ds)->ds_userrefs_obj,\n\t\t    tx));\n\tdsl_dir_rele(ds->ds_dir, ds);\n\tds->ds_dir = NULL;\n\tdmu_object_free_zapified(mos, obj, tx);\n}\n\nvoid\ndsl_destroy_snapshot_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_destroy_snapshot_arg_t *ddsa = arg;\n\tconst char *dsname = ddsa->ddsa_name;\n\tboolean_t defer = ddsa->ddsa_defer;\n\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\n\tint error = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\tif (error == ENOENT)\n\t\treturn;\n\tASSERT0(error);\n\tdsl_destroy_snapshot_sync_impl(ds, defer, tx);\n\tzvol_remove_minors(dp->dp_spa, dsname, B_TRUE);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\n \nint\ndsl_destroy_snapshots_nvl(nvlist_t *snaps, boolean_t defer,\n    nvlist_t *errlist)\n{\n\tif (nvlist_next_nvpair(snaps, NULL) == NULL)\n\t\treturn (0);\n\n\t \n\tnvlist_t *snaps_normalized = fnvlist_alloc();\n\tfor (nvpair_t *pair = nvlist_next_nvpair(snaps, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(snaps, pair)) {\n\t\tfnvlist_add_boolean_value(snaps_normalized,\n\t\t    nvpair_name(pair), B_TRUE);\n\t}\n\n\tnvlist_t *arg = fnvlist_alloc();\n\tfnvlist_add_nvlist(arg, \"snaps\", snaps_normalized);\n\tfnvlist_free(snaps_normalized);\n\tfnvlist_add_boolean_value(arg, \"defer\", defer);\n\n\tnvlist_t *wrapper = fnvlist_alloc();\n\tfnvlist_add_nvlist(wrapper, ZCP_ARG_ARGLIST, arg);\n\tfnvlist_free(arg);\n\n\tconst char *program =\n\t    \"arg = ...\\n\"\n\t    \"snaps = arg['snaps']\\n\"\n\t    \"defer = arg['defer']\\n\"\n\t    \"errors = { }\\n\"\n\t    \"has_errors = false\\n\"\n\t    \"for snap, v in pairs(snaps) do\\n\"\n\t    \"    errno = zfs.check.destroy{snap, defer=defer}\\n\"\n\t    \"    zfs.debug('snap: ' .. snap .. ' errno: ' .. errno)\\n\"\n\t    \"    if errno == ENOENT then\\n\"\n\t    \"        snaps[snap] = nil\\n\"\n\t    \"    elseif errno ~= 0 then\\n\"\n\t    \"        errors[snap] = errno\\n\"\n\t    \"        has_errors = true\\n\"\n\t    \"    end\\n\"\n\t    \"end\\n\"\n\t    \"if has_errors then\\n\"\n\t    \"    return errors\\n\"\n\t    \"end\\n\"\n\t    \"for snap, v in pairs(snaps) do\\n\"\n\t    \"    errno = zfs.sync.destroy{snap, defer=defer}\\n\"\n\t    \"    assert(errno == 0)\\n\"\n\t    \"end\\n\"\n\t    \"return { }\\n\";\n\n\tnvlist_t *result = fnvlist_alloc();\n\tint error = zcp_eval(nvpair_name(nvlist_next_nvpair(snaps, NULL)),\n\t    program,\n\t    B_TRUE,\n\t    0,\n\t    zfs_lua_max_memlimit,\n\t    fnvlist_lookup_nvpair(wrapper, ZCP_ARG_ARGLIST), result);\n\tif (error != 0) {\n\t\tconst char *errorstr = NULL;\n\t\t(void) nvlist_lookup_string(result, ZCP_RET_ERROR, &errorstr);\n\t\tif (errorstr != NULL) {\n\t\t\tzfs_dbgmsg(\"%s\", errorstr);\n\t\t}\n\t\tfnvlist_free(wrapper);\n\t\tfnvlist_free(result);\n\t\treturn (error);\n\t}\n\tfnvlist_free(wrapper);\n\n\t \n\tint rv = 0;\n\tnvlist_t *errlist_raw = fnvlist_lookup_nvlist(result, ZCP_RET_RETURN);\n\tfor (nvpair_t *pair = nvlist_next_nvpair(errlist_raw, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(errlist_raw, pair)) {\n\t\tint32_t val = (int32_t)fnvpair_value_int64(pair);\n\t\tif (rv == 0)\n\t\t\trv = val;\n\t\tfnvlist_add_int32(errlist, nvpair_name(pair), val);\n\t}\n\tfnvlist_free(result);\n\treturn (rv);\n}\n\nint\ndsl_destroy_snapshot(const char *name, boolean_t defer)\n{\n\tint error;\n\tnvlist_t *nvl = fnvlist_alloc();\n\tnvlist_t *errlist = fnvlist_alloc();\n\n\tfnvlist_add_boolean(nvl, name);\n\terror = dsl_destroy_snapshots_nvl(nvl, defer, errlist);\n\tfnvlist_free(errlist);\n\tfnvlist_free(nvl);\n\treturn (error);\n}\n\nstruct killarg {\n\tdsl_dataset_t *ds;\n\tdmu_tx_t *tx;\n};\n\nstatic int\nkill_blkptr(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)\n{\n\t(void) spa, (void) dnp;\n\tstruct killarg *ka = arg;\n\tdmu_tx_t *tx = ka->tx;\n\n\tif (zb->zb_level == ZB_DNODE_LEVEL || BP_IS_HOLE(bp) ||\n\t    BP_IS_EMBEDDED(bp))\n\t\treturn (0);\n\n\tif (zb->zb_level == ZB_ZIL_LEVEL) {\n\t\tASSERT(zilog != NULL);\n\t\t \n\t\tdsl_free(ka->tx->tx_pool, ka->tx->tx_txg, bp);\n\t} else {\n\t\tASSERT(zilog == NULL);\n\t\tASSERT3U(bp->blk_birth, >,\n\t\t    dsl_dataset_phys(ka->ds)->ds_prev_snap_txg);\n\t\t(void) dsl_dataset_block_kill(ka->ds, bp, tx, B_FALSE);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nold_synchronous_dataset_destroy(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tstruct killarg ka;\n\n\tspa_history_log_internal_ds(ds, \"destroy\", tx,\n\t    \"(synchronous, mintxg=%llu)\",\n\t    (long long)dsl_dataset_phys(ds)->ds_prev_snap_txg);\n\n\t \n\tka.ds = ds;\n\tka.tx = tx;\n\tVERIFY0(traverse_dataset(ds,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg, TRAVERSE_POST |\n\t    TRAVERSE_NO_DECRYPT, kill_blkptr, &ka));\n\tASSERT(!DS_UNIQUE_IS_ACCURATE(ds) ||\n\t    dsl_dataset_phys(ds)->ds_unique_bytes == 0);\n}\n\nint\ndsl_destroy_head_check_impl(dsl_dataset_t *ds, int expected_holds)\n{\n\tint error;\n\tuint64_t count;\n\tobjset_t *mos;\n\n\tASSERT(!ds->ds_is_snapshot);\n\tif (ds->ds_is_snapshot)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zfs_refcount_count(&ds->ds_longholds) != expected_holds)\n\t\treturn (SET_ERROR(EBUSY));\n\n\tASSERT0(ds->ds_dir->dd_activity_waiters);\n\n\tmos = ds->ds_dir->dd_pool->dp_meta_objset;\n\n\t \n\tif (ds->ds_prev != NULL &&\n\t    dsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj == ds->ds_object)\n\t\treturn (SET_ERROR(EBUSY));\n\n\t \n\terror = zap_count(mos,\n\t    dsl_dir_phys(ds->ds_dir)->dd_child_dir_zapobj, &count);\n\tif (error != 0)\n\t\treturn (error);\n\tif (count != 0)\n\t\treturn (SET_ERROR(EEXIST));\n\n\tif (dsl_dir_is_clone(ds->ds_dir) && DS_IS_DEFER_DESTROY(ds->ds_prev) &&\n\t    dsl_dataset_phys(ds->ds_prev)->ds_num_children == 2 &&\n\t    ds->ds_prev->ds_userrefs == 0) {\n\t\t \n\t\tif (!zfs_refcount_is_zero(&ds->ds_prev->ds_longholds))\n\t\t\treturn (SET_ERROR(EBUSY));\n\t}\n\treturn (0);\n}\n\nint\ndsl_destroy_head_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_destroy_head_arg_t *ddha = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\tint error;\n\n\terror = dsl_dataset_hold(dp, ddha->ddha_name, FTAG, &ds);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = dsl_destroy_head_check_impl(ds, 0);\n\tdsl_dataset_rele(ds, FTAG);\n\treturn (error);\n}\n\nstatic void\ndsl_dir_destroy_sync(uint64_t ddobj, dmu_tx_t *tx)\n{\n\tdsl_dir_t *dd;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tdd_used_t t;\n\n\tASSERT(RRW_WRITE_HELD(&dmu_tx_pool(tx)->dp_config_rwlock));\n\n\tVERIFY0(dsl_dir_hold_obj(dp, ddobj, NULL, FTAG, &dd));\n\n\tASSERT0(dsl_dir_phys(dd)->dd_head_dataset_obj);\n\n\t \n\tif (dd->dd_parent != NULL)\n\t\tdsl_fs_ss_count_adjust(dd->dd_parent, -1,\n\t\t    DD_FIELD_FILESYSTEM_COUNT, tx);\n\n\t \n\tdsl_dir_set_reservation_sync_impl(dd, 0, tx);\n\n\tASSERT0(dsl_dir_phys(dd)->dd_used_bytes);\n\tASSERT0(dsl_dir_phys(dd)->dd_reserved);\n\tfor (t = 0; t < DD_USED_NUM; t++)\n\t\tASSERT0(dsl_dir_phys(dd)->dd_used_breakdown[t]);\n\n\tif (dd->dd_crypto_obj != 0) {\n\t\tdsl_crypto_key_destroy_sync(dd->dd_crypto_obj, tx);\n\t\t(void) spa_keystore_unload_wkey_impl(dp->dp_spa, dd->dd_object);\n\t}\n\n\tVERIFY0(zap_destroy(mos, dsl_dir_phys(dd)->dd_child_dir_zapobj, tx));\n\tVERIFY0(zap_destroy(mos, dsl_dir_phys(dd)->dd_props_zapobj, tx));\n\tif (dsl_dir_phys(dd)->dd_clones != 0)\n\t\tVERIFY0(zap_destroy(mos, dsl_dir_phys(dd)->dd_clones, tx));\n\tVERIFY0(dsl_deleg_destroy(mos, dsl_dir_phys(dd)->dd_deleg_zapobj, tx));\n\tVERIFY0(zap_remove(mos,\n\t    dsl_dir_phys(dd->dd_parent)->dd_child_dir_zapobj,\n\t    dd->dd_myname, tx));\n\n\tdsl_dir_rele(dd, FTAG);\n\tdmu_object_free_zapified(mos, ddobj, tx);\n}\n\nstatic void\ndsl_clone_destroy_assert(dsl_dir_t *dd)\n{\n\tuint64_t used, comp, uncomp;\n\n\tASSERT(dsl_dir_is_clone(dd));\n\tdsl_deadlist_space(&dd->dd_livelist, &used, &comp, &uncomp);\n\n\tASSERT3U(dsl_dir_phys(dd)->dd_used_bytes, ==, used);\n\tASSERT3U(dsl_dir_phys(dd)->dd_compressed_bytes, ==, comp);\n\t \n\tASSERT3U(dsl_dir_phys(dd)->dd_uncompressed_bytes, >=, uncomp);\n\n\tASSERT(list_is_empty(&dd->dd_pending_allocs.bpl_list));\n\tASSERT(list_is_empty(&dd->dd_pending_frees.bpl_list));\n}\n\n \nstatic void\ndsl_async_clone_destroy(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tuint64_t zap_obj, to_delete, used, comp, uncomp;\n\tobjset_t *os;\n\tdsl_dir_t *dd = ds->ds_dir;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tspa_t *spa = dmu_tx_pool(tx)->dp_spa;\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\n\tuint64_t mintxg = 0;\n\tdsl_deadlist_entry_t *dle = dsl_deadlist_first(&dd->dd_livelist);\n\tif (dle != NULL)\n\t\tmintxg = dle->dle_mintxg;\n\n\tspa_history_log_internal_ds(ds, \"destroy\", tx,\n\t    \"(livelist, mintxg=%llu)\", (long long)mintxg);\n\n\t \n\tdsl_clone_destroy_assert(dd);\n\n\t \n\tzil_destroy_sync(dmu_objset_zil(os), tx);\n\n\tVERIFY0(zap_lookup(mos, dd->dd_object,\n\t    DD_FIELD_LIVELIST, sizeof (uint64_t), 1, &to_delete));\n\t \n\tint error = zap_lookup(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_DELETED_CLONES, sizeof (uint64_t), 1, &zap_obj);\n\tif (error == ENOENT) {\n\t\tzap_obj = zap_create(mos, DMU_OTN_ZAP_METADATA,\n\t\t    DMU_OT_NONE, 0, tx);\n\t\tVERIFY0(zap_add(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_DELETED_CLONES, sizeof (uint64_t), 1,\n\t\t    &(zap_obj), tx));\n\t\tspa->spa_livelists_to_delete = zap_obj;\n\t} else if (error != 0) {\n\t\tzfs_panic_recover(\"zfs: error %d was returned while looking \"\n\t\t    \"up DMU_POOL_DELETED_CLONES in the zap\", error);\n\t\treturn;\n\t}\n\tVERIFY0(zap_add_int(mos, zap_obj, to_delete, tx));\n\n\t \n\tdsl_deadlist_space(&dd->dd_livelist, &used, &comp, &uncomp);\n\tdsl_dir_diduse_space(dd, DD_USED_HEAD,\n\t    -used, -comp, -dsl_dir_phys(dd)->dd_uncompressed_bytes,\n\t    tx);\n\tdsl_dir_diduse_space(dp->dp_free_dir, DD_USED_HEAD,\n\t    used, comp, uncomp, tx);\n\tdsl_dir_remove_livelist(dd, tx, B_FALSE);\n\tzthr_wakeup(spa->spa_livelist_delete_zthr);\n}\n\n \nstatic void\ndsl_async_dataset_destroy(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tuint64_t used, comp, uncomp;\n\tobjset_t *os;\n\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tspa_history_log_internal_ds(ds, \"destroy\", tx,\n\t    \"(bptree, mintxg=%llu)\",\n\t    (long long)dsl_dataset_phys(ds)->ds_prev_snap_txg);\n\n\tzil_destroy_sync(dmu_objset_zil(os), tx);\n\n\tif (!spa_feature_is_active(dp->dp_spa,\n\t    SPA_FEATURE_ASYNC_DESTROY)) {\n\t\tdsl_scan_t *scn = dp->dp_scan;\n\t\tspa_feature_incr(dp->dp_spa, SPA_FEATURE_ASYNC_DESTROY,\n\t\t    tx);\n\t\tdp->dp_bptree_obj = bptree_alloc(mos, tx);\n\t\tVERIFY0(zap_add(mos,\n\t\t    DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_BPTREE_OBJ, sizeof (uint64_t), 1,\n\t\t    &dp->dp_bptree_obj, tx));\n\t\tASSERT(!scn->scn_async_destroying);\n\t\tscn->scn_async_destroying = B_TRUE;\n\t}\n\n\tused = dsl_dir_phys(ds->ds_dir)->dd_used_bytes;\n\tcomp = dsl_dir_phys(ds->ds_dir)->dd_compressed_bytes;\n\tuncomp = dsl_dir_phys(ds->ds_dir)->dd_uncompressed_bytes;\n\n\tASSERT(!DS_UNIQUE_IS_ACCURATE(ds) ||\n\t    dsl_dataset_phys(ds)->ds_unique_bytes == used);\n\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tbptree_add(mos, dp->dp_bptree_obj,\n\t    &dsl_dataset_phys(ds)->ds_bp,\n\t    dsl_dataset_phys(ds)->ds_prev_snap_txg,\n\t    used, comp, uncomp, tx);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\tdsl_dir_diduse_space(ds->ds_dir, DD_USED_HEAD,\n\t    -used, -comp, -uncomp, tx);\n\tdsl_dir_diduse_space(dp->dp_free_dir, DD_USED_HEAD,\n\t    used, comp, uncomp, tx);\n}\n\nvoid\ndsl_destroy_head_sync_impl(dsl_dataset_t *ds, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t obj, ddobj, prevobj = 0;\n\tboolean_t rmorigin;\n\n\tASSERT3U(dsl_dataset_phys(ds)->ds_num_children, <=, 1);\n\tASSERT(ds->ds_prev == NULL ||\n\t    dsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj != ds->ds_object);\n\trrw_enter(&ds->ds_bp_rwlock, RW_READER, FTAG);\n\tASSERT3U(dsl_dataset_phys(ds)->ds_bp.blk_birth, <=, tx->tx_txg);\n\trrw_exit(&ds->ds_bp_rwlock, FTAG);\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\n\tdsl_dir_cancel_waiters(ds->ds_dir);\n\n\trmorigin = (dsl_dir_is_clone(ds->ds_dir) &&\n\t    DS_IS_DEFER_DESTROY(ds->ds_prev) &&\n\t    dsl_dataset_phys(ds->ds_prev)->ds_num_children == 2 &&\n\t    ds->ds_prev->ds_userrefs == 0);\n\n\t \n\tif (ds->ds_reserved != 0) {\n\t\tdsl_dataset_set_refreservation_sync_impl(ds,\n\t\t    (ZPROP_SRC_NONE | ZPROP_SRC_LOCAL | ZPROP_SRC_RECEIVED),\n\t\t    0, tx);\n\t\tASSERT0(ds->ds_reserved);\n\t}\n\n\tobj = ds->ds_object;\n\n\tfor (spa_feature_t f = 0; f < SPA_FEATURES; f++) {\n\t\tif (dsl_dataset_feature_is_active(ds, f))\n\t\t\tdsl_dataset_deactivate_feature(ds, f, tx);\n\t}\n\n\tdsl_scan_ds_destroyed(ds, tx);\n\n\tif (dsl_dataset_phys(ds)->ds_prev_snap_obj != 0) {\n\t\t \n\t\tASSERT(ds->ds_prev != NULL);\n\t\tASSERT3U(dsl_dataset_phys(ds->ds_prev)->ds_next_snap_obj, !=,\n\t\t    obj);\n\t\tASSERT0(dsl_dataset_phys(ds)->ds_next_snap_obj);\n\n\t\tdmu_buf_will_dirty(ds->ds_prev->ds_dbuf, tx);\n\t\tif (dsl_dataset_phys(ds->ds_prev)->ds_next_clones_obj != 0) {\n\t\t\tdsl_dataset_remove_from_next_clones(ds->ds_prev,\n\t\t\t    obj, tx);\n\t\t}\n\n\t\tASSERT3U(dsl_dataset_phys(ds->ds_prev)->ds_num_children, >, 1);\n\t\tdsl_dataset_phys(ds->ds_prev)->ds_num_children--;\n\t}\n\n\t \n\tdsl_deadlist_close(&ds->ds_deadlist);\n\tdsl_deadlist_free(mos, dsl_dataset_phys(ds)->ds_deadlist_obj, tx);\n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tdsl_dataset_phys(ds)->ds_deadlist_obj = 0;\n\n\tif (dsl_dataset_remap_deadlist_exists(ds))\n\t\tdsl_dataset_destroy_remap_deadlist(ds, tx);\n\n\t \n\tif (dsl_deadlist_is_open(&ds->ds_dir->dd_livelist)) {\n\t\tdsl_async_clone_destroy(ds, tx);\n\t} else if (spa_feature_is_enabled(dp->dp_spa,\n\t    SPA_FEATURE_ASYNC_DESTROY)) {\n\t\tdsl_async_dataset_destroy(ds, tx);\n\t} else {\n\t\told_synchronous_dataset_destroy(ds, tx);\n\t}\n\n\tif (ds->ds_prev != NULL) {\n\t\tif (spa_version(dp->dp_spa) >= SPA_VERSION_DIR_CLONES) {\n\t\t\tVERIFY0(zap_remove_int(mos,\n\t\t\t    dsl_dir_phys(ds->ds_prev->ds_dir)->dd_clones,\n\t\t\t    ds->ds_object, tx));\n\t\t}\n\t\tprevobj = ds->ds_prev->ds_object;\n\t\tdsl_dataset_rele(ds->ds_prev, ds);\n\t\tds->ds_prev = NULL;\n\t}\n\n\t \n\tif (ds->ds_objset) {\n\t\tdmu_objset_evict(ds->ds_objset);\n\t\tds->ds_objset = NULL;\n\t}\n\n\t \n\tdmu_buf_will_dirty(ds->ds_dir->dd_dbuf, tx);\n\tdsl_dir_phys(ds->ds_dir)->dd_head_dataset_obj = 0;\n\tddobj = ds->ds_dir->dd_object;\n\tASSERT(dsl_dataset_phys(ds)->ds_snapnames_zapobj != 0);\n\tVERIFY0(zap_destroy(mos,\n\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj, tx));\n\n\tif (ds->ds_bookmarks_obj != 0) {\n\t\tvoid *cookie = NULL;\n\t\tdsl_bookmark_node_t *dbn;\n\n\t\twhile ((dbn = avl_destroy_nodes(&ds->ds_bookmarks, &cookie)) !=\n\t\t    NULL) {\n\t\t\tif (dbn->dbn_phys.zbm_redaction_obj != 0) {\n\t\t\t\tVERIFY0(dmu_object_free(mos,\n\t\t\t\t    dbn->dbn_phys.zbm_redaction_obj, tx));\n\t\t\t\tspa_feature_decr(dmu_objset_spa(mos),\n\t\t\t\t    SPA_FEATURE_REDACTION_BOOKMARKS, tx);\n\t\t\t}\n\t\t\tif (dbn->dbn_phys.zbm_flags & ZBM_FLAG_HAS_FBN) {\n\t\t\t\tspa_feature_decr(dmu_objset_spa(mos),\n\t\t\t\t    SPA_FEATURE_BOOKMARK_WRITTEN, tx);\n\t\t\t}\n\t\t\tspa_strfree(dbn->dbn_name);\n\t\t\tmutex_destroy(&dbn->dbn_lock);\n\t\t\tkmem_free(dbn, sizeof (*dbn));\n\t\t}\n\t\tavl_destroy(&ds->ds_bookmarks);\n\t\tVERIFY0(zap_destroy(mos, ds->ds_bookmarks_obj, tx));\n\t\tspa_feature_decr(dp->dp_spa, SPA_FEATURE_BOOKMARKS, tx);\n\t}\n\n\tspa_prop_clear_bootfs(dp->dp_spa, ds->ds_object, tx);\n\n\tASSERT0(dsl_dataset_phys(ds)->ds_next_clones_obj);\n\tASSERT0(dsl_dataset_phys(ds)->ds_props_obj);\n\tASSERT0(dsl_dataset_phys(ds)->ds_userrefs_obj);\n\tdsl_dir_rele(ds->ds_dir, ds);\n\tds->ds_dir = NULL;\n\tdmu_object_free_zapified(mos, obj, tx);\n\n\tdsl_dir_destroy_sync(ddobj, tx);\n\n\tif (rmorigin) {\n\t\tdsl_dataset_t *prev;\n\t\tVERIFY0(dsl_dataset_hold_obj(dp, prevobj, FTAG, &prev));\n\t\tdsl_destroy_snapshot_sync_impl(prev, B_FALSE, tx);\n\t\tdsl_dataset_rele(prev, FTAG);\n\t}\n\t \n\tif (spa_feature_is_enabled(dp->dp_spa, SPA_FEATURE_HEAD_ERRLOG))\n\t\tspa_delete_dataset_errlog(dp->dp_spa, ds->ds_object, tx);\n}\n\nvoid\ndsl_destroy_head_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_destroy_head_arg_t *ddha = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddha->ddha_name, FTAG, &ds));\n\tdsl_destroy_head_sync_impl(ds, tx);\n\tzvol_remove_minors(dp->dp_spa, ddha->ddha_name, B_TRUE);\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nstatic void\ndsl_destroy_head_begin_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_destroy_head_arg_t *ddha = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tdsl_dataset_t *ds;\n\n\tVERIFY0(dsl_dataset_hold(dp, ddha->ddha_name, FTAG, &ds));\n\n\t \n\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\tdsl_dataset_phys(ds)->ds_flags |= DS_FLAG_INCONSISTENT;\n\n\tspa_history_log_internal_ds(ds, \"destroy begin\", tx, \" \");\n\tdsl_dataset_rele(ds, FTAG);\n}\n\nint\ndsl_destroy_head(const char *name)\n{\n\tdsl_destroy_head_arg_t ddha;\n\tint error;\n\tspa_t *spa;\n\tboolean_t isenabled;\n\n#ifdef _KERNEL\n\tzfs_destroy_unmount_origin(name);\n#endif\n\n\terror = spa_open(name, &spa, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\tisenabled = spa_feature_is_enabled(spa, SPA_FEATURE_ASYNC_DESTROY);\n\tspa_close(spa, FTAG);\n\n\tddha.ddha_name = name;\n\n\tif (!isenabled) {\n\t\tobjset_t *os;\n\n\t\terror = dsl_sync_task(name, dsl_destroy_head_check,\n\t\t    dsl_destroy_head_begin_sync, &ddha,\n\t\t    0, ZFS_SPACE_CHECK_DESTROY);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\t \n\t\terror = dmu_objset_own(name, DMU_OST_ANY, B_FALSE, B_TRUE,\n\t\t    FTAG, &os);\n\t\tif (error == 0) {\n\t\t\tuint64_t prev_snap_txg =\n\t\t\t    dsl_dataset_phys(dmu_objset_ds(os))->\n\t\t\t    ds_prev_snap_txg;\n\t\t\tfor (uint64_t obj = 0; error == 0;\n\t\t\t    error = dmu_object_next(os, &obj, FALSE,\n\t\t\t    prev_snap_txg))\n\t\t\t\t(void) dmu_free_long_object(os, obj);\n\t\t\t \n\t\t\ttxg_wait_synced(dmu_objset_pool(os), 0);\n\t\t\tdmu_objset_disown(os, B_TRUE, FTAG);\n\t\t}\n\t}\n\n\treturn (dsl_sync_task(name, dsl_destroy_head_check,\n\t    dsl_destroy_head_sync, &ddha, 0, ZFS_SPACE_CHECK_DESTROY));\n}\n\n \nint\ndsl_destroy_inconsistent(const char *dsname, void *arg)\n{\n\t(void) arg;\n\tobjset_t *os;\n\n\tif (dmu_objset_hold(dsname, FTAG, &os) == 0) {\n\t\tboolean_t need_destroy = DS_IS_INCONSISTENT(dmu_objset_ds(os));\n\n\t\t \n\t\tif (dsl_dataset_has_resume_receive_state(dmu_objset_ds(os)))\n\t\t\tneed_destroy = B_FALSE;\n\n\t\tdmu_objset_rele(os, FTAG);\n\t\tif (need_destroy)\n\t\t\t(void) dsl_destroy_head(dsname);\n\t}\n\treturn (0);\n}\n\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(dsl_destroy_head);\nEXPORT_SYMBOL(dsl_destroy_head_sync_impl);\nEXPORT_SYMBOL(dsl_dataset_user_hold_check_one);\nEXPORT_SYMBOL(dsl_destroy_snapshot_sync_impl);\nEXPORT_SYMBOL(dsl_destroy_inconsistent);\nEXPORT_SYMBOL(dsl_dataset_user_release_tmp);\nEXPORT_SYMBOL(dsl_destroy_head_check_impl);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}