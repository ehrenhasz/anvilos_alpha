{
  "module_name": "zcp_get.c",
  "hash_id": "b7594546dfb4f8d92ca4e04042c37c04b18c6c9b65d21c2956349600b047ddf5",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zcp_get.c",
  "human_readable_source": " \n\n \n\n#include <sys/lua/lua.h>\n#include <sys/lua/lualib.h>\n#include <sys/lua/lauxlib.h>\n\n#include <zfs_prop.h>\n\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dmu_objset.h>\n#include <sys/mntent.h>\n#include <sys/sunddi.h>\n#include <sys/zap.h>\n#include <sys/zcp.h>\n#include <sys/zcp_iter.h>\n#include <sys/zcp_global.h>\n#include <sys/zcp_prop.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_znode.h>\n#include <sys/zvol.h>\n\n#ifdef _KERNEL\n#include <sys/zfs_quota.h>\n#include <sys/zfs_vfsops.h>\n#endif\n\nstatic int\nget_objset_type(dsl_dataset_t *ds, zfs_type_t *type)\n{\n\tint error;\n\tobjset_t *os;\n\terror = dmu_objset_from_ds(ds, &os);\n\tif (error != 0)\n\t\treturn (error);\n\tif (ds->ds_is_snapshot) {\n\t\t*type = ZFS_TYPE_SNAPSHOT;\n\t} else {\n\t\tswitch (os->os_phys->os_type) {\n\t\tcase DMU_OST_ZFS:\n\t\t\t*type = ZFS_TYPE_FILESYSTEM;\n\t\t\tbreak;\n\t\tcase DMU_OST_ZVOL:\n\t\t\t*type = ZFS_TYPE_VOLUME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nstatic int\nget_objset_type_name(dsl_dataset_t *ds, char *str)\n{\n\tzfs_type_t type = ZFS_TYPE_INVALID;\n\tint error = get_objset_type(ds, &type);\n\tif (error != 0)\n\t\treturn (error);\n\tswitch (type) {\n\tcase ZFS_TYPE_SNAPSHOT:\n\t\t(void) strlcpy(str, \"snapshot\", ZAP_MAXVALUELEN);\n\t\tbreak;\n\tcase ZFS_TYPE_FILESYSTEM:\n\t\t(void) strlcpy(str, \"filesystem\", ZAP_MAXVALUELEN);\n\t\tbreak;\n\tcase ZFS_TYPE_VOLUME:\n\t\t(void) strlcpy(str, \"volume\", ZAP_MAXVALUELEN);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}\n\n \nstatic void\nget_prop_src(lua_State *state, const char *setpoint, zfs_prop_t prop)\n{\n\tif (zfs_prop_readonly(prop) || (prop == ZFS_PROP_VERSION)) {\n\t\tlua_pushnil(state);\n\t} else {\n\t\tconst char *src;\n\t\tif (strcmp(\"\", setpoint) == 0) {\n\t\t\tsrc = \"default\";\n\t\t} else {\n\t\t\tsrc = setpoint;\n\t\t}\n\t\t(void) lua_pushstring(state, src);\n\t}\n}\n\n \nstatic int\nzcp_handle_error(lua_State *state, const char *dataset_name,\n    const char *property_name, int error)\n{\n\tASSERT3S(error, !=, 0);\n\tif (error == ENOENT) {\n\t\treturn (0);\n\t} else if (error == EINVAL) {\n\t\treturn (luaL_error(state,\n\t\t    \"property '%s' is not a valid property on dataset '%s'\",\n\t\t    property_name, dataset_name));\n\t} else if (error == EIO) {\n\t\treturn (luaL_error(state,\n\t\t    \"I/O error while retrieving property '%s' on dataset '%s'\",\n\t\t    property_name, dataset_name));\n\t} else {\n\t\treturn (luaL_error(state, \"unexpected error %d while \"\n\t\t    \"retrieving property '%s' on dataset '%s'\",\n\t\t    error, property_name, dataset_name));\n\t}\n}\n\n \nstatic int\nzcp_get_user_prop(lua_State *state, dsl_pool_t *dp, const char *dataset_name,\n    const char *property_name)\n{\n\tint error;\n\tchar *buf;\n\tchar setpoint[ZFS_MAX_DATASET_NAME_LEN];\n\t \n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, dataset_name, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\tbuf = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);\n\terror = dsl_prop_get_ds(ds, property_name, 1, ZAP_MAXVALUELEN,\n\t    buf, setpoint);\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif (error != 0) {\n\t\tkmem_free(buf, ZAP_MAXVALUELEN);\n\t\treturn (zcp_handle_error(state, dataset_name, property_name,\n\t\t    error));\n\t}\n\t(void) lua_pushstring(state, buf);\n\t(void) lua_pushstring(state, setpoint);\n\tkmem_free(buf, ZAP_MAXVALUELEN);\n\treturn (2);\n}\n\n \nstatic int\nget_dsl_dir_prop(dsl_dataset_t *ds, zfs_prop_t zfs_prop,\n    uint64_t *val)\n{\n\tdsl_dir_t *dd = ds->ds_dir;\n\tmutex_enter(&dd->dd_lock);\n\tswitch (zfs_prop) {\n\tcase ZFS_PROP_USEDSNAP:\n\t\t*val = dsl_dir_get_usedsnap(dd);\n\t\tbreak;\n\tcase ZFS_PROP_USEDCHILD:\n\t\t*val = dsl_dir_get_usedchild(dd);\n\t\tbreak;\n\tcase ZFS_PROP_USEDDS:\n\t\t*val = dsl_dir_get_usedds(dd);\n\t\tbreak;\n\tcase ZFS_PROP_USEDREFRESERV:\n\t\t*val = dsl_dir_get_usedrefreserv(dd);\n\t\tbreak;\n\tcase ZFS_PROP_LOGICALUSED:\n\t\t*val = dsl_dir_get_logicalused(dd);\n\t\tbreak;\n\tdefault:\n\t\tmutex_exit(&dd->dd_lock);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\tmutex_exit(&dd->dd_lock);\n\treturn (0);\n}\n\n \nstatic int\nget_special_prop(lua_State *state, dsl_dataset_t *ds, const char *dsname,\n    zfs_prop_t zfs_prop)\n{\n\tint error = 0;\n\tobjset_t *os;\n\tuint64_t numval = 0;\n\tchar *strval = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);\n\tchar setpoint[ZFS_MAX_DATASET_NAME_LEN] =\n\t    \"Internal error - setpoint not determined\";\n\tzfs_type_t ds_type = ZFS_TYPE_INVALID;\n\tzprop_type_t prop_type = zfs_prop_get_type(zfs_prop);\n\t(void) get_objset_type(ds, &ds_type);\n\n\tswitch (zfs_prop) {\n\tcase ZFS_PROP_REFRATIO:\n\t\tnumval = dsl_get_refratio(ds);\n\t\tbreak;\n\tcase ZFS_PROP_USED:\n\t\tnumval = dsl_get_used(ds);\n\t\tbreak;\n\tcase ZFS_PROP_CLONES: {\n\t\tnvlist_t *clones = fnvlist_alloc();\n\t\terror = get_clones_stat_impl(ds, clones);\n\t\tif (error == 0) {\n\t\t\t \n\t\t\tVERIFY0(zcp_nvlist_to_lua(state, clones, NULL, 0ULL));\n\t\t\t \n\t\t\t(void) lua_pushnil(state);\n\t\t}\n\t\tnvlist_free(clones);\n\t\tkmem_free(strval, ZAP_MAXVALUELEN);\n\t\treturn (error);\n\t}\n\tcase ZFS_PROP_COMPRESSRATIO:\n\t\tnumval = dsl_get_compressratio(ds);\n\t\tbreak;\n\tcase ZFS_PROP_CREATION:\n\t\tnumval = dsl_get_creation(ds);\n\t\tbreak;\n\tcase ZFS_PROP_REFERENCED:\n\t\tnumval = dsl_get_referenced(ds);\n\t\tbreak;\n\tcase ZFS_PROP_AVAILABLE:\n\t\tnumval = dsl_get_available(ds);\n\t\tbreak;\n\tcase ZFS_PROP_LOGICALREFERENCED:\n\t\tnumval = dsl_get_logicalreferenced(ds);\n\t\tbreak;\n\tcase ZFS_PROP_CREATETXG:\n\t\tnumval = dsl_get_creationtxg(ds);\n\t\tbreak;\n\tcase ZFS_PROP_GUID:\n\t\tnumval = dsl_get_guid(ds);\n\t\tbreak;\n\tcase ZFS_PROP_UNIQUE:\n\t\tnumval = dsl_get_unique(ds);\n\t\tbreak;\n\tcase ZFS_PROP_OBJSETID:\n\t\tnumval = dsl_get_objsetid(ds);\n\t\tbreak;\n\tcase ZFS_PROP_ORIGIN:\n\t\tdsl_dir_get_origin(ds->ds_dir, strval);\n\t\tbreak;\n\tcase ZFS_PROP_USERACCOUNTING:\n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\tif (error == 0)\n\t\t\tnumval = dmu_objset_userspace_present(os);\n\t\tbreak;\n\tcase ZFS_PROP_WRITTEN:\n\t\terror = dsl_get_written(ds, &numval);\n\t\tbreak;\n\tcase ZFS_PROP_TYPE:\n\t\terror = get_objset_type_name(ds, strval);\n\t\tbreak;\n\tcase ZFS_PROP_PREV_SNAP:\n\t\terror = dsl_get_prev_snap(ds, strval);\n\t\tbreak;\n\tcase ZFS_PROP_NAME:\n\t\tdsl_dataset_name(ds, strval);\n\t\tbreak;\n\tcase ZFS_PROP_MOUNTPOINT:\n\t\terror = dsl_get_mountpoint(ds, dsname, strval, setpoint);\n\t\tbreak;\n\tcase ZFS_PROP_VERSION:\n\t\t \n\t\tASSERT(ds_type != ZFS_TYPE_VOLUME);\n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\t \n\t\tif (error == 0) {\n\t\t\terror = zap_lookup(os, MASTER_NODE_OBJ, ZPL_VERSION_STR,\n\t\t\t    sizeof (numval), 1, &numval);\n\t\t}\n\t\tbreak;\n\tcase ZFS_PROP_DEFER_DESTROY:\n\t\tnumval = dsl_get_defer_destroy(ds);\n\t\tbreak;\n\tcase ZFS_PROP_USERREFS:\n\t\tnumval = dsl_get_userrefs(ds);\n\t\tbreak;\n\tcase ZFS_PROP_FILESYSTEM_COUNT:\n\t\terror = dsl_dir_get_filesystem_count(ds->ds_dir, &numval);\n\t\t(void) strlcpy(setpoint, \"\", ZFS_MAX_DATASET_NAME_LEN);\n\t\tbreak;\n\tcase ZFS_PROP_SNAPSHOT_COUNT:\n\t\terror = dsl_dir_get_snapshot_count(ds->ds_dir, &numval);\n\t\t(void) strlcpy(setpoint, \"\", ZFS_MAX_DATASET_NAME_LEN);\n\t\tbreak;\n\tcase ZFS_PROP_NUMCLONES:\n\t\tnumval = dsl_get_numclones(ds);\n\t\tbreak;\n\tcase ZFS_PROP_INCONSISTENT:\n\t\tnumval = dsl_get_inconsistent(ds);\n\t\tbreak;\n\tcase ZFS_PROP_IVSET_GUID:\n\t\tif (dsl_dataset_is_zapified(ds)) {\n\t\t\terror = zap_lookup(ds->ds_dir->dd_pool->dp_meta_objset,\n\t\t\t    ds->ds_object, DS_FIELD_IVSET_GUID,\n\t\t\t    sizeof (numval), 1, &numval);\n\t\t} else {\n\t\t\terror = ENOENT;\n\t\t}\n\t\tbreak;\n\tcase ZFS_PROP_RECEIVE_RESUME_TOKEN: {\n\t\tchar *token = get_receive_resume_token(ds);\n\t\tif (token != NULL) {\n\t\t\t(void) strlcpy(strval, token, ZAP_MAXVALUELEN);\n\t\t\tkmem_strfree(token);\n\t\t} else {\n\t\t\terror = ENOENT;\n\t\t}\n\t\tbreak;\n\t}\n\tcase ZFS_PROP_VOLSIZE:\n\t\tASSERT(ds_type == ZFS_TYPE_VOLUME ||\n\t\t    ds_type == ZFS_TYPE_SNAPSHOT);\n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\tif (error == 0) {\n\t\t\terror = zap_lookup(os, ZVOL_ZAP_OBJ, \"size\",\n\t\t\t    sizeof (numval), 1, &numval);\n\t\t}\n\t\tif (error == 0)\n\t\t\t(void) strlcpy(setpoint, dsname,\n\t\t\t    ZFS_MAX_DATASET_NAME_LEN);\n\n\t\tbreak;\n\tcase ZFS_PROP_VOLBLOCKSIZE: {\n\t\tASSERT(ds_type == ZFS_TYPE_VOLUME);\n\t\tdmu_object_info_t doi;\n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\tif (error == 0) {\n\t\t\terror = dmu_object_info(os, ZVOL_OBJ, &doi);\n\t\t\tif (error == 0)\n\t\t\t\tnumval = doi.doi_data_block_size;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase ZFS_PROP_KEYSTATUS:\n\tcase ZFS_PROP_KEYFORMAT: {\n\t\t \n\t\tsetpoint[0] = '\\0';\n\t\tif (zfs_prop == ZFS_PROP_KEYSTATUS)\n\t\t\tnumval = ZFS_KEYSTATUS_NONE;\n\t\telse\n\t\t\tnumval = ZFS_KEYFORMAT_NONE;\n\n\t\tnvlist_t *nvl, *propval;\n\t\tnvl = fnvlist_alloc();\n\t\tdsl_dataset_crypt_stats(ds, nvl);\n\t\tif (nvlist_lookup_nvlist(nvl, zfs_prop_to_name(zfs_prop),\n\t\t    &propval) == 0) {\n\t\t\tconst char *source;\n\n\t\t\t(void) nvlist_lookup_uint64(propval, ZPROP_VALUE,\n\t\t\t    &numval);\n\t\t\tif (nvlist_lookup_string(propval, ZPROP_SOURCE,\n\t\t\t    &source) == 0)\n\t\t\t\tstrlcpy(setpoint, source, sizeof (setpoint));\n\t\t}\n\t\tnvlist_free(nvl);\n\t\tbreak;\n\t}\n\n\tcase ZFS_PROP_SNAPSHOTS_CHANGED:\n\t\tnumval = dsl_dir_snap_cmtime(ds->ds_dir).tv_sec;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\terror = get_dsl_dir_prop(ds, zfs_prop, &numval);\n\t}\n\tif (error != 0) {\n\t\tkmem_free(strval, ZAP_MAXVALUELEN);\n\t\treturn (error);\n\t}\n\n\tswitch (prop_type) {\n\tcase PROP_TYPE_NUMBER: {\n\t\t(void) lua_pushnumber(state, numval);\n\t\tbreak;\n\t}\n\tcase PROP_TYPE_STRING: {\n\t\t(void) lua_pushstring(state, strval);\n\t\tbreak;\n\t}\n\tcase PROP_TYPE_INDEX: {\n\t\tconst char *propval;\n\t\terror = zfs_prop_index_to_string(zfs_prop, numval, &propval);\n\t\tif (error != 0) {\n\t\t\tkmem_free(strval, ZAP_MAXVALUELEN);\n\t\t\treturn (error);\n\t\t}\n\t\t(void) lua_pushstring(state, propval);\n\t\tbreak;\n\t}\n\t}\n\tkmem_free(strval, ZAP_MAXVALUELEN);\n\n\t \n\tget_prop_src(state, setpoint, zfs_prop);\n\treturn (0);\n}\n\n \nstatic int\nget_zap_prop(lua_State *state, dsl_dataset_t *ds, zfs_prop_t zfs_prop)\n{\n\tint error = 0;\n\tchar setpoint[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *strval = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);\n\tuint64_t numval;\n\tconst char *prop_name = zfs_prop_to_name(zfs_prop);\n\tzprop_type_t prop_type = zfs_prop_get_type(zfs_prop);\n\n\tif (prop_type == PROP_TYPE_STRING) {\n\t\t \n\t\terror = dsl_prop_get_ds(ds, prop_name, 1,\n\t\t    ZAP_MAXVALUELEN, strval, setpoint);\n\t\tif (error == 0)\n\t\t\t(void) lua_pushstring(state, strval);\n\t} else {\n\t\terror = dsl_prop_get_ds(ds, prop_name, sizeof (numval),\n\t\t    1, &numval, setpoint);\n\t\tif (error != 0)\n\t\t\tgoto out;\n#ifdef _KERNEL\n\t\t \n\t\t(void) zfs_get_temporary_prop(ds, zfs_prop, &numval, setpoint);\n#else\n\t\tkmem_free(strval, ZAP_MAXVALUELEN);\n\t\treturn (luaL_error(state,\n\t\t    \"temporary properties only supported in kernel mode\",\n\t\t    prop_name));\n#endif\n\t\t \n\t\tif (prop_type == PROP_TYPE_INDEX) {\n\t\t\tconst char *propval;\n\t\t\terror = zfs_prop_index_to_string(zfs_prop, numval,\n\t\t\t    &propval);\n\t\t\tif (error == 0)\n\t\t\t\t(void) lua_pushstring(state, propval);\n\t\t} else {\n\t\t\tif (error == 0)\n\t\t\t\t(void) lua_pushnumber(state, numval);\n\t\t}\n\t}\nout:\n\tkmem_free(strval, ZAP_MAXVALUELEN);\n\tif (error == 0)\n\t\tget_prop_src(state, setpoint, zfs_prop);\n\treturn (error);\n}\n\n \nboolean_t\nprop_valid_for_ds(dsl_dataset_t *ds, zfs_prop_t zfs_prop)\n{\n\tzfs_type_t zfs_type = ZFS_TYPE_INVALID;\n\n\t \n\tif ((zfs_prop == ZFS_PROP_ISCSIOPTIONS) ||\n\t    (zfs_prop == ZFS_PROP_MOUNTED))\n\t\treturn (B_FALSE);\n\n\t \n\tif ((zfs_prop == ZFS_PROP_ORIGIN) && (!dsl_dir_is_clone(ds->ds_dir)))\n\t\treturn (B_FALSE);\n\n\tint error = get_objset_type(ds, &zfs_type);\n\tif (error != 0)\n\t\treturn (B_FALSE);\n\treturn (zfs_prop_valid_for_type(zfs_prop, zfs_type, B_FALSE));\n}\n\n \nstatic int\nzcp_get_system_prop(lua_State *state, dsl_pool_t *dp, const char *dataset_name,\n    zfs_prop_t zfs_prop)\n{\n\tint error;\n\t \n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, dataset_name, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\t \n\tconst char *prop_name = zfs_prop_to_name(zfs_prop);\n\tif (!prop_valid_for_ds(ds, zfs_prop)) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\terror = get_special_prop(state, ds, dataset_name, zfs_prop);\n\tif (error == 0) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\t \n\t\treturn (2);\n\t}\n\tif (error != ENOENT) {\n\t\tdsl_dataset_rele(ds, FTAG);\n\t\treturn (zcp_handle_error(state, dataset_name,\n\t\t    prop_name, error));\n\t}\n\n\t \n\terror = get_zap_prop(state, ds, zfs_prop);\n\tdsl_dataset_rele(ds, FTAG);\n\tif (error != 0) {\n\t\treturn (zcp_handle_error(state, dataset_name,\n\t\t    prop_name, error));\n\t}\n\t \n\treturn (2);\n}\n\n#ifdef _KERNEL\nstatic zfs_userquota_prop_t\nget_userquota_prop(const char *prop_name)\n{\n\tzfs_userquota_prop_t type;\n\t \n\tfor (type = 0; type < ZFS_NUM_USERQUOTA_PROPS; type++) {\n\t\tif (strncmp(prop_name, zfs_userquota_prop_prefixes[type],\n\t\t    strlen(zfs_userquota_prop_prefixes[type])) == 0)\n\t\t\tbreak;\n\t}\n\treturn (type);\n}\n\n \nstatic int\nparse_userquota_prop(const char *prop_name, zfs_userquota_prop_t *type,\n    char **domain, uint64_t *rid)\n{\n\tchar *cp, *end, *domain_val;\n\n\t*type = get_userquota_prop(prop_name);\n\tif (*type >= ZFS_NUM_USERQUOTA_PROPS)\n\t\treturn (EINVAL);\n\n\t*rid = 0;\n\tcp = strchr(prop_name, '@') + 1;\n\tif (strncmp(cp, \"S-1-\", 4) == 0) {\n\t\t \n\t\tint domain_len = strrchr(cp, '-') - cp;\n\t\tdomain_val = kmem_alloc(domain_len + 1, KM_SLEEP);\n\t\t(void) strlcpy(domain_val, cp, domain_len + 1);\n\t\tcp += domain_len + 1;\n\n\t\t(void) ddi_strtoll(cp, &end, 10, (longlong_t *)rid);\n\t\tif (*end != '\\0') {\n\t\t\tkmem_strfree(domain_val);\n\t\t\treturn (EINVAL);\n\t\t}\n\t} else {\n\t\t \n\t\tdomain_val = NULL;\n\t\t(void) ddi_strtoll(cp, &end, 10, (longlong_t *)rid);\n\t\tif (*end != '\\0')\n\t\t\treturn (EINVAL);\n\t}\n\t*domain = domain_val;\n\treturn (0);\n}\n\n \nstatic int\nzcp_get_userquota_prop(lua_State *state, dsl_pool_t *dp,\n    const char *dataset_name, const char *prop_name)\n{\n\tzfsvfs_t *zfvp;\n\tzfsvfs_t *zfsvfs;\n\tint error;\n\tzfs_userquota_prop_t type;\n\tchar *domain;\n\tuint64_t rid, value = 0;\n\tobjset_t *os;\n\n\tdsl_dataset_t *ds = zcp_dataset_hold(state, dp, dataset_name, FTAG);\n\tif (ds == NULL)\n\t\treturn (1);  \n\n\terror = parse_userquota_prop(prop_name, &type, &domain, &rid);\n\tif (error == 0) {\n\t\terror = dmu_objset_from_ds(ds, &os);\n\t\tif (error == 0) {\n\t\t\tzfsvfs = kmem_zalloc(sizeof (zfsvfs_t), KM_SLEEP);\n\t\t\terror = zfsvfs_create_impl(&zfvp, zfsvfs, os);\n\t\t\tif (error == 0) {\n\t\t\t\terror = zfs_userspace_one(zfvp, type, domain,\n\t\t\t\t    rid, &value);\n\t\t\t\tzfsvfs_free(zfvp);\n\t\t\t}\n\t\t}\n\t\tif (domain != NULL)\n\t\t\tkmem_strfree(domain);\n\t}\n\tdsl_dataset_rele(ds, FTAG);\n\n\tif ((value == 0) && ((type == ZFS_PROP_USERQUOTA) ||\n\t    (type == ZFS_PROP_GROUPQUOTA)))\n\t\terror = SET_ERROR(ENOENT);\n\tif (error != 0) {\n\t\treturn (zcp_handle_error(state, dataset_name,\n\t\t    prop_name, error));\n\t}\n\n\t(void) lua_pushnumber(state, value);\n\t(void) lua_pushstring(state, dataset_name);\n\treturn (2);\n}\n#endif\n\n \nstatic void\nparse_written_prop(const char *dataset_name, const char *prop_name,\n    char *snap_name)\n{\n\tASSERT(zfs_prop_written(prop_name));\n\tconst char *name = prop_name + ZFS_WRITTEN_PROP_PREFIX_LEN;\n\tif (strchr(name, '@') == NULL) {\n\t\t(void) snprintf(snap_name, ZFS_MAX_DATASET_NAME_LEN, \"%s@%s\",\n\t\t    dataset_name, name);\n\t} else {\n\t\t(void) strlcpy(snap_name, name, ZFS_MAX_DATASET_NAME_LEN);\n\t}\n}\n\n \nstatic int\nzcp_get_written_prop(lua_State *state, dsl_pool_t *dp,\n    const char *dataset_name, const char *prop_name)\n{\n\tchar snap_name[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t used, comp, uncomp;\n\tdsl_dataset_t *old;\n\tint error = 0;\n\n\tparse_written_prop(dataset_name, prop_name, snap_name);\n\tdsl_dataset_t *new = zcp_dataset_hold(state, dp, dataset_name, FTAG);\n\tif (new == NULL)\n\t\treturn (1);  \n\n\terror = dsl_dataset_hold(dp, snap_name, FTAG, &old);\n\tif (error != 0) {\n\t\tdsl_dataset_rele(new, FTAG);\n\t\treturn (zcp_dataset_hold_error(state, dp, snap_name,\n\t\t    error));\n\t}\n\terror = dsl_dataset_space_written(old, new,\n\t    &used, &comp, &uncomp);\n\n\tdsl_dataset_rele(old, FTAG);\n\tdsl_dataset_rele(new, FTAG);\n\n\tif (error != 0) {\n\t\treturn (zcp_handle_error(state, dataset_name,\n\t\t    snap_name, error));\n\t}\n\t(void) lua_pushnumber(state, used);\n\t(void) lua_pushstring(state, dataset_name);\n\treturn (2);\n}\n\nstatic int zcp_get_prop(lua_State *state);\nstatic const zcp_lib_info_t zcp_get_prop_info = {\n\t.name = \"get_prop\",\n\t.func = zcp_get_prop,\n\t.pargs = {\n\t    { .za_name = \"dataset\", .za_lua_type = LUA_TSTRING },\n\t    { .za_name = \"property\", .za_lua_type =  LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t}\n};\n\nstatic int\nzcp_get_prop(lua_State *state)\n{\n\tconst char *dataset_name;\n\tconst char *property_name;\n\tdsl_pool_t *dp = zcp_run_info(state)->zri_pool;\n\tconst zcp_lib_info_t *libinfo = &zcp_get_prop_info;\n\n\tzcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);\n\n\tdataset_name = lua_tostring(state, 1);\n\tproperty_name = lua_tostring(state, 2);\n\n\t \n\tif (zfs_prop_user(property_name)) {\n\t\treturn (zcp_get_user_prop(state, dp,\n\t\t    dataset_name, property_name));\n\t}\n\t \n\tif (zfs_prop_userquota(property_name)) {\n#ifdef _KERNEL\n\t\treturn (zcp_get_userquota_prop(state, dp,\n\t\t    dataset_name, property_name));\n#else\n\t\treturn (luaL_error(state,\n\t\t    \"user quota properties only supported in kernel mode\",\n\t\t    property_name));\n#endif\n\t}\n\t \n\tif (zfs_prop_written(property_name)) {\n\t\treturn (zcp_get_written_prop(state, dp,\n\t\t    dataset_name, property_name));\n\t}\n\n\tzfs_prop_t zfs_prop = zfs_name_to_prop(property_name);\n\t \n\tif (zfs_prop != ZPROP_INVAL) {\n\t\treturn (zcp_get_system_prop(state, dp, dataset_name,\n\t\t    zfs_prop));\n\t}\n\n\t \n\treturn (luaL_error(state,\n\t    \"'%s' is not a valid property\", property_name));\n}\n\nint\nzcp_load_get_lib(lua_State *state)\n{\n\tlua_pushcclosure(state, zcp_get_prop_info.func, 0);\n\tlua_setfield(state, -2, zcp_get_prop_info.name);\n\n\treturn (1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}