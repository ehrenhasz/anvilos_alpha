{
  "module_name": "zap_leaf.c",
  "hash_id": "8fc795048f891d14826850df10768841cbe8e2fbd501636e1b7654666ac16733",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zap_leaf.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/zio.h>\n#include <sys/spa.h>\n#include <sys/dmu.h>\n#include <sys/zfs_context.h>\n#include <sys/fs/zfs.h>\n#include <sys/zap.h>\n#include <sys/zap_impl.h>\n#include <sys/zap_leaf.h>\n#include <sys/arc.h>\n\nstatic uint16_t *zap_leaf_rehash_entry(zap_leaf_t *l, uint16_t entry);\n\n#define\tCHAIN_END 0xffff  \n\n#define\tLEAF_HASH(l, h) \\\n\t((ZAP_LEAF_HASH_NUMENTRIES(l)-1) & \\\n\t((h) >> \\\n\t(64 - ZAP_LEAF_HASH_SHIFT(l) - zap_leaf_phys(l)->l_hdr.lh_prefix_len)))\n\n#define\tLEAF_HASH_ENTPTR(l, h)\t(&zap_leaf_phys(l)->l_hash[LEAF_HASH(l, h)])\n\nstatic void\nzap_memset(void *a, int c, size_t n)\n{\n\tchar *cp = a;\n\tchar *cpend = cp + n;\n\n\twhile (cp < cpend)\n\t\t*cp++ = c;\n}\n\nstatic void\nstv(int len, void *addr, uint64_t value)\n{\n\tswitch (len) {\n\tcase 1:\n\t\t*(uint8_t *)addr = value;\n\t\treturn;\n\tcase 2:\n\t\t*(uint16_t *)addr = value;\n\t\treturn;\n\tcase 4:\n\t\t*(uint32_t *)addr = value;\n\t\treturn;\n\tcase 8:\n\t\t*(uint64_t *)addr = value;\n\t\treturn;\n\tdefault:\n\t\tcmn_err(CE_PANIC, \"bad int len %d\", len);\n\t}\n}\n\nstatic uint64_t\nldv(int len, const void *addr)\n{\n\tswitch (len) {\n\tcase 1:\n\t\treturn (*(uint8_t *)addr);\n\tcase 2:\n\t\treturn (*(uint16_t *)addr);\n\tcase 4:\n\t\treturn (*(uint32_t *)addr);\n\tcase 8:\n\t\treturn (*(uint64_t *)addr);\n\tdefault:\n\t\tcmn_err(CE_PANIC, \"bad int len %d\", len);\n\t}\n\treturn (0xFEEDFACEDEADBEEFULL);\n}\n\nvoid\nzap_leaf_byteswap(zap_leaf_phys_t *buf, int size)\n{\n\tzap_leaf_t l;\n\tdmu_buf_t l_dbuf;\n\n\tl_dbuf.db_data = buf;\n\tl.l_bs = highbit64(size) - 1;\n\tl.l_dbuf = &l_dbuf;\n\n\tbuf->l_hdr.lh_block_type =\tBSWAP_64(buf->l_hdr.lh_block_type);\n\tbuf->l_hdr.lh_prefix =\t\tBSWAP_64(buf->l_hdr.lh_prefix);\n\tbuf->l_hdr.lh_magic =\t\tBSWAP_32(buf->l_hdr.lh_magic);\n\tbuf->l_hdr.lh_nfree =\t\tBSWAP_16(buf->l_hdr.lh_nfree);\n\tbuf->l_hdr.lh_nentries =\tBSWAP_16(buf->l_hdr.lh_nentries);\n\tbuf->l_hdr.lh_prefix_len =\tBSWAP_16(buf->l_hdr.lh_prefix_len);\n\tbuf->l_hdr.lh_freelist =\tBSWAP_16(buf->l_hdr.lh_freelist);\n\n\tfor (int i = 0; i < ZAP_LEAF_HASH_NUMENTRIES(&l); i++)\n\t\tbuf->l_hash[i] = BSWAP_16(buf->l_hash[i]);\n\n\tfor (int i = 0; i < ZAP_LEAF_NUMCHUNKS(&l); i++) {\n\t\tzap_leaf_chunk_t *lc = &ZAP_LEAF_CHUNK(&l, i);\n\t\tstruct zap_leaf_entry *le;\n\n\t\tswitch (lc->l_free.lf_type) {\n\t\tcase ZAP_CHUNK_ENTRY:\n\t\t\tle = &lc->l_entry;\n\n\t\t\tle->le_type =\t\tBSWAP_8(le->le_type);\n\t\t\tle->le_value_intlen =\tBSWAP_8(le->le_value_intlen);\n\t\t\tle->le_next =\t\tBSWAP_16(le->le_next);\n\t\t\tle->le_name_chunk =\tBSWAP_16(le->le_name_chunk);\n\t\t\tle->le_name_numints =\tBSWAP_16(le->le_name_numints);\n\t\t\tle->le_value_chunk =\tBSWAP_16(le->le_value_chunk);\n\t\t\tle->le_value_numints =\tBSWAP_16(le->le_value_numints);\n\t\t\tle->le_cd =\t\tBSWAP_32(le->le_cd);\n\t\t\tle->le_hash =\t\tBSWAP_64(le->le_hash);\n\t\t\tbreak;\n\t\tcase ZAP_CHUNK_FREE:\n\t\t\tlc->l_free.lf_type =\tBSWAP_8(lc->l_free.lf_type);\n\t\t\tlc->l_free.lf_next =\tBSWAP_16(lc->l_free.lf_next);\n\t\t\tbreak;\n\t\tcase ZAP_CHUNK_ARRAY:\n\t\t\tlc->l_array.la_type =\tBSWAP_8(lc->l_array.la_type);\n\t\t\tlc->l_array.la_next =\tBSWAP_16(lc->l_array.la_next);\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmn_err(CE_PANIC, \"bad leaf type %d\",\n\t\t\t    lc->l_free.lf_type);\n\t\t}\n\t}\n}\n\nvoid\nzap_leaf_init(zap_leaf_t *l, boolean_t sort)\n{\n\tl->l_bs = highbit64(l->l_dbuf->db_size) - 1;\n\tzap_memset(&zap_leaf_phys(l)->l_hdr, 0,\n\t    sizeof (struct zap_leaf_header));\n\tzap_memset(zap_leaf_phys(l)->l_hash, CHAIN_END,\n\t    2*ZAP_LEAF_HASH_NUMENTRIES(l));\n\tfor (int i = 0; i < ZAP_LEAF_NUMCHUNKS(l); i++) {\n\t\tZAP_LEAF_CHUNK(l, i).l_free.lf_type = ZAP_CHUNK_FREE;\n\t\tZAP_LEAF_CHUNK(l, i).l_free.lf_next = i+1;\n\t}\n\tZAP_LEAF_CHUNK(l, ZAP_LEAF_NUMCHUNKS(l)-1).l_free.lf_next = CHAIN_END;\n\tzap_leaf_phys(l)->l_hdr.lh_block_type = ZBT_LEAF;\n\tzap_leaf_phys(l)->l_hdr.lh_magic = ZAP_LEAF_MAGIC;\n\tzap_leaf_phys(l)->l_hdr.lh_nfree = ZAP_LEAF_NUMCHUNKS(l);\n\tif (sort)\n\t\tzap_leaf_phys(l)->l_hdr.lh_flags |= ZLF_ENTRIES_CDSORTED;\n}\n\n \n\nstatic uint16_t\nzap_leaf_chunk_alloc(zap_leaf_t *l)\n{\n\tASSERT(zap_leaf_phys(l)->l_hdr.lh_nfree > 0);\n\n\tint chunk = zap_leaf_phys(l)->l_hdr.lh_freelist;\n\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\tASSERT3U(ZAP_LEAF_CHUNK(l, chunk).l_free.lf_type, ==, ZAP_CHUNK_FREE);\n\n\tzap_leaf_phys(l)->l_hdr.lh_freelist =\n\t    ZAP_LEAF_CHUNK(l, chunk).l_free.lf_next;\n\n\tzap_leaf_phys(l)->l_hdr.lh_nfree--;\n\n\treturn (chunk);\n}\n\nstatic void\nzap_leaf_chunk_free(zap_leaf_t *l, uint16_t chunk)\n{\n\tstruct zap_leaf_free *zlf = &ZAP_LEAF_CHUNK(l, chunk).l_free;\n\tASSERT3U(zap_leaf_phys(l)->l_hdr.lh_nfree, <, ZAP_LEAF_NUMCHUNKS(l));\n\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\tASSERT(zlf->lf_type != ZAP_CHUNK_FREE);\n\n\tzlf->lf_type = ZAP_CHUNK_FREE;\n\tzlf->lf_next = zap_leaf_phys(l)->l_hdr.lh_freelist;\n\tmemset(zlf->lf_pad, 0, sizeof (zlf->lf_pad));  \n\tzap_leaf_phys(l)->l_hdr.lh_freelist = chunk;\n\n\tzap_leaf_phys(l)->l_hdr.lh_nfree++;\n}\n\n \n\nstatic uint16_t\nzap_leaf_array_create(zap_leaf_t *l, const char *buf,\n    int integer_size, int num_integers)\n{\n\tuint16_t chunk_head;\n\tuint16_t *chunkp = &chunk_head;\n\tint byten = 0;\n\tuint64_t value = 0;\n\tint shift = (integer_size - 1) * 8;\n\tint len = num_integers;\n\n\tASSERT3U(num_integers * integer_size, <=, ZAP_MAXVALUELEN);\n\n\twhile (len > 0) {\n\t\tuint16_t chunk = zap_leaf_chunk_alloc(l);\n\t\tstruct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;\n\n\t\tla->la_type = ZAP_CHUNK_ARRAY;\n\t\tfor (int i = 0; i < ZAP_LEAF_ARRAY_BYTES; i++) {\n\t\t\tif (byten == 0)\n\t\t\t\tvalue = ldv(integer_size, buf);\n\t\t\tla->la_array[i] = value >> shift;\n\t\t\tvalue <<= 8;\n\t\t\tif (++byten == integer_size) {\n\t\t\t\tbyten = 0;\n\t\t\t\tbuf += integer_size;\n\t\t\t\tif (--len == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*chunkp = chunk;\n\t\tchunkp = &la->la_next;\n\t}\n\t*chunkp = CHAIN_END;\n\n\treturn (chunk_head);\n}\n\nstatic void\nzap_leaf_array_free(zap_leaf_t *l, uint16_t *chunkp)\n{\n\tuint16_t chunk = *chunkp;\n\n\t*chunkp = CHAIN_END;\n\n\twhile (chunk != CHAIN_END) {\n\t\tint nextchunk = ZAP_LEAF_CHUNK(l, chunk).l_array.la_next;\n\t\tASSERT3U(ZAP_LEAF_CHUNK(l, chunk).l_array.la_type, ==,\n\t\t    ZAP_CHUNK_ARRAY);\n\t\tzap_leaf_chunk_free(l, chunk);\n\t\tchunk = nextchunk;\n\t}\n}\n\n \nstatic void\nzap_leaf_array_read(zap_leaf_t *l, uint16_t chunk,\n    int array_int_len, int array_len, int buf_int_len, uint64_t buf_len,\n    void *buf)\n{\n\tint len = MIN(array_len, buf_len);\n\tint byten = 0;\n\tuint64_t value = 0;\n\tchar *p = buf;\n\n\tASSERT3U(array_int_len, <=, buf_int_len);\n\n\t \n\tif (array_int_len == 8 && buf_int_len == 8 && len == 1) {\n\t\tstruct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;\n\t\tuint8_t *ip = la->la_array;\n\t\tuint64_t *buf64 = buf;\n\n\t\t*buf64 = (uint64_t)ip[0] << 56 | (uint64_t)ip[1] << 48 |\n\t\t    (uint64_t)ip[2] << 40 | (uint64_t)ip[3] << 32 |\n\t\t    (uint64_t)ip[4] << 24 | (uint64_t)ip[5] << 16 |\n\t\t    (uint64_t)ip[6] << 8 | (uint64_t)ip[7];\n\t\treturn;\n\t}\n\n\t \n\tif (array_int_len == 1 && buf_int_len == 1 &&\n\t    buf_len > array_len + ZAP_LEAF_ARRAY_BYTES) {\n\t\twhile (chunk != CHAIN_END) {\n\t\t\tstruct zap_leaf_array *la =\n\t\t\t    &ZAP_LEAF_CHUNK(l, chunk).l_array;\n\t\t\tmemcpy(p, la->la_array, ZAP_LEAF_ARRAY_BYTES);\n\t\t\tp += ZAP_LEAF_ARRAY_BYTES;\n\t\t\tchunk = la->la_next;\n\t\t}\n\t\treturn;\n\t}\n\n\twhile (len > 0) {\n\t\tstruct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;\n\n\t\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\t\tfor (int i = 0; i < ZAP_LEAF_ARRAY_BYTES; i++) {\n\t\t\tvalue = (value << 8) | la->la_array[i];\n\t\t\tbyten++;\n\t\t\tif (byten == array_int_len) {\n\t\t\t\tstv(buf_int_len, p, value);\n\t\t\t\tbyten = 0;\n\t\t\t\tlen--;\n\t\t\t\tif (len == 0)\n\t\t\t\t\treturn;\n\t\t\t\tp += buf_int_len;\n\t\t\t}\n\t\t}\n\t\tchunk = la->la_next;\n\t}\n}\n\nstatic boolean_t\nzap_leaf_array_match(zap_leaf_t *l, zap_name_t *zn,\n    int chunk, int array_numints)\n{\n\tint bseen = 0;\n\n\tif (zap_getflags(zn->zn_zap) & ZAP_FLAG_UINT64_KEY) {\n\t\tuint64_t *thiskey =\n\t\t    kmem_alloc(array_numints * sizeof (*thiskey), KM_SLEEP);\n\t\tASSERT(zn->zn_key_intlen == sizeof (*thiskey));\n\n\t\tzap_leaf_array_read(l, chunk, sizeof (*thiskey), array_numints,\n\t\t    sizeof (*thiskey), array_numints, thiskey);\n\t\tboolean_t match = memcmp(thiskey, zn->zn_key_orig,\n\t\t    array_numints * sizeof (*thiskey)) == 0;\n\t\tkmem_free(thiskey, array_numints * sizeof (*thiskey));\n\t\treturn (match);\n\t}\n\n\tASSERT(zn->zn_key_intlen == 1);\n\tif (zn->zn_matchtype & MT_NORMALIZE) {\n\t\tchar *thisname = kmem_alloc(array_numints, KM_SLEEP);\n\n\t\tzap_leaf_array_read(l, chunk, sizeof (char), array_numints,\n\t\t    sizeof (char), array_numints, thisname);\n\t\tboolean_t match = zap_match(zn, thisname);\n\t\tkmem_free(thisname, array_numints);\n\t\treturn (match);\n\t}\n\n\t \n\tif (array_numints != zn->zn_key_orig_numints)\n\t\treturn (B_FALSE);\n\twhile (bseen < array_numints) {\n\t\tstruct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;\n\t\tint toread = MIN(array_numints - bseen, ZAP_LEAF_ARRAY_BYTES);\n\t\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\t\tif (memcmp(la->la_array, (char *)zn->zn_key_orig + bseen,\n\t\t    toread))\n\t\t\tbreak;\n\t\tchunk = la->la_next;\n\t\tbseen += toread;\n\t}\n\treturn (bseen == array_numints);\n}\n\n \n\nint\nzap_leaf_lookup(zap_leaf_t *l, zap_name_t *zn, zap_entry_handle_t *zeh)\n{\n\tstruct zap_leaf_entry *le;\n\n\tASSERT3U(zap_leaf_phys(l)->l_hdr.lh_magic, ==, ZAP_LEAF_MAGIC);\n\n\tfor (uint16_t *chunkp = LEAF_HASH_ENTPTR(l, zn->zn_hash);\n\t    *chunkp != CHAIN_END; chunkp = &le->le_next) {\n\t\tuint16_t chunk = *chunkp;\n\t\tle = ZAP_LEAF_ENTRY(l, chunk);\n\n\t\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\t\tASSERT3U(le->le_type, ==, ZAP_CHUNK_ENTRY);\n\n\t\tif (le->le_hash != zn->zn_hash)\n\t\t\tcontinue;\n\n\t\t \n\t\tASSERT((zn->zn_matchtype == 0) ||\n\t\t    (zap_leaf_phys(l)->l_hdr.lh_flags & ZLF_ENTRIES_CDSORTED));\n\t\tif (zap_leaf_array_match(l, zn, le->le_name_chunk,\n\t\t    le->le_name_numints)) {\n\t\t\tzeh->zeh_num_integers = le->le_value_numints;\n\t\t\tzeh->zeh_integer_size = le->le_value_intlen;\n\t\t\tzeh->zeh_cd = le->le_cd;\n\t\t\tzeh->zeh_hash = le->le_hash;\n\t\t\tzeh->zeh_chunkp = chunkp;\n\t\t\tzeh->zeh_leaf = l;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (SET_ERROR(ENOENT));\n}\n\n \n#define\tHCD_GTEQ(h1, cd1, h2, cd2) \\\n\t((h1 > h2) ? TRUE : ((h1 == h2 && cd1 >= cd2) ? TRUE : FALSE))\n\nint\nzap_leaf_lookup_closest(zap_leaf_t *l,\n    uint64_t h, uint32_t cd, zap_entry_handle_t *zeh)\n{\n\tuint64_t besth = -1ULL;\n\tuint32_t bestcd = -1U;\n\tuint16_t bestlh = ZAP_LEAF_HASH_NUMENTRIES(l)-1;\n\tstruct zap_leaf_entry *le;\n\n\tASSERT3U(zap_leaf_phys(l)->l_hdr.lh_magic, ==, ZAP_LEAF_MAGIC);\n\n\tfor (uint16_t lh = LEAF_HASH(l, h); lh <= bestlh; lh++) {\n\t\tfor (uint16_t chunk = zap_leaf_phys(l)->l_hash[lh];\n\t\t    chunk != CHAIN_END; chunk = le->le_next) {\n\t\t\tle = ZAP_LEAF_ENTRY(l, chunk);\n\n\t\t\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\t\t\tASSERT3U(le->le_type, ==, ZAP_CHUNK_ENTRY);\n\n\t\t\tif (HCD_GTEQ(le->le_hash, le->le_cd, h, cd) &&\n\t\t\t    HCD_GTEQ(besth, bestcd, le->le_hash, le->le_cd)) {\n\t\t\t\tASSERT3U(bestlh, >=, lh);\n\t\t\t\tbestlh = lh;\n\t\t\t\tbesth = le->le_hash;\n\t\t\t\tbestcd = le->le_cd;\n\n\t\t\t\tzeh->zeh_num_integers = le->le_value_numints;\n\t\t\t\tzeh->zeh_integer_size = le->le_value_intlen;\n\t\t\t\tzeh->zeh_cd = le->le_cd;\n\t\t\t\tzeh->zeh_hash = le->le_hash;\n\t\t\t\tzeh->zeh_fakechunk = chunk;\n\t\t\t\tzeh->zeh_chunkp = &zeh->zeh_fakechunk;\n\t\t\t\tzeh->zeh_leaf = l;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (bestcd == -1U ? SET_ERROR(ENOENT) : 0);\n}\n\nint\nzap_entry_read(const zap_entry_handle_t *zeh,\n    uint8_t integer_size, uint64_t num_integers, void *buf)\n{\n\tstruct zap_leaf_entry *le =\n\t    ZAP_LEAF_ENTRY(zeh->zeh_leaf, *zeh->zeh_chunkp);\n\tASSERT3U(le->le_type, ==, ZAP_CHUNK_ENTRY);\n\n\tif (le->le_value_intlen > integer_size)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzap_leaf_array_read(zeh->zeh_leaf, le->le_value_chunk,\n\t    le->le_value_intlen, le->le_value_numints,\n\t    integer_size, num_integers, buf);\n\n\tif (zeh->zeh_num_integers > num_integers)\n\t\treturn (SET_ERROR(EOVERFLOW));\n\treturn (0);\n\n}\n\nint\nzap_entry_read_name(zap_t *zap, const zap_entry_handle_t *zeh, uint16_t buflen,\n    char *buf)\n{\n\tstruct zap_leaf_entry *le =\n\t    ZAP_LEAF_ENTRY(zeh->zeh_leaf, *zeh->zeh_chunkp);\n\tASSERT3U(le->le_type, ==, ZAP_CHUNK_ENTRY);\n\n\tif (zap_getflags(zap) & ZAP_FLAG_UINT64_KEY) {\n\t\tzap_leaf_array_read(zeh->zeh_leaf, le->le_name_chunk, 8,\n\t\t    le->le_name_numints, 8, buflen / 8, buf);\n\t} else {\n\t\tzap_leaf_array_read(zeh->zeh_leaf, le->le_name_chunk, 1,\n\t\t    le->le_name_numints, 1, buflen, buf);\n\t}\n\tif (le->le_name_numints > buflen)\n\t\treturn (SET_ERROR(EOVERFLOW));\n\treturn (0);\n}\n\nint\nzap_entry_update(zap_entry_handle_t *zeh,\n    uint8_t integer_size, uint64_t num_integers, const void *buf)\n{\n\tzap_leaf_t *l = zeh->zeh_leaf;\n\tstruct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, *zeh->zeh_chunkp);\n\n\tint delta_chunks = ZAP_LEAF_ARRAY_NCHUNKS(num_integers * integer_size) -\n\t    ZAP_LEAF_ARRAY_NCHUNKS(le->le_value_numints * le->le_value_intlen);\n\n\tif ((int)zap_leaf_phys(l)->l_hdr.lh_nfree < delta_chunks)\n\t\treturn (SET_ERROR(EAGAIN));\n\n\tzap_leaf_array_free(l, &le->le_value_chunk);\n\tle->le_value_chunk =\n\t    zap_leaf_array_create(l, buf, integer_size, num_integers);\n\tle->le_value_numints = num_integers;\n\tle->le_value_intlen = integer_size;\n\treturn (0);\n}\n\nvoid\nzap_entry_remove(zap_entry_handle_t *zeh)\n{\n\tzap_leaf_t *l = zeh->zeh_leaf;\n\n\tASSERT3P(zeh->zeh_chunkp, !=, &zeh->zeh_fakechunk);\n\n\tuint16_t entry_chunk = *zeh->zeh_chunkp;\n\tstruct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, entry_chunk);\n\tASSERT3U(le->le_type, ==, ZAP_CHUNK_ENTRY);\n\n\tzap_leaf_array_free(l, &le->le_name_chunk);\n\tzap_leaf_array_free(l, &le->le_value_chunk);\n\n\t*zeh->zeh_chunkp = le->le_next;\n\tzap_leaf_chunk_free(l, entry_chunk);\n\n\tzap_leaf_phys(l)->l_hdr.lh_nentries--;\n}\n\nint\nzap_entry_create(zap_leaf_t *l, zap_name_t *zn, uint32_t cd,\n    uint8_t integer_size, uint64_t num_integers, const void *buf,\n    zap_entry_handle_t *zeh)\n{\n\tuint16_t chunk;\n\tstruct zap_leaf_entry *le;\n\tuint64_t h = zn->zn_hash;\n\n\tuint64_t valuelen = integer_size * num_integers;\n\n\tint numchunks = 1 + ZAP_LEAF_ARRAY_NCHUNKS(zn->zn_key_orig_numints *\n\t    zn->zn_key_intlen) + ZAP_LEAF_ARRAY_NCHUNKS(valuelen);\n\tif (numchunks > ZAP_LEAF_NUMCHUNKS(l))\n\t\treturn (SET_ERROR(E2BIG));\n\n\tif (cd == ZAP_NEED_CD) {\n\t\t \n\t\tif (zap_leaf_phys(l)->l_hdr.lh_flags & ZLF_ENTRIES_CDSORTED) {\n\t\t\tcd = 0;\n\n\t\t\tfor (chunk = *LEAF_HASH_ENTPTR(l, h);\n\t\t\t    chunk != CHAIN_END; chunk = le->le_next) {\n\t\t\t\tle = ZAP_LEAF_ENTRY(l, chunk);\n\t\t\t\tif (le->le_cd > cd)\n\t\t\t\t\tbreak;\n\t\t\t\tif (le->le_hash == h) {\n\t\t\t\t\tASSERT3U(cd, ==, le->le_cd);\n\t\t\t\t\tcd++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tfor (cd = 0; ; cd++) {\n\t\t\t\tfor (chunk = *LEAF_HASH_ENTPTR(l, h);\n\t\t\t\t    chunk != CHAIN_END; chunk = le->le_next) {\n\t\t\t\t\tle = ZAP_LEAF_ENTRY(l, chunk);\n\t\t\t\t\tif (le->le_hash == h &&\n\t\t\t\t\t    le->le_cd == cd) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (chunk == CHAIN_END)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tASSERT3U(cd, <, zap_maxcd(zn->zn_zap));\n\t}\n\n\tif (zap_leaf_phys(l)->l_hdr.lh_nfree < numchunks)\n\t\treturn (SET_ERROR(EAGAIN));\n\n\t \n\tchunk = zap_leaf_chunk_alloc(l);\n\tle = ZAP_LEAF_ENTRY(l, chunk);\n\tle->le_type = ZAP_CHUNK_ENTRY;\n\tle->le_name_chunk = zap_leaf_array_create(l, zn->zn_key_orig,\n\t    zn->zn_key_intlen, zn->zn_key_orig_numints);\n\tle->le_name_numints = zn->zn_key_orig_numints;\n\tle->le_value_chunk =\n\t    zap_leaf_array_create(l, buf, integer_size, num_integers);\n\tle->le_value_numints = num_integers;\n\tle->le_value_intlen = integer_size;\n\tle->le_hash = h;\n\tle->le_cd = cd;\n\n\t \n\t \n\tuint16_t *chunkp = zap_leaf_rehash_entry(l, chunk);\n\n\tzap_leaf_phys(l)->l_hdr.lh_nentries++;\n\n\tzeh->zeh_leaf = l;\n\tzeh->zeh_num_integers = num_integers;\n\tzeh->zeh_integer_size = le->le_value_intlen;\n\tzeh->zeh_cd = le->le_cd;\n\tzeh->zeh_hash = le->le_hash;\n\tzeh->zeh_chunkp = chunkp;\n\n\treturn (0);\n}\n\n \nboolean_t\nzap_entry_normalization_conflict(zap_entry_handle_t *zeh, zap_name_t *zn,\n    const char *name, zap_t *zap)\n{\n\tstruct zap_leaf_entry *le;\n\tboolean_t allocdzn = B_FALSE;\n\n\tif (zap->zap_normflags == 0)\n\t\treturn (B_FALSE);\n\n\tfor (uint16_t chunk = *LEAF_HASH_ENTPTR(zeh->zeh_leaf, zeh->zeh_hash);\n\t    chunk != CHAIN_END; chunk = le->le_next) {\n\t\tle = ZAP_LEAF_ENTRY(zeh->zeh_leaf, chunk);\n\t\tif (le->le_hash != zeh->zeh_hash)\n\t\t\tcontinue;\n\t\tif (le->le_cd == zeh->zeh_cd)\n\t\t\tcontinue;\n\n\t\tif (zn == NULL) {\n\t\t\tzn = zap_name_alloc_str(zap, name, MT_NORMALIZE);\n\t\t\tallocdzn = B_TRUE;\n\t\t}\n\t\tif (zap_leaf_array_match(zeh->zeh_leaf, zn,\n\t\t    le->le_name_chunk, le->le_name_numints)) {\n\t\t\tif (allocdzn)\n\t\t\t\tzap_name_free(zn);\n\t\t\treturn (B_TRUE);\n\t\t}\n\t}\n\tif (allocdzn)\n\t\tzap_name_free(zn);\n\treturn (B_FALSE);\n}\n\n \n\nstatic uint16_t *\nzap_leaf_rehash_entry(zap_leaf_t *l, uint16_t entry)\n{\n\tstruct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, entry);\n\tstruct zap_leaf_entry *le2;\n\tuint16_t *chunkp;\n\n\t \n\tfor (chunkp = LEAF_HASH_ENTPTR(l, le->le_hash);\n\t    *chunkp != CHAIN_END; chunkp = &le2->le_next) {\n\t\tle2 = ZAP_LEAF_ENTRY(l, *chunkp);\n\t\tif (le2->le_cd > le->le_cd)\n\t\t\tbreak;\n\t}\n\n\tle->le_next = *chunkp;\n\t*chunkp = entry;\n\treturn (chunkp);\n}\n\nstatic uint16_t\nzap_leaf_transfer_array(zap_leaf_t *l, uint16_t chunk, zap_leaf_t *nl)\n{\n\tuint16_t new_chunk;\n\tuint16_t *nchunkp = &new_chunk;\n\n\twhile (chunk != CHAIN_END) {\n\t\tuint16_t nchunk = zap_leaf_chunk_alloc(nl);\n\t\tstruct zap_leaf_array *nla =\n\t\t    &ZAP_LEAF_CHUNK(nl, nchunk).l_array;\n\t\tstruct zap_leaf_array *la =\n\t\t    &ZAP_LEAF_CHUNK(l, chunk).l_array;\n\t\tint nextchunk = la->la_next;\n\n\t\tASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\t\tASSERT3U(nchunk, <, ZAP_LEAF_NUMCHUNKS(l));\n\n\t\t*nla = *la;  \n\n\t\tzap_leaf_chunk_free(l, chunk);\n\t\tchunk = nextchunk;\n\t\t*nchunkp = nchunk;\n\t\tnchunkp = &nla->la_next;\n\t}\n\t*nchunkp = CHAIN_END;\n\treturn (new_chunk);\n}\n\nstatic void\nzap_leaf_transfer_entry(zap_leaf_t *l, int entry, zap_leaf_t *nl)\n{\n\tstruct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, entry);\n\tASSERT3U(le->le_type, ==, ZAP_CHUNK_ENTRY);\n\n\tuint16_t chunk = zap_leaf_chunk_alloc(nl);\n\tstruct zap_leaf_entry *nle = ZAP_LEAF_ENTRY(nl, chunk);\n\t*nle = *le;  \n\n\t(void) zap_leaf_rehash_entry(nl, chunk);\n\n\tnle->le_name_chunk = zap_leaf_transfer_array(l, le->le_name_chunk, nl);\n\tnle->le_value_chunk =\n\t    zap_leaf_transfer_array(l, le->le_value_chunk, nl);\n\n\tzap_leaf_chunk_free(l, entry);\n\n\tzap_leaf_phys(l)->l_hdr.lh_nentries--;\n\tzap_leaf_phys(nl)->l_hdr.lh_nentries++;\n}\n\n \nvoid\nzap_leaf_split(zap_leaf_t *l, zap_leaf_t *nl, boolean_t sort)\n{\n\tint bit = 64 - 1 - zap_leaf_phys(l)->l_hdr.lh_prefix_len;\n\n\t \n\tzap_leaf_phys(l)->l_hdr.lh_prefix <<= 1;\n\tzap_leaf_phys(l)->l_hdr.lh_prefix_len++;\n\tzap_leaf_phys(nl)->l_hdr.lh_prefix =\n\t    zap_leaf_phys(l)->l_hdr.lh_prefix | 1;\n\tzap_leaf_phys(nl)->l_hdr.lh_prefix_len =\n\t    zap_leaf_phys(l)->l_hdr.lh_prefix_len;\n\n\t \n\tzap_memset(zap_leaf_phys(l)->l_hash, CHAIN_END,\n\t    2*ZAP_LEAF_HASH_NUMENTRIES(l));\n\n\tif (sort)\n\t\tzap_leaf_phys(l)->l_hdr.lh_flags |= ZLF_ENTRIES_CDSORTED;\n\n\t \n\tfor (int i = 0; i < ZAP_LEAF_NUMCHUNKS(l); i++) {\n\t\tstruct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, i);\n\t\tif (le->le_type != ZAP_CHUNK_ENTRY)\n\t\t\tcontinue;\n\n\t\tif (le->le_hash & (1ULL << bit))\n\t\t\tzap_leaf_transfer_entry(l, i, nl);\n\t\telse\n\t\t\t(void) zap_leaf_rehash_entry(l, i);\n\t}\n}\n\nvoid\nzap_leaf_stats(zap_t *zap, zap_leaf_t *l, zap_stats_t *zs)\n{\n\tint n = zap_f_phys(zap)->zap_ptrtbl.zt_shift -\n\t    zap_leaf_phys(l)->l_hdr.lh_prefix_len;\n\tn = MIN(n, ZAP_HISTOGRAM_SIZE-1);\n\tzs->zs_leafs_with_2n_pointers[n]++;\n\n\n\tn = zap_leaf_phys(l)->l_hdr.lh_nentries/5;\n\tn = MIN(n, ZAP_HISTOGRAM_SIZE-1);\n\tzs->zs_blocks_with_n5_entries[n]++;\n\n\tn = ((1<<FZAP_BLOCK_SHIFT(zap)) -\n\t    zap_leaf_phys(l)->l_hdr.lh_nfree * (ZAP_LEAF_ARRAY_BYTES+1))*10 /\n\t    (1<<FZAP_BLOCK_SHIFT(zap));\n\tn = MIN(n, ZAP_HISTOGRAM_SIZE-1);\n\tzs->zs_blocks_n_tenths_full[n]++;\n\n\tfor (int i = 0; i < ZAP_LEAF_HASH_NUMENTRIES(l); i++) {\n\t\tint nentries = 0;\n\t\tint chunk = zap_leaf_phys(l)->l_hash[i];\n\n\t\twhile (chunk != CHAIN_END) {\n\t\t\tstruct zap_leaf_entry *le =\n\t\t\t    ZAP_LEAF_ENTRY(l, chunk);\n\n\t\t\tn = 1 + ZAP_LEAF_ARRAY_NCHUNKS(le->le_name_numints) +\n\t\t\t    ZAP_LEAF_ARRAY_NCHUNKS(le->le_value_numints *\n\t\t\t    le->le_value_intlen);\n\t\t\tn = MIN(n, ZAP_HISTOGRAM_SIZE-1);\n\t\t\tzs->zs_entries_using_n_chunks[n]++;\n\n\t\t\tchunk = le->le_next;\n\t\t\tnentries++;\n\t\t}\n\n\t\tn = nentries;\n\t\tn = MIN(n, ZAP_HISTOGRAM_SIZE-1);\n\t\tzs->zs_buckets_with_n_entries[n]++;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}