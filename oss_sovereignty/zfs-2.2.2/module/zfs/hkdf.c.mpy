{
  "module_name": "hkdf.c",
  "hash_id": "6c3a7ecdc3e71788aeabec92540e2e3ce10469d3ced7d2a00628c8702a2da256",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/hkdf.c",
  "human_readable_source": " \n\n \n\n#include <sys/crypto/api.h>\n#include <sys/sha2.h>\n#include <sys/hkdf.h>\n\nstatic int\nhkdf_sha512_extract(uint8_t *salt, uint_t salt_len, uint8_t *key_material,\n    uint_t km_len, uint8_t *out_buf)\n{\n\tint ret;\n\tcrypto_mechanism_t mech;\n\tcrypto_key_t key;\n\tcrypto_data_t input_cd, output_cd;\n\n\t \n\tmech.cm_type = crypto_mech2id(SUN_CKM_SHA512_HMAC);\n\tmech.cm_param = NULL;\n\tmech.cm_param_len = 0;\n\n\t \n\tkey.ck_length = CRYPTO_BYTES2BITS(salt_len);\n\tkey.ck_data = salt;\n\n\t \n\tinput_cd.cd_format = CRYPTO_DATA_RAW;\n\tinput_cd.cd_offset = 0;\n\tinput_cd.cd_length = km_len;\n\tinput_cd.cd_raw.iov_base = (char *)key_material;\n\tinput_cd.cd_raw.iov_len = input_cd.cd_length;\n\n\toutput_cd.cd_format = CRYPTO_DATA_RAW;\n\toutput_cd.cd_offset = 0;\n\toutput_cd.cd_length = SHA512_DIGEST_LENGTH;\n\toutput_cd.cd_raw.iov_base = (char *)out_buf;\n\toutput_cd.cd_raw.iov_len = output_cd.cd_length;\n\n\tret = crypto_mac(&mech, &input_cd, &key, NULL, &output_cd);\n\tif (ret != CRYPTO_SUCCESS)\n\t\treturn (SET_ERROR(EIO));\n\n\treturn (0);\n}\n\nstatic int\nhkdf_sha512_expand(uint8_t *extract_key, uint8_t *info, uint_t info_len,\n    uint8_t *out_buf, uint_t out_len)\n{\n\tint ret;\n\tcrypto_mechanism_t mech;\n\tcrypto_context_t ctx;\n\tcrypto_key_t key;\n\tcrypto_data_t T_cd, info_cd, c_cd;\n\tuint_t i, T_len = 0, pos = 0;\n\tuint8_t c;\n\tuint_t N = (out_len + SHA512_DIGEST_LENGTH) / SHA512_DIGEST_LENGTH;\n\tuint8_t T[SHA512_DIGEST_LENGTH];\n\n\tif (N > 255)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tmech.cm_type = crypto_mech2id(SUN_CKM_SHA512_HMAC);\n\tmech.cm_param = NULL;\n\tmech.cm_param_len = 0;\n\n\t \n\tkey.ck_length = CRYPTO_BYTES2BITS(SHA512_DIGEST_LENGTH);\n\tkey.ck_data = extract_key;\n\n\t \n\tT_cd.cd_format = CRYPTO_DATA_RAW;\n\tT_cd.cd_offset = 0;\n\tT_cd.cd_raw.iov_base = (char *)T;\n\n\tc_cd.cd_format = CRYPTO_DATA_RAW;\n\tc_cd.cd_offset = 0;\n\tc_cd.cd_length = 1;\n\tc_cd.cd_raw.iov_base = (char *)&c;\n\tc_cd.cd_raw.iov_len = c_cd.cd_length;\n\n\tinfo_cd.cd_format = CRYPTO_DATA_RAW;\n\tinfo_cd.cd_offset = 0;\n\tinfo_cd.cd_length = info_len;\n\tinfo_cd.cd_raw.iov_base = (char *)info;\n\tinfo_cd.cd_raw.iov_len = info_cd.cd_length;\n\n\tfor (i = 1; i <= N; i++) {\n\t\tc = i;\n\n\t\tT_cd.cd_length = T_len;\n\t\tT_cd.cd_raw.iov_len = T_cd.cd_length;\n\n\t\tret = crypto_mac_init(&mech, &key, NULL, &ctx);\n\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\treturn (SET_ERROR(EIO));\n\n\t\tret = crypto_mac_update(ctx, &T_cd);\n\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\treturn (SET_ERROR(EIO));\n\n\t\tret = crypto_mac_update(ctx, &info_cd);\n\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\treturn (SET_ERROR(EIO));\n\n\t\tret = crypto_mac_update(ctx, &c_cd);\n\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\treturn (SET_ERROR(EIO));\n\n\t\tT_len = SHA512_DIGEST_LENGTH;\n\t\tT_cd.cd_length = T_len;\n\t\tT_cd.cd_raw.iov_len = T_cd.cd_length;\n\n\t\tret = crypto_mac_final(ctx, &T_cd);\n\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\treturn (SET_ERROR(EIO));\n\n\t\tmemcpy(out_buf + pos, T,\n\t\t    (i != N) ? SHA512_DIGEST_LENGTH : (out_len - pos));\n\t\tpos += SHA512_DIGEST_LENGTH;\n\t}\n\n\treturn (0);\n}\n\n \nint\nhkdf_sha512(uint8_t *key_material, uint_t km_len, uint8_t *salt,\n    uint_t salt_len, uint8_t *info, uint_t info_len, uint8_t *output_key,\n    uint_t out_len)\n{\n\tint ret;\n\tuint8_t extract_key[SHA512_DIGEST_LENGTH];\n\n\tret = hkdf_sha512_extract(salt, salt_len, key_material, km_len,\n\t    extract_key);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tret = hkdf_sha512_expand(extract_key, info, info_len, output_key,\n\t    out_len);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}