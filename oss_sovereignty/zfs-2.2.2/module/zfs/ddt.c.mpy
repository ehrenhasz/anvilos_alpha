{
  "module_name": "ddt.c",
  "hash_id": "949151c56fa1ba7d8ae10f0699b7c36ecd6910b20dee7b8b46645ea674849dd7",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/ddt.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zio.h>\n#include <sys/ddt.h>\n#include <sys/zap.h>\n#include <sys/dmu_tx.h>\n#include <sys/arc.h>\n#include <sys/dsl_pool.h>\n#include <sys/zio_checksum.h>\n#include <sys/zio_compress.h>\n#include <sys/dsl_scan.h>\n#include <sys/abd.h>\n\nstatic kmem_cache_t *ddt_cache;\nstatic kmem_cache_t *ddt_entry_cache;\n\n \nint zfs_dedup_prefetch = 0;\n\nstatic const ddt_ops_t *const ddt_ops[DDT_TYPES] = {\n\t&ddt_zap_ops,\n};\n\nstatic const char *const ddt_class_name[DDT_CLASSES] = {\n\t\"ditto\",\n\t\"duplicate\",\n\t\"unique\",\n};\n\nstatic void\nddt_object_create(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    dmu_tx_t *tx)\n{\n\tspa_t *spa = ddt->ddt_spa;\n\tobjset_t *os = ddt->ddt_os;\n\tuint64_t *objectp = &ddt->ddt_object[type][class];\n\tboolean_t prehash = zio_checksum_table[ddt->ddt_checksum].ci_flags &\n\t    ZCHECKSUM_FLAG_DEDUP;\n\tchar name[DDT_NAMELEN];\n\n\tddt_object_name(ddt, type, class, name);\n\n\tASSERT(*objectp == 0);\n\tVERIFY(ddt_ops[type]->ddt_op_create(os, objectp, tx, prehash) == 0);\n\tASSERT(*objectp != 0);\n\n\tVERIFY(zap_add(os, DMU_POOL_DIRECTORY_OBJECT, name,\n\t    sizeof (uint64_t), 1, objectp, tx) == 0);\n\n\tVERIFY(zap_add(os, spa->spa_ddt_stat_object, name,\n\t    sizeof (uint64_t), sizeof (ddt_histogram_t) / sizeof (uint64_t),\n\t    &ddt->ddt_histogram[type][class], tx) == 0);\n}\n\nstatic void\nddt_object_destroy(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    dmu_tx_t *tx)\n{\n\tspa_t *spa = ddt->ddt_spa;\n\tobjset_t *os = ddt->ddt_os;\n\tuint64_t *objectp = &ddt->ddt_object[type][class];\n\tuint64_t count;\n\tchar name[DDT_NAMELEN];\n\n\tddt_object_name(ddt, type, class, name);\n\n\tASSERT(*objectp != 0);\n\tASSERT(ddt_histogram_empty(&ddt->ddt_histogram[type][class]));\n\tVERIFY(ddt_object_count(ddt, type, class, &count) == 0 && count == 0);\n\tVERIFY(zap_remove(os, DMU_POOL_DIRECTORY_OBJECT, name, tx) == 0);\n\tVERIFY(zap_remove(os, spa->spa_ddt_stat_object, name, tx) == 0);\n\tVERIFY(ddt_ops[type]->ddt_op_destroy(os, *objectp, tx) == 0);\n\tmemset(&ddt->ddt_object_stats[type][class], 0, sizeof (ddt_object_t));\n\n\t*objectp = 0;\n}\n\nstatic int\nddt_object_load(ddt_t *ddt, enum ddt_type type, enum ddt_class class)\n{\n\tddt_object_t *ddo = &ddt->ddt_object_stats[type][class];\n\tdmu_object_info_t doi;\n\tuint64_t count;\n\tchar name[DDT_NAMELEN];\n\tint error;\n\n\tddt_object_name(ddt, type, class, name);\n\n\terror = zap_lookup(ddt->ddt_os, DMU_POOL_DIRECTORY_OBJECT, name,\n\t    sizeof (uint64_t), 1, &ddt->ddt_object[type][class]);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(ddt->ddt_os, ddt->ddt_spa->spa_ddt_stat_object, name,\n\t    sizeof (uint64_t), sizeof (ddt_histogram_t) / sizeof (uint64_t),\n\t    &ddt->ddt_histogram[type][class]);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n\terror = ddt_object_info(ddt, type, class, &doi);\n\tif (error)\n\t\treturn (error);\n\n\terror = ddt_object_count(ddt, type, class, &count);\n\tif (error)\n\t\treturn (error);\n\n\tddo->ddo_count = count;\n\tddo->ddo_dspace = doi.doi_physical_blocks_512 << 9;\n\tddo->ddo_mspace = doi.doi_fill_count * doi.doi_data_block_size;\n\n\treturn (0);\n}\n\nstatic void\nddt_object_sync(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    dmu_tx_t *tx)\n{\n\tddt_object_t *ddo = &ddt->ddt_object_stats[type][class];\n\tdmu_object_info_t doi;\n\tuint64_t count;\n\tchar name[DDT_NAMELEN];\n\n\tddt_object_name(ddt, type, class, name);\n\n\tVERIFY(zap_update(ddt->ddt_os, ddt->ddt_spa->spa_ddt_stat_object, name,\n\t    sizeof (uint64_t), sizeof (ddt_histogram_t) / sizeof (uint64_t),\n\t    &ddt->ddt_histogram[type][class], tx) == 0);\n\n\t \n\tVERIFY(ddt_object_info(ddt, type, class, &doi) == 0);\n\tVERIFY(ddt_object_count(ddt, type, class, &count) == 0);\n\n\tddo->ddo_count = count;\n\tddo->ddo_dspace = doi.doi_physical_blocks_512 << 9;\n\tddo->ddo_mspace = doi.doi_fill_count * doi.doi_data_block_size;\n}\n\nstatic int\nddt_object_lookup(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    ddt_entry_t *dde)\n{\n\tif (!ddt_object_exists(ddt, type, class))\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (ddt_ops[type]->ddt_op_lookup(ddt->ddt_os,\n\t    ddt->ddt_object[type][class], dde));\n}\n\nstatic void\nddt_object_prefetch(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    ddt_entry_t *dde)\n{\n\tif (!ddt_object_exists(ddt, type, class))\n\t\treturn;\n\n\tddt_ops[type]->ddt_op_prefetch(ddt->ddt_os,\n\t    ddt->ddt_object[type][class], dde);\n}\n\nint\nddt_object_update(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    ddt_entry_t *dde, dmu_tx_t *tx)\n{\n\tASSERT(ddt_object_exists(ddt, type, class));\n\n\treturn (ddt_ops[type]->ddt_op_update(ddt->ddt_os,\n\t    ddt->ddt_object[type][class], dde, tx));\n}\n\nstatic int\nddt_object_remove(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    ddt_entry_t *dde, dmu_tx_t *tx)\n{\n\tASSERT(ddt_object_exists(ddt, type, class));\n\n\treturn (ddt_ops[type]->ddt_op_remove(ddt->ddt_os,\n\t    ddt->ddt_object[type][class], dde, tx));\n}\n\nint\nddt_object_walk(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    uint64_t *walk, ddt_entry_t *dde)\n{\n\tASSERT(ddt_object_exists(ddt, type, class));\n\n\treturn (ddt_ops[type]->ddt_op_walk(ddt->ddt_os,\n\t    ddt->ddt_object[type][class], dde, walk));\n}\n\nint\nddt_object_count(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    uint64_t *count)\n{\n\tASSERT(ddt_object_exists(ddt, type, class));\n\n\treturn (ddt_ops[type]->ddt_op_count(ddt->ddt_os,\n\t    ddt->ddt_object[type][class], count));\n}\n\nint\nddt_object_info(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    dmu_object_info_t *doi)\n{\n\tif (!ddt_object_exists(ddt, type, class))\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (dmu_object_info(ddt->ddt_os, ddt->ddt_object[type][class],\n\t    doi));\n}\n\nboolean_t\nddt_object_exists(ddt_t *ddt, enum ddt_type type, enum ddt_class class)\n{\n\treturn (!!ddt->ddt_object[type][class]);\n}\n\nvoid\nddt_object_name(ddt_t *ddt, enum ddt_type type, enum ddt_class class,\n    char *name)\n{\n\t(void) snprintf(name, DDT_NAMELEN, DMU_POOL_DDT,\n\t    zio_checksum_table[ddt->ddt_checksum].ci_name,\n\t    ddt_ops[type]->ddt_op_name, ddt_class_name[class]);\n}\n\nvoid\nddt_bp_fill(const ddt_phys_t *ddp, blkptr_t *bp, uint64_t txg)\n{\n\tASSERT(txg != 0);\n\n\tfor (int d = 0; d < SPA_DVAS_PER_BP; d++)\n\t\tbp->blk_dva[d] = ddp->ddp_dva[d];\n\tBP_SET_BIRTH(bp, txg, ddp->ddp_phys_birth);\n}\n\n \nvoid\nddt_bp_create(enum zio_checksum checksum,\n    const ddt_key_t *ddk, const ddt_phys_t *ddp, blkptr_t *bp)\n{\n\tBP_ZERO(bp);\n\n\tif (ddp != NULL)\n\t\tddt_bp_fill(ddp, bp, ddp->ddp_phys_birth);\n\n\tbp->blk_cksum = ddk->ddk_cksum;\n\n\tBP_SET_LSIZE(bp, DDK_GET_LSIZE(ddk));\n\tBP_SET_PSIZE(bp, DDK_GET_PSIZE(ddk));\n\tBP_SET_COMPRESS(bp, DDK_GET_COMPRESS(ddk));\n\tBP_SET_CRYPT(bp, DDK_GET_CRYPT(ddk));\n\tBP_SET_FILL(bp, 1);\n\tBP_SET_CHECKSUM(bp, checksum);\n\tBP_SET_TYPE(bp, DMU_OT_DEDUP);\n\tBP_SET_LEVEL(bp, 0);\n\tBP_SET_DEDUP(bp, 1);\n\tBP_SET_BYTEORDER(bp, ZFS_HOST_BYTEORDER);\n}\n\nvoid\nddt_key_fill(ddt_key_t *ddk, const blkptr_t *bp)\n{\n\tddk->ddk_cksum = bp->blk_cksum;\n\tddk->ddk_prop = 0;\n\n\tASSERT(BP_IS_ENCRYPTED(bp) || !BP_USES_CRYPT(bp));\n\n\tDDK_SET_LSIZE(ddk, BP_GET_LSIZE(bp));\n\tDDK_SET_PSIZE(ddk, BP_GET_PSIZE(bp));\n\tDDK_SET_COMPRESS(ddk, BP_GET_COMPRESS(bp));\n\tDDK_SET_CRYPT(ddk, BP_USES_CRYPT(bp));\n}\n\nvoid\nddt_phys_fill(ddt_phys_t *ddp, const blkptr_t *bp)\n{\n\tASSERT(ddp->ddp_phys_birth == 0);\n\n\tfor (int d = 0; d < SPA_DVAS_PER_BP; d++)\n\t\tddp->ddp_dva[d] = bp->blk_dva[d];\n\tddp->ddp_phys_birth = BP_PHYSICAL_BIRTH(bp);\n}\n\nvoid\nddt_phys_clear(ddt_phys_t *ddp)\n{\n\tmemset(ddp, 0, sizeof (*ddp));\n}\n\nvoid\nddt_phys_addref(ddt_phys_t *ddp)\n{\n\tddp->ddp_refcnt++;\n}\n\nvoid\nddt_phys_decref(ddt_phys_t *ddp)\n{\n\tif (ddp) {\n\t\tASSERT(ddp->ddp_refcnt > 0);\n\t\tddp->ddp_refcnt--;\n\t}\n}\n\nvoid\nddt_phys_free(ddt_t *ddt, ddt_key_t *ddk, ddt_phys_t *ddp, uint64_t txg)\n{\n\tblkptr_t blk;\n\n\tddt_bp_create(ddt->ddt_checksum, ddk, ddp, &blk);\n\n\t \n\tBP_SET_DEDUP(&blk, 0);\n\n\tddt_phys_clear(ddp);\n\tzio_free(ddt->ddt_spa, txg, &blk);\n}\n\nddt_phys_t *\nddt_phys_select(const ddt_entry_t *dde, const blkptr_t *bp)\n{\n\tddt_phys_t *ddp = (ddt_phys_t *)dde->dde_phys;\n\n\tfor (int p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {\n\t\tif (DVA_EQUAL(BP_IDENTITY(bp), &ddp->ddp_dva[0]) &&\n\t\t    BP_PHYSICAL_BIRTH(bp) == ddp->ddp_phys_birth)\n\t\t\treturn (ddp);\n\t}\n\treturn (NULL);\n}\n\nuint64_t\nddt_phys_total_refcnt(const ddt_entry_t *dde)\n{\n\tuint64_t refcnt = 0;\n\n\tfor (int p = DDT_PHYS_SINGLE; p <= DDT_PHYS_TRIPLE; p++)\n\t\trefcnt += dde->dde_phys[p].ddp_refcnt;\n\n\treturn (refcnt);\n}\n\nstatic void\nddt_stat_generate(ddt_t *ddt, ddt_entry_t *dde, ddt_stat_t *dds)\n{\n\tspa_t *spa = ddt->ddt_spa;\n\tddt_phys_t *ddp = dde->dde_phys;\n\tddt_key_t *ddk = &dde->dde_key;\n\tuint64_t lsize = DDK_GET_LSIZE(ddk);\n\tuint64_t psize = DDK_GET_PSIZE(ddk);\n\n\tmemset(dds, 0, sizeof (*dds));\n\n\tfor (int p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {\n\t\tuint64_t dsize = 0;\n\t\tuint64_t refcnt = ddp->ddp_refcnt;\n\n\t\tif (ddp->ddp_phys_birth == 0)\n\t\t\tcontinue;\n\n\t\tfor (int d = 0; d < DDE_GET_NDVAS(dde); d++)\n\t\t\tdsize += dva_get_dsize_sync(spa, &ddp->ddp_dva[d]);\n\n\t\tdds->dds_blocks += 1;\n\t\tdds->dds_lsize += lsize;\n\t\tdds->dds_psize += psize;\n\t\tdds->dds_dsize += dsize;\n\n\t\tdds->dds_ref_blocks += refcnt;\n\t\tdds->dds_ref_lsize += lsize * refcnt;\n\t\tdds->dds_ref_psize += psize * refcnt;\n\t\tdds->dds_ref_dsize += dsize * refcnt;\n\t}\n}\n\nvoid\nddt_stat_add(ddt_stat_t *dst, const ddt_stat_t *src, uint64_t neg)\n{\n\tconst uint64_t *s = (const uint64_t *)src;\n\tuint64_t *d = (uint64_t *)dst;\n\tuint64_t *d_end = (uint64_t *)(dst + 1);\n\n\tASSERT(neg == 0 || neg == -1ULL);\t \n\n\tfor (int i = 0; i < d_end - d; i++)\n\t\td[i] += (s[i] ^ neg) - neg;\n}\n\nstatic void\nddt_stat_update(ddt_t *ddt, ddt_entry_t *dde, uint64_t neg)\n{\n\tddt_stat_t dds;\n\tddt_histogram_t *ddh;\n\tint bucket;\n\n\tddt_stat_generate(ddt, dde, &dds);\n\n\tbucket = highbit64(dds.dds_ref_blocks) - 1;\n\tASSERT(bucket >= 0);\n\n\tddh = &ddt->ddt_histogram[dde->dde_type][dde->dde_class];\n\n\tddt_stat_add(&ddh->ddh_stat[bucket], &dds, neg);\n}\n\nvoid\nddt_histogram_add(ddt_histogram_t *dst, const ddt_histogram_t *src)\n{\n\tfor (int h = 0; h < 64; h++)\n\t\tddt_stat_add(&dst->ddh_stat[h], &src->ddh_stat[h], 0);\n}\n\nvoid\nddt_histogram_stat(ddt_stat_t *dds, const ddt_histogram_t *ddh)\n{\n\tmemset(dds, 0, sizeof (*dds));\n\n\tfor (int h = 0; h < 64; h++)\n\t\tddt_stat_add(dds, &ddh->ddh_stat[h], 0);\n}\n\nboolean_t\nddt_histogram_empty(const ddt_histogram_t *ddh)\n{\n\tconst uint64_t *s = (const uint64_t *)ddh;\n\tconst uint64_t *s_end = (const uint64_t *)(ddh + 1);\n\n\twhile (s < s_end)\n\t\tif (*s++ != 0)\n\t\t\treturn (B_FALSE);\n\n\treturn (B_TRUE);\n}\n\nvoid\nddt_get_dedup_object_stats(spa_t *spa, ddt_object_t *ddo_total)\n{\n\t \n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++) {\n\t\tddt_t *ddt = spa->spa_ddt[c];\n\t\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES;\n\t\t\t    class++) {\n\t\t\t\tddt_object_t *ddo =\n\t\t\t\t    &ddt->ddt_object_stats[type][class];\n\t\t\t\tddo_total->ddo_count += ddo->ddo_count;\n\t\t\t\tddo_total->ddo_dspace += ddo->ddo_dspace;\n\t\t\t\tddo_total->ddo_mspace += ddo->ddo_mspace;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ddo_total->ddo_count != 0) {\n\t\tddo_total->ddo_dspace /= ddo_total->ddo_count;\n\t\tddo_total->ddo_mspace /= ddo_total->ddo_count;\n\t}\n}\n\nvoid\nddt_get_dedup_histogram(spa_t *spa, ddt_histogram_t *ddh)\n{\n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++) {\n\t\tddt_t *ddt = spa->spa_ddt[c];\n\t\tfor (enum ddt_type type = 0; type < DDT_TYPES && ddt; type++) {\n\t\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES;\n\t\t\t    class++) {\n\t\t\t\tddt_histogram_add(ddh,\n\t\t\t\t    &ddt->ddt_histogram_cache[type][class]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nddt_get_dedup_stats(spa_t *spa, ddt_stat_t *dds_total)\n{\n\tddt_histogram_t *ddh_total;\n\n\tddh_total = kmem_zalloc(sizeof (ddt_histogram_t), KM_SLEEP);\n\tddt_get_dedup_histogram(spa, ddh_total);\n\tddt_histogram_stat(dds_total, ddh_total);\n\tkmem_free(ddh_total, sizeof (ddt_histogram_t));\n}\n\nuint64_t\nddt_get_dedup_dspace(spa_t *spa)\n{\n\tddt_stat_t dds_total;\n\n\tif (spa->spa_dedup_dspace != ~0ULL)\n\t\treturn (spa->spa_dedup_dspace);\n\n\tmemset(&dds_total, 0, sizeof (ddt_stat_t));\n\n\t \n\tddt_get_dedup_stats(spa, &dds_total);\n\tspa->spa_dedup_dspace = dds_total.dds_ref_dsize - dds_total.dds_dsize;\n\treturn (spa->spa_dedup_dspace);\n}\n\nuint64_t\nddt_get_pool_dedup_ratio(spa_t *spa)\n{\n\tddt_stat_t dds_total = { 0 };\n\n\tddt_get_dedup_stats(spa, &dds_total);\n\tif (dds_total.dds_dsize == 0)\n\t\treturn (100);\n\n\treturn (dds_total.dds_ref_dsize * 100 / dds_total.dds_dsize);\n}\n\nsize_t\nddt_compress(void *src, uchar_t *dst, size_t s_len, size_t d_len)\n{\n\tuchar_t *version = dst++;\n\tint cpfunc = ZIO_COMPRESS_ZLE;\n\tzio_compress_info_t *ci = &zio_compress_table[cpfunc];\n\tsize_t c_len;\n\n\tASSERT(d_len >= s_len + 1);\t \n\n\tc_len = ci->ci_compress(src, dst, s_len, d_len - 1, ci->ci_level);\n\n\tif (c_len == s_len) {\n\t\tcpfunc = ZIO_COMPRESS_OFF;\n\t\tmemcpy(dst, src, s_len);\n\t}\n\n\t*version = cpfunc;\n\tif (ZFS_HOST_BYTEORDER)\n\t\t*version |= DDT_COMPRESS_BYTEORDER_MASK;\n\n\treturn (c_len + 1);\n}\n\nvoid\nddt_decompress(uchar_t *src, void *dst, size_t s_len, size_t d_len)\n{\n\tuchar_t version = *src++;\n\tint cpfunc = version & DDT_COMPRESS_FUNCTION_MASK;\n\tzio_compress_info_t *ci = &zio_compress_table[cpfunc];\n\n\tif (ci->ci_decompress != NULL)\n\t\t(void) ci->ci_decompress(src, dst, s_len, d_len, ci->ci_level);\n\telse\n\t\tmemcpy(dst, src, d_len);\n\n\tif (((version & DDT_COMPRESS_BYTEORDER_MASK) != 0) !=\n\t    (ZFS_HOST_BYTEORDER != 0))\n\t\tbyteswap_uint64_array(dst, d_len);\n}\n\nddt_t *\nddt_select(spa_t *spa, const blkptr_t *bp)\n{\n\treturn (spa->spa_ddt[BP_GET_CHECKSUM(bp)]);\n}\n\nvoid\nddt_enter(ddt_t *ddt)\n{\n\tmutex_enter(&ddt->ddt_lock);\n}\n\nvoid\nddt_exit(ddt_t *ddt)\n{\n\tmutex_exit(&ddt->ddt_lock);\n}\n\nvoid\nddt_init(void)\n{\n\tddt_cache = kmem_cache_create(\"ddt_cache\",\n\t    sizeof (ddt_t), 0, NULL, NULL, NULL, NULL, NULL, 0);\n\tddt_entry_cache = kmem_cache_create(\"ddt_entry_cache\",\n\t    sizeof (ddt_entry_t), 0, NULL, NULL, NULL, NULL, NULL, 0);\n}\n\nvoid\nddt_fini(void)\n{\n\tkmem_cache_destroy(ddt_entry_cache);\n\tkmem_cache_destroy(ddt_cache);\n}\n\nstatic ddt_entry_t *\nddt_alloc(const ddt_key_t *ddk)\n{\n\tddt_entry_t *dde;\n\n\tdde = kmem_cache_alloc(ddt_entry_cache, KM_SLEEP);\n\tmemset(dde, 0, sizeof (ddt_entry_t));\n\tcv_init(&dde->dde_cv, NULL, CV_DEFAULT, NULL);\n\n\tdde->dde_key = *ddk;\n\n\treturn (dde);\n}\n\nstatic void\nddt_free(ddt_entry_t *dde)\n{\n\tASSERT(!dde->dde_loading);\n\n\tfor (int p = 0; p < DDT_PHYS_TYPES; p++)\n\t\tASSERT(dde->dde_lead_zio[p] == NULL);\n\n\tif (dde->dde_repair_abd != NULL)\n\t\tabd_free(dde->dde_repair_abd);\n\n\tcv_destroy(&dde->dde_cv);\n\tkmem_cache_free(ddt_entry_cache, dde);\n}\n\nvoid\nddt_remove(ddt_t *ddt, ddt_entry_t *dde)\n{\n\tASSERT(MUTEX_HELD(&ddt->ddt_lock));\n\n\tavl_remove(&ddt->ddt_tree, dde);\n\tddt_free(dde);\n}\n\nddt_entry_t *\nddt_lookup(ddt_t *ddt, const blkptr_t *bp, boolean_t add)\n{\n\tddt_entry_t *dde, dde_search;\n\tenum ddt_type type;\n\tenum ddt_class class;\n\tavl_index_t where;\n\tint error;\n\n\tASSERT(MUTEX_HELD(&ddt->ddt_lock));\n\n\tddt_key_fill(&dde_search.dde_key, bp);\n\n\tdde = avl_find(&ddt->ddt_tree, &dde_search, &where);\n\tif (dde == NULL) {\n\t\tif (!add)\n\t\t\treturn (NULL);\n\t\tdde = ddt_alloc(&dde_search.dde_key);\n\t\tavl_insert(&ddt->ddt_tree, dde, where);\n\t}\n\n\twhile (dde->dde_loading)\n\t\tcv_wait(&dde->dde_cv, &ddt->ddt_lock);\n\n\tif (dde->dde_loaded)\n\t\treturn (dde);\n\n\tdde->dde_loading = B_TRUE;\n\n\tddt_exit(ddt);\n\n\terror = ENOENT;\n\n\tfor (type = 0; type < DDT_TYPES; type++) {\n\t\tfor (class = 0; class < DDT_CLASSES; class++) {\n\t\t\terror = ddt_object_lookup(ddt, type, class, dde);\n\t\t\tif (error != ENOENT) {\n\t\t\t\tASSERT0(error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (error != ENOENT)\n\t\t\tbreak;\n\t}\n\n\tddt_enter(ddt);\n\n\tASSERT(dde->dde_loaded == B_FALSE);\n\tASSERT(dde->dde_loading == B_TRUE);\n\n\tdde->dde_type = type;\t \n\tdde->dde_class = class;\t \n\tdde->dde_loaded = B_TRUE;\n\tdde->dde_loading = B_FALSE;\n\n\tif (error == 0)\n\t\tddt_stat_update(ddt, dde, -1ULL);\n\n\tcv_broadcast(&dde->dde_cv);\n\n\treturn (dde);\n}\n\nvoid\nddt_prefetch(spa_t *spa, const blkptr_t *bp)\n{\n\tddt_t *ddt;\n\tddt_entry_t dde;\n\n\tif (!zfs_dedup_prefetch || bp == NULL || !BP_GET_DEDUP(bp))\n\t\treturn;\n\n\t \n\tddt = ddt_select(spa, bp);\n\tddt_key_fill(&dde.dde_key, bp);\n\n\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES; class++) {\n\t\t\tddt_object_prefetch(ddt, type, class, &dde);\n\t\t}\n\t}\n}\n\n \n#define\tDDT_KEY_CMP_LEN\t(sizeof (ddt_key_t) / sizeof (uint16_t))\n\ntypedef struct ddt_key_cmp {\n\tuint16_t\tu16[DDT_KEY_CMP_LEN];\n} ddt_key_cmp_t;\n\nint\nddt_entry_compare(const void *x1, const void *x2)\n{\n\tconst ddt_entry_t *dde1 = x1;\n\tconst ddt_entry_t *dde2 = x2;\n\tconst ddt_key_cmp_t *k1 = (const ddt_key_cmp_t *)&dde1->dde_key;\n\tconst ddt_key_cmp_t *k2 = (const ddt_key_cmp_t *)&dde2->dde_key;\n\tint32_t cmp = 0;\n\n\tfor (int i = 0; i < DDT_KEY_CMP_LEN; i++) {\n\t\tcmp = (int32_t)k1->u16[i] - (int32_t)k2->u16[i];\n\t\tif (likely(cmp))\n\t\t\tbreak;\n\t}\n\n\treturn (TREE_ISIGN(cmp));\n}\n\nstatic ddt_t *\nddt_table_alloc(spa_t *spa, enum zio_checksum c)\n{\n\tddt_t *ddt;\n\n\tddt = kmem_cache_alloc(ddt_cache, KM_SLEEP);\n\tmemset(ddt, 0, sizeof (ddt_t));\n\n\tmutex_init(&ddt->ddt_lock, NULL, MUTEX_DEFAULT, NULL);\n\tavl_create(&ddt->ddt_tree, ddt_entry_compare,\n\t    sizeof (ddt_entry_t), offsetof(ddt_entry_t, dde_node));\n\tavl_create(&ddt->ddt_repair_tree, ddt_entry_compare,\n\t    sizeof (ddt_entry_t), offsetof(ddt_entry_t, dde_node));\n\tddt->ddt_checksum = c;\n\tddt->ddt_spa = spa;\n\tddt->ddt_os = spa->spa_meta_objset;\n\n\treturn (ddt);\n}\n\nstatic void\nddt_table_free(ddt_t *ddt)\n{\n\tASSERT(avl_numnodes(&ddt->ddt_tree) == 0);\n\tASSERT(avl_numnodes(&ddt->ddt_repair_tree) == 0);\n\tavl_destroy(&ddt->ddt_tree);\n\tavl_destroy(&ddt->ddt_repair_tree);\n\tmutex_destroy(&ddt->ddt_lock);\n\tkmem_cache_free(ddt_cache, ddt);\n}\n\nvoid\nddt_create(spa_t *spa)\n{\n\tspa->spa_dedup_checksum = ZIO_DEDUPCHECKSUM;\n\n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++)\n\t\tspa->spa_ddt[c] = ddt_table_alloc(spa, c);\n}\n\nint\nddt_load(spa_t *spa)\n{\n\tint error;\n\n\tddt_create(spa);\n\n\terror = zap_lookup(spa->spa_meta_objset, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_DDT_STATS, sizeof (uint64_t), 1,\n\t    &spa->spa_ddt_stat_object);\n\n\tif (error)\n\t\treturn (error == ENOENT ? 0 : error);\n\n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++) {\n\t\tddt_t *ddt = spa->spa_ddt[c];\n\t\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES;\n\t\t\t    class++) {\n\t\t\t\terror = ddt_object_load(ddt, type, class);\n\t\t\t\tif (error != 0 && error != ENOENT)\n\t\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmemcpy(&ddt->ddt_histogram_cache, ddt->ddt_histogram,\n\t\t    sizeof (ddt->ddt_histogram));\n\t\tspa->spa_dedup_dspace = ~0ULL;\n\t}\n\n\treturn (0);\n}\n\nvoid\nddt_unload(spa_t *spa)\n{\n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++) {\n\t\tif (spa->spa_ddt[c]) {\n\t\t\tddt_table_free(spa->spa_ddt[c]);\n\t\t\tspa->spa_ddt[c] = NULL;\n\t\t}\n\t}\n}\n\nboolean_t\nddt_class_contains(spa_t *spa, enum ddt_class max_class, const blkptr_t *bp)\n{\n\tddt_t *ddt;\n\tddt_entry_t *dde;\n\n\tif (!BP_GET_DEDUP(bp))\n\t\treturn (B_FALSE);\n\n\tif (max_class == DDT_CLASS_UNIQUE)\n\t\treturn (B_TRUE);\n\n\tddt = spa->spa_ddt[BP_GET_CHECKSUM(bp)];\n\tdde = kmem_cache_alloc(ddt_entry_cache, KM_SLEEP);\n\n\tddt_key_fill(&(dde->dde_key), bp);\n\n\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\tfor (enum ddt_class class = 0; class <= max_class; class++) {\n\t\t\tif (ddt_object_lookup(ddt, type, class, dde) == 0) {\n\t\t\t\tkmem_cache_free(ddt_entry_cache, dde);\n\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\tkmem_cache_free(ddt_entry_cache, dde);\n\treturn (B_FALSE);\n}\n\nddt_entry_t *\nddt_repair_start(ddt_t *ddt, const blkptr_t *bp)\n{\n\tddt_key_t ddk;\n\tddt_entry_t *dde;\n\n\tddt_key_fill(&ddk, bp);\n\n\tdde = ddt_alloc(&ddk);\n\n\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES; class++) {\n\t\t\t \n\t\t\tif (class != DDT_CLASS_UNIQUE &&\n\t\t\t    ddt_object_lookup(ddt, type, class, dde) == 0)\n\t\t\t\treturn (dde);\n\t\t}\n\t}\n\n\tmemset(dde->dde_phys, 0, sizeof (dde->dde_phys));\n\n\treturn (dde);\n}\n\nvoid\nddt_repair_done(ddt_t *ddt, ddt_entry_t *dde)\n{\n\tavl_index_t where;\n\n\tddt_enter(ddt);\n\n\tif (dde->dde_repair_abd != NULL && spa_writeable(ddt->ddt_spa) &&\n\t    avl_find(&ddt->ddt_repair_tree, dde, &where) == NULL)\n\t\tavl_insert(&ddt->ddt_repair_tree, dde, where);\n\telse\n\t\tddt_free(dde);\n\n\tddt_exit(ddt);\n}\n\nstatic void\nddt_repair_entry_done(zio_t *zio)\n{\n\tddt_entry_t *rdde = zio->io_private;\n\n\tddt_free(rdde);\n}\n\nstatic void\nddt_repair_entry(ddt_t *ddt, ddt_entry_t *dde, ddt_entry_t *rdde, zio_t *rio)\n{\n\tddt_phys_t *ddp = dde->dde_phys;\n\tddt_phys_t *rddp = rdde->dde_phys;\n\tddt_key_t *ddk = &dde->dde_key;\n\tddt_key_t *rddk = &rdde->dde_key;\n\tzio_t *zio;\n\tblkptr_t blk;\n\n\tzio = zio_null(rio, rio->io_spa, NULL,\n\t    ddt_repair_entry_done, rdde, rio->io_flags);\n\n\tfor (int p = 0; p < DDT_PHYS_TYPES; p++, ddp++, rddp++) {\n\t\tif (ddp->ddp_phys_birth == 0 ||\n\t\t    ddp->ddp_phys_birth != rddp->ddp_phys_birth ||\n\t\t    memcmp(ddp->ddp_dva, rddp->ddp_dva, sizeof (ddp->ddp_dva)))\n\t\t\tcontinue;\n\t\tddt_bp_create(ddt->ddt_checksum, ddk, ddp, &blk);\n\t\tzio_nowait(zio_rewrite(zio, zio->io_spa, 0, &blk,\n\t\t    rdde->dde_repair_abd, DDK_GET_PSIZE(rddk), NULL, NULL,\n\t\t    ZIO_PRIORITY_SYNC_WRITE, ZIO_DDT_CHILD_FLAGS(zio), NULL));\n\t}\n\n\tzio_nowait(zio);\n}\n\nstatic void\nddt_repair_table(ddt_t *ddt, zio_t *rio)\n{\n\tspa_t *spa = ddt->ddt_spa;\n\tddt_entry_t *dde, *rdde_next, *rdde;\n\tavl_tree_t *t = &ddt->ddt_repair_tree;\n\tblkptr_t blk;\n\n\tif (spa_sync_pass(spa) > 1)\n\t\treturn;\n\n\tddt_enter(ddt);\n\tfor (rdde = avl_first(t); rdde != NULL; rdde = rdde_next) {\n\t\trdde_next = AVL_NEXT(t, rdde);\n\t\tavl_remove(&ddt->ddt_repair_tree, rdde);\n\t\tddt_exit(ddt);\n\t\tddt_bp_create(ddt->ddt_checksum, &rdde->dde_key, NULL, &blk);\n\t\tdde = ddt_repair_start(ddt, &blk);\n\t\tddt_repair_entry(ddt, dde, rdde, rio);\n\t\tddt_repair_done(ddt, dde);\n\t\tddt_enter(ddt);\n\t}\n\tddt_exit(ddt);\n}\n\nstatic void\nddt_sync_entry(ddt_t *ddt, ddt_entry_t *dde, dmu_tx_t *tx, uint64_t txg)\n{\n\tdsl_pool_t *dp = ddt->ddt_spa->spa_dsl_pool;\n\tddt_phys_t *ddp = dde->dde_phys;\n\tddt_key_t *ddk = &dde->dde_key;\n\tenum ddt_type otype = dde->dde_type;\n\tenum ddt_type ntype = DDT_TYPE_CURRENT;\n\tenum ddt_class oclass = dde->dde_class;\n\tenum ddt_class nclass;\n\tuint64_t total_refcnt = 0;\n\n\tASSERT(dde->dde_loaded);\n\tASSERT(!dde->dde_loading);\n\n\tfor (int p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {\n\t\tASSERT(dde->dde_lead_zio[p] == NULL);\n\t\tif (ddp->ddp_phys_birth == 0) {\n\t\t\tASSERT(ddp->ddp_refcnt == 0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (p == DDT_PHYS_DITTO) {\n\t\t\t \n\t\t\tddt_phys_free(ddt, ddk, ddp, txg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ddp->ddp_refcnt == 0)\n\t\t\tddt_phys_free(ddt, ddk, ddp, txg);\n\t\ttotal_refcnt += ddp->ddp_refcnt;\n\t}\n\n\t \n\tASSERT0(dde->dde_phys[DDT_PHYS_DITTO].ddp_phys_birth);\n\tif (total_refcnt > 1)\n\t\tnclass = DDT_CLASS_DUPLICATE;\n\telse\n\t\tnclass = DDT_CLASS_UNIQUE;\n\n\tif (otype != DDT_TYPES &&\n\t    (otype != ntype || oclass != nclass || total_refcnt == 0)) {\n\t\tVERIFY(ddt_object_remove(ddt, otype, oclass, dde, tx) == 0);\n\t\tASSERT(ddt_object_lookup(ddt, otype, oclass, dde) == ENOENT);\n\t}\n\n\tif (total_refcnt != 0) {\n\t\tdde->dde_type = ntype;\n\t\tdde->dde_class = nclass;\n\t\tddt_stat_update(ddt, dde, 0);\n\t\tif (!ddt_object_exists(ddt, ntype, nclass))\n\t\t\tddt_object_create(ddt, ntype, nclass, tx);\n\t\tVERIFY(ddt_object_update(ddt, ntype, nclass, dde, tx) == 0);\n\n\t\t \n\t\tif (nclass < oclass) {\n\t\t\tdsl_scan_ddt_entry(dp->dp_scan,\n\t\t\t    ddt->ddt_checksum, dde, tx);\n\t\t}\n\t}\n}\n\nstatic void\nddt_sync_table(ddt_t *ddt, dmu_tx_t *tx, uint64_t txg)\n{\n\tspa_t *spa = ddt->ddt_spa;\n\tddt_entry_t *dde;\n\tvoid *cookie = NULL;\n\n\tif (avl_numnodes(&ddt->ddt_tree) == 0)\n\t\treturn;\n\n\tASSERT(spa->spa_uberblock.ub_version >= SPA_VERSION_DEDUP);\n\n\tif (spa->spa_ddt_stat_object == 0) {\n\t\tspa->spa_ddt_stat_object = zap_create_link(ddt->ddt_os,\n\t\t    DMU_OT_DDT_STATS, DMU_POOL_DIRECTORY_OBJECT,\n\t\t    DMU_POOL_DDT_STATS, tx);\n\t}\n\n\twhile ((dde = avl_destroy_nodes(&ddt->ddt_tree, &cookie)) != NULL) {\n\t\tddt_sync_entry(ddt, dde, tx, txg);\n\t\tddt_free(dde);\n\t}\n\n\tfor (enum ddt_type type = 0; type < DDT_TYPES; type++) {\n\t\tuint64_t add, count = 0;\n\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES; class++) {\n\t\t\tif (ddt_object_exists(ddt, type, class)) {\n\t\t\t\tddt_object_sync(ddt, type, class, tx);\n\t\t\t\tVERIFY(ddt_object_count(ddt, type, class,\n\t\t\t\t    &add) == 0);\n\t\t\t\tcount += add;\n\t\t\t}\n\t\t}\n\t\tfor (enum ddt_class class = 0; class < DDT_CLASSES; class++) {\n\t\t\tif (count == 0 && ddt_object_exists(ddt, type, class))\n\t\t\t\tddt_object_destroy(ddt, type, class, tx);\n\t\t}\n\t}\n\n\tmemcpy(&ddt->ddt_histogram_cache, ddt->ddt_histogram,\n\t    sizeof (ddt->ddt_histogram));\n\tspa->spa_dedup_dspace = ~0ULL;\n}\n\nvoid\nddt_sync(spa_t *spa, uint64_t txg)\n{\n\tdsl_scan_t *scn = spa->spa_dsl_pool->dp_scan;\n\tdmu_tx_t *tx;\n\tzio_t *rio;\n\n\tASSERT(spa_syncing_txg(spa) == txg);\n\n\ttx = dmu_tx_create_assigned(spa->spa_dsl_pool, txg);\n\n\trio = zio_root(spa, NULL, NULL,\n\t    ZIO_FLAG_CANFAIL | ZIO_FLAG_SPECULATIVE | ZIO_FLAG_SELF_HEAL);\n\n\t \n\tASSERT3P(scn->scn_zio_root, ==, NULL);\n\tscn->scn_zio_root = rio;\n\n\tfor (enum zio_checksum c = 0; c < ZIO_CHECKSUM_FUNCTIONS; c++) {\n\t\tddt_t *ddt = spa->spa_ddt[c];\n\t\tif (ddt == NULL)\n\t\t\tcontinue;\n\t\tddt_sync_table(ddt, tx, txg);\n\t\tddt_repair_table(ddt, rio);\n\t}\n\n\t(void) zio_wait(rio);\n\tscn->scn_zio_root = NULL;\n\n\tdmu_tx_commit(tx);\n}\n\nint\nddt_walk(spa_t *spa, ddt_bookmark_t *ddb, ddt_entry_t *dde)\n{\n\tdo {\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tddt_t *ddt = spa->spa_ddt[ddb->ddb_checksum];\n\t\t\t\tint error = ENOENT;\n\t\t\t\tif (ddt_object_exists(ddt, ddb->ddb_type,\n\t\t\t\t    ddb->ddb_class)) {\n\t\t\t\t\terror = ddt_object_walk(ddt,\n\t\t\t\t\t    ddb->ddb_type, ddb->ddb_class,\n\t\t\t\t\t    &ddb->ddb_cursor, dde);\n\t\t\t\t}\n\t\t\t\tdde->dde_type = ddb->ddb_type;\n\t\t\t\tdde->dde_class = ddb->ddb_class;\n\t\t\t\tif (error == 0)\n\t\t\t\t\treturn (0);\n\t\t\t\tif (error != ENOENT)\n\t\t\t\t\treturn (error);\n\t\t\t\tddb->ddb_cursor = 0;\n\t\t\t} while (++ddb->ddb_checksum < ZIO_CHECKSUM_FUNCTIONS);\n\t\t\tddb->ddb_checksum = 0;\n\t\t} while (++ddb->ddb_type < DDT_TYPES);\n\t\tddb->ddb_type = 0;\n\t} while (++ddb->ddb_class < DDT_CLASSES);\n\n\treturn (SET_ERROR(ENOENT));\n}\n\n \nboolean_t\nddt_addref(spa_t *spa, const blkptr_t *bp)\n{\n\tddt_t *ddt;\n\tddt_entry_t *dde;\n\tboolean_t result;\n\n\tspa_config_enter(spa, SCL_ZIO, FTAG, RW_READER);\n\tddt = ddt_select(spa, bp);\n\tddt_enter(ddt);\n\n\tdde = ddt_lookup(ddt, bp, B_TRUE);\n\tASSERT(dde != NULL);\n\n\tif (dde->dde_type < DDT_TYPES) {\n\t\tddt_phys_t *ddp;\n\n\t\tASSERT3S(dde->dde_class, <, DDT_CLASSES);\n\n\t\tddp = &dde->dde_phys[BP_GET_NDVAS(bp)];\n\n\t\t \n\t\tASSERT3U(ddp->ddp_refcnt, >, 0);\n\n\t\tddt_phys_addref(ddp);\n\t\tresult = B_TRUE;\n\t} else {\n\t\t \n\t\tASSERT3S(dde->dde_class, ==, DDT_CLASSES);\n\t\tddt_remove(ddt, dde);\n\t\tresult = B_FALSE;\n\t}\n\n\tddt_exit(ddt);\n\tspa_config_exit(spa, SCL_ZIO, FTAG);\n\n\treturn (result);\n}\n\nZFS_MODULE_PARAM(zfs_dedup, zfs_dedup_, prefetch, INT, ZMOD_RW,\n\t\"Enable prefetching dedup-ed blks\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}