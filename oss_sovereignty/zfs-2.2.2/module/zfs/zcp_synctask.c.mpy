{
  "module_name": "zcp_synctask.c",
  "hash_id": "01b644229300c5d3430c8273e2245f380a599a68fb836488038f35c0e56ca019",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zcp_synctask.c",
  "human_readable_source": " \n\n \n\n#include <sys/lua/lua.h>\n#include <sys/lua/lauxlib.h>\n\n#include <sys/zcp.h>\n#include <sys/zcp_set.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dmu_objset.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfeature.h>\n#include <sys/metaslab.h>\n\n#define\tDST_AVG_BLKSHIFT 14\n\ntypedef struct zcp_inherit_prop_arg {\n\tlua_State\t\t*zipa_state;\n\tconst char\t\t*zipa_prop;\n\tdsl_props_set_arg_t\tzipa_dpsa;\n} zcp_inherit_prop_arg_t;\n\ntypedef int (zcp_synctask_func_t)(lua_State *, boolean_t, nvlist_t *);\ntypedef struct zcp_synctask_info {\n\tconst char *name;\n\tzcp_synctask_func_t *func;\n\tconst zcp_arg_t pargs[4];\n\tconst zcp_arg_t kwargs[2];\n\tzfs_space_check_t space_check;\n\tint blocks_modified;\n} zcp_synctask_info_t;\n\nstatic void\nzcp_synctask_cleanup(void *arg)\n{\n\tfnvlist_free(arg);\n}\n\n \nstatic int\nzcp_sync_task(lua_State *state, dsl_checkfunc_t *checkfunc,\n    dsl_syncfunc_t *syncfunc, void *arg, boolean_t sync, const char *err_dsname)\n{\n\tint err;\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\n\terr = checkfunc(arg, ri->zri_tx);\n\tif (!sync)\n\t\treturn (err);\n\n\tif (!ri->zri_sync) {\n\t\treturn (luaL_error(state, \"running functions from the zfs.sync \"\n\t\t    \"submodule requires passing sync=TRUE to \"\n\t\t    \"lzc_channel_program() (i.e. do not specify the \\\"-n\\\" \"\n\t\t    \"command line argument)\"));\n\t}\n\n\tif (err == 0) {\n\t\tsyncfunc(arg, ri->zri_tx);\n\t} else if (err == EIO) {\n\t\tif (err_dsname != NULL) {\n\t\t\treturn (luaL_error(state,\n\t\t\t    \"I/O error while accessing dataset '%s'\",\n\t\t\t    err_dsname));\n\t\t} else {\n\t\t\treturn (luaL_error(state,\n\t\t\t    \"I/O error while accessing dataset.\"));\n\t\t}\n\t}\n\n\treturn (err);\n}\n\n\nstatic int zcp_synctask_destroy(lua_State *, boolean_t, nvlist_t *);\nstatic const zcp_synctask_info_t zcp_synctask_destroy_info = {\n\t.name = \"destroy\",\n\t.func = zcp_synctask_destroy,\n\t.pargs = {\n\t    {.za_name = \"filesystem | snapshot\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {.za_name = \"defer\", .za_lua_type = LUA_TBOOLEAN },\n\t    {NULL, 0}\n\t},\n\t.space_check = ZFS_SPACE_CHECK_DESTROY,\n\t.blocks_modified = 0\n};\n\nstatic int\nzcp_synctask_destroy(lua_State *state, boolean_t sync, nvlist_t *err_details)\n{\n\t(void) err_details;\n\tint err;\n\tconst char *dsname = lua_tostring(state, 1);\n\n\tboolean_t issnap = (strchr(dsname, '@') != NULL);\n\n\tif (!issnap && !lua_isnil(state, 2)) {\n\t\treturn (luaL_error(state,\n\t\t    \"'deferred' kwarg only supported for snapshots: %s\",\n\t\t    dsname));\n\t}\n\n\tif (issnap) {\n\t\tdsl_destroy_snapshot_arg_t ddsa = { 0 };\n\t\tddsa.ddsa_name = dsname;\n\t\tif (!lua_isnil(state, 2)) {\n\t\t\tddsa.ddsa_defer = lua_toboolean(state, 2);\n\t\t} else {\n\t\t\tddsa.ddsa_defer = B_FALSE;\n\t\t}\n\n\t\terr = zcp_sync_task(state, dsl_destroy_snapshot_check,\n\t\t    dsl_destroy_snapshot_sync, &ddsa, sync, dsname);\n\t} else {\n\t\tdsl_destroy_head_arg_t ddha = { 0 };\n\t\tddha.ddha_name = dsname;\n\n\t\terr = zcp_sync_task(state, dsl_destroy_head_check,\n\t\t    dsl_destroy_head_sync, &ddha, sync, dsname);\n\t}\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_promote(lua_State *, boolean_t, nvlist_t *);\nstatic const zcp_synctask_info_t zcp_synctask_promote_info = {\n\t.name = \"promote\",\n\t.func = zcp_synctask_promote,\n\t.pargs = {\n\t    {.za_name = \"clone\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t},\n\t.space_check = ZFS_SPACE_CHECK_RESERVED,\n\t.blocks_modified = 3\n};\n\nstatic int\nzcp_synctask_promote(lua_State *state, boolean_t sync, nvlist_t *err_details)\n{\n\tint err;\n\tdsl_dataset_promote_arg_t ddpa = { 0 };\n\tconst char *dsname = lua_tostring(state, 1);\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\n\tddpa.ddpa_clonename = dsname;\n\tddpa.err_ds = err_details;\n\tddpa.cr = ri->zri_cred;\n\tddpa.proc = ri->zri_proc;\n\n\t \n\terr = zcp_sync_task(state, dsl_dataset_promote_check,\n\t    dsl_dataset_promote_sync, &ddpa, sync, dsname);\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_rollback(lua_State *, boolean_t, nvlist_t *err_details);\nstatic const zcp_synctask_info_t zcp_synctask_rollback_info = {\n\t.name = \"rollback\",\n\t.func = zcp_synctask_rollback,\n\t.space_check = ZFS_SPACE_CHECK_RESERVED,\n\t.blocks_modified = 1,\n\t.pargs = {\n\t    {.za_name = \"filesystem\", .za_lua_type = LUA_TSTRING },\n\t    {0, 0}\n\t},\n\t.kwargs = {\n\t    {0, 0}\n\t}\n};\n\nstatic int\nzcp_synctask_rollback(lua_State *state, boolean_t sync, nvlist_t *err_details)\n{\n\tint err;\n\tconst char *dsname = lua_tostring(state, 1);\n\tdsl_dataset_rollback_arg_t ddra = { 0 };\n\n\tddra.ddra_fsname = dsname;\n\tddra.ddra_result = err_details;\n\n\terr = zcp_sync_task(state, dsl_dataset_rollback_check,\n\t    dsl_dataset_rollback_sync, &ddra, sync, dsname);\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_snapshot(lua_State *, boolean_t, nvlist_t *);\nstatic const zcp_synctask_info_t zcp_synctask_snapshot_info = {\n\t.name = \"snapshot\",\n\t.func = zcp_synctask_snapshot,\n\t.pargs = {\n\t    {.za_name = \"filesystem@snapname | volume@snapname\",\n\t    .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t},\n\t.space_check = ZFS_SPACE_CHECK_NORMAL,\n\t.blocks_modified = 3\n};\n\nstatic int\nzcp_synctask_snapshot(lua_State *state, boolean_t sync, nvlist_t *err_details)\n{\n\t(void) err_details;\n\tint err;\n\tdsl_dataset_snapshot_arg_t ddsa = { 0 };\n\tconst char *dsname = lua_tostring(state, 1);\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\n\t \n\tif (spa_version(ri->zri_pool->dp_spa) < SPA_VERSION_FAST_SNAP) {\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\t \n\tddsa.ddsa_errors = NULL;\n\tddsa.ddsa_props = NULL;\n\tddsa.ddsa_cr = ri->zri_cred;\n\tddsa.ddsa_proc = ri->zri_proc;\n\tddsa.ddsa_snaps = fnvlist_alloc();\n\tfnvlist_add_boolean(ddsa.ddsa_snaps, dsname);\n\n\tzcp_cleanup_handler_t *zch = zcp_register_cleanup(state,\n\t    zcp_synctask_cleanup, ddsa.ddsa_snaps);\n\n\terr = zcp_sync_task(state, dsl_dataset_snapshot_check,\n\t    dsl_dataset_snapshot_sync, &ddsa, sync, dsname);\n\n\tif (err == 0) {\n\t\t \n\t\tfnvlist_add_boolean(ri->zri_new_zvols, dsname);\n\t}\n\n\tzcp_deregister_cleanup(state, zch);\n\tfnvlist_free(ddsa.ddsa_snaps);\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_rename_snapshot(lua_State *, boolean_t, nvlist_t *);\nstatic const zcp_synctask_info_t zcp_synctask_rename_snapshot_info = {\n\t.name = \"rename_snapshot\",\n\t.func = zcp_synctask_rename_snapshot,\n\t.pargs = {\n\t    {.za_name = \"filesystem | volume\", .za_lua_type = LUA_TSTRING },\n\t    {.za_name = \"oldsnapname\", .za_lua_type = LUA_TSTRING },\n\t    {.za_name = \"newsnapname\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.space_check = ZFS_SPACE_CHECK_RESERVED,\n\t.blocks_modified = 1\n};\n\nstatic int\nzcp_synctask_rename_snapshot(lua_State *state, boolean_t sync,\n    nvlist_t *err_details)\n{\n\t(void) err_details;\n\tint err;\n\tconst char *fsname = lua_tostring(state, 1);\n\tconst char *oldsnapname = lua_tostring(state, 2);\n\tconst char *newsnapname = lua_tostring(state, 3);\n\n\tstruct dsl_dataset_rename_snapshot_arg ddrsa = { 0 };\n\tddrsa.ddrsa_fsname = fsname;\n\tddrsa.ddrsa_oldsnapname = oldsnapname;\n\tddrsa.ddrsa_newsnapname = newsnapname;\n\tddrsa.ddrsa_recursive = B_FALSE;\n\n\terr = zcp_sync_task(state, dsl_dataset_rename_snapshot_check,\n\t    dsl_dataset_rename_snapshot_sync, &ddrsa, sync, NULL);\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_inherit_prop(lua_State *, boolean_t,\n    nvlist_t *err_details);\nstatic const zcp_synctask_info_t zcp_synctask_inherit_prop_info = {\n\t.name = \"inherit\",\n\t.func = zcp_synctask_inherit_prop,\n\t.space_check = ZFS_SPACE_CHECK_RESERVED,\n\t.blocks_modified = 2,  \n\t.pargs = {\n\t\t{ .za_name = \"dataset\", .za_lua_type = LUA_TSTRING },\n\t\t{ .za_name = \"property\", .za_lua_type = LUA_TSTRING },\n\t\t{ NULL, 0 }\n\t},\n\t.kwargs = {\n\t\t{ NULL, 0 }\n\t},\n};\n\nstatic int\nzcp_synctask_inherit_prop_check(void *arg, dmu_tx_t *tx)\n{\n\tzcp_inherit_prop_arg_t *args = arg;\n\tzfs_prop_t prop = zfs_name_to_prop(args->zipa_prop);\n\n\tif (prop == ZPROP_USERPROP) {\n\t\tif (zfs_prop_user(args->zipa_prop))\n\t\t\treturn (0);\n\n\t\treturn (EINVAL);\n\t}\n\n\tif (zfs_prop_readonly(prop))\n\t\treturn (EINVAL);\n\n\tif (!zfs_prop_inheritable(prop))\n\t\treturn (EINVAL);\n\n\treturn (dsl_props_set_check(&args->zipa_dpsa, tx));\n}\n\nstatic void\nzcp_synctask_inherit_prop_sync(void *arg, dmu_tx_t *tx)\n{\n\tzcp_inherit_prop_arg_t *args = arg;\n\tdsl_props_set_arg_t *dpsa = &args->zipa_dpsa;\n\n\tdsl_props_set_sync(dpsa, tx);\n}\n\nstatic int\nzcp_synctask_inherit_prop(lua_State *state, boolean_t sync,\n    nvlist_t *err_details)\n{\n\t(void) err_details;\n\tint err;\n\tzcp_inherit_prop_arg_t zipa = { 0 };\n\tdsl_props_set_arg_t *dpsa = &zipa.zipa_dpsa;\n\n\tconst char *dsname = lua_tostring(state, 1);\n\tconst char *prop = lua_tostring(state, 2);\n\n\tzipa.zipa_state = state;\n\tzipa.zipa_prop = prop;\n\tdpsa->dpsa_dsname = dsname;\n\tdpsa->dpsa_source = ZPROP_SRC_INHERITED;\n\tdpsa->dpsa_props = fnvlist_alloc();\n\tfnvlist_add_boolean(dpsa->dpsa_props, prop);\n\n\tzcp_cleanup_handler_t *zch = zcp_register_cleanup(state,\n\t    zcp_synctask_cleanup, dpsa->dpsa_props);\n\n\terr = zcp_sync_task(state, zcp_synctask_inherit_prop_check,\n\t    zcp_synctask_inherit_prop_sync, &zipa, sync, dsname);\n\n\tzcp_deregister_cleanup(state, zch);\n\tfnvlist_free(dpsa->dpsa_props);\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_bookmark(lua_State *, boolean_t, nvlist_t *);\nstatic const zcp_synctask_info_t zcp_synctask_bookmark_info = {\n\t.name = \"bookmark\",\n\t.func = zcp_synctask_bookmark,\n\t.pargs = {\n\t    {.za_name = \"snapshot | bookmark\", .za_lua_type = LUA_TSTRING },\n\t    {.za_name = \"bookmark\", .za_lua_type = LUA_TSTRING },\n\t    {NULL, 0}\n\t},\n\t.kwargs = {\n\t    {NULL, 0}\n\t},\n\t.space_check = ZFS_SPACE_CHECK_NORMAL,\n\t.blocks_modified = 1,\n};\n\nstatic int\nzcp_synctask_bookmark(lua_State *state, boolean_t sync, nvlist_t *err_details)\n{\n\t(void) err_details;\n\tint err;\n\tconst char *source = lua_tostring(state, 1);\n\tconst char *new = lua_tostring(state, 2);\n\n\tnvlist_t *bmarks = fnvlist_alloc();\n\tfnvlist_add_string(bmarks, new, source);\n\n\tzcp_cleanup_handler_t *zch = zcp_register_cleanup(state,\n\t    zcp_synctask_cleanup, bmarks);\n\n\tdsl_bookmark_create_arg_t dbca = {\n\t\t.dbca_bmarks = bmarks,\n\t\t.dbca_errors = NULL,\n\t};\n\terr = zcp_sync_task(state, dsl_bookmark_create_check,\n\t    dsl_bookmark_create_sync, &dbca, sync, source);\n\n\tzcp_deregister_cleanup(state, zch);\n\tfnvlist_free(bmarks);\n\n\treturn (err);\n}\n\nstatic int zcp_synctask_set_prop(lua_State *, boolean_t, nvlist_t *err_details);\nstatic const zcp_synctask_info_t zcp_synctask_set_prop_info = {\n\t.name = \"set_prop\",\n\t.func = zcp_synctask_set_prop,\n\t.space_check = ZFS_SPACE_CHECK_RESERVED,\n\t.blocks_modified = 2,\n\t.pargs = {\n\t\t{ .za_name = \"dataset\", .za_lua_type = LUA_TSTRING },\n\t\t{ .za_name = \"property\", .za_lua_type =  LUA_TSTRING },\n\t\t{ .za_name = \"value\", .za_lua_type =  LUA_TSTRING },\n\t\t{ NULL, 0 }\n\t},\n\t.kwargs = {\n\t\t{ NULL, 0 }\n\t}\n};\n\nstatic int\nzcp_synctask_set_prop(lua_State *state, boolean_t sync, nvlist_t *err_details)\n{\n\t(void) err_details;\n\tint err;\n\tzcp_set_prop_arg_t args = { 0 };\n\n\tconst char *dsname = lua_tostring(state, 1);\n\tconst char *prop = lua_tostring(state, 2);\n\tconst char *val = lua_tostring(state, 3);\n\n\targs.state = state;\n\targs.dsname = dsname;\n\targs.prop = prop;\n\targs.val = val;\n\n\terr = zcp_sync_task(state, zcp_set_prop_check, zcp_set_prop_sync,\n\t    &args, sync, dsname);\n\n\treturn (err);\n}\n\nstatic int\nzcp_synctask_wrapper(lua_State *state)\n{\n\tint err;\n\tzcp_cleanup_handler_t *zch;\n\tint num_ret = 1;\n\tnvlist_t *err_details = fnvlist_alloc();\n\n\t \n\tzch = zcp_register_cleanup(state, zcp_synctask_cleanup, err_details);\n\n\tzcp_synctask_info_t *info = lua_touserdata(state, lua_upvalueindex(1));\n\tboolean_t sync = lua_toboolean(state, lua_upvalueindex(2));\n\n\tzcp_run_info_t *ri = zcp_run_info(state);\n\tdsl_pool_t *dp = ri->zri_pool;\n\n\t \n\tuint64_t funcspace =\n\t    ((uint64_t)info->blocks_modified << DST_AVG_BLKSHIFT) * 3;\n\n\tzcp_parse_args(state, info->name, info->pargs, info->kwargs);\n\n\terr = 0;\n\tif (info->space_check != ZFS_SPACE_CHECK_NONE) {\n\t\tuint64_t quota = dsl_pool_unreserved_space(dp,\n\t\t    info->space_check);\n\t\tuint64_t used = dsl_dir_phys(dp->dp_root_dir)->dd_used_bytes +\n\t\t    ri->zri_space_used;\n\n\t\tif (used + funcspace > quota) {\n\t\t\terr = SET_ERROR(ENOSPC);\n\t\t}\n\t}\n\n\tif (err == 0) {\n\t\terr = info->func(state, sync, err_details);\n\t}\n\n\tif (err == 0) {\n\t\tri->zri_space_used += funcspace;\n\t}\n\n\tlua_pushnumber(state, (lua_Number)err);\n\tif (fnvlist_num_pairs(err_details) > 0) {\n\t\t(void) zcp_nvlist_to_lua(state, err_details, NULL, 0);\n\t\tnum_ret++;\n\t}\n\n\tzcp_deregister_cleanup(state, zch);\n\tfnvlist_free(err_details);\n\n\treturn (num_ret);\n}\n\nint\nzcp_load_synctask_lib(lua_State *state, boolean_t sync)\n{\n\tconst zcp_synctask_info_t *zcp_synctask_funcs[] = {\n\t\t&zcp_synctask_destroy_info,\n\t\t&zcp_synctask_promote_info,\n\t\t&zcp_synctask_rollback_info,\n\t\t&zcp_synctask_snapshot_info,\n\t\t&zcp_synctask_rename_snapshot_info,\n\t\t&zcp_synctask_inherit_prop_info,\n\t\t&zcp_synctask_bookmark_info,\n\t\t&zcp_synctask_set_prop_info,\n\t\tNULL\n\t};\n\n\tlua_newtable(state);\n\n\tfor (int i = 0; zcp_synctask_funcs[i] != NULL; i++) {\n\t\tconst zcp_synctask_info_t *info = zcp_synctask_funcs[i];\n\t\tlua_pushlightuserdata(state, (void *)(uintptr_t)info);\n\t\tlua_pushboolean(state, sync);\n\t\tlua_pushcclosure(state, &zcp_synctask_wrapper, 2);\n\t\tlua_setfield(state, -2, info->name);\n\t}\n\n\treturn (1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}