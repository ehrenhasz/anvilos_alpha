{
  "module_name": "bqueue.c",
  "hash_id": "fdac0c979917b89489aadd4db160b49bb34886d5ca3e333a9362fe8d905d7319",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/bqueue.c",
  "human_readable_source": " \n \n\n#include\t<sys/bqueue.h>\n#include\t<sys/zfs_context.h>\n\nstatic inline bqueue_node_t *\nobj2node(bqueue_t *q, void *data)\n{\n\treturn ((bqueue_node_t *)((char *)data + q->bq_node_offset));\n}\n\n \nint\nbqueue_init(bqueue_t *q, uint_t fill_fraction, size_t size, size_t node_offset)\n{\n\tif (fill_fraction == 0) {\n\t\treturn (-1);\n\t}\n\tlist_create(&q->bq_list, node_offset + sizeof (bqueue_node_t),\n\t    node_offset + offsetof(bqueue_node_t, bqn_node));\n\tlist_create(&q->bq_dequeuing_list, node_offset + sizeof (bqueue_node_t),\n\t    node_offset + offsetof(bqueue_node_t, bqn_node));\n\tlist_create(&q->bq_enqueuing_list, node_offset + sizeof (bqueue_node_t),\n\t    node_offset + offsetof(bqueue_node_t, bqn_node));\n\tcv_init(&q->bq_add_cv, NULL, CV_DEFAULT, NULL);\n\tcv_init(&q->bq_pop_cv, NULL, CV_DEFAULT, NULL);\n\tmutex_init(&q->bq_lock, NULL, MUTEX_DEFAULT, NULL);\n\tq->bq_node_offset = node_offset;\n\tq->bq_size = 0;\n\tq->bq_dequeuing_size = 0;\n\tq->bq_enqueuing_size = 0;\n\tq->bq_maxsize = size;\n\tq->bq_fill_fraction = fill_fraction;\n\treturn (0);\n}\n\n \nvoid\nbqueue_destroy(bqueue_t *q)\n{\n\tmutex_enter(&q->bq_lock);\n\tASSERT0(q->bq_size);\n\tASSERT0(q->bq_dequeuing_size);\n\tASSERT0(q->bq_enqueuing_size);\n\tcv_destroy(&q->bq_add_cv);\n\tcv_destroy(&q->bq_pop_cv);\n\tlist_destroy(&q->bq_list);\n\tlist_destroy(&q->bq_dequeuing_list);\n\tlist_destroy(&q->bq_enqueuing_list);\n\tmutex_exit(&q->bq_lock);\n\tmutex_destroy(&q->bq_lock);\n}\n\nstatic void\nbqueue_enqueue_impl(bqueue_t *q, void *data, size_t item_size, boolean_t flush)\n{\n\tASSERT3U(item_size, >, 0);\n\tASSERT3U(item_size, <=, q->bq_maxsize);\n\n\tobj2node(q, data)->bqn_size = item_size;\n\tq->bq_enqueuing_size += item_size;\n\tlist_insert_tail(&q->bq_enqueuing_list, data);\n\n\tif (flush ||\n\t    q->bq_enqueuing_size >= q->bq_maxsize / q->bq_fill_fraction) {\n\t\t \n\t\tmutex_enter(&q->bq_lock);\n\t\twhile (q->bq_size > q->bq_maxsize) {\n\t\t\tcv_wait_sig(&q->bq_add_cv, &q->bq_lock);\n\t\t}\n\t\tq->bq_size += q->bq_enqueuing_size;\n\t\tlist_move_tail(&q->bq_list, &q->bq_enqueuing_list);\n\t\tq->bq_enqueuing_size = 0;\n\t\tcv_broadcast(&q->bq_pop_cv);\n\t\tmutex_exit(&q->bq_lock);\n\t}\n}\n\n \nvoid\nbqueue_enqueue(bqueue_t *q, void *data, size_t item_size)\n{\n\tbqueue_enqueue_impl(q, data, item_size, B_FALSE);\n}\n\n \nvoid\nbqueue_enqueue_flush(bqueue_t *q, void *data, size_t item_size)\n{\n\tbqueue_enqueue_impl(q, data, item_size, B_TRUE);\n}\n\n \nvoid *\nbqueue_dequeue(bqueue_t *q)\n{\n\tvoid *ret = list_remove_head(&q->bq_dequeuing_list);\n\tif (ret == NULL) {\n\t\t \n\t\tmutex_enter(&q->bq_lock);\n\t\twhile (q->bq_size == 0) {\n\t\t\tcv_wait_sig(&q->bq_pop_cv, &q->bq_lock);\n\t\t}\n\t\tASSERT0(q->bq_dequeuing_size);\n\t\tASSERT(list_is_empty(&q->bq_dequeuing_list));\n\t\tlist_move_tail(&q->bq_dequeuing_list, &q->bq_list);\n\t\tq->bq_dequeuing_size = q->bq_size;\n\t\tq->bq_size = 0;\n\t\tcv_broadcast(&q->bq_add_cv);\n\t\tmutex_exit(&q->bq_lock);\n\t\tret = list_remove_head(&q->bq_dequeuing_list);\n\t}\n\tq->bq_dequeuing_size -= obj2node(q, ret)->bqn_size;\n\treturn (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}