{
  "module_name": "dsl_deadlist.c",
  "hash_id": "91bbf31bf89e0992847954f628deae2246961040d1643feec7e2dccc57c854d7",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_deadlist.c",
  "human_readable_source": " \n \n\n#include <sys/dmu.h>\n#include <sys/zap.h>\n#include <sys/zfs_context.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_dataset.h>\n\n \n\n \n\n \nuint64_t zfs_livelist_max_entries = 500000;\n\n \nint zfs_livelist_min_percent_shared = 75;\n\nstatic int\ndsl_deadlist_compare(const void *arg1, const void *arg2)\n{\n\tconst dsl_deadlist_entry_t *dle1 = arg1;\n\tconst dsl_deadlist_entry_t *dle2 = arg2;\n\n\treturn (TREE_CMP(dle1->dle_mintxg, dle2->dle_mintxg));\n}\n\nstatic int\ndsl_deadlist_cache_compare(const void *arg1, const void *arg2)\n{\n\tconst dsl_deadlist_cache_entry_t *dlce1 = arg1;\n\tconst dsl_deadlist_cache_entry_t *dlce2 = arg2;\n\n\treturn (TREE_CMP(dlce1->dlce_mintxg, dlce2->dlce_mintxg));\n}\n\nstatic void\ndsl_deadlist_load_tree(dsl_deadlist_t *dl)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tint error;\n\n\tASSERT(MUTEX_HELD(&dl->dl_lock));\n\n\tASSERT(!dl->dl_oldfmt);\n\tif (dl->dl_havecache) {\n\t\t \n\t\tdsl_deadlist_cache_entry_t *dlce;\n\t\tvoid *cookie = NULL;\n\t\twhile ((dlce = avl_destroy_nodes(&dl->dl_cache, &cookie))\n\t\t    != NULL) {\n\t\t\tkmem_free(dlce, sizeof (*dlce));\n\t\t}\n\t\tavl_destroy(&dl->dl_cache);\n\t\tdl->dl_havecache = B_FALSE;\n\t}\n\tif (dl->dl_havetree)\n\t\treturn;\n\n\tavl_create(&dl->dl_tree, dsl_deadlist_compare,\n\t    sizeof (dsl_deadlist_entry_t),\n\t    offsetof(dsl_deadlist_entry_t, dle_node));\n\tfor (zap_cursor_init(&zc, dl->dl_os, dl->dl_object);\n\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tdsl_deadlist_entry_t *dle = kmem_alloc(sizeof (*dle), KM_SLEEP);\n\t\tdle->dle_mintxg = zfs_strtonum(za.za_name, NULL);\n\n\t\t \n\t\tdle->dle_bpobj.bpo_object = za.za_first_integer;\n\t\tdmu_prefetch(dl->dl_os, dle->dle_bpobj.bpo_object,\n\t\t    0, 0, 0, ZIO_PRIORITY_SYNC_READ);\n\n\t\tavl_add(&dl->dl_tree, dle);\n\t}\n\tVERIFY3U(error, ==, ENOENT);\n\tzap_cursor_fini(&zc);\n\n\tfor (dsl_deadlist_entry_t *dle = avl_first(&dl->dl_tree);\n\t    dle != NULL; dle = AVL_NEXT(&dl->dl_tree, dle)) {\n\t\tVERIFY0(bpobj_open(&dle->dle_bpobj, dl->dl_os,\n\t\t    dle->dle_bpobj.bpo_object));\n\t}\n\tdl->dl_havetree = B_TRUE;\n}\n\n \nstatic void\ndsl_deadlist_load_cache(dsl_deadlist_t *dl)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tint error;\n\n\tASSERT(MUTEX_HELD(&dl->dl_lock));\n\n\tASSERT(!dl->dl_oldfmt);\n\tif (dl->dl_havecache)\n\t\treturn;\n\n\tuint64_t empty_bpobj = dmu_objset_pool(dl->dl_os)->dp_empty_bpobj;\n\n\tavl_create(&dl->dl_cache, dsl_deadlist_cache_compare,\n\t    sizeof (dsl_deadlist_cache_entry_t),\n\t    offsetof(dsl_deadlist_cache_entry_t, dlce_node));\n\tfor (zap_cursor_init(&zc, dl->dl_os, dl->dl_object);\n\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tif (za.za_first_integer == empty_bpobj)\n\t\t\tcontinue;\n\t\tdsl_deadlist_cache_entry_t *dlce =\n\t\t    kmem_zalloc(sizeof (*dlce), KM_SLEEP);\n\t\tdlce->dlce_mintxg = zfs_strtonum(za.za_name, NULL);\n\n\t\t \n\t\tdlce->dlce_bpobj = za.za_first_integer;\n\t\tdmu_prefetch(dl->dl_os, dlce->dlce_bpobj,\n\t\t    0, 0, 0, ZIO_PRIORITY_SYNC_READ);\n\t\tavl_add(&dl->dl_cache, dlce);\n\t}\n\tVERIFY3U(error, ==, ENOENT);\n\tzap_cursor_fini(&zc);\n\n\tfor (dsl_deadlist_cache_entry_t *dlce = avl_first(&dl->dl_cache);\n\t    dlce != NULL; dlce = AVL_NEXT(&dl->dl_cache, dlce)) {\n\t\tbpobj_t bpo;\n\t\tVERIFY0(bpobj_open(&bpo, dl->dl_os, dlce->dlce_bpobj));\n\n\t\tVERIFY0(bpobj_space(&bpo,\n\t\t    &dlce->dlce_bytes, &dlce->dlce_comp, &dlce->dlce_uncomp));\n\t\tbpobj_close(&bpo);\n\t}\n\tdl->dl_havecache = B_TRUE;\n}\n\n \nvoid\ndsl_deadlist_discard_tree(dsl_deadlist_t *dl)\n{\n\tmutex_enter(&dl->dl_lock);\n\n\tif (!dl->dl_havetree) {\n\t\tmutex_exit(&dl->dl_lock);\n\t\treturn;\n\t}\n\tdsl_deadlist_entry_t *dle;\n\tvoid *cookie = NULL;\n\twhile ((dle = avl_destroy_nodes(&dl->dl_tree, &cookie)) != NULL) {\n\t\tbpobj_close(&dle->dle_bpobj);\n\t\tkmem_free(dle, sizeof (*dle));\n\t}\n\tavl_destroy(&dl->dl_tree);\n\n\tdl->dl_havetree = B_FALSE;\n\tmutex_exit(&dl->dl_lock);\n}\n\nvoid\ndsl_deadlist_iterate(dsl_deadlist_t *dl, deadlist_iter_t func, void *args)\n{\n\tdsl_deadlist_entry_t *dle;\n\n\tASSERT(dsl_deadlist_is_open(dl));\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\tmutex_exit(&dl->dl_lock);\n\tfor (dle = avl_first(&dl->dl_tree); dle != NULL;\n\t    dle = AVL_NEXT(&dl->dl_tree, dle)) {\n\t\tif (func(args, dle) != 0)\n\t\t\tbreak;\n\t}\n}\n\nvoid\ndsl_deadlist_open(dsl_deadlist_t *dl, objset_t *os, uint64_t object)\n{\n\tdmu_object_info_t doi;\n\n\tASSERT(!dsl_deadlist_is_open(dl));\n\n\tmutex_init(&dl->dl_lock, NULL, MUTEX_DEFAULT, NULL);\n\tdl->dl_os = os;\n\tdl->dl_object = object;\n\tVERIFY0(dmu_bonus_hold(os, object, dl, &dl->dl_dbuf));\n\tdmu_object_info_from_db(dl->dl_dbuf, &doi);\n\tif (doi.doi_type == DMU_OT_BPOBJ) {\n\t\tdmu_buf_rele(dl->dl_dbuf, dl);\n\t\tdl->dl_dbuf = NULL;\n\t\tdl->dl_oldfmt = B_TRUE;\n\t\tVERIFY0(bpobj_open(&dl->dl_bpobj, os, object));\n\t\treturn;\n\t}\n\n\tdl->dl_oldfmt = B_FALSE;\n\tdl->dl_phys = dl->dl_dbuf->db_data;\n\tdl->dl_havetree = B_FALSE;\n\tdl->dl_havecache = B_FALSE;\n}\n\nboolean_t\ndsl_deadlist_is_open(dsl_deadlist_t *dl)\n{\n\treturn (dl->dl_os != NULL);\n}\n\nvoid\ndsl_deadlist_close(dsl_deadlist_t *dl)\n{\n\tASSERT(dsl_deadlist_is_open(dl));\n\tmutex_destroy(&dl->dl_lock);\n\n\tif (dl->dl_oldfmt) {\n\t\tdl->dl_oldfmt = B_FALSE;\n\t\tbpobj_close(&dl->dl_bpobj);\n\t\tdl->dl_os = NULL;\n\t\tdl->dl_object = 0;\n\t\treturn;\n\t}\n\n\tif (dl->dl_havetree) {\n\t\tdsl_deadlist_entry_t *dle;\n\t\tvoid *cookie = NULL;\n\t\twhile ((dle = avl_destroy_nodes(&dl->dl_tree, &cookie))\n\t\t    != NULL) {\n\t\t\tbpobj_close(&dle->dle_bpobj);\n\t\t\tkmem_free(dle, sizeof (*dle));\n\t\t}\n\t\tavl_destroy(&dl->dl_tree);\n\t}\n\tif (dl->dl_havecache) {\n\t\tdsl_deadlist_cache_entry_t *dlce;\n\t\tvoid *cookie = NULL;\n\t\twhile ((dlce = avl_destroy_nodes(&dl->dl_cache, &cookie))\n\t\t    != NULL) {\n\t\t\tkmem_free(dlce, sizeof (*dlce));\n\t\t}\n\t\tavl_destroy(&dl->dl_cache);\n\t}\n\tdmu_buf_rele(dl->dl_dbuf, dl);\n\tdl->dl_dbuf = NULL;\n\tdl->dl_phys = NULL;\n\tdl->dl_os = NULL;\n\tdl->dl_object = 0;\n}\n\nuint64_t\ndsl_deadlist_alloc(objset_t *os, dmu_tx_t *tx)\n{\n\tif (spa_version(dmu_objset_spa(os)) < SPA_VERSION_DEADLISTS)\n\t\treturn (bpobj_alloc(os, SPA_OLD_MAXBLOCKSIZE, tx));\n\treturn (zap_create(os, DMU_OT_DEADLIST, DMU_OT_DEADLIST_HDR,\n\t    sizeof (dsl_deadlist_phys_t), tx));\n}\n\nvoid\ndsl_deadlist_free(objset_t *os, uint64_t dlobj, dmu_tx_t *tx)\n{\n\tdmu_object_info_t doi;\n\tzap_cursor_t zc;\n\tzap_attribute_t za;\n\tint error;\n\n\tVERIFY0(dmu_object_info(os, dlobj, &doi));\n\tif (doi.doi_type == DMU_OT_BPOBJ) {\n\t\tbpobj_free(os, dlobj, tx);\n\t\treturn;\n\t}\n\n\tfor (zap_cursor_init(&zc, os, dlobj);\n\t    (error = zap_cursor_retrieve(&zc, &za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tuint64_t obj = za.za_first_integer;\n\t\tif (obj == dmu_objset_pool(os)->dp_empty_bpobj)\n\t\t\tbpobj_decr_empty(os, tx);\n\t\telse\n\t\t\tbpobj_free(os, obj, tx);\n\t}\n\tVERIFY3U(error, ==, ENOENT);\n\tzap_cursor_fini(&zc);\n\tVERIFY0(dmu_object_free(os, dlobj, tx));\n}\n\nstatic void\ndle_enqueue(dsl_deadlist_t *dl, dsl_deadlist_entry_t *dle,\n    const blkptr_t *bp, boolean_t bp_freed, dmu_tx_t *tx)\n{\n\tASSERT(MUTEX_HELD(&dl->dl_lock));\n\tif (dle->dle_bpobj.bpo_object ==\n\t    dmu_objset_pool(dl->dl_os)->dp_empty_bpobj) {\n\t\tuint64_t obj = bpobj_alloc(dl->dl_os, SPA_OLD_MAXBLOCKSIZE, tx);\n\t\tbpobj_close(&dle->dle_bpobj);\n\t\tbpobj_decr_empty(dl->dl_os, tx);\n\t\tVERIFY0(bpobj_open(&dle->dle_bpobj, dl->dl_os, obj));\n\t\tVERIFY0(zap_update_int_key(dl->dl_os, dl->dl_object,\n\t\t    dle->dle_mintxg, obj, tx));\n\t}\n\tbpobj_enqueue(&dle->dle_bpobj, bp, bp_freed, tx);\n}\n\nstatic void\ndle_enqueue_subobj(dsl_deadlist_t *dl, dsl_deadlist_entry_t *dle,\n    uint64_t obj, dmu_tx_t *tx)\n{\n\tASSERT(MUTEX_HELD(&dl->dl_lock));\n\tif (dle->dle_bpobj.bpo_object !=\n\t    dmu_objset_pool(dl->dl_os)->dp_empty_bpobj) {\n\t\tbpobj_enqueue_subobj(&dle->dle_bpobj, obj, tx);\n\t} else {\n\t\tbpobj_close(&dle->dle_bpobj);\n\t\tbpobj_decr_empty(dl->dl_os, tx);\n\t\tVERIFY0(bpobj_open(&dle->dle_bpobj, dl->dl_os, obj));\n\t\tVERIFY0(zap_update_int_key(dl->dl_os, dl->dl_object,\n\t\t    dle->dle_mintxg, obj, tx));\n\t}\n}\n\n \nstatic void\ndle_prefetch_subobj(dsl_deadlist_t *dl, dsl_deadlist_entry_t *dle,\n    uint64_t obj)\n{\n\tif (dle->dle_bpobj.bpo_object !=\n\t    dmu_objset_pool(dl->dl_os)->dp_empty_bpobj)\n\t\tbpobj_prefetch_subobj(&dle->dle_bpobj, obj);\n}\n\nvoid\ndsl_deadlist_insert(dsl_deadlist_t *dl, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\tdsl_deadlist_entry_t dle_tofind;\n\tdsl_deadlist_entry_t *dle;\n\tavl_index_t where;\n\n\tif (dl->dl_oldfmt) {\n\t\tbpobj_enqueue(&dl->dl_bpobj, bp, bp_freed, tx);\n\t\treturn;\n\t}\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\n\tdmu_buf_will_dirty(dl->dl_dbuf, tx);\n\n\tint sign = bp_freed ? -1 : +1;\n\tdl->dl_phys->dl_used +=\n\t    sign * bp_get_dsize_sync(dmu_objset_spa(dl->dl_os), bp);\n\tdl->dl_phys->dl_comp += sign * BP_GET_PSIZE(bp);\n\tdl->dl_phys->dl_uncomp += sign * BP_GET_UCSIZE(bp);\n\n\tdle_tofind.dle_mintxg = bp->blk_birth;\n\tdle = avl_find(&dl->dl_tree, &dle_tofind, &where);\n\tif (dle == NULL)\n\t\tdle = avl_nearest(&dl->dl_tree, where, AVL_BEFORE);\n\telse\n\t\tdle = AVL_PREV(&dl->dl_tree, dle);\n\n\tif (dle == NULL) {\n\t\tzfs_panic_recover(\"blkptr at %p has invalid BLK_BIRTH %llu\",\n\t\t    bp, (longlong_t)bp->blk_birth);\n\t\tdle = avl_first(&dl->dl_tree);\n\t}\n\n\tASSERT3P(dle, !=, NULL);\n\tdle_enqueue(dl, dle, bp, bp_freed, tx);\n\tmutex_exit(&dl->dl_lock);\n}\n\nint\ndsl_deadlist_insert_alloc_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\tdsl_deadlist_t *dl = arg;\n\tdsl_deadlist_insert(dl, bp, B_FALSE, tx);\n\treturn (0);\n}\n\nint\ndsl_deadlist_insert_free_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)\n{\n\tdsl_deadlist_t *dl = arg;\n\tdsl_deadlist_insert(dl, bp, B_TRUE, tx);\n\treturn (0);\n}\n\n \nvoid\ndsl_deadlist_add_key(dsl_deadlist_t *dl, uint64_t mintxg, dmu_tx_t *tx)\n{\n\tuint64_t obj;\n\tdsl_deadlist_entry_t *dle;\n\n\tif (dl->dl_oldfmt)\n\t\treturn;\n\n\tdle = kmem_alloc(sizeof (*dle), KM_SLEEP);\n\tdle->dle_mintxg = mintxg;\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\n\tobj = bpobj_alloc_empty(dl->dl_os, SPA_OLD_MAXBLOCKSIZE, tx);\n\tVERIFY0(bpobj_open(&dle->dle_bpobj, dl->dl_os, obj));\n\tavl_add(&dl->dl_tree, dle);\n\n\tVERIFY0(zap_add_int_key(dl->dl_os, dl->dl_object,\n\t    mintxg, obj, tx));\n\tmutex_exit(&dl->dl_lock);\n}\n\n \nvoid\ndsl_deadlist_remove_key(dsl_deadlist_t *dl, uint64_t mintxg, dmu_tx_t *tx)\n{\n\tdsl_deadlist_entry_t dle_tofind;\n\tdsl_deadlist_entry_t *dle, *dle_prev;\n\n\tif (dl->dl_oldfmt)\n\t\treturn;\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\n\tdle_tofind.dle_mintxg = mintxg;\n\tdle = avl_find(&dl->dl_tree, &dle_tofind, NULL);\n\tASSERT3P(dle, !=, NULL);\n\tdle_prev = AVL_PREV(&dl->dl_tree, dle);\n\tASSERT3P(dle_prev, !=, NULL);\n\n\tdle_enqueue_subobj(dl, dle_prev, dle->dle_bpobj.bpo_object, tx);\n\n\tavl_remove(&dl->dl_tree, dle);\n\tbpobj_close(&dle->dle_bpobj);\n\tkmem_free(dle, sizeof (*dle));\n\n\tVERIFY0(zap_remove_int(dl->dl_os, dl->dl_object, mintxg, tx));\n\tmutex_exit(&dl->dl_lock);\n}\n\n \nvoid\ndsl_deadlist_remove_entry(dsl_deadlist_t *dl, uint64_t mintxg, dmu_tx_t *tx)\n{\n\tuint64_t used, comp, uncomp;\n\tdsl_deadlist_entry_t dle_tofind;\n\tdsl_deadlist_entry_t *dle;\n\tobjset_t *os = dl->dl_os;\n\n\tif (dl->dl_oldfmt)\n\t\treturn;\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\n\tdle_tofind.dle_mintxg = mintxg;\n\tdle = avl_find(&dl->dl_tree, &dle_tofind, NULL);\n\tVERIFY3P(dle, !=, NULL);\n\n\tavl_remove(&dl->dl_tree, dle);\n\tVERIFY0(zap_remove_int(os, dl->dl_object, mintxg, tx));\n\tVERIFY0(bpobj_space(&dle->dle_bpobj, &used, &comp, &uncomp));\n\tdmu_buf_will_dirty(dl->dl_dbuf, tx);\n\tdl->dl_phys->dl_used -= used;\n\tdl->dl_phys->dl_comp -= comp;\n\tdl->dl_phys->dl_uncomp -= uncomp;\n\tif (dle->dle_bpobj.bpo_object == dmu_objset_pool(os)->dp_empty_bpobj) {\n\t\tbpobj_decr_empty(os, tx);\n\t} else {\n\t\tbpobj_free(os, dle->dle_bpobj.bpo_object, tx);\n\t}\n\tbpobj_close(&dle->dle_bpobj);\n\tkmem_free(dle, sizeof (*dle));\n\tmutex_exit(&dl->dl_lock);\n}\n\n \nvoid\ndsl_deadlist_clear_entry(dsl_deadlist_entry_t *dle, dsl_deadlist_t *dl,\n    dmu_tx_t *tx)\n{\n\tuint64_t new_obj, used, comp, uncomp;\n\tobjset_t *os = dl->dl_os;\n\n\tmutex_enter(&dl->dl_lock);\n\tVERIFY0(zap_remove_int(os, dl->dl_object, dle->dle_mintxg, tx));\n\tVERIFY0(bpobj_space(&dle->dle_bpobj, &used, &comp, &uncomp));\n\tdmu_buf_will_dirty(dl->dl_dbuf, tx);\n\tdl->dl_phys->dl_used -= used;\n\tdl->dl_phys->dl_comp -= comp;\n\tdl->dl_phys->dl_uncomp -= uncomp;\n\tif (dle->dle_bpobj.bpo_object == dmu_objset_pool(os)->dp_empty_bpobj)\n\t\tbpobj_decr_empty(os, tx);\n\telse\n\t\tbpobj_free(os, dle->dle_bpobj.bpo_object, tx);\n\tbpobj_close(&dle->dle_bpobj);\n\tnew_obj = bpobj_alloc_empty(os, SPA_OLD_MAXBLOCKSIZE, tx);\n\tVERIFY0(bpobj_open(&dle->dle_bpobj, os, new_obj));\n\tVERIFY0(zap_add_int_key(os, dl->dl_object, dle->dle_mintxg,\n\t    new_obj, tx));\n\tASSERT(bpobj_is_empty(&dle->dle_bpobj));\n\tmutex_exit(&dl->dl_lock);\n}\n\n \ndsl_deadlist_entry_t *\ndsl_deadlist_first(dsl_deadlist_t *dl)\n{\n\tdsl_deadlist_entry_t *dle;\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\tdle = avl_first(&dl->dl_tree);\n\tmutex_exit(&dl->dl_lock);\n\n\treturn (dle);\n}\n\n \ndsl_deadlist_entry_t *\ndsl_deadlist_last(dsl_deadlist_t *dl)\n{\n\tdsl_deadlist_entry_t *dle;\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\tdle = avl_last(&dl->dl_tree);\n\tmutex_exit(&dl->dl_lock);\n\n\treturn (dle);\n}\n\n \nstatic void\ndsl_deadlist_regenerate(objset_t *os, uint64_t dlobj,\n    uint64_t mrs_obj, dmu_tx_t *tx)\n{\n\tdsl_deadlist_t dl = { 0 };\n\tdsl_pool_t *dp = dmu_objset_pool(os);\n\n\tdsl_deadlist_open(&dl, os, dlobj);\n\tif (dl.dl_oldfmt) {\n\t\tdsl_deadlist_close(&dl);\n\t\treturn;\n\t}\n\n\twhile (mrs_obj != 0) {\n\t\tdsl_dataset_t *ds;\n\t\tVERIFY0(dsl_dataset_hold_obj(dp, mrs_obj, FTAG, &ds));\n\t\tdsl_deadlist_add_key(&dl,\n\t\t    dsl_dataset_phys(ds)->ds_prev_snap_txg, tx);\n\t\tmrs_obj = dsl_dataset_phys(ds)->ds_prev_snap_obj;\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\tdsl_deadlist_close(&dl);\n}\n\nuint64_t\ndsl_deadlist_clone(dsl_deadlist_t *dl, uint64_t maxtxg,\n    uint64_t mrs_obj, dmu_tx_t *tx)\n{\n\tdsl_deadlist_entry_t *dle;\n\tuint64_t newobj;\n\n\tnewobj = dsl_deadlist_alloc(dl->dl_os, tx);\n\n\tif (dl->dl_oldfmt) {\n\t\tdsl_deadlist_regenerate(dl->dl_os, newobj, mrs_obj, tx);\n\t\treturn (newobj);\n\t}\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_tree(dl);\n\n\tfor (dle = avl_first(&dl->dl_tree); dle;\n\t    dle = AVL_NEXT(&dl->dl_tree, dle)) {\n\t\tuint64_t obj;\n\n\t\tif (dle->dle_mintxg >= maxtxg)\n\t\t\tbreak;\n\n\t\tobj = bpobj_alloc_empty(dl->dl_os, SPA_OLD_MAXBLOCKSIZE, tx);\n\t\tVERIFY0(zap_add_int_key(dl->dl_os, newobj,\n\t\t    dle->dle_mintxg, obj, tx));\n\t}\n\tmutex_exit(&dl->dl_lock);\n\treturn (newobj);\n}\n\nvoid\ndsl_deadlist_space(dsl_deadlist_t *dl,\n    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tASSERT(dsl_deadlist_is_open(dl));\n\tif (dl->dl_oldfmt) {\n\t\tVERIFY0(bpobj_space(&dl->dl_bpobj,\n\t\t    usedp, compp, uncompp));\n\t\treturn;\n\t}\n\n\tmutex_enter(&dl->dl_lock);\n\t*usedp = dl->dl_phys->dl_used;\n\t*compp = dl->dl_phys->dl_comp;\n\t*uncompp = dl->dl_phys->dl_uncomp;\n\tmutex_exit(&dl->dl_lock);\n}\n\n \nvoid\ndsl_deadlist_space_range(dsl_deadlist_t *dl, uint64_t mintxg, uint64_t maxtxg,\n    uint64_t *usedp, uint64_t *compp, uint64_t *uncompp)\n{\n\tdsl_deadlist_cache_entry_t *dlce;\n\tdsl_deadlist_cache_entry_t dlce_tofind;\n\tavl_index_t where;\n\n\tif (dl->dl_oldfmt) {\n\t\tVERIFY0(bpobj_space_range(&dl->dl_bpobj,\n\t\t    mintxg, maxtxg, usedp, compp, uncompp));\n\t\treturn;\n\t}\n\n\t*usedp = *compp = *uncompp = 0;\n\n\tmutex_enter(&dl->dl_lock);\n\tdsl_deadlist_load_cache(dl);\n\tdlce_tofind.dlce_mintxg = mintxg;\n\tdlce = avl_find(&dl->dl_cache, &dlce_tofind, &where);\n\n\t \n\tif (dlce == NULL)\n\t\tdlce = avl_nearest(&dl->dl_cache, where, AVL_AFTER);\n\n\tfor (; dlce && dlce->dlce_mintxg < maxtxg;\n\t    dlce = AVL_NEXT(&dl->dl_tree, dlce)) {\n\t\t*usedp += dlce->dlce_bytes;\n\t\t*compp += dlce->dlce_comp;\n\t\t*uncompp += dlce->dlce_uncomp;\n\t}\n\n\tmutex_exit(&dl->dl_lock);\n}\n\nstatic void\ndsl_deadlist_insert_bpobj(dsl_deadlist_t *dl, uint64_t obj, uint64_t birth,\n    dmu_tx_t *tx)\n{\n\tdsl_deadlist_entry_t dle_tofind;\n\tdsl_deadlist_entry_t *dle;\n\tavl_index_t where;\n\tuint64_t used, comp, uncomp;\n\tbpobj_t bpo;\n\n\tASSERT(MUTEX_HELD(&dl->dl_lock));\n\n\tVERIFY0(bpobj_open(&bpo, dl->dl_os, obj));\n\tVERIFY0(bpobj_space(&bpo, &used, &comp, &uncomp));\n\tbpobj_close(&bpo);\n\n\tdsl_deadlist_load_tree(dl);\n\n\tdmu_buf_will_dirty(dl->dl_dbuf, tx);\n\tdl->dl_phys->dl_used += used;\n\tdl->dl_phys->dl_comp += comp;\n\tdl->dl_phys->dl_uncomp += uncomp;\n\n\tdle_tofind.dle_mintxg = birth;\n\tdle = avl_find(&dl->dl_tree, &dle_tofind, &where);\n\tif (dle == NULL)\n\t\tdle = avl_nearest(&dl->dl_tree, where, AVL_BEFORE);\n\tdle_enqueue_subobj(dl, dle, obj, tx);\n}\n\n \nstatic void\ndsl_deadlist_prefetch_bpobj(dsl_deadlist_t *dl, uint64_t obj, uint64_t birth)\n{\n\tdsl_deadlist_entry_t dle_tofind;\n\tdsl_deadlist_entry_t *dle;\n\tavl_index_t where;\n\n\tASSERT(MUTEX_HELD(&dl->dl_lock));\n\n\tdsl_deadlist_load_tree(dl);\n\n\tdle_tofind.dle_mintxg = birth;\n\tdle = avl_find(&dl->dl_tree, &dle_tofind, &where);\n\tif (dle == NULL)\n\t\tdle = avl_nearest(&dl->dl_tree, where, AVL_BEFORE);\n\tdle_prefetch_subobj(dl, dle, obj);\n}\n\nstatic int\ndsl_deadlist_insert_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\tdsl_deadlist_t *dl = arg;\n\tdsl_deadlist_insert(dl, bp, bp_freed, tx);\n\treturn (0);\n}\n\n \nvoid\ndsl_deadlist_merge(dsl_deadlist_t *dl, uint64_t obj, dmu_tx_t *tx)\n{\n\tzap_cursor_t zc, pzc;\n\tzap_attribute_t *za, *pza;\n\tdmu_buf_t *bonus;\n\tdsl_deadlist_phys_t *dlp;\n\tdmu_object_info_t doi;\n\tint error, perror, i;\n\n\tVERIFY0(dmu_object_info(dl->dl_os, obj, &doi));\n\tif (doi.doi_type == DMU_OT_BPOBJ) {\n\t\tbpobj_t bpo;\n\t\tVERIFY0(bpobj_open(&bpo, dl->dl_os, obj));\n\t\tVERIFY0(bpobj_iterate(&bpo, dsl_deadlist_insert_cb, dl, tx));\n\t\tbpobj_close(&bpo);\n\t\treturn;\n\t}\n\n\tza = kmem_alloc(sizeof (*za), KM_SLEEP);\n\tpza = kmem_alloc(sizeof (*pza), KM_SLEEP);\n\n\tmutex_enter(&dl->dl_lock);\n\t \n\tfor (zap_cursor_init(&pzc, dl->dl_os, obj), i = 0;\n\t    (perror = zap_cursor_retrieve(&pzc, pza)) == 0 && i < 128;\n\t    zap_cursor_advance(&pzc), i++) {\n\t\tdsl_deadlist_prefetch_bpobj(dl, pza->za_first_integer,\n\t\t    zfs_strtonum(pza->za_name, NULL));\n\t}\n\tfor (zap_cursor_init(&zc, dl->dl_os, obj);\n\t    (error = zap_cursor_retrieve(&zc, za)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\tdsl_deadlist_insert_bpobj(dl, za->za_first_integer,\n\t\t    zfs_strtonum(za->za_name, NULL), tx);\n\t\tVERIFY0(zap_remove(dl->dl_os, obj, za->za_name, tx));\n\t\tif (perror == 0) {\n\t\t\tdsl_deadlist_prefetch_bpobj(dl, pza->za_first_integer,\n\t\t\t    zfs_strtonum(pza->za_name, NULL));\n\t\t\tzap_cursor_advance(&pzc);\n\t\t\tperror = zap_cursor_retrieve(&pzc, pza);\n\t\t}\n\t}\n\tVERIFY3U(error, ==, ENOENT);\n\tzap_cursor_fini(&zc);\n\tzap_cursor_fini(&pzc);\n\n\tVERIFY0(dmu_bonus_hold(dl->dl_os, obj, FTAG, &bonus));\n\tdlp = bonus->db_data;\n\tdmu_buf_will_dirty(bonus, tx);\n\tmemset(dlp, 0, sizeof (*dlp));\n\tdmu_buf_rele(bonus, FTAG);\n\tmutex_exit(&dl->dl_lock);\n\n\tkmem_free(za, sizeof (*za));\n\tkmem_free(pza, sizeof (*pza));\n}\n\n \nvoid\ndsl_deadlist_move_bpobj(dsl_deadlist_t *dl, bpobj_t *bpo, uint64_t mintxg,\n    dmu_tx_t *tx)\n{\n\tdsl_deadlist_entry_t dle_tofind;\n\tdsl_deadlist_entry_t *dle, *pdle;\n\tavl_index_t where;\n\tint i;\n\n\tASSERT(!dl->dl_oldfmt);\n\n\tmutex_enter(&dl->dl_lock);\n\tdmu_buf_will_dirty(dl->dl_dbuf, tx);\n\tdsl_deadlist_load_tree(dl);\n\n\tdle_tofind.dle_mintxg = mintxg;\n\tdle = avl_find(&dl->dl_tree, &dle_tofind, &where);\n\tif (dle == NULL)\n\t\tdle = avl_nearest(&dl->dl_tree, where, AVL_AFTER);\n\t \n\tfor (pdle = dle, i = 0; pdle && i < 128; i++) {\n\t\tbpobj_prefetch_subobj(bpo, pdle->dle_bpobj.bpo_object);\n\t\tpdle = AVL_NEXT(&dl->dl_tree, pdle);\n\t}\n\twhile (dle) {\n\t\tuint64_t used, comp, uncomp;\n\t\tdsl_deadlist_entry_t *dle_next;\n\n\t\tbpobj_enqueue_subobj(bpo, dle->dle_bpobj.bpo_object, tx);\n\t\tif (pdle) {\n\t\t\tbpobj_prefetch_subobj(bpo, pdle->dle_bpobj.bpo_object);\n\t\t\tpdle = AVL_NEXT(&dl->dl_tree, pdle);\n\t\t}\n\n\t\tVERIFY0(bpobj_space(&dle->dle_bpobj,\n\t\t    &used, &comp, &uncomp));\n\t\tASSERT3U(dl->dl_phys->dl_used, >=, used);\n\t\tASSERT3U(dl->dl_phys->dl_comp, >=, comp);\n\t\tASSERT3U(dl->dl_phys->dl_uncomp, >=, uncomp);\n\t\tdl->dl_phys->dl_used -= used;\n\t\tdl->dl_phys->dl_comp -= comp;\n\t\tdl->dl_phys->dl_uncomp -= uncomp;\n\n\t\tVERIFY0(zap_remove_int(dl->dl_os, dl->dl_object,\n\t\t    dle->dle_mintxg, tx));\n\n\t\tdle_next = AVL_NEXT(&dl->dl_tree, dle);\n\t\tavl_remove(&dl->dl_tree, dle);\n\t\tbpobj_close(&dle->dle_bpobj);\n\t\tkmem_free(dle, sizeof (*dle));\n\t\tdle = dle_next;\n\t}\n\tmutex_exit(&dl->dl_lock);\n}\n\ntypedef struct livelist_entry {\n\tblkptr_t le_bp;\n\tuint32_t le_refcnt;\n\tavl_node_t le_node;\n} livelist_entry_t;\n\nstatic int\nlivelist_compare(const void *larg, const void *rarg)\n{\n\tconst blkptr_t *l = &((livelist_entry_t *)larg)->le_bp;\n\tconst blkptr_t *r = &((livelist_entry_t *)rarg)->le_bp;\n\n\t \n\tuint64_t l_dva0_vdev = DVA_GET_VDEV(&l->blk_dva[0]);\n\tuint64_t r_dva0_vdev = DVA_GET_VDEV(&r->blk_dva[0]);\n\n\tif (l_dva0_vdev != r_dva0_vdev)\n\t\treturn (TREE_CMP(l_dva0_vdev, r_dva0_vdev));\n\n\t \n\tuint64_t l_dva0_offset = DVA_GET_OFFSET(&l->blk_dva[0]);\n\tuint64_t r_dva0_offset = DVA_GET_OFFSET(&r->blk_dva[0]);\n\tif (l_dva0_offset == r_dva0_offset)\n\t\tASSERT3U(l->blk_birth, ==, r->blk_birth);\n\treturn (TREE_CMP(l_dva0_offset, r_dva0_offset));\n}\n\nstruct livelist_iter_arg {\n\tavl_tree_t *avl;\n\tbplist_t *to_free;\n\tzthr_t *t;\n};\n\n \nstatic int\ndsl_livelist_iterate(void *arg, const blkptr_t *bp, boolean_t bp_freed,\n    dmu_tx_t *tx)\n{\n\tstruct livelist_iter_arg *lia = arg;\n\tavl_tree_t *avl = lia->avl;\n\tbplist_t *to_free = lia->to_free;\n\tzthr_t *t = lia->t;\n\tASSERT(tx == NULL);\n\n\tif ((t != NULL) && (zthr_has_waiters(t) || zthr_iscancelled(t)))\n\t\treturn (SET_ERROR(EINTR));\n\n\tlivelist_entry_t node;\n\tnode.le_bp = *bp;\n\tlivelist_entry_t *found = avl_find(avl, &node, NULL);\n\tif (bp_freed) {\n\t\tif (found == NULL) {\n\t\t\t \n\t\t\tlivelist_entry_t *e =\n\t\t\t    kmem_alloc(sizeof (livelist_entry_t), KM_SLEEP);\n\t\t\te->le_bp = *bp;\n\t\t\te->le_refcnt = 1;\n\t\t\tavl_add(avl, e);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT(BP_GET_DEDUP(bp));\n\t\t\tASSERT3U(BP_GET_CHECKSUM(bp), ==,\n\t\t\t    BP_GET_CHECKSUM(&found->le_bp));\n\t\t\tASSERT3U(found->le_refcnt + 1, >, found->le_refcnt);\n\t\t\tfound->le_refcnt++;\n\t\t}\n\t} else {\n\t\tif (found == NULL) {\n\t\t\t \n\t\t\tbplist_append(to_free, bp);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT3U(found->le_refcnt, !=, 0);\n\t\t\tfound->le_refcnt--;\n\t\t\tif (found->le_refcnt == 0) {\n\t\t\t\t \n\t\t\t\tavl_remove(avl, found);\n\t\t\t\tkmem_free(found, sizeof (livelist_entry_t));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tASSERT(BP_GET_DEDUP(bp));\n\t\t\t\tASSERT3U(BP_GET_CHECKSUM(bp), ==,\n\t\t\t\t    BP_GET_CHECKSUM(&found->le_bp));\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nint\ndsl_process_sub_livelist(bpobj_t *bpobj, bplist_t *to_free, zthr_t *t,\n    uint64_t *size)\n{\n\tavl_tree_t avl;\n\tavl_create(&avl, livelist_compare, sizeof (livelist_entry_t),\n\t    offsetof(livelist_entry_t, le_node));\n\n\t \n\tstruct livelist_iter_arg arg = {\n\t    .avl = &avl,\n\t    .to_free = to_free,\n\t    .t = t\n\t};\n\tint err = bpobj_iterate_nofree(bpobj, dsl_livelist_iterate, &arg, size);\n\tVERIFY(err != 0 || avl_numnodes(&avl) == 0);\n\n\tvoid *cookie = NULL;\n\tlivelist_entry_t *le = NULL;\n\twhile ((le = avl_destroy_nodes(&avl, &cookie)) != NULL) {\n\t\tkmem_free(le, sizeof (livelist_entry_t));\n\t}\n\tavl_destroy(&avl);\n\treturn (err);\n}\n\nZFS_MODULE_PARAM(zfs_livelist, zfs_livelist_, max_entries, U64, ZMOD_RW,\n\t\"Size to start the next sub-livelist in a livelist\");\n\nZFS_MODULE_PARAM(zfs_livelist, zfs_livelist_, min_percent_shared, INT, ZMOD_RW,\n\t\"Threshold at which livelist is disabled\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}