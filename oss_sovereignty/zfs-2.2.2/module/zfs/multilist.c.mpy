{
  "module_name": "multilist.c",
  "hash_id": "49861fdd444228655e2df401bb4d0000fff5f70008acd2119189890dceab2305",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/multilist.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/multilist.h>\n#include <sys/trace_zfs.h>\n\n \nuint_t zfs_multilist_num_sublists = 0;\n\n \n#ifdef ZFS_DEBUG\nstatic multilist_node_t *\nmultilist_d2l(multilist_t *ml, void *obj)\n{\n\treturn ((multilist_node_t *)((char *)obj + ml->ml_offset));\n}\n#else\n#define\tmultilist_d2l(ml, obj) ((void) sizeof (ml), (void) sizeof (obj), NULL)\n#endif\n\n \nstatic void\nmultilist_create_impl(multilist_t *ml, size_t size, size_t offset,\n    uint_t num, multilist_sublist_index_func_t *index_func)\n{\n\tASSERT3U(size, >, 0);\n\tASSERT3U(size, >=, offset + sizeof (multilist_node_t));\n\tASSERT3U(num, >, 0);\n\tASSERT3P(index_func, !=, NULL);\n\n\tml->ml_offset = offset;\n\tml->ml_num_sublists = num;\n\tml->ml_index_func = index_func;\n\n\tml->ml_sublists = kmem_zalloc(sizeof (multilist_sublist_t) *\n\t    ml->ml_num_sublists, KM_SLEEP);\n\n\tASSERT3P(ml->ml_sublists, !=, NULL);\n\n\tfor (int i = 0; i < ml->ml_num_sublists; i++) {\n\t\tmultilist_sublist_t *mls = &ml->ml_sublists[i];\n\t\tmutex_init(&mls->mls_lock, NULL, MUTEX_NOLOCKDEP, NULL);\n\t\tlist_create(&mls->mls_list, size, offset);\n\t}\n}\n\n \nvoid\nmultilist_create(multilist_t *ml, size_t size, size_t offset,\n    multilist_sublist_index_func_t *index_func)\n{\n\tuint_t num_sublists;\n\n\tif (zfs_multilist_num_sublists > 0) {\n\t\tnum_sublists = zfs_multilist_num_sublists;\n\t} else {\n\t\tnum_sublists = MAX(boot_ncpus, 4);\n\t}\n\n\tmultilist_create_impl(ml, size, offset, num_sublists, index_func);\n}\n\n \nvoid\nmultilist_destroy(multilist_t *ml)\n{\n\tASSERT(multilist_is_empty(ml));\n\n\tfor (int i = 0; i < ml->ml_num_sublists; i++) {\n\t\tmultilist_sublist_t *mls = &ml->ml_sublists[i];\n\n\t\tASSERT(list_is_empty(&mls->mls_list));\n\n\t\tlist_destroy(&mls->mls_list);\n\t\tmutex_destroy(&mls->mls_lock);\n\t}\n\n\tASSERT3P(ml->ml_sublists, !=, NULL);\n\tkmem_free(ml->ml_sublists,\n\t    sizeof (multilist_sublist_t) * ml->ml_num_sublists);\n\n\tml->ml_num_sublists = 0;\n\tml->ml_offset = 0;\n\tml->ml_sublists = NULL;\n}\n\n \nvoid\nmultilist_insert(multilist_t *ml, void *obj)\n{\n\tunsigned int sublist_idx = ml->ml_index_func(ml, obj);\n\tmultilist_sublist_t *mls;\n\tboolean_t need_lock;\n\n\tDTRACE_PROBE3(multilist__insert, multilist_t *, ml,\n\t    unsigned int, sublist_idx, void *, obj);\n\n\tASSERT3U(sublist_idx, <, ml->ml_num_sublists);\n\n\tmls = &ml->ml_sublists[sublist_idx];\n\n\t \n\tneed_lock = !MUTEX_HELD(&mls->mls_lock);\n\n\tif (need_lock)\n\t\tmutex_enter(&mls->mls_lock);\n\n\tASSERT(!multilist_link_active(multilist_d2l(ml, obj)));\n\n\tmultilist_sublist_insert_head(mls, obj);\n\n\tif (need_lock)\n\t\tmutex_exit(&mls->mls_lock);\n}\n\n \nvoid\nmultilist_remove(multilist_t *ml, void *obj)\n{\n\tunsigned int sublist_idx = ml->ml_index_func(ml, obj);\n\tmultilist_sublist_t *mls;\n\tboolean_t need_lock;\n\n\tDTRACE_PROBE3(multilist__remove, multilist_t *, ml,\n\t    unsigned int, sublist_idx, void *, obj);\n\n\tASSERT3U(sublist_idx, <, ml->ml_num_sublists);\n\n\tmls = &ml->ml_sublists[sublist_idx];\n\t \n\tneed_lock = !MUTEX_HELD(&mls->mls_lock);\n\n\tif (need_lock)\n\t\tmutex_enter(&mls->mls_lock);\n\n\tASSERT(multilist_link_active(multilist_d2l(ml, obj)));\n\n\tmultilist_sublist_remove(mls, obj);\n\n\tif (need_lock)\n\t\tmutex_exit(&mls->mls_lock);\n}\n\n \nint\nmultilist_is_empty(multilist_t *ml)\n{\n\tfor (int i = 0; i < ml->ml_num_sublists; i++) {\n\t\tmultilist_sublist_t *mls = &ml->ml_sublists[i];\n\t\t \n\t\tboolean_t need_lock = !MUTEX_HELD(&mls->mls_lock);\n\n\t\tif (need_lock)\n\t\t\tmutex_enter(&mls->mls_lock);\n\n\t\tif (!list_is_empty(&mls->mls_list)) {\n\t\t\tif (need_lock)\n\t\t\t\tmutex_exit(&mls->mls_lock);\n\n\t\t\treturn (FALSE);\n\t\t}\n\n\t\tif (need_lock)\n\t\t\tmutex_exit(&mls->mls_lock);\n\t}\n\n\treturn (TRUE);\n}\n\n \nunsigned int\nmultilist_get_num_sublists(multilist_t *ml)\n{\n\treturn (ml->ml_num_sublists);\n}\n\n \nunsigned int\nmultilist_get_random_index(multilist_t *ml)\n{\n\treturn (random_in_range(ml->ml_num_sublists));\n}\n\n \nmultilist_sublist_t *\nmultilist_sublist_lock(multilist_t *ml, unsigned int sublist_idx)\n{\n\tmultilist_sublist_t *mls;\n\n\tASSERT3U(sublist_idx, <, ml->ml_num_sublists);\n\tmls = &ml->ml_sublists[sublist_idx];\n\tmutex_enter(&mls->mls_lock);\n\n\treturn (mls);\n}\n\n \nmultilist_sublist_t *\nmultilist_sublist_lock_obj(multilist_t *ml, void *obj)\n{\n\treturn (multilist_sublist_lock(ml, ml->ml_index_func(ml, obj)));\n}\n\nvoid\nmultilist_sublist_unlock(multilist_sublist_t *mls)\n{\n\tmutex_exit(&mls->mls_lock);\n}\n\n \nvoid\nmultilist_sublist_insert_head(multilist_sublist_t *mls, void *obj)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\tlist_insert_head(&mls->mls_list, obj);\n}\n\n \nvoid\nmultilist_sublist_insert_tail(multilist_sublist_t *mls, void *obj)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\tlist_insert_tail(&mls->mls_list, obj);\n}\n\n \nvoid\nmultilist_sublist_move_forward(multilist_sublist_t *mls, void *obj)\n{\n\tvoid *prev = list_prev(&mls->mls_list, obj);\n\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\tASSERT(!list_is_empty(&mls->mls_list));\n\n\t \n\tif (prev == NULL)\n\t\treturn;\n\n\tlist_remove(&mls->mls_list, obj);\n\tlist_insert_before(&mls->mls_list, prev, obj);\n}\n\nvoid\nmultilist_sublist_remove(multilist_sublist_t *mls, void *obj)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\tlist_remove(&mls->mls_list, obj);\n}\n\nint\nmultilist_sublist_is_empty(multilist_sublist_t *mls)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\treturn (list_is_empty(&mls->mls_list));\n}\n\nint\nmultilist_sublist_is_empty_idx(multilist_t *ml, unsigned int sublist_idx)\n{\n\tmultilist_sublist_t *mls;\n\tint empty;\n\n\tASSERT3U(sublist_idx, <, ml->ml_num_sublists);\n\tmls = &ml->ml_sublists[sublist_idx];\n\tASSERT(!MUTEX_HELD(&mls->mls_lock));\n\tmutex_enter(&mls->mls_lock);\n\tempty = list_is_empty(&mls->mls_list);\n\tmutex_exit(&mls->mls_lock);\n\treturn (empty);\n}\n\nvoid *\nmultilist_sublist_head(multilist_sublist_t *mls)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\treturn (list_head(&mls->mls_list));\n}\n\nvoid *\nmultilist_sublist_tail(multilist_sublist_t *mls)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\treturn (list_tail(&mls->mls_list));\n}\n\nvoid *\nmultilist_sublist_next(multilist_sublist_t *mls, void *obj)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\treturn (list_next(&mls->mls_list, obj));\n}\n\nvoid *\nmultilist_sublist_prev(multilist_sublist_t *mls, void *obj)\n{\n\tASSERT(MUTEX_HELD(&mls->mls_lock));\n\treturn (list_prev(&mls->mls_list, obj));\n}\n\nvoid\nmultilist_link_init(multilist_node_t *link)\n{\n\tlist_link_init(link);\n}\n\nint\nmultilist_link_active(multilist_node_t *link)\n{\n\treturn (list_link_active(link));\n}\n\nZFS_MODULE_PARAM(zfs, zfs_, multilist_num_sublists, UINT, ZMOD_RW,\n\t\"Number of sublists used in each multilist\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}