{
  "module_name": "fm.c",
  "hash_id": "351bd28709a65651d6d84a300bf257cb64fb3385091959f47e490a39b06e85d9",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/fm.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/list.h>\n#include <sys/nvpair.h>\n#include <sys/cmn_err.h>\n#include <sys/sysmacros.h>\n#include <sys/sunddi.h>\n#include <sys/systeminfo.h>\n#include <sys/fm/util.h>\n#include <sys/fm/protocol.h>\n#include <sys/kstat.h>\n#include <sys/zfs_context.h>\n#ifdef _KERNEL\n#include <sys/atomic.h>\n#include <sys/condvar.h>\n#include <sys/zfs_ioctl.h>\n\nstatic uint_t zfs_zevent_len_max = 512;\n\nstatic uint_t zevent_len_cur = 0;\nstatic int zevent_waiters = 0;\nstatic int zevent_flags = 0;\n\n \nstatic uint64_t ratelimit_dropped = 0;\n\n \nstatic uint64_t zevent_eid = 0;\n\nstatic kmutex_t zevent_lock;\nstatic list_t zevent_list;\nstatic kcondvar_t zevent_cv;\n#endif  \n\n\n \n\nstruct erpt_kstat {\n\tkstat_named_t\terpt_dropped;\t\t \n\tkstat_named_t\terpt_set_failed;\t \n\tkstat_named_t\tfmri_set_failed;\t \n\tkstat_named_t\tpayload_set_failed;\t \n\tkstat_named_t\terpt_duplicates;\t \n};\n\nstatic struct erpt_kstat erpt_kstat_data = {\n\t{ \"erpt-dropped\", KSTAT_DATA_UINT64 },\n\t{ \"erpt-set-failed\", KSTAT_DATA_UINT64 },\n\t{ \"fmri-set-failed\", KSTAT_DATA_UINT64 },\n\t{ \"payload-set-failed\", KSTAT_DATA_UINT64 },\n\t{ \"erpt-duplicates\", KSTAT_DATA_UINT64 }\n};\n\nkstat_t *fm_ksp;\n\n#ifdef _KERNEL\n\nstatic zevent_t *\nzfs_zevent_alloc(void)\n{\n\tzevent_t *ev;\n\n\tev = kmem_zalloc(sizeof (zevent_t), KM_SLEEP);\n\n\tlist_create(&ev->ev_ze_list, sizeof (zfs_zevent_t),\n\t    offsetof(zfs_zevent_t, ze_node));\n\tlist_link_init(&ev->ev_node);\n\n\treturn (ev);\n}\n\nstatic void\nzfs_zevent_free(zevent_t *ev)\n{\n\t \n\tev->ev_cb(ev->ev_nvl, ev->ev_detector);\n\n\tlist_destroy(&ev->ev_ze_list);\n\tkmem_free(ev, sizeof (zevent_t));\n}\n\nstatic void\nzfs_zevent_drain(zevent_t *ev)\n{\n\tzfs_zevent_t *ze;\n\n\tASSERT(MUTEX_HELD(&zevent_lock));\n\tlist_remove(&zevent_list, ev);\n\n\t \n\twhile ((ze = list_remove_head(&ev->ev_ze_list)) != NULL) {\n\t\tze->ze_zevent = NULL;\n\t\tze->ze_dropped++;\n\t}\n\n\tzfs_zevent_free(ev);\n}\n\nvoid\nzfs_zevent_drain_all(uint_t *count)\n{\n\tzevent_t *ev;\n\n\tmutex_enter(&zevent_lock);\n\twhile ((ev = list_head(&zevent_list)) != NULL)\n\t\tzfs_zevent_drain(ev);\n\n\t*count = zevent_len_cur;\n\tzevent_len_cur = 0;\n\tmutex_exit(&zevent_lock);\n}\n\n \nstatic void\nzfs_zevent_insert(zevent_t *ev)\n{\n\tASSERT(MUTEX_HELD(&zevent_lock));\n\tlist_insert_head(&zevent_list, ev);\n\n\tif (zevent_len_cur >= zfs_zevent_len_max)\n\t\tzfs_zevent_drain(list_tail(&zevent_list));\n\telse\n\t\tzevent_len_cur++;\n}\n\n \nint\nzfs_zevent_post(nvlist_t *nvl, nvlist_t *detector, zevent_cb_t *cb)\n{\n\tinode_timespec_t tv;\n\tint64_t tv_array[2];\n\tuint64_t eid;\n\tsize_t nvl_size = 0;\n\tzevent_t *ev;\n\tint error;\n\n\tASSERT(cb != NULL);\n\n\tgethrestime(&tv);\n\ttv_array[0] = tv.tv_sec;\n\ttv_array[1] = tv.tv_nsec;\n\n\terror = nvlist_add_int64_array(nvl, FM_EREPORT_TIME, tv_array, 2);\n\tif (error) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n\t\tgoto out;\n\t}\n\n\teid = atomic_inc_64_nv(&zevent_eid);\n\terror = nvlist_add_uint64(nvl, FM_EREPORT_EID, eid);\n\tif (error) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n\t\tgoto out;\n\t}\n\n\terror = nvlist_size(nvl, &nvl_size, NV_ENCODE_NATIVE);\n\tif (error) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_dropped.value.ui64);\n\t\tgoto out;\n\t}\n\n\tif (nvl_size > ERPT_DATA_SZ || nvl_size == 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_dropped.value.ui64);\n\t\terror = EOVERFLOW;\n\t\tgoto out;\n\t}\n\n\tev = zfs_zevent_alloc();\n\tif (ev == NULL) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_dropped.value.ui64);\n\t\terror = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tev->ev_nvl = nvl;\n\tev->ev_detector = detector;\n\tev->ev_cb = cb;\n\tev->ev_eid = eid;\n\n\tmutex_enter(&zevent_lock);\n\tzfs_zevent_insert(ev);\n\tcv_broadcast(&zevent_cv);\n\tmutex_exit(&zevent_lock);\n\nout:\n\tif (error)\n\t\tcb(nvl, detector);\n\n\treturn (error);\n}\n\nvoid\nzfs_zevent_track_duplicate(void)\n{\n\tatomic_inc_64(&erpt_kstat_data.erpt_duplicates.value.ui64);\n}\n\nstatic int\nzfs_zevent_minor_to_state(minor_t minor, zfs_zevent_t **ze)\n{\n\t*ze = zfsdev_get_state(minor, ZST_ZEVENT);\n\tif (*ze == NULL)\n\t\treturn (SET_ERROR(EBADF));\n\n\treturn (0);\n}\n\nzfs_file_t *\nzfs_zevent_fd_hold(int fd, minor_t *minorp, zfs_zevent_t **ze)\n{\n\tzfs_file_t *fp = zfs_file_get(fd);\n\tif (fp == NULL)\n\t\treturn (NULL);\n\n\tint error = zfsdev_getminor(fp, minorp);\n\tif (error == 0)\n\t\terror = zfs_zevent_minor_to_state(*minorp, ze);\n\n\tif (error) {\n\t\tzfs_zevent_fd_rele(fp);\n\t\tfp = NULL;\n\t}\n\n\treturn (fp);\n}\n\nvoid\nzfs_zevent_fd_rele(zfs_file_t *fp)\n{\n\tzfs_file_put(fp);\n}\n\n \nint\nzfs_zevent_next(zfs_zevent_t *ze, nvlist_t **event, uint64_t *event_size,\n    uint64_t *dropped)\n{\n\tzevent_t *ev;\n\tsize_t size;\n\tint error = 0;\n\n\tmutex_enter(&zevent_lock);\n\tif (ze->ze_zevent == NULL) {\n\t\t \n\t\tev = list_tail(&zevent_list);\n\t\tif (ev == NULL) {\n\t\t\terror = ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tev = list_prev(&zevent_list, ze->ze_zevent);\n\t\tif (ev == NULL) {\n\t\t\terror = ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tVERIFY(nvlist_size(ev->ev_nvl, &size, NV_ENCODE_NATIVE) == 0);\n\tif (size > *event_size) {\n\t\t*event_size = size;\n\t\terror = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (ze->ze_zevent)\n\t\tlist_remove(&ze->ze_zevent->ev_ze_list, ze);\n\n\tze->ze_zevent = ev;\n\tlist_insert_head(&ev->ev_ze_list, ze);\n\t(void) nvlist_dup(ev->ev_nvl, event, KM_SLEEP);\n\t*dropped = ze->ze_dropped;\n\n#ifdef _KERNEL\n\t \n\t*dropped += atomic_swap_64(&ratelimit_dropped, 0);\n#endif\n\tze->ze_dropped = 0;\nout:\n\tmutex_exit(&zevent_lock);\n\n\treturn (error);\n}\n\n \nint\nzfs_zevent_wait(zfs_zevent_t *ze)\n{\n\tint error = EAGAIN;\n\n\tmutex_enter(&zevent_lock);\n\tzevent_waiters++;\n\n\twhile (error == EAGAIN) {\n\t\tif (zevent_flags & ZEVENT_SHUTDOWN) {\n\t\t\terror = SET_ERROR(ESHUTDOWN);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cv_wait_sig(&zevent_cv, &zevent_lock) == 0) {\n\t\t\terror = SET_ERROR(EINTR);\n\t\t\tbreak;\n\t\t} else if (!list_is_empty(&zevent_list)) {\n\t\t\terror = 0;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\terror = EAGAIN;\n\t\t}\n\t}\n\n\tzevent_waiters--;\n\tmutex_exit(&zevent_lock);\n\n\treturn (error);\n}\n\n \nint\nzfs_zevent_seek(zfs_zevent_t *ze, uint64_t eid)\n{\n\tzevent_t *ev;\n\tint error = 0;\n\n\tmutex_enter(&zevent_lock);\n\n\tif (eid == ZEVENT_SEEK_START) {\n\t\tif (ze->ze_zevent)\n\t\t\tlist_remove(&ze->ze_zevent->ev_ze_list, ze);\n\n\t\tze->ze_zevent = NULL;\n\t\tgoto out;\n\t}\n\n\tif (eid == ZEVENT_SEEK_END) {\n\t\tif (ze->ze_zevent)\n\t\t\tlist_remove(&ze->ze_zevent->ev_ze_list, ze);\n\n\t\tev = list_head(&zevent_list);\n\t\tif (ev) {\n\t\t\tze->ze_zevent = ev;\n\t\t\tlist_insert_head(&ev->ev_ze_list, ze);\n\t\t} else {\n\t\t\tze->ze_zevent = NULL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tfor (ev = list_tail(&zevent_list); ev != NULL;\n\t    ev = list_prev(&zevent_list, ev)) {\n\t\tif (ev->ev_eid == eid) {\n\t\t\tif (ze->ze_zevent)\n\t\t\t\tlist_remove(&ze->ze_zevent->ev_ze_list, ze);\n\n\t\t\tze->ze_zevent = ev;\n\t\t\tlist_insert_head(&ev->ev_ze_list, ze);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ev == NULL)\n\t\terror = ENOENT;\n\nout:\n\tmutex_exit(&zevent_lock);\n\n\treturn (error);\n}\n\nvoid\nzfs_zevent_init(zfs_zevent_t **zep)\n{\n\tzfs_zevent_t *ze;\n\n\tze = *zep = kmem_zalloc(sizeof (zfs_zevent_t), KM_SLEEP);\n\tlist_link_init(&ze->ze_node);\n}\n\nvoid\nzfs_zevent_destroy(zfs_zevent_t *ze)\n{\n\tmutex_enter(&zevent_lock);\n\tif (ze->ze_zevent)\n\t\tlist_remove(&ze->ze_zevent->ev_ze_list, ze);\n\tmutex_exit(&zevent_lock);\n\n\tkmem_free(ze, sizeof (zfs_zevent_t));\n}\n#endif  \n\n \nstatic void *\ni_fm_alloc(nv_alloc_t *nva, size_t size)\n{\n\t(void) nva;\n\treturn (kmem_alloc(size, KM_SLEEP));\n}\n\nstatic void\ni_fm_free(nv_alloc_t *nva, void *buf, size_t size)\n{\n\t(void) nva;\n\tkmem_free(buf, size);\n}\n\nstatic const nv_alloc_ops_t fm_mem_alloc_ops = {\n\t.nv_ao_init = NULL,\n\t.nv_ao_fini = NULL,\n\t.nv_ao_alloc = i_fm_alloc,\n\t.nv_ao_free = i_fm_free,\n\t.nv_ao_reset = NULL\n};\n\n \nnv_alloc_t *\nfm_nva_xcreate(char *buf, size_t bufsz)\n{\n\tnv_alloc_t *nvhdl = kmem_zalloc(sizeof (nv_alloc_t), KM_SLEEP);\n\n\tif (bufsz == 0 || nv_alloc_init(nvhdl, nv_fixed_ops, buf, bufsz) != 0) {\n\t\tkmem_free(nvhdl, sizeof (nv_alloc_t));\n\t\treturn (NULL);\n\t}\n\n\treturn (nvhdl);\n}\n\n \nvoid\nfm_nva_xdestroy(nv_alloc_t *nva)\n{\n\tnv_alloc_fini(nva);\n\tkmem_free(nva, sizeof (nv_alloc_t));\n}\n\n \nnvlist_t *\nfm_nvlist_create(nv_alloc_t *nva)\n{\n\tint hdl_alloced = 0;\n\tnvlist_t *nvl;\n\tnv_alloc_t *nvhdl;\n\n\tif (nva == NULL) {\n\t\tnvhdl = kmem_zalloc(sizeof (nv_alloc_t), KM_SLEEP);\n\n\t\tif (nv_alloc_init(nvhdl, &fm_mem_alloc_ops, NULL, 0) != 0) {\n\t\t\tkmem_free(nvhdl, sizeof (nv_alloc_t));\n\t\t\treturn (NULL);\n\t\t}\n\t\thdl_alloced = 1;\n\t} else {\n\t\tnvhdl = nva;\n\t}\n\n\tif (nvlist_xalloc(&nvl, NV_UNIQUE_NAME, nvhdl) != 0) {\n\t\tif (hdl_alloced) {\n\t\t\tnv_alloc_fini(nvhdl);\n\t\t\tkmem_free(nvhdl, sizeof (nv_alloc_t));\n\t\t}\n\t\treturn (NULL);\n\t}\n\n\treturn (nvl);\n}\n\n \nvoid\nfm_nvlist_destroy(nvlist_t *nvl, int flag)\n{\n\tnv_alloc_t *nva = nvlist_lookup_nv_alloc(nvl);\n\n\tnvlist_free(nvl);\n\n\tif (nva != NULL) {\n\t\tif (flag == FM_NVA_FREE)\n\t\t\tfm_nva_xdestroy(nva);\n\t}\n}\n\nint\ni_fm_payload_set(nvlist_t *payload, const char *name, va_list ap)\n{\n\tint nelem, ret = 0;\n\tdata_type_t type;\n\n\twhile (ret == 0 && name != NULL) {\n\t\ttype = va_arg(ap, data_type_t);\n\t\tswitch (type) {\n\t\tcase DATA_TYPE_BYTE:\n\t\t\tret = nvlist_add_byte(payload, name,\n\t\t\t    va_arg(ap, uint_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_BYTE_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_byte_array(payload, name,\n\t\t\t    va_arg(ap, uchar_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_BOOLEAN_VALUE:\n\t\t\tret = nvlist_add_boolean_value(payload, name,\n\t\t\t    va_arg(ap, boolean_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_BOOLEAN_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_boolean_array(payload, name,\n\t\t\t    va_arg(ap, boolean_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT8:\n\t\t\tret = nvlist_add_int8(payload, name,\n\t\t\t    va_arg(ap, int));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT8_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_int8_array(payload, name,\n\t\t\t    va_arg(ap, int8_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT8:\n\t\t\tret = nvlist_add_uint8(payload, name,\n\t\t\t    va_arg(ap, uint_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT8_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_uint8_array(payload, name,\n\t\t\t    va_arg(ap, uint8_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT16:\n\t\t\tret = nvlist_add_int16(payload, name,\n\t\t\t    va_arg(ap, int));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT16_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_int16_array(payload, name,\n\t\t\t    va_arg(ap, int16_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT16:\n\t\t\tret = nvlist_add_uint16(payload, name,\n\t\t\t    va_arg(ap, uint_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT16_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_uint16_array(payload, name,\n\t\t\t    va_arg(ap, uint16_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT32:\n\t\t\tret = nvlist_add_int32(payload, name,\n\t\t\t    va_arg(ap, int32_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT32_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_int32_array(payload, name,\n\t\t\t    va_arg(ap, int32_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT32:\n\t\t\tret = nvlist_add_uint32(payload, name,\n\t\t\t    va_arg(ap, uint32_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT32_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_uint32_array(payload, name,\n\t\t\t    va_arg(ap, uint32_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT64:\n\t\t\tret = nvlist_add_int64(payload, name,\n\t\t\t    va_arg(ap, int64_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_INT64_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_int64_array(payload, name,\n\t\t\t    va_arg(ap, int64_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT64:\n\t\t\tret = nvlist_add_uint64(payload, name,\n\t\t\t    va_arg(ap, uint64_t));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_UINT64_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_uint64_array(payload, name,\n\t\t\t    va_arg(ap, uint64_t *), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_STRING:\n\t\t\tret = nvlist_add_string(payload, name,\n\t\t\t    va_arg(ap, char *));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_STRING_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_string_array(payload, name,\n\t\t\t    va_arg(ap, const char **), nelem);\n\t\t\tbreak;\n\t\tcase DATA_TYPE_NVLIST:\n\t\t\tret = nvlist_add_nvlist(payload, name,\n\t\t\t    va_arg(ap, nvlist_t *));\n\t\t\tbreak;\n\t\tcase DATA_TYPE_NVLIST_ARRAY:\n\t\t\tnelem = va_arg(ap, int);\n\t\t\tret = nvlist_add_nvlist_array(payload, name,\n\t\t\t    va_arg(ap, const nvlist_t **), nelem);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = EINVAL;\n\t\t}\n\n\t\tname = va_arg(ap, char *);\n\t}\n\treturn (ret);\n}\n\nvoid\nfm_payload_set(nvlist_t *payload, ...)\n{\n\tint ret;\n\tconst char *name;\n\tva_list ap;\n\n\tva_start(ap, payload);\n\tname = va_arg(ap, char *);\n\tret = i_fm_payload_set(payload, name, ap);\n\tva_end(ap);\n\n\tif (ret)\n\t\tatomic_inc_64(&erpt_kstat_data.payload_set_failed.value.ui64);\n}\n\n \nvoid\nfm_ereport_set(nvlist_t *ereport, int version, const char *erpt_class,\n    uint64_t ena, const nvlist_t *detector, ...)\n{\n\tchar ereport_class[FM_MAX_CLASS];\n\tconst char *name;\n\tva_list ap;\n\tint ret;\n\n\tif (version != FM_EREPORT_VERS0) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\t(void) snprintf(ereport_class, FM_MAX_CLASS, \"%s.%s\",\n\t    FM_EREPORT_CLASS, erpt_class);\n\tif (nvlist_add_string(ereport, FM_CLASS, ereport_class) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_uint64(ereport, FM_EREPORT_ENA, ena)) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n\t}\n\n\tif (nvlist_add_nvlist(ereport, FM_EREPORT_DETECTOR,\n\t    (nvlist_t *)detector) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n\t}\n\n\tva_start(ap, detector);\n\tname = va_arg(ap, const char *);\n\tret = i_fm_payload_set(ereport, name, ap);\n\tva_end(ap);\n\n\tif (ret)\n\t\tatomic_inc_64(&erpt_kstat_data.erpt_set_failed.value.ui64);\n}\n\n \n\n#define\tHC_MAXPAIRS\t20\n#define\tHC_MAXNAMELEN\t50\n\nstatic int\nfm_fmri_hc_set_common(nvlist_t *fmri, int version, const nvlist_t *auth)\n{\n\tif (version != FM_HC_SCHEME_VERSION) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn (0);\n\t}\n\n\tif (nvlist_add_uint8(fmri, FM_VERSION, version) != 0 ||\n\t    nvlist_add_string(fmri, FM_FMRI_SCHEME, FM_FMRI_SCHEME_HC) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn (0);\n\t}\n\n\tif (auth != NULL && nvlist_add_nvlist(fmri, FM_FMRI_AUTHORITY,\n\t    (nvlist_t *)auth) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}\n\nvoid\nfm_fmri_hc_set(nvlist_t *fmri, int version, const nvlist_t *auth,\n    nvlist_t *snvl, int npairs, ...)\n{\n\tnv_alloc_t *nva = nvlist_lookup_nv_alloc(fmri);\n\tnvlist_t *pairs[HC_MAXPAIRS];\n\tva_list ap;\n\tint i;\n\n\tif (!fm_fmri_hc_set_common(fmri, version, auth))\n\t\treturn;\n\n\tnpairs = MIN(npairs, HC_MAXPAIRS);\n\n\tva_start(ap, npairs);\n\tfor (i = 0; i < npairs; i++) {\n\t\tconst char *name = va_arg(ap, const char *);\n\t\tuint32_t id = va_arg(ap, uint32_t);\n\t\tchar idstr[11];\n\n\t\t(void) snprintf(idstr, sizeof (idstr), \"%u\", id);\n\n\t\tpairs[i] = fm_nvlist_create(nva);\n\t\tif (nvlist_add_string(pairs[i], FM_FMRI_HC_NAME, name) != 0 ||\n\t\t    nvlist_add_string(pairs[i], FM_FMRI_HC_ID, idstr) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t}\n\t}\n\tva_end(ap);\n\n\tif (nvlist_add_nvlist_array(fmri, FM_FMRI_HC_LIST,\n\t    (const nvlist_t **)pairs, npairs) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t}\n\n\tfor (i = 0; i < npairs; i++)\n\t\tfm_nvlist_destroy(pairs[i], FM_NVA_RETAIN);\n\n\tif (snvl != NULL) {\n\t\tif (nvlist_add_nvlist(fmri, FM_FMRI_HC_SPECIFIC, snvl) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t}\n\t}\n}\n\nvoid\nfm_fmri_hc_create(nvlist_t *fmri, int version, const nvlist_t *auth,\n    nvlist_t *snvl, nvlist_t *bboard, int npairs, ...)\n{\n\tnv_alloc_t *nva = nvlist_lookup_nv_alloc(fmri);\n\tnvlist_t *pairs[HC_MAXPAIRS];\n\tnvlist_t **hcl;\n\tuint_t n;\n\tint i, j;\n\tva_list ap;\n\tconst char *hcname, *hcid;\n\n\tif (!fm_fmri_hc_set_common(fmri, version, auth))\n\t\treturn;\n\n\t \n\tif (nvlist_lookup_nvlist_array(bboard, FM_FMRI_HC_LIST, &hcl, &n)\n\t    != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (nvlist_lookup_string(hcl[i], FM_FMRI_HC_NAME,\n\t\t    &hcname) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t\treturn;\n\t\t}\n\t\tif (nvlist_lookup_string(hcl[i], FM_FMRI_HC_ID, &hcid) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t\treturn;\n\t\t}\n\n\t\tpairs[i] = fm_nvlist_create(nva);\n\t\tif (nvlist_add_string(pairs[i], FM_FMRI_HC_NAME, hcname) != 0 ||\n\t\t    nvlist_add_string(pairs[i], FM_FMRI_HC_ID, hcid) != 0) {\n\t\t\tfor (j = 0; j <= i; j++) {\n\t\t\t\tif (pairs[j] != NULL)\n\t\t\t\t\tfm_nvlist_destroy(pairs[j],\n\t\t\t\t\t    FM_NVA_RETAIN);\n\t\t\t}\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tnpairs = MIN(npairs, HC_MAXPAIRS);\n\n\tva_start(ap, npairs);\n\tfor (i = n; i < npairs + n; i++) {\n\t\tconst char *name = va_arg(ap, const char *);\n\t\tuint32_t id = va_arg(ap, uint32_t);\n\t\tchar idstr[11];\n\t\t(void) snprintf(idstr, sizeof (idstr), \"%u\", id);\n\t\tpairs[i] = fm_nvlist_create(nva);\n\t\tif (nvlist_add_string(pairs[i], FM_FMRI_HC_NAME, name) != 0 ||\n\t\t    nvlist_add_string(pairs[i], FM_FMRI_HC_ID, idstr) != 0) {\n\t\t\tfor (j = 0; j <= i; j++) {\n\t\t\t\tif (pairs[j] != NULL)\n\t\t\t\t\tfm_nvlist_destroy(pairs[j],\n\t\t\t\t\t    FM_NVA_RETAIN);\n\t\t\t}\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t\tva_end(ap);\n\t\t\treturn;\n\t\t}\n\t}\n\tva_end(ap);\n\n\t \n\tif (nvlist_add_nvlist_array(fmri, FM_FMRI_HC_LIST,\n\t    (const nvlist_t **)pairs, npairs + n) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npairs + n; i++) {\n\t\t\tfm_nvlist_destroy(pairs[i], FM_NVA_RETAIN);\n\t}\n\n\tif (snvl != NULL) {\n\t\tif (nvlist_add_nvlist(fmri, FM_FMRI_HC_SPECIFIC, snvl) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nvoid\nfm_fmri_dev_set(nvlist_t *fmri_dev, int version, const nvlist_t *auth,\n    const char *devpath, const char *devid, const char *tpl0)\n{\n\tint err = 0;\n\n\tif (version != DEV_SCHEME_VERSION0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\terr |= nvlist_add_uint8(fmri_dev, FM_VERSION, version);\n\terr |= nvlist_add_string(fmri_dev, FM_FMRI_SCHEME, FM_FMRI_SCHEME_DEV);\n\n\tif (auth != NULL) {\n\t\terr |= nvlist_add_nvlist(fmri_dev, FM_FMRI_AUTHORITY,\n\t\t    (nvlist_t *)auth);\n\t}\n\n\terr |= nvlist_add_string(fmri_dev, FM_FMRI_DEV_PATH, devpath);\n\n\tif (devid != NULL)\n\t\terr |= nvlist_add_string(fmri_dev, FM_FMRI_DEV_ID, devid);\n\n\tif (tpl0 != NULL)\n\t\terr |= nvlist_add_string(fmri_dev, FM_FMRI_DEV_TGTPTLUN0, tpl0);\n\n\tif (err)\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\n}\n\n \nvoid\nfm_fmri_cpu_set(nvlist_t *fmri_cpu, int version, const nvlist_t *auth,\n    uint32_t cpu_id, uint8_t *cpu_maskp, const char *serial_idp)\n{\n\tuint64_t *failedp = &erpt_kstat_data.fmri_set_failed.value.ui64;\n\n\tif (version < CPU_SCHEME_VERSION1) {\n\t\tatomic_inc_64(failedp);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_uint8(fmri_cpu, FM_VERSION, version) != 0) {\n\t\tatomic_inc_64(failedp);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_string(fmri_cpu, FM_FMRI_SCHEME,\n\t    FM_FMRI_SCHEME_CPU) != 0) {\n\t\tatomic_inc_64(failedp);\n\t\treturn;\n\t}\n\n\tif (auth != NULL && nvlist_add_nvlist(fmri_cpu, FM_FMRI_AUTHORITY,\n\t    (nvlist_t *)auth) != 0)\n\t\tatomic_inc_64(failedp);\n\n\tif (nvlist_add_uint32(fmri_cpu, FM_FMRI_CPU_ID, cpu_id) != 0)\n\t\tatomic_inc_64(failedp);\n\n\tif (cpu_maskp != NULL && nvlist_add_uint8(fmri_cpu, FM_FMRI_CPU_MASK,\n\t    *cpu_maskp) != 0)\n\t\tatomic_inc_64(failedp);\n\n\tif (serial_idp == NULL || nvlist_add_string(fmri_cpu,\n\t    FM_FMRI_CPU_SERIAL_ID, (char *)serial_idp) != 0)\n\t\t\tatomic_inc_64(failedp);\n}\n\n \nvoid\nfm_fmri_mem_set(nvlist_t *fmri, int version, const nvlist_t *auth,\n    const char *unum, const char *serial, uint64_t offset)\n{\n\tif (version != MEM_SCHEME_VERSION0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (!serial && (offset != (uint64_t)-1)) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_uint8(fmri, FM_VERSION, version) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_string(fmri, FM_FMRI_SCHEME, FM_FMRI_SCHEME_MEM) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (auth != NULL) {\n\t\tif (nvlist_add_nvlist(fmri, FM_FMRI_AUTHORITY,\n\t\t    (nvlist_t *)auth) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t}\n\t}\n\n\tif (nvlist_add_string(fmri, FM_FMRI_MEM_UNUM, unum) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t}\n\n\tif (serial != NULL) {\n\t\tif (nvlist_add_string_array(fmri, FM_FMRI_MEM_SERIAL_ID,\n\t\t    (const char **)&serial, 1) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t}\n\t\tif (offset != (uint64_t)-1 && nvlist_add_uint64(fmri,\n\t\t    FM_FMRI_MEM_OFFSET, offset) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t}\n\t}\n}\n\nvoid\nfm_fmri_zfs_set(nvlist_t *fmri, int version, uint64_t pool_guid,\n    uint64_t vdev_guid)\n{\n\tif (version != ZFS_SCHEME_VERSION0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_uint8(fmri, FM_VERSION, version) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_string(fmri, FM_FMRI_SCHEME, FM_FMRI_SCHEME_ZFS) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\treturn;\n\t}\n\n\tif (nvlist_add_uint64(fmri, FM_FMRI_ZFS_POOL, pool_guid) != 0) {\n\t\tatomic_inc_64(&erpt_kstat_data.fmri_set_failed.value.ui64);\n\t}\n\n\tif (vdev_guid != 0) {\n\t\tif (nvlist_add_uint64(fmri, FM_FMRI_ZFS_VDEV, vdev_guid) != 0) {\n\t\t\tatomic_inc_64(\n\t\t\t    &erpt_kstat_data.fmri_set_failed.value.ui64);\n\t\t}\n\t}\n}\n\nuint64_t\nfm_ena_increment(uint64_t ena)\n{\n\tuint64_t new_ena;\n\n\tswitch (ENA_FORMAT(ena)) {\n\tcase FM_ENA_FMT1:\n\t\tnew_ena = ena + (1 << ENA_FMT1_GEN_SHFT);\n\t\tbreak;\n\tcase FM_ENA_FMT2:\n\t\tnew_ena = ena + (1 << ENA_FMT2_GEN_SHFT);\n\t\tbreak;\n\tdefault:\n\t\tnew_ena = 0;\n\t}\n\n\treturn (new_ena);\n}\n\nuint64_t\nfm_ena_generate_cpu(uint64_t timestamp, processorid_t cpuid, uchar_t format)\n{\n\tuint64_t ena = 0;\n\n\tswitch (format) {\n\tcase FM_ENA_FMT1:\n\t\tif (timestamp) {\n\t\t\tena = (uint64_t)((format & ENA_FORMAT_MASK) |\n\t\t\t    ((cpuid << ENA_FMT1_CPUID_SHFT) &\n\t\t\t    ENA_FMT1_CPUID_MASK) |\n\t\t\t    ((timestamp << ENA_FMT1_TIME_SHFT) &\n\t\t\t    ENA_FMT1_TIME_MASK));\n\t\t} else {\n\t\t\tena = (uint64_t)((format & ENA_FORMAT_MASK) |\n\t\t\t    ((cpuid << ENA_FMT1_CPUID_SHFT) &\n\t\t\t    ENA_FMT1_CPUID_MASK) |\n\t\t\t    ((gethrtime() << ENA_FMT1_TIME_SHFT) &\n\t\t\t    ENA_FMT1_TIME_MASK));\n\t\t}\n\t\tbreak;\n\tcase FM_ENA_FMT2:\n\t\tena = (uint64_t)((format & ENA_FORMAT_MASK) |\n\t\t    ((timestamp << ENA_FMT2_TIME_SHFT) & ENA_FMT2_TIME_MASK));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (ena);\n}\n\nuint64_t\nfm_ena_generate(uint64_t timestamp, uchar_t format)\n{\n\tuint64_t ena;\n\n\tkpreempt_disable();\n\tena = fm_ena_generate_cpu(timestamp, getcpuid(), format);\n\tkpreempt_enable();\n\n\treturn (ena);\n}\n\nuint64_t\nfm_ena_generation_get(uint64_t ena)\n{\n\tuint64_t gen;\n\n\tswitch (ENA_FORMAT(ena)) {\n\tcase FM_ENA_FMT1:\n\t\tgen = (ena & ENA_FMT1_GEN_MASK) >> ENA_FMT1_GEN_SHFT;\n\t\tbreak;\n\tcase FM_ENA_FMT2:\n\t\tgen = (ena & ENA_FMT2_GEN_MASK) >> ENA_FMT2_GEN_SHFT;\n\t\tbreak;\n\tdefault:\n\t\tgen = 0;\n\t\tbreak;\n\t}\n\n\treturn (gen);\n}\n\nuchar_t\nfm_ena_format_get(uint64_t ena)\n{\n\n\treturn (ENA_FORMAT(ena));\n}\n\nuint64_t\nfm_ena_id_get(uint64_t ena)\n{\n\tuint64_t id;\n\n\tswitch (ENA_FORMAT(ena)) {\n\tcase FM_ENA_FMT1:\n\t\tid = (ena & ENA_FMT1_ID_MASK) >> ENA_FMT1_ID_SHFT;\n\t\tbreak;\n\tcase FM_ENA_FMT2:\n\t\tid = (ena & ENA_FMT2_ID_MASK) >> ENA_FMT2_ID_SHFT;\n\t\tbreak;\n\tdefault:\n\t\tid = 0;\n\t}\n\n\treturn (id);\n}\n\nuint64_t\nfm_ena_time_get(uint64_t ena)\n{\n\tuint64_t time;\n\n\tswitch (ENA_FORMAT(ena)) {\n\tcase FM_ENA_FMT1:\n\t\ttime = (ena & ENA_FMT1_TIME_MASK) >> ENA_FMT1_TIME_SHFT;\n\t\tbreak;\n\tcase FM_ENA_FMT2:\n\t\ttime = (ena & ENA_FMT2_TIME_MASK) >> ENA_FMT2_TIME_SHFT;\n\t\tbreak;\n\tdefault:\n\t\ttime = 0;\n\t}\n\n\treturn (time);\n}\n\n#ifdef _KERNEL\n \nvoid\nfm_erpt_dropped_increment(void)\n{\n\tatomic_inc_64(&ratelimit_dropped);\n}\n\nvoid\nfm_init(void)\n{\n\tzevent_len_cur = 0;\n\tzevent_flags = 0;\n\n\t \n\tfm_ksp = kstat_create(\"zfs\", 0, \"fm\", \"misc\", KSTAT_TYPE_NAMED,\n\t    sizeof (struct erpt_kstat) / sizeof (kstat_named_t),\n\t    KSTAT_FLAG_VIRTUAL);\n\n\tif (fm_ksp != NULL) {\n\t\tfm_ksp->ks_data = &erpt_kstat_data;\n\t\tkstat_install(fm_ksp);\n\t} else {\n\t\tcmn_err(CE_NOTE, \"failed to create fm/misc kstat\\n\");\n\t}\n\n\tmutex_init(&zevent_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&zevent_list, sizeof (zevent_t),\n\t    offsetof(zevent_t, ev_node));\n\tcv_init(&zevent_cv, NULL, CV_DEFAULT, NULL);\n\n\tzfs_ereport_init();\n}\n\nvoid\nfm_fini(void)\n{\n\tuint_t count;\n\n\tzfs_ereport_fini();\n\n\tzfs_zevent_drain_all(&count);\n\n\tmutex_enter(&zevent_lock);\n\tcv_broadcast(&zevent_cv);\n\n\tzevent_flags |= ZEVENT_SHUTDOWN;\n\twhile (zevent_waiters > 0) {\n\t\tmutex_exit(&zevent_lock);\n\t\tkpreempt(KPREEMPT_SYNC);\n\t\tmutex_enter(&zevent_lock);\n\t}\n\tmutex_exit(&zevent_lock);\n\n\tcv_destroy(&zevent_cv);\n\tlist_destroy(&zevent_list);\n\tmutex_destroy(&zevent_lock);\n\n\tif (fm_ksp != NULL) {\n\t\tkstat_delete(fm_ksp);\n\t\tfm_ksp = NULL;\n\t}\n}\n#endif  \n\nZFS_MODULE_PARAM(zfs_zevent, zfs_zevent_, len_max, UINT, ZMOD_RW,\n\t\"Max event queue length\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}