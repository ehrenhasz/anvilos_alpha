{
  "module_name": "btree.c",
  "hash_id": "7114778661d26ba1d4fc92b2702bf523a0ed85cd000ae42e75ef0955efa4e66c",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/btree.c",
  "human_readable_source": " \n \n\n#include\t<sys/btree.h>\n#include\t<sys/bitops.h>\n#include\t<sys/zfs_context.h>\n\nkmem_cache_t *zfs_btree_leaf_cache;\n\n \nuint_t zfs_btree_verify_intensity = 0;\n\n \nstatic void\nbcpy(const void *src, void *dest, size_t size)\n{\n\t(void) memcpy(dest, src, size);\n}\n\nstatic void\nbmov(const void *src, void *dest, size_t size)\n{\n\t(void) memmove(dest, src, size);\n}\n\nstatic boolean_t\nzfs_btree_is_core(struct zfs_btree_hdr *hdr)\n{\n\treturn (hdr->bth_first == -1);\n}\n\n#ifdef _ILP32\n#define\tBTREE_POISON 0xabadb10c\n#else\n#define\tBTREE_POISON 0xabadb10cdeadbeef\n#endif\n\nstatic void\nzfs_btree_poison_node(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n#ifdef ZFS_DEBUG\n\tsize_t size = tree->bt_elem_size;\n\tif (zfs_btree_is_core(hdr)) {\n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\t\tfor (uint32_t i = hdr->bth_count + 1; i <= BTREE_CORE_ELEMS;\n\t\t    i++) {\n\t\t\tnode->btc_children[i] =\n\t\t\t    (zfs_btree_hdr_t *)BTREE_POISON;\n\t\t}\n\t\t(void) memset(node->btc_elems + hdr->bth_count * size, 0x0f,\n\t\t    (BTREE_CORE_ELEMS - hdr->bth_count) * size);\n\t} else {\n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)hdr;\n\t\t(void) memset(leaf->btl_elems, 0x0f, hdr->bth_first * size);\n\t\t(void) memset(leaf->btl_elems +\n\t\t    (hdr->bth_first + hdr->bth_count) * size, 0x0f,\n\t\t    tree->bt_leaf_size - offsetof(zfs_btree_leaf_t, btl_elems) -\n\t\t    (hdr->bth_first + hdr->bth_count) * size);\n\t}\n#endif\n}\n\nstatic inline void\nzfs_btree_poison_node_at(zfs_btree_t *tree, zfs_btree_hdr_t *hdr,\n    uint32_t idx, uint32_t count)\n{\n#ifdef ZFS_DEBUG\n\tsize_t size = tree->bt_elem_size;\n\tif (zfs_btree_is_core(hdr)) {\n\t\tASSERT3U(idx, >=, hdr->bth_count);\n\t\tASSERT3U(idx, <=, BTREE_CORE_ELEMS);\n\t\tASSERT3U(idx + count, <=, BTREE_CORE_ELEMS);\n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\t\tfor (uint32_t i = 1; i <= count; i++) {\n\t\t\tnode->btc_children[idx + i] =\n\t\t\t    (zfs_btree_hdr_t *)BTREE_POISON;\n\t\t}\n\t\t(void) memset(node->btc_elems + idx * size, 0x0f, count * size);\n\t} else {\n\t\tASSERT3U(idx, <=, tree->bt_leaf_cap);\n\t\tASSERT3U(idx + count, <=, tree->bt_leaf_cap);\n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)hdr;\n\t\t(void) memset(leaf->btl_elems +\n\t\t    (hdr->bth_first + idx) * size, 0x0f, count * size);\n\t}\n#endif\n}\n\nstatic inline void\nzfs_btree_verify_poison_at(zfs_btree_t *tree, zfs_btree_hdr_t *hdr,\n    uint32_t idx)\n{\n#ifdef ZFS_DEBUG\n\tsize_t size = tree->bt_elem_size;\n\tif (zfs_btree_is_core(hdr)) {\n\t\tASSERT3U(idx, <, BTREE_CORE_ELEMS);\n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\t\tzfs_btree_hdr_t *cval = (zfs_btree_hdr_t *)BTREE_POISON;\n\t\tVERIFY3P(node->btc_children[idx + 1], ==, cval);\n\t\tfor (size_t i = 0; i < size; i++)\n\t\t\tVERIFY3U(node->btc_elems[idx * size + i], ==, 0x0f);\n\t} else  {\n\t\tASSERT3U(idx, <, tree->bt_leaf_cap);\n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)hdr;\n\t\tif (idx >= tree->bt_leaf_cap - hdr->bth_first)\n\t\t\treturn;\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tVERIFY3U(leaf->btl_elems[(hdr->bth_first + idx)\n\t\t\t    * size + i], ==, 0x0f);\n\t\t}\n\t}\n#endif\n}\n\nvoid\nzfs_btree_init(void)\n{\n\tzfs_btree_leaf_cache = kmem_cache_create(\"zfs_btree_leaf_cache\",\n\t    BTREE_LEAF_SIZE, 0, NULL, NULL, NULL, NULL, NULL, 0);\n}\n\nvoid\nzfs_btree_fini(void)\n{\n\tkmem_cache_destroy(zfs_btree_leaf_cache);\n}\n\nstatic void *\nzfs_btree_leaf_alloc(zfs_btree_t *tree)\n{\n\tif (tree->bt_leaf_size == BTREE_LEAF_SIZE)\n\t\treturn (kmem_cache_alloc(zfs_btree_leaf_cache, KM_SLEEP));\n\telse\n\t\treturn (kmem_alloc(tree->bt_leaf_size, KM_SLEEP));\n}\n\nstatic void\nzfs_btree_leaf_free(zfs_btree_t *tree, void *ptr)\n{\n\tif (tree->bt_leaf_size == BTREE_LEAF_SIZE)\n\t\treturn (kmem_cache_free(zfs_btree_leaf_cache, ptr));\n\telse\n\t\treturn (kmem_free(ptr, tree->bt_leaf_size));\n}\n\nvoid\nzfs_btree_create(zfs_btree_t *tree, int (*compar) (const void *, const void *),\n    bt_find_in_buf_f bt_find_in_buf, size_t size)\n{\n\tzfs_btree_create_custom(tree, compar, bt_find_in_buf, size,\n\t    BTREE_LEAF_SIZE);\n}\n\nstatic void *\nzfs_btree_find_in_buf(zfs_btree_t *tree, uint8_t *buf, uint32_t nelems,\n    const void *value, zfs_btree_index_t *where);\n\nvoid\nzfs_btree_create_custom(zfs_btree_t *tree,\n    int (*compar) (const void *, const void *),\n    bt_find_in_buf_f bt_find_in_buf,\n    size_t size, size_t lsize)\n{\n\tsize_t esize = lsize - offsetof(zfs_btree_leaf_t, btl_elems);\n\n\tASSERT3U(size, <=, esize / 2);\n\tmemset(tree, 0, sizeof (*tree));\n\ttree->bt_compar = compar;\n\ttree->bt_find_in_buf = (bt_find_in_buf == NULL) ?\n\t    zfs_btree_find_in_buf : bt_find_in_buf;\n\ttree->bt_elem_size = size;\n\ttree->bt_leaf_size = lsize;\n\ttree->bt_leaf_cap = P2ALIGN(esize / size, 2);\n\ttree->bt_height = -1;\n\ttree->bt_bulk = NULL;\n}\n\n \nstatic void *\nzfs_btree_find_in_buf(zfs_btree_t *tree, uint8_t *buf, uint32_t nelems,\n    const void *value, zfs_btree_index_t *where)\n{\n\tuint32_t max = nelems;\n\tuint32_t min = 0;\n\twhile (max > min) {\n\t\tuint32_t idx = (min + max) / 2;\n\t\tuint8_t *cur = buf + idx * tree->bt_elem_size;\n\t\tint comp = tree->bt_compar(cur, value);\n\t\tif (comp < 0) {\n\t\t\tmin = idx + 1;\n\t\t} else if (comp > 0) {\n\t\t\tmax = idx;\n\t\t} else {\n\t\t\twhere->bti_offset = idx;\n\t\t\twhere->bti_before = B_FALSE;\n\t\t\treturn (cur);\n\t\t}\n\t}\n\n\twhere->bti_offset = max;\n\twhere->bti_before = B_TRUE;\n\treturn (NULL);\n}\n\n \nvoid *\nzfs_btree_find(zfs_btree_t *tree, const void *value, zfs_btree_index_t *where)\n{\n\tif (tree->bt_height == -1) {\n\t\tif (where != NULL) {\n\t\t\twhere->bti_node = NULL;\n\t\t\twhere->bti_offset = 0;\n\t\t}\n\t\tASSERT0(tree->bt_num_elems);\n\t\treturn (NULL);\n\t}\n\n\t \n\tzfs_btree_index_t idx;\n\tsize_t size = tree->bt_elem_size;\n\tif (tree->bt_bulk != NULL) {\n\t\tzfs_btree_leaf_t *last_leaf = tree->bt_bulk;\n\t\tint comp = tree->bt_compar(last_leaf->btl_elems +\n\t\t    (last_leaf->btl_hdr.bth_first +\n\t\t    last_leaf->btl_hdr.bth_count - 1) * size, value);\n\t\tif (comp < 0) {\n\t\t\t \n\t\t\tif (where != NULL) {\n\t\t\t\twhere->bti_node = (zfs_btree_hdr_t *)last_leaf;\n\t\t\t\twhere->bti_offset =\n\t\t\t\t    last_leaf->btl_hdr.bth_count;\n\t\t\t\twhere->bti_before = B_TRUE;\n\t\t\t}\n\t\t\treturn (NULL);\n\t\t} else if (comp == 0) {\n\t\t\tif (where != NULL) {\n\t\t\t\twhere->bti_node = (zfs_btree_hdr_t *)last_leaf;\n\t\t\t\twhere->bti_offset =\n\t\t\t\t    last_leaf->btl_hdr.bth_count - 1;\n\t\t\t\twhere->bti_before = B_FALSE;\n\t\t\t}\n\t\t\treturn (last_leaf->btl_elems +\n\t\t\t    (last_leaf->btl_hdr.bth_first +\n\t\t\t    last_leaf->btl_hdr.bth_count - 1) * size);\n\t\t}\n\t\tif (tree->bt_compar(last_leaf->btl_elems +\n\t\t    last_leaf->btl_hdr.bth_first * size, value) <= 0) {\n\t\t\t \n\t\t\tvoid *d = tree->bt_find_in_buf(tree,\n\t\t\t    last_leaf->btl_elems +\n\t\t\t    last_leaf->btl_hdr.bth_first * size,\n\t\t\t    last_leaf->btl_hdr.bth_count, value, &idx);\n\n\t\t\tif (where != NULL) {\n\t\t\t\tidx.bti_node = (zfs_btree_hdr_t *)last_leaf;\n\t\t\t\t*where = idx;\n\t\t\t}\n\t\t\treturn (d);\n\t\t}\n\t}\n\n\tzfs_btree_core_t *node = NULL;\n\tuint32_t child = 0;\n\tuint32_t depth = 0;\n\n\t \n\tfor (node = (zfs_btree_core_t *)tree->bt_root; depth < tree->bt_height;\n\t    node = (zfs_btree_core_t *)node->btc_children[child], depth++) {\n\t\tASSERT3P(node, !=, NULL);\n\t\tvoid *d = tree->bt_find_in_buf(tree, node->btc_elems,\n\t\t    node->btc_hdr.bth_count, value, &idx);\n\t\tEQUIV(d != NULL, !idx.bti_before);\n\t\tif (d != NULL) {\n\t\t\tif (where != NULL) {\n\t\t\t\tidx.bti_node = (zfs_btree_hdr_t *)node;\n\t\t\t\t*where = idx;\n\t\t\t}\n\t\t\treturn (d);\n\t\t}\n\t\tASSERT(idx.bti_before);\n\t\tchild = idx.bti_offset;\n\t}\n\n\t \n\tzfs_btree_leaf_t *leaf = (depth == 0 ?\n\t    (zfs_btree_leaf_t *)tree->bt_root : (zfs_btree_leaf_t *)node);\n\tvoid *d = tree->bt_find_in_buf(tree, leaf->btl_elems +\n\t    leaf->btl_hdr.bth_first * size,\n\t    leaf->btl_hdr.bth_count, value, &idx);\n\n\tif (where != NULL) {\n\t\tidx.bti_node = (zfs_btree_hdr_t *)leaf;\n\t\t*where = idx;\n\t}\n\n\treturn (d);\n}\n\n \n\nenum bt_shift_shape {\n\tBSS_TRAPEZOID,\n\tBSS_PARALLELOGRAM\n};\n\nenum bt_shift_direction {\n\tBSD_LEFT,\n\tBSD_RIGHT\n};\n\n \nstatic inline void\nbt_shift_core(zfs_btree_t *tree, zfs_btree_core_t *node, uint32_t idx,\n    uint32_t count, uint32_t off, enum bt_shift_shape shape,\n    enum bt_shift_direction dir)\n{\n\tsize_t size = tree->bt_elem_size;\n\tASSERT(zfs_btree_is_core(&node->btc_hdr));\n\n\tuint8_t *e_start = node->btc_elems + idx * size;\n\tuint8_t *e_out = (dir == BSD_LEFT ? e_start - off * size :\n\t    e_start + off * size);\n\tbmov(e_start, e_out, count * size);\n\n\tzfs_btree_hdr_t **c_start = node->btc_children + idx +\n\t    (shape == BSS_TRAPEZOID ? 0 : 1);\n\tzfs_btree_hdr_t **c_out = (dir == BSD_LEFT ? c_start - off :\n\t    c_start + off);\n\tuint32_t c_count = count + (shape == BSS_TRAPEZOID ? 1 : 0);\n\tbmov(c_start, c_out, c_count * sizeof (*c_start));\n}\n\n \nstatic inline void\nbt_shift_core_left(zfs_btree_t *tree, zfs_btree_core_t *node, uint32_t idx,\n    uint32_t count, enum bt_shift_shape shape)\n{\n\tbt_shift_core(tree, node, idx, count, 1, shape, BSD_LEFT);\n}\n\n \nstatic inline void\nbt_shift_core_right(zfs_btree_t *tree, zfs_btree_core_t *node, uint32_t idx,\n    uint32_t count, enum bt_shift_shape shape)\n{\n\tbt_shift_core(tree, node, idx, count, 1, shape, BSD_RIGHT);\n}\n\n \nstatic inline void\nbt_shift_leaf(zfs_btree_t *tree, zfs_btree_leaf_t *node, uint32_t idx,\n    uint32_t count, uint32_t off, enum bt_shift_direction dir)\n{\n\tsize_t size = tree->bt_elem_size;\n\tzfs_btree_hdr_t *hdr = &node->btl_hdr;\n\tASSERT(!zfs_btree_is_core(hdr));\n\n\tif (count == 0)\n\t\treturn;\n\tuint8_t *start = node->btl_elems + (hdr->bth_first + idx) * size;\n\tuint8_t *out = (dir == BSD_LEFT ? start - off * size :\n\t    start + off * size);\n\tbmov(start, out, count * size);\n}\n\n \nstatic void\nbt_grow_leaf(zfs_btree_t *tree, zfs_btree_leaf_t *leaf, uint32_t idx,\n    uint32_t n)\n{\n\tzfs_btree_hdr_t *hdr = &leaf->btl_hdr;\n\tASSERT(!zfs_btree_is_core(hdr));\n\tASSERT3U(idx, <=, hdr->bth_count);\n\tuint32_t capacity = tree->bt_leaf_cap;\n\tASSERT3U(hdr->bth_count + n, <=, capacity);\n\tboolean_t cl = (hdr->bth_first >= n);\n\tboolean_t cr = (hdr->bth_first + hdr->bth_count + n <= capacity);\n\n\tif (cl && (!cr || idx <= hdr->bth_count / 2)) {\n\t\t \n\t\thdr->bth_first -= n;\n\t\tbt_shift_leaf(tree, leaf, n, idx, n, BSD_LEFT);\n\t} else if (cr) {\n\t\t \n\t\tbt_shift_leaf(tree, leaf, idx, hdr->bth_count - idx, n,\n\t\t    BSD_RIGHT);\n\t} else {\n\t\t \n\t\tuint32_t fn = hdr->bth_first -\n\t\t    (capacity - (hdr->bth_count + n)) / 2;\n\t\thdr->bth_first -= fn;\n\t\tbt_shift_leaf(tree, leaf, fn, idx, fn, BSD_LEFT);\n\t\tbt_shift_leaf(tree, leaf, fn + idx, hdr->bth_count - idx,\n\t\t    n - fn, BSD_RIGHT);\n\t}\n\thdr->bth_count += n;\n}\n\n \nstatic void\nbt_shrink_leaf(zfs_btree_t *tree, zfs_btree_leaf_t *leaf, uint32_t idx,\n    uint32_t n)\n{\n\tzfs_btree_hdr_t *hdr = &leaf->btl_hdr;\n\tASSERT(!zfs_btree_is_core(hdr));\n\tASSERT3U(idx, <=, hdr->bth_count);\n\tASSERT3U(idx + n, <=, hdr->bth_count);\n\n\tif (idx <= (hdr->bth_count - n) / 2) {\n\t\tbt_shift_leaf(tree, leaf, 0, idx, n, BSD_RIGHT);\n\t\tzfs_btree_poison_node_at(tree, hdr, 0, n);\n\t\thdr->bth_first += n;\n\t} else {\n\t\tbt_shift_leaf(tree, leaf, idx + n, hdr->bth_count - idx - n, n,\n\t\t    BSD_LEFT);\n\t\tzfs_btree_poison_node_at(tree, hdr, hdr->bth_count - n, n);\n\t}\n\thdr->bth_count -= n;\n}\n\n \nstatic inline void\nbt_transfer_core(zfs_btree_t *tree, zfs_btree_core_t *source, uint32_t sidx,\n    uint32_t count, zfs_btree_core_t *dest, uint32_t didx,\n    enum bt_shift_shape shape)\n{\n\tsize_t size = tree->bt_elem_size;\n\tASSERT(zfs_btree_is_core(&source->btc_hdr));\n\tASSERT(zfs_btree_is_core(&dest->btc_hdr));\n\n\tbcpy(source->btc_elems + sidx * size, dest->btc_elems + didx * size,\n\t    count * size);\n\n\tuint32_t c_count = count + (shape == BSS_TRAPEZOID ? 1 : 0);\n\tbcpy(source->btc_children + sidx + (shape == BSS_TRAPEZOID ? 0 : 1),\n\t    dest->btc_children + didx + (shape == BSS_TRAPEZOID ? 0 : 1),\n\t    c_count * sizeof (*source->btc_children));\n}\n\nstatic inline void\nbt_transfer_leaf(zfs_btree_t *tree, zfs_btree_leaf_t *source, uint32_t sidx,\n    uint32_t count, zfs_btree_leaf_t *dest, uint32_t didx)\n{\n\tsize_t size = tree->bt_elem_size;\n\tASSERT(!zfs_btree_is_core(&source->btl_hdr));\n\tASSERT(!zfs_btree_is_core(&dest->btl_hdr));\n\n\tbcpy(source->btl_elems + (source->btl_hdr.bth_first + sidx) * size,\n\t    dest->btl_elems + (dest->btl_hdr.bth_first + didx) * size,\n\t    count * size);\n}\n\n \nstatic void *\nzfs_btree_first_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr,\n    zfs_btree_index_t *where)\n{\n\tzfs_btree_hdr_t *node;\n\n\tfor (node = hdr; zfs_btree_is_core(node);\n\t    node = ((zfs_btree_core_t *)node)->btc_children[0])\n\t\t;\n\n\tASSERT(!zfs_btree_is_core(node));\n\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)node;\n\tif (where != NULL) {\n\t\twhere->bti_node = node;\n\t\twhere->bti_offset = 0;\n\t\twhere->bti_before = B_FALSE;\n\t}\n\treturn (&leaf->btl_elems[node->bth_first * tree->bt_elem_size]);\n}\n\n \nstatic void\nzfs_btree_insert_core_impl(zfs_btree_t *tree, zfs_btree_core_t *parent,\n    uint32_t offset, zfs_btree_hdr_t *new_node, void *buf)\n{\n\tsize_t size = tree->bt_elem_size;\n\tzfs_btree_hdr_t *par_hdr = &parent->btc_hdr;\n\tASSERT3P(par_hdr, ==, new_node->bth_parent);\n\tASSERT3U(par_hdr->bth_count, <, BTREE_CORE_ELEMS);\n\n\tif (zfs_btree_verify_intensity >= 5) {\n\t\tzfs_btree_verify_poison_at(tree, par_hdr,\n\t\t    par_hdr->bth_count);\n\t}\n\t \n\tuint32_t count = par_hdr->bth_count - offset;\n\tbt_shift_core_right(tree, parent, offset, count,\n\t    BSS_PARALLELOGRAM);\n\n\t \n\tparent->btc_children[offset + 1] = new_node;\n\tbcpy(buf, parent->btc_elems + offset * size, size);\n\tpar_hdr->bth_count++;\n}\n\n \nstatic void\nzfs_btree_insert_into_parent(zfs_btree_t *tree, zfs_btree_hdr_t *old_node,\n    zfs_btree_hdr_t *new_node, void *buf)\n{\n\tASSERT3P(old_node->bth_parent, ==, new_node->bth_parent);\n\tsize_t size = tree->bt_elem_size;\n\tzfs_btree_core_t *parent = old_node->bth_parent;\n\n\t \n\tif (parent == NULL) {\n\t\tASSERT3P(old_node, ==, tree->bt_root);\n\t\ttree->bt_num_nodes++;\n\t\tzfs_btree_core_t *new_root =\n\t\t    kmem_alloc(sizeof (zfs_btree_core_t) + BTREE_CORE_ELEMS *\n\t\t    size, KM_SLEEP);\n\t\tzfs_btree_hdr_t *new_root_hdr = &new_root->btc_hdr;\n\t\tnew_root_hdr->bth_parent = NULL;\n\t\tnew_root_hdr->bth_first = -1;\n\t\tnew_root_hdr->bth_count = 1;\n\n\t\told_node->bth_parent = new_node->bth_parent = new_root;\n\t\tnew_root->btc_children[0] = old_node;\n\t\tnew_root->btc_children[1] = new_node;\n\t\tbcpy(buf, new_root->btc_elems, size);\n\n\t\ttree->bt_height++;\n\t\ttree->bt_root = new_root_hdr;\n\t\tzfs_btree_poison_node(tree, new_root_hdr);\n\t\treturn;\n\t}\n\n\t \n\tzfs_btree_hdr_t *par_hdr = &parent->btc_hdr;\n\tzfs_btree_index_t idx;\n\tASSERT(zfs_btree_is_core(par_hdr));\n\tVERIFY3P(tree->bt_find_in_buf(tree, parent->btc_elems,\n\t    par_hdr->bth_count, buf, &idx), ==, NULL);\n\tASSERT(idx.bti_before);\n\tuint32_t offset = idx.bti_offset;\n\tASSERT3U(offset, <=, par_hdr->bth_count);\n\tASSERT3P(parent->btc_children[offset], ==, old_node);\n\n\t \n\tif (par_hdr->bth_count != BTREE_CORE_ELEMS) {\n\t\tzfs_btree_insert_core_impl(tree, parent, offset, new_node, buf);\n\t\treturn;\n\t}\n\n\t \n\tuint32_t move_count = MAX((BTREE_CORE_ELEMS / (tree->bt_bulk == NULL ?\n\t    2 : 4)) - 1, 2);\n\tuint32_t keep_count = BTREE_CORE_ELEMS - move_count - 1;\n\tASSERT3U(BTREE_CORE_ELEMS - move_count, >=, 2);\n\ttree->bt_num_nodes++;\n\tzfs_btree_core_t *new_parent = kmem_alloc(sizeof (zfs_btree_core_t) +\n\t    BTREE_CORE_ELEMS * size, KM_SLEEP);\n\tzfs_btree_hdr_t *new_par_hdr = &new_parent->btc_hdr;\n\tnew_par_hdr->bth_parent = par_hdr->bth_parent;\n\tnew_par_hdr->bth_first = -1;\n\tnew_par_hdr->bth_count = move_count;\n\tzfs_btree_poison_node(tree, new_par_hdr);\n\n\tpar_hdr->bth_count = keep_count;\n\n\tbt_transfer_core(tree, parent, keep_count + 1, move_count, new_parent,\n\t    0, BSS_TRAPEZOID);\n\n\t \n\tuint8_t *tmp_buf = kmem_alloc(size, KM_SLEEP);\n\tbcpy(parent->btc_elems + keep_count * size, tmp_buf,\n\t    size);\n\tzfs_btree_poison_node(tree, par_hdr);\n\n\tif (offset < keep_count) {\n\t\t \n\t\tzfs_btree_insert_core_impl(tree, parent, offset, new_node,\n\t\t    buf);\n\n\t\t \n\t\tbcpy(tmp_buf, buf, size);\n\t} else if (offset > keep_count) {\n\t\t \n\t\tnew_node->bth_parent = new_parent;\n\t\tzfs_btree_insert_core_impl(tree, new_parent,\n\t\t    offset - keep_count - 1, new_node, buf);\n\n\t\t \n\t\tbcpy(tmp_buf, buf, size);\n\t} else {\n\t\t \n\t\tbt_shift_core_right(tree, new_parent, 0, move_count,\n\t\t    BSS_TRAPEZOID);\n\t\tnew_parent->btc_children[0] = new_node;\n\t\tbcpy(tmp_buf, new_parent->btc_elems, size);\n\t\tnew_par_hdr->bth_count++;\n\t}\n\tkmem_free(tmp_buf, size);\n\tzfs_btree_poison_node(tree, par_hdr);\n\n\tfor (uint32_t i = 0; i <= new_parent->btc_hdr.bth_count; i++)\n\t\tnew_parent->btc_children[i]->bth_parent = new_parent;\n\n\tfor (uint32_t i = 0; i <= parent->btc_hdr.bth_count; i++)\n\t\tASSERT3P(parent->btc_children[i]->bth_parent, ==, parent);\n\n\t \n\tzfs_btree_insert_into_parent(tree, &parent->btc_hdr,\n\t    &new_parent->btc_hdr, buf);\n}\n\n \nstatic void\nzfs_btree_insert_leaf_impl(zfs_btree_t *tree, zfs_btree_leaf_t *leaf,\n    uint32_t idx, const void *value)\n{\n\tsize_t size = tree->bt_elem_size;\n\tzfs_btree_hdr_t *hdr = &leaf->btl_hdr;\n\tASSERT3U(leaf->btl_hdr.bth_count, <, tree->bt_leaf_cap);\n\n\tif (zfs_btree_verify_intensity >= 5) {\n\t\tzfs_btree_verify_poison_at(tree, &leaf->btl_hdr,\n\t\t    leaf->btl_hdr.bth_count);\n\t}\n\n\tbt_grow_leaf(tree, leaf, idx, 1);\n\tuint8_t *start = leaf->btl_elems + (hdr->bth_first + idx) * size;\n\tbcpy(value, start, size);\n}\n\nstatic void\nzfs_btree_verify_order_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr);\n\n \nstatic void\nzfs_btree_insert_into_leaf(zfs_btree_t *tree, zfs_btree_leaf_t *leaf,\n    const void *value, uint32_t idx)\n{\n\tsize_t size = tree->bt_elem_size;\n\tuint32_t capacity = tree->bt_leaf_cap;\n\n\t \n\tif (leaf->btl_hdr.bth_count != capacity) {\n\t\tzfs_btree_insert_leaf_impl(tree, leaf, idx, value);\n\t\treturn;\n\t}\n\n\t \n\tuint32_t move_count = MAX(capacity / (tree->bt_bulk ? 4 : 2), 1) - 1;\n\tuint32_t keep_count = capacity - move_count - 1;\n\tASSERT3U(keep_count, >=, 1);\n\t \n\tif (idx < keep_count) {\n\t\tkeep_count--;\n\t\tmove_count++;\n\t}\n\ttree->bt_num_nodes++;\n\tzfs_btree_leaf_t *new_leaf = zfs_btree_leaf_alloc(tree);\n\tzfs_btree_hdr_t *new_hdr = &new_leaf->btl_hdr;\n\tnew_hdr->bth_parent = leaf->btl_hdr.bth_parent;\n\tnew_hdr->bth_first = (tree->bt_bulk ? 0 : capacity / 4) +\n\t    (idx >= keep_count && idx <= keep_count + move_count / 2);\n\tnew_hdr->bth_count = move_count;\n\tzfs_btree_poison_node(tree, new_hdr);\n\n\tif (tree->bt_bulk != NULL && leaf == tree->bt_bulk)\n\t\ttree->bt_bulk = new_leaf;\n\n\t \n\tbt_transfer_leaf(tree, leaf, keep_count + 1, move_count, new_leaf, 0);\n\n\t \n\tuint8_t *buf = kmem_alloc(size, KM_SLEEP);\n\tbcpy(leaf->btl_elems + (leaf->btl_hdr.bth_first + keep_count) * size,\n\t    buf, size);\n\n\tbt_shrink_leaf(tree, leaf, keep_count, 1 + move_count);\n\n\tif (idx < keep_count) {\n\t\t \n\t\tzfs_btree_insert_leaf_impl(tree, leaf, idx, value);\n\t} else if (idx > keep_count) {\n\t\t \n\t\tzfs_btree_insert_leaf_impl(tree, new_leaf, idx - keep_count -\n\t\t    1, value);\n\t} else {\n\t\t \n\t\tzfs_btree_insert_leaf_impl(tree, new_leaf, 0, buf);\n\t\tbcpy(value, buf, size);\n\t}\n\n\t \n\tzfs_btree_insert_into_parent(tree, &leaf->btl_hdr, &new_leaf->btl_hdr,\n\t    buf);\n\tkmem_free(buf, size);\n}\n\nstatic uint32_t\nzfs_btree_find_parent_idx(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n\tvoid *buf;\n\tif (zfs_btree_is_core(hdr)) {\n\t\tbuf = ((zfs_btree_core_t *)hdr)->btc_elems;\n\t} else {\n\t\tbuf = ((zfs_btree_leaf_t *)hdr)->btl_elems +\n\t\t    hdr->bth_first * tree->bt_elem_size;\n\t}\n\tzfs_btree_index_t idx;\n\tzfs_btree_core_t *parent = hdr->bth_parent;\n\tVERIFY3P(tree->bt_find_in_buf(tree, parent->btc_elems,\n\t    parent->btc_hdr.bth_count, buf, &idx), ==, NULL);\n\tASSERT(idx.bti_before);\n\tASSERT3U(idx.bti_offset, <=, parent->btc_hdr.bth_count);\n\tASSERT3P(parent->btc_children[idx.bti_offset], ==, hdr);\n\treturn (idx.bti_offset);\n}\n\n \nstatic void\nzfs_btree_bulk_finish(zfs_btree_t *tree)\n{\n\tASSERT3P(tree->bt_bulk, !=, NULL);\n\tASSERT3P(tree->bt_root, !=, NULL);\n\tzfs_btree_leaf_t *leaf = tree->bt_bulk;\n\tzfs_btree_hdr_t *hdr = &leaf->btl_hdr;\n\tzfs_btree_core_t *parent = hdr->bth_parent;\n\tsize_t size = tree->bt_elem_size;\n\tuint32_t capacity = tree->bt_leaf_cap;\n\n\t \n\tif (parent == NULL) {\n\t\ttree->bt_bulk = NULL;\n\t\treturn;\n\t}\n\n\t \n\tif (hdr->bth_count < capacity / 2) {\n\t\t \n\t\tzfs_btree_index_t idx = {\n\t\t\t.bti_node = hdr,\n\t\t\t.bti_offset = 0\n\t\t};\n\t\tVERIFY3P(zfs_btree_prev(tree, &idx, &idx), !=, NULL);\n\t\tASSERT(zfs_btree_is_core(idx.bti_node));\n\t\tzfs_btree_core_t *common = (zfs_btree_core_t *)idx.bti_node;\n\t\tuint32_t common_idx = idx.bti_offset;\n\n\t\tVERIFY3P(zfs_btree_prev(tree, &idx, &idx), !=, NULL);\n\t\tASSERT(!zfs_btree_is_core(idx.bti_node));\n\t\tzfs_btree_leaf_t *l_neighbor = (zfs_btree_leaf_t *)idx.bti_node;\n\t\tzfs_btree_hdr_t *l_hdr = idx.bti_node;\n\t\tuint32_t move_count = (capacity / 2) - hdr->bth_count;\n\t\tASSERT3U(l_neighbor->btl_hdr.bth_count - move_count, >=,\n\t\t    capacity / 2);\n\n\t\tif (zfs_btree_verify_intensity >= 5) {\n\t\t\tfor (uint32_t i = 0; i < move_count; i++) {\n\t\t\t\tzfs_btree_verify_poison_at(tree, hdr,\n\t\t\t\t    leaf->btl_hdr.bth_count + i);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbt_grow_leaf(tree, leaf, 0, move_count);\n\n\t\t \n\t\tuint8_t *separator = common->btc_elems + common_idx * size;\n\t\tuint8_t *out = leaf->btl_elems +\n\t\t    (hdr->bth_first + move_count - 1) * size;\n\t\tbcpy(separator, out, size);\n\n\t\t \n\t\tbt_transfer_leaf(tree, l_neighbor, l_hdr->bth_count -\n\t\t    (move_count - 1), move_count - 1, leaf, 0);\n\n\t\t \n\t\tbcpy(l_neighbor->btl_elems + (l_hdr->bth_first +\n\t\t    l_hdr->bth_count - move_count) * size, separator, size);\n\n\t\t \n\t\tbt_shrink_leaf(tree, l_neighbor, l_hdr->bth_count - move_count,\n\t\t    move_count);\n\n\t\tASSERT3U(l_hdr->bth_count, >=, capacity / 2);\n\t\tASSERT3U(hdr->bth_count, >=, capacity / 2);\n\t}\n\n\t \n\tcapacity = BTREE_CORE_ELEMS;\n\twhile (parent->btc_hdr.bth_parent != NULL) {\n\t\tzfs_btree_core_t *cur = parent;\n\t\tzfs_btree_hdr_t *hdr = &cur->btc_hdr;\n\t\tparent = hdr->bth_parent;\n\t\t \n\t\tif (hdr->bth_count >= capacity / 2)\n\t\t\tcontinue;\n\n\t\t \n\t\tuint32_t parent_idx = zfs_btree_find_parent_idx(tree, hdr);\n\t\tASSERT3U(parent_idx, >, 0);\n\t\tzfs_btree_core_t *l_neighbor =\n\t\t    (zfs_btree_core_t *)parent->btc_children[parent_idx - 1];\n\t\tuint32_t move_count = (capacity / 2) - hdr->bth_count;\n\t\tASSERT3U(l_neighbor->btc_hdr.bth_count - move_count, >=,\n\t\t    capacity / 2);\n\n\t\tif (zfs_btree_verify_intensity >= 5) {\n\t\t\tfor (uint32_t i = 0; i < move_count; i++) {\n\t\t\t\tzfs_btree_verify_poison_at(tree, hdr,\n\t\t\t\t    hdr->bth_count + i);\n\t\t\t}\n\t\t}\n\t\t \n\t\tbt_shift_core(tree, cur, 0, hdr->bth_count, move_count,\n\t\t    BSS_TRAPEZOID, BSD_RIGHT);\n\n\t\t \n\t\tuint8_t *separator = parent->btc_elems + ((parent_idx - 1) *\n\t\t    size);\n\t\tuint8_t *e_out = cur->btc_elems + ((move_count - 1) * size);\n\t\tbcpy(separator, e_out, size);\n\n\t\t \n\t\tmove_count--;\n\t\tuint32_t move_idx = l_neighbor->btc_hdr.bth_count - move_count;\n\t\tbt_transfer_core(tree, l_neighbor, move_idx, move_count, cur, 0,\n\t\t    BSS_TRAPEZOID);\n\n\t\t \n\t\tmove_idx--;\n\t\tbcpy(l_neighbor->btc_elems + move_idx * size, separator, size);\n\n\t\tl_neighbor->btc_hdr.bth_count -= move_count + 1;\n\t\thdr->bth_count += move_count + 1;\n\n\t\tASSERT3U(l_neighbor->btc_hdr.bth_count, >=, capacity / 2);\n\t\tASSERT3U(hdr->bth_count, >=, capacity / 2);\n\n\t\tzfs_btree_poison_node(tree, &l_neighbor->btc_hdr);\n\n\t\tfor (uint32_t i = 0; i <= hdr->bth_count; i++)\n\t\t\tcur->btc_children[i]->bth_parent = cur;\n\t}\n\n\ttree->bt_bulk = NULL;\n\tzfs_btree_verify(tree);\n}\n\n \nvoid\nzfs_btree_add_idx(zfs_btree_t *tree, const void *value,\n    const zfs_btree_index_t *where)\n{\n\tzfs_btree_index_t idx = {0};\n\n\t \n\tif (tree->bt_bulk != NULL) {\n\t\tif (where->bti_node != &tree->bt_bulk->btl_hdr) {\n\t\t\tzfs_btree_bulk_finish(tree);\n\t\t\tVERIFY3P(zfs_btree_find(tree, value, &idx), ==, NULL);\n\t\t\twhere = &idx;\n\t\t}\n\t}\n\n\ttree->bt_num_elems++;\n\t \n\tif (where->bti_node == NULL) {\n\t\tASSERT3U(tree->bt_num_elems, ==, 1);\n\t\tASSERT3S(tree->bt_height, ==, -1);\n\t\tASSERT3P(tree->bt_root, ==, NULL);\n\t\tASSERT0(where->bti_offset);\n\n\t\ttree->bt_num_nodes++;\n\t\tzfs_btree_leaf_t *leaf = zfs_btree_leaf_alloc(tree);\n\t\ttree->bt_root = &leaf->btl_hdr;\n\t\ttree->bt_height++;\n\n\t\tzfs_btree_hdr_t *hdr = &leaf->btl_hdr;\n\t\thdr->bth_parent = NULL;\n\t\thdr->bth_first = 0;\n\t\thdr->bth_count = 0;\n\t\tzfs_btree_poison_node(tree, hdr);\n\n\t\tzfs_btree_insert_into_leaf(tree, leaf, value, 0);\n\t\ttree->bt_bulk = leaf;\n\t} else if (!zfs_btree_is_core(where->bti_node)) {\n\t\t \n\t\tzfs_btree_insert_into_leaf(tree,\n\t\t    (zfs_btree_leaf_t *)where->bti_node, value,\n\t\t    where->bti_offset);\n\t} else {\n\t\t \n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)where->bti_node;\n\n\t\t \n\t\tuint32_t off = where->bti_offset;\n\t\tzfs_btree_hdr_t *subtree = node->btc_children[off + 1];\n\t\tsize_t size = tree->bt_elem_size;\n\t\tuint8_t *buf = kmem_alloc(size, KM_SLEEP);\n\t\tbcpy(node->btc_elems + off * size, buf, size);\n\t\tbcpy(value, node->btc_elems + off * size, size);\n\n\t\t \n\t\tzfs_btree_index_t new_idx;\n\t\tVERIFY3P(zfs_btree_first_helper(tree, subtree, &new_idx), !=,\n\t\t    NULL);\n\t\tASSERT0(new_idx.bti_offset);\n\t\tASSERT(!zfs_btree_is_core(new_idx.bti_node));\n\t\tzfs_btree_insert_into_leaf(tree,\n\t\t    (zfs_btree_leaf_t *)new_idx.bti_node, buf, 0);\n\t\tkmem_free(buf, size);\n\t}\n\tzfs_btree_verify(tree);\n}\n\n \nvoid *\nzfs_btree_first(zfs_btree_t *tree, zfs_btree_index_t *where)\n{\n\tif (tree->bt_height == -1) {\n\t\tASSERT0(tree->bt_num_elems);\n\t\treturn (NULL);\n\t}\n\treturn (zfs_btree_first_helper(tree, tree->bt_root, where));\n}\n\n \nstatic void *\nzfs_btree_last_helper(zfs_btree_t *btree, zfs_btree_hdr_t *hdr,\n    zfs_btree_index_t *where)\n{\n\tzfs_btree_hdr_t *node;\n\n\tfor (node = hdr; zfs_btree_is_core(node); node =\n\t    ((zfs_btree_core_t *)node)->btc_children[node->bth_count])\n\t\t;\n\n\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)node;\n\tif (where != NULL) {\n\t\twhere->bti_node = node;\n\t\twhere->bti_offset = node->bth_count - 1;\n\t\twhere->bti_before = B_FALSE;\n\t}\n\treturn (leaf->btl_elems + (node->bth_first + node->bth_count - 1) *\n\t    btree->bt_elem_size);\n}\n\n \nvoid *\nzfs_btree_last(zfs_btree_t *tree, zfs_btree_index_t *where)\n{\n\tif (tree->bt_height == -1) {\n\t\tASSERT0(tree->bt_num_elems);\n\t\treturn (NULL);\n\t}\n\treturn (zfs_btree_last_helper(tree, tree->bt_root, where));\n}\n\n \nstatic void *\nzfs_btree_next_helper(zfs_btree_t *tree, const zfs_btree_index_t *idx,\n    zfs_btree_index_t *out_idx,\n    void (*done_func)(zfs_btree_t *, zfs_btree_hdr_t *))\n{\n\tif (idx->bti_node == NULL) {\n\t\tASSERT3S(tree->bt_height, ==, -1);\n\t\treturn (NULL);\n\t}\n\n\tuint32_t offset = idx->bti_offset;\n\tif (!zfs_btree_is_core(idx->bti_node)) {\n\t\t \n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)idx->bti_node;\n\t\tuint32_t new_off = offset + (idx->bti_before ? 0 : 1);\n\t\tif (leaf->btl_hdr.bth_count > new_off) {\n\t\t\tout_idx->bti_node = &leaf->btl_hdr;\n\t\t\tout_idx->bti_offset = new_off;\n\t\t\tout_idx->bti_before = B_FALSE;\n\t\t\treturn (leaf->btl_elems + (leaf->btl_hdr.bth_first +\n\t\t\t    new_off) * tree->bt_elem_size);\n\t\t}\n\n\t\tzfs_btree_hdr_t *prev = &leaf->btl_hdr;\n\t\tfor (zfs_btree_core_t *node = leaf->btl_hdr.bth_parent;\n\t\t    node != NULL; node = node->btc_hdr.bth_parent) {\n\t\t\tzfs_btree_hdr_t *hdr = &node->btc_hdr;\n\t\t\tASSERT(zfs_btree_is_core(hdr));\n\t\t\tuint32_t i = zfs_btree_find_parent_idx(tree, prev);\n\t\t\tif (done_func != NULL)\n\t\t\t\tdone_func(tree, prev);\n\t\t\tif (i == hdr->bth_count) {\n\t\t\t\tprev = hdr;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout_idx->bti_node = hdr;\n\t\t\tout_idx->bti_offset = i;\n\t\t\tout_idx->bti_before = B_FALSE;\n\t\t\treturn (node->btc_elems + i * tree->bt_elem_size);\n\t\t}\n\t\tif (done_func != NULL)\n\t\t\tdone_func(tree, prev);\n\t\t \n\t\treturn (NULL);\n\t}\n\n\t \n\tASSERT(zfs_btree_is_core(idx->bti_node));\n\tzfs_btree_core_t *node = (zfs_btree_core_t *)idx->bti_node;\n\tif (idx->bti_before) {\n\t\tout_idx->bti_before = B_FALSE;\n\t\treturn (node->btc_elems + offset * tree->bt_elem_size);\n\t}\n\n\t \n\tzfs_btree_hdr_t *child = node->btc_children[offset + 1];\n\treturn (zfs_btree_first_helper(tree, child, out_idx));\n}\n\n \nvoid *\nzfs_btree_next(zfs_btree_t *tree, const zfs_btree_index_t *idx,\n    zfs_btree_index_t *out_idx)\n{\n\treturn (zfs_btree_next_helper(tree, idx, out_idx, NULL));\n}\n\n \nvoid *\nzfs_btree_prev(zfs_btree_t *tree, const zfs_btree_index_t *idx,\n    zfs_btree_index_t *out_idx)\n{\n\tif (idx->bti_node == NULL) {\n\t\tASSERT3S(tree->bt_height, ==, -1);\n\t\treturn (NULL);\n\t}\n\n\tuint32_t offset = idx->bti_offset;\n\tif (!zfs_btree_is_core(idx->bti_node)) {\n\t\t \n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)idx->bti_node;\n\t\tif (offset != 0) {\n\t\t\tout_idx->bti_node = &leaf->btl_hdr;\n\t\t\tout_idx->bti_offset = offset - 1;\n\t\t\tout_idx->bti_before = B_FALSE;\n\t\t\treturn (leaf->btl_elems + (leaf->btl_hdr.bth_first +\n\t\t\t    offset - 1) * tree->bt_elem_size);\n\t\t}\n\t\tzfs_btree_hdr_t *prev = &leaf->btl_hdr;\n\t\tfor (zfs_btree_core_t *node = leaf->btl_hdr.bth_parent;\n\t\t    node != NULL; node = node->btc_hdr.bth_parent) {\n\t\t\tzfs_btree_hdr_t *hdr = &node->btc_hdr;\n\t\t\tASSERT(zfs_btree_is_core(hdr));\n\t\t\tuint32_t i = zfs_btree_find_parent_idx(tree, prev);\n\t\t\tif (i == 0) {\n\t\t\t\tprev = hdr;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout_idx->bti_node = hdr;\n\t\t\tout_idx->bti_offset = i - 1;\n\t\t\tout_idx->bti_before = B_FALSE;\n\t\t\treturn (node->btc_elems + (i - 1) * tree->bt_elem_size);\n\t\t}\n\t\t \n\t\treturn (NULL);\n\t}\n\n\t \n\tASSERT(zfs_btree_is_core(idx->bti_node));\n\tzfs_btree_core_t *node = (zfs_btree_core_t *)idx->bti_node;\n\tzfs_btree_hdr_t *child = node->btc_children[offset];\n\treturn (zfs_btree_last_helper(tree, child, out_idx));\n}\n\n \nvoid *\nzfs_btree_get(zfs_btree_t *tree, zfs_btree_index_t *idx)\n{\n\tASSERT(!idx->bti_before);\n\tsize_t size = tree->bt_elem_size;\n\tif (!zfs_btree_is_core(idx->bti_node)) {\n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)idx->bti_node;\n\t\treturn (leaf->btl_elems + (leaf->btl_hdr.bth_first +\n\t\t    idx->bti_offset) * size);\n\t}\n\tzfs_btree_core_t *node = (zfs_btree_core_t *)idx->bti_node;\n\treturn (node->btc_elems + idx->bti_offset * size);\n}\n\n \nvoid\nzfs_btree_add(zfs_btree_t *tree, const void *node)\n{\n\tzfs_btree_index_t where = {0};\n\tVERIFY3P(zfs_btree_find(tree, node, &where), ==, NULL);\n\tzfs_btree_add_idx(tree, node, &where);\n}\n\n \nstatic void\nzfs_btree_node_destroy(zfs_btree_t *tree, zfs_btree_hdr_t *node)\n{\n\ttree->bt_num_nodes--;\n\tif (!zfs_btree_is_core(node)) {\n\t\tzfs_btree_leaf_free(tree, node);\n\t} else {\n\t\tkmem_free(node, sizeof (zfs_btree_core_t) +\n\t\t    BTREE_CORE_ELEMS * tree->bt_elem_size);\n\t}\n}\n\n \nstatic void\nzfs_btree_remove_from_node(zfs_btree_t *tree, zfs_btree_core_t *node,\n    zfs_btree_hdr_t *rm_hdr)\n{\n\tsize_t size = tree->bt_elem_size;\n\tuint32_t min_count = (BTREE_CORE_ELEMS / 2) - 1;\n\tzfs_btree_hdr_t *hdr = &node->btc_hdr;\n\t \n\tif (hdr->bth_parent == NULL && hdr->bth_count <= 1) {\n\t\tASSERT3U(hdr->bth_count, ==, 1);\n\t\tASSERT3P(tree->bt_root, ==, node);\n\t\tASSERT3P(node->btc_children[1], ==, rm_hdr);\n\t\ttree->bt_root = node->btc_children[0];\n\t\tnode->btc_children[0]->bth_parent = NULL;\n\t\tzfs_btree_node_destroy(tree, hdr);\n\t\ttree->bt_height--;\n\t\treturn;\n\t}\n\n\tuint32_t idx;\n\tfor (idx = 0; idx <= hdr->bth_count; idx++) {\n\t\tif (node->btc_children[idx] == rm_hdr)\n\t\t\tbreak;\n\t}\n\tASSERT3U(idx, <=, hdr->bth_count);\n\n\t \n\tif (hdr->bth_parent == NULL ||\n\t    hdr->bth_count > min_count) {\n\t\t \n\t\tbt_shift_core_left(tree, node, idx, hdr->bth_count - idx,\n\t\t    BSS_PARALLELOGRAM);\n\t\thdr->bth_count--;\n\t\tzfs_btree_poison_node_at(tree, hdr, hdr->bth_count, 1);\n\t\treturn;\n\t}\n\n\tASSERT3U(hdr->bth_count, ==, min_count);\n\n\t \n\tzfs_btree_core_t *parent = hdr->bth_parent;\n\tuint32_t parent_idx = zfs_btree_find_parent_idx(tree, hdr);\n\n\tzfs_btree_hdr_t *l_hdr = (parent_idx == 0 ? NULL :\n\t    parent->btc_children[parent_idx - 1]);\n\tif (l_hdr != NULL && l_hdr->bth_count > min_count) {\n\t\t \n\t\tASSERT(zfs_btree_is_core(l_hdr));\n\t\tzfs_btree_core_t *neighbor = (zfs_btree_core_t *)l_hdr;\n\n\t\t \n\t\tbt_shift_core_right(tree, node, 0, idx - 1, BSS_TRAPEZOID);\n\n\t\t \n\t\tuint8_t *separator = parent->btc_elems + (parent_idx - 1) *\n\t\t    size;\n\t\tbcpy(separator, node->btc_elems, size);\n\n\t\t \n\t\tnode->btc_children[0] =\n\t\t    neighbor->btc_children[l_hdr->bth_count];\n\t\tnode->btc_children[0]->bth_parent = node;\n\n\t\t \n\t\tuint8_t *take_elem = neighbor->btc_elems +\n\t\t    (l_hdr->bth_count - 1) * size;\n\t\tbcpy(take_elem, separator, size);\n\t\tl_hdr->bth_count--;\n\t\tzfs_btree_poison_node_at(tree, l_hdr, l_hdr->bth_count, 1);\n\t\treturn;\n\t}\n\n\tzfs_btree_hdr_t *r_hdr = (parent_idx == parent->btc_hdr.bth_count ?\n\t    NULL : parent->btc_children[parent_idx + 1]);\n\tif (r_hdr != NULL && r_hdr->bth_count > min_count) {\n\t\t \n\t\tASSERT(zfs_btree_is_core(r_hdr));\n\t\tzfs_btree_core_t *neighbor = (zfs_btree_core_t *)r_hdr;\n\n\t\t \n\t\tbt_shift_core_left(tree, node, idx, hdr->bth_count - idx,\n\t\t    BSS_PARALLELOGRAM);\n\n\t\t \n\t\tuint8_t *separator = parent->btc_elems + parent_idx * size;\n\t\tbcpy(separator, node->btc_elems + (hdr->bth_count - 1) * size,\n\t\t    size);\n\n\t\t \n\t\tnode->btc_children[hdr->bth_count] = neighbor->btc_children[0];\n\t\tnode->btc_children[hdr->bth_count]->bth_parent = node;\n\n\t\t \n\t\tuint8_t *take_elem = neighbor->btc_elems;\n\t\tbcpy(take_elem, separator, size);\n\t\tr_hdr->bth_count--;\n\n\t\t \n\t\tbt_shift_core_left(tree, neighbor, 1, r_hdr->bth_count,\n\t\t    BSS_TRAPEZOID);\n\t\tzfs_btree_poison_node_at(tree, r_hdr, r_hdr->bth_count, 1);\n\t\treturn;\n\t}\n\n\t \n\tzfs_btree_hdr_t *new_rm_hdr, *keep_hdr;\n\tuint32_t new_idx = idx;\n\tif (l_hdr != NULL) {\n\t\tkeep_hdr = l_hdr;\n\t\tnew_rm_hdr = hdr;\n\t\tnew_idx += keep_hdr->bth_count + 1;\n\t} else {\n\t\tASSERT3P(r_hdr, !=, NULL);\n\t\tkeep_hdr = hdr;\n\t\tnew_rm_hdr = r_hdr;\n\t\tparent_idx++;\n\t}\n\n\tASSERT(zfs_btree_is_core(keep_hdr));\n\tASSERT(zfs_btree_is_core(new_rm_hdr));\n\n\tzfs_btree_core_t *keep = (zfs_btree_core_t *)keep_hdr;\n\tzfs_btree_core_t *rm = (zfs_btree_core_t *)new_rm_hdr;\n\n\tif (zfs_btree_verify_intensity >= 5) {\n\t\tfor (uint32_t i = 0; i < new_rm_hdr->bth_count + 1; i++) {\n\t\t\tzfs_btree_verify_poison_at(tree, keep_hdr,\n\t\t\t    keep_hdr->bth_count + i);\n\t\t}\n\t}\n\n\t \n\tuint8_t *e_out = keep->btc_elems + keep_hdr->bth_count * size;\n\tuint8_t *separator = parent->btc_elems + (parent_idx - 1) *\n\t    size;\n\tbcpy(separator, e_out, size);\n\tkeep_hdr->bth_count++;\n\n\t \n\tbt_transfer_core(tree, rm, 0, new_rm_hdr->bth_count, keep,\n\t    keep_hdr->bth_count, BSS_TRAPEZOID);\n\n\tuint32_t old_count = keep_hdr->bth_count;\n\n\t \n\tkeep_hdr->bth_count += new_rm_hdr->bth_count;\n\tASSERT3U(keep_hdr->bth_count, ==, (min_count * 2) + 1);\n\n\t \n\tASSERT3P(keep->btc_children[new_idx], ==, rm_hdr);\n\tbt_shift_core_left(tree, keep, new_idx, keep_hdr->bth_count - new_idx,\n\t    BSS_PARALLELOGRAM);\n\tkeep_hdr->bth_count--;\n\n\t \n\tzfs_btree_hdr_t **new_start = keep->btc_children +\n\t    old_count - 1;\n\tfor (uint32_t i = 0; i < new_rm_hdr->bth_count + 1; i++)\n\t\tnew_start[i]->bth_parent = keep;\n\tfor (uint32_t i = 0; i <= keep_hdr->bth_count; i++) {\n\t\tASSERT3P(keep->btc_children[i]->bth_parent, ==, keep);\n\t\tASSERT3P(keep->btc_children[i], !=, rm_hdr);\n\t}\n\tzfs_btree_poison_node_at(tree, keep_hdr, keep_hdr->bth_count, 1);\n\n\tnew_rm_hdr->bth_count = 0;\n\tzfs_btree_remove_from_node(tree, parent, new_rm_hdr);\n\tzfs_btree_node_destroy(tree, new_rm_hdr);\n}\n\n \nvoid\nzfs_btree_remove_idx(zfs_btree_t *tree, zfs_btree_index_t *where)\n{\n\tsize_t size = tree->bt_elem_size;\n\tzfs_btree_hdr_t *hdr = where->bti_node;\n\tuint32_t idx = where->bti_offset;\n\n\tASSERT(!where->bti_before);\n\tif (tree->bt_bulk != NULL) {\n\t\t \n\t\tuint8_t *value = zfs_btree_get(tree, where);\n\t\tuint8_t *tmp = kmem_alloc(size, KM_SLEEP);\n\t\tbcpy(value, tmp, size);\n\t\tzfs_btree_bulk_finish(tree);\n\t\tVERIFY3P(zfs_btree_find(tree, tmp, where), !=, NULL);\n\t\tkmem_free(tmp, size);\n\t\thdr = where->bti_node;\n\t\tidx = where->bti_offset;\n\t}\n\n\ttree->bt_num_elems--;\n\t \n\tif (zfs_btree_is_core(hdr)) {\n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\t\tzfs_btree_hdr_t *left_subtree = node->btc_children[idx];\n\t\tvoid *new_value = zfs_btree_last_helper(tree, left_subtree,\n\t\t    where);\n\t\tASSERT3P(new_value, !=, NULL);\n\n\t\tbcpy(new_value, node->btc_elems + idx * size, size);\n\n\t\thdr = where->bti_node;\n\t\tidx = where->bti_offset;\n\t\tASSERT(!where->bti_before);\n\t}\n\n\t \n\tASSERT(!zfs_btree_is_core(hdr));\n\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)hdr;\n\tASSERT3U(hdr->bth_count, >, 0);\n\n\tuint32_t min_count = (tree->bt_leaf_cap / 2) - 1;\n\n\t \n\tif (hdr->bth_count > min_count || hdr->bth_parent == NULL) {\n\t\tbt_shrink_leaf(tree, leaf, idx, 1);\n\t\tif (hdr->bth_parent == NULL) {\n\t\t\tASSERT0(tree->bt_height);\n\t\t\tif (hdr->bth_count == 0) {\n\t\t\t\ttree->bt_root = NULL;\n\t\t\t\ttree->bt_height--;\n\t\t\t\tzfs_btree_node_destroy(tree, &leaf->btl_hdr);\n\t\t\t}\n\t\t}\n\t\tzfs_btree_verify(tree);\n\t\treturn;\n\t}\n\tASSERT3U(hdr->bth_count, ==, min_count);\n\n\t \n\tzfs_btree_core_t *parent = hdr->bth_parent;\n\tuint32_t parent_idx = zfs_btree_find_parent_idx(tree, hdr);\n\n\tzfs_btree_hdr_t *l_hdr = (parent_idx == 0 ? NULL :\n\t    parent->btc_children[parent_idx - 1]);\n\tif (l_hdr != NULL && l_hdr->bth_count > min_count) {\n\t\t \n\t\tASSERT(!zfs_btree_is_core(l_hdr));\n\t\tzfs_btree_leaf_t *neighbor = (zfs_btree_leaf_t *)l_hdr;\n\n\t\t \n\t\tbt_shift_leaf(tree, leaf, 0, idx, 1, BSD_RIGHT);\n\n\t\t \n\t\tuint8_t *separator = parent->btc_elems + (parent_idx - 1) *\n\t\t    size;\n\t\tbcpy(separator, leaf->btl_elems + hdr->bth_first * size, size);\n\n\t\t \n\t\tuint8_t *take_elem = neighbor->btl_elems +\n\t\t    (l_hdr->bth_first + l_hdr->bth_count - 1) * size;\n\t\tbcpy(take_elem, separator, size);\n\n\t\t \n\t\tbt_shrink_leaf(tree, neighbor, l_hdr->bth_count - 1, 1);\n\t\tzfs_btree_verify(tree);\n\t\treturn;\n\t}\n\n\tzfs_btree_hdr_t *r_hdr = (parent_idx == parent->btc_hdr.bth_count ?\n\t    NULL : parent->btc_children[parent_idx + 1]);\n\tif (r_hdr != NULL && r_hdr->bth_count > min_count) {\n\t\t \n\t\tASSERT(!zfs_btree_is_core(r_hdr));\n\t\tzfs_btree_leaf_t *neighbor = (zfs_btree_leaf_t *)r_hdr;\n\n\t\t \n\t\tbt_shift_leaf(tree, leaf, idx + 1, hdr->bth_count - idx - 1,\n\t\t    1, BSD_LEFT);\n\n\t\t \n\t\tuint8_t *separator = parent->btc_elems + parent_idx * size;\n\t\tbcpy(separator, leaf->btl_elems + (hdr->bth_first +\n\t\t    hdr->bth_count - 1) * size, size);\n\n\t\t \n\t\tuint8_t *take_elem = neighbor->btl_elems +\n\t\t    r_hdr->bth_first * size;\n\t\tbcpy(take_elem, separator, size);\n\n\t\t \n\t\tbt_shrink_leaf(tree, neighbor, 0, 1);\n\t\tzfs_btree_verify(tree);\n\t\treturn;\n\t}\n\n\t \n\tzfs_btree_hdr_t *rm_hdr, *k_hdr;\n\tif (l_hdr != NULL) {\n\t\tk_hdr = l_hdr;\n\t\trm_hdr = hdr;\n\t} else {\n\t\tASSERT3P(r_hdr, !=, NULL);\n\t\tk_hdr = hdr;\n\t\trm_hdr = r_hdr;\n\t\tparent_idx++;\n\t}\n\tASSERT(!zfs_btree_is_core(k_hdr));\n\tASSERT(!zfs_btree_is_core(rm_hdr));\n\tASSERT3U(k_hdr->bth_count, ==, min_count);\n\tASSERT3U(rm_hdr->bth_count, ==, min_count);\n\tzfs_btree_leaf_t *keep = (zfs_btree_leaf_t *)k_hdr;\n\tzfs_btree_leaf_t *rm = (zfs_btree_leaf_t *)rm_hdr;\n\n\tif (zfs_btree_verify_intensity >= 5) {\n\t\tfor (uint32_t i = 0; i < rm_hdr->bth_count + 1; i++) {\n\t\t\tzfs_btree_verify_poison_at(tree, k_hdr,\n\t\t\t    k_hdr->bth_count + i);\n\t\t}\n\t}\n\n\t \n\tbt_shrink_leaf(tree, leaf, idx, 1);\n\n\t \n\tuint32_t k_count = k_hdr->bth_count;\n\tbt_grow_leaf(tree, keep, k_count, 1 + rm_hdr->bth_count);\n\tASSERT3U(k_hdr->bth_count, ==, min_count * 2);\n\n\t \n\tuint8_t *out = keep->btl_elems + (k_hdr->bth_first + k_count) * size;\n\tuint8_t *separator = parent->btc_elems + (parent_idx - 1) * size;\n\tbcpy(separator, out, size);\n\n\t \n\tbt_transfer_leaf(tree, rm, 0, rm_hdr->bth_count, keep, k_count + 1);\n\n\t \n\tzfs_btree_remove_from_node(tree, parent, rm_hdr);\n\tzfs_btree_node_destroy(tree, rm_hdr);\n\tzfs_btree_verify(tree);\n}\n\n \nvoid\nzfs_btree_remove(zfs_btree_t *tree, const void *value)\n{\n\tzfs_btree_index_t where = {0};\n\tVERIFY3P(zfs_btree_find(tree, value, &where), !=, NULL);\n\tzfs_btree_remove_idx(tree, &where);\n}\n\n \nulong_t\nzfs_btree_numnodes(zfs_btree_t *tree)\n{\n\treturn (tree->bt_num_elems);\n}\n\n \nvoid *\nzfs_btree_destroy_nodes(zfs_btree_t *tree, zfs_btree_index_t **cookie)\n{\n\tif (*cookie == NULL) {\n\t\tif (tree->bt_height == -1)\n\t\t\treturn (NULL);\n\t\t*cookie = kmem_alloc(sizeof (**cookie), KM_SLEEP);\n\t\treturn (zfs_btree_first(tree, *cookie));\n\t}\n\n\tvoid *rval = zfs_btree_next_helper(tree, *cookie, *cookie,\n\t    zfs_btree_node_destroy);\n\tif (rval == NULL)   {\n\t\ttree->bt_root = NULL;\n\t\ttree->bt_height = -1;\n\t\ttree->bt_num_elems = 0;\n\t\tkmem_free(*cookie, sizeof (**cookie));\n\t\ttree->bt_bulk = NULL;\n\t}\n\treturn (rval);\n}\n\nstatic void\nzfs_btree_clear_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n\tif (zfs_btree_is_core(hdr)) {\n\t\tzfs_btree_core_t *btc = (zfs_btree_core_t *)hdr;\n\t\tfor (uint32_t i = 0; i <= hdr->bth_count; i++)\n\t\t\tzfs_btree_clear_helper(tree, btc->btc_children[i]);\n\t}\n\n\tzfs_btree_node_destroy(tree, hdr);\n}\n\nvoid\nzfs_btree_clear(zfs_btree_t *tree)\n{\n\tif (tree->bt_root == NULL) {\n\t\tASSERT0(tree->bt_num_elems);\n\t\treturn;\n\t}\n\n\tzfs_btree_clear_helper(tree, tree->bt_root);\n\ttree->bt_num_elems = 0;\n\ttree->bt_root = NULL;\n\ttree->bt_num_nodes = 0;\n\ttree->bt_height = -1;\n\ttree->bt_bulk = NULL;\n}\n\nvoid\nzfs_btree_destroy(zfs_btree_t *tree)\n{\n\tASSERT0(tree->bt_num_elems);\n\tASSERT3P(tree->bt_root, ==, NULL);\n}\n\n \nstatic void\nzfs_btree_verify_pointers_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n\tif (!zfs_btree_is_core(hdr))\n\t\treturn;\n\n\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\tfor (uint32_t i = 0; i <= hdr->bth_count; i++) {\n\t\tVERIFY3P(node->btc_children[i]->bth_parent, ==, hdr);\n\t\tzfs_btree_verify_pointers_helper(tree, node->btc_children[i]);\n\t}\n}\n\n \nstatic void\nzfs_btree_verify_pointers(zfs_btree_t *tree)\n{\n\tif (tree->bt_height == -1) {\n\t\tVERIFY3P(tree->bt_root, ==, NULL);\n\t\treturn;\n\t}\n\tVERIFY3P(tree->bt_root->bth_parent, ==, NULL);\n\tzfs_btree_verify_pointers_helper(tree, tree->bt_root);\n}\n\n \nstatic uint64_t\nzfs_btree_verify_counts_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n\tif (!zfs_btree_is_core(hdr)) {\n\t\tif (tree->bt_root != hdr && tree->bt_bulk &&\n\t\t    hdr != &tree->bt_bulk->btl_hdr) {\n\t\t\tVERIFY3U(hdr->bth_count, >=, tree->bt_leaf_cap / 2 - 1);\n\t\t}\n\n\t\treturn (hdr->bth_count);\n\t} else {\n\n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\t\tuint64_t ret = hdr->bth_count;\n\t\tif (tree->bt_root != hdr && tree->bt_bulk == NULL)\n\t\t\tVERIFY3P(hdr->bth_count, >=, BTREE_CORE_ELEMS / 2 - 1);\n\t\tfor (uint32_t i = 0; i <= hdr->bth_count; i++) {\n\t\t\tret += zfs_btree_verify_counts_helper(tree,\n\t\t\t    node->btc_children[i]);\n\t\t}\n\n\t\treturn (ret);\n\t}\n}\n\n \nstatic void\nzfs_btree_verify_counts(zfs_btree_t *tree)\n{\n\tEQUIV(tree->bt_num_elems == 0, tree->bt_height == -1);\n\tif (tree->bt_height == -1) {\n\t\treturn;\n\t}\n\tVERIFY3P(zfs_btree_verify_counts_helper(tree, tree->bt_root), ==,\n\t    tree->bt_num_elems);\n}\n\n \nstatic uint64_t\nzfs_btree_verify_height_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr,\n    int32_t height)\n{\n\tif (!zfs_btree_is_core(hdr)) {\n\t\tVERIFY0(height);\n\t\treturn (1);\n\t}\n\n\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\tuint64_t ret = 1;\n\tfor (uint32_t i = 0; i <= hdr->bth_count; i++) {\n\t\tret += zfs_btree_verify_height_helper(tree,\n\t\t    node->btc_children[i], height - 1);\n\t}\n\treturn (ret);\n}\n\n \nstatic void\nzfs_btree_verify_height(zfs_btree_t *tree)\n{\n\tEQUIV(tree->bt_height == -1, tree->bt_root == NULL);\n\tif (tree->bt_height == -1) {\n\t\treturn;\n\t}\n\n\tVERIFY3U(zfs_btree_verify_height_helper(tree, tree->bt_root,\n\t    tree->bt_height), ==, tree->bt_num_nodes);\n}\n\n \nstatic void\nzfs_btree_verify_order_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n\tsize_t size = tree->bt_elem_size;\n\tif (!zfs_btree_is_core(hdr)) {\n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)hdr;\n\t\tfor (uint32_t i = 1; i < hdr->bth_count; i++) {\n\t\t\tVERIFY3S(tree->bt_compar(leaf->btl_elems +\n\t\t\t    (hdr->bth_first + i - 1) * size,\n\t\t\t    leaf->btl_elems +\n\t\t\t    (hdr->bth_first + i) * size), ==, -1);\n\t\t}\n\t\treturn;\n\t}\n\n\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\tfor (uint32_t i = 1; i < hdr->bth_count; i++) {\n\t\tVERIFY3S(tree->bt_compar(node->btc_elems + (i - 1) * size,\n\t\t    node->btc_elems + i * size), ==, -1);\n\t}\n\tfor (uint32_t i = 0; i < hdr->bth_count; i++) {\n\t\tuint8_t *left_child_last = NULL;\n\t\tzfs_btree_hdr_t *left_child_hdr = node->btc_children[i];\n\t\tif (zfs_btree_is_core(left_child_hdr)) {\n\t\t\tzfs_btree_core_t *left_child =\n\t\t\t    (zfs_btree_core_t *)left_child_hdr;\n\t\t\tleft_child_last = left_child->btc_elems +\n\t\t\t    (left_child_hdr->bth_count - 1) * size;\n\t\t} else {\n\t\t\tzfs_btree_leaf_t *left_child =\n\t\t\t    (zfs_btree_leaf_t *)left_child_hdr;\n\t\t\tleft_child_last = left_child->btl_elems +\n\t\t\t    (left_child_hdr->bth_first +\n\t\t\t    left_child_hdr->bth_count - 1) * size;\n\t\t}\n\t\tint comp = tree->bt_compar(node->btc_elems + i * size,\n\t\t    left_child_last);\n\t\tif (comp <= 0) {\n\t\t\tpanic(\"btree: compar returned %d (expected 1) at \"\n\t\t\t    \"%px %d: compar(%px,  %px)\", comp, node, i,\n\t\t\t    node->btc_elems + i * size, left_child_last);\n\t\t}\n\n\t\tuint8_t *right_child_first = NULL;\n\t\tzfs_btree_hdr_t *right_child_hdr = node->btc_children[i + 1];\n\t\tif (zfs_btree_is_core(right_child_hdr)) {\n\t\t\tzfs_btree_core_t *right_child =\n\t\t\t    (zfs_btree_core_t *)right_child_hdr;\n\t\t\tright_child_first = right_child->btc_elems;\n\t\t} else {\n\t\t\tzfs_btree_leaf_t *right_child =\n\t\t\t    (zfs_btree_leaf_t *)right_child_hdr;\n\t\t\tright_child_first = right_child->btl_elems +\n\t\t\t    right_child_hdr->bth_first * size;\n\t\t}\n\t\tcomp = tree->bt_compar(node->btc_elems + i * size,\n\t\t    right_child_first);\n\t\tif (comp >= 0) {\n\t\t\tpanic(\"btree: compar returned %d (expected -1) at \"\n\t\t\t    \"%px %d: compar(%px,  %px)\", comp, node, i,\n\t\t\t    node->btc_elems + i * size, right_child_first);\n\t\t}\n\t}\n\tfor (uint32_t i = 0; i <= hdr->bth_count; i++)\n\t\tzfs_btree_verify_order_helper(tree, node->btc_children[i]);\n}\n\n \nstatic void\nzfs_btree_verify_order(zfs_btree_t *tree)\n{\n\tEQUIV(tree->bt_height == -1, tree->bt_root == NULL);\n\tif (tree->bt_height == -1) {\n\t\treturn;\n\t}\n\n\tzfs_btree_verify_order_helper(tree, tree->bt_root);\n}\n\n#ifdef ZFS_DEBUG\n \nstatic void\nzfs_btree_verify_poison_helper(zfs_btree_t *tree, zfs_btree_hdr_t *hdr)\n{\n\tsize_t size = tree->bt_elem_size;\n\tif (!zfs_btree_is_core(hdr)) {\n\t\tzfs_btree_leaf_t *leaf = (zfs_btree_leaf_t *)hdr;\n\t\tfor (size_t i = 0; i < hdr->bth_first * size; i++)\n\t\t\tVERIFY3U(leaf->btl_elems[i], ==, 0x0f);\n\t\tsize_t esize = tree->bt_leaf_size -\n\t\t    offsetof(zfs_btree_leaf_t, btl_elems);\n\t\tfor (size_t i = (hdr->bth_first + hdr->bth_count) * size;\n\t\t    i < esize; i++)\n\t\t\tVERIFY3U(leaf->btl_elems[i], ==, 0x0f);\n\t} else {\n\t\tzfs_btree_core_t *node = (zfs_btree_core_t *)hdr;\n\t\tfor (size_t i = hdr->bth_count * size;\n\t\t    i < BTREE_CORE_ELEMS * size; i++)\n\t\t\tVERIFY3U(node->btc_elems[i], ==, 0x0f);\n\n\t\tfor (uint32_t i = hdr->bth_count + 1; i <= BTREE_CORE_ELEMS;\n\t\t    i++) {\n\t\t\tVERIFY3P(node->btc_children[i], ==,\n\t\t\t    (zfs_btree_hdr_t *)BTREE_POISON);\n\t\t}\n\n\t\tfor (uint32_t i = 0; i <= hdr->bth_count; i++) {\n\t\t\tzfs_btree_verify_poison_helper(tree,\n\t\t\t    node->btc_children[i]);\n\t\t}\n\t}\n}\n#endif\n\n \nstatic void\nzfs_btree_verify_poison(zfs_btree_t *tree)\n{\n#ifdef ZFS_DEBUG\n\tif (tree->bt_height == -1)\n\t\treturn;\n\tzfs_btree_verify_poison_helper(tree, tree->bt_root);\n#endif\n}\n\nvoid\nzfs_btree_verify(zfs_btree_t *tree)\n{\n\tif (zfs_btree_verify_intensity == 0)\n\t\treturn;\n\tzfs_btree_verify_height(tree);\n\tif (zfs_btree_verify_intensity == 1)\n\t\treturn;\n\tzfs_btree_verify_pointers(tree);\n\tif (zfs_btree_verify_intensity == 2)\n\t\treturn;\n\tzfs_btree_verify_counts(tree);\n\tif (zfs_btree_verify_intensity == 3)\n\t\treturn;\n\tzfs_btree_verify_order(tree);\n\n\tif (zfs_btree_verify_intensity == 4)\n\t\treturn;\n\tzfs_btree_verify_poison(tree);\n}\n\n \nZFS_MODULE_PARAM(zfs, zfs_, btree_verify_intensity, UINT, ZMOD_RW,\n\t\"Enable btree verification. Levels above 4 require ZFS be built \"\n\t\"with debugging\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}