{
  "module_name": "dmu_send.c",
  "hash_id": "6e6d3daed9afc1c39febe687db0bcee01811cc294db28f6a114138e2936bb710",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dmu_send.c",
  "human_readable_source": " \n \n\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/spa_impl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_znode.h>\n#include <zfs_fletcher.h>\n#include <sys/avl.h>\n#include <sys/ddt.h>\n#include <sys/zfs_onexit.h>\n#include <sys/dmu_send.h>\n#include <sys/dmu_recv.h>\n#include <sys/dsl_destroy.h>\n#include <sys/blkptr.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/zfeature.h>\n#include <sys/bqueue.h>\n#include <sys/zvol.h>\n#include <sys/policy.h>\n#include <sys/objlist.h>\n#ifdef _KERNEL\n#include <sys/zfs_vfsops.h>\n#endif\n\n \nstatic int zfs_send_corrupt_data = B_FALSE;\n \nstatic uint_t zfs_send_queue_length = SPA_MAXBLOCKSIZE;\n \nstatic uint_t zfs_send_no_prefetch_queue_length = 1024 * 1024;\n \nstatic uint_t zfs_send_queue_ff = 20;\nstatic uint_t zfs_send_no_prefetch_queue_ff = 20;\n\n \nstatic uint_t zfs_override_estimate_recordsize = 0;\n\n \nstatic const boolean_t zfs_send_set_freerecords_bit = B_TRUE;\n\n \nstatic int zfs_send_unmodified_spill_blocks = B_TRUE;\n\nstatic inline boolean_t\noverflow_multiply(uint64_t a, uint64_t b, uint64_t *c)\n{\n\tuint64_t temp = a * b;\n\tif (b != 0 && temp / b != a)\n\t\treturn (B_FALSE);\n\t*c = temp;\n\treturn (B_TRUE);\n}\n\nstruct send_thread_arg {\n\tbqueue_t\tq;\n\tobjset_t\t*os;\t\t \n\tuint64_t\tfromtxg;\t \n\tint\t\tflags;\t\t \n\tint\t\terror_code;\n\tboolean_t\tcancel;\n\tzbookmark_phys_t resume;\n\tuint64_t\t*num_blocks_visited;\n};\n\nstruct redact_list_thread_arg {\n\tboolean_t\t\tcancel;\n\tbqueue_t\t\tq;\n\tzbookmark_phys_t\tresume;\n\tredaction_list_t\t*rl;\n\tboolean_t\t\tmark_redact;\n\tint\t\t\terror_code;\n\tuint64_t\t\t*num_blocks_visited;\n};\n\nstruct send_merge_thread_arg {\n\tbqueue_t\t\t\tq;\n\tobjset_t\t\t\t*os;\n\tstruct redact_list_thread_arg\t*from_arg;\n\tstruct send_thread_arg\t\t*to_arg;\n\tstruct redact_list_thread_arg\t*redact_arg;\n\tint\t\t\t\terror;\n\tboolean_t\t\t\tcancel;\n};\n\nstruct send_range {\n\tboolean_t\t\teos_marker;  \n\tuint64_t\t\tobject;\n\tuint64_t\t\tstart_blkid;\n\tuint64_t\t\tend_blkid;\n\tbqueue_node_t\t\tln;\n\tenum type {DATA, HOLE, OBJECT, OBJECT_RANGE, REDACT,\n\t    PREVIOUSLY_REDACTED} type;\n\tunion {\n\t\tstruct srd {\n\t\t\tdmu_object_type_t\tobj_type;\n\t\t\tuint32_t\t\tdatablksz;  \n\t\t\tuint32_t\t\tdatasz;  \n\t\t\tblkptr_t\t\tbp;\n\t\t\tarc_buf_t\t\t*abuf;\n\t\t\tabd_t\t\t\t*abd;\n\t\t\tkmutex_t\t\tlock;\n\t\t\tkcondvar_t\t\tcv;\n\t\t\tboolean_t\t\tio_outstanding;\n\t\t\tboolean_t\t\tio_compressed;\n\t\t\tint\t\t\tio_err;\n\t\t} data;\n\t\tstruct srh {\n\t\t\tuint32_t\t\tdatablksz;\n\t\t} hole;\n\t\tstruct sro {\n\t\t\t \n\t\t\tdnode_phys_t\t\t*dnp;\n\t\t\tblkptr_t\t\tbp;\n\t\t} object;\n\t\tstruct srr {\n\t\t\tuint32_t\t\tdatablksz;\n\t\t} redact;\n\t\tstruct sror {\n\t\t\tblkptr_t\t\tbp;\n\t\t} object_range;\n\t} sru;\n};\n\n \ntypedef enum {\n\tPENDING_NONE,\n\tPENDING_FREE,\n\tPENDING_FREEOBJECTS,\n\tPENDING_REDACT\n} dmu_pendop_t;\n\ntypedef struct dmu_send_cookie {\n\tdmu_replay_record_t *dsc_drr;\n\tdmu_send_outparams_t *dsc_dso;\n\toffset_t *dsc_off;\n\tobjset_t *dsc_os;\n\tzio_cksum_t dsc_zc;\n\tuint64_t dsc_toguid;\n\tuint64_t dsc_fromtxg;\n\tint dsc_err;\n\tdmu_pendop_t dsc_pending_op;\n\tuint64_t dsc_featureflags;\n\tuint64_t dsc_last_data_object;\n\tuint64_t dsc_last_data_offset;\n\tuint64_t dsc_resume_object;\n\tuint64_t dsc_resume_offset;\n\tboolean_t dsc_sent_begin;\n\tboolean_t dsc_sent_end;\n} dmu_send_cookie_t;\n\nstatic int do_dump(dmu_send_cookie_t *dscp, struct send_range *range);\n\nstatic void\nrange_free(struct send_range *range)\n{\n\tif (range->type == OBJECT) {\n\t\tsize_t size = sizeof (dnode_phys_t) *\n\t\t    (range->sru.object.dnp->dn_extra_slots + 1);\n\t\tkmem_free(range->sru.object.dnp, size);\n\t} else if (range->type == DATA) {\n\t\tmutex_enter(&range->sru.data.lock);\n\t\twhile (range->sru.data.io_outstanding)\n\t\t\tcv_wait(&range->sru.data.cv, &range->sru.data.lock);\n\t\tif (range->sru.data.abd != NULL)\n\t\t\tabd_free(range->sru.data.abd);\n\t\tif (range->sru.data.abuf != NULL) {\n\t\t\tarc_buf_destroy(range->sru.data.abuf,\n\t\t\t    &range->sru.data.abuf);\n\t\t}\n\t\tmutex_exit(&range->sru.data.lock);\n\n\t\tcv_destroy(&range->sru.data.cv);\n\t\tmutex_destroy(&range->sru.data.lock);\n\t}\n\tkmem_free(range, sizeof (*range));\n}\n\n \nstatic int\ndump_record(dmu_send_cookie_t *dscp, void *payload, int payload_len)\n{\n\tdmu_send_outparams_t *dso = dscp->dsc_dso;\n\tASSERT3U(offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum),\n\t    ==, sizeof (dmu_replay_record_t) - sizeof (zio_cksum_t));\n\t(void) fletcher_4_incremental_native(dscp->dsc_drr,\n\t    offsetof(dmu_replay_record_t, drr_u.drr_checksum.drr_checksum),\n\t    &dscp->dsc_zc);\n\tif (dscp->dsc_drr->drr_type == DRR_BEGIN) {\n\t\tdscp->dsc_sent_begin = B_TRUE;\n\t} else {\n\t\tASSERT(ZIO_CHECKSUM_IS_ZERO(&dscp->dsc_drr->drr_u.\n\t\t    drr_checksum.drr_checksum));\n\t\tdscp->dsc_drr->drr_u.drr_checksum.drr_checksum = dscp->dsc_zc;\n\t}\n\tif (dscp->dsc_drr->drr_type == DRR_END) {\n\t\tdscp->dsc_sent_end = B_TRUE;\n\t}\n\t(void) fletcher_4_incremental_native(&dscp->dsc_drr->\n\t    drr_u.drr_checksum.drr_checksum,\n\t    sizeof (zio_cksum_t), &dscp->dsc_zc);\n\t*dscp->dsc_off += sizeof (dmu_replay_record_t);\n\tdscp->dsc_err = dso->dso_outfunc(dscp->dsc_os, dscp->dsc_drr,\n\t    sizeof (dmu_replay_record_t), dso->dso_arg);\n\tif (dscp->dsc_err != 0)\n\t\treturn (SET_ERROR(EINTR));\n\tif (payload_len != 0) {\n\t\t*dscp->dsc_off += payload_len;\n\t\t \n\t\tif (payload != NULL) {\n\t\t\t(void) fletcher_4_incremental_native(\n\t\t\t    payload, payload_len, &dscp->dsc_zc);\n\t\t}\n\n\t\t \n\n\t\tASSERT((payload_len % 8 == 0) ||\n\t\t    (dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW));\n\n\t\tdscp->dsc_err = dso->dso_outfunc(dscp->dsc_os, payload,\n\t\t    payload_len, dso->dso_arg);\n\t\tif (dscp->dsc_err != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t}\n\treturn (0);\n}\n\n \nstatic int\ndump_free(dmu_send_cookie_t *dscp, uint64_t object, uint64_t offset,\n    uint64_t length)\n{\n\tstruct drr_free *drrf = &(dscp->dsc_drr->drr_u.drr_free);\n\n\t \n\tASSERT(object > dscp->dsc_last_data_object ||\n\t    (object == dscp->dsc_last_data_object &&\n\t    offset > dscp->dsc_last_data_offset));\n\n\t \n\tif (dscp->dsc_pending_op != PENDING_NONE &&\n\t    dscp->dsc_pending_op != PENDING_FREE) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\tif (dscp->dsc_pending_op == PENDING_FREE) {\n\t\t \n\t\tif (drrf->drr_object == object && drrf->drr_offset +\n\t\t    drrf->drr_length == offset) {\n\t\t\tif (offset + length < offset || length == UINT64_MAX)\n\t\t\t\tdrrf->drr_length = UINT64_MAX;\n\t\t\telse\n\t\t\t\tdrrf->drr_length += length;\n\t\t\treturn (0);\n\t\t} else {\n\t\t\t \n\t\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\t\treturn (SET_ERROR(EINTR));\n\t\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t\t}\n\t}\n\t \n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_FREE;\n\tdrrf->drr_object = object;\n\tdrrf->drr_offset = offset;\n\tif (offset + length < offset)\n\t\tdrrf->drr_length = DMU_OBJECT_END;\n\telse\n\t\tdrrf->drr_length = length;\n\tdrrf->drr_toguid = dscp->dsc_toguid;\n\tif (length == DMU_OBJECT_END) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t} else {\n\t\tdscp->dsc_pending_op = PENDING_FREE;\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\ndump_redact(dmu_send_cookie_t *dscp, uint64_t object, uint64_t offset,\n    uint64_t length)\n{\n\tstruct drr_redact *drrr = &dscp->dsc_drr->drr_u.drr_redact;\n\n\t \n\tif (dscp->dsc_pending_op != PENDING_NONE &&\n\t    dscp->dsc_pending_op != PENDING_REDACT) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\tif (dscp->dsc_pending_op == PENDING_REDACT) {\n\t\t \n\t\tif (drrr->drr_object == object && drrr->drr_offset +\n\t\t    drrr->drr_length == offset) {\n\t\t\tdrrr->drr_length += length;\n\t\t\treturn (0);\n\t\t} else {\n\t\t\t \n\t\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\t\treturn (SET_ERROR(EINTR));\n\t\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t\t}\n\t}\n\t \n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_REDACT;\n\tdrrr->drr_object = object;\n\tdrrr->drr_offset = offset;\n\tdrrr->drr_length = length;\n\tdrrr->drr_toguid = dscp->dsc_toguid;\n\tdscp->dsc_pending_op = PENDING_REDACT;\n\n\treturn (0);\n}\n\nstatic int\ndmu_dump_write(dmu_send_cookie_t *dscp, dmu_object_type_t type, uint64_t object,\n    uint64_t offset, int lsize, int psize, const blkptr_t *bp,\n    boolean_t io_compressed, void *data)\n{\n\tuint64_t payload_size;\n\tboolean_t raw = (dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW);\n\tstruct drr_write *drrw = &(dscp->dsc_drr->drr_u.drr_write);\n\n\t \n\tASSERT(object > dscp->dsc_last_data_object ||\n\t    (object == dscp->dsc_last_data_object &&\n\t    offset > dscp->dsc_last_data_offset));\n\tdscp->dsc_last_data_object = object;\n\tdscp->dsc_last_data_offset = offset + lsize - 1;\n\n\t \n\tif (dscp->dsc_pending_op != PENDING_NONE) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\t \n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_WRITE;\n\tdrrw->drr_object = object;\n\tdrrw->drr_type = type;\n\tdrrw->drr_offset = offset;\n\tdrrw->drr_toguid = dscp->dsc_toguid;\n\tdrrw->drr_logical_size = lsize;\n\n\t \n\tboolean_t compressed =\n\t    (bp != NULL ? BP_GET_COMPRESS(bp) != ZIO_COMPRESS_OFF &&\n\t    io_compressed : lsize != psize);\n\tif (raw || compressed) {\n\t\tASSERT(bp != NULL);\n\t\tASSERT(raw || dscp->dsc_featureflags &\n\t\t    DMU_BACKUP_FEATURE_COMPRESSED);\n\t\tASSERT(!BP_IS_EMBEDDED(bp));\n\t\tASSERT3S(psize, >, 0);\n\n\t\tif (raw) {\n\t\t\tASSERT(BP_IS_PROTECTED(bp));\n\n\t\t\t \n\t\t\tif (BP_SHOULD_BYTESWAP(bp))\n\t\t\t\tdrrw->drr_flags |= DRR_RAW_BYTESWAP;\n\t\t\tzio_crypt_decode_params_bp(bp, drrw->drr_salt,\n\t\t\t    drrw->drr_iv);\n\t\t\tzio_crypt_decode_mac_bp(bp, drrw->drr_mac);\n\t\t} else {\n\t\t\t \n\t\t\tASSERT(dscp->dsc_featureflags &\n\t\t\t    DMU_BACKUP_FEATURE_COMPRESSED);\n\t\t\tASSERT(!BP_SHOULD_BYTESWAP(bp));\n\t\t\tASSERT(!DMU_OT_IS_METADATA(BP_GET_TYPE(bp)));\n\t\t\tASSERT3U(BP_GET_COMPRESS(bp), !=, ZIO_COMPRESS_OFF);\n\t\t\tASSERT3S(lsize, >=, psize);\n\t\t}\n\n\t\t \n\t\tdrrw->drr_compressiontype = BP_GET_COMPRESS(bp);\n\t\tdrrw->drr_compressed_size = psize;\n\t\tpayload_size = drrw->drr_compressed_size;\n\t} else {\n\t\tpayload_size = drrw->drr_logical_size;\n\t}\n\n\tif (bp == NULL || BP_IS_EMBEDDED(bp) || (BP_IS_PROTECTED(bp) && !raw)) {\n\t\t \n\t\tdrrw->drr_checksumtype = ZIO_CHECKSUM_OFF;\n\t} else {\n\t\tdrrw->drr_checksumtype = BP_GET_CHECKSUM(bp);\n\t\tif (zio_checksum_table[drrw->drr_checksumtype].ci_flags &\n\t\t    ZCHECKSUM_FLAG_DEDUP)\n\t\t\tdrrw->drr_flags |= DRR_CHECKSUM_DEDUP;\n\t\tDDK_SET_LSIZE(&drrw->drr_key, BP_GET_LSIZE(bp));\n\t\tDDK_SET_PSIZE(&drrw->drr_key, BP_GET_PSIZE(bp));\n\t\tDDK_SET_COMPRESS(&drrw->drr_key, BP_GET_COMPRESS(bp));\n\t\tDDK_SET_CRYPT(&drrw->drr_key, BP_IS_PROTECTED(bp));\n\t\tdrrw->drr_key.ddk_cksum = bp->blk_cksum;\n\t}\n\n\tif (dump_record(dscp, data, payload_size) != 0)\n\t\treturn (SET_ERROR(EINTR));\n\treturn (0);\n}\n\nstatic int\ndump_write_embedded(dmu_send_cookie_t *dscp, uint64_t object, uint64_t offset,\n    int blksz, const blkptr_t *bp)\n{\n\tchar buf[BPE_PAYLOAD_SIZE];\n\tstruct drr_write_embedded *drrw =\n\t    &(dscp->dsc_drr->drr_u.drr_write_embedded);\n\n\tif (dscp->dsc_pending_op != PENDING_NONE) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\tASSERT(BP_IS_EMBEDDED(bp));\n\n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_WRITE_EMBEDDED;\n\tdrrw->drr_object = object;\n\tdrrw->drr_offset = offset;\n\tdrrw->drr_length = blksz;\n\tdrrw->drr_toguid = dscp->dsc_toguid;\n\tdrrw->drr_compression = BP_GET_COMPRESS(bp);\n\tdrrw->drr_etype = BPE_GET_ETYPE(bp);\n\tdrrw->drr_lsize = BPE_GET_LSIZE(bp);\n\tdrrw->drr_psize = BPE_GET_PSIZE(bp);\n\n\tdecode_embedded_bp_compressed(bp, buf);\n\n\tuint32_t psize = drrw->drr_psize;\n\tuint32_t rsize = P2ROUNDUP(psize, 8);\n\n\tif (psize != rsize)\n\t\tmemset(buf + psize, 0, rsize - psize);\n\n\tif (dump_record(dscp, buf, rsize) != 0)\n\t\treturn (SET_ERROR(EINTR));\n\treturn (0);\n}\n\nstatic int\ndump_spill(dmu_send_cookie_t *dscp, const blkptr_t *bp, uint64_t object,\n    void *data)\n{\n\tstruct drr_spill *drrs = &(dscp->dsc_drr->drr_u.drr_spill);\n\tuint64_t blksz = BP_GET_LSIZE(bp);\n\tuint64_t payload_size = blksz;\n\n\tif (dscp->dsc_pending_op != PENDING_NONE) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\t \n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_SPILL;\n\tdrrs->drr_object = object;\n\tdrrs->drr_length = blksz;\n\tdrrs->drr_toguid = dscp->dsc_toguid;\n\n\t \n\tif (zfs_send_unmodified_spill_blocks &&\n\t    (bp->blk_birth <= dscp->dsc_fromtxg)) {\n\t\tdrrs->drr_flags |= DRR_SPILL_UNMODIFIED;\n\t}\n\n\t \n\tif (dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\tASSERT(BP_IS_PROTECTED(bp));\n\n\t\tif (BP_SHOULD_BYTESWAP(bp))\n\t\t\tdrrs->drr_flags |= DRR_RAW_BYTESWAP;\n\t\tdrrs->drr_compressiontype = BP_GET_COMPRESS(bp);\n\t\tdrrs->drr_compressed_size = BP_GET_PSIZE(bp);\n\t\tzio_crypt_decode_params_bp(bp, drrs->drr_salt, drrs->drr_iv);\n\t\tzio_crypt_decode_mac_bp(bp, drrs->drr_mac);\n\t\tpayload_size = drrs->drr_compressed_size;\n\t}\n\n\tif (dump_record(dscp, data, payload_size) != 0)\n\t\treturn (SET_ERROR(EINTR));\n\treturn (0);\n}\n\nstatic int\ndump_freeobjects(dmu_send_cookie_t *dscp, uint64_t firstobj, uint64_t numobjs)\n{\n\tstruct drr_freeobjects *drrfo = &(dscp->dsc_drr->drr_u.drr_freeobjects);\n\tuint64_t maxobj = DNODES_PER_BLOCK *\n\t    (DMU_META_DNODE(dscp->dsc_os)->dn_maxblkid + 1);\n\n\t \n\tif (maxobj > 0) {\n\t\tif (maxobj <= firstobj)\n\t\t\treturn (0);\n\n\t\tif (maxobj < firstobj + numobjs)\n\t\t\tnumobjs = maxobj - firstobj;\n\t}\n\n\t \n\tif (dscp->dsc_pending_op != PENDING_NONE &&\n\t    dscp->dsc_pending_op != PENDING_FREEOBJECTS) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\tif (dscp->dsc_pending_op == PENDING_FREEOBJECTS) {\n\t\t \n\t\tif (drrfo->drr_firstobj + drrfo->drr_numobjs == firstobj) {\n\t\t\tdrrfo->drr_numobjs += numobjs;\n\t\t\treturn (0);\n\t\t} else {\n\t\t\t \n\t\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\t\treturn (SET_ERROR(EINTR));\n\t\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t\t}\n\t}\n\n\t \n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_FREEOBJECTS;\n\tdrrfo->drr_firstobj = firstobj;\n\tdrrfo->drr_numobjs = numobjs;\n\tdrrfo->drr_toguid = dscp->dsc_toguid;\n\n\tdscp->dsc_pending_op = PENDING_FREEOBJECTS;\n\n\treturn (0);\n}\n\nstatic int\ndump_dnode(dmu_send_cookie_t *dscp, const blkptr_t *bp, uint64_t object,\n    dnode_phys_t *dnp)\n{\n\tstruct drr_object *drro = &(dscp->dsc_drr->drr_u.drr_object);\n\tint bonuslen;\n\n\tif (object < dscp->dsc_resume_object) {\n\t\t \n\t\tASSERT3U(dscp->dsc_resume_object - object, <,\n\t\t    1 << (DNODE_BLOCK_SHIFT - DNODE_SHIFT));\n\t\treturn (0);\n\t}\n\n\tif (dnp == NULL || dnp->dn_type == DMU_OT_NONE)\n\t\treturn (dump_freeobjects(dscp, object, 1));\n\n\tif (dscp->dsc_pending_op != PENDING_NONE) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\t \n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_OBJECT;\n\tdrro->drr_object = object;\n\tdrro->drr_type = dnp->dn_type;\n\tdrro->drr_bonustype = dnp->dn_bonustype;\n\tdrro->drr_blksz = dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT;\n\tdrro->drr_bonuslen = dnp->dn_bonuslen;\n\tdrro->drr_dn_slots = dnp->dn_extra_slots + 1;\n\tdrro->drr_checksumtype = dnp->dn_checksum;\n\tdrro->drr_compress = dnp->dn_compress;\n\tdrro->drr_toguid = dscp->dsc_toguid;\n\n\tif (!(dscp->dsc_featureflags & DMU_BACKUP_FEATURE_LARGE_BLOCKS) &&\n\t    drro->drr_blksz > SPA_OLD_MAXBLOCKSIZE)\n\t\tdrro->drr_blksz = SPA_OLD_MAXBLOCKSIZE;\n\n\tbonuslen = P2ROUNDUP(dnp->dn_bonuslen, 8);\n\n\tif ((dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW)) {\n\t\tASSERT(BP_IS_ENCRYPTED(bp));\n\n\t\tif (BP_SHOULD_BYTESWAP(bp))\n\t\t\tdrro->drr_flags |= DRR_RAW_BYTESWAP;\n\n\t\t \n\t\tdrro->drr_maxblkid = dnp->dn_maxblkid;\n\t\tdrro->drr_indblkshift = dnp->dn_indblkshift;\n\t\tdrro->drr_nlevels = dnp->dn_nlevels;\n\t\tdrro->drr_nblkptr = dnp->dn_nblkptr;\n\n\t\t \n\t\tif (bonuslen != 0) {\n\t\t\tif (drro->drr_bonuslen > DN_MAX_BONUS_LEN(dnp))\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\tdrro->drr_raw_bonuslen = DN_MAX_BONUS_LEN(dnp);\n\t\t\tbonuslen = drro->drr_raw_bonuslen;\n\t\t}\n\t}\n\n\t \n\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR)\n\t\tdrro->drr_flags |= DRR_OBJECT_SPILL;\n\n\tif (dump_record(dscp, DN_BONUS(dnp), bonuslen) != 0)\n\t\treturn (SET_ERROR(EINTR));\n\n\t \n\tif (dump_free(dscp, object, (dnp->dn_maxblkid + 1) *\n\t    (dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT), DMU_OBJECT_END) != 0)\n\t\treturn (SET_ERROR(EINTR));\n\n\t \n\tif (zfs_send_unmodified_spill_blocks &&\n\t    (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) &&\n\t    (DN_SPILL_BLKPTR(dnp)->blk_birth <= dscp->dsc_fromtxg)) {\n\t\tstruct send_range record;\n\t\tblkptr_t *bp = DN_SPILL_BLKPTR(dnp);\n\n\t\tmemset(&record, 0, sizeof (struct send_range));\n\t\trecord.type = DATA;\n\t\trecord.object = object;\n\t\trecord.eos_marker = B_FALSE;\n\t\trecord.start_blkid = DMU_SPILL_BLKID;\n\t\trecord.end_blkid = record.start_blkid + 1;\n\t\trecord.sru.data.bp = *bp;\n\t\trecord.sru.data.obj_type = dnp->dn_type;\n\t\trecord.sru.data.datablksz = BP_GET_LSIZE(bp);\n\n\t\tif (do_dump(dscp, &record) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t}\n\n\tif (dscp->dsc_err != 0)\n\t\treturn (SET_ERROR(EINTR));\n\n\treturn (0);\n}\n\nstatic int\ndump_object_range(dmu_send_cookie_t *dscp, const blkptr_t *bp,\n    uint64_t firstobj, uint64_t numslots)\n{\n\tstruct drr_object_range *drror =\n\t    &(dscp->dsc_drr->drr_u.drr_object_range);\n\n\t \n\tASSERT(BP_IS_PROTECTED(bp));\n\tASSERT(dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW);\n\tASSERT3U(BP_GET_COMPRESS(bp), ==, ZIO_COMPRESS_OFF);\n\tASSERT3U(BP_GET_TYPE(bp), ==, DMU_OT_DNODE);\n\tASSERT0(BP_GET_LEVEL(bp));\n\n\tif (dscp->dsc_pending_op != PENDING_NONE) {\n\t\tif (dump_record(dscp, NULL, 0) != 0)\n\t\t\treturn (SET_ERROR(EINTR));\n\t\tdscp->dsc_pending_op = PENDING_NONE;\n\t}\n\n\tmemset(dscp->dsc_drr, 0, sizeof (dmu_replay_record_t));\n\tdscp->dsc_drr->drr_type = DRR_OBJECT_RANGE;\n\tdrror->drr_firstobj = firstobj;\n\tdrror->drr_numslots = numslots;\n\tdrror->drr_toguid = dscp->dsc_toguid;\n\tif (BP_SHOULD_BYTESWAP(bp))\n\t\tdrror->drr_flags |= DRR_RAW_BYTESWAP;\n\tzio_crypt_decode_params_bp(bp, drror->drr_salt, drror->drr_iv);\n\tzio_crypt_decode_mac_bp(bp, drror->drr_mac);\n\n\tif (dump_record(dscp, NULL, 0) != 0)\n\t\treturn (SET_ERROR(EINTR));\n\treturn (0);\n}\n\nstatic boolean_t\nsend_do_embed(const blkptr_t *bp, uint64_t featureflags)\n{\n\tif (!BP_IS_EMBEDDED(bp))\n\t\treturn (B_FALSE);\n\n\t \n\tif ((BP_GET_COMPRESS(bp) >= ZIO_COMPRESS_LEGACY_FUNCTIONS &&\n\t    !(featureflags & DMU_BACKUP_FEATURE_LZ4)))\n\t\treturn (B_FALSE);\n\n\t \n\tif ((BP_GET_COMPRESS(bp) == ZIO_COMPRESS_ZSTD &&\n\t    !(featureflags & DMU_BACKUP_FEATURE_ZSTD)))\n\t\treturn (B_FALSE);\n\n\t \n\tswitch (BPE_GET_ETYPE(bp)) {\n\tcase BP_EMBEDDED_TYPE_DATA:\n\t\tif (featureflags & DMU_BACKUP_FEATURE_EMBED_DATA)\n\t\t\treturn (B_TRUE);\n\t\tbreak;\n\tdefault:\n\t\treturn (B_FALSE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nstatic int\ndo_dump(dmu_send_cookie_t *dscp, struct send_range *range)\n{\n\tint err = 0;\n\tswitch (range->type) {\n\tcase OBJECT:\n\t\terr = dump_dnode(dscp, &range->sru.object.bp, range->object,\n\t\t    range->sru.object.dnp);\n\t\treturn (err);\n\tcase OBJECT_RANGE: {\n\t\tASSERT3U(range->start_blkid + 1, ==, range->end_blkid);\n\t\tif (!(dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW)) {\n\t\t\treturn (0);\n\t\t}\n\t\tuint64_t epb = BP_GET_LSIZE(&range->sru.object_range.bp) >>\n\t\t    DNODE_SHIFT;\n\t\tuint64_t firstobj = range->start_blkid * epb;\n\t\terr = dump_object_range(dscp, &range->sru.object_range.bp,\n\t\t    firstobj, epb);\n\t\tbreak;\n\t}\n\tcase REDACT: {\n\t\tstruct srr *srrp = &range->sru.redact;\n\t\terr = dump_redact(dscp, range->object, range->start_blkid *\n\t\t    srrp->datablksz, (range->end_blkid - range->start_blkid) *\n\t\t    srrp->datablksz);\n\t\treturn (err);\n\t}\n\tcase DATA: {\n\t\tstruct srd *srdp = &range->sru.data;\n\t\tblkptr_t *bp = &srdp->bp;\n\t\tspa_t *spa =\n\t\t    dmu_objset_spa(dscp->dsc_os);\n\n\t\tASSERT3U(srdp->datablksz, ==, BP_GET_LSIZE(bp));\n\t\tASSERT3U(range->start_blkid + 1, ==, range->end_blkid);\n\t\tif (BP_GET_TYPE(bp) == DMU_OT_SA) {\n\t\t\tarc_flags_t aflags = ARC_FLAG_WAIT;\n\t\t\tzio_flag_t zioflags = ZIO_FLAG_CANFAIL;\n\n\t\t\tif (dscp->dsc_featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\t\t\tASSERT(BP_IS_PROTECTED(bp));\n\t\t\t\tzioflags |= ZIO_FLAG_RAW;\n\t\t\t}\n\n\t\t\tzbookmark_phys_t zb;\n\t\t\tASSERT3U(range->start_blkid, ==, DMU_SPILL_BLKID);\n\t\t\tzb.zb_objset = dmu_objset_id(dscp->dsc_os);\n\t\t\tzb.zb_object = range->object;\n\t\t\tzb.zb_level = 0;\n\t\t\tzb.zb_blkid = range->start_blkid;\n\n\t\t\tarc_buf_t *abuf = NULL;\n\t\t\tif (!dscp->dsc_dso->dso_dryrun && arc_read(NULL, spa,\n\t\t\t    bp, arc_getbuf_func, &abuf, ZIO_PRIORITY_ASYNC_READ,\n\t\t\t    zioflags, &aflags, &zb) != 0)\n\t\t\t\treturn (SET_ERROR(EIO));\n\n\t\t\terr = dump_spill(dscp, bp, zb.zb_object,\n\t\t\t    (abuf == NULL ? NULL : abuf->b_data));\n\t\t\tif (abuf != NULL)\n\t\t\t\tarc_buf_destroy(abuf, &abuf);\n\t\t\treturn (err);\n\t\t}\n\t\tif (send_do_embed(bp, dscp->dsc_featureflags)) {\n\t\t\terr = dump_write_embedded(dscp, range->object,\n\t\t\t    range->start_blkid * srdp->datablksz,\n\t\t\t    srdp->datablksz, bp);\n\t\t\treturn (err);\n\t\t}\n\t\tASSERT(range->object > dscp->dsc_resume_object ||\n\t\t    (range->object == dscp->dsc_resume_object &&\n\t\t    range->start_blkid * srdp->datablksz >=\n\t\t    dscp->dsc_resume_offset));\n\t\t \n\n\t\tmutex_enter(&srdp->lock);\n\t\twhile (srdp->io_outstanding)\n\t\t\tcv_wait(&srdp->cv, &srdp->lock);\n\t\terr = srdp->io_err;\n\t\tmutex_exit(&srdp->lock);\n\n\t\tif (err != 0) {\n\t\t\tif (zfs_send_corrupt_data &&\n\t\t\t    !dscp->dsc_dso->dso_dryrun) {\n\t\t\t\t \n\t\t\t\tsrdp->abuf = arc_alloc_buf(spa, &srdp->abuf,\n\t\t\t\t    ARC_BUFC_DATA, srdp->datablksz);\n\t\t\t\tuint64_t *ptr;\n\t\t\t\tfor (ptr = srdp->abuf->b_data;\n\t\t\t\t    (char *)ptr < (char *)srdp->abuf->b_data +\n\t\t\t\t    srdp->datablksz; ptr++)\n\t\t\t\t\t*ptr = 0x2f5baddb10cULL;\n\t\t\t} else {\n\t\t\t\treturn (SET_ERROR(EIO));\n\t\t\t}\n\t\t}\n\n\t\tASSERT(dscp->dsc_dso->dso_dryrun ||\n\t\t    srdp->abuf != NULL || srdp->abd != NULL);\n\n\t\tuint64_t offset = range->start_blkid * srdp->datablksz;\n\n\t\tchar *data = NULL;\n\t\tif (srdp->abd != NULL) {\n\t\t\tdata = abd_to_buf(srdp->abd);\n\t\t\tASSERT3P(srdp->abuf, ==, NULL);\n\t\t} else if (srdp->abuf != NULL) {\n\t\t\tdata = srdp->abuf->b_data;\n\t\t}\n\n\t\t \n\t\tif (srdp->datablksz > SPA_OLD_MAXBLOCKSIZE &&\n\t\t    !(dscp->dsc_featureflags &\n\t\t    DMU_BACKUP_FEATURE_LARGE_BLOCKS)) {\n\t\t\twhile (srdp->datablksz > 0 && err == 0) {\n\t\t\t\tint n = MIN(srdp->datablksz,\n\t\t\t\t    SPA_OLD_MAXBLOCKSIZE);\n\t\t\t\terr = dmu_dump_write(dscp, srdp->obj_type,\n\t\t\t\t    range->object, offset, n, n, NULL, B_FALSE,\n\t\t\t\t    data);\n\t\t\t\toffset += n;\n\t\t\t\t \n\t\t\t\tif (data != NULL)\n\t\t\t\t\tdata += n;\n\t\t\t\tsrdp->datablksz -= n;\n\t\t\t}\n\t\t} else {\n\t\t\terr = dmu_dump_write(dscp, srdp->obj_type,\n\t\t\t    range->object, offset,\n\t\t\t    srdp->datablksz, srdp->datasz, bp,\n\t\t\t    srdp->io_compressed, data);\n\t\t}\n\t\treturn (err);\n\t}\n\tcase HOLE: {\n\t\tstruct srh *srhp = &range->sru.hole;\n\t\tif (range->object == DMU_META_DNODE_OBJECT) {\n\t\t\tuint32_t span = srhp->datablksz >> DNODE_SHIFT;\n\t\t\tuint64_t first_obj = range->start_blkid * span;\n\t\t\tuint64_t numobj = range->end_blkid * span - first_obj;\n\t\t\treturn (dump_freeobjects(dscp, first_obj, numobj));\n\t\t}\n\t\tuint64_t offset = 0;\n\n\t\t \n\t\tif (!overflow_multiply(range->start_blkid, srhp->datablksz,\n\t\t    &offset)) {\n\t\t\treturn (0);\n\t\t}\n\t\tuint64_t len = 0;\n\n\t\tif (!overflow_multiply(range->end_blkid, srhp->datablksz, &len))\n\t\t\tlen = UINT64_MAX;\n\t\tlen = len - offset;\n\t\treturn (dump_free(dscp, range->object, offset, len));\n\t}\n\tdefault:\n\t\tpanic(\"Invalid range type in do_dump: %d\", range->type);\n\t}\n\treturn (err);\n}\n\nstatic struct send_range *\nrange_alloc(enum type type, uint64_t object, uint64_t start_blkid,\n    uint64_t end_blkid, boolean_t eos)\n{\n\tstruct send_range *range = kmem_alloc(sizeof (*range), KM_SLEEP);\n\trange->type = type;\n\trange->object = object;\n\trange->start_blkid = start_blkid;\n\trange->end_blkid = end_blkid;\n\trange->eos_marker = eos;\n\tif (type == DATA) {\n\t\trange->sru.data.abd = NULL;\n\t\trange->sru.data.abuf = NULL;\n\t\tmutex_init(&range->sru.data.lock, NULL, MUTEX_DEFAULT, NULL);\n\t\tcv_init(&range->sru.data.cv, NULL, CV_DEFAULT, NULL);\n\t\trange->sru.data.io_outstanding = 0;\n\t\trange->sru.data.io_err = 0;\n\t\trange->sru.data.io_compressed = B_FALSE;\n\t}\n\treturn (range);\n}\n\n \nstatic int\nsend_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,\n    const zbookmark_phys_t *zb, const struct dnode_phys *dnp, void *arg)\n{\n\t(void) zilog;\n\tstruct send_thread_arg *sta = arg;\n\tstruct send_range *record;\n\n\tASSERT(zb->zb_object == DMU_META_DNODE_OBJECT ||\n\t    zb->zb_object >= sta->resume.zb_object);\n\n\t \n\tif (sta->os->os_encrypted &&\n\t    !BP_IS_HOLE(bp) && !BP_USES_CRYPT(bp)) {\n\t\tspa_log_error(spa, zb, &bp->blk_birth);\n\t\tzfs_panic_recover(\"unencrypted block in encrypted \"\n\t\t    \"object set %llu\", dmu_objset_id(sta->os));\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\tif (sta->cancel)\n\t\treturn (SET_ERROR(EINTR));\n\tif (zb->zb_object != DMU_META_DNODE_OBJECT &&\n\t    DMU_OBJECT_IS_SPECIAL(zb->zb_object))\n\t\treturn (0);\n\tatomic_inc_64(sta->num_blocks_visited);\n\n\tif (zb->zb_level == ZB_DNODE_LEVEL) {\n\t\tif (zb->zb_object == DMU_META_DNODE_OBJECT)\n\t\t\treturn (0);\n\t\trecord = range_alloc(OBJECT, zb->zb_object, 0, 0, B_FALSE);\n\t\trecord->sru.object.bp = *bp;\n\t\tsize_t size  = sizeof (*dnp) * (dnp->dn_extra_slots + 1);\n\t\trecord->sru.object.dnp = kmem_alloc(size, KM_SLEEP);\n\t\tmemcpy(record->sru.object.dnp, dnp, size);\n\t\tbqueue_enqueue(&sta->q, record, sizeof (*record));\n\t\treturn (0);\n\t}\n\tif (zb->zb_level == 0 && zb->zb_object == DMU_META_DNODE_OBJECT &&\n\t    !BP_IS_HOLE(bp)) {\n\t\trecord = range_alloc(OBJECT_RANGE, 0, zb->zb_blkid,\n\t\t    zb->zb_blkid + 1, B_FALSE);\n\t\trecord->sru.object_range.bp = *bp;\n\t\tbqueue_enqueue(&sta->q, record, sizeof (*record));\n\t\treturn (0);\n\t}\n\tif (zb->zb_level < 0 || (zb->zb_level > 0 && !BP_IS_HOLE(bp)))\n\t\treturn (0);\n\tif (zb->zb_object == DMU_META_DNODE_OBJECT && !BP_IS_HOLE(bp))\n\t\treturn (0);\n\n\tuint64_t span = bp_span_in_blocks(dnp->dn_indblkshift, zb->zb_level);\n\tuint64_t start;\n\n\t \n\tif (!overflow_multiply(span, zb->zb_blkid, &start) || (!(zb->zb_blkid ==\n\t    DMU_SPILL_BLKID || DMU_OT_IS_METADATA(dnp->dn_type)) &&\n\t    span * zb->zb_blkid > dnp->dn_maxblkid)) {\n\t\tASSERT(BP_IS_HOLE(bp));\n\t\treturn (0);\n\t}\n\n\tif (zb->zb_blkid == DMU_SPILL_BLKID)\n\t\tASSERT3U(BP_GET_TYPE(bp), ==, DMU_OT_SA);\n\n\tenum type record_type = DATA;\n\tif (BP_IS_HOLE(bp))\n\t\trecord_type = HOLE;\n\telse if (BP_IS_REDACTED(bp))\n\t\trecord_type = REDACT;\n\telse\n\t\trecord_type = DATA;\n\n\trecord = range_alloc(record_type, zb->zb_object, start,\n\t    (start + span < start ? 0 : start + span), B_FALSE);\n\n\tuint64_t datablksz = (zb->zb_blkid == DMU_SPILL_BLKID ?\n\t    BP_GET_LSIZE(bp) : dnp->dn_datablkszsec << SPA_MINBLOCKSHIFT);\n\n\tif (BP_IS_HOLE(bp)) {\n\t\trecord->sru.hole.datablksz = datablksz;\n\t} else if (BP_IS_REDACTED(bp)) {\n\t\trecord->sru.redact.datablksz = datablksz;\n\t} else {\n\t\trecord->sru.data.datablksz = datablksz;\n\t\trecord->sru.data.obj_type = dnp->dn_type;\n\t\trecord->sru.data.bp = *bp;\n\t}\n\n\tbqueue_enqueue(&sta->q, record, sizeof (*record));\n\treturn (0);\n}\n\nstruct redact_list_cb_arg {\n\tuint64_t *num_blocks_visited;\n\tbqueue_t *q;\n\tboolean_t *cancel;\n\tboolean_t mark_redact;\n};\n\nstatic int\nredact_list_cb(redact_block_phys_t *rb, void *arg)\n{\n\tstruct redact_list_cb_arg *rlcap = arg;\n\n\tatomic_inc_64(rlcap->num_blocks_visited);\n\tif (*rlcap->cancel)\n\t\treturn (-1);\n\n\tstruct send_range *data = range_alloc(REDACT, rb->rbp_object,\n\t    rb->rbp_blkid, rb->rbp_blkid + redact_block_get_count(rb), B_FALSE);\n\tASSERT3U(data->end_blkid, >, rb->rbp_blkid);\n\tif (rlcap->mark_redact) {\n\t\tdata->type = REDACT;\n\t\tdata->sru.redact.datablksz = redact_block_get_size(rb);\n\t} else {\n\t\tdata->type = PREVIOUSLY_REDACTED;\n\t}\n\tbqueue_enqueue(rlcap->q, data, sizeof (*data));\n\n\treturn (0);\n}\n\n \nstatic __attribute__((noreturn)) void\nsend_traverse_thread(void *arg)\n{\n\tstruct send_thread_arg *st_arg = arg;\n\tint err = 0;\n\tstruct send_range *data;\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\n\terr = traverse_dataset_resume(st_arg->os->os_dsl_dataset,\n\t    st_arg->fromtxg, &st_arg->resume,\n\t    st_arg->flags, send_cb, st_arg);\n\n\tif (err != EINTR)\n\t\tst_arg->error_code = err;\n\tdata = range_alloc(DATA, 0, 0, 0, B_TRUE);\n\tbqueue_enqueue_flush(&st_arg->q, data, sizeof (*data));\n\tspl_fstrans_unmark(cookie);\n\tthread_exit();\n}\n\n \nstatic int __attribute__((unused))\nsend_range_after(const struct send_range *from, const struct send_range *to)\n{\n\tif (from->eos_marker == B_TRUE)\n\t\treturn (1);\n\tif (to->eos_marker == B_TRUE)\n\t\treturn (-1);\n\n\tuint64_t from_obj = from->object;\n\tuint64_t from_end_obj = from->object + 1;\n\tuint64_t to_obj = to->object;\n\tuint64_t to_end_obj = to->object + 1;\n\tif (from_obj == 0) {\n\t\tASSERT(from->type == HOLE || from->type == OBJECT_RANGE);\n\t\tfrom_obj = from->start_blkid << DNODES_PER_BLOCK_SHIFT;\n\t\tfrom_end_obj = from->end_blkid << DNODES_PER_BLOCK_SHIFT;\n\t}\n\tif (to_obj == 0) {\n\t\tASSERT(to->type == HOLE || to->type == OBJECT_RANGE);\n\t\tto_obj = to->start_blkid << DNODES_PER_BLOCK_SHIFT;\n\t\tto_end_obj = to->end_blkid << DNODES_PER_BLOCK_SHIFT;\n\t}\n\n\tif (from_end_obj <= to_obj)\n\t\treturn (-1);\n\tif (from_obj >= to_end_obj)\n\t\treturn (1);\n\tint64_t cmp = TREE_CMP(to->type == OBJECT_RANGE, from->type ==\n\t    OBJECT_RANGE);\n\tif (unlikely(cmp))\n\t\treturn (cmp);\n\tcmp = TREE_CMP(to->type == OBJECT, from->type == OBJECT);\n\tif (unlikely(cmp))\n\t\treturn (cmp);\n\tif (from->end_blkid <= to->start_blkid)\n\t\treturn (-1);\n\tif (from->start_blkid >= to->end_blkid)\n\t\treturn (1);\n\treturn (0);\n}\n\n \nstatic struct send_range *\nget_next_range_nofree(bqueue_t *bq, struct send_range *prev)\n{\n\tstruct send_range *next = bqueue_dequeue(bq);\n\tASSERT3S(send_range_after(prev, next), ==, -1);\n\treturn (next);\n}\n\n \nstatic struct send_range *\nget_next_range(bqueue_t *bq, struct send_range *prev)\n{\n\tstruct send_range *next = get_next_range_nofree(bq, prev);\n\trange_free(prev);\n\treturn (next);\n}\n\nstatic __attribute__((noreturn)) void\nredact_list_thread(void *arg)\n{\n\tstruct redact_list_thread_arg *rlt_arg = arg;\n\tstruct send_range *record;\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\tif (rlt_arg->rl != NULL) {\n\t\tstruct redact_list_cb_arg rlcba = {0};\n\t\trlcba.cancel = &rlt_arg->cancel;\n\t\trlcba.q = &rlt_arg->q;\n\t\trlcba.num_blocks_visited = rlt_arg->num_blocks_visited;\n\t\trlcba.mark_redact = rlt_arg->mark_redact;\n\t\tint err = dsl_redaction_list_traverse(rlt_arg->rl,\n\t\t    &rlt_arg->resume, redact_list_cb, &rlcba);\n\t\tif (err != EINTR)\n\t\t\trlt_arg->error_code = err;\n\t}\n\trecord = range_alloc(DATA, 0, 0, 0, B_TRUE);\n\tbqueue_enqueue_flush(&rlt_arg->q, record, sizeof (*record));\n\tspl_fstrans_unmark(cookie);\n\n\tthread_exit();\n}\n\n \nstatic int\nsend_range_start_compare(struct send_range *r1, struct send_range *r2)\n{\n\tuint64_t r1_objequiv = r1->object;\n\tuint64_t r1_l0equiv = r1->start_blkid;\n\tuint64_t r2_objequiv = r2->object;\n\tuint64_t r2_l0equiv = r2->start_blkid;\n\tint64_t cmp = TREE_CMP(r1->eos_marker, r2->eos_marker);\n\tif (unlikely(cmp))\n\t\treturn (cmp);\n\tif (r1->object == 0) {\n\t\tr1_objequiv = r1->start_blkid * DNODES_PER_BLOCK;\n\t\tr1_l0equiv = 0;\n\t}\n\tif (r2->object == 0) {\n\t\tr2_objequiv = r2->start_blkid * DNODES_PER_BLOCK;\n\t\tr2_l0equiv = 0;\n\t}\n\n\tcmp = TREE_CMP(r1_objequiv, r2_objequiv);\n\tif (likely(cmp))\n\t\treturn (cmp);\n\tcmp = TREE_CMP(r2->type == OBJECT_RANGE, r1->type == OBJECT_RANGE);\n\tif (unlikely(cmp))\n\t\treturn (cmp);\n\tcmp = TREE_CMP(r2->type == OBJECT, r1->type == OBJECT);\n\tif (unlikely(cmp))\n\t\treturn (cmp);\n\n\treturn (TREE_CMP(r1_l0equiv, r2_l0equiv));\n}\n\nenum q_idx {\n\tREDACT_IDX = 0,\n\tTO_IDX,\n\tFROM_IDX,\n\tNUM_THREADS\n};\n\n \nstatic struct send_range *\nfind_next_range(struct send_range **ranges, bqueue_t **qs, uint64_t *out_mask)\n{\n\tint idx = 0;  \n\tint i;\n\tuint64_t bmask = 0;\n\tfor (i = 1; i < NUM_THREADS; i++) {\n\t\tif (send_range_start_compare(ranges[i], ranges[idx]) < 0)\n\t\t\tidx = i;\n\t}\n\tif (ranges[idx]->eos_marker) {\n\t\tstruct send_range *ret = range_alloc(DATA, 0, 0, 0, B_TRUE);\n\t\t*out_mask = 0;\n\t\treturn (ret);\n\t}\n\t \n\tfor (i = 0; i < NUM_THREADS; i++) {\n\t\tif (send_range_start_compare(ranges[i], ranges[idx]) == 0)\n\t\t\tbmask |= 1 << i;\n\t}\n\t*out_mask = bmask;\n\t \n\tif (ranges[idx]->type == OBJECT_RANGE) {\n\t\tASSERT3U(idx, ==, TO_IDX);\n\t\tASSERT3U(*out_mask, ==, 1 << TO_IDX);\n\t\tstruct send_range *ret = ranges[idx];\n\t\tranges[idx] = get_next_range_nofree(qs[idx], ranges[idx]);\n\t\treturn (ret);\n\t}\n\t \n\tuint64_t first_change = ranges[idx]->end_blkid;\n\tfor (i = 0; i < NUM_THREADS; i++) {\n\t\tif (i == idx || ranges[i]->eos_marker ||\n\t\t    ranges[i]->object > ranges[idx]->object ||\n\t\t    ranges[i]->object == DMU_META_DNODE_OBJECT)\n\t\t\tcontinue;\n\t\tASSERT3U(ranges[i]->object, ==, ranges[idx]->object);\n\t\tif (first_change > ranges[i]->start_blkid &&\n\t\t    (bmask & (1 << i)) == 0)\n\t\t\tfirst_change = ranges[i]->start_blkid;\n\t\telse if (first_change > ranges[i]->end_blkid)\n\t\t\tfirst_change = ranges[i]->end_blkid;\n\t}\n\t \n\tfor (i = 0; i < NUM_THREADS; i++) {\n\t\tif (i == idx || (bmask & (1 << i)) == 0)\n\t\t\tcontinue;\n\t\tASSERT3U(first_change, >, ranges[i]->start_blkid);\n\t\tranges[i]->start_blkid = first_change;\n\t\tASSERT3U(ranges[i]->start_blkid, <=, ranges[i]->end_blkid);\n\t\tif (ranges[i]->start_blkid == ranges[i]->end_blkid)\n\t\t\tranges[i] = get_next_range(qs[i], ranges[i]);\n\t}\n\t \n\tif (first_change == ranges[idx]->end_blkid) {\n\t\tstruct send_range *ret = ranges[idx];\n\t\tranges[idx] = get_next_range_nofree(qs[idx], ranges[idx]);\n\t\treturn (ret);\n\t}\n\n\t \n\tstruct send_range *ret = kmem_alloc(sizeof (*ret), KM_SLEEP);\n\t*ret = *ranges[idx];\n\tret->end_blkid = first_change;\n\tranges[idx]->start_blkid = first_change;\n\treturn (ret);\n}\n\n#define\tFROM_AND_REDACT_BITS ((1 << REDACT_IDX) | (1 << FROM_IDX))\n\n \nstatic __attribute__((noreturn)) void\nsend_merge_thread(void *arg)\n{\n\tstruct send_merge_thread_arg *smt_arg = arg;\n\tstruct send_range *front_ranges[NUM_THREADS];\n\tbqueue_t *queues[NUM_THREADS];\n\tint err = 0;\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\n\tif (smt_arg->redact_arg == NULL) {\n\t\tfront_ranges[REDACT_IDX] =\n\t\t    kmem_zalloc(sizeof (struct send_range), KM_SLEEP);\n\t\tfront_ranges[REDACT_IDX]->eos_marker = B_TRUE;\n\t\tfront_ranges[REDACT_IDX]->type = REDACT;\n\t\tqueues[REDACT_IDX] = NULL;\n\t} else {\n\t\tfront_ranges[REDACT_IDX] =\n\t\t    bqueue_dequeue(&smt_arg->redact_arg->q);\n\t\tqueues[REDACT_IDX] = &smt_arg->redact_arg->q;\n\t}\n\tfront_ranges[TO_IDX] = bqueue_dequeue(&smt_arg->to_arg->q);\n\tqueues[TO_IDX] = &smt_arg->to_arg->q;\n\tfront_ranges[FROM_IDX] = bqueue_dequeue(&smt_arg->from_arg->q);\n\tqueues[FROM_IDX] = &smt_arg->from_arg->q;\n\tuint64_t mask = 0;\n\tstruct send_range *range;\n\tfor (range = find_next_range(front_ranges, queues, &mask);\n\t    !range->eos_marker && err == 0 && !smt_arg->cancel;\n\t    range = find_next_range(front_ranges, queues, &mask)) {\n\t\t \n\t\tif ((mask & FROM_AND_REDACT_BITS) == FROM_AND_REDACT_BITS) {\n\t\t\tASSERT3U(range->type, ==, REDACT);\n\t\t\trange_free(range);\n\t\t\tcontinue;\n\t\t}\n\t\tbqueue_enqueue(&smt_arg->q, range, sizeof (*range));\n\n\t\tif (smt_arg->to_arg->error_code != 0) {\n\t\t\terr = smt_arg->to_arg->error_code;\n\t\t} else if (smt_arg->from_arg->error_code != 0) {\n\t\t\terr = smt_arg->from_arg->error_code;\n\t\t} else if (smt_arg->redact_arg != NULL &&\n\t\t    smt_arg->redact_arg->error_code != 0) {\n\t\t\terr = smt_arg->redact_arg->error_code;\n\t\t}\n\t}\n\tif (smt_arg->cancel && err == 0)\n\t\terr = SET_ERROR(EINTR);\n\tsmt_arg->error = err;\n\tif (smt_arg->error != 0) {\n\t\tsmt_arg->to_arg->cancel = B_TRUE;\n\t\tsmt_arg->from_arg->cancel = B_TRUE;\n\t\tif (smt_arg->redact_arg != NULL)\n\t\t\tsmt_arg->redact_arg->cancel = B_TRUE;\n\t}\n\tfor (int i = 0; i < NUM_THREADS; i++) {\n\t\twhile (!front_ranges[i]->eos_marker) {\n\t\t\tfront_ranges[i] = get_next_range(queues[i],\n\t\t\t    front_ranges[i]);\n\t\t}\n\t\trange_free(front_ranges[i]);\n\t}\n\trange->eos_marker = B_TRUE;\n\tbqueue_enqueue_flush(&smt_arg->q, range, 1);\n\tspl_fstrans_unmark(cookie);\n\tthread_exit();\n}\n\nstruct send_reader_thread_arg {\n\tstruct send_merge_thread_arg *smta;\n\tbqueue_t q;\n\tboolean_t cancel;\n\tboolean_t issue_reads;\n\tuint64_t featureflags;\n\tint error;\n};\n\nstatic void\ndmu_send_read_done(zio_t *zio)\n{\n\tstruct send_range *range = zio->io_private;\n\n\tmutex_enter(&range->sru.data.lock);\n\tif (zio->io_error != 0) {\n\t\tabd_free(range->sru.data.abd);\n\t\trange->sru.data.abd = NULL;\n\t\trange->sru.data.io_err = zio->io_error;\n\t}\n\n\tASSERT(range->sru.data.io_outstanding);\n\trange->sru.data.io_outstanding = B_FALSE;\n\tcv_broadcast(&range->sru.data.cv);\n\tmutex_exit(&range->sru.data.lock);\n}\n\nstatic void\nissue_data_read(struct send_reader_thread_arg *srta, struct send_range *range)\n{\n\tstruct srd *srdp = &range->sru.data;\n\tblkptr_t *bp = &srdp->bp;\n\tobjset_t *os = srta->smta->os;\n\n\tASSERT3U(range->type, ==, DATA);\n\tASSERT3U(range->start_blkid + 1, ==, range->end_blkid);\n\t \n\tboolean_t split_large_blocks =\n\t    srdp->datablksz > SPA_OLD_MAXBLOCKSIZE &&\n\t    !(srta->featureflags & DMU_BACKUP_FEATURE_LARGE_BLOCKS);\n\t \n\tboolean_t request_compressed =\n\t    (srta->featureflags & DMU_BACKUP_FEATURE_COMPRESSED) &&\n\t    !split_large_blocks && !BP_SHOULD_BYTESWAP(bp) &&\n\t    !BP_IS_EMBEDDED(bp) && !DMU_OT_IS_METADATA(BP_GET_TYPE(bp));\n\n\tzio_flag_t zioflags = ZIO_FLAG_CANFAIL;\n\n\tif (srta->featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\tzioflags |= ZIO_FLAG_RAW;\n\t\tsrdp->io_compressed = B_TRUE;\n\t} else if (request_compressed) {\n\t\tzioflags |= ZIO_FLAG_RAW_COMPRESS;\n\t\tsrdp->io_compressed = B_TRUE;\n\t}\n\n\tsrdp->datasz = (zioflags & ZIO_FLAG_RAW_COMPRESS) ?\n\t    BP_GET_PSIZE(bp) : BP_GET_LSIZE(bp);\n\n\tif (!srta->issue_reads)\n\t\treturn;\n\tif (BP_IS_REDACTED(bp))\n\t\treturn;\n\tif (send_do_embed(bp, srta->featureflags))\n\t\treturn;\n\n\tzbookmark_phys_t zb = {\n\t    .zb_objset = dmu_objset_id(os),\n\t    .zb_object = range->object,\n\t    .zb_level = 0,\n\t    .zb_blkid = range->start_blkid,\n\t};\n\n\tarc_flags_t aflags = ARC_FLAG_CACHED_ONLY;\n\n\tint arc_err = arc_read(NULL, os->os_spa, bp,\n\t    arc_getbuf_func, &srdp->abuf, ZIO_PRIORITY_ASYNC_READ,\n\t    zioflags, &aflags, &zb);\n\t \n\tif (arc_err != 0) {\n\t\tsrdp->abd = abd_alloc_linear(srdp->datasz, B_FALSE);\n\t\tsrdp->io_outstanding = B_TRUE;\n\t\tzio_nowait(zio_read(NULL, os->os_spa, bp, srdp->abd,\n\t\t    srdp->datasz, dmu_send_read_done, range,\n\t\t    ZIO_PRIORITY_ASYNC_READ, zioflags, &zb));\n\t}\n}\n\n \nstatic void\nenqueue_range(struct send_reader_thread_arg *srta, bqueue_t *q, dnode_t *dn,\n    uint64_t blkid, uint64_t count, const blkptr_t *bp, uint32_t datablksz)\n{\n\tenum type range_type = (bp == NULL || BP_IS_HOLE(bp) ? HOLE :\n\t    (BP_IS_REDACTED(bp) ? REDACT : DATA));\n\n\tstruct send_range *range = range_alloc(range_type, dn->dn_object,\n\t    blkid, blkid + count, B_FALSE);\n\n\tif (blkid == DMU_SPILL_BLKID) {\n\t\tASSERT3P(bp, !=, NULL);\n\t\tASSERT3U(BP_GET_TYPE(bp), ==, DMU_OT_SA);\n\t}\n\n\tswitch (range_type) {\n\tcase HOLE:\n\t\trange->sru.hole.datablksz = datablksz;\n\t\tbreak;\n\tcase DATA:\n\t\tASSERT3U(count, ==, 1);\n\t\trange->sru.data.datablksz = datablksz;\n\t\trange->sru.data.obj_type = dn->dn_type;\n\t\trange->sru.data.bp = *bp;\n\t\tissue_data_read(srta, range);\n\t\tbreak;\n\tcase REDACT:\n\t\trange->sru.redact.datablksz = datablksz;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tbqueue_enqueue(q, range, datablksz);\n}\n\n \nstatic __attribute__((noreturn)) void\nsend_reader_thread(void *arg)\n{\n\tstruct send_reader_thread_arg *srta = arg;\n\tstruct send_merge_thread_arg *smta = srta->smta;\n\tbqueue_t *inq = &smta->q;\n\tbqueue_t *outq = &srta->q;\n\tobjset_t *os = smta->os;\n\tfstrans_cookie_t cookie = spl_fstrans_mark();\n\tstruct send_range *range = bqueue_dequeue(inq);\n\tint err = 0;\n\n\t \n\tuint64_t last_obj = UINT64_MAX;\n\tuint64_t last_obj_exists = B_TRUE;\n\twhile (!range->eos_marker && !srta->cancel && smta->error == 0 &&\n\t    err == 0) {\n\t\tswitch (range->type) {\n\t\tcase DATA:\n\t\t\tissue_data_read(srta, range);\n\t\t\tbqueue_enqueue(outq, range, range->sru.data.datablksz);\n\t\t\trange = get_next_range_nofree(inq, range);\n\t\t\tbreak;\n\t\tcase HOLE:\n\t\tcase OBJECT:\n\t\tcase OBJECT_RANGE:\n\t\tcase REDACT: \n\t\t\tbqueue_enqueue(outq, range, sizeof (*range));\n\t\t\trange = get_next_range_nofree(inq, range);\n\t\t\tbreak;\n\t\tcase PREVIOUSLY_REDACTED: {\n\t\t\t \n\t\t\tboolean_t object_exists = B_TRUE;\n\t\t\t \n\t\t\tdnode_t *dn;\n\t\t\tif (range->object == last_obj && !last_obj_exists) {\n\t\t\t\t \n\t\t\t\tobject_exists = B_FALSE;\n\t\t\t} else {\n\t\t\t\terr = dnode_hold(os, range->object, FTAG, &dn);\n\t\t\t\tif (err == ENOENT) {\n\t\t\t\t\tobject_exists = B_FALSE;\n\t\t\t\t\terr = 0;\n\t\t\t\t}\n\t\t\t\tlast_obj = range->object;\n\t\t\t\tlast_obj_exists = object_exists;\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (!object_exists) {\n\t\t\t\t \n\t\t\t\trange = get_next_range(inq, range);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuint64_t file_max =\n\t\t\t    MIN(dn->dn_maxblkid, range->end_blkid);\n\t\t\t \n\t\t\trw_enter(&dn->dn_struct_rwlock, RW_READER);\n\t\t\tfor (uint64_t blkid = range->start_blkid;\n\t\t\t    blkid < file_max; blkid++) {\n\t\t\t\tblkptr_t bp;\n\t\t\t\tuint32_t datablksz =\n\t\t\t\t    dn->dn_phys->dn_datablkszsec <<\n\t\t\t\t    SPA_MINBLOCKSHIFT;\n\t\t\t\tuint64_t offset = blkid * datablksz;\n\t\t\t\t \n\t\t\t\terr = dnode_next_offset(dn, DNODE_FIND_HAVELOCK,\n\t\t\t\t    &offset, 1, 1, 0);\n\t\t\t\tif (err == ESRCH) {\n\t\t\t\t\toffset = UINT64_MAX;\n\t\t\t\t\terr = 0;\n\t\t\t\t} else if (err != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (offset != blkid * datablksz) {\n\t\t\t\t\t \n\t\t\t\t\toffset = MIN(offset, file_max *\n\t\t\t\t\t    datablksz);\n\t\t\t\t\tuint64_t nblks = (offset / datablksz) -\n\t\t\t\t\t    blkid;\n\t\t\t\t\tenqueue_range(srta, outq, dn, blkid,\n\t\t\t\t\t    nblks, NULL, datablksz);\n\t\t\t\t\tblkid += nblks;\n\t\t\t\t}\n\t\t\t\tif (blkid >= file_max)\n\t\t\t\t\tbreak;\n\t\t\t\terr = dbuf_dnode_findbp(dn, 0, blkid, &bp,\n\t\t\t\t    NULL, NULL);\n\t\t\t\tif (err != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tASSERT(!BP_IS_HOLE(&bp));\n\t\t\t\tenqueue_range(srta, outq, dn, blkid, 1, &bp,\n\t\t\t\t    datablksz);\n\t\t\t}\n\t\t\trw_exit(&dn->dn_struct_rwlock);\n\t\t\tdnode_rele(dn, FTAG);\n\t\t\trange = get_next_range(inq, range);\n\t\t}\n\t\t}\n\t}\n\tif (srta->cancel || err != 0) {\n\t\tsmta->cancel = B_TRUE;\n\t\tsrta->error = err;\n\t} else if (smta->error != 0) {\n\t\tsrta->error = smta->error;\n\t}\n\twhile (!range->eos_marker)\n\t\trange = get_next_range(inq, range);\n\n\tbqueue_enqueue_flush(outq, range, 1);\n\tspl_fstrans_unmark(cookie);\n\tthread_exit();\n}\n\n#define\tNUM_SNAPS_NOT_REDACTED UINT64_MAX\n\nstruct dmu_send_params {\n\t \n\tconst void *tag;  \n\tdsl_pool_t *dp;\n\t \n\tconst char *tosnap;\n\tdsl_dataset_t *to_ds;\n\t \n\tzfs_bookmark_phys_t ancestor_zb;\n\tuint64_t *fromredactsnaps;\n\t \n\tuint64_t numfromredactsnaps;\n\t \n\tboolean_t is_clone;\n\tboolean_t embedok;\n\tboolean_t large_block_ok;\n\tboolean_t compressok;\n\tboolean_t rawok;\n\tboolean_t savedok;\n\tuint64_t resumeobj;\n\tuint64_t resumeoff;\n\tuint64_t saved_guid;\n\tzfs_bookmark_phys_t *redactbook;\n\t \n\tdmu_send_outparams_t *dso;\n\n\t \n\toffset_t *off;\n\tint outfd;\n\tchar saved_toname[MAXNAMELEN];\n};\n\nstatic int\nsetup_featureflags(struct dmu_send_params *dspp, objset_t *os,\n    uint64_t *featureflags)\n{\n\tdsl_dataset_t *to_ds = dspp->to_ds;\n\tdsl_pool_t *dp = dspp->dp;\n\n\tif (dmu_objset_type(os) == DMU_OST_ZFS) {\n\t\tuint64_t version;\n\t\tif (zfs_get_zplprop(os, ZFS_PROP_VERSION, &version) != 0)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif (version >= ZPL_VERSION_SA)\n\t\t\t*featureflags |= DMU_BACKUP_FEATURE_SA_SPILL;\n\t}\n\n\t \n\tif ((dspp->rawok || dspp->large_block_ok) &&\n\t    dsl_dataset_feature_is_active(to_ds, SPA_FEATURE_LARGE_BLOCKS)) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_LARGE_BLOCKS;\n\t}\n\n\t \n\tif ((dspp->embedok || dspp->rawok) && !os->os_encrypted &&\n\t    spa_feature_is_active(dp->dp_spa, SPA_FEATURE_EMBEDDED_DATA)) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_EMBED_DATA;\n\t}\n\n\t \n\tif (dspp->compressok || dspp->rawok)\n\t\t*featureflags |= DMU_BACKUP_FEATURE_COMPRESSED;\n\n\tif (dspp->rawok && os->os_encrypted)\n\t\t*featureflags |= DMU_BACKUP_FEATURE_RAW;\n\n\tif ((*featureflags &\n\t    (DMU_BACKUP_FEATURE_EMBED_DATA | DMU_BACKUP_FEATURE_COMPRESSED |\n\t    DMU_BACKUP_FEATURE_RAW)) != 0 &&\n\t    spa_feature_is_active(dp->dp_spa, SPA_FEATURE_LZ4_COMPRESS)) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_LZ4;\n\t}\n\n\t \n\tif ((*featureflags &\n\t    (DMU_BACKUP_FEATURE_COMPRESSED | DMU_BACKUP_FEATURE_RAW)) != 0 &&\n\t    dsl_dataset_feature_is_active(to_ds, SPA_FEATURE_ZSTD_COMPRESS)) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_ZSTD;\n\t}\n\n\tif (dspp->resumeobj != 0 || dspp->resumeoff != 0) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_RESUMING;\n\t}\n\n\tif (dspp->redactbook != NULL) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_REDACTED;\n\t}\n\n\tif (dsl_dataset_feature_is_active(to_ds, SPA_FEATURE_LARGE_DNODE)) {\n\t\t*featureflags |= DMU_BACKUP_FEATURE_LARGE_DNODE;\n\t}\n\treturn (0);\n}\n\nstatic dmu_replay_record_t *\ncreate_begin_record(struct dmu_send_params *dspp, objset_t *os,\n    uint64_t featureflags)\n{\n\tdmu_replay_record_t *drr = kmem_zalloc(sizeof (dmu_replay_record_t),\n\t    KM_SLEEP);\n\tdrr->drr_type = DRR_BEGIN;\n\n\tstruct drr_begin *drrb = &drr->drr_u.drr_begin;\n\tdsl_dataset_t *to_ds = dspp->to_ds;\n\n\tdrrb->drr_magic = DMU_BACKUP_MAGIC;\n\tdrrb->drr_creation_time = dsl_dataset_phys(to_ds)->ds_creation_time;\n\tdrrb->drr_type = dmu_objset_type(os);\n\tdrrb->drr_toguid = dsl_dataset_phys(to_ds)->ds_guid;\n\tdrrb->drr_fromguid = dspp->ancestor_zb.zbm_guid;\n\n\tDMU_SET_STREAM_HDRTYPE(drrb->drr_versioninfo, DMU_SUBSTREAM);\n\tDMU_SET_FEATUREFLAGS(drrb->drr_versioninfo, featureflags);\n\n\tif (dspp->is_clone)\n\t\tdrrb->drr_flags |= DRR_FLAG_CLONE;\n\tif (dsl_dataset_phys(dspp->to_ds)->ds_flags & DS_FLAG_CI_DATASET)\n\t\tdrrb->drr_flags |= DRR_FLAG_CI_DATA;\n\tif (zfs_send_set_freerecords_bit)\n\t\tdrrb->drr_flags |= DRR_FLAG_FREERECORDS;\n\tdrr->drr_u.drr_begin.drr_flags |= DRR_FLAG_SPILL_BLOCK;\n\n\tif (dspp->savedok) {\n\t\tdrrb->drr_toguid = dspp->saved_guid;\n\t\tstrlcpy(drrb->drr_toname, dspp->saved_toname,\n\t\t    sizeof (drrb->drr_toname));\n\t} else {\n\t\tdsl_dataset_name(to_ds, drrb->drr_toname);\n\t\tif (!to_ds->ds_is_snapshot) {\n\t\t\t(void) strlcat(drrb->drr_toname, \"@--head--\",\n\t\t\t    sizeof (drrb->drr_toname));\n\t\t}\n\t}\n\treturn (drr);\n}\n\nstatic void\nsetup_to_thread(struct send_thread_arg *to_arg, objset_t *to_os,\n    dmu_sendstatus_t *dssp, uint64_t fromtxg, boolean_t rawok)\n{\n\tVERIFY0(bqueue_init(&to_arg->q, zfs_send_no_prefetch_queue_ff,\n\t    MAX(zfs_send_no_prefetch_queue_length, 2 * zfs_max_recordsize),\n\t    offsetof(struct send_range, ln)));\n\tto_arg->error_code = 0;\n\tto_arg->cancel = B_FALSE;\n\tto_arg->os = to_os;\n\tto_arg->fromtxg = fromtxg;\n\tto_arg->flags = TRAVERSE_PRE | TRAVERSE_PREFETCH_METADATA;\n\tif (rawok)\n\t\tto_arg->flags |= TRAVERSE_NO_DECRYPT;\n\tif (zfs_send_corrupt_data)\n\t\tto_arg->flags |= TRAVERSE_HARD;\n\tto_arg->num_blocks_visited = &dssp->dss_blocks;\n\t(void) thread_create(NULL, 0, send_traverse_thread, to_arg, 0,\n\t    curproc, TS_RUN, minclsyspri);\n}\n\nstatic void\nsetup_from_thread(struct redact_list_thread_arg *from_arg,\n    redaction_list_t *from_rl, dmu_sendstatus_t *dssp)\n{\n\tVERIFY0(bqueue_init(&from_arg->q, zfs_send_no_prefetch_queue_ff,\n\t    MAX(zfs_send_no_prefetch_queue_length, 2 * zfs_max_recordsize),\n\t    offsetof(struct send_range, ln)));\n\tfrom_arg->error_code = 0;\n\tfrom_arg->cancel = B_FALSE;\n\tfrom_arg->rl = from_rl;\n\tfrom_arg->mark_redact = B_FALSE;\n\tfrom_arg->num_blocks_visited = &dssp->dss_blocks;\n\t \n\t(void) thread_create(NULL, 0, redact_list_thread, from_arg, 0,\n\t    curproc, TS_RUN, minclsyspri);\n}\n\nstatic void\nsetup_redact_list_thread(struct redact_list_thread_arg *rlt_arg,\n    struct dmu_send_params *dspp, redaction_list_t *rl, dmu_sendstatus_t *dssp)\n{\n\tif (dspp->redactbook == NULL)\n\t\treturn;\n\n\trlt_arg->cancel = B_FALSE;\n\tVERIFY0(bqueue_init(&rlt_arg->q, zfs_send_no_prefetch_queue_ff,\n\t    MAX(zfs_send_no_prefetch_queue_length, 2 * zfs_max_recordsize),\n\t    offsetof(struct send_range, ln)));\n\trlt_arg->error_code = 0;\n\trlt_arg->mark_redact = B_TRUE;\n\trlt_arg->rl = rl;\n\trlt_arg->num_blocks_visited = &dssp->dss_blocks;\n\n\t(void) thread_create(NULL, 0, redact_list_thread, rlt_arg, 0,\n\t    curproc, TS_RUN, minclsyspri);\n}\n\nstatic void\nsetup_merge_thread(struct send_merge_thread_arg *smt_arg,\n    struct dmu_send_params *dspp, struct redact_list_thread_arg *from_arg,\n    struct send_thread_arg *to_arg, struct redact_list_thread_arg *rlt_arg,\n    objset_t *os)\n{\n\tVERIFY0(bqueue_init(&smt_arg->q, zfs_send_no_prefetch_queue_ff,\n\t    MAX(zfs_send_no_prefetch_queue_length, 2 * zfs_max_recordsize),\n\t    offsetof(struct send_range, ln)));\n\tsmt_arg->cancel = B_FALSE;\n\tsmt_arg->error = 0;\n\tsmt_arg->from_arg = from_arg;\n\tsmt_arg->to_arg = to_arg;\n\tif (dspp->redactbook != NULL)\n\t\tsmt_arg->redact_arg = rlt_arg;\n\n\tsmt_arg->os = os;\n\t(void) thread_create(NULL, 0, send_merge_thread, smt_arg, 0, curproc,\n\t    TS_RUN, minclsyspri);\n}\n\nstatic void\nsetup_reader_thread(struct send_reader_thread_arg *srt_arg,\n    struct dmu_send_params *dspp, struct send_merge_thread_arg *smt_arg,\n    uint64_t featureflags)\n{\n\tVERIFY0(bqueue_init(&srt_arg->q, zfs_send_queue_ff,\n\t    MAX(zfs_send_queue_length, 2 * zfs_max_recordsize),\n\t    offsetof(struct send_range, ln)));\n\tsrt_arg->smta = smt_arg;\n\tsrt_arg->issue_reads = !dspp->dso->dso_dryrun;\n\tsrt_arg->featureflags = featureflags;\n\t(void) thread_create(NULL, 0, send_reader_thread, srt_arg, 0,\n\t    curproc, TS_RUN, minclsyspri);\n}\n\nstatic int\nsetup_resume_points(struct dmu_send_params *dspp,\n    struct send_thread_arg *to_arg, struct redact_list_thread_arg *from_arg,\n    struct redact_list_thread_arg *rlt_arg,\n    struct send_merge_thread_arg *smt_arg, boolean_t resuming, objset_t *os,\n    redaction_list_t *redact_rl, nvlist_t *nvl)\n{\n\t(void) smt_arg;\n\tdsl_dataset_t *to_ds = dspp->to_ds;\n\tint err = 0;\n\n\tuint64_t obj = 0;\n\tuint64_t blkid = 0;\n\tif (resuming) {\n\t\tobj = dspp->resumeobj;\n\t\tdmu_object_info_t to_doi;\n\t\terr = dmu_object_info(os, obj, &to_doi);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\tblkid = dspp->resumeoff / to_doi.doi_data_block_size;\n\t}\n\t \n\tif (redact_rl != NULL) {\n\t\tSET_BOOKMARK(&rlt_arg->resume, to_ds->ds_object, obj, 0, blkid);\n\t}\n\n\tSET_BOOKMARK(&to_arg->resume, to_ds->ds_object, obj, 0, blkid);\n\tif (nvlist_exists(nvl, BEGINNV_REDACT_FROM_SNAPS)) {\n\t\tuint64_t objset = dspp->ancestor_zb.zbm_redaction_obj;\n\t\t \n\t\tSET_BOOKMARK(&from_arg->resume, objset, obj, 0, blkid);\n\t}\n\tif (resuming) {\n\t\tfnvlist_add_uint64(nvl, BEGINNV_RESUME_OBJECT, dspp->resumeobj);\n\t\tfnvlist_add_uint64(nvl, BEGINNV_RESUME_OFFSET, dspp->resumeoff);\n\t}\n\treturn (0);\n}\n\nstatic dmu_sendstatus_t *\nsetup_send_progress(struct dmu_send_params *dspp)\n{\n\tdmu_sendstatus_t *dssp = kmem_zalloc(sizeof (*dssp), KM_SLEEP);\n\tdssp->dss_outfd = dspp->outfd;\n\tdssp->dss_off = dspp->off;\n\tdssp->dss_proc = curproc;\n\tmutex_enter(&dspp->to_ds->ds_sendstream_lock);\n\tlist_insert_head(&dspp->to_ds->ds_sendstreams, dssp);\n\tmutex_exit(&dspp->to_ds->ds_sendstream_lock);\n\treturn (dssp);\n}\n\n \nstatic int\ndmu_send_impl(struct dmu_send_params *dspp)\n{\n\tobjset_t *os;\n\tdmu_replay_record_t *drr;\n\tdmu_sendstatus_t *dssp;\n\tdmu_send_cookie_t dsc = {0};\n\tint err;\n\tuint64_t fromtxg = dspp->ancestor_zb.zbm_creation_txg;\n\tuint64_t featureflags = 0;\n\tstruct redact_list_thread_arg *from_arg;\n\tstruct send_thread_arg *to_arg;\n\tstruct redact_list_thread_arg *rlt_arg;\n\tstruct send_merge_thread_arg *smt_arg;\n\tstruct send_reader_thread_arg *srt_arg;\n\tstruct send_range *range;\n\tredaction_list_t *from_rl = NULL;\n\tredaction_list_t *redact_rl = NULL;\n\tboolean_t resuming = (dspp->resumeobj != 0 || dspp->resumeoff != 0);\n\tboolean_t book_resuming = resuming;\n\n\tdsl_dataset_t *to_ds = dspp->to_ds;\n\tzfs_bookmark_phys_t *ancestor_zb = &dspp->ancestor_zb;\n\tdsl_pool_t *dp = dspp->dp;\n\tconst void *tag = dspp->tag;\n\n\terr = dmu_objset_from_ds(to_ds, &os);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dp, tag);\n\t\treturn (err);\n\t}\n\n\t \n\tif (!dspp->rawok && os->os_encrypted &&\n\t    arc_is_unauthenticated(os->os_phys_buf)) {\n\t\tzbookmark_phys_t zb;\n\n\t\tSET_BOOKMARK(&zb, to_ds->ds_object, ZB_ROOT_OBJECT,\n\t\t    ZB_ROOT_LEVEL, ZB_ROOT_BLKID);\n\t\terr = arc_untransform(os->os_phys_buf, os->os_spa,\n\t\t    &zb, B_FALSE);\n\t\tif (err != 0) {\n\t\t\tdsl_pool_rele(dp, tag);\n\t\t\treturn (err);\n\t\t}\n\n\t\tASSERT0(arc_is_unauthenticated(os->os_phys_buf));\n\t}\n\n\tif ((err = setup_featureflags(dspp, os, &featureflags)) != 0) {\n\t\tdsl_pool_rele(dp, tag);\n\t\treturn (err);\n\t}\n\n\t \n\tif (dspp->redactbook != NULL) {\n\t\terr = dsl_redaction_list_hold_obj(dp,\n\t\t    dspp->redactbook->zbm_redaction_obj, FTAG,\n\t\t    &redact_rl);\n\t\tif (err != 0) {\n\t\t\tdsl_pool_rele(dp, tag);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t\tdsl_redaction_list_long_hold(dp, redact_rl, FTAG);\n\t}\n\n\t \n\tif (ancestor_zb->zbm_redaction_obj != 0) {\n\t\terr = dsl_redaction_list_hold_obj(dp,\n\t\t    ancestor_zb->zbm_redaction_obj, FTAG, &from_rl);\n\t\tif (err != 0) {\n\t\t\tif (redact_rl != NULL) {\n\t\t\t\tdsl_redaction_list_long_rele(redact_rl, FTAG);\n\t\t\t\tdsl_redaction_list_rele(redact_rl, FTAG);\n\t\t\t}\n\t\t\tdsl_pool_rele(dp, tag);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\t\tdsl_redaction_list_long_hold(dp, from_rl, FTAG);\n\t}\n\n\tdsl_dataset_long_hold(to_ds, FTAG);\n\n\tfrom_arg = kmem_zalloc(sizeof (*from_arg), KM_SLEEP);\n\tto_arg = kmem_zalloc(sizeof (*to_arg), KM_SLEEP);\n\trlt_arg = kmem_zalloc(sizeof (*rlt_arg), KM_SLEEP);\n\tsmt_arg = kmem_zalloc(sizeof (*smt_arg), KM_SLEEP);\n\tsrt_arg = kmem_zalloc(sizeof (*srt_arg), KM_SLEEP);\n\n\tdrr = create_begin_record(dspp, os, featureflags);\n\tdssp = setup_send_progress(dspp);\n\n\tdsc.dsc_drr = drr;\n\tdsc.dsc_dso = dspp->dso;\n\tdsc.dsc_os = os;\n\tdsc.dsc_off = dspp->off;\n\tdsc.dsc_toguid = dsl_dataset_phys(to_ds)->ds_guid;\n\tdsc.dsc_fromtxg = fromtxg;\n\tdsc.dsc_pending_op = PENDING_NONE;\n\tdsc.dsc_featureflags = featureflags;\n\tdsc.dsc_resume_object = dspp->resumeobj;\n\tdsc.dsc_resume_offset = dspp->resumeoff;\n\n\tdsl_pool_rele(dp, tag);\n\n\tvoid *payload = NULL;\n\tsize_t payload_len = 0;\n\tnvlist_t *nvl = fnvlist_alloc();\n\n\t \n\tif (dspp->redactbook != NULL) {\n\t\tfnvlist_add_uint64_array(nvl, BEGINNV_REDACT_SNAPS,\n\t\t    redact_rl->rl_phys->rlp_snaps,\n\t\t    redact_rl->rl_phys->rlp_num_snaps);\n\t} else if (dsl_dataset_feature_is_active(to_ds,\n\t    SPA_FEATURE_REDACTED_DATASETS)) {\n\t\tuint64_t *tods_guids;\n\t\tuint64_t length;\n\t\tVERIFY(dsl_dataset_get_uint64_array_feature(to_ds,\n\t\t    SPA_FEATURE_REDACTED_DATASETS, &length, &tods_guids));\n\t\tfnvlist_add_uint64_array(nvl, BEGINNV_REDACT_SNAPS, tods_guids,\n\t\t    length);\n\t}\n\n\t \n\tif (from_rl != NULL) {\n\t\tfnvlist_add_uint64_array(nvl, BEGINNV_REDACT_FROM_SNAPS,\n\t\t    from_rl->rl_phys->rlp_snaps,\n\t\t    from_rl->rl_phys->rlp_num_snaps);\n\t}\n\n\t \n\tif (dspp->numfromredactsnaps != NUM_SNAPS_NOT_REDACTED) {\n\t\tASSERT3P(from_rl, ==, NULL);\n\t\tfnvlist_add_uint64_array(nvl, BEGINNV_REDACT_FROM_SNAPS,\n\t\t    dspp->fromredactsnaps, (uint_t)dspp->numfromredactsnaps);\n\t\tif (dspp->numfromredactsnaps > 0) {\n\t\t\tkmem_free(dspp->fromredactsnaps,\n\t\t\t    dspp->numfromredactsnaps * sizeof (uint64_t));\n\t\t\tdspp->fromredactsnaps = NULL;\n\t\t}\n\t}\n\n\tif (resuming || book_resuming) {\n\t\terr = setup_resume_points(dspp, to_arg, from_arg,\n\t\t    rlt_arg, smt_arg, resuming, os, redact_rl, nvl);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t}\n\n\tif (featureflags & DMU_BACKUP_FEATURE_RAW) {\n\t\tuint64_t ivset_guid = ancestor_zb->zbm_ivset_guid;\n\t\tnvlist_t *keynvl = NULL;\n\t\tASSERT(os->os_encrypted);\n\n\t\terr = dsl_crypto_populate_key_nvlist(os, ivset_guid,\n\t\t    &keynvl);\n\t\tif (err != 0) {\n\t\t\tfnvlist_free(nvl);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfnvlist_add_nvlist(nvl, \"crypt_keydata\", keynvl);\n\t\tfnvlist_free(keynvl);\n\t}\n\n\tif (!nvlist_empty(nvl)) {\n\t\tpayload = fnvlist_pack(nvl, &payload_len);\n\t\tdrr->drr_payloadlen = payload_len;\n\t}\n\n\tfnvlist_free(nvl);\n\terr = dump_record(&dsc, payload, payload_len);\n\tfnvlist_pack_free(payload, payload_len);\n\tif (err != 0) {\n\t\terr = dsc.dsc_err;\n\t\tgoto out;\n\t}\n\n\tsetup_to_thread(to_arg, os, dssp, fromtxg, dspp->rawok);\n\tsetup_from_thread(from_arg, from_rl, dssp);\n\tsetup_redact_list_thread(rlt_arg, dspp, redact_rl, dssp);\n\tsetup_merge_thread(smt_arg, dspp, from_arg, to_arg, rlt_arg, os);\n\tsetup_reader_thread(srt_arg, dspp, smt_arg, featureflags);\n\n\trange = bqueue_dequeue(&srt_arg->q);\n\twhile (err == 0 && !range->eos_marker) {\n\t\terr = do_dump(&dsc, range);\n\t\trange = get_next_range(&srt_arg->q, range);\n\t\tif (issig(JUSTLOOKING) && issig(FORREAL))\n\t\t\terr = SET_ERROR(EINTR);\n\t}\n\n\t \n\tif (err != 0) {\n\t\tsrt_arg->cancel = B_TRUE;\n\t\twhile (!range->eos_marker) {\n\t\t\trange = get_next_range(&srt_arg->q, range);\n\t\t}\n\t}\n\trange_free(range);\n\n\tbqueue_destroy(&srt_arg->q);\n\tbqueue_destroy(&smt_arg->q);\n\tif (dspp->redactbook != NULL)\n\t\tbqueue_destroy(&rlt_arg->q);\n\tbqueue_destroy(&to_arg->q);\n\tbqueue_destroy(&from_arg->q);\n\n\tif (err == 0 && srt_arg->error != 0)\n\t\terr = srt_arg->error;\n\n\tif (err != 0)\n\t\tgoto out;\n\n\tif (dsc.dsc_pending_op != PENDING_NONE)\n\t\tif (dump_record(&dsc, NULL, 0) != 0)\n\t\t\terr = SET_ERROR(EINTR);\n\n\tif (err != 0) {\n\t\tif (err == EINTR && dsc.dsc_err != 0)\n\t\t\terr = dsc.dsc_err;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!dspp->savedok) {\n\t\tmemset(drr, 0, sizeof (dmu_replay_record_t));\n\t\tdrr->drr_type = DRR_END;\n\t\tdrr->drr_u.drr_end.drr_checksum = dsc.dsc_zc;\n\t\tdrr->drr_u.drr_end.drr_toguid = dsc.dsc_toguid;\n\n\t\tif (dump_record(&dsc, NULL, 0) != 0)\n\t\t\terr = dsc.dsc_err;\n\t}\nout:\n\tmutex_enter(&to_ds->ds_sendstream_lock);\n\tlist_remove(&to_ds->ds_sendstreams, dssp);\n\tmutex_exit(&to_ds->ds_sendstream_lock);\n\n\tVERIFY(err != 0 || (dsc.dsc_sent_begin &&\n\t    (dsc.dsc_sent_end || dspp->savedok)));\n\n\tkmem_free(drr, sizeof (dmu_replay_record_t));\n\tkmem_free(dssp, sizeof (dmu_sendstatus_t));\n\tkmem_free(from_arg, sizeof (*from_arg));\n\tkmem_free(to_arg, sizeof (*to_arg));\n\tkmem_free(rlt_arg, sizeof (*rlt_arg));\n\tkmem_free(smt_arg, sizeof (*smt_arg));\n\tkmem_free(srt_arg, sizeof (*srt_arg));\n\n\tdsl_dataset_long_rele(to_ds, FTAG);\n\tif (from_rl != NULL) {\n\t\tdsl_redaction_list_long_rele(from_rl, FTAG);\n\t\tdsl_redaction_list_rele(from_rl, FTAG);\n\t}\n\tif (redact_rl != NULL) {\n\t\tdsl_redaction_list_long_rele(redact_rl, FTAG);\n\t\tdsl_redaction_list_rele(redact_rl, FTAG);\n\t}\n\n\treturn (err);\n}\n\nint\ndmu_send_obj(const char *pool, uint64_t tosnap, uint64_t fromsnap,\n    boolean_t embedok, boolean_t large_block_ok, boolean_t compressok,\n    boolean_t rawok, boolean_t savedok, int outfd, offset_t *off,\n    dmu_send_outparams_t *dsop)\n{\n\tint err;\n\tdsl_dataset_t *fromds;\n\tds_hold_flags_t dsflags;\n\tstruct dmu_send_params dspp = {0};\n\tdspp.embedok = embedok;\n\tdspp.large_block_ok = large_block_ok;\n\tdspp.compressok = compressok;\n\tdspp.outfd = outfd;\n\tdspp.off = off;\n\tdspp.dso = dsop;\n\tdspp.tag = FTAG;\n\tdspp.rawok = rawok;\n\tdspp.savedok = savedok;\n\n\tdsflags = (rawok) ? DS_HOLD_FLAG_NONE : DS_HOLD_FLAG_DECRYPT;\n\terr = dsl_pool_hold(pool, FTAG, &dspp.dp);\n\tif (err != 0)\n\t\treturn (err);\n\n\terr = dsl_dataset_hold_obj_flags(dspp.dp, tosnap, dsflags, FTAG,\n\t    &dspp.to_ds);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dspp.dp, FTAG);\n\t\treturn (err);\n\t}\n\n\tif (fromsnap != 0) {\n\t\terr = dsl_dataset_hold_obj_flags(dspp.dp, fromsnap, dsflags,\n\t\t    FTAG, &fromds);\n\t\tif (err != 0) {\n\t\t\tdsl_dataset_rele_flags(dspp.to_ds, dsflags, FTAG);\n\t\t\tdsl_pool_rele(dspp.dp, FTAG);\n\t\t\treturn (err);\n\t\t}\n\t\tdspp.ancestor_zb.zbm_guid = dsl_dataset_phys(fromds)->ds_guid;\n\t\tdspp.ancestor_zb.zbm_creation_txg =\n\t\t    dsl_dataset_phys(fromds)->ds_creation_txg;\n\t\tdspp.ancestor_zb.zbm_creation_time =\n\t\t    dsl_dataset_phys(fromds)->ds_creation_time;\n\n\t\tif (dsl_dataset_is_zapified(fromds)) {\n\t\t\t(void) zap_lookup(dspp.dp->dp_meta_objset,\n\t\t\t    fromds->ds_object, DS_FIELD_IVSET_GUID, 8, 1,\n\t\t\t    &dspp.ancestor_zb.zbm_ivset_guid);\n\t\t}\n\n\t\t \n\t\tuint64_t *fromredact;\n\n\t\tif (!dsl_dataset_get_uint64_array_feature(fromds,\n\t\t    SPA_FEATURE_REDACTED_DATASETS,\n\t\t    &dspp.numfromredactsnaps,\n\t\t    &fromredact)) {\n\t\t\tdspp.numfromredactsnaps = NUM_SNAPS_NOT_REDACTED;\n\t\t} else if (dspp.numfromredactsnaps > 0) {\n\t\t\tuint64_t size = dspp.numfromredactsnaps *\n\t\t\t    sizeof (uint64_t);\n\t\t\tdspp.fromredactsnaps = kmem_zalloc(size, KM_SLEEP);\n\t\t\tmemcpy(dspp.fromredactsnaps, fromredact, size);\n\t\t}\n\n\t\tboolean_t is_before =\n\t\t    dsl_dataset_is_before(dspp.to_ds, fromds, 0);\n\t\tdspp.is_clone = (dspp.to_ds->ds_dir !=\n\t\t    fromds->ds_dir);\n\t\tdsl_dataset_rele(fromds, FTAG);\n\t\tif (!is_before) {\n\t\t\tdsl_pool_rele(dspp.dp, FTAG);\n\t\t\terr = SET_ERROR(EXDEV);\n\t\t} else {\n\t\t\terr = dmu_send_impl(&dspp);\n\t\t}\n\t} else {\n\t\tdspp.numfromredactsnaps = NUM_SNAPS_NOT_REDACTED;\n\t\terr = dmu_send_impl(&dspp);\n\t}\n\tif (dspp.fromredactsnaps)\n\t\tkmem_free(dspp.fromredactsnaps,\n\t\t    dspp.numfromredactsnaps * sizeof (uint64_t));\n\n\tdsl_dataset_rele(dspp.to_ds, FTAG);\n\treturn (err);\n}\n\nint\ndmu_send(const char *tosnap, const char *fromsnap, boolean_t embedok,\n    boolean_t large_block_ok, boolean_t compressok, boolean_t rawok,\n    boolean_t savedok, uint64_t resumeobj, uint64_t resumeoff,\n    const char *redactbook, int outfd, offset_t *off,\n    dmu_send_outparams_t *dsop)\n{\n\tint err = 0;\n\tds_hold_flags_t dsflags;\n\tboolean_t owned = B_FALSE;\n\tdsl_dataset_t *fromds = NULL;\n\tzfs_bookmark_phys_t book = {0};\n\tstruct dmu_send_params dspp = {0};\n\n\tdsflags = (rawok) ? DS_HOLD_FLAG_NONE : DS_HOLD_FLAG_DECRYPT;\n\tdspp.tosnap = tosnap;\n\tdspp.embedok = embedok;\n\tdspp.large_block_ok = large_block_ok;\n\tdspp.compressok = compressok;\n\tdspp.outfd = outfd;\n\tdspp.off = off;\n\tdspp.dso = dsop;\n\tdspp.tag = FTAG;\n\tdspp.resumeobj = resumeobj;\n\tdspp.resumeoff = resumeoff;\n\tdspp.rawok = rawok;\n\tdspp.savedok = savedok;\n\n\tif (fromsnap != NULL && strpbrk(fromsnap, \"@#\") == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terr = dsl_pool_hold(tosnap, FTAG, &dspp.dp);\n\tif (err != 0)\n\t\treturn (err);\n\n\tif (strchr(tosnap, '@') == NULL && spa_writeable(dspp.dp->dp_spa)) {\n\t\t \n\n\t\tif (savedok) {\n\t\t\t \n\t\t\tchar *name = kmem_asprintf(\"%s/%s\", tosnap,\n\t\t\t    recv_clone_name);\n\t\t\terr = dsl_dataset_own_force(dspp.dp, name, dsflags,\n\t\t\t    FTAG, &dspp.to_ds);\n\t\t\tif (err == ENOENT) {\n\t\t\t\terr = dsl_dataset_own_force(dspp.dp, tosnap,\n\t\t\t\t    dsflags, FTAG, &dspp.to_ds);\n\t\t\t}\n\n\t\t\tif (err == 0) {\n\t\t\t\towned = B_TRUE;\n\t\t\t\terr = zap_lookup(dspp.dp->dp_meta_objset,\n\t\t\t\t    dspp.to_ds->ds_object,\n\t\t\t\t    DS_FIELD_RESUME_TOGUID, 8, 1,\n\t\t\t\t    &dspp.saved_guid);\n\t\t\t}\n\n\t\t\tif (err == 0) {\n\t\t\t\terr = zap_lookup(dspp.dp->dp_meta_objset,\n\t\t\t\t    dspp.to_ds->ds_object,\n\t\t\t\t    DS_FIELD_RESUME_TONAME, 1,\n\t\t\t\t    sizeof (dspp.saved_toname),\n\t\t\t\t    dspp.saved_toname);\n\t\t\t}\n\t\t\t \n\t\t\tif (owned && (err != 0))\n\t\t\t\tdsl_dataset_disown(dspp.to_ds, dsflags, FTAG);\n\n\t\t\tkmem_strfree(name);\n\t\t} else {\n\t\t\terr = dsl_dataset_own(dspp.dp, tosnap, dsflags,\n\t\t\t    FTAG, &dspp.to_ds);\n\t\t\tif (err == 0)\n\t\t\t\towned = B_TRUE;\n\t\t}\n\t} else {\n\t\terr = dsl_dataset_hold_flags(dspp.dp, tosnap, dsflags, FTAG,\n\t\t    &dspp.to_ds);\n\t}\n\n\tif (err != 0) {\n\t\t \n\t\tdsl_pool_rele(dspp.dp, FTAG);\n\t\treturn (err);\n\t}\n\n\tif (redactbook != NULL) {\n\t\tchar path[ZFS_MAX_DATASET_NAME_LEN];\n\t\t(void) strlcpy(path, tosnap, sizeof (path));\n\t\tchar *at = strchr(path, '@');\n\t\tif (at == NULL) {\n\t\t\terr = EINVAL;\n\t\t} else {\n\t\t\t(void) snprintf(at, sizeof (path) - (at - path), \"#%s\",\n\t\t\t    redactbook);\n\t\t\terr = dsl_bookmark_lookup(dspp.dp, path,\n\t\t\t    NULL, &book);\n\t\t\tdspp.redactbook = &book;\n\t\t}\n\t}\n\n\tif (err != 0) {\n\t\tdsl_pool_rele(dspp.dp, FTAG);\n\t\tif (owned)\n\t\t\tdsl_dataset_disown(dspp.to_ds, dsflags, FTAG);\n\t\telse\n\t\t\tdsl_dataset_rele_flags(dspp.to_ds, dsflags, FTAG);\n\t\treturn (err);\n\t}\n\n\tif (fromsnap != NULL) {\n\t\tzfs_bookmark_phys_t *zb = &dspp.ancestor_zb;\n\t\tint fsnamelen;\n\t\tif (strpbrk(tosnap, \"@#\") != NULL)\n\t\t\tfsnamelen = strpbrk(tosnap, \"@#\") - tosnap;\n\t\telse\n\t\t\tfsnamelen = strlen(tosnap);\n\n\t\t \n\t\tif (strncmp(tosnap, fromsnap, fsnamelen) != 0 ||\n\t\t    (fromsnap[fsnamelen] != '@' &&\n\t\t    fromsnap[fsnamelen] != '#')) {\n\t\t\tdspp.is_clone = B_TRUE;\n\t\t}\n\n\t\tif (strchr(fromsnap, '@') != NULL) {\n\t\t\terr = dsl_dataset_hold(dspp.dp, fromsnap, FTAG,\n\t\t\t    &fromds);\n\n\t\t\tif (err != 0) {\n\t\t\t\tASSERT3P(fromds, ==, NULL);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuint64_t *fromredact;\n\t\t\t\tif (!dsl_dataset_get_uint64_array_feature(\n\t\t\t\t    fromds, SPA_FEATURE_REDACTED_DATASETS,\n\t\t\t\t    &dspp.numfromredactsnaps,\n\t\t\t\t    &fromredact)) {\n\t\t\t\t\tdspp.numfromredactsnaps =\n\t\t\t\t\t    NUM_SNAPS_NOT_REDACTED;\n\t\t\t\t} else if (dspp.numfromredactsnaps > 0) {\n\t\t\t\t\tuint64_t size =\n\t\t\t\t\t    dspp.numfromredactsnaps *\n\t\t\t\t\t    sizeof (uint64_t);\n\t\t\t\t\tdspp.fromredactsnaps = kmem_zalloc(size,\n\t\t\t\t\t    KM_SLEEP);\n\t\t\t\t\tmemcpy(dspp.fromredactsnaps, fromredact,\n\t\t\t\t\t    size);\n\t\t\t\t}\n\t\t\t\tif (!dsl_dataset_is_before(dspp.to_ds, fromds,\n\t\t\t\t    0)) {\n\t\t\t\t\terr = SET_ERROR(EXDEV);\n\t\t\t\t} else {\n\t\t\t\t\tzb->zbm_creation_txg =\n\t\t\t\t\t    dsl_dataset_phys(fromds)->\n\t\t\t\t\t    ds_creation_txg;\n\t\t\t\t\tzb->zbm_creation_time =\n\t\t\t\t\t    dsl_dataset_phys(fromds)->\n\t\t\t\t\t    ds_creation_time;\n\t\t\t\t\tzb->zbm_guid =\n\t\t\t\t\t    dsl_dataset_phys(fromds)->ds_guid;\n\t\t\t\t\tzb->zbm_redaction_obj = 0;\n\n\t\t\t\t\tif (dsl_dataset_is_zapified(fromds)) {\n\t\t\t\t\t\t(void) zap_lookup(\n\t\t\t\t\t\t    dspp.dp->dp_meta_objset,\n\t\t\t\t\t\t    fromds->ds_object,\n\t\t\t\t\t\t    DS_FIELD_IVSET_GUID, 8, 1,\n\t\t\t\t\t\t    &zb->zbm_ivset_guid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdsl_dataset_rele(fromds, FTAG);\n\t\t\t}\n\t\t} else {\n\t\t\tdspp.numfromredactsnaps = NUM_SNAPS_NOT_REDACTED;\n\t\t\terr = dsl_bookmark_lookup(dspp.dp, fromsnap, dspp.to_ds,\n\t\t\t    zb);\n\t\t\tif (err == EXDEV && zb->zbm_redaction_obj != 0 &&\n\t\t\t    zb->zbm_guid ==\n\t\t\t    dsl_dataset_phys(dspp.to_ds)->ds_guid)\n\t\t\t\terr = 0;\n\t\t}\n\n\t\tif (err == 0) {\n\t\t\t \n\t\t\terr = dmu_send_impl(&dspp);\n\t\t} else {\n\t\t\tif (dspp.fromredactsnaps)\n\t\t\t\tkmem_free(dspp.fromredactsnaps,\n\t\t\t\t    dspp.numfromredactsnaps *\n\t\t\t\t    sizeof (uint64_t));\n\t\t\tdsl_pool_rele(dspp.dp, FTAG);\n\t\t}\n\t} else {\n\t\tdspp.numfromredactsnaps = NUM_SNAPS_NOT_REDACTED;\n\t\terr = dmu_send_impl(&dspp);\n\t}\n\tif (owned)\n\t\tdsl_dataset_disown(dspp.to_ds, dsflags, FTAG);\n\telse\n\t\tdsl_dataset_rele_flags(dspp.to_ds, dsflags, FTAG);\n\treturn (err);\n}\n\nstatic int\ndmu_adjust_send_estimate_for_indirects(dsl_dataset_t *ds, uint64_t uncompressed,\n    uint64_t compressed, boolean_t stream_compressed, uint64_t *sizep)\n{\n\tint err = 0;\n\tuint64_t size;\n\t \n\n\tuint64_t recordsize;\n\tuint64_t record_count;\n\tobjset_t *os;\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\n\t \n\tif (zfs_override_estimate_recordsize != 0) {\n\t\trecordsize = zfs_override_estimate_recordsize;\n\t} else if (os->os_phys->os_type == DMU_OST_ZVOL) {\n\t\terr = dsl_prop_get_int_ds(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_VOLBLOCKSIZE), &recordsize);\n\t} else {\n\t\terr = dsl_prop_get_int_ds(ds,\n\t\t    zfs_prop_to_name(ZFS_PROP_RECORDSIZE), &recordsize);\n\t}\n\tif (err != 0)\n\t\treturn (err);\n\trecord_count = uncompressed / recordsize;\n\n\t \n\tsize = stream_compressed ? compressed : uncompressed;\n\n\t \n\tsize -= record_count * sizeof (blkptr_t);\n\n\t \n\tsize += record_count * sizeof (dmu_replay_record_t);\n\n\t*sizep = size;\n\n\treturn (0);\n}\n\nint\ndmu_send_estimate_fast(dsl_dataset_t *origds, dsl_dataset_t *fromds,\n    zfs_bookmark_phys_t *frombook, boolean_t stream_compressed,\n    boolean_t saved, uint64_t *sizep)\n{\n\tint err;\n\tdsl_dataset_t *ds = origds;\n\tuint64_t uncomp, comp;\n\n\tASSERT(dsl_pool_config_held(origds->ds_dir->dd_pool));\n\tASSERT(fromds == NULL || frombook == NULL);\n\n\t \n\tif (saved) {\n\t\tobjset_t *mos = origds->ds_dir->dd_pool->dp_meta_objset;\n\t\tuint64_t guid;\n\t\tchar dsname[ZFS_MAX_DATASET_NAME_LEN + 6];\n\n\t\tdsl_dataset_name(origds, dsname);\n\t\t(void) strcat(dsname, \"/\");\n\t\t(void) strlcat(dsname, recv_clone_name, sizeof (dsname));\n\n\t\terr = dsl_dataset_hold(origds->ds_dir->dd_pool,\n\t\t    dsname, FTAG, &ds);\n\t\tif (err != ENOENT && err != 0) {\n\t\t\treturn (err);\n\t\t} else if (err == ENOENT) {\n\t\t\tds = origds;\n\t\t}\n\n\t\t \n\t\terr = zap_lookup(mos, ds->ds_object,\n\t\t    DS_FIELD_RESUME_TOGUID, 8, 1, &guid);\n\t\tif (err != 0) {\n\t\t\terr = SET_ERROR(err == ENOENT ? EINVAL : err);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = zap_lookup(mos, ds->ds_object,\n\t\t    DS_FIELD_RESUME_TONAME, 1, sizeof (dsname), dsname);\n\t\tif (err != 0) {\n\t\t\terr = SET_ERROR(err == ENOENT ? EINVAL : err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!ds->ds_is_snapshot && ds == origds)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (fromds != NULL) {\n\t\tuint64_t used;\n\t\tif (!fromds->ds_is_snapshot) {\n\t\t\terr = SET_ERROR(EINVAL);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!dsl_dataset_is_before(ds, fromds, 0)) {\n\t\t\terr = SET_ERROR(EXDEV);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = dsl_dataset_space_written(fromds, ds, &used, &comp,\n\t\t    &uncomp);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t} else if (frombook != NULL) {\n\t\tuint64_t used;\n\t\terr = dsl_dataset_space_written_bookmark(frombook, ds, &used,\n\t\t    &comp, &uncomp);\n\t\tif (err != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tuncomp = dsl_dataset_phys(ds)->ds_uncompressed_bytes;\n\t\tcomp = dsl_dataset_phys(ds)->ds_compressed_bytes;\n\t}\n\n\terr = dmu_adjust_send_estimate_for_indirects(ds, uncomp, comp,\n\t    stream_compressed, sizep);\n\t \n\t*sizep += 2 * sizeof (dmu_replay_record_t);\n\nout:\n\tif (ds != origds)\n\t\tdsl_dataset_rele(ds, FTAG);\n\treturn (err);\n}\n\nZFS_MODULE_PARAM(zfs_send, zfs_send_, corrupt_data, INT, ZMOD_RW,\n\t\"Allow sending corrupt data\");\n\nZFS_MODULE_PARAM(zfs_send, zfs_send_, queue_length, UINT, ZMOD_RW,\n\t\"Maximum send queue length\");\n\nZFS_MODULE_PARAM(zfs_send, zfs_send_, unmodified_spill_blocks, INT, ZMOD_RW,\n\t\"Send unmodified spill blocks\");\n\nZFS_MODULE_PARAM(zfs_send, zfs_send_, no_prefetch_queue_length, UINT, ZMOD_RW,\n\t\"Maximum send queue length for non-prefetch queues\");\n\nZFS_MODULE_PARAM(zfs_send, zfs_send_, queue_ff, UINT, ZMOD_RW,\n\t\"Send queue fill fraction\");\n\nZFS_MODULE_PARAM(zfs_send, zfs_send_, no_prefetch_queue_ff, UINT, ZMOD_RW,\n\t\"Send queue fill fraction for non-prefetch queues\");\n\nZFS_MODULE_PARAM(zfs_send, zfs_, override_estimate_recordsize, UINT, ZMOD_RW,\n\t\"Override block size estimate with fixed size\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}