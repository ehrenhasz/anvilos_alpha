{
  "module_name": "dsl_userhold.c",
  "hash_id": "0b7c6c586711855cf066ecf7232b12258f8c1d2be401a62972b1e4d5e29bead5",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/dsl_userhold.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/dsl_userhold.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dmu_tx.h>\n#include <sys/zfs_onexit.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_dir.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n\ntypedef struct dsl_dataset_user_hold_arg {\n\tnvlist_t *dduha_holds;\n\tnvlist_t *dduha_chkholds;\n\tnvlist_t *dduha_errlist;\n\tminor_t dduha_minor;\n} dsl_dataset_user_hold_arg_t;\n\n \nint\ndsl_dataset_user_hold_check_one(dsl_dataset_t *ds, const char *htag,\n    boolean_t temphold, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tobjset_t *mos = dp->dp_meta_objset;\n\tint error = 0;\n\n\tASSERT(dsl_pool_config_held(dp));\n\n\tif (strlen(htag) > MAXNAMELEN)\n\t\treturn (SET_ERROR(E2BIG));\n\t \n\tif (temphold && strlen(htag) + MAX_TAG_PREFIX_LEN >= MAXNAMELEN)\n\t\treturn (SET_ERROR(E2BIG));\n\n\t \n\tif (ds != NULL && dsl_dataset_phys(ds)->ds_userrefs_obj != 0) {\n\t\tuint64_t value;\n\n\t\terror = zap_lookup(mos, dsl_dataset_phys(ds)->ds_userrefs_obj,\n\t\t    htag, 8, 1, &value);\n\t\tif (error == 0)\n\t\t\terror = SET_ERROR(EEXIST);\n\t\telse if (error == ENOENT)\n\t\t\terror = 0;\n\t}\n\n\treturn (error);\n}\n\nstatic int\ndsl_dataset_user_hold_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_user_hold_arg_t *dduha = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tnvlist_t *tmp_holds;\n\n\tif (spa_version(dp->dp_spa) < SPA_VERSION_USERREFS)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (!dmu_tx_is_syncing(tx))\n\t\treturn (0);\n\n\t \n\ttmp_holds = fnvlist_alloc();\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dduha->dduha_holds, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(dduha->dduha_holds, pair)) {\n\t\tsize_t len = strlen(nvpair_name(pair)) +\n\t\t    strlen(fnvpair_value_string(pair));\n\t\tchar *nameval = kmem_zalloc(len + 2, KM_SLEEP);\n\t\t(void) strlcpy(nameval, nvpair_name(pair), len + 2);\n\t\t(void) strlcat(nameval, \"@\", len + 2);\n\t\t(void) strlcat(nameval, fnvpair_value_string(pair), len + 2);\n\t\tfnvlist_add_string(tmp_holds, nameval, \"\");\n\t\tkmem_free(nameval, len + 2);\n\t}\n\tsize_t tmp_count = fnvlist_num_pairs(tmp_holds);\n\tfnvlist_free(tmp_holds);\n\tif (tmp_count != fnvlist_num_pairs(dduha->dduha_holds))\n\t\treturn (SET_ERROR(EEXIST));\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dduha->dduha_holds, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(dduha->dduha_holds, pair)) {\n\t\tdsl_dataset_t *ds;\n\t\tint error = 0;\n\t\tconst char *htag, *name;\n\n\t\t \n\t\tname = nvpair_name(pair);\n\t\tif (strchr(name, '@') == NULL)\n\t\t\terror = SET_ERROR(EINVAL);\n\n\t\tif (error == 0)\n\t\t\terror = nvpair_value_string(pair, &htag);\n\n\t\tif (error == 0)\n\t\t\terror = dsl_dataset_hold(dp, name, FTAG, &ds);\n\n\t\tif (error == 0) {\n\t\t\terror = dsl_dataset_user_hold_check_one(ds, htag,\n\t\t\t    dduha->dduha_minor != 0, tx);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t}\n\n\t\tif (error == 0) {\n\t\t\tfnvlist_add_string(dduha->dduha_chkholds, name, htag);\n\t\t} else {\n\t\t\t \n\t\t\tfnvlist_add_int32(dduha->dduha_errlist, name, error);\n\t\t\tif (error != ENOENT)\n\t\t\t\treturn (error);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n\nstatic void\ndsl_dataset_user_hold_sync_one_impl(nvlist_t *tmpholds, dsl_dataset_t *ds,\n    const char *htag, minor_t minor, uint64_t now, dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\tuint64_t zapobj;\n\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\n\tif (dsl_dataset_phys(ds)->ds_userrefs_obj == 0) {\n\t\t \n\t\tdmu_buf_will_dirty(ds->ds_dbuf, tx);\n\t\tzapobj = dsl_dataset_phys(ds)->ds_userrefs_obj =\n\t\t    zap_create(mos, DMU_OT_USERREFS, DMU_OT_NONE, 0, tx);\n\t} else {\n\t\tzapobj = dsl_dataset_phys(ds)->ds_userrefs_obj;\n\t}\n\tds->ds_userrefs++;\n\n\tVERIFY0(zap_add(mos, zapobj, htag, 8, 1, &now, tx));\n\n\tif (minor != 0) {\n\t\tchar name[MAXNAMELEN];\n\t\tnvlist_t *tags;\n\n\t\tVERIFY0(dsl_pool_user_hold(dp, ds->ds_object,\n\t\t    htag, now, tx));\n\t\t(void) snprintf(name, sizeof (name), \"%llx\",\n\t\t    (u_longlong_t)ds->ds_object);\n\n\t\tif (nvlist_lookup_nvlist(tmpholds, name, &tags) != 0) {\n\t\t\ttags = fnvlist_alloc();\n\t\t\tfnvlist_add_boolean(tags, htag);\n\t\t\tfnvlist_add_nvlist(tmpholds, name, tags);\n\t\t\tfnvlist_free(tags);\n\t\t} else {\n\t\t\tfnvlist_add_boolean(tags, htag);\n\t\t}\n\t}\n\n\tspa_history_log_internal_ds(ds, \"hold\", tx,\n\t    \"tag=%s temp=%d refs=%llu\",\n\t    htag, minor != 0, (u_longlong_t)ds->ds_userrefs);\n}\n\ntypedef struct zfs_hold_cleanup_arg {\n\tchar zhca_spaname[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t zhca_spa_load_guid;\n\tnvlist_t *zhca_holds;\n} zfs_hold_cleanup_arg_t;\n\nstatic void\ndsl_dataset_user_release_onexit(void *arg)\n{\n\tzfs_hold_cleanup_arg_t *ca = arg;\n\tspa_t *spa;\n\tint error;\n\n\terror = spa_open(ca->zhca_spaname, &spa, FTAG);\n\tif (error != 0) {\n\t\tzfs_dbgmsg(\"couldn't release holds on pool=%s \"\n\t\t    \"because pool is no longer loaded\",\n\t\t    ca->zhca_spaname);\n\t\treturn;\n\t}\n\tif (spa_load_guid(spa) != ca->zhca_spa_load_guid) {\n\t\tzfs_dbgmsg(\"couldn't release holds on pool=%s \"\n\t\t    \"because pool is no longer loaded (guid doesn't match)\",\n\t\t    ca->zhca_spaname);\n\t\tspa_close(spa, FTAG);\n\t\treturn;\n\t}\n\n\t(void) dsl_dataset_user_release_tmp(spa_get_dsl(spa), ca->zhca_holds);\n\tfnvlist_free(ca->zhca_holds);\n\tkmem_free(ca, sizeof (zfs_hold_cleanup_arg_t));\n\tspa_close(spa, FTAG);\n}\n\nstatic void\ndsl_onexit_hold_cleanup(spa_t *spa, nvlist_t *holds, minor_t minor)\n{\n\tzfs_hold_cleanup_arg_t *ca;\n\n\tif (minor == 0 || nvlist_empty(holds)) {\n\t\tfnvlist_free(holds);\n\t\treturn;\n\t}\n\n\tASSERT(spa != NULL);\n\tca = kmem_alloc(sizeof (*ca), KM_SLEEP);\n\n\t(void) strlcpy(ca->zhca_spaname, spa_name(spa),\n\t    sizeof (ca->zhca_spaname));\n\tca->zhca_spa_load_guid = spa_load_guid(spa);\n\tca->zhca_holds = holds;\n\tVERIFY0(zfs_onexit_add_cb(minor,\n\t    dsl_dataset_user_release_onexit, ca, NULL));\n}\n\nvoid\ndsl_dataset_user_hold_sync_one(dsl_dataset_t *ds, const char *htag,\n    minor_t minor, uint64_t now, dmu_tx_t *tx)\n{\n\tnvlist_t *tmpholds;\n\n\tif (minor != 0)\n\t\ttmpholds = fnvlist_alloc();\n\telse\n\t\ttmpholds = NULL;\n\tdsl_dataset_user_hold_sync_one_impl(tmpholds, ds, htag, minor, now, tx);\n\tdsl_onexit_hold_cleanup(dsl_dataset_get_spa(ds), tmpholds, minor);\n}\n\nstatic void\ndsl_dataset_user_hold_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_user_hold_arg_t *dduha = arg;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\tnvlist_t *tmpholds;\n\tuint64_t now = gethrestime_sec();\n\n\tif (dduha->dduha_minor != 0)\n\t\ttmpholds = fnvlist_alloc();\n\telse\n\t\ttmpholds = NULL;\n\tfor (nvpair_t *pair = nvlist_next_nvpair(dduha->dduha_chkholds, NULL);\n\t    pair != NULL;\n\t    pair = nvlist_next_nvpair(dduha->dduha_chkholds, pair)) {\n\t\tdsl_dataset_t *ds;\n\n\t\tVERIFY0(dsl_dataset_hold(dp, nvpair_name(pair), FTAG, &ds));\n\t\tdsl_dataset_user_hold_sync_one_impl(tmpholds, ds,\n\t\t    fnvpair_value_string(pair), dduha->dduha_minor, now, tx);\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n\tdsl_onexit_hold_cleanup(dp->dp_spa, tmpholds, dduha->dduha_minor);\n}\n\n \nint\ndsl_dataset_user_hold(nvlist_t *holds, minor_t cleanup_minor, nvlist_t *errlist)\n{\n\tdsl_dataset_user_hold_arg_t dduha;\n\tnvpair_t *pair;\n\tint ret;\n\n\tpair = nvlist_next_nvpair(holds, NULL);\n\tif (pair == NULL)\n\t\treturn (0);\n\n\tdduha.dduha_holds = holds;\n\t \n\tVERIFY(0 == nvlist_alloc(&dduha.dduha_chkholds, 0, KM_SLEEP));\n\tdduha.dduha_errlist = errlist;\n\tdduha.dduha_minor = cleanup_minor;\n\n\tret = dsl_sync_task(nvpair_name(pair), dsl_dataset_user_hold_check,\n\t    dsl_dataset_user_hold_sync, &dduha,\n\t    fnvlist_num_pairs(holds), ZFS_SPACE_CHECK_RESERVED);\n\tfnvlist_free(dduha.dduha_chkholds);\n\n\treturn (ret);\n}\n\ntypedef int (dsl_holdfunc_t)(dsl_pool_t *dp, const char *name, const void *tag,\n    dsl_dataset_t **dsp);\n\ntypedef struct dsl_dataset_user_release_arg {\n\tdsl_holdfunc_t *ddura_holdfunc;\n\tnvlist_t *ddura_holds;\n\tnvlist_t *ddura_todelete;\n\tnvlist_t *ddura_errlist;\n\tnvlist_t *ddura_chkholds;\n} dsl_dataset_user_release_arg_t;\n\n \nstatic int\ndsl_dataset_hold_obj_string(dsl_pool_t *dp, const char *dsobj, const void *tag,\n    dsl_dataset_t **dsp)\n{\n\treturn (dsl_dataset_hold_obj(dp, zfs_strtonum(dsobj, NULL), tag, dsp));\n}\n\nstatic int\ndsl_dataset_user_release_check_one(dsl_dataset_user_release_arg_t *ddura,\n    dsl_dataset_t *ds, nvlist_t *holds, const char *snapname)\n{\n\tuint64_t zapobj;\n\tnvlist_t *holds_found;\n\tobjset_t *mos;\n\tint numholds;\n\n\tif (!ds->ds_is_snapshot)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (nvlist_empty(holds))\n\t\treturn (0);\n\n\tnumholds = 0;\n\tmos = ds->ds_dir->dd_pool->dp_meta_objset;\n\tzapobj = dsl_dataset_phys(ds)->ds_userrefs_obj;\n\tVERIFY0(nvlist_alloc(&holds_found, NV_UNIQUE_NAME, KM_SLEEP));\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(holds, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(holds, pair)) {\n\t\tuint64_t tmp;\n\t\tint error;\n\t\tconst char *holdname = nvpair_name(pair);\n\n\t\tif (zapobj != 0)\n\t\t\terror = zap_lookup(mos, zapobj, holdname, 8, 1, &tmp);\n\t\telse\n\t\t\terror = SET_ERROR(ENOENT);\n\n\t\t \n\t\tif (error == ENOENT) {\n\t\t\tif (ddura->ddura_errlist != NULL) {\n\t\t\t\tchar *errtag = kmem_asprintf(\"%s#%s\",\n\t\t\t\t    snapname, holdname);\n\t\t\t\tfnvlist_add_int32(ddura->ddura_errlist, errtag,\n\t\t\t\t    ENOENT);\n\t\t\t\tkmem_strfree(errtag);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (error != 0) {\n\t\t\tfnvlist_free(holds_found);\n\t\t\treturn (error);\n\t\t}\n\n\t\tfnvlist_add_boolean(holds_found, holdname);\n\t\tnumholds++;\n\t}\n\n\tif (DS_IS_DEFER_DESTROY(ds) &&\n\t    dsl_dataset_phys(ds)->ds_num_children == 1 &&\n\t    ds->ds_userrefs == numholds) {\n\t\t \n\t\tif (dsl_dataset_long_held(ds)) {\n\t\t\tfnvlist_free(holds_found);\n\t\t\treturn (SET_ERROR(EBUSY));\n\t\t}\n\t\tfnvlist_add_boolean(ddura->ddura_todelete, snapname);\n\t}\n\n\tif (numholds != 0) {\n\t\tfnvlist_add_nvlist(ddura->ddura_chkholds, snapname,\n\t\t    holds_found);\n\t}\n\tfnvlist_free(holds_found);\n\n\treturn (0);\n}\n\nstatic int\ndsl_dataset_user_release_check(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_user_release_arg_t *ddura;\n\tdsl_holdfunc_t *holdfunc;\n\tdsl_pool_t *dp;\n\n\tif (!dmu_tx_is_syncing(tx))\n\t\treturn (0);\n\n\tdp = dmu_tx_pool(tx);\n\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\n\tddura = arg;\n\tholdfunc = ddura->ddura_holdfunc;\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(ddura->ddura_holds, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(ddura->ddura_holds, pair)) {\n\t\tint error;\n\t\tdsl_dataset_t *ds;\n\t\tnvlist_t *holds;\n\t\tconst char *snapname = nvpair_name(pair);\n\n\t\terror = nvpair_value_nvlist(pair, &holds);\n\t\tif (error != 0)\n\t\t\terror = (SET_ERROR(EINVAL));\n\t\telse\n\t\t\terror = holdfunc(dp, snapname, FTAG, &ds);\n\t\tif (error == 0) {\n\t\t\terror = dsl_dataset_user_release_check_one(ddura, ds,\n\t\t\t    holds, snapname);\n\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t}\n\t\tif (error != 0) {\n\t\t\tif (ddura->ddura_errlist != NULL) {\n\t\t\t\tfnvlist_add_int32(ddura->ddura_errlist,\n\t\t\t\t    snapname, error);\n\t\t\t}\n\t\t\t \n\t\t\tif (error != ENOENT)\n\t\t\t\treturn (error);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nstatic void\ndsl_dataset_user_release_sync_one(dsl_dataset_t *ds, nvlist_t *holds,\n    dmu_tx_t *tx)\n{\n\tdsl_pool_t *dp = ds->ds_dir->dd_pool;\n\tobjset_t *mos = dp->dp_meta_objset;\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(holds, NULL); pair != NULL;\n\t    pair = nvlist_next_nvpair(holds, pair)) {\n\t\tint error;\n\t\tconst char *holdname = nvpair_name(pair);\n\n\t\t \n\t\terror = dsl_pool_user_release(dp, ds->ds_object, holdname, tx);\n\t\tVERIFY(error == 0 || error == ENOENT);\n\n\t\tVERIFY0(zap_remove(mos, dsl_dataset_phys(ds)->ds_userrefs_obj,\n\t\t    holdname, tx));\n\t\tds->ds_userrefs--;\n\n\t\tspa_history_log_internal_ds(ds, \"release\", tx,\n\t\t    \"tag=%s refs=%lld\", holdname, (longlong_t)ds->ds_userrefs);\n\t}\n}\n\nstatic void\ndsl_dataset_user_release_sync(void *arg, dmu_tx_t *tx)\n{\n\tdsl_dataset_user_release_arg_t *ddura = arg;\n\tdsl_holdfunc_t *holdfunc = ddura->ddura_holdfunc;\n\tdsl_pool_t *dp = dmu_tx_pool(tx);\n\n\tASSERT(RRW_WRITE_HELD(&dp->dp_config_rwlock));\n\n\tfor (nvpair_t *pair = nvlist_next_nvpair(ddura->ddura_chkholds, NULL);\n\t    pair != NULL; pair = nvlist_next_nvpair(ddura->ddura_chkholds,\n\t    pair)) {\n\t\tdsl_dataset_t *ds;\n\t\tconst char *name = nvpair_name(pair);\n\n\t\tVERIFY0(holdfunc(dp, name, FTAG, &ds));\n\n\t\tdsl_dataset_user_release_sync_one(ds,\n\t\t    fnvpair_value_nvlist(pair), tx);\n\t\tif (nvlist_exists(ddura->ddura_todelete, name)) {\n\t\t\tASSERT(ds->ds_userrefs == 0 &&\n\t\t\t    dsl_dataset_phys(ds)->ds_num_children == 1 &&\n\t\t\t    DS_IS_DEFER_DESTROY(ds));\n\t\t\tdsl_destroy_snapshot_sync_impl(ds, B_FALSE, tx);\n\t\t}\n\t\tdsl_dataset_rele(ds, FTAG);\n\t}\n}\n\n \nstatic int\ndsl_dataset_user_release_impl(nvlist_t *holds, nvlist_t *errlist,\n    dsl_pool_t *tmpdp)\n{\n\tdsl_dataset_user_release_arg_t ddura;\n\tnvpair_t *pair;\n\tconst char *pool;\n\tint error;\n\n\tpair = nvlist_next_nvpair(holds, NULL);\n\tif (pair == NULL)\n\t\treturn (0);\n\n\t \n\tif (tmpdp != NULL) {\n\t\t \n\t\tddura.ddura_holdfunc = dsl_dataset_hold_obj_string;\n\t\tpool = spa_name(tmpdp->dp_spa);\n#ifdef _KERNEL\n\t\tfor (pair = nvlist_next_nvpair(holds, NULL); pair != NULL;\n\t\t    pair = nvlist_next_nvpair(holds, pair)) {\n\t\t\tdsl_dataset_t *ds;\n\n\t\t\tdsl_pool_config_enter(tmpdp, FTAG);\n\t\t\terror = dsl_dataset_hold_obj_string(tmpdp,\n\t\t\t    nvpair_name(pair), FTAG, &ds);\n\t\t\tif (error == 0) {\n\t\t\t\tchar name[ZFS_MAX_DATASET_NAME_LEN];\n\t\t\t\tdsl_dataset_name(ds, name);\n\t\t\t\tdsl_pool_config_exit(tmpdp, FTAG);\n\t\t\t\tdsl_dataset_rele(ds, FTAG);\n\t\t\t\t(void) zfs_unmount_snap(name);\n\t\t\t} else {\n\t\t\t\tdsl_pool_config_exit(tmpdp, FTAG);\n\t\t\t}\n\t\t}\n#endif\n\t} else {\n\t\t \n\t\tddura.ddura_holdfunc = dsl_dataset_hold;\n\t\tpool = nvpair_name(pair);\n#ifdef _KERNEL\n\t\tfor (pair = nvlist_next_nvpair(holds, NULL); pair != NULL;\n\t\t    pair = nvlist_next_nvpair(holds, pair)) {\n\t\t\t(void) zfs_unmount_snap(nvpair_name(pair));\n\t\t}\n#endif\n\t}\n\n\tddura.ddura_holds = holds;\n\tddura.ddura_errlist = errlist;\n\tVERIFY0(nvlist_alloc(&ddura.ddura_todelete, NV_UNIQUE_NAME,\n\t    KM_SLEEP));\n\tVERIFY0(nvlist_alloc(&ddura.ddura_chkholds, NV_UNIQUE_NAME,\n\t    KM_SLEEP));\n\n\terror = dsl_sync_task(pool, dsl_dataset_user_release_check,\n\t    dsl_dataset_user_release_sync, &ddura, 0,\n\t    ZFS_SPACE_CHECK_EXTRA_RESERVED);\n\tfnvlist_free(ddura.ddura_todelete);\n\tfnvlist_free(ddura.ddura_chkholds);\n\n\treturn (error);\n}\n\n \nint\ndsl_dataset_user_release(nvlist_t *holds, nvlist_t *errlist)\n{\n\treturn (dsl_dataset_user_release_impl(holds, errlist, NULL));\n}\n\n \nvoid\ndsl_dataset_user_release_tmp(struct dsl_pool *dp, nvlist_t *holds)\n{\n\tASSERT(dp != NULL);\n\t(void) dsl_dataset_user_release_impl(holds, NULL, dp);\n}\n\nint\ndsl_dataset_get_holds(const char *dsname, nvlist_t *nvl)\n{\n\tdsl_pool_t *dp;\n\tdsl_dataset_t *ds;\n\tint err;\n\n\terr = dsl_pool_hold(dsname, FTAG, &dp);\n\tif (err != 0)\n\t\treturn (err);\n\terr = dsl_dataset_hold(dp, dsname, FTAG, &ds);\n\tif (err != 0) {\n\t\tdsl_pool_rele(dp, FTAG);\n\t\treturn (err);\n\t}\n\n\tif (dsl_dataset_phys(ds)->ds_userrefs_obj != 0) {\n\t\tzap_attribute_t *za;\n\t\tzap_cursor_t zc;\n\n\t\tza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);\n\t\tfor (zap_cursor_init(&zc, ds->ds_dir->dd_pool->dp_meta_objset,\n\t\t    dsl_dataset_phys(ds)->ds_userrefs_obj);\n\t\t    zap_cursor_retrieve(&zc, za) == 0;\n\t\t    zap_cursor_advance(&zc)) {\n\t\t\tfnvlist_add_uint64(nvl, za->za_name,\n\t\t\t    za->za_first_integer);\n\t\t}\n\t\tzap_cursor_fini(&zc);\n\t\tkmem_free(za, sizeof (zap_attribute_t));\n\t}\n\tdsl_dataset_rele(ds, FTAG);\n\tdsl_pool_rele(dp, FTAG);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}