{
  "module_name": "spa_config.c",
  "hash_id": "2a71dc1ba9c1ab20b881827039512f035de8db2fd6fbc286c723a7fdb6c619ac",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/spa_config.c",
  "human_readable_source": " \n\n \n\n#include <sys/spa.h>\n#include <sys/file.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/spa_impl.h>\n#include <sys/nvpair.h>\n#include <sys/fs/zfs.h>\n#include <sys/vdev_impl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/systeminfo.h>\n#include <sys/sunddi.h>\n#include <sys/zfeature.h>\n#include <sys/zfs_file.h>\n#include <sys/zfs_context.h>\n#ifdef _KERNEL\n#include <sys/zone.h>\n#endif\n\n \n\nstatic uint64_t spa_config_generation = 1;\n\n \nchar *spa_config_path = (char *)ZPOOL_CACHE;\n#ifdef _KERNEL\nstatic int zfs_autoimport_disable = B_TRUE;\n#endif\n\n \nvoid\nspa_config_load(void)\n{\n\tvoid *buf = NULL;\n\tnvlist_t *nvlist, *child;\n\tnvpair_t *nvpair;\n\tchar *pathname;\n\tzfs_file_t *fp;\n\tzfs_file_attr_t zfa;\n\tuint64_t fsize;\n\tint err;\n\n#ifdef _KERNEL\n\tif (zfs_autoimport_disable)\n\t\treturn;\n#endif\n\n\t \n\tpathname = kmem_alloc(MAXPATHLEN, KM_SLEEP);\n\n\t(void) snprintf(pathname, MAXPATHLEN, \"%s\", spa_config_path);\n\n\terr = zfs_file_open(pathname, O_RDONLY, 0, &fp);\n\n#ifdef __FreeBSD__\n\tif (err)\n\t\terr = zfs_file_open(ZPOOL_CACHE_BOOT, O_RDONLY, 0, &fp);\n#endif\n\tkmem_free(pathname, MAXPATHLEN);\n\n\tif (err)\n\t\treturn;\n\n\tif (zfs_file_getattr(fp, &zfa))\n\t\tgoto out;\n\n\tfsize = zfa.zfa_size;\n\tbuf = kmem_alloc(fsize, KM_SLEEP);\n\n\t \n\tif (zfs_file_read(fp, buf, fsize, NULL) < 0)\n\t\tgoto out;\n\n\t \n\tif (nvlist_unpack(buf, fsize, &nvlist, KM_SLEEP) != 0)\n\t\tgoto out;\n\n\t \n\tmutex_enter(&spa_namespace_lock);\n\tnvpair = NULL;\n\twhile ((nvpair = nvlist_next_nvpair(nvlist, nvpair)) != NULL) {\n\t\tif (nvpair_type(nvpair) != DATA_TYPE_NVLIST)\n\t\t\tcontinue;\n\n\t\tchild = fnvpair_value_nvlist(nvpair);\n\n\t\tif (spa_lookup(nvpair_name(nvpair)) != NULL)\n\t\t\tcontinue;\n\t\t(void) spa_add(nvpair_name(nvpair), child, NULL);\n\t}\n\tmutex_exit(&spa_namespace_lock);\n\n\tnvlist_free(nvlist);\n\nout:\n\tif (buf != NULL)\n\t\tkmem_free(buf, fsize);\n\n\tzfs_file_close(fp);\n}\n\nstatic int\nspa_config_remove(spa_config_dirent_t *dp)\n{\n\tint error = 0;\n\n\t \n\terror = zfs_file_unlink(dp->scd_path);\n\tif (error == EOPNOTSUPP) {\n\t\tint flags = O_RDWR | O_TRUNC;\n\t\tzfs_file_t *fp;\n\n\t\terror = zfs_file_open(dp->scd_path, flags, 0644, &fp);\n\t\tif (error == 0) {\n\t\t\t(void) zfs_file_fsync(fp, O_SYNC);\n\t\t\t(void) zfs_file_close(fp);\n\t\t}\n\t}\n\n\treturn (error);\n}\n\nstatic int\nspa_config_write(spa_config_dirent_t *dp, nvlist_t *nvl)\n{\n\tsize_t buflen;\n\tchar *buf;\n\tint oflags = O_RDWR | O_TRUNC | O_CREAT | O_LARGEFILE;\n\tchar *temp;\n\tint err;\n\tzfs_file_t *fp;\n\n\t \n\tif (nvl == NULL) {\n\t\terr = spa_config_remove(dp);\n\t\tif (err == ENOENT)\n\t\t\terr = 0;\n\n\t\treturn (err);\n\t}\n\n\t \n\tbuf = fnvlist_pack(nvl, &buflen);\n\ttemp = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\t \n\terr = zfs_file_open(dp->scd_path, oflags, 0644, &fp);\n\tif (err == 0) {\n\t\terr = zfs_file_write(fp, buf, buflen, NULL);\n\t\tif (err == 0)\n\t\t\terr = zfs_file_fsync(fp, O_SYNC);\n\n\t\tzfs_file_close(fp);\n\t\tif (err)\n\t\t\t(void) spa_config_remove(dp);\n\t}\n\tfnvlist_pack_free(buf, buflen);\n\tkmem_free(temp, MAXPATHLEN);\n\treturn (err);\n}\n\n \nvoid\nspa_write_cachefile(spa_t *target, boolean_t removing, boolean_t postsysevent,\n    boolean_t postblkidevent)\n{\n\tspa_config_dirent_t *dp, *tdp;\n\tnvlist_t *nvl;\n\tconst char *pool_name;\n\tboolean_t ccw_failure;\n\tint error = 0;\n\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\n\tif (!(spa_mode_global & SPA_MODE_WRITE))\n\t\treturn;\n\n\t \n\tccw_failure = B_FALSE;\n\tfor (dp = list_head(&target->spa_config_list); dp != NULL;\n\t    dp = list_next(&target->spa_config_list, dp)) {\n\t\tspa_t *spa = NULL;\n\t\tif (dp->scd_path == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tnvl = NULL;\n\t\twhile ((spa = spa_next(spa)) != NULL) {\n\t\t\t \n\t\t\tif ((spa == target && removing) ||\n\t\t\t    !spa_writeable(spa))\n\t\t\t\tcontinue;\n\n\t\t\tmutex_enter(&spa->spa_props_lock);\n\t\t\ttdp = list_head(&spa->spa_config_list);\n\t\t\tif (spa->spa_config == NULL ||\n\t\t\t    tdp == NULL ||\n\t\t\t    tdp->scd_path == NULL ||\n\t\t\t    strcmp(tdp->scd_path, dp->scd_path) != 0) {\n\t\t\t\tmutex_exit(&spa->spa_props_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (nvl == NULL)\n\t\t\t\tnvl = fnvlist_alloc();\n\n\t\t\tif (spa->spa_import_flags & ZFS_IMPORT_TEMP_NAME)\n\t\t\t\tpool_name = fnvlist_lookup_string(\n\t\t\t\t    spa->spa_config, ZPOOL_CONFIG_POOL_NAME);\n\t\t\telse\n\t\t\t\tpool_name = spa_name(spa);\n\n\t\t\tfnvlist_add_nvlist(nvl, pool_name, spa->spa_config);\n\t\t\tmutex_exit(&spa->spa_props_lock);\n\t\t}\n\n\t\terror = spa_config_write(dp, nvl);\n\t\tif (error != 0)\n\t\t\tccw_failure = B_TRUE;\n\t\tnvlist_free(nvl);\n\t}\n\n\tif (ccw_failure) {\n\t\t \n\t\tif (target->spa_ccw_fail_time == 0) {\n\t\t\t(void) zfs_ereport_post(\n\t\t\t    FM_EREPORT_ZFS_CONFIG_CACHE_WRITE,\n\t\t\t    target, NULL, NULL, NULL, 0);\n\t\t}\n\t\ttarget->spa_ccw_fail_time = gethrtime();\n\t\tspa_async_request(target, SPA_ASYNC_CONFIG_UPDATE);\n\t} else {\n\t\t \n\t\ttarget->spa_ccw_fail_time = 0;\n\t}\n\n\t \n\tdp = list_head(&target->spa_config_list);\n\twhile ((tdp = list_next(&target->spa_config_list, dp)) != NULL) {\n\t\tlist_remove(&target->spa_config_list, tdp);\n\t\tif (tdp->scd_path != NULL)\n\t\t\tspa_strfree(tdp->scd_path);\n\t\tkmem_free(tdp, sizeof (spa_config_dirent_t));\n\t}\n\n\tspa_config_generation++;\n\n\tif (postsysevent)\n\t\tspa_event_notify(target, NULL, NULL, ESC_ZFS_CONFIG_SYNC);\n\n\t \n\tif ((target->spa_root_vdev) && postblkidevent) {\n\t\tvdev_post_kobj_evt(target->spa_root_vdev);\n\t\tfor (int i = 0; i < target->spa_l2cache.sav_count; i++)\n\t\t\tvdev_post_kobj_evt(target->spa_l2cache.sav_vdevs[i]);\n\t\tfor (int i = 0; i < target->spa_spares.sav_count; i++)\n\t\t\tvdev_post_kobj_evt(target->spa_spares.sav_vdevs[i]);\n\t}\n}\n\n \nint\nspa_all_configs(uint64_t *generation, nvlist_t **pools)\n{\n\tspa_t *spa = NULL;\n\n\tif (*generation == spa_config_generation)\n\t\treturn (SET_ERROR(EEXIST));\n\n\tint error = mutex_enter_interruptible(&spa_namespace_lock);\n\tif (error)\n\t\treturn (SET_ERROR(EINTR));\n\n\t*pools = fnvlist_alloc();\n\twhile ((spa = spa_next(spa)) != NULL) {\n\t\tif (INGLOBALZONE(curproc) ||\n\t\t    zone_dataset_visible(spa_name(spa), NULL)) {\n\t\t\tmutex_enter(&spa->spa_props_lock);\n\t\t\tfnvlist_add_nvlist(*pools, spa_name(spa),\n\t\t\t    spa->spa_config);\n\t\t\tmutex_exit(&spa->spa_props_lock);\n\t\t}\n\t}\n\t*generation = spa_config_generation;\n\tmutex_exit(&spa_namespace_lock);\n\n\treturn (0);\n}\n\nvoid\nspa_config_set(spa_t *spa, nvlist_t *config)\n{\n\tmutex_enter(&spa->spa_props_lock);\n\tif (spa->spa_config != NULL && spa->spa_config != config)\n\t\tnvlist_free(spa->spa_config);\n\tspa->spa_config = config;\n\tmutex_exit(&spa->spa_props_lock);\n}\n\n \nnvlist_t *\nspa_config_generate(spa_t *spa, vdev_t *vd, uint64_t txg, int getstats)\n{\n\tnvlist_t *config, *nvroot;\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tunsigned long hostid = 0;\n\tboolean_t locked = B_FALSE;\n\tuint64_t split_guid;\n\tconst char *pool_name;\n\n\tif (vd == NULL) {\n\t\tvd = rvd;\n\t\tlocked = B_TRUE;\n\t\tspa_config_enter(spa, SCL_CONFIG | SCL_STATE, FTAG, RW_READER);\n\t}\n\n\tASSERT(spa_config_held(spa, SCL_CONFIG | SCL_STATE, RW_READER) ==\n\t    (SCL_CONFIG | SCL_STATE));\n\n\t \n\tif (txg == -1ULL)\n\t\ttxg = spa->spa_config_txg;\n\n\t \n\tif (spa->spa_import_flags & ZFS_IMPORT_TEMP_NAME) {\n\t\tVERIFY0(nvlist_lookup_string(spa->spa_config,\n\t\t    ZPOOL_CONFIG_POOL_NAME, &pool_name));\n\t} else\n\t\tpool_name = spa_name(spa);\n\n\tconfig = fnvlist_alloc();\n\n\tfnvlist_add_uint64(config, ZPOOL_CONFIG_VERSION, spa_version(spa));\n\tfnvlist_add_string(config, ZPOOL_CONFIG_POOL_NAME, pool_name);\n\tfnvlist_add_uint64(config, ZPOOL_CONFIG_POOL_STATE, spa_state(spa));\n\tfnvlist_add_uint64(config, ZPOOL_CONFIG_POOL_TXG, txg);\n\tfnvlist_add_uint64(config, ZPOOL_CONFIG_POOL_GUID, spa_guid(spa));\n\tfnvlist_add_uint64(config, ZPOOL_CONFIG_ERRATA, spa->spa_errata);\n\tif (spa->spa_comment != NULL)\n\t\tfnvlist_add_string(config, ZPOOL_CONFIG_COMMENT,\n\t\t    spa->spa_comment);\n\tif (spa->spa_compatibility != NULL)\n\t\tfnvlist_add_string(config, ZPOOL_CONFIG_COMPATIBILITY,\n\t\t    spa->spa_compatibility);\n\n\thostid = spa_get_hostid(spa);\n\tif (hostid != 0)\n\t\tfnvlist_add_uint64(config, ZPOOL_CONFIG_HOSTID, hostid);\n\tfnvlist_add_string(config, ZPOOL_CONFIG_HOSTNAME, utsname()->nodename);\n\n\tint config_gen_flags = 0;\n\tif (vd != rvd) {\n\t\tfnvlist_add_uint64(config, ZPOOL_CONFIG_TOP_GUID,\n\t\t    vd->vdev_top->vdev_guid);\n\t\tfnvlist_add_uint64(config, ZPOOL_CONFIG_GUID,\n\t\t    vd->vdev_guid);\n\t\tif (vd->vdev_isspare)\n\t\t\tfnvlist_add_uint64(config,\n\t\t\t    ZPOOL_CONFIG_IS_SPARE, 1ULL);\n\t\tif (vd->vdev_islog)\n\t\t\tfnvlist_add_uint64(config,\n\t\t\t    ZPOOL_CONFIG_IS_LOG, 1ULL);\n\t\tvd = vd->vdev_top;\t\t \n\t} else {\n\t\t \n\t\tif (spa->spa_config_splitting != NULL)\n\t\t\tfnvlist_add_nvlist(config, ZPOOL_CONFIG_SPLIT,\n\t\t\t    spa->spa_config_splitting);\n\n\t\tfnvlist_add_boolean(config, ZPOOL_CONFIG_HAS_PER_VDEV_ZAPS);\n\n\t\tconfig_gen_flags |= VDEV_CONFIG_MOS;\n\t}\n\n\t \n\tvdev_top_config_generate(spa, config);\n\n\t \n\tif (spa->spa_config_splitting != NULL &&\n\t    nvlist_lookup_uint64(spa->spa_config_splitting,\n\t    ZPOOL_CONFIG_SPLIT_GUID, &split_guid) == 0) {\n\t\tfnvlist_add_uint64(config, ZPOOL_CONFIG_SPLIT_GUID, split_guid);\n\t}\n\n\tnvroot = vdev_config_generate(spa, vd, getstats, config_gen_flags);\n\tfnvlist_add_nvlist(config, ZPOOL_CONFIG_VDEV_TREE, nvroot);\n\tnvlist_free(nvroot);\n\n\t \n\tfnvlist_add_nvlist(config, ZPOOL_CONFIG_FEATURES_FOR_READ,\n\t    spa->spa_label_features);\n\n\tif (getstats && spa_load_state(spa) == SPA_LOAD_NONE) {\n\t\tddt_histogram_t *ddh;\n\t\tddt_stat_t *dds;\n\t\tddt_object_t *ddo;\n\n\t\tddh = kmem_zalloc(sizeof (ddt_histogram_t), KM_SLEEP);\n\t\tddt_get_dedup_histogram(spa, ddh);\n\t\tfnvlist_add_uint64_array(config,\n\t\t    ZPOOL_CONFIG_DDT_HISTOGRAM,\n\t\t    (uint64_t *)ddh, sizeof (*ddh) / sizeof (uint64_t));\n\t\tkmem_free(ddh, sizeof (ddt_histogram_t));\n\n\t\tddo = kmem_zalloc(sizeof (ddt_object_t), KM_SLEEP);\n\t\tddt_get_dedup_object_stats(spa, ddo);\n\t\tfnvlist_add_uint64_array(config,\n\t\t    ZPOOL_CONFIG_DDT_OBJ_STATS,\n\t\t    (uint64_t *)ddo, sizeof (*ddo) / sizeof (uint64_t));\n\t\tkmem_free(ddo, sizeof (ddt_object_t));\n\n\t\tdds = kmem_zalloc(sizeof (ddt_stat_t), KM_SLEEP);\n\t\tddt_get_dedup_stats(spa, dds);\n\t\tfnvlist_add_uint64_array(config,\n\t\t    ZPOOL_CONFIG_DDT_STATS,\n\t\t    (uint64_t *)dds, sizeof (*dds) / sizeof (uint64_t));\n\t\tkmem_free(dds, sizeof (ddt_stat_t));\n\t}\n\n\tif (locked)\n\t\tspa_config_exit(spa, SCL_CONFIG | SCL_STATE, FTAG);\n\n\treturn (config);\n}\n\n \nvoid\nspa_config_update(spa_t *spa, int what)\n{\n\tvdev_t *rvd = spa->spa_root_vdev;\n\tuint64_t txg;\n\tint c;\n\n\tASSERT(MUTEX_HELD(&spa_namespace_lock));\n\n\tspa_config_enter(spa, SCL_ALL, FTAG, RW_WRITER);\n\ttxg = spa_last_synced_txg(spa) + 1;\n\tif (what == SPA_CONFIG_UPDATE_POOL) {\n\t\tvdev_config_dirty(rvd);\n\t} else {\n\t\t \n\t\tfor (c = 0; c < rvd->vdev_children; c++) {\n\t\t\tvdev_t *tvd = rvd->vdev_child[c];\n\n\t\t\t \n\t\t\tif (!vdev_is_concrete(tvd) ||\n\t\t\t    (tvd->vdev_islog && tvd->vdev_removing))\n\t\t\t\tcontinue;\n\n\t\t\tif (tvd->vdev_ms_array == 0)\n\t\t\t\tvdev_metaslab_set_size(tvd);\n\t\t\tvdev_expand(tvd, txg);\n\t\t}\n\t}\n\tspa_config_exit(spa, SCL_ALL, FTAG);\n\n\t \n\ttxg_wait_synced(spa->spa_dsl_pool, txg);\n\n\t \n\tif (!spa->spa_is_root) {\n\t\tspa_write_cachefile(spa, B_FALSE,\n\t\t    what != SPA_CONFIG_UPDATE_POOL,\n\t\t    what != SPA_CONFIG_UPDATE_POOL);\n\t}\n\n\tif (what == SPA_CONFIG_UPDATE_POOL)\n\t\tspa_config_update(spa, SPA_CONFIG_UPDATE_VDEVS);\n}\n\nEXPORT_SYMBOL(spa_config_load);\nEXPORT_SYMBOL(spa_all_configs);\nEXPORT_SYMBOL(spa_config_set);\nEXPORT_SYMBOL(spa_config_generate);\nEXPORT_SYMBOL(spa_config_update);\n\n#ifdef __linux__\n \nZFS_MODULE_PARAM(zfs_spa, spa_, config_path, STRING, ZMOD_RD,\n\t\"SPA config file (/etc/zfs/zpool.cache)\");\n#endif\n\nZFS_MODULE_PARAM(zfs, zfs_, autoimport_disable, INT, ZMOD_RW,\n\t\"Disable pool import at module load\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}