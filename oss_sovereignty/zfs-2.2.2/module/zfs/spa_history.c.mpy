{
  "module_name": "spa_history.c",
  "hash_id": "ef9e2f9532782272be4ce367d988e739bdfdad38f4e2d7d660b880494cdad424",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/spa_history.c",
  "human_readable_source": " \n\n \n\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zap.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dmu_tx.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/cmn_err.h>\n#include <sys/sunddi.h>\n#include <sys/cred.h>\n#include \"zfs_comutil.h\"\n#include \"zfs_gitrev.h\"\n#ifdef _KERNEL\n#include <sys/zone.h>\n#endif\n\n \n\n \nstatic uint64_t\nspa_history_log_to_phys(uint64_t log_off, spa_history_phys_t *shpp)\n{\n\tuint64_t phys_len;\n\n\tphys_len = shpp->sh_phys_max_off - shpp->sh_pool_create_len;\n\treturn ((log_off - shpp->sh_pool_create_len) % phys_len\n\t    + shpp->sh_pool_create_len);\n}\n\nvoid\nspa_history_create_obj(spa_t *spa, dmu_tx_t *tx)\n{\n\tdmu_buf_t *dbp;\n\tspa_history_phys_t *shpp;\n\tobjset_t *mos = spa->spa_meta_objset;\n\n\tASSERT0(spa->spa_history);\n\tspa->spa_history = dmu_object_alloc(mos, DMU_OT_SPA_HISTORY,\n\t    SPA_OLD_MAXBLOCKSIZE, DMU_OT_SPA_HISTORY_OFFSETS,\n\t    sizeof (spa_history_phys_t), tx);\n\n\tVERIFY0(zap_add(mos, DMU_POOL_DIRECTORY_OBJECT,\n\t    DMU_POOL_HISTORY, sizeof (uint64_t), 1,\n\t    &spa->spa_history, tx));\n\n\tVERIFY0(dmu_bonus_hold(mos, spa->spa_history, FTAG, &dbp));\n\tASSERT3U(dbp->db_size, >=, sizeof (spa_history_phys_t));\n\n\tshpp = dbp->db_data;\n\tdmu_buf_will_dirty(dbp, tx);\n\n\t \n\tshpp->sh_phys_max_off =\n\t    metaslab_class_get_dspace(spa_normal_class(spa)) / 1000;\n\tshpp->sh_phys_max_off = MIN(shpp->sh_phys_max_off, 1<<30);\n\tshpp->sh_phys_max_off = MAX(shpp->sh_phys_max_off, 128<<10);\n\n\tdmu_buf_rele(dbp, FTAG);\n}\n\n \nstatic int\nspa_history_advance_bof(spa_t *spa, spa_history_phys_t *shpp)\n{\n\tobjset_t *mos = spa->spa_meta_objset;\n\tuint64_t firstread, reclen, phys_bof;\n\tchar buf[sizeof (reclen)];\n\tint err;\n\n\tphys_bof = spa_history_log_to_phys(shpp->sh_bof, shpp);\n\tfirstread = MIN(sizeof (reclen), shpp->sh_phys_max_off - phys_bof);\n\n\tif ((err = dmu_read(mos, spa->spa_history, phys_bof, firstread,\n\t    buf, DMU_READ_PREFETCH)) != 0)\n\t\treturn (err);\n\tif (firstread != sizeof (reclen)) {\n\t\tif ((err = dmu_read(mos, spa->spa_history,\n\t\t    shpp->sh_pool_create_len, sizeof (reclen) - firstread,\n\t\t    buf + firstread, DMU_READ_PREFETCH)) != 0)\n\t\t\treturn (err);\n\t}\n\n\treclen = LE_64(*((uint64_t *)buf));\n\tshpp->sh_bof += reclen + sizeof (reclen);\n\tshpp->sh_records_lost++;\n\treturn (0);\n}\n\nstatic int\nspa_history_write(spa_t *spa, void *buf, uint64_t len, spa_history_phys_t *shpp,\n    dmu_tx_t *tx)\n{\n\tuint64_t firstwrite, phys_eof;\n\tobjset_t *mos = spa->spa_meta_objset;\n\tint err;\n\n\tASSERT(MUTEX_HELD(&spa->spa_history_lock));\n\n\t \n\twhile (shpp->sh_phys_max_off - shpp->sh_pool_create_len -\n\t    (shpp->sh_eof - shpp->sh_bof) <= len) {\n\t\tif ((err = spa_history_advance_bof(spa, shpp)) != 0) {\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\tphys_eof = spa_history_log_to_phys(shpp->sh_eof, shpp);\n\tfirstwrite = MIN(len, shpp->sh_phys_max_off - phys_eof);\n\tshpp->sh_eof += len;\n\tdmu_write(mos, spa->spa_history, phys_eof, firstwrite, buf, tx);\n\n\tlen -= firstwrite;\n\tif (len > 0) {\n\t\t \n\t\tdmu_write(mos, spa->spa_history, shpp->sh_pool_create_len,\n\t\t    len, (char *)buf + firstwrite, tx);\n\t}\n\n\treturn (0);\n}\n\n \nstatic void\nspa_history_log_notify(spa_t *spa, nvlist_t *nvl)\n{\n\tnvlist_t *hist_nvl = fnvlist_alloc();\n\tuint64_t uint64;\n\tconst char *string;\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_CMD, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_CMD, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_INT_NAME, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_INT_NAME, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_ZONE, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_ZONE, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_HOST, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_HOST, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_DSNAME, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_DSNAME, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_INT_STR, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_INT_STR, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_IOCTL, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_IOCTL, string);\n\n\tif (nvlist_lookup_string(nvl, ZPOOL_HIST_INT_NAME, &string) == 0)\n\t\tfnvlist_add_string(hist_nvl, ZFS_EV_HIST_INT_NAME, string);\n\n\tif (nvlist_lookup_uint64(nvl, ZPOOL_HIST_DSID, &uint64) == 0)\n\t\tfnvlist_add_uint64(hist_nvl, ZFS_EV_HIST_DSID, uint64);\n\n\tif (nvlist_lookup_uint64(nvl, ZPOOL_HIST_TXG, &uint64) == 0)\n\t\tfnvlist_add_uint64(hist_nvl, ZFS_EV_HIST_TXG, uint64);\n\n\tif (nvlist_lookup_uint64(nvl, ZPOOL_HIST_TIME, &uint64) == 0)\n\t\tfnvlist_add_uint64(hist_nvl, ZFS_EV_HIST_TIME, uint64);\n\n\tif (nvlist_lookup_uint64(nvl, ZPOOL_HIST_WHO, &uint64) == 0)\n\t\tfnvlist_add_uint64(hist_nvl, ZFS_EV_HIST_WHO, uint64);\n\n\tif (nvlist_lookup_uint64(nvl, ZPOOL_HIST_INT_EVENT, &uint64) == 0)\n\t\tfnvlist_add_uint64(hist_nvl, ZFS_EV_HIST_INT_EVENT, uint64);\n\n\tspa_event_notify(spa, NULL, hist_nvl, ESC_ZFS_HISTORY_EVENT);\n\n\tnvlist_free(hist_nvl);\n}\n\n \nstatic void\nspa_history_log_sync(void *arg, dmu_tx_t *tx)\n{\n\tnvlist_t\t*nvl = arg;\n\tspa_t\t\t*spa = dmu_tx_pool(tx)->dp_spa;\n\tobjset_t\t*mos = spa->spa_meta_objset;\n\tdmu_buf_t\t*dbp;\n\tspa_history_phys_t *shpp;\n\tsize_t\t\treclen;\n\tuint64_t\tle_len;\n\tchar\t\t*record_packed = NULL;\n\tint\t\tret;\n\n\t \n\tmutex_enter(&spa->spa_history_lock);\n\tif (!spa->spa_history)\n\t\tspa_history_create_obj(spa, tx);\n\tmutex_exit(&spa->spa_history_lock);\n\n\t \n\tVERIFY0(dmu_bonus_hold(mos, spa->spa_history, FTAG, &dbp));\n\tshpp = dbp->db_data;\n\n\tdmu_buf_will_dirty(dbp, tx);\n\n#ifdef ZFS_DEBUG\n\t{\n\t\tdmu_object_info_t doi;\n\t\tdmu_object_info_from_db(dbp, &doi);\n\t\tASSERT3U(doi.doi_bonus_type, ==, DMU_OT_SPA_HISTORY_OFFSETS);\n\t}\n#endif\n\n\tfnvlist_add_string(nvl, ZPOOL_HIST_HOST, utsname()->nodename);\n\n\tif (nvlist_exists(nvl, ZPOOL_HIST_CMD)) {\n\t\tzfs_dbgmsg(\"command: %s\",\n\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_CMD));\n\t} else if (nvlist_exists(nvl, ZPOOL_HIST_INT_NAME)) {\n\t\tif (nvlist_exists(nvl, ZPOOL_HIST_DSNAME)) {\n\t\t\tzfs_dbgmsg(\"txg %lld %s %s (id %llu) %s\",\n\t\t\t    (longlong_t)fnvlist_lookup_uint64(nvl,\n\t\t\t    ZPOOL_HIST_TXG),\n\t\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_INT_NAME),\n\t\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_DSNAME),\n\t\t\t    (u_longlong_t)fnvlist_lookup_uint64(nvl,\n\t\t\t    ZPOOL_HIST_DSID),\n\t\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_INT_STR));\n\t\t} else {\n\t\t\tzfs_dbgmsg(\"txg %lld %s %s\",\n\t\t\t    (longlong_t)fnvlist_lookup_uint64(nvl,\n\t\t\t    ZPOOL_HIST_TXG),\n\t\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_INT_NAME),\n\t\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_INT_STR));\n\t\t}\n\t\t \n\t\tspa_history_log_notify(spa, nvl);\n\t} else if (nvlist_exists(nvl, ZPOOL_HIST_IOCTL)) {\n\t\tzfs_dbgmsg(\"ioctl %s\",\n\t\t    fnvlist_lookup_string(nvl, ZPOOL_HIST_IOCTL));\n\t}\n\n\tVERIFY3U(nvlist_pack(nvl, &record_packed, &reclen, NV_ENCODE_NATIVE,\n\t    KM_SLEEP), ==, 0);\n\n\tmutex_enter(&spa->spa_history_lock);\n\n\t \n\tle_len = LE_64((uint64_t)reclen);\n\tret = spa_history_write(spa, &le_len, sizeof (le_len), shpp, tx);\n\tif (!ret)\n\t\tret = spa_history_write(spa, record_packed, reclen, shpp, tx);\n\n\t \n\tif (ret == 0 && shpp->sh_pool_create_len == 0 &&\n\t    nvlist_exists(nvl, ZPOOL_HIST_CMD)) {\n\t\tshpp->sh_pool_create_len = shpp->sh_bof = shpp->sh_eof;\n\t}\n\n\tmutex_exit(&spa->spa_history_lock);\n\tfnvlist_pack_free(record_packed, reclen);\n\tdmu_buf_rele(dbp, FTAG);\n\tfnvlist_free(nvl);\n}\n\n \nint\nspa_history_log(spa_t *spa, const char *msg)\n{\n\tint err;\n\tnvlist_t *nvl = fnvlist_alloc();\n\n\tfnvlist_add_string(nvl, ZPOOL_HIST_CMD, msg);\n\terr = spa_history_log_nvl(spa, nvl);\n\tfnvlist_free(nvl);\n\treturn (err);\n}\n\nint\nspa_history_log_nvl(spa_t *spa, nvlist_t *nvl)\n{\n\tint err = 0;\n\tdmu_tx_t *tx;\n\tnvlist_t *nvarg, *in_nvl = NULL;\n\n\tif (spa_version(spa) < SPA_VERSION_ZPOOL_HISTORY || !spa_writeable(spa))\n\t\treturn (SET_ERROR(EINVAL));\n\n\terr = nvlist_lookup_nvlist(nvl, ZPOOL_HIST_INPUT_NVL, &in_nvl);\n\tif (err == 0) {\n\t\t(void) nvlist_remove_all(in_nvl, ZPOOL_HIDDEN_ARGS);\n\t}\n\n\ttx = dmu_tx_create_dd(spa_get_dsl(spa)->dp_mos_dir);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (err);\n\t}\n\n\tVERIFY0(nvlist_dup(nvl, &nvarg, KM_SLEEP));\n\tif (spa_history_zone() != NULL) {\n\t\tfnvlist_add_string(nvarg, ZPOOL_HIST_ZONE,\n\t\t    spa_history_zone());\n\t}\n\tfnvlist_add_uint64(nvarg, ZPOOL_HIST_WHO, crgetruid(CRED()));\n\n\t \n\tfnvlist_add_uint64(nvarg, ZPOOL_HIST_TIME, gethrestime_sec());\n\n\t \n\tdsl_sync_task_nowait(spa_get_dsl(spa), spa_history_log_sync, nvarg, tx);\n\tdmu_tx_commit(tx);\n\n\t \n\treturn (err);\n}\n\n \nint\nspa_history_get(spa_t *spa, uint64_t *offp, uint64_t *len, char *buf)\n{\n\tobjset_t *mos = spa->spa_meta_objset;\n\tdmu_buf_t *dbp;\n\tuint64_t read_len, phys_read_off, phys_eof;\n\tuint64_t leftover = 0;\n\tspa_history_phys_t *shpp;\n\tint err;\n\n\t \n\tif (!spa->spa_history)\n\t\treturn (SET_ERROR(ENOENT));\n\n\t \n\tif (*offp == 0 && spa_writeable(spa))\n\t\ttxg_wait_synced(spa_get_dsl(spa), 0);\n\n\tif ((err = dmu_bonus_hold(mos, spa->spa_history, FTAG, &dbp)) != 0)\n\t\treturn (err);\n\tshpp = dbp->db_data;\n\n#ifdef ZFS_DEBUG\n\t{\n\t\tdmu_object_info_t doi;\n\t\tdmu_object_info_from_db(dbp, &doi);\n\t\tASSERT3U(doi.doi_bonus_type, ==, DMU_OT_SPA_HISTORY_OFFSETS);\n\t}\n#endif\n\n\tmutex_enter(&spa->spa_history_lock);\n\tphys_eof = spa_history_log_to_phys(shpp->sh_eof, shpp);\n\n\tif (*offp < shpp->sh_pool_create_len) {\n\t\t \n\t\tphys_read_off = *offp;\n\t\tread_len = MIN(*len, shpp->sh_pool_create_len -\n\t\t    phys_read_off);\n\t} else {\n\t\t \n\t\t*offp = MAX(*offp, shpp->sh_bof);\n\t\tphys_read_off = spa_history_log_to_phys(*offp, shpp);\n\n\t\t \n\t\tif (phys_read_off <= phys_eof) {\n\t\t\tread_len = MIN(*len, phys_eof - phys_read_off);\n\t\t} else {\n\t\t\tread_len = MIN(*len,\n\t\t\t    shpp->sh_phys_max_off - phys_read_off);\n\t\t\tif (phys_read_off + *len > shpp->sh_phys_max_off) {\n\t\t\t\tleftover = MIN(*len - read_len,\n\t\t\t\t    phys_eof - shpp->sh_pool_create_len);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\t*offp += read_len + leftover;\n\n\t \n\t*len = read_len + leftover;\n\n\tif (read_len == 0) {\n\t\tmutex_exit(&spa->spa_history_lock);\n\t\tdmu_buf_rele(dbp, FTAG);\n\t\treturn (0);\n\t}\n\n\terr = dmu_read(mos, spa->spa_history, phys_read_off, read_len, buf,\n\t    DMU_READ_PREFETCH);\n\tif (leftover && err == 0) {\n\t\terr = dmu_read(mos, spa->spa_history, shpp->sh_pool_create_len,\n\t\t    leftover, buf + read_len, DMU_READ_PREFETCH);\n\t}\n\tmutex_exit(&spa->spa_history_lock);\n\n\tdmu_buf_rele(dbp, FTAG);\n\treturn (err);\n}\n\n \nstatic void\nlog_internal(nvlist_t *nvl, const char *operation, spa_t *spa,\n    dmu_tx_t *tx, const char *fmt, va_list adx)\n{\n\tchar *msg;\n\n\t \n\tif (spa_is_initializing(spa) || !spa_writeable(spa)) {\n\t\tfnvlist_free(nvl);\n\t\treturn;\n\t}\n\n\tmsg = kmem_vasprintf(fmt, adx);\n\tfnvlist_add_string(nvl, ZPOOL_HIST_INT_STR, msg);\n\tkmem_strfree(msg);\n\n\tfnvlist_add_string(nvl, ZPOOL_HIST_INT_NAME, operation);\n\tfnvlist_add_uint64(nvl, ZPOOL_HIST_TXG, tx->tx_txg);\n\tfnvlist_add_uint64(nvl, ZPOOL_HIST_TIME, gethrestime_sec());\n\n\tif (dmu_tx_is_syncing(tx)) {\n\t\tspa_history_log_sync(nvl, tx);\n\t} else {\n\t\tdsl_sync_task_nowait(spa_get_dsl(spa),\n\t\t    spa_history_log_sync, nvl, tx);\n\t}\n\t \n}\n\nvoid\nspa_history_log_internal(spa_t *spa, const char *operation,\n    dmu_tx_t *tx, const char *fmt, ...)\n{\n\tdmu_tx_t *htx = tx;\n\tva_list adx;\n\n\t \n\tif (tx == NULL) {\n\t\thtx = dmu_tx_create_dd(spa_get_dsl(spa)->dp_mos_dir);\n\t\tif (dmu_tx_assign(htx, TXG_WAIT) != 0) {\n\t\t\tdmu_tx_abort(htx);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tva_start(adx, fmt);\n\tlog_internal(fnvlist_alloc(), operation, spa, htx, fmt, adx);\n\tva_end(adx);\n\n\t \n\tif (tx == NULL)\n\t\tdmu_tx_commit(htx);\n}\n\nvoid\nspa_history_log_internal_ds(dsl_dataset_t *ds, const char *operation,\n    dmu_tx_t *tx, const char *fmt, ...)\n{\n\tva_list adx;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\tnvlist_t *nvl = fnvlist_alloc();\n\n\tASSERT(tx != NULL);\n\n\tdsl_dataset_name(ds, namebuf);\n\tfnvlist_add_string(nvl, ZPOOL_HIST_DSNAME, namebuf);\n\tfnvlist_add_uint64(nvl, ZPOOL_HIST_DSID, ds->ds_object);\n\n\tva_start(adx, fmt);\n\tlog_internal(nvl, operation, dsl_dataset_get_spa(ds), tx, fmt, adx);\n\tva_end(adx);\n}\n\nvoid\nspa_history_log_internal_dd(dsl_dir_t *dd, const char *operation,\n    dmu_tx_t *tx, const char *fmt, ...)\n{\n\tva_list adx;\n\tchar namebuf[ZFS_MAX_DATASET_NAME_LEN];\n\tnvlist_t *nvl = fnvlist_alloc();\n\n\tASSERT(tx != NULL);\n\n\tdsl_dir_name(dd, namebuf);\n\tfnvlist_add_string(nvl, ZPOOL_HIST_DSNAME, namebuf);\n\tfnvlist_add_uint64(nvl, ZPOOL_HIST_DSID,\n\t    dsl_dir_phys(dd)->dd_head_dataset_obj);\n\n\tva_start(adx, fmt);\n\tlog_internal(nvl, operation, dd->dd_pool->dp_spa, tx, fmt, adx);\n\tva_end(adx);\n}\n\nvoid\nspa_history_log_version(spa_t *spa, const char *operation, dmu_tx_t *tx)\n{\n\tutsname_t *u = utsname();\n\n\tspa_history_log_internal(spa, operation, tx,\n\t    \"pool version %llu; software version %s; uts %s %s %s %s\",\n\t    (u_longlong_t)spa_version(spa), ZFS_META_GITREV,\n\t    u->nodename, u->release, u->version, u->machine);\n}\n\n#ifndef _KERNEL\nconst char *\nspa_history_zone(void)\n{\n\treturn (NULL);\n}\n#endif\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(spa_history_create_obj);\nEXPORT_SYMBOL(spa_history_get);\nEXPORT_SYMBOL(spa_history_log);\nEXPORT_SYMBOL(spa_history_log_internal);\nEXPORT_SYMBOL(spa_history_log_version);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}