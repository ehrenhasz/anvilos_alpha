{
  "module_name": "mmp.c",
  "hash_id": "58c2f3cf3673ebdbaeb78076a8032bee26a64eccf69a69b1a6a4f832149cde0c",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/mmp.c",
  "human_readable_source": " \n \n\n#include <sys/abd.h>\n#include <sys/mmp.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/time.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/zfs_context.h>\n#include <sys/callb.h>\n\n \n\n \nuint64_t zfs_multihost_interval = MMP_DEFAULT_INTERVAL;\n\n \nuint_t zfs_multihost_import_intervals = MMP_DEFAULT_IMPORT_INTERVALS;\n\n \nuint_t zfs_multihost_fail_intervals = MMP_DEFAULT_FAIL_INTERVALS;\n\nstatic const void *const mmp_tag = \"mmp_write_uberblock\";\nstatic __attribute__((noreturn)) void mmp_thread(void *arg);\n\nvoid\nmmp_init(spa_t *spa)\n{\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\n\tmutex_init(&mmp->mmp_thread_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&mmp->mmp_thread_cv, NULL, CV_DEFAULT, NULL);\n\tmutex_init(&mmp->mmp_io_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmmp->mmp_kstat_id = 1;\n}\n\nvoid\nmmp_fini(spa_t *spa)\n{\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\n\tmutex_destroy(&mmp->mmp_thread_lock);\n\tcv_destroy(&mmp->mmp_thread_cv);\n\tmutex_destroy(&mmp->mmp_io_lock);\n}\n\nstatic void\nmmp_thread_enter(mmp_thread_t *mmp, callb_cpr_t *cpr)\n{\n\tCALLB_CPR_INIT(cpr, &mmp->mmp_thread_lock, callb_generic_cpr, FTAG);\n\tmutex_enter(&mmp->mmp_thread_lock);\n}\n\nstatic void\nmmp_thread_exit(mmp_thread_t *mmp, kthread_t **mpp, callb_cpr_t *cpr)\n{\n\tASSERT(*mpp != NULL);\n\t*mpp = NULL;\n\tcv_broadcast(&mmp->mmp_thread_cv);\n\tCALLB_CPR_EXIT(cpr);\t\t \n}\n\nvoid\nmmp_thread_start(spa_t *spa)\n{\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\n\tif (spa_writeable(spa)) {\n\t\tmutex_enter(&mmp->mmp_thread_lock);\n\t\tif (!mmp->mmp_thread) {\n\t\t\tmmp->mmp_thread = thread_create(NULL, 0, mmp_thread,\n\t\t\t    spa, 0, &p0, TS_RUN, defclsyspri);\n\t\t\tzfs_dbgmsg(\"MMP thread started pool '%s' \"\n\t\t\t    \"gethrtime %llu\", spa_name(spa), gethrtime());\n\t\t}\n\t\tmutex_exit(&mmp->mmp_thread_lock);\n\t}\n}\n\nvoid\nmmp_thread_stop(spa_t *spa)\n{\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\n\tmutex_enter(&mmp->mmp_thread_lock);\n\tmmp->mmp_thread_exiting = 1;\n\tcv_broadcast(&mmp->mmp_thread_cv);\n\n\twhile (mmp->mmp_thread) {\n\t\tcv_wait(&mmp->mmp_thread_cv, &mmp->mmp_thread_lock);\n\t}\n\tmutex_exit(&mmp->mmp_thread_lock);\n\tzfs_dbgmsg(\"MMP thread stopped pool '%s' gethrtime %llu\",\n\t    spa_name(spa), gethrtime());\n\n\tASSERT(mmp->mmp_thread == NULL);\n\tmmp->mmp_thread_exiting = 0;\n}\n\ntypedef enum mmp_vdev_state_flag {\n\tMMP_FAIL_NOT_WRITABLE\t= (1 << 0),\n\tMMP_FAIL_WRITE_PENDING\t= (1 << 1),\n} mmp_vdev_state_flag_t;\n\n \n\nstatic int\nmmp_next_leaf(spa_t *spa)\n{\n\tvdev_t *leaf;\n\tvdev_t *starting_leaf;\n\tint fail_mask = 0;\n\n\tASSERT(MUTEX_HELD(&spa->spa_mmp.mmp_io_lock));\n\tASSERT(spa_config_held(spa, SCL_STATE, RW_READER));\n\tASSERT(list_link_active(&spa->spa_leaf_list.list_head) == B_TRUE);\n\tASSERT(!list_is_empty(&spa->spa_leaf_list));\n\n\tif (spa->spa_mmp.mmp_leaf_last_gen != spa->spa_leaf_list_gen) {\n\t\tspa->spa_mmp.mmp_last_leaf = list_head(&spa->spa_leaf_list);\n\t\tspa->spa_mmp.mmp_leaf_last_gen = spa->spa_leaf_list_gen;\n\t}\n\n\tleaf = spa->spa_mmp.mmp_last_leaf;\n\tif (leaf == NULL)\n\t\tleaf = list_head(&spa->spa_leaf_list);\n\tstarting_leaf = leaf;\n\n\tdo {\n\t\tleaf = list_next(&spa->spa_leaf_list, leaf);\n\t\tif (leaf == NULL) {\n\t\t\tleaf = list_head(&spa->spa_leaf_list);\n\t\t\tASSERT3P(leaf, !=, NULL);\n\t\t}\n\n\t\t \n\t\tif (!vdev_writeable(leaf) || leaf->vdev_offline ||\n\t\t    leaf->vdev_detached) {\n\t\t\tfail_mask |= MMP_FAIL_NOT_WRITABLE;\n\t\t} else if (leaf->vdev_ops == &vdev_draid_spare_ops) {\n\t\t\tcontinue;\n\t\t} else if (leaf->vdev_mmp_pending != 0) {\n\t\t\tfail_mask |= MMP_FAIL_WRITE_PENDING;\n\t\t} else {\n\t\t\tspa->spa_mmp.mmp_last_leaf = leaf;\n\t\t\treturn (0);\n\t\t}\n\t} while (leaf != starting_leaf);\n\n\tASSERT(fail_mask);\n\n\treturn (fail_mask);\n}\n\n \nstatic void\nmmp_delay_update(spa_t *spa, boolean_t write_completed)\n{\n\tmmp_thread_t *mts = &spa->spa_mmp;\n\thrtime_t delay = gethrtime() - mts->mmp_last_write;\n\n\tASSERT(MUTEX_HELD(&mts->mmp_io_lock));\n\n\tif (spa_multihost(spa) == B_FALSE) {\n\t\tmts->mmp_delay = 0;\n\t\treturn;\n\t}\n\n\tif (delay > mts->mmp_delay)\n\t\tmts->mmp_delay = delay;\n\n\tif (write_completed == B_FALSE)\n\t\treturn;\n\n\tmts->mmp_last_write = gethrtime();\n\n\t \n\tif (delay < mts->mmp_delay) {\n\t\thrtime_t min_delay =\n\t\t    MSEC2NSEC(MMP_INTERVAL_OK(zfs_multihost_interval)) /\n\t\t    MAX(1, vdev_count_leaves(spa));\n\t\tmts->mmp_delay = MAX(((delay + mts->mmp_delay * 127) / 128),\n\t\t    min_delay);\n\t}\n}\n\nstatic void\nmmp_write_done(zio_t *zio)\n{\n\tspa_t *spa = zio->io_spa;\n\tvdev_t *vd = zio->io_vd;\n\tmmp_thread_t *mts = zio->io_private;\n\n\tmutex_enter(&mts->mmp_io_lock);\n\tuint64_t mmp_kstat_id = vd->vdev_mmp_kstat_id;\n\thrtime_t mmp_write_duration = gethrtime() - vd->vdev_mmp_pending;\n\n\tmmp_delay_update(spa, (zio->io_error == 0));\n\n\tvd->vdev_mmp_pending = 0;\n\tvd->vdev_mmp_kstat_id = 0;\n\n\tmutex_exit(&mts->mmp_io_lock);\n\tspa_config_exit(spa, SCL_STATE, mmp_tag);\n\n\tspa_mmp_history_set(spa, mmp_kstat_id, zio->io_error,\n\t    mmp_write_duration);\n\n\tabd_free(zio->io_abd);\n}\n\n \nvoid\nmmp_update_uberblock(spa_t *spa, uberblock_t *ub)\n{\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\n\tmutex_enter(&mmp->mmp_io_lock);\n\tmmp->mmp_ub = *ub;\n\tmmp->mmp_seq = 1;\n\tmmp->mmp_ub.ub_timestamp = gethrestime_sec();\n\tmmp_delay_update(spa, B_TRUE);\n\tmutex_exit(&mmp->mmp_io_lock);\n}\n\n \nstatic void\nmmp_write_uberblock(spa_t *spa)\n{\n\tint flags = ZIO_FLAG_CONFIG_WRITER | ZIO_FLAG_CANFAIL;\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\tuberblock_t *ub;\n\tvdev_t *vd = NULL;\n\tint label, error;\n\tuint64_t offset;\n\n\thrtime_t lock_acquire_time = gethrtime();\n\tspa_config_enter_mmp(spa, SCL_STATE, mmp_tag, RW_READER);\n\tlock_acquire_time = gethrtime() - lock_acquire_time;\n\tif (lock_acquire_time > (MSEC2NSEC(MMP_MIN_INTERVAL) / 10))\n\t\tzfs_dbgmsg(\"MMP SCL_STATE acquisition pool '%s' took %llu ns \"\n\t\t    \"gethrtime %llu\", spa_name(spa), lock_acquire_time,\n\t\t    gethrtime());\n\n\tmutex_enter(&mmp->mmp_io_lock);\n\n\terror = mmp_next_leaf(spa);\n\n\t \n\n\tif (error) {\n\t\tmmp_delay_update(spa, B_FALSE);\n\t\tif (mmp->mmp_skip_error == error) {\n\t\t\tspa_mmp_history_set_skip(spa, mmp->mmp_kstat_id - 1);\n\t\t} else {\n\t\t\tmmp->mmp_skip_error = error;\n\t\t\tspa_mmp_history_add(spa, mmp->mmp_ub.ub_txg,\n\t\t\t    gethrestime_sec(), mmp->mmp_delay, NULL, 0,\n\t\t\t    mmp->mmp_kstat_id++, error);\n\t\t\tzfs_dbgmsg(\"MMP error choosing leaf pool '%s' \"\n\t\t\t    \"gethrtime %llu fail_mask %#x\", spa_name(spa),\n\t\t\t    gethrtime(), error);\n\t\t}\n\t\tmutex_exit(&mmp->mmp_io_lock);\n\t\tspa_config_exit(spa, SCL_STATE, mmp_tag);\n\t\treturn;\n\t}\n\n\tvd = spa->spa_mmp.mmp_last_leaf;\n\tif (mmp->mmp_skip_error != 0) {\n\t\tmmp->mmp_skip_error = 0;\n\t\tzfs_dbgmsg(\"MMP write after skipping due to unavailable \"\n\t\t    \"leaves, pool '%s' gethrtime %llu leaf %llu\",\n\t\t    spa_name(spa), (u_longlong_t)gethrtime(),\n\t\t    (u_longlong_t)vd->vdev_guid);\n\t}\n\n\tif (mmp->mmp_zio_root == NULL)\n\t\tmmp->mmp_zio_root = zio_root(spa, NULL, NULL,\n\t\t    flags | ZIO_FLAG_GODFATHER);\n\n\tif (mmp->mmp_ub.ub_timestamp != gethrestime_sec()) {\n\t\t \n\t\tmmp->mmp_ub.ub_timestamp = gethrestime_sec();\n\t\tmmp->mmp_seq = 1;\n\t}\n\n\tub = &mmp->mmp_ub;\n\tub->ub_mmp_magic = MMP_MAGIC;\n\tub->ub_mmp_delay = mmp->mmp_delay;\n\tub->ub_mmp_config = MMP_SEQ_SET(mmp->mmp_seq) |\n\t    MMP_INTERVAL_SET(MMP_INTERVAL_OK(zfs_multihost_interval)) |\n\t    MMP_FAIL_INT_SET(MMP_FAIL_INTVS_OK(\n\t    zfs_multihost_fail_intervals));\n\tvd->vdev_mmp_pending = gethrtime();\n\tvd->vdev_mmp_kstat_id = mmp->mmp_kstat_id;\n\n\tzio_t *zio  = zio_null(mmp->mmp_zio_root, spa, NULL, NULL, NULL, flags);\n\tabd_t *ub_abd = abd_alloc_for_io(VDEV_UBERBLOCK_SIZE(vd), B_TRUE);\n\tabd_zero(ub_abd, VDEV_UBERBLOCK_SIZE(vd));\n\tabd_copy_from_buf(ub_abd, ub, sizeof (uberblock_t));\n\n\tmmp->mmp_seq++;\n\tmmp->mmp_kstat_id++;\n\tmutex_exit(&mmp->mmp_io_lock);\n\n\toffset = VDEV_UBERBLOCK_OFFSET(vd, VDEV_UBERBLOCK_COUNT(vd) -\n\t    MMP_BLOCKS_PER_LABEL + random_in_range(MMP_BLOCKS_PER_LABEL));\n\n\tlabel = random_in_range(VDEV_LABELS);\n\tvdev_label_write(zio, vd, label, ub_abd, offset,\n\t    VDEV_UBERBLOCK_SIZE(vd), mmp_write_done, mmp,\n\t    flags | ZIO_FLAG_DONT_PROPAGATE);\n\n\t(void) spa_mmp_history_add(spa, ub->ub_txg, ub->ub_timestamp,\n\t    ub->ub_mmp_delay, vd, label, vd->vdev_mmp_kstat_id, 0);\n\n\tzio_nowait(zio);\n}\n\nstatic __attribute__((noreturn)) void\nmmp_thread(void *arg)\n{\n\tspa_t *spa = (spa_t *)arg;\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\tboolean_t suspended = spa_suspended(spa);\n\tboolean_t multihost = spa_multihost(spa);\n\tuint64_t mmp_interval = MSEC2NSEC(MMP_INTERVAL_OK(\n\t    zfs_multihost_interval));\n\tuint32_t mmp_fail_intervals = MMP_FAIL_INTVS_OK(\n\t    zfs_multihost_fail_intervals);\n\thrtime_t mmp_fail_ns = mmp_fail_intervals * mmp_interval;\n\tboolean_t last_spa_suspended;\n\tboolean_t last_spa_multihost;\n\tuint64_t last_mmp_interval;\n\tuint32_t last_mmp_fail_intervals;\n\thrtime_t last_mmp_fail_ns;\n\tcallb_cpr_t cpr;\n\tint skip_wait = 0;\n\n\tmmp_thread_enter(mmp, &cpr);\n\n\t \n\n\tmutex_enter(&mmp->mmp_io_lock);\n\tmmp->mmp_last_write = gethrtime();\n\tmmp->mmp_delay = MSEC2NSEC(MMP_INTERVAL_OK(zfs_multihost_interval));\n\tmutex_exit(&mmp->mmp_io_lock);\n\n\twhile (!mmp->mmp_thread_exiting) {\n\t\thrtime_t next_time = gethrtime() +\n\t\t    MSEC2NSEC(MMP_DEFAULT_INTERVAL);\n\t\tint leaves = MAX(vdev_count_leaves(spa), 1);\n\n\t\t \n\n\t\tlast_spa_suspended = suspended;\n\t\tlast_spa_multihost = multihost;\n\t\tsuspended = spa_suspended(spa);\n\t\tmultihost = spa_multihost(spa);\n\n\t\tlast_mmp_interval = mmp_interval;\n\t\tlast_mmp_fail_intervals = mmp_fail_intervals;\n\t\tlast_mmp_fail_ns = mmp_fail_ns;\n\t\tmmp_interval = MSEC2NSEC(MMP_INTERVAL_OK(\n\t\t    zfs_multihost_interval));\n\t\tmmp_fail_intervals = MMP_FAIL_INTVS_OK(\n\t\t    zfs_multihost_fail_intervals);\n\n\t\t \n\t\tif (mmp_fail_intervals * mmp_interval < mmp_fail_ns) {\n\t\t\tmmp_fail_ns = (mmp_fail_ns * 31 +\n\t\t\t    mmp_fail_intervals * mmp_interval) / 32;\n\t\t} else {\n\t\t\tmmp_fail_ns = mmp_fail_intervals *\n\t\t\t    mmp_interval;\n\t\t}\n\n\t\tif (mmp_interval != last_mmp_interval ||\n\t\t    mmp_fail_intervals != last_mmp_fail_intervals) {\n\t\t\t \n\t\t\tskip_wait += leaves;\n\t\t}\n\n\t\tif (multihost)\n\t\t\tnext_time = gethrtime() + mmp_interval / leaves;\n\n\t\tif (mmp_fail_ns != last_mmp_fail_ns) {\n\t\t\tzfs_dbgmsg(\"MMP interval change pool '%s' \"\n\t\t\t    \"gethrtime %llu last_mmp_interval %llu \"\n\t\t\t    \"mmp_interval %llu last_mmp_fail_intervals %u \"\n\t\t\t    \"mmp_fail_intervals %u mmp_fail_ns %llu \"\n\t\t\t    \"skip_wait %d leaves %d next_time %llu\",\n\t\t\t    spa_name(spa), (u_longlong_t)gethrtime(),\n\t\t\t    (u_longlong_t)last_mmp_interval,\n\t\t\t    (u_longlong_t)mmp_interval, last_mmp_fail_intervals,\n\t\t\t    mmp_fail_intervals, (u_longlong_t)mmp_fail_ns,\n\t\t\t    skip_wait, leaves, (u_longlong_t)next_time);\n\t\t}\n\n\t\t \n\t\tif ((!last_spa_multihost && multihost) ||\n\t\t    (last_spa_suspended && !suspended)) {\n\t\t\tzfs_dbgmsg(\"MMP state change pool '%s': gethrtime %llu \"\n\t\t\t    \"last_spa_multihost %u multihost %u \"\n\t\t\t    \"last_spa_suspended %u suspended %u\",\n\t\t\t    spa_name(spa), (u_longlong_t)gethrtime(),\n\t\t\t    last_spa_multihost, multihost, last_spa_suspended,\n\t\t\t    suspended);\n\t\t\tmutex_enter(&mmp->mmp_io_lock);\n\t\t\tmmp->mmp_last_write = gethrtime();\n\t\t\tmmp->mmp_delay = mmp_interval;\n\t\t\tmutex_exit(&mmp->mmp_io_lock);\n\t\t}\n\n\t\t \n\t\tif (last_spa_multihost && !multihost) {\n\t\t\tmutex_enter(&mmp->mmp_io_lock);\n\t\t\tmmp->mmp_delay = 0;\n\t\t\tmutex_exit(&mmp->mmp_io_lock);\n\t\t}\n\n\t\t \n\t\tif (multihost && !suspended && mmp_fail_intervals &&\n\t\t    (gethrtime() - mmp->mmp_last_write) > mmp_fail_ns) {\n\t\t\tzfs_dbgmsg(\"MMP suspending pool '%s': gethrtime %llu \"\n\t\t\t    \"mmp_last_write %llu mmp_interval %llu \"\n\t\t\t    \"mmp_fail_intervals %llu mmp_fail_ns %llu\",\n\t\t\t    spa_name(spa), (u_longlong_t)gethrtime(),\n\t\t\t    (u_longlong_t)mmp->mmp_last_write,\n\t\t\t    (u_longlong_t)mmp_interval,\n\t\t\t    (u_longlong_t)mmp_fail_intervals,\n\t\t\t    (u_longlong_t)mmp_fail_ns);\n\t\t\tcmn_err(CE_WARN, \"MMP writes to pool '%s' have not \"\n\t\t\t    \"succeeded in over %llu ms; suspending pool. \"\n\t\t\t    \"Hrtime %llu\",\n\t\t\t    spa_name(spa),\n\t\t\t    NSEC2MSEC(gethrtime() - mmp->mmp_last_write),\n\t\t\t    gethrtime());\n\t\t\tzio_suspend(spa, NULL, ZIO_SUSPEND_MMP);\n\t\t}\n\n\t\tif (multihost && !suspended)\n\t\t\tmmp_write_uberblock(spa);\n\n\t\tif (skip_wait > 0) {\n\t\t\tnext_time = gethrtime() + MSEC2NSEC(MMP_MIN_INTERVAL) /\n\t\t\t    leaves;\n\t\t\tskip_wait--;\n\t\t}\n\n\t\tCALLB_CPR_SAFE_BEGIN(&cpr);\n\t\t(void) cv_timedwait_idle_hires(&mmp->mmp_thread_cv,\n\t\t    &mmp->mmp_thread_lock, next_time, USEC2NSEC(100),\n\t\t    CALLOUT_FLAG_ABSOLUTE);\n\t\tCALLB_CPR_SAFE_END(&cpr, &mmp->mmp_thread_lock);\n\t}\n\n\t \n\tzio_wait(mmp->mmp_zio_root);\n\n\tmmp->mmp_zio_root = NULL;\n\tmmp_thread_exit(mmp, &mmp->mmp_thread, &cpr);\n\n\tthread_exit();\n}\n\n \nstatic void\nmmp_signal_thread(spa_t *spa)\n{\n\tmmp_thread_t *mmp = &spa->spa_mmp;\n\n\tmutex_enter(&mmp->mmp_thread_lock);\n\tif (mmp->mmp_thread)\n\t\tcv_broadcast(&mmp->mmp_thread_cv);\n\tmutex_exit(&mmp->mmp_thread_lock);\n}\n\nvoid\nmmp_signal_all_threads(void)\n{\n\tspa_t *spa = NULL;\n\n\tmutex_enter(&spa_namespace_lock);\n\twhile ((spa = spa_next(spa))) {\n\t\tif (spa->spa_state == POOL_STATE_ACTIVE)\n\t\t\tmmp_signal_thread(spa);\n\t}\n\tmutex_exit(&spa_namespace_lock);\n}\n\n \nZFS_MODULE_PARAM_CALL(zfs_multihost, zfs_multihost_, interval,\n\tparam_set_multihost_interval, spl_param_get_u64, ZMOD_RW,\n\t\"Milliseconds between mmp writes to each leaf\");\n \n\nZFS_MODULE_PARAM(zfs_multihost, zfs_multihost_, fail_intervals, UINT, ZMOD_RW,\n\t\"Max allowed period without a successful mmp write\");\n\nZFS_MODULE_PARAM(zfs_multihost, zfs_multihost_, import_intervals, UINT, ZMOD_RW,\n\t\"Number of zfs_multihost_interval periods to wait for activity\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}