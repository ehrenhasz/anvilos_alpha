{
  "module_name": "zrlock.c",
  "hash_id": "4d089c94d41d3c375bb71dae6bc6d7813f237f56cfa83481ba3a209d94619b56",
  "original_prompt": "Ingested from zfs-2.2.2/module/zfs/zrlock.c",
  "human_readable_source": " \n \n\n \n#include <sys/zrlock.h>\n#include <sys/trace_zfs.h>\n\n \n#define\tZRL_LOCKED\t-1\n#define\tZRL_DESTROYED\t-2\n\nvoid\nzrl_init(zrlock_t *zrl)\n{\n\tmutex_init(&zrl->zr_mtx, NULL, MUTEX_DEFAULT, NULL);\n\tzrl->zr_refcount = 0;\n\tcv_init(&zrl->zr_cv, NULL, CV_DEFAULT, NULL);\n#ifdef\tZFS_DEBUG\n\tzrl->zr_owner = NULL;\n\tzrl->zr_caller = NULL;\n#endif\n}\n\nvoid\nzrl_destroy(zrlock_t *zrl)\n{\n\tASSERT0(zrl->zr_refcount);\n\n\tmutex_destroy(&zrl->zr_mtx);\n\tzrl->zr_refcount = ZRL_DESTROYED;\n\tcv_destroy(&zrl->zr_cv);\n}\n\nvoid\nzrl_add_impl(zrlock_t *zrl, const char *zc)\n{\n\tfor (;;) {\n\t\tuint32_t n = (uint32_t)zrl->zr_refcount;\n\t\twhile (n != ZRL_LOCKED) {\n\t\t\tuint32_t cas = atomic_cas_32(\n\t\t\t    (uint32_t *)&zrl->zr_refcount, n, n + 1);\n\t\t\tif (cas == n) {\n\t\t\t\tASSERT3S((int32_t)n, >=, 0);\n#ifdef\tZFS_DEBUG\n\t\t\t\tif (zrl->zr_owner == curthread) {\n\t\t\t\t\tDTRACE_PROBE3(zrlock__reentry,\n\t\t\t\t\t    zrlock_t *, zrl,\n\t\t\t\t\t    kthread_t *, curthread,\n\t\t\t\t\t    uint32_t, n);\n\t\t\t\t}\n\t\t\t\tzrl->zr_owner = curthread;\n\t\t\t\tzrl->zr_caller = zc;\n#endif\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tn = cas;\n\t\t}\n\n\t\tmutex_enter(&zrl->zr_mtx);\n\t\twhile (zrl->zr_refcount == ZRL_LOCKED) {\n\t\t\tcv_wait(&zrl->zr_cv, &zrl->zr_mtx);\n\t\t}\n\t\tmutex_exit(&zrl->zr_mtx);\n\t}\n}\n\nvoid\nzrl_remove(zrlock_t *zrl)\n{\n#ifdef\tZFS_DEBUG\n\tif (zrl->zr_owner == curthread) {\n\t\tzrl->zr_owner = NULL;\n\t\tzrl->zr_caller = NULL;\n\t}\n\tint32_t n = atomic_dec_32_nv((uint32_t *)&zrl->zr_refcount);\n\tASSERT3S(n, >=, 0);\n#else\n\tatomic_dec_32((uint32_t *)&zrl->zr_refcount);\n#endif\n}\n\nint\nzrl_tryenter(zrlock_t *zrl)\n{\n\tuint32_t n = (uint32_t)zrl->zr_refcount;\n\n\tif (n == 0) {\n\t\tuint32_t cas = atomic_cas_32(\n\t\t    (uint32_t *)&zrl->zr_refcount, 0, ZRL_LOCKED);\n\t\tif (cas == 0) {\n#ifdef\tZFS_DEBUG\n\t\t\tASSERT3P(zrl->zr_owner, ==, NULL);\n\t\t\tzrl->zr_owner = curthread;\n#endif\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tASSERT3S((int32_t)n, >, ZRL_DESTROYED);\n\n\treturn (0);\n}\n\nvoid\nzrl_exit(zrlock_t *zrl)\n{\n\tASSERT3S(zrl->zr_refcount, ==, ZRL_LOCKED);\n\n\tmutex_enter(&zrl->zr_mtx);\n#ifdef\tZFS_DEBUG\n\tASSERT3P(zrl->zr_owner, ==, curthread);\n\tzrl->zr_owner = NULL;\n\tmembar_producer();\t \n#endif\n\tzrl->zr_refcount = 0;\n\tcv_broadcast(&zrl->zr_cv);\n\tmutex_exit(&zrl->zr_mtx);\n}\n\nint\nzrl_is_zero(zrlock_t *zrl)\n{\n\tASSERT3S(zrl->zr_refcount, >, ZRL_DESTROYED);\n\n\treturn (zrl->zr_refcount <= 0);\n}\n\nint\nzrl_is_locked(zrlock_t *zrl)\n{\n\tASSERT3S(zrl->zr_refcount, >, ZRL_DESTROYED);\n\n\treturn (zrl->zr_refcount == ZRL_LOCKED);\n}\n\n#ifdef\tZFS_DEBUG\nkthread_t *\nzrl_owner(zrlock_t *zrl)\n{\n\treturn (zrl->zr_owner);\n}\n#endif\n\n#if defined(_KERNEL)\n\nEXPORT_SYMBOL(zrl_add_impl);\nEXPORT_SYMBOL(zrl_remove);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}