{
  "module_name": "zpl_file.c",
  "hash_id": "5134c42c51d8ea2bfd878186ac258789f3828361390ad6c65150289eb693a351",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_file.c",
  "human_readable_source": " \n \n\n\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n#include <linux/fs.h>\n#include <sys/file.h>\n#include <sys/dmu_objset.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_project.h>\n#if defined(HAVE_VFS_SET_PAGE_DIRTY_NOBUFFERS) || \\\n    defined(HAVE_VFS_FILEMAP_DIRTY_FOLIO)\n#include <linux/pagemap.h>\n#endif\n#ifdef HAVE_FILE_FADVISE\n#include <linux/fadvise.h>\n#endif\n#ifdef HAVE_VFS_FILEMAP_DIRTY_FOLIO\n#include <linux/writeback.h>\n#endif\n\n \nstatic unsigned int zfs_fallocate_reserve_percent = 110;\n\nstatic int\nzpl_open(struct inode *ip, struct file *filp)\n{\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\terror = generic_file_open(ip, filp);\n\tif (error)\n\t\treturn (error);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_open(ip, filp->f_mode, filp->f_flags, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_release(struct inode *ip, struct file *filp)\n{\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\tcookie = spl_fstrans_mark();\n\tif (ITOZ(ip)->z_atime_dirty)\n\t\tzfs_mark_inode_dirty(ip);\n\n\tcrhold(cr);\n\terror = -zfs_close(ip, filp->f_flags, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_iterate(struct file *filp, zpl_dir_context_t *ctx)\n{\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_readdir(file_inode(filp), ctx, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#if !defined(HAVE_VFS_ITERATE) && !defined(HAVE_VFS_ITERATE_SHARED)\nstatic int\nzpl_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tzpl_dir_context_t ctx =\n\t    ZPL_DIR_CONTEXT_INIT(dirent, filldir, filp->f_pos);\n\tint error;\n\n\terror = zpl_iterate(filp, &ctx);\n\tfilp->f_pos = ctx.pos;\n\n\treturn (error);\n}\n#endif  \n\n#if defined(HAVE_FSYNC_WITHOUT_DENTRY)\n \nstatic int\nzpl_fsync(struct file *filp, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_fsync(ITOZ(inode), datasync, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#ifdef HAVE_FILE_AIO_FSYNC\nstatic int\nzpl_aio_fsync(struct kiocb *kiocb, int datasync)\n{\n\treturn (zpl_fsync(kiocb->ki_filp, datasync));\n}\n#endif\n\n#elif defined(HAVE_FSYNC_RANGE)\n \nstatic int\nzpl_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tznode_t *zp = ITOZ(inode);\n\tzfsvfs_t *zfsvfs = ITOZSB(inode);\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\t \n\tatomic_inc_32(&zp->z_sync_writes_cnt);\n\t \n\tif (atomic_load_32(&zp->z_async_writes_cnt) > 0) {\n\t\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0) {\n\t\t\tatomic_dec_32(&zp->z_sync_writes_cnt);\n\t\t\treturn (error);\n\t\t}\n\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\t\tzpl_exit(zfsvfs, FTAG);\n\t}\n\n\terror = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\n\t \n\tatomic_dec_32(&zp->z_sync_writes_cnt);\n\n\tif (error)\n\t\treturn (error);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_fsync(zp, datasync, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#ifdef HAVE_FILE_AIO_FSYNC\nstatic int\nzpl_aio_fsync(struct kiocb *kiocb, int datasync)\n{\n\treturn (zpl_fsync(kiocb->ki_filp, kiocb->ki_pos, -1, datasync));\n}\n#endif\n\n#else\n#error \"Unsupported fops->fsync() implementation\"\n#endif\n\nstatic inline int\nzfs_io_flags(struct kiocb *kiocb)\n{\n\tint flags = 0;\n\n#if defined(IOCB_DSYNC)\n\tif (kiocb->ki_flags & IOCB_DSYNC)\n\t\tflags |= O_DSYNC;\n#endif\n#if defined(IOCB_SYNC)\n\tif (kiocb->ki_flags & IOCB_SYNC)\n\t\tflags |= O_SYNC;\n#endif\n#if defined(IOCB_APPEND)\n\tif (kiocb->ki_flags & IOCB_APPEND)\n\t\tflags |= O_APPEND;\n#endif\n#if defined(IOCB_DIRECT)\n\tif (kiocb->ki_flags & IOCB_DIRECT)\n\t\tflags |= O_DIRECT;\n#endif\n\treturn (flags);\n}\n\n \nstatic inline void\nzpl_file_accessed(struct file *filp)\n{\n\tstruct inode *ip = filp->f_mapping->host;\n\n\tif (!IS_NOATIME(ip) && ITOZSB(ip)->z_relatime) {\n\t\tif (zfs_relatime_need_update(ip))\n\t\t\tfile_accessed(filp);\n\t} else {\n\t\tfile_accessed(filp);\n\t}\n}\n\n#if defined(HAVE_VFS_RW_ITERATE)\n\n \nstatic void\nzpl_uio_init(zfs_uio_t *uio, struct kiocb *kiocb, struct iov_iter *to,\n    loff_t pos, ssize_t count, size_t skip)\n{\n#if defined(HAVE_VFS_IOV_ITER)\n\tzfs_uio_iov_iter_init(uio, to, pos, count, skip);\n#else\n\tzfs_uio_iovec_init(uio, zfs_uio_iter_iov(to), to->nr_segs, pos,\n\t    zfs_uio_iov_iter_type(to) & ITER_KVEC ?\n\t    UIO_SYSSPACE : UIO_USERSPACE,\n\t    count, skip);\n#endif\n}\n\nstatic ssize_t\nzpl_iter_read(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tstruct file *filp = kiocb->ki_filp;\n\tssize_t count = iov_iter_count(to);\n\tzfs_uio_t uio;\n\n\tzpl_uio_init(&uio, kiocb, to, kiocb->ki_pos, count, 0);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\n\tint error = -zfs_read(ITOZ(filp->f_mapping->host), &uio,\n\t    filp->f_flags | zfs_io_flags(kiocb), cr);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error < 0)\n\t\treturn (error);\n\n\tssize_t read = count - uio.uio_resid;\n\tkiocb->ki_pos += read;\n\n\tzpl_file_accessed(filp);\n\n\treturn (read);\n}\n\nstatic inline ssize_t\nzpl_generic_write_checks(struct kiocb *kiocb, struct iov_iter *from,\n    size_t *countp)\n{\n#ifdef HAVE_GENERIC_WRITE_CHECKS_KIOCB\n\tssize_t ret = generic_write_checks(kiocb, from);\n\tif (ret <= 0)\n\t\treturn (ret);\n\n\t*countp = ret;\n#else\n\tstruct file *file = kiocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *ip = mapping->host;\n\tint isblk = S_ISBLK(ip->i_mode);\n\n\t*countp = iov_iter_count(from);\n\tssize_t ret = generic_write_checks(file, &kiocb->ki_pos, countp, isblk);\n\tif (ret)\n\t\treturn (ret);\n#endif\n\n\treturn (0);\n}\n\nstatic ssize_t\nzpl_iter_write(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tstruct file *filp = kiocb->ki_filp;\n\tstruct inode *ip = filp->f_mapping->host;\n\tzfs_uio_t uio;\n\tsize_t count = 0;\n\tssize_t ret;\n\n\tret = zpl_generic_write_checks(kiocb, from, &count);\n\tif (ret)\n\t\treturn (ret);\n\n\tzpl_uio_init(&uio, kiocb, from, kiocb->ki_pos, count, from->iov_offset);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\n\tint error = -zfs_write(ITOZ(ip), &uio,\n\t    filp->f_flags | zfs_io_flags(kiocb), cr);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error < 0)\n\t\treturn (error);\n\n\tssize_t wrote = count - uio.uio_resid;\n\tkiocb->ki_pos += wrote;\n\n\treturn (wrote);\n}\n\n#else  \n\nstatic ssize_t\nzpl_aio_read(struct kiocb *kiocb, const struct iovec *iov,\n    unsigned long nr_segs, loff_t pos)\n{\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tstruct file *filp = kiocb->ki_filp;\n\tsize_t count;\n\tssize_t ret;\n\n\tret = generic_segment_checks(iov, &nr_segs, &count, VERIFY_WRITE);\n\tif (ret)\n\t\treturn (ret);\n\n\tzfs_uio_t uio;\n\tzfs_uio_iovec_init(&uio, iov, nr_segs, kiocb->ki_pos, UIO_USERSPACE,\n\t    count, 0);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\n\tint error = -zfs_read(ITOZ(filp->f_mapping->host), &uio,\n\t    filp->f_flags | zfs_io_flags(kiocb), cr);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error < 0)\n\t\treturn (error);\n\n\tssize_t read = count - uio.uio_resid;\n\tkiocb->ki_pos += read;\n\n\tzpl_file_accessed(filp);\n\n\treturn (read);\n}\n\nstatic ssize_t\nzpl_aio_write(struct kiocb *kiocb, const struct iovec *iov,\n    unsigned long nr_segs, loff_t pos)\n{\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tstruct file *filp = kiocb->ki_filp;\n\tstruct inode *ip = filp->f_mapping->host;\n\tsize_t count;\n\tssize_t ret;\n\n\tret = generic_segment_checks(iov, &nr_segs, &count, VERIFY_READ);\n\tif (ret)\n\t\treturn (ret);\n\n\tret = generic_write_checks(filp, &pos, &count, S_ISBLK(ip->i_mode));\n\tif (ret)\n\t\treturn (ret);\n\n\tkiocb->ki_pos = pos;\n\n\tzfs_uio_t uio;\n\tzfs_uio_iovec_init(&uio, iov, nr_segs, kiocb->ki_pos, UIO_USERSPACE,\n\t    count, 0);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\n\tint error = -zfs_write(ITOZ(ip), &uio,\n\t    filp->f_flags | zfs_io_flags(kiocb), cr);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error < 0)\n\t\treturn (error);\n\n\tssize_t wrote = count - uio.uio_resid;\n\tkiocb->ki_pos += wrote;\n\n\treturn (wrote);\n}\n#endif  \n\n#if defined(HAVE_VFS_RW_ITERATE)\nstatic ssize_t\nzpl_direct_IO_impl(int rw, struct kiocb *kiocb, struct iov_iter *iter)\n{\n\tif (rw == WRITE)\n\t\treturn (zpl_iter_write(kiocb, iter));\n\telse\n\t\treturn (zpl_iter_read(kiocb, iter));\n}\n#if defined(HAVE_VFS_DIRECT_IO_ITER)\nstatic ssize_t\nzpl_direct_IO(struct kiocb *kiocb, struct iov_iter *iter)\n{\n\treturn (zpl_direct_IO_impl(iov_iter_rw(iter), kiocb, iter));\n}\n#elif defined(HAVE_VFS_DIRECT_IO_ITER_OFFSET)\nstatic ssize_t\nzpl_direct_IO(struct kiocb *kiocb, struct iov_iter *iter, loff_t pos)\n{\n\tASSERT3S(pos, ==, kiocb->ki_pos);\n\treturn (zpl_direct_IO_impl(iov_iter_rw(iter), kiocb, iter));\n}\n#elif defined(HAVE_VFS_DIRECT_IO_ITER_RW_OFFSET)\nstatic ssize_t\nzpl_direct_IO(int rw, struct kiocb *kiocb, struct iov_iter *iter, loff_t pos)\n{\n\tASSERT3S(pos, ==, kiocb->ki_pos);\n\treturn (zpl_direct_IO_impl(rw, kiocb, iter));\n}\n#else\n#error \"Unknown direct IO interface\"\n#endif\n\n#else  \n\n#if defined(HAVE_VFS_DIRECT_IO_IOVEC)\nstatic ssize_t\nzpl_direct_IO(int rw, struct kiocb *kiocb, const struct iovec *iov,\n    loff_t pos, unsigned long nr_segs)\n{\n\tif (rw == WRITE)\n\t\treturn (zpl_aio_write(kiocb, iov, nr_segs, pos));\n\telse\n\t\treturn (zpl_aio_read(kiocb, iov, nr_segs, pos));\n}\n#elif defined(HAVE_VFS_DIRECT_IO_ITER_RW_OFFSET)\nstatic ssize_t\nzpl_direct_IO(int rw, struct kiocb *kiocb, struct iov_iter *iter, loff_t pos)\n{\n\tconst struct iovec *iovp = iov_iter_iovec(iter);\n\tunsigned long nr_segs = iter->nr_segs;\n\n\tASSERT3S(pos, ==, kiocb->ki_pos);\n\tif (rw == WRITE)\n\t\treturn (zpl_aio_write(kiocb, iovp, nr_segs, pos));\n\telse\n\t\treturn (zpl_aio_read(kiocb, iovp, nr_segs, pos));\n}\n#else\n#error \"Unknown direct IO interface\"\n#endif\n\n#endif  \n\nstatic loff_t\nzpl_llseek(struct file *filp, loff_t offset, int whence)\n{\n#if defined(SEEK_HOLE) && defined(SEEK_DATA)\n\tfstrans_cookie_t cookie;\n\n\tif (whence == SEEK_DATA || whence == SEEK_HOLE) {\n\t\tstruct inode *ip = filp->f_mapping->host;\n\t\tloff_t maxbytes = ip->i_sb->s_maxbytes;\n\t\tloff_t error;\n\n\t\tspl_inode_lock_shared(ip);\n\t\tcookie = spl_fstrans_mark();\n\t\terror = -zfs_holey(ITOZ(ip), whence, &offset);\n\t\tspl_fstrans_unmark(cookie);\n\t\tif (error == 0)\n\t\t\terror = lseek_execute(filp, ip, offset, maxbytes);\n\t\tspl_inode_unlock_shared(ip);\n\n\t\treturn (error);\n\t}\n#endif  \n\n\treturn (generic_file_llseek(filp, offset, whence));\n}\n\n \nstatic int\nzpl_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct inode *ip = filp->f_mapping->host;\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_map(ip, vma->vm_pgoff, (caddr_t *)vma->vm_start,\n\t    (size_t)(vma->vm_end - vma->vm_start), vma->vm_flags);\n\tspl_fstrans_unmark(cookie);\n\tif (error)\n\t\treturn (error);\n\n\terror = generic_file_mmap(filp, vma);\n\tif (error)\n\t\treturn (error);\n\n#if !defined(HAVE_FILEMAP_RANGE_HAS_PAGE)\n\tznode_t *zp = ITOZ(ip);\n\tmutex_enter(&zp->z_lock);\n\tzp->z_is_mapped = B_TRUE;\n\tmutex_exit(&zp->z_lock);\n#endif\n\n\treturn (error);\n}\n\n \nstatic inline int\nzpl_readpage_common(struct page *pp)\n{\n\tfstrans_cookie_t cookie;\n\n\tASSERT(PageLocked(pp));\n\n\tcookie = spl_fstrans_mark();\n\tint error = -zfs_getpage(pp->mapping->host, pp);\n\tspl_fstrans_unmark(cookie);\n\n\tunlock_page(pp);\n\n\treturn (error);\n}\n\n#ifdef HAVE_VFS_READ_FOLIO\nstatic int\nzpl_read_folio(struct file *filp, struct folio *folio)\n{\n\treturn (zpl_readpage_common(&folio->page));\n}\n#else\nstatic int\nzpl_readpage(struct file *filp, struct page *pp)\n{\n\treturn (zpl_readpage_common(pp));\n}\n#endif\n\nstatic int\nzpl_readpage_filler(void *data, struct page *pp)\n{\n\treturn (zpl_readpage_common(pp));\n}\n\n \n#ifdef HAVE_VFS_READPAGES\nstatic int\nzpl_readpages(struct file *filp, struct address_space *mapping,\n    struct list_head *pages, unsigned nr_pages)\n{\n\treturn (read_cache_pages(mapping, pages, zpl_readpage_filler, NULL));\n}\n#else\nstatic void\nzpl_readahead(struct readahead_control *ractl)\n{\n\tstruct page *page;\n\n\twhile ((page = readahead_page(ractl)) != NULL) {\n\t\tint ret;\n\n\t\tret = zpl_readpage_filler(NULL, page);\n\t\tput_page(page);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n}\n#endif\n\nstatic int\nzpl_putpage(struct page *pp, struct writeback_control *wbc, void *data)\n{\n\tboolean_t *for_sync = data;\n\tfstrans_cookie_t cookie;\n\n\tASSERT(PageLocked(pp));\n\tASSERT(!PageWriteback(pp));\n\n\tcookie = spl_fstrans_mark();\n\t(void) zfs_putpage(pp->mapping->host, pp, wbc, *for_sync);\n\tspl_fstrans_unmark(cookie);\n\n\treturn (0);\n}\n\n#ifdef HAVE_WRITEPAGE_T_FOLIO\nstatic int\nzpl_putfolio(struct folio *pp, struct writeback_control *wbc, void *data)\n{\n\t(void) zpl_putpage(&pp->page, wbc, data);\n\treturn (0);\n}\n#endif\n\nstatic inline int\nzpl_write_cache_pages(struct address_space *mapping,\n    struct writeback_control *wbc, void *data)\n{\n\tint result;\n\n#ifdef HAVE_WRITEPAGE_T_FOLIO\n\tresult = write_cache_pages(mapping, wbc, zpl_putfolio, data);\n#else\n\tresult = write_cache_pages(mapping, wbc, zpl_putpage, data);\n#endif\n\treturn (result);\n}\n\nstatic int\nzpl_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tznode_t\t\t*zp = ITOZ(mapping->host);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(mapping->host);\n\tenum writeback_sync_modes sync_mode;\n\tint result;\n\n\tif ((result = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (result);\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\twbc->sync_mode = WB_SYNC_ALL;\n\tzpl_exit(zfsvfs, FTAG);\n\tsync_mode = wbc->sync_mode;\n\n\t \n\tboolean_t for_sync = (sync_mode == WB_SYNC_ALL);\n\twbc->sync_mode = WB_SYNC_NONE;\n\tresult = zpl_write_cache_pages(mapping, wbc, &for_sync);\n\tif (sync_mode != wbc->sync_mode) {\n\t\tif ((result = zpl_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\t\treturn (result);\n\t\tif (zfsvfs->z_log != NULL)\n\t\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\t\tzpl_exit(zfsvfs, FTAG);\n\n\t\t \n\t\twbc->sync_mode = sync_mode;\n\t\tresult = zpl_write_cache_pages(mapping, wbc, &for_sync);\n\t}\n\treturn (result);\n}\n\n \nstatic int\nzpl_writepage(struct page *pp, struct writeback_control *wbc)\n{\n\tif (ITOZSB(pp->mapping->host)->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\twbc->sync_mode = WB_SYNC_ALL;\n\n\tboolean_t for_sync = (wbc->sync_mode == WB_SYNC_ALL);\n\n\treturn (zpl_putpage(pp, wbc, &for_sync));\n}\n\n \nstatic long\nzpl_fallocate_common(struct inode *ip, int mode, loff_t offset, loff_t len)\n{\n\tcred_t *cr = CRED();\n\tloff_t olen;\n\tfstrans_cookie_t cookie;\n\tint error = 0;\n\n\tint test_mode = FALLOC_FL_PUNCH_HOLE;\n#ifdef HAVE_FALLOC_FL_ZERO_RANGE\n\ttest_mode |= FALLOC_FL_ZERO_RANGE;\n#endif\n\n\tif ((mode & ~(FALLOC_FL_KEEP_SIZE | test_mode)) != 0)\n\t\treturn (-EOPNOTSUPP);\n\n\tif (offset < 0 || len <= 0)\n\t\treturn (-EINVAL);\n\n\tspl_inode_lock(ip);\n\tolen = i_size_read(ip);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\tif (mode & (test_mode)) {\n\t\tflock64_t bf;\n\n\t\tif (mode & FALLOC_FL_KEEP_SIZE) {\n\t\t\tif (offset > olen)\n\t\t\t\tgoto out_unmark;\n\n\t\t\tif (offset + len > olen)\n\t\t\t\tlen = olen - offset;\n\t\t}\n\t\tbf.l_type = F_WRLCK;\n\t\tbf.l_whence = SEEK_SET;\n\t\tbf.l_start = offset;\n\t\tbf.l_len = len;\n\t\tbf.l_pid = 0;\n\n\t\terror = -zfs_space(ITOZ(ip), F_FREESP, &bf, O_RDWR, offset, cr);\n\t} else if ((mode & ~FALLOC_FL_KEEP_SIZE) == 0) {\n\t\tunsigned int percent = zfs_fallocate_reserve_percent;\n\t\tstruct kstatfs statfs;\n\n\t\t \n\t\tif (percent == 0) {\n\t\t\terror = -EOPNOTSUPP;\n\t\t\tgoto out_unmark;\n\t\t}\n\n\t\t \n\t\terror = zfs_statvfs(ip, &statfs);\n\t\tif (error)\n\t\t\tgoto out_unmark;\n\n\t\t \n\t\tif (len > statfs.f_bavail * (statfs.f_bsize * 100 / percent)) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\tif (!(mode & FALLOC_FL_KEEP_SIZE) && offset + len > olen)\n\t\t\terror = zfs_freesp(ITOZ(ip), offset + len, 0, 0, FALSE);\n\t}\nout_unmark:\n\tspl_fstrans_unmark(cookie);\n\tspl_inode_unlock(ip);\n\n\tcrfree(cr);\n\n\treturn (error);\n}\n\nstatic long\nzpl_fallocate(struct file *filp, int mode, loff_t offset, loff_t len)\n{\n\treturn zpl_fallocate_common(file_inode(filp),\n\t    mode, offset, len);\n}\n\nstatic int\nzpl_ioctl_getversion(struct file *filp, void __user *arg)\n{\n\tuint32_t generation = file_inode(filp)->i_generation;\n\n\treturn (copy_to_user(arg, &generation, sizeof (generation)));\n}\n\n#ifdef HAVE_FILE_FADVISE\nstatic int\nzpl_fadvise(struct file *filp, loff_t offset, loff_t len, int advice)\n{\n\tstruct inode *ip = file_inode(filp);\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tobjset_t *os = zfsvfs->z_os;\n\tint error = 0;\n\n\tif (S_ISFIFO(ip->i_mode))\n\t\treturn (-ESPIPE);\n\n\tif (offset < 0 || len < 0)\n\t\treturn (-EINVAL);\n\n\tif ((error = zpl_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tswitch (advice) {\n\tcase POSIX_FADV_SEQUENTIAL:\n\tcase POSIX_FADV_WILLNEED:\n#ifdef HAVE_GENERIC_FADVISE\n\t\tif (zn_has_cached_data(zp, offset, offset + len - 1))\n\t\t\terror = generic_fadvise(filp, offset, len, advice);\n#endif\n\t\t \n\t\tif (len == 0)\n\t\t\tlen = i_size_read(ip) - offset;\n\n\t\tdmu_prefetch(os, zp->z_id, 0, offset, len,\n\t\t    ZIO_PRIORITY_ASYNC_READ);\n\t\tbreak;\n\tcase POSIX_FADV_NORMAL:\n\tcase POSIX_FADV_RANDOM:\n\tcase POSIX_FADV_DONTNEED:\n\tcase POSIX_FADV_NOREUSE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n#endif  \n\n#define\tZFS_FL_USER_VISIBLE\t(FS_FL_USER_VISIBLE | ZFS_PROJINHERIT_FL)\n#define\tZFS_FL_USER_MODIFIABLE\t(FS_FL_USER_MODIFIABLE | ZFS_PROJINHERIT_FL)\n\nstatic uint32_t\n__zpl_ioctl_getflags(struct inode *ip)\n{\n\tuint64_t zfs_flags = ITOZ(ip)->z_pflags;\n\tuint32_t ioctl_flags = 0;\n\n\tif (zfs_flags & ZFS_IMMUTABLE)\n\t\tioctl_flags |= FS_IMMUTABLE_FL;\n\n\tif (zfs_flags & ZFS_APPENDONLY)\n\t\tioctl_flags |= FS_APPEND_FL;\n\n\tif (zfs_flags & ZFS_NODUMP)\n\t\tioctl_flags |= FS_NODUMP_FL;\n\n\tif (zfs_flags & ZFS_PROJINHERIT)\n\t\tioctl_flags |= ZFS_PROJINHERIT_FL;\n\n\treturn (ioctl_flags & ZFS_FL_USER_VISIBLE);\n}\n\n \nstatic int\nzpl_ioctl_getflags(struct file *filp, void __user *arg)\n{\n\tuint32_t flags;\n\tint err;\n\n\tflags = __zpl_ioctl_getflags(file_inode(filp));\n\terr = copy_to_user(arg, &flags, sizeof (flags));\n\n\treturn (err);\n}\n\n \n\n#define\tfchange(f0, f1, b0, b1) (!((f0) & (b0)) != !((f1) & (b1)))\n\nstatic int\n__zpl_ioctl_setflags(struct inode *ip, uint32_t ioctl_flags, xvattr_t *xva)\n{\n\tuint64_t zfs_flags = ITOZ(ip)->z_pflags;\n\txoptattr_t *xoap;\n\n\tif (ioctl_flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NODUMP_FL |\n\t    ZFS_PROJINHERIT_FL))\n\t\treturn (-EOPNOTSUPP);\n\n\tif (ioctl_flags & ~ZFS_FL_USER_MODIFIABLE)\n\t\treturn (-EACCES);\n\n\tif ((fchange(ioctl_flags, zfs_flags, FS_IMMUTABLE_FL, ZFS_IMMUTABLE) ||\n\t    fchange(ioctl_flags, zfs_flags, FS_APPEND_FL, ZFS_APPENDONLY)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn (-EPERM);\n\n\tif (!zpl_inode_owner_or_capable(zfs_init_idmap, ip))\n\t\treturn (-EACCES);\n\n\txva_init(xva);\n\txoap = xva_getxoptattr(xva);\n\n#define\tFLAG_CHANGE(iflag, zflag, xflag, xfield)\tdo {\t\\\n\tif (((ioctl_flags & (iflag)) && !(zfs_flags & (zflag))) ||\t\\\n\t    ((zfs_flags & (zflag)) && !(ioctl_flags & (iflag)))) {\t\\\n\t\tXVA_SET_REQ(xva, (xflag));\t\\\n\t\t(xfield) = ((ioctl_flags & (iflag)) != 0);\t\\\n\t}\t\\\n} while (0)\n\n\tFLAG_CHANGE(FS_IMMUTABLE_FL, ZFS_IMMUTABLE, XAT_IMMUTABLE,\n\t    xoap->xoa_immutable);\n\tFLAG_CHANGE(FS_APPEND_FL, ZFS_APPENDONLY, XAT_APPENDONLY,\n\t    xoap->xoa_appendonly);\n\tFLAG_CHANGE(FS_NODUMP_FL, ZFS_NODUMP, XAT_NODUMP,\n\t    xoap->xoa_nodump);\n\tFLAG_CHANGE(ZFS_PROJINHERIT_FL, ZFS_PROJINHERIT, XAT_PROJINHERIT,\n\t    xoap->xoa_projinherit);\n\n#undef\tFLAG_CHANGE\n\n\treturn (0);\n}\n\nstatic int\nzpl_ioctl_setflags(struct file *filp, void __user *arg)\n{\n\tstruct inode *ip = file_inode(filp);\n\tuint32_t flags;\n\tcred_t *cr = CRED();\n\txvattr_t xva;\n\tint err;\n\tfstrans_cookie_t cookie;\n\n\tif (copy_from_user(&flags, arg, sizeof (flags)))\n\t\treturn (-EFAULT);\n\n\terr = __zpl_ioctl_setflags(ip, flags, &xva);\n\tif (err)\n\t\treturn (err);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terr = -zfs_setattr(ITOZ(ip), (vattr_t *)&xva, 0, cr, zfs_init_idmap);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\treturn (err);\n}\n\nstatic int\nzpl_ioctl_getxattr(struct file *filp, void __user *arg)\n{\n\tzfsxattr_t fsx = { 0 };\n\tstruct inode *ip = file_inode(filp);\n\tint err;\n\n\tfsx.fsx_xflags = __zpl_ioctl_getflags(ip);\n\tfsx.fsx_projid = ITOZ(ip)->z_projid;\n\terr = copy_to_user(arg, &fsx, sizeof (fsx));\n\n\treturn (err);\n}\n\nstatic int\nzpl_ioctl_setxattr(struct file *filp, void __user *arg)\n{\n\tstruct inode *ip = file_inode(filp);\n\tzfsxattr_t fsx;\n\tcred_t *cr = CRED();\n\txvattr_t xva;\n\txoptattr_t *xoap;\n\tint err;\n\tfstrans_cookie_t cookie;\n\n\tif (copy_from_user(&fsx, arg, sizeof (fsx)))\n\t\treturn (-EFAULT);\n\n\tif (!zpl_is_valid_projid(fsx.fsx_projid))\n\t\treturn (-EINVAL);\n\n\terr = __zpl_ioctl_setflags(ip, fsx.fsx_xflags, &xva);\n\tif (err)\n\t\treturn (err);\n\n\txoap = xva_getxoptattr(&xva);\n\tXVA_SET_REQ(&xva, XAT_PROJID);\n\txoap->xoa_projid = fsx.fsx_projid;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terr = -zfs_setattr(ITOZ(ip), (vattr_t *)&xva, 0, cr, zfs_init_idmap);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\treturn (err);\n}\n\n \nstatic int\nzpl_ioctl_getdosflags(struct file *filp, void __user *arg)\n{\n\tstruct inode *ip = file_inode(filp);\n\tuint64_t dosflags = ITOZ(ip)->z_pflags;\n\tdosflags &= ZFS_DOS_FL_USER_VISIBLE;\n\tint err = copy_to_user(arg, &dosflags, sizeof (dosflags));\n\n\treturn (err);\n}\n\nstatic int\n__zpl_ioctl_setdosflags(struct inode *ip, uint64_t ioctl_flags, xvattr_t *xva)\n{\n\tuint64_t zfs_flags = ITOZ(ip)->z_pflags;\n\txoptattr_t *xoap;\n\n\tif (ioctl_flags & (~ZFS_DOS_FL_USER_VISIBLE))\n\t\treturn (-EOPNOTSUPP);\n\n\tif ((fchange(ioctl_flags, zfs_flags, ZFS_IMMUTABLE, ZFS_IMMUTABLE) ||\n\t    fchange(ioctl_flags, zfs_flags, ZFS_APPENDONLY, ZFS_APPENDONLY)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\treturn (-EPERM);\n\n\tif (!zpl_inode_owner_or_capable(zfs_init_idmap, ip))\n\t\treturn (-EACCES);\n\n\txva_init(xva);\n\txoap = xva_getxoptattr(xva);\n\n#define\tFLAG_CHANGE(iflag, xflag, xfield)\tdo {\t\\\n\tif (((ioctl_flags & (iflag)) && !(zfs_flags & (iflag))) ||\t\\\n\t    ((zfs_flags & (iflag)) && !(ioctl_flags & (iflag)))) {\t\\\n\t\tXVA_SET_REQ(xva, (xflag));\t\\\n\t\t(xfield) = ((ioctl_flags & (iflag)) != 0);\t\\\n\t}\t\\\n} while (0)\n\n\tFLAG_CHANGE(ZFS_IMMUTABLE, XAT_IMMUTABLE, xoap->xoa_immutable);\n\tFLAG_CHANGE(ZFS_APPENDONLY, XAT_APPENDONLY, xoap->xoa_appendonly);\n\tFLAG_CHANGE(ZFS_NODUMP, XAT_NODUMP, xoap->xoa_nodump);\n\tFLAG_CHANGE(ZFS_READONLY, XAT_READONLY, xoap->xoa_readonly);\n\tFLAG_CHANGE(ZFS_HIDDEN, XAT_HIDDEN, xoap->xoa_hidden);\n\tFLAG_CHANGE(ZFS_SYSTEM, XAT_SYSTEM, xoap->xoa_system);\n\tFLAG_CHANGE(ZFS_ARCHIVE, XAT_ARCHIVE, xoap->xoa_archive);\n\tFLAG_CHANGE(ZFS_NOUNLINK, XAT_NOUNLINK, xoap->xoa_nounlink);\n\tFLAG_CHANGE(ZFS_REPARSE, XAT_REPARSE, xoap->xoa_reparse);\n\tFLAG_CHANGE(ZFS_OFFLINE, XAT_OFFLINE, xoap->xoa_offline);\n\tFLAG_CHANGE(ZFS_SPARSE, XAT_SPARSE, xoap->xoa_sparse);\n\n#undef\tFLAG_CHANGE\n\n\treturn (0);\n}\n\n \nstatic int\nzpl_ioctl_setdosflags(struct file *filp, void __user *arg)\n{\n\tstruct inode *ip = file_inode(filp);\n\tuint64_t dosflags;\n\tcred_t *cr = CRED();\n\txvattr_t xva;\n\tint err;\n\tfstrans_cookie_t cookie;\n\n\tif (copy_from_user(&dosflags, arg, sizeof (dosflags)))\n\t\treturn (-EFAULT);\n\n\terr = __zpl_ioctl_setdosflags(ip, dosflags, &xva);\n\tif (err)\n\t\treturn (err);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terr = -zfs_setattr(ITOZ(ip), (vattr_t *)&xva, 0, cr, zfs_init_idmap);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\treturn (err);\n}\n\nstatic long\nzpl_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC_GETVERSION:\n\t\treturn (zpl_ioctl_getversion(filp, (void *)arg));\n\tcase FS_IOC_GETFLAGS:\n\t\treturn (zpl_ioctl_getflags(filp, (void *)arg));\n\tcase FS_IOC_SETFLAGS:\n\t\treturn (zpl_ioctl_setflags(filp, (void *)arg));\n\tcase ZFS_IOC_FSGETXATTR:\n\t\treturn (zpl_ioctl_getxattr(filp, (void *)arg));\n\tcase ZFS_IOC_FSSETXATTR:\n\t\treturn (zpl_ioctl_setxattr(filp, (void *)arg));\n\tcase ZFS_IOC_GETDOSFLAGS:\n\t\treturn (zpl_ioctl_getdosflags(filp, (void *)arg));\n\tcase ZFS_IOC_SETDOSFLAGS:\n\t\treturn (zpl_ioctl_setdosflags(filp, (void *)arg));\n\tcase ZFS_IOC_COMPAT_FICLONE:\n\t\treturn (zpl_ioctl_ficlone(filp, (void *)arg));\n\tcase ZFS_IOC_COMPAT_FICLONERANGE:\n\t\treturn (zpl_ioctl_ficlonerange(filp, (void *)arg));\n\tcase ZFS_IOC_COMPAT_FIDEDUPERANGE:\n\t\treturn (zpl_ioctl_fideduperange(filp, (void *)arg));\n\tdefault:\n\t\treturn (-ENOTTY);\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\nzpl_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETVERSION:\n\t\tcmd = FS_IOC_GETVERSION;\n\t\tbreak;\n\tcase FS_IOC32_GETFLAGS:\n\t\tcmd = FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = FS_IOC_SETFLAGS;\n\t\tbreak;\n\tdefault:\n\t\treturn (-ENOTTY);\n\t}\n\treturn (zpl_ioctl(filp, cmd, (unsigned long)compat_ptr(arg)));\n}\n#endif  \n\nconst struct address_space_operations zpl_address_space_operations = {\n#ifdef HAVE_VFS_READPAGES\n\t.readpages\t= zpl_readpages,\n#else\n\t.readahead\t= zpl_readahead,\n#endif\n#ifdef HAVE_VFS_READ_FOLIO\n\t.read_folio\t= zpl_read_folio,\n#else\n\t.readpage\t= zpl_readpage,\n#endif\n\t.writepage\t= zpl_writepage,\n\t.writepages\t= zpl_writepages,\n\t.direct_IO\t= zpl_direct_IO,\n#ifdef HAVE_VFS_SET_PAGE_DIRTY_NOBUFFERS\n\t.set_page_dirty = __set_page_dirty_nobuffers,\n#endif\n#ifdef HAVE_VFS_FILEMAP_DIRTY_FOLIO\n\t.dirty_folio\t= filemap_dirty_folio,\n#endif\n};\n\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\nconst struct file_operations_extend zpl_file_operations = {\n\t.kabi_fops = {\n#else\nconst struct file_operations zpl_file_operations = {\n#endif\n\t.open\t\t= zpl_open,\n\t.release\t= zpl_release,\n\t.llseek\t\t= zpl_llseek,\n#ifdef HAVE_VFS_RW_ITERATE\n#ifdef HAVE_NEW_SYNC_READ\n\t.read\t\t= new_sync_read,\n\t.write\t\t= new_sync_write,\n#endif\n\t.read_iter\t= zpl_iter_read,\n\t.write_iter\t= zpl_iter_write,\n#ifdef HAVE_VFS_IOV_ITER\n#ifdef HAVE_COPY_SPLICE_READ\n\t.splice_read\t= copy_splice_read,\n#else\n\t.splice_read\t= generic_file_splice_read,\n#endif\n\t.splice_write\t= iter_file_splice_write,\n#endif\n#else\n\t.read\t\t= do_sync_read,\n\t.write\t\t= do_sync_write,\n\t.aio_read\t= zpl_aio_read,\n\t.aio_write\t= zpl_aio_write,\n#endif\n\t.mmap\t\t= zpl_mmap,\n\t.fsync\t\t= zpl_fsync,\n#ifdef HAVE_FILE_AIO_FSYNC\n\t.aio_fsync\t= zpl_aio_fsync,\n#endif\n\t.fallocate\t= zpl_fallocate,\n#ifdef HAVE_VFS_COPY_FILE_RANGE\n\t.copy_file_range\t= zpl_copy_file_range,\n#endif\n#ifdef HAVE_VFS_CLONE_FILE_RANGE\n\t.clone_file_range\t= zpl_clone_file_range,\n#endif\n#ifdef HAVE_VFS_REMAP_FILE_RANGE\n\t.remap_file_range\t= zpl_remap_file_range,\n#endif\n#ifdef HAVE_VFS_DEDUPE_FILE_RANGE\n\t.dedupe_file_range\t= zpl_dedupe_file_range,\n#endif\n#ifdef HAVE_FILE_FADVISE\n\t.fadvise\t= zpl_fadvise,\n#endif\n\t.unlocked_ioctl\t= zpl_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= zpl_compat_ioctl,\n#endif\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\n\t},  \n\t.copy_file_range\t= zpl_copy_file_range,\n\t.clone_file_range\t= zpl_clone_file_range,\n#endif\n};\n\nconst struct file_operations zpl_dir_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n#if defined(HAVE_VFS_ITERATE_SHARED)\n\t.iterate_shared\t= zpl_iterate,\n#elif defined(HAVE_VFS_ITERATE)\n\t.iterate\t= zpl_iterate,\n#else\n\t.readdir\t= zpl_readdir,\n#endif\n\t.fsync\t\t= zpl_fsync,\n\t.unlocked_ioctl = zpl_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = zpl_compat_ioctl,\n#endif\n};\n\n \nmodule_param(zfs_fallocate_reserve_percent, uint, 0644);\nMODULE_PARM_DESC(zfs_fallocate_reserve_percent,\n\t\"Percentage of length to use for the available capacity check\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}