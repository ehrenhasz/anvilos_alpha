{
  "module_name": "zpl_super.c",
  "hash_id": "227e579f787ab154bdb1e5169cb4386fc8803c35aa16d706a35b57d51c135eed",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_super.c",
  "human_readable_source": " \n \n\n\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zpl.h>\n\n\nstatic struct inode *\nzpl_inode_alloc(struct super_block *sb)\n{\n\tstruct inode *ip;\n\n\tVERIFY3S(zfs_inode_alloc(sb, &ip), ==, 0);\n\tinode_set_iversion(ip, 1);\n\n\treturn (ip);\n}\n\nstatic void\nzpl_inode_destroy(struct inode *ip)\n{\n\tASSERT(atomic_read(&ip->i_count) == 0);\n\tzfs_inode_destroy(ip);\n}\n\n \n#ifdef HAVE_DIRTY_INODE_WITH_FLAGS\nstatic void\nzpl_dirty_inode(struct inode *ip, int flags)\n{\n\tfstrans_cookie_t cookie;\n\n\tcookie = spl_fstrans_mark();\n\tzfs_dirty_inode(ip, flags);\n\tspl_fstrans_unmark(cookie);\n}\n#else\nstatic void\nzpl_dirty_inode(struct inode *ip)\n{\n\tfstrans_cookie_t cookie;\n\n\tcookie = spl_fstrans_mark();\n\tzfs_dirty_inode(ip, 0);\n\tspl_fstrans_unmark(cookie);\n}\n#endif  \n\n \nstatic void\nzpl_evict_inode(struct inode *ip)\n{\n\tfstrans_cookie_t cookie;\n\n\tcookie = spl_fstrans_mark();\n\ttruncate_setsize(ip, 0);\n\tclear_inode(ip);\n\tzfs_inactive(ip);\n\tspl_fstrans_unmark(cookie);\n}\n\nstatic void\nzpl_put_super(struct super_block *sb)\n{\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_umount(sb);\n\tspl_fstrans_unmark(cookie);\n\tASSERT3S(error, <=, 0);\n}\n\nstatic int\nzpl_sync_fs(struct super_block *sb, int wait)\n{\n\tfstrans_cookie_t cookie;\n\tcred_t *cr = CRED();\n\tint error;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_sync(sb, wait, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_statfs(struct dentry *dentry, struct kstatfs *statp)\n{\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_statvfs(dentry->d_inode, statp);\n\tspl_fstrans_unmark(cookie);\n\tASSERT3S(error, <=, 0);\n\n\t \n\tif (unlikely(zpl_is_32bit_api())) {\n\t\twhile (statp->f_blocks > UINT32_MAX &&\n\t\t    statp->f_bsize < SPA_MAXBLOCKSIZE) {\n\t\t\tstatp->f_frsize <<= 1;\n\t\t\tstatp->f_bsize <<= 1;\n\n\t\t\tstatp->f_blocks >>= 1;\n\t\t\tstatp->f_bfree >>= 1;\n\t\t\tstatp->f_bavail >>= 1;\n\t\t}\n\n\t\tuint64_t usedobjs = statp->f_files - statp->f_ffree;\n\t\tstatp->f_ffree = MIN(statp->f_ffree, UINT32_MAX - usedobjs);\n\t\tstatp->f_files = statp->f_ffree + usedobjs;\n\t}\n\n\treturn (error);\n}\n\nstatic int\nzpl_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tzfs_mnt_t zm = { .mnt_osname = NULL, .mnt_data = data };\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_remount(sb, flags, &zm);\n\tspl_fstrans_unmark(cookie);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\n__zpl_show_devname(struct seq_file *seq, zfsvfs_t *zfsvfs)\n{\n\tint error;\n\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tchar *fsname = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\tdmu_objset_name(zfsvfs->z_os, fsname);\n\n\tfor (int i = 0; fsname[i] != 0; i++) {\n\t\t \n\t\tif (fsname[i] == ' ') {\n\t\t\tseq_puts(seq, \"\\\\040\");\n\t\t} else {\n\t\t\tseq_putc(seq, fsname[i]);\n\t\t}\n\t}\n\n\tkmem_free(fsname, ZFS_MAX_DATASET_NAME_LEN);\n\n\tzpl_exit(zfsvfs, FTAG);\n\n\treturn (0);\n}\n\nstatic int\nzpl_show_devname(struct seq_file *seq, struct dentry *root)\n{\n\treturn (__zpl_show_devname(seq, root->d_sb->s_fs_info));\n}\n\nstatic int\n__zpl_show_options(struct seq_file *seq, zfsvfs_t *zfsvfs)\n{\n\tseq_printf(seq, \",%s\",\n\t    zfsvfs->z_flags & ZSB_XATTR ? \"xattr\" : \"noxattr\");\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tswitch (zfsvfs->z_acl_type) {\n\tcase ZFS_ACLTYPE_POSIX:\n\t\tseq_puts(seq, \",posixacl\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(seq, \",noacl\");\n\t\tbreak;\n\t}\n#endif  \n\n\tswitch (zfsvfs->z_case) {\n\tcase ZFS_CASE_SENSITIVE:\n\t\tseq_puts(seq, \",casesensitive\");\n\t\tbreak;\n\tcase ZFS_CASE_INSENSITIVE:\n\t\tseq_puts(seq, \",caseinsensitive\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(seq, \",casemixed\");\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzpl_show_options(struct seq_file *seq, struct dentry *root)\n{\n\treturn (__zpl_show_options(seq, root->d_sb->s_fs_info));\n}\n\nstatic int\nzpl_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tzfs_mnt_t *zm = (zfs_mnt_t *)data;\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_domount(sb, zm, silent);\n\tspl_fstrans_unmark(cookie);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_test_super(struct super_block *s, void *data)\n{\n\tzfsvfs_t *zfsvfs = s->s_fs_info;\n\tobjset_t *os = data;\n\t \n\treturn (zfsvfs != NULL && os == zfsvfs->z_os);\n}\n\nstatic struct super_block *\nzpl_mount_impl(struct file_system_type *fs_type, int flags, zfs_mnt_t *zm)\n{\n\tstruct super_block *s;\n\tobjset_t *os;\n\tint err;\n\n\terr = dmu_objset_hold(zm->mnt_osname, FTAG, &os);\n\tif (err)\n\t\treturn (ERR_PTR(-err));\n\n\t \n\tdsl_dataset_long_hold(dmu_objset_ds(os), FTAG);\n\tdsl_pool_rele(dmu_objset_pool(os), FTAG);\n\n\ts = sget(fs_type, zpl_test_super, set_anon_super, flags, os);\n\n\t \n\tif (!IS_ERR(s) && s->s_fs_info != NULL) {\n\t\tzfsvfs_t *zfsvfs = s->s_fs_info;\n\t\tif (zpl_enter(zfsvfs, FTAG) == 0) {\n\t\t\tif (os != zfsvfs->z_os)\n\t\t\t\terr = -SET_ERROR(EBUSY);\n\t\t\tzpl_exit(zfsvfs, FTAG);\n\t\t} else {\n\t\t\terr = -SET_ERROR(EBUSY);\n\t\t}\n\t}\n\tdsl_dataset_long_rele(dmu_objset_ds(os), FTAG);\n\tdsl_dataset_rele(dmu_objset_ds(os), FTAG);\n\n\tif (IS_ERR(s))\n\t\treturn (ERR_CAST(s));\n\n\tif (err) {\n\t\tdeactivate_locked_super(s);\n\t\treturn (ERR_PTR(err));\n\t}\n\n\tif (s->s_root == NULL) {\n\t\terr = zpl_fill_super(s, zm, flags & SB_SILENT ? 1 : 0);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn (ERR_PTR(err));\n\t\t}\n\t\ts->s_flags |= SB_ACTIVE;\n\t} else if ((flags ^ s->s_flags) & SB_RDONLY) {\n\t\tdeactivate_locked_super(s);\n\t\treturn (ERR_PTR(-EBUSY));\n\t}\n\n\treturn (s);\n}\n\nstatic struct dentry *\nzpl_mount(struct file_system_type *fs_type, int flags,\n    const char *osname, void *data)\n{\n\tzfs_mnt_t zm = { .mnt_osname = osname, .mnt_data = data };\n\n\tstruct super_block *sb = zpl_mount_impl(fs_type, flags, &zm);\n\tif (IS_ERR(sb))\n\t\treturn (ERR_CAST(sb));\n\n\treturn (dget(sb->s_root));\n}\n\nstatic void\nzpl_kill_sb(struct super_block *sb)\n{\n\tzfs_preumount(sb);\n\tkill_anon_super(sb);\n}\n\nvoid\nzpl_prune_sb(uint64_t nr_to_scan, void *arg)\n{\n\tstruct super_block *sb = (struct super_block *)arg;\n\tint objects = 0;\n\n\t(void) -zfs_prune(sb, nr_to_scan, &objects);\n}\n\nconst struct super_operations zpl_super_operations = {\n\t.alloc_inode\t\t= zpl_inode_alloc,\n\t.destroy_inode\t\t= zpl_inode_destroy,\n\t.dirty_inode\t\t= zpl_dirty_inode,\n\t.write_inode\t\t= NULL,\n\t.evict_inode\t\t= zpl_evict_inode,\n\t.put_super\t\t= zpl_put_super,\n\t.sync_fs\t\t= zpl_sync_fs,\n\t.statfs\t\t\t= zpl_statfs,\n\t.remount_fs\t\t= zpl_remount_fs,\n\t.show_devname\t\t= zpl_show_devname,\n\t.show_options\t\t= zpl_show_options,\n\t.show_stats\t\t= NULL,\n};\n\nstruct file_system_type zpl_fs_type = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= ZFS_DRIVER,\n#if defined(HAVE_IDMAP_MNT_API)\n\t.fs_flags\t\t= FS_USERNS_MOUNT | FS_ALLOW_IDMAP,\n#else\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n#endif\n\t.mount\t\t\t= zpl_mount,\n\t.kill_sb\t\t= zpl_kill_sb,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}