{
  "module_name": "zfs_uio.c",
  "hash_id": "514c0fd6a64947d2e4c1ccfef174bb65b3ad758667768a364600422f824f9de2",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_uio.c",
  "human_readable_source": " \n \n\n \n \n\n \n \n\n#ifdef _KERNEL\n\n#include <sys/types.h>\n#include <sys/uio_impl.h>\n#include <sys/sysmacros.h>\n#include <sys/string.h>\n#include <linux/kmap_compat.h>\n#include <linux/uaccess.h>\n\n \nstatic int\nzfs_uiomove_iov(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio)\n{\n\tconst struct iovec *iov = uio->uio_iov;\n\tsize_t skip = uio->uio_skip;\n\tulong_t cnt;\n\n\twhile (n && uio->uio_resid) {\n\t\tcnt = MIN(iov->iov_len - skip, n);\n\t\tswitch (uio->uio_segflg) {\n\t\tcase UIO_USERSPACE:\n\t\t\t \n\t\t\tif (rw == UIO_READ) {\n\t\t\t\tif (copy_to_user(iov->iov_base+skip, p, cnt))\n\t\t\t\t\treturn (EFAULT);\n\t\t\t} else {\n\t\t\t\tunsigned long b_left = 0;\n\t\t\t\tif (uio->uio_fault_disable) {\n\t\t\t\t\tif (!zfs_access_ok(VERIFY_READ,\n\t\t\t\t\t    (iov->iov_base + skip), cnt)) {\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t\t}\n\t\t\t\t\tpagefault_disable();\n\t\t\t\t\tb_left =\n\t\t\t\t\t    __copy_from_user_inatomic(p,\n\t\t\t\t\t    (iov->iov_base + skip), cnt);\n\t\t\t\t\tpagefault_enable();\n\t\t\t\t} else {\n\t\t\t\t\tb_left =\n\t\t\t\t\t    copy_from_user(p,\n\t\t\t\t\t    (iov->iov_base + skip), cnt);\n\t\t\t\t}\n\t\t\t\tif (b_left > 0) {\n\t\t\t\t\tunsigned long c_bytes =\n\t\t\t\t\t    cnt - b_left;\n\t\t\t\t\tuio->uio_skip += c_bytes;\n\t\t\t\t\tASSERT3U(uio->uio_skip, <,\n\t\t\t\t\t    iov->iov_len);\n\t\t\t\t\tuio->uio_resid -= c_bytes;\n\t\t\t\t\tuio->uio_loffset += c_bytes;\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UIO_SYSSPACE:\n\t\t\tif (rw == UIO_READ)\n\t\t\t\tmemcpy(iov->iov_base + skip, p, cnt);\n\t\t\telse\n\t\t\t\tmemcpy(p, iov->iov_base + skip, cnt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t}\n\t\tskip += cnt;\n\t\tif (skip == iov->iov_len) {\n\t\t\tskip = 0;\n\t\t\tuio->uio_iov = (++iov);\n\t\t\tuio->uio_iovcnt--;\n\t\t}\n\t\tuio->uio_skip = skip;\n\t\tuio->uio_resid -= cnt;\n\t\tuio->uio_loffset += cnt;\n\t\tp = (caddr_t)p + cnt;\n\t\tn -= cnt;\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_uiomove_bvec_impl(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio)\n{\n\tconst struct bio_vec *bv = uio->uio_bvec;\n\tsize_t skip = uio->uio_skip;\n\tulong_t cnt;\n\n\twhile (n && uio->uio_resid) {\n\t\tvoid *paddr;\n\t\tcnt = MIN(bv->bv_len - skip, n);\n\n\t\tpaddr = zfs_kmap_atomic(bv->bv_page);\n\t\tif (rw == UIO_READ) {\n\t\t\t \n\t\t\tmemcpy(paddr + bv->bv_offset + skip, p, cnt);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(p, paddr + bv->bv_offset + skip, cnt);\n\t\t}\n\t\tzfs_kunmap_atomic(paddr);\n\n\t\tskip += cnt;\n\t\tif (skip == bv->bv_len) {\n\t\t\tskip = 0;\n\t\t\tuio->uio_bvec = (++bv);\n\t\t\tuio->uio_iovcnt--;\n\t\t}\n\t\tuio->uio_skip = skip;\n\t\tuio->uio_resid -= cnt;\n\t\tuio->uio_loffset += cnt;\n\t\tp = (caddr_t)p + cnt;\n\t\tn -= cnt;\n\t}\n\treturn (0);\n}\n\n#ifdef HAVE_BLK_MQ\nstatic void\nzfs_copy_bvec(void *p, size_t skip, size_t cnt, zfs_uio_rw_t rw,\n    struct bio_vec *bv)\n{\n\tvoid *paddr;\n\n\tpaddr = zfs_kmap_atomic(bv->bv_page);\n\tif (rw == UIO_READ) {\n\t\t \n\t\tmemcpy(paddr + bv->bv_offset + skip, p, cnt);\n\t} else {\n\t\t \n\t\tmemcpy(p, paddr + bv->bv_offset + skip, cnt);\n\t}\n\tzfs_kunmap_atomic(paddr);\n}\n\n \nstatic int\nzfs_uiomove_bvec_rq(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio)\n{\n\tstruct request *rq = uio->rq;\n\tstruct bio_vec bv;\n\tstruct req_iterator iter;\n\tsize_t this_seg_start;\t \n\tsize_t this_seg_end;\t\t \n\tsize_t skip_in_seg;\n\tsize_t copy_from_seg;\n\tsize_t orig_loffset;\n\tint copied = 0;\n\n\t \n\torig_loffset = io_offset(NULL, rq);\n\tthis_seg_start = orig_loffset;\n\n\trq_for_each_segment(bv, rq, iter) {\n\t\t \n\t\tthis_seg_end = this_seg_start + bv.bv_len - 1;\n\n\t\t \n\t\tif (uio->uio_loffset >= this_seg_start &&\n\t\t    uio->uio_loffset <= this_seg_end) {\n\t\t\t \n\n\t\t\t \n\t\t\tskip_in_seg = uio->uio_loffset - this_seg_start;\n\n\t\t\t \n\t\t\tcopy_from_seg = MIN(bv.bv_len - skip_in_seg, n);\n\n\t\t\t \n\t\t\tzfs_copy_bvec(p, skip_in_seg, copy_from_seg, rw, &bv);\n\t\t\tp = ((char *)p) + copy_from_seg;\n\n\t\t\tn -= copy_from_seg;\n\t\t\tuio->uio_resid -= copy_from_seg;\n\t\t\tuio->uio_loffset += copy_from_seg;\n\t\t\tcopied = 1;\t \n\t\t}\n\n\t\tthis_seg_start = this_seg_end + 1;\n\t}\n\n\tif (!copied) {\n\t\t \n\t\tuio->uio_resid = 0;\n\t}\n\treturn (0);\n}\n#endif\n\nstatic int\nzfs_uiomove_bvec(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio)\n{\n#ifdef HAVE_BLK_MQ\n\tif (uio->rq != NULL)\n\t\treturn (zfs_uiomove_bvec_rq(p, n, rw, uio));\n#else\n\tASSERT3P(uio->rq, ==, NULL);\n#endif\n\treturn (zfs_uiomove_bvec_impl(p, n, rw, uio));\n}\n\n#if defined(HAVE_VFS_IOV_ITER)\nstatic int\nzfs_uiomove_iter(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio,\n    boolean_t revert)\n{\n\tsize_t cnt = MIN(n, uio->uio_resid);\n\n\tif (uio->uio_skip)\n\t\tiov_iter_advance(uio->uio_iter, uio->uio_skip);\n\n\tif (rw == UIO_READ)\n\t\tcnt = copy_to_iter(p, cnt, uio->uio_iter);\n\telse\n\t\tcnt = copy_from_iter(p, cnt, uio->uio_iter);\n\n\t \n\tif (cnt == 0)\n\t\treturn (EFAULT);\n\n\t \n\tif (revert)\n\t\tiov_iter_revert(uio->uio_iter, cnt);\n\n\tuio->uio_resid -= cnt;\n\tuio->uio_loffset += cnt;\n\n\treturn (0);\n}\n#endif\n\nint\nzfs_uiomove(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio)\n{\n\tif (uio->uio_segflg == UIO_BVEC)\n\t\treturn (zfs_uiomove_bvec(p, n, rw, uio));\n#if defined(HAVE_VFS_IOV_ITER)\n\telse if (uio->uio_segflg == UIO_ITER)\n\t\treturn (zfs_uiomove_iter(p, n, rw, uio, B_FALSE));\n#endif\n\telse\n\t\treturn (zfs_uiomove_iov(p, n, rw, uio));\n}\nEXPORT_SYMBOL(zfs_uiomove);\n\n \nint\nzfs_uio_prefaultpages(ssize_t n, zfs_uio_t *uio)\n{\n\tif (uio->uio_segflg == UIO_SYSSPACE || uio->uio_segflg == UIO_BVEC) {\n\t\t \n\t\treturn (0);\n#if defined(HAVE_VFS_IOV_ITER)\n\t} else if (uio->uio_segflg == UIO_ITER) {\n\t\t \n\t\tif (iov_iter_fault_in_readable(uio->uio_iter, n))\n\t\t\treturn (EFAULT);\n#endif\n\t} else {\n\t\t \n\t\tASSERT3S(uio->uio_segflg, ==, UIO_USERSPACE);\n\t\tconst struct iovec *iov = uio->uio_iov;\n\t\tint iovcnt = uio->uio_iovcnt;\n\t\tsize_t skip = uio->uio_skip;\n\t\tuint8_t tmp;\n\t\tcaddr_t p;\n\n\t\tfor (; n > 0 && iovcnt > 0; iov++, iovcnt--, skip = 0) {\n\t\t\tulong_t cnt = MIN(iov->iov_len - skip, n);\n\t\t\t \n\t\t\tif (cnt == 0)\n\t\t\t\tcontinue;\n\t\t\tn -= cnt;\n\t\t\t \n\t\t\tp = iov->iov_base + skip;\n\t\t\twhile (cnt) {\n\t\t\t\tif (copy_from_user(&tmp, p, 1))\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tulong_t incr = MIN(cnt, PAGESIZE);\n\t\t\t\tp += incr;\n\t\t\t\tcnt -= incr;\n\t\t\t}\n\t\t\t \n\t\t\tp--;\n\t\t\tif (copy_from_user(&tmp, p, 1))\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t}\n\n\treturn (0);\n}\nEXPORT_SYMBOL(zfs_uio_prefaultpages);\n\n \nint\nzfs_uiocopy(void *p, size_t n, zfs_uio_rw_t rw, zfs_uio_t *uio, size_t *cbytes)\n{\n\tzfs_uio_t uio_copy;\n\tint ret;\n\n\tmemcpy(&uio_copy, uio, sizeof (zfs_uio_t));\n\n\tif (uio->uio_segflg == UIO_BVEC)\n\t\tret = zfs_uiomove_bvec(p, n, rw, &uio_copy);\n#if defined(HAVE_VFS_IOV_ITER)\n\telse if (uio->uio_segflg == UIO_ITER)\n\t\tret = zfs_uiomove_iter(p, n, rw, &uio_copy, B_TRUE);\n#endif\n\telse\n\t\tret = zfs_uiomove_iov(p, n, rw, &uio_copy);\n\n\t*cbytes = uio->uio_resid - uio_copy.uio_resid;\n\n\treturn (ret);\n}\nEXPORT_SYMBOL(zfs_uiocopy);\n\n \nvoid\nzfs_uioskip(zfs_uio_t *uio, size_t n)\n{\n\tif (n > uio->uio_resid)\n\t\treturn;\n\t \n\tif (uio->uio_segflg == UIO_BVEC && uio->rq == NULL) {\n\t\tuio->uio_skip += n;\n\t\twhile (uio->uio_iovcnt &&\n\t\t    uio->uio_skip >= uio->uio_bvec->bv_len) {\n\t\t\tuio->uio_skip -= uio->uio_bvec->bv_len;\n\t\t\tuio->uio_bvec++;\n\t\t\tuio->uio_iovcnt--;\n\t\t}\n#if defined(HAVE_VFS_IOV_ITER)\n\t} else if (uio->uio_segflg == UIO_ITER) {\n\t\tiov_iter_advance(uio->uio_iter, n);\n#endif\n\t} else {\n\t\tuio->uio_skip += n;\n\t\twhile (uio->uio_iovcnt &&\n\t\t    uio->uio_skip >= uio->uio_iov->iov_len) {\n\t\t\tuio->uio_skip -= uio->uio_iov->iov_len;\n\t\t\tuio->uio_iov++;\n\t\t\tuio->uio_iovcnt--;\n\t\t}\n\t}\n\tuio->uio_loffset += n;\n\tuio->uio_resid -= n;\n}\nEXPORT_SYMBOL(zfs_uioskip);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}