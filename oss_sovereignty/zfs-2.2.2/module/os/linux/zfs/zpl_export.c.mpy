{
  "module_name": "zpl_export.c",
  "hash_id": "78cb3eb498194663ecc2c191d69d470d95083f6575d936cd9d76a38b56618c50",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_export.c",
  "human_readable_source": " \n \n\n\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zpl.h>\n\n\nstatic int\n#ifdef HAVE_ENCODE_FH_WITH_INODE\nzpl_encode_fh(struct inode *ip, __u32 *fh, int *max_len, struct inode *parent)\n{\n#else\nzpl_encode_fh(struct dentry *dentry, __u32 *fh, int *max_len, int connectable)\n{\n\t \n\tstruct inode *ip = dentry->d_inode;\n#endif  \n\tfstrans_cookie_t cookie;\n\tushort_t empty_fid = 0;\n\tfid_t *fid;\n\tint len_bytes, rc;\n\n\tlen_bytes = *max_len * sizeof (__u32);\n\n\tif (len_bytes < offsetof(fid_t, fid_data)) {\n\t\tfid = (fid_t *)&empty_fid;\n\t} else {\n\t\tfid = (fid_t *)fh;\n\t\tfid->fid_len = len_bytes - offsetof(fid_t, fid_data);\n\t}\n\n\tcookie = spl_fstrans_mark();\n\n\tif (zfsctl_is_node(ip))\n\t\trc = zfsctl_fid(ip, fid);\n\telse\n\t\trc = zfs_fid(ip, fid);\n\n\tspl_fstrans_unmark(cookie);\n\tlen_bytes = offsetof(fid_t, fid_data) + fid->fid_len;\n\t*max_len = roundup(len_bytes, sizeof (__u32)) / sizeof (__u32);\n\n\treturn (rc == 0 ? FILEID_INO32_GEN : 255);\n}\n\nstatic struct dentry *\nzpl_fh_to_dentry(struct super_block *sb, struct fid *fh,\n    int fh_len, int fh_type)\n{\n\tfid_t *fid = (fid_t *)fh;\n\tfstrans_cookie_t cookie;\n\tstruct inode *ip;\n\tint len_bytes, rc;\n\n\tlen_bytes = fh_len * sizeof (__u32);\n\n\tif (fh_type != FILEID_INO32_GEN ||\n\t    len_bytes < offsetof(fid_t, fid_data) ||\n\t    len_bytes < offsetof(fid_t, fid_data) + fid->fid_len)\n\t\treturn (ERR_PTR(-EINVAL));\n\n\tcookie = spl_fstrans_mark();\n\trc = zfs_vget(sb, &ip, fid);\n\tspl_fstrans_unmark(cookie);\n\n\tif (rc) {\n\t\t \n\t\tif (rc == ENOENT)\n\t\t\trc = ESTALE;\n\n\t\treturn (ERR_PTR(-rc));\n\t}\n\n\tASSERT((ip != NULL) && !IS_ERR(ip));\n\n\treturn (d_obtain_alias(ip));\n}\n\nstatic struct dentry *\nzpl_get_parent(struct dentry *child)\n{\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tznode_t *zp;\n\tint error;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_lookup(ITOZ(child->d_inode), \"..\", &zp, 0, cr, NULL, NULL);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\tif (error)\n\t\treturn (ERR_PTR(error));\n\n\treturn (d_obtain_alias(ZTOI(zp)));\n}\n\nstatic int\nzpl_commit_metadata(struct inode *inode)\n{\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tif (zfsctl_is_node(inode))\n\t\treturn (0);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_fsync(ITOZ(inode), 0, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nconst struct export_operations zpl_export_operations = {\n\t.encode_fh\t\t= zpl_encode_fh,\n\t.fh_to_dentry\t\t= zpl_fh_to_dentry,\n\t.get_parent\t\t= zpl_get_parent,\n\t.commit_metadata\t= zpl_commit_metadata,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}