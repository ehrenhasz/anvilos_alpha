{
  "module_name": "zpl_xattr.c",
  "hash_id": "0e04ce2681c271ba99d9b474ecb3fd12d0c82bc6b36eb11ba2d0c0ded49284b2",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_xattr.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zap.h>\n#include <sys/vfs.h>\n#include <sys/zpl.h>\n#include <linux/vfs_compat.h>\n\nenum xattr_permission {\n\tXAPERM_DENY,\n\tXAPERM_ALLOW,\n\tXAPERM_COMPAT,\n};\n\ntypedef struct xattr_filldir {\n\tsize_t size;\n\tsize_t offset;\n\tchar *buf;\n\tstruct dentry *dentry;\n} xattr_filldir_t;\n\nstatic enum xattr_permission zpl_xattr_permission(xattr_filldir_t *,\n    const char *, int);\n\nstatic int zfs_xattr_compat = 0;\n\n \nstatic int\nzpl_xattr_filldir(xattr_filldir_t *xf, const char *name, int name_len)\n{\n\tenum xattr_permission perm;\n\n\t \n\tperm = zpl_xattr_permission(xf, name, name_len);\n\tif (perm == XAPERM_DENY)\n\t\treturn (0);\n\n\t \n\tif (perm == XAPERM_COMPAT) {\n\t\tif (xf->buf) {\n\t\t\tif (xf->offset + XATTR_USER_PREFIX_LEN + 1 > xf->size)\n\t\t\t\treturn (-ERANGE);\n\n\t\t\tmemcpy(xf->buf + xf->offset, XATTR_USER_PREFIX,\n\t\t\t    XATTR_USER_PREFIX_LEN);\n\t\t\txf->buf[xf->offset + XATTR_USER_PREFIX_LEN] = '\\0';\n\t\t}\n\n\t\txf->offset += XATTR_USER_PREFIX_LEN;\n\t}\n\n\t \n\tif (xf->buf) {\n\t\tif (xf->offset + name_len + 1 > xf->size)\n\t\t\treturn (-ERANGE);\n\n\t\tmemcpy(xf->buf + xf->offset, name, name_len);\n\t\txf->buf[xf->offset + name_len] = '\\0';\n\t}\n\n\txf->offset += (name_len + 1);\n\n\treturn (0);\n}\n\n \nstatic int\nzpl_xattr_readdir(struct inode *dxip, xattr_filldir_t *xf)\n{\n\tzap_cursor_t zc;\n\tzap_attribute_t\tzap;\n\tint error;\n\n\tzap_cursor_init(&zc, ITOZSB(dxip)->z_os, ITOZ(dxip)->z_id);\n\n\twhile ((error = -zap_cursor_retrieve(&zc, &zap)) == 0) {\n\n\t\tif (zap.za_integer_length != 8 || zap.za_num_integers != 1) {\n\t\t\terror = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\terror = zpl_xattr_filldir(xf, zap.za_name, strlen(zap.za_name));\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tzap_cursor_advance(&zc);\n\t}\n\n\tzap_cursor_fini(&zc);\n\n\tif (error == -ENOENT)\n\t\terror = 0;\n\n\treturn (error);\n}\n\nstatic ssize_t\nzpl_xattr_list_dir(xattr_filldir_t *xf, cred_t *cr)\n{\n\tstruct inode *ip = xf->dentry->d_inode;\n\tstruct inode *dxip = NULL;\n\tznode_t *dxzp;\n\tint error;\n\n\t \n\terror = -zfs_lookup(ITOZ(ip), NULL, &dxzp, LOOKUP_XATTR,\n\t    cr, NULL, NULL);\n\tif (error) {\n\t\tif (error == -ENOENT)\n\t\t\terror = 0;\n\n\t\treturn (error);\n\t}\n\n\tdxip = ZTOI(dxzp);\n\terror = zpl_xattr_readdir(dxip, xf);\n\tiput(dxip);\n\n\treturn (error);\n}\n\nstatic ssize_t\nzpl_xattr_list_sa(xattr_filldir_t *xf)\n{\n\tznode_t *zp = ITOZ(xf->dentry->d_inode);\n\tnvpair_t *nvp = NULL;\n\tint error = 0;\n\n\tmutex_enter(&zp->z_lock);\n\tif (zp->z_xattr_cached == NULL)\n\t\terror = -zfs_sa_get_xattr(zp);\n\tmutex_exit(&zp->z_lock);\n\n\tif (error)\n\t\treturn (error);\n\n\tASSERT(zp->z_xattr_cached);\n\n\twhile ((nvp = nvlist_next_nvpair(zp->z_xattr_cached, nvp)) != NULL) {\n\t\tASSERT3U(nvpair_type(nvp), ==, DATA_TYPE_BYTE_ARRAY);\n\n\t\terror = zpl_xattr_filldir(xf, nvpair_name(nvp),\n\t\t    strlen(nvpair_name(nvp)));\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\treturn (0);\n}\n\nssize_t\nzpl_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tznode_t *zp = ITOZ(dentry->d_inode);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\txattr_filldir_t xf = { buffer_size, 0, buffer, dentry };\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tint error = 0;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\tif ((error = zpl_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\tgoto out1;\n\trw_enter(&zp->z_xattr_lock, RW_READER);\n\n\tif (zfsvfs->z_use_sa && zp->z_is_sa) {\n\t\terror = zpl_xattr_list_sa(&xf);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = zpl_xattr_list_dir(&xf, cr);\n\tif (error)\n\t\tgoto out;\n\n\terror = xf.offset;\nout:\n\n\trw_exit(&zp->z_xattr_lock);\n\tzpl_exit(zfsvfs, FTAG);\nout1:\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\treturn (error);\n}\n\nstatic int\nzpl_xattr_get_dir(struct inode *ip, const char *name, void *value,\n    size_t size, cred_t *cr)\n{\n\tfstrans_cookie_t cookie;\n\tstruct inode *xip = NULL;\n\tznode_t *dxzp = NULL;\n\tznode_t *xzp = NULL;\n\tint error;\n\n\t \n\terror = -zfs_lookup(ITOZ(ip), NULL, &dxzp, LOOKUP_XATTR,\n\t    cr, NULL, NULL);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = -zfs_lookup(dxzp, (char *)name, &xzp, 0, cr, NULL, NULL);\n\tif (error)\n\t\tgoto out;\n\n\txip = ZTOI(xzp);\n\tif (!size) {\n\t\terror = i_size_read(xip);\n\t\tgoto out;\n\t}\n\n\tif (size < i_size_read(xip)) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tstruct iovec iov;\n\tiov.iov_base = (void *)value;\n\tiov.iov_len = size;\n\n\tzfs_uio_t uio;\n\tzfs_uio_iovec_init(&uio, &iov, 1, 0, UIO_SYSSPACE, size, 0);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_read(ITOZ(xip), &uio, 0, cr);\n\tspl_fstrans_unmark(cookie);\n\n\tif (error == 0)\n\t\terror = size - zfs_uio_resid(&uio);\nout:\n\tif (xzp)\n\t\tzrele(xzp);\n\n\tif (dxzp)\n\t\tzrele(dxzp);\n\n\treturn (error);\n}\n\nstatic int\nzpl_xattr_get_sa(struct inode *ip, const char *name, void *value, size_t size)\n{\n\tznode_t *zp = ITOZ(ip);\n\tuchar_t *nv_value;\n\tuint_t nv_size;\n\tint error = 0;\n\n\tASSERT(RW_LOCK_HELD(&zp->z_xattr_lock));\n\n\tmutex_enter(&zp->z_lock);\n\tif (zp->z_xattr_cached == NULL)\n\t\terror = -zfs_sa_get_xattr(zp);\n\tmutex_exit(&zp->z_lock);\n\n\tif (error)\n\t\treturn (error);\n\n\tASSERT(zp->z_xattr_cached);\n\terror = -nvlist_lookup_byte_array(zp->z_xattr_cached, name,\n\t    &nv_value, &nv_size);\n\tif (error)\n\t\treturn (error);\n\n\tif (size == 0 || value == NULL)\n\t\treturn (nv_size);\n\n\tif (size < nv_size)\n\t\treturn (-ERANGE);\n\n\tmemcpy(value, nv_value, nv_size);\n\n\treturn (nv_size);\n}\n\nstatic int\n__zpl_xattr_get(struct inode *ip, const char *name, void *value, size_t size,\n    cred_t *cr)\n{\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\tASSERT(RW_LOCK_HELD(&zp->z_xattr_lock));\n\n\tif (zfsvfs->z_use_sa && zp->z_is_sa) {\n\t\terror = zpl_xattr_get_sa(ip, name, value, size);\n\t\tif (error != -ENOENT)\n\t\t\tgoto out;\n\t}\n\n\terror = zpl_xattr_get_dir(ip, name, value, size, cr);\nout:\n\tif (error == -ENOENT)\n\t\terror = -ENODATA;\n\n\treturn (error);\n}\n\n#define\tXATTR_NOENT\t0x0\n#define\tXATTR_IN_SA\t0x1\n#define\tXATTR_IN_DIR\t0x2\n \nstatic int\n__zpl_xattr_where(struct inode *ip, const char *name, int *where, cred_t *cr)\n{\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\tASSERT(where);\n\tASSERT(RW_LOCK_HELD(&zp->z_xattr_lock));\n\n\t*where = XATTR_NOENT;\n\tif (zfsvfs->z_use_sa && zp->z_is_sa) {\n\t\terror = zpl_xattr_get_sa(ip, name, NULL, 0);\n\t\tif (error >= 0)\n\t\t\t*where |= XATTR_IN_SA;\n\t\telse if (error != -ENOENT)\n\t\t\treturn (error);\n\t}\n\n\terror = zpl_xattr_get_dir(ip, name, NULL, 0, cr);\n\tif (error >= 0)\n\t\t*where |= XATTR_IN_DIR;\n\telse if (error != -ENOENT)\n\t\treturn (error);\n\n\tif (*where == (XATTR_IN_SA|XATTR_IN_DIR))\n\t\tcmn_err(CE_WARN, \"ZFS: inode %p has xattr \\\"%s\\\"\"\n\t\t    \" in both SA and dir\", ip, name);\n\tif (*where == XATTR_NOENT)\n\t\terror = -ENODATA;\n\telse\n\t\terror = 0;\n\treturn (error);\n}\n\nstatic int\nzpl_xattr_get(struct inode *ip, const char *name, void *value, size_t size)\n{\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\tif ((error = zpl_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\tgoto out;\n\trw_enter(&zp->z_xattr_lock, RW_READER);\n\terror = __zpl_xattr_get(ip, name, value, size, cr);\n\trw_exit(&zp->z_xattr_lock);\n\tzpl_exit(zfsvfs, FTAG);\nout:\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\treturn (error);\n}\n\nstatic int\nzpl_xattr_set_dir(struct inode *ip, const char *name, const void *value,\n    size_t size, int flags, cred_t *cr)\n{\n\tznode_t *dxzp = NULL;\n\tznode_t *xzp = NULL;\n\tvattr_t *vap = NULL;\n\tint lookup_flags, error;\n\tconst int xattr_mode = S_IFREG | 0644;\n\tloff_t pos = 0;\n\n\t \n\tlookup_flags = LOOKUP_XATTR;\n\tif (value != NULL)\n\t\tlookup_flags |= CREATE_XATTR_DIR;\n\n\terror = -zfs_lookup(ITOZ(ip), NULL, &dxzp, lookup_flags,\n\t    cr, NULL, NULL);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = -zfs_lookup(dxzp, (char *)name, &xzp, 0, cr, NULL, NULL);\n\tif (error && (error != -ENOENT))\n\t\tgoto out;\n\n\terror = 0;\n\n\t \n\tif (value == NULL) {\n\t\tif (xzp)\n\t\t\terror = -zfs_remove(dxzp, (char *)name, cr, 0);\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (xzp == NULL) {\n\t\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\t\tvap->va_mode = xattr_mode;\n\t\tvap->va_mask = ATTR_MODE;\n\t\tvap->va_uid = crgetuid(cr);\n\t\tvap->va_gid = crgetgid(cr);\n\n\t\terror = -zfs_create(dxzp, (char *)name, vap, 0, 0644, &xzp,\n\t\t    cr, ATTR_NOACLCHECK, NULL, zfs_init_idmap);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tASSERT(xzp != NULL);\n\n\terror = -zfs_freesp(xzp, 0, 0, xattr_mode, TRUE);\n\tif (error)\n\t\tgoto out;\n\n\terror = -zfs_write_simple(xzp, value, size, pos, NULL);\nout:\n\tif (error == 0) {\n\t\tzpl_inode_set_ctime_to_ts(ip, current_time(ip));\n\t\tzfs_mark_inode_dirty(ip);\n\t}\n\n\tif (vap)\n\t\tkmem_free(vap, sizeof (vattr_t));\n\n\tif (xzp)\n\t\tzrele(xzp);\n\n\tif (dxzp)\n\t\tzrele(dxzp);\n\n\tif (error == -ENOENT)\n\t\terror = -ENODATA;\n\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_xattr_set_sa(struct inode *ip, const char *name, const void *value,\n    size_t size, int flags, cred_t *cr)\n{\n\tznode_t *zp = ITOZ(ip);\n\tnvlist_t *nvl;\n\tsize_t sa_size;\n\tint error = 0;\n\n\tmutex_enter(&zp->z_lock);\n\tif (zp->z_xattr_cached == NULL)\n\t\terror = -zfs_sa_get_xattr(zp);\n\tmutex_exit(&zp->z_lock);\n\n\tif (error)\n\t\treturn (error);\n\n\tASSERT(zp->z_xattr_cached);\n\tnvl = zp->z_xattr_cached;\n\n\tif (value == NULL) {\n\t\terror = -nvlist_remove(nvl, name, DATA_TYPE_BYTE_ARRAY);\n\t\tif (error == -ENOENT)\n\t\t\terror = zpl_xattr_set_dir(ip, name, NULL, 0, flags, cr);\n\t} else {\n\t\t \n\t\tif (size > DXATTR_MAX_ENTRY_SIZE)\n\t\t\treturn (-EFBIG);\n\n\t\t \n\t\terror = -nvlist_size(nvl, &sa_size, NV_ENCODE_XDR);\n\t\tif (error)\n\t\t\treturn (error);\n\n\t\tif (sa_size > DXATTR_MAX_SA_SIZE)\n\t\t\treturn (-EFBIG);\n\n\t\terror = -nvlist_add_byte_array(nvl, name,\n\t\t    (uchar_t *)value, size);\n\t}\n\n\t \n\tif (error == 0)\n\t\terror = -zfs_sa_set_xattr(zp, name, value, size);\n\n\tif (error) {\n\t\tnvlist_free(nvl);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_xattr_set(struct inode *ip, const char *name, const void *value,\n    size_t size, int flags)\n{\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tint where;\n\tint error;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\tif ((error = zpl_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\tgoto out1;\n\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\n\t \n\terror = __zpl_xattr_where(ip, name, &where, cr);\n\tif (error < 0) {\n\t\tif (error != -ENODATA)\n\t\t\tgoto out;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto out;\n\n\t\t \n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (zfsvfs->z_use_sa && zp->z_is_sa &&\n\t    (zfsvfs->z_xattr_sa || (value == NULL && where & XATTR_IN_SA))) {\n\t\terror = zpl_xattr_set_sa(ip, name, value, size, flags, cr);\n\t\tif (error == 0) {\n\t\t\t \n\t\t\tif (where & XATTR_IN_DIR)\n\t\t\t\tzpl_xattr_set_dir(ip, name, NULL, 0, 0, cr);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = zpl_xattr_set_dir(ip, name, value, size, flags, cr);\n\t \n\tif (error == 0 && (where & XATTR_IN_SA))\n\t\tzpl_xattr_set_sa(ip, name, NULL, 0, 0, cr);\nout:\n\trw_exit(&zp->z_xattr_lock);\n\tzpl_exit(zfsvfs, FTAG);\nout1:\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n \nstatic int\n__zpl_xattr_user_list(struct inode *ip, char *list, size_t list_size,\n    const char *name, size_t name_len)\n{\n\treturn (ITOZSB(ip)->z_flags & ZSB_XATTR);\n}\nZPL_XATTR_LIST_WRAPPER(zpl_xattr_user_list);\n\nstatic int\n__zpl_xattr_user_get(struct inode *ip, const char *name,\n    void *value, size_t size)\n{\n\tint error;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") == 0)\n\t\treturn (-EINVAL);\n#endif\n\tif (ZFS_XA_NS_PREFIX_FORBIDDEN(name))\n\t\treturn (-EINVAL);\n\tif (!(ITOZSB(ip)->z_flags & ZSB_XATTR))\n\t\treturn (-EOPNOTSUPP);\n\n\t \n\tchar *xattr_name = kmem_asprintf(\"%s%s\", XATTR_USER_PREFIX, name);\n\terror = zpl_xattr_get(ip, xattr_name, value, size);\n\tkmem_strfree(xattr_name);\n\tif (error == -ENODATA)\n\t\terror = zpl_xattr_get(ip, name, value, size);\n\n\treturn (error);\n}\nZPL_XATTR_GET_WRAPPER(zpl_xattr_user_get);\n\nstatic int\n__zpl_xattr_user_set(zidmap_t *user_ns,\n    struct inode *ip, const char *name,\n    const void *value, size_t size, int flags)\n{\n\t(void) user_ns;\n\tint error = 0;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") == 0)\n\t\treturn (-EINVAL);\n#endif\n\tif (ZFS_XA_NS_PREFIX_FORBIDDEN(name))\n\t\treturn (-EINVAL);\n\tif (!(ITOZSB(ip)->z_flags & ZSB_XATTR))\n\t\treturn (-EOPNOTSUPP);\n\n\t \n\tchar *prefixed_name = kmem_asprintf(\"%s%s\", XATTR_USER_PREFIX, name);\n\tconst char *clear_name, *set_name;\n\tif (zfs_xattr_compat) {\n\t\tclear_name = prefixed_name;\n\t\tset_name = name;\n\t} else {\n\t\tclear_name = name;\n\t\tset_name = prefixed_name;\n\t}\n\t \n\terror = zpl_xattr_set(ip, clear_name, NULL, 0, flags);\n\t \n\tif (error == -EEXIST)\n\t\tgoto out;\n\t \n\tif (error == 0)\n\t\tflags &= ~XATTR_REPLACE;\n\t \n\terror = zpl_xattr_set(ip, set_name, value, size, flags);\nout:\n\tkmem_strfree(prefixed_name);\n\treturn (error);\n}\nZPL_XATTR_SET_WRAPPER(zpl_xattr_user_set);\n\nstatic xattr_handler_t zpl_xattr_user_handler =\n{\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.list\t= zpl_xattr_user_list,\n\t.get\t= zpl_xattr_user_get,\n\t.set\t= zpl_xattr_user_set,\n};\n\n \nstatic int\n__zpl_xattr_trusted_list(struct inode *ip, char *list, size_t list_size,\n    const char *name, size_t name_len)\n{\n\treturn (capable(CAP_SYS_ADMIN));\n}\nZPL_XATTR_LIST_WRAPPER(zpl_xattr_trusted_list);\n\nstatic int\n__zpl_xattr_trusted_get(struct inode *ip, const char *name,\n    void *value, size_t size)\n{\n\tchar *xattr_name;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn (-EACCES);\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") == 0)\n\t\treturn (-EINVAL);\n#endif\n\txattr_name = kmem_asprintf(\"%s%s\", XATTR_TRUSTED_PREFIX, name);\n\terror = zpl_xattr_get(ip, xattr_name, value, size);\n\tkmem_strfree(xattr_name);\n\n\treturn (error);\n}\nZPL_XATTR_GET_WRAPPER(zpl_xattr_trusted_get);\n\nstatic int\n__zpl_xattr_trusted_set(zidmap_t *user_ns,\n    struct inode *ip, const char *name,\n    const void *value, size_t size, int flags)\n{\n\t(void) user_ns;\n\tchar *xattr_name;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn (-EACCES);\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") == 0)\n\t\treturn (-EINVAL);\n#endif\n\txattr_name = kmem_asprintf(\"%s%s\", XATTR_TRUSTED_PREFIX, name);\n\terror = zpl_xattr_set(ip, xattr_name, value, size, flags);\n\tkmem_strfree(xattr_name);\n\n\treturn (error);\n}\nZPL_XATTR_SET_WRAPPER(zpl_xattr_trusted_set);\n\nstatic xattr_handler_t zpl_xattr_trusted_handler = {\n\t.prefix\t= XATTR_TRUSTED_PREFIX,\n\t.list\t= zpl_xattr_trusted_list,\n\t.get\t= zpl_xattr_trusted_get,\n\t.set\t= zpl_xattr_trusted_set,\n};\n\n \nstatic int\n__zpl_xattr_security_list(struct inode *ip, char *list, size_t list_size,\n    const char *name, size_t name_len)\n{\n\treturn (1);\n}\nZPL_XATTR_LIST_WRAPPER(zpl_xattr_security_list);\n\nstatic int\n__zpl_xattr_security_get(struct inode *ip, const char *name,\n    void *value, size_t size)\n{\n\tchar *xattr_name;\n\tint error;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") == 0)\n\t\treturn (-EINVAL);\n#endif\n\txattr_name = kmem_asprintf(\"%s%s\", XATTR_SECURITY_PREFIX, name);\n\terror = zpl_xattr_get(ip, xattr_name, value, size);\n\tkmem_strfree(xattr_name);\n\n\treturn (error);\n}\nZPL_XATTR_GET_WRAPPER(zpl_xattr_security_get);\n\nstatic int\n__zpl_xattr_security_set(zidmap_t *user_ns,\n    struct inode *ip, const char *name,\n    const void *value, size_t size, int flags)\n{\n\t(void) user_ns;\n\tchar *xattr_name;\n\tint error;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") == 0)\n\t\treturn (-EINVAL);\n#endif\n\txattr_name = kmem_asprintf(\"%s%s\", XATTR_SECURITY_PREFIX, name);\n\terror = zpl_xattr_set(ip, xattr_name, value, size, flags);\n\tkmem_strfree(xattr_name);\n\n\treturn (error);\n}\nZPL_XATTR_SET_WRAPPER(zpl_xattr_security_set);\n\nstatic int\nzpl_xattr_security_init_impl(struct inode *ip, const struct xattr *xattrs,\n    void *fs_info)\n{\n\tconst struct xattr *xattr;\n\tint error = 0;\n\n\tfor (xattr = xattrs; xattr->name != NULL; xattr++) {\n\t\terror = __zpl_xattr_security_set(NULL, ip,\n\t\t    xattr->name, xattr->value, xattr->value_len, 0);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}\n\nint\nzpl_xattr_security_init(struct inode *ip, struct inode *dip,\n    const struct qstr *qstr)\n{\n\treturn security_inode_init_security(ip, dip, qstr,\n\t    &zpl_xattr_security_init_impl, NULL);\n}\n\n \nstatic xattr_handler_t zpl_xattr_security_handler = {\n\t.prefix\t= XATTR_SECURITY_PREFIX,\n\t.list\t= zpl_xattr_security_list,\n\t.get\t= zpl_xattr_security_get,\n\t.set\t= zpl_xattr_security_set,\n};\n\n \n#ifdef CONFIG_FS_POSIX_ACL\nstatic int\nzpl_set_acl_impl(struct inode *ip, struct posix_acl *acl, int type)\n{\n\tchar *name, *value = NULL;\n\tint error = 0;\n\tsize_t size = 0;\n\n\tif (S_ISLNK(ip->i_mode))\n\t\treturn (-EOPNOTSUPP);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = ip->i_mode;\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\treturn (error);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (ip->i_mode != mode) {\n\t\t\t\t\tip->i_mode = ITOZ(ip)->z_mode = mode;\n\t\t\t\t\tzpl_inode_set_ctime_to_ts(ip,\n\t\t\t\t\t    current_time(ip));\n\t\t\t\t\tzfs_mark_inode_dirty(ip);\n\t\t\t\t}\n\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(ip->i_mode))\n\t\t\treturn (acl ? -EACCES : 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (-EINVAL);\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmem_alloc(size, KM_SLEEP);\n\n\t\terror = zpl_acl_to_xattr(acl, value, size);\n\t\tif (error < 0) {\n\t\t\tkmem_free(value, size);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\terror = zpl_xattr_set(ip, name, value, size, 0);\n\tif (value)\n\t\tkmem_free(value, size);\n\n\tif (!error) {\n\t\tif (acl)\n\t\t\tzpl_set_cached_acl(ip, type, acl);\n\t\telse\n\t\t\tzpl_forget_cached_acl(ip, type);\n\t}\n\n\treturn (error);\n}\n\n#ifdef HAVE_SET_ACL\nint\n#ifdef HAVE_SET_ACL_USERNS\nzpl_set_acl(struct user_namespace *userns, struct inode *ip,\n    struct posix_acl *acl, int type)\n#elif defined(HAVE_SET_ACL_IDMAP_DENTRY)\nzpl_set_acl(struct mnt_idmap *userns, struct dentry *dentry,\n    struct posix_acl *acl, int type)\n#elif defined(HAVE_SET_ACL_USERNS_DENTRY_ARG2)\nzpl_set_acl(struct user_namespace *userns, struct dentry *dentry,\n    struct posix_acl *acl, int type)\n#else\nzpl_set_acl(struct inode *ip, struct posix_acl *acl, int type)\n#endif  \n{\n#ifdef HAVE_SET_ACL_USERNS_DENTRY_ARG2\n\treturn (zpl_set_acl_impl(d_inode(dentry), acl, type));\n#elif defined(HAVE_SET_ACL_IDMAP_DENTRY)\n\treturn (zpl_set_acl_impl(d_inode(dentry), acl, type));\n#else\n\treturn (zpl_set_acl_impl(ip, acl, type));\n#endif  \n}\n#endif  \n\nstatic struct posix_acl *\nzpl_get_acl_impl(struct inode *ip, int type)\n{\n\tstruct posix_acl *acl;\n\tvoid *value = NULL;\n\tchar *name;\n\n\t \n#ifndef HAVE_KERNEL_GET_ACL_HANDLE_CACHE\n\tacl = get_cached_acl(ip, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn (acl);\n#endif\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn (ERR_PTR(-EINVAL));\n\t}\n\n\tint size = zpl_xattr_get(ip, name, NULL, 0);\n\tif (size > 0) {\n\t\tvalue = kmem_alloc(size, KM_SLEEP);\n\t\tsize = zpl_xattr_get(ip, name, value, size);\n\t}\n\n\tif (size > 0) {\n\t\tacl = zpl_acl_from_xattr(value, size);\n\t} else if (size == -ENODATA || size == -ENOSYS) {\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(-EIO);\n\t}\n\n\tif (size > 0)\n\t\tkmem_free(value, size);\n\n\t \n#ifndef HAVE_KERNEL_GET_ACL_HANDLE_CACHE\n\tif (!IS_ERR(acl))\n\t\tzpl_set_cached_acl(ip, type, acl);\n#endif\n\n\treturn (acl);\n}\n\n#if defined(HAVE_GET_ACL_RCU) || defined(HAVE_GET_INODE_ACL)\nstruct posix_acl *\nzpl_get_acl(struct inode *ip, int type, bool rcu)\n{\n\tif (rcu)\n\t\treturn (ERR_PTR(-ECHILD));\n\n\treturn (zpl_get_acl_impl(ip, type));\n}\n#elif defined(HAVE_GET_ACL)\nstruct posix_acl *\nzpl_get_acl(struct inode *ip, int type)\n{\n\treturn (zpl_get_acl_impl(ip, type));\n}\n#else\n#error \"Unsupported iops->get_acl() implementation\"\n#endif  \n\nint\nzpl_init_acl(struct inode *ip, struct inode *dir)\n{\n\tstruct posix_acl *acl = NULL;\n\tint error = 0;\n\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (0);\n\n\tif (!S_ISLNK(ip->i_mode)) {\n\t\tacl = zpl_get_acl_impl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn (PTR_ERR(acl));\n\t\tif (!acl) {\n\t\t\tITOZ(ip)->z_mode = (ip->i_mode &= ~current_umask());\n\t\t\tzpl_inode_set_ctime_to_ts(ip, current_time(ip));\n\t\t\tzfs_mark_inode_dirty(ip);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif (acl) {\n\t\tumode_t mode;\n\n\t\tif (S_ISDIR(ip->i_mode)) {\n\t\t\terror = zpl_set_acl_impl(ip, acl, ACL_TYPE_DEFAULT);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tmode = ip->i_mode;\n\t\terror = __posix_acl_create(&acl, GFP_KERNEL, &mode);\n\t\tif (error >= 0) {\n\t\t\tip->i_mode = ITOZ(ip)->z_mode = mode;\n\t\t\tzfs_mark_inode_dirty(ip);\n\t\t\tif (error > 0) {\n\t\t\t\terror = zpl_set_acl_impl(ip, acl,\n\t\t\t\t    ACL_TYPE_ACCESS);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tzpl_posix_acl_release(acl);\n\n\treturn (error);\n}\n\nint\nzpl_chmod_acl(struct inode *ip)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (0);\n\n\tif (S_ISLNK(ip->i_mode))\n\t\treturn (-EOPNOTSUPP);\n\n\tacl = zpl_get_acl_impl(ip, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl) || !acl)\n\t\treturn (PTR_ERR(acl));\n\n\terror = __posix_acl_chmod(&acl, GFP_KERNEL, ip->i_mode);\n\tif (!error)\n\t\terror = zpl_set_acl_impl(ip, acl, ACL_TYPE_ACCESS);\n\n\tzpl_posix_acl_release(acl);\n\n\treturn (error);\n}\n\nstatic int\n__zpl_xattr_acl_list_access(struct inode *ip, char *list, size_t list_size,\n    const char *name, size_t name_len)\n{\n\tchar *xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\tsize_t xattr_size = sizeof (XATTR_NAME_POSIX_ACL_ACCESS);\n\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (0);\n\n\tif (list && xattr_size <= list_size)\n\t\tmemcpy(list, xattr_name, xattr_size);\n\n\treturn (xattr_size);\n}\nZPL_XATTR_LIST_WRAPPER(zpl_xattr_acl_list_access);\n\nstatic int\n__zpl_xattr_acl_list_default(struct inode *ip, char *list, size_t list_size,\n    const char *name, size_t name_len)\n{\n\tchar *xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\tsize_t xattr_size = sizeof (XATTR_NAME_POSIX_ACL_DEFAULT);\n\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (0);\n\n\tif (list && xattr_size <= list_size)\n\t\tmemcpy(list, xattr_name, xattr_size);\n\n\treturn (xattr_size);\n}\nZPL_XATTR_LIST_WRAPPER(zpl_xattr_acl_list_default);\n\nstatic int\n__zpl_xattr_acl_get_access(struct inode *ip, const char *name,\n    void *buffer, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint type = ACL_TYPE_ACCESS;\n\tint error;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") != 0)\n\t\treturn (-EINVAL);\n#endif\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (-EOPNOTSUPP);\n\n\tacl = zpl_get_acl_impl(ip, type);\n\tif (IS_ERR(acl))\n\t\treturn (PTR_ERR(acl));\n\tif (acl == NULL)\n\t\treturn (-ENODATA);\n\n\terror = zpl_acl_to_xattr(acl, buffer, size);\n\tzpl_posix_acl_release(acl);\n\n\treturn (error);\n}\nZPL_XATTR_GET_WRAPPER(zpl_xattr_acl_get_access);\n\nstatic int\n__zpl_xattr_acl_get_default(struct inode *ip, const char *name,\n    void *buffer, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint type = ACL_TYPE_DEFAULT;\n\tint error;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") != 0)\n\t\treturn (-EINVAL);\n#endif\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (-EOPNOTSUPP);\n\n\tacl = zpl_get_acl_impl(ip, type);\n\tif (IS_ERR(acl))\n\t\treturn (PTR_ERR(acl));\n\tif (acl == NULL)\n\t\treturn (-ENODATA);\n\n\terror = zpl_acl_to_xattr(acl, buffer, size);\n\tzpl_posix_acl_release(acl);\n\n\treturn (error);\n}\nZPL_XATTR_GET_WRAPPER(zpl_xattr_acl_get_default);\n\nstatic int\n__zpl_xattr_acl_set_access(zidmap_t *mnt_ns,\n    struct inode *ip, const char *name,\n    const void *value, size_t size, int flags)\n{\n\tstruct posix_acl *acl;\n\tint type = ACL_TYPE_ACCESS;\n\tint error = 0;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") != 0)\n\t\treturn (-EINVAL);\n#endif\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (-EOPNOTSUPP);\n\n#if defined(HAVE_XATTR_SET_USERNS) || defined(HAVE_XATTR_SET_IDMAP)\n\tif (!zpl_inode_owner_or_capable(mnt_ns, ip))\n\t\treturn (-EPERM);\n#else\n\t(void) mnt_ns;\n\tif (!zpl_inode_owner_or_capable(zfs_init_idmap, ip))\n\t\treturn (-EPERM);\n#endif\n\n\tif (value) {\n\t\tacl = zpl_acl_from_xattr(value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn (PTR_ERR(acl));\n\t\telse if (acl) {\n\t\t\terror = zpl_posix_acl_valid(ip, acl);\n\t\t\tif (error) {\n\t\t\t\tzpl_posix_acl_release(acl);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tacl = NULL;\n\t}\n\terror = zpl_set_acl_impl(ip, acl, type);\n\tzpl_posix_acl_release(acl);\n\n\treturn (error);\n}\nZPL_XATTR_SET_WRAPPER(zpl_xattr_acl_set_access);\n\nstatic int\n__zpl_xattr_acl_set_default(zidmap_t *mnt_ns,\n    struct inode *ip, const char *name,\n    const void *value, size_t size, int flags)\n{\n\tstruct posix_acl *acl;\n\tint type = ACL_TYPE_DEFAULT;\n\tint error = 0;\n\t \n#ifndef HAVE_XATTR_HANDLER_NAME\n\tif (strcmp(name, \"\") != 0)\n\t\treturn (-EINVAL);\n#endif\n\tif (ITOZSB(ip)->z_acl_type != ZFS_ACLTYPE_POSIX)\n\t\treturn (-EOPNOTSUPP);\n\n#if defined(HAVE_XATTR_SET_USERNS) || defined(HAVE_XATTR_SET_IDMAP)\n\tif (!zpl_inode_owner_or_capable(mnt_ns, ip))\n\t\treturn (-EPERM);\n#else\n\t(void) mnt_ns;\n\tif (!zpl_inode_owner_or_capable(zfs_init_idmap, ip))\n\t\treturn (-EPERM);\n#endif\n\n\tif (value) {\n\t\tacl = zpl_acl_from_xattr(value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn (PTR_ERR(acl));\n\t\telse if (acl) {\n\t\t\terror = zpl_posix_acl_valid(ip, acl);\n\t\t\tif (error) {\n\t\t\t\tzpl_posix_acl_release(acl);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tacl = NULL;\n\t}\n\n\terror = zpl_set_acl_impl(ip, acl, type);\n\tzpl_posix_acl_release(acl);\n\n\treturn (error);\n}\nZPL_XATTR_SET_WRAPPER(zpl_xattr_acl_set_default);\n\n \nstatic xattr_handler_t zpl_xattr_acl_access_handler = {\n#ifdef HAVE_XATTR_HANDLER_NAME\n\t.name\t= XATTR_NAME_POSIX_ACL_ACCESS,\n#else\n\t.prefix\t= XATTR_NAME_POSIX_ACL_ACCESS,\n#endif\n\t.list\t= zpl_xattr_acl_list_access,\n\t.get\t= zpl_xattr_acl_get_access,\n\t.set\t= zpl_xattr_acl_set_access,\n#if defined(HAVE_XATTR_LIST_SIMPLE) || \\\n    defined(HAVE_XATTR_LIST_DENTRY) || \\\n    defined(HAVE_XATTR_LIST_HANDLER)\n\t.flags\t= ACL_TYPE_ACCESS,\n#endif\n};\n\n \nstatic xattr_handler_t zpl_xattr_acl_default_handler = {\n#ifdef HAVE_XATTR_HANDLER_NAME\n\t.name\t= XATTR_NAME_POSIX_ACL_DEFAULT,\n#else\n\t.prefix\t= XATTR_NAME_POSIX_ACL_DEFAULT,\n#endif\n\t.list\t= zpl_xattr_acl_list_default,\n\t.get\t= zpl_xattr_acl_get_default,\n\t.set\t= zpl_xattr_acl_set_default,\n#if defined(HAVE_XATTR_LIST_SIMPLE) || \\\n    defined(HAVE_XATTR_LIST_DENTRY) || \\\n    defined(HAVE_XATTR_LIST_HANDLER)\n\t.flags\t= ACL_TYPE_DEFAULT,\n#endif\n};\n\n#endif  \n\nxattr_handler_t *zpl_xattr_handlers[] = {\n\t&zpl_xattr_security_handler,\n\t&zpl_xattr_trusted_handler,\n\t&zpl_xattr_user_handler,\n#ifdef CONFIG_FS_POSIX_ACL\n\t&zpl_xattr_acl_access_handler,\n\t&zpl_xattr_acl_default_handler,\n#endif  \n\tNULL\n};\n\nstatic const struct xattr_handler *\nzpl_xattr_handler(const char *name)\n{\n\tif (strncmp(name, XATTR_USER_PREFIX,\n\t    XATTR_USER_PREFIX_LEN) == 0)\n\t\treturn (&zpl_xattr_user_handler);\n\n\tif (strncmp(name, XATTR_TRUSTED_PREFIX,\n\t    XATTR_TRUSTED_PREFIX_LEN) == 0)\n\t\treturn (&zpl_xattr_trusted_handler);\n\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t    XATTR_SECURITY_PREFIX_LEN) == 0)\n\t\treturn (&zpl_xattr_security_handler);\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS,\n\t    sizeof (XATTR_NAME_POSIX_ACL_ACCESS)) == 0)\n\t\treturn (&zpl_xattr_acl_access_handler);\n\n\tif (strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,\n\t    sizeof (XATTR_NAME_POSIX_ACL_DEFAULT)) == 0)\n\t\treturn (&zpl_xattr_acl_default_handler);\n#endif  \n\n\treturn (NULL);\n}\n\nstatic enum xattr_permission\nzpl_xattr_permission(xattr_filldir_t *xf, const char *name, int name_len)\n{\n\tconst struct xattr_handler *handler;\n\tstruct dentry *d __maybe_unused = xf->dentry;\n\tenum xattr_permission perm = XAPERM_ALLOW;\n\n\thandler = zpl_xattr_handler(name);\n\tif (handler == NULL) {\n\t\t \n\t\tif (ZFS_XA_NS_PREFIX_MATCH(FREEBSD, name))\n\t\t\treturn (XAPERM_DENY);\n\t\t \n\t\tperm = XAPERM_COMPAT;\n\t\thandler = &zpl_xattr_user_handler;\n\t}\n\n\tif (handler->list) {\n#if defined(HAVE_XATTR_LIST_SIMPLE)\n\t\tif (!handler->list(d))\n\t\t\treturn (XAPERM_DENY);\n#elif defined(HAVE_XATTR_LIST_DENTRY)\n\t\tif (!handler->list(d, NULL, 0, name, name_len, 0))\n\t\t\treturn (XAPERM_DENY);\n#elif defined(HAVE_XATTR_LIST_HANDLER)\n\t\tif (!handler->list(handler, d, NULL, 0, name, name_len))\n\t\t\treturn (XAPERM_DENY);\n#endif\n\t}\n\n\treturn (perm);\n}\n\n#if defined(CONFIG_FS_POSIX_ACL) && \\\n\t(!defined(HAVE_POSIX_ACL_RELEASE) || \\\n\t\tdefined(HAVE_POSIX_ACL_RELEASE_GPL_ONLY))\nstruct acl_rel_struct {\n\tstruct acl_rel_struct *next;\n\tstruct posix_acl *acl;\n\tclock_t time;\n};\n\n#define\tACL_REL_GRACE\t(60*HZ)\n#define\tACL_REL_WINDOW\t(1*HZ)\n#define\tACL_REL_SCHED\t(ACL_REL_GRACE+ACL_REL_WINDOW)\n\n \nstatic struct acl_rel_struct *acl_rel_head = NULL;\nstatic struct acl_rel_struct **acl_rel_tail = &acl_rel_head;\n\nstatic void\nzpl_posix_acl_free(void *arg)\n{\n\tstruct acl_rel_struct *freelist = NULL;\n\tstruct acl_rel_struct *a;\n\tclock_t new_time;\n\tboolean_t refire = B_FALSE;\n\n\tASSERT3P(acl_rel_head, !=, NULL);\n\twhile (acl_rel_head) {\n\t\ta = acl_rel_head;\n\t\tif (ddi_get_lbolt() - a->time >= ACL_REL_GRACE) {\n\t\t\t \n\t\t\tif (acl_rel_tail == &a->next) {\n\t\t\t\tacl_rel_head = NULL;\n\t\t\t\tif (cmpxchg(&acl_rel_tail, &a->next,\n\t\t\t\t    &acl_rel_head) == &a->next) {\n\t\t\t\t\tASSERT3P(a->next, ==, NULL);\n\t\t\t\t\ta->next = freelist;\n\t\t\t\t\tfreelist = a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\twhile (READ_ONCE(a->next) == NULL)\n\t\t\t\tcpu_relax();\n\t\t\tacl_rel_head = a->next;\n\t\t\ta->next = freelist;\n\t\t\tfreelist = a;\n\t\t} else {\n\t\t\t \n\t\t\tnew_time = a->time + ACL_REL_SCHED;\n\t\t\trefire = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (refire)\n\t\ttaskq_dispatch_delay(system_delay_taskq, zpl_posix_acl_free,\n\t\t    NULL, TQ_SLEEP, new_time);\n\n\twhile (freelist) {\n\t\ta = freelist;\n\t\tfreelist = a->next;\n\t\tkfree(a->acl);\n\t\tkmem_free(a, sizeof (struct acl_rel_struct));\n\t}\n}\n\nvoid\nzpl_posix_acl_release_impl(struct posix_acl *acl)\n{\n\tstruct acl_rel_struct *a, **prev;\n\n\ta = kmem_alloc(sizeof (struct acl_rel_struct), KM_SLEEP);\n\ta->next = NULL;\n\ta->acl = acl;\n\ta->time = ddi_get_lbolt();\n\t \n\tprev = xchg(&acl_rel_tail, &a->next);\n\tASSERT3P(*prev, ==, NULL);\n\t*prev = a;\n\t \n\tif (prev == &acl_rel_head)\n\t\ttaskq_dispatch_delay(system_delay_taskq, zpl_posix_acl_free,\n\t\t    NULL, TQ_SLEEP, ddi_get_lbolt() + ACL_REL_SCHED);\n}\n#endif\n\nZFS_MODULE_PARAM(zfs, zfs_, xattr_compat, INT, ZMOD_RW,\n\t\"Use legacy ZFS xattr naming for writing new user namespace xattrs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}