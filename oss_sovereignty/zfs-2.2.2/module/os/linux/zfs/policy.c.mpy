{
  "module_name": "policy.c",
  "hash_id": "b3d9b961df3ef964d2bd40d101062f7ec42de1c27b840d72db676607238226a4",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/policy.c",
  "human_readable_source": " \n\n \n\n#include <sys/policy.h>\n#include <linux/security.h>\n#include <linux/vfs_compat.h>\n\n \nstatic int\npriv_policy_ns(const cred_t *cr, int capability, int err,\n    struct user_namespace *ns)\n{\n\tif (cr != CRED() && (cr != kcred))\n\t\treturn (err);\n\n#if defined(CONFIG_USER_NS)\n\tif (!(ns ? ns_capable(ns, capability) : capable(capability)))\n#else\n\tif (!capable(capability))\n#endif\n\t\treturn (err);\n\n\treturn (0);\n}\n\nstatic int\npriv_policy(const cred_t *cr, int capability, int err)\n{\n\treturn (priv_policy_ns(cr, capability, err, cr->user_ns));\n}\n\nstatic int\npriv_policy_user(const cred_t *cr, int capability, int err)\n{\n\t \n#if defined(CONFIG_USER_NS)\n\treturn (priv_policy_ns(cr, capability, err, cr->user_ns));\n#else\n\treturn (priv_policy_ns(cr, capability, err, NULL));\n#endif\n}\n\n \nint\nsecpolicy_nfs(const cred_t *cr)\n{\n\treturn (priv_policy(cr, CAP_SYS_ADMIN, EPERM));\n}\n\n \nint\nsecpolicy_sys_config(const cred_t *cr, boolean_t checkonly)\n{\n\treturn (priv_policy(cr, CAP_SYS_ADMIN, EPERM));\n}\n\n \nint\nsecpolicy_vnode_access2(const cred_t *cr, struct inode *ip, uid_t owner,\n    mode_t curmode, mode_t wantmode)\n{\n\treturn (0);\n}\n\n \nint\nsecpolicy_vnode_any_access(const cred_t *cr, struct inode *ip, uid_t owner)\n{\n\tif (crgetuid(cr) == owner)\n\t\treturn (0);\n\n\tif (zpl_inode_owner_or_capable(zfs_init_idmap, ip))\n\t\treturn (0);\n\n#if defined(CONFIG_USER_NS)\n\tif (!kuid_has_mapping(cr->user_ns, SUID_TO_KUID(owner)))\n\t\treturn (EPERM);\n#endif\n\n\tif (priv_policy_user(cr, CAP_DAC_OVERRIDE, EPERM) == 0)\n\t\treturn (0);\n\n\tif (priv_policy_user(cr, CAP_DAC_READ_SEARCH, EPERM) == 0)\n\t\treturn (0);\n\n\treturn (EPERM);\n}\n\n \nint\nsecpolicy_vnode_chown(const cred_t *cr, uid_t owner)\n{\n\tif (crgetuid(cr) == owner)\n\t\treturn (0);\n\n#if defined(CONFIG_USER_NS)\n\tif (!kuid_has_mapping(cr->user_ns, SUID_TO_KUID(owner)))\n\t\treturn (EPERM);\n#endif\n\n\treturn (priv_policy_user(cr, CAP_FOWNER, EPERM));\n}\n\n \nint\nsecpolicy_vnode_create_gid(const cred_t *cr)\n{\n\treturn (priv_policy(cr, CAP_SETGID, EPERM));\n}\n\n \nint\nsecpolicy_vnode_remove(const cred_t *cr)\n{\n\treturn (priv_policy(cr, CAP_FOWNER, EPERM));\n}\n\n \nint\nsecpolicy_vnode_setdac(const cred_t *cr, uid_t owner)\n{\n\tif (crgetuid(cr) == owner)\n\t\treturn (0);\n\n#if defined(CONFIG_USER_NS)\n\tif (!kuid_has_mapping(cr->user_ns, SUID_TO_KUID(owner)))\n\t\treturn (EPERM);\n#endif\n\n\treturn (priv_policy_user(cr, CAP_FOWNER, EPERM));\n}\n\n \nint\nsecpolicy_vnode_setid_retain(struct znode *zp __maybe_unused, const cred_t *cr,\n    boolean_t issuidroot)\n{\n\treturn (priv_policy_user(cr, CAP_FSETID, EPERM));\n}\n\n \nint\nsecpolicy_vnode_setids_setgids(const cred_t *cr, gid_t gid, zidmap_t *mnt_ns,\n    struct user_namespace *fs_ns)\n{\n\tgid = zfs_gid_to_vfsgid(mnt_ns, fs_ns, gid);\n#if defined(CONFIG_USER_NS)\n\tif (!kgid_has_mapping(cr->user_ns, SGID_TO_KGID(gid)))\n\t\treturn (EPERM);\n#endif\n\tif (crgetgid(cr) != gid && !groupmember(gid, cr))\n\t\treturn (priv_policy_user(cr, CAP_FSETID, EPERM));\n\n\treturn (0);\n}\n\n \nint\nsecpolicy_zinject(const cred_t *cr)\n{\n\treturn (priv_policy(cr, CAP_SYS_ADMIN, EACCES));\n}\n\n \nint\nsecpolicy_zfs(const cred_t *cr)\n{\n\treturn (priv_policy(cr, CAP_SYS_ADMIN, EACCES));\n}\n\n \nint\nsecpolicy_zfs_proc(const cred_t *cr, proc_t *proc)\n{\n#if defined(HAVE_HAS_CAPABILITY)\n\tif (!has_capability(proc, CAP_SYS_ADMIN))\n\t\treturn (EACCES);\n\treturn (0);\n#else\n\treturn (EACCES);\n#endif\n}\n\nvoid\nsecpolicy_setid_clear(vattr_t *vap, cred_t *cr)\n{\n\tif ((vap->va_mode & (S_ISUID | S_ISGID)) != 0 &&\n\t    secpolicy_vnode_setid_retain(NULL, cr,\n\t    (vap->va_mode & S_ISUID) != 0 &&\n\t    (vap->va_mask & AT_UID) != 0 && vap->va_uid == 0) != 0) {\n\t\tvap->va_mask |= AT_MODE;\n\t\tvap->va_mode &= ~(S_ISUID|S_ISGID);\n\t}\n}\n\n \nstatic int\nsecpolicy_vnode_setid_modify(const cred_t *cr, uid_t owner, zidmap_t *mnt_ns,\n    struct user_namespace *fs_ns)\n{\n\towner = zfs_uid_to_vfsuid(mnt_ns, fs_ns, owner);\n\n\tif (crgetuid(cr) == owner)\n\t\treturn (0);\n\n#if defined(CONFIG_USER_NS)\n\tif (!kuid_has_mapping(cr->user_ns, SUID_TO_KUID(owner)))\n\t\treturn (EPERM);\n#endif\n\n\treturn (priv_policy_user(cr, CAP_FSETID, EPERM));\n}\n\n \nstatic int\nsecpolicy_vnode_stky_modify(const cred_t *cr)\n{\n\treturn (0);\n}\n\nint\nsecpolicy_setid_setsticky_clear(struct inode *ip, vattr_t *vap,\n    const vattr_t *ovap, cred_t *cr, zidmap_t *mnt_ns,\n    struct user_namespace *fs_ns)\n{\n\tint error;\n\n\tif ((vap->va_mode & S_ISUID) != 0 &&\n\t    (error = secpolicy_vnode_setid_modify(cr,\n\t    ovap->va_uid, mnt_ns, fs_ns)) != 0) {\n\t\treturn (error);\n\t}\n\n\t \n\tif (!S_ISDIR(ip->i_mode) && (vap->va_mode & S_ISVTX) != 0 &&\n\t    secpolicy_vnode_stky_modify(cr) != 0) {\n\t\tvap->va_mode &= ~S_ISVTX;\n\t}\n\n\t \n\tif ((vap->va_mode & S_ISGID) != 0 &&\n\t    secpolicy_vnode_setids_setgids(cr, ovap->va_gid,\n\t    mnt_ns, fs_ns) != 0) {\n\t\tvap->va_mode &= ~S_ISGID;\n\t}\n\n\treturn (0);\n}\n\n \nint\nsecpolicy_xvattr(xvattr_t *xvap, uid_t owner, cred_t *cr, mode_t type)\n{\n\treturn (secpolicy_vnode_chown(cr, owner));\n}\n\n \nint\nsecpolicy_vnode_setattr(cred_t *cr, struct inode *ip, struct vattr *vap,\n    const struct vattr *ovap, int flags,\n    int unlocked_access(void *, int, cred_t *), void *node)\n{\n\treturn (0);\n}\n\n \nint\nsecpolicy_basic_link(const cred_t *cr)\n{\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}