{
  "module_name": "zfs_ctldir.c",
  "hash_id": "375a7a9f4dd88391d618b7a6588bc26f498e3e80bca4ec6a462f2c411991c5a5",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_ctldir.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/sysmacros.h>\n#include <sys/pathname.h>\n#include <sys/vfs.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_vnops.h>\n#include <sys/stat.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_deleg.h>\n#include <sys/zpl.h>\n#include <sys/mntent.h>\n#include \"zfs_namecheck.h\"\n\n \nstatic avl_tree_t zfs_snapshots_by_name;\nstatic avl_tree_t zfs_snapshots_by_objsetid;\nstatic krwlock_t zfs_snapshot_lock;\n\n \nint zfs_expire_snapshot = ZFSCTL_EXPIRE_SNAPSHOT;\nstatic int zfs_admin_snapshot = 0;\n\ntypedef struct {\n\tchar\t\t*se_name;\t \n\tchar\t\t*se_path;\t \n\tspa_t\t\t*se_spa;\t \n\tuint64_t\tse_objsetid;\t \n\tstruct dentry   *se_root_dentry;  \n\tkrwlock_t\tse_taskqid_lock;   \n\ttaskqid_t\tse_taskqid;\t \n\tavl_node_t\tse_node_name;\t \n\tavl_node_t\tse_node_objsetid;  \n\tzfs_refcount_t\tse_refcount;\t \n} zfs_snapentry_t;\n\nstatic void zfsctl_snapshot_unmount_delay_impl(zfs_snapentry_t *se, int delay);\n\n \nstatic zfs_snapentry_t *\nzfsctl_snapshot_alloc(const char *full_name, const char *full_path, spa_t *spa,\n    uint64_t objsetid, struct dentry *root_dentry)\n{\n\tzfs_snapentry_t *se;\n\n\tse = kmem_zalloc(sizeof (zfs_snapentry_t), KM_SLEEP);\n\n\tse->se_name = kmem_strdup(full_name);\n\tse->se_path = kmem_strdup(full_path);\n\tse->se_spa = spa;\n\tse->se_objsetid = objsetid;\n\tse->se_root_dentry = root_dentry;\n\tse->se_taskqid = TASKQID_INVALID;\n\trw_init(&se->se_taskqid_lock, NULL, RW_DEFAULT, NULL);\n\n\tzfs_refcount_create(&se->se_refcount);\n\n\treturn (se);\n}\n\n \nstatic void\nzfsctl_snapshot_free(zfs_snapentry_t *se)\n{\n\tzfs_refcount_destroy(&se->se_refcount);\n\tkmem_strfree(se->se_name);\n\tkmem_strfree(se->se_path);\n\trw_destroy(&se->se_taskqid_lock);\n\n\tkmem_free(se, sizeof (zfs_snapentry_t));\n}\n\n \nstatic void\nzfsctl_snapshot_hold(zfs_snapentry_t *se)\n{\n\tzfs_refcount_add(&se->se_refcount, NULL);\n}\n\n \nstatic void\nzfsctl_snapshot_rele(zfs_snapentry_t *se)\n{\n\tif (zfs_refcount_remove(&se->se_refcount, NULL) == 0)\n\t\tzfsctl_snapshot_free(se);\n}\n\n \nstatic void\nzfsctl_snapshot_add(zfs_snapentry_t *se)\n{\n\tASSERT(RW_WRITE_HELD(&zfs_snapshot_lock));\n\tzfsctl_snapshot_hold(se);\n\tavl_add(&zfs_snapshots_by_name, se);\n\tavl_add(&zfs_snapshots_by_objsetid, se);\n}\n\n \nstatic void\nzfsctl_snapshot_remove(zfs_snapentry_t *se)\n{\n\tASSERT(RW_WRITE_HELD(&zfs_snapshot_lock));\n\tavl_remove(&zfs_snapshots_by_name, se);\n\tavl_remove(&zfs_snapshots_by_objsetid, se);\n\tzfsctl_snapshot_rele(se);\n}\n\n \nstatic int\nsnapentry_compare_by_name(const void *a, const void *b)\n{\n\tconst zfs_snapentry_t *se_a = a;\n\tconst zfs_snapentry_t *se_b = b;\n\tint ret;\n\n\tret = strcmp(se_a->se_name, se_b->se_name);\n\n\tif (ret < 0)\n\t\treturn (-1);\n\telse if (ret > 0)\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}\n\n \nstatic int\nsnapentry_compare_by_objsetid(const void *a, const void *b)\n{\n\tconst zfs_snapentry_t *se_a = a;\n\tconst zfs_snapentry_t *se_b = b;\n\n\tif (se_a->se_spa != se_b->se_spa)\n\t\treturn ((ulong_t)se_a->se_spa < (ulong_t)se_b->se_spa ? -1 : 1);\n\n\tif (se_a->se_objsetid < se_b->se_objsetid)\n\t\treturn (-1);\n\telse if (se_a->se_objsetid > se_b->se_objsetid)\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}\n\n \nstatic zfs_snapentry_t *\nzfsctl_snapshot_find_by_name(const char *snapname)\n{\n\tzfs_snapentry_t *se, search;\n\n\tASSERT(RW_LOCK_HELD(&zfs_snapshot_lock));\n\n\tsearch.se_name = (char *)snapname;\n\tse = avl_find(&zfs_snapshots_by_name, &search, NULL);\n\tif (se)\n\t\tzfsctl_snapshot_hold(se);\n\n\treturn (se);\n}\n\n \nstatic zfs_snapentry_t *\nzfsctl_snapshot_find_by_objsetid(spa_t *spa, uint64_t objsetid)\n{\n\tzfs_snapentry_t *se, search;\n\n\tASSERT(RW_LOCK_HELD(&zfs_snapshot_lock));\n\n\tsearch.se_spa = spa;\n\tsearch.se_objsetid = objsetid;\n\tse = avl_find(&zfs_snapshots_by_objsetid, &search, NULL);\n\tif (se)\n\t\tzfsctl_snapshot_hold(se);\n\n\treturn (se);\n}\n\n \nstatic int\nzfsctl_snapshot_rename(const char *old_snapname, const char *new_snapname)\n{\n\tzfs_snapentry_t *se;\n\n\tASSERT(RW_WRITE_HELD(&zfs_snapshot_lock));\n\n\tse = zfsctl_snapshot_find_by_name(old_snapname);\n\tif (se == NULL)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tzfsctl_snapshot_remove(se);\n\tkmem_strfree(se->se_name);\n\tse->se_name = kmem_strdup(new_snapname);\n\tzfsctl_snapshot_add(se);\n\tzfsctl_snapshot_rele(se);\n\n\treturn (0);\n}\n\n \nstatic void\nsnapentry_expire(void *data)\n{\n\tzfs_snapentry_t *se = (zfs_snapentry_t *)data;\n\tspa_t *spa = se->se_spa;\n\tuint64_t objsetid = se->se_objsetid;\n\n\tif (zfs_expire_snapshot <= 0) {\n\t\tzfsctl_snapshot_rele(se);\n\t\treturn;\n\t}\n\n\trw_enter(&se->se_taskqid_lock, RW_WRITER);\n\tse->se_taskqid = TASKQID_INVALID;\n\trw_exit(&se->se_taskqid_lock);\n\t(void) zfsctl_snapshot_unmount(se->se_name, MNT_EXPIRE);\n\tzfsctl_snapshot_rele(se);\n\n\t \n\trw_enter(&zfs_snapshot_lock, RW_READER);\n\tif ((se = zfsctl_snapshot_find_by_objsetid(spa, objsetid)) != NULL) {\n\t\tzfsctl_snapshot_unmount_delay_impl(se, zfs_expire_snapshot);\n\t\tzfsctl_snapshot_rele(se);\n\t}\n\trw_exit(&zfs_snapshot_lock);\n}\n\n \nstatic void\nzfsctl_snapshot_unmount_cancel(zfs_snapentry_t *se)\n{\n\tint err = 0;\n\trw_enter(&se->se_taskqid_lock, RW_WRITER);\n\terr = taskq_cancel_id(system_delay_taskq, se->se_taskqid);\n\t \n\tse->se_taskqid = TASKQID_INVALID;\n\trw_exit(&se->se_taskqid_lock);\n\tif (err == 0) {\n\t\tzfsctl_snapshot_rele(se);\n\t}\n}\n\n \nstatic void\nzfsctl_snapshot_unmount_delay_impl(zfs_snapentry_t *se, int delay)\n{\n\n\tif (delay <= 0)\n\t\treturn;\n\n\tzfsctl_snapshot_hold(se);\n\trw_enter(&se->se_taskqid_lock, RW_WRITER);\n\t \n\tif (se->se_taskqid != TASKQID_INVALID) {\n\t\trw_exit(&se->se_taskqid_lock);\n\t\tzfsctl_snapshot_rele(se);\n\t\treturn;\n\t}\n\tse->se_taskqid = taskq_dispatch_delay(system_delay_taskq,\n\t    snapentry_expire, se, TQ_SLEEP, ddi_get_lbolt() + delay * HZ);\n\trw_exit(&se->se_taskqid_lock);\n}\n\n \nint\nzfsctl_snapshot_unmount_delay(spa_t *spa, uint64_t objsetid, int delay)\n{\n\tzfs_snapentry_t *se;\n\tint error = ENOENT;\n\n\trw_enter(&zfs_snapshot_lock, RW_READER);\n\tif ((se = zfsctl_snapshot_find_by_objsetid(spa, objsetid)) != NULL) {\n\t\tzfsctl_snapshot_unmount_cancel(se);\n\t\tzfsctl_snapshot_unmount_delay_impl(se, delay);\n\t\tzfsctl_snapshot_rele(se);\n\t\terror = 0;\n\t}\n\trw_exit(&zfs_snapshot_lock);\n\n\treturn (error);\n}\n\n \nstatic boolean_t\nzfsctl_snapshot_ismounted(const char *snapname)\n{\n\tzfs_snapentry_t *se;\n\tboolean_t ismounted = B_FALSE;\n\n\trw_enter(&zfs_snapshot_lock, RW_READER);\n\tif ((se = zfsctl_snapshot_find_by_name(snapname)) != NULL) {\n\t\tzfsctl_snapshot_rele(se);\n\t\tismounted = B_TRUE;\n\t}\n\trw_exit(&zfs_snapshot_lock);\n\n\treturn (ismounted);\n}\n\n \nboolean_t\nzfsctl_is_node(struct inode *ip)\n{\n\treturn (ITOZ(ip)->z_is_ctldir);\n}\n\n \nboolean_t\nzfsctl_is_snapdir(struct inode *ip)\n{\n\treturn (zfsctl_is_node(ip) && (ip->i_ino <= ZFSCTL_INO_SNAPDIRS));\n}\n\n \nstatic struct inode *\nzfsctl_inode_alloc(zfsvfs_t *zfsvfs, uint64_t id,\n    const struct file_operations *fops, const struct inode_operations *ops,\n    uint64_t creation)\n{\n\tstruct inode *ip;\n\tznode_t *zp;\n\tinode_timespec_t now = {.tv_sec = creation};\n\n\tip = new_inode(zfsvfs->z_sb);\n\tif (ip == NULL)\n\t\treturn (NULL);\n\n\tif (!creation)\n\t\tnow = current_time(ip);\n\tzp = ITOZ(ip);\n\tASSERT3P(zp->z_dirlocks, ==, NULL);\n\tASSERT3P(zp->z_acl_cached, ==, NULL);\n\tASSERT3P(zp->z_xattr_cached, ==, NULL);\n\tzp->z_id = id;\n\tzp->z_unlinked = B_FALSE;\n\tzp->z_atime_dirty = B_FALSE;\n\tzp->z_zn_prefetch = B_FALSE;\n\tzp->z_is_sa = B_FALSE;\n#if !defined(HAVE_FILEMAP_RANGE_HAS_PAGE)\n\tzp->z_is_mapped = B_FALSE;\n#endif\n\tzp->z_is_ctldir = B_TRUE;\n\tzp->z_sa_hdl = NULL;\n\tzp->z_blksz = 0;\n\tzp->z_seq = 0;\n\tzp->z_mapcnt = 0;\n\tzp->z_size = 0;\n\tzp->z_pflags = 0;\n\tzp->z_mode = 0;\n\tzp->z_sync_cnt = 0;\n\tzp->z_sync_writes_cnt = 0;\n\tzp->z_async_writes_cnt = 0;\n\tip->i_generation = 0;\n\tip->i_ino = id;\n\tip->i_mode = (S_IFDIR | S_IRWXUGO);\n\tip->i_uid = SUID_TO_KUID(0);\n\tip->i_gid = SGID_TO_KGID(0);\n\tip->i_blkbits = SPA_MINBLOCKSHIFT;\n\tip->i_atime = now;\n\tip->i_mtime = now;\n\tzpl_inode_set_ctime_to_ts(ip, now);\n\tip->i_fop = fops;\n\tip->i_op = ops;\n#if defined(IOP_XATTR)\n\tip->i_opflags &= ~IOP_XATTR;\n#endif\n\n\tif (insert_inode_locked(ip)) {\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t\treturn (NULL);\n\t}\n\n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tlist_insert_tail(&zfsvfs->z_all_znodes, zp);\n\tmembar_producer();\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n\tunlock_new_inode(ip);\n\n\treturn (ip);\n}\n\n \nstatic struct inode *\nzfsctl_inode_lookup(zfsvfs_t *zfsvfs, uint64_t id,\n    const struct file_operations *fops, const struct inode_operations *ops)\n{\n\tstruct inode *ip = NULL;\n\tuint64_t creation = 0;\n\tdsl_dataset_t *snap_ds;\n\tdsl_pool_t *pool;\n\n\twhile (ip == NULL) {\n\t\tip = ilookup(zfsvfs->z_sb, (unsigned long)id);\n\t\tif (ip)\n\t\t\tbreak;\n\n\t\tif (id <= ZFSCTL_INO_SNAPDIRS && !creation) {\n\t\t\tpool = dmu_objset_pool(zfsvfs->z_os);\n\t\t\tdsl_pool_config_enter(pool, FTAG);\n\t\t\tif (!dsl_dataset_hold_obj(pool,\n\t\t\t    ZFSCTL_INO_SNAPDIRS - id, FTAG, &snap_ds)) {\n\t\t\t\tcreation = dsl_get_creation(snap_ds);\n\t\t\t\tdsl_dataset_rele(snap_ds, FTAG);\n\t\t\t}\n\t\t\tdsl_pool_config_exit(pool, FTAG);\n\t\t}\n\n\t\t \n\t\tip = zfsctl_inode_alloc(zfsvfs, id, fops, ops, creation);\n\t}\n\n\treturn (ip);\n}\n\n \nint\nzfsctl_create(zfsvfs_t *zfsvfs)\n{\n\tASSERT(zfsvfs->z_ctldir == NULL);\n\n\tzfsvfs->z_ctldir = zfsctl_inode_alloc(zfsvfs, ZFSCTL_INO_ROOT,\n\t    &zpl_fops_root, &zpl_ops_root, 0);\n\tif (zfsvfs->z_ctldir == NULL)\n\t\treturn (SET_ERROR(ENOENT));\n\n\treturn (0);\n}\n\n \nvoid\nzfsctl_destroy(zfsvfs_t *zfsvfs)\n{\n\tif (zfsvfs->z_issnap) {\n\t\tzfs_snapentry_t *se;\n\t\tspa_t *spa = zfsvfs->z_os->os_spa;\n\t\tuint64_t objsetid = dmu_objset_id(zfsvfs->z_os);\n\n\t\trw_enter(&zfs_snapshot_lock, RW_WRITER);\n\t\tse = zfsctl_snapshot_find_by_objsetid(spa, objsetid);\n\t\tif (se != NULL)\n\t\t\tzfsctl_snapshot_remove(se);\n\t\trw_exit(&zfs_snapshot_lock);\n\t\tif (se != NULL) {\n\t\t\tzfsctl_snapshot_unmount_cancel(se);\n\t\t\tzfsctl_snapshot_rele(se);\n\t\t}\n\t} else if (zfsvfs->z_ctldir) {\n\t\tiput(zfsvfs->z_ctldir);\n\t\tzfsvfs->z_ctldir = NULL;\n\t}\n}\n\n \nstruct inode *\nzfsctl_root(znode_t *zp)\n{\n\tASSERT(zfs_has_ctldir(zp));\n\t \n\tVERIFY3P(igrab(ZTOZSB(zp)->z_ctldir), !=, NULL);\n\treturn (ZTOZSB(zp)->z_ctldir);\n}\n\n \nstatic int\nzfsctl_snapdir_fid(struct inode *ip, fid_t *fidp)\n{\n\tzfid_short_t *zfid = (zfid_short_t *)fidp;\n\tzfid_long_t *zlfid = (zfid_long_t *)fidp;\n\tuint32_t gen = 0;\n\tuint64_t object;\n\tuint64_t objsetid;\n\tint i;\n\tstruct dentry *dentry;\n\n\tif (fidp->fid_len < LONG_FID_LEN) {\n\t\tfidp->fid_len = LONG_FID_LEN;\n\t\treturn (SET_ERROR(ENOSPC));\n\t}\n\n\tobject = ip->i_ino;\n\tobjsetid = ZFSCTL_INO_SNAPDIRS - ip->i_ino;\n\tzfid->zf_len = LONG_FID_LEN;\n\n\tdentry = d_obtain_alias(igrab(ip));\n\tif (!IS_ERR(dentry)) {\n\t\tgen = !!d_mountpoint(dentry);\n\t\tdput(dentry);\n\t}\n\n\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\tzfid->zf_object[i] = (uint8_t)(object >> (8 * i));\n\n\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\tzfid->zf_gen[i] = (uint8_t)(gen >> (8 * i));\n\n\tfor (i = 0; i < sizeof (zlfid->zf_setid); i++)\n\t\tzlfid->zf_setid[i] = (uint8_t)(objsetid >> (8 * i));\n\n\tfor (i = 0; i < sizeof (zlfid->zf_setgen); i++)\n\t\tzlfid->zf_setgen[i] = 0;\n\n\treturn (0);\n}\n\n \nint\nzfsctl_fid(struct inode *ip, fid_t *fidp)\n{\n\tznode_t\t\t*zp = ITOZ(ip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(ip);\n\tuint64_t\tobject = zp->z_id;\n\tzfid_short_t\t*zfid;\n\tint\t\ti;\n\tint\t\terror;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zfsctl_is_snapdir(ip)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (zfsctl_snapdir_fid(ip, fidp));\n\t}\n\n\tif (fidp->fid_len < SHORT_FID_LEN) {\n\t\tfidp->fid_len = SHORT_FID_LEN;\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENOSPC));\n\t}\n\n\tzfid = (zfid_short_t *)fidp;\n\n\tzfid->zf_len = SHORT_FID_LEN;\n\n\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\tzfid->zf_object[i] = (uint8_t)(object >> (8 * i));\n\n\t \n\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\tzfid->zf_gen[i] = 0;\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n \nstatic int\nzfsctl_snapshot_name(zfsvfs_t *zfsvfs, const char *snap_name, int len,\n    char *full_name)\n{\n\tobjset_t *os = zfsvfs->z_os;\n\n\tif (zfs_component_namecheck(snap_name, NULL, NULL) != 0)\n\t\treturn (SET_ERROR(EILSEQ));\n\n\tdmu_objset_name(os, full_name);\n\tif ((strlen(full_name) + 1 + strlen(snap_name)) >= len)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\t(void) strcat(full_name, \"@\");\n\t(void) strcat(full_name, snap_name);\n\n\treturn (0);\n}\n\n \nstatic int\nzfsctl_snapshot_path_objset(zfsvfs_t *zfsvfs, uint64_t objsetid,\n    int path_len, char *full_path)\n{\n\tobjset_t *os = zfsvfs->z_os;\n\tfstrans_cookie_t cookie;\n\tchar *snapname;\n\tboolean_t case_conflict;\n\tuint64_t id, pos = 0;\n\tint error = 0;\n\n\tif (zfsvfs->z_vfs->vfs_mntpoint == NULL)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tcookie = spl_fstrans_mark();\n\tsnapname = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\n\twhile (error == 0) {\n\t\tdsl_pool_config_enter(dmu_objset_pool(os), FTAG);\n\t\terror = dmu_snapshot_list_next(zfsvfs->z_os,\n\t\t    ZFS_MAX_DATASET_NAME_LEN, snapname, &id, &pos,\n\t\t    &case_conflict);\n\t\tdsl_pool_config_exit(dmu_objset_pool(os), FTAG);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (id == objsetid)\n\t\t\tbreak;\n\t}\n\n\tsnprintf(full_path, path_len, \"%s/.zfs/snapshot/%s\",\n\t    zfsvfs->z_vfs->vfs_mntpoint, snapname);\nout:\n\tkmem_free(snapname, ZFS_MAX_DATASET_NAME_LEN);\n\tspl_fstrans_unmark(cookie);\n\n\treturn (error);\n}\n\n \nint\nzfsctl_root_lookup(struct inode *dip, const char *name, struct inode **ipp,\n    int flags, cred_t *cr, int *direntflags, pathname_t *realpnp)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(dip);\n\tint error = 0;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (strcmp(name, \"..\") == 0) {\n\t\t*ipp = dip->i_sb->s_root->d_inode;\n\t} else if (strcmp(name, ZFS_SNAPDIR_NAME) == 0) {\n\t\t*ipp = zfsctl_inode_lookup(zfsvfs, ZFSCTL_INO_SNAPDIR,\n\t\t    &zpl_fops_snapdir, &zpl_ops_snapdir);\n\t} else if (strcmp(name, ZFS_SHAREDIR_NAME) == 0) {\n\t\t*ipp = zfsctl_inode_lookup(zfsvfs, ZFSCTL_INO_SHARES,\n\t\t    &zpl_fops_shares, &zpl_ops_shares);\n\t} else {\n\t\t*ipp = NULL;\n\t}\n\n\tif (*ipp == NULL)\n\t\terror = SET_ERROR(ENOENT);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfsctl_snapdir_lookup(struct inode *dip, const char *name, struct inode **ipp,\n    int flags, cred_t *cr, int *direntflags, pathname_t *realpnp)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(dip);\n\tuint64_t id;\n\tint error;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = dmu_snapshot_lookup(zfsvfs->z_os, name, &id);\n\tif (error) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t*ipp = zfsctl_inode_lookup(zfsvfs, ZFSCTL_INO_SNAPDIRS - id,\n\t    &simple_dir_operations, &simple_dir_inode_operations);\n\tif (*ipp == NULL)\n\t\terror = SET_ERROR(ENOENT);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfsctl_snapdir_rename(struct inode *sdip, const char *snm,\n    struct inode *tdip, const char *tnm, cred_t *cr, int flags)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(sdip);\n\tchar *to, *from, *real, *fsname;\n\tint error;\n\n\tif (!zfs_admin_snapshot)\n\t\treturn (SET_ERROR(EACCES));\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tto = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\tfrom = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\treal = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\tfsname = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\n\tif (zfsvfs->z_case == ZFS_CASE_INSENSITIVE) {\n\t\terror = dmu_snapshot_realname(zfsvfs->z_os, snm, real,\n\t\t    ZFS_MAX_DATASET_NAME_LEN, NULL);\n\t\tif (error == 0) {\n\t\t\tsnm = real;\n\t\t} else if (error != ENOTSUP) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdmu_objset_name(zfsvfs->z_os, fsname);\n\n\terror = zfsctl_snapshot_name(ITOZSB(sdip), snm,\n\t    ZFS_MAX_DATASET_NAME_LEN, from);\n\tif (error == 0)\n\t\terror = zfsctl_snapshot_name(ITOZSB(tdip), tnm,\n\t\t    ZFS_MAX_DATASET_NAME_LEN, to);\n\tif (error == 0)\n\t\terror = zfs_secpolicy_rename_perms(from, to, cr);\n\tif (error != 0)\n\t\tgoto out;\n\n\t \n\tif (sdip != tdip) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\n\t \n\tif (strcmp(snm, tnm) == 0) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\trw_enter(&zfs_snapshot_lock, RW_WRITER);\n\n\terror = dsl_dataset_rename_snapshot(fsname, snm, tnm, B_FALSE);\n\tif (error == 0)\n\t\t(void) zfsctl_snapshot_rename(snm, tnm);\n\n\trw_exit(&zfs_snapshot_lock);\nout:\n\tkmem_free(from, ZFS_MAX_DATASET_NAME_LEN);\n\tkmem_free(to, ZFS_MAX_DATASET_NAME_LEN);\n\tkmem_free(real, ZFS_MAX_DATASET_NAME_LEN);\n\tkmem_free(fsname, ZFS_MAX_DATASET_NAME_LEN);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfsctl_snapdir_remove(struct inode *dip, const char *name, cred_t *cr,\n    int flags)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(dip);\n\tchar *snapname, *real;\n\tint error;\n\n\tif (!zfs_admin_snapshot)\n\t\treturn (SET_ERROR(EACCES));\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tsnapname = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\treal = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\n\tif (zfsvfs->z_case == ZFS_CASE_INSENSITIVE) {\n\t\terror = dmu_snapshot_realname(zfsvfs->z_os, name, real,\n\t\t    ZFS_MAX_DATASET_NAME_LEN, NULL);\n\t\tif (error == 0) {\n\t\t\tname = real;\n\t\t} else if (error != ENOTSUP) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = zfsctl_snapshot_name(ITOZSB(dip), name,\n\t    ZFS_MAX_DATASET_NAME_LEN, snapname);\n\tif (error == 0)\n\t\terror = zfs_secpolicy_destroy_perms(snapname, cr);\n\tif (error != 0)\n\t\tgoto out;\n\n\terror = zfsctl_snapshot_unmount(snapname, MNT_FORCE);\n\tif ((error == 0) || (error == ENOENT))\n\t\terror = dsl_destroy_snapshot(snapname, B_FALSE);\nout:\n\tkmem_free(snapname, ZFS_MAX_DATASET_NAME_LEN);\n\tkmem_free(real, ZFS_MAX_DATASET_NAME_LEN);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfsctl_snapdir_mkdir(struct inode *dip, const char *dirname, vattr_t *vap,\n    struct inode **ipp, cred_t *cr, int flags)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(dip);\n\tchar *dsname;\n\tint error;\n\n\tif (!zfs_admin_snapshot)\n\t\treturn (SET_ERROR(EACCES));\n\n\tdsname = kmem_alloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\n\tif (zfs_component_namecheck(dirname, NULL, NULL) != 0) {\n\t\terror = SET_ERROR(EILSEQ);\n\t\tgoto out;\n\t}\n\n\tdmu_objset_name(zfsvfs->z_os, dsname);\n\n\terror = zfs_secpolicy_snapshot_perms(dsname, cr);\n\tif (error != 0)\n\t\tgoto out;\n\n\tif (error == 0) {\n\t\terror = dmu_objset_snapshot_one(dsname, dirname);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\n\t\terror = zfsctl_snapdir_lookup(dip, dirname, ipp,\n\t\t    0, cr, NULL, NULL);\n\t}\nout:\n\tkmem_free(dsname, ZFS_MAX_DATASET_NAME_LEN);\n\n\treturn (error);\n}\n\n \nstatic void\nexportfs_flush(void)\n{\n\tchar *argv[] = { \"/usr/sbin/exportfs\", \"-f\", NULL };\n\tchar *envp[] = { NULL };\n\n\t(void) call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n}\n\n \nint\nzfsctl_snapshot_unmount(const char *snapname, int flags)\n{\n\tchar *argv[] = { \"/usr/bin/env\", \"umount\", \"-t\", \"zfs\", \"-n\", NULL,\n\t    NULL };\n\tchar *envp[] = { NULL };\n\tzfs_snapentry_t *se;\n\tint error;\n\n\trw_enter(&zfs_snapshot_lock, RW_READER);\n\tif ((se = zfsctl_snapshot_find_by_name(snapname)) == NULL) {\n\t\trw_exit(&zfs_snapshot_lock);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\trw_exit(&zfs_snapshot_lock);\n\n\texportfs_flush();\n\n\tif (flags & MNT_FORCE)\n\t\targv[4] = \"-fn\";\n\targv[5] = se->se_path;\n\tdprintf(\"unmount; path=%s\\n\", se->se_path);\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tzfsctl_snapshot_rele(se);\n\n\n\t \n\tif (error)\n\t\terror = SET_ERROR(EBUSY);\n\n\treturn (error);\n}\n\nint\nzfsctl_snapshot_mount(struct path *path, int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *ip = dentry->d_inode;\n\tzfsvfs_t *zfsvfs;\n\tzfsvfs_t *snap_zfsvfs;\n\tzfs_snapentry_t *se;\n\tchar *full_name, *full_path;\n\tchar *argv[] = { \"/usr/bin/env\", \"mount\", \"-t\", \"zfs\", \"-n\", NULL, NULL,\n\t    NULL };\n\tchar *envp[] = { NULL };\n\tint error;\n\tstruct path spath;\n\n\tif (ip == NULL)\n\t\treturn (SET_ERROR(EISDIR));\n\n\tzfsvfs = ITOZSB(ip);\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tfull_name = kmem_zalloc(ZFS_MAX_DATASET_NAME_LEN, KM_SLEEP);\n\tfull_path = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\terror = zfsctl_snapshot_name(zfsvfs, dname(dentry),\n\t    ZFS_MAX_DATASET_NAME_LEN, full_name);\n\tif (error)\n\t\tgoto error;\n\n\t \n\tsnprintf(full_path, MAXPATHLEN, \"%s/.zfs/snapshot/%s\",\n\t    zfsvfs->z_vfs->vfs_mntpoint ? zfsvfs->z_vfs->vfs_mntpoint : \"\",\n\t    dname(dentry));\n\n\t \n\tif (zfsctl_snapshot_ismounted(full_name)) {\n\t\terror = 0;\n\t\tgoto error;\n\t}\n\n\t \n\tdprintf(\"mount; name=%s path=%s\\n\", full_name, full_path);\n\targv[5] = full_name;\n\targv[6] = full_path;\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tif (!(error & MOUNT_BUSY << 8)) {\n\t\t\tzfs_dbgmsg(\"Unable to automount %s error=%d\",\n\t\t\t    full_path, error);\n\t\t\terror = SET_ERROR(EISDIR);\n\t\t} else {\n\t\t\t \n\t\t\terror = 0;\n\t\t}\n\t\tgoto error;\n\t}\n\n\t \n\tspath = *path;\n\tpath_get(&spath);\n\tif (follow_down_one(&spath)) {\n\t\tsnap_zfsvfs = ITOZSB(spath.dentry->d_inode);\n\t\tsnap_zfsvfs->z_parent = zfsvfs;\n\t\tdentry = spath.dentry;\n\t\tspath.mnt->mnt_flags |= MNT_SHRINKABLE;\n\n\t\trw_enter(&zfs_snapshot_lock, RW_WRITER);\n\t\tse = zfsctl_snapshot_alloc(full_name, full_path,\n\t\t    snap_zfsvfs->z_os->os_spa, dmu_objset_id(snap_zfsvfs->z_os),\n\t\t    dentry);\n\t\tzfsctl_snapshot_add(se);\n\t\tzfsctl_snapshot_unmount_delay_impl(se, zfs_expire_snapshot);\n\t\trw_exit(&zfs_snapshot_lock);\n\t}\n\tpath_put(&spath);\nerror:\n\tkmem_free(full_name, ZFS_MAX_DATASET_NAME_LEN);\n\tkmem_free(full_path, MAXPATHLEN);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfsctl_snapdir_vget(struct super_block *sb, uint64_t objsetid, int gen,\n    struct inode **ipp)\n{\n\tint error;\n\tstruct path path;\n\tchar *mnt;\n\tstruct dentry *dentry;\n\n\tmnt = kmem_alloc(MAXPATHLEN, KM_SLEEP);\n\n\terror = zfsctl_snapshot_path_objset(sb->s_fs_info, objsetid,\n\t    MAXPATHLEN, mnt);\n\tif (error)\n\t\tgoto out;\n\n\t \n\terror = -kern_path(mnt, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &path);\n\tif (error)\n\t\tgoto out;\n\n\tpath_put(&path);\n\t \n\t*ipp = ilookup(sb, ZFSCTL_INO_SNAPDIRS - objsetid);\n\tif (*ipp == NULL) {\n\t\terror = SET_ERROR(ENOENT);\n\t\tgoto out;\n\t}\n\n\t \n\tdentry = d_obtain_alias(igrab(*ipp));\n\tif (gen != (!IS_ERR(dentry) && d_mountpoint(dentry))) {\n\t\tiput(*ipp);\n\t\t*ipp = NULL;\n\t\terror = SET_ERROR(ENOENT);\n\t}\n\tif (!IS_ERR(dentry))\n\t\tdput(dentry);\nout:\n\tkmem_free(mnt, MAXPATHLEN);\n\treturn (error);\n}\n\nint\nzfsctl_shares_lookup(struct inode *dip, char *name, struct inode **ipp,\n    int flags, cred_t *cr, int *direntflags, pathname_t *realpnp)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(dip);\n\tznode_t *zp;\n\tznode_t *dzp;\n\tint error;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zfsvfs->z_shares_dir == 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\tif ((error = zfs_zget(zfsvfs, zfsvfs->z_shares_dir, &dzp)) == 0) {\n\t\terror = zfs_lookup(dzp, name, &zp, 0, cr, NULL, NULL);\n\t\tzrele(dzp);\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nvoid\nzfsctl_init(void)\n{\n\tavl_create(&zfs_snapshots_by_name, snapentry_compare_by_name,\n\t    sizeof (zfs_snapentry_t), offsetof(zfs_snapentry_t,\n\t    se_node_name));\n\tavl_create(&zfs_snapshots_by_objsetid, snapentry_compare_by_objsetid,\n\t    sizeof (zfs_snapentry_t), offsetof(zfs_snapentry_t,\n\t    se_node_objsetid));\n\trw_init(&zfs_snapshot_lock, NULL, RW_DEFAULT, NULL);\n}\n\n \nvoid\nzfsctl_fini(void)\n{\n\tavl_destroy(&zfs_snapshots_by_name);\n\tavl_destroy(&zfs_snapshots_by_objsetid);\n\trw_destroy(&zfs_snapshot_lock);\n}\n\nmodule_param(zfs_admin_snapshot, int, 0644);\nMODULE_PARM_DESC(zfs_admin_snapshot, \"Enable mkdir/rmdir/mv in .zfs/snapshot\");\n\nmodule_param(zfs_expire_snapshot, int, 0644);\nMODULE_PARM_DESC(zfs_expire_snapshot, \"Seconds to expire .zfs/snapshot\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}