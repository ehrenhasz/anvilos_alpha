{
  "module_name": "zfs_znode.c",
  "hash_id": "7901524f30e34d5e09e8b620359797cc2594944cdd62d54bb32ed2b129aa5abc",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_znode.c",
  "human_readable_source": " \n \n\n \n\n#ifdef _KERNEL\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/sysmacros.h>\n#include <sys/mntent.h>\n#include <sys/u8_textprep.h>\n#include <sys/dsl_dataset.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/errno.h>\n#include <sys/atomic.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_rlock.h>\n#include <sys/zfs_fuid.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/dnode.h>\n#include <sys/fs/zfs.h>\n#include <sys/zpl.h>\n#endif  \n\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/zfs_refcount.h>\n#include <sys/stat.h>\n#include <sys/zap.h>\n#include <sys/zfs_znode.h>\n#include <sys/sa.h>\n#include <sys/zfs_sa.h>\n#include <sys/zfs_stat.h>\n\n#include \"zfs_prop.h\"\n#include \"zfs_comutil.h\"\n\n \n#ifdef _KERNEL\n\nstatic kmem_cache_t *znode_cache = NULL;\nstatic kmem_cache_t *znode_hold_cache = NULL;\nunsigned int zfs_object_mutex_size = ZFS_OBJ_MTX_SZ;\n\n \nstatic int zfs_unlink_suspend_progress = 0;\n\n \nstatic void\nzfs_rangelock_cb(zfs_locked_range_t *new, void *arg)\n{\n\tznode_t *zp = arg;\n\n\t \n\tif (new->lr_type == RL_APPEND) {\n\t\tnew->lr_offset = zp->z_size;\n\t\tnew->lr_type = RL_WRITER;\n\t}\n\n\t \n\tuint64_t end_size = MAX(zp->z_size, new->lr_offset + new->lr_length);\n\tif (end_size > zp->z_blksz && (!ISP2(zp->z_blksz) ||\n\t    zp->z_blksz < ZTOZSB(zp)->z_max_blksz)) {\n\t\tnew->lr_offset = 0;\n\t\tnew->lr_length = UINT64_MAX;\n\t}\n}\n\nstatic int\nzfs_znode_cache_constructor(void *buf, void *arg, int kmflags)\n{\n\t(void) arg, (void) kmflags;\n\tznode_t *zp = buf;\n\n\tinode_init_once(ZTOI(zp));\n\tlist_link_init(&zp->z_link_node);\n\n\tmutex_init(&zp->z_lock, NULL, MUTEX_DEFAULT, NULL);\n\trw_init(&zp->z_parent_lock, NULL, RW_DEFAULT, NULL);\n\trw_init(&zp->z_name_lock, NULL, RW_NOLOCKDEP, NULL);\n\tmutex_init(&zp->z_acl_lock, NULL, MUTEX_DEFAULT, NULL);\n\trw_init(&zp->z_xattr_lock, NULL, RW_DEFAULT, NULL);\n\n\tzfs_rangelock_init(&zp->z_rangelock, zfs_rangelock_cb, zp);\n\n\tzp->z_dirlocks = NULL;\n\tzp->z_acl_cached = NULL;\n\tzp->z_xattr_cached = NULL;\n\tzp->z_xattr_parent = 0;\n\tzp->z_sync_writes_cnt = 0;\n\tzp->z_async_writes_cnt = 0;\n\n\treturn (0);\n}\n\nstatic void\nzfs_znode_cache_destructor(void *buf, void *arg)\n{\n\t(void) arg;\n\tznode_t *zp = buf;\n\n\tASSERT(!list_link_active(&zp->z_link_node));\n\tmutex_destroy(&zp->z_lock);\n\trw_destroy(&zp->z_parent_lock);\n\trw_destroy(&zp->z_name_lock);\n\tmutex_destroy(&zp->z_acl_lock);\n\trw_destroy(&zp->z_xattr_lock);\n\tzfs_rangelock_fini(&zp->z_rangelock);\n\n\tASSERT3P(zp->z_dirlocks, ==, NULL);\n\tASSERT3P(zp->z_acl_cached, ==, NULL);\n\tASSERT3P(zp->z_xattr_cached, ==, NULL);\n\n\tASSERT0(atomic_load_32(&zp->z_sync_writes_cnt));\n\tASSERT0(atomic_load_32(&zp->z_async_writes_cnt));\n}\n\nstatic int\nzfs_znode_hold_cache_constructor(void *buf, void *arg, int kmflags)\n{\n\t(void) arg, (void) kmflags;\n\tznode_hold_t *zh = buf;\n\n\tmutex_init(&zh->zh_lock, NULL, MUTEX_DEFAULT, NULL);\n\tzh->zh_refcount = 0;\n\n\treturn (0);\n}\n\nstatic void\nzfs_znode_hold_cache_destructor(void *buf, void *arg)\n{\n\t(void) arg;\n\tznode_hold_t *zh = buf;\n\n\tmutex_destroy(&zh->zh_lock);\n}\n\nvoid\nzfs_znode_init(void)\n{\n\t \n\tASSERT(znode_cache == NULL);\n\tznode_cache = kmem_cache_create(\"zfs_znode_cache\",\n\t    sizeof (znode_t), 0, zfs_znode_cache_constructor,\n\t    zfs_znode_cache_destructor, NULL, NULL, NULL, KMC_SLAB);\n\n\tASSERT(znode_hold_cache == NULL);\n\tznode_hold_cache = kmem_cache_create(\"zfs_znode_hold_cache\",\n\t    sizeof (znode_hold_t), 0, zfs_znode_hold_cache_constructor,\n\t    zfs_znode_hold_cache_destructor, NULL, NULL, NULL, 0);\n}\n\nvoid\nzfs_znode_fini(void)\n{\n\t \n\tif (znode_cache)\n\t\tkmem_cache_destroy(znode_cache);\n\tznode_cache = NULL;\n\n\tif (znode_hold_cache)\n\t\tkmem_cache_destroy(znode_hold_cache);\n\tznode_hold_cache = NULL;\n}\n\n \nint\nzfs_znode_hold_compare(const void *a, const void *b)\n{\n\tconst znode_hold_t *zh_a = (const znode_hold_t *)a;\n\tconst znode_hold_t *zh_b = (const znode_hold_t *)b;\n\n\treturn (TREE_CMP(zh_a->zh_obj, zh_b->zh_obj));\n}\n\nstatic boolean_t __maybe_unused\nzfs_znode_held(zfsvfs_t *zfsvfs, uint64_t obj)\n{\n\tznode_hold_t *zh, search;\n\tint i = ZFS_OBJ_HASH(zfsvfs, obj);\n\tboolean_t held;\n\n\tsearch.zh_obj = obj;\n\n\tmutex_enter(&zfsvfs->z_hold_locks[i]);\n\tzh = avl_find(&zfsvfs->z_hold_trees[i], &search, NULL);\n\theld = (zh && MUTEX_HELD(&zh->zh_lock)) ? B_TRUE : B_FALSE;\n\tmutex_exit(&zfsvfs->z_hold_locks[i]);\n\n\treturn (held);\n}\n\nznode_hold_t *\nzfs_znode_hold_enter(zfsvfs_t *zfsvfs, uint64_t obj)\n{\n\tznode_hold_t *zh, *zh_new, search;\n\tint i = ZFS_OBJ_HASH(zfsvfs, obj);\n\tboolean_t found = B_FALSE;\n\n\tzh_new = kmem_cache_alloc(znode_hold_cache, KM_SLEEP);\n\tsearch.zh_obj = obj;\n\n\tmutex_enter(&zfsvfs->z_hold_locks[i]);\n\tzh = avl_find(&zfsvfs->z_hold_trees[i], &search, NULL);\n\tif (likely(zh == NULL)) {\n\t\tzh = zh_new;\n\t\tzh->zh_obj = obj;\n\t\tavl_add(&zfsvfs->z_hold_trees[i], zh);\n\t} else {\n\t\tASSERT3U(zh->zh_obj, ==, obj);\n\t\tfound = B_TRUE;\n\t}\n\tzh->zh_refcount++;\n\tASSERT3S(zh->zh_refcount, >, 0);\n\tmutex_exit(&zfsvfs->z_hold_locks[i]);\n\n\tif (found == B_TRUE)\n\t\tkmem_cache_free(znode_hold_cache, zh_new);\n\n\tASSERT(MUTEX_NOT_HELD(&zh->zh_lock));\n\tmutex_enter(&zh->zh_lock);\n\n\treturn (zh);\n}\n\nvoid\nzfs_znode_hold_exit(zfsvfs_t *zfsvfs, znode_hold_t *zh)\n{\n\tint i = ZFS_OBJ_HASH(zfsvfs, zh->zh_obj);\n\tboolean_t remove = B_FALSE;\n\n\tASSERT(zfs_znode_held(zfsvfs, zh->zh_obj));\n\tmutex_exit(&zh->zh_lock);\n\n\tmutex_enter(&zfsvfs->z_hold_locks[i]);\n\tASSERT3S(zh->zh_refcount, >, 0);\n\tif (--zh->zh_refcount == 0) {\n\t\tavl_remove(&zfsvfs->z_hold_trees[i], zh);\n\t\tremove = B_TRUE;\n\t}\n\tmutex_exit(&zfsvfs->z_hold_locks[i]);\n\n\tif (remove == B_TRUE)\n\t\tkmem_cache_free(znode_hold_cache, zh);\n}\n\ndev_t\nzfs_cmpldev(uint64_t dev)\n{\n\treturn (dev);\n}\n\nstatic void\nzfs_znode_sa_init(zfsvfs_t *zfsvfs, znode_t *zp,\n    dmu_buf_t *db, dmu_object_type_t obj_type, sa_handle_t *sa_hdl)\n{\n\tASSERT(zfs_znode_held(zfsvfs, zp->z_id));\n\n\tmutex_enter(&zp->z_lock);\n\n\tASSERT(zp->z_sa_hdl == NULL);\n\tASSERT(zp->z_acl_cached == NULL);\n\tif (sa_hdl == NULL) {\n\t\tVERIFY(0 == sa_handle_get_from_db(zfsvfs->z_os, db, zp,\n\t\t    SA_HDL_SHARED, &zp->z_sa_hdl));\n\t} else {\n\t\tzp->z_sa_hdl = sa_hdl;\n\t\tsa_set_userp(sa_hdl, zp);\n\t}\n\n\tzp->z_is_sa = (obj_type == DMU_OT_SA) ? B_TRUE : B_FALSE;\n\n\tmutex_exit(&zp->z_lock);\n}\n\nvoid\nzfs_znode_dmu_fini(znode_t *zp)\n{\n\tASSERT(zfs_znode_held(ZTOZSB(zp), zp->z_id) ||\n\t    RW_WRITE_HELD(&ZTOZSB(zp)->z_teardown_inactive_lock));\n\n\tsa_handle_destroy(zp->z_sa_hdl);\n\tzp->z_sa_hdl = NULL;\n}\n\n \nint\nzfs_inode_alloc(struct super_block *sb, struct inode **ip)\n{\n\tznode_t *zp;\n\n\tzp = kmem_cache_alloc(znode_cache, KM_SLEEP);\n\t*ip = ZTOI(zp);\n\n\treturn (0);\n}\n\n \nvoid\nzfs_inode_destroy(struct inode *ip)\n{\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tif (list_link_active(&zp->z_link_node)) {\n\t\tlist_remove(&zfsvfs->z_all_znodes, zp);\n\t}\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n\tif (zp->z_acl_cached) {\n\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = NULL;\n\t}\n\n\tif (zp->z_xattr_cached) {\n\t\tnvlist_free(zp->z_xattr_cached);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\n\tkmem_cache_free(znode_cache, zp);\n}\n\nstatic void\nzfs_inode_set_ops(zfsvfs_t *zfsvfs, struct inode *ip)\n{\n\tuint64_t rdev = 0;\n\n\tswitch (ip->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tip->i_op = &zpl_inode_operations;\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\n\t\tip->i_fop = &zpl_file_operations.kabi_fops;\n#else\n\t\tip->i_fop = &zpl_file_operations;\n#endif\n\t\tip->i_mapping->a_ops = &zpl_address_space_operations;\n\t\tbreak;\n\n\tcase S_IFDIR:\n#ifdef HAVE_RENAME2_OPERATIONS_WRAPPER\n\t\tip->i_flags |= S_IOPS_WRAPPER;\n\t\tip->i_op = &zpl_dir_inode_operations.ops;\n#else\n\t\tip->i_op = &zpl_dir_inode_operations;\n#endif\n\t\tip->i_fop = &zpl_dir_file_operations;\n\t\tITOZ(ip)->z_zn_prefetch = B_TRUE;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tip->i_op = &zpl_symlink_inode_operations;\n\t\tbreak;\n\n\t \n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\t\t(void) sa_lookup(ITOZ(ip)->z_sa_hdl, SA_ZPL_RDEV(zfsvfs), &rdev,\n\t\t    sizeof (rdev));\n\t\tzfs_fallthrough;\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(ip, ip->i_mode, rdev);\n\t\tip->i_op = &zpl_special_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tzfs_panic_recover(\"inode %llu has invalid mode: 0x%x\\n\",\n\t\t    (u_longlong_t)ip->i_ino, ip->i_mode);\n\n\t\t \n\t\tip->i_mode = S_IFREG | 0644;\n\t\tip->i_op = &zpl_inode_operations;\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\n\t\tip->i_fop = &zpl_file_operations.kabi_fops;\n#else\n\t\tip->i_fop = &zpl_file_operations;\n#endif\n\t\tip->i_mapping->a_ops = &zpl_address_space_operations;\n\t\tbreak;\n\t}\n}\n\nstatic void\nzfs_set_inode_flags(znode_t *zp, struct inode *ip)\n{\n\t \n#ifdef HAVE_INODE_SET_FLAGS\n\tunsigned int flags = 0;\n\tif (zp->z_pflags & ZFS_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (zp->z_pflags & ZFS_APPENDONLY)\n\t\tflags |= S_APPEND;\n\n\tinode_set_flags(ip, flags, S_IMMUTABLE|S_APPEND);\n#else\n\tif (zp->z_pflags & ZFS_IMMUTABLE)\n\t\tip->i_flags |= S_IMMUTABLE;\n\telse\n\t\tip->i_flags &= ~S_IMMUTABLE;\n\n\tif (zp->z_pflags & ZFS_APPENDONLY)\n\t\tip->i_flags |= S_APPEND;\n\telse\n\t\tip->i_flags &= ~S_APPEND;\n#endif\n}\n\n \nvoid\nzfs_znode_update_vfs(znode_t *zp)\n{\n\tstruct inode\t*ip;\n\tuint32_t\tblksize;\n\tu_longlong_t\ti_blocks;\n\n\tASSERT(zp != NULL);\n\tip = ZTOI(zp);\n\n\t \n\tif (zfsctl_is_node(ip))\n\t\treturn;\n\n\tdmu_object_size_from_db(sa_get_db(zp->z_sa_hdl), &blksize, &i_blocks);\n\n\tspin_lock(&ip->i_lock);\n\tip->i_mode = zp->z_mode;\n\tip->i_blocks = i_blocks;\n\ti_size_write(ip, zp->z_size);\n\tspin_unlock(&ip->i_lock);\n}\n\n\n \nstatic znode_t *\nzfs_znode_alloc(zfsvfs_t *zfsvfs, dmu_buf_t *db, int blksz,\n    dmu_object_type_t obj_type, sa_handle_t *hdl)\n{\n\tznode_t\t*zp;\n\tstruct inode *ip;\n\tuint64_t mode;\n\tuint64_t parent;\n\tuint64_t tmp_gen;\n\tuint64_t links;\n\tuint64_t z_uid, z_gid;\n\tuint64_t atime[2], mtime[2], ctime[2], btime[2];\n\tinode_timespec_t tmp_ctime;\n\tuint64_t projid = ZFS_DEFAULT_PROJID;\n\tsa_bulk_attr_t bulk[12];\n\tint count = 0;\n\n\tASSERT(zfsvfs != NULL);\n\n\tip = new_inode(zfsvfs->z_sb);\n\tif (ip == NULL)\n\t\treturn (NULL);\n\n\tzp = ITOZ(ip);\n\tASSERT(zp->z_dirlocks == NULL);\n\tASSERT3P(zp->z_acl_cached, ==, NULL);\n\tASSERT3P(zp->z_xattr_cached, ==, NULL);\n\tzp->z_unlinked = B_FALSE;\n\tzp->z_atime_dirty = B_FALSE;\n#if !defined(HAVE_FILEMAP_RANGE_HAS_PAGE)\n\tzp->z_is_mapped = B_FALSE;\n#endif\n\tzp->z_is_ctldir = B_FALSE;\n\tzp->z_suspended = B_FALSE;\n\tzp->z_sa_hdl = NULL;\n\tzp->z_mapcnt = 0;\n\tzp->z_id = db->db_object;\n\tzp->z_blksz = blksz;\n\tzp->z_seq = 0x7A4653;\n\tzp->z_sync_cnt = 0;\n\tzp->z_sync_writes_cnt = 0;\n\tzp->z_async_writes_cnt = 0;\n\n\tzfs_znode_sa_init(zfsvfs, zp, db, obj_type, hdl);\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL, &mode, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GEN(zfsvfs), NULL, &tmp_gen, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL, &links, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PARENT(zfsvfs), NULL,\n\t    &parent, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL, &z_uid, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL, &z_gid, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL, &atime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CRTIME(zfsvfs), NULL, &btime, 16);\n\n\tif (sa_bulk_lookup(zp->z_sa_hdl, bulk, count) != 0 || tmp_gen == 0 ||\n\t    (dmu_objset_projectquota_enabled(zfsvfs->z_os) &&\n\t    (zp->z_pflags & ZFS_PROJID) &&\n\t    sa_lookup(zp->z_sa_hdl, SA_ZPL_PROJID(zfsvfs), &projid, 8) != 0)) {\n\t\tif (hdl == NULL)\n\t\t\tsa_handle_destroy(zp->z_sa_hdl);\n\t\tzp->z_sa_hdl = NULL;\n\t\tgoto error;\n\t}\n\n\tzp->z_projid = projid;\n\tzp->z_mode = ip->i_mode = mode;\n\tip->i_generation = (uint32_t)tmp_gen;\n\tip->i_blkbits = SPA_MINBLOCKSHIFT;\n\tset_nlink(ip, (uint32_t)links);\n\tzfs_uid_write(ip, z_uid);\n\tzfs_gid_write(ip, z_gid);\n\tzfs_set_inode_flags(zp, ip);\n\n\t \n\tif (zp->z_pflags & ZFS_XATTR)\n\t\tzp->z_xattr_parent = parent;\n\n\tZFS_TIME_DECODE(&ip->i_atime, atime);\n\tZFS_TIME_DECODE(&ip->i_mtime, mtime);\n\tZFS_TIME_DECODE(&tmp_ctime, ctime);\n\tzpl_inode_set_ctime_to_ts(ip, tmp_ctime);\n\tZFS_TIME_DECODE(&zp->z_btime, btime);\n\n\tip->i_ino = zp->z_id;\n\tzfs_znode_update_vfs(zp);\n\tzfs_inode_set_ops(zfsvfs, ip);\n\n\t \n\tif (links > 0)\n\t\tVERIFY3S(insert_inode_locked(ip), ==, 0);\n\n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tlist_insert_tail(&zfsvfs->z_all_znodes, zp);\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n\tif (links > 0)\n\t\tunlock_new_inode(ip);\n\treturn (zp);\n\nerror:\n\tiput(ip);\n\treturn (NULL);\n}\n\n \nvoid\nzfs_mark_inode_dirty(struct inode *ip)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\n\tif (zfs_is_readonly(zfsvfs) || dmu_objset_is_snapshot(zfsvfs->z_os))\n\t\treturn;\n\n\tmark_inode_dirty(ip);\n}\n\nstatic uint64_t empty_xattr;\nstatic uint64_t pad[4];\nstatic zfs_acl_phys_t acl_phys;\n \nvoid\nzfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,\n    uint_t flag, znode_t **zpp, zfs_acl_ids_t *acl_ids)\n{\n\tuint64_t\tcrtime[2], atime[2], mtime[2], ctime[2];\n\tuint64_t\tmode, size, links, parent, pflags;\n\tuint64_t\tprojid = ZFS_DEFAULT_PROJID;\n\tuint64_t\trdev = 0;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tdmu_buf_t\t*db;\n\tinode_timespec_t now;\n\tuint64_t\tgen, obj;\n\tint\t\tbonuslen;\n\tint\t\tdnodesize;\n\tsa_handle_t\t*sa_hdl;\n\tdmu_object_type_t obj_type;\n\tsa_bulk_attr_t\t*sa_attrs;\n\tint\t\tcnt = 0;\n\tzfs_acl_locator_cb_t locate = { 0 };\n\tznode_hold_t\t*zh;\n\n\tif (zfsvfs->z_replay) {\n\t\tobj = vap->va_nodeid;\n\t\tnow = vap->va_ctime;\t\t \n\t\tgen = vap->va_nblocks;\t\t \n\t\tdnodesize = vap->va_fsid;\t \n\t} else {\n\t\tobj = 0;\n\t\tgethrestime(&now);\n\t\tgen = dmu_tx_get_txg(tx);\n\t\tdnodesize = dmu_objset_dnodesize(zfsvfs->z_os);\n\t}\n\n\tif (dnodesize == 0)\n\t\tdnodesize = DNODE_MIN_SIZE;\n\n\tobj_type = zfsvfs->z_use_sa ? DMU_OT_SA : DMU_OT_ZNODE;\n\n\tbonuslen = (obj_type == DMU_OT_SA) ?\n\t    DN_BONUS_SIZE(dnodesize) : ZFS_OLD_ZNODE_PHYS_SIZE;\n\n\t \n\t \n\tif (S_ISDIR(vap->va_mode)) {\n\t\tif (zfsvfs->z_replay) {\n\t\t\tVERIFY0(zap_create_claim_norm_dnsize(zfsvfs->z_os, obj,\n\t\t\t    zfsvfs->z_norm, DMU_OT_DIRECTORY_CONTENTS,\n\t\t\t    obj_type, bonuslen, dnodesize, tx));\n\t\t} else {\n\t\t\tobj = zap_create_norm_dnsize(zfsvfs->z_os,\n\t\t\t    zfsvfs->z_norm, DMU_OT_DIRECTORY_CONTENTS,\n\t\t\t    obj_type, bonuslen, dnodesize, tx);\n\t\t}\n\t} else {\n\t\tif (zfsvfs->z_replay) {\n\t\t\tVERIFY0(dmu_object_claim_dnsize(zfsvfs->z_os, obj,\n\t\t\t    DMU_OT_PLAIN_FILE_CONTENTS, 0,\n\t\t\t    obj_type, bonuslen, dnodesize, tx));\n\t\t} else {\n\t\t\tobj = dmu_object_alloc_dnsize(zfsvfs->z_os,\n\t\t\t    DMU_OT_PLAIN_FILE_CONTENTS, 0,\n\t\t\t    obj_type, bonuslen, dnodesize, tx);\n\t\t}\n\t}\n\n\tzh = zfs_znode_hold_enter(zfsvfs, obj);\n\tVERIFY0(sa_buf_hold(zfsvfs->z_os, obj, NULL, &db));\n\n\t \n\tif (flag & IS_ROOT_NODE) {\n\t\tdzp->z_id = obj;\n\t}\n\n\t \n\tif (dzp->z_pflags & ZFS_XATTR) {\n\t\tflag |= IS_XATTR;\n\t}\n\n\tif (zfsvfs->z_use_fuids)\n\t\tpflags = ZFS_ARCHIVE | ZFS_AV_MODIFIED;\n\telse\n\t\tpflags = 0;\n\n\tif (S_ISDIR(vap->va_mode)) {\n\t\tsize = 2;\t\t \n\t\tlinks = 2;\n\t} else {\n\t\tsize = 0;\n\t\tlinks = (flag & IS_TMPFILE) ? 0 : 1;\n\t}\n\n\tif (S_ISBLK(vap->va_mode) || S_ISCHR(vap->va_mode))\n\t\trdev = vap->va_rdev;\n\n\tparent = dzp->z_id;\n\tmode = acl_ids->z_mode;\n\tif (flag & IS_XATTR)\n\t\tpflags |= ZFS_XATTR;\n\n\tif (S_ISREG(vap->va_mode) || S_ISDIR(vap->va_mode)) {\n\t\t \n\t\tif (obj_type != DMU_OT_ZNODE &&\n\t\t    dmu_objset_projectquota_enabled(zfsvfs->z_os))\n\t\t\tpflags |= ZFS_PROJID;\n\n\t\t \n\t\tprojid = zfs_inherit_projid(dzp);\n\t\tif (dzp->z_pflags & ZFS_PROJINHERIT)\n\t\t\tpflags |= ZFS_PROJINHERIT;\n\t}\n\n\t \n\tpflags |= acl_ids->z_aclp->z_hints &\n\t    (ZFS_ACL_TRIVIAL|ZFS_INHERIT_ACE|ZFS_ACL_AUTO_INHERIT|\n\t    ZFS_ACL_DEFAULTED|ZFS_ACL_PROTECTED);\n\n\tZFS_TIME_ENCODE(&now, crtime);\n\tZFS_TIME_ENCODE(&now, ctime);\n\n\tif (vap->va_mask & ATTR_ATIME) {\n\t\tZFS_TIME_ENCODE(&vap->va_atime, atime);\n\t} else {\n\t\tZFS_TIME_ENCODE(&now, atime);\n\t}\n\n\tif (vap->va_mask & ATTR_MTIME) {\n\t\tZFS_TIME_ENCODE(&vap->va_mtime, mtime);\n\t} else {\n\t\tZFS_TIME_ENCODE(&now, mtime);\n\t}\n\n\t \n\tVERIFY(0 == sa_handle_get_from_db(zfsvfs->z_os, db, NULL, SA_HDL_SHARED,\n\t    &sa_hdl));\n\n\t \n\tsa_attrs = kmem_alloc(sizeof (sa_bulk_attr_t) * ZPL_END, KM_SLEEP);\n\n\tif (obj_type == DMU_OT_ZNODE) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ATIME(zfsvfs),\n\t\t    NULL, &atime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MTIME(zfsvfs),\n\t\t    NULL, &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CTIME(zfsvfs),\n\t\t    NULL, &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CRTIME(zfsvfs),\n\t\t    NULL, &crtime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GEN(zfsvfs),\n\t\t    NULL, &gen, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MODE(zfsvfs),\n\t\t    NULL, &mode, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_SIZE(zfsvfs),\n\t\t    NULL, &size, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PARENT(zfsvfs),\n\t\t    NULL, &parent, 8);\n\t} else {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MODE(zfsvfs),\n\t\t    NULL, &mode, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_SIZE(zfsvfs),\n\t\t    NULL, &size, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GEN(zfsvfs),\n\t\t    NULL, &gen, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_UID(zfsvfs),\n\t\t    NULL, &acl_ids->z_fuid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GID(zfsvfs),\n\t\t    NULL, &acl_ids->z_fgid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PARENT(zfsvfs),\n\t\t    NULL, &parent, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &pflags, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ATIME(zfsvfs),\n\t\t    NULL, &atime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MTIME(zfsvfs),\n\t\t    NULL, &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CTIME(zfsvfs),\n\t\t    NULL, &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CRTIME(zfsvfs),\n\t\t    NULL, &crtime, 16);\n\t}\n\n\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_LINKS(zfsvfs), NULL, &links, 8);\n\n\tif (obj_type == DMU_OT_ZNODE) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_XATTR(zfsvfs), NULL,\n\t\t    &empty_xattr, 8);\n\t} else if (dmu_objset_projectquota_enabled(zfsvfs->z_os) &&\n\t    pflags & ZFS_PROJID) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PROJID(zfsvfs),\n\t\t    NULL, &projid, 8);\n\t}\n\tif (obj_type == DMU_OT_ZNODE ||\n\t    (S_ISBLK(vap->va_mode) || S_ISCHR(vap->va_mode))) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_RDEV(zfsvfs),\n\t\t    NULL, &rdev, 8);\n\t}\n\tif (obj_type == DMU_OT_ZNODE) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &pflags, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_UID(zfsvfs), NULL,\n\t\t    &acl_ids->z_fuid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GID(zfsvfs), NULL,\n\t\t    &acl_ids->z_fgid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PAD(zfsvfs), NULL, pad,\n\t\t    sizeof (uint64_t) * 4);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ZNODE_ACL(zfsvfs), NULL,\n\t\t    &acl_phys, sizeof (zfs_acl_phys_t));\n\t} else if (acl_ids->z_aclp->z_version >= ZFS_ACL_VERSION_FUID) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_DACL_COUNT(zfsvfs), NULL,\n\t\t    &acl_ids->z_aclp->z_acl_count, 8);\n\t\tlocate.cb_aclp = acl_ids->z_aclp;\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_DACL_ACES(zfsvfs),\n\t\t    zfs_acl_data_locator, &locate,\n\t\t    acl_ids->z_aclp->z_acl_bytes);\n\t\tmode = zfs_mode_compute(mode, acl_ids->z_aclp, &pflags,\n\t\t    acl_ids->z_fuid, acl_ids->z_fgid);\n\t}\n\n\tVERIFY(sa_replace_all_by_template(sa_hdl, sa_attrs, cnt, tx) == 0);\n\n\tif (!(flag & IS_ROOT_NODE)) {\n\t\t \n\t\tdo {\n\t\t\t*zpp = zfs_znode_alloc(zfsvfs, db, 0, obj_type, sa_hdl);\n\t\t} while (*zpp == NULL);\n\n\t\tVERIFY(*zpp != NULL);\n\t\tVERIFY(dzp != NULL);\n\t} else {\n\t\t \n\t\t*zpp = dzp;\n\n\t\t(*zpp)->z_sa_hdl = sa_hdl;\n\t}\n\n\t(*zpp)->z_pflags = pflags;\n\t(*zpp)->z_mode = ZTOI(*zpp)->i_mode = mode;\n\t(*zpp)->z_dnodesize = dnodesize;\n\t(*zpp)->z_projid = projid;\n\n\tif (obj_type == DMU_OT_ZNODE ||\n\t    acl_ids->z_aclp->z_version < ZFS_ACL_VERSION_FUID) {\n\t\tVERIFY0(zfs_aclset_common(*zpp, acl_ids->z_aclp, cr, tx));\n\t}\n\tkmem_free(sa_attrs, sizeof (sa_bulk_attr_t) * ZPL_END);\n\tzfs_znode_hold_exit(zfsvfs, zh);\n}\n\n \nvoid\nzfs_xvattr_set(znode_t *zp, xvattr_t *xvap, dmu_tx_t *tx)\n{\n\txoptattr_t *xoap;\n\tboolean_t update_inode = B_FALSE;\n\n\txoap = xva_getxoptattr(xvap);\n\tASSERT(xoap);\n\n\tif (XVA_ISSET_REQ(xvap, XAT_CREATETIME)) {\n\t\tuint64_t times[2];\n\t\tZFS_TIME_ENCODE(&xoap->xoa_createtime, times);\n\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_CRTIME(ZTOZSB(zp)),\n\t\t    &times, sizeof (times), tx);\n\t\tXVA_SET_RTN(xvap, XAT_CREATETIME);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_READONLY)) {\n\t\tZFS_ATTR_SET(zp, ZFS_READONLY, xoap->xoa_readonly,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_READONLY);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_HIDDEN)) {\n\t\tZFS_ATTR_SET(zp, ZFS_HIDDEN, xoap->xoa_hidden,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_HIDDEN);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_SYSTEM)) {\n\t\tZFS_ATTR_SET(zp, ZFS_SYSTEM, xoap->xoa_system,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_SYSTEM);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_ARCHIVE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_ARCHIVE, xoap->xoa_archive,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_ARCHIVE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_IMMUTABLE, xoap->xoa_immutable,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_IMMUTABLE);\n\n\t\tupdate_inode = B_TRUE;\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK)) {\n\t\tZFS_ATTR_SET(zp, ZFS_NOUNLINK, xoap->xoa_nounlink,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_NOUNLINK);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY)) {\n\t\tZFS_ATTR_SET(zp, ZFS_APPENDONLY, xoap->xoa_appendonly,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_APPENDONLY);\n\n\t\tupdate_inode = B_TRUE;\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP)) {\n\t\tZFS_ATTR_SET(zp, ZFS_NODUMP, xoap->xoa_nodump,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_NODUMP);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_OPAQUE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_OPAQUE, xoap->xoa_opaque,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_OPAQUE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED)) {\n\t\tZFS_ATTR_SET(zp, ZFS_AV_QUARANTINED,\n\t\t    xoap->xoa_av_quarantined, zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_AV_QUARANTINED);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED)) {\n\t\tZFS_ATTR_SET(zp, ZFS_AV_MODIFIED, xoap->xoa_av_modified,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_AV_MODIFIED);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP)) {\n\t\tzfs_sa_set_scanstamp(zp, xvap, tx);\n\t\tXVA_SET_RTN(xvap, XAT_AV_SCANSTAMP);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_REPARSE, xoap->xoa_reparse,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_REPARSE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_OFFLINE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_OFFLINE, xoap->xoa_offline,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_OFFLINE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_SPARSE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_SPARSE, xoap->xoa_sparse,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_SPARSE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT)) {\n\t\tZFS_ATTR_SET(zp, ZFS_PROJINHERIT, xoap->xoa_projinherit,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_PROJINHERIT);\n\t}\n\n\tif (update_inode)\n\t\tzfs_set_inode_flags(zp, ZTOI(zp));\n}\n\nint\nzfs_zget(zfsvfs_t *zfsvfs, uint64_t obj_num, znode_t **zpp)\n{\n\tdmu_object_info_t doi;\n\tdmu_buf_t\t*db;\n\tznode_t\t\t*zp;\n\tznode_hold_t\t*zh;\n\tint err;\n\tsa_handle_t\t*hdl;\n\n\t*zpp = NULL;\n\nagain:\n\tzh = zfs_znode_hold_enter(zfsvfs, obj_num);\n\n\terr = sa_buf_hold(zfsvfs->z_os, obj_num, NULL, &db);\n\tif (err) {\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\treturn (err);\n\t}\n\n\tdmu_object_info_from_db(db, &doi);\n\tif (doi.doi_bonus_type != DMU_OT_SA &&\n\t    (doi.doi_bonus_type != DMU_OT_ZNODE ||\n\t    (doi.doi_bonus_type == DMU_OT_ZNODE &&\n\t    doi.doi_bonus_size < sizeof (znode_phys_t)))) {\n\t\tsa_buf_rele(db, NULL);\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\thdl = dmu_buf_get_user(db);\n\tif (hdl != NULL) {\n\t\tzp = sa_get_userdata(hdl);\n\n\n\t\t \n\n\t\tASSERT3P(zp, !=, NULL);\n\n\t\tmutex_enter(&zp->z_lock);\n\t\tASSERT3U(zp->z_id, ==, obj_num);\n\t\t \n\t\tif (igrab(ZTOI(zp)) == NULL) {\n\t\t\tif (zp->z_unlinked)\n\t\t\t\terr = SET_ERROR(ENOENT);\n\t\t\telse\n\t\t\t\terr = SET_ERROR(EAGAIN);\n\t\t} else {\n\t\t\t*zpp = zp;\n\t\t\terr = 0;\n\t\t}\n\n\t\tmutex_exit(&zp->z_lock);\n\t\tsa_buf_rele(db, NULL);\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\n\t\tif (err == EAGAIN) {\n\t\t\t \n\t\t\tcond_resched();\n\t\t\tgoto again;\n\t\t}\n\t\treturn (err);\n\t}\n\n\t \n\tzp = zfs_znode_alloc(zfsvfs, db, doi.doi_data_block_size,\n\t    doi.doi_bonus_type, NULL);\n\tif (zp == NULL) {\n\t\terr = SET_ERROR(ENOENT);\n\t} else {\n\t\t*zpp = zp;\n\t}\n\tzfs_znode_hold_exit(zfsvfs, zh);\n\treturn (err);\n}\n\nint\nzfs_rezget(znode_t *zp)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tdmu_object_info_t doi;\n\tdmu_buf_t *db;\n\tuint64_t obj_num = zp->z_id;\n\tuint64_t mode;\n\tuint64_t links;\n\tsa_bulk_attr_t bulk[11];\n\tint err;\n\tint count = 0;\n\tuint64_t gen;\n\tuint64_t z_uid, z_gid;\n\tuint64_t atime[2], mtime[2], ctime[2], btime[2];\n\tinode_timespec_t tmp_ctime;\n\tuint64_t projid = ZFS_DEFAULT_PROJID;\n\tznode_hold_t *zh;\n\n\t \n\tif (zp->z_is_ctldir)\n\t\treturn (0);\n\n\tzh = zfs_znode_hold_enter(zfsvfs, obj_num);\n\n\tmutex_enter(&zp->z_acl_lock);\n\tif (zp->z_acl_cached) {\n\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = NULL;\n\t}\n\tmutex_exit(&zp->z_acl_lock);\n\n\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\tif (zp->z_xattr_cached) {\n\t\tnvlist_free(zp->z_xattr_cached);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\trw_exit(&zp->z_xattr_lock);\n\n\tASSERT(zp->z_sa_hdl == NULL);\n\terr = sa_buf_hold(zfsvfs->z_os, obj_num, NULL, &db);\n\tif (err) {\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\treturn (err);\n\t}\n\n\tdmu_object_info_from_db(db, &doi);\n\tif (doi.doi_bonus_type != DMU_OT_SA &&\n\t    (doi.doi_bonus_type != DMU_OT_ZNODE ||\n\t    (doi.doi_bonus_type == DMU_OT_ZNODE &&\n\t    doi.doi_bonus_size < sizeof (znode_phys_t)))) {\n\t\tsa_buf_rele(db, NULL);\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tzfs_znode_sa_init(zfsvfs, zp, db, doi.doi_bonus_type, NULL);\n\n\t \n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GEN(zfsvfs), NULL,\n\t    &gen, sizeof (gen));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, sizeof (zp->z_size));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL,\n\t    &links, sizeof (links));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t    &z_uid, sizeof (z_uid));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL,\n\t    &z_gid, sizeof (z_gid));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t    &mode, sizeof (mode));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t    &atime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t    &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t    &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CRTIME(zfsvfs), NULL, &btime, 16);\n\n\tif (sa_bulk_lookup(zp->z_sa_hdl, bulk, count)) {\n\t\tzfs_znode_dmu_fini(zp);\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\tif (dmu_objset_projectquota_enabled(zfsvfs->z_os)) {\n\t\terr = sa_lookup(zp->z_sa_hdl, SA_ZPL_PROJID(zfsvfs),\n\t\t    &projid, 8);\n\t\tif (err != 0 && err != ENOENT) {\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\t\treturn (SET_ERROR(err));\n\t\t}\n\t}\n\n\tzp->z_projid = projid;\n\tzp->z_mode = ZTOI(zp)->i_mode = mode;\n\tzfs_uid_write(ZTOI(zp), z_uid);\n\tzfs_gid_write(ZTOI(zp), z_gid);\n\n\tZFS_TIME_DECODE(&ZTOI(zp)->i_atime, atime);\n\tZFS_TIME_DECODE(&ZTOI(zp)->i_mtime, mtime);\n\tZFS_TIME_DECODE(&tmp_ctime, ctime);\n\tzpl_inode_set_ctime_to_ts(ZTOI(zp), tmp_ctime);\n\tZFS_TIME_DECODE(&zp->z_btime, btime);\n\n\tif ((uint32_t)gen != ZTOI(zp)->i_generation) {\n\t\tzfs_znode_dmu_fini(zp);\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\tset_nlink(ZTOI(zp), (uint32_t)links);\n\tzfs_set_inode_flags(zp, ZTOI(zp));\n\n\tzp->z_blksz = doi.doi_data_block_size;\n\tzp->z_atime_dirty = B_FALSE;\n\tzfs_znode_update_vfs(zp);\n\n\t \n\tzp->z_unlinked = (ZTOI(zp)->i_nlink == 0);\n\tif (zp->z_unlinked)\n\t\tzfs_znode_dmu_fini(zp);\n\n\tzfs_znode_hold_exit(zfsvfs, zh);\n\n\treturn (0);\n}\n\nvoid\nzfs_znode_delete(znode_t *zp, dmu_tx_t *tx)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tobjset_t *os = zfsvfs->z_os;\n\tuint64_t obj = zp->z_id;\n\tuint64_t acl_obj = zfs_external_acl(zp);\n\tznode_hold_t *zh;\n\n\tzh = zfs_znode_hold_enter(zfsvfs, obj);\n\tif (acl_obj) {\n\t\tVERIFY(!zp->z_is_sa);\n\t\tVERIFY(0 == dmu_object_free(os, acl_obj, tx));\n\t}\n\tVERIFY(0 == dmu_object_free(os, obj, tx));\n\tzfs_znode_dmu_fini(zp);\n\tzfs_znode_hold_exit(zfsvfs, zh);\n}\n\nvoid\nzfs_zinactive(znode_t *zp)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tuint64_t z_id = zp->z_id;\n\tznode_hold_t *zh;\n\n\tASSERT(zp->z_sa_hdl);\n\n\t \n\tzh = zfs_znode_hold_enter(zfsvfs, z_id);\n\n\tmutex_enter(&zp->z_lock);\n\n\t \n\tif (zp->z_unlinked) {\n\t\tASSERT(!zfsvfs->z_issnap);\n\t\tif (!zfs_is_readonly(zfsvfs) && !zfs_unlink_suspend_progress) {\n\t\t\tmutex_exit(&zp->z_lock);\n\t\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\t\tzfs_rmnode(zp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmutex_exit(&zp->z_lock);\n\tzfs_znode_dmu_fini(zp);\n\n\tzfs_znode_hold_exit(zfsvfs, zh);\n}\n\n#if defined(HAVE_INODE_TIMESPEC64_TIMES)\n#define\tzfs_compare_timespec timespec64_compare\n#else\n#define\tzfs_compare_timespec timespec_compare\n#endif\n\n \nboolean_t\nzfs_relatime_need_update(const struct inode *ip)\n{\n\tinode_timespec_t now, tmp_ctime;\n\n\tgethrestime(&now);\n\t \n\tif (zfs_compare_timespec(&ip->i_mtime, &ip->i_atime) >= 0)\n\t\treturn (B_TRUE);\n\n\ttmp_ctime = zpl_inode_get_ctime(ip);\n\tif (zfs_compare_timespec(&tmp_ctime, &ip->i_atime) >= 0)\n\t\treturn (B_TRUE);\n\n\tif ((hrtime_t)now.tv_sec - (hrtime_t)ip->i_atime.tv_sec >= 24*60*60)\n\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\n \nvoid\nzfs_tstamp_update_setup(znode_t *zp, uint_t flag, uint64_t mtime[2],\n    uint64_t ctime[2])\n{\n\tinode_timespec_t now, tmp_ctime;\n\n\tgethrestime(&now);\n\n\tzp->z_seq++;\n\n\tif (flag & ATTR_MTIME) {\n\t\tZFS_TIME_ENCODE(&now, mtime);\n\t\tZFS_TIME_DECODE(&(ZTOI(zp)->i_mtime), mtime);\n\t\tif (ZTOZSB(zp)->z_use_fuids) {\n\t\t\tzp->z_pflags |= (ZFS_ARCHIVE |\n\t\t\t    ZFS_AV_MODIFIED);\n\t\t}\n\t}\n\n\tif (flag & ATTR_CTIME) {\n\t\tZFS_TIME_ENCODE(&now, ctime);\n\t\tZFS_TIME_DECODE(&tmp_ctime, ctime);\n\t\tzpl_inode_set_ctime_to_ts(ZTOI(zp), tmp_ctime);\n\t\tif (ZTOZSB(zp)->z_use_fuids)\n\t\t\tzp->z_pflags |= ZFS_ARCHIVE;\n\t}\n}\n\n \nvoid\nzfs_grow_blocksize(znode_t *zp, uint64_t size, dmu_tx_t *tx)\n{\n\tint\t\terror;\n\tu_longlong_t\tdummy;\n\n\tif (size <= zp->z_blksz)\n\t\treturn;\n\t \n\tif (zp->z_blksz && zp->z_size > zp->z_blksz)\n\t\treturn;\n\n\terror = dmu_object_set_blocksize(ZTOZSB(zp)->z_os, zp->z_id,\n\t    size, 0, tx);\n\n\tif (error == ENOTSUP)\n\t\treturn;\n\tASSERT0(error);\n\n\t \n\tdmu_object_size_from_db(sa_get_db(zp->z_sa_hdl), &zp->z_blksz, &dummy);\n}\n\n \nstatic int\nzfs_extend(znode_t *zp, uint64_t end)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tdmu_tx_t *tx;\n\tzfs_locked_range_t *lr;\n\tuint64_t newblksz;\n\tint error;\n\n\t \n\tlr = zfs_rangelock_enter(&zp->z_rangelock, 0, UINT64_MAX, RL_WRITER);\n\n\t \n\tif (end <= zp->z_size) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (0);\n\t}\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tif (end > zp->z_blksz &&\n\t    (!ISP2(zp->z_blksz) || zp->z_blksz < zfsvfs->z_max_blksz)) {\n\t\t \n\t\tif (zp->z_blksz > ZTOZSB(zp)->z_max_blksz) {\n\t\t\t \n\t\t\tASSERT(!ISP2(zp->z_blksz));\n\t\t\tnewblksz = MIN(end, 1 << highbit64(zp->z_blksz));\n\t\t} else {\n\t\t\tnewblksz = MIN(end, ZTOZSB(zp)->z_max_blksz);\n\t\t}\n\t\tdmu_tx_hold_write(tx, zp->z_id, 0, newblksz);\n\t} else {\n\t\tnewblksz = 0;\n\t}\n\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (error);\n\t}\n\n\tif (newblksz)\n\t\tzfs_grow_blocksize(zp, newblksz, tx);\n\n\tzp->z_size = end;\n\n\tVERIFY(0 == sa_update(zp->z_sa_hdl, SA_ZPL_SIZE(ZTOZSB(zp)),\n\t    &zp->z_size, sizeof (zp->z_size), tx));\n\n\tzfs_rangelock_exit(lr);\n\n\tdmu_tx_commit(tx);\n\n\treturn (0);\n}\n\n \nstatic void\nzfs_zero_partial_page(znode_t *zp, uint64_t start, uint64_t len)\n{\n\tstruct address_space *mp = ZTOI(zp)->i_mapping;\n\tstruct page *pp;\n\tint64_t\toff;\n\tvoid *pb;\n\n\tASSERT((start & PAGE_MASK) == ((start + len - 1) & PAGE_MASK));\n\n\toff = start & (PAGE_SIZE - 1);\n\tstart &= PAGE_MASK;\n\n\tpp = find_lock_page(mp, start >> PAGE_SHIFT);\n\tif (pp) {\n\t\tif (mapping_writably_mapped(mp))\n\t\t\tflush_dcache_page(pp);\n\n\t\tpb = kmap(pp);\n\t\tmemset(pb + off, 0, len);\n\t\tkunmap(pp);\n\n\t\tif (mapping_writably_mapped(mp))\n\t\t\tflush_dcache_page(pp);\n\n\t\tmark_page_accessed(pp);\n\t\tSetPageUptodate(pp);\n\t\tClearPageError(pp);\n\t\tunlock_page(pp);\n\t\tput_page(pp);\n\t}\n}\n\n \nstatic int\nzfs_free_range(znode_t *zp, uint64_t off, uint64_t len)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tzfs_locked_range_t *lr;\n\tint error;\n\n\t \n\tlr = zfs_rangelock_enter(&zp->z_rangelock, off, len, RL_WRITER);\n\n\t \n\tif (off >= zp->z_size) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (0);\n\t}\n\n\tif (off + len > zp->z_size)\n\t\tlen = zp->z_size - off;\n\n\terror = dmu_free_long_range(zfsvfs->z_os, zp->z_id, off, len);\n\n\t \n\tif (zn_has_cached_data(zp, off, off + len - 1)) {\n\t\tloff_t first_page, last_page, page_len;\n\t\tloff_t first_page_offset, last_page_offset;\n\n\t\t \n\t\tfirst_page = (off + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\t \n\t\tlast_page = (off + len) >> PAGE_SHIFT;\n\n\t\t \n\t\tfirst_page_offset = first_page << PAGE_SHIFT;\n\t\t \n\t\tlast_page_offset = last_page << PAGE_SHIFT;\n\n\t\t \n\t\tif (last_page_offset > first_page_offset) {\n\t\t\ttruncate_inode_pages_range(ZTOI(zp)->i_mapping,\n\t\t\t    first_page_offset, last_page_offset - 1);\n\t\t}\n\n\t\t \n\t\tif (first_page > last_page) {\n\t\t\t \n\t\t\tzfs_zero_partial_page(zp, off, len);\n\t\t} else {\n\t\t\t \n\t\t\tpage_len  = first_page_offset - off;\n\t\t\tif (page_len > 0)\n\t\t\t\tzfs_zero_partial_page(zp, off, page_len);\n\n\t\t\t \n\t\t\tpage_len = off + len - last_page_offset;\n\t\t\tif (page_len > 0)\n\t\t\t\tzfs_zero_partial_page(zp, last_page_offset,\n\t\t\t\t    page_len);\n\t\t}\n\t}\n\tzfs_rangelock_exit(lr);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_trunc(znode_t *zp, uint64_t end)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tdmu_tx_t *tx;\n\tzfs_locked_range_t *lr;\n\tint error;\n\tsa_bulk_attr_t bulk[2];\n\tint count = 0;\n\n\t \n\tlr = zfs_rangelock_enter(&zp->z_rangelock, 0, UINT64_MAX, RL_WRITER);\n\n\t \n\tif (end >= zp->z_size) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (0);\n\t}\n\n\terror = dmu_free_long_range(zfsvfs->z_os, zp->z_id, end,\n\t    DMU_OBJECT_END);\n\tif (error) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (error);\n\t}\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tdmu_tx_mark_netfree(tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (error);\n\t}\n\n\tzp->z_size = end;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs),\n\t    NULL, &zp->z_size, sizeof (zp->z_size));\n\n\tif (end == 0) {\n\t\tzp->z_pflags &= ~ZFS_SPARSE;\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &zp->z_pflags, 8);\n\t}\n\tVERIFY(sa_bulk_update(zp->z_sa_hdl, bulk, count, tx) == 0);\n\n\tdmu_tx_commit(tx);\n\tzfs_rangelock_exit(lr);\n\n\treturn (0);\n}\n\n \nint\nzfs_freesp(znode_t *zp, uint64_t off, uint64_t len, int flag, boolean_t log)\n{\n\tdmu_tx_t *tx;\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tzilog_t *zilog = zfsvfs->z_log;\n\tuint64_t mode;\n\tuint64_t mtime[2], ctime[2];\n\tsa_bulk_attr_t bulk[3];\n\tint count = 0;\n\tint error;\n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_MODE(zfsvfs), &mode,\n\t    sizeof (mode))) != 0)\n\t\treturn (error);\n\n\tif (off > zp->z_size) {\n\t\terror =  zfs_extend(zp, off+len);\n\t\tif (error == 0 && log)\n\t\t\tgoto log;\n\t\tgoto out;\n\t}\n\n\tif (len == 0) {\n\t\terror = zfs_trunc(zp, off);\n\t} else {\n\t\tif ((error = zfs_free_range(zp, off, len)) == 0 &&\n\t\t    off + len > zp->z_size)\n\t\t\terror = zfs_extend(zp, off+len);\n\t}\n\tif (error || !log)\n\t\tgoto out;\nlog:\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tgoto out;\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL, mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL, ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t    NULL, &zp->z_pflags, 8);\n\tzfs_tstamp_update_setup(zp, CONTENT_MODIFIED, mtime, ctime);\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\tASSERT(error == 0);\n\n\tzfs_log_truncate(zilog, tx, TX_TRUNCATE, zp, off, len);\n\n\tdmu_tx_commit(tx);\n\n\tzfs_znode_update_vfs(zp);\n\terror = 0;\n\nout:\n\t \n\tif (len == 0)\n\t\ttruncate_setsize(ZTOI(zp), off);\n\treturn (error);\n}\n\nvoid\nzfs_create_fs(objset_t *os, cred_t *cr, nvlist_t *zplprops, dmu_tx_t *tx)\n{\n\tstruct super_block *sb;\n\tzfsvfs_t\t*zfsvfs;\n\tuint64_t\tmoid, obj, sa_obj, version;\n\tuint64_t\tsense = ZFS_CASE_SENSITIVE;\n\tuint64_t\tnorm = 0;\n\tnvpair_t\t*elem;\n\tint\t\tsize;\n\tint\t\terror;\n\tint\t\ti;\n\tznode_t\t\t*rootzp = NULL;\n\tvattr_t\t\tvattr;\n\tznode_t\t\t*zp;\n\tzfs_acl_ids_t\tacl_ids;\n\n\t \n\t \n\tmoid = MASTER_NODE_OBJ;\n\terror = zap_create_claim(os, moid, DMU_OT_MASTER_NODE,\n\t    DMU_OT_NONE, 0, tx);\n\tASSERT(error == 0);\n\n\t \n\tversion = zfs_zpl_version_map(spa_version(dmu_objset_spa(os)));\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(zplprops, elem)) != NULL) {\n\t\t \n\t\tuint64_t val;\n\t\tconst char *name;\n\n\t\tASSERT(nvpair_type(elem) == DATA_TYPE_UINT64);\n\t\tVERIFY(nvpair_value_uint64(elem, &val) == 0);\n\t\tname = nvpair_name(elem);\n\t\tif (strcmp(name, zfs_prop_to_name(ZFS_PROP_VERSION)) == 0) {\n\t\t\tif (val < version)\n\t\t\t\tversion = val;\n\t\t} else {\n\t\t\terror = zap_update(os, moid, name, 8, 1, &val, tx);\n\t\t}\n\t\tASSERT(error == 0);\n\t\tif (strcmp(name, zfs_prop_to_name(ZFS_PROP_NORMALIZE)) == 0)\n\t\t\tnorm = val;\n\t\telse if (strcmp(name, zfs_prop_to_name(ZFS_PROP_CASE)) == 0)\n\t\t\tsense = val;\n\t}\n\tASSERT(version != 0);\n\terror = zap_update(os, moid, ZPL_VERSION_STR, 8, 1, &version, tx);\n\tASSERT(error == 0);\n\n\t \n\n\tif (version >= ZPL_VERSION_SA) {\n\t\tsa_obj = zap_create(os, DMU_OT_SA_MASTER_NODE,\n\t\t    DMU_OT_NONE, 0, tx);\n\t\terror = zap_add(os, moid, ZFS_SA_ATTRS, 8, 1, &sa_obj, tx);\n\t\tASSERT(error == 0);\n\t} else {\n\t\tsa_obj = 0;\n\t}\n\t \n\tobj = zap_create(os, DMU_OT_UNLINKED_SET, DMU_OT_NONE, 0, tx);\n\n\terror = zap_add(os, moid, ZFS_UNLINKED_SET, 8, 1, &obj, tx);\n\tASSERT(error == 0);\n\n\t \n\tvattr.va_mask = ATTR_MODE|ATTR_UID|ATTR_GID;\n\tvattr.va_mode = S_IFDIR|0755;\n\tvattr.va_uid = crgetuid(cr);\n\tvattr.va_gid = crgetgid(cr);\n\n\trootzp = kmem_cache_alloc(znode_cache, KM_SLEEP);\n\trootzp->z_unlinked = B_FALSE;\n\trootzp->z_atime_dirty = B_FALSE;\n\trootzp->z_is_sa = USE_SA(version, os);\n\trootzp->z_pflags = 0;\n\n\tzfsvfs = kmem_zalloc(sizeof (zfsvfs_t), KM_SLEEP);\n\tzfsvfs->z_os = os;\n\tzfsvfs->z_parent = zfsvfs;\n\tzfsvfs->z_version = version;\n\tzfsvfs->z_use_fuids = USE_FUIDS(version, os);\n\tzfsvfs->z_use_sa = USE_SA(version, os);\n\tzfsvfs->z_norm = norm;\n\n\tsb = kmem_zalloc(sizeof (struct super_block), KM_SLEEP);\n\tsb->s_fs_info = zfsvfs;\n\n\tZTOI(rootzp)->i_sb = sb;\n\n\terror = sa_setup(os, sa_obj, zfs_attr_table, ZPL_END,\n\t    &zfsvfs->z_attr_table);\n\n\tASSERT(error == 0);\n\n\t \n\tif (sense == ZFS_CASE_INSENSITIVE || sense == ZFS_CASE_MIXED)\n\t\tzfsvfs->z_norm |= U8_TEXTPREP_TOUPPER;\n\n\tmutex_init(&zfsvfs->z_znodes_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&zfsvfs->z_all_znodes, sizeof (znode_t),\n\t    offsetof(znode_t, z_link_node));\n\n\tsize = MIN(1 << (highbit64(zfs_object_mutex_size)-1), ZFS_OBJ_MTX_MAX);\n\tzfsvfs->z_hold_size = size;\n\tzfsvfs->z_hold_trees = vmem_zalloc(sizeof (avl_tree_t) * size,\n\t    KM_SLEEP);\n\tzfsvfs->z_hold_locks = vmem_zalloc(sizeof (kmutex_t) * size, KM_SLEEP);\n\tfor (i = 0; i != size; i++) {\n\t\tavl_create(&zfsvfs->z_hold_trees[i], zfs_znode_hold_compare,\n\t\t    sizeof (znode_hold_t), offsetof(znode_hold_t, zh_node));\n\t\tmutex_init(&zfsvfs->z_hold_locks[i], NULL, MUTEX_DEFAULT, NULL);\n\t}\n\n\tVERIFY(0 == zfs_acl_ids_create(rootzp, IS_ROOT_NODE, &vattr,\n\t    cr, NULL, &acl_ids, zfs_init_idmap));\n\tzfs_mknode(rootzp, &vattr, tx, cr, IS_ROOT_NODE, &zp, &acl_ids);\n\tASSERT3P(zp, ==, rootzp);\n\terror = zap_add(os, moid, ZFS_ROOT_OBJ, 8, 1, &rootzp->z_id, tx);\n\tASSERT(error == 0);\n\tzfs_acl_ids_free(&acl_ids);\n\n\tatomic_set(&ZTOI(rootzp)->i_count, 0);\n\tsa_handle_destroy(rootzp->z_sa_hdl);\n\tkmem_cache_free(znode_cache, rootzp);\n\n\tfor (i = 0; i != size; i++) {\n\t\tavl_destroy(&zfsvfs->z_hold_trees[i]);\n\t\tmutex_destroy(&zfsvfs->z_hold_locks[i]);\n\t}\n\n\tmutex_destroy(&zfsvfs->z_znodes_lock);\n\n\tvmem_free(zfsvfs->z_hold_trees, sizeof (avl_tree_t) * size);\n\tvmem_free(zfsvfs->z_hold_locks, sizeof (kmutex_t) * size);\n\tkmem_free(sb, sizeof (struct super_block));\n\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n}\n#endif  \n\nstatic int\nzfs_sa_setup(objset_t *osp, sa_attr_type_t **sa_table)\n{\n\tuint64_t sa_obj = 0;\n\tint error;\n\n\terror = zap_lookup(osp, MASTER_NODE_OBJ, ZFS_SA_ATTRS, 8, 1, &sa_obj);\n\tif (error != 0 && error != ENOENT)\n\t\treturn (error);\n\n\terror = sa_setup(osp, sa_obj, zfs_attr_table, ZPL_END, sa_table);\n\treturn (error);\n}\n\nstatic int\nzfs_grab_sa_handle(objset_t *osp, uint64_t obj, sa_handle_t **hdlp,\n    dmu_buf_t **db, const void *tag)\n{\n\tdmu_object_info_t doi;\n\tint error;\n\n\tif ((error = sa_buf_hold(osp, obj, tag, db)) != 0)\n\t\treturn (error);\n\n\tdmu_object_info_from_db(*db, &doi);\n\tif ((doi.doi_bonus_type != DMU_OT_SA &&\n\t    doi.doi_bonus_type != DMU_OT_ZNODE) ||\n\t    (doi.doi_bonus_type == DMU_OT_ZNODE &&\n\t    doi.doi_bonus_size < sizeof (znode_phys_t))) {\n\t\tsa_buf_rele(*db, tag);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\terror = sa_handle_get(osp, obj, NULL, SA_HDL_PRIVATE, hdlp);\n\tif (error != 0) {\n\t\tsa_buf_rele(*db, tag);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzfs_release_sa_handle(sa_handle_t *hdl, dmu_buf_t *db, const void *tag)\n{\n\tsa_handle_destroy(hdl);\n\tsa_buf_rele(db, tag);\n}\n\n \nstatic int\nzfs_obj_to_pobj(objset_t *osp, sa_handle_t *hdl, sa_attr_type_t *sa_table,\n    uint64_t *pobjp, int *is_xattrdir)\n{\n\tuint64_t parent;\n\tuint64_t pflags;\n\tuint64_t mode;\n\tuint64_t parent_mode;\n\tsa_bulk_attr_t bulk[3];\n\tsa_handle_t *sa_hdl;\n\tdmu_buf_t *sa_db;\n\tint count = 0;\n\tint error;\n\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_PARENT], NULL,\n\t    &parent, sizeof (parent));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_FLAGS], NULL,\n\t    &pflags, sizeof (pflags));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_MODE], NULL,\n\t    &mode, sizeof (mode));\n\n\tif ((error = sa_bulk_lookup(hdl, bulk, count)) != 0)\n\t\treturn (error);\n\n\t \n\terror = zfs_grab_sa_handle(osp, parent, &sa_hdl, &sa_db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = sa_lookup(sa_hdl, ZPL_MODE, &parent_mode, sizeof (parent_mode));\n\tzfs_release_sa_handle(sa_hdl, sa_db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\t*is_xattrdir = ((pflags & ZFS_XATTR) != 0) && S_ISDIR(mode);\n\n\t \n\tif (!*is_xattrdir && !S_ISDIR(parent_mode))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t*pobjp = parent;\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_obj_to_stats_impl(sa_handle_t *hdl, sa_attr_type_t *sa_table,\n    zfs_stat_t *sb)\n{\n\tsa_bulk_attr_t bulk[4];\n\tint count = 0;\n\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_MODE], NULL,\n\t    &sb->zs_mode, sizeof (sb->zs_mode));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_GEN], NULL,\n\t    &sb->zs_gen, sizeof (sb->zs_gen));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_LINKS], NULL,\n\t    &sb->zs_links, sizeof (sb->zs_links));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_CTIME], NULL,\n\t    &sb->zs_ctime, sizeof (sb->zs_ctime));\n\n\treturn (sa_bulk_lookup(hdl, bulk, count));\n}\n\nstatic int\nzfs_obj_to_path_impl(objset_t *osp, uint64_t obj, sa_handle_t *hdl,\n    sa_attr_type_t *sa_table, char *buf, int len)\n{\n\tsa_handle_t *sa_hdl;\n\tsa_handle_t *prevhdl = NULL;\n\tdmu_buf_t *prevdb = NULL;\n\tdmu_buf_t *sa_db = NULL;\n\tchar *path = buf + len - 1;\n\tint error;\n\n\t*path = '\\0';\n\tsa_hdl = hdl;\n\n\tuint64_t deleteq_obj;\n\tVERIFY0(zap_lookup(osp, MASTER_NODE_OBJ,\n\t    ZFS_UNLINKED_SET, sizeof (uint64_t), 1, &deleteq_obj));\n\terror = zap_lookup_int(osp, deleteq_obj, obj);\n\tif (error == 0) {\n\t\treturn (ESTALE);\n\t} else if (error != ENOENT) {\n\t\treturn (error);\n\t}\n\n\tfor (;;) {\n\t\tuint64_t pobj = 0;\n\t\tchar component[MAXNAMELEN + 2];\n\t\tsize_t complen;\n\t\tint is_xattrdir = 0;\n\n\t\tif (prevdb) {\n\t\t\tASSERT(prevhdl != NULL);\n\t\t\tzfs_release_sa_handle(prevhdl, prevdb, FTAG);\n\t\t}\n\n\t\tif ((error = zfs_obj_to_pobj(osp, sa_hdl, sa_table, &pobj,\n\t\t    &is_xattrdir)) != 0)\n\t\t\tbreak;\n\n\t\tif (pobj == obj) {\n\t\t\tif (path[0] != '/')\n\t\t\t\t*--path = '/';\n\t\t\tbreak;\n\t\t}\n\n\t\tcomponent[0] = '/';\n\t\tif (is_xattrdir) {\n\t\t\tstrcpy(component + 1, \"<xattrdir>\");\n\t\t} else {\n\t\t\terror = zap_value_search(osp, pobj, obj,\n\t\t\t    ZFS_DIRENT_OBJ(-1ULL), component + 1);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcomplen = strlen(component);\n\t\tpath -= complen;\n\t\tASSERT(path >= buf);\n\t\tmemcpy(path, component, complen);\n\t\tobj = pobj;\n\n\t\tif (sa_hdl != hdl) {\n\t\t\tprevhdl = sa_hdl;\n\t\t\tprevdb = sa_db;\n\t\t}\n\t\terror = zfs_grab_sa_handle(osp, obj, &sa_hdl, &sa_db, FTAG);\n\t\tif (error != 0) {\n\t\t\tsa_hdl = prevhdl;\n\t\t\tsa_db = prevdb;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sa_hdl != NULL && sa_hdl != hdl) {\n\t\tASSERT(sa_db != NULL);\n\t\tzfs_release_sa_handle(sa_hdl, sa_db, FTAG);\n\t}\n\n\tif (error == 0)\n\t\t(void) memmove(buf, path, buf + len - path);\n\n\treturn (error);\n}\n\nint\nzfs_obj_to_path(objset_t *osp, uint64_t obj, char *buf, int len)\n{\n\tsa_attr_type_t *sa_table;\n\tsa_handle_t *hdl;\n\tdmu_buf_t *db;\n\tint error;\n\n\terror = zfs_sa_setup(osp, &sa_table);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_grab_sa_handle(osp, obj, &hdl, &db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_obj_to_path_impl(osp, obj, hdl, sa_table, buf, len);\n\n\tzfs_release_sa_handle(hdl, db, FTAG);\n\treturn (error);\n}\n\nint\nzfs_obj_to_stats(objset_t *osp, uint64_t obj, zfs_stat_t *sb,\n    char *buf, int len)\n{\n\tchar *path = buf + len - 1;\n\tsa_attr_type_t *sa_table;\n\tsa_handle_t *hdl;\n\tdmu_buf_t *db;\n\tint error;\n\n\t*path = '\\0';\n\n\terror = zfs_sa_setup(osp, &sa_table);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_grab_sa_handle(osp, obj, &hdl, &db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_obj_to_stats_impl(hdl, sa_table, sb);\n\tif (error != 0) {\n\t\tzfs_release_sa_handle(hdl, db, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = zfs_obj_to_path_impl(osp, obj, hdl, sa_table, buf, len);\n\n\tzfs_release_sa_handle(hdl, db, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_get_zplprop(objset_t *os, zfs_prop_t prop, uint64_t *value)\n{\n\tuint64_t *cached_copy = NULL;\n\n\t \n\tif (os != NULL) {\n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_VERSION:\n\t\t\tcached_copy = &os->os_version;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_NORMALIZE:\n\t\t\tcached_copy = &os->os_normalization;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_UTF8ONLY:\n\t\t\tcached_copy = &os->os_utf8only;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_CASE:\n\t\t\tcached_copy = &os->os_casesensitivity;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cached_copy != NULL && *cached_copy != OBJSET_PROP_UNINITIALIZED) {\n\t\t*value = *cached_copy;\n\t\treturn (0);\n\t}\n\n\t \n\tconst char *pname;\n\tint error = ENOENT;\n\tif (prop == ZFS_PROP_VERSION)\n\t\tpname = ZPL_VERSION_STR;\n\telse\n\t\tpname = zfs_prop_to_name(prop);\n\n\tif (os != NULL) {\n\t\tASSERT3U(os->os_phys->os_type, ==, DMU_OST_ZFS);\n\t\terror = zap_lookup(os, MASTER_NODE_OBJ, pname, 8, 1, value);\n\t}\n\n\tif (error == ENOENT) {\n\t\t \n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_VERSION:\n\t\t\t*value = ZPL_VERSION;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_NORMALIZE:\n\t\tcase ZFS_PROP_UTF8ONLY:\n\t\t\t*value = 0;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_CASE:\n\t\t\t*value = ZFS_CASE_SENSITIVE;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_ACLTYPE:\n\t\t\t*value = ZFS_ACLTYPE_OFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (error);\n\t\t}\n\t\terror = 0;\n\t}\n\n\t \n\tif (error == 0 && cached_copy != NULL) {\n\t\t*cached_copy = *value;\n\t}\n\n\treturn (error);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zfs_create_fs);\nEXPORT_SYMBOL(zfs_obj_to_path);\n\n \nmodule_param(zfs_object_mutex_size, uint, 0644);\nMODULE_PARM_DESC(zfs_object_mutex_size, \"Size of znode hold array\");\nmodule_param(zfs_unlink_suspend_progress, int, 0644);\nMODULE_PARM_DESC(zfs_unlink_suspend_progress, \"Set to prevent async unlinks \"\n\"(debug - leaks space into the unlinked set)\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}