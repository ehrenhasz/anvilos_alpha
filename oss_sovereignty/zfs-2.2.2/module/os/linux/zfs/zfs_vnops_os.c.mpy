{
  "module_name": "zfs_vnops_os.c",
  "hash_id": "c71f2a7b8cb0da811802a5fc4ae28965d095b00ed772fce6d14456196c928a4b",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_vnops_os.c",
  "human_readable_source": " \n\n \n\n \n \n\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/sysmacros.h>\n#include <sys/vfs.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/kmem.h>\n#include <sys/taskq.h>\n#include <sys/uio.h>\n#include <sys/vmsystm.h>\n#include <sys/atomic.h>\n#include <sys/pathname.h>\n#include <sys/cmn_err.h>\n#include <sys/errno.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/fs/zfs.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/spa.h>\n#include <sys/txg.h>\n#include <sys/dbuf.h>\n#include <sys/zap.h>\n#include <sys/sa.h>\n#include <sys/policy.h>\n#include <sys/sunddi.h>\n#include <sys/sid.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_fuid.h>\n#include <sys/zfs_quota.h>\n#include <sys/zfs_sa.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_rlock.h>\n#include <sys/cred.h>\n#include <sys/zpl.h>\n#include <sys/zil.h>\n#include <sys/sa_impl.h>\n\n \nint\nzfs_open(struct inode *ip, int mode, int flag, cred_t *cr)\n{\n\t(void) cr;\n\tznode_t\t*zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\t \n\tif (blk_mode_is_open_write(mode) && (zp->z_pflags & ZFS_APPENDONLY) &&\n\t    ((flag & O_APPEND) == 0)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\tif (flag & O_SYNC)\n\t\tatomic_inc_32(&zp->z_sync_cnt);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nint\nzfs_close(struct inode *ip, int flag, cred_t *cr)\n{\n\t(void) cr;\n\tznode_t\t*zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\t \n\tif (flag & O_SYNC)\n\t\tatomic_dec_32(&zp->z_sync_cnt);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n#if defined(_KERNEL)\n\nstatic int zfs_fillpage(struct inode *ip, struct page *pp);\n\n \nvoid\nupdate_pages(znode_t *zp, int64_t start, int len, objset_t *os)\n{\n\tstruct address_space *mp = ZTOI(zp)->i_mapping;\n\tint64_t off = start & (PAGE_SIZE - 1);\n\n\tfor (start &= PAGE_MASK; len > 0; start += PAGE_SIZE) {\n\t\tuint64_t nbytes = MIN(PAGE_SIZE - off, len);\n\n\t\tstruct page *pp = find_lock_page(mp, start >> PAGE_SHIFT);\n\t\tif (pp) {\n\t\t\tif (mapping_writably_mapped(mp))\n\t\t\t\tflush_dcache_page(pp);\n\n\t\t\tvoid *pb = kmap(pp);\n\t\t\tint error = dmu_read(os, zp->z_id, start + off,\n\t\t\t    nbytes, pb + off, DMU_READ_PREFETCH);\n\t\t\tkunmap(pp);\n\n\t\t\tif (error) {\n\t\t\t\tSetPageError(pp);\n\t\t\t\tClearPageUptodate(pp);\n\t\t\t} else {\n\t\t\t\tClearPageError(pp);\n\t\t\t\tSetPageUptodate(pp);\n\n\t\t\t\tif (mapping_writably_mapped(mp))\n\t\t\t\t\tflush_dcache_page(pp);\n\n\t\t\t\tmark_page_accessed(pp);\n\t\t\t}\n\n\t\t\tunlock_page(pp);\n\t\t\tput_page(pp);\n\t\t}\n\n\t\tlen -= nbytes;\n\t\toff = 0;\n\t}\n}\n\n \nint\nmappedread(znode_t *zp, int nbytes, zfs_uio_t *uio)\n{\n\tstruct inode *ip = ZTOI(zp);\n\tstruct address_space *mp = ip->i_mapping;\n\tint64_t start = uio->uio_loffset;\n\tint64_t off = start & (PAGE_SIZE - 1);\n\tint len = nbytes;\n\tint error = 0;\n\n\tfor (start &= PAGE_MASK; len > 0; start += PAGE_SIZE) {\n\t\tuint64_t bytes = MIN(PAGE_SIZE - off, len);\n\n\t\tstruct page *pp = find_lock_page(mp, start >> PAGE_SHIFT);\n\t\tif (pp) {\n\t\t\t \n\t\t\tif (unlikely(!PageUptodate(pp))) {\n\t\t\t\terror = zfs_fillpage(ip, pp);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_page(pp);\n\t\t\t\t\tput_page(pp);\n\t\t\t\t\treturn (error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tASSERT(PageUptodate(pp) || PageDirty(pp));\n\n\t\t\tunlock_page(pp);\n\n\t\t\tvoid *pb = kmap(pp);\n\t\t\terror = zfs_uiomove(pb + off, bytes, UIO_READ, uio);\n\t\t\tkunmap(pp);\n\n\t\t\tif (mapping_writably_mapped(mp))\n\t\t\t\tflush_dcache_page(pp);\n\n\t\t\tmark_page_accessed(pp);\n\t\t\tput_page(pp);\n\t\t} else {\n\t\t\terror = dmu_read_uio_dbuf(sa_get_db(zp->z_sa_hdl),\n\t\t\t    uio, bytes);\n\t\t}\n\n\t\tlen -= bytes;\n\t\toff = 0;\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn (error);\n}\n#endif  \n\nstatic unsigned long zfs_delete_blocks = DMU_MAX_DELETEBLKCNT;\n\n \nint\nzfs_write_simple(znode_t *zp, const void *data, size_t len,\n    loff_t pos, size_t *residp)\n{\n\tfstrans_cookie_t cookie;\n\tint error;\n\n\tstruct iovec iov;\n\tiov.iov_base = (void *)data;\n\tiov.iov_len = len;\n\n\tzfs_uio_t uio;\n\tzfs_uio_iovec_init(&uio, &iov, 1, pos, UIO_SYSSPACE, len, 0);\n\n\tcookie = spl_fstrans_mark();\n\terror = zfs_write(zp, &uio, 0, kcred);\n\tspl_fstrans_unmark(cookie);\n\n\tif (error == 0) {\n\t\tif (residp != NULL)\n\t\t\t*residp = zfs_uio_resid(&uio);\n\t\telse if (zfs_uio_resid(&uio) != 0)\n\t\t\terror = SET_ERROR(EIO);\n\t}\n\n\treturn (error);\n}\n\nstatic void\nzfs_rele_async_task(void *arg)\n{\n\tiput(arg);\n}\n\nvoid\nzfs_zrele_async(znode_t *zp)\n{\n\tstruct inode *ip = ZTOI(zp);\n\tobjset_t *os = ITOZSB(ip)->z_os;\n\n\tASSERT(atomic_read(&ip->i_count) > 0);\n\tASSERT(os != NULL);\n\n\t \n\tif (!atomic_add_unless(&ip->i_count, -1, 1)) {\n\t\tVERIFY(taskq_dispatch(dsl_pool_zrele_taskq(dmu_objset_pool(os)),\n\t\t    zfs_rele_async_task, ip, TQ_SLEEP) != TASKQID_INVALID);\n\t}\n}\n\n\n \nint\nzfs_lookup(znode_t *zdp, char *nm, znode_t **zpp, int flags, cred_t *cr,\n    int *direntflags, pathname_t *realpnp)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zdp);\n\tint error = 0;\n\n\t \n\tif (!(flags & (LOOKUP_XATTR | FIGNORECASE))) {\n\n\t\tif (!S_ISDIR(ZTOI(zdp)->i_mode)) {\n\t\t\treturn (SET_ERROR(ENOTDIR));\n\t\t} else if (zdp->z_sa_hdl == NULL) {\n\t\t\treturn (SET_ERROR(EIO));\n\t\t}\n\n\t\tif (nm[0] == 0 || (nm[0] == '.' && nm[1] == '\\0')) {\n\t\t\terror = zfs_fastaccesschk_execute(zdp, cr);\n\t\t\tif (!error) {\n\t\t\t\t*zpp = zdp;\n\t\t\t\tzhold(*zpp);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zdp, FTAG)) != 0)\n\t\treturn (error);\n\n\t*zpp = NULL;\n\n\tif (flags & LOOKUP_XATTR) {\n\t\t \n\t\tif (zdp->z_pflags & ZFS_XATTR) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tif ((error = zfs_get_xattrdir(zdp, zpp, cr, flags))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\t \n\n\t\tif ((error = zfs_zaccess(*zpp, ACE_EXECUTE, 0,\n\t\t    B_TRUE, cr, zfs_init_idmap))) {\n\t\t\tzrele(*zpp);\n\t\t\t*zpp = NULL;\n\t\t}\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (!S_ISDIR(ZTOI(zdp)->i_mode)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENOTDIR));\n\t}\n\n\t \n\n\tif ((error = zfs_zaccess(zdp, ACE_EXECUTE, 0, B_FALSE, cr,\n\t    zfs_init_idmap))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(nm, strlen(nm),\n\t    NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\terror = zfs_dirlook(zdp, nm, zpp, flags, direntflags, realpnp);\n\tif ((error == 0) && (*zpp))\n\t\tzfs_znode_update_vfs(*zpp);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_create(znode_t *dzp, char *name, vattr_t *vap, int excl,\n    int mode, znode_t **zpp, cred_t *cr, int flag, vsecattr_t *vsecp,\n    zidmap_t *mnt_ns)\n{\n\tznode_t\t\t*zp;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzilog_t\t\t*zilog;\n\tobjset_t\t*os;\n\tzfs_dirlock_t\t*dl;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tuid_t\t\tuid;\n\tgid_t\t\tgid;\n\tzfs_acl_ids_t   acl_ids;\n\tboolean_t\tfuid_dirtied;\n\tboolean_t\thave_acl = B_FALSE;\n\tboolean_t\twaited = B_FALSE;\n\tboolean_t\tskip_acl = (flag & ATTR_NOACLCHECK) ? B_TRUE : B_FALSE;\n\n\t \n\n\tgid = crgetgid(cr);\n\tuid = crgetuid(cr);\n\n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    (vsecp || IS_EPHEMERAL(uid) || IS_EPHEMERAL(gid)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (name == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tos = zfsvfs->z_os;\n\tzilog = zfsvfs->z_log;\n\n\tif (zfsvfs->z_utf8 && u8_validate(name, strlen(name),\n\t    NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\tif (vap->va_mask & ATTR_XVATTR) {\n\t\tif ((error = secpolicy_xvattr((xvattr_t *)vap,\n\t\t    crgetuid(cr), cr, vap->va_mode)) != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\ntop:\n\t*zpp = NULL;\n\tif (*name == '\\0') {\n\t\t \n\t\tzhold(dzp);\n\t\tzp = dzp;\n\t\tdl = NULL;\n\t\terror = 0;\n\t} else {\n\t\t \n\t\tint zflg = 0;\n\n\t\tif (flag & FIGNORECASE)\n\t\t\tzflg |= ZCILOOK;\n\n\t\terror = zfs_dirent_lock(&dl, dzp, name, &zp, zflg,\n\t\t    NULL, NULL);\n\t\tif (error) {\n\t\t\tif (have_acl)\n\t\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\t\tif (strcmp(name, \"..\") == 0)\n\t\t\t\terror = SET_ERROR(EISDIR);\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (zp == NULL) {\n\t\tuint64_t txtype;\n\t\tuint64_t projid = ZFS_DEFAULT_PROJID;\n\n\t\t \n\t\tif ((error = zfs_zaccess(dzp, ACE_ADD_FILE, 0, skip_acl, cr,\n\t\t    mnt_ns))) {\n\t\t\tif (have_acl)\n\t\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\n\t\tif ((dzp->z_pflags & ZFS_XATTR) && !S_ISREG(vap->va_mode)) {\n\t\t\tif (have_acl)\n\t\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!have_acl && (error = zfs_acl_ids_create(dzp, 0, vap,\n\t\t    cr, vsecp, &acl_ids, mnt_ns)) != 0)\n\t\t\tgoto out;\n\t\thave_acl = B_TRUE;\n\n\t\tif (S_ISREG(vap->va_mode) || S_ISDIR(vap->va_mode))\n\t\t\tprojid = zfs_inherit_projid(dzp);\n\t\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, projid)) {\n\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\t\terror = SET_ERROR(EDQUOT);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx = dmu_tx_create(os);\n\n\t\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t\t    ZFS_SA_BASE_ATTR_SIZE);\n\n\t\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\t\tif (fuid_dirtied)\n\t\t\tzfs_fuid_txhold(zfsvfs, tx);\n\t\tdmu_tx_hold_zap(tx, dzp->z_id, TRUE, name);\n\t\tdmu_tx_hold_sa(tx, dzp->z_sa_hdl, B_FALSE);\n\t\tif (!zfsvfs->z_use_sa &&\n\t\t    acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t\t    0, acl_ids.z_aclp->z_acl_bytes);\n\t\t}\n\n\t\terror = dmu_tx_assign(tx,\n\t\t    (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\t\tif (error) {\n\t\t\tzfs_dirent_unlock(dl);\n\t\t\tif (error == ERESTART) {\n\t\t\t\twaited = B_TRUE;\n\t\t\t\tdmu_tx_wait(tx);\n\t\t\t\tdmu_tx_abort(tx);\n\t\t\t\tgoto top;\n\t\t\t}\n\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\tzfs_mknode(dzp, vap, tx, cr, 0, &zp, &acl_ids);\n\n\t\terror = zfs_link_create(dl, zp, tx, ZNEW);\n\t\tif (error != 0) {\n\t\t\t \n\t\t\tzfs_znode_delete(zp, tx);\n\t\t\tremove_inode_hash(ZTOI(zp));\n\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\t\tdmu_tx_commit(tx);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fuid_dirtied)\n\t\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\t\ttxtype = zfs_log_create_txtype(Z_FILE, vsecp, vap);\n\t\tif (flag & FIGNORECASE)\n\t\t\ttxtype |= TX_CI;\n\t\tzfs_log_create(zilog, tx, txtype, dzp, zp, name,\n\t\t    vsecp, acl_ids.z_fuidp, vap);\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_commit(tx);\n\t} else {\n\t\tint aflags = (flag & O_APPEND) ? V_APPEND : 0;\n\n\t\tif (have_acl)\n\t\t\tzfs_acl_ids_free(&acl_ids);\n\n\t\t \n\t\t \n\t\tif (excl) {\n\t\t\terror = SET_ERROR(EEXIST);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (S_ISDIR(ZTOI(zp)->i_mode)) {\n\t\t\terror = SET_ERROR(EISDIR);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (mode && (error = zfs_zaccess_rwx(zp, mode, aflags, cr,\n\t\t    mnt_ns))) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_enter(&dzp->z_lock);\n\t\tdzp->z_seq++;\n\t\tmutex_exit(&dzp->z_lock);\n\n\t\t \n\t\tif (S_ISREG(ZTOI(zp)->i_mode) &&\n\t\t    (vap->va_mask & ATTR_SIZE) && (vap->va_size == 0)) {\n\t\t\t \n\t\t\tif (dl) {\n\t\t\t\tzfs_dirent_unlock(dl);\n\t\t\t\tdl = NULL;\n\t\t\t}\n\t\t\terror = zfs_freesp(zp, 0, 0, mode, TRUE);\n\t\t}\n\t}\nout:\n\n\tif (dl)\n\t\tzfs_dirent_unlock(dl);\n\n\tif (error) {\n\t\tif (zp)\n\t\t\tzrele(zp);\n\t} else {\n\t\tzfs_znode_update_vfs(dzp);\n\t\tzfs_znode_update_vfs(zp);\n\t\t*zpp = zp;\n\t}\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nint\nzfs_tmpfile(struct inode *dip, vattr_t *vap, int excl,\n    int mode, struct inode **ipp, cred_t *cr, int flag, vsecattr_t *vsecp,\n    zidmap_t *mnt_ns)\n{\n\t(void) excl, (void) mode, (void) flag;\n\tznode_t\t\t*zp = NULL, *dzp = ITOZ(dip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(dip);\n\tobjset_t\t*os;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tuid_t\t\tuid;\n\tgid_t\t\tgid;\n\tzfs_acl_ids_t   acl_ids;\n\tuint64_t\tprojid = ZFS_DEFAULT_PROJID;\n\tboolean_t\tfuid_dirtied;\n\tboolean_t\thave_acl = B_FALSE;\n\tboolean_t\twaited = B_FALSE;\n\n\t \n\n\tgid = crgetgid(cr);\n\tuid = crgetuid(cr);\n\n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    (vsecp || IS_EPHEMERAL(uid) || IS_EPHEMERAL(gid)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tos = zfsvfs->z_os;\n\n\tif (vap->va_mask & ATTR_XVATTR) {\n\t\tif ((error = secpolicy_xvattr((xvattr_t *)vap,\n\t\t    crgetuid(cr), cr, vap->va_mode)) != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\ntop:\n\t*ipp = NULL;\n\n\t \n\tif ((error = zfs_zaccess(dzp, ACE_ADD_FILE, 0, B_FALSE, cr, mnt_ns))) {\n\t\tif (have_acl)\n\t\t\tzfs_acl_ids_free(&acl_ids);\n\t\tgoto out;\n\t}\n\n\tif (!have_acl && (error = zfs_acl_ids_create(dzp, 0, vap,\n\t    cr, vsecp, &acl_ids, mnt_ns)) != 0)\n\t\tgoto out;\n\thave_acl = B_TRUE;\n\n\tif (S_ISREG(vap->va_mode) || S_ISDIR(vap->va_mode))\n\t\tprojid = zfs_inherit_projid(dzp);\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, projid)) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\terror = SET_ERROR(EDQUOT);\n\t\tgoto out;\n\t}\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\tif (!zfsvfs->z_use_sa &&\n\t    acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t    0, acl_ids.z_aclp->z_acl_bytes);\n\t}\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tgoto top;\n\t\t}\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tzfs_mknode(dzp, vap, tx, cr, IS_TMPFILE, &zp, &acl_ids);\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\t \n\tzp->z_unlinked = B_TRUE;\n\tzfs_unlinked_add(zp, tx);\n\tzfs_acl_ids_free(&acl_ids);\n\tdmu_tx_commit(tx);\nout:\n\n\tif (error) {\n\t\tif (zp)\n\t\t\tzrele(zp);\n\t} else {\n\t\tzfs_znode_update_vfs(dzp);\n\t\tzfs_znode_update_vfs(zp);\n\t\t*ipp = ZTOI(zp);\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \n\nstatic uint64_t null_xattr = 0;\n\nint\nzfs_remove(znode_t *dzp, char *name, cred_t *cr, int flags)\n{\n\tznode_t\t\t*zp;\n\tznode_t\t\t*xzp;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzilog_t\t\t*zilog;\n\tuint64_t\tacl_obj, xattr_obj;\n\tuint64_t\txattr_obj_unlinked = 0;\n\tuint64_t\tobj = 0;\n\tuint64_t\tlinks;\n\tzfs_dirlock_t\t*dl;\n\tdmu_tx_t\t*tx;\n\tboolean_t\tmay_delete_now, delete_now = FALSE;\n\tboolean_t\tunlinked, toobig = FALSE;\n\tuint64_t\ttxtype;\n\tpathname_t\t*realnmp = NULL;\n\tpathname_t\trealnm;\n\tint\t\terror;\n\tint\t\tzflg = ZEXISTS;\n\tboolean_t\twaited = B_FALSE;\n\n\tif (name == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif (flags & FIGNORECASE) {\n\t\tzflg |= ZCILOOK;\n\t\tpn_alloc(&realnm);\n\t\trealnmp = &realnm;\n\t}\n\ntop:\n\txattr_obj = 0;\n\txzp = NULL;\n\t \n\tif ((error = zfs_dirent_lock(&dl, dzp, name, &zp, zflg,\n\t    NULL, realnmp))) {\n\t\tif (realnmp)\n\t\t\tpn_free(realnmp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif ((error = zfs_zaccess_delete(dzp, zp, cr, zfs_init_idmap))) {\n\t\tgoto out;\n\t}\n\n\t \n\tif (S_ISDIR(ZTOI(zp)->i_mode)) {\n\t\terror = SET_ERROR(EPERM);\n\t\tgoto out;\n\t}\n\n\tmutex_enter(&zp->z_lock);\n\tmay_delete_now = atomic_read(&ZTOI(zp)->i_count) == 1 &&\n\t    !zn_has_cached_data(zp, 0, LLONG_MAX);\n\tmutex_exit(&zp->z_lock);\n\n\t \n\tobj = zp->z_id;\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, dzp->z_id, FALSE, name);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tzfs_sa_upgrade_txholds(tx, dzp);\n\tif (may_delete_now) {\n\t\ttoobig = zp->z_size > zp->z_blksz * zfs_delete_blocks;\n\t\t \n\t\tdmu_tx_hold_free(tx, zp->z_id, 0,\n\t\t    (toobig ? DMU_MAX_ACCESS : DMU_OBJECT_END));\n\t}\n\n\t \n\terror = sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t    &xattr_obj, sizeof (xattr_obj));\n\tif (error == 0 && xattr_obj) {\n\t\terror = zfs_zget(zfsvfs, xattr_obj, &xzp);\n\t\tASSERT0(error);\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t\tdmu_tx_hold_sa(tx, xzp->z_sa_hdl, B_FALSE);\n\t}\n\n\tmutex_enter(&zp->z_lock);\n\tif ((acl_obj = zfs_external_acl(zp)) != 0 && may_delete_now)\n\t\tdmu_tx_hold_free(tx, acl_obj, 0, DMU_OBJECT_END);\n\tmutex_exit(&zp->z_lock);\n\n\t \n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\n\t \n\tdmu_tx_mark_netfree(tx);\n\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\tzfs_dirent_unlock(dl);\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tzrele(zp);\n\t\t\tif (xzp)\n\t\t\t\tzrele(xzp);\n\t\t\tgoto top;\n\t\t}\n\t\tif (realnmp)\n\t\t\tpn_free(realnmp);\n\t\tdmu_tx_abort(tx);\n\t\tzrele(zp);\n\t\tif (xzp)\n\t\t\tzrele(xzp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = zfs_link_destroy(dl, zp, tx, zflg, &unlinked);\n\n\tif (error) {\n\t\tdmu_tx_commit(tx);\n\t\tgoto out;\n\t}\n\n\tif (unlinked) {\n\t\t \n\t\tmutex_enter(&zp->z_lock);\n\t\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t\t    &xattr_obj_unlinked, sizeof (xattr_obj_unlinked));\n\t\tdelete_now = may_delete_now && !toobig &&\n\t\t    atomic_read(&ZTOI(zp)->i_count) == 1 &&\n\t\t    !zn_has_cached_data(zp, 0, LLONG_MAX) &&\n\t\t    xattr_obj == xattr_obj_unlinked &&\n\t\t    zfs_external_acl(zp) == acl_obj;\n\t\tVERIFY_IMPLY(xattr_obj_unlinked, xzp);\n\t}\n\n\tif (delete_now) {\n\t\tif (xattr_obj_unlinked) {\n\t\t\tASSERT3U(ZTOI(xzp)->i_nlink, ==, 2);\n\t\t\tmutex_enter(&xzp->z_lock);\n\t\t\txzp->z_unlinked = B_TRUE;\n\t\t\tclear_nlink(ZTOI(xzp));\n\t\t\tlinks = 0;\n\t\t\terror = sa_update(xzp->z_sa_hdl, SA_ZPL_LINKS(zfsvfs),\n\t\t\t    &links, sizeof (links), tx);\n\t\t\tASSERT3U(error,  ==,  0);\n\t\t\tmutex_exit(&xzp->z_lock);\n\t\t\tzfs_unlinked_add(xzp, tx);\n\n\t\t\tif (zp->z_is_sa)\n\t\t\t\terror = sa_remove(zp->z_sa_hdl,\n\t\t\t\t    SA_ZPL_XATTR(zfsvfs), tx);\n\t\t\telse\n\t\t\t\terror = sa_update(zp->z_sa_hdl,\n\t\t\t\t    SA_ZPL_XATTR(zfsvfs), &null_xattr,\n\t\t\t\t    sizeof (uint64_t), tx);\n\t\t\tASSERT0(error);\n\t\t}\n\t\t \n\t\tzfs_unlinked_add(zp, tx);\n\t\tmutex_exit(&zp->z_lock);\n\t} else if (unlinked) {\n\t\tmutex_exit(&zp->z_lock);\n\t\tzfs_unlinked_add(zp, tx);\n\t}\n\n\ttxtype = TX_REMOVE;\n\tif (flags & FIGNORECASE)\n\t\ttxtype |= TX_CI;\n\tzfs_log_remove(zilog, tx, txtype, dzp, name, obj, unlinked);\n\n\tdmu_tx_commit(tx);\nout:\n\tif (realnmp)\n\t\tpn_free(realnmp);\n\n\tzfs_dirent_unlock(dl);\n\tzfs_znode_update_vfs(dzp);\n\tzfs_znode_update_vfs(zp);\n\n\tif (delete_now)\n\t\tzrele(zp);\n\telse\n\t\tzfs_zrele_async(zp);\n\n\tif (xzp) {\n\t\tzfs_znode_update_vfs(xzp);\n\t\tzfs_zrele_async(xzp);\n\t}\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_mkdir(znode_t *dzp, char *dirname, vattr_t *vap, znode_t **zpp,\n    cred_t *cr, int flags, vsecattr_t *vsecp, zidmap_t *mnt_ns)\n{\n\tznode_t\t\t*zp;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzilog_t\t\t*zilog;\n\tzfs_dirlock_t\t*dl;\n\tuint64_t\ttxtype;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tint\t\tzf = ZNEW;\n\tuid_t\t\tuid;\n\tgid_t\t\tgid = crgetgid(cr);\n\tzfs_acl_ids_t   acl_ids;\n\tboolean_t\tfuid_dirtied;\n\tboolean_t\twaited = B_FALSE;\n\n\tASSERT(S_ISDIR(vap->va_mode));\n\n\t \n\n\tuid = crgetuid(cr);\n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    (vsecp || IS_EPHEMERAL(uid) || IS_EPHEMERAL(gid)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (dirname == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif (dzp->z_pflags & ZFS_XATTR) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(dirname,\n\t    strlen(dirname), NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\tif (flags & FIGNORECASE)\n\t\tzf |= ZCILOOK;\n\n\tif (vap->va_mask & ATTR_XVATTR) {\n\t\tif ((error = secpolicy_xvattr((xvattr_t *)vap,\n\t\t    crgetuid(cr), cr, vap->va_mode)) != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif ((error = zfs_acl_ids_create(dzp, 0, vap, cr,\n\t    vsecp, &acl_ids, mnt_ns)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\t \ntop:\n\t*zpp = NULL;\n\n\tif ((error = zfs_dirent_lock(&dl, dzp, dirname, &zp, zf,\n\t    NULL, NULL))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif ((error = zfs_zaccess(dzp, ACE_ADD_SUBDIRECTORY, 0, B_FALSE, cr,\n\t    mnt_ns))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_dirent_unlock(dl);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, zfs_inherit_projid(dzp))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_dirent_unlock(dl);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\t \n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, dzp->z_id, TRUE, dirname);\n\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, FALSE, NULL);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\tif (!zfsvfs->z_use_sa && acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,\n\t\t    acl_ids.z_aclp->z_acl_bytes);\n\t}\n\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE);\n\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\tzfs_dirent_unlock(dl);\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tgoto top;\n\t\t}\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tzfs_mknode(dzp, vap, tx, cr, 0, &zp, &acl_ids);\n\n\t \n\terror = zfs_link_create(dl, zp, tx, ZNEW);\n\tif (error != 0) {\n\t\tzfs_znode_delete(zp, tx);\n\t\tremove_inode_hash(ZTOI(zp));\n\t\tgoto out;\n\t}\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\t*zpp = zp;\n\n\ttxtype = zfs_log_create_txtype(Z_DIR, vsecp, vap);\n\tif (flags & FIGNORECASE)\n\t\ttxtype |= TX_CI;\n\tzfs_log_create(zilog, tx, txtype, dzp, zp, dirname, vsecp,\n\t    acl_ids.z_fuidp, vap);\n\nout:\n\tzfs_acl_ids_free(&acl_ids);\n\n\tdmu_tx_commit(tx);\n\n\tzfs_dirent_unlock(dl);\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tif (error != 0) {\n\t\tzrele(zp);\n\t} else {\n\t\tzfs_znode_update_vfs(dzp);\n\t\tzfs_znode_update_vfs(zp);\n\t}\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_rmdir(znode_t *dzp, char *name, znode_t *cwd, cred_t *cr,\n    int flags)\n{\n\tznode_t\t\t*zp;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzilog_t\t\t*zilog;\n\tzfs_dirlock_t\t*dl;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tint\t\tzflg = ZEXISTS;\n\tboolean_t\twaited = B_FALSE;\n\n\tif (name == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif (flags & FIGNORECASE)\n\t\tzflg |= ZCILOOK;\ntop:\n\tzp = NULL;\n\n\t \n\tif ((error = zfs_dirent_lock(&dl, dzp, name, &zp, zflg,\n\t    NULL, NULL))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif ((error = zfs_zaccess_delete(dzp, zp, cr, zfs_init_idmap))) {\n\t\tgoto out;\n\t}\n\n\tif (!S_ISDIR(ZTOI(zp)->i_mode)) {\n\t\terror = SET_ERROR(ENOTDIR);\n\t\tgoto out;\n\t}\n\n\tif (zp == cwd) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\n\t \n\trw_enter(&zp->z_name_lock, RW_WRITER);\n\n\t \n\trw_enter(&zp->z_parent_lock, RW_WRITER);\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, dzp->z_id, FALSE, name);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tzfs_sa_upgrade_txholds(tx, dzp);\n\tdmu_tx_mark_netfree(tx);\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\trw_exit(&zp->z_parent_lock);\n\t\trw_exit(&zp->z_name_lock);\n\t\tzfs_dirent_unlock(dl);\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tzrele(zp);\n\t\t\tgoto top;\n\t\t}\n\t\tdmu_tx_abort(tx);\n\t\tzrele(zp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = zfs_link_destroy(dl, zp, tx, zflg, NULL);\n\n\tif (error == 0) {\n\t\tuint64_t txtype = TX_RMDIR;\n\t\tif (flags & FIGNORECASE)\n\t\t\ttxtype |= TX_CI;\n\t\tzfs_log_remove(zilog, tx, txtype, dzp, name, ZFS_NO_OBJECT,\n\t\t    B_FALSE);\n\t}\n\n\tdmu_tx_commit(tx);\n\n\trw_exit(&zp->z_parent_lock);\n\trw_exit(&zp->z_name_lock);\nout:\n\tzfs_dirent_unlock(dl);\n\n\tzfs_znode_update_vfs(dzp);\n\tzfs_znode_update_vfs(zp);\n\tzrele(zp);\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_readdir(struct inode *ip, zpl_dir_context_t *ctx, cred_t *cr)\n{\n\t(void) cr;\n\tznode_t\t\t*zp = ITOZ(ip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(ip);\n\tobjset_t\t*os;\n\tzap_cursor_t\tzc;\n\tzap_attribute_t\tzap;\n\tint\t\terror;\n\tuint8_t\t\tprefetch;\n\tuint8_t\t\ttype;\n\tint\t\tdone = 0;\n\tuint64_t\tparent;\n\tuint64_t\toffset;  \n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs),\n\t    &parent, sizeof (parent))) != 0)\n\t\tgoto out;\n\n\t \n\tif (zp->z_unlinked)\n\t\tgoto out;\n\n\terror = 0;\n\tos = zfsvfs->z_os;\n\toffset = ctx->pos;\n\tprefetch = zp->z_zn_prefetch;\n\n\t \n\tif (offset <= 3) {\n\t\t \n\t\tzap_cursor_init(&zc, os, zp->z_id);\n\t} else {\n\t\t \n\t\tzap_cursor_init_serialized(&zc, os, zp->z_id, offset);\n\t}\n\n\t \n\twhile (!done) {\n\t\tuint64_t objnum;\n\t\t \n\t\tif (offset == 0) {\n\t\t\t(void) strcpy(zap.za_name, \".\");\n\t\t\tzap.za_normalization_conflict = 0;\n\t\t\tobjnum = zp->z_id;\n\t\t\ttype = DT_DIR;\n\t\t} else if (offset == 1) {\n\t\t\t(void) strcpy(zap.za_name, \"..\");\n\t\t\tzap.za_normalization_conflict = 0;\n\t\t\tobjnum = parent;\n\t\t\ttype = DT_DIR;\n\t\t} else if (offset == 2 && zfs_show_ctldir(zp)) {\n\t\t\t(void) strcpy(zap.za_name, ZFS_CTLDIR_NAME);\n\t\t\tzap.za_normalization_conflict = 0;\n\t\t\tobjnum = ZFSCTL_INO_ROOT;\n\t\t\ttype = DT_DIR;\n\t\t} else {\n\t\t\t \n\t\t\tif ((error = zap_cursor_retrieve(&zc, &zap))) {\n\t\t\t\tif (error == ENOENT)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tgoto update;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (zap.za_integer_length != 8 ||\n\t\t\t    zap.za_num_integers == 0) {\n\t\t\t\tcmn_err(CE_WARN, \"zap_readdir: bad directory \"\n\t\t\t\t    \"entry, obj = %lld, offset = %lld, \"\n\t\t\t\t    \"length = %d, num = %lld\\n\",\n\t\t\t\t    (u_longlong_t)zp->z_id,\n\t\t\t\t    (u_longlong_t)offset,\n\t\t\t\t    zap.za_integer_length,\n\t\t\t\t    (u_longlong_t)zap.za_num_integers);\n\t\t\t\terror = SET_ERROR(ENXIO);\n\t\t\t\tgoto update;\n\t\t\t}\n\n\t\t\tobjnum = ZFS_DIRENT_OBJ(zap.za_first_integer);\n\t\t\ttype = ZFS_DIRENT_TYPE(zap.za_first_integer);\n\t\t}\n\n\t\tdone = !zpl_dir_emit(ctx, zap.za_name, strlen(zap.za_name),\n\t\t    objnum, type);\n\t\tif (done)\n\t\t\tbreak;\n\n\t\t \n\t\tif (prefetch) {\n\t\t\tdmu_prefetch(os, objnum, 0, 0, 0,\n\t\t\t    ZIO_PRIORITY_SYNC_READ);\n\t\t}\n\n\t\t \n\t\tif (offset > 2 || (offset == 2 && !zfs_show_ctldir(zp))) {\n\t\t\tzap_cursor_advance(&zc);\n\t\t\toffset = zap_cursor_serialize(&zc);\n\t\t} else {\n\t\t\toffset += 1;\n\t\t}\n\t\tctx->pos = offset;\n\t}\n\tzp->z_zn_prefetch = B_FALSE;  \n\nupdate:\n\tzap_cursor_fini(&zc);\n\tif (error == ENOENT)\n\t\terror = 0;\nout:\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\n#ifdef HAVE_GENERIC_FILLATTR_IDMAP_REQMASK\nzfs_getattr_fast(zidmap_t *user_ns, u32 request_mask, struct inode *ip,\n    struct kstat *sp)\n#else\nzfs_getattr_fast(zidmap_t *user_ns, struct inode *ip, struct kstat *sp)\n#endif\n{\n\tznode_t *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tuint32_t blksize;\n\tu_longlong_t nblocks;\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tmutex_enter(&zp->z_lock);\n\n#ifdef HAVE_GENERIC_FILLATTR_IDMAP_REQMASK\n\tzpl_generic_fillattr(user_ns, request_mask, ip, sp);\n#else\n\tzpl_generic_fillattr(user_ns, ip, sp);\n#endif\n\t \n\tif ((zp->z_id == zfsvfs->z_root) && zfs_show_ctldir(zp))\n\t\tif (sp->nlink < ZFS_LINK_MAX)\n\t\t\tsp->nlink++;\n\n\tsa_object_size(zp->z_sa_hdl, &blksize, &nblocks);\n\tsp->blksize = blksize;\n\tsp->blocks = nblocks;\n\n\tif (unlikely(zp->z_blksz == 0)) {\n\t\t \n\t\tsp->blksize = zfsvfs->z_max_blksz;\n\t}\n\n\tmutex_exit(&zp->z_lock);\n\n\t \n\tif (zfsvfs->z_issnap) {\n\t\tif (ip->i_sb->s_root->d_inode == ip)\n\t\t\tsp->ino = ZFSCTL_INO_SNAPDIRS -\n\t\t\t    dmu_objset_id(zfsvfs->z_os);\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_setattr_dir(znode_t *dzp)\n{\n\tstruct inode\t*dxip = ZTOI(dzp);\n\tstruct inode\t*xip = NULL;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tobjset_t\t*os = zfsvfs->z_os;\n\tzap_cursor_t\tzc;\n\tzap_attribute_t\tzap;\n\tzfs_dirlock_t\t*dl;\n\tznode_t\t\t*zp = NULL;\n\tdmu_tx_t\t*tx = NULL;\n\tuint64_t\tuid, gid;\n\tsa_bulk_attr_t\tbulk[4];\n\tint\t\tcount;\n\tint\t\terr;\n\n\tzap_cursor_init(&zc, os, dzp->z_id);\n\twhile ((err = zap_cursor_retrieve(&zc, &zap)) == 0) {\n\t\tcount = 0;\n\t\tif (zap.za_integer_length != 8 || zap.za_num_integers != 1) {\n\t\t\terr = ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = zfs_dirent_lock(&dl, dzp, (char *)zap.za_name, &zp,\n\t\t    ZEXISTS, NULL, NULL);\n\t\tif (err == ENOENT)\n\t\t\tgoto next;\n\t\tif (err)\n\t\t\tbreak;\n\n\t\txip = ZTOI(zp);\n\t\tif (KUID_TO_SUID(xip->i_uid) == KUID_TO_SUID(dxip->i_uid) &&\n\t\t    KGID_TO_SGID(xip->i_gid) == KGID_TO_SGID(dxip->i_gid) &&\n\t\t    zp->z_projid == dzp->z_projid)\n\t\t\tgoto next;\n\n\t\ttx = dmu_tx_create(os);\n\t\tif (!(zp->z_pflags & ZFS_PROJID))\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t\telse\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\n\t\terr = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tmutex_enter(&dzp->z_lock);\n\n\t\tif (KUID_TO_SUID(xip->i_uid) != KUID_TO_SUID(dxip->i_uid)) {\n\t\t\txip->i_uid = dxip->i_uid;\n\t\t\tuid = zfs_uid_read(dxip);\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t\t\t    &uid, sizeof (uid));\n\t\t}\n\n\t\tif (KGID_TO_SGID(xip->i_gid) != KGID_TO_SGID(dxip->i_gid)) {\n\t\t\txip->i_gid = dxip->i_gid;\n\t\t\tgid = zfs_gid_read(dxip);\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL,\n\t\t\t    &gid, sizeof (gid));\n\t\t}\n\n\t\tif (zp->z_projid != dzp->z_projid) {\n\t\t\tif (!(zp->z_pflags & ZFS_PROJID)) {\n\t\t\t\tzp->z_pflags |= ZFS_PROJID;\n\t\t\t\tSA_ADD_BULK_ATTR(bulk, count,\n\t\t\t\t    SA_ZPL_FLAGS(zfsvfs), NULL, &zp->z_pflags,\n\t\t\t\t    sizeof (zp->z_pflags));\n\t\t\t}\n\n\t\t\tzp->z_projid = dzp->z_projid;\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PROJID(zfsvfs),\n\t\t\t    NULL, &zp->z_projid, sizeof (zp->z_projid));\n\t\t}\n\n\t\tmutex_exit(&dzp->z_lock);\n\n\t\tif (likely(count > 0)) {\n\t\t\terr = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\t\t\tdmu_tx_commit(tx);\n\t\t} else {\n\t\t\tdmu_tx_abort(tx);\n\t\t}\n\t\ttx = NULL;\n\t\tif (err != 0 && err != ENOENT)\n\t\t\tbreak;\n\nnext:\n\t\tif (zp) {\n\t\t\tzrele(zp);\n\t\t\tzp = NULL;\n\t\t\tzfs_dirent_unlock(dl);\n\t\t}\n\t\tzap_cursor_advance(&zc);\n\t}\n\n\tif (tx)\n\t\tdmu_tx_abort(tx);\n\tif (zp) {\n\t\tzrele(zp);\n\t\tzfs_dirent_unlock(dl);\n\t}\n\tzap_cursor_fini(&zc);\n\n\treturn (err == ENOENT ? 0 : err);\n}\n\n \nint\nzfs_setattr(znode_t *zp, vattr_t *vap, int flags, cred_t *cr, zidmap_t *mnt_ns)\n{\n\tstruct inode\t*ip;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zp);\n\tobjset_t\t*os = zfsvfs->z_os;\n\tzilog_t\t\t*zilog;\n\tdmu_tx_t\t*tx;\n\tvattr_t\t\toldva;\n\txvattr_t\t*tmpxvattr;\n\tuint_t\t\tmask = vap->va_mask;\n\tuint_t\t\tsaved_mask = 0;\n\tint\t\ttrim_mask = 0;\n\tuint64_t\tnew_mode;\n\tuint64_t\tnew_kuid = 0, new_kgid = 0, new_uid, new_gid;\n\tuint64_t\txattr_obj;\n\tuint64_t\tmtime[2], ctime[2], atime[2];\n\tuint64_t\tprojid = ZFS_INVALID_PROJID;\n\tznode_t\t\t*attrzp;\n\tint\t\tneed_policy = FALSE;\n\tint\t\terr, err2 = 0;\n\tzfs_fuid_info_t *fuidp = NULL;\n\txvattr_t *xvap = (xvattr_t *)vap;\t \n\txoptattr_t\t*xoap;\n\tzfs_acl_t\t*aclp;\n\tboolean_t skipaclchk = (flags & ATTR_NOACLCHECK) ? B_TRUE : B_FALSE;\n\tboolean_t\tfuid_dirtied = B_FALSE;\n\tboolean_t\thandle_eadir = B_FALSE;\n\tsa_bulk_attr_t\t*bulk, *xattr_bulk;\n\tint\t\tcount = 0, xattr_count = 0, bulks = 8;\n\n\tif (mask == 0)\n\t\treturn (0);\n\n\tif ((err = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (err);\n\tip = ZTOI(zp);\n\n\t \n\txoap = xva_getxoptattr(xvap);\n\tif (xoap != NULL && (mask & ATTR_XVATTR)) {\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJID)) {\n\t\t\tif (!dmu_objset_projectquota_enabled(os) ||\n\t\t\t    (!S_ISREG(ip->i_mode) && !S_ISDIR(ip->i_mode))) {\n\t\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t\t}\n\n\t\t\tprojid = xoap->xoa_projid;\n\t\t\tif (unlikely(projid == ZFS_INVALID_PROJID)) {\n\t\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\n\t\t\tif (projid == zp->z_projid && zp->z_pflags & ZFS_PROJID)\n\t\t\t\tprojid = ZFS_INVALID_PROJID;\n\t\t\telse\n\t\t\t\tneed_policy = TRUE;\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT) &&\n\t\t    (xoap->xoa_projinherit !=\n\t\t    ((zp->z_pflags & ZFS_PROJINHERIT) != 0)) &&\n\t\t    (!dmu_objset_projectquota_enabled(os) ||\n\t\t    (!S_ISREG(ip->i_mode) && !S_ISDIR(ip->i_mode)))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\t}\n\t}\n\n\tzilog = zfsvfs->z_log;\n\n\t \n\n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    (((mask & ATTR_UID) && IS_EPHEMERAL(vap->va_uid)) ||\n\t    ((mask & ATTR_GID) && IS_EPHEMERAL(vap->va_gid)) ||\n\t    (mask & ATTR_XVATTR))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (mask & ATTR_SIZE && S_ISDIR(ip->i_mode)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EISDIR));\n\t}\n\n\tif (mask & ATTR_SIZE && !S_ISREG(ip->i_mode) && !S_ISFIFO(ip->i_mode)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\ttmpxvattr = kmem_alloc(sizeof (xvattr_t), KM_SLEEP);\n\txva_init(tmpxvattr);\n\n\tbulk = kmem_alloc(sizeof (sa_bulk_attr_t) * bulks, KM_SLEEP);\n\txattr_bulk = kmem_alloc(sizeof (sa_bulk_attr_t) * bulks, KM_SLEEP);\n\n\t \n\tif ((zp->z_pflags & ZFS_IMMUTABLE) &&\n\t    ((mask & (ATTR_SIZE|ATTR_UID|ATTR_GID|ATTR_MTIME|ATTR_MODE)) ||\n\t    ((mask & ATTR_XVATTR) && XVA_ISSET_REQ(xvap, XAT_CREATETIME)))) {\n\t\terr = SET_ERROR(EPERM);\n\t\tgoto out3;\n\t}\n\n\tif ((mask & ATTR_SIZE) && (zp->z_pflags & ZFS_READONLY)) {\n\t\terr = SET_ERROR(EPERM);\n\t\tgoto out3;\n\t}\n\n\t \n\tif (mask & (ATTR_ATIME | ATTR_MTIME)) {\n\t\tif (((mask & ATTR_ATIME) &&\n\t\t    TIMESPEC_OVERFLOW(&vap->va_atime)) ||\n\t\t    ((mask & ATTR_MTIME) &&\n\t\t    TIMESPEC_OVERFLOW(&vap->va_mtime))) {\n\t\t\terr = SET_ERROR(EOVERFLOW);\n\t\t\tgoto out3;\n\t\t}\n\t}\n\ntop:\n\tattrzp = NULL;\n\taclp = NULL;\n\n\t \n\tif (zfs_is_readonly(zfsvfs)) {\n\t\terr = SET_ERROR(EROFS);\n\t\tgoto out3;\n\t}\n\n\t \n\n\tif (mask & ATTR_SIZE) {\n\t\terr = zfs_zaccess(zp, ACE_WRITE_DATA, 0, skipaclchk, cr,\n\t\t    mnt_ns);\n\t\tif (err)\n\t\t\tgoto out3;\n\n\t\t \n\t\t \n\t\terr = zfs_freesp(zp, vap->va_size, 0, 0, FALSE);\n\t\tif (err)\n\t\t\tgoto out3;\n\t}\n\n\tif (mask & (ATTR_ATIME|ATTR_MTIME) ||\n\t    ((mask & ATTR_XVATTR) && (XVA_ISSET_REQ(xvap, XAT_HIDDEN) ||\n\t    XVA_ISSET_REQ(xvap, XAT_READONLY) ||\n\t    XVA_ISSET_REQ(xvap, XAT_ARCHIVE) ||\n\t    XVA_ISSET_REQ(xvap, XAT_OFFLINE) ||\n\t    XVA_ISSET_REQ(xvap, XAT_SPARSE) ||\n\t    XVA_ISSET_REQ(xvap, XAT_CREATETIME) ||\n\t    XVA_ISSET_REQ(xvap, XAT_SYSTEM)))) {\n\t\tneed_policy = zfs_zaccess(zp, ACE_WRITE_ATTRIBUTES, 0,\n\t\t    skipaclchk, cr, mnt_ns);\n\t}\n\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\tint\tidmask = (mask & (ATTR_UID|ATTR_GID));\n\t\tint\ttake_owner;\n\t\tint\ttake_group;\n\t\tuid_t\tuid;\n\t\tgid_t\tgid;\n\n\t\t \n\n\t\tif (!(mask & ATTR_MODE))\n\t\t\tvap->va_mode = zp->z_mode;\n\n\t\t \n\n\t\tuid = zfs_uid_to_vfsuid(mnt_ns, zfs_i_user_ns(ip),\n\t\t    vap->va_uid);\n\t\tgid = zfs_gid_to_vfsgid(mnt_ns, zfs_i_user_ns(ip),\n\t\t    vap->va_gid);\n\t\ttake_owner = (mask & ATTR_UID) && (uid == crgetuid(cr));\n\t\ttake_group = (mask & ATTR_GID) &&\n\t\t    zfs_groupmember(zfsvfs, gid, cr);\n\n\t\t \n\n\t\tif (((idmask == (ATTR_UID|ATTR_GID)) &&\n\t\t    take_owner && take_group) ||\n\t\t    ((idmask == ATTR_UID) && take_owner) ||\n\t\t    ((idmask == ATTR_GID) && take_group)) {\n\t\t\tif (zfs_zaccess(zp, ACE_WRITE_OWNER, 0,\n\t\t\t    skipaclchk, cr, mnt_ns) == 0) {\n\t\t\t\t \n\t\t\t\t(void) secpolicy_setid_clear(vap, cr);\n\t\t\t\ttrim_mask = (mask & (ATTR_UID|ATTR_GID));\n\t\t\t} else {\n\t\t\t\tneed_policy =  TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tneed_policy =  TRUE;\n\t\t}\n\t}\n\n\tmutex_enter(&zp->z_lock);\n\toldva.va_mode = zp->z_mode;\n\tzfs_fuid_map_ids(zp, cr, &oldva.va_uid, &oldva.va_gid);\n\tif (mask & ATTR_XVATTR) {\n\t\t \n\t\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY)) {\n\t\t\tif (xoap->xoa_appendonly !=\n\t\t\t    ((zp->z_pflags & ZFS_APPENDONLY) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_APPENDONLY);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_APPENDONLY);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT)) {\n\t\t\tif (xoap->xoa_projinherit !=\n\t\t\t    ((zp->z_pflags & ZFS_PROJINHERIT) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_PROJINHERIT);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_PROJINHERIT);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK)) {\n\t\t\tif (xoap->xoa_nounlink !=\n\t\t\t    ((zp->z_pflags & ZFS_NOUNLINK) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_NOUNLINK);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_NOUNLINK);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE)) {\n\t\t\tif (xoap->xoa_immutable !=\n\t\t\t    ((zp->z_pflags & ZFS_IMMUTABLE) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_IMMUTABLE);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_IMMUTABLE);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP)) {\n\t\t\tif (xoap->xoa_nodump !=\n\t\t\t    ((zp->z_pflags & ZFS_NODUMP) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_NODUMP);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_NODUMP);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED)) {\n\t\t\tif (xoap->xoa_av_modified !=\n\t\t\t    ((zp->z_pflags & ZFS_AV_MODIFIED) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_AV_MODIFIED);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_AV_MODIFIED);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED)) {\n\t\t\tif ((!S_ISREG(ip->i_mode) &&\n\t\t\t    xoap->xoa_av_quarantined) ||\n\t\t\t    xoap->xoa_av_quarantined !=\n\t\t\t    ((zp->z_pflags & ZFS_AV_QUARANTINED) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_AV_QUARANTINED);\n\t\t\t\tXVA_SET_REQ(tmpxvattr, XAT_AV_QUARANTINED);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE)) {\n\t\t\tmutex_exit(&zp->z_lock);\n\t\t\terr = SET_ERROR(EPERM);\n\t\t\tgoto out3;\n\t\t}\n\n\t\tif (need_policy == FALSE &&\n\t\t    (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP) ||\n\t\t    XVA_ISSET_REQ(xvap, XAT_OPAQUE))) {\n\t\t\tneed_policy = TRUE;\n\t\t}\n\t}\n\n\tmutex_exit(&zp->z_lock);\n\n\tif (mask & ATTR_MODE) {\n\t\tif (zfs_zaccess(zp, ACE_WRITE_ACL, 0, skipaclchk, cr,\n\t\t    mnt_ns) == 0) {\n\t\t\terr = secpolicy_setid_setsticky_clear(ip, vap,\n\t\t\t    &oldva, cr, mnt_ns, zfs_i_user_ns(ip));\n\t\t\tif (err)\n\t\t\t\tgoto out3;\n\t\t\ttrim_mask |= ATTR_MODE;\n\t\t} else {\n\t\t\tneed_policy = TRUE;\n\t\t}\n\t}\n\n\tif (need_policy) {\n\t\t \n\n\t\tif (trim_mask) {\n\t\t\tsaved_mask = vap->va_mask;\n\t\t\tvap->va_mask &= ~trim_mask;\n\t\t}\n\t\terr = secpolicy_vnode_setattr(cr, ip, vap, &oldva, flags,\n\t\t    zfs_zaccess_unix, zp);\n\t\tif (err)\n\t\t\tgoto out3;\n\n\t\tif (trim_mask)\n\t\t\tvap->va_mask |= saved_mask;\n\t}\n\n\t \n\tmask = vap->va_mask;\n\n\tif ((mask & (ATTR_UID | ATTR_GID)) || projid != ZFS_INVALID_PROJID) {\n\t\thandle_eadir = B_TRUE;\n\t\terr = sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t\t    &xattr_obj, sizeof (xattr_obj));\n\n\t\tif (err == 0 && xattr_obj) {\n\t\t\terr = zfs_zget(ZTOZSB(zp), xattr_obj, &attrzp);\n\t\t\tif (err)\n\t\t\t\tgoto out2;\n\t\t}\n\t\tif (mask & ATTR_UID) {\n\t\t\tnew_kuid = zfs_fuid_create(zfsvfs,\n\t\t\t    (uint64_t)vap->va_uid, cr, ZFS_OWNER, &fuidp);\n\t\t\tif (new_kuid != KUID_TO_SUID(ZTOI(zp)->i_uid) &&\n\t\t\t    zfs_id_overquota(zfsvfs, DMU_USERUSED_OBJECT,\n\t\t\t    new_kuid)) {\n\t\t\t\tif (attrzp)\n\t\t\t\t\tzrele(attrzp);\n\t\t\t\terr = SET_ERROR(EDQUOT);\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\n\t\tif (mask & ATTR_GID) {\n\t\t\tnew_kgid = zfs_fuid_create(zfsvfs,\n\t\t\t    (uint64_t)vap->va_gid, cr, ZFS_GROUP, &fuidp);\n\t\t\tif (new_kgid != KGID_TO_SGID(ZTOI(zp)->i_gid) &&\n\t\t\t    zfs_id_overquota(zfsvfs, DMU_GROUPUSED_OBJECT,\n\t\t\t    new_kgid)) {\n\t\t\t\tif (attrzp)\n\t\t\t\t\tzrele(attrzp);\n\t\t\t\terr = SET_ERROR(EDQUOT);\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\n\t\tif (projid != ZFS_INVALID_PROJID &&\n\t\t    zfs_id_overquota(zfsvfs, DMU_PROJECTUSED_OBJECT, projid)) {\n\t\t\tif (attrzp)\n\t\t\t\tzrele(attrzp);\n\t\t\terr = EDQUOT;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\ttx = dmu_tx_create(os);\n\n\tif (mask & ATTR_MODE) {\n\t\tuint64_t pmode = zp->z_mode;\n\t\tuint64_t acl_obj;\n\t\tnew_mode = (pmode & S_IFMT) | (vap->va_mode & ~S_IFMT);\n\n\t\tif (ZTOZSB(zp)->z_acl_mode == ZFS_ACL_RESTRICTED &&\n\t\t    !(zp->z_pflags & ZFS_ACL_TRIVIAL)) {\n\t\t\terr = EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((err = zfs_acl_chmod_setattr(zp, &aclp, new_mode)))\n\t\t\tgoto out;\n\n\t\tmutex_enter(&zp->z_lock);\n\t\tif (!zp->z_is_sa && ((acl_obj = zfs_external_acl(zp)) != 0)) {\n\t\t\t \n\t\t\tif (zfsvfs->z_version >= ZPL_VERSION_FUID &&\n\t\t\t    zfs_znode_acl_version(zp) ==\n\t\t\t    ZFS_ACL_VERSION_INITIAL) {\n\t\t\t\tdmu_tx_hold_free(tx, acl_obj, 0,\n\t\t\t\t    DMU_OBJECT_END);\n\t\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t\t\t    0, aclp->z_acl_bytes);\n\t\t\t} else {\n\t\t\t\tdmu_tx_hold_write(tx, acl_obj, 0,\n\t\t\t\t    aclp->z_acl_bytes);\n\t\t\t}\n\t\t} else if (!zp->z_is_sa && aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t\t    0, aclp->z_acl_bytes);\n\t\t}\n\t\tmutex_exit(&zp->z_lock);\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t} else {\n\t\tif (((mask & ATTR_XVATTR) &&\n\t\t    XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP)) ||\n\t\t    (projid != ZFS_INVALID_PROJID &&\n\t\t    !(zp->z_pflags & ZFS_PROJID)))\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t\telse\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t}\n\n\tif (attrzp) {\n\t\tdmu_tx_hold_sa(tx, attrzp->z_sa_hdl, B_FALSE);\n\t}\n\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\n\tzfs_sa_upgrade_txholds(tx, zp);\n\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err)\n\t\tgoto out;\n\n\tcount = 0;\n\t \n\n\tif (projid != ZFS_INVALID_PROJID && !(zp->z_pflags & ZFS_PROJID)) {\n\t\t \n\t\tif (attrzp)\n\t\t\terr = sa_add_projid(attrzp->z_sa_hdl, tx, projid);\n\t\tif (err == 0)\n\t\t\terr = sa_add_projid(zp->z_sa_hdl, tx, projid);\n\n\t\tif (unlikely(err == EEXIST))\n\t\t\terr = 0;\n\t\telse if (err != 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tprojid = ZFS_INVALID_PROJID;\n\t}\n\n\tif (mask & (ATTR_UID|ATTR_GID|ATTR_MODE))\n\t\tmutex_enter(&zp->z_acl_lock);\n\tmutex_enter(&zp->z_lock);\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\n\tif (attrzp) {\n\t\tif (mask & (ATTR_UID|ATTR_GID|ATTR_MODE))\n\t\t\tmutex_enter(&attrzp->z_acl_lock);\n\t\tmutex_enter(&attrzp->z_lock);\n\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t    SA_ZPL_FLAGS(zfsvfs), NULL, &attrzp->z_pflags,\n\t\t    sizeof (attrzp->z_pflags));\n\t\tif (projid != ZFS_INVALID_PROJID) {\n\t\t\tattrzp->z_projid = projid;\n\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t    SA_ZPL_PROJID(zfsvfs), NULL, &attrzp->z_projid,\n\t\t\t    sizeof (attrzp->z_projid));\n\t\t}\n\t}\n\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\n\t\tif (mask & ATTR_UID) {\n\t\t\tZTOI(zp)->i_uid = SUID_TO_KUID(new_kuid);\n\t\t\tnew_uid = zfs_uid_read(ZTOI(zp));\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t\t\t    &new_uid, sizeof (new_uid));\n\t\t\tif (attrzp) {\n\t\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t\t    SA_ZPL_UID(zfsvfs), NULL, &new_uid,\n\t\t\t\t    sizeof (new_uid));\n\t\t\t\tZTOI(attrzp)->i_uid = SUID_TO_KUID(new_uid);\n\t\t\t}\n\t\t}\n\n\t\tif (mask & ATTR_GID) {\n\t\t\tZTOI(zp)->i_gid = SGID_TO_KGID(new_kgid);\n\t\t\tnew_gid = zfs_gid_read(ZTOI(zp));\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs),\n\t\t\t    NULL, &new_gid, sizeof (new_gid));\n\t\t\tif (attrzp) {\n\t\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t\t    SA_ZPL_GID(zfsvfs), NULL, &new_gid,\n\t\t\t\t    sizeof (new_gid));\n\t\t\t\tZTOI(attrzp)->i_gid = SGID_TO_KGID(new_kgid);\n\t\t\t}\n\t\t}\n\t\tif (!(mask & ATTR_MODE)) {\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs),\n\t\t\t    NULL, &new_mode, sizeof (new_mode));\n\t\t\tnew_mode = zp->z_mode;\n\t\t}\n\t\terr = zfs_acl_chown_setattr(zp);\n\t\tASSERT(err == 0);\n\t\tif (attrzp) {\n\t\t\terr = zfs_acl_chown_setattr(attrzp);\n\t\t\tASSERT(err == 0);\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t\t    &new_mode, sizeof (new_mode));\n\t\tzp->z_mode = ZTOI(zp)->i_mode = new_mode;\n\t\tASSERT3P(aclp, !=, NULL);\n\t\terr = zfs_aclset_common(zp, aclp, cr, tx);\n\t\tASSERT0(err);\n\t\tif (zp->z_acl_cached)\n\t\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = aclp;\n\t\taclp = NULL;\n\t}\n\n\tif ((mask & ATTR_ATIME) || zp->z_atime_dirty) {\n\t\tzp->z_atime_dirty = B_FALSE;\n\t\tZFS_TIME_ENCODE(&ip->i_atime, atime);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t\t    &atime, sizeof (atime));\n\t}\n\n\tif (mask & (ATTR_MTIME | ATTR_SIZE)) {\n\t\tZFS_TIME_ENCODE(&vap->va_mtime, mtime);\n\t\tZTOI(zp)->i_mtime = zpl_inode_timestamp_truncate(\n\t\t    vap->va_mtime, ZTOI(zp));\n\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t\t    mtime, sizeof (mtime));\n\t}\n\n\tif (mask & (ATTR_CTIME | ATTR_SIZE)) {\n\t\tZFS_TIME_ENCODE(&vap->va_ctime, ctime);\n\t\tzpl_inode_set_ctime_to_ts(ZTOI(zp),\n\t\t    zpl_inode_timestamp_truncate(vap->va_ctime, ZTOI(zp)));\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    ctime, sizeof (ctime));\n\t}\n\n\tif (projid != ZFS_INVALID_PROJID) {\n\t\tzp->z_projid = projid;\n\t\tSA_ADD_BULK_ATTR(bulk, count,\n\t\t    SA_ZPL_PROJID(zfsvfs), NULL, &zp->z_projid,\n\t\t    sizeof (zp->z_projid));\n\t}\n\n\tif (attrzp && mask) {\n\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t    SA_ZPL_CTIME(zfsvfs), NULL, &ctime,\n\t\t    sizeof (ctime));\n\t}\n\n\t \n\n\tif (xoap && (mask & ATTR_XVATTR)) {\n\n\t\t \n\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_APPENDONLY)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_APPENDONLY);\n\t\t}\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_NOUNLINK)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_NOUNLINK);\n\t\t}\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_IMMUTABLE)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_IMMUTABLE);\n\t\t}\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_NODUMP)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_NODUMP);\n\t\t}\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_AV_MODIFIED)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_AV_MODIFIED);\n\t\t}\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_AV_QUARANTINED)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_AV_QUARANTINED);\n\t\t}\n\t\tif (XVA_ISSET_REQ(tmpxvattr, XAT_PROJINHERIT)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_PROJINHERIT);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP))\n\t\t\tASSERT(S_ISREG(ip->i_mode));\n\n\t\tzfs_xvattr_set(zp, xvap, tx);\n\t}\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tif (mask != 0)\n\t\tzfs_log_setattr(zilog, tx, TX_SETATTR, zp, vap, mask, fuidp);\n\n\tmutex_exit(&zp->z_lock);\n\tif (mask & (ATTR_UID|ATTR_GID|ATTR_MODE))\n\t\tmutex_exit(&zp->z_acl_lock);\n\n\tif (attrzp) {\n\t\tif (mask & (ATTR_UID|ATTR_GID|ATTR_MODE))\n\t\t\tmutex_exit(&attrzp->z_acl_lock);\n\t\tmutex_exit(&attrzp->z_lock);\n\t}\nout:\n\tif (err == 0 && xattr_count > 0) {\n\t\terr2 = sa_bulk_update(attrzp->z_sa_hdl, xattr_bulk,\n\t\t    xattr_count, tx);\n\t\tASSERT(err2 == 0);\n\t}\n\n\tif (aclp)\n\t\tzfs_acl_free(aclp);\n\n\tif (fuidp) {\n\t\tzfs_fuid_info_free(fuidp);\n\t\tfuidp = NULL;\n\t}\n\n\tif (err) {\n\t\tdmu_tx_abort(tx);\n\t\tif (attrzp)\n\t\t\tzrele(attrzp);\n\t\tif (err == ERESTART)\n\t\t\tgoto top;\n\t} else {\n\t\tif (count > 0)\n\t\t\terr2 = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\t\tdmu_tx_commit(tx);\n\t\tif (attrzp) {\n\t\t\tif (err2 == 0 && handle_eadir)\n\t\t\t\terr = zfs_setattr_dir(attrzp);\n\t\t\tzrele(attrzp);\n\t\t}\n\t\tzfs_znode_update_vfs(zp);\n\t}\n\nout2:\n\tif (os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\nout3:\n\tkmem_free(xattr_bulk, sizeof (sa_bulk_attr_t) * bulks);\n\tkmem_free(bulk, sizeof (sa_bulk_attr_t) * bulks);\n\tkmem_free(tmpxvattr, sizeof (xvattr_t));\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (err);\n}\n\ntypedef struct zfs_zlock {\n\tkrwlock_t\t*zl_rwlock;\t \n\tznode_t\t\t*zl_znode;\t \n\tstruct zfs_zlock *zl_next;\t \n} zfs_zlock_t;\n\n \nstatic void\nzfs_rename_unlock(zfs_zlock_t **zlpp)\n{\n\tzfs_zlock_t *zl;\n\n\twhile ((zl = *zlpp) != NULL) {\n\t\tif (zl->zl_znode != NULL)\n\t\t\tzfs_zrele_async(zl->zl_znode);\n\t\trw_exit(zl->zl_rwlock);\n\t\t*zlpp = zl->zl_next;\n\t\tkmem_free(zl, sizeof (*zl));\n\t}\n}\n\n \nstatic int\nzfs_rename_lock(znode_t *szp, znode_t *tdzp, znode_t *sdzp, zfs_zlock_t **zlpp)\n{\n\tzfs_zlock_t\t*zl;\n\tznode_t\t\t*zp = tdzp;\n\tuint64_t\trootid = ZTOZSB(zp)->z_root;\n\tuint64_t\toidp = zp->z_id;\n\tkrwlock_t\t*rwlp = &szp->z_parent_lock;\n\tkrw_t\t\trw = RW_WRITER;\n\n\t \n\tdo {\n\t\tif (!rw_tryenter(rwlp, rw)) {\n\t\t\t \n\t\t\tif (rw == RW_READER && zp->z_id > szp->z_id) {\n\t\t\t\t \n\t\t\t\tzfs_rename_unlock(&zl);\n\t\t\t\t*zlpp = NULL;\n\t\t\t\tzp = tdzp;\n\t\t\t\toidp = zp->z_id;\n\t\t\t\trwlp = &szp->z_parent_lock;\n\t\t\t\trw = RW_WRITER;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trw_enter(rwlp, rw);\n\t\t\t}\n\t\t}\n\n\t\tzl = kmem_alloc(sizeof (*zl), KM_SLEEP);\n\t\tzl->zl_rwlock = rwlp;\n\t\tzl->zl_znode = NULL;\n\t\tzl->zl_next = *zlpp;\n\t\t*zlpp = zl;\n\n\t\tif (oidp == szp->z_id)\t\t \n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tif (oidp == rootid)\t\t \n\t\t\treturn (0);\n\n\t\tif (rw == RW_READER) {\t\t \n\t\t\tint error = zfs_zget(ZTOZSB(zp), oidp, &zp);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tzl->zl_znode = zp;\n\t\t}\n\t\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_PARENT(ZTOZSB(zp)),\n\t\t    &oidp, sizeof (oidp));\n\t\trwlp = &zp->z_parent_lock;\n\t\trw = RW_READER;\n\n\t} while (zp->z_id != sdzp->z_id);\n\n\treturn (0);\n}\n\n \nint\nzfs_rename(znode_t *sdzp, char *snm, znode_t *tdzp, char *tnm,\n    cred_t *cr, int flags, uint64_t rflags, vattr_t *wo_vap, zidmap_t *mnt_ns)\n{\n\tznode_t\t\t*szp, *tzp;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(sdzp);\n\tzilog_t\t\t*zilog;\n\tzfs_dirlock_t\t*sdl, *tdl;\n\tdmu_tx_t\t*tx;\n\tzfs_zlock_t\t*zl;\n\tint\t\tcmp, serr, terr;\n\tint\t\terror = 0;\n\tint\t\tzflg = 0;\n\tboolean_t\twaited = B_FALSE;\n\t \n\tboolean_t\tfuid_dirtied;\n\tzfs_acl_ids_t\tacl_ids;\n\tboolean_t\thave_acl = B_FALSE;\n\tznode_t\t\t*wzp = NULL;\n\n\n\tif (snm == NULL || tnm == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (rflags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (rflags & RENAME_EXCHANGE &&\n\t    (rflags & (RENAME_NOREPLACE | RENAME_WHITEOUT)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tVERIFY_EQUIV(rflags & RENAME_WHITEOUT, wo_vap != NULL);\n\tVERIFY_IMPLY(wo_vap, wo_vap->va_mode == S_IFCHR);\n\tVERIFY_IMPLY(wo_vap, wo_vap->va_rdev == makedevice(0, 0));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, sdzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif ((error = zfs_verify_zp(tdzp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (ZTOI(tdzp)->i_sb != ZTOI(sdzp)->i_sb ||\n\t    zfsctl_is_node(ZTOI(tdzp))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(tnm,\n\t    strlen(tnm), NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\tif (flags & FIGNORECASE)\n\t\tzflg |= ZCILOOK;\n\ntop:\n\tszp = NULL;\n\ttzp = NULL;\n\tzl = NULL;\n\n\t \n\tif ((tdzp->z_pflags & ZFS_XATTR) != (sdzp->z_pflags & ZFS_XATTR)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (sdzp->z_id < tdzp->z_id) {\n\t\tcmp = -1;\n\t} else if (sdzp->z_id > tdzp->z_id) {\n\t\tcmp = 1;\n\t} else {\n\t\t \n\t\tint nofold = (zfsvfs->z_norm & ~U8_TEXTPREP_TOUPPER);\n\n\t\tcmp = u8_strcmp(snm, tnm, 0, nofold, U8_UNICODE_LATEST, &error);\n\t\tASSERT(error == 0 || !zfsvfs->z_utf8);\n\t\tif (cmp == 0) {\n\t\t\t \n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (0);\n\t\t}\n\t\t \n\t\tif ((zfsvfs->z_case == ZFS_CASE_INSENSITIVE ||\n\t\t    (zfsvfs->z_case == ZFS_CASE_MIXED &&\n\t\t    flags & FIGNORECASE)) &&\n\t\t    u8_strcmp(snm, tnm, 0, zfsvfs->z_norm, U8_UNICODE_LATEST,\n\t\t    &error) == 0) {\n\t\t\t \n\t\t\tzflg |= ZCIEXACT;\n\t\t\tzflg &= ~ZCILOOK;\n\t\t}\n\t}\n\n\t \n\tif (sdzp == tdzp) {\n\t\tzflg |= ZHAVELOCK;\n\t\trw_enter(&sdzp->z_name_lock, RW_READER);\n\t}\n\n\tif (cmp < 0) {\n\t\tserr = zfs_dirent_lock(&sdl, sdzp, snm, &szp,\n\t\t    ZEXISTS | zflg, NULL, NULL);\n\t\tterr = zfs_dirent_lock(&tdl,\n\t\t    tdzp, tnm, &tzp, ZRENAMING | zflg, NULL, NULL);\n\t} else {\n\t\tterr = zfs_dirent_lock(&tdl,\n\t\t    tdzp, tnm, &tzp, zflg, NULL, NULL);\n\t\tserr = zfs_dirent_lock(&sdl,\n\t\t    sdzp, snm, &szp, ZEXISTS | ZRENAMING | zflg,\n\t\t    NULL, NULL);\n\t}\n\n\tif (serr) {\n\t\t \n\t\tif (!terr) {\n\t\t\tzfs_dirent_unlock(tdl);\n\t\t\tif (tzp)\n\t\t\t\tzrele(tzp);\n\t\t}\n\n\t\tif (sdzp == tdzp)\n\t\t\trw_exit(&sdzp->z_name_lock);\n\n\t\tif (strcmp(snm, \"..\") == 0)\n\t\t\tserr = EINVAL;\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (serr);\n\t}\n\tif (terr) {\n\t\tzfs_dirent_unlock(sdl);\n\t\tzrele(szp);\n\n\t\tif (sdzp == tdzp)\n\t\t\trw_exit(&sdzp->z_name_lock);\n\n\t\tif (strcmp(tnm, \"..\") == 0)\n\t\t\tterr = EINVAL;\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (terr);\n\t}\n\n\t \n\tif (tdzp->z_pflags & ZFS_PROJINHERIT &&\n\t    tdzp->z_projid != szp->z_projid) {\n\t\terror = SET_ERROR(EXDEV);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((error = zfs_zaccess_rename(sdzp, szp, tdzp, tzp, cr, mnt_ns)))\n\t\tgoto out;\n\n\tif (S_ISDIR(ZTOI(szp)->i_mode)) {\n\t\t \n\t\tif ((error = zfs_rename_lock(szp, tdzp, sdzp, &zl)))\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (tzp) {\n\t\tif (rflags & RENAME_NOREPLACE) {\n\t\t\terror = SET_ERROR(EEXIST);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (!(rflags & RENAME_EXCHANGE)) {\n\t\t\tboolean_t s_is_dir = S_ISDIR(ZTOI(szp)->i_mode) != 0;\n\t\t\tboolean_t t_is_dir = S_ISDIR(ZTOI(tzp)->i_mode) != 0;\n\n\t\t\tif (s_is_dir != t_is_dir) {\n\t\t\t\terror = SET_ERROR(s_is_dir ? ENOTDIR : EISDIR);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (szp->z_id == tzp->z_id) {\n\t\t\terror = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else if (rflags & RENAME_EXCHANGE) {\n\t\t \n\t\terror = SET_ERROR(ENOENT);\n\t\tgoto out;\n\t}\n\n\t \n\tif (rflags & RENAME_WHITEOUT) {\n\t\t \n\t\tuint64_t wo_projid = ZFS_DEFAULT_PROJID;\n\n\t\terror = zfs_zaccess(sdzp, ACE_ADD_FILE, 0, B_FALSE, cr, mnt_ns);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!have_acl) {\n\t\t\terror = zfs_acl_ids_create(sdzp, 0, wo_vap, cr, NULL,\n\t\t\t    &acl_ids, mnt_ns);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\thave_acl = B_TRUE;\n\t\t}\n\n\t\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, wo_projid)) {\n\t\t\terror = SET_ERROR(EDQUOT);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, szp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_sa(tx, sdzp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_zap(tx, sdzp->z_id,\n\t    (rflags & RENAME_EXCHANGE) ? TRUE : FALSE, snm);\n\tdmu_tx_hold_zap(tx, tdzp->z_id, TRUE, tnm);\n\tif (sdzp != tdzp) {\n\t\tdmu_tx_hold_sa(tx, tdzp->z_sa_hdl, B_FALSE);\n\t\tzfs_sa_upgrade_txholds(tx, tdzp);\n\t}\n\tif (tzp) {\n\t\tdmu_tx_hold_sa(tx, tzp->z_sa_hdl, B_FALSE);\n\t\tzfs_sa_upgrade_txholds(tx, tzp);\n\t}\n\tif (rflags & RENAME_WHITEOUT) {\n\t\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t\t    ZFS_SA_BASE_ATTR_SIZE);\n\n\t\tdmu_tx_hold_zap(tx, sdzp->z_id, TRUE, snm);\n\t\tdmu_tx_hold_sa(tx, sdzp->z_sa_hdl, B_FALSE);\n\t\tif (!zfsvfs->z_use_sa &&\n\t\t    acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t\t    0, acl_ids.z_aclp->z_acl_bytes);\n\t\t}\n\t}\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\tzfs_sa_upgrade_txholds(tx, szp);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\tif (zl != NULL)\n\t\t\tzfs_rename_unlock(&zl);\n\t\tzfs_dirent_unlock(sdl);\n\t\tzfs_dirent_unlock(tdl);\n\n\t\tif (sdzp == tdzp)\n\t\t\trw_exit(&sdzp->z_name_lock);\n\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tzrele(szp);\n\t\t\tif (tzp)\n\t\t\t\tzrele(tzp);\n\t\t\tgoto top;\n\t\t}\n\t\tdmu_tx_abort(tx);\n\t\tzrele(szp);\n\t\tif (tzp)\n\t\t\tzrele(tzp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tszp->z_pflags |= ZFS_AV_MODIFIED;\n\tif (tdzp->z_pflags & ZFS_PROJINHERIT)\n\t\tszp->z_pflags |= ZFS_PROJINHERIT;\n\n\terror = sa_update(szp->z_sa_hdl, SA_ZPL_FLAGS(zfsvfs),\n\t    (void *)&szp->z_pflags, sizeof (uint64_t), tx);\n\tVERIFY0(error);\n\n\terror = zfs_link_destroy(sdl, szp, tx, ZRENAMING, NULL);\n\tif (error)\n\t\tgoto commit;\n\n\t \n\tif (tzp) {\n\t\tint tzflg = zflg;\n\n\t\tif (rflags & RENAME_EXCHANGE) {\n\t\t\t \n\t\t\ttzflg |= ZRENAMING;\n\n\t\t\ttzp->z_pflags |= ZFS_AV_MODIFIED;\n\t\t\tif (sdzp->z_pflags & ZFS_PROJINHERIT)\n\t\t\t\ttzp->z_pflags |= ZFS_PROJINHERIT;\n\n\t\t\terror = sa_update(tzp->z_sa_hdl, SA_ZPL_FLAGS(zfsvfs),\n\t\t\t    (void *)&tzp->z_pflags, sizeof (uint64_t), tx);\n\t\t\tASSERT0(error);\n\t\t}\n\t\terror = zfs_link_destroy(tdl, tzp, tx, tzflg, NULL);\n\t\tif (error)\n\t\t\tgoto commit_link_szp;\n\t}\n\n\t \n\terror = zfs_link_create(tdl, szp, tx, ZRENAMING);\n\tif (error) {\n\t\t \n\t\tASSERT3P(tzp, ==, NULL);\n\t\tgoto commit_link_tzp;\n\t}\n\n\tswitch (rflags & (RENAME_EXCHANGE | RENAME_WHITEOUT)) {\n\tcase RENAME_EXCHANGE:\n\t\terror = zfs_link_create(sdl, tzp, tx, ZRENAMING);\n\t\t \n\t\tASSERT0(error);\n\t\tif (error)\n\t\t\tgoto commit_unlink_td_szp;\n\t\tbreak;\n\tcase RENAME_WHITEOUT:\n\t\tzfs_mknode(sdzp, wo_vap, tx, cr, 0, &wzp, &acl_ids);\n\t\terror = zfs_link_create(sdl, wzp, tx, ZNEW);\n\t\tif (error) {\n\t\t\tzfs_znode_delete(wzp, tx);\n\t\t\tremove_inode_hash(ZTOI(wzp));\n\t\t\tgoto commit_unlink_td_szp;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tswitch (rflags & (RENAME_EXCHANGE | RENAME_WHITEOUT)) {\n\tcase RENAME_EXCHANGE:\n\t\tzfs_log_rename_exchange(zilog, tx,\n\t\t    (flags & FIGNORECASE ? TX_CI : 0), sdzp, sdl->dl_name,\n\t\t    tdzp, tdl->dl_name, szp);\n\t\tbreak;\n\tcase RENAME_WHITEOUT:\n\t\tzfs_log_rename_whiteout(zilog, tx,\n\t\t    (flags & FIGNORECASE ? TX_CI : 0), sdzp, sdl->dl_name,\n\t\t    tdzp, tdl->dl_name, szp, wzp);\n\t\tbreak;\n\tdefault:\n\t\tASSERT0(rflags & ~RENAME_NOREPLACE);\n\t\tzfs_log_rename(zilog, tx, (flags & FIGNORECASE ? TX_CI : 0),\n\t\t    sdzp, sdl->dl_name, tdzp, tdl->dl_name, szp);\n\t\tbreak;\n\t}\n\ncommit:\n\tdmu_tx_commit(tx);\nout:\n\tif (have_acl)\n\t\tzfs_acl_ids_free(&acl_ids);\n\n\tzfs_znode_update_vfs(sdzp);\n\tif (sdzp == tdzp)\n\t\trw_exit(&sdzp->z_name_lock);\n\n\tif (sdzp != tdzp)\n\t\tzfs_znode_update_vfs(tdzp);\n\n\tzfs_znode_update_vfs(szp);\n\tzrele(szp);\n\tif (wzp) {\n\t\tzfs_znode_update_vfs(wzp);\n\t\tzrele(wzp);\n\t}\n\tif (tzp) {\n\t\tzfs_znode_update_vfs(tzp);\n\t\tzrele(tzp);\n\t}\n\n\tif (zl != NULL)\n\t\tzfs_rename_unlock(&zl);\n\n\tzfs_dirent_unlock(sdl);\n\tzfs_dirent_unlock(tdl);\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n\n\t \ncommit_unlink_td_szp:\n\tVERIFY0(zfs_link_destroy(tdl, szp, tx, ZRENAMING, NULL));\ncommit_link_tzp:\n\tif (tzp) {\n\t\tif (zfs_link_create(tdl, tzp, tx, ZRENAMING))\n\t\t\tVERIFY0(zfs_drop_nlink(tzp, tx, NULL));\n\t}\ncommit_link_szp:\n\tif (zfs_link_create(sdl, szp, tx, ZRENAMING))\n\t\tVERIFY0(zfs_drop_nlink(szp, tx, NULL));\n\tgoto commit;\n}\n\n \nint\nzfs_symlink(znode_t *dzp, char *name, vattr_t *vap, char *link,\n    znode_t **zpp, cred_t *cr, int flags, zidmap_t *mnt_ns)\n{\n\tznode_t\t\t*zp;\n\tzfs_dirlock_t\t*dl;\n\tdmu_tx_t\t*tx;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzilog_t\t\t*zilog;\n\tuint64_t\tlen = strlen(link);\n\tint\t\terror;\n\tint\t\tzflg = ZNEW;\n\tzfs_acl_ids_t\tacl_ids;\n\tboolean_t\tfuid_dirtied;\n\tuint64_t\ttxtype = TX_SYMLINK;\n\tboolean_t\twaited = B_FALSE;\n\n\tASSERT(S_ISLNK(vap->va_mode));\n\n\tif (name == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif (zfsvfs->z_utf8 && u8_validate(name, strlen(name),\n\t    NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\tif (flags & FIGNORECASE)\n\t\tzflg |= ZCILOOK;\n\n\tif (len > MAXPATHLEN) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t}\n\n\tif ((error = zfs_acl_ids_create(dzp, 0,\n\t    vap, cr, NULL, &acl_ids, mnt_ns)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\ntop:\n\t*zpp = NULL;\n\n\t \n\terror = zfs_dirent_lock(&dl, dzp, name, &zp, zflg, NULL, NULL);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif ((error = zfs_zaccess(dzp, ACE_ADD_FILE, 0, B_FALSE, cr, mnt_ns))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_dirent_unlock(dl);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, ZFS_DEFAULT_PROJID)) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_dirent_unlock(dl);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0, MAX(1, len));\n\tdmu_tx_hold_zap(tx, dzp->z_id, TRUE, name);\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE + len);\n\tdmu_tx_hold_sa(tx, dzp->z_sa_hdl, B_FALSE);\n\tif (!zfsvfs->z_use_sa && acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,\n\t\t    acl_ids.z_aclp->z_acl_bytes);\n\t}\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\tzfs_dirent_unlock(dl);\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tgoto top;\n\t\t}\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tzfs_mknode(dzp, vap, tx, cr, 0, &zp, &acl_ids);\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tmutex_enter(&zp->z_lock);\n\tif (zp->z_is_sa)\n\t\terror = sa_update(zp->z_sa_hdl, SA_ZPL_SYMLINK(zfsvfs),\n\t\t    link, len, tx);\n\telse\n\t\tzfs_sa_symlink(zp, link, len, tx);\n\tmutex_exit(&zp->z_lock);\n\n\tzp->z_size = len;\n\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_SIZE(zfsvfs),\n\t    &zp->z_size, sizeof (zp->z_size), tx);\n\t \n\terror = zfs_link_create(dl, zp, tx, ZNEW);\n\tif (error != 0) {\n\t\tzfs_znode_delete(zp, tx);\n\t\tremove_inode_hash(ZTOI(zp));\n\t} else {\n\t\tif (flags & FIGNORECASE)\n\t\t\ttxtype |= TX_CI;\n\t\tzfs_log_symlink(zilog, tx, txtype, dzp, zp, name, link);\n\n\t\tzfs_znode_update_vfs(dzp);\n\t\tzfs_znode_update_vfs(zp);\n\t}\n\n\tzfs_acl_ids_free(&acl_ids);\n\n\tdmu_tx_commit(tx);\n\n\tzfs_dirent_unlock(dl);\n\n\tif (error == 0) {\n\t\t*zpp = zp;\n\n\t\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\t\tzil_commit(zilog, 0);\n\t} else {\n\t\tzrele(zp);\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_readlink(struct inode *ip, zfs_uio_t *uio, cred_t *cr)\n{\n\t(void) cr;\n\tznode_t\t\t*zp = ITOZ(ip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(ip);\n\tint\t\terror;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tmutex_enter(&zp->z_lock);\n\tif (zp->z_is_sa)\n\t\terror = sa_lookup_uio(zp->z_sa_hdl,\n\t\t    SA_ZPL_SYMLINK(zfsvfs), uio);\n\telse\n\t\terror = zfs_sa_readlink(zp, uio);\n\tmutex_exit(&zp->z_lock);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_link(znode_t *tdzp, znode_t *szp, char *name, cred_t *cr,\n    int flags)\n{\n\tstruct inode *sip = ZTOI(szp);\n\tznode_t\t\t*tzp;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(tdzp);\n\tzilog_t\t\t*zilog;\n\tzfs_dirlock_t\t*dl;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tint\t\tzf = ZNEW;\n\tuint64_t\tparent;\n\tuid_t\t\towner;\n\tboolean_t\twaited = B_FALSE;\n\tboolean_t\tis_tmpfile = 0;\n\tuint64_t\ttxg;\n#ifdef HAVE_TMPFILE\n\tis_tmpfile = (sip->i_nlink == 0 && (sip->i_state & I_LINKABLE));\n#endif\n\tASSERT(S_ISDIR(ZTOI(tdzp)->i_mode));\n\n\tif (name == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, tdzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\t \n\tif (S_ISDIR(sip->i_mode)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif ((error = zfs_verify_zp(szp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (tdzp->z_pflags & ZFS_PROJINHERIT &&\n\t    tdzp->z_projid != szp->z_projid) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\t \n\tif (sip->i_sb != ZTOI(tdzp)->i_sb || zfsctl_is_node(sip)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\t \n\n\tif ((error = sa_lookup(szp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs),\n\t    &parent, sizeof (uint64_t))) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tif (parent == zfsvfs->z_shares_dir) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(name,\n\t    strlen(name), NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\tif (flags & FIGNORECASE)\n\t\tzf |= ZCILOOK;\n\n\t \n\tif ((szp->z_pflags & ZFS_XATTR) != (tdzp->z_pflags & ZFS_XATTR)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\towner = zfs_fuid_map_id(zfsvfs, KUID_TO_SUID(sip->i_uid),\n\t    cr, ZFS_OWNER);\n\tif (owner != crgetuid(cr) && secpolicy_basic_link(cr) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif ((error = zfs_zaccess(tdzp, ACE_ADD_FILE, 0, B_FALSE, cr,\n\t    zfs_init_idmap))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\ntop:\n\t \n\terror = zfs_dirent_lock(&dl, tdzp, name, &tzp, zf, NULL, NULL);\n\tif (error) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, szp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_zap(tx, tdzp->z_id, TRUE, name);\n\tif (is_tmpfile)\n\t\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\n\tzfs_sa_upgrade_txholds(tx, szp);\n\tzfs_sa_upgrade_txholds(tx, tdzp);\n\terror = dmu_tx_assign(tx, (waited ? TXG_NOTHROTTLE : 0) | TXG_NOWAIT);\n\tif (error) {\n\t\tzfs_dirent_unlock(dl);\n\t\tif (error == ERESTART) {\n\t\t\twaited = B_TRUE;\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tgoto top;\n\t\t}\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\t \n\tif (is_tmpfile)\n\t\tszp->z_unlinked = B_FALSE;\n\terror = zfs_link_create(dl, szp, tx, 0);\n\n\tif (error == 0) {\n\t\tuint64_t txtype = TX_LINK;\n\t\t \n\t\tif (is_tmpfile) {\n\t\t\tVERIFY(zap_remove_int(zfsvfs->z_os,\n\t\t\t    zfsvfs->z_unlinkedobj, szp->z_id, tx) == 0);\n\t\t} else {\n\t\t\tif (flags & FIGNORECASE)\n\t\t\t\ttxtype |= TX_CI;\n\t\t\tzfs_log_link(zilog, tx, txtype, tdzp, szp, name);\n\t\t}\n\t} else if (is_tmpfile) {\n\t\t \n\t\tszp->z_unlinked = B_TRUE;\n\t}\n\ttxg = dmu_tx_get_txg(tx);\n\tdmu_tx_commit(tx);\n\n\tzfs_dirent_unlock(dl);\n\n\tif (!is_tmpfile && zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tif (is_tmpfile && zfsvfs->z_os->os_sync != ZFS_SYNC_DISABLED)\n\t\ttxg_wait_synced(dmu_objset_pool(zfsvfs->z_os), txg);\n\n\tzfs_znode_update_vfs(tdzp);\n\tzfs_znode_update_vfs(szp);\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nstatic void\nzfs_putpage_sync_commit_cb(void *arg)\n{\n\tstruct page *pp = arg;\n\n\tClearPageError(pp);\n\tend_page_writeback(pp);\n}\n\nstatic void\nzfs_putpage_async_commit_cb(void *arg)\n{\n\tstruct page *pp = arg;\n\tznode_t *zp = ITOZ(pp->mapping->host);\n\n\tClearPageError(pp);\n\tend_page_writeback(pp);\n\tatomic_dec_32(&zp->z_async_writes_cnt);\n}\n\n \nint\nzfs_putpage(struct inode *ip, struct page *pp, struct writeback_control *wbc,\n    boolean_t for_sync)\n{\n\tznode_t\t\t*zp = ITOZ(ip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(ip);\n\tloff_t\t\toffset;\n\tloff_t\t\tpgoff;\n\tunsigned int\tpglen;\n\tdmu_tx_t\t*tx;\n\tcaddr_t\t\tva;\n\tint\t\terr = 0;\n\tuint64_t\tmtime[2], ctime[2];\n\tinode_timespec_t tmp_ctime;\n\tsa_bulk_attr_t\tbulk[3];\n\tint\t\tcnt = 0;\n\tstruct address_space *mapping;\n\n\tif ((err = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (err);\n\n\tASSERT(PageLocked(pp));\n\n\tpgoff = page_offset(pp);\t \n\toffset = i_size_read(ip);\t \n\tpglen = MIN(PAGE_SIZE,\t\t \n\t    P2ROUNDUP(offset, PAGE_SIZE)-pgoff);\n\n\t \n\tif (pgoff >= offset) {\n\t\tunlock_page(pp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tif (pgoff + pglen > offset)\n\t\tpglen = offset - pgoff;\n\n#if 0\n\t \n\tif (zfs_id_overblockquota(zfsvfs, DMU_USERUSED_OBJECT,\n\t    KUID_TO_SUID(ip->i_uid)) ||\n\t    zfs_id_overblockquota(zfsvfs, DMU_GROUPUSED_OBJECT,\n\t    KGID_TO_SGID(ip->i_gid)) ||\n\t    (zp->z_projid != ZFS_DEFAULT_PROJID &&\n\t    zfs_id_overblockquota(zfsvfs, DMU_PROJECTUSED_OBJECT,\n\t    zp->z_projid))) {\n\t\terr = EDQUOT;\n\t}\n#endif\n\n\t \n\tmapping = pp->mapping;\n\tredirty_page_for_writepage(wbc, pp);\n\tunlock_page(pp);\n\n\tzfs_locked_range_t *lr = zfs_rangelock_enter(&zp->z_rangelock,\n\t    pgoff, pglen, RL_WRITER);\n\tlock_page(pp);\n\n\t \n\tif (unlikely((mapping != pp->mapping) || !PageDirty(pp))) {\n\t\tunlock_page(pp);\n\t\tzfs_rangelock_exit(lr);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tif (PageWriteback(pp)) {\n\t\tunlock_page(pp);\n\t\tzfs_rangelock_exit(lr);\n\n\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t \n\t\t\tif (atomic_load_32(&zp->z_async_writes_cnt) > 0) {\n\t\t\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\t\t\t}\n\n\t\t\tif (PageWriteback(pp))\n#ifdef HAVE_PAGEMAP_FOLIO_WAIT_BIT\n\t\t\t\tfolio_wait_bit(page_folio(pp), PG_writeback);\n#else\n\t\t\t\twait_on_page_bit(pp, PG_writeback);\n#endif\n\t\t}\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\tif (!clear_page_dirty_for_io(pp)) {\n\t\tunlock_page(pp);\n\t\tzfs_rangelock_exit(lr);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\t \n\twbc->pages_skipped--;\n\tif (!for_sync)\n\t\tatomic_inc_32(&zp->z_async_writes_cnt);\n\tset_page_writeback(pp);\n\tunlock_page(pp);\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_write(tx, zp->z_id, pgoff, pglen);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\n\terr = dmu_tx_assign(tx, TXG_NOWAIT);\n\tif (err != 0) {\n\t\tif (err == ERESTART)\n\t\t\tdmu_tx_wait(tx);\n\n\t\tdmu_tx_abort(tx);\n#ifdef HAVE_VFS_FILEMAP_DIRTY_FOLIO\n\t\tfilemap_dirty_folio(page_mapping(pp), page_folio(pp));\n#else\n\t\t__set_page_dirty_nobuffers(pp);\n#endif\n\t\tClearPageError(pp);\n\t\tend_page_writeback(pp);\n\t\tif (!for_sync)\n\t\t\tatomic_dec_32(&zp->z_async_writes_cnt);\n\t\tzfs_rangelock_exit(lr);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (err);\n\t}\n\n\tva = kmap(pp);\n\tASSERT3U(pglen, <=, PAGE_SIZE);\n\tdmu_write(zfsvfs->z_os, zp->z_id, pgoff, pglen, va, tx);\n\tkunmap(pp);\n\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, 8);\n\n\t \n\tZFS_TIME_ENCODE(&ip->i_mtime, mtime);\n\ttmp_ctime = zpl_inode_get_ctime(ip);\n\tZFS_TIME_ENCODE(&tmp_ctime, ctime);\n\tzp->z_atime_dirty = B_FALSE;\n\tzp->z_seq++;\n\n\terr = sa_bulk_update(zp->z_sa_hdl, bulk, cnt, tx);\n\n\tzfs_log_write(zfsvfs->z_log, tx, TX_WRITE, zp, pgoff, pglen, 0,\n\t    for_sync ? zfs_putpage_sync_commit_cb :\n\t    zfs_putpage_async_commit_cb, pp);\n\n\tdmu_tx_commit(tx);\n\n\tzfs_rangelock_exit(lr);\n\n\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t \n\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\t} else if (!for_sync && atomic_load_32(&zp->z_sync_writes_cnt) > 0) {\n\t\t \n\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\t}\n\n\tdataset_kstats_update_write_kstats(&zfsvfs->z_kstat, pglen);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (err);\n}\n\n \nint\nzfs_dirty_inode(struct inode *ip, int flags)\n{\n\tznode_t\t\t*zp = ITOZ(ip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(ip);\n\tdmu_tx_t\t*tx;\n\tuint64_t\tmode, atime[2], mtime[2], ctime[2];\n\tinode_timespec_t tmp_ctime;\n\tsa_bulk_attr_t\tbulk[4];\n\tint\t\terror = 0;\n\tint\t\tcnt = 0;\n\n\tif (zfs_is_readonly(zfsvfs) || dmu_objset_is_snapshot(zfsvfs->z_os))\n\t\treturn (0);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n#ifdef I_DIRTY_TIME\n\t \n\tif (flags == I_DIRTY_TIME) {\n\t\tzp->z_atime_dirty = B_TRUE;\n\t\tgoto out;\n\t}\n#endif\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tgoto out;\n\t}\n\n\tmutex_enter(&zp->z_lock);\n\tzp->z_atime_dirty = B_FALSE;\n\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_MODE(zfsvfs), NULL, &mode, 8);\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_ATIME(zfsvfs), NULL, &atime, 16);\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, cnt, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\n\t \n\tZFS_TIME_ENCODE(&ip->i_atime, atime);\n\tZFS_TIME_ENCODE(&ip->i_mtime, mtime);\n\ttmp_ctime = zpl_inode_get_ctime(ip);\n\tZFS_TIME_ENCODE(&tmp_ctime, ctime);\n\tmode = ip->i_mode;\n\n\tzp->z_mode = mode;\n\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, cnt, tx);\n\tmutex_exit(&zp->z_lock);\n\n\tdmu_tx_commit(tx);\nout:\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nvoid\nzfs_inactive(struct inode *ip)\n{\n\tznode_t\t*zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tuint64_t atime[2];\n\tint error;\n\tint need_unlock = 0;\n\n\t \n\tif (!RW_WRITE_HELD(&zfsvfs->z_teardown_inactive_lock)) {\n\t\tneed_unlock = 1;\n\t\trw_enter(&zfsvfs->z_teardown_inactive_lock, RW_READER);\n\t}\n\tif (zp->z_sa_hdl == NULL) {\n\t\tif (need_unlock)\n\t\t\trw_exit(&zfsvfs->z_teardown_inactive_lock);\n\t\treturn;\n\t}\n\n\tif (zp->z_atime_dirty && zp->z_unlinked == B_FALSE) {\n\t\tdmu_tx_t *tx = dmu_tx_create(zfsvfs->z_os);\n\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t\tzfs_sa_upgrade_txholds(tx, zp);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tdmu_tx_abort(tx);\n\t\t} else {\n\t\t\tZFS_TIME_ENCODE(&ip->i_atime, atime);\n\t\t\tmutex_enter(&zp->z_lock);\n\t\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_ATIME(zfsvfs),\n\t\t\t    (void *)&atime, sizeof (atime), tx);\n\t\t\tzp->z_atime_dirty = B_FALSE;\n\t\t\tmutex_exit(&zp->z_lock);\n\t\t\tdmu_tx_commit(tx);\n\t\t}\n\t}\n\n\tzfs_zinactive(zp);\n\tif (need_unlock)\n\t\trw_exit(&zfsvfs->z_teardown_inactive_lock);\n}\n\n \nstatic int\nzfs_fillpage(struct inode *ip, struct page *pp)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tloff_t i_size = i_size_read(ip);\n\tu_offset_t io_off = page_offset(pp);\n\tsize_t io_len = PAGE_SIZE;\n\n\tASSERT3U(io_off, <, i_size);\n\n\tif (io_off + io_len > i_size)\n\t\tio_len = i_size - io_off;\n\n\tvoid *va = kmap(pp);\n\tint error = dmu_read(zfsvfs->z_os, ITOZ(ip)->z_id, io_off,\n\t    io_len, va, DMU_READ_PREFETCH);\n\tif (io_len != PAGE_SIZE)\n\t\tmemset((char *)va + io_len, 0, PAGE_SIZE - io_len);\n\tkunmap(pp);\n\n\tif (error) {\n\t\t \n\t\tif (error == ECKSUM)\n\t\t\terror = SET_ERROR(EIO);\n\n\t\tSetPageError(pp);\n\t\tClearPageUptodate(pp);\n\t} else {\n\t\tClearPageError(pp);\n\t\tSetPageUptodate(pp);\n\t}\n\n\treturn (error);\n}\n\n \nint\nzfs_getpage(struct inode *ip, struct page *pp)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tznode_t *zp = ITOZ(ip);\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = zfs_fillpage(ip, pp);\n\tif (error == 0)\n\t\tdataset_kstats_update_read_kstats(&zfsvfs->z_kstat, PAGE_SIZE);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n \nint\nzfs_map(struct inode *ip, offset_t off, caddr_t *addrp, size_t len,\n    unsigned long vm_flags)\n{\n\t(void) addrp;\n\tznode_t  *zp = ITOZ(ip);\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((vm_flags & VM_WRITE) && (vm_flags & VM_SHARED) &&\n\t    (zp->z_pflags & (ZFS_IMMUTABLE | ZFS_READONLY | ZFS_APPENDONLY))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif ((vm_flags & (VM_READ | VM_EXEC)) &&\n\t    (zp->z_pflags & ZFS_AV_QUARANTINED)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EACCES));\n\t}\n\n\tif (off < 0 || len > MAXOFFSET_T - off) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n \nint\nzfs_space(znode_t *zp, int cmd, flock64_t *bfp, int flag,\n    offset_t offset, cred_t *cr)\n{\n\t(void) offset;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zp);\n\tuint64_t\toff, len;\n\tint\t\terror;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (cmd != F_FREESP) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (zfs_is_readonly(zfsvfs)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\tif (bfp->l_len < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif ((error = zfs_zaccess(zp, ACE_WRITE_DATA, 0, B_FALSE, cr,\n\t    zfs_init_idmap))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\toff = bfp->l_start;\n\tlen = bfp->l_len;  \n\n\terror = zfs_freesp(zp, off, len, flag, TRUE);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nint\nzfs_fid(struct inode *ip, fid_t *fidp)\n{\n\tznode_t\t\t*zp = ITOZ(ip);\n\tzfsvfs_t\t*zfsvfs = ITOZSB(ip);\n\tuint32_t\tgen;\n\tuint64_t\tgen64;\n\tuint64_t\tobject = zp->z_id;\n\tzfid_short_t\t*zfid;\n\tint\t\tsize, i, error;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (fidp->fid_len < SHORT_FID_LEN) {\n\t\tfidp->fid_len = SHORT_FID_LEN;\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENOSPC));\n\t}\n\n\tif ((error = zfs_verify_zp(zp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(zfsvfs),\n\t    &gen64, sizeof (uint64_t))) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tgen = (uint32_t)gen64;\n\n\tsize = SHORT_FID_LEN;\n\n\tzfid = (zfid_short_t *)fidp;\n\n\tzfid->zf_len = size;\n\n\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\tzfid->zf_object[i] = (uint8_t)(object >> (8 * i));\n\n\t \n\tif (gen == 0)\n\t\tgen = 1;\n\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\tzfid->zf_gen[i] = (uint8_t)(gen >> (8 * i));\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zfs_open);\nEXPORT_SYMBOL(zfs_close);\nEXPORT_SYMBOL(zfs_lookup);\nEXPORT_SYMBOL(zfs_create);\nEXPORT_SYMBOL(zfs_tmpfile);\nEXPORT_SYMBOL(zfs_remove);\nEXPORT_SYMBOL(zfs_mkdir);\nEXPORT_SYMBOL(zfs_rmdir);\nEXPORT_SYMBOL(zfs_readdir);\nEXPORT_SYMBOL(zfs_getattr_fast);\nEXPORT_SYMBOL(zfs_setattr);\nEXPORT_SYMBOL(zfs_rename);\nEXPORT_SYMBOL(zfs_symlink);\nEXPORT_SYMBOL(zfs_readlink);\nEXPORT_SYMBOL(zfs_link);\nEXPORT_SYMBOL(zfs_inactive);\nEXPORT_SYMBOL(zfs_space);\nEXPORT_SYMBOL(zfs_fid);\nEXPORT_SYMBOL(zfs_getpage);\nEXPORT_SYMBOL(zfs_putpage);\nEXPORT_SYMBOL(zfs_dirty_inode);\nEXPORT_SYMBOL(zfs_map);\n\n \nmodule_param(zfs_delete_blocks, ulong, 0644);\nMODULE_PARM_DESC(zfs_delete_blocks, \"Delete files larger than N blocks async\");\n\n \nmodule_param(zfs_bclone_enabled, uint, 0644);\nMODULE_PARM_DESC(zfs_bclone_enabled, \"Enable block cloning\");\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}