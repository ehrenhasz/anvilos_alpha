{
  "module_name": "zpl_ctldir.c",
  "hash_id": "e48ff2ddb8476e0ef5bade8b9b7ec82bc11f20d2a03a9413e733e48ed0c92ce2",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_ctldir.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zpl.h>\n#include <sys/dmu.h>\n#include <sys/dsl_dataset.h>\n#include <sys/zap.h>\n\n \nstatic int\nzpl_common_open(struct inode *ip, struct file *filp)\n{\n\tif (blk_mode_is_open_write(filp->f_mode))\n\t\treturn (-EACCES);\n\n\treturn (generic_file_open(ip, filp));\n}\n\n \nstatic int\nzpl_root_iterate(struct file *filp, zpl_dir_context_t *ctx)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(file_inode(filp));\n\tint error = 0;\n\n\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (!zpl_dir_emit_dots(filp, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos == 2) {\n\t\tif (!zpl_dir_emit(ctx, ZFS_SNAPDIR_NAME,\n\t\t    strlen(ZFS_SNAPDIR_NAME), ZFSCTL_INO_SNAPDIR, DT_DIR))\n\t\t\tgoto out;\n\n\t\tctx->pos++;\n\t}\n\n\tif (ctx->pos == 3) {\n\t\tif (!zpl_dir_emit(ctx, ZFS_SHAREDIR_NAME,\n\t\t    strlen(ZFS_SHAREDIR_NAME), ZFSCTL_INO_SHARES, DT_DIR))\n\t\t\tgoto out;\n\n\t\tctx->pos++;\n\t}\nout:\n\tzpl_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\n#if !defined(HAVE_VFS_ITERATE) && !defined(HAVE_VFS_ITERATE_SHARED)\nstatic int\nzpl_root_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tzpl_dir_context_t ctx =\n\t    ZPL_DIR_CONTEXT_INIT(dirent, filldir, filp->f_pos);\n\tint error;\n\n\terror = zpl_root_iterate(filp, &ctx);\n\tfilp->f_pos = ctx.pos;\n\n\treturn (error);\n}\n#endif  \n\n \nstatic int\n#ifdef HAVE_IDMAP_IOPS_GETATTR\nzpl_root_getattr_impl(struct mnt_idmap *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#elif defined(HAVE_USERNS_IOPS_GETATTR)\nzpl_root_getattr_impl(struct user_namespace *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#else\nzpl_root_getattr_impl(const struct path *path, struct kstat *stat,\n    u32 request_mask, unsigned int query_flags)\n#endif\n{\n\t(void) request_mask, (void) query_flags;\n\tstruct inode *ip = path->dentry->d_inode;\n\n#if (defined(HAVE_USERNS_IOPS_GETATTR) || defined(HAVE_IDMAP_IOPS_GETATTR))\n#ifdef HAVE_GENERIC_FILLATTR_USERNS\n\tgeneric_fillattr(user_ns, ip, stat);\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP)\n\tgeneric_fillattr(user_ns, ip, stat);\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP_REQMASK)\n\tgeneric_fillattr(user_ns, request_mask, ip, stat);\n#else\n\t(void) user_ns;\n#endif\n#else\n\tgeneric_fillattr(ip, stat);\n#endif\n\tstat->atime = current_time(ip);\n\n\treturn (0);\n}\nZPL_GETATTR_WRAPPER(zpl_root_getattr);\n\nstatic struct dentry *\nzpl_root_lookup(struct inode *dip, struct dentry *dentry, unsigned int flags)\n{\n\tcred_t *cr = CRED();\n\tstruct inode *ip;\n\tint error;\n\n\tcrhold(cr);\n\terror = -zfsctl_root_lookup(dip, dname(dentry), &ip, 0, cr, NULL, NULL);\n\tASSERT3S(error, <=, 0);\n\tcrfree(cr);\n\n\tif (error) {\n\t\tif (error == -ENOENT)\n\t\t\treturn (d_splice_alias(NULL, dentry));\n\t\telse\n\t\t\treturn (ERR_PTR(error));\n\t}\n\n\treturn (d_splice_alias(ip, dentry));\n}\n\n \nconst struct file_operations zpl_fops_root = {\n\t.open\t\t= zpl_common_open,\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n#ifdef HAVE_VFS_ITERATE_SHARED\n\t.iterate_shared\t= zpl_root_iterate,\n#elif defined(HAVE_VFS_ITERATE)\n\t.iterate\t= zpl_root_iterate,\n#else\n\t.readdir\t= zpl_root_readdir,\n#endif\n};\n\nconst struct inode_operations zpl_ops_root = {\n\t.lookup\t\t= zpl_root_lookup,\n\t.getattr\t= zpl_root_getattr,\n};\n\nstatic struct vfsmount *\nzpl_snapdir_automount(struct path *path)\n{\n\tint error;\n\n\terror = -zfsctl_snapshot_mount(path, 0);\n\tif (error)\n\t\treturn (ERR_PTR(error));\n\n\t \n\treturn (NULL);\n}\n\n \nstatic int\n#ifdef HAVE_D_REVALIDATE_NAMEIDATA\nzpl_snapdir_revalidate(struct dentry *dentry, struct nameidata *i)\n#else\nzpl_snapdir_revalidate(struct dentry *dentry, unsigned int flags)\n#endif\n{\n\treturn (!!dentry->d_inode);\n}\n\nstatic dentry_operations_t zpl_dops_snapdirs = {\n \n\t.d_automount\t= zpl_snapdir_automount,\n\t.d_revalidate\t= zpl_snapdir_revalidate,\n};\n\nstatic struct dentry *\nzpl_snapdir_lookup(struct inode *dip, struct dentry *dentry,\n    unsigned int flags)\n{\n\tfstrans_cookie_t cookie;\n\tcred_t *cr = CRED();\n\tstruct inode *ip = NULL;\n\tint error;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfsctl_snapdir_lookup(dip, dname(dentry), &ip,\n\t    0, cr, NULL, NULL);\n\tASSERT3S(error, <=, 0);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error && error != -ENOENT)\n\t\treturn (ERR_PTR(error));\n\n\tASSERT(error == 0 || ip == NULL);\n\td_clear_d_op(dentry);\n\td_set_d_op(dentry, &zpl_dops_snapdirs);\n\tdentry->d_flags |= DCACHE_NEED_AUTOMOUNT;\n\n\treturn (d_splice_alias(ip, dentry));\n}\n\nstatic int\nzpl_snapdir_iterate(struct file *filp, zpl_dir_context_t *ctx)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(file_inode(filp));\n\tfstrans_cookie_t cookie;\n\tchar snapname[MAXNAMELEN];\n\tboolean_t case_conflict;\n\tuint64_t id, pos;\n\tint error = 0;\n\n\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\tcookie = spl_fstrans_mark();\n\n\tif (!zpl_dir_emit_dots(filp, ctx))\n\t\tgoto out;\n\n\t \n\tpos = (ctx->pos == 2 ? 0 : ctx->pos);\n\twhile (error == 0) {\n\t\tdsl_pool_config_enter(dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\terror = -dmu_snapshot_list_next(zfsvfs->z_os, MAXNAMELEN,\n\t\t    snapname, &id, &pos, &case_conflict);\n\t\tdsl_pool_config_exit(dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!zpl_dir_emit(ctx, snapname, strlen(snapname),\n\t\t    ZFSCTL_INO_SHARES - id, DT_DIR))\n\t\t\tgoto out;\n\n\t\tctx->pos = pos;\n\t}\nout:\n\tspl_fstrans_unmark(cookie);\n\tzpl_exit(zfsvfs, FTAG);\n\n\tif (error == -ENOENT)\n\t\treturn (0);\n\n\treturn (error);\n}\n\n#if !defined(HAVE_VFS_ITERATE) && !defined(HAVE_VFS_ITERATE_SHARED)\nstatic int\nzpl_snapdir_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tzpl_dir_context_t ctx =\n\t    ZPL_DIR_CONTEXT_INIT(dirent, filldir, filp->f_pos);\n\tint error;\n\n\terror = zpl_snapdir_iterate(filp, &ctx);\n\tfilp->f_pos = ctx.pos;\n\n\treturn (error);\n}\n#endif  \n\nstatic int\n#ifdef HAVE_IOPS_RENAME_USERNS\nzpl_snapdir_rename2(struct user_namespace *user_ns, struct inode *sdip,\n    struct dentry *sdentry, struct inode *tdip, struct dentry *tdentry,\n    unsigned int flags)\n#elif defined(HAVE_IOPS_RENAME_IDMAP)\nzpl_snapdir_rename2(struct mnt_idmap *user_ns, struct inode *sdip,\n    struct dentry *sdentry, struct inode *tdip, struct dentry *tdentry,\n    unsigned int flags)\n#else\nzpl_snapdir_rename2(struct inode *sdip, struct dentry *sdentry,\n    struct inode *tdip, struct dentry *tdentry, unsigned int flags)\n#endif\n{\n\tcred_t *cr = CRED();\n\tint error;\n\n\t \n\tif (flags)\n\t\treturn (-EINVAL);\n\n\tcrhold(cr);\n\terror = -zfsctl_snapdir_rename(sdip, dname(sdentry),\n\t    tdip, dname(tdentry), cr, 0);\n\tASSERT3S(error, <=, 0);\n\tcrfree(cr);\n\n\treturn (error);\n}\n\n#if (!defined(HAVE_RENAME_WANTS_FLAGS) && \\\n\t!defined(HAVE_IOPS_RENAME_USERNS) && \\\n\t!defined(HAVE_IOPS_RENAME_IDMAP))\nstatic int\nzpl_snapdir_rename(struct inode *sdip, struct dentry *sdentry,\n    struct inode *tdip, struct dentry *tdentry)\n{\n\treturn (zpl_snapdir_rename2(sdip, sdentry, tdip, tdentry, 0));\n}\n#endif\n\nstatic int\nzpl_snapdir_rmdir(struct inode *dip, struct dentry *dentry)\n{\n\tcred_t *cr = CRED();\n\tint error;\n\n\tcrhold(cr);\n\terror = -zfsctl_snapdir_remove(dip, dname(dentry), cr, 0);\n\tASSERT3S(error, <=, 0);\n\tcrfree(cr);\n\n\treturn (error);\n}\n\nstatic int\n#ifdef HAVE_IOPS_MKDIR_USERNS\nzpl_snapdir_mkdir(struct user_namespace *user_ns, struct inode *dip,\n    struct dentry *dentry, umode_t mode)\n#elif defined(HAVE_IOPS_MKDIR_IDMAP)\nzpl_snapdir_mkdir(struct mnt_idmap *user_ns, struct inode *dip,\n    struct dentry *dentry, umode_t mode)\n#else\nzpl_snapdir_mkdir(struct inode *dip, struct dentry *dentry, umode_t mode)\n#endif\n{\n\tcred_t *cr = CRED();\n\tvattr_t *vap;\n\tstruct inode *ip;\n\tint error;\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n#if (defined(HAVE_IOPS_MKDIR_USERNS) || defined(HAVE_IOPS_MKDIR_IDMAP))\n\tzpl_vap_init(vap, dip, mode | S_IFDIR, cr, user_ns);\n#else\n\tzpl_vap_init(vap, dip, mode | S_IFDIR, cr, zfs_init_idmap);\n#endif\n\n\terror = -zfsctl_snapdir_mkdir(dip, dname(dentry), vap, &ip, cr, 0);\n\tif (error == 0) {\n\t\td_clear_d_op(dentry);\n\t\td_set_d_op(dentry, &zpl_dops_snapdirs);\n\t\td_instantiate(dentry, ip);\n\t}\n\n\tkmem_free(vap, sizeof (vattr_t));\n\tASSERT3S(error, <=, 0);\n\tcrfree(cr);\n\n\treturn (error);\n}\n\n \nstatic int\n#ifdef HAVE_IDMAP_IOPS_GETATTR\nzpl_snapdir_getattr_impl(struct mnt_idmap *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#elif defined(HAVE_USERNS_IOPS_GETATTR)\nzpl_snapdir_getattr_impl(struct user_namespace *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#else\nzpl_snapdir_getattr_impl(const struct path *path, struct kstat *stat,\n    u32 request_mask, unsigned int query_flags)\n#endif\n{\n\t(void) request_mask, (void) query_flags;\n\tstruct inode *ip = path->dentry->d_inode;\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tint error;\n\n\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n#if (defined(HAVE_USERNS_IOPS_GETATTR) || defined(HAVE_IDMAP_IOPS_GETATTR))\n#ifdef HAVE_GENERIC_FILLATTR_USERNS\n\tgeneric_fillattr(user_ns, ip, stat);\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP)\n\tgeneric_fillattr(user_ns, ip, stat);\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP_REQMASK)\n\tgeneric_fillattr(user_ns, request_mask, ip, stat);\n#else\n\t(void) user_ns;\n#endif\n#else\n\tgeneric_fillattr(ip, stat);\n#endif\n\n\tstat->nlink = stat->size = 2;\n\n\tdsl_dataset_t *ds = dmu_objset_ds(zfsvfs->z_os);\n\tif (dsl_dataset_phys(ds)->ds_snapnames_zapobj != 0) {\n\t\tuint64_t snap_count;\n\t\tint err = zap_count(\n\t\t    dmu_objset_pool(ds->ds_objset)->dp_meta_objset,\n\t\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj, &snap_count);\n\t\tif (err != 0) {\n\t\t\tzpl_exit(zfsvfs, FTAG);\n\t\t\treturn (-err);\n\t\t}\n\t\tstat->nlink += snap_count;\n\t}\n\n\tstat->ctime = stat->mtime = dmu_objset_snap_cmtime(zfsvfs->z_os);\n\tstat->atime = current_time(ip);\n\tzpl_exit(zfsvfs, FTAG);\n\n\treturn (0);\n}\nZPL_GETATTR_WRAPPER(zpl_snapdir_getattr);\n\n \nconst struct file_operations zpl_fops_snapdir = {\n\t.open\t\t= zpl_common_open,\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n#ifdef HAVE_VFS_ITERATE_SHARED\n\t.iterate_shared\t= zpl_snapdir_iterate,\n#elif defined(HAVE_VFS_ITERATE)\n\t.iterate\t= zpl_snapdir_iterate,\n#else\n\t.readdir\t= zpl_snapdir_readdir,\n#endif\n\n};\n\n \nconst struct inode_operations zpl_ops_snapdir = {\n\t.lookup\t\t= zpl_snapdir_lookup,\n\t.getattr\t= zpl_snapdir_getattr,\n#if (defined(HAVE_RENAME_WANTS_FLAGS) || \\\n\tdefined(HAVE_IOPS_RENAME_USERNS) || \\\n\tdefined(HAVE_IOPS_RENAME_IDMAP))\n\t.rename\t\t= zpl_snapdir_rename2,\n#else\n\t.rename\t\t= zpl_snapdir_rename,\n#endif\n\t.rmdir\t\t= zpl_snapdir_rmdir,\n\t.mkdir\t\t= zpl_snapdir_mkdir,\n};\n\nstatic struct dentry *\nzpl_shares_lookup(struct inode *dip, struct dentry *dentry,\n    unsigned int flags)\n{\n\tfstrans_cookie_t cookie;\n\tcred_t *cr = CRED();\n\tstruct inode *ip = NULL;\n\tint error;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfsctl_shares_lookup(dip, dname(dentry), &ip,\n\t    0, cr, NULL, NULL);\n\tASSERT3S(error, <=, 0);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error) {\n\t\tif (error == -ENOENT)\n\t\t\treturn (d_splice_alias(NULL, dentry));\n\t\telse\n\t\t\treturn (ERR_PTR(error));\n\t}\n\n\treturn (d_splice_alias(ip, dentry));\n}\n\nstatic int\nzpl_shares_iterate(struct file *filp, zpl_dir_context_t *ctx)\n{\n\tfstrans_cookie_t cookie;\n\tcred_t *cr = CRED();\n\tzfsvfs_t *zfsvfs = ITOZSB(file_inode(filp));\n\tznode_t *dzp;\n\tint error = 0;\n\n\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\tcookie = spl_fstrans_mark();\n\n\tif (zfsvfs->z_shares_dir == 0) {\n\t\tzpl_dir_emit_dots(filp, ctx);\n\t\tgoto out;\n\t}\n\n\terror = -zfs_zget(zfsvfs, zfsvfs->z_shares_dir, &dzp);\n\tif (error)\n\t\tgoto out;\n\n\tcrhold(cr);\n\terror = -zfs_readdir(ZTOI(dzp), ctx, cr);\n\tcrfree(cr);\n\n\tiput(ZTOI(dzp));\nout:\n\tspl_fstrans_unmark(cookie);\n\tzpl_exit(zfsvfs, FTAG);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#if !defined(HAVE_VFS_ITERATE) && !defined(HAVE_VFS_ITERATE_SHARED)\nstatic int\nzpl_shares_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tzpl_dir_context_t ctx =\n\t    ZPL_DIR_CONTEXT_INIT(dirent, filldir, filp->f_pos);\n\tint error;\n\n\terror = zpl_shares_iterate(filp, &ctx);\n\tfilp->f_pos = ctx.pos;\n\n\treturn (error);\n}\n#endif  \n\nstatic int\n#ifdef HAVE_USERNS_IOPS_GETATTR\nzpl_shares_getattr_impl(struct user_namespace *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#elif defined(HAVE_IDMAP_IOPS_GETATTR)\nzpl_shares_getattr_impl(struct mnt_idmap *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#else\nzpl_shares_getattr_impl(const struct path *path, struct kstat *stat,\n    u32 request_mask, unsigned int query_flags)\n#endif\n{\n\t(void) request_mask, (void) query_flags;\n\tstruct inode *ip = path->dentry->d_inode;\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tznode_t *dzp;\n\tint error;\n\n\tif ((error = zpl_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zfsvfs->z_shares_dir == 0) {\n#if (defined(HAVE_USERNS_IOPS_GETATTR) || defined(HAVE_IDMAP_IOPS_GETATTR))\n#ifdef HAVE_GENERIC_FILLATTR_USERNS\n\t\tgeneric_fillattr(user_ns, path->dentry->d_inode, stat);\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP)\n\t\tgeneric_fillattr(user_ns, path->dentry->d_inode, stat);\n#elif defined(HAVE_GENERIC_FILLATTR_IDMAP_REQMASK)\n\tgeneric_fillattr(user_ns, request_mask, ip, stat);\n#else\n\t\t(void) user_ns;\n#endif\n#else\n\t\tgeneric_fillattr(path->dentry->d_inode, stat);\n#endif\n\t\tstat->nlink = stat->size = 2;\n\t\tstat->atime = current_time(ip);\n\t\tzpl_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\terror = -zfs_zget(zfsvfs, zfsvfs->z_shares_dir, &dzp);\n\tif (error == 0) {\n#ifdef HAVE_GENERIC_FILLATTR_IDMAP_REQMASK\n\t\terror = -zfs_getattr_fast(user_ns, request_mask, ZTOI(dzp),\n\t\t    stat);\n#elif (defined(HAVE_USERNS_IOPS_GETATTR) || defined(HAVE_IDMAP_IOPS_GETATTR))\n\t\terror = -zfs_getattr_fast(user_ns, ZTOI(dzp), stat);\n#else\n\t\terror = -zfs_getattr_fast(kcred->user_ns, ZTOI(dzp), stat);\n#endif\n\t\tiput(ZTOI(dzp));\n\t}\n\n\tzpl_exit(zfsvfs, FTAG);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\nZPL_GETATTR_WRAPPER(zpl_shares_getattr);\n\n \nconst struct file_operations zpl_fops_shares = {\n\t.open\t\t= zpl_common_open,\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n#ifdef HAVE_VFS_ITERATE_SHARED\n\t.iterate_shared\t= zpl_shares_iterate,\n#elif defined(HAVE_VFS_ITERATE)\n\t.iterate\t= zpl_shares_iterate,\n#else\n\t.readdir\t= zpl_shares_readdir,\n#endif\n\n};\n\n \nconst struct inode_operations zpl_ops_shares = {\n\t.lookup\t\t= zpl_shares_lookup,\n\t.getattr\t= zpl_shares_getattr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}