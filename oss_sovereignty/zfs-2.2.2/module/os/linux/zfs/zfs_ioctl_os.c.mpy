{
  "module_name": "zfs_ioctl_os.c",
  "hash_id": "9bcc40778dd4e5f9bc8baac8ed17ffb04052e87b795ed8eb40a1645644c8daa2",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_ioctl_os.c",
  "human_readable_source": " \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/errno.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/stat.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zap.h>\n#include <sys/spa.h>\n#include <sys/nvpair.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_onexit.h>\n#include <sys/zvol.h>\n#include <sys/fm/util.h>\n#include <sys/dsl_crypt.h>\n#include <sys/crypto/icp.h>\n#include <sys/zstd/zstd.h>\n\n#include <sys/zfs_ioctl_impl.h>\n\n#include <sys/zfs_sysfs.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n\nboolean_t\nzfs_vfs_held(zfsvfs_t *zfsvfs)\n{\n\treturn (zfsvfs->z_sb != NULL);\n}\n\nint\nzfs_vfs_ref(zfsvfs_t **zfvp)\n{\n\tif (*zfvp == NULL || (*zfvp)->z_sb == NULL ||\n\t    !atomic_inc_not_zero(&((*zfvp)->z_sb->s_active))) {\n\t\treturn (SET_ERROR(ESRCH));\n\t}\n\treturn (0);\n}\n\nvoid\nzfs_vfs_rele(zfsvfs_t *zfsvfs)\n{\n\tdeactivate_super(zfsvfs->z_sb);\n}\n\nvoid\nzfsdev_private_set_state(void *priv, zfsdev_state_t *zs)\n{\n\tstruct file *filp = priv;\n\n\tfilp->private_data = zs;\n}\n\nzfsdev_state_t *\nzfsdev_private_get_state(void *priv)\n{\n\tstruct file *filp = priv;\n\n\treturn (filp->private_data);\n}\n\nstatic int\nzfsdev_open(struct inode *ino, struct file *filp)\n{\n\tint error;\n\n\tmutex_enter(&zfsdev_state_lock);\n\terror = zfsdev_state_init(filp);\n\tmutex_exit(&zfsdev_state_lock);\n\n\treturn (-error);\n}\n\nstatic int\nzfsdev_release(struct inode *ino, struct file *filp)\n{\n\tzfsdev_state_destroy(filp);\n\n\treturn (0);\n}\n\nstatic long\nzfsdev_ioctl(struct file *filp, unsigned cmd, unsigned long arg)\n{\n\tuint_t vecnum;\n\tzfs_cmd_t *zc;\n\tint error, rc;\n\n\tvecnum = cmd - ZFS_IOC_FIRST;\n\n\tzc = vmem_zalloc(sizeof (zfs_cmd_t), KM_SLEEP);\n\n\tif (ddi_copyin((void *)(uintptr_t)arg, zc, sizeof (zfs_cmd_t), 0)) {\n\t\terror = -SET_ERROR(EFAULT);\n\t\tgoto out;\n\t}\n\terror = -zfsdev_ioctl_common(vecnum, zc, 0);\n\trc = ddi_copyout(zc, (void *)(uintptr_t)arg, sizeof (zfs_cmd_t), 0);\n\tif (error == 0 && rc != 0)\n\t\terror = -SET_ERROR(EFAULT);\nout:\n\tvmem_free(zc, sizeof (zfs_cmd_t));\n\treturn (error);\n\n}\n\nstatic int\nzfs_ioc_userns_attach(zfs_cmd_t *zc)\n{\n\tint error;\n\n\tif (zc == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = zone_dataset_attach(CRED(), zc->zc_name, zc->zc_cleanup_fd);\n\n\t \n\tif (error == ENOTTY)\n\t\terror = ZFS_ERR_NOT_USER_NAMESPACE;\n\n\treturn (error);\n}\n\nstatic int\nzfs_ioc_userns_detach(zfs_cmd_t *zc)\n{\n\tint error;\n\n\tif (zc == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terror = zone_dataset_detach(CRED(), zc->zc_name, zc->zc_cleanup_fd);\n\n\t \n\tif (error == ENOTTY)\n\t\terror = ZFS_ERR_NOT_USER_NAMESPACE;\n\n\treturn (error);\n}\n\nuint64_t\nzfs_max_nvlist_src_size_os(void)\n{\n\tif (zfs_max_nvlist_src_size != 0)\n\t\treturn (zfs_max_nvlist_src_size);\n\n\treturn (MIN(ptob(zfs_totalram_pages) / 4, 128 * 1024 * 1024));\n}\n\n \nvoid\nzfs_ioctl_update_mount_cache(const char *dsname)\n{\n}\n\nvoid\nzfs_ioctl_init_os(void)\n{\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_USERNS_ATTACH,\n\t    zfs_ioc_userns_attach, zfs_secpolicy_config, POOL_CHECK_NONE);\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_USERNS_DETACH,\n\t    zfs_ioc_userns_detach, zfs_secpolicy_config, POOL_CHECK_NONE);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\nzfsdev_compat_ioctl(struct file *filp, unsigned cmd, unsigned long arg)\n{\n\treturn (zfsdev_ioctl(filp, cmd, arg));\n}\n#else\n#define\tzfsdev_compat_ioctl\tNULL\n#endif\n\nstatic const struct file_operations zfsdev_fops = {\n\t.open\t\t= zfsdev_open,\n\t.release\t= zfsdev_release,\n\t.unlocked_ioctl\t= zfsdev_ioctl,\n\t.compat_ioctl\t= zfsdev_compat_ioctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic struct miscdevice zfs_misc = {\n\t.minor\t\t= ZFS_DEVICE_MINOR,\n\t.name\t\t= ZFS_DRIVER,\n\t.fops\t\t= &zfsdev_fops,\n};\n\nMODULE_ALIAS_MISCDEV(ZFS_DEVICE_MINOR);\nMODULE_ALIAS(\"devname:zfs\");\n\nint\nzfsdev_attach(void)\n{\n\tint error;\n\n\terror = misc_register(&zfs_misc);\n\tif (error == -EBUSY) {\n\t\t \n\t\tprintk(KERN_INFO \"ZFS: misc_register() with static minor %d \"\n\t\t    \"failed %d, retrying with MISC_DYNAMIC_MINOR\\n\",\n\t\t    ZFS_DEVICE_MINOR, error);\n\n\t\tzfs_misc.minor = MISC_DYNAMIC_MINOR;\n\t\terror = misc_register(&zfs_misc);\n\t}\n\n\tif (error)\n\t\tprintk(KERN_INFO \"ZFS: misc_register() failed %d\\n\", error);\n\n\treturn (error);\n}\n\nvoid\nzfsdev_detach(void)\n{\n\tmisc_deregister(&zfs_misc);\n}\n\n#ifdef ZFS_DEBUG\n#define\tZFS_DEBUG_STR\t\" (DEBUG mode)\"\n#else\n#define\tZFS_DEBUG_STR\t\"\"\n#endif\n\nzidmap_t *zfs_init_idmap;\n\nstatic int\nopenzfs_init_os(void)\n{\n\tint error;\n\n\tif ((error = zfs_kmod_init()) != 0) {\n\t\tprintk(KERN_NOTICE \"ZFS: Failed to Load ZFS Filesystem v%s-%s%s\"\n\t\t    \", rc = %d\\n\", ZFS_META_VERSION, ZFS_META_RELEASE,\n\t\t    ZFS_DEBUG_STR, error);\n\n\t\treturn (-error);\n\t}\n\n\tzfs_sysfs_init();\n\n\tprintk(KERN_NOTICE \"ZFS: Loaded module v%s-%s%s, \"\n\t    \"ZFS pool version %s, ZFS filesystem version %s\\n\",\n\t    ZFS_META_VERSION, ZFS_META_RELEASE, ZFS_DEBUG_STR,\n\t    SPA_VERSION_STRING, ZPL_VERSION_STRING);\n#ifndef CONFIG_FS_POSIX_ACL\n\tprintk(KERN_NOTICE \"ZFS: Posix ACLs disabled by kernel\\n\");\n#endif  \n\n\tzfs_init_idmap = (zidmap_t *)zfs_get_init_idmap();\n\n\treturn (0);\n}\n\nstatic void\nopenzfs_fini_os(void)\n{\n\tzfs_sysfs_fini();\n\tzfs_kmod_fini();\n\n\tprintk(KERN_NOTICE \"ZFS: Unloaded module v%s-%s%s\\n\",\n\t    ZFS_META_VERSION, ZFS_META_RELEASE, ZFS_DEBUG_STR);\n}\n\n\nextern int __init zcommon_init(void);\nextern void zcommon_fini(void);\n\nstatic int __init\nopenzfs_init(void)\n{\n\tint err;\n\tif ((err = zcommon_init()) != 0)\n\t\tgoto zcommon_failed;\n\tif ((err = icp_init()) != 0)\n\t\tgoto icp_failed;\n\tif ((err = zstd_init()) != 0)\n\t\tgoto zstd_failed;\n\tif ((err = openzfs_init_os()) != 0)\n\t\tgoto openzfs_os_failed;\n\treturn (0);\n\nopenzfs_os_failed:\n\tzstd_fini();\nzstd_failed:\n\ticp_fini();\nicp_failed:\n\tzcommon_fini();\nzcommon_failed:\n\treturn (err);\n}\n\nstatic void __exit\nopenzfs_fini(void)\n{\n\topenzfs_fini_os();\n\tzstd_fini();\n\ticp_fini();\n\tzcommon_fini();\n}\n\n#if defined(_KERNEL)\nmodule_init(openzfs_init);\nmodule_exit(openzfs_fini);\n#endif\n\nMODULE_ALIAS(\"zavl\");\nMODULE_ALIAS(\"icp\");\nMODULE_ALIAS(\"zlua\");\nMODULE_ALIAS(\"znvpair\");\nMODULE_ALIAS(\"zunicode\");\nMODULE_ALIAS(\"zcommon\");\nMODULE_ALIAS(\"zzstd\");\nMODULE_DESCRIPTION(\"ZFS\");\nMODULE_AUTHOR(ZFS_META_AUTHOR);\nMODULE_LICENSE(\"Dual MIT/GPL\");  \nMODULE_LICENSE(\"Dual BSD/GPL\");  \nMODULE_LICENSE(ZFS_META_LICENSE);\nMODULE_VERSION(ZFS_META_VERSION \"-\" ZFS_META_RELEASE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}