{
  "module_name": "zpl_file_range.c",
  "hash_id": "010e11e5c647036d15fc1c41c86b6695a5c7d5199603ebc522725e53a336c7c9",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_file_range.c",
  "human_readable_source": " \n \n\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n#include <linux/fs.h>\n#include <sys/file.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfeature.h>\n\nint zfs_bclone_enabled = 0;\n\n \nstatic ssize_t\n__zpl_clone_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, size_t len)\n{\n\tstruct inode *src_i = file_inode(src_file);\n\tstruct inode *dst_i = file_inode(dst_file);\n\tuint64_t src_off_o = (uint64_t)src_off;\n\tuint64_t dst_off_o = (uint64_t)dst_off;\n\tuint64_t len_o = (uint64_t)len;\n\tcred_t *cr = CRED();\n\tfstrans_cookie_t cookie;\n\tint err;\n\n\tif (!zfs_bclone_enabled)\n\t\treturn (-EOPNOTSUPP);\n\n\tif (!spa_feature_is_enabled(\n\t    dmu_objset_spa(ITOZSB(dst_i)->z_os), SPA_FEATURE_BLOCK_CLONING))\n\t\treturn (-EOPNOTSUPP);\n\n\tif (src_i != dst_i)\n\t\tspl_inode_lock_shared(src_i);\n\tspl_inode_lock(dst_i);\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\n\terr = -zfs_clone_range(ITOZ(src_i), &src_off_o, ITOZ(dst_i),\n\t    &dst_off_o, &len_o, cr);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tspl_inode_unlock(dst_i);\n\tif (src_i != dst_i)\n\t\tspl_inode_unlock_shared(src_i);\n\n\tif (err < 0)\n\t\treturn (err);\n\n\treturn ((ssize_t)len_o);\n}\n\n#if defined(HAVE_VFS_COPY_FILE_RANGE) || \\\n    defined(HAVE_VFS_FILE_OPERATIONS_EXTEND)\n \nssize_t\nzpl_copy_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tif (flags != 0)\n\t\treturn (-EINVAL);\n\n\t \n\tret = __zpl_clone_file_range(src_file, src_off,\n\t    dst_file, dst_off, len);\n\n#ifdef HAVE_VFS_GENERIC_COPY_FILE_RANGE\n\t \n\tif (ret == -EOPNOTSUPP || ret == -EINVAL || ret == -EXDEV ||\n\t    ret == -EAGAIN)\n\t\tret = generic_copy_file_range(src_file, src_off, dst_file,\n\t\t    dst_off, len, flags);\n#else\n\t \n\tif (ret == -EINVAL || ret == -EXDEV || ret == -EAGAIN)\n\t\tret = -EOPNOTSUPP;\n#endif  \n\n\treturn (ret);\n}\n#endif  \n\n#ifdef HAVE_VFS_REMAP_FILE_RANGE\n \nloff_t\nzpl_remap_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, loff_t len, unsigned int flags)\n{\n\tif (flags & ~(REMAP_FILE_DEDUP | REMAP_FILE_CAN_SHORTEN))\n\t\treturn (-EINVAL);\n\n\t \n\tflags &= ~REMAP_FILE_CAN_SHORTEN;\n\n\tif (flags & REMAP_FILE_DEDUP)\n\t\t \n\t\treturn (-EOPNOTSUPP);\n\n\t \n\tif (len == 0)\n\t\tlen = i_size_read(file_inode(src_file)) - src_off;\n\n\treturn (__zpl_clone_file_range(src_file, src_off,\n\t    dst_file, dst_off, len));\n}\n#endif  \n\n#if defined(HAVE_VFS_CLONE_FILE_RANGE) || \\\n    defined(HAVE_VFS_FILE_OPERATIONS_EXTEND)\n \nint\nzpl_clone_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, uint64_t len)\n{\n\t \n\tif (len == 0)\n\t\tlen = i_size_read(file_inode(src_file)) - src_off;\n\n\treturn (__zpl_clone_file_range(src_file, src_off,\n\t    dst_file, dst_off, len));\n}\n#endif  \n\n#ifdef HAVE_VFS_DEDUPE_FILE_RANGE\n \nint\nzpl_dedupe_file_range(struct file *src_file, loff_t src_off,\n    struct file *dst_file, loff_t dst_off, uint64_t len)\n{\n\t \n\treturn (-EOPNOTSUPP);\n}\n#endif  \n\n \nlong\nzpl_ioctl_ficlone(struct file *dst_file, void *arg)\n{\n\tunsigned long sfd = (unsigned long)arg;\n\n\tstruct file *src_file = fget(sfd);\n\tif (src_file == NULL)\n\t\treturn (-EBADF);\n\n\tif (dst_file->f_op != src_file->f_op) {\n\t\tfput(src_file);\n\t\treturn (-EXDEV);\n\t}\n\n\tsize_t len = i_size_read(file_inode(src_file));\n\n\tssize_t ret =\n\t    __zpl_clone_file_range(src_file, 0, dst_file, 0, len);\n\n\tfput(src_file);\n\n\tif (ret < 0) {\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\treturn (-ENOTTY);\n\t\treturn (ret);\n\t}\n\n\tif (ret != len)\n\t\treturn (-EINVAL);\n\n\treturn (0);\n}\n\n \nlong\nzpl_ioctl_ficlonerange(struct file *dst_file, void __user *arg)\n{\n\tzfs_ioc_compat_file_clone_range_t fcr;\n\n\tif (copy_from_user(&fcr, arg, sizeof (fcr)))\n\t\treturn (-EFAULT);\n\n\tstruct file *src_file = fget(fcr.fcr_src_fd);\n\tif (src_file == NULL)\n\t\treturn (-EBADF);\n\n\tif (dst_file->f_op != src_file->f_op) {\n\t\tfput(src_file);\n\t\treturn (-EXDEV);\n\t}\n\n\tsize_t len = fcr.fcr_src_length;\n\tif (len == 0)\n\t\tlen = i_size_read(file_inode(src_file)) - fcr.fcr_src_offset;\n\n\tssize_t ret = __zpl_clone_file_range(src_file, fcr.fcr_src_offset,\n\t    dst_file, fcr.fcr_dest_offset, len);\n\n\tfput(src_file);\n\n\tif (ret < 0) {\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\treturn (-ENOTTY);\n\t\treturn (ret);\n\t}\n\n\tif (ret != len)\n\t\treturn (-EINVAL);\n\n\treturn (0);\n}\n\n \nlong\nzpl_ioctl_fideduperange(struct file *filp, void *arg)\n{\n\t(void) arg;\n\n\t \n\treturn (-ENOTTY);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}