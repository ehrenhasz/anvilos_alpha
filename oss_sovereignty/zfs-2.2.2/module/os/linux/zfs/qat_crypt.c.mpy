{
  "module_name": "qat_crypt.c",
  "hash_id": "58ca91fb97305c752c56edaa07bea0ca8bec452c9f21b7b60835c120e86b5eb8",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/qat_crypt.c",
  "human_readable_source": " \n\n \n\n#if defined(_KERNEL) && defined(HAVE_QAT)\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/completion.h>\n#include <sys/zfs_context.h>\n#include <sys/zio_crypt.h>\n#include \"lac/cpa_cy_im.h\"\n#include \"lac/cpa_cy_common.h\"\n#include <sys/qat.h>\n\n \n#define\tQAT_CRYPT_MAX_INSTANCES\t\t48\n\n#define\tMAX_PAGE_NUM\t\t\t1024\n\nstatic Cpa32U inst_num = 0;\nstatic Cpa16U num_inst = 0;\nstatic CpaInstanceHandle cy_inst_handles[QAT_CRYPT_MAX_INSTANCES];\nstatic boolean_t qat_cy_init_done = B_FALSE;\nint zfs_qat_encrypt_disable = 0;\nint zfs_qat_checksum_disable = 0;\n\ntypedef struct cy_callback {\n\tCpaBoolean verify_result;\n\tstruct completion complete;\n} cy_callback_t;\n\nstatic void\nsymcallback(void *p_callback, CpaStatus status, const CpaCySymOp operation,\n    void *op_data, CpaBufferList *buf_list_dst, CpaBoolean verify)\n{\n\tcy_callback_t *cb = p_callback;\n\n\tif (cb != NULL) {\n\t\t \n\t\tcb->verify_result = verify;\n\t\tcomplete(&cb->complete);\n\t}\n}\n\nboolean_t\nqat_crypt_use_accel(size_t s_len)\n{\n\treturn (!zfs_qat_encrypt_disable &&\n\t    qat_cy_init_done &&\n\t    s_len >= QAT_MIN_BUF_SIZE &&\n\t    s_len <= QAT_MAX_BUF_SIZE);\n}\n\nboolean_t\nqat_checksum_use_accel(size_t s_len)\n{\n\treturn (!zfs_qat_checksum_disable &&\n\t    qat_cy_init_done &&\n\t    s_len >= QAT_MIN_BUF_SIZE &&\n\t    s_len <= QAT_MAX_BUF_SIZE);\n}\n\nvoid\nqat_cy_clean(void)\n{\n\tfor (Cpa16U i = 0; i < num_inst; i++)\n\t\tcpaCyStopInstance(cy_inst_handles[i]);\n\n\tnum_inst = 0;\n\tqat_cy_init_done = B_FALSE;\n}\n\nint\nqat_cy_init(void)\n{\n\tCpaStatus status = CPA_STATUS_FAIL;\n\n\tif (qat_cy_init_done)\n\t\treturn (0);\n\n\tstatus = cpaCyGetNumInstances(&num_inst);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (-1);\n\n\t \n\tif (num_inst == 0)\n\t\treturn (0);\n\n\tif (num_inst > QAT_CRYPT_MAX_INSTANCES)\n\t\tnum_inst = QAT_CRYPT_MAX_INSTANCES;\n\n\tstatus = cpaCyGetInstances(num_inst, &cy_inst_handles[0]);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (-1);\n\n\tfor (Cpa16U i = 0; i < num_inst; i++) {\n\t\tstatus = cpaCySetAddressTranslation(cy_inst_handles[i],\n\t\t    (void *)virt_to_phys);\n\t\tif (status != CPA_STATUS_SUCCESS)\n\t\t\tgoto error;\n\n\t\tstatus = cpaCyStartInstance(cy_inst_handles[i]);\n\t\tif (status != CPA_STATUS_SUCCESS)\n\t\t\tgoto error;\n\t}\n\n\tqat_cy_init_done = B_TRUE;\n\treturn (0);\n\nerror:\n\tqat_cy_clean();\n\treturn (-1);\n}\n\nvoid\nqat_cy_fini(void)\n{\n\tif (!qat_cy_init_done)\n\t\treturn;\n\n\tqat_cy_clean();\n}\n\nstatic CpaStatus\nqat_init_crypt_session_ctx(qat_encrypt_dir_t dir, CpaInstanceHandle inst_handle,\n    CpaCySymSessionCtx **cy_session_ctx, crypto_key_t *key,\n    Cpa64U crypt, Cpa32U aad_len)\n{\n\tCpaStatus status = CPA_STATUS_SUCCESS;\n\tCpa32U ctx_size;\n\tCpa32U ciper_algorithm;\n\tCpa32U hash_algorithm;\n\tCpaCySymSessionSetupData sd = { 0 };\n\n\tif (zio_crypt_table[crypt].ci_crypt_type == ZC_TYPE_CCM) {\n\t\treturn (CPA_STATUS_FAIL);\n\t} else {\n\t\tciper_algorithm = CPA_CY_SYM_CIPHER_AES_GCM;\n\t\thash_algorithm = CPA_CY_SYM_HASH_AES_GCM;\n\t}\n\n\tsd.cipherSetupData.cipherAlgorithm = ciper_algorithm;\n\tsd.cipherSetupData.pCipherKey = key->ck_data;\n\tsd.cipherSetupData.cipherKeyLenInBytes = key->ck_length / 8;\n\tsd.hashSetupData.hashAlgorithm = hash_algorithm;\n\tsd.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;\n\tsd.hashSetupData.digestResultLenInBytes = ZIO_DATA_MAC_LEN;\n\tsd.hashSetupData.authModeSetupData.aadLenInBytes = aad_len;\n\tsd.sessionPriority = CPA_CY_PRIORITY_NORMAL;\n\tsd.symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;\n\tsd.digestIsAppended = CPA_FALSE;\n\tsd.verifyDigest = CPA_FALSE;\n\n\tif (dir == QAT_ENCRYPT) {\n\t\tsd.cipherSetupData.cipherDirection =\n\t\t    CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;\n\t\tsd.algChainOrder =\n\t\t    CPA_CY_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER;\n\t} else {\n\t\tASSERT3U(dir, ==, QAT_DECRYPT);\n\t\tsd.cipherSetupData.cipherDirection =\n\t\t    CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;\n\t\tsd.algChainOrder =\n\t\t    CPA_CY_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH;\n\t}\n\n\tstatus = cpaCySymSessionCtxGetSize(inst_handle, &sd, &ctx_size);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (status);\n\n\tstatus = QAT_PHYS_CONTIG_ALLOC(cy_session_ctx, ctx_size);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (status);\n\n\tstatus = cpaCySymInitSession(inst_handle, symcallback, &sd,\n\t    *cy_session_ctx);\n\tif (status != CPA_STATUS_SUCCESS) {\n\t\tQAT_PHYS_CONTIG_FREE(*cy_session_ctx);\n\t\treturn (status);\n\t}\n\n\treturn (CPA_STATUS_SUCCESS);\n}\n\nstatic CpaStatus\nqat_init_checksum_session_ctx(CpaInstanceHandle inst_handle,\n    CpaCySymSessionCtx **cy_session_ctx, Cpa64U cksum)\n{\n\tCpaStatus status = CPA_STATUS_SUCCESS;\n\tCpa32U ctx_size;\n\tCpa32U hash_algorithm;\n\tCpaCySymSessionSetupData sd = { 0 };\n\n\t \n\tif (cksum == ZIO_CHECKSUM_SHA256)\n\t\thash_algorithm = CPA_CY_SYM_HASH_SHA256;\n\telse\n\t\treturn (CPA_STATUS_FAIL);\n\n\tsd.sessionPriority = CPA_CY_PRIORITY_NORMAL;\n\tsd.symOperation = CPA_CY_SYM_OP_HASH;\n\tsd.hashSetupData.hashAlgorithm = hash_algorithm;\n\tsd.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_PLAIN;\n\tsd.hashSetupData.digestResultLenInBytes = sizeof (zio_cksum_t);\n\tsd.digestIsAppended = CPA_FALSE;\n\tsd.verifyDigest = CPA_FALSE;\n\n\tstatus = cpaCySymSessionCtxGetSize(inst_handle, &sd, &ctx_size);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (status);\n\n\tstatus = QAT_PHYS_CONTIG_ALLOC(cy_session_ctx, ctx_size);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (status);\n\n\tstatus = cpaCySymInitSession(inst_handle, symcallback, &sd,\n\t    *cy_session_ctx);\n\tif (status != CPA_STATUS_SUCCESS) {\n\t\tQAT_PHYS_CONTIG_FREE(*cy_session_ctx);\n\t\treturn (status);\n\t}\n\n\treturn (CPA_STATUS_SUCCESS);\n}\n\nstatic CpaStatus\nqat_init_cy_buffer_lists(CpaInstanceHandle inst_handle, uint32_t nr_bufs,\n    CpaBufferList *src, CpaBufferList *dst)\n{\n\tCpaStatus status = CPA_STATUS_SUCCESS;\n\tCpa32U meta_size = 0;\n\n\tstatus = cpaCyBufferListGetMetaSize(inst_handle, nr_bufs, &meta_size);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\treturn (status);\n\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&src->pPrivateMetaData, meta_size);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto error;\n\n\tif (src != dst) {\n\t\tstatus = QAT_PHYS_CONTIG_ALLOC(&dst->pPrivateMetaData,\n\t\t    meta_size);\n\t\tif (status != CPA_STATUS_SUCCESS)\n\t\t\tgoto error;\n\t}\n\n\treturn (CPA_STATUS_SUCCESS);\n\nerror:\n\tQAT_PHYS_CONTIG_FREE(src->pPrivateMetaData);\n\tif (src != dst)\n\t\tQAT_PHYS_CONTIG_FREE(dst->pPrivateMetaData);\n\n\treturn (status);\n}\n\nint\nqat_crypt(qat_encrypt_dir_t dir, uint8_t *src_buf, uint8_t *dst_buf,\n    uint8_t *aad_buf, uint32_t aad_len, uint8_t *iv_buf, uint8_t *digest_buf,\n    crypto_key_t *key, uint64_t crypt, uint32_t enc_len)\n{\n\tCpaStatus status = CPA_STATUS_SUCCESS;\n\tCpa16U i;\n\tCpaInstanceHandle cy_inst_handle;\n\tCpa16U nr_bufs = (enc_len >> PAGE_SHIFT) + 2;\n\tCpa32U bytes_left = 0;\n\tCpa8S *data = NULL;\n\tCpaCySymSessionCtx *cy_session_ctx = NULL;\n\tcy_callback_t cb;\n\tCpaCySymOpData op_data = { 0 };\n\tCpaBufferList src_buffer_list = { 0 };\n\tCpaBufferList dst_buffer_list = { 0 };\n\tCpaFlatBuffer *flat_src_buf_array = NULL;\n\tCpaFlatBuffer *flat_src_buf = NULL;\n\tCpaFlatBuffer *flat_dst_buf_array = NULL;\n\tCpaFlatBuffer *flat_dst_buf = NULL;\n\tstruct page *in_pages[MAX_PAGE_NUM];\n\tstruct page *out_pages[MAX_PAGE_NUM];\n\tCpa32U in_page_num = 0;\n\tCpa32U out_page_num = 0;\n\tCpa32U in_page_off = 0;\n\tCpa32U out_page_off = 0;\n\n\tif (dir == QAT_ENCRYPT) {\n\t\tQAT_STAT_BUMP(encrypt_requests);\n\t\tQAT_STAT_INCR(encrypt_total_in_bytes, enc_len);\n\t} else {\n\t\tQAT_STAT_BUMP(decrypt_requests);\n\t\tQAT_STAT_INCR(decrypt_total_in_bytes, enc_len);\n\t}\n\n\ti = (Cpa32U)atomic_inc_32_nv(&inst_num) % num_inst;\n\tcy_inst_handle = cy_inst_handles[i];\n\n\tstatus = qat_init_crypt_session_ctx(dir, cy_inst_handle,\n\t    &cy_session_ctx, key, crypt, aad_len);\n\tif (status != CPA_STATUS_SUCCESS) {\n\t\t \n\t\tif (zio_crypt_table[crypt].ci_crypt_type == ZC_TYPE_GCM)\n\t\t\tQAT_STAT_BUMP(crypt_fails);\n\t\treturn (status);\n\t}\n\n\t \n\tstatus = qat_init_cy_buffer_lists(cy_inst_handle, nr_bufs,\n\t    &src_buffer_list, &dst_buffer_list);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&flat_src_buf_array,\n\t    nr_bufs * sizeof (CpaFlatBuffer));\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&flat_dst_buf_array,\n\t    nr_bufs * sizeof (CpaFlatBuffer));\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&op_data.pDigestResult,\n\t    ZIO_DATA_MAC_LEN);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&op_data.pIv,\n\t    ZIO_DATA_IV_LEN);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\tif (aad_len > 0) {\n\t\tstatus = QAT_PHYS_CONTIG_ALLOC(&op_data.pAdditionalAuthData,\n\t\t    aad_len);\n\t\tif (status != CPA_STATUS_SUCCESS)\n\t\t\tgoto fail;\n\t\tmemcpy(op_data.pAdditionalAuthData, aad_buf, aad_len);\n\t}\n\n\tbytes_left = enc_len;\n\tdata = src_buf;\n\tflat_src_buf = flat_src_buf_array;\n\twhile (bytes_left > 0) {\n\t\tin_page_off = ((long)data & ~PAGE_MASK);\n\t\tin_pages[in_page_num] = qat_mem_to_page(data);\n\t\tflat_src_buf->pData = kmap(in_pages[in_page_num]) + in_page_off;\n\t\tflat_src_buf->dataLenInBytes =\n\t\t    min((long)PAGE_SIZE - in_page_off, (long)bytes_left);\n\t\tdata += flat_src_buf->dataLenInBytes;\n\t\tbytes_left -= flat_src_buf->dataLenInBytes;\n\t\tflat_src_buf++;\n\t\tin_page_num++;\n\t}\n\tsrc_buffer_list.pBuffers = flat_src_buf_array;\n\tsrc_buffer_list.numBuffers = in_page_num;\n\n\tbytes_left = enc_len;\n\tdata = dst_buf;\n\tflat_dst_buf = flat_dst_buf_array;\n\twhile (bytes_left > 0) {\n\t\tout_page_off = ((long)data & ~PAGE_MASK);\n\t\tout_pages[out_page_num] = qat_mem_to_page(data);\n\t\tflat_dst_buf->pData = kmap(out_pages[out_page_num]) +\n\t\t    out_page_off;\n\t\tflat_dst_buf->dataLenInBytes =\n\t\t    min((long)PAGE_SIZE - out_page_off, (long)bytes_left);\n\t\tdata += flat_dst_buf->dataLenInBytes;\n\t\tbytes_left -= flat_dst_buf->dataLenInBytes;\n\t\tflat_dst_buf++;\n\t\tout_page_num++;\n\t}\n\tdst_buffer_list.pBuffers = flat_dst_buf_array;\n\tdst_buffer_list.numBuffers = out_page_num;\n\n\top_data.sessionCtx = cy_session_ctx;\n\top_data.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;\n\top_data.cryptoStartSrcOffsetInBytes = 0;\n\top_data.messageLenToCipherInBytes = 0;\n\top_data.hashStartSrcOffsetInBytes = 0;\n\top_data.messageLenToHashInBytes = 0;\n\top_data.messageLenToCipherInBytes = enc_len;\n\top_data.ivLenInBytes = ZIO_DATA_IV_LEN;\n\tmemcpy(op_data.pIv, iv_buf, ZIO_DATA_IV_LEN);\n\t \n\tif (dir == QAT_DECRYPT)\n\t\tmemcpy(op_data.pDigestResult, digest_buf, ZIO_DATA_MAC_LEN);\n\n\tcb.verify_result = CPA_FALSE;\n\tinit_completion(&cb.complete);\n\tstatus = cpaCySymPerformOp(cy_inst_handle, &cb, &op_data,\n\t    &src_buffer_list, &dst_buffer_list, NULL);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\n\t \n\twait_for_completion(&cb.complete);\n\n\tif (cb.verify_result == CPA_FALSE) {\n\t\tstatus = CPA_STATUS_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif (dir == QAT_ENCRYPT) {\n\t\t \n\t\tmemcpy(digest_buf, op_data.pDigestResult, ZIO_DATA_MAC_LEN);\n\t\tQAT_STAT_INCR(encrypt_total_out_bytes, enc_len);\n\t} else {\n\t\tQAT_STAT_INCR(decrypt_total_out_bytes, enc_len);\n\t}\n\nfail:\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tQAT_STAT_BUMP(crypt_fails);\n\n\tfor (i = 0; i < in_page_num; i++)\n\t\tkunmap(in_pages[i]);\n\tfor (i = 0; i < out_page_num; i++)\n\t\tkunmap(out_pages[i]);\n\n\tcpaCySymRemoveSession(cy_inst_handle, cy_session_ctx);\n\tif (aad_len > 0)\n\t\tQAT_PHYS_CONTIG_FREE(op_data.pAdditionalAuthData);\n\tQAT_PHYS_CONTIG_FREE(op_data.pIv);\n\tQAT_PHYS_CONTIG_FREE(op_data.pDigestResult);\n\tQAT_PHYS_CONTIG_FREE(src_buffer_list.pPrivateMetaData);\n\tQAT_PHYS_CONTIG_FREE(dst_buffer_list.pPrivateMetaData);\n\tQAT_PHYS_CONTIG_FREE(cy_session_ctx);\n\tQAT_PHYS_CONTIG_FREE(flat_src_buf_array);\n\tQAT_PHYS_CONTIG_FREE(flat_dst_buf_array);\n\n\treturn (status);\n}\n\nint\nqat_checksum(uint64_t cksum, uint8_t *buf, uint64_t size, zio_cksum_t *zcp)\n{\n\tCpaStatus status;\n\tCpa16U i;\n\tCpaInstanceHandle cy_inst_handle;\n\tCpa16U nr_bufs = (size >> PAGE_SHIFT) + 2;\n\tCpa32U bytes_left = 0;\n\tCpa8S *data = NULL;\n\tCpaCySymSessionCtx *cy_session_ctx = NULL;\n\tcy_callback_t cb;\n\tCpa8U *digest_buffer = NULL;\n\tCpaCySymOpData op_data = { 0 };\n\tCpaBufferList src_buffer_list = { 0 };\n\tCpaFlatBuffer *flat_src_buf_array = NULL;\n\tCpaFlatBuffer *flat_src_buf = NULL;\n\tstruct page *in_pages[MAX_PAGE_NUM];\n\tCpa32U page_num = 0;\n\tCpa32U page_off = 0;\n\n\tQAT_STAT_BUMP(cksum_requests);\n\tQAT_STAT_INCR(cksum_total_in_bytes, size);\n\n\ti = (Cpa32U)atomic_inc_32_nv(&inst_num) % num_inst;\n\tcy_inst_handle = cy_inst_handles[i];\n\n\tstatus = qat_init_checksum_session_ctx(cy_inst_handle,\n\t    &cy_session_ctx, cksum);\n\tif (status != CPA_STATUS_SUCCESS) {\n\t\t \n\t\tif (cksum == ZIO_CHECKSUM_SHA256 ||\n\t\t    cksum == ZIO_CHECKSUM_SHA512)\n\t\t\tQAT_STAT_BUMP(cksum_fails);\n\t\treturn (status);\n\t}\n\n\t \n\tstatus = qat_init_cy_buffer_lists(cy_inst_handle, nr_bufs,\n\t    &src_buffer_list, &src_buffer_list);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&flat_src_buf_array,\n\t    nr_bufs * sizeof (CpaFlatBuffer));\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\tstatus = QAT_PHYS_CONTIG_ALLOC(&digest_buffer,\n\t    sizeof (zio_cksum_t));\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\n\tbytes_left = size;\n\tdata = buf;\n\tflat_src_buf = flat_src_buf_array;\n\twhile (bytes_left > 0) {\n\t\tpage_off = ((long)data & ~PAGE_MASK);\n\t\tin_pages[page_num] = qat_mem_to_page(data);\n\t\tflat_src_buf->pData = kmap(in_pages[page_num]) + page_off;\n\t\tflat_src_buf->dataLenInBytes =\n\t\t    min((long)PAGE_SIZE - page_off, (long)bytes_left);\n\t\tdata += flat_src_buf->dataLenInBytes;\n\t\tbytes_left -= flat_src_buf->dataLenInBytes;\n\t\tflat_src_buf++;\n\t\tpage_num++;\n\t}\n\tsrc_buffer_list.pBuffers = flat_src_buf_array;\n\tsrc_buffer_list.numBuffers = page_num;\n\n\top_data.sessionCtx = cy_session_ctx;\n\top_data.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;\n\top_data.hashStartSrcOffsetInBytes = 0;\n\top_data.messageLenToHashInBytes = size;\n\top_data.pDigestResult = digest_buffer;\n\n\tcb.verify_result = CPA_FALSE;\n\tinit_completion(&cb.complete);\n\tstatus = cpaCySymPerformOp(cy_inst_handle, &cb, &op_data,\n\t    &src_buffer_list, &src_buffer_list, NULL);\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tgoto fail;\n\n\t \n\twait_for_completion(&cb.complete);\n\n\tif (cb.verify_result == CPA_FALSE) {\n\t\tstatus = CPA_STATUS_FAIL;\n\t\tgoto fail;\n\t}\n\n\tmemcpy(zcp, digest_buffer, sizeof (zio_cksum_t));\n\nfail:\n\tif (status != CPA_STATUS_SUCCESS)\n\t\tQAT_STAT_BUMP(cksum_fails);\n\n\tfor (i = 0; i < page_num; i++)\n\t\tkunmap(in_pages[i]);\n\n\tcpaCySymRemoveSession(cy_inst_handle, cy_session_ctx);\n\tQAT_PHYS_CONTIG_FREE(digest_buffer);\n\tQAT_PHYS_CONTIG_FREE(src_buffer_list.pPrivateMetaData);\n\tQAT_PHYS_CONTIG_FREE(cy_session_ctx);\n\tQAT_PHYS_CONTIG_FREE(flat_src_buf_array);\n\n\treturn (status);\n}\n\nstatic int\nparam_set_qat_encrypt(const char *val, zfs_kernel_param_t *kp)\n{\n\tint ret;\n\tint *pvalue = kp->arg;\n\tret = param_set_int(val, kp);\n\tif (ret)\n\t\treturn (ret);\n\t \n\tif (*pvalue == 0 && !qat_cy_init_done) {\n\t\tret = qat_cy_init();\n\t\tif (ret != 0) {\n\t\t\tzfs_qat_encrypt_disable = 1;\n\t\t\treturn (ret);\n\t\t}\n\t}\n\treturn (ret);\n}\n\nstatic int\nparam_set_qat_checksum(const char *val, zfs_kernel_param_t *kp)\n{\n\tint ret;\n\tint *pvalue = kp->arg;\n\tret = param_set_int(val, kp);\n\tif (ret)\n\t\treturn (ret);\n\t \n\tif (*pvalue == 0 && !qat_cy_init_done) {\n\t\tret = qat_cy_init();\n\t\tif (ret != 0) {\n\t\t\tzfs_qat_checksum_disable = 1;\n\t\t\treturn (ret);\n\t\t}\n\t}\n\treturn (ret);\n}\n\nmodule_param_call(zfs_qat_encrypt_disable, param_set_qat_encrypt,\n    param_get_int, &zfs_qat_encrypt_disable, 0644);\nMODULE_PARM_DESC(zfs_qat_encrypt_disable, \"Enable/Disable QAT encryption\");\n\nmodule_param_call(zfs_qat_checksum_disable, param_set_qat_checksum,\n    param_get_int, &zfs_qat_checksum_disable, 0644);\nMODULE_PARM_DESC(zfs_qat_checksum_disable, \"Enable/Disable QAT checksumming\");\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}