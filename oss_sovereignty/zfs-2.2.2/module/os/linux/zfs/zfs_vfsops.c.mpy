{
  "module_name": "zfs_vfsops.c",
  "hash_id": "e7ff9e9aea58fea276bbdeec0d03718825853195b27994656d90ad62b2a23011",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_vfsops.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/kmem.h>\n#include <sys/pathname.h>\n#include <sys/vnode.h>\n#include <sys/vfs.h>\n#include <sys/mntent.h>\n#include <sys/cmn_err.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_dir.h>\n#include <sys/zil.h>\n#include <sys/fs/zfs.h>\n#include <sys/dmu.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_deleg.h>\n#include <sys/spa.h>\n#include <sys/zap.h>\n#include <sys/sa.h>\n#include <sys/sa_impl.h>\n#include <sys/policy.h>\n#include <sys/atomic.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_fuid.h>\n#include <sys/zfs_quota.h>\n#include <sys/sunddi.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n#include <sys/objlist.h>\n#include <sys/zpl.h>\n#include <linux/vfs_compat.h>\n#include \"zfs_comutil.h\"\n\nenum {\n\tTOKEN_RO,\n\tTOKEN_RW,\n\tTOKEN_SETUID,\n\tTOKEN_NOSETUID,\n\tTOKEN_EXEC,\n\tTOKEN_NOEXEC,\n\tTOKEN_DEVICES,\n\tTOKEN_NODEVICES,\n\tTOKEN_DIRXATTR,\n\tTOKEN_SAXATTR,\n\tTOKEN_XATTR,\n\tTOKEN_NOXATTR,\n\tTOKEN_ATIME,\n\tTOKEN_NOATIME,\n\tTOKEN_RELATIME,\n\tTOKEN_NORELATIME,\n\tTOKEN_NBMAND,\n\tTOKEN_NONBMAND,\n\tTOKEN_MNTPOINT,\n\tTOKEN_LAST,\n};\n\nstatic const match_table_t zpl_tokens = {\n\t{ TOKEN_RO,\t\tMNTOPT_RO },\n\t{ TOKEN_RW,\t\tMNTOPT_RW },\n\t{ TOKEN_SETUID,\t\tMNTOPT_SETUID },\n\t{ TOKEN_NOSETUID,\tMNTOPT_NOSETUID },\n\t{ TOKEN_EXEC,\t\tMNTOPT_EXEC },\n\t{ TOKEN_NOEXEC,\t\tMNTOPT_NOEXEC },\n\t{ TOKEN_DEVICES,\tMNTOPT_DEVICES },\n\t{ TOKEN_NODEVICES,\tMNTOPT_NODEVICES },\n\t{ TOKEN_DIRXATTR,\tMNTOPT_DIRXATTR },\n\t{ TOKEN_SAXATTR,\tMNTOPT_SAXATTR },\n\t{ TOKEN_XATTR,\t\tMNTOPT_XATTR },\n\t{ TOKEN_NOXATTR,\tMNTOPT_NOXATTR },\n\t{ TOKEN_ATIME,\t\tMNTOPT_ATIME },\n\t{ TOKEN_NOATIME,\tMNTOPT_NOATIME },\n\t{ TOKEN_RELATIME,\tMNTOPT_RELATIME },\n\t{ TOKEN_NORELATIME,\tMNTOPT_NORELATIME },\n\t{ TOKEN_NBMAND,\t\tMNTOPT_NBMAND },\n\t{ TOKEN_NONBMAND,\tMNTOPT_NONBMAND },\n\t{ TOKEN_MNTPOINT,\tMNTOPT_MNTPOINT \"=%s\" },\n\t{ TOKEN_LAST,\t\tNULL },\n};\n\nstatic void\nzfsvfs_vfs_free(vfs_t *vfsp)\n{\n\tif (vfsp != NULL) {\n\t\tif (vfsp->vfs_mntpoint != NULL)\n\t\t\tkmem_strfree(vfsp->vfs_mntpoint);\n\n\t\tkmem_free(vfsp, sizeof (vfs_t));\n\t}\n}\n\nstatic int\nzfsvfs_parse_option(char *option, int token, substring_t *args, vfs_t *vfsp)\n{\n\tswitch (token) {\n\tcase TOKEN_RO:\n\t\tvfsp->vfs_readonly = B_TRUE;\n\t\tvfsp->vfs_do_readonly = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_RW:\n\t\tvfsp->vfs_readonly = B_FALSE;\n\t\tvfsp->vfs_do_readonly = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_SETUID:\n\t\tvfsp->vfs_setuid = B_TRUE;\n\t\tvfsp->vfs_do_setuid = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NOSETUID:\n\t\tvfsp->vfs_setuid = B_FALSE;\n\t\tvfsp->vfs_do_setuid = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_EXEC:\n\t\tvfsp->vfs_exec = B_TRUE;\n\t\tvfsp->vfs_do_exec = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NOEXEC:\n\t\tvfsp->vfs_exec = B_FALSE;\n\t\tvfsp->vfs_do_exec = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_DEVICES:\n\t\tvfsp->vfs_devices = B_TRUE;\n\t\tvfsp->vfs_do_devices = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NODEVICES:\n\t\tvfsp->vfs_devices = B_FALSE;\n\t\tvfsp->vfs_do_devices = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_DIRXATTR:\n\t\tvfsp->vfs_xattr = ZFS_XATTR_DIR;\n\t\tvfsp->vfs_do_xattr = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_SAXATTR:\n\t\tvfsp->vfs_xattr = ZFS_XATTR_SA;\n\t\tvfsp->vfs_do_xattr = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_XATTR:\n\t\tvfsp->vfs_xattr = ZFS_XATTR_DIR;\n\t\tvfsp->vfs_do_xattr = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NOXATTR:\n\t\tvfsp->vfs_xattr = ZFS_XATTR_OFF;\n\t\tvfsp->vfs_do_xattr = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_ATIME:\n\t\tvfsp->vfs_atime = B_TRUE;\n\t\tvfsp->vfs_do_atime = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NOATIME:\n\t\tvfsp->vfs_atime = B_FALSE;\n\t\tvfsp->vfs_do_atime = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_RELATIME:\n\t\tvfsp->vfs_relatime = B_TRUE;\n\t\tvfsp->vfs_do_relatime = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NORELATIME:\n\t\tvfsp->vfs_relatime = B_FALSE;\n\t\tvfsp->vfs_do_relatime = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NBMAND:\n\t\tvfsp->vfs_nbmand = B_TRUE;\n\t\tvfsp->vfs_do_nbmand = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_NONBMAND:\n\t\tvfsp->vfs_nbmand = B_FALSE;\n\t\tvfsp->vfs_do_nbmand = B_TRUE;\n\t\tbreak;\n\tcase TOKEN_MNTPOINT:\n\t\tvfsp->vfs_mntpoint = match_strdup(&args[0]);\n\t\tif (vfsp->vfs_mntpoint == NULL)\n\t\t\treturn (SET_ERROR(ENOMEM));\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nzfsvfs_parse_options(char *mntopts, vfs_t **vfsp)\n{\n\tvfs_t *tmp_vfsp;\n\tint error;\n\n\ttmp_vfsp = kmem_zalloc(sizeof (vfs_t), KM_SLEEP);\n\n\tif (mntopts != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tchar *tmp_mntopts, *p, *t;\n\t\tint token;\n\n\t\ttmp_mntopts = t = kmem_strdup(mntopts);\n\t\tif (tmp_mntopts == NULL)\n\t\t\treturn (SET_ERROR(ENOMEM));\n\n\t\twhile ((p = strsep(&t, \",\")) != NULL) {\n\t\t\tif (!*p)\n\t\t\t\tcontinue;\n\n\t\t\targs[0].to = args[0].from = NULL;\n\t\t\ttoken = match_token(p, zpl_tokens, args);\n\t\t\terror = zfsvfs_parse_option(p, token, args, tmp_vfsp);\n\t\t\tif (error) {\n\t\t\t\tkmem_strfree(tmp_mntopts);\n\t\t\t\tzfsvfs_vfs_free(tmp_vfsp);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\tkmem_strfree(tmp_mntopts);\n\t}\n\n\t*vfsp = tmp_vfsp;\n\n\treturn (0);\n}\n\nboolean_t\nzfs_is_readonly(zfsvfs_t *zfsvfs)\n{\n\treturn (!!(zfsvfs->z_sb->s_flags & SB_RDONLY));\n}\n\nint\nzfs_sync(struct super_block *sb, int wait, cred_t *cr)\n{\n\t(void) cr;\n\tzfsvfs_t *zfsvfs = sb->s_fs_info;\n\n\t \n\tif (!wait)\n\t\treturn (0);\n\n\tif (zfsvfs != NULL) {\n\t\t \n\t\tdsl_pool_t *dp;\n\t\tint error;\n\n\t\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\t\treturn (error);\n\t\tdp = dmu_objset_pool(zfsvfs->z_os);\n\n\t\t \n\t\tif (spa_suspended(dp->dp_spa)) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif (zfsvfs->z_log != NULL)\n\t\t\tzil_commit(zfsvfs->z_log, 0);\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\t} else {\n\t\t \n\t\tspa_sync_allpools();\n\t}\n\n\treturn (0);\n}\n\nstatic void\natime_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tstruct super_block *sb = zfsvfs->z_sb;\n\n\tif (sb == NULL)\n\t\treturn;\n\t \n\tif (newval)\n\t\tsb->s_flags &= ~SB_NOATIME;\n\telse\n\t\tsb->s_flags |= SB_NOATIME;\n}\n\nstatic void\nrelatime_changed_cb(void *arg, uint64_t newval)\n{\n\t((zfsvfs_t *)arg)->z_relatime = newval;\n}\n\nstatic void\nxattr_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tif (newval == ZFS_XATTR_OFF) {\n\t\tzfsvfs->z_flags &= ~ZSB_XATTR;\n\t} else {\n\t\tzfsvfs->z_flags |= ZSB_XATTR;\n\n\t\tif (newval == ZFS_XATTR_SA)\n\t\t\tzfsvfs->z_xattr_sa = B_TRUE;\n\t\telse\n\t\t\tzfsvfs->z_xattr_sa = B_FALSE;\n\t}\n}\n\nstatic void\nacltype_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tswitch (newval) {\n\tcase ZFS_ACLTYPE_NFSV4:\n\tcase ZFS_ACLTYPE_OFF:\n\t\tzfsvfs->z_acl_type = ZFS_ACLTYPE_OFF;\n\t\tzfsvfs->z_sb->s_flags &= ~SB_POSIXACL;\n\t\tbreak;\n\tcase ZFS_ACLTYPE_POSIX:\n#ifdef CONFIG_FS_POSIX_ACL\n\t\tzfsvfs->z_acl_type = ZFS_ACLTYPE_POSIX;\n\t\tzfsvfs->z_sb->s_flags |= SB_POSIXACL;\n#else\n\t\tzfsvfs->z_acl_type = ZFS_ACLTYPE_OFF;\n\t\tzfsvfs->z_sb->s_flags &= ~SB_POSIXACL;\n#endif  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nblksz_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tASSERT3U(newval, <=, spa_maxblocksize(dmu_objset_spa(zfsvfs->z_os)));\n\tASSERT3U(newval, >=, SPA_MINBLOCKSIZE);\n\tASSERT(ISP2(newval));\n\n\tzfsvfs->z_max_blksz = newval;\n}\n\nstatic void\nreadonly_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tstruct super_block *sb = zfsvfs->z_sb;\n\n\tif (sb == NULL)\n\t\treturn;\n\n\tif (newval)\n\t\tsb->s_flags |= SB_RDONLY;\n\telse\n\t\tsb->s_flags &= ~SB_RDONLY;\n}\n\nstatic void\ndevices_changed_cb(void *arg, uint64_t newval)\n{\n}\n\nstatic void\nsetuid_changed_cb(void *arg, uint64_t newval)\n{\n}\n\nstatic void\nexec_changed_cb(void *arg, uint64_t newval)\n{\n}\n\nstatic void\nnbmand_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tstruct super_block *sb = zfsvfs->z_sb;\n\n\tif (sb == NULL)\n\t\treturn;\n\n\tif (newval == TRUE)\n\t\tsb->s_flags |= SB_MANDLOCK;\n\telse\n\t\tsb->s_flags &= ~SB_MANDLOCK;\n}\n\nstatic void\nsnapdir_changed_cb(void *arg, uint64_t newval)\n{\n\t((zfsvfs_t *)arg)->z_show_ctldir = newval;\n}\n\nstatic void\nacl_mode_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tzfsvfs->z_acl_mode = newval;\n}\n\nstatic void\nacl_inherit_changed_cb(void *arg, uint64_t newval)\n{\n\t((zfsvfs_t *)arg)->z_acl_inherit = newval;\n}\n\nstatic int\nzfs_register_callbacks(vfs_t *vfsp)\n{\n\tstruct dsl_dataset *ds = NULL;\n\tobjset_t *os = NULL;\n\tzfsvfs_t *zfsvfs = NULL;\n\tint error = 0;\n\n\tASSERT(vfsp);\n\tzfsvfs = vfsp->vfs_data;\n\tASSERT(zfsvfs);\n\tos = zfsvfs->z_os;\n\n\t \n\tif (zfs_is_readonly(zfsvfs) || !spa_writeable(dmu_objset_spa(os))) {\n\t\tvfsp->vfs_do_readonly = B_TRUE;\n\t\tvfsp->vfs_readonly = B_TRUE;\n\t}\n\n\t \n\tds = dmu_objset_ds(os);\n\tdsl_pool_config_enter(dmu_objset_pool(os), FTAG);\n\terror = dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ATIME), atime_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_RELATIME), relatime_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_XATTR), xattr_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_RECORDSIZE), blksz_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_READONLY), readonly_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_DEVICES), devices_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_SETUID), setuid_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_EXEC), exec_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_SNAPDIR), snapdir_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ACLTYPE), acltype_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ACLMODE), acl_mode_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ACLINHERIT), acl_inherit_changed_cb,\n\t    zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_NBMAND), nbmand_changed_cb, zfsvfs);\n\tdsl_pool_config_exit(dmu_objset_pool(os), FTAG);\n\tif (error)\n\t\tgoto unregister;\n\n\t \n\tif (vfsp->vfs_do_readonly)\n\t\treadonly_changed_cb(zfsvfs, vfsp->vfs_readonly);\n\tif (vfsp->vfs_do_setuid)\n\t\tsetuid_changed_cb(zfsvfs, vfsp->vfs_setuid);\n\tif (vfsp->vfs_do_exec)\n\t\texec_changed_cb(zfsvfs, vfsp->vfs_exec);\n\tif (vfsp->vfs_do_devices)\n\t\tdevices_changed_cb(zfsvfs, vfsp->vfs_devices);\n\tif (vfsp->vfs_do_xattr)\n\t\txattr_changed_cb(zfsvfs, vfsp->vfs_xattr);\n\tif (vfsp->vfs_do_atime)\n\t\tatime_changed_cb(zfsvfs, vfsp->vfs_atime);\n\tif (vfsp->vfs_do_relatime)\n\t\trelatime_changed_cb(zfsvfs, vfsp->vfs_relatime);\n\tif (vfsp->vfs_do_nbmand)\n\t\tnbmand_changed_cb(zfsvfs, vfsp->vfs_nbmand);\n\n\treturn (0);\n\nunregister:\n\tdsl_prop_unregister_all(ds, zfsvfs);\n\treturn (error);\n}\n\n \nint\nzfs_get_temporary_prop(dsl_dataset_t *ds, zfs_prop_t zfs_prop, uint64_t *val,\n    char *setpoint)\n{\n\tint error;\n\tzfsvfs_t *zfvp;\n\tvfs_t *vfsp;\n\tobjset_t *os;\n\tuint64_t tmp = *val;\n\n\terror = dmu_objset_from_ds(ds, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (dmu_objset_type(os) != DMU_OST_ZFS)\n\t\treturn (EINVAL);\n\n\tmutex_enter(&os->os_user_ptr_lock);\n\tzfvp = dmu_objset_get_user(os);\n\tmutex_exit(&os->os_user_ptr_lock);\n\tif (zfvp == NULL)\n\t\treturn (ESRCH);\n\n\tvfsp = zfvp->z_vfs;\n\n\tswitch (zfs_prop) {\n\tcase ZFS_PROP_ATIME:\n\t\tif (vfsp->vfs_do_atime)\n\t\t\ttmp = vfsp->vfs_atime;\n\t\tbreak;\n\tcase ZFS_PROP_RELATIME:\n\t\tif (vfsp->vfs_do_relatime)\n\t\t\ttmp = vfsp->vfs_relatime;\n\t\tbreak;\n\tcase ZFS_PROP_DEVICES:\n\t\tif (vfsp->vfs_do_devices)\n\t\t\ttmp = vfsp->vfs_devices;\n\t\tbreak;\n\tcase ZFS_PROP_EXEC:\n\t\tif (vfsp->vfs_do_exec)\n\t\t\ttmp = vfsp->vfs_exec;\n\t\tbreak;\n\tcase ZFS_PROP_SETUID:\n\t\tif (vfsp->vfs_do_setuid)\n\t\t\ttmp = vfsp->vfs_setuid;\n\t\tbreak;\n\tcase ZFS_PROP_READONLY:\n\t\tif (vfsp->vfs_do_readonly)\n\t\t\ttmp = vfsp->vfs_readonly;\n\t\tbreak;\n\tcase ZFS_PROP_XATTR:\n\t\tif (vfsp->vfs_do_xattr)\n\t\t\ttmp = vfsp->vfs_xattr;\n\t\tbreak;\n\tcase ZFS_PROP_NBMAND:\n\t\tif (vfsp->vfs_do_nbmand)\n\t\t\ttmp = vfsp->vfs_nbmand;\n\t\tbreak;\n\tdefault:\n\t\treturn (ENOENT);\n\t}\n\n\tif (tmp != *val) {\n\t\tif (setpoint)\n\t\t\t(void) strcpy(setpoint, \"temporary\");\n\t\t*val = tmp;\n\t}\n\treturn (0);\n}\n\n \nstatic int\nzfsvfs_init(zfsvfs_t *zfsvfs, objset_t *os)\n{\n\tint error;\n\tuint64_t val;\n\n\tzfsvfs->z_max_blksz = SPA_OLD_MAXBLOCKSIZE;\n\tzfsvfs->z_show_ctldir = ZFS_SNAPDIR_VISIBLE;\n\tzfsvfs->z_os = os;\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_VERSION, &zfsvfs->z_version);\n\tif (error != 0)\n\t\treturn (error);\n\tif (zfsvfs->z_version >\n\t    zfs_zpl_version_map(spa_version(dmu_objset_spa(os)))) {\n\t\t(void) printk(\"Can't mount a version %lld file system \"\n\t\t    \"on a version %lld pool\\n. Pool must be upgraded to mount \"\n\t\t    \"this file system.\\n\", (u_longlong_t)zfsvfs->z_version,\n\t\t    (u_longlong_t)spa_version(dmu_objset_spa(os)));\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terror = zfs_get_zplprop(os, ZFS_PROP_NORMALIZE, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_norm = (int)val;\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_UTF8ONLY, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_utf8 = (val != 0);\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_CASE, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_case = (uint_t)val;\n\n\tif ((error = zfs_get_zplprop(os, ZFS_PROP_ACLTYPE, &val)) != 0)\n\t\treturn (error);\n\tzfsvfs->z_acl_type = (uint_t)val;\n\n\t \n\tif (zfsvfs->z_case == ZFS_CASE_INSENSITIVE ||\n\t    zfsvfs->z_case == ZFS_CASE_MIXED)\n\t\tzfsvfs->z_norm |= U8_TEXTPREP_TOUPPER;\n\n\tzfsvfs->z_use_fuids = USE_FUIDS(zfsvfs->z_version, zfsvfs->z_os);\n\tzfsvfs->z_use_sa = USE_SA(zfsvfs->z_version, zfsvfs->z_os);\n\n\tuint64_t sa_obj = 0;\n\tif (zfsvfs->z_use_sa) {\n\t\t \n\t\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_SA_ATTRS, 8, 1,\n\t\t    &sa_obj);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\terror = zfs_get_zplprop(os, ZFS_PROP_XATTR, &val);\n\t\tif ((error == 0) && (val == ZFS_XATTR_SA))\n\t\t\tzfsvfs->z_xattr_sa = B_TRUE;\n\t}\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_ROOT_OBJ, 8, 1,\n\t    &zfsvfs->z_root);\n\tif (error != 0)\n\t\treturn (error);\n\tASSERT(zfsvfs->z_root != 0);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_UNLINKED_SET, 8, 1,\n\t    &zfsvfs->z_unlinkedobj);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_USERQUOTA],\n\t    8, 1, &zfsvfs->z_userquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_userquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_GROUPQUOTA],\n\t    8, 1, &zfsvfs->z_groupquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_groupquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_PROJECTQUOTA],\n\t    8, 1, &zfsvfs->z_projectquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_projectquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_USEROBJQUOTA],\n\t    8, 1, &zfsvfs->z_userobjquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_userobjquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_GROUPOBJQUOTA],\n\t    8, 1, &zfsvfs->z_groupobjquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_groupobjquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_PROJECTOBJQUOTA],\n\t    8, 1, &zfsvfs->z_projectobjquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_projectobjquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_FUID_TABLES, 8, 1,\n\t    &zfsvfs->z_fuid_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_fuid_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_SHARES_DIR, 8, 1,\n\t    &zfsvfs->z_shares_dir);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_shares_dir = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = sa_setup(os, sa_obj, zfs_attr_table, ZPL_END,\n\t    &zfsvfs->z_attr_table);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (zfsvfs->z_version >= ZPL_VERSION_SA)\n\t\tsa_register_update_callback(os, zfs_sa_upgrade);\n\n\treturn (0);\n}\n\nint\nzfsvfs_create(const char *osname, boolean_t readonly, zfsvfs_t **zfvp)\n{\n\tobjset_t *os;\n\tzfsvfs_t *zfsvfs;\n\tint error;\n\tboolean_t ro = (readonly || (strchr(osname, '@') != NULL));\n\n\tzfsvfs = kmem_zalloc(sizeof (zfsvfs_t), KM_SLEEP);\n\n\terror = dmu_objset_own(osname, DMU_OST_ZFS, ro, B_TRUE, zfsvfs, &os);\n\tif (error != 0) {\n\t\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n\t\treturn (error);\n\t}\n\n\terror = zfsvfs_create_impl(zfvp, zfsvfs, os);\n\n\treturn (error);\n}\n\n\n \nint\nzfsvfs_create_impl(zfsvfs_t **zfvp, zfsvfs_t *zfsvfs, objset_t *os)\n{\n\tint error;\n\n\tzfsvfs->z_vfs = NULL;\n\tzfsvfs->z_sb = NULL;\n\tzfsvfs->z_parent = zfsvfs;\n\n\tmutex_init(&zfsvfs->z_znodes_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&zfsvfs->z_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&zfsvfs->z_all_znodes, sizeof (znode_t),\n\t    offsetof(znode_t, z_link_node));\n\tZFS_TEARDOWN_INIT(zfsvfs);\n\trw_init(&zfsvfs->z_teardown_inactive_lock, NULL, RW_DEFAULT, NULL);\n\trw_init(&zfsvfs->z_fuid_lock, NULL, RW_DEFAULT, NULL);\n\n\tint size = MIN(1 << (highbit64(zfs_object_mutex_size) - 1),\n\t    ZFS_OBJ_MTX_MAX);\n\tzfsvfs->z_hold_size = size;\n\tzfsvfs->z_hold_trees = vmem_zalloc(sizeof (avl_tree_t) * size,\n\t    KM_SLEEP);\n\tzfsvfs->z_hold_locks = vmem_zalloc(sizeof (kmutex_t) * size, KM_SLEEP);\n\tfor (int i = 0; i != size; i++) {\n\t\tavl_create(&zfsvfs->z_hold_trees[i], zfs_znode_hold_compare,\n\t\t    sizeof (znode_hold_t), offsetof(znode_hold_t, zh_node));\n\t\tmutex_init(&zfsvfs->z_hold_locks[i], NULL, MUTEX_DEFAULT, NULL);\n\t}\n\n\terror = zfsvfs_init(zfsvfs, os);\n\tif (error != 0) {\n\t\tdmu_objset_disown(os, B_TRUE, zfsvfs);\n\t\t*zfvp = NULL;\n\t\tzfsvfs_free(zfsvfs);\n\t\treturn (error);\n\t}\n\n\tzfsvfs->z_drain_task = TASKQID_INVALID;\n\tzfsvfs->z_draining = B_FALSE;\n\tzfsvfs->z_drain_cancel = B_TRUE;\n\n\t*zfvp = zfsvfs;\n\treturn (0);\n}\n\nstatic int\nzfsvfs_setup(zfsvfs_t *zfsvfs, boolean_t mounting)\n{\n\tint error;\n\tboolean_t readonly = zfs_is_readonly(zfsvfs);\n\n\terror = zfs_register_callbacks(zfsvfs->z_vfs);\n\tif (error)\n\t\treturn (error);\n\n\t \n\tif (mounting) {\n\t\tASSERT3P(zfsvfs->z_kstat.dk_kstats, ==, NULL);\n\t\terror = dataset_kstats_create(&zfsvfs->z_kstat, zfsvfs->z_os);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tzfsvfs->z_log = zil_open(zfsvfs->z_os, zfs_get_data,\n\t\t    &zfsvfs->z_kstat.dk_zil_sums);\n\n\t\t \n\t\tif (readonly != 0) {\n\t\t\treadonly_changed_cb(zfsvfs, B_FALSE);\n\t\t} else {\n\t\t\tzap_stats_t zs;\n\t\t\tif (zap_get_stats(zfsvfs->z_os, zfsvfs->z_unlinkedobj,\n\t\t\t    &zs) == 0) {\n\t\t\t\tdataset_kstats_update_nunlinks_kstat(\n\t\t\t\t    &zfsvfs->z_kstat, zs.zs_num_entries);\n\t\t\t\tdprintf_ds(zfsvfs->z_os->os_dsl_dataset,\n\t\t\t\t    \"num_entries in unlinked set: %llu\",\n\t\t\t\t    zs.zs_num_entries);\n\t\t\t}\n\t\t\tzfs_unlinked_drain(zfsvfs);\n\t\t\tdsl_dir_t *dd = zfsvfs->z_os->os_dsl_dataset->ds_dir;\n\t\t\tdd->dd_activity_cancelled = B_FALSE;\n\t\t}\n\n\t\t \n\t\tif (spa_writeable(dmu_objset_spa(zfsvfs->z_os))) {\n\t\t\tif (zil_replay_disable) {\n\t\t\t\tzil_destroy(zfsvfs->z_log, B_FALSE);\n\t\t\t} else {\n\t\t\t\tzfsvfs->z_replay = B_TRUE;\n\t\t\t\tzil_replay(zfsvfs->z_os, zfsvfs,\n\t\t\t\t    zfs_replay_vector);\n\t\t\t\tzfsvfs->z_replay = B_FALSE;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (readonly != 0)\n\t\t\treadonly_changed_cb(zfsvfs, B_TRUE);\n\t} else {\n\t\tASSERT3P(zfsvfs->z_kstat.dk_kstats, !=, NULL);\n\t\tzfsvfs->z_log = zil_open(zfsvfs->z_os, zfs_get_data,\n\t\t    &zfsvfs->z_kstat.dk_zil_sums);\n\t}\n\n\t \n\tmutex_enter(&zfsvfs->z_os->os_user_ptr_lock);\n\tdmu_objset_set_user(zfsvfs->z_os, zfsvfs);\n\tmutex_exit(&zfsvfs->z_os->os_user_ptr_lock);\n\n\treturn (0);\n}\n\nvoid\nzfsvfs_free(zfsvfs_t *zfsvfs)\n{\n\tint i, size = zfsvfs->z_hold_size;\n\n\tzfs_fuid_destroy(zfsvfs);\n\n\tmutex_destroy(&zfsvfs->z_znodes_lock);\n\tmutex_destroy(&zfsvfs->z_lock);\n\tlist_destroy(&zfsvfs->z_all_znodes);\n\tZFS_TEARDOWN_DESTROY(zfsvfs);\n\trw_destroy(&zfsvfs->z_teardown_inactive_lock);\n\trw_destroy(&zfsvfs->z_fuid_lock);\n\tfor (i = 0; i != size; i++) {\n\t\tavl_destroy(&zfsvfs->z_hold_trees[i]);\n\t\tmutex_destroy(&zfsvfs->z_hold_locks[i]);\n\t}\n\tvmem_free(zfsvfs->z_hold_trees, sizeof (avl_tree_t) * size);\n\tvmem_free(zfsvfs->z_hold_locks, sizeof (kmutex_t) * size);\n\tzfsvfs_vfs_free(zfsvfs->z_vfs);\n\tdataset_kstats_destroy(&zfsvfs->z_kstat);\n\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n}\n\nstatic void\nzfs_set_fuid_feature(zfsvfs_t *zfsvfs)\n{\n\tzfsvfs->z_use_fuids = USE_FUIDS(zfsvfs->z_version, zfsvfs->z_os);\n\tzfsvfs->z_use_sa = USE_SA(zfsvfs->z_version, zfsvfs->z_os);\n}\n\nstatic void\nzfs_unregister_callbacks(zfsvfs_t *zfsvfs)\n{\n\tobjset_t *os = zfsvfs->z_os;\n\n\tif (!dmu_objset_is_snapshot(os))\n\t\tdsl_prop_unregister_all(dmu_objset_ds(os), zfsvfs);\n}\n\n#ifdef HAVE_MLSLABEL\n \nint\nzfs_check_global_label(const char *dsname, const char *hexsl)\n{\n\tif (strcasecmp(hexsl, ZFS_MLSLABEL_DEFAULT) == 0)\n\t\treturn (0);\n\tif (strcasecmp(hexsl, ADMIN_HIGH) == 0)\n\t\treturn (0);\n\tif (strcasecmp(hexsl, ADMIN_LOW) == 0) {\n\t\t \n\t\tuint64_t rdonly;\n\n\t\tif (dsl_prop_get_integer(dsname,\n\t\t    zfs_prop_to_name(ZFS_PROP_READONLY), &rdonly, NULL))\n\t\t\treturn (SET_ERROR(EACCES));\n\t\treturn (rdonly ? 0 : SET_ERROR(EACCES));\n\t}\n\treturn (SET_ERROR(EACCES));\n}\n#endif  \n\nstatic int\nzfs_statfs_project(zfsvfs_t *zfsvfs, znode_t *zp, struct kstatfs *statp,\n    uint32_t bshift)\n{\n\tchar buf[20 + DMU_OBJACCT_PREFIX_LEN];\n\tuint64_t offset = DMU_OBJACCT_PREFIX_LEN;\n\tuint64_t quota;\n\tuint64_t used;\n\tint err;\n\n\tstrlcpy(buf, DMU_OBJACCT_PREFIX, DMU_OBJACCT_PREFIX_LEN + 1);\n\terr = zfs_id_to_fuidstr(zfsvfs, NULL, zp->z_projid, buf + offset,\n\t    sizeof (buf) - offset, B_FALSE);\n\tif (err)\n\t\treturn (err);\n\n\tif (zfsvfs->z_projectquota_obj == 0)\n\t\tgoto objs;\n\n\terr = zap_lookup(zfsvfs->z_os, zfsvfs->z_projectquota_obj,\n\t    buf + offset, 8, 1, &quota);\n\tif (err == ENOENT)\n\t\tgoto objs;\n\telse if (err)\n\t\treturn (err);\n\n\terr = zap_lookup(zfsvfs->z_os, DMU_PROJECTUSED_OBJECT,\n\t    buf + offset, 8, 1, &used);\n\tif (unlikely(err == ENOENT)) {\n\t\tuint32_t blksize;\n\t\tu_longlong_t nblocks;\n\n\t\t \n\t\tsa_object_size(zp->z_sa_hdl, &blksize, &nblocks);\n\t\tif (unlikely(zp->z_blksz == 0))\n\t\t\tblksize = zfsvfs->z_max_blksz;\n\n\t\tused = blksize * nblocks;\n\t} else if (err) {\n\t\treturn (err);\n\t}\n\n\tstatp->f_blocks = quota >> bshift;\n\tstatp->f_bfree = (quota > used) ? ((quota - used) >> bshift) : 0;\n\tstatp->f_bavail = statp->f_bfree;\n\nobjs:\n\tif (zfsvfs->z_projectobjquota_obj == 0)\n\t\treturn (0);\n\n\terr = zap_lookup(zfsvfs->z_os, zfsvfs->z_projectobjquota_obj,\n\t    buf + offset, 8, 1, &quota);\n\tif (err == ENOENT)\n\t\treturn (0);\n\telse if (err)\n\t\treturn (err);\n\n\terr = zap_lookup(zfsvfs->z_os, DMU_PROJECTUSED_OBJECT,\n\t    buf, 8, 1, &used);\n\tif (unlikely(err == ENOENT)) {\n\t\t \n\t\tused = 1;\n\t} else if (err) {\n\t\treturn (err);\n\t}\n\n\tstatp->f_files = quota;\n\tstatp->f_ffree = (quota > used) ? (quota - used) : 0;\n\n\treturn (0);\n}\n\nint\nzfs_statvfs(struct inode *ip, struct kstatfs *statp)\n{\n\tzfsvfs_t *zfsvfs = ITOZSB(ip);\n\tuint64_t refdbytes, availbytes, usedobjs, availobjs;\n\tint err = 0;\n\n\tif ((err = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (err);\n\n\tdmu_objset_space(zfsvfs->z_os,\n\t    &refdbytes, &availbytes, &usedobjs, &availobjs);\n\n\tuint64_t fsid = dmu_objset_fsid_guid(zfsvfs->z_os);\n\t \n\tstatp->f_frsize = zfsvfs->z_max_blksz;\n\tstatp->f_bsize = zfsvfs->z_max_blksz;\n\tuint32_t bshift = fls(statp->f_bsize) - 1;\n\n\t \n\n\t \n\trefdbytes = P2ROUNDUP(refdbytes, statp->f_bsize);\n\tstatp->f_blocks = (refdbytes + availbytes) >> bshift;\n\tstatp->f_bfree = availbytes >> bshift;\n\tstatp->f_bavail = statp->f_bfree;  \n\n\t \n\tstatp->f_ffree = MIN(availobjs, availbytes >> DNODE_SHIFT);\n\tstatp->f_files = statp->f_ffree + usedobjs;\n\tstatp->f_fsid.val[0] = (uint32_t)fsid;\n\tstatp->f_fsid.val[1] = (uint32_t)(fsid >> 32);\n\tstatp->f_type = ZFS_SUPER_MAGIC;\n\tstatp->f_namelen = MAXNAMELEN - 1;\n\n\t \n\tmemset(statp->f_spare, 0, sizeof (statp->f_spare));\n\n\tif (dmu_objset_projectquota_enabled(zfsvfs->z_os) &&\n\t    dmu_objset_projectquota_present(zfsvfs->z_os)) {\n\t\tznode_t *zp = ITOZ(ip);\n\n\t\tif (zp->z_pflags & ZFS_PROJINHERIT && zp->z_projid &&\n\t\t    zpl_is_valid_projid(zp->z_projid))\n\t\t\terr = zfs_statfs_project(zfsvfs, zp, statp, bshift);\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (err);\n}\n\nstatic int\nzfs_root(zfsvfs_t *zfsvfs, struct inode **ipp)\n{\n\tznode_t *rootzp;\n\tint error;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = zfs_zget(zfsvfs, zfsvfs->z_root, &rootzp);\n\tif (error == 0)\n\t\t*ipp = ZTOI(rootzp);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_prune_aliases(zfsvfs_t *zfsvfs, unsigned long nr_to_scan)\n{\n\tznode_t **zp_array, *zp;\n\tint max_array = MIN(nr_to_scan, PAGE_SIZE * 8 / sizeof (znode_t *));\n\tint objects = 0;\n\tint i = 0, j = 0;\n\n\tzp_array = vmem_zalloc(max_array * sizeof (znode_t *), KM_SLEEP);\n\n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\twhile ((zp = list_head(&zfsvfs->z_all_znodes)) != NULL) {\n\n\t\tif ((i++ > nr_to_scan) || (j >= max_array))\n\t\t\tbreak;\n\n\t\tASSERT(list_link_active(&zp->z_link_node));\n\t\tlist_remove(&zfsvfs->z_all_znodes, zp);\n\t\tlist_insert_tail(&zfsvfs->z_all_znodes, zp);\n\n\t\t \n\t\tif (MUTEX_HELD(&zp->z_lock) || zp->z_is_ctldir)\n\t\t\tcontinue;\n\n\t\tif (igrab(ZTOI(zp)) == NULL)\n\t\t\tcontinue;\n\n\t\tzp_array[j] = zp;\n\t\tj++;\n\t}\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n\tfor (i = 0; i < j; i++) {\n\t\tzp = zp_array[i];\n\n\t\tASSERT3P(zp, !=, NULL);\n\t\td_prune_aliases(ZTOI(zp));\n\n\t\tif (atomic_read(&ZTOI(zp)->i_count) == 1)\n\t\t\tobjects++;\n\n\t\tzrele(zp);\n\t}\n\n\tvmem_free(zp_array, max_array * sizeof (znode_t *));\n\n\treturn (objects);\n}\n\n \nint\nzfs_prune(struct super_block *sb, unsigned long nr_to_scan, int *objects)\n{\n\tzfsvfs_t *zfsvfs = sb->s_fs_info;\n\tint error = 0;\n\tstruct shrinker *shrinker = &sb->s_shrink;\n\tstruct shrink_control sc = {\n\t\t.nr_to_scan = nr_to_scan,\n\t\t.gfp_mask = GFP_KERNEL,\n\t};\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n#if defined(HAVE_SPLIT_SHRINKER_CALLBACK) && \\\n\tdefined(SHRINK_CONTROL_HAS_NID) && \\\n\tdefined(SHRINKER_NUMA_AWARE)\n\tif (sb->s_shrink.flags & SHRINKER_NUMA_AWARE) {\n\t\t*objects = 0;\n\t\tfor_each_online_node(sc.nid) {\n\t\t\t*objects += (*shrinker->scan_objects)(shrinker, &sc);\n\t\t\t \n\t\t\tsc.nr_to_scan = nr_to_scan;\n\t\t}\n\t} else {\n\t\t\t*objects = (*shrinker->scan_objects)(shrinker, &sc);\n\t}\n\n#elif defined(HAVE_SPLIT_SHRINKER_CALLBACK)\n\t*objects = (*shrinker->scan_objects)(shrinker, &sc);\n#elif defined(HAVE_SINGLE_SHRINKER_CALLBACK)\n\t*objects = (*shrinker->shrink)(shrinker, &sc);\n#elif defined(HAVE_D_PRUNE_ALIASES)\n#define\tD_PRUNE_ALIASES_IS_DEFAULT\n\t*objects = zfs_prune_aliases(zfsvfs, nr_to_scan);\n#else\n#error \"No available dentry and inode cache pruning mechanism.\"\n#endif\n\n#if defined(HAVE_D_PRUNE_ALIASES) && !defined(D_PRUNE_ALIASES_IS_DEFAULT)\n#undef\tD_PRUNE_ALIASES_IS_DEFAULT\n\t \n\tif (*objects == 0)\n\t\t*objects = zfs_prune_aliases(zfsvfs, nr_to_scan);\n#endif\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\tdprintf_ds(zfsvfs->z_os->os_dsl_dataset,\n\t    \"pruning, nr_to_scan=%lu objects=%d error=%d\\n\",\n\t    nr_to_scan, *objects, error);\n\n\treturn (error);\n}\n\n \nstatic int\nzfsvfs_teardown(zfsvfs_t *zfsvfs, boolean_t unmounting)\n{\n\tznode_t\t*zp;\n\n\tzfs_unlinked_drain_stop_wait(zfsvfs);\n\n\t \n\tif (zfsvfs->z_os) {\n\t\t \n\t\tint round = 0;\n\t\twhile (!list_is_empty(&zfsvfs->z_all_znodes)) {\n\t\t\ttaskq_wait_outstanding(dsl_pool_zrele_taskq(\n\t\t\t    dmu_objset_pool(zfsvfs->z_os)), 0);\n\t\t\tif (++round > 1 && !unmounting)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tZFS_TEARDOWN_ENTER_WRITE(zfsvfs, FTAG);\n\n\tif (!unmounting) {\n\t\t \n\t\tshrink_dcache_sb(zfsvfs->z_parent->z_sb);\n\t}\n\n\t \n\tif (zfsvfs->z_log) {\n\t\tzil_close(zfsvfs->z_log);\n\t\tzfsvfs->z_log = NULL;\n\t}\n\n\trw_enter(&zfsvfs->z_teardown_inactive_lock, RW_WRITER);\n\n\t \n\tif (!unmounting && (zfsvfs->z_unmounted || zfsvfs->z_os == NULL)) {\n\t\trw_exit(&zfsvfs->z_teardown_inactive_lock);\n\t\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t \n\tif (!unmounting) {\n\t\tmutex_enter(&zfsvfs->z_znodes_lock);\n\t\tfor (zp = list_head(&zfsvfs->z_all_znodes); zp != NULL;\n\t\t    zp = list_next(&zfsvfs->z_all_znodes, zp)) {\n\t\t\tif (zp->z_sa_hdl)\n\t\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tif (igrab(ZTOI(zp)) != NULL)\n\t\t\t\tzp->z_suspended = B_TRUE;\n\n\t\t}\n\t\tmutex_exit(&zfsvfs->z_znodes_lock);\n\t}\n\n\t \n\tif (unmounting) {\n\t\tzfsvfs->z_unmounted = B_TRUE;\n\t\trw_exit(&zfsvfs->z_teardown_inactive_lock);\n\t\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\t}\n\n\t \n\tif (zfsvfs->z_os == NULL)\n\t\treturn (0);\n\n\t \n\tzfs_unregister_callbacks(zfsvfs);\n\n\t \n\tobjset_t *os = zfsvfs->z_os;\n\tboolean_t os_dirty = B_FALSE;\n\tfor (int t = 0; t < TXG_SIZE; t++) {\n\t\tif (dmu_objset_is_dirty(os, t)) {\n\t\t\tos_dirty = B_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!zfs_is_readonly(zfsvfs) && os_dirty) {\n\t\ttxg_wait_synced(dmu_objset_pool(zfsvfs->z_os), 0);\n\t}\n\tdmu_objset_evict_dbufs(zfsvfs->z_os);\n\tdsl_dir_t *dd = os->os_dsl_dataset->ds_dir;\n\tdsl_dir_cancel_waiters(dd);\n\n\treturn (0);\n}\n\n#if defined(HAVE_SUPER_SETUP_BDI_NAME)\natomic_long_t zfs_bdi_seq = ATOMIC_LONG_INIT(0);\n#endif\n\nint\nzfs_domount(struct super_block *sb, zfs_mnt_t *zm, int silent)\n{\n\tconst char *osname = zm->mnt_osname;\n\tstruct inode *root_inode = NULL;\n\tuint64_t recordsize;\n\tint error = 0;\n\tzfsvfs_t *zfsvfs = NULL;\n\tvfs_t *vfs = NULL;\n\tint canwrite;\n\tint dataset_visible_zone;\n\n\tASSERT(zm);\n\tASSERT(osname);\n\n\tdataset_visible_zone = zone_dataset_visible(osname, &canwrite);\n\n\t \n\tif (!INGLOBALZONE(curproc) &&\n\t    (!dataset_visible_zone || !canwrite)) {\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\terror = zfsvfs_parse_options(zm->mnt_data, &vfs);\n\tif (error)\n\t\treturn (error);\n\n\t \n\tif (!canwrite)\n\t\tvfs->vfs_readonly = B_TRUE;\n\n\terror = zfsvfs_create(osname, vfs->vfs_readonly, &zfsvfs);\n\tif (error) {\n\t\tzfsvfs_vfs_free(vfs);\n\t\tgoto out;\n\t}\n\n\tif ((error = dsl_prop_get_integer(osname, \"recordsize\",\n\t    &recordsize, NULL))) {\n\t\tzfsvfs_vfs_free(vfs);\n\t\tgoto out;\n\t}\n\n\tvfs->vfs_data = zfsvfs;\n\tzfsvfs->z_vfs = vfs;\n\tzfsvfs->z_sb = sb;\n\tsb->s_fs_info = zfsvfs;\n\tsb->s_magic = ZFS_SUPER_MAGIC;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_time_gran = 1;\n\tsb->s_blocksize = recordsize;\n\tsb->s_blocksize_bits = ilog2(recordsize);\n\n\terror = -zpl_bdi_setup(sb, \"zfs\");\n\tif (error)\n\t\tgoto out;\n\n\tsb->s_bdi->ra_pages = 0;\n\n\t \n\tsb->s_op = &zpl_super_operations;\n\tsb->s_xattr = zpl_xattr_handlers;\n\tsb->s_export_op = &zpl_export_operations;\n\n\t \n\tzfs_set_fuid_feature(zfsvfs);\n\n\tif (dmu_objset_is_snapshot(zfsvfs->z_os)) {\n\t\tuint64_t pval;\n\n\t\tatime_changed_cb(zfsvfs, B_FALSE);\n\t\treadonly_changed_cb(zfsvfs, B_TRUE);\n\t\tif ((error = dsl_prop_get_integer(osname,\n\t\t    \"xattr\", &pval, NULL)))\n\t\t\tgoto out;\n\t\txattr_changed_cb(zfsvfs, pval);\n\t\tif ((error = dsl_prop_get_integer(osname,\n\t\t    \"acltype\", &pval, NULL)))\n\t\t\tgoto out;\n\t\tacltype_changed_cb(zfsvfs, pval);\n\t\tzfsvfs->z_issnap = B_TRUE;\n\t\tzfsvfs->z_os->os_sync = ZFS_SYNC_DISABLED;\n\t\tzfsvfs->z_snap_defer_time = jiffies;\n\n\t\tmutex_enter(&zfsvfs->z_os->os_user_ptr_lock);\n\t\tdmu_objset_set_user(zfsvfs->z_os, zfsvfs);\n\t\tmutex_exit(&zfsvfs->z_os->os_user_ptr_lock);\n\t} else {\n\t\tif ((error = zfsvfs_setup(zfsvfs, B_TRUE)))\n\t\t\tgoto out;\n\t}\n\n\t \n\terror = zfs_root(zfsvfs, &root_inode);\n\tif (error) {\n\t\t(void) zfs_umount(sb);\n\t\tzfsvfs = NULL;  \n\t\tgoto out;\n\t}\n\n\t \n\tsb->s_root = d_make_root(root_inode);\n\tif (sb->s_root == NULL) {\n\t\t(void) zfs_umount(sb);\n\t\tzfsvfs = NULL;  \n\t\terror = SET_ERROR(ENOMEM);\n\t\tgoto out;\n\t}\n\n\tif (!zfsvfs->z_issnap)\n\t\tzfsctl_create(zfsvfs);\n\n\tzfsvfs->z_arc_prune = arc_add_prune_callback(zpl_prune_sb, sb);\nout:\n\tif (error) {\n\t\tif (zfsvfs != NULL) {\n\t\t\tdmu_objset_disown(zfsvfs->z_os, B_TRUE, zfsvfs);\n\t\t\tzfsvfs_free(zfsvfs);\n\t\t}\n\t\t \n\t\tsb->s_fs_info = NULL;\n\t}\n\n\treturn (error);\n}\n\n \nvoid\nzfs_preumount(struct super_block *sb)\n{\n\tzfsvfs_t *zfsvfs = sb->s_fs_info;\n\n\t \n\tif (zfsvfs) {\n\t\tzfs_unlinked_drain_stop_wait(zfsvfs);\n\t\tzfsctl_destroy(sb->s_fs_info);\n\t\t \n\t\ttaskq_wait_outstanding(dsl_pool_zrele_taskq(\n\t\t    dmu_objset_pool(zfsvfs->z_os)), 0);\n\t\ttaskq_wait_outstanding(dsl_pool_zrele_taskq(\n\t\t    dmu_objset_pool(zfsvfs->z_os)), 0);\n\t}\n}\n\n \nint\nzfs_umount(struct super_block *sb)\n{\n\tzfsvfs_t *zfsvfs = sb->s_fs_info;\n\tobjset_t *os;\n\n\tif (zfsvfs->z_arc_prune != NULL)\n\t\tarc_remove_prune_callback(zfsvfs->z_arc_prune);\n\tVERIFY(zfsvfs_teardown(zfsvfs, B_TRUE) == 0);\n\tos = zfsvfs->z_os;\n\tzpl_bdi_destroy(sb);\n\n\t \n\tif (os != NULL) {\n\t\t \n\t\tmutex_enter(&os->os_user_ptr_lock);\n\t\tdmu_objset_set_user(os, NULL);\n\t\tmutex_exit(&os->os_user_ptr_lock);\n\n\t\t \n\t\tdmu_objset_disown(os, B_TRUE, zfsvfs);\n\t}\n\n\tzfsvfs_free(zfsvfs);\n\tsb->s_fs_info = NULL;\n\treturn (0);\n}\n\nint\nzfs_remount(struct super_block *sb, int *flags, zfs_mnt_t *zm)\n{\n\tzfsvfs_t *zfsvfs = sb->s_fs_info;\n\tvfs_t *vfsp;\n\tboolean_t issnap = dmu_objset_is_snapshot(zfsvfs->z_os);\n\tint error;\n\n\tif ((issnap || !spa_writeable(dmu_objset_spa(zfsvfs->z_os))) &&\n\t    !(*flags & SB_RDONLY)) {\n\t\t*flags |= SB_RDONLY;\n\t\treturn (EROFS);\n\t}\n\n\terror = zfsvfs_parse_options(zm->mnt_data, &vfsp);\n\tif (error)\n\t\treturn (error);\n\n\tif (!zfs_is_readonly(zfsvfs) && (*flags & SB_RDONLY))\n\t\ttxg_wait_synced(dmu_objset_pool(zfsvfs->z_os), 0);\n\n\tzfs_unregister_callbacks(zfsvfs);\n\tzfsvfs_vfs_free(zfsvfs->z_vfs);\n\n\tvfsp->vfs_data = zfsvfs;\n\tzfsvfs->z_vfs = vfsp;\n\tif (!issnap)\n\t\t(void) zfs_register_callbacks(vfsp);\n\n\treturn (error);\n}\n\nint\nzfs_vget(struct super_block *sb, struct inode **ipp, fid_t *fidp)\n{\n\tzfsvfs_t\t*zfsvfs = sb->s_fs_info;\n\tznode_t\t\t*zp;\n\tuint64_t\tobject = 0;\n\tuint64_t\tfid_gen = 0;\n\tuint64_t\tgen_mask;\n\tuint64_t\tzp_gen;\n\tint\t\ti, err;\n\n\t*ipp = NULL;\n\n\tif (fidp->fid_len == SHORT_FID_LEN || fidp->fid_len == LONG_FID_LEN) {\n\t\tzfid_short_t\t*zfid = (zfid_short_t *)fidp;\n\n\t\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\t\tobject |= ((uint64_t)zfid->zf_object[i]) << (8 * i);\n\n\t\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\t\tfid_gen |= ((uint64_t)zfid->zf_gen[i]) << (8 * i);\n\t} else {\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (fidp->fid_len == LONG_FID_LEN) {\n\t\tzfid_long_t\t*zlfid = (zfid_long_t *)fidp;\n\t\tuint64_t\tobjsetid = 0;\n\t\tuint64_t\tsetgen = 0;\n\n\t\tfor (i = 0; i < sizeof (zlfid->zf_setid); i++)\n\t\t\tobjsetid |= ((uint64_t)zlfid->zf_setid[i]) << (8 * i);\n\n\t\tfor (i = 0; i < sizeof (zlfid->zf_setgen); i++)\n\t\t\tsetgen |= ((uint64_t)zlfid->zf_setgen[i]) << (8 * i);\n\n\t\tif (objsetid != ZFSCTL_INO_SNAPDIRS - object) {\n\t\t\tdprintf(\"snapdir fid: objsetid (%llu) != \"\n\t\t\t    \"ZFSCTL_INO_SNAPDIRS (%llu) - object (%llu)\\n\",\n\t\t\t    objsetid, ZFSCTL_INO_SNAPDIRS, object);\n\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tif (fid_gen > 1 || setgen != 0) {\n\t\t\tdprintf(\"snapdir fid: fid_gen (%llu) and setgen \"\n\t\t\t    \"(%llu)\\n\", fid_gen, setgen);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\treturn (zfsctl_snapdir_vget(sb, objsetid, fid_gen, ipp));\n\t}\n\n\tif ((err = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (err);\n\t \n\tif (fid_gen == 0 &&\n\t    (object == ZFSCTL_INO_ROOT || object == ZFSCTL_INO_SNAPDIR)) {\n\t\t*ipp = zfsvfs->z_ctldir;\n\t\tASSERT(*ipp != NULL);\n\t\tif (object == ZFSCTL_INO_SNAPDIR) {\n\t\t\tVERIFY(zfsctl_root_lookup(*ipp, \"snapshot\", ipp,\n\t\t\t    0, kcred, NULL, NULL) == 0);\n\t\t} else {\n\t\t\t \n\t\t\tVERIFY3P(igrab(*ipp), !=, NULL);\n\t\t}\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\tgen_mask = -1ULL >> (64 - 8 * i);\n\n\tdprintf(\"getting %llu [%llu mask %llx]\\n\", object, fid_gen, gen_mask);\n\tif ((err = zfs_zget(zfsvfs, object, &zp))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (err);\n\t}\n\n\t \n\tif (zp->z_pflags & ZFS_XATTR) {\n\t\tzrele(zp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(zfsvfs), &zp_gen,\n\t    sizeof (uint64_t));\n\tzp_gen = zp_gen & gen_mask;\n\tif (zp_gen == 0)\n\t\tzp_gen = 1;\n\tif ((fid_gen == 0) && (zfsvfs->z_root == object))\n\t\tfid_gen = zp_gen;\n\tif (zp->z_unlinked || zp_gen != fid_gen) {\n\t\tdprintf(\"znode gen (%llu) != fid gen (%llu)\\n\", zp_gen,\n\t\t    fid_gen);\n\t\tzrele(zp);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\t*ipp = ZTOI(zp);\n\tif (*ipp)\n\t\tzfs_znode_update_vfs(ITOZ(*ipp));\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n \nint\nzfs_suspend_fs(zfsvfs_t *zfsvfs)\n{\n\tint error;\n\n\tif ((error = zfsvfs_teardown(zfsvfs, B_FALSE)) != 0)\n\t\treturn (error);\n\n\treturn (0);\n}\n\n \nint\nzfs_resume_fs(zfsvfs_t *zfsvfs, dsl_dataset_t *ds)\n{\n\tint err, err2;\n\tznode_t *zp;\n\n\tASSERT(ZFS_TEARDOWN_WRITE_HELD(zfsvfs));\n\tASSERT(RW_WRITE_HELD(&zfsvfs->z_teardown_inactive_lock));\n\n\t \n\tobjset_t *os;\n\tVERIFY3P(ds->ds_owner, ==, zfsvfs);\n\tVERIFY(dsl_dataset_long_held(ds));\n\tdsl_pool_t *dp = spa_get_dsl(dsl_dataset_get_spa(ds));\n\tdsl_pool_config_enter(dp, FTAG);\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tdsl_pool_config_exit(dp, FTAG);\n\n\terr = zfsvfs_init(zfsvfs, os);\n\tif (err != 0)\n\t\tgoto bail;\n\n\tds->ds_dir->dd_activity_cancelled = B_FALSE;\n\tVERIFY(zfsvfs_setup(zfsvfs, B_FALSE) == 0);\n\n\tzfs_set_fuid_feature(zfsvfs);\n\tzfsvfs->z_rollback_time = jiffies;\n\n\t \n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tfor (zp = list_head(&zfsvfs->z_all_znodes); zp;\n\t    zp = list_next(&zfsvfs->z_all_znodes, zp)) {\n\t\terr2 = zfs_rezget(zp);\n\t\tif (err2) {\n\t\t\tzpl_d_drop_aliases(ZTOI(zp));\n\t\t\tremove_inode_hash(ZTOI(zp));\n\t\t}\n\n\t\t \n\t\tif (zp->z_suspended) {\n\t\t\tzfs_zrele_async(zp);\n\t\t\tzp->z_suspended = B_FALSE;\n\t\t}\n\t}\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n\tif (!zfs_is_readonly(zfsvfs) && !zfsvfs->z_unmounted) {\n\t\t \n\t\tzfs_unlinked_drain(zfsvfs);\n\t}\n\n\t \n\tshrink_dcache_sb(zfsvfs->z_sb);\n\nbail:\n\tif (err != 0)\n\t\tzfsvfs->z_unmounted = B_TRUE;\n\n\t \n\trw_exit(&zfsvfs->z_teardown_inactive_lock);\n\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\n\tif (err != 0) {\n\t\t \n\t\tif (zfsvfs->z_os)\n\t\t\t(void) zfs_umount(zfsvfs->z_sb);\n\t}\n\treturn (err);\n}\n\n \nint\nzfs_end_fs(zfsvfs_t *zfsvfs, dsl_dataset_t *ds)\n{\n\tASSERT(ZFS_TEARDOWN_WRITE_HELD(zfsvfs));\n\tASSERT(RW_WRITE_HELD(&zfsvfs->z_teardown_inactive_lock));\n\n\t \n\tobjset_t *os;\n\tVERIFY3P(ds->ds_owner, ==, zfsvfs);\n\tVERIFY(dsl_dataset_long_held(ds));\n\tdsl_pool_t *dp = spa_get_dsl(dsl_dataset_get_spa(ds));\n\tdsl_pool_config_enter(dp, FTAG);\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tdsl_pool_config_exit(dp, FTAG);\n\tzfsvfs->z_os = os;\n\n\t \n\trw_exit(&zfsvfs->z_teardown_inactive_lock);\n\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\n\t \n\t(void) zfs_umount(zfsvfs->z_sb);\n\tzfsvfs->z_unmounted = B_TRUE;\n\treturn (0);\n}\n\n \n\ninline void\nzfs_exit_fs(zfsvfs_t *zfsvfs)\n{\n\tif (!zfsvfs->z_issnap)\n\t\treturn;\n\n\tif (time_after(jiffies, zfsvfs->z_snap_defer_time +\n\t    MAX(zfs_expire_snapshot * HZ / 2, HZ))) {\n\t\tzfsvfs->z_snap_defer_time = jiffies;\n\t\tzfsctl_snapshot_unmount_delay(zfsvfs->z_os->os_spa,\n\t\t    dmu_objset_id(zfsvfs->z_os),\n\t\t    zfs_expire_snapshot);\n\t}\n}\n\nint\nzfs_set_version(zfsvfs_t *zfsvfs, uint64_t newvers)\n{\n\tint error;\n\tobjset_t *os = zfsvfs->z_os;\n\tdmu_tx_t *tx;\n\n\tif (newvers < ZPL_VERSION_INITIAL || newvers > ZPL_VERSION)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (newvers < zfsvfs->z_version)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zfs_spa_version_map(newvers) >\n\t    spa_version(dmu_objset_spa(zfsvfs->z_os)))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_zap(tx, MASTER_NODE_OBJ, B_FALSE, ZPL_VERSION_STR);\n\tif (newvers >= ZPL_VERSION_SA && !zfsvfs->z_use_sa) {\n\t\tdmu_tx_hold_zap(tx, MASTER_NODE_OBJ, B_TRUE,\n\t\t    ZFS_SA_ATTRS);\n\t\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, FALSE, NULL);\n\t}\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (error);\n\t}\n\n\terror = zap_update(os, MASTER_NODE_OBJ, ZPL_VERSION_STR,\n\t    8, 1, &newvers, tx);\n\n\tif (error) {\n\t\tdmu_tx_commit(tx);\n\t\treturn (error);\n\t}\n\n\tif (newvers >= ZPL_VERSION_SA && !zfsvfs->z_use_sa) {\n\t\tuint64_t sa_obj;\n\n\t\tASSERT3U(spa_version(dmu_objset_spa(zfsvfs->z_os)), >=,\n\t\t    SPA_VERSION_SA);\n\t\tsa_obj = zap_create(os, DMU_OT_SA_MASTER_NODE,\n\t\t    DMU_OT_NONE, 0, tx);\n\n\t\terror = zap_add(os, MASTER_NODE_OBJ,\n\t\t    ZFS_SA_ATTRS, 8, 1, &sa_obj, tx);\n\t\tASSERT0(error);\n\n\t\tVERIFY(0 == sa_set_sa_object(os, sa_obj));\n\t\tsa_register_update_callback(os, zfs_sa_upgrade);\n\t}\n\n\tspa_history_log_internal_ds(dmu_objset_ds(os), \"upgrade\", tx,\n\t    \"from %llu to %llu\", zfsvfs->z_version, newvers);\n\n\tdmu_tx_commit(tx);\n\n\tzfsvfs->z_version = newvers;\n\tos->os_version = newvers;\n\n\tzfs_set_fuid_feature(zfsvfs);\n\n\treturn (0);\n}\n\n \nboolean_t\nzfs_get_vfs_flag_unmounted(objset_t *os)\n{\n\tzfsvfs_t *zfvp;\n\tboolean_t unmounted = B_FALSE;\n\n\tASSERT(dmu_objset_type(os) == DMU_OST_ZFS);\n\n\tmutex_enter(&os->os_user_ptr_lock);\n\tzfvp = dmu_objset_get_user(os);\n\tif (zfvp != NULL && zfvp->z_unmounted)\n\t\tunmounted = B_TRUE;\n\tmutex_exit(&os->os_user_ptr_lock);\n\n\treturn (unmounted);\n}\n\nvoid\nzfsvfs_update_fromname(const char *oldname, const char *newname)\n{\n\t \n\t(void) oldname, (void) newname;\n}\n\nvoid\nzfs_init(void)\n{\n\tzfsctl_init();\n\tzfs_znode_init();\n\tdmu_objset_register_type(DMU_OST_ZFS, zpl_get_file_info);\n\tregister_filesystem(&zpl_fs_type);\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\n\tregister_fo_extend(&zpl_file_operations);\n#endif\n}\n\nvoid\nzfs_fini(void)\n{\n\t \n\ttaskq_wait(system_delay_taskq);\n\ttaskq_wait(system_taskq);\n#ifdef HAVE_VFS_FILE_OPERATIONS_EXTEND\n\tunregister_fo_extend(&zpl_file_operations);\n#endif\n\tunregister_filesystem(&zpl_fs_type);\n\tzfs_znode_fini();\n\tzfsctl_fini();\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zfs_suspend_fs);\nEXPORT_SYMBOL(zfs_resume_fs);\nEXPORT_SYMBOL(zfs_set_version);\nEXPORT_SYMBOL(zfsvfs_create);\nEXPORT_SYMBOL(zfsvfs_free);\nEXPORT_SYMBOL(zfs_is_readonly);\nEXPORT_SYMBOL(zfs_domount);\nEXPORT_SYMBOL(zfs_preumount);\nEXPORT_SYMBOL(zfs_umount);\nEXPORT_SYMBOL(zfs_remount);\nEXPORT_SYMBOL(zfs_statvfs);\nEXPORT_SYMBOL(zfs_vget);\nEXPORT_SYMBOL(zfs_prune);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}