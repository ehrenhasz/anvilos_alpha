{
  "module_name": "zfs_file_os.c",
  "hash_id": "3757dfb4ab462b5e7874fe6e919ad3311fc76d7bf07acad4ab7e43ad6d75a200",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_file_os.c",
  "human_readable_source": " \n\n#include <sys/zfs_context.h>\n#include <sys/zfs_file.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <linux/falloc.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#ifdef HAVE_FDTABLE_HEADER\n#include <linux/fdtable.h>\n#endif\n\n \nint\nzfs_file_open(const char *path, int flags, int mode, zfs_file_t **fpp)\n{\n\tstruct file *filp;\n\tint saved_umask;\n\n\tif (!(flags & O_CREAT) && (flags & O_WRONLY))\n\t\tflags |= O_EXCL;\n\n\tif (flags & O_CREAT)\n\t\tsaved_umask = xchg(&current->fs->umask, 0);\n\n\tfilp = filp_open(path, flags, mode);\n\n\tif (flags & O_CREAT)\n\t\t(void) xchg(&current->fs->umask, saved_umask);\n\n\tif (IS_ERR(filp))\n\t\treturn (-PTR_ERR(filp));\n\n\t*fpp = filp;\n\treturn (0);\n}\n\nvoid\nzfs_file_close(zfs_file_t *fp)\n{\n\tfilp_close(fp, 0);\n}\n\nstatic ssize_t\nzfs_file_write_impl(zfs_file_t *fp, const void *buf, size_t count, loff_t *off)\n{\n#if defined(HAVE_KERNEL_WRITE_PPOS)\n\treturn (kernel_write(fp, buf, count, off));\n#else\n\tmm_segment_t saved_fs;\n\tssize_t rc;\n\n\tsaved_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\trc = vfs_write(fp, (__force const char __user __user *)buf, count, off);\n\n\tset_fs(saved_fs);\n\n\treturn (rc);\n#endif\n}\n\n \nint\nzfs_file_write(zfs_file_t *fp, const void *buf, size_t count, ssize_t *resid)\n{\n\tloff_t off = fp->f_pos;\n\tssize_t rc;\n\n\trc = zfs_file_write_impl(fp, buf, count, &off);\n\tif (rc < 0)\n\t\treturn (-rc);\n\n\tfp->f_pos = off;\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_pwrite(zfs_file_t *fp, const void *buf, size_t count, loff_t off,\n    ssize_t *resid)\n{\n\tssize_t rc;\n\n\trc  = zfs_file_write_impl(fp, buf, count, &off);\n\tif (rc < 0)\n\t\treturn (-rc);\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\nstatic ssize_t\nzfs_file_read_impl(zfs_file_t *fp, void *buf, size_t count, loff_t *off)\n{\n#if defined(HAVE_KERNEL_READ_PPOS)\n\treturn (kernel_read(fp, buf, count, off));\n#else\n\tmm_segment_t saved_fs;\n\tssize_t rc;\n\n\tsaved_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\trc = vfs_read(fp, (void __user *)buf, count, off);\n\tset_fs(saved_fs);\n\n\treturn (rc);\n#endif\n}\n\n \nint\nzfs_file_read(zfs_file_t *fp, void *buf, size_t count, ssize_t *resid)\n{\n\tloff_t off = fp->f_pos;\n\tssize_t rc;\n\n\trc = zfs_file_read_impl(fp, buf, count, &off);\n\tif (rc < 0)\n\t\treturn (-rc);\n\n\tfp->f_pos = off;\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_pread(zfs_file_t *fp, void *buf, size_t count, loff_t off,\n    ssize_t *resid)\n{\n\tssize_t rc;\n\n\trc = zfs_file_read_impl(fp, buf, count, &off);\n\tif (rc < 0)\n\t\treturn (-rc);\n\n\tif (resid) {\n\t\t*resid = count - rc;\n\t} else if (rc != count) {\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}\n\n \nint\nzfs_file_seek(zfs_file_t *fp, loff_t *offp, int whence)\n{\n\tloff_t rc;\n\n\tif (*offp < 0)\n\t\treturn (EINVAL);\n\n\trc = vfs_llseek(fp, *offp, whence);\n\tif (rc < 0)\n\t\treturn (-rc);\n\n\t*offp = rc;\n\n\treturn (0);\n}\n\n \nint\nzfs_file_getattr(zfs_file_t *filp, zfs_file_attr_t *zfattr)\n{\n\tstruct kstat stat;\n\tint rc;\n\n#if defined(HAVE_4ARGS_VFS_GETATTR)\n\trc = vfs_getattr(&filp->f_path, &stat, STATX_BASIC_STATS,\n\t    AT_STATX_SYNC_AS_STAT);\n#elif defined(HAVE_2ARGS_VFS_GETATTR)\n\trc = vfs_getattr(&filp->f_path, &stat);\n#elif defined(HAVE_3ARGS_VFS_GETATTR)\n\trc = vfs_getattr(filp->f_path.mnt, filp->f_dentry, &stat);\n#else\n#error \"No available vfs_getattr()\"\n#endif\n\tif (rc)\n\t\treturn (-rc);\n\n\tzfattr->zfa_size = stat.size;\n\tzfattr->zfa_mode = stat.mode;\n\n\treturn (0);\n}\n\n \nint\nzfs_file_fsync(zfs_file_t *filp, int flags)\n{\n\tint datasync = 0;\n\tint error;\n\tint fstrans;\n\n\tif (flags & O_DSYNC)\n\t\tdatasync = 1;\n\n\t \n\tfstrans = __spl_pf_fstrans_check();\n\tif (fstrans)\n\t\tcurrent->flags &= ~(__SPL_PF_FSTRANS);\n\n\terror = -vfs_fsync(filp, datasync);\n\n\tif (fstrans)\n\t\tcurrent->flags |= __SPL_PF_FSTRANS;\n\n\treturn (error);\n}\n\n \nint\nzfs_file_fallocate(zfs_file_t *fp, int mode, loff_t offset, loff_t len)\n{\n\t \n\tint fstrans = __spl_pf_fstrans_check();\n\tif (fstrans)\n\t\tcurrent->flags &= ~(__SPL_PF_FSTRANS);\n\n\t \n\tint error = EOPNOTSUPP;\n\tif (fp->f_op->fallocate)\n\t\terror = fp->f_op->fallocate(fp, mode, offset, len);\n\n\tif (fstrans)\n\t\tcurrent->flags |= __SPL_PF_FSTRANS;\n\n\treturn (error);\n}\n\n \nloff_t\nzfs_file_off(zfs_file_t *fp)\n{\n\treturn (fp->f_pos);\n}\n\n \nvoid *\nzfs_file_private(zfs_file_t *fp)\n{\n\treturn (fp->private_data);\n}\n\n \nint\nzfs_file_unlink(const char *path)\n{\n\treturn (EOPNOTSUPP);\n}\n\n \nzfs_file_t *\nzfs_file_get(int fd)\n{\n\treturn (fget(fd));\n}\n\n \nvoid\nzfs_file_put(zfs_file_t *fp)\n{\n\tfput(fp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}