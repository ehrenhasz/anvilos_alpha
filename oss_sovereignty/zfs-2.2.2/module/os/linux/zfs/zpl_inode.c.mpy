{
  "module_name": "zpl_inode.c",
  "hash_id": "82da39cff920180fbc609035e4c5fcc486b9afd726a616312e1b9d0d5d7962d6",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zpl_inode.c",
  "human_readable_source": " \n \n\n\n#include <sys/sysmacros.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_znode.h>\n#include <sys/dmu_objset.h>\n#include <sys/vfs.h>\n#include <sys/zpl.h>\n#include <sys/file.h>\n\nstatic struct dentry *\nzpl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tcred_t *cr = CRED();\n\tstruct inode *ip;\n\tznode_t *zp;\n\tint error;\n\tfstrans_cookie_t cookie;\n\tpathname_t *ppn = NULL;\n\tpathname_t pn;\n\tint zfs_flags = 0;\n\tzfsvfs_t *zfsvfs = dentry->d_sb->s_fs_info;\n\n\tif (dlen(dentry) >= ZAP_MAXNAMELEN)\n\t\treturn (ERR_PTR(-ENAMETOOLONG));\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\n\t \n\tif (zfsvfs->z_case == ZFS_CASE_INSENSITIVE) {\n\t\tzfs_flags = FIGNORECASE;\n\t\tpn_alloc(&pn);\n\t\tppn = &pn;\n\t}\n\n\terror = -zfs_lookup(ITOZ(dir), dname(dentry), &zp,\n\t    zfs_flags, cr, NULL, ppn);\n\tspl_fstrans_unmark(cookie);\n\tASSERT3S(error, <=, 0);\n\tcrfree(cr);\n\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_time = jiffies;\n\tspin_unlock(&dentry->d_lock);\n\n\tif (error) {\n\t\t \n\t\tif (ppn) {\n\t\t\tpn_free(ppn);\n\t\t\tif (error == -ENOENT)\n\t\t\t\treturn (NULL);\n\t\t}\n\n\t\tif (error == -ENOENT)\n\t\t\treturn (d_splice_alias(NULL, dentry));\n\t\telse\n\t\t\treturn (ERR_PTR(error));\n\t}\n\tip = ZTOI(zp);\n\n\t \n\tif (ppn) {\n\t\tstruct dentry *new_dentry;\n\t\tstruct qstr ci_name;\n\n\t\tif (strcmp(dname(dentry), pn.pn_buf) == 0) {\n\t\t\tnew_dentry = d_splice_alias(ip,  dentry);\n\t\t} else {\n\t\t\tci_name.name = pn.pn_buf;\n\t\t\tci_name.len = strlen(pn.pn_buf);\n\t\t\tnew_dentry = d_add_ci(dentry, ip, &ci_name);\n\t\t}\n\t\tpn_free(ppn);\n\t\treturn (new_dentry);\n\t} else {\n\t\treturn (d_splice_alias(ip, dentry));\n\t}\n}\n\nvoid\nzpl_vap_init(vattr_t *vap, struct inode *dir, umode_t mode, cred_t *cr,\n    zidmap_t *mnt_ns)\n{\n\tvap->va_mask = ATTR_MODE;\n\tvap->va_mode = mode;\n\n\tvap->va_uid = zfs_vfsuid_to_uid(mnt_ns,\n\t    zfs_i_user_ns(dir), crgetuid(cr));\n\n\tif (dir->i_mode & S_ISGID) {\n\t\tvap->va_gid = KGID_TO_SGID(dir->i_gid);\n\t\tif (S_ISDIR(mode))\n\t\t\tvap->va_mode |= S_ISGID;\n\t} else {\n\t\tvap->va_gid = zfs_vfsgid_to_gid(mnt_ns,\n\t\t    zfs_i_user_ns(dir), crgetgid(cr));\n\t}\n}\n\nstatic int\n#ifdef HAVE_IOPS_CREATE_USERNS\nzpl_create(struct user_namespace *user_ns, struct inode *dir,\n    struct dentry *dentry, umode_t mode, bool flag)\n#elif defined(HAVE_IOPS_CREATE_IDMAP)\nzpl_create(struct mnt_idmap *user_ns, struct inode *dir,\n    struct dentry *dentry, umode_t mode, bool flag)\n#else\nzpl_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool flag)\n#endif\n{\n\tcred_t *cr = CRED();\n\tznode_t *zp;\n\tvattr_t *vap;\n\tint error;\n\tfstrans_cookie_t cookie;\n#if !(defined(HAVE_IOPS_CREATE_USERNS) || defined(HAVE_IOPS_CREATE_IDMAP))\n\tzidmap_t *user_ns = kcred->user_ns;\n#endif\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\tzpl_vap_init(vap, dir, mode, cr, user_ns);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_create(ITOZ(dir), dname(dentry), vap, 0,\n\t    mode, &zp, cr, 0, NULL, user_ns);\n\tif (error == 0) {\n\t\terror = zpl_xattr_security_init(ZTOI(zp), dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\terror = zpl_init_acl(ZTOI(zp), dir);\n\n\t\tif (error) {\n\t\t\t(void) zfs_remove(ITOZ(dir), dname(dentry), cr, 0);\n\t\t\tremove_inode_hash(ZTOI(zp));\n\t\t\tiput(ZTOI(zp));\n\t\t} else {\n\t\t\td_instantiate(dentry, ZTOI(zp));\n\t\t}\n\t}\n\n\tspl_fstrans_unmark(cookie);\n\tkmem_free(vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\n#ifdef HAVE_IOPS_MKNOD_USERNS\nzpl_mknod(struct user_namespace *user_ns, struct inode *dir,\n    struct dentry *dentry, umode_t mode,\n#elif defined(HAVE_IOPS_MKNOD_IDMAP)\nzpl_mknod(struct mnt_idmap *user_ns, struct inode *dir,\n    struct dentry *dentry, umode_t mode,\n#else\nzpl_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n#endif\n    dev_t rdev)\n{\n\tcred_t *cr = CRED();\n\tznode_t *zp;\n\tvattr_t *vap;\n\tint error;\n\tfstrans_cookie_t cookie;\n#if !(defined(HAVE_IOPS_MKNOD_USERNS) || defined(HAVE_IOPS_MKNOD_IDMAP))\n\tzidmap_t *user_ns = kcred->user_ns;\n#endif\n\n\t \n\tif (S_ISSOCK(mode) || S_ISFIFO(mode))\n\t\tASSERT(rdev == 0);\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\tzpl_vap_init(vap, dir, mode, cr, user_ns);\n\tvap->va_rdev = rdev;\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_create(ITOZ(dir), dname(dentry), vap, 0,\n\t    mode, &zp, cr, 0, NULL, user_ns);\n\tif (error == 0) {\n\t\terror = zpl_xattr_security_init(ZTOI(zp), dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\terror = zpl_init_acl(ZTOI(zp), dir);\n\n\t\tif (error) {\n\t\t\t(void) zfs_remove(ITOZ(dir), dname(dentry), cr, 0);\n\t\t\tremove_inode_hash(ZTOI(zp));\n\t\t\tiput(ZTOI(zp));\n\t\t} else {\n\t\t\td_instantiate(dentry, ZTOI(zp));\n\t\t}\n\t}\n\n\tspl_fstrans_unmark(cookie);\n\tkmem_free(vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#ifdef HAVE_TMPFILE\nstatic int\n#ifdef HAVE_TMPFILE_IDMAP\nzpl_tmpfile(struct mnt_idmap *userns, struct inode *dir,\n    struct file *file, umode_t mode)\n#elif !defined(HAVE_TMPFILE_DENTRY)\nzpl_tmpfile(struct user_namespace *userns, struct inode *dir,\n    struct file *file, umode_t mode)\n#else\n#ifdef HAVE_TMPFILE_USERNS\nzpl_tmpfile(struct user_namespace *userns, struct inode *dir,\n    struct dentry *dentry, umode_t mode)\n#else\nzpl_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n#endif\n#endif\n{\n\tcred_t *cr = CRED();\n\tstruct inode *ip;\n\tvattr_t *vap;\n\tint error;\n\tfstrans_cookie_t cookie;\n#if !(defined(HAVE_TMPFILE_USERNS) || defined(HAVE_TMPFILE_IDMAP))\n\tzidmap_t *userns = kcred->user_ns;\n#endif\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\t \n\tif (!IS_POSIXACL(dir))\n\t\tmode &= ~current_umask();\n\tzpl_vap_init(vap, dir, mode, cr, userns);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_tmpfile(dir, vap, 0, mode, &ip, cr, 0, NULL, userns);\n\tif (error == 0) {\n\t\t \n\t\tset_nlink(ip, 1);\n#ifndef HAVE_TMPFILE_DENTRY\n\t\td_tmpfile(file, ip);\n\n\t\terror = zpl_xattr_security_init(ip, dir,\n\t\t    &file->f_path.dentry->d_name);\n#else\n\t\td_tmpfile(dentry, ip);\n\n\t\terror = zpl_xattr_security_init(ip, dir, &dentry->d_name);\n#endif\n\t\tif (error == 0)\n\t\t\terror = zpl_init_acl(ip, dir);\n#ifndef HAVE_TMPFILE_DENTRY\n\t\terror = finish_open_simple(file, error);\n#endif\n\t\t \n\t}\n\n\tspl_fstrans_unmark(cookie);\n\tkmem_free(vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n#endif\n\nstatic int\nzpl_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\tzfsvfs_t *zfsvfs = dentry->d_sb->s_fs_info;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_remove(ITOZ(dir), dname(dentry), cr, 0);\n\n\t \n\tif (error == 0 && zfsvfs->z_case == ZFS_CASE_INSENSITIVE)\n\t\td_invalidate(dentry);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\n#ifdef HAVE_IOPS_MKDIR_USERNS\nzpl_mkdir(struct user_namespace *user_ns, struct inode *dir,\n    struct dentry *dentry, umode_t mode)\n#elif defined(HAVE_IOPS_MKDIR_IDMAP)\nzpl_mkdir(struct mnt_idmap *user_ns, struct inode *dir,\n    struct dentry *dentry, umode_t mode)\n#else\nzpl_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n#endif\n{\n\tcred_t *cr = CRED();\n\tvattr_t *vap;\n\tznode_t *zp;\n\tint error;\n\tfstrans_cookie_t cookie;\n#if !(defined(HAVE_IOPS_MKDIR_USERNS) || defined(HAVE_IOPS_MKDIR_IDMAP))\n\tzidmap_t *user_ns = kcred->user_ns;\n#endif\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\tzpl_vap_init(vap, dir, mode | S_IFDIR, cr, user_ns);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_mkdir(ITOZ(dir), dname(dentry), vap, &zp, cr, 0, NULL,\n\t    user_ns);\n\tif (error == 0) {\n\t\terror = zpl_xattr_security_init(ZTOI(zp), dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\terror = zpl_init_acl(ZTOI(zp), dir);\n\n\t\tif (error) {\n\t\t\t(void) zfs_rmdir(ITOZ(dir), dname(dentry), NULL, cr, 0);\n\t\t\tremove_inode_hash(ZTOI(zp));\n\t\t\tiput(ZTOI(zp));\n\t\t} else {\n\t\t\td_instantiate(dentry, ZTOI(zp));\n\t\t}\n\t}\n\n\tspl_fstrans_unmark(cookie);\n\tkmem_free(vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\nzpl_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tcred_t *cr = CRED();\n\tint error;\n\tfstrans_cookie_t cookie;\n\tzfsvfs_t *zfsvfs = dentry->d_sb->s_fs_info;\n\n\tcrhold(cr);\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_rmdir(ITOZ(dir), dname(dentry), NULL, cr, 0);\n\n\t \n\tif (error == 0 && zfsvfs->z_case == ZFS_CASE_INSENSITIVE)\n\t\td_invalidate(dentry);\n\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\n#ifdef HAVE_USERNS_IOPS_GETATTR\nzpl_getattr_impl(struct user_namespace *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#elif defined(HAVE_IDMAP_IOPS_GETATTR)\nzpl_getattr_impl(struct mnt_idmap *user_ns,\n    const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#else\nzpl_getattr_impl(const struct path *path, struct kstat *stat, u32 request_mask,\n    unsigned int query_flags)\n#endif\n{\n\tint error;\n\tfstrans_cookie_t cookie;\n\tstruct inode *ip = path->dentry->d_inode;\n\tznode_t *zp __maybe_unused = ITOZ(ip);\n\n\tcookie = spl_fstrans_mark();\n\n\t \n\n#ifdef HAVE_GENERIC_FILLATTR_IDMAP_REQMASK\n\terror = -zfs_getattr_fast(user_ns, request_mask, ip, stat);\n#elif (defined(HAVE_USERNS_IOPS_GETATTR) || defined(HAVE_IDMAP_IOPS_GETATTR))\n\terror = -zfs_getattr_fast(user_ns, ip, stat);\n#else\n\terror = -zfs_getattr_fast(kcred->user_ns, ip, stat);\n#endif\n\n#ifdef STATX_BTIME\n\tif (request_mask & STATX_BTIME) {\n\t\tstat->btime = zp->z_btime;\n\t\tstat->result_mask |= STATX_BTIME;\n\t}\n#endif\n\n#ifdef STATX_ATTR_IMMUTABLE\n\tif (zp->z_pflags & ZFS_IMMUTABLE)\n\t\tstat->attributes |= STATX_ATTR_IMMUTABLE;\n\tstat->attributes_mask |= STATX_ATTR_IMMUTABLE;\n#endif\n\n#ifdef STATX_ATTR_APPEND\n\tif (zp->z_pflags & ZFS_APPENDONLY)\n\t\tstat->attributes |= STATX_ATTR_APPEND;\n\tstat->attributes_mask |= STATX_ATTR_APPEND;\n#endif\n\n#ifdef STATX_ATTR_NODUMP\n\tif (zp->z_pflags & ZFS_NODUMP)\n\t\tstat->attributes |= STATX_ATTR_NODUMP;\n\tstat->attributes_mask |= STATX_ATTR_NODUMP;\n#endif\n\n\tspl_fstrans_unmark(cookie);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\nZPL_GETATTR_WRAPPER(zpl_getattr);\n\nstatic int\n#ifdef HAVE_USERNS_IOPS_SETATTR\nzpl_setattr(struct user_namespace *user_ns, struct dentry *dentry,\n    struct iattr *ia)\n#elif defined(HAVE_IDMAP_IOPS_SETATTR)\nzpl_setattr(struct mnt_idmap *user_ns, struct dentry *dentry,\n    struct iattr *ia)\n#else\nzpl_setattr(struct dentry *dentry, struct iattr *ia)\n#endif\n{\n\tstruct inode *ip = dentry->d_inode;\n\tcred_t *cr = CRED();\n\tvattr_t *vap;\n\tint error;\n\tfstrans_cookie_t cookie;\n\n#ifdef HAVE_SETATTR_PREPARE_USERNS\n\terror = zpl_setattr_prepare(user_ns, dentry, ia);\n#elif defined(HAVE_SETATTR_PREPARE_IDMAP)\n\terror = zpl_setattr_prepare(user_ns, dentry, ia);\n#else\n\terror = zpl_setattr_prepare(zfs_init_idmap, dentry, ia);\n#endif\n\tif (error)\n\t\treturn (error);\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\tvap->va_mask = ia->ia_valid & ATTR_IATTR_MASK;\n\tvap->va_mode = ia->ia_mode;\n\tif (ia->ia_valid & ATTR_UID)\n#ifdef HAVE_IATTR_VFSID\n\t\tvap->va_uid = zfs_vfsuid_to_uid(user_ns, zfs_i_user_ns(ip),\n\t\t    __vfsuid_val(ia->ia_vfsuid));\n#else\n\t\tvap->va_uid = KUID_TO_SUID(ia->ia_uid);\n#endif\n\tif (ia->ia_valid & ATTR_GID)\n#ifdef HAVE_IATTR_VFSID\n\t\tvap->va_gid = zfs_vfsgid_to_gid(user_ns, zfs_i_user_ns(ip),\n\t\t    __vfsgid_val(ia->ia_vfsgid));\n#else\n\t\tvap->va_gid = KGID_TO_SGID(ia->ia_gid);\n#endif\n\tvap->va_size = ia->ia_size;\n\tvap->va_atime = ia->ia_atime;\n\tvap->va_mtime = ia->ia_mtime;\n\tvap->va_ctime = ia->ia_ctime;\n\n\tif (vap->va_mask & ATTR_ATIME)\n\t\tip->i_atime = zpl_inode_timestamp_truncate(ia->ia_atime, ip);\n\n\tcookie = spl_fstrans_mark();\n#ifdef HAVE_USERNS_IOPS_SETATTR\n\terror = -zfs_setattr(ITOZ(ip), vap, 0, cr, user_ns);\n#elif defined(HAVE_IDMAP_IOPS_SETATTR)\n\terror = -zfs_setattr(ITOZ(ip), vap, 0, cr, user_ns);\n#else\n\terror = -zfs_setattr(ITOZ(ip), vap, 0, cr, zfs_init_idmap);\n#endif\n\tif (!error && (ia->ia_valid & ATTR_MODE))\n\t\terror = zpl_chmod_acl(ip);\n\n\tspl_fstrans_unmark(cookie);\n\tkmem_free(vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nstatic int\n#ifdef HAVE_IOPS_RENAME_USERNS\nzpl_rename2(struct user_namespace *user_ns, struct inode *sdip,\n    struct dentry *sdentry, struct inode *tdip, struct dentry *tdentry,\n    unsigned int rflags)\n#elif defined(HAVE_IOPS_RENAME_IDMAP)\nzpl_rename2(struct mnt_idmap *user_ns, struct inode *sdip,\n    struct dentry *sdentry, struct inode *tdip, struct dentry *tdentry,\n    unsigned int rflags)\n#else\nzpl_rename2(struct inode *sdip, struct dentry *sdentry,\n    struct inode *tdip, struct dentry *tdentry, unsigned int rflags)\n#endif\n{\n\tcred_t *cr = CRED();\n\tvattr_t *wo_vap = NULL;\n\tint error;\n\tfstrans_cookie_t cookie;\n#if !(defined(HAVE_IOPS_RENAME_USERNS) || defined(HAVE_IOPS_RENAME_IDMAP))\n\tzidmap_t *user_ns = kcred->user_ns;\n#endif\n\n\tcrhold(cr);\n\tif (rflags & RENAME_WHITEOUT) {\n\t\two_vap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\t\tzpl_vap_init(wo_vap, sdip, S_IFCHR, cr, user_ns);\n\t\two_vap->va_rdev = makedevice(0, 0);\n\t}\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_rename(ITOZ(sdip), dname(sdentry), ITOZ(tdip),\n\t    dname(tdentry), cr, 0, rflags, wo_vap, user_ns);\n\tspl_fstrans_unmark(cookie);\n\tif (wo_vap)\n\t\tkmem_free(wo_vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#if !defined(HAVE_IOPS_RENAME_USERNS) && \\\n\t!defined(HAVE_RENAME_WANTS_FLAGS) && \\\n\t!defined(HAVE_RENAME2) && \\\n\t!defined(HAVE_IOPS_RENAME_IDMAP)\nstatic int\nzpl_rename(struct inode *sdip, struct dentry *sdentry,\n    struct inode *tdip, struct dentry *tdentry)\n{\n\treturn (zpl_rename2(sdip, sdentry, tdip, tdentry, 0));\n}\n#endif\n\nstatic int\n#ifdef HAVE_IOPS_SYMLINK_USERNS\nzpl_symlink(struct user_namespace *user_ns, struct inode *dir,\n    struct dentry *dentry, const char *name)\n#elif defined(HAVE_IOPS_SYMLINK_IDMAP)\nzpl_symlink(struct mnt_idmap *user_ns, struct inode *dir,\n    struct dentry *dentry, const char *name)\n#else\nzpl_symlink(struct inode *dir, struct dentry *dentry, const char *name)\n#endif\n{\n\tcred_t *cr = CRED();\n\tvattr_t *vap;\n\tznode_t *zp;\n\tint error;\n\tfstrans_cookie_t cookie;\n#if !(defined(HAVE_IOPS_SYMLINK_USERNS) || defined(HAVE_IOPS_SYMLINK_IDMAP))\n\tzidmap_t *user_ns = kcred->user_ns;\n#endif\n\n\tcrhold(cr);\n\tvap = kmem_zalloc(sizeof (vattr_t), KM_SLEEP);\n\tzpl_vap_init(vap, dir, S_IFLNK | S_IRWXUGO, cr, user_ns);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_symlink(ITOZ(dir), dname(dentry), vap,\n\t    (char *)name, &zp, cr, 0, user_ns);\n\tif (error == 0) {\n\t\terror = zpl_xattr_security_init(ZTOI(zp), dir, &dentry->d_name);\n\t\tif (error) {\n\t\t\t(void) zfs_remove(ITOZ(dir), dname(dentry), cr, 0);\n\t\t\tremove_inode_hash(ZTOI(zp));\n\t\t\tiput(ZTOI(zp));\n\t\t} else {\n\t\t\td_instantiate(dentry, ZTOI(zp));\n\t\t}\n\t}\n\n\tspl_fstrans_unmark(cookie);\n\tkmem_free(vap, sizeof (vattr_t));\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\n#if defined(HAVE_PUT_LINK_COOKIE)\nstatic void\nzpl_put_link(struct inode *unused, void *cookie)\n{\n\tkmem_free(cookie, MAXPATHLEN);\n}\n#elif defined(HAVE_PUT_LINK_NAMEIDATA)\nstatic void\nzpl_put_link(struct dentry *dentry, struct nameidata *nd, void *ptr)\n{\n\tconst char *link = nd_get_link(nd);\n\n\tif (!IS_ERR(link))\n\t\tkmem_free(link, MAXPATHLEN);\n}\n#elif defined(HAVE_PUT_LINK_DELAYED)\nstatic void\nzpl_put_link(void *ptr)\n{\n\tkmem_free(ptr, MAXPATHLEN);\n}\n#endif\n\nstatic int\nzpl_get_link_common(struct dentry *dentry, struct inode *ip, char **link)\n{\n\tfstrans_cookie_t cookie;\n\tcred_t *cr = CRED();\n\tint error;\n\n\tcrhold(cr);\n\t*link = NULL;\n\n\tstruct iovec iov;\n\tiov.iov_len = MAXPATHLEN;\n\tiov.iov_base = kmem_zalloc(MAXPATHLEN, KM_SLEEP);\n\n\tzfs_uio_t uio;\n\tzfs_uio_iovec_init(&uio, &iov, 1, 0, UIO_SYSSPACE, MAXPATHLEN - 1, 0);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_readlink(ip, &uio, cr);\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\n\tif (error)\n\t\tkmem_free(iov.iov_base, MAXPATHLEN);\n\telse\n\t\t*link = iov.iov_base;\n\n\treturn (error);\n}\n\n#if defined(HAVE_GET_LINK_DELAYED)\nstatic const char *\nzpl_get_link(struct dentry *dentry, struct inode *inode,\n    struct delayed_call *done)\n{\n\tchar *link = NULL;\n\tint error;\n\n\tif (!dentry)\n\t\treturn (ERR_PTR(-ECHILD));\n\n\terror = zpl_get_link_common(dentry, inode, &link);\n\tif (error)\n\t\treturn (ERR_PTR(error));\n\n\tset_delayed_call(done, zpl_put_link, link);\n\n\treturn (link);\n}\n#elif defined(HAVE_GET_LINK_COOKIE)\nstatic const char *\nzpl_get_link(struct dentry *dentry, struct inode *inode, void **cookie)\n{\n\tchar *link = NULL;\n\tint error;\n\n\tif (!dentry)\n\t\treturn (ERR_PTR(-ECHILD));\n\n\terror = zpl_get_link_common(dentry, inode, &link);\n\tif (error)\n\t\treturn (ERR_PTR(error));\n\n\treturn (*cookie = link);\n}\n#elif defined(HAVE_FOLLOW_LINK_COOKIE)\nstatic const char *\nzpl_follow_link(struct dentry *dentry, void **cookie)\n{\n\tchar *link = NULL;\n\tint error;\n\n\terror = zpl_get_link_common(dentry, dentry->d_inode, &link);\n\tif (error)\n\t\treturn (ERR_PTR(error));\n\n\treturn (*cookie = link);\n}\n#elif defined(HAVE_FOLLOW_LINK_NAMEIDATA)\nstatic void *\nzpl_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tchar *link = NULL;\n\tint error;\n\n\terror = zpl_get_link_common(dentry, dentry->d_inode, &link);\n\tif (error)\n\t\tnd_set_link(nd, ERR_PTR(error));\n\telse\n\t\tnd_set_link(nd, link);\n\n\treturn (NULL);\n}\n#endif\n\nstatic int\nzpl_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tcred_t *cr = CRED();\n\tstruct inode *ip = old_dentry->d_inode;\n\tint error;\n\tfstrans_cookie_t cookie;\n\n\tif (ip->i_nlink >= ZFS_LINK_MAX)\n\t\treturn (-EMLINK);\n\n\tcrhold(cr);\n\tzpl_inode_set_ctime_to_ts(ip, current_time(ip));\n\t \n\tVERIFY3P(igrab(ip), !=, NULL);\n\n\tcookie = spl_fstrans_mark();\n\terror = -zfs_link(ITOZ(dir), ITOZ(ip), dname(dentry), cr, 0);\n\tif (error) {\n\t\tiput(ip);\n\t\tgoto out;\n\t}\n\n\td_instantiate(dentry, ip);\nout:\n\tspl_fstrans_unmark(cookie);\n\tcrfree(cr);\n\tASSERT3S(error, <=, 0);\n\n\treturn (error);\n}\n\nconst struct inode_operations zpl_inode_operations = {\n\t.setattr\t= zpl_setattr,\n\t.getattr\t= zpl_getattr,\n#ifdef HAVE_GENERIC_SETXATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.listxattr\t= zpl_xattr_list,\n#if defined(CONFIG_FS_POSIX_ACL)\n#if defined(HAVE_SET_ACL)\n\t.set_acl\t= zpl_set_acl,\n#endif  \n#if defined(HAVE_GET_INODE_ACL)\n\t.get_inode_acl\t= zpl_get_acl,\n#else\n\t.get_acl\t= zpl_get_acl,\n#endif  \n#endif  \n};\n\n#ifdef HAVE_RENAME2_OPERATIONS_WRAPPER\nconst struct inode_operations_wrapper zpl_dir_inode_operations = {\n\t.ops = {\n#else\nconst struct inode_operations zpl_dir_inode_operations = {\n#endif\n\t.create\t\t= zpl_create,\n\t.lookup\t\t= zpl_lookup,\n\t.link\t\t= zpl_link,\n\t.unlink\t\t= zpl_unlink,\n\t.symlink\t= zpl_symlink,\n\t.mkdir\t\t= zpl_mkdir,\n\t.rmdir\t\t= zpl_rmdir,\n\t.mknod\t\t= zpl_mknod,\n#ifdef HAVE_RENAME2\n\t.rename2\t= zpl_rename2,\n#elif defined(HAVE_RENAME_WANTS_FLAGS) || defined(HAVE_IOPS_RENAME_USERNS)\n\t.rename\t\t= zpl_rename2,\n#elif defined(HAVE_IOPS_RENAME_IDMAP)\n\t.rename\t\t= zpl_rename2,\n#else\n\t.rename\t\t= zpl_rename,\n#endif\n#ifdef HAVE_TMPFILE\n\t.tmpfile\t= zpl_tmpfile,\n#endif\n\t.setattr\t= zpl_setattr,\n\t.getattr\t= zpl_getattr,\n#ifdef HAVE_GENERIC_SETXATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.listxattr\t= zpl_xattr_list,\n#if defined(CONFIG_FS_POSIX_ACL)\n#if defined(HAVE_SET_ACL)\n\t.set_acl\t= zpl_set_acl,\n#endif  \n#if defined(HAVE_GET_INODE_ACL)\n\t.get_inode_acl\t= zpl_get_acl,\n#else\n\t.get_acl\t= zpl_get_acl,\n#endif  \n#endif  \n#ifdef HAVE_RENAME2_OPERATIONS_WRAPPER\n\t},\n\t.rename2\t= zpl_rename2,\n#endif\n};\n\nconst struct inode_operations zpl_symlink_inode_operations = {\n#ifdef HAVE_GENERIC_READLINK\n\t.readlink\t= generic_readlink,\n#endif\n#if defined(HAVE_GET_LINK_DELAYED) || defined(HAVE_GET_LINK_COOKIE)\n\t.get_link\t= zpl_get_link,\n#elif defined(HAVE_FOLLOW_LINK_COOKIE) || defined(HAVE_FOLLOW_LINK_NAMEIDATA)\n\t.follow_link\t= zpl_follow_link,\n#endif\n#if defined(HAVE_PUT_LINK_COOKIE) || defined(HAVE_PUT_LINK_NAMEIDATA)\n\t.put_link\t= zpl_put_link,\n#endif\n\t.setattr\t= zpl_setattr,\n\t.getattr\t= zpl_getattr,\n#ifdef HAVE_GENERIC_SETXATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.listxattr\t= zpl_xattr_list,\n};\n\nconst struct inode_operations zpl_special_inode_operations = {\n\t.setattr\t= zpl_setattr,\n\t.getattr\t= zpl_getattr,\n#ifdef HAVE_GENERIC_SETXATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n\t.listxattr\t= zpl_xattr_list,\n#if defined(CONFIG_FS_POSIX_ACL)\n#if defined(HAVE_SET_ACL)\n\t.set_acl\t= zpl_set_acl,\n#endif  \n#if defined(HAVE_GET_INODE_ACL)\n\t.get_inode_acl\t= zpl_get_acl,\n#else\n\t.get_acl\t= zpl_get_acl,\n#endif  \n#endif  \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}