{
  "module_name": "zfs_sysfs.c",
  "hash_id": "619c152a637327b21a81973b9896808f61ed047467c6c81af88a0a6d1eaea7bd",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_sysfs.c",
  "human_readable_source": " \n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/zfeature.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_sysfs.h>\n#include <sys/kmem.h>\n#include <sys/fs/zfs.h>\n#include <linux/kobject.h>\n\n#include \"zfs_prop.h\"\n\n#if !defined(_KERNEL)\n#error kernel builds only\n#endif\n\n \n\n \ntypedef struct zfs_mod_kobj zfs_mod_kobj_t;\nstruct zfs_mod_kobj {\n\tstruct kobject\t\tzko_kobj;\n\tstruct kobj_type\tzko_kobj_type;\n\tstruct sysfs_ops\tzko_sysfs_ops;\n\tsize_t\t\t\tzko_attr_count;\n\tstruct attribute\t*zko_attr_list;\t\t \n\tstruct attribute_group\tzko_default_group;\t \n\tconst struct attribute_group\t*zko_default_groups[2];\n\tsize_t\t\t\tzko_child_count;\n\tzfs_mod_kobj_t\t\t*zko_children;\t\t \n};\n\n#define\tATTR_TABLE_SIZE(cnt)\t(sizeof (struct attribute) * (cnt))\n \n#define\tDEFAULT_ATTR_SIZE(cnt)\t(sizeof (struct attribute *) * (cnt + 1))\n#define\tCHILD_TABLE_SIZE(cnt)\t(sizeof (zfs_mod_kobj_t) * (cnt))\n\n \nstatic zfs_mod_kobj_t kernel_features_kobj;\nstatic zfs_mod_kobj_t pool_features_kobj;\nstatic zfs_mod_kobj_t dataset_props_kobj;\nstatic zfs_mod_kobj_t vdev_props_kobj;\nstatic zfs_mod_kobj_t pool_props_kobj;\n\n \ntypedef ssize_t\t(*sysfs_show_func)(struct kobject *, struct attribute *,\n    char *);\n\nstatic void\nzfs_kobj_fini(zfs_mod_kobj_t *zkobj)\n{\n\t \n\tif (zkobj->zko_child_count != 0) {\n\t\tASSERT(zkobj->zko_children);\n\t\tfor (int i = 0; i < zkobj->zko_child_count; i++)\n\t\t\tzfs_kobj_fini(&zkobj->zko_children[i]);\n\t}\n\n\t \n\tkobject_del(&zkobj->zko_kobj);\n\tkobject_put(&zkobj->zko_kobj);\n}\n\nstatic void\nzfs_kobj_release(struct kobject *kobj)\n{\n\tzfs_mod_kobj_t *zkobj = container_of(kobj, zfs_mod_kobj_t, zko_kobj);\n\n\tif (zkobj->zko_attr_list != NULL) {\n\t\tASSERT3S(zkobj->zko_attr_count, !=, 0);\n\t\tkmem_free(zkobj->zko_attr_list,\n\t\t    ATTR_TABLE_SIZE(zkobj->zko_attr_count));\n\t\tzkobj->zko_attr_list = NULL;\n\t}\n\n\tif (zkobj->zko_default_group.attrs != NULL) {\n\t\tkmem_free(zkobj->zko_default_group.attrs,\n\t\t    DEFAULT_ATTR_SIZE(zkobj->zko_attr_count));\n\t\tzkobj->zko_default_group.attrs = NULL;\n\t}\n\n\tif (zkobj->zko_child_count != 0) {\n\t\tASSERT(zkobj->zko_children);\n\n\t\tkmem_free(zkobj->zko_children,\n\t\t    CHILD_TABLE_SIZE(zkobj->zko_child_count));\n\t\tzkobj->zko_child_count = 0;\n\t\tzkobj->zko_children = NULL;\n\t}\n\n\tzkobj->zko_attr_count = 0;\n}\n\n#ifndef sysfs_attr_init\n#define\tsysfs_attr_init(attr) do {} while (0)\n#endif\n\nstatic void\nzfs_kobj_add_attr(zfs_mod_kobj_t *zkobj, int attr_num, const char *attr_name)\n{\n\tVERIFY3U(attr_num, <, zkobj->zko_attr_count);\n\tASSERT(zkobj->zko_attr_list);\n\tASSERT(zkobj->zko_default_group.attrs);\n\n\tzkobj->zko_attr_list[attr_num].name = attr_name;\n\tzkobj->zko_attr_list[attr_num].mode = 0444;\n\tzkobj->zko_default_group.attrs[attr_num] =\n\t    &zkobj->zko_attr_list[attr_num];\n\tsysfs_attr_init(&zkobj->zko_attr_list[attr_num]);\n}\n\nstatic int\nzfs_kobj_init(zfs_mod_kobj_t *zkobj, int attr_cnt, int child_cnt,\n    sysfs_show_func show_func)\n{\n\t \n\tif (attr_cnt > 0) {\n\t\tzkobj->zko_attr_list = kmem_zalloc(ATTR_TABLE_SIZE(attr_cnt),\n\t\t    KM_SLEEP);\n\t\tif (zkobj->zko_attr_list == NULL)\n\t\t\treturn (ENOMEM);\n\t}\n\t \n\tzkobj->zko_default_group.attrs =\n\t    kmem_zalloc(DEFAULT_ATTR_SIZE(attr_cnt), KM_SLEEP);\n\tif (zkobj->zko_default_group.attrs == NULL) {\n\t\tif (zkobj->zko_attr_list != NULL) {\n\t\t\tkmem_free(zkobj->zko_attr_list,\n\t\t\t    ATTR_TABLE_SIZE(attr_cnt));\n\t\t}\n\t\treturn (ENOMEM);\n\t}\n\tzkobj->zko_attr_count = attr_cnt;\n\tzkobj->zko_default_groups[0] = &zkobj->zko_default_group;\n#ifdef HAVE_SYSFS_DEFAULT_GROUPS\n\tzkobj->zko_kobj_type.default_groups = zkobj->zko_default_groups;\n#else\n\tzkobj->zko_kobj_type.default_attrs = zkobj->zko_default_group.attrs;\n#endif\n\n\tif (child_cnt > 0) {\n\t\tzkobj->zko_children = kmem_zalloc(CHILD_TABLE_SIZE(child_cnt),\n\t\t    KM_SLEEP);\n\t\tif (zkobj->zko_children == NULL) {\n\t\t\tif (zkobj->zko_default_group.attrs != NULL) {\n\t\t\t\tkmem_free(zkobj->zko_default_group.attrs,\n\t\t\t\t    DEFAULT_ATTR_SIZE(attr_cnt));\n\t\t\t}\n\t\t\tif (zkobj->zko_attr_list != NULL) {\n\t\t\t\tkmem_free(zkobj->zko_attr_list,\n\t\t\t\t    ATTR_TABLE_SIZE(attr_cnt));\n\t\t\t}\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tzkobj->zko_child_count = child_cnt;\n\t}\n\n\tzkobj->zko_sysfs_ops.show = show_func;\n\tzkobj->zko_kobj_type.sysfs_ops = &zkobj->zko_sysfs_ops;\n\tzkobj->zko_kobj_type.release = zfs_kobj_release;\n\n\treturn (0);\n}\n\nstatic int\nzfs_kobj_add(zfs_mod_kobj_t *zkobj, struct kobject *parent, const char *name)\n{\n\t \n\tASSERT(zkobj->zko_default_group.attrs != NULL);\n\tASSERT(zkobj->zko_default_group.attrs[zkobj->zko_attr_count] == NULL);\n\n\tkobject_init(&zkobj->zko_kobj, &zkobj->zko_kobj_type);\n\treturn (kobject_add(&zkobj->zko_kobj, parent, name));\n}\n\n \nstatic const char *const zprop_attrs[]  = {\n\t\"type\",\n\t\"readonly\",\n\t\"setonce\",\n\t\"visible\",\n\t\"values\",\n\t\"default\",\n\t\"datasets\"\t \n};\n\n#define\tZFS_PROP_ATTR_COUNT\tARRAY_SIZE(zprop_attrs)\n#define\tZPOOL_PROP_ATTR_COUNT\t(ZFS_PROP_ATTR_COUNT - 1)\n\nstatic const char *const zprop_types[]  = {\n\t\"number\",\n\t\"string\",\n\t\"index\",\n};\n\ntypedef struct zfs_type_map {\n\tzfs_type_t\tztm_type;\n\tconst char\t*ztm_name;\n} zfs_type_map_t;\n\nstatic const zfs_type_map_t type_map[] = {\n\t{ZFS_TYPE_FILESYSTEM,\t\"filesystem\"},\n\t{ZFS_TYPE_SNAPSHOT,\t\"snapshot\"},\n\t{ZFS_TYPE_VOLUME,\t\"volume\"},\n\t{ZFS_TYPE_BOOKMARK,\t\"bookmark\"}\n};\n\n \nstatic ssize_t\nzprop_sysfs_show(const char *attr_name, const zprop_desc_t *property,\n    char *buf, size_t buflen)\n{\n\tconst char *show_str;\n\tchar number[32];\n\n\t \n\tif (strcmp(attr_name, \"datasets\") == 0 &&\n\t    property->pd_types != ZFS_TYPE_POOL) {\n\t\tint len = 0;\n\n\t\tfor (int i = 0; i < ARRAY_SIZE(type_map); i++) {\n\t\t\tif (type_map[i].ztm_type & property->pd_types)  {\n\t\t\t\tlen += kmem_scnprintf(buf + len, buflen - len,\n\t\t\t\t    \"%s \", type_map[i].ztm_name);\n\t\t\t}\n\t\t}\n\t\tlen += kmem_scnprintf(buf + len, buflen - len, \"\\n\");\n\t\treturn (len);\n\t}\n\n\tif (strcmp(attr_name, \"type\") == 0) {\n\t\tshow_str = zprop_types[property->pd_proptype];\n\t} else if (strcmp(attr_name, \"readonly\") == 0) {\n\t\tshow_str = property->pd_attr == PROP_READONLY ? \"1\" : \"0\";\n\t} else if (strcmp(attr_name, \"setonce\") == 0) {\n\t\tshow_str = property->pd_attr == PROP_ONETIME ? \"1\" : \"0\";\n\t} else if (strcmp(attr_name, \"visible\") == 0) {\n\t\tshow_str = property->pd_visible ? \"1\" : \"0\";\n\t} else if (strcmp(attr_name, \"values\") == 0) {\n\t\tshow_str = property->pd_values ? property->pd_values : \"\";\n\t} else if (strcmp(attr_name, \"default\") == 0) {\n\t\tswitch (property->pd_proptype) {\n\t\tcase PROP_TYPE_NUMBER:\n\t\t\t(void) snprintf(number, sizeof (number), \"%llu\",\n\t\t\t    (u_longlong_t)property->pd_numdefault);\n\t\t\tshow_str = number;\n\t\t\tbreak;\n\t\tcase PROP_TYPE_STRING:\n\t\t\tshow_str = property->pd_strdefault ?\n\t\t\t    property->pd_strdefault : \"\";\n\t\t\tbreak;\n\t\tcase PROP_TYPE_INDEX:\n\t\t\tif (zprop_index_to_string(property->pd_propnum,\n\t\t\t    property->pd_numdefault, &show_str,\n\t\t\t    property->pd_types) != 0) {\n\t\t\t\tshow_str = \"\";\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\treturn (0);\n\t}\n\n\treturn (snprintf(buf, buflen, \"%s\\n\", show_str));\n}\n\nstatic ssize_t\ndataset_property_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tzfs_prop_t prop = zfs_name_to_prop(kobject_name(kobj));\n\tzprop_desc_t *prop_tbl = zfs_prop_get_table();\n\tssize_t len;\n\n\tASSERT3U(prop, <, ZFS_NUM_PROPS);\n\n\tlen = zprop_sysfs_show(attr->name, &prop_tbl[prop], buf, PAGE_SIZE);\n\n\treturn (len);\n}\n\nstatic ssize_t\nvdev_property_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tvdev_prop_t prop = vdev_name_to_prop(kobject_name(kobj));\n\tzprop_desc_t *prop_tbl = vdev_prop_get_table();\n\tssize_t len;\n\n\tASSERT3U(prop, <, VDEV_NUM_PROPS);\n\n\tlen = zprop_sysfs_show(attr->name, &prop_tbl[prop], buf, PAGE_SIZE);\n\n\treturn (len);\n}\n\nstatic ssize_t\npool_property_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tzpool_prop_t prop = zpool_name_to_prop(kobject_name(kobj));\n\tzprop_desc_t *prop_tbl = zpool_prop_get_table();\n\tssize_t len;\n\n\tASSERT3U(prop, <, ZPOOL_NUM_PROPS);\n\n\tlen = zprop_sysfs_show(attr->name, &prop_tbl[prop], buf, PAGE_SIZE);\n\n\treturn (len);\n}\n\n \nstatic const char *const zfs_kernel_features[] = {\n\t \n\t\"com.delphix:vdev_initialize\",\n\t\"org.zfsonlinux:vdev_trim\",\n\t\"org.openzfs:l2arc_persistent\",\n};\n\n#define\tKERNEL_FEATURE_COUNT\tARRAY_SIZE(zfs_kernel_features)\n\nstatic ssize_t\nkernel_feature_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tif (strcmp(attr->name, \"supported\") == 0)\n\t\treturn (snprintf(buf, PAGE_SIZE, \"yes\\n\"));\n\treturn (0);\n}\n\nstatic void\nkernel_feature_to_kobj(zfs_mod_kobj_t *parent, int slot, const char *name)\n{\n\tzfs_mod_kobj_t *zfs_kobj = &parent->zko_children[slot];\n\n\tASSERT3U(slot, <, KERNEL_FEATURE_COUNT);\n\tASSERT(name);\n\n\tint err = zfs_kobj_init(zfs_kobj, 1, 0, kernel_feature_show);\n\tif (err)\n\t\treturn;\n\n\tzfs_kobj_add_attr(zfs_kobj, 0, \"supported\");\n\n\terr = zfs_kobj_add(zfs_kobj, &parent->zko_kobj, name);\n\tif (err)\n\t\tzfs_kobj_release(&zfs_kobj->zko_kobj);\n}\n\nstatic int\nzfs_kernel_features_init(zfs_mod_kobj_t *zfs_kobj, struct kobject *parent)\n{\n\t \n\tint err = zfs_kobj_init(zfs_kobj, 0, KERNEL_FEATURE_COUNT,\n\t    kernel_feature_show);\n\tif (err)\n\t\treturn (err);\n\terr = zfs_kobj_add(zfs_kobj, parent, ZFS_SYSFS_KERNEL_FEATURES);\n\tif (err) {\n\t\tzfs_kobj_release(&zfs_kobj->zko_kobj);\n\t\treturn (err);\n\t}\n\n\t \n\tfor (int f = 0; f < KERNEL_FEATURE_COUNT; f++)\n\t\tkernel_feature_to_kobj(zfs_kobj, f, zfs_kernel_features[f]);\n\n\treturn (0);\n}\n\n \nstatic const char *const pool_feature_attrs[]  = {\n\t\"description\",\n\t\"guid\",\n\t\"uname\",\n\t\"readonly_compatible\",\n\t\"required_for_mos\",\n\t\"activate_on_enable\",\n\t\"per_dataset\"\n};\n\n#define\tZPOOL_FEATURE_ATTR_COUNT\tARRAY_SIZE(pool_feature_attrs)\n\n \nstatic ssize_t\npool_feature_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tspa_feature_t fid;\n\n\tif (zfeature_lookup_guid(kobject_name(kobj), &fid) != 0)\n\t\treturn (0);\n\n\tASSERT3U(fid, <, SPA_FEATURES);\n\n\tzfeature_flags_t flags = spa_feature_table[fid].fi_flags;\n\tconst char *show_str = NULL;\n\n\tif (strcmp(attr->name, \"description\") == 0) {\n\t\tshow_str = spa_feature_table[fid].fi_desc;\n\t} else if (strcmp(attr->name, \"guid\") == 0) {\n\t\tshow_str = spa_feature_table[fid].fi_guid;\n\t} else if (strcmp(attr->name, \"uname\") == 0) {\n\t\tshow_str = spa_feature_table[fid].fi_uname;\n\t} else if (strcmp(attr->name, \"readonly_compatible\") == 0) {\n\t\tshow_str = flags & ZFEATURE_FLAG_READONLY_COMPAT ? \"1\" : \"0\";\n\t} else if (strcmp(attr->name, \"required_for_mos\") == 0) {\n\t\tshow_str = flags & ZFEATURE_FLAG_MOS ? \"1\" : \"0\";\n\t} else if (strcmp(attr->name, \"activate_on_enable\") == 0) {\n\t\tshow_str = flags & ZFEATURE_FLAG_ACTIVATE_ON_ENABLE ? \"1\" : \"0\";\n\t} else if (strcmp(attr->name, \"per_dataset\") == 0) {\n\t\tshow_str = flags & ZFEATURE_FLAG_PER_DATASET ? \"1\" : \"0\";\n\t}\n\tif (show_str == NULL)\n\t\treturn (0);\n\n\treturn (snprintf(buf, PAGE_SIZE, \"%s\\n\", show_str));\n}\n\nstatic void\npool_feature_to_kobj(zfs_mod_kobj_t *parent, spa_feature_t fid,\n    const char *name)\n{\n\tzfs_mod_kobj_t *zfs_kobj = &parent->zko_children[fid];\n\n\tASSERT3U(fid, <, SPA_FEATURES);\n\tASSERT(name);\n\n\tint err = zfs_kobj_init(zfs_kobj, ZPOOL_FEATURE_ATTR_COUNT, 0,\n\t    pool_feature_show);\n\tif (err)\n\t\treturn;\n\n\tfor (int i = 0; i < ZPOOL_FEATURE_ATTR_COUNT; i++)\n\t\tzfs_kobj_add_attr(zfs_kobj, i, pool_feature_attrs[i]);\n\n\terr = zfs_kobj_add(zfs_kobj, &parent->zko_kobj, name);\n\tif (err)\n\t\tzfs_kobj_release(&zfs_kobj->zko_kobj);\n}\n\nstatic int\nzfs_pool_features_init(zfs_mod_kobj_t *zfs_kobj, struct kobject *parent)\n{\n\t \n\tint err = zfs_kobj_init(zfs_kobj, 0, SPA_FEATURES, pool_feature_show);\n\tif (err)\n\t\treturn (err);\n\terr = zfs_kobj_add(zfs_kobj, parent, ZFS_SYSFS_POOL_FEATURES);\n\tif (err) {\n\t\tzfs_kobj_release(&zfs_kobj->zko_kobj);\n\t\treturn (err);\n\t}\n\n\t \n\tfor (spa_feature_t i = 0; i < SPA_FEATURES; i++)\n\t\tpool_feature_to_kobj(zfs_kobj, i, spa_feature_table[i].fi_guid);\n\n\treturn (0);\n}\n\ntypedef struct prop_to_kobj_arg {\n\tzprop_desc_t\t*p2k_table;\n\tzfs_mod_kobj_t\t*p2k_parent;\n\tsysfs_show_func\tp2k_show_func;\n\tint\t\tp2k_attr_count;\n} prop_to_kobj_arg_t;\n\nstatic int\nzprop_to_kobj(int prop, void *args)\n{\n\tprop_to_kobj_arg_t *data = args;\n\tzfs_mod_kobj_t *parent = data->p2k_parent;\n\tzfs_mod_kobj_t *zfs_kobj = &parent->zko_children[prop];\n\tconst char *name = data->p2k_table[prop].pd_name;\n\tint err;\n\n\tASSERT(name);\n\n\terr = zfs_kobj_init(zfs_kobj, data->p2k_attr_count, 0,\n\t    data->p2k_show_func);\n\tif (err)\n\t\treturn (ZPROP_CONT);\n\n\tfor (int i = 0; i < data->p2k_attr_count; i++)\n\t\tzfs_kobj_add_attr(zfs_kobj, i, zprop_attrs[i]);\n\n\terr = zfs_kobj_add(zfs_kobj, &parent->zko_kobj, name);\n\tif (err)\n\t\tzfs_kobj_release(&zfs_kobj->zko_kobj);\n\n\treturn (ZPROP_CONT);\n}\n\nstatic int\nzfs_sysfs_properties_init(zfs_mod_kobj_t *zfs_kobj, struct kobject *parent,\n    zfs_type_t type)\n{\n\tprop_to_kobj_arg_t context;\n\tconst char *name;\n\tint err;\n\n\t \n\tif (type == ZFS_TYPE_POOL) {\n\t\tname = ZFS_SYSFS_POOL_PROPERTIES;\n\t\tcontext.p2k_table = zpool_prop_get_table();\n\t\tcontext.p2k_attr_count = ZPOOL_PROP_ATTR_COUNT;\n\t\tcontext.p2k_parent = zfs_kobj;\n\t\tcontext.p2k_show_func = pool_property_show;\n\t\terr = zfs_kobj_init(zfs_kobj, 0, ZPOOL_NUM_PROPS,\n\t\t    pool_property_show);\n\t} else if (type == ZFS_TYPE_VDEV) {\n\t\tname = ZFS_SYSFS_VDEV_PROPERTIES;\n\t\tcontext.p2k_table = vdev_prop_get_table();\n\t\tcontext.p2k_attr_count = ZPOOL_PROP_ATTR_COUNT;\n\t\tcontext.p2k_parent = zfs_kobj;\n\t\tcontext.p2k_show_func = vdev_property_show;\n\t\terr = zfs_kobj_init(zfs_kobj, 0, VDEV_NUM_PROPS,\n\t\t    vdev_property_show);\n\t} else {\n\t\tname = ZFS_SYSFS_DATASET_PROPERTIES;\n\t\tcontext.p2k_table = zfs_prop_get_table();\n\t\tcontext.p2k_attr_count = ZFS_PROP_ATTR_COUNT;\n\t\tcontext.p2k_parent = zfs_kobj;\n\t\tcontext.p2k_show_func = dataset_property_show;\n\t\terr = zfs_kobj_init(zfs_kobj, 0, ZFS_NUM_PROPS,\n\t\t    dataset_property_show);\n\t}\n\n\tif (err)\n\t\treturn (err);\n\n\terr = zfs_kobj_add(zfs_kobj, parent, name);\n\tif (err) {\n\t\tzfs_kobj_release(&zfs_kobj->zko_kobj);\n\t\treturn (err);\n\t}\n\n\t \n\t(void) zprop_iter_common(zprop_to_kobj, &context, B_TRUE,\n\t    B_FALSE, type);\n\n\treturn (err);\n}\n\nvoid\nzfs_sysfs_init(void)\n{\n\tstruct kobject *parent;\n#if defined(CONFIG_ZFS) && !defined(CONFIG_ZFS_MODULE)\n\tparent = kobject_create_and_add(\"zfs\", fs_kobj);\n#else\n\tparent = &(((struct module *)(THIS_MODULE))->mkobj).kobj;\n#endif\n\tint err;\n\n\tif (parent == NULL)\n\t\treturn;\n\n\terr = zfs_kernel_features_init(&kernel_features_kobj, parent);\n\tif (err)\n\t\treturn;\n\n\terr = zfs_pool_features_init(&pool_features_kobj, parent);\n\tif (err) {\n\t\tzfs_kobj_fini(&kernel_features_kobj);\n\t\treturn;\n\t}\n\n\terr = zfs_sysfs_properties_init(&pool_props_kobj, parent,\n\t    ZFS_TYPE_POOL);\n\tif (err) {\n\t\tzfs_kobj_fini(&kernel_features_kobj);\n\t\tzfs_kobj_fini(&pool_features_kobj);\n\t\treturn;\n\t}\n\n\terr = zfs_sysfs_properties_init(&vdev_props_kobj, parent,\n\t    ZFS_TYPE_VDEV);\n\tif (err) {\n\t\tzfs_kobj_fini(&kernel_features_kobj);\n\t\tzfs_kobj_fini(&pool_features_kobj);\n\t\tzfs_kobj_fini(&pool_props_kobj);\n\t\treturn;\n\t}\n\n\terr = zfs_sysfs_properties_init(&dataset_props_kobj, parent,\n\t    ZFS_TYPE_FILESYSTEM);\n\tif (err) {\n\t\tzfs_kobj_fini(&kernel_features_kobj);\n\t\tzfs_kobj_fini(&pool_features_kobj);\n\t\tzfs_kobj_fini(&pool_props_kobj);\n\t\tzfs_kobj_fini(&vdev_props_kobj);\n\t\treturn;\n\t}\n}\n\nvoid\nzfs_sysfs_fini(void)\n{\n\t \n\tzfs_kobj_fini(&kernel_features_kobj);\n\tzfs_kobj_fini(&pool_features_kobj);\n\tzfs_kobj_fini(&pool_props_kobj);\n\tzfs_kobj_fini(&vdev_props_kobj);\n\tzfs_kobj_fini(&dataset_props_kobj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}