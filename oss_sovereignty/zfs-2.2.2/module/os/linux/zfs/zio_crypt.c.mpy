{
  "module_name": "zio_crypt.c",
  "hash_id": "2b0d9f105cde70ad0de23725f0f747800c49971231b1fc39c898dce986a4e081",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zio_crypt.c",
  "human_readable_source": " \n\n \n\n#include <sys/zio_crypt.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dnode.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio.h>\n#include <sys/zil.h>\n#include <sys/sha2.h>\n#include <sys/hkdf.h>\n#include <sys/qat.h>\n\n \n\n \n#define\tZFS_KEY_MAX_SALT_USES_DEFAULT\t400000000\n#define\tZFS_CURRENT_MAX_SALT_USES\t\\\n\t(MIN(zfs_key_max_salt_uses, ZFS_KEY_MAX_SALT_USES_DEFAULT))\nstatic unsigned long zfs_key_max_salt_uses = ZFS_KEY_MAX_SALT_USES_DEFAULT;\n\ntypedef struct blkptr_auth_buf {\n\tuint64_t bab_prop;\t\t\t \n\tuint8_t bab_mac[ZIO_DATA_MAC_LEN];\t \n\tuint64_t bab_pad;\t\t\t \n} blkptr_auth_buf_t;\n\nconst zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS] = {\n\t{\"\",\t\t\tZC_TYPE_NONE,\t0,\t\"inherit\"},\n\t{\"\",\t\t\tZC_TYPE_NONE,\t0,\t\"on\"},\n\t{\"\",\t\t\tZC_TYPE_NONE,\t0,\t\"off\"},\n\t{SUN_CKM_AES_CCM,\tZC_TYPE_CCM,\t16,\t\"aes-128-ccm\"},\n\t{SUN_CKM_AES_CCM,\tZC_TYPE_CCM,\t24,\t\"aes-192-ccm\"},\n\t{SUN_CKM_AES_CCM,\tZC_TYPE_CCM,\t32,\t\"aes-256-ccm\"},\n\t{SUN_CKM_AES_GCM,\tZC_TYPE_GCM,\t16,\t\"aes-128-gcm\"},\n\t{SUN_CKM_AES_GCM,\tZC_TYPE_GCM,\t24,\t\"aes-192-gcm\"},\n\t{SUN_CKM_AES_GCM,\tZC_TYPE_GCM,\t32,\t\"aes-256-gcm\"}\n};\n\nvoid\nzio_crypt_key_destroy(zio_crypt_key_t *key)\n{\n\trw_destroy(&key->zk_salt_lock);\n\n\t \n\tcrypto_destroy_ctx_template(key->zk_current_tmpl);\n\tcrypto_destroy_ctx_template(key->zk_hmac_tmpl);\n\n\t \n\tmemset(key, 0, sizeof (zio_crypt_key_t));\n}\n\nint\nzio_crypt_key_init(uint64_t crypt, zio_crypt_key_t *key)\n{\n\tint ret;\n\tcrypto_mechanism_t mech = {0};\n\tuint_t keydata_len;\n\n\tASSERT(key != NULL);\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n \n#if defined(__GNUC__) && !defined(__clang__) && \\\n\t((!defined(_KERNEL) && defined(ZFS_UBSAN_ENABLED)) || \\\n\t    defined(CONFIG_UBSAN))\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n#endif\n\tkeydata_len = zio_crypt_table[crypt].ci_keylen;\n#if defined(__GNUC__) && !defined(__clang__) && \\\n\t((!defined(_KERNEL) && defined(ZFS_UBSAN_ENABLED)) || \\\n\t    defined(CONFIG_UBSAN))\n#pragma GCC diagnostic pop\n#endif\n\tmemset(key, 0, sizeof (zio_crypt_key_t));\n\trw_init(&key->zk_salt_lock, NULL, RW_DEFAULT, NULL);\n\n\t \n\tret = random_get_bytes((uint8_t *)&key->zk_guid, sizeof (uint64_t));\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = random_get_bytes(key->zk_master_keydata, keydata_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = random_get_bytes(key->zk_hmac_keydata, SHA512_HMAC_KEYLEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = random_get_bytes(key->zk_salt, ZIO_DATA_SALT_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t    key->zk_salt, ZIO_DATA_SALT_LEN, key->zk_current_keydata,\n\t    keydata_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tkey->zk_current_key.ck_data = key->zk_current_keydata;\n\tkey->zk_current_key.ck_length = CRYPTO_BYTES2BITS(keydata_len);\n\n\tkey->zk_hmac_key.ck_data = &key->zk_hmac_key;\n\tkey->zk_hmac_key.ck_length = CRYPTO_BYTES2BITS(SHA512_HMAC_KEYLEN);\n\n\t \n\tmech.cm_type = crypto_mech2id(zio_crypt_table[crypt].ci_mechname);\n\tret = crypto_create_ctx_template(&mech, &key->zk_current_key,\n\t    &key->zk_current_tmpl);\n\tif (ret != CRYPTO_SUCCESS)\n\t\tkey->zk_current_tmpl = NULL;\n\n\tmech.cm_type = crypto_mech2id(SUN_CKM_SHA512_HMAC);\n\tret = crypto_create_ctx_template(&mech, &key->zk_hmac_key,\n\t    &key->zk_hmac_tmpl);\n\tif (ret != CRYPTO_SUCCESS)\n\t\tkey->zk_hmac_tmpl = NULL;\n\n\tkey->zk_crypt = crypt;\n\tkey->zk_version = ZIO_CRYPT_KEY_CURRENT_VERSION;\n\tkey->zk_salt_count = 0;\n\n\treturn (0);\n\nerror:\n\tzio_crypt_key_destroy(key);\n\treturn (ret);\n}\n\nstatic int\nzio_crypt_key_change_salt(zio_crypt_key_t *key)\n{\n\tint ret = 0;\n\tuint8_t salt[ZIO_DATA_SALT_LEN];\n\tcrypto_mechanism_t mech;\n\tuint_t keydata_len = zio_crypt_table[key->zk_crypt].ci_keylen;\n\n\t \n\tret = random_get_bytes(salt, ZIO_DATA_SALT_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\trw_enter(&key->zk_salt_lock, RW_WRITER);\n\n\t \n\tif (key->zk_salt_count < ZFS_CURRENT_MAX_SALT_USES)\n\t\tgoto out_unlock;\n\n\t \n\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t    salt, ZIO_DATA_SALT_LEN, key->zk_current_keydata, keydata_len);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\t \n\tmemcpy(key->zk_salt, salt, ZIO_DATA_SALT_LEN);\n\tkey->zk_salt_count = 0;\n\n\t \n\tcrypto_destroy_ctx_template(key->zk_current_tmpl);\n\tret = crypto_create_ctx_template(&mech, &key->zk_current_key,\n\t    &key->zk_current_tmpl);\n\tif (ret != CRYPTO_SUCCESS)\n\t\tkey->zk_current_tmpl = NULL;\n\n\trw_exit(&key->zk_salt_lock);\n\n\treturn (0);\n\nout_unlock:\n\trw_exit(&key->zk_salt_lock);\nerror:\n\treturn (ret);\n}\n\n \nint\nzio_crypt_key_get_salt(zio_crypt_key_t *key, uint8_t *salt)\n{\n\tint ret;\n\tboolean_t salt_change;\n\n\trw_enter(&key->zk_salt_lock, RW_READER);\n\n\tmemcpy(salt, key->zk_salt, ZIO_DATA_SALT_LEN);\n\tsalt_change = (atomic_inc_64_nv(&key->zk_salt_count) >=\n\t    ZFS_CURRENT_MAX_SALT_USES);\n\n\trw_exit(&key->zk_salt_lock);\n\n\tif (salt_change) {\n\t\tret = zio_crypt_key_change_salt(key);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\n \nstatic int\nzio_do_crypt_uio(boolean_t encrypt, uint64_t crypt, crypto_key_t *key,\n    crypto_ctx_template_t tmpl, uint8_t *ivbuf, uint_t datalen,\n    zfs_uio_t *puio, zfs_uio_t *cuio, uint8_t *authbuf, uint_t auth_len)\n{\n\tint ret;\n\tcrypto_data_t plaindata, cipherdata;\n\tCK_AES_CCM_PARAMS ccmp;\n\tCK_AES_GCM_PARAMS gcmp;\n\tcrypto_mechanism_t mech;\n\tzio_crypt_info_t crypt_info;\n\tuint_t plain_full_len, maclen;\n\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\t \n\tcrypt_info = zio_crypt_table[crypt];\n\n\t \n\tmaclen = cuio->uio_iov[cuio->uio_iovcnt - 1].iov_len;\n\n\tASSERT(maclen <= ZIO_DATA_MAC_LEN);\n\n\t \n\tmech.cm_type = crypto_mech2id(crypt_info.ci_mechname);\n\n\t \n\tif (encrypt) {\n\t\tplain_full_len = datalen;\n\t} else {\n\t\tplain_full_len = datalen + maclen;\n\t}\n\n\t \n\tif (crypt_info.ci_crypt_type == ZC_TYPE_CCM) {\n\t\tccmp.ulNonceSize = ZIO_DATA_IV_LEN;\n\t\tccmp.ulAuthDataSize = auth_len;\n\t\tccmp.authData = authbuf;\n\t\tccmp.ulMACSize = maclen;\n\t\tccmp.nonce = ivbuf;\n\t\tccmp.ulDataSize = plain_full_len;\n\n\t\tmech.cm_param = (char *)(&ccmp);\n\t\tmech.cm_param_len = sizeof (CK_AES_CCM_PARAMS);\n\t} else {\n\t\tgcmp.ulIvLen = ZIO_DATA_IV_LEN;\n\t\tgcmp.ulIvBits = CRYPTO_BYTES2BITS(ZIO_DATA_IV_LEN);\n\t\tgcmp.ulAADLen = auth_len;\n\t\tgcmp.pAAD = authbuf;\n\t\tgcmp.ulTagBits = CRYPTO_BYTES2BITS(maclen);\n\t\tgcmp.pIv = ivbuf;\n\n\t\tmech.cm_param = (char *)(&gcmp);\n\t\tmech.cm_param_len = sizeof (CK_AES_GCM_PARAMS);\n\t}\n\n\t \n\tplaindata.cd_format = CRYPTO_DATA_UIO;\n\tplaindata.cd_offset = 0;\n\tplaindata.cd_uio = puio;\n\tplaindata.cd_length = plain_full_len;\n\n\tcipherdata.cd_format = CRYPTO_DATA_UIO;\n\tcipherdata.cd_offset = 0;\n\tcipherdata.cd_uio = cuio;\n\tcipherdata.cd_length = datalen + maclen;\n\n\t \n\tif (encrypt) {\n\t\tret = crypto_encrypt(&mech, &plaindata, key, tmpl, &cipherdata);\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\tret = SET_ERROR(EIO);\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tret = crypto_decrypt(&mech, &cipherdata, key, tmpl, &plaindata);\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\tASSERT3U(ret, ==, CRYPTO_INVALID_MAC);\n\t\t\tret = SET_ERROR(ECKSUM);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\nint\nzio_crypt_key_wrap(crypto_key_t *cwkey, zio_crypt_key_t *key, uint8_t *iv,\n    uint8_t *mac, uint8_t *keydata_out, uint8_t *hmac_keydata_out)\n{\n\tint ret;\n\tzfs_uio_t puio, cuio;\n\tuint64_t aad[3];\n\tiovec_t plain_iovecs[2], cipher_iovecs[3];\n\tuint64_t crypt = key->zk_crypt;\n\tuint_t enc_len, keydata_len, aad_len;\n\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\tkeydata_len = zio_crypt_table[crypt].ci_keylen;\n\n\t \n\tret = random_get_pseudo_bytes(iv, WRAPPING_IV_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tplain_iovecs[0].iov_base = key->zk_master_keydata;\n\tplain_iovecs[0].iov_len = keydata_len;\n\tplain_iovecs[1].iov_base = key->zk_hmac_keydata;\n\tplain_iovecs[1].iov_len = SHA512_HMAC_KEYLEN;\n\n\tcipher_iovecs[0].iov_base = keydata_out;\n\tcipher_iovecs[0].iov_len = keydata_len;\n\tcipher_iovecs[1].iov_base = hmac_keydata_out;\n\tcipher_iovecs[1].iov_len = SHA512_HMAC_KEYLEN;\n\tcipher_iovecs[2].iov_base = mac;\n\tcipher_iovecs[2].iov_len = WRAPPING_MAC_LEN;\n\n\t \n\tif (key->zk_version == 0) {\n\t\taad_len = sizeof (uint64_t);\n\t\taad[0] = LE_64(key->zk_guid);\n\t} else {\n\t\tASSERT3U(key->zk_version, ==, ZIO_CRYPT_KEY_CURRENT_VERSION);\n\t\taad_len = sizeof (uint64_t) * 3;\n\t\taad[0] = LE_64(key->zk_guid);\n\t\taad[1] = LE_64(crypt);\n\t\taad[2] = LE_64(key->zk_version);\n\t}\n\n\tenc_len = zio_crypt_table[crypt].ci_keylen + SHA512_HMAC_KEYLEN;\n\tpuio.uio_iov = plain_iovecs;\n\tpuio.uio_iovcnt = 2;\n\tpuio.uio_segflg = UIO_SYSSPACE;\n\tcuio.uio_iov = cipher_iovecs;\n\tcuio.uio_iovcnt = 3;\n\tcuio.uio_segflg = UIO_SYSSPACE;\n\n\t \n\tret = zio_do_crypt_uio(B_TRUE, crypt, cwkey, NULL, iv, enc_len,\n\t    &puio, &cuio, (uint8_t *)aad, aad_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\nint\nzio_crypt_key_unwrap(crypto_key_t *cwkey, uint64_t crypt, uint64_t version,\n    uint64_t guid, uint8_t *keydata, uint8_t *hmac_keydata, uint8_t *iv,\n    uint8_t *mac, zio_crypt_key_t *key)\n{\n\tcrypto_mechanism_t mech;\n\tzfs_uio_t puio, cuio;\n\tuint64_t aad[3];\n\tiovec_t plain_iovecs[2], cipher_iovecs[3];\n\tuint_t enc_len, keydata_len, aad_len;\n\tint ret;\n\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\trw_init(&key->zk_salt_lock, NULL, RW_DEFAULT, NULL);\n\n\tkeydata_len = zio_crypt_table[crypt].ci_keylen;\n\n\t \n\tplain_iovecs[0].iov_base = key->zk_master_keydata;\n\tplain_iovecs[0].iov_len = keydata_len;\n\tplain_iovecs[1].iov_base = key->zk_hmac_keydata;\n\tplain_iovecs[1].iov_len = SHA512_HMAC_KEYLEN;\n\n\tcipher_iovecs[0].iov_base = keydata;\n\tcipher_iovecs[0].iov_len = keydata_len;\n\tcipher_iovecs[1].iov_base = hmac_keydata;\n\tcipher_iovecs[1].iov_len = SHA512_HMAC_KEYLEN;\n\tcipher_iovecs[2].iov_base = mac;\n\tcipher_iovecs[2].iov_len = WRAPPING_MAC_LEN;\n\n\tif (version == 0) {\n\t\taad_len = sizeof (uint64_t);\n\t\taad[0] = LE_64(guid);\n\t} else {\n\t\tASSERT3U(version, ==, ZIO_CRYPT_KEY_CURRENT_VERSION);\n\t\taad_len = sizeof (uint64_t) * 3;\n\t\taad[0] = LE_64(guid);\n\t\taad[1] = LE_64(crypt);\n\t\taad[2] = LE_64(version);\n\t}\n\n\tenc_len = keydata_len + SHA512_HMAC_KEYLEN;\n\tpuio.uio_iov = plain_iovecs;\n\tpuio.uio_segflg = UIO_SYSSPACE;\n\tpuio.uio_iovcnt = 2;\n\tcuio.uio_iov = cipher_iovecs;\n\tcuio.uio_iovcnt = 3;\n\tcuio.uio_segflg = UIO_SYSSPACE;\n\n\t \n\tret = zio_do_crypt_uio(B_FALSE, crypt, cwkey, NULL, iv, enc_len,\n\t    &puio, &cuio, (uint8_t *)aad, aad_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = random_get_bytes(key->zk_salt, ZIO_DATA_SALT_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t    key->zk_salt, ZIO_DATA_SALT_LEN, key->zk_current_keydata,\n\t    keydata_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tkey->zk_current_key.ck_data = key->zk_current_keydata;\n\tkey->zk_current_key.ck_length = CRYPTO_BYTES2BITS(keydata_len);\n\n\tkey->zk_hmac_key.ck_data = key->zk_hmac_keydata;\n\tkey->zk_hmac_key.ck_length = CRYPTO_BYTES2BITS(SHA512_HMAC_KEYLEN);\n\n\t \n\tmech.cm_type = crypto_mech2id(zio_crypt_table[crypt].ci_mechname);\n\tret = crypto_create_ctx_template(&mech, &key->zk_current_key,\n\t    &key->zk_current_tmpl);\n\tif (ret != CRYPTO_SUCCESS)\n\t\tkey->zk_current_tmpl = NULL;\n\n\tmech.cm_type = crypto_mech2id(SUN_CKM_SHA512_HMAC);\n\tret = crypto_create_ctx_template(&mech, &key->zk_hmac_key,\n\t    &key->zk_hmac_tmpl);\n\tif (ret != CRYPTO_SUCCESS)\n\t\tkey->zk_hmac_tmpl = NULL;\n\n\tkey->zk_crypt = crypt;\n\tkey->zk_version = version;\n\tkey->zk_guid = guid;\n\tkey->zk_salt_count = 0;\n\n\treturn (0);\n\nerror:\n\tzio_crypt_key_destroy(key);\n\treturn (ret);\n}\n\nint\nzio_crypt_generate_iv(uint8_t *ivbuf)\n{\n\tint ret;\n\n\t \n\tret = random_get_pseudo_bytes(ivbuf, ZIO_DATA_IV_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\treturn (0);\n\nerror:\n\tmemset(ivbuf, 0, ZIO_DATA_IV_LEN);\n\treturn (ret);\n}\n\nint\nzio_crypt_do_hmac(zio_crypt_key_t *key, uint8_t *data, uint_t datalen,\n    uint8_t *digestbuf, uint_t digestlen)\n{\n\tint ret;\n\tcrypto_mechanism_t mech;\n\tcrypto_data_t in_data, digest_data;\n\tuint8_t raw_digestbuf[SHA512_DIGEST_LENGTH];\n\n\tASSERT3U(digestlen, <=, SHA512_DIGEST_LENGTH);\n\n\t \n\tmech.cm_type = crypto_mech2id(SUN_CKM_SHA512_HMAC);\n\tmech.cm_param = NULL;\n\tmech.cm_param_len = 0;\n\n\t \n\tin_data.cd_format = CRYPTO_DATA_RAW;\n\tin_data.cd_offset = 0;\n\tin_data.cd_length = datalen;\n\tin_data.cd_raw.iov_base = (char *)data;\n\tin_data.cd_raw.iov_len = in_data.cd_length;\n\n\tdigest_data.cd_format = CRYPTO_DATA_RAW;\n\tdigest_data.cd_offset = 0;\n\tdigest_data.cd_length = SHA512_DIGEST_LENGTH;\n\tdigest_data.cd_raw.iov_base = (char *)raw_digestbuf;\n\tdigest_data.cd_raw.iov_len = digest_data.cd_length;\n\n\t \n\tret = crypto_mac(&mech, &in_data, &key->zk_hmac_key, key->zk_hmac_tmpl,\n\t    &digest_data);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\tmemcpy(digestbuf, raw_digestbuf, digestlen);\n\n\treturn (0);\n\nerror:\n\tmemset(digestbuf, 0, digestlen);\n\treturn (ret);\n}\n\nint\nzio_crypt_generate_iv_salt_dedup(zio_crypt_key_t *key, uint8_t *data,\n    uint_t datalen, uint8_t *ivbuf, uint8_t *salt)\n{\n\tint ret;\n\tuint8_t digestbuf[SHA512_DIGEST_LENGTH];\n\n\tret = zio_crypt_do_hmac(key, data, datalen,\n\t    digestbuf, SHA512_DIGEST_LENGTH);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tmemcpy(salt, digestbuf, ZIO_DATA_SALT_LEN);\n\tmemcpy(ivbuf, digestbuf + ZIO_DATA_SALT_LEN, ZIO_DATA_IV_LEN);\n\n\treturn (0);\n}\n\n \nvoid\nzio_crypt_encode_params_bp(blkptr_t *bp, uint8_t *salt, uint8_t *iv)\n{\n\tuint64_t val64;\n\tuint32_t val32;\n\n\tASSERT(BP_IS_ENCRYPTED(bp));\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(&bp->blk_dva[2].dva_word[0], salt, sizeof (uint64_t));\n\t\tmemcpy(&bp->blk_dva[2].dva_word[1], iv, sizeof (uint64_t));\n\t\tmemcpy(&val32, iv + sizeof (uint64_t), sizeof (uint32_t));\n\t\tBP_SET_IV2(bp, val32);\n\t} else {\n\t\tmemcpy(&val64, salt, sizeof (uint64_t));\n\t\tbp->blk_dva[2].dva_word[0] = BSWAP_64(val64);\n\n\t\tmemcpy(&val64, iv, sizeof (uint64_t));\n\t\tbp->blk_dva[2].dva_word[1] = BSWAP_64(val64);\n\n\t\tmemcpy(&val32, iv + sizeof (uint64_t), sizeof (uint32_t));\n\t\tBP_SET_IV2(bp, BSWAP_32(val32));\n\t}\n}\n\nvoid\nzio_crypt_decode_params_bp(const blkptr_t *bp, uint8_t *salt, uint8_t *iv)\n{\n\tuint64_t val64;\n\tuint32_t val32;\n\n\tASSERT(BP_IS_PROTECTED(bp));\n\n\t \n\tif (BP_IS_AUTHENTICATED(bp)) {\n\t\tmemset(salt, 0, ZIO_DATA_SALT_LEN);\n\t\tmemset(iv, 0, ZIO_DATA_IV_LEN);\n\t\treturn;\n\t}\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(salt, &bp->blk_dva[2].dva_word[0], sizeof (uint64_t));\n\t\tmemcpy(iv, &bp->blk_dva[2].dva_word[1], sizeof (uint64_t));\n\n\t\tval32 = (uint32_t)BP_GET_IV2(bp);\n\t\tmemcpy(iv + sizeof (uint64_t), &val32, sizeof (uint32_t));\n\t} else {\n\t\tval64 = BSWAP_64(bp->blk_dva[2].dva_word[0]);\n\t\tmemcpy(salt, &val64, sizeof (uint64_t));\n\n\t\tval64 = BSWAP_64(bp->blk_dva[2].dva_word[1]);\n\t\tmemcpy(iv, &val64, sizeof (uint64_t));\n\n\t\tval32 = BSWAP_32((uint32_t)BP_GET_IV2(bp));\n\t\tmemcpy(iv + sizeof (uint64_t), &val32, sizeof (uint32_t));\n\t}\n}\n\nvoid\nzio_crypt_encode_mac_bp(blkptr_t *bp, uint8_t *mac)\n{\n\tuint64_t val64;\n\n\tASSERT(BP_USES_CRYPT(bp));\n\tASSERT3U(BP_GET_TYPE(bp), !=, DMU_OT_OBJSET);\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(&bp->blk_cksum.zc_word[2], mac, sizeof (uint64_t));\n\t\tmemcpy(&bp->blk_cksum.zc_word[3], mac + sizeof (uint64_t),\n\t\t    sizeof (uint64_t));\n\t} else {\n\t\tmemcpy(&val64, mac, sizeof (uint64_t));\n\t\tbp->blk_cksum.zc_word[2] = BSWAP_64(val64);\n\n\t\tmemcpy(&val64, mac + sizeof (uint64_t), sizeof (uint64_t));\n\t\tbp->blk_cksum.zc_word[3] = BSWAP_64(val64);\n\t}\n}\n\nvoid\nzio_crypt_decode_mac_bp(const blkptr_t *bp, uint8_t *mac)\n{\n\tuint64_t val64;\n\n\tASSERT(BP_USES_CRYPT(bp) || BP_IS_HOLE(bp));\n\n\t \n\tif (BP_GET_TYPE(bp) == DMU_OT_OBJSET) {\n\t\tmemset(mac, 0, ZIO_DATA_MAC_LEN);\n\t\treturn;\n\t}\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(mac, &bp->blk_cksum.zc_word[2], sizeof (uint64_t));\n\t\tmemcpy(mac + sizeof (uint64_t), &bp->blk_cksum.zc_word[3],\n\t\t    sizeof (uint64_t));\n\t} else {\n\t\tval64 = BSWAP_64(bp->blk_cksum.zc_word[2]);\n\t\tmemcpy(mac, &val64, sizeof (uint64_t));\n\n\t\tval64 = BSWAP_64(bp->blk_cksum.zc_word[3]);\n\t\tmemcpy(mac + sizeof (uint64_t), &val64, sizeof (uint64_t));\n\t}\n}\n\nvoid\nzio_crypt_encode_mac_zil(void *data, uint8_t *mac)\n{\n\tzil_chain_t *zilc = data;\n\n\tmemcpy(&zilc->zc_eck.zec_cksum.zc_word[2], mac, sizeof (uint64_t));\n\tmemcpy(&zilc->zc_eck.zec_cksum.zc_word[3], mac + sizeof (uint64_t),\n\t    sizeof (uint64_t));\n}\n\nvoid\nzio_crypt_decode_mac_zil(const void *data, uint8_t *mac)\n{\n\t \n\tconst zil_chain_t *zilc = data;\n\n\tmemcpy(mac, &zilc->zc_eck.zec_cksum.zc_word[2], sizeof (uint64_t));\n\tmemcpy(mac + sizeof (uint64_t), &zilc->zc_eck.zec_cksum.zc_word[3],\n\t    sizeof (uint64_t));\n}\n\n \nvoid\nzio_crypt_copy_dnode_bonus(abd_t *src_abd, uint8_t *dst, uint_t datalen)\n{\n\tuint_t i, max_dnp = datalen >> DNODE_SHIFT;\n\tuint8_t *src;\n\tdnode_phys_t *dnp, *sdnp, *ddnp;\n\n\tsrc = abd_borrow_buf_copy(src_abd, datalen);\n\n\tsdnp = (dnode_phys_t *)src;\n\tddnp = (dnode_phys_t *)dst;\n\n\tfor (i = 0; i < max_dnp; i += sdnp[i].dn_extra_slots + 1) {\n\t\tdnp = &sdnp[i];\n\t\tif (dnp->dn_type != DMU_OT_NONE &&\n\t\t    DMU_OT_IS_ENCRYPTED(dnp->dn_bonustype) &&\n\t\t    dnp->dn_bonuslen != 0) {\n\t\t\tmemcpy(DN_BONUS(&ddnp[i]), DN_BONUS(dnp),\n\t\t\t    DN_MAX_BONUS_LEN(dnp));\n\t\t}\n\t}\n\n\tabd_return_buf(src_abd, src, datalen);\n}\n\n \nstatic void\nzio_crypt_bp_zero_nonportable_blkprop(blkptr_t *bp, uint64_t version)\n{\n\t \n\tif (version == 0) {\n\t\tBP_SET_DEDUP(bp, 0);\n\t\tBP_SET_CHECKSUM(bp, 0);\n\t\tBP_SET_PSIZE(bp, SPA_MINBLOCKSIZE);\n\t\treturn;\n\t}\n\n\tASSERT3U(version, ==, ZIO_CRYPT_KEY_CURRENT_VERSION);\n\n\t \n\tif (BP_IS_HOLE(bp)) {\n\t\tbp->blk_prop = 0ULL;\n\t\treturn;\n\t}\n\n\t \n\tif (BP_GET_LEVEL(bp) != 0) {\n\t\tBP_SET_BYTEORDER(bp, 0);\n\t\tBP_SET_COMPRESS(bp, 0);\n\n\t\t \n\t\tBP_SET_PSIZE(bp, SPA_MINBLOCKSIZE);\n\t}\n\n\tBP_SET_DEDUP(bp, 0);\n\tBP_SET_CHECKSUM(bp, 0);\n}\n\nstatic void\nzio_crypt_bp_auth_init(uint64_t version, boolean_t should_bswap, blkptr_t *bp,\n    blkptr_auth_buf_t *bab, uint_t *bab_len)\n{\n\tblkptr_t tmpbp = *bp;\n\n\tif (should_bswap)\n\t\tbyteswap_uint64_array(&tmpbp, sizeof (blkptr_t));\n\n\tASSERT(BP_USES_CRYPT(&tmpbp) || BP_IS_HOLE(&tmpbp));\n\tASSERT0(BP_IS_EMBEDDED(&tmpbp));\n\n\tzio_crypt_decode_mac_bp(&tmpbp, bab->bab_mac);\n\n\t \n\tzio_crypt_bp_zero_nonportable_blkprop(&tmpbp, version);\n\tbab->bab_prop = LE_64(tmpbp.blk_prop);\n\tbab->bab_pad = 0ULL;\n\n\t \n\t*bab_len = sizeof (blkptr_auth_buf_t);\n\tif (version == 0)\n\t\t*bab_len -= sizeof (uint64_t);\n}\n\nstatic int\nzio_crypt_bp_do_hmac_updates(crypto_context_t ctx, uint64_t version,\n    boolean_t should_bswap, blkptr_t *bp)\n{\n\tint ret;\n\tuint_t bab_len;\n\tblkptr_auth_buf_t bab;\n\tcrypto_data_t cd;\n\n\tzio_crypt_bp_auth_init(version, should_bswap, bp, &bab, &bab_len);\n\tcd.cd_format = CRYPTO_DATA_RAW;\n\tcd.cd_offset = 0;\n\tcd.cd_length = bab_len;\n\tcd.cd_raw.iov_base = (char *)&bab;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_update(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\nstatic void\nzio_crypt_bp_do_indrect_checksum_updates(SHA2_CTX *ctx, uint64_t version,\n    boolean_t should_bswap, blkptr_t *bp)\n{\n\tuint_t bab_len;\n\tblkptr_auth_buf_t bab;\n\n\tzio_crypt_bp_auth_init(version, should_bswap, bp, &bab, &bab_len);\n\tSHA2Update(ctx, &bab, bab_len);\n}\n\nstatic void\nzio_crypt_bp_do_aad_updates(uint8_t **aadp, uint_t *aad_len, uint64_t version,\n    boolean_t should_bswap, blkptr_t *bp)\n{\n\tuint_t bab_len;\n\tblkptr_auth_buf_t bab;\n\n\tzio_crypt_bp_auth_init(version, should_bswap, bp, &bab, &bab_len);\n\tmemcpy(*aadp, &bab, bab_len);\n\t*aadp += bab_len;\n\t*aad_len += bab_len;\n}\n\nstatic int\nzio_crypt_do_dnode_hmac_updates(crypto_context_t ctx, uint64_t version,\n    boolean_t should_bswap, dnode_phys_t *dnp)\n{\n\tint ret, i;\n\tdnode_phys_t *adnp, tmp_dncore;\n\tsize_t dn_core_size = offsetof(dnode_phys_t, dn_blkptr);\n\tboolean_t le_bswap = (should_bswap == ZFS_HOST_BYTEORDER);\n\tcrypto_data_t cd;\n\n\tcd.cd_format = CRYPTO_DATA_RAW;\n\tcd.cd_offset = 0;\n\n\t \n\tmemcpy(&tmp_dncore, dnp, dn_core_size);\n\tadnp = &tmp_dncore;\n\n\tif (le_bswap) {\n\t\tadnp->dn_datablkszsec = BSWAP_16(adnp->dn_datablkszsec);\n\t\tadnp->dn_bonuslen = BSWAP_16(adnp->dn_bonuslen);\n\t\tadnp->dn_maxblkid = BSWAP_64(adnp->dn_maxblkid);\n\t\tadnp->dn_used = BSWAP_64(adnp->dn_used);\n\t}\n\tadnp->dn_flags &= DNODE_CRYPT_PORTABLE_FLAGS_MASK;\n\tadnp->dn_used = 0;\n\n\tcd.cd_length = dn_core_size;\n\tcd.cd_raw.iov_base = (char *)adnp;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_update(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < dnp->dn_nblkptr; i++) {\n\t\tret = zio_crypt_bp_do_hmac_updates(ctx, version,\n\t\t    should_bswap, &dnp->dn_blkptr[i]);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\tret = zio_crypt_bp_do_hmac_updates(ctx, version,\n\t\t    should_bswap, DN_SPILL_BLKPTR(dnp));\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\n \nint\nzio_crypt_do_objset_hmacs(zio_crypt_key_t *key, void *data, uint_t datalen,\n    boolean_t should_bswap, uint8_t *portable_mac, uint8_t *local_mac)\n{\n\tint ret;\n\tcrypto_mechanism_t mech;\n\tcrypto_context_t ctx;\n\tcrypto_data_t cd;\n\tobjset_phys_t *osp = data;\n\tuint64_t intval;\n\tboolean_t le_bswap = (should_bswap == ZFS_HOST_BYTEORDER);\n\tuint8_t raw_portable_mac[SHA512_DIGEST_LENGTH];\n\tuint8_t raw_local_mac[SHA512_DIGEST_LENGTH];\n\n\t \n\tmech.cm_type = crypto_mech2id(SUN_CKM_SHA512_HMAC);\n\tmech.cm_param = NULL;\n\tmech.cm_param_len = 0;\n\n\tcd.cd_format = CRYPTO_DATA_RAW;\n\tcd.cd_offset = 0;\n\n\t \n\tret = crypto_mac_init(&mech, &key->zk_hmac_key, NULL, &ctx);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\t \n\tintval = (le_bswap) ? osp->os_type : BSWAP_64(osp->os_type);\n\tcd.cd_length = sizeof (uint64_t);\n\tcd.cd_raw.iov_base = (char *)&intval;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_update(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\t \n\tintval = osp->os_flags;\n\tif (should_bswap)\n\t\tintval = BSWAP_64(intval);\n\tintval &= OBJSET_CRYPT_PORTABLE_FLAGS_MASK;\n\tif (!ZFS_HOST_BYTEORDER)\n\t\tintval = BSWAP_64(intval);\n\n\tcd.cd_length = sizeof (uint64_t);\n\tcd.cd_raw.iov_base = (char *)&intval;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_update(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\t \n\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t    should_bswap, &osp->os_meta_dnode);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tcd.cd_length = SHA512_DIGEST_LENGTH;\n\tcd.cd_raw.iov_base = (char *)raw_portable_mac;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_final(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\tmemcpy(portable_mac, raw_portable_mac, ZIO_OBJSET_MAC_LEN);\n\n\t \n\tintval = osp->os_flags;\n\tif (should_bswap)\n\t\tintval = BSWAP_64(intval);\n\tboolean_t uacct_incomplete =\n\t    !(intval & OBJSET_FLAG_USERACCOUNTING_COMPLETE);\n\n\t \n\tif (uacct_incomplete ||\n\t    (datalen >= OBJSET_PHYS_SIZE_V3 &&\n\t    osp->os_userused_dnode.dn_type == DMU_OT_NONE &&\n\t    osp->os_groupused_dnode.dn_type == DMU_OT_NONE &&\n\t    osp->os_projectused_dnode.dn_type == DMU_OT_NONE) ||\n\t    (datalen >= OBJSET_PHYS_SIZE_V2 &&\n\t    osp->os_userused_dnode.dn_type == DMU_OT_NONE &&\n\t    osp->os_groupused_dnode.dn_type == DMU_OT_NONE) ||\n\t    (datalen <= OBJSET_PHYS_SIZE_V1)) {\n\t\tmemset(local_mac, 0, ZIO_OBJSET_MAC_LEN);\n\t\treturn (0);\n\t}\n\n\t \n\tret = crypto_mac_init(&mech, &key->zk_hmac_key, NULL, &ctx);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\t \n\tintval = osp->os_flags;\n\tif (should_bswap)\n\t\tintval = BSWAP_64(intval);\n\tintval &= ~OBJSET_CRYPT_PORTABLE_FLAGS_MASK;\n\tif (!ZFS_HOST_BYTEORDER)\n\t\tintval = BSWAP_64(intval);\n\n\tcd.cd_length = sizeof (uint64_t);\n\tcd.cd_raw.iov_base = (char *)&intval;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_update(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\t \n\tif (osp->os_userused_dnode.dn_type != DMU_OT_NONE) {\n\t\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t\t    should_bswap, &osp->os_userused_dnode);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (osp->os_groupused_dnode.dn_type != DMU_OT_NONE) {\n\t\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t\t    should_bswap, &osp->os_groupused_dnode);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (osp->os_projectused_dnode.dn_type != DMU_OT_NONE &&\n\t    datalen >= OBJSET_PHYS_SIZE_V3) {\n\t\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t\t    should_bswap, &osp->os_projectused_dnode);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\t \n\tcd.cd_length = SHA512_DIGEST_LENGTH;\n\tcd.cd_raw.iov_base = (char *)raw_local_mac;\n\tcd.cd_raw.iov_len = cd.cd_length;\n\n\tret = crypto_mac_final(ctx, &cd);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tret = SET_ERROR(EIO);\n\t\tgoto error;\n\t}\n\n\tmemcpy(local_mac, raw_local_mac, ZIO_OBJSET_MAC_LEN);\n\n\treturn (0);\n\nerror:\n\tmemset(portable_mac, 0, ZIO_OBJSET_MAC_LEN);\n\tmemset(local_mac, 0, ZIO_OBJSET_MAC_LEN);\n\treturn (ret);\n}\n\nstatic void\nzio_crypt_destroy_uio(zfs_uio_t *uio)\n{\n\tif (uio->uio_iov)\n\t\tkmem_free(uio->uio_iov, uio->uio_iovcnt * sizeof (iovec_t));\n}\n\n \nstatic int\nzio_crypt_do_indirect_mac_checksum_impl(boolean_t generate, void *buf,\n    uint_t datalen, uint64_t version, boolean_t byteswap, uint8_t *cksum)\n{\n\tblkptr_t *bp;\n\tint i, epb = datalen >> SPA_BLKPTRSHIFT;\n\tSHA2_CTX ctx;\n\tuint8_t digestbuf[SHA512_DIGEST_LENGTH];\n\n\t \n\tSHA2Init(SHA512, &ctx);\n\tfor (i = 0, bp = buf; i < epb; i++, bp++) {\n\t\tzio_crypt_bp_do_indrect_checksum_updates(&ctx, version,\n\t\t    byteswap, bp);\n\t}\n\tSHA2Final(digestbuf, &ctx);\n\n\tif (generate) {\n\t\tmemcpy(cksum, digestbuf, ZIO_DATA_MAC_LEN);\n\t\treturn (0);\n\t}\n\n\tif (memcmp(digestbuf, cksum, ZIO_DATA_MAC_LEN) != 0)\n\t\treturn (SET_ERROR(ECKSUM));\n\n\treturn (0);\n}\n\nint\nzio_crypt_do_indirect_mac_checksum(boolean_t generate, void *buf,\n    uint_t datalen, boolean_t byteswap, uint8_t *cksum)\n{\n\tint ret;\n\n\t \n\tret = zio_crypt_do_indirect_mac_checksum_impl(generate, buf,\n\t    datalen, ZIO_CRYPT_KEY_CURRENT_VERSION, byteswap, cksum);\n\tif (ret == ECKSUM) {\n\t\tASSERT(!generate);\n\t\tret = zio_crypt_do_indirect_mac_checksum_impl(generate,\n\t\t    buf, datalen, 0, byteswap, cksum);\n\t}\n\n\treturn (ret);\n}\n\nint\nzio_crypt_do_indirect_mac_checksum_abd(boolean_t generate, abd_t *abd,\n    uint_t datalen, boolean_t byteswap, uint8_t *cksum)\n{\n\tint ret;\n\tvoid *buf;\n\n\tbuf = abd_borrow_buf_copy(abd, datalen);\n\tret = zio_crypt_do_indirect_mac_checksum(generate, buf, datalen,\n\t    byteswap, cksum);\n\tabd_return_buf(abd, buf, datalen);\n\n\treturn (ret);\n}\n\n \nstatic int\nzio_crypt_init_uios_zil(boolean_t encrypt, uint8_t *plainbuf,\n    uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap, zfs_uio_t *puio,\n    zfs_uio_t *cuio, uint_t *enc_len, uint8_t **authbuf, uint_t *auth_len,\n    boolean_t *no_crypt)\n{\n\tint ret;\n\tuint64_t txtype, lr_len;\n\tuint_t nr_src, nr_dst, crypt_len;\n\tuint_t aad_len = 0, nr_iovecs = 0, total_len = 0;\n\tiovec_t *src_iovecs = NULL, *dst_iovecs = NULL;\n\tuint8_t *src, *dst, *slrp, *dlrp, *blkend, *aadp;\n\tzil_chain_t *zilc;\n\tlr_t *lr;\n\tuint8_t *aadbuf = zio_buf_alloc(datalen);\n\n\t \n\tif (encrypt) {\n\t\tsrc = plainbuf;\n\t\tdst = cipherbuf;\n\t\tnr_src = 0;\n\t\tnr_dst = 1;\n\t} else {\n\t\tsrc = cipherbuf;\n\t\tdst = plainbuf;\n\t\tnr_src = 1;\n\t\tnr_dst = 0;\n\t}\n\tmemset(dst, 0, datalen);\n\n\t \n\tzilc = (zil_chain_t *)src;\n\tslrp = src + sizeof (zil_chain_t);\n\taadp = aadbuf;\n\tblkend = src + ((byteswap) ? BSWAP_64(zilc->zc_nused) : zilc->zc_nused);\n\n\t \n\tfor (; slrp < blkend; slrp += lr_len) {\n\t\tlr = (lr_t *)slrp;\n\n\t\tif (!byteswap) {\n\t\t\ttxtype = lr->lrc_txtype;\n\t\t\tlr_len = lr->lrc_reclen;\n\t\t} else {\n\t\t\ttxtype = BSWAP_64(lr->lrc_txtype);\n\t\t\tlr_len = BSWAP_64(lr->lrc_reclen);\n\t\t}\n\n\t\tnr_iovecs++;\n\t\tif (txtype == TX_WRITE && lr_len != sizeof (lr_write_t))\n\t\t\tnr_iovecs++;\n\t}\n\n\tnr_src += nr_iovecs;\n\tnr_dst += nr_iovecs;\n\n\t \n\tif (nr_src != 0) {\n\t\tsrc_iovecs = kmem_alloc(nr_src * sizeof (iovec_t), KM_SLEEP);\n\t\tif (src_iovecs == NULL) {\n\t\t\tret = SET_ERROR(ENOMEM);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (nr_dst != 0) {\n\t\tdst_iovecs = kmem_alloc(nr_dst * sizeof (iovec_t), KM_SLEEP);\n\t\tif (dst_iovecs == NULL) {\n\t\t\tret = SET_ERROR(ENOMEM);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tmemcpy(dst, src, sizeof (zil_chain_t));\n\tmemcpy(aadp, src, sizeof (zil_chain_t) - sizeof (zio_eck_t));\n\taadp += sizeof (zil_chain_t) - sizeof (zio_eck_t);\n\taad_len += sizeof (zil_chain_t) - sizeof (zio_eck_t);\n\n\t \n\tnr_iovecs = 0;\n\tslrp = src + sizeof (zil_chain_t);\n\tdlrp = dst + sizeof (zil_chain_t);\n\n\tfor (; slrp < blkend; slrp += lr_len, dlrp += lr_len) {\n\t\tlr = (lr_t *)slrp;\n\n\t\tif (!byteswap) {\n\t\t\ttxtype = lr->lrc_txtype;\n\t\t\tlr_len = lr->lrc_reclen;\n\t\t} else {\n\t\t\ttxtype = BSWAP_64(lr->lrc_txtype);\n\t\t\tlr_len = BSWAP_64(lr->lrc_reclen);\n\t\t}\n\n\t\t \n\t\tmemcpy(dlrp, slrp, sizeof (lr_t));\n\t\tmemcpy(aadp, slrp, sizeof (lr_t));\n\t\taadp += sizeof (lr_t);\n\t\taad_len += sizeof (lr_t);\n\n\t\tASSERT3P(src_iovecs, !=, NULL);\n\t\tASSERT3P(dst_iovecs, !=, NULL);\n\n\t\t \n\t\tif (txtype == TX_WRITE) {\n\t\t\tcrypt_len = sizeof (lr_write_t) -\n\t\t\t    sizeof (lr_t) - sizeof (blkptr_t);\n\t\t\tsrc_iovecs[nr_iovecs].iov_base = slrp + sizeof (lr_t);\n\t\t\tsrc_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\tdst_iovecs[nr_iovecs].iov_base = dlrp + sizeof (lr_t);\n\t\t\tdst_iovecs[nr_iovecs].iov_len = crypt_len;\n\n\t\t\t \n\t\t\tmemcpy(dlrp + sizeof (lr_write_t) - sizeof (blkptr_t),\n\t\t\t    slrp + sizeof (lr_write_t) - sizeof (blkptr_t),\n\t\t\t    sizeof (blkptr_t));\n\t\t\tmemcpy(aadp,\n\t\t\t    slrp + sizeof (lr_write_t) - sizeof (blkptr_t),\n\t\t\t    sizeof (blkptr_t));\n\t\t\taadp += sizeof (blkptr_t);\n\t\t\taad_len += sizeof (blkptr_t);\n\t\t\tnr_iovecs++;\n\t\t\ttotal_len += crypt_len;\n\n\t\t\tif (lr_len != sizeof (lr_write_t)) {\n\t\t\t\tcrypt_len = lr_len - sizeof (lr_write_t);\n\t\t\t\tsrc_iovecs[nr_iovecs].iov_base =\n\t\t\t\t    slrp + sizeof (lr_write_t);\n\t\t\t\tsrc_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\t\tdst_iovecs[nr_iovecs].iov_base =\n\t\t\t\t    dlrp + sizeof (lr_write_t);\n\t\t\t\tdst_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\t\tnr_iovecs++;\n\t\t\t\ttotal_len += crypt_len;\n\t\t\t}\n\t\t} else if (txtype == TX_CLONE_RANGE) {\n\t\t\tconst size_t o = offsetof(lr_clone_range_t, lr_nbps);\n\t\t\tcrypt_len = o - sizeof (lr_t);\n\t\t\tsrc_iovecs[nr_iovecs].iov_base = slrp + sizeof (lr_t);\n\t\t\tsrc_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\tdst_iovecs[nr_iovecs].iov_base = dlrp + sizeof (lr_t);\n\t\t\tdst_iovecs[nr_iovecs].iov_len = crypt_len;\n\n\t\t\t \n\t\t\tmemcpy(dlrp + o, slrp + o, lr_len - o);\n\t\t\tmemcpy(aadp, slrp + o, lr_len - o);\n\t\t\taadp += lr_len - o;\n\t\t\taad_len += lr_len - o;\n\t\t\tnr_iovecs++;\n\t\t\ttotal_len += crypt_len;\n\t\t} else {\n\t\t\tcrypt_len = lr_len - sizeof (lr_t);\n\t\t\tsrc_iovecs[nr_iovecs].iov_base = slrp + sizeof (lr_t);\n\t\t\tsrc_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\tdst_iovecs[nr_iovecs].iov_base = dlrp + sizeof (lr_t);\n\t\t\tdst_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\tnr_iovecs++;\n\t\t\ttotal_len += crypt_len;\n\t\t}\n\t}\n\n\t*no_crypt = (nr_iovecs == 0);\n\t*enc_len = total_len;\n\t*authbuf = aadbuf;\n\t*auth_len = aad_len;\n\n\tif (encrypt) {\n\t\tpuio->uio_iov = src_iovecs;\n\t\tpuio->uio_iovcnt = nr_src;\n\t\tcuio->uio_iov = dst_iovecs;\n\t\tcuio->uio_iovcnt = nr_dst;\n\t} else {\n\t\tpuio->uio_iov = dst_iovecs;\n\t\tpuio->uio_iovcnt = nr_dst;\n\t\tcuio->uio_iov = src_iovecs;\n\t\tcuio->uio_iovcnt = nr_src;\n\t}\n\n\treturn (0);\n\nerror:\n\tzio_buf_free(aadbuf, datalen);\n\tif (src_iovecs != NULL)\n\t\tkmem_free(src_iovecs, nr_src * sizeof (iovec_t));\n\tif (dst_iovecs != NULL)\n\t\tkmem_free(dst_iovecs, nr_dst * sizeof (iovec_t));\n\n\t*enc_len = 0;\n\t*authbuf = NULL;\n\t*auth_len = 0;\n\t*no_crypt = B_FALSE;\n\tpuio->uio_iov = NULL;\n\tpuio->uio_iovcnt = 0;\n\tcuio->uio_iov = NULL;\n\tcuio->uio_iovcnt = 0;\n\treturn (ret);\n}\n\n \nstatic int\nzio_crypt_init_uios_dnode(boolean_t encrypt, uint64_t version,\n    uint8_t *plainbuf, uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap,\n    zfs_uio_t *puio, zfs_uio_t *cuio, uint_t *enc_len, uint8_t **authbuf,\n    uint_t *auth_len, boolean_t *no_crypt)\n{\n\tint ret;\n\tuint_t nr_src, nr_dst, crypt_len;\n\tuint_t aad_len = 0, nr_iovecs = 0, total_len = 0;\n\tuint_t i, j, max_dnp = datalen >> DNODE_SHIFT;\n\tiovec_t *src_iovecs = NULL, *dst_iovecs = NULL;\n\tuint8_t *src, *dst, *aadp;\n\tdnode_phys_t *dnp, *adnp, *sdnp, *ddnp;\n\tuint8_t *aadbuf = zio_buf_alloc(datalen);\n\n\tif (encrypt) {\n\t\tsrc = plainbuf;\n\t\tdst = cipherbuf;\n\t\tnr_src = 0;\n\t\tnr_dst = 1;\n\t} else {\n\t\tsrc = cipherbuf;\n\t\tdst = plainbuf;\n\t\tnr_src = 1;\n\t\tnr_dst = 0;\n\t}\n\n\tsdnp = (dnode_phys_t *)src;\n\tddnp = (dnode_phys_t *)dst;\n\taadp = aadbuf;\n\n\t \n\tfor (i = 0; i < max_dnp; i += sdnp[i].dn_extra_slots + 1) {\n\t\t \n\t\tif (sdnp[i].dn_type != DMU_OT_NONE &&\n\t\t    DMU_OT_IS_ENCRYPTED(sdnp[i].dn_bonustype) &&\n\t\t    sdnp[i].dn_bonuslen != 0) {\n\t\t\tnr_iovecs++;\n\t\t}\n\t}\n\n\tnr_src += nr_iovecs;\n\tnr_dst += nr_iovecs;\n\n\tif (nr_src != 0) {\n\t\tsrc_iovecs = kmem_alloc(nr_src * sizeof (iovec_t), KM_SLEEP);\n\t\tif (src_iovecs == NULL) {\n\t\t\tret = SET_ERROR(ENOMEM);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (nr_dst != 0) {\n\t\tdst_iovecs = kmem_alloc(nr_dst * sizeof (iovec_t), KM_SLEEP);\n\t\tif (dst_iovecs == NULL) {\n\t\t\tret = SET_ERROR(ENOMEM);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tnr_iovecs = 0;\n\n\t \n\tfor (i = 0; i < max_dnp; i += sdnp[i].dn_extra_slots + 1) {\n\t\tdnp = &sdnp[i];\n\n\t\t \n\t\tmemcpy(&ddnp[i], dnp,\n\t\t    (uint8_t *)DN_BONUS(dnp) - (uint8_t *)dnp);\n\n\t\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\t\tmemcpy(DN_SPILL_BLKPTR(&ddnp[i]), DN_SPILL_BLKPTR(dnp),\n\t\t\t    sizeof (blkptr_t));\n\t\t}\n\n\t\t \n\t\tcrypt_len = offsetof(dnode_phys_t, dn_blkptr);\n\t\tmemcpy(aadp, dnp, crypt_len);\n\t\tadnp = (dnode_phys_t *)aadp;\n\t\tadnp->dn_flags &= DNODE_CRYPT_PORTABLE_FLAGS_MASK;\n\t\tadnp->dn_used = 0;\n\t\taadp += crypt_len;\n\t\taad_len += crypt_len;\n\n\t\tfor (j = 0; j < dnp->dn_nblkptr; j++) {\n\t\t\tzio_crypt_bp_do_aad_updates(&aadp, &aad_len,\n\t\t\t    version, byteswap, &dnp->dn_blkptr[j]);\n\t\t}\n\n\t\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\t\tzio_crypt_bp_do_aad_updates(&aadp, &aad_len,\n\t\t\t    version, byteswap, DN_SPILL_BLKPTR(dnp));\n\t\t}\n\n\t\t \n\t\tcrypt_len = DN_MAX_BONUS_LEN(dnp);\n\t\tif (dnp->dn_type != DMU_OT_NONE &&\n\t\t    DMU_OT_IS_ENCRYPTED(dnp->dn_bonustype) &&\n\t\t    dnp->dn_bonuslen != 0) {\n\t\t\tASSERT3U(nr_iovecs, <, nr_src);\n\t\t\tASSERT3U(nr_iovecs, <, nr_dst);\n\t\t\tASSERT3P(src_iovecs, !=, NULL);\n\t\t\tASSERT3P(dst_iovecs, !=, NULL);\n\t\t\tsrc_iovecs[nr_iovecs].iov_base = DN_BONUS(dnp);\n\t\t\tsrc_iovecs[nr_iovecs].iov_len = crypt_len;\n\t\t\tdst_iovecs[nr_iovecs].iov_base = DN_BONUS(&ddnp[i]);\n\t\t\tdst_iovecs[nr_iovecs].iov_len = crypt_len;\n\n\t\t\tnr_iovecs++;\n\t\t\ttotal_len += crypt_len;\n\t\t} else {\n\t\t\tmemcpy(DN_BONUS(&ddnp[i]), DN_BONUS(dnp), crypt_len);\n\t\t\tmemcpy(aadp, DN_BONUS(dnp), crypt_len);\n\t\t\taadp += crypt_len;\n\t\t\taad_len += crypt_len;\n\t\t}\n\t}\n\n\t*no_crypt = (nr_iovecs == 0);\n\t*enc_len = total_len;\n\t*authbuf = aadbuf;\n\t*auth_len = aad_len;\n\n\tif (encrypt) {\n\t\tpuio->uio_iov = src_iovecs;\n\t\tpuio->uio_iovcnt = nr_src;\n\t\tcuio->uio_iov = dst_iovecs;\n\t\tcuio->uio_iovcnt = nr_dst;\n\t} else {\n\t\tpuio->uio_iov = dst_iovecs;\n\t\tpuio->uio_iovcnt = nr_dst;\n\t\tcuio->uio_iov = src_iovecs;\n\t\tcuio->uio_iovcnt = nr_src;\n\t}\n\n\treturn (0);\n\nerror:\n\tzio_buf_free(aadbuf, datalen);\n\tif (src_iovecs != NULL)\n\t\tkmem_free(src_iovecs, nr_src * sizeof (iovec_t));\n\tif (dst_iovecs != NULL)\n\t\tkmem_free(dst_iovecs, nr_dst * sizeof (iovec_t));\n\n\t*enc_len = 0;\n\t*authbuf = NULL;\n\t*auth_len = 0;\n\t*no_crypt = B_FALSE;\n\tpuio->uio_iov = NULL;\n\tpuio->uio_iovcnt = 0;\n\tcuio->uio_iov = NULL;\n\tcuio->uio_iovcnt = 0;\n\treturn (ret);\n}\n\nstatic int\nzio_crypt_init_uios_normal(boolean_t encrypt, uint8_t *plainbuf,\n    uint8_t *cipherbuf, uint_t datalen, zfs_uio_t *puio, zfs_uio_t *cuio,\n    uint_t *enc_len)\n{\n\t(void) encrypt;\n\tint ret;\n\tuint_t nr_plain = 1, nr_cipher = 2;\n\tiovec_t *plain_iovecs = NULL, *cipher_iovecs = NULL;\n\n\t \n\tplain_iovecs = kmem_alloc(nr_plain * sizeof (iovec_t),\n\t    KM_SLEEP);\n\tif (!plain_iovecs) {\n\t\tret = SET_ERROR(ENOMEM);\n\t\tgoto error;\n\t}\n\n\tcipher_iovecs = kmem_alloc(nr_cipher * sizeof (iovec_t),\n\t    KM_SLEEP);\n\tif (!cipher_iovecs) {\n\t\tret = SET_ERROR(ENOMEM);\n\t\tgoto error;\n\t}\n\n\tplain_iovecs[0].iov_base = plainbuf;\n\tplain_iovecs[0].iov_len = datalen;\n\tcipher_iovecs[0].iov_base = cipherbuf;\n\tcipher_iovecs[0].iov_len = datalen;\n\n\t*enc_len = datalen;\n\tpuio->uio_iov = plain_iovecs;\n\tpuio->uio_iovcnt = nr_plain;\n\tcuio->uio_iov = cipher_iovecs;\n\tcuio->uio_iovcnt = nr_cipher;\n\n\treturn (0);\n\nerror:\n\tif (plain_iovecs != NULL)\n\t\tkmem_free(plain_iovecs, nr_plain * sizeof (iovec_t));\n\tif (cipher_iovecs != NULL)\n\t\tkmem_free(cipher_iovecs, nr_cipher * sizeof (iovec_t));\n\n\t*enc_len = 0;\n\tpuio->uio_iov = NULL;\n\tpuio->uio_iovcnt = 0;\n\tcuio->uio_iov = NULL;\n\tcuio->uio_iovcnt = 0;\n\treturn (ret);\n}\n\n \nstatic int\nzio_crypt_init_uios(boolean_t encrypt, uint64_t version, dmu_object_type_t ot,\n    uint8_t *plainbuf, uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap,\n    uint8_t *mac, zfs_uio_t *puio, zfs_uio_t *cuio, uint_t *enc_len,\n    uint8_t **authbuf, uint_t *auth_len, boolean_t *no_crypt)\n{\n\tint ret;\n\tiovec_t *mac_iov;\n\n\tASSERT(DMU_OT_IS_ENCRYPTED(ot) || ot == DMU_OT_NONE);\n\n\t \n\tswitch (ot) {\n\tcase DMU_OT_INTENT_LOG:\n\t\tret = zio_crypt_init_uios_zil(encrypt, plainbuf, cipherbuf,\n\t\t    datalen, byteswap, puio, cuio, enc_len, authbuf, auth_len,\n\t\t    no_crypt);\n\t\tbreak;\n\tcase DMU_OT_DNODE:\n\t\tret = zio_crypt_init_uios_dnode(encrypt, version, plainbuf,\n\t\t    cipherbuf, datalen, byteswap, puio, cuio, enc_len, authbuf,\n\t\t    auth_len, no_crypt);\n\t\tbreak;\n\tdefault:\n\t\tret = zio_crypt_init_uios_normal(encrypt, plainbuf, cipherbuf,\n\t\t    datalen, puio, cuio, enc_len);\n\t\t*authbuf = NULL;\n\t\t*auth_len = 0;\n\t\t*no_crypt = B_FALSE;\n\t\tbreak;\n\t}\n\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tpuio->uio_segflg = UIO_SYSSPACE;\n\tcuio->uio_segflg = UIO_SYSSPACE;\n\n\tmac_iov = ((iovec_t *)&cuio->uio_iov[cuio->uio_iovcnt - 1]);\n\tmac_iov->iov_base = mac;\n\tmac_iov->iov_len = ZIO_DATA_MAC_LEN;\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\n \nint\nzio_do_crypt_data(boolean_t encrypt, zio_crypt_key_t *key,\n    dmu_object_type_t ot, boolean_t byteswap, uint8_t *salt, uint8_t *iv,\n    uint8_t *mac, uint_t datalen, uint8_t *plainbuf, uint8_t *cipherbuf,\n    boolean_t *no_crypt)\n{\n\tint ret;\n\tboolean_t locked = B_FALSE;\n\tuint64_t crypt = key->zk_crypt;\n\tuint_t keydata_len = zio_crypt_table[crypt].ci_keylen;\n\tuint_t enc_len, auth_len;\n\tzfs_uio_t puio, cuio;\n\tuint8_t enc_keydata[MASTER_KEY_MAX_LEN];\n\tcrypto_key_t tmp_ckey, *ckey = NULL;\n\tcrypto_ctx_template_t tmpl;\n\tuint8_t *authbuf = NULL;\n\n\tmemset(&puio, 0, sizeof (puio));\n\tmemset(&cuio, 0, sizeof (cuio));\n\n\t \n\trw_enter(&key->zk_salt_lock, RW_READER);\n\tlocked = B_TRUE;\n\n\tif (memcmp(salt, key->zk_salt, ZIO_DATA_SALT_LEN) == 0) {\n\t\tckey = &key->zk_current_key;\n\t\ttmpl = key->zk_current_tmpl;\n\t} else {\n\t\trw_exit(&key->zk_salt_lock);\n\t\tlocked = B_FALSE;\n\n\t\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t\t    salt, ZIO_DATA_SALT_LEN, enc_keydata, keydata_len);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\ttmp_ckey.ck_data = enc_keydata;\n\t\ttmp_ckey.ck_length = CRYPTO_BYTES2BITS(keydata_len);\n\n\t\tckey = &tmp_ckey;\n\t\ttmpl = NULL;\n\t}\n\n\t \n\tif (qat_crypt_use_accel(datalen) &&\n\t    ot != DMU_OT_INTENT_LOG && ot != DMU_OT_DNODE) {\n\t\tuint8_t *srcbuf, *dstbuf;\n\n\t\tif (encrypt) {\n\t\t\tsrcbuf = plainbuf;\n\t\t\tdstbuf = cipherbuf;\n\t\t} else {\n\t\t\tsrcbuf = cipherbuf;\n\t\t\tdstbuf = plainbuf;\n\t\t}\n\n\t\tret = qat_crypt((encrypt) ? QAT_ENCRYPT : QAT_DECRYPT, srcbuf,\n\t\t    dstbuf, NULL, 0, iv, mac, ckey, key->zk_crypt, datalen);\n\t\tif (ret == CPA_STATUS_SUCCESS) {\n\t\t\tif (locked) {\n\t\t\t\trw_exit(&key->zk_salt_lock);\n\t\t\t\tlocked = B_FALSE;\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t\t \n\t}\n\n\t \n\tret = zio_crypt_init_uios(encrypt, key->zk_version, ot, plainbuf,\n\t    cipherbuf, datalen, byteswap, mac, &puio, &cuio, &enc_len,\n\t    &authbuf, &auth_len, no_crypt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = zio_do_crypt_uio(encrypt, key->zk_crypt, ckey, tmpl, iv, enc_len,\n\t    &puio, &cuio, authbuf, auth_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tif (locked) {\n\t\trw_exit(&key->zk_salt_lock);\n\t}\n\n\tif (authbuf != NULL)\n\t\tzio_buf_free(authbuf, datalen);\n\tif (ckey == &tmp_ckey)\n\t\tmemset(enc_keydata, 0, keydata_len);\n\tzio_crypt_destroy_uio(&puio);\n\tzio_crypt_destroy_uio(&cuio);\n\n\treturn (0);\n\nerror:\n\tif (locked)\n\t\trw_exit(&key->zk_salt_lock);\n\tif (authbuf != NULL)\n\t\tzio_buf_free(authbuf, datalen);\n\tif (ckey == &tmp_ckey)\n\t\tmemset(enc_keydata, 0, keydata_len);\n\tzio_crypt_destroy_uio(&puio);\n\tzio_crypt_destroy_uio(&cuio);\n\n\treturn (ret);\n}\n\n \nint\nzio_do_crypt_abd(boolean_t encrypt, zio_crypt_key_t *key, dmu_object_type_t ot,\n    boolean_t byteswap, uint8_t *salt, uint8_t *iv, uint8_t *mac,\n    uint_t datalen, abd_t *pabd, abd_t *cabd, boolean_t *no_crypt)\n{\n\tint ret;\n\tvoid *ptmp, *ctmp;\n\n\tif (encrypt) {\n\t\tptmp = abd_borrow_buf_copy(pabd, datalen);\n\t\tctmp = abd_borrow_buf(cabd, datalen);\n\t} else {\n\t\tptmp = abd_borrow_buf(pabd, datalen);\n\t\tctmp = abd_borrow_buf_copy(cabd, datalen);\n\t}\n\n\tret = zio_do_crypt_data(encrypt, key, ot, byteswap, salt, iv, mac,\n\t    datalen, ptmp, ctmp, no_crypt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tif (encrypt) {\n\t\tabd_return_buf(pabd, ptmp, datalen);\n\t\tabd_return_buf_copy(cabd, ctmp, datalen);\n\t} else {\n\t\tabd_return_buf_copy(pabd, ptmp, datalen);\n\t\tabd_return_buf(cabd, ctmp, datalen);\n\t}\n\n\treturn (0);\n\nerror:\n\tif (encrypt) {\n\t\tabd_return_buf(pabd, ptmp, datalen);\n\t\tabd_return_buf_copy(cabd, ctmp, datalen);\n\t} else {\n\t\tabd_return_buf_copy(pabd, ptmp, datalen);\n\t\tabd_return_buf(cabd, ctmp, datalen);\n\t}\n\n\treturn (ret);\n}\n\n#if defined(_KERNEL)\n \nmodule_param(zfs_key_max_salt_uses, ulong, 0644);\nMODULE_PARM_DESC(zfs_key_max_salt_uses, \"Max number of times a salt value \"\n\t\"can be used for generating encryption keys before it is rotated\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}