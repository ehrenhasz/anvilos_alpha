{
  "module_name": "zfs_dir.c",
  "hash_id": "ecd9f9813ea869c7fc3aa8b49184c8d74a279ec53abbbfde5a5903f2e60af460",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/zfs/zfs_dir.c",
  "human_readable_source": " \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/sysmacros.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/uio.h>\n#include <sys/pathname.h>\n#include <sys/cmn_err.h>\n#include <sys/errno.h>\n#include <sys/stat.h>\n#include <sys/sunddi.h>\n#include <sys/random.h>\n#include <sys/policy.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_vnops.h>\n#include <sys/fs/zfs.h>\n#include <sys/zap.h>\n#include <sys/dmu.h>\n#include <sys/atomic.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_fuid.h>\n#include <sys/sa.h>\n#include <sys/zfs_sa.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n\n \nstatic int\nzfs_match_find(zfsvfs_t *zfsvfs, znode_t *dzp, const char *name,\n    matchtype_t mt, boolean_t update, int *deflags, pathname_t *rpnp,\n    uint64_t *zoid)\n{\n\tboolean_t conflict = B_FALSE;\n\tint error;\n\n\tif (zfsvfs->z_norm) {\n\t\tsize_t bufsz = 0;\n\t\tchar *buf = NULL;\n\n\t\tif (rpnp) {\n\t\t\tbuf = rpnp->pn_buf;\n\t\t\tbufsz = rpnp->pn_bufsize;\n\t\t}\n\n\t\t \n\t\terror = zap_lookup_norm(zfsvfs->z_os, dzp->z_id, name, 8, 1,\n\t\t    zoid, mt, buf, bufsz, &conflict);\n\t} else {\n\t\terror = zap_lookup(zfsvfs->z_os, dzp->z_id, name, 8, 1, zoid);\n\t}\n\n\t \n\tif (error == EOVERFLOW)\n\t\terror = 0;\n\n\tif (zfsvfs->z_norm && !error && deflags)\n\t\t*deflags = conflict ? ED_CASE_CONFLICT : 0;\n\n\t*zoid = ZFS_DIRENT_OBJ(*zoid);\n\n\treturn (error);\n}\n\n \nint\nzfs_dirent_lock(zfs_dirlock_t **dlpp, znode_t *dzp, char *name,\n    znode_t **zpp, int flag, int *direntflags, pathname_t *realpnp)\n{\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzfs_dirlock_t\t*dl;\n\tboolean_t\tupdate;\n\tmatchtype_t\tmt = 0;\n\tuint64_t\tzoid;\n\tint\t\terror = 0;\n\tint\t\tcmpflags;\n\n\t*zpp = NULL;\n\t*dlpp = NULL;\n\n\t \n\tif ((name[0] == '.' &&\n\t    (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'))) ||\n\t    (zfs_has_ctldir(dzp) && strcmp(name, ZFS_CTLDIR_NAME) == 0))\n\t\treturn (SET_ERROR(EEXIST));\n\n\t \n\n\t \n\tif (zfsvfs->z_norm != 0) {\n\t\tmt = MT_NORMALIZE;\n\n\t\t \n\t\tif ((zfsvfs->z_case == ZFS_CASE_INSENSITIVE &&\n\t\t    (flag & ZCIEXACT)) ||\n\t\t    (zfsvfs->z_case == ZFS_CASE_MIXED && !(flag & ZCILOOK))) {\n\t\t\tmt |= MT_MATCH_CASE;\n\t\t}\n\t}\n\n\t \n\tupdate = !zfsvfs->z_norm ||\n\t    (zfsvfs->z_case == ZFS_CASE_MIXED &&\n\t    !(zfsvfs->z_norm & ~U8_TEXTPREP_TOUPPER) && !(flag & ZCILOOK));\n\n\t \n\tif (flag & ZRENAMING)\n\t\tcmpflags = 0;\n\telse\n\t\tcmpflags = zfsvfs->z_norm;\n\n\t \n\tASSERT(!(flag & ZSHARED) || !(flag & ZHAVELOCK));\n\tif (!(flag & ZHAVELOCK))\n\t\trw_enter(&dzp->z_name_lock, RW_READER);\n\n\tmutex_enter(&dzp->z_lock);\n\tfor (;;) {\n\t\tif (dzp->z_unlinked && !(flag & ZXATTR)) {\n\t\t\tmutex_exit(&dzp->z_lock);\n\t\t\tif (!(flag & ZHAVELOCK))\n\t\t\t\trw_exit(&dzp->z_name_lock);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\t\tfor (dl = dzp->z_dirlocks; dl != NULL; dl = dl->dl_next) {\n\t\t\tif ((u8_strcmp(name, dl->dl_name, 0, cmpflags,\n\t\t\t    U8_UNICODE_LATEST, &error) == 0) || error != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (error != 0) {\n\t\t\tmutex_exit(&dzp->z_lock);\n\t\t\tif (!(flag & ZHAVELOCK))\n\t\t\t\trw_exit(&dzp->z_name_lock);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\t\tif (dl == NULL)\t{\n\t\t\t \n\t\t\tdl = kmem_alloc(sizeof (zfs_dirlock_t), KM_SLEEP);\n\t\t\tcv_init(&dl->dl_cv, NULL, CV_DEFAULT, NULL);\n\t\t\tdl->dl_name = name;\n\t\t\tdl->dl_sharecnt = 0;\n\t\t\tdl->dl_namelock = 0;\n\t\t\tdl->dl_namesize = 0;\n\t\t\tdl->dl_dzp = dzp;\n\t\t\tdl->dl_next = dzp->z_dirlocks;\n\t\t\tdzp->z_dirlocks = dl;\n\t\t\tbreak;\n\t\t}\n\t\tif ((flag & ZSHARED) && dl->dl_sharecnt != 0)\n\t\t\tbreak;\n\t\tcv_wait(&dl->dl_cv, &dzp->z_lock);\n\t}\n\n\t \n\tif (flag & ZHAVELOCK)\n\t\tdl->dl_namelock = 1;\n\n\tif ((flag & ZSHARED) && ++dl->dl_sharecnt > 1 && dl->dl_namesize == 0) {\n\t\t \n\t\tdl->dl_namesize = strlen(dl->dl_name) + 1;\n\t\tname = kmem_alloc(dl->dl_namesize, KM_SLEEP);\n\t\tmemcpy(name, dl->dl_name, dl->dl_namesize);\n\t\tdl->dl_name = name;\n\t}\n\n\tmutex_exit(&dzp->z_lock);\n\n\t \n\tif (flag & ZXATTR) {\n\t\terror = sa_lookup(dzp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs), &zoid,\n\t\t    sizeof (zoid));\n\t\tif (error == 0)\n\t\t\terror = (zoid == 0 ? SET_ERROR(ENOENT) : 0);\n\t} else {\n\t\terror = zfs_match_find(zfsvfs, dzp, name, mt,\n\t\t    update, direntflags, realpnp, &zoid);\n\t}\n\tif (error) {\n\t\tif (error != ENOENT || (flag & ZEXISTS)) {\n\t\t\tzfs_dirent_unlock(dl);\n\t\t\treturn (error);\n\t\t}\n\t} else {\n\t\tif (flag & ZNEW) {\n\t\t\tzfs_dirent_unlock(dl);\n\t\t\treturn (SET_ERROR(EEXIST));\n\t\t}\n\t\terror = zfs_zget(zfsvfs, zoid, zpp);\n\t\tif (error) {\n\t\t\tzfs_dirent_unlock(dl);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t*dlpp = dl;\n\n\treturn (0);\n}\n\n \nvoid\nzfs_dirent_unlock(zfs_dirlock_t *dl)\n{\n\tznode_t *dzp = dl->dl_dzp;\n\tzfs_dirlock_t **prev_dl, *cur_dl;\n\n\tmutex_enter(&dzp->z_lock);\n\n\tif (!dl->dl_namelock)\n\t\trw_exit(&dzp->z_name_lock);\n\n\tif (dl->dl_sharecnt > 1) {\n\t\tdl->dl_sharecnt--;\n\t\tmutex_exit(&dzp->z_lock);\n\t\treturn;\n\t}\n\tprev_dl = &dzp->z_dirlocks;\n\twhile ((cur_dl = *prev_dl) != dl)\n\t\tprev_dl = &cur_dl->dl_next;\n\t*prev_dl = dl->dl_next;\n\tcv_broadcast(&dl->dl_cv);\n\tmutex_exit(&dzp->z_lock);\n\n\tif (dl->dl_namesize != 0)\n\t\tkmem_free(dl->dl_name, dl->dl_namesize);\n\tcv_destroy(&dl->dl_cv);\n\tkmem_free(dl, sizeof (*dl));\n}\n\n \nint\nzfs_dirlook(znode_t *dzp, char *name, znode_t **zpp, int flags,\n    int *deflg, pathname_t *rpnp)\n{\n\tzfs_dirlock_t *dl;\n\tznode_t *zp;\n\tstruct inode *ip;\n\tint error = 0;\n\tuint64_t parent;\n\n\tif (name[0] == 0 || (name[0] == '.' && name[1] == 0)) {\n\t\t*zpp = dzp;\n\t\tzhold(*zpp);\n\t} else if (name[0] == '.' && name[1] == '.' && name[2] == 0) {\n\t\tzfsvfs_t *zfsvfs = ZTOZSB(dzp);\n\n\t\t \n\t\tif ((error = sa_lookup(dzp->z_sa_hdl,\n\t\t    SA_ZPL_PARENT(zfsvfs), &parent, sizeof (parent))) != 0)\n\t\t\treturn (error);\n\n\t\tif (parent == dzp->z_id && zfsvfs->z_parent != zfsvfs) {\n\t\t\terror = zfsctl_root_lookup(zfsvfs->z_parent->z_ctldir,\n\t\t\t    \"snapshot\", &ip, 0, kcred, NULL, NULL);\n\t\t\t*zpp = ITOZ(ip);\n\t\t\treturn (error);\n\t\t}\n\t\trw_enter(&dzp->z_parent_lock, RW_READER);\n\t\terror = zfs_zget(zfsvfs, parent, &zp);\n\t\tif (error == 0)\n\t\t\t*zpp = zp;\n\t\trw_exit(&dzp->z_parent_lock);\n\t} else if (zfs_has_ctldir(dzp) && strcmp(name, ZFS_CTLDIR_NAME) == 0) {\n\t\tip = zfsctl_root(dzp);\n\t\t*zpp = ITOZ(ip);\n\t} else {\n\t\tint zf;\n\n\t\tzf = ZEXISTS | ZSHARED;\n\t\tif (flags & FIGNORECASE)\n\t\t\tzf |= ZCILOOK;\n\n\t\terror = zfs_dirent_lock(&dl, dzp, name, &zp, zf, deflg, rpnp);\n\t\tif (error == 0) {\n\t\t\t*zpp = zp;\n\t\t\tzfs_dirent_unlock(dl);\n\t\t\tdzp->z_zn_prefetch = B_TRUE;  \n\t\t}\n\t\trpnp = NULL;\n\t}\n\n\tif ((flags & FIGNORECASE) && rpnp && !error)\n\t\t(void) strlcpy(rpnp->pn_buf, name, rpnp->pn_bufsize);\n\n\treturn (error);\n}\n\n \nvoid\nzfs_unlinked_add(znode_t *zp, dmu_tx_t *tx)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\n\tASSERT(zp->z_unlinked);\n\tASSERT(ZTOI(zp)->i_nlink == 0);\n\n\tVERIFY3U(0, ==,\n\t    zap_add_int(zfsvfs->z_os, zfsvfs->z_unlinkedobj, zp->z_id, tx));\n\n\tdataset_kstats_update_nunlinks_kstat(&zfsvfs->z_kstat, 1);\n}\n\n \nstatic void\nzfs_unlinked_drain_task(void *arg)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tzap_cursor_t\tzc;\n\tzap_attribute_t zap;\n\tdmu_object_info_t doi;\n\tznode_t\t\t*zp;\n\tint\t\terror;\n\n\tASSERT3B(zfsvfs->z_draining, ==, B_TRUE);\n\n\t \n\tfor (zap_cursor_init(&zc, zfsvfs->z_os, zfsvfs->z_unlinkedobj);\n\t    zap_cursor_retrieve(&zc, &zap) == 0 && !zfsvfs->z_drain_cancel;\n\t    zap_cursor_advance(&zc)) {\n\n\t\t \n\n\t\terror = dmu_object_info(zfsvfs->z_os,\n\t\t    zap.za_first_integer, &doi);\n\t\tif (error != 0)\n\t\t\tcontinue;\n\n\t\tASSERT((doi.doi_type == DMU_OT_PLAIN_FILE_CONTENTS) ||\n\t\t    (doi.doi_type == DMU_OT_DIRECTORY_CONTENTS));\n\t\t \n\t\terror = zfs_zget(zfsvfs, zap.za_first_integer, &zp);\n\n\t\t \n\t\tif (error != 0)\n\t\t\tcontinue;\n\n\t\tzp->z_unlinked = B_TRUE;\n\n\t\t \n\t\tzrele(zp);\n\t\tASSERT3B(zfsvfs->z_unmounted, ==, B_FALSE);\n\t}\n\tzap_cursor_fini(&zc);\n\n\tzfsvfs->z_draining = B_FALSE;\n\tzfsvfs->z_drain_task = TASKQID_INVALID;\n}\n\n \nvoid\nzfs_unlinked_drain(zfsvfs_t *zfsvfs)\n{\n\tASSERT3B(zfsvfs->z_unmounted, ==, B_FALSE);\n\tASSERT3B(zfsvfs->z_draining, ==, B_FALSE);\n\n\tzfsvfs->z_draining = B_TRUE;\n\tzfsvfs->z_drain_cancel = B_FALSE;\n\n\tzfsvfs->z_drain_task = taskq_dispatch(\n\t    dsl_pool_unlinked_drain_taskq(dmu_objset_pool(zfsvfs->z_os)),\n\t    zfs_unlinked_drain_task, zfsvfs, TQ_SLEEP);\n\tif (zfsvfs->z_drain_task == TASKQID_INVALID) {\n\t\tzfs_dbgmsg(\"async zfs_unlinked_drain dispatch failed\");\n\t\tzfs_unlinked_drain_task(zfsvfs);\n\t}\n}\n\n \nvoid\nzfs_unlinked_drain_stop_wait(zfsvfs_t *zfsvfs)\n{\n\tASSERT3B(zfsvfs->z_unmounted, ==, B_FALSE);\n\n\tif (zfsvfs->z_draining) {\n\t\tzfsvfs->z_drain_cancel = B_TRUE;\n\t\ttaskq_cancel_id(dsl_pool_unlinked_drain_taskq(\n\t\t    dmu_objset_pool(zfsvfs->z_os)), zfsvfs->z_drain_task);\n\t\tzfsvfs->z_drain_task = TASKQID_INVALID;\n\t\tzfsvfs->z_draining = B_FALSE;\n\t}\n}\n\n \nstatic int\nzfs_purgedir(znode_t *dzp)\n{\n\tzap_cursor_t\tzc;\n\tzap_attribute_t\tzap;\n\tznode_t\t\t*xzp;\n\tdmu_tx_t\t*tx;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(dzp);\n\tzfs_dirlock_t\tdl;\n\tint skipped = 0;\n\tint error;\n\n\tfor (zap_cursor_init(&zc, zfsvfs->z_os, dzp->z_id);\n\t    (error = zap_cursor_retrieve(&zc, &zap)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\terror = zfs_zget(zfsvfs,\n\t\t    ZFS_DIRENT_OBJ(zap.za_first_integer), &xzp);\n\t\tif (error) {\n\t\t\tskipped += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tASSERT(S_ISREG(ZTOI(xzp)->i_mode) ||\n\t\t    S_ISLNK(ZTOI(xzp)->i_mode));\n\n\t\ttx = dmu_tx_create(zfsvfs->z_os);\n\t\tdmu_tx_hold_sa(tx, dzp->z_sa_hdl, B_FALSE);\n\t\tdmu_tx_hold_zap(tx, dzp->z_id, FALSE, zap.za_name);\n\t\tdmu_tx_hold_sa(tx, xzp->z_sa_hdl, B_FALSE);\n\t\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\t\t \n\t\tzfs_sa_upgrade_txholds(tx, xzp);\n\t\tdmu_tx_mark_netfree(tx);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tdmu_tx_abort(tx);\n\t\t\tzfs_zrele_async(xzp);\n\t\t\tskipped += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tmemset(&dl, 0, sizeof (dl));\n\t\tdl.dl_dzp = dzp;\n\t\tdl.dl_name = zap.za_name;\n\n\t\terror = zfs_link_destroy(&dl, xzp, tx, 0, NULL);\n\t\tif (error)\n\t\t\tskipped += 1;\n\t\tdmu_tx_commit(tx);\n\n\t\tzfs_zrele_async(xzp);\n\t}\n\tzap_cursor_fini(&zc);\n\tif (error != ENOENT)\n\t\tskipped += 1;\n\treturn (skipped);\n}\n\nvoid\nzfs_rmnode(znode_t *zp)\n{\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zp);\n\tobjset_t\t*os = zfsvfs->z_os;\n\tznode_t\t\t*xzp = NULL;\n\tdmu_tx_t\t*tx;\n\tznode_hold_t\t*zh;\n\tuint64_t\tz_id = zp->z_id;\n\tuint64_t\tacl_obj;\n\tuint64_t\txattr_obj;\n\tuint64_t\tlinks;\n\tint\t\terror;\n\n\tASSERT(ZTOI(zp)->i_nlink == 0);\n\tASSERT(atomic_read(&ZTOI(zp)->i_count) == 0);\n\n\t \n\tif (S_ISDIR(ZTOI(zp)->i_mode) && (zp->z_pflags & ZFS_XATTR)) {\n\t\tif (zfs_purgedir(zp) != 0) {\n\t\t\t \n\t\t\tzh = zfs_znode_hold_enter(zfsvfs, z_id);\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (S_ISREG(ZTOI(zp)->i_mode)) {\n\t\terror = dmu_free_long_range(os, zp->z_id, 0, DMU_OBJECT_END);\n\t\tif (error) {\n\t\t\t \n\t\t\tzh = zfs_znode_hold_enter(zfsvfs, z_id);\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\terror = sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t    &xattr_obj, sizeof (xattr_obj));\n\tif (error == 0 && xattr_obj) {\n\t\terror = zfs_zget(zfsvfs, xattr_obj, &xzp);\n\t\tASSERT(error == 0);\n\t}\n\n\tacl_obj = zfs_external_acl(zp);\n\n\t \n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_free(tx, zp->z_id, 0, DMU_OBJECT_END);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\tif (xzp) {\n\t\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, TRUE, NULL);\n\t\tdmu_tx_hold_sa(tx, xzp->z_sa_hdl, B_FALSE);\n\t}\n\tif (acl_obj)\n\t\tdmu_tx_hold_free(tx, acl_obj, 0, DMU_OBJECT_END);\n\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\t \n\t\tdmu_tx_abort(tx);\n\t\tzh = zfs_znode_hold_enter(zfsvfs, z_id);\n\t\tzfs_znode_dmu_fini(zp);\n\t\tzfs_znode_hold_exit(zfsvfs, zh);\n\t\tgoto out;\n\t}\n\n\tif (xzp) {\n\t\tASSERT(error == 0);\n\t\tmutex_enter(&xzp->z_lock);\n\t\txzp->z_unlinked = B_TRUE;\t \n\t\tclear_nlink(ZTOI(xzp));\t\t \n\t\tlinks = 0;\n\t\tVERIFY(0 == sa_update(xzp->z_sa_hdl, SA_ZPL_LINKS(zfsvfs),\n\t\t    &links, sizeof (links), tx));\n\t\tmutex_exit(&xzp->z_lock);\n\t\tzfs_unlinked_add(xzp, tx);\n\t}\n\n\tmutex_enter(&os->os_dsl_dataset->ds_dir->dd_activity_lock);\n\n\t \n\terror = zap_remove_int(zfsvfs->z_os, zfsvfs->z_unlinkedobj,\n\t    zp->z_id, tx);\n\tVERIFY(error == 0 || error == ENOENT);\n\n\tuint64_t count;\n\tif (zap_count(os, zfsvfs->z_unlinkedobj, &count) == 0 && count == 0) {\n\t\tcv_broadcast(&os->os_dsl_dataset->ds_dir->dd_activity_cv);\n\t}\n\n\tmutex_exit(&os->os_dsl_dataset->ds_dir->dd_activity_lock);\n\n\tdataset_kstats_update_nunlinked_kstat(&zfsvfs->z_kstat, 1);\n\n\tzfs_znode_delete(zp, tx);\n\n\tdmu_tx_commit(tx);\nout:\n\tif (xzp)\n\t\tzfs_zrele_async(xzp);\n}\n\nstatic uint64_t\nzfs_dirent(znode_t *zp, uint64_t mode)\n{\n\tuint64_t de = zp->z_id;\n\n\tif (ZTOZSB(zp)->z_version >= ZPL_VERSION_DIRENT_TYPE)\n\t\tde |= IFTODT(mode) << 60;\n\treturn (de);\n}\n\n \nint\nzfs_link_create(zfs_dirlock_t *dl, znode_t *zp, dmu_tx_t *tx, int flag)\n{\n\tznode_t *dzp = dl->dl_dzp;\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tuint64_t value;\n\tint zp_is_dir = S_ISDIR(ZTOI(zp)->i_mode);\n\tsa_bulk_attr_t bulk[5];\n\tuint64_t mtime[2], ctime[2];\n\tuint64_t links;\n\tint count = 0;\n\tint error;\n\n\tmutex_enter(&zp->z_lock);\n\n\tif (!(flag & ZRENAMING)) {\n\t\tif (zp->z_unlinked) {\t \n\t\t\tASSERT(!(flag & (ZNEW | ZEXISTS)));\n\t\t\tmutex_exit(&zp->z_lock);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\t\tif (!(flag & ZNEW)) {\n\t\t\t \n\t\t\tinc_nlink(ZTOI(zp));\n\t\t\tlinks = ZTOI(zp)->i_nlink;\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs),\n\t\t\t    NULL, &links, sizeof (links));\n\t\t}\n\t}\n\n\tvalue = zfs_dirent(zp, zp->z_mode);\n\terror = zap_add(ZTOZSB(zp)->z_os, dzp->z_id, dl->dl_name, 8, 1,\n\t    &value, tx);\n\n\t \n\tif (error != 0) {\n\t\tif (!(flag & ZRENAMING) && !(flag & ZNEW))\n\t\t\tdrop_nlink(ZTOI(zp));\n\t\tmutex_exit(&zp->z_lock);\n\t\treturn (error);\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PARENT(zfsvfs), NULL,\n\t    &dzp->z_id, sizeof (dzp->z_id));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\n\tif (!(flag & ZNEW)) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    ctime, sizeof (ctime));\n\t\tzfs_tstamp_update_setup(zp, STATE_CHANGED, mtime,\n\t\t    ctime);\n\t}\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\tASSERT(error == 0);\n\n\tmutex_exit(&zp->z_lock);\n\n\tmutex_enter(&dzp->z_lock);\n\tdzp->z_size++;\n\tif (zp_is_dir)\n\t\tinc_nlink(ZTOI(dzp));\n\tlinks = ZTOI(dzp)->i_nlink;\n\tcount = 0;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &dzp->z_size, sizeof (dzp->z_size));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL,\n\t    &links, sizeof (links));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t    mtime, sizeof (mtime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t    ctime, sizeof (ctime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &dzp->z_pflags, sizeof (dzp->z_pflags));\n\tzfs_tstamp_update_setup(dzp, CONTENT_MODIFIED, mtime, ctime);\n\terror = sa_bulk_update(dzp->z_sa_hdl, bulk, count, tx);\n\tASSERT(error == 0);\n\tmutex_exit(&dzp->z_lock);\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_dropname(zfs_dirlock_t *dl, znode_t *zp, znode_t *dzp, dmu_tx_t *tx,\n    int flag)\n{\n\tint error;\n\n\tif (ZTOZSB(zp)->z_norm) {\n\t\tmatchtype_t mt = MT_NORMALIZE;\n\n\t\tif ((ZTOZSB(zp)->z_case == ZFS_CASE_INSENSITIVE &&\n\t\t    (flag & ZCIEXACT)) ||\n\t\t    (ZTOZSB(zp)->z_case == ZFS_CASE_MIXED &&\n\t\t    !(flag & ZCILOOK))) {\n\t\t\tmt |= MT_MATCH_CASE;\n\t\t}\n\n\t\terror = zap_remove_norm(ZTOZSB(zp)->z_os, dzp->z_id,\n\t\t    dl->dl_name, mt, tx);\n\t} else {\n\t\terror = zap_remove(ZTOZSB(zp)->z_os, dzp->z_id, dl->dl_name,\n\t\t    tx);\n\t}\n\n\treturn (error);\n}\n\nstatic int\nzfs_drop_nlink_locked(znode_t *zp, dmu_tx_t *tx, boolean_t *unlinkedp)\n{\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zp);\n\tint\t\tzp_is_dir = S_ISDIR(ZTOI(zp)->i_mode);\n\tboolean_t\tunlinked = B_FALSE;\n\tsa_bulk_attr_t\tbulk[3];\n\tuint64_t\tmtime[2], ctime[2];\n\tuint64_t\tlinks;\n\tint\t\tcount = 0;\n\tint\t\terror;\n\n\tif (zp_is_dir && !zfs_dirempty(zp))\n\t\treturn (SET_ERROR(ENOTEMPTY));\n\n\tif (ZTOI(zp)->i_nlink <= zp_is_dir) {\n\t\tzfs_panic_recover(\"zfs: link count on %lu is %u, \"\n\t\t    \"should be at least %u\", zp->z_id,\n\t\t    (int)ZTOI(zp)->i_nlink, zp_is_dir + 1);\n\t\tset_nlink(ZTOI(zp), zp_is_dir + 1);\n\t}\n\tdrop_nlink(ZTOI(zp));\n\tif (ZTOI(zp)->i_nlink == zp_is_dir) {\n\t\tzp->z_unlinked = B_TRUE;\n\t\tclear_nlink(ZTOI(zp));\n\t\tunlinked = B_TRUE;\n\t} else {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs),\n\t\t    NULL, &ctime, sizeof (ctime));\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &zp->z_pflags, sizeof (zp->z_pflags));\n\t\tzfs_tstamp_update_setup(zp, STATE_CHANGED, mtime,\n\t\t    ctime);\n\t}\n\tlinks = ZTOI(zp)->i_nlink;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs),\n\t    NULL, &links, sizeof (links));\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\tASSERT3U(error, ==, 0);\n\n\tif (unlinkedp != NULL)\n\t\t*unlinkedp = unlinked;\n\telse if (unlinked)\n\t\tzfs_unlinked_add(zp, tx);\n\n\treturn (0);\n}\n\n \nint\nzfs_drop_nlink(znode_t *zp, dmu_tx_t *tx, boolean_t *unlinkedp)\n{\n\tint error;\n\n\tmutex_enter(&zp->z_lock);\n\terror = zfs_drop_nlink_locked(zp, tx, unlinkedp);\n\tmutex_exit(&zp->z_lock);\n\n\treturn (error);\n}\n\n \nint\nzfs_link_destroy(zfs_dirlock_t *dl, znode_t *zp, dmu_tx_t *tx, int flag,\n    boolean_t *unlinkedp)\n{\n\tznode_t *dzp = dl->dl_dzp;\n\tzfsvfs_t *zfsvfs = ZTOZSB(dzp);\n\tint zp_is_dir = S_ISDIR(ZTOI(zp)->i_mode);\n\tboolean_t unlinked = B_FALSE;\n\tsa_bulk_attr_t bulk[5];\n\tuint64_t mtime[2], ctime[2];\n\tuint64_t links;\n\tint count = 0;\n\tint error;\n\n\tif (!(flag & ZRENAMING)) {\n\t\tmutex_enter(&zp->z_lock);\n\n\t\tif (zp_is_dir && !zfs_dirempty(zp)) {\n\t\t\tmutex_exit(&zp->z_lock);\n\t\t\treturn (SET_ERROR(ENOTEMPTY));\n\t\t}\n\n\t\t \n\t\terror = zfs_dropname(dl, zp, dzp, tx, flag);\n\t\tif (error != 0) {\n\t\t\tmutex_exit(&zp->z_lock);\n\t\t\treturn (error);\n\t\t}\n\n\t\t \n\t\terror = zfs_drop_nlink_locked(zp, tx, &unlinked);\n\t\tASSERT3U(error, ==, 0);\n\t\tmutex_exit(&zp->z_lock);\n\t} else {\n\t\terror = zfs_dropname(dl, zp, dzp, tx, flag);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\tmutex_enter(&dzp->z_lock);\n\tdzp->z_size--;\t\t \n\tif (zp_is_dir)\n\t\tdrop_nlink(ZTOI(dzp));\t \n\tlinks = ZTOI(dzp)->i_nlink;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs),\n\t    NULL, &links, sizeof (links));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs),\n\t    NULL, &dzp->z_size, sizeof (dzp->z_size));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs),\n\t    NULL, ctime, sizeof (ctime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs),\n\t    NULL, mtime, sizeof (mtime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t    NULL, &dzp->z_pflags, sizeof (dzp->z_pflags));\n\tzfs_tstamp_update_setup(dzp, CONTENT_MODIFIED, mtime, ctime);\n\terror = sa_bulk_update(dzp->z_sa_hdl, bulk, count, tx);\n\tASSERT(error == 0);\n\tmutex_exit(&dzp->z_lock);\n\n\tif (unlinkedp != NULL)\n\t\t*unlinkedp = unlinked;\n\telse if (unlinked)\n\t\tzfs_unlinked_add(zp, tx);\n\n\treturn (0);\n}\n\n \nboolean_t\nzfs_dirempty(znode_t *dzp)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(dzp);\n\tuint64_t count;\n\tint error;\n\n\tif (dzp->z_dirlocks != NULL)\n\t\treturn (B_FALSE);\n\n\terror = zap_count(zfsvfs->z_os, dzp->z_id, &count);\n\tif (error != 0 || count != 0)\n\t\treturn (B_FALSE);\n\n\treturn (B_TRUE);\n}\n\nint\nzfs_make_xattrdir(znode_t *zp, vattr_t *vap, znode_t **xzpp, cred_t *cr)\n{\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tznode_t *xzp;\n\tdmu_tx_t *tx;\n\tint error;\n\tzfs_acl_ids_t acl_ids;\n\tboolean_t fuid_dirtied;\n#ifdef ZFS_DEBUG\n\tuint64_t parent;\n#endif\n\n\t*xzpp = NULL;\n\n\tif ((error = zfs_acl_ids_create(zp, IS_XATTR, vap, cr, NULL,\n\t    &acl_ids, zfs_init_idmap)) != 0)\n\t\treturn (error);\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, zp->z_projid)) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, FALSE, NULL);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\treturn (error);\n\t}\n\tzfs_mknode(zp, vap, tx, cr, IS_XATTR, &xzp, &acl_ids);\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n#ifdef ZFS_DEBUG\n\terror = sa_lookup(xzp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs),\n\t    &parent, sizeof (parent));\n\tASSERT(error == 0 && parent == zp->z_id);\n#endif\n\n\tVERIFY(0 == sa_update(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs), &xzp->z_id,\n\t    sizeof (xzp->z_id), tx));\n\n\tif (!zp->z_unlinked)\n\t\tzfs_log_create(zfsvfs->z_log, tx, TX_MKXATTR, zp, xzp, \"\", NULL,\n\t\t    acl_ids.z_fuidp, vap);\n\n\tzfs_acl_ids_free(&acl_ids);\n\tdmu_tx_commit(tx);\n\n\t*xzpp = xzp;\n\n\treturn (0);\n}\n\n \nint\nzfs_get_xattrdir(znode_t *zp, znode_t **xzpp, cred_t *cr, int flags)\n{\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zp);\n\tznode_t\t\t*xzp;\n\tzfs_dirlock_t\t*dl;\n\tvattr_t\t\tva;\n\tint\t\terror;\ntop:\n\terror = zfs_dirent_lock(&dl, zp, \"\", &xzp, ZXATTR, NULL, NULL);\n\tif (error)\n\t\treturn (error);\n\n\tif (xzp != NULL) {\n\t\t*xzpp = xzp;\n\t\tzfs_dirent_unlock(dl);\n\t\treturn (0);\n\t}\n\n\tif (!(flags & CREATE_XATTR_DIR)) {\n\t\tzfs_dirent_unlock(dl);\n\t\treturn (SET_ERROR(ENOENT));\n\t}\n\n\tif (zfs_is_readonly(zfsvfs)) {\n\t\tzfs_dirent_unlock(dl);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\tva.va_mask = ATTR_MODE | ATTR_UID | ATTR_GID;\n\tva.va_mode = S_IFDIR | S_ISVTX | 0777;\n\tzfs_fuid_map_ids(zp, cr, &va.va_uid, &va.va_gid);\n\n\tva.va_dentry = NULL;\n\terror = zfs_make_xattrdir(zp, &va, xzpp, cr);\n\tzfs_dirent_unlock(dl);\n\n\tif (error == ERESTART) {\n\t\t \n\t\tgoto top;\n\t}\n\n\treturn (error);\n}\n\n \nint\nzfs_sticky_remove_access(znode_t *zdp, znode_t *zp, cred_t *cr)\n{\n\tuid_t\t\tuid;\n\tuid_t\t\tdowner;\n\tuid_t\t\tfowner;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zdp);\n\n\tif (zfsvfs->z_replay)\n\t\treturn (0);\n\n\tif ((zdp->z_mode & S_ISVTX) == 0)\n\t\treturn (0);\n\n\tdowner = zfs_fuid_map_id(zfsvfs, KUID_TO_SUID(ZTOI(zdp)->i_uid),\n\t    cr, ZFS_OWNER);\n\tfowner = zfs_fuid_map_id(zfsvfs, KUID_TO_SUID(ZTOI(zp)->i_uid),\n\t    cr, ZFS_OWNER);\n\n\tif ((uid = crgetuid(cr)) == downer || uid == fowner ||\n\t    zfs_zaccess(zp, ACE_WRITE_DATA, 0, B_FALSE, cr,\n\t    zfs_init_idmap) == 0)\n\t\treturn (0);\n\telse\n\t\treturn (secpolicy_vnode_remove(cr));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}