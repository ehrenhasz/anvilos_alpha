{
  "module_name": "spl-kstat.c",
  "hash_id": "0738578c45442dd8bec3f0f5d936ef40ee67eea9255fc668910c07ba2bc97f72",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-kstat.c",
  "human_readable_source": " \n\n#include <linux/seq_file.h>\n#include <sys/kstat.h>\n#include <sys/vmem.h>\n#include <sys/cmn_err.h>\n#include <sys/sysmacros.h>\n\nstatic kmutex_t kstat_module_lock;\nstatic struct list_head kstat_module_list;\nstatic kid_t kstat_id;\n\nstatic int\nkstat_resize_raw(kstat_t *ksp)\n{\n\tif (ksp->ks_raw_bufsize == KSTAT_RAW_MAX)\n\t\treturn (ENOMEM);\n\n\tvmem_free(ksp->ks_raw_buf, ksp->ks_raw_bufsize);\n\tksp->ks_raw_bufsize = MIN(ksp->ks_raw_bufsize * 2, KSTAT_RAW_MAX);\n\tksp->ks_raw_buf = vmem_alloc(ksp->ks_raw_bufsize, KM_SLEEP);\n\n\treturn (0);\n}\n\nstatic int\nkstat_seq_show_headers(struct seq_file *f)\n{\n\tkstat_t *ksp = (kstat_t *)f->private;\n\tint rc = 0;\n\n\tASSERT(ksp->ks_magic == KS_MAGIC);\n\n\tseq_printf(f, \"%d %d 0x%02x %d %d %lld %lld\\n\",\n\t    ksp->ks_kid, ksp->ks_type, ksp->ks_flags,\n\t    ksp->ks_ndata, (int)ksp->ks_data_size,\n\t    ksp->ks_crtime, ksp->ks_snaptime);\n\n\tswitch (ksp->ks_type) {\n\t\tcase KSTAT_TYPE_RAW:\nrestart:\n\t\t\tif (ksp->ks_raw_ops.headers) {\n\t\t\t\trc = ksp->ks_raw_ops.headers(\n\t\t\t\t    ksp->ks_raw_buf, ksp->ks_raw_bufsize);\n\t\t\t\tif (rc == ENOMEM && !kstat_resize_raw(ksp))\n\t\t\t\t\tgoto restart;\n\t\t\t\tif (!rc)\n\t\t\t\t\tseq_puts(f, ksp->ks_raw_buf);\n\t\t\t} else {\n\t\t\t\tseq_printf(f, \"raw data\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_NAMED:\n\t\t\tseq_printf(f, \"%-31s %-4s %s\\n\",\n\t\t\t    \"name\", \"type\", \"data\");\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_INTR:\n\t\t\tseq_printf(f, \"%-8s %-8s %-8s %-8s %-8s\\n\",\n\t\t\t    \"hard\", \"soft\", \"watchdog\",\n\t\t\t    \"spurious\", \"multsvc\");\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_IO:\n\t\t\tseq_printf(f,\n\t\t\t    \"%-8s %-8s %-8s %-8s %-8s %-8s \"\n\t\t\t    \"%-8s %-8s %-8s %-8s %-8s %-8s\\n\",\n\t\t\t    \"nread\", \"nwritten\", \"reads\", \"writes\",\n\t\t\t    \"wtime\", \"wlentime\", \"wupdate\",\n\t\t\t    \"rtime\", \"rlentime\", \"rupdate\",\n\t\t\t    \"wcnt\", \"rcnt\");\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_TIMER:\n\t\t\tseq_printf(f,\n\t\t\t    \"%-31s %-8s \"\n\t\t\t    \"%-8s %-8s %-8s %-8s %-8s\\n\",\n\t\t\t    \"name\", \"events\", \"elapsed\",\n\t\t\t    \"min\", \"max\", \"start\", \"stop\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPANIC(\"Undefined kstat type %d\\n\", ksp->ks_type);\n\t}\n\n\treturn (-rc);\n}\n\nstatic int\nkstat_seq_show_raw(struct seq_file *f, unsigned char *p, int l)\n{\n\tint i, j;\n\n\tfor (i = 0; ; i++) {\n\t\tseq_printf(f, \"%03x:\", i);\n\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (i * 16 + j >= l) {\n\t\t\t\tseq_printf(f, \"\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tseq_printf(f, \" %02x\", (unsigned char)p[i * 16 + j]);\n\t\t}\n\t\tseq_printf(f, \"\\n\");\n\t}\nout:\n\treturn (0);\n}\n\nstatic int\nkstat_seq_show_named(struct seq_file *f, kstat_named_t *knp)\n{\n\tseq_printf(f, \"%-31s %-4d \", knp->name, knp->data_type);\n\n\tswitch (knp->data_type) {\n\t\tcase KSTAT_DATA_CHAR:\n\t\t\tknp->value.c[15] = '\\0';  \n\t\t\tseq_printf(f, \"%-16s\", knp->value.c);\n\t\t\tbreak;\n\t\t \n\t\tcase KSTAT_DATA_INT32:\n\t\t\tseq_printf(f, \"%d\", knp->value.i32);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_UINT32:\n\t\t\tseq_printf(f, \"%u\", knp->value.ui32);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_INT64:\n\t\t\tseq_printf(f, \"%lld\", (signed long long)knp->value.i64);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_UINT64:\n\t\t\tseq_printf(f, \"%llu\",\n\t\t\t    (unsigned long long)knp->value.ui64);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_LONG:\n\t\t\tseq_printf(f, \"%ld\", knp->value.l);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_ULONG:\n\t\t\tseq_printf(f, \"%lu\", knp->value.ul);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_STRING:\n\t\t\tKSTAT_NAMED_STR_PTR(knp)\n\t\t\t\t[KSTAT_NAMED_STR_BUFLEN(knp)-1] = '\\0';\n\t\t\tseq_printf(f, \"%s\", KSTAT_NAMED_STR_PTR(knp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPANIC(\"Undefined kstat data type %d\\n\", knp->data_type);\n\t}\n\n\tseq_printf(f, \"\\n\");\n\n\treturn (0);\n}\n\nstatic int\nkstat_seq_show_intr(struct seq_file *f, kstat_intr_t *kip)\n{\n\tseq_printf(f, \"%-8u %-8u %-8u %-8u %-8u\\n\",\n\t    kip->intrs[KSTAT_INTR_HARD],\n\t    kip->intrs[KSTAT_INTR_SOFT],\n\t    kip->intrs[KSTAT_INTR_WATCHDOG],\n\t    kip->intrs[KSTAT_INTR_SPURIOUS],\n\t    kip->intrs[KSTAT_INTR_MULTSVC]);\n\n\treturn (0);\n}\n\nstatic int\nkstat_seq_show_io(struct seq_file *f, kstat_io_t *kip)\n{\n\t \n\tseq_printf(f,\n\t    \"%-8llu %-8llu %-8u %-8u %-8llu %-8llu \"\n\t    \"%-8llu %-8llu %-8llu %-8llu %-8u %-8u\\n\",\n\t    kip->nread, kip->nwritten,\n\t    kip->reads, kip->writes,\n\t    kip->wtime, kip->wlentime, kip->wlastupdate,\n\t    kip->rtime, kip->rlentime, kip->rlastupdate,\n\t    kip->wcnt,  kip->rcnt);\n\n\treturn (0);\n}\n\nstatic int\nkstat_seq_show_timer(struct seq_file *f, kstat_timer_t *ktp)\n{\n\tseq_printf(f,\n\t    \"%-31s %-8llu %-8llu %-8llu %-8llu %-8llu %-8llu\\n\",\n\t    ktp->name, ktp->num_events, ktp->elapsed_time,\n\t    ktp->min_time, ktp->max_time,\n\t    ktp->start_time, ktp->stop_time);\n\n\treturn (0);\n}\n\nstatic int\nkstat_seq_show(struct seq_file *f, void *p)\n{\n\tkstat_t *ksp = (kstat_t *)f->private;\n\tint rc = 0;\n\n\tASSERT(ksp->ks_magic == KS_MAGIC);\n\n\tswitch (ksp->ks_type) {\n\t\tcase KSTAT_TYPE_RAW:\nrestart:\n\t\t\tif (ksp->ks_raw_ops.data) {\n\t\t\t\trc = ksp->ks_raw_ops.data(\n\t\t\t\t    ksp->ks_raw_buf, ksp->ks_raw_bufsize, p);\n\t\t\t\tif (rc == ENOMEM && !kstat_resize_raw(ksp))\n\t\t\t\t\tgoto restart;\n\t\t\t\tif (!rc)\n\t\t\t\t\tseq_puts(f, ksp->ks_raw_buf);\n\t\t\t} else {\n\t\t\t\tASSERT(ksp->ks_ndata == 1);\n\t\t\t\trc = kstat_seq_show_raw(f, ksp->ks_data,\n\t\t\t\t    ksp->ks_data_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_NAMED:\n\t\t\trc = kstat_seq_show_named(f, (kstat_named_t *)p);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_INTR:\n\t\t\trc = kstat_seq_show_intr(f, (kstat_intr_t *)p);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_IO:\n\t\t\trc = kstat_seq_show_io(f, (kstat_io_t *)p);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_TIMER:\n\t\t\trc = kstat_seq_show_timer(f, (kstat_timer_t *)p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPANIC(\"Undefined kstat type %d\\n\", ksp->ks_type);\n\t}\n\n\treturn (-rc);\n}\n\nstatic int\nkstat_default_update(kstat_t *ksp, int rw)\n{\n\tASSERT(ksp != NULL);\n\n\tif (rw == KSTAT_WRITE)\n\t\treturn (EACCES);\n\n\treturn (0);\n}\n\nstatic void *\nkstat_seq_data_addr(kstat_t *ksp, loff_t n)\n{\n\tvoid *rc = NULL;\n\n\tswitch (ksp->ks_type) {\n\t\tcase KSTAT_TYPE_RAW:\n\t\t\tif (ksp->ks_raw_ops.addr)\n\t\t\t\trc = ksp->ks_raw_ops.addr(ksp, n);\n\t\t\telse\n\t\t\t\trc = ksp->ks_data;\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_NAMED:\n\t\t\trc = ksp->ks_data + n * sizeof (kstat_named_t);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_INTR:\n\t\t\trc = ksp->ks_data + n * sizeof (kstat_intr_t);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_IO:\n\t\t\trc = ksp->ks_data + n * sizeof (kstat_io_t);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_TIMER:\n\t\t\trc = ksp->ks_data + n * sizeof (kstat_timer_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPANIC(\"Undefined kstat type %d\\n\", ksp->ks_type);\n\t}\n\n\treturn (rc);\n}\n\nstatic void *\nkstat_seq_start(struct seq_file *f, loff_t *pos)\n{\n\tloff_t n = *pos;\n\tkstat_t *ksp = (kstat_t *)f->private;\n\tASSERT(ksp->ks_magic == KS_MAGIC);\n\n\tmutex_enter(ksp->ks_lock);\n\n\tif (ksp->ks_type == KSTAT_TYPE_RAW) {\n\t\tksp->ks_raw_bufsize = PAGE_SIZE;\n\t\tksp->ks_raw_buf = vmem_alloc(ksp->ks_raw_bufsize, KM_SLEEP);\n\t}\n\n\t \n\t(void) ksp->ks_update(ksp, KSTAT_READ);\n\n\tksp->ks_snaptime = gethrtime();\n\n\tif (!(ksp->ks_flags & KSTAT_FLAG_NO_HEADERS) && !n &&\n\t    kstat_seq_show_headers(f))\n\t\treturn (NULL);\n\n\tif (n >= ksp->ks_ndata)\n\t\treturn (NULL);\n\n\treturn (kstat_seq_data_addr(ksp, n));\n}\n\nstatic void *\nkstat_seq_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\tkstat_t *ksp = (kstat_t *)f->private;\n\tASSERT(ksp->ks_magic == KS_MAGIC);\n\n\t++*pos;\n\tif (*pos >= ksp->ks_ndata)\n\t\treturn (NULL);\n\n\treturn (kstat_seq_data_addr(ksp, *pos));\n}\n\nstatic void\nkstat_seq_stop(struct seq_file *f, void *v)\n{\n\tkstat_t *ksp = (kstat_t *)f->private;\n\tASSERT(ksp->ks_magic == KS_MAGIC);\n\n\tif (ksp->ks_type == KSTAT_TYPE_RAW)\n\t\tvmem_free(ksp->ks_raw_buf, ksp->ks_raw_bufsize);\n\n\tmutex_exit(ksp->ks_lock);\n}\n\nstatic const struct seq_operations kstat_seq_ops = {\n\t.show  = kstat_seq_show,\n\t.start = kstat_seq_start,\n\t.next  = kstat_seq_next,\n\t.stop  = kstat_seq_stop,\n};\n\nstatic kstat_module_t *\nkstat_find_module(char *name)\n{\n\tkstat_module_t *module = NULL;\n\n\tlist_for_each_entry(module, &kstat_module_list, ksm_module_list) {\n\t\tif (strncmp(name, module->ksm_name, KSTAT_STRLEN) == 0)\n\t\t\treturn (module);\n\t}\n\n\treturn (NULL);\n}\n\nstatic kstat_module_t *\nkstat_create_module(char *name)\n{\n\tkstat_module_t *module;\n\tstruct proc_dir_entry *pde;\n\n\tpde = proc_mkdir(name, proc_spl_kstat);\n\tif (pde == NULL)\n\t\treturn (NULL);\n\n\tmodule = kmem_alloc(sizeof (kstat_module_t), KM_SLEEP);\n\tmodule->ksm_proc = pde;\n\tstrlcpy(module->ksm_name, name, KSTAT_STRLEN);\n\tINIT_LIST_HEAD(&module->ksm_kstat_list);\n\tlist_add_tail(&module->ksm_module_list, &kstat_module_list);\n\n\treturn (module);\n\n}\n\nstatic void\nkstat_delete_module(kstat_module_t *module)\n{\n\tASSERT(list_empty(&module->ksm_kstat_list));\n\tremove_proc_entry(module->ksm_name, proc_spl_kstat);\n\tlist_del(&module->ksm_module_list);\n\tkmem_free(module, sizeof (kstat_module_t));\n}\n\nstatic int\nproc_kstat_open(struct inode *inode, struct file *filp)\n{\n\tstruct seq_file *f;\n\tint rc;\n\n\trc = seq_open(filp, &kstat_seq_ops);\n\tif (rc)\n\t\treturn (rc);\n\n\tf = filp->private_data;\n\tf->private = SPL_PDE_DATA(inode);\n\n\treturn (0);\n}\n\nstatic ssize_t\nproc_kstat_write(struct file *filp, const char __user *buf, size_t len,\n    loff_t *ppos)\n{\n\tstruct seq_file *f = filp->private_data;\n\tkstat_t *ksp = f->private;\n\tint rc;\n\n\tASSERT(ksp->ks_magic == KS_MAGIC);\n\n\tmutex_enter(ksp->ks_lock);\n\trc = ksp->ks_update(ksp, KSTAT_WRITE);\n\tmutex_exit(ksp->ks_lock);\n\n\tif (rc)\n\t\treturn (-rc);\n\n\t*ppos += len;\n\treturn (len);\n}\n\nstatic const kstat_proc_op_t proc_kstat_operations = {\n#ifdef HAVE_PROC_OPS_STRUCT\n\t.proc_open\t= proc_kstat_open,\n\t.proc_write\t= proc_kstat_write,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n#else\n\t.open\t\t= proc_kstat_open,\n\t.write\t\t= proc_kstat_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n#endif\n};\n\nvoid\n__kstat_set_raw_ops(kstat_t *ksp,\n    int (*headers)(char *buf, size_t size),\n    int (*data)(char *buf, size_t size, void *data),\n    void *(*addr)(kstat_t *ksp, loff_t index))\n{\n\tksp->ks_raw_ops.headers = headers;\n\tksp->ks_raw_ops.data    = data;\n\tksp->ks_raw_ops.addr    = addr;\n}\nEXPORT_SYMBOL(__kstat_set_raw_ops);\n\nvoid\nkstat_proc_entry_init(kstat_proc_entry_t *kpep, const char *module,\n    const char *name)\n{\n\tkpep->kpe_owner = NULL;\n\tkpep->kpe_proc = NULL;\n\tINIT_LIST_HEAD(&kpep->kpe_list);\n\tstrlcpy(kpep->kpe_module, module, sizeof (kpep->kpe_module));\n\tstrlcpy(kpep->kpe_name, name, sizeof (kpep->kpe_name));\n}\nEXPORT_SYMBOL(kstat_proc_entry_init);\n\nkstat_t *\n__kstat_create(const char *ks_module, int ks_instance, const char *ks_name,\n    const char *ks_class, uchar_t ks_type, uint_t ks_ndata,\n    uchar_t ks_flags)\n{\n\tkstat_t *ksp;\n\n\tASSERT(ks_module);\n\tASSERT(ks_instance == 0);\n\tASSERT(ks_name);\n\n\tif ((ks_type == KSTAT_TYPE_INTR) || (ks_type == KSTAT_TYPE_IO))\n\t\tASSERT(ks_ndata == 1);\n\n\tksp = kmem_zalloc(sizeof (*ksp), KM_SLEEP);\n\tif (ksp == NULL)\n\t\treturn (ksp);\n\n\tmutex_enter(&kstat_module_lock);\n\tksp->ks_kid = kstat_id;\n\tkstat_id++;\n\tmutex_exit(&kstat_module_lock);\n\n\tksp->ks_magic = KS_MAGIC;\n\tmutex_init(&ksp->ks_private_lock, NULL, MUTEX_DEFAULT, NULL);\n\tksp->ks_lock = &ksp->ks_private_lock;\n\n\tksp->ks_crtime = gethrtime();\n\tksp->ks_snaptime = ksp->ks_crtime;\n\tksp->ks_instance = ks_instance;\n\tstrlcpy(ksp->ks_class, ks_class, sizeof (ksp->ks_class));\n\tksp->ks_type = ks_type;\n\tksp->ks_flags = ks_flags;\n\tksp->ks_update = kstat_default_update;\n\tksp->ks_private = NULL;\n\tksp->ks_raw_ops.headers = NULL;\n\tksp->ks_raw_ops.data = NULL;\n\tksp->ks_raw_ops.addr = NULL;\n\tksp->ks_raw_buf = NULL;\n\tksp->ks_raw_bufsize = 0;\n\tkstat_proc_entry_init(&ksp->ks_proc, ks_module, ks_name);\n\n\tswitch (ksp->ks_type) {\n\t\tcase KSTAT_TYPE_RAW:\n\t\t\tksp->ks_ndata = 1;\n\t\t\tksp->ks_data_size = ks_ndata;\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_NAMED:\n\t\t\tksp->ks_ndata = ks_ndata;\n\t\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_named_t);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_INTR:\n\t\t\tksp->ks_ndata = ks_ndata;\n\t\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_intr_t);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_IO:\n\t\t\tksp->ks_ndata = ks_ndata;\n\t\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_io_t);\n\t\t\tbreak;\n\t\tcase KSTAT_TYPE_TIMER:\n\t\t\tksp->ks_ndata = ks_ndata;\n\t\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_timer_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPANIC(\"Undefined kstat type %d\\n\", ksp->ks_type);\n\t}\n\n\tif (ksp->ks_flags & KSTAT_FLAG_VIRTUAL) {\n\t\tksp->ks_data = NULL;\n\t} else {\n\t\tksp->ks_data = kmem_zalloc(ksp->ks_data_size, KM_SLEEP);\n\t\tif (ksp->ks_data == NULL) {\n\t\t\tkmem_free(ksp, sizeof (*ksp));\n\t\t\tksp = NULL;\n\t\t}\n\t}\n\n\treturn (ksp);\n}\nEXPORT_SYMBOL(__kstat_create);\n\nstatic int\nkstat_detect_collision(kstat_proc_entry_t *kpep)\n{\n\tkstat_module_t *module;\n\tkstat_proc_entry_t *tmp = NULL;\n\tchar *parent;\n\tchar *cp;\n\n\tparent = kmem_asprintf(\"%s\", kpep->kpe_module);\n\n\tif ((cp = strrchr(parent, '/')) == NULL) {\n\t\tkmem_strfree(parent);\n\t\treturn (0);\n\t}\n\n\tcp[0] = '\\0';\n\tif ((module = kstat_find_module(parent)) != NULL) {\n\t\tlist_for_each_entry(tmp, &module->ksm_kstat_list, kpe_list) {\n\t\t\tif (strncmp(tmp->kpe_name, cp+1, KSTAT_STRLEN) == 0) {\n\t\t\t\tkmem_strfree(parent);\n\t\t\t\treturn (EEXIST);\n\t\t\t}\n\t\t}\n\t}\n\n\tkmem_strfree(parent);\n\treturn (0);\n}\n\n \nvoid\nkstat_proc_entry_install(kstat_proc_entry_t *kpep, mode_t mode,\n    const kstat_proc_op_t *proc_ops, void *data)\n{\n\tkstat_module_t *module;\n\tkstat_proc_entry_t *tmp = NULL;\n\n\tASSERT(kpep);\n\n\tmutex_enter(&kstat_module_lock);\n\n\tmodule = kstat_find_module(kpep->kpe_module);\n\tif (module == NULL) {\n\t\tif (kstat_detect_collision(kpep) != 0) {\n\t\t\tcmn_err(CE_WARN, \"kstat_create('%s', '%s'): namespace\" \\\n\t\t\t    \" collision\", kpep->kpe_module, kpep->kpe_name);\n\t\t\tgoto out;\n\t\t}\n\t\tmodule = kstat_create_module(kpep->kpe_module);\n\t\tif (module == NULL)\n\t\t\tgoto out;\n\t}\n\n\t \n\tlist_for_each_entry(tmp, &module->ksm_kstat_list, kpe_list) {\n\t\tif (strncmp(tmp->kpe_name, kpep->kpe_name, KSTAT_STRLEN) == 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_tail(&kpep->kpe_list, &module->ksm_kstat_list);\n\n\tkpep->kpe_owner = module;\n\tkpep->kpe_proc = proc_create_data(kpep->kpe_name, mode,\n\t    module->ksm_proc, proc_ops, data);\n\tif (kpep->kpe_proc == NULL) {\n\t\tlist_del_init(&kpep->kpe_list);\n\t\tif (list_empty(&module->ksm_kstat_list))\n\t\t\tkstat_delete_module(module);\n\t}\nout:\n\tmutex_exit(&kstat_module_lock);\n\n}\nEXPORT_SYMBOL(kstat_proc_entry_install);\n\nvoid\n__kstat_install(kstat_t *ksp)\n{\n\tASSERT(ksp);\n\tmode_t mode;\n\t \n\tif (strncmp(ksp->ks_proc.kpe_name, \"dbufs\", KSTAT_STRLEN) == 0) {\n\t\tmode = 0600;\n\t} else {\n\t\tmode = 0644;\n\t}\n\tkstat_proc_entry_install(\n\t    &ksp->ks_proc, mode, &proc_kstat_operations, ksp);\n}\nEXPORT_SYMBOL(__kstat_install);\n\nvoid\nkstat_proc_entry_delete(kstat_proc_entry_t *kpep)\n{\n\tkstat_module_t *module = kpep->kpe_owner;\n\tif (kpep->kpe_proc)\n\t\tremove_proc_entry(kpep->kpe_name, module->ksm_proc);\n\n\tmutex_enter(&kstat_module_lock);\n\tlist_del_init(&kpep->kpe_list);\n\n\t \n\tif (kpep->kpe_proc && list_empty(&module->ksm_kstat_list))\n\t\tkstat_delete_module(module);\n\tmutex_exit(&kstat_module_lock);\n\n}\nEXPORT_SYMBOL(kstat_proc_entry_delete);\n\nvoid\n__kstat_delete(kstat_t *ksp)\n{\n\tkstat_proc_entry_delete(&ksp->ks_proc);\n\n\tif (!(ksp->ks_flags & KSTAT_FLAG_VIRTUAL))\n\t\tkmem_free(ksp->ks_data, ksp->ks_data_size);\n\n\tksp->ks_lock = NULL;\n\tmutex_destroy(&ksp->ks_private_lock);\n\tkmem_free(ksp, sizeof (*ksp));\n}\nEXPORT_SYMBOL(__kstat_delete);\n\nint\nspl_kstat_init(void)\n{\n\tmutex_init(&kstat_module_lock, NULL, MUTEX_DEFAULT, NULL);\n\tINIT_LIST_HEAD(&kstat_module_list);\n\tkstat_id = 0;\n\treturn (0);\n}\n\nvoid\nspl_kstat_fini(void)\n{\n\tASSERT(list_empty(&kstat_module_list));\n\tmutex_destroy(&kstat_module_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}