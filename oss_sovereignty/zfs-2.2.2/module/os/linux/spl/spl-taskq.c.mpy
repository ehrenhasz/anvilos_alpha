{
  "module_name": "spl-taskq.c",
  "hash_id": "4aa50279b68bcfeac740ccd3ce770cce1ac1cb17c29682ecec12ecb399afc3e1",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-taskq.c",
  "human_readable_source": " \n\n#include <sys/timer.h>\n#include <sys/taskq.h>\n#include <sys/kmem.h>\n#include <sys/tsd.h>\n#include <sys/trace_spl.h>\n#ifdef HAVE_CPU_HOTPLUG\n#include <linux/cpuhotplug.h>\n#endif\n\nstatic int spl_taskq_thread_bind = 0;\nmodule_param(spl_taskq_thread_bind, int, 0644);\nMODULE_PARM_DESC(spl_taskq_thread_bind, \"Bind taskq thread to CPU by default\");\n\nstatic uint_t spl_taskq_thread_timeout_ms = 10000;\n \nmodule_param(spl_taskq_thread_timeout_ms, uint, 0644);\n \nMODULE_PARM_DESC(spl_taskq_thread_timeout_ms,\n\t\"Time to require a dynamic thread be idle before it gets cleaned up\");\n\nstatic int spl_taskq_thread_dynamic = 1;\nmodule_param(spl_taskq_thread_dynamic, int, 0444);\nMODULE_PARM_DESC(spl_taskq_thread_dynamic, \"Allow dynamic taskq threads\");\n\nstatic int spl_taskq_thread_priority = 1;\nmodule_param(spl_taskq_thread_priority, int, 0644);\nMODULE_PARM_DESC(spl_taskq_thread_priority,\n\t\"Allow non-default priority for taskq threads\");\n\nstatic uint_t spl_taskq_thread_sequential = 4;\n \nmodule_param(spl_taskq_thread_sequential, uint, 0644);\n \nMODULE_PARM_DESC(spl_taskq_thread_sequential,\n\t\"Create new taskq threads after N sequential tasks\");\n\n \ntaskq_t *system_taskq;\nEXPORT_SYMBOL(system_taskq);\n \ntaskq_t *system_delay_taskq;\nEXPORT_SYMBOL(system_delay_taskq);\n\n \nstatic taskq_t *dynamic_taskq;\nstatic taskq_thread_t *taskq_thread_create(taskq_t *);\n\n#ifdef HAVE_CPU_HOTPLUG\n \nstatic int spl_taskq_cpuhp_state;\n#endif\n\n \nLIST_HEAD(tq_list);\nstruct rw_semaphore tq_list_sem;\nstatic uint_t taskq_tsd;\n\nstatic int\ntask_km_flags(uint_t flags)\n{\n\tif (flags & TQ_NOSLEEP)\n\t\treturn (KM_NOSLEEP);\n\n\tif (flags & TQ_PUSHPAGE)\n\t\treturn (KM_PUSHPAGE);\n\n\treturn (KM_SLEEP);\n}\n\n \nstatic int\ntaskq_find_by_name(const char *name)\n{\n\tstruct list_head *tql = NULL;\n\ttaskq_t *tq;\n\n\tlist_for_each_prev(tql, &tq_list) {\n\t\ttq = list_entry(tql, taskq_t, tq_taskqs);\n\t\tif (strcmp(name, tq->tq_name) == 0)\n\t\t\treturn (tq->tq_instance);\n\t}\n\treturn (-1);\n}\n\n \nstatic taskq_ent_t *\ntask_alloc(taskq_t *tq, uint_t flags, unsigned long *irqflags)\n{\n\ttaskq_ent_t *t;\n\tint count = 0;\n\n\tASSERT(tq);\nretry:\n\t \n\tif (!list_empty(&tq->tq_free_list) && !(flags & TQ_NEW)) {\n\t\tt = list_entry(tq->tq_free_list.next, taskq_ent_t, tqent_list);\n\n\t\tASSERT(!(t->tqent_flags & TQENT_FLAG_PREALLOC));\n\t\tASSERT(!(t->tqent_flags & TQENT_FLAG_CANCEL));\n\t\tASSERT(!timer_pending(&t->tqent_timer));\n\n\t\tlist_del_init(&t->tqent_list);\n\t\treturn (t);\n\t}\n\n\t \n\tif (flags & TQ_NOALLOC)\n\t\treturn (NULL);\n\n\t \n\tif (tq->tq_nalloc >= tq->tq_maxalloc) {\n\t\tif (flags & TQ_NOSLEEP)\n\t\t\treturn (NULL);\n\n\t\t \n\t\tspin_unlock_irqrestore(&tq->tq_lock, *irqflags);\n\t\tschedule_timeout(HZ / 100);\n\t\tspin_lock_irqsave_nested(&tq->tq_lock, *irqflags,\n\t\t    tq->tq_lock_class);\n\t\tif (count < 100) {\n\t\t\tcount++;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&tq->tq_lock, *irqflags);\n\tt = kmem_alloc(sizeof (taskq_ent_t), task_km_flags(flags));\n\tspin_lock_irqsave_nested(&tq->tq_lock, *irqflags, tq->tq_lock_class);\n\n\tif (t) {\n\t\ttaskq_init_ent(t);\n\t\ttq->tq_nalloc++;\n\t}\n\n\treturn (t);\n}\n\n \nstatic void\ntask_free(taskq_t *tq, taskq_ent_t *t)\n{\n\tASSERT(tq);\n\tASSERT(t);\n\tASSERT(list_empty(&t->tqent_list));\n\tASSERT(!timer_pending(&t->tqent_timer));\n\n\tkmem_free(t, sizeof (taskq_ent_t));\n\ttq->tq_nalloc--;\n}\n\n \nstatic void\ntask_done(taskq_t *tq, taskq_ent_t *t)\n{\n\tASSERT(tq);\n\tASSERT(t);\n\n\t \n\twake_up_all(&t->tqent_waitq);\n\n\tlist_del_init(&t->tqent_list);\n\n\tif (tq->tq_nalloc <= tq->tq_minalloc) {\n\t\tt->tqent_id = TASKQID_INVALID;\n\t\tt->tqent_func = NULL;\n\t\tt->tqent_arg = NULL;\n\t\tt->tqent_flags = 0;\n\n\t\tlist_add_tail(&t->tqent_list, &tq->tq_free_list);\n\t} else {\n\t\ttask_free(tq, t);\n\t}\n}\n\n \nstatic void\ntask_expire_impl(taskq_ent_t *t)\n{\n\ttaskq_ent_t *w;\n\ttaskq_t *tq = t->tqent_taskq;\n\tstruct list_head *l = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\n\tif (t->tqent_flags & TQENT_FLAG_CANCEL) {\n\t\tASSERT(list_empty(&t->tqent_list));\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t\treturn;\n\t}\n\n\tt->tqent_birth = jiffies;\n\tDTRACE_PROBE1(taskq_ent__birth, taskq_ent_t *, t);\n\n\t \n\tlist_del(&t->tqent_list);\n\tlist_for_each_prev(l, &tq->tq_prio_list) {\n\t\tw = list_entry(l, taskq_ent_t, tqent_list);\n\t\tif (w->tqent_id < t->tqent_id) {\n\t\t\tlist_add(&t->tqent_list, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (l == &tq->tq_prio_list)\n\t\tlist_add(&t->tqent_list, &tq->tq_prio_list);\n\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\twake_up(&tq->tq_work_waitq);\n}\n\nstatic void\ntask_expire(spl_timer_list_t tl)\n{\n\tstruct timer_list *tmr = (struct timer_list *)tl;\n\ttaskq_ent_t *t = from_timer(t, tmr, tqent_timer);\n\ttask_expire_impl(t);\n}\n\n \nstatic taskqid_t\ntaskq_lowest_id(taskq_t *tq)\n{\n\ttaskqid_t lowest_id = tq->tq_next_id;\n\ttaskq_ent_t *t;\n\ttaskq_thread_t *tqt;\n\n\tif (!list_empty(&tq->tq_pend_list)) {\n\t\tt = list_entry(tq->tq_pend_list.next, taskq_ent_t, tqent_list);\n\t\tlowest_id = MIN(lowest_id, t->tqent_id);\n\t}\n\n\tif (!list_empty(&tq->tq_prio_list)) {\n\t\tt = list_entry(tq->tq_prio_list.next, taskq_ent_t, tqent_list);\n\t\tlowest_id = MIN(lowest_id, t->tqent_id);\n\t}\n\n\tif (!list_empty(&tq->tq_delay_list)) {\n\t\tt = list_entry(tq->tq_delay_list.next, taskq_ent_t, tqent_list);\n\t\tlowest_id = MIN(lowest_id, t->tqent_id);\n\t}\n\n\tif (!list_empty(&tq->tq_active_list)) {\n\t\ttqt = list_entry(tq->tq_active_list.next, taskq_thread_t,\n\t\t    tqt_active_list);\n\t\tASSERT(tqt->tqt_id != TASKQID_INVALID);\n\t\tlowest_id = MIN(lowest_id, tqt->tqt_id);\n\t}\n\n\treturn (lowest_id);\n}\n\n \nstatic void\ntaskq_insert_in_order(taskq_t *tq, taskq_thread_t *tqt)\n{\n\ttaskq_thread_t *w;\n\tstruct list_head *l = NULL;\n\n\tASSERT(tq);\n\tASSERT(tqt);\n\n\tlist_for_each_prev(l, &tq->tq_active_list) {\n\t\tw = list_entry(l, taskq_thread_t, tqt_active_list);\n\t\tif (w->tqt_id < tqt->tqt_id) {\n\t\t\tlist_add(&tqt->tqt_active_list, l);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (l == &tq->tq_active_list)\n\t\tlist_add(&tqt->tqt_active_list, &tq->tq_active_list);\n}\n\n \nstatic taskq_ent_t *\ntaskq_find_list(taskq_t *tq, struct list_head *lh, taskqid_t id)\n{\n\tstruct list_head *l = NULL;\n\ttaskq_ent_t *t;\n\n\tlist_for_each(l, lh) {\n\t\tt = list_entry(l, taskq_ent_t, tqent_list);\n\n\t\tif (t->tqent_id == id)\n\t\t\treturn (t);\n\n\t\tif (t->tqent_id > id)\n\t\t\tbreak;\n\t}\n\n\treturn (NULL);\n}\n\n \nstatic taskq_ent_t *\ntaskq_find(taskq_t *tq, taskqid_t id)\n{\n\ttaskq_thread_t *tqt;\n\tstruct list_head *l = NULL;\n\ttaskq_ent_t *t;\n\n\tt = taskq_find_list(tq, &tq->tq_delay_list, id);\n\tif (t)\n\t\treturn (t);\n\n\tt = taskq_find_list(tq, &tq->tq_prio_list, id);\n\tif (t)\n\t\treturn (t);\n\n\tt = taskq_find_list(tq, &tq->tq_pend_list, id);\n\tif (t)\n\t\treturn (t);\n\n\tlist_for_each(l, &tq->tq_active_list) {\n\t\ttqt = list_entry(l, taskq_thread_t, tqt_active_list);\n\t\tif (tqt->tqt_id == id) {\n\t\t\t \n\t\t\treturn (ERR_PTR(-EBUSY));\n\t\t}\n\t}\n\n\treturn (NULL);\n}\n\n \nstatic int\ntaskq_wait_id_check(taskq_t *tq, taskqid_t id)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\trc = (taskq_find(tq, id) == NULL);\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\treturn (rc);\n}\n\n \nvoid\ntaskq_wait_id(taskq_t *tq, taskqid_t id)\n{\n\twait_event(tq->tq_wait_waitq, taskq_wait_id_check(tq, id));\n}\nEXPORT_SYMBOL(taskq_wait_id);\n\nstatic int\ntaskq_wait_outstanding_check(taskq_t *tq, taskqid_t id)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\trc = (id < tq->tq_lowest_id);\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\treturn (rc);\n}\n\n \nvoid\ntaskq_wait_outstanding(taskq_t *tq, taskqid_t id)\n{\n\tid = id ? id : tq->tq_next_id - 1;\n\twait_event(tq->tq_wait_waitq, taskq_wait_outstanding_check(tq, id));\n}\nEXPORT_SYMBOL(taskq_wait_outstanding);\n\nstatic int\ntaskq_wait_check(taskq_t *tq)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\trc = (tq->tq_lowest_id == tq->tq_next_id);\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\treturn (rc);\n}\n\n \nvoid\ntaskq_wait(taskq_t *tq)\n{\n\twait_event(tq->tq_wait_waitq, taskq_wait_check(tq));\n}\nEXPORT_SYMBOL(taskq_wait);\n\nint\ntaskq_member(taskq_t *tq, kthread_t *t)\n{\n\treturn (tq == (taskq_t *)tsd_get_by_thread(taskq_tsd, t));\n}\nEXPORT_SYMBOL(taskq_member);\n\ntaskq_t *\ntaskq_of_curthread(void)\n{\n\treturn (tsd_get(taskq_tsd));\n}\nEXPORT_SYMBOL(taskq_of_curthread);\n\n \nint\ntaskq_cancel_id(taskq_t *tq, taskqid_t id)\n{\n\ttaskq_ent_t *t;\n\tint rc = ENOENT;\n\tunsigned long flags;\n\n\tASSERT(tq);\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\tt = taskq_find(tq, id);\n\tif (t && t != ERR_PTR(-EBUSY)) {\n\t\tlist_del_init(&t->tqent_list);\n\t\tt->tqent_flags |= TQENT_FLAG_CANCEL;\n\n\t\t \n\t\tif (tq->tq_lowest_id == t->tqent_id) {\n\t\t\ttq->tq_lowest_id = taskq_lowest_id(tq);\n\t\t\tASSERT3S(tq->tq_lowest_id, >, t->tqent_id);\n\t\t}\n\n\t\t \n\t\tif (timer_pending(&t->tqent_timer)) {\n\t\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t\t\tdel_timer_sync(&t->tqent_timer);\n\t\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t\t    tq->tq_lock_class);\n\t\t}\n\n\t\tif (!(t->tqent_flags & TQENT_FLAG_PREALLOC))\n\t\t\ttask_done(tq, t);\n\n\t\trc = 0;\n\t}\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\tif (t == ERR_PTR(-EBUSY)) {\n\t\ttaskq_wait_id(tq, id);\n\t\trc = EBUSY;\n\t}\n\n\treturn (rc);\n}\nEXPORT_SYMBOL(taskq_cancel_id);\n\nstatic int taskq_thread_spawn(taskq_t *tq);\n\ntaskqid_t\ntaskq_dispatch(taskq_t *tq, task_func_t func, void *arg, uint_t flags)\n{\n\ttaskq_ent_t *t;\n\ttaskqid_t rc = TASKQID_INVALID;\n\tunsigned long irqflags;\n\n\tASSERT(tq);\n\tASSERT(func);\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, irqflags, tq->tq_lock_class);\n\n\t \n\tif (!(tq->tq_flags & TASKQ_ACTIVE))\n\t\tgoto out;\n\n\t \n\tASSERT(tq->tq_nactive <= tq->tq_nthreads);\n\tif ((flags & TQ_NOQUEUE) && (tq->tq_nactive == tq->tq_nthreads)) {\n\t\t \n\t\tif (!(tq->tq_flags & TASKQ_DYNAMIC) ||\n\t\t    taskq_thread_spawn(tq) == 0)\n\t\t\tgoto out;\n\t}\n\n\tif ((t = task_alloc(tq, flags, &irqflags)) == NULL)\n\t\tgoto out;\n\n\tspin_lock(&t->tqent_lock);\n\n\t \n\tif (flags & TQ_NOQUEUE)\n\t\tlist_add(&t->tqent_list, &tq->tq_prio_list);\n\t \n\telse if (flags & TQ_FRONT)\n\t\tlist_add_tail(&t->tqent_list, &tq->tq_prio_list);\n\telse\n\t\tlist_add_tail(&t->tqent_list, &tq->tq_pend_list);\n\n\tt->tqent_id = rc = tq->tq_next_id;\n\ttq->tq_next_id++;\n\tt->tqent_func = func;\n\tt->tqent_arg = arg;\n\tt->tqent_taskq = tq;\n\tt->tqent_timer.function = NULL;\n\tt->tqent_timer.expires = 0;\n\n\tt->tqent_birth = jiffies;\n\tDTRACE_PROBE1(taskq_ent__birth, taskq_ent_t *, t);\n\n\tASSERT(!(t->tqent_flags & TQENT_FLAG_PREALLOC));\n\n\tspin_unlock(&t->tqent_lock);\n\n\twake_up(&tq->tq_work_waitq);\nout:\n\t \n\tif (!(flags & TQ_NOQUEUE) && tq->tq_nactive == tq->tq_nthreads)\n\t\t(void) taskq_thread_spawn(tq);\n\n\tspin_unlock_irqrestore(&tq->tq_lock, irqflags);\n\treturn (rc);\n}\nEXPORT_SYMBOL(taskq_dispatch);\n\ntaskqid_t\ntaskq_dispatch_delay(taskq_t *tq, task_func_t func, void *arg,\n    uint_t flags, clock_t expire_time)\n{\n\ttaskqid_t rc = TASKQID_INVALID;\n\ttaskq_ent_t *t;\n\tunsigned long irqflags;\n\n\tASSERT(tq);\n\tASSERT(func);\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, irqflags, tq->tq_lock_class);\n\n\t \n\tif (!(tq->tq_flags & TASKQ_ACTIVE))\n\t\tgoto out;\n\n\tif ((t = task_alloc(tq, flags, &irqflags)) == NULL)\n\t\tgoto out;\n\n\tspin_lock(&t->tqent_lock);\n\n\t \n\tlist_add_tail(&t->tqent_list, &tq->tq_delay_list);\n\n\tt->tqent_id = rc = tq->tq_next_id;\n\ttq->tq_next_id++;\n\tt->tqent_func = func;\n\tt->tqent_arg = arg;\n\tt->tqent_taskq = tq;\n\tt->tqent_timer.function = task_expire;\n\tt->tqent_timer.expires = (unsigned long)expire_time;\n\tadd_timer(&t->tqent_timer);\n\n\tASSERT(!(t->tqent_flags & TQENT_FLAG_PREALLOC));\n\n\tspin_unlock(&t->tqent_lock);\nout:\n\t \n\tif (tq->tq_nactive == tq->tq_nthreads)\n\t\t(void) taskq_thread_spawn(tq);\n\tspin_unlock_irqrestore(&tq->tq_lock, irqflags);\n\treturn (rc);\n}\nEXPORT_SYMBOL(taskq_dispatch_delay);\n\nvoid\ntaskq_dispatch_ent(taskq_t *tq, task_func_t func, void *arg, uint_t flags,\n    taskq_ent_t *t)\n{\n\tunsigned long irqflags;\n\tASSERT(tq);\n\tASSERT(func);\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, irqflags,\n\t    tq->tq_lock_class);\n\n\t \n\tif (!(tq->tq_flags & TASKQ_ACTIVE)) {\n\t\tt->tqent_id = TASKQID_INVALID;\n\t\tgoto out;\n\t}\n\n\tif ((flags & TQ_NOQUEUE) && (tq->tq_nactive == tq->tq_nthreads)) {\n\t\t \n\t\tif (!(tq->tq_flags & TASKQ_DYNAMIC) ||\n\t\t    taskq_thread_spawn(tq) == 0)\n\t\t\tgoto out2;\n\t\tflags |= TQ_FRONT;\n\t}\n\n\tspin_lock(&t->tqent_lock);\n\n\t \n\tASSERT(taskq_empty_ent(t));\n\n\t \n\tt->tqent_flags |= TQENT_FLAG_PREALLOC;\n\n\t \n\tif (flags & TQ_FRONT)\n\t\tlist_add_tail(&t->tqent_list, &tq->tq_prio_list);\n\telse\n\t\tlist_add_tail(&t->tqent_list, &tq->tq_pend_list);\n\n\tt->tqent_id = tq->tq_next_id;\n\ttq->tq_next_id++;\n\tt->tqent_func = func;\n\tt->tqent_arg = arg;\n\tt->tqent_taskq = tq;\n\n\tt->tqent_birth = jiffies;\n\tDTRACE_PROBE1(taskq_ent__birth, taskq_ent_t *, t);\n\n\tspin_unlock(&t->tqent_lock);\n\n\twake_up(&tq->tq_work_waitq);\nout:\n\t \n\tif (tq->tq_nactive == tq->tq_nthreads)\n\t\t(void) taskq_thread_spawn(tq);\nout2:\n\tspin_unlock_irqrestore(&tq->tq_lock, irqflags);\n}\nEXPORT_SYMBOL(taskq_dispatch_ent);\n\nint\ntaskq_empty_ent(taskq_ent_t *t)\n{\n\treturn (list_empty(&t->tqent_list));\n}\nEXPORT_SYMBOL(taskq_empty_ent);\n\nvoid\ntaskq_init_ent(taskq_ent_t *t)\n{\n\tspin_lock_init(&t->tqent_lock);\n\tinit_waitqueue_head(&t->tqent_waitq);\n\ttimer_setup(&t->tqent_timer, NULL, 0);\n\tINIT_LIST_HEAD(&t->tqent_list);\n\tt->tqent_id = 0;\n\tt->tqent_func = NULL;\n\tt->tqent_arg = NULL;\n\tt->tqent_flags = 0;\n\tt->tqent_taskq = NULL;\n}\nEXPORT_SYMBOL(taskq_init_ent);\n\n \nstatic taskq_ent_t *\ntaskq_next_ent(taskq_t *tq)\n{\n\tstruct list_head *list;\n\n\tif (!list_empty(&tq->tq_prio_list))\n\t\tlist = &tq->tq_prio_list;\n\telse if (!list_empty(&tq->tq_pend_list))\n\t\tlist = &tq->tq_pend_list;\n\telse\n\t\treturn (NULL);\n\n\treturn (list_entry(list->next, taskq_ent_t, tqent_list));\n}\n\n \nstatic void\ntaskq_thread_spawn_task(void *arg)\n{\n\ttaskq_t *tq = (taskq_t *)arg;\n\tunsigned long flags;\n\n\tif (taskq_thread_create(tq) == NULL) {\n\t\t \n\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t    tq->tq_lock_class);\n\t\ttq->tq_nspawn--;\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t}\n}\n\n \nstatic int\ntaskq_thread_spawn(taskq_t *tq)\n{\n\tint spawning = 0;\n\n\tif (!(tq->tq_flags & TASKQ_DYNAMIC))\n\t\treturn (0);\n\n\tif ((tq->tq_nthreads + tq->tq_nspawn < tq->tq_maxthreads) &&\n\t    (tq->tq_flags & TASKQ_ACTIVE)) {\n\t\tspawning = (++tq->tq_nspawn);\n\t\ttaskq_dispatch(dynamic_taskq, taskq_thread_spawn_task,\n\t\t    tq, TQ_NOSLEEP);\n\t}\n\n\treturn (spawning);\n}\n\n \nstatic int\ntaskq_thread_should_stop(taskq_t *tq, taskq_thread_t *tqt)\n{\n\tif (!(tq->tq_flags & TASKQ_DYNAMIC))\n\t\treturn (0);\n\n\tif (list_first_entry(&(tq->tq_thread_list), taskq_thread_t,\n\t    tqt_thread_list) == tqt)\n\t\treturn (0);\n\n\tint no_work =\n\t    ((tq->tq_nspawn == 0) &&\t \n\t    (tq->tq_nactive == 0) &&\t \n\t    (tq->tq_nthreads > 1) &&\t \n\t    (!taskq_next_ent(tq)) &&\t \n\t    (spl_taskq_thread_dynamic));  \n\n\t \n\tif (no_work) {\n\t\t \n\t\t \n\t\tif (spl_taskq_thread_timeout_ms == 0 ||\n\t\t    !(tq->tq_flags & TASKQ_ACTIVE))\n\t\t\treturn (1);\n\t\tunsigned long lasttime = tq->lastshouldstop;\n\t\tif (lasttime > 0) {\n\t\t\tif (time_after(jiffies, lasttime +\n\t\t\t    msecs_to_jiffies(spl_taskq_thread_timeout_ms)))\n\t\t\t\treturn (1);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\ttq->lastshouldstop = jiffies;\n\t\t}\n\t} else {\n\t\ttq->lastshouldstop = 0;\n\t}\n\treturn (0);\n}\n\nstatic int\ntaskq_thread(void *args)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tsigset_t blocked;\n\ttaskq_thread_t *tqt = args;\n\ttaskq_t *tq;\n\ttaskq_ent_t *t;\n\tint seq_tasks = 0;\n\tunsigned long flags;\n\ttaskq_ent_t dup_task = {};\n\n\tASSERT(tqt);\n\tASSERT(tqt->tqt_tq);\n\ttq = tqt->tqt_tq;\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t(void) spl_fstrans_mark();\n\n\tsigfillset(&blocked);\n\tsigprocmask(SIG_BLOCK, &blocked, NULL);\n\tflush_signals(current);\n\n\ttsd_set(taskq_tsd, tq);\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\t \n\tif (tq->tq_flags & TASKQ_DYNAMIC)\n\t\ttq->tq_nspawn--;\n\n\t \n\tif (tq->tq_nthreads >= tq->tq_maxthreads)\n\t\tgoto error;\n\n\ttq->tq_nthreads++;\n\tlist_add_tail(&tqt->tqt_thread_list, &tq->tq_thread_list);\n\twake_up(&tq->tq_wait_waitq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (!kthread_should_stop()) {\n\n\t\tif (list_empty(&tq->tq_pend_list) &&\n\t\t    list_empty(&tq->tq_prio_list)) {\n\n\t\t\tif (taskq_thread_should_stop(tq, tqt)) {\n\t\t\t\twake_up_all(&tq->tq_wait_waitq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tadd_wait_queue_exclusive(&tq->tq_work_waitq, &wait);\n\t\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\t\t\tschedule();\n\t\t\tseq_tasks = 0;\n\n\t\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t\t    tq->tq_lock_class);\n\t\t\tremove_wait_queue(&tq->tq_work_waitq, &wait);\n\t\t} else {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\n\t\tif ((t = taskq_next_ent(tq)) != NULL) {\n\t\t\tlist_del_init(&t->tqent_list);\n\n\t\t\t \n\t\t\ttqt->tqt_id = t->tqent_id;\n\t\t\ttqt->tqt_flags = t->tqent_flags;\n\n\t\t\tif (t->tqent_flags & TQENT_FLAG_PREALLOC) {\n\t\t\t\tdup_task = *t;\n\t\t\t\tt = &dup_task;\n\t\t\t}\n\t\t\ttqt->tqt_task = t;\n\n\t\t\ttaskq_insert_in_order(tq, tqt);\n\t\t\ttq->tq_nactive++;\n\t\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\t\t\tDTRACE_PROBE1(taskq_ent__start, taskq_ent_t *, t);\n\n\t\t\t \n\t\t\tt->tqent_func(t->tqent_arg);\n\n\t\t\tDTRACE_PROBE1(taskq_ent__finish, taskq_ent_t *, t);\n\n\t\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t\t    tq->tq_lock_class);\n\t\t\ttq->tq_nactive--;\n\t\t\tlist_del_init(&tqt->tqt_active_list);\n\t\t\ttqt->tqt_task = NULL;\n\n\t\t\t \n\t\t\tif (!(tqt->tqt_flags & TQENT_FLAG_PREALLOC))\n\t\t\t\ttask_done(tq, t);\n\n\t\t\t \n\t\t\tif (tq->tq_lowest_id == tqt->tqt_id) {\n\t\t\t\ttq->tq_lowest_id = taskq_lowest_id(tq);\n\t\t\t\tASSERT3S(tq->tq_lowest_id, >, tqt->tqt_id);\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((++seq_tasks) > spl_taskq_thread_sequential &&\n\t\t\t    taskq_thread_spawn(tq))\n\t\t\t\tseq_tasks = 0;\n\n\t\t\ttqt->tqt_id = TASKQID_INVALID;\n\t\t\ttqt->tqt_flags = 0;\n\t\t\twake_up_all(&tq->tq_wait_waitq);\n\t\t} else {\n\t\t\tif (taskq_thread_should_stop(tq, tqt))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\ttq->tq_nthreads--;\n\tlist_del_init(&tqt->tqt_thread_list);\nerror:\n\tkmem_free(tqt, sizeof (taskq_thread_t));\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\ttsd_set(taskq_tsd, NULL);\n\tthread_exit();\n\n\treturn (0);\n}\n\nstatic taskq_thread_t *\ntaskq_thread_create(taskq_t *tq)\n{\n\tstatic int last_used_cpu = 0;\n\ttaskq_thread_t *tqt;\n\n\ttqt = kmem_alloc(sizeof (*tqt), KM_PUSHPAGE);\n\tINIT_LIST_HEAD(&tqt->tqt_thread_list);\n\tINIT_LIST_HEAD(&tqt->tqt_active_list);\n\ttqt->tqt_tq = tq;\n\ttqt->tqt_id = TASKQID_INVALID;\n\n\ttqt->tqt_thread = spl_kthread_create(taskq_thread, tqt,\n\t    \"%s\", tq->tq_name);\n\tif (tqt->tqt_thread == NULL) {\n\t\tkmem_free(tqt, sizeof (taskq_thread_t));\n\t\treturn (NULL);\n\t}\n\n\tif (spl_taskq_thread_bind) {\n\t\tlast_used_cpu = (last_used_cpu + 1) % num_online_cpus();\n\t\tkthread_bind(tqt->tqt_thread, last_used_cpu);\n\t}\n\n\tif (spl_taskq_thread_priority)\n\t\tset_user_nice(tqt->tqt_thread, PRIO_TO_NICE(tq->tq_pri));\n\n\twake_up_process(tqt->tqt_thread);\n\n\treturn (tqt);\n}\n\ntaskq_t *\ntaskq_create(const char *name, int threads_arg, pri_t pri,\n    int minalloc, int maxalloc, uint_t flags)\n{\n\ttaskq_t *tq;\n\ttaskq_thread_t *tqt;\n\tint count = 0, rc = 0, i;\n\tunsigned long irqflags;\n\tint nthreads = threads_arg;\n\n\tASSERT(name != NULL);\n\tASSERT(minalloc >= 0);\n\tASSERT(!(flags & (TASKQ_CPR_SAFE)));  \n\n\t \n\tif (flags & TASKQ_THREADS_CPU_PCT) {\n\t\tASSERT(nthreads <= 100);\n\t\tASSERT(nthreads >= 0);\n\t\tnthreads = MIN(threads_arg, 100);\n\t\tnthreads = MAX(nthreads, 0);\n\t\tnthreads = MAX((num_online_cpus() * nthreads) /100, 1);\n\t}\n\n\ttq = kmem_alloc(sizeof (*tq), KM_PUSHPAGE);\n\tif (tq == NULL)\n\t\treturn (NULL);\n\n\ttq->tq_hp_support = B_FALSE;\n#ifdef HAVE_CPU_HOTPLUG\n\tif (flags & TASKQ_THREADS_CPU_PCT) {\n\t\ttq->tq_hp_support = B_TRUE;\n\t\tif (cpuhp_state_add_instance_nocalls(spl_taskq_cpuhp_state,\n\t\t    &tq->tq_hp_cb_node) != 0) {\n\t\t\tkmem_free(tq, sizeof (*tq));\n\t\t\treturn (NULL);\n\t\t}\n\t}\n#endif\n\n\tspin_lock_init(&tq->tq_lock);\n\tINIT_LIST_HEAD(&tq->tq_thread_list);\n\tINIT_LIST_HEAD(&tq->tq_active_list);\n\ttq->tq_name = kmem_strdup(name);\n\ttq->tq_nactive = 0;\n\ttq->tq_nthreads = 0;\n\ttq->tq_nspawn = 0;\n\ttq->tq_maxthreads = nthreads;\n\ttq->tq_cpu_pct = threads_arg;\n\ttq->tq_pri = pri;\n\ttq->tq_minalloc = minalloc;\n\ttq->tq_maxalloc = maxalloc;\n\ttq->tq_nalloc = 0;\n\ttq->tq_flags = (flags | TASKQ_ACTIVE);\n\ttq->tq_next_id = TASKQID_INITIAL;\n\ttq->tq_lowest_id = TASKQID_INITIAL;\n\ttq->lastshouldstop = 0;\n\tINIT_LIST_HEAD(&tq->tq_free_list);\n\tINIT_LIST_HEAD(&tq->tq_pend_list);\n\tINIT_LIST_HEAD(&tq->tq_prio_list);\n\tINIT_LIST_HEAD(&tq->tq_delay_list);\n\tinit_waitqueue_head(&tq->tq_work_waitq);\n\tinit_waitqueue_head(&tq->tq_wait_waitq);\n\ttq->tq_lock_class = TQ_LOCK_GENERAL;\n\tINIT_LIST_HEAD(&tq->tq_taskqs);\n\n\tif (flags & TASKQ_PREPOPULATE) {\n\t\tspin_lock_irqsave_nested(&tq->tq_lock, irqflags,\n\t\t    tq->tq_lock_class);\n\n\t\tfor (i = 0; i < minalloc; i++)\n\t\t\ttask_done(tq, task_alloc(tq, TQ_PUSHPAGE | TQ_NEW,\n\t\t\t    &irqflags));\n\n\t\tspin_unlock_irqrestore(&tq->tq_lock, irqflags);\n\t}\n\n\tif ((flags & TASKQ_DYNAMIC) && spl_taskq_thread_dynamic)\n\t\tnthreads = 1;\n\n\tfor (i = 0; i < nthreads; i++) {\n\t\ttqt = taskq_thread_create(tq);\n\t\tif (tqt == NULL)\n\t\t\trc = 1;\n\t\telse\n\t\t\tcount++;\n\t}\n\n\t \n\twait_event(tq->tq_wait_waitq, tq->tq_nthreads == count);\n\t \n\ttq->tq_nspawn = 0;\n\n\tif (rc) {\n\t\ttaskq_destroy(tq);\n\t\ttq = NULL;\n\t} else {\n\t\tdown_write(&tq_list_sem);\n\t\ttq->tq_instance = taskq_find_by_name(name) + 1;\n\t\tlist_add_tail(&tq->tq_taskqs, &tq_list);\n\t\tup_write(&tq_list_sem);\n\t}\n\n\treturn (tq);\n}\nEXPORT_SYMBOL(taskq_create);\n\nvoid\ntaskq_destroy(taskq_t *tq)\n{\n\tstruct task_struct *thread;\n\ttaskq_thread_t *tqt;\n\ttaskq_ent_t *t;\n\tunsigned long flags;\n\n\tASSERT(tq);\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\ttq->tq_flags &= ~TASKQ_ACTIVE;\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n#ifdef HAVE_CPU_HOTPLUG\n\tif (tq->tq_hp_support) {\n\t\tVERIFY0(cpuhp_state_remove_instance_nocalls(\n\t\t    spl_taskq_cpuhp_state, &tq->tq_hp_cb_node));\n\t}\n#endif\n\t \n\tif (dynamic_taskq != NULL)\n\t\ttaskq_wait_outstanding(dynamic_taskq, 0);\n\n\ttaskq_wait(tq);\n\n\t \n\tdown_write(&tq_list_sem);\n\tlist_del(&tq->tq_taskqs);\n\tup_write(&tq_list_sem);\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\t \n\twhile (tq->tq_nspawn) {\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t\tschedule_timeout_interruptible(1);\n\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t    tq->tq_lock_class);\n\t}\n\n\t \n\twhile (!list_empty(&tq->tq_thread_list)) {\n\t\ttqt = list_entry(tq->tq_thread_list.next,\n\t\t    taskq_thread_t, tqt_thread_list);\n\t\tthread = tqt->tqt_thread;\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\t\tkthread_stop(thread);\n\n\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t    tq->tq_lock_class);\n\t}\n\n\twhile (!list_empty(&tq->tq_free_list)) {\n\t\tt = list_entry(tq->tq_free_list.next, taskq_ent_t, tqent_list);\n\n\t\tASSERT(!(t->tqent_flags & TQENT_FLAG_PREALLOC));\n\n\t\tlist_del_init(&t->tqent_list);\n\t\ttask_free(tq, t);\n\t}\n\n\tASSERT0(tq->tq_nthreads);\n\tASSERT0(tq->tq_nalloc);\n\tASSERT0(tq->tq_nspawn);\n\tASSERT(list_empty(&tq->tq_thread_list));\n\tASSERT(list_empty(&tq->tq_active_list));\n\tASSERT(list_empty(&tq->tq_free_list));\n\tASSERT(list_empty(&tq->tq_pend_list));\n\tASSERT(list_empty(&tq->tq_prio_list));\n\tASSERT(list_empty(&tq->tq_delay_list));\n\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\tkmem_strfree(tq->tq_name);\n\tkmem_free(tq, sizeof (taskq_t));\n}\nEXPORT_SYMBOL(taskq_destroy);\n\nstatic unsigned int spl_taskq_kick = 0;\n\n \nstatic int\n#ifdef module_param_cb\nparam_set_taskq_kick(const char *val, const struct kernel_param *kp)\n#else\nparam_set_taskq_kick(const char *val, struct kernel_param *kp)\n#endif\n{\n\tint ret;\n\ttaskq_t *tq = NULL;\n\ttaskq_ent_t *t;\n\tunsigned long flags;\n\n\tret = param_set_uint(val, kp);\n\tif (ret < 0 || !spl_taskq_kick)\n\t\treturn (ret);\n\t \n\tspl_taskq_kick = 0;\n\n\tdown_read(&tq_list_sem);\n\tlist_for_each_entry(tq, &tq_list, tq_taskqs) {\n\t\tspin_lock_irqsave_nested(&tq->tq_lock, flags,\n\t\t    tq->tq_lock_class);\n\t\t \n\t\tt = taskq_next_ent(tq);\n\t\tif (t && time_after(jiffies, t->tqent_birth + 5*HZ)) {\n\t\t\t(void) taskq_thread_spawn(tq);\n\t\t\tprintk(KERN_INFO \"spl: Kicked taskq %s/%d\\n\",\n\t\t\t    tq->tq_name, tq->tq_instance);\n\t\t}\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t}\n\tup_read(&tq_list_sem);\n\treturn (ret);\n}\n\n#ifdef module_param_cb\nstatic const struct kernel_param_ops param_ops_taskq_kick = {\n\t.set = param_set_taskq_kick,\n\t.get = param_get_uint,\n};\nmodule_param_cb(spl_taskq_kick, &param_ops_taskq_kick, &spl_taskq_kick, 0644);\n#else\nmodule_param_call(spl_taskq_kick, param_set_taskq_kick, param_get_uint,\n\t&spl_taskq_kick, 0644);\n#endif\nMODULE_PARM_DESC(spl_taskq_kick,\n\t\"Write nonzero to kick stuck taskqs to spawn more threads\");\n\n#ifdef HAVE_CPU_HOTPLUG\n \nstatic int\nspl_taskq_expand(unsigned int cpu, struct hlist_node *node)\n{\n\ttaskq_t *tq = list_entry(node, taskq_t, tq_hp_cb_node);\n\tunsigned long flags;\n\tint err = 0;\n\n\tASSERT(tq);\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\n\tif (!(tq->tq_flags & TASKQ_ACTIVE)) {\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t\treturn (err);\n\t}\n\n\tASSERT(tq->tq_flags & TASKQ_THREADS_CPU_PCT);\n\tint nthreads = MIN(tq->tq_cpu_pct, 100);\n\tnthreads = MAX(((num_online_cpus() + 1) * nthreads) / 100, 1);\n\ttq->tq_maxthreads = nthreads;\n\n\tif (!((tq->tq_flags & TASKQ_DYNAMIC) && spl_taskq_thread_dynamic) &&\n\t    tq->tq_maxthreads > tq->tq_nthreads) {\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t\ttaskq_thread_t *tqt = taskq_thread_create(tq);\n\t\tif (tqt == NULL)\n\t\t\terr = -1;\n\t\treturn (err);\n\t}\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\treturn (err);\n}\n\n \nstatic int\nspl_taskq_prepare_down(unsigned int cpu, struct hlist_node *node)\n{\n\ttaskq_t *tq = list_entry(node, taskq_t, tq_hp_cb_node);\n\tunsigned long flags;\n\n\tASSERT(tq);\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\n\tif (!(tq->tq_flags & TASKQ_ACTIVE))\n\t\tgoto out;\n\n\tASSERT(tq->tq_flags & TASKQ_THREADS_CPU_PCT);\n\tint nthreads = MIN(tq->tq_cpu_pct, 100);\n\tnthreads = MAX(((num_online_cpus()) * nthreads) / 100, 1);\n\ttq->tq_maxthreads = nthreads;\n\n\tif (!((tq->tq_flags & TASKQ_DYNAMIC) && spl_taskq_thread_dynamic) &&\n\t    tq->tq_maxthreads < tq->tq_nthreads) {\n\t\tASSERT3U(tq->tq_maxthreads, ==, tq->tq_nthreads - 1);\n\t\ttaskq_thread_t *tqt = list_entry(tq->tq_thread_list.next,\n\t\t    taskq_thread_t, tqt_thread_list);\n\t\tstruct task_struct *thread = tqt->tqt_thread;\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\t\tkthread_stop(thread);\n\n\t\treturn (0);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\treturn (0);\n}\n#endif\n\nint\nspl_taskq_init(void)\n{\n\tinit_rwsem(&tq_list_sem);\n\ttsd_create(&taskq_tsd, NULL);\n\n#ifdef HAVE_CPU_HOTPLUG\n\tspl_taskq_cpuhp_state = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,\n\t    \"fs/spl_taskq:online\", spl_taskq_expand, spl_taskq_prepare_down);\n#endif\n\n\tsystem_taskq = taskq_create(\"spl_system_taskq\", MAX(boot_ncpus, 64),\n\t    maxclsyspri, boot_ncpus, INT_MAX, TASKQ_PREPOPULATE|TASKQ_DYNAMIC);\n\tif (system_taskq == NULL)\n\t\treturn (-ENOMEM);\n\n\tsystem_delay_taskq = taskq_create(\"spl_delay_taskq\", MAX(boot_ncpus, 4),\n\t    maxclsyspri, boot_ncpus, INT_MAX, TASKQ_PREPOPULATE|TASKQ_DYNAMIC);\n\tif (system_delay_taskq == NULL) {\n#ifdef HAVE_CPU_HOTPLUG\n\t\tcpuhp_remove_multi_state(spl_taskq_cpuhp_state);\n#endif\n\t\ttaskq_destroy(system_taskq);\n\t\treturn (-ENOMEM);\n\t}\n\n\tdynamic_taskq = taskq_create(\"spl_dynamic_taskq\", 1,\n\t    maxclsyspri, boot_ncpus, INT_MAX, TASKQ_PREPOPULATE);\n\tif (dynamic_taskq == NULL) {\n#ifdef HAVE_CPU_HOTPLUG\n\t\tcpuhp_remove_multi_state(spl_taskq_cpuhp_state);\n#endif\n\t\ttaskq_destroy(system_taskq);\n\t\ttaskq_destroy(system_delay_taskq);\n\t\treturn (-ENOMEM);\n\t}\n\n\t \n\tdynamic_taskq->tq_lock_class = TQ_LOCK_DYNAMIC;\n\n\treturn (0);\n}\n\nvoid\nspl_taskq_fini(void)\n{\n\ttaskq_destroy(dynamic_taskq);\n\tdynamic_taskq = NULL;\n\n\ttaskq_destroy(system_delay_taskq);\n\tsystem_delay_taskq = NULL;\n\n\ttaskq_destroy(system_taskq);\n\tsystem_taskq = NULL;\n\n\ttsd_destroy(&taskq_tsd);\n\n#ifdef HAVE_CPU_HOTPLUG\n\tcpuhp_remove_multi_state(spl_taskq_cpuhp_state);\n\tspl_taskq_cpuhp_state = 0;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}