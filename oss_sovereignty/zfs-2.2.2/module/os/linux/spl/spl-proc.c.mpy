{
  "module_name": "spl-proc.c",
  "hash_id": "90f948983056903f986de5a41f7496f6bdcba6a104deb33c254d2b2932fa4a1c",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-proc.c",
  "human_readable_source": " \n\n#include <sys/systeminfo.h>\n#include <sys/kstat.h>\n#include <sys/kmem.h>\n#include <sys/kmem_cache.h>\n#include <sys/vmem.h>\n#include <sys/taskq.h>\n#include <sys/proc.h>\n#include <linux/ctype.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/version.h>\n#include \"zfs_gitrev.h\"\n\n#if defined(CONSTIFY_PLUGIN) && LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)\ntypedef struct ctl_table __no_const spl_ctl_table;\n#else\ntypedef struct ctl_table spl_ctl_table;\n#endif\n\nstatic unsigned long table_min = 0;\nstatic unsigned long table_max = ~0;\n\nstatic struct ctl_table_header *spl_header = NULL;\n#ifndef HAVE_REGISTER_SYSCTL_TABLE\nstatic struct ctl_table_header *spl_kmem = NULL;\nstatic struct ctl_table_header *spl_kstat = NULL;\n#endif\nstatic struct proc_dir_entry *proc_spl = NULL;\nstatic struct proc_dir_entry *proc_spl_kmem = NULL;\nstatic struct proc_dir_entry *proc_spl_kmem_slab = NULL;\nstatic struct proc_dir_entry *proc_spl_taskq_all = NULL;\nstatic struct proc_dir_entry *proc_spl_taskq = NULL;\nstruct proc_dir_entry *proc_spl_kstat = NULL;\n\n#ifdef DEBUG_KMEM\nstatic int\nproc_domemused(struct ctl_table *table, int write,\n    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint rc = 0;\n\tunsigned long val;\n\tspl_ctl_table dummy = *table;\n\n\tdummy.data = &val;\n\tdummy.proc_handler = &proc_dointvec;\n\tdummy.extra1 = &table_min;\n\tdummy.extra2 = &table_max;\n\n\tif (write) {\n\t\t*ppos += *lenp;\n\t} else {\n#ifdef HAVE_ATOMIC64_T\n\t\tval = atomic64_read((atomic64_t *)table->data);\n#else\n\t\tval = atomic_read((atomic_t *)table->data);\n#endif  \n\t\trc = proc_doulongvec_minmax(&dummy, write, buffer, lenp, ppos);\n\t}\n\n\treturn (rc);\n}\n#endif  \n\nstatic int\nproc_doslab(struct ctl_table *table, int write,\n    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint rc = 0;\n\tunsigned long val = 0, mask;\n\tspl_ctl_table dummy = *table;\n\tspl_kmem_cache_t *skc = NULL;\n\n\tdummy.data = &val;\n\tdummy.proc_handler = &proc_dointvec;\n\tdummy.extra1 = &table_min;\n\tdummy.extra2 = &table_max;\n\n\tif (write) {\n\t\t*ppos += *lenp;\n\t} else {\n\t\tdown_read(&spl_kmem_cache_sem);\n\t\tmask = (unsigned long)table->data;\n\n\t\tlist_for_each_entry(skc, &spl_kmem_cache_list, skc_list) {\n\n\t\t\t \n\t\t\tif (!(skc->skc_flags & mask))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tswitch (mask & (KMC_TOTAL | KMC_ALLOC | KMC_MAX)) {\n\t\t\tcase KMC_TOTAL:\n\t\t\t\tval += skc->skc_slab_size * skc->skc_slab_total;\n\t\t\t\tbreak;\n\t\t\tcase KMC_ALLOC:\n\t\t\t\tval += skc->skc_obj_size * skc->skc_obj_alloc;\n\t\t\t\tbreak;\n\t\t\tcase KMC_MAX:\n\t\t\t\tval += skc->skc_obj_size * skc->skc_obj_max;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tup_read(&spl_kmem_cache_sem);\n\t\trc = proc_doulongvec_minmax(&dummy, write, buffer, lenp, ppos);\n\t}\n\n\treturn (rc);\n}\n\nstatic int\nproc_dohostid(struct ctl_table *table, int write,\n    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar *end, str[32];\n\tunsigned long hid;\n\tspl_ctl_table dummy = *table;\n\n\tdummy.data = str;\n\tdummy.maxlen = sizeof (str) - 1;\n\n\tif (!write)\n\t\tsnprintf(str, sizeof (str), \"%lx\",\n\t\t    (unsigned long) zone_get_hostid(NULL));\n\n\t \n\tproc_dostring(&dummy, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\t \n\n\t\thid = simple_strtoul(str, &end, 16);\n\t\tif (str == end)\n\t\t\treturn (-EINVAL);\n\t\tspl_hostid = hid;\n\t}\n\n\treturn (0);\n}\n\nstatic void\ntaskq_seq_show_headers(struct seq_file *f)\n{\n\tseq_printf(f, \"%-25s %5s %5s %5s %5s %5s %5s %12s %5s %10s\\n\",\n\t    \"taskq\", \"act\", \"nthr\", \"spwn\", \"maxt\", \"pri\",\n\t    \"mina\", \"maxa\", \"cura\", \"flags\");\n}\n\n \n#define\tLHEAD_PEND\t0\n#define\tLHEAD_PRIO\t1\n#define\tLHEAD_DELAY\t2\n#define\tLHEAD_WAIT\t3\n#define\tLHEAD_ACTIVE\t4\n#define\tLHEAD_SIZE\t5\n\nstatic unsigned int spl_max_show_tasks = 512;\n \nmodule_param(spl_max_show_tasks, uint, 0644);\nMODULE_PARM_DESC(spl_max_show_tasks, \"Max number of tasks shown in taskq proc\");\n\nstatic int\ntaskq_seq_show_impl(struct seq_file *f, void *p, boolean_t allflag)\n{\n\ttaskq_t *tq = p;\n\ttaskq_thread_t *tqt = NULL;\n\tspl_wait_queue_entry_t *wq;\n\tstruct task_struct *tsk;\n\ttaskq_ent_t *tqe;\n\tchar name[100];\n\tstruct list_head *lheads[LHEAD_SIZE], *lh;\n\tstatic char *list_names[LHEAD_SIZE] =\n\t    {\"pend\", \"prio\", \"delay\", \"wait\", \"active\" };\n\tint i, j, have_lheads = 0;\n\tunsigned long wflags, flags;\n\n\tspin_lock_irqsave_nested(&tq->tq_lock, flags, tq->tq_lock_class);\n\tspin_lock_irqsave(&tq->tq_wait_waitq.lock, wflags);\n\n\t \n\tlheads[LHEAD_PEND] = &tq->tq_pend_list;\n\tlheads[LHEAD_PRIO] = &tq->tq_prio_list;\n\tlheads[LHEAD_DELAY] = &tq->tq_delay_list;\n#ifdef HAVE_WAIT_QUEUE_HEAD_ENTRY\n\tlheads[LHEAD_WAIT] = &tq->tq_wait_waitq.head;\n#else\n\tlheads[LHEAD_WAIT] = &tq->tq_wait_waitq.task_list;\n#endif\n\tlheads[LHEAD_ACTIVE] = &tq->tq_active_list;\n\n\tfor (i = 0; i < LHEAD_SIZE; ++i) {\n\t\tif (list_empty(lheads[i]))\n\t\t\tlheads[i] = NULL;\n\t\telse\n\t\t\t++have_lheads;\n\t}\n\n\t \n\tif (!allflag && !have_lheads) {\n\t\tspin_unlock_irqrestore(&tq->tq_wait_waitq.lock, wflags);\n\t\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\t\treturn (0);\n\t}\n\n\t \n\tif (!lheads[LHEAD_WAIT])\n\t\tspin_unlock_irqrestore(&tq->tq_wait_waitq.lock, wflags);\n\n\t \n\tsnprintf(name, sizeof (name), \"%s/%d\", tq->tq_name, tq->tq_instance);\n\tseq_printf(f, \"%-25s \", name);\n\tseq_printf(f, \"%5d %5d %5d %5d %5d %5d %12d %5d %10x\\n\",\n\t    tq->tq_nactive, tq->tq_nthreads, tq->tq_nspawn,\n\t    tq->tq_maxthreads, tq->tq_pri, tq->tq_minalloc, tq->tq_maxalloc,\n\t    tq->tq_nalloc, tq->tq_flags);\n\n\t \n\tif (lheads[LHEAD_ACTIVE]) {\n\t\tj = 0;\n\t\tlist_for_each_entry(tqt, &tq->tq_active_list, tqt_active_list) {\n\t\t\tif (j == 0)\n\t\t\t\tseq_printf(f, \"\\t%s:\",\n\t\t\t\t    list_names[LHEAD_ACTIVE]);\n\t\t\telse if (j == 2) {\n\t\t\t\tseq_printf(f, \"\\n\\t       \");\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t\tseq_printf(f, \" [%d]%pf(%ps)\",\n\t\t\t    tqt->tqt_thread->pid,\n\t\t\t    tqt->tqt_task->tqent_func,\n\t\t\t    tqt->tqt_task->tqent_arg);\n\t\t\t++j;\n\t\t}\n\t\tseq_printf(f, \"\\n\");\n\t}\n\n\tfor (i = LHEAD_PEND; i <= LHEAD_WAIT; ++i)\n\t\tif (lheads[i]) {\n\t\t\tj = 0;\n\t\t\tlist_for_each(lh, lheads[i]) {\n\t\t\t\tif (spl_max_show_tasks != 0 &&\n\t\t\t\t    j >= spl_max_show_tasks) {\n\t\t\t\t\tseq_printf(f, \"\\n\\t(truncated)\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (i == LHEAD_WAIT) {\n#ifdef HAVE_WAIT_QUEUE_HEAD_ENTRY\n\t\t\t\t\twq = list_entry(lh,\n\t\t\t\t\t    spl_wait_queue_entry_t, entry);\n#else\n\t\t\t\t\twq = list_entry(lh,\n\t\t\t\t\t    spl_wait_queue_entry_t, task_list);\n#endif\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\tseq_printf(f, \"\\t%s:\",\n\t\t\t\t\t\t    list_names[i]);\n\t\t\t\t\telse if (j % 8 == 0)\n\t\t\t\t\t\tseq_printf(f, \"\\n\\t     \");\n\n\t\t\t\t\ttsk = wq->private;\n\t\t\t\t\tseq_printf(f, \" %d\", tsk->pid);\n\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\ttqe = list_entry(lh, taskq_ent_t,\n\t\t\t\t\t    tqent_list);\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\tseq_printf(f, \"\\t%s:\",\n\t\t\t\t\t\t    list_names[i]);\n\t\t\t\t\telse if (j % 2 == 0)\n\t\t\t\t\t\tseq_printf(f, \"\\n\\t     \");\n\n\t\t\t\t\tseq_printf(f, \" %pf(%ps)\",\n\t\t\t\t\t    tqe->tqent_func,\n\t\t\t\t\t    tqe->tqent_arg);\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tseq_printf(f, \"\\n\");\n\t\t}\n\tif (lheads[LHEAD_WAIT])\n\t\tspin_unlock_irqrestore(&tq->tq_wait_waitq.lock, wflags);\n\tspin_unlock_irqrestore(&tq->tq_lock, flags);\n\n\treturn (0);\n}\n\nstatic int\ntaskq_all_seq_show(struct seq_file *f, void *p)\n{\n\treturn (taskq_seq_show_impl(f, p, B_TRUE));\n}\n\nstatic int\ntaskq_seq_show(struct seq_file *f, void *p)\n{\n\treturn (taskq_seq_show_impl(f, p, B_FALSE));\n}\n\nstatic void *\ntaskq_seq_start(struct seq_file *f, loff_t *pos)\n{\n\tstruct list_head *p;\n\tloff_t n = *pos;\n\n\tdown_read(&tq_list_sem);\n\tif (!n)\n\t\ttaskq_seq_show_headers(f);\n\n\tp = tq_list.next;\n\twhile (n--) {\n\t\tp = p->next;\n\t\tif (p == &tq_list)\n\t\treturn (NULL);\n\t}\n\n\treturn (list_entry(p, taskq_t, tq_taskqs));\n}\n\nstatic void *\ntaskq_seq_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\ttaskq_t *tq = p;\n\n\t++*pos;\n\treturn ((tq->tq_taskqs.next == &tq_list) ?\n\t    NULL : list_entry(tq->tq_taskqs.next, taskq_t, tq_taskqs));\n}\n\nstatic void\nslab_seq_show_headers(struct seq_file *f)\n{\n\tseq_printf(f,\n\t    \"--------------------- cache ----------\"\n\t    \"---------------------------------------------  \"\n\t    \"----- slab ------  \"\n\t    \"---- object -----  \"\n\t    \"--- emergency ---\\n\");\n\tseq_printf(f,\n\t    \"name                                  \"\n\t    \"  flags      size     alloc slabsize  objsize  \"\n\t    \"total alloc   max  \"\n\t    \"total alloc   max  \"\n\t    \"dlock alloc   max\\n\");\n}\n\nstatic int\nslab_seq_show(struct seq_file *f, void *p)\n{\n\tspl_kmem_cache_t *skc = p;\n\n\tASSERT(skc->skc_magic == SKC_MAGIC);\n\n\tif (skc->skc_flags & KMC_SLAB) {\n\t\t \n\t\tspin_lock(&skc->skc_lock);\n\t\tuint64_t objs_allocated =\n\t\t    percpu_counter_sum(&skc->skc_linux_alloc);\n\t\tseq_printf(f, \"%-36s  \", skc->skc_name);\n\t\tseq_printf(f, \"0x%05lx %9s %9lu %8s %8u  \"\n\t\t    \"%5s %5s %5s  %5s %5lu %5s  %5s %5s %5s\\n\",\n\t\t    (long unsigned)skc->skc_flags,\n\t\t    \"-\",\n\t\t    (long unsigned)(skc->skc_obj_size * objs_allocated),\n\t\t    \"-\",\n\t\t    (unsigned)skc->skc_obj_size,\n\t\t    \"-\", \"-\", \"-\", \"-\",\n\t\t    (long unsigned)objs_allocated,\n\t\t    \"-\", \"-\", \"-\", \"-\");\n\t\tspin_unlock(&skc->skc_lock);\n\t\treturn (0);\n\t}\n\n\tspin_lock(&skc->skc_lock);\n\tseq_printf(f, \"%-36s  \", skc->skc_name);\n\tseq_printf(f, \"0x%05lx %9lu %9lu %8u %8u  \"\n\t    \"%5lu %5lu %5lu  %5lu %5lu %5lu  %5lu %5lu %5lu\\n\",\n\t    (long unsigned)skc->skc_flags,\n\t    (long unsigned)(skc->skc_slab_size * skc->skc_slab_total),\n\t    (long unsigned)(skc->skc_obj_size * skc->skc_obj_alloc),\n\t    (unsigned)skc->skc_slab_size,\n\t    (unsigned)skc->skc_obj_size,\n\t    (long unsigned)skc->skc_slab_total,\n\t    (long unsigned)skc->skc_slab_alloc,\n\t    (long unsigned)skc->skc_slab_max,\n\t    (long unsigned)skc->skc_obj_total,\n\t    (long unsigned)skc->skc_obj_alloc,\n\t    (long unsigned)skc->skc_obj_max,\n\t    (long unsigned)skc->skc_obj_deadlock,\n\t    (long unsigned)skc->skc_obj_emergency,\n\t    (long unsigned)skc->skc_obj_emergency_max);\n\tspin_unlock(&skc->skc_lock);\n\treturn (0);\n}\n\nstatic void *\nslab_seq_start(struct seq_file *f, loff_t *pos)\n{\n\tstruct list_head *p;\n\tloff_t n = *pos;\n\n\tdown_read(&spl_kmem_cache_sem);\n\tif (!n)\n\t\tslab_seq_show_headers(f);\n\n\tp = spl_kmem_cache_list.next;\n\twhile (n--) {\n\t\tp = p->next;\n\t\tif (p == &spl_kmem_cache_list)\n\t\t\treturn (NULL);\n\t}\n\n\treturn (list_entry(p, spl_kmem_cache_t, skc_list));\n}\n\nstatic void *\nslab_seq_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\tspl_kmem_cache_t *skc = p;\n\n\t++*pos;\n\treturn ((skc->skc_list.next == &spl_kmem_cache_list) ?\n\t    NULL : list_entry(skc->skc_list.next, spl_kmem_cache_t, skc_list));\n}\n\nstatic void\nslab_seq_stop(struct seq_file *f, void *v)\n{\n\tup_read(&spl_kmem_cache_sem);\n}\n\nstatic const struct seq_operations slab_seq_ops = {\n\t.show  = slab_seq_show,\n\t.start = slab_seq_start,\n\t.next  = slab_seq_next,\n\t.stop  = slab_seq_stop,\n};\n\nstatic int\nproc_slab_open(struct inode *inode, struct file *filp)\n{\n\treturn (seq_open(filp, &slab_seq_ops));\n}\n\nstatic const kstat_proc_op_t proc_slab_operations = {\n#ifdef HAVE_PROC_OPS_STRUCT\n\t.proc_open\t= proc_slab_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n#else\n\t.open\t\t= proc_slab_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n#endif\n};\n\nstatic void\ntaskq_seq_stop(struct seq_file *f, void *v)\n{\n\tup_read(&tq_list_sem);\n}\n\nstatic const struct seq_operations taskq_all_seq_ops = {\n\t.show\t= taskq_all_seq_show,\n\t.start\t= taskq_seq_start,\n\t.next\t= taskq_seq_next,\n\t.stop\t= taskq_seq_stop,\n};\n\nstatic const struct seq_operations taskq_seq_ops = {\n\t.show\t= taskq_seq_show,\n\t.start\t= taskq_seq_start,\n\t.next\t= taskq_seq_next,\n\t.stop\t= taskq_seq_stop,\n};\n\nstatic int\nproc_taskq_all_open(struct inode *inode, struct file *filp)\n{\n\treturn (seq_open(filp, &taskq_all_seq_ops));\n}\n\nstatic int\nproc_taskq_open(struct inode *inode, struct file *filp)\n{\n\treturn (seq_open(filp, &taskq_seq_ops));\n}\n\nstatic const kstat_proc_op_t proc_taskq_all_operations = {\n#ifdef HAVE_PROC_OPS_STRUCT\n\t.proc_open\t= proc_taskq_all_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n#else\n\t.open\t\t= proc_taskq_all_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n#endif\n};\n\nstatic const kstat_proc_op_t proc_taskq_operations = {\n#ifdef HAVE_PROC_OPS_STRUCT\n\t.proc_open\t= proc_taskq_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n#else\n\t.open\t\t= proc_taskq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n#endif\n};\n\nstatic struct ctl_table spl_kmem_table[] = {\n#ifdef DEBUG_KMEM\n\t{\n\t\t.procname\t= \"kmem_used\",\n\t\t.data\t\t= &kmem_alloc_used,\n#ifdef HAVE_ATOMIC64_T\n\t\t.maxlen\t\t= sizeof (atomic64_t),\n#else\n\t\t.maxlen\t\t= sizeof (atomic_t),\n#endif  \n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= &proc_domemused,\n\t},\n\t{\n\t\t.procname\t= \"kmem_max\",\n\t\t.data\t\t= &kmem_alloc_max,\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.extra1\t\t= &table_min,\n\t\t.extra2\t\t= &table_max,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= &proc_doulongvec_minmax,\n\t},\n#endif  \n\t{\n\t\t.procname\t= \"slab_kvmem_total\",\n\t\t.data\t\t= (void *)(KMC_KVMEM | KMC_TOTAL),\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.extra1\t\t= &table_min,\n\t\t.extra2\t\t= &table_max,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= &proc_doslab,\n\t},\n\t{\n\t\t.procname\t= \"slab_kvmem_alloc\",\n\t\t.data\t\t= (void *)(KMC_KVMEM | KMC_ALLOC),\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.extra1\t\t= &table_min,\n\t\t.extra2\t\t= &table_max,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= &proc_doslab,\n\t},\n\t{\n\t\t.procname\t= \"slab_kvmem_max\",\n\t\t.data\t\t= (void *)(KMC_KVMEM | KMC_MAX),\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.extra1\t\t= &table_min,\n\t\t.extra2\t\t= &table_max,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= &proc_doslab,\n\t},\n\t{},\n};\n\nstatic struct ctl_table spl_kstat_table[] = {\n\t{},\n};\n\nstatic struct ctl_table spl_table[] = {\n\t \n\t{\n\t\t.procname\t= \"gitrev\",\n\t\t.data\t\t= (char *)ZFS_META_GITREV,\n\t\t.maxlen\t\t= sizeof (ZFS_META_GITREV),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= &proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"hostid\",\n\t\t.data\t\t= &spl_hostid,\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &proc_dohostid,\n\t},\n#ifdef HAVE_REGISTER_SYSCTL_TABLE\n\t{\n\t\t.procname\t= \"kmem\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= spl_kmem_table,\n\t},\n\t{\n\t\t.procname\t= \"kstat\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= spl_kstat_table,\n\t},\n#endif\n\t{},\n};\n\n#ifdef HAVE_REGISTER_SYSCTL_TABLE\nstatic struct ctl_table spl_dir[] = {\n\t{\n\t\t.procname\t= \"spl\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= spl_table,\n\t},\n\t{}\n};\n\nstatic struct ctl_table spl_root[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= spl_dir,\n\t},\n\t{}\n};\n#endif\n\nstatic void spl_proc_cleanup(void)\n{\n\tremove_proc_entry(\"kstat\", proc_spl);\n\tremove_proc_entry(\"slab\", proc_spl_kmem);\n\tremove_proc_entry(\"kmem\", proc_spl);\n\tremove_proc_entry(\"taskq-all\", proc_spl);\n\tremove_proc_entry(\"taskq\", proc_spl);\n\tremove_proc_entry(\"spl\", NULL);\n\n#ifndef HAVE_REGISTER_SYSCTL_TABLE\n\tif (spl_kstat) {\n\t\tunregister_sysctl_table(spl_kstat);\n\t\tspl_kstat = NULL;\n\t}\n\tif (spl_kmem) {\n\t\tunregister_sysctl_table(spl_kmem);\n\t\tspl_kmem = NULL;\n\t}\n#endif\n\tif (spl_header) {\n\t\tunregister_sysctl_table(spl_header);\n\t\tspl_header = NULL;\n\t}\n}\n\nint\nspl_proc_init(void)\n{\n\tint rc = 0;\n\n#ifdef HAVE_REGISTER_SYSCTL_TABLE\n\tspl_header = register_sysctl_table(spl_root);\n\tif (spl_header == NULL)\n\t\treturn (-EUNATCH);\n#else\n\tspl_header = register_sysctl(\"kernel/spl\", spl_table);\n\tif (spl_header == NULL)\n\t\treturn (-EUNATCH);\n\n\tspl_kmem = register_sysctl(\"kernel/spl/kmem\", spl_kmem_table);\n\tif (spl_kmem == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n\tspl_kstat = register_sysctl(\"kernel/spl/kstat\", spl_kstat_table);\n\tif (spl_kstat == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n#endif\n\n\tproc_spl = proc_mkdir(\"spl\", NULL);\n\tif (proc_spl == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tproc_spl_taskq_all = proc_create_data(\"taskq-all\", 0444, proc_spl,\n\t    &proc_taskq_all_operations, NULL);\n\tif (proc_spl_taskq_all == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tproc_spl_taskq = proc_create_data(\"taskq\", 0444, proc_spl,\n\t    &proc_taskq_operations, NULL);\n\tif (proc_spl_taskq == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tproc_spl_kmem = proc_mkdir(\"kmem\", proc_spl);\n\tif (proc_spl_kmem == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tproc_spl_kmem_slab = proc_create_data(\"slab\", 0444, proc_spl_kmem,\n\t    &proc_slab_operations, NULL);\n\tif (proc_spl_kmem_slab == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\n\n\tproc_spl_kstat = proc_mkdir(\"kstat\", proc_spl);\n\tif (proc_spl_kstat == NULL) {\n\t\trc = -EUNATCH;\n\t\tgoto out;\n\t}\nout:\n\tif (rc)\n\t\tspl_proc_cleanup();\n\n\treturn (rc);\n}\n\nvoid\nspl_proc_fini(void)\n{\n\tspl_proc_cleanup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}