{
  "module_name": "spl-thread.c",
  "hash_id": "a1c709a20764b7be1a54613b472435621ec7406e9afa8d8555adf58e6937c320",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-thread.c",
  "human_readable_source": " \n\n#include <sys/thread.h>\n#include <sys/kmem.h>\n#include <sys/tsd.h>\n\n \ntypedef struct thread_priv_s {\n\tunsigned long tp_magic;\t\t \n\tint tp_name_size;\t\t \n\tchar *tp_name;\t\t\t \n\tvoid (*tp_func)(void *);\t \n\tvoid *tp_args;\t\t\t \n\tsize_t tp_len;\t\t\t \n\tint tp_state;\t\t\t \n\tpri_t tp_pri;\t\t\t \n} thread_priv_t;\n\nstatic int\nthread_generic_wrapper(void *arg)\n{\n\tthread_priv_t *tp = (thread_priv_t *)arg;\n\tvoid (*func)(void *);\n\tvoid *args;\n\n\tASSERT(tp->tp_magic == TP_MAGIC);\n\tfunc = tp->tp_func;\n\targs = tp->tp_args;\n\tset_current_state(tp->tp_state);\n\tset_user_nice((kthread_t *)current, PRIO_TO_NICE(tp->tp_pri));\n\tkmem_free(tp->tp_name, tp->tp_name_size);\n\tkmem_free(tp, sizeof (thread_priv_t));\n\n\tif (func)\n\t\tfunc(args);\n\n\treturn (0);\n}\n\n \nkthread_t *\n__thread_create(caddr_t stk, size_t  stksize, thread_func_t func,\n    const char *name, void *args, size_t len, proc_t *pp, int state, pri_t pri)\n{\n\tthread_priv_t *tp;\n\tstruct task_struct *tsk;\n\tchar *p;\n\n\t \n\t \n\tASSERT(stk == NULL);\n\n\ttp = kmem_alloc(sizeof (thread_priv_t), KM_PUSHPAGE);\n\tif (tp == NULL)\n\t\treturn (NULL);\n\n\ttp->tp_magic = TP_MAGIC;\n\ttp->tp_name_size = strlen(name) + 1;\n\n\ttp->tp_name = kmem_alloc(tp->tp_name_size, KM_PUSHPAGE);\n\tif (tp->tp_name == NULL) {\n\t\tkmem_free(tp, sizeof (thread_priv_t));\n\t\treturn (NULL);\n\t}\n\n\tstrlcpy(tp->tp_name, name, tp->tp_name_size);\n\n\t \n\tp = strstr(tp->tp_name, \"_thread\");\n\tif (p)\n\t\tp[0] = '\\0';\n\n\ttp->tp_func  = func;\n\ttp->tp_args  = args;\n\ttp->tp_len   = len;\n\ttp->tp_state = state;\n\ttp->tp_pri   = pri;\n\n\ttsk = spl_kthread_create(thread_generic_wrapper, (void *)tp,\n\t    \"%s\", tp->tp_name);\n\tif (IS_ERR(tsk))\n\t\treturn (NULL);\n\n\twake_up_process(tsk);\n\treturn ((kthread_t *)tsk);\n}\nEXPORT_SYMBOL(__thread_create);\n\n \nstruct task_struct *\nspl_kthread_create(int (*func)(void *), void *data, const char namefmt[], ...)\n{\n\tstruct task_struct *tsk;\n\tva_list args;\n\tchar name[TASK_COMM_LEN];\n\n\tva_start(args, namefmt);\n\tvsnprintf(name, sizeof (name), namefmt, args);\n\tva_end(args);\n\tdo {\n\t\ttsk = kthread_create(func, data, \"%s\", name);\n\t\tif (IS_ERR(tsk)) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (PTR_ERR(tsk) == -ENOMEM)\n\t\t\t\tcontinue;\n\t\t\treturn (NULL);\n\t\t} else {\n\t\t\treturn (tsk);\n\t\t}\n\t} while (1);\n}\nEXPORT_SYMBOL(spl_kthread_create);\n\n \nint\nissig(int why)\n{\n\tASSERT(why == FORREAL || why == JUSTLOOKING);\n\n\tif (!signal_pending(current))\n\t\treturn (0);\n\n\tif (why != FORREAL)\n\t\treturn (1);\n\n\tstruct task_struct *task = current;\n\tspl_kernel_siginfo_t __info;\n\tsigset_t set;\n\tsiginitsetinv(&set, 1ULL << (SIGSTOP - 1) | 1ULL << (SIGTSTP - 1));\n\tsigorsets(&set, &task->blocked, &set);\n\n\tspin_lock_irq(&task->sighand->siglock);\n#ifdef HAVE_DEQUEUE_SIGNAL_4ARG\n\tenum pid_type __type;\n\tif (dequeue_signal(task, &set, &__info, &__type) != 0) {\n#else\n\tif (dequeue_signal(task, &set, &__info) != 0) {\n#endif\n#ifdef HAVE_SIGNAL_STOP\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\tkernel_signal_stop();\n#else\n\t\tif (current->jobctl & JOBCTL_STOP_DEQUEUED)\n\t\t\tspl_set_special_state(TASK_STOPPED);\n\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\tschedule();\n#endif\n\t\treturn (0);\n\t}\n\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn (1);\n}\n\nEXPORT_SYMBOL(issig);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}