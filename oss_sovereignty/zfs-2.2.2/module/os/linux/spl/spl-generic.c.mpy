{
  "module_name": "spl-generic.c",
  "hash_id": "aebc5f4e3dfd59151722b9e79e44c2ea1d58ff49ed14170a056128842ae16c5d",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-generic.c",
  "human_readable_source": " \n\n#include <sys/isa_defs.h>\n#include <sys/sysmacros.h>\n#include <sys/systeminfo.h>\n#include <sys/vmsystm.h>\n#include <sys/kmem.h>\n#include <sys/kmem_cache.h>\n#include <sys/vmem.h>\n#include <sys/mutex.h>\n#include <sys/rwlock.h>\n#include <sys/taskq.h>\n#include <sys/tsd.h>\n#include <sys/zmod.h>\n#include <sys/debug.h>\n#include <sys/proc.h>\n#include <sys/kstat.h>\n#include <sys/file.h>\n#include <sys/sunddi.h>\n#include <linux/ctype.h>\n#include <sys/disp.h>\n#include <sys/random.h>\n#include <sys/string.h>\n#include <linux/kmod.h>\n#include <linux/mod_compat.h>\n#include <sys/cred.h>\n#include <sys/vnode.h>\n#include <sys/misc.h>\n#include <linux/mod_compat.h>\n\nunsigned long spl_hostid = 0;\nEXPORT_SYMBOL(spl_hostid);\n\n \nmodule_param(spl_hostid, ulong, 0644);\nMODULE_PARM_DESC(spl_hostid, \"The system hostid.\");\n\nproc_t p0;\nEXPORT_SYMBOL(p0);\n\n \nstatic void __percpu *spl_pseudo_entropy;\n\n \n\nstatic inline uint64_t rotl(const uint64_t x, int k)\n{\n\treturn ((x << k) | (x >> (64 - k)));\n}\n\nstatic inline uint64_t\nspl_rand_next(uint64_t *s)\n{\n\tconst uint64_t result = rotl(s[0] + s[3], 23) + s[0];\n\n\tconst uint64_t t = s[1] << 17;\n\n\ts[2] ^= s[0];\n\ts[3] ^= s[1];\n\ts[1] ^= s[2];\n\ts[0] ^= s[3];\n\n\ts[2] ^= t;\n\n\ts[3] = rotl(s[3], 45);\n\n\treturn (result);\n}\n\nstatic inline void\nspl_rand_jump(uint64_t *s)\n{\n\tstatic const uint64_t JUMP[] = { 0x180ec6d33cfd0aba,\n\t    0xd5a61266f0c9392c, 0xa9582618e03fc9aa, 0x39abdc4529b1661c };\n\n\tuint64_t s0 = 0;\n\tuint64_t s1 = 0;\n\tuint64_t s2 = 0;\n\tuint64_t s3 = 0;\n\tint i, b;\n\tfor (i = 0; i < sizeof (JUMP) / sizeof (*JUMP); i++)\n\t\tfor (b = 0; b < 64; b++) {\n\t\t\tif (JUMP[i] & 1ULL << b) {\n\t\t\t\ts0 ^= s[0];\n\t\t\t\ts1 ^= s[1];\n\t\t\t\ts2 ^= s[2];\n\t\t\t\ts3 ^= s[3];\n\t\t\t}\n\t\t\t(void) spl_rand_next(s);\n\t\t}\n\n\ts[0] = s0;\n\ts[1] = s1;\n\ts[2] = s2;\n\ts[3] = s3;\n}\n\nint\nrandom_get_pseudo_bytes(uint8_t *ptr, size_t len)\n{\n\tuint64_t *xp, s[4];\n\n\tASSERT(ptr);\n\n\txp = get_cpu_ptr(spl_pseudo_entropy);\n\n\ts[0] = xp[0];\n\ts[1] = xp[1];\n\ts[2] = xp[2];\n\ts[3] = xp[3];\n\n\twhile (len) {\n\t\tunion {\n\t\t\tuint64_t ui64;\n\t\t\tuint8_t byte[sizeof (uint64_t)];\n\t\t}entropy;\n\t\tint i = MIN(len, sizeof (uint64_t));\n\n\t\tlen -= i;\n\t\tentropy.ui64 = spl_rand_next(s);\n\n\t\t \n\t\twhile (i--)\n#ifdef _ZFS_BIG_ENDIAN\n\t\t\t*ptr++ = entropy.byte[i];\n#else\n\t\t\t*ptr++ = entropy.byte[7 - i];\n#endif\n\t}\n\n\txp[0] = s[0];\n\txp[1] = s[1];\n\txp[2] = s[2];\n\txp[3] = s[3];\n\n\tput_cpu_ptr(spl_pseudo_entropy);\n\n\treturn (0);\n}\n\n\nEXPORT_SYMBOL(random_get_pseudo_bytes);\n\n#if BITS_PER_LONG == 32\n\n \n\n \nstatic int\nnlz64(uint64_t x)\n{\n\tregister int n = 0;\n\n\tif (x == 0)\n\t\treturn (64);\n\n\tif (x <= 0x00000000FFFFFFFFULL) { n = n + 32; x = x << 32; }\n\tif (x <= 0x0000FFFFFFFFFFFFULL) { n = n + 16; x = x << 16; }\n\tif (x <= 0x00FFFFFFFFFFFFFFULL) { n = n +  8; x = x <<  8; }\n\tif (x <= 0x0FFFFFFFFFFFFFFFULL) { n = n +  4; x = x <<  4; }\n\tif (x <= 0x3FFFFFFFFFFFFFFFULL) { n = n +  2; x = x <<  2; }\n\tif (x <= 0x7FFFFFFFFFFFFFFFULL) { n = n +  1; }\n\n\treturn (n);\n}\n\n \nstatic inline uint64_t\n__div_u64(uint64_t u, uint32_t v)\n{\n\t(void) do_div(u, v);\n\treturn (u);\n}\n\n \n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmissing-prototypes\"\n#endif\n\n \nuint64_t\n__udivdi3(uint64_t u, uint64_t v)\n{\n\tuint64_t u0, u1, v1, q0, q1, k;\n\tint n;\n\n\tif (v >> 32 == 0) {\t\t\t \n\t\tif (u >> 32 < v) {\t\t \n\t\t\treturn (__div_u64(u, v));  \n\t\t} else {\t\t\t \n\t\t\tu1 = u >> 32;\t\t \n\t\t\tu0 = u & 0xFFFFFFFF;\n\t\t\tq1 = __div_u64(u1, v);\t \n\t\t\tk  = u1 - q1 * v;\t \n\t\t\tu0 += (k << 32);\n\t\t\tq0 = __div_u64(u0, v);\t \n\t\t\treturn ((q1 << 32) + q0);\n\t\t}\n\t} else {\t\t\t\t \n\t\tn = nlz64(v);\t\t\t \n\t\tv1 = (v << n) >> 32;\t\t \n\t\tu1 = u >> 1;\t\t\t \n\t\tq1 = __div_u64(u1, v1);\t\t \n\t\tq0 = (q1 << n) >> 31;\t\t \n\t\t\t\t\t\t \n\t\tif (q0 != 0)\t\t\t \n\t\t\tq0 = q0 - 1;\t\t \n\t\tif ((u - q0 * v) >= v)\n\t\t\tq0 = q0 + 1;\t\t \n\n\t\treturn (q0);\n\t}\n}\nEXPORT_SYMBOL(__udivdi3);\n\n#ifndef abs64\n \n#define\tabs64(x)\t({ uint64_t t = (x) >> 63; ((x) ^ t) - t; })\n#endif\n\n \nint64_t\n__divdi3(int64_t u, int64_t v)\n{\n\tint64_t q, t;\n\tq = __udivdi3(abs64(u), abs64(v));\n\tt = (u ^ v) >> 63;\t \n\treturn ((q ^ t) - t);\t \n}\nEXPORT_SYMBOL(__divdi3);\n\n \nuint64_t\n__umoddi3(uint64_t dividend, uint64_t divisor)\n{\n\treturn (dividend - (divisor * __udivdi3(dividend, divisor)));\n}\nEXPORT_SYMBOL(__umoddi3);\n\n \nint64_t\n__moddi3(int64_t n, int64_t d)\n{\n\tint64_t q;\n\tboolean_t nn = B_FALSE;\n\n\tif (n < 0) {\n\t\tnn = B_TRUE;\n\t\tn = -n;\n\t}\n\tif (d < 0)\n\t\td = -d;\n\n\tq = __umoddi3(n, d);\n\n\treturn (nn ? -q : q);\n}\nEXPORT_SYMBOL(__moddi3);\n\n \nuint64_t\n__udivmoddi4(uint64_t n, uint64_t d, uint64_t *r)\n{\n\tuint64_t q = __udivdi3(n, d);\n\tif (r)\n\t\t*r = n - d * q;\n\treturn (q);\n}\nEXPORT_SYMBOL(__udivmoddi4);\n\n \nint64_t\n__divmoddi4(int64_t n, int64_t d, int64_t *r)\n{\n\tint64_t q, rr;\n\tboolean_t nn = B_FALSE;\n\tboolean_t nd = B_FALSE;\n\tif (n < 0) {\n\t\tnn = B_TRUE;\n\t\tn = -n;\n\t}\n\tif (d < 0) {\n\t\tnd = B_TRUE;\n\t\td = -d;\n\t}\n\n\tq = __udivmoddi4(n, d, (uint64_t *)&rr);\n\n\tif (nn != nd)\n\t\tq = -q;\n\tif (nn)\n\t\trr = -rr;\n\tif (r)\n\t\t*r = rr;\n\treturn (q);\n}\nEXPORT_SYMBOL(__divmoddi4);\n\n#if defined(__arm) || defined(__arm__)\n \nvoid\n__aeabi_uldivmod(uint64_t u, uint64_t v)\n{\n\tuint64_t res;\n\tuint64_t mod;\n\n\tres = __udivdi3(u, v);\n\tmod = __umoddi3(u, v);\n\t{\n\t\tregister uint32_t r0 asm(\"r0\") = (res & 0xFFFFFFFF);\n\t\tregister uint32_t r1 asm(\"r1\") = (res >> 32);\n\t\tregister uint32_t r2 asm(\"r2\") = (mod & 0xFFFFFFFF);\n\t\tregister uint32_t r3 asm(\"r3\") = (mod >> 32);\n\n\t\tasm volatile(\"\"\n\t\t    : \"+r\"(r0), \"+r\"(r1), \"+r\"(r2), \"+r\"(r3)   \n\t\t    : \"r\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3));     \n\n\t\treturn;  \n\t}\n}\nEXPORT_SYMBOL(__aeabi_uldivmod);\n\nvoid\n__aeabi_ldivmod(int64_t u, int64_t v)\n{\n\tint64_t res;\n\tuint64_t mod;\n\n\tres =  __divdi3(u, v);\n\tmod = __umoddi3(u, v);\n\t{\n\t\tregister uint32_t r0 asm(\"r0\") = (res & 0xFFFFFFFF);\n\t\tregister uint32_t r1 asm(\"r1\") = (res >> 32);\n\t\tregister uint32_t r2 asm(\"r2\") = (mod & 0xFFFFFFFF);\n\t\tregister uint32_t r3 asm(\"r3\") = (mod >> 32);\n\n\t\tasm volatile(\"\"\n\t\t    : \"+r\"(r0), \"+r\"(r1), \"+r\"(r2), \"+r\"(r3)   \n\t\t    : \"r\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3));     \n\n\t\treturn;  \n\t}\n}\nEXPORT_SYMBOL(__aeabi_ldivmod);\n#endif  \n\n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\n#endif  \n\n \nint ddi_strtol(const char *, char **, int, long *);\nint ddi_strtoull(const char *, char **, int, unsigned long long *);\nint ddi_strtoll(const char *, char **, int, long long *);\n\n#define\tdefine_ddi_strtox(type, valtype)\t\t\t\t\\\nint ddi_strto##type(const char *str, char **endptr,\t\t\t\\\n    int base, valtype *result)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tvaltype last_value, value = 0;\t\t\t\t\t\\\n\tchar *ptr = (char *)str;\t\t\t\t\t\\\n\tint digit, minus = 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (strchr(\" \\t\\n\\r\\f\", *ptr))\t\t\t\t\\\n\t\t++ptr;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (strlen(ptr) == 0)\t\t\t\t\t\t\\\n\t\treturn (EINVAL);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tswitch (*ptr) {\t\t\t\t\t\t\t\\\n\tcase '-':\t\t\t\t\t\t\t\\\n\t\tminus = 1;\t\t\t\t\t\t\\\n\t\tzfs_fallthrough;\t\t\t\t\t\\\n\tcase '+':\t\t\t\t\t\t\t\\\n\t\t++ptr;\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tif (!base) {\t\t\t\t\t\t\t\\\n\t\tif (str[0] == '0') {\t\t\t\t\t\\\n\t\t\tif (tolower(str[1]) == 'x' && isxdigit(str[2])) { \\\n\t\t\t\tbase = 16;  \t\t\t\\\n\t\t\t\tptr += 2;\t\t\t\t\\\n\t\t\t} else if (str[1] >= '0' && str[1] < '8') {\t\\\n\t\t\t\tbase = 8;  \t\t\t\\\n\t\t\t\tptr += 1;\t\t\t\t\\\n\t\t\t} else {\t\t\t\t\t\\\n\t\t\t\treturn (EINVAL);\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\tbase = 10;  \t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (isdigit(*ptr))\t\t\t\t\t\\\n\t\t\tdigit = *ptr - '0';\t\t\t\t\\\n\t\telse if (isalpha(*ptr))\t\t\t\t\t\\\n\t\t\tdigit = tolower(*ptr) - 'a' + 10;\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (digit >= base)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tlast_value = value;\t\t\t\t\t\\\n\t\tvalue = value * base + digit;\t\t\t\t\\\n\t\tif (last_value > value)  \t\t\t\\\n\t\t\treturn (ERANGE);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tptr++;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t*result = minus ? -value : value;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (endptr)\t\t\t\t\t\t\t\\\n\t\t*endptr = ptr;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn (0);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\ndefine_ddi_strtox(l, long)\ndefine_ddi_strtox(ull, unsigned long long)\ndefine_ddi_strtox(ll, long long)\n\nEXPORT_SYMBOL(ddi_strtol);\nEXPORT_SYMBOL(ddi_strtoll);\nEXPORT_SYMBOL(ddi_strtoull);\n\nint\nddi_copyin(const void *from, void *to, size_t len, int flags)\n{\n\t \n\tif (flags & FKIOCTL) {\n\t\tmemcpy(to, from, len);\n\t\treturn (0);\n\t}\n\n\treturn (copyin(from, to, len));\n}\nEXPORT_SYMBOL(ddi_copyin);\n\n#define\tdefine_spl_param(type, fmt)\t\t\t\t\t\\\nint\t\t\t\t\t\t\t\t\t\\\nspl_param_get_##type(char *buf, zfs_kernel_param_t *kp)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (scnprintf(buf, PAGE_SIZE, fmt \"\\n\",\t\t\t\\\n\t    *(type *)kp->arg));\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nint\t\t\t\t\t\t\t\t\t\\\nspl_param_set_##type(const char *buf, zfs_kernel_param_t *kp)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (kstrto##type(buf, 0, (type *)kp->arg));\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nconst struct kernel_param_ops spl_param_ops_##type = {\t\t\t\\\n\t.set = spl_param_set_##type,\t\t\t\t\t\\\n\t.get = spl_param_get_##type,\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(spl_param_get_##type);\t\t\t\t\t\\\nEXPORT_SYMBOL(spl_param_set_##type);\t\t\t\t\t\\\nEXPORT_SYMBOL(spl_param_ops_##type);\n\ndefine_spl_param(s64, \"%lld\")\ndefine_spl_param(u64, \"%llu\")\n\n \nvoid\nspl_signal_kobj_evt(struct block_device *bdev)\n{\n#if defined(HAVE_BDEV_KOBJ) || defined(HAVE_PART_TO_DEV)\n#ifdef HAVE_BDEV_KOBJ\n\tstruct kobject *disk_kobj = bdev_kobj(bdev);\n#else\n\tstruct kobject *disk_kobj = &part_to_dev(bdev->bd_part)->kobj;\n#endif\n\tif (disk_kobj) {\n\t\tint ret = kobject_uevent(disk_kobj, KOBJ_CHANGE);\n\t\tif (ret) {\n\t\t\tpr_warn(\"ZFS: Sending event '%d' to kobject: '%s'\"\n\t\t\t    \" (%p): failed(ret:%d)\\n\", KOBJ_CHANGE,\n\t\t\t    kobject_name(disk_kobj), disk_kobj, ret);\n\t\t}\n\t}\n#else\n \n#error \"Unsupported kernel: unable to get struct kobj from bdev\"\n#endif\n}\nEXPORT_SYMBOL(spl_signal_kobj_evt);\n\nint\nddi_copyout(const void *from, void *to, size_t len, int flags)\n{\n\t \n\tif (flags & FKIOCTL) {\n\t\tmemcpy(to, from, len);\n\t\treturn (0);\n\t}\n\n\treturn (copyout(from, to, len));\n}\nEXPORT_SYMBOL(ddi_copyout);\n\nstatic ssize_t\nspl_kernel_read(struct file *file, void *buf, size_t count, loff_t *pos)\n{\n#if defined(HAVE_KERNEL_READ_PPOS)\n\treturn (kernel_read(file, buf, count, pos));\n#else\n\tmm_segment_t saved_fs;\n\tssize_t ret;\n\n\tsaved_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\tret = vfs_read(file, (void __user *)buf, count, pos);\n\n\tset_fs(saved_fs);\n\n\treturn (ret);\n#endif\n}\n\nstatic int\nspl_getattr(struct file *filp, struct kstat *stat)\n{\n\tint rc;\n\n\tASSERT(filp);\n\tASSERT(stat);\n\n#if defined(HAVE_4ARGS_VFS_GETATTR)\n\trc = vfs_getattr(&filp->f_path, stat, STATX_BASIC_STATS,\n\t    AT_STATX_SYNC_AS_STAT);\n#elif defined(HAVE_2ARGS_VFS_GETATTR)\n\trc = vfs_getattr(&filp->f_path, stat);\n#elif defined(HAVE_3ARGS_VFS_GETATTR)\n\trc = vfs_getattr(filp->f_path.mnt, filp->f_dentry, stat);\n#else\n#error \"No available vfs_getattr()\"\n#endif\n\tif (rc)\n\t\treturn (-rc);\n\n\treturn (0);\n}\n\n \n\nstatic char *spl_hostid_path = HW_HOSTID_PATH;\nmodule_param(spl_hostid_path, charp, 0444);\nMODULE_PARM_DESC(spl_hostid_path, \"The system hostid file (/etc/hostid)\");\n\nstatic int\nhostid_read(uint32_t *hostid)\n{\n\tuint64_t size;\n\tuint32_t value = 0;\n\tint error;\n\tloff_t off;\n\tstruct file *filp;\n\tstruct kstat stat;\n\n\tfilp = filp_open(spl_hostid_path, 0, 0);\n\n\tif (IS_ERR(filp))\n\t\treturn (ENOENT);\n\n\terror = spl_getattr(filp, &stat);\n\tif (error) {\n\t\tfilp_close(filp, 0);\n\t\treturn (error);\n\t}\n\tsize = stat.size;\n\t\n\tif (size < sizeof (HW_HOSTID_MASK)) {\n\t\tfilp_close(filp, 0);\n\t\treturn (EINVAL);\n\t}\n\n\toff = 0;\n\t \n\terror = spl_kernel_read(filp, &value, sizeof (value), &off);\n\tif (error < 0) {\n\t\tfilp_close(filp, 0);\n\t\treturn (EIO);\n\t}\n\n\t \n\t*hostid = (value & HW_HOSTID_MASK);\n\tfilp_close(filp, 0);\n\n\treturn (0);\n}\n\n \nuint32_t\nzone_get_hostid(void *zone)\n{\n\tuint32_t hostid;\n\n\tASSERT3P(zone, ==, NULL);\n\n\tif (spl_hostid != 0)\n\t\treturn ((uint32_t)(spl_hostid & HW_HOSTID_MASK));\n\n\tif (hostid_read(&hostid) == 0)\n\t\treturn (hostid);\n\n\treturn (0);\n}\nEXPORT_SYMBOL(zone_get_hostid);\n\nstatic int\nspl_kvmem_init(void)\n{\n\tint rc = 0;\n\n\trc = spl_kmem_init();\n\tif (rc)\n\t\treturn (rc);\n\n\trc = spl_vmem_init();\n\tif (rc) {\n\t\tspl_kmem_fini();\n\t\treturn (rc);\n\t}\n\n\treturn (rc);\n}\n\n \nstatic int __init\nspl_random_init(void)\n{\n\tuint64_t s[4];\n\tint i = 0;\n\n\tspl_pseudo_entropy = __alloc_percpu(4 * sizeof (uint64_t),\n\t    sizeof (uint64_t));\n\n\tif (!spl_pseudo_entropy)\n\t\treturn (-ENOMEM);\n\n\tget_random_bytes(s, sizeof (s));\n\n\tif (s[0] == 0 && s[1] == 0 && s[2] == 0 && s[3] == 0) {\n\t\tif (jiffies != 0) {\n\t\t\ts[0] = jiffies;\n\t\t\ts[1] = ~0 - jiffies;\n\t\t\ts[2] = ~jiffies;\n\t\t\ts[3] = jiffies - ~0;\n\t\t} else {\n\t\t\t(void) memcpy(s, \"improbable seed\", 16);\n\t\t}\n\t\tprintk(\"SPL: get_random_bytes() returned 0 \"\n\t\t    \"when generating random seed. Setting initial seed to \"\n\t\t    \"0x%016llx%016llx%016llx%016llx.\\n\", cpu_to_be64(s[0]),\n\t\t    cpu_to_be64(s[1]), cpu_to_be64(s[2]), cpu_to_be64(s[3]));\n\t}\n\n\tfor_each_possible_cpu(i) {\n\t\tuint64_t *wordp = per_cpu_ptr(spl_pseudo_entropy, i);\n\n\t\tspl_rand_jump(s);\n\n\t\twordp[0] = s[0];\n\t\twordp[1] = s[1];\n\t\twordp[2] = s[2];\n\t\twordp[3] = s[3];\n\t}\n\n\treturn (0);\n}\n\nstatic void\nspl_random_fini(void)\n{\n\tfree_percpu(spl_pseudo_entropy);\n}\n\nstatic void\nspl_kvmem_fini(void)\n{\n\tspl_vmem_fini();\n\tspl_kmem_fini();\n}\n\nstatic int __init\nspl_init(void)\n{\n\tint rc = 0;\n\n\tif ((rc = spl_random_init()))\n\t\tgoto out0;\n\n\tif ((rc = spl_kvmem_init()))\n\t\tgoto out1;\n\n\tif ((rc = spl_tsd_init()))\n\t\tgoto out2;\n\n\tif ((rc = spl_taskq_init()))\n\t\tgoto out3;\n\n\tif ((rc = spl_kmem_cache_init()))\n\t\tgoto out4;\n\n\tif ((rc = spl_proc_init()))\n\t\tgoto out5;\n\n\tif ((rc = spl_kstat_init()))\n\t\tgoto out6;\n\n\tif ((rc = spl_zlib_init()))\n\t\tgoto out7;\n\n\tif ((rc = spl_zone_init()))\n\t\tgoto out8;\n\n\treturn (rc);\n\nout8:\n\tspl_zlib_fini();\nout7:\n\tspl_kstat_fini();\nout6:\n\tspl_proc_fini();\nout5:\n\tspl_kmem_cache_fini();\nout4:\n\tspl_taskq_fini();\nout3:\n\tspl_tsd_fini();\nout2:\n\tspl_kvmem_fini();\nout1:\n\tspl_random_fini();\nout0:\n\treturn (rc);\n}\n\nstatic void __exit\nspl_fini(void)\n{\n\tspl_zone_fini();\n\tspl_zlib_fini();\n\tspl_kstat_fini();\n\tspl_proc_fini();\n\tspl_kmem_cache_fini();\n\tspl_taskq_fini();\n\tspl_tsd_fini();\n\tspl_kvmem_fini();\n\tspl_random_fini();\n}\n\nmodule_init(spl_init);\nmodule_exit(spl_fini);\n\nMODULE_DESCRIPTION(\"Solaris Porting Layer\");\nMODULE_AUTHOR(ZFS_META_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ZFS_META_VERSION \"-\" ZFS_META_RELEASE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}