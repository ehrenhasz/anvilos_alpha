{
  "module_name": "spl-xdr.c",
  "hash_id": "49077e37fc7a0e27b0e52590ac5121fec78d300470c61c4a24cd7dab5b6a0351",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-xdr.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <sys/kmem.h>\n#include <sys/debug.h>\n#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <rpc/xdr.h>\n\n \n\nstatic const struct xdr_ops xdrmem_encode_ops;\nstatic const struct xdr_ops xdrmem_decode_ops;\n\nvoid\nxdrmem_create(XDR *xdrs, const caddr_t addr, const uint_t size,\n    const enum xdr_op op)\n{\n\tswitch (op) {\n\t\tcase XDR_ENCODE:\n\t\t\txdrs->x_ops = &xdrmem_encode_ops;\n\t\t\tbreak;\n\t\tcase XDR_DECODE:\n\t\t\txdrs->x_ops = &xdrmem_decode_ops;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txdrs->x_ops = NULL;  \n\t\t\treturn;\n\t}\n\n\txdrs->x_op = op;\n\txdrs->x_addr = addr;\n\txdrs->x_addr_end = addr + size;\n\n\tif (xdrs->x_addr_end < xdrs->x_addr) {\n\t\txdrs->x_ops = NULL;\n\t}\n}\nEXPORT_SYMBOL(xdrmem_create);\n\nstatic bool_t\nxdrmem_control(XDR *xdrs, int req, void *info)\n{\n\tstruct xdr_bytesrec *rec = (struct xdr_bytesrec *)info;\n\n\tif (req != XDR_GET_BYTES_AVAIL)\n\t\treturn (FALSE);\n\n\trec->xc_is_last_record = TRUE;  \n\trec->xc_num_avail = xdrs->x_addr_end - xdrs->x_addr;\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_enc_bytes(XDR *xdrs, caddr_t cp, const uint_t cnt)\n{\n\tuint_t size = roundup(cnt, 4);\n\tuint_t pad;\n\n\tif (size < cnt)\n\t\treturn (FALSE);  \n\n\tif (xdrs->x_addr > xdrs->x_addr_end)\n\t\treturn (FALSE);\n\n\tif (xdrs->x_addr_end - xdrs->x_addr < size)\n\t\treturn (FALSE);\n\n\tmemcpy(xdrs->x_addr, cp, cnt);\n\n\txdrs->x_addr += cnt;\n\n\tpad = size - cnt;\n\tif (pad > 0) {\n\t\tmemset(xdrs->x_addr, 0, pad);\n\t\txdrs->x_addr += pad;\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_dec_bytes(XDR *xdrs, caddr_t cp, const uint_t cnt)\n{\n\tstatic uint32_t zero = 0;\n\tuint_t size = roundup(cnt, 4);\n\tuint_t pad;\n\n\tif (size < cnt)\n\t\treturn (FALSE);  \n\n\tif (xdrs->x_addr > xdrs->x_addr_end)\n\t\treturn (FALSE);\n\n\tif (xdrs->x_addr_end - xdrs->x_addr < size)\n\t\treturn (FALSE);\n\n\tmemcpy(cp, xdrs->x_addr, cnt);\n\txdrs->x_addr += cnt;\n\n\tpad = size - cnt;\n\tif (pad > 0) {\n\t\t \n\t\tif (memcmp(&zero, xdrs->x_addr, pad) != 0)\n\t\t\treturn (FALSE);\n\n\t\txdrs->x_addr += pad;\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_enc_uint32(XDR *xdrs, uint32_t val)\n{\n\tif (xdrs->x_addr + sizeof (uint32_t) > xdrs->x_addr_end)\n\t\treturn (FALSE);\n\n\t*((uint32_t *)xdrs->x_addr) = cpu_to_be32(val);\n\n\txdrs->x_addr += sizeof (uint32_t);\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_dec_uint32(XDR *xdrs, uint32_t *val)\n{\n\tif (xdrs->x_addr + sizeof (uint32_t) > xdrs->x_addr_end)\n\t\treturn (FALSE);\n\n\t*val = be32_to_cpu(*((uint32_t *)xdrs->x_addr));\n\n\txdrs->x_addr += sizeof (uint32_t);\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_enc_char(XDR *xdrs, char *cp)\n{\n\tuint32_t val;\n\n\tBUILD_BUG_ON(sizeof (char) != 1);\n\tval = *((unsigned char *) cp);\n\n\treturn (xdrmem_enc_uint32(xdrs, val));\n}\n\nstatic bool_t\nxdrmem_dec_char(XDR *xdrs, char *cp)\n{\n\tuint32_t val;\n\n\tBUILD_BUG_ON(sizeof (char) != 1);\n\n\tif (!xdrmem_dec_uint32(xdrs, &val))\n\t\treturn (FALSE);\n\n\t \n\tif (val > 0xff)\n\t\treturn (FALSE);\n\n\t*((unsigned char *) cp) = val;\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_enc_ushort(XDR *xdrs, unsigned short *usp)\n{\n\tBUILD_BUG_ON(sizeof (unsigned short) != 2);\n\n\treturn (xdrmem_enc_uint32(xdrs, *usp));\n}\n\nstatic bool_t\nxdrmem_dec_ushort(XDR *xdrs, unsigned short *usp)\n{\n\tuint32_t val;\n\n\tBUILD_BUG_ON(sizeof (unsigned short) != 2);\n\n\tif (!xdrmem_dec_uint32(xdrs, &val))\n\t\treturn (FALSE);\n\n\t \n\tif (val > 0xffff)\n\t\treturn (FALSE);\n\n\t*usp = val;\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdrmem_enc_uint(XDR *xdrs, unsigned *up)\n{\n\tBUILD_BUG_ON(sizeof (unsigned) != 4);\n\n\treturn (xdrmem_enc_uint32(xdrs, *up));\n}\n\nstatic bool_t\nxdrmem_dec_uint(XDR *xdrs, unsigned *up)\n{\n\tBUILD_BUG_ON(sizeof (unsigned) != 4);\n\n\treturn (xdrmem_dec_uint32(xdrs, (uint32_t *)up));\n}\n\nstatic bool_t\nxdrmem_enc_ulonglong(XDR *xdrs, u_longlong_t *ullp)\n{\n\tBUILD_BUG_ON(sizeof (u_longlong_t) != 8);\n\n\tif (!xdrmem_enc_uint32(xdrs, *ullp >> 32))\n\t\treturn (FALSE);\n\n\treturn (xdrmem_enc_uint32(xdrs, *ullp & 0xffffffff));\n}\n\nstatic bool_t\nxdrmem_dec_ulonglong(XDR *xdrs, u_longlong_t *ullp)\n{\n\tuint32_t low, high;\n\n\tBUILD_BUG_ON(sizeof (u_longlong_t) != 8);\n\n\tif (!xdrmem_dec_uint32(xdrs, &high))\n\t\treturn (FALSE);\n\tif (!xdrmem_dec_uint32(xdrs, &low))\n\t\treturn (FALSE);\n\n\t*ullp = ((u_longlong_t)high << 32) | low;\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdr_enc_array(XDR *xdrs, caddr_t *arrp, uint_t *sizep, const uint_t maxsize,\n    const uint_t elsize, const xdrproc_t elproc)\n{\n\tuint_t i;\n\tcaddr_t addr = *arrp;\n\n\tif (*sizep > maxsize || *sizep > UINT_MAX / elsize)\n\t\treturn (FALSE);\n\n\tif (!xdrmem_enc_uint(xdrs, sizep))\n\t\treturn (FALSE);\n\n\tfor (i = 0; i < *sizep; i++) {\n\t\tif (!elproc(xdrs, addr))\n\t\t\treturn (FALSE);\n\t\taddr += elsize;\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdr_dec_array(XDR *xdrs, caddr_t *arrp, uint_t *sizep, const uint_t maxsize,\n    const uint_t elsize, const xdrproc_t elproc)\n{\n\tuint_t i, size;\n\tbool_t alloc = FALSE;\n\tcaddr_t addr;\n\n\tif (!xdrmem_dec_uint(xdrs, sizep))\n\t\treturn (FALSE);\n\n\tsize = *sizep;\n\n\tif (size > maxsize || size > UINT_MAX / elsize)\n\t\treturn (FALSE);\n\n\t \n\tif (*arrp == NULL) {\n\t\tBUILD_BUG_ON(sizeof (uint_t) > sizeof (size_t));\n\n\t\t*arrp = kmem_alloc(size * elsize, KM_NOSLEEP);\n\t\tif (*arrp == NULL)\n\t\t\treturn (FALSE);\n\n\t\talloc = TRUE;\n\t}\n\n\taddr = *arrp;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (!elproc(xdrs, addr)) {\n\t\t\tif (alloc)\n\t\t\t\tkmem_free(*arrp, size * elsize);\n\t\t\treturn (FALSE);\n\t\t}\n\t\taddr += elsize;\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\nxdr_enc_string(XDR *xdrs, char **sp, const uint_t maxsize)\n{\n\tsize_t slen = strlen(*sp);\n\tuint_t len;\n\n\tif (slen > maxsize)\n\t\treturn (FALSE);\n\n\tlen = slen;\n\n\tif (!xdrmem_enc_uint(xdrs, &len))\n\t\treturn (FALSE);\n\n\treturn (xdrmem_enc_bytes(xdrs, *sp, len));\n}\n\nstatic bool_t\nxdr_dec_string(XDR *xdrs, char **sp, const uint_t maxsize)\n{\n\tuint_t size;\n\tbool_t alloc = FALSE;\n\n\tif (!xdrmem_dec_uint(xdrs, &size))\n\t\treturn (FALSE);\n\n\tif (size > maxsize || size > UINT_MAX - 1)\n\t\treturn (FALSE);\n\n\t \n\tif (*sp == NULL) {\n\t\tBUILD_BUG_ON(sizeof (uint_t) > sizeof (size_t));\n\n\t\t*sp = kmem_alloc(size + 1, KM_NOSLEEP);\n\t\tif (*sp == NULL)\n\t\t\treturn (FALSE);\n\n\t\talloc = TRUE;\n\t}\n\n\tif (!xdrmem_dec_bytes(xdrs, *sp, size))\n\t\tgoto fail;\n\n\tif (memchr(*sp, 0, size) != NULL)\n\t\tgoto fail;\n\n\t(*sp)[size] = '\\0';\n\n\treturn (TRUE);\n\nfail:\n\tif (alloc)\n\t\tkmem_free(*sp, size + 1);\n\n\treturn (FALSE);\n}\n\nstatic const struct xdr_ops xdrmem_encode_ops = {\n\t.xdr_control\t\t= xdrmem_control,\n\t.xdr_char\t\t= xdrmem_enc_char,\n\t.xdr_u_short\t\t= xdrmem_enc_ushort,\n\t.xdr_u_int\t\t= xdrmem_enc_uint,\n\t.xdr_u_longlong_t\t= xdrmem_enc_ulonglong,\n\t.xdr_opaque\t\t= xdrmem_enc_bytes,\n\t.xdr_string\t\t= xdr_enc_string,\n\t.xdr_array\t\t= xdr_enc_array\n};\n\nstatic const struct xdr_ops xdrmem_decode_ops = {\n\t.xdr_control\t\t= xdrmem_control,\n\t.xdr_char\t\t= xdrmem_dec_char,\n\t.xdr_u_short\t\t= xdrmem_dec_ushort,\n\t.xdr_u_int\t\t= xdrmem_dec_uint,\n\t.xdr_u_longlong_t\t= xdrmem_dec_ulonglong,\n\t.xdr_opaque\t\t= xdrmem_dec_bytes,\n\t.xdr_string\t\t= xdr_dec_string,\n\t.xdr_array\t\t= xdr_dec_array\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}