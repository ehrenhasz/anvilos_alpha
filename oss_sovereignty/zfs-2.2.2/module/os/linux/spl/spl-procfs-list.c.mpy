{
  "module_name": "spl-procfs-list.c",
  "hash_id": "6eda17665698aa141390d493faeb57b0935cb5ae60f6d33d3f0001c5bd693bc5",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-procfs-list.c",
  "human_readable_source": " \n \n\n#include <sys/list.h>\n#include <sys/procfs_list.h>\n#include <linux/proc_fs.h>\n#include <sys/mutex.h>\n\n \n\n#define\tNODE_ID(procfs_list, obj) \\\n\t\t(((procfs_list_node_t *)(((char *)obj) + \\\n\t\t(procfs_list)->pl_node_offset))->pln_id)\n\ntypedef struct procfs_list_cursor {\n\tprocfs_list_t\t*procfs_list;\t \n\tvoid\t\t*cached_node;\t \n\tloff_t\t\tcached_pos;\t \n} procfs_list_cursor_t;\n\nstatic int\nprocfs_list_seq_show(struct seq_file *f, void *p)\n{\n\tprocfs_list_cursor_t *cursor = f->private;\n\tprocfs_list_t *procfs_list = cursor->procfs_list;\n\n\tASSERT(MUTEX_HELD(&procfs_list->pl_lock));\n\tif (p == SEQ_START_TOKEN) {\n\t\tif (procfs_list->pl_show_header != NULL)\n\t\t\treturn (procfs_list->pl_show_header(f));\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (procfs_list->pl_show(f, p));\n}\n\nstatic void *\nprocfs_list_next_node(procfs_list_cursor_t *cursor, loff_t *pos)\n{\n\tvoid *next_node;\n\tprocfs_list_t *procfs_list = cursor->procfs_list;\n\n\tif (cursor->cached_node == SEQ_START_TOKEN)\n\t\tnext_node = list_head(&procfs_list->pl_list);\n\telse\n\t\tnext_node = list_next(&procfs_list->pl_list,\n\t\t    cursor->cached_node);\n\n\tif (next_node != NULL) {\n\t\tcursor->cached_node = next_node;\n\t\tcursor->cached_pos = NODE_ID(procfs_list, cursor->cached_node);\n\t\t*pos = cursor->cached_pos;\n\t} else {\n\t\t \n\t\tcursor->cached_node = NULL;\n\t\tcursor->cached_pos++;\n\t\t*pos = cursor->cached_pos;\n\t}\n\n\treturn (next_node);\n}\n\nstatic void *\nprocfs_list_seq_start(struct seq_file *f, loff_t *pos)\n{\n\tprocfs_list_cursor_t *cursor = f->private;\n\tprocfs_list_t *procfs_list = cursor->procfs_list;\n\n\tmutex_enter(&procfs_list->pl_lock);\n\n\tif (*pos == 0) {\n\t\tcursor->cached_node = SEQ_START_TOKEN;\n\t\tcursor->cached_pos = 0;\n\t\treturn (SEQ_START_TOKEN);\n\t} else if (cursor->cached_node == NULL) {\n\t\treturn (NULL);\n\t}\n\n\t \n\tvoid *oldest_node = list_head(&procfs_list->pl_list);\n\tif (cursor->cached_node != SEQ_START_TOKEN && (oldest_node == NULL ||\n\t    NODE_ID(procfs_list, oldest_node) > cursor->cached_pos))\n\t\treturn (ERR_PTR(-EIO));\n\n\t \n\tif (*pos == cursor->cached_pos) {\n\t\treturn (cursor->cached_node);\n\t} else {\n\t\tASSERT3U(*pos, ==, cursor->cached_pos + 1);\n\t\treturn (procfs_list_next_node(cursor, pos));\n\t}\n}\n\nstatic void *\nprocfs_list_seq_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\tprocfs_list_cursor_t *cursor = f->private;\n\tASSERT(MUTEX_HELD(&cursor->procfs_list->pl_lock));\n\treturn (procfs_list_next_node(cursor, pos));\n}\n\nstatic void\nprocfs_list_seq_stop(struct seq_file *f, void *p)\n{\n\tprocfs_list_cursor_t *cursor = f->private;\n\tprocfs_list_t *procfs_list = cursor->procfs_list;\n\tmutex_exit(&procfs_list->pl_lock);\n}\n\nstatic const struct seq_operations procfs_list_seq_ops = {\n\t.show  = procfs_list_seq_show,\n\t.start = procfs_list_seq_start,\n\t.next  = procfs_list_seq_next,\n\t.stop  = procfs_list_seq_stop,\n};\n\nstatic int\nprocfs_list_open(struct inode *inode, struct file *filp)\n{\n\tint rc = seq_open_private(filp, &procfs_list_seq_ops,\n\t    sizeof (procfs_list_cursor_t));\n\tif (rc != 0)\n\t\treturn (rc);\n\n\tstruct seq_file *f = filp->private_data;\n\tprocfs_list_cursor_t *cursor = f->private;\n\tcursor->procfs_list = SPL_PDE_DATA(inode);\n\tcursor->cached_node = NULL;\n\tcursor->cached_pos = 0;\n\n\treturn (0);\n}\n\nstatic ssize_t\nprocfs_list_write(struct file *filp, const char __user *buf, size_t len,\n    loff_t *ppos)\n{\n\tstruct seq_file *f = filp->private_data;\n\tprocfs_list_cursor_t *cursor = f->private;\n\tprocfs_list_t *procfs_list = cursor->procfs_list;\n\tint rc;\n\n\tif (procfs_list->pl_clear != NULL &&\n\t    (rc = procfs_list->pl_clear(procfs_list)) != 0)\n\t\treturn (-rc);\n\treturn (len);\n}\n\nstatic const kstat_proc_op_t procfs_list_operations = {\n#ifdef HAVE_PROC_OPS_STRUCT\n\t.proc_open\t= procfs_list_open,\n\t.proc_write\t= procfs_list_write,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release_private,\n#else\n\t.open\t\t= procfs_list_open,\n\t.write\t\t= procfs_list_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_private,\n#endif\n};\n\n \nvoid\nprocfs_list_install(const char *module,\n    const char *submodule,\n    const char *name,\n    mode_t mode,\n    procfs_list_t *procfs_list,\n    int (*show)(struct seq_file *f, void *p),\n    int (*show_header)(struct seq_file *f),\n    int (*clear)(procfs_list_t *procfs_list),\n    size_t procfs_list_node_off)\n{\n\tchar *modulestr;\n\n\tif (submodule != NULL)\n\t\tmodulestr = kmem_asprintf(\"%s/%s\", module, submodule);\n\telse\n\t\tmodulestr = kmem_asprintf(\"%s\", module);\n\tmutex_init(&procfs_list->pl_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&procfs_list->pl_list,\n\t    procfs_list_node_off + sizeof (procfs_list_node_t),\n\t    procfs_list_node_off + offsetof(procfs_list_node_t, pln_link));\n\tprocfs_list->pl_next_id = 1;  \n\tprocfs_list->pl_show = show;\n\tprocfs_list->pl_show_header = show_header;\n\tprocfs_list->pl_clear = clear;\n\tprocfs_list->pl_node_offset = procfs_list_node_off;\n\n\tkstat_proc_entry_init(&procfs_list->pl_kstat_entry, modulestr, name);\n\tkstat_proc_entry_install(&procfs_list->pl_kstat_entry, mode,\n\t    &procfs_list_operations, procfs_list);\n\tkmem_strfree(modulestr);\n}\nEXPORT_SYMBOL(procfs_list_install);\n\n \nvoid\nprocfs_list_uninstall(procfs_list_t *procfs_list)\n{\n\tkstat_proc_entry_delete(&procfs_list->pl_kstat_entry);\n}\nEXPORT_SYMBOL(procfs_list_uninstall);\n\nvoid\nprocfs_list_destroy(procfs_list_t *procfs_list)\n{\n\tASSERT(list_is_empty(&procfs_list->pl_list));\n\tlist_destroy(&procfs_list->pl_list);\n\tmutex_destroy(&procfs_list->pl_lock);\n}\nEXPORT_SYMBOL(procfs_list_destroy);\n\n \nvoid\nprocfs_list_add(procfs_list_t *procfs_list, void *p)\n{\n\tASSERT(MUTEX_HELD(&procfs_list->pl_lock));\n\tNODE_ID(procfs_list, p) = procfs_list->pl_next_id++;\n\tlist_insert_tail(&procfs_list->pl_list, p);\n}\nEXPORT_SYMBOL(procfs_list_add);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}