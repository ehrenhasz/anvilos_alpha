{
  "module_name": "spl-zone.c",
  "hash_id": "c5fe8be0ecf15d1a67676205c48db4e9e07db01198d490cbe124899266544af3",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-zone.c",
  "human_readable_source": " \n\n#include <sys/types.h>\n#include <sys/sysmacros.h>\n#include <sys/kmem.h>\n#include <linux/file.h>\n#include <linux/magic.h>\n#include <sys/zone.h>\n\n#if defined(CONFIG_USER_NS)\n#include <linux/statfs.h>\n#include <linux/proc_ns.h>\n#endif\n\n#include <sys/mutex.h>\n\nstatic kmutex_t zone_datasets_lock;\nstatic struct list_head zone_datasets;\n\ntypedef struct zone_datasets {\n\tstruct list_head zds_list;\t \n\tstruct user_namespace *zds_userns;  \n\tstruct list_head zds_datasets;\t \n} zone_datasets_t;\n\ntypedef struct zone_dataset {\n\tstruct list_head zd_list;\t \n\tsize_t zd_dsnamelen;\t\t \n\tchar zd_dsname[];\t\t \n} zone_dataset_t;\n\n#if defined(CONFIG_USER_NS) && defined(HAVE_USER_NS_COMMON_INUM)\n \nstatic int\nuser_ns_get(int fd, struct user_namespace **userns)\n{\n\tstruct kstatfs st;\n\tstruct file *nsfile;\n\tstruct ns_common *ns;\n\tint error;\n\n\tif ((nsfile = fget(fd)) == NULL)\n\t\treturn (EBADF);\n\tif (vfs_statfs(&nsfile->f_path, &st) != 0) {\n\t\terror = ENOTTY;\n\t\tgoto done;\n\t}\n\tif (st.f_type != NSFS_MAGIC) {\n\t\terror = ENOTTY;\n\t\tgoto done;\n\t}\n\tns = get_proc_ns(file_inode(nsfile));\n\tif (ns->ops->type != CLONE_NEWUSER) {\n\t\terror = ENOTTY;\n\t\tgoto done;\n\t}\n\t*userns = container_of(ns, struct user_namespace, ns);\n\n\terror = 0;\ndone:\n\tfput(nsfile);\n\n\treturn (error);\n}\n#endif  \n\nstatic unsigned int\nuser_ns_zoneid(struct user_namespace *user_ns)\n{\n\tunsigned int r;\n\n#if defined(HAVE_USER_NS_COMMON_INUM)\n\tr = user_ns->ns.inum;\n#else\n\tr = user_ns->proc_inum;\n#endif\n\n\treturn (r);\n}\n\nstatic struct zone_datasets *\nzone_datasets_lookup(unsigned int nsinum)\n{\n\tzone_datasets_t *zds;\n\n\tlist_for_each_entry(zds, &zone_datasets, zds_list) {\n\t\tif (user_ns_zoneid(zds->zds_userns) == nsinum)\n\t\t\treturn (zds);\n\t}\n\treturn (NULL);\n}\n\n#if defined(CONFIG_USER_NS) && defined(HAVE_USER_NS_COMMON_INUM)\nstatic struct zone_dataset *\nzone_dataset_lookup(zone_datasets_t *zds, const char *dataset, size_t dsnamelen)\n{\n\tzone_dataset_t *zd;\n\n\tlist_for_each_entry(zd, &zds->zds_datasets, zd_list) {\n\t\tif (zd->zd_dsnamelen != dsnamelen)\n\t\t\tcontinue;\n\t\tif (strncmp(zd->zd_dsname, dataset, dsnamelen) == 0)\n\t\t\treturn (zd);\n\t}\n\n\treturn (NULL);\n}\n\nstatic int\nzone_dataset_cred_check(cred_t *cred)\n{\n\n\tif (!uid_eq(cred->uid, GLOBAL_ROOT_UID))\n\t\treturn (EPERM);\n\n\treturn (0);\n}\n#endif  \n\nstatic int\nzone_dataset_name_check(const char *dataset, size_t *dsnamelen)\n{\n\n\tif (dataset[0] == '\\0' || dataset[0] == '/')\n\t\treturn (ENOENT);\n\n\t*dsnamelen = strlen(dataset);\n\t \n\tif (dataset[*dsnamelen - 1] == '/')\n\t\t(*dsnamelen)--;\n\n\treturn (0);\n}\n\nint\nzone_dataset_attach(cred_t *cred, const char *dataset, int userns_fd)\n{\n#if defined(CONFIG_USER_NS) && defined(HAVE_USER_NS_COMMON_INUM)\n\tstruct user_namespace *userns;\n\tzone_datasets_t *zds;\n\tzone_dataset_t *zd;\n\tint error;\n\tsize_t dsnamelen;\n\n\tif ((error = zone_dataset_cred_check(cred)) != 0)\n\t\treturn (error);\n\tif ((error = zone_dataset_name_check(dataset, &dsnamelen)) != 0)\n\t\treturn (error);\n\tif ((error = user_ns_get(userns_fd, &userns)) != 0)\n\t\treturn (error);\n\n\tmutex_enter(&zone_datasets_lock);\n\tzds = zone_datasets_lookup(user_ns_zoneid(userns));\n\tif (zds == NULL) {\n\t\tzds = kmem_alloc(sizeof (zone_datasets_t), KM_SLEEP);\n\t\tINIT_LIST_HEAD(&zds->zds_list);\n\t\tINIT_LIST_HEAD(&zds->zds_datasets);\n\t\tzds->zds_userns = userns;\n\t\t \n\t\tget_user_ns(userns);\n\t\tlist_add_tail(&zds->zds_list, &zone_datasets);\n\t} else {\n\t\tzd = zone_dataset_lookup(zds, dataset, dsnamelen);\n\t\tif (zd != NULL) {\n\t\t\tmutex_exit(&zone_datasets_lock);\n\t\t\treturn (EEXIST);\n\t\t}\n\t}\n\n\tzd = kmem_alloc(sizeof (zone_dataset_t) + dsnamelen + 1, KM_SLEEP);\n\tzd->zd_dsnamelen = dsnamelen;\n\tstrlcpy(zd->zd_dsname, dataset, dsnamelen + 1);\n\tINIT_LIST_HEAD(&zd->zd_list);\n\tlist_add_tail(&zd->zd_list, &zds->zds_datasets);\n\n\tmutex_exit(&zone_datasets_lock);\n\treturn (0);\n#else\n\treturn (ENXIO);\n#endif  \n}\nEXPORT_SYMBOL(zone_dataset_attach);\n\nint\nzone_dataset_detach(cred_t *cred, const char *dataset, int userns_fd)\n{\n#if defined(CONFIG_USER_NS) && defined(HAVE_USER_NS_COMMON_INUM)\n\tstruct user_namespace *userns;\n\tzone_datasets_t *zds;\n\tzone_dataset_t *zd;\n\tint error;\n\tsize_t dsnamelen;\n\n\tif ((error = zone_dataset_cred_check(cred)) != 0)\n\t\treturn (error);\n\tif ((error = zone_dataset_name_check(dataset, &dsnamelen)) != 0)\n\t\treturn (error);\n\tif ((error = user_ns_get(userns_fd, &userns)) != 0)\n\t\treturn (error);\n\n\tmutex_enter(&zone_datasets_lock);\n\tzds = zone_datasets_lookup(user_ns_zoneid(userns));\n\tif (zds != NULL)\n\t\tzd = zone_dataset_lookup(zds, dataset, dsnamelen);\n\tif (zds == NULL || zd == NULL) {\n\t\tmutex_exit(&zone_datasets_lock);\n\t\treturn (ENOENT);\n\t}\n\n\tlist_del(&zd->zd_list);\n\tkmem_free(zd, sizeof (*zd) + zd->zd_dsnamelen + 1);\n\n\t \n\tif (list_empty(&zds->zds_datasets)) {\n\t\t \n\t\tput_user_ns(userns);\n\t\tlist_del(&zds->zds_list);\n\t\tkmem_free(zds, sizeof (*zds));\n\t}\n\n\tmutex_exit(&zone_datasets_lock);\n\treturn (0);\n#else\n\treturn (ENXIO);\n#endif  \n}\nEXPORT_SYMBOL(zone_dataset_detach);\n\n \nint\nzone_dataset_visible(const char *dataset, int *write)\n{\n\tzone_datasets_t *zds;\n\tzone_dataset_t *zd;\n\tsize_t dsnamelen, zd_len;\n\tint visible;\n\n\t \n\tif (write != NULL)\n\t\t*write = 0;\n\tif (zone_dataset_name_check(dataset, &dsnamelen) != 0)\n\t\treturn (0);\n\tif (INGLOBALZONE(curproc)) {\n\t\tif (write != NULL)\n\t\t\t*write = 1;\n\t\treturn (1);\n\t}\n\n\tmutex_enter(&zone_datasets_lock);\n\tzds = zone_datasets_lookup(crgetzoneid(curproc->cred));\n\tif (zds == NULL) {\n\t\tmutex_exit(&zone_datasets_lock);\n\t\treturn (0);\n\t}\n\n\tvisible = 0;\n\tlist_for_each_entry(zd, &zds->zds_datasets, zd_list) {\n\t\tzd_len = strlen(zd->zd_dsname);\n\t\tif (zd_len > dsnamelen) {\n\t\t\t \n\t\t\tvisible = memcmp(zd->zd_dsname, dataset,\n\t\t\t    dsnamelen) == 0 &&\n\t\t\t    zd->zd_dsname[dsnamelen] == '/';\n\t\t\tif (visible)\n\t\t\t\tbreak;\n\t\t} else if (zd_len == dsnamelen) {\n\t\t\t \n\t\t\tvisible = memcmp(zd->zd_dsname, dataset, zd_len) == 0;\n\t\t\tif (visible) {\n\t\t\t\tif (write != NULL)\n\t\t\t\t\t*write = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tvisible = memcmp(zd->zd_dsname, dataset,\n\t\t\t    zd_len) == 0 && dataset[zd_len] == '/';\n\t\t\tif (visible) {\n\t\t\t\tif (write != NULL)\n\t\t\t\t\t*write = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_exit(&zone_datasets_lock);\n\treturn (visible);\n}\nEXPORT_SYMBOL(zone_dataset_visible);\n\nunsigned int\nglobal_zoneid(void)\n{\n\tunsigned int z = 0;\n\n#if defined(CONFIG_USER_NS)\n\tz = user_ns_zoneid(&init_user_ns);\n#endif\n\n\treturn (z);\n}\nEXPORT_SYMBOL(global_zoneid);\n\nunsigned int\ncrgetzoneid(const cred_t *cr)\n{\n\tunsigned int r = 0;\n\n#if defined(CONFIG_USER_NS)\n\tr = user_ns_zoneid(cr->user_ns);\n#endif\n\n\treturn (r);\n}\nEXPORT_SYMBOL(crgetzoneid);\n\nboolean_t\ninglobalzone(proc_t *proc)\n{\n#if defined(CONFIG_USER_NS)\n\treturn (proc->cred->user_ns == &init_user_ns);\n#else\n\treturn (B_TRUE);\n#endif\n}\nEXPORT_SYMBOL(inglobalzone);\n\nint\nspl_zone_init(void)\n{\n\tmutex_init(&zone_datasets_lock, NULL, MUTEX_DEFAULT, NULL);\n\tINIT_LIST_HEAD(&zone_datasets);\n\treturn (0);\n}\n\nvoid\nspl_zone_fini(void)\n{\n\tzone_datasets_t *zds;\n\tzone_dataset_t *zd;\n\n\t \n\twhile (!list_empty(&zone_datasets)) {\n\t\tzds = list_entry(zone_datasets.next, zone_datasets_t, zds_list);\n\t\twhile (!list_empty(&zds->zds_datasets)) {\n\t\t\tzd = list_entry(zds->zds_datasets.next,\n\t\t\t    zone_dataset_t, zd_list);\n\t\t\tlist_del(&zd->zd_list);\n\t\t\tkmem_free(zd, sizeof (*zd) + zd->zd_dsnamelen + 1);\n\t\t}\n\t\tput_user_ns(zds->zds_userns);\n\t\tlist_del(&zds->zds_list);\n\t\tkmem_free(zds, sizeof (*zds));\n\t}\n\tmutex_destroy(&zone_datasets_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}