{
  "module_name": "spl-tsd.c",
  "hash_id": "a8ab94ec18eeaa4eee2989b586e0fe9542d304d4b931a008a6d49aa012de980d",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/linux/spl/spl-tsd.c",
  "human_readable_source": " \n\n#include <sys/kmem.h>\n#include <sys/thread.h>\n#include <sys/tsd.h>\n#include <linux/hash.h>\n\ntypedef struct tsd_hash_bin {\n\tspinlock_t\t\thb_lock;\n\tstruct hlist_head\thb_head;\n} tsd_hash_bin_t;\n\ntypedef struct tsd_hash_table {\n\tspinlock_t\t\tht_lock;\n\tuint_t\t\t\tht_bits;\n\tuint_t\t\t\tht_key;\n\ttsd_hash_bin_t\t\t*ht_bins;\n} tsd_hash_table_t;\n\ntypedef struct tsd_hash_entry {\n\tuint_t\t\t\the_key;\n\tpid_t\t\t\the_pid;\n\tdtor_func_t\t\the_dtor;\n\tvoid\t\t\t*he_value;\n\tstruct hlist_node\the_list;\n\tstruct list_head\the_key_list;\n\tstruct list_head\the_pid_list;\n} tsd_hash_entry_t;\n\nstatic tsd_hash_table_t *tsd_hash_table = NULL;\n\n\n \nstatic tsd_hash_entry_t *\ntsd_hash_search(tsd_hash_table_t *table, uint_t key, pid_t pid)\n{\n\tstruct hlist_node *node = NULL;\n\ttsd_hash_entry_t *entry;\n\ttsd_hash_bin_t *bin;\n\tulong_t hash;\n\n\thash = hash_long((ulong_t)key * (ulong_t)pid, table->ht_bits);\n\tbin = &table->ht_bins[hash];\n\tspin_lock(&bin->hb_lock);\n\thlist_for_each(node, &bin->hb_head) {\n\t\tentry = list_entry(node, tsd_hash_entry_t, he_list);\n\t\tif ((entry->he_key == key) && (entry->he_pid == pid)) {\n\t\t\tspin_unlock(&bin->hb_lock);\n\t\t\treturn (entry);\n\t\t}\n\t}\n\n\tspin_unlock(&bin->hb_lock);\n\treturn (NULL);\n}\n\n \nstatic void\ntsd_hash_dtor(struct hlist_head *work)\n{\n\ttsd_hash_entry_t *entry;\n\n\twhile (!hlist_empty(work)) {\n\t\tentry = hlist_entry(work->first, tsd_hash_entry_t, he_list);\n\t\thlist_del(&entry->he_list);\n\n\t\tif (entry->he_dtor && entry->he_pid != DTOR_PID)\n\t\t\tentry->he_dtor(entry->he_value);\n\n\t\tkmem_free(entry, sizeof (tsd_hash_entry_t));\n\t}\n}\n\n \nstatic int\ntsd_hash_add(tsd_hash_table_t *table, uint_t key, pid_t pid, void *value)\n{\n\ttsd_hash_entry_t *entry, *dtor_entry, *pid_entry;\n\ttsd_hash_bin_t *bin;\n\tulong_t hash;\n\tint rc = 0;\n\n\tASSERT3P(tsd_hash_search(table, key, pid), ==, NULL);\n\n\t \n\tentry = kmem_alloc(sizeof (tsd_hash_entry_t), KM_PUSHPAGE);\n\tif (entry == NULL)\n\t\treturn (ENOMEM);\n\n\tentry->he_key = key;\n\tentry->he_pid = pid;\n\tentry->he_value = value;\n\tINIT_HLIST_NODE(&entry->he_list);\n\tINIT_LIST_HEAD(&entry->he_key_list);\n\tINIT_LIST_HEAD(&entry->he_pid_list);\n\n\tspin_lock(&table->ht_lock);\n\n\t \n\tdtor_entry = tsd_hash_search(table, entry->he_key, DTOR_PID);\n\tASSERT3P(dtor_entry, !=, NULL);\n\tentry->he_dtor = dtor_entry->he_dtor;\n\n\t \n\tpid_entry = tsd_hash_search(table, PID_KEY, entry->he_pid);\n\tASSERT3P(pid_entry, !=, NULL);\n\n\thash = hash_long((ulong_t)key * (ulong_t)pid, table->ht_bits);\n\tbin = &table->ht_bins[hash];\n\tspin_lock(&bin->hb_lock);\n\n\t \n\thlist_add_head(&entry->he_list, &bin->hb_head);\n\tlist_add(&entry->he_key_list, &dtor_entry->he_key_list);\n\tlist_add(&entry->he_pid_list, &pid_entry->he_pid_list);\n\n\tspin_unlock(&bin->hb_lock);\n\tspin_unlock(&table->ht_lock);\n\n\treturn (rc);\n}\n\n \nstatic int\ntsd_hash_add_key(tsd_hash_table_t *table, uint_t *keyp, dtor_func_t dtor)\n{\n\ttsd_hash_entry_t *tmp_entry, *entry;\n\ttsd_hash_bin_t *bin;\n\tulong_t hash;\n\tint keys_checked = 0;\n\n\tASSERT3P(table, !=, NULL);\n\n\t \n\tentry = kmem_alloc(sizeof (tsd_hash_entry_t), KM_PUSHPAGE);\n\tif (entry == NULL)\n\t\treturn (ENOMEM);\n\n\t \n\tspin_lock(&table->ht_lock);\n\tdo {\n\t\t \n\t\tif (table->ht_key++ > TSD_KEYS_MAX)\n\t\t\ttable->ht_key = 1;\n\n\t\t \n\t\tif (keys_checked++ >= TSD_KEYS_MAX) {\n\t\t\tspin_unlock(&table->ht_lock);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\ttmp_entry = tsd_hash_search(table, table->ht_key, DTOR_PID);\n\t} while (tmp_entry);\n\n\t \n\tentry->he_key = *keyp = table->ht_key;\n\tentry->he_pid = DTOR_PID;\n\tentry->he_dtor = dtor;\n\tentry->he_value = NULL;\n\tINIT_HLIST_NODE(&entry->he_list);\n\tINIT_LIST_HEAD(&entry->he_key_list);\n\tINIT_LIST_HEAD(&entry->he_pid_list);\n\n\thash = hash_long((ulong_t)*keyp * (ulong_t)DTOR_PID, table->ht_bits);\n\tbin = &table->ht_bins[hash];\n\tspin_lock(&bin->hb_lock);\n\n\thlist_add_head(&entry->he_list, &bin->hb_head);\n\n\tspin_unlock(&bin->hb_lock);\n\tspin_unlock(&table->ht_lock);\n\n\treturn (0);\n}\n\n \nstatic int\ntsd_hash_add_pid(tsd_hash_table_t *table, pid_t pid)\n{\n\ttsd_hash_entry_t *entry;\n\ttsd_hash_bin_t *bin;\n\tulong_t hash;\n\n\t \n\tentry = kmem_alloc(sizeof (tsd_hash_entry_t), KM_PUSHPAGE);\n\tif (entry == NULL)\n\t\treturn (ENOMEM);\n\n\tspin_lock(&table->ht_lock);\n\tentry->he_key = PID_KEY;\n\tentry->he_pid = pid;\n\tentry->he_dtor = NULL;\n\tentry->he_value = NULL;\n\tINIT_HLIST_NODE(&entry->he_list);\n\tINIT_LIST_HEAD(&entry->he_key_list);\n\tINIT_LIST_HEAD(&entry->he_pid_list);\n\n\thash = hash_long((ulong_t)PID_KEY * (ulong_t)pid, table->ht_bits);\n\tbin = &table->ht_bins[hash];\n\tspin_lock(&bin->hb_lock);\n\n\thlist_add_head(&entry->he_list, &bin->hb_head);\n\n\tspin_unlock(&bin->hb_lock);\n\tspin_unlock(&table->ht_lock);\n\n\treturn (0);\n}\n\n \nstatic void\ntsd_hash_del(tsd_hash_table_t *table, tsd_hash_entry_t *entry)\n{\n\thlist_del(&entry->he_list);\n\tlist_del_init(&entry->he_key_list);\n\tlist_del_init(&entry->he_pid_list);\n}\n\n \nstatic tsd_hash_table_t *\ntsd_hash_table_init(uint_t bits)\n{\n\ttsd_hash_table_t *table;\n\tint hash, size = (1 << bits);\n\n\ttable = kmem_zalloc(sizeof (tsd_hash_table_t), KM_SLEEP);\n\tif (table == NULL)\n\t\treturn (NULL);\n\n\ttable->ht_bins = kmem_zalloc(sizeof (tsd_hash_bin_t) * size, KM_SLEEP);\n\tif (table->ht_bins == NULL) {\n\t\tkmem_free(table, sizeof (tsd_hash_table_t));\n\t\treturn (NULL);\n\t}\n\n\tfor (hash = 0; hash < size; hash++) {\n\t\tspin_lock_init(&table->ht_bins[hash].hb_lock);\n\t\tINIT_HLIST_HEAD(&table->ht_bins[hash].hb_head);\n\t}\n\n\tspin_lock_init(&table->ht_lock);\n\ttable->ht_bits = bits;\n\ttable->ht_key = 1;\n\n\treturn (table);\n}\n\n \nstatic void\ntsd_hash_table_fini(tsd_hash_table_t *table)\n{\n\tHLIST_HEAD(work);\n\ttsd_hash_bin_t *bin;\n\ttsd_hash_entry_t *entry;\n\tint size, i;\n\n\tASSERT3P(table, !=, NULL);\n\tspin_lock(&table->ht_lock);\n\tfor (i = 0, size = (1 << table->ht_bits); i < size; i++) {\n\t\tbin = &table->ht_bins[i];\n\t\tspin_lock(&bin->hb_lock);\n\t\twhile (!hlist_empty(&bin->hb_head)) {\n\t\t\tentry = hlist_entry(bin->hb_head.first,\n\t\t\t    tsd_hash_entry_t, he_list);\n\t\t\ttsd_hash_del(table, entry);\n\t\t\thlist_add_head(&entry->he_list, &work);\n\t\t}\n\t\tspin_unlock(&bin->hb_lock);\n\t}\n\tspin_unlock(&table->ht_lock);\n\n\ttsd_hash_dtor(&work);\n\tkmem_free(table->ht_bins, sizeof (tsd_hash_bin_t)*(1<<table->ht_bits));\n\tkmem_free(table, sizeof (tsd_hash_table_t));\n}\n\n \nstatic void\ntsd_remove_entry(tsd_hash_entry_t *entry)\n{\n\tHLIST_HEAD(work);\n\ttsd_hash_table_t *table;\n\ttsd_hash_entry_t *pid_entry;\n\ttsd_hash_bin_t *pid_entry_bin, *entry_bin;\n\tulong_t hash;\n\n\ttable = tsd_hash_table;\n\tASSERT3P(table, !=, NULL);\n\tASSERT3P(entry, !=, NULL);\n\n\tspin_lock(&table->ht_lock);\n\n\thash = hash_long((ulong_t)entry->he_key *\n\t    (ulong_t)entry->he_pid, table->ht_bits);\n\tentry_bin = &table->ht_bins[hash];\n\n\t \n\tpid_entry = list_entry(entry->he_pid_list.next, tsd_hash_entry_t,\n\t    he_pid_list);\n\n\t \n\tspin_lock(&entry_bin->hb_lock);\n\ttsd_hash_del(table, entry);\n\thlist_add_head(&entry->he_list, &work);\n\tspin_unlock(&entry_bin->hb_lock);\n\n\t \n\tif (pid_entry->he_key == PID_KEY &&\n\t    list_empty(&pid_entry->he_pid_list)) {\n\t\thash = hash_long((ulong_t)pid_entry->he_key *\n\t\t    (ulong_t)pid_entry->he_pid, table->ht_bits);\n\t\tpid_entry_bin = &table->ht_bins[hash];\n\n\t\tspin_lock(&pid_entry_bin->hb_lock);\n\t\ttsd_hash_del(table, pid_entry);\n\t\thlist_add_head(&pid_entry->he_list, &work);\n\t\tspin_unlock(&pid_entry_bin->hb_lock);\n\t}\n\n\tspin_unlock(&table->ht_lock);\n\n\ttsd_hash_dtor(&work);\n}\n\n \nint\ntsd_set(uint_t key, void *value)\n{\n\ttsd_hash_table_t *table;\n\ttsd_hash_entry_t *entry;\n\tpid_t pid;\n\tint rc;\n\t \n\tboolean_t remove = (value == NULL);\n\n\ttable = tsd_hash_table;\n\tpid = curthread->pid;\n\tASSERT3P(table, !=, NULL);\n\n\tif ((key == 0) || (key > TSD_KEYS_MAX))\n\t\treturn (EINVAL);\n\n\t \n\tentry = tsd_hash_search(table, key, pid);\n\tif (entry) {\n\t\tentry->he_value = value;\n\t\t \n\t\tif (remove)\n\t\t\ttsd_remove_entry(entry);\n\t\treturn (0);\n\t}\n\n\t \n\tif (remove)\n\t\treturn (0);\n\n\t \n\tentry = tsd_hash_search(table, PID_KEY, pid);\n\tif (entry == NULL) {\n\t\trc = tsd_hash_add_pid(table, pid);\n\t\tif (rc)\n\t\t\treturn (rc);\n\t}\n\n\trc = tsd_hash_add(table, key, pid, value);\n\treturn (rc);\n}\nEXPORT_SYMBOL(tsd_set);\n\n \nvoid *\ntsd_get(uint_t key)\n{\n\ttsd_hash_entry_t *entry;\n\n\tASSERT3P(tsd_hash_table, !=, NULL);\n\n\tif ((key == 0) || (key > TSD_KEYS_MAX))\n\t\treturn (NULL);\n\n\tentry = tsd_hash_search(tsd_hash_table, key, curthread->pid);\n\tif (entry == NULL)\n\t\treturn (NULL);\n\n\treturn (entry->he_value);\n}\nEXPORT_SYMBOL(tsd_get);\n\n \nvoid *\ntsd_get_by_thread(uint_t key, kthread_t *thread)\n{\n\ttsd_hash_entry_t *entry;\n\n\tASSERT3P(tsd_hash_table, !=, NULL);\n\n\tif ((key == 0) || (key > TSD_KEYS_MAX))\n\t\treturn (NULL);\n\n\tentry = tsd_hash_search(tsd_hash_table, key, thread->pid);\n\tif (entry == NULL)\n\t\treturn (NULL);\n\n\treturn (entry->he_value);\n}\nEXPORT_SYMBOL(tsd_get_by_thread);\n\n \nvoid\ntsd_create(uint_t *keyp, dtor_func_t dtor)\n{\n\tASSERT3P(keyp, !=, NULL);\n\tif (*keyp)\n\t\treturn;\n\n\t(void) tsd_hash_add_key(tsd_hash_table, keyp, dtor);\n}\nEXPORT_SYMBOL(tsd_create);\n\n \nvoid\ntsd_destroy(uint_t *keyp)\n{\n\tHLIST_HEAD(work);\n\ttsd_hash_table_t *table;\n\ttsd_hash_entry_t *dtor_entry, *entry;\n\ttsd_hash_bin_t *dtor_entry_bin, *entry_bin;\n\tulong_t hash;\n\n\ttable = tsd_hash_table;\n\tASSERT3P(table, !=, NULL);\n\n\tspin_lock(&table->ht_lock);\n\tdtor_entry = tsd_hash_search(table, *keyp, DTOR_PID);\n\tif (dtor_entry == NULL) {\n\t\tspin_unlock(&table->ht_lock);\n\t\treturn;\n\t}\n\n\t \n\twhile (!list_empty(&dtor_entry->he_key_list)) {\n\t\tentry = list_entry(dtor_entry->he_key_list.next,\n\t\t    tsd_hash_entry_t, he_key_list);\n\t\tASSERT3U(dtor_entry->he_key, ==, entry->he_key);\n\t\tASSERT3P(dtor_entry->he_dtor, ==, entry->he_dtor);\n\n\t\thash = hash_long((ulong_t)entry->he_key *\n\t\t    (ulong_t)entry->he_pid, table->ht_bits);\n\t\tentry_bin = &table->ht_bins[hash];\n\n\t\tspin_lock(&entry_bin->hb_lock);\n\t\ttsd_hash_del(table, entry);\n\t\thlist_add_head(&entry->he_list, &work);\n\t\tspin_unlock(&entry_bin->hb_lock);\n\t}\n\n\thash = hash_long((ulong_t)dtor_entry->he_key *\n\t    (ulong_t)dtor_entry->he_pid, table->ht_bits);\n\tdtor_entry_bin = &table->ht_bins[hash];\n\n\tspin_lock(&dtor_entry_bin->hb_lock);\n\ttsd_hash_del(table, dtor_entry);\n\thlist_add_head(&dtor_entry->he_list, &work);\n\tspin_unlock(&dtor_entry_bin->hb_lock);\n\tspin_unlock(&table->ht_lock);\n\n\ttsd_hash_dtor(&work);\n\t*keyp = 0;\n}\nEXPORT_SYMBOL(tsd_destroy);\n\n \nvoid\ntsd_exit(void)\n{\n\tHLIST_HEAD(work);\n\ttsd_hash_table_t *table;\n\ttsd_hash_entry_t *pid_entry, *entry;\n\ttsd_hash_bin_t *pid_entry_bin, *entry_bin;\n\tulong_t hash;\n\n\ttable = tsd_hash_table;\n\tASSERT3P(table, !=, NULL);\n\n\tspin_lock(&table->ht_lock);\n\tpid_entry = tsd_hash_search(table, PID_KEY, curthread->pid);\n\tif (pid_entry == NULL) {\n\t\tspin_unlock(&table->ht_lock);\n\t\treturn;\n\t}\n\n\t \n\n\twhile (!list_empty(&pid_entry->he_pid_list)) {\n\t\tentry = list_entry(pid_entry->he_pid_list.next,\n\t\t    tsd_hash_entry_t, he_pid_list);\n\t\tASSERT3U(pid_entry->he_pid, ==, entry->he_pid);\n\n\t\thash = hash_long((ulong_t)entry->he_key *\n\t\t    (ulong_t)entry->he_pid, table->ht_bits);\n\t\tentry_bin = &table->ht_bins[hash];\n\n\t\tspin_lock(&entry_bin->hb_lock);\n\t\ttsd_hash_del(table, entry);\n\t\thlist_add_head(&entry->he_list, &work);\n\t\tspin_unlock(&entry_bin->hb_lock);\n\t}\n\n\thash = hash_long((ulong_t)pid_entry->he_key *\n\t    (ulong_t)pid_entry->he_pid, table->ht_bits);\n\tpid_entry_bin = &table->ht_bins[hash];\n\n\tspin_lock(&pid_entry_bin->hb_lock);\n\ttsd_hash_del(table, pid_entry);\n\thlist_add_head(&pid_entry->he_list, &work);\n\tspin_unlock(&pid_entry_bin->hb_lock);\n\tspin_unlock(&table->ht_lock);\n\n\ttsd_hash_dtor(&work);\n}\nEXPORT_SYMBOL(tsd_exit);\n\nint\nspl_tsd_init(void)\n{\n\ttsd_hash_table = tsd_hash_table_init(TSD_HASH_TABLE_BITS_DEFAULT);\n\tif (tsd_hash_table == NULL)\n\t\treturn (-ENOMEM);\n\n\treturn (0);\n}\n\nvoid\nspl_tsd_fini(void)\n{\n\ttsd_hash_table_fini(tsd_hash_table);\n\ttsd_hash_table = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}