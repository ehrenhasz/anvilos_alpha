{
  "module_name": "spl_kstat.c",
  "hash_id": "c23b55428f5a2ea8207798606bb05b179594cada02448a7be27b91de1803ca6a",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_kstat.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/sysctl.h>\n#include <sys/kstat.h>\n#include <sys/sbuf.h>\n#include <sys/zone.h>\n\nstatic MALLOC_DEFINE(M_KSTAT, \"kstat_data\", \"Kernel statistics\");\n\nSYSCTL_ROOT_NODE(OID_AUTO, kstat, CTLFLAG_RW, 0, \"Kernel statistics\");\n\nvoid\n__kstat_set_raw_ops(kstat_t *ksp,\n    int (*headers)(char *buf, size_t size),\n    int (*data)(char *buf, size_t size, void *data),\n    void *(*addr)(kstat_t *ksp, loff_t index))\n{\n\tksp->ks_raw_ops.headers = headers;\n\tksp->ks_raw_ops.data    = data;\n\tksp->ks_raw_ops.addr    = addr;\n}\n\nvoid\n__kstat_set_seq_raw_ops(kstat_t *ksp,\n    int (*headers)(struct seq_file *f),\n    int (*data)(char *buf, size_t size, void *data),\n    void *(*addr)(kstat_t *ksp, loff_t index))\n{\n\tksp->ks_raw_ops.seq_headers = headers;\n\tksp->ks_raw_ops.data    = data;\n\tksp->ks_raw_ops.addr    = addr;\n}\n\nstatic int\nkstat_default_update(kstat_t *ksp, int rw)\n{\n\tASSERT3P(ksp, !=, NULL);\n\n\tif (rw == KSTAT_WRITE)\n\t\treturn (EACCES);\n\n\treturn (0);\n}\n\nstatic int\nkstat_resize_raw(kstat_t *ksp)\n{\n\tif (ksp->ks_raw_bufsize == KSTAT_RAW_MAX)\n\t\treturn (ENOMEM);\n\n\tfree(ksp->ks_raw_buf, M_TEMP);\n\tksp->ks_raw_bufsize = MIN(ksp->ks_raw_bufsize * 2, KSTAT_RAW_MAX);\n\tksp->ks_raw_buf = malloc(ksp->ks_raw_bufsize, M_TEMP, M_WAITOK);\n\n\treturn (0);\n}\n\nstatic void *\nkstat_raw_default_addr(kstat_t *ksp, loff_t n)\n{\n\tif (n == 0)\n\t\treturn (ksp->ks_data);\n\treturn (NULL);\n}\n\nstatic int\nkstat_sysctl(SYSCTL_HANDLER_ARGS)\n{\n\tkstat_t *ksp = arg1;\n\tkstat_named_t *ksent;\n\tuint64_t val;\n\n\tksent = ksp->ks_data;\n\t \n\tksent += arg2;\n\t \n\t(void) ksp->ks_update(ksp, KSTAT_READ);\n\tval = ksent->value.ui64;\n\n\treturn (sysctl_handle_64(oidp, &val, 0, req));\n}\n\nstatic int\nkstat_sysctl_string(SYSCTL_HANDLER_ARGS)\n{\n\tkstat_t *ksp = arg1;\n\tkstat_named_t *ksent = ksp->ks_data;\n\tchar *val;\n\tuint32_t len = 0;\n\n\t \n\tksent += arg2;\n\t \n\t(void) ksp->ks_update(ksp, KSTAT_READ);\n\tval = KSTAT_NAMED_STR_PTR(ksent);\n\tlen = KSTAT_NAMED_STR_BUFLEN(ksent);\n\tval[len-1] = '\\0';\n\n\treturn (sysctl_handle_string(oidp, val, len, req));\n}\n\nstatic int\nkstat_sysctl_dataset(SYSCTL_HANDLER_ARGS)\n{\n\tkstat_t *ksp = arg1;\n\tkstat_named_t *ksent;\n\tkstat_named_t *ksent_ds;\n\tuint64_t val;\n\tchar *ds_name;\n\tuint32_t ds_len = 0;\n\n\tksent_ds = ksent = ksp->ks_data;\n\tds_name = KSTAT_NAMED_STR_PTR(ksent_ds);\n\tds_len = KSTAT_NAMED_STR_BUFLEN(ksent_ds);\n\tds_name[ds_len-1] = '\\0';\n\n\tif (!zone_dataset_visible(ds_name, NULL)) {\n\t\treturn (EPERM);\n\t}\n\n\t \n\tksent += arg2;\n\t \n\t(void) ksp->ks_update(ksp, KSTAT_READ);\n\tval = ksent->value.ui64;\n\n\treturn (sysctl_handle_64(oidp, &val, 0, req));\n}\n\nstatic int\nkstat_sysctl_dataset_string(SYSCTL_HANDLER_ARGS)\n{\n\tkstat_t *ksp = arg1;\n\tkstat_named_t *ksent = ksp->ks_data;\n\tchar *val;\n\tuint32_t len = 0;\n\n\t \n\tksent += arg2;\n\tval = KSTAT_NAMED_STR_PTR(ksent);\n\tlen = KSTAT_NAMED_STR_BUFLEN(ksent);\n\tval[len-1] = '\\0';\n\n\tif (!zone_dataset_visible(val, NULL)) {\n\t\treturn (EPERM);\n\t}\n\n\treturn (sysctl_handle_string(oidp, val, len, req));\n}\n\nstatic int\nkstat_sysctl_io(SYSCTL_HANDLER_ARGS)\n{\n\tstruct sbuf *sb;\n\tkstat_t *ksp = arg1;\n\tkstat_io_t *kip = ksp->ks_data;\n\tint rc;\n\n\tsb = sbuf_new_auto();\n\tif (sb == NULL)\n\t\treturn (ENOMEM);\n\t \n\t(void) ksp->ks_update(ksp, KSTAT_READ);\n\n\t \n\tsbuf_printf(sb,\n\t    \"%-8llu %-8llu %-8u %-8u %-8llu %-8llu \"\n\t    \"%-8llu %-8llu %-8llu %-8llu %-8u %-8u\\n\",\n\t    kip->nread, kip->nwritten,\n\t    kip->reads, kip->writes,\n\t    kip->wtime, kip->wlentime, kip->wlastupdate,\n\t    kip->rtime, kip->rlentime, kip->rlastupdate,\n\t    kip->wcnt,  kip->rcnt);\n\trc = sbuf_finish(sb);\n\tif (rc == 0)\n\t\trc = SYSCTL_OUT(req, sbuf_data(sb), sbuf_len(sb));\n\tsbuf_delete(sb);\n\treturn (rc);\n}\n\nstatic int\nkstat_sysctl_raw(SYSCTL_HANDLER_ARGS)\n{\n\tstruct sbuf *sb;\n\tvoid *data;\n\tkstat_t *ksp = arg1;\n\tvoid *(*addr_op)(kstat_t *ksp, loff_t index);\n\tint n, has_header, rc = 0;\n\n\tsb = sbuf_new_auto();\n\tif (sb == NULL)\n\t\treturn (ENOMEM);\n\n\tif (ksp->ks_raw_ops.addr)\n\t\taddr_op = ksp->ks_raw_ops.addr;\n\telse\n\t\taddr_op = kstat_raw_default_addr;\n\n\tmutex_enter(ksp->ks_lock);\n\n\t \n\t(void) ksp->ks_update(ksp, KSTAT_READ);\n\n\tksp->ks_raw_bufsize = PAGE_SIZE;\n\tksp->ks_raw_buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);\n\n\tn = 0;\n\thas_header = (ksp->ks_raw_ops.headers ||\n\t    ksp->ks_raw_ops.seq_headers);\n\nrestart_headers:\n\tif (ksp->ks_raw_ops.headers) {\n\t\trc = ksp->ks_raw_ops.headers(\n\t\t    ksp->ks_raw_buf, ksp->ks_raw_bufsize);\n\t} else if (ksp->ks_raw_ops.seq_headers) {\n\t\tstruct seq_file f;\n\n\t\tf.sf_buf = ksp->ks_raw_buf;\n\t\tf.sf_size = ksp->ks_raw_bufsize;\n\t\trc = ksp->ks_raw_ops.seq_headers(&f);\n\t}\n\tif (has_header) {\n\t\tif (rc == ENOMEM && !kstat_resize_raw(ksp))\n\t\t\tgoto restart_headers;\n\t\tif (rc == 0)\n\t\t\tsbuf_printf(sb, \"\\n%s\", ksp->ks_raw_buf);\n\t}\n\n\twhile ((data = addr_op(ksp, n)) != NULL) {\nrestart:\n\t\tif (ksp->ks_raw_ops.data) {\n\t\t\trc = ksp->ks_raw_ops.data(ksp->ks_raw_buf,\n\t\t\t    ksp->ks_raw_bufsize, data);\n\t\t\tif (rc == ENOMEM && !kstat_resize_raw(ksp))\n\t\t\t\tgoto restart;\n\t\t\tif (rc == 0)\n\t\t\t\tsbuf_printf(sb, \"%s\", ksp->ks_raw_buf);\n\n\t\t} else {\n\t\t\tASSERT3U(ksp->ks_ndata, ==, 1);\n\t\t\tsbuf_hexdump(sb, ksp->ks_data,\n\t\t\t    ksp->ks_data_size, NULL, 0);\n\t\t}\n\t\tn++;\n\t}\n\tfree(ksp->ks_raw_buf, M_TEMP);\n\tmutex_exit(ksp->ks_lock);\n\tsbuf_trim(sb);\n\trc = sbuf_finish(sb);\n\tif (rc == 0)\n\t\trc = SYSCTL_OUT(req, sbuf_data(sb), sbuf_len(sb));\n\tsbuf_delete(sb);\n\treturn (rc);\n}\n\nkstat_t *\n__kstat_create(const char *module, int instance, const char *name,\n    const char *class, uchar_t ks_type, uint_t ks_ndata, uchar_t flags)\n{\n\tchar buf[KSTAT_STRLEN];\n\tstruct sysctl_oid *root;\n\tkstat_t *ksp;\n\tchar *pool;\n\n\tKASSERT(instance == 0, (\"instance=%d\", instance));\n\tif ((ks_type == KSTAT_TYPE_INTR) || (ks_type == KSTAT_TYPE_IO))\n\t\tASSERT3U(ks_ndata, ==, 1);\n\n\tif (class == NULL)\n\t\tclass = \"misc\";\n\n\t \n\tksp = malloc(sizeof (*ksp), M_KSTAT, M_WAITOK|M_ZERO);\n\n\tksp->ks_crtime = gethrtime();\n\tksp->ks_snaptime = ksp->ks_crtime;\n\tksp->ks_instance = instance;\n\t(void) strlcpy(ksp->ks_name, name, KSTAT_STRLEN);\n\t(void) strlcpy(ksp->ks_class, class, KSTAT_STRLEN);\n\tksp->ks_type = ks_type;\n\tksp->ks_flags = flags;\n\tksp->ks_update = kstat_default_update;\n\n\tmutex_init(&ksp->ks_private_lock, NULL, MUTEX_DEFAULT, NULL);\n\tksp->ks_lock = &ksp->ks_private_lock;\n\n\tswitch (ksp->ks_type) {\n\tcase KSTAT_TYPE_RAW:\n\t\tksp->ks_ndata = 1;\n\t\tksp->ks_data_size = ks_ndata;\n\t\tbreak;\n\tcase KSTAT_TYPE_NAMED:\n\t\tksp->ks_ndata = ks_ndata;\n\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_named_t);\n\t\tbreak;\n\tcase KSTAT_TYPE_INTR:\n\t\tksp->ks_ndata = ks_ndata;\n\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_intr_t);\n\t\tbreak;\n\tcase KSTAT_TYPE_IO:\n\t\tksp->ks_ndata = ks_ndata;\n\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_io_t);\n\t\tbreak;\n\tcase KSTAT_TYPE_TIMER:\n\t\tksp->ks_ndata = ks_ndata;\n\t\tksp->ks_data_size = ks_ndata * sizeof (kstat_timer_t);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"Undefined kstat type %d\\n\", ksp->ks_type);\n\t}\n\n\tif (ksp->ks_flags & KSTAT_FLAG_VIRTUAL)\n\t\tksp->ks_data = NULL;\n\telse\n\t\tksp->ks_data = kmem_zalloc(ksp->ks_data_size, KM_SLEEP);\n\n\t \n\t(void) strlcpy(buf, module, KSTAT_STRLEN);\n\tmodule = buf;\n\tpool = strchr(module, '/');\n\tif (pool != NULL)\n\t\t*pool++ = '\\0';\n\n\t \n\tsysctl_ctx_init(&ksp->ks_sysctl_ctx);\n\troot = SYSCTL_ADD_NODE(&ksp->ks_sysctl_ctx,\n\t    SYSCTL_STATIC_CHILDREN(_kstat), OID_AUTO, module, CTLFLAG_RW, 0,\n\t    \"\");\n\tif (root == NULL) {\n\t\tprintf(\"%s: Cannot create kstat.%s tree!\\n\", __func__, module);\n\t\tsysctl_ctx_free(&ksp->ks_sysctl_ctx);\n\t\tfree(ksp, M_KSTAT);\n\t\treturn (NULL);\n\t}\n\tif (pool != NULL) {\n\t\troot = SYSCTL_ADD_NODE(&ksp->ks_sysctl_ctx,\n\t\t    SYSCTL_CHILDREN(root), OID_AUTO, pool, CTLFLAG_RW, 0, \"\");\n\t\tif (root == NULL) {\n\t\t\tprintf(\"%s: Cannot create kstat.%s.%s tree!\\n\",\n\t\t\t    __func__, module, pool);\n\t\t\tsysctl_ctx_free(&ksp->ks_sysctl_ctx);\n\t\t\tfree(ksp, M_KSTAT);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\troot = SYSCTL_ADD_NODE(&ksp->ks_sysctl_ctx, SYSCTL_CHILDREN(root),\n\t    OID_AUTO, class, CTLFLAG_RW, 0, \"\");\n\tif (root == NULL) {\n\t\tif (pool != NULL)\n\t\t\tprintf(\"%s: Cannot create kstat.%s.%s.%s tree!\\n\",\n\t\t\t    __func__, module, pool, class);\n\t\telse\n\t\t\tprintf(\"%s: Cannot create kstat.%s.%s tree!\\n\",\n\t\t\t    __func__, module, class);\n\t\tsysctl_ctx_free(&ksp->ks_sysctl_ctx);\n\t\tfree(ksp, M_KSTAT);\n\t\treturn (NULL);\n\t}\n\tif (ksp->ks_type == KSTAT_TYPE_NAMED) {\n\t\troot = SYSCTL_ADD_NODE(&ksp->ks_sysctl_ctx,\n\t\t    SYSCTL_CHILDREN(root),\n\t\t    OID_AUTO, name, CTLFLAG_RW, 0, \"\");\n\t\tif (root == NULL) {\n\t\t\tif (pool != NULL)\n\t\t\t\tprintf(\"%s: Cannot create kstat.%s.%s.%s.%s \"\n\t\t\t\t    \"tree!\\n\", __func__, module, pool, class,\n\t\t\t\t    name);\n\t\t\telse\n\t\t\t\tprintf(\"%s: Cannot create kstat.%s.%s.%s \"\n\t\t\t\t    \"tree!\\n\", __func__, module, class, name);\n\t\t\tsysctl_ctx_free(&ksp->ks_sysctl_ctx);\n\t\t\tfree(ksp, M_KSTAT);\n\t\t\treturn (NULL);\n\t\t}\n\n\t}\n\tksp->ks_sysctl_root = root;\n\n\treturn (ksp);\n}\n\nstatic void\nkstat_install_named(kstat_t *ksp)\n{\n\tkstat_named_t *ksent;\n\tchar *namelast;\n\tint typelast;\n\n\tksent = ksp->ks_data;\n\n\tVERIFY((ksp->ks_flags & KSTAT_FLAG_VIRTUAL) || ksent != NULL);\n\n\ttypelast = 0;\n\tnamelast = NULL;\n\n\tfor (int i = 0; i < ksp->ks_ndata; i++, ksent++) {\n\t\tif (ksent->data_type != 0) {\n\t\t\ttypelast = ksent->data_type;\n\t\t\tnamelast = ksent->name;\n\t\t}\n\t\tswitch (typelast) {\n\t\tcase KSTAT_DATA_CHAR:\n\t\t\t \n\t\t\tbreak;\n\t\tcase KSTAT_DATA_INT32:\n\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, namelast,\n\t\t\t    CTLTYPE_S32 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t    ksp, i, kstat_sysctl, \"I\", namelast);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_UINT32:\n\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, namelast,\n\t\t\t    CTLTYPE_U32 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t    ksp, i, kstat_sysctl, \"IU\", namelast);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_INT64:\n\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, namelast,\n\t\t\t    CTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t    ksp, i, kstat_sysctl, \"Q\", namelast);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_UINT64:\n\t\t\tif (strcmp(ksp->ks_class, \"dataset\") == 0) {\n\t\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t\t    OID_AUTO, namelast,\n\t\t\t\t    CTLTYPE_U64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t\t    ksp, i, kstat_sysctl_dataset, \"QU\",\n\t\t\t\t    namelast);\n\t\t\t} else {\n\t\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t\t    OID_AUTO, namelast,\n\t\t\t\t    CTLTYPE_U64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t\t    ksp, i, kstat_sysctl, \"QU\", namelast);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_LONG:\n\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, namelast,\n\t\t\t    CTLTYPE_LONG | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t    ksp, i, kstat_sysctl, \"L\", namelast);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_ULONG:\n\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, namelast,\n\t\t\t    CTLTYPE_ULONG | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t    ksp, i, kstat_sysctl, \"LU\", namelast);\n\t\t\tbreak;\n\t\tcase KSTAT_DATA_STRING:\n\t\t\tif (strcmp(ksp->ks_class, \"dataset\") == 0) {\n\t\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t\t    OID_AUTO, namelast, CTLTYPE_STRING |\n\t\t\t\t    CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t\t    ksp, i, kstat_sysctl_dataset_string, \"A\",\n\t\t\t\t    namelast);\n\t\t\t} else {\n\t\t\t\tSYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t\t    OID_AUTO, namelast, CTLTYPE_STRING |\n\t\t\t\t    CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t\t\t    ksp, i, kstat_sysctl_string, \"A\",\n\t\t\t\t    namelast);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"unsupported type: %d\", typelast);\n\t\t}\n\t}\n}\n\nvoid\nkstat_install(kstat_t *ksp)\n{\n\tstruct sysctl_oid *root;\n\n\tif (ksp->ks_ndata == UINT32_MAX)\n\t\tVERIFY3U(ksp->ks_type, ==, KSTAT_TYPE_RAW);\n\n\tswitch (ksp->ks_type) {\n\tcase KSTAT_TYPE_NAMED:\n\t\treturn (kstat_install_named(ksp));\n\tcase KSTAT_TYPE_RAW:\n\t\tif (ksp->ks_raw_ops.data) {\n\t\t\troot = SYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, ksp->ks_name, CTLTYPE_STRING | CTLFLAG_RD\n\t\t\t    | CTLFLAG_MPSAFE | CTLFLAG_SKIP,\n\t\t\t    ksp, 0, kstat_sysctl_raw, \"A\", ksp->ks_name);\n\t\t} else {\n\t\t\troot = SYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t\t    OID_AUTO, ksp->ks_name, CTLTYPE_OPAQUE | CTLFLAG_RD\n\t\t\t    | CTLFLAG_MPSAFE | CTLFLAG_SKIP,\n\t\t\t    ksp, 0, kstat_sysctl_raw, \"\", ksp->ks_name);\n\t\t}\n\t\tbreak;\n\tcase KSTAT_TYPE_IO:\n\t\troot = SYSCTL_ADD_PROC(&ksp->ks_sysctl_ctx,\n\t\t    SYSCTL_CHILDREN(ksp->ks_sysctl_root),\n\t\t    OID_AUTO, ksp->ks_name,\n\t\t    CTLTYPE_STRING | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t\t    ksp, 0, kstat_sysctl_io, \"A\", ksp->ks_name);\n\t\tbreak;\n\tcase KSTAT_TYPE_TIMER:\n\tcase KSTAT_TYPE_INTR:\n\tdefault:\n\t\tpanic(\"unsupported kstat type %d\\n\", ksp->ks_type);\n\t}\n\tVERIFY3P(root, !=, NULL);\n\tksp->ks_sysctl_root = root;\n}\n\nvoid\nkstat_delete(kstat_t *ksp)\n{\n\n\tsysctl_ctx_free(&ksp->ks_sysctl_ctx);\n\tksp->ks_lock = NULL;\n\tmutex_destroy(&ksp->ks_private_lock);\n\tif (!(ksp->ks_flags & KSTAT_FLAG_VIRTUAL))\n\t\tkmem_free(ksp->ks_data, ksp->ks_data_size);\n\tfree(ksp, M_KSTAT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}