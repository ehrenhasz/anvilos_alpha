{
  "module_name": "spl_zlib.c",
  "hash_id": "2b896b4725264c2af73303920904817bbfecbbffa90386fcc871c6e7e2b4450a",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_zlib.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/kmem.h>\n#include <sys/kmem_cache.h>\n#include <sys/zmod.h>\n#include <contrib/zlib/zlib.h>\n#include <sys/kobj.h>\n\n\nstatic void *\nzcalloc(void *opaque, uint_t items, uint_t size)\n{\n\t(void) opaque;\n\treturn (malloc((size_t)items*size, M_SOLARIS, M_NOWAIT));\n}\n\nstatic void\nzcfree(void *opaque, void *ptr)\n{\n\t(void) opaque;\n\tfree(ptr, M_SOLARIS);\n}\n\nstatic int\nzlib_deflateInit(z_stream *stream, int level)\n{\n\n\tstream->zalloc = zcalloc;\n\tstream->opaque = NULL;\n\tstream->zfree = zcfree;\n\n\treturn (deflateInit(stream, level));\n}\n\nstatic int\nzlib_deflate(z_stream *stream, int flush)\n{\n\treturn (deflate(stream, flush));\n}\n\nstatic int\nzlib_deflateEnd(z_stream *stream)\n{\n\treturn (deflateEnd(stream));\n}\n\nstatic int\nzlib_inflateInit(z_stream *stream)\n{\n\tstream->zalloc = zcalloc;\n\tstream->opaque = NULL;\n\tstream->zfree = zcfree;\n\n\treturn (inflateInit(stream));\n}\n\nstatic int\nzlib_inflate(z_stream *stream, int finish)\n{\n\treturn (inflate(stream, finish));\n}\n\n\nstatic int\nzlib_inflateEnd(z_stream *stream)\n{\n\treturn (inflateEnd(stream));\n}\n\n \nstatic void *\nzlib_workspace_alloc(int flags)\n{\n\t\n\treturn (NULL);\n}\n\nstatic void\nzlib_workspace_free(void *workspace)\n{\n\t\n}\n\n \nint\nz_compress_level(void *dest, size_t *destLen, const void *source,\n    size_t sourceLen, int level)\n{\n\tz_stream stream = {0};\n\tint err;\n\n\tstream.next_in = (Byte *)source;\n\tstream.avail_in = (uInt)sourceLen;\n\tstream.next_out = dest;\n\tstream.avail_out = (uInt)*destLen;\n\tstream.opaque = NULL;\n\n\tif ((size_t)stream.avail_out != *destLen)\n\t\treturn (Z_BUF_ERROR);\n\n\tstream.opaque = zlib_workspace_alloc(KM_SLEEP);\n#if 0\n\tif (!stream.opaque)\n\t\treturn (Z_MEM_ERROR);\n#endif\n\terr = zlib_deflateInit(&stream, level);\n\tif (err != Z_OK) {\n\t\tzlib_workspace_free(stream.opaque);\n\t\treturn (err);\n\t}\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END) {\n\t\tzlib_deflateEnd(&stream);\n\t\tzlib_workspace_free(stream.opaque);\n\t\treturn (err == Z_OK ? Z_BUF_ERROR : err);\n\t}\n\t*destLen = stream.total_out;\n\n\terr = zlib_deflateEnd(&stream);\n\tzlib_workspace_free(stream.opaque);\n\treturn (err);\n}\n\n \nint\nz_uncompress(void *dest, size_t *destLen, const void *source, size_t sourceLen)\n{\n\tz_stream stream = {0};\n\tint err;\n\n\tstream.next_in = (Byte *)source;\n\tstream.avail_in = (uInt)sourceLen;\n\tstream.next_out = dest;\n\tstream.avail_out = (uInt)*destLen;\n\n\tif ((size_t)stream.avail_out != *destLen)\n\t\treturn (Z_BUF_ERROR);\n\n\tstream.opaque = zlib_workspace_alloc(KM_SLEEP);\n#if 0\n\tif (!stream.opaque)\n\t\treturn (Z_MEM_ERROR);\n#endif\n\terr = zlib_inflateInit(&stream);\n\tif (err != Z_OK) {\n\t\tzlib_workspace_free(stream.opaque);\n\t\treturn (err);\n\t}\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END) {\n\t\tzlib_inflateEnd(&stream);\n\t\tzlib_workspace_free(stream.opaque);\n\n\t\tif (err == Z_NEED_DICT ||\n\t\t    (err == Z_BUF_ERROR && stream.avail_in == 0))\n\t\t\treturn (Z_DATA_ERROR);\n\n\t\treturn (err);\n\t}\n\t*destLen = stream.total_out;\n\n\terr = zlib_inflateEnd(&stream);\n\tzlib_workspace_free(stream.opaque);\n\n\treturn (err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}