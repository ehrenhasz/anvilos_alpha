{
  "module_name": "spl_taskq.c",
  "hash_id": "3d97d5f93b9df9ab115673b55ce7858c519fd6deb51b1a8215938237067b8eec",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_taskq.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/kmem.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n#include <sys/queue.h>\n#include <sys/taskq.h>\n#include <sys/taskqueue.h>\n#include <sys/zfs_context.h>\n\n#if defined(__i386__) || defined(__amd64__) || defined(__aarch64__)\n#include <machine/pcb.h>\n#endif\n\n#include <vm/uma.h>\n\n#if __FreeBSD_version < 1201522\n#define\ttaskqueue_start_threads_in_proc(tqp, count, pri, proc, name, ...) \\\n    taskqueue_start_threads(tqp, count, pri, name, __VA_ARGS__)\n#endif\n\nstatic uint_t taskq_tsd;\nstatic uma_zone_t taskq_zone;\n\n \ntaskq_t *system_taskq = NULL;\ntaskq_t *system_delay_taskq = NULL;\ntaskq_t *dynamic_taskq = NULL;\n\nproc_t *system_proc;\n\nstatic MALLOC_DEFINE(M_TASKQ, \"taskq\", \"taskq structures\");\n\nstatic LIST_HEAD(tqenthashhead, taskq_ent) *tqenthashtbl;\nstatic unsigned long tqenthash;\nstatic unsigned long tqenthashlock;\nstatic struct sx *tqenthashtbl_lock;\n\nstatic taskqid_t tqidnext;\n\n#define\tTQIDHASH(tqid) (&tqenthashtbl[(tqid) & tqenthash])\n#define\tTQIDHASHLOCK(tqid) (&tqenthashtbl_lock[((tqid) & tqenthashlock)])\n\n#define\tNORMAL_TASK 0\n#define\tTIMEOUT_TASK 1\n\nstatic void\nsystem_taskq_init(void *arg)\n{\n\tint i;\n\n\ttsd_create(&taskq_tsd, NULL);\n\ttqenthashtbl = hashinit(mp_ncpus * 8, M_TASKQ, &tqenthash);\n\ttqenthashlock = (tqenthash + 1) / 8;\n\tif (tqenthashlock > 0)\n\t\ttqenthashlock--;\n\ttqenthashtbl_lock =\n\t    malloc(sizeof (*tqenthashtbl_lock) * (tqenthashlock + 1),\n\t    M_TASKQ, M_WAITOK | M_ZERO);\n\tfor (i = 0; i < tqenthashlock + 1; i++)\n\t\tsx_init_flags(&tqenthashtbl_lock[i], \"tqenthash\", SX_DUPOK);\n\ttaskq_zone = uma_zcreate(\"taskq_zone\", sizeof (taskq_ent_t),\n\t    NULL, NULL, NULL, NULL,\n\t    UMA_ALIGN_CACHE, 0);\n\tsystem_taskq = taskq_create(\"system_taskq\", mp_ncpus, minclsyspri,\n\t    0, 0, 0);\n\tsystem_delay_taskq = taskq_create(\"system_delay_taskq\", mp_ncpus,\n\t    minclsyspri, 0, 0, 0);\n}\nSYSINIT(system_taskq_init, SI_SUB_CONFIGURE, SI_ORDER_ANY, system_taskq_init,\n    NULL);\n\nstatic void\nsystem_taskq_fini(void *arg)\n{\n\tint i;\n\n\ttaskq_destroy(system_delay_taskq);\n\ttaskq_destroy(system_taskq);\n\tuma_zdestroy(taskq_zone);\n\ttsd_destroy(&taskq_tsd);\n\tfor (i = 0; i < tqenthashlock + 1; i++)\n\t\tsx_destroy(&tqenthashtbl_lock[i]);\n\tfor (i = 0; i < tqenthash + 1; i++)\n\t\tVERIFY(LIST_EMPTY(&tqenthashtbl[i]));\n\tfree(tqenthashtbl_lock, M_TASKQ);\n\tfree(tqenthashtbl, M_TASKQ);\n}\nSYSUNINIT(system_taskq_fini, SI_SUB_CONFIGURE, SI_ORDER_ANY, system_taskq_fini,\n    NULL);\n\n#ifdef __LP64__\nstatic taskqid_t\n__taskq_genid(void)\n{\n\ttaskqid_t tqid;\n\n\t \n\ttqid = atomic_add_64_nv(&tqidnext, 1);\n\tVERIFY(tqid);\n\treturn (tqid);\n}\n#else\nstatic taskqid_t\n__taskq_genid(void)\n{\n\ttaskqid_t tqid;\n\n\tfor (;;) {\n\t\ttqid = atomic_add_32_nv(&tqidnext, 1);\n\t\tif (__predict_true(tqid != 0))\n\t\t\tbreak;\n\t}\n\tVERIFY(tqid);\n\treturn (tqid);\n}\n#endif\n\nstatic taskq_ent_t *\ntaskq_lookup(taskqid_t tqid)\n{\n\ttaskq_ent_t *ent = NULL;\n\n\tif (tqid == 0)\n\t\treturn (NULL);\n\tsx_slock(TQIDHASHLOCK(tqid));\n\tLIST_FOREACH(ent, TQIDHASH(tqid), tqent_hash) {\n\t\tif (ent->tqent_id == tqid)\n\t\t\tbreak;\n\t}\n\tif (ent != NULL)\n\t\trefcount_acquire(&ent->tqent_rc);\n\tsx_sunlock(TQIDHASHLOCK(tqid));\n\treturn (ent);\n}\n\nstatic taskqid_t\ntaskq_insert(taskq_ent_t *ent)\n{\n\ttaskqid_t tqid = __taskq_genid();\n\n\tent->tqent_id = tqid;\n\tsx_xlock(TQIDHASHLOCK(tqid));\n\tLIST_INSERT_HEAD(TQIDHASH(tqid), ent, tqent_hash);\n\tsx_xunlock(TQIDHASHLOCK(tqid));\n\treturn (tqid);\n}\n\nstatic void\ntaskq_remove(taskq_ent_t *ent)\n{\n\ttaskqid_t tqid = ent->tqent_id;\n\n\tif (tqid == 0)\n\t\treturn;\n\tsx_xlock(TQIDHASHLOCK(tqid));\n\tif (ent->tqent_id != 0) {\n\t\tLIST_REMOVE(ent, tqent_hash);\n\t\tent->tqent_id = 0;\n\t}\n\tsx_xunlock(TQIDHASHLOCK(tqid));\n}\n\nstatic void\ntaskq_tsd_set(void *context)\n{\n\ttaskq_t *tq = context;\n\n#if defined(__amd64__) || defined(__i386__) || defined(__aarch64__)\n\tif (context != NULL && tsd_get(taskq_tsd) == NULL)\n\t\tfpu_kern_thread(FPU_KERN_NORMAL);\n#endif\n\ttsd_set(taskq_tsd, tq);\n}\n\nstatic taskq_t *\ntaskq_create_impl(const char *name, int nthreads, pri_t pri,\n    proc_t *proc __maybe_unused, uint_t flags)\n{\n\ttaskq_t *tq;\n\n\tif ((flags & TASKQ_THREADS_CPU_PCT) != 0)\n\t\tnthreads = MAX((mp_ncpus * nthreads) / 100, 1);\n\n\ttq = kmem_alloc(sizeof (*tq), KM_SLEEP);\n\ttq->tq_queue = taskqueue_create(name, M_WAITOK,\n\t    taskqueue_thread_enqueue, &tq->tq_queue);\n\ttaskqueue_set_callback(tq->tq_queue, TASKQUEUE_CALLBACK_TYPE_INIT,\n\t    taskq_tsd_set, tq);\n\ttaskqueue_set_callback(tq->tq_queue, TASKQUEUE_CALLBACK_TYPE_SHUTDOWN,\n\t    taskq_tsd_set, NULL);\n\t(void) taskqueue_start_threads_in_proc(&tq->tq_queue, nthreads, pri,\n\t    proc, \"%s\", name);\n\n\treturn ((taskq_t *)tq);\n}\n\ntaskq_t *\ntaskq_create(const char *name, int nthreads, pri_t pri, int minalloc __unused,\n    int maxalloc __unused, uint_t flags)\n{\n\treturn (taskq_create_impl(name, nthreads, pri, system_proc, flags));\n}\n\ntaskq_t *\ntaskq_create_proc(const char *name, int nthreads, pri_t pri,\n    int minalloc __unused, int maxalloc __unused, proc_t *proc, uint_t flags)\n{\n\treturn (taskq_create_impl(name, nthreads, pri, proc, flags));\n}\n\nvoid\ntaskq_destroy(taskq_t *tq)\n{\n\n\ttaskqueue_free(tq->tq_queue);\n\tkmem_free(tq, sizeof (*tq));\n}\n\nint\ntaskq_member(taskq_t *tq, kthread_t *thread)\n{\n\n\treturn (taskqueue_member(tq->tq_queue, thread));\n}\n\ntaskq_t *\ntaskq_of_curthread(void)\n{\n\treturn (tsd_get(taskq_tsd));\n}\n\nstatic void\ntaskq_free(taskq_ent_t *task)\n{\n\ttaskq_remove(task);\n\tif (refcount_release(&task->tqent_rc))\n\t\tuma_zfree(taskq_zone, task);\n}\n\nint\ntaskq_cancel_id(taskq_t *tq, taskqid_t tid)\n{\n\tuint32_t pend;\n\tint rc;\n\ttaskq_ent_t *ent;\n\n\tif ((ent = taskq_lookup(tid)) == NULL)\n\t\treturn (0);\n\n\tif (ent->tqent_type == NORMAL_TASK) {\n\t\trc = taskqueue_cancel(tq->tq_queue, &ent->tqent_task, &pend);\n\t\tif (rc == EBUSY)\n\t\t\ttaskqueue_drain(tq->tq_queue, &ent->tqent_task);\n\t} else {\n\t\trc = taskqueue_cancel_timeout(tq->tq_queue,\n\t\t    &ent->tqent_timeout_task, &pend);\n\t\tif (rc == EBUSY) {\n\t\t\ttaskqueue_drain_timeout(tq->tq_queue,\n\t\t\t    &ent->tqent_timeout_task);\n\t\t}\n\t}\n\tif (pend) {\n\t\t \n\t\ttaskq_free(ent);\n\t}\n\t \n\ttaskq_free(ent);\n\treturn (rc);\n}\n\nstatic void\ntaskq_run(void *arg, int pending)\n{\n\ttaskq_ent_t *task = arg;\n\n\tif (pending == 0)\n\t\treturn;\n\ttask->tqent_func(task->tqent_arg);\n\ttaskq_free(task);\n}\n\ntaskqid_t\ntaskq_dispatch_delay(taskq_t *tq, task_func_t func, void *arg,\n    uint_t flags, clock_t expire_time)\n{\n\ttaskq_ent_t *task;\n\ttaskqid_t tqid;\n\tclock_t timo;\n\tint mflag;\n\n\ttimo = expire_time - ddi_get_lbolt();\n\tif (timo <= 0)\n\t\treturn (taskq_dispatch(tq, func, arg, flags));\n\n\tif ((flags & (TQ_SLEEP | TQ_NOQUEUE)) == TQ_SLEEP)\n\t\tmflag = M_WAITOK;\n\telse\n\t\tmflag = M_NOWAIT;\n\n\ttask = uma_zalloc(taskq_zone, mflag);\n\tif (task == NULL)\n\t\treturn (0);\n\ttask->tqent_func = func;\n\ttask->tqent_arg = arg;\n\ttask->tqent_type = TIMEOUT_TASK;\n\trefcount_init(&task->tqent_rc, 1);\n\ttqid = taskq_insert(task);\n\tTIMEOUT_TASK_INIT(tq->tq_queue, &task->tqent_timeout_task, 0,\n\t    taskq_run, task);\n\n\ttaskqueue_enqueue_timeout(tq->tq_queue, &task->tqent_timeout_task,\n\t    timo);\n\treturn (tqid);\n}\n\ntaskqid_t\ntaskq_dispatch(taskq_t *tq, task_func_t func, void *arg, uint_t flags)\n{\n\ttaskq_ent_t *task;\n\tint mflag, prio;\n\ttaskqid_t tqid;\n\n\tif ((flags & (TQ_SLEEP | TQ_NOQUEUE)) == TQ_SLEEP)\n\t\tmflag = M_WAITOK;\n\telse\n\t\tmflag = M_NOWAIT;\n\t \n\tprio = !!(flags & TQ_FRONT);\n\n\ttask = uma_zalloc(taskq_zone, mflag);\n\tif (task == NULL)\n\t\treturn (0);\n\trefcount_init(&task->tqent_rc, 1);\n\ttask->tqent_func = func;\n\ttask->tqent_arg = arg;\n\ttask->tqent_type = NORMAL_TASK;\n\ttqid = taskq_insert(task);\n\tTASK_INIT(&task->tqent_task, prio, taskq_run, task);\n\ttaskqueue_enqueue(tq->tq_queue, &task->tqent_task);\n\treturn (tqid);\n}\n\nstatic void\ntaskq_run_ent(void *arg, int pending)\n{\n\ttaskq_ent_t *task = arg;\n\n\tif (pending == 0)\n\t\treturn;\n\ttask->tqent_func(task->tqent_arg);\n}\n\nvoid\ntaskq_dispatch_ent(taskq_t *tq, task_func_t func, void *arg, uint32_t flags,\n    taskq_ent_t *task)\n{\n\tint prio;\n\n\t \n\tprio = !!(flags & TQ_FRONT);\n\ttask->tqent_id = 0;\n\ttask->tqent_func = func;\n\ttask->tqent_arg = arg;\n\n\tTASK_INIT(&task->tqent_task, prio, taskq_run_ent, task);\n\ttaskqueue_enqueue(tq->tq_queue, &task->tqent_task);\n}\n\nvoid\ntaskq_wait(taskq_t *tq)\n{\n\ttaskqueue_quiesce(tq->tq_queue);\n}\n\nvoid\ntaskq_wait_id(taskq_t *tq, taskqid_t tid)\n{\n\ttaskq_ent_t *ent;\n\n\tif ((ent = taskq_lookup(tid)) == NULL)\n\t\treturn;\n\n\tif (ent->tqent_type == NORMAL_TASK)\n\t\ttaskqueue_drain(tq->tq_queue, &ent->tqent_task);\n\telse\n\t\ttaskqueue_drain_timeout(tq->tq_queue, &ent->tqent_timeout_task);\n\ttaskq_free(ent);\n}\n\nvoid\ntaskq_wait_outstanding(taskq_t *tq, taskqid_t id __unused)\n{\n\ttaskqueue_drain_all(tq->tq_queue);\n}\n\nint\ntaskq_empty_ent(taskq_ent_t *t)\n{\n\treturn (t->tqent_task.ta_pending == 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}