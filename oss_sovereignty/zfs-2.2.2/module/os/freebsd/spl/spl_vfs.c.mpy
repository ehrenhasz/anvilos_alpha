{
  "module_name": "spl_vfs.c",
  "hash_id": "dff216eebd5544d99a6d03bc45fd7f4018311058463992773d8fe100f2423ba1",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_vfs.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/mount.h>\n#include <sys/cred.h>\n#include <sys/vfs.h>\n#include <sys/priv.h>\n#include <sys/libkern.h>\n\n#include <sys/mutex.h>\n#include <sys/vnode.h>\n#include <sys/taskq.h>\n\n#include <sys/ccompat.h>\n\nMALLOC_DECLARE(M_MOUNT);\n\nvoid\nvfs_setmntopt(vfs_t *vfsp, const char *name, const char *arg,\n    int flags __unused)\n{\n\tstruct vfsopt *opt;\n\tsize_t namesize;\n\tint locked;\n\n\tif (!(locked = mtx_owned(MNT_MTX(vfsp))))\n\t\tMNT_ILOCK(vfsp);\n\n\tif (vfsp->mnt_opt == NULL) {\n\t\tvoid *opts;\n\n\t\tMNT_IUNLOCK(vfsp);\n\t\topts = malloc(sizeof (*vfsp->mnt_opt), M_MOUNT, M_WAITOK);\n\t\tMNT_ILOCK(vfsp);\n\t\tif (vfsp->mnt_opt == NULL) {\n\t\t\tvfsp->mnt_opt = opts;\n\t\t\tTAILQ_INIT(vfsp->mnt_opt);\n\t\t} else {\n\t\t\tfree(opts, M_MOUNT);\n\t\t}\n\t}\n\n\tMNT_IUNLOCK(vfsp);\n\n\topt = malloc(sizeof (*opt), M_MOUNT, M_WAITOK);\n\tnamesize = strlen(name) + 1;\n\topt->name = malloc(namesize, M_MOUNT, M_WAITOK);\n\tstrlcpy(opt->name, name, namesize);\n\topt->pos = -1;\n\topt->seen = 1;\n\tif (arg == NULL) {\n\t\topt->value = NULL;\n\t\topt->len = 0;\n\t} else {\n\t\topt->len = strlen(arg) + 1;\n\t\topt->value = malloc(opt->len, M_MOUNT, M_WAITOK);\n\t\tmemcpy(opt->value, arg, opt->len);\n\t}\n\n\tMNT_ILOCK(vfsp);\n\tTAILQ_INSERT_TAIL(vfsp->mnt_opt, opt, link);\n\tif (!locked)\n\t\tMNT_IUNLOCK(vfsp);\n}\n\nvoid\nvfs_clearmntopt(vfs_t *vfsp, const char *name)\n{\n\tint locked;\n\n\tif (!(locked = mtx_owned(MNT_MTX(vfsp))))\n\t\tMNT_ILOCK(vfsp);\n\tvfs_deleteopt(vfsp->mnt_opt, name);\n\tif (!locked)\n\t\tMNT_IUNLOCK(vfsp);\n}\n\nint\nvfs_optionisset(const vfs_t *vfsp, const char *opt, char **argp)\n{\n\tstruct vfsoptlist *opts = vfsp->mnt_optnew;\n\tint error;\n\n\tif (opts == NULL)\n\t\treturn (0);\n\terror = vfs_getopt(opts, opt, (void **)argp, NULL);\n\treturn (error != 0 ? 0 : 1);\n}\n\nint\nmount_snapshot(kthread_t *td, vnode_t **vpp, const char *fstype, char *fspath,\n    char *fspec, int fsflags, vfs_t *parent_vfsp)\n{\n\tstruct vfsconf *vfsp;\n\tstruct mount *mp;\n\tvnode_t *vp, *mvp;\n\tint error;\n\n\tASSERT_VOP_ELOCKED(*vpp, \"mount_snapshot\");\n\n\tvp = *vpp;\n\t*vpp = NULL;\n\terror = 0;\n\n\t \n\tif (strlen(fstype) >= MFSNAMELEN || strlen(fspath) >= MNAMELEN)\n\t\terror = ENAMETOOLONG;\n\tif (error == 0 && (vfsp = vfs_byname_kld(fstype, td, &error)) == NULL)\n\t\terror = ENODEV;\n\tif (error == 0 && vp->v_type != VDIR)\n\t\terror = ENOTDIR;\n\t \n\tif (error == 0) {\n\t\tVI_LOCK(vp);\n\t\tif ((vp->v_iflag & VI_MOUNT) == 0 && vp->v_mountedhere == NULL)\n\t\t\tvp->v_iflag |= VI_MOUNT;\n\t\telse\n\t\t\terror = EBUSY;\n\t\tVI_UNLOCK(vp);\n\t}\n\tif (error != 0) {\n\t\tvput(vp);\n\t\treturn (error);\n\t}\n\tvn_seqc_write_begin(vp);\n\tVOP_UNLOCK1(vp);\n\n\t \n\tmp = vfs_mount_alloc(vp, vfsp, fspath, vp->v_mount->mnt_cred);\n\n\tmp->mnt_optnew = NULL;\n\tvfs_setmntopt(mp, \"from\", fspec, 0);\n\tmp->mnt_optnew = mp->mnt_opt;\n\tmp->mnt_opt = NULL;\n\n\t \n\tmp->mnt_flag = fsflags & MNT_UPDATEMASK;\n\t \n\tmp->mnt_flag |= MNT_RDONLY;\n\t \n\tmp->mnt_flag |= MNT_NOSUID;\n\t \n\tmp->mnt_flag |= MNT_IGNORE;\n\n\terror = VFS_MOUNT(mp);\n\tif (error != 0) {\n\t\t \n\t\tvn_lock(vp, LK_EXCLUSIVE | LK_RETRY);\n\t\tVI_LOCK(vp);\n\t\tvp->v_iflag &= ~VI_MOUNT;\n\t\tVI_UNLOCK(vp);\n\t\tvn_seqc_write_end(vp);\n\t\tvput(vp);\n\t\tvfs_unbusy(mp);\n\t\tvfs_freeopts(mp->mnt_optnew);\n\t\tmp->mnt_vnodecovered = NULL;\n\t\tvfs_mount_destroy(mp);\n\t\treturn (error);\n\t}\n\n\tif (mp->mnt_opt != NULL)\n\t\tvfs_freeopts(mp->mnt_opt);\n\tmp->mnt_opt = mp->mnt_optnew;\n\t(void) VFS_STATFS(mp, &mp->mnt_stat);\n\n#ifdef VFS_SUPPORTS_EXJAIL_CLONE\n\t \n\tvfs_exjail_clone(parent_vfsp, mp);\n#endif\n\n\t \n\tmp->mnt_optnew = NULL;\n\n\tvn_lock(vp, LK_EXCLUSIVE | LK_RETRY);\n#ifdef FREEBSD_NAMECACHE\n\tcache_purge(vp);\n#endif\n\tVI_LOCK(vp);\n\tvp->v_iflag &= ~VI_MOUNT;\n#ifdef VIRF_MOUNTPOINT\n\tvn_irflag_set_locked(vp, VIRF_MOUNTPOINT);\n#endif\n\tvp->v_mountedhere = mp;\n\tVI_UNLOCK(vp);\n\t \n\tmtx_lock(&mountlist_mtx);\n\tTAILQ_INSERT_TAIL(&mountlist, mp, mnt_list);\n\tmtx_unlock(&mountlist_mtx);\n\tvfs_event_signal(NULL, VQ_MOUNT, 0);\n\tif (VFS_ROOT(mp, LK_EXCLUSIVE, &mvp))\n\t\tpanic(\"mount: lost mount\");\n\tvn_seqc_write_end(vp);\n\tVOP_UNLOCK1(vp);\n#if __FreeBSD_version >= 1300048\n\tvfs_op_exit(mp);\n#endif\n\tvfs_unbusy(mp);\n\t*vpp = mvp;\n\treturn (0);\n}\n\n \nvoid\nvn_rele_async(vnode_t *vp, taskq_t *taskq)\n{\n\tVERIFY3U(vp->v_usecount, >, 0);\n\tif (refcount_release_if_not_last(&vp->v_usecount)) {\n#if __FreeBSD_version < 1300045\n\t\tvdrop(vp);\n#endif\n\t\treturn;\n\t}\n\tVERIFY3U(taskq_dispatch((taskq_t *)taskq,\n\t    (task_func_t *)vrele, vp, TQ_SLEEP), !=, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}