{
  "module_name": "spl_acl.c",
  "hash_id": "92a9f2b971edf217f31f8b28176b0673b20210b18693812f4ef3d879ac36b419",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_acl.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/types.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/zfs_acl.h>\n#include <sys/acl.h>\n\nstruct zfs2bsd {\n\tuint32_t\tzb_zfs;\n\tint\t\tzb_bsd;\n};\n\nstatic const struct zfs2bsd perms[] = {{ACE_READ_DATA, ACL_READ_DATA},\n\t\t\t{ACE_WRITE_DATA, ACL_WRITE_DATA},\n\t\t\t{ACE_EXECUTE, ACL_EXECUTE},\n\t\t\t{ACE_APPEND_DATA, ACL_APPEND_DATA},\n\t\t\t{ACE_DELETE_CHILD, ACL_DELETE_CHILD},\n\t\t\t{ACE_DELETE, ACL_DELETE},\n\t\t\t{ACE_READ_ATTRIBUTES, ACL_READ_ATTRIBUTES},\n\t\t\t{ACE_WRITE_ATTRIBUTES, ACL_WRITE_ATTRIBUTES},\n\t\t\t{ACE_READ_NAMED_ATTRS, ACL_READ_NAMED_ATTRS},\n\t\t\t{ACE_WRITE_NAMED_ATTRS, ACL_WRITE_NAMED_ATTRS},\n\t\t\t{ACE_READ_ACL, ACL_READ_ACL},\n\t\t\t{ACE_WRITE_ACL, ACL_WRITE_ACL},\n\t\t\t{ACE_WRITE_OWNER, ACL_WRITE_OWNER},\n\t\t\t{ACE_SYNCHRONIZE, ACL_SYNCHRONIZE},\n\t\t\t{0, 0}};\n\nstatic const struct zfs2bsd flags[] = {{ACE_FILE_INHERIT_ACE,\n\t\t\t    ACL_ENTRY_FILE_INHERIT},\n\t\t\t{ACE_DIRECTORY_INHERIT_ACE,\n\t\t\t    ACL_ENTRY_DIRECTORY_INHERIT},\n\t\t\t{ACE_NO_PROPAGATE_INHERIT_ACE,\n\t\t\t    ACL_ENTRY_NO_PROPAGATE_INHERIT},\n\t\t\t{ACE_INHERIT_ONLY_ACE,\n\t\t\t    ACL_ENTRY_INHERIT_ONLY},\n\t\t\t{ACE_INHERITED_ACE,\n\t\t\t    ACL_ENTRY_INHERITED},\n\t\t\t{ACE_SUCCESSFUL_ACCESS_ACE_FLAG,\n\t\t\t    ACL_ENTRY_SUCCESSFUL_ACCESS},\n\t\t\t{ACE_FAILED_ACCESS_ACE_FLAG,\n\t\t\t    ACL_ENTRY_FAILED_ACCESS},\n\t\t\t{0, 0}};\n\nstatic int\n_bsd_from_zfs(uint32_t zfs, const struct zfs2bsd *table)\n{\n\tconst struct zfs2bsd *tmp;\n\tint bsd = 0;\n\n\tfor (tmp = table; tmp->zb_zfs != 0; tmp++) {\n\t\tif (zfs & tmp->zb_zfs)\n\t\t\tbsd |= tmp->zb_bsd;\n\t}\n\n\treturn (bsd);\n}\n\nstatic uint32_t\n_zfs_from_bsd(int bsd, const struct zfs2bsd *table)\n{\n\tconst struct zfs2bsd *tmp;\n\tuint32_t zfs = 0;\n\n\tfor (tmp = table; tmp->zb_bsd != 0; tmp++) {\n\t\tif (bsd & tmp->zb_bsd)\n\t\t\tzfs |= tmp->zb_zfs;\n\t}\n\n\treturn (zfs);\n}\n\nint\nacl_from_aces(struct acl *aclp, const ace_t *aces, int nentries)\n{\n\tint i;\n\tstruct acl_entry *entry;\n\tconst ace_t *ace;\n\n\tif (nentries < 1) {\n\t\tprintf(\"acl_from_aces: empty ZFS ACL; returning EINVAL.\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tif (nentries > ACL_MAX_ENTRIES) {\n\t\t \n\t\tprintf(\"acl_from_aces: ZFS ACL too big to fit \"\n\t\t    \"into 'struct acl'; returning EINVAL.\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tmemset(aclp, 0, sizeof (*aclp));\n\taclp->acl_maxcnt = ACL_MAX_ENTRIES;\n\taclp->acl_cnt = nentries;\n\n\tfor (i = 0; i < nentries; i++) {\n\t\tentry = &(aclp->acl_entry[i]);\n\t\tace = &(aces[i]);\n\n\t\tif (ace->a_flags & ACE_OWNER)\n\t\t\tentry->ae_tag = ACL_USER_OBJ;\n\t\telse if (ace->a_flags & ACE_GROUP)\n\t\t\tentry->ae_tag = ACL_GROUP_OBJ;\n\t\telse if (ace->a_flags & ACE_EVERYONE)\n\t\t\tentry->ae_tag = ACL_EVERYONE;\n\t\telse if (ace->a_flags & ACE_IDENTIFIER_GROUP)\n\t\t\tentry->ae_tag = ACL_GROUP;\n\t\telse\n\t\t\tentry->ae_tag = ACL_USER;\n\n\t\tif (entry->ae_tag == ACL_USER || entry->ae_tag == ACL_GROUP)\n\t\t\tentry->ae_id = ace->a_who;\n\t\telse\n\t\t\tentry->ae_id = ACL_UNDEFINED_ID;\n\n\t\tentry->ae_perm = _bsd_from_zfs(ace->a_access_mask, perms);\n\t\tentry->ae_flags = _bsd_from_zfs(ace->a_flags, flags);\n\n\t\tswitch (ace->a_type) {\n\t\tcase ACE_ACCESS_ALLOWED_ACE_TYPE:\n\t\t\tentry->ae_entry_type = ACL_ENTRY_TYPE_ALLOW;\n\t\t\tbreak;\n\t\tcase ACE_ACCESS_DENIED_ACE_TYPE:\n\t\t\tentry->ae_entry_type = ACL_ENTRY_TYPE_DENY;\n\t\t\tbreak;\n\t\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:\n\t\t\tentry->ae_entry_type = ACL_ENTRY_TYPE_AUDIT;\n\t\t\tbreak;\n\t\tcase ACE_SYSTEM_ALARM_ACE_TYPE:\n\t\t\tentry->ae_entry_type = ACL_ENTRY_TYPE_ALARM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"acl_from_aces: a_type is 0x%x\", ace->a_type);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\nvoid\naces_from_acl(ace_t *aces, int *nentries, const struct acl *aclp)\n{\n\tint i;\n\tconst struct acl_entry *entry;\n\tace_t *ace;\n\n\tmemset(aces, 0, sizeof (*aces) * aclp->acl_cnt);\n\n\t*nentries = aclp->acl_cnt;\n\n\tfor (i = 0; i < aclp->acl_cnt; i++) {\n\t\tentry = &(aclp->acl_entry[i]);\n\t\tace = &(aces[i]);\n\n\t\tace->a_who = entry->ae_id;\n\n\t\tif (entry->ae_tag == ACL_USER_OBJ)\n\t\t\tace->a_flags = ACE_OWNER;\n\t\telse if (entry->ae_tag == ACL_GROUP_OBJ)\n\t\t\tace->a_flags = (ACE_GROUP | ACE_IDENTIFIER_GROUP);\n\t\telse if (entry->ae_tag == ACL_GROUP)\n\t\t\tace->a_flags = ACE_IDENTIFIER_GROUP;\n\t\telse if (entry->ae_tag == ACL_EVERYONE)\n\t\t\tace->a_flags = ACE_EVERYONE;\n\t\telse  \n\t\t\tace->a_flags = 0;\n\n\t\tace->a_access_mask = _zfs_from_bsd(entry->ae_perm, perms);\n\t\tace->a_flags |= _zfs_from_bsd(entry->ae_flags, flags);\n\n\t\tswitch (entry->ae_entry_type) {\n\t\tcase ACL_ENTRY_TYPE_ALLOW:\n\t\t\tace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\tbreak;\n\t\tcase ACL_ENTRY_TYPE_DENY:\n\t\t\tace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tbreak;\n\t\tcase ACL_ENTRY_TYPE_ALARM:\n\t\t\tace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;\n\t\t\tbreak;\n\t\tcase ACL_ENTRY_TYPE_AUDIT:\n\t\t\tace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"aces_from_acl: ae_entry_type is 0x%x\",\n\t\t\t    entry->ae_entry_type);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}