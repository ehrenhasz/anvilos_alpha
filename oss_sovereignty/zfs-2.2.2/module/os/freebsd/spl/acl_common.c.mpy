{
  "module_name": "acl_common.c",
  "hash_id": "17142e77ddf3652c20fa03199f3ec3fa7dd3923e8154e755a56afac91e27d38c",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/acl_common.c",
  "human_readable_source": " \n \n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/avl.h>\n#include <sys/misc.h>\n#if defined(_KERNEL)\n#include <sys/kmem.h>\n#include <sys/systm.h>\n#include <sys/sysmacros.h>\n#include <acl/acl_common.h>\n#include <sys/debug.h>\n#else\n#include <errno.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <assert.h>\n#include <grp.h>\n#include <pwd.h>\n#include <acl_common.h>\n#endif\n\n#define\tACE_POSIX_SUPPORTED_BITS (ACE_READ_DATA | \\\n    ACE_WRITE_DATA | ACE_APPEND_DATA | ACE_EXECUTE | \\\n    ACE_READ_ATTRIBUTES | ACE_READ_ACL | ACE_WRITE_ACL)\n\n\n#define\tACL_SYNCHRONIZE_SET_DENY\t\t0x0000001\n#define\tACL_SYNCHRONIZE_SET_ALLOW\t\t0x0000002\n#define\tACL_SYNCHRONIZE_ERR_DENY\t\t0x0000004\n#define\tACL_SYNCHRONIZE_ERR_ALLOW\t\t0x0000008\n\n#define\tACL_WRITE_OWNER_SET_DENY\t\t0x0000010\n#define\tACL_WRITE_OWNER_SET_ALLOW\t\t0x0000020\n#define\tACL_WRITE_OWNER_ERR_DENY\t\t0x0000040\n#define\tACL_WRITE_OWNER_ERR_ALLOW\t\t0x0000080\n\n#define\tACL_DELETE_SET_DENY\t\t\t0x0000100\n#define\tACL_DELETE_SET_ALLOW\t\t\t0x0000200\n#define\tACL_DELETE_ERR_DENY\t\t\t0x0000400\n#define\tACL_DELETE_ERR_ALLOW\t\t\t0x0000800\n\n#define\tACL_WRITE_ATTRS_OWNER_SET_DENY\t\t0x0001000\n#define\tACL_WRITE_ATTRS_OWNER_SET_ALLOW\t\t0x0002000\n#define\tACL_WRITE_ATTRS_OWNER_ERR_DENY\t\t0x0004000\n#define\tACL_WRITE_ATTRS_OWNER_ERR_ALLOW\t\t0x0008000\n\n#define\tACL_WRITE_ATTRS_WRITER_SET_DENY\t\t0x0010000\n#define\tACL_WRITE_ATTRS_WRITER_SET_ALLOW\t0x0020000\n#define\tACL_WRITE_ATTRS_WRITER_ERR_DENY\t\t0x0040000\n#define\tACL_WRITE_ATTRS_WRITER_ERR_ALLOW\t0x0080000\n\n#define\tACL_WRITE_NAMED_WRITER_SET_DENY\t\t0x0100000\n#define\tACL_WRITE_NAMED_WRITER_SET_ALLOW\t0x0200000\n#define\tACL_WRITE_NAMED_WRITER_ERR_DENY\t\t0x0400000\n#define\tACL_WRITE_NAMED_WRITER_ERR_ALLOW\t0x0800000\n\n#define\tACL_READ_NAMED_READER_SET_DENY\t\t0x1000000\n#define\tACL_READ_NAMED_READER_SET_ALLOW\t\t0x2000000\n#define\tACL_READ_NAMED_READER_ERR_DENY\t\t0x4000000\n#define\tACL_READ_NAMED_READER_ERR_ALLOW\t\t0x8000000\n\n\n#define\tACE_VALID_MASK_BITS (\\\n    ACE_READ_DATA | \\\n    ACE_LIST_DIRECTORY | \\\n    ACE_WRITE_DATA | \\\n    ACE_ADD_FILE | \\\n    ACE_APPEND_DATA | \\\n    ACE_ADD_SUBDIRECTORY | \\\n    ACE_READ_NAMED_ATTRS | \\\n    ACE_WRITE_NAMED_ATTRS | \\\n    ACE_EXECUTE | \\\n    ACE_DELETE_CHILD | \\\n    ACE_READ_ATTRIBUTES | \\\n    ACE_WRITE_ATTRIBUTES | \\\n    ACE_DELETE | \\\n    ACE_READ_ACL | \\\n    ACE_WRITE_ACL | \\\n    ACE_WRITE_OWNER | \\\n    ACE_SYNCHRONIZE)\n\n#define\tACE_MASK_UNDEFINED\t\t\t0x80000000\n\n#define\tACE_VALID_FLAG_BITS (ACE_FILE_INHERIT_ACE | \\\n    ACE_DIRECTORY_INHERIT_ACE | \\\n    ACE_NO_PROPAGATE_INHERIT_ACE | ACE_INHERIT_ONLY_ACE | \\\n    ACE_SUCCESSFUL_ACCESS_ACE_FLAG | ACE_FAILED_ACCESS_ACE_FLAG | \\\n    ACE_IDENTIFIER_GROUP | ACE_OWNER | ACE_GROUP | ACE_EVERYONE)\n\n \n\ntypedef enum {\n\tace_unused,\n\tace_user_obj,\n\tace_user,\n\tace_group,  \n\tace_other_obj\n} ace_to_aent_state_t;\n\ntypedef struct acevals {\n\tuid_t key;\n\tavl_node_t avl;\n\tuint32_t mask;\n\tuint32_t allowed;\n\tuint32_t denied;\n\tint aent_type;\n} acevals_t;\n\ntypedef struct ace_list {\n\tacevals_t user_obj;\n\tavl_tree_t user;\n\tint numusers;\n\tacevals_t group_obj;\n\tavl_tree_t group;\n\tint numgroups;\n\tacevals_t other_obj;\n\tuint32_t acl_mask;\n\tint hasmask;\n\tint dfacl_flag;\n\tace_to_aent_state_t state;\n\tint seen;  \n} ace_list_t;\n\n \nvoid\nksort(caddr_t v, int n, int s, int (*f)(void *, void *))\n{\n\tint g, i, j, ii;\n\tunsigned int *p1, *p2;\n\tunsigned int tmp;\n\n\t \n\tif (v == NULL || n <= 1)\n\t\treturn;\n\n\t \n\tASSERT3U(((uintptr_t)v & 0x3), ==, 0);\n\tASSERT3S((s & 0x3), ==, 0);\n\tASSERT3S(s, >, 0);\n\tfor (g = n / 2; g > 0; g /= 2) {\n\t\tfor (i = g; i < n; i++) {\n\t\t\tfor (j = i - g; j >= 0 &&\n\t\t\t    (*f)(v + j * s, v + (j + g) * s) == 1;\n\t\t\t    j -= g) {\n\t\t\t\tp1 = (void *)(v + j * s);\n\t\t\t\tp2 = (void *)(v + (j + g) * s);\n\t\t\t\tfor (ii = 0; ii < s / 4; ii++) {\n\t\t\t\t\ttmp = *p1;\n\t\t\t\t\t*p1++ = *p2;\n\t\t\t\t\t*p2++ = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint\ncmp2acls(void *a, void *b)\n{\n\taclent_t *x = (aclent_t *)a;\n\taclent_t *y = (aclent_t *)b;\n\n\t \n\tif (x->a_type < y->a_type)\n\t\treturn (-1);\n\tif (x->a_type > y->a_type)\n\t\treturn (1);\n\t \n\tif (x->a_id < y->a_id)\n\t\treturn (-1);\n\tif (x->a_id > y->a_id)\n\t\treturn (1);\n\t \n\tif (x->a_perm < y->a_perm)\n\t\treturn (-1);\n\tif (x->a_perm > y->a_perm)\n\t\treturn (1);\n\t \n\treturn (0);\n}\n\nstatic int\ncacl_malloc(void **ptr, size_t size)\n{\n\t*ptr = kmem_zalloc(size, KM_SLEEP);\n\treturn (0);\n}\n\n\n#if !defined(_KERNEL)\nacl_t *\nacl_alloc(enum acl_type type)\n{\n\tacl_t *aclp;\n\n\tif (cacl_malloc((void **)&aclp, sizeof (acl_t)) != 0)\n\t\treturn (NULL);\n\n\taclp->acl_aclp = NULL;\n\taclp->acl_cnt = 0;\n\n\tswitch (type) {\n\tcase ACE_T:\n\t\taclp->acl_type = ACE_T;\n\t\taclp->acl_entry_size = sizeof (ace_t);\n\t\tbreak;\n\tcase ACLENT_T:\n\t\taclp->acl_type = ACLENT_T;\n\t\taclp->acl_entry_size = sizeof (aclent_t);\n\t\tbreak;\n\tdefault:\n\t\tacl_free(aclp);\n\t\taclp = NULL;\n\t}\n\treturn (aclp);\n}\n\n \nvoid\nacl_free(acl_t *aclp)\n{\n\tint acl_size;\n\n\tif (aclp == NULL)\n\t\treturn;\n\n\tif (aclp->acl_aclp) {\n\t\tacl_size = aclp->acl_cnt * aclp->acl_entry_size;\n\t\tcacl_free(aclp->acl_aclp, acl_size);\n\t}\n\n\tcacl_free(aclp, sizeof (acl_t));\n}\n\nstatic uint32_t\naccess_mask_set(int haswriteperm, int hasreadperm, int isowner, int isallow)\n{\n\tuint32_t access_mask = 0;\n\tint acl_produce;\n\tint synchronize_set = 0, write_owner_set = 0;\n\tint delete_set = 0, write_attrs_set = 0;\n\tint read_named_set = 0, write_named_set = 0;\n\n\tacl_produce = (ACL_SYNCHRONIZE_SET_ALLOW |\n\t    ACL_WRITE_ATTRS_OWNER_SET_ALLOW |\n\t    ACL_WRITE_ATTRS_WRITER_SET_DENY);\n\n\tif (isallow) {\n\t\tsynchronize_set = ACL_SYNCHRONIZE_SET_ALLOW;\n\t\twrite_owner_set = ACL_WRITE_OWNER_SET_ALLOW;\n\t\tdelete_set = ACL_DELETE_SET_ALLOW;\n\t\tif (hasreadperm)\n\t\t\tread_named_set = ACL_READ_NAMED_READER_SET_ALLOW;\n\t\tif (haswriteperm)\n\t\t\twrite_named_set = ACL_WRITE_NAMED_WRITER_SET_ALLOW;\n\t\tif (isowner)\n\t\t\twrite_attrs_set = ACL_WRITE_ATTRS_OWNER_SET_ALLOW;\n\t\telse if (haswriteperm)\n\t\t\twrite_attrs_set = ACL_WRITE_ATTRS_WRITER_SET_ALLOW;\n\t} else {\n\n\t\tsynchronize_set = ACL_SYNCHRONIZE_SET_DENY;\n\t\twrite_owner_set = ACL_WRITE_OWNER_SET_DENY;\n\t\tdelete_set = ACL_DELETE_SET_DENY;\n\t\tif (hasreadperm)\n\t\t\tread_named_set = ACL_READ_NAMED_READER_SET_DENY;\n\t\tif (haswriteperm)\n\t\t\twrite_named_set = ACL_WRITE_NAMED_WRITER_SET_DENY;\n\t\tif (isowner)\n\t\t\twrite_attrs_set = ACL_WRITE_ATTRS_OWNER_SET_DENY;\n\t\telse if (haswriteperm)\n\t\t\twrite_attrs_set = ACL_WRITE_ATTRS_WRITER_SET_DENY;\n\t\telse\n\t\t\t \n\t\t\taccess_mask |= ACE_WRITE_ATTRIBUTES;\n\t}\n\n\tif (acl_produce & synchronize_set)\n\t\taccess_mask |= ACE_SYNCHRONIZE;\n\tif (acl_produce & write_owner_set)\n\t\taccess_mask |= ACE_WRITE_OWNER;\n\tif (acl_produce & delete_set)\n\t\taccess_mask |= ACE_DELETE;\n\tif (acl_produce & write_attrs_set)\n\t\taccess_mask |= ACE_WRITE_ATTRIBUTES;\n\tif (acl_produce & read_named_set)\n\t\taccess_mask |= ACE_READ_NAMED_ATTRS;\n\tif (acl_produce & write_named_set)\n\t\taccess_mask |= ACE_WRITE_NAMED_ATTRS;\n\n\treturn (access_mask);\n}\n\n \nstatic uint32_t\nmode_to_ace_access(mode_t mode, boolean_t isdir, int isowner, int isallow)\n{\n\tuint32_t access = 0;\n\tint haswriteperm = 0;\n\tint hasreadperm = 0;\n\n\tif (isallow) {\n\t\thaswriteperm = (mode & S_IWOTH);\n\t\thasreadperm = (mode & S_IROTH);\n\t} else {\n\t\thaswriteperm = !(mode & S_IWOTH);\n\t\thasreadperm = !(mode & S_IROTH);\n\t}\n\n\t \n\taccess = access_mask_set(haswriteperm, hasreadperm, isowner, isallow);\n\n\tif (isallow) {\n\t\taccess |= ACE_READ_ACL | ACE_READ_ATTRIBUTES;\n\t\tif (isowner)\n\t\t\taccess |= ACE_WRITE_ACL;\n\t} else {\n\t\tif (! isowner)\n\t\t\taccess |= ACE_WRITE_ACL;\n\t}\n\n\t \n\tif (mode & S_IROTH) {\n\t\taccess |= ACE_READ_DATA;\n\t}\n\t \n\tif (mode & S_IWOTH) {\n\t\taccess |= ACE_WRITE_DATA |\n\t\t    ACE_APPEND_DATA;\n\t\tif (isdir)\n\t\t\taccess |= ACE_DELETE_CHILD;\n\t}\n\t \n\tif (mode & S_IXOTH) {\n\t\taccess |= ACE_EXECUTE;\n\t}\n\n\treturn (access);\n}\n\n \nstatic void\nace_make_deny(ace_t *allow, ace_t *deny, int isdir, int isowner)\n{\n\t(void) memcpy(deny, allow, sizeof (ace_t));\n\n\tdeny->a_who = allow->a_who;\n\n\tdeny->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\tdeny->a_access_mask ^= ACE_POSIX_SUPPORTED_BITS;\n\tif (isdir)\n\t\tdeny->a_access_mask ^= ACE_DELETE_CHILD;\n\n\tdeny->a_access_mask &= ~(ACE_SYNCHRONIZE | ACE_WRITE_OWNER |\n\t    ACE_DELETE | ACE_WRITE_ATTRIBUTES | ACE_READ_NAMED_ATTRS |\n\t    ACE_WRITE_NAMED_ATTRS);\n\tdeny->a_access_mask |= access_mask_set((allow->a_access_mask &\n\t    ACE_WRITE_DATA), (allow->a_access_mask & ACE_READ_DATA), isowner,\n\t    B_FALSE);\n}\n \nstatic int\nln_aent_preprocess(aclent_t *aclent, int n,\n    int *hasmask, mode_t *mask,\n    int *numuser, int *numgroup, int *needsort)\n{\n\tint error = 0;\n\tint i;\n\tint curtype = 0;\n\n\t*hasmask = 0;\n\t*mask = 07;\n\t*needsort = 0;\n\t*numuser = 0;\n\t*numgroup = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (aclent[i].a_type < curtype)\n\t\t\t*needsort = 1;\n\t\telse if (aclent[i].a_type > curtype)\n\t\t\tcurtype = aclent[i].a_type;\n\t\tif (aclent[i].a_type & USER)\n\t\t\t(*numuser)++;\n\t\tif (aclent[i].a_type & (GROUP | GROUP_OBJ))\n\t\t\t(*numgroup)++;\n\t\tif (aclent[i].a_type & CLASS_OBJ) {\n\t\t\tif (*hasmask) {\n\t\t\t\terror = EINVAL;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t*hasmask = 1;\n\t\t\t\t*mask = aclent[i].a_perm;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((! *hasmask) && (*numuser + *numgroup > 1)) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\treturn (error);\n}\n\n \nstatic int\nln_aent_to_ace(aclent_t *aclent, int n, ace_t **acepp, int *rescount, int isdir)\n{\n\tint error = 0;\n\tmode_t mask;\n\tint numuser, numgroup, needsort;\n\tint resultsize = 0;\n\tint i, groupi = 0, skip;\n\tace_t *acep, *result = NULL;\n\tint hasmask;\n\n\terror = ln_aent_preprocess(aclent, n, &hasmask, &mask,\n\t    &numuser, &numgroup, &needsort);\n\tif (error != 0)\n\t\tgoto out;\n\n\t \n\tresultsize = n * 2;\n\tif (hasmask) {\n\t\t \n\t\tresultsize += numuser + numgroup;\n\t\t \n\t\tresultsize -= 2;\n\t}\n\n\t \n\tif (needsort)\n\t\tksort((caddr_t)aclent, n, sizeof (aclent_t), cmp2acls);\n\n\tif (cacl_malloc((void **)&result, resultsize * sizeof (ace_t)) != 0)\n\t\tgoto out;\n\n\tacep = result;\n\n\tfor (i = 0; i < n; i++) {\n\t\t \n\t\tif (aclent[i].a_type & CLASS_OBJ)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((hasmask) &&\n\t\t    (aclent[i].a_type & (USER | GROUP | GROUP_OBJ))) {\n\t\t\tacep->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\tacep->a_flags = 0;\n\t\t\tif (aclent[i].a_type & GROUP_OBJ) {\n\t\t\t\tacep->a_who = (uid_t)-1;\n\t\t\t\tacep->a_flags |=\n\t\t\t\t    (ACE_IDENTIFIER_GROUP|ACE_GROUP);\n\t\t\t} else if (aclent[i].a_type & USER) {\n\t\t\t\tacep->a_who = aclent[i].a_id;\n\t\t\t} else {\n\t\t\t\tacep->a_who = aclent[i].a_id;\n\t\t\t\tacep->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n\t\t\tif (aclent[i].a_type & ACL_DEFAULT) {\n\t\t\t\tacep->a_flags |= ACE_INHERIT_ONLY_ACE |\n\t\t\t\t    ACE_FILE_INHERIT_ACE |\n\t\t\t\t    ACE_DIRECTORY_INHERIT_ACE;\n\t\t\t}\n\t\t\t \n\t\t\tacep->a_access_mask = mode_to_ace_access((mask ^ 07),\n\t\t\t    isdir, 0, 0);\n\t\t\tacep += 1;\n\t\t}\n\n\t\t \n\t\tacep->a_access_mask = mode_to_ace_access(aclent[i].a_perm,\n\t\t    isdir, aclent[i].a_type & USER_OBJ, 1);\n\n\t\t \n\t\tif (aclent[i].a_type & ACL_DEFAULT) {\n\t\t\tacep->a_flags |= ACE_INHERIT_ONLY_ACE |\n\t\t\t    ACE_FILE_INHERIT_ACE |\n\t\t\t    ACE_DIRECTORY_INHERIT_ACE;\n\t\t}\n\n\t\t \n\t\tif (aclent[i].a_type & USER_OBJ) {\n\t\t\tacep->a_who = (uid_t)-1;\n\t\t\tacep->a_flags |= ACE_OWNER;\n\t\t\tace_make_deny(acep, acep + 1, isdir, B_TRUE);\n\t\t\tacep += 2;\n\t\t} else if (aclent[i].a_type & USER) {\n\t\t\tacep->a_who = aclent[i].a_id;\n\t\t\tace_make_deny(acep, acep + 1, isdir, B_FALSE);\n\t\t\tacep += 2;\n\t\t} else if (aclent[i].a_type & (GROUP_OBJ | GROUP)) {\n\t\t\tif (aclent[i].a_type & GROUP_OBJ) {\n\t\t\t\tacep->a_who = (uid_t)-1;\n\t\t\t\tacep->a_flags |= ACE_GROUP;\n\t\t\t} else {\n\t\t\t\tacep->a_who = aclent[i].a_id;\n\t\t\t}\n\t\t\tacep->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t \n\t\t\tskip = (2 * numgroup) - 1 - groupi;\n\t\t\tace_make_deny(acep, acep + skip, isdir, B_FALSE);\n\t\t\t \n\t\t\tif (++groupi >= numgroup)\n\t\t\t\tacep += numgroup + 1;\n\t\t\telse\n\t\t\t\tacep += 1;\n\t\t} else if (aclent[i].a_type & OTHER_OBJ) {\n\t\t\tacep->a_who = (uid_t)-1;\n\t\t\tacep->a_flags |= ACE_EVERYONE;\n\t\t\tace_make_deny(acep, acep + 1, isdir, B_FALSE);\n\t\t\tacep += 2;\n\t\t} else {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*acepp = result;\n\t*rescount = resultsize;\n\nout:\n\tif (error != 0) {\n\t\tif ((result != NULL) && (resultsize > 0)) {\n\t\t\tcacl_free(result, resultsize * sizeof (ace_t));\n\t\t}\n\t}\n\n\treturn (error);\n}\n\nstatic int\nconvert_aent_to_ace(aclent_t *aclentp, int aclcnt, boolean_t isdir,\n    ace_t **retacep, int *retacecnt)\n{\n\tace_t *acep;\n\tace_t *dfacep;\n\tint acecnt = 0;\n\tint dfacecnt = 0;\n\tint dfaclstart = 0;\n\tint dfaclcnt = 0;\n\taclent_t *aclp;\n\tint i;\n\tint error;\n\tint acesz, dfacesz;\n\n\tksort((caddr_t)aclentp, aclcnt, sizeof (aclent_t), cmp2acls);\n\n\tfor (i = 0, aclp = aclentp; i < aclcnt; aclp++, i++) {\n\t\tif (aclp->a_type & ACL_DEFAULT)\n\t\t\tbreak;\n\t}\n\n\tif (i < aclcnt) {\n\t\tdfaclstart = i;\n\t\tdfaclcnt = aclcnt - i;\n\t}\n\n\tif (dfaclcnt && !isdir) {\n\t\treturn (EINVAL);\n\t}\n\n\terror = ln_aent_to_ace(aclentp, i,  &acep, &acecnt, isdir);\n\tif (error)\n\t\treturn (error);\n\n\tif (dfaclcnt) {\n\t\terror = ln_aent_to_ace(&aclentp[dfaclstart], dfaclcnt,\n\t\t    &dfacep, &dfacecnt, isdir);\n\t\tif (error) {\n\t\t\tif (acep) {\n\t\t\t\tcacl_free(acep, acecnt * sizeof (ace_t));\n\t\t\t}\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (dfacecnt != 0) {\n\t\tacesz = sizeof (ace_t) * acecnt;\n\t\tdfacesz = sizeof (ace_t) * dfacecnt;\n\t\tacep = cacl_realloc(acep, acesz, acesz + dfacesz);\n\t\tif (acep == NULL)\n\t\t\treturn (ENOMEM);\n\t\tif (dfaclcnt) {\n\t\t\t(void) memcpy(acep + acecnt, dfacep, dfacesz);\n\t\t}\n\t}\n\tif (dfaclcnt)\n\t\tcacl_free(dfacep, dfacecnt * sizeof (ace_t));\n\n\t*retacecnt = acecnt + dfacecnt;\n\t*retacep = acep;\n\treturn (0);\n}\n\nstatic int\nace_mask_to_mode(uint32_t  mask, o_mode_t *modep, boolean_t isdir)\n{\n\tint error = 0;\n\to_mode_t mode = 0;\n\tuint32_t bits, wantbits;\n\n\t \n\tif (mask & ACE_READ_DATA)\n\t\tmode |= S_IROTH;\n\n\t \n\twantbits = (ACE_WRITE_DATA | ACE_APPEND_DATA);\n\tif (isdir)\n\t\twantbits |= ACE_DELETE_CHILD;\n\tbits = mask & wantbits;\n\tif (bits != 0) {\n\t\tif (bits != wantbits) {\n\t\t\terror = ENOTSUP;\n\t\t\tgoto out;\n\t\t}\n\t\tmode |= S_IWOTH;\n\t}\n\n\t \n\tif (mask & ACE_EXECUTE) {\n\t\tmode |= S_IXOTH;\n\t}\n\n\t*modep = mode;\n\nout:\n\treturn (error);\n}\n\nstatic void\nacevals_init(acevals_t *vals, uid_t key)\n{\n\tmemset(vals, 0, sizeof (*vals));\n\tvals->allowed = ACE_MASK_UNDEFINED;\n\tvals->denied = ACE_MASK_UNDEFINED;\n\tvals->mask = ACE_MASK_UNDEFINED;\n\tvals->key = key;\n}\n\nstatic void\nace_list_init(ace_list_t *al, int dfacl_flag)\n{\n\tacevals_init(&al->user_obj, 0);\n\tacevals_init(&al->group_obj, 0);\n\tacevals_init(&al->other_obj, 0);\n\tal->numusers = 0;\n\tal->numgroups = 0;\n\tal->acl_mask = 0;\n\tal->hasmask = 0;\n\tal->state = ace_unused;\n\tal->seen = 0;\n\tal->dfacl_flag = dfacl_flag;\n}\n\n \nstatic acevals_t *\nacevals_find(ace_t *ace, avl_tree_t *avl, int *num)\n{\n\tacevals_t key, *rc;\n\tavl_index_t where;\n\n\tkey.key = ace->a_who;\n\trc = avl_find(avl, &key, &where);\n\tif (rc != NULL)\n\t\treturn (rc);\n\n\t \n\tif (cacl_malloc((void **)&rc, sizeof (acevals_t)) != 0)\n\t\treturn (NULL);\n\n\tacevals_init(rc, ace->a_who);\n\tavl_insert(avl, rc, where);\n\t(*num)++;\n\n\treturn (rc);\n}\n\nstatic int\naccess_mask_check(ace_t *acep, int mask_bit, int isowner)\n{\n\tint set_deny, err_deny;\n\tint set_allow, err_allow;\n\tint acl_consume;\n\tint haswriteperm, hasreadperm;\n\n\tif (acep->a_type == ACE_ACCESS_DENIED_ACE_TYPE) {\n\t\thaswriteperm = (acep->a_access_mask & ACE_WRITE_DATA) ? 0 : 1;\n\t\thasreadperm = (acep->a_access_mask & ACE_READ_DATA) ? 0 : 1;\n\t} else {\n\t\thaswriteperm = (acep->a_access_mask & ACE_WRITE_DATA) ? 1 : 0;\n\t\thasreadperm = (acep->a_access_mask & ACE_READ_DATA) ? 1 : 0;\n\t}\n\n\tacl_consume = (ACL_SYNCHRONIZE_ERR_DENY |\n\t    ACL_DELETE_ERR_DENY |\n\t    ACL_WRITE_OWNER_ERR_DENY |\n\t    ACL_WRITE_OWNER_ERR_ALLOW |\n\t    ACL_WRITE_ATTRS_OWNER_SET_ALLOW |\n\t    ACL_WRITE_ATTRS_OWNER_ERR_DENY |\n\t    ACL_WRITE_ATTRS_WRITER_SET_DENY |\n\t    ACL_WRITE_ATTRS_WRITER_ERR_ALLOW |\n\t    ACL_WRITE_NAMED_WRITER_ERR_DENY |\n\t    ACL_READ_NAMED_READER_ERR_DENY);\n\n\tif (mask_bit == ACE_SYNCHRONIZE) {\n\t\tset_deny = ACL_SYNCHRONIZE_SET_DENY;\n\t\terr_deny =  ACL_SYNCHRONIZE_ERR_DENY;\n\t\tset_allow = ACL_SYNCHRONIZE_SET_ALLOW;\n\t\terr_allow = ACL_SYNCHRONIZE_ERR_ALLOW;\n\t} else if (mask_bit == ACE_WRITE_OWNER) {\n\t\tset_deny = ACL_WRITE_OWNER_SET_DENY;\n\t\terr_deny =  ACL_WRITE_OWNER_ERR_DENY;\n\t\tset_allow = ACL_WRITE_OWNER_SET_ALLOW;\n\t\terr_allow = ACL_WRITE_OWNER_ERR_ALLOW;\n\t} else if (mask_bit == ACE_DELETE) {\n\t\tset_deny = ACL_DELETE_SET_DENY;\n\t\terr_deny =  ACL_DELETE_ERR_DENY;\n\t\tset_allow = ACL_DELETE_SET_ALLOW;\n\t\terr_allow = ACL_DELETE_ERR_ALLOW;\n\t} else if (mask_bit == ACE_WRITE_ATTRIBUTES) {\n\t\tif (isowner) {\n\t\t\tset_deny = ACL_WRITE_ATTRS_OWNER_SET_DENY;\n\t\t\terr_deny =  ACL_WRITE_ATTRS_OWNER_ERR_DENY;\n\t\t\tset_allow = ACL_WRITE_ATTRS_OWNER_SET_ALLOW;\n\t\t\terr_allow = ACL_WRITE_ATTRS_OWNER_ERR_ALLOW;\n\t\t} else if (haswriteperm) {\n\t\t\tset_deny = ACL_WRITE_ATTRS_WRITER_SET_DENY;\n\t\t\terr_deny =  ACL_WRITE_ATTRS_WRITER_ERR_DENY;\n\t\t\tset_allow = ACL_WRITE_ATTRS_WRITER_SET_ALLOW;\n\t\t\terr_allow = ACL_WRITE_ATTRS_WRITER_ERR_ALLOW;\n\t\t} else {\n\t\t\tif ((acep->a_access_mask & mask_bit) &&\n\t\t\t    (acep->a_type & ACE_ACCESS_ALLOWED_ACE_TYPE)) {\n\t\t\t\treturn (ENOTSUP);\n\t\t\t}\n\t\t\treturn (0);\n\t\t}\n\t} else if (mask_bit == ACE_READ_NAMED_ATTRS) {\n\t\tif (!hasreadperm)\n\t\t\treturn (0);\n\n\t\tset_deny = ACL_READ_NAMED_READER_SET_DENY;\n\t\terr_deny = ACL_READ_NAMED_READER_ERR_DENY;\n\t\tset_allow = ACL_READ_NAMED_READER_SET_ALLOW;\n\t\terr_allow = ACL_READ_NAMED_READER_ERR_ALLOW;\n\t} else if (mask_bit == ACE_WRITE_NAMED_ATTRS) {\n\t\tif (!haswriteperm)\n\t\t\treturn (0);\n\n\t\tset_deny = ACL_WRITE_NAMED_WRITER_SET_DENY;\n\t\terr_deny = ACL_WRITE_NAMED_WRITER_ERR_DENY;\n\t\tset_allow = ACL_WRITE_NAMED_WRITER_SET_ALLOW;\n\t\terr_allow = ACL_WRITE_NAMED_WRITER_ERR_ALLOW;\n\t} else {\n\t\treturn (EINVAL);\n\t}\n\n\tif (acep->a_type == ACE_ACCESS_DENIED_ACE_TYPE) {\n\t\tif (acl_consume & set_deny) {\n\t\t\tif (!(acep->a_access_mask & mask_bit)) {\n\t\t\t\treturn (ENOTSUP);\n\t\t\t}\n\t\t} else if (acl_consume & err_deny) {\n\t\t\tif (acep->a_access_mask & mask_bit) {\n\t\t\t\treturn (ENOTSUP);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (acl_consume & set_allow) {\n\t\t\tif (!(acep->a_access_mask & mask_bit)) {\n\t\t\t\treturn (ENOTSUP);\n\t\t\t}\n\t\t} else if (acl_consume & err_allow) {\n\t\t\tif (acep->a_access_mask & mask_bit) {\n\t\t\t\treturn (ENOTSUP);\n\t\t\t}\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int\nace_to_aent_legal(ace_t *acep)\n{\n\tint error = 0;\n\tint isowner;\n\n\t \n\tif ((acep->a_type != ACE_ACCESS_ALLOWED_ACE_TYPE) &&\n\t    (acep->a_type != ACE_ACCESS_DENIED_ACE_TYPE)) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (acep->a_flags & ~(ACE_VALID_FLAG_BITS)) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (acep->a_flags & (ACE_SUCCESSFUL_ACCESS_ACE_FLAG |\n\t    ACE_FAILED_ACCESS_ACE_FLAG |\n\t    ACE_NO_PROPAGATE_INHERIT_ACE)) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (acep->a_access_mask & ~(ACE_VALID_MASK_BITS)) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((acep->a_flags & ACE_OWNER)) {\n\t\tisowner = 1;\n\t} else {\n\t\tisowner = 0;\n\t}\n\n\terror = access_mask_check(acep, ACE_SYNCHRONIZE, isowner);\n\tif (error)\n\t\tgoto out;\n\n\terror = access_mask_check(acep, ACE_WRITE_OWNER, isowner);\n\tif (error)\n\t\tgoto out;\n\n\terror = access_mask_check(acep, ACE_DELETE, isowner);\n\tif (error)\n\t\tgoto out;\n\n\terror = access_mask_check(acep, ACE_WRITE_ATTRIBUTES, isowner);\n\tif (error)\n\t\tgoto out;\n\n\terror = access_mask_check(acep, ACE_READ_NAMED_ATTRS, isowner);\n\tif (error)\n\t\tgoto out;\n\n\terror = access_mask_check(acep, ACE_WRITE_NAMED_ATTRS, isowner);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (acep->a_type == ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\tif (! (acep->a_access_mask & ACE_READ_ATTRIBUTES)) {\n\t\t\terror = ENOTSUP;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((acep->a_access_mask & ACE_WRITE_DATA) &&\n\t\t    (! (acep->a_access_mask & ACE_APPEND_DATA))) {\n\t\t\terror = ENOTSUP;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((! (acep->a_access_mask & ACE_WRITE_DATA)) &&\n\t\t    (acep->a_access_mask & ACE_APPEND_DATA)) {\n\t\t\terror = ENOTSUP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif ((acep->a_access_mask & ACE_READ_ACL) &&\n\t    (acep->a_type != ACE_ACCESS_ALLOWED_ACE_TYPE)) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\tif (acep->a_access_mask & ACE_WRITE_ACL) {\n\t\tif ((acep->a_type == ACE_ACCESS_DENIED_ACE_TYPE) &&\n\t\t    (isowner)) {\n\t\t\terror = ENOTSUP;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((acep->a_type == ACE_ACCESS_ALLOWED_ACE_TYPE) &&\n\t\t    (! isowner)) {\n\t\t\terror = ENOTSUP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn (error);\n}\n\nstatic int\nace_allow_to_mode(uint32_t mask, o_mode_t *modep, boolean_t isdir)\n{\n\t \n\tif ((mask & (ACE_READ_ACL | ACE_READ_ATTRIBUTES)) !=\n\t    (ACE_READ_ACL | ACE_READ_ATTRIBUTES)) {\n\t\treturn (ENOTSUP);\n\t}\n\n\treturn (ace_mask_to_mode(mask, modep, isdir));\n}\n\nstatic int\nacevals_to_aent(acevals_t *vals, aclent_t *dest, ace_list_t *list,\n    uid_t owner, gid_t group, boolean_t isdir)\n{\n\tint error;\n\tuint32_t  flips = ACE_POSIX_SUPPORTED_BITS;\n\n\tif (isdir)\n\t\tflips |= ACE_DELETE_CHILD;\n\tif (vals->allowed != (vals->denied ^ flips)) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\tif ((list->hasmask) && (list->acl_mask != vals->mask) &&\n\t    (vals->aent_type & (USER | GROUP | GROUP_OBJ))) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\terror = ace_allow_to_mode(vals->allowed, &dest->a_perm, isdir);\n\tif (error != 0)\n\t\tgoto out;\n\tdest->a_type = vals->aent_type;\n\tif (dest->a_type & (USER | GROUP)) {\n\t\tdest->a_id = vals->key;\n\t} else if (dest->a_type & USER_OBJ) {\n\t\tdest->a_id = owner;\n\t} else if (dest->a_type & GROUP_OBJ) {\n\t\tdest->a_id = group;\n\t} else if (dest->a_type & OTHER_OBJ) {\n\t\tdest->a_id = 0;\n\t} else {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\treturn (error);\n}\n\n\nstatic int\nace_list_to_aent(ace_list_t *list, aclent_t **aclentp, int *aclcnt,\n    uid_t owner, gid_t group, boolean_t isdir)\n{\n\tint error = 0;\n\taclent_t *aent, *result = NULL;\n\tacevals_t *vals;\n\tint resultcount;\n\n\tif ((list->seen & (USER_OBJ | GROUP_OBJ | OTHER_OBJ)) !=\n\t    (USER_OBJ | GROUP_OBJ | OTHER_OBJ)) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\tif ((! list->hasmask) && (list->numusers + list->numgroups > 0)) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\n\tresultcount = 3 + list->numusers + list->numgroups;\n\t \n\tif ((list->hasmask) || (! list->dfacl_flag))\n\t\tresultcount += 1;\n\n\tif (cacl_malloc((void **)&result,\n\t    resultcount * sizeof (aclent_t)) != 0) {\n\t\terror = ENOMEM;\n\t\tgoto out;\n\t}\n\taent = result;\n\n\t \n\tif (!(list->user_obj.aent_type & USER_OBJ)) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\n\terror = acevals_to_aent(&list->user_obj, aent, list, owner, group,\n\t    isdir);\n\n\tif (error != 0)\n\t\tgoto out;\n\t++aent;\n\t \n\tvals = NULL;\n\tfor (vals = avl_first(&list->user); vals != NULL;\n\t    vals = AVL_NEXT(&list->user, vals)) {\n\t\tif (!(vals->aent_type & USER)) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terror = acevals_to_aent(vals, aent, list, owner, group,\n\t\t    isdir);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\t\t++aent;\n\t}\n\t \n\tif (!(list->group_obj.aent_type & GROUP_OBJ)) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\terror = acevals_to_aent(&list->group_obj, aent, list, owner, group,\n\t    isdir);\n\tif (error != 0)\n\t\tgoto out;\n\t++aent;\n\t \n\tvals = NULL;\n\tfor (vals = avl_first(&list->group); vals != NULL;\n\t    vals = AVL_NEXT(&list->group, vals)) {\n\t\tif (!(vals->aent_type & GROUP)) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terror = acevals_to_aent(vals, aent, list, owner, group,\n\t\t    isdir);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\t\t++aent;\n\t}\n\t \n\tif ((list->hasmask) || (! list->dfacl_flag)) {\n\t\tif (list->hasmask) {\n\t\t\tuint32_t flips = ACE_POSIX_SUPPORTED_BITS;\n\t\t\tif (isdir)\n\t\t\t\tflips |= ACE_DELETE_CHILD;\n\t\t\terror = ace_mask_to_mode(list->acl_mask ^ flips,\n\t\t\t    &aent->a_perm, isdir);\n\t\t\tif (error != 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\terror = ace_mask_to_mode(list->group_obj.allowed,\n\t\t\t    &aent->a_perm, isdir);\n\t\t\tif (error != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\taent->a_id = 0;\n\t\taent->a_type = CLASS_OBJ | list->dfacl_flag;\n\t\t++aent;\n\t}\n\t \n\tif (!(list->other_obj.aent_type & OTHER_OBJ)) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\terror = acevals_to_aent(&list->other_obj, aent, list, owner, group,\n\t    isdir);\n\tif (error != 0)\n\t\tgoto out;\n\t++aent;\n\n\t*aclentp = result;\n\t*aclcnt = resultcount;\n\nout:\n\tif (error != 0) {\n\t\tif (result != NULL)\n\t\t\tcacl_free(result, resultcount * sizeof (aclent_t));\n\t}\n\n\treturn (error);\n}\n\n\n \nstatic void\nace_list_free(ace_list_t *al)\n{\n\tacevals_t *node;\n\tvoid *cookie;\n\n\tif (al == NULL)\n\t\treturn;\n\n\tcookie = NULL;\n\twhile ((node = avl_destroy_nodes(&al->user, &cookie)) != NULL)\n\t\tcacl_free(node, sizeof (acevals_t));\n\tcookie = NULL;\n\twhile ((node = avl_destroy_nodes(&al->group, &cookie)) != NULL)\n\t\tcacl_free(node, sizeof (acevals_t));\n\n\tavl_destroy(&al->user);\n\tavl_destroy(&al->group);\n\n\t \n\tcacl_free(al, sizeof (ace_list_t));\n}\n\nstatic int\nacevals_compare(const void *va, const void *vb)\n{\n\tconst acevals_t *a = va, *b = vb;\n\n\tif (a->key == b->key)\n\t\treturn (0);\n\n\tif (a->key > b->key)\n\t\treturn (1);\n\n\telse\n\t\treturn (-1);\n}\n\n \nstatic int\nln_ace_to_aent(ace_t *ace, int n, uid_t owner, gid_t group,\n    aclent_t **aclentp, int *aclcnt, aclent_t **dfaclentp, int *dfaclcnt,\n    boolean_t isdir)\n{\n\tint error = 0;\n\tace_t *acep;\n\tuint32_t bits;\n\tint i;\n\tace_list_t *normacl = NULL, *dfacl = NULL, *acl;\n\tacevals_t *vals;\n\n\t*aclentp = NULL;\n\t*aclcnt = 0;\n\t*dfaclentp = NULL;\n\t*dfaclcnt = 0;\n\n\t \n\tif (n < 6) {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\tif (ace == NULL) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\n\terror = cacl_malloc((void **)&normacl, sizeof (ace_list_t));\n\tif (error != 0)\n\t\tgoto out;\n\n\tavl_create(&normacl->user, acevals_compare, sizeof (acevals_t),\n\t    offsetof(acevals_t, avl));\n\tavl_create(&normacl->group, acevals_compare, sizeof (acevals_t),\n\t    offsetof(acevals_t, avl));\n\n\tace_list_init(normacl, 0);\n\n\terror = cacl_malloc((void **)&dfacl, sizeof (ace_list_t));\n\tif (error != 0)\n\t\tgoto out;\n\n\tavl_create(&dfacl->user, acevals_compare, sizeof (acevals_t),\n\t    offsetof(acevals_t, avl));\n\tavl_create(&dfacl->group, acevals_compare, sizeof (acevals_t),\n\t    offsetof(acevals_t, avl));\n\tace_list_init(dfacl, ACL_DEFAULT);\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tacep = &ace[i];\n\n\t\t \n\t\terror = ace_to_aent_legal(acep);\n\t\tif (error != 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tacep->a_access_mask &= ~(ACE_WRITE_OWNER | ACE_DELETE |\n\t\t    ACE_SYNCHRONIZE | ACE_WRITE_ATTRIBUTES |\n\t\t    ACE_READ_NAMED_ATTRS | ACE_WRITE_NAMED_ATTRS);\n\n\t\t \n\t\tbits = acep->a_flags &\n\t\t    (ACE_INHERIT_ONLY_ACE |\n\t\t    ACE_FILE_INHERIT_ACE |\n\t\t    ACE_DIRECTORY_INHERIT_ACE);\n\t\tif (bits != 0) {\n\t\t\t \n\t\t\tif (bits != (ACE_INHERIT_ONLY_ACE |\n\t\t\t    ACE_FILE_INHERIT_ACE |\n\t\t\t    ACE_DIRECTORY_INHERIT_ACE)) {\n\t\t\t\terror = ENOTSUP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tacl = dfacl;\n\t\t} else {\n\t\t\tacl = normacl;\n\t\t}\n\n\t\tif ((acep->a_flags & ACE_OWNER)) {\n\t\t\tif (acl->state > ace_user_obj) {\n\t\t\t\terror = ENOTSUP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tacl->state = ace_user_obj;\n\t\t\tacl->seen |= USER_OBJ;\n\t\t\tvals = &acl->user_obj;\n\t\t\tvals->aent_type = USER_OBJ | acl->dfacl_flag;\n\t\t} else if ((acep->a_flags & ACE_EVERYONE)) {\n\t\t\tacl->state = ace_other_obj;\n\t\t\tacl->seen |= OTHER_OBJ;\n\t\t\tvals = &acl->other_obj;\n\t\t\tvals->aent_type = OTHER_OBJ | acl->dfacl_flag;\n\t\t} else if (acep->a_flags & ACE_IDENTIFIER_GROUP) {\n\t\t\tif (acl->state > ace_group) {\n\t\t\t\terror = ENOTSUP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((acep->a_flags & ACE_GROUP)) {\n\t\t\t\tacl->seen |= GROUP_OBJ;\n\t\t\t\tvals = &acl->group_obj;\n\t\t\t\tvals->aent_type = GROUP_OBJ | acl->dfacl_flag;\n\t\t\t} else {\n\t\t\t\tacl->seen |= GROUP;\n\t\t\t\tvals = acevals_find(acep, &acl->group,\n\t\t\t\t    &acl->numgroups);\n\t\t\t\tif (vals == NULL) {\n\t\t\t\t\terror = ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tvals->aent_type = GROUP | acl->dfacl_flag;\n\t\t\t}\n\t\t\tacl->state = ace_group;\n\t\t} else {\n\t\t\tif (acl->state > ace_user) {\n\t\t\t\terror = ENOTSUP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tacl->state = ace_user;\n\t\t\tacl->seen |= USER;\n\t\t\tvals = acevals_find(acep, &acl->user,\n\t\t\t    &acl->numusers);\n\t\t\tif (vals == NULL) {\n\t\t\t\terror = ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvals->aent_type = USER | acl->dfacl_flag;\n\t\t}\n\n\t\tif (!(acl->state > ace_unused)) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (acep->a_type == ACE_ACCESS_ALLOWED_ACE_TYPE) {\n\t\t\t \n\t\t\tif (vals->allowed != ACE_MASK_UNDEFINED) {\n\t\t\t\terror = ENOTSUP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvals->allowed = acep->a_access_mask;\n\t\t} else {\n\t\t\t \n\t\t\tif (vals->denied != ACE_MASK_UNDEFINED) {\n\t\t\t\t \n\t\t\t\tif ((acl->state != ace_user) &&\n\t\t\t\t    (acl->state != ace_group)) {\n\t\t\t\t\terror = ENOTSUP;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (! acl->hasmask) {\n\t\t\t\t\tacl->hasmask = 1;\n\t\t\t\t\tacl->acl_mask = vals->denied;\n\t\t\t\t \n\t\t\t\t} else if (acl->acl_mask != vals->denied) {\n\t\t\t\t\terror = ENOTSUP;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tvals->mask = vals->denied;\n\t\t\t}\n\t\t\tvals->denied = acep->a_access_mask;\n\t\t}\n\t}\n\n\t \n\tif (normacl->state != ace_unused) {\n\t\terror = ace_list_to_aent(normacl, aclentp, aclcnt,\n\t\t    owner, group, isdir);\n\t\tif (error != 0) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (dfacl->state != ace_unused) {\n\t\terror = ace_list_to_aent(dfacl, dfaclentp, dfaclcnt,\n\t\t    owner, group, isdir);\n\t\tif (error != 0) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (normacl != NULL)\n\t\tace_list_free(normacl);\n\tif (dfacl != NULL)\n\t\tace_list_free(dfacl);\n\n\treturn (error);\n}\n\nstatic int\nconvert_ace_to_aent(ace_t *acebufp, int acecnt, boolean_t isdir,\n    uid_t owner, gid_t group, aclent_t **retaclentp, int *retaclcnt)\n{\n\tint error = 0;\n\taclent_t *aclentp, *dfaclentp;\n\tint aclcnt, dfaclcnt;\n\tint aclsz, dfaclsz;\n\n\terror = ln_ace_to_aent(acebufp, acecnt, owner, group,\n\t    &aclentp, &aclcnt, &dfaclentp, &dfaclcnt, isdir);\n\n\tif (error)\n\t\treturn (error);\n\n\n\tif (dfaclcnt != 0) {\n\t\t \n\t\taclsz = sizeof (aclent_t) * aclcnt;\n\t\tdfaclsz = sizeof (aclent_t) * dfaclcnt;\n\t\taclentp = cacl_realloc(aclentp, aclsz, aclsz + dfaclsz);\n\t\tif (aclentp != NULL) {\n\t\t\t(void) memcpy(aclentp + aclcnt, dfaclentp, dfaclsz);\n\t\t} else {\n\t\t\terror = ENOMEM;\n\t\t}\n\t}\n\n\tif (aclentp) {\n\t\t*retaclentp = aclentp;\n\t\t*retaclcnt = aclcnt + dfaclcnt;\n\t}\n\n\tif (dfaclentp)\n\t\tcacl_free(dfaclentp, dfaclsz);\n\n\treturn (error);\n}\n\n\nint\nacl_translate(acl_t *aclp, int target_flavor, boolean_t isdir, uid_t owner,\n    gid_t group)\n{\n\tint aclcnt;\n\tvoid *acldata;\n\tint error;\n\n\t \n\tif ((target_flavor == _ACL_ACE_ENABLED && aclp->acl_type == ACE_T) ||\n\t    (target_flavor == _ACL_ACLENT_ENABLED &&\n\t    aclp->acl_type == ACLENT_T))\n\t\treturn (0);\n\n\tif (target_flavor == -1) {\n\t\terror = EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_flavor ==  _ACL_ACE_ENABLED &&\n\t    aclp->acl_type == ACLENT_T) {\n\t\terror = convert_aent_to_ace(aclp->acl_aclp,\n\t\t    aclp->acl_cnt, isdir, (ace_t **)&acldata, &aclcnt);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (target_flavor == _ACL_ACLENT_ENABLED &&\n\t    aclp->acl_type == ACE_T) {\n\t\terror = convert_ace_to_aent(aclp->acl_aclp, aclp->acl_cnt,\n\t\t    isdir, owner, group, (aclent_t **)&acldata, &aclcnt);\n\t\tif (error)\n\t\t\tgoto out;\n\t} else {\n\t\terror = ENOTSUP;\n\t\tgoto out;\n\t}\n\n\t \n\tcacl_free(aclp->acl_aclp, aclp->acl_cnt * aclp->acl_entry_size);\n\taclp->acl_aclp = acldata;\n\taclp->acl_cnt = aclcnt;\n\tif (target_flavor == _ACL_ACE_ENABLED) {\n\t\taclp->acl_type = ACE_T;\n\t\taclp->acl_entry_size = sizeof (ace_t);\n\t} else {\n\t\taclp->acl_type = ACLENT_T;\n\t\taclp->acl_entry_size = sizeof (aclent_t);\n\t}\n\treturn (0);\n\nout:\n\n#if !defined(_KERNEL)\n\terrno = error;\n\treturn (-1);\n#else\n\treturn (error);\n#endif\n}\n#endif  \n\n#define\tSET_ACE(acl, index, who, mask, type, flags) { \\\n\tacl[0][index].a_who = (uint32_t)who; \\\n\tacl[0][index].a_type = type; \\\n\tacl[0][index].a_flags = flags; \\\n\tacl[0][index++].a_access_mask = mask; \\\n}\n\nvoid\nacl_trivial_access_masks(mode_t mode, boolean_t isdir, trivial_acl_t *masks)\n{\n\tuint32_t read_mask = ACE_READ_DATA;\n\tuint32_t write_mask = ACE_WRITE_DATA|ACE_APPEND_DATA;\n\tuint32_t execute_mask = ACE_EXECUTE;\n\n\t(void) isdir;\t \n\n\tmasks->deny1 = 0;\n\tif (!(mode & S_IRUSR) && (mode & (S_IRGRP|S_IROTH)))\n\t\tmasks->deny1 |= read_mask;\n\tif (!(mode & S_IWUSR) && (mode & (S_IWGRP|S_IWOTH)))\n\t\tmasks->deny1 |= write_mask;\n\tif (!(mode & S_IXUSR) && (mode & (S_IXGRP|S_IXOTH)))\n\t\tmasks->deny1 |= execute_mask;\n\n\tmasks->deny2 = 0;\n\tif (!(mode & S_IRGRP) && (mode & S_IROTH))\n\t\tmasks->deny2 |= read_mask;\n\tif (!(mode & S_IWGRP) && (mode & S_IWOTH))\n\t\tmasks->deny2 |= write_mask;\n\tif (!(mode & S_IXGRP) && (mode & S_IXOTH))\n\t\tmasks->deny2 |= execute_mask;\n\n\tmasks->allow0 = 0;\n\tif ((mode & S_IRUSR) && (!(mode & S_IRGRP) && (mode & S_IROTH)))\n\t\tmasks->allow0 |= read_mask;\n\tif ((mode & S_IWUSR) && (!(mode & S_IWGRP) && (mode & S_IWOTH)))\n\t\tmasks->allow0 |= write_mask;\n\tif ((mode & S_IXUSR) && (!(mode & S_IXGRP) && (mode & S_IXOTH)))\n\t\tmasks->allow0 |= execute_mask;\n\n\tmasks->owner = ACE_WRITE_ATTRIBUTES|ACE_WRITE_OWNER|ACE_WRITE_ACL|\n\t    ACE_WRITE_NAMED_ATTRS|ACE_READ_ACL|ACE_READ_ATTRIBUTES|\n\t    ACE_READ_NAMED_ATTRS|ACE_SYNCHRONIZE;\n\tif (mode & S_IRUSR)\n\t\tmasks->owner |= read_mask;\n\tif (mode & S_IWUSR)\n\t\tmasks->owner |= write_mask;\n\tif (mode & S_IXUSR)\n\t\tmasks->owner |= execute_mask;\n\n\tmasks->group = ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_READ_NAMED_ATTRS|\n\t    ACE_SYNCHRONIZE;\n\tif (mode & S_IRGRP)\n\t\tmasks->group |= read_mask;\n\tif (mode & S_IWGRP)\n\t\tmasks->group |= write_mask;\n\tif (mode & S_IXGRP)\n\t\tmasks->group |= execute_mask;\n\n\tmasks->everyone = ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_READ_NAMED_ATTRS|\n\t    ACE_SYNCHRONIZE;\n\tif (mode & S_IROTH)\n\t\tmasks->everyone |= read_mask;\n\tif (mode & S_IWOTH)\n\t\tmasks->everyone |= write_mask;\n\tif (mode & S_IXOTH)\n\t\tmasks->everyone |= execute_mask;\n}\n\nint\nacl_trivial_create(mode_t mode, boolean_t isdir, ace_t **acl, int *count)\n{\n\tint\t\tindex = 0;\n\tint\t\terror;\n\ttrivial_acl_t\tmasks;\n\n\t*count = 3;\n\tacl_trivial_access_masks(mode, isdir, &masks);\n\n\tif (masks.allow0)\n\t\t(*count)++;\n\tif (masks.deny1)\n\t\t(*count)++;\n\tif (masks.deny2)\n\t\t(*count)++;\n\n\tif ((error = cacl_malloc((void **)acl, *count * sizeof (ace_t))) != 0)\n\t\treturn (error);\n\n\tif (masks.allow0) {\n\t\tSET_ACE(acl, index, -1, masks.allow0,\n\t\t    ACE_ACCESS_ALLOWED_ACE_TYPE, ACE_OWNER);\n\t}\n\tif (masks.deny1) {\n\t\tSET_ACE(acl, index, -1, masks.deny1,\n\t\t    ACE_ACCESS_DENIED_ACE_TYPE, ACE_OWNER);\n\t}\n\tif (masks.deny2) {\n\t\tSET_ACE(acl, index, -1, masks.deny2,\n\t\t    ACE_ACCESS_DENIED_ACE_TYPE, ACE_GROUP|ACE_IDENTIFIER_GROUP);\n\t}\n\n\tSET_ACE(acl, index, -1, masks.owner, ACE_ACCESS_ALLOWED_ACE_TYPE,\n\t    ACE_OWNER);\n\tSET_ACE(acl, index, -1, masks.group, ACE_ACCESS_ALLOWED_ACE_TYPE,\n\t    ACE_IDENTIFIER_GROUP|ACE_GROUP);\n\tSET_ACE(acl, index, -1, masks.everyone, ACE_ACCESS_ALLOWED_ACE_TYPE,\n\t    ACE_EVERYONE);\n\n\treturn (0);\n}\n\n \nint\nace_trivial_common(void *acep, int aclcnt,\n    uintptr_t (*walk)(void *, uintptr_t, int aclcnt,\n    uint16_t *, uint16_t *, uint32_t *))\n{\n\tuint16_t flags;\n\tuint32_t mask;\n\tuint16_t type;\n\tuintptr_t cookie = 0;\n\n\twhile ((cookie = walk(acep, cookie, aclcnt, &flags, &type, &mask))) {\n\t\tswitch (flags & ACE_TYPE_FLAGS) {\n\t\tcase ACE_OWNER:\n\t\tcase ACE_GROUP|ACE_IDENTIFIER_GROUP:\n\t\tcase ACE_EVERYONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (1);\n\n\t\t}\n\n\t\tif (flags & (ACE_FILE_INHERIT_ACE|\n\t\t    ACE_DIRECTORY_INHERIT_ACE|ACE_NO_PROPAGATE_INHERIT_ACE|\n\t\t    ACE_INHERIT_ONLY_ACE))\n\t\t\treturn (1);\n\n\t\t \n\t\tif ((mask & (ACE_READ_ACL|ACE_READ_ATTRIBUTES)) &&\n\t\t    (type == ACE_ACCESS_DENIED_ACE_TYPE))\n\t\t\treturn (1);\n\n\t\t \n\t\tif (mask & (ACE_DELETE|ACE_DELETE_CHILD))\n\t\t\treturn (1);\n\t\t \n\t\tif (type == ACE_ACCESS_ALLOWED_ACE_TYPE &&\n\t\t    (!(flags & ACE_OWNER) && (mask &\n\t\t    (ACE_WRITE_OWNER|ACE_WRITE_ACL| ACE_WRITE_ATTRIBUTES|\n\t\t    ACE_WRITE_NAMED_ATTRS))))\n\t\t\treturn (1);\n\n\t}\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}