{
  "module_name": "spl_policy.c",
  "hash_id": "38a46217cbe4418208a0d196467709263a5a3da90c0cde4d205de65d95594945",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_policy.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/priv.h>\n#include <sys/vnode.h>\n#include <sys/mntent.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/jail.h>\n#include <sys/policy.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n\n\nint\nsecpolicy_nfs(cred_t *cr)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_NFS_DAEMON));\n}\n\nint\nsecpolicy_zfs(cred_t *cr)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_MOUNT));\n}\n\nint\nsecpolicy_zfs_proc(cred_t *cr, proc_t *proc)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_MOUNT));\n}\n\nint\nsecpolicy_sys_config(cred_t *cr, int checkonly __unused)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_ZFS_POOL_CONFIG));\n}\n\nint\nsecpolicy_zinject(cred_t *cr)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_ZFS_INJECT));\n}\n\nint\nsecpolicy_fs_unmount(cred_t *cr, struct mount *vfsp __unused)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_UNMOUNT));\n}\n\nint\nsecpolicy_fs_owner(struct mount *mp, cred_t *cr)\n{\n\n\tif (zfs_super_owner) {\n\t\tif (cr->cr_uid == mp->mnt_cred->cr_uid &&\n\t\t    cr->cr_prison == mp->mnt_cred->cr_prison) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (EPERM);\n}\n\n \nextern int hardlink_check_uid;\nint\nsecpolicy_basic_link(vnode_t *vp, cred_t *cr)\n{\n\n\tif (!hardlink_check_uid)\n\t\treturn (0);\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_LINK));\n}\n\nint\nsecpolicy_vnode_stky_modify(cred_t *cr)\n{\n\n\treturn (EPERM);\n}\n\nint\nsecpolicy_vnode_remove(vnode_t *vp, cred_t *cr)\n{\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_ADMIN));\n}\n\nint\nsecpolicy_vnode_access(cred_t *cr, vnode_t *vp, uid_t owner, accmode_t accmode)\n{\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\n\tif ((accmode & VREAD) && spl_priv_check_cred(cr, PRIV_VFS_READ) != 0)\n\t\treturn (EACCES);\n\tif ((accmode & VWRITE) &&\n\t    spl_priv_check_cred(cr, PRIV_VFS_WRITE) != 0) {\n\t\treturn (EACCES);\n\t}\n\tif (accmode & VEXEC) {\n\t\tif (vp->v_type == VDIR) {\n\t\t\tif (spl_priv_check_cred(cr, PRIV_VFS_LOOKUP) != 0)\n\t\t\t\treturn (EACCES);\n\t\t} else {\n\t\t\tif (spl_priv_check_cred(cr, PRIV_VFS_EXEC) != 0)\n\t\t\t\treturn (EACCES);\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nint\nsecpolicy_vnode_access2(cred_t *cr, vnode_t *vp, uid_t owner,\n    accmode_t curmode, accmode_t wantmode)\n{\n\taccmode_t mode;\n\n\tmode = ~curmode & wantmode;\n\n\tif (mode == 0)\n\t\treturn (0);\n\n\treturn (secpolicy_vnode_access(cr, vp, owner, mode));\n}\n\nint\nsecpolicy_vnode_any_access(cred_t *cr, vnode_t *vp, uid_t owner)\n{\n\tstatic int privs[] = {\n\t    PRIV_VFS_ADMIN,\n\t    PRIV_VFS_READ,\n\t    PRIV_VFS_WRITE,\n\t    PRIV_VFS_EXEC,\n\t    PRIV_VFS_LOOKUP\n\t};\n\tint i;\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\n\t \n\tif (owner == cr->cr_uid)\n\t\treturn (0);\n\n\tfor (i = 0; i < sizeof (privs)/sizeof (int); i++) {\n\t\tint priv;\n\n\t\tswitch (priv = privs[i]) {\n\t\tcase PRIV_VFS_EXEC:\n\t\t\tif (vp->v_type == VDIR)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase PRIV_VFS_LOOKUP:\n\t\t\tif (vp->v_type != VDIR)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (spl_priv_check_cred(cr, priv) == 0)\n\t\t\treturn (0);\n\t}\n\treturn (EPERM);\n}\n\nint\nsecpolicy_vnode_setdac(vnode_t *vp, cred_t *cr, uid_t owner)\n{\n\n\tif (owner == cr->cr_uid)\n\t\treturn (0);\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_ADMIN));\n}\n\nint\nsecpolicy_vnode_setattr(cred_t *cr, vnode_t *vp, struct vattr *vap,\n    const struct vattr *ovap, int flags,\n    int unlocked_access(void *, int, cred_t *), void *node)\n{\n\tint mask = vap->va_mask;\n\tint error;\n\n\tif (mask & AT_SIZE) {\n\t\tif (vp->v_type == VDIR)\n\t\t\treturn (EISDIR);\n\t\terror = unlocked_access(node, VWRITE, cr);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\tif (mask & AT_MODE) {\n\t\t \n\t\terror = secpolicy_vnode_setdac(vp, cr, ovap->va_uid);\n\t\tif (error)\n\t\t\treturn (error);\n\t\terror = secpolicy_setid_setsticky_clear(vp, vap, ovap, cr);\n\t\tif (error)\n\t\t\treturn (error);\n\t} else {\n\t\tvap->va_mode = ovap->va_mode;\n\t}\n\tif (mask & (AT_UID | AT_GID)) {\n\t\terror = secpolicy_vnode_setdac(vp, cr, ovap->va_uid);\n\t\tif (error)\n\t\t\treturn (error);\n\n\t\t \n\t\tif (((mask & AT_UID) && vap->va_uid != ovap->va_uid) ||\n\t\t    ((mask & AT_GID) && vap->va_gid != ovap->va_gid &&\n\t\t    !groupmember(vap->va_gid, cr))) {\n\t\t\tif (secpolicy_fs_owner(vp->v_mount, cr) != 0) {\n\t\t\t\terror = spl_priv_check_cred(cr, PRIV_VFS_CHOWN);\n\t\t\t\tif (error)\n\t\t\t\t\treturn (error);\n\t\t\t}\n\t\t}\n\n\t\tif (((mask & AT_UID) && vap->va_uid != ovap->va_uid) ||\n\t\t    ((mask & AT_GID) && vap->va_gid != ovap->va_gid)) {\n\t\t\tsecpolicy_setid_clear(vap, vp, cr);\n\t\t}\n\t}\n\tif (mask & (AT_ATIME | AT_MTIME)) {\n\t\t \n\t\terror = secpolicy_vnode_setdac(vp, cr, ovap->va_uid);\n\t\tif (error && (vap->va_vaflags & VA_UTIMES_NULL))\n\t\t\terror = unlocked_access(node, VWRITE, cr);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\treturn (0);\n}\n\nint\nsecpolicy_vnode_create_gid(cred_t *cr)\n{\n\n\treturn (EPERM);\n}\n\nint\nsecpolicy_vnode_setids_setgids(vnode_t *vp, cred_t *cr, gid_t gid)\n{\n\n\tif (groupmember(gid, cr))\n\t\treturn (0);\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_SETGID));\n}\n\nint\nsecpolicy_vnode_setid_retain(znode_t *zp, cred_t *cr,\n    boolean_t issuidroot __unused)\n{\n\n\tif (secpolicy_fs_owner(ZTOV(zp)->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_RETAINSUGID));\n}\n\nvoid\nsecpolicy_setid_clear(struct vattr *vap, vnode_t *vp, cred_t *cr)\n{\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn;\n\n\tif ((vap->va_mode & (S_ISUID | S_ISGID)) != 0) {\n\t\tif (spl_priv_check_cred(cr, PRIV_VFS_RETAINSUGID)) {\n\t\t\tvap->va_mask |= AT_MODE;\n\t\t\tvap->va_mode &= ~(S_ISUID|S_ISGID);\n\t\t}\n\t}\n}\n\nint\nsecpolicy_setid_setsticky_clear(vnode_t *vp, struct vattr *vap,\n    const struct vattr *ovap, cred_t *cr)\n{\n\tint error;\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\n\t \n\tif (vp->v_type != VDIR && (vap->va_mode & S_ISTXT)) {\n\t\tif (spl_priv_check_cred(cr, PRIV_VFS_STICKYFILE))\n\t\t\treturn (EFTYPE);\n\t}\n\t \n\tif ((vap->va_mode & S_ISGID) != 0) {\n\t\terror = secpolicy_vnode_setids_setgids(vp, cr, ovap->va_gid);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\t \n\tif ((vap->va_mode & S_ISUID) && ovap->va_uid != cr->cr_uid) {\n\t\terror = spl_priv_check_cred(cr, PRIV_VFS_ADMIN);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\treturn (0);\n}\n\nint\nsecpolicy_fs_mount(cred_t *cr, vnode_t *mvp, struct mount *vfsp)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_MOUNT));\n}\n\nint\nsecpolicy_vnode_owner(vnode_t *vp, cred_t *cr, uid_t owner)\n{\n\n\tif (owner == cr->cr_uid)\n\t\treturn (0);\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\n\t \n\treturn (spl_priv_check_cred(cr, PRIV_VFS_MOUNT_OWNER));\n}\n\nint\nsecpolicy_vnode_chown(vnode_t *vp, cred_t *cr, uid_t owner)\n{\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_CHOWN));\n}\n\nvoid\nsecpolicy_fs_mount_clearopts(cred_t *cr, struct mount *vfsp)\n{\n\n\tif (spl_priv_check_cred(cr, PRIV_VFS_MOUNT_NONUSER) != 0) {\n\t\tMNT_ILOCK(vfsp);\n\t\tvfsp->vfs_flag |= VFS_NOSETUID | MNT_USER;\n\t\tvfs_clearmntopt(vfsp, MNTOPT_SETUID);\n\t\tvfs_setmntopt(vfsp, MNTOPT_NOSETUID, NULL, 0);\n\t\tMNT_IUNLOCK(vfsp);\n\t}\n}\n\n \nint\nsecpolicy_xvattr(vnode_t *vp, xvattr_t *xvap, uid_t owner, cred_t *cr,\n    vtype_t vtype)\n{\n\n\tif (secpolicy_fs_owner(vp->v_mount, cr) == 0)\n\t\treturn (0);\n\treturn (spl_priv_check_cred(cr, PRIV_VFS_SYSFLAGS));\n}\n\nint\nsecpolicy_smb(cred_t *cr)\n{\n\n\treturn (spl_priv_check_cred(cr, PRIV_NETSMB));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}