{
  "module_name": "callb.c",
  "hash_id": "319f5a48e8894143ae5827cefb8d4a2305010b48c82d5a02d9c9e6f7e84ea7fa",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/callb.c",
  "human_readable_source": " \n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/sysmacros.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/mutex.h>\n#include <sys/condvar.h>\n#include <sys/callb.h>\n#include <sys/kmem.h>\n#include <sys/cmn_err.h>\n#include <sys/debug.h>\n#include <sys/kobj.h>\n#include <sys/systm.h>\t \n#include <sys/taskq.h>   \n#include <sys/kernel.h>\n\n#define\tCB_MAXNAME\tTASKQ_NAMELEN\n\n \ntypedef struct callb {\n\tstruct callb\t*c_next; \t \n\tkthread_id_t\tc_thread;\t \n\tchar\t\tc_flag;\t\t \n\tuchar_t\t\tc_class;\t \n\tkcondvar_t\tc_done_cv;\t \n\tboolean_t\t(*c_func)(void *, int);\n\t\t\t\t\t \n\tvoid\t\t*c_arg;\t\t \n\tchar\t\tc_name[CB_MAXNAME+1];  \n} callb_t;\n\n \n#define\tCALLB_FREE\t\t0x0\n#define\tCALLB_TAKEN\t\t0x1\n#define\tCALLB_EXECUTING\t\t0x2\n\n \ntypedef struct callb_table {\n\tkmutex_t ct_lock;\t\t \n\tcallb_t\t*ct_freelist; \t\t \n\tboolean_t ct_busy;\t\t \n\tkcondvar_t ct_busy_cv;\t\t \n\tint\tct_ncallb; \t\t \n\tcallb_t\t*ct_first_cb[NCBCLASS];\t \n} callb_table_t;\n\nint callb_timeout_sec = CPR_KTHREAD_TIMEOUT_SEC;\n\nstatic callb_id_t callb_add_common(boolean_t (*)(void *, int),\n    void *, int, char *, kthread_id_t);\n\nstatic callb_table_t callb_table;\t \nstatic callb_table_t *ct = &callb_table;\nstatic kmutex_t\tcallb_safe_mutex;\ncallb_cpr_t\tcallb_cprinfo_safe = {\n\t&callb_safe_mutex, CALLB_CPR_ALWAYS_SAFE, 0, {0, 0} };\n\n \nstatic void\ncallb_init(void *dummy __unused)\n{\n\tcallb_table.ct_busy = B_FALSE;\t \n\tmutex_init(&callb_safe_mutex, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&callb_table.ct_lock, NULL, MUTEX_DEFAULT, NULL);\n}\n\nstatic void\ncallb_fini(void *dummy __unused)\n{\n\tcallb_t *cp;\n\tint i;\n\n\tmutex_enter(&ct->ct_lock);\n\tfor (i = 0; i < 16; i++) {\n\t\twhile ((cp = ct->ct_freelist) != NULL) {\n\t\t\tct->ct_freelist = cp->c_next;\n\t\t\tct->ct_ncallb--;\n\t\t\tkmem_free(cp, sizeof (callb_t));\n\t\t}\n\t\tif (ct->ct_ncallb == 0)\n\t\t\tbreak;\n\t\t \n\t\tmutex_exit(&ct->ct_lock);\n\t\ttsleep(ct, 0, \"callb\", hz / 4);\n\t\tmutex_enter(&ct->ct_lock);\n\t}\n\tif (ct->ct_ncallb > 0)\n\t\tprintf(\"%s: Leaked %d callbacks!\\n\", __func__, ct->ct_ncallb);\n\tmutex_exit(&ct->ct_lock);\n\tmutex_destroy(&callb_safe_mutex);\n\tmutex_destroy(&callb_table.ct_lock);\n}\n\n \nstatic callb_id_t\ncallb_add_common(boolean_t (*func)(void *arg, int code),\n    void *arg, int class, char *name, kthread_id_t t)\n{\n\tcallb_t *cp;\n\n\tASSERT3S(class, <, NCBCLASS);\n\n\tmutex_enter(&ct->ct_lock);\n\twhile (ct->ct_busy)\n\t\tcv_wait(&ct->ct_busy_cv, &ct->ct_lock);\n\tif ((cp = ct->ct_freelist) == NULL) {\n\t\tct->ct_ncallb++;\n\t\tcp = kmem_zalloc(sizeof (callb_t), KM_SLEEP);\n\t}\n\tct->ct_freelist = cp->c_next;\n\tcp->c_thread = t;\n\tcp->c_func = func;\n\tcp->c_arg = arg;\n\tcp->c_class = (uchar_t)class;\n\tcp->c_flag |= CALLB_TAKEN;\n#ifdef ZFS_DEBUG\n\tif (strlen(name) > CB_MAXNAME)\n\t\tcmn_err(CE_WARN, \"callb_add: name of callback function '%s' \"\n\t\t    \"too long -- truncated to %d chars\",\n\t\t    name, CB_MAXNAME);\n#endif\n\t(void) strlcpy(cp->c_name, name, sizeof (cp->c_name));\n\n\t \n\tcp->c_next = ct->ct_first_cb[class];\n\tct->ct_first_cb[class] = cp;\n\n\tmutex_exit(&ct->ct_lock);\n\treturn ((callb_id_t)cp);\n}\n\n \ncallb_id_t\ncallb_add(boolean_t (*func)(void *arg, int code),\n    void *arg, int class, char *name)\n{\n\treturn (callb_add_common(func, arg, class, name, curthread));\n}\n\n \ncallb_id_t\ncallb_add_thread(boolean_t (*func)(void *arg, int code),\n    void *arg, int class, char *name, kthread_id_t t)\n{\n\treturn (callb_add_common(func, arg, class, name, t));\n}\n\n \nint\ncallb_delete(callb_id_t id)\n{\n\tcallb_t **pp;\n\tcallb_t *me = (callb_t *)id;\n\n\tmutex_enter(&ct->ct_lock);\n\n\tfor (;;) {\n\t\tpp = &ct->ct_first_cb[me->c_class];\n\t\twhile (*pp != NULL && *pp != me)\n\t\t\tpp = &(*pp)->c_next;\n\n#ifdef ZFS_DEBUG\n\t\tif (*pp != me) {\n\t\t\tcmn_err(CE_WARN, \"callb delete bogus entry 0x%p\",\n\t\t\t    (void *)me);\n\t\t\tmutex_exit(&ct->ct_lock);\n\t\t\treturn (-1);\n\t\t}\n#endif  \n\n\t\t \n\t\tif (!(me->c_flag & CALLB_EXECUTING))\n\t\t\tbreak;\n\n\t\tcv_wait(&me->c_done_cv, &ct->ct_lock);\n\t}\n\t \n\t*pp = me->c_next;\n\n\t \n\tme->c_flag = CALLB_FREE;\n\tme->c_next = ct->ct_freelist;\n\tct->ct_freelist = me;\n\n\tmutex_exit(&ct->ct_lock);\n\treturn (0);\n}\n\n \nvoid *\ncallb_execute_class(int class, int code)\n{\n\tcallb_t *cp;\n\tvoid *ret = NULL;\n\n\tASSERT3S(class, <, NCBCLASS);\n\n\tmutex_enter(&ct->ct_lock);\n\n\tfor (cp = ct->ct_first_cb[class];\n\t    cp != NULL && ret == NULL; cp = cp->c_next) {\n\t\twhile (cp->c_flag & CALLB_EXECUTING)\n\t\t\tcv_wait(&cp->c_done_cv, &ct->ct_lock);\n\t\t \n\t\tif (cp->c_flag == CALLB_FREE)\n\t\t\tcontinue;\n\t\tcp->c_flag |= CALLB_EXECUTING;\n\n#ifdef CALLB_DEBUG\n\t\tprintf(\"callb_execute: name=%s func=%p arg=%p\\n\",\n\t\t    cp->c_name, (void *)cp->c_func, (void *)cp->c_arg);\n#endif  \n\n\t\tmutex_exit(&ct->ct_lock);\n\t\t \n\t\tif (!(*cp->c_func)(cp->c_arg, code))\n\t\t\tret = cp->c_name;\n\t\tmutex_enter(&ct->ct_lock);\n\n\t\tcp->c_flag &= ~CALLB_EXECUTING;\n\t\tcv_broadcast(&cp->c_done_cv);\n\t}\n\tmutex_exit(&ct->ct_lock);\n\treturn (ret);\n}\n\n \nboolean_t\ncallb_generic_cpr(void *arg, int code)\n{\n\tcallb_cpr_t *cp = (callb_cpr_t *)arg;\n\tclock_t ret = 0;\t\t\t \n\n\tmutex_enter(cp->cc_lockp);\n\n\tswitch (code) {\n\tcase CB_CODE_CPR_CHKPT:\n\t\tcp->cc_events |= CALLB_CPR_START;\n#ifdef CPR_NOT_THREAD_SAFE\n\t\twhile (!(cp->cc_events & CALLB_CPR_SAFE))\n\t\t\t \n\t\t\tif ((ret = cv_reltimedwait(&cp->cc_callb_cv,\n\t\t\t    cp->cc_lockp, (callb_timeout_sec * hz),\n\t\t\t    TR_CLOCK_TICK)) == -1)\n\t\t\t\tbreak;\n#endif\n\t\tbreak;\n\n\tcase CB_CODE_CPR_RESUME:\n\t\tcp->cc_events &= ~CALLB_CPR_START;\n\t\tcv_signal(&cp->cc_stop_cv);\n\t\tbreak;\n\t}\n\tmutex_exit(cp->cc_lockp);\n\treturn (ret != -1);\n}\n\n \nboolean_t\ncallb_generic_cpr_safe(void *arg, int code)\n{\n\t(void) arg, (void) code;\n\treturn (B_TRUE);\n}\n \nvoid\ncallb_lock_table(void)\n{\n\tmutex_enter(&ct->ct_lock);\n\tASSERT(!ct->ct_busy);\n\tct->ct_busy = B_TRUE;\n\tmutex_exit(&ct->ct_lock);\n}\n\n \nvoid\ncallb_unlock_table(void)\n{\n\tmutex_enter(&ct->ct_lock);\n\tASSERT(ct->ct_busy);\n\tct->ct_busy = B_FALSE;\n\tcv_broadcast(&ct->ct_busy_cv);\n\tmutex_exit(&ct->ct_lock);\n}\n\nSYSINIT(sol_callb, SI_SUB_DRIVERS, SI_ORDER_FIRST, callb_init, NULL);\nSYSUNINIT(sol_callb, SI_SUB_DRIVERS, SI_ORDER_FIRST, callb_fini, NULL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}