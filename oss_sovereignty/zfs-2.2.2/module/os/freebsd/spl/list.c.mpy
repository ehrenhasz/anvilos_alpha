{
  "module_name": "list.c",
  "hash_id": "71ba9fa620e9e4fa7c99836e42548d0adafaa8fe762b3836a6e953863dbbd77b",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/list.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/param.h>\n#include <sys/list.h>\n#include <sys/list_impl.h>\n#include <sys/types.h>\n#include <sys/debug.h>\n\n#define\tlist_d2l(a, obj) ((list_node_t *)(((char *)obj) + (a)->list_offset))\n#define\tlist_object(a, node) ((void *)(((char *)node) - (a)->list_offset))\n#define\tlist_empty(a) ((a)->list_head.list_next == &(a)->list_head)\n\n#define\tlist_insert_after_node(list, node, object) {\t\\\n\tlist_node_t *lnew = list_d2l(list, object);\t\\\n\tlnew->list_prev = (node);\t\t\t\\\n\tlnew->list_next = (node)->list_next;\t\t\\\n\t(node)->list_next->list_prev = lnew;\t\t\\\n\t(node)->list_next = lnew;\t\t\t\\\n}\n\n#define\tlist_insert_before_node(list, node, object) {\t\\\n\tlist_node_t *lnew = list_d2l(list, object);\t\\\n\tlnew->list_next = (node);\t\t\t\\\n\tlnew->list_prev = (node)->list_prev;\t\t\\\n\t(node)->list_prev->list_next = lnew;\t\t\\\n\t(node)->list_prev = lnew;\t\t\t\\\n}\n\n#define\tlist_remove_node(node)\t\t\t\t\t\\\n\t(node)->list_prev->list_next = (node)->list_next;\t\\\n\t(node)->list_next->list_prev = (node)->list_prev;\t\\\n\t(node)->list_next = (node)->list_prev = NULL\n\nvoid\nlist_create(list_t *list, size_t size, size_t offset)\n{\n\tASSERT3P(list, !=, NULL);\n\tASSERT3U(size, >=, offset + sizeof (list_node_t));\n\n\tlist->list_size = size;\n\tlist->list_offset = offset;\n\tlist->list_head.list_next = list->list_head.list_prev =\n\t    &list->list_head;\n}\n\nvoid\nlist_destroy(list_t *list)\n{\n\tlist_node_t *node = &list->list_head;\n\n\tASSERT3P(list, !=, NULL);\n\tASSERT3P(list->list_head.list_next, ==, node);\n\tASSERT3P(list->list_head.list_prev, ==, node);\n\n\tnode->list_next = node->list_prev = NULL;\n}\n\nvoid\nlist_insert_after(list_t *list, void *object, void *nobject)\n{\n\tif (object == NULL) {\n\t\tlist_insert_head(list, nobject);\n\t} else {\n\t\tlist_node_t *lold = list_d2l(list, object);\n\t\tlist_insert_after_node(list, lold, nobject);\n\t}\n}\n\nvoid\nlist_insert_before(list_t *list, void *object, void *nobject)\n{\n\tif (object == NULL) {\n\t\tlist_insert_tail(list, nobject);\n\t} else {\n\t\tlist_node_t *lold = list_d2l(list, object);\n\t\tlist_insert_before_node(list, lold, nobject);\n\t}\n}\n\nvoid\nlist_insert_head(list_t *list, void *object)\n{\n\tlist_node_t *lold = &list->list_head;\n\tlist_insert_after_node(list, lold, object);\n}\n\nvoid\nlist_insert_tail(list_t *list, void *object)\n{\n\tlist_node_t *lold = &list->list_head;\n\tlist_insert_before_node(list, lold, object);\n}\n\nvoid\nlist_remove(list_t *list, void *object)\n{\n\tlist_node_t *lold = list_d2l(list, object);\n\tASSERT(!list_empty(list));\n\tASSERT3P(lold->list_next, !=, NULL);\n\tlist_remove_node(lold);\n}\n\nvoid *\nlist_remove_head(list_t *list)\n{\n\tlist_node_t *head = list->list_head.list_next;\n\tif (head == &list->list_head)\n\t\treturn (NULL);\n\tlist_remove_node(head);\n\treturn (list_object(list, head));\n}\n\nvoid *\nlist_remove_tail(list_t *list)\n{\n\tlist_node_t *tail = list->list_head.list_prev;\n\tif (tail == &list->list_head)\n\t\treturn (NULL);\n\tlist_remove_node(tail);\n\treturn (list_object(list, tail));\n}\n\nvoid *\nlist_head(list_t *list)\n{\n\tif (list_empty(list))\n\t\treturn (NULL);\n\treturn (list_object(list, list->list_head.list_next));\n}\n\nvoid *\nlist_tail(list_t *list)\n{\n\tif (list_empty(list))\n\t\treturn (NULL);\n\treturn (list_object(list, list->list_head.list_prev));\n}\n\nvoid *\nlist_next(list_t *list, void *object)\n{\n\tlist_node_t *node = list_d2l(list, object);\n\n\tif (node->list_next != &list->list_head)\n\t\treturn (list_object(list, node->list_next));\n\n\treturn (NULL);\n}\n\nvoid *\nlist_prev(list_t *list, void *object)\n{\n\tlist_node_t *node = list_d2l(list, object);\n\n\tif (node->list_prev != &list->list_head)\n\t\treturn (list_object(list, node->list_prev));\n\n\treturn (NULL);\n}\n\n \nvoid\nlist_move_tail(list_t *dst, list_t *src)\n{\n\tlist_node_t *dstnode = &dst->list_head;\n\tlist_node_t *srcnode = &src->list_head;\n\n\tASSERT3U(dst->list_size, ==, src->list_size);\n\tASSERT3U(dst->list_offset, ==, src->list_offset);\n\n\tif (list_empty(src))\n\t\treturn;\n\n\tdstnode->list_prev->list_next = srcnode->list_next;\n\tsrcnode->list_next->list_prev = dstnode->list_prev;\n\tdstnode->list_prev = srcnode->list_prev;\n\tsrcnode->list_prev->list_next = dstnode;\n\n\t \n\tsrcnode->list_next = srcnode->list_prev = srcnode;\n}\n\nvoid\nlist_link_replace(list_node_t *lold, list_node_t *lnew)\n{\n\tASSERT(list_link_active(lold));\n\tASSERT(!list_link_active(lnew));\n\n\tlnew->list_next = lold->list_next;\n\tlnew->list_prev = lold->list_prev;\n\tlold->list_prev->list_next = lnew;\n\tlold->list_next->list_prev = lnew;\n\tlold->list_next = lold->list_prev = NULL;\n}\n\nvoid\nlist_link_init(list_node_t *link)\n{\n\tlink->list_next = NULL;\n\tlink->list_prev = NULL;\n}\n\nint\nlist_link_active(list_node_t *link)\n{\n\tEQUIV(link->list_next == NULL, link->list_prev == NULL);\n\treturn (link->list_next != NULL);\n}\n\nint\nlist_is_empty(list_t *list)\n{\n\treturn (list_empty(list));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}