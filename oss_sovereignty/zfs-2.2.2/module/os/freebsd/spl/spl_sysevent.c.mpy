{
  "module_name": "spl_sysevent.c",
  "hash_id": "7ea10f77489ef11c17a6c7c0363b08d47d9c17acfb303cc67e1bff4d8395e42c",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_sysevent.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kmem.h>\n#include <sys/list.h>\n#include <sys/proc.h>\n#include <sys/sbuf.h>\n#include <sys/nvpair.h>\n#include <sys/sunddi.h>\n#include <sys/sysevent.h>\n#include <sys/fm/protocol.h>\n#include <sys/fm/util.h>\n#include <sys/bus.h>\n\nstatic int\nlog_sysevent(nvlist_t *event)\n{\n\tstruct sbuf *sb;\n\tconst char *type;\n\tchar typestr[128];\n\tnvpair_t *elem = NULL;\n\n\tsb = sbuf_new_auto();\n\tif (sb == NULL)\n\t\treturn (ENOMEM);\n\ttype = NULL;\n\n\twhile ((elem = nvlist_next_nvpair(event, elem)) != NULL) {\n\t\tswitch (nvpair_type(elem)) {\n\t\tcase DATA_TYPE_BOOLEAN:\n\t\t{\n\t\t\tboolean_t value;\n\n\t\t\t(void) nvpair_value_boolean_value(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%s\", nvpair_name(elem),\n\t\t\t    value ? \"true\" : \"false\");\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT8:\n\t\t{\n\t\t\tuint8_t value;\n\n\t\t\t(void) nvpair_value_uint8(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%hhu\", nvpair_name(elem), value);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_INT32:\n\t\t{\n\t\t\tint32_t value;\n\n\t\t\t(void) nvpair_value_int32(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%jd\", nvpair_name(elem),\n\t\t\t    (intmax_t)value);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT32:\n\t\t{\n\t\t\tuint32_t value;\n\n\t\t\t(void) nvpair_value_uint32(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%ju\", nvpair_name(elem),\n\t\t\t    (uintmax_t)value);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_INT64:\n\t\t{\n\t\t\tint64_t value;\n\n\t\t\t(void) nvpair_value_int64(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%jd\", nvpair_name(elem),\n\t\t\t    (intmax_t)value);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT64:\n\t\t{\n\t\t\tuint64_t value;\n\n\t\t\t(void) nvpair_value_uint64(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%ju\", nvpair_name(elem),\n\t\t\t    (uintmax_t)value);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_STRING:\n\t\t{\n\t\t\tconst char *value;\n\n\t\t\t(void) nvpair_value_string(elem, &value);\n\t\t\tsbuf_printf(sb, \" %s=%s\", nvpair_name(elem), value);\n\t\t\tif (strcmp(FM_CLASS, nvpair_name(elem)) == 0)\n\t\t\t\ttype = value;\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT8_ARRAY:\n\t\t{\n\t\t\tuint8_t *value;\n\t\t\tuint_t ii, nelem;\n\n\t\t\t(void) nvpair_value_uint8_array(elem, &value, &nelem);\n\t\t\tsbuf_printf(sb, \" %s=\", nvpair_name(elem));\n\t\t\tfor (ii = 0; ii < nelem; ii++)\n\t\t\t\tsbuf_printf(sb, \"%02hhx\", value[ii]);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT16_ARRAY:\n\t\t{\n\t\t\tuint16_t *value;\n\t\t\tuint_t ii, nelem;\n\n\t\t\t(void) nvpair_value_uint16_array(elem, &value, &nelem);\n\t\t\tsbuf_printf(sb, \" %s=\", nvpair_name(elem));\n\t\t\tfor (ii = 0; ii < nelem; ii++)\n\t\t\t\tsbuf_printf(sb, \"%04hx\", value[ii]);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT32_ARRAY:\n\t\t{\n\t\t\tuint32_t *value;\n\t\t\tuint_t ii, nelem;\n\n\t\t\t(void) nvpair_value_uint32_array(elem, &value, &nelem);\n\t\t\tsbuf_printf(sb, \" %s=\", nvpair_name(elem));\n\t\t\tfor (ii = 0; ii < nelem; ii++)\n\t\t\t\tsbuf_printf(sb, \"%08jx\", (uintmax_t)value[ii]);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_INT64_ARRAY:\n\t\t{\n\t\t\tint64_t *value;\n\t\t\tuint_t ii, nelem;\n\n\t\t\t(void) nvpair_value_int64_array(elem, &value, &nelem);\n\t\t\tsbuf_printf(sb, \" %s=\", nvpair_name(elem));\n\t\t\tfor (ii = 0; ii < nelem; ii++)\n\t\t\t\tsbuf_printf(sb, \"%016lld\",\n\t\t\t\t    (long long)value[ii]);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_UINT64_ARRAY:\n\t\t{\n\t\t\tuint64_t *value;\n\t\t\tuint_t ii, nelem;\n\n\t\t\t(void) nvpair_value_uint64_array(elem, &value, &nelem);\n\t\t\tsbuf_printf(sb, \" %s=\", nvpair_name(elem));\n\t\t\tfor (ii = 0; ii < nelem; ii++)\n\t\t\t\tsbuf_printf(sb, \"%016jx\", (uintmax_t)value[ii]);\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_STRING_ARRAY:\n\t\t{\n\t\t\tconst char **strarr;\n\t\t\tuint_t ii, nelem;\n\n\t\t\t(void) nvpair_value_string_array(elem, &strarr, &nelem);\n\n\t\t\tfor (ii = 0; ii < nelem; ii++) {\n\t\t\t\tif (strarr[ii] == NULL)  {\n\t\t\t\t\tsbuf_printf(sb, \" <NULL>\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsbuf_printf(sb, \" %s\", strarr[ii]);\n\t\t\t\tif (strcmp(FM_CLASS, strarr[ii]) == 0)\n\t\t\t\t\ttype = strarr[ii];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase DATA_TYPE_NVLIST:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: type %d is not implemented\\n\", __func__,\n\t\t\t    nvpair_type(elem));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sbuf_finish(sb) != 0) {\n\t\tsbuf_delete(sb);\n\t\treturn (ENOMEM);\n\t}\n\n\tif (type == NULL)\n\t\ttype = \"\";\n\tif (strncmp(type, \"ESC_ZFS_\", 8) == 0) {\n\t\tsnprintf(typestr, sizeof (typestr), \"misc.fs.zfs.%s\", type + 8);\n\t\ttype = typestr;\n\t}\n\tdevctl_notify(\"ZFS\", \"ZFS\", type, sbuf_data(sb));\n\tsbuf_delete(sb);\n\n\treturn (0);\n}\n\nstatic void\nsysevent_worker(void *arg __unused)\n{\n\tzfs_zevent_t *ze;\n\tnvlist_t *event;\n\tuint64_t dropped = 0;\n\tuint64_t dst_size;\n\tint error;\n\n\tzfs_zevent_init(&ze);\n\tfor (;;) {\n\t\tdst_size = 131072;\n\t\tdropped = 0;\n\t\tevent = NULL;\n\t\terror = zfs_zevent_next(ze, &event,\n\t\t    &dst_size, &dropped);\n\t\tif (error) {\n\t\t\terror = zfs_zevent_wait(ze);\n\t\t\tif (error == ESHUTDOWN)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tVERIFY3P(event, !=, NULL);\n\t\t\tlog_sysevent(event);\n\t\t\tnvlist_free(event);\n\t\t}\n\t}\n\n\t \n\tVERIFY3P(ze->ze_zevent, ==, NULL);\n\tkmem_free(ze, sizeof (zfs_zevent_t));\n\n\tkthread_exit();\n}\n\nvoid\nddi_sysevent_init(void)\n{\n\tkproc_kthread_add(sysevent_worker, NULL, &system_proc, NULL, 0, 0,\n\t    \"zfskern\", \"sysevent\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}