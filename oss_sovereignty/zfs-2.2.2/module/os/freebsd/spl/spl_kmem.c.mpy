{
  "module_name": "spl_kmem.c",
  "hash_id": "bf0855c030de045cd9da0e4e8b9c8ebe1f1c57c159a8b354e03f785258aaa38a",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_kmem.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/byteorder.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/kmem.h>\n#include <sys/kmem_cache.h>\n#include <sys/debug.h>\n#include <sys/mutex.h>\n#include <sys/vmmeter.h>\n\n\n#include <vm/vm_page.h>\n#include <vm/vm_object.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_map.h>\n\n#ifdef KMEM_DEBUG\n#include <sys/queue.h>\n#include <sys/stack.h>\n#endif\n\n#ifdef _KERNEL\nMALLOC_DEFINE(M_SOLARIS, \"solaris\", \"Solaris\");\n#else\n#define\tmalloc(size, type, flags)\tmalloc(size)\n#define\tfree(addr, type)\t\tfree(addr)\n#endif\n\n#ifdef KMEM_DEBUG\nstruct kmem_item {\n\tstruct stack\tstack;\n\tLIST_ENTRY(kmem_item) next;\n};\nstatic LIST_HEAD(, kmem_item) kmem_items;\nstatic struct mtx kmem_items_mtx;\nMTX_SYSINIT(kmem_items_mtx, &kmem_items_mtx, \"kmem_items\", MTX_DEF);\n#endif\t \n\n#include <sys/vmem.h>\n\nvoid *\nzfs_kmem_alloc(size_t size, int kmflags)\n{\n\tvoid *p;\n#ifdef KMEM_DEBUG\n\tstruct kmem_item *i;\n\n\tsize += sizeof (struct kmem_item);\n#endif\n\tp = malloc(MAX(size, 16), M_SOLARIS, kmflags);\n#ifndef _KERNEL\n\tif (kmflags & KM_SLEEP)\n\t\tassert(p != NULL);\n#endif\n#ifdef KMEM_DEBUG\n\tif (p != NULL) {\n\t\ti = p;\n\t\tp = (uint8_t *)p + sizeof (struct kmem_item);\n\t\tstack_save(&i->stack);\n\t\tmtx_lock(&kmem_items_mtx);\n\t\tLIST_INSERT_HEAD(&kmem_items, i, next);\n\t\tmtx_unlock(&kmem_items_mtx);\n\t}\n#endif\n\treturn (p);\n}\n\nvoid\nzfs_kmem_free(void *buf, size_t size __unused)\n{\n#ifdef KMEM_DEBUG\n\tif (buf == NULL) {\n\t\tprintf(\"%s: attempt to free NULL\\n\", __func__);\n\t\treturn;\n\t}\n\tstruct kmem_item *i;\n\n\tbuf = (uint8_t *)buf - sizeof (struct kmem_item);\n\tmtx_lock(&kmem_items_mtx);\n\tLIST_FOREACH(i, &kmem_items, next) {\n\t\tif (i == buf)\n\t\t\tbreak;\n\t}\n\tASSERT3P(i, !=, NULL);\n\tLIST_REMOVE(i, next);\n\tmtx_unlock(&kmem_items_mtx);\n\tmemset(buf, 0xDC, MAX(size, 16));\n#endif\n\tfree(buf, M_SOLARIS);\n}\n\nstatic uint64_t kmem_size_val;\n\nstatic void\nkmem_size_init(void *unused __unused)\n{\n\n\tkmem_size_val = (uint64_t)vm_cnt.v_page_count * PAGE_SIZE;\n\tif (kmem_size_val > vm_kmem_size)\n\t\tkmem_size_val = vm_kmem_size;\n}\nSYSINIT(kmem_size_init, SI_SUB_KMEM, SI_ORDER_ANY, kmem_size_init, NULL);\n\nuint64_t\nkmem_size(void)\n{\n\n\treturn (kmem_size_val);\n}\n\nstatic int\nkmem_std_constructor(void *mem, int size __unused, void *private, int flags)\n{\n\tstruct kmem_cache *cache = private;\n\n\treturn (cache->kc_constructor(mem, cache->kc_private, flags));\n}\n\nstatic void\nkmem_std_destructor(void *mem, int size __unused, void *private)\n{\n\tstruct kmem_cache *cache = private;\n\n\tcache->kc_destructor(mem, cache->kc_private);\n}\n\nkmem_cache_t *\nkmem_cache_create(const char *name, size_t bufsize, size_t align,\n    int (*constructor)(void *, void *, int), void (*destructor)(void *, void *),\n    void (*reclaim)(void *) __unused, void *private, vmem_t *vmp, int cflags)\n{\n\tkmem_cache_t *cache;\n\n\tASSERT3P(vmp, ==, NULL);\n\n\tcache = kmem_alloc(sizeof (*cache), KM_SLEEP);\n\tstrlcpy(cache->kc_name, name, sizeof (cache->kc_name));\n\tcache->kc_constructor = constructor;\n\tcache->kc_destructor = destructor;\n\tcache->kc_private = private;\n#if defined(_KERNEL) && !defined(KMEM_DEBUG)\n\tcache->kc_zone = uma_zcreate(cache->kc_name, bufsize,\n\t    constructor != NULL ? kmem_std_constructor : NULL,\n\t    destructor != NULL ? kmem_std_destructor : NULL,\n\t    NULL, NULL, align > 0 ? align - 1 : 0, cflags);\n#else\n\tcache->kc_size = bufsize;\n#endif\n\n\treturn (cache);\n}\n\nvoid\nkmem_cache_destroy(kmem_cache_t *cache)\n{\n#if defined(_KERNEL) && !defined(KMEM_DEBUG)\n\tuma_zdestroy(cache->kc_zone);\n#endif\n\tkmem_free(cache, sizeof (*cache));\n}\n\nvoid *\nkmem_cache_alloc(kmem_cache_t *cache, int flags)\n{\n#if defined(_KERNEL) && !defined(KMEM_DEBUG)\n\treturn (uma_zalloc_arg(cache->kc_zone, cache, flags));\n#else\n\tvoid *p;\n\n\tp = kmem_alloc(cache->kc_size, flags);\n\tif (p != NULL && cache->kc_constructor != NULL)\n\t\tkmem_std_constructor(p, cache->kc_size, cache, flags);\n\treturn (p);\n#endif\n}\n\nvoid\nkmem_cache_free(kmem_cache_t *cache, void *buf)\n{\n#if defined(_KERNEL) && !defined(KMEM_DEBUG)\n\tuma_zfree_arg(cache->kc_zone, buf, cache);\n#else\n\tif (cache->kc_destructor != NULL)\n\t\tkmem_std_destructor(buf, cache->kc_size, cache);\n\tkmem_free(buf, cache->kc_size);\n#endif\n}\n\n \nboolean_t\nkmem_cache_reap_active(void)\n{\n\n\treturn (B_FALSE);\n}\n\n \n#ifdef _KERNEL\nvoid\nkmem_cache_reap_soon(kmem_cache_t *cache)\n{\n#ifndef KMEM_DEBUG\n#if __FreeBSD_version >= 1300043\n\tuma_zone_reclaim(cache->kc_zone, UMA_RECLAIM_DRAIN);\n#else\n\tzone_drain(cache->kc_zone);\n#endif\n#endif\n}\n\nvoid\nkmem_reap(void)\n{\n#if __FreeBSD_version >= 1300043\n\tuma_reclaim(UMA_RECLAIM_TRIM);\n#else\n\tuma_reclaim();\n#endif\n}\n#else\nvoid\nkmem_cache_reap_soon(kmem_cache_t *cache __unused)\n{\n}\n\nvoid\nkmem_reap(void)\n{\n}\n#endif\n\nint\nkmem_debugging(void)\n{\n\treturn (0);\n}\n\nvoid *\ncalloc(size_t n, size_t s)\n{\n\treturn (kmem_zalloc(n * s, KM_NOSLEEP));\n}\n\nchar *\nkmem_vasprintf(const char *fmt, va_list adx)\n{\n\tchar *msg;\n\tva_list adx2;\n\n\tva_copy(adx2, adx);\n\tmsg = kmem_alloc(vsnprintf(NULL, 0, fmt, adx) + 1, KM_SLEEP);\n\t(void) vsprintf(msg, fmt, adx2);\n\tva_end(adx2);\n\n\treturn (msg);\n}\n\n#include <vm/uma.h>\n#include <vm/uma_int.h>\n#ifdef KMEM_DEBUG\n#error \"KMEM_DEBUG not currently supported\"\n#endif\n\nuint64_t\nspl_kmem_cache_inuse(kmem_cache_t *cache)\n{\n\treturn (uma_zone_get_cur(cache->kc_zone));\n}\n\nuint64_t\nspl_kmem_cache_entry_size(kmem_cache_t *cache)\n{\n\treturn (cache->kc_zone->uz_size);\n}\n\n \nvoid\nspl_kmem_cache_set_move(kmem_cache_t *skc,\n    kmem_cbrc_t (move)(void *, void *, size_t, void *))\n{\n\tASSERT3P(move, !=, NULL);\n}\n\n#ifdef KMEM_DEBUG\nvoid kmem_show(void *);\nvoid\nkmem_show(void *dummy __unused)\n{\n\tstruct kmem_item *i;\n\n\tmtx_lock(&kmem_items_mtx);\n\tif (LIST_EMPTY(&kmem_items))\n\t\tprintf(\"KMEM_DEBUG: No leaked elements.\\n\");\n\telse {\n\t\tprintf(\"KMEM_DEBUG: Leaked elements:\\n\\n\");\n\t\tLIST_FOREACH(i, &kmem_items, next) {\n\t\t\tprintf(\"address=%p\\n\", i);\n\t\t\tstack_print_ddb(&i->stack);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tmtx_unlock(&kmem_items_mtx);\n}\n\nSYSUNINIT(sol_kmem, SI_SUB_CPU, SI_ORDER_FIRST, kmem_show, NULL);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}