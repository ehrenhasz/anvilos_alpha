{
  "module_name": "spl_procfs_list.c",
  "hash_id": "e20f45b372164c3c60f84cfef2a14abcd8b1a824db5fa8054482267dbd1980d7",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_procfs_list.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/list.h>\n#include <sys/mutex.h>\n#include <sys/procfs_list.h>\n\ntypedef struct procfs_list_iter {\n\tprocfs_list_t *pli_pl;\n\tvoid *pli_elt;\n} pli_t;\n\nvoid\nseq_printf(struct seq_file *f, const char *fmt, ...)\n{\n\tva_list adx;\n\n\tva_start(adx, fmt);\n\t(void) vsnprintf(f->sf_buf, f->sf_size, fmt, adx);\n\tva_end(adx);\n}\n\nstatic int\nprocfs_list_update(kstat_t *ksp, int rw)\n{\n\tprocfs_list_t *pl = ksp->ks_private;\n\n\tif (rw == KSTAT_WRITE)\n\t\tpl->pl_clear(pl);\n\n\treturn (0);\n}\n\nstatic int\nprocfs_list_data(char *buf, size_t size, void *data)\n{\n\tpli_t *p;\n\tvoid *elt;\n\tprocfs_list_t *pl;\n\tstruct seq_file f;\n\n\tp = data;\n\tpl = p->pli_pl;\n\telt = p->pli_elt;\n\tfree(p, M_TEMP);\n\tf.sf_buf = buf;\n\tf.sf_size = size;\n\treturn (pl->pl_show(&f, elt));\n}\n\nstatic void *\nprocfs_list_addr(kstat_t *ksp, loff_t n)\n{\n\tprocfs_list_t *pl = ksp->ks_private;\n\tvoid *elt = ksp->ks_private1;\n\tpli_t *p = NULL;\n\n\n\tif (n == 0)\n\t\tksp->ks_private1 = list_head(&pl->pl_list);\n\telse if (elt)\n\t\tksp->ks_private1 = list_next(&pl->pl_list, elt);\n\n\tif (ksp->ks_private1) {\n\t\tp = malloc(sizeof (*p), M_TEMP, M_WAITOK);\n\t\tp->pli_pl = pl;\n\t\tp->pli_elt = ksp->ks_private1;\n\t}\n\n\treturn (p);\n}\n\nvoid\nprocfs_list_install(const char *module,\n    const char *submodule,\n    const char *name,\n    mode_t mode,\n    procfs_list_t *procfs_list,\n    int (*show)(struct seq_file *f, void *p),\n    int (*show_header)(struct seq_file *f),\n    int (*clear)(procfs_list_t *procfs_list),\n    size_t procfs_list_node_off)\n{\n\tkstat_t *procfs_kstat;\n\n\tmutex_init(&procfs_list->pl_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&procfs_list->pl_list,\n\t    procfs_list_node_off + sizeof (procfs_list_node_t),\n\t    procfs_list_node_off + offsetof(procfs_list_node_t, pln_link));\n\tprocfs_list->pl_show = show;\n\tprocfs_list->pl_show_header = show_header;\n\tprocfs_list->pl_clear = clear;\n\tprocfs_list->pl_next_id = 1;\n\tprocfs_list->pl_node_offset = procfs_list_node_off;\n\n\tprocfs_kstat =  kstat_create(module, 0, name, submodule,\n\t    KSTAT_TYPE_RAW, 0, KSTAT_FLAG_VIRTUAL);\n\n\tif (procfs_kstat) {\n\t\tprocfs_kstat->ks_lock = &procfs_list->pl_lock;\n\t\tprocfs_kstat->ks_ndata = UINT32_MAX;\n\t\tprocfs_kstat->ks_private = procfs_list;\n\t\tprocfs_kstat->ks_update = procfs_list_update;\n\t\tkstat_set_seq_raw_ops(procfs_kstat, show_header,\n\t\t    procfs_list_data, procfs_list_addr);\n\t\tkstat_install(procfs_kstat);\n\t\tprocfs_list->pl_private = procfs_kstat;\n\t}\n}\n\nvoid\nprocfs_list_uninstall(procfs_list_t *procfs_list)\n{}\n\nvoid\nprocfs_list_destroy(procfs_list_t *procfs_list)\n{\n\tASSERT(list_is_empty(&procfs_list->pl_list));\n\tkstat_delete(procfs_list->pl_private);\n\tlist_destroy(&procfs_list->pl_list);\n\tmutex_destroy(&procfs_list->pl_lock);\n}\n\n#define\tNODE_ID(procfs_list, obj) \\\n\t\t(((procfs_list_node_t *)(((char *)obj) + \\\n\t\t(procfs_list)->pl_node_offset))->pln_id)\n\nvoid\nprocfs_list_add(procfs_list_t *procfs_list, void *p)\n{\n\tASSERT(MUTEX_HELD(&procfs_list->pl_lock));\n\tNODE_ID(procfs_list, p) = procfs_list->pl_next_id++;\n\tlist_insert_tail(&procfs_list->pl_list, p);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}