{
  "module_name": "spl_zone.c",
  "hash_id": "72da1e9fa3dc7e8916aba93c0728b8b16f20139060b313dfc8165bc59fd0b85e",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/spl/spl_zone.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/lock.h>\n#include <sys/mutex.h>\n#include <sys/sx.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/jail.h>\n#include <sys/osd.h>\n#include <sys/priv.h>\n#include <sys/zone.h>\n\n#include <sys/policy.h>\n\nstatic MALLOC_DEFINE(M_ZONES, \"zones_data\", \"Zones data\");\n\n \ntypedef struct zone_dataset {\n\tLIST_ENTRY(zone_dataset) zd_next;\n\tchar\tzd_dataset[0];\n} zone_dataset_t;\n\nLIST_HEAD(zone_dataset_head, zone_dataset);\n\nstatic int zone_slot;\n\nint\nzone_dataset_attach(struct ucred *cred, const char *dataset, int jailid)\n{\n\tstruct zone_dataset_head *head;\n\tzone_dataset_t *zd, *zd2;\n\tstruct prison *pr;\n\tint dofree, error;\n\n\tif ((error = spl_priv_check_cred(cred, PRIV_ZFS_JAIL)) != 0)\n\t\treturn (error);\n\n\t \n\tzd = malloc(sizeof (*zd) + strlen(dataset) + 1, M_ZONES, M_WAITOK);\n\n\tsx_slock(&allprison_lock);\n\tpr = prison_find(jailid);\t \n\tsx_sunlock(&allprison_lock);\n\tif (pr == NULL) {\n\t\tfree(zd, M_ZONES);\n\t\treturn (ENOENT);\n\t}\n\n\thead = osd_jail_get(pr, zone_slot);\n\tif (head != NULL) {\n\t\tdofree = 0;\n\t\tLIST_FOREACH(zd2, head, zd_next) {\n\t\t\tif (strcmp(dataset, zd2->zd_dataset) == 0) {\n\t\t\t\tfree(zd, M_ZONES);\n\t\t\t\terror = EEXIST;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdofree = 1;\n\t\tprison_hold_locked(pr);\n\t\tmtx_unlock(&pr->pr_mtx);\n\t\thead = malloc(sizeof (*head), M_ZONES, M_WAITOK);\n\t\tLIST_INIT(head);\n\t\tmtx_lock(&pr->pr_mtx);\n\t\terror = osd_jail_set(pr, zone_slot, head);\n\t\tKASSERT(error == 0, (\"osd_jail_set() failed (error=%d)\",\n\t\t    error));\n\t}\n\tstrcpy(zd->zd_dataset, dataset);\n\tLIST_INSERT_HEAD(head, zd, zd_next);\nend:\n\tif (dofree)\n\t\tprison_free_locked(pr);\n\telse\n\t\tmtx_unlock(&pr->pr_mtx);\n\treturn (error);\n}\n\nint\nzone_dataset_detach(struct ucred *cred, const char *dataset, int jailid)\n{\n\tstruct zone_dataset_head *head;\n\tzone_dataset_t *zd;\n\tstruct prison *pr;\n\tint error;\n\n\tif ((error = spl_priv_check_cred(cred, PRIV_ZFS_JAIL)) != 0)\n\t\treturn (error);\n\n\tsx_slock(&allprison_lock);\n\tpr = prison_find(jailid);\n\tsx_sunlock(&allprison_lock);\n\tif (pr == NULL)\n\t\treturn (ENOENT);\n\thead = osd_jail_get(pr, zone_slot);\n\tif (head == NULL) {\n\t\terror = ENOENT;\n\t\tgoto end;\n\t}\n\tLIST_FOREACH(zd, head, zd_next) {\n\t\tif (strcmp(dataset, zd->zd_dataset) == 0)\n\t\t\tbreak;\n\t}\n\tif (zd == NULL)\n\t\terror = ENOENT;\n\telse {\n\t\tLIST_REMOVE(zd, zd_next);\n\t\tfree(zd, M_ZONES);\n\t\tif (LIST_EMPTY(head))\n\t\t\tosd_jail_del(pr, zone_slot);\n\t\terror = 0;\n\t}\nend:\n\tmtx_unlock(&pr->pr_mtx);\n\treturn (error);\n}\n\n \nint\nzone_dataset_visible(const char *dataset, int *write)\n{\n\tstruct zone_dataset_head *head;\n\tzone_dataset_t *zd;\n\tstruct prison *pr;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (dataset[0] == '\\0')\n\t\treturn (0);\n\tif (INGLOBALZONE(curproc)) {\n\t\tif (write != NULL)\n\t\t\t*write = 1;\n\t\treturn (1);\n\t}\n\tpr = curthread->td_ucred->cr_prison;\n\tmtx_lock(&pr->pr_mtx);\n\thead = osd_jail_get(pr, zone_slot);\n\tif (head == NULL)\n\t\tgoto end;\n\n\t \n\tLIST_FOREACH(zd, head, zd_next) {\n\t\tlen = strlen(zd->zd_dataset);\n\t\tif (strlen(dataset) >= len &&\n\t\t    memcmp(dataset, zd->zd_dataset, len) == 0 &&\n\t\t    (dataset[len] == '\\0' || dataset[len] == '/' ||\n\t\t    dataset[len] == '@')) {\n\t\t\tif (write)\n\t\t\t\t*write = 1;\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t \n\tLIST_FOREACH(zd, head, zd_next) {\n\t\tlen = strlen(dataset);\n\t\tif (dataset[len - 1] == '/')\n\t\t\tlen--;\t \n\t\tif (len < strlen(zd->zd_dataset) &&\n\t\t    memcmp(dataset, zd->zd_dataset, len) == 0 &&\n\t\t    zd->zd_dataset[len] == '/') {\n\t\t\tif (write)\n\t\t\t\t*write = 0;\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t}\n\t}\nend:\n\tmtx_unlock(&pr->pr_mtx);\n\treturn (ret);\n}\n\nstatic void\nzone_destroy(void *arg)\n{\n\tstruct zone_dataset_head *head;\n\tzone_dataset_t *zd;\n\n\thead = arg;\n\twhile ((zd = LIST_FIRST(head)) != NULL) {\n\t\tLIST_REMOVE(zd, zd_next);\n\t\tfree(zd, M_ZONES);\n\t}\n\tfree(head, M_ZONES);\n}\n\nuint32_t\nzone_get_hostid(void *ptr)\n{\n\n\tKASSERT(ptr == NULL, (\"only NULL pointer supported in %s\", __func__));\n\n\treturn ((uint32_t)curthread->td_ucred->cr_prison->pr_hostid);\n}\n\nstatic void\nzone_sysinit(void *arg __unused)\n{\n\n\tzone_slot = osd_jail_register(zone_destroy, NULL);\n}\n\nstatic void\nzone_sysuninit(void *arg __unused)\n{\n\n\tosd_jail_deregister(zone_slot);\n}\n\nSYSINIT(zone_sysinit, SI_SUB_DRIVERS, SI_ORDER_ANY, zone_sysinit, NULL);\nSYSUNINIT(zone_sysuninit, SI_SUB_DRIVERS, SI_ORDER_ANY, zone_sysuninit, NULL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}