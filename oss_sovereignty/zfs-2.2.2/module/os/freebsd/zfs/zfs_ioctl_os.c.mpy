{
  "module_name": "zfs_ioctl_os.c",
  "hash_id": "6b7973bfd511d15939754de81dfada86b5086eac8d2e12a0b5296ab98dce0db6",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_ioctl_os.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/errno.h>\n#include <sys/nvpair.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev_os.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zone.h>\n#include <vm/vm_pageout.h>\n\n#include <sys/zfs_ioctl_impl.h>\n\n#if __FreeBSD_version < 1201517\n#define\tvm_page_max_user_wired\tvm_page_max_wired\n#endif\n\nint\nzfs_vfs_ref(zfsvfs_t **zfvp)\n{\n\tint error = 0;\n\n\tif (*zfvp == NULL)\n\t\treturn (SET_ERROR(ESRCH));\n\n\terror = vfs_busy((*zfvp)->z_vfs, 0);\n\tif (error != 0) {\n\t\t*zfvp = NULL;\n\t\terror = SET_ERROR(ESRCH);\n\t}\n\treturn (error);\n}\n\nboolean_t\nzfs_vfs_held(zfsvfs_t *zfsvfs)\n{\n\treturn (zfsvfs->z_vfs != NULL);\n}\n\nvoid\nzfs_vfs_rele(zfsvfs_t *zfsvfs)\n{\n\tvfs_unbusy(zfsvfs->z_vfs);\n}\n\nstatic const zfs_ioc_key_t zfs_keys_nextboot[] = {\n\t{\"command\",\t\tDATA_TYPE_STRING,\t0},\n\t{ ZPOOL_CONFIG_POOL_GUID,\t\tDATA_TYPE_UINT64,\t0},\n\t{ ZPOOL_CONFIG_GUID,\t\tDATA_TYPE_UINT64,\t0}\n};\n\nstatic int\nzfs_ioc_jail(zfs_cmd_t *zc)\n{\n\n\treturn (zone_dataset_attach(curthread->td_ucred, zc->zc_name,\n\t    (int)zc->zc_zoneid));\n}\n\nstatic int\nzfs_ioc_unjail(zfs_cmd_t *zc)\n{\n\n\treturn (zone_dataset_detach(curthread->td_ucred, zc->zc_name,\n\t    (int)zc->zc_zoneid));\n}\n\nstatic int\nzfs_ioc_nextboot(const char *unused, nvlist_t *innvl, nvlist_t *outnvl)\n{\n\tchar name[MAXNAMELEN];\n\tspa_t *spa;\n\tvdev_t *vd;\n\tconst char *command;\n\tuint64_t pool_guid;\n\tuint64_t vdev_guid;\n\tint error;\n\n\tif (nvlist_lookup_uint64(innvl,\n\t    ZPOOL_CONFIG_POOL_GUID, &pool_guid) != 0)\n\t\treturn (EINVAL);\n\tif (nvlist_lookup_uint64(innvl,\n\t    ZPOOL_CONFIG_GUID, &vdev_guid) != 0)\n\t\treturn (EINVAL);\n\tif (nvlist_lookup_string(innvl,\n\t    \"command\", &command) != 0)\n\t\treturn (EINVAL);\n\n\tmutex_enter(&spa_namespace_lock);\n\tspa = spa_by_guid(pool_guid, vdev_guid);\n\tif (spa != NULL)\n\t\tstrcpy(name, spa_name(spa));\n\tmutex_exit(&spa_namespace_lock);\n\tif (spa == NULL)\n\t\treturn (ENOENT);\n\n\tif ((error = spa_open(name, &spa, FTAG)) != 0)\n\t\treturn (error);\n\tspa_vdev_state_enter(spa, SCL_ALL);\n\tvd = spa_lookup_by_guid(spa, vdev_guid, B_TRUE);\n\tif (vd == NULL) {\n\t\t(void) spa_vdev_state_exit(spa, NULL, ENXIO);\n\t\tspa_close(spa, FTAG);\n\t\treturn (ENODEV);\n\t}\n\terror = vdev_label_write_pad2(vd, command, strlen(command));\n\t(void) spa_vdev_state_exit(spa, NULL, 0);\n\ttxg_wait_synced(spa->spa_dsl_pool, 0);\n\tspa_close(spa, FTAG);\n\treturn (error);\n}\n\n \nvoid\nzfs_ioctl_update_mount_cache(const char *dsname)\n{\n\tzfsvfs_t *zfsvfs;\n\n\tif (getzfsvfs(dsname, &zfsvfs) == 0) {\n\t\tstruct mount *mp = zfsvfs->z_vfs;\n\t\tVFS_STATFS(mp, &mp->mnt_stat);\n\t\tzfs_vfs_rele(zfsvfs);\n\t}\n\t \n}\n\nuint64_t\nzfs_max_nvlist_src_size_os(void)\n{\n\tif (zfs_max_nvlist_src_size != 0)\n\t\treturn (zfs_max_nvlist_src_size);\n\n\treturn (ptob(vm_page_max_user_wired) / 4);\n}\n\nvoid\nzfs_ioctl_init_os(void)\n{\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_JAIL, zfs_ioc_jail,\n\t    zfs_secpolicy_config, POOL_CHECK_NONE);\n\tzfs_ioctl_register_dataset_nolog(ZFS_IOC_UNJAIL, zfs_ioc_unjail,\n\t    zfs_secpolicy_config, POOL_CHECK_NONE);\n\tzfs_ioctl_register(\"fbsd_nextboot\", ZFS_IOC_NEXTBOOT,\n\t    zfs_ioc_nextboot, zfs_secpolicy_config, NO_NAME,\n\t    POOL_CHECK_NONE, B_FALSE, B_FALSE, zfs_keys_nextboot, 3);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}