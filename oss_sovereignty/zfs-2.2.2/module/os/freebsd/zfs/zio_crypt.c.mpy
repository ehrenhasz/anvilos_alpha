{
  "module_name": "zio_crypt.c",
  "hash_id": "993fb8538be65f3b21d3e1e6d25e659901323c8784f8d35d176c542c11c3b509",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zio_crypt.c",
  "human_readable_source": " \n\n \n\n#include <sys/zio_crypt.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dnode.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio.h>\n#include <sys/zil.h>\n#include <sys/sha2.h>\n#include <sys/hkdf.h>\n\n \n\n \n#define\tZFS_KEY_MAX_SALT_USES_DEFAULT\t400000000\n#define\tZFS_CURRENT_MAX_SALT_USES\t\\\n\t(MIN(zfs_key_max_salt_uses, ZFS_KEY_MAX_SALT_USES_DEFAULT))\nstatic unsigned long zfs_key_max_salt_uses = ZFS_KEY_MAX_SALT_USES_DEFAULT;\n\ntypedef struct blkptr_auth_buf {\n\tuint64_t bab_prop;\t\t\t \n\tuint8_t bab_mac[ZIO_DATA_MAC_LEN];\t \n\tuint64_t bab_pad;\t\t\t \n} blkptr_auth_buf_t;\n\nconst zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS] = {\n\t{\"\",\t\t\tZC_TYPE_NONE,\t0,\t\"inherit\"},\n\t{\"\",\t\t\tZC_TYPE_NONE,\t0,\t\"on\"},\n\t{\"\",\t\t\tZC_TYPE_NONE,\t0,\t\"off\"},\n\t{SUN_CKM_AES_CCM,\tZC_TYPE_CCM,\t16,\t\"aes-128-ccm\"},\n\t{SUN_CKM_AES_CCM,\tZC_TYPE_CCM,\t24,\t\"aes-192-ccm\"},\n\t{SUN_CKM_AES_CCM,\tZC_TYPE_CCM,\t32,\t\"aes-256-ccm\"},\n\t{SUN_CKM_AES_GCM,\tZC_TYPE_GCM,\t16,\t\"aes-128-gcm\"},\n\t{SUN_CKM_AES_GCM,\tZC_TYPE_GCM,\t24,\t\"aes-192-gcm\"},\n\t{SUN_CKM_AES_GCM,\tZC_TYPE_GCM,\t32,\t\"aes-256-gcm\"}\n};\n\nstatic void\nzio_crypt_key_destroy_early(zio_crypt_key_t *key)\n{\n\trw_destroy(&key->zk_salt_lock);\n\n\t \n\tmemset(&key->zk_session, 0, sizeof (key->zk_session));\n\n\t \n\tmemset(key, 0, sizeof (zio_crypt_key_t));\n}\n\nvoid\nzio_crypt_key_destroy(zio_crypt_key_t *key)\n{\n\n\tfreebsd_crypt_freesession(&key->zk_session);\n\tzio_crypt_key_destroy_early(key);\n}\n\nint\nzio_crypt_key_init(uint64_t crypt, zio_crypt_key_t *key)\n{\n\tint ret;\n\tcrypto_mechanism_t mech __unused;\n\tuint_t keydata_len;\n\tconst zio_crypt_info_t *ci = NULL;\n\n\tASSERT3P(key, !=, NULL);\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\tci = &zio_crypt_table[crypt];\n\tif (ci->ci_crypt_type != ZC_TYPE_GCM &&\n\t    ci->ci_crypt_type != ZC_TYPE_CCM)\n\t\treturn (ENOTSUP);\n\n\tkeydata_len = zio_crypt_table[crypt].ci_keylen;\n\tmemset(key, 0, sizeof (zio_crypt_key_t));\n\trw_init(&key->zk_salt_lock, NULL, RW_DEFAULT, NULL);\n\n\t \n\tret = random_get_bytes((uint8_t *)&key->zk_guid, sizeof (uint64_t));\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = random_get_bytes(key->zk_master_keydata, keydata_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = random_get_bytes(key->zk_hmac_keydata, SHA512_HMAC_KEYLEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tret = random_get_bytes(key->zk_salt, ZIO_DATA_SALT_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t    key->zk_salt, ZIO_DATA_SALT_LEN, key->zk_current_keydata,\n\t    keydata_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tkey->zk_current_key.ck_data = key->zk_current_keydata;\n\tkey->zk_current_key.ck_length = CRYPTO_BYTES2BITS(keydata_len);\n\n\tkey->zk_hmac_key.ck_data = &key->zk_hmac_key;\n\tkey->zk_hmac_key.ck_length = CRYPTO_BYTES2BITS(SHA512_HMAC_KEYLEN);\n\n\tci = &zio_crypt_table[crypt];\n\tif (ci->ci_crypt_type != ZC_TYPE_GCM &&\n\t    ci->ci_crypt_type != ZC_TYPE_CCM)\n\t\treturn (ENOTSUP);\n\n\tret = freebsd_crypt_newsession(&key->zk_session, ci,\n\t    &key->zk_current_key);\n\tif (ret)\n\t\tgoto error;\n\n\tkey->zk_crypt = crypt;\n\tkey->zk_version = ZIO_CRYPT_KEY_CURRENT_VERSION;\n\tkey->zk_salt_count = 0;\n\n\treturn (0);\n\nerror:\n\tzio_crypt_key_destroy_early(key);\n\treturn (ret);\n}\n\nstatic int\nzio_crypt_key_change_salt(zio_crypt_key_t *key)\n{\n\tint ret = 0;\n\tuint8_t salt[ZIO_DATA_SALT_LEN];\n\tcrypto_mechanism_t mech __unused;\n\n\tuint_t keydata_len = zio_crypt_table[key->zk_crypt].ci_keylen;\n\n\t \n\tret = random_get_bytes(salt, ZIO_DATA_SALT_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\trw_enter(&key->zk_salt_lock, RW_WRITER);\n\n\t \n\tif (key->zk_salt_count < ZFS_CURRENT_MAX_SALT_USES)\n\t\tgoto out_unlock;\n\n\t \n\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t    salt, ZIO_DATA_SALT_LEN, key->zk_current_keydata, keydata_len);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\t \n\tmemcpy(key->zk_salt, salt, ZIO_DATA_SALT_LEN);\n\tkey->zk_salt_count = 0;\n\n\tfreebsd_crypt_freesession(&key->zk_session);\n\tret = freebsd_crypt_newsession(&key->zk_session,\n\t    &zio_crypt_table[key->zk_crypt], &key->zk_current_key);\n\tif (ret != 0)\n\t\tgoto out_unlock;\n\n\trw_exit(&key->zk_salt_lock);\n\n\treturn (0);\n\nout_unlock:\n\trw_exit(&key->zk_salt_lock);\nerror:\n\treturn (ret);\n}\n\n \nint\nzio_crypt_key_get_salt(zio_crypt_key_t *key, uint8_t *salt)\n{\n\tint ret;\n\tboolean_t salt_change;\n\n\trw_enter(&key->zk_salt_lock, RW_READER);\n\n\tmemcpy(salt, key->zk_salt, ZIO_DATA_SALT_LEN);\n\tsalt_change = (atomic_inc_64_nv(&key->zk_salt_count) >=\n\t    ZFS_CURRENT_MAX_SALT_USES);\n\n\trw_exit(&key->zk_salt_lock);\n\n\tif (salt_change) {\n\t\tret = zio_crypt_key_change_salt(key);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\nvoid *failed_decrypt_buf;\nint failed_decrypt_size;\n\n \n \nstatic int\nzio_do_crypt_uio_opencrypto(boolean_t encrypt, freebsd_crypt_session_t *sess,\n    uint64_t crypt, crypto_key_t *key, uint8_t *ivbuf, uint_t datalen,\n    zfs_uio_t *uio, uint_t auth_len)\n{\n\tconst zio_crypt_info_t *ci = &zio_crypt_table[crypt];\n\tif (ci->ci_crypt_type != ZC_TYPE_GCM &&\n\t    ci->ci_crypt_type != ZC_TYPE_CCM)\n\t\treturn (ENOTSUP);\n\n\n\tint ret = freebsd_crypt_uio(encrypt, sess, ci, uio, key, ivbuf,\n\t    datalen, auth_len);\n\tif (ret != 0) {\n#ifdef FCRYPTO_DEBUG\n\t\tprintf(\"%s(%d):  Returning error %s\\n\",\n\t\t    __FUNCTION__, __LINE__, encrypt ? \"EIO\" : \"ECKSUM\");\n#endif\n\t\tret = SET_ERROR(encrypt ? EIO : ECKSUM);\n\t}\n\n\treturn (ret);\n}\n\nint\nzio_crypt_key_wrap(crypto_key_t *cwkey, zio_crypt_key_t *key, uint8_t *iv,\n    uint8_t *mac, uint8_t *keydata_out, uint8_t *hmac_keydata_out)\n{\n\tint ret;\n\tuint64_t aad[3];\n\t \n\tzfs_uio_t cuio;\n\tstruct uio cuio_s;\n\tiovec_t iovecs[4];\n\tuint64_t crypt = key->zk_crypt;\n\tuint_t enc_len, keydata_len, aad_len;\n\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\tzfs_uio_init(&cuio, &cuio_s);\n\n\tkeydata_len = zio_crypt_table[crypt].ci_keylen;\n\n\t \n\tret = random_get_pseudo_bytes(iv, WRAPPING_IV_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tmemcpy(keydata_out, key->zk_master_keydata, keydata_len);\n\tmemcpy(hmac_keydata_out, key->zk_hmac_keydata, SHA512_HMAC_KEYLEN);\n\tiovecs[1].iov_base = keydata_out;\n\tiovecs[1].iov_len = keydata_len;\n\tiovecs[2].iov_base = hmac_keydata_out;\n\tiovecs[2].iov_len = SHA512_HMAC_KEYLEN;\n\tiovecs[3].iov_base = mac;\n\tiovecs[3].iov_len = WRAPPING_MAC_LEN;\n\n\t \n\tif (key->zk_version == 0) {\n\t\taad_len = sizeof (uint64_t);\n\t\taad[0] = LE_64(key->zk_guid);\n\t} else {\n\t\tASSERT3U(key->zk_version, ==, ZIO_CRYPT_KEY_CURRENT_VERSION);\n\t\taad_len = sizeof (uint64_t) * 3;\n\t\taad[0] = LE_64(key->zk_guid);\n\t\taad[1] = LE_64(crypt);\n\t\taad[2] = LE_64(key->zk_version);\n\t}\n\n\tiovecs[0].iov_base = aad;\n\tiovecs[0].iov_len = aad_len;\n\tenc_len = zio_crypt_table[crypt].ci_keylen + SHA512_HMAC_KEYLEN;\n\n\tGET_UIO_STRUCT(&cuio)->uio_iov = iovecs;\n\tzfs_uio_iovcnt(&cuio) = 4;\n\tzfs_uio_segflg(&cuio) = UIO_SYSSPACE;\n\n\t \n\tret = zio_do_crypt_uio_opencrypto(B_TRUE, NULL, crypt, cwkey,\n\t    iv, enc_len, &cuio, aad_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\nint\nzio_crypt_key_unwrap(crypto_key_t *cwkey, uint64_t crypt, uint64_t version,\n    uint64_t guid, uint8_t *keydata, uint8_t *hmac_keydata, uint8_t *iv,\n    uint8_t *mac, zio_crypt_key_t *key)\n{\n\tint ret;\n\tuint64_t aad[3];\n\t \n\tzfs_uio_t cuio;\n\tstruct uio cuio_s;\n\tiovec_t iovecs[4];\n\tvoid *src, *dst;\n\tuint_t enc_len, keydata_len, aad_len;\n\n\tASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);\n\n\tkeydata_len = zio_crypt_table[crypt].ci_keylen;\n\trw_init(&key->zk_salt_lock, NULL, RW_DEFAULT, NULL);\n\n\tzfs_uio_init(&cuio, &cuio_s);\n\n\t \n\tdst = key->zk_master_keydata;\n\tsrc = keydata;\n\tmemcpy(dst, src, keydata_len);\n\n\tdst = key->zk_hmac_keydata;\n\tsrc = hmac_keydata;\n\tmemcpy(dst, src, SHA512_HMAC_KEYLEN);\n\n\tiovecs[1].iov_base = key->zk_master_keydata;\n\tiovecs[1].iov_len = keydata_len;\n\tiovecs[2].iov_base = key->zk_hmac_keydata;\n\tiovecs[2].iov_len = SHA512_HMAC_KEYLEN;\n\tiovecs[3].iov_base = mac;\n\tiovecs[3].iov_len = WRAPPING_MAC_LEN;\n\n\tif (version == 0) {\n\t\taad_len = sizeof (uint64_t);\n\t\taad[0] = LE_64(guid);\n\t} else {\n\t\tASSERT3U(version, ==, ZIO_CRYPT_KEY_CURRENT_VERSION);\n\t\taad_len = sizeof (uint64_t) * 3;\n\t\taad[0] = LE_64(guid);\n\t\taad[1] = LE_64(crypt);\n\t\taad[2] = LE_64(version);\n\t}\n\n\tenc_len = keydata_len + SHA512_HMAC_KEYLEN;\n\tiovecs[0].iov_base = aad;\n\tiovecs[0].iov_len = aad_len;\n\n\tGET_UIO_STRUCT(&cuio)->uio_iov = iovecs;\n\tzfs_uio_iovcnt(&cuio) = 4;\n\tzfs_uio_segflg(&cuio) = UIO_SYSSPACE;\n\n\t \n\tret = zio_do_crypt_uio_opencrypto(B_FALSE, NULL, crypt, cwkey,\n\t    iv, enc_len, &cuio, aad_len);\n\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = random_get_bytes(key->zk_salt, ZIO_DATA_SALT_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t    key->zk_salt, ZIO_DATA_SALT_LEN, key->zk_current_keydata,\n\t    keydata_len);\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tkey->zk_current_key.ck_data = key->zk_current_keydata;\n\tkey->zk_current_key.ck_length = CRYPTO_BYTES2BITS(keydata_len);\n\n\tkey->zk_hmac_key.ck_data = key->zk_hmac_keydata;\n\tkey->zk_hmac_key.ck_length = CRYPTO_BYTES2BITS(SHA512_HMAC_KEYLEN);\n\n\tret = freebsd_crypt_newsession(&key->zk_session,\n\t    &zio_crypt_table[crypt], &key->zk_current_key);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tkey->zk_crypt = crypt;\n\tkey->zk_version = version;\n\tkey->zk_guid = guid;\n\tkey->zk_salt_count = 0;\n\n\treturn (0);\n\nerror:\n\tzio_crypt_key_destroy_early(key);\n\treturn (ret);\n}\n\nint\nzio_crypt_generate_iv(uint8_t *ivbuf)\n{\n\tint ret;\n\n\t \n\tret = random_get_pseudo_bytes(ivbuf, ZIO_DATA_IV_LEN);\n\tif (ret != 0)\n\t\tgoto error;\n\n\treturn (0);\n\nerror:\n\tmemset(ivbuf, 0, ZIO_DATA_IV_LEN);\n\treturn (ret);\n}\n\nint\nzio_crypt_do_hmac(zio_crypt_key_t *key, uint8_t *data, uint_t datalen,\n    uint8_t *digestbuf, uint_t digestlen)\n{\n\tuint8_t raw_digestbuf[SHA512_DIGEST_LENGTH];\n\n\tASSERT3U(digestlen, <=, SHA512_DIGEST_LENGTH);\n\n\tcrypto_mac(&key->zk_hmac_key, data, datalen,\n\t    raw_digestbuf, SHA512_DIGEST_LENGTH);\n\n\tmemcpy(digestbuf, raw_digestbuf, digestlen);\n\n\treturn (0);\n}\n\nint\nzio_crypt_generate_iv_salt_dedup(zio_crypt_key_t *key, uint8_t *data,\n    uint_t datalen, uint8_t *ivbuf, uint8_t *salt)\n{\n\tint ret;\n\tuint8_t digestbuf[SHA512_DIGEST_LENGTH];\n\n\tret = zio_crypt_do_hmac(key, data, datalen,\n\t    digestbuf, SHA512_DIGEST_LENGTH);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\tmemcpy(salt, digestbuf, ZIO_DATA_SALT_LEN);\n\tmemcpy(ivbuf, digestbuf + ZIO_DATA_SALT_LEN, ZIO_DATA_IV_LEN);\n\n\treturn (0);\n}\n\n \nvoid\nzio_crypt_encode_params_bp(blkptr_t *bp, uint8_t *salt, uint8_t *iv)\n{\n\tuint64_t val64;\n\tuint32_t val32;\n\n\tASSERT(BP_IS_ENCRYPTED(bp));\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(&bp->blk_dva[2].dva_word[0], salt, sizeof (uint64_t));\n\t\tmemcpy(&bp->blk_dva[2].dva_word[1], iv, sizeof (uint64_t));\n\t\tmemcpy(&val32, iv + sizeof (uint64_t), sizeof (uint32_t));\n\t\tBP_SET_IV2(bp, val32);\n\t} else {\n\t\tmemcpy(&val64, salt, sizeof (uint64_t));\n\t\tbp->blk_dva[2].dva_word[0] = BSWAP_64(val64);\n\n\t\tmemcpy(&val64, iv, sizeof (uint64_t));\n\t\tbp->blk_dva[2].dva_word[1] = BSWAP_64(val64);\n\n\t\tmemcpy(&val32, iv + sizeof (uint64_t), sizeof (uint32_t));\n\t\tBP_SET_IV2(bp, BSWAP_32(val32));\n\t}\n}\n\nvoid\nzio_crypt_decode_params_bp(const blkptr_t *bp, uint8_t *salt, uint8_t *iv)\n{\n\tuint64_t val64;\n\tuint32_t val32;\n\n\tASSERT(BP_IS_PROTECTED(bp));\n\n\t \n\tif (BP_IS_AUTHENTICATED(bp)) {\n\t\tmemset(salt, 0, ZIO_DATA_SALT_LEN);\n\t\tmemset(iv, 0, ZIO_DATA_IV_LEN);\n\t\treturn;\n\t}\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(salt, &bp->blk_dva[2].dva_word[0], sizeof (uint64_t));\n\t\tmemcpy(iv, &bp->blk_dva[2].dva_word[1], sizeof (uint64_t));\n\n\t\tval32 = (uint32_t)BP_GET_IV2(bp);\n\t\tmemcpy(iv + sizeof (uint64_t), &val32, sizeof (uint32_t));\n\t} else {\n\t\tval64 = BSWAP_64(bp->blk_dva[2].dva_word[0]);\n\t\tmemcpy(salt, &val64, sizeof (uint64_t));\n\n\t\tval64 = BSWAP_64(bp->blk_dva[2].dva_word[1]);\n\t\tmemcpy(iv, &val64, sizeof (uint64_t));\n\n\t\tval32 = BSWAP_32((uint32_t)BP_GET_IV2(bp));\n\t\tmemcpy(iv + sizeof (uint64_t), &val32, sizeof (uint32_t));\n\t}\n}\n\nvoid\nzio_crypt_encode_mac_bp(blkptr_t *bp, uint8_t *mac)\n{\n\tuint64_t val64;\n\n\tASSERT(BP_USES_CRYPT(bp));\n\tASSERT3U(BP_GET_TYPE(bp), !=, DMU_OT_OBJSET);\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(&bp->blk_cksum.zc_word[2], mac, sizeof (uint64_t));\n\t\tmemcpy(&bp->blk_cksum.zc_word[3], mac + sizeof (uint64_t),\n\t\t    sizeof (uint64_t));\n\t} else {\n\t\tmemcpy(&val64, mac, sizeof (uint64_t));\n\t\tbp->blk_cksum.zc_word[2] = BSWAP_64(val64);\n\n\t\tmemcpy(&val64, mac + sizeof (uint64_t), sizeof (uint64_t));\n\t\tbp->blk_cksum.zc_word[3] = BSWAP_64(val64);\n\t}\n}\n\nvoid\nzio_crypt_decode_mac_bp(const blkptr_t *bp, uint8_t *mac)\n{\n\tuint64_t val64;\n\n\tASSERT(BP_USES_CRYPT(bp) || BP_IS_HOLE(bp));\n\n\t \n\tif (BP_GET_TYPE(bp) == DMU_OT_OBJSET) {\n\t\tmemset(mac, 0, ZIO_DATA_MAC_LEN);\n\t\treturn;\n\t}\n\n\tif (!BP_SHOULD_BYTESWAP(bp)) {\n\t\tmemcpy(mac, &bp->blk_cksum.zc_word[2], sizeof (uint64_t));\n\t\tmemcpy(mac + sizeof (uint64_t), &bp->blk_cksum.zc_word[3],\n\t\t    sizeof (uint64_t));\n\t} else {\n\t\tval64 = BSWAP_64(bp->blk_cksum.zc_word[2]);\n\t\tmemcpy(mac, &val64, sizeof (uint64_t));\n\n\t\tval64 = BSWAP_64(bp->blk_cksum.zc_word[3]);\n\t\tmemcpy(mac + sizeof (uint64_t), &val64, sizeof (uint64_t));\n\t}\n}\n\nvoid\nzio_crypt_encode_mac_zil(void *data, uint8_t *mac)\n{\n\tzil_chain_t *zilc = data;\n\n\tmemcpy(&zilc->zc_eck.zec_cksum.zc_word[2], mac, sizeof (uint64_t));\n\tmemcpy(&zilc->zc_eck.zec_cksum.zc_word[3], mac + sizeof (uint64_t),\n\t    sizeof (uint64_t));\n}\n\nvoid\nzio_crypt_decode_mac_zil(const void *data, uint8_t *mac)\n{\n\t \n\tconst zil_chain_t *zilc = data;\n\n\tmemcpy(mac, &zilc->zc_eck.zec_cksum.zc_word[2], sizeof (uint64_t));\n\tmemcpy(mac + sizeof (uint64_t), &zilc->zc_eck.zec_cksum.zc_word[3],\n\t    sizeof (uint64_t));\n}\n\n \nvoid\nzio_crypt_copy_dnode_bonus(abd_t *src_abd, uint8_t *dst, uint_t datalen)\n{\n\tuint_t i, max_dnp = datalen >> DNODE_SHIFT;\n\tuint8_t *src;\n\tdnode_phys_t *dnp, *sdnp, *ddnp;\n\n\tsrc = abd_borrow_buf_copy(src_abd, datalen);\n\n\tsdnp = (dnode_phys_t *)src;\n\tddnp = (dnode_phys_t *)dst;\n\n\tfor (i = 0; i < max_dnp; i += sdnp[i].dn_extra_slots + 1) {\n\t\tdnp = &sdnp[i];\n\t\tif (dnp->dn_type != DMU_OT_NONE &&\n\t\t    DMU_OT_IS_ENCRYPTED(dnp->dn_bonustype) &&\n\t\t    dnp->dn_bonuslen != 0) {\n\t\t\tmemcpy(DN_BONUS(&ddnp[i]), DN_BONUS(dnp),\n\t\t\t    DN_MAX_BONUS_LEN(dnp));\n\t\t}\n\t}\n\n\tabd_return_buf(src_abd, src, datalen);\n}\n\n \nstatic void\nzio_crypt_bp_zero_nonportable_blkprop(blkptr_t *bp, uint64_t version)\n{\n\tint avoidlint = SPA_MINBLOCKSIZE;\n\t \n\tif (version == 0) {\n\t\tBP_SET_DEDUP(bp, 0);\n\t\tBP_SET_CHECKSUM(bp, 0);\n\t\tBP_SET_PSIZE(bp, avoidlint);\n\t\treturn;\n\t}\n\n\tASSERT3U(version, ==, ZIO_CRYPT_KEY_CURRENT_VERSION);\n\n\t \n\tif (BP_IS_HOLE(bp)) {\n\t\tbp->blk_prop = 0ULL;\n\t\treturn;\n\t}\n\n\t \n\tif (BP_GET_LEVEL(bp) != 0) {\n\t\tBP_SET_BYTEORDER(bp, 0);\n\t\tBP_SET_COMPRESS(bp, 0);\n\n\t\t \n\t\tBP_SET_PSIZE(bp, avoidlint);\n\t}\n\n\tBP_SET_DEDUP(bp, 0);\n\tBP_SET_CHECKSUM(bp, 0);\n}\n\nstatic void\nzio_crypt_bp_auth_init(uint64_t version, boolean_t should_bswap, blkptr_t *bp,\n    blkptr_auth_buf_t *bab, uint_t *bab_len)\n{\n\tblkptr_t tmpbp = *bp;\n\n\tif (should_bswap)\n\t\tbyteswap_uint64_array(&tmpbp, sizeof (blkptr_t));\n\n\tASSERT(BP_USES_CRYPT(&tmpbp) || BP_IS_HOLE(&tmpbp));\n\tASSERT0(BP_IS_EMBEDDED(&tmpbp));\n\n\tzio_crypt_decode_mac_bp(&tmpbp, bab->bab_mac);\n\n\t \n\tzio_crypt_bp_zero_nonportable_blkprop(&tmpbp, version);\n\tbab->bab_prop = LE_64(tmpbp.blk_prop);\n\tbab->bab_pad = 0ULL;\n\n\t \n\t*bab_len = sizeof (blkptr_auth_buf_t);\n\tif (version == 0)\n\t\t*bab_len -= sizeof (uint64_t);\n}\n\nstatic int\nzio_crypt_bp_do_hmac_updates(crypto_context_t ctx, uint64_t version,\n    boolean_t should_bswap, blkptr_t *bp)\n{\n\tuint_t bab_len;\n\tblkptr_auth_buf_t bab;\n\n\tzio_crypt_bp_auth_init(version, should_bswap, bp, &bab, &bab_len);\n\tcrypto_mac_update(ctx, &bab, bab_len);\n\n\treturn (0);\n}\n\nstatic void\nzio_crypt_bp_do_indrect_checksum_updates(SHA2_CTX *ctx, uint64_t version,\n    boolean_t should_bswap, blkptr_t *bp)\n{\n\tuint_t bab_len;\n\tblkptr_auth_buf_t bab;\n\n\tzio_crypt_bp_auth_init(version, should_bswap, bp, &bab, &bab_len);\n\tSHA2Update(ctx, &bab, bab_len);\n}\n\nstatic void\nzio_crypt_bp_do_aad_updates(uint8_t **aadp, uint_t *aad_len, uint64_t version,\n    boolean_t should_bswap, blkptr_t *bp)\n{\n\tuint_t bab_len;\n\tblkptr_auth_buf_t bab;\n\n\tzio_crypt_bp_auth_init(version, should_bswap, bp, &bab, &bab_len);\n\tmemcpy(*aadp, &bab, bab_len);\n\t*aadp += bab_len;\n\t*aad_len += bab_len;\n}\n\nstatic int\nzio_crypt_do_dnode_hmac_updates(crypto_context_t ctx, uint64_t version,\n    boolean_t should_bswap, dnode_phys_t *dnp)\n{\n\tint ret, i;\n\tdnode_phys_t *adnp;\n\tboolean_t le_bswap = (should_bswap == ZFS_HOST_BYTEORDER);\n\tuint8_t tmp_dncore[offsetof(dnode_phys_t, dn_blkptr)];\n\n\t \n\tmemcpy(tmp_dncore, dnp, sizeof (tmp_dncore));\n\tadnp = (dnode_phys_t *)tmp_dncore;\n\tif (le_bswap) {\n\t\tadnp->dn_datablkszsec = BSWAP_16(adnp->dn_datablkszsec);\n\t\tadnp->dn_bonuslen = BSWAP_16(adnp->dn_bonuslen);\n\t\tadnp->dn_maxblkid = BSWAP_64(adnp->dn_maxblkid);\n\t\tadnp->dn_used = BSWAP_64(adnp->dn_used);\n\t}\n\tadnp->dn_flags &= DNODE_CRYPT_PORTABLE_FLAGS_MASK;\n\tadnp->dn_used = 0;\n\n\tcrypto_mac_update(ctx, adnp, sizeof (tmp_dncore));\n\n\tfor (i = 0; i < dnp->dn_nblkptr; i++) {\n\t\tret = zio_crypt_bp_do_hmac_updates(ctx, version,\n\t\t    should_bswap, &dnp->dn_blkptr[i]);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\tret = zio_crypt_bp_do_hmac_updates(ctx, version,\n\t\t    should_bswap, DN_SPILL_BLKPTR(dnp));\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t}\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\n \nint\nzio_crypt_do_objset_hmacs(zio_crypt_key_t *key, void *data, uint_t datalen,\n    boolean_t should_bswap, uint8_t *portable_mac, uint8_t *local_mac)\n{\n\tint ret;\n\tstruct hmac_ctx hash_ctx;\n\tstruct hmac_ctx *ctx = &hash_ctx;\n\tobjset_phys_t *osp = data;\n\tuint64_t intval;\n\tboolean_t le_bswap = (should_bswap == ZFS_HOST_BYTEORDER);\n\tuint8_t raw_portable_mac[SHA512_DIGEST_LENGTH];\n\tuint8_t raw_local_mac[SHA512_DIGEST_LENGTH];\n\n\n\t \n\tcrypto_mac_init(ctx, &key->zk_hmac_key);\n\n\t \n\tintval = (le_bswap) ? osp->os_type : BSWAP_64(osp->os_type);\n\tcrypto_mac_update(ctx, &intval, sizeof (uint64_t));\n\n\t \n\tintval = osp->os_flags;\n\tif (should_bswap)\n\t\tintval = BSWAP_64(intval);\n\tintval &= OBJSET_CRYPT_PORTABLE_FLAGS_MASK;\n\tif (!ZFS_HOST_BYTEORDER)\n\t\tintval = BSWAP_64(intval);\n\n\tcrypto_mac_update(ctx, &intval, sizeof (uint64_t));\n\n\t \n\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t    should_bswap, &osp->os_meta_dnode);\n\tif (ret)\n\t\tgoto error;\n\n\tcrypto_mac_final(ctx, raw_portable_mac, SHA512_DIGEST_LENGTH);\n\n\tmemcpy(portable_mac, raw_portable_mac, ZIO_OBJSET_MAC_LEN);\n\n\t \n\tintval = osp->os_flags;\n\tif (should_bswap)\n\t\tintval = BSWAP_64(intval);\n\tboolean_t uacct_incomplete =\n\t    !(intval & OBJSET_FLAG_USERACCOUNTING_COMPLETE);\n\n\t \n\tif (uacct_incomplete ||\n\t    (datalen >= OBJSET_PHYS_SIZE_V3 &&\n\t    osp->os_userused_dnode.dn_type == DMU_OT_NONE &&\n\t    osp->os_groupused_dnode.dn_type == DMU_OT_NONE &&\n\t    osp->os_projectused_dnode.dn_type == DMU_OT_NONE) ||\n\t    (datalen >= OBJSET_PHYS_SIZE_V2 &&\n\t    osp->os_userused_dnode.dn_type == DMU_OT_NONE &&\n\t    osp->os_groupused_dnode.dn_type == DMU_OT_NONE) ||\n\t    (datalen <= OBJSET_PHYS_SIZE_V1)) {\n\t\tmemset(local_mac, 0, ZIO_OBJSET_MAC_LEN);\n\t\treturn (0);\n\t}\n\n\t \n\tcrypto_mac_init(ctx, &key->zk_hmac_key);\n\n\t \n\tintval = osp->os_flags;\n\tif (should_bswap)\n\t\tintval = BSWAP_64(intval);\n\tintval &= ~OBJSET_CRYPT_PORTABLE_FLAGS_MASK;\n\tif (!ZFS_HOST_BYTEORDER)\n\t\tintval = BSWAP_64(intval);\n\n\tcrypto_mac_update(ctx, &intval, sizeof (uint64_t));\n\n\t \n\t \n\tif (osp->os_userused_dnode.dn_type != DMU_OT_NONE) {\n\t\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t\t    should_bswap, &osp->os_userused_dnode);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (osp->os_groupused_dnode.dn_type != DMU_OT_NONE) {\n\t\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t\t    should_bswap, &osp->os_groupused_dnode);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tif (osp->os_projectused_dnode.dn_type != DMU_OT_NONE &&\n\t    datalen >= OBJSET_PHYS_SIZE_V3) {\n\t\tret = zio_crypt_do_dnode_hmac_updates(ctx, key->zk_version,\n\t\t    should_bswap, &osp->os_projectused_dnode);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tcrypto_mac_final(ctx, raw_local_mac, SHA512_DIGEST_LENGTH);\n\n\tmemcpy(local_mac, raw_local_mac, ZIO_OBJSET_MAC_LEN);\n\n\treturn (0);\n\nerror:\n\tmemset(portable_mac, 0, ZIO_OBJSET_MAC_LEN);\n\tmemset(local_mac, 0, ZIO_OBJSET_MAC_LEN);\n\treturn (ret);\n}\n\nstatic void\nzio_crypt_destroy_uio(zfs_uio_t *uio)\n{\n\tif (GET_UIO_STRUCT(uio)->uio_iov)\n\t\tkmem_free(GET_UIO_STRUCT(uio)->uio_iov,\n\t\t    zfs_uio_iovcnt(uio) * sizeof (iovec_t));\n}\n\n \nstatic int\nzio_crypt_do_indirect_mac_checksum_impl(boolean_t generate, void *buf,\n    uint_t datalen, uint64_t version, boolean_t byteswap, uint8_t *cksum)\n{\n\tblkptr_t *bp;\n\tint i, epb = datalen >> SPA_BLKPTRSHIFT;\n\tSHA2_CTX ctx;\n\tuint8_t digestbuf[SHA512_DIGEST_LENGTH];\n\n\t \n\tSHA2Init(SHA512, &ctx);\n\tfor (i = 0, bp = buf; i < epb; i++, bp++) {\n\t\tzio_crypt_bp_do_indrect_checksum_updates(&ctx, version,\n\t\t    byteswap, bp);\n\t}\n\tSHA2Final(digestbuf, &ctx);\n\n\tif (generate) {\n\t\tmemcpy(cksum, digestbuf, ZIO_DATA_MAC_LEN);\n\t\treturn (0);\n\t}\n\n\tif (memcmp(digestbuf, cksum, ZIO_DATA_MAC_LEN) != 0) {\n#ifdef FCRYPTO_DEBUG\n\t\tprintf(\"%s(%d): Setting ECKSUM\\n\", __FUNCTION__, __LINE__);\n#endif\n\t\treturn (SET_ERROR(ECKSUM));\n\t}\n\treturn (0);\n}\n\nint\nzio_crypt_do_indirect_mac_checksum(boolean_t generate, void *buf,\n    uint_t datalen, boolean_t byteswap, uint8_t *cksum)\n{\n\tint ret;\n\n\t \n\tret = zio_crypt_do_indirect_mac_checksum_impl(generate, buf,\n\t    datalen, ZIO_CRYPT_KEY_CURRENT_VERSION, byteswap, cksum);\n\tif (ret == ECKSUM) {\n\t\tASSERT(!generate);\n\t\tret = zio_crypt_do_indirect_mac_checksum_impl(generate,\n\t\t    buf, datalen, 0, byteswap, cksum);\n\t}\n\n\treturn (ret);\n}\n\nint\nzio_crypt_do_indirect_mac_checksum_abd(boolean_t generate, abd_t *abd,\n    uint_t datalen, boolean_t byteswap, uint8_t *cksum)\n{\n\tint ret;\n\tvoid *buf;\n\n\tbuf = abd_borrow_buf_copy(abd, datalen);\n\tret = zio_crypt_do_indirect_mac_checksum(generate, buf, datalen,\n\t    byteswap, cksum);\n\tabd_return_buf(abd, buf, datalen);\n\n\treturn (ret);\n}\n\n \n \n\nstatic int\nzio_crypt_init_uios_zil(boolean_t encrypt, uint8_t *plainbuf,\n    uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap, zfs_uio_t *puio,\n    zfs_uio_t *out_uio, uint_t *enc_len, uint8_t **authbuf, uint_t *auth_len,\n    boolean_t *no_crypt)\n{\n\t(void) puio;\n\tuint8_t *aadbuf = zio_buf_alloc(datalen);\n\tuint8_t *src, *dst, *slrp, *dlrp, *blkend, *aadp;\n\tiovec_t *dst_iovecs;\n\tzil_chain_t *zilc;\n\tlr_t *lr;\n\tuint64_t txtype, lr_len;\n\tuint_t crypt_len, nr_iovecs, vec;\n\tuint_t aad_len = 0, total_len = 0;\n\n\tif (encrypt) {\n\t\tsrc = plainbuf;\n\t\tdst = cipherbuf;\n\t} else {\n\t\tsrc = cipherbuf;\n\t\tdst = plainbuf;\n\t}\n\tmemcpy(dst, src, datalen);\n\n\t \n\tzilc = (zil_chain_t *)src;\n\tslrp = src + sizeof (zil_chain_t);\n\taadp = aadbuf;\n\tblkend = src + ((byteswap) ? BSWAP_64(zilc->zc_nused) : zilc->zc_nused);\n\n\t \n\n\t \n\tnr_iovecs = 2;\n\n\tfor (; slrp < blkend; slrp += lr_len) {\n\t\tlr = (lr_t *)slrp;\n\n\t\tif (byteswap) {\n\t\t\ttxtype = BSWAP_64(lr->lrc_txtype);\n\t\t\tlr_len = BSWAP_64(lr->lrc_reclen);\n\t\t} else {\n\t\t\ttxtype = lr->lrc_txtype;\n\t\t\tlr_len = lr->lrc_reclen;\n\t\t}\n\n\t\tnr_iovecs++;\n\t\tif (txtype == TX_WRITE && lr_len != sizeof (lr_write_t))\n\t\t\tnr_iovecs++;\n\t}\n\n\tdst_iovecs = kmem_alloc(nr_iovecs * sizeof (iovec_t), KM_SLEEP);\n\n\t \n\tmemcpy(aadp, src, sizeof (zil_chain_t) - sizeof (zio_eck_t));\n\taadp += sizeof (zil_chain_t) - sizeof (zio_eck_t);\n\taad_len += sizeof (zil_chain_t) - sizeof (zio_eck_t);\n\n\tslrp = src + sizeof (zil_chain_t);\n\tdlrp = dst + sizeof (zil_chain_t);\n\n\t \n\n\t \n\tvec = 1;\n\n\tfor (; slrp < blkend; slrp += lr_len, dlrp += lr_len) {\n\t\tlr = (lr_t *)slrp;\n\n\t\tif (!byteswap) {\n\t\t\ttxtype = lr->lrc_txtype;\n\t\t\tlr_len = lr->lrc_reclen;\n\t\t} else {\n\t\t\ttxtype = BSWAP_64(lr->lrc_txtype);\n\t\t\tlr_len = BSWAP_64(lr->lrc_reclen);\n\t\t}\n\n\t\t \n\t\tmemcpy(dlrp, slrp, sizeof (lr_t));\n\t\tmemcpy(aadp, slrp, sizeof (lr_t));\n\t\taadp += sizeof (lr_t);\n\t\taad_len += sizeof (lr_t);\n\n\t\t \n\t\tif (txtype == TX_WRITE) {\n\t\t\tcrypt_len = sizeof (lr_write_t) -\n\t\t\t    sizeof (lr_t) - sizeof (blkptr_t);\n\t\t\tdst_iovecs[vec].iov_base = (char *)dlrp +\n\t\t\t    sizeof (lr_t);\n\t\t\tdst_iovecs[vec].iov_len = crypt_len;\n\n\t\t\t \n\t\t\tmemcpy(dlrp + sizeof (lr_write_t) - sizeof (blkptr_t),\n\t\t\t    slrp + sizeof (lr_write_t) - sizeof (blkptr_t),\n\t\t\t    sizeof (blkptr_t));\n\t\t\tmemcpy(aadp,\n\t\t\t    slrp + sizeof (lr_write_t) - sizeof (blkptr_t),\n\t\t\t    sizeof (blkptr_t));\n\t\t\taadp += sizeof (blkptr_t);\n\t\t\taad_len += sizeof (blkptr_t);\n\t\t\tvec++;\n\t\t\ttotal_len += crypt_len;\n\n\t\t\tif (lr_len != sizeof (lr_write_t)) {\n\t\t\t\tcrypt_len = lr_len - sizeof (lr_write_t);\n\t\t\t\tdst_iovecs[vec].iov_base = (char *)\n\t\t\t\t    dlrp + sizeof (lr_write_t);\n\t\t\t\tdst_iovecs[vec].iov_len = crypt_len;\n\t\t\t\tvec++;\n\t\t\t\ttotal_len += crypt_len;\n\t\t\t}\n\t\t} else if (txtype == TX_CLONE_RANGE) {\n\t\t\tconst size_t o = offsetof(lr_clone_range_t, lr_nbps);\n\t\t\tcrypt_len = o - sizeof (lr_t);\n\t\t\tdst_iovecs[vec].iov_base = (char *)dlrp + sizeof (lr_t);\n\t\t\tdst_iovecs[vec].iov_len = crypt_len;\n\n\t\t\t \n\t\t\tmemcpy(dlrp + o, slrp + o, lr_len - o);\n\t\t\tmemcpy(aadp, slrp + o, lr_len - o);\n\t\t\taadp += lr_len - o;\n\t\t\taad_len += lr_len - o;\n\t\t\tvec++;\n\t\t\ttotal_len += crypt_len;\n\t\t} else {\n\t\t\tcrypt_len = lr_len - sizeof (lr_t);\n\t\t\tdst_iovecs[vec].iov_base = (char *)dlrp +\n\t\t\t    sizeof (lr_t);\n\t\t\tdst_iovecs[vec].iov_len = crypt_len;\n\t\t\tvec++;\n\t\t\ttotal_len += crypt_len;\n\t\t}\n\t}\n\n\t \n\tASSERT3U(vec, ==, nr_iovecs - 1);\n\n\t \n\tdst_iovecs[0].iov_base = aadbuf;\n\tdst_iovecs[0].iov_len = aad_len;\n\t \n\tdst_iovecs[vec].iov_base = 0;\n\tdst_iovecs[vec].iov_len = 0;\n\n\t*no_crypt = (vec == 1);\n\t*enc_len = total_len;\n\t*authbuf = aadbuf;\n\t*auth_len = aad_len;\n\tGET_UIO_STRUCT(out_uio)->uio_iov = dst_iovecs;\n\tzfs_uio_iovcnt(out_uio) = nr_iovecs;\n\n\treturn (0);\n}\n\n \nstatic int\nzio_crypt_init_uios_dnode(boolean_t encrypt, uint64_t version,\n    uint8_t *plainbuf, uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap,\n    zfs_uio_t *puio, zfs_uio_t *out_uio, uint_t *enc_len, uint8_t **authbuf,\n    uint_t *auth_len, boolean_t *no_crypt)\n{\n\tuint8_t *aadbuf = zio_buf_alloc(datalen);\n\tuint8_t *src, *dst, *aadp;\n\tdnode_phys_t *dnp, *adnp, *sdnp, *ddnp;\n\tiovec_t *dst_iovecs;\n\tuint_t nr_iovecs, crypt_len, vec;\n\tuint_t aad_len = 0, total_len = 0;\n\tuint_t i, j, max_dnp = datalen >> DNODE_SHIFT;\n\n\tif (encrypt) {\n\t\tsrc = plainbuf;\n\t\tdst = cipherbuf;\n\t} else {\n\t\tsrc = cipherbuf;\n\t\tdst = plainbuf;\n\t}\n\tmemcpy(dst, src, datalen);\n\n\tsdnp = (dnode_phys_t *)src;\n\tddnp = (dnode_phys_t *)dst;\n\taadp = aadbuf;\n\n\t \n\n\t \n\tnr_iovecs = 2;\n\n\tfor (i = 0; i < max_dnp; i += sdnp[i].dn_extra_slots + 1) {\n\t\t \n\t\tif (sdnp[i].dn_type != DMU_OT_NONE &&\n\t\t    DMU_OT_IS_ENCRYPTED(sdnp[i].dn_bonustype) &&\n\t\t    sdnp[i].dn_bonuslen != 0) {\n\t\t\tnr_iovecs++;\n\t\t}\n\t}\n\n\tdst_iovecs = kmem_alloc(nr_iovecs * sizeof (iovec_t), KM_SLEEP);\n\n\t \n\n\t \n\tvec = 1;\n\n\tfor (i = 0; i < max_dnp; i += sdnp[i].dn_extra_slots + 1) {\n\t\tdnp = &sdnp[i];\n\n\t\t \n\t\tmemcpy(&ddnp[i], dnp,\n\t\t    (uint8_t *)DN_BONUS(dnp) - (uint8_t *)dnp);\n\n\t\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\t\tmemcpy(DN_SPILL_BLKPTR(&ddnp[i]), DN_SPILL_BLKPTR(dnp),\n\t\t\t    sizeof (blkptr_t));\n\t\t}\n\n\t\t \n\t\tcrypt_len = offsetof(dnode_phys_t, dn_blkptr);\n\t\tmemcpy(aadp, dnp, crypt_len);\n\t\tadnp = (dnode_phys_t *)aadp;\n\t\tadnp->dn_flags &= DNODE_CRYPT_PORTABLE_FLAGS_MASK;\n\t\tadnp->dn_used = 0;\n\t\taadp += crypt_len;\n\t\taad_len += crypt_len;\n\n\t\tfor (j = 0; j < dnp->dn_nblkptr; j++) {\n\t\t\tzio_crypt_bp_do_aad_updates(&aadp, &aad_len,\n\t\t\t    version, byteswap, &dnp->dn_blkptr[j]);\n\t\t}\n\n\t\tif (dnp->dn_flags & DNODE_FLAG_SPILL_BLKPTR) {\n\t\t\tzio_crypt_bp_do_aad_updates(&aadp, &aad_len,\n\t\t\t    version, byteswap, DN_SPILL_BLKPTR(dnp));\n\t\t}\n\n\t\t \n\t\tcrypt_len = DN_MAX_BONUS_LEN(dnp);\n\t\tif (dnp->dn_type != DMU_OT_NONE &&\n\t\t    DMU_OT_IS_ENCRYPTED(dnp->dn_bonustype) &&\n\t\t    dnp->dn_bonuslen != 0) {\n\t\t\tdst_iovecs[vec].iov_base = DN_BONUS(&ddnp[i]);\n\t\t\tdst_iovecs[vec].iov_len = crypt_len;\n\n\t\t\tvec++;\n\t\t\ttotal_len += crypt_len;\n\t\t} else {\n\t\t\tmemcpy(DN_BONUS(&ddnp[i]), DN_BONUS(dnp), crypt_len);\n\t\t\tmemcpy(aadp, DN_BONUS(dnp), crypt_len);\n\t\t\taadp += crypt_len;\n\t\t\taad_len += crypt_len;\n\t\t}\n\t}\n\n\t \n\tASSERT3U(vec, ==, nr_iovecs - 1);\n\n\t \n\tdst_iovecs[0].iov_base = aadbuf;\n\tdst_iovecs[0].iov_len = aad_len;\n\t \n\tdst_iovecs[vec].iov_base = 0;\n\tdst_iovecs[vec].iov_len = 0;\n\n\t*no_crypt = (vec == 1);\n\t*enc_len = total_len;\n\t*authbuf = aadbuf;\n\t*auth_len = aad_len;\n\tGET_UIO_STRUCT(out_uio)->uio_iov = dst_iovecs;\n\tzfs_uio_iovcnt(out_uio) = nr_iovecs;\n\n\treturn (0);\n}\n\nstatic int\nzio_crypt_init_uios_normal(boolean_t encrypt, uint8_t *plainbuf,\n    uint8_t *cipherbuf, uint_t datalen, zfs_uio_t *puio, zfs_uio_t *out_uio,\n    uint_t *enc_len)\n{\n\t(void) puio;\n\tint ret;\n\tuint_t nr_plain = 1, nr_cipher = 2;\n\tiovec_t *plain_iovecs = NULL, *cipher_iovecs = NULL;\n\tvoid *src, *dst;\n\n\tcipher_iovecs = kmem_zalloc(nr_cipher * sizeof (iovec_t),\n\t    KM_SLEEP);\n\tif (!cipher_iovecs) {\n\t\tret = SET_ERROR(ENOMEM);\n\t\tgoto error;\n\t}\n\n\tif (encrypt) {\n\t\tsrc = plainbuf;\n\t\tdst = cipherbuf;\n\t} else {\n\t\tsrc = cipherbuf;\n\t\tdst = plainbuf;\n\t}\n\tmemcpy(dst, src, datalen);\n\tcipher_iovecs[0].iov_base = dst;\n\tcipher_iovecs[0].iov_len = datalen;\n\n\t*enc_len = datalen;\n\tGET_UIO_STRUCT(out_uio)->uio_iov = cipher_iovecs;\n\tzfs_uio_iovcnt(out_uio) = nr_cipher;\n\n\treturn (0);\n\nerror:\n\tif (plain_iovecs != NULL)\n\t\tkmem_free(plain_iovecs, nr_plain * sizeof (iovec_t));\n\tif (cipher_iovecs != NULL)\n\t\tkmem_free(cipher_iovecs, nr_cipher * sizeof (iovec_t));\n\n\t*enc_len = 0;\n\tGET_UIO_STRUCT(out_uio)->uio_iov = NULL;\n\tzfs_uio_iovcnt(out_uio) = 0;\n\n\treturn (ret);\n}\n\n \nstatic int\nzio_crypt_init_uios(boolean_t encrypt, uint64_t version, dmu_object_type_t ot,\n    uint8_t *plainbuf, uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap,\n    uint8_t *mac, zfs_uio_t *puio, zfs_uio_t *cuio, uint_t *enc_len,\n    uint8_t **authbuf, uint_t *auth_len, boolean_t *no_crypt)\n{\n\tint ret;\n\tiovec_t *mac_iov;\n\n\tASSERT(DMU_OT_IS_ENCRYPTED(ot) || ot == DMU_OT_NONE);\n\n\t \n\tswitch (ot) {\n\tcase DMU_OT_INTENT_LOG:\n\t\tret = zio_crypt_init_uios_zil(encrypt, plainbuf, cipherbuf,\n\t\t    datalen, byteswap, puio, cuio, enc_len, authbuf, auth_len,\n\t\t    no_crypt);\n\t\tbreak;\n\tcase DMU_OT_DNODE:\n\t\tret = zio_crypt_init_uios_dnode(encrypt, version, plainbuf,\n\t\t    cipherbuf, datalen, byteswap, puio, cuio, enc_len, authbuf,\n\t\t    auth_len, no_crypt);\n\t\tbreak;\n\tdefault:\n\t\tret = zio_crypt_init_uios_normal(encrypt, plainbuf, cipherbuf,\n\t\t    datalen, puio, cuio, enc_len);\n\t\t*authbuf = NULL;\n\t\t*auth_len = 0;\n\t\t*no_crypt = B_FALSE;\n\t\tbreak;\n\t}\n\n\tif (ret != 0)\n\t\tgoto error;\n\n\t \n\tzfs_uio_segflg(cuio) = UIO_SYSSPACE;\n\n\tmac_iov =\n\t    ((iovec_t *)&(GET_UIO_STRUCT(cuio)->\n\t    uio_iov[zfs_uio_iovcnt(cuio) - 1]));\n\tmac_iov->iov_base = (void *)mac;\n\tmac_iov->iov_len = ZIO_DATA_MAC_LEN;\n\n\treturn (0);\n\nerror:\n\treturn (ret);\n}\n\nvoid *failed_decrypt_buf;\nint faile_decrypt_size;\n\n \nint\nzio_do_crypt_data(boolean_t encrypt, zio_crypt_key_t *key,\n    dmu_object_type_t ot, boolean_t byteswap, uint8_t *salt, uint8_t *iv,\n    uint8_t *mac, uint_t datalen, uint8_t *plainbuf, uint8_t *cipherbuf,\n    boolean_t *no_crypt)\n{\n\tint ret;\n\tboolean_t locked = B_FALSE;\n\tuint64_t crypt = key->zk_crypt;\n\tuint_t keydata_len = zio_crypt_table[crypt].ci_keylen;\n\tuint_t enc_len, auth_len;\n\tzfs_uio_t puio, cuio;\n\tstruct uio puio_s, cuio_s;\n\tuint8_t enc_keydata[MASTER_KEY_MAX_LEN];\n\tcrypto_key_t tmp_ckey, *ckey = NULL;\n\tfreebsd_crypt_session_t *tmpl = NULL;\n\tuint8_t *authbuf = NULL;\n\n\n\tzfs_uio_init(&puio, &puio_s);\n\tzfs_uio_init(&cuio, &cuio_s);\n\tmemset(GET_UIO_STRUCT(&puio), 0, sizeof (struct uio));\n\tmemset(GET_UIO_STRUCT(&cuio), 0, sizeof (struct uio));\n\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s(%s, %p, %p, %d, %p, %p, %u, %s, %p, %p, %p)\\n\",\n\t    __FUNCTION__,\n\t    encrypt ? \"encrypt\" : \"decrypt\",\n\t    key, salt, ot, iv, mac, datalen,\n\t    byteswap ? \"byteswap\" : \"native_endian\", plainbuf,\n\t    cipherbuf, no_crypt);\n\n\tprintf(\"\\tkey = {\");\n\tfor (int i = 0; i < key->zk_current_key.ck_length/8; i++)\n\t\tprintf(\"%02x \", ((uint8_t *)key->zk_current_key.ck_data)[i]);\n\tprintf(\"}\\n\");\n#endif\n\t \n\tret = zio_crypt_init_uios(encrypt, key->zk_version, ot, plainbuf,\n\t    cipherbuf, datalen, byteswap, mac, &puio, &cuio, &enc_len,\n\t    &authbuf, &auth_len, no_crypt);\n\tif (ret != 0)\n\t\treturn (ret);\n\n\t \n\trw_enter(&key->zk_salt_lock, RW_READER);\n\tlocked = B_TRUE;\n\n\tif (memcmp(salt, key->zk_salt, ZIO_DATA_SALT_LEN) == 0) {\n\t\tckey = &key->zk_current_key;\n\t\ttmpl = &key->zk_session;\n\t} else {\n\t\trw_exit(&key->zk_salt_lock);\n\t\tlocked = B_FALSE;\n\n\t\tret = hkdf_sha512(key->zk_master_keydata, keydata_len, NULL, 0,\n\t\t    salt, ZIO_DATA_SALT_LEN, enc_keydata, keydata_len);\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\t\ttmp_ckey.ck_data = enc_keydata;\n\t\ttmp_ckey.ck_length = CRYPTO_BYTES2BITS(keydata_len);\n\n\t\tckey = &tmp_ckey;\n\t\ttmpl = NULL;\n\t}\n\n\t \n\tret = zio_do_crypt_uio_opencrypto(encrypt, tmpl, key->zk_crypt,\n\t    ckey, iv, enc_len, &cuio, auth_len);\n\tif (ret != 0)\n\t\tgoto error;\n\tif (locked) {\n\t\trw_exit(&key->zk_salt_lock);\n\t}\n\n\tif (authbuf != NULL)\n\t\tzio_buf_free(authbuf, datalen);\n\tif (ckey == &tmp_ckey)\n\t\tmemset(enc_keydata, 0, keydata_len);\n\tzio_crypt_destroy_uio(&puio);\n\tzio_crypt_destroy_uio(&cuio);\n\n\treturn (0);\n\nerror:\n\tif (!encrypt) {\n\t\tif (failed_decrypt_buf != NULL)\n\t\t\tkmem_free(failed_decrypt_buf, failed_decrypt_size);\n\t\tfailed_decrypt_buf = kmem_alloc(datalen, KM_SLEEP);\n\t\tfailed_decrypt_size = datalen;\n\t\tmemcpy(failed_decrypt_buf, cipherbuf, datalen);\n\t}\n\tif (locked)\n\t\trw_exit(&key->zk_salt_lock);\n\tif (authbuf != NULL)\n\t\tzio_buf_free(authbuf, datalen);\n\tif (ckey == &tmp_ckey)\n\t\tmemset(enc_keydata, 0, keydata_len);\n\tzio_crypt_destroy_uio(&puio);\n\tzio_crypt_destroy_uio(&cuio);\n\treturn (SET_ERROR(ret));\n}\n\n \nint\nzio_do_crypt_abd(boolean_t encrypt, zio_crypt_key_t *key, dmu_object_type_t ot,\n    boolean_t byteswap, uint8_t *salt, uint8_t *iv, uint8_t *mac,\n    uint_t datalen, abd_t *pabd, abd_t *cabd, boolean_t *no_crypt)\n{\n\tint ret;\n\tvoid *ptmp, *ctmp;\n\n\tif (encrypt) {\n\t\tptmp = abd_borrow_buf_copy(pabd, datalen);\n\t\tctmp = abd_borrow_buf(cabd, datalen);\n\t} else {\n\t\tptmp = abd_borrow_buf(pabd, datalen);\n\t\tctmp = abd_borrow_buf_copy(cabd, datalen);\n\t}\n\n\tret = zio_do_crypt_data(encrypt, key, ot, byteswap, salt, iv, mac,\n\t    datalen, ptmp, ctmp, no_crypt);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tif (encrypt) {\n\t\tabd_return_buf(pabd, ptmp, datalen);\n\t\tabd_return_buf_copy(cabd, ctmp, datalen);\n\t} else {\n\t\tabd_return_buf_copy(pabd, ptmp, datalen);\n\t\tabd_return_buf(cabd, ctmp, datalen);\n\t}\n\n\treturn (0);\n\nerror:\n\tif (encrypt) {\n\t\tabd_return_buf(pabd, ptmp, datalen);\n\t\tabd_return_buf_copy(cabd, ctmp, datalen);\n\t} else {\n\t\tabd_return_buf_copy(pabd, ptmp, datalen);\n\t\tabd_return_buf(cabd, ctmp, datalen);\n\t}\n\n\treturn (SET_ERROR(ret));\n}\n\n#if defined(_KERNEL) && defined(HAVE_SPL)\n \nmodule_param(zfs_key_max_salt_uses, ulong, 0644);\nMODULE_PARM_DESC(zfs_key_max_salt_uses, \"Max number of times a salt value \"\n\t\"can be used for generating encryption keys before it is rotated\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}