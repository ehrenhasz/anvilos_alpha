{
  "module_name": "spa_os.c",
  "hash_id": "b4c0b3993000361c1d8cf6c32c96e87bfcef34b61e61b5e780aa658132c9dd8e",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/spa_os.c",
  "human_readable_source": " \n\n \n\n\n#include <sys/zfs_context.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/spa_impl.h>\n#include <sys/zio.h>\n#include <sys/zio_checksum.h>\n#include <sys/dmu.h>\n#include <sys/dmu_tx.h>\n#include <sys/zap.h>\n#include <sys/zil.h>\n#include <sys/ddt.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_os.h>\n#include <sys/vdev_removal.h>\n#include <sys/vdev_indirect_mapping.h>\n#include <sys/vdev_indirect_births.h>\n#include <sys/metaslab.h>\n#include <sys/metaslab_impl.h>\n#include <sys/uberblock_impl.h>\n#include <sys/txg.h>\n#include <sys/avl.h>\n#include <sys/bpobj.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dmu_objset.h>\n#include <sys/unique.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_synctask.h>\n#include <sys/fs/zfs.h>\n#include <sys/arc.h>\n#include <sys/callb.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/dsl_scan.h>\n#include <sys/dmu_send.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_userhold.h>\n#include <sys/zfeature.h>\n#include <sys/zvol.h>\n#include <sys/abd.h>\n#include <sys/callb.h>\n#include <sys/zone.h>\n\n#include \"zfs_prop.h\"\n#include \"zfs_comutil.h\"\n\nstatic nvlist_t *\nspa_generate_rootconf(const char *name)\n{\n\tnvlist_t **configs, **tops;\n\tnvlist_t *config;\n\tnvlist_t *best_cfg, *nvtop, *nvroot;\n\tuint64_t *holes;\n\tuint64_t best_txg;\n\tuint64_t nchildren;\n\tuint64_t pgid;\n\tuint64_t count;\n\tuint64_t i;\n\tuint_t   nholes;\n\n\tif (vdev_geom_read_pool_label(name, &configs, &count) != 0)\n\t\treturn (NULL);\n\n\tASSERT3U(count, !=, 0);\n\tbest_txg = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tuint64_t txg;\n\n\t\tif (configs[i] == NULL)\n\t\t\tcontinue;\n\t\ttxg = fnvlist_lookup_uint64(configs[i], ZPOOL_CONFIG_POOL_TXG);\n\t\tif (txg > best_txg) {\n\t\t\tbest_txg = txg;\n\t\t\tbest_cfg = configs[i];\n\t\t}\n\t}\n\n\tnchildren = 1;\n\tnvlist_lookup_uint64(best_cfg, ZPOOL_CONFIG_VDEV_CHILDREN, &nchildren);\n\tholes = NULL;\n\tnvlist_lookup_uint64_array(best_cfg, ZPOOL_CONFIG_HOLE_ARRAY,\n\t    &holes, &nholes);\n\n\ttops = kmem_zalloc(nchildren * sizeof (void *), KM_SLEEP);\n\tfor (i = 0; i < nchildren; i++) {\n\t\tif (i >= count)\n\t\t\tbreak;\n\t\tif (configs[i] == NULL)\n\t\t\tcontinue;\n\t\tnvtop = fnvlist_lookup_nvlist(configs[i],\n\t\t    ZPOOL_CONFIG_VDEV_TREE);\n\t\ttops[i] = fnvlist_dup(nvtop);\n\t}\n\tfor (i = 0; holes != NULL && i < nholes; i++) {\n\t\tif (i >= nchildren)\n\t\t\tcontinue;\n\t\tif (tops[holes[i]] != NULL)\n\t\t\tcontinue;\n\t\ttops[holes[i]] = fnvlist_alloc();\n\t\tfnvlist_add_string(tops[holes[i]], ZPOOL_CONFIG_TYPE,\n\t\t    VDEV_TYPE_HOLE);\n\t\tfnvlist_add_uint64(tops[holes[i]], ZPOOL_CONFIG_ID, holes[i]);\n\t\tfnvlist_add_uint64(tops[holes[i]], ZPOOL_CONFIG_GUID, 0);\n\t}\n\tfor (i = 0; i < nchildren; i++) {\n\t\tif (tops[i] != NULL)\n\t\t\tcontinue;\n\t\ttops[i] = fnvlist_alloc();\n\t\tfnvlist_add_string(tops[i], ZPOOL_CONFIG_TYPE,\n\t\t    VDEV_TYPE_MISSING);\n\t\tfnvlist_add_uint64(tops[i], ZPOOL_CONFIG_ID, i);\n\t\tfnvlist_add_uint64(tops[i], ZPOOL_CONFIG_GUID, 0);\n\t}\n\n\t \n\tconfig = fnvlist_dup(best_cfg);\n\n\t \n\tpgid = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID);\n\tnvroot = fnvlist_alloc();\n\tfnvlist_add_string(nvroot, ZPOOL_CONFIG_TYPE, VDEV_TYPE_ROOT);\n\tfnvlist_add_uint64(nvroot, ZPOOL_CONFIG_ID, 0ULL);\n\tfnvlist_add_uint64(nvroot, ZPOOL_CONFIG_GUID, pgid);\n\tfnvlist_add_nvlist_array(nvroot, ZPOOL_CONFIG_CHILDREN,\n\t    (const nvlist_t * const *)tops, nchildren);\n\n\t \n\tfnvlist_add_nvlist(config, ZPOOL_CONFIG_VDEV_TREE, nvroot);\n\n\t \n\tfnvlist_remove(config, ZPOOL_CONFIG_GUID);\n\tfnvlist_remove(config, ZPOOL_CONFIG_TOP_GUID);\n\n\tfor (i = 0; i < count; i++)\n\t\tfnvlist_free(configs[i]);\n\tkmem_free(configs, count * sizeof (void *));\n\tfor (i = 0; i < nchildren; i++)\n\t\tfnvlist_free(tops[i]);\n\tkmem_free(tops, nchildren * sizeof (void *));\n\tfnvlist_free(nvroot);\n\treturn (config);\n}\n\nint\nspa_import_rootpool(const char *name, bool checkpointrewind)\n{\n\tspa_t *spa;\n\tvdev_t *rvd;\n\tnvlist_t *config, *nvtop;\n\tconst char *pname;\n\tint error;\n\n\t \n\tconfig = spa_generate_rootconf(name);\n\n\tmutex_enter(&spa_namespace_lock);\n\tif (config != NULL) {\n\t\tpname = fnvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME);\n\t\tVERIFY0(strcmp(name, pname));\n\n\t\tif ((spa = spa_lookup(pname)) != NULL) {\n\t\t\t \n\t\t\tif (spa->spa_state == POOL_STATE_ACTIVE) {\n\t\t\t\tmutex_exit(&spa_namespace_lock);\n\t\t\t\tfnvlist_free(config);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t \n\t\t\tspa_remove(spa);\n\t\t}\n\t\tspa = spa_add(pname, config, NULL);\n\n\t\t \n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_VERSION,\n\t\t    &spa->spa_ubsync.ub_version) != 0)\n\t\t\tspa->spa_ubsync.ub_version = SPA_VERSION_INITIAL;\n\t} else if ((spa = spa_lookup(name)) == NULL) {\n\t\tmutex_exit(&spa_namespace_lock);\n\t\tfnvlist_free(config);\n\t\tcmn_err(CE_NOTE, \"Cannot find the pool label for '%s'\",\n\t\t    name);\n\t\treturn (EIO);\n\t} else {\n\t\tconfig = fnvlist_dup(spa->spa_config);\n\t}\n\tspa->spa_is_root = B_TRUE;\n\tspa->spa_import_flags = ZFS_IMPORT_VERBATIM;\n\tif (checkpointrewind) {\n\t\tspa->spa_import_flags |= ZFS_IMPORT_CHECKPOINT;\n\t}\n\n\t \n\tnvtop = fnvlist_lookup_nvlist(config, ZPOOL_CONFIG_VDEV_TREE);\n\tspa_config_enter(spa, SCL_ALL, FTAG, RW_WRITER);\n\terror = spa_config_parse(spa, &rvd, nvtop, NULL, 0,\n\t    VDEV_ALLOC_ROOTPOOL);\n\tspa_config_exit(spa, SCL_ALL, FTAG);\n\tif (error) {\n\t\tmutex_exit(&spa_namespace_lock);\n\t\tfnvlist_free(config);\n\t\tcmn_err(CE_NOTE, \"Can not parse the config for pool '%s'\",\n\t\t    name);\n\t\treturn (error);\n\t}\n\n\tspa_config_enter(spa, SCL_ALL, FTAG, RW_WRITER);\n\tvdev_free(rvd);\n\tspa_config_exit(spa, SCL_ALL, FTAG);\n\tmutex_exit(&spa_namespace_lock);\n\n\tfnvlist_free(config);\n\treturn (0);\n}\n\nconst char *\nspa_history_zone(void)\n{\n\treturn (\"freebsd\");\n}\n\nvoid\nspa_import_os(spa_t *spa)\n{\n\t(void) spa;\n}\n\nvoid\nspa_export_os(spa_t *spa)\n{\n\t(void) spa;\n}\n\nvoid\nspa_activate_os(spa_t *spa)\n{\n\t(void) spa;\n}\n\nvoid\nspa_deactivate_os(spa_t *spa)\n{\n\t(void) spa;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}