{
  "module_name": "vdev_file.c",
  "hash_id": "3b975630fd5e2f3acf4e2c53aa9581869ec84f828ad995da7794dfadd79f51db",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/vdev_file.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/spa.h>\n#include <sys/file.h>\n#include <sys/vdev_file.h>\n#include <sys/vdev_impl.h>\n#include <sys/zio.h>\n#include <sys/fs/zfs.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/abd.h>\n#include <sys/stat.h>\n\n \n\nstatic taskq_t *vdev_file_taskq;\n\nstatic uint_t vdev_file_logical_ashift = SPA_MINBLOCKSHIFT;\nstatic uint_t vdev_file_physical_ashift = SPA_MINBLOCKSHIFT;\n\nvoid\nvdev_file_init(void)\n{\n\tvdev_file_taskq = taskq_create(\"z_vdev_file\", MAX(max_ncpus, 16),\n\t    minclsyspri, max_ncpus, INT_MAX, 0);\n}\n\nvoid\nvdev_file_fini(void)\n{\n\ttaskq_destroy(vdev_file_taskq);\n}\n\nstatic void\nvdev_file_hold(vdev_t *vd)\n{\n\tASSERT3P(vd->vdev_path, !=, NULL);\n}\n\nstatic void\nvdev_file_rele(vdev_t *vd)\n{\n\tASSERT3P(vd->vdev_path, !=, NULL);\n}\n\nstatic mode_t\nvdev_file_open_mode(spa_mode_t spa_mode)\n{\n\tmode_t mode = 0;\n\n\tif ((spa_mode & SPA_MODE_READ) && (spa_mode & SPA_MODE_WRITE)) {\n\t\tmode = O_RDWR;\n\t} else if (spa_mode & SPA_MODE_READ) {\n\t\tmode = O_RDONLY;\n\t} else if (spa_mode & SPA_MODE_WRITE) {\n\t\tmode = O_WRONLY;\n\t}\n\n\treturn (mode | O_LARGEFILE);\n}\n\nstatic int\nvdev_file_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,\n    uint64_t *logical_ashift, uint64_t *physical_ashift)\n{\n\tvdev_file_t *vf;\n\tzfs_file_t *fp;\n\tzfs_file_attr_t zfa;\n\tint error;\n\n\t \n\tvd->vdev_nonrot = B_TRUE;\n\n\t \n\tvd->vdev_has_trim = B_TRUE;\n\n\t \n\tvd->vdev_has_securetrim = B_FALSE;\n\n\t \n\tif (vd->vdev_path == NULL || vd->vdev_path[0] != '/') {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_BAD_LABEL;\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (vd->vdev_tsd != NULL) {\n\t\tASSERT(vd->vdev_reopening);\n\t\tvf = vd->vdev_tsd;\n\t\tgoto skip_open;\n\t}\n\n\tvf = vd->vdev_tsd = kmem_zalloc(sizeof (vdev_file_t), KM_SLEEP);\n\n\t \n\tASSERT3P(vd->vdev_path, !=, NULL);\n\tASSERT(vd->vdev_path[0] == '/');\n\n\terror = zfs_file_open(vd->vdev_path,\n\t    vdev_file_open_mode(spa_mode(vd->vdev_spa)), 0, &fp);\n\tif (error) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_OPEN_FAILED;\n\t\treturn (error);\n\t}\n\n\tvf->vf_file = fp;\n\n#ifdef _KERNEL\n\t \n\tif (zfs_file_getattr(fp, &zfa)) {\n\t\treturn (SET_ERROR(ENODEV));\n\t}\n\tif (!S_ISREG(zfa.zfa_mode)) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_OPEN_FAILED;\n\t\treturn (SET_ERROR(ENODEV));\n\t}\n#endif\n\nskip_open:\n\n\terror =  zfs_file_getattr(vf->vf_file, &zfa);\n\tif (error) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_OPEN_FAILED;\n\t\treturn (error);\n\t}\n\n\t*max_psize = *psize = zfa.zfa_size;\n\t*logical_ashift = vdev_file_logical_ashift;\n\t*physical_ashift = vdev_file_physical_ashift;\n\n\treturn (0);\n}\n\nstatic void\nvdev_file_close(vdev_t *vd)\n{\n\tvdev_file_t *vf = vd->vdev_tsd;\n\n\tif (vd->vdev_reopening || vf == NULL)\n\t\treturn;\n\n\tif (vf->vf_file != NULL) {\n\t\tzfs_file_close(vf->vf_file);\n\t}\n\n\tvd->vdev_delayed_close = B_FALSE;\n\tkmem_free(vf, sizeof (vdev_file_t));\n\tvd->vdev_tsd = NULL;\n}\n\n \nstatic void\nvdev_file_io_intr(zio_t *zio)\n{\n\tzio_delay_interrupt(zio);\n}\n\nstatic void\nvdev_file_io_strategy(void *arg)\n{\n\tzio_t *zio = arg;\n\tvdev_t *vd = zio->io_vd;\n\tvdev_file_t *vf;\n\tvoid *buf;\n\tssize_t resid;\n\tloff_t off;\n\tssize_t size;\n\tint err;\n\n\toff = zio->io_offset;\n\tsize = zio->io_size;\n\tresid = 0;\n\n\tvf = vd->vdev_tsd;\n\n\tASSERT(zio->io_type == ZIO_TYPE_READ || zio->io_type == ZIO_TYPE_WRITE);\n\tif (zio->io_type == ZIO_TYPE_READ) {\n\t\tbuf = abd_borrow_buf(zio->io_abd, zio->io_size);\n\t\terr = zfs_file_pread(vf->vf_file, buf, size, off, &resid);\n\t\tabd_return_buf_copy(zio->io_abd, buf, size);\n\t} else {\n\t\tbuf = abd_borrow_buf_copy(zio->io_abd, zio->io_size);\n\t\terr = zfs_file_pwrite(vf->vf_file, buf, size, off, &resid);\n\t\tabd_return_buf(zio->io_abd, buf, size);\n\t}\n\tzio->io_error = err;\n\tif (resid != 0 && zio->io_error == 0)\n\t\tzio->io_error = ENOSPC;\n\n\tvdev_file_io_intr(zio);\n}\n\nstatic void\nvdev_file_io_start(zio_t *zio)\n{\n\tvdev_t *vd = zio->io_vd;\n\tvdev_file_t *vf = vd->vdev_tsd;\n\n\tif (zio->io_type == ZIO_TYPE_IOCTL) {\n\t\t \n\t\tif (!vdev_readable(vd)) {\n\t\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\t\tzio_interrupt(zio);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (zio->io_cmd) {\n\t\tcase DKIOCFLUSHWRITECACHE:\n\t\t\tzio->io_error = zfs_file_fsync(vf->vf_file,\n\t\t\t    O_SYNC|O_DSYNC);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzio->io_error = SET_ERROR(ENOTSUP);\n\t\t}\n\n\t\tzio_execute(zio);\n\t\treturn;\n\t} else if (zio->io_type == ZIO_TYPE_TRIM) {\n#ifdef notyet\n\t\tint mode = 0;\n\n\t\tASSERT3U(zio->io_size, !=, 0);\n\n\t\t \n\t\tzio->io_error = zfs_file_fallocate(vf->vf_file,\n\t\t    mode, zio->io_offset, zio->io_size);\n#endif\n\t\tzio->io_error = SET_ERROR(ENOTSUP);\n\t\tzio_execute(zio);\n\t\treturn;\n\t}\n\tASSERT(zio->io_type == ZIO_TYPE_READ || zio->io_type == ZIO_TYPE_WRITE);\n\tzio->io_target_timestamp = zio_handle_io_delay(zio);\n\n\tVERIFY3U(taskq_dispatch(vdev_file_taskq, vdev_file_io_strategy, zio,\n\t    TQ_SLEEP), !=, 0);\n}\n\nstatic void\nvdev_file_io_done(zio_t *zio)\n{\n\t(void) zio;\n}\n\nvdev_ops_t vdev_file_ops = {\n\t.vdev_op_init = NULL,\n\t.vdev_op_fini = NULL,\n\t.vdev_op_open = vdev_file_open,\n\t.vdev_op_close = vdev_file_close,\n\t.vdev_op_asize = vdev_default_asize,\n\t.vdev_op_min_asize = vdev_default_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = vdev_file_io_start,\n\t.vdev_op_io_done = vdev_file_io_done,\n\t.vdev_op_state_change = NULL,\n\t.vdev_op_need_resilver = NULL,\n\t.vdev_op_hold = vdev_file_hold,\n\t.vdev_op_rele = vdev_file_rele,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = vdev_default_xlate,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = NULL,\n\t.vdev_op_nparity = NULL,\n\t.vdev_op_ndisks = NULL,\n\t.vdev_op_type = VDEV_TYPE_FILE,\t\t \n\t.vdev_op_leaf = B_TRUE\t\t\t \n};\n\n \n#ifndef _KERNEL\n\nvdev_ops_t vdev_disk_ops = {\n\t.vdev_op_init = NULL,\n\t.vdev_op_fini = NULL,\n\t.vdev_op_open = vdev_file_open,\n\t.vdev_op_close = vdev_file_close,\n\t.vdev_op_asize = vdev_default_asize,\n\t.vdev_op_min_asize = vdev_default_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = vdev_file_io_start,\n\t.vdev_op_io_done = vdev_file_io_done,\n\t.vdev_op_state_change = NULL,\n\t.vdev_op_need_resilver = NULL,\n\t.vdev_op_hold = vdev_file_hold,\n\t.vdev_op_rele = vdev_file_rele,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = vdev_default_xlate,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = NULL,\n\t.vdev_op_nparity = NULL,\n\t.vdev_op_ndisks = NULL,\n\t.vdev_op_type = VDEV_TYPE_DISK,\t\t \n\t.vdev_op_leaf = B_TRUE\t\t\t \n};\n\n#endif\n\nZFS_MODULE_PARAM(zfs_vdev_file, vdev_file_, logical_ashift, UINT, ZMOD_RW,\n\t\"Logical ashift for file-based devices\");\nZFS_MODULE_PARAM(zfs_vdev_file, vdev_file_, physical_ashift, UINT, ZMOD_RW,\n\t\"Physical ashift for file-based devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}