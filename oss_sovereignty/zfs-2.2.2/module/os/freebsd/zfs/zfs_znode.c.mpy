{
  "module_name": "zfs_znode.c",
  "hash_id": "95862ce993a48f8d897b92eb918ad3cdf59500af6fb23e1a00abc8c0ac224eb9",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_znode.c",
  "human_readable_source": " \n \n\n \n \n\n#ifdef _KERNEL\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/systm.h>\n#include <sys/sysmacros.h>\n#include <sys/resource.h>\n#include <sys/resourcevar.h>\n#include <sys/mntent.h>\n#include <sys/u8_textprep.h>\n#include <sys/dsl_dataset.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/errno.h>\n#include <sys/unistd.h>\n#include <sys/atomic.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_rlock.h>\n#include <sys/zfs_fuid.h>\n#include <sys/dnode.h>\n#include <sys/fs/zfs.h>\n#endif  \n\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_tx.h>\n#include <sys/zfs_refcount.h>\n#include <sys/stat.h>\n#include <sys/zap.h>\n#include <sys/zfs_znode.h>\n#include <sys/sa.h>\n#include <sys/zfs_sa.h>\n#include <sys/zfs_stat.h>\n\n#include \"zfs_prop.h\"\n#include \"zfs_comutil.h\"\n\n \nSYSCTL_INT(_debug_sizeof, OID_AUTO, znode, CTLFLAG_RD,\n\tSYSCTL_NULL_INT_PTR, sizeof (znode_t), \"sizeof(znode_t)\");\n\n \n#ifdef\tZFS_DEBUG\n#define\tZNODE_STATS\n#endif\t \n\n#ifdef\tZNODE_STATS\n#define\tZNODE_STAT_ADD(stat)\t\t\t((stat)++)\n#else\n#define\tZNODE_STAT_ADD(stat)\t\t\t \n#endif\t \n\n \n#ifdef _KERNEL\n#if !defined(KMEM_DEBUG) && __FreeBSD_version >= 1300102\n#define\t_ZFS_USE_SMR\nstatic uma_zone_t znode_uma_zone;\n#else\nstatic kmem_cache_t *znode_cache = NULL;\n#endif\n\nextern struct vop_vector zfs_vnodeops;\nextern struct vop_vector zfs_fifoops;\nextern struct vop_vector zfs_shareops;\n\n\n \nstatic void\nzfs_rangelock_cb(zfs_locked_range_t *new, void *arg)\n{\n\tznode_t *zp = arg;\n\n\t \n\tif (new->lr_type == RL_APPEND) {\n\t\tnew->lr_offset = zp->z_size;\n\t\tnew->lr_type = RL_WRITER;\n\t}\n\n\t \n\tuint64_t end_size = MAX(zp->z_size, new->lr_offset + new->lr_length);\n\tif (end_size > zp->z_blksz && (!ISP2(zp->z_blksz) ||\n\t    zp->z_blksz < ZTOZSB(zp)->z_max_blksz)) {\n\t\tnew->lr_offset = 0;\n\t\tnew->lr_length = UINT64_MAX;\n\t}\n}\n\nstatic int\nzfs_znode_cache_constructor(void *buf, void *arg, int kmflags)\n{\n\tznode_t *zp = buf;\n\n\tPOINTER_INVALIDATE(&zp->z_zfsvfs);\n\n\tlist_link_init(&zp->z_link_node);\n\n\tmutex_init(&zp->z_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&zp->z_acl_lock, NULL, MUTEX_DEFAULT, NULL);\n\trw_init(&zp->z_xattr_lock, NULL, RW_DEFAULT, NULL);\n\n\tzfs_rangelock_init(&zp->z_rangelock, zfs_rangelock_cb, zp);\n\n\tzp->z_acl_cached = NULL;\n\tzp->z_xattr_cached = NULL;\n\tzp->z_xattr_parent = 0;\n\tzp->z_vnode = NULL;\n\tzp->z_sync_writes_cnt = 0;\n\tzp->z_async_writes_cnt = 0;\n\n\treturn (0);\n}\n\nstatic void\nzfs_znode_cache_destructor(void *buf, void *arg)\n{\n\t(void) arg;\n\tznode_t *zp = buf;\n\n\tASSERT(!POINTER_IS_VALID(zp->z_zfsvfs));\n\tASSERT3P(zp->z_vnode, ==, NULL);\n\tASSERT(!list_link_active(&zp->z_link_node));\n\tmutex_destroy(&zp->z_lock);\n\tmutex_destroy(&zp->z_acl_lock);\n\trw_destroy(&zp->z_xattr_lock);\n\tzfs_rangelock_fini(&zp->z_rangelock);\n\n\tASSERT3P(zp->z_acl_cached, ==, NULL);\n\tASSERT3P(zp->z_xattr_cached, ==, NULL);\n\n\tASSERT0(atomic_load_32(&zp->z_sync_writes_cnt));\n\tASSERT0(atomic_load_32(&zp->z_async_writes_cnt));\n}\n\n\n#ifdef _ZFS_USE_SMR\nVFS_SMR_DECLARE;\n\nstatic int\nzfs_znode_cache_constructor_smr(void *mem, int size __unused, void *private,\n    int flags)\n{\n\treturn (zfs_znode_cache_constructor(mem, private, flags));\n}\n\nstatic void\nzfs_znode_cache_destructor_smr(void *mem, int size __unused, void *private)\n{\n\tzfs_znode_cache_destructor(mem, private);\n}\n\nvoid\nzfs_znode_init(void)\n{\n\t \n\tASSERT3P(znode_uma_zone, ==, NULL);\n\tznode_uma_zone = uma_zcreate(\"zfs_znode_cache\",\n\t    sizeof (znode_t), zfs_znode_cache_constructor_smr,\n\t    zfs_znode_cache_destructor_smr, NULL, NULL, 0, 0);\n\tVFS_SMR_ZONE_SET(znode_uma_zone);\n}\n\nstatic znode_t *\nzfs_znode_alloc_kmem(int flags)\n{\n\treturn (uma_zalloc_smr(znode_uma_zone, flags));\n}\n\nstatic void\nzfs_znode_free_kmem(znode_t *zp)\n{\n\tif (zp->z_xattr_cached) {\n\t\tnvlist_free(zp->z_xattr_cached);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\tuma_zfree_smr(znode_uma_zone, zp);\n}\n#else\nvoid\nzfs_znode_init(void)\n{\n\t \n\tASSERT3P(znode_cache, ==, NULL);\n\tznode_cache = kmem_cache_create(\"zfs_znode_cache\",\n\t    sizeof (znode_t), 0, zfs_znode_cache_constructor,\n\t    zfs_znode_cache_destructor, NULL, NULL, NULL, 0);\n}\n\nstatic znode_t *\nzfs_znode_alloc_kmem(int flags)\n{\n\treturn (kmem_cache_alloc(znode_cache, flags));\n}\n\nstatic void\nzfs_znode_free_kmem(znode_t *zp)\n{\n\tif (zp->z_xattr_cached) {\n\t\tnvlist_free(zp->z_xattr_cached);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\tkmem_cache_free(znode_cache, zp);\n}\n#endif\n\nvoid\nzfs_znode_fini(void)\n{\n\t \n#ifdef _ZFS_USE_SMR\n\tif (znode_uma_zone) {\n\t\tuma_zdestroy(znode_uma_zone);\n\t\tznode_uma_zone = NULL;\n\t}\n#else\n\tif (znode_cache) {\n\t\tkmem_cache_destroy(znode_cache);\n\t\tznode_cache = NULL;\n\t}\n#endif\n}\n\n\nstatic int\nzfs_create_share_dir(zfsvfs_t *zfsvfs, dmu_tx_t *tx)\n{\n\tzfs_acl_ids_t acl_ids;\n\tvattr_t vattr;\n\tznode_t *sharezp;\n\tznode_t *zp;\n\tint error;\n\n\tvattr.va_mask = AT_MODE|AT_UID|AT_GID;\n\tvattr.va_type = VDIR;\n\tvattr.va_mode = S_IFDIR|0555;\n\tvattr.va_uid = crgetuid(kcred);\n\tvattr.va_gid = crgetgid(kcred);\n\n\tsharezp = zfs_znode_alloc_kmem(KM_SLEEP);\n\tASSERT(!POINTER_IS_VALID(sharezp->z_zfsvfs));\n\tsharezp->z_unlinked = 0;\n\tsharezp->z_atime_dirty = 0;\n\tsharezp->z_zfsvfs = zfsvfs;\n\tsharezp->z_is_sa = zfsvfs->z_use_sa;\n\n\tVERIFY0(zfs_acl_ids_create(sharezp, IS_ROOT_NODE, &vattr,\n\t    kcred, NULL, &acl_ids, NULL));\n\tzfs_mknode(sharezp, &vattr, tx, kcred, IS_ROOT_NODE, &zp, &acl_ids);\n\tASSERT3P(zp, ==, sharezp);\n\tPOINTER_INVALIDATE(&sharezp->z_zfsvfs);\n\terror = zap_add(zfsvfs->z_os, MASTER_NODE_OBJ,\n\t    ZFS_SHARES_DIR, 8, 1, &sharezp->z_id, tx);\n\tzfsvfs->z_shares_dir = sharezp->z_id;\n\n\tzfs_acl_ids_free(&acl_ids);\n\tsa_handle_destroy(sharezp->z_sa_hdl);\n\tzfs_znode_free_kmem(sharezp);\n\n\treturn (error);\n}\n\n \n#ifndef NBITSMINOR64\n#define\tNBITSMINOR64\t32\n#endif\n#ifndef MAXMAJ64\n#define\tMAXMAJ64\t0xffffffffUL\n#endif\n#ifndef\tMAXMIN64\n#define\tMAXMIN64\t0xffffffffUL\n#endif\n\n \nstatic uint64_t\nzfs_expldev(dev_t dev)\n{\n\treturn (((uint64_t)major(dev) << NBITSMINOR64) | minor(dev));\n}\n \ndev_t\nzfs_cmpldev(uint64_t dev)\n{\n\treturn (makedev((dev >> NBITSMINOR64), (dev & MAXMIN64)));\n}\n\nstatic void\nzfs_znode_sa_init(zfsvfs_t *zfsvfs, znode_t *zp,\n    dmu_buf_t *db, dmu_object_type_t obj_type, sa_handle_t *sa_hdl)\n{\n\tASSERT(!POINTER_IS_VALID(zp->z_zfsvfs) || (zfsvfs == zp->z_zfsvfs));\n\tASSERT(MUTEX_HELD(ZFS_OBJ_MUTEX(zfsvfs, zp->z_id)));\n\n\tASSERT3P(zp->z_sa_hdl, ==, NULL);\n\tASSERT3P(zp->z_acl_cached, ==, NULL);\n\tif (sa_hdl == NULL) {\n\t\tVERIFY0(sa_handle_get_from_db(zfsvfs->z_os, db, zp,\n\t\t    SA_HDL_SHARED, &zp->z_sa_hdl));\n\t} else {\n\t\tzp->z_sa_hdl = sa_hdl;\n\t\tsa_set_userp(sa_hdl, zp);\n\t}\n\n\tzp->z_is_sa = (obj_type == DMU_OT_SA) ? B_TRUE : B_FALSE;\n\n\t \n\tif (zp->z_id == zfsvfs->z_root && zfsvfs->z_parent == zfsvfs)\n\t\tZTOV(zp)->v_flag |= VROOT;\n\n\tvn_exists(ZTOV(zp));\n}\n\nvoid\nzfs_znode_dmu_fini(znode_t *zp)\n{\n\tASSERT(MUTEX_HELD(ZFS_OBJ_MUTEX(zp->z_zfsvfs, zp->z_id)) ||\n\t    ZFS_TEARDOWN_INACTIVE_WRITE_HELD(zp->z_zfsvfs));\n\n\tsa_handle_destroy(zp->z_sa_hdl);\n\tzp->z_sa_hdl = NULL;\n}\n\nstatic void\nzfs_vnode_forget(vnode_t *vp)\n{\n\n\t \n\tvp->v_data = NULL;\n\tvp->v_op = &dead_vnodeops;\n\tvgone(vp);\n\tvput(vp);\n}\n\n \nstatic znode_t *\nzfs_znode_alloc(zfsvfs_t *zfsvfs, dmu_buf_t *db, int blksz,\n    dmu_object_type_t obj_type, sa_handle_t *hdl)\n{\n\tznode_t\t*zp;\n\tvnode_t *vp;\n\tuint64_t mode;\n\tuint64_t parent;\n#ifdef notyet\n\tuint64_t mtime[2], ctime[2];\n#endif\n\tuint64_t projid = ZFS_DEFAULT_PROJID;\n\tsa_bulk_attr_t bulk[9];\n\tint count = 0;\n\tint error;\n\n\tzp = zfs_znode_alloc_kmem(KM_SLEEP);\n\n#ifndef _ZFS_USE_SMR\n\tKASSERT((zfsvfs->z_parent->z_vfs->mnt_kern_flag & MNTK_FPLOOKUP) == 0,\n\t    (\"%s: fast path lookup enabled without smr\", __func__));\n#endif\n\n#if __FreeBSD_version >= 1300076\n\tKASSERT(curthread->td_vp_reserved != NULL,\n\t    (\"zfs_znode_alloc: getnewvnode without any vnodes reserved\"));\n#else\n\tKASSERT(curthread->td_vp_reserv > 0,\n\t    (\"zfs_znode_alloc: getnewvnode without any vnodes reserved\"));\n#endif\n\terror = getnewvnode(\"zfs\", zfsvfs->z_parent->z_vfs, &zfs_vnodeops, &vp);\n\tif (error != 0) {\n\t\tzfs_znode_free_kmem(zp);\n\t\treturn (NULL);\n\t}\n\tzp->z_vnode = vp;\n\tvp->v_data = zp;\n\n\t \n\tvn_lock(vp, LK_EXCLUSIVE | LK_RETRY);\n\n\tASSERT(!POINTER_IS_VALID(zp->z_zfsvfs));\n\n\tzp->z_sa_hdl = NULL;\n\tzp->z_unlinked = 0;\n\tzp->z_atime_dirty = 0;\n\tzp->z_mapcnt = 0;\n\tzp->z_id = db->db_object;\n\tzp->z_blksz = blksz;\n\tzp->z_seq = 0x7A4653;\n\tzp->z_sync_cnt = 0;\n\tzp->z_sync_writes_cnt = 0;\n\tzp->z_async_writes_cnt = 0;\n#if __FreeBSD_version >= 1300139\n\tatomic_store_ptr(&zp->z_cached_symlink, NULL);\n#endif\n\n\tzfs_znode_sa_init(zfsvfs, zp, db, obj_type, hdl);\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL, &mode, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GEN(zfsvfs), NULL, &zp->z_gen, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL,\n\t    &zp->z_links, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PARENT(zfsvfs), NULL, &parent, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t    &zp->z_atime, 16);\n#ifdef notyet\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t    &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t    &ctime, 16);\n#endif\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t    &zp->z_uid, 8);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL,\n\t    &zp->z_gid, 8);\n\n\tif (sa_bulk_lookup(zp->z_sa_hdl, bulk, count) != 0 || zp->z_gen == 0 ||\n\t    (dmu_objset_projectquota_enabled(zfsvfs->z_os) &&\n\t    (zp->z_pflags & ZFS_PROJID) &&\n\t    sa_lookup(zp->z_sa_hdl, SA_ZPL_PROJID(zfsvfs), &projid, 8) != 0)) {\n\t\tif (hdl == NULL)\n\t\t\tsa_handle_destroy(zp->z_sa_hdl);\n\t\tzfs_vnode_forget(vp);\n\t\tzp->z_vnode = NULL;\n\t\tzfs_znode_free_kmem(zp);\n\t\treturn (NULL);\n\t}\n\n\tzp->z_projid = projid;\n\tzp->z_mode = mode;\n\n\t \n\tif (zp->z_pflags & ZFS_XATTR)\n\t\tzp->z_xattr_parent = parent;\n\n\tvp->v_type = IFTOVT((mode_t)mode);\n\n\tswitch (vp->v_type) {\n\tcase VDIR:\n\t\tzp->z_zn_prefetch = B_TRUE;  \n\t\tbreak;\n\tcase VFIFO:\n\t\tvp->v_op = &zfs_fifoops;\n\t\tbreak;\n\tcase VREG:\n\t\tif (parent == zfsvfs->z_shares_dir) {\n\t\t\tASSERT0(zp->z_uid);\n\t\t\tASSERT0(zp->z_gid);\n\t\t\tvp->v_op = &zfs_shareops;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tlist_insert_tail(&zfsvfs->z_all_znodes, zp);\n\tzp->z_zfsvfs = zfsvfs;\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n#if __FreeBSD_version >= 1400077\n\tvn_set_state(vp, VSTATE_CONSTRUCTED);\n#endif\n\tVN_LOCK_AREC(vp);\n\tif (vp->v_type != VFIFO)\n\t\tVN_LOCK_ASHARE(vp);\n\n\treturn (zp);\n}\n\nstatic uint64_t empty_xattr;\nstatic uint64_t pad[4];\nstatic zfs_acl_phys_t acl_phys;\n \nvoid\nzfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,\n    uint_t flag, znode_t **zpp, zfs_acl_ids_t *acl_ids)\n{\n\tuint64_t\tcrtime[2], atime[2], mtime[2], ctime[2];\n\tuint64_t\tmode, size, links, parent, pflags;\n\tuint64_t\tdzp_pflags = 0;\n\tuint64_t\trdev = 0;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tdmu_buf_t\t*db;\n\ttimestruc_t\tnow;\n\tuint64_t\tgen, obj;\n\tint\t\tbonuslen;\n\tint\t\tdnodesize;\n\tsa_handle_t\t*sa_hdl;\n\tdmu_object_type_t obj_type;\n\tsa_bulk_attr_t\t*sa_attrs;\n\tint\t\tcnt = 0;\n\tzfs_acl_locator_cb_t locate = { 0 };\n\n\tASSERT3P(vap, !=, NULL);\n\tASSERT3U((vap->va_mask & AT_MODE), ==, AT_MODE);\n\n\tif (zfsvfs->z_replay) {\n\t\tobj = vap->va_nodeid;\n\t\tnow = vap->va_ctime;\t\t \n\t\tgen = vap->va_nblocks;\t\t \n\t\tdnodesize = vap->va_fsid;\t \n\t} else {\n\t\tobj = 0;\n\t\tvfs_timestamp(&now);\n\t\tgen = dmu_tx_get_txg(tx);\n\t\tdnodesize = dmu_objset_dnodesize(zfsvfs->z_os);\n\t}\n\n\tif (dnodesize == 0)\n\t\tdnodesize = DNODE_MIN_SIZE;\n\n\tobj_type = zfsvfs->z_use_sa ? DMU_OT_SA : DMU_OT_ZNODE;\n\tbonuslen = (obj_type == DMU_OT_SA) ?\n\t    DN_BONUS_SIZE(dnodesize) : ZFS_OLD_ZNODE_PHYS_SIZE;\n\n\t \n\t \n\tif (vap->va_type == VDIR) {\n\t\tif (zfsvfs->z_replay) {\n\t\t\tVERIFY0(zap_create_claim_norm_dnsize(zfsvfs->z_os, obj,\n\t\t\t    zfsvfs->z_norm, DMU_OT_DIRECTORY_CONTENTS,\n\t\t\t    obj_type, bonuslen, dnodesize, tx));\n\t\t} else {\n\t\t\tobj = zap_create_norm_dnsize(zfsvfs->z_os,\n\t\t\t    zfsvfs->z_norm, DMU_OT_DIRECTORY_CONTENTS,\n\t\t\t    obj_type, bonuslen, dnodesize, tx);\n\t\t}\n\t} else {\n\t\tif (zfsvfs->z_replay) {\n\t\t\tVERIFY0(dmu_object_claim_dnsize(zfsvfs->z_os, obj,\n\t\t\t    DMU_OT_PLAIN_FILE_CONTENTS, 0,\n\t\t\t    obj_type, bonuslen, dnodesize, tx));\n\t\t} else {\n\t\t\tobj = dmu_object_alloc_dnsize(zfsvfs->z_os,\n\t\t\t    DMU_OT_PLAIN_FILE_CONTENTS, 0,\n\t\t\t    obj_type, bonuslen, dnodesize, tx);\n\t\t}\n\t}\n\n\tZFS_OBJ_HOLD_ENTER(zfsvfs, obj);\n\tVERIFY0(sa_buf_hold(zfsvfs->z_os, obj, NULL, &db));\n\n\t \n\tif (flag & IS_ROOT_NODE) {\n\t\tdzp->z_id = obj;\n\t} else {\n\t\tdzp_pflags = dzp->z_pflags;\n\t}\n\n\t \n\tif (dzp_pflags & ZFS_XATTR) {\n\t\tflag |= IS_XATTR;\n\t}\n\n\tif (zfsvfs->z_use_fuids)\n\t\tpflags = ZFS_ARCHIVE | ZFS_AV_MODIFIED;\n\telse\n\t\tpflags = 0;\n\n\tif (vap->va_type == VDIR) {\n\t\tsize = 2;\t\t \n\t\tlinks = (flag & (IS_ROOT_NODE | IS_XATTR)) ? 2 : 1;\n\t} else {\n\t\tsize = links = 0;\n\t}\n\n\tif (vap->va_type == VBLK || vap->va_type == VCHR) {\n\t\trdev = zfs_expldev(vap->va_rdev);\n\t}\n\n\tparent = dzp->z_id;\n\tmode = acl_ids->z_mode;\n\tif (flag & IS_XATTR)\n\t\tpflags |= ZFS_XATTR;\n\n\t \n\tpflags |= acl_ids->z_aclp->z_hints &\n\t    (ZFS_ACL_TRIVIAL|ZFS_INHERIT_ACE|ZFS_ACL_AUTO_INHERIT|\n\t    ZFS_ACL_DEFAULTED|ZFS_ACL_PROTECTED);\n\n\tZFS_TIME_ENCODE(&now, crtime);\n\tZFS_TIME_ENCODE(&now, ctime);\n\n\tif (vap->va_mask & AT_ATIME) {\n\t\tZFS_TIME_ENCODE(&vap->va_atime, atime);\n\t} else {\n\t\tZFS_TIME_ENCODE(&now, atime);\n\t}\n\n\tif (vap->va_mask & AT_MTIME) {\n\t\tZFS_TIME_ENCODE(&vap->va_mtime, mtime);\n\t} else {\n\t\tZFS_TIME_ENCODE(&now, mtime);\n\t}\n\n\t \n\tVERIFY0(sa_handle_get_from_db(zfsvfs->z_os, db, NULL, SA_HDL_SHARED,\n\t    &sa_hdl));\n\n\t \n\tsa_attrs = kmem_alloc(sizeof (sa_bulk_attr_t) * ZPL_END, KM_SLEEP);\n\n\tif (obj_type == DMU_OT_ZNODE) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ATIME(zfsvfs),\n\t\t    NULL, &atime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MTIME(zfsvfs),\n\t\t    NULL, &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CTIME(zfsvfs),\n\t\t    NULL, &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CRTIME(zfsvfs),\n\t\t    NULL, &crtime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GEN(zfsvfs),\n\t\t    NULL, &gen, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MODE(zfsvfs),\n\t\t    NULL, &mode, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_SIZE(zfsvfs),\n\t\t    NULL, &size, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PARENT(zfsvfs),\n\t\t    NULL, &parent, 8);\n\t} else {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MODE(zfsvfs),\n\t\t    NULL, &mode, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_SIZE(zfsvfs),\n\t\t    NULL, &size, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GEN(zfsvfs),\n\t\t    NULL, &gen, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_UID(zfsvfs),\n\t\t    NULL, &acl_ids->z_fuid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GID(zfsvfs),\n\t\t    NULL, &acl_ids->z_fgid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PARENT(zfsvfs),\n\t\t    NULL, &parent, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &pflags, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ATIME(zfsvfs),\n\t\t    NULL, &atime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_MTIME(zfsvfs),\n\t\t    NULL, &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CTIME(zfsvfs),\n\t\t    NULL, &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_CRTIME(zfsvfs),\n\t\t    NULL, &crtime, 16);\n\t}\n\n\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_LINKS(zfsvfs), NULL, &links, 8);\n\n\tif (obj_type == DMU_OT_ZNODE) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_XATTR(zfsvfs), NULL,\n\t\t    &empty_xattr, 8);\n\t}\n\tif (obj_type == DMU_OT_ZNODE ||\n\t    (vap->va_type == VBLK || vap->va_type == VCHR)) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_RDEV(zfsvfs),\n\t\t    NULL, &rdev, 8);\n\n\t}\n\tif (obj_type == DMU_OT_ZNODE) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &pflags, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_UID(zfsvfs), NULL,\n\t\t    &acl_ids->z_fuid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_GID(zfsvfs), NULL,\n\t\t    &acl_ids->z_fgid, 8);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_PAD(zfsvfs), NULL, pad,\n\t\t    sizeof (uint64_t) * 4);\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_ZNODE_ACL(zfsvfs), NULL,\n\t\t    &acl_phys, sizeof (zfs_acl_phys_t));\n\t} else if (acl_ids->z_aclp->z_version >= ZFS_ACL_VERSION_FUID) {\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_DACL_COUNT(zfsvfs), NULL,\n\t\t    &acl_ids->z_aclp->z_acl_count, 8);\n\t\tlocate.cb_aclp = acl_ids->z_aclp;\n\t\tSA_ADD_BULK_ATTR(sa_attrs, cnt, SA_ZPL_DACL_ACES(zfsvfs),\n\t\t    zfs_acl_data_locator, &locate,\n\t\t    acl_ids->z_aclp->z_acl_bytes);\n\t\tmode = zfs_mode_compute(mode, acl_ids->z_aclp, &pflags,\n\t\t    acl_ids->z_fuid, acl_ids->z_fgid);\n\t}\n\n\tVERIFY0(sa_replace_all_by_template(sa_hdl, sa_attrs, cnt, tx));\n\n\tif (!(flag & IS_ROOT_NODE)) {\n\t\t*zpp = zfs_znode_alloc(zfsvfs, db, 0, obj_type, sa_hdl);\n\t\tASSERT3P(*zpp, !=, NULL);\n\t} else {\n\t\t \n\t\t*zpp = dzp;\n\n\t\t(*zpp)->z_sa_hdl = sa_hdl;\n\t}\n\n\t(*zpp)->z_pflags = pflags;\n\t(*zpp)->z_mode = mode;\n\t(*zpp)->z_dnodesize = dnodesize;\n\n\tif (vap->va_mask & AT_XVATTR)\n\t\tzfs_xvattr_set(*zpp, (xvattr_t *)vap, tx);\n\n\tif (obj_type == DMU_OT_ZNODE ||\n\t    acl_ids->z_aclp->z_version < ZFS_ACL_VERSION_FUID) {\n\t\tVERIFY0(zfs_aclset_common(*zpp, acl_ids->z_aclp, cr, tx));\n\t}\n\tif (!(flag & IS_ROOT_NODE)) {\n\t\tvnode_t *vp = ZTOV(*zpp);\n\t\tvp->v_vflag |= VV_FORCEINSMQ;\n\t\tint err = insmntque(vp, zfsvfs->z_vfs);\n\t\tvp->v_vflag &= ~VV_FORCEINSMQ;\n\t\t(void) err;\n\t\tKASSERT(err == 0, (\"insmntque() failed: error %d\", err));\n\t}\n\tkmem_free(sa_attrs, sizeof (sa_bulk_attr_t) * ZPL_END);\n\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj);\n}\n\n \nvoid\nzfs_xvattr_set(znode_t *zp, xvattr_t *xvap, dmu_tx_t *tx)\n{\n\txoptattr_t *xoap;\n\n\txoap = xva_getxoptattr(xvap);\n\tASSERT3P(xoap, !=, NULL);\n\n\tif (zp->z_zfsvfs->z_replay == B_FALSE) {\n\t\tASSERT_VOP_IN_SEQC(ZTOV(zp));\n\t}\n\n\tif (XVA_ISSET_REQ(xvap, XAT_CREATETIME)) {\n\t\tuint64_t times[2];\n\t\tZFS_TIME_ENCODE(&xoap->xoa_createtime, times);\n\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_CRTIME(zp->z_zfsvfs),\n\t\t    &times, sizeof (times), tx);\n\t\tXVA_SET_RTN(xvap, XAT_CREATETIME);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_READONLY)) {\n\t\tZFS_ATTR_SET(zp, ZFS_READONLY, xoap->xoa_readonly,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_READONLY);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_HIDDEN)) {\n\t\tZFS_ATTR_SET(zp, ZFS_HIDDEN, xoap->xoa_hidden,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_HIDDEN);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_SYSTEM)) {\n\t\tZFS_ATTR_SET(zp, ZFS_SYSTEM, xoap->xoa_system,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_SYSTEM);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_ARCHIVE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_ARCHIVE, xoap->xoa_archive,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_ARCHIVE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_IMMUTABLE, xoap->xoa_immutable,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_IMMUTABLE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK)) {\n\t\tZFS_ATTR_SET(zp, ZFS_NOUNLINK, xoap->xoa_nounlink,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_NOUNLINK);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY)) {\n\t\tZFS_ATTR_SET(zp, ZFS_APPENDONLY, xoap->xoa_appendonly,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_APPENDONLY);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP)) {\n\t\tZFS_ATTR_SET(zp, ZFS_NODUMP, xoap->xoa_nodump,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_NODUMP);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_OPAQUE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_OPAQUE, xoap->xoa_opaque,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_OPAQUE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED)) {\n\t\tZFS_ATTR_SET(zp, ZFS_AV_QUARANTINED,\n\t\t    xoap->xoa_av_quarantined, zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_AV_QUARANTINED);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED)) {\n\t\tZFS_ATTR_SET(zp, ZFS_AV_MODIFIED, xoap->xoa_av_modified,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_AV_MODIFIED);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP)) {\n\t\tzfs_sa_set_scanstamp(zp, xvap, tx);\n\t\tXVA_SET_RTN(xvap, XAT_AV_SCANSTAMP);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_REPARSE, xoap->xoa_reparse,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_REPARSE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_OFFLINE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_OFFLINE, xoap->xoa_offline,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_OFFLINE);\n\t}\n\tif (XVA_ISSET_REQ(xvap, XAT_SPARSE)) {\n\t\tZFS_ATTR_SET(zp, ZFS_SPARSE, xoap->xoa_sparse,\n\t\t    zp->z_pflags, tx);\n\t\tXVA_SET_RTN(xvap, XAT_SPARSE);\n\t}\n}\n\nint\nzfs_zget(zfsvfs_t *zfsvfs, uint64_t obj_num, znode_t **zpp)\n{\n\tdmu_object_info_t doi;\n\tdmu_buf_t\t*db;\n\tznode_t\t\t*zp;\n\tvnode_t\t\t*vp;\n\tsa_handle_t\t*hdl;\n\tint locked;\n\tint err;\n\n\tgetnewvnode_reserve_();\nagain:\n\t*zpp = NULL;\n\tZFS_OBJ_HOLD_ENTER(zfsvfs, obj_num);\n\n\terr = sa_buf_hold(zfsvfs->z_os, obj_num, NULL, &db);\n\tif (err) {\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\tgetnewvnode_drop_reserve();\n\t\treturn (err);\n\t}\n\n\tdmu_object_info_from_db(db, &doi);\n\tif (doi.doi_bonus_type != DMU_OT_SA &&\n\t    (doi.doi_bonus_type != DMU_OT_ZNODE ||\n\t    (doi.doi_bonus_type == DMU_OT_ZNODE &&\n\t    doi.doi_bonus_size < sizeof (znode_phys_t)))) {\n\t\tsa_buf_rele(db, NULL);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\tgetnewvnode_drop_reserve();\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\thdl = dmu_buf_get_user(db);\n\tif (hdl != NULL) {\n\t\tzp = sa_get_userdata(hdl);\n\n\t\t \n\t\tASSERT3P(zp, !=, NULL);\n\t\tASSERT3U(zp->z_id, ==, obj_num);\n\t\tif (zp->z_unlinked) {\n\t\t\terr = SET_ERROR(ENOENT);\n\t\t} else {\n\t\t\tvp = ZTOV(zp);\n\t\t\t \n\t\t\tVN_HOLD(vp);\n\t\t\t*zpp = zp;\n\t\t\terr = 0;\n\t\t}\n\n\t\tsa_buf_rele(db, NULL);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\n\t\tif (err) {\n\t\t\tgetnewvnode_drop_reserve();\n\t\t\treturn (err);\n\t\t}\n\n\t\tlocked = VOP_ISLOCKED(vp);\n\t\tVI_LOCK(vp);\n\t\tif (VN_IS_DOOMED(vp) && locked != LK_EXCLUSIVE) {\n\t\t\t \n\t\t\tVI_UNLOCK(vp);\n\n\t\t\t \n\t\t\tVN_RELE(vp);\n\t\t\tgoto again;\n\t\t}\n\t\tVI_UNLOCK(vp);\n\t\tgetnewvnode_drop_reserve();\n\t\treturn (err);\n\t}\n\n\t \n\tzp = zfs_znode_alloc(zfsvfs, db, doi.doi_data_block_size,\n\t    doi.doi_bonus_type, NULL);\n\tif (zp == NULL) {\n\t\terr = SET_ERROR(ENOENT);\n\t} else {\n\t\t*zpp = zp;\n\t}\n\tif (err == 0) {\n\t\tvnode_t *vp = ZTOV(zp);\n\n\t\terr = insmntque(vp, zfsvfs->z_vfs);\n\t\tif (err == 0) {\n\t\t\tvp->v_hash = obj_num;\n\t\t\tVOP_UNLOCK1(vp);\n\t\t} else {\n\t\t\tzp->z_vnode = NULL;\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tzfs_znode_free(zp);\n\t\t\t*zpp = NULL;\n\t\t}\n\t}\n\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\tgetnewvnode_drop_reserve();\n\treturn (err);\n}\n\nint\nzfs_rezget(znode_t *zp)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tdmu_object_info_t doi;\n\tdmu_buf_t *db;\n\tvnode_t *vp;\n\tuint64_t obj_num = zp->z_id;\n\tuint64_t mode, size;\n\tsa_bulk_attr_t bulk[8];\n\tint err;\n\tint count = 0;\n\tuint64_t gen;\n\n\t \n\tvp = ZTOV(zp);\n#if __FreeBSD_version >= 1400042\n\tvn_pages_remove_valid(vp, 0, 0);\n#else\n\tvn_pages_remove(vp, 0, 0);\n#endif\n\n\tZFS_OBJ_HOLD_ENTER(zfsvfs, obj_num);\n\n\tmutex_enter(&zp->z_acl_lock);\n\tif (zp->z_acl_cached) {\n\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = NULL;\n\t}\n\tmutex_exit(&zp->z_acl_lock);\n\n\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\tif (zp->z_xattr_cached) {\n\t\tnvlist_free(zp->z_xattr_cached);\n\t\tzp->z_xattr_cached = NULL;\n\t}\n\trw_exit(&zp->z_xattr_lock);\n\n\tASSERT3P(zp->z_sa_hdl, ==, NULL);\n\terr = sa_buf_hold(zfsvfs->z_os, obj_num, NULL, &db);\n\tif (err) {\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\treturn (err);\n\t}\n\n\tdmu_object_info_from_db(db, &doi);\n\tif (doi.doi_bonus_type != DMU_OT_SA &&\n\t    (doi.doi_bonus_type != DMU_OT_ZNODE ||\n\t    (doi.doi_bonus_type == DMU_OT_ZNODE &&\n\t    doi.doi_bonus_size < sizeof (znode_phys_t)))) {\n\t\tsa_buf_rele(db, NULL);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tzfs_znode_sa_init(zfsvfs, zp, db, doi.doi_bonus_type, NULL);\n\tsize = zp->z_size;\n\n\t \n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GEN(zfsvfs), NULL,\n\t    &gen, sizeof (gen));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &zp->z_size, sizeof (zp->z_size));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL,\n\t    &zp->z_links, sizeof (zp->z_links));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t    &zp->z_atime, sizeof (zp->z_atime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t    &zp->z_uid, sizeof (zp->z_uid));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs), NULL,\n\t    &zp->z_gid, sizeof (zp->z_gid));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t    &mode, sizeof (mode));\n\n\tif (sa_bulk_lookup(zp->z_sa_hdl, bulk, count)) {\n\t\tzfs_znode_dmu_fini(zp);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\tzp->z_mode = mode;\n\n\tif (gen != zp->z_gen) {\n\t\tzfs_znode_dmu_fini(zp);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t \n\tif (vp->v_type != IFTOVT((mode_t)zp->z_mode)) {\n\t\tzfs_znode_dmu_fini(zp);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t \n\tzp->z_unlinked = (zp->z_links == 0);\n\tif (zp->z_unlinked) {\n\t\tzfs_znode_dmu_fini(zp);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\t\treturn (0);\n\t}\n\n\tzp->z_blksz = doi.doi_data_block_size;\n\tif (zp->z_size != size)\n\t\tvnode_pager_setsize(vp, zp->z_size);\n\n\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj_num);\n\n\treturn (0);\n}\n\nvoid\nzfs_znode_delete(znode_t *zp, dmu_tx_t *tx)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tobjset_t *os = zfsvfs->z_os;\n\tuint64_t obj = zp->z_id;\n\tuint64_t acl_obj = zfs_external_acl(zp);\n\n\tZFS_OBJ_HOLD_ENTER(zfsvfs, obj);\n\tif (acl_obj) {\n\t\tVERIFY(!zp->z_is_sa);\n\t\tVERIFY0(dmu_object_free(os, acl_obj, tx));\n\t}\n\tVERIFY0(dmu_object_free(os, obj, tx));\n\tzfs_znode_dmu_fini(zp);\n\tZFS_OBJ_HOLD_EXIT(zfsvfs, obj);\n\tzfs_znode_free(zp);\n}\n\nvoid\nzfs_zinactive(znode_t *zp)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tuint64_t z_id = zp->z_id;\n\n\tASSERT3P(zp->z_sa_hdl, !=, NULL);\n\n\t \n\tZFS_OBJ_HOLD_ENTER(zfsvfs, z_id);\n\n\t \n\tif (zp->z_unlinked) {\n\t\tASSERT(!zfsvfs->z_issnap);\n\t\tif ((zfsvfs->z_vfs->vfs_flag & VFS_RDONLY) == 0) {\n\t\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, z_id);\n\t\t\tzfs_rmnode(zp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tzfs_znode_dmu_fini(zp);\n\tZFS_OBJ_HOLD_EXIT(zfsvfs, z_id);\n\tzfs_znode_free(zp);\n}\n\nvoid\nzfs_znode_free(znode_t *zp)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n#if __FreeBSD_version >= 1300139\n\tchar *symlink;\n#endif\n\n\tASSERT3P(zp->z_sa_hdl, ==, NULL);\n\tzp->z_vnode = NULL;\n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tPOINTER_INVALIDATE(&zp->z_zfsvfs);\n\tlist_remove(&zfsvfs->z_all_znodes, zp);\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n#if __FreeBSD_version >= 1300139\n\tsymlink = atomic_load_ptr(&zp->z_cached_symlink);\n\tif (symlink != NULL) {\n\t\tatomic_store_rel_ptr((uintptr_t *)&zp->z_cached_symlink,\n\t\t    (uintptr_t)NULL);\n\t\tcache_symlink_free(symlink, strlen(symlink) + 1);\n\t}\n#endif\n\n\tif (zp->z_acl_cached) {\n\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = NULL;\n\t}\n\n\tzfs_znode_free_kmem(zp);\n}\n\nvoid\nzfs_tstamp_update_setup_ext(znode_t *zp, uint_t flag, uint64_t mtime[2],\n    uint64_t ctime[2], boolean_t have_tx)\n{\n\ttimestruc_t\tnow;\n\n\tvfs_timestamp(&now);\n\n\tif (have_tx) {\t \n\t\tzp->z_atime_dirty = 0;\n\t\tzp->z_seq++;\n\t} else {\n\t\tzp->z_atime_dirty = 1;\n\t}\n\n\tif (flag & AT_ATIME) {\n\t\tZFS_TIME_ENCODE(&now, zp->z_atime);\n\t}\n\n\tif (flag & AT_MTIME) {\n\t\tZFS_TIME_ENCODE(&now, mtime);\n\t\tif (zp->z_zfsvfs->z_use_fuids) {\n\t\t\tzp->z_pflags |= (ZFS_ARCHIVE |\n\t\t\t    ZFS_AV_MODIFIED);\n\t\t}\n\t}\n\n\tif (flag & AT_CTIME) {\n\t\tZFS_TIME_ENCODE(&now, ctime);\n\t\tif (zp->z_zfsvfs->z_use_fuids)\n\t\t\tzp->z_pflags |= ZFS_ARCHIVE;\n\t}\n}\n\n\nvoid\nzfs_tstamp_update_setup(znode_t *zp, uint_t flag, uint64_t mtime[2],\n    uint64_t ctime[2])\n{\n\tzfs_tstamp_update_setup_ext(zp, flag, mtime, ctime, B_TRUE);\n}\n \nvoid\nzfs_grow_blocksize(znode_t *zp, uint64_t size, dmu_tx_t *tx)\n{\n\tint\t\terror;\n\tu_longlong_t\tdummy;\n\n\tif (size <= zp->z_blksz)\n\t\treturn;\n\t \n\tif (zp->z_blksz && zp->z_size > zp->z_blksz)\n\t\treturn;\n\n\terror = dmu_object_set_blocksize(zp->z_zfsvfs->z_os, zp->z_id,\n\t    size, 0, tx);\n\n\tif (error == ENOTSUP)\n\t\treturn;\n\tASSERT0(error);\n\n\t \n\tdmu_object_size_from_db(sa_get_db(zp->z_sa_hdl), &zp->z_blksz, &dummy);\n}\n\n \nstatic int\nzfs_extend(znode_t *zp, uint64_t end)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tdmu_tx_t *tx;\n\tzfs_locked_range_t *lr;\n\tuint64_t newblksz;\n\tint error;\n\n\t \n\tlr = zfs_rangelock_enter(&zp->z_rangelock, 0, UINT64_MAX, RL_WRITER);\n\n\t \n\tif (end <= zp->z_size) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (0);\n\t}\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tif (end > zp->z_blksz &&\n\t    (!ISP2(zp->z_blksz) || zp->z_blksz < zfsvfs->z_max_blksz)) {\n\t\t \n\t\tif (zp->z_blksz > zp->z_zfsvfs->z_max_blksz) {\n\t\t\t \n\t\t\tASSERT(!ISP2(zp->z_blksz));\n\t\t\tnewblksz = MIN(end, 1 << highbit64(zp->z_blksz));\n\t\t} else {\n\t\t\tnewblksz = MIN(end, zp->z_zfsvfs->z_max_blksz);\n\t\t}\n\t\tdmu_tx_hold_write(tx, zp->z_id, 0, newblksz);\n\t} else {\n\t\tnewblksz = 0;\n\t}\n\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (error);\n\t}\n\n\tif (newblksz)\n\t\tzfs_grow_blocksize(zp, newblksz, tx);\n\n\tzp->z_size = end;\n\n\tVERIFY0(sa_update(zp->z_sa_hdl, SA_ZPL_SIZE(zp->z_zfsvfs),\n\t    &zp->z_size, sizeof (zp->z_size), tx));\n\n\tvnode_pager_setsize(ZTOV(zp), end);\n\n\tzfs_rangelock_exit(lr);\n\n\tdmu_tx_commit(tx);\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_free_range(znode_t *zp, uint64_t off, uint64_t len)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tzfs_locked_range_t *lr;\n\tint error;\n\n\t \n\tlr = zfs_rangelock_enter(&zp->z_rangelock, off, len, RL_WRITER);\n\n\t \n\tif (off >= zp->z_size) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (0);\n\t}\n\n\tif (off + len > zp->z_size)\n\t\tlen = zp->z_size - off;\n\n\terror = dmu_free_long_range(zfsvfs->z_os, zp->z_id, off, len);\n\n\tif (error == 0) {\n#if __FreeBSD_version >= 1400032\n\t\tvnode_pager_purge_range(ZTOV(zp), off, off + len);\n#else\n\t\t \n\t\tvnode_pager_setsize(ZTOV(zp), off);\n#endif\n\t}\n\n\tzfs_rangelock_exit(lr);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_trunc(znode_t *zp, uint64_t end)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tvnode_t *vp = ZTOV(zp);\n\tdmu_tx_t *tx;\n\tzfs_locked_range_t *lr;\n\tint error;\n\tsa_bulk_attr_t bulk[2];\n\tint count = 0;\n\n\t \n\tlr = zfs_rangelock_enter(&zp->z_rangelock, 0, UINT64_MAX, RL_WRITER);\n\n\t \n\tif (end >= zp->z_size) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (0);\n\t}\n\n\terror = dmu_free_long_range(zfsvfs->z_os, zp->z_id, end,\n\t    DMU_OBJECT_END);\n\tif (error) {\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (error);\n\t}\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tdmu_tx_mark_netfree(tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_rangelock_exit(lr);\n\t\treturn (error);\n\t}\n\n\tzp->z_size = end;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs),\n\t    NULL, &zp->z_size, sizeof (zp->z_size));\n\n\tif (end == 0) {\n\t\tzp->z_pflags &= ~ZFS_SPARSE;\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t\t    NULL, &zp->z_pflags, 8);\n\t}\n\tVERIFY0(sa_bulk_update(zp->z_sa_hdl, bulk, count, tx));\n\n\tdmu_tx_commit(tx);\n\n\t \n\tvnode_pager_setsize(vp, end);\n\n\tzfs_rangelock_exit(lr);\n\n\treturn (0);\n}\n\n \nint\nzfs_freesp(znode_t *zp, uint64_t off, uint64_t len, int flag, boolean_t log)\n{\n\tdmu_tx_t *tx;\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tzilog_t *zilog = zfsvfs->z_log;\n\tuint64_t mode;\n\tuint64_t mtime[2], ctime[2];\n\tsa_bulk_attr_t bulk[3];\n\tint count = 0;\n\tint error;\n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_MODE(zfsvfs), &mode,\n\t    sizeof (mode))) != 0)\n\t\treturn (error);\n\n\tif (off > zp->z_size) {\n\t\terror =  zfs_extend(zp, off+len);\n\t\tif (error == 0 && log)\n\t\t\tgoto log;\n\t\telse\n\t\t\treturn (error);\n\t}\n\n\tif (len == 0) {\n\t\terror = zfs_trunc(zp, off);\n\t} else {\n\t\tif ((error = zfs_free_range(zp, off, len)) == 0 &&\n\t\t    off + len > zp->z_size)\n\t\t\terror = zfs_extend(zp, off+len);\n\t}\n\tif (error || !log)\n\t\treturn (error);\nlog:\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (error);\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL, mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL, ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t    NULL, &zp->z_pflags, 8);\n\tzfs_tstamp_update_setup(zp, CONTENT_MODIFIED, mtime, ctime);\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\tASSERT0(error);\n\n\tzfs_log_truncate(zilog, tx, TX_TRUNCATE, zp, off, len);\n\n\tdmu_tx_commit(tx);\n\treturn (0);\n}\n\nvoid\nzfs_create_fs(objset_t *os, cred_t *cr, nvlist_t *zplprops, dmu_tx_t *tx)\n{\n\tuint64_t\tmoid, obj, sa_obj, version;\n\tuint64_t\tsense = ZFS_CASE_SENSITIVE;\n\tuint64_t\tnorm = 0;\n\tnvpair_t\t*elem;\n\tint\t\terror;\n\tint\t\ti;\n\tznode_t\t\t*rootzp = NULL;\n\tzfsvfs_t\t*zfsvfs;\n\tvattr_t\t\tvattr;\n\tznode_t\t\t*zp;\n\tzfs_acl_ids_t\tacl_ids;\n\n\t \n\t \n\tmoid = MASTER_NODE_OBJ;\n\terror = zap_create_claim(os, moid, DMU_OT_MASTER_NODE,\n\t    DMU_OT_NONE, 0, tx);\n\tASSERT0(error);\n\n\t \n\tversion = zfs_zpl_version_map(spa_version(dmu_objset_spa(os)));\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(zplprops, elem)) != NULL) {\n\t\t \n\t\tuint64_t val;\n\t\tconst char *name;\n\n\t\tASSERT3S(nvpair_type(elem), ==, DATA_TYPE_UINT64);\n\t\tval = fnvpair_value_uint64(elem);\n\t\tname = nvpair_name(elem);\n\t\tif (strcmp(name, zfs_prop_to_name(ZFS_PROP_VERSION)) == 0) {\n\t\t\tif (val < version)\n\t\t\t\tversion = val;\n\t\t} else {\n\t\t\terror = zap_update(os, moid, name, 8, 1, &val, tx);\n\t\t}\n\t\tASSERT0(error);\n\t\tif (strcmp(name, zfs_prop_to_name(ZFS_PROP_NORMALIZE)) == 0)\n\t\t\tnorm = val;\n\t\telse if (strcmp(name, zfs_prop_to_name(ZFS_PROP_CASE)) == 0)\n\t\t\tsense = val;\n\t}\n\tASSERT3U(version, !=, 0);\n\terror = zap_update(os, moid, ZPL_VERSION_STR, 8, 1, &version, tx);\n\tASSERT0(error);\n\n\t \n\n\tif (version >= ZPL_VERSION_SA) {\n\t\tsa_obj = zap_create(os, DMU_OT_SA_MASTER_NODE,\n\t\t    DMU_OT_NONE, 0, tx);\n\t\terror = zap_add(os, moid, ZFS_SA_ATTRS, 8, 1, &sa_obj, tx);\n\t\tASSERT0(error);\n\t} else {\n\t\tsa_obj = 0;\n\t}\n\t \n\tobj = zap_create(os, DMU_OT_UNLINKED_SET, DMU_OT_NONE, 0, tx);\n\n\terror = zap_add(os, moid, ZFS_UNLINKED_SET, 8, 1, &obj, tx);\n\tASSERT0(error);\n\n\t \n\tVATTR_NULL(&vattr);\n\tvattr.va_mask = AT_MODE|AT_UID|AT_GID;\n\tvattr.va_type = VDIR;\n\tvattr.va_mode = S_IFDIR|0755;\n\tvattr.va_uid = crgetuid(cr);\n\tvattr.va_gid = crgetgid(cr);\n\n\tzfsvfs = kmem_zalloc(sizeof (zfsvfs_t), KM_SLEEP);\n\n\trootzp = zfs_znode_alloc_kmem(KM_SLEEP);\n\tASSERT(!POINTER_IS_VALID(rootzp->z_zfsvfs));\n\trootzp->z_unlinked = 0;\n\trootzp->z_atime_dirty = 0;\n\trootzp->z_is_sa = USE_SA(version, os);\n\n\tzfsvfs->z_os = os;\n\tzfsvfs->z_parent = zfsvfs;\n\tzfsvfs->z_version = version;\n\tzfsvfs->z_use_fuids = USE_FUIDS(version, os);\n\tzfsvfs->z_use_sa = USE_SA(version, os);\n\tzfsvfs->z_norm = norm;\n\n\terror = sa_setup(os, sa_obj, zfs_attr_table, ZPL_END,\n\t    &zfsvfs->z_attr_table);\n\n\tASSERT0(error);\n\n\t \n\tif (sense == ZFS_CASE_INSENSITIVE || sense == ZFS_CASE_MIXED)\n\t\tzfsvfs->z_norm |= U8_TEXTPREP_TOUPPER;\n\n\tmutex_init(&zfsvfs->z_znodes_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&zfsvfs->z_all_znodes, sizeof (znode_t),\n\t    offsetof(znode_t, z_link_node));\n\n\tfor (i = 0; i != ZFS_OBJ_MTX_SZ; i++)\n\t\tmutex_init(&zfsvfs->z_hold_mtx[i], NULL, MUTEX_DEFAULT, NULL);\n\n\trootzp->z_zfsvfs = zfsvfs;\n\tVERIFY0(zfs_acl_ids_create(rootzp, IS_ROOT_NODE, &vattr,\n\t    cr, NULL, &acl_ids, NULL));\n\tzfs_mknode(rootzp, &vattr, tx, cr, IS_ROOT_NODE, &zp, &acl_ids);\n\tASSERT3P(zp, ==, rootzp);\n\terror = zap_add(os, moid, ZFS_ROOT_OBJ, 8, 1, &rootzp->z_id, tx);\n\tASSERT0(error);\n\tzfs_acl_ids_free(&acl_ids);\n\tPOINTER_INVALIDATE(&rootzp->z_zfsvfs);\n\n\tsa_handle_destroy(rootzp->z_sa_hdl);\n\tzfs_znode_free_kmem(rootzp);\n\n\t \n\n\terror = zfs_create_share_dir(zfsvfs, tx);\n\n\tASSERT0(error);\n\n\tfor (i = 0; i != ZFS_OBJ_MTX_SZ; i++)\n\t\tmutex_destroy(&zfsvfs->z_hold_mtx[i]);\n\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n}\n#endif  \n\nstatic int\nzfs_sa_setup(objset_t *osp, sa_attr_type_t **sa_table)\n{\n\tuint64_t sa_obj = 0;\n\tint error;\n\n\terror = zap_lookup(osp, MASTER_NODE_OBJ, ZFS_SA_ATTRS, 8, 1, &sa_obj);\n\tif (error != 0 && error != ENOENT)\n\t\treturn (error);\n\n\terror = sa_setup(osp, sa_obj, zfs_attr_table, ZPL_END, sa_table);\n\treturn (error);\n}\n\nstatic int\nzfs_grab_sa_handle(objset_t *osp, uint64_t obj, sa_handle_t **hdlp,\n    dmu_buf_t **db, const void *tag)\n{\n\tdmu_object_info_t doi;\n\tint error;\n\n\tif ((error = sa_buf_hold(osp, obj, tag, db)) != 0)\n\t\treturn (error);\n\n\tdmu_object_info_from_db(*db, &doi);\n\tif ((doi.doi_bonus_type != DMU_OT_SA &&\n\t    doi.doi_bonus_type != DMU_OT_ZNODE) ||\n\t    (doi.doi_bonus_type == DMU_OT_ZNODE &&\n\t    doi.doi_bonus_size < sizeof (znode_phys_t))) {\n\t\tsa_buf_rele(*db, tag);\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\n\terror = sa_handle_get(osp, obj, NULL, SA_HDL_PRIVATE, hdlp);\n\tif (error != 0) {\n\t\tsa_buf_rele(*db, tag);\n\t\treturn (error);\n\t}\n\n\treturn (0);\n}\n\nstatic void\nzfs_release_sa_handle(sa_handle_t *hdl, dmu_buf_t *db, const void *tag)\n{\n\tsa_handle_destroy(hdl);\n\tsa_buf_rele(db, tag);\n}\n\n \nstatic int\nzfs_obj_to_pobj(objset_t *osp, sa_handle_t *hdl, sa_attr_type_t *sa_table,\n    uint64_t *pobjp, int *is_xattrdir)\n{\n\tuint64_t parent;\n\tuint64_t pflags;\n\tuint64_t mode;\n\tuint64_t parent_mode;\n\tsa_bulk_attr_t bulk[3];\n\tsa_handle_t *sa_hdl;\n\tdmu_buf_t *sa_db;\n\tint count = 0;\n\tint error;\n\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_PARENT], NULL,\n\t    &parent, sizeof (parent));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_FLAGS], NULL,\n\t    &pflags, sizeof (pflags));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_MODE], NULL,\n\t    &mode, sizeof (mode));\n\n\tif ((error = sa_bulk_lookup(hdl, bulk, count)) != 0)\n\t\treturn (error);\n\n\t \n\terror = zfs_grab_sa_handle(osp, parent, &sa_hdl, &sa_db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = sa_lookup(sa_hdl, ZPL_MODE, &parent_mode, sizeof (parent_mode));\n\tzfs_release_sa_handle(sa_hdl, sa_db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\t*is_xattrdir = ((pflags & ZFS_XATTR) != 0) && S_ISDIR(mode);\n\n\t \n\tif (!*is_xattrdir && !S_ISDIR(parent_mode))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t*pobjp = parent;\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_obj_to_stats_impl(sa_handle_t *hdl, sa_attr_type_t *sa_table,\n    zfs_stat_t *sb)\n{\n\tsa_bulk_attr_t bulk[4];\n\tint count = 0;\n\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_MODE], NULL,\n\t    &sb->zs_mode, sizeof (sb->zs_mode));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_GEN], NULL,\n\t    &sb->zs_gen, sizeof (sb->zs_gen));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_LINKS], NULL,\n\t    &sb->zs_links, sizeof (sb->zs_links));\n\tSA_ADD_BULK_ATTR(bulk, count, sa_table[ZPL_CTIME], NULL,\n\t    &sb->zs_ctime, sizeof (sb->zs_ctime));\n\n\treturn (sa_bulk_lookup(hdl, bulk, count));\n}\n\nstatic int\nzfs_obj_to_path_impl(objset_t *osp, uint64_t obj, sa_handle_t *hdl,\n    sa_attr_type_t *sa_table, char *buf, int len)\n{\n\tsa_handle_t *sa_hdl;\n\tsa_handle_t *prevhdl = NULL;\n\tdmu_buf_t *prevdb = NULL;\n\tdmu_buf_t *sa_db = NULL;\n\tchar *path = buf + len - 1;\n\tint error;\n\n\t*path = '\\0';\n\tsa_hdl = hdl;\n\n\tuint64_t deleteq_obj;\n\tVERIFY0(zap_lookup(osp, MASTER_NODE_OBJ,\n\t    ZFS_UNLINKED_SET, sizeof (uint64_t), 1, &deleteq_obj));\n\terror = zap_lookup_int(osp, deleteq_obj, obj);\n\tif (error == 0) {\n\t\treturn (ESTALE);\n\t} else if (error != ENOENT) {\n\t\treturn (error);\n\t}\n\n\tfor (;;) {\n\t\tuint64_t pobj;\n\t\tchar component[MAXNAMELEN + 2];\n\t\tsize_t complen;\n\t\tint is_xattrdir;\n\n\t\tif (prevdb) {\n\t\t\tASSERT3P(prevhdl, !=, NULL);\n\t\t\tzfs_release_sa_handle(prevhdl, prevdb, FTAG);\n\t\t}\n\n\t\tif ((error = zfs_obj_to_pobj(osp, sa_hdl, sa_table, &pobj,\n\t\t    &is_xattrdir)) != 0)\n\t\t\tbreak;\n\n\t\tif (pobj == obj) {\n\t\t\tif (path[0] != '/')\n\t\t\t\t*--path = '/';\n\t\t\tbreak;\n\t\t}\n\n\t\tcomponent[0] = '/';\n\t\tif (is_xattrdir) {\n\t\t\t(void) sprintf(component + 1, \"<xattrdir>\");\n\t\t} else {\n\t\t\terror = zap_value_search(osp, pobj, obj,\n\t\t\t    ZFS_DIRENT_OBJ(-1ULL), component + 1);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcomplen = strlen(component);\n\t\tpath -= complen;\n\t\tASSERT3P(path, >=, buf);\n\t\tmemcpy(path, component, complen);\n\t\tobj = pobj;\n\n\t\tif (sa_hdl != hdl) {\n\t\t\tprevhdl = sa_hdl;\n\t\t\tprevdb = sa_db;\n\t\t}\n\t\terror = zfs_grab_sa_handle(osp, obj, &sa_hdl, &sa_db, FTAG);\n\t\tif (error != 0) {\n\t\t\tsa_hdl = prevhdl;\n\t\t\tsa_db = prevdb;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sa_hdl != NULL && sa_hdl != hdl) {\n\t\tASSERT3P(sa_db, !=, NULL);\n\t\tzfs_release_sa_handle(sa_hdl, sa_db, FTAG);\n\t}\n\n\tif (error == 0)\n\t\t(void) memmove(buf, path, buf + len - path);\n\n\treturn (error);\n}\n\nint\nzfs_obj_to_path(objset_t *osp, uint64_t obj, char *buf, int len)\n{\n\tsa_attr_type_t *sa_table;\n\tsa_handle_t *hdl;\n\tdmu_buf_t *db;\n\tint error;\n\n\terror = zfs_sa_setup(osp, &sa_table);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_grab_sa_handle(osp, obj, &hdl, &db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_obj_to_path_impl(osp, obj, hdl, sa_table, buf, len);\n\n\tzfs_release_sa_handle(hdl, db, FTAG);\n\treturn (error);\n}\n\nint\nzfs_obj_to_stats(objset_t *osp, uint64_t obj, zfs_stat_t *sb,\n    char *buf, int len)\n{\n\tchar *path = buf + len - 1;\n\tsa_attr_type_t *sa_table;\n\tsa_handle_t *hdl;\n\tdmu_buf_t *db;\n\tint error;\n\n\t*path = '\\0';\n\n\terror = zfs_sa_setup(osp, &sa_table);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_grab_sa_handle(osp, obj, &hdl, &db, FTAG);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zfs_obj_to_stats_impl(hdl, sa_table, sb);\n\tif (error != 0) {\n\t\tzfs_release_sa_handle(hdl, db, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = zfs_obj_to_path_impl(osp, obj, hdl, sa_table, buf, len);\n\n\tzfs_release_sa_handle(hdl, db, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_get_zplprop(objset_t *os, zfs_prop_t prop, uint64_t *value)\n{\n\tuint64_t *cached_copy = NULL;\n\n\t \n\tif (os != NULL) {\n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_VERSION:\n\t\t\tcached_copy = &os->os_version;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_NORMALIZE:\n\t\t\tcached_copy = &os->os_normalization;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_UTF8ONLY:\n\t\t\tcached_copy = &os->os_utf8only;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_CASE:\n\t\t\tcached_copy = &os->os_casesensitivity;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cached_copy != NULL && *cached_copy != OBJSET_PROP_UNINITIALIZED) {\n\t\t*value = *cached_copy;\n\t\treturn (0);\n\t}\n\n\t \n\tconst char *pname;\n\tint error = ENOENT;\n\tif (prop == ZFS_PROP_VERSION) {\n\t\tpname = ZPL_VERSION_STR;\n\t} else {\n\t\tpname = zfs_prop_to_name(prop);\n\t}\n\n\tif (os != NULL) {\n\t\tASSERT3U(os->os_phys->os_type, ==, DMU_OST_ZFS);\n\t\terror = zap_lookup(os, MASTER_NODE_OBJ, pname, 8, 1, value);\n\t}\n\n\tif (error == ENOENT) {\n\t\t \n\t\tswitch (prop) {\n\t\tcase ZFS_PROP_VERSION:\n\t\t\t*value = ZPL_VERSION;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_NORMALIZE:\n\t\tcase ZFS_PROP_UTF8ONLY:\n\t\t\t*value = 0;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_CASE:\n\t\t\t*value = ZFS_CASE_SENSITIVE;\n\t\t\tbreak;\n\t\tcase ZFS_PROP_ACLTYPE:\n\t\t\t*value = ZFS_ACLTYPE_NFSV4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (error);\n\t\t}\n\t\terror = 0;\n\t}\n\n\t \n\tif (error == 0 && cached_copy != NULL) {\n\t\t*cached_copy = *value;\n\t}\n\n\treturn (error);\n}\n\n\n\nvoid\nzfs_znode_update_vfs(znode_t *zp)\n{\n\tvm_object_t object;\n\n\tif ((object = ZTOV(zp)->v_object) == NULL ||\n\t    zp->z_size == object->un_pager.vnp.vnp_size)\n\t\treturn;\n\n\tvnode_pager_setsize(ZTOV(zp), zp->z_size);\n}\n\n\n#ifdef _KERNEL\nint\nzfs_znode_parent_and_name(znode_t *zp, znode_t **dzpp, char *buf)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tuint64_t parent;\n\tint is_xattrdir;\n\tint err;\n\n\t \n\tif ((zp->z_pflags & ZFS_XATTR) != 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terr = zfs_obj_to_pobj(zfsvfs->z_os, zp->z_sa_hdl, zfsvfs->z_attr_table,\n\t    &parent, &is_xattrdir);\n\tif (err != 0)\n\t\treturn (err);\n\tASSERT0(is_xattrdir);\n\n\t \n\tif (parent == zp->z_id)\n\t\treturn (SET_ERROR(EINVAL));\n\n\terr = zap_value_search(zfsvfs->z_os, parent, zp->z_id,\n\t    ZFS_DIRENT_OBJ(-1ULL), buf);\n\tif (err != 0)\n\t\treturn (err);\n\terr = zfs_zget(zfsvfs, parent, dzpp);\n\treturn (err);\n}\n#endif  \n\n#ifdef _KERNEL\nint\nzfs_rlimit_fsize(off_t fsize)\n{\n\tstruct thread *td = curthread;\n\toff_t lim;\n\n\tif (td == NULL)\n\t\treturn (0);\n\n\tlim = lim_cur(td, RLIMIT_FSIZE);\n\tif (__predict_true((uoff_t)fsize <= lim))\n\t\treturn (0);\n\n\t \n\tPROC_LOCK(td->td_proc);\n\tkern_psignal(td->td_proc, SIGXFSZ);\n\tPROC_UNLOCK(td->td_proc);\n\n\treturn (EFBIG);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}