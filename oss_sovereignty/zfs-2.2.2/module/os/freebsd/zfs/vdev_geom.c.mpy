{
  "module_name": "vdev_geom.c",
  "hash_id": "d8a7c802629cfd2d8f6e9b38b77d35107cc676ae67eea39cfe8edcf5b3fc1b91",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/vdev_geom.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/bio.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_os.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio.h>\n#include <vm/vm_page.h>\n#include <geom/geom.h>\n#include <geom/geom_disk.h>\n#include <geom/geom_int.h>\n\n#ifndef g_topology_locked\n#define\tg_topology_locked()\tsx_xlocked(&topology_lock)\n#endif\n\n \n\nstatic g_attrchanged_t vdev_geom_attrchanged;\nstruct g_class zfs_vdev_class = {\n\t.name = \"ZFS::VDEV\",\n\t.version = G_VERSION,\n\t.attrchanged = vdev_geom_attrchanged,\n};\n\nstruct consumer_vdev_elem {\n\tSLIST_ENTRY(consumer_vdev_elem)\telems;\n\tvdev_t\t*vd;\n};\n\nSLIST_HEAD(consumer_priv_t, consumer_vdev_elem);\n_Static_assert(\n    sizeof (((struct g_consumer *)NULL)->private) ==\n    sizeof (struct consumer_priv_t *),\n\t\"consumer_priv_t* can't be stored in g_consumer.private\");\n\nDECLARE_GEOM_CLASS(zfs_vdev_class, zfs_vdev);\n\nSYSCTL_DECL(_vfs_zfs_vdev);\n \nstatic int vdev_geom_bio_flush_disable;\nSYSCTL_INT(_vfs_zfs_vdev, OID_AUTO, bio_flush_disable, CTLFLAG_RWTUN,\n\t&vdev_geom_bio_flush_disable, 0, \"Disable BIO_FLUSH\");\n \nstatic int vdev_geom_bio_delete_disable;\nSYSCTL_INT(_vfs_zfs_vdev, OID_AUTO, bio_delete_disable, CTLFLAG_RWTUN,\n\t&vdev_geom_bio_delete_disable, 0, \"Disable BIO_DELETE\");\n\n \nstatic void vdev_geom_detach(struct g_consumer *cp, boolean_t open_for_read);\n\n \nuint_t zfs_geom_probe_vdev_key;\n\nstatic void\nvdev_geom_set_physpath(vdev_t *vd, struct g_consumer *cp,\n    boolean_t do_null_update)\n{\n\tboolean_t needs_update = B_FALSE;\n\tchar *physpath;\n\tint error, physpath_len;\n\n\tphyspath_len = MAXPATHLEN;\n\tphyspath = g_malloc(physpath_len, M_WAITOK|M_ZERO);\n\terror = g_io_getattr(\"GEOM::physpath\", cp, &physpath_len, physpath);\n\tif (error == 0) {\n\t\tchar *old_physpath;\n\n\t\t \n\t\tg_topology_assert();\n\t\told_physpath = vd->vdev_physpath;\n\t\tvd->vdev_physpath = spa_strdup(physpath);\n\n\t\tif (old_physpath != NULL) {\n\t\t\tneeds_update = (strcmp(old_physpath,\n\t\t\t    vd->vdev_physpath) != 0);\n\t\t\tspa_strfree(old_physpath);\n\t\t} else\n\t\t\tneeds_update = do_null_update;\n\t}\n\tg_free(physpath);\n\n\t \n\tif (needs_update)\n\t\tspa_async_request(vd->vdev_spa, SPA_ASYNC_CONFIG_UPDATE);\n\n}\n\nstatic void\nvdev_geom_attrchanged(struct g_consumer *cp, const char *attr)\n{\n\tstruct consumer_priv_t *priv;\n\tstruct consumer_vdev_elem *elem;\n\n\tpriv = (struct consumer_priv_t *)&cp->private;\n\tif (SLIST_EMPTY(priv))\n\t\treturn;\n\n\tSLIST_FOREACH(elem, priv, elems) {\n\t\tvdev_t *vd = elem->vd;\n\t\tif (strcmp(attr, \"GEOM::physpath\") == 0) {\n\t\t\tvdev_geom_set_physpath(vd, cp,  B_TRUE);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\nvdev_geom_resize(struct g_consumer *cp)\n{\n\tstruct consumer_priv_t *priv;\n\tstruct consumer_vdev_elem *elem;\n\tspa_t *spa;\n\tvdev_t *vd;\n\n\tpriv = (struct consumer_priv_t *)&cp->private;\n\tif (SLIST_EMPTY(priv))\n\t\treturn;\n\n\tSLIST_FOREACH(elem, priv, elems) {\n\t\tvd = elem->vd;\n\t\tif (vd->vdev_state != VDEV_STATE_HEALTHY)\n\t\t\tcontinue;\n\t\tspa = vd->vdev_spa;\n\t\tif (!spa->spa_autoexpand)\n\t\t\tcontinue;\n\t\tvdev_online(spa, vd->vdev_guid, ZFS_ONLINE_EXPAND, NULL);\n\t}\n}\n\nstatic void\nvdev_geom_orphan(struct g_consumer *cp)\n{\n\tstruct consumer_priv_t *priv;\n\t\n\tstruct consumer_vdev_elem *elem;\n\n\tg_topology_assert();\n\n\tpriv = (struct consumer_priv_t *)&cp->private;\n\tif (SLIST_EMPTY(priv))\n\t\t \n\t\treturn;\n\n\t \n\tSLIST_FOREACH(elem, priv, elems) {\n\t\t\n\t\tvdev_t *vd = elem->vd;\n\n\t\tvd->vdev_remove_wanted = B_TRUE;\n\t\tspa_async_request(vd->vdev_spa, SPA_ASYNC_REMOVE);\n\t}\n}\n\nstatic struct g_consumer *\nvdev_geom_attach(struct g_provider *pp, vdev_t *vd, boolean_t sanity)\n{\n\tstruct g_geom *gp;\n\tstruct g_consumer *cp;\n\tint error;\n\n\tg_topology_assert();\n\n\tZFS_LOG(1, \"Attaching to %s.\", pp->name);\n\n\tif (sanity) {\n\t\tif (pp->sectorsize > VDEV_PAD_SIZE || !ISP2(pp->sectorsize)) {\n\t\t\tZFS_LOG(1, \"Failing attach of %s. \"\n\t\t\t    \"Incompatible sectorsize %d\\n\",\n\t\t\t    pp->name, pp->sectorsize);\n\t\t\treturn (NULL);\n\t\t} else if (pp->mediasize < SPA_MINDEVSIZE) {\n\t\t\tZFS_LOG(1, \"Failing attach of %s. \"\n\t\t\t    \"Incompatible mediasize %ju\\n\",\n\t\t\t    pp->name, pp->mediasize);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t \n\tLIST_FOREACH(gp, &zfs_vdev_class.geom, geom) {\n\t\tif (gp->flags & G_GEOM_WITHER)\n\t\t\tcontinue;\n\t\tif (strcmp(gp->name, \"zfs::vdev\") != 0)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (gp == NULL) {\n\t\tgp = g_new_geomf(&zfs_vdev_class, \"zfs::vdev\");\n\t\tgp->orphan = vdev_geom_orphan;\n\t\tgp->attrchanged = vdev_geom_attrchanged;\n\t\tgp->resize = vdev_geom_resize;\n\t\tcp = g_new_consumer(gp);\n\t\terror = g_attach(cp, pp);\n\t\tif (error != 0) {\n\t\t\tZFS_LOG(1, \"%s(%d): g_attach failed: %d\\n\", __func__,\n\t\t\t    __LINE__, error);\n\t\t\tvdev_geom_detach(cp, B_FALSE);\n\t\t\treturn (NULL);\n\t\t}\n\t\terror = g_access(cp, 1, 0, 1);\n\t\tif (error != 0) {\n\t\t\tZFS_LOG(1, \"%s(%d): g_access failed: %d\\n\", __func__,\n\t\t\t    __LINE__, error);\n\t\t\tvdev_geom_detach(cp, B_FALSE);\n\t\t\treturn (NULL);\n\t\t}\n\t\tZFS_LOG(1, \"Created geom and consumer for %s.\", pp->name);\n\t} else {\n\t\t \n\t\tLIST_FOREACH(cp, &gp->consumer, consumer) {\n\t\t\tif (cp->provider == pp) {\n\t\t\t\tZFS_LOG(1, \"Found consumer for %s.\", pp->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (cp == NULL) {\n\t\t\tcp = g_new_consumer(gp);\n\t\t\terror = g_attach(cp, pp);\n\t\t\tif (error != 0) {\n\t\t\t\tZFS_LOG(1, \"%s(%d): g_attach failed: %d\\n\",\n\t\t\t\t    __func__, __LINE__, error);\n\t\t\t\tvdev_geom_detach(cp, B_FALSE);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\terror = g_access(cp, 1, 0, 1);\n\t\t\tif (error != 0) {\n\t\t\t\tZFS_LOG(1, \"%s(%d): g_access failed: %d\\n\",\n\t\t\t\t    __func__, __LINE__, error);\n\t\t\t\tvdev_geom_detach(cp, B_FALSE);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tZFS_LOG(1, \"Created consumer for %s.\", pp->name);\n\t\t} else {\n\t\t\terror = g_access(cp, 1, 0, 1);\n\t\t\tif (error != 0) {\n\t\t\t\tZFS_LOG(1, \"%s(%d): g_access failed: %d\\n\",\n\t\t\t\t    __func__, __LINE__, error);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tZFS_LOG(1, \"Used existing consumer for %s.\", pp->name);\n\t\t}\n\t}\n\n\tif (vd != NULL)\n\t\tvd->vdev_tsd = cp;\n\n\tcp->flags |= G_CF_DIRECT_SEND | G_CF_DIRECT_RECEIVE;\n\treturn (cp);\n}\n\nstatic void\nvdev_geom_detach(struct g_consumer *cp, boolean_t open_for_read)\n{\n\tstruct g_geom *gp;\n\n\tg_topology_assert();\n\n\tZFS_LOG(1, \"Detaching from %s.\",\n\t    cp->provider && cp->provider->name ? cp->provider->name : \"NULL\");\n\n\tgp = cp->geom;\n\tif (open_for_read)\n\t\tg_access(cp, -1, 0, -1);\n\t \n\tif (cp->acr == 0 && cp->ace == 0) {\n\t\tif (cp->acw > 0)\n\t\t\tg_access(cp, 0, -cp->acw, 0);\n\t\tif (cp->provider != NULL) {\n\t\t\tZFS_LOG(1, \"Destroying consumer for %s.\",\n\t\t\t    cp->provider->name ? cp->provider->name : \"NULL\");\n\t\t\tg_detach(cp);\n\t\t}\n\t\tg_destroy_consumer(cp);\n\t}\n\t \n\tif (LIST_EMPTY(&gp->consumer)) {\n\t\tZFS_LOG(1, \"Destroyed geom %s.\", gp->name);\n\t\tg_wither_geom(gp, ENXIO);\n\t}\n}\n\nstatic void\nvdev_geom_close_locked(vdev_t *vd)\n{\n\tstruct g_consumer *cp;\n\tstruct consumer_priv_t *priv;\n\tstruct consumer_vdev_elem *elem, *elem_temp;\n\n\tg_topology_assert();\n\n\tcp = vd->vdev_tsd;\n\tvd->vdev_delayed_close = B_FALSE;\n\tif (cp == NULL)\n\t\treturn;\n\n\tZFS_LOG(1, \"Closing access to %s.\", cp->provider->name);\n\tKASSERT(cp->private != NULL, (\"%s: cp->private is NULL\", __func__));\n\tpriv = (struct consumer_priv_t *)&cp->private;\n\tvd->vdev_tsd = NULL;\n\tSLIST_FOREACH_SAFE(elem, priv, elems, elem_temp) {\n\t\tif (elem->vd == vd) {\n\t\t\tSLIST_REMOVE(priv, elem, consumer_vdev_elem, elems);\n\t\t\tg_free(elem);\n\t\t}\n\t}\n\n\tvdev_geom_detach(cp, B_TRUE);\n}\n\n \nstatic void\nvdev_geom_io(struct g_consumer *cp, int *cmds, void **datas, off_t *offsets,\n    off_t *sizes, int *errors, int ncmds)\n{\n\tstruct bio **bios;\n\tuint8_t *p;\n\toff_t off, maxio, s, end;\n\tint i, n_bios, j;\n\tsize_t bios_size;\n\n#if __FreeBSD_version > 1300130\n\tmaxio = maxphys - (maxphys % cp->provider->sectorsize);\n#else\n\tmaxio = MAXPHYS - (MAXPHYS % cp->provider->sectorsize);\n#endif\n\tn_bios = 0;\n\n\t \n\tfor (i = 0; i < ncmds; i++)\n\t\tn_bios += (sizes[i] + maxio - 1) / maxio;\n\n\t \n\tbios_size = n_bios * sizeof (struct bio *);\n\tbios = kmem_zalloc(bios_size, KM_SLEEP);\n\n\t \n\tfor (i = j = 0; i < ncmds; i++) {\n\t\toff = offsets[i];\n\t\tp = datas[i];\n\t\ts = sizes[i];\n\t\tend = off + s;\n\t\tASSERT0(off % cp->provider->sectorsize);\n\t\tASSERT0(s % cp->provider->sectorsize);\n\n\t\tfor (; off < end; off += maxio, p += maxio, s -= maxio, j++) {\n\t\t\tbios[j] = g_alloc_bio();\n\t\t\tbios[j]->bio_cmd = cmds[i];\n\t\t\tbios[j]->bio_done = NULL;\n\t\t\tbios[j]->bio_offset = off;\n\t\t\tbios[j]->bio_length = MIN(s, maxio);\n\t\t\tbios[j]->bio_data = (caddr_t)p;\n\t\t\tg_io_request(bios[j], cp);\n\t\t}\n\t}\n\tASSERT3S(j, ==, n_bios);\n\n\t \n\tfor (i = j = 0; i < ncmds; i++) {\n\t\toff = offsets[i];\n\t\ts = sizes[i];\n\t\tend = off + s;\n\n\t\tfor (; off < end; off += maxio, s -= maxio, j++) {\n\t\t\terrors[i] = biowait(bios[j], \"vdev_geom_io\") ||\n\t\t\t    errors[i];\n\t\t\tg_destroy_bio(bios[j]);\n\t\t}\n\t}\n\tkmem_free(bios, bios_size);\n}\n\n \nstatic int\nvdev_geom_read_config(struct g_consumer *cp, nvlist_t **configp)\n{\n\tstruct g_provider *pp;\n\tnvlist_t *config;\n\tvdev_phys_t *vdev_lists[VDEV_LABELS];\n\tchar *buf;\n\tsize_t buflen;\n\tuint64_t psize, state, txg;\n\toff_t offsets[VDEV_LABELS];\n\toff_t size;\n\toff_t sizes[VDEV_LABELS];\n\tint cmds[VDEV_LABELS];\n\tint errors[VDEV_LABELS];\n\tint l, nlabels;\n\n\tg_topology_assert_not();\n\n\tpp = cp->provider;\n\tZFS_LOG(1, \"Reading config from %s...\", pp->name);\n\n\tpsize = pp->mediasize;\n\tpsize = P2ALIGN(psize, (uint64_t)sizeof (vdev_label_t));\n\n\tsize = sizeof (*vdev_lists[0]) + pp->sectorsize -\n\t    ((sizeof (*vdev_lists[0]) - 1) % pp->sectorsize) - 1;\n\n\tbuflen = sizeof (vdev_lists[0]->vp_nvlist);\n\n\t \n\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\tcmds[l] = BIO_READ;\n\t\tvdev_lists[l] = kmem_alloc(size, KM_SLEEP);\n\t\toffsets[l] = vdev_label_offset(psize, l, 0) + VDEV_SKIP_SIZE;\n\t\tsizes[l] = size;\n\t\terrors[l] = 0;\n\t\tASSERT0(offsets[l] % pp->sectorsize);\n\t}\n\n\t \n\tvdev_geom_io(cp, cmds, (void**)vdev_lists, offsets, sizes, errors,\n\t    VDEV_LABELS);\n\n\t \n\tconfig = *configp = NULL;\n\tnlabels = 0;\n\tfor (l = 0; l < VDEV_LABELS; l++) {\n\t\tif (errors[l] != 0)\n\t\t\tcontinue;\n\n\t\tbuf = vdev_lists[l]->vp_nvlist;\n\n\t\tif (nvlist_unpack(buf, buflen, &config, 0) != 0)\n\t\t\tcontinue;\n\n\t\tif (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_STATE,\n\t\t    &state) != 0 || state > POOL_STATE_L2CACHE) {\n\t\t\tnvlist_free(config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state != POOL_STATE_SPARE &&\n\t\t    state != POOL_STATE_L2CACHE &&\n\t\t    (nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_TXG,\n\t\t    &txg) != 0 || txg == 0)) {\n\t\t\tnvlist_free(config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*configp != NULL)\n\t\t\tnvlist_free(*configp);\n\t\t*configp = config;\n\t\tnlabels++;\n\t}\n\n\t \n\tfor (l = 0; l < VDEV_LABELS; l++)\n\t\tkmem_free(vdev_lists[l], size);\n\n\treturn (nlabels);\n}\n\nstatic void\nresize_configs(nvlist_t ***configs, uint64_t *count, uint64_t id)\n{\n\tnvlist_t **new_configs;\n\tuint64_t i;\n\n\tif (id < *count)\n\t\treturn;\n\tnew_configs = kmem_zalloc((id + 1) * sizeof (nvlist_t *),\n\t    KM_SLEEP);\n\tfor (i = 0; i < *count; i++)\n\t\tnew_configs[i] = (*configs)[i];\n\tif (*configs != NULL)\n\t\tkmem_free(*configs, *count * sizeof (void *));\n\t*configs = new_configs;\n\t*count = id + 1;\n}\n\nstatic void\nprocess_vdev_config(nvlist_t ***configs, uint64_t *count, nvlist_t *cfg,\n    const char *name, uint64_t *known_pool_guid)\n{\n\tnvlist_t *vdev_tree;\n\tuint64_t pool_guid;\n\tuint64_t vdev_guid;\n\tuint64_t id, txg, known_txg;\n\tconst char *pname;\n\n\tif (nvlist_lookup_string(cfg, ZPOOL_CONFIG_POOL_NAME, &pname) != 0 ||\n\t    strcmp(pname, name) != 0)\n\t\tgoto ignore;\n\n\tif (nvlist_lookup_uint64(cfg, ZPOOL_CONFIG_POOL_GUID, &pool_guid) != 0)\n\t\tgoto ignore;\n\n\tif (nvlist_lookup_uint64(cfg, ZPOOL_CONFIG_TOP_GUID, &vdev_guid) != 0)\n\t\tgoto ignore;\n\n\tif (nvlist_lookup_nvlist(cfg, ZPOOL_CONFIG_VDEV_TREE, &vdev_tree) != 0)\n\t\tgoto ignore;\n\n\tif (nvlist_lookup_uint64(vdev_tree, ZPOOL_CONFIG_ID, &id) != 0)\n\t\tgoto ignore;\n\n\ttxg = fnvlist_lookup_uint64(cfg, ZPOOL_CONFIG_POOL_TXG);\n\n\tif (*known_pool_guid != 0) {\n\t\tif (pool_guid != *known_pool_guid)\n\t\t\tgoto ignore;\n\t} else\n\t\t*known_pool_guid = pool_guid;\n\n\tresize_configs(configs, count, id);\n\n\tif ((*configs)[id] != NULL) {\n\t\tknown_txg = fnvlist_lookup_uint64((*configs)[id],\n\t\t    ZPOOL_CONFIG_POOL_TXG);\n\t\tif (txg <= known_txg)\n\t\t\tgoto ignore;\n\t\tnvlist_free((*configs)[id]);\n\t}\n\n\t(*configs)[id] = cfg;\n\treturn;\n\nignore:\n\tnvlist_free(cfg);\n}\n\nint\nvdev_geom_read_pool_label(const char *name,\n    nvlist_t ***configs, uint64_t *count)\n{\n\tstruct g_class *mp;\n\tstruct g_geom *gp;\n\tstruct g_provider *pp;\n\tstruct g_consumer *zcp;\n\tnvlist_t *vdev_cfg;\n\tuint64_t pool_guid;\n\tint nlabels;\n\n\tDROP_GIANT();\n\tg_topology_lock();\n\n\t*configs = NULL;\n\t*count = 0;\n\tpool_guid = 0;\n\tLIST_FOREACH(mp, &g_classes, class) {\n\t\tif (mp == &zfs_vdev_class)\n\t\t\tcontinue;\n\t\tLIST_FOREACH(gp, &mp->geom, geom) {\n\t\t\tif (gp->flags & G_GEOM_WITHER)\n\t\t\t\tcontinue;\n\t\t\tLIST_FOREACH(pp, &gp->provider, provider) {\n\t\t\t\tif (pp->flags & G_PF_WITHER)\n\t\t\t\t\tcontinue;\n\t\t\t\tzcp = vdev_geom_attach(pp, NULL, B_TRUE);\n\t\t\t\tif (zcp == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tg_topology_unlock();\n\t\t\t\tnlabels = vdev_geom_read_config(zcp, &vdev_cfg);\n\t\t\t\tg_topology_lock();\n\t\t\t\tvdev_geom_detach(zcp, B_TRUE);\n\t\t\t\tif (nlabels == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tZFS_LOG(1, \"successfully read vdev config\");\n\n\t\t\t\tprocess_vdev_config(configs, count,\n\t\t\t\t    vdev_cfg, name, &pool_guid);\n\t\t\t}\n\t\t}\n\t}\n\tg_topology_unlock();\n\tPICKUP_GIANT();\n\n\treturn (*count > 0 ? 0 : ENOENT);\n}\n\nenum match {\n\tNO_MATCH = 0,\t\t \n\tTOPGUID_MATCH = 1,\t \n\tZERO_MATCH = 1,\t\t \n\tONE_MATCH = 2,\t\t \n\tTWO_MATCH = 3,\t\t \n\tTHREE_MATCH = 4,\t \n\tFULL_MATCH = 5\t\t \n};\n\nstatic enum match\nvdev_attach_ok(vdev_t *vd, struct g_provider *pp)\n{\n\tnvlist_t *config;\n\tuint64_t pool_guid, top_guid, vdev_guid;\n\tstruct g_consumer *cp;\n\tint nlabels;\n\n\tcp = vdev_geom_attach(pp, NULL, B_TRUE);\n\tif (cp == NULL) {\n\t\tZFS_LOG(1, \"Unable to attach tasting instance to %s.\",\n\t\t    pp->name);\n\t\treturn (NO_MATCH);\n\t}\n\tg_topology_unlock();\n\tnlabels = vdev_geom_read_config(cp, &config);\n\tg_topology_lock();\n\tvdev_geom_detach(cp, B_TRUE);\n\tif (nlabels == 0) {\n\t\tZFS_LOG(1, \"Unable to read config from %s.\", pp->name);\n\t\treturn (NO_MATCH);\n\t}\n\n\tpool_guid = 0;\n\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_GUID, &pool_guid);\n\ttop_guid = 0;\n\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_TOP_GUID, &top_guid);\n\tvdev_guid = 0;\n\t(void) nvlist_lookup_uint64(config, ZPOOL_CONFIG_GUID, &vdev_guid);\n\tnvlist_free(config);\n\n\t \n\tif (pool_guid != 0 && pool_guid != spa_guid(vd->vdev_spa)) {\n\t\tZFS_LOG(1, \"pool guid mismatch for provider %s: %ju != %ju.\",\n\t\t    pp->name,\n\t\t    (uintmax_t)spa_guid(vd->vdev_spa), (uintmax_t)pool_guid);\n\t\treturn (NO_MATCH);\n\t}\n\n\t \n\tif (vdev_guid == vd->vdev_guid) {\n\t\tZFS_LOG(1, \"guids match for provider %s.\", pp->name);\n\t\treturn (ZERO_MATCH + nlabels);\n\t} else if (top_guid == vd->vdev_guid && vd == vd->vdev_top) {\n\t\tZFS_LOG(1, \"top vdev guid match for provider %s.\", pp->name);\n\t\treturn (TOPGUID_MATCH);\n\t}\n\tZFS_LOG(1, \"vdev guid mismatch for provider %s: %ju != %ju.\",\n\t    pp->name, (uintmax_t)vd->vdev_guid, (uintmax_t)vdev_guid);\n\treturn (NO_MATCH);\n}\n\nstatic struct g_consumer *\nvdev_geom_attach_by_guids(vdev_t *vd)\n{\n\tstruct g_class *mp;\n\tstruct g_geom *gp;\n\tstruct g_provider *pp, *best_pp;\n\tstruct g_consumer *cp;\n\tconst char *vdpath;\n\tenum match match, best_match;\n\n\tg_topology_assert();\n\n\tvdpath = vd->vdev_path + sizeof (\"/dev/\") - 1;\n\tcp = NULL;\n\tbest_pp = NULL;\n\tbest_match = NO_MATCH;\n\tLIST_FOREACH(mp, &g_classes, class) {\n\t\tif (mp == &zfs_vdev_class)\n\t\t\tcontinue;\n\t\tLIST_FOREACH(gp, &mp->geom, geom) {\n\t\t\tif (gp->flags & G_GEOM_WITHER)\n\t\t\t\tcontinue;\n\t\t\tLIST_FOREACH(pp, &gp->provider, provider) {\n\t\t\t\tmatch = vdev_attach_ok(vd, pp);\n\t\t\t\tif (match > best_match) {\n\t\t\t\t\tbest_match = match;\n\t\t\t\t\tbest_pp = pp;\n\t\t\t\t} else if (match == best_match) {\n\t\t\t\t\tif (strcmp(pp->name, vdpath) == 0) {\n\t\t\t\t\t\tbest_pp = pp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (match == FULL_MATCH)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tif (best_pp) {\n\t\tcp = vdev_geom_attach(best_pp, vd, B_TRUE);\n\t\tif (cp == NULL) {\n\t\t\tprintf(\"ZFS WARNING: Unable to attach to %s.\\n\",\n\t\t\t    best_pp->name);\n\t\t}\n\t}\n\treturn (cp);\n}\n\nstatic struct g_consumer *\nvdev_geom_open_by_guids(vdev_t *vd)\n{\n\tstruct g_consumer *cp;\n\tchar *buf;\n\tsize_t len;\n\n\tg_topology_assert();\n\n\tZFS_LOG(1, \"Searching by guids [%ju:%ju].\",\n\t    (uintmax_t)spa_guid(vd->vdev_spa), (uintmax_t)vd->vdev_guid);\n\tcp = vdev_geom_attach_by_guids(vd);\n\tif (cp != NULL) {\n\t\tlen = strlen(cp->provider->name) + strlen(\"/dev/\") + 1;\n\t\tbuf = kmem_alloc(len, KM_SLEEP);\n\n\t\tsnprintf(buf, len, \"/dev/%s\", cp->provider->name);\n\t\tspa_strfree(vd->vdev_path);\n\t\tvd->vdev_path = buf;\n\n\t\tZFS_LOG(1, \"Attach by guid [%ju:%ju] succeeded, provider %s.\",\n\t\t    (uintmax_t)spa_guid(vd->vdev_spa),\n\t\t    (uintmax_t)vd->vdev_guid, cp->provider->name);\n\t} else {\n\t\tZFS_LOG(1, \"Search by guid [%ju:%ju] failed.\",\n\t\t    (uintmax_t)spa_guid(vd->vdev_spa),\n\t\t    (uintmax_t)vd->vdev_guid);\n\t}\n\n\treturn (cp);\n}\n\nstatic struct g_consumer *\nvdev_geom_open_by_path(vdev_t *vd, int check_guid)\n{\n\tstruct g_provider *pp;\n\tstruct g_consumer *cp;\n\n\tg_topology_assert();\n\n\tcp = NULL;\n\tpp = g_provider_by_name(vd->vdev_path + sizeof (\"/dev/\") - 1);\n\tif (pp != NULL) {\n\t\tZFS_LOG(1, \"Found provider by name %s.\", vd->vdev_path);\n\t\tif (!check_guid || vdev_attach_ok(vd, pp) == FULL_MATCH)\n\t\t\tcp = vdev_geom_attach(pp, vd, B_FALSE);\n\t}\n\n\treturn (cp);\n}\n\nstatic int\nvdev_geom_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,\n    uint64_t *logical_ashift, uint64_t *physical_ashift)\n{\n\tstruct g_provider *pp;\n\tstruct g_consumer *cp;\n\tint error, has_trim;\n\tuint16_t rate;\n\n\t \n\tVERIFY0(tsd_set(zfs_geom_probe_vdev_key, vd));\n\n\t \n\tif (vd->vdev_path == NULL || strncmp(vd->vdev_path, \"/dev/\", 5) != 0) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_BAD_LABEL;\n\t\treturn (EINVAL);\n\t}\n\n\t \n\tif ((cp = vd->vdev_tsd) != NULL) {\n\t\tASSERT(vd->vdev_reopening);\n\t\tgoto skip_open;\n\t}\n\n\tDROP_GIANT();\n\tg_topology_lock();\n\terror = 0;\n\n\tif (vd->vdev_spa->spa_is_splitting ||\n\t    ((vd->vdev_prevstate == VDEV_STATE_UNKNOWN &&\n\t    (vd->vdev_spa->spa_load_state == SPA_LOAD_NONE ||\n\t    vd->vdev_spa->spa_load_state == SPA_LOAD_CREATE)))) {\n\t\t \n\t\tcp = vdev_geom_open_by_path(vd, 0);\n\t} else {\n\t\t \n\t\tcp = vdev_geom_open_by_path(vd, 1);\n\t\tif (cp == NULL) {\n\t\t\t \n\t\t\tcp = vdev_geom_open_by_guids(vd);\n\t\t}\n\t}\n\n\t \n\tVERIFY0(tsd_set(zfs_geom_probe_vdev_key, NULL));\n\n\tif (cp == NULL) {\n\t\tZFS_LOG(1, \"Vdev %s not found.\", vd->vdev_path);\n\t\terror = ENOENT;\n\t} else {\n\t\tstruct consumer_priv_t *priv;\n\t\tstruct consumer_vdev_elem *elem;\n\t\tint spamode;\n\n\t\tpriv = (struct consumer_priv_t *)&cp->private;\n\t\tif (cp->private == NULL)\n\t\t\tSLIST_INIT(priv);\n\t\telem = g_malloc(sizeof (*elem), M_WAITOK|M_ZERO);\n\t\telem->vd = vd;\n\t\tSLIST_INSERT_HEAD(priv, elem, elems);\n\n\t\tspamode = spa_mode(vd->vdev_spa);\n\t\tif (cp->provider->sectorsize > VDEV_PAD_SIZE ||\n\t\t    !ISP2(cp->provider->sectorsize)) {\n\t\t\tZFS_LOG(1, \"Provider %s has unsupported sectorsize.\",\n\t\t\t    cp->provider->name);\n\n\t\t\tvdev_geom_close_locked(vd);\n\t\t\terror = EINVAL;\n\t\t\tcp = NULL;\n\t\t} else if (cp->acw == 0 && (spamode & FWRITE) != 0) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\terror = g_access(cp, 0, 1, 0);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tg_topology_unlock();\n\t\t\t\ttsleep(vd, 0, \"vdev\", hz / 2);\n\t\t\t\tg_topology_lock();\n\t\t\t}\n\t\t\tif (error != 0) {\n\t\t\t\tprintf(\"ZFS WARNING: Unable to open %s for \"\n\t\t\t\t    \"writing (error=%d).\\n\",\n\t\t\t\t    cp->provider->name, error);\n\t\t\t\tvdev_geom_close_locked(vd);\n\t\t\t\tcp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (cp != NULL) {\n\t\tvdev_geom_attrchanged(cp, \"GEOM::physpath\");\n\n\t\t \n\t\tvdev_geom_set_physpath(vd, cp,  B_FALSE);\n\t}\n\n\tg_topology_unlock();\n\tPICKUP_GIANT();\n\tif (cp == NULL) {\n\t\tvd->vdev_stat.vs_aux = VDEV_AUX_OPEN_FAILED;\n\t\tvdev_dbgmsg(vd, \"vdev_geom_open: failed to open [error=%d]\",\n\t\t    error);\n\t\treturn (error);\n\t}\nskip_open:\n\tpp = cp->provider;\n\n\t \n\t*max_psize = *psize = pp->mediasize;\n\n\t \n\t*logical_ashift = highbit(MAX(pp->sectorsize, SPA_MINBLOCKSIZE)) - 1;\n\t*physical_ashift = 0;\n\tif (pp->stripesize && pp->stripesize > (1 << *logical_ashift) &&\n\t    ISP2(pp->stripesize) && pp->stripeoffset == 0)\n\t\t*physical_ashift = highbit(pp->stripesize) - 1;\n\n\t \n\tvd->vdev_nowritecache = B_FALSE;\n\n\t \n\terror = g_getattr(\"GEOM::rotation_rate\", cp, &rate);\n\tif (error == 0 && rate == DISK_RR_NON_ROTATING)\n\t\tvd->vdev_nonrot = B_TRUE;\n\telse\n\t\tvd->vdev_nonrot = B_FALSE;\n\n\t \n\terror = g_getattr(\"GEOM::candelete\", cp, &has_trim);\n\tvd->vdev_has_trim = (error == 0 && has_trim);\n\n\t \n\t \n\tvd->vdev_has_securetrim = B_FALSE;\n\n\treturn (0);\n}\n\nstatic void\nvdev_geom_close(vdev_t *vd)\n{\n\tstruct g_consumer *cp;\n\tboolean_t locked;\n\n\tcp = vd->vdev_tsd;\n\n\tDROP_GIANT();\n\tlocked = g_topology_locked();\n\tif (!locked)\n\t\tg_topology_lock();\n\n\tif (!vd->vdev_reopening ||\n\t    (cp != NULL && ((cp->flags & G_CF_ORPHAN) != 0 ||\n\t    (cp->provider != NULL && cp->provider->error != 0))))\n\t\tvdev_geom_close_locked(vd);\n\n\tif (!locked)\n\t\tg_topology_unlock();\n\tPICKUP_GIANT();\n}\n\nstatic void\nvdev_geom_io_intr(struct bio *bp)\n{\n\tvdev_t *vd;\n\tzio_t *zio;\n\n\tzio = bp->bio_caller1;\n\tvd = zio->io_vd;\n\tzio->io_error = bp->bio_error;\n\tif (zio->io_error == 0 && bp->bio_resid != 0)\n\t\tzio->io_error = SET_ERROR(EIO);\n\n\tswitch (zio->io_error) {\n\tcase ENOTSUP:\n\t\t \n\t\tswitch (bp->bio_cmd) {\n\t\tcase BIO_FLUSH:\n\t\t\tvd->vdev_nowritecache = B_TRUE;\n\t\t\tbreak;\n\t\tcase BIO_DELETE:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ENXIO:\n\t\tif (!vd->vdev_remove_wanted) {\n\t\t\t \n\t\t\tif (bp->bio_to->error != 0) {\n\t\t\t\tvd->vdev_remove_wanted = B_TRUE;\n\t\t\t\tspa_async_request(zio->io_spa,\n\t\t\t\t    SPA_ASYNC_REMOVE);\n\t\t\t} else if (!vd->vdev_delayed_close) {\n\t\t\t\tvd->vdev_delayed_close = B_TRUE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (zio->io_type != ZIO_TYPE_READ && zio->io_type != ZIO_TYPE_WRITE) {\n\t\tg_destroy_bio(bp);\n\t\tzio->io_bio = NULL;\n\t}\n\tzio_delay_interrupt(zio);\n}\n\nstruct vdev_geom_check_unmapped_cb_state {\n\tint\tpages;\n\tuint_t\tend;\n};\n\n \nstatic int\nvdev_geom_check_unmapped_cb(void *buf, size_t len, void *priv)\n{\n\tstruct vdev_geom_check_unmapped_cb_state *s = priv;\n\tvm_offset_t off = (vm_offset_t)buf & PAGE_MASK;\n\n\tif (s->pages != 0 && off != 0)\n\t\treturn (1);\n\tif (s->end != 0)\n\t\treturn (1);\n\ts->end = (off + len) & PAGE_MASK;\n\ts->pages += (off + len + PAGE_MASK) >> PAGE_SHIFT;\n\treturn (0);\n}\n\n \nstatic int\nvdev_geom_check_unmapped(zio_t *zio, struct g_consumer *cp)\n{\n\tstruct vdev_geom_check_unmapped_cb_state s;\n\n\t \n\tif (!unmapped_buf_allowed)\n\t\treturn (0);\n\n\t \n\tif (abd_is_linear(zio->io_abd))\n\t\treturn (0);\n\n\t \n\tif ((cp->provider->flags & G_PF_ACCEPT_UNMAPPED) == 0)\n\t\treturn (0);\n\n\t \n\ts.pages = s.end = 0;\n\tif (abd_iterate_func(zio->io_abd, 0, zio->io_size,\n\t    vdev_geom_check_unmapped_cb, &s))\n\t\treturn (0);\n\treturn (s.pages);\n}\n\n \nstatic int\nvdev_geom_fill_unmap_cb(void *buf, size_t len, void *priv)\n{\n\tstruct bio *bp = priv;\n\tvm_offset_t addr = (vm_offset_t)buf;\n\tvm_offset_t end = addr + len;\n\n\tif (bp->bio_ma_n == 0) {\n\t\tbp->bio_ma_offset = addr & PAGE_MASK;\n\t\taddr &= ~PAGE_MASK;\n\t} else {\n\t\tASSERT0(P2PHASE(addr, PAGE_SIZE));\n\t}\n\tdo {\n\t\tbp->bio_ma[bp->bio_ma_n++] =\n\t\t    PHYS_TO_VM_PAGE(pmap_kextract(addr));\n\t\taddr += PAGE_SIZE;\n\t} while (addr < end);\n\treturn (0);\n}\n\nstatic void\nvdev_geom_io_start(zio_t *zio)\n{\n\tvdev_t *vd;\n\tstruct g_consumer *cp;\n\tstruct bio *bp;\n\n\tvd = zio->io_vd;\n\n\tswitch (zio->io_type) {\n\tcase ZIO_TYPE_IOCTL:\n\t\t \n\t\tif (!vdev_readable(vd)) {\n\t\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\t\tzio_interrupt(zio);\n\t\t\treturn;\n\t\t} else {\n\t\t\tswitch (zio->io_cmd) {\n\t\t\tcase DKIOCFLUSHWRITECACHE:\n\t\t\t\tif (zfs_nocacheflush ||\n\t\t\t\t    vdev_geom_bio_flush_disable)\n\t\t\t\t\tbreak;\n\t\t\t\tif (vd->vdev_nowritecache) {\n\t\t\t\t\tzio->io_error = SET_ERROR(ENOTSUP);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto sendreq;\n\t\t\tdefault:\n\t\t\t\tzio->io_error = SET_ERROR(ENOTSUP);\n\t\t\t}\n\t\t}\n\n\t\tzio_execute(zio);\n\t\treturn;\n\tcase ZIO_TYPE_TRIM:\n\t\tif (!vdev_geom_bio_delete_disable) {\n\t\t\tgoto sendreq;\n\t\t}\n\t\tzio_execute(zio);\n\t\treturn;\n\tdefault:\n\t\t\t;\n\t\t \n\t}\nsendreq:\n\tASSERT(zio->io_type == ZIO_TYPE_READ ||\n\t    zio->io_type == ZIO_TYPE_WRITE ||\n\t    zio->io_type == ZIO_TYPE_TRIM ||\n\t    zio->io_type == ZIO_TYPE_IOCTL);\n\n\tcp = vd->vdev_tsd;\n\tif (cp == NULL) {\n\t\tzio->io_error = SET_ERROR(ENXIO);\n\t\tzio_interrupt(zio);\n\t\treturn;\n\t}\n\tbp = g_alloc_bio();\n\tbp->bio_caller1 = zio;\n\tswitch (zio->io_type) {\n\tcase ZIO_TYPE_READ:\n\tcase ZIO_TYPE_WRITE:\n\t\tzio->io_target_timestamp = zio_handle_io_delay(zio);\n\t\tbp->bio_offset = zio->io_offset;\n\t\tbp->bio_length = zio->io_size;\n\t\tif (zio->io_type == ZIO_TYPE_READ)\n\t\t\tbp->bio_cmd = BIO_READ;\n\t\telse\n\t\t\tbp->bio_cmd = BIO_WRITE;\n\n\t\t \n\t\tint pgs = vdev_geom_check_unmapped(zio, cp);\n\t\tif (pgs > 0) {\n\t\t\tbp->bio_ma = malloc(sizeof (struct vm_page *) * pgs,\n\t\t\t    M_DEVBUF, M_WAITOK);\n\t\t\tbp->bio_ma_n = 0;\n\t\t\tbp->bio_ma_offset = 0;\n\t\t\tabd_iterate_func(zio->io_abd, 0, zio->io_size,\n\t\t\t    vdev_geom_fill_unmap_cb, bp);\n\t\t\tbp->bio_data = unmapped_buf;\n\t\t\tbp->bio_flags |= BIO_UNMAPPED;\n\t\t} else {\n\t\t\tif (zio->io_type == ZIO_TYPE_READ) {\n\t\t\t\tbp->bio_data = abd_borrow_buf(zio->io_abd,\n\t\t\t\t    zio->io_size);\n\t\t\t} else {\n\t\t\t\tbp->bio_data = abd_borrow_buf_copy(zio->io_abd,\n\t\t\t\t    zio->io_size);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ZIO_TYPE_TRIM:\n\t\tbp->bio_cmd = BIO_DELETE;\n\t\tbp->bio_data = NULL;\n\t\tbp->bio_offset = zio->io_offset;\n\t\tbp->bio_length = zio->io_size;\n\t\tbreak;\n\tcase ZIO_TYPE_IOCTL:\n\t\tbp->bio_cmd = BIO_FLUSH;\n\t\tbp->bio_data = NULL;\n\t\tbp->bio_offset = cp->provider->mediasize;\n\t\tbp->bio_length = 0;\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"invalid zio->io_type: %d\\n\", zio->io_type);\n\t}\n\tbp->bio_done = vdev_geom_io_intr;\n\tzio->io_bio = bp;\n\n\tg_io_request(bp, cp);\n}\n\nstatic void\nvdev_geom_io_done(zio_t *zio)\n{\n\tstruct bio *bp = zio->io_bio;\n\n\tif (zio->io_type != ZIO_TYPE_READ && zio->io_type != ZIO_TYPE_WRITE) {\n\t\tASSERT3P(bp, ==, NULL);\n\t\treturn;\n\t}\n\n\tif (bp == NULL) {\n\t\tASSERT3S(zio->io_error, ==, ENXIO);\n\t\treturn;\n\t}\n\n\tif (bp->bio_ma != NULL) {\n\t\tfree(bp->bio_ma, M_DEVBUF);\n\t} else {\n\t\tif (zio->io_type == ZIO_TYPE_READ) {\n\t\t\tabd_return_buf_copy(zio->io_abd, bp->bio_data,\n\t\t\t    zio->io_size);\n\t\t} else {\n\t\t\tabd_return_buf(zio->io_abd, bp->bio_data,\n\t\t\t    zio->io_size);\n\t\t}\n\t}\n\n\tg_destroy_bio(bp);\n\tzio->io_bio = NULL;\n}\n\nstatic void\nvdev_geom_hold(vdev_t *vd)\n{\n}\n\nstatic void\nvdev_geom_rele(vdev_t *vd)\n{\n}\n\nvdev_ops_t vdev_disk_ops = {\n\t.vdev_op_init = NULL,\n\t.vdev_op_fini = NULL,\n\t.vdev_op_open = vdev_geom_open,\n\t.vdev_op_close = vdev_geom_close,\n\t.vdev_op_asize = vdev_default_asize,\n\t.vdev_op_min_asize = vdev_default_min_asize,\n\t.vdev_op_min_alloc = NULL,\n\t.vdev_op_io_start = vdev_geom_io_start,\n\t.vdev_op_io_done = vdev_geom_io_done,\n\t.vdev_op_state_change = NULL,\n\t.vdev_op_need_resilver = NULL,\n\t.vdev_op_hold = vdev_geom_hold,\n\t.vdev_op_rele = vdev_geom_rele,\n\t.vdev_op_remap = NULL,\n\t.vdev_op_xlate = vdev_default_xlate,\n\t.vdev_op_rebuild_asize = NULL,\n\t.vdev_op_metaslab_init = NULL,\n\t.vdev_op_config_generate = NULL,\n\t.vdev_op_nparity = NULL,\n\t.vdev_op_ndisks = NULL,\n\t.vdev_op_type = VDEV_TYPE_DISK,\t\t \n\t.vdev_op_leaf = B_TRUE\t\t\t \n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}