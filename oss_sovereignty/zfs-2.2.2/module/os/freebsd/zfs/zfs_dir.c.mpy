{
  "module_name": "zfs_dir.c",
  "hash_id": "02aec1635f7279bf82fd2896582422d77d71c5f570ceb404bc940c93427c3b6a",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_dir.c",
  "human_readable_source": " \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/systm.h>\n#include <sys/sysmacros.h>\n#include <sys/resource.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/uio.h>\n#include <sys/cmn_err.h>\n#include <sys/errno.h>\n#include <sys/stat.h>\n#include <sys/unistd.h>\n#include <sys/sunddi.h>\n#include <sys/random.h>\n#include <sys/policy.h>\n#include <sys/condvar.h>\n#include <sys/callb.h>\n#include <sys/smp.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_acl.h>\n#include <sys/fs/zfs.h>\n#include <sys/zap.h>\n#include <sys/dmu.h>\n#include <sys/atomic.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_fuid.h>\n#include <sys/sa.h>\n#include <sys/zfs_sa.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n\n#include <sys/ccompat.h>\n\n \nstatic int\nzfs_match_find(zfsvfs_t *zfsvfs, znode_t *dzp, const char *name,\n    matchtype_t mt, uint64_t *zoid)\n{\n\tint error;\n\n\tif (zfsvfs->z_norm) {\n\n\t\t \n\t\terror = zap_lookup_norm(zfsvfs->z_os, dzp->z_id, name, 8, 1,\n\t\t    zoid, mt, NULL, 0, NULL);\n\t} else {\n\t\terror = zap_lookup(zfsvfs->z_os, dzp->z_id, name, 8, 1, zoid);\n\t}\n\t*zoid = ZFS_DIRENT_OBJ(*zoid);\n\n\treturn (error);\n}\n\n \nint\nzfs_dirent_lookup(znode_t *dzp, const char *name, znode_t **zpp, int flag)\n{\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tznode_t\t\t*zp;\n\tmatchtype_t\tmt = 0;\n\tuint64_t\tzoid;\n\tint\t\terror = 0;\n\n\tif (zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(ZTOV(dzp), __func__);\n\n\t*zpp = NULL;\n\n\t \n\tif (name[0] == '.' &&\n\t    (((name[1] == '\\0') || (name[1] == '.' && name[2] == '\\0')) ||\n\t    (zfs_has_ctldir(dzp) && strcmp(name, ZFS_CTLDIR_NAME) == 0)))\n\t\treturn (SET_ERROR(EEXIST));\n\n\t \n\tif (zfsvfs->z_norm != 0) {\n\t\tmt = MT_NORMALIZE;\n\n\t\t \n\t\tif (zfsvfs->z_case == ZFS_CASE_MIXED) {\n\t\t\tmt |= MT_MATCH_CASE;\n\t\t}\n\t}\n\n\t \n\n\tif (dzp->z_unlinked && !(flag & ZXATTR))\n\t\treturn (ENOENT);\n\tif (flag & ZXATTR) {\n\t\terror = sa_lookup(dzp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs), &zoid,\n\t\t    sizeof (zoid));\n\t\tif (error == 0)\n\t\t\terror = (zoid == 0 ? ENOENT : 0);\n\t} else {\n\t\terror = zfs_match_find(zfsvfs, dzp, name, mt, &zoid);\n\t}\n\tif (error) {\n\t\tif (error != ENOENT || (flag & ZEXISTS)) {\n\t\t\treturn (error);\n\t\t}\n\t} else {\n\t\tif (flag & ZNEW) {\n\t\t\treturn (SET_ERROR(EEXIST));\n\t\t}\n\t\terror = zfs_zget(zfsvfs, zoid, &zp);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tASSERT(!zp->z_unlinked);\n\t\t*zpp = zp;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzfs_dd_lookup(znode_t *dzp, znode_t **zpp)\n{\n\tzfsvfs_t *zfsvfs = dzp->z_zfsvfs;\n\tznode_t *zp;\n\tuint64_t parent;\n\tint error;\n\n#ifdef ZFS_DEBUG\n\tif (zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(ZTOV(dzp), __func__);\n#endif\n\tif (dzp->z_unlinked)\n\t\treturn (ENOENT);\n\n\tif ((error = sa_lookup(dzp->z_sa_hdl,\n\t    SA_ZPL_PARENT(zfsvfs), &parent, sizeof (parent))) != 0)\n\t\treturn (error);\n\n\terror = zfs_zget(zfsvfs, parent, &zp);\n\tif (error == 0)\n\t\t*zpp = zp;\n\treturn (error);\n}\n\nint\nzfs_dirlook(znode_t *dzp, const char *name, znode_t **zpp)\n{\n\tzfsvfs_t *zfsvfs __unused = dzp->z_zfsvfs;\n\tznode_t *zp = NULL;\n\tint error = 0;\n\n#ifdef ZFS_DEBUG\n\tif (zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(ZTOV(dzp), __func__);\n#endif\n\tif (dzp->z_unlinked)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tif (name[0] == 0 || (name[0] == '.' && name[1] == 0)) {\n\t\t*zpp = dzp;\n\t} else if (name[0] == '.' && name[1] == '.' && name[2] == 0) {\n\t\terror = zfs_dd_lookup(dzp, &zp);\n\t\tif (error == 0)\n\t\t\t*zpp = zp;\n\t} else {\n\t\terror = zfs_dirent_lookup(dzp, name, &zp, ZEXISTS);\n\t\tif (error == 0) {\n\t\t\tdzp->z_zn_prefetch = B_TRUE;  \n\t\t\t*zpp = zp;\n\t\t}\n\t}\n\treturn (error);\n}\n\n \nvoid\nzfs_unlinked_add(znode_t *zp, dmu_tx_t *tx)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\n\tASSERT(zp->z_unlinked);\n\tASSERT3U(zp->z_links, ==, 0);\n\n\tVERIFY0(zap_add_int(zfsvfs->z_os, zfsvfs->z_unlinkedobj, zp->z_id, tx));\n\n\tdataset_kstats_update_nunlinks_kstat(&zfsvfs->z_kstat, 1);\n}\n\n \nvoid\nzfs_unlinked_drain(zfsvfs_t *zfsvfs)\n{\n\tzap_cursor_t\tzc;\n\tzap_attribute_t zap;\n\tdmu_object_info_t doi;\n\tznode_t\t\t*zp;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\n\t \n\tfor (zap_cursor_init(&zc, zfsvfs->z_os, zfsvfs->z_unlinkedobj);\n\t    zap_cursor_retrieve(&zc, &zap) == 0;\n\t    zap_cursor_advance(&zc)) {\n\n\t\t \n\n\t\terror = dmu_object_info(zfsvfs->z_os,\n\t\t    zap.za_first_integer, &doi);\n\t\tif (error != 0)\n\t\t\tcontinue;\n\n\t\tASSERT((doi.doi_type == DMU_OT_PLAIN_FILE_CONTENTS) ||\n\t\t    (doi.doi_type == DMU_OT_DIRECTORY_CONTENTS));\n\t\t \n\t\terror = zfs_zget(zfsvfs, zap.za_first_integer, &zp);\n\n\t\t \n\t\tif (error != 0)\n\t\t\tcontinue;\n\n\t\tvn_lock(ZTOV(zp), LK_EXCLUSIVE | LK_RETRY);\n\n\t\t \n\t\tif (zp->z_links != 0) {\n\t\t\ttx = dmu_tx_create(zfsvfs->z_os);\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\t\tif (error != 0) {\n\t\t\t\tdmu_tx_abort(tx);\n\t\t\t\tvput(ZTOV(zp));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tzp->z_links = 0;\n\t\t\tVERIFY0(sa_update(zp->z_sa_hdl, SA_ZPL_LINKS(zfsvfs),\n\t\t\t    &zp->z_links, sizeof (zp->z_links), tx));\n\t\t\tdmu_tx_commit(tx);\n\t\t}\n\n\t\tzp->z_unlinked = B_TRUE;\n\t\tvput(ZTOV(zp));\n\t}\n\tzap_cursor_fini(&zc);\n}\n\n \nstatic int\nzfs_purgedir(znode_t *dzp)\n{\n\tzap_cursor_t\tzc;\n\tzap_attribute_t\tzap;\n\tznode_t\t\t*xzp;\n\tdmu_tx_t\t*tx;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tint skipped = 0;\n\tint error;\n\n\tfor (zap_cursor_init(&zc, zfsvfs->z_os, dzp->z_id);\n\t    (error = zap_cursor_retrieve(&zc, &zap)) == 0;\n\t    zap_cursor_advance(&zc)) {\n\t\terror = zfs_zget(zfsvfs,\n\t\t    ZFS_DIRENT_OBJ(zap.za_first_integer), &xzp);\n\t\tif (error) {\n\t\t\tskipped += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvn_lock(ZTOV(xzp), LK_EXCLUSIVE | LK_RETRY);\n\t\tASSERT((ZTOV(xzp)->v_type == VREG) ||\n\t\t    (ZTOV(xzp)->v_type == VLNK));\n\n\t\ttx = dmu_tx_create(zfsvfs->z_os);\n\t\tdmu_tx_hold_sa(tx, dzp->z_sa_hdl, B_FALSE);\n\t\tdmu_tx_hold_zap(tx, dzp->z_id, FALSE, zap.za_name);\n\t\tdmu_tx_hold_sa(tx, xzp->z_sa_hdl, B_FALSE);\n\t\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\t\t \n\t\tzfs_sa_upgrade_txholds(tx, xzp);\n\t\tdmu_tx_mark_netfree(tx);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tdmu_tx_abort(tx);\n\t\t\tvput(ZTOV(xzp));\n\t\t\tskipped += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = zfs_link_destroy(dzp, zap.za_name, xzp, tx, 0, NULL);\n\t\tif (error)\n\t\t\tskipped += 1;\n\t\tdmu_tx_commit(tx);\n\n\t\tvput(ZTOV(xzp));\n\t}\n\tzap_cursor_fini(&zc);\n\tif (error != ENOENT)\n\t\tskipped += 1;\n\treturn (skipped);\n}\n\nextern taskq_t *zfsvfs_taskq;\n\nvoid\nzfs_rmnode(znode_t *zp)\n{\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tobjset_t\t*os = zfsvfs->z_os;\n\tdmu_tx_t\t*tx;\n\tuint64_t\tz_id = zp->z_id;\n\tuint64_t\tacl_obj;\n\tuint64_t\txattr_obj;\n\tuint64_t\tcount;\n\tint\t\terror;\n\n\tASSERT3U(zp->z_links, ==, 0);\n\tif (zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n\n\t \n\tif (ZTOV(zp) != NULL && ZTOV(zp)->v_type == VDIR &&\n\t    (zp->z_pflags & ZFS_XATTR)) {\n\t\tif (zfs_purgedir(zp) != 0) {\n\t\t\t \n\t\t\tZFS_OBJ_HOLD_ENTER(zfsvfs, z_id);\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tzfs_znode_free(zp);\n\t\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, z_id);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\terror = dmu_free_long_range(os, zp->z_id, 0, DMU_OBJECT_END);\n\t\tif (error) {\n\t\t\t \n\t\t\tZFS_OBJ_HOLD_ENTER(zfsvfs, z_id);\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t\tzfs_znode_free(zp);\n\t\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, z_id);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\terror = sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t    &xattr_obj, sizeof (xattr_obj));\n\tif (error)\n\t\txattr_obj = 0;\n\n\tacl_obj = zfs_external_acl(zp);\n\n\t \n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_free(tx, zp->z_id, 0, DMU_OBJECT_END);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\tif (xattr_obj)\n\t\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, TRUE, NULL);\n\tif (acl_obj)\n\t\tdmu_tx_hold_free(tx, acl_obj, 0, DMU_OBJECT_END);\n\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\t \n\t\tdmu_tx_abort(tx);\n\t\tZFS_OBJ_HOLD_ENTER(zfsvfs, z_id);\n\t\tzfs_znode_dmu_fini(zp);\n\t\tzfs_znode_free(zp);\n\t\tZFS_OBJ_HOLD_EXIT(zfsvfs, z_id);\n\t\treturn;\n\t}\n\n\t \n\tif (xattr_obj) {\n\t\t \n\t\tVERIFY3U(0, ==,\n\t\t    zap_add_int(os, zfsvfs->z_unlinkedobj, xattr_obj, tx));\n\t}\n\n\tmutex_enter(&os->os_dsl_dataset->ds_dir->dd_activity_lock);\n\n\t \n\tVERIFY3U(0, ==,\n\t    zap_remove_int(os, zfsvfs->z_unlinkedobj, zp->z_id, tx));\n\n\tif (zap_count(os, zfsvfs->z_unlinkedobj, &count) == 0 && count == 0) {\n\t\tcv_broadcast(&os->os_dsl_dataset->ds_dir->dd_activity_cv);\n\t}\n\n\tmutex_exit(&os->os_dsl_dataset->ds_dir->dd_activity_lock);\n\n\tdataset_kstats_update_nunlinked_kstat(&zfsvfs->z_kstat, 1);\n\n\tzfs_znode_delete(zp, tx);\n\n\tdmu_tx_commit(tx);\n\n\tif (xattr_obj) {\n\t\t \n\t\ttaskqueue_enqueue(zfsvfs_taskq->tq_queue,\n\t\t    &zfsvfs->z_unlinked_drain_task);\n\t}\n}\n\nstatic uint64_t\nzfs_dirent(znode_t *zp, uint64_t mode)\n{\n\tuint64_t de = zp->z_id;\n\n\tif (zp->z_zfsvfs->z_version >= ZPL_VERSION_DIRENT_TYPE)\n\t\tde |= IFTODT(mode) << 60;\n\treturn (de);\n}\n\n \nint\nzfs_link_create(znode_t *dzp, const char *name, znode_t *zp, dmu_tx_t *tx,\n    int flag)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tvnode_t *vp = ZTOV(zp);\n\tuint64_t value;\n\tint zp_is_dir = (vp->v_type == VDIR);\n\tsa_bulk_attr_t bulk[5];\n\tuint64_t mtime[2], ctime[2];\n\tint count = 0;\n\tint error;\n\n\tif (zfsvfs->z_replay == B_FALSE) {\n\t\tASSERT_VOP_ELOCKED(ZTOV(dzp), __func__);\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n\t}\n\tif (zp_is_dir) {\n\t\tif (dzp->z_links >= ZFS_LINK_MAX)\n\t\t\treturn (SET_ERROR(EMLINK));\n\t}\n\tif (!(flag & ZRENAMING)) {\n\t\tif (zp->z_unlinked) {\t \n\t\t\tASSERT(!(flag & (ZNEW | ZEXISTS)));\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\t\tif (zp->z_links >= ZFS_LINK_MAX - zp_is_dir) {\n\t\t\treturn (SET_ERROR(EMLINK));\n\t\t}\n\t\tzp->z_links++;\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL,\n\t\t    &zp->z_links, sizeof (zp->z_links));\n\n\t} else {\n\t\tASSERT(!zp->z_unlinked);\n\t}\n\tvalue = zfs_dirent(zp, zp->z_mode);\n\terror = zap_add(zp->z_zfsvfs->z_os, dzp->z_id, name,\n\t    8, 1, &value, tx);\n\n\t \n\tif (error != 0) {\n\t\tif (!(flag & ZRENAMING) && !(flag & ZNEW))\n\t\t\tzp->z_links--;\n\t\treturn (error);\n\t}\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_PARENT(zfsvfs), NULL,\n\t    &dzp->z_id, sizeof (dzp->z_id));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\n\tif (!(flag & ZNEW)) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    ctime, sizeof (ctime));\n\t\tzfs_tstamp_update_setup(zp, STATE_CHANGED, mtime,\n\t\t    ctime);\n\t}\n\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\tASSERT0(error);\n\n\tdzp->z_size++;\n\tdzp->z_links += zp_is_dir;\n\tcount = 0;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs), NULL,\n\t    &dzp->z_size, sizeof (dzp->z_size));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs), NULL,\n\t    &dzp->z_links, sizeof (dzp->z_links));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t    mtime, sizeof (mtime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t    ctime, sizeof (ctime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &dzp->z_pflags, sizeof (dzp->z_pflags));\n\tzfs_tstamp_update_setup(dzp, CONTENT_MODIFIED, mtime, ctime);\n\terror = sa_bulk_update(dzp->z_sa_hdl, bulk, count, tx);\n\tASSERT0(error);\n\treturn (0);\n}\n\n \nstatic int\nzfs_dropname(znode_t *dzp, const char *name, znode_t *zp, dmu_tx_t *tx,\n    int flag)\n{\n\tint error;\n\n\tif (zp->z_zfsvfs->z_norm) {\n\t\tmatchtype_t mt = MT_NORMALIZE;\n\n\t\tif (zp->z_zfsvfs->z_case == ZFS_CASE_MIXED) {\n\t\t\tmt |= MT_MATCH_CASE;\n\t\t}\n\n\t\terror = zap_remove_norm(zp->z_zfsvfs->z_os, dzp->z_id,\n\t\t    name, mt, tx);\n\t} else {\n\t\terror = zap_remove(zp->z_zfsvfs->z_os, dzp->z_id, name, tx);\n\t}\n\n\treturn (error);\n}\n\n \nint\nzfs_link_destroy(znode_t *dzp, const char *name, znode_t *zp, dmu_tx_t *tx,\n    int flag, boolean_t *unlinkedp)\n{\n\tzfsvfs_t *zfsvfs = dzp->z_zfsvfs;\n\tvnode_t *vp = ZTOV(zp);\n\tint zp_is_dir = (vp->v_type == VDIR);\n\tboolean_t unlinked = B_FALSE;\n\tsa_bulk_attr_t bulk[5];\n\tuint64_t mtime[2], ctime[2];\n\tint count = 0;\n\tint error;\n\n\tif (zfsvfs->z_replay == B_FALSE) {\n\t\tASSERT_VOP_ELOCKED(ZTOV(dzp), __func__);\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n\t}\n\tif (!(flag & ZRENAMING)) {\n\n\t\tif (zp_is_dir && !zfs_dirempty(zp))\n\t\t\treturn (SET_ERROR(ENOTEMPTY));\n\n\t\t \n\t\terror = zfs_dropname(dzp, name, zp, tx, flag);\n\t\tif (error != 0) {\n\t\t\treturn (error);\n\t\t}\n\n\t\tif (zp->z_links <= zp_is_dir) {\n\t\t\tzfs_panic_recover(\"zfs: link count on vnode %p is %u, \"\n\t\t\t    \"should be at least %u\", zp->z_vnode,\n\t\t\t    (int)zp->z_links,\n\t\t\t    zp_is_dir + 1);\n\t\t\tzp->z_links = zp_is_dir + 1;\n\t\t}\n\t\tif (--zp->z_links == zp_is_dir) {\n\t\t\tzp->z_unlinked = B_TRUE;\n\t\t\tzp->z_links = 0;\n\t\t\tunlinked = B_TRUE;\n\t\t} else {\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs),\n\t\t\t    NULL, &ctime, sizeof (ctime));\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t\t\t    NULL, &zp->z_pflags, sizeof (zp->z_pflags));\n\t\t\tzfs_tstamp_update_setup(zp, STATE_CHANGED, mtime,\n\t\t\t    ctime);\n\t\t}\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs),\n\t\t    NULL, &zp->z_links, sizeof (zp->z_links));\n\t\terror = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\t\tcount = 0;\n\t\tASSERT0(error);\n\t} else {\n\t\tASSERT(!zp->z_unlinked);\n\t\terror = zfs_dropname(dzp, name, zp, tx, flag);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t}\n\n\tdzp->z_size--;\t\t \n\tdzp->z_links -= zp_is_dir;\t \n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_LINKS(zfsvfs),\n\t    NULL, &dzp->z_links, sizeof (dzp->z_links));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_SIZE(zfsvfs),\n\t    NULL, &dzp->z_size, sizeof (dzp->z_size));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs),\n\t    NULL, ctime, sizeof (ctime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs),\n\t    NULL, mtime, sizeof (mtime));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs),\n\t    NULL, &dzp->z_pflags, sizeof (dzp->z_pflags));\n\tzfs_tstamp_update_setup(dzp, CONTENT_MODIFIED, mtime, ctime);\n\terror = sa_bulk_update(dzp->z_sa_hdl, bulk, count, tx);\n\tASSERT0(error);\n\n\tif (unlinkedp != NULL)\n\t\t*unlinkedp = unlinked;\n\telse if (unlinked)\n\t\tzfs_unlinked_add(zp, tx);\n\n\treturn (0);\n}\n\n \nboolean_t\nzfs_dirempty(znode_t *dzp)\n{\n\treturn (dzp->z_size == 2);\n}\n\nint\nzfs_make_xattrdir(znode_t *zp, vattr_t *vap, znode_t **xvpp, cred_t *cr)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tznode_t *xzp;\n\tdmu_tx_t *tx;\n\tint error;\n\tzfs_acl_ids_t acl_ids;\n\tboolean_t fuid_dirtied;\n\tuint64_t parent __maybe_unused;\n\n\t*xvpp = NULL;\n\n\tif ((error = zfs_acl_ids_create(zp, IS_XATTR, vap, cr, NULL,\n\t    &acl_ids, NULL)) != 0)\n\t\treturn (error);\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, 0)) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\tgetnewvnode_reserve_();\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, FALSE, NULL);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tgetnewvnode_drop_reserve();\n\t\treturn (error);\n\t}\n\tzfs_mknode(zp, vap, tx, cr, IS_XATTR, &xzp, &acl_ids);\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tASSERT0(sa_lookup(xzp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs), &parent,\n\t    sizeof (parent)));\n\tASSERT3U(parent, ==, zp->z_id);\n\n\tVERIFY0(sa_update(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs), &xzp->z_id,\n\t    sizeof (xzp->z_id), tx));\n\n\tzfs_log_create(zfsvfs->z_log, tx, TX_MKXATTR, zp, xzp, \"\", NULL,\n\t    acl_ids.z_fuidp, vap);\n\n\tzfs_acl_ids_free(&acl_ids);\n\tdmu_tx_commit(tx);\n\n\tgetnewvnode_drop_reserve();\n\n\t*xvpp = xzp;\n\n\treturn (0);\n}\n\n \nint\nzfs_get_xattrdir(znode_t *zp, znode_t **xzpp, cred_t *cr, int flags)\n{\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tznode_t\t\t*xzp;\n\tvattr_t\t\tva;\n\tint\t\terror;\ntop:\n\terror = zfs_dirent_lookup(zp, \"\", &xzp, ZXATTR);\n\tif (error)\n\t\treturn (error);\n\n\tif (xzp != NULL) {\n\t\t*xzpp = xzp;\n\t\treturn (0);\n\t}\n\n\n\tif (!(flags & CREATE_XATTR_DIR))\n\t\treturn (SET_ERROR(ENOATTR));\n\n\tif (zfsvfs->z_vfs->vfs_flag & VFS_RDONLY) {\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\tva.va_mask = AT_MODE | AT_UID | AT_GID;\n\tva.va_type = VDIR;\n\tva.va_mode = S_IFDIR | S_ISVTX | 0777;\n\tzfs_fuid_map_ids(zp, cr, &va.va_uid, &va.va_gid);\n\n\terror = zfs_make_xattrdir(zp, &va, xzpp, cr);\n\n\tif (error == ERESTART) {\n\t\t \n\t\tgoto top;\n\t}\n\tif (error == 0)\n\t\tVOP_UNLOCK1(ZTOV(*xzpp));\n\n\treturn (error);\n}\n\n \nint\nzfs_sticky_remove_access(znode_t *zdp, znode_t *zp, cred_t *cr)\n{\n\tuid_t  \t\tuid;\n\tuid_t\t\tdowner;\n\tuid_t\t\tfowner;\n\tzfsvfs_t\t*zfsvfs = zdp->z_zfsvfs;\n\n\tif (zdp->z_zfsvfs->z_replay)\n\t\treturn (0);\n\n\tif ((zdp->z_mode & S_ISVTX) == 0)\n\t\treturn (0);\n\n\tdowner = zfs_fuid_map_id(zfsvfs, zdp->z_uid, cr, ZFS_OWNER);\n\tfowner = zfs_fuid_map_id(zfsvfs, zp->z_uid, cr, ZFS_OWNER);\n\n\tif ((uid = crgetuid(cr)) == downer || uid == fowner ||\n\t    (ZTOV(zp)->v_type == VREG &&\n\t    zfs_zaccess(zp, ACE_WRITE_DATA, 0, B_FALSE, cr, NULL) == 0))\n\t\treturn (0);\n\telse\n\t\treturn (secpolicy_vnode_remove(ZTOV(zp), cr));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}