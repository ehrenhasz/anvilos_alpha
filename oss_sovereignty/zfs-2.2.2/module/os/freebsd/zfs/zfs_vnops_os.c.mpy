{
  "module_name": "zfs_vnops_os.c",
  "hash_id": "11447c8881479fa08c60cf22532bb0e6ce2c19180e65ebd5f4bd8d62614ac9f6",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_vnops_os.c",
  "human_readable_source": " \n\n \n\n \n \n\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/systm.h>\n#include <sys/sysmacros.h>\n#include <sys/resource.h>\n#include <security/mac/mac_framework.h>\n#include <sys/vfs.h>\n#include <sys/endian.h>\n#include <sys/vm.h>\n#include <sys/vnode.h>\n#if __FreeBSD_version >= 1300102\n#include <sys/smr.h>\n#endif\n#include <sys/dirent.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/kmem.h>\n#include <sys/taskq.h>\n#include <sys/uio.h>\n#include <sys/atomic.h>\n#include <sys/namei.h>\n#include <sys/mman.h>\n#include <sys/cmn_err.h>\n#include <sys/kdb.h>\n#include <sys/sysproto.h>\n#include <sys/errno.h>\n#include <sys/unistd.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/fs/zfs.h>\n#include <sys/dmu.h>\n#include <sys/dmu_objset.h>\n#include <sys/spa.h>\n#include <sys/txg.h>\n#include <sys/dbuf.h>\n#include <sys/zap.h>\n#include <sys/sa.h>\n#include <sys/policy.h>\n#include <sys/sunddi.h>\n#include <sys/filio.h>\n#include <sys/sid.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_fuid.h>\n#include <sys/zfs_quota.h>\n#include <sys/zfs_sa.h>\n#include <sys/zfs_rlock.h>\n#include <sys/bio.h>\n#include <sys/buf.h>\n#include <sys/sched.h>\n#include <sys/acl.h>\n#include <sys/vmmeter.h>\n#include <vm/vm_param.h>\n#include <sys/zil.h>\n#include <sys/zfs_vnops.h>\n#include <sys/module.h>\n#include <sys/sysent.h>\n#include <sys/dmu_impl.h>\n#include <sys/brt.h>\n#include <sys/zfeature.h>\n\n#include <vm/vm_object.h>\n\n#include <sys/extattr.h>\n#include <sys/priv.h>\n\n#ifndef VN_OPEN_INVFS\n#define\tVN_OPEN_INVFS\t0x0\n#endif\n\nVFS_SMR_DECLARE;\n\n#if __FreeBSD_version < 1300103\n#define\tNDFREE_PNBUF(ndp)\tNDFREE((ndp), NDF_ONLY_PNBUF)\n#endif\n\n#if __FreeBSD_version >= 1300047\n#define\tvm_page_wire_lock(pp)\n#define\tvm_page_wire_unlock(pp)\n#else\n#define\tvm_page_wire_lock(pp) vm_page_lock(pp)\n#define\tvm_page_wire_unlock(pp) vm_page_unlock(pp)\n#endif\n\n#ifdef DEBUG_VFS_LOCKS\n#define\tVNCHECKREF(vp)\t\t\t\t  \\\n\tVNASSERT((vp)->v_holdcnt > 0 && (vp)->v_usecount > 0, vp,\t\\\n\t    (\"%s: wrong ref counts\", __func__));\n#else\n#define\tVNCHECKREF(vp)\n#endif\n\n#if __FreeBSD_version >= 1400045\ntypedef uint64_t cookie_t;\n#else\ntypedef ulong_t cookie_t;\n#endif\n\n \nstatic int\nzfs_open(vnode_t **vpp, int flag, cred_t *cr)\n{\n\t(void) cr;\n\tznode_t\t*zp = VTOZ(*vpp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((flag & FWRITE) && (zp->z_pflags & ZFS_APPENDONLY) &&\n\t    ((flag & FAPPEND) == 0)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\tif (flag & O_SYNC)\n\t\tatomic_inc_32(&zp->z_sync_cnt);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nstatic int\nzfs_close(vnode_t *vp, int flag, int count, offset_t offset, cred_t *cr)\n{\n\t(void) offset, (void) cr;\n\tznode_t\t*zp = VTOZ(vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\t \n\tif ((flag & O_SYNC) && (count == 1))\n\t\tatomic_dec_32(&zp->z_sync_cnt);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nstatic int\nzfs_ioctl(vnode_t *vp, ulong_t com, intptr_t data, int flag, cred_t *cred,\n    int *rvalp)\n{\n\t(void) flag, (void) cred, (void) rvalp;\n\tloff_t off;\n\tint error;\n\n\tswitch (com) {\n\tcase _FIOFFS:\n\t{\n\t\treturn (0);\n\n\t\t \n\t}\n\tcase _FIOGDIO:\n\tcase _FIOSDIO:\n\t{\n\t\treturn (0);\n\t}\n\n\tcase F_SEEK_DATA:\n\tcase F_SEEK_HOLE:\n\t{\n\t\toff = *(offset_t *)data;\n\t\t \n\t\terror = zfs_holey(VTOZ(vp), com, &off);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*(offset_t *)data = off;\n\t\treturn (0);\n\t}\n\t}\n\treturn (SET_ERROR(ENOTTY));\n}\n\nstatic vm_page_t\npage_busy(vnode_t *vp, int64_t start, int64_t off, int64_t nbytes)\n{\n\tvm_object_t obj;\n\tvm_page_t pp;\n\tint64_t end;\n\n\t \n\tend = rounddown2(off + nbytes, DEV_BSIZE);\n\toff = roundup2(off, DEV_BSIZE);\n\tnbytes = end - off;\n\n\tobj = vp->v_object;\n\tzfs_vmobject_assert_wlocked_12(obj);\n#if __FreeBSD_version < 1300050\n\tfor (;;) {\n\t\tif ((pp = vm_page_lookup(obj, OFF_TO_IDX(start))) != NULL &&\n\t\t    pp->valid) {\n\t\t\tif (vm_page_xbusied(pp)) {\n\t\t\t\t \n\t\t\t\tvm_page_reference(pp);\n\t\t\t\tvm_page_lock(pp);\n\t\t\t\tzfs_vmobject_wunlock(obj);\n\t\t\t\tvm_page_busy_sleep(pp, \"zfsmwb\", true);\n\t\t\t\tzfs_vmobject_wlock(obj);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvm_page_sbusy(pp);\n\t\t} else if (pp != NULL) {\n\t\t\tASSERT(!pp->valid);\n\t\t\tpp = NULL;\n\t\t}\n\t\tif (pp != NULL) {\n\t\t\tASSERT3U(pp->valid, ==, VM_PAGE_BITS_ALL);\n\t\t\tvm_object_pip_add(obj, 1);\n\t\t\tpmap_remove_write(pp);\n\t\t\tif (nbytes != 0)\n\t\t\t\tvm_page_clear_dirty(pp, off, nbytes);\n\t\t}\n\t\tbreak;\n\t}\n#else\n\tvm_page_grab_valid_unlocked(&pp, obj, OFF_TO_IDX(start),\n\t    VM_ALLOC_NOCREAT | VM_ALLOC_SBUSY | VM_ALLOC_NORMAL |\n\t    VM_ALLOC_IGN_SBUSY);\n\tif (pp != NULL) {\n\t\tASSERT3U(pp->valid, ==, VM_PAGE_BITS_ALL);\n\t\tvm_object_pip_add(obj, 1);\n\t\tpmap_remove_write(pp);\n\t\tif (nbytes != 0)\n\t\t\tvm_page_clear_dirty(pp, off, nbytes);\n\t}\n#endif\n\treturn (pp);\n}\n\nstatic void\npage_unbusy(vm_page_t pp)\n{\n\n\tvm_page_sunbusy(pp);\n#if __FreeBSD_version >= 1300041\n\tvm_object_pip_wakeup(pp->object);\n#else\n\tvm_object_pip_subtract(pp->object, 1);\n#endif\n}\n\n#if __FreeBSD_version > 1300051\nstatic vm_page_t\npage_hold(vnode_t *vp, int64_t start)\n{\n\tvm_object_t obj;\n\tvm_page_t m;\n\n\tobj = vp->v_object;\n\tvm_page_grab_valid_unlocked(&m, obj, OFF_TO_IDX(start),\n\t    VM_ALLOC_NOCREAT | VM_ALLOC_WIRED | VM_ALLOC_IGN_SBUSY |\n\t    VM_ALLOC_NOBUSY);\n\treturn (m);\n}\n#else\nstatic vm_page_t\npage_hold(vnode_t *vp, int64_t start)\n{\n\tvm_object_t obj;\n\tvm_page_t pp;\n\n\tobj = vp->v_object;\n\tzfs_vmobject_assert_wlocked(obj);\n\n\tfor (;;) {\n\t\tif ((pp = vm_page_lookup(obj, OFF_TO_IDX(start))) != NULL &&\n\t\t    pp->valid) {\n\t\t\tif (vm_page_xbusied(pp)) {\n\t\t\t\t \n\t\t\t\tvm_page_reference(pp);\n\t\t\t\tvm_page_lock(pp);\n\t\t\t\tzfs_vmobject_wunlock(obj);\n\t\t\t\tvm_page_busy_sleep(pp, \"zfsmwb\", true);\n\t\t\t\tzfs_vmobject_wlock(obj);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tASSERT3U(pp->valid, ==, VM_PAGE_BITS_ALL);\n\t\t\tvm_page_wire_lock(pp);\n\t\t\tvm_page_hold(pp);\n\t\t\tvm_page_wire_unlock(pp);\n\n\t\t} else\n\t\t\tpp = NULL;\n\t\tbreak;\n\t}\n\treturn (pp);\n}\n#endif\n\nstatic void\npage_unhold(vm_page_t pp)\n{\n\n\tvm_page_wire_lock(pp);\n#if __FreeBSD_version >= 1300035\n\tvm_page_unwire(pp, PQ_ACTIVE);\n#else\n\tvm_page_unhold(pp);\n#endif\n\tvm_page_wire_unlock(pp);\n}\n\n \nvoid\nupdate_pages(znode_t *zp, int64_t start, int len, objset_t *os)\n{\n\tvm_object_t obj;\n\tstruct sf_buf *sf;\n\tvnode_t *vp = ZTOV(zp);\n\tcaddr_t va;\n\tint off;\n\n\tASSERT3P(vp->v_mount, !=, NULL);\n\tobj = vp->v_object;\n\tASSERT3P(obj, !=, NULL);\n\n\toff = start & PAGEOFFSET;\n\tzfs_vmobject_wlock_12(obj);\n#if __FreeBSD_version >= 1300041\n\tvm_object_pip_add(obj, 1);\n#endif\n\tfor (start &= PAGEMASK; len > 0; start += PAGESIZE) {\n\t\tvm_page_t pp;\n\t\tint nbytes = imin(PAGESIZE - off, len);\n\n\t\tif ((pp = page_busy(vp, start, off, nbytes)) != NULL) {\n\t\t\tzfs_vmobject_wunlock_12(obj);\n\n\t\t\tva = zfs_map_page(pp, &sf);\n\t\t\t(void) dmu_read(os, zp->z_id, start + off, nbytes,\n\t\t\t    va + off, DMU_READ_PREFETCH);\n\t\t\tzfs_unmap_page(sf);\n\n\t\t\tzfs_vmobject_wlock_12(obj);\n\t\t\tpage_unbusy(pp);\n\t\t}\n\t\tlen -= nbytes;\n\t\toff = 0;\n\t}\n#if __FreeBSD_version >= 1300041\n\tvm_object_pip_wakeup(obj);\n#else\n\tvm_object_pip_wakeupn(obj, 0);\n#endif\n\tzfs_vmobject_wunlock_12(obj);\n}\n\n \nint\nmappedread_sf(znode_t *zp, int nbytes, zfs_uio_t *uio)\n{\n\tvnode_t *vp = ZTOV(zp);\n\tobjset_t *os = zp->z_zfsvfs->z_os;\n\tstruct sf_buf *sf;\n\tvm_object_t obj;\n\tvm_page_t pp;\n\tint64_t start;\n\tcaddr_t va;\n\tint len = nbytes;\n\tint error = 0;\n\n\tASSERT3U(zfs_uio_segflg(uio), ==, UIO_NOCOPY);\n\tASSERT3P(vp->v_mount, !=, NULL);\n\tobj = vp->v_object;\n\tASSERT3P(obj, !=, NULL);\n\tASSERT0(zfs_uio_offset(uio) & PAGEOFFSET);\n\n\tzfs_vmobject_wlock_12(obj);\n\tfor (start = zfs_uio_offset(uio); len > 0; start += PAGESIZE) {\n\t\tint bytes = MIN(PAGESIZE, len);\n\n\t\tpp = vm_page_grab_unlocked(obj, OFF_TO_IDX(start),\n\t\t    VM_ALLOC_SBUSY | VM_ALLOC_NORMAL | VM_ALLOC_IGN_SBUSY);\n\t\tif (vm_page_none_valid(pp)) {\n\t\t\tzfs_vmobject_wunlock_12(obj);\n\t\t\tva = zfs_map_page(pp, &sf);\n\t\t\terror = dmu_read(os, zp->z_id, start, bytes, va,\n\t\t\t    DMU_READ_PREFETCH);\n\t\t\tif (bytes != PAGESIZE && error == 0)\n\t\t\t\tmemset(va + bytes, 0, PAGESIZE - bytes);\n\t\t\tzfs_unmap_page(sf);\n\t\t\tzfs_vmobject_wlock_12(obj);\n#if  __FreeBSD_version >= 1300081\n\t\t\tif (error == 0) {\n\t\t\t\tvm_page_valid(pp);\n\t\t\t\tvm_page_activate(pp);\n\t\t\t\tvm_page_do_sunbusy(pp);\n\t\t\t} else {\n\t\t\t\tzfs_vmobject_wlock(obj);\n\t\t\t\tif (!vm_page_wired(pp) && pp->valid == 0 &&\n\t\t\t\t    vm_page_busy_tryupgrade(pp))\n\t\t\t\t\tvm_page_free(pp);\n\t\t\t\telse\n\t\t\t\t\tvm_page_sunbusy(pp);\n\t\t\t\tzfs_vmobject_wunlock(obj);\n\t\t\t}\n#else\n\t\t\tvm_page_do_sunbusy(pp);\n\t\t\tvm_page_lock(pp);\n\t\t\tif (error) {\n\t\t\t\tif (pp->wire_count == 0 && pp->valid == 0 &&\n\t\t\t\t    !vm_page_busied(pp))\n\t\t\t\t\tvm_page_free(pp);\n\t\t\t} else {\n\t\t\t\tpp->valid = VM_PAGE_BITS_ALL;\n\t\t\t\tvm_page_activate(pp);\n\t\t\t}\n\t\t\tvm_page_unlock(pp);\n#endif\n\t\t} else {\n\t\t\tASSERT3U(pp->valid, ==, VM_PAGE_BITS_ALL);\n\t\t\tvm_page_do_sunbusy(pp);\n\t\t}\n\t\tif (error)\n\t\t\tbreak;\n\t\tzfs_uio_advance(uio, bytes);\n\t\tlen -= bytes;\n\t}\n\tzfs_vmobject_wunlock_12(obj);\n\treturn (error);\n}\n\n \nint\nmappedread(znode_t *zp, int nbytes, zfs_uio_t *uio)\n{\n\tvnode_t *vp = ZTOV(zp);\n\tvm_object_t obj;\n\tint64_t start;\n\tint len = nbytes;\n\tint off;\n\tint error = 0;\n\n\tASSERT3P(vp->v_mount, !=, NULL);\n\tobj = vp->v_object;\n\tASSERT3P(obj, !=, NULL);\n\n\tstart = zfs_uio_offset(uio);\n\toff = start & PAGEOFFSET;\n\tzfs_vmobject_wlock_12(obj);\n\tfor (start &= PAGEMASK; len > 0; start += PAGESIZE) {\n\t\tvm_page_t pp;\n\t\tuint64_t bytes = MIN(PAGESIZE - off, len);\n\n\t\tif ((pp = page_hold(vp, start))) {\n\t\t\tstruct sf_buf *sf;\n\t\t\tcaddr_t va;\n\n\t\t\tzfs_vmobject_wunlock_12(obj);\n\t\t\tva = zfs_map_page(pp, &sf);\n\t\t\terror = vn_io_fault_uiomove(va + off, bytes,\n\t\t\t    GET_UIO_STRUCT(uio));\n\t\t\tzfs_unmap_page(sf);\n\t\t\tzfs_vmobject_wlock_12(obj);\n\t\t\tpage_unhold(pp);\n\t\t} else {\n\t\t\tzfs_vmobject_wunlock_12(obj);\n\t\t\terror = dmu_read_uio_dbuf(sa_get_db(zp->z_sa_hdl),\n\t\t\t    uio, bytes);\n\t\t\tzfs_vmobject_wlock_12(obj);\n\t\t}\n\t\tlen -= bytes;\n\t\toff = 0;\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tzfs_vmobject_wunlock_12(obj);\n\treturn (error);\n}\n\nint\nzfs_write_simple(znode_t *zp, const void *data, size_t len,\n    loff_t pos, size_t *presid)\n{\n\tint error = 0;\n\tssize_t resid;\n\n\terror = vn_rdwr(UIO_WRITE, ZTOV(zp), __DECONST(void *, data), len, pos,\n\t    UIO_SYSSPACE, IO_SYNC, kcred, NOCRED, &resid, curthread);\n\n\tif (error) {\n\t\treturn (SET_ERROR(error));\n\t} else if (presid == NULL) {\n\t\tif (resid != 0) {\n\t\t\terror = SET_ERROR(EIO);\n\t\t}\n\t} else {\n\t\t*presid = resid;\n\t}\n\treturn (error);\n}\n\nvoid\nzfs_zrele_async(znode_t *zp)\n{\n\tvnode_t *vp = ZTOV(zp);\n\tobjset_t *os = ITOZSB(vp)->z_os;\n\n\tVN_RELE_ASYNC(vp, dsl_pool_zrele_taskq(dmu_objset_pool(os)));\n}\n\nstatic int\nzfs_dd_callback(struct mount *mp, void *arg, int lkflags, struct vnode **vpp)\n{\n\tint error;\n\n\t*vpp = arg;\n\terror = vn_lock(*vpp, lkflags);\n\tif (error != 0)\n\t\tvrele(*vpp);\n\treturn (error);\n}\n\nstatic int\nzfs_lookup_lock(vnode_t *dvp, vnode_t *vp, const char *name, int lkflags)\n{\n\tznode_t *zdp = VTOZ(dvp);\n\tzfsvfs_t *zfsvfs __unused = zdp->z_zfsvfs;\n\tint error;\n\tint ltype;\n\n\tif (zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(dvp, __func__);\n\n\tif (name[0] == 0 || (name[0] == '.' && name[1] == 0)) {\n\t\tASSERT3P(dvp, ==, vp);\n\t\tvref(dvp);\n\t\tltype = lkflags & LK_TYPE_MASK;\n\t\tif (ltype != VOP_ISLOCKED(dvp)) {\n\t\t\tif (ltype == LK_EXCLUSIVE)\n\t\t\t\tvn_lock(dvp, LK_UPGRADE | LK_RETRY);\n\t\t\telse  \n\t\t\t\tvn_lock(dvp, LK_DOWNGRADE | LK_RETRY);\n\n\t\t\t \n\t\t\tif (VN_IS_DOOMED(dvp)) {\n\t\t\t\tvrele(dvp);\n\t\t\t\treturn (SET_ERROR(ENOENT));\n\t\t\t}\n\t\t}\n\t\treturn (0);\n\t} else if (name[0] == '.' && name[1] == '.' && name[2] == 0) {\n\t\t \n\t\terror = vn_vget_ino_gen(dvp, zfs_dd_callback, vp, lkflags, &vp);\n\t\treturn (error);\n\t} else {\n\t\terror = vn_lock(vp, lkflags);\n\t\tif (error != 0)\n\t\t\tvrele(vp);\n\t\treturn (error);\n\t}\n}\n\n \nstatic int\nzfs_lookup(vnode_t *dvp, const char *nm, vnode_t **vpp,\n    struct componentname *cnp, int nameiop, cred_t *cr, int flags,\n    boolean_t cached)\n{\n\tznode_t *zdp = VTOZ(dvp);\n\tznode_t *zp;\n\tzfsvfs_t *zfsvfs = zdp->z_zfsvfs;\n#if\t__FreeBSD_version > 1300124\n\tseqc_t dvp_seqc;\n#endif\n\tint\terror = 0;\n\n\t \n\tif (!(flags & LOOKUP_XATTR)) {\n\t\tif (dvp->v_type != VDIR) {\n\t\t\treturn (SET_ERROR(ENOTDIR));\n\t\t} else if (zdp->z_sa_hdl == NULL) {\n\t\t\treturn (SET_ERROR(EIO));\n\t\t}\n\t}\n\n\tDTRACE_PROBE2(zfs__fastpath__lookup__miss, vnode_t *, dvp,\n\t    const char *, nm);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zdp, FTAG)) != 0)\n\t\treturn (error);\n\n#if\t__FreeBSD_version > 1300124\n\tdvp_seqc = vn_seqc_read_notmodify(dvp);\n#endif\n\n\t*vpp = NULL;\n\n\tif (flags & LOOKUP_XATTR) {\n\t\t \n\t\tif (!(zfsvfs->z_flags & ZSB_XATTR)) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t\t}\n\n\t\t \n\t\tif (zdp->z_pflags & ZFS_XATTR) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\t}\n\n\t\tif ((error = zfs_get_xattrdir(VTOZ(dvp), &zp, cr, flags))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t\t*vpp = ZTOV(zp);\n\n\t\t \n\t\terror = zfs_zaccess(zp, ACE_EXECUTE, 0, B_FALSE, cr, NULL);\n\t\tif (error) {\n\t\t\tvrele(ZTOV(zp));\n\t\t}\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (!cached) {\n#ifdef NOEXECCHECK\n\t\tif ((cnp->cn_flags & NOEXECCHECK) != 0) {\n\t\t\tcnp->cn_flags &= ~NOEXECCHECK;\n\t\t} else\n#endif\n\t\tif ((error = zfs_zaccess(zdp, ACE_EXECUTE, 0, B_FALSE, cr,\n\t\t    NULL))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(nm, strlen(nm),\n\t    NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\n\t \n\tif ((cnp->cn_flags & ISDOTDOT) != 0) {\n\t\t \n\t\tif (zdp->z_id == zfsvfs->z_root && zfsvfs->z_parent != zfsvfs) {\n\t\t\tstruct componentname cn;\n\t\t\tvnode_t *zfsctl_vp;\n\t\t\tint ltype;\n\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\tltype = VOP_ISLOCKED(dvp);\n\t\t\tVOP_UNLOCK1(dvp);\n\t\t\terror = zfsctl_root(zfsvfs->z_parent, LK_SHARED,\n\t\t\t    &zfsctl_vp);\n\t\t\tif (error == 0) {\n\t\t\t\tcn.cn_nameptr = \"snapshot\";\n\t\t\t\tcn.cn_namelen = strlen(cn.cn_nameptr);\n\t\t\t\tcn.cn_nameiop = cnp->cn_nameiop;\n\t\t\t\tcn.cn_flags = cnp->cn_flags & ~ISDOTDOT;\n\t\t\t\tcn.cn_lkflags = cnp->cn_lkflags;\n\t\t\t\terror = VOP_LOOKUP(zfsctl_vp, vpp, &cn);\n\t\t\t\tvput(zfsctl_vp);\n\t\t\t}\n\t\t\tvn_lock(dvp, ltype | LK_RETRY);\n\t\t\treturn (error);\n\t\t}\n\t}\n\tif (zfs_has_ctldir(zdp) && strcmp(nm, ZFS_CTLDIR_NAME) == 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\tif ((cnp->cn_flags & ISLASTCN) != 0 && nameiop != LOOKUP)\n\t\t\treturn (SET_ERROR(ENOTSUP));\n\t\terror = zfsctl_root(zfsvfs, cnp->cn_lkflags, vpp);\n\t\treturn (error);\n\t}\n\n\t \n\tfor (;;) {\n\t\tuint64_t parent;\n\n\t\terror = zfs_dirlook(zdp, nm, &zp);\n\t\tif (error == 0)\n\t\t\t*vpp = ZTOV(zp);\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\terror = zfs_lookup_lock(dvp, *vpp, nm, cnp->cn_lkflags);\n\t\tif (error != 0) {\n\t\t\t \n\t\t\t*vpp = NULL;\n\t\t\treturn (error);\n\t\t}\n\n\t\tif ((cnp->cn_flags & ISDOTDOT) == 0)\n\t\t\tbreak;\n\n\t\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0) {\n\t\t\tvput(ZTOV(zp));\n\t\t\t*vpp = NULL;\n\t\t\treturn (error);\n\t\t}\n\t\tif (zdp->z_sa_hdl == NULL) {\n\t\t\terror = SET_ERROR(EIO);\n\t\t} else {\n\t\t\terror = sa_lookup(zdp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs),\n\t\t\t    &parent, sizeof (parent));\n\t\t}\n\t\tif (error != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\tvput(ZTOV(zp));\n\t\t\tbreak;\n\t\t}\n\t\tif (zp->z_id == parent) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\tbreak;\n\t\t}\n\t\tvput(ZTOV(zp));\n\t}\n\n\tif (error != 0)\n\t\t*vpp = NULL;\n\n\t \n\tif (cnp->cn_flags & ISLASTCN) {\n\t\tswitch (nameiop) {\n\t\tcase CREATE:\n\t\tcase RENAME:\n\t\t\tif (error == ENOENT) {\n\t\t\t\terror = EJUSTRETURN;\n#if __FreeBSD_version < 1400068\n\t\t\t\tcnp->cn_flags |= SAVENAME;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tzfs_fallthrough;\n\t\tcase DELETE:\n#if __FreeBSD_version < 1400068\n\t\t\tif (error == 0)\n\t\t\t\tcnp->cn_flags |= SAVENAME;\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if\t__FreeBSD_version > 1300124\n\tif ((cnp->cn_flags & ISDOTDOT) != 0) {\n\t\t \n\t\tif (!vn_seqc_consistent(dvp, dvp_seqc)) {\n\t\t\tcnp->cn_flags &= ~MAKEENTRY;\n\t\t}\n\t}\n#endif\n\n\t \n\tif (zfsvfs->z_use_namecache && !zfsvfs->z_replay &&\n\t    error == ENOENT && (cnp->cn_flags & MAKEENTRY) != 0)\n\t\tcache_enter(dvp, NULL, cnp);\n\n\t \n\tif (zfsvfs->z_use_namecache && !zfsvfs->z_replay &&\n\t    error == 0 && (cnp->cn_flags & MAKEENTRY)) {\n\t\tif (!(cnp->cn_flags & ISLASTCN) ||\n\t\t    (nameiop != DELETE && nameiop != RENAME)) {\n\t\t\tcache_enter(dvp, *vpp, cnp);\n\t\t}\n\t}\n\n\treturn (error);\n}\n\n \nint\nzfs_create(znode_t *dzp, const char *name, vattr_t *vap, int excl, int mode,\n    znode_t **zpp, cred_t *cr, int flag, vsecattr_t *vsecp, zidmap_t *mnt_ns)\n{\n\t(void) excl, (void) mode, (void) flag;\n\tznode_t\t\t*zp;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tzilog_t\t\t*zilog;\n\tobjset_t\t*os;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tuid_t\t\tuid = crgetuid(cr);\n\tgid_t\t\tgid = crgetgid(cr);\n\tuint64_t\tprojid = ZFS_DEFAULT_PROJID;\n\tzfs_acl_ids_t   acl_ids;\n\tboolean_t\tfuid_dirtied;\n\tuint64_t\ttxtype;\n#ifdef DEBUG_VFS_LOCKS\n\tvnode_t\t*dvp = ZTOV(dzp);\n#endif\n\n\t \n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    (vsecp || (vap->va_mask & AT_XVATTR) ||\n\t    IS_EPHEMERAL(uid) || IS_EPHEMERAL(gid)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tos = zfsvfs->z_os;\n\tzilog = zfsvfs->z_log;\n\n\tif (zfsvfs->z_utf8 && u8_validate(name, strlen(name),\n\t    NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\tif (vap->va_mask & AT_XVATTR) {\n\t\tif ((error = secpolicy_xvattr(ZTOV(dzp), (xvattr_t *)vap,\n\t\t    crgetuid(cr), cr, vap->va_type)) != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t*zpp = NULL;\n\n\tif ((vap->va_mode & S_ISVTX) && secpolicy_vnode_stky_modify(cr))\n\t\tvap->va_mode &= ~S_ISVTX;\n\n\terror = zfs_dirent_lookup(dzp, name, &zp, ZNEW);\n\tif (error) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tASSERT3P(zp, ==, NULL);\n\n\t \n\tif ((error = zfs_zaccess(dzp, ACE_ADD_FILE, 0, B_FALSE, cr, mnt_ns))) {\n\t\tgoto out;\n\t}\n\n\t \n\n\tif ((dzp->z_pflags & ZFS_XATTR) &&\n\t    (vap->va_type != VREG)) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\n\tif ((error = zfs_acl_ids_create(dzp, 0, vap,\n\t    cr, vsecp, &acl_ids, NULL)) != 0)\n\t\tgoto out;\n\n\tif (S_ISREG(vap->va_mode) || S_ISDIR(vap->va_mode))\n\t\tprojid = zfs_inherit_projid(dzp);\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, projid)) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\terror = SET_ERROR(EDQUOT);\n\t\tgoto out;\n\t}\n\n\tgetnewvnode_reserve_();\n\n\ttx = dmu_tx_create(os);\n\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE);\n\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\tdmu_tx_hold_zap(tx, dzp->z_id, TRUE, name);\n\tdmu_tx_hold_sa(tx, dzp->z_sa_hdl, B_FALSE);\n\tif (!zfsvfs->z_use_sa &&\n\t    acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t    0, acl_ids.z_aclp->z_acl_bytes);\n\t}\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tgetnewvnode_drop_reserve();\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tzfs_mknode(dzp, vap, tx, cr, 0, &zp, &acl_ids);\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\t(void) zfs_link_create(dzp, name, zp, tx, ZNEW);\n\ttxtype = zfs_log_create_txtype(Z_FILE, vsecp, vap);\n\tzfs_log_create(zilog, tx, txtype, dzp, zp, name,\n\t    vsecp, acl_ids.z_fuidp, vap);\n\tzfs_acl_ids_free(&acl_ids);\n\tdmu_tx_commit(tx);\n\n\tgetnewvnode_drop_reserve();\n\nout:\n\tVNCHECKREF(dvp);\n\tif (error == 0) {\n\t\t*zpp = zp;\n\t}\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_remove_(vnode_t *dvp, vnode_t *vp, const char *name, cred_t *cr)\n{\n\tznode_t\t\t*dzp = VTOZ(dvp);\n\tznode_t\t\t*zp;\n\tznode_t\t\t*xzp;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tzilog_t\t\t*zilog;\n\tuint64_t\txattr_obj;\n\tuint64_t\tobj = 0;\n\tdmu_tx_t\t*tx;\n\tboolean_t\tunlinked;\n\tuint64_t\ttxtype;\n\tint\t\terror;\n\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzp = VTOZ(vp);\n\tif ((error = zfs_verify_zp(zp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tzilog = zfsvfs->z_log;\n\n\txattr_obj = 0;\n\txzp = NULL;\n\n\tif ((error = zfs_zaccess_delete(dzp, zp, cr, NULL))) {\n\t\tgoto out;\n\t}\n\n\t \n\tif (vp->v_type == VDIR) {\n\t\terror = SET_ERROR(EPERM);\n\t\tgoto out;\n\t}\n\n\tvnevent_remove(vp, dvp, name, ct);\n\n\tobj = zp->z_id;\n\n\t \n\terror = sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t    &xattr_obj, sizeof (xattr_obj));\n\tif (error == 0 && xattr_obj) {\n\t\terror = zfs_zget(zfsvfs, xattr_obj, &xzp);\n\t\tASSERT0(error);\n\t}\n\n\t \n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, dzp->z_id, FALSE, name);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tzfs_sa_upgrade_txholds(tx, dzp);\n\n\tif (xzp) {\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t\tdmu_tx_hold_sa(tx, xzp->z_sa_hdl, B_FALSE);\n\t}\n\n\t \n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\n\t \n\tdmu_tx_mark_netfree(tx);\n\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = zfs_link_destroy(dzp, name, zp, tx, ZEXISTS, &unlinked);\n\n\tif (error) {\n\t\tdmu_tx_commit(tx);\n\t\tgoto out;\n\t}\n\n\tif (unlinked) {\n\t\tzfs_unlinked_add(zp, tx);\n\t\tvp->v_vflag |= VV_NOSYNC;\n\t}\n\t \n\ttxtype = TX_REMOVE;\n\tzfs_log_remove(zilog, tx, txtype, dzp, name, obj, unlinked);\n\n\tdmu_tx_commit(tx);\nout:\n\n\tif (xzp)\n\t\tvrele(ZTOV(xzp));\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n\nstatic int\nzfs_lookup_internal(znode_t *dzp, const char *name, vnode_t **vpp,\n    struct componentname *cnp, int nameiop)\n{\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tint error;\n\n\tcnp->cn_nameptr = __DECONST(char *, name);\n\tcnp->cn_namelen = strlen(name);\n\tcnp->cn_nameiop = nameiop;\n\tcnp->cn_flags = ISLASTCN;\n#if __FreeBSD_version < 1400068\n\tcnp->cn_flags |= SAVENAME;\n#endif\n\tcnp->cn_lkflags = LK_EXCLUSIVE | LK_RETRY;\n\tcnp->cn_cred = kcred;\n#if __FreeBSD_version < 1400037\n\tcnp->cn_thread = curthread;\n#endif\n\n\tif (zfsvfs->z_use_namecache && !zfsvfs->z_replay) {\n\t\tstruct vop_lookup_args a;\n\n\t\ta.a_gen.a_desc = &vop_lookup_desc;\n\t\ta.a_dvp = ZTOV(dzp);\n\t\ta.a_vpp = vpp;\n\t\ta.a_cnp = cnp;\n\t\terror = vfs_cache_lookup(&a);\n\t} else {\n\t\terror = zfs_lookup(ZTOV(dzp), name, vpp, cnp, nameiop, kcred, 0,\n\t\t    B_FALSE);\n\t}\n#ifdef ZFS_DEBUG\n\tif (error) {\n\t\tprintf(\"got error %d on name %s on op %d\\n\", error, name,\n\t\t    nameiop);\n\t\tkdb_backtrace();\n\t}\n#endif\n\treturn (error);\n}\n\nint\nzfs_remove(znode_t *dzp, const char *name, cred_t *cr, int flags)\n{\n\tvnode_t *vp;\n\tint error;\n\tstruct componentname cn;\n\n\tif ((error = zfs_lookup_internal(dzp, name, &vp, &cn, DELETE)))\n\t\treturn (error);\n\n\terror = zfs_remove_(ZTOV(dzp), vp, name, cr);\n\tvput(vp);\n\treturn (error);\n}\n \nint\nzfs_mkdir(znode_t *dzp, const char *dirname, vattr_t *vap, znode_t **zpp,\n    cred_t *cr, int flags, vsecattr_t *vsecp, zidmap_t *mnt_ns)\n{\n\t(void) flags, (void) vsecp;\n\tznode_t\t\t*zp;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tzilog_t\t\t*zilog;\n\tuint64_t\ttxtype;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tuid_t\t\tuid = crgetuid(cr);\n\tgid_t\t\tgid = crgetgid(cr);\n\tzfs_acl_ids_t   acl_ids;\n\tboolean_t\tfuid_dirtied;\n\n\tASSERT3U(vap->va_type, ==, VDIR);\n\n\t \n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    ((vap->va_mask & AT_XVATTR) ||\n\t    IS_EPHEMERAL(uid) || IS_EPHEMERAL(gid)))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif (dzp->z_pflags & ZFS_XATTR) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(dirname,\n\t    strlen(dirname), NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\tif (vap->va_mask & AT_XVATTR) {\n\t\tif ((error = secpolicy_xvattr(ZTOV(dzp), (xvattr_t *)vap,\n\t\t    crgetuid(cr), cr, vap->va_type)) != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\tif ((error = zfs_acl_ids_create(dzp, 0, vap, cr,\n\t    NULL, &acl_ids, NULL)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\t*zpp = NULL;\n\n\tif ((error = zfs_dirent_lookup(dzp, dirname, &zp, ZNEW))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tASSERT3P(zp, ==, NULL);\n\n\tif ((error = zfs_zaccess(dzp, ACE_ADD_SUBDIRECTORY, 0, B_FALSE, cr,\n\t    mnt_ns))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids, zfs_inherit_projid(dzp))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\t \n\tgetnewvnode_reserve_();\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, dzp->z_id, TRUE, dirname);\n\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, FALSE, NULL);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\tif (!zfsvfs->z_use_sa && acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,\n\t\t    acl_ids.z_aclp->z_acl_bytes);\n\t}\n\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE);\n\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tgetnewvnode_drop_reserve();\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tzfs_mknode(dzp, vap, tx, cr, 0, &zp, &acl_ids);\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\t \n\t(void) zfs_link_create(dzp, dirname, zp, tx, ZNEW);\n\n\t*zpp = zp;\n\n\ttxtype = zfs_log_create_txtype(Z_DIR, NULL, vap);\n\tzfs_log_create(zilog, tx, txtype, dzp, zp, dirname, NULL,\n\t    acl_ids.z_fuidp, vap);\n\n\tzfs_acl_ids_free(&acl_ids);\n\n\tdmu_tx_commit(tx);\n\n\tgetnewvnode_drop_reserve();\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n#if\t__FreeBSD_version < 1300124\nstatic void\ncache_vop_rmdir(struct vnode *dvp, struct vnode *vp)\n{\n\n\tcache_purge(dvp);\n\tcache_purge(vp);\n}\n#endif\n\n \nstatic int\nzfs_rmdir_(vnode_t *dvp, vnode_t *vp, const char *name, cred_t *cr)\n{\n\tznode_t\t\t*dzp = VTOZ(dvp);\n\tznode_t\t\t*zp = VTOZ(vp);\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tzilog_t\t\t*zilog;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tif ((error = zfs_verify_zp(zp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tzilog = zfsvfs->z_log;\n\n\n\tif ((error = zfs_zaccess_delete(dzp, zp, cr, NULL))) {\n\t\tgoto out;\n\t}\n\n\tif (vp->v_type != VDIR) {\n\t\terror = SET_ERROR(ENOTDIR);\n\t\tgoto out;\n\t}\n\n\tvnevent_rmdir(vp, dvp, name, ct);\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_zap(tx, dzp->z_id, FALSE, name);\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\tzfs_sa_upgrade_txholds(tx, dzp);\n\tdmu_tx_mark_netfree(tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = zfs_link_destroy(dzp, name, zp, tx, ZEXISTS, NULL);\n\n\tif (error == 0) {\n\t\tuint64_t txtype = TX_RMDIR;\n\t\tzfs_log_remove(zilog, tx, txtype, dzp, name,\n\t\t    ZFS_NO_OBJECT, B_FALSE);\n\t}\n\n\tdmu_tx_commit(tx);\n\n\tif (zfsvfs->z_use_namecache)\n\t\tcache_vop_rmdir(dvp, vp);\nout:\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nint\nzfs_rmdir(znode_t *dzp, const char *name, znode_t *cwd, cred_t *cr, int flags)\n{\n\tstruct componentname cn;\n\tvnode_t *vp;\n\tint error;\n\n\tif ((error = zfs_lookup_internal(dzp, name, &vp, &cn, DELETE)))\n\t\treturn (error);\n\n\terror = zfs_rmdir_(ZTOV(dzp), vp, name, cr);\n\tvput(vp);\n\treturn (error);\n}\n\n \nstatic int\nzfs_readdir(vnode_t *vp, zfs_uio_t *uio, cred_t *cr, int *eofp,\n    int *ncookies, cookie_t **cookies)\n{\n\tznode_t\t\t*zp = VTOZ(vp);\n\tiovec_t\t\t*iovp;\n\tdirent64_t\t*odp;\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tobjset_t\t*os;\n\tcaddr_t\t\toutbuf;\n\tsize_t\t\tbufsize;\n\tzap_cursor_t\tzc;\n\tzap_attribute_t\tzap;\n\tuint_t\t\tbytes_wanted;\n\tuint64_t\toffset;  \n\tuint64_t\tparent;\n\tint\t\tlocal_eof;\n\tint\t\toutcount;\n\tint\t\terror;\n\tuint8_t\t\tprefetch;\n\tuint8_t\t\ttype;\n\tint\t\tncooks;\n\tcookie_t\t*cooks = NULL;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs),\n\t    &parent, sizeof (parent))) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (eofp == NULL)\n\t\teofp = &local_eof;\n\n\t \n\tif (GET_UIO_STRUCT(uio)->uio_iov->iov_len <= 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif ((*eofp = zp->z_unlinked) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\terror = 0;\n\tos = zfsvfs->z_os;\n\toffset = zfs_uio_offset(uio);\n\tprefetch = zp->z_zn_prefetch;\n\n\t \n\tif (offset <= 3) {\n\t\t \n\t\tzap_cursor_init(&zc, os, zp->z_id);\n\t} else {\n\t\t \n\t\tzap_cursor_init_serialized(&zc, os, zp->z_id, offset);\n\t}\n\n\t \n\tiovp = GET_UIO_STRUCT(uio)->uio_iov;\n\tbytes_wanted = iovp->iov_len;\n\tif (zfs_uio_segflg(uio) != UIO_SYSSPACE || zfs_uio_iovcnt(uio) != 1) {\n\t\tbufsize = bytes_wanted;\n\t\toutbuf = kmem_alloc(bufsize, KM_SLEEP);\n\t\todp = (struct dirent64 *)outbuf;\n\t} else {\n\t\tbufsize = bytes_wanted;\n\t\toutbuf = NULL;\n\t\todp = (struct dirent64 *)iovp->iov_base;\n\t}\n\n\tif (ncookies != NULL) {\n\t\t \n\t\tncooks = zfs_uio_resid(uio) / (sizeof (struct dirent) -\n\t\t    sizeof (((struct dirent *)NULL)->d_name) + 1);\n\t\tcooks = malloc(ncooks * sizeof (*cooks), M_TEMP, M_WAITOK);\n\t\t*cookies = cooks;\n\t\t*ncookies = ncooks;\n\t}\n\n\t \n\toutcount = 0;\n\twhile (outcount < bytes_wanted) {\n\t\tino64_t objnum;\n\t\tushort_t reclen;\n\t\toff64_t *next = NULL;\n\n\t\t \n\t\tif (offset == 0) {\n\t\t\t(void) strcpy(zap.za_name, \".\");\n\t\t\tzap.za_normalization_conflict = 0;\n\t\t\tobjnum = zp->z_id;\n\t\t\ttype = DT_DIR;\n\t\t} else if (offset == 1) {\n\t\t\t(void) strcpy(zap.za_name, \"..\");\n\t\t\tzap.za_normalization_conflict = 0;\n\t\t\tobjnum = parent;\n\t\t\ttype = DT_DIR;\n\t\t} else if (offset == 2 && zfs_show_ctldir(zp)) {\n\t\t\t(void) strcpy(zap.za_name, ZFS_CTLDIR_NAME);\n\t\t\tzap.za_normalization_conflict = 0;\n\t\t\tobjnum = ZFSCTL_INO_ROOT;\n\t\t\ttype = DT_DIR;\n\t\t} else {\n\t\t\t \n\t\t\tif ((error = zap_cursor_retrieve(&zc, &zap))) {\n\t\t\t\tif ((*eofp = (error == ENOENT)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tgoto update;\n\t\t\t}\n\n\t\t\tif (zap.za_integer_length != 8 ||\n\t\t\t    zap.za_num_integers != 1) {\n\t\t\t\tcmn_err(CE_WARN, \"zap_readdir: bad directory \"\n\t\t\t\t    \"entry, obj = %lld, offset = %lld\\n\",\n\t\t\t\t    (u_longlong_t)zp->z_id,\n\t\t\t\t    (u_longlong_t)offset);\n\t\t\t\terror = SET_ERROR(ENXIO);\n\t\t\t\tgoto update;\n\t\t\t}\n\n\t\t\tobjnum = ZFS_DIRENT_OBJ(zap.za_first_integer);\n\t\t\t \n\t\t\ttype = ZFS_DIRENT_TYPE(zap.za_first_integer);\n\t\t}\n\n\t\treclen = DIRENT64_RECLEN(strlen(zap.za_name));\n\n\t\t \n\t\tif (outcount + reclen > bufsize) {\n\t\t\t \n\t\t\tif (!outcount) {\n\t\t\t\terror = SET_ERROR(EINVAL);\n\t\t\t\tgoto update;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\todp->d_ino = objnum;\n\t\todp->d_reclen = reclen;\n\t\todp->d_namlen = strlen(zap.za_name);\n\t\t \n\t\tnext = &odp->d_off;\n\t\tstrlcpy(odp->d_name, zap.za_name, odp->d_namlen + 1);\n\t\todp->d_type = type;\n\t\tdirent_terminate(odp);\n\t\todp = (dirent64_t *)((intptr_t)odp + reclen);\n\n\t\toutcount += reclen;\n\n\t\tASSERT3S(outcount, <=, bufsize);\n\n\t\t \n\t\tif (prefetch)\n\t\t\tdmu_prefetch(os, objnum, 0, 0, 0,\n\t\t\t    ZIO_PRIORITY_SYNC_READ);\n\n\t\t \n\t\tif (offset > 2 || (offset == 2 && !zfs_show_ctldir(zp))) {\n\t\t\tzap_cursor_advance(&zc);\n\t\t\toffset = zap_cursor_serialize(&zc);\n\t\t} else {\n\t\t\toffset += 1;\n\t\t}\n\n\t\t \n\t\tif (next != NULL)\n\t\t\t*next = offset;\n\t\tif (cooks != NULL) {\n\t\t\t*cooks++ = offset;\n\t\t\tncooks--;\n\t\t\tKASSERT(ncooks >= 0, (\"ncookies=%d\", ncooks));\n\t\t}\n\t}\n\tzp->z_zn_prefetch = B_FALSE;  \n\n\t \n\tif (ncookies != NULL)\n\t\t*ncookies -= ncooks;\n\n\tif (zfs_uio_segflg(uio) == UIO_SYSSPACE && zfs_uio_iovcnt(uio) == 1) {\n\t\tiovp->iov_base += outcount;\n\t\tiovp->iov_len -= outcount;\n\t\tzfs_uio_resid(uio) -= outcount;\n\t} else if ((error =\n\t    zfs_uiomove(outbuf, (long)outcount, UIO_READ, uio))) {\n\t\t \n\t\toffset = zfs_uio_offset(uio);\n\t}\n\nupdate:\n\tzap_cursor_fini(&zc);\n\tif (zfs_uio_segflg(uio) != UIO_SYSSPACE || zfs_uio_iovcnt(uio) != 1)\n\t\tkmem_free(outbuf, bufsize);\n\n\tif (error == ENOENT)\n\t\terror = 0;\n\n\tZFS_ACCESSTIME_STAMP(zfsvfs, zp);\n\n\tzfs_uio_setoffset(uio, offset);\n\tzfs_exit(zfsvfs, FTAG);\n\tif (error != 0 && cookies != NULL) {\n\t\tfree(*cookies, M_TEMP);\n\t\t*cookies = NULL;\n\t\t*ncookies = 0;\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfs_getattr(vnode_t *vp, vattr_t *vap, int flags, cred_t *cr)\n{\n\tznode_t *zp = VTOZ(vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tint\terror = 0;\n\tuint32_t blksize;\n\tu_longlong_t nblocks;\n\tuint64_t mtime[2], ctime[2], crtime[2], rdev;\n\txvattr_t *xvap = (xvattr_t *)vap;\t \n\txoptattr_t *xoap = NULL;\n\tboolean_t skipaclchk = (flags & ATTR_NOACLCHECK) ? B_TRUE : B_FALSE;\n\tsa_bulk_attr_t bulk[4];\n\tint count = 0;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tzfs_fuid_map_ids(zp, cr, &vap->va_uid, &vap->va_gid);\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL, &mtime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL, &ctime, 16);\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CRTIME(zfsvfs), NULL, &crtime, 16);\n\tif (vp->v_type == VBLK || vp->v_type == VCHR)\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_RDEV(zfsvfs), NULL,\n\t\t    &rdev, 8);\n\n\tif ((error = sa_bulk_lookup(zp->z_sa_hdl, bulk, count)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (!(zp->z_pflags & ZFS_ACL_TRIVIAL) &&\n\t    (vap->va_uid != crgetuid(cr))) {\n\t\tif ((error = zfs_zaccess(zp, ACE_READ_ATTRIBUTES, 0,\n\t\t    skipaclchk, cr, NULL))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t \n\n\tvap->va_type = IFTOVT(zp->z_mode);\n\tvap->va_mode = zp->z_mode & ~S_IFMT;\n\tvn_fsid(vp, vap);\n\tvap->va_nodeid = zp->z_id;\n\tvap->va_nlink = zp->z_links;\n\tif ((vp->v_flag & VROOT) && zfs_show_ctldir(zp) &&\n\t    zp->z_links < ZFS_LINK_MAX)\n\t\tvap->va_nlink++;\n\tvap->va_size = zp->z_size;\n\tif (vp->v_type == VBLK || vp->v_type == VCHR)\n\t\tvap->va_rdev = zfs_cmpldev(rdev);\n\tvap->va_gen = zp->z_gen;\n\tvap->va_flags = 0;\t \n\tvap->va_filerev = zp->z_seq;\n\n\t \n\tif ((xoap = xva_getxoptattr(xvap)) != NULL && zfsvfs->z_use_fuids) {\n\t\tif (XVA_ISSET_REQ(xvap, XAT_ARCHIVE)) {\n\t\t\txoap->xoa_archive =\n\t\t\t    ((zp->z_pflags & ZFS_ARCHIVE) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_ARCHIVE);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_READONLY)) {\n\t\t\txoap->xoa_readonly =\n\t\t\t    ((zp->z_pflags & ZFS_READONLY) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_READONLY);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_SYSTEM)) {\n\t\t\txoap->xoa_system =\n\t\t\t    ((zp->z_pflags & ZFS_SYSTEM) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_SYSTEM);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_HIDDEN)) {\n\t\t\txoap->xoa_hidden =\n\t\t\t    ((zp->z_pflags & ZFS_HIDDEN) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_HIDDEN);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK)) {\n\t\t\txoap->xoa_nounlink =\n\t\t\t    ((zp->z_pflags & ZFS_NOUNLINK) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_NOUNLINK);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE)) {\n\t\t\txoap->xoa_immutable =\n\t\t\t    ((zp->z_pflags & ZFS_IMMUTABLE) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_IMMUTABLE);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY)) {\n\t\t\txoap->xoa_appendonly =\n\t\t\t    ((zp->z_pflags & ZFS_APPENDONLY) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_APPENDONLY);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP)) {\n\t\t\txoap->xoa_nodump =\n\t\t\t    ((zp->z_pflags & ZFS_NODUMP) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_NODUMP);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_OPAQUE)) {\n\t\t\txoap->xoa_opaque =\n\t\t\t    ((zp->z_pflags & ZFS_OPAQUE) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_OPAQUE);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED)) {\n\t\t\txoap->xoa_av_quarantined =\n\t\t\t    ((zp->z_pflags & ZFS_AV_QUARANTINED) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_AV_QUARANTINED);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED)) {\n\t\t\txoap->xoa_av_modified =\n\t\t\t    ((zp->z_pflags & ZFS_AV_MODIFIED) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_AV_MODIFIED);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP) &&\n\t\t    vp->v_type == VREG) {\n\t\t\tzfs_sa_get_scanstamp(zp, xvap);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE)) {\n\t\t\txoap->xoa_reparse = ((zp->z_pflags & ZFS_REPARSE) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_REPARSE);\n\t\t}\n\t\tif (XVA_ISSET_REQ(xvap, XAT_GEN)) {\n\t\t\txoap->xoa_generation = zp->z_gen;\n\t\t\tXVA_SET_RTN(xvap, XAT_GEN);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_OFFLINE)) {\n\t\t\txoap->xoa_offline =\n\t\t\t    ((zp->z_pflags & ZFS_OFFLINE) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_OFFLINE);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_SPARSE)) {\n\t\t\txoap->xoa_sparse =\n\t\t\t    ((zp->z_pflags & ZFS_SPARSE) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_SPARSE);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT)) {\n\t\t\txoap->xoa_projinherit =\n\t\t\t    ((zp->z_pflags & ZFS_PROJINHERIT) != 0);\n\t\t\tXVA_SET_RTN(xvap, XAT_PROJINHERIT);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJID)) {\n\t\t\txoap->xoa_projid = zp->z_projid;\n\t\t\tXVA_SET_RTN(xvap, XAT_PROJID);\n\t\t}\n\t}\n\n\tZFS_TIME_DECODE(&vap->va_atime, zp->z_atime);\n\tZFS_TIME_DECODE(&vap->va_mtime, mtime);\n\tZFS_TIME_DECODE(&vap->va_ctime, ctime);\n\tZFS_TIME_DECODE(&vap->va_birthtime, crtime);\n\n\n\tsa_object_size(zp->z_sa_hdl, &blksize, &nblocks);\n\tvap->va_blksize = blksize;\n\tvap->va_bytes = nblocks << 9;\t \n\n\tif (zp->z_blksz == 0) {\n\t\t \n\t\tvap->va_blksize = zfsvfs->z_max_blksz;\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\n \nint\nzfs_setattr(znode_t *zp, vattr_t *vap, int flags, cred_t *cr, zidmap_t *mnt_ns)\n{\n\tvnode_t\t\t*vp = ZTOV(zp);\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tobjset_t\t*os;\n\tzilog_t\t\t*zilog;\n\tdmu_tx_t\t*tx;\n\tvattr_t\t\toldva;\n\txvattr_t\ttmpxvattr;\n\tuint_t\t\tmask = vap->va_mask;\n\tuint_t\t\tsaved_mask = 0;\n\tuint64_t\tsaved_mode;\n\tint\t\ttrim_mask = 0;\n\tuint64_t\tnew_mode;\n\tuint64_t\tnew_uid, new_gid;\n\tuint64_t\txattr_obj;\n\tuint64_t\tmtime[2], ctime[2];\n\tuint64_t\tprojid = ZFS_INVALID_PROJID;\n\tznode_t\t\t*attrzp;\n\tint\t\tneed_policy = FALSE;\n\tint\t\terr, err2;\n\tzfs_fuid_info_t *fuidp = NULL;\n\txvattr_t *xvap = (xvattr_t *)vap;\t \n\txoptattr_t\t*xoap;\n\tzfs_acl_t\t*aclp;\n\tboolean_t skipaclchk = (flags & ATTR_NOACLCHECK) ? B_TRUE : B_FALSE;\n\tboolean_t\tfuid_dirtied = B_FALSE;\n\tsa_bulk_attr_t\tbulk[7], xattr_bulk[7];\n\tint\t\tcount = 0, xattr_count = 0;\n\n\tif (mask == 0)\n\t\treturn (0);\n\n\tif (mask & AT_NOSET)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif ((err = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (err);\n\n\tos = zfsvfs->z_os;\n\tzilog = zfsvfs->z_log;\n\n\t \n\n\tif (zfsvfs->z_use_fuids == B_FALSE &&\n\t    (((mask & AT_UID) && IS_EPHEMERAL(vap->va_uid)) ||\n\t    ((mask & AT_GID) && IS_EPHEMERAL(vap->va_gid)) ||\n\t    (mask & AT_XVATTR))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (mask & AT_SIZE && vp->v_type == VDIR) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EISDIR));\n\t}\n\n\tif (mask & AT_SIZE && vp->v_type != VREG && vp->v_type != VFIFO) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\txoap = xva_getxoptattr(xvap);\n\n\txva_init(&tmpxvattr);\n\n\t \n\tif ((zp->z_pflags & ZFS_IMMUTABLE) &&\n\t    ((mask & (AT_SIZE|AT_UID|AT_GID|AT_MTIME|AT_MODE)) ||\n\t    ((mask & AT_XVATTR) && XVA_ISSET_REQ(xvap, XAT_CREATETIME)))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\n\t \n\tif (mask & (AT_ATIME | AT_MTIME)) {\n\t\tif (((mask & AT_ATIME) && TIMESPEC_OVERFLOW(&vap->va_atime)) ||\n\t\t    ((mask & AT_MTIME) && TIMESPEC_OVERFLOW(&vap->va_mtime))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EOVERFLOW));\n\t\t}\n\t}\n\tif (xoap != NULL && (mask & AT_XVATTR)) {\n\t\tif (XVA_ISSET_REQ(xvap, XAT_CREATETIME) &&\n\t\t    TIMESPEC_OVERFLOW(&vap->va_birthtime)) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EOVERFLOW));\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJID)) {\n\t\t\tif (!dmu_objset_projectquota_enabled(os) ||\n\t\t\t    (!S_ISREG(zp->z_mode) && !S_ISDIR(zp->z_mode))) {\n\t\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t\t\t}\n\n\t\t\tprojid = xoap->xoa_projid;\n\t\t\tif (unlikely(projid == ZFS_INVALID_PROJID)) {\n\t\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\t\treturn (SET_ERROR(EINVAL));\n\t\t\t}\n\n\t\t\tif (projid == zp->z_projid && zp->z_pflags & ZFS_PROJID)\n\t\t\t\tprojid = ZFS_INVALID_PROJID;\n\t\t\telse\n\t\t\t\tneed_policy = TRUE;\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT) &&\n\t\t    (xoap->xoa_projinherit !=\n\t\t    ((zp->z_pflags & ZFS_PROJINHERIT) != 0)) &&\n\t\t    (!dmu_objset_projectquota_enabled(os) ||\n\t\t    (!S_ISREG(zp->z_mode) && !S_ISDIR(zp->z_mode)))) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t\t}\n\t}\n\n\tattrzp = NULL;\n\taclp = NULL;\n\n\tif (zfsvfs->z_vfs->vfs_flag & VFS_RDONLY) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\n\tif (mask & AT_SIZE) {\n\t\t \n\t\t \n\t\terr = zfs_freesp(zp, vap->va_size, 0, 0, FALSE);\n\t\tif (err) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (err);\n\t\t}\n\t}\n\n\tif (mask & (AT_ATIME|AT_MTIME) ||\n\t    ((mask & AT_XVATTR) && (XVA_ISSET_REQ(xvap, XAT_HIDDEN) ||\n\t    XVA_ISSET_REQ(xvap, XAT_READONLY) ||\n\t    XVA_ISSET_REQ(xvap, XAT_ARCHIVE) ||\n\t    XVA_ISSET_REQ(xvap, XAT_OFFLINE) ||\n\t    XVA_ISSET_REQ(xvap, XAT_SPARSE) ||\n\t    XVA_ISSET_REQ(xvap, XAT_CREATETIME) ||\n\t    XVA_ISSET_REQ(xvap, XAT_SYSTEM)))) {\n\t\tneed_policy = zfs_zaccess(zp, ACE_WRITE_ATTRIBUTES, 0,\n\t\t    skipaclchk, cr, mnt_ns);\n\t}\n\n\tif (mask & (AT_UID|AT_GID)) {\n\t\tint\tidmask = (mask & (AT_UID|AT_GID));\n\t\tint\ttake_owner;\n\t\tint\ttake_group;\n\n\t\t \n\n\t\tif (!(mask & AT_MODE))\n\t\t\tvap->va_mode = zp->z_mode;\n\n\t\t \n\n\t\ttake_owner = (mask & AT_UID) && (vap->va_uid == crgetuid(cr));\n\t\ttake_group = (mask & AT_GID) &&\n\t\t    zfs_groupmember(zfsvfs, vap->va_gid, cr);\n\n\t\t \n\n\t\tif (((idmask == (AT_UID|AT_GID)) && take_owner && take_group) ||\n\t\t    ((idmask == AT_UID) && take_owner) ||\n\t\t    ((idmask == AT_GID) && take_group)) {\n\t\t\tif (zfs_zaccess(zp, ACE_WRITE_OWNER, 0,\n\t\t\t    skipaclchk, cr, mnt_ns) == 0) {\n\t\t\t\t \n\t\t\t\tsecpolicy_setid_clear(vap, vp, cr);\n\t\t\t\ttrim_mask = (mask & (AT_UID|AT_GID));\n\t\t\t} else {\n\t\t\t\tneed_policy =  TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tneed_policy =  TRUE;\n\t\t}\n\t}\n\n\toldva.va_mode = zp->z_mode;\n\tzfs_fuid_map_ids(zp, cr, &oldva.va_uid, &oldva.va_gid);\n\tif (mask & AT_XVATTR) {\n\t\t \n\t\tif (XVA_ISSET_REQ(xvap, XAT_APPENDONLY)) {\n\t\t\tif (xoap->xoa_appendonly !=\n\t\t\t    ((zp->z_pflags & ZFS_APPENDONLY) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_APPENDONLY);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_APPENDONLY);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_PROJINHERIT)) {\n\t\t\tif (xoap->xoa_projinherit !=\n\t\t\t    ((zp->z_pflags & ZFS_PROJINHERIT) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_PROJINHERIT);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_PROJINHERIT);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_NOUNLINK)) {\n\t\t\tif (xoap->xoa_nounlink !=\n\t\t\t    ((zp->z_pflags & ZFS_NOUNLINK) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_NOUNLINK);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_NOUNLINK);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_IMMUTABLE)) {\n\t\t\tif (xoap->xoa_immutable !=\n\t\t\t    ((zp->z_pflags & ZFS_IMMUTABLE) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_IMMUTABLE);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_IMMUTABLE);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_NODUMP)) {\n\t\t\tif (xoap->xoa_nodump !=\n\t\t\t    ((zp->z_pflags & ZFS_NODUMP) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_NODUMP);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_NODUMP);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_MODIFIED)) {\n\t\t\tif (xoap->xoa_av_modified !=\n\t\t\t    ((zp->z_pflags & ZFS_AV_MODIFIED) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_AV_MODIFIED);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_AV_MODIFIED);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_QUARANTINED)) {\n\t\t\tif ((vp->v_type != VREG &&\n\t\t\t    xoap->xoa_av_quarantined) ||\n\t\t\t    xoap->xoa_av_quarantined !=\n\t\t\t    ((zp->z_pflags & ZFS_AV_QUARANTINED) != 0)) {\n\t\t\t\tneed_policy = TRUE;\n\t\t\t} else {\n\t\t\t\tXVA_CLR_REQ(xvap, XAT_AV_QUARANTINED);\n\t\t\t\tXVA_SET_REQ(&tmpxvattr, XAT_AV_QUARANTINED);\n\t\t\t}\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_REPARSE)) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(EPERM));\n\t\t}\n\n\t\tif (need_policy == FALSE &&\n\t\t    (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP) ||\n\t\t    XVA_ISSET_REQ(xvap, XAT_OPAQUE))) {\n\t\t\tneed_policy = TRUE;\n\t\t}\n\t}\n\n\tif (mask & AT_MODE) {\n\t\tif (zfs_zaccess(zp, ACE_WRITE_ACL, 0, skipaclchk, cr,\n\t\t    mnt_ns) == 0) {\n\t\t\terr = secpolicy_setid_setsticky_clear(vp, vap,\n\t\t\t    &oldva, cr);\n\t\t\tif (err) {\n\t\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\t\treturn (err);\n\t\t\t}\n\t\t\ttrim_mask |= AT_MODE;\n\t\t} else {\n\t\t\tneed_policy = TRUE;\n\t\t}\n\t}\n\n\tif (need_policy) {\n\t\t \n\n\t\tif (trim_mask) {\n\t\t\tsaved_mask = vap->va_mask;\n\t\t\tvap->va_mask &= ~trim_mask;\n\t\t\tif (trim_mask & AT_MODE) {\n\t\t\t\t \n\t\t\t\tsaved_mode = vap->va_mode;\n\t\t\t}\n\t\t}\n\t\terr = secpolicy_vnode_setattr(cr, vp, vap, &oldva, flags,\n\t\t    (int (*)(void *, int, cred_t *))zfs_zaccess_unix, zp);\n\t\tif (err) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (err);\n\t\t}\n\n\t\tif (trim_mask) {\n\t\t\tvap->va_mask |= saved_mask;\n\t\t\tif (trim_mask & AT_MODE) {\n\t\t\t\t \n\t\t\t\tvap->va_mode = saved_mode;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmask = vap->va_mask;\n\n\tif ((mask & (AT_UID | AT_GID)) || projid != ZFS_INVALID_PROJID) {\n\t\terr = sa_lookup(zp->z_sa_hdl, SA_ZPL_XATTR(zfsvfs),\n\t\t    &xattr_obj, sizeof (xattr_obj));\n\n\t\tif (err == 0 && xattr_obj) {\n\t\t\terr = zfs_zget(zp->z_zfsvfs, xattr_obj, &attrzp);\n\t\t\tif (err == 0) {\n\t\t\t\terr = vn_lock(ZTOV(attrzp), LK_EXCLUSIVE);\n\t\t\t\tif (err != 0)\n\t\t\t\t\tvrele(ZTOV(attrzp));\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tgoto out2;\n\t\t}\n\t\tif (mask & AT_UID) {\n\t\t\tnew_uid = zfs_fuid_create(zfsvfs,\n\t\t\t    (uint64_t)vap->va_uid, cr, ZFS_OWNER, &fuidp);\n\t\t\tif (new_uid != zp->z_uid &&\n\t\t\t    zfs_id_overquota(zfsvfs, DMU_USERUSED_OBJECT,\n\t\t\t    new_uid)) {\n\t\t\t\tif (attrzp)\n\t\t\t\t\tvput(ZTOV(attrzp));\n\t\t\t\terr = SET_ERROR(EDQUOT);\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\n\t\tif (mask & AT_GID) {\n\t\t\tnew_gid = zfs_fuid_create(zfsvfs, (uint64_t)vap->va_gid,\n\t\t\t    cr, ZFS_GROUP, &fuidp);\n\t\t\tif (new_gid != zp->z_gid &&\n\t\t\t    zfs_id_overquota(zfsvfs, DMU_GROUPUSED_OBJECT,\n\t\t\t    new_gid)) {\n\t\t\t\tif (attrzp)\n\t\t\t\t\tvput(ZTOV(attrzp));\n\t\t\t\terr = SET_ERROR(EDQUOT);\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t}\n\n\t\tif (projid != ZFS_INVALID_PROJID &&\n\t\t    zfs_id_overquota(zfsvfs, DMU_PROJECTUSED_OBJECT, projid)) {\n\t\t\tif (attrzp)\n\t\t\t\tvput(ZTOV(attrzp));\n\t\t\terr = SET_ERROR(EDQUOT);\n\t\t\tgoto out2;\n\t\t}\n\t}\n\ttx = dmu_tx_create(os);\n\n\tif (mask & AT_MODE) {\n\t\tuint64_t pmode = zp->z_mode;\n\t\tuint64_t acl_obj;\n\t\tnew_mode = (pmode & S_IFMT) | (vap->va_mode & ~S_IFMT);\n\n\t\tif (zp->z_zfsvfs->z_acl_mode == ZFS_ACL_RESTRICTED &&\n\t\t    !(zp->z_pflags & ZFS_ACL_TRIVIAL)) {\n\t\t\terr = SET_ERROR(EPERM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((err = zfs_acl_chmod_setattr(zp, &aclp, new_mode)))\n\t\t\tgoto out;\n\n\t\tif (!zp->z_is_sa && ((acl_obj = zfs_external_acl(zp)) != 0)) {\n\t\t\t \n\t\t\tif (zfsvfs->z_version >= ZPL_VERSION_FUID &&\n\t\t\t    zfs_znode_acl_version(zp) ==\n\t\t\t    ZFS_ACL_VERSION_INITIAL) {\n\t\t\t\tdmu_tx_hold_free(tx, acl_obj, 0,\n\t\t\t\t    DMU_OBJECT_END);\n\t\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t\t\t    0, aclp->z_acl_bytes);\n\t\t\t} else {\n\t\t\t\tdmu_tx_hold_write(tx, acl_obj, 0,\n\t\t\t\t    aclp->z_acl_bytes);\n\t\t\t}\n\t\t} else if (!zp->z_is_sa && aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT,\n\t\t\t    0, aclp->z_acl_bytes);\n\t\t}\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t} else {\n\t\tif (((mask & AT_XVATTR) &&\n\t\t    XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP)) ||\n\t\t    (projid != ZFS_INVALID_PROJID &&\n\t\t    !(zp->z_pflags & ZFS_PROJID)))\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\t\telse\n\t\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t}\n\n\tif (attrzp) {\n\t\tdmu_tx_hold_sa(tx, attrzp->z_sa_hdl, B_FALSE);\n\t}\n\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\n\tzfs_sa_upgrade_txholds(tx, zp);\n\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err)\n\t\tgoto out;\n\n\tcount = 0;\n\t \n\n\tif (projid != ZFS_INVALID_PROJID && !(zp->z_pflags & ZFS_PROJID)) {\n\t\t \n\t\tif (attrzp)\n\t\t\terr = sa_add_projid(attrzp->z_sa_hdl, tx, projid);\n\t\tif (err == 0)\n\t\t\terr = sa_add_projid(zp->z_sa_hdl, tx, projid);\n\n\t\tif (unlikely(err == EEXIST))\n\t\t\terr = 0;\n\t\telse if (err != 0)\n\t\t\tgoto out;\n\t\telse\n\t\t\tprojid = ZFS_INVALID_PROJID;\n\t}\n\n\tif (mask & (AT_UID|AT_GID|AT_MODE))\n\t\tmutex_enter(&zp->z_acl_lock);\n\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\n\tif (attrzp) {\n\t\tif (mask & (AT_UID|AT_GID|AT_MODE))\n\t\t\tmutex_enter(&attrzp->z_acl_lock);\n\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t    SA_ZPL_FLAGS(zfsvfs), NULL, &attrzp->z_pflags,\n\t\t    sizeof (attrzp->z_pflags));\n\t\tif (projid != ZFS_INVALID_PROJID) {\n\t\t\tattrzp->z_projid = projid;\n\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t    SA_ZPL_PROJID(zfsvfs), NULL, &attrzp->z_projid,\n\t\t\t    sizeof (attrzp->z_projid));\n\t\t}\n\t}\n\n\tif (mask & (AT_UID|AT_GID)) {\n\n\t\tif (mask & AT_UID) {\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_UID(zfsvfs), NULL,\n\t\t\t    &new_uid, sizeof (new_uid));\n\t\t\tzp->z_uid = new_uid;\n\t\t\tif (attrzp) {\n\t\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t\t    SA_ZPL_UID(zfsvfs), NULL, &new_uid,\n\t\t\t\t    sizeof (new_uid));\n\t\t\t\tattrzp->z_uid = new_uid;\n\t\t\t}\n\t\t}\n\n\t\tif (mask & AT_GID) {\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_GID(zfsvfs),\n\t\t\t    NULL, &new_gid, sizeof (new_gid));\n\t\t\tzp->z_gid = new_gid;\n\t\t\tif (attrzp) {\n\t\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t\t    SA_ZPL_GID(zfsvfs), NULL, &new_gid,\n\t\t\t\t    sizeof (new_gid));\n\t\t\t\tattrzp->z_gid = new_gid;\n\t\t\t}\n\t\t}\n\t\tif (!(mask & AT_MODE)) {\n\t\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs),\n\t\t\t    NULL, &new_mode, sizeof (new_mode));\n\t\t\tnew_mode = zp->z_mode;\n\t\t}\n\t\terr = zfs_acl_chown_setattr(zp);\n\t\tASSERT0(err);\n\t\tif (attrzp) {\n\t\t\tvn_seqc_write_begin(ZTOV(attrzp));\n\t\t\terr = zfs_acl_chown_setattr(attrzp);\n\t\t\tvn_seqc_write_end(ZTOV(attrzp));\n\t\t\tASSERT0(err);\n\t\t}\n\t}\n\n\tif (mask & AT_MODE) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t\t    &new_mode, sizeof (new_mode));\n\t\tzp->z_mode = new_mode;\n\t\tASSERT3P(aclp, !=, NULL);\n\t\terr = zfs_aclset_common(zp, aclp, cr, tx);\n\t\tASSERT0(err);\n\t\tif (zp->z_acl_cached)\n\t\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = aclp;\n\t\taclp = NULL;\n\t}\n\n\n\tif (mask & AT_ATIME) {\n\t\tZFS_TIME_ENCODE(&vap->va_atime, zp->z_atime);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ATIME(zfsvfs), NULL,\n\t\t    &zp->z_atime, sizeof (zp->z_atime));\n\t}\n\n\tif (mask & AT_MTIME) {\n\t\tZFS_TIME_ENCODE(&vap->va_mtime, mtime);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t\t    mtime, sizeof (mtime));\n\t}\n\n\tif (projid != ZFS_INVALID_PROJID) {\n\t\tzp->z_projid = projid;\n\t\tSA_ADD_BULK_ATTR(bulk, count,\n\t\t    SA_ZPL_PROJID(zfsvfs), NULL, &zp->z_projid,\n\t\t    sizeof (zp->z_projid));\n\t}\n\n\t \n\tif (mask & AT_SIZE && !(mask & AT_MTIME)) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs),\n\t\t    NULL, mtime, sizeof (mtime));\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    &ctime, sizeof (ctime));\n\t\tzfs_tstamp_update_setup(zp, CONTENT_MODIFIED, mtime, ctime);\n\t} else if (mask != 0) {\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    &ctime, sizeof (ctime));\n\t\tzfs_tstamp_update_setup(zp, STATE_CHANGED, mtime, ctime);\n\t\tif (attrzp) {\n\t\t\tSA_ADD_BULK_ATTR(xattr_bulk, xattr_count,\n\t\t\t    SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t\t    &ctime, sizeof (ctime));\n\t\t\tzfs_tstamp_update_setup(attrzp, STATE_CHANGED,\n\t\t\t    mtime, ctime);\n\t\t}\n\t}\n\n\t \n\n\tif (xoap && (mask & AT_XVATTR)) {\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_CREATETIME))\n\t\t\txoap->xoa_createtime = vap->va_birthtime;\n\t\t \n\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_APPENDONLY)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_APPENDONLY);\n\t\t}\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_NOUNLINK)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_NOUNLINK);\n\t\t}\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_IMMUTABLE)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_IMMUTABLE);\n\t\t}\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_NODUMP)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_NODUMP);\n\t\t}\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_AV_MODIFIED)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_AV_MODIFIED);\n\t\t}\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_AV_QUARANTINED)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_AV_QUARANTINED);\n\t\t}\n\t\tif (XVA_ISSET_REQ(&tmpxvattr, XAT_PROJINHERIT)) {\n\t\t\tXVA_SET_REQ(xvap, XAT_PROJINHERIT);\n\t\t}\n\n\t\tif (XVA_ISSET_REQ(xvap, XAT_AV_SCANSTAMP))\n\t\t\tASSERT3S(vp->v_type, ==, VREG);\n\n\t\tzfs_xvattr_set(zp, xvap, tx);\n\t}\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tif (mask != 0)\n\t\tzfs_log_setattr(zilog, tx, TX_SETATTR, zp, vap, mask, fuidp);\n\n\tif (mask & (AT_UID|AT_GID|AT_MODE))\n\t\tmutex_exit(&zp->z_acl_lock);\n\n\tif (attrzp) {\n\t\tif (mask & (AT_UID|AT_GID|AT_MODE))\n\t\t\tmutex_exit(&attrzp->z_acl_lock);\n\t}\nout:\n\tif (err == 0 && attrzp) {\n\t\terr2 = sa_bulk_update(attrzp->z_sa_hdl, xattr_bulk,\n\t\t    xattr_count, tx);\n\t\tASSERT0(err2);\n\t}\n\n\tif (attrzp)\n\t\tvput(ZTOV(attrzp));\n\n\tif (aclp)\n\t\tzfs_acl_free(aclp);\n\n\tif (fuidp) {\n\t\tzfs_fuid_info_free(fuidp);\n\t\tfuidp = NULL;\n\t}\n\n\tif (err) {\n\t\tdmu_tx_abort(tx);\n\t} else {\n\t\terr2 = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\t\tdmu_tx_commit(tx);\n\t}\n\nout2:\n\tif (os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (err);\n}\n\n \nstatic int\nzfs_rename_relock_lookup(znode_t *sdzp, const struct componentname *scnp,\n    znode_t **szpp, znode_t *tdzp, const struct componentname *tcnp,\n    znode_t **tzpp)\n{\n\tzfsvfs_t *zfsvfs;\n\tznode_t *szp, *tzp;\n\tint error;\n\n\t \n\tzfsvfs = sdzp->z_zfsvfs;\n\tASSERT3P(zfsvfs, ==, tdzp->z_zfsvfs);\n\tif ((error = zfs_enter_verify_zp(zfsvfs, sdzp, FTAG)) != 0)\n\t\treturn (error);\n\tif ((error = zfs_verify_zp(tdzp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = zfs_dirent_lookup(sdzp, scnp->cn_nameptr, &szp, ZEXISTS);\n\tif (error != 0) {\n\t\t \n\t\tif ((scnp->cn_flags & ISDOTDOT) != 0 ||\n\t\t    (scnp->cn_namelen == 1 && scnp->cn_nameptr[0] == '.'))\n\t\t\terror = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\t*szpp = szp;\n\n\t \n\terror = zfs_dirent_lookup(tdzp, tcnp->cn_nameptr, &tzp, 0);\n\tif (error != 0) {\n\t\tvrele(ZTOV(szp));\n\t\tif ((tcnp->cn_flags & ISDOTDOT) != 0)\n\t\t\terror = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\t*tzpp = tzp;\nout:\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_rename_relock(struct vnode *sdvp, struct vnode **svpp,\n    struct vnode *tdvp, struct vnode **tvpp,\n    const struct componentname *scnp, const struct componentname *tcnp)\n{\n\tstruct vnode\t*nvp, *svp, *tvp;\n\tznode_t\t\t*sdzp, *tdzp, *szp, *tzp;\n\tint\t\terror;\n\n\tVOP_UNLOCK1(tdvp);\n\tif (*tvpp != NULL && *tvpp != tdvp)\n\t\tVOP_UNLOCK1(*tvpp);\n\nrelock:\n\terror = vn_lock(sdvp, LK_EXCLUSIVE);\n\tif (error)\n\t\tgoto out;\n\terror = vn_lock(tdvp, LK_EXCLUSIVE | LK_NOWAIT);\n\tif (error != 0) {\n\t\tVOP_UNLOCK1(sdvp);\n\t\tif (error != EBUSY)\n\t\t\tgoto out;\n\t\terror = vn_lock(tdvp, LK_EXCLUSIVE);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tVOP_UNLOCK1(tdvp);\n\t\tgoto relock;\n\t}\n\ttdzp = VTOZ(tdvp);\n\tsdzp = VTOZ(sdvp);\n\n\terror = zfs_rename_relock_lookup(sdzp, scnp, &szp, tdzp, tcnp, &tzp);\n\tif (error != 0) {\n\t\tVOP_UNLOCK1(sdvp);\n\t\tVOP_UNLOCK1(tdvp);\n\t\tgoto out;\n\t}\n\tsvp = ZTOV(szp);\n\ttvp = tzp != NULL ? ZTOV(tzp) : NULL;\n\n\t \n\tnvp = svp;\n\terror = vn_lock(nvp, LK_EXCLUSIVE | LK_NOWAIT);\n\tif (error != 0) {\n\t\tVOP_UNLOCK1(sdvp);\n\t\tVOP_UNLOCK1(tdvp);\n\t\tif (tvp != NULL)\n\t\t\tvrele(tvp);\n\t\tif (error != EBUSY) {\n\t\t\tvrele(nvp);\n\t\t\tgoto out;\n\t\t}\n\t\terror = vn_lock(nvp, LK_EXCLUSIVE);\n\t\tif (error != 0) {\n\t\t\tvrele(nvp);\n\t\t\tgoto out;\n\t\t}\n\t\tVOP_UNLOCK1(nvp);\n\t\t \n\t\tif (nvp == tdvp) {\n\t\t\tvrele(nvp);\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t\tvrele(*svpp);\n\t\t*svpp = nvp;\n\t\tgoto relock;\n\t}\n\tvrele(*svpp);\n\t*svpp = nvp;\n\n\tif (*tvpp != NULL)\n\t\tvrele(*tvpp);\n\t*tvpp = NULL;\n\tif (tvp != NULL) {\n\t\tnvp = tvp;\n\t\terror = vn_lock(nvp, LK_EXCLUSIVE | LK_NOWAIT);\n\t\tif (error != 0) {\n\t\t\tVOP_UNLOCK1(sdvp);\n\t\t\tVOP_UNLOCK1(tdvp);\n\t\t\tVOP_UNLOCK1(*svpp);\n\t\t\tif (error != EBUSY) {\n\t\t\t\tvrele(nvp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terror = vn_lock(nvp, LK_EXCLUSIVE);\n\t\t\tif (error != 0) {\n\t\t\t\tvrele(nvp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvput(nvp);\n\t\t\tgoto relock;\n\t\t}\n\t\t*tvpp = nvp;\n\t}\n\n\treturn (0);\n\nout:\n\treturn (error);\n}\n\n \nstatic int\nzfs_rename_check(znode_t *szp, znode_t *sdzp, znode_t *tdzp)\n{\n\tzfsvfs_t\t*zfsvfs;\n\tznode_t\t\t*zp, *zp1;\n\tuint64_t\tparent;\n\tint\t\terror;\n\n\tzfsvfs = tdzp->z_zfsvfs;\n\tif (tdzp == szp)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (tdzp == sdzp)\n\t\treturn (0);\n\tif (tdzp->z_id == zfsvfs->z_root)\n\t\treturn (0);\n\tzp = tdzp;\n\tfor (;;) {\n\t\tASSERT(!zp->z_unlinked);\n\t\tif ((error = sa_lookup(zp->z_sa_hdl,\n\t\t    SA_ZPL_PARENT(zfsvfs), &parent, sizeof (parent))) != 0)\n\t\t\tbreak;\n\n\t\tif (parent == szp->z_id) {\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tif (parent == zfsvfs->z_root)\n\t\t\tbreak;\n\t\tif (parent == sdzp->z_id)\n\t\t\tbreak;\n\n\t\terror = zfs_zget(zfsvfs, parent, &zp1);\n\t\tif (error != 0)\n\t\t\tbreak;\n\n\t\tif (zp != tdzp)\n\t\t\tVN_RELE_ASYNC(ZTOV(zp),\n\t\t\t    dsl_pool_zrele_taskq(\n\t\t\t    dmu_objset_pool(zfsvfs->z_os)));\n\t\tzp = zp1;\n\t}\n\n\tif (error == ENOTDIR)\n\t\tpanic(\"checkpath: .. not a directory\\n\");\n\tif (zp != tdzp)\n\t\tVN_RELE_ASYNC(ZTOV(zp),\n\t\t    dsl_pool_zrele_taskq(dmu_objset_pool(zfsvfs->z_os)));\n\treturn (error);\n}\n\n#if\t__FreeBSD_version < 1300124\nstatic void\ncache_vop_rename(struct vnode *fdvp, struct vnode *fvp, struct vnode *tdvp,\n    struct vnode *tvp, struct componentname *fcnp, struct componentname *tcnp)\n{\n\n\tcache_purge(fvp);\n\tif (tvp != NULL)\n\t\tcache_purge(tvp);\n\tcache_purge_negative(tdvp);\n}\n#endif\n\nstatic int\nzfs_do_rename_impl(vnode_t *sdvp, vnode_t **svpp, struct componentname *scnp,\n    vnode_t *tdvp, vnode_t **tvpp, struct componentname *tcnp,\n    cred_t *cr);\n\n \nstatic int\nzfs_do_rename(vnode_t *sdvp, vnode_t **svpp, struct componentname *scnp,\n    vnode_t *tdvp, vnode_t **tvpp, struct componentname *tcnp,\n    cred_t *cr)\n{\n\tint\terror;\n\n\tASSERT_VOP_ELOCKED(tdvp, __func__);\n\tif (*tvpp != NULL)\n\t\tASSERT_VOP_ELOCKED(*tvpp, __func__);\n\n\t \n\tif ((*svpp)->v_mount != tdvp->v_mount ||\n\t    ((*tvpp) != NULL && (*svpp)->v_mount != (*tvpp)->v_mount)) {\n\t\terror = SET_ERROR(EXDEV);\n\t\tgoto out;\n\t}\n\n\tif (zfsctl_is_node(tdvp)) {\n\t\terror = SET_ERROR(EXDEV);\n\t\tgoto out;\n\t}\n\n\t \n\terror = zfs_rename_relock(sdvp, svpp, tdvp, tvpp, scnp, tcnp);\n\tif (error != 0) {\n\t\t \n\t\treturn (error);\n\t}\n\n\terror = zfs_do_rename_impl(sdvp, svpp, scnp, tdvp, tvpp, tcnp, cr);\n\tVOP_UNLOCK1(sdvp);\n\tVOP_UNLOCK1(*svpp);\nout:\n\tif (*tvpp != NULL)\n\t\tVOP_UNLOCK1(*tvpp);\n\tif (tdvp != *tvpp)\n\t\tVOP_UNLOCK1(tdvp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_do_rename_impl(vnode_t *sdvp, vnode_t **svpp, struct componentname *scnp,\n    vnode_t *tdvp, vnode_t **tvpp, struct componentname *tcnp,\n    cred_t *cr)\n{\n\tdmu_tx_t\t*tx;\n\tzfsvfs_t\t*zfsvfs;\n\tzilog_t\t\t*zilog;\n\tznode_t\t\t*tdzp, *sdzp, *tzp, *szp;\n\tconst char\t*snm = scnp->cn_nameptr;\n\tconst char\t*tnm = tcnp->cn_nameptr;\n\tint\t\terror;\n\n\ttdzp = VTOZ(tdvp);\n\tsdzp = VTOZ(sdvp);\n\tzfsvfs = tdzp->z_zfsvfs;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, tdzp, FTAG)) != 0)\n\t\treturn (error);\n\tif ((error = zfs_verify_zp(sdzp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tzilog = zfsvfs->z_log;\n\n\tif (zfsvfs->z_utf8 && u8_validate(tnm,\n\t    strlen(tnm), NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\terror = SET_ERROR(EILSEQ);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((*svpp) == (*tvpp)) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\tif (((*svpp)->v_type == VDIR && (*svpp)->v_mountedhere != NULL) ||\n\t    ((*tvpp) != NULL && (*tvpp)->v_type == VDIR &&\n\t    (*tvpp)->v_mountedhere != NULL)) {\n\t\terror = SET_ERROR(EXDEV);\n\t\tgoto out;\n\t}\n\n\tszp = VTOZ(*svpp);\n\tif ((error = zfs_verify_zp(szp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\ttzp = *tvpp == NULL ? NULL : VTOZ(*tvpp);\n\tif (tzp != NULL) {\n\t\tif ((error = zfs_verify_zp(tzp)) != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\t \n\tif ((tdzp->z_pflags & ZFS_XATTR) != (sdzp->z_pflags & ZFS_XATTR)) {\n\t\terror = SET_ERROR(EINVAL);\n\t\tgoto out;\n\t}\n\n\t \n\tif (tdzp->z_pflags & ZFS_PROJINHERIT &&\n\t    tdzp->z_projid != szp->z_projid) {\n\t\terror = SET_ERROR(EXDEV);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((error = zfs_zaccess_rename(sdzp, szp, tdzp, tzp, cr, NULL)))\n\t\tgoto out;\n\n\tif ((*svpp)->v_type == VDIR) {\n\t\t \n\t\tif ((scnp->cn_namelen == 1 && scnp->cn_nameptr[0] == '.') ||\n\t\t    sdzp == szp ||\n\t\t    (scnp->cn_flags | tcnp->cn_flags) & ISDOTDOT) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif ((error = zfs_rename_check(szp, sdzp, tdzp)))\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (tzp) {\n\t\t \n\t\tif ((*svpp)->v_type == VDIR) {\n\t\t\tif ((*tvpp)->v_type != VDIR) {\n\t\t\t\terror = SET_ERROR(ENOTDIR);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tcache_purge(tdvp);\n\t\t\t\tif (sdvp != tdvp)\n\t\t\t\t\tcache_purge(sdvp);\n\t\t\t}\n\t\t} else {\n\t\t\tif ((*tvpp)->v_type == VDIR) {\n\t\t\t\terror = SET_ERROR(EISDIR);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tvn_seqc_write_begin(*svpp);\n\tvn_seqc_write_begin(sdvp);\n\tif (*tvpp != NULL)\n\t\tvn_seqc_write_begin(*tvpp);\n\tif (tdvp != *tvpp)\n\t\tvn_seqc_write_begin(tdvp);\n\n\tvnevent_rename_src(*svpp, sdvp, scnp->cn_nameptr, ct);\n\tif (tzp)\n\t\tvnevent_rename_dest(*tvpp, tdvp, tnm, ct);\n\n\t \n\tif (tdvp != sdvp) {\n\t\tvnevent_rename_dest_dir(tdvp, ct);\n\t}\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, szp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_sa(tx, sdzp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_zap(tx, sdzp->z_id, FALSE, snm);\n\tdmu_tx_hold_zap(tx, tdzp->z_id, TRUE, tnm);\n\tif (sdzp != tdzp) {\n\t\tdmu_tx_hold_sa(tx, tdzp->z_sa_hdl, B_FALSE);\n\t\tzfs_sa_upgrade_txholds(tx, tdzp);\n\t}\n\tif (tzp) {\n\t\tdmu_tx_hold_sa(tx, tzp->z_sa_hdl, B_FALSE);\n\t\tzfs_sa_upgrade_txholds(tx, tzp);\n\t}\n\n\tzfs_sa_upgrade_txholds(tx, szp);\n\tdmu_tx_hold_zap(tx, zfsvfs->z_unlinkedobj, FALSE, NULL);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tgoto out_seq;\n\t}\n\n\tif (tzp)\t \n\t\terror = zfs_link_destroy(tdzp, tnm, tzp, tx, 0, NULL);\n\n\tif (error == 0) {\n\t\terror = zfs_link_create(tdzp, tnm, szp, tx, ZRENAMING);\n\t\tif (error == 0) {\n\t\t\tszp->z_pflags |= ZFS_AV_MODIFIED;\n\n\t\t\terror = sa_update(szp->z_sa_hdl, SA_ZPL_FLAGS(zfsvfs),\n\t\t\t    (void *)&szp->z_pflags, sizeof (uint64_t), tx);\n\t\t\tASSERT0(error);\n\n\t\t\terror = zfs_link_destroy(sdzp, snm, szp, tx, ZRENAMING,\n\t\t\t    NULL);\n\t\t\tif (error == 0) {\n\t\t\t\tzfs_log_rename(zilog, tx, TX_RENAME, sdzp,\n\t\t\t\t    snm, tdzp, tnm, szp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tVERIFY0(zfs_link_destroy(tdzp, tnm, szp, tx,\n\t\t\t\t    ZRENAMING, NULL));\n\t\t\t}\n\t\t}\n\t\tif (error == 0) {\n\t\t\tcache_vop_rename(sdvp, *svpp, tdvp, *tvpp, scnp, tcnp);\n\t\t}\n\t}\n\n\tdmu_tx_commit(tx);\n\nout_seq:\n\tvn_seqc_write_end(*svpp);\n\tvn_seqc_write_end(sdvp);\n\tif (*tvpp != NULL)\n\t\tvn_seqc_write_end(*tvpp);\n\tif (tdvp != *tvpp)\n\t\tvn_seqc_write_end(tdvp);\n\nout:\n\tif (error == 0 && zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\tzfs_exit(zfsvfs, FTAG);\n\n\treturn (error);\n}\n\nint\nzfs_rename(znode_t *sdzp, const char *sname, znode_t *tdzp, const char *tname,\n    cred_t *cr, int flags, uint64_t rflags, vattr_t *wo_vap, zidmap_t *mnt_ns)\n{\n\tstruct componentname scn, tcn;\n\tvnode_t *sdvp, *tdvp;\n\tvnode_t *svp, *tvp;\n\tint error;\n\tsvp = tvp = NULL;\n\n\tif (rflags != 0 || wo_vap != NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tsdvp = ZTOV(sdzp);\n\ttdvp = ZTOV(tdzp);\n\terror = zfs_lookup_internal(sdzp, sname, &svp, &scn, DELETE);\n\tif (sdzp->z_zfsvfs->z_replay == B_FALSE)\n\t\tVOP_UNLOCK1(sdvp);\n\tif (error != 0)\n\t\tgoto fail;\n\tVOP_UNLOCK1(svp);\n\n\tvn_lock(tdvp, LK_EXCLUSIVE | LK_RETRY);\n\terror = zfs_lookup_internal(tdzp, tname, &tvp, &tcn, RENAME);\n\tif (error == EJUSTRETURN)\n\t\ttvp = NULL;\n\telse if (error != 0) {\n\t\tVOP_UNLOCK1(tdvp);\n\t\tgoto fail;\n\t}\n\n\terror = zfs_do_rename(sdvp, &svp, &scn, tdvp, &tvp, &tcn, cr);\nfail:\n\tif (svp != NULL)\n\t\tvrele(svp);\n\tif (tvp != NULL)\n\t\tvrele(tvp);\n\n\treturn (error);\n}\n\n \nint\nzfs_symlink(znode_t *dzp, const char *name, vattr_t *vap,\n    const char *link, znode_t **zpp, cred_t *cr, int flags, zidmap_t *mnt_ns)\n{\n\t(void) flags;\n\tznode_t\t\t*zp;\n\tdmu_tx_t\t*tx;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tzilog_t\t\t*zilog;\n\tuint64_t\tlen = strlen(link);\n\tint\t\terror;\n\tzfs_acl_ids_t\tacl_ids;\n\tboolean_t\tfuid_dirtied;\n\tuint64_t\ttxtype = TX_SYMLINK;\n\n\tASSERT3S(vap->va_type, ==, VLNK);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, dzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\tif (zfsvfs->z_utf8 && u8_validate(name, strlen(name),\n\t    NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\tif (len > MAXPATHLEN) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t}\n\n\tif ((error = zfs_acl_ids_create(dzp, 0,\n\t    vap, cr, NULL, &acl_ids, NULL)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = zfs_dirent_lookup(dzp, name, &zp, ZNEW);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif ((error = zfs_zaccess(dzp, ACE_ADD_FILE, 0, B_FALSE, cr, mnt_ns))) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tif (zfs_acl_ids_overquota(zfsvfs, &acl_ids,\n\t    0  )) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EDQUOT));\n\t}\n\n\tgetnewvnode_reserve_();\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0, MAX(1, len));\n\tdmu_tx_hold_zap(tx, dzp->z_id, TRUE, name);\n\tdmu_tx_hold_sa_create(tx, acl_ids.z_aclp->z_acl_bytes +\n\t    ZFS_SA_BASE_ATTR_SIZE + len);\n\tdmu_tx_hold_sa(tx, dzp->z_sa_hdl, B_FALSE);\n\tif (!zfsvfs->z_use_sa && acl_ids.z_aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,\n\t\t    acl_ids.z_aclp->z_acl_bytes);\n\t}\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tzfs_acl_ids_free(&acl_ids);\n\t\tdmu_tx_abort(tx);\n\t\tgetnewvnode_drop_reserve();\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tzfs_mknode(dzp, vap, tx, cr, 0, &zp, &acl_ids);\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tif (zp->z_is_sa)\n\t\terror = sa_update(zp->z_sa_hdl, SA_ZPL_SYMLINK(zfsvfs),\n\t\t    __DECONST(void *, link), len, tx);\n\telse\n\t\tzfs_sa_symlink(zp, __DECONST(char *, link), len, tx);\n\n\tzp->z_size = len;\n\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_SIZE(zfsvfs),\n\t    &zp->z_size, sizeof (zp->z_size), tx);\n\t \n\t(void) zfs_link_create(dzp, name, zp, tx, ZNEW);\n\n\tzfs_log_symlink(zilog, tx, txtype, dzp, zp, name, link);\n\t*zpp = zp;\n\n\tzfs_acl_ids_free(&acl_ids);\n\n\tdmu_tx_commit(tx);\n\n\tgetnewvnode_drop_reserve();\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nstatic int\nzfs_readlink(vnode_t *vp, zfs_uio_t *uio, cred_t *cr, caller_context_t *ct)\n{\n\t(void) cr, (void) ct;\n\tznode_t\t\t*zp = VTOZ(vp);\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tint\t\terror;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (zp->z_is_sa)\n\t\terror = sa_lookup_uio(zp->z_sa_hdl,\n\t\t    SA_ZPL_SYMLINK(zfsvfs), uio);\n\telse\n\t\terror = zfs_sa_readlink(zp, uio);\n\n\tZFS_ACCESSTIME_STAMP(zfsvfs, zp);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_link(znode_t *tdzp, znode_t *szp, const char *name, cred_t *cr,\n    int flags)\n{\n\t(void) flags;\n\tznode_t\t\t*tzp;\n\tzfsvfs_t\t*zfsvfs = tdzp->z_zfsvfs;\n\tzilog_t\t\t*zilog;\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tuint64_t\tparent;\n\tuid_t\t\towner;\n\n\tASSERT3S(ZTOV(tdzp)->v_type, ==, VDIR);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, tdzp, FTAG)) != 0)\n\t\treturn (error);\n\tzilog = zfsvfs->z_log;\n\n\t \n\tif (ZTOV(szp)->v_type == VDIR) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif ((error = zfs_verify_zp(szp)) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\tif (tdzp->z_pflags & ZFS_PROJINHERIT &&\n\t    tdzp->z_projid != szp->z_projid) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EXDEV));\n\t}\n\n\tif (szp->z_pflags & (ZFS_APPENDONLY |\n\t    ZFS_IMMUTABLE | ZFS_READONLY)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\n\tif ((error = sa_lookup(szp->z_sa_hdl, SA_ZPL_PARENT(zfsvfs),\n\t    &parent, sizeof (uint64_t))) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tif (parent == zfsvfs->z_shares_dir) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif (zfsvfs->z_utf8 && u8_validate(name,\n\t    strlen(name), NULL, U8_VALIDATE_ENTIRE, &error) < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EILSEQ));\n\t}\n\n\t \n\tif ((szp->z_pflags & ZFS_XATTR) != (tdzp->z_pflags & ZFS_XATTR)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\n\towner = zfs_fuid_map_id(zfsvfs, szp->z_uid, cr, ZFS_OWNER);\n\tif (owner != crgetuid(cr) && secpolicy_basic_link(ZTOV(szp), cr) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\tif ((error = zfs_zaccess(tdzp, ACE_ADD_FILE, 0, B_FALSE, cr, NULL))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = zfs_dirent_lookup(tdzp, name, &tzp, ZNEW);\n\tif (error) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_sa(tx, szp->z_sa_hdl, B_FALSE);\n\tdmu_tx_hold_zap(tx, tdzp->z_id, TRUE, name);\n\tzfs_sa_upgrade_txholds(tx, szp);\n\tzfs_sa_upgrade_txholds(tx, tdzp);\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\terror = zfs_link_create(tdzp, name, szp, tx, 0);\n\n\tif (error == 0) {\n\t\tuint64_t txtype = TX_LINK;\n\t\tzfs_log_link(zilog, tx, txtype, tdzp, szp, name);\n\t}\n\n\tdmu_tx_commit(tx);\n\n\tif (error == 0) {\n\t\tvnevent_link(ZTOV(szp), ct);\n\t}\n\n\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zilog, 0);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n \nint\nzfs_space(znode_t *zp, int cmd, flock64_t *bfp, int flag,\n    offset_t offset, cred_t *cr)\n{\n\t(void) offset;\n\tzfsvfs_t\t*zfsvfs = ZTOZSB(zp);\n\tuint64_t\toff, len;\n\tint\t\terror;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif (cmd != F_FREESP) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif (zfs_is_readonly(zfsvfs)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\tif (bfp->l_len < 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif ((error = zfs_zaccess(zp, ACE_WRITE_DATA, 0, B_FALSE, cr, NULL))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\toff = bfp->l_start;\n\tlen = bfp->l_len;  \n\n\terror = zfs_freesp(zp, off, len, flag, TRUE);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\nstatic void\nzfs_inactive(vnode_t *vp, cred_t *cr, caller_context_t *ct)\n{\n\t(void) cr, (void) ct;\n\tznode_t\t*zp = VTOZ(vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tint error;\n\n\tZFS_TEARDOWN_INACTIVE_ENTER_READ(zfsvfs);\n\tif (zp->z_sa_hdl == NULL) {\n\t\t \n\t\tZFS_TEARDOWN_INACTIVE_EXIT_READ(zfsvfs);\n\t\tvrecycle(vp);\n\t\treturn;\n\t}\n\n\tif (zp->z_unlinked) {\n\t\t \n\t\tZFS_TEARDOWN_INACTIVE_EXIT_READ(zfsvfs);\n\t\tvrecycle(vp);\n\t\treturn;\n\t}\n\n\tif (zp->z_atime_dirty && zp->z_unlinked == 0) {\n\t\tdmu_tx_t *tx = dmu_tx_create(zfsvfs->z_os);\n\n\t\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\t\tzfs_sa_upgrade_txholds(tx, zp);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tdmu_tx_abort(tx);\n\t\t} else {\n\t\t\t(void) sa_update(zp->z_sa_hdl, SA_ZPL_ATIME(zfsvfs),\n\t\t\t    (void *)&zp->z_atime, sizeof (zp->z_atime), tx);\n\t\t\tzp->z_atime_dirty = 0;\n\t\t\tdmu_tx_commit(tx);\n\t\t}\n\t}\n\tZFS_TEARDOWN_INACTIVE_EXIT_READ(zfsvfs);\n}\n\n\n_Static_assert(sizeof (struct zfid_short) <= sizeof (struct fid),\n\t\"struct zfid_short bigger than struct fid\");\n_Static_assert(sizeof (struct zfid_long) <= sizeof (struct fid),\n\t\"struct zfid_long bigger than struct fid\");\n\nstatic int\nzfs_fid(vnode_t *vp, fid_t *fidp, caller_context_t *ct)\n{\n\t(void) ct;\n\tznode_t\t\t*zp = VTOZ(vp);\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tuint32_t\tgen;\n\tuint64_t\tgen64;\n\tuint64_t\tobject = zp->z_id;\n\tzfid_short_t\t*zfid;\n\tint\t\tsize, i, error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(zfsvfs),\n\t    &gen64, sizeof (uint64_t))) != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\n\tgen = (uint32_t)gen64;\n\n\tsize = (zfsvfs->z_parent != zfsvfs) ? LONG_FID_LEN : SHORT_FID_LEN;\n\tfidp->fid_len = size;\n\n\tzfid = (zfid_short_t *)fidp;\n\n\tzfid->zf_len = size;\n\n\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\tzfid->zf_object[i] = (uint8_t)(object >> (8 * i));\n\n\t \n\tif (gen == 0)\n\t\tgen = 1;\n\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\tzfid->zf_gen[i] = (uint8_t)(gen >> (8 * i));\n\n\tif (size == LONG_FID_LEN) {\n\t\tuint64_t\tobjsetid = dmu_objset_id(zfsvfs->z_os);\n\t\tzfid_long_t\t*zlfid;\n\n\t\tzlfid = (zfid_long_t *)fidp;\n\n\t\tfor (i = 0; i < sizeof (zlfid->zf_setid); i++)\n\t\t\tzlfid->zf_setid[i] = (uint8_t)(objsetid >> (8 * i));\n\n\t\t \n\t\tfor (i = 0; i < sizeof (zlfid->zf_setgen); i++)\n\t\t\tzlfid->zf_setgen[i] = 0;\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nstatic int\nzfs_pathconf(vnode_t *vp, int cmd, ulong_t *valp, cred_t *cr,\n    caller_context_t *ct)\n{\n\tznode_t *zp;\n\tzfsvfs_t *zfsvfs;\n\tint error;\n\n\tswitch (cmd) {\n\tcase _PC_LINK_MAX:\n\t\t*valp = MIN(LONG_MAX, ZFS_LINK_MAX);\n\t\treturn (0);\n\n\tcase _PC_FILESIZEBITS:\n\t\t*valp = 64;\n\t\treturn (0);\n\tcase _PC_MIN_HOLE_SIZE:\n\t\t*valp = (int)SPA_MINBLOCKSIZE;\n\t\treturn (0);\n\tcase _PC_ACL_EXTENDED:\n#if 0\t\t \n\t\tzp = VTOZ(vp);\n\t\tzfsvfs = zp->z_zfsvfs;\n\t\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\t\treturn (error);\n\t\t*valp = zfsvfs->z_acl_type == ZFSACLTYPE_POSIX ? 1 : 0;\n\t\tzfs_exit(zfsvfs, FTAG);\n#else\n\t\t*valp = 0;\n#endif\n\t\treturn (0);\n\n\tcase _PC_ACL_NFS4:\n\t\tzp = VTOZ(vp);\n\t\tzfsvfs = zp->z_zfsvfs;\n\t\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\t\treturn (error);\n\t\t*valp = zfsvfs->z_acl_type == ZFS_ACLTYPE_NFSV4 ? 1 : 0;\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\n\tcase _PC_ACL_PATH_MAX:\n\t\t*valp = ACL_MAX_ENTRIES;\n\t\treturn (0);\n\n\tdefault:\n\t\treturn (EOPNOTSUPP);\n\t}\n}\n\nstatic int\nzfs_getpages(struct vnode *vp, vm_page_t *ma, int count, int *rbehind,\n    int *rahead)\n{\n\tznode_t *zp = VTOZ(vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tzfs_locked_range_t *lr;\n\tvm_object_t object;\n\toff_t start, end, obj_size;\n\tuint_t blksz;\n\tint pgsin_b, pgsin_a;\n\tint error;\n\n\tif (zfs_enter_verify_zp(zfsvfs, zp, FTAG) != 0)\n\t\treturn (zfs_vm_pagerret_error);\n\n\tstart = IDX_TO_OFF(ma[0]->pindex);\n\tend = IDX_TO_OFF(ma[count - 1]->pindex + 1);\n\n\t \n\tfor (;;) {\n\t\tblksz = zp->z_blksz;\n\t\tlr = zfs_rangelock_tryenter(&zp->z_rangelock,\n\t\t    rounddown(start, blksz),\n\t\t    roundup(end, blksz) - rounddown(start, blksz), RL_READER);\n\t\tif (lr == NULL) {\n\t\t\tif (rahead != NULL) {\n\t\t\t\t*rahead = 0;\n\t\t\t\trahead = NULL;\n\t\t\t}\n\t\t\tif (rbehind != NULL) {\n\t\t\t\t*rbehind = 0;\n\t\t\t\trbehind = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (blksz == zp->z_blksz)\n\t\t\tbreak;\n\t\tzfs_rangelock_exit(lr);\n\t}\n\n\tobject = ma[0]->object;\n\tzfs_vmobject_wlock(object);\n\tobj_size = object->un_pager.vnp.vnp_size;\n\tzfs_vmobject_wunlock(object);\n\tif (IDX_TO_OFF(ma[count - 1]->pindex) >= obj_size) {\n\t\tif (lr != NULL)\n\t\t\tzfs_rangelock_exit(lr);\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (zfs_vm_pagerret_bad);\n\t}\n\n\tpgsin_b = 0;\n\tif (rbehind != NULL) {\n\t\tpgsin_b = OFF_TO_IDX(start - rounddown(start, blksz));\n\t\tpgsin_b = MIN(*rbehind, pgsin_b);\n\t}\n\n\tpgsin_a = 0;\n\tif (rahead != NULL) {\n\t\tpgsin_a = OFF_TO_IDX(roundup(end, blksz) - end);\n\t\tif (end + IDX_TO_OFF(pgsin_a) >= obj_size)\n\t\t\tpgsin_a = OFF_TO_IDX(round_page(obj_size) - end);\n\t\tpgsin_a = MIN(*rahead, pgsin_a);\n\t}\n\n\t \n\terror = dmu_read_pages(zfsvfs->z_os, zp->z_id, ma, count, &pgsin_b,\n\t    &pgsin_a, MIN(end, obj_size) - (end - PAGE_SIZE));\n\n\tif (lr != NULL)\n\t\tzfs_rangelock_exit(lr);\n\tZFS_ACCESSTIME_STAMP(zfsvfs, zp);\n\n\tdataset_kstats_update_read_kstats(&zfsvfs->z_kstat, count*PAGE_SIZE);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\tif (error != 0)\n\t\treturn (zfs_vm_pagerret_error);\n\n\tVM_CNT_INC(v_vnodein);\n\tVM_CNT_ADD(v_vnodepgsin, count + pgsin_b + pgsin_a);\n\tif (rbehind != NULL)\n\t\t*rbehind = pgsin_b;\n\tif (rahead != NULL)\n\t\t*rahead = pgsin_a;\n\treturn (zfs_vm_pagerret_ok);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_getpages_args {\n\tstruct vnode *a_vp;\n\tvm_page_t *a_m;\n\tint a_count;\n\tint *a_rbehind;\n\tint *a_rahead;\n};\n#endif\n\nstatic int\nzfs_freebsd_getpages(struct vop_getpages_args *ap)\n{\n\n\treturn (zfs_getpages(ap->a_vp, ap->a_m, ap->a_count, ap->a_rbehind,\n\t    ap->a_rahead));\n}\n\nstatic int\nzfs_putpages(struct vnode *vp, vm_page_t *ma, size_t len, int flags,\n    int *rtvals)\n{\n\tznode_t\t\t*zp = VTOZ(vp);\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tzfs_locked_range_t\t\t*lr;\n\tdmu_tx_t\t*tx;\n\tstruct sf_buf\t*sf;\n\tvm_object_t\tobject;\n\tvm_page_t\tm;\n\tcaddr_t\t\tva;\n\tsize_t\t\ttocopy;\n\tsize_t\t\tlo_len;\n\tvm_ooffset_t\tlo_off;\n\tvm_ooffset_t\toff;\n\tuint_t\t\tblksz;\n\tint\t\tncount;\n\tint\t\tpcount;\n\tint\t\terr;\n\tint\t\ti;\n\n\tobject = vp->v_object;\n\tKASSERT(ma[0]->object == object, (\"mismatching object\"));\n\tKASSERT(len > 0 && (len & PAGE_MASK) == 0, (\"unexpected length\"));\n\n\tpcount = btoc(len);\n\tncount = pcount;\n\tfor (i = 0; i < pcount; i++)\n\t\trtvals[i] = zfs_vm_pagerret_error;\n\n\tif (zfs_enter_verify_zp(zfsvfs, zp, FTAG) != 0)\n\t\treturn (zfs_vm_pagerret_error);\n\n\toff = IDX_TO_OFF(ma[0]->pindex);\n\tblksz = zp->z_blksz;\n\tlo_off = rounddown(off, blksz);\n\tlo_len = roundup(len + (off - lo_off), blksz);\n\tlr = zfs_rangelock_enter(&zp->z_rangelock, lo_off, lo_len, RL_WRITER);\n\n\tzfs_vmobject_wlock(object);\n\tif (len + off > object->un_pager.vnp.vnp_size) {\n\t\tif (object->un_pager.vnp.vnp_size > off) {\n\t\t\tint pgoff;\n\n\t\t\tlen = object->un_pager.vnp.vnp_size - off;\n\t\t\tncount = btoc(len);\n\t\t\tif ((pgoff = (int)len & PAGE_MASK) != 0) {\n\t\t\t\t \n\t\t\t\tm = ma[ncount - 1];\n\t\t\t\tvm_page_assert_sbusied(m);\n\t\t\t\tKASSERT(!pmap_page_is_write_mapped(m),\n\t\t\t\t    (\"zfs_putpages: page %p is not read-only\",\n\t\t\t\t    m));\n\t\t\t\tvm_page_clear_dirty(m, pgoff, PAGE_SIZE -\n\t\t\t\t    pgoff);\n\t\t\t}\n\t\t} else {\n\t\t\tlen = 0;\n\t\t\tncount = 0;\n\t\t}\n\t\tif (ncount < pcount) {\n\t\t\tfor (i = ncount; i < pcount; i++) {\n\t\t\t\trtvals[i] = zfs_vm_pagerret_bad;\n\t\t\t}\n\t\t}\n\t}\n\tzfs_vmobject_wunlock(object);\n\n\tif (ncount == 0)\n\t\tgoto out;\n\n\tif (zfs_id_overblockquota(zfsvfs, DMU_USERUSED_OBJECT, zp->z_uid) ||\n\t    zfs_id_overblockquota(zfsvfs, DMU_GROUPUSED_OBJECT, zp->z_gid) ||\n\t    (zp->z_projid != ZFS_DEFAULT_PROJID &&\n\t    zfs_id_overblockquota(zfsvfs, DMU_PROJECTUSED_OBJECT,\n\t    zp->z_projid))) {\n\t\tgoto out;\n\t}\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\tdmu_tx_hold_write(tx, zp->z_id, off, len);\n\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_FALSE);\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terr = dmu_tx_assign(tx, TXG_WAIT);\n\tif (err != 0) {\n\t\tdmu_tx_abort(tx);\n\t\tgoto out;\n\t}\n\n\tif (zp->z_blksz < PAGE_SIZE) {\n\t\tfor (i = 0; len > 0; off += tocopy, len -= tocopy, i++) {\n\t\t\ttocopy = len > PAGE_SIZE ? PAGE_SIZE : len;\n\t\t\tva = zfs_map_page(ma[i], &sf);\n\t\t\tdmu_write(zfsvfs->z_os, zp->z_id, off, tocopy, va, tx);\n\t\t\tzfs_unmap_page(sf);\n\t\t}\n\t} else {\n\t\terr = dmu_write_pages(zfsvfs->z_os, zp->z_id, off, len, ma, tx);\n\t}\n\n\tif (err == 0) {\n\t\tuint64_t mtime[2], ctime[2];\n\t\tsa_bulk_attr_t bulk[3];\n\t\tint count = 0;\n\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MTIME(zfsvfs), NULL,\n\t\t    &mtime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t\t    &ctime, 16);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t\t    &zp->z_pflags, 8);\n\t\tzfs_tstamp_update_setup(zp, CONTENT_MODIFIED, mtime, ctime);\n\t\terr = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);\n\t\tASSERT0(err);\n\t\t \n\t\tzfs_log_write(zfsvfs->z_log, tx, TX_WRITE, zp, off,\n\t\t    len, 0, NULL, NULL);\n\n\t\tzfs_vmobject_wlock(object);\n\t\tfor (i = 0; i < ncount; i++) {\n\t\t\trtvals[i] = zfs_vm_pagerret_ok;\n\t\t\tvm_page_undirty(ma[i]);\n\t\t}\n\t\tzfs_vmobject_wunlock(object);\n\t\tVM_CNT_INC(v_vnodeout);\n\t\tVM_CNT_ADD(v_vnodepgsout, ncount);\n\t}\n\tdmu_tx_commit(tx);\n\nout:\n\tzfs_rangelock_exit(lr);\n\tif ((flags & (zfs_vm_pagerput_sync | zfs_vm_pagerput_inval)) != 0 ||\n\t    zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS)\n\t\tzil_commit(zfsvfs->z_log, zp->z_id);\n\n\tdataset_kstats_update_write_kstats(&zfsvfs->z_kstat, len);\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (rtvals[0]);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_putpages_args {\n\tstruct vnode *a_vp;\n\tvm_page_t *a_m;\n\tint a_count;\n\tint a_sync;\n\tint *a_rtvals;\n};\n#endif\n\nstatic int\nzfs_freebsd_putpages(struct vop_putpages_args *ap)\n{\n\n\treturn (zfs_putpages(ap->a_vp, ap->a_m, ap->a_count, ap->a_sync,\n\t    ap->a_rtvals));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_bmap_args {\n\tstruct vnode *a_vp;\n\tdaddr_t  a_bn;\n\tstruct bufobj **a_bop;\n\tdaddr_t *a_bnp;\n\tint *a_runp;\n\tint *a_runb;\n};\n#endif\n\nstatic int\nzfs_freebsd_bmap(struct vop_bmap_args *ap)\n{\n\n\tif (ap->a_bop != NULL)\n\t\t*ap->a_bop = &ap->a_vp->v_bufobj;\n\tif (ap->a_bnp != NULL)\n\t\t*ap->a_bnp = ap->a_bn;\n\tif (ap->a_runp != NULL)\n\t\t*ap->a_runp = 0;\n\tif (ap->a_runb != NULL)\n\t\t*ap->a_runb = 0;\n\n\treturn (0);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_open_args {\n\tstruct vnode *a_vp;\n\tint a_mode;\n\tstruct ucred *a_cred;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_open(struct vop_open_args *ap)\n{\n\tvnode_t\t*vp = ap->a_vp;\n\tznode_t *zp = VTOZ(vp);\n\tint error;\n\n\terror = zfs_open(&vp, ap->a_mode, ap->a_cred);\n\tif (error == 0)\n\t\tvnode_create_vobject(vp, zp->z_size, ap->a_td);\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_close_args {\n\tstruct vnode *a_vp;\n\tint  a_fflag;\n\tstruct ucred *a_cred;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_close(struct vop_close_args *ap)\n{\n\n\treturn (zfs_close(ap->a_vp, ap->a_fflag, 1, 0, ap->a_cred));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_ioctl_args {\n\tstruct vnode *a_vp;\n\tulong_t a_command;\n\tcaddr_t a_data;\n\tint a_fflag;\n\tstruct ucred *cred;\n\tstruct thread *td;\n};\n#endif\n\nstatic int\nzfs_freebsd_ioctl(struct vop_ioctl_args *ap)\n{\n\n\treturn (zfs_ioctl(ap->a_vp, ap->a_command, (intptr_t)ap->a_data,\n\t    ap->a_fflag, ap->a_cred, NULL));\n}\n\nstatic int\nioflags(int ioflags)\n{\n\tint flags = 0;\n\n\tif (ioflags & IO_APPEND)\n\t\tflags |= O_APPEND;\n\tif (ioflags & IO_NDELAY)\n\t\tflags |= O_NONBLOCK;\n\tif (ioflags & IO_SYNC)\n\t\tflags |= O_SYNC;\n\n\treturn (flags);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_read_args {\n\tstruct vnode *a_vp;\n\tstruct uio *a_uio;\n\tint a_ioflag;\n\tstruct ucred *a_cred;\n};\n#endif\n\nstatic int\nzfs_freebsd_read(struct vop_read_args *ap)\n{\n\tzfs_uio_t uio;\n\tzfs_uio_init(&uio, ap->a_uio);\n\treturn (zfs_read(VTOZ(ap->a_vp), &uio, ioflags(ap->a_ioflag),\n\t    ap->a_cred));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_write_args {\n\tstruct vnode *a_vp;\n\tstruct uio *a_uio;\n\tint a_ioflag;\n\tstruct ucred *a_cred;\n};\n#endif\n\nstatic int\nzfs_freebsd_write(struct vop_write_args *ap)\n{\n\tzfs_uio_t uio;\n\tzfs_uio_init(&uio, ap->a_uio);\n\treturn (zfs_write(VTOZ(ap->a_vp), &uio, ioflags(ap->a_ioflag),\n\t    ap->a_cred));\n}\n\n#if __FreeBSD_version >= 1300102\n \nstatic int\nzfs_freebsd_fplookup_vexec(struct vop_fplookup_vexec_args *v)\n{\n\tvnode_t *vp;\n\tznode_t *zp;\n\tuint64_t pflags;\n\n\tvp = v->a_vp;\n\tzp = VTOZ_SMR(vp);\n\tif (__predict_false(zp == NULL))\n\t\treturn (EAGAIN);\n\tpflags = atomic_load_64(&zp->z_pflags);\n\tif (pflags & ZFS_AV_QUARANTINED)\n\t\treturn (EAGAIN);\n\tif (pflags & ZFS_XATTR)\n\t\treturn (EAGAIN);\n\tif ((pflags & ZFS_NO_EXECS_DENIED) == 0)\n\t\treturn (EAGAIN);\n\treturn (0);\n}\n#endif\n\n#if __FreeBSD_version >= 1300139\nstatic int\nzfs_freebsd_fplookup_symlink(struct vop_fplookup_symlink_args *v)\n{\n\tvnode_t *vp;\n\tznode_t *zp;\n\tchar *target;\n\n\tvp = v->a_vp;\n\tzp = VTOZ_SMR(vp);\n\tif (__predict_false(zp == NULL)) {\n\t\treturn (EAGAIN);\n\t}\n\n\ttarget = atomic_load_consume_ptr(&zp->z_cached_symlink);\n\tif (target == NULL) {\n\t\treturn (EAGAIN);\n\t}\n\treturn (cache_symlink_resolve(v->a_fpl, target, strlen(target)));\n}\n#endif\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_access_args {\n\tstruct vnode *a_vp;\n\taccmode_t a_accmode;\n\tstruct ucred *a_cred;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_access(struct vop_access_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\tznode_t *zp = VTOZ(vp);\n\taccmode_t accmode;\n\tint error = 0;\n\n\n\tif (ap->a_accmode == VEXEC) {\n\t\tif (zfs_fastaccesschk_execute(zp, ap->a_cred) == 0)\n\t\t\treturn (0);\n\t}\n\n\t \n\taccmode = ap->a_accmode & (VREAD|VWRITE|VEXEC|VAPPEND);\n\tif (accmode != 0)\n\t\terror = zfs_access(zp, accmode, 0, ap->a_cred);\n\n\t \n\tif (error == 0) {\n\t\taccmode = ap->a_accmode & ~(VREAD|VWRITE|VEXEC|VAPPEND);\n\t\tif (accmode != 0) {\n#if __FreeBSD_version >= 1300105\n\t\t\terror = vaccess(vp->v_type, zp->z_mode, zp->z_uid,\n\t\t\t    zp->z_gid, accmode, ap->a_cred);\n#else\n\t\t\terror = vaccess(vp->v_type, zp->z_mode, zp->z_uid,\n\t\t\t    zp->z_gid, accmode, ap->a_cred, NULL);\n#endif\n\t\t}\n\t}\n\n\t \n\tif (error == 0 && (ap->a_accmode & VEXEC) != 0 && vp->v_type != VDIR &&\n\t    (zp->z_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0) {\n\t\terror = EACCES;\n\t}\n\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_lookup_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode **a_vpp;\n\tstruct componentname *a_cnp;\n};\n#endif\n\nstatic int\nzfs_freebsd_lookup(struct vop_lookup_args *ap, boolean_t cached)\n{\n\tstruct componentname *cnp = ap->a_cnp;\n\tchar nm[NAME_MAX + 1];\n\n\tASSERT3U(cnp->cn_namelen, <, sizeof (nm));\n\tstrlcpy(nm, cnp->cn_nameptr, MIN(cnp->cn_namelen + 1, sizeof (nm)));\n\n\treturn (zfs_lookup(ap->a_dvp, nm, ap->a_vpp, cnp, cnp->cn_nameiop,\n\t    cnp->cn_cred, 0, cached));\n}\n\nstatic int\nzfs_freebsd_cachedlookup(struct vop_cachedlookup_args *ap)\n{\n\n\treturn (zfs_freebsd_lookup((struct vop_lookup_args *)ap, B_TRUE));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_lookup_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode **a_vpp;\n\tstruct componentname *a_cnp;\n};\n#endif\n\nstatic int\nzfs_cache_lookup(struct vop_lookup_args *ap)\n{\n\tzfsvfs_t *zfsvfs;\n\n\tzfsvfs = ap->a_dvp->v_mount->mnt_data;\n\tif (zfsvfs->z_use_namecache)\n\t\treturn (vfs_cache_lookup(ap));\n\telse\n\t\treturn (zfs_freebsd_lookup(ap, B_FALSE));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_create_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode **a_vpp;\n\tstruct componentname *a_cnp;\n\tstruct vattr *a_vap;\n};\n#endif\n\nstatic int\nzfs_freebsd_create(struct vop_create_args *ap)\n{\n\tzfsvfs_t *zfsvfs;\n\tstruct componentname *cnp = ap->a_cnp;\n\tvattr_t *vap = ap->a_vap;\n\tznode_t *zp = NULL;\n\tint rc, mode;\n\n#if __FreeBSD_version < 1400068\n\tASSERT(cnp->cn_flags & SAVENAME);\n#endif\n\n\tvattr_init_mask(vap);\n\tmode = vap->va_mode & ALLPERMS;\n\tzfsvfs = ap->a_dvp->v_mount->mnt_data;\n\t*ap->a_vpp = NULL;\n\n\trc = zfs_create(VTOZ(ap->a_dvp), cnp->cn_nameptr, vap, 0, mode,\n\t    &zp, cnp->cn_cred, 0  , NULL  , NULL);\n\tif (rc == 0)\n\t\t*ap->a_vpp = ZTOV(zp);\n\tif (zfsvfs->z_use_namecache &&\n\t    rc == 0 && (cnp->cn_flags & MAKEENTRY) != 0)\n\t\tcache_enter(ap->a_dvp, *ap->a_vpp, cnp);\n\n\treturn (rc);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_remove_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode *a_vp;\n\tstruct componentname *a_cnp;\n};\n#endif\n\nstatic int\nzfs_freebsd_remove(struct vop_remove_args *ap)\n{\n\n#if __FreeBSD_version < 1400068\n\tASSERT(ap->a_cnp->cn_flags & SAVENAME);\n#endif\n\n\treturn (zfs_remove_(ap->a_dvp, ap->a_vp, ap->a_cnp->cn_nameptr,\n\t    ap->a_cnp->cn_cred));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_mkdir_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode **a_vpp;\n\tstruct componentname *a_cnp;\n\tstruct vattr *a_vap;\n};\n#endif\n\nstatic int\nzfs_freebsd_mkdir(struct vop_mkdir_args *ap)\n{\n\tvattr_t *vap = ap->a_vap;\n\tznode_t *zp = NULL;\n\tint rc;\n\n#if __FreeBSD_version < 1400068\n\tASSERT(ap->a_cnp->cn_flags & SAVENAME);\n#endif\n\n\tvattr_init_mask(vap);\n\t*ap->a_vpp = NULL;\n\n\trc = zfs_mkdir(VTOZ(ap->a_dvp), ap->a_cnp->cn_nameptr, vap, &zp,\n\t    ap->a_cnp->cn_cred, 0, NULL, NULL);\n\n\tif (rc == 0)\n\t\t*ap->a_vpp = ZTOV(zp);\n\treturn (rc);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_rmdir_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode *a_vp;\n\tstruct componentname *a_cnp;\n};\n#endif\n\nstatic int\nzfs_freebsd_rmdir(struct vop_rmdir_args *ap)\n{\n\tstruct componentname *cnp = ap->a_cnp;\n\n#if __FreeBSD_version < 1400068\n\tASSERT(cnp->cn_flags & SAVENAME);\n#endif\n\n\treturn (zfs_rmdir_(ap->a_dvp, ap->a_vp, cnp->cn_nameptr, cnp->cn_cred));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_readdir_args {\n\tstruct vnode *a_vp;\n\tstruct uio *a_uio;\n\tstruct ucred *a_cred;\n\tint *a_eofflag;\n\tint *a_ncookies;\n\tcookie_t **a_cookies;\n};\n#endif\n\nstatic int\nzfs_freebsd_readdir(struct vop_readdir_args *ap)\n{\n\tzfs_uio_t uio;\n\tzfs_uio_init(&uio, ap->a_uio);\n\treturn (zfs_readdir(ap->a_vp, &uio, ap->a_cred, ap->a_eofflag,\n\t    ap->a_ncookies, ap->a_cookies));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_fsync_args {\n\tstruct vnode *a_vp;\n\tint a_waitfor;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_fsync(struct vop_fsync_args *ap)\n{\n\n\treturn (zfs_fsync(VTOZ(ap->a_vp), 0, ap->a_td->td_ucred));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_getattr_args {\n\tstruct vnode *a_vp;\n\tstruct vattr *a_vap;\n\tstruct ucred *a_cred;\n};\n#endif\n\nstatic int\nzfs_freebsd_getattr(struct vop_getattr_args *ap)\n{\n\tvattr_t *vap = ap->a_vap;\n\txvattr_t xvap;\n\tulong_t fflags = 0;\n\tint error;\n\n\txva_init(&xvap);\n\txvap.xva_vattr = *vap;\n\txvap.xva_vattr.va_mask |= AT_XVATTR;\n\n\t \n\t \n\tXVA_SET_REQ(&xvap, XAT_IMMUTABLE);\n\tXVA_SET_REQ(&xvap, XAT_APPENDONLY);\n\tXVA_SET_REQ(&xvap, XAT_NOUNLINK);\n\tXVA_SET_REQ(&xvap, XAT_NODUMP);\n\tXVA_SET_REQ(&xvap, XAT_READONLY);\n\tXVA_SET_REQ(&xvap, XAT_ARCHIVE);\n\tXVA_SET_REQ(&xvap, XAT_SYSTEM);\n\tXVA_SET_REQ(&xvap, XAT_HIDDEN);\n\tXVA_SET_REQ(&xvap, XAT_REPARSE);\n\tXVA_SET_REQ(&xvap, XAT_OFFLINE);\n\tXVA_SET_REQ(&xvap, XAT_SPARSE);\n\n\terror = zfs_getattr(ap->a_vp, (vattr_t *)&xvap, 0, ap->a_cred);\n\tif (error != 0)\n\t\treturn (error);\n\n\t \n#define\tFLAG_CHECK(fflag, xflag, xfield)\tdo {\t\t\t\\\n\tif (XVA_ISSET_RTN(&xvap, (xflag)) && (xfield) != 0)\t\t\\\n\t\tfflags |= (fflag);\t\t\t\t\t\\\n} while (0)\n\tFLAG_CHECK(SF_IMMUTABLE, XAT_IMMUTABLE,\n\t    xvap.xva_xoptattrs.xoa_immutable);\n\tFLAG_CHECK(SF_APPEND, XAT_APPENDONLY,\n\t    xvap.xva_xoptattrs.xoa_appendonly);\n\tFLAG_CHECK(SF_NOUNLINK, XAT_NOUNLINK,\n\t    xvap.xva_xoptattrs.xoa_nounlink);\n\tFLAG_CHECK(UF_ARCHIVE, XAT_ARCHIVE,\n\t    xvap.xva_xoptattrs.xoa_archive);\n\tFLAG_CHECK(UF_NODUMP, XAT_NODUMP,\n\t    xvap.xva_xoptattrs.xoa_nodump);\n\tFLAG_CHECK(UF_READONLY, XAT_READONLY,\n\t    xvap.xva_xoptattrs.xoa_readonly);\n\tFLAG_CHECK(UF_SYSTEM, XAT_SYSTEM,\n\t    xvap.xva_xoptattrs.xoa_system);\n\tFLAG_CHECK(UF_HIDDEN, XAT_HIDDEN,\n\t    xvap.xva_xoptattrs.xoa_hidden);\n\tFLAG_CHECK(UF_REPARSE, XAT_REPARSE,\n\t    xvap.xva_xoptattrs.xoa_reparse);\n\tFLAG_CHECK(UF_OFFLINE, XAT_OFFLINE,\n\t    xvap.xva_xoptattrs.xoa_offline);\n\tFLAG_CHECK(UF_SPARSE, XAT_SPARSE,\n\t    xvap.xva_xoptattrs.xoa_sparse);\n\n#undef\tFLAG_CHECK\n\t*vap = xvap.xva_vattr;\n\tvap->va_flags = fflags;\n\treturn (0);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_setattr_args {\n\tstruct vnode *a_vp;\n\tstruct vattr *a_vap;\n\tstruct ucred *a_cred;\n};\n#endif\n\nstatic int\nzfs_freebsd_setattr(struct vop_setattr_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\tvattr_t *vap = ap->a_vap;\n\tcred_t *cred = ap->a_cred;\n\txvattr_t xvap;\n\tulong_t fflags;\n\tuint64_t zflags;\n\n\tvattr_init_mask(vap);\n\tvap->va_mask &= ~AT_NOSET;\n\n\txva_init(&xvap);\n\txvap.xva_vattr = *vap;\n\n\tzflags = VTOZ(vp)->z_pflags;\n\n\tif (vap->va_flags != VNOVAL) {\n\t\tzfsvfs_t *zfsvfs = VTOZ(vp)->z_zfsvfs;\n\t\tint error;\n\n\t\tif (zfsvfs->z_use_fuids == B_FALSE)\n\t\t\treturn (EOPNOTSUPP);\n\n\t\tfflags = vap->va_flags;\n\t\t \n\t\tif ((fflags & ~(SF_IMMUTABLE|SF_APPEND|SF_NOUNLINK|UF_ARCHIVE|\n\t\t    UF_NODUMP|UF_SYSTEM|UF_HIDDEN|UF_READONLY|UF_REPARSE|\n\t\t    UF_OFFLINE|UF_SPARSE)) != 0)\n\t\t\treturn (EOPNOTSUPP);\n\t\t \n\t\tif (secpolicy_fs_owner(vp->v_mount, cred) == 0 ||\n\t\t    spl_priv_check_cred(cred, PRIV_VFS_SYSFLAGS) == 0) {\n\t\t\tif (zflags &\n\t\t\t    (ZFS_IMMUTABLE | ZFS_APPENDONLY | ZFS_NOUNLINK)) {\n\t\t\t\terror = securelevel_gt(cred, 0);\n\t\t\t\tif (error != 0)\n\t\t\t\t\treturn (error);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((error = VOP_ACCESS(vp, VADMIN, cred,\n\t\t\t    curthread)) != 0)\n\t\t\t\treturn (error);\n\t\t\tif (zflags &\n\t\t\t    (ZFS_IMMUTABLE | ZFS_APPENDONLY |\n\t\t\t    ZFS_NOUNLINK)) {\n\t\t\t\treturn (EPERM);\n\t\t\t}\n\t\t\tif (fflags &\n\t\t\t    (SF_IMMUTABLE | SF_APPEND | SF_NOUNLINK)) {\n\t\t\t\treturn (EPERM);\n\t\t\t}\n\t\t}\n\n#define\tFLAG_CHANGE(fflag, zflag, xflag, xfield)\tdo {\t\t\\\n\tif (((fflags & (fflag)) && !(zflags & (zflag))) ||\t\t\\\n\t    ((zflags & (zflag)) && !(fflags & (fflag)))) {\t\t\\\n\t\tXVA_SET_REQ(&xvap, (xflag));\t\t\t\t\\\n\t\t(xfield) = ((fflags & (fflag)) != 0);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\t\t \n\t\t \n\t\tFLAG_CHANGE(SF_IMMUTABLE, ZFS_IMMUTABLE, XAT_IMMUTABLE,\n\t\t    xvap.xva_xoptattrs.xoa_immutable);\n\t\tFLAG_CHANGE(SF_APPEND, ZFS_APPENDONLY, XAT_APPENDONLY,\n\t\t    xvap.xva_xoptattrs.xoa_appendonly);\n\t\tFLAG_CHANGE(SF_NOUNLINK, ZFS_NOUNLINK, XAT_NOUNLINK,\n\t\t    xvap.xva_xoptattrs.xoa_nounlink);\n\t\tFLAG_CHANGE(UF_ARCHIVE, ZFS_ARCHIVE, XAT_ARCHIVE,\n\t\t    xvap.xva_xoptattrs.xoa_archive);\n\t\tFLAG_CHANGE(UF_NODUMP, ZFS_NODUMP, XAT_NODUMP,\n\t\t    xvap.xva_xoptattrs.xoa_nodump);\n\t\tFLAG_CHANGE(UF_READONLY, ZFS_READONLY, XAT_READONLY,\n\t\t    xvap.xva_xoptattrs.xoa_readonly);\n\t\tFLAG_CHANGE(UF_SYSTEM, ZFS_SYSTEM, XAT_SYSTEM,\n\t\t    xvap.xva_xoptattrs.xoa_system);\n\t\tFLAG_CHANGE(UF_HIDDEN, ZFS_HIDDEN, XAT_HIDDEN,\n\t\t    xvap.xva_xoptattrs.xoa_hidden);\n\t\tFLAG_CHANGE(UF_REPARSE, ZFS_REPARSE, XAT_REPARSE,\n\t\t    xvap.xva_xoptattrs.xoa_reparse);\n\t\tFLAG_CHANGE(UF_OFFLINE, ZFS_OFFLINE, XAT_OFFLINE,\n\t\t    xvap.xva_xoptattrs.xoa_offline);\n\t\tFLAG_CHANGE(UF_SPARSE, ZFS_SPARSE, XAT_SPARSE,\n\t\t    xvap.xva_xoptattrs.xoa_sparse);\n#undef\tFLAG_CHANGE\n\t}\n\tif (vap->va_birthtime.tv_sec != VNOVAL) {\n\t\txvap.xva_vattr.va_mask |= AT_XVATTR;\n\t\tXVA_SET_REQ(&xvap, XAT_CREATETIME);\n\t}\n\treturn (zfs_setattr(VTOZ(vp), (vattr_t *)&xvap, 0, cred, NULL));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_rename_args {\n\tstruct vnode *a_fdvp;\n\tstruct vnode *a_fvp;\n\tstruct componentname *a_fcnp;\n\tstruct vnode *a_tdvp;\n\tstruct vnode *a_tvp;\n\tstruct componentname *a_tcnp;\n};\n#endif\n\nstatic int\nzfs_freebsd_rename(struct vop_rename_args *ap)\n{\n\tvnode_t *fdvp = ap->a_fdvp;\n\tvnode_t *fvp = ap->a_fvp;\n\tvnode_t *tdvp = ap->a_tdvp;\n\tvnode_t *tvp = ap->a_tvp;\n\tint error;\n\n#if __FreeBSD_version < 1400068\n\tASSERT(ap->a_fcnp->cn_flags & (SAVENAME|SAVESTART));\n\tASSERT(ap->a_tcnp->cn_flags & (SAVENAME|SAVESTART));\n#endif\n\n\terror = zfs_do_rename(fdvp, &fvp, ap->a_fcnp, tdvp, &tvp,\n\t    ap->a_tcnp, ap->a_fcnp->cn_cred);\n\n\tvrele(fdvp);\n\tvrele(fvp);\n\tvrele(tdvp);\n\tif (tvp != NULL)\n\t\tvrele(tvp);\n\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_symlink_args {\n\tstruct vnode *a_dvp;\n\tstruct vnode **a_vpp;\n\tstruct componentname *a_cnp;\n\tstruct vattr *a_vap;\n\tchar *a_target;\n};\n#endif\n\nstatic int\nzfs_freebsd_symlink(struct vop_symlink_args *ap)\n{\n\tstruct componentname *cnp = ap->a_cnp;\n\tvattr_t *vap = ap->a_vap;\n\tznode_t *zp = NULL;\n#if __FreeBSD_version >= 1300139\n\tchar *symlink;\n\tsize_t symlink_len;\n#endif\n\tint rc;\n\n#if __FreeBSD_version < 1400068\n\tASSERT(cnp->cn_flags & SAVENAME);\n#endif\n\n\tvap->va_type = VLNK;\t \n\tvattr_init_mask(vap);\n\t*ap->a_vpp = NULL;\n\n\trc = zfs_symlink(VTOZ(ap->a_dvp), cnp->cn_nameptr, vap,\n\t    ap->a_target, &zp, cnp->cn_cred, 0  , NULL);\n\tif (rc == 0) {\n\t\t*ap->a_vpp = ZTOV(zp);\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n#if __FreeBSD_version >= 1300139\n\t\tMPASS(zp->z_cached_symlink == NULL);\n\t\tsymlink_len = strlen(ap->a_target);\n\t\tsymlink = cache_symlink_alloc(symlink_len + 1, M_WAITOK);\n\t\tif (symlink != NULL) {\n\t\t\tmemcpy(symlink, ap->a_target, symlink_len);\n\t\t\tsymlink[symlink_len] = '\\0';\n\t\t\tatomic_store_rel_ptr((uintptr_t *)&zp->z_cached_symlink,\n\t\t\t    (uintptr_t)symlink);\n\t\t}\n#endif\n\t}\n\treturn (rc);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_readlink_args {\n\tstruct vnode *a_vp;\n\tstruct uio *a_uio;\n\tstruct ucred *a_cred;\n};\n#endif\n\nstatic int\nzfs_freebsd_readlink(struct vop_readlink_args *ap)\n{\n\tzfs_uio_t uio;\n\tint error;\n#if __FreeBSD_version >= 1300139\n\tznode_t\t*zp = VTOZ(ap->a_vp);\n\tchar *symlink, *base;\n\tsize_t symlink_len;\n\tbool trycache;\n#endif\n\n\tzfs_uio_init(&uio, ap->a_uio);\n#if __FreeBSD_version >= 1300139\n\ttrycache = false;\n\tif (zfs_uio_segflg(&uio) == UIO_SYSSPACE &&\n\t    zfs_uio_iovcnt(&uio) == 1) {\n\t\tbase = zfs_uio_iovbase(&uio, 0);\n\t\tsymlink_len = zfs_uio_iovlen(&uio, 0);\n\t\ttrycache = true;\n\t}\n#endif\n\terror = zfs_readlink(ap->a_vp, &uio, ap->a_cred, NULL);\n#if __FreeBSD_version >= 1300139\n\tif (atomic_load_ptr(&zp->z_cached_symlink) != NULL ||\n\t    error != 0 || !trycache) {\n\t\treturn (error);\n\t}\n\tsymlink_len -= zfs_uio_resid(&uio);\n\tsymlink = cache_symlink_alloc(symlink_len + 1, M_WAITOK);\n\tif (symlink != NULL) {\n\t\tmemcpy(symlink, base, symlink_len);\n\t\tsymlink[symlink_len] = '\\0';\n\t\tif (!atomic_cmpset_rel_ptr((uintptr_t *)&zp->z_cached_symlink,\n\t\t    (uintptr_t)NULL, (uintptr_t)symlink)) {\n\t\t\tcache_symlink_free(symlink, symlink_len + 1);\n\t\t}\n\t}\n#endif\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_link_args {\n\tstruct vnode *a_tdvp;\n\tstruct vnode *a_vp;\n\tstruct componentname *a_cnp;\n};\n#endif\n\nstatic int\nzfs_freebsd_link(struct vop_link_args *ap)\n{\n\tstruct componentname *cnp = ap->a_cnp;\n\tvnode_t *vp = ap->a_vp;\n\tvnode_t *tdvp = ap->a_tdvp;\n\n\tif (tdvp->v_mount != vp->v_mount)\n\t\treturn (EXDEV);\n\n#if __FreeBSD_version < 1400068\n\tASSERT(cnp->cn_flags & SAVENAME);\n#endif\n\n\treturn (zfs_link(VTOZ(tdvp), VTOZ(vp),\n\t    cnp->cn_nameptr, cnp->cn_cred, 0));\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_inactive_args {\n\tstruct vnode *a_vp;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_inactive(struct vop_inactive_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\n#if __FreeBSD_version >= 1300123\n\tzfs_inactive(vp, curthread->td_ucred, NULL);\n#else\n\tzfs_inactive(vp, ap->a_td->td_ucred, NULL);\n#endif\n\treturn (0);\n}\n\n#if __FreeBSD_version >= 1300042\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_need_inactive_args {\n\tstruct vnode *a_vp;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_need_inactive(struct vop_need_inactive_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\tznode_t\t*zp = VTOZ(vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tint need;\n\n\tif (vn_need_pageq_flush(vp))\n\t\treturn (1);\n\n\tif (!ZFS_TEARDOWN_INACTIVE_TRY_ENTER_READ(zfsvfs))\n\t\treturn (1);\n\tneed = (zp->z_sa_hdl == NULL || zp->z_unlinked || zp->z_atime_dirty);\n\tZFS_TEARDOWN_INACTIVE_EXIT_READ(zfsvfs);\n\n\treturn (need);\n}\n#endif\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_reclaim_args {\n\tstruct vnode *a_vp;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_freebsd_reclaim(struct vop_reclaim_args *ap)\n{\n\tvnode_t\t*vp = ap->a_vp;\n\tznode_t\t*zp = VTOZ(vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\n\tASSERT3P(zp, !=, NULL);\n\n#if __FreeBSD_version < 1300042\n\t \n\tvnode_destroy_vobject(vp);\n#endif\n\t \n\tZFS_TEARDOWN_INACTIVE_ENTER_READ(zfsvfs);\n\tif (zp->z_sa_hdl == NULL)\n\t\tzfs_znode_free(zp);\n\telse\n\t\tzfs_zinactive(zp);\n\tZFS_TEARDOWN_INACTIVE_EXIT_READ(zfsvfs);\n\n\tvp->v_data = NULL;\n\treturn (0);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_fid_args {\n\tstruct vnode *a_vp;\n\tstruct fid *a_fid;\n};\n#endif\n\nstatic int\nzfs_freebsd_fid(struct vop_fid_args *ap)\n{\n\n\treturn (zfs_fid(ap->a_vp, (void *)ap->a_fid, NULL));\n}\n\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_pathconf_args {\n\tstruct vnode *a_vp;\n\tint a_name;\n\tregister_t *a_retval;\n} *ap;\n#endif\n\nstatic int\nzfs_freebsd_pathconf(struct vop_pathconf_args *ap)\n{\n\tulong_t val;\n\tint error;\n\n\terror = zfs_pathconf(ap->a_vp, ap->a_name, &val,\n\t    curthread->td_ucred, NULL);\n\tif (error == 0) {\n\t\t*ap->a_retval = val;\n\t\treturn (error);\n\t}\n\tif (error != EOPNOTSUPP)\n\t\treturn (error);\n\n\tswitch (ap->a_name) {\n\tcase _PC_NAME_MAX:\n\t\t*ap->a_retval = NAME_MAX;\n\t\treturn (0);\n#if __FreeBSD_version >= 1400032\n\tcase _PC_DEALLOC_PRESENT:\n\t\t*ap->a_retval = 1;\n\t\treturn (0);\n#endif\n\tcase _PC_PIPE_BUF:\n\t\tif (ap->a_vp->v_type == VDIR || ap->a_vp->v_type == VFIFO) {\n\t\t\t*ap->a_retval = PIPE_BUF;\n\t\t\treturn (0);\n\t\t}\n\t\treturn (EINVAL);\n\tdefault:\n\t\treturn (vop_stdpathconf(ap));\n\t}\n}\n\nstatic int zfs_xattr_compat = 1;\n\nstatic int\nzfs_check_attrname(const char *name)\n{\n\t \n\tif (strchr(name, '/') != NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\t \n\tif (ZFS_XA_NS_PREFIX_FORBIDDEN(name))\n\t\treturn (SET_ERROR(EINVAL));\n\treturn (0);\n}\n\n \nstatic int\nzfs_create_attrname(int attrnamespace, const char *name, char *attrname,\n    size_t size, boolean_t compat)\n{\n\tconst char *namespace, *prefix, *suffix;\n\n\tmemset(attrname, 0, size);\n\n\tswitch (attrnamespace) {\n\tcase EXTATTR_NAMESPACE_USER:\n\t\tif (compat) {\n\t\t\t \n\t\t\tprefix = namespace = suffix = \"\";\n\t\t} else {\n\t\t\t \n\t\t\tprefix = \"\";\n\t\t\tnamespace = \"user\";\n\t\t\tsuffix = \".\";\n\t\t}\n\t\tbreak;\n\tcase EXTATTR_NAMESPACE_SYSTEM:\n\t\tprefix = \"freebsd:\";\n\t\tnamespace = EXTATTR_NAMESPACE_SYSTEM_STRING;\n\t\tsuffix = \":\";\n\t\tbreak;\n\tcase EXTATTR_NAMESPACE_EMPTY:\n\tdefault:\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\tif (snprintf(attrname, size, \"%s%s%s%s\", prefix, namespace, suffix,\n\t    name) >= size) {\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_ensure_xattr_cached(znode_t *zp)\n{\n\tint error = 0;\n\n\tASSERT(RW_LOCK_HELD(&zp->z_xattr_lock));\n\n\tif (zp->z_xattr_cached != NULL)\n\t\treturn (0);\n\n\tif (rw_write_held(&zp->z_xattr_lock))\n\t\treturn (zfs_sa_get_xattr(zp));\n\n\tif (!rw_tryupgrade(&zp->z_xattr_lock)) {\n\t\trw_exit(&zp->z_xattr_lock);\n\t\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\t}\n\tif (zp->z_xattr_cached == NULL)\n\t\terror = zfs_sa_get_xattr(zp);\n\trw_downgrade(&zp->z_xattr_lock);\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_getextattr {\n\tIN struct vnode *a_vp;\n\tIN int a_attrnamespace;\n\tIN const char *a_name;\n\tINOUT struct uio *a_uio;\n\tOUT size_t *a_size;\n\tIN struct ucred *a_cred;\n\tIN struct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_getextattr_dir(struct vop_getextattr_args *ap, const char *attrname)\n{\n\tstruct thread *td = ap->a_td;\n\tstruct nameidata nd;\n\tstruct vattr va;\n\tvnode_t *xvp = NULL, *vp;\n\tint error, flags;\n\n\terror = zfs_lookup(ap->a_vp, NULL, &xvp, NULL, 0, ap->a_cred,\n\t    LOOKUP_XATTR, B_FALSE);\n\tif (error != 0)\n\t\treturn (error);\n\n\tflags = FREAD;\n#if __FreeBSD_version < 1400043\n\tNDINIT_ATVP(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, attrname,\n\t    xvp, td);\n#else\n\tNDINIT_ATVP(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, attrname, xvp);\n#endif\n\terror = vn_open_cred(&nd, &flags, 0, VN_OPEN_INVFS, ap->a_cred, NULL);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\tvp = nd.ni_vp;\n\tNDFREE_PNBUF(&nd);\n\n\tif (ap->a_size != NULL) {\n\t\terror = VOP_GETATTR(vp, &va, ap->a_cred);\n\t\tif (error == 0)\n\t\t\t*ap->a_size = (size_t)va.va_size;\n\t} else if (ap->a_uio != NULL)\n\t\terror = VOP_READ(vp, ap->a_uio, IO_UNIT, ap->a_cred);\n\n\tVOP_UNLOCK1(vp);\n\tvn_close(vp, flags, ap->a_cred, td);\n\treturn (error);\n}\n\nstatic int\nzfs_getextattr_sa(struct vop_getextattr_args *ap, const char *attrname)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tuchar_t *nv_value;\n\tuint_t nv_size;\n\tint error;\n\n\terror = zfs_ensure_xattr_cached(zp);\n\tif (error != 0)\n\t\treturn (error);\n\n\tASSERT(RW_LOCK_HELD(&zp->z_xattr_lock));\n\tASSERT3P(zp->z_xattr_cached, !=, NULL);\n\n\terror = nvlist_lookup_byte_array(zp->z_xattr_cached, attrname,\n\t    &nv_value, &nv_size);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\tif (ap->a_size != NULL)\n\t\t*ap->a_size = nv_size;\n\telse if (ap->a_uio != NULL)\n\t\terror = uiomove(nv_value, nv_size, ap->a_uio);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\treturn (0);\n}\n\nstatic int\nzfs_getextattr_impl(struct vop_getextattr_args *ap, boolean_t compat)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tchar attrname[EXTATTR_MAXNAMELEN+1];\n\tint error;\n\n\terror = zfs_create_attrname(ap->a_attrnamespace, ap->a_name, attrname,\n\t    sizeof (attrname), compat);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = ENOENT;\n\tif (zfsvfs->z_use_sa && zp->z_is_sa)\n\t\terror = zfs_getextattr_sa(ap, attrname);\n\tif (error == ENOENT)\n\t\terror = zfs_getextattr_dir(ap, attrname);\n\treturn (error);\n}\n\n \nstatic int\nzfs_getextattr(struct vop_getextattr_args *ap)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\t \n\tif (!(zfsvfs->z_flags & ZSB_XATTR))\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\n\terror = extattr_check_cred(ap->a_vp, ap->a_attrnamespace,\n\t    ap->a_cred, ap->a_td, VREAD);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\terror = zfs_check_attrname(ap->a_name);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\terror = ENOENT;\n\trw_enter(&zp->z_xattr_lock, RW_READER);\n\n\terror = zfs_getextattr_impl(ap, zfs_xattr_compat);\n\tif ((error == ENOENT || error == ENOATTR) &&\n\t    ap->a_attrnamespace == EXTATTR_NAMESPACE_USER) {\n\t\t \n\t\terror = zfs_getextattr_impl(ap, !zfs_xattr_compat);\n\t}\n\n\trw_exit(&zp->z_xattr_lock);\n\tzfs_exit(zfsvfs, FTAG);\n\tif (error == ENOENT)\n\t\terror = SET_ERROR(ENOATTR);\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_deleteextattr {\n\tIN struct vnode *a_vp;\n\tIN int a_attrnamespace;\n\tIN const char *a_name;\n\tIN struct ucred *a_cred;\n\tIN struct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_deleteextattr_dir(struct vop_deleteextattr_args *ap, const char *attrname)\n{\n\tstruct nameidata nd;\n\tvnode_t *xvp = NULL, *vp;\n\tint error;\n\n\terror = zfs_lookup(ap->a_vp, NULL, &xvp, NULL, 0, ap->a_cred,\n\t    LOOKUP_XATTR, B_FALSE);\n\tif (error != 0)\n\t\treturn (error);\n\n#if __FreeBSD_version < 1400043\n\tNDINIT_ATVP(&nd, DELETE, NOFOLLOW | LOCKPARENT | LOCKLEAF,\n\t    UIO_SYSSPACE, attrname, xvp, ap->a_td);\n#else\n\tNDINIT_ATVP(&nd, DELETE, NOFOLLOW | LOCKPARENT | LOCKLEAF,\n\t    UIO_SYSSPACE, attrname, xvp);\n#endif\n\terror = namei(&nd);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\tvp = nd.ni_vp;\n\terror = VOP_REMOVE(nd.ni_dvp, vp, &nd.ni_cnd);\n\tNDFREE_PNBUF(&nd);\n\n\tvput(nd.ni_dvp);\n\tif (vp == nd.ni_dvp)\n\t\tvrele(vp);\n\telse\n\t\tvput(vp);\n\n\treturn (error);\n}\n\nstatic int\nzfs_deleteextattr_sa(struct vop_deleteextattr_args *ap, const char *attrname)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tnvlist_t *nvl;\n\tint error;\n\n\terror = zfs_ensure_xattr_cached(zp);\n\tif (error != 0)\n\t\treturn (error);\n\n\tASSERT(RW_WRITE_HELD(&zp->z_xattr_lock));\n\tASSERT3P(zp->z_xattr_cached, !=, NULL);\n\n\tnvl = zp->z_xattr_cached;\n\terror = nvlist_remove(nvl, attrname, DATA_TYPE_BYTE_ARRAY);\n\tif (error != 0)\n\t\terror = SET_ERROR(error);\n\telse\n\t\terror = zfs_sa_set_xattr(zp, attrname, NULL, 0);\n\tif (error != 0) {\n\t\tzp->z_xattr_cached = NULL;\n\t\tnvlist_free(nvl);\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_deleteextattr_impl(struct vop_deleteextattr_args *ap, boolean_t compat)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tchar attrname[EXTATTR_MAXNAMELEN+1];\n\tint error;\n\n\terror = zfs_create_attrname(ap->a_attrnamespace, ap->a_name, attrname,\n\t    sizeof (attrname), compat);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = ENOENT;\n\tif (zfsvfs->z_use_sa && zp->z_is_sa)\n\t\terror = zfs_deleteextattr_sa(ap, attrname);\n\tif (error == ENOENT)\n\t\terror = zfs_deleteextattr_dir(ap, attrname);\n\treturn (error);\n}\n\n \nstatic int\nzfs_deleteextattr(struct vop_deleteextattr_args *ap)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\t \n\tif (!(zfsvfs->z_flags & ZSB_XATTR))\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\n\terror = extattr_check_cred(ap->a_vp, ap->a_attrnamespace,\n\t    ap->a_cred, ap->a_td, VWRITE);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\terror = zfs_check_attrname(ap->a_name);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\n\terror = zfs_deleteextattr_impl(ap, zfs_xattr_compat);\n\tif ((error == ENOENT || error == ENOATTR) &&\n\t    ap->a_attrnamespace == EXTATTR_NAMESPACE_USER) {\n\t\t \n\t\terror = zfs_deleteextattr_impl(ap, !zfs_xattr_compat);\n\t}\n\n\trw_exit(&zp->z_xattr_lock);\n\tzfs_exit(zfsvfs, FTAG);\n\tif (error == ENOENT)\n\t\terror = SET_ERROR(ENOATTR);\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_setextattr {\n\tIN struct vnode *a_vp;\n\tIN int a_attrnamespace;\n\tIN const char *a_name;\n\tINOUT struct uio *a_uio;\n\tIN struct ucred *a_cred;\n\tIN struct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_setextattr_dir(struct vop_setextattr_args *ap, const char *attrname)\n{\n\tstruct thread *td = ap->a_td;\n\tstruct nameidata nd;\n\tstruct vattr va;\n\tvnode_t *xvp = NULL, *vp;\n\tint error, flags;\n\n\terror = zfs_lookup(ap->a_vp, NULL, &xvp, NULL, 0, ap->a_cred,\n\t    LOOKUP_XATTR | CREATE_XATTR_DIR, B_FALSE);\n\tif (error != 0)\n\t\treturn (error);\n\n\tflags = FFLAGS(O_WRONLY | O_CREAT);\n#if __FreeBSD_version < 1400043\n\tNDINIT_ATVP(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, attrname, xvp, td);\n#else\n\tNDINIT_ATVP(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, attrname, xvp);\n#endif\n\terror = vn_open_cred(&nd, &flags, 0600, VN_OPEN_INVFS, ap->a_cred,\n\t    NULL);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\tvp = nd.ni_vp;\n\tNDFREE_PNBUF(&nd);\n\n\tVATTR_NULL(&va);\n\tva.va_size = 0;\n\terror = VOP_SETATTR(vp, &va, ap->a_cred);\n\tif (error == 0)\n\t\tVOP_WRITE(vp, ap->a_uio, IO_UNIT, ap->a_cred);\n\n\tVOP_UNLOCK1(vp);\n\tvn_close(vp, flags, ap->a_cred, td);\n\treturn (error);\n}\n\nstatic int\nzfs_setextattr_sa(struct vop_setextattr_args *ap, const char *attrname)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tnvlist_t *nvl;\n\tsize_t sa_size;\n\tint error;\n\n\terror = zfs_ensure_xattr_cached(zp);\n\tif (error != 0)\n\t\treturn (error);\n\n\tASSERT(RW_WRITE_HELD(&zp->z_xattr_lock));\n\tASSERT3P(zp->z_xattr_cached, !=, NULL);\n\n\tnvl = zp->z_xattr_cached;\n\tsize_t entry_size = ap->a_uio->uio_resid;\n\tif (entry_size > DXATTR_MAX_ENTRY_SIZE)\n\t\treturn (SET_ERROR(EFBIG));\n\terror = nvlist_size(nvl, &sa_size, NV_ENCODE_XDR);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\tif (sa_size > DXATTR_MAX_SA_SIZE)\n\t\treturn (SET_ERROR(EFBIG));\n\tuchar_t *buf = kmem_alloc(entry_size, KM_SLEEP);\n\terror = uiomove(buf, entry_size, ap->a_uio);\n\tif (error != 0) {\n\t\terror = SET_ERROR(error);\n\t} else {\n\t\terror = nvlist_add_byte_array(nvl, attrname, buf, entry_size);\n\t\tif (error != 0)\n\t\t\terror = SET_ERROR(error);\n\t}\n\tif (error == 0)\n\t\terror = zfs_sa_set_xattr(zp, attrname, buf, entry_size);\n\tkmem_free(buf, entry_size);\n\tif (error != 0) {\n\t\tzp->z_xattr_cached = NULL;\n\t\tnvlist_free(nvl);\n\t}\n\treturn (error);\n}\n\nstatic int\nzfs_setextattr_impl(struct vop_setextattr_args *ap, boolean_t compat)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tchar attrname[EXTATTR_MAXNAMELEN+1];\n\tint error;\n\n\terror = zfs_create_attrname(ap->a_attrnamespace, ap->a_name, attrname,\n\t    sizeof (attrname), compat);\n\tif (error != 0)\n\t\treturn (error);\n\n\tstruct vop_deleteextattr_args vda = {\n\t\t.a_vp = ap->a_vp,\n\t\t.a_attrnamespace = ap->a_attrnamespace,\n\t\t.a_name = ap->a_name,\n\t\t.a_cred = ap->a_cred,\n\t\t.a_td = ap->a_td,\n\t};\n\terror = ENOENT;\n\tif (zfsvfs->z_use_sa && zp->z_is_sa && zfsvfs->z_xattr_sa) {\n\t\terror = zfs_setextattr_sa(ap, attrname);\n\t\tif (error == 0) {\n\t\t\t \n\t\t\tzfs_deleteextattr_dir(&vda, attrname);\n\t\t}\n\t}\n\tif (error != 0) {\n\t\terror = zfs_setextattr_dir(ap, attrname);\n\t\tif (error == 0 && zp->z_is_sa) {\n\t\t\t \n\t\t\tzfs_deleteextattr_sa(&vda, attrname);\n\t\t}\n\t}\n\tif (error == 0 && ap->a_attrnamespace == EXTATTR_NAMESPACE_USER) {\n\t\t \n\t\tzfs_deleteextattr_impl(&vda, !compat);\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfs_setextattr(struct vop_setextattr_args *ap)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\t \n\tif (!(zfsvfs->z_flags & ZSB_XATTR))\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\n\terror = extattr_check_cred(ap->a_vp, ap->a_attrnamespace,\n\t    ap->a_cred, ap->a_td, VWRITE);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\terror = zfs_check_attrname(ap->a_name);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\trw_enter(&zp->z_xattr_lock, RW_WRITER);\n\n\terror = zfs_setextattr_impl(ap, zfs_xattr_compat);\n\n\trw_exit(&zp->z_xattr_lock);\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_listextattr {\n\tIN struct vnode *a_vp;\n\tIN int a_attrnamespace;\n\tINOUT struct uio *a_uio;\n\tOUT size_t *a_size;\n\tIN struct ucred *a_cred;\n\tIN struct thread *a_td;\n};\n#endif\n\nstatic int\nzfs_listextattr_dir(struct vop_listextattr_args *ap, const char *attrprefix)\n{\n\tstruct thread *td = ap->a_td;\n\tstruct nameidata nd;\n\tuint8_t dirbuf[sizeof (struct dirent)];\n\tstruct iovec aiov;\n\tstruct uio auio;\n\tvnode_t *xvp = NULL, *vp;\n\tint error, eof;\n\n\terror = zfs_lookup(ap->a_vp, NULL, &xvp, NULL, 0, ap->a_cred,\n\t    LOOKUP_XATTR, B_FALSE);\n\tif (error != 0) {\n\t\t \n\t\tif (error == ENOATTR)\n\t\t\terror = 0;\n\t\treturn (error);\n\t}\n\n#if __FreeBSD_version < 1400043\n\tNDINIT_ATVP(&nd, LOOKUP, NOFOLLOW | LOCKLEAF | LOCKSHARED,\n\t    UIO_SYSSPACE, \".\", xvp, td);\n#else\n\tNDINIT_ATVP(&nd, LOOKUP, NOFOLLOW | LOCKLEAF | LOCKSHARED,\n\t    UIO_SYSSPACE, \".\", xvp);\n#endif\n\terror = namei(&nd);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\tvp = nd.ni_vp;\n\tNDFREE_PNBUF(&nd);\n\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_td = td;\n\tauio.uio_rw = UIO_READ;\n\tauio.uio_offset = 0;\n\n\tsize_t plen = strlen(attrprefix);\n\n\tdo {\n\t\taiov.iov_base = (void *)dirbuf;\n\t\taiov.iov_len = sizeof (dirbuf);\n\t\tauio.uio_resid = sizeof (dirbuf);\n\t\terror = VOP_READDIR(vp, &auio, ap->a_cred, &eof, NULL, NULL);\n\t\tif (error != 0)\n\t\t\tbreak;\n\t\tint done = sizeof (dirbuf) - auio.uio_resid;\n\t\tfor (int pos = 0; pos < done; ) {\n\t\t\tstruct dirent *dp = (struct dirent *)(dirbuf + pos);\n\t\t\tpos += dp->d_reclen;\n\t\t\t \n\t\t\tif (dp->d_type != DT_REG && dp->d_type != DT_UNKNOWN)\n\t\t\t\tcontinue;\n\t\t\telse if (plen == 0 &&\n\t\t\t    ZFS_XA_NS_PREFIX_FORBIDDEN(dp->d_name))\n\t\t\t\tcontinue;\n\t\t\telse if (strncmp(dp->d_name, attrprefix, plen) != 0)\n\t\t\t\tcontinue;\n\t\t\tuint8_t nlen = dp->d_namlen - plen;\n\t\t\tif (ap->a_size != NULL) {\n\t\t\t\t*ap->a_size += 1 + nlen;\n\t\t\t} else if (ap->a_uio != NULL) {\n\t\t\t\t \n\t\t\t\terror = uiomove(&nlen, 1, ap->a_uio);\n\t\t\t\tif (error == 0) {\n\t\t\t\t\tchar *namep = dp->d_name + plen;\n\t\t\t\t\terror = uiomove(namep, nlen, ap->a_uio);\n\t\t\t\t}\n\t\t\t\tif (error != 0) {\n\t\t\t\t\terror = SET_ERROR(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (!eof && error == 0);\n\n\tvput(vp);\n\treturn (error);\n}\n\nstatic int\nzfs_listextattr_sa(struct vop_listextattr_args *ap, const char *attrprefix)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tint error;\n\n\terror = zfs_ensure_xattr_cached(zp);\n\tif (error != 0)\n\t\treturn (error);\n\n\tASSERT(RW_LOCK_HELD(&zp->z_xattr_lock));\n\tASSERT3P(zp->z_xattr_cached, !=, NULL);\n\n\tsize_t plen = strlen(attrprefix);\n\tnvpair_t *nvp = NULL;\n\twhile ((nvp = nvlist_next_nvpair(zp->z_xattr_cached, nvp)) != NULL) {\n\t\tASSERT3U(nvpair_type(nvp), ==, DATA_TYPE_BYTE_ARRAY);\n\n\t\tconst char *name = nvpair_name(nvp);\n\t\tif (plen == 0 && ZFS_XA_NS_PREFIX_FORBIDDEN(name))\n\t\t\tcontinue;\n\t\telse if (strncmp(name, attrprefix, plen) != 0)\n\t\t\tcontinue;\n\t\tuint8_t nlen = strlen(name) - plen;\n\t\tif (ap->a_size != NULL) {\n\t\t\t*ap->a_size += 1 + nlen;\n\t\t} else if (ap->a_uio != NULL) {\n\t\t\t \n\t\t\terror = uiomove(&nlen, 1, ap->a_uio);\n\t\t\tif (error == 0) {\n\t\t\t\tchar *namep = __DECONST(char *, name) + plen;\n\t\t\t\terror = uiomove(namep, nlen, ap->a_uio);\n\t\t\t}\n\t\t\tif (error != 0) {\n\t\t\t\terror = SET_ERROR(error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error);\n}\n\nstatic int\nzfs_listextattr_impl(struct vop_listextattr_args *ap, boolean_t compat)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tchar attrprefix[16];\n\tint error;\n\n\terror = zfs_create_attrname(ap->a_attrnamespace, \"\", attrprefix,\n\t    sizeof (attrprefix), compat);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (zfsvfs->z_use_sa && zp->z_is_sa)\n\t\terror = zfs_listextattr_sa(ap, attrprefix);\n\tif (error == 0)\n\t\terror = zfs_listextattr_dir(ap, attrprefix);\n\treturn (error);\n}\n\n \nstatic int\nzfs_listextattr(struct vop_listextattr_args *ap)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = ZTOZSB(zp);\n\tint error;\n\n\tif (ap->a_size != NULL)\n\t\t*ap->a_size = 0;\n\n\t \n\tif (!(zfsvfs->z_flags & ZSB_XATTR))\n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\n\terror = extattr_check_cred(ap->a_vp, ap->a_attrnamespace,\n\t    ap->a_cred, ap->a_td, VREAD);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\trw_enter(&zp->z_xattr_lock, RW_READER);\n\n\terror = zfs_listextattr_impl(ap, zfs_xattr_compat);\n\tif (error == 0 && ap->a_attrnamespace == EXTATTR_NAMESPACE_USER) {\n\t\t \n\t\terror = zfs_listextattr_impl(ap, !zfs_xattr_compat);\n\t}\n\n\trw_exit(&zp->z_xattr_lock);\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_getacl_args {\n\tstruct vnode *vp;\n\tacl_type_t type;\n\tstruct acl *aclp;\n\tstruct ucred *cred;\n\tstruct thread *td;\n};\n#endif\n\nstatic int\nzfs_freebsd_getacl(struct vop_getacl_args *ap)\n{\n\tint\t\terror;\n\tvsecattr_t\tvsecattr;\n\n\tif (ap->a_type != ACL_TYPE_NFS4)\n\t\treturn (EINVAL);\n\n\tvsecattr.vsa_mask = VSA_ACE | VSA_ACECNT;\n\tif ((error = zfs_getsecattr(VTOZ(ap->a_vp),\n\t    &vsecattr, 0, ap->a_cred)))\n\t\treturn (error);\n\n\terror = acl_from_aces(ap->a_aclp, vsecattr.vsa_aclentp,\n\t    vsecattr.vsa_aclcnt);\n\tif (vsecattr.vsa_aclentp != NULL)\n\t\tkmem_free(vsecattr.vsa_aclentp, vsecattr.vsa_aclentsz);\n\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_setacl_args {\n\tstruct vnode *vp;\n\tacl_type_t type;\n\tstruct acl *aclp;\n\tstruct ucred *cred;\n\tstruct thread *td;\n};\n#endif\n\nstatic int\nzfs_freebsd_setacl(struct vop_setacl_args *ap)\n{\n\tint\t\terror;\n\tvsecattr_t vsecattr;\n\tint\t\taclbsize;\t \n\taclent_t\t*aaclp;\n\n\tif (ap->a_type != ACL_TYPE_NFS4)\n\t\treturn (EINVAL);\n\n\tif (ap->a_aclp == NULL)\n\t\treturn (EINVAL);\n\n\tif (ap->a_aclp->acl_cnt < 1 || ap->a_aclp->acl_cnt > MAX_ACL_ENTRIES)\n\t\treturn (EINVAL);\n\n\t \n\tif (ap->a_aclp->acl_cnt * 2 + 6 > ACL_MAX_ENTRIES)\n\t\treturn (ENOSPC);\n\n\terror = acl_nfs4_check(ap->a_aclp, ap->a_vp->v_type == VDIR);\n\tif (error != 0)\n\t\treturn (error);\n\n\tvsecattr.vsa_mask = VSA_ACE;\n\taclbsize = ap->a_aclp->acl_cnt * sizeof (ace_t);\n\tvsecattr.vsa_aclentp = kmem_alloc(aclbsize, KM_SLEEP);\n\taaclp = vsecattr.vsa_aclentp;\n\tvsecattr.vsa_aclentsz = aclbsize;\n\n\taces_from_acl(vsecattr.vsa_aclentp, &vsecattr.vsa_aclcnt, ap->a_aclp);\n\terror = zfs_setsecattr(VTOZ(ap->a_vp), &vsecattr, 0, ap->a_cred);\n\tkmem_free(aaclp, aclbsize);\n\n\treturn (error);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_aclcheck_args {\n\tstruct vnode *vp;\n\tacl_type_t type;\n\tstruct acl *aclp;\n\tstruct ucred *cred;\n\tstruct thread *td;\n};\n#endif\n\nstatic int\nzfs_freebsd_aclcheck(struct vop_aclcheck_args *ap)\n{\n\n\treturn (EOPNOTSUPP);\n}\n\nstatic int\nzfs_vptocnp(struct vop_vptocnp_args *ap)\n{\n\tvnode_t *covered_vp;\n\tvnode_t *vp = ap->a_vp;\n\tzfsvfs_t *zfsvfs = vp->v_vfsp->vfs_data;\n\tznode_t *zp = VTOZ(vp);\n\tint ltype;\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\t \n\tif (zp->z_id != zfsvfs->z_root || zfsvfs->z_parent == zfsvfs) {\n\t\tchar name[MAXNAMLEN + 1];\n\t\tznode_t *dzp;\n\t\tsize_t len;\n\n\t\terror = zfs_znode_parent_and_name(zp, &dzp, name);\n\t\tif (error == 0) {\n\t\t\tlen = strlen(name);\n\t\t\tif (*ap->a_buflen < len)\n\t\t\t\terror = SET_ERROR(ENOMEM);\n\t\t}\n\t\tif (error == 0) {\n\t\t\t*ap->a_buflen -= len;\n\t\t\tmemcpy(ap->a_buf + *ap->a_buflen, name, len);\n\t\t\t*ap->a_vpp = ZTOV(dzp);\n\t\t}\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (error);\n\t}\n\tzfs_exit(zfsvfs, FTAG);\n\n\tcovered_vp = vp->v_mount->mnt_vnodecovered;\n#if __FreeBSD_version >= 1300045\n\tenum vgetstate vs = vget_prep(covered_vp);\n#else\n\tvhold(covered_vp);\n#endif\n\tltype = VOP_ISLOCKED(vp);\n\tVOP_UNLOCK1(vp);\n#if __FreeBSD_version >= 1300045\n\terror = vget_finish(covered_vp, LK_SHARED, vs);\n#else\n\terror = vget(covered_vp, LK_SHARED | LK_VNHELD, curthread);\n#endif\n\tif (error == 0) {\n#if __FreeBSD_version >= 1300123\n\t\terror = VOP_VPTOCNP(covered_vp, ap->a_vpp, ap->a_buf,\n\t\t    ap->a_buflen);\n#else\n\t\terror = VOP_VPTOCNP(covered_vp, ap->a_vpp, ap->a_cred,\n\t\t    ap->a_buf, ap->a_buflen);\n#endif\n\t\tvput(covered_vp);\n\t}\n\tvn_lock(vp, ltype | LK_RETRY);\n\tif (VN_IS_DOOMED(vp))\n\t\terror = SET_ERROR(ENOENT);\n\treturn (error);\n}\n\n#if __FreeBSD_version >= 1400032\nstatic int\nzfs_deallocate(struct vop_deallocate_args *ap)\n{\n\tznode_t *zp = VTOZ(ap->a_vp);\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tzilog_t *zilog;\n\toff_t off, len, file_sz;\n\tint error;\n\n\tif ((error = zfs_enter_verify_zp(zfsvfs, zp, FTAG)) != 0)\n\t\treturn (error);\n\n\t \n\tif (zfs_is_readonly(zfsvfs)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\tzilog = zfsvfs->z_log;\n\toff = *ap->a_offset;\n\tlen = *ap->a_len;\n\tfile_sz = zp->z_size;\n\tif (off + len > file_sz)\n\t\tlen = file_sz - off;\n\t \n\tif (len <= 0) {\n\t\t*ap->a_len = 0;\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (0);\n\t}\n\n\terror = zfs_freesp(zp, off, len, O_RDWR, TRUE);\n\tif (error == 0) {\n\t\tif (zfsvfs->z_os->os_sync == ZFS_SYNC_ALWAYS ||\n\t\t    (ap->a_ioflag & IO_SYNC) != 0)\n\t\t\tzil_commit(zilog, zp->z_id);\n\t\t*ap->a_offset = off + len;\n\t\t*ap->a_len = 0;\n\t}\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n#endif\n\n#if __FreeBSD_version >= 1300039\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_copy_file_range_args {\n\tstruct vnode *a_invp;\n\toff_t *a_inoffp;\n\tstruct vnode *a_outvp;\n\toff_t *a_outoffp;\n\tsize_t *a_lenp;\n\tunsigned int a_flags;\n\tstruct ucred *a_incred;\n\tstruct ucred *a_outcred;\n\tstruct thread *a_fsizetd;\n}\n#endif\n \nstatic int\nzfs_freebsd_copy_file_range(struct vop_copy_file_range_args *ap)\n{\n\tzfsvfs_t *outzfsvfs;\n\tstruct vnode *invp = ap->a_invp;\n\tstruct vnode *outvp = ap->a_outvp;\n\tstruct mount *mp;\n\tstruct uio io;\n\tint error;\n\tuint64_t len = *ap->a_lenp;\n\n\tif (!zfs_bclone_enabled) {\n\t\tmp = NULL;\n\t\tgoto bad_write_fallback;\n\t}\n\n\t \n\n\tvn_start_write(outvp, &mp, V_WAIT);\n\tif (__predict_true(mp == outvp->v_mount)) {\n\t\toutzfsvfs = (zfsvfs_t *)mp->mnt_data;\n\t\tif (!spa_feature_is_enabled(dmu_objset_spa(outzfsvfs->z_os),\n\t\t    SPA_FEATURE_BLOCK_CLONING)) {\n\t\t\tgoto bad_write_fallback;\n\t\t}\n\t}\n\tif (invp == outvp) {\n\t\tif (vn_lock(outvp, LK_EXCLUSIVE) != 0) {\n\t\t\tgoto bad_write_fallback;\n\t\t}\n\t} else {\n#if (__FreeBSD_version >= 1302506 && __FreeBSD_version < 1400000) || \\\n\t__FreeBSD_version >= 1400086\n\t\tvn_lock_pair(invp, false, LK_EXCLUSIVE, outvp, false,\n\t\t    LK_EXCLUSIVE);\n#else\n\t\tvn_lock_pair(invp, false, outvp, false);\n#endif\n\t\tif (VN_IS_DOOMED(invp) || VN_IS_DOOMED(outvp)) {\n\t\t\tgoto bad_locked_fallback;\n\t\t}\n\t}\n\n#ifdef MAC\n\terror = mac_vnode_check_write(curthread->td_ucred, ap->a_outcred,\n\t    outvp);\n\tif (error != 0)\n\t\tgoto out_locked;\n#endif\n\n\tio.uio_offset = *ap->a_outoffp;\n\tio.uio_resid = *ap->a_lenp;\n\terror = vn_rlimit_fsize(outvp, &io, ap->a_fsizetd);\n\tif (error != 0)\n\t\tgoto out_locked;\n\n\terror = zfs_clone_range(VTOZ(invp), ap->a_inoffp, VTOZ(outvp),\n\t    ap->a_outoffp, &len, ap->a_outcred);\n\tif (error == EXDEV || error == EAGAIN || error == EINVAL ||\n\t    error == EOPNOTSUPP)\n\t\tgoto bad_locked_fallback;\n\t*ap->a_lenp = (size_t)len;\nout_locked:\n\tif (invp != outvp)\n\t\tVOP_UNLOCK(invp);\n\tVOP_UNLOCK(outvp);\n\tif (mp != NULL)\n\t\tvn_finished_write(mp);\n\treturn (error);\n\nbad_locked_fallback:\n\tif (invp != outvp)\n\t\tVOP_UNLOCK(invp);\n\tVOP_UNLOCK(outvp);\nbad_write_fallback:\n\tif (mp != NULL)\n\t\tvn_finished_write(mp);\n\terror = vn_generic_copy_file_range(ap->a_invp, ap->a_inoffp,\n\t    ap->a_outvp, ap->a_outoffp, ap->a_lenp, ap->a_flags,\n\t    ap->a_incred, ap->a_outcred, ap->a_fsizetd);\n\treturn (error);\n}\n#endif\n\nstruct vop_vector zfs_vnodeops;\nstruct vop_vector zfs_fifoops;\nstruct vop_vector zfs_shareops;\n\nstruct vop_vector zfs_vnodeops = {\n\t.vop_default =\t\t&default_vnodeops,\n\t.vop_inactive =\t\tzfs_freebsd_inactive,\n#if __FreeBSD_version >= 1300042\n\t.vop_need_inactive =\tzfs_freebsd_need_inactive,\n#endif\n\t.vop_reclaim =\t\tzfs_freebsd_reclaim,\n#if __FreeBSD_version >= 1300102\n\t.vop_fplookup_vexec = zfs_freebsd_fplookup_vexec,\n#endif\n#if __FreeBSD_version >= 1300139\n\t.vop_fplookup_symlink = zfs_freebsd_fplookup_symlink,\n#endif\n\t.vop_access =\t\tzfs_freebsd_access,\n\t.vop_allocate =\t\tVOP_EINVAL,\n#if __FreeBSD_version >= 1400032\n\t.vop_deallocate =\tzfs_deallocate,\n#endif\n\t.vop_lookup =\t\tzfs_cache_lookup,\n\t.vop_cachedlookup =\tzfs_freebsd_cachedlookup,\n\t.vop_getattr =\t\tzfs_freebsd_getattr,\n\t.vop_setattr =\t\tzfs_freebsd_setattr,\n\t.vop_create =\t\tzfs_freebsd_create,\n\t.vop_mknod =\t\t(vop_mknod_t *)zfs_freebsd_create,\n\t.vop_mkdir =\t\tzfs_freebsd_mkdir,\n\t.vop_readdir =\t\tzfs_freebsd_readdir,\n\t.vop_fsync =\t\tzfs_freebsd_fsync,\n\t.vop_open =\t\tzfs_freebsd_open,\n\t.vop_close =\t\tzfs_freebsd_close,\n\t.vop_rmdir =\t\tzfs_freebsd_rmdir,\n\t.vop_ioctl =\t\tzfs_freebsd_ioctl,\n\t.vop_link =\t\tzfs_freebsd_link,\n\t.vop_symlink =\t\tzfs_freebsd_symlink,\n\t.vop_readlink =\t\tzfs_freebsd_readlink,\n\t.vop_read =\t\tzfs_freebsd_read,\n\t.vop_write =\t\tzfs_freebsd_write,\n\t.vop_remove =\t\tzfs_freebsd_remove,\n\t.vop_rename =\t\tzfs_freebsd_rename,\n\t.vop_pathconf =\t\tzfs_freebsd_pathconf,\n\t.vop_bmap =\t\tzfs_freebsd_bmap,\n\t.vop_fid =\t\tzfs_freebsd_fid,\n\t.vop_getextattr =\tzfs_getextattr,\n\t.vop_deleteextattr =\tzfs_deleteextattr,\n\t.vop_setextattr =\tzfs_setextattr,\n\t.vop_listextattr =\tzfs_listextattr,\n\t.vop_getacl =\t\tzfs_freebsd_getacl,\n\t.vop_setacl =\t\tzfs_freebsd_setacl,\n\t.vop_aclcheck =\t\tzfs_freebsd_aclcheck,\n\t.vop_getpages =\t\tzfs_freebsd_getpages,\n\t.vop_putpages =\t\tzfs_freebsd_putpages,\n\t.vop_vptocnp =\t\tzfs_vptocnp,\n#if __FreeBSD_version >= 1300064\n\t.vop_lock1 =\t\tvop_lock,\n\t.vop_unlock =\t\tvop_unlock,\n\t.vop_islocked =\t\tvop_islocked,\n#endif\n#if __FreeBSD_version >= 1400043\n\t.vop_add_writecount =\tvop_stdadd_writecount_nomsync,\n#endif\n#if __FreeBSD_version >= 1300039\n\t.vop_copy_file_range =\tzfs_freebsd_copy_file_range,\n#endif\n};\nVFS_VOP_VECTOR_REGISTER(zfs_vnodeops);\n\nstruct vop_vector zfs_fifoops = {\n\t.vop_default =\t\t&fifo_specops,\n\t.vop_fsync =\t\tzfs_freebsd_fsync,\n#if __FreeBSD_version >= 1300102\n\t.vop_fplookup_vexec = zfs_freebsd_fplookup_vexec,\n#endif\n#if __FreeBSD_version >= 1300139\n\t.vop_fplookup_symlink = zfs_freebsd_fplookup_symlink,\n#endif\n\t.vop_access =\t\tzfs_freebsd_access,\n\t.vop_getattr =\t\tzfs_freebsd_getattr,\n\t.vop_inactive =\t\tzfs_freebsd_inactive,\n\t.vop_read =\t\tVOP_PANIC,\n\t.vop_reclaim =\t\tzfs_freebsd_reclaim,\n\t.vop_setattr =\t\tzfs_freebsd_setattr,\n\t.vop_write =\t\tVOP_PANIC,\n\t.vop_pathconf = \tzfs_freebsd_pathconf,\n\t.vop_fid =\t\tzfs_freebsd_fid,\n\t.vop_getacl =\t\tzfs_freebsd_getacl,\n\t.vop_setacl =\t\tzfs_freebsd_setacl,\n\t.vop_aclcheck =\t\tzfs_freebsd_aclcheck,\n#if __FreeBSD_version >= 1400043\n\t.vop_add_writecount =\tvop_stdadd_writecount_nomsync,\n#endif\n};\nVFS_VOP_VECTOR_REGISTER(zfs_fifoops);\n\n \nstruct vop_vector zfs_shareops = {\n\t.vop_default =\t\t&default_vnodeops,\n#if __FreeBSD_version >= 1300121\n\t.vop_fplookup_vexec =\tVOP_EAGAIN,\n#endif\n#if __FreeBSD_version >= 1300139\n\t.vop_fplookup_symlink =\tVOP_EAGAIN,\n#endif\n\t.vop_access =\t\tzfs_freebsd_access,\n\t.vop_inactive =\t\tzfs_freebsd_inactive,\n\t.vop_reclaim =\t\tzfs_freebsd_reclaim,\n\t.vop_fid =\t\tzfs_freebsd_fid,\n\t.vop_pathconf =\t\tzfs_freebsd_pathconf,\n#if __FreeBSD_version >= 1400043\n\t.vop_add_writecount =\tvop_stdadd_writecount_nomsync,\n#endif\n};\nVFS_VOP_VECTOR_REGISTER(zfs_shareops);\n\nZFS_MODULE_PARAM(zfs, zfs_, xattr_compat, INT, ZMOD_RW,\n\t\"Use legacy ZFS xattr naming for writing new user namespace xattrs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}