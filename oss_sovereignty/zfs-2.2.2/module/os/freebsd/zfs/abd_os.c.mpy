{
  "module_name": "abd_os.c",
  "hash_id": "ac699625b3c623d3f4ed5176ede56a68c4bd3b02b45994f592c4b06f161ce6c0",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/abd_os.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/abd_impl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include <sys/zio.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_znode.h>\n\ntypedef struct abd_stats {\n\tkstat_named_t abdstat_struct_size;\n\tkstat_named_t abdstat_scatter_cnt;\n\tkstat_named_t abdstat_scatter_data_size;\n\tkstat_named_t abdstat_scatter_chunk_waste;\n\tkstat_named_t abdstat_linear_cnt;\n\tkstat_named_t abdstat_linear_data_size;\n} abd_stats_t;\n\nstatic abd_stats_t abd_stats = {\n\t \n\t{ \"struct_size\",\t\t\tKSTAT_DATA_UINT64 },\n\t \n\t{ \"scatter_cnt\",\t\t\tKSTAT_DATA_UINT64 },\n\t \n\t{ \"scatter_data_size\",\t\t\tKSTAT_DATA_UINT64 },\n\t \n\t{ \"scatter_chunk_waste\",\t\tKSTAT_DATA_UINT64 },\n\t \n\t{ \"linear_cnt\",\t\t\t\tKSTAT_DATA_UINT64 },\n\t \n\t{ \"linear_data_size\",\t\t\tKSTAT_DATA_UINT64 },\n};\n\nstruct {\n\twmsum_t abdstat_struct_size;\n\twmsum_t abdstat_scatter_cnt;\n\twmsum_t abdstat_scatter_data_size;\n\twmsum_t abdstat_scatter_chunk_waste;\n\twmsum_t abdstat_linear_cnt;\n\twmsum_t abdstat_linear_data_size;\n} abd_sums;\n\n \nstatic size_t zfs_abd_scatter_min_size = PAGE_SIZE + 1;\n\n#if defined(_KERNEL)\nSYSCTL_DECL(_vfs_zfs);\n\nSYSCTL_INT(_vfs_zfs, OID_AUTO, abd_scatter_enabled, CTLFLAG_RWTUN,\n\t&zfs_abd_scatter_enabled, 0, \"Enable scattered ARC data buffers\");\nSYSCTL_ULONG(_vfs_zfs, OID_AUTO, abd_scatter_min_size, CTLFLAG_RWTUN,\n\t&zfs_abd_scatter_min_size, 0, \"Minimum size of scatter allocations.\");\n#endif\n\nkmem_cache_t *abd_chunk_cache;\nstatic kstat_t *abd_ksp;\n\n \nabd_t *abd_zero_scatter = NULL;\n\nstatic uint_t\nabd_chunkcnt_for_bytes(size_t size)\n{\n\treturn ((size + PAGE_MASK) >> PAGE_SHIFT);\n}\n\nstatic inline uint_t\nabd_scatter_chunkcnt(abd_t *abd)\n{\n\tASSERT(!abd_is_linear(abd));\n\treturn (abd_chunkcnt_for_bytes(\n\t    ABD_SCATTER(abd).abd_offset + abd->abd_size));\n}\n\nboolean_t\nabd_size_alloc_linear(size_t size)\n{\n\treturn (!zfs_abd_scatter_enabled || size < zfs_abd_scatter_min_size);\n}\n\nvoid\nabd_update_scatter_stats(abd_t *abd, abd_stats_op_t op)\n{\n\tuint_t n = abd_scatter_chunkcnt(abd);\n\tASSERT(op == ABDSTAT_INCR || op == ABDSTAT_DECR);\n\tint waste = (n << PAGE_SHIFT) - abd->abd_size;\n\tif (op == ABDSTAT_INCR) {\n\t\tABDSTAT_BUMP(abdstat_scatter_cnt);\n\t\tABDSTAT_INCR(abdstat_scatter_data_size, abd->abd_size);\n\t\tABDSTAT_INCR(abdstat_scatter_chunk_waste, waste);\n\t\tarc_space_consume(waste, ARC_SPACE_ABD_CHUNK_WASTE);\n\t} else {\n\t\tABDSTAT_BUMPDOWN(abdstat_scatter_cnt);\n\t\tABDSTAT_INCR(abdstat_scatter_data_size, -(int)abd->abd_size);\n\t\tABDSTAT_INCR(abdstat_scatter_chunk_waste, -waste);\n\t\tarc_space_return(waste, ARC_SPACE_ABD_CHUNK_WASTE);\n\t}\n}\n\nvoid\nabd_update_linear_stats(abd_t *abd, abd_stats_op_t op)\n{\n\tASSERT(op == ABDSTAT_INCR || op == ABDSTAT_DECR);\n\tif (op == ABDSTAT_INCR) {\n\t\tABDSTAT_BUMP(abdstat_linear_cnt);\n\t\tABDSTAT_INCR(abdstat_linear_data_size, abd->abd_size);\n\t} else {\n\t\tABDSTAT_BUMPDOWN(abdstat_linear_cnt);\n\t\tABDSTAT_INCR(abdstat_linear_data_size, -(int)abd->abd_size);\n\t}\n}\n\nvoid\nabd_verify_scatter(abd_t *abd)\n{\n\tuint_t i, n;\n\n\t \n\tASSERT(!abd_is_linear_page(abd));\n\tASSERT3U(ABD_SCATTER(abd).abd_offset, <, PAGE_SIZE);\n\tn = abd_scatter_chunkcnt(abd);\n\tfor (i = 0; i < n; i++) {\n\t\tASSERT3P(ABD_SCATTER(abd).abd_chunks[i], !=, NULL);\n\t}\n}\n\nvoid\nabd_alloc_chunks(abd_t *abd, size_t size)\n{\n\tuint_t i, n;\n\n\tn = abd_chunkcnt_for_bytes(size);\n\tfor (i = 0; i < n; i++) {\n\t\tABD_SCATTER(abd).abd_chunks[i] =\n\t\t    kmem_cache_alloc(abd_chunk_cache, KM_PUSHPAGE);\n\t}\n}\n\nvoid\nabd_free_chunks(abd_t *abd)\n{\n\tuint_t i, n;\n\n\tn = abd_scatter_chunkcnt(abd);\n\tfor (i = 0; i < n; i++) {\n\t\tkmem_cache_free(abd_chunk_cache,\n\t\t    ABD_SCATTER(abd).abd_chunks[i]);\n\t}\n}\n\nabd_t *\nabd_alloc_struct_impl(size_t size)\n{\n\tuint_t chunkcnt = abd_chunkcnt_for_bytes(size);\n\t \n\tsize_t abd_size = MAX(sizeof (abd_t),\n\t    offsetof(abd_t, abd_u.abd_scatter.abd_chunks[chunkcnt]));\n\tabd_t *abd = kmem_alloc(abd_size, KM_PUSHPAGE);\n\tASSERT3P(abd, !=, NULL);\n\tABDSTAT_INCR(abdstat_struct_size, abd_size);\n\n\treturn (abd);\n}\n\nvoid\nabd_free_struct_impl(abd_t *abd)\n{\n\tuint_t chunkcnt = abd_is_linear(abd) || abd_is_gang(abd) ? 0 :\n\t    abd_scatter_chunkcnt(abd);\n\tssize_t size = MAX(sizeof (abd_t),\n\t    offsetof(abd_t, abd_u.abd_scatter.abd_chunks[chunkcnt]));\n\tkmem_free(abd, size);\n\tABDSTAT_INCR(abdstat_struct_size, -size);\n}\n\n \n_Static_assert(ZERO_REGION_SIZE >= PAGE_SIZE, \"zero_region too small\");\nstatic void\nabd_alloc_zero_scatter(void)\n{\n\tuint_t i, n;\n\n\tn = abd_chunkcnt_for_bytes(SPA_MAXBLOCKSIZE);\n\tabd_zero_scatter = abd_alloc_struct(SPA_MAXBLOCKSIZE);\n\tabd_zero_scatter->abd_flags |= ABD_FLAG_OWNER | ABD_FLAG_ZEROS;\n\tabd_zero_scatter->abd_size = SPA_MAXBLOCKSIZE;\n\n\tABD_SCATTER(abd_zero_scatter).abd_offset = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tABD_SCATTER(abd_zero_scatter).abd_chunks[i] =\n\t\t    __DECONST(void *, zero_region);\n\t}\n\n\tABDSTAT_BUMP(abdstat_scatter_cnt);\n\tABDSTAT_INCR(abdstat_scatter_data_size, PAGE_SIZE);\n}\n\nstatic void\nabd_free_zero_scatter(void)\n{\n\tABDSTAT_BUMPDOWN(abdstat_scatter_cnt);\n\tABDSTAT_INCR(abdstat_scatter_data_size, -(int)PAGE_SIZE);\n\n\tabd_free_struct(abd_zero_scatter);\n\tabd_zero_scatter = NULL;\n}\n\nstatic int\nabd_kstats_update(kstat_t *ksp, int rw)\n{\n\tabd_stats_t *as = ksp->ks_data;\n\n\tif (rw == KSTAT_WRITE)\n\t\treturn (EACCES);\n\tas->abdstat_struct_size.value.ui64 =\n\t    wmsum_value(&abd_sums.abdstat_struct_size);\n\tas->abdstat_scatter_cnt.value.ui64 =\n\t    wmsum_value(&abd_sums.abdstat_scatter_cnt);\n\tas->abdstat_scatter_data_size.value.ui64 =\n\t    wmsum_value(&abd_sums.abdstat_scatter_data_size);\n\tas->abdstat_scatter_chunk_waste.value.ui64 =\n\t    wmsum_value(&abd_sums.abdstat_scatter_chunk_waste);\n\tas->abdstat_linear_cnt.value.ui64 =\n\t    wmsum_value(&abd_sums.abdstat_linear_cnt);\n\tas->abdstat_linear_data_size.value.ui64 =\n\t    wmsum_value(&abd_sums.abdstat_linear_data_size);\n\treturn (0);\n}\n\nvoid\nabd_init(void)\n{\n\tabd_chunk_cache = kmem_cache_create(\"abd_chunk\", PAGE_SIZE, 0,\n\t    NULL, NULL, NULL, NULL, 0, KMC_NODEBUG);\n\n\twmsum_init(&abd_sums.abdstat_struct_size, 0);\n\twmsum_init(&abd_sums.abdstat_scatter_cnt, 0);\n\twmsum_init(&abd_sums.abdstat_scatter_data_size, 0);\n\twmsum_init(&abd_sums.abdstat_scatter_chunk_waste, 0);\n\twmsum_init(&abd_sums.abdstat_linear_cnt, 0);\n\twmsum_init(&abd_sums.abdstat_linear_data_size, 0);\n\n\tabd_ksp = kstat_create(\"zfs\", 0, \"abdstats\", \"misc\", KSTAT_TYPE_NAMED,\n\t    sizeof (abd_stats) / sizeof (kstat_named_t), KSTAT_FLAG_VIRTUAL);\n\tif (abd_ksp != NULL) {\n\t\tabd_ksp->ks_data = &abd_stats;\n\t\tabd_ksp->ks_update = abd_kstats_update;\n\t\tkstat_install(abd_ksp);\n\t}\n\n\tabd_alloc_zero_scatter();\n}\n\nvoid\nabd_fini(void)\n{\n\tabd_free_zero_scatter();\n\n\tif (abd_ksp != NULL) {\n\t\tkstat_delete(abd_ksp);\n\t\tabd_ksp = NULL;\n\t}\n\n\twmsum_fini(&abd_sums.abdstat_struct_size);\n\twmsum_fini(&abd_sums.abdstat_scatter_cnt);\n\twmsum_fini(&abd_sums.abdstat_scatter_data_size);\n\twmsum_fini(&abd_sums.abdstat_scatter_chunk_waste);\n\twmsum_fini(&abd_sums.abdstat_linear_cnt);\n\twmsum_fini(&abd_sums.abdstat_linear_data_size);\n\n\tkmem_cache_destroy(abd_chunk_cache);\n\tabd_chunk_cache = NULL;\n}\n\nvoid\nabd_free_linear_page(abd_t *abd)\n{\n\t \n\tVERIFY(0);\n}\n\n \nabd_t *\nabd_alloc_for_io(size_t size, boolean_t is_metadata)\n{\n\treturn (abd_alloc_linear(size, is_metadata));\n}\n\nabd_t *\nabd_get_offset_scatter(abd_t *abd, abd_t *sabd, size_t off,\n    size_t size)\n{\n\tabd_verify(sabd);\n\tASSERT3U(off, <=, sabd->abd_size);\n\n\tsize_t new_offset = ABD_SCATTER(sabd).abd_offset + off;\n\tsize_t chunkcnt = abd_chunkcnt_for_bytes(\n\t    (new_offset & PAGE_MASK) + size);\n\n\tASSERT3U(chunkcnt, <=, abd_scatter_chunkcnt(sabd));\n\n\t \n\tif (abd != NULL &&\n\t    offsetof(abd_t, abd_u.abd_scatter.abd_chunks[chunkcnt]) >\n\t    sizeof (abd_t)) {\n\t\tabd = NULL;\n\t}\n\n\tif (abd == NULL)\n\t\tabd = abd_alloc_struct(chunkcnt << PAGE_SHIFT);\n\n\t \n\n\tABD_SCATTER(abd).abd_offset = new_offset & PAGE_MASK;\n\n\t \n\t(void) memcpy(&ABD_SCATTER(abd).abd_chunks,\n\t    &ABD_SCATTER(sabd).abd_chunks[new_offset >> PAGE_SHIFT],\n\t    chunkcnt * sizeof (void *));\n\n\treturn (abd);\n}\n\n \nvoid\nabd_iter_init(struct abd_iter *aiter, abd_t *abd)\n{\n\tASSERT(!abd_is_gang(abd));\n\tabd_verify(abd);\n\taiter->iter_abd = abd;\n\taiter->iter_pos = 0;\n\taiter->iter_mapaddr = NULL;\n\taiter->iter_mapsize = 0;\n}\n\n \nboolean_t\nabd_iter_at_end(struct abd_iter *aiter)\n{\n\treturn (aiter->iter_pos == aiter->iter_abd->abd_size);\n}\n\n \nvoid\nabd_iter_advance(struct abd_iter *aiter, size_t amount)\n{\n\tASSERT3P(aiter->iter_mapaddr, ==, NULL);\n\tASSERT0(aiter->iter_mapsize);\n\n\t \n\tif (abd_iter_at_end(aiter))\n\t\treturn;\n\n\taiter->iter_pos += amount;\n}\n\n \nvoid\nabd_iter_map(struct abd_iter *aiter)\n{\n\tvoid *paddr;\n\n\tASSERT3P(aiter->iter_mapaddr, ==, NULL);\n\tASSERT0(aiter->iter_mapsize);\n\n\t \n\tif (abd_iter_at_end(aiter))\n\t\treturn;\n\n\tabd_t *abd = aiter->iter_abd;\n\tsize_t offset = aiter->iter_pos;\n\tif (abd_is_linear(abd)) {\n\t\taiter->iter_mapsize = abd->abd_size - offset;\n\t\tpaddr = ABD_LINEAR_BUF(abd);\n\t} else {\n\t\toffset += ABD_SCATTER(abd).abd_offset;\n\t\tpaddr = ABD_SCATTER(abd).abd_chunks[offset >> PAGE_SHIFT];\n\t\toffset &= PAGE_MASK;\n\t\taiter->iter_mapsize = MIN(PAGE_SIZE - offset,\n\t\t    abd->abd_size - aiter->iter_pos);\n\t}\n\taiter->iter_mapaddr = (char *)paddr + offset;\n}\n\n \nvoid\nabd_iter_unmap(struct abd_iter *aiter)\n{\n\tif (!abd_iter_at_end(aiter)) {\n\t\tASSERT3P(aiter->iter_mapaddr, !=, NULL);\n\t\tASSERT3U(aiter->iter_mapsize, >, 0);\n\t}\n\n\taiter->iter_mapaddr = NULL;\n\taiter->iter_mapsize = 0;\n}\n\nvoid\nabd_cache_reap_now(void)\n{\n\tkmem_cache_reap_soon(abd_chunk_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}