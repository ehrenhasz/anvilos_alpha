{
  "module_name": "sysctl_os.c",
  "hash_id": "b6d773d521dffefe8584445a9cc441fec8bef6f0c0382e60148fe7c2fa0501d9",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/sysctl_os.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/lock.h>\n#include <sys/malloc.h>\n#include <sys/mutex.h>\n#include <sys/proc.h>\n#include <sys/errno.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/kmem.h>\n#include <sys/conf.h>\n#include <sys/cmn_err.h>\n#include <sys/stat.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n#include <sys/zap.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/vdev.h>\n#include <sys/vdev_impl.h>\n#include <sys/arc_os.h>\n#include <sys/dmu.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_deleg.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/sunddi.h>\n#include <sys/policy.h>\n#include <sys/zone.h>\n#include <sys/nvpair.h>\n#include <sys/mount.h>\n#include <sys/taskqueue.h>\n#include <sys/sdt.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_onexit.h>\n#include <sys/zvol.h>\n#include <sys/dsl_scan.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_send.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dsl_userhold.h>\n#include <sys/zfeature.h>\n#include <sys/zcp.h>\n#include <sys/zio_checksum.h>\n#include <sys/vdev_removal.h>\n#include <sys/dsl_crypt.h>\n\n#include <sys/zfs_ioctl_compat.h>\n#include <sys/zfs_context.h>\n\n#include <sys/arc_impl.h>\n#include <sys/dsl_pool.h>\n\n#include <sys/vmmeter.h>\n\nSYSCTL_DECL(_vfs_zfs);\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, arc, CTLFLAG_RW, 0,\n\t\"ZFS adaptive replacement cache\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, brt, CTLFLAG_RW, 0,\n\t\"ZFS Block Reference Table\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, condense, CTLFLAG_RW, 0, \"ZFS condense\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, dbuf, CTLFLAG_RW, 0, \"ZFS disk buf cache\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, dbuf_cache, CTLFLAG_RW, 0,\n\t\"ZFS disk buf cache\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, deadman, CTLFLAG_RW, 0, \"ZFS deadman\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, dedup, CTLFLAG_RW, 0, \"ZFS dedup\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, l2arc, CTLFLAG_RW, 0, \"ZFS l2arc\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, livelist, CTLFLAG_RW, 0, \"ZFS livelist\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, lua, CTLFLAG_RW, 0, \"ZFS lua\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, metaslab, CTLFLAG_RW, 0, \"ZFS metaslab\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, mg, CTLFLAG_RW, 0, \"ZFS metaslab group\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, multihost, CTLFLAG_RW, 0,\n\t\"ZFS multihost protection\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, prefetch, CTLFLAG_RW, 0, \"ZFS prefetch\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, reconstruct, CTLFLAG_RW, 0, \"ZFS reconstruct\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, recv, CTLFLAG_RW, 0, \"ZFS receive\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, send, CTLFLAG_RW, 0, \"ZFS send\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, spa, CTLFLAG_RW, 0, \"ZFS space allocation\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, trim, CTLFLAG_RW, 0, \"ZFS TRIM\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, txg, CTLFLAG_RW, 0, \"ZFS transaction group\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, vdev, CTLFLAG_RW, 0, \"ZFS VDEV\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, vnops, CTLFLAG_RW, 0, \"ZFS VNOPS\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, zevent, CTLFLAG_RW, 0, \"ZFS event\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, zil, CTLFLAG_RW, 0, \"ZFS ZIL\");\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, zio, CTLFLAG_RW, 0, \"ZFS ZIO\");\n\nSYSCTL_NODE(_vfs_zfs_livelist, OID_AUTO, condense, CTLFLAG_RW, 0,\n\t\"ZFS livelist condense\");\nSYSCTL_NODE(_vfs_zfs_vdev, OID_AUTO, cache, CTLFLAG_RW, 0, \"ZFS VDEV Cache\");\nSYSCTL_NODE(_vfs_zfs_vdev, OID_AUTO, file, CTLFLAG_RW, 0, \"ZFS VDEV file\");\nSYSCTL_NODE(_vfs_zfs_vdev, OID_AUTO, mirror, CTLFLAG_RD, 0,\n\t\"ZFS VDEV mirror\");\n\nSYSCTL_DECL(_vfs_zfs_version);\nSYSCTL_CONST_STRING(_vfs_zfs_version, OID_AUTO, module, CTLFLAG_RD,\n\t(ZFS_META_VERSION \"-\" ZFS_META_RELEASE), \"OpenZFS module version\");\n\n \n\nint\nparam_set_arc_u64(SYSCTL_HANDLER_ARGS)\n{\n\tint err;\n\n\terr = sysctl_handle_64(oidp, arg1, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\tarc_tuning_update(B_TRUE);\n\n\treturn (0);\n}\n\nint\nparam_set_arc_int(SYSCTL_HANDLER_ARGS)\n{\n\tint err;\n\n\terr = sysctl_handle_int(oidp, arg1, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\tarc_tuning_update(B_TRUE);\n\n\treturn (0);\n}\n\nint\nparam_set_arc_max(SYSCTL_HANDLER_ARGS)\n{\n\tunsigned long val;\n\tint err;\n\n\tval = zfs_arc_max;\n\terr = sysctl_handle_64(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (SET_ERROR(err));\n\n\tif (val != 0 && (val < MIN_ARC_MAX || val <= arc_c_min ||\n\t    val >= arc_all_memory()))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzfs_arc_max = val;\n\tarc_tuning_update(B_TRUE);\n\n\t \n\tif (val != 0)\n\t\tzfs_arc_max = arc_c_max;\n\n\treturn (0);\n}\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, arc_max,\n\tCTLTYPE_ULONG | CTLFLAG_RWTUN | CTLFLAG_MPSAFE,\n\tNULL, 0, param_set_arc_max, \"LU\",\n\t\"Maximum ARC size in bytes (LEGACY)\");\n \n\nint\nparam_set_arc_min(SYSCTL_HANDLER_ARGS)\n{\n\tunsigned long val;\n\tint err;\n\n\tval = zfs_arc_min;\n\terr = sysctl_handle_64(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (SET_ERROR(err));\n\n\tif (val != 0 && (val < 2ULL << SPA_MAXBLOCKSHIFT || val > arc_c_max))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzfs_arc_min = val;\n\tarc_tuning_update(B_TRUE);\n\n\t \n\tif (val != 0)\n\t\tzfs_arc_min = arc_c_min;\n\n\treturn (0);\n}\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, arc_min,\n\tCTLTYPE_ULONG | CTLFLAG_RWTUN | CTLFLAG_MPSAFE,\n\tNULL, 0, param_set_arc_min, \"LU\",\n\t\"Minimum ARC size in bytes (LEGACY)\");\n \n\nextern uint_t zfs_arc_free_target;\n\nint\nparam_set_arc_free_target(SYSCTL_HANDLER_ARGS)\n{\n\tuint_t val;\n\tint err;\n\n\tval = zfs_arc_free_target;\n\terr = sysctl_handle_int(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\tif (val < minfree)\n\t\treturn (EINVAL);\n\tif (val > vm_cnt.v_page_count)\n\t\treturn (EINVAL);\n\n\tzfs_arc_free_target = val;\n\n\treturn (0);\n}\n\n \n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, arc_free_target,\n\tCTLTYPE_UINT | CTLFLAG_RW | CTLFLAG_MPSAFE,\n\tNULL, 0, param_set_arc_free_target, \"IU\",\n\t\"Desired number of free pages below which ARC triggers reclaim\"\n\t\" (LEGACY)\");\n \n\nint\nparam_set_arc_no_grow_shift(SYSCTL_HANDLER_ARGS)\n{\n\tint err, val;\n\n\tval = arc_no_grow_shift;\n\terr = sysctl_handle_int(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\tif (val < 0 || val >= arc_shrink_shift)\n\t\treturn (EINVAL);\n\n\tarc_no_grow_shift = val;\n\n\treturn (0);\n}\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, arc_no_grow_shift,\n\tCTLTYPE_INT | CTLFLAG_RWTUN | CTLFLAG_MPSAFE,\n\tNULL, 0, param_set_arc_no_grow_shift, \"I\",\n\t\"log2(fraction of ARC which must be free to allow growing) (LEGACY)\");\n \n\nextern uint64_t l2arc_write_max;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, l2arc_write_max,\n\tCTLFLAG_RWTUN, &l2arc_write_max, 0,\n\t\"Max write bytes per interval (LEGACY)\");\n \n\nextern uint64_t l2arc_write_boost;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, l2arc_write_boost,\n\tCTLFLAG_RWTUN, &l2arc_write_boost, 0,\n\t\"Extra write bytes during device warmup (LEGACY)\");\n \n\nextern uint64_t l2arc_headroom;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, l2arc_headroom,\n\tCTLFLAG_RWTUN, &l2arc_headroom, 0,\n\t\"Number of max device writes to precache (LEGACY)\");\n \n\nextern uint64_t l2arc_headroom_boost;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, l2arc_headroom_boost,\n\tCTLFLAG_RWTUN, &l2arc_headroom_boost, 0,\n\t\"Compressed l2arc_headroom multiplier (LEGACY)\");\n \n\nextern uint64_t l2arc_feed_secs;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, l2arc_feed_secs,\n\tCTLFLAG_RWTUN, &l2arc_feed_secs, 0,\n\t\"Seconds between L2ARC writing (LEGACY)\");\n \n\nextern uint64_t l2arc_feed_min_ms;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, l2arc_feed_min_ms,\n\tCTLFLAG_RWTUN, &l2arc_feed_min_ms, 0,\n\t\"Min feed interval in milliseconds (LEGACY)\");\n \n\nextern int l2arc_noprefetch;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, l2arc_noprefetch,\n\tCTLFLAG_RWTUN, &l2arc_noprefetch, 0,\n\t\"Skip caching prefetched buffers (LEGACY)\");\n \n\nextern int l2arc_feed_again;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, l2arc_feed_again,\n\tCTLFLAG_RWTUN, &l2arc_feed_again, 0,\n\t\"Turbo L2ARC warmup (LEGACY)\");\n \n\nextern int l2arc_norw;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, l2arc_norw,\n\tCTLFLAG_RWTUN, &l2arc_norw, 0,\n\t\"No reads during writes (LEGACY)\");\n \n\nstatic int\nparam_get_arc_state_size(SYSCTL_HANDLER_ARGS)\n{\n\tarc_state_t *state = (arc_state_t *)arg1;\n\tint64_t val;\n\n\tval = zfs_refcount_count(&state->arcs_size[ARC_BUFC_DATA]) +\n\t    zfs_refcount_count(&state->arcs_size[ARC_BUFC_METADATA]);\n\treturn (sysctl_handle_64(oidp, &val, 0, req));\n}\n\nextern arc_state_t ARC_anon;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, anon_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_anon, 0, param_get_arc_state_size, \"Q\",\n\t\"size of anonymous state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, anon_metadata_esize, CTLFLAG_RD,\n\t&ARC_anon.arcs_esize[ARC_BUFC_METADATA].rc_count, 0,\n\t\"size of evictable metadata in anonymous state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, anon_data_esize, CTLFLAG_RD,\n\t&ARC_anon.arcs_esize[ARC_BUFC_DATA].rc_count, 0,\n\t\"size of evictable data in anonymous state\");\n \n\nextern arc_state_t ARC_mru;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, mru_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_mru, 0, param_get_arc_state_size, \"Q\",\n\t\"size of mru state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mru_metadata_esize, CTLFLAG_RD,\n\t&ARC_mru.arcs_esize[ARC_BUFC_METADATA].rc_count, 0,\n\t\"size of evictable metadata in mru state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mru_data_esize, CTLFLAG_RD,\n\t&ARC_mru.arcs_esize[ARC_BUFC_DATA].rc_count, 0,\n\t\"size of evictable data in mru state\");\n \n\nextern arc_state_t ARC_mru_ghost;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, mru_ghost_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_mru_ghost, 0, param_get_arc_state_size, \"Q\",\n\t\"size of mru ghost state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mru_ghost_metadata_esize, CTLFLAG_RD,\n\t&ARC_mru_ghost.arcs_esize[ARC_BUFC_METADATA].rc_count, 0,\n\t\"size of evictable metadata in mru ghost state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mru_ghost_data_esize, CTLFLAG_RD,\n\t&ARC_mru_ghost.arcs_esize[ARC_BUFC_DATA].rc_count, 0,\n\t\"size of evictable data in mru ghost state\");\n \n\nextern arc_state_t ARC_mfu;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, mfu_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_mfu, 0, param_get_arc_state_size, \"Q\",\n\t\"size of mfu state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mfu_metadata_esize, CTLFLAG_RD,\n\t&ARC_mfu.arcs_esize[ARC_BUFC_METADATA].rc_count, 0,\n\t\"size of evictable metadata in mfu state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mfu_data_esize, CTLFLAG_RD,\n\t&ARC_mfu.arcs_esize[ARC_BUFC_DATA].rc_count, 0,\n\t\"size of evictable data in mfu state\");\n \n\nextern arc_state_t ARC_mfu_ghost;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, mfu_ghost_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_mfu_ghost, 0, param_get_arc_state_size, \"Q\",\n\t\"size of mfu ghost state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mfu_ghost_metadata_esize, CTLFLAG_RD,\n\t&ARC_mfu_ghost.arcs_esize[ARC_BUFC_METADATA].rc_count, 0,\n\t\"size of evictable metadata in mfu ghost state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, mfu_ghost_data_esize, CTLFLAG_RD,\n\t&ARC_mfu_ghost.arcs_esize[ARC_BUFC_DATA].rc_count, 0,\n\t\"size of evictable data in mfu ghost state\");\n \n\nextern arc_state_t ARC_uncached;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, uncached_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_uncached, 0, param_get_arc_state_size, \"Q\",\n\t\"size of uncached state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, uncached_metadata_esize, CTLFLAG_RD,\n\t&ARC_uncached.arcs_esize[ARC_BUFC_METADATA].rc_count, 0,\n\t\"size of evictable metadata in uncached state\");\nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, uncached_data_esize, CTLFLAG_RD,\n\t&ARC_uncached.arcs_esize[ARC_BUFC_DATA].rc_count, 0,\n\t\"size of evictable data in uncached state\");\n \n\nextern arc_state_t ARC_l2c_only;\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, l2c_only_size,\n\tCTLTYPE_S64 | CTLFLAG_RD | CTLFLAG_MPSAFE,\n\t&ARC_l2c_only, 0, param_get_arc_state_size, \"Q\",\n\t\"size of l2c_only state\");\n \n\n \n\n \n\n \n\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, zfetch, CTLFLAG_RW, 0, \"ZFS ZFETCH (LEGACY)\");\n\nextern uint32_t\tzfetch_max_distance;\n\n \nSYSCTL_UINT(_vfs_zfs_zfetch, OID_AUTO, max_distance,\n\tCTLFLAG_RWTUN, &zfetch_max_distance, 0,\n\t\"Max bytes to prefetch per stream (LEGACY)\");\n \n\nextern uint32_t\tzfetch_max_idistance;\n\n \nSYSCTL_UINT(_vfs_zfs_zfetch, OID_AUTO, max_idistance,\n\tCTLFLAG_RWTUN, &zfetch_max_idistance, 0,\n\t\"Max bytes to prefetch indirects for per stream (LEGACY)\");\n \n\n \n\n \n\n \n\n \n\n \nextern int zfs_metaslab_sm_blksz_no_log;\n\n \nSYSCTL_INT(_vfs_zfs_metaslab, OID_AUTO, sm_blksz_no_log,\n\tCTLFLAG_RDTUN, &zfs_metaslab_sm_blksz_no_log, 0,\n\t\"Block size for space map in pools with log space map disabled.  \"\n\t\"Power of 2 greater than 4096.\");\n \n\n \nextern int zfs_metaslab_sm_blksz_with_log;\n\n \nSYSCTL_INT(_vfs_zfs_metaslab, OID_AUTO, sm_blksz_with_log,\n\tCTLFLAG_RDTUN, &zfs_metaslab_sm_blksz_with_log, 0,\n\t\"Block size for space map in pools with log space map enabled.  \"\n\t\"Power of 2 greater than 4096.\");\n \n\n \nextern uint_t zfs_condense_pct;\n\n \nSYSCTL_UINT(_vfs_zfs, OID_AUTO, condense_pct,\n\tCTLFLAG_RWTUN, &zfs_condense_pct, 0,\n\t\"Condense on-disk spacemap when it is more than this many percents\"\n\t\" of in-memory counterpart\");\n \n\nextern uint_t zfs_remove_max_segment;\n\n \nSYSCTL_UINT(_vfs_zfs, OID_AUTO, remove_max_segment,\n\tCTLFLAG_RWTUN, &zfs_remove_max_segment, 0,\n\t\"Largest contiguous segment ZFS will attempt to allocate when removing\"\n\t\" a device\");\n \n\nextern int zfs_removal_suspend_progress;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, removal_suspend_progress,\n\tCTLFLAG_RWTUN, &zfs_removal_suspend_progress, 0,\n\t\"Ensures certain actions can happen while in the middle of a removal\");\n \n\n \nextern uint64_t metaslab_df_alloc_threshold;\n\n \nSYSCTL_QUAD(_vfs_zfs_metaslab, OID_AUTO, df_alloc_threshold,\n\tCTLFLAG_RWTUN, &metaslab_df_alloc_threshold, 0,\n\t\"Minimum size which forces the dynamic allocator to change its\"\n\t\" allocation strategy\");\n \n\n \nextern uint_t metaslab_df_free_pct;\n\n \nSYSCTL_UINT(_vfs_zfs_metaslab, OID_AUTO, df_free_pct,\n\tCTLFLAG_RWTUN, &metaslab_df_free_pct, 0,\n\t\"The minimum free space, in percent, which must be available in a\"\n\t\" space map to continue allocations in a first-fit fashion\");\n \n\n \n\nint\nparam_set_multihost_interval(SYSCTL_HANDLER_ARGS)\n{\n\tint err;\n\n\terr = sysctl_handle_64(oidp, &zfs_multihost_interval, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\tif (spa_mode_global != SPA_MODE_UNINIT)\n\t\tmmp_signal_all_threads();\n\n\treturn (0);\n}\n\n \n\nextern int zfs_ccw_retry_interval;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, ccw_retry_interval,\n\tCTLFLAG_RWTUN, &zfs_ccw_retry_interval, 0,\n\t\"Configuration cache file write, retry after failure, interval\"\n\t\" (seconds)\");\n \n\nextern uint64_t zfs_max_missing_tvds_cachefile;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, max_missing_tvds_cachefile,\n\tCTLFLAG_RWTUN, &zfs_max_missing_tvds_cachefile, 0,\n\t\"Allow importing pools with missing top-level vdevs in cache file\");\n \n\nextern uint64_t zfs_max_missing_tvds_scan;\n\n \nSYSCTL_UQUAD(_vfs_zfs, OID_AUTO, max_missing_tvds_scan,\n\tCTLFLAG_RWTUN, &zfs_max_missing_tvds_scan, 0,\n\t\"Allow importing pools with missing top-level vdevs during scan\");\n \n\n \n\nextern int zfs_flags;\n\nstatic int\nsysctl_vfs_zfs_debug_flags(SYSCTL_HANDLER_ARGS)\n{\n\tint err, val;\n\n\tval = zfs_flags;\n\terr = sysctl_handle_int(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\t \n\tif (!(zfs_flags & ZFS_DEBUG_MODIFY))\n\t\tval &= ~ZFS_DEBUG_MODIFY;\n\tzfs_flags = val;\n\n\treturn (0);\n}\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, debugflags,\n\tCTLTYPE_UINT | CTLFLAG_MPSAFE | CTLFLAG_RWTUN, NULL, 0,\n\tsysctl_vfs_zfs_debug_flags, \"IU\", \"Debug flags for ZFS testing.\");\n \n\nint\nparam_set_deadman_synctime(SYSCTL_HANDLER_ARGS)\n{\n\tunsigned long val;\n\tint err;\n\n\tval = zfs_deadman_synctime_ms;\n\terr = sysctl_handle_64(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\tzfs_deadman_synctime_ms = val;\n\n\tspa_set_deadman_synctime(MSEC2NSEC(zfs_deadman_synctime_ms));\n\n\treturn (0);\n}\n\nint\nparam_set_deadman_ziotime(SYSCTL_HANDLER_ARGS)\n{\n\tunsigned long val;\n\tint err;\n\n\tval = zfs_deadman_ziotime_ms;\n\terr = sysctl_handle_64(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\tzfs_deadman_ziotime_ms = val;\n\n\tspa_set_deadman_ziotime(MSEC2NSEC(zfs_deadman_synctime_ms));\n\n\treturn (0);\n}\n\nint\nparam_set_deadman_failmode(SYSCTL_HANDLER_ARGS)\n{\n\tchar buf[16];\n\tint rc;\n\n\tif (req->newptr == NULL)\n\t\tstrlcpy(buf, zfs_deadman_failmode, sizeof (buf));\n\n\trc = sysctl_handle_string(oidp, buf, sizeof (buf), req);\n\tif (rc || req->newptr == NULL)\n\t\treturn (rc);\n\tif (strcmp(buf, zfs_deadman_failmode) == 0)\n\t\treturn (0);\n\tif (strcmp(buf, \"wait\") == 0)\n\t\tzfs_deadman_failmode = \"wait\";\n\tif (strcmp(buf, \"continue\") == 0)\n\t\tzfs_deadman_failmode = \"continue\";\n\tif (strcmp(buf, \"panic\") == 0)\n\t\tzfs_deadman_failmode = \"panic\";\n\n\treturn (-param_set_deadman_failmode_common(buf));\n}\n\nint\nparam_set_slop_shift(SYSCTL_HANDLER_ARGS)\n{\n\tint val;\n\tint err;\n\n\tval = spa_slop_shift;\n\terr = sysctl_handle_int(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (err);\n\n\tif (val < 1 || val > 31)\n\t\treturn (EINVAL);\n\n\tspa_slop_shift = val;\n\n\treturn (0);\n}\n\n \n\nextern int space_map_ibs;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, space_map_ibs, CTLFLAG_RWTUN,\n\t&space_map_ibs, 0, \"Space map indirect block shift\");\n \n\n\n \n\nint\nparam_set_min_auto_ashift(SYSCTL_HANDLER_ARGS)\n{\n\tint val;\n\tint err;\n\n\tval = zfs_vdev_min_auto_ashift;\n\terr = sysctl_handle_int(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (SET_ERROR(err));\n\n\tif (val < ASHIFT_MIN || val > zfs_vdev_max_auto_ashift)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzfs_vdev_min_auto_ashift = val;\n\n\treturn (0);\n}\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, min_auto_ashift,\n\tCTLTYPE_UINT | CTLFLAG_RWTUN | CTLFLAG_MPSAFE,\n\t&zfs_vdev_min_auto_ashift, sizeof (zfs_vdev_min_auto_ashift),\n\tparam_set_min_auto_ashift, \"IU\",\n\t\"Min ashift used when creating new top-level vdev. (LEGACY)\");\n \n\nint\nparam_set_max_auto_ashift(SYSCTL_HANDLER_ARGS)\n{\n\tint val;\n\tint err;\n\n\tval = zfs_vdev_max_auto_ashift;\n\terr = sysctl_handle_int(oidp, &val, 0, req);\n\tif (err != 0 || req->newptr == NULL)\n\t\treturn (SET_ERROR(err));\n\n\tif (val > ASHIFT_MAX || val < zfs_vdev_min_auto_ashift)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tzfs_vdev_max_auto_ashift = val;\n\n\treturn (0);\n}\n\n \nSYSCTL_PROC(_vfs_zfs, OID_AUTO, max_auto_ashift,\n\tCTLTYPE_UINT | CTLFLAG_RWTUN | CTLFLAG_MPSAFE,\n\t&zfs_vdev_max_auto_ashift, sizeof (zfs_vdev_max_auto_ashift),\n\tparam_set_max_auto_ashift, \"IU\",\n\t\"Max ashift used when optimizing for logical -> physical sector size on\"\n\t\" new top-level vdevs. (LEGACY)\");\n \n\n \nextern int zfs_vdev_dtl_sm_blksz;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, dtl_sm_blksz,\n\tCTLFLAG_RDTUN, &zfs_vdev_dtl_sm_blksz, 0,\n\t\"Block size for DTL space map.  Power of 2 greater than 4096.\");\n \n\n \nextern int zfs_vdev_standard_sm_blksz;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, standard_sm_blksz,\n\tCTLFLAG_RDTUN, &zfs_vdev_standard_sm_blksz, 0,\n\t\"Block size for standard space map.  Power of 2 greater than 4096.\");\n \n\nextern int vdev_validate_skip;\n\n \nSYSCTL_INT(_vfs_zfs, OID_AUTO, validate_skip,\n\tCTLFLAG_RDTUN, &vdev_validate_skip, 0,\n\t\"Enable to bypass vdev_validate().\");\n \n\n \n\n \n\nextern uint_t zfs_vdev_max_active;\n\n \nSYSCTL_UINT(_vfs_zfs, OID_AUTO, top_maxinflight,\n\tCTLFLAG_RWTUN, &zfs_vdev_max_active, 0,\n\t\"The maximum number of I/Os of all types active for each device.\"\n\t\" (LEGACY)\");\n \n\n \n\n \nSYSCTL_INT(_vfs_zfs_zio, OID_AUTO, exclude_metadata,\n\tCTLFLAG_RDTUN, &zio_exclude_metadata, 0,\n\t\"Exclude metadata buffers from dumps as well\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}