{
  "module_name": "zvol_os.c",
  "hash_id": "c77f6e8f26014b104bb27d26cf22a6b2f36297d57e352222c5a6887bf23ce93c",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zvol_os.c",
  "human_readable_source": " \n \n\n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/uio.h>\n#include <sys/bio.h>\n#include <sys/buf.h>\n#include <sys/kmem.h>\n#include <sys/conf.h>\n#include <sys/cmn_err.h>\n#include <sys/stat.h>\n#include <sys/proc.h>\n#include <sys/zap.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/zio.h>\n#include <sys/disk.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dnode.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_dir.h>\n#include <sys/byteorder.h>\n#include <sys/sunddi.h>\n#include <sys/dirent.h>\n#include <sys/policy.h>\n#include <sys/queue.h>\n#include <sys/fs/zfs.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zil.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_rlock.h>\n#include <sys/vdev_impl.h>\n#include <sys/vdev_raidz.h>\n#include <sys/zvol.h>\n#include <sys/zil_impl.h>\n#include <sys/dataset_kstats.h>\n#include <sys/dbuf.h>\n#include <sys/dmu_tx.h>\n#include <sys/zfeature.h>\n#include <sys/zio_checksum.h>\n#include <sys/zil_impl.h>\n#include <sys/filio.h>\n#include <sys/freebsd_event.h>\n\n#include <geom/geom.h>\n#include <sys/zvol.h>\n#include <sys/zvol_impl.h>\n\n#include \"zfs_namecheck.h\"\n\n#define\tZVOL_DUMPSIZE\t\t\"dumpsize\"\n\n#ifdef ZVOL_LOCK_DEBUG\n#define\tZVOL_RW_READER\t\tRW_WRITER\n#define\tZVOL_RW_READ_HELD\tRW_WRITE_HELD\n#else\n#define\tZVOL_RW_READER\t\tRW_READER\n#define\tZVOL_RW_READ_HELD\tRW_READ_HELD\n#endif\n\nenum zvol_geom_state {\n\tZVOL_GEOM_UNINIT,\n\tZVOL_GEOM_STOPPED,\n\tZVOL_GEOM_RUNNING,\n};\n\nstruct zvol_state_os {\n#define\tzso_dev\t\t_zso_state._zso_dev\n#define\tzso_geom\t_zso_state._zso_geom\n\tunion {\n\t\t \n\t\tstruct zvol_state_dev {\n\t\t\tstruct cdev *zsd_cdev;\n\t\t\tuint64_t zsd_sync_cnt;\n\t\t\tstruct selinfo zsd_selinfo;\n\t\t} _zso_dev;\n\n\t\t \n\t\tstruct zvol_state_geom {\n\t\t\tstruct g_provider *zsg_provider;\n\t\t\tstruct bio_queue_head zsg_queue;\n\t\t\tstruct mtx zsg_queue_mtx;\n\t\t\tenum zvol_geom_state zsg_state;\n\t\t} _zso_geom;\n\t} _zso_state;\n\tint zso_dying;\n};\n\nstatic uint32_t zvol_minors;\n\nSYSCTL_DECL(_vfs_zfs);\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, vol, CTLFLAG_RW, 0, \"ZFS VOLUME\");\nSYSCTL_INT(_vfs_zfs_vol, OID_AUTO, mode, CTLFLAG_RWTUN, &zvol_volmode, 0,\n\t\"Expose as GEOM providers (1), device files (2) or neither\");\nstatic boolean_t zpool_on_zvol = B_FALSE;\nSYSCTL_INT(_vfs_zfs_vol, OID_AUTO, recursive, CTLFLAG_RWTUN, &zpool_on_zvol, 0,\n\t\"Allow zpools to use zvols as vdevs (DANGEROUS)\");\n\n \nboolean_t zvol_unmap_enabled = B_TRUE;\n\nSYSCTL_INT(_vfs_zfs_vol, OID_AUTO, unmap_enabled, CTLFLAG_RWTUN,\n\t&zvol_unmap_enabled, 0, \"Enable UNMAP functionality\");\n\n \nint zvol_maxphys = DMU_MAX_ACCESS / 2;\n\nstatic void zvol_ensure_zilog(zvol_state_t *zv);\n\nstatic d_open_t\t\tzvol_cdev_open;\nstatic d_close_t\tzvol_cdev_close;\nstatic d_ioctl_t\tzvol_cdev_ioctl;\nstatic d_read_t\t\tzvol_cdev_read;\nstatic d_write_t\tzvol_cdev_write;\nstatic d_strategy_t\tzvol_geom_bio_strategy;\nstatic d_kqfilter_t\tzvol_cdev_kqfilter;\n\nstatic struct cdevsw zvol_cdevsw = {\n\t.d_name =\t\"zvol\",\n\t.d_version =\tD_VERSION,\n\t.d_flags =\tD_DISK | D_TRACKCLOSE,\n\t.d_open =\tzvol_cdev_open,\n\t.d_close =\tzvol_cdev_close,\n\t.d_ioctl =\tzvol_cdev_ioctl,\n\t.d_read =\tzvol_cdev_read,\n\t.d_write =\tzvol_cdev_write,\n\t.d_strategy =\tzvol_geom_bio_strategy,\n\t.d_kqfilter =\tzvol_cdev_kqfilter,\n};\n\nstatic void\t\tzvol_filter_detach(struct knote *kn);\nstatic int\t\tzvol_filter_vnode(struct knote *kn, long hint);\n\nstatic struct filterops zvol_filterops_vnode = {\n\t.f_isfd = 1,\n\t.f_detach = zvol_filter_detach,\n\t.f_event = zvol_filter_vnode,\n};\n\nextern uint_t zfs_geom_probe_vdev_key;\n\nstruct g_class zfs_zvol_class = {\n\t.name = \"ZFS::ZVOL\",\n\t.version = G_VERSION,\n};\n\nDECLARE_GEOM_CLASS(zfs_zvol_class, zfs_zvol);\n\nstatic int zvol_geom_open(struct g_provider *pp, int flag, int count);\nstatic int zvol_geom_close(struct g_provider *pp, int flag, int count);\nstatic void zvol_geom_run(zvol_state_t *zv);\nstatic void zvol_geom_destroy(zvol_state_t *zv);\nstatic int zvol_geom_access(struct g_provider *pp, int acr, int acw, int ace);\nstatic void zvol_geom_worker(void *arg);\nstatic void zvol_geom_bio_start(struct bio *bp);\nstatic int zvol_geom_bio_getattr(struct bio *bp);\n \n\n \n\nstatic int\nzvol_geom_open(struct g_provider *pp, int flag, int count)\n{\n\tzvol_state_t *zv;\n\tint err = 0;\n\tboolean_t drop_suspend = B_FALSE;\n\n\tif (!zpool_on_zvol && tsd_get(zfs_geom_probe_vdev_key) != NULL) {\n\t\t \n\t\treturn (SET_ERROR(EOPNOTSUPP));\n\t}\n\nretry:\n\trw_enter(&zvol_state_lock, ZVOL_RW_READER);\n\t \n\tzv = pp->private;\n\tif (zv == NULL) {\n\t\trw_exit(&zvol_state_lock);\n\t\terr = SET_ERROR(ENXIO);\n\t\tgoto out_locked;\n\t}\n\n\tmutex_enter(&zv->zv_state_lock);\n\tif (zv->zv_zso->zso_dying) {\n\t\trw_exit(&zvol_state_lock);\n\t\terr = SET_ERROR(ENXIO);\n\t\tgoto out_zv_locked;\n\t}\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_GEOM);\n\n\t \n\tif (zv->zv_open_count == 0) {\n\t\tdrop_suspend = B_TRUE;\n\t\tif (!rw_tryenter(&zv->zv_suspend_lock, ZVOL_RW_READER)) {\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\t\t\tmutex_enter(&zv->zv_state_lock);\n\t\t\t \n\t\t\tif (zv->zv_open_count != 0) {\n\t\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\t\tdrop_suspend = B_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\trw_exit(&zvol_state_lock);\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\tif (zv->zv_open_count == 0) {\n\t\tboolean_t drop_namespace = B_FALSE;\n\n\t\tASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));\n\n\t\t \n\t\tif (!mutex_owned(&spa_namespace_lock)) {\n\t\t\tif (!mutex_tryenter(&spa_namespace_lock)) {\n\t\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\t\tkern_yield(PRI_USER);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tdrop_namespace = B_TRUE;\n\t\t\t}\n\t\t}\n\t\terr = zvol_first_open(zv, !(flag & FWRITE));\n\t\tif (drop_namespace)\n\t\t\tmutex_exit(&spa_namespace_lock);\n\t\tif (err)\n\t\t\tgoto out_zv_locked;\n\t\tpp->mediasize = zv->zv_volsize;\n\t\tpp->stripeoffset = 0;\n\t\tpp->stripesize = zv->zv_volblocksize;\n\t}\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\t \n\tif ((flag & FWRITE) && ((zv->zv_flags & ZVOL_RDONLY) ||\n\t    dmu_objset_incompatible_encryption_version(zv->zv_objset))) {\n\t\terr = SET_ERROR(EROFS);\n\t\tgoto out_opened;\n\t}\n\tif (zv->zv_flags & ZVOL_EXCL) {\n\t\terr = SET_ERROR(EBUSY);\n\t\tgoto out_opened;\n\t}\n\tif (flag & O_EXCL) {\n\t\tif (zv->zv_open_count != 0) {\n\t\t\terr = SET_ERROR(EBUSY);\n\t\t\tgoto out_opened;\n\t\t}\n\t\tzv->zv_flags |= ZVOL_EXCL;\n\t}\n\n\tzv->zv_open_count += count;\nout_opened:\n\tif (zv->zv_open_count == 0) {\n\t\tzvol_last_close(zv);\n\t\twakeup(zv);\n\t}\nout_zv_locked:\n\tmutex_exit(&zv->zv_state_lock);\nout_locked:\n\tif (drop_suspend)\n\t\trw_exit(&zv->zv_suspend_lock);\n\treturn (err);\n}\n\nstatic int\nzvol_geom_close(struct g_provider *pp, int flag, int count)\n{\n\t(void) flag;\n\tzvol_state_t *zv;\n\tboolean_t drop_suspend = B_TRUE;\n\tint new_open_count;\n\n\trw_enter(&zvol_state_lock, ZVOL_RW_READER);\n\tzv = pp->private;\n\tif (zv == NULL) {\n\t\trw_exit(&zvol_state_lock);\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\tmutex_enter(&zv->zv_state_lock);\n\tif (zv->zv_flags & ZVOL_EXCL) {\n\t\tASSERT3U(zv->zv_open_count, ==, 1);\n\t\tzv->zv_flags &= ~ZVOL_EXCL;\n\t}\n\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_GEOM);\n\n\t \n\tASSERT3U(zv->zv_open_count, >, 0);\n\n\t \n\tnew_open_count = zv->zv_open_count - count;\n\tif (new_open_count == 0) {\n\t\tif (!rw_tryenter(&zv->zv_suspend_lock, ZVOL_RW_READER)) {\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\t\t\tmutex_enter(&zv->zv_state_lock);\n\t\t\t \n\t\t\tnew_open_count = zv->zv_open_count - count;\n\t\t\tif (new_open_count != 0) {\n\t\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\t\tdrop_suspend = B_FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdrop_suspend = B_FALSE;\n\t}\n\trw_exit(&zvol_state_lock);\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\t \n\tzv->zv_open_count = new_open_count;\n\tif (zv->zv_open_count == 0) {\n\t\tASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));\n\t\tzvol_last_close(zv);\n\t\twakeup(zv);\n\t}\n\n\tmutex_exit(&zv->zv_state_lock);\n\n\tif (drop_suspend)\n\t\trw_exit(&zv->zv_suspend_lock);\n\treturn (0);\n}\n\nstatic void\nzvol_geom_run(zvol_state_t *zv)\n{\n\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\tstruct g_provider *pp = zsg->zsg_provider;\n\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_GEOM);\n\n\tg_error_provider(pp, 0);\n\n\tkproc_kthread_add(zvol_geom_worker, zv, &system_proc, NULL, 0, 0,\n\t    \"zfskern\", \"zvol %s\", pp->name + sizeof (ZVOL_DRIVER));\n}\n\nstatic void\nzvol_geom_destroy(zvol_state_t *zv)\n{\n\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\tstruct g_provider *pp = zsg->zsg_provider;\n\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_GEOM);\n\n\tg_topology_assert();\n\n\tmutex_enter(&zv->zv_state_lock);\n\tVERIFY3S(zsg->zsg_state, ==, ZVOL_GEOM_RUNNING);\n\tmutex_exit(&zv->zv_state_lock);\n\tzsg->zsg_provider = NULL;\n\tg_wither_geom(pp->geom, ENXIO);\n}\n\nvoid\nzvol_wait_close(zvol_state_t *zv)\n{\n\n\tif (zv->zv_volmode != ZFS_VOLMODE_GEOM)\n\t\treturn;\n\tmutex_enter(&zv->zv_state_lock);\n\tzv->zv_zso->zso_dying = B_TRUE;\n\n\tif (zv->zv_open_count)\n\t\tmsleep(zv, &zv->zv_state_lock,\n\t\t    PRIBIO, \"zvol:dying\", 10*hz);\n\tmutex_exit(&zv->zv_state_lock);\n}\n\n\nstatic int\nzvol_geom_access(struct g_provider *pp, int acr, int acw, int ace)\n{\n\tint count, error, flags;\n\n\tg_topology_assert();\n\n\t \n\tKASSERT((acr >= 0 && acw >= 0 && ace >= 0) ||\n\t    (acr <= 0 && acw <= 0 && ace <= 0),\n\t    (\"Unsupported access request to %s (acr=%d, acw=%d, ace=%d).\",\n\t    pp->name, acr, acw, ace));\n\n\tif (pp->private == NULL) {\n\t\tif (acr <= 0 && acw <= 0 && ace <= 0)\n\t\t\treturn (0);\n\t\treturn (pp->error);\n\t}\n\n\t \n\n\tcount = acr + acw + ace;\n\tif (count == 0)\n\t\treturn (0);\n\n\tflags = 0;\n\tif (acr != 0 || ace != 0)\n\t\tflags |= FREAD;\n\tif (acw != 0)\n\t\tflags |= FWRITE;\n\n\tg_topology_unlock();\n\tif (count > 0)\n\t\terror = zvol_geom_open(pp, flags, count);\n\telse\n\t\terror = zvol_geom_close(pp, flags, -count);\n\tg_topology_lock();\n\treturn (error);\n}\n\nstatic void\nzvol_geom_worker(void *arg)\n{\n\tzvol_state_t *zv = arg;\n\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\tstruct bio *bp;\n\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_GEOM);\n\n\tthread_lock(curthread);\n\tsched_prio(curthread, PRIBIO);\n\tthread_unlock(curthread);\n\n\tfor (;;) {\n\t\tmtx_lock(&zsg->zsg_queue_mtx);\n\t\tbp = bioq_takefirst(&zsg->zsg_queue);\n\t\tif (bp == NULL) {\n\t\t\tif (zsg->zsg_state == ZVOL_GEOM_STOPPED) {\n\t\t\t\tzsg->zsg_state = ZVOL_GEOM_RUNNING;\n\t\t\t\twakeup(&zsg->zsg_state);\n\t\t\t\tmtx_unlock(&zsg->zsg_queue_mtx);\n\t\t\t\tkthread_exit();\n\t\t\t}\n\t\t\tmsleep(&zsg->zsg_queue, &zsg->zsg_queue_mtx,\n\t\t\t    PRIBIO | PDROP, \"zvol:io\", 0);\n\t\t\tcontinue;\n\t\t}\n\t\tmtx_unlock(&zsg->zsg_queue_mtx);\n\t\tzvol_geom_bio_strategy(bp);\n\t}\n}\n\nstatic void\nzvol_geom_bio_start(struct bio *bp)\n{\n\tzvol_state_t *zv = bp->bio_to->private;\n\tstruct zvol_state_geom *zsg;\n\tboolean_t first;\n\n\tif (zv == NULL) {\n\t\tg_io_deliver(bp, ENXIO);\n\t\treturn;\n\t}\n\tif (bp->bio_cmd == BIO_GETATTR) {\n\t\tif (zvol_geom_bio_getattr(bp))\n\t\t\tg_io_deliver(bp, EOPNOTSUPP);\n\t\treturn;\n\t}\n\n\tif (!THREAD_CAN_SLEEP()) {\n\t\tzsg = &zv->zv_zso->zso_geom;\n\t\tmtx_lock(&zsg->zsg_queue_mtx);\n\t\tfirst = (bioq_first(&zsg->zsg_queue) == NULL);\n\t\tbioq_insert_tail(&zsg->zsg_queue, bp);\n\t\tmtx_unlock(&zsg->zsg_queue_mtx);\n\t\tif (first)\n\t\t\twakeup_one(&zsg->zsg_queue);\n\t\treturn;\n\t}\n\n\tzvol_geom_bio_strategy(bp);\n}\n\nstatic int\nzvol_geom_bio_getattr(struct bio *bp)\n{\n\tzvol_state_t *zv;\n\n\tzv = bp->bio_to->private;\n\tASSERT3P(zv, !=, NULL);\n\n\tspa_t *spa = dmu_objset_spa(zv->zv_objset);\n\tuint64_t refd, avail, usedobjs, availobjs;\n\n\tif (g_handleattr_int(bp, \"GEOM::candelete\", 1))\n\t\treturn (0);\n\tif (strcmp(bp->bio_attribute, \"blocksavail\") == 0) {\n\t\tdmu_objset_space(zv->zv_objset, &refd, &avail,\n\t\t    &usedobjs, &availobjs);\n\t\tif (g_handleattr_off_t(bp, \"blocksavail\", avail / DEV_BSIZE))\n\t\t\treturn (0);\n\t} else if (strcmp(bp->bio_attribute, \"blocksused\") == 0) {\n\t\tdmu_objset_space(zv->zv_objset, &refd, &avail,\n\t\t    &usedobjs, &availobjs);\n\t\tif (g_handleattr_off_t(bp, \"blocksused\", refd / DEV_BSIZE))\n\t\t\treturn (0);\n\t} else if (strcmp(bp->bio_attribute, \"poolblocksavail\") == 0) {\n\t\tavail = metaslab_class_get_space(spa_normal_class(spa));\n\t\tavail -= metaslab_class_get_alloc(spa_normal_class(spa));\n\t\tif (g_handleattr_off_t(bp, \"poolblocksavail\",\n\t\t    avail / DEV_BSIZE))\n\t\t\treturn (0);\n\t} else if (strcmp(bp->bio_attribute, \"poolblocksused\") == 0) {\n\t\trefd = metaslab_class_get_alloc(spa_normal_class(spa));\n\t\tif (g_handleattr_off_t(bp, \"poolblocksused\", refd / DEV_BSIZE))\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nstatic void\nzvol_filter_detach(struct knote *kn)\n{\n\tzvol_state_t *zv;\n\tstruct zvol_state_dev *zsd;\n\n\tzv = kn->kn_hook;\n\tzsd = &zv->zv_zso->zso_dev;\n\n\tknlist_remove(&zsd->zsd_selinfo.si_note, kn, 0);\n}\n\nstatic int\nzvol_filter_vnode(struct knote *kn, long hint)\n{\n\tkn->kn_fflags |= kn->kn_sfflags & hint;\n\n\treturn (kn->kn_fflags != 0);\n}\n\nstatic int\nzvol_cdev_kqfilter(struct cdev *dev, struct knote *kn)\n{\n\tzvol_state_t *zv;\n\tstruct zvol_state_dev *zsd;\n\n\tzv = dev->si_drv2;\n\tzsd = &zv->zv_zso->zso_dev;\n\n\tif (kn->kn_filter != EVFILT_VNODE)\n\t\treturn (EINVAL);\n\n\t \n\tif (kn->kn_sfflags != NOTE_ATTRIB)\n\t\treturn (EINVAL);\n\n\tkn->kn_fop = &zvol_filterops_vnode;\n\tkn->kn_hook = zv;\n\tknlist_add(&zsd->zsd_selinfo.si_note, kn, 0);\n\n\treturn (0);\n}\n\nstatic void\nzvol_geom_bio_strategy(struct bio *bp)\n{\n\tzvol_state_t *zv;\n\tuint64_t off, volsize;\n\tsize_t resid;\n\tchar *addr;\n\tobjset_t *os;\n\tzfs_locked_range_t *lr;\n\tint error = 0;\n\tboolean_t doread = B_FALSE;\n\tboolean_t is_dumpified;\n\tboolean_t sync;\n\n\tif (bp->bio_to)\n\t\tzv = bp->bio_to->private;\n\telse\n\t\tzv = bp->bio_dev->si_drv2;\n\n\tif (zv == NULL) {\n\t\terror = SET_ERROR(ENXIO);\n\t\tgoto out;\n\t}\n\n\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\n\tswitch (bp->bio_cmd) {\n\tcase BIO_READ:\n\t\tdoread = B_TRUE;\n\t\tbreak;\n\tcase BIO_WRITE:\n\tcase BIO_FLUSH:\n\tcase BIO_DELETE:\n\t\tif (zv->zv_flags & ZVOL_RDONLY) {\n\t\t\terror = SET_ERROR(EROFS);\n\t\t\tgoto resume;\n\t\t}\n\t\tzvol_ensure_zilog(zv);\n\t\tif (bp->bio_cmd == BIO_FLUSH)\n\t\t\tgoto sync;\n\t\tbreak;\n\tdefault:\n\t\terror = SET_ERROR(EOPNOTSUPP);\n\t\tgoto resume;\n\t}\n\n\toff = bp->bio_offset;\n\tvolsize = zv->zv_volsize;\n\n\tos = zv->zv_objset;\n\tASSERT3P(os, !=, NULL);\n\n\taddr = bp->bio_data;\n\tresid = bp->bio_length;\n\n\tif (resid > 0 && off >= volsize) {\n\t\terror = SET_ERROR(EIO);\n\t\tgoto resume;\n\t}\n\n\tis_dumpified = B_FALSE;\n\tsync = !doread && !is_dumpified &&\n\t    zv->zv_objset->os_sync == ZFS_SYNC_ALWAYS;\n\n\t \n\tlr = zfs_rangelock_enter(&zv->zv_rangelock, off, resid,\n\t    doread ? RL_READER : RL_WRITER);\n\n\tif (bp->bio_cmd == BIO_DELETE) {\n\t\tdmu_tx_t *tx = dmu_tx_create(zv->zv_objset);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error != 0) {\n\t\t\tdmu_tx_abort(tx);\n\t\t} else {\n\t\t\tzvol_log_truncate(zv, tx, off, resid, sync);\n\t\t\tdmu_tx_commit(tx);\n\t\t\terror = dmu_free_long_range(zv->zv_objset, ZVOL_OBJ,\n\t\t\t    off, resid);\n\t\t\tresid = 0;\n\t\t}\n\t\tgoto unlock;\n\t}\n\twhile (resid != 0 && off < volsize) {\n\t\tsize_t size = MIN(resid, zvol_maxphys);\n\t\tif (doread) {\n\t\t\terror = dmu_read(os, ZVOL_OBJ, off, size, addr,\n\t\t\t    DMU_READ_PREFETCH);\n\t\t} else {\n\t\t\tdmu_tx_t *tx = dmu_tx_create(os);\n\t\t\tdmu_tx_hold_write_by_dnode(tx, zv->zv_dn, off, size);\n\t\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\t\tif (error) {\n\t\t\t\tdmu_tx_abort(tx);\n\t\t\t} else {\n\t\t\t\tdmu_write(os, ZVOL_OBJ, off, size, addr, tx);\n\t\t\t\tzvol_log_write(zv, tx, off, size, sync);\n\t\t\t\tdmu_tx_commit(tx);\n\t\t\t}\n\t\t}\n\t\tif (error) {\n\t\t\t \n\t\t\tif (error == ECKSUM)\n\t\t\t\terror = SET_ERROR(EIO);\n\t\t\tbreak;\n\t\t}\n\t\toff += size;\n\t\taddr += size;\n\t\tresid -= size;\n\t}\nunlock:\n\tzfs_rangelock_exit(lr);\n\n\tbp->bio_completed = bp->bio_length - resid;\n\tif (bp->bio_completed < bp->bio_length && off > volsize)\n\t\terror = SET_ERROR(EINVAL);\n\n\tswitch (bp->bio_cmd) {\n\tcase BIO_FLUSH:\n\t\tbreak;\n\tcase BIO_READ:\n\t\tdataset_kstats_update_read_kstats(&zv->zv_kstat,\n\t\t    bp->bio_completed);\n\t\tbreak;\n\tcase BIO_WRITE:\n\t\tdataset_kstats_update_write_kstats(&zv->zv_kstat,\n\t\t    bp->bio_completed);\n\t\tbreak;\n\tcase BIO_DELETE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sync) {\nsync:\n\t\tzil_commit(zv->zv_zilog, ZVOL_OBJ);\n\t}\nresume:\n\trw_exit(&zv->zv_suspend_lock);\nout:\n\tif (bp->bio_to)\n\t\tg_io_deliver(bp, error);\n\telse\n\t\tbiofinish(bp, NULL, error);\n}\n\n \n\nstatic int\nzvol_cdev_read(struct cdev *dev, struct uio *uio_s, int ioflag)\n{\n\tzvol_state_t *zv;\n\tuint64_t volsize;\n\tzfs_locked_range_t *lr;\n\tint error = 0;\n\tzfs_uio_t uio;\n\n\tzfs_uio_init(&uio, uio_s);\n\n\tzv = dev->si_drv2;\n\n\tvolsize = zv->zv_volsize;\n\t \n\tif (zfs_uio_resid(&uio) > 0 &&\n\t    (zfs_uio_offset(&uio) < 0 || zfs_uio_offset(&uio) > volsize))\n\t\treturn (SET_ERROR(EIO));\n\n\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\tssize_t start_resid = zfs_uio_resid(&uio);\n\tlr = zfs_rangelock_enter(&zv->zv_rangelock, zfs_uio_offset(&uio),\n\t    zfs_uio_resid(&uio), RL_READER);\n\twhile (zfs_uio_resid(&uio) > 0 && zfs_uio_offset(&uio) < volsize) {\n\t\tuint64_t bytes = MIN(zfs_uio_resid(&uio), DMU_MAX_ACCESS >> 1);\n\n\t\t \n\t\tif (bytes > volsize - zfs_uio_offset(&uio))\n\t\t\tbytes = volsize - zfs_uio_offset(&uio);\n\n\t\terror =  dmu_read_uio_dnode(zv->zv_dn, &uio, bytes);\n\t\tif (error) {\n\t\t\t \n\t\t\tif (error == ECKSUM)\n\t\t\t\terror = SET_ERROR(EIO);\n\t\t\tbreak;\n\t\t}\n\t}\n\tzfs_rangelock_exit(lr);\n\tint64_t nread = start_resid - zfs_uio_resid(&uio);\n\tdataset_kstats_update_read_kstats(&zv->zv_kstat, nread);\n\trw_exit(&zv->zv_suspend_lock);\n\n\treturn (error);\n}\n\nstatic int\nzvol_cdev_write(struct cdev *dev, struct uio *uio_s, int ioflag)\n{\n\tzvol_state_t *zv;\n\tuint64_t volsize;\n\tzfs_locked_range_t *lr;\n\tint error = 0;\n\tboolean_t sync;\n\tzfs_uio_t uio;\n\n\tzv = dev->si_drv2;\n\n\tvolsize = zv->zv_volsize;\n\n\tzfs_uio_init(&uio, uio_s);\n\n\tif (zfs_uio_resid(&uio) > 0 &&\n\t    (zfs_uio_offset(&uio) < 0 || zfs_uio_offset(&uio) > volsize))\n\t\treturn (SET_ERROR(EIO));\n\n\tssize_t start_resid = zfs_uio_resid(&uio);\n\tsync = (ioflag & IO_SYNC) ||\n\t    (zv->zv_objset->os_sync == ZFS_SYNC_ALWAYS);\n\n\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\tzvol_ensure_zilog(zv);\n\n\tlr = zfs_rangelock_enter(&zv->zv_rangelock, zfs_uio_offset(&uio),\n\t    zfs_uio_resid(&uio), RL_WRITER);\n\twhile (zfs_uio_resid(&uio) > 0 && zfs_uio_offset(&uio) < volsize) {\n\t\tuint64_t bytes = MIN(zfs_uio_resid(&uio), DMU_MAX_ACCESS >> 1);\n\t\tuint64_t off = zfs_uio_offset(&uio);\n\t\tdmu_tx_t *tx = dmu_tx_create(zv->zv_objset);\n\n\t\tif (bytes > volsize - off)\t \n\t\t\tbytes = volsize - off;\n\n\t\tdmu_tx_hold_write_by_dnode(tx, zv->zv_dn, off, bytes);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error) {\n\t\t\tdmu_tx_abort(tx);\n\t\t\tbreak;\n\t\t}\n\t\terror = dmu_write_uio_dnode(zv->zv_dn, &uio, bytes, tx);\n\t\tif (error == 0)\n\t\t\tzvol_log_write(zv, tx, off, bytes, sync);\n\t\tdmu_tx_commit(tx);\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tzfs_rangelock_exit(lr);\n\tint64_t nwritten = start_resid - zfs_uio_resid(&uio);\n\tdataset_kstats_update_write_kstats(&zv->zv_kstat, nwritten);\n\tif (sync)\n\t\tzil_commit(zv->zv_zilog, ZVOL_OBJ);\n\trw_exit(&zv->zv_suspend_lock);\n\treturn (error);\n}\n\nstatic int\nzvol_cdev_open(struct cdev *dev, int flags, int fmt, struct thread *td)\n{\n\tzvol_state_t *zv;\n\tstruct zvol_state_dev *zsd;\n\tint err = 0;\n\tboolean_t drop_suspend = B_FALSE;\n\nretry:\n\trw_enter(&zvol_state_lock, ZVOL_RW_READER);\n\t \n\tzv = dev->si_drv2;\n\tif (zv == NULL) {\n\t\trw_exit(&zvol_state_lock);\n\t\terr = SET_ERROR(ENXIO);\n\t\tgoto out_locked;\n\t}\n\n\tmutex_enter(&zv->zv_state_lock);\n\tif (zv->zv_zso->zso_dying) {\n\t\trw_exit(&zvol_state_lock);\n\t\terr = SET_ERROR(ENXIO);\n\t\tgoto out_zv_locked;\n\t}\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_DEV);\n\n\t \n\tif (zv->zv_open_count == 0) {\n\t\tdrop_suspend = B_TRUE;\n\t\tif (!rw_tryenter(&zv->zv_suspend_lock, ZVOL_RW_READER)) {\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\t\t\tmutex_enter(&zv->zv_state_lock);\n\t\t\t \n\t\t\tif (zv->zv_open_count != 0) {\n\t\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\t\tdrop_suspend = B_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\trw_exit(&zvol_state_lock);\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\tif (zv->zv_open_count == 0) {\n\t\tboolean_t drop_namespace = B_FALSE;\n\n\t\tASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));\n\n\t\t \n\t\tif (!mutex_owned(&spa_namespace_lock)) {\n\t\t\tif (!mutex_tryenter(&spa_namespace_lock)) {\n\t\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\t\tkern_yield(PRI_USER);\n\t\t\t\tgoto retry;\n\t\t\t} else {\n\t\t\t\tdrop_namespace = B_TRUE;\n\t\t\t}\n\t\t}\n\t\terr = zvol_first_open(zv, !(flags & FWRITE));\n\t\tif (drop_namespace)\n\t\t\tmutex_exit(&spa_namespace_lock);\n\t\tif (err)\n\t\t\tgoto out_zv_locked;\n\t}\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\tif ((flags & FWRITE) && (zv->zv_flags & ZVOL_RDONLY)) {\n\t\terr = SET_ERROR(EROFS);\n\t\tgoto out_opened;\n\t}\n\tif (zv->zv_flags & ZVOL_EXCL) {\n\t\terr = SET_ERROR(EBUSY);\n\t\tgoto out_opened;\n\t}\n\tif (flags & O_EXCL) {\n\t\tif (zv->zv_open_count != 0) {\n\t\t\terr = SET_ERROR(EBUSY);\n\t\t\tgoto out_opened;\n\t\t}\n\t\tzv->zv_flags |= ZVOL_EXCL;\n\t}\n\n\tzv->zv_open_count++;\n\tif (flags & O_SYNC) {\n\t\tzsd = &zv->zv_zso->zso_dev;\n\t\tzsd->zsd_sync_cnt++;\n\t\tif (zsd->zsd_sync_cnt == 1 &&\n\t\t    (zv->zv_flags & ZVOL_WRITTEN_TO) != 0)\n\t\t\tzil_async_to_sync(zv->zv_zilog, ZVOL_OBJ);\n\t}\nout_opened:\n\tif (zv->zv_open_count == 0) {\n\t\tzvol_last_close(zv);\n\t\twakeup(zv);\n\t}\nout_zv_locked:\n\tmutex_exit(&zv->zv_state_lock);\nout_locked:\n\tif (drop_suspend)\n\t\trw_exit(&zv->zv_suspend_lock);\n\treturn (err);\n}\n\nstatic int\nzvol_cdev_close(struct cdev *dev, int flags, int fmt, struct thread *td)\n{\n\tzvol_state_t *zv;\n\tstruct zvol_state_dev *zsd;\n\tboolean_t drop_suspend = B_TRUE;\n\n\trw_enter(&zvol_state_lock, ZVOL_RW_READER);\n\tzv = dev->si_drv2;\n\tif (zv == NULL) {\n\t\trw_exit(&zvol_state_lock);\n\t\treturn (SET_ERROR(ENXIO));\n\t}\n\n\tmutex_enter(&zv->zv_state_lock);\n\tif (zv->zv_flags & ZVOL_EXCL) {\n\t\tASSERT3U(zv->zv_open_count, ==, 1);\n\t\tzv->zv_flags &= ~ZVOL_EXCL;\n\t}\n\n\tASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_DEV);\n\n\t \n\tASSERT3U(zv->zv_open_count, >, 0);\n\t \n\tif (zv->zv_open_count == 1) {\n\t\tif (!rw_tryenter(&zv->zv_suspend_lock, ZVOL_RW_READER)) {\n\t\t\tmutex_exit(&zv->zv_state_lock);\n\t\t\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\t\t\tmutex_enter(&zv->zv_state_lock);\n\t\t\t \n\t\t\tif (zv->zv_open_count != 1) {\n\t\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\t\tdrop_suspend = B_FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdrop_suspend = B_FALSE;\n\t}\n\trw_exit(&zvol_state_lock);\n\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\t \n\tzv->zv_open_count--;\n\tif (flags & O_SYNC) {\n\t\tzsd = &zv->zv_zso->zso_dev;\n\t\tzsd->zsd_sync_cnt--;\n\t}\n\n\tif (zv->zv_open_count == 0) {\n\t\tASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));\n\t\tzvol_last_close(zv);\n\t\twakeup(zv);\n\t}\n\n\tmutex_exit(&zv->zv_state_lock);\n\n\tif (drop_suspend)\n\t\trw_exit(&zv->zv_suspend_lock);\n\treturn (0);\n}\n\nstatic int\nzvol_cdev_ioctl(struct cdev *dev, ulong_t cmd, caddr_t data,\n    int fflag, struct thread *td)\n{\n\tzvol_state_t *zv;\n\tzfs_locked_range_t *lr;\n\toff_t offset, length;\n\tint error;\n\tboolean_t sync;\n\n\tzv = dev->si_drv2;\n\n\terror = 0;\n\tKASSERT(zv->zv_open_count > 0,\n\t    (\"Device with zero access count in %s\", __func__));\n\n\tswitch (cmd) {\n\tcase DIOCGSECTORSIZE:\n\t\t*(uint32_t *)data = DEV_BSIZE;\n\t\tbreak;\n\tcase DIOCGMEDIASIZE:\n\t\t*(off_t *)data = zv->zv_volsize;\n\t\tbreak;\n\tcase DIOCGFLUSH:\n\t\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\t\tif (zv->zv_zilog != NULL)\n\t\t\tzil_commit(zv->zv_zilog, ZVOL_OBJ);\n\t\trw_exit(&zv->zv_suspend_lock);\n\t\tbreak;\n\tcase DIOCGDELETE:\n\t\tif (!zvol_unmap_enabled)\n\t\t\tbreak;\n\n\t\toffset = ((off_t *)data)[0];\n\t\tlength = ((off_t *)data)[1];\n\t\tif ((offset % DEV_BSIZE) != 0 || (length % DEV_BSIZE) != 0 ||\n\t\t    offset < 0 || offset >= zv->zv_volsize ||\n\t\t    length <= 0) {\n\t\t\tprintf(\"%s: offset=%jd length=%jd\\n\", __func__, offset,\n\t\t\t    length);\n\t\t\terror = SET_ERROR(EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\trw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);\n\t\tzvol_ensure_zilog(zv);\n\t\tlr = zfs_rangelock_enter(&zv->zv_rangelock, offset, length,\n\t\t    RL_WRITER);\n\t\tdmu_tx_t *tx = dmu_tx_create(zv->zv_objset);\n\t\terror = dmu_tx_assign(tx, TXG_WAIT);\n\t\tif (error != 0) {\n\t\t\tsync = FALSE;\n\t\t\tdmu_tx_abort(tx);\n\t\t} else {\n\t\t\tsync = (zv->zv_objset->os_sync == ZFS_SYNC_ALWAYS);\n\t\t\tzvol_log_truncate(zv, tx, offset, length, sync);\n\t\t\tdmu_tx_commit(tx);\n\t\t\terror = dmu_free_long_range(zv->zv_objset, ZVOL_OBJ,\n\t\t\t    offset, length);\n\t\t}\n\t\tzfs_rangelock_exit(lr);\n\t\tif (sync)\n\t\t\tzil_commit(zv->zv_zilog, ZVOL_OBJ);\n\t\trw_exit(&zv->zv_suspend_lock);\n\t\tbreak;\n\tcase DIOCGSTRIPESIZE:\n\t\t*(off_t *)data = zv->zv_volblocksize;\n\t\tbreak;\n\tcase DIOCGSTRIPEOFFSET:\n\t\t*(off_t *)data = 0;\n\t\tbreak;\n\tcase DIOCGATTR: {\n\t\tspa_t *spa = dmu_objset_spa(zv->zv_objset);\n\t\tstruct diocgattr_arg *arg = (struct diocgattr_arg *)data;\n\t\tuint64_t refd, avail, usedobjs, availobjs;\n\n\t\tif (strcmp(arg->name, \"GEOM::candelete\") == 0)\n\t\t\targ->value.i = 1;\n\t\telse if (strcmp(arg->name, \"blocksavail\") == 0) {\n\t\t\tdmu_objset_space(zv->zv_objset, &refd, &avail,\n\t\t\t    &usedobjs, &availobjs);\n\t\t\targ->value.off = avail / DEV_BSIZE;\n\t\t} else if (strcmp(arg->name, \"blocksused\") == 0) {\n\t\t\tdmu_objset_space(zv->zv_objset, &refd, &avail,\n\t\t\t    &usedobjs, &availobjs);\n\t\t\targ->value.off = refd / DEV_BSIZE;\n\t\t} else if (strcmp(arg->name, \"poolblocksavail\") == 0) {\n\t\t\tavail = metaslab_class_get_space(spa_normal_class(spa));\n\t\t\tavail -= metaslab_class_get_alloc(\n\t\t\t    spa_normal_class(spa));\n\t\t\targ->value.off = avail / DEV_BSIZE;\n\t\t} else if (strcmp(arg->name, \"poolblocksused\") == 0) {\n\t\t\trefd = metaslab_class_get_alloc(spa_normal_class(spa));\n\t\t\targ->value.off = refd / DEV_BSIZE;\n\t\t} else\n\t\t\terror = SET_ERROR(ENOIOCTL);\n\t\tbreak;\n\t}\n\tcase FIOSEEKHOLE:\n\tcase FIOSEEKDATA: {\n\t\toff_t *off = (off_t *)data;\n\t\tuint64_t noff;\n\t\tboolean_t hole;\n\n\t\thole = (cmd == FIOSEEKHOLE);\n\t\tnoff = *off;\n\t\tlr = zfs_rangelock_enter(&zv->zv_rangelock, 0, UINT64_MAX,\n\t\t    RL_READER);\n\t\terror = dmu_offset_next(zv->zv_objset, ZVOL_OBJ, hole, &noff);\n\t\tzfs_rangelock_exit(lr);\n\t\t*off = noff;\n\t\tbreak;\n\t}\n\tdefault:\n\t\terror = SET_ERROR(ENOIOCTL);\n\t}\n\n\treturn (error);\n}\n\n \n\nstatic void\nzvol_ensure_zilog(zvol_state_t *zv)\n{\n\tASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));\n\n\t \n\tif (zv->zv_zilog == NULL) {\n\t\tif (!rw_tryupgrade(&zv->zv_suspend_lock)) {\n\t\t\trw_exit(&zv->zv_suspend_lock);\n\t\t\trw_enter(&zv->zv_suspend_lock, RW_WRITER);\n\t\t}\n\t\tif (zv->zv_zilog == NULL) {\n\t\t\tzv->zv_zilog = zil_open(zv->zv_objset,\n\t\t\t    zvol_get_data, &zv->zv_kstat.dk_zil_sums);\n\t\t\tzv->zv_flags |= ZVOL_WRITTEN_TO;\n\t\t\t \n\t\t\tVERIFY0(zv->zv_zilog->zl_header->zh_flags &\n\t\t\t    ZIL_REPLAY_NEEDED);\n\t\t}\n\t\trw_downgrade(&zv->zv_suspend_lock);\n\t}\n}\n\nboolean_t\nzvol_os_is_zvol(const char *device)\n{\n\treturn (device && strncmp(device, ZVOL_DIR, strlen(ZVOL_DIR)) == 0);\n}\n\nvoid\nzvol_os_rename_minor(zvol_state_t *zv, const char *newname)\n{\n\tASSERT(RW_LOCK_HELD(&zvol_state_lock));\n\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\n\t \n\tzv->zv_hash = zvol_name_hash(zv->zv_name);\n\thlist_del(&zv->zv_hlink);\n\thlist_add_head(&zv->zv_hlink, ZVOL_HT_HEAD(zv->zv_hash));\n\n\tif (zv->zv_volmode == ZFS_VOLMODE_GEOM) {\n\t\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\t\tstruct g_provider *pp = zsg->zsg_provider;\n\t\tstruct g_geom *gp;\n\n\t\tg_topology_lock();\n\t\tgp = pp->geom;\n\t\tASSERT3P(gp, !=, NULL);\n\n\t\tzsg->zsg_provider = NULL;\n\t\tg_wither_provider(pp, ENXIO);\n\n\t\tpp = g_new_providerf(gp, \"%s/%s\", ZVOL_DRIVER, newname);\n\t\tpp->flags |= G_PF_DIRECT_RECEIVE | G_PF_DIRECT_SEND;\n\t\tpp->sectorsize = DEV_BSIZE;\n\t\tpp->mediasize = zv->zv_volsize;\n\t\tpp->private = zv;\n\t\tzsg->zsg_provider = pp;\n\t\tg_error_provider(pp, 0);\n\t\tg_topology_unlock();\n\t} else if (zv->zv_volmode == ZFS_VOLMODE_DEV) {\n\t\tstruct zvol_state_dev *zsd = &zv->zv_zso->zso_dev;\n\t\tstruct cdev *dev;\n\t\tstruct make_dev_args args;\n\n\t\tdev = zsd->zsd_cdev;\n\t\tif (dev != NULL) {\n\t\t\tdestroy_dev(dev);\n\t\t\tdev = zsd->zsd_cdev = NULL;\n\t\t\tif (zv->zv_open_count > 0) {\n\t\t\t\tzv->zv_flags &= ~ZVOL_EXCL;\n\t\t\t\tzv->zv_open_count = 0;\n\t\t\t\t \n\t\t\t\tzvol_last_close(zv);\n\t\t\t}\n\t\t}\n\n\t\tmake_dev_args_init(&args);\n\t\targs.mda_flags = MAKEDEV_CHECKNAME | MAKEDEV_WAITOK;\n\t\targs.mda_devsw = &zvol_cdevsw;\n\t\targs.mda_cr = NULL;\n\t\targs.mda_uid = UID_ROOT;\n\t\targs.mda_gid = GID_OPERATOR;\n\t\targs.mda_mode = 0640;\n\t\targs.mda_si_drv2 = zv;\n\t\tif (make_dev_s(&args, &dev, \"%s/%s\", ZVOL_DRIVER, newname)\n\t\t    == 0) {\n#if __FreeBSD_version > 1300130\n\t\t\tdev->si_iosize_max = maxphys;\n#else\n\t\t\tdev->si_iosize_max = MAXPHYS;\n#endif\n\t\t\tzsd->zsd_cdev = dev;\n\t\t}\n\t}\n\tstrlcpy(zv->zv_name, newname, sizeof (zv->zv_name));\n}\n\n \nvoid\nzvol_os_free(zvol_state_t *zv)\n{\n\tASSERT(!RW_LOCK_HELD(&zv->zv_suspend_lock));\n\tASSERT(!MUTEX_HELD(&zv->zv_state_lock));\n\tASSERT0(zv->zv_open_count);\n\n\tZFS_LOG(1, \"ZVOL %s destroyed.\", zv->zv_name);\n\n\trw_destroy(&zv->zv_suspend_lock);\n\tzfs_rangelock_fini(&zv->zv_rangelock);\n\n\tif (zv->zv_volmode == ZFS_VOLMODE_GEOM) {\n\t\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\t\tstruct g_provider *pp __maybe_unused = zsg->zsg_provider;\n\n\t\tASSERT3P(pp->private, ==, NULL);\n\n\t\tg_topology_lock();\n\t\tzvol_geom_destroy(zv);\n\t\tg_topology_unlock();\n\t\tmtx_destroy(&zsg->zsg_queue_mtx);\n\t} else if (zv->zv_volmode == ZFS_VOLMODE_DEV) {\n\t\tstruct zvol_state_dev *zsd = &zv->zv_zso->zso_dev;\n\t\tstruct cdev *dev = zsd->zsd_cdev;\n\n\t\tif (dev != NULL) {\n\t\t\tASSERT3P(dev->si_drv2, ==, NULL);\n\t\t\tdestroy_dev(dev);\n\t\t\tknlist_clear(&zsd->zsd_selinfo.si_note, 0);\n\t\t\tknlist_destroy(&zsd->zsd_selinfo.si_note);\n\t\t}\n\t}\n\n\tmutex_destroy(&zv->zv_state_lock);\n\tdataset_kstats_destroy(&zv->zv_kstat);\n\tkmem_free(zv->zv_zso, sizeof (struct zvol_state_os));\n\tkmem_free(zv, sizeof (zvol_state_t));\n\tzvol_minors--;\n}\n\n \nint\nzvol_os_create_minor(const char *name)\n{\n\tzvol_state_t *zv;\n\tobjset_t *os;\n\tdmu_object_info_t *doi;\n\tuint64_t volsize;\n\tuint64_t volmode, hash;\n\tint error;\n\tbool replayed_zil = B_FALSE;\n\n\tZFS_LOG(1, \"Creating ZVOL %s...\", name);\n\thash = zvol_name_hash(name);\n\tif ((zv = zvol_find_by_name_hash(name, hash, RW_NONE)) != NULL) {\n\t\tASSERT(MUTEX_HELD(&zv->zv_state_lock));\n\t\tmutex_exit(&zv->zv_state_lock);\n\t\treturn (SET_ERROR(EEXIST));\n\t}\n\n\tDROP_GIANT();\n\n\tdoi = kmem_alloc(sizeof (dmu_object_info_t), KM_SLEEP);\n\n\t \n\terror = dmu_objset_own(name, DMU_OST_ZVOL, B_TRUE, B_TRUE, FTAG, &os);\n\tif (error)\n\t\tgoto out_doi;\n\n\terror = dmu_object_info(os, ZVOL_OBJ, doi);\n\tif (error)\n\t\tgoto out_dmu_objset_disown;\n\n\terror = zap_lookup(os, ZVOL_ZAP_OBJ, \"size\", 8, 1, &volsize);\n\tif (error)\n\t\tgoto out_dmu_objset_disown;\n\n\terror = dsl_prop_get_integer(name,\n\t    zfs_prop_to_name(ZFS_PROP_VOLMODE), &volmode, NULL);\n\tif (error || volmode == ZFS_VOLMODE_DEFAULT)\n\t\tvolmode = zvol_volmode;\n\terror = 0;\n\n\t \n\tzv = kmem_zalloc(sizeof (*zv), KM_SLEEP);\n\tzv->zv_hash = hash;\n\tmutex_init(&zv->zv_state_lock, NULL, MUTEX_DEFAULT, NULL);\n\tzv->zv_zso = kmem_zalloc(sizeof (struct zvol_state_os), KM_SLEEP);\n\tzv->zv_volmode = volmode;\n\tif (zv->zv_volmode == ZFS_VOLMODE_GEOM) {\n\t\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\t\tstruct g_provider *pp;\n\t\tstruct g_geom *gp;\n\n\t\tzsg->zsg_state = ZVOL_GEOM_UNINIT;\n\t\tmtx_init(&zsg->zsg_queue_mtx, \"zvol\", NULL, MTX_DEF);\n\n\t\tg_topology_lock();\n\t\tgp = g_new_geomf(&zfs_zvol_class, \"zfs::zvol::%s\", name);\n\t\tgp->start = zvol_geom_bio_start;\n\t\tgp->access = zvol_geom_access;\n\t\tpp = g_new_providerf(gp, \"%s/%s\", ZVOL_DRIVER, name);\n\t\tpp->flags |= G_PF_DIRECT_RECEIVE | G_PF_DIRECT_SEND;\n\t\tpp->sectorsize = DEV_BSIZE;\n\t\tpp->mediasize = 0;\n\t\tpp->private = zv;\n\n\t\tzsg->zsg_provider = pp;\n\t\tbioq_init(&zsg->zsg_queue);\n\t} else if (zv->zv_volmode == ZFS_VOLMODE_DEV) {\n\t\tstruct zvol_state_dev *zsd = &zv->zv_zso->zso_dev;\n\t\tstruct cdev *dev;\n\t\tstruct make_dev_args args;\n\n\t\tmake_dev_args_init(&args);\n\t\targs.mda_flags = MAKEDEV_CHECKNAME | MAKEDEV_WAITOK;\n\t\targs.mda_devsw = &zvol_cdevsw;\n\t\targs.mda_cr = NULL;\n\t\targs.mda_uid = UID_ROOT;\n\t\targs.mda_gid = GID_OPERATOR;\n\t\targs.mda_mode = 0640;\n\t\targs.mda_si_drv2 = zv;\n\t\tif (make_dev_s(&args, &dev, \"%s/%s\", ZVOL_DRIVER, name)\n\t\t    == 0) {\n#if __FreeBSD_version > 1300130\n\t\t\tdev->si_iosize_max = maxphys;\n#else\n\t\t\tdev->si_iosize_max = MAXPHYS;\n#endif\n\t\t\tzsd->zsd_cdev = dev;\n\t\t\tknlist_init_sx(&zsd->zsd_selinfo.si_note,\n\t\t\t    &zv->zv_state_lock);\n\t\t}\n\t}\n\t(void) strlcpy(zv->zv_name, name, MAXPATHLEN);\n\trw_init(&zv->zv_suspend_lock, NULL, RW_DEFAULT, NULL);\n\tzfs_rangelock_init(&zv->zv_rangelock, NULL, NULL);\n\n\tif (dmu_objset_is_snapshot(os) || !spa_writeable(dmu_objset_spa(os)))\n\t\tzv->zv_flags |= ZVOL_RDONLY;\n\n\tzv->zv_volblocksize = doi->doi_data_block_size;\n\tzv->zv_volsize = volsize;\n\tzv->zv_objset = os;\n\n\tASSERT3P(zv->zv_kstat.dk_kstats, ==, NULL);\n\terror = dataset_kstats_create(&zv->zv_kstat, zv->zv_objset);\n\tif (error)\n\t\tgoto out_dmu_objset_disown;\n\tASSERT3P(zv->zv_zilog, ==, NULL);\n\tzv->zv_zilog = zil_open(os, zvol_get_data, &zv->zv_kstat.dk_zil_sums);\n\tif (spa_writeable(dmu_objset_spa(os))) {\n\t\tif (zil_replay_disable)\n\t\t\treplayed_zil = zil_destroy(zv->zv_zilog, B_FALSE);\n\t\telse\n\t\t\treplayed_zil = zil_replay(os, zv, zvol_replay_vector);\n\t}\n\tif (replayed_zil)\n\t\tzil_close(zv->zv_zilog);\n\tzv->zv_zilog = NULL;\n\n\t \n\n\tzv->zv_objset = NULL;\nout_dmu_objset_disown:\n\tdmu_objset_disown(os, B_TRUE, FTAG);\n\n\tif (error == 0 && volmode == ZFS_VOLMODE_GEOM) {\n\t\tzvol_geom_run(zv);\n\t\tg_topology_unlock();\n\t}\nout_doi:\n\tkmem_free(doi, sizeof (dmu_object_info_t));\n\tif (error == 0) {\n\t\trw_enter(&zvol_state_lock, RW_WRITER);\n\t\tzvol_insert(zv);\n\t\tzvol_minors++;\n\t\trw_exit(&zvol_state_lock);\n\t\tZFS_LOG(1, \"ZVOL %s created.\", name);\n\t}\n\tPICKUP_GIANT();\n\treturn (error);\n}\n\nvoid\nzvol_os_clear_private(zvol_state_t *zv)\n{\n\tASSERT(RW_LOCK_HELD(&zvol_state_lock));\n\tif (zv->zv_volmode == ZFS_VOLMODE_GEOM) {\n\t\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\t\tstruct g_provider *pp = zsg->zsg_provider;\n\n\t\tif (pp->private == NULL)  \n\t\t\treturn;\n\n\t\tmtx_lock(&zsg->zsg_queue_mtx);\n\t\tzsg->zsg_state = ZVOL_GEOM_STOPPED;\n\t\tpp->private = NULL;\n\t\twakeup_one(&zsg->zsg_queue);\n\t\twhile (zsg->zsg_state != ZVOL_GEOM_RUNNING)\n\t\t\tmsleep(&zsg->zsg_state, &zsg->zsg_queue_mtx,\n\t\t\t    0, \"zvol:w\", 0);\n\t\tmtx_unlock(&zsg->zsg_queue_mtx);\n\t\tASSERT(!RW_LOCK_HELD(&zv->zv_suspend_lock));\n\t} else if (zv->zv_volmode == ZFS_VOLMODE_DEV) {\n\t\tstruct zvol_state_dev *zsd = &zv->zv_zso->zso_dev;\n\t\tstruct cdev *dev = zsd->zsd_cdev;\n\n\t\tif (dev != NULL)\n\t\t\tdev->si_drv2 = NULL;\n\t}\n}\n\nint\nzvol_os_update_volsize(zvol_state_t *zv, uint64_t volsize)\n{\n\tzv->zv_volsize = volsize;\n\tif (zv->zv_volmode == ZFS_VOLMODE_GEOM) {\n\t\tstruct zvol_state_geom *zsg = &zv->zv_zso->zso_geom;\n\t\tstruct g_provider *pp = zsg->zsg_provider;\n\n\t\tg_topology_lock();\n\n\t\tif (pp->private == NULL) {\n\t\t\tg_topology_unlock();\n\t\t\treturn (SET_ERROR(ENXIO));\n\t\t}\n\n\t\t \n\t\tif (pp->mediasize == 0)\n\t\t\tpp->mediasize = zv->zv_volsize;\n\t\telse\n\t\t\tg_resize_provider(pp, zv->zv_volsize);\n\n\t\tg_topology_unlock();\n\t} else if (zv->zv_volmode == ZFS_VOLMODE_DEV) {\n\t\tstruct zvol_state_dev *zsd = &zv->zv_zso->zso_dev;\n\n\t\tKNOTE_UNLOCKED(&zsd->zsd_selinfo.si_note, NOTE_ATTRIB);\n\t}\n\treturn (0);\n}\n\nvoid\nzvol_os_set_disk_ro(zvol_state_t *zv, int flags)\n{\n\t\n}\n\nvoid\nzvol_os_set_capacity(zvol_state_t *zv, uint64_t capacity)\n{\n\t\n}\n\n \n\nint\nzvol_busy(void)\n{\n\treturn (zvol_minors != 0);\n}\n\nint\nzvol_init(void)\n{\n\tzvol_init_impl();\n\treturn (0);\n}\n\nvoid\nzvol_fini(void)\n{\n\tzvol_fini_impl();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}