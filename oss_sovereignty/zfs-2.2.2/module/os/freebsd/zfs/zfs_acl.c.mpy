{
  "module_name": "zfs_acl.c",
  "hash_id": "4db75e24221e588838e1a600e0d6d1643a98d01f76aa029a1458f8359107d5d7",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_acl.c",
  "human_readable_source": " \n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/systm.h>\n#include <sys/sysmacros.h>\n#include <sys/resource.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/kmem.h>\n#include <sys/cmn_err.h>\n#include <sys/errno.h>\n#include <sys/unistd.h>\n#include <sys/sdt.h>\n#include <sys/fs/zfs.h>\n#include <sys/policy.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_fuid.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_quota.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/dmu.h>\n#include <sys/dnode.h>\n#include <sys/zap.h>\n#include <sys/sa.h>\n#include <acl/acl_common.h>\n\n\n#define\tALLOW\tACE_ACCESS_ALLOWED_ACE_TYPE\n#define\tDENY\tACE_ACCESS_DENIED_ACE_TYPE\n#define\tMAX_ACE_TYPE\tACE_SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE\n#define\tMIN_ACE_TYPE\tALLOW\n\n#define\tOWNING_GROUP\t\t(ACE_GROUP|ACE_IDENTIFIER_GROUP)\n#define\tEVERYONE_ALLOW_MASK (ACE_READ_ACL|ACE_READ_ATTRIBUTES | \\\n    ACE_READ_NAMED_ATTRS|ACE_SYNCHRONIZE)\n#define\tEVERYONE_DENY_MASK (ACE_WRITE_ACL|ACE_WRITE_OWNER | \\\n    ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)\n#define\tOWNER_ALLOW_MASK (ACE_WRITE_ACL | ACE_WRITE_OWNER | \\\n    ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)\n\n#define\tZFS_CHECKED_MASKS (ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_READ_DATA| \\\n    ACE_READ_NAMED_ATTRS|ACE_WRITE_DATA|ACE_WRITE_ATTRIBUTES| \\\n    ACE_WRITE_NAMED_ATTRS|ACE_APPEND_DATA|ACE_EXECUTE|ACE_WRITE_OWNER| \\\n    ACE_WRITE_ACL|ACE_DELETE|ACE_DELETE_CHILD|ACE_SYNCHRONIZE)\n\n#define\tWRITE_MASK_DATA (ACE_WRITE_DATA|ACE_APPEND_DATA|ACE_WRITE_NAMED_ATTRS)\n#define\tWRITE_MASK_ATTRS (ACE_WRITE_ACL|ACE_WRITE_OWNER|ACE_WRITE_ATTRIBUTES| \\\n    ACE_DELETE|ACE_DELETE_CHILD)\n#define\tWRITE_MASK (WRITE_MASK_DATA|WRITE_MASK_ATTRS)\n\n#define\tOGE_CLEAR\t(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \\\n    ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)\n\n#define\tOKAY_MASK_BITS (ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \\\n    ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)\n\n#define\tALL_INHERIT\t(ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE | \\\n    ACE_NO_PROPAGATE_INHERIT_ACE|ACE_INHERIT_ONLY_ACE|ACE_INHERITED_ACE)\n\n#define\tRESTRICTED_CLEAR\t(ACE_WRITE_ACL|ACE_WRITE_OWNER)\n\n#define\tV4_ACL_WIDE_FLAGS (ZFS_ACL_AUTO_INHERIT|ZFS_ACL_DEFAULTED|\\\n    ZFS_ACL_PROTECTED)\n\n#define\tZFS_ACL_WIDE_FLAGS (V4_ACL_WIDE_FLAGS|ZFS_ACL_TRIVIAL|ZFS_INHERIT_ACE|\\\n    ZFS_ACL_OBJ_ACE)\n\n#define\tALL_MODE_EXECS (S_IXUSR | S_IXGRP | S_IXOTH)\n\nstatic uint16_t\nzfs_ace_v0_get_type(void *acep)\n{\n\treturn (((zfs_oldace_t *)acep)->z_type);\n}\n\nstatic uint16_t\nzfs_ace_v0_get_flags(void *acep)\n{\n\treturn (((zfs_oldace_t *)acep)->z_flags);\n}\n\nstatic uint32_t\nzfs_ace_v0_get_mask(void *acep)\n{\n\treturn (((zfs_oldace_t *)acep)->z_access_mask);\n}\n\nstatic uint64_t\nzfs_ace_v0_get_who(void *acep)\n{\n\treturn (((zfs_oldace_t *)acep)->z_fuid);\n}\n\nstatic void\nzfs_ace_v0_set_type(void *acep, uint16_t type)\n{\n\t((zfs_oldace_t *)acep)->z_type = type;\n}\n\nstatic void\nzfs_ace_v0_set_flags(void *acep, uint16_t flags)\n{\n\t((zfs_oldace_t *)acep)->z_flags = flags;\n}\n\nstatic void\nzfs_ace_v0_set_mask(void *acep, uint32_t mask)\n{\n\t((zfs_oldace_t *)acep)->z_access_mask = mask;\n}\n\nstatic void\nzfs_ace_v0_set_who(void *acep, uint64_t who)\n{\n\t((zfs_oldace_t *)acep)->z_fuid = who;\n}\n\nstatic size_t\nzfs_ace_v0_size(void *acep)\n{\n\t(void) acep;\n\treturn (sizeof (zfs_oldace_t));\n}\n\nstatic size_t\nzfs_ace_v0_abstract_size(void)\n{\n\treturn (sizeof (zfs_oldace_t));\n}\n\nstatic int\nzfs_ace_v0_mask_off(void)\n{\n\treturn (offsetof(zfs_oldace_t, z_access_mask));\n}\n\nstatic int\nzfs_ace_v0_data(void *acep, void **datap)\n{\n\t(void) acep;\n\t*datap = NULL;\n\treturn (0);\n}\n\nstatic const acl_ops_t zfs_acl_v0_ops = {\n\tzfs_ace_v0_get_mask,\n\tzfs_ace_v0_set_mask,\n\tzfs_ace_v0_get_flags,\n\tzfs_ace_v0_set_flags,\n\tzfs_ace_v0_get_type,\n\tzfs_ace_v0_set_type,\n\tzfs_ace_v0_get_who,\n\tzfs_ace_v0_set_who,\n\tzfs_ace_v0_size,\n\tzfs_ace_v0_abstract_size,\n\tzfs_ace_v0_mask_off,\n\tzfs_ace_v0_data\n};\n\nstatic uint16_t\nzfs_ace_fuid_get_type(void *acep)\n{\n\treturn (((zfs_ace_hdr_t *)acep)->z_type);\n}\n\nstatic uint16_t\nzfs_ace_fuid_get_flags(void *acep)\n{\n\treturn (((zfs_ace_hdr_t *)acep)->z_flags);\n}\n\nstatic uint32_t\nzfs_ace_fuid_get_mask(void *acep)\n{\n\treturn (((zfs_ace_hdr_t *)acep)->z_access_mask);\n}\n\nstatic uint64_t\nzfs_ace_fuid_get_who(void *args)\n{\n\tuint16_t entry_type;\n\tzfs_ace_t *acep = args;\n\n\tentry_type = acep->z_hdr.z_flags & ACE_TYPE_FLAGS;\n\n\tif (entry_type == ACE_OWNER || entry_type == OWNING_GROUP ||\n\t    entry_type == ACE_EVERYONE)\n\t\treturn (-1);\n\treturn (((zfs_ace_t *)acep)->z_fuid);\n}\n\nstatic void\nzfs_ace_fuid_set_type(void *acep, uint16_t type)\n{\n\t((zfs_ace_hdr_t *)acep)->z_type = type;\n}\n\nstatic void\nzfs_ace_fuid_set_flags(void *acep, uint16_t flags)\n{\n\t((zfs_ace_hdr_t *)acep)->z_flags = flags;\n}\n\nstatic void\nzfs_ace_fuid_set_mask(void *acep, uint32_t mask)\n{\n\t((zfs_ace_hdr_t *)acep)->z_access_mask = mask;\n}\n\nstatic void\nzfs_ace_fuid_set_who(void *arg, uint64_t who)\n{\n\tzfs_ace_t *acep = arg;\n\n\tuint16_t entry_type = acep->z_hdr.z_flags & ACE_TYPE_FLAGS;\n\n\tif (entry_type == ACE_OWNER || entry_type == OWNING_GROUP ||\n\t    entry_type == ACE_EVERYONE)\n\t\treturn;\n\tacep->z_fuid = who;\n}\n\nstatic size_t\nzfs_ace_fuid_size(void *acep)\n{\n\tzfs_ace_hdr_t *zacep = acep;\n\tuint16_t entry_type;\n\n\tswitch (zacep->z_type) {\n\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\treturn (sizeof (zfs_object_ace_t));\n\tcase ALLOW:\n\tcase DENY:\n\t\tentry_type =\n\t\t    (((zfs_ace_hdr_t *)acep)->z_flags & ACE_TYPE_FLAGS);\n\t\tif (entry_type == ACE_OWNER ||\n\t\t    entry_type == OWNING_GROUP ||\n\t\t    entry_type == ACE_EVERYONE)\n\t\t\treturn (sizeof (zfs_ace_hdr_t));\n\t\tzfs_fallthrough;\n\tdefault:\n\t\treturn (sizeof (zfs_ace_t));\n\t}\n}\n\nstatic size_t\nzfs_ace_fuid_abstract_size(void)\n{\n\treturn (sizeof (zfs_ace_hdr_t));\n}\n\nstatic int\nzfs_ace_fuid_mask_off(void)\n{\n\treturn (offsetof(zfs_ace_hdr_t, z_access_mask));\n}\n\nstatic int\nzfs_ace_fuid_data(void *acep, void **datap)\n{\n\tzfs_ace_t *zacep = acep;\n\tzfs_object_ace_t *zobjp;\n\n\tswitch (zacep->z_hdr.z_type) {\n\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\tzobjp = acep;\n\t\t*datap = (caddr_t)zobjp + sizeof (zfs_ace_t);\n\t\treturn (sizeof (zfs_object_ace_t) - sizeof (zfs_ace_t));\n\tdefault:\n\t\t*datap = NULL;\n\t\treturn (0);\n\t}\n}\n\nstatic const acl_ops_t zfs_acl_fuid_ops = {\n\tzfs_ace_fuid_get_mask,\n\tzfs_ace_fuid_set_mask,\n\tzfs_ace_fuid_get_flags,\n\tzfs_ace_fuid_set_flags,\n\tzfs_ace_fuid_get_type,\n\tzfs_ace_fuid_set_type,\n\tzfs_ace_fuid_get_who,\n\tzfs_ace_fuid_set_who,\n\tzfs_ace_fuid_size,\n\tzfs_ace_fuid_abstract_size,\n\tzfs_ace_fuid_mask_off,\n\tzfs_ace_fuid_data\n};\n\n \nuint64_t\nzfs_external_acl(znode_t *zp)\n{\n\tzfs_acl_phys_t acl_phys;\n\tint error;\n\n\tif (zp->z_is_sa)\n\t\treturn (0);\n\n\t \n\n\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_ZNODE_ACL(zp->z_zfsvfs),\n\t    &acl_phys, sizeof (acl_phys))) == 0)\n\t\treturn (acl_phys.z_acl_extern_obj);\n\telse {\n\t\t \n\t\tVERIFY(zp->z_is_sa);\n\t\tVERIFY3S(error, ==, ENOENT);\n\t\treturn (0);\n\t}\n}\n\n \nstatic int\nzfs_acl_znode_info(znode_t *zp, int *aclsize, int *aclcount,\n    zfs_acl_phys_t *aclphys)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tuint64_t acl_count;\n\tint size;\n\tint error;\n\n\tASSERT(MUTEX_HELD(&zp->z_acl_lock));\n\tif (zp->z_is_sa) {\n\t\tif ((error = sa_size(zp->z_sa_hdl, SA_ZPL_DACL_ACES(zfsvfs),\n\t\t    &size)) != 0)\n\t\t\treturn (error);\n\t\t*aclsize = size;\n\t\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_DACL_COUNT(zfsvfs),\n\t\t    &acl_count, sizeof (acl_count))) != 0)\n\t\t\treturn (error);\n\t\t*aclcount = acl_count;\n\t} else {\n\t\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_ZNODE_ACL(zfsvfs),\n\t\t    aclphys, sizeof (*aclphys))) != 0)\n\t\t\treturn (error);\n\n\t\tif (aclphys->z_acl_version == ZFS_ACL_VERSION_INITIAL) {\n\t\t\t*aclsize = ZFS_ACL_SIZE(aclphys->z_acl_size);\n\t\t\t*aclcount = aclphys->z_acl_size;\n\t\t} else {\n\t\t\t*aclsize = aclphys->z_acl_size;\n\t\t\t*aclcount = aclphys->z_acl_count;\n\t\t}\n\t}\n\treturn (0);\n}\n\nint\nzfs_znode_acl_version(znode_t *zp)\n{\n\tzfs_acl_phys_t acl_phys;\n\n\tif (zp->z_is_sa)\n\t\treturn (ZFS_ACL_VERSION_FUID);\n\telse {\n\t\tint error;\n\n\t\t \n\t\tif ((error = sa_lookup(zp->z_sa_hdl,\n\t\t    SA_ZPL_ZNODE_ACL(zp->z_zfsvfs),\n\t\t    &acl_phys, sizeof (acl_phys))) == 0)\n\t\t\treturn (acl_phys.z_acl_version);\n\t\telse {\n\t\t\t \n\t\t\tVERIFY(zp->z_is_sa);\n\t\t\tVERIFY3S(error, ==, ENOENT);\n\t\t\treturn (ZFS_ACL_VERSION_FUID);\n\t\t}\n\t}\n}\n\nstatic int\nzfs_acl_version(int version)\n{\n\tif (version < ZPL_VERSION_FUID)\n\t\treturn (ZFS_ACL_VERSION_INITIAL);\n\telse\n\t\treturn (ZFS_ACL_VERSION_FUID);\n}\n\nstatic int\nzfs_acl_version_zp(znode_t *zp)\n{\n\treturn (zfs_acl_version(zp->z_zfsvfs->z_version));\n}\n\nzfs_acl_t *\nzfs_acl_alloc(int vers)\n{\n\tzfs_acl_t *aclp;\n\n\taclp = kmem_zalloc(sizeof (zfs_acl_t), KM_SLEEP);\n\tlist_create(&aclp->z_acl, sizeof (zfs_acl_node_t),\n\t    offsetof(zfs_acl_node_t, z_next));\n\taclp->z_version = vers;\n\tif (vers == ZFS_ACL_VERSION_FUID)\n\t\taclp->z_ops = &zfs_acl_fuid_ops;\n\telse\n\t\taclp->z_ops = &zfs_acl_v0_ops;\n\treturn (aclp);\n}\n\nzfs_acl_node_t *\nzfs_acl_node_alloc(size_t bytes)\n{\n\tzfs_acl_node_t *aclnode;\n\n\taclnode = kmem_zalloc(sizeof (zfs_acl_node_t), KM_SLEEP);\n\tif (bytes) {\n\t\taclnode->z_acldata = kmem_alloc(bytes, KM_SLEEP);\n\t\taclnode->z_allocdata = aclnode->z_acldata;\n\t\taclnode->z_allocsize = bytes;\n\t\taclnode->z_size = bytes;\n\t}\n\n\treturn (aclnode);\n}\n\nstatic void\nzfs_acl_node_free(zfs_acl_node_t *aclnode)\n{\n\tif (aclnode->z_allocsize)\n\t\tkmem_free(aclnode->z_allocdata, aclnode->z_allocsize);\n\tkmem_free(aclnode, sizeof (zfs_acl_node_t));\n}\n\nstatic void\nzfs_acl_release_nodes(zfs_acl_t *aclp)\n{\n\tzfs_acl_node_t *aclnode;\n\n\twhile ((aclnode = list_remove_head(&aclp->z_acl)))\n\t\tzfs_acl_node_free(aclnode);\n\taclp->z_acl_count = 0;\n\taclp->z_acl_bytes = 0;\n}\n\nvoid\nzfs_acl_free(zfs_acl_t *aclp)\n{\n\tzfs_acl_release_nodes(aclp);\n\tlist_destroy(&aclp->z_acl);\n\tkmem_free(aclp, sizeof (zfs_acl_t));\n}\n\nstatic boolean_t\nzfs_acl_valid_ace_type(uint_t type, uint_t flags)\n{\n\tuint16_t entry_type;\n\n\tswitch (type) {\n\tcase ALLOW:\n\tcase DENY:\n\tcase ACE_SYSTEM_AUDIT_ACE_TYPE:\n\tcase ACE_SYSTEM_ALARM_ACE_TYPE:\n\t\tentry_type = flags & ACE_TYPE_FLAGS;\n\t\treturn (entry_type == ACE_OWNER ||\n\t\t    entry_type == OWNING_GROUP ||\n\t\t    entry_type == ACE_EVERYONE || entry_type == 0 ||\n\t\t    entry_type == ACE_IDENTIFIER_GROUP);\n\tdefault:\n\t\tif (type <= MAX_ACE_TYPE)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\nstatic boolean_t\nzfs_ace_valid(vtype_t obj_type, zfs_acl_t *aclp, uint16_t type, uint16_t iflags)\n{\n\t \n\n\tif (!zfs_acl_valid_ace_type(type, iflags))\n\t\treturn (B_FALSE);\n\n\tswitch (type) {\n\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\tif (aclp->z_version < ZFS_ACL_VERSION_FUID)\n\t\t\treturn (B_FALSE);\n\t\taclp->z_hints |= ZFS_ACL_OBJ_ACE;\n\t}\n\n\t \n\n\tif (obj_type == VDIR &&\n\t    (iflags & (ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE)))\n\t\taclp->z_hints |= ZFS_INHERIT_ACE;\n\n\tif (iflags & (ACE_INHERIT_ONLY_ACE|ACE_NO_PROPAGATE_INHERIT_ACE)) {\n\t\tif ((iflags & (ACE_FILE_INHERIT_ACE|\n\t\t    ACE_DIRECTORY_INHERIT_ACE)) == 0) {\n\t\t\treturn (B_FALSE);\n\t\t}\n\t}\n\n\treturn (B_TRUE);\n}\n\nstatic void *\nzfs_acl_next_ace(zfs_acl_t *aclp, void *start, uint64_t *who,\n    uint32_t *access_mask, uint16_t *iflags, uint16_t *type)\n{\n\tzfs_acl_node_t *aclnode;\n\n\tASSERT3P(aclp, !=, NULL);\n\n\tif (start == NULL) {\n\t\taclnode = list_head(&aclp->z_acl);\n\t\tif (aclnode == NULL)\n\t\t\treturn (NULL);\n\n\t\taclp->z_next_ace = aclnode->z_acldata;\n\t\taclp->z_curr_node = aclnode;\n\t\taclnode->z_ace_idx = 0;\n\t}\n\n\taclnode = aclp->z_curr_node;\n\n\tif (aclnode == NULL)\n\t\treturn (NULL);\n\n\tif (aclnode->z_ace_idx >= aclnode->z_ace_count) {\n\t\taclnode = list_next(&aclp->z_acl, aclnode);\n\t\tif (aclnode == NULL)\n\t\t\treturn (NULL);\n\t\telse {\n\t\t\taclp->z_curr_node = aclnode;\n\t\t\taclnode->z_ace_idx = 0;\n\t\t\taclp->z_next_ace = aclnode->z_acldata;\n\t\t}\n\t}\n\n\tif (aclnode->z_ace_idx < aclnode->z_ace_count) {\n\t\tvoid *acep = aclp->z_next_ace;\n\t\tsize_t ace_size;\n\n\t\t \n\t\tace_size = aclp->z_ops->ace_size(acep);\n\n\t\tif (((caddr_t)acep + ace_size) >\n\t\t    ((caddr_t)aclnode->z_acldata + aclnode->z_size)) {\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t*iflags = aclp->z_ops->ace_flags_get(acep);\n\t\t*type = aclp->z_ops->ace_type_get(acep);\n\t\t*access_mask = aclp->z_ops->ace_mask_get(acep);\n\t\t*who = aclp->z_ops->ace_who_get(acep);\n\t\taclp->z_next_ace = (caddr_t)aclp->z_next_ace + ace_size;\n\t\taclnode->z_ace_idx++;\n\n\t\treturn ((void *)acep);\n\t}\n\treturn (NULL);\n}\n\nstatic uintptr_t\nzfs_ace_walk(void *datap, uintptr_t cookie, int aclcnt,\n    uint16_t *flags, uint16_t *type, uint32_t *mask)\n{\n\t(void) aclcnt;\n\tzfs_acl_t *aclp = datap;\n\tzfs_ace_hdr_t *acep = (zfs_ace_hdr_t *)(uintptr_t)cookie;\n\tuint64_t who;\n\n\tacep = zfs_acl_next_ace(aclp, acep, &who, mask,\n\t    flags, type);\n\treturn ((uintptr_t)acep);\n}\n\n \nstatic int\nzfs_copy_ace_2_fuid(zfsvfs_t *zfsvfs, vtype_t obj_type, zfs_acl_t *aclp,\n    void *datap, zfs_ace_t *z_acl, uint64_t aclcnt, size_t *size,\n    zfs_fuid_info_t **fuidp, cred_t *cr)\n{\n\tint i;\n\tuint16_t entry_type;\n\tzfs_ace_t *aceptr = z_acl;\n\tace_t *acep = datap;\n\tzfs_object_ace_t *zobjacep;\n\tace_object_t *aceobjp;\n\n\tfor (i = 0; i != aclcnt; i++) {\n\t\taceptr->z_hdr.z_access_mask = acep->a_access_mask;\n\t\taceptr->z_hdr.z_flags = acep->a_flags;\n\t\taceptr->z_hdr.z_type = acep->a_type;\n\t\tentry_type = aceptr->z_hdr.z_flags & ACE_TYPE_FLAGS;\n\t\tif (entry_type != ACE_OWNER && entry_type != OWNING_GROUP &&\n\t\t    entry_type != ACE_EVERYONE) {\n\t\t\taceptr->z_fuid = zfs_fuid_create(zfsvfs, acep->a_who,\n\t\t\t    cr, (entry_type == 0) ?\n\t\t\t    ZFS_ACE_USER : ZFS_ACE_GROUP, fuidp);\n\t\t}\n\n\t\t \n\t\tif (zfs_ace_valid(obj_type, aclp, aceptr->z_hdr.z_type,\n\t\t    aceptr->z_hdr.z_flags) != B_TRUE)\n\t\t\treturn (SET_ERROR(EINVAL));\n\n\t\tswitch (acep->a_type) {\n\t\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\t\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\t\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\t\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\t\tzobjacep = (zfs_object_ace_t *)aceptr;\n\t\t\taceobjp = (ace_object_t *)acep;\n\n\t\t\tmemcpy(zobjacep->z_object_type, aceobjp->a_obj_type,\n\t\t\t    sizeof (aceobjp->a_obj_type));\n\t\t\tmemcpy(zobjacep->z_inherit_type,\n\t\t\t    aceobjp->a_inherit_obj_type,\n\t\t\t    sizeof (aceobjp->a_inherit_obj_type));\n\t\t\tacep = (ace_t *)((caddr_t)acep + sizeof (ace_object_t));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacep = (ace_t *)((caddr_t)acep + sizeof (ace_t));\n\t\t}\n\n\t\taceptr = (zfs_ace_t *)((caddr_t)aceptr +\n\t\t    aclp->z_ops->ace_size(aceptr));\n\t}\n\n\t*size = (caddr_t)aceptr - (caddr_t)z_acl;\n\n\treturn (0);\n}\n\n \nstatic void\nzfs_copy_fuid_2_ace(zfsvfs_t *zfsvfs, zfs_acl_t *aclp, cred_t *cr,\n    void *datap, int filter)\n{\n\tuint64_t who;\n\tuint32_t access_mask;\n\tuint16_t iflags, type;\n\tzfs_ace_hdr_t *zacep = NULL;\n\tace_t *acep = datap;\n\tace_object_t *objacep;\n\tzfs_object_ace_t *zobjacep;\n\tsize_t ace_size;\n\tuint16_t entry_type;\n\n\twhile ((zacep = zfs_acl_next_ace(aclp, zacep,\n\t    &who, &access_mask, &iflags, &type))) {\n\n\t\tswitch (type) {\n\t\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\t\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\t\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\t\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\t\tif (filter) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tzobjacep = (zfs_object_ace_t *)zacep;\n\t\t\tobjacep = (ace_object_t *)acep;\n\t\t\tmemcpy(objacep->a_obj_type,\n\t\t\t    zobjacep->z_object_type,\n\t\t\t    sizeof (zobjacep->z_object_type));\n\t\t\tmemcpy(objacep->a_inherit_obj_type,\n\t\t\t    zobjacep->z_inherit_type,\n\t\t\t    sizeof (zobjacep->z_inherit_type));\n\t\t\tace_size = sizeof (ace_object_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tace_size = sizeof (ace_t);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry_type = (iflags & ACE_TYPE_FLAGS);\n\t\tif ((entry_type != ACE_OWNER &&\n\t\t    entry_type != OWNING_GROUP &&\n\t\t    entry_type != ACE_EVERYONE)) {\n\t\t\tacep->a_who = zfs_fuid_map_id(zfsvfs, who,\n\t\t\t    cr, (entry_type & ACE_IDENTIFIER_GROUP) ?\n\t\t\t    ZFS_ACE_GROUP : ZFS_ACE_USER);\n\t\t} else {\n\t\t\tacep->a_who = (uid_t)(int64_t)who;\n\t\t}\n\t\tacep->a_access_mask = access_mask;\n\t\tacep->a_flags = iflags;\n\t\tacep->a_type = type;\n\t\tacep = (ace_t *)((caddr_t)acep + ace_size);\n\t}\n}\n\nstatic int\nzfs_copy_ace_2_oldace(vtype_t obj_type, zfs_acl_t *aclp, ace_t *acep,\n    zfs_oldace_t *z_acl, int aclcnt, size_t *size)\n{\n\tint i;\n\tzfs_oldace_t *aceptr = z_acl;\n\n\tfor (i = 0; i != aclcnt; i++, aceptr++) {\n\t\taceptr->z_access_mask = acep[i].a_access_mask;\n\t\taceptr->z_type = acep[i].a_type;\n\t\taceptr->z_flags = acep[i].a_flags;\n\t\taceptr->z_fuid = acep[i].a_who;\n\t\t \n\t\tif (zfs_ace_valid(obj_type, aclp, aceptr->z_type,\n\t\t    aceptr->z_flags) != B_TRUE)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t}\n\t*size = (caddr_t)aceptr - (caddr_t)z_acl;\n\treturn (0);\n}\n\n \nvoid\nzfs_acl_xform(znode_t *zp, zfs_acl_t *aclp, cred_t *cr)\n{\n\tzfs_oldace_t *oldaclp;\n\tint i;\n\tuint16_t type, iflags;\n\tuint32_t access_mask;\n\tuint64_t who;\n\tvoid *cookie = NULL;\n\tzfs_acl_node_t *newaclnode;\n\n\tASSERT3U(aclp->z_version, ==, ZFS_ACL_VERSION_INITIAL);\n\t \n\toldaclp = kmem_alloc(sizeof (zfs_oldace_t) * aclp->z_acl_count,\n\t    KM_SLEEP);\n\ti = 0;\n\twhile ((cookie = zfs_acl_next_ace(aclp, cookie, &who,\n\t    &access_mask, &iflags, &type))) {\n\t\toldaclp[i].z_flags = iflags;\n\t\toldaclp[i].z_type = type;\n\t\toldaclp[i].z_fuid = who;\n\t\toldaclp[i++].z_access_mask = access_mask;\n\t}\n\n\tnewaclnode = zfs_acl_node_alloc(aclp->z_acl_count *\n\t    sizeof (zfs_object_ace_t));\n\taclp->z_ops = &zfs_acl_fuid_ops;\n\tVERIFY0(zfs_copy_ace_2_fuid(zp->z_zfsvfs, ZTOV(zp)->v_type, aclp,\n\t    oldaclp, newaclnode->z_acldata, aclp->z_acl_count,\n\t    &newaclnode->z_size, NULL, cr));\n\tnewaclnode->z_ace_count = aclp->z_acl_count;\n\taclp->z_version = ZFS_ACL_VERSION;\n\tkmem_free(oldaclp, aclp->z_acl_count * sizeof (zfs_oldace_t));\n\n\t \n\n\tzfs_acl_release_nodes(aclp);\n\n\tlist_insert_head(&aclp->z_acl, newaclnode);\n\n\taclp->z_acl_bytes = newaclnode->z_size;\n\taclp->z_acl_count = newaclnode->z_ace_count;\n\n}\n\n \nstatic uint32_t\nzfs_unix_to_v4(uint32_t access_mask)\n{\n\tuint32_t new_mask = 0;\n\n\tif (access_mask & S_IXOTH)\n\t\tnew_mask |= ACE_EXECUTE;\n\tif (access_mask & S_IWOTH)\n\t\tnew_mask |= ACE_WRITE_DATA;\n\tif (access_mask & S_IROTH)\n\t\tnew_mask |= ACE_READ_DATA;\n\treturn (new_mask);\n}\n\nstatic void\nzfs_set_ace(zfs_acl_t *aclp, void *acep, uint32_t access_mask,\n    uint16_t access_type, uint64_t fuid, uint16_t entry_type)\n{\n\tuint16_t type = entry_type & ACE_TYPE_FLAGS;\n\n\taclp->z_ops->ace_mask_set(acep, access_mask);\n\taclp->z_ops->ace_type_set(acep, access_type);\n\taclp->z_ops->ace_flags_set(acep, entry_type);\n\tif ((type != ACE_OWNER && type != OWNING_GROUP &&\n\t    type != ACE_EVERYONE))\n\t\taclp->z_ops->ace_who_set(acep, fuid);\n}\n\n \nuint64_t\nzfs_mode_compute(uint64_t fmode, zfs_acl_t *aclp,\n    uint64_t *pflags, uint64_t fuid, uint64_t fgid)\n{\n\tint\t\tentry_type;\n\tmode_t\t\tmode;\n\tmode_t\t\tseen = 0;\n\tzfs_ace_hdr_t \t*acep = NULL;\n\tuint64_t\twho;\n\tuint16_t\tiflags, type;\n\tuint32_t\taccess_mask;\n\tboolean_t\tan_exec_denied = B_FALSE;\n\n\tmode = (fmode & (S_IFMT | S_ISUID | S_ISGID | S_ISVTX));\n\n\twhile ((acep = zfs_acl_next_ace(aclp, acep, &who,\n\t    &access_mask, &iflags, &type))) {\n\n\t\tif (!zfs_acl_valid_ace_type(type, iflags))\n\t\t\tcontinue;\n\n\t\tentry_type = (iflags & ACE_TYPE_FLAGS);\n\n\t\t \n\t\tif (iflags & ACE_INHERIT_ONLY_ACE)\n\t\t\tcontinue;\n\n\t\tif (entry_type == ACE_OWNER || (entry_type == 0 &&\n\t\t    who == fuid)) {\n\t\t\tif ((access_mask & ACE_READ_DATA) &&\n\t\t\t    (!(seen & S_IRUSR))) {\n\t\t\t\tseen |= S_IRUSR;\n\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\tmode |= S_IRUSR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((access_mask & ACE_WRITE_DATA) &&\n\t\t\t    (!(seen & S_IWUSR))) {\n\t\t\t\tseen |= S_IWUSR;\n\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\tmode |= S_IWUSR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((access_mask & ACE_EXECUTE) &&\n\t\t\t    (!(seen & S_IXUSR))) {\n\t\t\t\tseen |= S_IXUSR;\n\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\tmode |= S_IXUSR;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (entry_type == OWNING_GROUP ||\n\t\t    (entry_type == ACE_IDENTIFIER_GROUP && who == fgid)) {\n\t\t\tif ((access_mask & ACE_READ_DATA) &&\n\t\t\t    (!(seen & S_IRGRP))) {\n\t\t\t\tseen |= S_IRGRP;\n\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\tmode |= S_IRGRP;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((access_mask & ACE_WRITE_DATA) &&\n\t\t\t    (!(seen & S_IWGRP))) {\n\t\t\t\tseen |= S_IWGRP;\n\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\tmode |= S_IWGRP;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((access_mask & ACE_EXECUTE) &&\n\t\t\t    (!(seen & S_IXGRP))) {\n\t\t\t\tseen |= S_IXGRP;\n\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\tmode |= S_IXGRP;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (entry_type == ACE_EVERYONE) {\n\t\t\tif ((access_mask & ACE_READ_DATA)) {\n\t\t\t\tif (!(seen & S_IRUSR)) {\n\t\t\t\t\tseen |= S_IRUSR;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IRUSR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(seen & S_IRGRP)) {\n\t\t\t\t\tseen |= S_IRGRP;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IRGRP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(seen & S_IROTH)) {\n\t\t\t\t\tseen |= S_IROTH;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IROTH;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((access_mask & ACE_WRITE_DATA)) {\n\t\t\t\tif (!(seen & S_IWUSR)) {\n\t\t\t\t\tseen |= S_IWUSR;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IWUSR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(seen & S_IWGRP)) {\n\t\t\t\t\tseen |= S_IWGRP;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IWGRP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(seen & S_IWOTH)) {\n\t\t\t\t\tseen |= S_IWOTH;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IWOTH;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((access_mask & ACE_EXECUTE)) {\n\t\t\t\tif (!(seen & S_IXUSR)) {\n\t\t\t\t\tseen |= S_IXUSR;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IXUSR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(seen & S_IXGRP)) {\n\t\t\t\t\tseen |= S_IXGRP;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IXGRP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(seen & S_IXOTH)) {\n\t\t\t\t\tseen |= S_IXOTH;\n\t\t\t\t\tif (type == ALLOW) {\n\t\t\t\t\t\tmode |= S_IXOTH;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((access_mask & ACE_EXECUTE) && type == DENY)\n\t\t\t\tan_exec_denied = B_TRUE;\n\t\t}\n\t}\n\n\t \n\tif (!an_exec_denied &&\n\t    ((seen & ALL_MODE_EXECS) != ALL_MODE_EXECS ||\n\t    (mode & ALL_MODE_EXECS) != ALL_MODE_EXECS))\n\t\tan_exec_denied = B_TRUE;\n\n\tif (an_exec_denied)\n\t\t*pflags &= ~ZFS_NO_EXECS_DENIED;\n\telse\n\t\t*pflags |= ZFS_NO_EXECS_DENIED;\n\n\treturn (mode);\n}\n\n \nint\nzfs_acl_node_read(znode_t *zp, boolean_t have_lock, zfs_acl_t **aclpp,\n    boolean_t will_modify)\n{\n\tzfs_acl_t\t*aclp;\n\tint\t\taclsize;\n\tint\t\tacl_count;\n\tzfs_acl_node_t\t*aclnode;\n\tzfs_acl_phys_t\tznode_acl;\n\tint\t\tversion;\n\tint\t\terror;\n\n\tASSERT(MUTEX_HELD(&zp->z_acl_lock));\n\tif (zp->z_zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(ZTOV(zp), __func__);\n\n\tif (zp->z_acl_cached && !will_modify) {\n\t\t*aclpp = zp->z_acl_cached;\n\t\treturn (0);\n\t}\n\n\tversion = zfs_znode_acl_version(zp);\n\n\tif ((error = zfs_acl_znode_info(zp, &aclsize,\n\t    &acl_count, &znode_acl)) != 0) {\n\t\tgoto done;\n\t}\n\n\taclp = zfs_acl_alloc(version);\n\n\taclp->z_acl_count = acl_count;\n\taclp->z_acl_bytes = aclsize;\n\n\taclnode = zfs_acl_node_alloc(aclsize);\n\taclnode->z_ace_count = aclp->z_acl_count;\n\taclnode->z_size = aclsize;\n\n\tif (!zp->z_is_sa) {\n\t\tif (znode_acl.z_acl_extern_obj) {\n\t\t\terror = dmu_read(zp->z_zfsvfs->z_os,\n\t\t\t    znode_acl.z_acl_extern_obj, 0, aclnode->z_size,\n\t\t\t    aclnode->z_acldata, DMU_READ_PREFETCH);\n\t\t} else {\n\t\t\tmemcpy(aclnode->z_acldata, znode_acl.z_ace_data,\n\t\t\t    aclnode->z_size);\n\t\t}\n\t} else {\n\t\terror = sa_lookup(zp->z_sa_hdl, SA_ZPL_DACL_ACES(zp->z_zfsvfs),\n\t\t    aclnode->z_acldata, aclnode->z_size);\n\t}\n\n\tif (error != 0) {\n\t\tzfs_acl_free(aclp);\n\t\tzfs_acl_node_free(aclnode);\n\t\t \n\t\tif (error == ECKSUM)\n\t\t\terror = SET_ERROR(EIO);\n\t\tgoto done;\n\t}\n\n\tlist_insert_head(&aclp->z_acl, aclnode);\n\n\t*aclpp = aclp;\n\tif (!will_modify)\n\t\tzp->z_acl_cached = aclp;\ndone:\n\treturn (error);\n}\n\nvoid\nzfs_acl_data_locator(void **dataptr, uint32_t *length, uint32_t buflen,\n    boolean_t start, void *userdata)\n{\n\t(void) buflen;\n\tzfs_acl_locator_cb_t *cb = (zfs_acl_locator_cb_t *)userdata;\n\n\tif (start) {\n\t\tcb->cb_acl_node = list_head(&cb->cb_aclp->z_acl);\n\t} else {\n\t\tcb->cb_acl_node = list_next(&cb->cb_aclp->z_acl,\n\t\t    cb->cb_acl_node);\n\t}\n\tASSERT3P(cb->cb_acl_node, !=, NULL);\n\t*dataptr = cb->cb_acl_node->z_acldata;\n\t*length = cb->cb_acl_node->z_size;\n}\n\nint\nzfs_acl_chown_setattr(znode_t *zp)\n{\n\tint error;\n\tzfs_acl_t *aclp;\n\n\tif (zp->z_zfsvfs->z_replay == B_FALSE) {\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n\t\tASSERT_VOP_IN_SEQC(ZTOV(zp));\n\t}\n\tASSERT(MUTEX_HELD(&zp->z_acl_lock));\n\n\tif ((error = zfs_acl_node_read(zp, B_TRUE, &aclp, B_FALSE)) == 0)\n\t\tzp->z_mode = zfs_mode_compute(zp->z_mode, aclp,\n\t\t    &zp->z_pflags, zp->z_uid, zp->z_gid);\n\treturn (error);\n}\n\n \nint\nzfs_aclset_common(znode_t *zp, zfs_acl_t *aclp, cred_t *cr, dmu_tx_t *tx)\n{\n\tint\t\t\terror;\n\tzfsvfs_t\t\t*zfsvfs = zp->z_zfsvfs;\n\tdmu_object_type_t\totype;\n\tzfs_acl_locator_cb_t\tlocate = { 0 };\n\tuint64_t\t\tmode;\n\tsa_bulk_attr_t\t\tbulk[5];\n\tuint64_t\t\tctime[2];\n\tint\t\t\tcount = 0;\n\tzfs_acl_phys_t\t\tacl_phys;\n\n\tif (zp->z_zfsvfs->z_replay == B_FALSE) {\n\t\tASSERT_VOP_IN_SEQC(ZTOV(zp));\n\t}\n\n\tmode = zp->z_mode;\n\n\tmode = zfs_mode_compute(mode, aclp, &zp->z_pflags,\n\t    zp->z_uid, zp->z_gid);\n\n\tzp->z_mode = mode;\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_MODE(zfsvfs), NULL,\n\t    &mode, sizeof (mode));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_FLAGS(zfsvfs), NULL,\n\t    &zp->z_pflags, sizeof (zp->z_pflags));\n\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_CTIME(zfsvfs), NULL,\n\t    &ctime, sizeof (ctime));\n\n\tif (zp->z_acl_cached) {\n\t\tzfs_acl_free(zp->z_acl_cached);\n\t\tzp->z_acl_cached = NULL;\n\t}\n\n\t \n\tif (!zfsvfs->z_use_fuids) {\n\t\totype = DMU_OT_OLDACL;\n\t} else {\n\t\tif ((aclp->z_version == ZFS_ACL_VERSION_INITIAL) &&\n\t\t    (zfsvfs->z_version >= ZPL_VERSION_FUID))\n\t\t\tzfs_acl_xform(zp, aclp, cr);\n\t\tASSERT3U(aclp->z_version, >=, ZFS_ACL_VERSION_FUID);\n\t\totype = DMU_OT_ACL;\n\t}\n\n\t \n\n\tif (zp->z_is_sa) {  \n\t\tlocate.cb_aclp = aclp;\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_DACL_ACES(zfsvfs),\n\t\t    zfs_acl_data_locator, &locate, aclp->z_acl_bytes);\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_DACL_COUNT(zfsvfs),\n\t\t    NULL, &aclp->z_acl_count, sizeof (uint64_t));\n\t} else {  \n\t\tzfs_acl_node_t *aclnode;\n\t\tuint64_t off = 0;\n\t\tuint64_t aoid;\n\n\t\tif ((error = sa_lookup(zp->z_sa_hdl, SA_ZPL_ZNODE_ACL(zfsvfs),\n\t\t    &acl_phys, sizeof (acl_phys))) != 0)\n\t\t\treturn (error);\n\n\t\taoid = acl_phys.z_acl_extern_obj;\n\n\t\tif (aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\t\t \n\t\t\tif (aoid &&\n\t\t\t    aclp->z_version != acl_phys.z_acl_version) {\n\t\t\t\terror = dmu_object_free(zfsvfs->z_os, aoid, tx);\n\t\t\t\tif (error)\n\t\t\t\t\treturn (error);\n\t\t\t\taoid = 0;\n\t\t\t}\n\t\t\tif (aoid == 0) {\n\t\t\t\taoid = dmu_object_alloc(zfsvfs->z_os,\n\t\t\t\t    otype, aclp->z_acl_bytes,\n\t\t\t\t    otype == DMU_OT_ACL ?\n\t\t\t\t    DMU_OT_SYSACL : DMU_OT_NONE,\n\t\t\t\t    otype == DMU_OT_ACL ?\n\t\t\t\t    DN_OLD_MAX_BONUSLEN : 0, tx);\n\t\t\t} else {\n\t\t\t\t(void) dmu_object_set_blocksize(zfsvfs->z_os,\n\t\t\t\t    aoid, aclp->z_acl_bytes, 0, tx);\n\t\t\t}\n\t\t\tacl_phys.z_acl_extern_obj = aoid;\n\t\t\tfor (aclnode = list_head(&aclp->z_acl); aclnode;\n\t\t\t    aclnode = list_next(&aclp->z_acl, aclnode)) {\n\t\t\t\tif (aclnode->z_ace_count == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdmu_write(zfsvfs->z_os, aoid, off,\n\t\t\t\t    aclnode->z_size, aclnode->z_acldata, tx);\n\t\t\t\toff += aclnode->z_size;\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *start = acl_phys.z_ace_data;\n\t\t\t \n\t\t\tif (acl_phys.z_acl_extern_obj) {\n\t\t\t\terror = dmu_object_free(zfsvfs->z_os,\n\t\t\t\t    acl_phys.z_acl_extern_obj, tx);\n\t\t\t\tif (error)\n\t\t\t\t\treturn (error);\n\t\t\t\tacl_phys.z_acl_extern_obj = 0;\n\t\t\t}\n\n\t\t\tfor (aclnode = list_head(&aclp->z_acl); aclnode;\n\t\t\t    aclnode = list_next(&aclp->z_acl, aclnode)) {\n\t\t\t\tif (aclnode->z_ace_count == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(start, aclnode->z_acldata,\n\t\t\t\t    aclnode->z_size);\n\t\t\t\tstart = (caddr_t)start + aclnode->z_size;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (aclp->z_version == ZFS_ACL_VERSION_INITIAL) {\n\t\t\tacl_phys.z_acl_size = aclp->z_acl_count;\n\t\t\tacl_phys.z_acl_count = aclp->z_acl_bytes;\n\t\t} else {\n\t\t\tacl_phys.z_acl_size = aclp->z_acl_bytes;\n\t\t\tacl_phys.z_acl_count = aclp->z_acl_count;\n\t\t}\n\t\tacl_phys.z_acl_version = aclp->z_version;\n\n\t\tSA_ADD_BULK_ATTR(bulk, count, SA_ZPL_ZNODE_ACL(zfsvfs), NULL,\n\t\t    &acl_phys, sizeof (acl_phys));\n\t}\n\n\t \n\tzp->z_pflags &= ~ZFS_ACL_WIDE_FLAGS;\n\n\tzp->z_pflags |= aclp->z_hints;\n\n\tif (ace_trivial_common(aclp, 0, zfs_ace_walk) == 0)\n\t\tzp->z_pflags |= ZFS_ACL_TRIVIAL;\n\n\tzfs_tstamp_update_setup(zp, STATE_CHANGED, NULL, ctime);\n\treturn (sa_bulk_update(zp->z_sa_hdl, bulk, count, tx));\n}\n\nstatic void\nzfs_acl_chmod(vtype_t vtype, uint64_t mode, boolean_t split, boolean_t trim,\n    zfs_acl_t *aclp)\n{\n\tvoid\t\t*acep = NULL;\n\tuint64_t\twho;\n\tint\t\tnew_count, new_bytes;\n\tint\t\tace_size;\n\tint \t\tentry_type;\n\tuint16_t\tiflags, type;\n\tuint32_t\taccess_mask;\n\tzfs_acl_node_t\t*newnode;\n\tsize_t \t\tabstract_size = aclp->z_ops->ace_abstract_size();\n\tvoid \t\t*zacep;\n\tboolean_t\tisdir;\n\ttrivial_acl_t\tmasks;\n\n\tnew_count = new_bytes = 0;\n\n\tisdir = (vtype == VDIR);\n\n\tacl_trivial_access_masks((mode_t)mode, isdir, &masks);\n\n\tnewnode = zfs_acl_node_alloc((abstract_size * 6) + aclp->z_acl_bytes);\n\n\tzacep = newnode->z_acldata;\n\tif (masks.allow0) {\n\t\tzfs_set_ace(aclp, zacep, masks.allow0, ALLOW, -1, ACE_OWNER);\n\t\tzacep = (void *)((uintptr_t)zacep + abstract_size);\n\t\tnew_count++;\n\t\tnew_bytes += abstract_size;\n\t}\n\tif (masks.deny1) {\n\t\tzfs_set_ace(aclp, zacep, masks.deny1, DENY, -1, ACE_OWNER);\n\t\tzacep = (void *)((uintptr_t)zacep + abstract_size);\n\t\tnew_count++;\n\t\tnew_bytes += abstract_size;\n\t}\n\tif (masks.deny2) {\n\t\tzfs_set_ace(aclp, zacep, masks.deny2, DENY, -1, OWNING_GROUP);\n\t\tzacep = (void *)((uintptr_t)zacep + abstract_size);\n\t\tnew_count++;\n\t\tnew_bytes += abstract_size;\n\t}\n\n\twhile ((acep = zfs_acl_next_ace(aclp, acep, &who, &access_mask,\n\t    &iflags, &type))) {\n\t\tentry_type = (iflags & ACE_TYPE_FLAGS);\n\t\t \n\t\tif (split && (entry_type == ACE_OWNER ||\n\t\t    entry_type == OWNING_GROUP ||\n\t\t    entry_type == ACE_EVERYONE)) {\n\t\t\tif (!isdir || !(iflags &\n\t\t\t    (ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tiflags |= ACE_INHERIT_ONLY_ACE;\n\t\t}\n\n\t\t \n\t\tif (isdir && (iflags &\n\t\t    (ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE)))\n\t\t\taclp->z_hints |= ZFS_INHERIT_ACE;\n\n\t\tif ((type != ALLOW && type != DENY) ||\n\t\t    (iflags & ACE_INHERIT_ONLY_ACE)) {\n\t\t\tswitch (type) {\n\t\t\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\t\t\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\t\t\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\t\t\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\t\t\taclp->z_hints |= ZFS_ACL_OBJ_ACE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((type == ALLOW) && trim)\n\t\t\t\taccess_mask &= masks.group;\n\t\t}\n\t\tzfs_set_ace(aclp, zacep, access_mask, type, who, iflags);\n\t\tace_size = aclp->z_ops->ace_size(acep);\n\t\tzacep = (void *)((uintptr_t)zacep + ace_size);\n\t\tnew_count++;\n\t\tnew_bytes += ace_size;\n\t}\n\tzfs_set_ace(aclp, zacep, masks.owner, ALLOW, -1, ACE_OWNER);\n\tzacep = (void *)((uintptr_t)zacep + abstract_size);\n\tzfs_set_ace(aclp, zacep, masks.group, ALLOW, -1, OWNING_GROUP);\n\tzacep = (void *)((uintptr_t)zacep + abstract_size);\n\tzfs_set_ace(aclp, zacep, masks.everyone, ALLOW, -1, ACE_EVERYONE);\n\n\tnew_count += 3;\n\tnew_bytes += abstract_size * 3;\n\tzfs_acl_release_nodes(aclp);\n\taclp->z_acl_count = new_count;\n\taclp->z_acl_bytes = new_bytes;\n\tnewnode->z_ace_count = new_count;\n\tnewnode->z_size = new_bytes;\n\tlist_insert_tail(&aclp->z_acl, newnode);\n}\n\nint\nzfs_acl_chmod_setattr(znode_t *zp, zfs_acl_t **aclp, uint64_t mode)\n{\n\tint error = 0;\n\n\tmutex_enter(&zp->z_acl_lock);\n\tif (zp->z_zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n\tif (zp->z_zfsvfs->z_acl_mode == ZFS_ACL_DISCARD)\n\t\t*aclp = zfs_acl_alloc(zfs_acl_version_zp(zp));\n\telse\n\t\terror = zfs_acl_node_read(zp, B_TRUE, aclp, B_TRUE);\n\n\tif (error == 0) {\n\t\t(*aclp)->z_hints = zp->z_pflags & V4_ACL_WIDE_FLAGS;\n\t\tzfs_acl_chmod(ZTOV(zp)->v_type, mode, B_TRUE,\n\t\t    (zp->z_zfsvfs->z_acl_mode == ZFS_ACL_GROUPMASK), *aclp);\n\t}\n\tmutex_exit(&zp->z_acl_lock);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_ace_can_use(vtype_t vtype, uint16_t acep_flags)\n{\n\tint\tiflags = (acep_flags & 0xf);\n\n\tif ((vtype == VDIR) && (iflags & ACE_DIRECTORY_INHERIT_ACE))\n\t\treturn (1);\n\telse if (iflags & ACE_FILE_INHERIT_ACE)\n\t\treturn (!((vtype == VDIR) &&\n\t\t    (iflags & ACE_NO_PROPAGATE_INHERIT_ACE)));\n\treturn (0);\n}\n\n \nstatic zfs_acl_t *\nzfs_acl_inherit(zfsvfs_t *zfsvfs, vtype_t vtype, zfs_acl_t *paclp,\n    uint64_t mode, boolean_t *need_chmod)\n{\n\tvoid\t\t*pacep = NULL;\n\tvoid\t\t*acep;\n\tzfs_acl_node_t  *aclnode;\n\tzfs_acl_t\t*aclp = NULL;\n\tuint64_t\twho;\n\tuint32_t\taccess_mask;\n\tuint16_t\tiflags, newflags, type;\n\tsize_t\t\tace_size;\n\tvoid\t\t*data1, *data2;\n\tsize_t\t\tdata1sz, data2sz;\n\tuint_t\t\taclinherit;\n\tboolean_t\tisdir = (vtype == VDIR);\n\tboolean_t\tisreg = (vtype == VREG);\n\n\t*need_chmod = B_TRUE;\n\n\taclp = zfs_acl_alloc(paclp->z_version);\n\taclinherit = zfsvfs->z_acl_inherit;\n\tif (aclinherit == ZFS_ACL_DISCARD || vtype == VLNK)\n\t\treturn (aclp);\n\n\twhile ((pacep = zfs_acl_next_ace(paclp, pacep, &who,\n\t    &access_mask, &iflags, &type))) {\n\n\t\t \n\t\tif (!zfs_acl_valid_ace_type(type, iflags))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((aclinherit == ZFS_ACL_NOALLOW && type == ALLOW) ||\n\t\t    !zfs_ace_can_use(vtype, iflags))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((aclinherit == ZFS_ACL_PASSTHROUGH ||\n\t\t    aclinherit == ZFS_ACL_PASSTHROUGH_X) &&\n\t\t    ((iflags & (ACE_OWNER|ACE_EVERYONE)) ||\n\t\t    ((iflags & OWNING_GROUP) == OWNING_GROUP)) &&\n\t\t    (isreg || (isdir && (iflags & ACE_DIRECTORY_INHERIT_ACE))))\n\t\t\t*need_chmod = B_FALSE;\n\n\t\t \n\t\tif (aclinherit == ZFS_ACL_PASSTHROUGH_X && type == ALLOW &&\n\t\t    !isdir && ((mode & (S_IXUSR|S_IXGRP|S_IXOTH)) == 0)) {\n\t\t\taccess_mask &= ~ACE_EXECUTE;\n\t\t}\n\n\t\t \n\t\tif (aclinherit == ZFS_ACL_RESTRICTED && type == ALLOW) {\n\t\t\taccess_mask &= ~RESTRICTED_CLEAR;\n\t\t}\n\n\t\tace_size = aclp->z_ops->ace_size(pacep);\n\t\taclnode = zfs_acl_node_alloc(ace_size);\n\t\tlist_insert_tail(&aclp->z_acl, aclnode);\n\t\tacep = aclnode->z_acldata;\n\n\t\tzfs_set_ace(aclp, acep, access_mask, type,\n\t\t    who, iflags|ACE_INHERITED_ACE);\n\n\t\t \n\t\tif ((data1sz = paclp->z_ops->ace_data(pacep, &data1)) != 0) {\n\t\t\tdata2sz = aclp->z_ops->ace_data(acep, &data2);\n\t\t\tVERIFY3U(data2sz, ==, data1sz);\n\t\t\tmemcpy(data2, data1, data2sz);\n\t\t}\n\n\t\taclp->z_acl_count++;\n\t\taclnode->z_ace_count++;\n\t\taclp->z_acl_bytes += aclnode->z_size;\n\t\tnewflags = aclp->z_ops->ace_flags_get(acep);\n\n\t\t \n\t\tif (!isdir || (iflags & ACE_NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tnewflags &= ~ALL_INHERIT;\n\t\t\taclp->z_ops->ace_flags_set(acep,\n\t\t\t    newflags|ACE_INHERITED_ACE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\taclp->z_hints |= ZFS_INHERIT_ACE;\n\n\t\t \n\t\tif ((iflags & (ACE_FILE_INHERIT_ACE |\n\t\t    ACE_DIRECTORY_INHERIT_ACE)) == ACE_FILE_INHERIT_ACE) {\n\t\t\tnewflags |= ACE_INHERIT_ONLY_ACE;\n\t\t\taclp->z_ops->ace_flags_set(acep,\n\t\t\t    newflags|ACE_INHERITED_ACE);\n\t\t} else {\n\t\t\tnewflags &= ~ACE_INHERIT_ONLY_ACE;\n\t\t\taclp->z_ops->ace_flags_set(acep,\n\t\t\t    newflags|ACE_INHERITED_ACE);\n\t\t}\n\t}\n\tif (zfsvfs->z_acl_mode == ZFS_ACL_RESTRICTED &&\n\t    aclp->z_acl_count != 0) {\n\t\t*need_chmod = B_FALSE;\n\t}\n\n\treturn (aclp);\n}\n\n \nint\nzfs_acl_ids_create(znode_t *dzp, int flag, vattr_t *vap, cred_t *cr,\n    vsecattr_t *vsecp, zfs_acl_ids_t *acl_ids, zidmap_t *mnt_ns)\n{\n\tint\t\terror;\n\tzfsvfs_t\t*zfsvfs = dzp->z_zfsvfs;\n\tzfs_acl_t\t*paclp;\n\tgid_t\t\tgid;\n\tboolean_t\tneed_chmod = B_TRUE;\n\tboolean_t\ttrim = B_FALSE;\n\tboolean_t\tinherited = B_FALSE;\n\n\tif ((flag & IS_ROOT_NODE) == 0) {\n\t\tif (zfsvfs->z_replay == B_FALSE)\n\t\t\tASSERT_VOP_ELOCKED(ZTOV(dzp), __func__);\n\t} else\n\t\tASSERT3P(dzp->z_vnode, ==, NULL);\n\tmemset(acl_ids, 0, sizeof (zfs_acl_ids_t));\n\tacl_ids->z_mode = MAKEIMODE(vap->va_type, vap->va_mode);\n\n\tif (vsecp)\n\t\tif ((error = zfs_vsec_2_aclp(zfsvfs, vap->va_type, vsecp, cr,\n\t\t    &acl_ids->z_fuidp, &acl_ids->z_aclp)) != 0)\n\t\t\treturn (error);\n\t \n\tif ((flag & IS_ROOT_NODE) || zfsvfs->z_replay ||\n\t    ((flag & IS_XATTR) && (vap->va_type == VDIR))) {\n\t\tacl_ids->z_fuid = zfs_fuid_create(zfsvfs,\n\t\t    (uint64_t)vap->va_uid, cr,\n\t\t    ZFS_OWNER, &acl_ids->z_fuidp);\n\t\tacl_ids->z_fgid = zfs_fuid_create(zfsvfs,\n\t\t    (uint64_t)vap->va_gid, cr,\n\t\t    ZFS_GROUP, &acl_ids->z_fuidp);\n\t\tgid = vap->va_gid;\n\t} else {\n\t\tuid_t id = crgetuid(cr);\n\t\tif (IS_EPHEMERAL(id))\n\t\t\tid = UID_NOBODY;\n\t\tacl_ids->z_fuid = (uint64_t)id;\n\t\tacl_ids->z_fgid = 0;\n\t\tif (vap->va_mask & AT_GID)  {\n\t\t\tacl_ids->z_fgid = zfs_fuid_create(zfsvfs,\n\t\t\t    (uint64_t)vap->va_gid,\n\t\t\t    cr, ZFS_GROUP, &acl_ids->z_fuidp);\n\t\t\tgid = vap->va_gid;\n\t\t\tif (acl_ids->z_fgid != dzp->z_gid &&\n\t\t\t    !groupmember(vap->va_gid, cr) &&\n\t\t\t    secpolicy_vnode_create_gid(cr) != 0)\n\t\t\t\tacl_ids->z_fgid = 0;\n\t\t}\n\t\tif (acl_ids->z_fgid == 0) {\n\t\t\tconst char\t*domain;\n\t\t\tuint32_t\trid;\n\n\t\t\tacl_ids->z_fgid = dzp->z_gid;\n\t\t\tgid = zfs_fuid_map_id(zfsvfs, acl_ids->z_fgid,\n\t\t\t    cr, ZFS_GROUP);\n\n\t\t\tif (zfsvfs->z_use_fuids &&\n\t\t\t    IS_EPHEMERAL(acl_ids->z_fgid)) {\n\t\t\t\tdomain =\n\t\t\t\t    zfs_fuid_idx_domain(&zfsvfs->z_fuid_idx,\n\t\t\t\t    FUID_INDEX(acl_ids->z_fgid));\n\t\t\t\trid = FUID_RID(acl_ids->z_fgid);\n\t\t\t\tzfs_fuid_node_add(&acl_ids->z_fuidp,\n\t\t\t\t    domain, rid, FUID_INDEX(acl_ids->z_fgid),\n\t\t\t\t    acl_ids->z_fgid, ZFS_GROUP);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (!(flag & IS_ROOT_NODE) && (dzp->z_mode & S_ISGID) &&\n\t    (vap->va_type == VDIR)) {\n\t\tacl_ids->z_mode |= S_ISGID;\n\t} else {\n\t\tif ((acl_ids->z_mode & S_ISGID) &&\n\t\t    secpolicy_vnode_setids_setgids(ZTOV(dzp), cr, gid) != 0)\n\t\t\tacl_ids->z_mode &= ~S_ISGID;\n\t}\n\n\tif (acl_ids->z_aclp == NULL) {\n\t\tmutex_enter(&dzp->z_acl_lock);\n\t\tif (!(flag & IS_ROOT_NODE) &&\n\t\t    (dzp->z_pflags & ZFS_INHERIT_ACE) &&\n\t\t    !(dzp->z_pflags & ZFS_XATTR)) {\n\t\t\tVERIFY0(zfs_acl_node_read(dzp, B_TRUE,\n\t\t\t    &paclp, B_FALSE));\n\t\t\tacl_ids->z_aclp = zfs_acl_inherit(zfsvfs,\n\t\t\t    vap->va_type, paclp, acl_ids->z_mode, &need_chmod);\n\t\t\tinherited = B_TRUE;\n\t\t} else {\n\t\t\tacl_ids->z_aclp =\n\t\t\t    zfs_acl_alloc(zfs_acl_version_zp(dzp));\n\t\t\tacl_ids->z_aclp->z_hints |= ZFS_ACL_TRIVIAL;\n\t\t}\n\t\tmutex_exit(&dzp->z_acl_lock);\n\n\t\tif (need_chmod) {\n\t\t\tif (vap->va_type == VDIR)\n\t\t\t\tacl_ids->z_aclp->z_hints |=\n\t\t\t\t    ZFS_ACL_AUTO_INHERIT;\n\n\t\t\tif (zfsvfs->z_acl_mode == ZFS_ACL_GROUPMASK &&\n\t\t\t    zfsvfs->z_acl_inherit != ZFS_ACL_PASSTHROUGH &&\n\t\t\t    zfsvfs->z_acl_inherit != ZFS_ACL_PASSTHROUGH_X)\n\t\t\t\ttrim = B_TRUE;\n\t\t\tzfs_acl_chmod(vap->va_type, acl_ids->z_mode, B_FALSE,\n\t\t\t    trim, acl_ids->z_aclp);\n\t\t}\n\t}\n\n\tif (inherited || vsecp) {\n\t\tacl_ids->z_mode = zfs_mode_compute(acl_ids->z_mode,\n\t\t    acl_ids->z_aclp, &acl_ids->z_aclp->z_hints,\n\t\t    acl_ids->z_fuid, acl_ids->z_fgid);\n\t\tif (ace_trivial_common(acl_ids->z_aclp, 0, zfs_ace_walk) == 0)\n\t\t\tacl_ids->z_aclp->z_hints |= ZFS_ACL_TRIVIAL;\n\t}\n\n\treturn (0);\n}\n\n \nvoid\nzfs_acl_ids_free(zfs_acl_ids_t *acl_ids)\n{\n\tif (acl_ids->z_aclp)\n\t\tzfs_acl_free(acl_ids->z_aclp);\n\tif (acl_ids->z_fuidp)\n\t\tzfs_fuid_info_free(acl_ids->z_fuidp);\n\tacl_ids->z_aclp = NULL;\n\tacl_ids->z_fuidp = NULL;\n}\n\nboolean_t\nzfs_acl_ids_overquota(zfsvfs_t *zv, zfs_acl_ids_t *acl_ids, uint64_t projid)\n{\n\treturn (zfs_id_overquota(zv, DMU_USERUSED_OBJECT, acl_ids->z_fuid) ||\n\t    zfs_id_overquota(zv, DMU_GROUPUSED_OBJECT, acl_ids->z_fgid) ||\n\t    (projid != ZFS_DEFAULT_PROJID && projid != ZFS_INVALID_PROJID &&\n\t    zfs_id_overquota(zv, DMU_PROJECTUSED_OBJECT, projid)));\n}\n\n \nint\nzfs_getacl(znode_t *zp, vsecattr_t *vsecp, boolean_t skipaclchk, cred_t *cr)\n{\n\tzfs_acl_t\t*aclp;\n\tulong_t\t\tmask;\n\tint\t\terror;\n\tint \t\tcount = 0;\n\tint\t\tlargeace = 0;\n\n\tmask = vsecp->vsa_mask & (VSA_ACE | VSA_ACECNT |\n\t    VSA_ACE_ACLFLAGS | VSA_ACE_ALLTYPES);\n\n\tif (mask == 0)\n\t\treturn (SET_ERROR(ENOSYS));\n\n\tif ((error = zfs_zaccess(zp, ACE_READ_ACL, 0, skipaclchk, cr, NULL)))\n\t\treturn (error);\n\n\tmutex_enter(&zp->z_acl_lock);\n\n\tif (zp->z_zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(ZTOV(zp), __func__);\n\terror = zfs_acl_node_read(zp, B_TRUE, &aclp, B_FALSE);\n\tif (error != 0) {\n\t\tmutex_exit(&zp->z_acl_lock);\n\t\treturn (error);\n\t}\n\n\t \n\tif ((zp->z_pflags & ZFS_ACL_OBJ_ACE) && !(mask & VSA_ACE_ALLTYPES)) {\n\t\tvoid *zacep = NULL;\n\t\tuint64_t who;\n\t\tuint32_t access_mask;\n\t\tuint16_t type, iflags;\n\n\t\twhile ((zacep = zfs_acl_next_ace(aclp, zacep,\n\t\t    &who, &access_mask, &iflags, &type))) {\n\t\t\tswitch (type) {\n\t\t\tcase ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE:\n\t\t\tcase ACE_ACCESS_DENIED_OBJECT_ACE_TYPE:\n\t\t\tcase ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE:\n\t\t\tcase ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE:\n\t\t\t\tlargeace++;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tvsecp->vsa_aclcnt = count;\n\t} else\n\t\tcount = (int)aclp->z_acl_count;\n\n\tif (mask & VSA_ACECNT) {\n\t\tvsecp->vsa_aclcnt = count;\n\t}\n\n\tif (mask & VSA_ACE) {\n\t\tsize_t aclsz;\n\n\t\taclsz = count * sizeof (ace_t) +\n\t\t    sizeof (ace_object_t) * largeace;\n\n\t\tvsecp->vsa_aclentp = kmem_alloc(aclsz, KM_SLEEP);\n\t\tvsecp->vsa_aclentsz = aclsz;\n\n\t\tif (aclp->z_version == ZFS_ACL_VERSION_FUID)\n\t\t\tzfs_copy_fuid_2_ace(zp->z_zfsvfs, aclp, cr,\n\t\t\t    vsecp->vsa_aclentp, !(mask & VSA_ACE_ALLTYPES));\n\t\telse {\n\t\t\tzfs_acl_node_t *aclnode;\n\t\t\tvoid *start = vsecp->vsa_aclentp;\n\n\t\t\tfor (aclnode = list_head(&aclp->z_acl); aclnode;\n\t\t\t    aclnode = list_next(&aclp->z_acl, aclnode)) {\n\t\t\t\tmemcpy(start, aclnode->z_acldata,\n\t\t\t\t    aclnode->z_size);\n\t\t\t\tstart = (caddr_t)start + aclnode->z_size;\n\t\t\t}\n\t\t\tASSERT3U((caddr_t)start - (caddr_t)vsecp->vsa_aclentp,\n\t\t\t    ==, aclp->z_acl_bytes);\n\t\t}\n\t}\n\tif (mask & VSA_ACE_ACLFLAGS) {\n\t\tvsecp->vsa_aclflags = 0;\n\t\tif (zp->z_pflags & ZFS_ACL_DEFAULTED)\n\t\t\tvsecp->vsa_aclflags |= ACL_DEFAULTED;\n\t\tif (zp->z_pflags & ZFS_ACL_PROTECTED)\n\t\t\tvsecp->vsa_aclflags |= ACL_PROTECTED;\n\t\tif (zp->z_pflags & ZFS_ACL_AUTO_INHERIT)\n\t\t\tvsecp->vsa_aclflags |= ACL_AUTO_INHERIT;\n\t}\n\n\tmutex_exit(&zp->z_acl_lock);\n\n\treturn (0);\n}\n\nint\nzfs_vsec_2_aclp(zfsvfs_t *zfsvfs, umode_t obj_type,\n    vsecattr_t *vsecp, cred_t *cr, zfs_fuid_info_t **fuidp, zfs_acl_t **zaclp)\n{\n\tzfs_acl_t *aclp;\n\tzfs_acl_node_t *aclnode;\n\tint aclcnt = vsecp->vsa_aclcnt;\n\tint error;\n\n\tif (vsecp->vsa_aclcnt > MAX_ACL_ENTRIES || vsecp->vsa_aclcnt <= 0)\n\t\treturn (SET_ERROR(EINVAL));\n\n\taclp = zfs_acl_alloc(zfs_acl_version(zfsvfs->z_version));\n\n\taclp->z_hints = 0;\n\taclnode = zfs_acl_node_alloc(aclcnt * sizeof (zfs_object_ace_t));\n\tif (aclp->z_version == ZFS_ACL_VERSION_INITIAL) {\n\t\tif ((error = zfs_copy_ace_2_oldace(obj_type, aclp,\n\t\t    (ace_t *)vsecp->vsa_aclentp, aclnode->z_acldata,\n\t\t    aclcnt, &aclnode->z_size)) != 0) {\n\t\t\tzfs_acl_free(aclp);\n\t\t\tzfs_acl_node_free(aclnode);\n\t\t\treturn (error);\n\t\t}\n\t} else {\n\t\tif ((error = zfs_copy_ace_2_fuid(zfsvfs, obj_type, aclp,\n\t\t    vsecp->vsa_aclentp, aclnode->z_acldata, aclcnt,\n\t\t    &aclnode->z_size, fuidp, cr)) != 0) {\n\t\t\tzfs_acl_free(aclp);\n\t\t\tzfs_acl_node_free(aclnode);\n\t\t\treturn (error);\n\t\t}\n\t}\n\taclp->z_acl_bytes = aclnode->z_size;\n\taclnode->z_ace_count = aclcnt;\n\taclp->z_acl_count = aclcnt;\n\tlist_insert_head(&aclp->z_acl, aclnode);\n\n\t \n\tif (vsecp->vsa_mask & VSA_ACE_ACLFLAGS) {\n\t\tif (vsecp->vsa_aclflags & ACL_PROTECTED)\n\t\t\taclp->z_hints |= ZFS_ACL_PROTECTED;\n\t\tif (vsecp->vsa_aclflags & ACL_DEFAULTED)\n\t\t\taclp->z_hints |= ZFS_ACL_DEFAULTED;\n\t\tif (vsecp->vsa_aclflags & ACL_AUTO_INHERIT)\n\t\t\taclp->z_hints |= ZFS_ACL_AUTO_INHERIT;\n\t}\n\n\t*zaclp = aclp;\n\n\treturn (0);\n}\n\n \nint\nzfs_setacl(znode_t *zp, vsecattr_t *vsecp, boolean_t skipaclchk, cred_t *cr)\n{\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tzilog_t\t\t*zilog = zfsvfs->z_log;\n\tulong_t\t\tmask = vsecp->vsa_mask & (VSA_ACE | VSA_ACECNT);\n\tdmu_tx_t\t*tx;\n\tint\t\terror;\n\tzfs_acl_t\t*aclp;\n\tzfs_fuid_info_t\t*fuidp = NULL;\n\tboolean_t\tfuid_dirtied;\n\tuint64_t\tacl_obj;\n\n\tif (zp->z_zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_ELOCKED(ZTOV(zp), __func__);\n\tif (mask == 0)\n\t\treturn (SET_ERROR(ENOSYS));\n\n\tif (zp->z_pflags & ZFS_IMMUTABLE)\n\t\treturn (SET_ERROR(EPERM));\n\n\tif ((error = zfs_zaccess(zp, ACE_WRITE_ACL, 0, skipaclchk, cr, NULL)))\n\t\treturn (error);\n\n\terror = zfs_vsec_2_aclp(zfsvfs, ZTOV(zp)->v_type, vsecp, cr, &fuidp,\n\t    &aclp);\n\tif (error)\n\t\treturn (error);\n\n\t \n\tif (!(vsecp->vsa_mask & VSA_ACE_ACLFLAGS)) {\n\t\taclp->z_hints |=\n\t\t    (zp->z_pflags & V4_ACL_WIDE_FLAGS);\n\t}\ntop:\n\tmutex_enter(&zp->z_acl_lock);\n\n\ttx = dmu_tx_create(zfsvfs->z_os);\n\n\tdmu_tx_hold_sa(tx, zp->z_sa_hdl, B_TRUE);\n\n\tfuid_dirtied = zfsvfs->z_fuid_dirty;\n\tif (fuid_dirtied)\n\t\tzfs_fuid_txhold(zfsvfs, tx);\n\n\t \n\n\tif ((acl_obj = zfs_external_acl(zp)) != 0) {\n\t\tif (zfsvfs->z_version >= ZPL_VERSION_FUID &&\n\t\t    zfs_znode_acl_version(zp) <= ZFS_ACL_VERSION_INITIAL) {\n\t\t\tdmu_tx_hold_free(tx, acl_obj, 0,\n\t\t\t    DMU_OBJECT_END);\n\t\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,\n\t\t\t    aclp->z_acl_bytes);\n\t\t} else {\n\t\t\tdmu_tx_hold_write(tx, acl_obj, 0, aclp->z_acl_bytes);\n\t\t}\n\t} else if (!zp->z_is_sa && aclp->z_acl_bytes > ZFS_ACE_SPACE) {\n\t\tdmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0, aclp->z_acl_bytes);\n\t}\n\n\tzfs_sa_upgrade_txholds(tx, zp);\n\terror = dmu_tx_assign(tx, TXG_NOWAIT);\n\tif (error) {\n\t\tmutex_exit(&zp->z_acl_lock);\n\n\t\tif (error == ERESTART) {\n\t\t\tdmu_tx_wait(tx);\n\t\t\tdmu_tx_abort(tx);\n\t\t\tgoto top;\n\t\t}\n\t\tdmu_tx_abort(tx);\n\t\tzfs_acl_free(aclp);\n\t\treturn (error);\n\t}\n\n\terror = zfs_aclset_common(zp, aclp, cr, tx);\n\tASSERT0(error);\n\tASSERT3P(zp->z_acl_cached, ==, NULL);\n\tzp->z_acl_cached = aclp;\n\n\tif (fuid_dirtied)\n\t\tzfs_fuid_sync(zfsvfs, tx);\n\n\tzfs_log_acl(zilog, tx, zp, vsecp, fuidp);\n\n\tif (fuidp)\n\t\tzfs_fuid_info_free(fuidp);\n\tdmu_tx_commit(tx);\n\tmutex_exit(&zp->z_acl_lock);\n\n\treturn (error);\n}\n\n \nstatic int\nzfs_zaccess_dataset_check(znode_t *zp, uint32_t v4_mode)\n{\n\tif ((v4_mode & WRITE_MASK) &&\n\t    (zp->z_zfsvfs->z_vfs->vfs_flag & VFS_RDONLY) &&\n\t    (!IS_DEVVP(ZTOV(zp)) || (v4_mode & WRITE_MASK_ATTRS))) {\n\t\treturn (SET_ERROR(EROFS));\n\t}\n\n\t \n\tif ((v4_mode & WRITE_MASK_DATA) &&\n\t    (zp->z_pflags & ZFS_IMMUTABLE)) {\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\t \n\tif ((v4_mode & ACE_DELETE) &&\n\t    (zp->z_pflags & ZFS_NOUNLINK)) {\n\t\treturn (EPERM);\n\t}\n\n\tif (((v4_mode & (ACE_READ_DATA|ACE_EXECUTE)) &&\n\t    (zp->z_pflags & ZFS_AV_QUARANTINED))) {\n\t\treturn (SET_ERROR(EACCES));\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nzfs_zaccess_aces_check(znode_t *zp, uint32_t *working_mode,\n    boolean_t anyaccess, cred_t *cr)\n{\n\tzfsvfs_t\t*zfsvfs = zp->z_zfsvfs;\n\tzfs_acl_t\t*aclp;\n\tint\t\terror;\n\tuid_t\t\tuid = crgetuid(cr);\n\tuint64_t \twho;\n\tuint16_t\ttype, iflags;\n\tuint16_t\tentry_type;\n\tuint32_t\taccess_mask;\n\tuint32_t\tdeny_mask = 0;\n\tzfs_ace_hdr_t\t*acep = NULL;\n\tboolean_t\tcheckit;\n\tuid_t\t\tgowner;\n\tuid_t\t\tfowner;\n\n\tzfs_fuid_map_ids(zp, cr, &fowner, &gowner);\n\n\tmutex_enter(&zp->z_acl_lock);\n\n\tif (zp->z_zfsvfs->z_replay == B_FALSE)\n\t\tASSERT_VOP_LOCKED(ZTOV(zp), __func__);\n\terror = zfs_acl_node_read(zp, B_TRUE, &aclp, B_FALSE);\n\tif (error != 0) {\n\t\tmutex_exit(&zp->z_acl_lock);\n\t\treturn (error);\n\t}\n\n\tASSERT3P(zp->z_acl_cached, !=, NULL);\n\n\twhile ((acep = zfs_acl_next_ace(aclp, acep, &who, &access_mask,\n\t    &iflags, &type))) {\n\t\tuint32_t mask_matched;\n\n\t\tif (!zfs_acl_valid_ace_type(type, iflags))\n\t\t\tcontinue;\n\n\t\tif (ZTOV(zp)->v_type == VDIR && (iflags & ACE_INHERIT_ONLY_ACE))\n\t\t\tcontinue;\n\n\t\t \n\t\tmask_matched = (access_mask & *working_mode);\n\t\tif (!mask_matched)\n\t\t\tcontinue;\n\n\t\tentry_type = (iflags & ACE_TYPE_FLAGS);\n\n\t\tcheckit = B_FALSE;\n\n\t\tswitch (entry_type) {\n\t\tcase ACE_OWNER:\n\t\t\tif (uid == fowner)\n\t\t\t\tcheckit = B_TRUE;\n\t\t\tbreak;\n\t\tcase OWNING_GROUP:\n\t\t\twho = gowner;\n\t\t\tzfs_fallthrough;\n\t\tcase ACE_IDENTIFIER_GROUP:\n\t\t\tcheckit = zfs_groupmember(zfsvfs, who, cr);\n\t\t\tbreak;\n\t\tcase ACE_EVERYONE:\n\t\t\tcheckit = B_TRUE;\n\t\t\tbreak;\n\n\t\t \n\t\tdefault:\n\t\t\tif (entry_type == 0) {\n\t\t\t\tuid_t newid;\n\n\t\t\t\tnewid = zfs_fuid_map_id(zfsvfs, who, cr,\n\t\t\t\t    ZFS_ACE_USER);\n\t\t\t\tif (newid !=  UID_NOBODY &&\n\t\t\t\t    uid == newid)\n\t\t\t\t\tcheckit = B_TRUE;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmutex_exit(&zp->z_acl_lock);\n\t\t\t\treturn (SET_ERROR(EIO));\n\t\t\t}\n\t\t}\n\n\t\tif (checkit) {\n\t\t\tif (type == DENY) {\n\t\t\t\tDTRACE_PROBE3(zfs__ace__denies,\n\t\t\t\t    znode_t *, zp,\n\t\t\t\t    zfs_ace_hdr_t *, acep,\n\t\t\t\t    uint32_t, mask_matched);\n\t\t\t\tdeny_mask |= mask_matched;\n\t\t\t} else {\n\t\t\t\tDTRACE_PROBE3(zfs__ace__allows,\n\t\t\t\t    znode_t *, zp,\n\t\t\t\t    zfs_ace_hdr_t *, acep,\n\t\t\t\t    uint32_t, mask_matched);\n\t\t\t\tif (anyaccess) {\n\t\t\t\t\tmutex_exit(&zp->z_acl_lock);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*working_mode &= ~mask_matched;\n\t\t}\n\n\t\t \n\t\tif (*working_mode == 0)\n\t\t\tbreak;\n\t}\n\n\tmutex_exit(&zp->z_acl_lock);\n\n\t \n\tif (deny_mask) {\n\t\t*working_mode |= deny_mask;\n\t\treturn (SET_ERROR(EACCES));\n\t} else if (*working_mode) {\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\n \nboolean_t\nzfs_has_access(znode_t *zp, cred_t *cr)\n{\n\tuint32_t have = ACE_ALL_PERMS;\n\n\tif (zfs_zaccess_aces_check(zp, &have, B_TRUE, cr) != 0) {\n\t\tuid_t owner;\n\n\t\towner = zfs_fuid_map_id(zp->z_zfsvfs, zp->z_uid, cr, ZFS_OWNER);\n\t\treturn (secpolicy_vnode_any_access(cr, ZTOV(zp), owner) == 0);\n\t}\n\treturn (B_TRUE);\n}\n\nstatic int\nzfs_zaccess_common(znode_t *zp, uint32_t v4_mode, uint32_t *working_mode,\n    boolean_t *check_privs, boolean_t skipaclchk, cred_t *cr)\n{\n\tzfsvfs_t *zfsvfs = zp->z_zfsvfs;\n\tint err;\n\n\t*working_mode = v4_mode;\n\t*check_privs = B_TRUE;\n\n\t \n\tif (v4_mode == 0 || zfsvfs->z_replay) {\n\t\t*working_mode = 0;\n\t\treturn (0);\n\t}\n\n\tif ((err = zfs_zaccess_dataset_check(zp, v4_mode)) != 0) {\n\t\t*check_privs = B_FALSE;\n\t\treturn (err);\n\t}\n\n\t \n\tif (skipaclchk) {\n\t\t*working_mode = 0;\n\t\treturn (0);\n\t}\n\n\t \n\tif ((v4_mode & WRITE_MASK_DATA) &&\n\t    (ZTOV(zp)->v_type != VDIR) &&\n\t    (zp->z_pflags & ZFS_READONLY)) {\n\t\treturn (SET_ERROR(EPERM));\n\t}\n\n\treturn (zfs_zaccess_aces_check(zp, working_mode, B_FALSE, cr));\n}\n\nstatic int\nzfs_zaccess_append(znode_t *zp, uint32_t *working_mode, boolean_t *check_privs,\n    cred_t *cr)\n{\n\tif (*working_mode != ACE_WRITE_DATA)\n\t\treturn (SET_ERROR(EACCES));\n\n\treturn (zfs_zaccess_common(zp, ACE_APPEND_DATA, working_mode,\n\t    check_privs, B_FALSE, cr));\n}\n\n \nint\nzfs_fastaccesschk_execute(znode_t *zdp, cred_t *cr)\n{\n\tboolean_t is_attr;\n\n\tif (zdp->z_pflags & ZFS_AV_QUARANTINED)\n\t\treturn (1);\n\n\tis_attr = ((zdp->z_pflags & ZFS_XATTR) &&\n\t    (ZTOV(zdp)->v_type == VDIR));\n\tif (is_attr)\n\t\treturn (1);\n\n\tif (zdp->z_pflags & ZFS_NO_EXECS_DENIED)\n\t\treturn (0);\n\n\treturn (1);\n}\n\n\n \nint\nzfs_zaccess(znode_t *zp, int mode, int flags, boolean_t skipaclchk, cred_t *cr,\n    zidmap_t *mnt_ns)\n{\n\tuint32_t\tworking_mode;\n\tint\t\terror;\n\tint\t\tis_attr;\n\tboolean_t \tcheck_privs;\n\tznode_t\t\t*xzp = NULL;\n\tznode_t \t*check_zp = zp;\n\tmode_t\t\tneeded_bits;\n\tuid_t\t\towner;\n\n\tis_attr = ((zp->z_pflags & ZFS_XATTR) && (ZTOV(zp)->v_type == VDIR));\n\n\t \n\tif (zp->z_pflags & ZFS_XATTR)\n\t\treturn (0);\n\n\towner = zfs_fuid_map_id(zp->z_zfsvfs, zp->z_uid, cr, ZFS_OWNER);\n\n\t \n\tneeded_bits = 0;\n\n\tworking_mode = mode;\n\tif ((working_mode & (ACE_READ_ACL|ACE_READ_ATTRIBUTES)) &&\n\t    owner == crgetuid(cr))\n\t\tworking_mode &= ~(ACE_READ_ACL|ACE_READ_ATTRIBUTES);\n\n\tif (working_mode & (ACE_READ_DATA|ACE_READ_NAMED_ATTRS|\n\t    ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_SYNCHRONIZE))\n\t\tneeded_bits |= VREAD;\n\tif (working_mode & (ACE_WRITE_DATA|ACE_WRITE_NAMED_ATTRS|\n\t    ACE_APPEND_DATA|ACE_WRITE_ATTRIBUTES|ACE_SYNCHRONIZE))\n\t\tneeded_bits |= VWRITE;\n\tif (working_mode & ACE_EXECUTE)\n\t\tneeded_bits |= VEXEC;\n\n\tif ((error = zfs_zaccess_common(check_zp, mode, &working_mode,\n\t    &check_privs, skipaclchk, cr)) == 0) {\n\t\tif (is_attr)\n\t\t\tVN_RELE(ZTOV(xzp));\n\t\treturn (secpolicy_vnode_access2(cr, ZTOV(zp), owner,\n\t\t    needed_bits, needed_bits));\n\t}\n\n\tif (error && !check_privs) {\n\t\tif (is_attr)\n\t\t\tVN_RELE(ZTOV(xzp));\n\t\treturn (error);\n\t}\n\n\tif (error && (flags & V_APPEND)) {\n\t\terror = zfs_zaccess_append(zp, &working_mode, &check_privs, cr);\n\t}\n\n\tif (error && check_privs) {\n\t\tmode_t\t\tcheckmode = 0;\n\t\tvnode_t *check_vp = ZTOV(check_zp);\n\n\t\t \n\n\t\tASSERT3U(working_mode, !=, 0);\n\n\t\tif ((working_mode & (ACE_READ_ACL|ACE_READ_ATTRIBUTES) &&\n\t\t    owner == crgetuid(cr)))\n\t\t\tworking_mode &= ~(ACE_READ_ACL|ACE_READ_ATTRIBUTES);\n\n\t\tif (working_mode & (ACE_READ_DATA|ACE_READ_NAMED_ATTRS|\n\t\t    ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_SYNCHRONIZE))\n\t\t\tcheckmode |= VREAD;\n\t\tif (working_mode & (ACE_WRITE_DATA|ACE_WRITE_NAMED_ATTRS|\n\t\t    ACE_APPEND_DATA|ACE_WRITE_ATTRIBUTES|ACE_SYNCHRONIZE))\n\t\t\tcheckmode |= VWRITE;\n\t\tif (working_mode & ACE_EXECUTE)\n\t\t\tcheckmode |= VEXEC;\n\n\t\terror = secpolicy_vnode_access2(cr, check_vp, owner,\n\t\t    needed_bits & ~checkmode, needed_bits);\n\n\t\tif (error == 0 && (working_mode & ACE_WRITE_OWNER))\n\t\t\terror = secpolicy_vnode_chown(check_vp, cr, owner);\n\t\tif (error == 0 && (working_mode & ACE_WRITE_ACL))\n\t\t\terror = secpolicy_vnode_setdac(check_vp, cr, owner);\n\n\t\tif (error == 0 && (working_mode &\n\t\t    (ACE_DELETE|ACE_DELETE_CHILD)))\n\t\t\terror = secpolicy_vnode_remove(check_vp, cr);\n\n\t\tif (error == 0 && (working_mode & ACE_SYNCHRONIZE)) {\n\t\t\terror = secpolicy_vnode_chown(check_vp, cr, owner);\n\t\t}\n\t\tif (error == 0) {\n\t\t\t \n\t\t\tif (working_mode & ~(ZFS_CHECKED_MASKS)) {\n\t\t\t\terror = SET_ERROR(EACCES);\n\t\t\t}\n\t\t}\n\t} else if (error == 0) {\n\t\terror = secpolicy_vnode_access2(cr, ZTOV(zp), owner,\n\t\t    needed_bits, needed_bits);\n\t}\n\n\n\tif (is_attr)\n\t\tVN_RELE(ZTOV(xzp));\n\n\treturn (error);\n}\n\n \nint\nzfs_zaccess_rwx(znode_t *zp, mode_t mode, int flags, cred_t *cr,\n    zidmap_t *mnt_ns)\n{\n\treturn (zfs_zaccess(zp, zfs_unix_to_v4(mode >> 6), flags, B_FALSE, cr,\n\t    mnt_ns));\n}\n\n \nint\nzfs_zaccess_unix(void *zp, int mode, cred_t *cr)\n{\n\tint v4_mode = zfs_unix_to_v4(mode >> 6);\n\n\treturn (zfs_zaccess(zp, v4_mode, 0, B_FALSE, cr, NULL));\n}\n\nstatic int\nzfs_delete_final_check(znode_t *zp, znode_t *dzp,\n    mode_t available_perms, cred_t *cr)\n{\n\tint error;\n\tuid_t downer;\n\n\tdowner = zfs_fuid_map_id(dzp->z_zfsvfs, dzp->z_uid, cr, ZFS_OWNER);\n\n\terror = secpolicy_vnode_access2(cr, ZTOV(dzp),\n\t    downer, available_perms, VWRITE|VEXEC);\n\n\tif (error == 0)\n\t\terror = zfs_sticky_remove_access(dzp, zp, cr);\n\n\treturn (error);\n}\n\n \nint\nzfs_zaccess_delete(znode_t *dzp, znode_t *zp, cred_t *cr, zidmap_t *mnt_ns)\n{\n\tuint32_t dzp_working_mode = 0;\n\tuint32_t zp_working_mode = 0;\n\tint dzp_error, zp_error;\n\tmode_t available_perms;\n\tboolean_t dzpcheck_privs = B_TRUE;\n\tboolean_t zpcheck_privs = B_TRUE;\n\n\t \n\n\tif (zp->z_pflags & (ZFS_IMMUTABLE | ZFS_NOUNLINK))\n\t\treturn (SET_ERROR(EPERM));\n\n\t \n\tif ((dzp_error = zfs_zaccess_common(dzp, ACE_DELETE_CHILD,\n\t    &dzp_working_mode, &dzpcheck_privs, B_FALSE, cr)) == 0)\n\t\treturn (0);\n\n\t \n\tif ((zp_error = zfs_zaccess_common(zp, ACE_DELETE, &zp_working_mode,\n\t    &zpcheck_privs, B_FALSE, cr)) == 0)\n\t\treturn (0);\n\n\tASSERT(dzp_error);\n\tASSERT(zp_error);\n\n\tif (!dzpcheck_privs)\n\t\treturn (dzp_error);\n\tif (!zpcheck_privs)\n\t\treturn (zp_error);\n\n\t \n\n\tif (dzp_error == EACCES) {\n\t\t \n\t\treturn (secpolicy_vnode_remove(ZTOV(dzp), cr));\n\t}\n\t \n\n\tdzp_error = zfs_zaccess_common(dzp, ACE_EXECUTE|ACE_WRITE_DATA,\n\t    &dzp_working_mode, &dzpcheck_privs, B_FALSE, cr);\n\n\tif (dzp_error != 0 && !dzpcheck_privs)\n\t\treturn (dzp_error);\n\n\t \n\n\tavailable_perms = (dzp_working_mode & ACE_WRITE_DATA) ? 0 : VWRITE;\n\tavailable_perms |= (dzp_working_mode & ACE_EXECUTE) ? 0 : VEXEC;\n\n\treturn (zfs_delete_final_check(zp, dzp, available_perms, cr));\n\n}\n\nint\nzfs_zaccess_rename(znode_t *sdzp, znode_t *szp, znode_t *tdzp,\n    znode_t *tzp, cred_t *cr, zidmap_t *mnt_ns)\n{\n\tint add_perm;\n\tint error;\n\n\tif (szp->z_pflags & ZFS_AV_QUARANTINED)\n\t\treturn (SET_ERROR(EACCES));\n\n\tadd_perm = (ZTOV(szp)->v_type == VDIR) ?\n\t    ACE_ADD_SUBDIRECTORY : ACE_ADD_FILE;\n\n\t \n\tif (ZTOV(szp)->v_type == VDIR && ZTOV(sdzp) != ZTOV(tdzp)) {\n\t\tif ((error = zfs_zaccess(szp, ACE_WRITE_DATA, 0, B_FALSE, cr,\n\t\t    mnt_ns)))\n\t\t\treturn (error);\n\t}\n\n\t \n\n\tif ((error = zfs_zaccess_delete(sdzp, szp, cr, mnt_ns)))\n\t\treturn (error);\n\n\t \n\tif (tzp && (error = zfs_zaccess_delete(tdzp, tzp, cr, mnt_ns)))\n\t\treturn (error);\n\n\t \n\terror = zfs_zaccess(tdzp, add_perm, 0, B_FALSE, cr, mnt_ns);\n\n\treturn (error);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}