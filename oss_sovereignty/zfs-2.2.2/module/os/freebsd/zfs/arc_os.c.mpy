{
  "module_name": "arc_os.c",
  "hash_id": "060e470ce1e28ec04431e6c489daccba2515284eced304b2ccbb32b50f09b77c",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/arc_os.c",
  "human_readable_source": " \n\n#include <sys/spa.h>\n#include <sys/zio.h>\n#include <sys/spa_impl.h>\n#include <sys/counter.h>\n#include <sys/zio_compress.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_context.h>\n#include <sys/arc.h>\n#include <sys/arc_os.h>\n#include <sys/zfs_refcount.h>\n#include <sys/vdev.h>\n#include <sys/vdev_trim.h>\n#include <sys/vdev_impl.h>\n#include <sys/dsl_pool.h>\n#include <sys/zio_checksum.h>\n#include <sys/multilist.h>\n#include <sys/abd.h>\n#include <sys/zil.h>\n#include <sys/fm/fs/zfs.h>\n#include <sys/eventhandler.h>\n#include <sys/callb.h>\n#include <sys/kstat.h>\n#include <sys/zthr.h>\n#include <zfs_fletcher.h>\n#include <sys/arc_impl.h>\n#include <sys/sdt.h>\n#include <sys/aggsum.h>\n#include <sys/vnode.h>\n#include <cityhash.h>\n#include <machine/vmparam.h>\n#include <sys/vm.h>\n#include <sys/vmmeter.h>\n\nextern struct vfsops zfs_vfsops;\n\nuint_t zfs_arc_free_target = 0;\n\nstatic void\narc_free_target_init(void *unused __unused)\n{\n\tzfs_arc_free_target = vm_cnt.v_free_target;\n}\nSYSINIT(arc_free_target_init, SI_SUB_KTHREAD_PAGE, SI_ORDER_ANY,\n    arc_free_target_init, NULL);\n\n \nZFS_MODULE_PARAM_CALL(zfs_arc, zfs_arc_, free_target,\n    param_set_arc_free_target, 0, CTLFLAG_RW,\n\t\"Desired number of free pages below which ARC triggers reclaim\");\nZFS_MODULE_PARAM_CALL(zfs_arc, zfs_arc_, no_grow_shift,\n    param_set_arc_no_grow_shift, 0, ZMOD_RW,\n\t\"log2(fraction of ARC which must be free to allow growing)\");\n\nint64_t\narc_available_memory(void)\n{\n\tint64_t lowest = INT64_MAX;\n\tint64_t n __unused;\n\n\t \n\tn = PAGESIZE * ((int64_t)freemem - zfs_arc_free_target);\n\tif (n < lowest) {\n\t\tlowest = n;\n\t}\n#if defined(__i386) || !defined(UMA_MD_SMALL_ALLOC)\n\t \n\tn = uma_avail() - (long)(uma_limit() / 4);\n\tif (n < lowest) {\n\t\tlowest = n;\n\t}\n#endif\n\n\tDTRACE_PROBE1(arc__available_memory, int64_t, lowest);\n\treturn (lowest);\n}\n\n \nuint64_t\narc_default_max(uint64_t min, uint64_t allmem)\n{\n\tuint64_t size;\n\n\tif (allmem >= 1 << 30)\n\t\tsize = allmem - (1 << 30);\n\telse\n\t\tsize = min;\n\treturn (MAX(allmem * 5 / 8, size));\n}\n\nuint64_t\narc_all_memory(void)\n{\n\treturn (ptob(physmem));\n}\n\nint\narc_memory_throttle(spa_t *spa, uint64_t reserve, uint64_t txg)\n{\n\treturn (0);\n}\n\nuint64_t\narc_free_memory(void)\n{\n\treturn (ptob(freemem));\n}\n\nstatic eventhandler_tag arc_event_lowmem = NULL;\n\nstatic void\narc_lowmem(void *arg __unused, int howto __unused)\n{\n\tint64_t free_memory, to_free;\n\n\tarc_no_grow = B_TRUE;\n\tarc_warm = B_TRUE;\n\tarc_growtime = gethrtime() + SEC2NSEC(arc_grow_retry);\n\tfree_memory = arc_available_memory();\n\tint64_t can_free = arc_c - arc_c_min;\n\tif (can_free <= 0)\n\t\treturn;\n\tto_free = (can_free >> arc_shrink_shift) - MIN(free_memory, 0);\n\tDTRACE_PROBE2(arc__needfree, int64_t, free_memory, int64_t, to_free);\n\tarc_reduce_target_size(to_free);\n\n\t \n\tif (curproc == pageproc)\n\t\tarc_wait_for_eviction(to_free, B_FALSE);\n}\n\nvoid\narc_lowmem_init(void)\n{\n\tarc_event_lowmem = EVENTHANDLER_REGISTER(vm_lowmem, arc_lowmem, NULL,\n\t    EVENTHANDLER_PRI_FIRST);\n}\n\nvoid\narc_lowmem_fini(void)\n{\n\tif (arc_event_lowmem != NULL)\n\t\tEVENTHANDLER_DEREGISTER(vm_lowmem, arc_event_lowmem);\n}\n\nvoid\narc_register_hotplug(void)\n{\n}\n\nvoid\narc_unregister_hotplug(void)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}