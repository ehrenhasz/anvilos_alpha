{
  "module_name": "zfs_file_os.c",
  "hash_id": "7afbb7b8ca7669726cfe442db9a91634cc597781af949a3be6ba772005af7655",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_file_os.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_recv.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_file.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n\nint\nzfs_file_open(const char *path, int flags, int mode, zfs_file_t **fpp)\n{\n\tstruct thread *td;\n\tint rc, fd;\n\n\ttd = curthread;\n\tpwd_ensure_dirs();\n\t \n\trc = kern_openat(td, AT_FDCWD, __DECONST(char *, path),\n\t    UIO_SYSSPACE, flags, mode);\n\tif (rc)\n\t\treturn (SET_ERROR(rc));\n\tfd = td->td_retval[0];\n\ttd->td_retval[0] = 0;\n\tif (fget(curthread, fd, &cap_no_rights, fpp))\n\t\tkern_close(td, fd);\n\treturn (0);\n}\n\nvoid\nzfs_file_close(zfs_file_t *fp)\n{\n\tfo_close(fp, curthread);\n}\n\nstatic int\nzfs_file_write_impl(zfs_file_t *fp, const void *buf, size_t count, loff_t *offp,\n    ssize_t *resid)\n{\n\tssize_t rc;\n\tstruct uio auio;\n\tstruct thread *td;\n\tstruct iovec aiov;\n\n\ttd = curthread;\n\taiov.iov_base = (void *)(uintptr_t)buf;\n\taiov.iov_len = count;\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_resid = count;\n\tauio.uio_rw = UIO_WRITE;\n\tauio.uio_td = td;\n\tauio.uio_offset = *offp;\n\n\tif ((fp->f_flag & FWRITE) == 0)\n\t\treturn (SET_ERROR(EBADF));\n\n\tif (fp->f_type == DTYPE_VNODE)\n\t\tbwillwrite();\n\n\trc = fo_write(fp, &auio, td->td_ucred, FOF_OFFSET, td);\n\tif (rc)\n\t\treturn (SET_ERROR(rc));\n\tif (resid)\n\t\t*resid = auio.uio_resid;\n\telse if (auio.uio_resid)\n\t\treturn (SET_ERROR(EIO));\n\t*offp += count - auio.uio_resid;\n\treturn (rc);\n}\n\nint\nzfs_file_write(zfs_file_t *fp, const void *buf, size_t count, ssize_t *resid)\n{\n\tloff_t off = fp->f_offset;\n\tssize_t rc;\n\n\trc = zfs_file_write_impl(fp, buf, count, &off, resid);\n\tif (rc == 0)\n\t\tfp->f_offset = off;\n\n\treturn (SET_ERROR(rc));\n}\n\nint\nzfs_file_pwrite(zfs_file_t *fp, const void *buf, size_t count, loff_t off,\n    ssize_t *resid)\n{\n\treturn (zfs_file_write_impl(fp, buf, count, &off, resid));\n}\n\nstatic int\nzfs_file_read_impl(zfs_file_t *fp, void *buf, size_t count, loff_t *offp,\n    ssize_t *resid)\n{\n\tssize_t rc;\n\tstruct uio auio;\n\tstruct thread *td;\n\tstruct iovec aiov;\n\n\ttd = curthread;\n\taiov.iov_base = (void *)(uintptr_t)buf;\n\taiov.iov_len = count;\n\tauio.uio_iov = &aiov;\n\tauio.uio_iovcnt = 1;\n\tauio.uio_segflg = UIO_SYSSPACE;\n\tauio.uio_resid = count;\n\tauio.uio_rw = UIO_READ;\n\tauio.uio_td = td;\n\tauio.uio_offset = *offp;\n\n\tif ((fp->f_flag & FREAD) == 0)\n\t\treturn (SET_ERROR(EBADF));\n\n\trc = fo_read(fp, &auio, td->td_ucred, FOF_OFFSET, td);\n\tif (rc)\n\t\treturn (SET_ERROR(rc));\n\tif (resid)\n\t\t*resid = auio.uio_resid;\n\t*offp += count - auio.uio_resid;\n\treturn (SET_ERROR(0));\n}\n\nint\nzfs_file_read(zfs_file_t *fp, void *buf, size_t count, ssize_t *resid)\n{\n\tloff_t off = fp->f_offset;\n\tssize_t rc;\n\n\trc = zfs_file_read_impl(fp, buf, count, &off, resid);\n\tif (rc == 0)\n\t\tfp->f_offset = off;\n\treturn (rc);\n}\n\nint\nzfs_file_pread(zfs_file_t *fp, void *buf, size_t count, loff_t off,\n    ssize_t *resid)\n{\n\treturn (zfs_file_read_impl(fp, buf, count, &off, resid));\n}\n\nint\nzfs_file_seek(zfs_file_t *fp, loff_t *offp, int whence)\n{\n\tint rc;\n\tstruct thread *td;\n\n\ttd = curthread;\n\tif ((fp->f_ops->fo_flags & DFLAG_SEEKABLE) == 0)\n\t\treturn (SET_ERROR(ESPIPE));\n\trc = fo_seek(fp, *offp, whence, td);\n\tif (rc == 0)\n\t\t*offp = td->td_uretoff.tdu_off;\n\treturn (SET_ERROR(rc));\n}\n\nint\nzfs_file_getattr(zfs_file_t *fp, zfs_file_attr_t *zfattr)\n{\n\tstruct thread *td;\n\tstruct stat sb;\n\tint rc;\n\n\ttd = curthread;\n\n#if __FreeBSD_version < 1400037\n\trc = fo_stat(fp, &sb, td->td_ucred, td);\n#else\n\trc = fo_stat(fp, &sb, td->td_ucred);\n#endif\n\tif (rc)\n\t\treturn (SET_ERROR(rc));\n\tzfattr->zfa_size = sb.st_size;\n\tzfattr->zfa_mode = sb.st_mode;\n\n\treturn (0);\n}\n\nstatic __inline int\nzfs_vop_fsync(vnode_t *vp)\n{\n\tstruct mount *mp;\n\tint error;\n\n#if __FreeBSD_version < 1400068\n\tif ((error = vn_start_write(vp, &mp, V_WAIT | PCATCH)) != 0)\n#else\n\tif ((error = vn_start_write(vp, &mp, V_WAIT | V_PCATCH)) != 0)\n#endif\n\t\tgoto drop;\n\tvn_lock(vp, LK_EXCLUSIVE | LK_RETRY);\n\terror = VOP_FSYNC(vp, MNT_WAIT, curthread);\n\tVOP_UNLOCK1(vp);\n\tvn_finished_write(mp);\ndrop:\n\treturn (SET_ERROR(error));\n}\n\nint\nzfs_file_fsync(zfs_file_t *fp, int flags)\n{\n\tif (fp->f_type != DTYPE_VNODE)\n\t\treturn (EINVAL);\n\n\treturn (zfs_vop_fsync(fp->f_vnode));\n}\n\nzfs_file_t *\nzfs_file_get(int fd)\n{\n\tstruct file *fp;\n\n\tif (fget(curthread, fd, &cap_no_rights, &fp))\n\t\treturn (NULL);\n\n\treturn (fp);\n}\n\nvoid\nzfs_file_put(zfs_file_t *fp)\n{\n\tfdrop(fp, curthread);\n}\n\nloff_t\nzfs_file_off(zfs_file_t *fp)\n{\n\treturn (fp->f_offset);\n}\n\nvoid *\nzfs_file_private(zfs_file_t *fp)\n{\n\tfile_t *tmpfp;\n\tvoid *data;\n\tint error;\n\n\ttmpfp = curthread->td_fpop;\n\tcurthread->td_fpop = fp;\n\terror = devfs_get_cdevpriv(&data);\n\tcurthread->td_fpop = tmpfp;\n\tif (error != 0)\n\t\treturn (NULL);\n\treturn (data);\n}\n\nint\nzfs_file_unlink(const char *fnamep)\n{\n\tzfs_uio_seg_t seg = UIO_SYSSPACE;\n\tint rc;\n\n#if __FreeBSD_version >= 1300018\n\trc = kern_funlinkat(curthread, AT_FDCWD, fnamep, FD_NONE, seg, 0, 0);\n#elif __FreeBSD_version >= 1202504 || defined(AT_BENEATH)\n\trc = kern_unlinkat(curthread, AT_FDCWD, __DECONST(char *, fnamep),\n\t    seg, 0, 0);\n#else\n\trc = kern_unlinkat(curthread, AT_FDCWD, __DECONST(char *, fnamep),\n\t    seg, 0);\n#endif\n\treturn (SET_ERROR(rc));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}