{
  "module_name": "dmu_os.c",
  "hash_id": "a8ed2d564ff2d3ee491f1899dc882f2a78d523b39a6f81ac9206490843ae092a",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/dmu_os.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_tx.h>\n#include <sys/dbuf.h>\n#include <sys/dnode.h>\n#include <sys/zfs_context.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_traverse.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_pool.h>\n#include <sys/dsl_synctask.h>\n#include <sys/dsl_prop.h>\n#include <sys/dmu_zfetch.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zap.h>\n#include <sys/zio_checksum.h>\n#include <sys/zio_compress.h>\n#include <sys/sa.h>\n#include <sys/zfeature.h>\n#include <sys/abd.h>\n#include <sys/zfs_rlock.h>\n#include <sys/racct.h>\n#include <sys/vm.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vnops.h>\n\n#include <sys/ccompat.h>\n\n#ifndef IDX_TO_OFF\n#define\tIDX_TO_OFF(idx) (((vm_ooffset_t)(idx)) << PAGE_SHIFT)\n#endif\n\n#if  __FreeBSD_version < 1300051\n#define\tVM_ALLOC_BUSY_FLAGS VM_ALLOC_NOBUSY\n#else\n#define\tVM_ALLOC_BUSY_FLAGS  VM_ALLOC_SBUSY | VM_ALLOC_IGN_SBUSY\n#endif\n\n\n#if __FreeBSD_version < 1300072\n#define\tdmu_page_lock(m)\tvm_page_lock(m)\n#define\tdmu_page_unlock(m)\tvm_page_unlock(m)\n#else\n#define\tdmu_page_lock(m)\n#define\tdmu_page_unlock(m)\n#endif\n\nint\ndmu_write_pages(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,\n    vm_page_t *ma, dmu_tx_t *tx)\n{\n\tdmu_buf_t **dbp;\n\tstruct sf_buf *sf;\n\tint numbufs, i;\n\tint err;\n\n\tif (size == 0)\n\t\treturn (0);\n\n\terr = dmu_buf_hold_array(os, object, offset, size,\n\t    FALSE, FTAG, &numbufs, &dbp);\n\tif (err)\n\t\treturn (err);\n\n\tfor (i = 0; i < numbufs; i++) {\n\t\tint tocpy, copied, thiscpy;\n\t\tint bufoff;\n\t\tdmu_buf_t *db = dbp[i];\n\t\tcaddr_t va;\n\n\t\tASSERT3U(size, >, 0);\n\t\tASSERT3U(db->db_size, >=, PAGESIZE);\n\n\t\tbufoff = offset - db->db_offset;\n\t\ttocpy = (int)MIN(db->db_size - bufoff, size);\n\n\t\tASSERT(i == 0 || i == numbufs-1 || tocpy == db->db_size);\n\n\t\tif (tocpy == db->db_size)\n\t\t\tdmu_buf_will_fill(db, tx);\n\t\telse\n\t\t\tdmu_buf_will_dirty(db, tx);\n\n\t\tfor (copied = 0; copied < tocpy; copied += PAGESIZE) {\n\t\t\tASSERT3U(ptoa((*ma)->pindex), ==,\n\t\t\t    db->db_offset + bufoff);\n\t\t\tthiscpy = MIN(PAGESIZE, tocpy - copied);\n\t\t\tva = zfs_map_page(*ma, &sf);\n\t\t\tmemcpy((char *)db->db_data + bufoff, va, thiscpy);\n\t\t\tzfs_unmap_page(sf);\n\t\t\tma += 1;\n\t\t\tbufoff += PAGESIZE;\n\t\t}\n\n\t\tif (tocpy == db->db_size)\n\t\t\tdmu_buf_fill_done(db, tx);\n\n\t\toffset += tocpy;\n\t\tsize -= tocpy;\n\t}\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\treturn (err);\n}\n\nint\ndmu_read_pages(objset_t *os, uint64_t object, vm_page_t *ma, int count,\n    int *rbehind, int *rahead, int last_size)\n{\n\tstruct sf_buf *sf;\n\tvm_object_t vmobj;\n\tvm_page_t m;\n\tdmu_buf_t **dbp;\n\tdmu_buf_t *db;\n\tcaddr_t va;\n\tint numbufs, i;\n\tint bufoff, pgoff, tocpy;\n\tint mi, di;\n\tint err;\n\n\tASSERT3U(ma[0]->pindex + count - 1, ==, ma[count - 1]->pindex);\n\tASSERT3S(last_size, <=, PAGE_SIZE);\n\n\terr = dmu_buf_hold_array(os, object, IDX_TO_OFF(ma[0]->pindex),\n\t    IDX_TO_OFF(count - 1) + last_size, TRUE, FTAG, &numbufs, &dbp);\n\tif (err != 0)\n\t\treturn (err);\n\n#ifdef ZFS_DEBUG\n\tIMPLY(last_size < PAGE_SIZE, *rahead == 0);\n\tif (dbp[0]->db_offset != 0 || numbufs > 1) {\n\t\tfor (i = 0; i < numbufs; i++) {\n\t\t\tASSERT(ISP2(dbp[i]->db_size));\n\t\t\tASSERT3U((dbp[i]->db_offset % dbp[i]->db_size), ==, 0);\n\t\t\tASSERT3U(dbp[i]->db_size, ==, dbp[0]->db_size);\n\t\t}\n\t}\n#endif\n\n\tvmobj = ma[0]->object;\n\tzfs_vmobject_wlock_12(vmobj);\n\n\tdb = dbp[0];\n\tfor (i = 0; i < *rbehind; i++) {\n\t\tm = vm_page_grab_unlocked(vmobj, ma[0]->pindex - 1 - i,\n\t\t    VM_ALLOC_NORMAL | VM_ALLOC_NOWAIT | VM_ALLOC_BUSY_FLAGS);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tif (!vm_page_none_valid(m)) {\n\t\t\tASSERT3U(m->valid, ==, VM_PAGE_BITS_ALL);\n\t\t\tvm_page_do_sunbusy(m);\n\t\t\tbreak;\n\t\t}\n\t\tASSERT3U(m->dirty, ==, 0);\n\t\tASSERT(!pmap_page_is_write_mapped(m));\n\n\t\tASSERT3U(db->db_size, >, PAGE_SIZE);\n\t\tbufoff = IDX_TO_OFF(m->pindex) % db->db_size;\n\t\tva = zfs_map_page(m, &sf);\n\t\tmemcpy(va, (char *)db->db_data + bufoff, PAGESIZE);\n\t\tzfs_unmap_page(sf);\n\t\tvm_page_valid(m);\n\t\tdmu_page_lock(m);\n\t\tif ((m->busy_lock & VPB_BIT_WAITERS) != 0)\n\t\t\tvm_page_activate(m);\n\t\telse\n\t\t\tvm_page_deactivate(m);\n\t\tdmu_page_unlock(m);\n\t\tvm_page_do_sunbusy(m);\n\t}\n\t*rbehind = i;\n\n\tbufoff = IDX_TO_OFF(ma[0]->pindex) % db->db_size;\n\tpgoff = 0;\n\tfor (mi = 0, di = 0; mi < count && di < numbufs; ) {\n\t\tif (pgoff == 0) {\n\t\t\tm = ma[mi];\n\t\t\tif (m != bogus_page) {\n\t\t\t\tvm_page_assert_xbusied(m);\n\t\t\t\tASSERT(vm_page_none_valid(m));\n\t\t\t\tASSERT3U(m->dirty, ==, 0);\n\t\t\t\tASSERT(!pmap_page_is_write_mapped(m));\n\t\t\t\tva = zfs_map_page(m, &sf);\n\t\t\t}\n\t\t}\n\t\tif (bufoff == 0)\n\t\t\tdb = dbp[di];\n\n\t\tif (m != bogus_page) {\n\t\t\tASSERT3U(IDX_TO_OFF(m->pindex) + pgoff, ==,\n\t\t\t    db->db_offset + bufoff);\n\t\t}\n\n\t\t \n\t\ttocpy = MIN(db->db_size - bufoff, PAGESIZE - pgoff);\n\t\tASSERT3S(tocpy, >=, 0);\n\t\tif (m != bogus_page)\n\t\t\tmemcpy(va + pgoff, (char *)db->db_data + bufoff, tocpy);\n\n\t\tpgoff += tocpy;\n\t\tASSERT3S(pgoff, >=, 0);\n\t\tASSERT3S(pgoff, <=, PAGESIZE);\n\t\tif (pgoff == PAGESIZE) {\n\t\t\tif (m != bogus_page) {\n\t\t\t\tzfs_unmap_page(sf);\n\t\t\t\tvm_page_valid(m);\n\t\t\t}\n\t\t\tASSERT3S(mi, <, count);\n\t\t\tmi++;\n\t\t\tpgoff = 0;\n\t\t}\n\n\t\tbufoff += tocpy;\n\t\tASSERT3S(bufoff, >=, 0);\n\t\tASSERT3S(bufoff, <=, db->db_size);\n\t\tif (bufoff == db->db_size) {\n\t\t\tASSERT3S(di, <, numbufs);\n\t\t\tdi++;\n\t\t\tbufoff = 0;\n\t\t}\n\t}\n\n#ifdef ZFS_DEBUG\n\t \n\tif (mi == count) {\n\t\tASSERT3S(di, >=, numbufs - 1);\n\t\tIMPLY(*rahead != 0, di == numbufs - 1);\n\t\tIMPLY(*rahead != 0, bufoff != 0);\n\t\tASSERT0(pgoff);\n\t}\n\tif (di == numbufs) {\n\t\tASSERT3S(mi, >=, count - 1);\n\t\tASSERT0(*rahead);\n\t\tIMPLY(pgoff == 0, mi == count);\n\t\tif (pgoff != 0) {\n\t\t\tASSERT3S(mi, ==, count - 1);\n\t\t\tASSERT3U((dbp[0]->db_size & PAGE_MASK), !=, 0);\n\t\t}\n\t}\n#endif\n\tif (pgoff != 0) {\n\t\tASSERT3P(m, !=, bogus_page);\n\t\tmemset(va + pgoff, 0, PAGESIZE - pgoff);\n\t\tzfs_unmap_page(sf);\n\t\tvm_page_valid(m);\n\t}\n\n\tfor (i = 0; i < *rahead; i++) {\n\t\tm = vm_page_grab_unlocked(vmobj, ma[count - 1]->pindex + 1 + i,\n\t\t    VM_ALLOC_NORMAL | VM_ALLOC_NOWAIT | VM_ALLOC_BUSY_FLAGS);\n\t\tif (m == NULL)\n\t\t\tbreak;\n\t\tif (!vm_page_none_valid(m)) {\n\t\t\tASSERT3U(m->valid, ==, VM_PAGE_BITS_ALL);\n\t\t\tvm_page_do_sunbusy(m);\n\t\t\tbreak;\n\t\t}\n\t\tASSERT3U(m->dirty, ==, 0);\n\t\tASSERT(!pmap_page_is_write_mapped(m));\n\n\t\tASSERT3U(db->db_size, >, PAGE_SIZE);\n\t\tbufoff = IDX_TO_OFF(m->pindex) % db->db_size;\n\t\ttocpy = MIN(db->db_size - bufoff, PAGESIZE);\n\t\tva = zfs_map_page(m, &sf);\n\t\tmemcpy(va, (char *)db->db_data + bufoff, tocpy);\n\t\tif (tocpy < PAGESIZE) {\n\t\t\tASSERT3S(i, ==, *rahead - 1);\n\t\t\tASSERT3U((db->db_size & PAGE_MASK), !=, 0);\n\t\t\tmemset(va + tocpy, 0, PAGESIZE - tocpy);\n\t\t}\n\t\tzfs_unmap_page(sf);\n\t\tvm_page_valid(m);\n\t\tdmu_page_lock(m);\n\t\tif ((m->busy_lock & VPB_BIT_WAITERS) != 0)\n\t\t\tvm_page_activate(m);\n\t\telse\n\t\t\tvm_page_deactivate(m);\n\t\tdmu_page_unlock(m);\n\t\tvm_page_do_sunbusy(m);\n\t}\n\t*rahead = i;\n\tzfs_vmobject_wunlock_12(vmobj);\n\n\tdmu_buf_rele_array(dbp, numbufs, FTAG);\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}