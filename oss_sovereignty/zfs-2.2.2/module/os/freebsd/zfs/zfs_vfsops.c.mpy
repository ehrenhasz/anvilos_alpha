{
  "module_name": "zfs_vfsops.c",
  "hash_id": "b7fe051daef215783fbf5e6e4822d1ce78f9a546bff9ec83486c0ffb5a1d9949",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_vfsops.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/systm.h>\n#include <sys/kernel.h>\n#include <sys/sysmacros.h>\n#include <sys/kmem.h>\n#include <sys/acl.h>\n#include <sys/vnode.h>\n#include <sys/vfs.h>\n#include <sys/mntent.h>\n#include <sys/mount.h>\n#include <sys/cmn_err.h>\n#include <sys/zfs_znode.h>\n#include <sys/zfs_vnops.h>\n#include <sys/zfs_dir.h>\n#include <sys/zil.h>\n#include <sys/fs/zfs.h>\n#include <sys/dmu.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_deleg.h>\n#include <sys/spa.h>\n#include <sys/zap.h>\n#include <sys/sa.h>\n#include <sys/sa_impl.h>\n#include <sys/policy.h>\n#include <sys/atomic.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_fuid.h>\n#include <sys/sunddi.h>\n#include <sys/dmu_objset.h>\n#include <sys/dsl_dir.h>\n#include <sys/jail.h>\n#include <sys/osd.h>\n#include <ufs/ufs/quota.h>\n#include <sys/zfs_quota.h>\n\n#include \"zfs_comutil.h\"\n\n#ifndef\tMNTK_VMSETSIZE_BUG\n#define\tMNTK_VMSETSIZE_BUG\t0\n#endif\n#ifndef\tMNTK_NOMSYNC\n#define\tMNTK_NOMSYNC\t8\n#endif\n\nstruct mtx zfs_debug_mtx;\nMTX_SYSINIT(zfs_debug_mtx, &zfs_debug_mtx, \"zfs_debug\", MTX_DEF);\n\nSYSCTL_NODE(_vfs, OID_AUTO, zfs, CTLFLAG_RW, 0, \"ZFS file system\");\n\nint zfs_super_owner;\nSYSCTL_INT(_vfs_zfs, OID_AUTO, super_owner, CTLFLAG_RW, &zfs_super_owner, 0,\n\t\"File system owners can perform privileged operation on file systems\");\n\nint zfs_debug_level;\nSYSCTL_INT(_vfs_zfs, OID_AUTO, debug, CTLFLAG_RWTUN, &zfs_debug_level, 0,\n\t\"Debug level\");\n\nint zfs_bclone_enabled = 0;\nSYSCTL_INT(_vfs_zfs, OID_AUTO, bclone_enabled, CTLFLAG_RWTUN,\n\t&zfs_bclone_enabled, 0, \"Enable block cloning\");\n\nstruct zfs_jailparam {\n\tint mount_snapshot;\n};\n\nstatic struct zfs_jailparam zfs_jailparam0 = {\n\t.mount_snapshot = 0,\n};\n\nstatic int zfs_jailparam_slot;\n\nSYSCTL_JAIL_PARAM_SYS_NODE(zfs, CTLFLAG_RW, \"Jail ZFS parameters\");\nSYSCTL_JAIL_PARAM(_zfs, mount_snapshot, CTLTYPE_INT | CTLFLAG_RW, \"I\",\n\t\"Allow mounting snapshots in the .zfs directory for unjailed datasets\");\n\nSYSCTL_NODE(_vfs_zfs, OID_AUTO, version, CTLFLAG_RD, 0, \"ZFS versions\");\nstatic int zfs_version_acl = ZFS_ACL_VERSION;\nSYSCTL_INT(_vfs_zfs_version, OID_AUTO, acl, CTLFLAG_RD, &zfs_version_acl, 0,\n\t\"ZFS_ACL_VERSION\");\nstatic int zfs_version_spa = SPA_VERSION;\nSYSCTL_INT(_vfs_zfs_version, OID_AUTO, spa, CTLFLAG_RD, &zfs_version_spa, 0,\n\t\"SPA_VERSION\");\nstatic int zfs_version_zpl = ZPL_VERSION;\nSYSCTL_INT(_vfs_zfs_version, OID_AUTO, zpl, CTLFLAG_RD, &zfs_version_zpl, 0,\n\t\"ZPL_VERSION\");\n\n#if __FreeBSD_version >= 1400018\nstatic int zfs_quotactl(vfs_t *vfsp, int cmds, uid_t id, void *arg,\n    bool *mp_busy);\n#else\nstatic int zfs_quotactl(vfs_t *vfsp, int cmds, uid_t id, void *arg);\n#endif\nstatic int zfs_mount(vfs_t *vfsp);\nstatic int zfs_umount(vfs_t *vfsp, int fflag);\nstatic int zfs_root(vfs_t *vfsp, int flags, vnode_t **vpp);\nstatic int zfs_statfs(vfs_t *vfsp, struct statfs *statp);\nstatic int zfs_vget(vfs_t *vfsp, ino_t ino, int flags, vnode_t **vpp);\nstatic int zfs_sync(vfs_t *vfsp, int waitfor);\n#if __FreeBSD_version >= 1300098\nstatic int zfs_checkexp(vfs_t *vfsp, struct sockaddr *nam, uint64_t *extflagsp,\n    struct ucred **credanonp, int *numsecflavors, int *secflavors);\n#else\nstatic int zfs_checkexp(vfs_t *vfsp, struct sockaddr *nam, int *extflagsp,\n    struct ucred **credanonp, int *numsecflavors, int **secflavors);\n#endif\nstatic int zfs_fhtovp(vfs_t *vfsp, fid_t *fidp, int flags, vnode_t **vpp);\nstatic void zfs_freevfs(vfs_t *vfsp);\n\nstruct vfsops zfs_vfsops = {\n\t.vfs_mount =\t\tzfs_mount,\n\t.vfs_unmount =\t\tzfs_umount,\n#if __FreeBSD_version >= 1300049\n\t.vfs_root =\t\tvfs_cache_root,\n\t.vfs_cachedroot = zfs_root,\n#else\n\t.vfs_root =\t\tzfs_root,\n#endif\n\t.vfs_statfs =\t\tzfs_statfs,\n\t.vfs_vget =\t\tzfs_vget,\n\t.vfs_sync =\t\tzfs_sync,\n\t.vfs_checkexp =\t\tzfs_checkexp,\n\t.vfs_fhtovp =\t\tzfs_fhtovp,\n\t.vfs_quotactl =\t\tzfs_quotactl,\n};\n\n#ifdef VFCF_CROSS_COPY_FILE_RANGE\nVFS_SET(zfs_vfsops, zfs,\n    VFCF_DELEGADMIN | VFCF_JAIL | VFCF_CROSS_COPY_FILE_RANGE);\n#else\nVFS_SET(zfs_vfsops, zfs, VFCF_DELEGADMIN | VFCF_JAIL);\n#endif\n\n \nstatic uint32_t\tzfs_active_fs_count = 0;\n\nint\nzfs_get_temporary_prop(dsl_dataset_t *ds, zfs_prop_t zfs_prop, uint64_t *val,\n    char *setpoint)\n{\n\tint error;\n\tzfsvfs_t *zfvp;\n\tvfs_t *vfsp;\n\tobjset_t *os;\n\tuint64_t tmp = *val;\n\n\terror = dmu_objset_from_ds(ds, &os);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = getzfsvfs_impl(os, &zfvp);\n\tif (error != 0)\n\t\treturn (error);\n\tif (zfvp == NULL)\n\t\treturn (ENOENT);\n\tvfsp = zfvp->z_vfs;\n\tswitch (zfs_prop) {\n\tcase ZFS_PROP_ATIME:\n\t\tif (vfs_optionisset(vfsp, MNTOPT_NOATIME, NULL))\n\t\t\ttmp = 0;\n\t\tif (vfs_optionisset(vfsp, MNTOPT_ATIME, NULL))\n\t\t\ttmp = 1;\n\t\tbreak;\n\tcase ZFS_PROP_DEVICES:\n\t\tif (vfs_optionisset(vfsp, MNTOPT_NODEVICES, NULL))\n\t\t\ttmp = 0;\n\t\tif (vfs_optionisset(vfsp, MNTOPT_DEVICES, NULL))\n\t\t\ttmp = 1;\n\t\tbreak;\n\tcase ZFS_PROP_EXEC:\n\t\tif (vfs_optionisset(vfsp, MNTOPT_NOEXEC, NULL))\n\t\t\ttmp = 0;\n\t\tif (vfs_optionisset(vfsp, MNTOPT_EXEC, NULL))\n\t\t\ttmp = 1;\n\t\tbreak;\n\tcase ZFS_PROP_SETUID:\n\t\tif (vfs_optionisset(vfsp, MNTOPT_NOSETUID, NULL))\n\t\t\ttmp = 0;\n\t\tif (vfs_optionisset(vfsp, MNTOPT_SETUID, NULL))\n\t\t\ttmp = 1;\n\t\tbreak;\n\tcase ZFS_PROP_READONLY:\n\t\tif (vfs_optionisset(vfsp, MNTOPT_RW, NULL))\n\t\t\ttmp = 0;\n\t\tif (vfs_optionisset(vfsp, MNTOPT_RO, NULL))\n\t\t\ttmp = 1;\n\t\tbreak;\n\tcase ZFS_PROP_XATTR:\n\t\tif (zfvp->z_flags & ZSB_XATTR)\n\t\t\ttmp = zfvp->z_xattr;\n\t\tbreak;\n\tcase ZFS_PROP_NBMAND:\n\t\tif (vfs_optionisset(vfsp, MNTOPT_NONBMAND, NULL))\n\t\t\ttmp = 0;\n\t\tif (vfs_optionisset(vfsp, MNTOPT_NBMAND, NULL))\n\t\t\ttmp = 1;\n\t\tbreak;\n\tdefault:\n\t\tvfs_unbusy(vfsp);\n\t\treturn (ENOENT);\n\t}\n\n\tvfs_unbusy(vfsp);\n\tif (tmp != *val) {\n\t\tif (setpoint)\n\t\t\t(void) strcpy(setpoint, \"temporary\");\n\t\t*val = tmp;\n\t}\n\treturn (0);\n}\n\nstatic int\nzfs_getquota(zfsvfs_t *zfsvfs, uid_t id, int isgroup, struct dqblk64 *dqp)\n{\n\tint error = 0;\n\tchar buf[32];\n\tuint64_t usedobj, quotaobj;\n\tuint64_t quota, used = 0;\n\ttimespec_t now;\n\n\tusedobj = isgroup ? DMU_GROUPUSED_OBJECT : DMU_USERUSED_OBJECT;\n\tquotaobj = isgroup ? zfsvfs->z_groupquota_obj : zfsvfs->z_userquota_obj;\n\n\tif (quotaobj == 0 || zfsvfs->z_replay) {\n\t\terror = ENOENT;\n\t\tgoto done;\n\t}\n\t(void) sprintf(buf, \"%llx\", (longlong_t)id);\n\tif ((error = zap_lookup(zfsvfs->z_os, quotaobj,\n\t    buf, sizeof (quota), 1, &quota)) != 0) {\n\t\tdprintf(\"%s(%d): quotaobj lookup failed\\n\",\n\t\t    __FUNCTION__, __LINE__);\n\t\tgoto done;\n\t}\n\t \n\tdqp->dqb_bsoftlimit = dqp->dqb_bhardlimit = btodb(quota);\n\terror = zap_lookup(zfsvfs->z_os, usedobj, buf, sizeof (used), 1, &used);\n\tif (error && error != ENOENT) {\n\t\tdprintf(\"%s(%d):  usedobj failed; %d\\n\",\n\t\t    __FUNCTION__, __LINE__, error);\n\t\tgoto done;\n\t}\n\tdqp->dqb_curblocks = btodb(used);\n\tdqp->dqb_ihardlimit = dqp->dqb_isoftlimit = 0;\n\tvfs_timestamp(&now);\n\t \n\tdqp->dqb_btime = dqp->dqb_itime = now.tv_sec;\ndone:\n\treturn (error);\n}\n\nstatic int\n#if __FreeBSD_version >= 1400018\nzfs_quotactl(vfs_t *vfsp, int cmds, uid_t id, void *arg, bool *mp_busy)\n#else\nzfs_quotactl(vfs_t *vfsp, int cmds, uid_t id, void *arg)\n#endif\n{\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\tstruct thread *td;\n\tint cmd, type, error = 0;\n\tint bitsize;\n\tzfs_userquota_prop_t quota_type;\n\tstruct dqblk64 dqblk = { 0 };\n\n\ttd = curthread;\n\tcmd = cmds >> SUBCMDSHIFT;\n\ttype = cmds & SUBCMDMASK;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\tif (id == -1) {\n\t\tswitch (type) {\n\t\tcase USRQUOTA:\n\t\t\tid = td->td_ucred->cr_ruid;\n\t\t\tbreak;\n\t\tcase GRPQUOTA:\n\t\t\tid = td->td_ucred->cr_rgid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n#if __FreeBSD_version < 1400018\n\t\t\tif (cmd == Q_QUOTAON || cmd == Q_QUOTAOFF)\n\t\t\t\tvfs_unbusy(vfsp);\n#endif\n\t\t\tgoto done;\n\t\t}\n\t}\n\t \n\tswitch (cmd) {\n\tcase Q_SETQUOTA:\n\tcase Q_SETQUOTA32:\n\t\tif (type == USRQUOTA)\n\t\t\tquota_type = ZFS_PROP_USERQUOTA;\n\t\telse if (type == GRPQUOTA)\n\t\t\tquota_type = ZFS_PROP_GROUPQUOTA;\n\t\telse\n\t\t\terror = EINVAL;\n\t\tbreak;\n\tcase Q_GETQUOTA:\n\tcase Q_GETQUOTA32:\n\t\tif (type == USRQUOTA)\n\t\t\tquota_type = ZFS_PROP_USERUSED;\n\t\telse if (type == GRPQUOTA)\n\t\t\tquota_type = ZFS_PROP_GROUPUSED;\n\t\telse\n\t\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif ((uint32_t)type >= MAXQUOTAS) {\n\t\terror = EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (cmd) {\n\tcase Q_GETQUOTASIZE:\n\t\tbitsize = 64;\n\t\terror = copyout(&bitsize, arg, sizeof (int));\n\t\tbreak;\n\tcase Q_QUOTAON:\n\t\t\n\t\terror = 0;\n#if __FreeBSD_version < 1400018\n\t\tvfs_unbusy(vfsp);\n#endif\n\t\tbreak;\n\tcase Q_QUOTAOFF:\n\t\terror = ENOTSUP;\n#if __FreeBSD_version < 1400018\n\t\tvfs_unbusy(vfsp);\n#endif\n\t\tbreak;\n\tcase Q_SETQUOTA:\n\t\terror = copyin(arg, &dqblk, sizeof (dqblk));\n\t\tif (error == 0)\n\t\t\terror = zfs_set_userquota(zfsvfs, quota_type,\n\t\t\t    \"\", id, dbtob(dqblk.dqb_bhardlimit));\n\t\tbreak;\n\tcase Q_GETQUOTA:\n\t\terror = zfs_getquota(zfsvfs, id, type == GRPQUOTA, &dqblk);\n\t\tif (error == 0)\n\t\t\terror = copyout(&dqblk, arg, sizeof (dqblk));\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (error);\n}\n\n\nboolean_t\nzfs_is_readonly(zfsvfs_t *zfsvfs)\n{\n\treturn (!!(zfsvfs->z_vfs->vfs_flag & VFS_RDONLY));\n}\n\nstatic int\nzfs_sync(vfs_t *vfsp, int waitfor)\n{\n\n\t \n\tif (panicstr)\n\t\treturn (0);\n\n\t \n\tif (waitfor == MNT_LAZY)\n\t\treturn (0);\n\n\tif (vfsp != NULL) {\n\t\t \n\t\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\t\tdsl_pool_t *dp;\n\t\tint error;\n\n\t\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\t\treturn (error);\n\t\tdp = dmu_objset_pool(zfsvfs->z_os);\n\n\t\t \n\t\tif (rebooting && spa_suspended(dp->dp_spa)) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (0);\n\t\t}\n\n\t\tif (zfsvfs->z_log != NULL)\n\t\t\tzil_commit(zfsvfs->z_log, 0);\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\t} else {\n\t\t \n\t\tspa_sync_allpools();\n\t}\n\n\treturn (0);\n}\n\nstatic void\natime_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tif (newval == TRUE) {\n\t\tzfsvfs->z_atime = TRUE;\n\t\tzfsvfs->z_vfs->vfs_flag &= ~MNT_NOATIME;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_NOATIME);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_ATIME, NULL, 0);\n\t} else {\n\t\tzfsvfs->z_atime = FALSE;\n\t\tzfsvfs->z_vfs->vfs_flag |= MNT_NOATIME;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_ATIME);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_NOATIME, NULL, 0);\n\t}\n}\n\nstatic void\nxattr_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tif (newval == ZFS_XATTR_OFF) {\n\t\tzfsvfs->z_flags &= ~ZSB_XATTR;\n\t} else {\n\t\tzfsvfs->z_flags |= ZSB_XATTR;\n\n\t\tif (newval == ZFS_XATTR_SA)\n\t\t\tzfsvfs->z_xattr_sa = B_TRUE;\n\t\telse\n\t\t\tzfsvfs->z_xattr_sa = B_FALSE;\n\t}\n}\n\nstatic void\nblksz_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tASSERT3U(newval, <=, spa_maxblocksize(dmu_objset_spa(zfsvfs->z_os)));\n\tASSERT3U(newval, >=, SPA_MINBLOCKSIZE);\n\tASSERT(ISP2(newval));\n\n\tzfsvfs->z_max_blksz = newval;\n\tzfsvfs->z_vfs->mnt_stat.f_iosize = newval;\n}\n\nstatic void\nreadonly_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tif (newval) {\n\t\t \n\t\tzfsvfs->z_vfs->vfs_flag |= VFS_RDONLY;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_RW);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_RO, NULL, 0);\n\t} else {\n\t\t \n\t\tzfsvfs->z_vfs->vfs_flag &= ~VFS_RDONLY;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_RO);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_RW, NULL, 0);\n\t}\n}\n\nstatic void\nsetuid_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tif (newval == FALSE) {\n\t\tzfsvfs->z_vfs->vfs_flag |= VFS_NOSETUID;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_SETUID);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_NOSETUID, NULL, 0);\n\t} else {\n\t\tzfsvfs->z_vfs->vfs_flag &= ~VFS_NOSETUID;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_NOSETUID);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_SETUID, NULL, 0);\n\t}\n}\n\nstatic void\nexec_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tif (newval == FALSE) {\n\t\tzfsvfs->z_vfs->vfs_flag |= VFS_NOEXEC;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_EXEC);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_NOEXEC, NULL, 0);\n\t} else {\n\t\tzfsvfs->z_vfs->vfs_flag &= ~VFS_NOEXEC;\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_NOEXEC);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_EXEC, NULL, 0);\n\t}\n}\n\n \nstatic void\nnbmand_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\tif (newval == FALSE) {\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_NBMAND);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_NONBMAND, NULL, 0);\n\t} else {\n\t\tvfs_clearmntopt(zfsvfs->z_vfs, MNTOPT_NONBMAND);\n\t\tvfs_setmntopt(zfsvfs->z_vfs, MNTOPT_NBMAND, NULL, 0);\n\t}\n}\n\nstatic void\nsnapdir_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tzfsvfs->z_show_ctldir = newval;\n}\n\nstatic void\nacl_mode_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tzfsvfs->z_acl_mode = newval;\n}\n\nstatic void\nacl_inherit_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tzfsvfs->z_acl_inherit = newval;\n}\n\nstatic void\nacl_type_changed_cb(void *arg, uint64_t newval)\n{\n\tzfsvfs_t *zfsvfs = arg;\n\n\tzfsvfs->z_acl_type = newval;\n}\n\nstatic int\nzfs_register_callbacks(vfs_t *vfsp)\n{\n\tstruct dsl_dataset *ds = NULL;\n\tobjset_t *os = NULL;\n\tzfsvfs_t *zfsvfs = NULL;\n\tuint64_t nbmand;\n\tboolean_t readonly = B_FALSE;\n\tboolean_t do_readonly = B_FALSE;\n\tboolean_t setuid = B_FALSE;\n\tboolean_t do_setuid = B_FALSE;\n\tboolean_t exec = B_FALSE;\n\tboolean_t do_exec = B_FALSE;\n\tboolean_t xattr = B_FALSE;\n\tboolean_t atime = B_FALSE;\n\tboolean_t do_atime = B_FALSE;\n\tboolean_t do_xattr = B_FALSE;\n\tint error = 0;\n\n\tASSERT3P(vfsp, !=, NULL);\n\tzfsvfs = vfsp->vfs_data;\n\tASSERT3P(zfsvfs, !=, NULL);\n\tos = zfsvfs->z_os;\n\n\t \n\tif (dmu_objset_is_snapshot(os))\n\t\treturn (EOPNOTSUPP);\n\n\t \n\tif (vfs_optionisset(vfsp, MNTOPT_RO, NULL) ||\n\t    !spa_writeable(dmu_objset_spa(os))) {\n\t\treadonly = B_TRUE;\n\t\tdo_readonly = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_RW, NULL)) {\n\t\treadonly = B_FALSE;\n\t\tdo_readonly = B_TRUE;\n\t}\n\tif (vfs_optionisset(vfsp, MNTOPT_NOSETUID, NULL)) {\n\t\tsetuid = B_FALSE;\n\t\tdo_setuid = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_SETUID, NULL)) {\n\t\tsetuid = B_TRUE;\n\t\tdo_setuid = B_TRUE;\n\t}\n\tif (vfs_optionisset(vfsp, MNTOPT_NOEXEC, NULL)) {\n\t\texec = B_FALSE;\n\t\tdo_exec = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_EXEC, NULL)) {\n\t\texec = B_TRUE;\n\t\tdo_exec = B_TRUE;\n\t}\n\tif (vfs_optionisset(vfsp, MNTOPT_NOXATTR, NULL)) {\n\t\tzfsvfs->z_xattr = xattr = ZFS_XATTR_OFF;\n\t\tdo_xattr = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_XATTR, NULL)) {\n\t\tzfsvfs->z_xattr = xattr = ZFS_XATTR_DIR;\n\t\tdo_xattr = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_DIRXATTR, NULL)) {\n\t\tzfsvfs->z_xattr = xattr = ZFS_XATTR_DIR;\n\t\tdo_xattr = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_SAXATTR, NULL)) {\n\t\tzfsvfs->z_xattr = xattr = ZFS_XATTR_SA;\n\t\tdo_xattr = B_TRUE;\n\t}\n\tif (vfs_optionisset(vfsp, MNTOPT_NOATIME, NULL)) {\n\t\tatime = B_FALSE;\n\t\tdo_atime = B_TRUE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_ATIME, NULL)) {\n\t\tatime = B_TRUE;\n\t\tdo_atime = B_TRUE;\n\t}\n\n\t \n\tds = dmu_objset_ds(os);\n\tdsl_pool_config_enter(dmu_objset_pool(os), FTAG);\n\n\t \n\tif (vfs_optionisset(vfsp, MNTOPT_NONBMAND, NULL)) {\n\t\tnbmand = B_FALSE;\n\t} else if (vfs_optionisset(vfsp, MNTOPT_NBMAND, NULL)) {\n\t\tnbmand = B_TRUE;\n\t} else if ((error = dsl_prop_get_int_ds(ds, \"nbmand\", &nbmand)) != 0) {\n\t\tdsl_pool_config_exit(dmu_objset_pool(os), FTAG);\n\t\treturn (error);\n\t}\n\n\t \n\terror = dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ATIME), atime_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_XATTR), xattr_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_RECORDSIZE), blksz_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_READONLY), readonly_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_SETUID), setuid_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_EXEC), exec_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_SNAPDIR), snapdir_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ACLTYPE), acl_type_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ACLMODE), acl_mode_changed_cb, zfsvfs);\n\terror = error ? error : dsl_prop_register(ds,\n\t    zfs_prop_to_name(ZFS_PROP_ACLINHERIT), acl_inherit_changed_cb,\n\t    zfsvfs);\n\tdsl_pool_config_exit(dmu_objset_pool(os), FTAG);\n\tif (error)\n\t\tgoto unregister;\n\n\t \n\tif (do_readonly)\n\t\treadonly_changed_cb(zfsvfs, readonly);\n\tif (do_setuid)\n\t\tsetuid_changed_cb(zfsvfs, setuid);\n\tif (do_exec)\n\t\texec_changed_cb(zfsvfs, exec);\n\tif (do_xattr)\n\t\txattr_changed_cb(zfsvfs, xattr);\n\tif (do_atime)\n\t\tatime_changed_cb(zfsvfs, atime);\n\n\tnbmand_changed_cb(zfsvfs, nbmand);\n\n\treturn (0);\n\nunregister:\n\tdsl_prop_unregister_all(ds, zfsvfs);\n\treturn (error);\n}\n\n \nstatic int\nzfsvfs_init(zfsvfs_t *zfsvfs, objset_t *os)\n{\n\tint error;\n\tuint64_t val;\n\n\tzfsvfs->z_max_blksz = SPA_OLD_MAXBLOCKSIZE;\n\tzfsvfs->z_show_ctldir = ZFS_SNAPDIR_VISIBLE;\n\tzfsvfs->z_os = os;\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_VERSION, &zfsvfs->z_version);\n\tif (error != 0)\n\t\treturn (error);\n\tif (zfsvfs->z_version >\n\t    zfs_zpl_version_map(spa_version(dmu_objset_spa(os)))) {\n\t\t(void) printf(\"Can't mount a version %lld file system \"\n\t\t    \"on a version %lld pool\\n. Pool must be upgraded to mount \"\n\t\t    \"this file system.\", (u_longlong_t)zfsvfs->z_version,\n\t\t    (u_longlong_t)spa_version(dmu_objset_spa(os)));\n\t\treturn (SET_ERROR(ENOTSUP));\n\t}\n\terror = zfs_get_zplprop(os, ZFS_PROP_NORMALIZE, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_norm = (int)val;\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_UTF8ONLY, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_utf8 = (val != 0);\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_CASE, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_case = (uint_t)val;\n\n\terror = zfs_get_zplprop(os, ZFS_PROP_ACLTYPE, &val);\n\tif (error != 0)\n\t\treturn (error);\n\tzfsvfs->z_acl_type = (uint_t)val;\n\n\t \n\tif (zfsvfs->z_case == ZFS_CASE_INSENSITIVE ||\n\t    zfsvfs->z_case == ZFS_CASE_MIXED)\n\t\tzfsvfs->z_norm |= U8_TEXTPREP_TOUPPER;\n\n\tzfsvfs->z_use_fuids = USE_FUIDS(zfsvfs->z_version, zfsvfs->z_os);\n\tzfsvfs->z_use_sa = USE_SA(zfsvfs->z_version, zfsvfs->z_os);\n\n\tuint64_t sa_obj = 0;\n\tif (zfsvfs->z_use_sa) {\n\t\t \n\t\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_SA_ATTRS, 8, 1,\n\t\t    &sa_obj);\n\t\tif (error != 0)\n\t\t\treturn (error);\n\n\t\terror = zfs_get_zplprop(os, ZFS_PROP_XATTR, &val);\n\t\tif (error == 0 && val == ZFS_XATTR_SA)\n\t\t\tzfsvfs->z_xattr_sa = B_TRUE;\n\t}\n\n\terror = sa_setup(os, sa_obj, zfs_attr_table, ZPL_END,\n\t    &zfsvfs->z_attr_table);\n\tif (error != 0)\n\t\treturn (error);\n\n\tif (zfsvfs->z_version >= ZPL_VERSION_SA)\n\t\tsa_register_update_callback(os, zfs_sa_upgrade);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_ROOT_OBJ, 8, 1,\n\t    &zfsvfs->z_root);\n\tif (error != 0)\n\t\treturn (error);\n\tASSERT3U(zfsvfs->z_root, !=, 0);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_UNLINKED_SET, 8, 1,\n\t    &zfsvfs->z_unlinkedobj);\n\tif (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_USERQUOTA],\n\t    8, 1, &zfsvfs->z_userquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_userquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_GROUPQUOTA],\n\t    8, 1, &zfsvfs->z_groupquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_groupquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_PROJECTQUOTA],\n\t    8, 1, &zfsvfs->z_projectquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_projectquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_USEROBJQUOTA],\n\t    8, 1, &zfsvfs->z_userobjquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_userobjquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_GROUPOBJQUOTA],\n\t    8, 1, &zfsvfs->z_groupobjquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_groupobjquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ,\n\t    zfs_userquota_prop_prefixes[ZFS_PROP_PROJECTOBJQUOTA],\n\t    8, 1, &zfsvfs->z_projectobjquota_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_projectobjquota_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_FUID_TABLES, 8, 1,\n\t    &zfsvfs->z_fuid_obj);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_fuid_obj = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\terror = zap_lookup(os, MASTER_NODE_OBJ, ZFS_SHARES_DIR, 8, 1,\n\t    &zfsvfs->z_shares_dir);\n\tif (error == ENOENT)\n\t\tzfsvfs->z_shares_dir = 0;\n\telse if (error != 0)\n\t\treturn (error);\n\n\t \n\tzfsvfs->z_use_namecache = !zfsvfs->z_norm ||\n\t    ((zfsvfs->z_case == ZFS_CASE_MIXED) &&\n\t    !(zfsvfs->z_norm & ~U8_TEXTPREP_TOUPPER));\n\n\treturn (0);\n}\n\ntaskq_t *zfsvfs_taskq;\n\nstatic void\nzfsvfs_task_unlinked_drain(void *context, int pending __unused)\n{\n\n\tzfs_unlinked_drain((zfsvfs_t *)context);\n}\n\nint\nzfsvfs_create(const char *osname, boolean_t readonly, zfsvfs_t **zfvp)\n{\n\tobjset_t *os;\n\tzfsvfs_t *zfsvfs;\n\tint error;\n\tboolean_t ro = (readonly || (strchr(osname, '@') != NULL));\n\n\t \n\tif (strlen(osname) >= MNAMELEN)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\tzfsvfs = kmem_zalloc(sizeof (zfsvfs_t), KM_SLEEP);\n\n\terror = dmu_objset_own(osname, DMU_OST_ZFS, ro, B_TRUE, zfsvfs,\n\t    &os);\n\tif (error != 0) {\n\t\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n\t\treturn (error);\n\t}\n\n\terror = zfsvfs_create_impl(zfvp, zfsvfs, os);\n\n\treturn (error);\n}\n\n\nint\nzfsvfs_create_impl(zfsvfs_t **zfvp, zfsvfs_t *zfsvfs, objset_t *os)\n{\n\tint error;\n\n\tzfsvfs->z_vfs = NULL;\n\tzfsvfs->z_parent = zfsvfs;\n\n\tmutex_init(&zfsvfs->z_znodes_lock, NULL, MUTEX_DEFAULT, NULL);\n\tmutex_init(&zfsvfs->z_lock, NULL, MUTEX_DEFAULT, NULL);\n\tlist_create(&zfsvfs->z_all_znodes, sizeof (znode_t),\n\t    offsetof(znode_t, z_link_node));\n\tTASK_INIT(&zfsvfs->z_unlinked_drain_task, 0,\n\t    zfsvfs_task_unlinked_drain, zfsvfs);\n\tZFS_TEARDOWN_INIT(zfsvfs);\n\tZFS_TEARDOWN_INACTIVE_INIT(zfsvfs);\n\trw_init(&zfsvfs->z_fuid_lock, NULL, RW_DEFAULT, NULL);\n\tfor (int i = 0; i != ZFS_OBJ_MTX_SZ; i++)\n\t\tmutex_init(&zfsvfs->z_hold_mtx[i], NULL, MUTEX_DEFAULT, NULL);\n\n\terror = zfsvfs_init(zfsvfs, os);\n\tif (error != 0) {\n\t\tdmu_objset_disown(os, B_TRUE, zfsvfs);\n\t\t*zfvp = NULL;\n\t\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n\t\treturn (error);\n\t}\n\n\t*zfvp = zfsvfs;\n\treturn (0);\n}\n\nstatic int\nzfsvfs_setup(zfsvfs_t *zfsvfs, boolean_t mounting)\n{\n\tint error;\n\n\t \n\tif (!(zfsvfs->z_vfs->vfs_flag & VFS_RDONLY) &&\n\t    dmu_objset_incompatible_encryption_version(zfsvfs->z_os))\n\t\treturn (SET_ERROR(EROFS));\n\n\terror = zfs_register_callbacks(zfsvfs->z_vfs);\n\tif (error)\n\t\treturn (error);\n\n\t \n\tif (mounting) {\n\t\tboolean_t readonly;\n\n\t\tASSERT3P(zfsvfs->z_kstat.dk_kstats, ==, NULL);\n\t\terror = dataset_kstats_create(&zfsvfs->z_kstat, zfsvfs->z_os);\n\t\tif (error)\n\t\t\treturn (error);\n\t\tzfsvfs->z_log = zil_open(zfsvfs->z_os, zfs_get_data,\n\t\t    &zfsvfs->z_kstat.dk_zil_sums);\n\n\t\t \n\t\treadonly = zfsvfs->z_vfs->vfs_flag & VFS_RDONLY;\n\t\tif (readonly != 0) {\n\t\t\tzfsvfs->z_vfs->vfs_flag &= ~VFS_RDONLY;\n\t\t} else {\n\t\t\tdsl_dir_t *dd;\n\t\t\tzap_stats_t zs;\n\n\t\t\tif (zap_get_stats(zfsvfs->z_os, zfsvfs->z_unlinkedobj,\n\t\t\t    &zs) == 0) {\n\t\t\t\tdataset_kstats_update_nunlinks_kstat(\n\t\t\t\t    &zfsvfs->z_kstat, zs.zs_num_entries);\n\t\t\t\tdprintf_ds(zfsvfs->z_os->os_dsl_dataset,\n\t\t\t\t    \"num_entries in unlinked set: %llu\",\n\t\t\t\t    (u_longlong_t)zs.zs_num_entries);\n\t\t\t}\n\n\t\t\tzfs_unlinked_drain(zfsvfs);\n\t\t\tdd = zfsvfs->z_os->os_dsl_dataset->ds_dir;\n\t\t\tdd->dd_activity_cancelled = B_FALSE;\n\t\t}\n\n\t\t \n\t\tif (spa_writeable(dmu_objset_spa(zfsvfs->z_os))) {\n\t\t\tif (zil_replay_disable) {\n\t\t\t\tzil_destroy(zfsvfs->z_log, B_FALSE);\n\t\t\t} else {\n\t\t\t\tboolean_t use_nc = zfsvfs->z_use_namecache;\n\t\t\t\tzfsvfs->z_use_namecache = B_FALSE;\n\t\t\t\tzfsvfs->z_replay = B_TRUE;\n\t\t\t\tzil_replay(zfsvfs->z_os, zfsvfs,\n\t\t\t\t    zfs_replay_vector);\n\t\t\t\tzfsvfs->z_replay = B_FALSE;\n\t\t\t\tzfsvfs->z_use_namecache = use_nc;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (readonly != 0)\n\t\t\tzfsvfs->z_vfs->vfs_flag |= VFS_RDONLY;\n\t} else {\n\t\tASSERT3P(zfsvfs->z_kstat.dk_kstats, !=, NULL);\n\t\tzfsvfs->z_log = zil_open(zfsvfs->z_os, zfs_get_data,\n\t\t    &zfsvfs->z_kstat.dk_zil_sums);\n\t}\n\n\t \n\tmutex_enter(&zfsvfs->z_os->os_user_ptr_lock);\n\tdmu_objset_set_user(zfsvfs->z_os, zfsvfs);\n\tmutex_exit(&zfsvfs->z_os->os_user_ptr_lock);\n\n\treturn (0);\n}\n\nvoid\nzfsvfs_free(zfsvfs_t *zfsvfs)\n{\n\tint i;\n\n\tzfs_fuid_destroy(zfsvfs);\n\n\tmutex_destroy(&zfsvfs->z_znodes_lock);\n\tmutex_destroy(&zfsvfs->z_lock);\n\tlist_destroy(&zfsvfs->z_all_znodes);\n\tZFS_TEARDOWN_DESTROY(zfsvfs);\n\tZFS_TEARDOWN_INACTIVE_DESTROY(zfsvfs);\n\trw_destroy(&zfsvfs->z_fuid_lock);\n\tfor (i = 0; i != ZFS_OBJ_MTX_SZ; i++)\n\t\tmutex_destroy(&zfsvfs->z_hold_mtx[i]);\n\tdataset_kstats_destroy(&zfsvfs->z_kstat);\n\tkmem_free(zfsvfs, sizeof (zfsvfs_t));\n}\n\nstatic void\nzfs_set_fuid_feature(zfsvfs_t *zfsvfs)\n{\n\tzfsvfs->z_use_fuids = USE_FUIDS(zfsvfs->z_version, zfsvfs->z_os);\n\tzfsvfs->z_use_sa = USE_SA(zfsvfs->z_version, zfsvfs->z_os);\n}\n\nstatic int\nzfs_domount(vfs_t *vfsp, char *osname)\n{\n\tuint64_t recordsize, fsid_guid;\n\tint error = 0;\n\tzfsvfs_t *zfsvfs;\n\n\tASSERT3P(vfsp, !=, NULL);\n\tASSERT3P(osname, !=, NULL);\n\n\terror = zfsvfs_create(osname, vfsp->mnt_flag & MNT_RDONLY, &zfsvfs);\n\tif (error)\n\t\treturn (error);\n\tzfsvfs->z_vfs = vfsp;\n\n\tif ((error = dsl_prop_get_integer(osname,\n\t    \"recordsize\", &recordsize, NULL)))\n\t\tgoto out;\n\tzfsvfs->z_vfs->vfs_bsize = SPA_MINBLOCKSIZE;\n\tzfsvfs->z_vfs->mnt_stat.f_iosize = recordsize;\n\n\tvfsp->vfs_data = zfsvfs;\n\tvfsp->mnt_flag |= MNT_LOCAL;\n\tvfsp->mnt_kern_flag |= MNTK_LOOKUP_SHARED;\n\tvfsp->mnt_kern_flag |= MNTK_SHARED_WRITES;\n\tvfsp->mnt_kern_flag |= MNTK_EXTENDED_SHARED;\n\t \n\tvfsp->mnt_kern_flag |= MNTK_NO_IOPF;\t \n\tvfsp->mnt_kern_flag |= MNTK_NOMSYNC;\n\tvfsp->mnt_kern_flag |= MNTK_VMSETSIZE_BUG;\n\n#if defined(_KERNEL) && !defined(KMEM_DEBUG)\n\tvfsp->mnt_kern_flag |= MNTK_FPLOOKUP;\n#endif\n\t \n\tfsid_guid = dmu_objset_fsid_guid(zfsvfs->z_os);\n\tASSERT3U((fsid_guid & ~((1ULL << 56) - 1)), ==, 0);\n\tvfsp->vfs_fsid.val[0] = fsid_guid;\n\tvfsp->vfs_fsid.val[1] = ((fsid_guid >> 32) << 8) |\n\t    (vfsp->mnt_vfc->vfc_typenum & 0xFF);\n\n\t \n\tzfs_set_fuid_feature(zfsvfs);\n\n\tif (dmu_objset_is_snapshot(zfsvfs->z_os)) {\n\t\tuint64_t pval;\n\n\t\tatime_changed_cb(zfsvfs, B_FALSE);\n\t\treadonly_changed_cb(zfsvfs, B_TRUE);\n\t\tif ((error = dsl_prop_get_integer(osname,\n\t\t    \"xattr\", &pval, NULL)))\n\t\t\tgoto out;\n\t\txattr_changed_cb(zfsvfs, pval);\n\t\tif ((error = dsl_prop_get_integer(osname,\n\t\t    \"acltype\", &pval, NULL)))\n\t\t\tgoto out;\n\t\tacl_type_changed_cb(zfsvfs, pval);\n\t\tzfsvfs->z_issnap = B_TRUE;\n\t\tzfsvfs->z_os->os_sync = ZFS_SYNC_DISABLED;\n\n\t\tmutex_enter(&zfsvfs->z_os->os_user_ptr_lock);\n\t\tdmu_objset_set_user(zfsvfs->z_os, zfsvfs);\n\t\tmutex_exit(&zfsvfs->z_os->os_user_ptr_lock);\n\t} else {\n\t\tif ((error = zfsvfs_setup(zfsvfs, B_TRUE)))\n\t\t\tgoto out;\n\t}\n\n\tvfs_mountedfrom(vfsp, osname);\n\n\tif (!zfsvfs->z_issnap)\n\t\tzfsctl_create(zfsvfs);\nout:\n\tif (error) {\n\t\tdmu_objset_disown(zfsvfs->z_os, B_TRUE, zfsvfs);\n\t\tzfsvfs_free(zfsvfs);\n\t} else {\n\t\tatomic_inc_32(&zfs_active_fs_count);\n\t}\n\n\treturn (error);\n}\n\nstatic void\nzfs_unregister_callbacks(zfsvfs_t *zfsvfs)\n{\n\tobjset_t *os = zfsvfs->z_os;\n\n\tif (!dmu_objset_is_snapshot(os))\n\t\tdsl_prop_unregister_all(dmu_objset_ds(os), zfsvfs);\n}\n\nstatic int\ngetpoolname(const char *osname, char *poolname)\n{\n\tchar *p;\n\n\tp = strchr(osname, '/');\n\tif (p == NULL) {\n\t\tif (strlen(osname) >= MAXNAMELEN)\n\t\t\treturn (ENAMETOOLONG);\n\t\t(void) strcpy(poolname, osname);\n\t} else {\n\t\tif (p - osname >= MAXNAMELEN)\n\t\t\treturn (ENAMETOOLONG);\n\t\t(void) strlcpy(poolname, osname, p - osname + 1);\n\t}\n\treturn (0);\n}\n\nstatic void\nfetch_osname_options(char *name, bool *checkpointrewind)\n{\n\n\tif (name[0] == '!') {\n\t\t*checkpointrewind = true;\n\t\tmemmove(name, name + 1, strlen(name));\n\t} else {\n\t\t*checkpointrewind = false;\n\t}\n}\n\nstatic int\nzfs_mount(vfs_t *vfsp)\n{\n\tkthread_t\t*td = curthread;\n\tvnode_t\t\t*mvp = vfsp->mnt_vnodecovered;\n\tcred_t\t\t*cr = td->td_ucred;\n\tchar\t\t*osname;\n\tint\t\terror = 0;\n\tint\t\tcanwrite;\n\tbool\t\tcheckpointrewind, isctlsnap = false;\n\n\tif (vfs_getopt(vfsp->mnt_optnew, \"from\", (void **)&osname, NULL))\n\t\treturn (SET_ERROR(EINVAL));\n\n\t \n\tif (zfs_super_owner &&\n\t    dsl_deleg_access(osname, ZFS_DELEG_PERM_MOUNT, cr) != ECANCELED) {\n\t\tsecpolicy_fs_mount_clearopts(cr, vfsp);\n\t}\n\n\tfetch_osname_options(osname, &checkpointrewind);\n\tisctlsnap = (mvp != NULL && zfsctl_is_node(mvp) &&\n\t    strchr(osname, '@') != NULL);\n\n\t \n\terror = secpolicy_fs_mount(cr, mvp, vfsp);\n\tif (error && isctlsnap) {\n\t\tsecpolicy_fs_mount_clearopts(cr, vfsp);\n\t} else if (error) {\n\t\tif (dsl_deleg_access(osname, ZFS_DELEG_PERM_MOUNT, cr) != 0)\n\t\t\tgoto out;\n\n\t\tif (!(vfsp->vfs_flag & MS_REMOUNT)) {\n\t\t\tvattr_t\t\tvattr;\n\n\t\t\t \n\n\t\t\tvattr.va_mask = AT_UID;\n\n\t\t\tvn_lock(mvp, LK_SHARED | LK_RETRY);\n\t\t\tif (VOP_GETATTR(mvp, &vattr, cr)) {\n\t\t\t\tVOP_UNLOCK1(mvp);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (secpolicy_vnode_owner(mvp, cr, vattr.va_uid) != 0 &&\n\t\t\t    VOP_ACCESS(mvp, VWRITE, cr, td) != 0) {\n\t\t\t\tVOP_UNLOCK1(mvp);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tVOP_UNLOCK1(mvp);\n\t\t}\n\n\t\tsecpolicy_fs_mount_clearopts(cr, vfsp);\n\t}\n\n\t \n\tif (!INGLOBALZONE(curproc) &&\n\t    (!zone_dataset_visible(osname, &canwrite) || !canwrite)) {\n\t\tboolean_t mount_snapshot = B_FALSE;\n\n\t\t \n\t\tif (isctlsnap) {\n\t\t\tstruct prison *pr;\n\t\t\tstruct zfs_jailparam *zjp;\n\n\t\t\tpr = curthread->td_ucred->cr_prison;\n\t\t\tmtx_lock(&pr->pr_mtx);\n\t\t\tzjp = osd_jail_get(pr, zfs_jailparam_slot);\n\t\t\tmtx_unlock(&pr->pr_mtx);\n\t\t\tif (zjp && zjp->mount_snapshot)\n\t\t\t\tmount_snapshot = B_TRUE;\n\t\t}\n\t\tif (!mount_snapshot) {\n\t\t\terror = SET_ERROR(EPERM);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tvfsp->vfs_flag |= MNT_NFS4ACLS;\n\n\t \n\tif (vfsp->vfs_flag & MS_REMOUNT) {\n\t\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\n\t\t \n\t\tZFS_TEARDOWN_ENTER_WRITE(zfsvfs, FTAG);\n\t\tzfs_unregister_callbacks(zfsvfs);\n\t\terror = zfs_register_callbacks(vfsp);\n\t\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((vfsp->vfs_flag & MNT_ROOTFS) != 0 &&\n\t    (vfsp->vfs_flag & MNT_UPDATE) == 0) {\n\t\tchar pname[MAXNAMELEN];\n\n\t\terror = getpoolname(osname, pname);\n\t\tif (error == 0)\n\t\t\terror = spa_import_rootpool(pname, checkpointrewind);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tDROP_GIANT();\n\terror = zfs_domount(vfsp, osname);\n\tPICKUP_GIANT();\n\nout:\n\treturn (error);\n}\n\nstatic int\nzfs_statfs(vfs_t *vfsp, struct statfs *statp)\n{\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\tuint64_t refdbytes, availbytes, usedobjs, availobjs;\n\tint error;\n\n\tstatp->f_version = STATFS_VERSION;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\tdmu_objset_space(zfsvfs->z_os,\n\t    &refdbytes, &availbytes, &usedobjs, &availobjs);\n\n\t \n\tstatp->f_bsize = SPA_MINBLOCKSIZE;\n\tstatp->f_iosize = zfsvfs->z_vfs->mnt_stat.f_iosize;\n\n\t \n\n\tstatp->f_blocks = (refdbytes + availbytes) >> SPA_MINBLOCKSHIFT;\n\tstatp->f_bfree = availbytes / statp->f_bsize;\n\tstatp->f_bavail = statp->f_bfree;  \n\n\t \n\tstatp->f_ffree = MIN(availobjs, statp->f_bfree);\n\tstatp->f_files = statp->f_ffree + usedobjs;\n\n\t \n\tstrlcpy(statp->f_fstypename, \"zfs\",\n\t    sizeof (statp->f_fstypename));\n\n\tstrlcpy(statp->f_mntfromname, vfsp->mnt_stat.f_mntfromname,\n\t    sizeof (statp->f_mntfromname));\n\tstrlcpy(statp->f_mntonname, vfsp->mnt_stat.f_mntonname,\n\t    sizeof (statp->f_mntonname));\n\n\tstatp->f_namemax = MAXNAMELEN - 1;\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nstatic int\nzfs_root(vfs_t *vfsp, int flags, vnode_t **vpp)\n{\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\tznode_t *rootzp;\n\tint error;\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\n\terror = zfs_zget(zfsvfs, zfsvfs->z_root, &rootzp);\n\tif (error == 0)\n\t\t*vpp = ZTOV(rootzp);\n\n\tzfs_exit(zfsvfs, FTAG);\n\n\tif (error == 0) {\n\t\terror = vn_lock(*vpp, flags);\n\t\tif (error != 0) {\n\t\t\tVN_RELE(*vpp);\n\t\t\t*vpp = NULL;\n\t\t}\n\t}\n\treturn (error);\n}\n\n \nstatic int\nzfsvfs_teardown(zfsvfs_t *zfsvfs, boolean_t unmounting)\n{\n\tznode_t\t*zp;\n\tdsl_dir_t *dd;\n\n\t \n\tif (zfsvfs->z_os) {\n\t\t \n\t\tint round = 0;\n\t\twhile (!list_is_empty(&zfsvfs->z_all_znodes)) {\n\t\t\ttaskq_wait_outstanding(dsl_pool_zrele_taskq(\n\t\t\t    dmu_objset_pool(zfsvfs->z_os)), 0);\n\t\t\tif (++round > 1 && !unmounting)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tZFS_TEARDOWN_ENTER_WRITE(zfsvfs, FTAG);\n\n\tif (!unmounting) {\n\t\t \n#ifdef FREEBSD_NAMECACHE\n#if __FreeBSD_version >= 1300117\n\t\tcache_purgevfs(zfsvfs->z_parent->z_vfs);\n#else\n\t\tcache_purgevfs(zfsvfs->z_parent->z_vfs, true);\n#endif\n#endif\n\t}\n\n\t \n\tif (zfsvfs->z_log) {\n\t\tzil_close(zfsvfs->z_log);\n\t\tzfsvfs->z_log = NULL;\n\t}\n\n\tZFS_TEARDOWN_INACTIVE_ENTER_WRITE(zfsvfs);\n\n\t \n\tif (!unmounting && (zfsvfs->z_unmounted || zfsvfs->z_os == NULL)) {\n\t\tZFS_TEARDOWN_INACTIVE_EXIT_WRITE(zfsvfs);\n\t\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EIO));\n\t}\n\n\t \n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tfor (zp = list_head(&zfsvfs->z_all_znodes); zp != NULL;\n\t    zp = list_next(&zfsvfs->z_all_znodes, zp)) {\n\t\tif (zp->z_sa_hdl != NULL) {\n\t\t\tzfs_znode_dmu_fini(zp);\n\t\t}\n\t}\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\n\t \n\tif (unmounting) {\n\t\tzfsvfs->z_unmounted = B_TRUE;\n\t\tZFS_TEARDOWN_INACTIVE_EXIT_WRITE(zfsvfs);\n\t\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\t}\n\n\t \n\tif (zfsvfs->z_os == NULL)\n\t\treturn (0);\n\n\t \n\tzfs_unregister_callbacks(zfsvfs);\n\n\t \n\tif (!zfs_is_readonly(zfsvfs))\n\t\ttxg_wait_synced(dmu_objset_pool(zfsvfs->z_os), 0);\n\tdmu_objset_evict_dbufs(zfsvfs->z_os);\n\tdd = zfsvfs->z_os->os_dsl_dataset->ds_dir;\n\tdsl_dir_cancel_waiters(dd);\n\n\treturn (0);\n}\n\nstatic int\nzfs_umount(vfs_t *vfsp, int fflag)\n{\n\tkthread_t *td = curthread;\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\tobjset_t *os;\n\tcred_t *cr = td->td_ucred;\n\tint ret;\n\n\tret = secpolicy_fs_unmount(cr, vfsp);\n\tif (ret) {\n\t\tif (dsl_deleg_access((char *)vfsp->vfs_resource,\n\t\t    ZFS_DELEG_PERM_MOUNT, cr))\n\t\t\treturn (ret);\n\t}\n\n\t \n\tif (zfsvfs->z_ctldir != NULL) {\n\t\tif ((ret = zfsctl_umount_snapshots(vfsp, fflag, cr)) != 0)\n\t\t\treturn (ret);\n\t}\n\n\tif (fflag & MS_FORCE) {\n\t\t \n\t\tZFS_TEARDOWN_ENTER_WRITE(zfsvfs, FTAG);\n\t\tzfsvfs->z_unmounted = B_TRUE;\n\t\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\t}\n\n\t \n\tret = vflush(vfsp, 0, (fflag & MS_FORCE) ? FORCECLOSE : 0, td);\n\tif (ret != 0)\n\t\treturn (ret);\n\twhile (taskqueue_cancel(zfsvfs_taskq->tq_queue,\n\t    &zfsvfs->z_unlinked_drain_task, NULL) != 0)\n\t\ttaskqueue_drain(zfsvfs_taskq->tq_queue,\n\t\t    &zfsvfs->z_unlinked_drain_task);\n\n\tVERIFY0(zfsvfs_teardown(zfsvfs, B_TRUE));\n\tos = zfsvfs->z_os;\n\n\t \n\tif (os != NULL) {\n\t\t \n\t\tmutex_enter(&os->os_user_ptr_lock);\n\t\tdmu_objset_set_user(os, NULL);\n\t\tmutex_exit(&os->os_user_ptr_lock);\n\n\t\t \n\t\tdmu_objset_disown(os, B_TRUE, zfsvfs);\n\t}\n\n\t \n\tif (zfsvfs->z_ctldir != NULL)\n\t\tzfsctl_destroy(zfsvfs);\n\tzfs_freevfs(vfsp);\n\n\treturn (0);\n}\n\nstatic int\nzfs_vget(vfs_t *vfsp, ino_t ino, int flags, vnode_t **vpp)\n{\n\tzfsvfs_t\t*zfsvfs = vfsp->vfs_data;\n\tznode_t\t\t*zp;\n\tint \t\terr;\n\n\t \n\tif (ino == ZFSCTL_INO_ROOT || ino == ZFSCTL_INO_SNAPDIR ||\n\t    (zfsvfs->z_shares_dir != 0 && ino == zfsvfs->z_shares_dir))\n\t\treturn (EOPNOTSUPP);\n\n\tif ((err = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (err);\n\terr = zfs_zget(zfsvfs, ino, &zp);\n\tif (err == 0 && zp->z_unlinked) {\n\t\tvrele(ZTOV(zp));\n\t\terr = EINVAL;\n\t}\n\tif (err == 0)\n\t\t*vpp = ZTOV(zp);\n\tzfs_exit(zfsvfs, FTAG);\n\tif (err == 0) {\n\t\terr = vn_lock(*vpp, flags);\n\t\tif (err != 0)\n\t\t\tvrele(*vpp);\n\t}\n\tif (err != 0)\n\t\t*vpp = NULL;\n\treturn (err);\n}\n\nstatic int\n#if __FreeBSD_version >= 1300098\nzfs_checkexp(vfs_t *vfsp, struct sockaddr *nam, uint64_t *extflagsp,\n    struct ucred **credanonp, int *numsecflavors, int *secflavors)\n#else\nzfs_checkexp(vfs_t *vfsp, struct sockaddr *nam, int *extflagsp,\n    struct ucred **credanonp, int *numsecflavors, int **secflavors)\n#endif\n{\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\n\t \n\treturn (vfs_stdcheckexp(zfsvfs->z_parent->z_vfs, nam, extflagsp,\n\t    credanonp, numsecflavors, secflavors));\n}\n\n_Static_assert(sizeof (struct fid) >= SHORT_FID_LEN,\n\t\"struct fid bigger than SHORT_FID_LEN\");\n_Static_assert(sizeof (struct fid) >= LONG_FID_LEN,\n\t\"struct fid bigger than LONG_FID_LEN\");\n\nstatic int\nzfs_fhtovp(vfs_t *vfsp, fid_t *fidp, int flags, vnode_t **vpp)\n{\n\tstruct componentname cn;\n\tzfsvfs_t\t*zfsvfs = vfsp->vfs_data;\n\tznode_t\t\t*zp;\n\tvnode_t\t\t*dvp;\n\tuint64_t\tobject = 0;\n\tuint64_t\tfid_gen = 0;\n\tuint64_t\tsetgen = 0;\n\tuint64_t\tgen_mask;\n\tuint64_t\tzp_gen;\n\tint \t\ti, err;\n\n\t*vpp = NULL;\n\n\tif ((err = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (err);\n\n\t \n\tif (zfsvfs->z_parent == zfsvfs && fidp->fid_len == LONG_FID_LEN) {\n\t\tzfid_long_t\t*zlfid = (zfid_long_t *)fidp;\n\t\tuint64_t\tobjsetid = 0;\n\n\t\tfor (i = 0; i < sizeof (zlfid->zf_setid); i++)\n\t\t\tobjsetid |= ((uint64_t)zlfid->zf_setid[i]) << (8 * i);\n\n\t\tfor (i = 0; i < sizeof (zlfid->zf_setgen); i++)\n\t\t\tsetgen |= ((uint64_t)zlfid->zf_setgen[i]) << (8 * i);\n\n\t\tzfs_exit(zfsvfs, FTAG);\n\n\t\terr = zfsctl_lookup_objset(vfsp, objsetid, &zfsvfs);\n\t\tif (err)\n\t\t\treturn (SET_ERROR(EINVAL));\n\t\tif ((err = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\t\treturn (err);\n\t}\n\n\tif (fidp->fid_len == SHORT_FID_LEN || fidp->fid_len == LONG_FID_LEN) {\n\t\tzfid_short_t\t*zfid = (zfid_short_t *)fidp;\n\n\t\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\t\tobject |= ((uint64_t)zfid->zf_object[i]) << (8 * i);\n\n\t\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\t\tfid_gen |= ((uint64_t)zfid->zf_gen[i]) << (8 * i);\n\t} else {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\tif (fidp->fid_len == LONG_FID_LEN && setgen != 0) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\tdprintf(\"snapdir fid: fid_gen (%llu) and setgen (%llu)\\n\",\n\t\t    (u_longlong_t)fid_gen, (u_longlong_t)setgen);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t \n\tif ((fid_gen == 0 &&\n\t    (object == ZFSCTL_INO_ROOT || object == ZFSCTL_INO_SNAPDIR)) ||\n\t    (zfsvfs->z_shares_dir != 0 && object == zfsvfs->z_shares_dir)) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\tVERIFY0(zfsctl_root(zfsvfs, LK_SHARED, &dvp));\n\t\tif (object == ZFSCTL_INO_SNAPDIR) {\n\t\t\tcn.cn_nameptr = \"snapshot\";\n\t\t\tcn.cn_namelen = strlen(cn.cn_nameptr);\n\t\t\tcn.cn_nameiop = LOOKUP;\n\t\t\tcn.cn_flags = ISLASTCN | LOCKLEAF;\n\t\t\tcn.cn_lkflags = flags;\n\t\t\tVERIFY0(VOP_LOOKUP(dvp, vpp, &cn));\n\t\t\tvput(dvp);\n\t\t} else if (object == zfsvfs->z_shares_dir) {\n\t\t\t \n\t\t\tcn.cn_nameptr = \"shares\";\n\t\t\tcn.cn_namelen = strlen(cn.cn_nameptr);\n\t\t\tcn.cn_nameiop = LOOKUP;\n\t\t\tcn.cn_flags = ISLASTCN;\n\t\t\tcn.cn_lkflags = flags;\n\t\t\tVERIFY0(VOP_LOOKUP(dvp, vpp, &cn));\n\t\t\tvput(dvp);\n\t\t} else {\n\t\t\t*vpp = dvp;\n\t\t}\n\t\treturn (err);\n\t}\n\n\tgen_mask = -1ULL >> (64 - 8 * i);\n\n\tdprintf(\"getting %llu [%llu mask %llx]\\n\", (u_longlong_t)object,\n\t    (u_longlong_t)fid_gen,\n\t    (u_longlong_t)gen_mask);\n\tif ((err = zfs_zget(zfsvfs, object, &zp))) {\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (err);\n\t}\n\t(void) sa_lookup(zp->z_sa_hdl, SA_ZPL_GEN(zfsvfs), &zp_gen,\n\t    sizeof (uint64_t));\n\tzp_gen = zp_gen & gen_mask;\n\tif (zp_gen == 0)\n\t\tzp_gen = 1;\n\tif (zp->z_unlinked || zp_gen != fid_gen) {\n\t\tdprintf(\"znode gen (%llu) != fid gen (%llu)\\n\",\n\t\t    (u_longlong_t)zp_gen, (u_longlong_t)fid_gen);\n\t\tvrele(ZTOV(zp));\n\t\tzfs_exit(zfsvfs, FTAG);\n\t\treturn (SET_ERROR(EINVAL));\n\t}\n\n\t*vpp = ZTOV(zp);\n\tzfs_exit(zfsvfs, FTAG);\n\terr = vn_lock(*vpp, flags);\n\tif (err == 0)\n\t\tvnode_create_vobject(*vpp, zp->z_size, curthread);\n\telse\n\t\t*vpp = NULL;\n\treturn (err);\n}\n\n \nint\nzfs_suspend_fs(zfsvfs_t *zfsvfs)\n{\n\tint error;\n\n\tif ((error = zfsvfs_teardown(zfsvfs, B_FALSE)) != 0)\n\t\treturn (error);\n\n\treturn (0);\n}\n\n \nint\nzfs_resume_fs(zfsvfs_t *zfsvfs, dsl_dataset_t *ds)\n{\n\tint err;\n\tznode_t *zp;\n\n\tASSERT(ZFS_TEARDOWN_WRITE_HELD(zfsvfs));\n\tASSERT(ZFS_TEARDOWN_INACTIVE_WRITE_HELD(zfsvfs));\n\n\t \n\tobjset_t *os;\n\tVERIFY3P(ds->ds_owner, ==, zfsvfs);\n\tVERIFY(dsl_dataset_long_held(ds));\n\tdsl_pool_t *dp = spa_get_dsl(dsl_dataset_get_spa(ds));\n\tdsl_pool_config_enter(dp, FTAG);\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tdsl_pool_config_exit(dp, FTAG);\n\n\terr = zfsvfs_init(zfsvfs, os);\n\tif (err != 0)\n\t\tgoto bail;\n\n\tds->ds_dir->dd_activity_cancelled = B_FALSE;\n\tVERIFY0(zfsvfs_setup(zfsvfs, B_FALSE));\n\n\tzfs_set_fuid_feature(zfsvfs);\n\n\t \n\tmutex_enter(&zfsvfs->z_znodes_lock);\n\tfor (zp = list_head(&zfsvfs->z_all_znodes); zp;\n\t    zp = list_next(&zfsvfs->z_all_znodes, zp)) {\n\t\t(void) zfs_rezget(zp);\n\t}\n\tmutex_exit(&zfsvfs->z_znodes_lock);\n\nbail:\n\t \n\tZFS_TEARDOWN_INACTIVE_EXIT_WRITE(zfsvfs);\n\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\n\tif (err) {\n\t\t \n\t\tif (vn_vfswlock(zfsvfs->z_vfs->vfs_vnodecovered) == 0) {\n\t\t\tvfs_ref(zfsvfs->z_vfs);\n\t\t\t(void) dounmount(zfsvfs->z_vfs, MS_FORCE, curthread);\n\t\t}\n\t}\n\treturn (err);\n}\n\nstatic void\nzfs_freevfs(vfs_t *vfsp)\n{\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\n\tzfsvfs_free(zfsvfs);\n\n\tatomic_dec_32(&zfs_active_fs_count);\n}\n\n#ifdef __i386__\nstatic int desiredvnodes_backup;\n#include <sys/vmmeter.h>\n\n\n#include <vm/vm_page.h>\n#include <vm/vm_object.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_map.h>\n#endif\n\nstatic void\nzfs_vnodes_adjust(void)\n{\n#ifdef __i386__\n\tint newdesiredvnodes;\n\n\tdesiredvnodes_backup = desiredvnodes;\n\n\t \n\tnewdesiredvnodes = min(maxproc + vm_cnt.v_page_count / 4, 2 *\n\t    vm_kmem_size / (5 * (sizeof (struct vm_object) +\n\t    sizeof (struct vnode))));\n\tif (newdesiredvnodes == desiredvnodes)\n\t\tdesiredvnodes = (3 * newdesiredvnodes) / 4;\n#endif\n}\n\nstatic void\nzfs_vnodes_adjust_back(void)\n{\n\n#ifdef __i386__\n\tdesiredvnodes = desiredvnodes_backup;\n#endif\n}\n\n#if __FreeBSD_version >= 1300139\nstatic struct sx zfs_vnlru_lock;\nstatic struct vnode *zfs_vnlru_marker;\n#endif\nstatic arc_prune_t *zfs_prune;\n\nstatic void\nzfs_prune_task(uint64_t nr_to_scan, void *arg __unused)\n{\n\tif (nr_to_scan > INT_MAX)\n\t\tnr_to_scan = INT_MAX;\n#if __FreeBSD_version >= 1300139\n\tsx_xlock(&zfs_vnlru_lock);\n\tvnlru_free_vfsops(nr_to_scan, &zfs_vfsops, zfs_vnlru_marker);\n\tsx_xunlock(&zfs_vnlru_lock);\n#else\n\tvnlru_free(nr_to_scan, &zfs_vfsops);\n#endif\n}\n\nvoid\nzfs_init(void)\n{\n\n\tprintf(\"ZFS filesystem version: \" ZPL_VERSION_STRING \"\\n\");\n\n\t \n\tzfsctl_init();\n\n\t \n\tzfs_znode_init();\n\n\t \n\tzfs_vnodes_adjust();\n\n\tdmu_objset_register_type(DMU_OST_ZFS, zpl_get_file_info);\n\n\tzfsvfs_taskq = taskq_create(\"zfsvfs\", 1, minclsyspri, 0, 0, 0);\n\n#if __FreeBSD_version >= 1300139\n\tzfs_vnlru_marker = vnlru_alloc_marker();\n\tsx_init(&zfs_vnlru_lock, \"zfs vnlru lock\");\n#endif\n\tzfs_prune = arc_add_prune_callback(zfs_prune_task, NULL);\n}\n\nvoid\nzfs_fini(void)\n{\n\tarc_remove_prune_callback(zfs_prune);\n#if __FreeBSD_version >= 1300139\n\tvnlru_free_marker(zfs_vnlru_marker);\n\tsx_destroy(&zfs_vnlru_lock);\n#endif\n\n\ttaskq_destroy(zfsvfs_taskq);\n\tzfsctl_fini();\n\tzfs_znode_fini();\n\tzfs_vnodes_adjust_back();\n}\n\nint\nzfs_busy(void)\n{\n\treturn (zfs_active_fs_count != 0);\n}\n\n \nint\nzfs_end_fs(zfsvfs_t *zfsvfs, dsl_dataset_t *ds)\n{\n\tASSERT(ZFS_TEARDOWN_WRITE_HELD(zfsvfs));\n\tASSERT(ZFS_TEARDOWN_INACTIVE_WRITE_HELD(zfsvfs));\n\n\t \n\tobjset_t *os;\n\tVERIFY3P(ds->ds_owner, ==, zfsvfs);\n\tVERIFY(dsl_dataset_long_held(ds));\n\tdsl_pool_t *dp = spa_get_dsl(dsl_dataset_get_spa(ds));\n\tdsl_pool_config_enter(dp, FTAG);\n\tVERIFY0(dmu_objset_from_ds(ds, &os));\n\tdsl_pool_config_exit(dp, FTAG);\n\tzfsvfs->z_os = os;\n\n\t \n\tZFS_TEARDOWN_INACTIVE_EXIT_WRITE(zfsvfs);\n\tZFS_TEARDOWN_EXIT(zfsvfs, FTAG);\n\n\t \n\t(void) zfs_umount(zfsvfs->z_vfs, 0);\n\tzfsvfs->z_unmounted = B_TRUE;\n\treturn (0);\n}\n\nint\nzfs_set_version(zfsvfs_t *zfsvfs, uint64_t newvers)\n{\n\tint error;\n\tobjset_t *os = zfsvfs->z_os;\n\tdmu_tx_t *tx;\n\n\tif (newvers < ZPL_VERSION_INITIAL || newvers > ZPL_VERSION)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (newvers < zfsvfs->z_version)\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zfs_spa_version_map(newvers) >\n\t    spa_version(dmu_objset_spa(zfsvfs->z_os)))\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\ttx = dmu_tx_create(os);\n\tdmu_tx_hold_zap(tx, MASTER_NODE_OBJ, B_FALSE, ZPL_VERSION_STR);\n\tif (newvers >= ZPL_VERSION_SA && !zfsvfs->z_use_sa) {\n\t\tdmu_tx_hold_zap(tx, MASTER_NODE_OBJ, B_TRUE,\n\t\t    ZFS_SA_ATTRS);\n\t\tdmu_tx_hold_zap(tx, DMU_NEW_OBJECT, FALSE, NULL);\n\t}\n\terror = dmu_tx_assign(tx, TXG_WAIT);\n\tif (error) {\n\t\tdmu_tx_abort(tx);\n\t\treturn (error);\n\t}\n\n\terror = zap_update(os, MASTER_NODE_OBJ, ZPL_VERSION_STR,\n\t    8, 1, &newvers, tx);\n\n\tif (error) {\n\t\tdmu_tx_commit(tx);\n\t\treturn (error);\n\t}\n\n\tif (newvers >= ZPL_VERSION_SA && !zfsvfs->z_use_sa) {\n\t\tuint64_t sa_obj;\n\n\t\tASSERT3U(spa_version(dmu_objset_spa(zfsvfs->z_os)), >=,\n\t\t    SPA_VERSION_SA);\n\t\tsa_obj = zap_create(os, DMU_OT_SA_MASTER_NODE,\n\t\t    DMU_OT_NONE, 0, tx);\n\n\t\terror = zap_add(os, MASTER_NODE_OBJ,\n\t\t    ZFS_SA_ATTRS, 8, 1, &sa_obj, tx);\n\t\tASSERT0(error);\n\n\t\tVERIFY0(sa_set_sa_object(os, sa_obj));\n\t\tsa_register_update_callback(os, zfs_sa_upgrade);\n\t}\n\n\tspa_history_log_internal_ds(dmu_objset_ds(os), \"upgrade\", tx,\n\t    \"from %ju to %ju\", (uintmax_t)zfsvfs->z_version,\n\t    (uintmax_t)newvers);\n\tdmu_tx_commit(tx);\n\n\tzfsvfs->z_version = newvers;\n\tos->os_version = newvers;\n\n\tzfs_set_fuid_feature(zfsvfs);\n\n\treturn (0);\n}\n\n \nboolean_t\nzfs_get_vfs_flag_unmounted(objset_t *os)\n{\n\tzfsvfs_t *zfvp;\n\tboolean_t unmounted = B_FALSE;\n\n\tASSERT3U(dmu_objset_type(os), ==, DMU_OST_ZFS);\n\n\tmutex_enter(&os->os_user_ptr_lock);\n\tzfvp = dmu_objset_get_user(os);\n\tif (zfvp != NULL && zfvp->z_vfs != NULL &&\n\t    (zfvp->z_vfs->mnt_kern_flag & MNTK_UNMOUNT))\n\t\tunmounted = B_TRUE;\n\tmutex_exit(&os->os_user_ptr_lock);\n\n\treturn (unmounted);\n}\n\n#ifdef _KERNEL\nvoid\nzfsvfs_update_fromname(const char *oldname, const char *newname)\n{\n\tchar tmpbuf[MAXPATHLEN];\n\tstruct mount *mp;\n\tchar *fromname;\n\tsize_t oldlen;\n\n\toldlen = strlen(oldname);\n\n\tmtx_lock(&mountlist_mtx);\n\tTAILQ_FOREACH(mp, &mountlist, mnt_list) {\n\t\tfromname = mp->mnt_stat.f_mntfromname;\n\t\tif (strcmp(fromname, oldname) == 0) {\n\t\t\t(void) strlcpy(fromname, newname,\n\t\t\t    sizeof (mp->mnt_stat.f_mntfromname));\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncmp(fromname, oldname, oldlen) == 0 &&\n\t\t    (fromname[oldlen] == '/' || fromname[oldlen] == '@')) {\n\t\t\t(void) snprintf(tmpbuf, sizeof (tmpbuf), \"%s%s\",\n\t\t\t    newname, fromname + oldlen);\n\t\t\t(void) strlcpy(fromname, tmpbuf,\n\t\t\t    sizeof (mp->mnt_stat.f_mntfromname));\n\t\t\tcontinue;\n\t\t}\n\t}\n\tmtx_unlock(&mountlist_mtx);\n}\n#endif\n\n \nstatic struct zfs_jailparam *\nzfs_jailparam_find(struct prison *spr, struct prison **prp)\n{\n\tstruct prison *pr;\n\tstruct zfs_jailparam *zjp;\n\n\tfor (pr = spr; ; pr = pr->pr_parent) {\n\t\tmtx_lock(&pr->pr_mtx);\n\t\tif (pr == &prison0) {\n\t\t\tzjp = &zfs_jailparam0;\n\t\t\tbreak;\n\t\t}\n\t\tzjp = osd_jail_get(pr, zfs_jailparam_slot);\n\t\tif (zjp != NULL)\n\t\t\tbreak;\n\t\tmtx_unlock(&pr->pr_mtx);\n\t}\n\t*prp = pr;\n\n\treturn (zjp);\n}\n\n \nstatic void\nzfs_jailparam_alloc(struct prison *pr, struct zfs_jailparam **zjpp)\n{\n\tstruct prison *ppr;\n\tstruct zfs_jailparam *zjp, *nzjp;\n\tvoid **rsv;\n\n\t \n\tzjp = zfs_jailparam_find(pr, &ppr);\n\tif (ppr == pr)\n\t\tgoto done;\n\n\t \n\tmtx_unlock(&ppr->pr_mtx);\n\tnzjp = malloc(sizeof (struct zfs_jailparam), M_PRISON, M_WAITOK);\n\trsv = osd_reserve(zfs_jailparam_slot);\n\tzjp = zfs_jailparam_find(pr, &ppr);\n\tif (ppr == pr) {\n\t\tfree(nzjp, M_PRISON);\n\t\tosd_free_reserved(rsv);\n\t\tgoto done;\n\t}\n\t \n\tmtx_lock(&pr->pr_mtx);\n\t(void) osd_jail_set_reserved(pr, zfs_jailparam_slot, rsv, nzjp);\n\t(void) memcpy(nzjp, zjp, sizeof (*zjp));\n\tzjp = nzjp;\n\tmtx_unlock(&ppr->pr_mtx);\ndone:\n\tif (zjpp != NULL)\n\t\t*zjpp = zjp;\n\telse\n\t\tmtx_unlock(&pr->pr_mtx);\n}\n\n \nstatic int\nzfs_jailparam_create(void *obj, void *data)\n{\n\tstruct prison *pr = obj;\n\tstruct vfsoptlist *opts = data;\n\tint jsys;\n\n\tif (vfs_copyopt(opts, \"zfs\", &jsys, sizeof (jsys)) == 0 &&\n\t    jsys == JAIL_SYS_INHERIT)\n\t\treturn (0);\n\t \n\tzfs_jailparam_alloc(pr, NULL);\n\treturn (0);\n}\n\nstatic int\nzfs_jailparam_get(void *obj, void *data)\n{\n\tstruct prison *ppr, *pr = obj;\n\tstruct vfsoptlist *opts = data;\n\tstruct zfs_jailparam *zjp;\n\tint jsys, error;\n\n\tzjp = zfs_jailparam_find(pr, &ppr);\n\tjsys = (ppr == pr) ? JAIL_SYS_NEW : JAIL_SYS_INHERIT;\n\terror = vfs_setopt(opts, \"zfs\", &jsys, sizeof (jsys));\n\tif (error != 0 && error != ENOENT)\n\t\tgoto done;\n\tif (jsys == JAIL_SYS_NEW) {\n\t\terror = vfs_setopt(opts, \"zfs.mount_snapshot\",\n\t\t    &zjp->mount_snapshot, sizeof (zjp->mount_snapshot));\n\t\tif (error != 0 && error != ENOENT)\n\t\t\tgoto done;\n\t} else {\n\t\t \n\t\tstatic int mount_snapshot = 0;\n\n\t\terror = vfs_setopt(opts, \"zfs.mount_snapshot\",\n\t\t    &mount_snapshot, sizeof (mount_snapshot));\n\t\tif (error != 0 && error != ENOENT)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tmtx_unlock(&ppr->pr_mtx);\n\treturn (error);\n}\n\nstatic int\nzfs_jailparam_set(void *obj, void *data)\n{\n\tstruct prison *pr = obj;\n\tstruct prison *ppr;\n\tstruct vfsoptlist *opts = data;\n\tint error, jsys, mount_snapshot;\n\n\t \n\terror = vfs_copyopt(opts, \"zfs\", &jsys, sizeof (jsys));\n\tif (error == ENOENT)\n\t\tjsys = -1;\n\terror = vfs_copyopt(opts, \"zfs.mount_snapshot\", &mount_snapshot,\n\t    sizeof (mount_snapshot));\n\tif (error == ENOENT)\n\t\tmount_snapshot = -1;\n\telse\n\t\tjsys = JAIL_SYS_NEW;\n\tswitch (jsys) {\n\tcase JAIL_SYS_NEW:\n\t{\n\t\t \n\t\tstruct zfs_jailparam *zjp;\n\n\t\t \n\t\tif (pr->pr_parent != &prison0) {\n\t\t\tzjp = zfs_jailparam_find(pr->pr_parent, &ppr);\n\t\t\tmtx_unlock(&ppr->pr_mtx);\n\t\t\tif (zjp->mount_snapshot < mount_snapshot) {\n\t\t\t\treturn (EPERM);\n\t\t\t}\n\t\t}\n\t\tzfs_jailparam_alloc(pr, &zjp);\n\t\tif (mount_snapshot != -1)\n\t\t\tzjp->mount_snapshot = mount_snapshot;\n\t\tmtx_unlock(&pr->pr_mtx);\n\t\tbreak;\n\t}\n\tcase JAIL_SYS_INHERIT:\n\t\t \n\t\tmtx_lock(&pr->pr_mtx);\n\t\tosd_jail_del(pr, zfs_jailparam_slot);\n\t\tmtx_unlock(&pr->pr_mtx);\n\t\tbreak;\n\tcase -1:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\nstatic int\nzfs_jailparam_check(void *obj __unused, void *data)\n{\n\tstruct vfsoptlist *opts = data;\n\tint error, jsys, mount_snapshot;\n\n\t \n\terror = vfs_copyopt(opts, \"zfs\", &jsys, sizeof (jsys));\n\tif (error != ENOENT) {\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t\tif (jsys != JAIL_SYS_NEW && jsys != JAIL_SYS_INHERIT)\n\t\t\treturn (EINVAL);\n\t}\n\terror = vfs_copyopt(opts, \"zfs.mount_snapshot\", &mount_snapshot,\n\t    sizeof (mount_snapshot));\n\tif (error != ENOENT) {\n\t\tif (error != 0)\n\t\t\treturn (error);\n\t\tif (mount_snapshot != 0 && mount_snapshot != 1)\n\t\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}\n\nstatic void\nzfs_jailparam_destroy(void *data)\n{\n\n\tfree(data, M_PRISON);\n}\n\nstatic void\nzfs_jailparam_sysinit(void *arg __unused)\n{\n\tstruct prison *pr;\n\tosd_method_t  methods[PR_MAXMETHOD] = {\n\t\t[PR_METHOD_CREATE] = zfs_jailparam_create,\n\t\t[PR_METHOD_GET] = zfs_jailparam_get,\n\t\t[PR_METHOD_SET] = zfs_jailparam_set,\n\t\t[PR_METHOD_CHECK] = zfs_jailparam_check,\n\t};\n\n\tzfs_jailparam_slot = osd_jail_register(zfs_jailparam_destroy, methods);\n\t \n\tsx_slock(&allprison_lock);\n\tTAILQ_FOREACH(pr, &allprison, pr_list)\n\t\tzfs_jailparam_alloc(pr, NULL);\n\tsx_sunlock(&allprison_lock);\n}\n\nstatic void\nzfs_jailparam_sysuninit(void *arg __unused)\n{\n\n\tosd_jail_deregister(zfs_jailparam_slot);\n}\n\nSYSINIT(zfs_jailparam_sysinit, SI_SUB_DRIVERS, SI_ORDER_ANY,\n\tzfs_jailparam_sysinit, NULL);\nSYSUNINIT(zfs_jailparam_sysuninit, SI_SUB_DRIVERS, SI_ORDER_ANY,\n\tzfs_jailparam_sysuninit, NULL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}