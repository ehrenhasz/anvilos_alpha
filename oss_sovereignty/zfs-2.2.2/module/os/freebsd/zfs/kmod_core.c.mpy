{
  "module_name": "kmod_core.c",
  "hash_id": "c776f775d62609a1682d2eedd93c68667655fb877a6af3ce6932bd6b1e65dcd1",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/kmod_core.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/param.h>\n#include <sys/buf.h>\n#include <sys/cmn_err.h>\n#include <sys/conf.h>\n#include <sys/dmu.h>\n#include <sys/dmu_impl.h>\n#include <sys/dmu_objset.h>\n#include <sys/dmu_send.h>\n#include <sys/dmu_tx.h>\n#include <sys/dsl_bookmark.h>\n#include <sys/dsl_crypt.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_deleg.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_dir.h>\n#include <sys/dsl_prop.h>\n#include <sys/dsl_scan.h>\n#include <sys/dsl_userhold.h>\n#include <sys/errno.h>\n#include <sys/eventhandler.h>\n#include <sys/file.h>\n#include <sys/fm/util.h>\n#include <sys/fs/zfs.h>\n#include <sys/kernel.h>\n#include <sys/kmem.h>\n#include <sys/lock.h>\n#include <sys/malloc.h>\n#include <sys/mount.h>\n#include <sys/mutex.h>\n#include <sys/nvpair.h>\n#include <sys/policy.h>\n#include <sys/proc.h>\n#include <sys/sdt.h>\n#include <sys/spa.h>\n#include <sys/spa_impl.h>\n#include <sys/stat.h>\n#include <sys/sunddi.h>\n#include <sys/systm.h>\n#include <sys/taskqueue.h>\n#include <sys/uio.h>\n#include <sys/vdev.h>\n#include <sys/vdev_removal.h>\n#include <sys/zap.h>\n#include <sys/zcp.h>\n#include <sys/zfeature.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_dir.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_ioctl_compat.h>\n#include <sys/zfs_ioctl_impl.h>\n#include <sys/zfs_onexit.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/zfs_znode.h>\n#include <sys/zio_checksum.h>\n#include <sys/zone.h>\n#include <sys/zvol.h>\n\n#include \"zfs_comutil.h\"\n#include \"zfs_deleg.h\"\n#include \"zfs_namecheck.h\"\n#include \"zfs_prop.h\"\n\nSYSCTL_DECL(_vfs_zfs);\nSYSCTL_DECL(_vfs_zfs_vdev);\n\nextern uint_t rrw_tsd_key;\nstatic int zfs_version_ioctl = ZFS_IOCVER_OZFS;\nSYSCTL_DECL(_vfs_zfs_version);\nSYSCTL_INT(_vfs_zfs_version, OID_AUTO, ioctl, CTLFLAG_RD, &zfs_version_ioctl,\n    0, \"ZFS_IOCTL_VERSION\");\n\nstatic struct cdev *zfsdev;\n\nstatic struct root_hold_token *zfs_root_token;\n\nextern uint_t rrw_tsd_key;\nextern uint_t zfs_allow_log_key;\nextern uint_t zfs_geom_probe_vdev_key;\n\nstatic int zfs__init(void);\nstatic int zfs__fini(void);\nstatic void zfs_shutdown(void *, int);\n\nstatic eventhandler_tag zfs_shutdown_event_tag;\n\n#define\tZFS_MIN_KSTACK_PAGES 4\n\nstatic int\nzfsdev_ioctl(struct cdev *dev, ulong_t zcmd, caddr_t arg, int flag,\n    struct thread *td)\n{\n\tuint_t len;\n\tint vecnum;\n\tzfs_iocparm_t *zp;\n\tzfs_cmd_t *zc;\n#ifdef ZFS_LEGACY_SUPPORT\n\tzfs_cmd_legacy_t *zcl;\n#endif\n\tint rc, error;\n\tvoid *uaddr;\n\n\tlen = IOCPARM_LEN(zcmd);\n\tvecnum = zcmd & 0xff;\n\tzp = (void *)arg;\n\terror = 0;\n#ifdef ZFS_LEGACY_SUPPORT\n\tzcl = NULL;\n#endif\n\n\tif (len != sizeof (zfs_iocparm_t))\n\t\treturn (EINVAL);\n\n\tuaddr = (void *)(uintptr_t)zp->zfs_cmd;\n\tzc = vmem_zalloc(sizeof (zfs_cmd_t), KM_SLEEP);\n#ifdef ZFS_LEGACY_SUPPORT\n\t \n\tif (zp->zfs_ioctl_version == ZFS_IOCVER_LEGACY) {\n\t\tvecnum = zfs_ioctl_legacy_to_ozfs(vecnum);\n\t\tif (vecnum < 0) {\n\t\t\tvmem_free(zc, sizeof (zfs_cmd_t));\n\t\t\treturn (ENOTSUP);\n\t\t}\n\t\tzcl = vmem_zalloc(sizeof (zfs_cmd_legacy_t), KM_SLEEP);\n\t\tif (copyin(uaddr, zcl, sizeof (zfs_cmd_legacy_t))) {\n\t\t\terror = SET_ERROR(EFAULT);\n\t\t\tgoto out;\n\t\t}\n\t\tzfs_cmd_legacy_to_ozfs(zcl, zc);\n\t} else\n#endif\n\tif (copyin(uaddr, zc, sizeof (zfs_cmd_t))) {\n\t\terror = SET_ERROR(EFAULT);\n\t\tgoto out;\n\t}\n\terror = zfsdev_ioctl_common(vecnum, zc, 0);\n#ifdef ZFS_LEGACY_SUPPORT\n\tif (zcl) {\n\t\tzfs_cmd_ozfs_to_legacy(zc, zcl);\n\t\trc = copyout(zcl, uaddr, sizeof (*zcl));\n\t} else\n#endif\n\t{\n\t\trc = copyout(zc, uaddr, sizeof (*zc));\n\t}\n\tif (error == 0 && rc != 0)\n\t\terror = SET_ERROR(EFAULT);\nout:\n#ifdef ZFS_LEGACY_SUPPORT\n\tif (zcl)\n\t\tvmem_free(zcl, sizeof (zfs_cmd_legacy_t));\n#endif\n\tvmem_free(zc, sizeof (zfs_cmd_t));\n\tMPASS(tsd_get(rrw_tsd_key) == NULL);\n\treturn (error);\n}\n\nstatic void\nzfsdev_close(void *data)\n{\n\tzfsdev_state_destroy(data);\n}\n\nvoid\nzfsdev_private_set_state(void *priv __unused, zfsdev_state_t *zs)\n{\n\tdevfs_set_cdevpriv(zs, zfsdev_close);\n}\n\nzfsdev_state_t *\nzfsdev_private_get_state(void *priv)\n{\n\treturn (priv);\n}\n\nstatic int\nzfsdev_open(struct cdev *devp __unused, int flag __unused, int mode __unused,\n    struct thread *td __unused)\n{\n\tint error;\n\n\tmutex_enter(&zfsdev_state_lock);\n\terror = zfsdev_state_init(NULL);\n\tmutex_exit(&zfsdev_state_lock);\n\n\treturn (error);\n}\n\nstatic struct cdevsw zfs_cdevsw = {\n\t.d_version =\tD_VERSION,\n\t.d_open =\tzfsdev_open,\n\t.d_ioctl =\tzfsdev_ioctl,\n\t.d_name =\tZFS_DRIVER\n};\n\nint\nzfsdev_attach(void)\n{\n\tstruct make_dev_args args;\n\n\tmake_dev_args_init(&args);\n\targs.mda_flags = MAKEDEV_CHECKNAME | MAKEDEV_WAITOK;\n\targs.mda_devsw = &zfs_cdevsw;\n\targs.mda_cr = NULL;\n\targs.mda_uid = UID_ROOT;\n\targs.mda_gid = GID_OPERATOR;\n\targs.mda_mode = 0666;\n\treturn (make_dev_s(&args, &zfsdev, ZFS_DRIVER));\n}\n\nvoid\nzfsdev_detach(void)\n{\n\tif (zfsdev != NULL)\n\t\tdestroy_dev(zfsdev);\n}\n\nint\nzfs__init(void)\n{\n\tint error;\n\n#if KSTACK_PAGES < ZFS_MIN_KSTACK_PAGES\n\tprintf(\"ZFS NOTICE: KSTACK_PAGES is %d which could result in stack \"\n\t    \"overflow panic!\\nPlease consider adding \"\n\t    \"'options KSTACK_PAGES=%d' to your kernel config\\n\", KSTACK_PAGES,\n\t    ZFS_MIN_KSTACK_PAGES);\n#endif\n\tzfs_root_token = root_mount_hold(\"ZFS\");\n\tif ((error = zfs_kmod_init()) != 0) {\n\t\tprintf(\"ZFS: Failed to Load ZFS Filesystem\"\n\t\t    \", rc = %d\\n\", error);\n\t\troot_mount_rel(zfs_root_token);\n\t\treturn (error);\n\t}\n\n\n\ttsd_create(&zfs_geom_probe_vdev_key, NULL);\n\n\tprintf(\"ZFS storage pool version: features support (\"\n\t    SPA_VERSION_STRING \")\\n\");\n\troot_mount_rel(zfs_root_token);\n\tddi_sysevent_init();\n\treturn (0);\n}\n\nint\nzfs__fini(void)\n{\n\tif (zfs_busy() || zvol_busy() ||\n\t    zio_injection_enabled) {\n\t\treturn (EBUSY);\n\t}\n\tzfs_kmod_fini();\n\ttsd_destroy(&zfs_geom_probe_vdev_key);\n\treturn (0);\n}\n\nstatic void\nzfs_shutdown(void *arg __unused, int howto __unused)\n{\n\n\t \n\tif (panicstr == NULL)\n\t\tzfs__fini();\n}\n\nstatic int\nzfs_modevent(module_t mod, int type, void *unused __unused)\n{\n\tint err;\n\n\tswitch (type) {\n\tcase MOD_LOAD:\n\t\terr = zfs__init();\n\t\tif (err == 0)\n\t\t\tzfs_shutdown_event_tag = EVENTHANDLER_REGISTER(\n\t\t\t    shutdown_post_sync, zfs_shutdown, NULL,\n\t\t\t    SHUTDOWN_PRI_FIRST);\n\t\treturn (err);\n\tcase MOD_UNLOAD:\n\t\terr = zfs__fini();\n\t\tif (err == 0 && zfs_shutdown_event_tag != NULL)\n\t\t\tEVENTHANDLER_DEREGISTER(shutdown_post_sync,\n\t\t\t    zfs_shutdown_event_tag);\n\t\treturn (err);\n\tcase MOD_SHUTDOWN:\n\t\treturn (0);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (EOPNOTSUPP);\n}\n\nstatic moduledata_t zfs_mod = {\n\t\"zfsctrl\",\n\tzfs_modevent,\n\t0\n};\n\n#ifdef _KERNEL\nEVENTHANDLER_DEFINE(mountroot, spa_boot_init, NULL, 0);\n#endif\n\nDECLARE_MODULE(zfsctrl, zfs_mod, SI_SUB_CLOCKS, SI_ORDER_ANY);\nMODULE_VERSION(zfsctrl, 1);\n#if __FreeBSD_version > 1300092\nMODULE_DEPEND(zfsctrl, xdr, 1, 1, 1);\n#else\nMODULE_DEPEND(zfsctrl, krpc, 1, 1, 1);\n#endif\nMODULE_DEPEND(zfsctrl, acl_nfs4, 1, 1, 1);\nMODULE_DEPEND(zfsctrl, crypto, 1, 1, 1);\nMODULE_DEPEND(zfsctrl, zlib, 1, 1, 1);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}