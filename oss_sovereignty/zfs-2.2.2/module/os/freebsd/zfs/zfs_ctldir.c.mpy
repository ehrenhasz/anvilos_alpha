{
  "module_name": "zfs_ctldir.c",
  "hash_id": "ff1e428a916bd552d0004e67b7e6824c19ebccda58b1f60dd0bc413bdbcd45f6",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/zfs_ctldir.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/libkern.h>\n#include <sys/dirent.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_ctldir.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_vfsops.h>\n#include <sys/namei.h>\n#include <sys/stat.h>\n#include <sys/dmu.h>\n#include <sys/dsl_dataset.h>\n#include <sys/dsl_destroy.h>\n#include <sys/dsl_deleg.h>\n#include <sys/mount.h>\n#include <sys/zap.h>\n#include <sys/sysproto.h>\n\n#include \"zfs_namecheck.h\"\n\n#include <sys/kernel.h>\n#include <sys/ccompat.h>\n\n \nconst uint16_t zfsctl_ctldir_mode = S_IRUSR | S_IXUSR | S_IRGRP | S_IXGRP |\n    S_IROTH | S_IXOTH;\n\n \n\n \n#define\tKASSERT_IMPLY(A, B, msg)\tKASSERT(!(A) || (B), (msg));\n\nstatic MALLOC_DEFINE(M_SFSNODES, \"sfs_nodes\", \"synthetic-fs nodes\");\n\ntypedef struct sfs_node {\n\tchar\t\tsn_name[ZFS_MAX_DATASET_NAME_LEN];\n\tuint64_t\tsn_parent_id;\n\tuint64_t\tsn_id;\n} sfs_node_t;\n\n \nstatic int\nsfs_compare_ids(struct vnode *vp, void *arg)\n{\n\tsfs_node_t *n1 = vp->v_data;\n\tsfs_node_t *n2 = arg;\n\tbool equal;\n\n\tequal = n1->sn_id == n2->sn_id &&\n\t    n1->sn_parent_id == n2->sn_parent_id;\n\n\t \n\treturn (!equal);\n}\n\nstatic int\nsfs_vnode_get(const struct mount *mp, int flags, uint64_t parent_id,\n    uint64_t id, struct vnode **vpp)\n{\n\tsfs_node_t search;\n\tint err;\n\n\tsearch.sn_id = id;\n\tsearch.sn_parent_id = parent_id;\n\terr = vfs_hash_get(mp, (uint32_t)id, flags, curthread, vpp,\n\t    sfs_compare_ids, &search);\n\treturn (err);\n}\n\nstatic int\nsfs_vnode_insert(struct vnode *vp, int flags, uint64_t parent_id,\n    uint64_t id, struct vnode **vpp)\n{\n\tint err;\n\n\tKASSERT(vp->v_data != NULL, (\"sfs_vnode_insert with NULL v_data\"));\n\terr = vfs_hash_insert(vp, (uint32_t)id, flags, curthread, vpp,\n\t    sfs_compare_ids, vp->v_data);\n\treturn (err);\n}\n\nstatic void\nsfs_vnode_remove(struct vnode *vp)\n{\n\tvfs_hash_remove(vp);\n}\n\ntypedef void sfs_vnode_setup_fn(vnode_t *vp, void *arg);\n\nstatic int\nsfs_vgetx(struct mount *mp, int flags, uint64_t parent_id, uint64_t id,\n    const char *tag, struct vop_vector *vops,\n    sfs_vnode_setup_fn setup, void *arg,\n    struct vnode **vpp)\n{\n\tstruct vnode *vp;\n\tint error;\n\n\terror = sfs_vnode_get(mp, flags, parent_id, id, vpp);\n\tif (error != 0 || *vpp != NULL) {\n\t\tKASSERT_IMPLY(error == 0, (*vpp)->v_data != NULL,\n\t\t    \"sfs vnode with no data\");\n\t\treturn (error);\n\t}\n\n\t \n\terror = getnewvnode(tag, mp, vops, &vp);\n\tif (error != 0) {\n\t\t*vpp = NULL;\n\t\treturn (error);\n\t}\n\n\t \n\tlockmgr(vp->v_vnlock, LK_EXCLUSIVE, NULL);\n\terror = insmntque(vp, mp);\n\tif (error != 0) {\n\t\t*vpp = NULL;\n\t\treturn (error);\n\t}\n\n\tsetup(vp, arg);\n\n\terror = sfs_vnode_insert(vp, flags, parent_id, id, vpp);\n\tif (error != 0 || *vpp != NULL) {\n\t\tKASSERT_IMPLY(error == 0, (*vpp)->v_data != NULL,\n\t\t    \"sfs vnode with no data\");\n\t\treturn (error);\n\t}\n\n#if __FreeBSD_version >= 1400077\n\tvn_set_state(vp, VSTATE_CONSTRUCTED);\n#endif\n\n\t*vpp = vp;\n\treturn (0);\n}\n\nstatic void\nsfs_print_node(sfs_node_t *node)\n{\n\tprintf(\"\\tname = %s\\n\", node->sn_name);\n\tprintf(\"\\tparent_id = %ju\\n\", (uintmax_t)node->sn_parent_id);\n\tprintf(\"\\tid = %ju\\n\", (uintmax_t)node->sn_id);\n}\n\nstatic sfs_node_t *\nsfs_alloc_node(size_t size, const char *name, uint64_t parent_id, uint64_t id)\n{\n\tstruct sfs_node *node;\n\n\tKASSERT(strlen(name) < sizeof (node->sn_name),\n\t    (\"sfs node name is too long\"));\n\tKASSERT(size >= sizeof (*node), (\"sfs node size is too small\"));\n\tnode = malloc(size, M_SFSNODES, M_WAITOK | M_ZERO);\n\tstrlcpy(node->sn_name, name, sizeof (node->sn_name));\n\tnode->sn_parent_id = parent_id;\n\tnode->sn_id = id;\n\n\treturn (node);\n}\n\nstatic void\nsfs_destroy_node(sfs_node_t *node)\n{\n\tfree(node, M_SFSNODES);\n}\n\nstatic void *\nsfs_reclaim_vnode(vnode_t *vp)\n{\n\tvoid *data;\n\n\tsfs_vnode_remove(vp);\n\tdata = vp->v_data;\n\tvp->v_data = NULL;\n\treturn (data);\n}\n\nstatic int\nsfs_readdir_common(uint64_t parent_id, uint64_t id, struct vop_readdir_args *ap,\n    zfs_uio_t *uio, off_t *offp)\n{\n\tstruct dirent entry;\n\tint error;\n\n\t \n\tif (ap->a_ncookies != NULL)\n\t\t*ap->a_ncookies = 0;\n\n\tif (zfs_uio_resid(uio) < sizeof (entry))\n\t\treturn (SET_ERROR(EINVAL));\n\n\tif (zfs_uio_offset(uio) < 0)\n\t\treturn (SET_ERROR(EINVAL));\n\tif (zfs_uio_offset(uio) == 0) {\n\t\tentry.d_fileno = id;\n\t\tentry.d_type = DT_DIR;\n\t\tentry.d_name[0] = '.';\n\t\tentry.d_name[1] = '\\0';\n\t\tentry.d_namlen = 1;\n\t\tentry.d_reclen = sizeof (entry);\n\t\terror = vfs_read_dirent(ap, &entry, zfs_uio_offset(uio));\n\t\tif (error != 0)\n\t\t\treturn (SET_ERROR(error));\n\t}\n\n\tif (zfs_uio_offset(uio) < sizeof (entry))\n\t\treturn (SET_ERROR(EINVAL));\n\tif (zfs_uio_offset(uio) == sizeof (entry)) {\n\t\tentry.d_fileno = parent_id;\n\t\tentry.d_type = DT_DIR;\n\t\tentry.d_name[0] = '.';\n\t\tentry.d_name[1] = '.';\n\t\tentry.d_name[2] = '\\0';\n\t\tentry.d_namlen = 2;\n\t\tentry.d_reclen = sizeof (entry);\n\t\terror = vfs_read_dirent(ap, &entry, zfs_uio_offset(uio));\n\t\tif (error != 0)\n\t\t\treturn (SET_ERROR(error));\n\t}\n\n\tif (offp != NULL)\n\t\t*offp = 2 * sizeof (entry);\n\treturn (0);\n}\n\n\n \n#define\tZFSCTL_INO_SNAP(id)\t(id)\n\nstatic struct vop_vector zfsctl_ops_root;\nstatic struct vop_vector zfsctl_ops_snapdir;\nstatic struct vop_vector zfsctl_ops_snapshot;\n\nvoid\nzfsctl_init(void)\n{\n}\n\nvoid\nzfsctl_fini(void)\n{\n}\n\nboolean_t\nzfsctl_is_node(vnode_t *vp)\n{\n\treturn (vn_matchops(vp, zfsctl_ops_root) ||\n\t    vn_matchops(vp, zfsctl_ops_snapdir) ||\n\t    vn_matchops(vp, zfsctl_ops_snapshot));\n\n}\n\ntypedef struct zfsctl_root {\n\tsfs_node_t\tnode;\n\tsfs_node_t\t*snapdir;\n\ttimestruc_t\tcmtime;\n} zfsctl_root_t;\n\n\n \nvoid\nzfsctl_create(zfsvfs_t *zfsvfs)\n{\n\tzfsctl_root_t *dot_zfs;\n\tsfs_node_t *snapdir;\n\tvnode_t *rvp;\n\tuint64_t crtime[2];\n\n\tASSERT3P(zfsvfs->z_ctldir, ==, NULL);\n\n\tsnapdir = sfs_alloc_node(sizeof (*snapdir), \"snapshot\", ZFSCTL_INO_ROOT,\n\t    ZFSCTL_INO_SNAPDIR);\n\tdot_zfs = (zfsctl_root_t *)sfs_alloc_node(sizeof (*dot_zfs), \".zfs\", 0,\n\t    ZFSCTL_INO_ROOT);\n\tdot_zfs->snapdir = snapdir;\n\n\tVERIFY0(VFS_ROOT(zfsvfs->z_vfs, LK_EXCLUSIVE, &rvp));\n\tVERIFY0(sa_lookup(VTOZ(rvp)->z_sa_hdl, SA_ZPL_CRTIME(zfsvfs),\n\t    &crtime, sizeof (crtime)));\n\tZFS_TIME_DECODE(&dot_zfs->cmtime, crtime);\n\tvput(rvp);\n\n\tzfsvfs->z_ctldir = dot_zfs;\n}\n\n \nvoid\nzfsctl_destroy(zfsvfs_t *zfsvfs)\n{\n\tsfs_destroy_node(zfsvfs->z_ctldir->snapdir);\n\tsfs_destroy_node((sfs_node_t *)zfsvfs->z_ctldir);\n\tzfsvfs->z_ctldir = NULL;\n}\n\nstatic int\nzfsctl_fs_root_vnode(struct mount *mp, void *arg __unused, int flags,\n    struct vnode **vpp)\n{\n\treturn (VFS_ROOT(mp, flags, vpp));\n}\n\nstatic void\nzfsctl_common_vnode_setup(vnode_t *vp, void *arg)\n{\n\tASSERT_VOP_ELOCKED(vp, __func__);\n\n\t \n\tVN_LOCK_ASHARE(vp);\n\tvp->v_type = VDIR;\n\tvp->v_data = arg;\n}\n\nstatic int\nzfsctl_root_vnode(struct mount *mp, void *arg __unused, int flags,\n    struct vnode **vpp)\n{\n\tvoid *node;\n\tint err;\n\n\tnode = ((zfsvfs_t *)mp->mnt_data)->z_ctldir;\n\terr = sfs_vgetx(mp, flags, 0, ZFSCTL_INO_ROOT, \"zfs\", &zfsctl_ops_root,\n\t    zfsctl_common_vnode_setup, node, vpp);\n\treturn (err);\n}\n\nstatic int\nzfsctl_snapdir_vnode(struct mount *mp, void *arg __unused, int flags,\n    struct vnode **vpp)\n{\n\tvoid *node;\n\tint err;\n\n\tnode = ((zfsvfs_t *)mp->mnt_data)->z_ctldir->snapdir;\n\terr = sfs_vgetx(mp, flags, ZFSCTL_INO_ROOT, ZFSCTL_INO_SNAPDIR, \"zfs\",\n\t    &zfsctl_ops_snapdir, zfsctl_common_vnode_setup, node, vpp);\n\treturn (err);\n}\n\n \nint\nzfsctl_root(zfsvfs_t *zfsvfs, int flags, vnode_t **vpp)\n{\n\tint error;\n\n\terror = zfsctl_root_vnode(zfsvfs->z_vfs, NULL, flags, vpp);\n\treturn (error);\n}\n\n \nstatic int\nzfsctl_common_open(struct vop_open_args *ap)\n{\n\tint flags = ap->a_mode;\n\n\tif (flags & FWRITE)\n\t\treturn (SET_ERROR(EACCES));\n\n\treturn (0);\n}\n\n \nstatic int\nzfsctl_common_close(struct vop_close_args *ap)\n{\n\t(void) ap;\n\treturn (0);\n}\n\n \nstatic int\nzfsctl_common_access(struct vop_access_args *ap)\n{\n\taccmode_t accmode = ap->a_accmode;\n\n\tif (accmode & VWRITE)\n\t\treturn (SET_ERROR(EACCES));\n\treturn (0);\n}\n\n \nstatic void\nzfsctl_common_getattr(vnode_t *vp, vattr_t *vap)\n{\n\ttimestruc_t\tnow;\n\tsfs_node_t *node;\n\n\tnode = vp->v_data;\n\n\tvap->va_uid = 0;\n\tvap->va_gid = 0;\n\tvap->va_rdev = 0;\n\t \n\tvap->va_blksize = 0;\n\tvap->va_nblocks = 0;\n\tvap->va_gen = 0;\n\tvn_fsid(vp, vap);\n\tvap->va_mode = zfsctl_ctldir_mode;\n\tvap->va_type = VDIR;\n\t \n\tgethrestime(&now);\n\tvap->va_atime = now;\n\t \n\tvap->va_flags = 0;\n\n\tvap->va_nodeid = node->sn_id;\n\n\t \n\tvap->va_nlink = 2;\n}\n\n#ifndef _OPENSOLARIS_SYS_VNODE_H_\nstruct vop_fid_args {\n\tstruct vnode *a_vp;\n\tstruct fid *a_fid;\n};\n#endif\n\nstatic int\nzfsctl_common_fid(struct vop_fid_args *ap)\n{\n\tvnode_t\t\t*vp = ap->a_vp;\n\tfid_t\t\t*fidp = (void *)ap->a_fid;\n\tsfs_node_t\t*node = vp->v_data;\n\tuint64_t\tobject = node->sn_id;\n\tzfid_short_t\t*zfid;\n\tint\t\ti;\n\n\tzfid = (zfid_short_t *)fidp;\n\tzfid->zf_len = SHORT_FID_LEN;\n\n\tfor (i = 0; i < sizeof (zfid->zf_object); i++)\n\t\tzfid->zf_object[i] = (uint8_t)(object >> (8 * i));\n\n\t \n\tfor (i = 0; i < sizeof (zfid->zf_gen); i++)\n\t\tzfid->zf_gen[i] = 0;\n\n\treturn (0);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_reclaim_args {\n\tstruct vnode *a_vp;\n\tstruct thread *a_td;\n};\n#endif\n\nstatic int\nzfsctl_common_reclaim(struct vop_reclaim_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\n\t(void) sfs_reclaim_vnode(vp);\n\treturn (0);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_print_args {\n\tstruct vnode *a_vp;\n};\n#endif\n\nstatic int\nzfsctl_common_print(struct vop_print_args *ap)\n{\n\tsfs_print_node(ap->a_vp->v_data);\n\treturn (0);\n}\n\n#ifndef _SYS_SYSPROTO_H_\nstruct vop_getattr_args {\n\tstruct vnode *a_vp;\n\tstruct vattr *a_vap;\n\tstruct ucred *a_cred;\n};\n#endif\n\n \nstatic int\nzfsctl_root_getattr(struct vop_getattr_args *ap)\n{\n\tstruct vnode *vp = ap->a_vp;\n\tstruct vattr *vap = ap->a_vap;\n\tzfsctl_root_t *node = vp->v_data;\n\n\tzfsctl_common_getattr(vp, vap);\n\tvap->va_ctime = node->cmtime;\n\tvap->va_mtime = vap->va_ctime;\n\tvap->va_birthtime = vap->va_ctime;\n\tvap->va_nlink += 1;  \n\tvap->va_size = vap->va_nlink;\n\treturn (0);\n}\n\n \nstatic int\nzfsctl_relock_dot(vnode_t *dvp, int ltype)\n{\n\tvref(dvp);\n\tif (ltype != VOP_ISLOCKED(dvp)) {\n\t\tif (ltype == LK_EXCLUSIVE)\n\t\t\tvn_lock(dvp, LK_UPGRADE | LK_RETRY);\n\t\telse  \n\t\t\tvn_lock(dvp, LK_DOWNGRADE | LK_RETRY);\n\n\t\t \n\t\tif (VN_IS_DOOMED(dvp)) {\n\t\t\tvrele(dvp);\n\t\t\treturn (SET_ERROR(ENOENT));\n\t\t}\n\t}\n\treturn (0);\n}\n\n \nstatic int\nzfsctl_root_lookup(struct vop_lookup_args *ap)\n{\n\tstruct componentname *cnp = ap->a_cnp;\n\tvnode_t *dvp = ap->a_dvp;\n\tvnode_t **vpp = ap->a_vpp;\n\tint flags = ap->a_cnp->cn_flags;\n\tint lkflags = ap->a_cnp->cn_lkflags;\n\tint nameiop = ap->a_cnp->cn_nameiop;\n\tint err;\n\n\tASSERT3S(dvp->v_type, ==, VDIR);\n\n\tif ((flags & ISLASTCN) != 0 && nameiop != LOOKUP)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (cnp->cn_namelen == 1 && *cnp->cn_nameptr == '.') {\n\t\terr = zfsctl_relock_dot(dvp, lkflags & LK_TYPE_MASK);\n\t\tif (err == 0)\n\t\t\t*vpp = dvp;\n\t} else if ((flags & ISDOTDOT) != 0) {\n\t\terr = vn_vget_ino_gen(dvp, zfsctl_fs_root_vnode, NULL,\n\t\t    lkflags, vpp);\n\t} else if (strncmp(cnp->cn_nameptr, \"snapshot\", cnp->cn_namelen) == 0) {\n\t\terr = zfsctl_snapdir_vnode(dvp->v_mount, NULL, lkflags, vpp);\n\t} else {\n\t\terr = SET_ERROR(ENOENT);\n\t}\n\tif (err != 0)\n\t\t*vpp = NULL;\n\treturn (err);\n}\n\nstatic int\nzfsctl_root_readdir(struct vop_readdir_args *ap)\n{\n\tstruct dirent entry;\n\tvnode_t *vp = ap->a_vp;\n\tzfsvfs_t *zfsvfs = vp->v_vfsp->vfs_data;\n\tzfsctl_root_t *node = vp->v_data;\n\tzfs_uio_t uio;\n\tint *eofp = ap->a_eofflag;\n\toff_t dots_offset;\n\tint error;\n\n\tzfs_uio_init(&uio, ap->a_uio);\n\n\tASSERT3S(vp->v_type, ==, VDIR);\n\n\t \n\tif (zfs_uio_offset(&uio) == 3 * sizeof (entry)) {\n\t\treturn (0);\n\t}\n\n\terror = sfs_readdir_common(zfsvfs->z_root, ZFSCTL_INO_ROOT, ap, &uio,\n\t    &dots_offset);\n\tif (error != 0) {\n\t\tif (error == ENAMETOOLONG)  \n\t\t\terror = 0;\n\t\treturn (error);\n\t}\n\tif (zfs_uio_offset(&uio) != dots_offset)\n\t\treturn (SET_ERROR(EINVAL));\n\n\t_Static_assert(sizeof (node->snapdir->sn_name) <= sizeof (entry.d_name),\n\t    \"node->snapdir->sn_name too big for entry.d_name\");\n\tentry.d_fileno = node->snapdir->sn_id;\n\tentry.d_type = DT_DIR;\n\tstrcpy(entry.d_name, node->snapdir->sn_name);\n\tentry.d_namlen = strlen(entry.d_name);\n\tentry.d_reclen = sizeof (entry);\n\terror = vfs_read_dirent(ap, &entry, zfs_uio_offset(&uio));\n\tif (error != 0) {\n\t\tif (error == ENAMETOOLONG)\n\t\t\terror = 0;\n\t\treturn (SET_ERROR(error));\n\t}\n\tif (eofp != NULL)\n\t\t*eofp = 1;\n\treturn (0);\n}\n\nstatic int\nzfsctl_root_vptocnp(struct vop_vptocnp_args *ap)\n{\n\tstatic const char dotzfs_name[4] = \".zfs\";\n\tvnode_t *dvp;\n\tint error;\n\n\tif (*ap->a_buflen < sizeof (dotzfs_name))\n\t\treturn (SET_ERROR(ENOMEM));\n\n\terror = vn_vget_ino_gen(ap->a_vp, zfsctl_fs_root_vnode, NULL,\n\t    LK_SHARED, &dvp);\n\tif (error != 0)\n\t\treturn (SET_ERROR(error));\n\n\tVOP_UNLOCK1(dvp);\n\t*ap->a_vpp = dvp;\n\t*ap->a_buflen -= sizeof (dotzfs_name);\n\tmemcpy(ap->a_buf + *ap->a_buflen, dotzfs_name, sizeof (dotzfs_name));\n\treturn (0);\n}\n\nstatic int\nzfsctl_common_pathconf(struct vop_pathconf_args *ap)\n{\n\t \n\tswitch (ap->a_name) {\n\tcase _PC_LINK_MAX:\n\t\t*ap->a_retval = MIN(LONG_MAX, ZFS_LINK_MAX);\n\t\treturn (0);\n\n\tcase _PC_FILESIZEBITS:\n\t\t*ap->a_retval = 64;\n\t\treturn (0);\n\n\tcase _PC_MIN_HOLE_SIZE:\n\t\t*ap->a_retval = (int)SPA_MINBLOCKSIZE;\n\t\treturn (0);\n\n\tcase _PC_ACL_EXTENDED:\n\t\t*ap->a_retval = 0;\n\t\treturn (0);\n\n\tcase _PC_ACL_NFS4:\n\t\t*ap->a_retval = 1;\n\t\treturn (0);\n\n\tcase _PC_ACL_PATH_MAX:\n\t\t*ap->a_retval = ACL_MAX_ENTRIES;\n\t\treturn (0);\n\n\tcase _PC_NAME_MAX:\n\t\t*ap->a_retval = NAME_MAX;\n\t\treturn (0);\n\n\tdefault:\n\t\treturn (vop_stdpathconf(ap));\n\t}\n}\n\n \nstatic int\nzfsctl_common_getacl(struct vop_getacl_args *ap)\n{\n\tint i;\n\n\tif (ap->a_type != ACL_TYPE_NFS4)\n\t\treturn (EINVAL);\n\n\tacl_nfs4_sync_acl_from_mode(ap->a_aclp, zfsctl_ctldir_mode, 0);\n\t \n\tfor (i = 0; i < ap->a_aclp->acl_cnt; i++) {\n\t\tstruct acl_entry *entry;\n\t\tentry = &(ap->a_aclp->acl_entry[i]);\n\t\tentry->ae_perm &= ~(ACL_WRITE_ACL | ACL_WRITE_OWNER |\n\t\t    ACL_WRITE_ATTRIBUTES | ACL_WRITE_NAMED_ATTRS |\n\t\t    ACL_READ_NAMED_ATTRS);\n\t}\n\n\treturn (0);\n}\n\nstatic struct vop_vector zfsctl_ops_root = {\n\t.vop_default =\t&default_vnodeops,\n#if __FreeBSD_version >= 1300121\n\t.vop_fplookup_vexec = VOP_EAGAIN,\n#endif\n#if __FreeBSD_version >= 1300139\n\t.vop_fplookup_symlink = VOP_EAGAIN,\n#endif\n\t.vop_open =\tzfsctl_common_open,\n\t.vop_close =\tzfsctl_common_close,\n\t.vop_ioctl =\tVOP_EINVAL,\n\t.vop_getattr =\tzfsctl_root_getattr,\n\t.vop_access =\tzfsctl_common_access,\n\t.vop_readdir =\tzfsctl_root_readdir,\n\t.vop_lookup =\tzfsctl_root_lookup,\n\t.vop_inactive =\tVOP_NULL,\n\t.vop_reclaim =\tzfsctl_common_reclaim,\n\t.vop_fid =\tzfsctl_common_fid,\n\t.vop_print =\tzfsctl_common_print,\n\t.vop_vptocnp =\tzfsctl_root_vptocnp,\n\t.vop_pathconf =\tzfsctl_common_pathconf,\n\t.vop_getacl =\tzfsctl_common_getacl,\n#if __FreeBSD_version >= 1400043\n\t.vop_add_writecount =\tvop_stdadd_writecount_nomsync,\n#endif\n};\nVFS_VOP_VECTOR_REGISTER(zfsctl_ops_root);\n\nstatic int\nzfsctl_snapshot_zname(vnode_t *vp, const char *name, int len, char *zname)\n{\n\tobjset_t *os = ((zfsvfs_t *)((vp)->v_vfsp->vfs_data))->z_os;\n\n\tdmu_objset_name(os, zname);\n\tif (strlen(zname) + 1 + strlen(name) >= len)\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\t(void) strcat(zname, \"@\");\n\t(void) strcat(zname, name);\n\treturn (0);\n}\n\nstatic int\nzfsctl_snapshot_lookup(vnode_t *vp, const char *name, uint64_t *id)\n{\n\tobjset_t *os = ((zfsvfs_t *)((vp)->v_vfsp->vfs_data))->z_os;\n\tint err;\n\n\terr = dsl_dataset_snap_lookup(dmu_objset_ds(os), name, id);\n\treturn (err);\n}\n\n \nstatic int\nzfsctl_mounted_here(vnode_t **vpp, int flags)\n{\n\tstruct mount *mp;\n\tint err;\n\n\tASSERT_VOP_LOCKED(*vpp, __func__);\n\tASSERT3S((*vpp)->v_type, ==, VDIR);\n\n\tif ((mp = (*vpp)->v_mountedhere) != NULL) {\n\t\terr = vfs_busy(mp, 0);\n\t\tKASSERT(err == 0, (\"vfs_busy(mp, 0) failed with %d\", err));\n\t\tKASSERT(vrefcnt(*vpp) > 1, (\"unreferenced mountpoint\"));\n\t\tvput(*vpp);\n\t\terr = VFS_ROOT(mp, flags, vpp);\n\t\tvfs_unbusy(mp);\n\t\treturn (err);\n\t}\n\treturn (EJUSTRETURN);\n}\n\ntypedef struct {\n\tconst char *snap_name;\n\tuint64_t    snap_id;\n} snapshot_setup_arg_t;\n\nstatic void\nzfsctl_snapshot_vnode_setup(vnode_t *vp, void *arg)\n{\n\tsnapshot_setup_arg_t *ssa = arg;\n\tsfs_node_t *node;\n\n\tASSERT_VOP_ELOCKED(vp, __func__);\n\n\tnode = sfs_alloc_node(sizeof (sfs_node_t),\n\t    ssa->snap_name, ZFSCTL_INO_SNAPDIR, ssa->snap_id);\n\tzfsctl_common_vnode_setup(vp, node);\n\n\t \n\tVN_LOCK_AREC(vp);\n}\n\n \nstatic int\nzfsctl_snapdir_lookup(struct vop_lookup_args *ap)\n{\n\tvnode_t *dvp = ap->a_dvp;\n\tvnode_t **vpp = ap->a_vpp;\n\tstruct componentname *cnp = ap->a_cnp;\n\tchar name[NAME_MAX + 1];\n\tchar fullname[ZFS_MAX_DATASET_NAME_LEN];\n\tchar *mountpoint;\n\tsize_t mountpoint_len;\n\tzfsvfs_t *zfsvfs = dvp->v_vfsp->vfs_data;\n\tuint64_t snap_id;\n\tint nameiop = cnp->cn_nameiop;\n\tint lkflags = cnp->cn_lkflags;\n\tint flags = cnp->cn_flags;\n\tint err;\n\n\tASSERT3S(dvp->v_type, ==, VDIR);\n\n\tif ((flags & ISLASTCN) != 0 && nameiop != LOOKUP)\n\t\treturn (SET_ERROR(ENOTSUP));\n\n\tif (cnp->cn_namelen == 1 && *cnp->cn_nameptr == '.') {\n\t\terr = zfsctl_relock_dot(dvp, lkflags & LK_TYPE_MASK);\n\t\tif (err == 0)\n\t\t\t*vpp = dvp;\n\t\treturn (err);\n\t}\n\tif (flags & ISDOTDOT) {\n\t\terr = vn_vget_ino_gen(dvp, zfsctl_root_vnode, NULL, lkflags,\n\t\t    vpp);\n\t\treturn (err);\n\t}\n\n\tif (cnp->cn_namelen >= sizeof (name))\n\t\treturn (SET_ERROR(ENAMETOOLONG));\n\n\tstrlcpy(name, ap->a_cnp->cn_nameptr, ap->a_cnp->cn_namelen + 1);\n\terr = zfsctl_snapshot_lookup(dvp, name, &snap_id);\n\tif (err != 0)\n\t\treturn (SET_ERROR(ENOENT));\n\n\tfor (;;) {\n\t\tsnapshot_setup_arg_t ssa;\n\n\t\tssa.snap_name = name;\n\t\tssa.snap_id = snap_id;\n\t\terr = sfs_vgetx(dvp->v_mount, LK_SHARED, ZFSCTL_INO_SNAPDIR,\n\t\t    snap_id, \"zfs\", &zfsctl_ops_snapshot,\n\t\t    zfsctl_snapshot_vnode_setup, &ssa, vpp);\n\t\tif (err != 0)\n\t\t\treturn (err);\n\n\t\t \n\t\tif (VOP_ISLOCKED(*vpp) == LK_EXCLUSIVE)\n\t\t\tbreak;\n\n\t\t \n\t\terr = zfsctl_mounted_here(vpp, lkflags);\n\t\tif (err != EJUSTRETURN)\n\t\t\treturn (err);\n\n\t\t \n\t\tVI_LOCK(*vpp);\n\t\tif (((*vpp)->v_iflag & VI_MOUNT) == 0) {\n\t\t\tVI_UNLOCK(*vpp);\n\t\t\t \n\t\t\terr = VOP_LOCK(*vpp, LK_TRYUPGRADE);\n\t\t\tif (err == 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tVI_UNLOCK(*vpp);\n\t\t}\n\n\t\t \n\t\tvput(*vpp);\n\t\tkern_yield(PRI_USER);\n\t}\n\n\tVERIFY0(zfsctl_snapshot_zname(dvp, name, sizeof (fullname), fullname));\n\n\tmountpoint_len = strlen(dvp->v_vfsp->mnt_stat.f_mntonname) +\n\t    strlen(\"/\" ZFS_CTLDIR_NAME \"/snapshot/\") + strlen(name) + 1;\n\tmountpoint = kmem_alloc(mountpoint_len, KM_SLEEP);\n\t(void) snprintf(mountpoint, mountpoint_len,\n\t    \"%s/\" ZFS_CTLDIR_NAME \"/snapshot/%s\",\n\t    dvp->v_vfsp->mnt_stat.f_mntonname, name);\n\n\terr = mount_snapshot(curthread, vpp, \"zfs\", mountpoint, fullname, 0,\n\t    dvp->v_vfsp);\n\tkmem_free(mountpoint, mountpoint_len);\n\tif (err == 0) {\n\t\t \n\t\tASSERT3P(VTOZ(*vpp)->z_zfsvfs, !=, zfsvfs);\n\t\tVTOZ(*vpp)->z_zfsvfs->z_parent = zfsvfs;\n\n\t\t \n\t\t(*vpp)->v_vflag &= ~VV_ROOT;\n\t}\n\n\tif (err != 0)\n\t\t*vpp = NULL;\n\treturn (err);\n}\n\nstatic int\nzfsctl_snapdir_readdir(struct vop_readdir_args *ap)\n{\n\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\tstruct dirent entry;\n\tvnode_t *vp = ap->a_vp;\n\tzfsvfs_t *zfsvfs = vp->v_vfsp->vfs_data;\n\tzfs_uio_t uio;\n\tint *eofp = ap->a_eofflag;\n\toff_t dots_offset;\n\tint error;\n\n\tzfs_uio_init(&uio, ap->a_uio);\n\n\tASSERT3S(vp->v_type, ==, VDIR);\n\n\terror = sfs_readdir_common(ZFSCTL_INO_ROOT, ZFSCTL_INO_SNAPDIR, ap,\n\t    &uio, &dots_offset);\n\tif (error != 0) {\n\t\tif (error == ENAMETOOLONG)  \n\t\t\terror = 0;\n\t\treturn (error);\n\t}\n\n\tif ((error = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (error);\n\tfor (;;) {\n\t\tuint64_t cookie;\n\t\tuint64_t id;\n\n\t\tcookie = zfs_uio_offset(&uio) - dots_offset;\n\n\t\tdsl_pool_config_enter(dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\terror = dmu_snapshot_list_next(zfsvfs->z_os, sizeof (snapname),\n\t\t    snapname, &id, &cookie, NULL);\n\t\tdsl_pool_config_exit(dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\tif (error != 0) {\n\t\t\tif (error == ENOENT) {\n\t\t\t\tif (eofp != NULL)\n\t\t\t\t\t*eofp = 1;\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (error);\n\t\t}\n\n\t\tentry.d_fileno = id;\n\t\tentry.d_type = DT_DIR;\n\t\tstrcpy(entry.d_name, snapname);\n\t\tentry.d_namlen = strlen(entry.d_name);\n\t\tentry.d_reclen = sizeof (entry);\n\t\terror = vfs_read_dirent(ap, &entry, zfs_uio_offset(&uio));\n\t\tif (error != 0) {\n\t\t\tif (error == ENAMETOOLONG)\n\t\t\t\terror = 0;\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (SET_ERROR(error));\n\t\t}\n\t\tzfs_uio_setoffset(&uio, cookie + dots_offset);\n\t}\n\t__builtin_unreachable();\n}\n\nstatic int\nzfsctl_snapdir_getattr(struct vop_getattr_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\tvattr_t *vap = ap->a_vap;\n\tzfsvfs_t *zfsvfs = vp->v_vfsp->vfs_data;\n\tdsl_dataset_t *ds;\n\tuint64_t snap_count;\n\tint err;\n\n\tif ((err = zfs_enter(zfsvfs, FTAG)) != 0)\n\t\treturn (err);\n\tds = dmu_objset_ds(zfsvfs->z_os);\n\tzfsctl_common_getattr(vp, vap);\n\tvap->va_ctime = dmu_objset_snap_cmtime(zfsvfs->z_os);\n\tvap->va_mtime = vap->va_ctime;\n\tvap->va_birthtime = vap->va_ctime;\n\tif (dsl_dataset_phys(ds)->ds_snapnames_zapobj != 0) {\n\t\terr = zap_count(dmu_objset_pool(ds->ds_objset)->dp_meta_objset,\n\t\t    dsl_dataset_phys(ds)->ds_snapnames_zapobj, &snap_count);\n\t\tif (err != 0) {\n\t\t\tzfs_exit(zfsvfs, FTAG);\n\t\t\treturn (err);\n\t\t}\n\t\tvap->va_nlink += snap_count;\n\t}\n\tvap->va_size = vap->va_nlink;\n\n\tzfs_exit(zfsvfs, FTAG);\n\treturn (0);\n}\n\nstatic struct vop_vector zfsctl_ops_snapdir = {\n\t.vop_default =\t&default_vnodeops,\n#if __FreeBSD_version >= 1300121\n\t.vop_fplookup_vexec = VOP_EAGAIN,\n#endif\n#if __FreeBSD_version >= 1300139\n\t.vop_fplookup_symlink = VOP_EAGAIN,\n#endif\n\t.vop_open =\tzfsctl_common_open,\n\t.vop_close =\tzfsctl_common_close,\n\t.vop_getattr =\tzfsctl_snapdir_getattr,\n\t.vop_access =\tzfsctl_common_access,\n\t.vop_readdir =\tzfsctl_snapdir_readdir,\n\t.vop_lookup =\tzfsctl_snapdir_lookup,\n\t.vop_reclaim =\tzfsctl_common_reclaim,\n\t.vop_fid =\tzfsctl_common_fid,\n\t.vop_print =\tzfsctl_common_print,\n\t.vop_pathconf =\tzfsctl_common_pathconf,\n\t.vop_getacl =\tzfsctl_common_getacl,\n#if __FreeBSD_version >= 1400043\n\t.vop_add_writecount =\tvop_stdadd_writecount_nomsync,\n#endif\n};\nVFS_VOP_VECTOR_REGISTER(zfsctl_ops_snapdir);\n\n\nstatic int\nzfsctl_snapshot_inactive(struct vop_inactive_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\n\tvrecycle(vp);\n\treturn (0);\n}\n\nstatic int\nzfsctl_snapshot_reclaim(struct vop_reclaim_args *ap)\n{\n\tvnode_t *vp = ap->a_vp;\n\tvoid *data = vp->v_data;\n\n\tsfs_reclaim_vnode(vp);\n\tsfs_destroy_node(data);\n\treturn (0);\n}\n\nstatic int\nzfsctl_snapshot_vptocnp(struct vop_vptocnp_args *ap)\n{\n\tstruct mount *mp;\n\tvnode_t *dvp;\n\tvnode_t *vp;\n\tsfs_node_t *node;\n\tsize_t len;\n\tint locked;\n\tint error;\n\n\tvp = ap->a_vp;\n\tnode = vp->v_data;\n\tlen = strlen(node->sn_name);\n\tif (*ap->a_buflen < len)\n\t\treturn (SET_ERROR(ENOMEM));\n\n\t \n\tmp = vp->v_mountedhere;\n\tif (mp == NULL)\n\t\treturn (SET_ERROR(ENOENT));\n\terror = vfs_busy(mp, 0);\n\tKASSERT(error == 0, (\"vfs_busy(mp, 0) failed with %d\", error));\n\n\t \n\tlocked = VOP_ISLOCKED(vp);\n#if __FreeBSD_version >= 1300045\n\tenum vgetstate vs = vget_prep(vp);\n#else\n\tvhold(vp);\n#endif\n\tvput(vp);\n\n\t \n\terror = zfsctl_snapdir_vnode(vp->v_mount, NULL, LK_SHARED, &dvp);\n\tif (error == 0) {\n\t\tVOP_UNLOCK1(dvp);\n\t\t*ap->a_vpp = dvp;\n\t\t*ap->a_buflen -= len;\n\t\tmemcpy(ap->a_buf + *ap->a_buflen, node->sn_name, len);\n\t}\n\tvfs_unbusy(mp);\n#if __FreeBSD_version >= 1300045\n\tvget_finish(vp, locked | LK_RETRY, vs);\n#else\n\tvget(vp, locked | LK_VNHELD | LK_RETRY, curthread);\n#endif\n\treturn (error);\n}\n\n \nstatic struct vop_vector zfsctl_ops_snapshot = {\n\t.vop_default =\t\tNULL,  \n#if __FreeBSD_version >= 1300121\n\t.vop_fplookup_vexec =\tVOP_EAGAIN,\n#endif\n#if __FreeBSD_version >= 1300139\n\t.vop_fplookup_symlink = VOP_EAGAIN,\n#endif\n\t.vop_open =\t\tzfsctl_common_open,\n\t.vop_close =\t\tzfsctl_common_close,\n\t.vop_inactive =\t\tzfsctl_snapshot_inactive,\n#if __FreeBSD_version >= 1300045\n\t.vop_need_inactive = vop_stdneed_inactive,\n#endif\n\t.vop_reclaim =\t\tzfsctl_snapshot_reclaim,\n\t.vop_vptocnp =\t\tzfsctl_snapshot_vptocnp,\n\t.vop_lock1 =\t\tvop_stdlock,\n\t.vop_unlock =\t\tvop_stdunlock,\n\t.vop_islocked =\t\tvop_stdislocked,\n\t.vop_advlockpurge =\tvop_stdadvlockpurge,  \n\t.vop_print =\t\tzfsctl_common_print,\n#if __FreeBSD_version >= 1400043\n\t.vop_add_writecount =\tvop_stdadd_writecount_nomsync,\n#endif\n};\nVFS_VOP_VECTOR_REGISTER(zfsctl_ops_snapshot);\n\nint\nzfsctl_lookup_objset(vfs_t *vfsp, uint64_t objsetid, zfsvfs_t **zfsvfsp)\n{\n\tzfsvfs_t *zfsvfs __unused = vfsp->vfs_data;\n\tvnode_t *vp;\n\tint error;\n\n\tASSERT3P(zfsvfs->z_ctldir, !=, NULL);\n\t*zfsvfsp = NULL;\n\terror = sfs_vnode_get(vfsp, LK_EXCLUSIVE,\n\t    ZFSCTL_INO_SNAPDIR, objsetid, &vp);\n\tif (error == 0 && vp != NULL) {\n\t\t \n\t\tif (vp->v_mountedhere != NULL)\n\t\t\t*zfsvfsp = vp->v_mountedhere->mnt_data;\n\t\tvput(vp);\n\t}\n\tif (*zfsvfsp == NULL)\n\t\treturn (SET_ERROR(EINVAL));\n\treturn (0);\n}\n\n \nint\nzfsctl_umount_snapshots(vfs_t *vfsp, int fflags, cred_t *cr)\n{\n\tchar snapname[ZFS_MAX_DATASET_NAME_LEN];\n\tzfsvfs_t *zfsvfs = vfsp->vfs_data;\n\tstruct mount *mp;\n\tvnode_t *vp;\n\tuint64_t cookie;\n\tint error;\n\n\tASSERT3P(zfsvfs->z_ctldir, !=, NULL);\n\n\tcookie = 0;\n\tfor (;;) {\n\t\tuint64_t id;\n\n\t\tdsl_pool_config_enter(dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\terror = dmu_snapshot_list_next(zfsvfs->z_os, sizeof (snapname),\n\t\t    snapname, &id, &cookie, NULL);\n\t\tdsl_pool_config_exit(dmu_objset_pool(zfsvfs->z_os), FTAG);\n\t\tif (error != 0) {\n\t\t\tif (error == ENOENT)\n\t\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (;;) {\n\t\t\terror = sfs_vnode_get(vfsp, LK_EXCLUSIVE,\n\t\t\t    ZFSCTL_INO_SNAPDIR, id, &vp);\n\t\t\tif (error != 0 || vp == NULL)\n\t\t\t\tbreak;\n\n\t\t\tmp = vp->v_mountedhere;\n\n\t\t\t \n\t\t\tif (mp != NULL)\n\t\t\t\tbreak;\n\t\t\tvput(vp);\n\t\t}\n\t\tif (error != 0)\n\t\t\tbreak;\n\t\tif (vp == NULL)\n\t\t\tcontinue;\t \n\n\t\t \n\t\tvfs_ref(mp);\n\t\terror = dounmount(mp, fflags, curthread);\n\t\tKASSERT_IMPLY(error == 0, vrefcnt(vp) == 1,\n\t\t    (\"extra references after unmount\"));\n\t\tvput(vp);\n\t\tif (error != 0)\n\t\t\tbreak;\n\t}\n\tKASSERT_IMPLY((fflags & MS_FORCE) != 0, error == 0,\n\t    (\"force unmounting failed\"));\n\treturn (error);\n}\n\nint\nzfsctl_snapshot_unmount(const char *snapname, int flags __unused)\n{\n\tvfs_t *vfsp = NULL;\n\tzfsvfs_t *zfsvfs = NULL;\n\n\tif (strchr(snapname, '@') == NULL)\n\t\treturn (0);\n\n\tint err = getzfsvfs(snapname, &zfsvfs);\n\tif (err != 0) {\n\t\tASSERT3P(zfsvfs, ==, NULL);\n\t\treturn (0);\n\t}\n\tvfsp = zfsvfs->z_vfs;\n\n\tASSERT(!dsl_pool_config_held(dmu_objset_pool(zfsvfs->z_os)));\n\n\tvfs_ref(vfsp);\n\tvfs_unbusy(vfsp);\n\treturn (dounmount(vfsp, MS_FORCE, curthread));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}