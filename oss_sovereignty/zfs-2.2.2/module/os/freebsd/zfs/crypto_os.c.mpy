{
  "module_name": "crypto_os.c",
  "hash_id": "c8107c9d734b924c747c8f25dcd08406864113f3612cedb26ea9b27338203f0a",
  "original_prompt": "Ingested from zfs-2.2.2/module/os/freebsd/zfs/crypto_os.c",
  "human_readable_source": " \n\n#include <sys/cdefs.h>\n__FBSDID(\"$FreeBSD$\");\n\n#include <sys/types.h>\n#include <sys/errno.h>\n\n#ifdef _KERNEL\n#include <sys/libkern.h>\n#include <sys/malloc.h>\n#include <sys/sysctl.h>\n#include <opencrypto/cryptodev.h>\n#include <opencrypto/xform.h>\n#endif\n\n#include <sys/zio_crypt.h>\n#include <sys/fs/zfs.h>\n#include <sys/zio.h>\n\n#include <sys/freebsd_crypto.h>\n\n#define\tSHA512_HMAC_BLOCK_SIZE\t128\n\nstatic int crypt_sessions = 0;\nSYSCTL_DECL(_vfs_zfs);\nSYSCTL_INT(_vfs_zfs, OID_AUTO, crypt_sessions, CTLFLAG_RD,\n\t&crypt_sessions, 0, \"Number of cryptographic sessions created\");\n\nvoid\ncrypto_mac_init(struct hmac_ctx *ctx, const crypto_key_t *c_key)\n{\n\tuint8_t k_ipad[SHA512_HMAC_BLOCK_SIZE],\n\t    k_opad[SHA512_HMAC_BLOCK_SIZE],\n\t    key[SHA512_HMAC_BLOCK_SIZE];\n\tSHA512_CTX lctx;\n\tint i;\n\tsize_t cl_bytes = CRYPTO_BITS2BYTES(c_key->ck_length);\n\n\t \n\tmemset(key, 0, sizeof (key));\n\tif (c_key->ck_length  == 0)\n\t\t ;\n\telse if (cl_bytes <= SHA512_HMAC_BLOCK_SIZE)\n\t\tmemcpy(key, c_key->ck_data, cl_bytes);\n\telse {\n\t\t \n\t\tSHA512_Init(&lctx);\n\t\tSHA512_Update(&lctx, c_key->ck_data, cl_bytes);\n\t\tSHA512_Final(key, &lctx);\n\t}\n\n\t \n\tfor (i = 0; i < sizeof (key); i++) {\n\t\tk_ipad[i] = key[i] ^ 0x36;\n\t\tk_opad[i] = key[i] ^ 0x5c;\n\t}\n\tmemset(key, 0, sizeof (key));\n\n\t \n\tSHA512_Init(&ctx->innerctx);\n\tSHA512_Update(&ctx->innerctx, k_ipad, sizeof (k_ipad));\n\tmemset(k_ipad, 0, sizeof (k_ipad));\n\t \n\tSHA512_Init(&ctx->outerctx);\n\tSHA512_Update(&ctx->outerctx, k_opad, sizeof (k_opad));\n\tmemset(k_opad, 0, sizeof (k_opad));\n}\n\nvoid\ncrypto_mac_update(struct hmac_ctx *ctx, const void *data, size_t datasize)\n{\n\tSHA512_Update(&ctx->innerctx, data, datasize);\n}\n\nvoid\ncrypto_mac_final(struct hmac_ctx *ctx, void *md, size_t mdsize)\n{\n\tuint8_t digest[SHA512_DIGEST_LENGTH];\n\n\t \n\tSHA512_Final(digest, &ctx->innerctx);\n\n\t \n\tSHA512_Update(&ctx->outerctx, digest, sizeof (digest));\n\tSHA512_Final(digest, &ctx->outerctx);\n\n\tmemset(ctx, 0, sizeof (*ctx));\n\t \n\tif (mdsize == 0)\n\t\tmdsize = SHA512_DIGEST_LENGTH;\n\tmemcpy(md, digest, mdsize);\n\tmemset(digest, 0, sizeof (digest));\n}\n\nvoid\ncrypto_mac(const crypto_key_t *key, const void *in_data, size_t in_data_size,\n    void *out_data, size_t out_data_size)\n{\n\tstruct hmac_ctx ctx;\n\n\tcrypto_mac_init(&ctx, key);\n\tcrypto_mac_update(&ctx, in_data, in_data_size);\n\tcrypto_mac_final(&ctx, out_data, out_data_size);\n}\n\nstatic int\nfreebsd_zfs_crypt_done(struct cryptop *crp)\n{\n\tfreebsd_crypt_session_t *ses;\n\n\tses = crp->crp_opaque;\n\tmtx_lock(&ses->fs_lock);\n\tses->fs_done = true;\n\tmtx_unlock(&ses->fs_lock);\n\twakeup(crp);\n\treturn (0);\n}\n\nstatic int\nfreebsd_zfs_crypt_done_sync(struct cryptop *crp)\n{\n\n\treturn (0);\n}\n\nvoid\nfreebsd_crypt_freesession(freebsd_crypt_session_t *sess)\n{\n\tmtx_destroy(&sess->fs_lock);\n\tcrypto_freesession(sess->fs_sid);\n\tmemset(sess, 0, sizeof (*sess));\n}\n\nstatic int\nzfs_crypto_dispatch(freebsd_crypt_session_t *session, struct cryptop *crp)\n{\n\tint error;\n\n\tcrp->crp_opaque = session;\n\tfor (;;) {\n#if __FreeBSD_version < 1400004\n\t\tboolean_t async = ((crypto_ses2caps(crp->crp_session) &\n\t\t    CRYPTOCAP_F_SYNC) == 0);\n#else\n\t\tboolean_t async = !CRYPTO_SESS_SYNC(crp->crp_session);\n#endif\n\t\tcrp->crp_callback = async ? freebsd_zfs_crypt_done :\n\t\t    freebsd_zfs_crypt_done_sync;\n\t\terror = crypto_dispatch(crp);\n\t\tif (error == 0) {\n\t\t\tif (async) {\n\t\t\t\tmtx_lock(&session->fs_lock);\n\t\t\t\twhile (session->fs_done == false) {\n\t\t\t\t\tmsleep(crp, &session->fs_lock, 0,\n\t\t\t\t\t    \"zfs_crypto\", 0);\n\t\t\t\t}\n\t\t\t\tmtx_unlock(&session->fs_lock);\n\t\t\t}\n\t\t\terror = crp->crp_etype;\n\t\t}\n\n\t\tif (error == ENOMEM) {\n\t\t\tpause(\"zcrnomem\", 1);\n\t\t} else if (error != EAGAIN) {\n\t\t\tbreak;\n\t\t}\n\t\tcrp->crp_etype = 0;\n\t\tcrp->crp_flags &= ~CRYPTO_F_DONE;\n\t\tsession->fs_done = false;\n#if __FreeBSD_version < 1300087\n\t\t \n\t\tsession->fs_sid = crp->crp_session;\n#endif\n\t}\n\treturn (error);\n}\nstatic void\nfreebsd_crypt_uio_debug_log(boolean_t encrypt,\n    freebsd_crypt_session_t *input_sessionp,\n    const struct zio_crypt_info *c_info,\n    zfs_uio_t *data_uio,\n    crypto_key_t *key,\n    uint8_t *ivbuf,\n    size_t datalen,\n    size_t auth_len)\n{\n#ifdef FCRYPTO_DEBUG\n\tstruct cryptodesc *crd;\n\tuint8_t *p = NULL;\n\tsize_t total = 0;\n\n\tprintf(\"%s(%s, %p, { %s, %d, %d, %s }, %p, { %p, %u }, \"\n\t    \"%p, %u, %u)\\n\",\n\t    __FUNCTION__, encrypt ? \"encrypt\" : \"decrypt\", input_sessionp,\n\t    c_info->ci_algname, c_info->ci_crypt_type,\n\t    (unsigned int)c_info->ci_keylen, c_info->ci_name,\n\t    data_uio, key->ck_data,\n\t    (unsigned int)key->ck_length,\n\t    ivbuf, (unsigned int)datalen, (unsigned int)auth_len);\n\tprintf(\"\\tkey = { \");\n\tfor (int i = 0; i < key->ck_length / 8; i++) {\n\t\tuint8_t *b = (uint8_t *)key->ck_data;\n\t\tprintf(\"%02x \", b[i]);\n\t}\n\tprintf(\"}\\n\");\n\tfor (int i = 0; i < zfs_uio_iovcnt(data_uio); i++) {\n\t\tprintf(\"\\tiovec #%d: <%p, %u>\\n\", i,\n\t\t    zfs_uio_iovbase(data_uio, i),\n\t\t    (unsigned int)zfs_uio_iovlen(data_uio, i));\n\t\ttotal += zfs_uio_iovlen(data_uio, i);\n\t}\n\tzfs_uio_resid(data_uio) = total;\n#endif\n}\n \n#if __FreeBSD_version >= 1300087\nint\nfreebsd_crypt_newsession(freebsd_crypt_session_t *sessp,\n    const struct zio_crypt_info *c_info, crypto_key_t *key)\n{\n\tstruct crypto_session_params csp = {0};\n\tint error = 0;\n\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s(%p, { %s, %d, %d, %s }, { %p, %u })\\n\",\n\t    __FUNCTION__, sessp,\n\t    c_info->ci_algname, c_info->ci_crypt_type,\n\t    (unsigned int)c_info->ci_keylen, c_info->ci_name,\n\t    key->ck_data, (unsigned int)key->ck_length);\n\tprintf(\"\\tkey = { \");\n\tfor (int i = 0; i < key->ck_length / 8; i++) {\n\t\tuint8_t *b = (uint8_t *)key->ck_data;\n\t\tprintf(\"%02x \", b[i]);\n\t}\n\tprintf(\"}\\n\");\n#endif\n\tcsp.csp_mode = CSP_MODE_AEAD;\n\tcsp.csp_cipher_key = key->ck_data;\n\tcsp.csp_cipher_klen = key->ck_length / 8;\n\tswitch (c_info->ci_crypt_type) {\n\t\tcase ZC_TYPE_GCM:\n\t\tcsp.csp_cipher_alg = CRYPTO_AES_NIST_GCM_16;\n\t\tcsp.csp_ivlen = AES_GCM_IV_LEN;\n\t\tswitch (key->ck_length/8) {\n\t\tcase AES_128_GMAC_KEY_LEN:\n\t\tcase AES_192_GMAC_KEY_LEN:\n\t\tcase AES_256_GMAC_KEY_LEN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\tcase ZC_TYPE_CCM:\n\t\tcsp.csp_cipher_alg = CRYPTO_AES_CCM_16;\n\t\tcsp.csp_ivlen = AES_CCM_IV_LEN;\n\t\tswitch (key->ck_length/8) {\n\t\tcase AES_128_CBC_MAC_KEY_LEN:\n\t\tcase AES_192_CBC_MAC_KEY_LEN:\n\t\tcase AES_256_CBC_MAC_KEY_LEN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = ENOTSUP;\n\t\tgoto bad;\n\t}\n\n\t \n\terror = crypto_newsession(&sessp->fs_sid, &csp, CRYPTOCAP_F_SOFTWARE);\n\tmtx_init(&sessp->fs_lock, \"FreeBSD Cryptographic Session Lock\",\n\t    NULL, MTX_DEF);\n\tcrypt_sessions++;\nbad:\n#ifdef FCRYPTO_DEBUG\n\tif (error)\n\t\tprintf(\"%s: returning error %d\\n\", __FUNCTION__, error);\n#endif\n\treturn (error);\n}\n\nint\nfreebsd_crypt_uio(boolean_t encrypt,\n    freebsd_crypt_session_t *input_sessionp,\n    const struct zio_crypt_info *c_info,\n    zfs_uio_t *data_uio,\n    crypto_key_t *key,\n    uint8_t *ivbuf,\n    size_t datalen,\n    size_t auth_len)\n{\n\tstruct cryptop *crp;\n\tfreebsd_crypt_session_t *session = NULL;\n\tint error = 0;\n\tsize_t total = 0;\n\n\tfreebsd_crypt_uio_debug_log(encrypt, input_sessionp, c_info, data_uio,\n\t    key, ivbuf, datalen, auth_len);\n\tfor (int i = 0; i < zfs_uio_iovcnt(data_uio); i++)\n\t\ttotal += zfs_uio_iovlen(data_uio, i);\n\tzfs_uio_resid(data_uio) = total;\n\tif (input_sessionp == NULL) {\n\t\tsession = kmem_zalloc(sizeof (*session), KM_SLEEP);\n\t\terror = freebsd_crypt_newsession(session, c_info, key);\n\t\tif (error)\n\t\t\tgoto out;\n\t} else\n\t\tsession = input_sessionp;\n\n\tcrp = crypto_getreq(session->fs_sid, M_WAITOK);\n\tif (encrypt) {\n\t\tcrp->crp_op = CRYPTO_OP_ENCRYPT |\n\t\t    CRYPTO_OP_COMPUTE_DIGEST;\n\t} else {\n\t\tcrp->crp_op = CRYPTO_OP_DECRYPT |\n\t\t    CRYPTO_OP_VERIFY_DIGEST;\n\t}\n\tcrp->crp_flags = CRYPTO_F_CBIFSYNC | CRYPTO_F_IV_SEPARATE;\n\tcrypto_use_uio(crp, GET_UIO_STRUCT(data_uio));\n\n\tcrp->crp_aad_start = 0;\n\tcrp->crp_aad_length = auth_len;\n\tcrp->crp_payload_start = auth_len;\n\tcrp->crp_payload_length = datalen;\n\tcrp->crp_digest_start = auth_len + datalen;\n\n\tmemcpy(crp->crp_iv, ivbuf, ZIO_DATA_IV_LEN);\n\terror = zfs_crypto_dispatch(session, crp);\n\tcrypto_freereq(crp);\nout:\n#ifdef FCRYPTO_DEBUG\n\tif (error)\n\t\tprintf(\"%s: returning error %d\\n\", __FUNCTION__, error);\n#endif\n\tif (input_sessionp == NULL) {\n\t\tfreebsd_crypt_freesession(session);\n\t\tkmem_free(session, sizeof (*session));\n\t}\n\treturn (error);\n}\n\n#else\nint\nfreebsd_crypt_newsession(freebsd_crypt_session_t *sessp,\n    const struct zio_crypt_info *c_info, crypto_key_t *key)\n{\n\tstruct cryptoini cria = {0}, crie = {0}, *crip;\n\tstruct enc_xform *xform;\n\tstruct auth_hash *xauth;\n\tint error = 0;\n\tcrypto_session_t sid;\n\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s(%p, { %s, %d, %d, %s }, { %p, %u })\\n\",\n\t    __FUNCTION__, sessp,\n\t    c_info->ci_algname, c_info->ci_crypt_type,\n\t    (unsigned int)c_info->ci_keylen, c_info->ci_name,\n\t    key->ck_data, (unsigned int)key->ck_length);\n\tprintf(\"\\tkey = { \");\n\tfor (int i = 0; i < key->ck_length / 8; i++) {\n\t\tuint8_t *b = (uint8_t *)key->ck_data;\n\t\tprintf(\"%02x \", b[i]);\n\t}\n\tprintf(\"}\\n\");\n#endif\n\tswitch (c_info->ci_crypt_type) {\n\tcase ZC_TYPE_GCM:\n\t\txform = &enc_xform_aes_nist_gcm;\n\t\tswitch (key->ck_length/8) {\n\t\tcase AES_128_GMAC_KEY_LEN:\n\t\t\txauth = &auth_hash_nist_gmac_aes_128;\n\t\t\tbreak;\n\t\tcase AES_192_GMAC_KEY_LEN:\n\t\t\txauth = &auth_hash_nist_gmac_aes_192;\n\t\t\tbreak;\n\t\tcase AES_256_GMAC_KEY_LEN:\n\t\t\txauth = &auth_hash_nist_gmac_aes_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\tcase ZC_TYPE_CCM:\n\t\txform = &enc_xform_ccm;\n\t\tswitch (key->ck_length/8) {\n\t\tcase AES_128_CBC_MAC_KEY_LEN:\n\t\t\txauth = &auth_hash_ccm_cbc_mac_128;\n\t\t\tbreak;\n\t\tcase AES_192_CBC_MAC_KEY_LEN:\n\t\t\txauth = &auth_hash_ccm_cbc_mac_192;\n\t\t\tbreak;\n\t\tcase AES_256_CBC_MAC_KEY_LEN:\n\t\t\txauth = &auth_hash_ccm_cbc_mac_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = ENOTSUP;\n\t\tgoto bad;\n\t}\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s(%d): Using crypt %s (key length %u [%u bytes]), \"\n\t    \"auth %s (key length %d)\\n\",\n\t    __FUNCTION__, __LINE__,\n\t    xform->name, (unsigned int)key->ck_length,\n\t    (unsigned int)key->ck_length/8,\n\t    xauth->name, xauth->keysize);\n#endif\n\n\tcrie.cri_alg = xform->type;\n\tcrie.cri_key = key->ck_data;\n\tcrie.cri_klen = key->ck_length;\n\n\tcria.cri_alg = xauth->type;\n\tcria.cri_key = key->ck_data;\n\tcria.cri_klen = key->ck_length;\n\n\tcria.cri_next = &crie;\n\tcrie.cri_next = NULL;\n\tcrip = &cria;\n\t\n\n\terror = crypto_newsession(&sid, crip,\n\t    CRYPTOCAP_F_HARDWARE | CRYPTOCAP_F_SOFTWARE);\n\tif (error != 0) {\n\t\tprintf(\"%s(%d):  crypto_newsession failed with %d\\n\",\n\t\t    __FUNCTION__, __LINE__, error);\n\t\tgoto bad;\n\t}\n\tsessp->fs_sid = sid;\n\tmtx_init(&sessp->fs_lock, \"FreeBSD Cryptographic Session Lock\",\n\t    NULL, MTX_DEF);\n\tcrypt_sessions++;\nbad:\n\treturn (error);\n}\n\n \nint\nfreebsd_crypt_uio(boolean_t encrypt,\n    freebsd_crypt_session_t *input_sessionp,\n    const struct zio_crypt_info *c_info,\n    zfs_uio_t *data_uio,\n    crypto_key_t *key,\n    uint8_t *ivbuf,\n    size_t datalen,\n    size_t auth_len)\n{\n\tstruct cryptop *crp;\n\tstruct cryptodesc *enc_desc, *auth_desc;\n\tstruct enc_xform *xform;\n\tstruct auth_hash *xauth;\n\tfreebsd_crypt_session_t *session = NULL;\n\tint error;\n\n\tfreebsd_crypt_uio_debug_log(encrypt, input_sessionp, c_info, data_uio,\n\t    key, ivbuf, datalen, auth_len);\n\tswitch (c_info->ci_crypt_type) {\n\tcase ZC_TYPE_GCM:\n\t\txform = &enc_xform_aes_nist_gcm;\n\t\tswitch (key->ck_length/8) {\n\t\tcase AES_128_GMAC_KEY_LEN:\n\t\t\txauth = &auth_hash_nist_gmac_aes_128;\n\t\t\tbreak;\n\t\tcase AES_192_GMAC_KEY_LEN:\n\t\t\txauth = &auth_hash_nist_gmac_aes_192;\n\t\t\tbreak;\n\t\tcase AES_256_GMAC_KEY_LEN:\n\t\t\txauth = &auth_hash_nist_gmac_aes_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\tcase ZC_TYPE_CCM:\n\t\txform = &enc_xform_ccm;\n\t\tswitch (key->ck_length/8) {\n\t\tcase AES_128_CBC_MAC_KEY_LEN:\n\t\t\txauth = &auth_hash_ccm_cbc_mac_128;\n\t\t\tbreak;\n\t\tcase AES_192_CBC_MAC_KEY_LEN:\n\t\t\txauth = &auth_hash_ccm_cbc_mac_192;\n\t\t\tbreak;\n\t\tcase AES_256_CBC_MAC_KEY_LEN:\n\t\t\txauth = &auth_hash_ccm_cbc_mac_256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = EINVAL;\n\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = ENOTSUP;\n\t\tgoto bad;\n\t}\n\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s(%d): Using crypt %s (key length %u [%u bytes]), \"\n\t    \"auth %s (key length %d)\\n\",\n\t    __FUNCTION__, __LINE__,\n\t    xform->name, (unsigned int)key->ck_length,\n\t    (unsigned int)key->ck_length/8,\n\t    xauth->name, xauth->keysize);\n#endif\n\n\tif (input_sessionp == NULL) {\n\t\tsession = kmem_zalloc(sizeof (*session), KM_SLEEP);\n\t\terror = freebsd_crypt_newsession(session, c_info, key);\n\t\tif (error)\n\t\t\tgoto out;\n\t} else\n\t\tsession = input_sessionp;\n\n\tcrp = crypto_getreq(2);\n\tif (crp == NULL) {\n\t\terror = ENOMEM;\n\t\tgoto bad;\n\t}\n\n\tauth_desc = crp->crp_desc;\n\tenc_desc = auth_desc->crd_next;\n\n\tcrp->crp_session = session->fs_sid;\n\tcrp->crp_ilen = auth_len + datalen;\n\tcrp->crp_buf = (void*)GET_UIO_STRUCT(data_uio);\n\tcrp->crp_flags = CRYPTO_F_IOV | CRYPTO_F_CBIFSYNC;\n\n\tauth_desc->crd_skip = 0;\n\tauth_desc->crd_len = auth_len;\n\tauth_desc->crd_inject = auth_len + datalen;\n\tauth_desc->crd_alg = xauth->type;\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s: auth: skip = %u, len = %u, inject = %u\\n\",\n\t    __FUNCTION__, auth_desc->crd_skip, auth_desc->crd_len,\n\t    auth_desc->crd_inject);\n#endif\n\n\tenc_desc->crd_skip = auth_len;\n\tenc_desc->crd_len = datalen;\n\tenc_desc->crd_inject = auth_len;\n\tenc_desc->crd_alg = xform->type;\n\tenc_desc->crd_flags = CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT;\n\tmemcpy(enc_desc->crd_iv, ivbuf, ZIO_DATA_IV_LEN);\n\tenc_desc->crd_next = NULL;\n\n#ifdef FCRYPTO_DEBUG\n\tprintf(\"%s: enc: skip = %u, len = %u, inject = %u\\n\",\n\t    __FUNCTION__, enc_desc->crd_skip, enc_desc->crd_len,\n\t    enc_desc->crd_inject);\n#endif\n\n\tif (encrypt)\n\t\tenc_desc->crd_flags |= CRD_F_ENCRYPT;\n\n\terror = zfs_crypto_dispatch(session, crp);\n\tcrypto_freereq(crp);\nout:\n\tif (input_sessionp == NULL) {\n\t\tfreebsd_crypt_freesession(session);\n\t\tkmem_free(session, sizeof (*session));\n\t}\nbad:\n#ifdef FCRYPTO_DEBUG\n\tif (error)\n\t\tprintf(\"%s: returning error %d\\n\", __FUNCTION__, error);\n#endif\n\treturn (error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}