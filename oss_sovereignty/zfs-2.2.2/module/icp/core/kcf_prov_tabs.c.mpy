{
  "module_name": "kcf_prov_tabs.c",
  "hash_id": "b907c85ea81a7c75c5e2fdf874a172a61bc16c87b0fdb3348b537886af38e921",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/core/kcf_prov_tabs.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n#include <sys/crypto/sched_impl.h>\n#include <sys/crypto/spi.h>\n\n#define\tKCF_MAX_PROVIDERS\t8\t \n\n \nstatic kcf_provider_desc_t *prov_tab[KCF_MAX_PROVIDERS];\nstatic kmutex_t prov_tab_mutex;  \nstatic uint_t prov_tab_num = 0;  \n\nvoid\nkcf_prov_tab_destroy(void)\n{\n\tmutex_destroy(&prov_tab_mutex);\n}\n\n \nvoid\nkcf_prov_tab_init(void)\n{\n\tmutex_init(&prov_tab_mutex, NULL, MUTEX_DEFAULT, NULL);\n}\n\n \nint\nkcf_prov_tab_add_provider(kcf_provider_desc_t *prov_desc)\n{\n\tuint_t i;\n\n\tmutex_enter(&prov_tab_mutex);\n\n\t \n\tfor (i = 1; i < KCF_MAX_PROVIDERS && prov_tab[i] != NULL; i++)\n\t\t;\n\tif (i == KCF_MAX_PROVIDERS) {\n\t\t \n\t\tmutex_exit(&prov_tab_mutex);\n\t\tcmn_err(CE_WARN, \"out of providers entries\");\n\t\treturn (CRYPTO_HOST_MEMORY);\n\t}\n\n\t \n\tprov_tab[i] = prov_desc;\n\tKCF_PROV_REFHOLD(prov_desc);\n\tKCF_PROV_IREFHOLD(prov_desc);\n\tprov_tab_num++;\n\n\tmutex_exit(&prov_tab_mutex);\n\n\t \n\tprov_desc->pd_prov_id = i;\n\n\t \n\tprov_desc->pd_kcf_prov_handle =\n\t    (crypto_kcf_provider_handle_t)prov_desc->pd_prov_id;\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nint\nkcf_prov_tab_rem_provider(crypto_provider_id_t prov_id)\n{\n\tkcf_provider_desc_t *prov_desc;\n\n\t \n\n\tmutex_enter(&prov_tab_mutex);\n\tif (prov_id >= KCF_MAX_PROVIDERS ||\n\t    ((prov_desc = prov_tab[prov_id]) == NULL)) {\n\t\tmutex_exit(&prov_tab_mutex);\n\t\treturn (CRYPTO_INVALID_PROVIDER_ID);\n\t}\n\tmutex_exit(&prov_tab_mutex);\n\n\t \n\n\tKCF_PROV_IREFRELE(prov_desc);\n\tKCF_PROV_REFRELE(prov_desc);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nkcf_provider_desc_t *\nkcf_prov_tab_lookup(crypto_provider_id_t prov_id)\n{\n\tkcf_provider_desc_t *prov_desc;\n\n\tmutex_enter(&prov_tab_mutex);\n\n\tprov_desc = prov_tab[prov_id];\n\n\tif (prov_desc == NULL) {\n\t\tmutex_exit(&prov_tab_mutex);\n\t\treturn (NULL);\n\t}\n\n\tKCF_PROV_REFHOLD(prov_desc);\n\n\tmutex_exit(&prov_tab_mutex);\n\n\treturn (prov_desc);\n}\n\n \nkcf_provider_desc_t *\nkcf_alloc_provider_desc(void)\n{\n\tkcf_provider_desc_t *desc =\n\t    kmem_zalloc(sizeof (kcf_provider_desc_t), KM_SLEEP);\n\n\tfor (int i = 0; i < KCF_OPS_CLASSSIZE; i++)\n\t\tfor (int j = 0; j < KCF_MAXMECHTAB; j++)\n\t\t\tdesc->pd_mech_indx[i][j] = KCF_INVALID_INDX;\n\n\tdesc->pd_prov_id = KCF_PROVID_INVALID;\n\tdesc->pd_state = KCF_PROV_ALLOCATED;\n\n\tmutex_init(&desc->pd_lock, NULL, MUTEX_DEFAULT, NULL);\n\tcv_init(&desc->pd_remove_cv, NULL, CV_DEFAULT, NULL);\n\n\treturn (desc);\n}\n\n \nvoid\nkcf_provider_zero_refcnt(kcf_provider_desc_t *desc)\n{\n\tmutex_enter(&desc->pd_lock);\n\tif (desc->pd_state == KCF_PROV_REMOVED ||\n\t    desc->pd_state == KCF_PROV_DISABLED) {\n\t\tdesc->pd_state = KCF_PROV_FREED;\n\t\tcv_broadcast(&desc->pd_remove_cv);\n\t\tmutex_exit(&desc->pd_lock);\n\t\treturn;\n\t}\n\n\tmutex_exit(&desc->pd_lock);\n\tkcf_free_provider_desc(desc);\n}\n\n \nvoid\nkcf_free_provider_desc(kcf_provider_desc_t *desc)\n{\n\tif (desc == NULL)\n\t\treturn;\n\n\tmutex_enter(&prov_tab_mutex);\n\tif (desc->pd_prov_id != KCF_PROVID_INVALID) {\n\t\t \n\t\tASSERT(prov_tab[desc->pd_prov_id] != NULL);\n\t\tprov_tab[desc->pd_prov_id] = NULL;\n\t\tprov_tab_num--;\n\t}\n\tmutex_exit(&prov_tab_mutex);\n\n\t \n\n\tmutex_destroy(&desc->pd_lock);\n\tcv_destroy(&desc->pd_remove_cv);\n\n\tkmem_free(desc, sizeof (kcf_provider_desc_t));\n}\n\n \nint\nkcf_get_sw_prov(crypto_mech_type_t mech_type, kcf_provider_desc_t **pd,\n    kcf_mech_entry_t **mep, boolean_t log_warn)\n{\n\tkcf_mech_entry_t *me;\n\n\t \n\tif (kcf_get_mech_entry(mech_type, &me) != KCF_SUCCESS)\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\n\t \n\tif (me->me_sw_prov == NULL ||\n\t    (*pd = me->me_sw_prov->pm_prov_desc) == NULL) {\n\t\t \n\t\tif (log_warn)\n\t\t\tcmn_err(CE_WARN, \"no provider for \\\"%s\\\"\\n\",\n\t\t\t    me->me_name);\n\t\treturn (CRYPTO_MECH_NOT_SUPPORTED);\n\t}\n\n\tKCF_PROV_REFHOLD(*pd);\n\n\tif (mep != NULL)\n\t\t*mep = me;\n\n\treturn (CRYPTO_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}