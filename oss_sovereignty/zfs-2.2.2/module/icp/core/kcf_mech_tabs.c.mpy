{
  "module_name": "kcf_mech_tabs.c",
  "hash_id": "788dbb0476f1018e72db5aa2b5ea28454ef8cd02c9e0adbe825d83ea0d365416",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/core/kcf_mech_tabs.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/api.h>\n#include <sys/crypto/impl.h>\n\n \n\n \n\n \n\n\t\t \n\n\n \n\nstatic kcf_mech_entry_t kcf_digest_mechs_tab[KCF_MAXDIGEST];\nstatic kcf_mech_entry_t kcf_cipher_mechs_tab[KCF_MAXCIPHER];\nstatic kcf_mech_entry_t kcf_mac_mechs_tab[KCF_MAXMAC];\n\nconst kcf_mech_entry_tab_t kcf_mech_tabs_tab[KCF_LAST_OPSCLASS + 1] = {\n\t{0, NULL},\t\t\t\t \n\t{KCF_MAXDIGEST, kcf_digest_mechs_tab},\n\t{KCF_MAXCIPHER, kcf_cipher_mechs_tab},\n\t{KCF_MAXMAC, kcf_mac_mechs_tab},\n};\n\nstatic avl_tree_t kcf_mech_hash;\n\nstatic int\nkcf_mech_hash_compar(const void *lhs, const void *rhs)\n{\n\tconst kcf_mech_entry_t *l = lhs, *r = rhs;\n\tint cmp = strncmp(l->me_name, r->me_name, CRYPTO_MAX_MECH_NAME);\n\treturn ((0 < cmp) - (cmp < 0));\n}\n\nvoid\nkcf_destroy_mech_tabs(void)\n{\n\tfor (void *cookie = NULL; avl_destroy_nodes(&kcf_mech_hash, &cookie); )\n\t\t;\n\tavl_destroy(&kcf_mech_hash);\n}\n\n \nvoid\nkcf_init_mech_tabs(void)\n{\n\tavl_create(&kcf_mech_hash, kcf_mech_hash_compar,\n\t    sizeof (kcf_mech_entry_t), offsetof(kcf_mech_entry_t, me_node));\n}\n\n \nstatic int\nkcf_create_mech_entry(kcf_ops_class_t class, const char *mechname)\n{\n\tif ((class < KCF_FIRST_OPSCLASS) || (class > KCF_LAST_OPSCLASS))\n\t\treturn (KCF_INVALID_MECH_CLASS);\n\n\tif ((mechname == NULL) || (mechname[0] == 0))\n\t\treturn (KCF_INVALID_MECH_NAME);\n\t \n\tavl_index_t where = 0;\n\tkcf_mech_entry_t tmptab;\n\tstrlcpy(tmptab.me_name, mechname, CRYPTO_MAX_MECH_NAME);\n\tif (avl_find(&kcf_mech_hash, &tmptab, &where) != NULL)\n\t\treturn (KCF_SUCCESS);\n\t \n\tkcf_mech_entry_t *me_tab = kcf_mech_tabs_tab[class].met_tab;\n\tint size = kcf_mech_tabs_tab[class].met_size;\n\n\tfor (int i = 0; i < size; ++i)\n\t\tif (me_tab[i].me_name[0] == 0) {\n\t\t\t \n\t\t\tstrlcpy(me_tab[i].me_name, mechname,\n\t\t\t    CRYPTO_MAX_MECH_NAME);\n\t\t\tme_tab[i].me_mechid = KCF_MECHID(class, i);\n\n\t\t\t \n\t\t\tavl_insert(&kcf_mech_hash, &me_tab[i], where);\n\t\t\treturn (KCF_SUCCESS);\n\t\t}\n\n\treturn (KCF_MECH_TAB_FULL);\n}\n\n \nint\nkcf_add_mech_provider(short mech_indx,\n    kcf_provider_desc_t *prov_desc, kcf_prov_mech_desc_t **pmdpp)\n{\n\tint error;\n\tkcf_mech_entry_t *mech_entry = NULL;\n\tconst crypto_mech_info_t *mech_info;\n\tcrypto_mech_type_t kcf_mech_type;\n\tkcf_prov_mech_desc_t *prov_mech;\n\n\tmech_info = &prov_desc->pd_mechanisms[mech_indx];\n\n\t \n\tkcf_mech_type = crypto_mech2id(mech_info->cm_mech_name);\n\tif (kcf_mech_type == CRYPTO_MECH_INVALID) {\n\t\tcrypto_func_group_t fg = mech_info->cm_func_group_mask;\n\t\tkcf_ops_class_t class;\n\n\t\tif (fg & CRYPTO_FG_DIGEST || fg & CRYPTO_FG_DIGEST_ATOMIC)\n\t\t\tclass = KCF_DIGEST_CLASS;\n\t\telse if (fg & CRYPTO_FG_ENCRYPT || fg & CRYPTO_FG_DECRYPT ||\n\t\t    fg & CRYPTO_FG_ENCRYPT_ATOMIC ||\n\t\t    fg & CRYPTO_FG_DECRYPT_ATOMIC)\n\t\t\tclass = KCF_CIPHER_CLASS;\n\t\telse if (fg & CRYPTO_FG_MAC || fg & CRYPTO_FG_MAC_ATOMIC)\n\t\t\tclass = KCF_MAC_CLASS;\n\t\telse\n\t\t\t__builtin_unreachable();\n\n\t\t \n\t\tif ((error = kcf_create_mech_entry(class,\n\t\t    mech_info->cm_mech_name)) != KCF_SUCCESS) {\n\t\t\treturn (error);\n\t\t}\n\t\t \n\t\tkcf_mech_type = crypto_mech2id(mech_info->cm_mech_name);\n\t\tASSERT(kcf_mech_type != CRYPTO_MECH_INVALID);\n\t}\n\n\terror = kcf_get_mech_entry(kcf_mech_type, &mech_entry);\n\tASSERT(error == KCF_SUCCESS);\n\n\t \n\tprov_mech = kmem_zalloc(sizeof (kcf_prov_mech_desc_t), KM_SLEEP);\n\tmemcpy(&prov_mech->pm_mech_info, mech_info,\n\t    sizeof (crypto_mech_info_t));\n\tprov_mech->pm_prov_desc = prov_desc;\n\tprov_desc->pd_mech_indx[KCF_MECH2CLASS(kcf_mech_type)]\n\t    [KCF_MECH2INDEX(kcf_mech_type)] = mech_indx;\n\n\tKCF_PROV_REFHOLD(prov_desc);\n\tKCF_PROV_IREFHOLD(prov_desc);\n\n\t \n\tif (mech_entry->me_sw_prov != NULL) {\n\t\t \n\t\tcmn_err(CE_WARN, \"The cryptographic provider \"\n\t\t    \"\\\"%s\\\" will not be used for %s. The provider \"\n\t\t    \"\\\"%s\\\" will be used for this mechanism \"\n\t\t    \"instead.\", prov_desc->pd_description,\n\t\t    mech_info->cm_mech_name,\n\t\t    mech_entry->me_sw_prov->pm_prov_desc->\n\t\t    pd_description);\n\t\tKCF_PROV_REFRELE(prov_desc);\n\t\tkmem_free(prov_mech, sizeof (kcf_prov_mech_desc_t));\n\t\tprov_mech = NULL;\n\t} else {\n\t\t \n\t\tmech_entry->me_sw_prov = prov_mech;\n\t}\n\n\t*pmdpp = prov_mech;\n\n\treturn (KCF_SUCCESS);\n}\n\n \nvoid\nkcf_remove_mech_provider(const char *mech_name, kcf_provider_desc_t *prov_desc)\n{\n\tcrypto_mech_type_t mech_type;\n\tkcf_prov_mech_desc_t *prov_mech = NULL;\n\tkcf_mech_entry_t *mech_entry;\n\n\t \n\tif ((mech_type = crypto_mech2id(mech_name)) ==\n\t    CRYPTO_MECH_INVALID) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (kcf_get_mech_entry(mech_type, &mech_entry) != KCF_SUCCESS) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (mech_entry->me_sw_prov == NULL ||\n\t    mech_entry->me_sw_prov->pm_prov_desc != prov_desc) {\n\t\t \n\t\treturn;\n\t}\n\tprov_mech = mech_entry->me_sw_prov;\n\tmech_entry->me_sw_prov = NULL;\n\n\t \n\tKCF_PROV_IREFRELE(prov_mech->pm_prov_desc);\n\tKCF_PROV_REFRELE(prov_mech->pm_prov_desc);\n\tkmem_free(prov_mech, sizeof (kcf_prov_mech_desc_t));\n}\n\n \nint\nkcf_get_mech_entry(crypto_mech_type_t mech_type, kcf_mech_entry_t **mep)\n{\n\tkcf_ops_class_t\t\tclass;\n\tint\t\t\tindex;\n\tconst kcf_mech_entry_tab_t\t*me_tab;\n\n\tASSERT(mep != NULL);\n\n\tclass = KCF_MECH2CLASS(mech_type);\n\n\tif ((class < KCF_FIRST_OPSCLASS) || (class > KCF_LAST_OPSCLASS)) {\n\t\t \n\t\treturn (KCF_INVALID_MECH_NUMBER);\n\t}\n\n\tme_tab = &kcf_mech_tabs_tab[class];\n\tindex = KCF_MECH2INDEX(mech_type);\n\n\tif ((index < 0) || (index >= me_tab->met_size)) {\n\t\treturn (KCF_INVALID_MECH_NUMBER);\n\t}\n\n\t*mep = &((me_tab->met_tab)[index]);\n\n\treturn (KCF_SUCCESS);\n}\n\n \n \ncrypto_mech_type_t\ncrypto_mech2id(const char *mechname)\n{\n\tkcf_mech_entry_t tmptab, *found;\n\tstrlcpy(tmptab.me_name, mechname, CRYPTO_MAX_MECH_NAME);\n\n\tif ((found = avl_find(&kcf_mech_hash, &tmptab, NULL))) {\n\t\tASSERT(found->me_mechid != CRYPTO_MECH_INVALID);\n\t\treturn (found->me_mechid);\n\t}\n\n\treturn (CRYPTO_MECH_INVALID);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(crypto_mech2id);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}