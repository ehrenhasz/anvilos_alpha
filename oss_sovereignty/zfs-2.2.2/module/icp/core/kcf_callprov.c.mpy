{
  "module_name": "kcf_callprov.c",
  "hash_id": "194363c72fa8088f59ffea9bbd3b73d9dc0d402bdf26f601ca1cd9099a56be33",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/core/kcf_callprov.c",
  "human_readable_source": " \n \n\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n#include <sys/crypto/sched_impl.h>\n\nvoid\nkcf_free_triedlist(kcf_prov_tried_t *list)\n{\n\tkcf_prov_tried_t *l;\n\n\twhile ((l = list) != NULL) {\n\t\tlist = list->pt_next;\n\t\tKCF_PROV_REFRELE(l->pt_pd);\n\t\tkmem_free(l, sizeof (kcf_prov_tried_t));\n\t}\n}\n\nkcf_prov_tried_t *\nkcf_insert_triedlist(kcf_prov_tried_t **list, kcf_provider_desc_t *pd,\n    int kmflag)\n{\n\tkcf_prov_tried_t *l;\n\n\tl = kmem_alloc(sizeof (kcf_prov_tried_t), kmflag);\n\tif (l == NULL)\n\t\treturn (NULL);\n\n\tl->pt_pd = pd;\n\tl->pt_next = *list;\n\t*list = l;\n\n\treturn (l);\n}\n\nstatic boolean_t\nis_in_triedlist(kcf_provider_desc_t *pd, kcf_prov_tried_t *triedl)\n{\n\twhile (triedl != NULL) {\n\t\tif (triedl->pt_pd == pd)\n\t\t\treturn (B_TRUE);\n\t\ttriedl = triedl->pt_next;\n\t}\n\n\treturn (B_FALSE);\n}\n\n \nkcf_provider_desc_t *\nkcf_get_mech_provider(crypto_mech_type_t mech_type, kcf_mech_entry_t **mepp,\n    int *error, kcf_prov_tried_t *triedl, crypto_func_group_t fg)\n{\n\tkcf_provider_desc_t *pd = NULL;\n\tkcf_prov_mech_desc_t *mdesc;\n\tkcf_ops_class_t class;\n\tint index;\n\tkcf_mech_entry_t *me;\n\tconst kcf_mech_entry_tab_t *me_tab;\n\n\tclass = KCF_MECH2CLASS(mech_type);\n\tif ((class < KCF_FIRST_OPSCLASS) || (class > KCF_LAST_OPSCLASS)) {\n\t\t*error = CRYPTO_MECHANISM_INVALID;\n\t\treturn (NULL);\n\t}\n\n\tme_tab = &kcf_mech_tabs_tab[class];\n\tindex = KCF_MECH2INDEX(mech_type);\n\tif ((index < 0) || (index >= me_tab->met_size)) {\n\t\t*error = CRYPTO_MECHANISM_INVALID;\n\t\treturn (NULL);\n\t}\n\n\tme = &((me_tab->met_tab)[index]);\n\tif (mepp != NULL)\n\t\t*mepp = me;\n\n\t \n\tif (pd == NULL && (mdesc = me->me_sw_prov) != NULL) {\n\t\tpd = mdesc->pm_prov_desc;\n\t\tif (!IS_FG_SUPPORTED(mdesc, fg) ||\n\t\t    !KCF_IS_PROV_USABLE(pd) ||\n\t\t    IS_PROVIDER_TRIED(pd, triedl))\n\t\t\tpd = NULL;\n\t}\n\n\tif (pd == NULL) {\n\t\t \n\t\tif (triedl == NULL)\n\t\t\t*error = CRYPTO_MECH_NOT_SUPPORTED;\n\t} else\n\t\tKCF_PROV_REFHOLD(pd);\n\n\treturn (pd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}