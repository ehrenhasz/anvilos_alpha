{
  "module_name": "kcf_prov_lib.c",
  "hash_id": "1e084e3cb5c5649341e51806f5351720de8c88f3a6171af6d22ce98bfbf39f9d",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/core/kcf_prov_lib.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n\n \n\n \nstatic int\ncrypto_uio_copy_to_data(crypto_data_t *data, uchar_t *buf, int len)\n{\n\tzfs_uio_t *uiop = data->cd_uio;\n\toff_t offset = data->cd_offset;\n\tsize_t length = len;\n\tuint_t vec_idx;\n\tsize_t cur_len;\n\tuchar_t *datap;\n\n\tASSERT(data->cd_format == CRYPTO_DATA_UIO);\n\tif (zfs_uio_segflg(uiop) != UIO_SYSSPACE) {\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t}\n\n\t \n\toffset = zfs_uio_index_at_offset(uiop, offset, &vec_idx);\n\n\tif (vec_idx == zfs_uio_iovcnt(uiop) && length > 0) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\twhile (vec_idx < zfs_uio_iovcnt(uiop) && length > 0) {\n\t\tcur_len = MIN(zfs_uio_iovlen(uiop, vec_idx) -\n\t\t    offset, length);\n\n\t\tdatap = (uchar_t *)(zfs_uio_iovbase(uiop, vec_idx) + offset);\n\t\tmemcpy(datap, buf, cur_len);\n\t\tbuf += cur_len;\n\n\t\tlength -= cur_len;\n\t\tvec_idx++;\n\t\toffset = 0;\n\t}\n\n\tif (vec_idx == zfs_uio_iovcnt(uiop) && length > 0) {\n\t\t \n\t\tdata->cd_length = len;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\ncrypto_put_output_data(uchar_t *buf, crypto_data_t *output, int len)\n{\n\tswitch (output->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tif (output->cd_raw.iov_len < len) {\n\t\t\toutput->cd_length = len;\n\t\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t\t}\n\t\tmemcpy((uchar_t *)(output->cd_raw.iov_base +\n\t\t    output->cd_offset), buf, len);\n\t\tbreak;\n\n\tcase CRYPTO_DATA_UIO:\n\t\treturn (crypto_uio_copy_to_data(output, buf, len));\n\tdefault:\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\ncrypto_update_iov(void *ctx, crypto_data_t *input, crypto_data_t *output,\n    int (*cipher)(void *, caddr_t, size_t, crypto_data_t *))\n{\n\tASSERT(input != output);\n\n\tif (input->cd_raw.iov_len < input->cd_length)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\treturn ((cipher)(ctx, input->cd_raw.iov_base + input->cd_offset,\n\t    input->cd_length, output));\n}\n\nint\ncrypto_update_uio(void *ctx, crypto_data_t *input, crypto_data_t *output,\n    int (*cipher)(void *, caddr_t, size_t, crypto_data_t *))\n{\n\tzfs_uio_t *uiop = input->cd_uio;\n\toff_t offset = input->cd_offset;\n\tsize_t length = input->cd_length;\n\tuint_t vec_idx;\n\tsize_t cur_len;\n\n\tASSERT(input != output);\n\n\tif (zfs_uio_segflg(input->cd_uio) != UIO_SYSSPACE) {\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t}\n\n\t \n\toffset = zfs_uio_index_at_offset(uiop, offset, &vec_idx);\n\tif (vec_idx == zfs_uio_iovcnt(uiop) && length > 0) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\t \n\twhile (vec_idx < zfs_uio_iovcnt(uiop) && length > 0) {\n\t\tcur_len = MIN(zfs_uio_iovlen(uiop, vec_idx) -\n\t\t    offset, length);\n\n\t\tint rv = (cipher)(ctx, zfs_uio_iovbase(uiop, vec_idx) + offset,\n\t\t    cur_len, output);\n\n\t\tif (rv != CRYPTO_SUCCESS) {\n\t\t\treturn (rv);\n\t\t}\n\t\tlength -= cur_len;\n\t\tvec_idx++;\n\t\toffset = 0;\n\t}\n\n\tif (vec_idx == zfs_uio_iovcnt(uiop) && length > 0) {\n\t\t \n\n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}