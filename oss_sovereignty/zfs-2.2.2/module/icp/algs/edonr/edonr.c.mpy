{
  "module_name": "edonr.c",
  "hash_id": "1ff0621a409ba50dbadcd53fa0538f42f688c54b9738e411d00668fe1900f403",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/edonr/edonr.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/string.h>\n#include <sys/edonr.h>\n\n \n#if defined(__GNUC__) && defined(_ILP32)\n#pragma GCC diagnostic ignored \"-Wframe-larger-than=\"\n#endif\n\n \n#define\tMEMORY_BARRIER   asm volatile(\"\" ::: \"memory\");\n\n#if defined(_ZFS_BIG_ENDIAN)\n#define\tld_swap64(s, d) (d = __builtin_bswap64(*(s)))\n#define\tst_swap64(s, d) (*(d) = __builtin_bswap64(s))\n#else\n#define\tld_swap64(s, d) (d = *(s))\n#define\tst_swap64(s, d) (*(d) = s)\n#endif\n\n#define\thashState512(x)\t((x)->pipe->p512)\n\n \n#define\trotl64(x, n)\t(((x) << (n)) | ((x) >> (64 - (n))))\n\n \nstatic const uint64_t i512p2[16] = {\n\t0x8081828384858687ull, 0x88898a8b8c8d8e8full,\n\t0x9091929394959697ull, 0x98999a9b9c9d9e9full,\n\t0xa0a1a2a3a4a5a6a7ull, 0xa8a9aaabacadaeafull,\n\t0xb0b1b2b3b4b5b6b7ull, 0xb8b9babbbcbdbebfull,\n\t0xc0c1c2c3c4c5c6c7ull, 0xc8c9cacbcccdcecfull,\n\t0xd0d1d2d3d4d5d6d7ull, 0xd8d9dadbdcdddedfull,\n\t0xe0e1e2e3e4e5e6e7ull, 0xe8e9eaebecedeeefull,\n\t0xf0f1f2f3f4f5f6f7ull, 0xf8f9fafbfcfdfeffull\n};\n\n#define\tLS1_512(x0, x1, x2, x3, x4, x5, x6, x7)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tMEMORY_BARRIER\t\t\t\t\t\\\n\tz1 = x0 + x4, z2 = x1 + x7; z5 = z1 + z2;\t\\\n\ts0 = 0xaaaaaaaaaaaaaaaaull + z5 + x2;\t\t\\\n\ts1 = rotl64(z5 + x3, 5);\t\t\t\\\n\ts2 = rotl64(z5 + x6, 15); z3 = x2 + x3;\t\t\\\n\ts5 = rotl64(z1 + z3 + x5, 40); z4 = x5 + x6;\t\\\n\ts6 = rotl64(z2 + z4 + x0, 50); z6 = z3 + z4;\t\\\n\ts3 = rotl64(z6 + x7, 22);\t\t\t\\\n\ts4 = rotl64(z6 + x1, 31);\t\t\t\\\n\ts7 = rotl64(z6 + x4, 59);\t\t\t\\\n}\n\n#define\tLS2_512(y0, y1, y2, y3, y4, y5, y6, y7)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tz1 = y0 + y1, z2 = y2 + y5; z6 = z1 + z2;\t\\\n\tt0  = ~0xaaaaaaaaaaaaaaaaull + z6 + y7;\t\t\\\n\tt2 = rotl64(z6 + y3, 19);\t\t\t\\\n\tz3 = y3 + y4, z5 = z1 + z3;\t\t\t\\\n\tt1 = rotl64(z5 + y6, 10);\t\t\t\\\n\tt4 = rotl64(z5 + y5, 36);\t\t\t\\\n\tz4 = y6 + y7, z8 = z3 + z4;\t\t\t\\\n\tt3 = rotl64(z8 + y2, 29);\t\t\t\\\n\tt7 = rotl64(z8 + y0, 55); z7 = z2 + z4;\t\t\\\n\tt5 = rotl64(z7 + y4, 44);\t\t\t\\\n\tt6 = rotl64(z7 + y1, 48);\t\t\t\\\n}\n\n#define\tQEF_512(r0, r1, r2, r3, r4, r5, r6, r7)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tz1 = s0 ^ s4, z5 = t0 ^ t1;\t\t\t\\\n\tr0 = (z1 ^ s1) + (z5 ^ t5); z8 = t6 ^ t7;\t\\\n\tr1 = (z1 ^ s7) + (t2 ^ z8); z3 = s2 ^ s3;\t\\\n\tr7 = (z3 ^ s5) + (t4 ^ z8); z7 = t3 ^ t4;\t\\\n\tr3 = (z3 ^ s4) + (t0 ^ z7); z4 = s5 ^ s6;\t\\\n\tr5 = (s3 ^ z4) + (z7 ^ t6); z6 = t2 ^ t5;\t\\\n\tr6 = (s2 ^ z4) + (z6 ^ t7); z2 = s1 ^ s7;\t\\\n\tr4 = (s0 ^ z2) + (t1 ^ z6);\t\t\t\\\n\tr2 = (z2 ^ s6) + (z5 ^ t3);\t\t\t\\\n}\n\nstatic inline size_t\nQ512(size_t bitlen, const uint64_t *data, uint64_t *p)\n{\n\tsize_t bl;\n\n\tfor (bl = bitlen; bl >= EdonR512_BLOCK_BITSIZE;\n\t    bl -= EdonR512_BLOCK_BITSIZE, data += 16) {\n\t\tuint64_t q0, q1, q2, q3, q4, q5, q6, q7;\n\t\tuint64_t p0, p1, p2, p3, p4, p5, p6, p7;\n\t\tuint64_t s0, s1, s2, s3, s4, s5, s6, s7;\n\t\tuint64_t t0, t1, t2, t3, t4, t5, t6, t7;\n\t\tuint64_t z1, z2, z3, z4, z5, z6, z7, z8;\n\n#if defined(_ZFS_BIG_ENDIAN)\n\t\tuint64_t swp0, swp1, swp2, swp3, swp4, swp5, swp6, swp7,\n\t\t    swp8, swp9, swp10, swp11, swp12, swp13, swp14, swp15;\n#define\td(j)\tswp##j\n#define\ts64(j)\tld_swap64((uint64_t *)data+j, swp##j)\n\t\ts64(0);\n\t\ts64(1);\n\t\ts64(2);\n\t\ts64(3);\n\t\ts64(4);\n\t\ts64(5);\n\t\ts64(6);\n\t\ts64(7);\n\t\ts64(8);\n\t\ts64(9);\n\t\ts64(10);\n\t\ts64(11);\n\t\ts64(12);\n\t\ts64(13);\n\t\ts64(14);\n\t\ts64(15);\n#else\n#define\td(j)\tdata[j]\n#endif\n\n\t\t \n\t\tLS1_512(d(15), d(14), d(13), d(12), d(11), d(10), d(9), d(8));\n\t\tLS2_512(d(0), d(1), d(2), d(3), d(4), d(5), d(6), d(7));\n\t\tQEF_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\n\t\tLS1_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tLS2_512(d(8), d(9), d(10), d(11), d(12), d(13), d(14), d(15));\n\t\tQEF_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\n\t\t \n\t\tLS1_512(p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);\n\t\tLS2_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tQEF_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\n\t\tLS1_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tLS2_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\t\tQEF_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\n\t\t \n\t\tLS1_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tLS2_512(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\n\t\tQEF_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\n\t\tLS1_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\t\tLS2_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tQEF_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\n\t\t \n\t\tLS1_512(d(7), d(6), d(5), d(4), d(3), d(2), d(1), d(0));\n\t\tLS2_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tQEF_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\n\t\tLS1_512(p0, p1, p2, p3, p4, p5, p6, p7);\n\t\tLS2_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\t\tQEF_512(q0, q1, q2, q3, q4, q5, q6, q7);\n\n\t\t \n\t\tp[0] ^= d(8) ^ p0;\n\t\tp[1] ^= d(9) ^ p1;\n\t\tp[2] ^= d(10) ^ p2;\n\t\tp[3] ^= d(11) ^ p3;\n\t\tp[4] ^= d(12) ^ p4;\n\t\tp[5] ^= d(13) ^ p5;\n\t\tp[6] ^= d(14) ^ p6;\n\t\tp[7] ^= d(15) ^ p7;\n\t\tp[8] ^= d(0) ^ q0;\n\t\tp[9] ^= d(1) ^ q1;\n\t\tp[10] ^= d(2) ^ q2;\n\t\tp[11] ^= d(3) ^ q3;\n\t\tp[12] ^= d(4) ^ q4;\n\t\tp[13] ^= d(5) ^ q5;\n\t\tp[14] ^= d(6) ^ q6;\n\t\tp[15] ^= d(7) ^ q7;\n\t}\n\n#undef s64\n#undef d\n\treturn (bitlen - bl);\n}\n\nvoid\nEdonRInit(EdonRState *state)\n{\n\tstate->bits_processed = 0;\n\tstate->unprocessed_bits = 0;\n\tmemcpy(hashState512(state)->DoublePipe, i512p2, sizeof (i512p2));\n}\n\nvoid\nEdonRUpdate(EdonRState *state, const uint8_t *data, size_t databitlen)\n{\n\tuint64_t *data64;\n\tsize_t bits_processed;\n\n\tif (state->unprocessed_bits > 0) {\n\t\t \n\t\tint LastBytes = (int)databitlen >> 3;\n\n\t\tASSERT(state->unprocessed_bits + databitlen <=\n\t\t    EdonR512_BLOCK_SIZE * 8);\n\n\t\tmemcpy(hashState512(state)->LastPart\n\t\t    + (state->unprocessed_bits >> 3), data, LastBytes);\n\t\tstate->unprocessed_bits += (int)databitlen;\n\t\tdatabitlen = state->unprocessed_bits;\n\t\t \n\t\tdata64 = (uint64_t *)hashState512(state)->LastPart;\n\t} else\n\t\t \n\t\tdata64 = (uint64_t *)data;\n\n\tbits_processed = Q512(databitlen, data64,\n\t    hashState512(state)->DoublePipe);\n\tstate->bits_processed += bits_processed;\n\tdatabitlen -= bits_processed;\n\tstate->unprocessed_bits = (int)databitlen;\n\tif (databitlen > 0) {\n\t\t \n\t\tint LastBytes = ((~(((-(int)databitlen) >> 3) & 0x03ff)) + 1) \\\n\t\t    & 0x03ff;\n\n\t\tdata64 += bits_processed >> 6;\t \n\t\tmemmove(hashState512(state)->LastPart, data64, LastBytes);\n\t}\n}\n\nvoid\nEdonRFinal(EdonRState *state, uint8_t *hashval)\n{\n\tuint64_t *data64, num_bits;\n\tsize_t databitlen;\n\tint LastByte, PadOnePosition;\n\n\tnum_bits = state->bits_processed + state->unprocessed_bits;\n\tLastByte = (int)state->unprocessed_bits >> 3;\n\tPadOnePosition = 7 - (state->unprocessed_bits & 0x07);\n\thashState512(state)->LastPart[LastByte] =\n\t    (hashState512(state)->LastPart[LastByte] \\\n\t    & (0xff << (PadOnePosition + 1))) ^ (0x01 << PadOnePosition);\n\t \n\tdata64 = (uint64_t *)hashState512(state)->LastPart;\n\n\tif (state->unprocessed_bits < 960) {\n\t\tmemset((hashState512(state)->LastPart) +\n\t\t    LastByte + 1, 0x00, EdonR512_BLOCK_SIZE - LastByte - 9);\n\t\tdatabitlen = EdonR512_BLOCK_SIZE * 8;\n#if defined(_ZFS_BIG_ENDIAN)\n\t\tst_swap64(num_bits, data64 + 15);\n#else\n\t\tdata64[15] = num_bits;\n#endif\n\t} else {\n\t\tmemset((hashState512(state)->LastPart) + LastByte + 1,\n\t\t    0x00, EdonR512_BLOCK_SIZE * 2 - LastByte - 9);\n\t\tdatabitlen = EdonR512_BLOCK_SIZE * 16;\n#if defined(_ZFS_BIG_ENDIAN)\n\t\tst_swap64(num_bits, data64 + 31);\n#else\n\t\tdata64[31] = num_bits;\n#endif\n\t}\n\n\tstate->bits_processed += Q512(databitlen, data64,\n\t    hashState512(state)->DoublePipe);\n\n#if defined(_ZFS_BIG_ENDIAN)\n\tdata64 = (uint64_t *)hashval;\n\tuint64_t *s64 = hashState512(state)->DoublePipe + 8;\n\tint j;\n\n\tfor (j = 0; j < EdonR512_DIGEST_SIZE >> 3; j++)\n\t\tst_swap64(s64[j], data64 + j);\n#else\n\tmemcpy(hashval, hashState512(state)->DoublePipe + 8,\n\t    EdonR512_DIGEST_SIZE);\n#endif\n}\n\nvoid\nEdonRHash(const uint8_t *data, size_t databitlen, uint8_t *hashval)\n{\n\tEdonRState state;\n\n\tEdonRInit(&state);\n\tEdonRUpdate(&state, data, databitlen);\n\tEdonRFinal(&state, hashval);\n}\n\n#ifdef _KERNEL\nEXPORT_SYMBOL(EdonRInit);\nEXPORT_SYMBOL(EdonRUpdate);\nEXPORT_SYMBOL(EdonRHash);\nEXPORT_SYMBOL(EdonRFinal);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}