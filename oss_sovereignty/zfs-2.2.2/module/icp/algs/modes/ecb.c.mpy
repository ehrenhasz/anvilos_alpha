{
  "module_name": "ecb.c",
  "hash_id": "1b0739464e50bf5d97231df68158eab2441ed0ee89cdad72c04f91bd3e894f34",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/modes/ecb.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n\n \nint\necb_cipher_contiguous_blocks(ecb_ctx_t *ctx, char *data, size_t length,\n    crypto_data_t *out, size_t block_size,\n    int (*cipher)(const void *ks, const uint8_t *pt, uint8_t *ct))\n{\n\tsize_t remainder = length;\n\tsize_t need = 0;\n\tuint8_t *datap = (uint8_t *)data;\n\tuint8_t *blockp;\n\tuint8_t *lastp;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\n\tif (length + ctx->ecb_remainder_len < block_size) {\n\t\t \n\t\tmemcpy((uint8_t *)ctx->ecb_remainder + ctx->ecb_remainder_len,\n\t\t    datap,\n\t\t    length);\n\t\tctx->ecb_remainder_len += length;\n\t\tctx->ecb_copy_to = datap;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tlastp = (uint8_t *)ctx->ecb_iv;\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\n\tdo {\n\t\t \n\t\tif (ctx->ecb_remainder_len > 0) {\n\t\t\tneed = block_size - ctx->ecb_remainder_len;\n\n\t\t\tif (need > remainder)\n\t\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\n\t\t\tmemcpy(&((uint8_t *)ctx->ecb_remainder)\n\t\t\t    [ctx->ecb_remainder_len], datap, need);\n\n\t\t\tblockp = (uint8_t *)ctx->ecb_remainder;\n\t\t} else {\n\t\t\tblockp = datap;\n\t\t}\n\n\t\tcipher(ctx->ecb_keysched, blockp, lastp);\n\t\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t\t    &out_data_1_len, &out_data_2, block_size);\n\n\t\t \n\t\tmemcpy(out_data_1, lastp, out_data_1_len);\n\t\tif (out_data_2 != NULL) {\n\t\t\tmemcpy(out_data_2, lastp + out_data_1_len,\n\t\t\t    block_size - out_data_1_len);\n\t\t}\n\t\t \n\t\tout->cd_offset += block_size;\n\n\t\t \n\t\tif (ctx->ecb_remainder_len != 0) {\n\t\t\tdatap += need;\n\t\t\tctx->ecb_remainder_len = 0;\n\t\t} else {\n\t\t\tdatap += block_size;\n\t\t}\n\n\t\tremainder = (size_t)&data[length] - (size_t)datap;\n\n\t\t \n\t\tif (remainder > 0 && remainder < block_size) {\n\t\t\tmemcpy(ctx->ecb_remainder, datap, remainder);\n\t\t\tctx->ecb_remainder_len = remainder;\n\t\t\tctx->ecb_copy_to = datap;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->ecb_copy_to = NULL;\n\n\t} while (remainder > 0);\n\nout:\n\treturn (CRYPTO_SUCCESS);\n}\n\nvoid *\necb_alloc_ctx(int kmflag)\n{\n\tecb_ctx_t *ecb_ctx;\n\n\tif ((ecb_ctx = kmem_zalloc(sizeof (ecb_ctx_t), kmflag)) == NULL)\n\t\treturn (NULL);\n\n\tecb_ctx->ecb_flags = ECB_MODE;\n\treturn (ecb_ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}