{
  "module_name": "ccm.c",
  "hash_id": "5a96cc75e495ec1d14e2d92201e76844607f3fcbfce261e21e422f591ccefd5b",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/modes/ccm.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n\n#ifdef HAVE_EFFICIENT_UNALIGNED_ACCESS\n#include <sys/byteorder.h>\n#define\tUNALIGNED_POINTERS_PERMITTED\n#endif\n\n \nint\nccm_mode_encrypt_contiguous_blocks(ccm_ctx_t *ctx, char *data, size_t length,\n    crypto_data_t *out, size_t block_size,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),\n    void (*copy_block)(uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tsize_t remainder = length;\n\tsize_t need = 0;\n\tuint8_t *datap = (uint8_t *)data;\n\tuint8_t *blockp;\n\tuint8_t *lastp;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\tuint64_t counter;\n\tuint8_t *mac_buf;\n\n\tif (length + ctx->ccm_remainder_len < block_size) {\n\t\t \n\t\tmemcpy((uint8_t *)ctx->ccm_remainder + ctx->ccm_remainder_len,\n\t\t    datap,\n\t\t    length);\n\t\tctx->ccm_remainder_len += length;\n\t\tctx->ccm_copy_to = datap;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\n\tmac_buf = (uint8_t *)ctx->ccm_mac_buf;\n\n\tdo {\n\t\t \n\t\tif (ctx->ccm_remainder_len > 0) {\n\t\t\tneed = block_size - ctx->ccm_remainder_len;\n\n\t\t\tif (need > remainder)\n\t\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\n\t\t\tmemcpy(&((uint8_t *)ctx->ccm_remainder)\n\t\t\t    [ctx->ccm_remainder_len], datap, need);\n\n\t\t\tblockp = (uint8_t *)ctx->ccm_remainder;\n\t\t} else {\n\t\t\tblockp = datap;\n\t\t}\n\n\t\t \n\t\txor_block(blockp, mac_buf);\n\t\tencrypt_block(ctx->ccm_keysched, mac_buf, mac_buf);\n\n\t\t \n\t\tencrypt_block(ctx->ccm_keysched, (uint8_t *)ctx->ccm_cb,\n\t\t    (uint8_t *)ctx->ccm_tmp);\n\n\t\tlastp = (uint8_t *)ctx->ccm_tmp;\n\n\t\t \n#ifdef _ZFS_LITTLE_ENDIAN\n\t\tcounter = ntohll(ctx->ccm_cb[1] & ctx->ccm_counter_mask);\n\t\tcounter = htonll(counter + 1);\n#else\n\t\tcounter = ctx->ccm_cb[1] & ctx->ccm_counter_mask;\n\t\tcounter++;\n#endif\t \n\t\tcounter &= ctx->ccm_counter_mask;\n\t\tctx->ccm_cb[1] =\n\t\t    (ctx->ccm_cb[1] & ~(ctx->ccm_counter_mask)) | counter;\n\n\t\t \n\t\txor_block(blockp, lastp);\n\n\t\tctx->ccm_processed_data_len += block_size;\n\n\t\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t\t    &out_data_1_len, &out_data_2, block_size);\n\n\t\t \n\t\tif (out_data_1_len == block_size) {\n\t\t\tcopy_block(lastp, out_data_1);\n\t\t} else {\n\t\t\tmemcpy(out_data_1, lastp, out_data_1_len);\n\t\t\tif (out_data_2 != NULL) {\n\t\t\t\tmemcpy(out_data_2,\n\t\t\t\t    lastp + out_data_1_len,\n\t\t\t\t    block_size - out_data_1_len);\n\t\t\t}\n\t\t}\n\t\t \n\t\tout->cd_offset += block_size;\n\n\t\t \n\t\tif (ctx->ccm_remainder_len != 0) {\n\t\t\tdatap += need;\n\t\t\tctx->ccm_remainder_len = 0;\n\t\t} else {\n\t\t\tdatap += block_size;\n\t\t}\n\n\t\tremainder = (size_t)&data[length] - (size_t)datap;\n\n\t\t \n\t\tif (remainder > 0 && remainder < block_size) {\n\t\t\tmemcpy(ctx->ccm_remainder, datap, remainder);\n\t\t\tctx->ccm_remainder_len = remainder;\n\t\t\tctx->ccm_copy_to = datap;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->ccm_copy_to = NULL;\n\n\t} while (remainder > 0);\n\nout:\n\treturn (CRYPTO_SUCCESS);\n}\n\nvoid\ncalculate_ccm_mac(ccm_ctx_t *ctx, uint8_t *ccm_mac,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *))\n{\n\tuint64_t counter;\n\tuint8_t *counterp, *mac_buf;\n\tint i;\n\n\tmac_buf = (uint8_t *)ctx->ccm_mac_buf;\n\n\t \n\tcounter = 0;\n\tctx->ccm_cb[1] = (ctx->ccm_cb[1] & ~(ctx->ccm_counter_mask)) | counter;\n\n\tcounterp = (uint8_t *)ctx->ccm_tmp;\n\tencrypt_block(ctx->ccm_keysched, (uint8_t *)ctx->ccm_cb, counterp);\n\n\t \n\tfor (i = 0; i < ctx->ccm_mac_len; i++) {\n\t\tccm_mac[i] = mac_buf[i] ^ counterp[i];\n\t}\n}\n\nint\nccm_encrypt_final(ccm_ctx_t *ctx, crypto_data_t *out, size_t block_size,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tuint8_t *lastp, *mac_buf, *ccm_mac_p, *macp = NULL;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\tint i;\n\n\tif (out->cd_length < (ctx->ccm_remainder_len + ctx->ccm_mac_len)) {\n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\t \n\tif ((ctx->ccm_processed_data_len + ctx->ccm_remainder_len)\n\t    != (ctx->ccm_data_len)) {\n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\tmac_buf = (uint8_t *)ctx->ccm_mac_buf;\n\n\tif (ctx->ccm_remainder_len > 0) {\n\n\t\t \n\t\tmacp = (uint8_t *)ctx->ccm_mac_input_buf;\n\t\tmemset(macp, 0, block_size);\n\n\t\t \n\t\tmemcpy(macp, ctx->ccm_remainder, ctx->ccm_remainder_len);\n\n\t\t \n\t\txor_block(macp, mac_buf);\n\t\tencrypt_block(ctx->ccm_keysched, mac_buf, mac_buf);\n\n\t\t \n\t\tlastp = (uint8_t *)ctx->ccm_tmp;\n\t\tencrypt_block(ctx->ccm_keysched, (uint8_t *)ctx->ccm_cb, lastp);\n\n\t\t \n\t\tfor (i = 0; i < ctx->ccm_remainder_len; i++) {\n\t\t\tmacp[i] ^= lastp[i];\n\t\t}\n\t\tctx->ccm_processed_data_len += ctx->ccm_remainder_len;\n\t}\n\n\t \n\tccm_mac_p = (uint8_t *)ctx->ccm_tmp;\n\tcalculate_ccm_mac(ctx, ccm_mac_p, encrypt_block);\n\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t    &out_data_1_len, &out_data_2,\n\t    ctx->ccm_remainder_len + ctx->ccm_mac_len);\n\n\tif (ctx->ccm_remainder_len > 0) {\n\t\t \n\t\tif (out_data_2 == NULL) {\n\t\t\t \n\t\t\tmemcpy(out_data_1, macp, ctx->ccm_remainder_len);\n\t\t\tmemcpy(out_data_1 + ctx->ccm_remainder_len, ccm_mac_p,\n\t\t\t    ctx->ccm_mac_len);\n\t\t} else {\n\t\t\tif (out_data_1_len < ctx->ccm_remainder_len) {\n\t\t\t\tsize_t data_2_len_used;\n\n\t\t\t\tmemcpy(out_data_1, macp, out_data_1_len);\n\n\t\t\t\tdata_2_len_used = ctx->ccm_remainder_len\n\t\t\t\t    - out_data_1_len;\n\n\t\t\t\tmemcpy(out_data_2,\n\t\t\t\t    (uint8_t *)macp + out_data_1_len,\n\t\t\t\t    data_2_len_used);\n\t\t\t\tmemcpy(out_data_2 + data_2_len_used,\n\t\t\t\t    ccm_mac_p,\n\t\t\t\t    ctx->ccm_mac_len);\n\t\t\t} else {\n\t\t\t\tmemcpy(out_data_1, macp, out_data_1_len);\n\t\t\t\tif (out_data_1_len == ctx->ccm_remainder_len) {\n\t\t\t\t\t \n\t\t\t\t\tmemcpy(out_data_2, ccm_mac_p,\n\t\t\t\t\t    ctx->ccm_mac_len);\n\t\t\t\t} else {\n\t\t\t\t\tsize_t len_not_used = out_data_1_len -\n\t\t\t\t\t    ctx->ccm_remainder_len;\n\t\t\t\t\t \n\t\t\t\t\tmemcpy(out_data_1 +\n\t\t\t\t\t    ctx->ccm_remainder_len,\n\t\t\t\t\t    ccm_mac_p, len_not_used);\n\t\t\t\t\tmemcpy(out_data_2,\n\t\t\t\t\t    ccm_mac_p + len_not_used,\n\t\t\t\t\t    ctx->ccm_mac_len - len_not_used);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(out_data_1, ccm_mac_p, out_data_1_len);\n\t\tif (out_data_2 != NULL) {\n\t\t\tmemcpy(out_data_2, ccm_mac_p + out_data_1_len,\n\t\t\t    block_size - out_data_1_len);\n\t\t}\n\t}\n\tout->cd_offset += ctx->ccm_remainder_len + ctx->ccm_mac_len;\n\tctx->ccm_remainder_len = 0;\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nstatic void\nccm_decrypt_incomplete_block(ccm_ctx_t *ctx,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *))\n{\n\tuint8_t *datap, *outp, *counterp;\n\tint i;\n\n\tdatap = (uint8_t *)ctx->ccm_remainder;\n\toutp = &((ctx->ccm_pt_buf)[ctx->ccm_processed_data_len]);\n\n\tcounterp = (uint8_t *)ctx->ccm_tmp;\n\tencrypt_block(ctx->ccm_keysched, (uint8_t *)ctx->ccm_cb, counterp);\n\n\t \n\tfor (i = 0; i < ctx->ccm_remainder_len; i++) {\n\t\toutp[i] = datap[i] ^ counterp[i];\n\t}\n}\n\n \nint\nccm_mode_decrypt_contiguous_blocks(ccm_ctx_t *ctx, char *data, size_t length,\n    crypto_data_t *out, size_t block_size,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),\n    void (*copy_block)(uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\t(void) out;\n\tsize_t remainder = length;\n\tsize_t need = 0;\n\tuint8_t *datap = (uint8_t *)data;\n\tuint8_t *blockp;\n\tuint8_t *cbp;\n\tuint64_t counter;\n\tsize_t pt_len, total_decrypted_len, mac_len, pm_len, pd_len;\n\tuint8_t *resultp;\n\n\n\tpm_len = ctx->ccm_processed_mac_len;\n\n\tif (pm_len > 0) {\n\t\tuint8_t *tmp;\n\t\t \n\t\tif ((pm_len + length) > ctx->ccm_mac_len) {\n\t\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\t\t}\n\t\ttmp = (uint8_t *)ctx->ccm_mac_input_buf;\n\n\t\tmemcpy(tmp + pm_len, datap, length);\n\n\t\tctx->ccm_processed_mac_len += length;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\t \n\tpd_len = ctx->ccm_processed_data_len;\n\ttotal_decrypted_len = pd_len + length + ctx->ccm_remainder_len;\n\n\tif (total_decrypted_len >\n\t    (ctx->ccm_data_len + ctx->ccm_mac_len)) {\n\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\t}\n\n\tpt_len = ctx->ccm_data_len;\n\n\tif (total_decrypted_len > pt_len) {\n\t\t \n\t\tsize_t pt_part = pt_len - pd_len - ctx->ccm_remainder_len;\n\n\t\tmac_len = length - pt_part;\n\n\t\tctx->ccm_processed_mac_len = mac_len;\n\t\tmemcpy(ctx->ccm_mac_input_buf, data + pt_part, mac_len);\n\n\t\tif (pt_part + ctx->ccm_remainder_len < block_size) {\n\t\t\t \n\t\t\tmemcpy(&((uint8_t *)ctx->ccm_remainder)\n\t\t\t    [ctx->ccm_remainder_len], datap, pt_part);\n\t\t\tctx->ccm_remainder_len += pt_part;\n\t\t\tccm_decrypt_incomplete_block(ctx, encrypt_block);\n\t\t\tctx->ccm_processed_data_len += ctx->ccm_remainder_len;\n\t\t\tctx->ccm_remainder_len = 0;\n\t\t\treturn (CRYPTO_SUCCESS);\n\t\t} else {\n\t\t\t \n\t\t\tlength = pt_part;\n\t\t}\n\t} else if (length + ctx->ccm_remainder_len < block_size) {\n\t\t \n\t\tmemcpy((uint8_t *)ctx->ccm_remainder + ctx->ccm_remainder_len,\n\t\t    datap,\n\t\t    length);\n\t\tctx->ccm_remainder_len += length;\n\t\tctx->ccm_copy_to = datap;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tdo {\n\t\t \n\t\tif (ctx->ccm_remainder_len > 0) {\n\t\t\tneed = block_size - ctx->ccm_remainder_len;\n\n\t\t\tif (need > remainder)\n\t\t\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\n\t\t\tmemcpy(&((uint8_t *)ctx->ccm_remainder)\n\t\t\t    [ctx->ccm_remainder_len], datap, need);\n\n\t\t\tblockp = (uint8_t *)ctx->ccm_remainder;\n\t\t} else {\n\t\t\tblockp = datap;\n\t\t}\n\n\t\t \n\t\tcbp = (uint8_t *)ctx->ccm_tmp;\n\t\tencrypt_block(ctx->ccm_keysched, (uint8_t *)ctx->ccm_cb, cbp);\n\n\t\t \n#ifdef _ZFS_LITTLE_ENDIAN\n\t\tcounter = ntohll(ctx->ccm_cb[1] & ctx->ccm_counter_mask);\n\t\tcounter = htonll(counter + 1);\n#else\n\t\tcounter = ctx->ccm_cb[1] & ctx->ccm_counter_mask;\n\t\tcounter++;\n#endif\t \n\t\tcounter &= ctx->ccm_counter_mask;\n\t\tctx->ccm_cb[1] =\n\t\t    (ctx->ccm_cb[1] & ~(ctx->ccm_counter_mask)) | counter;\n\n\t\t \n\t\txor_block(blockp, cbp);\n\n\t\t \n\t\tresultp = (uint8_t *)ctx->ccm_pt_buf +\n\t\t    ctx->ccm_processed_data_len;\n\t\tcopy_block(cbp, resultp);\n\n\t\tctx->ccm_processed_data_len += block_size;\n\n\t\tctx->ccm_lastp = blockp;\n\n\t\t \n\t\tif (ctx->ccm_remainder_len != 0) {\n\t\t\tdatap += need;\n\t\t\tctx->ccm_remainder_len = 0;\n\t\t} else {\n\t\t\tdatap += block_size;\n\t\t}\n\n\t\tremainder = (size_t)&data[length] - (size_t)datap;\n\n\t\t \n\t\tif (remainder > 0 && remainder < block_size) {\n\t\t\tmemcpy(ctx->ccm_remainder, datap, remainder);\n\t\t\tctx->ccm_remainder_len = remainder;\n\t\t\tctx->ccm_copy_to = datap;\n\t\t\tif (ctx->ccm_processed_mac_len > 0) {\n\t\t\t\t \n\t\t\t\tccm_decrypt_incomplete_block(ctx,\n\t\t\t\t    encrypt_block);\n\t\t\t\tctx->ccm_processed_data_len += remainder;\n\t\t\t\tctx->ccm_remainder_len = 0;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tctx->ccm_copy_to = NULL;\n\n\t} while (remainder > 0);\n\nout:\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\nccm_decrypt_final(ccm_ctx_t *ctx, crypto_data_t *out, size_t block_size,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),\n    void (*copy_block)(uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tsize_t mac_remain, pt_len;\n\tuint8_t *pt, *mac_buf, *macp, *ccm_mac_p;\n\tint rv;\n\n\tpt_len = ctx->ccm_data_len;\n\n\t \n\tif (out->cd_length < pt_len) {\n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\tpt = ctx->ccm_pt_buf;\n\tmac_remain = ctx->ccm_processed_data_len;\n\tmac_buf = (uint8_t *)ctx->ccm_mac_buf;\n\n\tmacp = (uint8_t *)ctx->ccm_tmp;\n\n\twhile (mac_remain > 0) {\n\t\tif (mac_remain < block_size) {\n\t\t\tmemset(macp, 0, block_size);\n\t\t\tmemcpy(macp, pt, mac_remain);\n\t\t\tmac_remain = 0;\n\t\t} else {\n\t\t\tcopy_block(pt, macp);\n\t\t\tmac_remain -= block_size;\n\t\t\tpt += block_size;\n\t\t}\n\n\t\t \n\t\txor_block(macp, mac_buf);\n\t\tencrypt_block(ctx->ccm_keysched, mac_buf, mac_buf);\n\t}\n\n\t \n\tccm_mac_p = (uint8_t *)ctx->ccm_tmp;\n\tcalculate_ccm_mac((ccm_ctx_t *)ctx, ccm_mac_p, encrypt_block);\n\n\t \n\tif (memcmp(ctx->ccm_mac_input_buf, ccm_mac_p, ctx->ccm_mac_len)) {\n\t\t \n\t\treturn (CRYPTO_INVALID_MAC);\n\t} else {\n\t\trv = crypto_put_output_data(ctx->ccm_pt_buf, out, pt_len);\n\t\tif (rv != CRYPTO_SUCCESS)\n\t\t\treturn (rv);\n\t\tout->cd_offset += pt_len;\n\t}\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\nccm_validate_args(CK_AES_CCM_PARAMS *ccm_param, boolean_t is_encrypt_init)\n{\n\tsize_t macSize, nonceSize;\n\tuint8_t q;\n\tuint64_t maxValue;\n\n\t \n\tmacSize = ccm_param->ulMACSize;\n\tif ((macSize < 4) || (macSize > 16) || ((macSize % 2) != 0)) {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\n\t \n\tnonceSize = ccm_param->ulNonceSize;\n\tif ((nonceSize < 7) || (nonceSize > 13)) {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\n\t \n\tq = (uint8_t)((15 - nonceSize) & 0xFF);\n\n\n\t \n\tif ((!is_encrypt_init) && (ccm_param->ulDataSize < macSize)) {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\n\t \n\tif (q < 8) {\n\t\tmaxValue = (1ULL << (q * 8)) - 1;\n\t} else {\n\t\tmaxValue = ULONG_MAX;\n\t}\n\n\tif (ccm_param->ulDataSize > maxValue) {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nstatic void\nccm_format_initial_blocks(uchar_t *nonce, ulong_t nonceSize,\n    ulong_t authDataSize, uint8_t *b0, ccm_ctx_t *aes_ctx)\n{\n\tuint64_t payloadSize;\n\tuint8_t t, q, have_adata = 0;\n\tsize_t limit;\n\tint i, j, k;\n\tuint64_t mask = 0;\n\tuint8_t *cb;\n\n\tq = (uint8_t)((15 - nonceSize) & 0xFF);\n\tt = (uint8_t)((aes_ctx->ccm_mac_len) & 0xFF);\n\n\t \n\tif (authDataSize > 0) {\n\t\thave_adata = 1;\n\t}\n\tb0[0] = (have_adata << 6) | (((t - 2)  / 2) << 3) | (q - 1);\n\n\t \n\tmemcpy(&(b0[1]), nonce, nonceSize);\n\n\t \n\tmemset(&(b0[1+nonceSize]), 0, q);\n\n\tpayloadSize = aes_ctx->ccm_data_len;\n\tlimit = MIN(8, q);\n\n\tfor (i = 0, j = 0, k = 15; i < limit; i++, j += 8, k--) {\n\t\tb0[k] = (uint8_t)((payloadSize >> j) & 0xFF);\n\t}\n\n\t \n\n\tcb = (uint8_t *)aes_ctx->ccm_cb;\n\n\tcb[0] = 0x07 & (q-1);  \n\n\t \n\tmemcpy(&(cb[1]), nonce, nonceSize);\n\n\tmemset(&(cb[1+nonceSize]), 0, q);\n\n\t \n\tq <<= 3;\n\twhile (q-- > 0) {\n\t\tmask |= (1ULL << q);\n\t}\n\n#ifdef _ZFS_LITTLE_ENDIAN\n\tmask = htonll(mask);\n#endif\n\taes_ctx->ccm_counter_mask = mask;\n\n\t \n\tcb[15] = 0x01;\n}\n\n \nstatic void\nencode_adata_len(ulong_t auth_data_len, uint8_t *encoded, size_t *encoded_len)\n{\n#ifdef UNALIGNED_POINTERS_PERMITTED\n\tuint32_t\t*lencoded_ptr;\n#ifdef _LP64\n\tuint64_t\t*llencoded_ptr;\n#endif\n#endif\t \n\n\tif (auth_data_len < ((1ULL<<16) - (1ULL<<8))) {\n\t\t \n\t\t*encoded_len = 2;\n\t\tencoded[0] = (auth_data_len & 0xff00) >> 8;\n\t\tencoded[1] = auth_data_len & 0xff;\n\n\t} else if ((auth_data_len >= ((1ULL<<16) - (1ULL<<8))) &&\n\t    (auth_data_len < (1ULL << 31))) {\n\t\t \n\t\t*encoded_len = 6;\n\t\tencoded[0] = 0xff;\n\t\tencoded[1] = 0xfe;\n#ifdef UNALIGNED_POINTERS_PERMITTED\n\t\tlencoded_ptr = (uint32_t *)&encoded[2];\n\t\t*lencoded_ptr = htonl(auth_data_len);\n#else\n\t\tencoded[2] = (auth_data_len & 0xff000000) >> 24;\n\t\tencoded[3] = (auth_data_len & 0xff0000) >> 16;\n\t\tencoded[4] = (auth_data_len & 0xff00) >> 8;\n\t\tencoded[5] = auth_data_len & 0xff;\n#endif\t \n\n#ifdef _LP64\n\t} else {\n\t\t \n\t\t*encoded_len = 10;\n\t\tencoded[0] = 0xff;\n\t\tencoded[1] = 0xff;\n#ifdef UNALIGNED_POINTERS_PERMITTED\n\t\tllencoded_ptr = (uint64_t *)&encoded[2];\n\t\t*llencoded_ptr = htonl(auth_data_len);\n#else\n\t\tencoded[2] = (auth_data_len & 0xff00000000000000) >> 56;\n\t\tencoded[3] = (auth_data_len & 0xff000000000000) >> 48;\n\t\tencoded[4] = (auth_data_len & 0xff0000000000) >> 40;\n\t\tencoded[5] = (auth_data_len & 0xff00000000) >> 32;\n\t\tencoded[6] = (auth_data_len & 0xff000000) >> 24;\n\t\tencoded[7] = (auth_data_len & 0xff0000) >> 16;\n\t\tencoded[8] = (auth_data_len & 0xff00) >> 8;\n\t\tencoded[9] = auth_data_len & 0xff;\n#endif\t \n#endif\t \n\t}\n}\n\nstatic int\nccm_init(ccm_ctx_t *ctx, unsigned char *nonce, size_t nonce_len,\n    unsigned char *auth_data, size_t auth_data_len, size_t block_size,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tuint8_t *mac_buf, *datap, *ivp, *authp;\n\tsize_t remainder, processed;\n\tuint8_t encoded_a[10];  \n\tsize_t encoded_a_len = 0;\n\n\tmac_buf = (uint8_t *)&(ctx->ccm_mac_buf);\n\n\t \n\tccm_format_initial_blocks(nonce, nonce_len,\n\t    auth_data_len, mac_buf, ctx);\n\n\t \n\tivp = (uint8_t *)ctx->ccm_tmp;\n\tmemset(ivp, 0, block_size);\n\n\txor_block(ivp, mac_buf);\n\n\t \n\tencrypt_block(ctx->ccm_keysched, mac_buf, mac_buf);\n\n\t \n\tif (auth_data_len == 0) {\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tencode_adata_len(auth_data_len, encoded_a, &encoded_a_len);\n\n\tremainder = auth_data_len;\n\n\t \n\tauthp = (uint8_t *)ctx->ccm_tmp;\n\tmemset(authp, 0, block_size);\n\tmemcpy(authp, encoded_a, encoded_a_len);\n\tprocessed = block_size - encoded_a_len;\n\tif (processed > auth_data_len) {\n\t\t \n\t\tprocessed = auth_data_len;\n\t}\n\tmemcpy(authp+encoded_a_len, auth_data, processed);\n\t \n\txor_block(authp, mac_buf);\n\tencrypt_block(ctx->ccm_keysched, mac_buf, mac_buf);\n\tremainder -= processed;\n\tif (remainder == 0) {\n\t\t \n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tdo {\n\t\tif (remainder < block_size) {\n\t\t\t \n\t\t\tmemset(authp, 0, block_size);\n\t\t\tmemcpy(authp, &(auth_data[processed]), remainder);\n\t\t\tdatap = (uint8_t *)authp;\n\t\t\tremainder = 0;\n\t\t} else {\n\t\t\tdatap = (uint8_t *)(&(auth_data[processed]));\n\t\t\tprocessed += block_size;\n\t\t\tremainder -= block_size;\n\t\t}\n\n\t\txor_block(datap, mac_buf);\n\t\tencrypt_block(ctx->ccm_keysched, mac_buf, mac_buf);\n\n\t} while (remainder > 0);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nint\nccm_init_ctx(ccm_ctx_t *ccm_ctx, char *param, int kmflag,\n    boolean_t is_encrypt_init, size_t block_size,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tint rv;\n\tCK_AES_CCM_PARAMS *ccm_param;\n\n\tif (param != NULL) {\n\t\tccm_param = (CK_AES_CCM_PARAMS *)param;\n\n\t\tif ((rv = ccm_validate_args(ccm_param,\n\t\t    is_encrypt_init)) != 0) {\n\t\t\treturn (rv);\n\t\t}\n\n\t\tccm_ctx->ccm_mac_len = ccm_param->ulMACSize;\n\t\tif (is_encrypt_init) {\n\t\t\tccm_ctx->ccm_data_len = ccm_param->ulDataSize;\n\t\t} else {\n\t\t\tccm_ctx->ccm_data_len =\n\t\t\t    ccm_param->ulDataSize - ccm_ctx->ccm_mac_len;\n\t\t\tccm_ctx->ccm_processed_mac_len = 0;\n\t\t}\n\t\tccm_ctx->ccm_processed_data_len = 0;\n\n\t\tccm_ctx->ccm_flags |= CCM_MODE;\n\t} else {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\n\tif (ccm_init(ccm_ctx, ccm_param->nonce, ccm_param->ulNonceSize,\n\t    ccm_param->authData, ccm_param->ulAuthDataSize, block_size,\n\t    encrypt_block, xor_block) != 0) {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\tif (!is_encrypt_init) {\n\t\t \n\t\tccm_ctx->ccm_pt_buf = vmem_alloc(ccm_ctx->ccm_data_len,\n\t\t    kmflag);\n\t\tif (ccm_ctx->ccm_pt_buf == NULL) {\n\t\t\trv = CRYPTO_HOST_MEMORY;\n\t\t}\n\t}\n\treturn (rv);\n}\n\nvoid *\nccm_alloc_ctx(int kmflag)\n{\n\tccm_ctx_t *ccm_ctx;\n\n\tif ((ccm_ctx = kmem_zalloc(sizeof (ccm_ctx_t), kmflag)) == NULL)\n\t\treturn (NULL);\n\n\tccm_ctx->ccm_flags = CCM_MODE;\n\treturn (ccm_ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}