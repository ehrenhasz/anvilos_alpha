{
  "module_name": "cbc.c",
  "hash_id": "bd4be7987408ac860e99070789786e853c69dff7196f6437623ad2fd6cdb375e",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/modes/cbc.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n\n \nint\ncbc_encrypt_contiguous_blocks(cbc_ctx_t *ctx, char *data, size_t length,\n    crypto_data_t *out, size_t block_size,\n    int (*encrypt)(const void *, const uint8_t *, uint8_t *),\n    void (*copy_block)(uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tsize_t remainder = length;\n\tsize_t need = 0;\n\tuint8_t *datap = (uint8_t *)data;\n\tuint8_t *blockp;\n\tuint8_t *lastp;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\n\tif (length + ctx->cbc_remainder_len < block_size) {\n\t\t \n\t\tmemcpy((uint8_t *)ctx->cbc_remainder + ctx->cbc_remainder_len,\n\t\t    datap,\n\t\t    length);\n\t\tctx->cbc_remainder_len += length;\n\t\tctx->cbc_copy_to = datap;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tlastp = (uint8_t *)ctx->cbc_iv;\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\n\tdo {\n\t\t \n\t\tif (ctx->cbc_remainder_len > 0) {\n\t\t\tneed = block_size - ctx->cbc_remainder_len;\n\n\t\t\tif (need > remainder)\n\t\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\n\t\t\tmemcpy(&((uint8_t *)ctx->cbc_remainder)\n\t\t\t    [ctx->cbc_remainder_len], datap, need);\n\n\t\t\tblockp = (uint8_t *)ctx->cbc_remainder;\n\t\t} else {\n\t\t\tblockp = datap;\n\t\t}\n\n\t\t \n\t\txor_block(blockp, lastp);\n\t\tencrypt(ctx->cbc_keysched, lastp, lastp);\n\t\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t\t    &out_data_1_len, &out_data_2, block_size);\n\n\t\t \n\t\tif (out_data_1_len == block_size) {\n\t\t\tcopy_block(lastp, out_data_1);\n\t\t} else {\n\t\t\tmemcpy(out_data_1, lastp, out_data_1_len);\n\t\t\tif (out_data_2 != NULL) {\n\t\t\t\tmemcpy(out_data_2,\n\t\t\t\t    lastp + out_data_1_len,\n\t\t\t\t    block_size - out_data_1_len);\n\t\t\t}\n\t\t}\n\t\t \n\t\tout->cd_offset += block_size;\n\n\t\t \n\t\tif (ctx->cbc_remainder_len != 0) {\n\t\t\tdatap += need;\n\t\t\tctx->cbc_remainder_len = 0;\n\t\t} else {\n\t\t\tdatap += block_size;\n\t\t}\n\n\t\tremainder = (size_t)&data[length] - (size_t)datap;\n\n\t\t \n\t\tif (remainder > 0 && remainder < block_size) {\n\t\t\tmemcpy(ctx->cbc_remainder, datap, remainder);\n\t\t\tctx->cbc_remainder_len = remainder;\n\t\t\tctx->cbc_copy_to = datap;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->cbc_copy_to = NULL;\n\n\t} while (remainder > 0);\n\nout:\n\t \n\tif (ctx->cbc_lastp != NULL) {\n\t\tcopy_block((uint8_t *)ctx->cbc_lastp, (uint8_t *)ctx->cbc_iv);\n\t\tctx->cbc_lastp = (uint8_t *)ctx->cbc_iv;\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n#define\tOTHER(a, ctx) \\\n\t(((a) == (ctx)->cbc_lastblock) ? (ctx)->cbc_iv : (ctx)->cbc_lastblock)\n\nint\ncbc_decrypt_contiguous_blocks(cbc_ctx_t *ctx, char *data, size_t length,\n    crypto_data_t *out, size_t block_size,\n    int (*decrypt)(const void *, const uint8_t *, uint8_t *),\n    void (*copy_block)(uint8_t *, uint8_t *),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tsize_t remainder = length;\n\tsize_t need = 0;\n\tuint8_t *datap = (uint8_t *)data;\n\tuint8_t *blockp;\n\tuint8_t *lastp;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\n\tif (length + ctx->cbc_remainder_len < block_size) {\n\t\t \n\t\tmemcpy((uint8_t *)ctx->cbc_remainder + ctx->cbc_remainder_len,\n\t\t    datap,\n\t\t    length);\n\t\tctx->cbc_remainder_len += length;\n\t\tctx->cbc_copy_to = datap;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tlastp = ctx->cbc_lastp;\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\n\tdo {\n\t\t \n\t\tif (ctx->cbc_remainder_len > 0) {\n\t\t\tneed = block_size - ctx->cbc_remainder_len;\n\n\t\t\tif (need > remainder)\n\t\t\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\n\t\t\tmemcpy(&((uint8_t *)ctx->cbc_remainder)\n\t\t\t    [ctx->cbc_remainder_len], datap, need);\n\n\t\t\tblockp = (uint8_t *)ctx->cbc_remainder;\n\t\t} else {\n\t\t\tblockp = datap;\n\t\t}\n\n\t\t \n\t\tcopy_block(blockp, (uint8_t *)OTHER((uint64_t *)lastp, ctx));\n\n\t\tdecrypt(ctx->cbc_keysched, blockp,\n\t\t    (uint8_t *)ctx->cbc_remainder);\n\t\tblockp = (uint8_t *)ctx->cbc_remainder;\n\n\t\t \n\t\txor_block(lastp, blockp);\n\n\t\t \n\t\tlastp = (uint8_t *)OTHER((uint64_t *)lastp, ctx);\n\n\t\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t\t    &out_data_1_len, &out_data_2, block_size);\n\n\t\tmemcpy(out_data_1, blockp, out_data_1_len);\n\t\tif (out_data_2 != NULL) {\n\t\t\tmemcpy(out_data_2, blockp + out_data_1_len,\n\t\t\t    block_size - out_data_1_len);\n\t\t}\n\n\t\t \n\t\tout->cd_offset += block_size;\n\n\t\t \n\t\tif (ctx->cbc_remainder_len != 0) {\n\t\t\tdatap += need;\n\t\t\tctx->cbc_remainder_len = 0;\n\t\t} else {\n\t\t\tdatap += block_size;\n\t\t}\n\n\t\tremainder = (size_t)&data[length] - (size_t)datap;\n\n\t\t \n\t\tif (remainder > 0 && remainder < block_size) {\n\t\t\tmemcpy(ctx->cbc_remainder, datap, remainder);\n\t\t\tctx->cbc_remainder_len = remainder;\n\t\t\tctx->cbc_lastp = lastp;\n\t\t\tctx->cbc_copy_to = datap;\n\t\t\treturn (CRYPTO_SUCCESS);\n\t\t}\n\t\tctx->cbc_copy_to = NULL;\n\n\t} while (remainder > 0);\n\n\tctx->cbc_lastp = lastp;\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\ncbc_init_ctx(cbc_ctx_t *cbc_ctx, char *param, size_t param_len,\n    size_t block_size, void (*copy_block)(uint8_t *, uint64_t *))\n{\n\t \n\tASSERT3P(param, !=, NULL);\n\tASSERT3U(param_len, ==, block_size);\n\n\tcopy_block((uchar_t *)param, cbc_ctx->cbc_iv);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nvoid *\ncbc_alloc_ctx(int kmflag)\n{\n\tcbc_ctx_t *cbc_ctx;\n\n\tif ((cbc_ctx = kmem_zalloc(sizeof (cbc_ctx_t), kmflag)) == NULL)\n\t\treturn (NULL);\n\n\tcbc_ctx->cbc_flags = CBC_MODE;\n\treturn (cbc_ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}