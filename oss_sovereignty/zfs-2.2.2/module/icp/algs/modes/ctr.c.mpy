{
  "module_name": "ctr.c",
  "hash_id": "f5e9d40b4458301a962df0372e83a055dd36528d8413430c754d4c19b87022bd",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/modes/ctr.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n#include <sys/byteorder.h>\n\n \nint\nctr_mode_contiguous_blocks(ctr_ctx_t *ctx, char *data, size_t length,\n    crypto_data_t *out, size_t block_size,\n    int (*cipher)(const void *ks, const uint8_t *pt, uint8_t *ct),\n    void (*xor_block)(uint8_t *, uint8_t *))\n{\n\tsize_t remainder = length;\n\tsize_t need = 0;\n\tuint8_t *datap = (uint8_t *)data;\n\tuint8_t *blockp;\n\tuint8_t *lastp;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\tuint64_t lower_counter, upper_counter;\n\n\tif (length + ctx->ctr_remainder_len < block_size) {\n\t\t \n\t\tmemcpy((uint8_t *)ctx->ctr_remainder + ctx->ctr_remainder_len,\n\t\t    datap,\n\t\t    length);\n\t\tctx->ctr_remainder_len += length;\n\t\tctx->ctr_copy_to = datap;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\n\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\n\tdo {\n\t\t \n\t\tif (ctx->ctr_remainder_len > 0) {\n\t\t\tneed = block_size - ctx->ctr_remainder_len;\n\n\t\t\tif (need > remainder)\n\t\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\n\t\t\tmemcpy(&((uint8_t *)ctx->ctr_remainder)\n\t\t\t    [ctx->ctr_remainder_len], datap, need);\n\n\t\t\tblockp = (uint8_t *)ctx->ctr_remainder;\n\t\t} else {\n\t\t\tblockp = datap;\n\t\t}\n\n\t\t \n\t\tcipher(ctx->ctr_keysched, (uint8_t *)ctx->ctr_cb,\n\t\t    (uint8_t *)ctx->ctr_tmp);\n\n\t\tlastp = (uint8_t *)ctx->ctr_tmp;\n\n\t\t \n\t\tlower_counter = ntohll(ctx->ctr_cb[1] & ctx->ctr_lower_mask);\n\t\tlower_counter = htonll(lower_counter + 1);\n\t\tlower_counter &= ctx->ctr_lower_mask;\n\t\tctx->ctr_cb[1] = (ctx->ctr_cb[1] & ~(ctx->ctr_lower_mask)) |\n\t\t    lower_counter;\n\n\t\t \n\t\tif (lower_counter == 0) {\n\t\t\tupper_counter =\n\t\t\t    ntohll(ctx->ctr_cb[0] & ctx->ctr_upper_mask);\n\t\t\tupper_counter = htonll(upper_counter + 1);\n\t\t\tupper_counter &= ctx->ctr_upper_mask;\n\t\t\tctx->ctr_cb[0] =\n\t\t\t    (ctx->ctr_cb[0] & ~(ctx->ctr_upper_mask)) |\n\t\t\t    upper_counter;\n\t\t}\n\n\t\t \n\t\txor_block(blockp, lastp);\n\n\t\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t\t    &out_data_1_len, &out_data_2, block_size);\n\n\t\t \n\t\tmemcpy(out_data_1, lastp, out_data_1_len);\n\t\tif (out_data_2 != NULL) {\n\t\t\tmemcpy(out_data_2, lastp + out_data_1_len,\n\t\t\t    block_size - out_data_1_len);\n\t\t}\n\t\t \n\t\tout->cd_offset += block_size;\n\n\t\t \n\t\tif (ctx->ctr_remainder_len != 0) {\n\t\t\tdatap += need;\n\t\t\tctx->ctr_remainder_len = 0;\n\t\t} else {\n\t\t\tdatap += block_size;\n\t\t}\n\n\t\tremainder = (size_t)&data[length] - (size_t)datap;\n\n\t\t \n\t\tif (remainder > 0 && remainder < block_size) {\n\t\t\tmemcpy(ctx->ctr_remainder, datap, remainder);\n\t\t\tctx->ctr_remainder_len = remainder;\n\t\t\tctx->ctr_copy_to = datap;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->ctr_copy_to = NULL;\n\n\t} while (remainder > 0);\n\nout:\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\nctr_mode_final(ctr_ctx_t *ctx, crypto_data_t *out,\n    int (*encrypt_block)(const void *, const uint8_t *, uint8_t *))\n{\n\tuint8_t *lastp;\n\tvoid *iov_or_mp;\n\toffset_t offset;\n\tuint8_t *out_data_1;\n\tuint8_t *out_data_2;\n\tsize_t out_data_1_len;\n\tuint8_t *p;\n\tint i;\n\n\tif (out->cd_length < ctx->ctr_remainder_len)\n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\n\tencrypt_block(ctx->ctr_keysched, (uint8_t *)ctx->ctr_cb,\n\t    (uint8_t *)ctx->ctr_tmp);\n\n\tlastp = (uint8_t *)ctx->ctr_tmp;\n\tp = (uint8_t *)ctx->ctr_remainder;\n\tfor (i = 0; i < ctx->ctr_remainder_len; i++) {\n\t\tp[i] ^= lastp[i];\n\t}\n\n\tcrypto_init_ptrs(out, &iov_or_mp, &offset);\n\tcrypto_get_ptrs(out, &iov_or_mp, &offset, &out_data_1,\n\t    &out_data_1_len, &out_data_2, ctx->ctr_remainder_len);\n\n\tmemcpy(out_data_1, p, out_data_1_len);\n\tif (out_data_2 != NULL) {\n\t\tmemcpy(out_data_2,\n\t\t    (uint8_t *)p + out_data_1_len,\n\t\t    ctx->ctr_remainder_len - out_data_1_len);\n\t}\n\tout->cd_offset += ctx->ctr_remainder_len;\n\tctx->ctr_remainder_len = 0;\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\nctr_init_ctx(ctr_ctx_t *ctr_ctx, ulong_t count, uint8_t *cb,\n    void (*copy_block)(uint8_t *, uint8_t *))\n{\n\tuint64_t upper_mask = 0;\n\tuint64_t lower_mask = 0;\n\n\tif (count == 0 || count > 128) {\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t}\n\t \n\tif (count >= 64) {\n\t\tcount -= 64;\n\t\tupper_mask = (count == 64) ? UINT64_MAX : (1ULL << count) - 1;\n\t\tlower_mask = UINT64_MAX;\n\t} else {\n\t\t \n\t\tlower_mask = (1ULL << count) - 1;\n\t}\n\tctr_ctx->ctr_lower_mask = htonll(lower_mask);\n\tctr_ctx->ctr_upper_mask = htonll(upper_mask);\n\n\tcopy_block(cb, (uchar_t *)ctr_ctx->ctr_cb);\n\tctr_ctx->ctr_lastp = (uint8_t *)&ctr_ctx->ctr_cb[0];\n\tctr_ctx->ctr_flags |= CTR_MODE;\n\treturn (CRYPTO_SUCCESS);\n}\n\nvoid *\nctr_alloc_ctx(int kmflag)\n{\n\tctr_ctx_t *ctr_ctx;\n\n\tif ((ctr_ctx = kmem_zalloc(sizeof (ctr_ctx_t), kmflag)) == NULL)\n\t\treturn (NULL);\n\n\tctr_ctx->ctr_flags = CTR_MODE;\n\treturn (ctr_ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}