{
  "module_name": "modes.c",
  "hash_id": "4728b5df0d95dc4319ecff42edd02a87b6ad8f56bacec797db80873837dc6bde",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/modes/modes.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n\n \nvoid\ncrypto_init_ptrs(crypto_data_t *out, void **iov_or_mp, offset_t *current_offset)\n{\n\toffset_t offset;\n\n\tswitch (out->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\t*current_offset = out->cd_offset;\n\t\tbreak;\n\n\tcase CRYPTO_DATA_UIO: {\n\t\tzfs_uio_t *uiop = out->cd_uio;\n\t\tuint_t vec_idx;\n\n\t\toffset = out->cd_offset;\n\t\toffset = zfs_uio_index_at_offset(uiop, offset, &vec_idx);\n\n\t\t*current_offset = offset;\n\t\t*iov_or_mp = (void *)(uintptr_t)vec_idx;\n\t\tbreak;\n\t}\n\t}  \n}\n\n \nvoid\ncrypto_get_ptrs(crypto_data_t *out, void **iov_or_mp, offset_t *current_offset,\n    uint8_t **out_data_1, size_t *out_data_1_len, uint8_t **out_data_2,\n    size_t amt)\n{\n\toffset_t offset;\n\n\tswitch (out->cd_format) {\n\tcase CRYPTO_DATA_RAW: {\n\t\tiovec_t *iov;\n\n\t\toffset = *current_offset;\n\t\tiov = &out->cd_raw;\n\t\tif ((offset + amt) <= iov->iov_len) {\n\t\t\t \n\t\t\t*out_data_1 = (uint8_t *)iov->iov_base + offset;\n\t\t\t*out_data_1_len = amt;\n\t\t\t*out_data_2 = NULL;\n\t\t\t*current_offset = offset + amt;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase CRYPTO_DATA_UIO: {\n\t\tzfs_uio_t *uio = out->cd_uio;\n\t\toffset_t offset;\n\t\tuint_t vec_idx;\n\t\tuint8_t *p;\n\t\tuint64_t iov_len;\n\t\tvoid *iov_base;\n\n\t\toffset = *current_offset;\n\t\tvec_idx = (uintptr_t)(*iov_or_mp);\n\t\tzfs_uio_iov_at_index(uio, vec_idx, &iov_base, &iov_len);\n\t\tp = (uint8_t *)iov_base + offset;\n\t\t*out_data_1 = p;\n\n\t\tif (offset + amt <= iov_len) {\n\t\t\t \n\t\t\t*out_data_1_len = amt;\n\t\t\t*out_data_2 = NULL;\n\t\t\t*current_offset = offset + amt;\n\t\t} else {\n\t\t\t \n\t\t\t*out_data_1_len = iov_len - offset;\n\t\t\tif (vec_idx == zfs_uio_iovcnt(uio)) {\n\t\t\t\t*out_data_2 = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec_idx++;\n\t\t\tzfs_uio_iov_at_index(uio, vec_idx, &iov_base, &iov_len);\n\t\t\t*out_data_2 = (uint8_t *)iov_base;\n\t\t\t*current_offset = amt - *out_data_1_len;\n\t\t}\n\t\t*iov_or_mp = (void *)(uintptr_t)vec_idx;\n\t\tbreak;\n\t}\n\t}  \n}\n\nvoid\ncrypto_free_mode_ctx(void *ctx)\n{\n\tcommon_ctx_t *common_ctx = (common_ctx_t *)ctx;\n\n\tswitch (common_ctx->cc_flags &\n\t    (ECB_MODE|CBC_MODE|CTR_MODE|CCM_MODE|GCM_MODE|GMAC_MODE)) {\n\tcase ECB_MODE:\n\t\tkmem_free(common_ctx, sizeof (ecb_ctx_t));\n\t\tbreak;\n\n\tcase CBC_MODE:\n\t\tkmem_free(common_ctx, sizeof (cbc_ctx_t));\n\t\tbreak;\n\n\tcase CTR_MODE:\n\t\tkmem_free(common_ctx, sizeof (ctr_ctx_t));\n\t\tbreak;\n\n\tcase CCM_MODE:\n\t\tif (((ccm_ctx_t *)ctx)->ccm_pt_buf != NULL)\n\t\t\tvmem_free(((ccm_ctx_t *)ctx)->ccm_pt_buf,\n\t\t\t    ((ccm_ctx_t *)ctx)->ccm_data_len);\n\n\t\tkmem_free(ctx, sizeof (ccm_ctx_t));\n\t\tbreak;\n\n\tcase GCM_MODE:\n\tcase GMAC_MODE:\n\t\tgcm_clear_ctx((gcm_ctx_t *)ctx);\n\t\tkmem_free(ctx, sizeof (gcm_ctx_t));\n\t}\n}\n\nstatic void *\nexplicit_memset(void *s, int c, size_t n)\n{\n\tmemset(s, c, n);\n\t__asm__ __volatile__(\"\" :: \"r\"(s) : \"memory\");\n\treturn (s);\n}\n\n \nvoid\ngcm_clear_ctx(gcm_ctx_t *ctx)\n{\n\texplicit_memset(ctx->gcm_remainder, 0, sizeof (ctx->gcm_remainder));\n\texplicit_memset(ctx->gcm_H, 0, sizeof (ctx->gcm_H));\n#if defined(CAN_USE_GCM_ASM)\n\tif (ctx->gcm_use_avx == B_TRUE) {\n\t\tASSERT3P(ctx->gcm_Htable, !=, NULL);\n\t\tmemset(ctx->gcm_Htable, 0, ctx->gcm_htab_len);\n\t\tkmem_free(ctx->gcm_Htable, ctx->gcm_htab_len);\n\t}\n#endif\n\tif (ctx->gcm_pt_buf != NULL) {\n\t\tmemset(ctx->gcm_pt_buf, 0, ctx->gcm_pt_buf_len);\n\t\tvmem_free(ctx->gcm_pt_buf, ctx->gcm_pt_buf_len);\n\t}\n\t \n\texplicit_memset(ctx->gcm_J0, 0, sizeof (ctx->gcm_J0));\n\texplicit_memset(ctx->gcm_tmp, 0, sizeof (ctx->gcm_tmp));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}