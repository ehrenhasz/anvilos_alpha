{
  "module_name": "skein.c",
  "hash_id": "38ce0813b32978c9623ec0cc1d4f14e356034f11aa078358beddf5a24648dc28",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/skein/skein.c",
  "human_readable_source": " \n \n\n#include <sys/sysmacros.h>\n#include <sys/types.h>\n#include <sys/skein.h>\t\t \n#include \"skein_impl.h\"\t\t \n\n \n \nint\nSkein_256_Init(Skein_256_Ctxt_t *ctx, size_t hashBitLen)\n{\n\tunion {\n\t\tuint8_t b[SKEIN_256_STATE_BYTES];\n\t\tuint64_t w[SKEIN_256_STATE_WORDS];\n\t} cfg;\t\t\t \n\n\tSkein_Assert(hashBitLen > 0, SKEIN_BAD_HASHLEN);\n\tctx->h.hashBitLen = hashBitLen;\t \n\n\tswitch (hashBitLen) {\t \n#ifndef\tSKEIN_NO_PRECOMP\n\tcase 256:\n\t\tmemcpy(ctx->X, SKEIN_256_IV_256, sizeof (ctx->X));\n\t\tbreak;\n\tcase 224:\n\t\tmemcpy(ctx->X, SKEIN_256_IV_224, sizeof (ctx->X));\n\t\tbreak;\n\tcase 160:\n\t\tmemcpy(ctx->X, SKEIN_256_IV_160, sizeof (ctx->X));\n\t\tbreak;\n\tcase 128:\n\t\tmemcpy(ctx->X, SKEIN_256_IV_128, sizeof (ctx->X));\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\t \n\t\t \n\t\tSkein_Start_New_Type(ctx, CFG_FINAL);\n\n\t\t \n\t\tcfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\n\t\t \n\t\tcfg.w[1] = Skein_Swap64(hashBitLen);\n\t\tcfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\n\t\t \n\t\tmemset(&cfg.w[3], 0, sizeof (cfg) - 3 * sizeof (cfg.w[0]));\n\n\t\t \n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t\tSkein_256_Process_Block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\n\t\tbreak;\n\t}\n\t \n\tSkein_Start_New_Type(ctx, MSG);\t \n\n\treturn (SKEIN_SUCCESS);\n}\n\n \n \nint\nSkein_256_InitExt(Skein_256_Ctxt_t *ctx, size_t hashBitLen, uint64_t treeInfo,\n    const uint8_t *key, size_t keyBytes)\n{\n\tunion {\n\t\tuint8_t b[SKEIN_256_STATE_BYTES];\n\t\tuint64_t w[SKEIN_256_STATE_WORDS];\n\t} cfg;\t\t\t \n\n\tSkein_Assert(hashBitLen > 0, SKEIN_BAD_HASHLEN);\n\tSkein_Assert(keyBytes == 0 || key != NULL, SKEIN_FAIL);\n\n\t \n\tif (keyBytes == 0) {\t \n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t} else {\t\t \n\n\t\tSkein_assert(sizeof (cfg.b) >= sizeof (ctx->X));\n\t\t \n\t\t \n\t\tctx->h.hashBitLen = 8 * sizeof (ctx->X);\n\t\t \n\t\tSkein_Start_New_Type(ctx, KEY);\n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t\t \n\t\t(void) Skein_256_Update(ctx, key, keyBytes);\n\t\t \n\t\t(void) Skein_256_Final_Pad(ctx, cfg.b);\n\t\t \n\t\tmemcpy(ctx->X, cfg.b, sizeof (cfg.b));\n#if\tSKEIN_NEED_SWAP\n\t\t{\n\t\t\tuint_t i;\n\t\t\t \n\t\t\tfor (i = 0; i < SKEIN_256_STATE_WORDS; i++)\n\t\t\t\tctx->X[i] = Skein_Swap64(ctx->X[i]);\n\t\t}\n#endif\n\t}\n\t \n\tctx->h.hashBitLen = hashBitLen;\t \n\tSkein_Start_New_Type(ctx, CFG_FINAL);\n\n\tmemset(&cfg.w, 0, sizeof (cfg.w));  \n\tcfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\n\tcfg.w[1] = Skein_Swap64(hashBitLen);\t \n\t \n\tcfg.w[2] = Skein_Swap64(treeInfo);\n\n\tSkein_Show_Key(256, &ctx->h, key, keyBytes);\n\n\t \n\tSkein_256_Process_Block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\n\n\t \n\t \n\tctx->h.bCnt = 0;\t \n\tSkein_Start_New_Type(ctx, MSG);\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein_256_Update(Skein_256_Ctxt_t *ctx, const uint8_t *msg, size_t msgByteCnt)\n{\n\tsize_t n;\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\tif (msgByteCnt + ctx->h.bCnt > SKEIN_256_BLOCK_BYTES) {\n\t\t \n\t\tif (ctx->h.bCnt) {\n\t\t\t \n\t\t\tn = SKEIN_256_BLOCK_BYTES - ctx->h.bCnt;\n\t\t\tif (n) {\n\t\t\t\t \n\t\t\t\tSkein_assert(n < msgByteCnt);\n\t\t\t\tmemcpy(&ctx->b[ctx->h.bCnt], msg, n);\n\t\t\t\tmsgByteCnt -= n;\n\t\t\t\tmsg += n;\n\t\t\t\tctx->h.bCnt += n;\n\t\t\t}\n\t\t\tSkein_assert(ctx->h.bCnt == SKEIN_256_BLOCK_BYTES);\n\t\t\tSkein_256_Process_Block(ctx, ctx->b, 1,\n\t\t\t    SKEIN_256_BLOCK_BYTES);\n\t\t\tctx->h.bCnt = 0;\n\t\t}\n\t\t \n\t\tif (msgByteCnt > SKEIN_256_BLOCK_BYTES) {\n\t\t\t \n\t\t\tn = (msgByteCnt - 1) / SKEIN_256_BLOCK_BYTES;\n\t\t\tSkein_256_Process_Block(ctx, msg, n,\n\t\t\t    SKEIN_256_BLOCK_BYTES);\n\t\t\tmsgByteCnt -= n * SKEIN_256_BLOCK_BYTES;\n\t\t\tmsg += n * SKEIN_256_BLOCK_BYTES;\n\t\t}\n\t\tSkein_assert(ctx->h.bCnt == 0);\n\t}\n\n\t \n\tif (msgByteCnt) {\n\t\tSkein_assert(msgByteCnt + ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES);\n\t\tmemcpy(&ctx->b[ctx->h.bCnt], msg, msgByteCnt);\n\t\tctx->h.bCnt += msgByteCnt;\n\t}\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein_256_Final(Skein_256_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\tsize_t i, n, byteCnt;\n\tuint64_t X[SKEIN_256_STATE_WORDS];\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\n\n\tctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;\t \n\t \n\tif (ctx->h.bCnt < SKEIN_256_BLOCK_BYTES)\n\t\tmemset(&ctx->b[ctx->h.bCnt], 0,\n\t\t    SKEIN_256_BLOCK_BYTES - ctx->h.bCnt);\n\n\t \n\tSkein_256_Process_Block(ctx, ctx->b, 1, ctx->h.bCnt);\n\n\t \n\t \n\tbyteCnt = (ctx->h.hashBitLen + 7) >> 3;\n\n\t \n\t \n\tmemset(ctx->b, 0, sizeof (ctx->b));\n\t \n\tmemcpy(X, ctx->X, sizeof (X));\n\tfor (i = 0; i * SKEIN_256_BLOCK_BYTES < byteCnt; i++) {\n\t\t \n\t\t*(uint64_t *)ctx->b = Skein_Swap64((uint64_t)i);\n\t\tSkein_Start_New_Type(ctx, OUT_FINAL);\n\t\t \n\t\tSkein_256_Process_Block(ctx, ctx->b, 1, sizeof (uint64_t));\n\t\t \n\t\tn = byteCnt - i * SKEIN_256_BLOCK_BYTES;\n\t\tif (n >= SKEIN_256_BLOCK_BYTES)\n\t\t\tn = SKEIN_256_BLOCK_BYTES;\n\t\tSkein_Put64_LSB_First(hashVal + i * SKEIN_256_BLOCK_BYTES,\n\t\t    ctx->X, n);\t \n\t\tSkein_Show_Final(256, &ctx->h, n,\n\t\t    hashVal + i * SKEIN_256_BLOCK_BYTES);\n\t\t \n\t\tmemcpy(ctx->X, X, sizeof (X));\n\t}\n\treturn (SKEIN_SUCCESS);\n}\n\n \n\n \nint\nSkein_512_Init(Skein_512_Ctxt_t *ctx, size_t hashBitLen)\n{\n\tunion {\n\t\tuint8_t b[SKEIN_512_STATE_BYTES];\n\t\tuint64_t w[SKEIN_512_STATE_WORDS];\n\t} cfg;\t\t\t \n\n\tSkein_Assert(hashBitLen > 0, SKEIN_BAD_HASHLEN);\n\tctx->h.hashBitLen = hashBitLen;\t \n\n\tswitch (hashBitLen) {\t \n#ifndef\tSKEIN_NO_PRECOMP\n\tcase 512:\n\t\tmemcpy(ctx->X, SKEIN_512_IV_512, sizeof (ctx->X));\n\t\tbreak;\n\tcase 384:\n\t\tmemcpy(ctx->X, SKEIN_512_IV_384, sizeof (ctx->X));\n\t\tbreak;\n\tcase 256:\n\t\tmemcpy(ctx->X, SKEIN_512_IV_256, sizeof (ctx->X));\n\t\tbreak;\n\tcase 224:\n\t\tmemcpy(ctx->X, SKEIN_512_IV_224, sizeof (ctx->X));\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\t \n\t\tSkein_Start_New_Type(ctx, CFG_FINAL);\n\n\t\t \n\t\tcfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\n\t\t \n\t\tcfg.w[1] = Skein_Swap64(hashBitLen);\n\t\tcfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\n\t\t \n\t\tmemset(&cfg.w[3], 0, sizeof (cfg) - 3 * sizeof (cfg.w[0]));\n\n\t\t \n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t\tSkein_512_Process_Block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\n\t\tbreak;\n\t}\n\n\t \n\tSkein_Start_New_Type(ctx, MSG);\t \n\n\treturn (SKEIN_SUCCESS);\n}\n\n \n \nint\nSkein_512_InitExt(Skein_512_Ctxt_t *ctx, size_t hashBitLen, uint64_t treeInfo,\n    const uint8_t *key, size_t keyBytes)\n{\n\tunion {\n\t\tuint8_t b[SKEIN_512_STATE_BYTES];\n\t\tuint64_t w[SKEIN_512_STATE_WORDS];\n\t} cfg;\t\t\t \n\n\tSkein_Assert(hashBitLen > 0, SKEIN_BAD_HASHLEN);\n\tSkein_Assert(keyBytes == 0 || key != NULL, SKEIN_FAIL);\n\n\t \n\tif (keyBytes == 0) {\t \n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t} else {\t\t \n\n\t\tSkein_assert(sizeof (cfg.b) >= sizeof (ctx->X));\n\t\t \n\t\t \n\t\tctx->h.hashBitLen = 8 * sizeof (ctx->X);\n\t\t \n\t\tSkein_Start_New_Type(ctx, KEY);\n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t\t(void) Skein_512_Update(ctx, key, keyBytes);  \n\t\t \n\t\t(void) Skein_512_Final_Pad(ctx, cfg.b);\n\t\t \n\t\tmemcpy(ctx->X, cfg.b, sizeof (cfg.b));\n#if\tSKEIN_NEED_SWAP\n\t\t{\n\t\t\tuint_t i;\n\t\t\t \n\t\t\tfor (i = 0; i < SKEIN_512_STATE_WORDS; i++)\n\t\t\t\tctx->X[i] = Skein_Swap64(ctx->X[i]);\n\t\t}\n#endif\n\t}\n\t \n\tctx->h.hashBitLen = hashBitLen;\t \n\tSkein_Start_New_Type(ctx, CFG_FINAL);\n\n\tmemset(&cfg.w, 0, sizeof (cfg.w));  \n\tcfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\n\tcfg.w[1] = Skein_Swap64(hashBitLen);\t \n\t \n\tcfg.w[2] = Skein_Swap64(treeInfo);\n\n\tSkein_Show_Key(512, &ctx->h, key, keyBytes);\n\n\t \n\tSkein_512_Process_Block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\n\n\t \n\t \n\tctx->h.bCnt = 0;\t \n\tSkein_Start_New_Type(ctx, MSG);\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein_512_Update(Skein_512_Ctxt_t *ctx, const uint8_t *msg, size_t msgByteCnt)\n{\n\tsize_t n;\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\tif (msgByteCnt + ctx->h.bCnt > SKEIN_512_BLOCK_BYTES) {\n\t\t \n\t\tif (ctx->h.bCnt) {\n\t\t\t \n\t\t\tn = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;\n\t\t\tif (n) {\n\t\t\t\t \n\t\t\t\tSkein_assert(n < msgByteCnt);\n\t\t\t\tmemcpy(&ctx->b[ctx->h.bCnt], msg, n);\n\t\t\t\tmsgByteCnt -= n;\n\t\t\t\tmsg += n;\n\t\t\t\tctx->h.bCnt += n;\n\t\t\t}\n\t\t\tSkein_assert(ctx->h.bCnt == SKEIN_512_BLOCK_BYTES);\n\t\t\tSkein_512_Process_Block(ctx, ctx->b, 1,\n\t\t\t    SKEIN_512_BLOCK_BYTES);\n\t\t\tctx->h.bCnt = 0;\n\t\t}\n\t\t \n\t\tif (msgByteCnt > SKEIN_512_BLOCK_BYTES) {\n\t\t\t \n\t\t\tn = (msgByteCnt - 1) / SKEIN_512_BLOCK_BYTES;\n\t\t\tSkein_512_Process_Block(ctx, msg, n,\n\t\t\t    SKEIN_512_BLOCK_BYTES);\n\t\t\tmsgByteCnt -= n * SKEIN_512_BLOCK_BYTES;\n\t\t\tmsg += n * SKEIN_512_BLOCK_BYTES;\n\t\t}\n\t\tSkein_assert(ctx->h.bCnt == 0);\n\t}\n\n\t \n\tif (msgByteCnt) {\n\t\tSkein_assert(msgByteCnt + ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES);\n\t\tmemcpy(&ctx->b[ctx->h.bCnt], msg, msgByteCnt);\n\t\tctx->h.bCnt += msgByteCnt;\n\t}\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein_512_Final(Skein_512_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\tsize_t i, n, byteCnt;\n\tuint64_t X[SKEIN_512_STATE_WORDS];\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\n\n\tctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;\t \n\t \n\tif (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES)\n\t\tmemset(&ctx->b[ctx->h.bCnt], 0,\n\t\t    SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);\n\n\t \n\tSkein_512_Process_Block(ctx, ctx->b, 1, ctx->h.bCnt);\n\n\t \n\t \n\tbyteCnt = (ctx->h.hashBitLen + 7) >> 3;\n\n\t \n\t \n\tmemset(ctx->b, 0, sizeof (ctx->b));\n\t \n\tmemcpy(X, ctx->X, sizeof (X));\n\tfor (i = 0; i * SKEIN_512_BLOCK_BYTES < byteCnt; i++) {\n\t\t \n\t\t*(uint64_t *)ctx->b = Skein_Swap64((uint64_t)i);\n\t\tSkein_Start_New_Type(ctx, OUT_FINAL);\n\t\t \n\t\tSkein_512_Process_Block(ctx, ctx->b, 1, sizeof (uint64_t));\n\t\t \n\t\tn = byteCnt - i * SKEIN_512_BLOCK_BYTES;\n\t\tif (n >= SKEIN_512_BLOCK_BYTES)\n\t\t\tn = SKEIN_512_BLOCK_BYTES;\n\t\tSkein_Put64_LSB_First(hashVal + i * SKEIN_512_BLOCK_BYTES,\n\t\t    ctx->X, n);\t \n\t\tSkein_Show_Final(512, &ctx->h, n,\n\t\t    hashVal + i * SKEIN_512_BLOCK_BYTES);\n\t\t \n\t\tmemcpy(ctx->X, X, sizeof (X));\n\t}\n\treturn (SKEIN_SUCCESS);\n}\n\n \n\n \nint\nSkein1024_Init(Skein1024_Ctxt_t *ctx, size_t hashBitLen)\n{\n\tunion {\n\t\tuint8_t b[SKEIN1024_STATE_BYTES];\n\t\tuint64_t w[SKEIN1024_STATE_WORDS];\n\t} cfg;\t\t\t \n\n\tSkein_Assert(hashBitLen > 0, SKEIN_BAD_HASHLEN);\n\tctx->h.hashBitLen = hashBitLen;\t \n\n\tswitch (hashBitLen) {\t \n#ifndef\tSKEIN_NO_PRECOMP\n\tcase 512:\n\t\tmemcpy(ctx->X, SKEIN1024_IV_512, sizeof (ctx->X));\n\t\tbreak;\n\tcase 384:\n\t\tmemcpy(ctx->X, SKEIN1024_IV_384, sizeof (ctx->X));\n\t\tbreak;\n\tcase 1024:\n\t\tmemcpy(ctx->X, SKEIN1024_IV_1024, sizeof (ctx->X));\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\t \n\t\t \n\t\tSkein_Start_New_Type(ctx, CFG_FINAL);\n\n\t\t \n\t\tcfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\n\t\t \n\t\tcfg.w[1] = Skein_Swap64(hashBitLen);\n\t\tcfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\n\t\t \n\t\tmemset(&cfg.w[3], 0, sizeof (cfg) - 3 * sizeof (cfg.w[0]));\n\n\t\t \n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t\tSkein1024_Process_Block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\n\t\tbreak;\n\t}\n\n\t \n\tSkein_Start_New_Type(ctx, MSG);\t \n\n\treturn (SKEIN_SUCCESS);\n}\n\n \n \nint\nSkein1024_InitExt(Skein1024_Ctxt_t *ctx, size_t hashBitLen, uint64_t treeInfo,\n    const uint8_t *key, size_t keyBytes)\n{\n\tunion {\n\t\tuint8_t b[SKEIN1024_STATE_BYTES];\n\t\tuint64_t w[SKEIN1024_STATE_WORDS];\n\t} cfg;\t\t\t \n\n\tSkein_Assert(hashBitLen > 0, SKEIN_BAD_HASHLEN);\n\tSkein_Assert(keyBytes == 0 || key != NULL, SKEIN_FAIL);\n\n\t \n\tif (keyBytes == 0) {\t \n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t} else {\t\t \n\t\tSkein_assert(sizeof (cfg.b) >= sizeof (ctx->X));\n\t\t \n\t\t \n\t\tctx->h.hashBitLen = 8 * sizeof (ctx->X);\n\t\t \n\t\tSkein_Start_New_Type(ctx, KEY);\n\t\t \n\t\tmemset(ctx->X, 0, sizeof (ctx->X));\n\t\t(void) Skein1024_Update(ctx, key, keyBytes);  \n\t\t \n\t\t(void) Skein1024_Final_Pad(ctx, cfg.b);\n\t\t \n\t\tmemcpy(ctx->X, cfg.b, sizeof (cfg.b));\n#if\tSKEIN_NEED_SWAP\n\t\t{\n\t\t\tuint_t i;\n\t\t\t \n\t\t\tfor (i = 0; i < SKEIN1024_STATE_WORDS; i++)\n\t\t\t\tctx->X[i] = Skein_Swap64(ctx->X[i]);\n\t\t}\n#endif\n\t}\n\t \n\tctx->h.hashBitLen = hashBitLen;\t \n\tSkein_Start_New_Type(ctx, CFG_FINAL);\n\n\tmemset(&cfg.w, 0, sizeof (cfg.w));  \n\tcfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\n\t \n\tcfg.w[1] = Skein_Swap64(hashBitLen);\n\t \n\tcfg.w[2] = Skein_Swap64(treeInfo);\n\n\tSkein_Show_Key(1024, &ctx->h, key, keyBytes);\n\n\t \n\tSkein1024_Process_Block(ctx, cfg.b, 1, SKEIN_CFG_STR_LEN);\n\n\t \n\t \n\tctx->h.bCnt = 0;\t \n\tSkein_Start_New_Type(ctx, MSG);\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein1024_Update(Skein1024_Ctxt_t *ctx, const uint8_t *msg, size_t msgByteCnt)\n{\n\tsize_t n;\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\tif (msgByteCnt + ctx->h.bCnt > SKEIN1024_BLOCK_BYTES) {\n\t\t \n\t\tif (ctx->h.bCnt) {\n\t\t\t \n\t\t\tn = SKEIN1024_BLOCK_BYTES - ctx->h.bCnt;\n\t\t\tif (n) {\n\t\t\t\t \n\t\t\t\tSkein_assert(n < msgByteCnt);\n\t\t\t\tmemcpy(&ctx->b[ctx->h.bCnt], msg, n);\n\t\t\t\tmsgByteCnt -= n;\n\t\t\t\tmsg += n;\n\t\t\t\tctx->h.bCnt += n;\n\t\t\t}\n\t\t\tSkein_assert(ctx->h.bCnt == SKEIN1024_BLOCK_BYTES);\n\t\t\tSkein1024_Process_Block(ctx, ctx->b, 1,\n\t\t\t    SKEIN1024_BLOCK_BYTES);\n\t\t\tctx->h.bCnt = 0;\n\t\t}\n\t\t \n\t\tif (msgByteCnt > SKEIN1024_BLOCK_BYTES) {\n\t\t\t \n\t\t\tn = (msgByteCnt - 1) / SKEIN1024_BLOCK_BYTES;\n\t\t\tSkein1024_Process_Block(ctx, msg, n,\n\t\t\t    SKEIN1024_BLOCK_BYTES);\n\t\t\tmsgByteCnt -= n * SKEIN1024_BLOCK_BYTES;\n\t\t\tmsg += n * SKEIN1024_BLOCK_BYTES;\n\t\t}\n\t\tSkein_assert(ctx->h.bCnt == 0);\n\t}\n\n\t \n\tif (msgByteCnt) {\n\t\tSkein_assert(msgByteCnt + ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES);\n\t\tmemcpy(&ctx->b[ctx->h.bCnt], msg, msgByteCnt);\n\t\tctx->h.bCnt += msgByteCnt;\n\t}\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein1024_Final(Skein1024_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\tsize_t i, n, byteCnt;\n\tuint64_t X[SKEIN1024_STATE_WORDS];\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES, SKEIN_FAIL);\n\n\tctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;\t \n\t \n\tif (ctx->h.bCnt < SKEIN1024_BLOCK_BYTES)\n\t\tmemset(&ctx->b[ctx->h.bCnt], 0,\n\t\t    SKEIN1024_BLOCK_BYTES - ctx->h.bCnt);\n\n\t \n\tSkein1024_Process_Block(ctx, ctx->b, 1, ctx->h.bCnt);\n\n\t \n\t \n\tbyteCnt = (ctx->h.hashBitLen + 7) >> 3;\n\n\t \n\t \n\tmemset(ctx->b, 0, sizeof (ctx->b));\n\t \n\tmemcpy(X, ctx->X, sizeof (X));\n\tfor (i = 0; i * SKEIN1024_BLOCK_BYTES < byteCnt; i++) {\n\t\t \n\t\t*(uint64_t *)ctx->b = Skein_Swap64((uint64_t)i);\n\t\tSkein_Start_New_Type(ctx, OUT_FINAL);\n\t\t \n\t\tSkein1024_Process_Block(ctx, ctx->b, 1, sizeof (uint64_t));\n\t\t \n\t\tn = byteCnt - i * SKEIN1024_BLOCK_BYTES;\n\t\tif (n >= SKEIN1024_BLOCK_BYTES)\n\t\t\tn = SKEIN1024_BLOCK_BYTES;\n\t\tSkein_Put64_LSB_First(hashVal + i * SKEIN1024_BLOCK_BYTES,\n\t\t    ctx->X, n);\t \n\t\tSkein_Show_Final(1024, &ctx->h, n,\n\t\t    hashVal + i * SKEIN1024_BLOCK_BYTES);\n\t\t \n\t\tmemcpy(ctx->X, X, sizeof (X));\n\t}\n\treturn (SKEIN_SUCCESS);\n}\n\n \n \n\n \nint\nSkein_256_Final_Pad(Skein_256_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\n\n\tctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;\t \n\t \n\tif (ctx->h.bCnt < SKEIN_256_BLOCK_BYTES)\n\t\tmemset(&ctx->b[ctx->h.bCnt], 0,\n\t\t    SKEIN_256_BLOCK_BYTES - ctx->h.bCnt);\n\t \n\tSkein_256_Process_Block(ctx, ctx->b, 1, ctx->h.bCnt);\n\n\t \n\tSkein_Put64_LSB_First(hashVal, ctx->X, SKEIN_256_BLOCK_BYTES);\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein_512_Final_Pad(Skein_512_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\n\n\tctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;\t \n\t \n\tif (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES)\n\t\tmemset(&ctx->b[ctx->h.bCnt], 0,\n\t\t    SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);\n\t \n\tSkein_512_Process_Block(ctx, ctx->b, 1, ctx->h.bCnt);\n\n\t \n\tSkein_Put64_LSB_First(hashVal, ctx->X, SKEIN_512_BLOCK_BYTES);\n\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein1024_Final_Pad(Skein1024_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\tctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;\n\t \n\tif (ctx->h.bCnt < SKEIN1024_BLOCK_BYTES)\n\t\tmemset(&ctx->b[ctx->h.bCnt], 0,\n\t\t    SKEIN1024_BLOCK_BYTES - ctx->h.bCnt);\n\t \n\tSkein1024_Process_Block(ctx, ctx->b, 1, ctx->h.bCnt);\n\n\t \n\tSkein_Put64_LSB_First(hashVal, ctx->X, SKEIN1024_BLOCK_BYTES);\n\n\treturn (SKEIN_SUCCESS);\n}\n\n#if\tSKEIN_TREE_HASH\n \nint\nSkein_256_Output(Skein_256_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\tsize_t i, n, byteCnt;\n\tuint64_t X[SKEIN_256_STATE_WORDS];\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\t \n\tbyteCnt = (ctx->h.hashBitLen + 7) >> 3;\n\n\t \n\t \n\tmemset(ctx->b, 0, sizeof (ctx->b));\n\t \n\tmemcpy(X, ctx->X, sizeof (X));\n\tfor (i = 0; i * SKEIN_256_BLOCK_BYTES < byteCnt; i++) {\n\t\t \n\t\t*(uint64_t *)ctx->b = Skein_Swap64((uint64_t)i);\n\t\tSkein_Start_New_Type(ctx, OUT_FINAL);\n\t\t \n\t\tSkein_256_Process_Block(ctx, ctx->b, 1, sizeof (uint64_t));\n\t\t \n\t\tn = byteCnt - i * SKEIN_256_BLOCK_BYTES;\n\t\tif (n >= SKEIN_256_BLOCK_BYTES)\n\t\t\tn = SKEIN_256_BLOCK_BYTES;\n\t\tSkein_Put64_LSB_First(hashVal + i * SKEIN_256_BLOCK_BYTES,\n\t\t    ctx->X, n);\t \n\t\tSkein_Show_Final(256, &ctx->h, n,\n\t\t    hashVal + i * SKEIN_256_BLOCK_BYTES);\n\t\t \n\t\tmemcpy(ctx->X, X, sizeof (X));\n\t}\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein_512_Output(Skein_512_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\tsize_t i, n, byteCnt;\n\tuint64_t X[SKEIN_512_STATE_WORDS];\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\t \n\tbyteCnt = (ctx->h.hashBitLen + 7) >> 3;\n\n\t \n\t \n\tmemset(ctx->b, 0, sizeof (ctx->b));\n\t \n\tmemcpy(X, ctx->X, sizeof (X));\n\tfor (i = 0; i * SKEIN_512_BLOCK_BYTES < byteCnt; i++) {\n\t\t \n\t\t*(uint64_t *)ctx->b = Skein_Swap64((uint64_t)i);\n\t\tSkein_Start_New_Type(ctx, OUT_FINAL);\n\t\t \n\t\tSkein_512_Process_Block(ctx, ctx->b, 1, sizeof (uint64_t));\n\t\t \n\t\tn = byteCnt - i * SKEIN_512_BLOCK_BYTES;\n\t\tif (n >= SKEIN_512_BLOCK_BYTES)\n\t\t\tn = SKEIN_512_BLOCK_BYTES;\n\t\tSkein_Put64_LSB_First(hashVal + i * SKEIN_512_BLOCK_BYTES,\n\t\t    ctx->X, n);\t \n\t\tSkein_Show_Final(256, &ctx->h, n,\n\t\t    hashVal + i * SKEIN_512_BLOCK_BYTES);\n\t\t \n\t\tmemcpy(ctx->X, X, sizeof (X));\n\t}\n\treturn (SKEIN_SUCCESS);\n}\n\n \nint\nSkein1024_Output(Skein1024_Ctxt_t *ctx, uint8_t *hashVal)\n{\n\tsize_t i, n, byteCnt;\n\tuint64_t X[SKEIN1024_STATE_WORDS];\n\n\t \n\tSkein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES, SKEIN_FAIL);\n\n\t \n\t \n\tbyteCnt = (ctx->h.hashBitLen + 7) >> 3;\n\n\t \n\t \n\tmemset(ctx->b, 0, sizeof (ctx->b));\n\t \n\tmemcpy(X, ctx->X, sizeof (X));\n\tfor (i = 0; i * SKEIN1024_BLOCK_BYTES < byteCnt; i++) {\n\t\t \n\t\t*(uint64_t *)ctx->b = Skein_Swap64((uint64_t)i);\n\t\tSkein_Start_New_Type(ctx, OUT_FINAL);\n\t\t \n\t\tSkein1024_Process_Block(ctx, ctx->b, 1, sizeof (uint64_t));\n\t\t \n\t\tn = byteCnt - i * SKEIN1024_BLOCK_BYTES;\n\t\tif (n >= SKEIN1024_BLOCK_BYTES)\n\t\t\tn = SKEIN1024_BLOCK_BYTES;\n\t\tSkein_Put64_LSB_First(hashVal + i * SKEIN1024_BLOCK_BYTES,\n\t\t    ctx->X, n);\t \n\t\tSkein_Show_Final(256, &ctx->h, n,\n\t\t    hashVal + i * SKEIN1024_BLOCK_BYTES);\n\t\t \n\t\tmemcpy(ctx->X, X, sizeof (X));\n\t}\n\treturn (SKEIN_SUCCESS);\n}\n#endif\n\n#ifdef _KERNEL\nEXPORT_SYMBOL(Skein_512_Init);\nEXPORT_SYMBOL(Skein_512_InitExt);\nEXPORT_SYMBOL(Skein_512_Update);\nEXPORT_SYMBOL(Skein_512_Final);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}