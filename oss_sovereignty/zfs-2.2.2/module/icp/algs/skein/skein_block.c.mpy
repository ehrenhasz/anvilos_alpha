{
  "module_name": "skein_block.c",
  "hash_id": "074347683da45ad22986b872d40fb6441488b2b419d4e3eadaf128e0bf90c50d",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/skein/skein_block.c",
  "human_readable_source": " \n \n\n#include <sys/skein.h>\n#include \"skein_impl.h\"\n#include <sys/isa_defs.h>\t \n\n#ifndef\tSKEIN_USE_ASM\n#define\tSKEIN_USE_ASM\t(0)\t \n#endif\n\n#ifndef\tSKEIN_LOOP\n \n#if defined(_ILP32) || defined(__powerpc)\t \n#if defined(__GNUC__) && !defined(__clang__)\n#pragma GCC diagnostic ignored \"-Wframe-larger-than=\"\n#endif\n \n#define\tSKEIN_LOOP 111\n#else\n \n#define\tSKEIN_LOOP 001\t\t \n#endif\n#endif\n\n \n#define\tBLK_BITS\t(WCNT*64)\n#define\tKW_TWK_BASE\t(0)\n#define\tKW_KEY_BASE\t(3)\n#define\tks\t\t(kw + KW_KEY_BASE)\n#define\tts\t\t(kw + KW_TWK_BASE)\n\n \n#define\tDebugSaveTweak(ctx)\n\n \n#if\t!(SKEIN_USE_ASM & 256)\nvoid\nSkein_256_Process_Block(Skein_256_Ctxt_t *ctx, const uint8_t *blkPtr,\n    size_t blkCnt, size_t byteCntAdd)\n{\n\tenum {\n\t\tWCNT = SKEIN_256_STATE_WORDS\n\t};\n#undef  RCNT\n#define\tRCNT  (SKEIN_256_ROUNDS_TOTAL / 8)\n\n#ifdef\tSKEIN_LOOP\t\t \n#define\tSKEIN_UNROLL_256 (((SKEIN_LOOP) / 100) % 10)\n#else\n#define\tSKEIN_UNROLL_256 (0)\n#endif\n\n#if\tSKEIN_UNROLL_256\n#if\t(RCNT % SKEIN_UNROLL_256)\n#error \"Invalid SKEIN_UNROLL_256\"\t \n#endif\n\tsize_t r;\n\t \n\tuint64_t kw[WCNT + 4 + RCNT * 2];\n#else\n\tuint64_t kw[WCNT + 4];\t \n#endif\n\t \n\tuint64_t X0, X1, X2, X3;\n\tuint64_t w[WCNT];\t\t \n#ifdef\tSKEIN_DEBUG\n\t \n\tconst uint64_t *Xptr[4];\n\tXptr[0] = &X0;\n\tXptr[1] = &X1;\n\tXptr[2] = &X2;\n\tXptr[3] = &X3;\n#endif\n\tSkein_assert(blkCnt != 0);\t \n\tts[0] = ctx->h.T[0];\n\tts[1] = ctx->h.T[1];\n\tdo {\n\t\t \n\t\tts[0] += byteCntAdd;\t \n\n\t\t \n\t\tks[0] = ctx->X[0];\n\t\tks[1] = ctx->X[1];\n\t\tks[2] = ctx->X[2];\n\t\tks[3] = ctx->X[3];\n\t\tks[4] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ SKEIN_KS_PARITY;\n\n\t\tts[2] = ts[0] ^ ts[1];\n\n\t\t \n\t\tSkein_Get64_LSB_First(w, blkPtr, WCNT);\n\t\tDebugSaveTweak(ctx);\n\t\tSkein_Show_Block(BLK_BITS, &ctx->h, ctx->X, blkPtr, w, ks, ts);\n\n\t\tX0 = w[0] + ks[0];\t \n\t\tX1 = w[1] + ks[1] + ts[0];\n\t\tX2 = w[2] + ks[2] + ts[1];\n\t\tX3 = w[3] + ks[3];\n\n\t\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INITIAL,\n\t\t    Xptr);\t \n\n\t\tblkPtr += SKEIN_256_BLOCK_BYTES;\n\n\t\t \n\n#define\tRound256(p0, p1, p2, p3, ROT, rNum)                          \\\n\tX##p0 += X##p1; X##p1 = RotL_64(X##p1, ROT##_0); X##p1 ^= X##p0; \\\n\tX##p2 += X##p3; X##p3 = RotL_64(X##p3, ROT##_1); X##p3 ^= X##p2; \\\n\n#if\tSKEIN_UNROLL_256 == 0\n#define\tR256(p0, p1, p2, p3, ROT, rNum)\t\t \t\\\n\tRound256(p0, p1, p2, p3, ROT, rNum)\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, rNum, Xptr);\n\n#define\tI256(R)\t\t\t\t\t\t\t\t\\\n\tX0 += ks[((R) + 1) % 5];   \\\n\tX1 += ks[((R) + 2) % 5] + ts[((R) + 1) % 3];\t\t\t\\\n\tX2 += ks[((R) + 3) % 5] + ts[((R) + 2) % 3];\t\t\t\\\n\tX3 += ks[((R) + 4) % 5] + (R) + 1;\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, Xptr);\n#else\t\t\t\t \n#define\tR256(p0, p1, p2, p3, ROT, rNum)                             \\\n\tRound256(p0, p1, p2, p3, ROT, rNum)                             \\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, 4 * (r - 1) + rNum, Xptr);\n\n#define\tI256(R)\t\t\t\t\t\t\t\t\\\n\tX0 += ks[r + (R) + 0];\t \t\\\n\tX1 += ks[r + (R) + 1] + ts[r + (R) + 0];\t\t\t\\\n\tX2 += ks[r + (R) + 2] + ts[r + (R) + 1];\t\t\t\\\n\tX3 += ks[r + (R) + 3] + r + (R);\t\t\t\t\\\n\tks[r + (R) + 4] = ks[r + (R) - 1];    \t\\\n\tts[r + (R) + 2] = ts[r + (R) - 1];\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, Xptr);\n\n\t\t \n\t\tfor (r = 1; r < 2 * RCNT; r += 2 * SKEIN_UNROLL_256)\n#endif\n\t\t{\n#define\tR256_8_rounds(R)                         \\\n\tR256(0, 1, 2, 3, R_256_0, 8 * (R) + 1);  \\\n\tR256(0, 3, 2, 1, R_256_1, 8 * (R) + 2);  \\\n\tR256(0, 1, 2, 3, R_256_2, 8 * (R) + 3);  \\\n\tR256(0, 3, 2, 1, R_256_3, 8 * (R) + 4);  \\\n\tI256(2 * (R));                           \\\n\tR256(0, 1, 2, 3, R_256_4, 8 * (R) + 5);  \\\n\tR256(0, 3, 2, 1, R_256_5, 8 * (R) + 6);  \\\n\tR256(0, 1, 2, 3, R_256_6, 8 * (R) + 7);  \\\n\tR256(0, 3, 2, 1, R_256_7, 8 * (R) + 8);  \\\n\tI256(2 * (R) + 1);\n\n\t\t\tR256_8_rounds(0);\n\n#define\tR256_Unroll_R(NN) \\\n\t((SKEIN_UNROLL_256 == 0 && SKEIN_256_ROUNDS_TOTAL / 8 > (NN)) || \\\n\t(SKEIN_UNROLL_256 > (NN)))\n\n#if\tR256_Unroll_R(1)\n\t\t\tR256_8_rounds(1);\n#endif\n#if\tR256_Unroll_R(2)\n\t\t\tR256_8_rounds(2);\n#endif\n#if\tR256_Unroll_R(3)\n\t\t\tR256_8_rounds(3);\n#endif\n#if\tR256_Unroll_R(4)\n\t\t\tR256_8_rounds(4);\n#endif\n#if\tR256_Unroll_R(5)\n\t\t\tR256_8_rounds(5);\n#endif\n#if\tR256_Unroll_R(6)\n\t\t\tR256_8_rounds(6);\n#endif\n#if\tR256_Unroll_R(7)\n\t\t\tR256_8_rounds(7);\n#endif\n#if\tR256_Unroll_R(8)\n\t\t\tR256_8_rounds(8);\n#endif\n#if\tR256_Unroll_R(9)\n\t\t\tR256_8_rounds(9);\n#endif\n#if\tR256_Unroll_R(10)\n\t\t\tR256_8_rounds(10);\n#endif\n#if\tR256_Unroll_R(11)\n\t\t\tR256_8_rounds(11);\n#endif\n#if\tR256_Unroll_R(12)\n\t\t\tR256_8_rounds(12);\n#endif\n#if\tR256_Unroll_R(13)\n\t\t\tR256_8_rounds(13);\n#endif\n#if\tR256_Unroll_R(14)\n\t\t\tR256_8_rounds(14);\n#endif\n#if\t(SKEIN_UNROLL_256 > 14)\n#error  \"need more unrolling in Skein_256_Process_Block\"\n#endif\n\t\t}\n\t\t \n\t\tctx->X[0] = X0 ^ w[0];\n\t\tctx->X[1] = X1 ^ w[1];\n\t\tctx->X[2] = X2 ^ w[2];\n\t\tctx->X[3] = X3 ^ w[3];\n\n\t\tSkein_Show_Round(BLK_BITS, &ctx->h, SKEIN_RND_FEED_FWD, ctx->X);\n\n\t\tts[1] &= ~SKEIN_T1_FLAG_FIRST;\n\t} while (--blkCnt);\n\tctx->h.T[0] = ts[0];\n\tctx->h.T[1] = ts[1];\n}\n\n#if\tdefined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\nsize_t\nSkein_256_Process_Block_CodeSize(void)\n{\n\treturn ((uint8_t *)Skein_256_Process_Block_CodeSize) -\n\t    ((uint8_t *)Skein_256_Process_Block);\n}\n\nuint_t\nSkein_256_Unroll_Cnt(void)\n{\n\treturn (SKEIN_UNROLL_256);\n}\n#endif\n#endif\n\n \n#if\t!(SKEIN_USE_ASM & 512)\nvoid\nSkein_512_Process_Block(Skein_512_Ctxt_t *ctx, const uint8_t *blkPtr,\n    size_t blkCnt, size_t byteCntAdd)\n{\n\tenum {\n\t\tWCNT = SKEIN_512_STATE_WORDS\n\t};\n#undef  RCNT\n#define\tRCNT  (SKEIN_512_ROUNDS_TOTAL / 8)\n\n#ifdef\tSKEIN_LOOP\t\t \n#define\tSKEIN_UNROLL_512 (((SKEIN_LOOP) / 10) % 10)\n#else\n#define\tSKEIN_UNROLL_512 (0)\n#endif\n\n#if\tSKEIN_UNROLL_512\n#if\t(RCNT % SKEIN_UNROLL_512)\n#error \"Invalid SKEIN_UNROLL_512\"\t \n#endif\n\tsize_t r;\n\t \n\tuint64_t kw[WCNT + 4 + RCNT * 2];\n#else\n\tuint64_t kw[WCNT + 4];\t \n#endif\n\t \n\tuint64_t X0, X1, X2, X3, X4, X5, X6, X7;\n\tuint64_t w[WCNT];\t\t \n#ifdef\tSKEIN_DEBUG\n\t \n\tconst uint64_t *Xptr[8];\n\tXptr[0] = &X0;\n\tXptr[1] = &X1;\n\tXptr[2] = &X2;\n\tXptr[3] = &X3;\n\tXptr[4] = &X4;\n\tXptr[5] = &X5;\n\tXptr[6] = &X6;\n\tXptr[7] = &X7;\n#endif\n\n\tSkein_assert(blkCnt != 0);\t \n\tts[0] = ctx->h.T[0];\n\tts[1] = ctx->h.T[1];\n\tdo {\n\t\t \n\t\tts[0] += byteCntAdd;\t \n\n\t\t \n\t\tks[0] = ctx->X[0];\n\t\tks[1] = ctx->X[1];\n\t\tks[2] = ctx->X[2];\n\t\tks[3] = ctx->X[3];\n\t\tks[4] = ctx->X[4];\n\t\tks[5] = ctx->X[5];\n\t\tks[6] = ctx->X[6];\n\t\tks[7] = ctx->X[7];\n\t\tks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^\n\t\t    ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;\n\n\t\tts[2] = ts[0] ^ ts[1];\n\n\t\t \n\t\tSkein_Get64_LSB_First(w, blkPtr, WCNT);\n\t\tDebugSaveTweak(ctx);\n\t\tSkein_Show_Block(BLK_BITS, &ctx->h, ctx->X, blkPtr, w, ks, ts);\n\n\t\tX0 = w[0] + ks[0];\t \n\t\tX1 = w[1] + ks[1];\n\t\tX2 = w[2] + ks[2];\n\t\tX3 = w[3] + ks[3];\n\t\tX4 = w[4] + ks[4];\n\t\tX5 = w[5] + ks[5] + ts[0];\n\t\tX6 = w[6] + ks[6] + ts[1];\n\t\tX7 = w[7] + ks[7];\n\n\t\tblkPtr += SKEIN_512_BLOCK_BYTES;\n\n\t\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INITIAL,\n\t\t    Xptr);\n\t\t \n#define\tRound512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, rNum)\t\t\\\n\tX##p0 += X##p1; X##p1 = RotL_64(X##p1, ROT##_0); X##p1 ^= X##p0;\\\n\tX##p2 += X##p3; X##p3 = RotL_64(X##p3, ROT##_1); X##p3 ^= X##p2;\\\n\tX##p4 += X##p5; X##p5 = RotL_64(X##p5, ROT##_2); X##p5 ^= X##p4;\\\n\tX##p6 += X##p7; X##p7 = RotL_64(X##p7, ROT##_3); X##p7 ^= X##p6;\n\n#if\tSKEIN_UNROLL_512 == 0\n#define\tR512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, rNum)\t \t\\\n\tRound512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, rNum)\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, rNum, Xptr);\n\n#define\tI512(R)\t\t\t\t\t\t\t\t\\\n\tX0 += ks[((R) + 1) % 9];\t \\\n\tX1 += ks[((R) + 2) % 9];\t\t\t\t\t\\\n\tX2 += ks[((R) + 3) % 9];\t\t\t\t\t\\\n\tX3 += ks[((R) + 4) % 9];\t\t\t\t\t\\\n\tX4 += ks[((R) + 5) % 9];\t\t\t\t\t\\\n\tX5 += ks[((R) + 6) % 9] + ts[((R) + 1) % 3];\t\t\t\\\n\tX6 += ks[((R) + 7) % 9] + ts[((R) + 2) % 3];\t\t\t\\\n\tX7 += ks[((R) + 8) % 9] + (R) + 1;\t\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, Xptr);\n#else\t\t\t\t \n#define\tR512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, rNum)\t\t\t\\\n\tRound512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, rNum)\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, 4 * (r - 1) + rNum, Xptr);\n\n#define\tI512(R)\t\t\t\t\t\t\t\t\\\n\tX0 += ks[r + (R) + 0];\t \t\\\n\tX1 += ks[r + (R) + 1];\t\t\t\t\t\t\\\n\tX2 += ks[r + (R) + 2];\t\t\t\t\t\t\\\n\tX3 += ks[r + (R) + 3];\t\t\t\t\t\t\\\n\tX4 += ks[r + (R) + 4];\t\t\t\t\t\t\\\n\tX5 += ks[r + (R) + 5] + ts[r + (R) + 0];\t\t\t\\\n\tX6 += ks[r + (R) + 6] + ts[r + (R) + 1];\t\t\t\\\n\tX7 += ks[r + (R) + 7] + r + (R);\t\t\t\t\\\n\tks[r + (R)+8] = ks[r + (R) - 1];\t \\\n\tts[r + (R)+2] = ts[r + (R) - 1];\t\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, Xptr);\n\n\t\t \n\t\tfor (r = 1; r < 2 * RCNT; r += 2 * SKEIN_UNROLL_512)\n#endif\t\t\t\t \n\t\t{\n#define\tR512_8_rounds(R)\t \t\t\t\\\n\tR512(0, 1, 2, 3, 4, 5, 6, 7, R_512_0, 8 * (R) + 1);\t\t\\\n\tR512(2, 1, 4, 7, 6, 5, 0, 3, R_512_1, 8 * (R) + 2);\t\t\\\n\tR512(4, 1, 6, 3, 0, 5, 2, 7, R_512_2, 8 * (R) + 3);\t\t\\\n\tR512(6, 1, 0, 7, 2, 5, 4, 3, R_512_3, 8 * (R) + 4);\t\t\\\n\tI512(2 * (R));\t\t\t\t\t\t\t\\\n\tR512(0, 1, 2, 3, 4, 5, 6, 7, R_512_4, 8 * (R) + 5);\t\t\\\n\tR512(2, 1, 4, 7, 6, 5, 0, 3, R_512_5, 8 * (R) + 6);\t\t\\\n\tR512(4, 1, 6, 3, 0, 5, 2, 7, R_512_6, 8 * (R) + 7);\t\t\\\n\tR512(6, 1, 0, 7, 2, 5, 4, 3, R_512_7, 8 * (R) + 8);\t\t\\\n\tI512(2*(R) + 1);\t\t \n\n\t\t\tR512_8_rounds(0);\n\n#define\tR512_Unroll_R(NN) \\\n\t((SKEIN_UNROLL_512 == 0 && SKEIN_512_ROUNDS_TOTAL / 8 > (NN)) || \\\n\t(SKEIN_UNROLL_512 > (NN)))\n\n#if\tR512_Unroll_R(1)\n\t\t\tR512_8_rounds(1);\n#endif\n#if\tR512_Unroll_R(2)\n\t\t\tR512_8_rounds(2);\n#endif\n#if\tR512_Unroll_R(3)\n\t\t\tR512_8_rounds(3);\n#endif\n#if\tR512_Unroll_R(4)\n\t\t\tR512_8_rounds(4);\n#endif\n#if\tR512_Unroll_R(5)\n\t\t\tR512_8_rounds(5);\n#endif\n#if\tR512_Unroll_R(6)\n\t\t\tR512_8_rounds(6);\n#endif\n#if\tR512_Unroll_R(7)\n\t\t\tR512_8_rounds(7);\n#endif\n#if\tR512_Unroll_R(8)\n\t\t\tR512_8_rounds(8);\n#endif\n#if\tR512_Unroll_R(9)\n\t\t\tR512_8_rounds(9);\n#endif\n#if\tR512_Unroll_R(10)\n\t\t\tR512_8_rounds(10);\n#endif\n#if\tR512_Unroll_R(11)\n\t\t\tR512_8_rounds(11);\n#endif\n#if\tR512_Unroll_R(12)\n\t\t\tR512_8_rounds(12);\n#endif\n#if\tR512_Unroll_R(13)\n\t\t\tR512_8_rounds(13);\n#endif\n#if\tR512_Unroll_R(14)\n\t\t\tR512_8_rounds(14);\n#endif\n#if\t(SKEIN_UNROLL_512 > 14)\n#error \"need more unrolling in Skein_512_Process_Block\"\n#endif\n\t\t}\n\n\t\t \n\t\tctx->X[0] = X0 ^ w[0];\n\t\tctx->X[1] = X1 ^ w[1];\n\t\tctx->X[2] = X2 ^ w[2];\n\t\tctx->X[3] = X3 ^ w[3];\n\t\tctx->X[4] = X4 ^ w[4];\n\t\tctx->X[5] = X5 ^ w[5];\n\t\tctx->X[6] = X6 ^ w[6];\n\t\tctx->X[7] = X7 ^ w[7];\n\t\tSkein_Show_Round(BLK_BITS, &ctx->h, SKEIN_RND_FEED_FWD, ctx->X);\n\n\t\tts[1] &= ~SKEIN_T1_FLAG_FIRST;\n\t} while (--blkCnt);\n\tctx->h.T[0] = ts[0];\n\tctx->h.T[1] = ts[1];\n}\n\n#if\tdefined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\nsize_t\nSkein_512_Process_Block_CodeSize(void)\n{\n\treturn ((uint8_t *)Skein_512_Process_Block_CodeSize) -\n\t    ((uint8_t *)Skein_512_Process_Block);\n}\n\nuint_t\nSkein_512_Unroll_Cnt(void)\n{\n\treturn (SKEIN_UNROLL_512);\n}\n#endif\n#endif\n\n \n#if\t!(SKEIN_USE_ASM & 1024)\nvoid\nSkein1024_Process_Block(Skein1024_Ctxt_t *ctx, const uint8_t *blkPtr,\n    size_t blkCnt, size_t byteCntAdd)\n{\n\t \n\tenum {\n\t\tWCNT = SKEIN1024_STATE_WORDS\n\t};\n#undef  RCNT\n#define\tRCNT  (SKEIN1024_ROUNDS_TOTAL/8)\n\n#ifdef\tSKEIN_LOOP\t\t \n#define\tSKEIN_UNROLL_1024 ((SKEIN_LOOP)%10)\n#else\n#define\tSKEIN_UNROLL_1024 (0)\n#endif\n\n#if\t(SKEIN_UNROLL_1024 != 0)\n#if\t(RCNT % SKEIN_UNROLL_1024)\n#error \"Invalid SKEIN_UNROLL_1024\"\t \n#endif\n\tsize_t r;\n\t \n\tuint64_t kw[WCNT + 4 + RCNT * 2];\n#else\n\tuint64_t kw[WCNT + 4];\t \n#endif\n\n\t \n\tuint64_t X00, X01, X02, X03, X04, X05, X06, X07, X08, X09, X10, X11,\n\t    X12, X13, X14, X15;\n\tuint64_t w[WCNT];\t\t \n#ifdef\tSKEIN_DEBUG\n\t \n\tconst uint64_t *Xptr[16];\n\tXptr[0] = &X00;\n\tXptr[1] = &X01;\n\tXptr[2] = &X02;\n\tXptr[3] = &X03;\n\tXptr[4] = &X04;\n\tXptr[5] = &X05;\n\tXptr[6] = &X06;\n\tXptr[7] = &X07;\n\tXptr[8] = &X08;\n\tXptr[9] = &X09;\n\tXptr[10] = &X10;\n\tXptr[11] = &X11;\n\tXptr[12] = &X12;\n\tXptr[13] = &X13;\n\tXptr[14] = &X14;\n\tXptr[15] = &X15;\n#endif\n\n\tSkein_assert(blkCnt != 0);\t \n\tts[0] = ctx->h.T[0];\n\tts[1] = ctx->h.T[1];\n\tdo {\n\t\t \n\t\tts[0] += byteCntAdd;\t \n\n\t\t \n\t\tks[0] = ctx->X[0];\n\t\tks[1] = ctx->X[1];\n\t\tks[2] = ctx->X[2];\n\t\tks[3] = ctx->X[3];\n\t\tks[4] = ctx->X[4];\n\t\tks[5] = ctx->X[5];\n\t\tks[6] = ctx->X[6];\n\t\tks[7] = ctx->X[7];\n\t\tks[8] = ctx->X[8];\n\t\tks[9] = ctx->X[9];\n\t\tks[10] = ctx->X[10];\n\t\tks[11] = ctx->X[11];\n\t\tks[12] = ctx->X[12];\n\t\tks[13] = ctx->X[13];\n\t\tks[14] = ctx->X[14];\n\t\tks[15] = ctx->X[15];\n\t\tks[16] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^\n\t\t    ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^\n\t\t    ks[8] ^ ks[9] ^ ks[10] ^ ks[11] ^\n\t\t    ks[12] ^ ks[13] ^ ks[14] ^ ks[15] ^ SKEIN_KS_PARITY;\n\n\t\tts[2] = ts[0] ^ ts[1];\n\n\t\t \n\t\tSkein_Get64_LSB_First(w, blkPtr, WCNT);\n\t\tDebugSaveTweak(ctx);\n\t\tSkein_Show_Block(BLK_BITS, &ctx->h, ctx->X, blkPtr, w, ks, ts);\n\n\t\tX00 = w[0] + ks[0];\t \n\t\tX01 = w[1] + ks[1];\n\t\tX02 = w[2] + ks[2];\n\t\tX03 = w[3] + ks[3];\n\t\tX04 = w[4] + ks[4];\n\t\tX05 = w[5] + ks[5];\n\t\tX06 = w[6] + ks[6];\n\t\tX07 = w[7] + ks[7];\n\t\tX08 = w[8] + ks[8];\n\t\tX09 = w[9] + ks[9];\n\t\tX10 = w[10] + ks[10];\n\t\tX11 = w[11] + ks[11];\n\t\tX12 = w[12] + ks[12];\n\t\tX13 = w[13] + ks[13] + ts[0];\n\t\tX14 = w[14] + ks[14] + ts[1];\n\t\tX15 = w[15] + ks[15];\n\n\t\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INITIAL,\n\t\t    Xptr);\n\n#define\tRound1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC,\t\\\n\tpD, pE, pF, ROT, rNum)\t\t\t\t\t\t\\\n\tX##p0 += X##p1; X##p1 = RotL_64(X##p1, ROT##_0); X##p1 ^= X##p0;\\\n\tX##p2 += X##p3; X##p3 = RotL_64(X##p3, ROT##_1); X##p3 ^= X##p2;\\\n\tX##p4 += X##p5; X##p5 = RotL_64(X##p5, ROT##_2); X##p5 ^= X##p4;\\\n\tX##p6 += X##p7; X##p7 = RotL_64(X##p7, ROT##_3); X##p7 ^= X##p6;\\\n\tX##p8 += X##p9; X##p9 = RotL_64(X##p9, ROT##_4); X##p9 ^= X##p8;\\\n\tX##pA += X##pB; X##pB = RotL_64(X##pB, ROT##_5); X##pB ^= X##pA;\\\n\tX##pC += X##pD; X##pD = RotL_64(X##pD, ROT##_6); X##pD ^= X##pC;\\\n\tX##pE += X##pF; X##pF = RotL_64(X##pF, ROT##_7); X##pF ^= X##pE;\n\n#if\tSKEIN_UNROLL_1024 == 0\n#define\tR1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD,\t\\\n\tpE, pF, ROT, rn)\t\t\t\t\t\t\\\n\tRound1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC,\t\\\n\tpD, pE, pF, ROT, rn)\t\t\t\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, rn, Xptr);\n\n#define\tI1024(R)\t\t\t\t\t\t\t\\\n\tX00 += ks[((R) + 1) % 17];\t \\\n\tX01 += ks[((R) + 2) % 17];\t\t\t\t\t\\\n\tX02 += ks[((R) + 3) % 17];\t\t\t\t\t\\\n\tX03 += ks[((R) + 4) % 17];\t\t\t\t\t\\\n\tX04 += ks[((R) + 5) % 17];\t\t\t\t\t\\\n\tX05 += ks[((R) + 6) % 17];\t\t\t\t\t\\\n\tX06 += ks[((R) + 7) % 17];\t\t\t\t\t\\\n\tX07 += ks[((R) + 8) % 17];\t\t\t\t\t\\\n\tX08 += ks[((R) + 9) % 17];\t\t\t\t\t\\\n\tX09 += ks[((R) + 10) % 17];\t\t\t\t\t\\\n\tX10 += ks[((R) + 11) % 17];\t\t\t\t\t\\\n\tX11 += ks[((R) + 12) % 17];\t\t\t\t\t\\\n\tX12 += ks[((R) + 13) % 17];\t\t\t\t\t\\\n\tX13 += ks[((R) + 14) % 17] + ts[((R) + 1) % 3];\t\t\t\\\n\tX14 += ks[((R) + 15) % 17] + ts[((R) + 2) % 3];\t\t\t\\\n\tX15 += ks[((R) + 16) % 17] + (R) +1;\t\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, Xptr);\n#else\t\t\t\t \n#define\tR1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD,\t\\\n\tpE, pF, ROT, rn)\t\t\t\t\t\t\\\n\tRound1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC,\t\\\n\tpD, pE, pF, ROT, rn)\t\t\t\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, 4 * (r - 1) + rn, Xptr);\n\n#define\tI1024(R)\t\t\t\t\t\t\t\\\n\tX00 += ks[r + (R) + 0];\t \t\\\n\tX01 += ks[r + (R) + 1];\t\t\t\t\t\t\\\n\tX02 += ks[r + (R) + 2];\t\t\t\t\t\t\\\n\tX03 += ks[r + (R) + 3];\t\t\t\t\t\t\\\n\tX04 += ks[r + (R) + 4];\t\t\t\t\t\t\\\n\tX05 += ks[r + (R) + 5];\t\t\t\t\t\t\\\n\tX06 += ks[r + (R) + 6];\t\t\t\t\t\t\\\n\tX07 += ks[r + (R) + 7];\t\t\t\t\t\t\\\n\tX08 += ks[r + (R) + 8];\t\t\t\t\t\t\\\n\tX09 += ks[r + (R) + 9];\t\t\t\t\t\t\\\n\tX10 += ks[r + (R) + 10];\t\t\t\t\t\\\n\tX11 += ks[r + (R) + 11];\t\t\t\t\t\\\n\tX12 += ks[r + (R) + 12];\t\t\t\t\t\\\n\tX13 += ks[r + (R) + 13] + ts[r + (R) + 0];\t\t\t\\\n\tX14 += ks[r + (R) + 14] + ts[r + (R) + 1];\t\t\t\\\n\tX15 += ks[r + (R) + 15] +  r + (R);\t\t\t\t\\\n\tks[r + (R) + 16] = ks[r + (R) - 1];\t \\\n\tts[r + (R) + 2] = ts[r + (R) - 1];\t\t\t\t\\\n\tSkein_Show_R_Ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, Xptr);\n\n\t\t \n\t\tfor (r = 1; r <= 2 * RCNT; r += 2 * SKEIN_UNROLL_1024)\n#endif\n\t\t{\n#define\tR1024_8_rounds(R)\t \t\t\t\\\n\tR1024(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13,\t\\\n\t    14, 15, R1024_0, 8 * (R) + 1);\t\t\t\t\\\n\tR1024(00, 09, 02, 13, 06, 11, 04, 15, 10, 07, 12, 03, 14, 05,\t\\\n\t    08, 01, R1024_1, 8 * (R) + 2);\t\t\t\t\\\n\tR1024(00, 07, 02, 05, 04, 03, 06, 01, 12, 15, 14, 13, 08, 11,\t\\\n\t    10, 09, R1024_2, 8 * (R) + 3);\t\t\t\t\\\n\tR1024(00, 15, 02, 11, 06, 13, 04, 09, 14, 01, 08, 05, 10, 03,\t\\\n\t    12, 07, R1024_3, 8 * (R) + 4);\t\t\t\t\\\n\tI1024(2 * (R));\t\t\t\t\t\t\t\\\n\tR1024(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13,\t\\\n\t    14, 15, R1024_4, 8 * (R) + 5);\t\t\t\t\\\n\tR1024(00, 09, 02, 13, 06, 11, 04, 15, 10, 07, 12, 03, 14, 05,\t\\\n\t    08, 01, R1024_5, 8 * (R) + 6);\t\t\t\t\\\n\tR1024(00, 07, 02, 05, 04, 03, 06, 01, 12, 15, 14, 13, 08, 11,\t\\\n\t    10, 09, R1024_6, 8 * (R) + 7);\t\t\t\t\\\n\tR1024(00, 15, 02, 11, 06, 13, 04, 09, 14, 01, 08, 05, 10, 03,\t\\\n\t    12, 07, R1024_7, 8 * (R) + 8);\t\t\t\t\\\n\tI1024(2 * (R) + 1);\n\n\t\t\tR1024_8_rounds(0);\n\n#define\tR1024_Unroll_R(NN)\t\t\t\t\t\t\\\n\t((SKEIN_UNROLL_1024 == 0 && SKEIN1024_ROUNDS_TOTAL/8 > (NN)) ||\t\\\n\t(SKEIN_UNROLL_1024 > (NN)))\n\n#if\tR1024_Unroll_R(1)\n\t\t\tR1024_8_rounds(1);\n#endif\n#if\tR1024_Unroll_R(2)\n\t\t\tR1024_8_rounds(2);\n#endif\n#if\tR1024_Unroll_R(3)\n\t\t\tR1024_8_rounds(3);\n#endif\n#if\tR1024_Unroll_R(4)\n\t\t\tR1024_8_rounds(4);\n#endif\n#if\tR1024_Unroll_R(5)\n\t\t\tR1024_8_rounds(5);\n#endif\n#if\tR1024_Unroll_R(6)\n\t\t\tR1024_8_rounds(6);\n#endif\n#if\tR1024_Unroll_R(7)\n\t\t\tR1024_8_rounds(7);\n#endif\n#if\tR1024_Unroll_R(8)\n\t\t\tR1024_8_rounds(8);\n#endif\n#if\tR1024_Unroll_R(9)\n\t\t\tR1024_8_rounds(9);\n#endif\n#if\tR1024_Unroll_R(10)\n\t\t\tR1024_8_rounds(10);\n#endif\n#if\tR1024_Unroll_R(11)\n\t\t\tR1024_8_rounds(11);\n#endif\n#if\tR1024_Unroll_R(12)\n\t\t\tR1024_8_rounds(12);\n#endif\n#if\tR1024_Unroll_R(13)\n\t\t\tR1024_8_rounds(13);\n#endif\n#if\tR1024_Unroll_R(14)\n\t\t\tR1024_8_rounds(14);\n#endif\n#if\t(SKEIN_UNROLL_1024 > 14)\n#error  \"need more unrolling in Skein_1024_Process_Block\"\n#endif\n\t\t}\n\t\t \n\n\t\tctx->X[0] = X00 ^ w[0];\n\t\tctx->X[1] = X01 ^ w[1];\n\t\tctx->X[2] = X02 ^ w[2];\n\t\tctx->X[3] = X03 ^ w[3];\n\t\tctx->X[4] = X04 ^ w[4];\n\t\tctx->X[5] = X05 ^ w[5];\n\t\tctx->X[6] = X06 ^ w[6];\n\t\tctx->X[7] = X07 ^ w[7];\n\t\tctx->X[8] = X08 ^ w[8];\n\t\tctx->X[9] = X09 ^ w[9];\n\t\tctx->X[10] = X10 ^ w[10];\n\t\tctx->X[11] = X11 ^ w[11];\n\t\tctx->X[12] = X12 ^ w[12];\n\t\tctx->X[13] = X13 ^ w[13];\n\t\tctx->X[14] = X14 ^ w[14];\n\t\tctx->X[15] = X15 ^ w[15];\n\n\t\tSkein_Show_Round(BLK_BITS, &ctx->h, SKEIN_RND_FEED_FWD, ctx->X);\n\n\t\tts[1] &= ~SKEIN_T1_FLAG_FIRST;\n\t\tblkPtr += SKEIN1024_BLOCK_BYTES;\n\t} while (--blkCnt);\n\tctx->h.T[0] = ts[0];\n\tctx->h.T[1] = ts[1];\n}\n\n#if\tdefined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\nsize_t\nSkein1024_Process_Block_CodeSize(void)\n{\n\treturn ((uint8_t *)Skein1024_Process_Block_CodeSize) -\n\t    ((uint8_t *)Skein1024_Process_Block);\n}\n\nuint_t\nSkein1024_Unroll_Cnt(void)\n{\n\treturn (SKEIN_UNROLL_1024);\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}