{
  "module_name": "blake3_generic.c",
  "hash_id": "1dd4f0059f063e5cec8d49731068154575bc7e0d3f61d95155410a7af8509617",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/blake3/blake3_generic.c",
  "human_readable_source": " \n\n \n\n#include <sys/simd.h>\n#include <sys/zfs_context.h>\n#include \"blake3_impl.h\"\n\n#define\trotr32(x, n)\t(((x) >> (n)) | ((x) << (32 - (n))))\nstatic inline void g(uint32_t *state, size_t a, size_t b, size_t c, size_t d,\n    uint32_t x, uint32_t y)\n{\n\tstate[a] = state[a] + state[b] + x;\n\tstate[d] = rotr32(state[d] ^ state[a], 16);\n\tstate[c] = state[c] + state[d];\n\tstate[b] = rotr32(state[b] ^ state[c], 12);\n\tstate[a] = state[a] + state[b] + y;\n\tstate[d] = rotr32(state[d] ^ state[a], 8);\n\tstate[c] = state[c] + state[d];\n\tstate[b] = rotr32(state[b] ^ state[c], 7);\n}\n\nstatic inline void round_fn(uint32_t state[16], const uint32_t *msg,\n    size_t round)\n{\n\t \n\tconst uint8_t *schedule = BLAKE3_MSG_SCHEDULE[round];\n\n\t \n\tg(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);\n\tg(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);\n\tg(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);\n\tg(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);\n\n\t \n\tg(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);\n\tg(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);\n\tg(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);\n\tg(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);\n}\n\nstatic inline void compress_pre(uint32_t state[16], const uint32_t cv[8],\n    const uint8_t block[BLAKE3_BLOCK_LEN], uint8_t block_len,\n    uint64_t counter, uint8_t flags)\n{\n\tuint32_t block_words[16];\n\tblock_words[0] = load32(block + 4 * 0);\n\tblock_words[1] = load32(block + 4 * 1);\n\tblock_words[2] = load32(block + 4 * 2);\n\tblock_words[3] = load32(block + 4 * 3);\n\tblock_words[4] = load32(block + 4 * 4);\n\tblock_words[5] = load32(block + 4 * 5);\n\tblock_words[6] = load32(block + 4 * 6);\n\tblock_words[7] = load32(block + 4 * 7);\n\tblock_words[8] = load32(block + 4 * 8);\n\tblock_words[9] = load32(block + 4 * 9);\n\tblock_words[10] = load32(block + 4 * 10);\n\tblock_words[11] = load32(block + 4 * 11);\n\tblock_words[12] = load32(block + 4 * 12);\n\tblock_words[13] = load32(block + 4 * 13);\n\tblock_words[14] = load32(block + 4 * 14);\n\tblock_words[15] = load32(block + 4 * 15);\n\n\tstate[0] = cv[0];\n\tstate[1] = cv[1];\n\tstate[2] = cv[2];\n\tstate[3] = cv[3];\n\tstate[4] = cv[4];\n\tstate[5] = cv[5];\n\tstate[6] = cv[6];\n\tstate[7] = cv[7];\n\tstate[8] = BLAKE3_IV[0];\n\tstate[9] = BLAKE3_IV[1];\n\tstate[10] = BLAKE3_IV[2];\n\tstate[11] = BLAKE3_IV[3];\n\tstate[12] = counter_low(counter);\n\tstate[13] = counter_high(counter);\n\tstate[14] = (uint32_t)block_len;\n\tstate[15] = (uint32_t)flags;\n\n\tround_fn(state, &block_words[0], 0);\n\tround_fn(state, &block_words[0], 1);\n\tround_fn(state, &block_words[0], 2);\n\tround_fn(state, &block_words[0], 3);\n\tround_fn(state, &block_words[0], 4);\n\tround_fn(state, &block_words[0], 5);\n\tround_fn(state, &block_words[0], 6);\n}\n\nstatic inline void blake3_compress_in_place_generic(uint32_t cv[8],\n    const uint8_t block[BLAKE3_BLOCK_LEN], uint8_t block_len,\n    uint64_t counter, uint8_t flags)\n{\n\tuint32_t state[16];\n\tcompress_pre(state, cv, block, block_len, counter, flags);\n\tcv[0] = state[0] ^ state[8];\n\tcv[1] = state[1] ^ state[9];\n\tcv[2] = state[2] ^ state[10];\n\tcv[3] = state[3] ^ state[11];\n\tcv[4] = state[4] ^ state[12];\n\tcv[5] = state[5] ^ state[13];\n\tcv[6] = state[6] ^ state[14];\n\tcv[7] = state[7] ^ state[15];\n}\n\nstatic inline void hash_one_generic(const uint8_t *input, size_t blocks,\n    const uint32_t key[8], uint64_t counter, uint8_t flags,\n    uint8_t flags_start, uint8_t flags_end, uint8_t out[BLAKE3_OUT_LEN])\n{\n\tuint32_t cv[8];\n\tmemcpy(cv, key, BLAKE3_KEY_LEN);\n\tuint8_t block_flags = flags | flags_start;\n\twhile (blocks > 0) {\n\t\tif (blocks == 1) {\n\t\t\tblock_flags |= flags_end;\n\t\t}\n\t\tblake3_compress_in_place_generic(cv, input, BLAKE3_BLOCK_LEN,\n\t\t    counter, block_flags);\n\t\tinput = &input[BLAKE3_BLOCK_LEN];\n\t\tblocks -= 1;\n\t\tblock_flags = flags;\n\t}\n\tstore_cv_words(out, cv);\n}\n\nstatic inline void blake3_compress_xof_generic(const uint32_t cv[8],\n    const uint8_t block[BLAKE3_BLOCK_LEN], uint8_t block_len,\n    uint64_t counter, uint8_t flags, uint8_t out[64])\n{\n\tuint32_t state[16];\n\tcompress_pre(state, cv, block, block_len, counter, flags);\n\n\tstore32(&out[0 * 4], state[0] ^ state[8]);\n\tstore32(&out[1 * 4], state[1] ^ state[9]);\n\tstore32(&out[2 * 4], state[2] ^ state[10]);\n\tstore32(&out[3 * 4], state[3] ^ state[11]);\n\tstore32(&out[4 * 4], state[4] ^ state[12]);\n\tstore32(&out[5 * 4], state[5] ^ state[13]);\n\tstore32(&out[6 * 4], state[6] ^ state[14]);\n\tstore32(&out[7 * 4], state[7] ^ state[15]);\n\tstore32(&out[8 * 4], state[8] ^ cv[0]);\n\tstore32(&out[9 * 4], state[9] ^ cv[1]);\n\tstore32(&out[10 * 4], state[10] ^ cv[2]);\n\tstore32(&out[11 * 4], state[11] ^ cv[3]);\n\tstore32(&out[12 * 4], state[12] ^ cv[4]);\n\tstore32(&out[13 * 4], state[13] ^ cv[5]);\n\tstore32(&out[14 * 4], state[14] ^ cv[6]);\n\tstore32(&out[15 * 4], state[15] ^ cv[7]);\n}\n\nstatic inline void blake3_hash_many_generic(const uint8_t * const *inputs,\n    size_t num_inputs, size_t blocks, const uint32_t key[8], uint64_t counter,\n    boolean_t increment_counter, uint8_t flags, uint8_t flags_start,\n    uint8_t flags_end, uint8_t *out)\n{\n\twhile (num_inputs > 0) {\n\t\thash_one_generic(inputs[0], blocks, key, counter, flags,\n\t\t    flags_start, flags_end, out);\n\t\tif (increment_counter) {\n\t\t\tcounter += 1;\n\t\t}\n\t\tinputs += 1;\n\t\tnum_inputs -= 1;\n\t\tout = &out[BLAKE3_OUT_LEN];\n\t}\n}\n\n \nstatic boolean_t blake3_is_supported(void)\n{\n\treturn (B_TRUE);\n}\n\nconst blake3_ops_t blake3_generic_impl = {\n\t.compress_in_place = blake3_compress_in_place_generic,\n\t.compress_xof = blake3_compress_xof_generic,\n\t.hash_many = blake3_hash_many_generic,\n\t.is_supported = blake3_is_supported,\n\t.degree = 4,\n\t.name = \"generic\"\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}