{
  "module_name": "blake3_impl.h",
  "hash_id": "72bdd100fa0ae421b2daa8eae530fad10caa94a83d8f1faba56968e8d1ecb18b",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/blake3/blake3_impl.h",
  "human_readable_source": " \n\n \n\n#ifndef\tBLAKE3_IMPL_H\n#define\tBLAKE3_IMPL_H\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#include <sys/blake3.h>\n#include <sys/simd.h>\n#include <sys/asm_linkage.h>\n\n \ntypedef void (*blake3_compress_in_place_f)(uint32_t cv[8],\n    const uint8_t block[BLAKE3_BLOCK_LEN],\n    uint8_t block_len, uint64_t counter,\n    uint8_t flags);\n\ntypedef void (*blake3_compress_xof_f)(const uint32_t cv[8],\n    const uint8_t block[BLAKE3_BLOCK_LEN], uint8_t block_len,\n    uint64_t counter, uint8_t flags, uint8_t out[64]);\n\ntypedef void (*blake3_hash_many_f)(const uint8_t * const *inputs,\n    size_t num_inputs, size_t blocks, const uint32_t key[8],\n    uint64_t counter, boolean_t increment_counter, uint8_t flags,\n    uint8_t flags_start, uint8_t flags_end, uint8_t *out);\n\ntypedef boolean_t (*blake3_is_supported_f)(void);\n\ntypedef struct {\n\tblake3_compress_in_place_f compress_in_place;\n\tblake3_compress_xof_f compress_xof;\n\tblake3_hash_many_f hash_many;\n\tblake3_is_supported_f is_supported;\n\tint degree;\n\tconst char *name;\n} blake3_ops_t;\n\n \nextern const blake3_ops_t *blake3_get_ops(void);\n\n#if defined(__x86_64)\n#define\tMAX_SIMD_DEGREE 16\n#else\n#define\tMAX_SIMD_DEGREE 4\n#endif\n\n#define\tMAX_SIMD_DEGREE_OR_2\t(MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)\n\nstatic const uint32_t BLAKE3_IV[8] = {\n\t0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,\n\t0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL};\n\nstatic const uint8_t BLAKE3_MSG_SCHEDULE[7][16] = {\n\t{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},\n\t{2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},\n\t{3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},\n\t{10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},\n\t{12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},\n\t{9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},\n\t{11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},\n};\n\n \nstatic inline unsigned int highest_one(uint64_t x) {\n#if defined(__GNUC__) || defined(__clang__)\n\treturn (63 ^ __builtin_clzll(x));\n#elif defined(_MSC_VER) && defined(IS_X86_64)\n\tunsigned long index;\n\t_BitScanReverse64(&index, x);\n\treturn (index);\n#elif defined(_MSC_VER) && defined(IS_X86_32)\n\tif (x >> 32) {\n\t\tunsigned long index;\n\t\t_BitScanReverse(&index, x >> 32);\n\t\treturn (32 + index);\n\t} else {\n\t\tunsigned long index;\n\t\t_BitScanReverse(&index, x);\n\t\treturn (index);\n\t}\n#else\n\tunsigned int c = 0;\n\tif (x & 0xffffffff00000000ULL) { x >>= 32; c += 32; }\n\tif (x & 0x00000000ffff0000ULL) { x >>= 16; c += 16; }\n\tif (x & 0x000000000000ff00ULL) { x >>=  8; c +=  8; }\n\tif (x & 0x00000000000000f0ULL) { x >>=  4; c +=  4; }\n\tif (x & 0x000000000000000cULL) { x >>=  2; c +=  2; }\n\tif (x & 0x0000000000000002ULL) { c +=  1; }\n\treturn (c);\n#endif\n}\n\n \nstatic inline unsigned int popcnt(uint64_t x) {\n\tunsigned int count = 0;\n\n\twhile (x != 0) {\n\t\tcount += 1;\n\t\tx &= x - 1;\n\t}\n\n\treturn (count);\n}\n\n \nstatic inline uint64_t round_down_to_power_of_2(uint64_t x) {\n\treturn (1ULL << highest_one(x | 1));\n}\n\nstatic inline uint32_t counter_low(uint64_t counter) {\n\treturn ((uint32_t)counter);\n}\n\nstatic inline uint32_t counter_high(uint64_t counter) {\n\treturn ((uint32_t)(counter >> 32));\n}\n\nstatic inline uint32_t load32(const void *src) {\n\tconst uint8_t *p = (const uint8_t *)src;\n\treturn ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |\n\t    ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);\n}\n\nstatic inline void load_key_words(const uint8_t key[BLAKE3_KEY_LEN],\n    uint32_t key_words[8]) {\n\tkey_words[0] = load32(&key[0 * 4]);\n\tkey_words[1] = load32(&key[1 * 4]);\n\tkey_words[2] = load32(&key[2 * 4]);\n\tkey_words[3] = load32(&key[3 * 4]);\n\tkey_words[4] = load32(&key[4 * 4]);\n\tkey_words[5] = load32(&key[5 * 4]);\n\tkey_words[6] = load32(&key[6 * 4]);\n\tkey_words[7] = load32(&key[7 * 4]);\n}\n\nstatic inline void store32(void *dst, uint32_t w) {\n\tuint8_t *p = (uint8_t *)dst;\n\tp[0] = (uint8_t)(w >> 0);\n\tp[1] = (uint8_t)(w >> 8);\n\tp[2] = (uint8_t)(w >> 16);\n\tp[3] = (uint8_t)(w >> 24);\n}\n\nstatic inline void store_cv_words(uint8_t bytes_out[32], uint32_t cv_words[8]) {\n\tstore32(&bytes_out[0 * 4], cv_words[0]);\n\tstore32(&bytes_out[1 * 4], cv_words[1]);\n\tstore32(&bytes_out[2 * 4], cv_words[2]);\n\tstore32(&bytes_out[3 * 4], cv_words[3]);\n\tstore32(&bytes_out[4 * 4], cv_words[4]);\n\tstore32(&bytes_out[5 * 4], cv_words[5]);\n\tstore32(&bytes_out[6 * 4], cv_words[6]);\n\tstore32(&bytes_out[7 * 4], cv_words[7]);\n}\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}