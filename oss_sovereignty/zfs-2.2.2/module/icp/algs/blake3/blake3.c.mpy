{
  "module_name": "blake3.c",
  "hash_id": "1368eab1a2f9cf50447b1cb15bac9dc668150a13b527f016e2f6907b422b4da5",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/blake3/blake3.c",
  "human_readable_source": " \n\n \n\n#include <sys/simd.h>\n#include <sys/zfs_context.h>\n#include <sys/blake3.h>\n\n#include \"blake3_impl.h\"\n\n \n#if defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wframe-larger-than=\"\n#endif\n\n \ntypedef struct {\n\tuint32_t input_cv[8];\n\tuint64_t counter;\n\tuint8_t block[BLAKE3_BLOCK_LEN];\n\tuint8_t block_len;\n\tuint8_t flags;\n} output_t;\n\n \nenum blake3_flags {\n\tCHUNK_START\t\t= 1 << 0,\n\tCHUNK_END\t\t= 1 << 1,\n\tPARENT\t\t\t= 1 << 2,\n\tROOT\t\t\t= 1 << 3,\n\tKEYED_HASH\t\t= 1 << 4,\n\tDERIVE_KEY_CONTEXT\t= 1 << 5,\n\tDERIVE_KEY_MATERIAL\t= 1 << 6,\n};\n\n \nstatic void chunk_state_init(blake3_chunk_state_t *ctx,\n    const uint32_t key[8], uint8_t flags)\n{\n\tmemcpy(ctx->cv, key, BLAKE3_KEY_LEN);\n\tctx->chunk_counter = 0;\n\tmemset(ctx->buf, 0, BLAKE3_BLOCK_LEN);\n\tctx->buf_len = 0;\n\tctx->blocks_compressed = 0;\n\tctx->flags = flags;\n}\n\nstatic void chunk_state_reset(blake3_chunk_state_t *ctx,\n    const uint32_t key[8], uint64_t chunk_counter)\n{\n\tmemcpy(ctx->cv, key, BLAKE3_KEY_LEN);\n\tctx->chunk_counter = chunk_counter;\n\tctx->blocks_compressed = 0;\n\tmemset(ctx->buf, 0, BLAKE3_BLOCK_LEN);\n\tctx->buf_len = 0;\n}\n\nstatic size_t chunk_state_len(const blake3_chunk_state_t *ctx)\n{\n\treturn (BLAKE3_BLOCK_LEN * (size_t)ctx->blocks_compressed) +\n\t    ((size_t)ctx->buf_len);\n}\n\nstatic size_t chunk_state_fill_buf(blake3_chunk_state_t *ctx,\n    const uint8_t *input, size_t input_len)\n{\n\tsize_t take = BLAKE3_BLOCK_LEN - ((size_t)ctx->buf_len);\n\tif (take > input_len) {\n\t\ttake = input_len;\n\t}\n\tuint8_t *dest = ctx->buf + ((size_t)ctx->buf_len);\n\tmemcpy(dest, input, take);\n\tctx->buf_len += (uint8_t)take;\n\treturn (take);\n}\n\nstatic uint8_t chunk_state_maybe_start_flag(const blake3_chunk_state_t *ctx)\n{\n\tif (ctx->blocks_compressed == 0) {\n\t\treturn (CHUNK_START);\n\t} else {\n\t\treturn (0);\n\t}\n}\n\nstatic output_t make_output(const uint32_t input_cv[8],\n    const uint8_t *block, uint8_t block_len,\n    uint64_t counter, uint8_t flags)\n{\n\toutput_t ret;\n\tmemcpy(ret.input_cv, input_cv, 32);\n\tmemcpy(ret.block, block, BLAKE3_BLOCK_LEN);\n\tret.block_len = block_len;\n\tret.counter = counter;\n\tret.flags = flags;\n\treturn (ret);\n}\n\n \nstatic void output_chaining_value(const blake3_ops_t *ops,\n    const output_t *ctx, uint8_t cv[32])\n{\n\tuint32_t cv_words[8];\n\tmemcpy(cv_words, ctx->input_cv, 32);\n\tops->compress_in_place(cv_words, ctx->block, ctx->block_len,\n\t    ctx->counter, ctx->flags);\n\tstore_cv_words(cv, cv_words);\n}\n\nstatic void output_root_bytes(const blake3_ops_t *ops, const output_t *ctx,\n    uint64_t seek, uint8_t *out, size_t out_len)\n{\n\tuint64_t output_block_counter = seek / 64;\n\tsize_t offset_within_block = seek % 64;\n\tuint8_t wide_buf[64];\n\twhile (out_len > 0) {\n\t\tops->compress_xof(ctx->input_cv, ctx->block, ctx->block_len,\n\t\t    output_block_counter, ctx->flags | ROOT, wide_buf);\n\t\tsize_t available_bytes = 64 - offset_within_block;\n\t\tsize_t memcpy_len;\n\t\tif (out_len > available_bytes) {\n\t\t\tmemcpy_len = available_bytes;\n\t\t} else {\n\t\t\tmemcpy_len = out_len;\n\t\t}\n\t\tmemcpy(out, wide_buf + offset_within_block, memcpy_len);\n\t\tout += memcpy_len;\n\t\tout_len -= memcpy_len;\n\t\toutput_block_counter += 1;\n\t\toffset_within_block = 0;\n\t}\n}\n\nstatic void chunk_state_update(const blake3_ops_t *ops,\n    blake3_chunk_state_t *ctx, const uint8_t *input, size_t input_len)\n{\n\tif (ctx->buf_len > 0) {\n\t\tsize_t take = chunk_state_fill_buf(ctx, input, input_len);\n\t\tinput += take;\n\t\tinput_len -= take;\n\t\tif (input_len > 0) {\n\t\t\tops->compress_in_place(ctx->cv, ctx->buf,\n\t\t\t    BLAKE3_BLOCK_LEN, ctx->chunk_counter,\n\t\t\t    ctx->flags|chunk_state_maybe_start_flag(ctx));\n\t\t\tctx->blocks_compressed += 1;\n\t\t\tctx->buf_len = 0;\n\t\t\tmemset(ctx->buf, 0, BLAKE3_BLOCK_LEN);\n\t\t}\n\t}\n\n\twhile (input_len > BLAKE3_BLOCK_LEN) {\n\t\tops->compress_in_place(ctx->cv, input, BLAKE3_BLOCK_LEN,\n\t\t    ctx->chunk_counter,\n\t\t    ctx->flags|chunk_state_maybe_start_flag(ctx));\n\t\tctx->blocks_compressed += 1;\n\t\tinput += BLAKE3_BLOCK_LEN;\n\t\tinput_len -= BLAKE3_BLOCK_LEN;\n\t}\n\n\tchunk_state_fill_buf(ctx, input, input_len);\n}\n\nstatic output_t chunk_state_output(const blake3_chunk_state_t *ctx)\n{\n\tuint8_t block_flags =\n\t    ctx->flags | chunk_state_maybe_start_flag(ctx) | CHUNK_END;\n\treturn (make_output(ctx->cv, ctx->buf, ctx->buf_len, ctx->chunk_counter,\n\t    block_flags));\n}\n\nstatic output_t parent_output(const uint8_t block[BLAKE3_BLOCK_LEN],\n    const uint32_t key[8], uint8_t flags)\n{\n\treturn (make_output(key, block, BLAKE3_BLOCK_LEN, 0, flags | PARENT));\n}\n\n \nstatic size_t left_len(size_t content_len)\n{\n\t \n\tsize_t full_chunks = (content_len - 1) / BLAKE3_CHUNK_LEN;\n\treturn (round_down_to_power_of_2(full_chunks) * BLAKE3_CHUNK_LEN);\n}\n\n \nstatic size_t compress_chunks_parallel(const blake3_ops_t *ops,\n    const uint8_t *input, size_t input_len, const uint32_t key[8],\n    uint64_t chunk_counter, uint8_t flags, uint8_t *out)\n{\n\tconst uint8_t *chunks_array[MAX_SIMD_DEGREE];\n\tsize_t input_position = 0;\n\tsize_t chunks_array_len = 0;\n\twhile (input_len - input_position >= BLAKE3_CHUNK_LEN) {\n\t\tchunks_array[chunks_array_len] = &input[input_position];\n\t\tinput_position += BLAKE3_CHUNK_LEN;\n\t\tchunks_array_len += 1;\n\t}\n\n\tops->hash_many(chunks_array, chunks_array_len, BLAKE3_CHUNK_LEN /\n\t    BLAKE3_BLOCK_LEN, key, chunk_counter, B_TRUE, flags, CHUNK_START,\n\t    CHUNK_END, out);\n\n\t \n\tif (input_len > input_position) {\n\t\tuint64_t counter = chunk_counter + (uint64_t)chunks_array_len;\n\t\tblake3_chunk_state_t chunk_state;\n\t\tchunk_state_init(&chunk_state, key, flags);\n\t\tchunk_state.chunk_counter = counter;\n\t\tchunk_state_update(ops, &chunk_state, &input[input_position],\n\t\t    input_len - input_position);\n\t\toutput_t output = chunk_state_output(&chunk_state);\n\t\toutput_chaining_value(ops, &output, &out[chunks_array_len *\n\t\t    BLAKE3_OUT_LEN]);\n\t\treturn (chunks_array_len + 1);\n\t} else {\n\t\treturn (chunks_array_len);\n\t}\n}\n\n \nstatic size_t compress_parents_parallel(const blake3_ops_t *ops,\n    const uint8_t *child_chaining_values, size_t num_chaining_values,\n    const uint32_t key[8], uint8_t flags, uint8_t *out)\n{\n\tconst uint8_t *parents_array[MAX_SIMD_DEGREE_OR_2] = {0};\n\tsize_t parents_array_len = 0;\n\n\twhile (num_chaining_values - (2 * parents_array_len) >= 2) {\n\t\tparents_array[parents_array_len] = &child_chaining_values[2 *\n\t\t    parents_array_len * BLAKE3_OUT_LEN];\n\t\tparents_array_len += 1;\n\t}\n\n\tops->hash_many(parents_array, parents_array_len, 1, key, 0, B_FALSE,\n\t    flags | PARENT, 0, 0, out);\n\n\t \n\tif (num_chaining_values > 2 * parents_array_len) {\n\t\tmemcpy(&out[parents_array_len * BLAKE3_OUT_LEN],\n\t\t    &child_chaining_values[2 * parents_array_len *\n\t\t    BLAKE3_OUT_LEN], BLAKE3_OUT_LEN);\n\t\treturn (parents_array_len + 1);\n\t} else {\n\t\treturn (parents_array_len);\n\t}\n}\n\n \nstatic size_t blake3_compress_subtree_wide(const blake3_ops_t *ops,\n    const uint8_t *input, size_t input_len, const uint32_t key[8],\n    uint64_t chunk_counter, uint8_t flags, uint8_t *out)\n{\n\t \n\tif (input_len <= (size_t)(ops->degree * BLAKE3_CHUNK_LEN)) {\n\t\treturn (compress_chunks_parallel(ops, input, input_len, key,\n\t\t    chunk_counter, flags, out));\n\t}\n\n\n\t \n\tsize_t left_input_len = left_len(input_len);\n\tsize_t right_input_len = input_len - left_input_len;\n\tconst uint8_t *right_input = &input[left_input_len];\n\tuint64_t right_chunk_counter = chunk_counter +\n\t    (uint64_t)(left_input_len / BLAKE3_CHUNK_LEN);\n\n\t \n\tuint8_t cv_array[2 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];\n\tsize_t degree = ops->degree;\n\tif (left_input_len > BLAKE3_CHUNK_LEN && degree == 1) {\n\n\t\t \n\t\tdegree = 2;\n\t}\n\tuint8_t *right_cvs = &cv_array[degree * BLAKE3_OUT_LEN];\n\n\t \n\tsize_t left_n = blake3_compress_subtree_wide(ops, input, left_input_len,\n\t    key, chunk_counter, flags, cv_array);\n\tsize_t right_n = blake3_compress_subtree_wide(ops, right_input,\n\t    right_input_len, key, right_chunk_counter, flags, right_cvs);\n\n\t \n\tif (left_n == 1) {\n\t\tmemcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);\n\t\treturn (2);\n\t}\n\n\t \n\tsize_t num_chaining_values = left_n + right_n;\n\treturn compress_parents_parallel(ops, cv_array,\n\t    num_chaining_values, key, flags, out);\n}\n\n \nstatic void compress_subtree_to_parent_node(const blake3_ops_t *ops,\n    const uint8_t *input, size_t input_len, const uint32_t key[8],\n    uint64_t chunk_counter, uint8_t flags, uint8_t out[2 * BLAKE3_OUT_LEN])\n{\n\tuint8_t cv_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];\n\tsize_t num_cvs = blake3_compress_subtree_wide(ops, input, input_len,\n\t    key, chunk_counter, flags, cv_array);\n\n\t \n\tuint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN / 2];\n\twhile (num_cvs > 2) {\n\t\tnum_cvs = compress_parents_parallel(ops, cv_array, num_cvs, key,\n\t\t    flags, out_array);\n\t\tmemcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);\n\t}\n\tmemcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);\n}\n\nstatic void hasher_init_base(BLAKE3_CTX *ctx, const uint32_t key[8],\n    uint8_t flags)\n{\n\tmemcpy(ctx->key, key, BLAKE3_KEY_LEN);\n\tchunk_state_init(&ctx->chunk, key, flags);\n\tctx->cv_stack_len = 0;\n\tctx->ops = blake3_get_ops();\n}\n\n \nstatic void hasher_merge_cv_stack(BLAKE3_CTX *ctx, uint64_t total_len)\n{\n\tsize_t post_merge_stack_len = (size_t)popcnt(total_len);\n\twhile (ctx->cv_stack_len > post_merge_stack_len) {\n\t\tuint8_t *parent_node =\n\t\t    &ctx->cv_stack[(ctx->cv_stack_len - 2) * BLAKE3_OUT_LEN];\n\t\toutput_t output =\n\t\t    parent_output(parent_node, ctx->key, ctx->chunk.flags);\n\t\toutput_chaining_value(ctx->ops, &output, parent_node);\n\t\tctx->cv_stack_len -= 1;\n\t}\n}\n\n \nstatic void hasher_push_cv(BLAKE3_CTX *ctx, uint8_t new_cv[BLAKE3_OUT_LEN],\n    uint64_t chunk_counter)\n{\n\thasher_merge_cv_stack(ctx, chunk_counter);\n\tmemcpy(&ctx->cv_stack[ctx->cv_stack_len * BLAKE3_OUT_LEN], new_cv,\n\t    BLAKE3_OUT_LEN);\n\tctx->cv_stack_len += 1;\n}\n\nvoid\nBlake3_Init(BLAKE3_CTX *ctx)\n{\n\thasher_init_base(ctx, BLAKE3_IV, 0);\n}\n\nvoid\nBlake3_InitKeyed(BLAKE3_CTX *ctx, const uint8_t key[BLAKE3_KEY_LEN])\n{\n\tuint32_t key_words[8];\n\tload_key_words(key, key_words);\n\thasher_init_base(ctx, key_words, KEYED_HASH);\n}\n\nstatic void\nBlake3_Update2(BLAKE3_CTX *ctx, const void *input, size_t input_len)\n{\n\t \n\tif (input_len == 0) {\n\t\treturn;\n\t}\n\n\tconst uint8_t *input_bytes = (const uint8_t *)input;\n\n\t \n\tif (chunk_state_len(&ctx->chunk) > 0) {\n\t\tsize_t take = BLAKE3_CHUNK_LEN - chunk_state_len(&ctx->chunk);\n\t\tif (take > input_len) {\n\t\t\ttake = input_len;\n\t\t}\n\t\tchunk_state_update(ctx->ops, &ctx->chunk, input_bytes, take);\n\t\tinput_bytes += take;\n\t\tinput_len -= take;\n\t\t \n\t\tif (input_len > 0) {\n\t\t\toutput_t output = chunk_state_output(&ctx->chunk);\n\t\t\tuint8_t chunk_cv[32];\n\t\t\toutput_chaining_value(ctx->ops, &output, chunk_cv);\n\t\t\thasher_push_cv(ctx, chunk_cv, ctx->chunk.chunk_counter);\n\t\t\tchunk_state_reset(&ctx->chunk, ctx->key,\n\t\t\t    ctx->chunk.chunk_counter + 1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\twhile (input_len > BLAKE3_CHUNK_LEN) {\n\t\tsize_t subtree_len = round_down_to_power_of_2(input_len);\n\t\tuint64_t count_so_far =\n\t\t    ctx->chunk.chunk_counter * BLAKE3_CHUNK_LEN;\n\t\t \n\t\twhile ((((uint64_t)(subtree_len - 1)) & count_so_far) != 0) {\n\t\t\tsubtree_len /= 2;\n\t\t}\n\t\t \n\t\tuint64_t subtree_chunks = subtree_len / BLAKE3_CHUNK_LEN;\n\t\tif (subtree_len <= BLAKE3_CHUNK_LEN) {\n\t\t\tblake3_chunk_state_t chunk_state;\n\t\t\tchunk_state_init(&chunk_state, ctx->key,\n\t\t\t    ctx->chunk.flags);\n\t\t\tchunk_state.chunk_counter = ctx->chunk.chunk_counter;\n\t\t\tchunk_state_update(ctx->ops, &chunk_state, input_bytes,\n\t\t\t    subtree_len);\n\t\t\toutput_t output = chunk_state_output(&chunk_state);\n\t\t\tuint8_t cv[BLAKE3_OUT_LEN];\n\t\t\toutput_chaining_value(ctx->ops, &output, cv);\n\t\t\thasher_push_cv(ctx, cv, chunk_state.chunk_counter);\n\t\t} else {\n\t\t\t \n\t\t\tuint8_t cv_pair[2 * BLAKE3_OUT_LEN];\n\t\t\tcompress_subtree_to_parent_node(ctx->ops, input_bytes,\n\t\t\t    subtree_len, ctx->key, ctx-> chunk.chunk_counter,\n\t\t\t    ctx->chunk.flags, cv_pair);\n\t\t\thasher_push_cv(ctx, cv_pair, ctx->chunk.chunk_counter);\n\t\t\thasher_push_cv(ctx, &cv_pair[BLAKE3_OUT_LEN],\n\t\t\t    ctx->chunk.chunk_counter + (subtree_chunks / 2));\n\t\t}\n\t\tctx->chunk.chunk_counter += subtree_chunks;\n\t\tinput_bytes += subtree_len;\n\t\tinput_len -= subtree_len;\n\t}\n\n\t \n\tif (input_len > 0) {\n\t\tchunk_state_update(ctx->ops, &ctx->chunk, input_bytes,\n\t\t    input_len);\n\t\thasher_merge_cv_stack(ctx, ctx->chunk.chunk_counter);\n\t}\n}\n\nvoid\nBlake3_Update(BLAKE3_CTX *ctx, const void *input, size_t todo)\n{\n\tsize_t done = 0;\n\tconst uint8_t *data = input;\n\tconst size_t block_max = 1024 * 64;\n\n\t \n\twhile (todo != 0) {\n\t\tsize_t block = (todo >= block_max) ? block_max : todo;\n\t\tBlake3_Update2(ctx, data + done, block);\n\t\tdone += block;\n\t\ttodo -= block;\n\t}\n}\n\nvoid\nBlake3_Final(const BLAKE3_CTX *ctx, uint8_t *out)\n{\n\tBlake3_FinalSeek(ctx, 0, out, BLAKE3_OUT_LEN);\n}\n\nvoid\nBlake3_FinalSeek(const BLAKE3_CTX *ctx, uint64_t seek, uint8_t *out,\n    size_t out_len)\n{\n\t \n\tif (out_len == 0) {\n\t\treturn;\n\t}\n\t \n\tif (ctx->cv_stack_len == 0) {\n\t\toutput_t output = chunk_state_output(&ctx->chunk);\n\t\toutput_root_bytes(ctx->ops, &output, seek, out, out_len);\n\t\treturn;\n\t}\n\t \n\toutput_t output;\n\tsize_t cvs_remaining;\n\tif (chunk_state_len(&ctx->chunk) > 0) {\n\t\tcvs_remaining = ctx->cv_stack_len;\n\t\toutput = chunk_state_output(&ctx->chunk);\n\t} else {\n\t\t \n\t\tcvs_remaining = ctx->cv_stack_len - 2;\n\t\toutput = parent_output(&ctx->cv_stack[cvs_remaining * 32],\n\t\t    ctx->key, ctx->chunk.flags);\n\t}\n\twhile (cvs_remaining > 0) {\n\t\tcvs_remaining -= 1;\n\t\tuint8_t parent_block[BLAKE3_BLOCK_LEN];\n\t\tmemcpy(parent_block, &ctx->cv_stack[cvs_remaining * 32], 32);\n\t\toutput_chaining_value(ctx->ops, &output, &parent_block[32]);\n\t\toutput = parent_output(parent_block, ctx->key,\n\t\t    ctx->chunk.flags);\n\t}\n\toutput_root_bytes(ctx->ops, &output, seek, out, out_len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}