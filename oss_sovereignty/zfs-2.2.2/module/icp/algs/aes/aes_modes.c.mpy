{
  "module_name": "aes_modes.c",
  "hash_id": "4408bb393091b52b4b013d2c457e919eb4328f97350bb41d5f7d91b330032b73",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/aes/aes_modes.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <modes/modes.h>\n#include <aes/aes_impl.h>\n\n \nvoid\naes_copy_block(uint8_t *in, uint8_t *out)\n{\n\tif (IS_P2ALIGNED2(in, out, sizeof (uint32_t))) {\n\t\t \n\t\t*(uint32_t *)&out[0] = *(uint32_t *)&in[0];\n\t\t \n\t\t*(uint32_t *)&out[4] = *(uint32_t *)&in[4];\n\t\t \n\t\t*(uint32_t *)&out[8] = *(uint32_t *)&in[8];\n\t\t \n\t\t*(uint32_t *)&out[12] = *(uint32_t *)&in[12];\n\t} else {\n\t\tAES_COPY_BLOCK(in, out);\n\t}\n}\n\n\n \nvoid\naes_xor_block(uint8_t *data, uint8_t *dst)\n{\n\tif (IS_P2ALIGNED2(dst, data, sizeof (uint32_t))) {\n\t\t \n\t\t*(uint32_t *)&dst[0] ^= *(uint32_t *)&data[0];\n\t\t \n\t\t*(uint32_t *)&dst[4] ^= *(uint32_t *)&data[4];\n\t\t \n\t\t*(uint32_t *)&dst[8] ^= *(uint32_t *)&data[8];\n\t\t \n\t\t*(uint32_t *)&dst[12] ^= *(uint32_t *)&data[12];\n\t} else {\n\t\tAES_XOR_BLOCK(data, dst);\n\t}\n}\n\n\n \nint\naes_encrypt_contiguous_blocks(void *ctx, char *data, size_t length,\n    crypto_data_t *out)\n{\n\taes_ctx_t *aes_ctx = ctx;\n\tint rv;\n\n\tif (aes_ctx->ac_flags & CTR_MODE) {\n\t\trv = ctr_mode_contiguous_blocks(ctx, data, length, out,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);\n\t} else if (aes_ctx->ac_flags & CCM_MODE) {\n\t\trv = ccm_mode_encrypt_contiguous_blocks(ctx, data, length,\n\t\t    out, AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t} else if (aes_ctx->ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\trv = gcm_mode_encrypt_contiguous_blocks(ctx, data, length,\n\t\t    out, AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t} else if (aes_ctx->ac_flags & CBC_MODE) {\n\t\trv = cbc_encrypt_contiguous_blocks(ctx,\n\t\t    data, length, out, AES_BLOCK_LEN, aes_encrypt_block,\n\t\t    aes_copy_block, aes_xor_block);\n\t} else {\n\t\trv = ecb_cipher_contiguous_blocks(ctx, data, length, out,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block);\n\t}\n\treturn (rv);\n}\n\n\n \nint\naes_decrypt_contiguous_blocks(void *ctx, char *data, size_t length,\n    crypto_data_t *out)\n{\n\taes_ctx_t *aes_ctx = ctx;\n\tint rv;\n\n\tif (aes_ctx->ac_flags & CTR_MODE) {\n\t\trv = ctr_mode_contiguous_blocks(ctx, data, length, out,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);\n\t\tif (rv == CRYPTO_DATA_LEN_RANGE)\n\t\t\trv = CRYPTO_ENCRYPTED_DATA_LEN_RANGE;\n\t} else if (aes_ctx->ac_flags & CCM_MODE) {\n\t\trv = ccm_mode_decrypt_contiguous_blocks(ctx, data, length,\n\t\t    out, AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t} else if (aes_ctx->ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\trv = gcm_mode_decrypt_contiguous_blocks(ctx, data, length,\n\t\t    out, AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t} else if (aes_ctx->ac_flags & CBC_MODE) {\n\t\trv = cbc_decrypt_contiguous_blocks(ctx, data, length, out,\n\t\t    AES_BLOCK_LEN, aes_decrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t} else {\n\t\trv = ecb_cipher_contiguous_blocks(ctx, data, length, out,\n\t\t    AES_BLOCK_LEN, aes_decrypt_block);\n\t\tif (rv == CRYPTO_DATA_LEN_RANGE)\n\t\t\trv = CRYPTO_ENCRYPTED_DATA_LEN_RANGE;\n\t}\n\treturn (rv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}