{
  "module_name": "sha512_impl.c",
  "hash_id": "d2bfe94bb44544cd03bee3f5b3bd3ffc6b7198ea534d178dc8ae8425bf87cbfb",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/sha2/sha512_impl.c",
  "human_readable_source": " \n\n \n\n#include <sys/simd.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_impl.h>\n#include <sys/sha2.h>\n\n#include <sha2/sha2_impl.h>\n#include <sys/asm_linkage.h>\n\n#define\tTF(E, N) \\\n\textern void ASMABI E(uint64_t s[8], const void *, size_t); \\\n\tstatic inline void N(uint64_t s[8], const void *d, size_t b) { \\\n\tkfpu_begin(); E(s, d, b); kfpu_end(); \\\n}\n\n \nstatic inline boolean_t sha2_is_supported(void)\n{\n\treturn (B_TRUE);\n}\n\n#if defined(__x86_64)\n\n \nextern void ASMABI\nzfs_sha512_transform_x64(uint64_t s[8], const void *, size_t);\n\nstatic inline void\ntf_sha512_transform_x64(uint64_t s[8], const void *d, size_t b)\n{\n\tzfs_sha512_transform_x64(s, d, b);\n}\nconst sha512_ops_t sha512_x64_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = tf_sha512_transform_x64,\n\t.name = \"x64\"\n};\n\n#if defined(HAVE_AVX)\nstatic boolean_t sha2_have_avx(void)\n{\n\treturn (kfpu_allowed() && zfs_avx_available());\n}\n\nTF(zfs_sha512_transform_avx, tf_sha512_avx);\nconst sha512_ops_t sha512_avx_impl = {\n\t.is_supported = sha2_have_avx,\n\t.transform = tf_sha512_avx,\n\t.name = \"avx\"\n};\n#endif\n\n#if defined(HAVE_AVX2)\nstatic boolean_t sha2_have_avx2(void)\n{\n\treturn (kfpu_allowed() && zfs_avx2_available());\n}\n\nTF(zfs_sha512_transform_avx2, tf_sha512_avx2);\nconst sha512_ops_t sha512_avx2_impl = {\n\t.is_supported = sha2_have_avx2,\n\t.transform = tf_sha512_avx2,\n\t.name = \"avx2\"\n};\n#endif\n\n#elif defined(__aarch64__)\nextern void zfs_sha512_block_armv7(uint64_t s[8], const void *, size_t);\nconst sha512_ops_t sha512_armv7_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = zfs_sha512_block_armv7,\n\t.name = \"armv7\"\n};\n\nstatic boolean_t sha512_have_armv8ce(void)\n{\n\treturn (kfpu_allowed() && zfs_sha512_available());\n}\n\nTF(zfs_sha512_block_armv8, tf_sha512_armv8ce);\nconst sha512_ops_t sha512_armv8_impl = {\n\t.is_supported = sha512_have_armv8ce,\n\t.transform = tf_sha512_armv8ce,\n\t.name = \"armv8-ce\"\n};\n\n#elif defined(__arm__) && __ARM_ARCH > 6\nextern void zfs_sha512_block_armv7(uint64_t s[8], const void *, size_t);\nconst sha512_ops_t sha512_armv7_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = zfs_sha512_block_armv7,\n\t.name = \"armv7\"\n};\n\nstatic boolean_t sha512_have_neon(void)\n{\n\treturn (kfpu_allowed() && zfs_neon_available());\n}\n\nTF(zfs_sha512_block_neon, tf_sha512_neon);\nconst sha512_ops_t sha512_neon_impl = {\n\t.is_supported = sha512_have_neon,\n\t.transform = tf_sha512_neon,\n\t.name = \"neon\"\n};\n\n#elif defined(__PPC64__)\nTF(zfs_sha512_ppc, tf_sha512_ppc);\nconst sha512_ops_t sha512_ppc_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = tf_sha512_ppc,\n\t.name = \"ppc\"\n};\n\nstatic boolean_t sha512_have_isa207(void)\n{\n\treturn (kfpu_allowed() && zfs_isa207_available());\n}\n\nTF(zfs_sha512_power8, tf_sha512_power8);\nconst sha512_ops_t sha512_power8_impl = {\n\t.is_supported = sha512_have_isa207,\n\t.transform = tf_sha512_power8,\n\t.name = \"power8\"\n};\n#endif  \n\n \nextern const sha512_ops_t sha512_generic_impl;\n\n \nstatic const sha512_ops_t *const sha512_impls[] = {\n\t&sha512_generic_impl,\n#if defined(__x86_64)\n\t&sha512_x64_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX)\n\t&sha512_avx_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX2)\n\t&sha512_avx2_impl,\n#endif\n#if defined(__aarch64__)\n\t&sha512_armv7_impl,\n\t&sha512_armv8_impl,\n#endif\n#if defined(__arm__) && __ARM_ARCH > 6\n\t&sha512_armv7_impl,\n\t&sha512_neon_impl,\n#endif\n#if defined(__PPC64__)\n\t&sha512_ppc_impl,\n\t&sha512_power8_impl,\n#endif  \n};\n\n \n#define\tIMPL_NAME\t\t\"sha512\"\n#define\tIMPL_OPS_T\t\tsha512_ops_t\n#define\tIMPL_ARRAY\t\tsha512_impls\n#define\tIMPL_GET_OPS\t\tsha512_get_ops\n#define\tZFS_IMPL_OPS\t\tzfs_sha512_ops\n#include <generic_impl.c>\n\n#ifdef _KERNEL\n\n#define\tIMPL_FMT(impl, i)\t(((impl) == (i)) ? \"[%s] \" : \"%s \")\n\n#if defined(__linux__)\n\nstatic int\nsha512_param_get(char *buffer, zfs_kernel_param_t *unused)\n{\n\tconst uint32_t impl = IMPL_READ(generic_impl_chosen);\n\tchar *fmt;\n\tint cnt = 0;\n\n\t \n\tfmt = IMPL_FMT(impl, IMPL_CYCLE);\n\tcnt += sprintf(buffer + cnt, fmt, \"cycle\");\n\n\t \n\tfmt = IMPL_FMT(impl, IMPL_FASTEST);\n\tcnt += sprintf(buffer + cnt, fmt, \"fastest\");\n\n\t \n\tgeneric_impl_init();\n\tfor (uint32_t i = 0; i < generic_supp_impls_cnt; ++i) {\n\t\tfmt = IMPL_FMT(impl, i);\n\t\tcnt += sprintf(buffer + cnt, fmt,\n\t\t    generic_supp_impls[i]->name);\n\t}\n\n\treturn (cnt);\n}\n\nstatic int\nsha512_param_set(const char *val, zfs_kernel_param_t *unused)\n{\n\t(void) unused;\n\treturn (generic_impl_setname(val));\n}\n\n#elif defined(__FreeBSD__)\n\n#include <sys/sbuf.h>\n\nstatic int\nsha512_param(ZFS_MODULE_PARAM_ARGS)\n{\n\tint err;\n\n\tgeneric_impl_init();\n\tif (req->newptr == NULL) {\n\t\tconst uint32_t impl = IMPL_READ(generic_impl_chosen);\n\t\tconst int init_buflen = 64;\n\t\tconst char *fmt;\n\t\tstruct sbuf *s;\n\n\t\ts = sbuf_new_for_sysctl(NULL, NULL, init_buflen, req);\n\n\t\t \n\t\tfmt = IMPL_FMT(impl, IMPL_CYCLE);\n\t\t(void) sbuf_printf(s, fmt, \"cycle\");\n\n\t\t \n\t\tfmt = IMPL_FMT(impl, IMPL_FASTEST);\n\t\t(void) sbuf_printf(s, fmt, \"fastest\");\n\n\t\t \n\t\tfor (uint32_t i = 0; i < generic_supp_impls_cnt; ++i) {\n\t\t\tfmt = IMPL_FMT(impl, i);\n\t\t\t(void) sbuf_printf(s, fmt, generic_supp_impls[i]->name);\n\t\t}\n\n\t\terr = sbuf_finish(s);\n\t\tsbuf_delete(s);\n\n\t\treturn (err);\n\t}\n\n\t \n\tchar buf[16];\n\n\terr = sysctl_handle_string(oidp, buf, sizeof (buf), req);\n\tif (err) {\n\t\treturn (err);\n\t}\n\n\treturn (-generic_impl_setname(buf));\n}\n#endif\n\n#undef IMPL_FMT\n\nZFS_MODULE_VIRTUAL_PARAM_CALL(zfs, zfs_, sha512_impl,\n    sha512_param_set, sha512_param_get, ZMOD_RW, \\\n\t\"Select SHA512 implementation.\");\n#endif\n\n#undef TF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}