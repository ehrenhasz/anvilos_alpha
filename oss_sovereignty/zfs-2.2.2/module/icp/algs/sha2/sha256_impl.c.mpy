{
  "module_name": "sha256_impl.c",
  "hash_id": "065546d663dc59ce2b2ffd2c6f080013ea9bccb83f2afa68d5446bc984cafb9a",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/algs/sha2/sha256_impl.c",
  "human_readable_source": " \n\n \n\n#include <sys/simd.h>\n#include <sys/zfs_context.h>\n#include <sys/zfs_impl.h>\n#include <sys/sha2.h>\n\n#include <sha2/sha2_impl.h>\n#include <sys/asm_linkage.h>\n\n#define\tTF(E, N) \\\n\textern void ASMABI E(uint32_t s[8], const void *, size_t); \\\n\tstatic inline void N(uint32_t s[8], const void *d, size_t b) { \\\n\tkfpu_begin(); E(s, d, b); kfpu_end(); \\\n}\n\n \nstatic inline boolean_t sha2_is_supported(void)\n{\n\treturn (B_TRUE);\n}\n\n#if defined(__x86_64)\n\n \nextern void ASMABI\nzfs_sha256_transform_x64(uint32_t s[8], const void *, size_t);\n\nstatic inline void\ntf_sha256_transform_x64(uint32_t s[8], const void *d, size_t b)\n{\n\tzfs_sha256_transform_x64(s, d, b);\n}\n\nconst sha256_ops_t sha256_x64_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = tf_sha256_transform_x64,\n\t.name = \"x64\"\n};\n\n#if defined(HAVE_SSSE3)\nstatic boolean_t sha2_have_ssse3(void)\n{\n\treturn (kfpu_allowed() && zfs_ssse3_available());\n}\n\nTF(zfs_sha256_transform_ssse3, tf_sha256_ssse3);\nconst sha256_ops_t sha256_ssse3_impl = {\n\t.is_supported = sha2_have_ssse3,\n\t.transform = tf_sha256_ssse3,\n\t.name = \"ssse3\"\n};\n#endif\n\n#if defined(HAVE_AVX)\nstatic boolean_t sha2_have_avx(void)\n{\n\treturn (kfpu_allowed() && zfs_avx_available());\n}\n\nTF(zfs_sha256_transform_avx, tf_sha256_avx);\nconst sha256_ops_t sha256_avx_impl = {\n\t.is_supported = sha2_have_avx,\n\t.transform = tf_sha256_avx,\n\t.name = \"avx\"\n};\n#endif\n\n#if defined(HAVE_AVX2)\nstatic boolean_t sha2_have_avx2(void)\n{\n\treturn (kfpu_allowed() && zfs_avx2_available());\n}\n\nTF(zfs_sha256_transform_avx2, tf_sha256_avx2);\nconst sha256_ops_t sha256_avx2_impl = {\n\t.is_supported = sha2_have_avx2,\n\t.transform = tf_sha256_avx2,\n\t.name = \"avx2\"\n};\n#endif\n\n#if defined(HAVE_SSE4_1)\nstatic boolean_t sha2_have_shani(void)\n{\n\treturn (kfpu_allowed() && zfs_sse4_1_available() && \\\n\t    zfs_shani_available());\n}\n\nTF(zfs_sha256_transform_shani, tf_sha256_shani);\nconst sha256_ops_t sha256_shani_impl = {\n\t.is_supported = sha2_have_shani,\n\t.transform = tf_sha256_shani,\n\t.name = \"shani\"\n};\n#endif\n\n#elif defined(__aarch64__) || (defined(__arm__) && __ARM_ARCH > 6)\nstatic boolean_t sha256_have_neon(void)\n{\n\treturn (kfpu_allowed() && zfs_neon_available());\n}\n\nstatic boolean_t sha256_have_armv8ce(void)\n{\n\treturn (kfpu_allowed() && zfs_sha256_available());\n}\n\nextern void zfs_sha256_block_armv7(uint32_t s[8], const void *, size_t);\nconst sha256_ops_t sha256_armv7_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = zfs_sha256_block_armv7,\n\t.name = \"armv7\"\n};\n\nTF(zfs_sha256_block_neon, tf_sha256_neon);\nconst sha256_ops_t sha256_neon_impl = {\n\t.is_supported = sha256_have_neon,\n\t.transform = tf_sha256_neon,\n\t.name = \"neon\"\n};\n\nTF(zfs_sha256_block_armv8, tf_sha256_armv8ce);\nconst sha256_ops_t sha256_armv8_impl = {\n\t.is_supported = sha256_have_armv8ce,\n\t.transform = tf_sha256_armv8ce,\n\t.name = \"armv8-ce\"\n};\n\n#elif defined(__PPC64__)\nstatic boolean_t sha256_have_isa207(void)\n{\n\treturn (kfpu_allowed() && zfs_isa207_available());\n}\n\nTF(zfs_sha256_ppc, tf_sha256_ppc);\nconst sha256_ops_t sha256_ppc_impl = {\n\t.is_supported = sha2_is_supported,\n\t.transform = tf_sha256_ppc,\n\t.name = \"ppc\"\n};\n\nTF(zfs_sha256_power8, tf_sha256_power8);\nconst sha256_ops_t sha256_power8_impl = {\n\t.is_supported = sha256_have_isa207,\n\t.transform = tf_sha256_power8,\n\t.name = \"power8\"\n};\n#endif  \n\n \nextern const sha256_ops_t sha256_generic_impl;\n\n \nstatic const sha256_ops_t *const sha256_impls[] = {\n\t&sha256_generic_impl,\n#if defined(__x86_64)\n\t&sha256_x64_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_SSSE3)\n\t&sha256_ssse3_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX)\n\t&sha256_avx_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_AVX2)\n\t&sha256_avx2_impl,\n#endif\n#if defined(__x86_64) && defined(HAVE_SSE4_1)\n\t&sha256_shani_impl,\n#endif\n#if defined(__aarch64__) || (defined(__arm__) && __ARM_ARCH > 6)\n\t&sha256_armv7_impl,\n\t&sha256_neon_impl,\n\t&sha256_armv8_impl,\n#endif\n#if defined(__PPC64__)\n\t&sha256_ppc_impl,\n\t&sha256_power8_impl,\n#endif  \n};\n\n \n#define\tIMPL_NAME\t\t\"sha256\"\n#define\tIMPL_OPS_T\t\tsha256_ops_t\n#define\tIMPL_ARRAY\t\tsha256_impls\n#define\tIMPL_GET_OPS\t\tsha256_get_ops\n#define\tZFS_IMPL_OPS\t\tzfs_sha256_ops\n#include <generic_impl.c>\n\n#ifdef _KERNEL\n\n#define\tIMPL_FMT(impl, i)\t(((impl) == (i)) ? \"[%s] \" : \"%s \")\n\n#if defined(__linux__)\n\nstatic int\nsha256_param_get(char *buffer, zfs_kernel_param_t *unused)\n{\n\tconst uint32_t impl = IMPL_READ(generic_impl_chosen);\n\tchar *fmt;\n\tint cnt = 0;\n\n\t \n\tfmt = IMPL_FMT(impl, IMPL_CYCLE);\n\tcnt += sprintf(buffer + cnt, fmt, \"cycle\");\n\n\t \n\tfmt = IMPL_FMT(impl, IMPL_FASTEST);\n\tcnt += sprintf(buffer + cnt, fmt, \"fastest\");\n\n\t \n\tgeneric_impl_init();\n\tfor (uint32_t i = 0; i < generic_supp_impls_cnt; ++i) {\n\t\tfmt = IMPL_FMT(impl, i);\n\t\tcnt += sprintf(buffer + cnt, fmt,\n\t\t    generic_supp_impls[i]->name);\n\t}\n\n\treturn (cnt);\n}\n\nstatic int\nsha256_param_set(const char *val, zfs_kernel_param_t *unused)\n{\n\t(void) unused;\n\treturn (generic_impl_setname(val));\n}\n\n#elif defined(__FreeBSD__)\n\n#include <sys/sbuf.h>\n\nstatic int\nsha256_param(ZFS_MODULE_PARAM_ARGS)\n{\n\tint err;\n\n\tgeneric_impl_init();\n\tif (req->newptr == NULL) {\n\t\tconst uint32_t impl = IMPL_READ(generic_impl_chosen);\n\t\tconst int init_buflen = 64;\n\t\tconst char *fmt;\n\t\tstruct sbuf *s;\n\n\t\ts = sbuf_new_for_sysctl(NULL, NULL, init_buflen, req);\n\n\t\t \n\t\tfmt = IMPL_FMT(impl, IMPL_CYCLE);\n\t\t(void) sbuf_printf(s, fmt, \"cycle\");\n\n\t\t \n\t\tfmt = IMPL_FMT(impl, IMPL_FASTEST);\n\t\t(void) sbuf_printf(s, fmt, \"fastest\");\n\n\t\t \n\t\tfor (uint32_t i = 0; i < generic_supp_impls_cnt; ++i) {\n\t\t\tfmt = IMPL_FMT(impl, i);\n\t\t\t(void) sbuf_printf(s, fmt, generic_supp_impls[i]->name);\n\t\t}\n\n\t\terr = sbuf_finish(s);\n\t\tsbuf_delete(s);\n\n\t\treturn (err);\n\t}\n\n\tchar buf[16];\n\n\terr = sysctl_handle_string(oidp, buf, sizeof (buf), req);\n\tif (err) {\n\t\treturn (err);\n\t}\n\n\treturn (-generic_impl_setname(buf));\n}\n#endif\n\n#undef IMPL_FMT\n\nZFS_MODULE_VIRTUAL_PARAM_CALL(zfs, zfs_, sha256_impl,\n    sha256_param_set, sha256_param_get, ZMOD_RW, \\\n\t\"Select SHA256 implementation.\");\n#endif\n\n#undef TF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}