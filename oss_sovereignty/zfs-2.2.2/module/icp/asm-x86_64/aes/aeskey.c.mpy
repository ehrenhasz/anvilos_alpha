{
  "module_name": "aeskey.c",
  "hash_id": "db938590950812599b6cf02bff4ede3fc14ef5f9e5def2e06931898fa23f97bb",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/asm-x86_64/aes/aeskey.c",
  "human_readable_source": " \n\n#include <aes/aes_impl.h>\n#include \"aesopt.h\"\n#include \"aestab.h\"\n#include \"aestab2.h\"\n\n \n\n \n\n#if defined(REDUCE_CODE_SIZE)\n#define\tls_box ls_sub\n\tuint32_t\tls_sub(const uint32_t t, const uint32_t n);\n#define\tinv_mcol im_sub\n\tuint32_t\tim_sub(const uint32_t x);\n#ifdef ENC_KS_UNROLL\n#undef ENC_KS_UNROLL\n#endif\n#ifdef DEC_KS_UNROLL\n#undef DEC_KS_UNROLL\n#endif\n#endif\t \n\n\n#define\tke4(k, i) \\\n{\tk[4 * (i) + 4] = ss[0] ^= ls_box(ss[3], 3) ^ t_use(r, c)[i]; \\\n\tk[4 * (i) + 5] = ss[1] ^= ss[0]; \\\n\tk[4 * (i) + 6] = ss[2] ^= ss[1]; \\\n\tk[4 * (i) + 7] = ss[3] ^= ss[2]; \\\n}\n\nstatic void\naes_encrypt_key128(const unsigned char *key, uint32_t rk[])\n{\n\tuint32_t\tss[4];\n\n\trk[0] = ss[0] = word_in(key, 0);\n\trk[1] = ss[1] = word_in(key, 1);\n\trk[2] = ss[2] = word_in(key, 2);\n\trk[3] = ss[3] = word_in(key, 3);\n\n#ifdef ENC_KS_UNROLL\n\tke4(rk, 0);  ke4(rk, 1);\n\tke4(rk, 2);  ke4(rk, 3);\n\tke4(rk, 4);  ke4(rk, 5);\n\tke4(rk, 6);  ke4(rk, 7);\n\tke4(rk, 8);\n#else\n\t{\n\t\tuint32_t\ti;\n\t\tfor (i = 0; i < 9; ++i)\n\t\t\tke4(rk, i);\n\t}\n#endif\t \n\tke4(rk, 9);\n}\n\n\n#define\tkef6(k, i) \\\n{\tk[6 * (i) + 6] = ss[0] ^= ls_box(ss[5], 3) ^ t_use(r, c)[i]; \\\n\tk[6 * (i) + 7] = ss[1] ^= ss[0]; \\\n\tk[6 * (i) + 8] = ss[2] ^= ss[1]; \\\n\tk[6 * (i) + 9] = ss[3] ^= ss[2]; \\\n}\n\n#define\tke6(k, i) \\\n{\tkef6(k, i); \\\n\tk[6 * (i) + 10] = ss[4] ^= ss[3]; \\\n\tk[6 * (i) + 11] = ss[5] ^= ss[4]; \\\n}\n\nstatic void\naes_encrypt_key192(const unsigned char *key, uint32_t rk[])\n{\n\tuint32_t\tss[6];\n\n\trk[0] = ss[0] = word_in(key, 0);\n\trk[1] = ss[1] = word_in(key, 1);\n\trk[2] = ss[2] = word_in(key, 2);\n\trk[3] = ss[3] = word_in(key, 3);\n\trk[4] = ss[4] = word_in(key, 4);\n\trk[5] = ss[5] = word_in(key, 5);\n\n#ifdef ENC_KS_UNROLL\n\tke6(rk, 0);  ke6(rk, 1);\n\tke6(rk, 2);  ke6(rk, 3);\n\tke6(rk, 4);  ke6(rk, 5);\n\tke6(rk, 6);\n#else\n\t{\n\t\tuint32_t\ti;\n\t\tfor (i = 0; i < 7; ++i)\n\t\t\tke6(rk, i);\n\t}\n#endif\t \n\tkef6(rk, 7);\n}\n\n\n\n#define\tkef8(k, i) \\\n{\tk[8 * (i) + 8] = ss[0] ^= ls_box(ss[7], 3) ^ t_use(r, c)[i]; \\\n\tk[8 * (i) + 9] = ss[1] ^= ss[0]; \\\n\tk[8 * (i) + 10] = ss[2] ^= ss[1]; \\\n\tk[8 * (i) + 11] = ss[3] ^= ss[2]; \\\n}\n\n#define\tke8(k, i) \\\n{   kef8(k, i); \\\n\tk[8 * (i) + 12] = ss[4] ^= ls_box(ss[3], 0); \\\n\tk[8 * (i) + 13] = ss[5] ^= ss[4]; \\\n\tk[8 * (i) + 14] = ss[6] ^= ss[5]; \\\n\tk[8 * (i) + 15] = ss[7] ^= ss[6]; \\\n}\n\nstatic void\naes_encrypt_key256(const unsigned char *key, uint32_t rk[])\n{\n\tuint32_t\tss[8];\n\n\trk[0] = ss[0] = word_in(key, 0);\n\trk[1] = ss[1] = word_in(key, 1);\n\trk[2] = ss[2] = word_in(key, 2);\n\trk[3] = ss[3] = word_in(key, 3);\n\trk[4] = ss[4] = word_in(key, 4);\n\trk[5] = ss[5] = word_in(key, 5);\n\trk[6] = ss[6] = word_in(key, 6);\n\trk[7] = ss[7] = word_in(key, 7);\n\n#ifdef ENC_KS_UNROLL\n\tke8(rk, 0); ke8(rk, 1);\n\tke8(rk, 2); ke8(rk, 3);\n\tke8(rk, 4); ke8(rk, 5);\n#else\n\t{\n\t\tuint32_t\ti;\n\t\tfor (i = 0; i < 6; ++i)\n\t\t\tke8(rk,  i);\n\t}\n#endif\t \n\tkef8(rk, 6);\n}\n\n\n \nint\nrijndael_key_setup_enc_amd64(uint32_t rk[], const uint32_t cipherKey[],\n    int keyBits)\n{\n\tswitch (keyBits) {\n\tcase 128:\n\t\taes_encrypt_key128((unsigned char *)&cipherKey[0], rk);\n\t\treturn (10);\n\tcase 192:\n\t\taes_encrypt_key192((unsigned char *)&cipherKey[0], rk);\n\t\treturn (12);\n\tcase 256:\n\t\taes_encrypt_key256((unsigned char *)&cipherKey[0], rk);\n\t\treturn (14);\n\tdefault:  \n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n\n\n \n \n\n#ifdef AES_REV_DKS\n#define\tv(n, i)  ((n) - (i) + 2 * ((i) & 3))\n#else\n#define\tv(n, i)  (i)\n#endif\n\n#if DEC_ROUND == NO_TABLES\n#define\tff(x)   (x)\n#else\n#define\tff(x)   inv_mcol(x)\n#if defined(dec_imvars)\n#define\td_vars  dec_imvars\n#endif\n#endif\t \n\n\n#define\tk4e(k, i) \\\n{\tk[v(40, (4 * (i)) + 4)] = ss[0] ^= ls_box(ss[3], 3) ^ t_use(r, c)[i]; \\\n\tk[v(40, (4 * (i)) + 5)] = ss[1] ^= ss[0]; \\\n\tk[v(40, (4 * (i)) + 6)] = ss[2] ^= ss[1]; \\\n\tk[v(40, (4 * (i)) + 7)] = ss[3] ^= ss[2]; \\\n}\n\n#if 1\n\n#define\tkdf4(k, i) \\\n{\tss[0] = ss[0] ^ ss[2] ^ ss[1] ^ ss[3]; \\\n\tss[1] = ss[1] ^ ss[3]; \\\n\tss[2] = ss[2] ^ ss[3]; \\\n\tss[4] = ls_box(ss[(i + 3) % 4], 3) ^ t_use(r, c)[i]; \\\n\tss[i % 4] ^= ss[4]; \\\n\tss[4] ^= k[v(40, (4 * (i)))];   k[v(40, (4 * (i)) + 4)] = ff(ss[4]); \\\n\tss[4] ^= k[v(40, (4 * (i)) + 1)]; k[v(40, (4 * (i)) + 5)] = ff(ss[4]); \\\n\tss[4] ^= k[v(40, (4 * (i)) + 2)]; k[v(40, (4 * (i)) + 6)] = ff(ss[4]); \\\n\tss[4] ^= k[v(40, (4 * (i)) + 3)]; k[v(40, (4 * (i)) + 7)] = ff(ss[4]); \\\n}\n\n#define\tkd4(k, i) \\\n{\tss[4] = ls_box(ss[(i + 3) % 4], 3) ^ t_use(r, c)[i]; \\\n\tss[i % 4] ^= ss[4]; ss[4] = ff(ss[4]); \\\n\tk[v(40, (4 * (i)) + 4)] = ss[4] ^= k[v(40, (4 * (i)))]; \\\n\tk[v(40, (4 * (i)) + 5)] = ss[4] ^= k[v(40, (4 * (i)) + 1)]; \\\n\tk[v(40, (4 * (i)) + 6)] = ss[4] ^= k[v(40, (4 * (i)) + 2)]; \\\n\tk[v(40, (4 * (i)) + 7)] = ss[4] ^= k[v(40, (4 * (i)) + 3)]; \\\n}\n\n#define\tkdl4(k, i) \\\n{\tss[4] = ls_box(ss[(i + 3) % 4], 3) ^ t_use(r, c)[i]; \\\n\tss[i % 4] ^= ss[4]; \\\n\tk[v(40, (4 * (i)) + 4)] = (ss[0] ^= ss[1]) ^ ss[2] ^ ss[3]; \\\n\tk[v(40, (4 * (i)) + 5)] = ss[1] ^ ss[3]; \\\n\tk[v(40, (4 * (i)) + 6)] = ss[0]; \\\n\tk[v(40, (4 * (i)) + 7)] = ss[1]; \\\n}\n\n#else\n\n#define\tkdf4(k, i) \\\n{\tss[0] ^= ls_box(ss[3], 3) ^ t_use(r, c)[i]; \\\n\tk[v(40, (4 * (i)) + 4)] = ff(ss[0]); \\\n\tss[1] ^= ss[0]; k[v(40, (4 * (i)) + 5)] = ff(ss[1]); \\\n\tss[2] ^= ss[1]; k[v(40, (4 * (i)) + 6)] = ff(ss[2]); \\\n\tss[3] ^= ss[2]; k[v(40, (4 * (i)) + 7)] = ff(ss[3]); \\\n}\n\n#define\tkd4(k, i) \\\n{\tss[4] = ls_box(ss[3], 3) ^ t_use(r, c)[i]; \\\n\tss[0] ^= ss[4]; \\\n\tss[4] = ff(ss[4]); \\\n\tk[v(40, (4 * (i)) + 4)] = ss[4] ^= k[v(40, (4 * (i)))]; \\\n\tss[1] ^= ss[0]; \\\n\tk[v(40, (4 * (i)) + 5)] = ss[4] ^= k[v(40, (4 * (i)) + 1)]; \\\n\tss[2] ^= ss[1]; \\\n\tk[v(40, (4 * (i)) + 6)] = ss[4] ^= k[v(40, (4 * (i)) + 2)]; \\\n\tss[3] ^= ss[2]; \\\n\tk[v(40, (4 * (i)) + 7)] = ss[4] ^= k[v(40, (4 * (i)) + 3)]; \\\n}\n\n#define\tkdl4(k, i) \\\n{\tss[0] ^= ls_box(ss[3], 3) ^ t_use(r, c)[i]; \\\n\tk[v(40, (4 * (i)) + 4)] = ss[0]; \\\n\tss[1] ^= ss[0]; k[v(40, (4 * (i)) + 5)] = ss[1]; \\\n\tss[2] ^= ss[1]; k[v(40, (4 * (i)) + 6)] = ss[2]; \\\n\tss[3] ^= ss[2]; k[v(40, (4 * (i)) + 7)] = ss[3]; \\\n}\n\n#endif\n\nstatic void\naes_decrypt_key128(const unsigned char *key, uint32_t rk[])\n{\n\tuint32_t\tss[5];\n#if defined(d_vars)\n\td_vars;\n#endif\n\trk[v(40, (0))] = ss[0] = word_in(key, 0);\n\trk[v(40, (1))] = ss[1] = word_in(key, 1);\n\trk[v(40, (2))] = ss[2] = word_in(key, 2);\n\trk[v(40, (3))] = ss[3] = word_in(key, 3);\n\n#ifdef DEC_KS_UNROLL\n\tkdf4(rk, 0); kd4(rk, 1);\n\tkd4(rk, 2);  kd4(rk, 3);\n\tkd4(rk, 4);  kd4(rk, 5);\n\tkd4(rk, 6);  kd4(rk, 7);\n\tkd4(rk, 8);  kdl4(rk, 9);\n#else\n\t{\n\t\tuint32_t\ti;\n\t\tfor (i = 0; i < 10; ++i)\n\t\t\tk4e(rk, i);\n#if !(DEC_ROUND == NO_TABLES)\n\t\tfor (i = MAX_AES_NB; i < 10 * MAX_AES_NB; ++i)\n\t\t\trk[i] = inv_mcol(rk[i]);\n#endif\n\t}\n#endif\t \n}\n\n\n\n#define\tk6ef(k, i) \\\n{\tk[v(48, (6 * (i)) + 6)] = ss[0] ^= ls_box(ss[5], 3) ^ t_use(r, c)[i]; \\\n\tk[v(48, (6 * (i)) + 7)] = ss[1] ^= ss[0]; \\\n\tk[v(48, (6 * (i)) + 8)] = ss[2] ^= ss[1]; \\\n\tk[v(48, (6 * (i)) + 9)] = ss[3] ^= ss[2]; \\\n}\n\n#define\tk6e(k, i) \\\n{\tk6ef(k, i); \\\n\tk[v(48, (6 * (i)) + 10)] = ss[4] ^= ss[3]; \\\n\tk[v(48, (6 * (i)) + 11)] = ss[5] ^= ss[4]; \\\n}\n\n#define\tkdf6(k, i) \\\n{\tss[0] ^= ls_box(ss[5], 3) ^ t_use(r, c)[i]; \\\n\tk[v(48, (6 * (i)) + 6)] = ff(ss[0]); \\\n\tss[1] ^= ss[0]; k[v(48, (6 * (i)) + 7)] = ff(ss[1]); \\\n\tss[2] ^= ss[1]; k[v(48, (6 * (i)) + 8)] = ff(ss[2]); \\\n\tss[3] ^= ss[2]; k[v(48, (6 * (i)) + 9)] = ff(ss[3]); \\\n\tss[4] ^= ss[3]; k[v(48, (6 * (i)) + 10)] = ff(ss[4]); \\\n\tss[5] ^= ss[4]; k[v(48, (6 * (i)) + 11)] = ff(ss[5]); \\\n}\n\n#define\tkd6(k, i) \\\n{\tss[6] = ls_box(ss[5], 3) ^ t_use(r, c)[i]; \\\n\tss[0] ^= ss[6]; ss[6] = ff(ss[6]); \\\n\tk[v(48, (6 * (i)) + 6)] = ss[6] ^= k[v(48, (6 * (i)))]; \\\n\tss[1] ^= ss[0]; \\\n\tk[v(48, (6 * (i)) + 7)] = ss[6] ^= k[v(48, (6 * (i)) + 1)]; \\\n\tss[2] ^= ss[1]; \\\n\tk[v(48, (6 * (i)) + 8)] = ss[6] ^= k[v(48, (6 * (i)) + 2)]; \\\n\tss[3] ^= ss[2]; \\\n\tk[v(48, (6 * (i)) + 9)] = ss[6] ^= k[v(48, (6 * (i)) + 3)]; \\\n\tss[4] ^= ss[3]; \\\n\tk[v(48, (6 * (i)) + 10)] = ss[6] ^= k[v(48, (6 * (i)) + 4)]; \\\n\tss[5] ^= ss[4]; \\\n\tk[v(48, (6 * (i)) + 11)] = ss[6] ^= k[v(48, (6 * (i)) + 5)]; \\\n}\n\n#define\tkdl6(k, i) \\\n{\tss[0] ^= ls_box(ss[5], 3) ^ t_use(r, c)[i]; \\\n\tk[v(48, (6 * (i)) + 6)] = ss[0]; \\\n\tss[1] ^= ss[0]; k[v(48, (6 * (i)) + 7)] = ss[1]; \\\n\tss[2] ^= ss[1]; k[v(48, (6 * (i)) + 8)] = ss[2]; \\\n\tss[3] ^= ss[2]; k[v(48, (6 * (i)) + 9)] = ss[3]; \\\n}\n\nstatic void\naes_decrypt_key192(const unsigned char *key, uint32_t rk[])\n{\n\tuint32_t\tss[7];\n#if defined(d_vars)\n\td_vars;\n#endif\n\trk[v(48, (0))] = ss[0] = word_in(key, 0);\n\trk[v(48, (1))] = ss[1] = word_in(key, 1);\n\trk[v(48, (2))] = ss[2] = word_in(key, 2);\n\trk[v(48, (3))] = ss[3] = word_in(key, 3);\n\n#ifdef DEC_KS_UNROLL\n\tss[4] = word_in(key, 4);\n\trk[v(48, (4))] = ff(ss[4]);\n\tss[5] = word_in(key, 5);\n\trk[v(48, (5))] = ff(ss[5]);\n\tkdf6(rk, 0); kd6(rk, 1);\n\tkd6(rk, 2);  kd6(rk, 3);\n\tkd6(rk, 4);  kd6(rk, 5);\n\tkd6(rk, 6);  kdl6(rk, 7);\n#else\n\trk[v(48, (4))] = ss[4] = word_in(key, 4);\n\trk[v(48, (5))] = ss[5] = word_in(key, 5);\n\t{\n\t\tuint32_t\ti;\n\n\t\tfor (i = 0; i < 7; ++i)\n\t\t\tk6e(rk, i);\n\t\tk6ef(rk, 7);\n#if !(DEC_ROUND == NO_TABLES)\n\t\tfor (i = MAX_AES_NB; i < 12 * MAX_AES_NB; ++i)\n\t\t\trk[i] = inv_mcol(rk[i]);\n#endif\n\t}\n#endif\n}\n\n\n\n#define\tk8ef(k, i) \\\n{\tk[v(56, (8 * (i)) + 8)] = ss[0] ^= ls_box(ss[7], 3) ^ t_use(r, c)[i]; \\\n\tk[v(56, (8 * (i)) + 9)] = ss[1] ^= ss[0]; \\\n\tk[v(56, (8 * (i)) + 10)] = ss[2] ^= ss[1]; \\\n\tk[v(56, (8 * (i)) + 11)] = ss[3] ^= ss[2]; \\\n}\n\n#define\tk8e(k, i) \\\n{\tk8ef(k, i); \\\n\tk[v(56, (8 * (i)) + 12)] = ss[4] ^= ls_box(ss[3], 0); \\\n\tk[v(56, (8 * (i)) + 13)] = ss[5] ^= ss[4]; \\\n\tk[v(56, (8 * (i)) + 14)] = ss[6] ^= ss[5]; \\\n\tk[v(56, (8 * (i)) + 15)] = ss[7] ^= ss[6]; \\\n}\n\n#define\tkdf8(k, i) \\\n{\tss[0] ^= ls_box(ss[7], 3) ^ t_use(r, c)[i]; \\\n\tk[v(56, (8 * (i)) + 8)] = ff(ss[0]); \\\n\tss[1] ^= ss[0]; k[v(56, (8 * (i)) + 9)] = ff(ss[1]); \\\n\tss[2] ^= ss[1]; k[v(56, (8 * (i)) + 10)] = ff(ss[2]); \\\n\tss[3] ^= ss[2]; k[v(56, (8 * (i)) + 11)] = ff(ss[3]); \\\n\tss[4] ^= ls_box(ss[3], 0); k[v(56, (8 * (i)) + 12)] = ff(ss[4]); \\\n\tss[5] ^= ss[4]; k[v(56, (8 * (i)) + 13)] = ff(ss[5]); \\\n\tss[6] ^= ss[5]; k[v(56, (8 * (i)) + 14)] = ff(ss[6]); \\\n\tss[7] ^= ss[6]; k[v(56, (8 * (i)) + 15)] = ff(ss[7]); \\\n}\n\n#define\tkd8(k, i) \\\n{\tss[8] = ls_box(ss[7], 3) ^ t_use(r, c)[i]; \\\n\tss[0] ^= ss[8]; \\\n\tss[8] = ff(ss[8]); \\\n\tk[v(56, (8 * (i)) + 8)] = ss[8] ^= k[v(56, (8 * (i)))]; \\\n\tss[1] ^= ss[0]; \\\n\tk[v(56, (8 * (i)) + 9)] = ss[8] ^= k[v(56, (8 * (i)) + 1)]; \\\n\tss[2] ^= ss[1]; \\\n\tk[v(56, (8 * (i)) + 10)] = ss[8] ^= k[v(56, (8 * (i)) + 2)]; \\\n\tss[3] ^= ss[2]; \\\n\tk[v(56, (8 * (i)) + 11)] = ss[8] ^= k[v(56, (8 * (i)) + 3)]; \\\n\tss[8] = ls_box(ss[3], 0); \\\n\tss[4] ^= ss[8]; \\\n\tss[8] = ff(ss[8]); \\\n\tk[v(56, (8 * (i)) + 12)] = ss[8] ^= k[v(56, (8 * (i)) + 4)]; \\\n\tss[5] ^= ss[4]; \\\n\tk[v(56, (8 * (i)) + 13)] = ss[8] ^= k[v(56, (8 * (i)) + 5)]; \\\n\tss[6] ^= ss[5]; \\\n\tk[v(56, (8 * (i)) + 14)] = ss[8] ^= k[v(56, (8 * (i)) + 6)]; \\\n\tss[7] ^= ss[6]; \\\n\tk[v(56, (8 * (i)) + 15)] = ss[8] ^= k[v(56, (8 * (i)) + 7)]; \\\n}\n\n#define\tkdl8(k, i) \\\n{\tss[0] ^= ls_box(ss[7], 3) ^ t_use(r, c)[i]; \\\n\tk[v(56, (8 * (i)) + 8)] = ss[0]; \\\n\tss[1] ^= ss[0]; k[v(56, (8 * (i)) + 9)] = ss[1]; \\\n\tss[2] ^= ss[1]; k[v(56, (8 * (i)) + 10)] = ss[2]; \\\n\tss[3] ^= ss[2]; k[v(56, (8 * (i)) + 11)] = ss[3]; \\\n}\n\nstatic void\naes_decrypt_key256(const unsigned char *key, uint32_t rk[])\n{\n\tuint32_t\tss[9];\n#if defined(d_vars)\n\td_vars;\n#endif\n\trk[v(56, (0))] = ss[0] = word_in(key, 0);\n\trk[v(56, (1))] = ss[1] = word_in(key, 1);\n\trk[v(56, (2))] = ss[2] = word_in(key, 2);\n\trk[v(56, (3))] = ss[3] = word_in(key, 3);\n\n#ifdef DEC_KS_UNROLL\n\tss[4] = word_in(key, 4);\n\trk[v(56, (4))] = ff(ss[4]);\n\tss[5] = word_in(key, 5);\n\trk[v(56, (5))] = ff(ss[5]);\n\tss[6] = word_in(key, 6);\n\trk[v(56, (6))] = ff(ss[6]);\n\tss[7] = word_in(key, 7);\n\trk[v(56, (7))] = ff(ss[7]);\n\tkdf8(rk, 0); kd8(rk, 1);\n\tkd8(rk, 2);  kd8(rk, 3);\n\tkd8(rk, 4);  kd8(rk, 5);\n\tkdl8(rk, 6);\n#else\n\trk[v(56, (4))] = ss[4] = word_in(key, 4);\n\trk[v(56, (5))] = ss[5] = word_in(key, 5);\n\trk[v(56, (6))] = ss[6] = word_in(key, 6);\n\trk[v(56, (7))] = ss[7] = word_in(key, 7);\n\t{\n\t\tuint32_t\ti;\n\n\t\tfor (i = 0; i < 6; ++i)\n\t\t\tk8e(rk,  i);\n\t\tk8ef(rk,  6);\n#if !(DEC_ROUND == NO_TABLES)\n\t\tfor (i = MAX_AES_NB; i < 14 * MAX_AES_NB; ++i)\n\t\t\trk[i] = inv_mcol(rk[i]);\n#endif\n\t}\n#endif\t \n}\n\n\n \nint\nrijndael_key_setup_dec_amd64(uint32_t rk[], const uint32_t cipherKey[],\n    int keyBits)\n{\n\tswitch (keyBits) {\n\tcase 128:\n\t\taes_decrypt_key128((unsigned char *)&cipherKey[0], rk);\n\t\treturn (10);\n\tcase 192:\n\t\taes_decrypt_key192((unsigned char *)&cipherKey[0], rk);\n\t\treturn (12);\n\tcase 256:\n\t\taes_decrypt_key256((unsigned char *)&cipherKey[0], rk);\n\t\treturn (14);\n\tdefault:  \n\t\tbreak;\n\t}\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}