{
  "module_name": "aes.c",
  "hash_id": "8260830b69d386287fca6e82876093739d488dffb57a2e0a017736463584854e",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/io/aes.c",
  "human_readable_source": " \n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n#include <sys/crypto/spi.h>\n#include <sys/crypto/icp.h>\n#include <modes/modes.h>\n#define\t_AES_IMPL\n#include <aes/aes_impl.h>\n#include <modes/gcm_impl.h>\n\n \nstatic const crypto_mech_info_t aes_mech_info_tab[] = {\n\t \n\t{SUN_CKM_AES_ECB, AES_ECB_MECH_INFO_TYPE,\n\t    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |\n\t    CRYPTO_FG_DECRYPT | CRYPTO_FG_DECRYPT_ATOMIC},\n\t \n\t{SUN_CKM_AES_CBC, AES_CBC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |\n\t    CRYPTO_FG_DECRYPT | CRYPTO_FG_DECRYPT_ATOMIC},\n\t \n\t{SUN_CKM_AES_CTR, AES_CTR_MECH_INFO_TYPE,\n\t    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |\n\t    CRYPTO_FG_DECRYPT | CRYPTO_FG_DECRYPT_ATOMIC},\n\t \n\t{SUN_CKM_AES_CCM, AES_CCM_MECH_INFO_TYPE,\n\t    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |\n\t    CRYPTO_FG_DECRYPT | CRYPTO_FG_DECRYPT_ATOMIC},\n\t \n\t{SUN_CKM_AES_GCM, AES_GCM_MECH_INFO_TYPE,\n\t    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |\n\t    CRYPTO_FG_DECRYPT | CRYPTO_FG_DECRYPT_ATOMIC},\n\t \n\t{SUN_CKM_AES_GMAC, AES_GMAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |\n\t    CRYPTO_FG_DECRYPT | CRYPTO_FG_DECRYPT_ATOMIC |\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n};\n\nstatic int aes_encrypt_init(crypto_ctx_t *, crypto_mechanism_t *,\n    crypto_key_t *, crypto_spi_ctx_template_t);\nstatic int aes_decrypt_init(crypto_ctx_t *, crypto_mechanism_t *,\n    crypto_key_t *, crypto_spi_ctx_template_t);\nstatic int aes_common_init(crypto_ctx_t *, crypto_mechanism_t *,\n    crypto_key_t *, crypto_spi_ctx_template_t, boolean_t);\nstatic int aes_common_init_ctx(aes_ctx_t *, crypto_spi_ctx_template_t *,\n    crypto_mechanism_t *, crypto_key_t *, int, boolean_t);\nstatic int aes_encrypt_final(crypto_ctx_t *, crypto_data_t *);\nstatic int aes_decrypt_final(crypto_ctx_t *, crypto_data_t *);\n\nstatic int aes_encrypt(crypto_ctx_t *, crypto_data_t *, crypto_data_t *);\nstatic int aes_encrypt_update(crypto_ctx_t *, crypto_data_t *,\n    crypto_data_t *);\nstatic int aes_encrypt_atomic(crypto_mechanism_t *, crypto_key_t *,\n    crypto_data_t *, crypto_data_t *, crypto_spi_ctx_template_t);\n\nstatic int aes_decrypt(crypto_ctx_t *, crypto_data_t *, crypto_data_t *);\nstatic int aes_decrypt_update(crypto_ctx_t *, crypto_data_t *,\n    crypto_data_t *);\nstatic int aes_decrypt_atomic(crypto_mechanism_t *, crypto_key_t *,\n    crypto_data_t *, crypto_data_t *, crypto_spi_ctx_template_t);\n\nstatic const crypto_cipher_ops_t aes_cipher_ops = {\n\t.encrypt_init = aes_encrypt_init,\n\t.encrypt = aes_encrypt,\n\t.encrypt_update = aes_encrypt_update,\n\t.encrypt_final = aes_encrypt_final,\n\t.encrypt_atomic = aes_encrypt_atomic,\n\t.decrypt_init = aes_decrypt_init,\n\t.decrypt = aes_decrypt,\n\t.decrypt_update = aes_decrypt_update,\n\t.decrypt_final = aes_decrypt_final,\n\t.decrypt_atomic = aes_decrypt_atomic\n};\n\nstatic int aes_mac_atomic(crypto_mechanism_t *, crypto_key_t *, crypto_data_t *,\n    crypto_data_t *, crypto_spi_ctx_template_t);\nstatic int aes_mac_verify_atomic(crypto_mechanism_t *, crypto_key_t *,\n    crypto_data_t *, crypto_data_t *, crypto_spi_ctx_template_t);\n\nstatic const crypto_mac_ops_t aes_mac_ops = {\n\t.mac_init = NULL,\n\t.mac = NULL,\n\t.mac_update = NULL,\n\t.mac_final = NULL,\n\t.mac_atomic = aes_mac_atomic,\n\t.mac_verify_atomic = aes_mac_verify_atomic\n};\n\nstatic int aes_create_ctx_template(crypto_mechanism_t *, crypto_key_t *,\n    crypto_spi_ctx_template_t *, size_t *);\nstatic int aes_free_context(crypto_ctx_t *);\n\nstatic const crypto_ctx_ops_t aes_ctx_ops = {\n\t.create_ctx_template = aes_create_ctx_template,\n\t.free_context = aes_free_context\n};\n\nstatic const crypto_ops_t aes_crypto_ops = {\n\tNULL,\n\t&aes_cipher_ops,\n\t&aes_mac_ops,\n\t&aes_ctx_ops,\n};\n\nstatic const crypto_provider_info_t aes_prov_info = {\n\t\"AES Software Provider\",\n\t&aes_crypto_ops,\n\tsizeof (aes_mech_info_tab) / sizeof (crypto_mech_info_t),\n\taes_mech_info_tab\n};\n\nstatic crypto_kcf_provider_handle_t aes_prov_handle = 0;\nstatic crypto_data_t null_crypto_data = { CRYPTO_DATA_RAW };\n\nint\naes_mod_init(void)\n{\n\t \n\taes_impl_init();\n\tgcm_impl_init();\n\n\t \n\tif (crypto_register_provider(&aes_prov_info, &aes_prov_handle))\n\t\treturn (EACCES);\n\n\treturn (0);\n}\n\nint\naes_mod_fini(void)\n{\n\t \n\tif (aes_prov_handle != 0) {\n\t\tif (crypto_unregister_provider(aes_prov_handle))\n\t\t\treturn (EBUSY);\n\n\t\taes_prov_handle = 0;\n\t}\n\n\treturn (0);\n}\n\nstatic int\naes_check_mech_param(crypto_mechanism_t *mechanism, aes_ctx_t **ctx)\n{\n\tvoid *p = NULL;\n\tboolean_t param_required = B_TRUE;\n\tsize_t param_len;\n\tvoid *(*alloc_fun)(int);\n\tint rv = CRYPTO_SUCCESS;\n\n\tswitch (mechanism->cm_type) {\n\tcase AES_ECB_MECH_INFO_TYPE:\n\t\tparam_required = B_FALSE;\n\t\talloc_fun = ecb_alloc_ctx;\n\t\tbreak;\n\tcase AES_CBC_MECH_INFO_TYPE:\n\t\tparam_len = AES_BLOCK_LEN;\n\t\talloc_fun = cbc_alloc_ctx;\n\t\tbreak;\n\tcase AES_CTR_MECH_INFO_TYPE:\n\t\tparam_len = sizeof (CK_AES_CTR_PARAMS);\n\t\talloc_fun = ctr_alloc_ctx;\n\t\tbreak;\n\tcase AES_CCM_MECH_INFO_TYPE:\n\t\tparam_len = sizeof (CK_AES_CCM_PARAMS);\n\t\talloc_fun = ccm_alloc_ctx;\n\t\tbreak;\n\tcase AES_GCM_MECH_INFO_TYPE:\n\t\tparam_len = sizeof (CK_AES_GCM_PARAMS);\n\t\talloc_fun = gcm_alloc_ctx;\n\t\tbreak;\n\tcase AES_GMAC_MECH_INFO_TYPE:\n\t\tparam_len = sizeof (CK_AES_GMAC_PARAMS);\n\t\talloc_fun = gmac_alloc_ctx;\n\t\tbreak;\n\tdefault:\n\t\trv = CRYPTO_MECHANISM_INVALID;\n\t\treturn (rv);\n\t}\n\tif (param_required && mechanism->cm_param != NULL &&\n\t    mechanism->cm_param_len != param_len) {\n\t\trv = CRYPTO_MECHANISM_PARAM_INVALID;\n\t}\n\tif (ctx != NULL) {\n\t\tp = (alloc_fun)(KM_SLEEP);\n\t\t*ctx = p;\n\t}\n\treturn (rv);\n}\n\n \nstatic int\ninit_keysched(crypto_key_t *key, void *newbie)\n{\n\tif (key->ck_length < AES_MINBITS ||\n\t    key->ck_length > AES_MAXBITS) {\n\t\treturn (CRYPTO_KEY_SIZE_RANGE);\n\t}\n\n\t \n\tif ((key->ck_length & 63) != 0)\n\t\treturn (CRYPTO_KEY_SIZE_RANGE);\n\n\taes_init_keysched(key->ck_data, key->ck_length, newbie);\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\naes_encrypt_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_spi_ctx_template_t template)\n{\n\treturn (aes_common_init(ctx, mechanism, key, template, B_TRUE));\n}\n\nstatic int\naes_decrypt_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_spi_ctx_template_t template)\n{\n\treturn (aes_common_init(ctx, mechanism, key, template, B_FALSE));\n}\n\n\n\n \nstatic int\naes_common_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_spi_ctx_template_t template,\n    boolean_t is_encrypt_init)\n{\n\taes_ctx_t *aes_ctx;\n\tint rv;\n\n\tif ((rv = aes_check_mech_param(mechanism, &aes_ctx))\n\t    != CRYPTO_SUCCESS)\n\t\treturn (rv);\n\n\trv = aes_common_init_ctx(aes_ctx, template, mechanism, key, KM_SLEEP,\n\t    is_encrypt_init);\n\tif (rv != CRYPTO_SUCCESS) {\n\t\tcrypto_free_mode_ctx(aes_ctx);\n\t\treturn (rv);\n\t}\n\n\tctx->cc_provider_private = aes_ctx;\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic void\naes_copy_block64(uint8_t *in, uint64_t *out)\n{\n\tif (IS_P2ALIGNED(in, sizeof (uint64_t))) {\n\t\t \n\t\tout[0] = *(uint64_t *)&in[0];\n\t\t \n\t\tout[1] = *(uint64_t *)&in[8];\n\t} else {\n\t\tuint8_t *iv8 = (uint8_t *)&out[0];\n\n\t\tAES_COPY_BLOCK(in, iv8);\n\t}\n}\n\n\nstatic int\naes_encrypt(crypto_ctx_t *ctx, crypto_data_t *plaintext,\n    crypto_data_t *ciphertext)\n{\n\tint ret = CRYPTO_FAILED;\n\n\taes_ctx_t *aes_ctx;\n\tsize_t saved_length, saved_offset, length_needed;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\taes_ctx = ctx->cc_provider_private;\n\n\t \n\tif (((aes_ctx->ac_flags & (CTR_MODE|CCM_MODE|GCM_MODE|GMAC_MODE))\n\t    == 0) && (plaintext->cd_length & (AES_BLOCK_LEN - 1)) != 0)\n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\n\tASSERT(ciphertext != NULL);\n\n\t \n\tswitch (aes_ctx->ac_flags & (CCM_MODE|GCM_MODE|GMAC_MODE)) {\n\tcase CCM_MODE:\n\t\tlength_needed = plaintext->cd_length + aes_ctx->ac_mac_len;\n\t\tbreak;\n\tcase GCM_MODE:\n\t\tlength_needed = plaintext->cd_length + aes_ctx->ac_tag_len;\n\t\tbreak;\n\tcase GMAC_MODE:\n\t\tif (plaintext->cd_length != 0)\n\t\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t\tlength_needed = aes_ctx->ac_tag_len;\n\t\tbreak;\n\tdefault:\n\t\tlength_needed = plaintext->cd_length;\n\t}\n\n\tif (ciphertext->cd_length < length_needed) {\n\t\tciphertext->cd_length = length_needed;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\tsaved_length = ciphertext->cd_length;\n\tsaved_offset = ciphertext->cd_offset;\n\n\t \n\tret = aes_encrypt_update(ctx, plaintext, ciphertext);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\treturn (ret);\n\t}\n\n\t \n\tif (aes_ctx->ac_flags & CCM_MODE) {\n\t\t \n\n\t\t \n\t\tciphertext->cd_offset = ciphertext->cd_length;\n\t\tciphertext->cd_length = saved_length - ciphertext->cd_length;\n\t\tret = ccm_encrypt_final((ccm_ctx_t *)aes_ctx, ciphertext,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\treturn (ret);\n\t\t}\n\n\t\tif (plaintext != ciphertext) {\n\t\t\tciphertext->cd_length =\n\t\t\t    ciphertext->cd_offset - saved_offset;\n\t\t}\n\t\tciphertext->cd_offset = saved_offset;\n\t} else if (aes_ctx->ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\t \n\n\t\t \n\t\tciphertext->cd_offset = ciphertext->cd_length;\n\t\tciphertext->cd_length = saved_length - ciphertext->cd_length;\n\t\tret = gcm_encrypt_final((gcm_ctx_t *)aes_ctx, ciphertext,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\treturn (ret);\n\t\t}\n\n\t\tif (plaintext != ciphertext) {\n\t\t\tciphertext->cd_length =\n\t\t\t    ciphertext->cd_offset - saved_offset;\n\t\t}\n\t\tciphertext->cd_offset = saved_offset;\n\t}\n\n\tASSERT(aes_ctx->ac_remainder_len == 0);\n\t(void) aes_free_context(ctx);\n\n\treturn (ret);\n}\n\n\nstatic int\naes_decrypt(crypto_ctx_t *ctx, crypto_data_t *ciphertext,\n    crypto_data_t *plaintext)\n{\n\tint ret = CRYPTO_FAILED;\n\n\taes_ctx_t *aes_ctx;\n\toff_t saved_offset;\n\tsize_t saved_length, length_needed;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\taes_ctx = ctx->cc_provider_private;\n\n\t \n\tif (((aes_ctx->ac_flags & (CTR_MODE|CCM_MODE|GCM_MODE|GMAC_MODE))\n\t    == 0) && (ciphertext->cd_length & (AES_BLOCK_LEN - 1)) != 0) {\n\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\t}\n\n\tASSERT(plaintext != NULL);\n\n\t \n\tswitch (aes_ctx->ac_flags & (CCM_MODE|GCM_MODE|GMAC_MODE)) {\n\tcase CCM_MODE:\n\t\tlength_needed = aes_ctx->ac_processed_data_len;\n\t\tbreak;\n\tcase GCM_MODE:\n\t\tlength_needed = ciphertext->cd_length - aes_ctx->ac_tag_len;\n\t\tbreak;\n\tcase GMAC_MODE:\n\t\tif (plaintext->cd_length != 0)\n\t\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t\tlength_needed = 0;\n\t\tbreak;\n\tdefault:\n\t\tlength_needed = ciphertext->cd_length;\n\t}\n\n\tif (plaintext->cd_length < length_needed) {\n\t\tplaintext->cd_length = length_needed;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\tsaved_offset = plaintext->cd_offset;\n\tsaved_length = plaintext->cd_length;\n\n\t \n\tret = aes_decrypt_update(ctx, ciphertext, plaintext);\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\tif (aes_ctx->ac_flags & CCM_MODE) {\n\t\tASSERT(aes_ctx->ac_processed_data_len == aes_ctx->ac_data_len);\n\t\tASSERT(aes_ctx->ac_processed_mac_len == aes_ctx->ac_mac_len);\n\n\t\t \n\t\tplaintext->cd_offset = plaintext->cd_length;\n\t\tplaintext->cd_length = saved_length - plaintext->cd_length;\n\n\t\tret = ccm_decrypt_final((ccm_ctx_t *)aes_ctx, plaintext,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t\tif (ret == CRYPTO_SUCCESS) {\n\t\t\tif (plaintext != ciphertext) {\n\t\t\t\tplaintext->cd_length =\n\t\t\t\t    plaintext->cd_offset - saved_offset;\n\t\t\t}\n\t\t} else {\n\t\t\tplaintext->cd_length = saved_length;\n\t\t}\n\n\t\tplaintext->cd_offset = saved_offset;\n\t} else if (aes_ctx->ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\t \n\t\tplaintext->cd_offset = plaintext->cd_length;\n\t\tplaintext->cd_length = saved_length - plaintext->cd_length;\n\n\t\tret = gcm_decrypt_final((gcm_ctx_t *)aes_ctx, plaintext,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);\n\t\tif (ret == CRYPTO_SUCCESS) {\n\t\t\tif (plaintext != ciphertext) {\n\t\t\t\tplaintext->cd_length =\n\t\t\t\t    plaintext->cd_offset - saved_offset;\n\t\t\t}\n\t\t} else {\n\t\t\tplaintext->cd_length = saved_length;\n\t\t}\n\n\t\tplaintext->cd_offset = saved_offset;\n\t}\n\n\tASSERT(aes_ctx->ac_remainder_len == 0);\n\ncleanup:\n\t(void) aes_free_context(ctx);\n\n\treturn (ret);\n}\n\n\nstatic int\naes_encrypt_update(crypto_ctx_t *ctx, crypto_data_t *plaintext,\n    crypto_data_t *ciphertext)\n{\n\toff_t saved_offset;\n\tsize_t saved_length, out_len;\n\tint ret = CRYPTO_SUCCESS;\n\taes_ctx_t *aes_ctx;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\taes_ctx = ctx->cc_provider_private;\n\n\tASSERT(ciphertext != NULL);\n\n\t \n\tout_len = aes_ctx->ac_remainder_len;\n\tout_len += plaintext->cd_length;\n\tout_len &= ~(AES_BLOCK_LEN - 1);\n\n\t \n\tif (ciphertext->cd_length < out_len) {\n\t\tciphertext->cd_length = out_len;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\tsaved_offset = ciphertext->cd_offset;\n\tsaved_length = ciphertext->cd_length;\n\n\t \n\tswitch (plaintext->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tret = crypto_update_iov(ctx->cc_provider_private,\n\t\t    plaintext, ciphertext, aes_encrypt_contiguous_blocks);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = crypto_update_uio(ctx->cc_provider_private,\n\t\t    plaintext, ciphertext, aes_encrypt_contiguous_blocks);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\t \n\tif ((aes_ctx->ac_flags & CTR_MODE) && (aes_ctx->ac_remainder_len > 0)) {\n\t\tret = ctr_mode_final((ctr_ctx_t *)aes_ctx,\n\t\t    ciphertext, aes_encrypt_block);\n\t}\n\n\tif (ret == CRYPTO_SUCCESS) {\n\t\tif (plaintext != ciphertext)\n\t\t\tciphertext->cd_length =\n\t\t\t    ciphertext->cd_offset - saved_offset;\n\t} else {\n\t\tciphertext->cd_length = saved_length;\n\t}\n\tciphertext->cd_offset = saved_offset;\n\n\treturn (ret);\n}\n\n\nstatic int\naes_decrypt_update(crypto_ctx_t *ctx, crypto_data_t *ciphertext,\n    crypto_data_t *plaintext)\n{\n\toff_t saved_offset;\n\tsize_t saved_length, out_len;\n\tint ret = CRYPTO_SUCCESS;\n\taes_ctx_t *aes_ctx;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\taes_ctx = ctx->cc_provider_private;\n\n\tASSERT(plaintext != NULL);\n\n\t \n\tif ((aes_ctx->ac_flags & (CCM_MODE|GCM_MODE|GMAC_MODE)) == 0) {\n\t\tout_len = aes_ctx->ac_remainder_len;\n\t\tout_len += ciphertext->cd_length;\n\t\tout_len &= ~(AES_BLOCK_LEN - 1);\n\n\t\t \n\t\tif (plaintext->cd_length < out_len) {\n\t\t\tplaintext->cd_length = out_len;\n\t\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t\t}\n\t}\n\n\tsaved_offset = plaintext->cd_offset;\n\tsaved_length = plaintext->cd_length;\n\n\t \n\tswitch (ciphertext->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tret = crypto_update_iov(ctx->cc_provider_private,\n\t\t    ciphertext, plaintext, aes_decrypt_contiguous_blocks);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = crypto_update_uio(ctx->cc_provider_private,\n\t\t    ciphertext, plaintext, aes_decrypt_contiguous_blocks);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\t \n\tif ((aes_ctx->ac_flags & CTR_MODE) && (aes_ctx->ac_remainder_len > 0)) {\n\t\tret = ctr_mode_final((ctr_ctx_t *)aes_ctx, plaintext,\n\t\t    aes_encrypt_block);\n\t\tif (ret == CRYPTO_DATA_LEN_RANGE)\n\t\t\tret = CRYPTO_ENCRYPTED_DATA_LEN_RANGE;\n\t}\n\n\tif (ret == CRYPTO_SUCCESS) {\n\t\tif (ciphertext != plaintext)\n\t\t\tplaintext->cd_length =\n\t\t\t    plaintext->cd_offset - saved_offset;\n\t} else {\n\t\tplaintext->cd_length = saved_length;\n\t}\n\tplaintext->cd_offset = saved_offset;\n\n\n\treturn (ret);\n}\n\nstatic int\naes_encrypt_final(crypto_ctx_t *ctx, crypto_data_t *data)\n{\n\taes_ctx_t *aes_ctx;\n\tint ret;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\taes_ctx = ctx->cc_provider_private;\n\n\tif (data->cd_format != CRYPTO_DATA_RAW &&\n\t    data->cd_format != CRYPTO_DATA_UIO) {\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t}\n\n\tif (aes_ctx->ac_flags & CTR_MODE) {\n\t\tif (aes_ctx->ac_remainder_len > 0) {\n\t\t\tret = ctr_mode_final((ctr_ctx_t *)aes_ctx, data,\n\t\t\t    aes_encrypt_block);\n\t\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\t\treturn (ret);\n\t\t}\n\t} else if (aes_ctx->ac_flags & CCM_MODE) {\n\t\tret = ccm_encrypt_final((ccm_ctx_t *)aes_ctx, data,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\treturn (ret);\n\t\t}\n\t} else if (aes_ctx->ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\tsize_t saved_offset = data->cd_offset;\n\n\t\tret = gcm_encrypt_final((gcm_ctx_t *)aes_ctx, data,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\treturn (ret);\n\t\t}\n\t\tdata->cd_length = data->cd_offset - saved_offset;\n\t\tdata->cd_offset = saved_offset;\n\t} else {\n\t\t \n\t\tif (aes_ctx->ac_remainder_len > 0) {\n\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t\t}\n\t\tdata->cd_length = 0;\n\t}\n\n\t(void) aes_free_context(ctx);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\naes_decrypt_final(crypto_ctx_t *ctx, crypto_data_t *data)\n{\n\taes_ctx_t *aes_ctx;\n\tint ret;\n\toff_t saved_offset;\n\tsize_t saved_length;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\taes_ctx = ctx->cc_provider_private;\n\n\tif (data->cd_format != CRYPTO_DATA_RAW &&\n\t    data->cd_format != CRYPTO_DATA_UIO) {\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t}\n\n\t \n\tif (aes_ctx->ac_remainder_len > 0) {\n\t\tif ((aes_ctx->ac_flags & CTR_MODE) == 0)\n\t\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\t\telse {\n\t\t\tret = ctr_mode_final((ctr_ctx_t *)aes_ctx, data,\n\t\t\t    aes_encrypt_block);\n\t\t\tif (ret == CRYPTO_DATA_LEN_RANGE)\n\t\t\t\tret = CRYPTO_ENCRYPTED_DATA_LEN_RANGE;\n\t\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\t\treturn (ret);\n\t\t}\n\t}\n\n\tif (aes_ctx->ac_flags & CCM_MODE) {\n\t\t \n\t\tsize_t pt_len = aes_ctx->ac_data_len;\n\t\tif (data->cd_length < pt_len) {\n\t\t\tdata->cd_length = pt_len;\n\t\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t\t}\n\n\t\tASSERT(aes_ctx->ac_processed_data_len == pt_len);\n\t\tASSERT(aes_ctx->ac_processed_mac_len == aes_ctx->ac_mac_len);\n\t\tsaved_offset = data->cd_offset;\n\t\tsaved_length = data->cd_length;\n\t\tret = ccm_decrypt_final((ccm_ctx_t *)aes_ctx, data,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t\tif (ret == CRYPTO_SUCCESS) {\n\t\t\tdata->cd_length = data->cd_offset - saved_offset;\n\t\t} else {\n\t\t\tdata->cd_length = saved_length;\n\t\t}\n\n\t\tdata->cd_offset = saved_offset;\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\treturn (ret);\n\t\t}\n\t} else if (aes_ctx->ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\t \n\t\tgcm_ctx_t *ctx = (gcm_ctx_t *)aes_ctx;\n\t\tsize_t pt_len = ctx->gcm_processed_data_len - ctx->gcm_tag_len;\n\n\t\tif (data->cd_length < pt_len) {\n\t\t\tdata->cd_length = pt_len;\n\t\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t\t}\n\n\t\tsaved_offset = data->cd_offset;\n\t\tsaved_length = data->cd_length;\n\t\tret = gcm_decrypt_final((gcm_ctx_t *)aes_ctx, data,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_xor_block);\n\t\tif (ret == CRYPTO_SUCCESS) {\n\t\t\tdata->cd_length = data->cd_offset - saved_offset;\n\t\t} else {\n\t\t\tdata->cd_length = saved_length;\n\t\t}\n\n\t\tdata->cd_offset = saved_offset;\n\t\tif (ret != CRYPTO_SUCCESS) {\n\t\t\treturn (ret);\n\t\t}\n\t}\n\n\n\tif ((aes_ctx->ac_flags & (CTR_MODE|CCM_MODE|GCM_MODE|GMAC_MODE)) == 0) {\n\t\tdata->cd_length = 0;\n\t}\n\n\t(void) aes_free_context(ctx);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\naes_encrypt_atomic(crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_data_t *plaintext, crypto_data_t *ciphertext,\n    crypto_spi_ctx_template_t template)\n{\n\taes_ctx_t aes_ctx = {{{{0}}}};\n\toff_t saved_offset;\n\tsize_t saved_length;\n\tsize_t length_needed;\n\tint ret;\n\n\tASSERT(ciphertext != NULL);\n\n\t \n\tswitch (mechanism->cm_type) {\n\tcase AES_CTR_MECH_INFO_TYPE:\n\tcase AES_CCM_MECH_INFO_TYPE:\n\tcase AES_GCM_MECH_INFO_TYPE:\n\tcase AES_GMAC_MECH_INFO_TYPE:\n\t\tbreak;\n\tdefault:\n\t\tif ((plaintext->cd_length & (AES_BLOCK_LEN - 1)) != 0)\n\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\tif ((ret = aes_check_mech_param(mechanism, NULL)) != CRYPTO_SUCCESS)\n\t\treturn (ret);\n\n\tret = aes_common_init_ctx(&aes_ctx, template, mechanism, key,\n\t    KM_SLEEP, B_TRUE);\n\tif (ret != CRYPTO_SUCCESS)\n\t\treturn (ret);\n\n\tswitch (mechanism->cm_type) {\n\tcase AES_CCM_MECH_INFO_TYPE:\n\t\tlength_needed = plaintext->cd_length + aes_ctx.ac_mac_len;\n\t\tbreak;\n\tcase AES_GMAC_MECH_INFO_TYPE:\n\t\tif (plaintext->cd_length != 0)\n\t\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t\tzfs_fallthrough;\n\tcase AES_GCM_MECH_INFO_TYPE:\n\t\tlength_needed = plaintext->cd_length + aes_ctx.ac_tag_len;\n\t\tbreak;\n\tdefault:\n\t\tlength_needed = plaintext->cd_length;\n\t}\n\n\t \n\tif (ciphertext->cd_length < length_needed) {\n\t\tciphertext->cd_length = length_needed;\n\t\tret = CRYPTO_BUFFER_TOO_SMALL;\n\t\tgoto out;\n\t}\n\n\tsaved_offset = ciphertext->cd_offset;\n\tsaved_length = ciphertext->cd_length;\n\n\t \n\tswitch (plaintext->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tret = crypto_update_iov(&aes_ctx, plaintext, ciphertext,\n\t\t    aes_encrypt_contiguous_blocks);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = crypto_update_uio(&aes_ctx, plaintext, ciphertext,\n\t\t    aes_encrypt_contiguous_blocks);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (ret == CRYPTO_SUCCESS) {\n\t\tif (mechanism->cm_type == AES_CCM_MECH_INFO_TYPE) {\n\t\t\tret = ccm_encrypt_final((ccm_ctx_t *)&aes_ctx,\n\t\t\t    ciphertext, AES_BLOCK_LEN, aes_encrypt_block,\n\t\t\t    aes_xor_block);\n\t\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\t\tgoto out;\n\t\t\tASSERT(aes_ctx.ac_remainder_len == 0);\n\t\t} else if (mechanism->cm_type == AES_GCM_MECH_INFO_TYPE ||\n\t\t    mechanism->cm_type == AES_GMAC_MECH_INFO_TYPE) {\n\t\t\tret = gcm_encrypt_final((gcm_ctx_t *)&aes_ctx,\n\t\t\t    ciphertext, AES_BLOCK_LEN, aes_encrypt_block,\n\t\t\t    aes_copy_block, aes_xor_block);\n\t\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\t\tgoto out;\n\t\t\tASSERT(aes_ctx.ac_remainder_len == 0);\n\t\t} else if (mechanism->cm_type == AES_CTR_MECH_INFO_TYPE) {\n\t\t\tif (aes_ctx.ac_remainder_len > 0) {\n\t\t\t\tret = ctr_mode_final((ctr_ctx_t *)&aes_ctx,\n\t\t\t\t    ciphertext, aes_encrypt_block);\n\t\t\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(aes_ctx.ac_remainder_len == 0);\n\t\t}\n\n\t\tif (plaintext != ciphertext) {\n\t\t\tciphertext->cd_length =\n\t\t\t    ciphertext->cd_offset - saved_offset;\n\t\t}\n\t} else {\n\t\tciphertext->cd_length = saved_length;\n\t}\n\tciphertext->cd_offset = saved_offset;\n\nout:\n\tif (aes_ctx.ac_flags & PROVIDER_OWNS_KEY_SCHEDULE) {\n\t\tmemset(aes_ctx.ac_keysched, 0, aes_ctx.ac_keysched_len);\n\t\tkmem_free(aes_ctx.ac_keysched, aes_ctx.ac_keysched_len);\n\t}\n\tif (aes_ctx.ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\tgcm_clear_ctx((gcm_ctx_t *)&aes_ctx);\n\t}\n\treturn (ret);\n}\n\nstatic int\naes_decrypt_atomic(crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_data_t *ciphertext, crypto_data_t *plaintext,\n    crypto_spi_ctx_template_t template)\n{\n\taes_ctx_t aes_ctx = {{{{0}}}};\n\toff_t saved_offset;\n\tsize_t saved_length;\n\tsize_t length_needed;\n\tint ret;\n\n\tASSERT(plaintext != NULL);\n\n\t \n\tswitch (mechanism->cm_type) {\n\tcase AES_CTR_MECH_INFO_TYPE:\n\tcase AES_CCM_MECH_INFO_TYPE:\n\tcase AES_GCM_MECH_INFO_TYPE:\n\tcase AES_GMAC_MECH_INFO_TYPE:\n\t\tbreak;\n\tdefault:\n\t\tif ((ciphertext->cd_length & (AES_BLOCK_LEN - 1)) != 0)\n\t\t\treturn (CRYPTO_ENCRYPTED_DATA_LEN_RANGE);\n\t}\n\n\tif ((ret = aes_check_mech_param(mechanism, NULL)) != CRYPTO_SUCCESS)\n\t\treturn (ret);\n\n\tret = aes_common_init_ctx(&aes_ctx, template, mechanism, key,\n\t    KM_SLEEP, B_FALSE);\n\tif (ret != CRYPTO_SUCCESS)\n\t\treturn (ret);\n\n\tswitch (mechanism->cm_type) {\n\tcase AES_CCM_MECH_INFO_TYPE:\n\t\tlength_needed = aes_ctx.ac_data_len;\n\t\tbreak;\n\tcase AES_GCM_MECH_INFO_TYPE:\n\t\tlength_needed = ciphertext->cd_length - aes_ctx.ac_tag_len;\n\t\tbreak;\n\tcase AES_GMAC_MECH_INFO_TYPE:\n\t\tif (plaintext->cd_length != 0)\n\t\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t\tlength_needed = 0;\n\t\tbreak;\n\tdefault:\n\t\tlength_needed = ciphertext->cd_length;\n\t}\n\n\t \n\tif (plaintext->cd_length < length_needed) {\n\t\tplaintext->cd_length = length_needed;\n\t\tret = CRYPTO_BUFFER_TOO_SMALL;\n\t\tgoto out;\n\t}\n\n\tsaved_offset = plaintext->cd_offset;\n\tsaved_length = plaintext->cd_length;\n\n\t \n\tswitch (ciphertext->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tret = crypto_update_iov(&aes_ctx, ciphertext, plaintext,\n\t\t    aes_decrypt_contiguous_blocks);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = crypto_update_uio(&aes_ctx, ciphertext, plaintext,\n\t\t    aes_decrypt_contiguous_blocks);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (ret == CRYPTO_SUCCESS) {\n\t\tif (mechanism->cm_type == AES_CCM_MECH_INFO_TYPE) {\n\t\t\tASSERT(aes_ctx.ac_processed_data_len\n\t\t\t    == aes_ctx.ac_data_len);\n\t\t\tASSERT(aes_ctx.ac_processed_mac_len\n\t\t\t    == aes_ctx.ac_mac_len);\n\t\t\tret = ccm_decrypt_final((ccm_ctx_t *)&aes_ctx,\n\t\t\t    plaintext, AES_BLOCK_LEN, aes_encrypt_block,\n\t\t\t    aes_copy_block, aes_xor_block);\n\t\t\tASSERT(aes_ctx.ac_remainder_len == 0);\n\t\t\tif ((ret == CRYPTO_SUCCESS) &&\n\t\t\t    (ciphertext != plaintext)) {\n\t\t\t\tplaintext->cd_length =\n\t\t\t\t    plaintext->cd_offset - saved_offset;\n\t\t\t} else {\n\t\t\t\tplaintext->cd_length = saved_length;\n\t\t\t}\n\t\t} else if (mechanism->cm_type == AES_GCM_MECH_INFO_TYPE ||\n\t\t    mechanism->cm_type == AES_GMAC_MECH_INFO_TYPE) {\n\t\t\tret = gcm_decrypt_final((gcm_ctx_t *)&aes_ctx,\n\t\t\t    plaintext, AES_BLOCK_LEN, aes_encrypt_block,\n\t\t\t    aes_xor_block);\n\t\t\tASSERT(aes_ctx.ac_remainder_len == 0);\n\t\t\tif ((ret == CRYPTO_SUCCESS) &&\n\t\t\t    (ciphertext != plaintext)) {\n\t\t\t\tplaintext->cd_length =\n\t\t\t\t    plaintext->cd_offset - saved_offset;\n\t\t\t} else {\n\t\t\t\tplaintext->cd_length = saved_length;\n\t\t\t}\n\t\t} else if (mechanism->cm_type != AES_CTR_MECH_INFO_TYPE) {\n\t\t\tASSERT(aes_ctx.ac_remainder_len == 0);\n\t\t\tif (ciphertext != plaintext)\n\t\t\t\tplaintext->cd_length =\n\t\t\t\t    plaintext->cd_offset - saved_offset;\n\t\t} else {\n\t\t\tif (aes_ctx.ac_remainder_len > 0) {\n\t\t\t\tret = ctr_mode_final((ctr_ctx_t *)&aes_ctx,\n\t\t\t\t    plaintext, aes_encrypt_block);\n\t\t\t\tif (ret == CRYPTO_DATA_LEN_RANGE)\n\t\t\t\t\tret = CRYPTO_ENCRYPTED_DATA_LEN_RANGE;\n\t\t\t\tif (ret != CRYPTO_SUCCESS)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ciphertext != plaintext)\n\t\t\t\tplaintext->cd_length =\n\t\t\t\t    plaintext->cd_offset - saved_offset;\n\t\t}\n\t} else {\n\t\tplaintext->cd_length = saved_length;\n\t}\n\tplaintext->cd_offset = saved_offset;\n\nout:\n\tif (aes_ctx.ac_flags & PROVIDER_OWNS_KEY_SCHEDULE) {\n\t\tmemset(aes_ctx.ac_keysched, 0, aes_ctx.ac_keysched_len);\n\t\tkmem_free(aes_ctx.ac_keysched, aes_ctx.ac_keysched_len);\n\t}\n\n\tif (aes_ctx.ac_flags & CCM_MODE) {\n\t\tif (aes_ctx.ac_pt_buf != NULL) {\n\t\t\tvmem_free(aes_ctx.ac_pt_buf, aes_ctx.ac_data_len);\n\t\t}\n\t} else if (aes_ctx.ac_flags & (GCM_MODE|GMAC_MODE)) {\n\t\tgcm_clear_ctx((gcm_ctx_t *)&aes_ctx);\n\t}\n\n\treturn (ret);\n}\n\n \nstatic int\naes_create_ctx_template(crypto_mechanism_t *mechanism, crypto_key_t *key,\n    crypto_spi_ctx_template_t *tmpl, size_t *tmpl_size)\n{\n\tvoid *keysched;\n\tsize_t size;\n\tint rv;\n\n\tif (mechanism->cm_type != AES_ECB_MECH_INFO_TYPE &&\n\t    mechanism->cm_type != AES_CBC_MECH_INFO_TYPE &&\n\t    mechanism->cm_type != AES_CTR_MECH_INFO_TYPE &&\n\t    mechanism->cm_type != AES_CCM_MECH_INFO_TYPE &&\n\t    mechanism->cm_type != AES_GCM_MECH_INFO_TYPE &&\n\t    mechanism->cm_type != AES_GMAC_MECH_INFO_TYPE)\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\n\tif ((keysched = aes_alloc_keysched(&size, KM_SLEEP)) == NULL) {\n\t\treturn (CRYPTO_HOST_MEMORY);\n\t}\n\n\t \n\tif ((rv = init_keysched(key, keysched)) != CRYPTO_SUCCESS) {\n\t\tmemset(keysched, 0, size);\n\t\tkmem_free(keysched, size);\n\t\treturn (rv);\n\t}\n\n\t*tmpl = keysched;\n\t*tmpl_size = size;\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n\nstatic int\naes_free_context(crypto_ctx_t *ctx)\n{\n\taes_ctx_t *aes_ctx = ctx->cc_provider_private;\n\n\tif (aes_ctx != NULL) {\n\t\tif (aes_ctx->ac_flags & PROVIDER_OWNS_KEY_SCHEDULE) {\n\t\t\tASSERT(aes_ctx->ac_keysched_len != 0);\n\t\t\tmemset(aes_ctx->ac_keysched, 0,\n\t\t\t    aes_ctx->ac_keysched_len);\n\t\t\tkmem_free(aes_ctx->ac_keysched,\n\t\t\t    aes_ctx->ac_keysched_len);\n\t\t}\n\t\tcrypto_free_mode_ctx(aes_ctx);\n\t\tctx->cc_provider_private = NULL;\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n\nstatic int\naes_common_init_ctx(aes_ctx_t *aes_ctx, crypto_spi_ctx_template_t *template,\n    crypto_mechanism_t *mechanism, crypto_key_t *key, int kmflag,\n    boolean_t is_encrypt_init)\n{\n\tint rv = CRYPTO_SUCCESS;\n\tvoid *keysched;\n\tsize_t size = 0;\n\n\tif (template == NULL) {\n\t\tif ((keysched = aes_alloc_keysched(&size, kmflag)) == NULL)\n\t\t\treturn (CRYPTO_HOST_MEMORY);\n\t\t \n\t\tif ((rv = init_keysched(key, keysched)) != CRYPTO_SUCCESS) {\n\t\t\tkmem_free(keysched, size);\n\t\t\treturn (rv);\n\t\t}\n\n\t\taes_ctx->ac_flags |= PROVIDER_OWNS_KEY_SCHEDULE;\n\t\taes_ctx->ac_keysched_len = size;\n\t} else {\n\t\tkeysched = template;\n\t}\n\taes_ctx->ac_keysched = keysched;\n\n\tswitch (mechanism->cm_type) {\n\tcase AES_CBC_MECH_INFO_TYPE:\n\t\trv = cbc_init_ctx((cbc_ctx_t *)aes_ctx, mechanism->cm_param,\n\t\t    mechanism->cm_param_len, AES_BLOCK_LEN, aes_copy_block64);\n\t\tbreak;\n\tcase AES_CTR_MECH_INFO_TYPE: {\n\t\tCK_AES_CTR_PARAMS *pp;\n\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (CK_AES_CTR_PARAMS)) {\n\t\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t\t}\n\t\tpp = (CK_AES_CTR_PARAMS *)(void *)mechanism->cm_param;\n\t\trv = ctr_init_ctx((ctr_ctx_t *)aes_ctx, pp->ulCounterBits,\n\t\t    pp->cb, aes_copy_block);\n\t\tbreak;\n\t}\n\tcase AES_CCM_MECH_INFO_TYPE:\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (CK_AES_CCM_PARAMS)) {\n\t\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t\t}\n\t\trv = ccm_init_ctx((ccm_ctx_t *)aes_ctx, mechanism->cm_param,\n\t\t    kmflag, is_encrypt_init, AES_BLOCK_LEN, aes_encrypt_block,\n\t\t    aes_xor_block);\n\t\tbreak;\n\tcase AES_GCM_MECH_INFO_TYPE:\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (CK_AES_GCM_PARAMS)) {\n\t\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t\t}\n\t\trv = gcm_init_ctx((gcm_ctx_t *)aes_ctx, mechanism->cm_param,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t\tbreak;\n\tcase AES_GMAC_MECH_INFO_TYPE:\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (CK_AES_GMAC_PARAMS)) {\n\t\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t\t}\n\t\trv = gmac_init_ctx((gcm_ctx_t *)aes_ctx, mechanism->cm_param,\n\t\t    AES_BLOCK_LEN, aes_encrypt_block, aes_copy_block,\n\t\t    aes_xor_block);\n\t\tbreak;\n\tcase AES_ECB_MECH_INFO_TYPE:\n\t\taes_ctx->ac_flags |= ECB_MODE;\n\t}\n\n\tif (rv != CRYPTO_SUCCESS) {\n\t\tif (aes_ctx->ac_flags & PROVIDER_OWNS_KEY_SCHEDULE) {\n\t\t\tmemset(keysched, 0, size);\n\t\t\tkmem_free(keysched, size);\n\t\t}\n\t}\n\n\treturn (rv);\n}\n\nstatic int\nprocess_gmac_mech(crypto_mechanism_t *mech, crypto_data_t *data,\n    CK_AES_GCM_PARAMS *gcm_params)\n{\n\t \n\tCK_AES_GMAC_PARAMS *params = (CK_AES_GMAC_PARAMS *)mech->cm_param;\n\n\tif (mech->cm_type != AES_GMAC_MECH_INFO_TYPE)\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\n\tif (mech->cm_param_len != sizeof (CK_AES_GMAC_PARAMS))\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\n\tif (params->pIv == NULL)\n\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\n\tgcm_params->pIv = params->pIv;\n\tgcm_params->ulIvLen = AES_GMAC_IV_LEN;\n\tgcm_params->ulTagBits = AES_GMAC_TAG_BITS;\n\n\tif (data == NULL)\n\t\treturn (CRYPTO_SUCCESS);\n\n\tif (data->cd_format != CRYPTO_DATA_RAW)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\tgcm_params->pAAD = (uchar_t *)data->cd_raw.iov_base;\n\tgcm_params->ulAADLen = data->cd_length;\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\naes_mac_atomic(crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,\n    crypto_spi_ctx_template_t template)\n{\n\tCK_AES_GCM_PARAMS gcm_params;\n\tcrypto_mechanism_t gcm_mech;\n\tint rv;\n\n\tif ((rv = process_gmac_mech(mechanism, data, &gcm_params))\n\t    != CRYPTO_SUCCESS)\n\t\treturn (rv);\n\n\tgcm_mech.cm_type = AES_GCM_MECH_INFO_TYPE;\n\tgcm_mech.cm_param_len = sizeof (CK_AES_GCM_PARAMS);\n\tgcm_mech.cm_param = (char *)&gcm_params;\n\n\treturn (aes_encrypt_atomic(&gcm_mech,\n\t    key, &null_crypto_data, mac, template));\n}\n\nstatic int\naes_mac_verify_atomic(crypto_mechanism_t *mechanism, crypto_key_t *key,\n    crypto_data_t *data, crypto_data_t *mac, crypto_spi_ctx_template_t template)\n{\n\tCK_AES_GCM_PARAMS gcm_params;\n\tcrypto_mechanism_t gcm_mech;\n\tint rv;\n\n\tif ((rv = process_gmac_mech(mechanism, data, &gcm_params))\n\t    != CRYPTO_SUCCESS)\n\t\treturn (rv);\n\n\tgcm_mech.cm_type = AES_GCM_MECH_INFO_TYPE;\n\tgcm_mech.cm_param_len = sizeof (CK_AES_GCM_PARAMS);\n\tgcm_mech.cm_param = (char *)&gcm_params;\n\n\treturn (aes_decrypt_atomic(&gcm_mech,\n\t    key, mac, &null_crypto_data, template));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}