{
  "module_name": "sha2_mod.c",
  "hash_id": "0b55a5607a3662558d019e5bbf562a5e0afad6fea21b987e1f56aa1641c65791",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/io/sha2_mod.c",
  "human_readable_source": " \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/spi.h>\n#include <sys/crypto/icp.h>\n#include <sys/sha2.h>\n#include <sha2/sha2_impl.h>\n\n \n\n#define\tPROV_SHA2_CTX(ctx)\t((sha2_ctx_t *)(ctx)->cc_provider_private)\n#define\tPROV_SHA2_HMAC_CTX(ctx)\t((sha2_hmac_ctx_t *)(ctx)->cc_provider_private)\n\n \n#define\tPROV_SHA2_GET_DIGEST_LEN(m, len) {\t\t\t\t\\\n\tif (IS_P2ALIGNED((m)->cm_param, sizeof (ulong_t)))\t\t\\\n\t\t(len) = (uint32_t)*((ulong_t *)(m)->cm_param);\t\\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tulong_t tmp_ulong;\t\t\t\t\t\\\n\t\tmemcpy(&tmp_ulong, (m)->cm_param, sizeof (ulong_t));\t\\\n\t\t(len) = (uint32_t)tmp_ulong;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define\tPROV_SHA2_DIGEST_KEY(mech, ctx, key, len, digest) {\t\\\n\tSHA2Init(mech, ctx);\t\t\t\t\\\n\tSHA2Update(ctx, key, len);\t\t\t\\\n\tSHA2Final(digest, ctx);\t\t\t\t\\\n}\n\n \nstatic const crypto_mech_info_t sha2_mech_info_tab[] = {\n\t \n\t{SUN_CKM_SHA256, SHA256_MECH_INFO_TYPE,\n\t    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC},\n\t \n\t{SUN_CKM_SHA256_HMAC, SHA256_HMAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t \n\t{SUN_CKM_SHA256_HMAC_GENERAL, SHA256_HMAC_GEN_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t \n\t{SUN_CKM_SHA384, SHA384_MECH_INFO_TYPE,\n\t    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC},\n\t \n\t{SUN_CKM_SHA384_HMAC, SHA384_HMAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t \n\t{SUN_CKM_SHA384_HMAC_GENERAL, SHA384_HMAC_GEN_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t \n\t{SUN_CKM_SHA512, SHA512_MECH_INFO_TYPE,\n\t    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC},\n\t \n\t{SUN_CKM_SHA512_HMAC, SHA512_HMAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t \n\t{SUN_CKM_SHA512_HMAC_GENERAL, SHA512_HMAC_GEN_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n};\n\nstatic int sha2_digest_init(crypto_ctx_t *, crypto_mechanism_t *);\nstatic int sha2_digest(crypto_ctx_t *, crypto_data_t *, crypto_data_t *);\nstatic int sha2_digest_update(crypto_ctx_t *, crypto_data_t *);\nstatic int sha2_digest_final(crypto_ctx_t *, crypto_data_t *);\nstatic int sha2_digest_atomic(crypto_mechanism_t *, crypto_data_t *,\n    crypto_data_t *);\n\nstatic const crypto_digest_ops_t sha2_digest_ops = {\n\t.digest_init = sha2_digest_init,\n\t.digest = sha2_digest,\n\t.digest_update = sha2_digest_update,\n\t.digest_final = sha2_digest_final,\n\t.digest_atomic = sha2_digest_atomic\n};\n\nstatic int sha2_mac_init(crypto_ctx_t *, crypto_mechanism_t *, crypto_key_t *,\n    crypto_spi_ctx_template_t);\nstatic int sha2_mac_update(crypto_ctx_t *, crypto_data_t *);\nstatic int sha2_mac_final(crypto_ctx_t *, crypto_data_t *);\nstatic int sha2_mac_atomic(crypto_mechanism_t *, crypto_key_t *,\n    crypto_data_t *, crypto_data_t *, crypto_spi_ctx_template_t);\nstatic int sha2_mac_verify_atomic(crypto_mechanism_t *, crypto_key_t *,\n    crypto_data_t *, crypto_data_t *, crypto_spi_ctx_template_t);\n\nstatic const crypto_mac_ops_t sha2_mac_ops = {\n\t.mac_init = sha2_mac_init,\n\t.mac = NULL,\n\t.mac_update = sha2_mac_update,\n\t.mac_final = sha2_mac_final,\n\t.mac_atomic = sha2_mac_atomic,\n\t.mac_verify_atomic = sha2_mac_verify_atomic\n};\n\nstatic int sha2_create_ctx_template(crypto_mechanism_t *, crypto_key_t *,\n    crypto_spi_ctx_template_t *, size_t *);\nstatic int sha2_free_context(crypto_ctx_t *);\n\nstatic const crypto_ctx_ops_t sha2_ctx_ops = {\n\t.create_ctx_template = sha2_create_ctx_template,\n\t.free_context = sha2_free_context\n};\n\nstatic const crypto_ops_t sha2_crypto_ops = {\n\t&sha2_digest_ops,\n\tNULL,\n\t&sha2_mac_ops,\n\t&sha2_ctx_ops,\n};\n\nstatic const crypto_provider_info_t sha2_prov_info = {\n\t\"SHA2 Software Provider\",\n\t&sha2_crypto_ops,\n\tsizeof (sha2_mech_info_tab) / sizeof (crypto_mech_info_t),\n\tsha2_mech_info_tab\n};\n\nstatic crypto_kcf_provider_handle_t sha2_prov_handle = 0;\n\nint\nsha2_mod_init(void)\n{\n\tint ret;\n\n\t \n\tif ((ret = crypto_register_provider(&sha2_prov_info,\n\t    &sha2_prov_handle)) != CRYPTO_SUCCESS)\n\t\tcmn_err(CE_WARN, \"sha2 _init: \"\n\t\t    \"crypto_register_provider() failed (0x%x)\", ret);\n\n\treturn (0);\n}\n\nint\nsha2_mod_fini(void)\n{\n\tint ret = 0;\n\n\tif (sha2_prov_handle != 0) {\n\t\tif ((ret = crypto_unregister_provider(sha2_prov_handle)) !=\n\t\t    CRYPTO_SUCCESS) {\n\t\t\tcmn_err(CE_WARN,\n\t\t\t    \"sha2 _fini: crypto_unregister_provider() \"\n\t\t\t    \"failed (0x%x)\", ret);\n\t\t\treturn (EBUSY);\n\t\t}\n\t\tsha2_prov_handle = 0;\n\t}\n\n\treturn (ret);\n}\n\n \n\nstatic int\nsha2_digest_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism)\n{\n\n\t \n\tctx->cc_provider_private = kmem_alloc(sizeof (sha2_ctx_t), KM_SLEEP);\n\tif (ctx->cc_provider_private == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\tPROV_SHA2_CTX(ctx)->sc_mech_type = mechanism->cm_type;\n\tSHA2Init(mechanism->cm_type, &PROV_SHA2_CTX(ctx)->sc_sha2_ctx);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nstatic int\nsha2_digest_update_uio(SHA2_CTX *sha2_ctx, crypto_data_t *data)\n{\n\toff_t offset = data->cd_offset;\n\tsize_t length = data->cd_length;\n\tuint_t vec_idx = 0;\n\tsize_t cur_len;\n\n\t \n\tif (zfs_uio_segflg(data->cd_uio) != UIO_SYSSPACE)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t \n\toffset = zfs_uio_index_at_offset(data->cd_uio, offset, &vec_idx);\n\tif (vec_idx == zfs_uio_iovcnt(data->cd_uio)) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\t \n\twhile (vec_idx < zfs_uio_iovcnt(data->cd_uio) && length > 0) {\n\t\tcur_len = MIN(zfs_uio_iovlen(data->cd_uio, vec_idx) -\n\t\t    offset, length);\n\n\t\tSHA2Update(sha2_ctx, (uint8_t *)zfs_uio_iovbase(data->cd_uio,\n\t\t    vec_idx) + offset, cur_len);\n\t\tlength -= cur_len;\n\t\tvec_idx++;\n\t\toffset = 0;\n\t}\n\n\tif (vec_idx == zfs_uio_iovcnt(data->cd_uio) && length > 0) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nstatic int\nsha2_digest_final_uio(SHA2_CTX *sha2_ctx, crypto_data_t *digest,\n    ulong_t digest_len, uchar_t *digest_scratch)\n{\n\toff_t offset = digest->cd_offset;\n\tuint_t vec_idx = 0;\n\n\t \n\tif (zfs_uio_segflg(digest->cd_uio) != UIO_SYSSPACE)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t \n\toffset = zfs_uio_index_at_offset(digest->cd_uio, offset, &vec_idx);\n\tif (vec_idx == zfs_uio_iovcnt(digest->cd_uio)) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\tif (offset + digest_len <=\n\t    zfs_uio_iovlen(digest->cd_uio, vec_idx)) {\n\t\t \n\t\tif (((sha2_ctx->algotype <= SHA256_HMAC_GEN_MECH_INFO_TYPE) &&\n\t\t    (digest_len != SHA256_DIGEST_LENGTH)) ||\n\t\t    ((sha2_ctx->algotype > SHA256_HMAC_GEN_MECH_INFO_TYPE) &&\n\t\t    (digest_len != SHA512_DIGEST_LENGTH))) {\n\t\t\t \n\t\t\tSHA2Final(digest_scratch, sha2_ctx);\n\n\t\t\tmemcpy((uchar_t *)\n\t\t\t    zfs_uio_iovbase(digest->cd_uio, vec_idx) + offset,\n\t\t\t    digest_scratch, digest_len);\n\t\t} else {\n\t\t\tSHA2Final((uchar_t *)zfs_uio_iovbase(digest->\n\t\t\t    cd_uio, vec_idx) + offset,\n\t\t\t    sha2_ctx);\n\n\t\t}\n\t} else {\n\t\t \n\t\tuchar_t digest_tmp[SHA512_DIGEST_LENGTH];\n\t\toff_t scratch_offset = 0;\n\t\tsize_t length = digest_len;\n\t\tsize_t cur_len;\n\n\t\tSHA2Final(digest_tmp, sha2_ctx);\n\n\t\twhile (vec_idx < zfs_uio_iovcnt(digest->cd_uio) && length > 0) {\n\t\t\tcur_len =\n\t\t\t    MIN(zfs_uio_iovlen(digest->cd_uio, vec_idx) -\n\t\t\t    offset, length);\n\t\t\tmemcpy(\n\t\t\t    zfs_uio_iovbase(digest->cd_uio, vec_idx) + offset,\n\t\t\t    digest_tmp + scratch_offset,\n\t\t\t    cur_len);\n\n\t\t\tlength -= cur_len;\n\t\t\tvec_idx++;\n\t\t\tscratch_offset += cur_len;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tif (vec_idx == zfs_uio_iovcnt(digest->cd_uio) && length > 0) {\n\t\t\t \n\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t\t}\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\nsha2_digest(crypto_ctx_t *ctx, crypto_data_t *data, crypto_data_t *digest)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tuint_t sha_digest_len;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\n\tswitch (PROV_SHA2_CTX(ctx)->sc_mech_type) {\n\tcase SHA256_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA256_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA384_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA384_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA512_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA512_DIGEST_LENGTH;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t}\n\n\t \n\tif ((digest->cd_length == 0) ||\n\t    (digest->cd_length < sha_digest_len)) {\n\t\tdigest->cd_length = sha_digest_len;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\t \n\tswitch (data->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Update(&PROV_SHA2_CTX(ctx)->sc_sha2_ctx,\n\t\t    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,\n\t\t    data->cd_length);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_update_uio(&PROV_SHA2_CTX(ctx)->sc_sha2_ctx,\n\t\t    data);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (ret != CRYPTO_SUCCESS) {\n\t\t \n\t\tkmem_free(ctx->cc_provider_private, sizeof (sha2_ctx_t));\n\t\tctx->cc_provider_private = NULL;\n\t\tdigest->cd_length = 0;\n\t\treturn (ret);\n\t}\n\n\t \n\tswitch (digest->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Final((unsigned char *)digest->cd_raw.iov_base +\n\t\t    digest->cd_offset, &PROV_SHA2_CTX(ctx)->sc_sha2_ctx);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_final_uio(&PROV_SHA2_CTX(ctx)->sc_sha2_ctx,\n\t\t    digest, sha_digest_len, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\t \n\n\tif (ret == CRYPTO_SUCCESS)\n\t\tdigest->cd_length = sha_digest_len;\n\telse\n\t\tdigest->cd_length = 0;\n\n\tkmem_free(ctx->cc_provider_private, sizeof (sha2_ctx_t));\n\tctx->cc_provider_private = NULL;\n\treturn (ret);\n}\n\nstatic int\nsha2_digest_update(crypto_ctx_t *ctx, crypto_data_t *data)\n{\n\tint ret = CRYPTO_SUCCESS;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\n\t \n\tswitch (data->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Update(&PROV_SHA2_CTX(ctx)->sc_sha2_ctx,\n\t\t    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,\n\t\t    data->cd_length);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_update_uio(&PROV_SHA2_CTX(ctx)->sc_sha2_ctx,\n\t\t    data);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nsha2_digest_final(crypto_ctx_t *ctx, crypto_data_t *digest)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tuint_t sha_digest_len;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\n\tswitch (PROV_SHA2_CTX(ctx)->sc_mech_type) {\n\tcase SHA256_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA256_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA384_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA384_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA512_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA512_DIGEST_LENGTH;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t}\n\n\t \n\tif ((digest->cd_length == 0) ||\n\t    (digest->cd_length < sha_digest_len)) {\n\t\tdigest->cd_length = sha_digest_len;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\t \n\tswitch (digest->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Final((unsigned char *)digest->cd_raw.iov_base +\n\t\t    digest->cd_offset, &PROV_SHA2_CTX(ctx)->sc_sha2_ctx);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_final_uio(&PROV_SHA2_CTX(ctx)->sc_sha2_ctx,\n\t\t    digest, sha_digest_len, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\t \n\n\tif (ret == CRYPTO_SUCCESS)\n\t\tdigest->cd_length = sha_digest_len;\n\telse\n\t\tdigest->cd_length = 0;\n\n\tkmem_free(ctx->cc_provider_private, sizeof (sha2_ctx_t));\n\tctx->cc_provider_private = NULL;\n\n\treturn (ret);\n}\n\nstatic int\nsha2_digest_atomic(crypto_mechanism_t *mechanism, crypto_data_t *data,\n    crypto_data_t *digest)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tSHA2_CTX sha2_ctx;\n\tuint32_t sha_digest_len;\n\n\t \n\n\tSHA2Init(mechanism->cm_type, &sha2_ctx);\n\n\tswitch (data->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Update(&sha2_ctx, (uint8_t *)data->\n\t\t    cd_raw.iov_base + data->cd_offset, data->cd_length);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_update_uio(&sha2_ctx, data);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\t \n\n\tif (ret != CRYPTO_SUCCESS) {\n\t\t \n\t\tdigest->cd_length = 0;\n\t\treturn (ret);\n\t}\n\n\tif (mechanism->cm_type <= SHA256_HMAC_GEN_MECH_INFO_TYPE)\n\t\tsha_digest_len = SHA256_DIGEST_LENGTH;\n\telse\n\t\tsha_digest_len = SHA512_DIGEST_LENGTH;\n\n\t \n\tswitch (digest->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Final((unsigned char *)digest->cd_raw.iov_base +\n\t\t    digest->cd_offset, &sha2_ctx);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_final_uio(&sha2_ctx, digest,\n\t\t    sha_digest_len, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (ret == CRYPTO_SUCCESS)\n\t\tdigest->cd_length = sha_digest_len;\n\telse\n\t\tdigest->cd_length = 0;\n\n\treturn (ret);\n}\n\n \n\n \nstatic void\nsha2_mac_init_ctx(sha2_hmac_ctx_t *ctx, void *keyval, uint_t length_in_bytes)\n{\n\tuint64_t ipad[SHA512_HMAC_BLOCK_SIZE / sizeof (uint64_t)] = {0};\n\tuint64_t opad[SHA512_HMAC_BLOCK_SIZE / sizeof (uint64_t)] = {0};\n\tint i, block_size, blocks_per_int64;\n\n\t \n\tif (ctx->hc_mech_type <= SHA256_HMAC_GEN_MECH_INFO_TYPE) {\n\t\tblock_size = SHA256_HMAC_BLOCK_SIZE;\n\t\tblocks_per_int64 = SHA256_HMAC_BLOCK_SIZE / sizeof (uint64_t);\n\t} else {\n\t\tblock_size = SHA512_HMAC_BLOCK_SIZE;\n\t\tblocks_per_int64 = SHA512_HMAC_BLOCK_SIZE / sizeof (uint64_t);\n\t}\n\n\t(void) memset(ipad, 0, block_size);\n\t(void) memset(opad, 0, block_size);\n\n\tif (keyval != NULL) {\n\t\t(void) memcpy(ipad, keyval, length_in_bytes);\n\t\t(void) memcpy(opad, keyval, length_in_bytes);\n\t} else {\n\t\tASSERT0(length_in_bytes);\n\t}\n\n\t \n\tfor (i = 0; i < blocks_per_int64; i ++) {\n\t\tipad[i] ^= 0x3636363636363636;\n\t\topad[i] ^= 0x5c5c5c5c5c5c5c5c;\n\t}\n\n\t \n\tSHA2Init(ctx->hc_mech_type, &ctx->hc_icontext);\n\tSHA2Update(&ctx->hc_icontext, (uint8_t *)ipad, block_size);\n\n\t \n\tSHA2Init(ctx->hc_mech_type, &ctx->hc_ocontext);\n\tSHA2Update(&ctx->hc_ocontext, (uint8_t *)opad, block_size);\n}\n\n \nstatic int\nsha2_mac_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_spi_ctx_template_t ctx_template)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tuint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);\n\tuint_t sha_digest_len, sha_hmac_block_size;\n\n\t \n\tswitch (mechanism->cm_type) {\n\tcase SHA256_HMAC_MECH_INFO_TYPE:\n\tcase SHA256_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA256_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA256_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tcase SHA384_HMAC_MECH_INFO_TYPE:\n\tcase SHA384_HMAC_GEN_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA512_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA512_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t}\n\n\tctx->cc_provider_private =\n\t    kmem_alloc(sizeof (sha2_hmac_ctx_t), KM_SLEEP);\n\tif (ctx->cc_provider_private == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\tPROV_SHA2_HMAC_CTX(ctx)->hc_mech_type = mechanism->cm_type;\n\tif (ctx_template != NULL) {\n\t\t \n\t\tmemcpy(PROV_SHA2_HMAC_CTX(ctx), ctx_template,\n\t\t    sizeof (sha2_hmac_ctx_t));\n\t} else {\n\t\t \n\t\tif (keylen_in_bytes > sha_hmac_block_size) {\n\t\t\tuchar_t digested_key[SHA512_DIGEST_LENGTH];\n\t\t\tsha2_hmac_ctx_t *hmac_ctx = ctx->cc_provider_private;\n\n\t\t\t \n\t\t\tPROV_SHA2_DIGEST_KEY(mechanism->cm_type / 3,\n\t\t\t    &hmac_ctx->hc_icontext,\n\t\t\t    key->ck_data, keylen_in_bytes, digested_key);\n\t\t\tsha2_mac_init_ctx(PROV_SHA2_HMAC_CTX(ctx),\n\t\t\t    digested_key, sha_digest_len);\n\t\t} else {\n\t\t\tsha2_mac_init_ctx(PROV_SHA2_HMAC_CTX(ctx),\n\t\t\t    key->ck_data, keylen_in_bytes);\n\t\t}\n\t}\n\n\t \n\tif (mechanism->cm_type % 3 == 2) {\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (ulong_t)) {\n\t\t\tret = CRYPTO_MECHANISM_PARAM_INVALID;\n\t\t} else {\n\t\t\tPROV_SHA2_GET_DIGEST_LEN(mechanism,\n\t\t\t    PROV_SHA2_HMAC_CTX(ctx)->hc_digest_len);\n\t\t\tif (PROV_SHA2_HMAC_CTX(ctx)->hc_digest_len >\n\t\t\t    sha_digest_len)\n\t\t\t\tret = CRYPTO_MECHANISM_PARAM_INVALID;\n\t\t}\n\t}\n\n\tif (ret != CRYPTO_SUCCESS) {\n\t\tmemset(ctx->cc_provider_private, 0, sizeof (sha2_hmac_ctx_t));\n\t\tkmem_free(ctx->cc_provider_private, sizeof (sha2_hmac_ctx_t));\n\t\tctx->cc_provider_private = NULL;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nsha2_mac_update(crypto_ctx_t *ctx, crypto_data_t *data)\n{\n\tint ret = CRYPTO_SUCCESS;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\n\t \n\tswitch (data->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSHA2Update(&PROV_SHA2_HMAC_CTX(ctx)->hc_icontext,\n\t\t    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,\n\t\t    data->cd_length);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_update_uio(\n\t\t    &PROV_SHA2_HMAC_CTX(ctx)->hc_icontext, data);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\treturn (ret);\n}\n\nstatic int\nsha2_mac_final(crypto_ctx_t *ctx, crypto_data_t *mac)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tuchar_t digest[SHA512_DIGEST_LENGTH];\n\tuint32_t digest_len, sha_digest_len;\n\n\tASSERT(ctx->cc_provider_private != NULL);\n\n\t \n\tswitch (PROV_SHA2_HMAC_CTX(ctx)->hc_mech_type) {\n\tcase SHA256_HMAC_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA256_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA384_HMAC_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA384_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA512_HMAC_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA512_DIGEST_LENGTH;\n\t\tbreak;\n\tcase SHA256_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA256_DIGEST_LENGTH;\n\t\tdigest_len = PROV_SHA2_HMAC_CTX(ctx)->hc_digest_len;\n\t\tbreak;\n\tcase SHA384_HMAC_GEN_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA512_DIGEST_LENGTH;\n\t\tdigest_len = PROV_SHA2_HMAC_CTX(ctx)->hc_digest_len;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\t}\n\n\t \n\tif ((mac->cd_length == 0) || (mac->cd_length < digest_len)) {\n\t\tmac->cd_length = digest_len;\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\t \n\tSHA2Final(digest, &PROV_SHA2_HMAC_CTX(ctx)->hc_icontext);\n\n\t \n\tSHA2Update(&PROV_SHA2_HMAC_CTX(ctx)->hc_ocontext, digest,\n\t    sha_digest_len);\n\n\t \n\tswitch (mac->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tif (digest_len != sha_digest_len) {\n\t\t\t \n\t\t\tSHA2Final(digest,\n\t\t\t    &PROV_SHA2_HMAC_CTX(ctx)->hc_ocontext);\n\t\t\tmemcpy((unsigned char *)mac->cd_raw.iov_base +\n\t\t\t    mac->cd_offset, digest, digest_len);\n\t\t} else {\n\t\t\tSHA2Final((unsigned char *)mac->cd_raw.iov_base +\n\t\t\t    mac->cd_offset,\n\t\t\t    &PROV_SHA2_HMAC_CTX(ctx)->hc_ocontext);\n\t\t}\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_final_uio(\n\t\t    &PROV_SHA2_HMAC_CTX(ctx)->hc_ocontext, mac,\n\t\t    digest_len, digest);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (ret == CRYPTO_SUCCESS)\n\t\tmac->cd_length = digest_len;\n\telse\n\t\tmac->cd_length = 0;\n\n\tmemset(ctx->cc_provider_private, 0, sizeof (sha2_hmac_ctx_t));\n\tkmem_free(ctx->cc_provider_private, sizeof (sha2_hmac_ctx_t));\n\tctx->cc_provider_private = NULL;\n\n\treturn (ret);\n}\n\n#define\tSHA2_MAC_UPDATE(data, ctx, ret) {\t\t\t\t\\\n\tswitch (data->cd_format) {\t\t\t\t\t\\\n\tcase CRYPTO_DATA_RAW:\t\t\t\t\t\t\\\n\t\tSHA2Update(&(ctx).hc_icontext,\t\t\t\t\\\n\t\t    (uint8_t *)data->cd_raw.iov_base +\t\t\t\\\n\t\t    data->cd_offset, data->cd_length);\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase CRYPTO_DATA_UIO:\t\t\t\t\t\t\\\n\t\tret = sha2_digest_update_uio(&(ctx).hc_icontext, data);\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\tret = CRYPTO_ARGUMENTS_BAD;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nstatic int\nsha2_mac_atomic(crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,\n    crypto_spi_ctx_template_t ctx_template)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tuchar_t digest[SHA512_DIGEST_LENGTH];\n\tsha2_hmac_ctx_t sha2_hmac_ctx;\n\tuint32_t sha_digest_len, digest_len, sha_hmac_block_size;\n\tuint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);\n\n\t \n\tswitch (mechanism->cm_type) {\n\tcase SHA256_HMAC_MECH_INFO_TYPE:\n\tcase SHA256_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA256_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA256_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tcase SHA384_HMAC_MECH_INFO_TYPE:\n\tcase SHA384_HMAC_GEN_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA512_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA512_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t}\n\n\tif (ctx_template != NULL) {\n\t\t \n\t\tmemcpy(&sha2_hmac_ctx, ctx_template, sizeof (sha2_hmac_ctx_t));\n\t} else {\n\t\tsha2_hmac_ctx.hc_mech_type = mechanism->cm_type;\n\t\t \n\t\tif (keylen_in_bytes > sha_hmac_block_size) {\n\t\t\t \n\t\t\tPROV_SHA2_DIGEST_KEY(mechanism->cm_type / 3,\n\t\t\t    &sha2_hmac_ctx.hc_icontext,\n\t\t\t    key->ck_data, keylen_in_bytes, digest);\n\t\t\tsha2_mac_init_ctx(&sha2_hmac_ctx, digest,\n\t\t\t    sha_digest_len);\n\t\t} else {\n\t\t\tsha2_mac_init_ctx(&sha2_hmac_ctx, key->ck_data,\n\t\t\t    keylen_in_bytes);\n\t\t}\n\t}\n\n\t \n\tif ((mechanism->cm_type % 3) == 2) {\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (ulong_t)) {\n\t\t\tret = CRYPTO_MECHANISM_PARAM_INVALID;\n\t\t\tgoto bail;\n\t\t}\n\t\tPROV_SHA2_GET_DIGEST_LEN(mechanism, digest_len);\n\t\tif (digest_len > sha_digest_len) {\n\t\t\tret = CRYPTO_MECHANISM_PARAM_INVALID;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tSHA2_MAC_UPDATE(data, sha2_hmac_ctx, ret);\n\tif (ret != CRYPTO_SUCCESS)\n\t\t \n\t\tgoto bail;\n\n\t \n\tSHA2Final(digest, &sha2_hmac_ctx.hc_icontext);\n\n\t \n\tif (mechanism->cm_type == SHA384_HMAC_MECH_INFO_TYPE ||\n\t    mechanism->cm_type == SHA384_HMAC_GEN_MECH_INFO_TYPE)\n\t\tSHA2Update(&sha2_hmac_ctx.hc_ocontext, digest,\n\t\t    SHA384_DIGEST_LENGTH);\n\telse\n\t\tSHA2Update(&sha2_hmac_ctx.hc_ocontext, digest, sha_digest_len);\n\n\t \n\tswitch (mac->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tif (digest_len != sha_digest_len) {\n\t\t\t \n\t\t\tSHA2Final(digest, &sha2_hmac_ctx.hc_ocontext);\n\t\t\tmemcpy((unsigned char *)mac->cd_raw.iov_base +\n\t\t\t    mac->cd_offset, digest, digest_len);\n\t\t} else {\n\t\t\tSHA2Final((unsigned char *)mac->cd_raw.iov_base +\n\t\t\t    mac->cd_offset, &sha2_hmac_ctx.hc_ocontext);\n\t\t}\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\tret = sha2_digest_final_uio(&sha2_hmac_ctx.hc_ocontext, mac,\n\t\t    digest_len, digest);\n\t\tbreak;\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (ret == CRYPTO_SUCCESS) {\n\t\tmac->cd_length = digest_len;\n\t\treturn (CRYPTO_SUCCESS);\n\t}\nbail:\n\tmemset(&sha2_hmac_ctx, 0, sizeof (sha2_hmac_ctx_t));\n\tmac->cd_length = 0;\n\treturn (ret);\n}\n\nstatic int\nsha2_mac_verify_atomic(crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,\n    crypto_spi_ctx_template_t ctx_template)\n{\n\tint ret = CRYPTO_SUCCESS;\n\tuchar_t digest[SHA512_DIGEST_LENGTH];\n\tsha2_hmac_ctx_t sha2_hmac_ctx;\n\tuint32_t sha_digest_len, digest_len, sha_hmac_block_size;\n\tuint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);\n\n\t \n\tswitch (mechanism->cm_type) {\n\tcase SHA256_HMAC_MECH_INFO_TYPE:\n\tcase SHA256_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA256_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA256_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tcase SHA384_HMAC_MECH_INFO_TYPE:\n\tcase SHA384_HMAC_GEN_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = digest_len = SHA512_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA512_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t}\n\n\tif (ctx_template != NULL) {\n\t\t \n\t\tmemcpy(&sha2_hmac_ctx, ctx_template, sizeof (sha2_hmac_ctx_t));\n\t} else {\n\t\tsha2_hmac_ctx.hc_mech_type = mechanism->cm_type;\n\t\t \n\t\tif (keylen_in_bytes > sha_hmac_block_size) {\n\t\t\t \n\t\t\tPROV_SHA2_DIGEST_KEY(mechanism->cm_type / 3,\n\t\t\t    &sha2_hmac_ctx.hc_icontext,\n\t\t\t    key->ck_data, keylen_in_bytes, digest);\n\t\t\tsha2_mac_init_ctx(&sha2_hmac_ctx, digest,\n\t\t\t    sha_digest_len);\n\t\t} else {\n\t\t\tsha2_mac_init_ctx(&sha2_hmac_ctx, key->ck_data,\n\t\t\t    keylen_in_bytes);\n\t\t}\n\t}\n\n\t \n\tif (mechanism->cm_type % 3 == 2) {\n\t\tif (mechanism->cm_param == NULL ||\n\t\t    mechanism->cm_param_len != sizeof (ulong_t)) {\n\t\t\tret = CRYPTO_MECHANISM_PARAM_INVALID;\n\t\t\tgoto bail;\n\t\t}\n\t\tPROV_SHA2_GET_DIGEST_LEN(mechanism, digest_len);\n\t\tif (digest_len > sha_digest_len) {\n\t\t\tret = CRYPTO_MECHANISM_PARAM_INVALID;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (mac->cd_length != digest_len) {\n\t\tret = CRYPTO_INVALID_MAC;\n\t\tgoto bail;\n\t}\n\n\t \n\tSHA2_MAC_UPDATE(data, sha2_hmac_ctx, ret);\n\tif (ret != CRYPTO_SUCCESS)\n\t\t \n\t\tgoto bail;\n\n\t \n\tSHA2Final(digest, &sha2_hmac_ctx.hc_icontext);\n\n\t \n\tif (mechanism->cm_type == SHA384_HMAC_MECH_INFO_TYPE ||\n\t    mechanism->cm_type == SHA384_HMAC_GEN_MECH_INFO_TYPE)\n\t\tSHA2Update(&sha2_hmac_ctx.hc_ocontext, digest,\n\t\t    SHA384_DIGEST_LENGTH);\n\telse\n\t\tSHA2Update(&sha2_hmac_ctx.hc_ocontext, digest, sha_digest_len);\n\n\t \n\tSHA2Final(digest, &sha2_hmac_ctx.hc_ocontext);\n\n\t \n\n\tswitch (mac->cd_format) {\n\n\tcase CRYPTO_DATA_RAW:\n\t\tif (memcmp(digest, (unsigned char *)mac->cd_raw.iov_base +\n\t\t    mac->cd_offset, digest_len) != 0)\n\t\t\tret = CRYPTO_INVALID_MAC;\n\t\tbreak;\n\n\tcase CRYPTO_DATA_UIO: {\n\t\toff_t offset = mac->cd_offset;\n\t\tuint_t vec_idx = 0;\n\t\toff_t scratch_offset = 0;\n\t\tsize_t length = digest_len;\n\t\tsize_t cur_len;\n\n\t\t \n\t\tif (zfs_uio_segflg(mac->cd_uio) != UIO_SYSSPACE)\n\t\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t\t \n\t\toffset = zfs_uio_index_at_offset(mac->cd_uio, offset, &vec_idx);\n\t\tif (vec_idx == zfs_uio_iovcnt(mac->cd_uio)) {\n\t\t\t \n\t\t\tret = CRYPTO_DATA_LEN_RANGE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\twhile (vec_idx < zfs_uio_iovcnt(mac->cd_uio) && length > 0) {\n\t\t\tcur_len = MIN(zfs_uio_iovlen(mac->cd_uio, vec_idx) -\n\t\t\t    offset, length);\n\n\t\t\tif (memcmp(digest + scratch_offset,\n\t\t\t    zfs_uio_iovbase(mac->cd_uio, vec_idx) + offset,\n\t\t\t    cur_len) != 0) {\n\t\t\t\tret = CRYPTO_INVALID_MAC;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlength -= cur_len;\n\t\t\tvec_idx++;\n\t\t\tscratch_offset += cur_len;\n\t\t\toffset = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\treturn (ret);\nbail:\n\tmemset(&sha2_hmac_ctx, 0, sizeof (sha2_hmac_ctx_t));\n\tmac->cd_length = 0;\n\treturn (ret);\n}\n\n \n\nstatic int\nsha2_create_ctx_template(crypto_mechanism_t *mechanism, crypto_key_t *key,\n    crypto_spi_ctx_template_t *ctx_template, size_t *ctx_template_size)\n{\n\tsha2_hmac_ctx_t *sha2_hmac_ctx_tmpl;\n\tuint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);\n\tuint32_t sha_digest_len, sha_hmac_block_size;\n\n\t \n\tswitch (mechanism->cm_type) {\n\tcase SHA256_HMAC_MECH_INFO_TYPE:\n\tcase SHA256_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA256_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA256_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tcase SHA384_HMAC_MECH_INFO_TYPE:\n\tcase SHA384_HMAC_GEN_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_MECH_INFO_TYPE:\n\tcase SHA512_HMAC_GEN_MECH_INFO_TYPE:\n\t\tsha_digest_len = SHA512_DIGEST_LENGTH;\n\t\tsha_hmac_block_size = SHA512_HMAC_BLOCK_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t}\n\n\t \n\tsha2_hmac_ctx_tmpl = kmem_alloc(sizeof (sha2_hmac_ctx_t), KM_SLEEP);\n\tif (sha2_hmac_ctx_tmpl == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\tsha2_hmac_ctx_tmpl->hc_mech_type = mechanism->cm_type;\n\n\tif (keylen_in_bytes > sha_hmac_block_size) {\n\t\tuchar_t digested_key[SHA512_DIGEST_LENGTH];\n\n\t\t \n\t\tPROV_SHA2_DIGEST_KEY(mechanism->cm_type / 3,\n\t\t    &sha2_hmac_ctx_tmpl->hc_icontext,\n\t\t    key->ck_data, keylen_in_bytes, digested_key);\n\t\tsha2_mac_init_ctx(sha2_hmac_ctx_tmpl, digested_key,\n\t\t    sha_digest_len);\n\t} else {\n\t\tsha2_mac_init_ctx(sha2_hmac_ctx_tmpl, key->ck_data,\n\t\t    keylen_in_bytes);\n\t}\n\n\t*ctx_template = (crypto_spi_ctx_template_t)sha2_hmac_ctx_tmpl;\n\t*ctx_template_size = sizeof (sha2_hmac_ctx_t);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\nstatic int\nsha2_free_context(crypto_ctx_t *ctx)\n{\n\tuint_t ctx_len;\n\n\tif (ctx->cc_provider_private == NULL)\n\t\treturn (CRYPTO_SUCCESS);\n\n\t \n\n\tif (PROV_SHA2_CTX(ctx)->sc_mech_type % 3 == 0)\n\t\tctx_len = sizeof (sha2_ctx_t);\n\telse\n\t\tctx_len = sizeof (sha2_hmac_ctx_t);\n\n\tmemset(ctx->cc_provider_private, 0, ctx_len);\n\tkmem_free(ctx->cc_provider_private, ctx_len);\n\tctx->cc_provider_private = NULL;\n\n\treturn (CRYPTO_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}