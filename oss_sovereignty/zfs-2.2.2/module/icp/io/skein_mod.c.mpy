{
  "module_name": "skein_mod.c",
  "hash_id": "22789a7ed904f52803bc12a98bdbef028c62bef4859990b81ce02b4dd6c22b6c",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/io/skein_mod.c",
  "human_readable_source": " \n\n \n\n#include <sys/crypto/common.h>\n#include <sys/crypto/icp.h>\n#include <sys/crypto/spi.h>\n#include <sys/sysmacros.h>\n#define\tSKEIN_MODULE_IMPL\n#include <sys/skein.h>\n\nstatic const crypto_mech_info_t skein_mech_info_tab[] = {\n\t{CKM_SKEIN_256, SKEIN_256_MECH_INFO_TYPE,\n\t    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC},\n\t{CKM_SKEIN_256_MAC, SKEIN_256_MAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t{CKM_SKEIN_512, SKEIN_512_MECH_INFO_TYPE,\n\t    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC},\n\t{CKM_SKEIN_512_MAC, SKEIN_512_MAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n\t{CKM_SKEIN1024, SKEIN1024_MECH_INFO_TYPE,\n\t    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC},\n\t{CKM_SKEIN1024_MAC, SKEIN1024_MAC_MECH_INFO_TYPE,\n\t    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC},\n};\n\nstatic int skein_digest_init(crypto_ctx_t *, crypto_mechanism_t *);\nstatic int skein_digest(crypto_ctx_t *, crypto_data_t *, crypto_data_t *);\nstatic int skein_update(crypto_ctx_t *, crypto_data_t *);\nstatic int skein_final(crypto_ctx_t *, crypto_data_t *);\nstatic int skein_digest_atomic(crypto_mechanism_t *, crypto_data_t *,\n    crypto_data_t *);\n\nstatic const crypto_digest_ops_t skein_digest_ops = {\n\t.digest_init = skein_digest_init,\n\t.digest = skein_digest,\n\t.digest_update = skein_update,\n\t.digest_final = skein_final,\n\t.digest_atomic = skein_digest_atomic\n};\n\nstatic int skein_mac_init(crypto_ctx_t *, crypto_mechanism_t *, crypto_key_t *,\n    crypto_spi_ctx_template_t);\nstatic int skein_mac_atomic(crypto_mechanism_t *, crypto_key_t *,\n    crypto_data_t *, crypto_data_t *, crypto_spi_ctx_template_t);\n\nstatic const crypto_mac_ops_t skein_mac_ops = {\n\t.mac_init = skein_mac_init,\n\t.mac = NULL,\n\t.mac_update = skein_update,  \n\t.mac_final = skein_final,    \n\t.mac_atomic = skein_mac_atomic,\n\t.mac_verify_atomic = NULL\n};\n\nstatic int skein_create_ctx_template(crypto_mechanism_t *, crypto_key_t *,\n    crypto_spi_ctx_template_t *, size_t *);\nstatic int skein_free_context(crypto_ctx_t *);\n\nstatic const crypto_ctx_ops_t skein_ctx_ops = {\n\t.create_ctx_template = skein_create_ctx_template,\n\t.free_context = skein_free_context\n};\n\nstatic const crypto_ops_t skein_crypto_ops = {\n\t&skein_digest_ops,\n\tNULL,\n\t&skein_mac_ops,\n\t&skein_ctx_ops,\n};\n\nstatic const crypto_provider_info_t skein_prov_info = {\n\t\"Skein Software Provider\",\n\t&skein_crypto_ops,\n\tsizeof (skein_mech_info_tab) / sizeof (crypto_mech_info_t),\n\tskein_mech_info_tab\n};\n\nstatic crypto_kcf_provider_handle_t skein_prov_handle = 0;\n\ntypedef struct skein_ctx {\n\tskein_mech_type_t\t\tsc_mech_type;\n\tsize_t\t\t\t\tsc_digest_bitlen;\n\t \n\tunion {\n\t\tSkein_256_Ctxt_t\tsc_256;\n\t\tSkein_512_Ctxt_t\tsc_512;\n\t\tSkein1024_Ctxt_t\tsc_1024;\n\t};\n} skein_ctx_t;\n#define\tSKEIN_CTX(_ctx_)\t((skein_ctx_t *)((_ctx_)->cc_provider_private))\n#define\tSKEIN_CTX_LVALUE(_ctx_)\t(_ctx_)->cc_provider_private\n#define\tSKEIN_OP(_skein_ctx, _op, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tskein_ctx_t\t*sc = (_skein_ctx);\t\t\t\\\n\t\tswitch (sc->sc_mech_type) {\t\t\t\t\\\n\t\tcase SKEIN_256_MECH_INFO_TYPE:\t\t\t\t\\\n\t\tcase SKEIN_256_MAC_MECH_INFO_TYPE:\t\t\t\\\n\t\t\t(void) Skein_256_ ## _op(&sc->sc_256, __VA_ARGS__);\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase SKEIN_512_MECH_INFO_TYPE:\t\t\t\t\\\n\t\tcase SKEIN_512_MAC_MECH_INFO_TYPE:\t\t\t\\\n\t\t\t(void) Skein_512_ ## _op(&sc->sc_512, __VA_ARGS__);\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tcase SKEIN1024_MECH_INFO_TYPE:\t\t\t\t\\\n\t\tcase SKEIN1024_MAC_MECH_INFO_TYPE:\t\t\t\\\n\t\t\t(void) Skein1024_ ## _op(&sc->sc_1024, __VA_ARGS__);\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int\nskein_get_digest_bitlen(const crypto_mechanism_t *mechanism, size_t *result)\n{\n\tif (mechanism->cm_param != NULL) {\n\t\t \n\t\tskein_param_t\t*param = (skein_param_t *)mechanism->cm_param;\n\n\t\tif (mechanism->cm_param_len != sizeof (*param) ||\n\t\t    param->sp_digest_bitlen == 0) {\n\t\t\treturn (CRYPTO_MECHANISM_PARAM_INVALID);\n\t\t}\n\t\t*result = param->sp_digest_bitlen;\n\t} else {\n\t\tswitch (mechanism->cm_type) {\n\t\tcase SKEIN_256_MECH_INFO_TYPE:\n\t\t\t*result = 256;\n\t\t\tbreak;\n\t\tcase SKEIN_512_MECH_INFO_TYPE:\n\t\t\t*result = 512;\n\t\t\tbreak;\n\t\tcase SKEIN1024_MECH_INFO_TYPE:\n\t\t\t*result = 1024;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (CRYPTO_MECHANISM_INVALID);\n\t\t}\n\t}\n\treturn (CRYPTO_SUCCESS);\n}\n\nint\nskein_mod_init(void)\n{\n\t \n\t(void) crypto_register_provider(&skein_prov_info, &skein_prov_handle);\n\n\treturn (0);\n}\n\nint\nskein_mod_fini(void)\n{\n\tint ret = 0;\n\n\tif (skein_prov_handle != 0) {\n\t\tif ((ret = crypto_unregister_provider(skein_prov_handle)) !=\n\t\t    CRYPTO_SUCCESS) {\n\t\t\tcmn_err(CE_WARN,\n\t\t\t    \"skein _fini: crypto_unregister_provider() \"\n\t\t\t    \"failed (0x%x)\", ret);\n\t\t\treturn (EBUSY);\n\t\t}\n\t\tskein_prov_handle = 0;\n\t}\n\n\treturn (0);\n}\n\n \n\n \nstatic int\nskein_digest_update_uio(skein_ctx_t *ctx, const crypto_data_t *data)\n{\n\toff_t\t\toffset = data->cd_offset;\n\tsize_t\t\tlength = data->cd_length;\n\tuint_t\t\tvec_idx = 0;\n\tsize_t\t\tcur_len;\n\tzfs_uio_t\t*uio = data->cd_uio;\n\n\t \n\tif (zfs_uio_segflg(uio) != UIO_SYSSPACE)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t \n\toffset = zfs_uio_index_at_offset(uio, offset, &vec_idx);\n\tif (vec_idx == zfs_uio_iovcnt(uio)) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\t \n\twhile (vec_idx < zfs_uio_iovcnt(uio) && length > 0) {\n\t\tcur_len = MIN(zfs_uio_iovlen(uio, vec_idx) - offset, length);\n\t\tSKEIN_OP(ctx, Update, (uint8_t *)zfs_uio_iovbase(uio, vec_idx)\n\t\t    + offset, cur_len);\n\t\tlength -= cur_len;\n\t\tvec_idx++;\n\t\toffset = 0;\n\t}\n\n\tif (vec_idx == zfs_uio_iovcnt(uio) && length > 0) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nstatic int\nskein_digest_final_uio(skein_ctx_t *ctx, crypto_data_t *digest)\n{\n\toff_t offset = digest->cd_offset;\n\tuint_t vec_idx = 0;\n\tzfs_uio_t *uio = digest->cd_uio;\n\n\t \n\tif (zfs_uio_segflg(uio) != UIO_SYSSPACE)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\t \n\toffset = zfs_uio_index_at_offset(uio, offset, &vec_idx);\n\tif (vec_idx == zfs_uio_iovcnt(uio)) {\n\t\t \n\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t}\n\tif (offset + CRYPTO_BITS2BYTES(ctx->sc_digest_bitlen) <=\n\t    zfs_uio_iovlen(uio, vec_idx)) {\n\t\t \n\t\tSKEIN_OP(ctx, Final,\n\t\t    (uchar_t *)zfs_uio_iovbase(uio, vec_idx) + offset);\n\t} else {\n\t\tuint8_t *digest_tmp;\n\t\toff_t scratch_offset = 0;\n\t\tsize_t length = CRYPTO_BITS2BYTES(ctx->sc_digest_bitlen);\n\t\tsize_t cur_len;\n\n\t\tdigest_tmp = kmem_alloc(CRYPTO_BITS2BYTES(\n\t\t    ctx->sc_digest_bitlen), KM_SLEEP);\n\t\tif (digest_tmp == NULL)\n\t\t\treturn (CRYPTO_HOST_MEMORY);\n\t\tSKEIN_OP(ctx, Final, digest_tmp);\n\t\twhile (vec_idx < zfs_uio_iovcnt(uio) && length > 0) {\n\t\t\tcur_len = MIN(zfs_uio_iovlen(uio, vec_idx) - offset,\n\t\t\t    length);\n\t\t\tmemcpy(zfs_uio_iovbase(uio, vec_idx) + offset,\n\t\t\t    digest_tmp + scratch_offset, cur_len);\n\n\t\t\tlength -= cur_len;\n\t\t\tvec_idx++;\n\t\t\tscratch_offset += cur_len;\n\t\t\toffset = 0;\n\t\t}\n\t\tkmem_free(digest_tmp, CRYPTO_BITS2BYTES(ctx->sc_digest_bitlen));\n\n\t\tif (vec_idx == zfs_uio_iovcnt(uio) && length > 0) {\n\t\t\t \n\t\t\treturn (CRYPTO_DATA_LEN_RANGE);\n\t\t}\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \n\n \nstatic int\nskein_digest_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism)\n{\n\tint\terror = CRYPTO_SUCCESS;\n\n\tif (!VALID_SKEIN_DIGEST_MECH(mechanism->cm_type))\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\n\tSKEIN_CTX_LVALUE(ctx) = kmem_alloc(sizeof (*SKEIN_CTX(ctx)), KM_SLEEP);\n\tif (SKEIN_CTX(ctx) == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\tSKEIN_CTX(ctx)->sc_mech_type = mechanism->cm_type;\n\terror = skein_get_digest_bitlen(mechanism,\n\t    &SKEIN_CTX(ctx)->sc_digest_bitlen);\n\tif (error != CRYPTO_SUCCESS)\n\t\tgoto errout;\n\tSKEIN_OP(SKEIN_CTX(ctx), Init, SKEIN_CTX(ctx)->sc_digest_bitlen);\n\n\treturn (CRYPTO_SUCCESS);\nerrout:\n\tmemset(SKEIN_CTX(ctx), 0, sizeof (*SKEIN_CTX(ctx)));\n\tkmem_free(SKEIN_CTX(ctx), sizeof (*SKEIN_CTX(ctx)));\n\tSKEIN_CTX_LVALUE(ctx) = NULL;\n\treturn (error);\n}\n\n \nstatic int\nskein_digest(crypto_ctx_t *ctx, crypto_data_t *data, crypto_data_t *digest)\n{\n\tint error = CRYPTO_SUCCESS;\n\n\tASSERT(SKEIN_CTX(ctx) != NULL);\n\n\tif (digest->cd_length <\n\t    CRYPTO_BITS2BYTES(SKEIN_CTX(ctx)->sc_digest_bitlen)) {\n\t\tdigest->cd_length =\n\t\t    CRYPTO_BITS2BYTES(SKEIN_CTX(ctx)->sc_digest_bitlen);\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\terror = skein_update(ctx, data);\n\tif (error != CRYPTO_SUCCESS) {\n\t\tmemset(SKEIN_CTX(ctx), 0, sizeof (*SKEIN_CTX(ctx)));\n\t\tkmem_free(SKEIN_CTX(ctx), sizeof (*SKEIN_CTX(ctx)));\n\t\tSKEIN_CTX_LVALUE(ctx) = NULL;\n\t\tdigest->cd_length = 0;\n\t\treturn (error);\n\t}\n\terror = skein_final(ctx, digest);\n\n\treturn (error);\n}\n\n \nstatic int\nskein_update(crypto_ctx_t *ctx, crypto_data_t *data)\n{\n\tint error = CRYPTO_SUCCESS;\n\n\tASSERT(SKEIN_CTX(ctx) != NULL);\n\n\tswitch (data->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSKEIN_OP(SKEIN_CTX(ctx), Update,\n\t\t    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,\n\t\t    data->cd_length);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\terror = skein_digest_update_uio(SKEIN_CTX(ctx), data);\n\t\tbreak;\n\tdefault:\n\t\terror = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\treturn (error);\n}\n\n \nstatic int\nskein_final_nofree(crypto_ctx_t *ctx, crypto_data_t *digest)\n{\n\tint error = CRYPTO_SUCCESS;\n\n\tASSERT(SKEIN_CTX(ctx) != NULL);\n\n\tif (digest->cd_length <\n\t    CRYPTO_BITS2BYTES(SKEIN_CTX(ctx)->sc_digest_bitlen)) {\n\t\tdigest->cd_length =\n\t\t    CRYPTO_BITS2BYTES(SKEIN_CTX(ctx)->sc_digest_bitlen);\n\t\treturn (CRYPTO_BUFFER_TOO_SMALL);\n\t}\n\n\tswitch (digest->cd_format) {\n\tcase CRYPTO_DATA_RAW:\n\t\tSKEIN_OP(SKEIN_CTX(ctx), Final,\n\t\t    (uint8_t *)digest->cd_raw.iov_base + digest->cd_offset);\n\t\tbreak;\n\tcase CRYPTO_DATA_UIO:\n\t\terror = skein_digest_final_uio(SKEIN_CTX(ctx), digest);\n\t\tbreak;\n\tdefault:\n\t\terror = CRYPTO_ARGUMENTS_BAD;\n\t}\n\n\tif (error == CRYPTO_SUCCESS)\n\t\tdigest->cd_length =\n\t\t    CRYPTO_BITS2BYTES(SKEIN_CTX(ctx)->sc_digest_bitlen);\n\telse\n\t\tdigest->cd_length = 0;\n\n\treturn (error);\n}\n\nstatic int\nskein_final(crypto_ctx_t *ctx, crypto_data_t *digest)\n{\n\tint error = skein_final_nofree(ctx, digest);\n\n\tif (error == CRYPTO_BUFFER_TOO_SMALL)\n\t\treturn (error);\n\n\tmemset(SKEIN_CTX(ctx), 0, sizeof (*SKEIN_CTX(ctx)));\n\tkmem_free(SKEIN_CTX(ctx), sizeof (*(SKEIN_CTX(ctx))));\n\tSKEIN_CTX_LVALUE(ctx) = NULL;\n\n\treturn (error);\n}\n\n \nstatic int\nskein_digest_atomic(crypto_mechanism_t *mechanism, crypto_data_t *data,\n    crypto_data_t *digest)\n{\n\tint\t error;\n\tskein_ctx_t skein_ctx;\n\tcrypto_ctx_t ctx;\n\tSKEIN_CTX_LVALUE(&ctx) = &skein_ctx;\n\n\t \n\tif (!VALID_SKEIN_DIGEST_MECH(mechanism->cm_type))\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\tskein_ctx.sc_mech_type = mechanism->cm_type;\n\terror = skein_get_digest_bitlen(mechanism, &skein_ctx.sc_digest_bitlen);\n\tif (error != CRYPTO_SUCCESS)\n\t\tgoto out;\n\tSKEIN_OP(&skein_ctx, Init, skein_ctx.sc_digest_bitlen);\n\n\tif ((error = skein_update(&ctx, data)) != CRYPTO_SUCCESS)\n\t\tgoto out;\n\tif ((error = skein_final_nofree(&ctx, data)) != CRYPTO_SUCCESS)\n\t\tgoto out;\n\nout:\n\tif (error == CRYPTO_SUCCESS)\n\t\tdigest->cd_length =\n\t\t    CRYPTO_BITS2BYTES(skein_ctx.sc_digest_bitlen);\n\telse\n\t\tdigest->cd_length = 0;\n\tmemset(&skein_ctx, 0, sizeof (skein_ctx));\n\n\treturn (error);\n}\n\n \nstatic int\nskein_mac_ctx_build(skein_ctx_t *ctx, crypto_mechanism_t *mechanism,\n    crypto_key_t *key)\n{\n\tint error;\n\n\tif (!VALID_SKEIN_MAC_MECH(mechanism->cm_type))\n\t\treturn (CRYPTO_MECHANISM_INVALID);\n\tctx->sc_mech_type = mechanism->cm_type;\n\terror = skein_get_digest_bitlen(mechanism, &ctx->sc_digest_bitlen);\n\tif (error != CRYPTO_SUCCESS)\n\t\treturn (error);\n\tSKEIN_OP(ctx, InitExt, ctx->sc_digest_bitlen, 0, key->ck_data,\n\t    CRYPTO_BITS2BYTES(key->ck_length));\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \n \nstatic int\nskein_mac_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_spi_ctx_template_t ctx_template)\n{\n\tint\terror;\n\n\tSKEIN_CTX_LVALUE(ctx) = kmem_alloc(sizeof (*SKEIN_CTX(ctx)), KM_SLEEP);\n\tif (SKEIN_CTX(ctx) == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\tif (ctx_template != NULL) {\n\t\tmemcpy(SKEIN_CTX(ctx), ctx_template,\n\t\t    sizeof (*SKEIN_CTX(ctx)));\n\t} else {\n\t\terror = skein_mac_ctx_build(SKEIN_CTX(ctx), mechanism, key);\n\t\tif (error != CRYPTO_SUCCESS)\n\t\t\tgoto errout;\n\t}\n\n\treturn (CRYPTO_SUCCESS);\nerrout:\n\tmemset(SKEIN_CTX(ctx), 0, sizeof (*SKEIN_CTX(ctx)));\n\tkmem_free(SKEIN_CTX(ctx), sizeof (*SKEIN_CTX(ctx)));\n\treturn (error);\n}\n\n \n\n \nstatic int\nskein_mac_atomic(crypto_mechanism_t *mechanism,\n    crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,\n    crypto_spi_ctx_template_t ctx_template)\n{\n\t \n\tint\terror;\n\tcrypto_ctx_t ctx;\n\tskein_ctx_t skein_ctx;\n\tSKEIN_CTX_LVALUE(&ctx) = &skein_ctx;\n\n\tif (ctx_template != NULL) {\n\t\tmemcpy(&skein_ctx, ctx_template, sizeof (skein_ctx));\n\t} else {\n\t\terror = skein_mac_ctx_build(&skein_ctx, mechanism, key);\n\t\tif (error != CRYPTO_SUCCESS)\n\t\t\tgoto errout;\n\t}\n\n\tif ((error = skein_update(&ctx, data)) != CRYPTO_SUCCESS)\n\t\tgoto errout;\n\tif ((error = skein_final_nofree(&ctx, mac)) != CRYPTO_SUCCESS)\n\t\tgoto errout;\n\n\treturn (CRYPTO_SUCCESS);\nerrout:\n\tmemset(&skein_ctx, 0, sizeof (skein_ctx));\n\treturn (error);\n}\n\n \n\n \nstatic int\nskein_create_ctx_template(crypto_mechanism_t *mechanism, crypto_key_t *key,\n    crypto_spi_ctx_template_t *ctx_template, size_t *ctx_template_size)\n{\n\tint\t error;\n\tskein_ctx_t *ctx_tmpl;\n\n\tctx_tmpl = kmem_alloc(sizeof (*ctx_tmpl), KM_SLEEP);\n\tif (ctx_tmpl == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\terror = skein_mac_ctx_build(ctx_tmpl, mechanism, key);\n\tif (error != CRYPTO_SUCCESS)\n\t\tgoto errout;\n\t*ctx_template = ctx_tmpl;\n\t*ctx_template_size = sizeof (*ctx_tmpl);\n\n\treturn (CRYPTO_SUCCESS);\nerrout:\n\tmemset(ctx_tmpl, 0, sizeof (*ctx_tmpl));\n\tkmem_free(ctx_tmpl, sizeof (*ctx_tmpl));\n\treturn (error);\n}\n\n \nstatic int\nskein_free_context(crypto_ctx_t *ctx)\n{\n\tif (SKEIN_CTX(ctx) != NULL) {\n\t\tmemset(SKEIN_CTX(ctx), 0, sizeof (*SKEIN_CTX(ctx)));\n\t\tkmem_free(SKEIN_CTX(ctx), sizeof (*SKEIN_CTX(ctx)));\n\t\tSKEIN_CTX_LVALUE(ctx) = NULL;\n\t}\n\n\treturn (CRYPTO_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}