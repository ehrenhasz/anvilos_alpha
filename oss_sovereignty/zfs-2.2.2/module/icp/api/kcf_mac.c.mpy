{
  "module_name": "kcf_mac.c",
  "hash_id": "daa20de6f9352d5810486232e174440b3bd5f4f6f884e4ff52a593e0f8a8da4d",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/api/kcf_mac.c",
  "human_readable_source": " \n \n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n#include <sys/crypto/api.h>\n#include <sys/crypto/spi.h>\n#include <sys/crypto/sched_impl.h>\n\n \n\n \n\n \nint\ncrypto_mac(crypto_mechanism_t *mech, crypto_data_t *data,\n    crypto_key_t *key, crypto_ctx_template_t tmpl, crypto_data_t *mac)\n{\n\tint error;\n\tkcf_mech_entry_t *me;\n\tkcf_provider_desc_t *pd;\n\tkcf_ctx_template_t *ctx_tmpl;\n\tcrypto_spi_ctx_template_t spi_ctx_tmpl = NULL;\n\tkcf_prov_tried_t *list = NULL;\n\nretry:\n\t \n\tif ((pd = kcf_get_mech_provider(mech->cm_type, &me, &error,\n\t    list, CRYPTO_FG_MAC_ATOMIC)) == NULL) {\n\t\tif (list != NULL)\n\t\t\tkcf_free_triedlist(list);\n\t\treturn (error);\n\t}\n\n\tif (((ctx_tmpl = (kcf_ctx_template_t *)tmpl) != NULL))\n\t\tspi_ctx_tmpl = ctx_tmpl->ct_prov_tmpl;\n\n\tcrypto_mechanism_t lmech = *mech;\n\tKCF_SET_PROVIDER_MECHNUM(mech->cm_type, pd, &lmech);\n\terror = KCF_PROV_MAC_ATOMIC(pd, &lmech, key, data,\n\t    mac, spi_ctx_tmpl);\n\n\tif (error != CRYPTO_SUCCESS && IS_RECOVERABLE(error)) {\n\t\t \n\t\tif (kcf_insert_triedlist(&list, pd, KM_SLEEP) != NULL)\n\t\t\tgoto retry;\n\t}\n\n\tif (list != NULL)\n\t\tkcf_free_triedlist(list);\n\n\tKCF_PROV_REFRELE(pd);\n\treturn (error);\n}\n\n \nstatic int\ncrypto_mac_init_prov(kcf_provider_desc_t *pd,\n    crypto_mechanism_t *mech, crypto_key_t *key, crypto_spi_ctx_template_t tmpl,\n    crypto_context_t *ctxp)\n{\n\tint rv;\n\tcrypto_ctx_t *ctx;\n\tkcf_provider_desc_t *real_provider = pd;\n\n\tASSERT(KCF_PROV_REFHELD(pd));\n\n\t \n\tif ((ctx = kcf_new_ctx(real_provider)) == NULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\tcrypto_mechanism_t lmech = *mech;\n\tKCF_SET_PROVIDER_MECHNUM(mech->cm_type, real_provider, &lmech);\n\trv = KCF_PROV_MAC_INIT(real_provider, ctx, &lmech, key, tmpl);\n\n\tif (rv == CRYPTO_SUCCESS)\n\t\t*ctxp = (crypto_context_t)ctx;\n\telse {\n\t\t \n\t\tKCF_CONTEXT_REFRELE((kcf_context_t *)ctx->cc_framework_private);\n\t}\n\n\treturn (rv);\n}\n\n \nint\ncrypto_mac_init(crypto_mechanism_t *mech, crypto_key_t *key,\n    crypto_ctx_template_t tmpl, crypto_context_t *ctxp)\n{\n\tint error;\n\tkcf_mech_entry_t *me;\n\tkcf_provider_desc_t *pd;\n\tkcf_ctx_template_t *ctx_tmpl;\n\tcrypto_spi_ctx_template_t spi_ctx_tmpl = NULL;\n\tkcf_prov_tried_t *list = NULL;\n\nretry:\n\t \n\tif ((pd = kcf_get_mech_provider(mech->cm_type, &me, &error,\n\t    list, CRYPTO_FG_MAC)) == NULL) {\n\t\tif (list != NULL)\n\t\t\tkcf_free_triedlist(list);\n\t\treturn (error);\n\t}\n\n\t \n\n\tif (((ctx_tmpl = (kcf_ctx_template_t *)tmpl) != NULL))\n\t\tspi_ctx_tmpl = ctx_tmpl->ct_prov_tmpl;\n\n\terror = crypto_mac_init_prov(pd, mech, key,\n\t    spi_ctx_tmpl, ctxp);\n\tif (error != CRYPTO_SUCCESS && IS_RECOVERABLE(error)) {\n\t\t \n\t\tif (kcf_insert_triedlist(&list, pd, KM_SLEEP) != NULL)\n\t\t\tgoto retry;\n\t}\n\n\tif (list != NULL)\n\t\tkcf_free_triedlist(list);\n\n\tKCF_PROV_REFRELE(pd);\n\treturn (error);\n}\n\n \nint\ncrypto_mac_update(crypto_context_t context, crypto_data_t *data)\n{\n\tcrypto_ctx_t *ctx = (crypto_ctx_t *)context;\n\tkcf_context_t *kcf_ctx;\n\tkcf_provider_desc_t *pd;\n\n\tif ((ctx == NULL) ||\n\t    ((kcf_ctx = (kcf_context_t *)ctx->cc_framework_private) == NULL) ||\n\t    ((pd = kcf_ctx->kc_prov_desc) == NULL)) {\n\t\treturn (CRYPTO_INVALID_CONTEXT);\n\t}\n\n\treturn (KCF_PROV_MAC_UPDATE(pd, ctx, data));\n}\n\n \nint\ncrypto_mac_final(crypto_context_t context, crypto_data_t *mac)\n{\n\tcrypto_ctx_t *ctx = (crypto_ctx_t *)context;\n\tkcf_context_t *kcf_ctx;\n\tkcf_provider_desc_t *pd;\n\n\tif ((ctx == NULL) ||\n\t    ((kcf_ctx = (kcf_context_t *)ctx->cc_framework_private) == NULL) ||\n\t    ((pd = kcf_ctx->kc_prov_desc) == NULL)) {\n\t\treturn (CRYPTO_INVALID_CONTEXT);\n\t}\n\n\tint rv = KCF_PROV_MAC_FINAL(pd, ctx, mac);\n\n\t \n\tKCF_CONTEXT_COND_RELEASE(rv, kcf_ctx);\n\treturn (rv);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(crypto_mac);\nEXPORT_SYMBOL(crypto_mac_init);\nEXPORT_SYMBOL(crypto_mac_update);\nEXPORT_SYMBOL(crypto_mac_final);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}