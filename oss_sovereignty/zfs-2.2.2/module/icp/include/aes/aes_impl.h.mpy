{
  "module_name": "aes_impl.h",
  "hash_id": "030bb7b087982b09a96e52838b210ddbc218a5a9e0a924ee93aa399d1add8d71",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/include/aes/aes_impl.h",
  "human_readable_source": " \n \n\n#ifndef\t_AES_IMPL_H\n#define\t_AES_IMPL_H\n\n \n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/asm_linkage.h>\n\n \n#define\tIS_P2ALIGNED2(v, w, a) \\\n\t((((uintptr_t)(v) | (uintptr_t)(w)) & ((uintptr_t)(a) - 1)) == 0)\n\n#define\tAES_BLOCK_LEN\t16\t \n \n#define\tRC_LENGTH\t(5 * ((AES_BLOCK_LEN) / 4 - 2))\n\n#define\tAES_COPY_BLOCK(src, dst) \\\n\t(dst)[0] = (src)[0]; \\\n\t(dst)[1] = (src)[1]; \\\n\t(dst)[2] = (src)[2]; \\\n\t(dst)[3] = (src)[3]; \\\n\t(dst)[4] = (src)[4]; \\\n\t(dst)[5] = (src)[5]; \\\n\t(dst)[6] = (src)[6]; \\\n\t(dst)[7] = (src)[7]; \\\n\t(dst)[8] = (src)[8]; \\\n\t(dst)[9] = (src)[9]; \\\n\t(dst)[10] = (src)[10]; \\\n\t(dst)[11] = (src)[11]; \\\n\t(dst)[12] = (src)[12]; \\\n\t(dst)[13] = (src)[13]; \\\n\t(dst)[14] = (src)[14]; \\\n\t(dst)[15] = (src)[15]\n\n#define\tAES_XOR_BLOCK(src, dst) \\\n\t(dst)[0] ^= (src)[0]; \\\n\t(dst)[1] ^= (src)[1]; \\\n\t(dst)[2] ^= (src)[2]; \\\n\t(dst)[3] ^= (src)[3]; \\\n\t(dst)[4] ^= (src)[4]; \\\n\t(dst)[5] ^= (src)[5]; \\\n\t(dst)[6] ^= (src)[6]; \\\n\t(dst)[7] ^= (src)[7]; \\\n\t(dst)[8] ^= (src)[8]; \\\n\t(dst)[9] ^= (src)[9]; \\\n\t(dst)[10] ^= (src)[10]; \\\n\t(dst)[11] ^= (src)[11]; \\\n\t(dst)[12] ^= (src)[12]; \\\n\t(dst)[13] ^= (src)[13]; \\\n\t(dst)[14] ^= (src)[14]; \\\n\t(dst)[15] ^= (src)[15]\n\n \n#define\tAES_MINBITS\t\t128\n#define\tAES_MAXBITS\t\t256\n\n \n#define\tAES_32BIT_KS\t\t32\n#define\tAES_64BIT_KS\t\t64\n\n#define\tMAX_AES_NR\t\t14  \n#define\tMAX_AES_NB\t\t4   \n\ntypedef union {\n#ifdef\tsun4u\n\tuint64_t\tks64[((MAX_AES_NR) + 1) * (MAX_AES_NB)];\n#endif\n\tuint32_t\tks32[((MAX_AES_NR) + 1) * (MAX_AES_NB)];\n} aes_ks_t;\n\ntypedef struct aes_impl_ops aes_impl_ops_t;\n\n \ntypedef struct aes_key aes_key_t;\nstruct aes_key {\n\taes_ks_t\tencr_ks;   \n\taes_ks_t\tdecr_ks;   \n#ifdef __amd64\n\tlong double\talign128;  \n#endif\t \n\tconst aes_impl_ops_t\t*ops;\t \n\tint\t\tnr;\t   \n\tint\t\ttype;\t   \n};\n\n \nextern void *aes_alloc_keysched(size_t *size, int kmflag);\nextern void aes_init_keysched(const uint8_t *cipherKey, uint_t keyBits,\n\tvoid *keysched);\nextern int aes_encrypt_block(const void *ks, const uint8_t *pt, uint8_t *ct);\nextern int aes_decrypt_block(const void *ks, const uint8_t *ct, uint8_t *pt);\n\n \nextern void aes_copy_block(uint8_t *in, uint8_t *out);\nextern void aes_xor_block(uint8_t *data, uint8_t *dst);\n\n \nextern int aes_encrypt_contiguous_blocks(void *ctx, char *data, size_t length,\n    crypto_data_t *out);\nextern int aes_decrypt_contiguous_blocks(void *ctx, char *data, size_t length,\n    crypto_data_t *out);\n\n \n#ifdef _AES_IMPL\n\ntypedef enum aes_mech_type {\n\tAES_ECB_MECH_INFO_TYPE,\t\t \n\tAES_CBC_MECH_INFO_TYPE,\t\t \n\tAES_CBC_PAD_MECH_INFO_TYPE,\t \n\tAES_CTR_MECH_INFO_TYPE,\t\t \n\tAES_CCM_MECH_INFO_TYPE,\t\t \n\tAES_GCM_MECH_INFO_TYPE,\t\t \n\tAES_GMAC_MECH_INFO_TYPE\t\t \n} aes_mech_type_t;\n\n#endif  \n\n \ntypedef void \t\t(*aes_generate_f)(aes_key_t *, const uint32_t *, int);\ntypedef void\t\t(*aes_encrypt_f)(const uint32_t[], int,\n    const uint32_t[4], uint32_t[4]);\ntypedef void\t\t(*aes_decrypt_f)(const uint32_t[], int,\n    const uint32_t[4], uint32_t[4]);\ntypedef boolean_t\t(*aes_will_work_f)(void);\n\n#define\tAES_IMPL_NAME_MAX (16)\n\nstruct aes_impl_ops {\n\taes_generate_f generate;\n\taes_encrypt_f encrypt;\n\taes_decrypt_f decrypt;\n\taes_will_work_f is_supported;\n\tboolean_t needs_byteswap;\n\tchar name[AES_IMPL_NAME_MAX];\n};\n\nextern const aes_impl_ops_t aes_generic_impl;\n#if defined(__x86_64)\nextern const aes_impl_ops_t aes_x86_64_impl;\n\n \nextern ASMABI int rijndael_key_setup_enc_amd64(uint32_t rk[],\n\tconst uint32_t cipherKey[], int keyBits);\nextern ASMABI int rijndael_key_setup_dec_amd64(uint32_t rk[],\n\tconst uint32_t cipherKey[], int keyBits);\nextern ASMABI void aes_encrypt_amd64(const uint32_t rk[], int Nr,\n\tconst uint32_t pt[4], uint32_t ct[4]);\nextern ASMABI void aes_decrypt_amd64(const uint32_t rk[], int Nr,\n\tconst uint32_t ct[4], uint32_t pt[4]);\n#endif\n#if defined(__x86_64) && defined(HAVE_AES)\nextern const aes_impl_ops_t aes_aesni_impl;\n#endif\n\n \nvoid aes_impl_init(void);\n\n \nconst struct aes_impl_ops *aes_impl_get_ops(void);\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}