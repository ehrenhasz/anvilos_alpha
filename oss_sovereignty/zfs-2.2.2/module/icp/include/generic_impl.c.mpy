{
  "module_name": "generic_impl.c",
  "hash_id": "6e26bd41c910a386a8ee62b5f7e49f59f4768cd8f79e254e76150215b1ef0be7",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/include/generic_impl.c",
  "human_readable_source": " \n\n \n\n \n\n#include <sys/zfs_context.h>\n#include <sys/zio_checksum.h>\n#include <sys/zfs_impl.h>\n\n \n#define\tIMPL_FASTEST\t(UINT32_MAX)\n#define\tIMPL_CYCLE\t(UINT32_MAX - 1)\n\n#define\tIMPL_READ(i)\t(*(volatile uint32_t *) &(i))\n\n \nstatic IMPL_OPS_T generic_fastest_impl = {\n\t.name = \"fastest\"\n};\n\n \nstatic const IMPL_OPS_T *generic_supp_impls[ARRAY_SIZE(IMPL_ARRAY)];\nstatic uint32_t generic_supp_impls_cnt = 0;\n\n \nstatic uint32_t generic_impl_chosen = IMPL_FASTEST;\n\nstatic struct generic_impl_selector {\n\tconst char *name;\n\tuint32_t sel;\n} generic_impl_selectors[] = {\n\t{ \"cycle\",\tIMPL_CYCLE },\n\t{ \"fastest\",\tIMPL_FASTEST }\n};\n\n \nstatic void\ngeneric_impl_init(void)\n{\n\tint i, c;\n\n\t \n\tif (likely(generic_supp_impls_cnt != 0))\n\t\treturn;\n\n\t \n\tfor (i = 0, c = 0; i < ARRAY_SIZE(IMPL_ARRAY); i++) {\n\t\tconst IMPL_OPS_T *impl = IMPL_ARRAY[i];\n\n\t\tif (impl->is_supported && impl->is_supported())\n\t\t\tgeneric_supp_impls[c++] = impl;\n\t}\n\tgeneric_supp_impls_cnt = c;\n\n\t \n\tmemcpy(&generic_fastest_impl, generic_supp_impls[0],\n\t    sizeof (generic_fastest_impl));\n}\n\n \nstatic uint32_t\ngeneric_impl_getcnt(void)\n{\n\tgeneric_impl_init();\n\treturn (generic_supp_impls_cnt);\n}\n\n \nstatic uint32_t\ngeneric_impl_getid(void)\n{\n\tgeneric_impl_init();\n\treturn (IMPL_READ(generic_impl_chosen));\n}\n\n \nstatic const char *\ngeneric_impl_getname(void)\n{\n\tuint32_t impl = IMPL_READ(generic_impl_chosen);\n\n\tgeneric_impl_init();\n\tswitch (impl) {\n\tcase IMPL_FASTEST:\n\t\treturn (\"fastest\");\n\tcase IMPL_CYCLE:\n\t\treturn (\"cycle\");\n\tdefault:\n\t\treturn (generic_supp_impls[impl]->name);\n\t}\n}\n\n \nstatic void\ngeneric_impl_setid(uint32_t id)\n{\n\tgeneric_impl_init();\n\tswitch (id) {\n\tcase IMPL_FASTEST:\n\t\tatomic_swap_32(&generic_impl_chosen, IMPL_FASTEST);\n\t\tbreak;\n\tcase IMPL_CYCLE:\n\t\tatomic_swap_32(&generic_impl_chosen, IMPL_CYCLE);\n\t\tbreak;\n\tdefault:\n\t\tASSERT3U(id, <, generic_supp_impls_cnt);\n\t\tatomic_swap_32(&generic_impl_chosen, id);\n\t\tbreak;\n\t}\n}\n\n \nstatic int\ngeneric_impl_setname(const char *val)\n{\n\tuint32_t impl = IMPL_READ(generic_impl_chosen);\n\tsize_t val_len;\n\tint i, err = -EINVAL;\n\n\tgeneric_impl_init();\n\tval_len = strlen(val);\n\twhile ((val_len > 0) && !!isspace(val[val_len-1]))  \n\t\tval_len--;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(generic_impl_selectors); i++) {\n\t\tconst char *name = generic_impl_selectors[i].name;\n\n\t\tif (val_len == strlen(name) &&\n\t\t    strncmp(val, name, val_len) == 0) {\n\t\t\timpl = generic_impl_selectors[i].sel;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (err != 0) {\n\t\tfor (i = 0; i < generic_supp_impls_cnt; i++) {\n\t\t\tconst char *name = generic_supp_impls[i]->name;\n\n\t\t\tif (val_len == strlen(name) &&\n\t\t\t    strncmp(val, name, val_len) == 0) {\n\t\t\t\timpl = i;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err == 0) {\n\t\tatomic_swap_32(&generic_impl_chosen, impl);\n\t}\n\n\treturn (err);\n}\n\n \nstatic void\ngeneric_impl_set_fastest(uint32_t id)\n{\n\tgeneric_impl_init();\n\tmemcpy(&generic_fastest_impl, generic_supp_impls[id],\n\t    sizeof (generic_fastest_impl));\n}\n\n \nconst zfs_impl_t ZFS_IMPL_OPS = {\n\t.name = IMPL_NAME,\n\t.getcnt = generic_impl_getcnt,\n\t.getid = generic_impl_getid,\n\t.getname = generic_impl_getname,\n\t.set_fastest = generic_impl_set_fastest,\n\t.setid = generic_impl_setid,\n\t.setname = generic_impl_setname\n};\n\n \nconst IMPL_OPS_T *\nIMPL_GET_OPS(void)\n{\n\tconst IMPL_OPS_T *ops = NULL;\n\tuint32_t idx, impl = IMPL_READ(generic_impl_chosen);\n\tstatic uint32_t cycle_count = 0;\n\n\tgeneric_impl_init();\n\tswitch (impl) {\n\tcase IMPL_FASTEST:\n\t\tops = &generic_fastest_impl;\n\t\tbreak;\n\tcase IMPL_CYCLE:\n\t\tidx = (++cycle_count) % generic_supp_impls_cnt;\n\t\tops = generic_supp_impls[idx];\n\t\tbreak;\n\tdefault:\n\t\tASSERT3U(impl, <, generic_supp_impls_cnt);\n\t\tops = generic_supp_impls[impl];\n\t\tbreak;\n\t}\n\n\tASSERT3P(ops, !=, NULL);\n\treturn (ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}