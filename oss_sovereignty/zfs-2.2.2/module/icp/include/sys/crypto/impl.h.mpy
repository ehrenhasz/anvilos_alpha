{
  "module_name": "impl.h",
  "hash_id": "02e770461ac7c147da76aea1326902203e76629ff120ae2bfe1807c6cabd7402",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/include/sys/crypto/impl.h",
  "human_readable_source": " \n \n\n#ifndef\t_SYS_CRYPTO_IMPL_H\n#define\t_SYS_CRYPTO_IMPL_H\n\n \n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/api.h>\n#include <sys/crypto/spi.h>\n#include <sys/avl.h>\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n \n\n\n \n#define\tKCF_OPS_CLASSSIZE\t4\n#define\tKCF_MAXMECHTAB\t\t32\n\n \ntypedef enum {\n\tKCF_PROV_ALLOCATED = 1,\n\t \n\tKCF_PROV_READY,\n\t \n\tKCF_PROV_FAILED,\n\t \n\tKCF_PROV_DISABLED,\n\tKCF_PROV_REMOVED,\n\tKCF_PROV_FREED\n} kcf_prov_state_t;\n\n#define\tKCF_IS_PROV_USABLE(pd) ((pd)->pd_state == KCF_PROV_READY)\n#define\tKCF_IS_PROV_REMOVED(pd)\t((pd)->pd_state >= KCF_PROV_REMOVED)\n\n \ntypedef struct kcf_provider_desc {\n\tuint_t\t\t\t\tpd_refcnt;\n\tuint_t\t\t\t\tpd_irefcnt;\n\tkmutex_t\t\t\tpd_lock;\n\tkcf_prov_state_t\t\tpd_state;\n\tconst crypto_ops_t\t\t\t*pd_ops_vector;\n\tushort_t\t\t\tpd_mech_indx[KCF_OPS_CLASSSIZE]\\\n\t\t\t\t\t    [KCF_MAXMECHTAB];\n\tconst crypto_mech_info_t\t\t*pd_mechanisms;\n\tuint_t\t\t\t\tpd_mech_list_count;\n\tkcondvar_t\t\t\tpd_remove_cv;\n\tconst char\t\t\t\t*pd_description;\n\tcrypto_kcf_provider_handle_t\tpd_kcf_prov_handle;\n\tcrypto_provider_id_t\t\tpd_prov_id;\n} kcf_provider_desc_t;\n\n \n#define\tKCF_PROV_REFHOLD(desc) {\t\t\t\t\\\n\tint newval = atomic_add_32_nv(&(desc)->pd_refcnt, 1);\t\\\n\tASSERT(newval != 0);\t\t\t\t\t\\\n}\n\n#define\tKCF_PROV_IREFHOLD(desc) {\t\t\t\t\\\n\tint newval = atomic_add_32_nv(&(desc)->pd_irefcnt, 1);\t\\\n\tASSERT(newval != 0);\t\t\t\t\t\\\n}\n\n#define\tKCF_PROV_IREFRELE(desc) {\t\t\t\t\\\n\tmembar_producer();\t\t\t\t\t\\\n\tint newval = atomic_add_32_nv(&(desc)->pd_irefcnt, -1);\t\\\n\tASSERT(newval != -1);\t\t\t\t\t\\\n\tif (newval == 0) {\t\t\t\t\t\\\n\t\tcv_broadcast(&(desc)->pd_remove_cv);\t\t\\\n\t}\t\t\t\t\t\t\t\\\n}\n\n#define\tKCF_PROV_REFHELD(desc)\t((desc)->pd_refcnt >= 1)\n\n#define\tKCF_PROV_REFRELE(desc) {\t\t\t\t\\\n\tmembar_producer();\t\t\t\t\t\\\n\tint newval = atomic_add_32_nv(&(desc)->pd_refcnt, -1);\t\\\n\tASSERT(newval != -1);\t\t\t\t\t\\\n\tif (newval == 0) {\t\t\t\t\t\\\n\t\tkcf_provider_zero_refcnt((desc));\t\t\\\n\t}\t\t\t\t\t\t\t\\\n}\n\n\n \n\ntypedef struct kcf_prov_mech_desc {\n\tstruct kcf_mech_entry\t\t*pm_me;\t\t \n\tstruct kcf_prov_mech_desc\t*pm_next;\t \n\tcrypto_mech_info_t\t\tpm_mech_info;\t \n\tkcf_provider_desc_t\t\t*pm_prov_desc;\t \n} kcf_prov_mech_desc_t;\n\n \ntypedef\tstruct kcf_mech_entry {\n\tcrypto_mech_name_t\tme_name;\t \n\tcrypto_mech_type_t\tme_mechid;\t \n\tkcf_prov_mech_desc_t\t*me_sw_prov;     \n\tavl_node_t\tme_node;\n} kcf_mech_entry_t;\n\n \n#define\tKCF_POLICY_REFHOLD(desc) {\t\t\t\t\\\n\tint newval = atomic_add_32_nv(&(desc)->pd_refcnt, 1);\t\\\n\tASSERT(newval != 0);\t\t\t\t\t\\\n}\n\n \n#define\tKCF_POLICY_REFRELE(desc) {\t\t\t\t\\\n\tmembar_producer();\t\t\t\t\t\\\n\tint newval = atomic_add_32_nv(&(desc)->pd_refcnt, -1);\t\\\n\tASSERT(newval != -1);\t\t\t\t\t\\\n\tif (newval == 0)\t\t\t\t\t\\\n\t\tkcf_policy_free_desc(desc);\t\t\t\\\n}\n\n \n\n#define\tKCF_MAXDIGEST\t\t16\t \n#define\tKCF_MAXCIPHER\t\t32\t \n#define\tKCF_MAXMAC\t\t40\t \n\n_Static_assert(KCF_MAXCIPHER == KCF_MAXMECHTAB,\n\t\"KCF_MAXCIPHER != KCF_MAXMECHTAB\");\t \n\ntypedef\tenum {\n\tKCF_DIGEST_CLASS = 1,\n\tKCF_CIPHER_CLASS,\n\tKCF_MAC_CLASS,\n} kcf_ops_class_t;\n\n#define\tKCF_FIRST_OPSCLASS\tKCF_DIGEST_CLASS\n#define\tKCF_LAST_OPSCLASS\tKCF_MAC_CLASS\n_Static_assert(\n    KCF_OPS_CLASSSIZE == (KCF_LAST_OPSCLASS - KCF_FIRST_OPSCLASS + 2),\n\t\"KCF_OPS_CLASSSIZE doesn't match kcf_ops_class_t!\");\n\n \n\ntypedef\tstruct kcf_mech_entry_tab {\n\tint\t\t\tmet_size;\t \n\tkcf_mech_entry_t\t*met_tab;\t \n} kcf_mech_entry_tab_t;\n\nextern const kcf_mech_entry_tab_t kcf_mech_tabs_tab[];\n\n#define\tKCF_MECHID(class, index)\t\t\t\t\\\n\t(((crypto_mech_type_t)(class) << 32) | (crypto_mech_type_t)(index))\n\n#define\tKCF_MECH2CLASS(mech_type) ((kcf_ops_class_t)((mech_type) >> 32))\n\n#define\tKCF_MECH2INDEX(mech_type) ((int)((mech_type) & 0xFFFFFFFF))\n\n#define\tKCF_TO_PROV_MECH_INDX(pd, mech_type) \t\t\t\\\n\t((pd)->pd_mech_indx[KCF_MECH2CLASS(mech_type)] \t\t\\\n\t[KCF_MECH2INDEX(mech_type)])\n\n#define\tKCF_TO_PROV_MECHINFO(pd, mech_type)\t\t\t\\\n\t((pd)->pd_mechanisms[KCF_TO_PROV_MECH_INDX(pd, mech_type)])\n\n#define\tKCF_TO_PROV_MECHNUM(pd, mech_type)\t\t\t\\\n\t(KCF_TO_PROV_MECHINFO(pd, mech_type).cm_mech_number)\n\n \n#define\tKCF_SUCCESS\t\t0x0\t \n#define\tKCF_INVALID_MECH_NUMBER\t0x1\t \n#define\tKCF_INVALID_MECH_NAME\t0x2\t \n#define\tKCF_INVALID_MECH_CLASS\t0x3\t \n#define\tKCF_MECH_TAB_FULL\t0x4\t \n#define\tKCF_INVALID_INDX\t((ushort_t)-1)\n\n \n\n#define\tKCF_PROV_DIGEST_OPS(pd)\t\t((pd)->pd_ops_vector->co_digest_ops)\n#define\tKCF_PROV_CIPHER_OPS(pd)\t\t((pd)->pd_ops_vector->co_cipher_ops)\n#define\tKCF_PROV_MAC_OPS(pd)\t\t((pd)->pd_ops_vector->co_mac_ops)\n#define\tKCF_PROV_CTX_OPS(pd)\t\t((pd)->pd_ops_vector->co_ctx_ops)\n\n \n\n#define\tKCF_PROV_DIGEST_INIT(pd, ctx, mech) ( \\\n\t(KCF_PROV_DIGEST_OPS(pd) && KCF_PROV_DIGEST_OPS(pd)->digest_init) ? \\\n\tKCF_PROV_DIGEST_OPS(pd)->digest_init(ctx, mech) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n \n\n#define\tKCF_PROV_ENCRYPT_INIT(pd, ctx, mech, key, template) ( \\\n\t(KCF_PROV_CIPHER_OPS(pd) && KCF_PROV_CIPHER_OPS(pd)->encrypt_init) ? \\\n\tKCF_PROV_CIPHER_OPS(pd)->encrypt_init(ctx, mech, key, template) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n#define\tKCF_PROV_ENCRYPT_ATOMIC(pd, mech, key, plaintext, ciphertext, \\\n\t    template) ( \\\n\t(KCF_PROV_CIPHER_OPS(pd) && KCF_PROV_CIPHER_OPS(pd)->encrypt_atomic) ? \\\n\tKCF_PROV_CIPHER_OPS(pd)->encrypt_atomic( \\\n\t    mech, key, plaintext, ciphertext, template) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n#define\tKCF_PROV_DECRYPT_ATOMIC(pd, mech, key, ciphertext, plaintext, \\\n\t    template) ( \\\n\t(KCF_PROV_CIPHER_OPS(pd) && KCF_PROV_CIPHER_OPS(pd)->decrypt_atomic) ? \\\n\tKCF_PROV_CIPHER_OPS(pd)->decrypt_atomic( \\\n\t    mech, key, ciphertext, plaintext, template) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n \n\n#define\tKCF_PROV_MAC_INIT(pd, ctx, mech, key, template) ( \\\n\t(KCF_PROV_MAC_OPS(pd) && KCF_PROV_MAC_OPS(pd)->mac_init) ? \\\n\tKCF_PROV_MAC_OPS(pd)->mac_init(ctx, mech, key, template) \\\n\t: CRYPTO_NOT_SUPPORTED)\n\n \n#define\tKCF_PROV_MAC_UPDATE(pd, ctx, data) ( \\\n\t(KCF_PROV_MAC_OPS(pd) && KCF_PROV_MAC_OPS(pd)->mac_update) ? \\\n\tKCF_PROV_MAC_OPS(pd)->mac_update(ctx, data) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n#define\tKCF_PROV_MAC_FINAL(pd, ctx, mac) ( \\\n\t(KCF_PROV_MAC_OPS(pd) && KCF_PROV_MAC_OPS(pd)->mac_final) ? \\\n\tKCF_PROV_MAC_OPS(pd)->mac_final(ctx, mac) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n#define\tKCF_PROV_MAC_ATOMIC(pd, mech, key, data, mac, template) ( \\\n\t(KCF_PROV_MAC_OPS(pd) && KCF_PROV_MAC_OPS(pd)->mac_atomic) ? \\\n\tKCF_PROV_MAC_OPS(pd)->mac_atomic( \\\n\t    mech, key, data, mac, template) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n \n\n#define\tKCF_PROV_CREATE_CTX_TEMPLATE(pd, mech, key, template, size) ( \\\n\t(KCF_PROV_CTX_OPS(pd) && KCF_PROV_CTX_OPS(pd)->create_ctx_template) ? \\\n\tKCF_PROV_CTX_OPS(pd)->create_ctx_template( \\\n\t    mech, key, template, size) : \\\n\tCRYPTO_NOT_SUPPORTED)\n\n#define\tKCF_PROV_FREE_CONTEXT(pd, ctx) ( \\\n\t(KCF_PROV_CTX_OPS(pd) && KCF_PROV_CTX_OPS(pd)->free_context) ? \\\n\tKCF_PROV_CTX_OPS(pd)->free_context(ctx) : CRYPTO_NOT_SUPPORTED)\n\n\n \nextern void kcf_destroy_mech_tabs(void);\nextern void kcf_init_mech_tabs(void);\nextern int kcf_add_mech_provider(short, kcf_provider_desc_t *,\n    kcf_prov_mech_desc_t **);\nextern void kcf_remove_mech_provider(const char *, kcf_provider_desc_t *);\nextern int kcf_get_mech_entry(crypto_mech_type_t, kcf_mech_entry_t **);\nextern kcf_provider_desc_t *kcf_alloc_provider_desc(void);\nextern void kcf_provider_zero_refcnt(kcf_provider_desc_t *);\nextern void kcf_free_provider_desc(kcf_provider_desc_t *);\nextern void undo_register_provider(kcf_provider_desc_t *, boolean_t);\nextern int crypto_put_output_data(uchar_t *, crypto_data_t *, int);\nextern int crypto_update_iov(void *, crypto_data_t *, crypto_data_t *,\n    int (*cipher)(void *, caddr_t, size_t, crypto_data_t *));\nextern int crypto_update_uio(void *, crypto_data_t *, crypto_data_t *,\n    int (*cipher)(void *, caddr_t, size_t, crypto_data_t *));\n\n \nextern void kcf_prov_tab_destroy(void);\nextern void kcf_prov_tab_init(void);\nextern int kcf_prov_tab_add_provider(kcf_provider_desc_t *);\nextern int kcf_prov_tab_rem_provider(crypto_provider_id_t);\nextern kcf_provider_desc_t *kcf_prov_tab_lookup(crypto_provider_id_t);\nextern int kcf_get_sw_prov(crypto_mech_type_t, kcf_provider_desc_t **,\n    kcf_mech_entry_t **, boolean_t);\n\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}