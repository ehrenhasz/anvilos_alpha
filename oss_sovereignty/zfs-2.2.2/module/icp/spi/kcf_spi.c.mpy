{
  "module_name": "kcf_spi.c",
  "hash_id": "fe5fcd819b122cab835899845719ac51677b1e2a76a805e3e103cf389d46a818",
  "original_prompt": "Ingested from zfs-2.2.2/module/icp/spi/kcf_spi.c",
  "human_readable_source": " \n \n\n \n\n\n#include <sys/zfs_context.h>\n#include <sys/crypto/common.h>\n#include <sys/crypto/impl.h>\n#include <sys/crypto/sched_impl.h>\n#include <sys/crypto/spi.h>\n\nstatic int init_prov_mechs(const crypto_provider_info_t *,\n    kcf_provider_desc_t *);\n\n \nint\ncrypto_register_provider(const crypto_provider_info_t *info,\n    crypto_kcf_provider_handle_t *handle)\n{\n\tkcf_provider_desc_t *prov_desc = NULL;\n\tint ret = CRYPTO_ARGUMENTS_BAD;\n\n\t \n\tprov_desc = kcf_alloc_provider_desc();\n\tKCF_PROV_REFHOLD(prov_desc);\n\n\t \n\tprov_desc->pd_description = info->pi_provider_description;\n\n\t \n\tprov_desc->pd_ops_vector = info->pi_ops_vector;\n\n\t \n\tif ((ret = init_prov_mechs(info, prov_desc)) != CRYPTO_SUCCESS)\n\t\tgoto bail;\n\n\t \n\tif ((ret = kcf_prov_tab_add_provider(prov_desc)) != CRYPTO_SUCCESS) {\n\t\tundo_register_provider(prov_desc, B_FALSE);\n\t\tgoto bail;\n\t}\n\n\t \n\n\tmutex_enter(&prov_desc->pd_lock);\n\tprov_desc->pd_state = KCF_PROV_READY;\n\tmutex_exit(&prov_desc->pd_lock);\n\n\t*handle = prov_desc->pd_kcf_prov_handle;\n\tret = CRYPTO_SUCCESS;\n\nbail:\n\tKCF_PROV_REFRELE(prov_desc);\n\treturn (ret);\n}\n\n \nint\ncrypto_unregister_provider(crypto_kcf_provider_handle_t handle)\n{\n\tuint_t mech_idx;\n\tkcf_provider_desc_t *desc;\n\tkcf_prov_state_t saved_state;\n\n\t \n\tif ((desc = kcf_prov_tab_lookup((crypto_provider_id_t)handle)) == NULL)\n\t\treturn (CRYPTO_UNKNOWN_PROVIDER);\n\n\tmutex_enter(&desc->pd_lock);\n\t \n\tif (desc->pd_state >= KCF_PROV_DISABLED) {\n\t\tmutex_exit(&desc->pd_lock);\n\t\t \n\t\tKCF_PROV_REFRELE(desc);\n\t\treturn (CRYPTO_BUSY);\n\t}\n\n\tsaved_state = desc->pd_state;\n\tdesc->pd_state = KCF_PROV_REMOVED;\n\n\t \n\tif (desc->pd_refcnt > desc->pd_irefcnt + 1) {\n\t\tdesc->pd_state = saved_state;\n\t\tmutex_exit(&desc->pd_lock);\n\t\t \n\t\tKCF_PROV_REFRELE(desc);\n\t\t \n\t\treturn (CRYPTO_BUSY);\n\t}\n\tmutex_exit(&desc->pd_lock);\n\n\t \n\tfor (mech_idx = 0; mech_idx < desc->pd_mech_list_count;\n\t    mech_idx++) {\n\t\tkcf_remove_mech_provider(\n\t\t    desc->pd_mechanisms[mech_idx].cm_mech_name, desc);\n\t}\n\n\t \n\tif (kcf_prov_tab_rem_provider((crypto_provider_id_t)handle) !=\n\t    CRYPTO_SUCCESS) {\n\t\t \n\t\tKCF_PROV_REFRELE(desc);\n\t\treturn (CRYPTO_UNKNOWN_PROVIDER);\n\t}\n\n\t \n\tKCF_PROV_REFRELE(desc);\n\n\t \n\tmutex_enter(&desc->pd_lock);\n\twhile (desc->pd_state != KCF_PROV_FREED)\n\t\tcv_wait(&desc->pd_remove_cv, &desc->pd_lock);\n\tmutex_exit(&desc->pd_lock);\n\n\t \n\tASSERT(desc->pd_state == KCF_PROV_FREED &&\n\t    desc->pd_refcnt == 0);\n\tkcf_free_provider_desc(desc);\n\n\treturn (CRYPTO_SUCCESS);\n}\n\n \nstatic int\ninit_prov_mechs(const crypto_provider_info_t *info, kcf_provider_desc_t *desc)\n{\n\tuint_t mech_idx;\n\tuint_t cleanup_idx;\n\tint err = CRYPTO_SUCCESS;\n\tkcf_prov_mech_desc_t *pmd;\n\tint desc_use_count = 0;\n\n\t \n\tif (info != NULL) {\n\t\tASSERT(info->pi_mechanisms != NULL);\n\t\tdesc->pd_mech_list_count = info->pi_mech_list_count;\n\t\tdesc->pd_mechanisms = info->pi_mechanisms;\n\t}\n\n\t \n\tfor (mech_idx = 0; mech_idx < desc->pd_mech_list_count; mech_idx++) {\n\t\tif ((err = kcf_add_mech_provider(mech_idx, desc, &pmd)) !=\n\t\t    KCF_SUCCESS)\n\t\t\tbreak;\n\n\t\tif (pmd == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tdesc_use_count++;\n\t}\n\n\t \n\tif (desc_use_count == 0)\n\t\treturn (CRYPTO_ARGUMENTS_BAD);\n\n\tif (err == KCF_SUCCESS)\n\t\treturn (CRYPTO_SUCCESS);\n\n\t \n\tfor (cleanup_idx = 0; cleanup_idx < mech_idx; cleanup_idx++) {\n\t\tkcf_remove_mech_provider(\n\t\t    desc->pd_mechanisms[cleanup_idx].cm_mech_name, desc);\n\t}\n\n\tif (err == KCF_MECH_TAB_FULL)\n\t\treturn (CRYPTO_HOST_MEMORY);\n\n\treturn (CRYPTO_ARGUMENTS_BAD);\n}\n\n \nvoid\nundo_register_provider(kcf_provider_desc_t *desc, boolean_t remove_prov)\n{\n\tuint_t mech_idx;\n\n\t \n\tfor (mech_idx = 0; mech_idx < desc->pd_mech_list_count;\n\t    mech_idx++) {\n\t\tkcf_remove_mech_provider(\n\t\t    desc->pd_mechanisms[mech_idx].cm_mech_name, desc);\n\t}\n\n\t \n\tif (remove_prov)\n\t\t(void) kcf_prov_tab_rem_provider(desc->pd_prov_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}