{
  "module_name": "zprop_common.c",
  "hash_id": "a5ab48fdb98457df4bd74fd78882f1979dc531ff03bf0c1b4e4c95aa12f57d57",
  "original_prompt": "Ingested from zfs-2.2.2/module/zcommon/zprop_common.c",
  "human_readable_source": " \n \n \n\n \n\n#include <sys/zio.h>\n#include <sys/spa.h>\n#include <sys/zfs_acl.h>\n#include <sys/zfs_ioctl.h>\n#include <sys/zfs_sysfs.h>\n#include <sys/zfs_znode.h>\n#include <sys/fs/zfs.h>\n\n#include \"zfs_prop.h\"\n#include \"zfs_deleg.h\"\n\n#if !defined(_KERNEL)\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#endif\n\nstatic zprop_desc_t *\nzprop_get_proptable(zfs_type_t type)\n{\n\tif (type == ZFS_TYPE_POOL)\n\t\treturn (zpool_prop_get_table());\n\telse if (type == ZFS_TYPE_VDEV)\n\t\treturn (vdev_prop_get_table());\n\telse\n\t\treturn (zfs_prop_get_table());\n}\n\nstatic int\nzprop_get_numprops(zfs_type_t type)\n{\n\tif (type == ZFS_TYPE_POOL)\n\t\treturn (ZPOOL_NUM_PROPS);\n\telse if (type == ZFS_TYPE_VDEV)\n\t\treturn (VDEV_NUM_PROPS);\n\telse\n\t\treturn (ZFS_NUM_PROPS);\n}\n\nstatic boolean_t\nzfs_mod_supported_prop(const char *name, zfs_type_t type,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n \n#if defined(_KERNEL) || defined(LIB_ZPOOL_BUILD) || defined(__FreeBSD__)\n\t(void) name, (void) type, (void) sfeatures;\n\treturn (B_TRUE);\n#else\n\treturn (zfs_mod_supported(type == ZFS_TYPE_POOL ?\n\t    ZFS_SYSFS_POOL_PROPERTIES : (type == ZFS_TYPE_VDEV ?\n\t    ZFS_SYSFS_VDEV_PROPERTIES : ZFS_SYSFS_DATASET_PROPERTIES),\n\t    name, sfeatures));\n#endif\n}\n\nvoid\nzprop_register_impl(int prop, const char *name, zprop_type_t type,\n    uint64_t numdefault, const char *strdefault, zprop_attr_t attr,\n    int objset_types, const char *values, const char *colname,\n    boolean_t rightalign, boolean_t visible, boolean_t flex,\n    const zprop_index_t *idx_tbl,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\tzprop_desc_t *prop_tbl = zprop_get_proptable(objset_types);\n\tzprop_desc_t *pd;\n\n\tpd = &prop_tbl[prop];\n\n\tASSERT(pd->pd_name == NULL || pd->pd_name == name);\n\tASSERT(name != NULL);\n\tASSERT(colname != NULL);\n\n\tpd->pd_name = name;\n\tpd->pd_propnum = prop;\n\tpd->pd_proptype = type;\n\tpd->pd_numdefault = numdefault;\n\tpd->pd_strdefault = strdefault;\n\tpd->pd_attr = attr;\n\tpd->pd_types = objset_types;\n\tpd->pd_values = values;\n\tpd->pd_colname = colname;\n\tpd->pd_rightalign = rightalign;\n\tpd->pd_visible = visible;\n\tpd->pd_zfs_mod_supported =\n\t    zfs_mod_supported_prop(name, objset_types, sfeatures);\n\tpd->pd_always_flex = flex;\n\tpd->pd_table = idx_tbl;\n\tpd->pd_table_size = 0;\n\twhile (idx_tbl && (idx_tbl++)->pi_name != NULL)\n\t\tpd->pd_table_size++;\n}\n\nvoid\nzprop_register_string(int prop, const char *name, const char *def,\n    zprop_attr_t attr, int objset_types, const char *values,\n    const char *colname, const struct zfs_mod_supported_features *sfeatures)\n{\n\tzprop_register_impl(prop, name, PROP_TYPE_STRING, 0, def, attr,\n\t    objset_types, values, colname, B_FALSE, B_TRUE, B_TRUE, NULL,\n\t    sfeatures);\n\n}\n\nvoid\nzprop_register_number(int prop, const char *name, uint64_t def,\n    zprop_attr_t attr, int objset_types, const char *values,\n    const char *colname, boolean_t flex,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\tzprop_register_impl(prop, name, PROP_TYPE_NUMBER, def, NULL, attr,\n\t    objset_types, values, colname, B_TRUE, B_TRUE, flex, NULL,\n\t    sfeatures);\n}\n\nvoid\nzprop_register_index(int prop, const char *name, uint64_t def,\n    zprop_attr_t attr, int objset_types, const char *values,\n    const char *colname, const zprop_index_t *idx_tbl,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\tzprop_register_impl(prop, name, PROP_TYPE_INDEX, def, NULL, attr,\n\t    objset_types, values, colname, B_FALSE, B_TRUE, B_TRUE, idx_tbl,\n\t    sfeatures);\n}\n\nvoid\nzprop_register_hidden(int prop, const char *name, zprop_type_t type,\n    zprop_attr_t attr, int objset_types, const char *colname, boolean_t flex,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\tzprop_register_impl(prop, name, type, 0, NULL, attr,\n\t    objset_types, NULL, colname,\n\t    type == PROP_TYPE_NUMBER, B_FALSE, flex, NULL, sfeatures);\n}\n\n\n \nstatic int\nzprop_compare(const void *arg1, const void *arg2)\n{\n\tconst zprop_desc_t *p1 = *((zprop_desc_t **)arg1);\n\tconst zprop_desc_t *p2 = *((zprop_desc_t **)arg2);\n\tboolean_t p1ro, p2ro;\n\n\tp1ro = (p1->pd_attr == PROP_READONLY);\n\tp2ro = (p2->pd_attr == PROP_READONLY);\n\n\tif (p1ro == p2ro)\n\t\treturn (strcmp(p1->pd_name, p2->pd_name));\n\n\treturn (p1ro ? -1 : 1);\n}\n\n \nint\nzprop_iter_common(zprop_func func, void *cb, boolean_t show_all,\n    boolean_t ordered, zfs_type_t type)\n{\n\tint i, num_props, size, prop;\n\tzprop_desc_t *prop_tbl;\n\tzprop_desc_t **order;\n\n\tprop_tbl = zprop_get_proptable(type);\n\tnum_props = zprop_get_numprops(type);\n\tsize = num_props * sizeof (zprop_desc_t *);\n\n#if defined(_KERNEL)\n\torder = kmem_alloc(size, KM_SLEEP);\n#else\n\tif ((order = malloc(size)) == NULL)\n\t\treturn (ZPROP_CONT);\n#endif\n\n\tfor (int j = 0; j < num_props; j++)\n\t\torder[j] = &prop_tbl[j];\n\n\tif (ordered) {\n\t\tqsort((void *)order, num_props, sizeof (zprop_desc_t *),\n\t\t    zprop_compare);\n\t}\n\n\tprop = ZPROP_CONT;\n\tfor (i = 0; i < num_props; i++) {\n\t\tif ((order[i]->pd_visible || show_all) &&\n\t\t    order[i]->pd_zfs_mod_supported &&\n\t\t    (func(order[i]->pd_propnum, cb) != ZPROP_CONT)) {\n\t\t\tprop = order[i]->pd_propnum;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if defined(_KERNEL)\n\tkmem_free(order, size);\n#else\n\tfree(order);\n#endif\n\treturn (prop);\n}\n\nstatic boolean_t\npropname_match(const char *p, size_t len, zprop_desc_t *prop_entry)\n{\n\tconst char *propname = prop_entry->pd_name;\n#ifndef _KERNEL\n\tconst char *colname = prop_entry->pd_colname;\n\tint c;\n#endif\n\n\tASSERT(propname != NULL);\n\n\tif (len == strlen(propname) &&\n\t    strncmp(p, propname, len) == 0)\n\t\treturn (B_TRUE);\n\n#ifndef _KERNEL\n\tif (colname == NULL || len != strlen(colname))\n\t\treturn (B_FALSE);\n\n\tfor (c = 0; c < len; c++)\n\t\tif (p[c] != tolower(colname[c]))\n\t\t\tbreak;\n\n\treturn (colname[c] == '\\0');\n#else\n\treturn (B_FALSE);\n#endif\n}\n\ntypedef struct name_to_prop_cb {\n\tconst char *propname;\n\tzprop_desc_t *prop_tbl;\n} name_to_prop_cb_t;\n\nstatic int\nzprop_name_to_prop_cb(int prop, void *cb_data)\n{\n\tname_to_prop_cb_t *data = cb_data;\n\n\tif (propname_match(data->propname, strlen(data->propname),\n\t    &data->prop_tbl[prop]))\n\t\treturn (prop);\n\n\treturn (ZPROP_CONT);\n}\n\nint\nzprop_name_to_prop(const char *propname, zfs_type_t type)\n{\n\tint prop;\n\tname_to_prop_cb_t cb_data;\n\n\tcb_data.propname = propname;\n\tcb_data.prop_tbl = zprop_get_proptable(type);\n\n\tprop = zprop_iter_common(zprop_name_to_prop_cb, &cb_data,\n\t    B_TRUE, B_FALSE, type);\n\n\treturn (prop == ZPROP_CONT ? ZPROP_INVAL : prop);\n}\n\nint\nzprop_string_to_index(int prop, const char *string, uint64_t *index,\n    zfs_type_t type)\n{\n\tzprop_desc_t *prop_tbl;\n\tconst zprop_index_t *idx_tbl;\n\tint i;\n\n\tif (prop == ZPROP_INVAL || prop == ZPROP_CONT)\n\t\treturn (-1);\n\n\tASSERT(prop < zprop_get_numprops(type));\n\tprop_tbl = zprop_get_proptable(type);\n\tif ((idx_tbl = prop_tbl[prop].pd_table) == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; idx_tbl[i].pi_name != NULL; i++) {\n\t\tif (strcmp(string, idx_tbl[i].pi_name) == 0) {\n\t\t\t*index = idx_tbl[i].pi_value;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (-1);\n}\n\nint\nzprop_index_to_string(int prop, uint64_t index, const char **string,\n    zfs_type_t type)\n{\n\tzprop_desc_t *prop_tbl;\n\tconst zprop_index_t *idx_tbl;\n\tint i;\n\n\tif (prop == ZPROP_INVAL || prop == ZPROP_CONT)\n\t\treturn (-1);\n\n\tASSERT(prop < zprop_get_numprops(type));\n\tprop_tbl = zprop_get_proptable(type);\n\tif ((idx_tbl = prop_tbl[prop].pd_table) == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; idx_tbl[i].pi_name != NULL; i++) {\n\t\tif (idx_tbl[i].pi_value == index) {\n\t\t\t*string = idx_tbl[i].pi_name;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (-1);\n}\n\n \nuint64_t\nzprop_random_value(int prop, uint64_t seed, zfs_type_t type)\n{\n\tzprop_desc_t *prop_tbl;\n\tconst zprop_index_t *idx_tbl;\n\n\tASSERT((uint_t)prop < zprop_get_numprops(type));\n\tprop_tbl = zprop_get_proptable(type);\n\tidx_tbl = prop_tbl[prop].pd_table;\n\n\tif (idx_tbl == NULL)\n\t\treturn (seed);\n\n\treturn (idx_tbl[seed % prop_tbl[prop].pd_table_size].pi_value);\n}\n\nconst char *\nzprop_values(int prop, zfs_type_t type)\n{\n\tzprop_desc_t *prop_tbl;\n\n\tASSERT(prop != ZPROP_INVAL && prop != ZPROP_CONT);\n\tASSERT(prop < zprop_get_numprops(type));\n\n\tprop_tbl = zprop_get_proptable(type);\n\n\treturn (prop_tbl[prop].pd_values);\n}\n\n \nboolean_t\nzprop_valid_for_type(int prop, zfs_type_t type, boolean_t headcheck)\n{\n\tzprop_desc_t *prop_tbl;\n\n\tif (prop == ZPROP_INVAL || prop == ZPROP_CONT)\n\t\treturn (B_FALSE);\n\n\tASSERT(prop < zprop_get_numprops(type));\n\tprop_tbl = zprop_get_proptable(type);\n\tif (headcheck && prop_tbl[prop].pd_types == ZFS_TYPE_SNAPSHOT)\n\t\treturn (B_TRUE);\n\treturn ((prop_tbl[prop].pd_types & type) != 0);\n}\n\n \nint\nzprop_valid_char(char c)\n{\n\treturn ((c >= 'a' && c <= 'z') ||\n\t    (c >= '0' && c <= '9') ||\n\t    c == '-' || c == '_' || c == '.' || c == ':');\n}\n\n#ifndef _KERNEL\n\n \nsize_t\nzprop_width(int prop, boolean_t *fixed, zfs_type_t type)\n{\n\tzprop_desc_t *prop_tbl, *pd;\n\tconst zprop_index_t *idx;\n\tsize_t ret;\n\tint i;\n\n\tASSERT(prop != ZPROP_INVAL && prop != ZPROP_CONT);\n\tASSERT(prop < zprop_get_numprops(type));\n\n\tprop_tbl = zprop_get_proptable(type);\n\tpd = &prop_tbl[prop];\n\n\tif (type != ZFS_TYPE_POOL && type != ZFS_TYPE_VDEV)\n\t\ttype = ZFS_TYPE_FILESYSTEM;\n\n\t*fixed = !pd->pd_always_flex;\n\n\t \n\tret = strlen(pd->pd_colname);\n\n\t \n\tswitch (pd->pd_proptype) {\n\tcase PROP_TYPE_NUMBER:\n\t\t \n\t\tif (ret < 5)\n\t\t\tret = 5;\n\t\t \n\t\tif (type == ZFS_TYPE_POOL && prop == ZPOOL_PROP_HEALTH)\n\t\t\tret = 8;\n\t\tbreak;\n\n\tcase PROP_TYPE_INDEX:\n\t\tidx = prop_tbl[prop].pd_table;\n\t\tfor (i = 0; idx[i].pi_name != NULL; i++) {\n\t\t\tif (strlen(idx[i].pi_name) > ret)\n\t\t\t\tret = strlen(idx[i].pi_name);\n\t\t}\n\t\tbreak;\n\n\tcase PROP_TYPE_STRING:\n\t\tbreak;\n\t}\n\n\treturn (ret);\n}\n\n#endif\n\n#if defined(_KERNEL)\n \nEXPORT_SYMBOL(zprop_register_impl);\nEXPORT_SYMBOL(zprop_register_string);\nEXPORT_SYMBOL(zprop_register_number);\nEXPORT_SYMBOL(zprop_register_index);\nEXPORT_SYMBOL(zprop_register_hidden);\n\n \nEXPORT_SYMBOL(zprop_iter_common);\nEXPORT_SYMBOL(zprop_name_to_prop);\nEXPORT_SYMBOL(zprop_string_to_index);\nEXPORT_SYMBOL(zprop_index_to_string);\nEXPORT_SYMBOL(zprop_random_value);\nEXPORT_SYMBOL(zprop_values);\nEXPORT_SYMBOL(zprop_valid_for_type);\nEXPORT_SYMBOL(zprop_valid_char);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}