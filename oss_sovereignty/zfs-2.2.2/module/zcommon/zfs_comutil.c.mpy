{
  "module_name": "zfs_comutil.c",
  "hash_id": "9b41937b6b64b2124f09b7936dab955de7dae5cceed5c37542bc31e1e424a6c0",
  "original_prompt": "Ingested from zfs-2.2.2/module/zcommon/zfs_comutil.c",
  "human_readable_source": " \n \n\n \n\n#if !defined(_KERNEL)\n#include <string.h>\n#endif\n\n#include <sys/types.h>\n#include <sys/fs/zfs.h>\n#include <sys/nvpair.h>\n#include \"zfs_comutil.h\"\n#include <sys/zfs_ratelimit.h>\n\n \nboolean_t\nzfs_allocatable_devs(nvlist_t *nv)\n{\n\tuint64_t is_log;\n\tuint_t c;\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\t\treturn (B_FALSE);\n\t}\n\tfor (c = 0; c < children; c++) {\n\t\tis_log = 0;\n\t\t(void) nvlist_lookup_uint64(child[c], ZPOOL_CONFIG_IS_LOG,\n\t\t    &is_log);\n\t\tif (!is_log)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\n \nboolean_t\nzfs_special_devs(nvlist_t *nv, const char *type)\n{\n\tconst char *bias;\n\tuint_t c;\n\tnvlist_t **child;\n\tuint_t children;\n\n\tif (nvlist_lookup_nvlist_array(nv, ZPOOL_CONFIG_CHILDREN,\n\t    &child, &children) != 0) {\n\t\treturn (B_FALSE);\n\t}\n\tfor (c = 0; c < children; c++) {\n\t\tif (nvlist_lookup_string(child[c], ZPOOL_CONFIG_ALLOCATION_BIAS,\n\t\t    &bias) == 0) {\n\t\t\tif (strcmp(bias, VDEV_ALLOC_BIAS_SPECIAL) == 0 ||\n\t\t\t    strcmp(bias, VDEV_ALLOC_BIAS_DEDUP) == 0) {\n\t\t\t\tif (type == NULL ||\n\t\t\t\t    (type != NULL && strcmp(bias, type) == 0))\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\treturn (B_FALSE);\n}\n\nvoid\nzpool_get_load_policy(nvlist_t *nvl, zpool_load_policy_t *zlpp)\n{\n\tnvlist_t *policy;\n\tnvpair_t *elem;\n\tconst char *nm;\n\n\t \n\tzlpp->zlp_rewind = ZPOOL_NO_REWIND;\n\tzlpp->zlp_maxmeta = 0;\n\tzlpp->zlp_maxdata = UINT64_MAX;\n\tzlpp->zlp_txg = UINT64_MAX;\n\n\tif (nvl == NULL)\n\t\treturn;\n\n\telem = NULL;\n\twhile ((elem = nvlist_next_nvpair(nvl, elem)) != NULL) {\n\t\tnm = nvpair_name(elem);\n\t\tif (strcmp(nm, ZPOOL_LOAD_POLICY) == 0) {\n\t\t\tif (nvpair_value_nvlist(elem, &policy) == 0)\n\t\t\t\tzpool_get_load_policy(policy, zlpp);\n\t\t\treturn;\n\t\t} else if (strcmp(nm, ZPOOL_LOAD_REWIND_POLICY) == 0) {\n\t\t\tif (nvpair_value_uint32(elem, &zlpp->zlp_rewind) == 0)\n\t\t\t\tif (zlpp->zlp_rewind & ~ZPOOL_REWIND_POLICIES)\n\t\t\t\t\tzlpp->zlp_rewind = ZPOOL_NO_REWIND;\n\t\t} else if (strcmp(nm, ZPOOL_LOAD_REQUEST_TXG) == 0) {\n\t\t\t(void) nvpair_value_uint64(elem, &zlpp->zlp_txg);\n\t\t} else if (strcmp(nm, ZPOOL_LOAD_META_THRESH) == 0) {\n\t\t\t(void) nvpair_value_uint64(elem, &zlpp->zlp_maxmeta);\n\t\t} else if (strcmp(nm, ZPOOL_LOAD_DATA_THRESH) == 0) {\n\t\t\t(void) nvpair_value_uint64(elem, &zlpp->zlp_maxdata);\n\t\t}\n\t}\n\tif (zlpp->zlp_rewind == 0)\n\t\tzlpp->zlp_rewind = ZPOOL_NO_REWIND;\n}\n\ntypedef struct zfs_version_spa_map {\n\tint\tversion_zpl;\n\tint\tversion_spa;\n} zfs_version_spa_map_t;\n\n \nstatic zfs_version_spa_map_t zfs_version_table[] = {\n\t{ZPL_VERSION_INITIAL, SPA_VERSION_INITIAL},\n\t{ZPL_VERSION_DIRENT_TYPE, SPA_VERSION_INITIAL},\n\t{ZPL_VERSION_FUID, SPA_VERSION_FUID},\n\t{ZPL_VERSION_USERSPACE, SPA_VERSION_USERSPACE},\n\t{ZPL_VERSION_SA, SPA_VERSION_SA},\n\t{0, 0}\n};\n\n \nint\nzfs_zpl_version_map(int spa_version)\n{\n\tint version = -1;\n\n\tfor (int i = 0; zfs_version_table[i].version_spa; i++)\n\t\tif (spa_version >= zfs_version_table[i].version_spa)\n\t\t\tversion = zfs_version_table[i].version_zpl;\n\n\treturn (version);\n}\n\n \nint\nzfs_spa_version_map(int zpl_version)\n{\n\tfor (int i = 0; zfs_version_table[i].version_zpl; i++)\n\t\tif (zfs_version_table[i].version_zpl >= zpl_version)\n\t\t\treturn (zfs_version_table[i].version_spa);\n\n\treturn (-1);\n}\n\n \nconst char *const zfs_history_event_names[ZFS_NUM_LEGACY_HISTORY_EVENTS] = {\n\t\"invalid event\",\n\t\"pool create\",\n\t\"vdev add\",\n\t\"pool remove\",\n\t\"pool destroy\",\n\t\"pool export\",\n\t\"pool import\",\n\t\"vdev attach\",\n\t\"vdev replace\",\n\t\"vdev detach\",\n\t\"vdev online\",\n\t\"vdev offline\",\n\t\"vdev upgrade\",\n\t\"pool clear\",\n\t\"pool scrub\",\n\t\"pool property set\",\n\t\"create\",\n\t\"clone\",\n\t\"destroy\",\n\t\"destroy_begin_sync\",\n\t\"inherit\",\n\t\"property set\",\n\t\"quota set\",\n\t\"permission update\",\n\t\"permission remove\",\n\t\"permission who remove\",\n\t\"promote\",\n\t\"receive\",\n\t\"rename\",\n\t\"reservation set\",\n\t\"replay_inc_sync\",\n\t\"replay_full_sync\",\n\t\"rollback\",\n\t\"snapshot\",\n\t\"filesystem version upgrade\",\n\t\"refquota set\",\n\t\"refreservation set\",\n\t\"pool scrub done\",\n\t\"user hold\",\n\t\"user release\",\n\t\"pool split\",\n};\n\nboolean_t\nzfs_dataset_name_hidden(const char *name)\n{\n\t \n\tif (strpbrk(name, \"$%\") != NULL)\n\t\treturn (B_TRUE);\n\tif (!INGLOBALZONE(curproc) && !zone_dataset_visible(name, NULL))\n\t\treturn (B_TRUE);\n\treturn (B_FALSE);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zfs_allocatable_devs);\nEXPORT_SYMBOL(zfs_special_devs);\nEXPORT_SYMBOL(zpool_get_load_policy);\nEXPORT_SYMBOL(zfs_zpl_version_map);\nEXPORT_SYMBOL(zfs_spa_version_map);\nEXPORT_SYMBOL(zfs_history_event_names);\nEXPORT_SYMBOL(zfs_dataset_name_hidden);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}