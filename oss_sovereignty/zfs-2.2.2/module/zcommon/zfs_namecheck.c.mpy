{
  "module_name": "zfs_namecheck.c",
  "hash_id": "637cf00e9b98314d0e4758a440f03fc5a9378ba294a85076935c41e4a35b04a0",
  "original_prompt": "Ingested from zfs-2.2.2/module/zcommon/zfs_namecheck.c",
  "human_readable_source": " \n \n \n\n \n\n#if !defined(_KERNEL)\n#include <string.h>\n#endif\n\n#include <sys/dsl_dir.h>\n#include <sys/param.h>\n#include <sys/nvpair.h>\n#include \"zfs_namecheck.h\"\n#include \"zfs_deleg.h\"\n\n \nint zfs_max_dataset_nesting = 50;\n\nstatic int\nvalid_char(char c)\n{\n\treturn ((c >= 'a' && c <= 'z') ||\n\t    (c >= 'A' && c <= 'Z') ||\n\t    (c >= '0' && c <= '9') ||\n\t    c == '-' || c == '_' || c == '.' || c == ':' || c == ' ');\n}\n\n \nint\nget_dataset_depth(const char *path)\n{\n\tconst char *loc = path;\n\tint nesting = 0;\n\n\t \n\tfor (int i = 0; loc[i] != '\\0' &&\n\t    loc[i] != '@' &&\n\t    loc[i] != '#'; i++) {\n\t\tif (loc[i] == '/')\n\t\t\tnesting++;\n\t}\n\n\treturn (nesting);\n}\n\n \nint\nzfs_component_namecheck(const char *path, namecheck_err_t *why, char *what)\n{\n\tconst char *loc;\n\n\tif (strlen(path) >= ZFS_MAX_DATASET_NAME_LEN) {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_TOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (path[0] == '\\0') {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_EMPTY_COMPONENT;\n\t\treturn (-1);\n\t}\n\n\tfor (loc = path; *loc; loc++) {\n\t\tif (!valid_char(*loc)) {\n\t\t\tif (why) {\n\t\t\t\t*why = NAME_ERR_INVALCHAR;\n\t\t\t\t*what = *loc;\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (0);\n}\n\n\n \nint\npermset_namecheck(const char *path, namecheck_err_t *why, char *what)\n{\n\tif (strlen(path) >= ZFS_PERMSET_MAXLEN) {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_TOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (path[0] != '@') {\n\t\tif (why) {\n\t\t\t*why = NAME_ERR_NO_AT;\n\t\t\t*what = path[0];\n\t\t}\n\t\treturn (-1);\n\t}\n\n\treturn (zfs_component_namecheck(&path[1], why, what));\n}\n\n \nint\ndataset_nestcheck(const char *path)\n{\n\treturn ((get_dataset_depth(path) < zfs_max_dataset_nesting) ? 0 : -1);\n}\n\n \nint\nentity_namecheck(const char *path, namecheck_err_t *why, char *what)\n{\n\tconst char *end;\n\n\tEQUIV(why == NULL, what == NULL);\n\n\t \n\tif (strlen(path) >= ZFS_MAX_DATASET_NAME_LEN) {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_TOOLONG;\n\t\treturn (-1);\n\t}\n\n\t \n\tif (path[0] == '/') {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_LEADING_SLASH;\n\t\treturn (-1);\n\t}\n\n\tif (path[0] == '\\0') {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_EMPTY_COMPONENT;\n\t\treturn (-1);\n\t}\n\n\tconst char *start = path;\n\tboolean_t found_delim = B_FALSE;\n\tfor (;;) {\n\t\t \n\t\tend = start;\n\t\twhile (*end != '/' && *end != '@' && *end != '#' &&\n\t\t    *end != '\\0')\n\t\t\tend++;\n\n\t\tif (*end == '\\0' && end[-1] == '/') {\n\t\t\t \n\t\t\tif (why)\n\t\t\t\t*why = NAME_ERR_TRAILING_SLASH;\n\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\tfor (const char *loc = start; loc != end; loc++) {\n\t\t\tif (!valid_char(*loc) && *loc != '%') {\n\t\t\t\tif (why) {\n\t\t\t\t\t*why = NAME_ERR_INVALCHAR;\n\t\t\t\t\t*what = *loc;\n\t\t\t\t}\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\n\t\tif (*end == '\\0' || *end == '/') {\n\t\t\tint component_length = end - start;\n\t\t\t \n\t\t\tif (component_length == 1) {\n\t\t\t\tif (start[0] == '.') {\n\t\t\t\t\tif (why)\n\t\t\t\t\t\t*why = NAME_ERR_SELF_REF;\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (component_length == 2) {\n\t\t\t\tif (start[0] == '.' && start[1] == '.') {\n\t\t\t\t\tif (why)\n\t\t\t\t\t\t*why = NAME_ERR_PARENT_REF;\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (*end == '@' || *end == '#') {\n\t\t\t \n\t\t\tif (found_delim != 0) {\n\t\t\t\tif (why)\n\t\t\t\t\t*why = NAME_ERR_MULTIPLE_DELIMITERS;\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tfound_delim = B_TRUE;\n\t\t}\n\n\t\t \n\t\tif (start == end) {\n\t\t\tif (why)\n\t\t\t\t*why = NAME_ERR_EMPTY_COMPONENT;\n\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\tif (*end == '\\0')\n\t\t\treturn (0);\n\n\t\t \n\t\tif (*end == '/' && found_delim != 0) {\n\t\t\tif (why)\n\t\t\t\t*why = NAME_ERR_TRAILING_SLASH;\n\t\t\treturn (-1);\n\t\t}\n\n\t\t \n\t\tstart = end + 1;\n\t}\n}\n\n \nint\ndataset_namecheck(const char *path, namecheck_err_t *why, char *what)\n{\n\tint ret = entity_namecheck(path, why, what);\n\n\tif (ret == 0 && strchr(path, '#') != NULL) {\n\t\tif (why != NULL) {\n\t\t\t*why = NAME_ERR_INVALCHAR;\n\t\t\t*what = '#';\n\t\t}\n\t\treturn (-1);\n\t}\n\n\treturn (ret);\n}\n\n \nint\nbookmark_namecheck(const char *path, namecheck_err_t *why, char *what)\n{\n\tint ret = entity_namecheck(path, why, what);\n\n\tif (ret == 0 && strchr(path, '#') == NULL) {\n\t\tif (why != NULL) {\n\t\t\t*why = NAME_ERR_NO_POUND;\n\t\t\t*what = '#';\n\t\t}\n\t\treturn (-1);\n\t}\n\n\treturn (ret);\n}\n\n \nint\nsnapshot_namecheck(const char *path, namecheck_err_t *why, char *what)\n{\n\tint ret = entity_namecheck(path, why, what);\n\n\tif (ret == 0 && strchr(path, '@') == NULL) {\n\t\tif (why != NULL) {\n\t\t\t*why = NAME_ERR_NO_AT;\n\t\t\t*what = '@';\n\t\t}\n\t\treturn (-1);\n\t}\n\n\treturn (ret);\n}\n\n \nint\nmountpoint_namecheck(const char *path, namecheck_err_t *why)\n{\n\tconst char *start, *end;\n\n\t \n\n\tif (path == NULL || *path != '/') {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_LEADING_SLASH;\n\t\treturn (-1);\n\t}\n\n\t \n\tstart = &path[1];\n\tdo {\n\t\tend = start;\n\t\twhile (*end != '/' && *end != '\\0')\n\t\t\tend++;\n\n\t\tif (end - start >= ZFS_MAX_DATASET_NAME_LEN) {\n\t\t\tif (why)\n\t\t\t\t*why = NAME_ERR_TOOLONG;\n\t\t\treturn (-1);\n\t\t}\n\t\tstart = end + 1;\n\n\t} while (*end != '\\0');\n\n\treturn (0);\n}\n\n \nint\npool_namecheck(const char *pool, namecheck_err_t *why, char *what)\n{\n\tconst char *c;\n\n\t \n\tif (strlen(pool) >= (ZFS_MAX_DATASET_NAME_LEN - 2 -\n\t    strlen(ORIGIN_DIR_NAME) * 2)) {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_TOOLONG;\n\t\treturn (-1);\n\t}\n\n\tc = pool;\n\twhile (*c != '\\0') {\n\t\tif (!valid_char(*c)) {\n\t\t\tif (why) {\n\t\t\t\t*why = NAME_ERR_INVALCHAR;\n\t\t\t\t*what = *c;\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\t\tc++;\n\t}\n\n\tif (!(*pool >= 'a' && *pool <= 'z') &&\n\t    !(*pool >= 'A' && *pool <= 'Z')) {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_NOLETTER;\n\t\treturn (-1);\n\t}\n\n\tif (strcmp(pool, \"mirror\") == 0 ||\n\t    strcmp(pool, \"raidz\") == 0 ||\n\t    strcmp(pool, \"draid\") == 0) {\n\t\tif (why)\n\t\t\t*why = NAME_ERR_RESERVED;\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nEXPORT_SYMBOL(entity_namecheck);\nEXPORT_SYMBOL(pool_namecheck);\nEXPORT_SYMBOL(dataset_namecheck);\nEXPORT_SYMBOL(bookmark_namecheck);\nEXPORT_SYMBOL(snapshot_namecheck);\nEXPORT_SYMBOL(zfs_component_namecheck);\nEXPORT_SYMBOL(dataset_nestcheck);\nEXPORT_SYMBOL(get_dataset_depth);\nEXPORT_SYMBOL(zfs_max_dataset_nesting);\n\nZFS_MODULE_PARAM(zfs, zfs_, max_dataset_nesting, INT, ZMOD_RW,\n\t\"Limit to the amount of nesting a path can have. Defaults to 50.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}