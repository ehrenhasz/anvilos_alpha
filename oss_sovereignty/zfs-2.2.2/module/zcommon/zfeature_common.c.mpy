{
  "module_name": "zfeature_common.c",
  "hash_id": "91dc88137c11fde9edd856c988a0bf17b0a44c9a9a3505fcb54bde7740ee50d7",
  "original_prompt": "Ingested from zfs-2.2.2/module/zcommon/zfeature_common.c",
  "human_readable_source": " \n\n \n\n#ifndef _KERNEL\n#include <errno.h>\n#include <string.h>\n#include <dirent.h>\n#include <search.h>\n#include <sys/stat.h>\n#endif\n#include <sys/debug.h>\n#include <sys/fs/zfs.h>\n#include <sys/inttypes.h>\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/zfs_sysfs.h>\n#include \"zfeature_common.h\"\n\n \nboolean_t zfeature_checks_disable = B_FALSE;\n\nzfeature_info_t spa_feature_table[SPA_FEATURES];\n\n \nstatic int\nvalid_char(char c, boolean_t after_colon)\n{\n\treturn ((c >= 'a' && c <= 'z') ||\n\t    (c >= '0' && c <= '9') ||\n\t    (after_colon && c == '_') ||\n\t    (!after_colon && (c == '.' || c == '-')));\n}\n\n \nboolean_t\nzfeature_is_valid_guid(const char *name)\n{\n\tint i;\n\tboolean_t has_colon = B_FALSE;\n\n\ti = 0;\n\twhile (name[i] != '\\0') {\n\t\tchar c = name[i++];\n\t\tif (c == ':') {\n\t\t\tif (has_colon)\n\t\t\t\treturn (B_FALSE);\n\t\t\thas_colon = B_TRUE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!valid_char(c, has_colon))\n\t\t\treturn (B_FALSE);\n\t}\n\n\treturn (has_colon);\n}\n\nboolean_t\nzfeature_is_supported(const char *guid)\n{\n\tif (zfeature_checks_disable)\n\t\treturn (B_TRUE);\n\n\tfor (spa_feature_t i = 0; i < SPA_FEATURES; i++) {\n\t\tzfeature_info_t *feature = &spa_feature_table[i];\n\t\tif (!feature->fi_zfs_mod_supported)\n\t\t\tcontinue;\n\t\tif (strcmp(guid, feature->fi_guid) == 0)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\nint\nzfeature_lookup_guid(const char *guid, spa_feature_t *res)\n{\n\tfor (spa_feature_t i = 0; i < SPA_FEATURES; i++) {\n\t\tzfeature_info_t *feature = &spa_feature_table[i];\n\t\tif (!feature->fi_zfs_mod_supported)\n\t\t\tcontinue;\n\t\tif (strcmp(guid, feature->fi_guid) == 0) {\n\t\t\tif (res != NULL)\n\t\t\t\t*res = i;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (ENOENT);\n}\n\nint\nzfeature_lookup_name(const char *name, spa_feature_t *res)\n{\n\tfor (spa_feature_t i = 0; i < SPA_FEATURES; i++) {\n\t\tzfeature_info_t *feature = &spa_feature_table[i];\n\t\tif (!feature->fi_zfs_mod_supported)\n\t\t\tcontinue;\n\t\tif (strcmp(name, feature->fi_uname) == 0) {\n\t\t\tif (res != NULL)\n\t\t\t\t*res = i;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (ENOENT);\n}\n\nboolean_t\nzfeature_depends_on(spa_feature_t fid, spa_feature_t check)\n{\n\tzfeature_info_t *feature = &spa_feature_table[fid];\n\n\tfor (int i = 0; feature->fi_depends[i] != SPA_FEATURE_NONE; i++) {\n\t\tif (feature->fi_depends[i] == check)\n\t\t\treturn (B_TRUE);\n\t}\n\treturn (B_FALSE);\n}\n\nstatic boolean_t\ndeps_contains_feature(const spa_feature_t *deps, const spa_feature_t feature)\n{\n\tfor (int i = 0; deps[i] != SPA_FEATURE_NONE; i++)\n\t\tif (deps[i] == feature)\n\t\t\treturn (B_TRUE);\n\n\treturn (B_FALSE);\n}\n\n#define\tSTRCMP ((int(*)(const void *, const void *))&strcmp)\nstruct zfs_mod_supported_features {\n\tvoid *tree;\n\tboolean_t all_features;\n};\n\nstruct zfs_mod_supported_features *\nzfs_mod_list_supported(const char *scope)\n{\n#if defined(__FreeBSD__) || defined(_KERNEL) || defined(LIB_ZPOOL_BUILD)\n\t(void) scope;\n\treturn (NULL);\n#else\n\tstruct zfs_mod_supported_features *ret = calloc(1, sizeof (*ret));\n\tif (ret == NULL)\n\t\treturn (NULL);\n\n\tDIR *sysfs_dir = NULL;\n\tchar path[128];\n\n\tif (snprintf(path, sizeof (path), \"%s/%s\",\n\t    ZFS_SYSFS_DIR, scope) < sizeof (path))\n\t\tsysfs_dir = opendir(path);\n\tif (sysfs_dir == NULL && errno == ENOENT) {\n\t\tif (snprintf(path, sizeof (path), \"%s/%s\",\n\t\t    ZFS_SYSFS_ALT_DIR, scope) < sizeof (path))\n\t\t\tsysfs_dir = opendir(path);\n\t}\n\tif (sysfs_dir == NULL) {\n\t\tret->all_features = errno == ENOENT &&\n\t\t    (access(ZFS_SYSFS_DIR, F_OK) == 0 ||\n\t\t    access(ZFS_SYSFS_ALT_DIR, F_OK) == 0);\n\t\treturn (ret);\n\t}\n\n\tstruct dirent *node;\n\twhile ((node = readdir(sysfs_dir)) != NULL) {\n\t\tif (strcmp(node->d_name, \".\") == 0 ||\n\t\t    strcmp(node->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\tchar *name = strdup(node->d_name);\n\t\tif (name == NULL) {\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tif (tsearch(name, &ret->tree, STRCMP) == NULL) {\n\t\t\t \n\t\t\tfree(name);\n\t\t\tgoto nomem;\n\t\t}\n\t}\n\nend:\n\tclosedir(sysfs_dir);\n\treturn (ret);\n\nnomem:\n\tzfs_mod_list_supported_free(ret);\n\tret = NULL;\n\tgoto end;\n#endif\n}\n\nvoid\nzfs_mod_list_supported_free(struct zfs_mod_supported_features *list)\n{\n#if !defined(__FreeBSD__) && !defined(_KERNEL) && !defined(LIB_ZPOOL_BUILD)\n\tif (list) {\n\t\ttdestroy(list->tree, free);\n\t\tfree(list);\n\t}\n#else\n\t(void) list;\n#endif\n}\n\n#if !defined(_KERNEL) && !defined(LIB_ZPOOL_BUILD)\nstatic boolean_t\nzfs_mod_supported_impl(const char *scope, const char *name, const char *sysfs)\n{\n\tchar path[128];\n\tif (snprintf(path, sizeof (path), \"%s%s%s%s%s\", sysfs,\n\t    scope == NULL ? \"\" : \"/\", scope ?: \"\",\n\t    name == NULL ? \"\" : \"/\", name ?: \"\") < sizeof (path))\n\t\treturn (access(path, F_OK) == 0);\n\telse\n\t\treturn (B_FALSE);\n}\n\nboolean_t\nzfs_mod_supported(const char *scope, const char *name,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\tboolean_t supported;\n\n\tif (sfeatures != NULL)\n\t\treturn (sfeatures->all_features ||\n\t\t    tfind(name, &sfeatures->tree, STRCMP));\n\n\t \n\tsupported = (zfs_mod_supported_impl(scope, name, ZFS_SYSFS_DIR) ||\n\t    zfs_mod_supported_impl(scope, name, ZFS_SYSFS_ALT_DIR));\n\n\t \n\tif (supported == B_FALSE) {\n\t\tif ((access(ZFS_SYSFS_DIR, F_OK) == 0 &&\n\t\t    !zfs_mod_supported_impl(scope, NULL, ZFS_SYSFS_DIR)) ||\n\t\t    (access(ZFS_SYSFS_ALT_DIR, F_OK) == 0 &&\n\t\t    !zfs_mod_supported_impl(scope, NULL, ZFS_SYSFS_ALT_DIR))) {\n\t\t\tsupported = B_TRUE;\n\t\t}\n\t}\n\n\treturn (supported);\n}\n#endif\n\nstatic boolean_t\nzfs_mod_supported_feature(const char *name,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\t \n\n#if defined(_KERNEL) || defined(LIB_ZPOOL_BUILD) || defined(__FreeBSD__)\n\t(void) name, (void) sfeatures;\n\treturn (B_TRUE);\n#else\n\treturn (zfs_mod_supported(ZFS_SYSFS_POOL_FEATURES, name, sfeatures));\n#endif\n}\n\nstatic void\nzfeature_register(spa_feature_t fid, const char *guid, const char *name,\n    const char *desc, zfeature_flags_t flags, zfeature_type_t type,\n    const spa_feature_t *deps,\n    const struct zfs_mod_supported_features *sfeatures)\n{\n\tzfeature_info_t *feature = &spa_feature_table[fid];\n\tstatic const spa_feature_t nodeps[] = { SPA_FEATURE_NONE };\n\n\tASSERT(name != NULL);\n\tASSERT(desc != NULL);\n\tASSERT((flags & ZFEATURE_FLAG_READONLY_COMPAT) == 0 ||\n\t    (flags & ZFEATURE_FLAG_MOS) == 0);\n\tASSERT3U(fid, <, SPA_FEATURES);\n\tASSERT(zfeature_is_valid_guid(guid));\n\n\tif (deps == NULL)\n\t\tdeps = nodeps;\n\n\tVERIFY(((flags & ZFEATURE_FLAG_PER_DATASET) == 0) ||\n\t    (deps_contains_feature(deps, SPA_FEATURE_EXTENSIBLE_DATASET)));\n\n\tfeature->fi_feature = fid;\n\tfeature->fi_guid = guid;\n\tfeature->fi_uname = name;\n\tfeature->fi_desc = desc;\n\tfeature->fi_flags = flags;\n\tfeature->fi_type = type;\n\tfeature->fi_depends = deps;\n\tfeature->fi_zfs_mod_supported =\n\t    zfs_mod_supported_feature(guid, sfeatures);\n}\n\n \nvoid\nzpool_feature_init(void)\n{\n\tstruct zfs_mod_supported_features *sfeatures =\n\t    zfs_mod_list_supported(ZFS_SYSFS_POOL_FEATURES);\n\n\tzfeature_register(SPA_FEATURE_ASYNC_DESTROY,\n\t    \"com.delphix:async_destroy\", \"async_destroy\",\n\t    \"Destroy filesystems asynchronously.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_EMPTY_BPOBJ,\n\t    \"com.delphix:empty_bpobj\", \"empty_bpobj\",\n\t    \"Snapshots use less space.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_LZ4_COMPRESS,\n\t    \"org.illumos:lz4_compress\", \"lz4_compress\",\n\t    \"LZ4 compression algorithm support.\",\n\t    ZFEATURE_FLAG_ACTIVATE_ON_ENABLE, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_MULTI_VDEV_CRASH_DUMP,\n\t    \"com.joyent:multi_vdev_crash_dump\", \"multi_vdev_crash_dump\",\n\t    \"Crash dumps to multiple vdev pools.\",\n\t    0, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);\n\n\tzfeature_register(SPA_FEATURE_SPACEMAP_HISTOGRAM,\n\t    \"com.delphix:spacemap_histogram\", \"spacemap_histogram\",\n\t    \"Spacemaps maintain space histograms.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_ENABLED_TXG,\n\t    \"com.delphix:enabled_txg\", \"enabled_txg\",\n\t    \"Record txg at which a feature is enabled\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t hole_birth_deps[] = {\n\t\t\tSPA_FEATURE_ENABLED_TXG,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_HOLE_BIRTH,\n\t\t    \"com.delphix:hole_birth\", \"hole_birth\",\n\t\t    \"Retain hole birth txg for more precise zfs send\",\n\t\t    ZFEATURE_FLAG_MOS | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,\n\t\t    ZFEATURE_TYPE_BOOLEAN, hole_birth_deps, sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_POOL_CHECKPOINT,\n\t    \"com.delphix:zpool_checkpoint\", \"zpool_checkpoint\",\n\t    \"Pool state can be checkpointed, allowing rewind later.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_SPACEMAP_V2,\n\t    \"com.delphix:spacemap_v2\", \"spacemap_v2\",\n\t    \"Space maps representing large segments are more efficient.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,\n\t    ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);\n\n\tzfeature_register(SPA_FEATURE_EXTENSIBLE_DATASET,\n\t    \"com.delphix:extensible_dataset\", \"extensible_dataset\",\n\t    \"Enhanced dataset functionality, used by other features.\",\n\t    0, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t bookmarks_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\n\t\tzfeature_register(SPA_FEATURE_BOOKMARKS,\n\t\t    \"com.delphix:bookmarks\", \"bookmarks\",\n\t\t    \"\\\"zfs bookmark\\\" command\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,\n\t\t    bookmarks_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t filesystem_limits_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_FS_SS_LIMIT,\n\t\t    \"com.joyent:filesystem_limits\", \"filesystem_limits\",\n\t\t    \"Filesystem and snapshot limits.\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,\n\t\t    filesystem_limits_deps, sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_EMBEDDED_DATA,\n\t    \"com.delphix:embedded_data\", \"embedded_data\",\n\t    \"Blocks which compress very well use even less space.\",\n\t    ZFEATURE_FLAG_MOS | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,\n\t    ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t livelist_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_LIVELIST,\n\t\t    \"com.delphix:livelist\", \"livelist\",\n\t\t    \"Improved clone deletion performance.\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,\n\t\t    livelist_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t log_spacemap_deps[] = {\n\t\t\tSPA_FEATURE_SPACEMAP_V2,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_LOG_SPACEMAP,\n\t\t    \"com.delphix:log_spacemap\", \"log_spacemap\",\n\t\t    \"Log metaslab changes on a single spacemap and \"\n\t\t    \"flush them periodically.\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,\n\t\t    log_spacemap_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t large_blocks_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_LARGE_BLOCKS,\n\t\t    \"org.open-zfs:large_blocks\", \"large_blocks\",\n\t\t    \"Support for blocks larger than 128KB.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    large_blocks_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t large_dnode_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_LARGE_DNODE,\n\t\t    \"org.zfsonlinux:large_dnode\", \"large_dnode\",\n\t\t    \"Variable on-disk size of dnodes.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    large_dnode_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t sha512_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_SHA512,\n\t\t    \"org.illumos:sha512\", \"sha512\",\n\t\t    \"SHA-512/256 hash algorithm.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    sha512_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t skein_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_SKEIN,\n\t\t    \"org.illumos:skein\", \"skein\",\n\t\t    \"Skein hash algorithm.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    skein_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t edonr_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_EDONR,\n\t\t    \"org.illumos:edonr\", \"edonr\",\n\t\t    \"Edon-R hash algorithm.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    edonr_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t redact_books_deps[] = {\n\t\t\tSPA_FEATURE_BOOKMARK_V2,\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_BOOKMARKS,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_REDACTION_BOOKMARKS,\n\t\t    \"com.delphix:redaction_bookmarks\", \"redaction_bookmarks\",\n\t\t    \"Support for bookmarks which store redaction lists for zfs \"\n\t\t    \"redacted send/recv.\", 0, ZFEATURE_TYPE_BOOLEAN,\n\t\t    redact_books_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t redact_datasets_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_REDACTED_DATASETS,\n\t\t    \"com.delphix:redacted_datasets\", \"redacted_datasets\",\n\t\t    \"Support for redacted datasets, produced by receiving \"\n\t\t    \"a redacted zfs send stream.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_UINT64_ARRAY,\n\t\t    redact_datasets_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t bookmark_written_deps[] = {\n\t\t\tSPA_FEATURE_BOOKMARK_V2,\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_BOOKMARKS,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_BOOKMARK_WRITTEN,\n\t\t    \"com.delphix:bookmark_written\", \"bookmark_written\",\n\t\t    \"Additional accounting, enabling the written#<bookmark> \"\n\t\t    \"property (space written since a bookmark), \"\n\t\t    \"and estimates of send stream sizes for incrementals from \"\n\t\t    \"bookmarks.\",\n\t\t    0, ZFEATURE_TYPE_BOOLEAN, bookmark_written_deps, sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_DEVICE_REMOVAL,\n\t    \"com.delphix:device_removal\", \"device_removal\",\n\t    \"Top-level vdevs can be removed, reducing logical pool size.\",\n\t    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t obsolete_counts_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_DEVICE_REMOVAL,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_OBSOLETE_COUNTS,\n\t\t    \"com.delphix:obsolete_counts\", \"obsolete_counts\",\n\t\t    \"Reduce memory used by removed devices when their blocks \"\n\t\t    \"are freed or remapped.\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,\n\t\t    obsolete_counts_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t userobj_accounting_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_USEROBJ_ACCOUNTING,\n\t\t    \"org.zfsonlinux:userobj_accounting\", \"userobj_accounting\",\n\t\t    \"User/Group object accounting.\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_PER_DATASET,\n\t\t    ZFEATURE_TYPE_BOOLEAN, userobj_accounting_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t bookmark_v2_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_BOOKMARKS,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_BOOKMARK_V2,\n\t\t    \"com.datto:bookmark_v2\", \"bookmark_v2\",\n\t\t    \"Support for larger bookmarks\",\n\t\t    0, ZFEATURE_TYPE_BOOLEAN, bookmark_v2_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t encryption_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_BOOKMARK_V2,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_ENCRYPTION,\n\t\t    \"com.datto:encryption\", \"encryption\",\n\t\t    \"Support for dataset level encryption\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    encryption_deps, sfeatures);\n\t}\n\n\t{\n\t\tstatic const spa_feature_t project_quota_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_PROJECT_QUOTA,\n\t\t    \"org.zfsonlinux:project_quota\", \"project_quota\",\n\t\t    \"space/object accounting based on project ID.\",\n\t\t    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_PER_DATASET,\n\t\t    ZFEATURE_TYPE_BOOLEAN, project_quota_deps, sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_ALLOCATION_CLASSES,\n\t    \"org.zfsonlinux:allocation_classes\", \"allocation_classes\",\n\t    \"Support for separate allocation classes.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_RESILVER_DEFER,\n\t    \"com.datto:resilver_defer\", \"resilver_defer\",\n\t    \"Support for deferring new resilvers when one is already running.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_DEVICE_REBUILD,\n\t    \"org.openzfs:device_rebuild\", \"device_rebuild\",\n\t    \"Support for sequential mirror/dRAID device rebuilds\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t zstd_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_ZSTD_COMPRESS,\n\t\t    \"org.freebsd:zstd_compress\", \"zstd_compress\",\n\t\t    \"zstd compression algorithm support.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN, zstd_deps,\n\t\t    sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_DRAID,\n\t    \"org.openzfs:draid\", \"draid\", \"Support for distributed spare RAID\",\n\t    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t zilsaxattr_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_ZILSAXATTR,\n\t\t    \"org.openzfs:zilsaxattr\", \"zilsaxattr\",\n\t\t    \"Support for xattr=sa extended attribute logging in ZIL.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET | ZFEATURE_FLAG_READONLY_COMPAT,\n\t\t    ZFEATURE_TYPE_BOOLEAN, zilsaxattr_deps, sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_HEAD_ERRLOG,\n\t    \"com.delphix:head_errlog\", \"head_errlog\",\n\t    \"Support for per-dataset on-disk error logs.\",\n\t    ZFEATURE_FLAG_ACTIVATE_ON_ENABLE, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\t{\n\t\tstatic const spa_feature_t blake3_deps[] = {\n\t\t\tSPA_FEATURE_EXTENSIBLE_DATASET,\n\t\t\tSPA_FEATURE_NONE\n\t\t};\n\t\tzfeature_register(SPA_FEATURE_BLAKE3,\n\t\t    \"org.openzfs:blake3\", \"blake3\",\n\t\t    \"BLAKE3 hash algorithm.\",\n\t\t    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,\n\t\t    blake3_deps, sfeatures);\n\t}\n\n\tzfeature_register(SPA_FEATURE_BLOCK_CLONING,\n\t    \"com.fudosecurity:block_cloning\", \"block_cloning\",\n\t    \"Support for block cloning via Block Reference Table.\",\n\t    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfeature_register(SPA_FEATURE_AVZ_V2,\n\t    \"com.klarasystems:vdev_zaps_v2\", \"vdev_zaps_v2\",\n\t    \"Support for root vdev ZAP.\",\n\t    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL,\n\t    sfeatures);\n\n\tzfs_mod_list_supported_free(sfeatures);\n}\n\n#if defined(_KERNEL)\nEXPORT_SYMBOL(zfeature_lookup_guid);\nEXPORT_SYMBOL(zfeature_lookup_name);\nEXPORT_SYMBOL(zfeature_is_supported);\nEXPORT_SYMBOL(zfeature_is_valid_guid);\nEXPORT_SYMBOL(zfeature_depends_on);\nEXPORT_SYMBOL(zpool_feature_init);\nEXPORT_SYMBOL(spa_feature_table);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}