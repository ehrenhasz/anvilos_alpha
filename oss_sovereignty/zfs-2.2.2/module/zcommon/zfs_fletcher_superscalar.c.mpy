{
  "module_name": "zfs_fletcher_superscalar.c",
  "hash_id": "db648a3f6a4620d75701eec3552d086cda89c2db11111fdbd294f8de6d8445f6",
  "original_prompt": "Ingested from zfs-2.2.2/module/zcommon/zfs_fletcher_superscalar.c",
  "human_readable_source": " \n\n#include <sys/param.h>\n#include <sys/byteorder.h>\n#include <sys/spa_checksum.h>\n#include <sys/string.h>\n#include <zfs_fletcher.h>\n\nstatic void\nfletcher_4_superscalar_init(fletcher_4_ctx_t *ctx)\n{\n\tmemset(ctx->superscalar, 0, 4 * sizeof (zfs_fletcher_superscalar_t));\n}\n\nstatic void\nfletcher_4_superscalar_fini(fletcher_4_ctx_t *ctx, zio_cksum_t *zcp)\n{\n\tuint64_t A, B, C, D;\n\tA = ctx->superscalar[0].v[0] + ctx->superscalar[0].v[1];\n\tB = 2 * ctx->superscalar[1].v[0] + 2 * ctx->superscalar[1].v[1] -\n\t    ctx->superscalar[0].v[1];\n\tC = 4 * ctx->superscalar[2].v[0] - ctx->superscalar[1].v[0] +\n\t    4 * ctx->superscalar[2].v[1] - 3 * ctx->superscalar[1].v[1];\n\tD = 8 * ctx->superscalar[3].v[0] - 4 * ctx->superscalar[2].v[0] +\n\t    8 * ctx->superscalar[3].v[1] - 8 * ctx->superscalar[2].v[1] +\n\t    ctx->superscalar[1].v[1];\n\tZIO_SET_CHECKSUM(zcp, A, B, C, D);\n}\n\nstatic void\nfletcher_4_superscalar_native(fletcher_4_ctx_t *ctx,\n    const void *buf, uint64_t size)\n{\n\tconst uint32_t *ip = buf;\n\tconst uint32_t *ipend = ip + (size / sizeof (uint32_t));\n\tuint64_t a, b, c, d;\n\tuint64_t a2, b2, c2, d2;\n\n\ta = ctx->superscalar[0].v[0];\n\tb = ctx->superscalar[1].v[0];\n\tc = ctx->superscalar[2].v[0];\n\td = ctx->superscalar[3].v[0];\n\ta2 = ctx->superscalar[0].v[1];\n\tb2 = ctx->superscalar[1].v[1];\n\tc2 = ctx->superscalar[2].v[1];\n\td2 = ctx->superscalar[3].v[1];\n\n\tdo {\n\t\ta += ip[0];\n\t\ta2 += ip[1];\n\t\tb += a;\n\t\tb2 += a2;\n\t\tc += b;\n\t\tc2 += b2;\n\t\td += c;\n\t\td2 += c2;\n\t} while ((ip += 2) < ipend);\n\n\tctx->superscalar[0].v[0] = a;\n\tctx->superscalar[1].v[0] = b;\n\tctx->superscalar[2].v[0] = c;\n\tctx->superscalar[3].v[0] = d;\n\tctx->superscalar[0].v[1] = a2;\n\tctx->superscalar[1].v[1] = b2;\n\tctx->superscalar[2].v[1] = c2;\n\tctx->superscalar[3].v[1] = d2;\n}\n\nstatic void\nfletcher_4_superscalar_byteswap(fletcher_4_ctx_t *ctx,\n    const void *buf, uint64_t size)\n{\n\tconst uint32_t *ip = buf;\n\tconst uint32_t *ipend = ip + (size / sizeof (uint32_t));\n\tuint64_t a, b, c, d;\n\tuint64_t a2, b2, c2, d2;\n\n\ta = ctx->superscalar[0].v[0];\n\tb = ctx->superscalar[1].v[0];\n\tc = ctx->superscalar[2].v[0];\n\td = ctx->superscalar[3].v[0];\n\ta2 = ctx->superscalar[0].v[1];\n\tb2 = ctx->superscalar[1].v[1];\n\tc2 = ctx->superscalar[2].v[1];\n\td2 = ctx->superscalar[3].v[1];\n\n\tdo {\n\t\ta += BSWAP_32(ip[0]);\n\t\ta2 += BSWAP_32(ip[1]);\n\t\tb += a;\n\t\tb2 += a2;\n\t\tc += b;\n\t\tc2 += b2;\n\t\td += c;\n\t\td2 += c2;\n\t} while ((ip += 2) < ipend);\n\n\tctx->superscalar[0].v[0] = a;\n\tctx->superscalar[1].v[0] = b;\n\tctx->superscalar[2].v[0] = c;\n\tctx->superscalar[3].v[0] = d;\n\tctx->superscalar[0].v[1] = a2;\n\tctx->superscalar[1].v[1] = b2;\n\tctx->superscalar[2].v[1] = c2;\n\tctx->superscalar[3].v[1] = d2;\n}\n\nstatic boolean_t fletcher_4_superscalar_valid(void)\n{\n\treturn (B_TRUE);\n}\n\nconst fletcher_4_ops_t fletcher_4_superscalar_ops = {\n\t.init_native = fletcher_4_superscalar_init,\n\t.compute_native = fletcher_4_superscalar_native,\n\t.fini_native = fletcher_4_superscalar_fini,\n\t.init_byteswap = fletcher_4_superscalar_init,\n\t.compute_byteswap = fletcher_4_superscalar_byteswap,\n\t.fini_byteswap = fletcher_4_superscalar_fini,\n\t.valid = fletcher_4_superscalar_valid,\n\t.uses_fpu = B_FALSE,\n\t.name = \"superscalar\"\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}