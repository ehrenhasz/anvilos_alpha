{
  "module_name": "llex.c",
  "hash_id": "5fac752a8357fe316ca8cee5081c2b9bf317c97118e76646ffb5f9fbfa4a909e",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/llex.c",
  "human_readable_source": " \n\n#define llex_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lctype.h\"\n#include \"ldo.h\"\n#include \"llex.h\"\n#include \"lobject.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lzio.h\"\n\n\n\n#define next(ls) (ls->current = zgetc(ls->z))\n\n\n\n#define currIsNewline(ls)\t(ls->current == '\\n' || ls->current == '\\r')\n\n\n \nstatic const char *const luaX_tokens [] = {\n    \"and\", \"break\", \"do\", \"else\", \"elseif\",\n    \"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n    \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n    \"return\", \"then\", \"true\", \"until\", \"while\",\n    \"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\", \"::\", \"<eof>\",\n    \"<number>\", \"<name>\", \"<string>\"\n};\n\n\n#define save_and_next(ls) (save(ls, ls->current), next(ls))\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token);\n\n\nstatic void save (LexState *ls, int c) {\n  Mbuffer *b = ls->buff;\n  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {\n    size_t newsize;\n    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)\n      lexerror(ls, \"lexical element too long\", 0);\n    newsize = luaZ_sizebuffer(b) * 2;\n    luaZ_resizebuffer(ls->L, b, newsize);\n  }\n  b->buffer[luaZ_bufflen(b)++] = cast(char, c);\n}\n\n\nvoid luaX_init (lua_State *L) {\n  int i;\n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaS_fix(ts);   \n    ts->tsv.extra = cast_byte(i+1);   \n  }\n}\n\n\nconst char *luaX_token2str (LexState *ls, int token) {\n  if (token < FIRST_RESERVED) {   \n    lua_assert(token == cast(unsigned char, token));\n    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL(\"%c\"), token) :\n                              luaO_pushfstring(ls->L, \"char(%d)\", token);\n  }\n  else {\n    const char *s = luaX_tokens[token - FIRST_RESERVED];\n    if (token < TK_EOS)   \n      return luaO_pushfstring(ls->L, LUA_QS, s);\n    else   \n      return s;\n  }\n}\n\n\nstatic const char *txtToken (LexState *ls, int token) {\n  switch (token) {\n    case TK_NAME:\n    case TK_STRING:\n    case TK_NUMBER:\n      save(ls, '\\0');\n      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));\n    default:\n      return luaX_token2str(ls, token);\n  }\n}\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token) {\n  char buff[LUA_IDSIZE];\n  luaO_chunkid(buff, getstr(ls->source), LUA_IDSIZE);\n  msg = luaO_pushfstring(ls->L, \"%s:%d: %s\", buff, ls->linenumber, msg);\n  if (token)\n    luaO_pushfstring(ls->L, \"%s near %s\", msg, txtToken(ls, token));\n  luaD_throw(ls->L, LUA_ERRSYNTAX);\n}\n\n\nl_noret luaX_syntaxerror (LexState *ls, const char *msg) {\n  lexerror(ls, msg, ls->t.token);\n}\n\n\n \nTString *luaX_newstring (LexState *ls, const char *str, size_t l) {\n  lua_State *L = ls->L;\n  TValue *o;   \n  TString *ts = luaS_newlstr(L, str, l);   \n  setsvalue2s(L, L->top++, ts);   \n  o = luaH_set(L, ls->fs->h, L->top - 1);\n  if (ttisnil(o)) {   \n     \n    setbvalue(o, 1);   \n    luaC_checkGC(L);\n  }\n  else {   \n    ts = rawtsvalue(keyfromval(o));   \n  }\n  L->top--;   \n  return ts;\n}\n\n\n \nstatic void inclinenumber (LexState *ls) {\n  int old = ls->current;\n  lua_assert(currIsNewline(ls));\n  next(ls);   \n  if (currIsNewline(ls) && ls->current != old)\n    next(ls);   \n  if (++ls->linenumber >= MAX_INT)\n    lexerror(ls, \"chunk has too many lines\", 0);\n}\n\n\nvoid luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,\n                    int firstchar) {\n  ls->decpoint = '.';\n  ls->L = L;\n  ls->current = firstchar;\n  ls->lookahead.token = TK_EOS;   \n  ls->z = z;\n  ls->fs = NULL;\n  ls->linenumber = 1;\n  ls->lastline = 1;\n  ls->source = source;\n  ls->envn = luaS_new(L, LUA_ENV);   \n  luaS_fix(ls->envn);   \n  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);   \n}\n\n\n\n \n\n\n\nstatic int check_next (LexState *ls, const char *set) {\n  if (ls->current == '\\0' || !strchr(set, ls->current))\n    return 0;\n  save_and_next(ls);\n  return 1;\n}\n\n\n \nstatic void buffreplace (LexState *ls, char from, char to) {\n  size_t n = luaZ_bufflen(ls->buff);\n  char *p = luaZ_buffer(ls->buff);\n  while (n--)\n    if (p[n] == from) p[n] = to;\n}\n\n\n#if !defined(getlocaledecpoint)\n#define getlocaledecpoint()\t(localeconv()->decimal_point[0])\n#endif\n\n\n#define buff2d(b,e)\tluaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)\n\n \nstatic void trydecpoint (LexState *ls, SemInfo *seminfo) {\n  char old = ls->decpoint;\n  ls->decpoint = getlocaledecpoint();\n  buffreplace(ls, old, ls->decpoint);   \n  if (!buff2d(ls->buff, &seminfo->r)) {\n     \n    buffreplace(ls, ls->decpoint, '.');   \n    lexerror(ls, \"malformed number\", TK_NUMBER);\n  }\n}\n\n\n \n \nstatic void read_numeral (LexState *ls, SemInfo *seminfo) {\n  const char *expo = \"Ee\";\n  int first = ls->current;\n  lua_assert(lisdigit(ls->current));\n  save_and_next(ls);\n  if (first == '0' && check_next(ls, \"Xx\"))   \n    expo = \"Pp\";\n  for (;;) {\n    if (check_next(ls, expo))   \n      (void) check_next(ls, \"+-\");   \n    if (lisxdigit(ls->current) || ls->current == '.')\n      save_and_next(ls);\n    else  break;\n  }\n  save(ls, '\\0');\n  buffreplace(ls, '.', ls->decpoint);   \n  if (!buff2d(ls->buff, &seminfo->r))   \n    trydecpoint(ls, seminfo);  \n}\n\n\n \nstatic int skip_sep (LexState *ls) {\n  int count = 0;\n  int s = ls->current;\n  lua_assert(s == '[' || s == ']');\n  save_and_next(ls);\n  while (ls->current == '=') {\n    save_and_next(ls);\n    count++;\n  }\n  return (ls->current == s) ? count : (-count) - 1;\n}\n\n\nstatic void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {\n  save_and_next(ls);   \n  if (currIsNewline(ls))   \n    inclinenumber(ls);   \n  for (;;) {\n    switch (ls->current) {\n      case EOZ:\n        lexerror(ls, (seminfo) ? \"unfinished long string\" :\n                                 \"unfinished long comment\", TK_EOS);\n        break;   \n      case ']': {\n        if (skip_sep(ls) == sep) {\n          save_and_next(ls);   \n          goto endloop;\n        }\n        break;\n      }\n      case '\\n': case '\\r': {\n        save(ls, '\\n');\n        inclinenumber(ls);\n        if (!seminfo) luaZ_resetbuffer(ls->buff);   \n        break;\n      }\n      default: {\n        if (seminfo) save_and_next(ls);\n        else next(ls);\n      }\n    }\n  } endloop:\n  if (seminfo)\n    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),\n                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));\n}\n\n\nstatic void escerror (LexState *ls, int *c, int n, const char *msg) {\n  int i;\n  luaZ_resetbuffer(ls->buff);   \n  save(ls, '\\\\');\n  for (i = 0; i < n && c[i] != EOZ; i++)\n    save(ls, c[i]);\n  lexerror(ls, msg, TK_STRING);\n}\n\n\nstatic int readhexaesc (LexState *ls) {\n  int c[3], i;   \n  int r = 0;   \n  c[0] = 'x';   \n  for (i = 1; i < 3; i++) {   \n    c[i] = next(ls);\n    if (!lisxdigit(c[i]))\n      escerror(ls, c, i + 1, \"hexadecimal digit expected\");\n    r = (r << 4) + luaO_hexavalue(c[i]);\n  }\n  return r;\n}\n\n\nstatic int readdecesc (LexState *ls) {\n  int c[3], i;\n  int r = 0;   \n  for (i = 0; i < 3 && lisdigit(ls->current); i++) {   \n    c[i] = ls->current;\n    r = 10*r + c[i] - '0';\n    next(ls);\n  }\n  if (r > UCHAR_MAX)\n    escerror(ls, c, i, \"decimal escape too large\");\n  return r;\n}\n\n\nstatic void read_string (LexState *ls, int del, SemInfo *seminfo) {\n  save_and_next(ls);   \n  while (ls->current != del) {\n    switch (ls->current) {\n      case EOZ:\n        lexerror(ls, \"unfinished string\", TK_EOS);\n        break;   \n      case '\\n':\n      case '\\r':\n        lexerror(ls, \"unfinished string\", TK_STRING);\n        break;   \n      case '\\\\': {   \n        int c;   \n        next(ls);   \n        switch (ls->current) {\n          case 'a': c = '\\a'; goto read_save;\n          case 'b': c = '\\b'; goto read_save;\n          case 'f': c = '\\f'; goto read_save;\n          case 'n': c = '\\n'; goto read_save;\n          case 'r': c = '\\r'; goto read_save;\n          case 't': c = '\\t'; goto read_save;\n          case 'v': c = '\\v'; goto read_save;\n          case 'x': c = readhexaesc(ls); goto read_save;\n          case '\\n': case '\\r':\n            inclinenumber(ls); c = '\\n'; goto only_save;\n          case '\\\\': case '\\\"': case '\\'':\n            c = ls->current; goto read_save;\n          case EOZ: goto no_save;   \n          case 'z': {   \n            next(ls);   \n            while (lisspace(ls->current)) {\n              if (currIsNewline(ls)) inclinenumber(ls);\n              else next(ls);\n            }\n            goto no_save;\n          }\n          default: {\n            if (!lisdigit(ls->current))\n              escerror(ls, &ls->current, 1, \"invalid escape sequence\");\n             \n            c = readdecesc(ls);\n            goto only_save;\n          }\n        }\n       read_save: next(ls);   \n       only_save: save(ls, c);   \n       no_save: break;\n      }\n      default:\n        save_and_next(ls);\n    }\n  }\n  save_and_next(ls);   \n  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,\n                                   luaZ_bufflen(ls->buff) - 2);\n}\n\n\nstatic int llex (LexState *ls, SemInfo *seminfo) {\n  luaZ_resetbuffer(ls->buff);\n  for (;;) {\n    switch (ls->current) {\n      case '\\n': case '\\r': {   \n        inclinenumber(ls);\n        break;\n      }\n      case ' ': case '\\f': case '\\t': case '\\v': {   \n        next(ls);\n        break;\n      }\n      case '-': {   \n        next(ls);\n        if (ls->current != '-') return '-';\n         \n        next(ls);\n        if (ls->current == '[') {   \n          int sep = skip_sep(ls);\n          luaZ_resetbuffer(ls->buff);   \n          if (sep >= 0) {\n            read_long_string(ls, NULL, sep);   \n            luaZ_resetbuffer(ls->buff);   \n            break;\n          }\n        }\n         \n        while (!currIsNewline(ls) && ls->current != EOZ)\n          next(ls);   \n        break;\n      }\n      case '[': {   \n        int sep = skip_sep(ls);\n        if (sep >= 0) {\n          read_long_string(ls, seminfo, sep);\n          return TK_STRING;\n        } else if (sep == -1) {\n\t\treturn '[';\n        } else {\n\t\tlexerror(ls, \"invalid long string delimiter\", TK_STRING);\n\t\tbreak;\n\t}\n      }\n      case '=': {\n        next(ls);\n        if (ls->current != '=') return '=';\n        else { next(ls); return TK_EQ; }\n      }\n      case '<': {\n        next(ls);\n        if (ls->current != '=') return '<';\n        else { next(ls); return TK_LE; }\n      }\n      case '>': {\n        next(ls);\n        if (ls->current != '=') return '>';\n        else { next(ls); return TK_GE; }\n      }\n      case '~': {\n        next(ls);\n        if (ls->current != '=') return '~';\n        else { next(ls); return TK_NE; }\n      }\n      case ':': {\n        next(ls);\n        if (ls->current != ':') return ':';\n        else { next(ls); return TK_DBCOLON; }\n      }\n      case '\"': case '\\'': {   \n        read_string(ls, ls->current, seminfo);\n        return TK_STRING;\n      }\n      case '.': {   \n        save_and_next(ls);\n        if (check_next(ls, \".\")) {\n          if (check_next(ls, \".\"))\n            return TK_DOTS;    \n          else return TK_CONCAT;    \n        }\n        else if (!lisdigit(ls->current)) return '.';\n         \n      }\n        zfs_fallthrough;\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9': {\n        read_numeral(ls, seminfo);\n        return TK_NUMBER;\n      }\n      case EOZ: {\n        return TK_EOS;\n      }\n      default: {\n        if (lislalpha(ls->current)) {   \n          TString *ts;\n          do {\n            save_and_next(ls);\n          } while (lislalnum(ls->current));\n          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),\n                                  luaZ_bufflen(ls->buff));\n          seminfo->ts = ts;\n          if (isreserved(ts))   \n            return ts->tsv.extra - 1 + FIRST_RESERVED;\n          else {\n            return TK_NAME;\n          }\n        }\n        else {   \n          int c = ls->current;\n          next(ls);\n          return c;\n        }\n      }\n    }\n  }\n}\n\n\nvoid luaX_next (LexState *ls) {\n  ls->lastline = ls->linenumber;\n  if (ls->lookahead.token != TK_EOS) {   \n    ls->t = ls->lookahead;   \n    ls->lookahead.token = TK_EOS;   \n  }\n  else\n    ls->t.token = llex(ls, &ls->t.seminfo);   \n}\n\n\nint luaX_lookahead (LexState *ls) {\n  lua_assert(ls->lookahead.token == TK_EOS);\n  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);\n  return ls->lookahead.token;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}