{
  "module_name": "lmem.c",
  "hash_id": "0204fdace0c8ec64e61ceb65319e4d80c8c35364af2cf8c97bacaa2da6b588c5",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lmem.c",
  "human_readable_source": " \n\n\n#define lmem_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\n \n\n\n\n#define MINSIZEARRAY\t4\n\n\nvoid *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,\n                     int limit, const char *what) {\n  void *newblock;\n  int newsize;\n  if (*size >= limit/2) {   \n    if (*size >= limit)   \n      luaG_runerror(L, \"too many %s (limit is %d)\", what, limit);\n    newsize = limit;   \n  }\n  else {\n    newsize = (*size)*2;\n    if (newsize < MINSIZEARRAY)\n      newsize = MINSIZEARRAY;   \n  }\n  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);\n  *size = newsize;   \n  return newblock;\n}\n\n\nl_noret luaM_toobig (lua_State *L) {\n  luaG_runerror(L, \"memory allocation error: block too big\");\n}\n\n\n\n \nvoid *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {\n  void *newblock;\n  global_State *g = G(L);\n  size_t realosize = (block) ? osize : 0;\n  lua_assert((realosize == 0) == (block == NULL));\n#if defined(HARDMEMTESTS)\n  if (nsize > realosize && g->gcrunning)\n    luaC_fullgc(L, 1);   \n#endif\n  newblock = (*g->frealloc)(g->ud, block, osize, nsize);\n  if (newblock == NULL && nsize > 0) {\n    api_check(L, nsize > realosize,\n                 \"realloc cannot fail when shrinking a block\");\n    if (g->gcrunning) {\n      luaC_fullgc(L, 1);   \n      newblock = (*g->frealloc)(g->ud, block, osize, nsize);   \n    }\n    if (newblock == NULL)\n      luaD_throw(L, LUA_ERRMEM);\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->GCdebt = (g->GCdebt + nsize) - realosize;\n  return newblock;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}