{
  "module_name": "lparser.c",
  "hash_id": "0f0b67e44fe6362fef0957505fefca40f23accfa4a247671ae693e7c85a1ee69",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lparser.c",
  "human_readable_source": " \n\n#define lparser_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n\n\n\n \n#define MAXVARS\t\t200\n\n\n#define hasmultret(k)\t\t((k) == VCALL || (k) == VVARARG)\n\n\n\n \ntypedef struct BlockCnt {\n  struct BlockCnt *previous;   \n  short firstlabel;   \n  short firstgoto;   \n  lu_byte nactvar;   \n  lu_byte upval;   \n  lu_byte isloop;   \n} BlockCnt;\n\n\n\n \nstatic void statement (LexState *ls);\nstatic void expr (LexState *ls, expdesc *v);\n\n\nstatic void anchor_token (LexState *ls) {\n   \n  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);\n  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {\n    TString *ts = ls->t.seminfo.ts;\n    luaX_newstring(ls, getstr(ts), ts->tsv.len);\n  }\n}\n\n\n \nstatic l_noret semerror (LexState *ls, const char *msg) {\n  ls->t.token = 0;   \n  luaX_syntaxerror(ls, msg);\n}\n\n\nstatic l_noret error_expected (LexState *ls, int token) {\n  luaX_syntaxerror(ls,\n      luaO_pushfstring(ls->L, \"%s expected\", luaX_token2str(ls, token)));\n}\n\n\nstatic l_noret errorlimit (FuncState *fs, int limit, const char *what) {\n  lua_State *L = fs->ls->L;\n  const char *msg;\n  int line = fs->f->linedefined;\n  const char *where = (line == 0)\n                      ? \"main function\"\n                      : luaO_pushfstring(L, \"function at line %d\", line);\n  msg = luaO_pushfstring(L, \"too many %s (limit is %d) in %s\",\n                             what, limit, where);\n  luaX_syntaxerror(fs->ls, msg);\n}\n\n\nstatic void checklimit (FuncState *fs, int v, int l, const char *what) {\n  if (v > l) errorlimit(fs, l, what);\n}\n\n\nstatic int testnext (LexState *ls, int c) {\n  if (ls->t.token == c) {\n    luaX_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\nstatic void check (LexState *ls, int c) {\n  if (ls->t.token != c)\n    error_expected(ls, c);\n}\n\n\nstatic void checknext (LexState *ls, int c) {\n  check(ls, c);\n  luaX_next(ls);\n}\n\n\n#define check_condition(ls,c,msg)\t{ if (!(c)) luaX_syntaxerror(ls, msg); }\n\n\n\nstatic void check_match (LexState *ls, int what, int who, int where) {\n  if (!testnext(ls, what)) {\n    if (where == ls->linenumber)\n      error_expected(ls, what);\n    else {\n      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,\n             \"%s expected (to close %s at line %d)\",\n              luaX_token2str(ls, what), luaX_token2str(ls, who), where));\n    }\n  }\n}\n\n\nstatic TString *str_checkname (LexState *ls) {\n  TString *ts;\n  check(ls, TK_NAME);\n  ts = ls->t.seminfo.ts;\n  luaX_next(ls);\n  return ts;\n}\n\n\nstatic void init_exp (expdesc *e, expkind k, int i) {\n  e->f = e->t = NO_JUMP;\n  e->k = k;\n  e->u.info = i;\n}\n\n\nstatic void codestring (LexState *ls, expdesc *e, TString *s) {\n  init_exp(e, VK, luaK_stringK(ls->fs, s));\n}\n\n\nstatic void checkname (LexState *ls, expdesc *e) {\n  codestring(ls, e, str_checkname(ls));\n}\n\n\nstatic int registerlocalvar (LexState *ls, TString *varname) {\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int oldsize = f->sizelocvars;\n  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,\n                  LocVar, SHRT_MAX, \"local variables\");\n  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;\n  f->locvars[fs->nlocvars].varname = varname;\n  luaC_objbarrier(ls->L, f, varname);\n  return fs->nlocvars++;\n}\n\n\nstatic void new_localvar (LexState *ls, TString *name) {\n  FuncState *fs = ls->fs;\n  Dyndata *dyd = ls->dyd;\n  int reg = registerlocalvar(ls, name);\n  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,\n                  MAXVARS, \"local variables\");\n  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,\n                  dyd->actvar.size, Vardesc, MAX_INT, \"local variables\");\n  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);\n}\n\n\nstatic void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {\n  new_localvar(ls, luaX_newstring(ls, name, sz));\n}\n\n#define new_localvarliteral(ls,v) \\\n\tnew_localvarliteral_(ls, \"\" v, (sizeof(v)/sizeof(char))-1)\n\n\nstatic LocVar *getlocvar (FuncState *fs, int i) {\n  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;\n  lua_assert(idx < fs->nlocvars);\n  return &fs->f->locvars[idx];\n}\n\n\nstatic void adjustlocalvars (LexState *ls, int nvars) {\n  FuncState *fs = ls->fs;\n  fs->nactvar = cast_byte(fs->nactvar + nvars);\n  for (; nvars; nvars--) {\n    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;\n  }\n}\n\n\nstatic void removevars (FuncState *fs, int tolevel) {\n  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);\n  while (fs->nactvar > tolevel)\n    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;\n}\n\n\nstatic int searchupvalue (FuncState *fs, TString *name) {\n  int i;\n  Upvaldesc *up = fs->f->upvalues;\n  for (i = 0; i < fs->nups; i++) {\n    if (luaS_eqstr(up[i].name, name)) return i;\n  }\n  return -1;   \n}\n\n\nstatic int newupvalue (FuncState *fs, TString *name, expdesc *v) {\n  Proto *f = fs->f;\n  int oldsize = f->sizeupvalues;\n  checklimit(fs, fs->nups + 1, MAXUPVAL, \"upvalues\");\n  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,\n                  Upvaldesc, MAXUPVAL, \"upvalues\");\n  while (oldsize < f->sizeupvalues) f->upvalues[oldsize++].name = NULL;\n  f->upvalues[fs->nups].instack = (v->k == VLOCAL);\n  f->upvalues[fs->nups].idx = cast_byte(v->u.info);\n  f->upvalues[fs->nups].name = name;\n  luaC_objbarrier(fs->ls->L, f, name);\n  return fs->nups++;\n}\n\n\nstatic int searchvar (FuncState *fs, TString *n) {\n  int i;\n  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {\n    if (luaS_eqstr(n, getlocvar(fs, i)->varname))\n      return i;\n  }\n  return -1;   \n}\n\n\n \nstatic void markupval (FuncState *fs, int level) {\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level) bl = bl->previous;\n  bl->upval = 1;\n}\n\n\n \nstatic int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {\n  if (fs == NULL)   \n    return VVOID;   \n  else {\n    int v = searchvar(fs, n);   \n    if (v >= 0) {   \n      init_exp(var, VLOCAL, v);   \n      if (!base)\n        markupval(fs, v);   \n      return VLOCAL;\n    }\n    else {   \n      int idx = searchupvalue(fs, n);   \n      if (idx < 0) {   \n        if (singlevaraux(fs->prev, n, var, 0) == VVOID)  \n          return VVOID;   \n         \n        idx  = newupvalue(fs, n, var);   \n      }\n      init_exp(var, VUPVAL, idx);\n      return VUPVAL;\n    }\n  }\n}\n\n\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  if (singlevaraux(fs, varname, var, 1) == VVOID) {   \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);   \n    lua_assert(var->k == VLOCAL || var->k == VUPVAL);\n    codestring(ls, &key, varname);   \n    luaK_indexed(fs, var, &key);   \n  }\n}\n\n\nstatic void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {\n  FuncState *fs = ls->fs;\n  int extra = nvars - nexps;\n  if (hasmultret(e->k)) {\n    extra++;   \n    if (extra < 0) extra = 0;\n    luaK_setreturns(fs, e, extra);   \n    if (extra > 1) luaK_reserveregs(fs, extra-1);\n  }\n  else {\n    if (e->k != VVOID) luaK_exp2nextreg(fs, e);   \n    if (extra > 0) {\n      int reg = fs->freereg;\n      luaK_reserveregs(fs, extra);\n      luaK_nil(fs, reg, extra);\n    }\n  }\n}\n\n\nstatic void enterlevel (LexState *ls) {\n  lua_State *L = ls->L;\n  ++L->nCcalls;\n  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, \"C levels\");\n}\n\n\n#define leavelevel(ls)\t((ls)->L->nCcalls--)\n\n\nstatic void closegoto (LexState *ls, int g, Labeldesc *label) {\n  int i;\n  FuncState *fs = ls->fs;\n  Labellist *gl = &ls->dyd->gt;\n  Labeldesc *gt = &gl->arr[g];\n  lua_assert(luaS_eqstr(gt->name, label->name));\n  if (gt->nactvar < label->nactvar) {\n    TString *vname = getlocvar(fs, gt->nactvar)->varname;\n    const char *msg = luaO_pushfstring(ls->L,\n      \"<goto %s> at line %d jumps into the scope of local \" LUA_QS,\n      getstr(gt->name), gt->line, getstr(vname));\n    semerror(ls, msg);\n  }\n  luaK_patchlist(fs, gt->pc, label->pc);\n   \n  for (i = g; i < gl->n - 1; i++)\n    gl->arr[i] = gl->arr[i + 1];\n  gl->n--;\n}\n\n\n \nstatic int findlabel (LexState *ls, int g) {\n  int i;\n  BlockCnt *bl = ls->fs->bl;\n  Dyndata *dyd = ls->dyd;\n  Labeldesc *gt = &dyd->gt.arr[g];\n   \n  for (i = bl->firstlabel; i < dyd->label.n; i++) {\n    Labeldesc *lb = &dyd->label.arr[i];\n    if (luaS_eqstr(lb->name, gt->name)) {   \n      if (gt->nactvar > lb->nactvar &&\n          (bl->upval || dyd->label.n > bl->firstlabel))\n        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);\n      closegoto(ls, g, lb);   \n      return 1;\n    }\n  }\n  return 0;   \n}\n\n\nstatic int newlabelentry (LexState *ls, Labellist *l, TString *name,\n                          int line, int pc) {\n  int n = l->n;\n  luaM_growvector(ls->L, l->arr, n, l->size,\n                  Labeldesc, SHRT_MAX, \"labels/gotos\");\n  l->arr[n].name = name;\n  l->arr[n].line = line;\n  l->arr[n].nactvar = ls->fs->nactvar;\n  l->arr[n].pc = pc;\n  l->n++;\n  return n;\n}\n\n\n \nstatic void findgotos (LexState *ls, Labeldesc *lb) {\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  while (i < gl->n) {\n    if (luaS_eqstr(gl->arr[i].name, lb->name))\n      closegoto(ls, i, lb);\n    else\n      i++;\n  }\n}\n\n\n \nstatic void movegotosout (FuncState *fs, BlockCnt *bl) {\n  int i = bl->firstgoto;\n  Labellist *gl = &fs->ls->dyd->gt;\n   \n  while (i < gl->n) {\n    Labeldesc *gt = &gl->arr[i];\n    if (gt->nactvar > bl->nactvar) {\n      if (bl->upval)\n        luaK_patchclose(fs, gt->pc, bl->nactvar);\n      gt->nactvar = bl->nactvar;\n    }\n    if (!findlabel(fs->ls, i))\n      i++;   \n  }\n}\n\n\nstatic void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {\n  bl->isloop = isloop;\n  bl->nactvar = fs->nactvar;\n  bl->firstlabel = fs->ls->dyd->label.n;\n  bl->firstgoto = fs->ls->dyd->gt.n;\n  bl->upval = 0;\n  bl->previous = fs->bl;\n  fs->bl = bl;\n  lua_assert(fs->freereg == fs->nactvar);\n}\n\n\n \nstatic void breaklabel (LexState *ls) {\n  TString *n = luaS_new(ls->L, \"break\");\n  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);\n  findgotos(ls, &ls->dyd->label.arr[l]);\n}\n\n \nstatic l_noret undefgoto (LexState *ls, Labeldesc *gt) {\n  const char *msg = isreserved(gt->name)\n                    ? \"<%s> at line %d not inside a loop\"\n                    : \"no visible label \" LUA_QS \" for <goto> at line %d\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  semerror(ls, msg);\n}\n\n\nstatic void leaveblock (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  LexState *ls = fs->ls;\n  if (bl->previous && bl->upval) {\n     \n    int j = luaK_jump(fs);\n    luaK_patchclose(fs, j, bl->nactvar);\n    luaK_patchtohere(fs, j);\n  }\n  if (bl->isloop)\n    breaklabel(ls);   \n  fs->bl = bl->previous;\n  removevars(fs, bl->nactvar);\n  lua_assert(bl->nactvar == fs->nactvar);\n  fs->freereg = fs->nactvar;   \n  ls->dyd->label.n = bl->firstlabel;   \n  if (bl->previous)   \n    movegotosout(fs, bl);   \n  else if (bl->firstgoto < ls->dyd->gt.n)   \n    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);   \n}\n\n\n \nstatic Proto *addprototype (LexState *ls) {\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;   \n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep) f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}\n\n\n \nstatic void codeclosure (LexState *ls, expdesc *v) {\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);   \n}\n\n\nstatic void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {\n  lua_State *L = ls->L;\n  Proto *f;\n  fs->prev = ls->fs;   \n  fs->ls = ls;\n  ls->fs = fs;\n  fs->pc = 0;\n  fs->lasttarget = 0;\n  fs->jpc = NO_JUMP;\n  fs->freereg = 0;\n  fs->nk = 0;\n  fs->np = 0;\n  fs->nups = 0;\n  fs->nlocvars = 0;\n  fs->nactvar = 0;\n  fs->firstlocal = ls->dyd->actvar.n;\n  fs->bl = NULL;\n  f = fs->f;\n  f->source = ls->source;\n  f->maxstacksize = 2;   \n  fs->h = luaH_new(L);\n   \n  sethvalue2s(L, L->top, fs->h);\n  incr_top(L);\n  enterblock(fs, bl, 0);\n}\n\n\nstatic void close_func (LexState *ls) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  luaK_ret(fs, 0, 0);   \n  leaveblock(fs);\n  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);\n  f->sizecode = fs->pc;\n  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);\n  f->sizelineinfo = fs->pc;\n  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);\n  f->sizek = fs->nk;\n  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);\n  f->sizep = fs->np;\n  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);\n  f->sizelocvars = fs->nlocvars;\n  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);\n  f->sizeupvalues = fs->nups;\n  lua_assert(fs->bl == NULL);\n  ls->fs = fs->prev;\n   \n  anchor_token(ls);\n  L->top--;   \n  luaC_checkGC(L);\n}\n\n\n\n \n \n \n\n\n \nstatic int block_follow (LexState *ls, int withuntil) {\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}\n\n\n \n__attribute__((always_inline)) inline\nstatic void statlist (LexState *ls) {\n   \n  while (!block_follow(ls, 1)) {\n    if (ls->t.token == TK_RETURN) {\n      statement(ls);\n      return;   \n    }\n    statement(ls);\n  }\n}\n\n\nstatic void fieldsel (LexState *ls, expdesc *v) {\n   \n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyregup(fs, v);\n  luaX_next(ls);   \n  checkname(ls, &key);\n  luaK_indexed(fs, v, &key);\n}\n\n\nstatic void yindex (LexState *ls, expdesc *v) {\n   \n  luaX_next(ls);   \n  expr(ls, v);\n  luaK_exp2val(ls->fs, v);\n  checknext(ls, ']');\n}\n\n\n \n\n\nstruct ConsControl {\n  expdesc v;   \n  expdesc *t;   \n  int nh;   \n  int na;   \n  int tostore;   \n};\n\n\nstatic void recfield (LexState *ls, struct ConsControl *cc) {\n   \n  FuncState *fs = ls->fs;\n  int reg = ls->fs->freereg;\n  expdesc key, val;\n  int rkkey;\n  if (ls->t.token == TK_NAME) {\n    checklimit(fs, cc->nh, MAX_INT, \"items in a constructor\");\n    checkname(ls, &key);\n  }\n  else   \n    yindex(ls, &key);\n  cc->nh++;\n  checknext(ls, '=');\n  rkkey = luaK_exp2RK(fs, &key);\n  expr(ls, &val);\n  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));\n  fs->freereg = reg;   \n}\n\n\nstatic void closelistfield (FuncState *fs, struct ConsControl *cc) {\n  if (cc->v.k == VVOID) return;   \n  luaK_exp2nextreg(fs, &cc->v);\n  cc->v.k = VVOID;\n  if (cc->tostore == LFIELDS_PER_FLUSH) {\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);   \n    cc->tostore = 0;   \n  }\n}\n\n\nstatic void lastlistfield (FuncState *fs, struct ConsControl *cc) {\n  if (cc->tostore == 0) return;\n  if (hasmultret(cc->v.k)) {\n    luaK_setmultret(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);\n    cc->na--;   \n  }\n  else {\n    if (cc->v.k != VVOID)\n      luaK_exp2nextreg(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);\n  }\n}\n\n\nstatic void listfield (LexState *ls, struct ConsControl *cc) {\n   \n  expr(ls, &cc->v);\n  checklimit(ls->fs, cc->na, MAX_INT, \"items in a constructor\");\n  cc->na++;\n  cc->tostore++;\n}\n\n\nstatic void field (LexState *ls, struct ConsControl *cc) {\n   \n  switch(ls->t.token) {\n    case TK_NAME: {   \n      if (luaX_lookahead(ls) != '=')   \n        listfield(ls, cc);\n      else\n        recfield(ls, cc);\n      break;\n    }\n    case '[': {\n      recfield(ls, cc);\n      break;\n    }\n    default: {\n      listfield(ls, cc);\n      break;\n    }\n  }\n}\n\n\nstatic void constructor (LexState *ls, expdesc *t) {\n   \n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n  struct ConsControl cc;\n  cc.na = cc.nh = cc.tostore = 0;\n  cc.t = t;\n  init_exp(t, VRELOCABLE, pc);\n  init_exp(&cc.v, VVOID, 0);   \n  luaK_exp2nextreg(ls->fs, t);   \n  checknext(ls, '{');\n  do {\n    lua_assert(cc.v.k == VVOID || cc.tostore > 0);\n    if (ls->t.token == '}') break;\n    closelistfield(fs, &cc);\n    field(ls, &cc);\n  } while (testnext(ls, ',') || testnext(ls, ';'));\n  check_match(ls, '}', '{', line);\n  lastlistfield(fs, &cc);\n  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na));  \n  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));   \n}\n\n \n\n\n\nstatic void parlist (LexState *ls) {\n   \n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  f->is_vararg = 0;\n  if (ls->t.token != ')') {   \n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {   \n          new_localvar(ls, str_checkname(ls));\n          nparams++;\n          break;\n        }\n        case TK_DOTS: {   \n          luaX_next(ls);\n          f->is_vararg = 1;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or \" LUA_QL(\"...\") \" expected\");\n      }\n    } while (!f->is_vararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar);\n  luaK_reserveregs(fs, fs->nactvar);   \n}\n\n\nstatic void body (LexState *ls, expdesc *e, int ismethod, int line) {\n   \n  FuncState new_fs;\n  BlockCnt bl;\n  new_fs.f = addprototype(ls);\n  new_fs.f->linedefined = line;\n  open_func(ls, &new_fs, &bl);\n  checknext(ls, '(');\n  if (ismethod) {\n    new_localvarliteral(ls, \"self\");   \n    adjustlocalvars(ls, 1);\n  }\n  parlist(ls);\n  checknext(ls, ')');\n  statlist(ls);\n  new_fs.f->lastlinedefined = ls->linenumber;\n  check_match(ls, TK_END, TK_FUNCTION, line);\n  codeclosure(ls, e);\n  close_func(ls);\n}\n\n\nstatic int explist (LexState *ls, expdesc *v) {\n   \n  int n = 1;   \n  expr(ls, v);\n  while (testnext(ls, ',')) {\n    luaK_exp2nextreg(ls->fs, v);\n    expr(ls, v);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void funcargs (LexState *ls, expdesc *f, int line) {\n  FuncState *fs = ls->fs;\n  expdesc args;\n  int base, nparams;\n  switch (ls->t.token) {\n    case '(': {   \n      luaX_next(ls);\n      if (ls->t.token == ')')   \n        args.k = VVOID;\n      else {\n        explist(ls, &args);\n        luaK_setmultret(fs, &args);\n      }\n      check_match(ls, ')', '(', line);\n      break;\n    }\n    case '{': {   \n      constructor(ls, &args);\n      break;\n    }\n    case TK_STRING: {   \n      codestring(ls, &args, ls->t.seminfo.ts);\n      luaX_next(ls);   \n      break;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"function arguments expected\");\n    }\n  }\n  lua_assert(f->k == VNONRELOC);\n  base = f->u.info;   \n  if (hasmultret(args.k))\n    nparams = LUA_MULTRET;   \n  else {\n    if (args.k != VVOID)\n      luaK_exp2nextreg(fs, &args);   \n    nparams = fs->freereg - (base+1);\n  }\n  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n  luaK_fixline(fs, line);\n  fs->freereg = base+1;   \n}\n\n\n\n\n \n\n\nstatic void primaryexp (LexState *ls, expdesc *v) {\n   \n  switch (ls->t.token) {\n    case '(': {\n      int line = ls->linenumber;\n      luaX_next(ls);\n      expr(ls, v);\n      check_match(ls, ')', '(', line);\n      luaK_dischargevars(ls->fs, v);\n      return;\n    }\n    case TK_NAME: {\n      singlevar(ls, v);\n      return;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"unexpected symbol\");\n    }\n  }\n}\n\n\nstatic void suffixedexp (LexState *ls, expdesc *v) {\n   \n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  primaryexp(ls, v);\n  for (;;) {\n    switch (ls->t.token) {\n      case '.': {   \n        fieldsel(ls, v);\n        break;\n      }\n      case '[': {   \n        expdesc key;\n        luaK_exp2anyregup(fs, v);\n        yindex(ls, &key);\n        luaK_indexed(fs, v, &key);\n        break;\n      }\n      case ':': {   \n        expdesc key;\n        luaX_next(ls);\n        checkname(ls, &key);\n        luaK_self(fs, v, &key);\n        funcargs(ls, v, line);\n        break;\n      }\n      case '(': case TK_STRING: case '{': {   \n        luaK_exp2nextreg(fs, v);\n        funcargs(ls, v, line);\n        break;\n      }\n      default: return;\n    }\n  }\n}\n\n\nstatic void simpleexp (LexState *ls, expdesc *v) {\n   \n  switch (ls->t.token) {\n    case TK_NUMBER: {\n      init_exp(v, VKNUM, 0);\n      v->u.nval = ls->t.seminfo.r;\n      break;\n    }\n    case TK_STRING: {\n      codestring(ls, v, ls->t.seminfo.ts);\n      break;\n    }\n    case TK_NIL: {\n      init_exp(v, VNIL, 0);\n      break;\n    }\n    case TK_TRUE: {\n      init_exp(v, VTRUE, 0);\n      break;\n    }\n    case TK_FALSE: {\n      init_exp(v, VFALSE, 0);\n      break;\n    }\n    case TK_DOTS: {   \n      FuncState *fs = ls->fs;\n      check_condition(ls, fs->f->is_vararg,\n                      \"cannot use \" LUA_QL(\"...\") \" outside a vararg function\");\n      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));\n      break;\n    }\n    case '{': {   \n      constructor(ls, v);\n      return;\n    }\n    case TK_FUNCTION: {\n      luaX_next(ls);\n      body(ls, v, 0, ls->linenumber);\n      return;\n    }\n    default: {\n      suffixedexp(ls, v);\n      return;\n    }\n  }\n  luaX_next(ls);\n}\n\n\nstatic UnOpr getunopr (int op) {\n  switch (op) {\n    case TK_NOT: return OPR_NOT;\n    case '-': return OPR_MINUS;\n    case '#': return OPR_LEN;\n    default: return OPR_NOUNOPR;\n  }\n}\n\n\nstatic BinOpr getbinopr (int op) {\n  switch (op) {\n    case '+': return OPR_ADD;\n    case '-': return OPR_SUB;\n    case '*': return OPR_MUL;\n    case '/': return OPR_DIV;\n    case '%': return OPR_MOD;\n    case '^': return OPR_POW;\n    case TK_CONCAT: return OPR_CONCAT;\n    case TK_NE: return OPR_NE;\n    case TK_EQ: return OPR_EQ;\n    case '<': return OPR_LT;\n    case TK_LE: return OPR_LE;\n    case '>': return OPR_GT;\n    case TK_GE: return OPR_GE;\n    case TK_AND: return OPR_AND;\n    case TK_OR: return OPR_OR;\n    default: return OPR_NOBINOPR;\n  }\n}\n\n\nstatic const struct {\n  lu_byte left;   \n  lu_byte right;  \n} priority[] = {   \n   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},   \n   {10, 9}, {5, 4},                  \n   {3, 3}, {3, 3}, {3, 3},           \n   {3, 3}, {3, 3}, {3, 3},           \n   {2, 2}, {1, 1}                    \n};\n\n#define UNARY_PRIORITY\t8   \n\n\n \nstatic BinOpr subexpr (LexState *ls, expdesc *v, int limit) {\n  BinOpr op;\n  UnOpr uop;\n  enterlevel(ls);\n  uop = getunopr(ls->t.token);\n  if (uop != OPR_NOUNOPR) {\n    int line = ls->linenumber;\n    luaX_next(ls);\n    subexpr(ls, v, UNARY_PRIORITY);\n    luaK_prefix(ls->fs, uop, v, line);\n  }\n  else simpleexp(ls, v);\n   \n  op = getbinopr(ls->t.token);\n  while (op != OPR_NOBINOPR && priority[op].left > limit) {\n    expdesc v2;\n    BinOpr nextop;\n    int line = ls->linenumber;\n    luaX_next(ls);\n    luaK_infix(ls->fs, op, v);\n     \n    nextop = subexpr(ls, &v2, priority[op].right);\n    luaK_posfix(ls->fs, op, v, &v2, line);\n    op = nextop;\n  }\n  leavelevel(ls);\n  return op;   \n}\n\n\nstatic void expr (LexState *ls, expdesc *v) {\n  subexpr(ls, v, 0);\n}\n\n \n\n\n\n \n\n\nstatic void block (LexState *ls) {\n   \n  FuncState *fs = ls->fs;\n  BlockCnt bl;\n  enterblock(fs, &bl, 0);\n  statlist(ls);\n  leaveblock(fs);\n}\n\n\n \nstruct LHS_assign {\n  struct LHS_assign *prev;\n  expdesc v;   \n};\n\n\n \nstatic void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {\n  FuncState *fs = ls->fs;\n  int extra = fs->freereg;   \n  int conflict = 0;\n  for (; lh; lh = lh->prev) {   \n    if (lh->v.k == VINDEXED) {   \n       \n      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {\n        conflict = 1;\n        lh->v.u.ind.vt = VLOCAL;\n        lh->v.u.ind.t = extra;   \n      }\n       \n      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {\n        conflict = 1;\n        lh->v.u.ind.idx = extra;   \n      }\n    }\n  }\n  if (conflict) {\n     \n    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;\n    luaK_codeABC(fs, op, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n\nstatic void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {\n  expdesc e;\n  check_condition(ls, vkisvar(lh->v.k), \"syntax error\");\n  if (testnext(ls, ',')) {   \n    struct LHS_assign nv;\n    nv.prev = lh;\n    suffixedexp(ls, &nv.v);\n    if (nv.v.k != VINDEXED)\n      check_conflict(ls, lh, &nv.v);\n    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,\n                    \"C levels\");\n    assignment(ls, &nv, nvars+1);\n  }\n  else {   \n    int nexps;\n    checknext(ls, '=');\n    nexps = explist(ls, &e);\n    if (nexps != nvars) {\n      adjust_assign(ls, nvars, nexps, &e);\n      if (nexps > nvars)\n        ls->fs->freereg -= nexps - nvars;   \n    }\n    else {\n      luaK_setoneret(ls->fs, &e);   \n      luaK_storevar(ls->fs, &lh->v, &e);\n      return;   \n    }\n  }\n  init_exp(&e, VNONRELOC, ls->fs->freereg-1);   \n  luaK_storevar(ls->fs, &lh->v, &e);\n}\n\n\nstatic int cond (LexState *ls) {\n   \n  expdesc v;\n  expr(ls, &v);   \n  if (v.k == VNIL) v.k = VFALSE;   \n  luaK_goiftrue(ls->fs, &v);\n  return v.f;\n}\n\n\nstatic void gotostat (LexState *ls, int pc) {\n  int line = ls->linenumber;\n  TString *label;\n  int g;\n  if (testnext(ls, TK_GOTO))\n    label = str_checkname(ls);\n  else {\n    luaX_next(ls);   \n    label = luaS_new(ls->L, \"break\");\n  }\n  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);\n  findlabel(ls, g);   \n}\n\n\n \nstatic void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {\n  int i;\n  for (i = fs->bl->firstlabel; i < ll->n; i++) {\n    if (luaS_eqstr(label, ll->arr[i].name)) {\n      const char *msg = luaO_pushfstring(fs->ls->L,\n                          \"label \" LUA_QS \" already defined on line %d\",\n                          getstr(label), ll->arr[i].line);\n      semerror(fs->ls, msg);\n    }\n  }\n}\n\n\n \nstatic void skipnoopstat (LexState *ls) {\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);\n}\n\n\nstatic void labelstat (LexState *ls, TString *label, int line) {\n   \n  FuncState *fs = ls->fs;\n  Labellist *ll = &ls->dyd->label;\n  int l;   \n  checkrepeated(fs, ll, label);   \n  checknext(ls, TK_DBCOLON);   \n   \n  l = newlabelentry(ls, ll, label, line, fs->pc);\n  skipnoopstat(ls);   \n  if (block_follow(ls, 0)) {   \n     \n    ll->arr[l].nactvar = fs->bl->nactvar;\n  }\n  findgotos(ls, &ll->arr[l]);\n}\n\n\nstatic void whilestat (LexState *ls, int line) {\n   \n  FuncState *fs = ls->fs;\n  int whileinit;\n  int condexit;\n  BlockCnt bl;\n  luaX_next(ls);   \n  whileinit = luaK_getlabel(fs);\n  condexit = cond(ls);\n  enterblock(fs, &bl, 1);\n  checknext(ls, TK_DO);\n  block(ls);\n  luaK_jumpto(fs, whileinit);\n  check_match(ls, TK_END, TK_WHILE, line);\n  leaveblock(fs);\n  luaK_patchtohere(fs, condexit);   \n}\n\n\nstatic void repeatstat (LexState *ls, int line) {\n   \n  int condexit;\n  FuncState *fs = ls->fs;\n  int repeat_init = luaK_getlabel(fs);\n  BlockCnt bl1, bl2;\n  enterblock(fs, &bl1, 1);   \n  enterblock(fs, &bl2, 0);   \n  luaX_next(ls);   \n  statlist(ls);\n  check_match(ls, TK_UNTIL, TK_REPEAT, line);\n  condexit = cond(ls);   \n  if (bl2.upval)   \n    luaK_patchclose(fs, condexit, bl2.nactvar);\n  leaveblock(fs);   \n  luaK_patchlist(fs, condexit, repeat_init);   \n  leaveblock(fs);   \n}\n\n\nstatic int exp1 (LexState *ls) {\n  expdesc e;\n  int reg;\n  expr(ls, &e);\n  luaK_exp2nextreg(ls->fs, &e);\n  lua_assert(e.k == VNONRELOC);\n  reg = e.u.info;\n  return reg;\n}\n\n\nstatic void forbody (LexState *ls, int base, int line, int nvars, int isnum) {\n   \n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  int prep, endfor;\n  adjustlocalvars(ls, 3);   \n  checknext(ls, TK_DO);\n  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);\n  enterblock(fs, &bl, 0);   \n  adjustlocalvars(ls, nvars);\n  luaK_reserveregs(fs, nvars);\n  block(ls);\n  leaveblock(fs);   \n  luaK_patchtohere(fs, prep);\n  if (isnum)   \n    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);\n  else {   \n    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n    luaK_fixline(fs, line);\n    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);\n  }\n  luaK_patchlist(fs, endfor, prep + 1);\n  luaK_fixline(fs, line);\n}\n\n\nstatic void fornum (LexState *ls, TString *varname, int line) {\n   \n  FuncState *fs = ls->fs;\n  int base = fs->freereg;\n  new_localvarliteral(ls, \"(for index)\");\n  new_localvarliteral(ls, \"(for limit)\");\n  new_localvarliteral(ls, \"(for step)\");\n  new_localvar(ls, varname);\n  checknext(ls, '=');\n  exp1(ls);   \n  checknext(ls, ',');\n  exp1(ls);   \n  if (testnext(ls, ','))\n    exp1(ls);   \n  else {   \n    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));\n    luaK_reserveregs(fs, 1);\n  }\n  forbody(ls, base, line, 1, 1);\n}\n\n\nstatic void forlist (LexState *ls, TString *indexname) {\n   \n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nvars = 4;   \n  int line;\n  int base = fs->freereg;\n   \n  new_localvarliteral(ls, \"(for generator)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for control)\");\n   \n  new_localvar(ls, indexname);\n  while (testnext(ls, ',')) {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  }\n  checknext(ls, TK_IN);\n  line = ls->linenumber;\n  adjust_assign(ls, 3, explist(ls, &e), &e);\n  luaK_checkstack(fs, 3);   \n  forbody(ls, base, line, nvars - 3, 0);\n}\n\n\nstatic void forstat (LexState *ls, int line) {\n   \n  FuncState *fs = ls->fs;\n  TString *varname;\n  BlockCnt bl;\n  enterblock(fs, &bl, 1);   \n  luaX_next(ls);   \n  varname = str_checkname(ls);   \n  switch (ls->t.token) {\n    case '=': fornum(ls, varname, line); break;\n    case ',': case TK_IN: forlist(ls, varname); break;\n    default: luaX_syntaxerror(ls, LUA_QL(\"=\") \" or \" LUA_QL(\"in\") \" expected\");\n  }\n  check_match(ls, TK_END, TK_FOR, line);\n  leaveblock(fs);   \n}\n\n\n__attribute__((always_inline)) inline\nstatic void test_then_block (LexState *ls, int *escapelist) {\n   \n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  expdesc v;\n  int jf;   \n  luaX_next(ls);   \n  expr(ls, &v);   \n  checknext(ls, TK_THEN);\n  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {\n    luaK_goiffalse(ls->fs, &v);   \n    enterblock(fs, &bl, 0);   \n    gotostat(ls, v.t);   \n    skipnoopstat(ls);   \n    if (block_follow(ls, 0)) {   \n      leaveblock(fs);\n      return;   \n    }\n    else   \n      jf = luaK_jump(fs);\n  }\n  else {   \n    luaK_goiftrue(ls->fs, &v);   \n    enterblock(fs, &bl, 0);\n    jf = v.f;\n  }\n  statlist(ls);   \n  leaveblock(fs);\n  if (ls->t.token == TK_ELSE ||\n      ls->t.token == TK_ELSEIF)   \n    luaK_concat(fs, escapelist, luaK_jump(fs));   \n  luaK_patchtohere(fs, jf);\n}\n\n\nstatic void ifstat (LexState *ls, int line) {\n   \n  FuncState *fs = ls->fs;\n  int escapelist = NO_JUMP;   \n  test_then_block(ls, &escapelist);   \n  while (ls->t.token == TK_ELSEIF)\n    test_then_block(ls, &escapelist);   \n  if (testnext(ls, TK_ELSE))\n    block(ls);   \n  check_match(ls, TK_END, TK_IF, line);\n  luaK_patchtohere(fs, escapelist);   \n}\n\n\nstatic void localfunc (LexState *ls) {\n  expdesc b;\n  FuncState *fs = ls->fs;\n  new_localvar(ls, str_checkname(ls));   \n  adjustlocalvars(ls, 1);   \n  body(ls, &b, 0, ls->linenumber);   \n   \n  getlocvar(fs, b.u.info)->startpc = fs->pc;\n}\n\n\nstatic void localstat (LexState *ls) {\n   \n  int nvars = 0;\n  int nexps;\n  expdesc e;\n  do {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  } while (testnext(ls, ','));\n  if (testnext(ls, '='))\n    nexps = explist(ls, &e);\n  else {\n    e.k = VVOID;\n    nexps = 0;\n  }\n  adjust_assign(ls, nvars, nexps, &e);\n  adjustlocalvars(ls, nvars);\n}\n\n\nstatic int funcname (LexState *ls, expdesc *v) {\n   \n  int ismethod = 0;\n  singlevar(ls, v);\n  while (ls->t.token == '.')\n    fieldsel(ls, v);\n  if (ls->t.token == ':') {\n    ismethod = 1;\n    fieldsel(ls, v);\n  }\n  return ismethod;\n}\n\n\nstatic void funcstat (LexState *ls, int line) {\n   \n  int ismethod;\n  expdesc v, b;\n  luaX_next(ls);   \n  ismethod = funcname(ls, &v);\n  body(ls, &b, ismethod, line);\n  luaK_storevar(ls->fs, &v, &b);\n  luaK_fixline(ls->fs, line);   \n}\n\n\nstatic void exprstat (LexState *ls) {\n   \n  FuncState *fs = ls->fs;\n  struct LHS_assign v;\n  suffixedexp(ls, &v.v);\n  if (ls->t.token == '=' || ls->t.token == ',') {  \n    v.prev = NULL;\n    assignment(ls, &v, 1);\n  }\n  else {   \n    check_condition(ls, v.v.k == VCALL, \"syntax error\");\n    SETARG_C(getcode(fs, &v.v), 1);   \n  }\n}\n\n\nstatic void retstat (LexState *ls) {\n   \n  FuncState *fs = ls->fs;\n  expdesc e;\n  int first, nret;   \n  if (block_follow(ls, 1) || ls->t.token == ';')\n    first = nret = 0;   \n  else {\n    nret = explist(ls, &e);   \n    if (hasmultret(e.k)) {\n      luaK_setmultret(fs, &e);\n      if (e.k == VCALL && nret == 1) {   \n        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);\n        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);\n      }\n      first = fs->nactvar;\n      nret = LUA_MULTRET;   \n    }\n    else {\n      if (nret == 1)   \n        first = luaK_exp2anyreg(fs, &e);\n      else {\n        luaK_exp2nextreg(fs, &e);   \n        first = fs->nactvar;   \n        lua_assert(nret == fs->freereg - first);\n      }\n    }\n  }\n  luaK_ret(fs, first, nret);\n  (void) testnext(ls, ';');   \n}\n\n\nstatic void statement (LexState *ls) {\n  int line = ls->linenumber;   \n  enterlevel(ls);\n  switch (ls->t.token) {\n    case ';': {   \n      luaX_next(ls);   \n      break;\n    }\n    case TK_IF: {   \n      ifstat(ls, line);\n      break;\n    }\n    case TK_WHILE: {   \n      whilestat(ls, line);\n      break;\n    }\n    case TK_DO: {   \n      luaX_next(ls);   \n      block(ls);\n      check_match(ls, TK_END, TK_DO, line);\n      break;\n    }\n    case TK_FOR: {   \n      forstat(ls, line);\n      break;\n    }\n    case TK_REPEAT: {   \n      repeatstat(ls, line);\n      break;\n    }\n    case TK_FUNCTION: {   \n      funcstat(ls, line);\n      break;\n    }\n    case TK_LOCAL: {   \n      luaX_next(ls);   \n      if (testnext(ls, TK_FUNCTION))   \n        localfunc(ls);\n      else\n        localstat(ls);\n      break;\n    }\n    case TK_DBCOLON: {   \n      luaX_next(ls);   \n      labelstat(ls, str_checkname(ls), line);\n      break;\n    }\n    case TK_RETURN: {   \n      luaX_next(ls);   \n      retstat(ls);\n      break;\n    }\n    case TK_BREAK:    \n    case TK_GOTO: {   \n      gotostat(ls, luaK_jump(ls->fs));\n      break;\n    }\n    default: {   \n      exprstat(ls);\n      break;\n    }\n  }\n  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&\n             ls->fs->freereg >= ls->fs->nactvar);\n  ls->fs->freereg = ls->fs->nactvar;   \n  leavelevel(ls);\n}\n\n \n\n\n \nstatic void mainfunc (LexState *ls, FuncState *fs) {\n  BlockCnt bl;\n  expdesc v;\n  open_func(ls, fs, &bl);\n  fs->f->is_vararg = 1;   \n  init_exp(&v, VLOCAL, 0);   \n  newupvalue(fs, ls->envn, &v);   \n  luaX_next(ls);   \n  statlist(ls);   \n  check(ls, TK_EOS);\n  close_func(ls);\n}\n\n\nClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                      Dyndata *dyd, const char *name, int firstchar) {\n  LexState lexstate;\n  FuncState funcstate;\n  Closure *cl = luaF_newLclosure(L, 1);   \n   \n  setclLvalue(L, L->top, cl);\n  incr_top(L);\n  funcstate.f = cl->l.p = luaF_newproto(L);\n  funcstate.f->source = luaS_new(L, name);   \n  lexstate.buff = buff;\n  lexstate.dyd = dyd;\n  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;\n  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);\n  mainfunc(&lexstate, &funcstate);\n  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);\n   \n  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);\n  return cl;   \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}