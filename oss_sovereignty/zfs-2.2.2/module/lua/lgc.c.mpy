{
  "module_name": "lgc.c",
  "hash_id": "4ebcb5069bea5ab1e11bc6b98980e0ad791e07b70a036e5888f8da471cae8b36",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lgc.c",
  "human_readable_source": " \n\n#define lgc_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n\n \n#define GCSWEEPCOST\t((sizeof(TString) + 4) / 4)\n\n \n#define GCSWEEPMAX\t(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))\n\n \n#define GCFINALIZENUM\t4\n\n\n \n#define STEPMULADJ\t\t200\n\n\n \n#define PAUSEADJ\t\t100\n\n\n \n#define maskcolors\t(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))\n#define makewhite(g,x)\t\\\n (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))\n\n#define white2gray(x)\tresetbits(gch(x)->marked, WHITEBITS)\n#define black2gray(x)\tresetbit(gch(x)->marked, BLACKBIT)\n\n\n#define isfinalized(x)\t\ttestbit(gch(x)->marked, FINALIZEDBIT)\n\n#define checkdeadkey(n)\tlua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))\n\n\n#define checkconsistency(obj)  \\\n  lua_longassert(!iscollectable(obj) || righttt(obj))\n\n\n#define markvalue(g,o) { checkconsistency(o); \\\n  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }\n\n#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \\\n\t\treallymarkobject(g, obj2gco(t)); }\n\nstatic void reallymarkobject (global_State *g, GCObject *o);\n\n\n \n\n\n \n#define gnodelast(h)\tgnode(h, cast(size_t, sizenode(h)))\n\n\n \n#define linktable(h,p)\t((h)->gclist = *(p), *(p) = obj2gco(h))\n\n\n \nstatic void removeentry (Node *n) {\n  lua_assert(ttisnil(gval(n)));\n  if (valiswhite(gkey(n)))\n    setdeadvalue(gkey(n));   \n}\n\n\n \nstatic int iscleared (global_State *g, const TValue *o) {\n  if (!iscollectable(o)) return 0;\n  else if (ttisstring(o)) {\n    markobject(g, rawtsvalue(o));   \n    return 0;\n  }\n  else return iswhite(gcvalue(o));\n}\n\n\n \nvoid luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  lua_assert(g->gcstate != GCSpause);\n  lua_assert(gch(o)->tt != LUA_TTABLE);\n  if (keepinvariantout(g))   \n    reallymarkobject(g, v);   \n  else {   \n    lua_assert(issweepphase(g));\n    makewhite(g, o);   \n  }\n}\n\n\n \nvoid luaC_barrierback_ (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);\n  black2gray(o);   \n  gco2t(o)->gclist = g->grayagain;\n  g->grayagain = o;\n}\n\n\n \nLUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {\n  global_State *g = G(L);\n  lua_assert(isblack(obj2gco(p)));\n  if (p->cache == NULL) {   \n    luaC_objbarrier(L, p, c);\n  }\n  else {   \n    black2gray(obj2gco(p));   \n    p->gclist = g->grayagain;\n    g->grayagain = obj2gco(p);\n  }\n}\n\n\n \nvoid luaC_checkupvalcolor (global_State *g, UpVal *uv) {\n  GCObject *o = obj2gco(uv);\n  lua_assert(!isblack(o));   \n  if (isgray(o)) {\n    if (keepinvariant(g)) {\n      resetoldbit(o);   \n      gray2black(o);   \n      markvalue(g, uv->v);\n    }\n    else {\n      lua_assert(issweepphase(g));\n      makewhite(g, o);\n    }\n  }\n}\n\n\n \nGCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,\n                       int offset) {\n  global_State *g = G(L);\n  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));\n  GCObject *o = obj2gco(raw + offset);\n  if (list == NULL)\n    list = &g->allgc;   \n  gch(o)->marked = luaC_white(g);\n  gch(o)->tt = tt;\n  gch(o)->next = *list;\n  *list = o;\n  return o;\n}\n\n \n\n\n\n \n\n\n \nstatic void reallymarkobject (global_State *g, GCObject *o) {\n  lu_mem size;\n  white2gray(o);\n  switch (gch(o)->tt) {\n    case LUA_TSHRSTR:\n    case LUA_TLNGSTR: {\n      size = sizestring(gco2ts(o));\n      break;   \n    }\n    case LUA_TUSERDATA: {\n      Table *mt = gco2u(o)->metatable;\n      markobject(g, mt);\n      markobject(g, gco2u(o)->env);\n      size = sizeudata(gco2u(o));\n      break;\n    }\n    case LUA_TUPVAL: {\n      UpVal *uv = gco2uv(o);\n      markvalue(g, uv->v);\n      if (uv->v != &uv->u.value)   \n        return;   \n      size = sizeof(UpVal);\n      break;\n    }\n    case LUA_TLCL: {\n      gco2lcl(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    case LUA_TCCL: {\n      gco2ccl(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    case LUA_TTABLE: {\n      linktable(gco2t(o), &g->gray);\n      return;\n    }\n    case LUA_TTHREAD: {\n      gco2th(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    case LUA_TPROTO: {\n      gco2p(o)->gclist = g->gray;\n      g->gray = o;\n      return;\n    }\n    default: lua_assert(0); return;\n  }\n  gray2black(o);\n  g->GCmemtrav += size;\n}\n\n\n \nstatic void markmt (global_State *g) {\n  int i;\n  for (i=0; i < LUA_NUMTAGS; i++)\n    markobject(g, g->mt[i]);\n}\n\n\n \nstatic void markbeingfnz (global_State *g) {\n  GCObject *o;\n  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {\n    makewhite(g, o);\n    reallymarkobject(g, o);\n  }\n}\n\n\n \nstatic void remarkupvals (global_State *g) {\n  UpVal *uv;\n  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {\n    if (isgray(obj2gco(uv)))\n      markvalue(g, uv->v);\n  }\n}\n\n\n \nstatic void restartcollection (global_State *g) {\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);   \n}\n\n \n\n\n \n\nstatic void traverseweakvalue (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n   \n  int hasclears = (h->sizearray > 0);\n  for (n = gnode(h, 0); n < limit; n++) {\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))   \n      removeentry(n);   \n    else {\n      lua_assert(!ttisnil(gkey(n)));\n      markvalue(g, gkey(n));   \n      if (!hasclears && iscleared(g, gval(n)))   \n        hasclears = 1;   \n    }\n  }\n  if (hasclears)\n    linktable(h, &g->weak);   \n  else   \n    linktable(h, &g->grayagain);   \n}\n\n\nstatic int traverseephemeron (global_State *g, Table *h) {\n  int marked = 0;   \n  int hasclears = 0;   \n  int prop = 0;   \n  Node *n, *limit = gnodelast(h);\n  int i;\n   \n  for (i = 0; i < h->sizearray; i++) {\n    if (valiswhite(&h->array[i])) {\n      marked = 1;\n      reallymarkobject(g, gcvalue(&h->array[i]));\n    }\n  }\n   \n  for (n = gnode(h, 0); n < limit; n++) {\n    checkdeadkey(n);\n    if (ttisnil(gval(n)))   \n      removeentry(n);   \n    else if (iscleared(g, gkey(n))) {   \n      hasclears = 1;   \n      if (valiswhite(gval(n)))   \n        prop = 1;   \n    }\n    else if (valiswhite(gval(n))) {   \n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));   \n    }\n  }\n  if (g->gcstate != GCSatomic || prop)\n    linktable(h, &g->ephemeron);   \n  else if (hasclears)   \n    linktable(h, &g->allweak);   \n  else   \n    linktable(h, &g->grayagain);   \n  return marked;\n}\n\n\nstatic void traversestrongtable (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  int i;\n  for (i = 0; i < h->sizearray; i++)   \n    markvalue(g, &h->array[i]);\n  for (n = gnode(h, 0); n < limit; n++) {   \n    checkdeadkey(n);\n    if (ttisnil(gval(n)))   \n      removeentry(n);   \n    else {\n      lua_assert(!ttisnil(gkey(n)));\n      markvalue(g, gkey(n));   \n      markvalue(g, gval(n));   \n    }\n  }\n}\n\n\nstatic lu_mem traversetable (global_State *g, Table *h) {\n  const char *weakkey, *weakvalue;\n  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);\n  markobject(g, h->metatable);\n  if (mode && ttisstring(mode) &&   \n      ((weakkey = strchr(svalue(mode), 'k')),\n       (weakvalue = strchr(svalue(mode), 'v')),\n       (weakkey || weakvalue))) {   \n    black2gray(obj2gco(h));   \n    if (!weakkey)   \n      traverseweakvalue(g, h);\n    else if (!weakvalue)   \n      traverseephemeron(g, h);\n    else   \n      linktable(h, &g->allweak);   \n  }\n  else   \n    traversestrongtable(g, h);\n  return sizeof(Table) + sizeof(TValue) * h->sizearray +\n                         sizeof(Node) * cast(size_t, sizenode(h));\n}\n\n\nstatic int traverseproto (global_State *g, Proto *f) {\n  int i;\n  if (f->cache && iswhite(obj2gco(f->cache)))\n    f->cache = NULL;   \n  markobject(g, f->source);\n  for (i = 0; i < f->sizek; i++)   \n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)   \n    markobject(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)   \n    markobject(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)   \n    markobject(g, f->locvars[i].varname);\n  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +\n                         sizeof(Proto *) * f->sizep +\n                         sizeof(TValue) * f->sizek +\n                         sizeof(int) * f->sizelineinfo +\n                         sizeof(LocVar) * f->sizelocvars +\n                         sizeof(Upvaldesc) * f->sizeupvalues;\n}\n\n\nstatic lu_mem traverseCclosure (global_State *g, CClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)   \n    markvalue(g, &cl->upvalue[i]);\n  return sizeCclosure(cl->nupvalues);\n}\n\nstatic lu_mem traverseLclosure (global_State *g, LClosure *cl) {\n  int i;\n  markobject(g, cl->p);   \n  for (i = 0; i < cl->nupvalues; i++)   \n    markobject(g, cl->upvals[i]);\n  return sizeLclosure(cl->nupvalues);\n}\n\n\nstatic lu_mem traversestack (global_State *g, lua_State *th) {\n  int n = 0;\n  StkId o = th->stack;\n  if (o == NULL)\n    return 1;   \n  for (; o < th->top; o++)   \n    markvalue(g, o);\n  if (g->gcstate == GCSatomic) {   \n    StkId lim = th->stack + th->stacksize;   \n    for (; o < lim; o++)   \n      setnilvalue(o);\n  }\n  else {   \n    CallInfo *ci;\n    for (ci = &th->base_ci; ci != th->ci; ci = ci->next)\n      n++;\n  }\n  return sizeof(lua_State) + sizeof(TValue) * th->stacksize +\n         sizeof(CallInfo) * n;\n}\n\n\n \nstatic void propagatemark (global_State *g) {\n  lu_mem size;\n  GCObject *o = g->gray;\n  lua_assert(isgray(o));\n  gray2black(o);\n  switch (gch(o)->tt) {\n    case LUA_TTABLE: {\n      Table *h = gco2t(o);\n      g->gray = h->gclist;   \n      size = traversetable(g, h);\n      break;\n    }\n    case LUA_TLCL: {\n      LClosure *cl = gco2lcl(o);\n      g->gray = cl->gclist;   \n      size = traverseLclosure(g, cl);\n      break;\n    }\n    case LUA_TCCL: {\n      CClosure *cl = gco2ccl(o);\n      g->gray = cl->gclist;   \n      size = traverseCclosure(g, cl);\n      break;\n    }\n    case LUA_TTHREAD: {\n      lua_State *th = gco2th(o);\n      g->gray = th->gclist;   \n      th->gclist = g->grayagain;\n      g->grayagain = o;   \n      black2gray(o);\n      size = traversestack(g, th);\n      break;\n    }\n    case LUA_TPROTO: {\n      Proto *p = gco2p(o);\n      g->gray = p->gclist;   \n      size = traverseproto(g, p);\n      break;\n    }\n    default: lua_assert(0); return;\n  }\n  g->GCmemtrav += size;\n}\n\n\nstatic void propagateall (global_State *g) {\n  while (g->gray) propagatemark(g);\n}\n\n\nstatic void propagatelist (global_State *g, GCObject *l) {\n  lua_assert(g->gray == NULL);   \n  g->gray = l;\n  propagateall(g);   \n}\n\n \nstatic void retraversegrays (global_State *g) {\n  GCObject *weak = g->weak;   \n  GCObject *grayagain = g->grayagain;\n  GCObject *ephemeron = g->ephemeron;\n  g->weak = g->grayagain = g->ephemeron = NULL;\n  propagateall(g);   \n  propagatelist(g, grayagain);\n  propagatelist(g, weak);\n  propagatelist(g, ephemeron);\n}\n\n\nstatic void convergeephemerons (global_State *g) {\n  int changed;\n  do {\n    GCObject *w;\n    GCObject *next = g->ephemeron;   \n    g->ephemeron = NULL;   \n    changed = 0;\n    while ((w = next) != NULL) {\n      next = gco2t(w)->gclist;\n      if (traverseephemeron(g, gco2t(w))) {   \n        propagateall(g);   \n        changed = 1;   \n      }\n    }\n  } while (changed);\n}\n\n \n\n\n \n\n\n \nstatic void clearkeys (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {\n        setnilvalue(gval(n));   \n        removeentry(n);   \n      }\n    }\n  }\n}\n\n\n \nstatic void clearvalues (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    int i;\n    for (i = 0; i < h->sizearray; i++) {\n      TValue *o = &h->array[i];\n      if (iscleared(g, o))   \n        setnilvalue(o);   \n    }\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {\n        setnilvalue(gval(n));   \n        removeentry(n);   \n      }\n    }\n  }\n}\n\n\nstatic void freeobj (lua_State *L, GCObject *o) {\n  switch (gch(o)->tt) {\n    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;\n    case LUA_TLCL: {\n      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));\n      break;\n    }\n    case LUA_TCCL: {\n      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));\n      break;\n    }\n    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;\n    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;\n    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;\n    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;\n    case LUA_TSHRSTR:\n      G(L)->strt.nuse--;\n      zfs_fallthrough;\n    case LUA_TLNGSTR: {\n      luaM_freemem(L, o, sizestring(gco2ts(o)));\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\n#define sweepwholelist(L,p)\tsweeplist(L,p,MAX_LUMEM)\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);\n\n\n \nstatic void sweepthread (lua_State *L, lua_State *L1) {\n  if (L1->stack == NULL) return;   \n  sweepwholelist(L, &L1->openupval);   \n  luaE_freeCI(L1);   \n   \n  if (G(L)->gckind != KGC_EMERGENCY)\n    luaD_shrinkstack(L1);\n}\n\n\n \nstatic GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  int toclear, toset;   \n  int tostop;   \n  if (isgenerational(g)) {   \n    toclear = ~0;   \n    toset = bitmask(OLDBIT);   \n    tostop = bitmask(OLDBIT);   \n  }\n  else {   \n    toclear = maskcolors;   \n    toset = luaC_white(g);   \n    tostop = 0;   \n  }\n  while (*p != NULL && count-- > 0) {\n    GCObject *curr = *p;\n    int marked = gch(curr)->marked;\n    if (isdeadm(ow, marked)) {   \n      *p = gch(curr)->next;   \n      freeobj(L, curr);   \n    }\n    else {\n      if (testbits(marked, tostop))\n        return NULL;   \n      if (gch(curr)->tt == LUA_TTHREAD)\n        sweepthread(L, gco2th(curr));   \n       \n      gch(curr)->marked = cast_byte((marked & toclear) | toset);\n      p = &gch(curr)->next;   \n    }\n  }\n  return (*p == NULL) ? NULL : p;\n}\n\n\n \nstatic GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {\n  GCObject ** old = p;\n  int i = 0;\n  do {\n    i++;\n    p = sweeplist(L, p, 1);\n  } while (p == old);\n  if (n) *n += i;\n  return p;\n}\n\n \n\n\n \n\nstatic void checkSizes (lua_State *L) {\n  global_State *g = G(L);\n  if (g->gckind != KGC_EMERGENCY) {   \n    int hs = g->strt.size / 2;   \n    if (g->strt.nuse < cast(lu_int32, hs))   \n      luaS_resize(L, hs);   \n    luaZ_freebuffer(L, &g->buff);   \n  }\n}\n\n\nstatic GCObject *udata2finalize (global_State *g) {\n  GCObject *o = g->tobefnz;   \n  lua_assert(isfinalized(o));\n  g->tobefnz = gch(o)->next;   \n  gch(o)->next = g->allgc;   \n  g->allgc = o;\n  resetbit(gch(o)->marked, SEPARATED);   \n  lua_assert(!isold(o));   \n  if (!keepinvariantout(g))   \n    makewhite(g, o);   \n  return o;\n}\n\n\nstatic void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_call(L, L->top - 2, 0, 0);\n}\n\n\nstatic void GCTM (lua_State *L, int propagateerrors) {\n  global_State *g = G(L);\n  const TValue *tm;\n  TValue v;\n  setgcovalue(L, &v, udata2finalize(g));\n  tm = luaT_gettmbyobj(L, &v, TM_GC);\n  if (tm != NULL && ttisfunction(tm)) {   \n    int status;\n    lu_byte oldah = L->allowhook;\n    int running  = g->gcrunning;\n    L->allowhook = 0;   \n    g->gcrunning = 0;   \n    setobj2s(L, L->top, tm);   \n    setobj2s(L, L->top + 1, &v);   \n    L->top += 2;   \n    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);\n    L->allowhook = oldah;   \n    g->gcrunning = running;   \n    if (status != LUA_OK && propagateerrors) {   \n      if (status == LUA_ERRRUN) {   \n        const char *msg = (ttisstring(L->top - 1))\n                            ? svalue(L->top - 1)\n                            : \"no message\";\n        luaO_pushfstring(L, \"error in __gc metamethod (%s)\", msg);\n        status = LUA_ERRGCMM;   \n      }\n      luaD_throw(L, status);   \n    }\n  }\n}\n\n\n \nstatic void separatetobefnz (lua_State *L, int all) {\n  global_State *g = G(L);\n  GCObject **p = &g->finobj;\n  GCObject *curr;\n  GCObject **lastnext = &g->tobefnz;\n   \n  while (*lastnext != NULL)\n    lastnext = &gch(*lastnext)->next;\n  while ((curr = *p) != NULL) {   \n    lua_assert(!isfinalized(curr));\n    lua_assert(testbit(gch(curr)->marked, SEPARATED));\n    if (!(iswhite(curr) || all))   \n      p = &gch(curr)->next;   \n    else {\n      l_setbit(gch(curr)->marked, FINALIZEDBIT);  \n      *p = gch(curr)->next;   \n      gch(curr)->next = *lastnext;   \n      *lastnext = curr;\n      lastnext = &gch(curr)->next;\n    }\n  }\n}\n\n\n \nvoid luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {\n  global_State *g = G(L);\n  if (testbit(gch(o)->marked, SEPARATED) ||  \n      isfinalized(o) ||                            \n      gfasttm(g, mt, TM_GC) == NULL)                 \n    return;   \n  else {   \n    GCObject **p;\n    GCheader *ho = gch(o);\n    if (g->sweepgc == &ho->next) {   \n      lua_assert(issweepphase(g));\n      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);\n    }\n     \n    for (p = &g->allgc; *p != o; p = &gch(*p)->next) {   }\n    *p = ho->next;   \n    ho->next = g->finobj;   \n    g->finobj = o;\n    l_setbit(ho->marked, SEPARATED);   \n    if (!keepinvariantout(g))   \n      makewhite(g, o);   \n    else\n      resetoldbit(o);   \n  }\n}\n\n \n\n\n \n\n\n \nstatic void setpause (global_State *g, l_mem estimate) {\n  l_mem debt, threshold;\n  estimate = estimate / PAUSEADJ;   \n  threshold = (g->gcpause < MAX_LMEM / estimate)   \n            ? estimate * g->gcpause   \n            : MAX_LMEM;   \n  debt = -cast(l_mem, threshold - gettotalbytes(g));\n  luaE_setdebt(g, debt);\n}\n\n\n#define sweepphases  \\\n\t(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))\n\n\n \nstatic int entersweep (lua_State *L) {\n  global_State *g = G(L);\n  int n = 0;\n  g->gcstate = GCSsweepstring;\n  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);\n   \n  g->sweepstrgc = 0;\n  g->sweepfin = sweeptolive(L, &g->finobj, &n);\n  g->sweepgc = sweeptolive(L, &g->allgc, &n);\n  return n;\n}\n\n\n \nvoid luaC_changemode (lua_State *L, int mode) {\n  global_State *g = G(L);\n  if (mode == g->gckind) return;   \n  if (mode == KGC_GEN) {   \n     \n    luaC_runtilstate(L, bitmask(GCSpropagate));\n    g->GCestimate = gettotalbytes(g);\n    g->gckind = KGC_GEN;\n  }\n  else {   \n     \n    g->gckind = KGC_NORMAL;\n    entersweep(L);\n    luaC_runtilstate(L, ~sweepphases);\n  }\n}\n\n\n \nstatic void callallpendingfinalizers (lua_State *L, int propagateerrors) {\n  global_State *g = G(L);\n  while (g->tobefnz) {\n    resetoldbit(g->tobefnz);\n    GCTM(L, propagateerrors);\n  }\n}\n\n\nvoid luaC_freeallobjects (lua_State *L) {\n  global_State *g = G(L);\n  int i;\n  separatetobefnz(L, 1);   \n  lua_assert(g->finobj == NULL);\n  callallpendingfinalizers(L, 0);\n  g->currentwhite = WHITEBITS;  \n  g->gckind = KGC_NORMAL;\n  sweepwholelist(L, &g->finobj);   \n  sweepwholelist(L, &g->allgc);\n  for (i = 0; i < g->strt.size; i++)   \n    sweepwholelist(L, &g->strt.hash[i]);\n  lua_assert(g->strt.nuse == 0);\n}\n\n\nstatic l_mem atomic (lua_State *L) {\n  global_State *g = G(L);\n  l_mem work = -cast(l_mem, g->GCmemtrav);   \n  GCObject *origweak, *origall;\n  lua_assert(!iswhite(obj2gco(g->mainthread)));\n  markobject(g, L);   \n   \n  markvalue(g, &g->l_registry);\n  markmt(g);   \n   \n  remarkupvals(g);\n  propagateall(g);   \n  work += g->GCmemtrav;   \n   \n  retraversegrays(g);\n  work -= g->GCmemtrav;   \n  convergeephemerons(g);\n   \n   \n  clearvalues(g, g->weak, NULL);\n  clearvalues(g, g->allweak, NULL);\n  origweak = g->weak; origall = g->allweak;\n  work += g->GCmemtrav;   \n  separatetobefnz(L, 0);   \n  markbeingfnz(g);   \n  propagateall(g);   \n  work -= g->GCmemtrav;   \n  convergeephemerons(g);\n   \n   \n  clearkeys(g, g->ephemeron, NULL);   \n  clearkeys(g, g->allweak, NULL);   \n   \n  clearvalues(g, g->weak, origweak);\n  clearvalues(g, g->allweak, origall);\n  g->currentwhite = cast_byte(otherwhite(g));   \n  work += g->GCmemtrav;   \n  return work;   \n}\n\n\nstatic lu_mem singlestep (lua_State *L) {\n  global_State *g = G(L);\n  switch (g->gcstate) {\n    case GCSpause: {\n       \n      g->GCmemtrav = g->strt.size * sizeof(GCObject*);\n      lua_assert(!isgenerational(g));\n      restartcollection(g);\n      g->gcstate = GCSpropagate;\n      return g->GCmemtrav;\n    }\n    case GCSpropagate: {\n      if (g->gray) {\n        lu_mem oldtrav = g->GCmemtrav;\n        propagatemark(g);\n        return g->GCmemtrav - oldtrav;   \n      }\n      else {   \n        lu_mem work;\n        int sw;\n        g->gcstate = GCSatomic;   \n        g->GCestimate = g->GCmemtrav;   \n        work = atomic(L);   \n        g->GCestimate += work;   \n        sw = entersweep(L);\n        return work + sw * GCSWEEPCOST;\n      }\n    }\n    case GCSsweepstring: {\n      int i;\n      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)\n        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);\n      g->sweepstrgc += i;\n      if (g->sweepstrgc >= g->strt.size)   \n        g->gcstate = GCSsweepudata;\n      return i * GCSWEEPCOST;\n    }\n    case GCSsweepudata: {\n      if (g->sweepfin) {\n        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);\n        return GCSWEEPMAX*GCSWEEPCOST;\n      }\n      else {\n        g->gcstate = GCSsweep;\n        return 0;\n      }\n    }\n    case GCSsweep: {\n      if (g->sweepgc) {\n        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);\n        return GCSWEEPMAX*GCSWEEPCOST;\n      }\n      else {\n         \n        GCObject *mt = obj2gco(g->mainthread);\n        sweeplist(L, &mt, 1);\n        checkSizes(L);\n        g->gcstate = GCSpause;   \n        return GCSWEEPCOST;\n      }\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n \nvoid luaC_runtilstate (lua_State *L, int statesmask) {\n  global_State *g = G(L);\n  while (!testbit(statesmask, g->gcstate))\n    singlestep(L);\n}\n\n\nstatic void generationalcollection (lua_State *L) {\n  global_State *g = G(L);\n  lua_assert(g->gcstate == GCSpropagate);\n  if (g->GCestimate == 0) {   \n    luaC_fullgc(L, 0);   \n    g->GCestimate = gettotalbytes(g);   \n  }\n  else {\n    lu_mem estimate = g->GCestimate;\n    luaC_runtilstate(L, bitmask(GCSpause));   \n    g->gcstate = GCSpropagate;   \n    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)\n      g->GCestimate = 0;   \n    else\n      g->GCestimate = estimate;   \n\n  }\n  setpause(g, gettotalbytes(g));\n  lua_assert(g->gcstate == GCSpropagate);\n}\n\n\nstatic void incstep (lua_State *L) {\n  global_State *g = G(L);\n  l_mem debt = g->GCdebt;\n  int stepmul = g->gcstepmul;\n  if (stepmul < 40) stepmul = 40;   \n   \n  debt = (debt / STEPMULADJ) + 1;\n  debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;\n  do {   \n    lu_mem work = singlestep(L);   \n    debt -= work;\n  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);\n  if (g->gcstate == GCSpause)\n    setpause(g, g->GCestimate);   \n  else {\n    debt = (debt / stepmul) * STEPMULADJ;   \n    luaE_setdebt(g, debt);\n  }\n}\n\n\n \nvoid luaC_forcestep (lua_State *L) {\n  global_State *g = G(L);\n  int i;\n  if (isgenerational(g)) generationalcollection(L);\n  else incstep(L);\n   \n  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)\n    GCTM(L, 1);   \n}\n\n\n \nvoid luaC_step (lua_State *L) {\n  global_State *g = G(L);\n  if (g->gcrunning) luaC_forcestep(L);\n  else luaE_setdebt(g, -GCSTEPSIZE);   \n}\n\n\n\n \nvoid luaC_fullgc (lua_State *L, int isemergency) {\n  global_State *g = G(L);\n  int origkind = g->gckind;\n  lua_assert(origkind != KGC_EMERGENCY);\n  if (isemergency)   \n    g->gckind = KGC_EMERGENCY;\n  else {\n    g->gckind = KGC_NORMAL;\n    callallpendingfinalizers(L, 1);\n  }\n  if (keepinvariant(g)) {   \n     \n    entersweep(L);\n  }\n   \n  luaC_runtilstate(L, bitmask(GCSpause));\n  luaC_runtilstate(L, ~bitmask(GCSpause));   \n  luaC_runtilstate(L, bitmask(GCSpause));   \n  if (origkind == KGC_GEN) {   \n     \n    luaC_runtilstate(L, bitmask(GCSpropagate));\n  }\n  g->gckind = origkind;\n  setpause(g, gettotalbytes(g));\n  if (!isemergency)    \n    callallpendingfinalizers(L, 1);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}