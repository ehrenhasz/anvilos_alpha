{
  "module_name": "lstrlib.c",
  "hash_id": "f5a638fdae559363c54b0dc1144b63a5a17c422ba80079af014e1632c71ccf33",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lstrlib.c",
  "human_readable_source": " \n\n\n#define lstrlib_c\n#define LUA_LIB\n\n#include <sys/lua/lua.h>\n\n#include <sys/lua/lauxlib.h>\n#include <sys/lua/lualib.h>\n\n\n \n#if !defined(LUA_MAXCAPTURES)\n#define LUA_MAXCAPTURES\t\t16\n#endif\n\n\n \n#define uchar(c)\t((unsigned char)(c))\n\n \nstatic size_t str_sprintf(char *buf, const char *fmt, ...) {\n  va_list args;\n  size_t len;\n\n  va_start(args, fmt);\n  len = vsnprintf(buf, INT_MAX, fmt, args);\n  va_end(args);\n\n  return len;\n}\n\n\nstatic int str_len (lua_State *L) {\n  size_t l;\n  luaL_checklstring(L, 1, &l);\n  lua_pushinteger(L, (lua_Integer)l);\n  return 1;\n}\n\n\n \nstatic size_t posrelat (ptrdiff_t pos, size_t len) {\n  if (pos >= 0) return (size_t)pos;\n  else if (0u - (size_t)pos > len) return 0;\n  else return len - ((size_t)-pos) + 1;\n}\n\n\nstatic int str_sub (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  size_t start = posrelat(luaL_checkinteger(L, 2), l);\n  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);\n  if (start < 1) start = 1;\n  if (end > l) end = l;\n  if (start <= end)\n    lua_pushlstring(L, s + start - 1, end - start + 1);\n  else lua_pushliteral(L, \"\");\n  return 1;\n}\n\n\nstatic int str_reverse (lua_State *L) {\n  size_t l, i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i = 0; i < l; i++)\n    p[i] = s[l - i - 1];\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_lower (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = tolower(uchar(s[i]));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_upper (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = toupper(uchar(s[i]));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\n \n#define MAXSIZE\t\t((~(size_t)0) >> 1)\n\nstatic int str_rep (lua_State *L) {\n  size_t l, lsep;\n  const char *s = luaL_checklstring(L, 1, &l);\n  int n = luaL_checkint(L, 2);\n  const char *sep = luaL_optlstring(L, 3, \"\", &lsep);\n  if (n <= 0) lua_pushliteral(L, \"\");\n  else if (l + lsep < l || l + lsep >= MAXSIZE / n)   \n    return luaL_error(L, \"resulting string too large\");\n  else {\n    size_t totallen = n * l + (n - 1) * lsep;\n    luaL_Buffer b;\n    char *p = luaL_buffinitsize(L, &b, totallen);\n    while (n-- > 1) {   \n      memcpy(p, s, l * sizeof(char)); p += l;\n      if (lsep > 0) {   \n        memcpy(p, sep, lsep * sizeof(char)); p += lsep;\n      }\n    }\n    memcpy(p, s, l * sizeof(char));   \n    luaL_pushresultsize(&b, totallen);\n  }\n  return 1;\n}\n\n\nstatic int str_byte (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);\n  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);\n  int n, i;\n  if (posi < 1) posi = 1;\n  if (pose > l) pose = l;\n  if (posi > pose) return 0;   \n  n = (int)(pose -  posi + 1);\n  if (posi + n <= pose)   \n    return luaL_error(L, \"string slice too long\");\n  luaL_checkstack(L, n, \"string slice too long\");\n  for (i=0; i<n; i++)\n    lua_pushinteger(L, uchar(s[posi+i-1]));\n  return n;\n}\n\n\nstatic int str_char (lua_State *L) {\n  int n = lua_gettop(L);   \n  int i;\n  luaL_Buffer b;\n  char *p = luaL_buffinitsize(L, &b, n);\n  for (i=1; i<=n; i++) {\n    int c = luaL_checkint(L, i);\n    luaL_argcheck(L, uchar(c) == c, i, \"value out of range\");\n    p[i - 1] = uchar(c);\n  }\n  luaL_pushresultsize(&b, n);\n  return 1;\n}\n\n\n#if defined(LUA_USE_DUMP)\nstatic int writer (lua_State *L, const void* b, size_t size, void* B) {\n  (void)L;\n  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);\n  return 0;\n}\n\n\nstatic int str_dump (lua_State *L) {\n  luaL_Buffer b;\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  lua_settop(L, 1);\n  luaL_buffinit(L,&b);\n  if (lua_dump(L, writer, &b) != 0)\n    return luaL_error(L, \"unable to dump given function\");\n  luaL_pushresult(&b);\n  return 1;\n}\n#endif\n\n\n \n\n\n#define CAP_UNFINISHED\t(-1)\n#define CAP_POSITION\t(-2)\n\n\ntypedef struct MatchState {\n  int matchdepth;   \n  const char *src_init;   \n  const char *src_end;   \n  const char *p_end;   \n  lua_State *L;\n  int level;   \n  struct {\n    const char *init;\n    ptrdiff_t len;\n  } capture[LUA_MAXCAPTURES];\n} MatchState;\n\n\n \nstatic const char *match (MatchState *ms, const char *s, const char *p);\n\n\n \n#if !defined(MAXCCALLS)\n#define MAXCCALLS\t200\n#endif\n\n\n#define L_ESC\t\t'%'\n#define SPECIALS\t\"^$*+?.([%-\"\n\n\nstatic int check_capture (MatchState *ms, int l) {\n  l -= '1';\n  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)\n    return luaL_error(ms->L, \"invalid capture index %%%d\", l + 1);\n  return l;\n}\n\n\nstatic int capture_to_close (MatchState *ms) {\n  int level = ms->level;\n  for (level--; level>=0; level--)\n    if (ms->capture[level].len == CAP_UNFINISHED) return level;\n  return luaL_error(ms->L, \"invalid pattern capture\");\n}\n\n\nstatic const char *classend (MatchState *ms, const char *p) {\n  switch (*p++) {\n    case L_ESC: {\n      if (p == ms->p_end)\n        luaL_error(ms->L, \"malformed pattern (ends with \" LUA_QL(\"%%\") \")\");\n      return p+1;\n    }\n    case '[': {\n      if (*p == '^') p++;\n      do {   \n        if (p == ms->p_end)\n          luaL_error(ms->L, \"malformed pattern (missing \" LUA_QL(\"]\") \")\");\n        if (*(p++) == L_ESC && p < ms->p_end)\n          p++;   \n      } while (*p != ']');\n      return p+1;\n    }\n    default: {\n      return p;\n    }\n  }\n}\n\n\nstatic int match_class (int c, int cl) {\n  int res;\n  switch (tolower(cl)) {\n    case 'a' : res = isalpha(c); break;\n    case 'c' : res = iscntrl(c); break;\n    case 'd' : res = isdigit(c); break;\n    case 'g' : res = isgraph(c); break;\n    case 'l' : res = islower(c); break;\n    case 'p' : res = ispunct(c); break;\n    case 's' : res = isspace(c); break;\n    case 'u' : res = isupper(c); break;\n    case 'w' : res = isalnum(c); break;\n    case 'x' : res = isxdigit(c); break;\n    case 'z' : res = (c == 0); break;   \n    default: return (cl == c);\n  }\n  return (islower(cl) ? res : !res);\n}\n\n\nstatic int matchbracketclass (int c, const char *p, const char *ec) {\n  int sig = 1;\n  if (*(p+1) == '^') {\n    sig = 0;\n    p++;   \n  }\n  while (++p < ec) {\n    if (*p == L_ESC) {\n      p++;\n      if (match_class(c, uchar(*p)))\n        return sig;\n    }\n    else if ((*(p+1) == '-') && (p+2 < ec)) {\n      p+=2;\n      if (uchar(*(p-2)) <= c && c <= uchar(*p))\n        return sig;\n    }\n    else if (uchar(*p) == c) return sig;\n  }\n  return !sig;\n}\n\n\nstatic int singlematch (MatchState *ms, const char *s, const char *p,\n                        const char *ep) {\n  if (s >= ms->src_end)\n    return 0;\n  else {\n    int c = uchar(*s);\n    switch (*p) {\n      case '.': return 1;   \n      case L_ESC: return match_class(c, uchar(*(p+1)));\n      case '[': return matchbracketclass(c, p, ep-1);\n      default:  return (uchar(*p) == c);\n    }\n  }\n}\n\n\nstatic const char *matchbalance (MatchState *ms, const char *s,\n                                   const char *p) {\n  if (p >= ms->p_end - 1)\n    luaL_error(ms->L, \"malformed pattern \"\n                      \"(missing arguments to \" LUA_QL(\"%%b\") \")\");\n  if (*s != *p) return NULL;\n  else {\n    int b = *p;\n    int e = *(p+1);\n    int cont = 1;\n    while (++s < ms->src_end) {\n      if (*s == e) {\n        if (--cont == 0) return s+1;\n      }\n      else if (*s == b) cont++;\n    }\n  }\n  return NULL;   \n}\n\n\nstatic const char *max_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  ptrdiff_t i = 0;   \n  while (singlematch(ms, s + i, p, ep))\n    i++;\n   \n  while (i>=0) {\n    const char *res = match(ms, (s+i), ep+1);\n    if (res) return res;\n    i--;   \n  }\n  return NULL;\n}\n\n\nstatic const char *min_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  for (;;) {\n    const char *res = match(ms, s, ep+1);\n    if (res != NULL)\n      return res;\n    else if (singlematch(ms, s, p, ep))\n      s++;   \n    else return NULL;\n  }\n}\n\n\nstatic const char *start_capture (MatchState *ms, const char *s,\n                                    const char *p, int what) {\n  const char *res;\n  int level = ms->level;\n  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, \"too many captures\");\n  ms->capture[level].init = s;\n  ms->capture[level].len = what;\n  ms->level = level+1;\n  if ((res=match(ms, s, p)) == NULL)   \n    ms->level--;   \n  return res;\n}\n\n\nstatic const char *end_capture (MatchState *ms, const char *s,\n                                  const char *p) {\n  int l = capture_to_close(ms);\n  const char *res;\n  ms->capture[l].len = s - ms->capture[l].init;   \n  if ((res = match(ms, s, p)) == NULL)   \n    ms->capture[l].len = CAP_UNFINISHED;   \n  return res;\n}\n\n\nstatic const char *match_capture (MatchState *ms, const char *s, int l) {\n  size_t len;\n  l = check_capture(ms, l);\n  len = ms->capture[l].len;\n  if ((size_t)(ms->src_end-s) >= len &&\n      memcmp(ms->capture[l].init, s, len) == 0)\n    return s+len;\n  else return NULL;\n}\n\n\nstatic const char *match (MatchState *ms, const char *s, const char *p) {\n  if (ms->matchdepth-- == 0)\n    luaL_error(ms->L, \"pattern too complex\");\n  init:  \n  if (p != ms->p_end) {   \n    switch (*p) {\n      case '(': {   \n        if (*(p + 1) == ')')   \n          s = start_capture(ms, s, p + 2, CAP_POSITION);\n        else\n          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);\n        break;\n      }\n      case ')': {   \n        s = end_capture(ms, s, p + 1);\n        break;\n      }\n      case '$': {\n        if ((p + 1) != ms->p_end)   \n          goto dflt;   \n        s = (s == ms->src_end) ? s : NULL;   \n        break;\n      }\n      case L_ESC: {   \n        switch (*(p + 1)) {\n          case 'b': {   \n            s = matchbalance(ms, s, p + 2);\n            if (s != NULL) {\n              p += 4; goto init;   \n            }   \n            break;\n          }\n          case 'f': {   \n            const char *ep; char previous;\n            p += 2;\n            if (*p != '[')\n              luaL_error(ms->L, \"missing \" LUA_QL(\"[\") \" after \"\n                                 LUA_QL(\"%%f\") \" in pattern\");\n            ep = classend(ms, p);   \n            previous = (s == ms->src_init) ? '\\0' : *(s - 1);\n            if (!matchbracketclass(uchar(previous), p, ep - 1) &&\n               matchbracketclass(uchar(*s), p, ep - 1)) {\n              p = ep; goto init;   \n            }\n            s = NULL;   \n            break;\n          }\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n          case '8': case '9': {   \n            s = match_capture(ms, s, uchar(*(p + 1)));\n            if (s != NULL) {\n              p += 2; goto init;   \n            }\n            break;\n          }\n          default: goto dflt;\n        }\n        break;\n      }\n      default: dflt: {   \n        const char *ep = classend(ms, p);   \n         \n        if (!singlematch(ms, s, p, ep)) {\n          if (*ep == '*' || *ep == '?' || *ep == '-') {   \n            p = ep + 1; goto init;   \n          }\n          else   \n            s = NULL;   \n        }\n        else {   \n          switch (*ep) {   \n            case '?': {   \n              const char *res;\n              if ((res = match(ms, s + 1, ep + 1)) != NULL)\n                s = res;\n              else {\n                p = ep + 1; goto init;   \n              }\n              break;\n            }\n            case '+':   \n              s++;   \n              zfs_fallthrough;\n            case '*':   \n              s = max_expand(ms, s, p, ep);\n              break;\n            case '-':   \n              s = min_expand(ms, s, p, ep);\n              break;\n            default:   \n              s++; p = ep; goto init;   \n          }\n        }\n        break;\n      }\n    }\n  }\n  ms->matchdepth++;\n  return s;\n}\n\n\n\nstatic const char *lmemfind (const char *s1, size_t l1,\n                               const char *s2, size_t l2) {\n  if (l2 == 0) return s1;   \n  else if (l2 > l1) return NULL;   \n  else {\n    const char *init;   \n    l2--;   \n    l1 = l1-l2;   \n    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {\n      init++;    \n      if (memcmp(init, s2+1, l2) == 0)\n        return init-1;\n      else {   \n        l1 -= init-s1;\n        s1 = init;\n      }\n    }\n    return NULL;   \n  }\n}\n\n\nstatic void push_onecapture (MatchState *ms, int i, const char *s,\n                                                    const char *e) {\n  if (i >= ms->level) {\n    if (i == 0)   \n      lua_pushlstring(ms->L, s, e - s);   \n    else\n      luaL_error(ms->L, \"invalid capture index\");\n  }\n  else {\n    ptrdiff_t l = ms->capture[i].len;\n    if (l == CAP_UNFINISHED) luaL_error(ms->L, \"unfinished capture\");\n    if (l == CAP_POSITION)\n      lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);\n    else\n      lua_pushlstring(ms->L, ms->capture[i].init, l);\n  }\n}\n\n\nstatic int push_captures (MatchState *ms, const char *s, const char *e) {\n  int i;\n  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;\n  luaL_checkstack(ms->L, nlevels, \"too many captures\");\n  for (i = 0; i < nlevels; i++)\n    push_onecapture(ms, i, s, e);\n  return nlevels;   \n}\n\n\n \nstatic int nospecials (const char *p, size_t l) {\n  size_t upto = 0;\n  do {\n    if (strpbrk(p + upto, SPECIALS))\n      return 0;   \n    upto += strlen(p + upto) + 1;   \n  } while (upto <= l);\n  return 1;   \n}\n\n\nstatic int str_find_aux (lua_State *L, int find) {\n  size_t ls, lp;\n  const char *s = luaL_checklstring(L, 1, &ls);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);\n  if (init < 1) init = 1;\n  else if (init > ls + 1) {   \n    lua_pushnil(L);   \n    return 1;\n  }\n   \n  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {\n     \n    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);\n    if (s2) {\n      lua_pushinteger(L, s2 - s + 1);\n      lua_pushinteger(L, s2 - s + lp);\n      return 2;\n    }\n  }\n  else {\n    MatchState ms;\n    const char *s1 = s + init - 1;\n    int anchor = (*p == '^');\n    if (anchor) {\n      p++; lp--;   \n    }\n    ms.L = L;\n    ms.matchdepth = MAXCCALLS;\n    ms.src_init = s;\n    ms.src_end = s + ls;\n    ms.p_end = p + lp;\n    do {\n      const char *res;\n      ms.level = 0;\n      lua_assert(ms.matchdepth == MAXCCALLS);\n      if ((res=match(&ms, s1, p)) != NULL) {\n        if (find) {\n          lua_pushinteger(L, s1 - s + 1);   \n          lua_pushinteger(L, res - s);    \n          return push_captures(&ms, NULL, 0) + 2;\n        }\n        else\n          return push_captures(&ms, s1, res);\n      }\n    } while (s1++ < ms.src_end && !anchor);\n  }\n  lua_pushnil(L);   \n  return 1;\n}\n\n\nstatic int str_find (lua_State *L) {\n  return str_find_aux(L, 1);\n}\n\n\nstatic int str_match (lua_State *L) {\n  return str_find_aux(L, 0);\n}\n\n\nstatic int gmatch_aux (lua_State *L) {\n  MatchState ms;\n  size_t ls, lp;\n  const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);\n  const char *p = lua_tolstring(L, lua_upvalueindex(2), &lp);\n  const char *src;\n  ms.L = L;\n  ms.matchdepth = MAXCCALLS;\n  ms.src_init = s;\n  ms.src_end = s+ls;\n  ms.p_end = p + lp;\n  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));\n       src <= ms.src_end;\n       src++) {\n    const char *e;\n    ms.level = 0;\n    lua_assert(ms.matchdepth == MAXCCALLS);\n    if ((e = match(&ms, src, p)) != NULL) {\n      lua_Integer newstart = e-s;\n      if (e == src) newstart++;   \n      lua_pushinteger(L, newstart);\n      lua_replace(L, lua_upvalueindex(3));\n      return push_captures(&ms, src, e);\n    }\n  }\n  return 0;   \n}\n\n\nstatic int str_gmatch (lua_State *L) {\n  luaL_checkstring(L, 1);\n  luaL_checkstring(L, 2);\n  lua_settop(L, 2);\n  lua_pushinteger(L, 0);\n  lua_pushcclosure(L, gmatch_aux, 3);\n  return 1;\n}\n\n\nstatic void add_s (MatchState *ms, luaL_Buffer *b, const char *s,\n                                                   const char *e) {\n  size_t l, i;\n  const char *news = lua_tolstring(ms->L, 3, &l);\n  for (i = 0; i < l; i++) {\n    if (news[i] != L_ESC)\n      luaL_addchar(b, news[i]);\n    else {\n      i++;   \n      if (!isdigit(uchar(news[i]))) {\n        if (news[i] != L_ESC)\n          luaL_error(ms->L, \"invalid use of \" LUA_QL(\"%c\")\n                           \" in replacement string\", L_ESC);\n        luaL_addchar(b, news[i]);\n      }\n      else if (news[i] == '0')\n          luaL_addlstring(b, s, e - s);\n      else {\n        push_onecapture(ms, news[i] - '1', s, e);\n        luaL_addvalue(b);   \n      }\n    }\n  }\n}\n\n\nstatic void add_value (MatchState *ms, luaL_Buffer *b, const char *s,\n                                       const char *e, int tr) {\n  lua_State *L = ms->L;\n  switch (tr) {\n    case LUA_TFUNCTION: {\n      int n;\n      lua_pushvalue(L, 3);\n      n = push_captures(ms, s, e);\n      lua_call(L, n, 1);\n      break;\n    }\n    case LUA_TTABLE: {\n      push_onecapture(ms, 0, s, e);\n      lua_gettable(L, 3);\n      break;\n    }\n    default: {   \n      add_s(ms, b, s, e);\n      return;\n    }\n  }\n  if (!lua_toboolean(L, -1)) {   \n    lua_pop(L, 1);\n    lua_pushlstring(L, s, e - s);   \n  }\n  else if (!lua_isstring(L, -1))\n    luaL_error(L, \"invalid replacement value (a %s)\", luaL_typename(L, -1));\n  luaL_addvalue(b);   \n}\n\n\nstatic int str_gsub (lua_State *L) {\n  size_t srcl, lp;\n  const char *src = luaL_checklstring(L, 1, &srcl);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  int tr = lua_type(L, 3);\n  size_t max_s = luaL_optinteger(L, 4, srcl+1);\n  int anchor = (*p == '^');\n  size_t n = 0;\n  MatchState ms;\n  luaL_Buffer b;\n  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||\n                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,\n                      \"string/function/table expected\");\n  luaL_buffinit(L, &b);\n  if (anchor) {\n    p++; lp--;   \n  }\n  ms.L = L;\n  ms.matchdepth = MAXCCALLS;\n  ms.src_init = src;\n  ms.src_end = src+srcl;\n  ms.p_end = p + lp;\n  while (n < max_s) {\n    const char *e;\n    ms.level = 0;\n    lua_assert(ms.matchdepth == MAXCCALLS);\n    e = match(&ms, src, p);\n    if (e) {\n      n++;\n      add_value(&ms, &b, src, e, tr);\n    }\n    if (e && e>src)  \n      src = e;   \n    else if (src < ms.src_end)\n      luaL_addchar(&b, *src++);\n    else break;\n    if (anchor) break;\n  }\n  luaL_addlstring(&b, src, ms.src_end-src);\n  luaL_pushresult(&b);\n  lua_pushinteger(L, n);   \n  return 2;\n}\n\n \n\n\n\n \n\n \n#if !defined(LUA_INTFRMLEN)\t \n#if defined(LUA_USE_LONGLONG)\n\n#define LUA_INTFRMLEN\t\t\"ll\"\n#define LUA_INTFRM_T\t\tlong long\n\n#else\n\n#define LUA_INTFRMLEN\t\t\"l\"\n#define LUA_INTFRM_T\t\tlong\n\n#endif\n#endif\t\t\t\t \n\n\n \n#if !defined(LUA_FLTFRMLEN)\n\n#define LUA_FLTFRMLEN\t\t\"\"\n#define LUA_FLTFRM_T\t\tdouble\n\n#endif\n\n\n \n#define MAX_ITEM\t512\n \n#define FLAGS\t\"-+ #0\"\n \n#define MAX_FORMAT\t(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)\n\n\nstatic void addquoted (lua_State *L, luaL_Buffer *b, int arg) {\n  size_t l;\n  const char *s = luaL_checklstring(L, arg, &l);\n  luaL_addchar(b, '\"');\n  while (l--) {\n    if (*s == '\"' || *s == '\\\\' || *s == '\\n') {\n      luaL_addchar(b, '\\\\');\n      luaL_addchar(b, *s);\n    }\n    else if (*s == '\\0' || iscntrl(uchar(*s))) {\n      char buff[10];\n      if (!isdigit(uchar(*(s+1))))\n        snprintf(buff, sizeof(buff), \"\\\\%d\", (int)uchar(*s));\n      else\n        snprintf(buff, sizeof(buff), \"\\\\%03d\", (int)uchar(*s));\n      luaL_addstring(b, buff);\n    }\n    else\n      luaL_addchar(b, *s);\n    s++;\n  }\n  luaL_addchar(b, '\"');\n}\n\nstatic const char *scanformat (lua_State *L, const char *strfrmt, char *form) {\n  const char *p = strfrmt;\n  while (*p != '\\0' && strchr(FLAGS, *p) != NULL) p++;   \n  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))\n    luaL_error(L, \"invalid format (repeated flags)\");\n  if (isdigit(uchar(*p))) p++;   \n  if (isdigit(uchar(*p))) p++;   \n  if (*p == '.') {\n    p++;\n    if (isdigit(uchar(*p))) p++;   \n    if (isdigit(uchar(*p))) p++;   \n  }\n  if (isdigit(uchar(*p)))\n    luaL_error(L, \"invalid format (width or precision too long)\");\n  *(form++) = '%';\n  memcpy(form, strfrmt, (p - strfrmt + 1) * sizeof(char));\n  form += p - strfrmt + 1;\n  *form = '\\0';\n  return p;\n}\n\n\n \nstatic void addlenmod (char *form, const char *lenmod, size_t size) {\n  size_t l = strlen(form);\n  size_t lm = strlen(lenmod);\n  char spec = form[l - 1];\n  strlcpy(form + l - 1, lenmod, size - (l - 1));\n  form[l + lm - 1] = spec;\n  form[l + lm] = '\\0';\n}\n\n\nstatic int str_format (lua_State *L) {\n  int top = lua_gettop(L);\n  int arg = 1;\n  size_t sfl;\n  const char *strfrmt = luaL_checklstring(L, arg, &sfl);\n  const char *strfrmt_end = strfrmt+sfl;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while (strfrmt < strfrmt_end) {\n    if (*strfrmt != L_ESC)\n      luaL_addchar(&b, *strfrmt++);\n    else if (*++strfrmt == L_ESC)\n      luaL_addchar(&b, *strfrmt++);   \n    else {  \n      char form[MAX_FORMAT];   \n      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);   \n      int nb = 0;   \n      if (++arg > top)\n        luaL_argerror(L, arg, \"no value\");\n      strfrmt = scanformat(L, strfrmt, form);\n      switch (*strfrmt++) {\n        case 'c': {\n          nb = str_sprintf(buff, form, luaL_checkint(L, arg));\n          break;\n        }\n        case 'd': case 'i': {\n          lua_Number n = luaL_checknumber(L, arg);\n          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;\n          lua_Number diff = n - (lua_Number)ni;\n          luaL_argcheck(L, -1 < diff && diff < 1, arg,\n                        \"not a number in proper range\");\n          addlenmod(form, LUA_INTFRMLEN, MAX_FORMAT);\n          nb = str_sprintf(buff, form, ni);\n          break;\n        }\n        case 'o': case 'u': case 'x': case 'X': {\n          lua_Number n = luaL_checknumber(L, arg);\n          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;\n          lua_Number diff = n - (lua_Number)ni;\n          luaL_argcheck(L, -1 < diff && diff < 1, arg,\n                        \"not a non-negative number in proper range\");\n          addlenmod(form, LUA_INTFRMLEN, MAX_FORMAT);\n          nb = str_sprintf(buff, form, ni);\n          break;\n        }\n#if defined(LUA_USE_FLOAT_FORMATS)\n        case 'e': case 'E': case 'f':\n#if defined(LUA_USE_AFORMAT)\n        case 'a': case 'A':\n#endif\n        case 'g': case 'G': {\n          addlenmod(form, LUA_FLTFRMLEN, MAX_FORMAT);\n          nb = str_sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));\n          break;\n        }\n#endif\n        case 'q': {\n          addquoted(L, &b, arg);\n          break;\n        }\n        case 's': {\n          size_t l;\n          const char *s = luaL_tolstring(L, arg, &l);\n          if (!strchr(form, '.') && l >= 100) {\n             \n            luaL_addvalue(&b);\n            break;\n          }\n          else {\n            nb = str_sprintf(buff, form, s);\n            lua_pop(L, 1);   \n            break;\n          }\n        }\n        default: {   \n          return luaL_error(L, \"invalid option \" LUA_QL(\"%%%c\") \" to \"\n                               LUA_QL(\"format\"), *(strfrmt - 1));\n        }\n      }\n      luaL_addsize(&b, nb);\n    }\n  }\n  luaL_pushresult(&b);\n  return 1;\n}\n\n \n\n\nstatic const luaL_Reg strlib[] = {\n  {\"byte\", str_byte},\n  {\"char\", str_char},\n#if defined(LUA_USE_DUMP)\n  {\"dump\", str_dump},\n#endif\n  {\"find\", str_find},\n  {\"format\", str_format},\n  {\"gmatch\", str_gmatch},\n  {\"gsub\", str_gsub},\n  {\"len\", str_len},\n  {\"lower\", str_lower},\n  {\"match\", str_match},\n  {\"rep\", str_rep},\n  {\"reverse\", str_reverse},\n  {\"sub\", str_sub},\n  {\"upper\", str_upper},\n  {NULL, NULL}\n};\n\n\nstatic void createmetatable (lua_State *L) {\n  lua_createtable(L, 0, 1);   \n  lua_pushliteral(L, \"\");   \n  lua_pushvalue(L, -2);   \n  lua_setmetatable(L, -2);   \n  lua_pop(L, 1);   \n  lua_pushvalue(L, -2);   \n  lua_setfield(L, -2, \"__index\");   \n  lua_pop(L, 1);   \n}\n\n\n \nLUAMOD_API int luaopen_string (lua_State *L) {\n  luaL_newlib(L, strlib);\n  createmetatable(L);\n  return 1;\n}\n\n#if defined(_KERNEL)\n\nEXPORT_SYMBOL(luaopen_string);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}