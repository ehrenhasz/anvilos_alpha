{
  "module_name": "lauxlib.c",
  "hash_id": "61da1f3f3314b09ec03ee9d1415cfd5d7253979b1935c092a67e5cb5777b619c",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lauxlib.c",
  "human_readable_source": " \n\n\n \n\n#define lauxlib_c\n#define LUA_LIB\n\n#include <sys/lua/lua.h>\n\n#include <sys/lua/lauxlib.h>\n\n\n \n\n\n#define LEVELS1\t12\t \n#define LEVELS2\t10\t \n\n\n\n \nstatic int findfield (lua_State *L, int objidx, int level) {\n  if (level == 0 || !lua_istable(L, -1))\n    return 0;   \n  lua_pushnil(L);   \n  while (lua_next(L, -2)) {   \n    if (lua_type(L, -2) == LUA_TSTRING) {   \n      if (lua_rawequal(L, objidx, -1)) {   \n        lua_pop(L, 1);   \n        return 1;\n      }\n      else if (findfield(L, objidx, level - 1)) {   \n        lua_remove(L, -2);   \n        lua_pushliteral(L, \".\");\n        lua_insert(L, -2);   \n        lua_concat(L, 3);\n        return 1;\n      }\n    }\n    lua_pop(L, 1);   \n  }\n  return 0;   \n}\n\n\nstatic int pushglobalfuncname (lua_State *L, lua_Debug *ar) {\n  int top = lua_gettop(L);\n  lua_getinfo(L, \"f\", ar);   \n  lua_pushglobaltable(L);\n  if (findfield(L, top + 1, 2)) {\n    lua_copy(L, -1, top + 1);   \n    lua_pop(L, 2);   \n    return 1;\n  }\n  else {\n    lua_settop(L, top);   \n    return 0;\n  }\n}\n\n\nstatic void pushfuncname (lua_State *L, lua_Debug *ar) {\n  if (*ar->namewhat != '\\0')   \n    lua_pushfstring(L, \"function \" LUA_QS, ar->name);\n  else if (*ar->what == 'm')   \n      lua_pushliteral(L, \"main chunk\");\n  else if (*ar->what == 'C') {\n    if (pushglobalfuncname(L, ar)) {\n      lua_pushfstring(L, \"function \" LUA_QS, lua_tostring(L, -1));\n      lua_remove(L, -2);   \n    }\n    else\n      lua_pushliteral(L, \"?\");\n  }\n  else\n    lua_pushfstring(L, \"function <%s:%d>\", ar->short_src, ar->linedefined);\n}\n\n\nstatic int countlevels (lua_State *L) {\n  lua_Debug ar;\n  int li = 1, le = 1;\n   \n  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }\n   \n  while (li < le) {\n    int m = (li + le)/2;\n    if (lua_getstack(L, m, &ar)) li = m + 1;\n    else le = m;\n  }\n  return le - 1;\n}\n\n\nLUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,\n                                const char *msg, int level) {\n  lua_Debug ar;\n  int top = lua_gettop(L);\n  int numlevels = countlevels(L1);\n  int mark = (numlevels > LEVELS1 + LEVELS2) ? LEVELS1 : 0;\n  if (msg) lua_pushfstring(L, \"%s\\n\", msg);\n  lua_pushliteral(L, \"stack traceback:\");\n  while (lua_getstack(L1, level++, &ar)) {\n    if (level == mark) {   \n      lua_pushliteral(L, \"\\n\\t...\");   \n      level = numlevels - LEVELS2;   \n    }\n    else {\n      lua_getinfo(L1, \"Slnt\", &ar);\n      lua_pushfstring(L, \"\\n\\t%s:\", ar.short_src);\n      if (ar.currentline > 0)\n        lua_pushfstring(L, \"%d:\", ar.currentline);\n      lua_pushliteral(L, \" in \");\n      pushfuncname(L, &ar);\n      if (ar.istailcall)\n        lua_pushliteral(L, \"\\n\\t(...tail calls...)\");\n      lua_concat(L, lua_gettop(L) - top);\n    }\n  }\n  lua_concat(L, lua_gettop(L) - top);\n}\n\n \n\n\n \n\nLUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {\n  lua_Debug ar;\n  if (!lua_getstack(L, 0, &ar))   \n    return luaL_error(L, \"bad argument #%d (%s)\", narg, extramsg);\n  lua_getinfo(L, \"n\", &ar);\n  if (strcmp(ar.namewhat, \"method\") == 0) {\n    narg--;   \n    if (narg == 0)   \n      return luaL_error(L, \"calling \" LUA_QS \" on bad self (%s)\",\n                           ar.name, extramsg);\n  }\n  if (ar.name == NULL)\n    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : \"?\";\n  return luaL_error(L, \"bad argument #%d to \" LUA_QS \" (%s)\",\n                        narg, ar.name, extramsg);\n}\n\n\nstatic int typeerror (lua_State *L, int narg, const char *tname) {\n  const char *msg = lua_pushfstring(L, \"%s expected, got %s\",\n                                    tname, luaL_typename(L, narg));\n  return luaL_argerror(L, narg, msg);\n}\n\n\nstatic void tag_error (lua_State *L, int narg, int tag) {\n  typeerror(L, narg, lua_typename(L, tag));\n}\n\n\nLUALIB_API void luaL_where (lua_State *L, int level) {\n  lua_Debug ar;\n  if (lua_getstack(L, level, &ar)) {   \n    lua_getinfo(L, \"Sl\", &ar);   \n    if (ar.currentline > 0) {   \n      lua_pushfstring(L, \"%s:%d: \", ar.short_src, ar.currentline);\n      return;\n    }\n  }\n  lua_pushliteral(L, \"\");   \n}\n\n\nLUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {\n  va_list argp;\n  va_start(argp, fmt);\n  luaL_where(L, 1);\n  lua_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_concat(L, 2);\n  return lua_error(L);\n}\n\n\n#if !defined(inspectstat)\t \n\n#if defined(LUA_USE_POSIX)\n\n#include <sys/wait.h>\n\n \n#define inspectstat(stat,what)  \\\n   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \\\n   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = \"signal\"; }\n\n#else\n\n#define inspectstat(stat,what)   \n\n#endif\n\n#endif\t\t\t\t \n\n\n \n\n\n \n\nLUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {\n  luaL_getmetatable(L, tname);   \n  if (!lua_isnil(L, -1))   \n    return 0;   \n  lua_pop(L, 1);\n  lua_newtable(L);   \n  lua_pushvalue(L, -1);\n  lua_setfield(L, LUA_REGISTRYINDEX, tname);   \n  return 1;\n}\n\n\nLUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {\n  luaL_getmetatable(L, tname);\n  lua_setmetatable(L, -2);\n}\n\n\nLUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {\n  void *p = lua_touserdata(L, ud);\n  if (p != NULL) {   \n    if (lua_getmetatable(L, ud)) {   \n      luaL_getmetatable(L, tname);   \n      if (!lua_rawequal(L, -1, -2))   \n        p = NULL;   \n      lua_pop(L, 2);   \n      return p;\n    }\n  }\n  return NULL;   \n}\n\n\nLUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {\n  void *p = luaL_testudata(L, ud, tname);\n  if (p == NULL) typeerror(L, ud, tname);\n  return p;\n}\n\n \n\n\n \n\nLUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,\n                                 const char *const lst[]) {\n  const char *name = (def) ? luaL_optstring(L, narg, def) :\n                             luaL_checkstring(L, narg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, narg,\n                       lua_pushfstring(L, \"invalid option \" LUA_QS, name));\n}\n\n\nLUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {\n   \n  const int extra = LUA_MINSTACK;\n  if (!lua_checkstack(L, space + extra)) {\n    if (msg)\n      luaL_error(L, \"stack overflow (%s)\", msg);\n    else\n      luaL_error(L, \"stack overflow\");\n  }\n}\n\n\nLUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {\n  if (lua_type(L, narg) != t)\n    tag_error(L, narg, t);\n}\n\n\nLUALIB_API void luaL_checkany (lua_State *L, int narg) {\n  if (lua_type(L, narg) == LUA_TNONE)\n    luaL_argerror(L, narg, \"value expected\");\n}\n\n\nLUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {\n  const char *s = lua_tolstring(L, narg, len);\n  if (!s) tag_error(L, narg, LUA_TSTRING);\n  return s;\n}\n\n\nLUALIB_API const char *luaL_optlstring (lua_State *L, int narg,\n                                        const char *def, size_t *len) {\n  if (lua_isnoneornil(L, narg)) {\n    if (len)\n      *len = (def ? strlen(def) : 0);\n    return def;\n  }\n  else return luaL_checklstring(L, narg, len);\n}\n\n\nLUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {\n  int isnum;\n  lua_Number d = lua_tonumberx(L, narg, &isnum);\n  if (!isnum)\n    tag_error(L, narg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {\n  return luaL_opt(L, luaL_checknumber, narg, def);\n}\n\n\nLUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {\n  int isnum;\n  lua_Integer d = lua_tointegerx(L, narg, &isnum);\n  if (!isnum)\n    tag_error(L, narg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {\n  int isnum;\n  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);\n  if (!isnum)\n    tag_error(L, narg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,\n                                                      lua_Integer def) {\n  return luaL_opt(L, luaL_checkinteger, narg, def);\n}\n\n\nLUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,\n                                                        lua_Unsigned def) {\n  return luaL_opt(L, luaL_checkunsigned, narg, def);\n}\n\n \n\n\n \n\n \n#define buffonstack(B)\t((B)->b != (B)->initb)\n\n\n \nLUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {\n  lua_State *L = B->L;\n  if (B->size - B->n < sz) {   \n    char *newbuff;\n    size_t newsize = B->size * 2;   \n    if (newsize - B->n < sz)   \n      newsize = B->n + sz;\n    if (newsize < B->n || newsize - B->n < sz)\n      luaL_error(L, \"buffer too large\");\n     \n    newbuff = (char *)lua_newuserdata(L, newsize * sizeof(char));\n     \n    memcpy(newbuff, B->b, B->n * sizeof(char));\n    if (buffonstack(B))\n      lua_remove(L, -2);   \n    B->b = newbuff;\n    B->size = newsize;\n  }\n  return &B->b[B->n];\n}\n\n\nLUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {\n  char *b = luaL_prepbuffsize(B, l);\n  memcpy(b, s, l * sizeof(char));\n  luaL_addsize(B, l);\n}\n\n\nLUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {\n  luaL_addlstring(B, s, strlen(s));\n}\n\n\nLUALIB_API void luaL_pushresult (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  lua_pushlstring(L, B->b, B->n);\n  if (buffonstack(B))\n    lua_remove(L, -2);   \n}\n\n\nLUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {\n  luaL_addsize(B, sz);\n  luaL_pushresult(B);\n}\n\n\nLUALIB_API void luaL_addvalue (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  size_t l;\n  const char *s = lua_tolstring(L, -1, &l);\n  if (buffonstack(B))\n    lua_insert(L, -2);   \n  luaL_addlstring(B, s, l);\n  lua_remove(L, (buffonstack(B)) ? -2 : -1);   \n}\n\n\nLUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {\n  B->L = L;\n  B->b = B->initb;\n  B->n = 0;\n  B->size = LUAL_BUFFERSIZE;\n}\n\n\nLUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {\n  luaL_buffinit(L, B);\n  return luaL_prepbuffsize(B, sz);\n}\n\n \n\n\n \n\n \n#define freelist\t0\n\n\nLUALIB_API int luaL_ref (lua_State *L, int t) {\n  int ref;\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);   \n    return LUA_REFNIL;   \n  }\n  t = lua_absindex(L, t);\n  lua_rawgeti(L, t, freelist);   \n  ref = (int)lua_tointeger(L, -1);   \n  lua_pop(L, 1);   \n  if (ref != 0) {   \n    lua_rawgeti(L, t, ref);   \n    lua_rawseti(L, t, freelist);   \n  }\n  else   \n    ref = (int)lua_rawlen(L, t) + 1;   \n  lua_rawseti(L, t, ref);\n  return ref;\n}\n\n\nLUALIB_API void luaL_unref (lua_State *L, int t, int ref) {\n  if (ref >= 0) {\n    t = lua_absindex(L, t);\n    lua_rawgeti(L, t, freelist);\n    lua_rawseti(L, t, ref);   \n    lua_pushinteger(L, ref);\n    lua_rawseti(L, t, freelist);   \n  }\n}\n\n \n\n\n \n\ntypedef struct LoadS {\n  const char *s;\n  size_t size;\n} LoadS;\n\n\nstatic const char *getS (lua_State *L, void *ud, size_t *size) {\n  LoadS *ls = (LoadS *)ud;\n  (void)L;   \n  if (ls->size == 0) return NULL;\n  *size = ls->size;\n  ls->size = 0;\n  return ls->s;\n}\n\n\nLUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,\n                                 const char *name, const char *mode) {\n  LoadS ls;\n  ls.s = buff;\n  ls.size = size;\n  return lua_load(L, getS, &ls, name, mode);\n}\n\n\nLUALIB_API int luaL_loadstring (lua_State *L, const char *s) {\n  return luaL_loadbuffer(L, s, strlen(s), s);\n}\n\n \n\n\n\nLUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {\n  if (!lua_getmetatable(L, obj))   \n    return 0;\n  lua_pushstring(L, event);\n  lua_rawget(L, -2);\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 2);   \n    return 0;\n  }\n  else {\n    lua_remove(L, -2);   \n    return 1;\n  }\n}\n\n\nLUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {\n  obj = lua_absindex(L, obj);\n  if (!luaL_getmetafield(L, obj, event))   \n    return 0;\n  lua_pushvalue(L, obj);\n  lua_call(L, 1, 1);\n  return 1;\n}\n\n\nLUALIB_API int luaL_len (lua_State *L, int idx) {\n  int l;\n  int isnum;\n  lua_len(L, idx);\n  l = (int)lua_tointegerx(L, -1, &isnum);\n  if (!isnum)\n    luaL_error(L, \"object length is not a number\");\n  lua_pop(L, 1);   \n  return l;\n}\n\n\nLUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {\n  if (!luaL_callmeta(L, idx, \"__tostring\")) {   \n    switch (lua_type(L, idx)) {\n      case LUA_TNUMBER:\n      case LUA_TSTRING:\n        lua_pushvalue(L, idx);\n        break;\n      case LUA_TBOOLEAN:\n        lua_pushstring(L, (lua_toboolean(L, idx) ? \"true\" : \"false\"));\n        break;\n      case LUA_TNIL:\n        lua_pushliteral(L, \"nil\");\n        break;\n      default:\n        lua_pushfstring(L, \"%s: %p\", luaL_typename(L, idx),\n                                            lua_topointer(L, idx));\n        break;\n    }\n  }\n  return lua_tolstring(L, -1, len);\n}\n\n\n \n#if defined(LUA_COMPAT_MODULE)\n\nstatic const char *luaL_findtable (lua_State *L, int idx,\n                                   const char *fname, int szhint) {\n  const char *e;\n  if (idx) lua_pushvalue(L, idx);\n  do {\n    e = strchr(fname, '.');\n    if (e == NULL) e = fname + strlen(fname);\n    lua_pushlstring(L, fname, e - fname);\n    lua_rawget(L, -2);\n    if (lua_isnil(L, -1)) {   \n      lua_pop(L, 1);   \n      lua_createtable(L, 0, (*e == '.' ? 1 : szhint));  \n      lua_pushlstring(L, fname, e - fname);\n      lua_pushvalue(L, -2);\n      lua_settable(L, -4);   \n    }\n    else if (!lua_istable(L, -1)) {   \n      lua_pop(L, 2);   \n      return fname;   \n    }\n    lua_remove(L, -2);   \n    fname = e + 1;\n  } while (*e == '.');\n  return NULL;\n}\n\n\n \nstatic int libsize (const luaL_Reg *l) {\n  int size = 0;\n  for (; l && l->name; l++) size++;\n  return size;\n}\n\n\n \nLUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,\n                                 int sizehint) {\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 1);   \n  lua_getfield(L, -1, modname);   \n  if (!lua_istable(L, -1)) {   \n    lua_pop(L, 1);   \n     \n    lua_pushglobaltable(L);\n    if (luaL_findtable(L, 0, modname, sizehint) != NULL)\n      luaL_error(L, \"name conflict for module \" LUA_QS, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -3, modname);   \n  }\n  lua_remove(L, -2);   \n}\n\n\nLUALIB_API void luaL_openlib (lua_State *L, const char *libname,\n                               const luaL_Reg *l, int nup) {\n  luaL_checkversion(L);\n  if (libname) {\n    luaL_pushmodule(L, libname, libsize(l));   \n    lua_insert(L, -(nup + 1));   \n  }\n  if (l)\n    luaL_setfuncs(L, l, nup);\n  else\n    lua_pop(L, nup);   \n}\n\n#endif\n \n\n \nLUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {\n  luaL_checkversion(L);\n  luaL_checkstack(L, nup, \"too many upvalues\");\n  for (; l->name != NULL; l++) {   \n    int i;\n    for (i = 0; i < nup; i++)   \n      lua_pushvalue(L, -nup);\n    lua_pushcclosure(L, l->func, nup);   \n    lua_setfield(L, -(nup + 2), l->name);\n  }\n  lua_pop(L, nup);   \n}\n\n\n \nLUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {\n  lua_getfield(L, idx, fname);\n  if (lua_istable(L, -1)) return 1;   \n  else {\n    lua_pop(L, 1);   \n    idx = lua_absindex(L, idx);\n    lua_newtable(L);\n    lua_pushvalue(L, -1);   \n    lua_setfield(L, idx, fname);   \n    return 0;   \n  }\n}\n\n\n \nLUALIB_API void luaL_requiref (lua_State *L, const char *modname,\n                               lua_CFunction openf, int glb) {\n  lua_pushcfunction(L, openf);\n  lua_pushstring(L, modname);   \n  lua_call(L, 1, 1);   \n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_pushvalue(L, -2);   \n  lua_setfield(L, -2, modname);   \n  lua_pop(L, 1);   \n  if (glb) {\n    lua_pushvalue(L, -1);   \n    lua_setglobal(L, modname);   \n  }\n}\n\n\nLUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,\n                                                               const char *r) {\n  const char *wild;\n  size_t l = strlen(p);\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(&b, s, wild - s);   \n    luaL_addstring(&b, r);   \n    s = wild + l;   \n  }\n  luaL_addstring(&b, s);   \n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}\n\n\nLUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {\n  const lua_Number *v = lua_version(L);\n  if (v != lua_version(NULL))\n    luaL_error(L, \"multiple Lua VMs detected\");\n  else if (*v != ver)\n    luaL_error(L, \"version mismatch: app. needs %f, Lua core provides %f\",\n                  ver, *v);\n   \n  lua_pushnumber(L, -(lua_Number)0x1234);\n  if (lua_tointeger(L, -1) != -0x1234 ||\n      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)\n    luaL_error(L, \"bad conversion number->int;\"\n                  \" must recompile Lua with proper settings\");\n  lua_pop(L, 1);\n}\n\n#if defined(_KERNEL)\n\nEXPORT_SYMBOL(luaL_argerror);\nEXPORT_SYMBOL(luaL_error);\nEXPORT_SYMBOL(luaL_loadbufferx);\nEXPORT_SYMBOL(luaL_newmetatable);\nEXPORT_SYMBOL(luaL_traceback);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}