{
  "module_name": "lgc.h",
  "hash_id": "51122251d068518777a6b525018be8a677b2d7152a09724ec5c304443e70841c",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lgc.h",
  "human_readable_source": " \n\n#ifndef lgc_h\n#define lgc_h\n\n\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n \n\n\n\n \n#if !defined(GCSTEPSIZE)\n \n#define GCSTEPSIZE\t(cast_int(100 * sizeof(TString)))\n#endif\n\n\n \n#define GCSpropagate\t0\n#define GCSatomic\t1\n#define GCSsweepstring\t2\n#define GCSsweepudata\t3\n#define GCSsweep\t4\n#define GCSpause\t5\n\n\n#define issweepphase(g)  \\\n\t(GCSsweepstring <= (g)->gcstate && (g)->gcstate <= GCSsweep)\n\n#define isgenerational(g)\t((g)->gckind == KGC_GEN)\n\n \n\n#define keepinvariant(g)\t(isgenerational(g) || g->gcstate <= GCSatomic)\n\n\n \n#define keepinvariantout(g)  \\\n  check_exp(g->gcstate == GCSpropagate || !isgenerational(g),  \\\n            g->gcstate <= GCSatomic)\n\n\n \n#define resetbits(x,m)\t\t((x) &= cast(lu_byte, ~(m)))\n#define setbits(x,m)\t\t((x) |= (m))\n#define testbits(x,m)\t\t((x) & (m))\n#define bitmask(b)\t\t(1<<(b))\n#define bit2mask(b1,b2)\t\t(bitmask(b1) | bitmask(b2))\n#define l_setbit(x,b)\t\tsetbits(x, bitmask(b))\n#define resetbit(x,b)\t\tresetbits(x, bitmask(b))\n#define testbit(x,b)\t\ttestbits(x, bitmask(b))\n\n\n \n#define WHITE0BIT\t0   \n#define WHITE1BIT\t1   \n#define BLACKBIT\t2   \n#define FINALIZEDBIT\t3   \n#define SEPARATED\t4   \n#define FIXEDBIT\t5   \n#define OLDBIT\t\t6   \n \n\n#define WHITEBITS\tbit2mask(WHITE0BIT, WHITE1BIT)\n\n\n#define iswhite(x)      testbits((x)->gch.marked, WHITEBITS)\n#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)\n#define isgray(x)     \\\n\t(!testbits((x)->gch.marked, WHITEBITS | bitmask(BLACKBIT)))\n\n#define isold(x)\ttestbit((x)->gch.marked, OLDBIT)\n\n \n#define resetoldbit(o)\tresetbit((o)->gch.marked, OLDBIT)\n\n#define otherwhite(g)\t(g->currentwhite ^ WHITEBITS)\n#define isdeadm(ow,m)\t(!(((m) ^ WHITEBITS) & (ow)))\n#define isdead(g,v)\tisdeadm(otherwhite(g), (v)->gch.marked)\n\n#define changewhite(x)\t((x)->gch.marked ^= WHITEBITS)\n#define gray2black(x)\tl_setbit((x)->gch.marked, BLACKBIT)\n\n#define valiswhite(x)\t(iscollectable(x) && iswhite(gcvalue(x)))\n\n#define luaC_white(g)\tcast(lu_byte, (g)->currentwhite & WHITEBITS)\n\n\n#define luaC_condGC(L,c) \\\n\t{if (G(L)->GCdebt > 0) {c;} condchangemem(L);}\n#define luaC_checkGC(L)\t\tluaC_condGC(L, luaC_step(L);)\n\n\n#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \\\n\tluaC_barrier_(L,obj2gco(p),gcvalue(v)); }\n\n#define luaC_barrierback(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \\\n\tluaC_barrierback_(L,p); }\n\n#define luaC_objbarrier(L,p,o)  \\\n\t{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \\\n\t\tluaC_barrier_(L,obj2gco(p),obj2gco(o)); }\n\n#define luaC_objbarrierback(L,p,o)  \\\n   { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierback_(L,p); }\n\n#define luaC_barrierproto(L,p,c) \\\n   { if (isblack(obj2gco(p))) luaC_barrierproto_(L,p,c); }\n\nLUAI_FUNC void luaC_freeallobjects (lua_State *L);\nLUAI_FUNC void luaC_step (lua_State *L);\nLUAI_FUNC void luaC_forcestep (lua_State *L);\nLUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);\nLUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);\nLUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz,\n                                 GCObject **list, int offset);\nLUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);\nLUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);\nLUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c);\nLUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);\nLUAI_FUNC void luaC_checkupvalcolor (global_State *g, UpVal *uv);\nLUAI_FUNC void luaC_changemode (lua_State *L, int mode);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}