{
  "module_name": "lvm.c",
  "hash_id": "5366b80aac528612a80a9b38739fb35c4464e983d1d86b9fd329fa1e8e22191f",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lvm.c",
  "human_readable_source": " \n\n\n#define lvm_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n#ifdef _KERNEL\n#define\tstrcoll(l,r) (strcmp((l),(r)))\n#endif\n\n \n#define MAXTAGLOOP\t100\n\n\nconst TValue *luaV_tonumber (const TValue *obj, TValue *n) {\n  lua_Number num;\n  if (ttisnumber(obj)) return obj;\n  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {\n    setnvalue(n, num);\n    return n;\n  }\n  else\n    return NULL;\n}\n\n\nint luaV_tostring (lua_State *L, StkId obj) {\n  if (!ttisnumber(obj))\n    return 0;\n  else {\n    char s[LUAI_MAXNUMBER2STR];\n    lua_Number n = nvalue(obj);\n    int l = lua_number2str(s, n);\n    setsvalue2s(L, obj, luaS_newlstr(L, s, l));\n    return 1;\n  }\n}\n\n\nstatic void traceexec (lua_State *L) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);\n  if (counthook)\n    resethookcount(L);   \n  if (ci->callstatus & CIST_HOOKYIELD) {   \n    ci->callstatus &= ~CIST_HOOKYIELD;   \n    return;   \n  }\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1);   \n  if (mask & LUA_MASKLINE) {\n    Proto *p = ci_func(ci)->p;\n    int npc = pcRel(ci->u.l.savedpc, p);\n    int newline = getfuncline(p, npc);\n    if (npc == 0 ||   \n        ci->u.l.savedpc <= L->oldpc ||   \n        newline != getfuncline(p, pcRel(L->oldpc, p)))   \n      luaD_hook(L, LUA_HOOKLINE, newline);   \n  }\n  L->oldpc = ci->u.l.savedpc;\n  if (L->status == LUA_YIELD) {   \n    if (counthook)\n      L->hookcount = 1;   \n    ci->u.l.savedpc--;   \n    ci->callstatus |= CIST_HOOKYIELD;   \n    ci->func = L->top - 1;   \n    luaD_throw(L, LUA_YIELD);\n  }\n}\n\n\nstatic void callTM (lua_State *L, const TValue *f, const TValue *p1,\n                    const TValue *p2, TValue *p3, int hasres) {\n  if (L == NULL) return;\n\n  ptrdiff_t result = savestack(L, p3);\n  setobj2s(L, L->top++, f);   \n  setobj2s(L, L->top++, p1);   \n  setobj2s(L, L->top++, p2);   \n  if (!hasres)   \n    setobj2s(L, L->top++, p3);   \n   \n  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));\n  if (hasres) {   \n    p3 = restorestack(L, result);\n    setobjs2s(L, p3, --L->top);\n  }\n}\n\n\nvoid luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n  int loop;\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;\n    if (ttistable(t)) {   \n      Table *h = hvalue(t);\n      const TValue *res = luaH_get(h, key);  \n      if (!ttisnil(res) ||   \n          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) {  \n        setobj2s(L, val, res);\n        return;\n      }\n       \n    }\n    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))\n      luaG_typeerror(L, t, \"index\");\n    if (ttisfunction(tm)) {\n      callTM(L, tm, t, key, val, 1);\n      return;\n    }\n    t = tm;   \n  }\n  luaG_runerror(L, \"loop in gettable\");\n}\n\n\nvoid luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {\n  int loop;\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;\n    if (ttistable(t)) {   \n      Table *h = hvalue(t);\n      TValue *oldval = cast(TValue *, luaH_get(h, key));\n       \n      if (!ttisnil(oldval) ||\n          \n         ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&\n          \n         (oldval != luaO_nilobject ||\n          \n         (oldval = luaH_newkey(L, h, key), 1)))) {\n         \n        setobj2t(L, oldval, val);   \n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n       \n    }\n    else   \n      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))\n        luaG_typeerror(L, t, \"index\");\n     \n    if (ttisfunction(tm)) {\n      callTM(L, tm, t, key, val, 0);\n      return;\n    }\n    t = tm;   \n  }\n  luaG_runerror(L, \"loop in settable\");\n}\n\n\nstatic int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,\n                       StkId res, TMS event) {\n  const TValue *tm = luaT_gettmbyobj(L, p1, event);   \n  if (ttisnil(tm))\n    tm = luaT_gettmbyobj(L, p2, event);   \n  if (ttisnil(tm)) return 0;\n  callTM(L, tm, p1, p2, res, 1);\n  return 1;\n}\n\n\nstatic const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,\n                                  TMS event) {\n  const TValue *tm1 = fasttm(L, mt1, event);\n  const TValue *tm2;\n  if (tm1 == NULL) return NULL;   \n  if (mt1 == mt2) return tm1;   \n  tm2 = fasttm(L, mt2, event);\n  if (tm2 == NULL) return NULL;   \n  if (luaV_rawequalobj(tm1, tm2))   \n    return tm1;\n  return NULL;\n}\n\n\nstatic int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,\n                         TMS event) {\n  if (!call_binTM(L, p1, p2, L->top, event))\n    return -1;   \n  else\n    return !l_isfalse(L->top);\n}\n\n\nstatic int l_strcmp (const TString *ls, const TString *rs) {\n  const char *l = getstr(ls);\n  size_t ll = ls->tsv.len;\n  const char *r = getstr(rs);\n  size_t lr = rs->tsv.len;\n  for (;;) {\n    int temp = strcoll(l, r);\n    if (temp != 0) return temp;\n    else {   \n      size_t len = strlen(l);   \n      if (len == lr)   \n        return (len == ll) ? 0 : 1;\n      else if (len == ll)   \n        return -1;   \n       \n      len++;\n      l += len; ll -= len; r += len; lr -= len;\n    }\n  }\n}\n\n\nint luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {\n  int res;\n  if (ttisnumber(l) && ttisnumber(r))\n    return luai_numlt(L, nvalue(l), nvalue(r));\n  else if (ttisstring(l) && ttisstring(r))\n    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;\n  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)\n    luaG_ordererror(L, l, r);\n  return res;\n}\n\n\nint luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {\n  int res;\n  if (ttisnumber(l) && ttisnumber(r))\n    return luai_numle(L, nvalue(l), nvalue(r));\n  else if (ttisstring(l) && ttisstring(r))\n    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;\n  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)   \n    return res;\n  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)   \n    luaG_ordererror(L, l, r);\n  return !res;\n}\n\n\n \nint luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {\n  const TValue *tm;\n  lua_assert(ttisequal(t1, t2));\n  switch (ttype(t1)) {\n    case LUA_TNIL: return 1;\n    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));\n    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);   \n    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_TLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));\n    case LUA_TUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);\n      break;   \n    }\n    case LUA_TTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);\n      break;   \n    }\n    default:\n      lua_assert(iscollectable(t1));\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL || L == NULL) return 0;   \n  callTM(L, tm, t1, t2, L->top, 1);   \n  return !l_isfalse(L->top);\n}\n\n\nvoid luaV_concat (lua_State *L, int total) {\n  lua_assert(total >= 2);\n  do {\n    StkId top = L->top;\n    int n = 2;   \n    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {\n      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))\n        luaG_concaterror(L, top-2, top-1);\n    }\n    else if (tsvalue(top-1)->len == 0)   \n      (void)tostring(L, top - 2);   \n    else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {\n      setobjs2s(L, top - 2, top - 1);   \n    }\n    else {\n       \n      size_t tl = tsvalue(top-1)->len;\n      char *buffer;\n      int i;\n       \n      for (i = 1; i < total && tostring(L, top-i-1); i++) {\n        size_t l = tsvalue(top-i-1)->len;\n        if (l >= (MAX_SIZET/sizeof(char)) - tl)\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      buffer = luaZ_openspace(L, &G(L)->buff, tl);\n      tl = 0;\n      n = i;\n      do {   \n        size_t l = tsvalue(top-i)->len;\n        memcpy(buffer+tl, svalue(top-i), l * sizeof(char));\n        tl += l;\n      } while (--i > 0);\n      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));\n    }\n    total -= n-1;   \n    L->top -= n-1;   \n  } while (total > 1);   \n}\n\n\nvoid luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {\n  const TValue *tm;\n  switch (ttypenv(rb)) {\n    case LUA_TTABLE: {\n      Table *h = hvalue(rb);\n      tm = fasttm(L, h->metatable, TM_LEN);\n      if (tm) break;   \n      setnvalue(ra, cast_num(luaH_getn(h)));   \n      return;\n    }\n    case LUA_TSTRING: {\n      setnvalue(ra, cast_num(tsvalue(rb)->len));\n      return;\n    }\n    default: {   \n      tm = luaT_gettmbyobj(L, rb, TM_LEN);\n      if (ttisnil(tm))   \n        luaG_typeerror(L, rb, \"get length of\");\n      break;\n    }\n  }\n  callTM(L, tm, rb, rb, ra, 1);\n}\n\n \n\n \nstatic lua_Number luaV_div (lua_State *L, lua_Number m, lua_Number n) {\n  if ((lua_Unsigned)(n) + 1u <= 1u) {   \n    if (n == 0)\n      luaG_runerror(L, \"attempt to divide by zero\");\n    return (0 - m);    \n    if ((m ^ n) < 0 && m % n != 0)   \n      q -= 1;   \n    return q;\n  }\n}\n\n\n \nstatic lua_Number luaV_mod (lua_State *L, lua_Number m, lua_Number n) {\n  if ((lua_Unsigned)(n) + 1u <= 1u) {   \n    if (n == 0)\n      luaG_runerror(L, \"attempt to perform 'n%%0'\");\n    return 0;    \n  }\n  else {\n    lua_Number r = m % n;\n    if (r != 0 && (m ^ n) < 0)   \n      r += n;   \n    return r;\n  }\n}\n\n \n\nvoid luaV_arith (lua_State *L, StkId ra, const TValue *rb,\n                 const TValue *rc, TMS op) {\n  TValue tempb, tempc;\n  const TValue *b, *c;\n  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&\n      (c = luaV_tonumber(rc, &tempc)) != NULL) {\n     \n    lua_Number res;\n    int lop = op - TM_ADD + LUA_OPADD;\n    if (lop == LUA_OPDIV) {\n      res = luaV_div(L, nvalue(b), nvalue(c));\n    } else if (lop == LUA_OPMOD) {\n      res = luaV_mod(L, nvalue(b), nvalue(c));\n    } else {\n      res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));\n    }\n    setnvalue(ra, res);\n  }\n  else if (!call_binTM(L, rb, rc, ra, op))\n    luaG_aritherror(L, rb, rc);\n}\n\n\n \nstatic Closure *getcached (Proto *p, UpVal **encup, StkId base) {\n  Closure *c = p->cache;\n  if (c != NULL) {   \n    int nup = p->sizeupvalues;\n    Upvaldesc *uv = p->upvalues;\n    int i;\n    for (i = 0; i < nup; i++) {   \n      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;\n      if (c->l.upvals[i]->v != v)\n        return NULL;   \n    }\n  }\n  return c;   \n}\n\n\n \nstatic void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra) {\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  Closure *ncl = luaF_newLclosure(L, nup);\n  ncl->l.p = p;\n  setclLvalue(L, ra, ncl);   \n  for (i = 0; i < nup; i++) {   \n    if (uv[i].instack)   \n      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else   \n      ncl->l.upvals[i] = encup[uv[i].idx];\n  }\n  luaC_barrierproto(L, p, ncl);\n  p->cache = ncl;   \n}\n\n\n \nvoid luaV_finishOp (lua_State *L) {\n  CallInfo *ci = L->ci;\n  StkId base = ci->u.l.base;\n  Instruction inst = *(ci->u.l.savedpc - 1);   \n  OpCode op = GET_OPCODE(inst);\n  switch (op) {   \n    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:\n    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top);\n      break;\n    }\n    case OP_LE: case OP_LT: case OP_EQ: {\n      int res = !l_isfalse(L->top - 1);\n      L->top--;\n       \n      lua_assert(!ISK(GETARG_B(inst)));\n      if (op == OP_LE &&   \n          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))\n        res = !res;   \n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_A(inst))   \n        ci->u.l.savedpc++;   \n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top - 1;   \n      int b = GETARG_B(inst);       \n      int total = cast_int(top - 1 - (base + b));   \n      setobj2s(L, top - 2, top);   \n      if (total > 1) {   \n        L->top = top - 1;   \n        luaV_concat(L, total);   \n      }\n       \n      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);\n      L->top = ci->top;   \n      break;\n    }\n    case OP_TFORCALL: {\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);\n      L->top = ci->top;   \n      break;\n    }\n    case OP_CALL: {\n      if (GETARG_C(inst) - 1 >= 0)   \n        L->top = ci->top;   \n      break;\n    }\n    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:\n      break;\n    default: lua_assert(0);\n  }\n}\n\n\n\n \n\n#if !defined luai_runtimecheck\n#define luai_runtimecheck(L, c)\t\t \n#endif\n\n\n#define RA(i)\t(base+GETARG_A(i))\n \n#define RB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))\n#define RC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))\n#define RKB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\\n\tISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))\n#define RKC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\\n\tISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))\n#define KBx(i)  \\\n  (k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))\n\n\n \n#define dojump(ci,i,e) \\\n  { int a = GETARG_A(i); \\\n    if (a > 0) luaF_close(L, ci->u.l.base + a - 1); \\\n    ci->u.l.savedpc += GETARG_sBx(i) + e; }\n\n \n#define donextjump(ci)\t{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }\n\n\n#define Protect(x)\t{ {x;} base = ci->u.l.base; }\n\n#define checkGC(L,c)  \\\n  Protect( luaC_condGC(L,{L->top = (c);    \\\n                          luaC_step(L); \\\n                          L->top = ci->top;})    \\\n           luai_threadyield(L); )\n\n\n#define arith_op(op,tm) { \\\n        TValue *rb = RKB(i); \\\n        TValue *rc = RKC(i); \\\n        if (ttisnumber(rb) && ttisnumber(rc)) { \\\n          lua_Number nb = nvalue(rb), nc = nvalue(rc); \\\n          setnvalue(ra, op(L, nb, nc)); \\\n        } \\\n        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }\n\n\n#define vmdispatch(o)\tswitch(o)\n#define vmcase(l,b)\tcase l: {b}  break;\n#define vmcasenb(l,b)\tcase l: {b}\t\t \n\nvoid luaV_execute (lua_State *L) {\n  CallInfo *ci = L->ci;\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n newframe:   \n  lua_assert(ci == L->ci);\n  cl = clLvalue(ci->func);\n  k = cl->p->k;\n  base = ci->u.l.base;\n   \n  for (;;) {\n    Instruction i = *(ci->u.l.savedpc++);\n    StkId ra;\n    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&\n        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {\n      Protect(traceexec(L));\n    }\n     \n    ra = RA(i);\n    lua_assert(base == ci->u.l.base);\n    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE,\n        setobjs2s(L, ra, RB(i));\n      )\n      vmcase(OP_LOADK,\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n      )\n      vmcase(OP_LOADKX,\n        TValue *rb;\n        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);\n        rb = k + GETARG_Ax(*ci->u.l.savedpc++);\n        setobj2s(L, ra, rb);\n      )\n      vmcase(OP_LOADBOOL,\n        setbvalue(ra, GETARG_B(i));\n        if (GETARG_C(i)) ci->u.l.savedpc++;   \n      )\n      vmcase(OP_LOADNIL,\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(ra++);\n        } while (b--);\n      )\n      vmcase(OP_GETUPVAL,\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v);\n      )\n      vmcase(OP_GETTABUP,\n        int b = GETARG_B(i);\n        Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));\n      )\n      vmcase(OP_GETTABLE,\n        Protect(luaV_gettable(L, RB(i), RKC(i), ra));\n      )\n      vmcase(OP_SETTABUP,\n        int a = GETARG_A(i);\n        Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));\n      )\n      vmcase(OP_SETUPVAL,\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v, ra);\n        luaC_barrier(L, uv, ra);\n      )\n      vmcase(OP_SETTABLE,\n        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));\n      )\n      vmcase(OP_NEWTABLE,\n        int b = GETARG_B(i);\n        int c = GETARG_C(i);\n        Table *t = luaH_new(L);\n        sethvalue(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));\n        checkGC(L, ra + 1);\n      )\n      vmcase(OP_SELF,\n        StkId rb = RB(i);\n        setobjs2s(L, ra+1, rb);\n        Protect(luaV_gettable(L, rb, RKC(i), ra));\n      )\n      vmcase(OP_ADD,\n        arith_op(luai_numadd, TM_ADD);\n      )\n      vmcase(OP_SUB,\n        arith_op(luai_numsub, TM_SUB);\n      )\n      vmcase(OP_MUL,\n        arith_op(luai_nummul, TM_MUL);\n      )\n       \n      vmcase(OP_DIV,\n        arith_op(luaV_div, TM_DIV);\n      )\n      vmcase(OP_MOD,\n        arith_op(luaV_mod, TM_MOD);\n      )\n      vmcase(OP_POW,\n        arith_op(luai_numpow, TM_POW);\n      )\n      vmcase(OP_UNM,\n        TValue *rb = RB(i);\n        if (ttisnumber(rb)) {\n          lua_Number nb = nvalue(rb);\n          setnvalue(ra, luai_numunm(L, nb));\n        }\n        else {\n          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));\n        }\n      )\n      vmcase(OP_NOT,\n        TValue *rb = RB(i);\n        int res = l_isfalse(rb);   \n        setbvalue(ra, res);\n      )\n      vmcase(OP_LEN,\n        Protect(luaV_objlen(L, ra, RB(i)));\n      )\n      vmcase(OP_CONCAT,\n        int b = GETARG_B(i);\n        int c = GETARG_C(i);\n        StkId rb;\n        L->top = base + c + 1;   \n        Protect(luaV_concat(L, c - b + 1));\n        ra = RA(i);   \n        rb = b + base;\n        setobjs2s(L, ra, rb);\n        checkGC(L, (ra >= rb ? ra + 1 : rb));\n        L->top = ci->top;   \n      )\n      vmcase(OP_JMP,\n        dojump(ci, i, 0);\n      )\n      vmcase(OP_EQ,\n        TValue *rb = RKB(i);\n        TValue *rc = RKC(i);\n        Protect(\n          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))\n            ci->u.l.savedpc++;\n          else\n            donextjump(ci);\n        )\n      )\n      vmcase(OP_LT,\n        Protect(\n          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))\n            ci->u.l.savedpc++;\n          else\n            donextjump(ci);\n        )\n      )\n      vmcase(OP_LE,\n        Protect(\n          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))\n            ci->u.l.savedpc++;\n          else\n            donextjump(ci);\n        )\n      )\n      vmcase(OP_TEST,\n        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))\n            ci->u.l.savedpc++;\n          else\n          donextjump(ci);\n      )\n      vmcase(OP_TESTSET,\n        TValue *rb = RB(i);\n        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))\n          ci->u.l.savedpc++;\n        else {\n          setobjs2s(L, ra, rb);\n          donextjump(ci);\n        }\n      )\n      vmcase(OP_CALL,\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0) L->top = ra+b;   \n        if (luaD_precall(L, ra, nresults)) {   \n          if (nresults >= 0) L->top = ci->top;   \n          base = ci->u.l.base;\n        }\n        else {   \n          ci = L->ci;\n          ci->callstatus |= CIST_REENTRY;\n          goto newframe;   \n        }\n      )\n      vmcase(OP_TAILCALL,\n        int b = GETARG_B(i);\n        if (b != 0) L->top = ra+b;   \n        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);\n        if (luaD_precall(L, ra, LUA_MULTRET))   \n          base = ci->u.l.base;\n        else {\n           \n          CallInfo *nci = L->ci;   \n          CallInfo *oci = nci->previous;   \n          StkId nfunc = nci->func;   \n          StkId ofunc = oci->func;   \n           \n          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;\n          int aux;\n           \n          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);\n           \n          for (aux = 0; nfunc + aux < lim; aux++)\n            setobjs2s(L, ofunc + aux, nfunc + aux);\n          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);   \n          oci->top = L->top = ofunc + (L->top - nfunc);   \n          oci->u.l.savedpc = nci->u.l.savedpc;\n          oci->callstatus |= CIST_TAIL;   \n          ci = L->ci = oci;   \n          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);\n          goto newframe;   \n        }\n      )\n      vmcasenb(OP_RETURN,\n        int b = GETARG_B(i);\n        if (b != 0) L->top = ra+b-1;\n        if (cl->p->sizep > 0) luaF_close(L, base);\n        b = luaD_poscall(L, ra);\n        if (!(ci->callstatus & CIST_REENTRY))   \n          return;   \n        else {   \n          ci = L->ci;\n          if (b) L->top = ci->top;\n          lua_assert(isLua(ci));\n          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);\n          goto newframe;   \n        }\n      )\n      vmcase(OP_FORLOOP,\n        lua_Number step = nvalue(ra+2);\n        lua_Number idx = luai_numadd(L, nvalue(ra), step);  \n        lua_Number limit = nvalue(ra+1);\n        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)\n                                   : luai_numle(L, limit, idx)) {\n          ci->u.l.savedpc += GETARG_sBx(i);   \n          setnvalue(ra, idx);   \n          setnvalue(ra+3, idx);   \n        }\n      )\n      vmcase(OP_FORPREP,\n        const TValue *init = ra;\n        const TValue *plimit = ra+1;\n        const TValue *pstep = ra+2;\n        if (!tonumber(init, ra))\n          luaG_runerror(L, LUA_QL(\"for\") \" initial value must be a number\");\n        else if (!tonumber(plimit, ra+1))\n          luaG_runerror(L, LUA_QL(\"for\") \" limit must be a number\");\n        else if (!tonumber(pstep, ra+2))\n          luaG_runerror(L, LUA_QL(\"for\") \" step must be a number\");\n        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));\n        ci->u.l.savedpc += GETARG_sBx(i);\n      )\n      vmcasenb(OP_TFORCALL,\n        StkId cb = ra + 3;   \n        setobjs2s(L, cb+2, ra+2);\n        setobjs2s(L, cb+1, ra+1);\n        setobjs2s(L, cb, ra);\n        L->top = cb + 3;   \n        Protect(luaD_call(L, cb, GETARG_C(i), 1));\n        L->top = ci->top;\n        i = *(ci->u.l.savedpc++);   \n        ra = RA(i);\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);\n        goto l_tforloop;\n      )\n      vmcase(OP_TFORLOOP,\n        l_tforloop:\n        if (!ttisnil(ra + 1)) {   \n          setobjs2s(L, ra, ra + 1);   \n           ci->u.l.savedpc += GETARG_sBx(i);   \n        }\n      )\n      vmcase(OP_SETLIST,\n        int n = GETARG_B(i);\n        int c = GETARG_C(i);\n        int last;\n        Table *h;\n        if (n == 0) n = cast_int(L->top - ra) - 1;\n        if (c == 0) {\n          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);\n          c = GETARG_Ax(*ci->u.l.savedpc++);\n        }\n        luai_runtimecheck(L, ttistable(ra));\n        h = hvalue(ra);\n        last = ((c-1)*LFIELDS_PER_FLUSH) + n;\n        if (last > h->sizearray)   \n          luaH_resizearray(L, h, last);   \n        for (; n > 0; n--) {\n          TValue *val = ra+n;\n          luaH_setint(L, h, last--, val);\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        L->top = ci->top;   \n      )\n      vmcase(OP_CLOSURE,\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        Closure *ncl = getcached(p, cl->upvals, base);   \n        if (ncl == NULL)   \n          pushclosure(L, p, cl->upvals, base, ra);   \n        else\n          setclLvalue(L, ra, ncl);   \n        checkGC(L, ra + 1);\n      )\n      vmcase(OP_VARARG,\n        int b = GETARG_B(i) - 1;\n        int j;\n        int n = cast_int(base - ci->func) - cl->p->numparams - 1;\n        if (b < 0) {   \n          b = n;   \n          Protect(luaD_checkstack(L, n));\n          ra = RA(i);   \n          L->top = ra + n;\n        }\n        for (j = 0; j < b; j++) {\n          if (j < n) {\n            setobjs2s(L, ra + j, base - n + j);\n          }\n          else {\n            setnilvalue(ra + j);\n          }\n        }\n      )\n      vmcase(OP_EXTRAARG,\n        lua_assert(0);\n      )\n    }\n  }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}