{
  "module_name": "lstate.c",
  "hash_id": "90c94ad6efacf8d0623be209adb016d2f72ec30189d5ef1eaab438a66a51fa05",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lstate.c",
  "human_readable_source": " \n\n\n#define lstate_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n#if !defined(LUAI_GCPAUSE)\n#define LUAI_GCPAUSE\t200   \n#endif\n\n#if !defined(LUAI_GCMAJOR)\n#define LUAI_GCMAJOR\t200   \n#endif\n\n#if !defined(LUAI_GCMUL)\n#define LUAI_GCMUL\t200  \n#endif\n\n\n#define MEMERRMSG\t\"not enough memory\"\n\n\n \n#if !defined(luai_makeseed)\n#define luai_makeseed()\t\tcast(unsigned int, gethrtime())\n#endif\n\n\n\n \ntypedef struct LX {\n#if defined(LUAI_EXTRASPACE)\n  char buff[LUAI_EXTRASPACE];\n#endif\n  lua_State l;\n} LX;\n\n\n \ntypedef struct LG {\n  LX l;\n  global_State g;\n} LG;\n\n\n\n#define fromstate(L)\t(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))\n\n\n \n#define addbuff(b,p,e) \\\n  { size_t t = cast(size_t, e); \\\n    memcpy(buff + p, &t, sizeof(t)); p += sizeof(t); }\n\nstatic unsigned int makeseed (lua_State *L) {\n  char buff[4 * sizeof(size_t)];\n  unsigned int h = luai_makeseed();\n  int p = 0;\n  addbuff(buff, p, L);   \n  addbuff(buff, p, &h);   \n  addbuff(buff, p, luaO_nilobject);   \n  addbuff(buff, p, &lua_newstate);   \n  lua_assert(p == sizeof(buff));\n  return luaS_hash(buff, p, h);\n}\n\n\n \nvoid luaE_setdebt (global_State *g, l_mem debt) {\n  g->totalbytes -= (debt - g->GCdebt);\n  g->GCdebt = debt;\n}\n\n\nCallInfo *luaE_extendCI (lua_State *L) {\n  CallInfo *ci = luaM_new(L, CallInfo);\n  lua_assert(L->ci->next == NULL);\n  L->ci->next = ci;\n  ci->previous = L->ci;\n  ci->next = NULL;\n  return ci;\n}\n\n\nvoid luaE_freeCI (lua_State *L) {\n  CallInfo *ci = L->ci;\n  CallInfo *next = ci->next;\n  ci->next = NULL;\n  while ((ci = next) != NULL) {\n    next = ci->next;\n    luaM_free(L, ci);\n  }\n}\n\n\nstatic void stack_init (lua_State *L1, lua_State *L) {\n  int i; CallInfo *ci;\n   \n  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);\n  L1->stacksize = BASIC_STACK_SIZE;\n  for (i = 0; i < BASIC_STACK_SIZE; i++)\n    setnilvalue(L1->stack + i);   \n  L1->top = L1->stack;\n  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;\n   \n  ci = &L1->base_ci;\n  ci->next = ci->previous = NULL;\n  ci->callstatus = 0;\n  ci->func = L1->top;\n  setnilvalue(L1->top++);   \n  ci->top = L1->top + LUA_MINSTACK;\n  L1->ci = ci;\n}\n\n\nstatic void freestack (lua_State *L) {\n  if (L->stack == NULL)\n    return;   \n  L->ci = &L->base_ci;   \n  luaE_freeCI(L);\n  luaM_freearray(L, L->stack, L->stacksize);   \n}\n\n\n \nstatic void init_registry (lua_State *L, global_State *g) {\n  TValue mt;\n   \n  Table *registry = luaH_new(L);\n  sethvalue(L, &g->l_registry, registry);\n  luaH_resize(L, registry, LUA_RIDX_LAST, 0);\n   \n  setthvalue(L, &mt, L);\n  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);\n   \n  sethvalue(L, &mt, luaH_new(L));\n  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);\n}\n\n\n \nstatic void f_luaopen (lua_State *L, void *ud) {\n  global_State *g = G(L);\n  UNUSED(ud);\n  stack_init(L, L);   \n  init_registry(L, g);\n  luaS_resize(L, MINSTRTABSIZE);   \n  luaT_init(L);\n  luaX_init(L);\n   \n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaS_fix(g->memerrmsg);   \n  g->gcrunning = 1;   \n  g->version = lua_version(NULL);\n  luai_userstateopen(L);\n}\n\n\n \nstatic void preinit_state (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->stacksize = 0;\n  L->errorJmp = NULL;\n  L->nCcalls = 0;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->nny = 1;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->runerror = 0;\n}\n\n\nstatic void close_state (lua_State *L) {\n  global_State *g = G(L);\n  luaF_close(L, L->stack);   \n  luaC_freeallobjects(L);   \n  if (g->version)   \n    luai_userstateclose(L);\n  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);\n  luaZ_freebuffer(L, &g->buff);\n  freestack(L);\n  lua_assert(gettotalbytes(g) == sizeof(LG));\n  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);   \n}\n\n\nLUA_API lua_State *lua_newthread (lua_State *L) {\n  lua_State *L1;\n  lua_lock(L);\n  luaC_checkGC(L);\n  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;\n  setthvalue(L, L->top, L1);\n  api_incr_top(L);\n  preinit_state(L1, G(L));\n  L1->hookmask = L->hookmask;\n  L1->basehookcount = L->basehookcount;\n  L1->hook = L->hook;\n  resethookcount(L1);\n  luai_userstatethread(L, L1);\n  stack_init(L1, L);   \n  lua_unlock(L);\n  return L1;\n}\n\n\nvoid luaE_freethread (lua_State *L, lua_State *L1) {\n  LX *l = fromstate(L1);\n  luaF_close(L1, L1->stack);   \n  lua_assert(L1->openupval == NULL);\n  luai_userstatefree(L, L1);\n  freestack(L1);\n  luaM_free(L, l);\n}\n\n\nLUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {\n  int i;\n  lua_State *L;\n  global_State *g;\n  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));\n  if (l == NULL) return NULL;\n  L = &l->l.l;\n  g = &l->g;\n  L->next = NULL;\n  L->tt = LUA_TTHREAD;\n  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);\n  L->marked = luaC_white(g);\n  g->gckind = KGC_NORMAL;\n  preinit_state(L, g);\n  g->frealloc = f;\n  g->ud = ud;\n  g->mainthread = L;\n  g->seed = makeseed(L);\n  g->uvhead.u.l.prev = &g->uvhead;\n  g->uvhead.u.l.next = &g->uvhead;\n  g->gcrunning = 0;   \n  g->GCestimate = 0;\n  g->strt.size = 0;\n  g->strt.nuse = 0;\n  g->strt.hash = NULL;\n  setnilvalue(&g->l_registry);\n  luaZ_initbuffer(L, &g->buff);\n  g->panic = NULL;\n  g->version = NULL;\n  g->gcstate = GCSpause;\n  g->allgc = NULL;\n  g->finobj = NULL;\n  g->tobefnz = NULL;\n  g->sweepgc = g->sweepfin = NULL;\n  g->gray = g->grayagain = NULL;\n  g->weak = g->ephemeron = g->allweak = NULL;\n  g->totalbytes = sizeof(LG);\n  g->GCdebt = 0;\n  g->gcpause = LUAI_GCPAUSE;\n  g->gcmajorinc = LUAI_GCMAJOR;\n  g->gcstepmul = LUAI_GCMUL;\n  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;\n  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {\n     \n    close_state(L);\n    L = NULL;\n  }\n  return L;\n}\n\n\nLUA_API void lua_close (lua_State *L) {\n  L = G(L)->mainthread;   \n  lua_lock(L);\n  close_state(L);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}