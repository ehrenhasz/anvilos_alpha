{
  "module_name": "ltable.c",
  "hash_id": "092ebc8232e0c5999ceb3321ce536301e31aee7ef45732c2f19fc70df47a9686",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/ltable.c",
  "human_readable_source": " \n\n\n \n\n\n#define ltable_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n \n#if LUAI_BITSINT >= 32\n#define MAXBITS\t\t30\n#else\n#define MAXBITS\t\t(LUAI_BITSINT-2)\n#endif\n\n#define MAXASIZE\t(1 << MAXBITS)\n\n\n#define hashpow2(t,n)\t\t(gnode(t, lmod((n), sizenode(t))))\n\n#define hashstr(t,str)\t\thashpow2(t, (str)->tsv.hash)\n#define hashboolean(t,p)\thashpow2(t, p)\n\n\n \n#define hashmod(t,n)\t(gnode(t, ((n) % ((sizenode(t)-1)|1))))\n\n\n#define hashpointer(t,p)\thashmod(t, IntPoint(p))\n\n\n#define dummynode\t\t(&dummynode_)\n\n#define isdummy(n)\t\t((n) == dummynode)\n\nstatic const Node dummynode_ = {\n  {NILCONSTANT},   \n  {{NILCONSTANT, NULL}}   \n};\n\n\n \nstatic Node *hashnum (const Table *t, lua_Number n) {\n  int i;\n  luai_hashnum(i, n);\n  if (i < 0) {\n    if (cast(unsigned int, i) == 0u - i)   \n      i = 0;   \n    i = -i;   \n  }\n  return hashmod(t, i);\n}\n\n\n\n \nstatic Node *mainposition (const Table *t, const TValue *key) {\n  switch (ttype(key)) {\n    case LUA_TNUMBER:\n      return hashnum(t, nvalue(key));\n    case LUA_TLNGSTR: {\n      TString *s = rawtsvalue(key);\n      if (s->tsv.extra == 0) {   \n        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);\n        s->tsv.extra = 1;   \n      }\n      return hashstr(t, rawtsvalue(key));\n    }\n    case LUA_TSHRSTR:\n      return hashstr(t, rawtsvalue(key));\n    case LUA_TBOOLEAN:\n      return hashboolean(t, bvalue(key));\n    case LUA_TLIGHTUSERDATA:\n      return hashpointer(t, pvalue(key));\n    case LUA_TLCF:\n      return hashpointer(t, fvalue(key));\n    default:\n      return hashpointer(t, gcvalue(key));\n  }\n}\n\n\n \nstatic int arrayindex (const TValue *key) {\n  if (ttisnumber(key)) {\n    lua_Number n = nvalue(key);\n    int k;\n    lua_number2int(k, n);\n    if (luai_numeq(cast_num(k), n))\n      return k;\n  }\n  return -1;   \n}\n\n\n \nstatic int findindex (lua_State *L, Table *t, StkId key) {\n  int i;\n  if (ttisnil(key)) return -1;   \n  i = arrayindex(key);\n  if (0 < i && i <= t->sizearray)   \n    return i-1;   \n  else {\n    Node *n = mainposition(t, key);\n    for (;;) {   \n       \n      if (luaV_rawequalobj(gkey(n), key) ||\n            (ttisdeadkey(gkey(n)) && iscollectable(key) &&\n             deadvalue(gkey(n)) == gcvalue(key))) {\n        i = cast_int(n - gnode(t, 0));   \n         \n        return i + t->sizearray;\n      }\n      else n = gnext(n);\n      if (n == NULL)\n        luaG_runerror(L, \"invalid key to \" LUA_QL(\"next\"));   \n    }\n  }\n}\n\n\nint luaH_next (lua_State *L, Table *t, StkId key) {\n  int i = findindex(L, t, key);   \n  for (i++; i < t->sizearray; i++) {   \n    if (!ttisnil(&t->array[i])) {   \n      setnvalue(key, cast_num(i+1));\n      setobj2s(L, key+1, &t->array[i]);\n      return 1;\n    }\n  }\n  for (i -= t->sizearray; i < sizenode(t); i++) {   \n    if (!ttisnil(gval(gnode(t, i)))) {   \n      setobj2s(L, key, gkey(gnode(t, i)));\n      setobj2s(L, key+1, gval(gnode(t, i)));\n      return 1;\n    }\n  }\n  return 0;   \n}\n\n\n \n\n\nstatic int computesizes (int nums[], int *narray) {\n  int i;\n  int twotoi;   \n  int a = 0;   \n  int na = 0;   \n  int n = 0;   \n  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {\n    if (nums[i] > 0) {\n      a += nums[i];\n      if (a > twotoi/2) {   \n        n = twotoi;   \n        na = a;   \n      }\n    }\n    if (a == *narray) break;   \n  }\n  *narray = n;\n  lua_assert(*narray/2 <= na && na <= *narray);\n  return na;\n}\n\n\nstatic int countint (const TValue *key, int *nums) {\n  int k = arrayindex(key);\n  if (0 < k && k <= MAXASIZE) {   \n    nums[luaO_ceillog2(k)]++;   \n    return 1;\n  }\n  else\n    return 0;\n}\n\n\nstatic int numusearray (const Table *t, int *nums) {\n  int lg;\n  int ttlg;   \n  int ause = 0;   \n  int i = 1;   \n  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {   \n    int lc = 0;   \n    int lim = ttlg;\n    if (lim > t->sizearray) {\n      lim = t->sizearray;   \n      if (i > lim)\n        break;   \n    }\n     \n    for (; i <= lim; i++) {\n      if (!ttisnil(&t->array[i-1]))\n        lc++;\n    }\n    nums[lg] += lc;\n    ause += lc;\n  }\n  return ause;\n}\n\n\nstatic int numusehash (const Table *t, int *nums, int *pnasize) {\n  int totaluse = 0;   \n  int ause = 0;   \n  int i = sizenode(t);\n  while (i--) {\n    Node *n = &t->node[i];\n    if (!ttisnil(gval(n))) {\n      ause += countint(gkey(n), nums);\n      totaluse++;\n    }\n  }\n  *pnasize += ause;\n  return totaluse;\n}\n\n\nstatic void setarrayvector (lua_State *L, Table *t, int size) {\n  int i;\n  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);\n  for (i=t->sizearray; i<size; i++)\n     setnilvalue(&t->array[i]);\n  t->sizearray = size;\n}\n\n\nstatic void setnodevector (lua_State *L, Table *t, int size) {\n  int lsize;\n  if (size == 0) {   \n    t->node = cast(Node *, dummynode);   \n    lsize = 0;\n  }\n  else {\n    int i;\n    lsize = luaO_ceillog2(size);\n    if (lsize > MAXBITS)\n      luaG_runerror(L, \"table overflow\");\n    size = twoto(lsize);\n    t->node = luaM_newvector(L, size, Node);\n    for (i=0; i<size; i++) {\n      Node *n = gnode(t, i);\n      gnext(n) = NULL;\n      setnilvalue(gkey(n));\n      setnilvalue(gval(n));\n    }\n  }\n  t->lsizenode = cast_byte(lsize);\n  t->lastfree = gnode(t, size);   \n}\n\n\nvoid luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {\n  int i;\n  int oldasize = t->sizearray;\n  int oldhsize = t->lsizenode;\n  Node *nold = t->node;   \n  if (nasize > oldasize)   \n    setarrayvector(L, t, nasize);\n   \n  setnodevector(L, t, nhsize);\n  if (nasize < oldasize) {   \n    t->sizearray = nasize;\n     \n    for (i=nasize; i<oldasize; i++) {\n      if (!ttisnil(&t->array[i]))\n        luaH_setint(L, t, i + 1, &t->array[i]);\n    }\n     \n    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);\n  }\n   \n  for (i = twoto(oldhsize) - 1; i >= 0; i--) {\n    Node *old = nold+i;\n    if (!ttisnil(gval(old))) {\n       \n      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));\n    }\n  }\n  if (!isdummy(nold))\n    luaM_freearray(L, nold, cast(size_t, twoto(oldhsize)));  \n}\n\n\nvoid luaH_resizearray (lua_State *L, Table *t, int nasize) {\n  int nsize = isdummy(t->node) ? 0 : sizenode(t);\n  luaH_resize(L, t, nasize, nsize);\n}\n\n\nstatic void rehash (lua_State *L, Table *t, const TValue *ek) {\n  int nasize, na;\n  int nums[MAXBITS+1];   \n  int i;\n  int totaluse;\n  for (i=0; i<=MAXBITS; i++) nums[i] = 0;   \n  nasize = numusearray(t, nums);   \n  totaluse = nasize;   \n  totaluse += numusehash(t, nums, &nasize);   \n   \n  nasize += countint(ek, nums);\n  totaluse++;\n   \n  na = computesizes(nums, &nasize);\n   \n  luaH_resize(L, t, nasize, totaluse - na);\n}\n\n\n\n \n\n\nTable *luaH_new (lua_State *L) {\n  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;\n  t->metatable = NULL;\n  t->flags = cast_byte(~0);\n  t->array = NULL;\n  t->sizearray = 0;\n  setnodevector(L, t, 0);\n  return t;\n}\n\n\nvoid luaH_free (lua_State *L, Table *t) {\n  if (!isdummy(t->node))\n    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));\n  luaM_freearray(L, t->array, t->sizearray);\n  luaM_free(L, t);\n}\n\n\nstatic Node *getfreepos (Table *t) {\n  while (t->lastfree > t->node) {\n    t->lastfree--;\n    if (ttisnil(gkey(t->lastfree)))\n      return t->lastfree;\n  }\n  return NULL;   \n}\n\n\n\n \nTValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {\n  Node *mp;\n  if (ttisnil(key)) luaG_runerror(L, \"table index is nil\");\n#if defined LUA_HAS_FLOAT_NUMBERS\n  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))\n    luaG_runerror(L, \"table index is NaN\");\n#endif\n  mp = mainposition(t, key);\n  if (!ttisnil(gval(mp)) || isdummy(mp)) {   \n    Node *othern;\n    Node *n = getfreepos(t);   \n    if (n == NULL) {   \n      rehash(L, t, key);   \n       \n      return luaH_set(L, t, key);   \n    }\n    lua_assert(!isdummy(n));\n    othern = mainposition(t, gkey(mp));\n    if (othern != mp) {   \n       \n      while (gnext(othern) != mp) othern = gnext(othern);   \n      gnext(othern) = n;   \n      *n = *mp;   \n      gnext(mp) = NULL;   \n      setnilvalue(gval(mp));\n    }\n    else {   \n       \n      gnext(n) = gnext(mp);   \n      gnext(mp) = n;\n      mp = n;\n    }\n  }\n  setobj2t(L, gkey(mp), key);\n  luaC_barrierback(L, obj2gco(t), key);\n  lua_assert(ttisnil(gval(mp)));\n  return gval(mp);\n}\n\n\n \nconst TValue *luaH_getint (Table *t, int key) {\n   \n  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))\n    return &t->array[key-1];\n  else {\n    lua_Number nk = cast_num(key);\n    Node *n = hashnum(t, nk);\n    do {   \n      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))\n        return gval(n);   \n      else n = gnext(n);\n    } while (n);\n    return luaO_nilobject;\n  }\n}\n\n\n \nconst TValue *luaH_getstr (Table *t, TString *key) {\n  Node *n = hashstr(t, key);\n  lua_assert(key->tsv.tt == LUA_TSHRSTR);\n  do {   \n    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))\n      return gval(n);   \n    else n = gnext(n);\n  } while (n);\n  return luaO_nilobject;\n}\n\n\n \nconst TValue *luaH_get (Table *t, const TValue *key) {\n  switch (ttype(key)) {\n    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));\n    case LUA_TNIL: return luaO_nilobject;\n    case LUA_TNUMBER: {\n      int k;\n      lua_Number n = nvalue(key);\n      lua_number2int(k, n);\n      if (luai_numeq(cast_num(k), n))  \n        return luaH_getint(t, k);   \n       \n    }\n      zfs_fallthrough;\n    default: {\n      Node *n = mainposition(t, key);\n      do {   \n        if (luaV_rawequalobj(gkey(n), key))\n          return gval(n);   \n        else n = gnext(n);\n      } while (n);\n      return luaO_nilobject;\n    }\n  }\n}\n\n\n \nTValue *luaH_set (lua_State *L, Table *t, const TValue *key) {\n  const TValue *p = luaH_get(t, key);\n  if (p != luaO_nilobject)\n    return cast(TValue *, p);\n  else return luaH_newkey(L, t, key);\n}\n\n\nvoid luaH_setint (lua_State *L, Table *t, int key, TValue *value) {\n  const TValue *p = luaH_getint(t, key);\n  TValue *cell;\n  if (p != luaO_nilobject)\n    cell = cast(TValue *, p);\n  else {\n    TValue k;\n    setnvalue(&k, cast_num(key));\n    cell = luaH_newkey(L, t, &k);\n  }\n  setobj2t(L, cell, value);\n}\n\n\nstatic int unbound_search (Table *t, unsigned int j) {\n  unsigned int i = j;   \n  j++;\n   \n  while (!ttisnil(luaH_getint(t, j))) {\n    i = j;\n    j *= 2;\n    if (j > cast(unsigned int, MAX_INT)) {   \n       \n      i = 1;\n      while (!ttisnil(luaH_getint(t, i))) i++;\n      return i - 1;\n    }\n  }\n   \n  while (j - i > 1) {\n    unsigned int m = (i+j)/2;\n    if (ttisnil(luaH_getint(t, m))) j = m;\n    else i = m;\n  }\n  return i;\n}\n\n\n \nint luaH_getn (Table *t) {\n  unsigned int j = t->sizearray;\n  if (j > 0 && ttisnil(&t->array[j - 1])) {\n     \n    unsigned int i = 0;\n    while (j - i > 1) {\n      unsigned int m = (i+j)/2;\n      if (ttisnil(&t->array[m - 1])) j = m;\n      else i = m;\n    }\n    return i;\n  }\n   \n  else if (isdummy(t->node))   \n    return j;   \n  else return unbound_search(t, j);\n}\n\n\n\n#if defined(LUA_DEBUG)\n\nNode *luaH_mainposition (const Table *t, const TValue *key) {\n  return mainposition(t, key);\n}\n\nint luaH_isdummy (Node *n) { return isdummy(n); }\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}