{
  "module_name": "lbaselib.c",
  "hash_id": "718be291148f64b0b78cafe1ae32e4f79798b3711e6e3b3e4800eea9613cf68d",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lbaselib.c",
  "human_readable_source": " \n\n \n\n\n#define lbaselib_c\n#define LUA_LIB\n\n#include <sys/lua/lua.h>\n\n#include <sys/lua/lauxlib.h>\n#include <sys/lua/lualib.h>\n\n#define SPACECHARS\t\" \\f\\n\\r\\t\\v\"\n\nstatic int luaB_tonumber (lua_State *L) {\n  if (lua_isnoneornil(L, 2)) {   \n    int isnum;\n    lua_Number n = lua_tonumberx(L, 1, &isnum);\n    if (isnum) {\n      lua_pushnumber(L, n);\n      return 1;\n    }   \n    luaL_checkany(L, 1);\n  }\n  else {\n    size_t l;\n    const char *s = luaL_checklstring(L, 1, &l);\n    const char *e = s + l;   \n    int base = luaL_checkint(L, 2);\n    int neg = 0;\n    luaL_argcheck(L, 2 <= base && base <= 36, 2, \"base out of range\");\n    s += strspn(s, SPACECHARS);   \n    if (*s == '-') { s++; neg = 1; }   \n    else if (*s == '+') s++;\n    if (isalnum((unsigned char)*s)) {\n      lua_Number n = 0;\n      do {\n        int digit = (isdigit((unsigned char)*s)) ? *s - '0'\n                       : toupper((unsigned char)*s) - 'A' + 10;\n        if (digit >= base) break;   \n        n = n * (lua_Number)base + (lua_Number)digit;\n        s++;\n      } while (isalnum((unsigned char)*s));\n      s += strspn(s, SPACECHARS);   \n      if (s == e) {   \n        lua_pushnumber(L, (neg) ? -n : n);\n        return 1;\n      }   \n    }   \n  }\n  lua_pushnil(L);   \n  return 1;\n}\n\n\nstatic int luaB_error (lua_State *L) {\n  int level = luaL_optint(L, 2, 1);\n  lua_settop(L, 1);\n  if (lua_isstring(L, 1) && level > 0) {   \n    luaL_where(L, level);\n    lua_pushvalue(L, 1);\n    lua_concat(L, 2);\n  }\n  return lua_error(L);\n}\n\n\nstatic int luaB_getmetatable (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (!lua_getmetatable(L, 1)) {\n    lua_pushnil(L);\n    return 1;   \n  }\n  luaL_getmetafield(L, 1, \"__metatable\");\n  return 1;   \n}\n\n\nstatic int luaB_setmetatable (lua_State *L) {\n  int t = lua_type(L, 2);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,\n                    \"nil or table expected\");\n  if (luaL_getmetafield(L, 1, \"__metatable\"))\n    return luaL_error(L, \"cannot change a protected metatable\");\n  lua_settop(L, 2);\n  lua_setmetatable(L, 1);\n  return 1;\n}\n\n\nstatic int luaB_rawequal (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_checkany(L, 2);\n  lua_pushboolean(L, lua_rawequal(L, 1, 2));\n  return 1;\n}\n\n\nstatic int luaB_rawlen (lua_State *L) {\n  int t = lua_type(L, 1);\n  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,\n                   \"table or string expected\");\n  lua_pushinteger(L, lua_rawlen(L, 1));\n  return 1;\n}\n\n\nstatic int luaB_rawget (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  lua_settop(L, 2);\n  lua_rawget(L, 1);\n  return 1;\n}\n\nstatic int luaB_rawset (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  luaL_checkany(L, 3);\n  lua_settop(L, 3);\n  lua_rawset(L, 1);\n  return 1;\n}\n\n\nstatic int luaB_collectgarbage (lua_State *L) {\n  static const char *const opts[] = {\"stop\", \"restart\", \"collect\",\n    \"count\", \"step\", \"setpause\", \"setstepmul\",\n    \"setmajorinc\", \"isrunning\", \"generational\", \"incremental\", NULL};\n  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,\n    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,\n    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};\n  int o = optsnum[luaL_checkoption(L, 1, \"collect\", opts)];\n  int ex = luaL_optint(L, 2, 0);\n  int res = lua_gc(L, o, ex);\n  switch (o) {\n    case LUA_GCCOUNT: {\n      int b = lua_gc(L, LUA_GCCOUNTB, 0);\n      lua_pushnumber(L, res + ((lua_Number)b/1024));\n      lua_pushinteger(L, b);\n      return 2;\n    }\n    case LUA_GCSTEP: case LUA_GCISRUNNING: {\n      lua_pushboolean(L, res);\n      return 1;\n    }\n    default: {\n      lua_pushinteger(L, res);\n      return 1;\n    }\n  }\n}\n\n\nstatic int luaB_type (lua_State *L) {\n  luaL_checkany(L, 1);\n  lua_pushstring(L, luaL_typename(L, 1));\n  return 1;\n}\n\n\nstatic int pairsmeta (lua_State *L, const char *method, int iszero,\n                      lua_CFunction iter) {\n  if (!luaL_getmetafield(L, 1, method)) {   \n    luaL_checktype(L, 1, LUA_TTABLE);   \n    lua_pushcfunction(L, iter);   \n    lua_pushvalue(L, 1);   \n    if (iszero) lua_pushinteger(L, 0);   \n    else lua_pushnil(L);\n  }\n  else {\n    lua_pushvalue(L, 1);   \n    lua_call(L, 1, 3);   \n  }\n  return 3;\n}\n\n\nstatic int luaB_next (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  lua_settop(L, 2);   \n  if (lua_next(L, 1))\n    return 2;\n  else {\n    lua_pushnil(L);\n    return 1;\n  }\n}\n\n\nstatic int luaB_pairs (lua_State *L) {\n  return pairsmeta(L, \"__pairs\", 0, luaB_next);\n}\n\n\nstatic int ipairsaux (lua_State *L) {\n  int i = luaL_checkint(L, 2);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  i++;   \n  lua_pushinteger(L, i);\n  lua_rawgeti(L, 1, i);\n  return (lua_isnil(L, -1)) ? 1 : 2;\n}\n\n\nstatic int luaB_ipairs (lua_State *L) {\n  return pairsmeta(L, \"__ipairs\", 1, ipairsaux);\n}\n\n\nstatic int luaB_assert (lua_State *L) {\n  if (!lua_toboolean(L, 1))\n    return luaL_error(L, \"%s\", luaL_optstring(L, 2, \"assertion failed!\"));\n  return lua_gettop(L);\n}\n\n\nstatic int luaB_select (lua_State *L) {\n  int n = lua_gettop(L);\n  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {\n    lua_pushinteger(L, n-1);\n    return 1;\n  }\n  else {\n    int i = luaL_checkint(L, 1);\n    if (i < 0) i = n + i;\n    else if (i > n) i = n;\n    luaL_argcheck(L, 1 <= i, 1, \"index out of range\");\n    return n - i;\n  }\n}\n\nstatic int luaB_tostring (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_tolstring(L, 1, NULL);\n  return 1;\n}\n\nstatic const luaL_Reg base_funcs[] = {\n  {\"assert\", luaB_assert},\n  {\"collectgarbage\", luaB_collectgarbage},\n  {\"error\", luaB_error},\n  {\"getmetatable\", luaB_getmetatable},\n  {\"ipairs\", luaB_ipairs},\n#if defined(LUA_COMPAT_LOADSTRING)\n  {\"loadstring\", luaB_load},\n#endif\n  {\"next\", luaB_next},\n  {\"pairs\", luaB_pairs},\n  {\"rawequal\", luaB_rawequal},\n  {\"rawlen\", luaB_rawlen},\n  {\"rawget\", luaB_rawget},\n  {\"rawset\", luaB_rawset},\n  {\"select\", luaB_select},\n  {\"setmetatable\", luaB_setmetatable},\n  {\"tonumber\", luaB_tonumber},\n  {\"tostring\", luaB_tostring},\n  {\"type\", luaB_type},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_base (lua_State *L) {\n   \n  lua_pushglobaltable(L);\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"_G\");\n   \n  luaL_setfuncs(L, base_funcs, 0);\n  lua_pushliteral(L, LUA_VERSION);\n  lua_setfield(L, -2, \"_VERSION\");   \n  return 1;\n}\n\n#if defined(_KERNEL)\n\nEXPORT_SYMBOL(luaopen_base);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}