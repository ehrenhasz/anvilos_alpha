{
  "module_name": "lstate.h",
  "hash_id": "89d8236e937759a69e1fdf6ee3ff0d7db4a52c3a57b2b92abc6dd00ca3b4f7ff",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lstate.h",
  "human_readable_source": " \n\n#ifndef lstate_h\n#define lstate_h\n\n#include <sys/lua/lua.h>\n\n#include \"lobject.h\"\n#include \"ltm.h\"\n#include \"lzio.h\"\n\n\n \n\n\nstruct lua_longjmp;   \n\n\n\n \n#define EXTRA_STACK   5\n\n\n#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)\n\n\n \n#define KGC_NORMAL\t0\n#define KGC_EMERGENCY\t1\t \n#define KGC_GEN\t\t2\t \n\n\ntypedef struct stringtable {\n  GCObject **hash;\n  lu_int32 nuse;   \n  int size;\n} stringtable;\n\n\n \ntypedef struct CallInfo {\n  StkId func;   \n  StkId\ttop;   \n  struct CallInfo *previous, *next;   \n  short nresults;   \n  lu_byte callstatus;\n  ptrdiff_t extra;\n  union {\n    struct {   \n      StkId base;   \n      const Instruction *savedpc;\n    } l;\n    struct {   \n      int ctx;   \n      lua_CFunction k;   \n      ptrdiff_t old_errfunc;\n      lu_byte old_allowhook;\n      lu_byte status;\n    } c;\n  } u;\n} CallInfo;\n\n\n \n#define CIST_LUA\t(1<<0)\t \n#define CIST_HOOKED\t(1<<1)\t \n#define CIST_REENTRY\t(1<<2)\t \n#define CIST_YIELDED\t(1<<3)\t \n#define CIST_YPCALL\t(1<<4)\t \n#define CIST_STAT\t(1<<5)\t \n#define CIST_TAIL\t(1<<6)\t \n#define CIST_HOOKYIELD\t(1<<7)\t \n\n\n#define isLua(ci)\t((ci)->callstatus & CIST_LUA)\n\n\n \ntypedef struct global_State {\n  lua_Alloc frealloc;   \n  void *ud;          \n  lu_mem totalbytes;   \n  l_mem GCdebt;   \n  lu_mem GCmemtrav;   \n  lu_mem GCestimate;   \n  stringtable strt;   \n  TValue l_registry;\n  unsigned int seed;   \n  lu_byte currentwhite;\n  lu_byte gcstate;   \n  lu_byte gckind;   \n  lu_byte gcrunning;   \n  int sweepstrgc;   \n  GCObject *allgc;   \n  GCObject *finobj;   \n  GCObject **sweepgc;   \n  GCObject **sweepfin;   \n  GCObject *gray;   \n  GCObject *grayagain;   \n  GCObject *weak;   \n  GCObject *ephemeron;   \n  GCObject *allweak;   \n  GCObject *tobefnz;   \n  UpVal uvhead;   \n  Mbuffer buff;   \n  int gcpause;   \n  int gcmajorinc;   \n  int gcstepmul;   \n  lua_CFunction panic;   \n  struct lua_State *mainthread;\n  const lua_Number *version;   \n  TString *memerrmsg;   \n  TString *tmname[TM_N];   \n  struct Table *mt[LUA_NUMTAGS];   \n} global_State;\n\n\n \nstruct lua_State {\n  CommonHeader;\n  lu_byte status;\n  StkId top;   \n  global_State *l_G;\n  CallInfo *ci;   \n  const Instruction *oldpc;   \n  StkId stack_last;   \n  StkId stack;   \n  int stacksize;\n  unsigned short nny;   \n  unsigned short nCcalls;   \n  lu_byte hookmask;\n  lu_byte allowhook;\n  lu_byte runerror;  \n  int basehookcount;\n  int hookcount;\n  lua_Hook hook;\n  GCObject *openupval;   \n  GCObject *gclist;\n  struct lua_longjmp *errorJmp;   \n  ptrdiff_t errfunc;   \n  CallInfo base_ci;   \n};\n\n\n#define G(L)\t(L->l_G)\n\n\n \nunion GCObject {\n  GCheader gch;   \n  union TString ts;\n  union Udata u;\n  union Closure cl;\n  struct Table h;\n  struct Proto p;\n  struct UpVal uv;\n  struct lua_State th;   \n};\n\n\n#define gch(o)\t\t(&(o)->gch)\n\n \n#define rawgco2ts(o)  \\\n\tcheck_exp(novariant((o)->gch.tt) == LUA_TSTRING, &((o)->ts))\n#define gco2ts(o)\t(&rawgco2ts(o)->tsv)\n#define rawgco2u(o)\tcheck_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))\n#define gco2u(o)\t(&rawgco2u(o)->uv)\n#define gco2lcl(o)\tcheck_exp((o)->gch.tt == LUA_TLCL, &((o)->cl.l))\n#define gco2ccl(o)\tcheck_exp((o)->gch.tt == LUA_TCCL, &((o)->cl.c))\n#define gco2cl(o)  \\\n\tcheck_exp(novariant((o)->gch.tt) == LUA_TFUNCTION, &((o)->cl))\n#define gco2t(o)\tcheck_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))\n#define gco2p(o)\tcheck_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))\n#define gco2uv(o)\tcheck_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))\n#define gco2th(o)\tcheck_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))\n\n \n#define obj2gco(v)\t(cast(GCObject *, (v)))\n\n\n \n#define gettotalbytes(g)\t((g)->totalbytes + (g)->GCdebt)\n\nLUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);\nLUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);\nLUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);\nLUAI_FUNC void luaE_freeCI (lua_State *L);\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}