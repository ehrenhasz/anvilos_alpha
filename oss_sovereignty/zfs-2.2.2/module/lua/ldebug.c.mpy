{
  "module_name": "ldebug.c",
  "hash_id": "af7d27a719bd9981dad47c4e71601577375fc4436c920d66b0ce8c28d5241a6d",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/ldebug.c",
  "human_readable_source": " \n\n\n#define ldebug_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_TCCL)\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\nstatic int currentline (CallInfo *ci) {\n  return getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\nstatic void swapextra (lua_State *L) {\n  if (L->status == LUA_YIELD) {\n    CallInfo *ci = L->ci;   \n    StkId temp = ci->func;   \n    ci->func = restorestack(L, ci->extra);\n    ci->extra = savestack(L, temp);\n  }\n}\n\n\n \nLUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {   \n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  return 1;\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;   \n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {   \n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;   \n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  int nparams = clLvalue(ci->func)->p->numparams;\n  if (n >= ci->u.l.base - ci->func - nparams)\n    return NULL;   \n  else {\n    *pos = ci->func + nparams + n;\n    return \"(*vararg)\";   \n  }\n}\n\n\nstatic const char *findlocal (lua_State *L, CallInfo *ci, int n,\n                              StkId *pos) {\n  const char *name = NULL;\n  StkId base;\n  if (isLua(ci)) {\n    if (n < 0)   \n      return findvararg(ci, -n, pos);\n    else {\n      base = ci->u.l.base;\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n    }\n  }\n  else\n    base = ci->func + 1;\n  if (name == NULL) {   \n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0)   \n      name = \"(*temporary)\";   \n    else\n      return NULL;   \n  }\n  *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  swapextra(L);\n  if (ar == NULL) {   \n    if (!isLfunction(L->top - 1))   \n      name = NULL;\n    else   \n      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);\n  }\n  else {   \n    StkId pos = 0;   \n    name = findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobj2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  swapextra(L);\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = 0;   \n  const char *name;\n  lua_lock(L);\n  swapextra(L);\n  name = findlocal(L, ar->i_ci, n, &pos);\n  if (name)\n    setobjs2s(L, pos, L->top - 1);\n  L->top--;   \n  swapextra(L);\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    Proto *p = cl->l.p;\n    ar->source = p->source ? getstr(p->source) : \"=?\";\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(L->top);\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    int *lineinfo = f->l.p->lineinfo;\n    Table *t = luaH_new(L);   \n    sethvalue(L, L->top, t);   \n    api_incr_top(L);\n    setbvalue(&v, 1);   \n    for (i = 0; i < f->l.p->sizelineinfo; i++)   \n      luaH_setint(L, t, lineinfo[i], &v);   \n  }\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->is_vararg;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n         \n        if (ci && !(ci->callstatus & CIST_TAIL) && isLua(ci->previous))\n          ar->namewhat = getfuncname(L, ci->previous, &ar->name);\n        else\n          ar->namewhat = NULL;\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";   \n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':   \n        break;\n      default: status = 0;   \n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  StkId func;\n  lua_lock(L);\n  swapextra(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = L->top - 1;\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;   \n    L->top--;   \n  }\n  else {\n    ci = ar->i_ci;\n    func = ci->func;\n    lua_assert(ttisfunction(ci->func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobjs2s(L, L->top, func);\n    api_incr_top(L);\n  }\n  swapextra(L);\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n \n\nstatic const char *getobjname (Proto *p, int lastpc, int reg,\n                               const char **name);\n\n\n \nstatic void kname (Proto *p, int pc, int c, const char **name) {\n  if (ISK(c)) {   \n    TValue *kvalue = &p->k[INDEXK(c)];\n    if (ttisstring(kvalue)) {   \n      *name = svalue(kvalue);   \n      return;\n    }\n     \n  }\n  else {   \n    const char *what = getobjname(p, pc, c, name);  \n    if (what && *what == 'c') {   \n      return;   \n    }\n     \n  }\n  *name = \"?\";   \n}\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)   \n    return -1;   \n  else return pc;   \n}\n\n\n \nstatic int findsetreg (Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;   \n  int jmptarget = 0;   \n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    switch (op) {\n      case OP_LOADNIL: {\n        int b = GETARG_B(i);\n        if (a <= reg && reg <= a + b)   \n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      case OP_TFORCALL: {\n        if (reg >= a + 2)   \n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {\n        if (reg >= a)   \n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      case OP_JMP: {\n        int b = GETARG_sBx(i);\n        int dest = pc + 1 + b;\n         \n        if (pc < dest && dest <= lastpc) {\n          if (dest > jmptarget)\n            jmptarget = dest;   \n        }\n        break;\n      }\n      case OP_TEST: {\n        if (reg == a)   \n          setreg = filterpc(pc, jmptarget);\n        break;\n      }\n      default:\n        if (testAMode(op) && reg == a)   \n          setreg = filterpc(pc, jmptarget);\n        break;\n    }\n  }\n  return setreg;\n}\n\n\nstatic const char *getobjname (Proto *p, int lastpc, int reg,\n                               const char **name) {\n  int pc;\n  *name = luaF_getlocalname(p, reg + 1, lastpc);\n  if (*name)   \n    return \"local\";\n   \n  pc = findsetreg(p, lastpc, reg);\n  if (pc != -1) {   \n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);   \n        if (b < GETARG_A(i))\n          return getobjname(p, pc, b, name);   \n        break;\n      }\n      case OP_GETTABUP:\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);   \n        int t = GETARG_B(i);   \n        const char *vn = (op == OP_GETTABLE)   \n                         ? luaF_getlocalname(p, t + 1, pc)\n                         : upvalname(p, t);\n        kname(p, pc, k, name);\n        return (vn && strcmp(vn, LUA_ENV) == 0) ? \"global\" : \"field\";\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK:\n      case OP_LOADKX: {\n        int b = (op == OP_LOADK) ? GETARG_Bx(i)\n                                 : GETARG_Ax(p->code[pc + 1]);\n        if (ttisstring(&p->k[b])) {\n          *name = svalue(&p->k[b]);\n          return \"constant\";\n        }\n        break;\n      }\n      case OP_SELF: {\n        int k = GETARG_C(i);   \n        kname(p, pc, k, name);\n        return \"method\";\n      }\n      default: break;   \n    }\n  }\n  return NULL;   \n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  TMS tm;\n  Proto *p = ci_func(ci)->p;   \n  int pc = currentpc(ci);   \n  Instruction i = p->code[pc];   \n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:   \n      return getobjname(p, pc, GETARG_A(i), name);\n    case OP_TFORCALL: {   \n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n     \n    case OP_SELF:\n    case OP_GETTABUP:\n    case OP_GETTABLE: tm = TM_INDEX; break;\n    case OP_SETTABUP:\n    case OP_SETTABLE: tm = TM_NEWINDEX; break;\n    case OP_EQ: tm = TM_EQ; break;\n    case OP_ADD: tm = TM_ADD; break;\n    case OP_SUB: tm = TM_SUB; break;\n    case OP_MUL: tm = TM_MUL; break;\n    case OP_DIV: tm = TM_DIV; break;\n    case OP_MOD: tm = TM_MOD; break;\n    case OP_POW: tm = TM_POW; break;\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_LT: tm = TM_LT; break;\n    case OP_LE: tm = TM_LE; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    default:\n      return NULL;   \n  }\n  *name = getstr(G(L)->tmname[tm]);\n  return \"metamethod\";\n}\n\n \n\n\n\n \nstatic int isinstack (CallInfo *ci, const TValue *o) {\n  StkId p;\n  for (p = ci->u.l.base; p < ci->top; p++)\n    if (o == p) return 1;\n  return 0;\n}\n\n\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;\n  const char *t = objtypename(o);\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);   \n    if (!kind && isinstack(ci, o))   \n      kind = getobjname(ci_func(ci)->p, currentpc(ci),\n                        cast_int(o - ci->u.l.base), &name);\n  }\n  if (kind)\n    luaG_runerror(L, \"attempt to %s %s \" LUA_QS \" (a %s value)\",\n                op, kind, name, t);\n  else\n    luaG_runerror(L, \"attempt to %s a %s value\", op, t);\n}\n\n\nl_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {\n  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;\n  lua_assert(!ttisstring(p1) && !ttisnumber(p1));\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {\n  TValue temp;\n  if (luaV_tonumber(p1, &temp) == NULL)\n    p2 = p1;   \n  luaG_typeerror(L, p2, \"perform arithmetic on\");\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = objtypename(p1);\n  const char *t2 = objtypename(p2);\n  if (t1 == t2)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\nstatic void addinfo (lua_State *L, const char *msg) {\n  CallInfo *ci = L->ci;\n  if (isLua(ci)) {   \n    char buff[LUA_IDSIZE];   \n    int line = currentline(ci);\n    TString *src = ci_func(ci)->p->source;\n    if (src)\n      luaO_chunkid(buff, getstr(src), LUA_IDSIZE);\n    else {   \n      buff[0] = '?'; buff[1] = '\\0';\n    }\n    luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n  }\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {   \n    StkId errfunc = restorestack(L, L->errfunc);\n    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);\n    setobjs2s(L, L->top, L->top - 1);   \n    setobjs2s(L, L->top - 1, errfunc);   \n    L->top++;\n    luaD_call(L, L->top - 2, 1, 0);   \n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  L->runerror++;\n  va_list argp;\n  va_start(argp, fmt);\n  addinfo(L, luaO_pushvfstring(L, fmt, argp));\n  va_end(argp);\n  luaG_errormsg(L);\n  L->runerror--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}