{
  "module_name": "lobject.h",
  "hash_id": "1471277ba19587da2a31b992c08c7f63e6ad2e4609ae97894f691060c5df86da",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lobject.h",
  "human_readable_source": " \n\n\n#ifndef lobject_h\n#define lobject_h\n\n\n#include \"llimits.h\"\n#include <sys/lua/lua.h>\n\n\n \n#define LUA_TPROTO\tLUA_NUMTAGS\n#define LUA_TUPVAL\t(LUA_NUMTAGS+1)\n#define LUA_TDEADKEY\t(LUA_NUMTAGS+2)\n\n \n#define LUA_TOTALTAGS\t(LUA_TUPVAL+2)\n\n\n \n\n#define VARBITS\t\t(3 << 4)\n\n\n \n\n \n#define LUA_TLCL\t(LUA_TFUNCTION | (0 << 4))   \n#define LUA_TLCF\t(LUA_TFUNCTION | (1 << 4))   \n#define LUA_TCCL\t(LUA_TFUNCTION | (2 << 4))   \n\n\n \n#define LUA_TSHRSTR\t(LUA_TSTRING | (0 << 4))   \n#define LUA_TLNGSTR\t(LUA_TSTRING | (1 << 4))   \n\n\n \n#define BIT_ISCOLLECTABLE\t(1 << 6)\n\n \n#define ctb(t)\t\t\t((t) | BIT_ISCOLLECTABLE)\n\n\n \ntypedef union GCObject GCObject;\n\n\n \n#define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked\n\n\n \ntypedef struct GCheader {\n  CommonHeader;\n} GCheader;\n\n\n\n \ntypedef union Value Value;\n\n\n#define numfield\tlua_Number n;     \n\n\n\n \n\n#define TValuefields\tValue value_; int tt_\n\ntypedef struct lua_TValue TValue;\n\n\n \n#define NILCONSTANT\t{NULL}, LUA_TNIL\n\n\n#define val_(o)\t\t((o)->value_)\n#define num_(o)\t\t(val_(o).n)\n\n\n \n#define rttype(o)\t((o)->tt_)\n\n \n#define novariant(x)\t((x) & 0x0F)\n\n \n#define ttype(o)\t(rttype(o) & 0x3F)\n\n \n#define ttypenv(o)\t(novariant(rttype(o)))\n\n\n \n#define checktag(o,t)\t\t(rttype(o) == (t))\n#define checktype(o,t)\t\t(ttypenv(o) == (t))\n#define ttisnumber(o)\t\tchecktag((o), LUA_TNUMBER)\n#define ttisnil(o)\t\tchecktag((o), LUA_TNIL)\n#define ttisboolean(o)\t\tchecktag((o), LUA_TBOOLEAN)\n#define ttislightuserdata(o)\tchecktag((o), LUA_TLIGHTUSERDATA)\n#define ttisstring(o)\t\tchecktype((o), LUA_TSTRING)\n#define ttisshrstring(o)\tchecktag((o), ctb(LUA_TSHRSTR))\n#define ttislngstring(o)\tchecktag((o), ctb(LUA_TLNGSTR))\n#define ttistable(o)\t\tchecktag((o), ctb(LUA_TTABLE))\n#define ttisfunction(o)\t\tchecktype(o, LUA_TFUNCTION)\n#define ttisclosure(o)\t\t((rttype(o) & 0x1F) == LUA_TFUNCTION)\n#define ttisCclosure(o)\t\tchecktag((o), ctb(LUA_TCCL))\n#define ttisLclosure(o)\t\tchecktag((o), ctb(LUA_TLCL))\n#define ttislcf(o)\t\tchecktag((o), LUA_TLCF)\n#define ttisuserdata(o)\t\tchecktag((o), ctb(LUA_TUSERDATA))\n#define ttisthread(o)\t\tchecktag((o), ctb(LUA_TTHREAD))\n#define ttisdeadkey(o)\t\tchecktag((o), LUA_TDEADKEY)\n\n#define ttisequal(o1,o2)\t(rttype(o1) == rttype(o2))\n\n \n#define nvalue(o)\tcheck_exp(ttisnumber(o), num_(o))\n#define gcvalue(o)\tcheck_exp(iscollectable(o), val_(o).gc)\n#define pvalue(o)\tcheck_exp(ttislightuserdata(o), val_(o).p)\n#define rawtsvalue(o)\tcheck_exp(ttisstring(o), &val_(o).gc->ts)\n#define tsvalue(o)\t(&rawtsvalue(o)->tsv)\n#define rawuvalue(o)\tcheck_exp(ttisuserdata(o), &val_(o).gc->u)\n#define uvalue(o)\t(&rawuvalue(o)->uv)\n#define clvalue(o)\tcheck_exp(ttisclosure(o), &val_(o).gc->cl)\n#define clLvalue(o)\tcheck_exp(ttisLclosure(o), &val_(o).gc->cl.l)\n#define clCvalue(o)\tcheck_exp(ttisCclosure(o), &val_(o).gc->cl.c)\n#define fvalue(o)\tcheck_exp(ttislcf(o), val_(o).f)\n#define hvalue(o)\tcheck_exp(ttistable(o), &val_(o).gc->h)\n#define bvalue(o)\tcheck_exp(ttisboolean(o), val_(o).b)\n#define thvalue(o)\tcheck_exp(ttisthread(o), &val_(o).gc->th)\n \n#define deadvalue(o)\tcheck_exp(ttisdeadkey(o), cast(void *, val_(o).gc))\n\n#define l_isfalse(o)\t(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))\n\n\n#define iscollectable(o)\t(rttype(o) & BIT_ISCOLLECTABLE)\n\n\n \n#define righttt(obj)\t\t(ttype(obj) == gcvalue(obj)->gch.tt)\n\n#define checkliveness(g,obj) \\\n\tlua_longassert(!iscollectable(obj) || \\\n\t\t\t(righttt(obj) && !isdead(g,gcvalue(obj))))\n\n\n \n#define settt_(o,t)\t((o)->tt_=(t))\n\n#define setnvalue(obj,x) \\\n  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }\n\n#define setnilvalue(obj) settt_(obj, LUA_TNIL)\n\n#define setfvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_TLCF); }\n\n#define setpvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_TLIGHTUSERDATA); }\n\n#define setbvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }\n\n#define setgcovalue(L,obj,x) \\\n  { TValue *io=(obj); GCObject *i_g=(x); \\\n    val_(io).gc=i_g; settt_(io, ctb(gch(i_g)->tt)); }\n\n#define setsvalue(L,obj,x) \\\n  { TValue *io=(obj); \\\n    TString *x_ = (x); \\\n    val_(io).gc=cast(GCObject *, x_); settt_(io, ctb(x_->tsv.tt)); \\\n    checkliveness(G(L),io); }\n\n#define setuvalue(L,obj,x) \\\n  { TValue *io=(obj); \\\n    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TUSERDATA)); \\\n    checkliveness(G(L),io); }\n\n#define setthvalue(L,obj,x) \\\n  { TValue *io=(obj); \\\n    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTHREAD)); \\\n    checkliveness(G(L),io); }\n\n#define setclLvalue(L,obj,x) \\\n  { TValue *io=(obj); \\\n    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TLCL)); \\\n    checkliveness(G(L),io); }\n\n#define setclCvalue(L,obj,x) \\\n  { TValue *io=(obj); \\\n    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TCCL)); \\\n    checkliveness(G(L),io); }\n\n#define sethvalue(L,obj,x) \\\n  { TValue *io=(obj); \\\n    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTABLE)); \\\n    checkliveness(G(L),io); }\n\n#define setdeadvalue(obj)\tsettt_(obj, LUA_TDEADKEY)\n\n\n\n#define setobj(L,obj1,obj2) \\\n\t{ const TValue *io2=(obj2); TValue *io1=(obj1); \\\n\t  io1->value_ = io2->value_; io1->tt_ = io2->tt_; \\\n\t  checkliveness(G(L),io1); }\n\n\n \n\n \n#define setobjs2s\tsetobj\n \n#define setobj2s\tsetobj\n#define setsvalue2s\tsetsvalue\n#define sethvalue2s\tsethvalue\n#define setptvalue2s\tsetptvalue\n \n#define setobjt2t\tsetobj\n \n#define setobj2t\tsetobj\n \n#define setobj2n\tsetobj\n#define setsvalue2n\tsetsvalue\n\n\n \n#define luai_checknum(L,o,c)\t{   }\n\n\n \n#if defined(LUA_NANTRICK)\n\n \n\n \n#if !defined(NNMARK)\t \n\n\n#if !defined(LUA_IEEEENDIAN)\n#error option 'LUA_NANTRICK' needs 'LUA_IEEEENDIAN'\n#endif\n\n\n#define NNMARK\t\t0x7FF7A500\n#define NNMASK\t\t0x7FFFFF00\n\n#undef TValuefields\n#undef NILCONSTANT\n\n#if (LUA_IEEEENDIAN == 0)\t \n\n \n#define TValuefields  \\\n\tunion { struct { Value v__; int tt__; } i; double d__; } u\n#define NILCONSTANT\t{{{NULL}, tag2tt(LUA_TNIL)}}\n \n#define v_(o)\t\t((o)->u.i.v__)\n#define d_(o)\t\t((o)->u.d__)\n#define tt_(o)\t\t((o)->u.i.tt__)\n\n#else\t\t\t\t \n\n \n#define TValuefields  \\\n\tunion { struct { int tt__; Value v__; } i; double d__; } u\n#define NILCONSTANT\t{{tag2tt(LUA_TNIL), {NULL}}}\n \n#define v_(o)\t\t((o)->u.i.v__)\n#define d_(o)\t\t((o)->u.d__)\n#define tt_(o)\t\t((o)->u.i.tt__)\n\n#endif\t\t\t\t \n\n#endif\t\t\t \n\n\n \n#undef val_\n#define val_(o)\t\tv_(o)\n#undef num_\n#define num_(o)\t\td_(o)\n\n\n#undef numfield\n#define numfield\t \n\n \n#undef ttisnumber\n#define ttisnumber(o)\t((tt_(o) & NNMASK) != NNMARK)\n\n#define tag2tt(t)\t(NNMARK | (t))\n\n#undef rttype\n#define rttype(o)\t(ttisnumber(o) ? LUA_TNUMBER : tt_(o) & 0xff)\n\n#undef settt_\n#define settt_(o,t)\t(tt_(o) = tag2tt(t))\n\n#undef setnvalue\n#define setnvalue(obj,x) \\\n\t{ TValue *io_=(obj); num_(io_)=(x); lua_assert(ttisnumber(io_)); }\n\n#undef setobj\n#define setobj(L,obj1,obj2) \\\n\t{ const TValue *o2_=(obj2); TValue *o1_=(obj1); \\\n\t  o1_->u = o2_->u; \\\n\t  checkliveness(G(L),o1_); }\n\n\n \n\n#undef checktag\n#undef checktype\n#define checktag(o,t)\t(tt_(o) == tag2tt(t))\n#define checktype(o,t)\t(ctb(tt_(o) | VARBITS) == ctb(tag2tt(t) | VARBITS))\n\n#undef ttisequal\n#define ttisequal(o1,o2)  \\\n\t(ttisnumber(o1) ? ttisnumber(o2) : (tt_(o1) == tt_(o2)))\n\n\n#undef luai_checknum\n#define luai_checknum(L,o,c)\t{ if (!ttisnumber(o)) c; }\n\n#endif\n \n\n\n\n \n\n\nunion Value {\n  GCObject *gc;     \n  void *p;          \n  int b;            \n  lua_CFunction f;  \n  numfield          \n};\n\n\nstruct lua_TValue {\n  TValuefields;\n};\n\n\ntypedef TValue *StkId;   \n\n\n\n\n \ntypedef union TString {\n  L_Umaxalign dummy;   \n  struct {\n    CommonHeader;\n    lu_byte extra;   \n    unsigned int hash;\n    size_t len;   \n  } tsv;\n} TString;\n\n\n \n#define getstr(ts)\tcast(const char *, (ts) + 1)\n\n \n#define svalue(o)       getstr(rawtsvalue(o))\n\n\n \ntypedef union Udata {\n  L_Umaxalign dummy;   \n  struct {\n    CommonHeader;\n    struct Table *metatable;\n    struct Table *env;\n    size_t len;   \n  } uv;\n} Udata;\n\n\n\n \ntypedef struct Upvaldesc {\n  TString *name;   \n  lu_byte instack;   \n  lu_byte idx;   \n} Upvaldesc;\n\n\n \ntypedef struct LocVar {\n  TString *varname;\n  int startpc;   \n  int endpc;     \n} LocVar;\n\n\n \ntypedef struct Proto {\n  CommonHeader;\n  TValue *k;   \n  Instruction *code;\n  struct Proto **p;   \n  int *lineinfo;   \n  LocVar *locvars;   \n  Upvaldesc *upvalues;   \n  union Closure *cache;   \n  TString  *source;   \n  int sizeupvalues;   \n  int sizek;   \n  int sizecode;\n  int sizelineinfo;\n  int sizep;   \n  int sizelocvars;\n  int linedefined;\n  int lastlinedefined;\n  GCObject *gclist;\n  lu_byte numparams;   \n  lu_byte is_vararg;\n  lu_byte maxstacksize;   \n} Proto;\n\n\n\n \ntypedef struct UpVal {\n  CommonHeader;\n  TValue *v;   \n  union {\n    TValue value;   \n    struct {   \n      struct UpVal *prev;\n      struct UpVal *next;\n    } l;\n  } u;\n} UpVal;\n\n\n \n\n#define ClosureHeader \\\n\tCommonHeader; lu_byte nupvalues; GCObject *gclist\n\ntypedef struct CClosure {\n  ClosureHeader;\n  lua_CFunction f;\n  TValue upvalue[];   \n} CClosure;\n\n\ntypedef struct LClosure {\n  ClosureHeader;\n  struct Proto *p;\n  UpVal *upvals[];   \n} LClosure;\n\n\ntypedef union Closure {\n  CClosure c;\n  LClosure l;\n} Closure;\n\n\n#define isLfunction(o)\tttisLclosure(o)\n\n#define getproto(o)\t(clLvalue(o)->p)\n\n\n \n\ntypedef union TKey {\n  struct {\n    TValuefields;\n    struct Node *next;   \n  } nk;\n  TValue tvk;\n} TKey;\n\n\ntypedef struct Node {\n  TValue i_val;\n  TKey i_key;\n} Node;\n\n\ntypedef struct Table {\n  CommonHeader;\n  lu_byte flags;   \n  lu_byte lsizenode;   \n  int sizearray;   \n  TValue *array;   \n  Node *node;\n  Node *lastfree;   \n  struct Table *metatable;\n  GCObject *gclist;\n} Table;\n\n\n\n \n#define lmod(s,size) \\\n\t(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))\n\n\n#define twoto(x)\t(1<<(x))\n#define sizenode(t)\t(twoto((t)->lsizenode))\n\n\n \n#define luaO_nilobject\t\t(&luaO_nilobject_)\n\n\nLUAI_DDEC const TValue luaO_nilobject_;\n\n\nLUAI_FUNC int luaO_int2fb (unsigned int x);\nLUAI_FUNC int luaO_fb2int (int x);\nLUAI_FUNC int luaO_ceillog2 (unsigned int x);\nLUAI_FUNC lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2);\nLUAI_FUNC int luaO_str2d (const char *s, size_t len, lua_Number *result);\nLUAI_FUNC int luaO_hexavalue (int c);\nLUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,\n                                                       va_list argp);\nLUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);\nLUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}