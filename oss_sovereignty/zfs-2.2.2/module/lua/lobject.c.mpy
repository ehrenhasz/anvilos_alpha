{
  "module_name": "lobject.c",
  "hash_id": "c3e5dc71c9fed2ebe7813e2fad254c8028a6ad08bb10ca918078d5099f345985",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lobject.c",
  "human_readable_source": " \n\n#define lobject_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"lvm.h\"\n\n\n\nLUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};\n\n\n \nint luaO_int2fb (unsigned int x) {\n  int e = 0;   \n  if (x < 8) return x;\n  while (x >= 0x10) {\n    x = (x+1) >> 1;\n    e++;\n  }\n  return ((e+1) << 3) | (cast_int(x) - 8);\n}\n\n\n \nint luaO_fb2int (int x) {\n  int e = (x >> 3) & 0x1f;\n  if (e == 0) return x;\n  else return ((x & 7) + 8) << (e - 1);\n}\n\n\nint luaO_ceillog2 (unsigned int x) {\n  static const lu_byte log_2[256] = {\n    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8\n  };\n  int l = 0;\n  x--;\n  while (x >= 256) { l += 8; x >>= 8; }\n  return l + log_2[x];\n}\n\n\nlua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {\n  switch (op) {\n    case LUA_OPADD: return luai_numadd(NULL, v1, v2);\n    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);\n    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);\n    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);\n    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);\n    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);\n    case LUA_OPUNM: return luai_numunm(NULL, v1);\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nint luaO_hexavalue (int c) {\n  if (lisdigit(c)) return c - '0';\n  else return ltolower(c) - 'a' + 10;\n}\n\n\n#if !defined(lua_strx2number)\n\n\n\nstatic int isneg (const char **s) {\n  if (**s == '-') { (*s)++; return 1; }\n  else if (**s == '+') (*s)++;\n  return 0;\n}\n\n\nstatic lua_Number readhexa (const char **s, lua_Number r, int *count) {\n  for (; lisxdigit(cast_uchar(**s)); (*s)++) {   \n    r = (r * cast_num(16.0)) + cast_num(luaO_hexavalue(cast_uchar(**s)));\n    (*count)++;\n  }\n  return r;\n}\n\n\n \nstatic lua_Number lua_strx2number (const char *s, char **endptr) {\n  lua_Number r = 0.0;\n  int e = 0, i = 0;\n  int neg = 0;   \n  *endptr = cast(char *, s);   \n  while (lisspace(cast_uchar(*s))) s++;   \n  neg = isneg(&s);   \n  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))   \n    return 0.0;   \n  s += 2;   \n  r = readhexa(&s, r, &i);   \n  if (*s == '.') {\n    s++;   \n    r = readhexa(&s, r, &e);   \n  }\n  if (i == 0 && e == 0)\n    return 0.0;   \n  e *= -4;   \n  *endptr = cast(char *, s);   \n  if (*s == 'p' || *s == 'P') {   \n    int exp1 = 0;\n    int neg1;\n    s++;   \n    neg1 = isneg(&s);   \n    if (!lisdigit(cast_uchar(*s)))\n      goto ret;   \n    while (lisdigit(cast_uchar(*s)))   \n      exp1 = exp1 * 10 + *(s++) - '0';\n    if (neg1) exp1 = -exp1;\n    e += exp1;\n  }\n  *endptr = cast(char *, s);   \n ret:\n  if (neg) r = -r;\n  return ((e >= 0) ? (r * (1ULL << e)) : (r / (1ULL << -e)));\n}\n\n#endif\n\n\nint luaO_str2d (const char *s, size_t len, lua_Number *result) {\n  char *endptr;\n  if (strpbrk(s, \"nN\"))   \n    return 0;\n  else if (strpbrk(s, \"xX\"))   \n    *result = lua_strx2number(s, &endptr);\n  else\n    *result = lua_str2number(s, &endptr);\n  if (endptr == s) return 0;   \n  while (lisspace(cast_uchar(*endptr))) endptr++;\n  return (endptr == s + len);   \n}\n\n\n\nstatic void pushstr (lua_State *L, const char *str, size_t l) {\n  setsvalue2s(L, L->top++, luaS_newlstr(L, str, l));\n}\n\n\n \nconst char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {\n  int n = 0;\n  for (;;) {\n    const char *e = strchr(fmt, '%');\n    if (e == NULL) break;\n    luaD_checkstack(L, 2);   \n    pushstr(L, fmt, e - fmt);\n    switch (*(e+1)) {\n      case 's': {\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        pushstr(L, s, strlen(s));\n        break;\n      }\n      case 'c': {\n        char buff;\n        buff = cast(char, va_arg(argp, int));\n        pushstr(L, &buff, 1);\n        break;\n      }\n      case 'd': {\n        setnvalue(L->top++, cast_num(va_arg(argp, int)));\n        break;\n      }\n      case 'f': {\n        setnvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));\n        break;\n      }\n      case 'p': {\n        char buff[4*sizeof(void *) + 8];  \n        int l = lcompat_sprintf(buff, sizeof(buff), \"%p\", va_arg(argp, void *));\n        pushstr(L, buff, l);\n        break;\n      }\n      case '%': {\n        pushstr(L, \"%\", 1);\n        break;\n      }\n      default: {\n        luaG_runerror(L,\n            \"invalid option \" LUA_QL(\"%%%c\") \" to \" LUA_QL(\"lua_pushfstring\"),\n            *(e + 1));\n      }\n    }\n    n += 2;\n    fmt = e+2;\n  }\n  luaD_checkstack(L, 1);\n  pushstr(L, fmt, strlen(fmt));\n  if (n > 0) luaV_concat(L, n + 1);\n  return svalue(L->top - 1);\n}\n\n\nconst char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *msg;\n  va_list argp;\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  return msg;\n}\n\n\n \n#define LL(x)\t(sizeof(x)/sizeof(char) - 1)\n\n#define RETS\t\"...\"\n#define PRE\t\"[string \\\"\"\n#define POS\t\"\\\"]\"\n\n#define addstr(a,b,l)\t( memcpy(a,b,(l) * sizeof(char)), a += (l) )\n\nvoid luaO_chunkid (char *out, const char *source, size_t bufflen) {\n  size_t l = strlen(source);\n  if (*source == '=') {   \n    if (l <= bufflen)   \n      memcpy(out, source + 1, l * sizeof(char));\n    else {   \n      addstr(out, source + 1, bufflen - 1);\n      *out = '\\0';\n    }\n  }\n  else if (*source == '@') {   \n    if (l <= bufflen)   \n      memcpy(out, source + 1, l * sizeof(char));\n    else {   \n      addstr(out, RETS, LL(RETS));\n      bufflen -= LL(RETS);\n      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));\n    }\n  }\n  else {   \n    const char *nl = strchr(source, '\\n');   \n    addstr(out, PRE, LL(PRE));   \n    bufflen -= LL(PRE RETS POS) + 1;   \n    if (l < bufflen && nl == NULL) {   \n      addstr(out, source, l);   \n    }\n    else {\n      if (nl != NULL) l = nl - source;   \n      if (l > bufflen) l = bufflen;\n      addstr(out, source, l);\n      addstr(out, RETS, LL(RETS));\n    }\n    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));\n  }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}