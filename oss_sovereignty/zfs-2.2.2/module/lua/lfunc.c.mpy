{
  "module_name": "lfunc.c",
  "hash_id": "a6f23487a628876ddf4b065637d7b5d2c9e82131a00fa1becb13464ac4e3d573",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lfunc.c",
  "human_readable_source": " \n\n\n#define lfunc_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\nClosure *luaF_newCclosure (lua_State *L, int n) {\n  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;\n  c->c.nupvalues = cast_byte(n);\n  return c;\n}\n\n\nClosure *luaF_newLclosure (lua_State *L, int n) {\n  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;\n  c->l.p = NULL;\n  c->l.nupvalues = cast_byte(n);\n  while (n--) c->l.upvals[n] = NULL;\n  return c;\n}\n\n\nUpVal *luaF_newupval (lua_State *L) {\n  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;\n  uv->v = &uv->u.value;\n  setnilvalue(uv->v);\n  return uv;\n}\n\n\nUpVal *luaF_findupval (lua_State *L, StkId level) {\n  global_State *g = G(L);\n  GCObject **pp = &L->openupval;\n  UpVal *p;\n  UpVal *uv;\n  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {\n    GCObject *o = obj2gco(p);\n    lua_assert(p->v != &p->u.value);\n    lua_assert(!isold(o) || isold(obj2gco(L)));\n    if (p->v == level) {   \n      if (isdead(g, o))   \n        changewhite(o);   \n      return p;\n    }\n    pp = &p->next;\n  }\n   \n  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;\n  uv->v = level;   \n  uv->u.l.prev = &g->uvhead;   \n  uv->u.l.next = g->uvhead.u.l.next;\n  uv->u.l.next->u.l.prev = uv;\n  g->uvhead.u.l.next = uv;\n  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);\n  return uv;\n}\n\n\nstatic void unlinkupval (UpVal *uv) {\n  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);\n  uv->u.l.next->u.l.prev = uv->u.l.prev;   \n  uv->u.l.prev->u.l.next = uv->u.l.next;\n}\n\n\nvoid luaF_freeupval (lua_State *L, UpVal *uv) {\n  if (uv->v != &uv->u.value)   \n    unlinkupval(uv);   \n  luaM_free(L, uv);   \n}\n\n\nvoid luaF_close (lua_State *L, StkId level) {\n  UpVal *uv;\n  global_State *g = G(L);\n  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {\n    GCObject *o = obj2gco(uv);\n    lua_assert(!isblack(o) && uv->v != &uv->u.value);\n    L->openupval = uv->next;   \n    if (isdead(g, o))\n      luaF_freeupval(L, uv);   \n    else {\n      unlinkupval(uv);   \n      setobj(L, &uv->u.value, uv->v);   \n      uv->v = &uv->u.value;   \n      gch(o)->next = g->allgc;   \n      g->allgc = o;\n      luaC_checkupvalcolor(g, uv);\n    }\n  }\n}\n\n\nProto *luaF_newproto (lua_State *L) {\n  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;\n  f->k = NULL;\n  f->sizek = 0;\n  f->p = NULL;\n  f->sizep = 0;\n  f->code = NULL;\n  f->cache = NULL;\n  f->sizecode = 0;\n  f->lineinfo = NULL;\n  f->sizelineinfo = 0;\n  f->upvalues = NULL;\n  f->sizeupvalues = 0;\n  f->numparams = 0;\n  f->is_vararg = 0;\n  f->maxstacksize = 0;\n  f->locvars = NULL;\n  f->sizelocvars = 0;\n  f->linedefined = 0;\n  f->lastlinedefined = 0;\n  f->source = NULL;\n  return f;\n}\n\n\nvoid luaF_freeproto (lua_State *L, Proto *f) {\n  luaM_freearray(L, f->code, f->sizecode);\n  luaM_freearray(L, f->p, f->sizep);\n  luaM_freearray(L, f->k, f->sizek);\n  luaM_freearray(L, f->lineinfo, f->sizelineinfo);\n  luaM_freearray(L, f->locvars, f->sizelocvars);\n  luaM_freearray(L, f->upvalues, f->sizeupvalues);\n  luaM_free(L, f);\n}\n\n\n \nconst char *luaF_getlocalname (const Proto *f, int local_number, int pc) {\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {   \n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;   \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}