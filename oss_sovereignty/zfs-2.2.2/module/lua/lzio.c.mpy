{
  "module_name": "lzio.c",
  "hash_id": "e2174955a72902a5d7c9c67cffecc713a1e9f944d53d88cd7e9b3441afd991d9",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lzio.c",
  "human_readable_source": " \n\n\n#define lzio_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"llimits.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lzio.h\"\n\n\nint luaZ_fill (ZIO *z) {\n  size_t size;\n  lua_State *L = z->L;\n  const char *buff;\n  lua_unlock(L);\n  buff = z->reader(L, z->data, &size);\n  lua_lock(L);\n  if (buff == NULL || size == 0)\n    return EOZ;\n  z->n = size - 1;   \n  z->p = buff;\n  return cast_uchar(*(z->p++));\n}\n\n\nvoid luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {\n  z->L = L;\n  z->reader = reader;\n  z->data = data;\n  z->n = 0;\n  z->p = NULL;\n}\n\n\n \nsize_t luaZ_read (ZIO *z, void *b, size_t n) {\n  while (n) {\n    size_t m;\n    if (z->n == 0) {   \n      if (luaZ_fill(z) == EOZ)   \n        return n;   \n      else {\n        z->n++;   \n        z->p--;\n      }\n    }\n    m = (n <= z->n) ? n : z->n;   \n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}\n\n \nchar *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {\n  if (n > buff->buffsize) {\n    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;\n    luaZ_resizebuffer(L, buff, n);\n  }\n  return buff->buffer;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}