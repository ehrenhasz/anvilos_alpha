{
  "module_name": "ldo.c",
  "hash_id": "66d9917ed2048a37e719fe5e92375aa2a83f0148e4aff72918644535594d45d9",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/ldo.c",
  "human_readable_source": " \n\n\n#define ldo_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n#include <sys/asm_linkage.h>\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n \n#if defined (_KERNEL) && defined(__linux__)\n#include <asm/current.h>\nstatic intptr_t stack_remaining(void) {\n  intptr_t local;\n  local = (intptr_t)&local - (intptr_t)current->stack;\n  return local;\n}\n#elif defined (_KERNEL) && defined(__FreeBSD__)\n#include <sys/pcpu.h>\nstatic intptr_t stack_remaining(void) {\n  intptr_t local;\n  local = (intptr_t)&local - (intptr_t)curthread->td_kstack;\n  return local;\n}\n#else\nstatic intptr_t stack_remaining(void) {\n  return INTPTR_MAX;\n}\n#endif\n\n \n\n \n#if !defined(LUAI_THROW)\n\n#ifdef _KERNEL\n\n#ifdef __linux__\n#if defined(__i386__)\n#define\tJMP_BUF_CNT\t6\n#elif defined(__x86_64__)\n#define\tJMP_BUF_CNT\t8\n#elif defined(__sparc__) && defined(__arch64__)\n#define\tJMP_BUF_CNT\t6\n#elif defined(__powerpc__)\n#define\tJMP_BUF_CNT\t26\n#elif defined(__aarch64__)\n#define\tJMP_BUF_CNT\t64\n#elif defined(__arm__)\n#define\tJMP_BUF_CNT\t65\n#elif defined(__mips__)\n#define JMP_BUF_CNT\t12\n#elif defined(__s390x__)\n#define JMP_BUF_CNT\t18\n#elif defined(__riscv)\n#define JMP_BUF_CNT     64\n#elif defined(__loongarch_lp64)\n#define JMP_BUF_CNT     64\n#else\n#define\tJMP_BUF_CNT\t1\n#endif\n\ntypedef\tstruct _label_t { long long unsigned val[JMP_BUF_CNT]; } label_t;\n\nint ASMABI setjmp(label_t *) __attribute__ ((__nothrow__));\nextern __attribute__((noreturn)) void ASMABI longjmp(label_t *);\n\n#define LUAI_THROW(L,c)\t\tlongjmp(&(c)->b)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp(&(c)->b) == 0) { a }\n#define luai_jmpbuf\t\tlabel_t\n\n \n#if JMP_BUF_CNT == 1\nint setjmp (label_t *buf) {\n\treturn 1;\n}\n\nvoid longjmp (label_t * buf) {\n\tfor (;;);\n}\n#endif\n#else\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n#endif\n\n#else  \n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\n \n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,a) \\\n\ttry { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint   \n\n#elif defined(LUA_USE_ULONGJMP)\n \n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\n \n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)\t\tif (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\n\n#endif  \n\n#endif  \n\n\n \nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;   \n};\n\n\nstatic void seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {   \n      setsvalue2s(L, oldtop, G(L)->memerrmsg);  \n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    default: {\n      setobjs2s(L, oldtop, L->top - 1);   \n      break;\n    }\n  }\n  L->top = oldtop + 1;\n}\n\n \n#if defined(__GNUC__) && !defined(__clang__) && \\\n\tdefined(HAVE_KERNEL_INFINITE_RECURSION)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Winfinite-recursion\"\n#endif\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {   \n    L->errorJmp->status = errcode;   \n    LUAI_THROW(L, L->errorJmp);   \n  }\n  else {   \n    L->status = cast_byte(errcode);   \n    if (G(L)->mainthread->errorJmp) {   \n      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);   \n      luaD_throw(G(L)->mainthread, errcode);   \n    }\n    else {   \n      if (G(L)->panic) {   \n        lua_unlock(L);\n        G(L)->panic(L);   \n      }\n      panic(\"no error handler\");\n    }\n  }\n}\n\n#if defined(__GNUC__) && !defined(__clang__) && \\\n\tdefined(HAVE_INFINITE_RECURSION)\n#pragma GCC diagnostic pop\n#endif\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  unsigned short oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;   \n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,\n    (*f)(L, ud);\n  );\n  L->errorJmp = lj.previous;   \n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\n \n\n\nstatic void correctstack (lua_State *L, TValue *oldstack) {\n  CallInfo *ci;\n  GCObject *up;\n  L->top = (L->top - oldstack) + L->stack;\n  for (up = L->openupval; up != NULL; up = up->gch.next)\n    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top = (ci->top - oldstack) + L->stack;\n    ci->func = (ci->func - oldstack) + L->stack;\n    if (isLua(ci))\n      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;\n  }\n}\n\n\n \n#define ERRORSTACKSIZE\t(LUAI_MAXSTACK + 200)\n\n\nvoid luaD_reallocstack (lua_State *L, int newsize) {\n  TValue *oldstack = L->stack;\n  int lim = L->stacksize;\n  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);\n  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);\n  for (; lim < newsize; lim++)\n    setnilvalue(L->stack + lim);  \n  L->stacksize = newsize;\n  L->stack_last = L->stack + newsize - EXTRA_STACK;\n  correctstack(L, oldstack);\n}\n\n\nvoid luaD_growstack (lua_State *L, int n) {\n  int size = L->stacksize;\n  if (size > LUAI_MAXSTACK)   \n    luaD_throw(L, LUA_ERRERR);\n  else {\n    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;\n    int newsize = 2 * size;\n    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;\n    if (newsize < needed) newsize = needed;\n    if (newsize > LUAI_MAXSTACK) {   \n      luaD_reallocstack(L, ERRORSTACKSIZE);\n      luaG_runerror(L, \"stack overflow\");\n    }\n    else\n      luaD_reallocstack(L, newsize);\n  }\n}\n\n\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  StkId lim = L->top;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    lua_assert(ci->top <= L->stack_last);\n    if (lim < ci->top) lim = ci->top;\n  }\n  return cast_int(lim - L->stack) + 1;   \n}\n\n\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;\n  if (inuse > LUAI_MAXSTACK ||   \n      goodsize >= L->stacksize)   \n    condmovestack(L);   \n  else\n    luaD_reallocstack(L, goodsize);   \n}\n\n\nvoid luaD_hook (lua_State *L, int event, int line) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top);\n    ptrdiff_t ci_top = savestack(L, ci->top);\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    luaD_checkstack(L, LUA_MINSTACK);   \n    ci->top = L->top + LUA_MINSTACK;\n    lua_assert(ci->top <= L->stack_last);\n    L->allowhook = 0;   \n    ci->callstatus |= CIST_HOOKED;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top = restorestack(L, ci_top);\n    L->top = restorestack(L, top);\n    ci->callstatus &= ~CIST_HOOKED;\n  }\n}\n\n\nstatic void callhook (lua_State *L, CallInfo *ci) {\n  int hook = LUA_HOOKCALL;\n  ci->u.l.savedpc++;   \n  if (isLua(ci->previous) &&\n      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {\n    ci->callstatus |= CIST_TAIL;\n    hook = LUA_HOOKTAILCALL;\n  }\n  luaD_hook(L, hook, -1);\n  ci->u.l.savedpc--;   \n}\n\n\nstatic StkId adjust_varargs (lua_State *L, Proto *p, int actual) {\n  int i;\n  int nfixargs = p->numparams;\n  StkId base, fixed;\n  lua_assert(actual >= nfixargs);\n   \n  luaD_checkstack(L, p->maxstacksize);   \n  fixed = L->top - actual;   \n  base = L->top;   \n  for (i=0; i<nfixargs; i++) {\n    setobjs2s(L, L->top++, fixed + i);\n    setnilvalue(fixed + i);\n  }\n  return base;\n}\n\n\nstatic StkId tryfuncTM (lua_State *L, StkId func) {\n  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);\n  StkId p;\n  ptrdiff_t funcr = savestack(L, func);\n  if (!ttisfunction(tm))\n    luaG_typeerror(L, func, \"call\");\n   \n  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);\n  incr_top(L);\n  func = restorestack(L, funcr);   \n  setobj2s(L, func, tm);   \n  return func;\n}\n\n\n\n#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))\n\n\n \nint luaD_precall (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n  CallInfo *ci;\n  int n;   \n  ptrdiff_t funcr = savestack(L, func);\n  switch (ttype(func)) {\n    case LUA_TLCF:   \n      f = fvalue(func);\n      goto Cfunc;\n    case LUA_TCCL: {   \n      f = clCvalue(func)->f;\n     Cfunc:\n      luaD_checkstack(L, LUA_MINSTACK);   \n      ci = next_ci(L);   \n      ci->nresults = nresults;\n      ci->func = restorestack(L, funcr);\n      ci->top = L->top + LUA_MINSTACK;\n      lua_assert(ci->top <= L->stack_last);\n      ci->callstatus = 0;\n      luaC_checkGC(L);   \n      if (L->hookmask & LUA_MASKCALL)\n        luaD_hook(L, LUA_HOOKCALL, -1);\n      lua_unlock(L);\n      n = (*f)(L);   \n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, L->top - n);\n      return 1;\n    }\n    case LUA_TLCL: {   \n      StkId base;\n      Proto *p = clLvalue(func)->p;\n      n = cast_int(L->top - func) - 1;   \n      luaD_checkstack(L, p->maxstacksize + p->numparams);\n      for (; n < p->numparams; n++)\n        setnilvalue(L->top++);   \n      if (!p->is_vararg) {\n        func = restorestack(L, funcr);\n        base = func + 1;\n      }\n      else {\n        base = adjust_varargs(L, p, n);\n        func = restorestack(L, funcr);   \n      }\n      ci = next_ci(L);   \n      ci->nresults = nresults;\n      ci->func = func;\n      ci->u.l.base = base;\n      ci->top = base + p->maxstacksize;\n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;   \n      ci->callstatus = CIST_LUA;\n      L->top = ci->top;\n      luaC_checkGC(L);   \n      if (L->hookmask & LUA_MASKCALL)\n        callhook(L, ci);\n      return 0;\n    }\n    default: {   \n      func = tryfuncTM(L, func);   \n      return luaD_precall(L, func, nresults);   \n    }\n  }\n}\n\n\nint luaD_poscall (lua_State *L, StkId firstResult) {\n  StkId res;\n  int wanted, i;\n  CallInfo *ci = L->ci;\n  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {\n    if (L->hookmask & LUA_MASKRET) {\n      ptrdiff_t fr = savestack(L, firstResult);   \n      luaD_hook(L, LUA_HOOKRET, -1);\n      firstResult = restorestack(L, fr);\n    }\n    L->oldpc = ci->previous->u.l.savedpc;   \n  }\n  res = ci->func;   \n  wanted = ci->nresults;\n  L->ci = ci->previous;   \n   \n  for (i = wanted; i != 0 && firstResult < L->top; i--)\n    setobjs2s(L, res++, firstResult++);\n  while (i-- > 0)\n    setnilvalue(res++);\n  L->top = res;\n  return (wanted - LUA_MULTRET);   \n}\n\n\n \nvoid luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {\n  if (++L->nCcalls >= LUAI_MAXCCALLS) {\n    if (L->nCcalls == LUAI_MAXCCALLS)\n      luaG_runerror(L, \"C stack overflow\");\n    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))\n      luaD_throw(L, LUA_ERRERR);   \n  }\n  intptr_t remaining = stack_remaining();\n  if (L->runerror == 0 && remaining < LUAI_MINCSTACK)\n    luaG_runerror(L, \"C stack overflow\");\n  if (L->runerror != 0 && remaining < LUAI_MINCSTACK / 2)\n    luaD_throw(L, LUA_ERRERR);   \n  if (!allowyield) L->nny++;\n  if (!luaD_precall(L, func, nResults))   \n    luaV_execute(L);   \n  if (!allowyield) L->nny--;\n  L->nCcalls--;\n}\n\n\nstatic void finishCcall (lua_State *L) {\n  CallInfo *ci = L->ci;\n  int n;\n  lua_assert(ci->u.c.k != NULL);   \n  lua_assert(L->nny == 0);\n  if (ci->callstatus & CIST_YPCALL) {   \n    ci->callstatus &= ~CIST_YPCALL;   \n    L->errfunc = ci->u.c.old_errfunc;\n  }\n   \n  adjustresults(L, ci->nresults);\n   \n  if (!(ci->callstatus & CIST_STAT))   \n    ci->u.c.status = LUA_YIELD;   \n  lua_assert(ci->u.c.status != LUA_OK);\n  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;\n  lua_unlock(L);\n  n = (*ci->u.c.k)(L);\n  lua_lock(L);\n  api_checknelems(L, n);\n   \n  luaD_poscall(L, L->top - n);\n}\n\n\nstatic void unroll (lua_State *L, void *ud) {\n  UNUSED(ud);\n  for (;;) {\n    if (L->ci == &L->base_ci)   \n      return;   \n    if (!isLua(L->ci))   \n      finishCcall(L);\n    else {   \n      luaV_finishOp(L);   \n      luaV_execute(L);   \n    }\n  }\n}\n\n\n \nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {   \n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;   \n}\n\n\nstatic int recover (lua_State *L, int status) {\n  StkId oldtop;\n  CallInfo *ci = findpcall(L);\n  if (ci == NULL) return 0;   \n   \n  oldtop = restorestack(L, ci->extra);\n  luaF_close(L, oldtop);\n  seterrorobj(L, status, oldtop);\n  L->ci = ci;\n  L->allowhook = ci->u.c.old_allowhook;\n  L->nny = 0;   \n  luaD_shrinkstack(L);\n  L->errfunc = ci->u.c.old_errfunc;\n  ci->callstatus |= CIST_STAT;   \n  ci->u.c.status = status;   \n  return 1;   \n}\n\n\n \nstatic l_noret resume_error (lua_State *L, const char *msg, StkId firstArg) {\n  L->top = firstArg;   \n  setsvalue2s(L, L->top, luaS_new(L, msg));   \n  api_incr_top(L);\n  luaD_throw(L, -1);   \n}\n\n\n \nstatic void resume_cb (lua_State *L, void *ud) {\n  int nCcalls = L->nCcalls;\n  StkId firstArg = cast(StkId, ud);\n  CallInfo *ci = L->ci;\n  if (nCcalls >= LUAI_MAXCCALLS)\n    resume_error(L, \"C stack overflow\", firstArg);\n  if (L->status == LUA_OK) {   \n    if (ci != &L->base_ci)   \n      resume_error(L, \"cannot resume non-suspended coroutine\", firstArg);\n     \n    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))   \n      luaV_execute(L);   \n  }\n  else if (L->status != LUA_YIELD)\n    resume_error(L, \"cannot resume dead coroutine\", firstArg);\n  else {   \n    L->status = LUA_OK;\n    ci->func = restorestack(L, ci->extra);\n    if (isLua(ci))   \n      luaV_execute(L);   \n    else {   \n      if (ci->u.c.k != NULL) {   \n        int n;\n        ci->u.c.status = LUA_YIELD;   \n        ci->callstatus |= CIST_YIELDED;\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L);   \n        lua_lock(L);\n        api_checknelems(L, n);\n        firstArg = L->top - n;   \n      }\n      luaD_poscall(L, firstArg);   \n    }\n    unroll(L, NULL);\n  }\n  lua_assert(nCcalls == L->nCcalls);\n}\n\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {\n  int status;\n  int oldnny = L->nny;   \n  lua_lock(L);\n  luai_userstateresume(L, nargs);\n  L->nCcalls = (from) ? from->nCcalls + 1 : 1;\n  L->nny = 0;   \n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume_cb, L->top - nargs);\n  if (status == -1)   \n    status = LUA_ERRRUN;\n  else {   \n    while (status != LUA_OK && status != LUA_YIELD) {   \n      if (recover(L, status))   \n        status = luaD_rawrunprotected(L, unroll, NULL);   \n      else {   \n        L->status = cast_byte(status);   \n        seterrorobj(L, status, L->top);\n        L->ci->top = L->top;\n        break;\n      }\n    }\n    lua_assert(status == L->status);\n  }\n  L->nny = oldnny;   \n  L->nCcalls--;\n  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {\n  CallInfo *ci = L->ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  api_checknelems(L, nresults);\n  if (L->nny > 0) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  ci->extra = savestack(L, ci->func);   \n  if (isLua(ci)) {   \n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)   \n      ci->u.c.ctx = ctx;   \n    ci->func = L->top - nresults - 1;   \n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);   \n  lua_unlock(L);\n  return 0;   \n}\n\n\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  unsigned short old_nny = L->nny;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (status != LUA_OK) {   \n    StkId oldtop = restorestack(L, old_top);\n    luaF_close(L, oldtop);   \n    seterrorobj(L, status, oldtop);\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    L->nny = old_nny;\n    luaD_shrinkstack(L);\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n \nstruct SParser {   \n  ZIO *z;\n  Mbuffer buff;   \n  Dyndata dyd;   \n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (mode && strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is \" LUA_QS \")\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  int i;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = zgetc(p->z);   \n  lua_assert(c != LUA_SIGNATURE[0]);\t \n  checkmode(L, p->mode, \"text\");\n  cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);\n  for (i = 0; i < cl->l.nupvalues; i++) {   \n    UpVal *up = luaF_newupval(L);\n    cl->l.upvals[i] = up;\n    luaC_objbarrier(L, cl, up);\n  }\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  L->nny++;   \n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);\n  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);\n  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);\n  L->nny--;\n  return status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}