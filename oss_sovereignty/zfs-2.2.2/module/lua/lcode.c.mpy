{
  "module_name": "lcode.c",
  "hash_id": "cced28c9ec8b7bd6bb55e34436612d56685a6d65a067a66b34c4c853c6a4dd93",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lcode.c",
  "human_readable_source": " \n\n#define lcode_c\n#define LUA_CORE\n\n#if defined(HAVE_IMPLICIT_FALLTHROUGH)\n#pragma GCC diagnostic ignored \"-Wimplicit-fallthrough\"\n#endif\n\n#include <sys/lua/lua.h>\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n#define hasjumps(e)\t((e)->t != (e)->f)\n\n\nstatic int isnumeral(expdesc *e) {\n  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);\n}\n\n\nvoid luaK_nil (FuncState *fs, int from, int n) {\n  Instruction *previous;\n  int l = from + n - 1;   \n  if (fs->pc > fs->lasttarget) {   \n    previous = &fs->f->code[fs->pc-1];\n    if (GET_OPCODE(*previous) == OP_LOADNIL) {\n      int pfrom = GETARG_A(*previous);\n      int pl = pfrom + GETARG_B(*previous);\n      if ((pfrom <= from && from <= pl + 1) ||\n          (from <= pfrom && pfrom <= l + 1)) {   \n        if (pfrom < from) from = pfrom;   \n        if (pl > l) l = pl;   \n        SETARG_A(*previous, from);\n        SETARG_B(*previous, l - from);\n        return;\n      }\n    }   \n  }\n  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);   \n}\n\n\nint luaK_jump (FuncState *fs) {\n  int jpc = fs->jpc;   \n  int j;\n  fs->jpc = NO_JUMP;\n  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);\n  luaK_concat(fs, &j, jpc);   \n  return j;\n}\n\n\nvoid luaK_ret (FuncState *fs, int first, int nret) {\n  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);\n}\n\n\nstatic int condjump (FuncState *fs, OpCode op, int A, int B, int C) {\n  luaK_codeABC(fs, op, A, B, C);\n  return luaK_jump(fs);\n}\n\n\nstatic void fixjump (FuncState *fs, int pc, int dest) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest-(pc+1);\n  lua_assert(dest != NO_JUMP);\n  if (abs(offset) > MAXARG_sBx)\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  SETARG_sBx(*jmp, offset);\n}\n\n\n \nint luaK_getlabel (FuncState *fs) {\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}\n\n\nstatic int getjump (FuncState *fs, int pc) {\n  int offset = GETARG_sBx(fs->f->code[pc]);\n  if (offset == NO_JUMP)   \n    return NO_JUMP;   \n  else\n    return (pc+1)+offset;   \n}\n\n\nstatic Instruction *getjumpcontrol (FuncState *fs, int pc) {\n  Instruction *pi = &fs->f->code[pc];\n  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))\n    return pi-1;\n  else\n    return pi;\n}\n\n\n \nstatic int need_value (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;   \n}\n\n\nstatic int patchtestreg (FuncState *fs, int node, int reg) {\n  Instruction *i = getjumpcontrol(fs, node);\n  if (GET_OPCODE(*i) != OP_TESTSET)\n    return 0;   \n  if (reg != NO_REG && reg != GETARG_B(*i))\n    SETARG_A(*i, reg);\n  else   \n    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));\n\n  return 1;\n}\n\n\nstatic void removevalues (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list))\n      patchtestreg(fs, list, NO_REG);\n}\n\n\nstatic void patchlistaux (FuncState *fs, int list, int vtarget, int reg,\n                          int dtarget) {\n  while (list != NO_JUMP) {\n    int next = getjump(fs, list);\n    if (patchtestreg(fs, list, reg))\n      fixjump(fs, list, vtarget);\n    else\n      fixjump(fs, list, dtarget);   \n    list = next;\n  }\n}\n\n\nstatic void dischargejpc (FuncState *fs) {\n  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);\n  fs->jpc = NO_JUMP;\n}\n\n\nvoid luaK_patchlist (FuncState *fs, int list, int target) {\n  if (target == fs->pc)\n    luaK_patchtohere(fs, list);\n  else {\n    lua_assert(target < fs->pc);\n    patchlistaux(fs, list, target, NO_REG, target);\n  }\n}\n\n\nLUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {\n  level++;   \n  while (list != NO_JUMP) {\n    int next = getjump(fs, list);\n    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&\n                (GETARG_A(fs->f->code[list]) == 0 ||\n                 GETARG_A(fs->f->code[list]) >= level));\n    SETARG_A(fs->f->code[list], level);\n    list = next;\n  }\n}\n\n\nvoid luaK_patchtohere (FuncState *fs, int list) {\n  luaK_getlabel(fs);\n  luaK_concat(fs, &fs->jpc, list);\n}\n\n\nvoid luaK_concat (FuncState *fs, int *l1, int l2) {\n  if (l2 == NO_JUMP) return;\n  else if (*l1 == NO_JUMP)\n    *l1 = l2;\n  else {\n    int list = *l1;\n    int next;\n    while ((next = getjump(fs, list)) != NO_JUMP)   \n      list = next;\n    fixjump(fs, list, l2);\n  }\n}\n\n\nstatic int luaK_code (FuncState *fs, Instruction i) {\n  Proto *f = fs->f;\n  dischargejpc(fs);   \n   \n  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,\n                  MAX_INT, \"opcodes\");\n  f->code[fs->pc] = i;\n   \n  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,\n                  MAX_INT, \"opcodes\");\n  f->lineinfo[fs->pc] = fs->ls->lastline;\n  return fs->pc++;\n}\n\n\nint luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {\n  lua_assert(getOpMode(o) == iABC);\n  lua_assert(getBMode(o) != OpArgN || b == 0);\n  lua_assert(getCMode(o) != OpArgN || c == 0);\n  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);\n  return luaK_code(fs, CREATE_ABC(o, a, b, c));\n}\n\n\nint luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {\n  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);\n  lua_assert(getCMode(o) == OpArgN);\n  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);\n  return luaK_code(fs, CREATE_ABx(o, a, bc));\n}\n\n\nstatic int codeextraarg (FuncState *fs, int a) {\n  lua_assert(a <= MAXARG_Ax);\n  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));\n}\n\n\nint luaK_codek (FuncState *fs, int reg, int k) {\n  if (k <= MAXARG_Bx)\n    return luaK_codeABx(fs, OP_LOADK, reg, k);\n  else {\n    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);\n    codeextraarg(fs, k);\n    return p;\n  }\n}\n\n\nvoid luaK_checkstack (FuncState *fs, int n) {\n  int newstack = fs->freereg + n;\n  if (newstack > fs->f->maxstacksize) {\n    if (newstack >= MAXSTACK)\n      luaX_syntaxerror(fs->ls, \"function or expression too complex\");\n    fs->f->maxstacksize = cast_byte(newstack);\n  }\n}\n\n\nvoid luaK_reserveregs (FuncState *fs, int n) {\n  luaK_checkstack(fs, n);\n  fs->freereg += n;\n}\n\n\nstatic void freereg (FuncState *fs, int reg) {\n  if (!ISK(reg) && reg >= fs->nactvar) {\n    fs->freereg--;\n    lua_assert(reg == fs->freereg);\n  }\n}\n\n\nstatic void freeexp (FuncState *fs, expdesc *e) {\n  if (e->k == VNONRELOC)\n    freereg(fs, e->u.info);\n}\n\n\nstatic int addk (FuncState *fs, TValue *key, TValue *v) {\n  lua_State *L = fs->ls->L;\n  TValue *idx = luaH_set(L, fs->h, key);\n  Proto *f = fs->f;\n  int k, oldsize;\n  if (ttisnumber(idx)) {\n    lua_Number n = nvalue(idx);\n    lua_number2int(k, n);\n    if (luaV_rawequalobj(&f->k[k], v))\n      return k;\n     \n  }\n   \n  oldsize = f->sizek;\n  k = fs->nk;\n   \n  setnvalue(idx, cast_num(k));\n  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, \"constants\");\n  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);\n  setobj(L, &f->k[k], v);\n  fs->nk++;\n  luaC_barrier(L, f, v);\n  return k;\n}\n\n\nint luaK_stringK (FuncState *fs, TString *s) {\n  TValue o;\n  setsvalue(fs->ls->L, &o, s);\n  return addk(fs, &o, &o);\n}\n\n\nint luaK_numberK (FuncState *fs, lua_Number r) {\n  int n;\n  lua_State *L = fs->ls->L;\n  TValue o;\n  setnvalue(&o, r);\n  if (r == 0 || luai_numisnan(NULL, r)) {   \n     \n    setsvalue(L, L->top++, luaS_newlstr(L, (char *)&r, sizeof(r)));\n    n = addk(fs, L->top - 1, &o);\n    L->top--;\n  }\n  else\n    n = addk(fs, &o, &o);   \n  return n;\n}\n\n\nstatic int boolK (FuncState *fs, int b) {\n  TValue o;\n  setbvalue(&o, b);\n  return addk(fs, &o, &o);\n}\n\n\nstatic int nilK (FuncState *fs) {\n  TValue k, v;\n  setnilvalue(&v);\n   \n  sethvalue(fs->ls->L, &k, fs->h);\n  return addk(fs, &k, &v);\n}\n\n\nvoid luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {\n  if (e->k == VCALL) {   \n    SETARG_C(getcode(fs, e), nresults+1);\n  }\n  else if (e->k == VVARARG) {\n    SETARG_B(getcode(fs, e), nresults+1);\n    SETARG_A(getcode(fs, e), fs->freereg);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n\nvoid luaK_setoneret (FuncState *fs, expdesc *e) {\n  if (e->k == VCALL) {   \n    e->k = VNONRELOC;\n    e->u.info = GETARG_A(getcode(fs, e));\n  }\n  else if (e->k == VVARARG) {\n    SETARG_B(getcode(fs, e), 2);\n    e->k = VRELOCABLE;   \n  }\n}\n\n\nvoid luaK_dischargevars (FuncState *fs, expdesc *e) {\n  switch (e->k) {\n    case VLOCAL: {\n      e->k = VNONRELOC;\n      break;\n    }\n    case VUPVAL: {\n      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);\n      e->k = VRELOCABLE;\n      break;\n    }\n    case VINDEXED: {\n      OpCode op = OP_GETTABUP;   \n      freereg(fs, e->u.ind.idx);\n      if (e->u.ind.vt == VLOCAL) {   \n        freereg(fs, e->u.ind.t);\n        op = OP_GETTABLE;\n      }\n      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOCABLE;\n      break;\n    }\n    case VVARARG:\n    case VCALL: {\n      luaK_setoneret(fs, e);\n      break;\n    }\n    default: break;   \n  }\n}\n\n\nstatic int code_label (FuncState *fs, int A, int b, int jump) {\n  luaK_getlabel(fs);   \n  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);\n}\n\n\nstatic void discharge2reg (FuncState *fs, expdesc *e, int reg) {\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VNIL: {\n      luaK_nil(fs, reg, 1);\n      break;\n    }\n    case VFALSE: case VTRUE: {\n      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);\n      break;\n    }\n    case VK: {\n      luaK_codek(fs, reg, e->u.info);\n      break;\n    }\n    case VKNUM: {\n      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));\n      break;\n    }\n    case VRELOCABLE: {\n      Instruction *pc = &getcode(fs, e);\n      SETARG_A(*pc, reg);\n      break;\n    }\n    case VNONRELOC: {\n      if (reg != e->u.info)\n        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);\n      break;\n    }\n    default: {\n      lua_assert(e->k == VVOID || e->k == VJMP);\n      return;   \n    }\n  }\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\nstatic void discharge2anyreg (FuncState *fs, expdesc *e) {\n  if (e->k != VNONRELOC) {\n    luaK_reserveregs(fs, 1);\n    discharge2reg(fs, e, fs->freereg-1);\n  }\n}\n\n\nstatic void exp2reg (FuncState *fs, expdesc *e, int reg) {\n  discharge2reg(fs, e, reg);\n  if (e->k == VJMP)\n    luaK_concat(fs, &e->t, e->u.info);   \n  if (hasjumps(e)) {\n    int final;   \n    int p_f = NO_JUMP;   \n    int p_t = NO_JUMP;   \n    if (need_value(fs, e->t) || need_value(fs, e->f)) {\n      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);\n      p_f = code_label(fs, reg, 0, 1);\n      p_t = code_label(fs, reg, 1, 0);\n      luaK_patchtohere(fs, fj);\n    }\n    final = luaK_getlabel(fs);\n    patchlistaux(fs, e->f, final, reg, p_f);\n    patchlistaux(fs, e->t, final, reg, p_t);\n  }\n  e->f = e->t = NO_JUMP;\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\nvoid luaK_exp2nextreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  freeexp(fs, e);\n  luaK_reserveregs(fs, 1);\n  exp2reg(fs, e, fs->freereg - 1);\n}\n\n\nint luaK_exp2anyreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  if (e->k == VNONRELOC) {\n    if (!hasjumps(e)) return e->u.info;   \n    if (e->u.info >= fs->nactvar) {   \n      exp2reg(fs, e, e->u.info);   \n      return e->u.info;\n    }\n  }\n  luaK_exp2nextreg(fs, e);   \n  return e->u.info;\n}\n\n\nvoid luaK_exp2anyregup (FuncState *fs, expdesc *e) {\n  if (e->k != VUPVAL || hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n}\n\n\nvoid luaK_exp2val (FuncState *fs, expdesc *e) {\n  if (hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n  else\n    luaK_dischargevars(fs, e);\n}\n\n\nint luaK_exp2RK (FuncState *fs, expdesc *e) {\n  luaK_exp2val(fs, e);\n  switch (e->k) {\n    case VTRUE:\n    case VFALSE:\n    case VNIL: {\n      if (fs->nk <= MAXINDEXRK) {   \n        e->u.info = (e->k == VNIL) ? nilK(fs) : boolK(fs, (e->k == VTRUE));\n        e->k = VK;\n        return RKASK(e->u.info);\n      }\n      else break;\n    }\n    case VKNUM: {\n      e->u.info = luaK_numberK(fs, e->u.nval);\n      e->k = VK;\n       \n    }\n    case VK: {\n      if (e->u.info <= MAXINDEXRK)   \n        return RKASK(e->u.info);\n      else break;\n    }\n    default: break;\n  }\n   \n  return luaK_exp2anyreg(fs, e);\n}\n\n\nvoid luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {\n  switch (var->k) {\n    case VLOCAL: {\n      freeexp(fs, ex);\n      exp2reg(fs, ex, var->u.info);\n      return;\n    }\n    case VUPVAL: {\n      int e = luaK_exp2anyreg(fs, ex);\n      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);\n      break;\n    }\n    case VINDEXED: {\n      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;\n      int e = luaK_exp2RK(fs, ex);\n      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);\n      break;\n    }\n    default: {\n      lua_assert(0);   \n      break;\n    }\n  }\n  freeexp(fs, ex);\n}\n\n\nvoid luaK_self (FuncState *fs, expdesc *e, expdesc *key) {\n  int ereg;\n  luaK_exp2anyreg(fs, e);\n  ereg = e->u.info;   \n  freeexp(fs, e);\n  e->u.info = fs->freereg;   \n  e->k = VNONRELOC;\n  luaK_reserveregs(fs, 2);   \n  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));\n  freeexp(fs, key);\n}\n\n\nstatic void invertjump (FuncState *fs, expdesc *e) {\n  Instruction *pc = getjumpcontrol(fs, e->u.info);\n  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&\n                                           GET_OPCODE(*pc) != OP_TEST);\n  SETARG_A(*pc, !(GETARG_A(*pc)));\n}\n\n\nstatic int jumponcond (FuncState *fs, expdesc *e, int cond) {\n  if (e->k == VRELOCABLE) {\n    Instruction ie = getcode(fs, e);\n    if (GET_OPCODE(ie) == OP_NOT) {\n      fs->pc--;   \n      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);\n    }\n     \n  }\n  discharge2anyreg(fs, e);\n  freeexp(fs, e);\n  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);\n}\n\n\nvoid luaK_goiftrue (FuncState *fs, expdesc *e) {\n  int pc;   \n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {\n      invertjump(fs, e);\n      pc = e->u.info;\n      break;\n    }\n    case VK: case VKNUM: case VTRUE: {\n      pc = NO_JUMP;   \n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 0);\n      break;\n    }\n  }\n  luaK_concat(fs, &e->f, pc);   \n  luaK_patchtohere(fs, e->t);\n  e->t = NO_JUMP;\n}\n\n\nvoid luaK_goiffalse (FuncState *fs, expdesc *e) {\n  int pc;   \n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {\n      pc = e->u.info;\n      break;\n    }\n    case VNIL: case VFALSE: {\n      pc = NO_JUMP;   \n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 1);\n      break;\n    }\n  }\n  luaK_concat(fs, &e->t, pc);   \n  luaK_patchtohere(fs, e->f);\n  e->f = NO_JUMP;\n}\n\n\nstatic void codenot (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VNIL: case VFALSE: {\n      e->k = VTRUE;\n      break;\n    }\n    case VK: case VKNUM: case VTRUE: {\n      e->k = VFALSE;\n      break;\n    }\n    case VJMP: {\n      invertjump(fs, e);\n      break;\n    }\n    case VRELOCABLE:\n    case VNONRELOC: {\n      discharge2anyreg(fs, e);\n      freeexp(fs, e);\n      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);\n      e->k = VRELOCABLE;\n      break;\n    }\n    default: {\n      lua_assert(0);   \n      break;\n    }\n  }\n   \n  { int temp = e->f; e->f = e->t; e->t = temp; }\n  removevalues(fs, e->f);\n  removevalues(fs, e->t);\n}\n\n\nvoid luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {\n  lua_assert(!hasjumps(t));\n  t->u.ind.t = t->u.info;\n  t->u.ind.idx = luaK_exp2RK(fs, k);\n  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL\n                                 : check_exp(vkisinreg(t->k), VLOCAL);\n  t->k = VINDEXED;\n}\n\n\nstatic int constfolding (OpCode op, expdesc *e1, expdesc *e2) {\n  lua_Number r;\n  if (!isnumeral(e1) || !isnumeral(e2)) return 0;\n  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)\n    return 0;   \n   \n  if (op == OP_DIV && e1->u.nval == INT64_MIN && e2->u.nval == -1)\n    return 0;\n  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);\n  e1->u.nval = r;\n  return 1;\n}\n\n\nstatic void codearith (FuncState *fs, OpCode op,\n                       expdesc *e1, expdesc *e2, int line) {\n  if (constfolding(op, e1, e2))\n    return;\n  else {\n    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;\n    int o1 = luaK_exp2RK(fs, e1);\n    if (o1 > o2) {\n      freeexp(fs, e1);\n      freeexp(fs, e2);\n    }\n    else {\n      freeexp(fs, e2);\n      freeexp(fs, e1);\n    }\n    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);\n    e1->k = VRELOCABLE;\n    luaK_fixline(fs, line);\n  }\n}\n\n\nstatic void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,\n                                                          expdesc *e2) {\n  int o1 = luaK_exp2RK(fs, e1);\n  int o2 = luaK_exp2RK(fs, e2);\n  freeexp(fs, e2);\n  freeexp(fs, e1);\n  if (cond == 0 && op != OP_EQ) {\n    int temp;   \n    temp = o1; o1 = o2; o2 = temp;   \n    cond = 1;\n  }\n  e1->u.info = condjump(fs, op, cond, o1, o2);\n  e1->k = VJMP;\n}\n\n\nvoid luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {\n  expdesc e2;\n  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;\n  switch (op) {\n    case OPR_MINUS: {\n      if (isnumeral(e))   \n        e->u.nval = luai_numunm(NULL, e->u.nval);   \n      else {\n        luaK_exp2anyreg(fs, e);\n        codearith(fs, OP_UNM, e, &e2, line);\n      }\n      break;\n    }\n    case OPR_NOT: codenot(fs, e); break;\n    case OPR_LEN: {\n      luaK_exp2anyreg(fs, e);   \n      codearith(fs, OP_LEN, e, &e2, line);\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\nvoid luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {\n  switch (op) {\n    case OPR_AND: {\n      luaK_goiftrue(fs, v);\n      break;\n    }\n    case OPR_OR: {\n      luaK_goiffalse(fs, v);\n      break;\n    }\n    case OPR_CONCAT: {\n      luaK_exp2nextreg(fs, v);   \n      break;\n    }\n    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:\n    case OPR_MOD: case OPR_POW: {\n      if (!isnumeral(v)) luaK_exp2RK(fs, v);\n      break;\n    }\n    default: {\n      luaK_exp2RK(fs, v);\n      break;\n    }\n  }\n}\n\n\nvoid luaK_posfix (FuncState *fs, BinOpr op,\n                  expdesc *e1, expdesc *e2, int line) {\n  switch (op) {\n    case OPR_AND: {\n      lua_assert(e1->t == NO_JUMP);   \n      luaK_dischargevars(fs, e2);\n      luaK_concat(fs, &e2->f, e1->f);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_OR: {\n      lua_assert(e1->f == NO_JUMP);   \n      luaK_dischargevars(fs, e2);\n      luaK_concat(fs, &e2->t, e1->t);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_CONCAT: {\n      luaK_exp2val(fs, e2);\n      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {\n        lua_assert(e1->u.info == GETARG_B(getcode(fs, e2))-1);\n        freeexp(fs, e1);\n        SETARG_B(getcode(fs, e2), e1->u.info);\n        e1->k = VRELOCABLE; e1->u.info = e2->u.info;\n      }\n      else {\n        luaK_exp2nextreg(fs, e2);   \n        codearith(fs, OP_CONCAT, e1, e2, line);\n      }\n      break;\n    }\n    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:\n    case OPR_MOD: case OPR_POW: {\n      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);\n      break;\n    }\n    case OPR_EQ: case OPR_LT: case OPR_LE: {\n      codecomp(fs, cast(OpCode, op - OPR_EQ + OP_EQ), 1, e1, e2);\n      break;\n    }\n    case OPR_NE: case OPR_GT: case OPR_GE: {\n      codecomp(fs, cast(OpCode, op - OPR_NE + OP_EQ), 0, e1, e2);\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\nvoid luaK_fixline (FuncState *fs, int line) {\n  fs->f->lineinfo[fs->pc - 1] = line;\n}\n\n\nvoid luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {\n  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;\n  int b = (tostore == LUA_MULTRET) ? 0 : tostore;\n  lua_assert(tostore != 0);\n  if (c <= MAXARG_C)\n    luaK_codeABC(fs, OP_SETLIST, base, b, c);\n  else if (c <= MAXARG_Ax) {\n    luaK_codeABC(fs, OP_SETLIST, base, b, 0);\n    codeextraarg(fs, c);\n  }\n  else\n    luaX_syntaxerror(fs->ls, \"constructor too long\");\n  fs->freereg = base + 1;   \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}