{
  "module_name": "lstring.c",
  "hash_id": "342c2e470417aa8e91d9f50b0696201831d65b1213d4b183a76c59c526be9a6f",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lstring.c",
  "human_readable_source": " \n\n\n#define lstring_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n\n\n \n#if !defined(LUAI_HASHLIMIT)\n#define LUAI_HASHLIMIT\t\t5\n#endif\n\n\n \nint luaS_eqlngstr (TString *a, TString *b) {\n  size_t len = a->tsv.len;\n  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);\n  return (a == b) ||   \n    ((len == b->tsv.len) &&   \n     (memcmp(getstr(a), getstr(b), len) == 0));   \n}\n\n\n \nint luaS_eqstr (TString *a, TString *b) {\n  return (a->tsv.tt == b->tsv.tt) &&\n         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));\n}\n\n\nunsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {\n  unsigned int h = seed ^ cast(unsigned int, l);\n  size_t l1;\n  size_t step = (l >> LUAI_HASHLIMIT) + 1;\n  for (l1 = l; l1 >= step; l1 -= step)\n    h = h ^ ((h<<5) + (h>>2) + cast_byte(str[l1 - 1]));\n  return h;\n}\n\n\n \nvoid luaS_resize (lua_State *L, int newsize) {\n  int i;\n  stringtable *tb = &G(L)->strt;\n   \n  luaC_runtilstate(L, ~bitmask(GCSsweepstring));\n  if (newsize > tb->size) {\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);\n    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;\n  }\n   \n  for (i=0; i<tb->size; i++) {\n    GCObject *p = tb->hash[i];\n    tb->hash[i] = NULL;\n    while (p) {   \n      GCObject *next = gch(p)->next;   \n      unsigned int h = lmod(gco2ts(p)->hash, newsize);   \n      gch(p)->next = tb->hash[h];   \n      tb->hash[h] = p;\n      resetoldbit(p);   \n      p = next;\n    }\n  }\n  if (newsize < tb->size) {\n     \n    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);\n    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);\n  }\n  tb->size = newsize;\n}\n\n\n \nstatic TString *createstrobj (lua_State *L, const char *str, size_t l,\n                              int tag, unsigned int h, GCObject **list) {\n  TString *ts;\n  char *sbuf;\n  size_t totalsize;   \n  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));\n  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;\n  ts->tsv.len = l;\n  ts->tsv.hash = h;\n  ts->tsv.extra = 0;\n  sbuf = (char *)(TString *)(ts + 1);\n  memcpy(sbuf, str, l*sizeof(char));\n  sbuf[l] = '\\0';   \n  return ts;\n}\n\n\n \nstatic TString *newshrstr (lua_State *L, const char *str, size_t l,\n                                       unsigned int h) {\n  GCObject **list;   \n  stringtable *tb = &G(L)->strt;\n  TString *s;\n  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)\n    luaS_resize(L, tb->size*2);   \n  list = &tb->hash[lmod(h, tb->size)];\n  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);\n  tb->nuse++;\n  return s;\n}\n\n\n \nstatic TString *internshrstr (lua_State *L, const char *str, size_t l) {\n  GCObject *o;\n  global_State *g = G(L);\n  unsigned int h = luaS_hash(str, l, g->seed);\n  for (o = g->strt.hash[lmod(h, g->strt.size)];\n       o != NULL;\n       o = gch(o)->next) {\n    TString *ts = rawgco2ts(o);\n    if (h == ts->tsv.hash &&\n        l == ts->tsv.len &&\n        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {\n      if (isdead(G(L), o))   \n        changewhite(o);   \n      return ts;\n    }\n  }\n  return newshrstr(L, str, l, h);   \n}\n\n\n \nTString *luaS_newlstr (lua_State *L, const char *str, size_t l) {\n  if (l <= LUAI_MAXSHORTLEN)   \n    return internshrstr(L, str, l);\n  else {\n    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))\n      luaM_toobig(L);\n    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);\n  }\n}\n\n\n \nTString *luaS_new (lua_State *L, const char *str) {\n  return luaS_newlstr(L, str, strlen(str));\n}\n\n\nUdata *luaS_newudata (lua_State *L, size_t s, Table *e) {\n  Udata *u;\n  if (s > MAX_SIZET - sizeof(Udata))\n    luaM_toobig(L);\n  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;\n  u->uv.len = s;\n  u->uv.metatable = NULL;\n  u->uv.env = e;\n  return u;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}