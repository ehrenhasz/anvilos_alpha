{
  "module_name": "llimits.h",
  "hash_id": "a91086d669bfe806060ee77d3146e3fae4b6ef7d902949ba373fed783c025736",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/llimits.h",
  "human_readable_source": " \n\n#ifndef llimits_h\n#define llimits_h\n\n\n#include <sys/lua/lua.h>\n\n\ntypedef unsigned LUA_INT32 lu_int32;\n\ntypedef LUAI_UMEM lu_mem;\n\ntypedef LUAI_MEM l_mem;\n\n\n\n \ntypedef unsigned char lu_byte;\n\n\n#define MAX_SIZET\t((size_t)(~(size_t)0)-2)\n\n#define MAX_LUMEM\t((lu_mem)(~(lu_mem)0)-2)\n\n#define MAX_LMEM\t((l_mem) ((MAX_LUMEM >> 1) - 2))\n\n\n#define MAX_INT (INT_MAX-2)   \n\n \n#define IntPoint(p)  ((unsigned int)(lu_mem)(p))\n\n\n\n \n#if !defined(LUAI_USER_ALIGNMENT_T)\n#define LUAI_USER_ALIGNMENT_T\tunion { double u; void *s; long l; }\n#endif\n\ntypedef LUAI_USER_ALIGNMENT_T L_Umaxalign;\n\n\n \ntypedef LUAI_UACNUMBER l_uacNumber;\n\n\n \n#if defined(lua_assert)\n#define check_exp(c,e)\t\t(lua_assert(c), (e))\n \n#define lua_longassert(c)\t{ if (!(c)) lua_assert(0); }\n#else\n#define lua_assert(c)\t\t((void)0)\n#define check_exp(c,e)\t\t(e)\n#define lua_longassert(c)\t((void)0)\n#endif\n\n \n#if !defined(luai_apicheck)\n\n#if defined(LUA_USE_APICHECK)\n#include <assert.h>\n#define luai_apicheck(L,e)\tassert(e)\n#else\n#define luai_apicheck(L,e)\tlua_assert(e)\n#endif\n\n#endif\n\n#define api_check(l,e,msg)\tluai_apicheck(l,(e) && msg)\n\n\n#if !defined(UNUSED)\n#define UNUSED(x)\t((void)(x))\t \n#endif\n\n\n#define cast(t, exp)\t((t)(exp))\n\n#define cast_byte(i)\tcast(lu_byte, (i))\n#define cast_num(i)\tcast(lua_Number, (i))\n#define cast_int(i)\tcast(int, (i))\n#define cast_uchar(i)\tcast(unsigned char, (i))\n\n\n \n#if defined(__GNUC__) && !defined(_KERNEL)\n#define l_noret\t\tvoid __attribute__((noreturn))\n#elif defined(_MSC_VER)\n#define l_noret\t\tvoid __declspec(noreturn)\n#else\n#define l_noret\t\tvoid\n#endif\n\n\n\n \n#if !defined(LUAI_MAXCCALLS)\n#define LUAI_MAXCCALLS\t\t20\n#endif\n\n \n#define LUAI_MINCSTACK\t\t4096\n\n \n#define MAXUPVAL\tUCHAR_MAX\n\n\n \ntypedef lu_int32 Instruction;\n\n\n\n \n#define MAXSTACK\t250\n\n\n\n \n#if !defined(MINSTRTABSIZE)\n#define MINSTRTABSIZE\t32\n#endif\n\n\n \n#if !defined(LUA_MINBUFFER)\n#define LUA_MINBUFFER\t32\n#endif\n\n\n#if !defined(lua_lock)\n#define lua_lock(L)     ((void) 0)\n#define lua_unlock(L)   ((void) 0)\n#endif\n\n#if !defined(luai_threadyield)\n#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}\n#endif\n\n\n \n#if !defined(luai_userstateopen)\n#define luai_userstateopen(L)\t\t((void)L)\n#endif\n\n#if !defined(luai_userstateclose)\n#define luai_userstateclose(L)\t\t((void)L)\n#endif\n\n#if !defined(luai_userstatethread)\n#define luai_userstatethread(L,L1)\t((void)L)\n#endif\n\n#if !defined(luai_userstatefree)\n#define luai_userstatefree(L,L1)\t((void)L)\n#endif\n\n#if !defined(luai_userstateresume)\n#define luai_userstateresume(L,n)       ((void)L)\n#endif\n\n#if !defined(luai_userstateyield)\n#define luai_userstateyield(L,n)        ((void)L)\n#endif\n\n \n\n#if defined(MS_ASMTRICK) || defined(LUA_MSASMTRICK)\t \n \n\n#define lua_number2int(i,n)  __asm {__asm fld n   __asm fistp i}\n#define lua_number2integer(i,n)\t\tlua_number2int(i, n)\n#define lua_number2unsigned(i,n)  \\\n  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}\n\n\n#elif defined(LUA_IEEE754TRICK)\t\t \n \n\nunion luai_Cast { double l_d; LUA_INT32 l_p[2]; };\n\n#if !defined(LUA_IEEEENDIAN)\t \n#define LUAI_EXTRAIEEE\t\\\n  static const union luai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};\n#define LUA_IEEEENDIANLOC\t(ieeeendian.l_p[1] == 33)\n#else\n#define LUA_IEEEENDIANLOC\tLUA_IEEEENDIAN\n#define LUAI_EXTRAIEEE\t\t \n#endif\t\t\t\t \n\n#define lua_number2int32(i,n,t) \\\n  { LUAI_EXTRAIEEE \\\n    volatile union luai_Cast u; u.l_d = (n) + 6755399441055744.0; \\\n    (i) = (t)u.l_p[LUA_IEEEENDIANLOC]; }\n\n#define luai_hashnum(i,n)  \\\n  { volatile union luai_Cast u; u.l_d = (n) + 1.0;    \\\n    (i) = u.l_p[0]; (i) += u.l_p[1]; }   \n\n#define lua_number2int(i,n)\t\tlua_number2int32(i, n, int)\n#define lua_number2unsigned(i,n)\tlua_number2int32(i, n, lua_Unsigned)\n\n \n#if defined(LUA_IEEELL)\n#define lua_number2integer(i,n)\t\tlua_number2int32(i, n, lua_Integer)\n#endif\n\n#endif\t\t\t\t \n\n\n \n\n#if !defined(lua_number2int)\n#define lua_number2int(i,n)\t((i)=(int)(n))\n#endif\n\n#if !defined(lua_number2integer)\n#define lua_number2integer(i,n)\t((i)=(lua_Integer)(n))\n#endif\n\n#if !defined(lua_number2unsigned)\t \n \n#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_NUMBER_FLOAT)\n#include <math.h>\n#define SUPUNSIGNED\t((lua_Number)(~(lua_Unsigned)0) + 1)\n#define lua_number2unsigned(i,n)  \\\n\t((i)=(lua_Unsigned)((n) - floor((n)/SUPUNSIGNED)*SUPUNSIGNED))\n#else\n#define lua_number2unsigned(i,n)\t((i)=(lua_Unsigned)(n))\n#endif\n#endif\t\t\t\t \n\n\n#if !defined(lua_unsigned2number)\n \n#define lua_unsigned2number(u)  \\\n    (((u) <= (lua_Unsigned)INT_MAX) ? (lua_Number)(int)(u) : (lua_Number)(u))\n#endif\n\n\n\n#if defined(ltable_c) && !defined(luai_hashnum)\n\n#define luai_hashnum(i,n) (i = lcompat_hashnum(n))\n\n#endif\n\n\n\n \n#if !defined(HARDSTACKTESTS)\n#define condmovestack(L)\t((void)0)\n#else\n \n#define condmovestack(L)\tluaD_reallocstack((L), (L)->stacksize)\n#endif\n\n#if !defined(HARDMEMTESTS)\n#define condchangemem(L)\tcondmovestack(L)\n#else\n#define condchangemem(L)  \\\n\t((void)(!(G(L)->gcrunning) || (luaC_fullgc(L, 0), 1)))\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}