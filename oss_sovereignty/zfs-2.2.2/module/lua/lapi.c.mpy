{
  "module_name": "lapi.c",
  "hash_id": "b3b8c48072d50b2a48a945969178808abe23679132a254636d0d8265217bd280",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lapi.c",
  "human_readable_source": " \n\n\n#define lapi_c\n#define LUA_CORE\n\n#include <sys/lua/lua.h>\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\nconst char lua_ident[] =\n  \"$LuaVersion: \" LUA_COPYRIGHT \" $\"\n  \"$LuaAuthors: \" LUA_AUTHORS \" $\";\n\n\n \n#define NONVALIDVALUE\t\tcast(TValue *, luaO_nilobject)\n\n \n#define isvalid(o)\t((o) != luaO_nilobject)\n\n \n#define ispseudo(i)\t\t((i) <= LUA_REGISTRYINDEX)\n\n \n#define isstackindex(i, o)\t(isvalid(o) && !ispseudo(i))\n\n#define api_checkvalidindex(L, o)  api_check(L, isvalid(o), \"invalid index\")\n\n#define api_checkstackindex(L, i, o)  \\\n\tapi_check(L, isstackindex(i, o), \"index not in the stack\")\n\n\nstatic TValue *index2addr (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    TValue *o = ci->func + idx;\n    api_check(L, idx <= ci->top - (ci->func + 1), \"unacceptable index\");\n    if (o >= L->top) return NONVALIDVALUE;\n    else return o;\n  }\n  else if (!ispseudo(idx)) {   \n    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), \"invalid index\");\n    return L->top + idx;\n  }\n  else if (idx == LUA_REGISTRYINDEX)\n    return &G(L)->l_registry;\n  else {   \n    idx = LUA_REGISTRYINDEX - idx;\n    api_check(L, idx <= MAXUPVAL + 1, \"upvalue index too large\");\n    if (ttislcf(ci->func))   \n      return NONVALIDVALUE;   \n    else {\n      CClosure *func = clCvalue(ci->func);\n      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;\n    }\n  }\n}\n\n\n \nstatic void growstack (lua_State *L, void *ud) {\n  int size = *(int *)ud;\n  luaD_growstack(L, size);\n}\n\n\nLUA_API int lua_checkstack (lua_State *L, int size) {\n  int res;\n  CallInfo *ci = L->ci;\n  lua_lock(L);\n  if (L->stack_last - L->top > size)   \n    res = 1;   \n  else {   \n    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;\n    if (inuse > LUAI_MAXSTACK - size)   \n      res = 0;   \n    else   \n      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);\n  }\n  if (res && ci->top < L->top + size)\n    ci->top = L->top + size;   \n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {\n  int i;\n  if (from == to) return;\n  lua_lock(to);\n  api_checknelems(from, n);\n  api_check(from, G(from) == G(to), \"moving among independent states\");\n  api_check(from, to->ci->top - to->top >= n, \"not enough elements to move\");\n  from->top -= n;\n  for (i = 0; i < n; i++) {\n    setobj2s(to, to->top++, from->top + i);\n  }\n  lua_unlock(to);\n}\n\n\nLUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {\n  lua_CFunction old;\n  lua_lock(L);\n  old = G(L)->panic;\n  G(L)->panic = panicf;\n  lua_unlock(L);\n  return old;\n}\n\n\nLUA_API const lua_Number *lua_version (lua_State *L) {\n  static const lua_Number version = LUA_VERSION_NUM;\n  if (L == NULL) return &version;\n  else return G(L)->version;\n}\n\n\n\n \n\n\n \nLUA_API int lua_absindex (lua_State *L, int idx) {\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top - L->ci->func + idx);\n}\n\n\nLUA_API int lua_gettop (lua_State *L) {\n  return cast_int(L->top - (L->ci->func + 1));\n}\n\n\nLUA_API void lua_settop (lua_State *L, int idx) {\n  StkId func = L->ci->func;\n  lua_lock(L);\n  if (idx >= 0) {\n    api_check(L, idx <= L->stack_last - (func + 1), \"new top too large\");\n    while (L->top < (func + 1) + idx)\n      setnilvalue(L->top++);\n    L->top = (func + 1) + idx;\n  }\n  else {\n    api_check(L, -(idx+1) <= (L->top - (func + 1)), \"invalid new top\");\n    L->top += idx+1;   \n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_remove (lua_State *L, int idx) {\n  StkId p;\n  lua_lock(L);\n  p = index2addr(L, idx);\n  api_checkstackindex(L, idx, p);\n  while (++p < L->top) setobjs2s(L, p-1, p);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_insert (lua_State *L, int idx) {\n  StkId p;\n  StkId q;\n  lua_lock(L);\n  p = index2addr(L, idx);\n  api_checkstackindex(L, idx, p);\n  for (q = L->top; q > p; q--)   \n    setobjs2s(L, q, q - 1);\n  setobjs2s(L, p, L->top);\n  lua_unlock(L);\n}\n\n\nstatic void moveto (lua_State *L, TValue *fr, int idx) {\n  TValue *to = index2addr(L, idx);\n  api_checkvalidindex(L, to);\n  setobj(L, to, fr);\n  if (idx < LUA_REGISTRYINDEX)   \n    luaC_barrier(L, clCvalue(L->ci->func), fr);\n   \n}\n\n\nLUA_API void lua_replace (lua_State *L, int idx) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  moveto(L, L->top - 1, idx);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {\n  TValue *fr;\n  lua_lock(L);\n  fr = index2addr(L, fromidx);\n  moveto(L, fr, toidx);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushvalue (lua_State *L, int idx) {\n  lua_lock(L);\n  setobj2s(L, L->top, index2addr(L, idx));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n\n \n\n\nLUA_API int lua_type (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);\n}\n\n\nLUA_API const char *lua_typename (lua_State *L, int t) {\n  UNUSED(L);\n  if (t > 8 || t < 0)\n    return \"internal_type_error\";\n  return ttypename(t);\n}\n\n\nLUA_API int lua_iscfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (ttislcf(o) || (ttisCclosure(o)));\n}\n\n\nLUA_API int lua_isnumber (lua_State *L, int idx) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  return tonumber(o, &n);\n}\n\n\nLUA_API int lua_isstring (lua_State *L, int idx) {\n  int t = lua_type(L, idx);\n  return (t == LUA_TSTRING || t == LUA_TNUMBER);\n}\n\n\nLUA_API int lua_isuserdata (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return (ttisuserdata(o) || ttislightuserdata(o));\n}\n\n\nLUA_API int lua_rawequal (lua_State *L, int index1, int index2) {\n  StkId o1 = index2addr(L, index1);\n  StkId o2 = index2addr(L, index2);\n  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;\n}\n\n\nLUA_API void lua_arith (lua_State *L, int op) {\n  StkId o1;   \n  StkId o2;   \n  lua_lock(L);\n  if (op != LUA_OPUNM)  \n    api_checknelems(L, 2);\n  else {   \n    api_checknelems(L, 1);\n    setobjs2s(L, L->top, L->top - 1);\n    L->top++;\n  }\n  o1 = L->top - 2;\n  o2 = L->top - 1;\n  if (ttisnumber(o1) && ttisnumber(o2)) {\n    setnvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));\n  }\n  else\n    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {\n  StkId o1, o2;\n  int i = 0;\n  lua_lock(L);   \n  o1 = index2addr(L, index1);\n  o2 = index2addr(L, index2);\n  if (isvalid(o1) && isvalid(o2)) {\n    switch (op) {\n      case LUA_OPEQ: i = equalobj(L, o1, o2); break;\n      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;\n      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;\n      default: api_check(L, 0, \"invalid option\");\n    }\n  }\n  lua_unlock(L);\n  return i;\n}\n\n\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  if (tonumber(o, &n)) {\n    if (isnum) *isnum = 1;\n    return nvalue(o);\n  }\n  else {\n    if (isnum) *isnum = 0;\n    return 0;\n  }\n}\n\n\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  if (tonumber(o, &n)) {\n    lua_Integer res;\n    lua_Number num = nvalue(o);\n    lua_number2integer(res, num);\n    if (isnum) *isnum = 1;\n    return res;\n  }\n  else {\n    if (isnum) *isnum = 0;\n    return 0;\n  }\n}\n\n\nLUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {\n  TValue n;\n  const TValue *o = index2addr(L, idx);\n  if (tonumber(o, &n)) {\n    lua_Unsigned res;\n    lua_Number num = nvalue(o);\n    lua_number2unsigned(res, num);\n    if (isnum) *isnum = 1;\n    return res;\n  }\n  else {\n    if (isnum) *isnum = 0;\n    return 0;\n  }\n}\n\n\nLUA_API int lua_toboolean (lua_State *L, int idx) {\n  const TValue *o = index2addr(L, idx);\n  return !l_isfalse(o);\n}\n\n\nLUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {\n  StkId o = index2addr(L, idx);\n  if (!ttisstring(o)) {\n    lua_lock(L);   \n    if (!luaV_tostring(L, o)) {   \n      if (len != NULL) *len = 0;\n      lua_unlock(L);\n      return NULL;\n    }\n    luaC_checkGC(L);\n    o = index2addr(L, idx);   \n    lua_unlock(L);\n  }\n  if (len != NULL) *len = tsvalue(o)->len;\n  return svalue(o);\n}\n\n\nLUA_API size_t lua_rawlen (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttypenv(o)) {\n    case LUA_TSTRING: return tsvalue(o)->len;\n    case LUA_TUSERDATA: return uvalue(o)->len;\n    case LUA_TTABLE: return luaH_getn(hvalue(o));\n    default: return 0;\n  }\n}\n\n\nLUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  if (ttislcf(o)) return fvalue(o);\n  else if (ttisCclosure(o))\n    return clCvalue(o)->f;\n  else return NULL;   \n}\n\n\nLUA_API void *lua_touserdata (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttypenv(o)) {\n    case LUA_TUSERDATA: return ((void *)(rawuvalue(o) + 1));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\nLUA_API lua_State *lua_tothread (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  return (!ttisthread(o)) ? NULL : thvalue(o);\n}\n\n\nLUA_API const void *lua_topointer (lua_State *L, int idx) {\n  StkId o = index2addr(L, idx);\n  switch (ttype(o)) {\n    case LUA_TTABLE: return hvalue(o);\n    case LUA_TLCL: return clLvalue(o);\n    case LUA_TCCL: return clCvalue(o);\n    case LUA_TLCF: return cast(void *, cast(uintptr_t, fvalue(o)));\n    case LUA_TTHREAD: return thvalue(o);\n    case LUA_TUSERDATA:\n    case LUA_TLIGHTUSERDATA:\n      return lua_touserdata(L, idx);\n    default: return NULL;\n  }\n}\n\n\n\n \n\n\nLUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n) {\n  lua_lock(L);\n  setnvalue(L->top, n);\n  luai_checknum(L, L->top,\n    luaG_runerror(L, \"C API - attempt to push a signaling NaN\"));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {\n  lua_lock(L);\n  setnvalue(L->top, cast_num(n));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {\n  lua_Number n;\n  lua_lock(L);\n  n = lua_unsigned2number(u);\n  setnvalue(L->top, n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {\n  TString *ts;\n  lua_lock(L);\n  luaC_checkGC(L);\n  ts = luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top, ts);\n  api_incr_top(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushstring (lua_State *L, const char *s) {\n  if (s == NULL) {\n    lua_pushnil(L);\n    return NULL;\n  }\n  else {\n    TString *ts;\n    lua_lock(L);\n    luaC_checkGC(L);\n    ts = luaS_new(L, s);\n    setsvalue2s(L, L->top, ts);\n    api_incr_top(L);\n    lua_unlock(L);\n    return getstr(ts);\n  }\n}\n\n\nLUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,\n                                      va_list argp) {\n  const char *ret;\n  lua_lock(L);\n  luaC_checkGC(L);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *ret;\n  va_list argp;\n  lua_lock(L);\n  luaC_checkGC(L);\n  va_start(argp, fmt);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {\n  lua_lock(L);\n  if (n == 0) {\n    setfvalue(L->top, fn);\n  }\n  else {\n    Closure *cl;\n    api_checknelems(L, n);\n    api_check(L, n <= MAXUPVAL, \"upvalue index too large\");\n    luaC_checkGC(L);\n    cl = luaF_newCclosure(L, n);\n    cl->c.f = fn;\n    L->top -= n;\n    while (n--)\n      setobj2n(L, &cl->c.upvalue[n], L->top + n);\n    setclCvalue(L, L->top, cl);\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushboolean (lua_State *L, int b) {\n  lua_lock(L);\n  setbvalue(L->top, (b != 0));   \n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(L->top, p);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_pushthread (lua_State *L) {\n  lua_lock(L);\n  setthvalue(L, L->top, L);\n  api_incr_top(L);\n  lua_unlock(L);\n  return (G(L)->mainthread == L);\n}\n\n\n\n \n\n\nLUA_API void lua_getglobal (lua_State *L, const char *var) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  const TValue *gt;   \n  lua_lock(L);\n  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n  setsvalue2s(L, L->top++, luaS_new(L, var));\n  luaV_gettable(L, gt, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_gettable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_getfield (lua_State *L, int idx, const char *k) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  setsvalue2s(L, L->top, luaS_new(L, k));\n  api_incr_top(L);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawget (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawgeti (lua_State *L, int idx, int n) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2s(L, L->top, luaH_getint(hvalue(t), n));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {\n  StkId t;\n  TValue k;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  setobj2s(L, L->top, luaH_get(hvalue(t), &k));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_createtable (lua_State *L, int narray, int nrec) {\n  Table *t;\n  lua_lock(L);\n  luaC_checkGC(L);\n  t = luaH_new(L);\n  sethvalue(L, L->top, t);\n  api_incr_top(L);\n  if (narray > 0 || nrec > 0)\n    luaH_resize(L, t, narray, nrec);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_getmetatable (lua_State *L, int objindex) {\n  const TValue *obj;\n  Table *mt = NULL;\n  int res;\n  lua_lock(L);\n  obj = index2addr(L, objindex);\n  switch (ttypenv(obj)) {\n    case LUA_TTABLE:\n      mt = hvalue(obj)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(obj)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttypenv(obj)];\n      break;\n  }\n  if (mt == NULL)\n    res = 0;\n  else {\n    sethvalue(L, L->top, mt);\n    api_incr_top(L);\n    res = 1;\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_getuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  o = index2addr(L, idx);\n  api_check(L, ttisuserdata(o), \"userdata expected\");\n  if (uvalue(o)->env) {\n    sethvalue(L, L->top, uvalue(o)->env);\n  } else\n    setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n \n\n\nLUA_API void lua_setglobal (lua_State *L, const char *var) {\n  Table *reg = hvalue(&G(L)->l_registry);\n  const TValue *gt;   \n  lua_lock(L);\n  api_checknelems(L, 1);\n  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n  setsvalue2s(L, L->top++, luaS_new(L, var));\n  luaV_settable(L, gt, L->top - 1, L->top - 2);\n  L->top -= 2;   \n  lua_unlock(L);\n}\n\n\nLUA_API void lua_settable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2addr(L, idx);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;   \n  lua_unlock(L);\n}\n\n\nLUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  setsvalue2s(L, L->top++, luaS_new(L, k));\n  luaV_settable(L, t, L->top - 1, L->top - 2);\n  L->top -= 2;   \n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawset (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);\n  invalidateTMcache(hvalue(t));\n  luaC_barrierback(L, gcvalue(t), L->top-1);\n  L->top -= 2;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawseti (lua_State *L, int idx, int n) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  luaH_setint(L, hvalue(t), n, L->top - 1);\n  luaC_barrierback(L, gcvalue(t), L->top-1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {\n  StkId t;\n  TValue k;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  setpvalue(&k, cast(void *, p));\n  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);\n  luaC_barrierback(L, gcvalue(t), L->top - 1);\n  L->top--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  obj = index2addr(L, objindex);\n  if (ttisnil(L->top - 1))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1), \"table expected\");\n    mt = hvalue(L->top - 1);\n  }\n  switch (ttypenv(obj)) {\n    case LUA_TTABLE: {\n      hvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrierback(L, gcvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, rawuvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    default: {\n      G(L)->mt[ttypenv(obj)] = mt;\n      break;\n    }\n  }\n  L->top--;\n  lua_unlock(L);\n  return 1;\n}\n\n\nLUA_API void lua_setuservalue (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2addr(L, idx);\n  api_check(L, ttisuserdata(o), \"userdata expected\");\n  if (ttisnil(L->top - 1))\n    uvalue(o)->env = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1), \"table expected\");\n    uvalue(o)->env = hvalue(L->top - 1);\n    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));\n  }\n  L->top--;\n  lua_unlock(L);\n}\n\n\n \n\n\n#define checkresults(L,na,nr) \\\n     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \\\n\t\"results from function overflow current stack size\")\n\n\nLUA_API int lua_getctx (lua_State *L, int *ctx) {\n  if (L->ci->callstatus & CIST_YIELDED) {\n    if (ctx) *ctx = L->ci->u.c.ctx;\n    return L->ci->u.c.status;\n  }\n  else return LUA_OK;\n}\n\n\nLUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,\n                        lua_CFunction k) {\n  StkId func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  func = L->top - (nargs+1);\n  if (k != NULL && L->nny == 0) {   \n    L->ci->u.c.k = k;   \n    L->ci->u.c.ctx = ctx;   \n    luaD_call(L, func, nresults, 1);   \n  }\n  else   \n    luaD_call(L, func, nresults, 0);   \n  adjustresults(L, nresults);\n  lua_unlock(L);\n}\n\n\n\n \nstruct CallS {   \n  StkId func;\n  int nresults;\n};\n\n\nstatic void f_call (lua_State *L, void *ud) {\n  struct CallS *c = cast(struct CallS *, ud);\n  luaD_call(L, c->func, c->nresults, 0);\n}\n\n\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        int ctx, lua_CFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2addr(L, errfunc);\n    api_checkstackindex(L, errfunc, o);\n    func = savestack(L, o);\n  }\n  c.func = L->top - (nargs+1);   \n  if (k == NULL || L->nny > 0) {   \n    c.nresults = nresults;   \n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {   \n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;   \n    ci->u.c.ctx = ctx;   \n     \n    ci->extra = savestack(L, c.func);\n    ci->u.c.old_allowhook = L->allowhook;\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n     \n    ci->callstatus |= CIST_YPCALL;\n    luaD_call(L, c.func, nresults, 1);   \n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;   \n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,\n                      const char *chunkname, const char *mode) {\n  ZIO z;\n  int status;\n  lua_lock(L);\n  if (!chunkname) chunkname = \"?\";\n  luaZ_init(L, &z, reader, data);\n  status = luaD_protectedparser(L, &z, chunkname, mode);\n  if (status == LUA_OK) {   \n    LClosure *f = clLvalue(L->top - 1);   \n    if (f->nupvalues == 1) {   \n       \n      Table *reg = hvalue(&G(L)->l_registry);\n      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);\n       \n      setobj(L, f->upvals[0]->v, gt);\n      luaC_barrier(L, f->upvals[0], gt);\n    }\n  }\n  lua_unlock(L);\n  return status;\n}\n\n#if defined(LUA_USE_DUMP)\nLUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {\n  int status;\n  TValue *o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = L->top - 1;\n  if (isLfunction(o))\n    status = luaU_dump(L, getproto(o), writer, data, 0);\n  else\n    status = 1;\n  lua_unlock(L);\n  return status;\n}\n#endif\n\nLUA_API int lua_status (lua_State *L) {\n  return L->status;\n}\n\n\n \n\nLUA_API int lua_gc (lua_State *L, int what, int data) {\n  int res = 0;\n  global_State *g;\n  lua_lock(L);\n  g = G(L);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->gcrunning = 0;\n      break;\n    }\n    case LUA_GCRESTART: {\n      luaE_setdebt(g, 0);\n      g->gcrunning = 1;\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L, 0);\n      break;\n    }\n    case LUA_GCCOUNT: {\n       \n      res = cast_int(gettotalbytes(g) >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(gettotalbytes(g) & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      if (g->gckind == KGC_GEN) {   \n        res = (g->GCestimate == 0);   \n        luaC_forcestep(L);   \n      }\n      else {\n       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;\n       if (g->gcrunning)\n         debt += g->GCdebt;   \n       luaE_setdebt(g, debt);\n       luaC_forcestep(L);\n       if (g->gcstate == GCSpause)   \n         res = 1;   \n      }\n      break;\n    }\n    case LUA_GCSETPAUSE: {\n      res = g->gcpause;\n      g->gcpause = data;\n      break;\n    }\n    case LUA_GCSETMAJORINC: {\n      res = g->gcmajorinc;\n      g->gcmajorinc = data;\n      break;\n    }\n    case LUA_GCSETSTEPMUL: {\n      res = g->gcstepmul;\n      g->gcstepmul = data;\n      break;\n    }\n    case LUA_GCISRUNNING: {\n      res = g->gcrunning;\n      break;\n    }\n    case LUA_GCGEN: {   \n      luaC_changemode(L, KGC_GEN);\n      break;\n    }\n    case LUA_GCINC: {   \n      luaC_changemode(L, KGC_NORMAL);\n      break;\n    }\n    default: res = -1;   \n  }\n  lua_unlock(L);\n  return res;\n}\n\n\n\n \n\n\nLUA_API int lua_error (lua_State *L) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n   \n  return 0;   \n}\n\n\nLUA_API int lua_next (lua_State *L, int idx) {\n  StkId t;\n  int more;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  more = luaH_next(L, hvalue(t), L->top - 1);\n  if (more) {\n    api_incr_top(L);\n  }\n  else   \n    L->top -= 1;   \n  lua_unlock(L);\n  return more;\n}\n\n\nLUA_API void lua_concat (lua_State *L, int n) {\n  lua_lock(L);\n  api_checknelems(L, n);\n  if (n >= 2) {\n    luaC_checkGC(L);\n    luaV_concat(L, n);\n  }\n  else if (n == 0) {   \n    setsvalue2s(L, L->top, luaS_newlstr(L, \"\", 0));\n    api_incr_top(L);\n  }\n   \n  lua_unlock(L);\n}\n\n\nLUA_API void lua_len (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2addr(L, idx);\n  luaV_objlen(L, L->top, t);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {\n  lua_Alloc f;\n  lua_lock(L);\n  if (ud) *ud = G(L)->ud;\n  f = G(L)->frealloc;\n  lua_unlock(L);\n  return f;\n}\n\n\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {\n  lua_lock(L);\n  G(L)->ud = ud;\n  G(L)->frealloc = f;\n  lua_unlock(L);\n}\n\n\nLUA_API void *lua_newuserdata (lua_State *L, size_t size) {\n  Udata *u;\n  lua_lock(L);\n  luaC_checkGC(L);\n  u = luaS_newudata(L, size, NULL);\n  setuvalue(L, L->top, u);\n  api_incr_top(L);\n  lua_unlock(L);\n  return u + 1;\n}\n\n\n\nstatic const char *aux_upvalue (StkId fi, int n, TValue **val,\n                                GCObject **owner) {\n  switch (ttype(fi)) {\n    case LUA_TCCL: {   \n      CClosure *f = clCvalue(fi);\n      if (!(1 <= n && n <= f->nupvalues)) return NULL;\n      *val = &f->upvalue[n-1];\n      if (owner) *owner = obj2gco(f);\n      return \"\";\n    }\n    case LUA_TLCL: {   \n      LClosure *f = clLvalue(fi);\n      TString *name;\n      Proto *p = f->p;\n      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;\n      *val = f->upvals[n-1]->v;\n      if (owner) *owner = obj2gco(f->upvals[n - 1]);\n      name = p->upvalues[n-1].name;\n      return (name == NULL) ? \"\" : getstr(name);\n    }\n    default: return NULL;   \n  }\n}\n\n\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;   \n  lua_lock(L);\n  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);\n  if (name) {\n    setobj2s(L, L->top, val);\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;   \n  GCObject *owner = NULL;   \n  StkId fi;\n  lua_lock(L);\n  fi = index2addr(L, funcindex);\n  api_checknelems(L, 1);\n  name = aux_upvalue(fi, n, &val, &owner);\n  if (name) {\n    L->top--;\n    setobj(L, val, L->top);\n    luaC_barrier(L, owner, L->top);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];   \n}\n\n\nLUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {   \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {   \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}\n\n\nLUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  *up1 = *up2;\n  luaC_objbarrier(L, f1, *up2);\n}\n\nEXPORT_SYMBOL(lua_absindex);\nEXPORT_SYMBOL(lua_atpanic);\nEXPORT_SYMBOL(lua_checkstack);\nEXPORT_SYMBOL(lua_close);\nEXPORT_SYMBOL(lua_createtable);\nEXPORT_SYMBOL(lua_error);\nEXPORT_SYMBOL(lua_getfield);\nEXPORT_SYMBOL(lua_gettable);\nEXPORT_SYMBOL(lua_gettop);\nEXPORT_SYMBOL(lua_isnumber);\nEXPORT_SYMBOL(lua_isstring);\nEXPORT_SYMBOL(lua_newstate);\nEXPORT_SYMBOL(lua_newuserdata);\nEXPORT_SYMBOL(lua_next);\nEXPORT_SYMBOL(lua_pcallk);\nEXPORT_SYMBOL(lua_pushboolean);\nEXPORT_SYMBOL(lua_pushcclosure);\nEXPORT_SYMBOL(lua_pushfstring);\nEXPORT_SYMBOL(lua_pushinteger);\nEXPORT_SYMBOL(lua_pushlightuserdata);\nEXPORT_SYMBOL(lua_pushnil);\nEXPORT_SYMBOL(lua_pushnumber);\nEXPORT_SYMBOL(lua_pushstring);\nEXPORT_SYMBOL(lua_pushvalue);\nEXPORT_SYMBOL(lua_pushvfstring);\nEXPORT_SYMBOL(lua_remove);\nEXPORT_SYMBOL(lua_replace);\nEXPORT_SYMBOL(lua_setfield);\nEXPORT_SYMBOL(lua_setglobal);\nEXPORT_SYMBOL(lua_sethook);\nEXPORT_SYMBOL(lua_setmetatable);\nEXPORT_SYMBOL(lua_settable);\nEXPORT_SYMBOL(lua_settop);\nEXPORT_SYMBOL(lua_toboolean);\nEXPORT_SYMBOL(lua_tointegerx);\nEXPORT_SYMBOL(lua_tolstring);\nEXPORT_SYMBOL(lua_tonumberx);\nEXPORT_SYMBOL(lua_touserdata);\nEXPORT_SYMBOL(lua_type);\nEXPORT_SYMBOL(lua_typename);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}