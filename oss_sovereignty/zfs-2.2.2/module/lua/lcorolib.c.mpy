{
  "module_name": "lcorolib.c",
  "hash_id": "01abcf2aa8b9121432093cffa81cd4dc2e8c5aa3e50e639b2661c28f87918183",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lcorolib.c",
  "human_readable_source": " \n\n\n#define lcorolib_c\n#define LUA_LIB\n\n#include <sys/lua/lua.h>\n\n#include <sys/lua/lauxlib.h>\n#include <sys/lua/lualib.h>\n\n\nstatic int auxresume (lua_State *L, lua_State *co, int narg) {\n  int status;\n  if (!lua_checkstack(co, narg)) {\n    lua_pushliteral(L, \"too many arguments to resume\");\n    return -1;   \n  }\n  if (lua_status(co) == LUA_OK && lua_gettop(co) == 0) {\n    lua_pushliteral(L, \"cannot resume dead coroutine\");\n    return -1;   \n  }\n  lua_xmove(L, co, narg);\n  status = lua_resume(co, L, narg);\n  if (status == LUA_OK || status == LUA_YIELD) {\n    int nres = lua_gettop(co);\n    if (!lua_checkstack(L, nres + 1)) {\n      lua_pop(co, nres);   \n      lua_pushliteral(L, \"too many results to resume\");\n      return -1;   \n    }\n    lua_xmove(co, L, nres);   \n    return nres;\n  }\n  else {\n    lua_xmove(co, L, 1);   \n    return -1;   \n  }\n}\n\n\nstatic int luaB_coresume (lua_State *L) {\n  lua_State *co = lua_tothread(L, 1);\n  int r;\n  luaL_argcheck(L, co, 1, \"coroutine expected\");\n  r = auxresume(L, co, lua_gettop(L) - 1);\n  if (r < 0) {\n    lua_pushboolean(L, 0);\n    lua_insert(L, -2);\n    return 2;   \n  }\n  else {\n    lua_pushboolean(L, 1);\n    lua_insert(L, -(r + 1));\n    return r + 1;   \n  }\n}\n\n\nstatic int luaB_auxwrap (lua_State *L) {\n  lua_State *co = lua_tothread(L, lua_upvalueindex(1));\n  int r = auxresume(L, co, lua_gettop(L));\n  if (r < 0) {\n    if (lua_isstring(L, -1)) {   \n      luaL_where(L, 1);   \n      lua_insert(L, -2);\n      lua_concat(L, 2);\n    }\n    return lua_error(L);   \n  }\n  return r;\n}\n\n\nstatic int luaB_cocreate (lua_State *L) {\n  lua_State *NL;\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  NL = lua_newthread(L);\n  lua_pushvalue(L, 1);   \n  lua_xmove(L, NL, 1);   \n  return 1;\n}\n\n\nstatic int luaB_cowrap (lua_State *L) {\n  luaB_cocreate(L);\n  lua_pushcclosure(L, luaB_auxwrap, 1);\n  return 1;\n}\n\n\nstatic int luaB_yield (lua_State *L) {\n  return lua_yield(L, lua_gettop(L));\n}\n\n\nstatic int luaB_costatus (lua_State *L) {\n  lua_State *co = lua_tothread(L, 1);\n  luaL_argcheck(L, co, 1, \"coroutine expected\");\n  if (L == co) lua_pushliteral(L, \"running\");\n  else {\n    switch (lua_status(co)) {\n      case LUA_YIELD:\n        lua_pushliteral(L, \"suspended\");\n        break;\n      case LUA_OK: {\n        lua_Debug ar;\n        if (lua_getstack(co, 0, &ar) > 0)   \n          lua_pushliteral(L, \"normal\");   \n        else if (lua_gettop(co) == 0)\n            lua_pushliteral(L, \"dead\");\n        else\n          lua_pushliteral(L, \"suspended\");   \n        break;\n      }\n      default:   \n        lua_pushliteral(L, \"dead\");\n        break;\n    }\n  }\n  return 1;\n}\n\n\nstatic int luaB_corunning (lua_State *L) {\n  int ismain = lua_pushthread(L);\n  lua_pushboolean(L, ismain);\n  return 2;\n}\n\n\nstatic const luaL_Reg co_funcs[] = {\n  {\"create\", luaB_cocreate},\n  {\"resume\", luaB_coresume},\n  {\"running\", luaB_corunning},\n  {\"status\", luaB_costatus},\n  {\"wrap\", luaB_cowrap},\n  {\"yield\", luaB_yield},\n  {NULL, NULL}\n};\n\n\n\nLUAMOD_API int luaopen_coroutine (lua_State *L) {\n  luaL_newlib(L, co_funcs);\n  return 1;\n}\n\n#if defined(_KERNEL)\n\nEXPORT_SYMBOL(luaopen_coroutine);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}