{
  "module_name": "ltablib.c",
  "hash_id": "0882d2b0ee6dea5f9d1bfe7e578c8208983e52a096ae1f3f4b91c7c257fc1b2f",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/ltablib.c",
  "human_readable_source": " \n\n\n#define ltablib_c\n#define LUA_LIB\n\n#include <sys/lua/lua.h>\n\n#include <sys/lua/lauxlib.h>\n#include <sys/lua/lualib.h>\n\n\n#define aux_getn(L,n)\t(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))\n\n\n\n#if defined(LUA_COMPAT_MAXN)\nstatic int maxn (lua_State *L) {\n  lua_Number max = 0;\n  luaL_checktype(L, 1, LUA_TTABLE);\n  lua_pushnil(L);   \n  while (lua_next(L, 1)) {\n    lua_pop(L, 1);   \n    if (lua_type(L, -1) == LUA_TNUMBER) {\n      lua_Number v = lua_tonumber(L, -1);\n      if (v > max) max = v;\n    }\n  }\n  lua_pushnumber(L, max);\n  return 1;\n}\n#endif\n\n\nstatic int tinsert (lua_State *L) {\n  int e = aux_getn(L, 1) + 1;   \n  int pos;   \n  switch (lua_gettop(L)) {\n    case 2: {   \n      pos = e;   \n      break;\n    }\n    case 3: {\n      int i;\n      pos = luaL_checkint(L, 2);   \n      luaL_argcheck(L, 1 <= pos && pos <= e, 2, \"position out of bounds\");\n      for (i = e; i > pos; i--) {   \n        lua_rawgeti(L, 1, i-1);\n        lua_rawseti(L, 1, i);   \n      }\n      break;\n    }\n    default: {\n      return luaL_error(L, \"wrong number of arguments to \" LUA_QL(\"insert\"));\n    }\n  }\n  lua_rawseti(L, 1, pos);   \n  return 0;\n}\n\n\nstatic int tremove (lua_State *L) {\n  int size = aux_getn(L, 1);\n  int pos = luaL_optint(L, 2, size);\n  if (pos != size)   \n    luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, \"position out of bounds\");\n  lua_rawgeti(L, 1, pos);   \n  for ( ; pos < size; pos++) {\n    lua_rawgeti(L, 1, pos+1);\n    lua_rawseti(L, 1, pos);   \n  }\n  lua_pushnil(L);\n  lua_rawseti(L, 1, pos);   \n  return 1;\n}\n\n\nstatic void addfield (lua_State *L, luaL_Buffer *b, int i) {\n  lua_rawgeti(L, 1, i);\n  if (!lua_isstring(L, -1))\n    luaL_error(L, \"invalid value (%s) at index %d in table for \"\n                  LUA_QL(\"concat\"), luaL_typename(L, -1), i);\n  luaL_addvalue(b);\n}\n\n\nstatic int tconcat (lua_State *L) {\n  luaL_Buffer b;\n  size_t lsep;\n  int i, last;\n  const char *sep = luaL_optlstring(L, 2, \"\", &lsep);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  i = luaL_optint(L, 3, 1);\n  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));\n  luaL_buffinit(L, &b);\n  for (; i < last; i++) {\n    addfield(L, &b, i);\n    luaL_addlstring(&b, sep, lsep);\n  }\n  if (i == last)   \n    addfield(L, &b, i);\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\n \n\nstatic int pack (lua_State *L) {\n  int n = lua_gettop(L);   \n  lua_createtable(L, n, 1);   \n  lua_pushinteger(L, n);\n  lua_setfield(L, -2, \"n\");   \n  if (n > 0) {   \n    int i;\n    lua_pushvalue(L, 1);\n    lua_rawseti(L, -2, 1);   \n    lua_replace(L, 1);   \n    for (i = n; i >= 2; i--)   \n      lua_rawseti(L, 1, i);\n  }\n  return 1;   \n}\n\n\nstatic int unpack (lua_State *L) {\n  int i, e;\n  unsigned int n;\n  luaL_checktype(L, 1, LUA_TTABLE);\n  i = luaL_optint(L, 2, 1);\n  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));\n  if (i > e) return 0;   \n  n = (unsigned int)e - (unsigned int)i;   \n  if (n > (INT_MAX - 10) || !lua_checkstack(L, ++n))\n    return luaL_error(L, \"too many results to unpack\");\n  lua_rawgeti(L, 1, i);   \n  while (i++ < e)   \n    lua_rawgeti(L, 1, i);\n  return n;\n}\n\n \n\n\n\n \n\n\nstatic void set2 (lua_State *L, int i, int j) {\n  lua_rawseti(L, 1, i);\n  lua_rawseti(L, 1, j);\n}\n\nstatic int sort_comp (lua_State *L, int a, int b) {\n  if (!lua_isnil(L, 2)) {   \n    int res;\n    lua_pushvalue(L, 2);\n    lua_pushvalue(L, a-1);   \n    lua_pushvalue(L, b-2);   \n    lua_call(L, 2, 1);\n    res = lua_toboolean(L, -1);\n    lua_pop(L, 1);\n    return res;\n  }\n  else   \n    return lua_compare(L, a, b, LUA_OPLT);\n}\n\nstatic void auxsort (lua_State *L, int l, int u) {\n  while (l < u) {   \n    int i, j;\n     \n    lua_rawgeti(L, 1, l);\n    lua_rawgeti(L, 1, u);\n    if (sort_comp(L, -1, -2))   \n      set2(L, l, u);   \n    else\n      lua_pop(L, 2);\n    if (u-l == 1) break;   \n    i = (l+u)/2;\n    lua_rawgeti(L, 1, i);\n    lua_rawgeti(L, 1, l);\n    if (sort_comp(L, -2, -1))   \n      set2(L, i, l);\n    else {\n      lua_pop(L, 1);   \n      lua_rawgeti(L, 1, u);\n      if (sort_comp(L, -1, -2))   \n        set2(L, i, u);\n      else\n        lua_pop(L, 2);\n    }\n    if (u-l == 2) break;   \n    lua_rawgeti(L, 1, i);   \n    lua_pushvalue(L, -1);\n    lua_rawgeti(L, 1, u-1);\n    set2(L, i, u-1);\n     \n    i = l; j = u-1;\n    for (;;) {   \n       \n      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {\n        if (i>=u) luaL_error(L, \"invalid order function for sorting\");\n        lua_pop(L, 1);   \n      }\n       \n      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {\n        if (j<=l) luaL_error(L, \"invalid order function for sorting\");\n        lua_pop(L, 1);   \n      }\n      if (j<i) {\n        lua_pop(L, 3);   \n        break;\n      }\n      set2(L, i, j);\n    }\n    lua_rawgeti(L, 1, u-1);\n    lua_rawgeti(L, 1, i);\n    set2(L, u-1, i);   \n     \n     \n    if (i-l < u-i) {\n      j=l; i=i-1; l=i+2;\n    }\n    else {\n      j=i+1; i=u; u=j-2;\n    }\n    auxsort(L, j, i);   \n  }   \n}\n\nstatic int tsort (lua_State *L) {\n  int n = aux_getn(L, 1);\n  luaL_checkstack(L, 40, \"\");   \n  if (!lua_isnoneornil(L, 2))   \n    luaL_checktype(L, 2, LUA_TFUNCTION);\n  lua_settop(L, 2);   \n  auxsort(L, 1, n);\n  return 0;\n}\n\n \n\n\nstatic const luaL_Reg tab_funcs[] = {\n  {\"concat\", tconcat},\n#if defined(LUA_COMPAT_MAXN)\n  {\"maxn\", maxn},\n#endif\n  {\"insert\", tinsert},\n  {\"pack\", pack},\n  {\"unpack\", unpack},\n  {\"remove\", tremove},\n  {\"sort\", tsort},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_table (lua_State *L) {\n  luaL_newlib(L, tab_funcs);\n#if defined(LUA_COMPAT_UNPACK)\n   \n  lua_getfield(L, -1, \"unpack\");\n  lua_setglobal(L, \"unpack\");\n#endif\n  return 1;\n}\n\n#if defined(_KERNEL)\n\nEXPORT_SYMBOL(luaopen_table);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}