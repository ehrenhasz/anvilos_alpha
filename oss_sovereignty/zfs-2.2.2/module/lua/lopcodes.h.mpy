{
  "module_name": "lopcodes.h",
  "hash_id": "a872cf1f5544f0883b6926d6d09fae066bafbae0553c34b4b30b454d2a0c8169",
  "original_prompt": "Ingested from zfs-2.2.2/module/lua/lopcodes.h",
  "human_readable_source": " \n\n#ifndef lopcodes_h\n#define lopcodes_h\n\n#include \"llimits.h\"\n\n\n \n\n\nenum OpMode {iABC, iABx, iAsBx, iAx};   \n\n\n \n#define SIZE_C\t\t9\n#define SIZE_B\t\t9\n#define SIZE_Bx\t\t(SIZE_C + SIZE_B)\n#define SIZE_A\t\t8\n#define SIZE_Ax\t\t(SIZE_C + SIZE_B + SIZE_A)\n\n#define SIZE_OP\t\t6\n\n#define POS_OP\t\t0\n#define POS_A\t\t(POS_OP + SIZE_OP)\n#define POS_C\t\t(POS_A + SIZE_A)\n#define POS_B\t\t(POS_C + SIZE_C)\n#define POS_Bx\t\tPOS_C\n#define POS_Ax\t\tPOS_A\n\n\n \n#if SIZE_Bx < LUAI_BITSINT-1\n#define MAXARG_Bx        ((1<<SIZE_Bx)-1)\n#define MAXARG_sBx        (MAXARG_Bx>>1)          \n#else\n#define MAXARG_Bx        MAX_INT\n#define MAXARG_sBx        MAX_INT\n#endif\n\n#if SIZE_Ax < LUAI_BITSINT-1\n#define MAXARG_Ax\t((1<<SIZE_Ax)-1)\n#else\n#define MAXARG_Ax\tMAX_INT\n#endif\n\n\n#define MAXARG_A        ((1<<SIZE_A)-1)\n#define MAXARG_B        ((1<<SIZE_B)-1)\n#define MAXARG_C        ((1<<SIZE_C)-1)\n\n\n \n#define MASK1(n,p)\t((~((~(Instruction)0)<<(n)))<<(p))\n\n \n#define MASK0(n,p)\t(~MASK1(n,p))\n\n \n\n#define GET_OPCODE(i)\t(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))\n#define SET_OPCODE(i,o)\t((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \\\n\t\t((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))\n\n#define getarg(i,pos,size)\t(cast(int, ((i)>>pos) & MASK1(size,0)))\n#define setarg(i,v,pos,size)\t((i) = (((i)&MASK0(size,pos)) | \\\n                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))\n\n#define GETARG_A(i)\tgetarg(i, POS_A, SIZE_A)\n#define SETARG_A(i,v)\tsetarg(i, v, POS_A, SIZE_A)\n\n#define GETARG_B(i)\tgetarg(i, POS_B, SIZE_B)\n#define SETARG_B(i,v)\tsetarg(i, v, POS_B, SIZE_B)\n\n#define GETARG_C(i)\tgetarg(i, POS_C, SIZE_C)\n#define SETARG_C(i,v)\tsetarg(i, v, POS_C, SIZE_C)\n\n#define GETARG_Bx(i)\tgetarg(i, POS_Bx, SIZE_Bx)\n#define SETARG_Bx(i,v)\tsetarg(i, v, POS_Bx, SIZE_Bx)\n\n#define GETARG_Ax(i)\tgetarg(i, POS_Ax, SIZE_Ax)\n#define SETARG_Ax(i,v)\tsetarg(i, v, POS_Ax, SIZE_Ax)\n\n#define GETARG_sBx(i)\t(GETARG_Bx(i)-MAXARG_sBx)\n#define SETARG_sBx(i,b)\tSETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))\n\n\n#define CREATE_ABC(o,a,b,c)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, b)<<POS_B) \\\n\t\t\t| (cast(Instruction, c)<<POS_C))\n\n#define CREATE_ABx(o,a,bc)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, bc)<<POS_Bx))\n\n#define CREATE_Ax(o,a)\t\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_Ax))\n\n\n \n\n \n#define BITRK\t\t(1 << (SIZE_B - 1))\n\n \n#define ISK(x)\t\t((x) & BITRK)\n\n \n#define INDEXK(r)\t((int)(r) & ~BITRK)\n\n#define MAXINDEXRK\t(BITRK - 1)\n\n \n#define RKASK(x)\t((x) | BITRK)\n\n\n \n#define NO_REG\t\tMAXARG_A\n\n\n \n\n\n \n\ntypedef enum {\n \nOP_MOVE, \nOP_LOADK, \nOP_LOADKX, \nOP_LOADBOOL, \nOP_LOADNIL, \nOP_GETUPVAL, \n\nOP_GETTABUP, \nOP_GETTABLE, \n\nOP_SETTABUP, \nOP_SETUPVAL, \nOP_SETTABLE, \n\nOP_NEWTABLE, \n\nOP_SELF, \n\nOP_ADD, \nOP_SUB, \nOP_MUL, \nOP_DIV, \nOP_MOD, \nOP_POW, \nOP_UNM, \nOP_NOT, \nOP_LEN, \n\nOP_CONCAT, \n\nOP_JMP, \nOP_EQ, \nOP_LT, \nOP_LE, \n\nOP_TEST, \nOP_TESTSET, \n\nOP_CALL, \nOP_TAILCALL, \nOP_RETURN, \n\nOP_FORLOOP, \nOP_FORPREP, \n\nOP_TFORCALL, \nOP_TFORLOOP, \n\nOP_SETLIST, \n\nOP_CLOSURE, \n\nOP_VARARG, \n\nOP_EXTRAARG \n} OpCode;\n\n\n#define NUM_OPCODES\t(cast(int, OP_EXTRAARG) + 1)\n\n\n\n \n\n\n \n\nenum OpArgMask {\n  OpArgN,   \n  OpArgU,   \n  OpArgR,   \n  OpArgK    \n};\n\nLUAI_DDEC const lu_byte luaP_opmodes[NUM_OPCODES];\n\n#define getOpMode(m)\t(cast(enum OpMode, luaP_opmodes[m] & 3))\n#define getBMode(m)\t(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))\n#define getCMode(m)\t(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))\n#define testAMode(m)\t(luaP_opmodes[m] & (1 << 6))\n#define testTMode(m)\t(luaP_opmodes[m] & (1 << 7))\n\n\nLUAI_DDEC const char *const luaP_opnames[NUM_OPCODES+1];   \n\n\n \n#define LFIELDS_PER_FLUSH\t50\n\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}