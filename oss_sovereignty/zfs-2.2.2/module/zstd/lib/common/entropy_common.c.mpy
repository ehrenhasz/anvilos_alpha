{
  "module_name": "entropy_common.c",
  "hash_id": "17edfaaa184890a8a2d927b50170c6cbc1c8211fa584c7293e048a1de1ab35e5",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/common/entropy_common.c",
  "human_readable_source": " \n\n \n#include \"mem.h\"\n#include \"error_private.h\"        \n#define FSE_STATIC_LINKING_ONLY   \n#include \"fse.h\"\n#define HUF_STATIC_LINKING_ONLY   \n#include \"huf.h\"\n\n\n \nunsigned FSE_versionNumber(void) { return FSE_VERSION_NUMBER; }\n\n\n \nunsigned FSE_isError(size_t code) { return ERR_isError(code); }\nconst char* FSE_getErrorName(size_t code) { return ERR_getErrorName(code); }\n\nunsigned HUF_isError(size_t code) { return ERR_isError(code); }\nconst char* HUF_getErrorName(size_t code) { return ERR_getErrorName(code); }\n\n\n \nsize_t FSE_readNCount (short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n                 const void* headerBuffer, size_t hbSize)\n{\n    const BYTE* const istart = (const BYTE*) headerBuffer;\n    const BYTE* const iend = istart + hbSize;\n    const BYTE* ip = istart;\n    int nbBits;\n    int remaining;\n    int threshold;\n    U32 bitStream;\n    int bitCount;\n    unsigned charnum = 0;\n    int previous0 = 0;\n\n    if (hbSize < 4) {\n         \n        char buffer[4];\n        memset(buffer, 0, sizeof(buffer));\n        memcpy(buffer, headerBuffer, hbSize);\n        {   size_t const countSize = FSE_readNCount(normalizedCounter, maxSVPtr, tableLogPtr,\n                                                    buffer, sizeof(buffer));\n            if (FSE_isError(countSize)) return countSize;\n            if (countSize > hbSize) return ERROR(corruption_detected);\n            return countSize;\n    }   }\n    assert(hbSize >= 4);\n\n     \n    memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]));    \n    bitStream = MEM_readLE32(ip);\n    nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;    \n    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);\n    bitStream >>= 4;\n    bitCount = 4;\n    *tableLogPtr = nbBits;\n    remaining = (1<<nbBits)+1;\n    threshold = 1<<nbBits;\n    nbBits++;\n\n    while ((remaining>1) & (charnum<=*maxSVPtr)) {\n        if (previous0) {\n            unsigned n0 = charnum;\n            while ((bitStream & 0xFFFF) == 0xFFFF) {\n                n0 += 24;\n                if (ip < iend-5) {\n                    ip += 2;\n                    bitStream = MEM_readLE32(ip) >> bitCount;\n                } else {\n                    bitStream >>= 16;\n                    bitCount   += 16;\n            }   }\n            while ((bitStream & 3) == 3) {\n                n0 += 3;\n                bitStream >>= 2;\n                bitCount += 2;\n            }\n            n0 += bitStream & 3;\n            bitCount += 2;\n            if (n0 > *maxSVPtr) return ERROR(maxSymbolValue_tooSmall);\n            while (charnum < n0) normalizedCounter[charnum++] = 0;\n            if ((ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {\n                assert((bitCount >> 3) <= 3);  \n                ip += bitCount>>3;\n                bitCount &= 7;\n                bitStream = MEM_readLE32(ip) >> bitCount;\n            } else {\n                bitStream >>= 2;\n        }   }\n        {   int const max = (2*threshold-1) - remaining;\n            int count;\n\n            if ((bitStream & (threshold-1)) < (U32)max) {\n                count = bitStream & (threshold-1);\n                bitCount += nbBits-1;\n            } else {\n                count = bitStream & (2*threshold-1);\n                if (count >= threshold) count -= max;\n                bitCount += nbBits;\n            }\n\n            count--;    \n            remaining -= count < 0 ? -count : count;    \n            normalizedCounter[charnum++] = (short)count;\n            previous0 = !count;\n            while (remaining < threshold) {\n                nbBits--;\n                threshold >>= 1;\n            }\n\n            if ((ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {\n                ip += bitCount>>3;\n                bitCount &= 7;\n            } else {\n                bitCount -= (int)(8 * (iend - 4 - ip));\n                ip = iend - 4;\n            }\n            bitStream = MEM_readLE32(ip) >> (bitCount & 31);\n    }   }    \n    if (remaining != 1) return ERROR(corruption_detected);\n    if (bitCount > 32) return ERROR(corruption_detected);\n    *maxSVPtr = charnum-1;\n\n    ip += (bitCount+7)>>3;\n    return ip-istart;\n}\n\n\n \nsize_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,\n                     U32* nbSymbolsPtr, U32* tableLogPtr,\n                     const void* src, size_t srcSize)\n{\n    U32 weightTotal;\n    const BYTE* ip = (const BYTE*) src;\n    size_t iSize;\n    size_t oSize;\n\n    if (!srcSize) return ERROR(srcSize_wrong);\n    iSize = ip[0];\n     \n        oSize = iSize - 127;\n        iSize = ((oSize+1)/2);\n        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);\n        if (oSize >= hwSize) return ERROR(corruption_detected);\n        ip += 1;\n        {   U32 n;\n            for (n=0; n<oSize; n+=2) {\n                huffWeight[n]   = ip[n/2] >> 4;\n                huffWeight[n+1] = ip[n/2] & 15;\n    }   }   }\n    else  {    \n        FSE_DTable fseWorkspace[FSE_DTABLE_SIZE_U32(6)];   \n        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);\n        oSize = FSE_decompress_wksp(huffWeight, hwSize-1, ip+1, iSize, fseWorkspace, 6);    \n        if (FSE_isError(oSize)) return oSize;\n    }\n\n     \n    memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32));\n    weightTotal = 0;\n    {   U32 n; for (n=0; n<oSize; n++) {\n            if (huffWeight[n] >= HUF_TABLELOG_MAX) return ERROR(corruption_detected);\n            rankStats[huffWeight[n]]++;\n            weightTotal += (1 << huffWeight[n]) >> 1;\n    }   }\n    if (weightTotal == 0) return ERROR(corruption_detected);\n\n     \n    {   U32 const tableLog = BIT_highbit32(weightTotal) + 1;\n        if (tableLog > HUF_TABLELOG_MAX) return ERROR(corruption_detected);\n        *tableLogPtr = tableLog;\n         \n        {   U32 const total = 1 << tableLog;\n            U32 const rest = total - weightTotal;\n            U32 const verif = 1 << BIT_highbit32(rest);\n            U32 const lastWeight = BIT_highbit32(rest) + 1;\n            if (verif != rest) return ERROR(corruption_detected);     \n            huffWeight[oSize] = (BYTE)lastWeight;\n            rankStats[lastWeight]++;\n    }   }\n\n     \n    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);    \n\n     \n    *nbSymbolsPtr = (U32)(oSize+1);\n    return iSize+1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}