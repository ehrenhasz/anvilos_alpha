{
  "module_name": "mem.h",
  "hash_id": "3cecc497bde9ac3c3e82aa11cc1f4242b42b7a4f54770ad3bef1c07fd7298fa7",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/common/mem.h",
  "human_readable_source": " \n\n#ifndef MEM_H_MODULE\n#define MEM_H_MODULE\n\n#if defined (__cplusplus)\nextern \"C\" {\n#endif\n\n \n#include <stddef.h>      \n#include <string.h>      \n\n\n \n#if defined(_MSC_VER)    \n#   include <stdlib.h>   \n#   include <intrin.h>   \n#endif\n#if defined(__GNUC__)\n#  define MEM_STATIC static __inline __attribute__((unused))\n#elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)  )\n#  define MEM_STATIC static inline\n#elif defined(_MSC_VER)\n#  define MEM_STATIC static __inline\n#else\n#  define MEM_STATIC static   \n#endif\n\n#ifndef __has_builtin\n#  define __has_builtin(x) 0   \n#endif\n\n \n#define MEM_STATIC_ASSERT(c)   { enum { MEM_static_assert = 1/(int)(!!(c)) }; }\nMEM_STATIC void MEM_check(void) { MEM_STATIC_ASSERT((sizeof(size_t)==4) || (sizeof(size_t)==8)); }\n\n \n#if defined (__has_feature)\n#  if __has_feature(memory_sanitizer)\n#    define MEMORY_SANITIZER 1\n#  endif\n#endif\n\n#if defined (MEMORY_SANITIZER)\n \n\n#include <stdint.h>  \n\n \nvoid __msan_unpoison(const volatile void *a, size_t size);\n\n \nvoid __msan_poison(const volatile void *a, size_t size);\n\n \nintptr_t __msan_test_shadow(const volatile void *x, size_t size);\n#endif\n\n \n#if defined (ZFS_ASAN_ENABLED)\n#  define ADDRESS_SANITIZER 1\n#  define ZSTD_ASAN_DONT_POISON_WORKSPACE\n#endif\n\n#if defined (ADDRESS_SANITIZER)\n \n\n \nvoid __asan_poison_memory_region(void const volatile *addr, size_t size);\n\n \nvoid __asan_unpoison_memory_region(void const volatile *addr, size_t size);\n#endif\n\n\n \n#if  !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)  ) )\n# include <stdint.h>\n  typedef   uint8_t BYTE;\n  typedef  uint16_t U16;\n  typedef   int16_t S16;\n  typedef  uint32_t U32;\n  typedef   int32_t S32;\n  typedef  uint64_t U64;\n  typedef   int64_t S64;\n#else\n# include <limits.h>\n#if CHAR_BIT != 8\n#  error \"this implementation requires char to be exactly 8-bit type\"\n#endif\n  typedef unsigned char      BYTE;\n#if USHRT_MAX != 65535\n#  error \"this implementation requires short to be exactly 16-bit type\"\n#endif\n  typedef unsigned short      U16;\n  typedef   signed short      S16;\n#if UINT_MAX != 4294967295\n#  error \"this implementation requires int to be exactly 32-bit type\"\n#endif\n  typedef unsigned int        U32;\n  typedef   signed int        S32;\n \n  typedef unsigned long long  U64;\n  typedef   signed long long  S64;\n#endif\n\n\n \n \n#ifndef MEM_FORCE_MEMORY_ACCESS    \n#  if defined(__GNUC__) && ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )\n#    define MEM_FORCE_MEMORY_ACCESS 2\n#  elif defined(__INTEL_COMPILER) || defined(__GNUC__) || defined(__ICCARM__)\n#    define MEM_FORCE_MEMORY_ACCESS 1\n#  endif\n#endif\n\nMEM_STATIC unsigned MEM_32bits(void) { return sizeof(size_t)==4; }\nMEM_STATIC unsigned MEM_64bits(void) { return sizeof(size_t)==8; }\n\nMEM_STATIC unsigned MEM_isLittleEndian(void)\n{\n    const union { U32 u; BYTE c[4]; } one = { 1 };    \n    return one.c[0];\n}\n\n#if defined(MEM_FORCE_MEMORY_ACCESS) && (MEM_FORCE_MEMORY_ACCESS==2)\n\n \nMEM_STATIC U16 MEM_read16(const void* memPtr) { return *(const U16*) memPtr; }\nMEM_STATIC U32 MEM_read32(const void* memPtr) { return *(const U32*) memPtr; }\nMEM_STATIC U64 MEM_read64(const void* memPtr) { return *(const U64*) memPtr; }\nMEM_STATIC size_t MEM_readST(const void* memPtr) { return *(const size_t*) memPtr; }\n\nMEM_STATIC void MEM_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }\nMEM_STATIC void MEM_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }\nMEM_STATIC void MEM_write64(void* memPtr, U64 value) { *(U64*)memPtr = value; }\n\n#elif defined(MEM_FORCE_MEMORY_ACCESS) && (MEM_FORCE_MEMORY_ACCESS==1)\n\n \n \n#if defined(_MSC_VER) || (defined(__INTEL_COMPILER) && defined(WIN32))\n    __pragma( pack(push, 1) )\n    typedef struct { U16 v; } unalign16;\n    typedef struct { U32 v; } unalign32;\n    typedef struct { U64 v; } unalign64;\n    typedef struct { size_t v; } unalignArch;\n    __pragma( pack(pop) )\n#else\n    typedef struct { U16 v; } __attribute__((packed)) unalign16;\n    typedef struct { U32 v; } __attribute__((packed)) unalign32;\n    typedef struct { U64 v; } __attribute__((packed)) unalign64;\n    typedef struct { size_t v; } __attribute__((packed)) unalignArch;\n#endif\n\nMEM_STATIC U16 MEM_read16(const void* ptr) { return ((const unalign16*)ptr)->v; }\nMEM_STATIC U32 MEM_read32(const void* ptr) { return ((const unalign32*)ptr)->v; }\nMEM_STATIC U64 MEM_read64(const void* ptr) { return ((const unalign64*)ptr)->v; }\nMEM_STATIC size_t MEM_readST(const void* ptr) { return ((const unalignArch*)ptr)->v; }\n\nMEM_STATIC void MEM_write16(void* memPtr, U16 value) { ((unalign16*)memPtr)->v = value; }\nMEM_STATIC void MEM_write32(void* memPtr, U32 value) { ((unalign32*)memPtr)->v = value; }\nMEM_STATIC void MEM_write64(void* memPtr, U64 value) { ((unalign64*)memPtr)->v = value; }\n\n#else\n\n \n\nMEM_STATIC U16 MEM_read16(const void* memPtr)\n{\n    U16 val; memcpy(&val, memPtr, sizeof(val)); return val;\n}\n\nMEM_STATIC U32 MEM_read32(const void* memPtr)\n{\n    U32 val; memcpy(&val, memPtr, sizeof(val)); return val;\n}\n\nMEM_STATIC U64 MEM_read64(const void* memPtr)\n{\n    U64 val; memcpy(&val, memPtr, sizeof(val)); return val;\n}\n\nMEM_STATIC size_t MEM_readST(const void* memPtr)\n{\n    size_t val; memcpy(&val, memPtr, sizeof(val)); return val;\n}\n\nMEM_STATIC void MEM_write16(void* memPtr, U16 value)\n{\n    memcpy(memPtr, &value, sizeof(value));\n}\n\nMEM_STATIC void MEM_write32(void* memPtr, U32 value)\n{\n    memcpy(memPtr, &value, sizeof(value));\n}\n\nMEM_STATIC void MEM_write64(void* memPtr, U64 value)\n{\n    memcpy(memPtr, &value, sizeof(value));\n}\n\n#endif  \n\nMEM_STATIC U32 MEM_swap32(U32 in)\n{\n#if defined(_MSC_VER)      \n    return _byteswap_ulong(in);\n#elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \\\n  || (defined(__clang__) && __has_builtin(__builtin_bswap32))\n    return __builtin_bswap32(in);\n#else\n    return  ((in << 24) & 0xff000000 ) |\n            ((in <<  8) & 0x00ff0000 ) |\n            ((in >>  8) & 0x0000ff00 ) |\n            ((in >> 24) & 0x000000ff );\n#endif\n}\n\nMEM_STATIC U64 MEM_swap64(U64 in)\n{\n#if defined(_MSC_VER)      \n    return _byteswap_uint64(in);\n#elif (defined (__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 403)) \\\n  || (defined(__clang__) && __has_builtin(__builtin_bswap64))\n    return __builtin_bswap64(in);\n#else\n    return  ((in << 56) & 0xff00000000000000ULL) |\n            ((in << 40) & 0x00ff000000000000ULL) |\n            ((in << 24) & 0x0000ff0000000000ULL) |\n            ((in << 8)  & 0x000000ff00000000ULL) |\n            ((in >> 8)  & 0x00000000ff000000ULL) |\n            ((in >> 24) & 0x0000000000ff0000ULL) |\n            ((in >> 40) & 0x000000000000ff00ULL) |\n            ((in >> 56) & 0x00000000000000ffULL);\n#endif\n}\n\nMEM_STATIC size_t MEM_swapST(size_t in)\n{\n    if (MEM_32bits())\n        return (size_t)MEM_swap32((U32)in);\n    else\n        return (size_t)MEM_swap64((U64)in);\n}\n\n \n\nMEM_STATIC U16 MEM_readLE16(const void* memPtr)\n{\n    if (MEM_isLittleEndian())\n        return MEM_read16(memPtr);\n    else {\n        const BYTE* p = (const BYTE*)memPtr;\n        return (U16)(p[0] + (p[1]<<8));\n    }\n}\n\nMEM_STATIC void MEM_writeLE16(void* memPtr, U16 val)\n{\n    if (MEM_isLittleEndian()) {\n        MEM_write16(memPtr, val);\n    } else {\n        BYTE* p = (BYTE*)memPtr;\n        p[0] = (BYTE)val;\n        p[1] = (BYTE)(val>>8);\n    }\n}\n\nMEM_STATIC U32 MEM_readLE24(const void* memPtr)\n{\n    return MEM_readLE16(memPtr) + (((const BYTE*)memPtr)[2] << 16);\n}\n\nMEM_STATIC void MEM_writeLE24(void* memPtr, U32 val)\n{\n    MEM_writeLE16(memPtr, (U16)val);\n    ((BYTE*)memPtr)[2] = (BYTE)(val>>16);\n}\n\nMEM_STATIC U32 MEM_readLE32(const void* memPtr)\n{\n    if (MEM_isLittleEndian())\n        return MEM_read32(memPtr);\n    else\n        return MEM_swap32(MEM_read32(memPtr));\n}\n\nMEM_STATIC void MEM_writeLE32(void* memPtr, U32 val32)\n{\n    if (MEM_isLittleEndian())\n        MEM_write32(memPtr, val32);\n    else\n        MEM_write32(memPtr, MEM_swap32(val32));\n}\n\nMEM_STATIC U64 MEM_readLE64(const void* memPtr)\n{\n    if (MEM_isLittleEndian())\n        return MEM_read64(memPtr);\n    else\n        return MEM_swap64(MEM_read64(memPtr));\n}\n\nMEM_STATIC void MEM_writeLE64(void* memPtr, U64 val64)\n{\n    if (MEM_isLittleEndian())\n        MEM_write64(memPtr, val64);\n    else\n        MEM_write64(memPtr, MEM_swap64(val64));\n}\n\nMEM_STATIC size_t MEM_readLEST(const void* memPtr)\n{\n    if (MEM_32bits())\n        return (size_t)MEM_readLE32(memPtr);\n    else\n        return (size_t)MEM_readLE64(memPtr);\n}\n\nMEM_STATIC void MEM_writeLEST(void* memPtr, size_t val)\n{\n    if (MEM_32bits())\n        MEM_writeLE32(memPtr, (U32)val);\n    else\n        MEM_writeLE64(memPtr, (U64)val);\n}\n\n \n\nMEM_STATIC U32 MEM_readBE32(const void* memPtr)\n{\n    if (MEM_isLittleEndian())\n        return MEM_swap32(MEM_read32(memPtr));\n    else\n        return MEM_read32(memPtr);\n}\n\nMEM_STATIC void MEM_writeBE32(void* memPtr, U32 val32)\n{\n    if (MEM_isLittleEndian())\n        MEM_write32(memPtr, MEM_swap32(val32));\n    else\n        MEM_write32(memPtr, val32);\n}\n\nMEM_STATIC U64 MEM_readBE64(const void* memPtr)\n{\n    if (MEM_isLittleEndian())\n        return MEM_swap64(MEM_read64(memPtr));\n    else\n        return MEM_read64(memPtr);\n}\n\nMEM_STATIC void MEM_writeBE64(void* memPtr, U64 val64)\n{\n    if (MEM_isLittleEndian())\n        MEM_write64(memPtr, MEM_swap64(val64));\n    else\n        MEM_write64(memPtr, val64);\n}\n\nMEM_STATIC size_t MEM_readBEST(const void* memPtr)\n{\n    if (MEM_32bits())\n        return (size_t)MEM_readBE32(memPtr);\n    else\n        return (size_t)MEM_readBE64(memPtr);\n}\n\nMEM_STATIC void MEM_writeBEST(void* memPtr, size_t val)\n{\n    if (MEM_32bits())\n        MEM_writeBE32(memPtr, (U32)val);\n    else\n        MEM_writeBE64(memPtr, (U64)val);\n}\n\n\n#if defined (__cplusplus)\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}