{
  "module_name": "pool.c",
  "hash_id": "c60c05242c3ee970164d2272e7bb4150c856982fe77f731b6c6feaf13ca48a2d",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/common/pool.c",
  "human_readable_source": " \n\n\n \n#include <stddef.h>     \n#include \"debug.h\"      \n#include \"zstd_internal.h\"   \n#include \"pool.h\"\n\n \n#if defined(_MSC_VER)\n#  pragma warning(disable : 4204)         \n#endif\n\n\n#ifdef ZSTD_MULTITHREAD\n\n#include \"threading.h\"    \n\n \ntypedef struct POOL_job_s {\n    POOL_function function;\n    void *opaque;\n} POOL_job;\n\nstruct POOL_ctx_s {\n    ZSTD_customMem customMem;\n     \n    ZSTD_pthread_t* threads;\n    size_t threadCapacity;\n    size_t threadLimit;\n\n     \n    POOL_job *queue;\n    size_t queueHead;\n    size_t queueTail;\n    size_t queueSize;\n\n     \n    size_t numThreadsBusy;\n     \n    int queueEmpty;\n\n     \n    ZSTD_pthread_mutex_t queueMutex;\n     \n    ZSTD_pthread_cond_t queuePushCond;\n     \n    ZSTD_pthread_cond_t queuePopCond;\n     \n    int shutdown;\n};\n\n \nstatic void* POOL_thread(void* opaque) {\n    POOL_ctx* const ctx = (POOL_ctx*)opaque;\n    if (!ctx) { return NULL; }\n    for (;;) {\n         \n        ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n\n        while ( ctx->queueEmpty\n            || (ctx->numThreadsBusy >= ctx->threadLimit) ) {\n            if (ctx->shutdown) {\n                 \n                ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n                return opaque;\n            }\n            ZSTD_pthread_cond_wait(&ctx->queuePopCond, &ctx->queueMutex);\n        }\n         \n        {   POOL_job const job = ctx->queue[ctx->queueHead];\n            ctx->queueHead = (ctx->queueHead + 1) % ctx->queueSize;\n            ctx->numThreadsBusy++;\n            ctx->queueEmpty = ctx->queueHead == ctx->queueTail;\n             \n            ZSTD_pthread_cond_signal(&ctx->queuePushCond);\n            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n\n            job.function(job.opaque);\n\n             \n            ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n            ctx->numThreadsBusy--;\n            if (ctx->queueSize == 1) {\n                ZSTD_pthread_cond_signal(&ctx->queuePushCond);\n            }\n            ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n        }\n    }   \n    assert(0);   \n}\n\nPOOL_ctx* POOL_create(size_t numThreads, size_t queueSize) {\n    return POOL_create_advanced(numThreads, queueSize, ZSTD_defaultCMem);\n}\n\nPOOL_ctx* POOL_create_advanced(size_t numThreads, size_t queueSize,\n                               ZSTD_customMem customMem) {\n    POOL_ctx* ctx;\n     \n    if (!numThreads) { return NULL; }\n     \n    ctx = (POOL_ctx*)ZSTD_calloc(sizeof(POOL_ctx), customMem);\n    if (!ctx) { return NULL; }\n     \n    ctx->queueSize = queueSize + 1;\n    ctx->queue = (POOL_job*)ZSTD_malloc(ctx->queueSize * sizeof(POOL_job), customMem);\n    ctx->queueHead = 0;\n    ctx->queueTail = 0;\n    ctx->numThreadsBusy = 0;\n    ctx->queueEmpty = 1;\n    {\n        int error = 0;\n        error |= ZSTD_pthread_mutex_init(&ctx->queueMutex, NULL);\n        error |= ZSTD_pthread_cond_init(&ctx->queuePushCond, NULL);\n        error |= ZSTD_pthread_cond_init(&ctx->queuePopCond, NULL);\n        if (error) { POOL_free(ctx); return NULL; }\n    }\n    ctx->shutdown = 0;\n     \n    ctx->threads = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), customMem);\n    ctx->threadCapacity = 0;\n    ctx->customMem = customMem;\n     \n    if (!ctx->threads || !ctx->queue) { POOL_free(ctx); return NULL; }\n     \n    {   size_t i;\n        for (i = 0; i < numThreads; ++i) {\n            if (ZSTD_pthread_create(&ctx->threads[i], NULL, &POOL_thread, ctx)) {\n                ctx->threadCapacity = i;\n                POOL_free(ctx);\n                return NULL;\n        }   }\n        ctx->threadCapacity = numThreads;\n        ctx->threadLimit = numThreads;\n    }\n    return ctx;\n}\n\n \nstatic void POOL_join(POOL_ctx* ctx) {\n     \n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n    ctx->shutdown = 1;\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n     \n    ZSTD_pthread_cond_broadcast(&ctx->queuePushCond);\n    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);\n     \n    {   size_t i;\n        for (i = 0; i < ctx->threadCapacity; ++i) {\n            ZSTD_pthread_join(ctx->threads[i], NULL);   \n    }   }\n}\n\nvoid POOL_free(POOL_ctx *ctx) {\n    if (!ctx) { return; }\n    POOL_join(ctx);\n    ZSTD_pthread_mutex_destroy(&ctx->queueMutex);\n    ZSTD_pthread_cond_destroy(&ctx->queuePushCond);\n    ZSTD_pthread_cond_destroy(&ctx->queuePopCond);\n    ZSTD_free(ctx->queue, ctx->customMem);\n    ZSTD_free(ctx->threads, ctx->customMem);\n    ZSTD_free(ctx, ctx->customMem);\n}\n\n\n\nsize_t POOL_sizeof(POOL_ctx *ctx) {\n    if (ctx==NULL) return 0;   \n    return sizeof(*ctx)\n        + ctx->queueSize * sizeof(POOL_job)\n        + ctx->threadCapacity * sizeof(ZSTD_pthread_t);\n}\n\n\n \nstatic int POOL_resize_internal(POOL_ctx* ctx, size_t numThreads)\n{\n    if (numThreads <= ctx->threadCapacity) {\n        if (!numThreads) return 1;\n        ctx->threadLimit = numThreads;\n        return 0;\n    }\n     \n    {   ZSTD_pthread_t* const threadPool = (ZSTD_pthread_t*)ZSTD_malloc(numThreads * sizeof(ZSTD_pthread_t), ctx->customMem);\n        if (!threadPool) return 1;\n         \n        memcpy(threadPool, ctx->threads, ctx->threadCapacity * sizeof(*threadPool));\n        ZSTD_free(ctx->threads, ctx->customMem);\n        ctx->threads = threadPool;\n         \n        {   size_t threadId;\n            for (threadId = ctx->threadCapacity; threadId < numThreads; ++threadId) {\n                if (ZSTD_pthread_create(&threadPool[threadId], NULL, &POOL_thread, ctx)) {\n                    ctx->threadCapacity = threadId;\n                    return 1;\n            }   }\n    }   }\n     \n    ctx->threadCapacity = numThreads;\n    ctx->threadLimit = numThreads;\n    return 0;\n}\n\n \nint POOL_resize(POOL_ctx* ctx, size_t numThreads)\n{\n    int result;\n    if (ctx==NULL) return 1;\n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n    result = POOL_resize_internal(ctx, numThreads);\n    ZSTD_pthread_cond_broadcast(&ctx->queuePopCond);\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n    return result;\n}\n\n \nstatic int isQueueFull(POOL_ctx const* ctx) {\n    if (ctx->queueSize > 1) {\n        return ctx->queueHead == ((ctx->queueTail + 1) % ctx->queueSize);\n    } else {\n        return (ctx->numThreadsBusy == ctx->threadLimit) ||\n               !ctx->queueEmpty;\n    }\n}\n\n\nstatic void POOL_add_internal(POOL_ctx* ctx, POOL_function function, void *opaque)\n{\n    POOL_job const job = {function, opaque};\n    assert(ctx != NULL);\n    if (ctx->shutdown) return;\n\n    ctx->queueEmpty = 0;\n    ctx->queue[ctx->queueTail] = job;\n    ctx->queueTail = (ctx->queueTail + 1) % ctx->queueSize;\n    ZSTD_pthread_cond_signal(&ctx->queuePopCond);\n}\n\nvoid POOL_add(POOL_ctx* ctx, POOL_function function, void* opaque)\n{\n    assert(ctx != NULL);\n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n     \n    while (isQueueFull(ctx) && (!ctx->shutdown)) {\n        ZSTD_pthread_cond_wait(&ctx->queuePushCond, &ctx->queueMutex);\n    }\n    POOL_add_internal(ctx, function, opaque);\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n}\n\n\nint POOL_tryAdd(POOL_ctx* ctx, POOL_function function, void* opaque)\n{\n    assert(ctx != NULL);\n    ZSTD_pthread_mutex_lock(&ctx->queueMutex);\n    if (isQueueFull(ctx)) {\n        ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n        return 0;\n    }\n    POOL_add_internal(ctx, function, opaque);\n    ZSTD_pthread_mutex_unlock(&ctx->queueMutex);\n    return 1;\n}\n\n\n#else   \n\n \n \n \n\n\n \nstruct POOL_ctx_s {\n    int dummy;\n};\nstatic POOL_ctx g_ctx;\n\nPOOL_ctx* POOL_create(size_t numThreads, size_t queueSize) {\n    return POOL_create_advanced(numThreads, queueSize, ZSTD_defaultCMem);\n}\n\nPOOL_ctx* POOL_create_advanced(size_t numThreads, size_t queueSize, ZSTD_customMem customMem) {\n    (void)numThreads;\n    (void)queueSize;\n    (void)customMem;\n    return &g_ctx;\n}\n\nvoid POOL_free(POOL_ctx* ctx) {\n    assert(!ctx || ctx == &g_ctx);\n    (void)ctx;\n}\n\nint POOL_resize(POOL_ctx* ctx, size_t numThreads) {\n    (void)ctx; (void)numThreads;\n    return 0;\n}\n\nvoid POOL_add(POOL_ctx* ctx, POOL_function function, void* opaque) {\n    (void)ctx;\n    function(opaque);\n}\n\nint POOL_tryAdd(POOL_ctx* ctx, POOL_function function, void* opaque) {\n    (void)ctx;\n    function(opaque);\n    return 1;\n}\n\nsize_t POOL_sizeof(POOL_ctx* ctx) {\n    if (ctx==NULL) return 0;   \n    assert(ctx == &g_ctx);\n    return sizeof(*ctx);\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}