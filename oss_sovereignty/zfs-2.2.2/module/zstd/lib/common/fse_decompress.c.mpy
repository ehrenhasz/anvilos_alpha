{
  "module_name": "fse_decompress.c",
  "hash_id": "ab5e33edfaa5f2f5ef0e09e00beeef331bd521005b5d338defec9dd84784f640",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/common/fse_decompress.c",
  "human_readable_source": " \n\n\n \n#include <stdlib.h>      \n#include <string.h>      \n#include \"bitstream.h\"\n#include \"compiler.h\"\n#define FSE_STATIC_LINKING_ONLY\n#include \"fse.h\"\n#include \"error_private.h\"\n\n\n \n#define FSE_isError ERR_isError\n#define FSE_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)    \n\n\n \n \n\n \n#ifndef FSE_FUNCTION_EXTENSION\n#  error \"FSE_FUNCTION_EXTENSION must be defined\"\n#endif\n#ifndef FSE_FUNCTION_TYPE\n#  error \"FSE_FUNCTION_TYPE must be defined\"\n#endif\n\n \n#define FSE_CAT(X,Y) X##Y\n#define FSE_FUNCTION_NAME(X,Y) FSE_CAT(X,Y)\n#define FSE_TYPE_NAME(X,Y) FSE_CAT(X,Y)\n\n\n \nsize_t FSE_buildDTable(FSE_DTable* dt, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)\n{\n    void* const tdPtr = dt+1;    \n    FSE_DECODE_TYPE* const tableDecode = (FSE_DECODE_TYPE*) (tdPtr);\n    U16 symbolNext[FSE_MAX_SYMBOL_VALUE+1];\n\n    U32 const maxSV1 = maxSymbolValue + 1;\n    U32 const tableSize = 1 << tableLog;\n    U32 highThreshold = tableSize-1;\n\n     \n    if (maxSymbolValue > FSE_MAX_SYMBOL_VALUE) return ERROR(maxSymbolValue_tooLarge);\n    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);\n\n     \n    {   FSE_DTableHeader DTableH;\n        DTableH.tableLog = (U16)tableLog;\n        DTableH.fastMode = 1;\n        {   S16 const largeLimit= (S16)(1 << (tableLog-1));\n            U32 s;\n            for (s=0; s<maxSV1; s++) {\n                if (normalizedCounter[s]==-1) {\n                    tableDecode[highThreshold--].symbol = (FSE_FUNCTION_TYPE)s;\n                    symbolNext[s] = 1;\n                } else {\n                    if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;\n                    symbolNext[s] = normalizedCounter[s];\n        }   }   }\n        memcpy(dt, &DTableH, sizeof(DTableH));\n    }\n\n     \n    {   U32 const tableMask = tableSize-1;\n        U32 const step = FSE_TABLESTEP(tableSize);\n        U32 s, position = 0;\n        for (s=0; s<maxSV1; s++) {\n            int i;\n            for (i=0; i<normalizedCounter[s]; i++) {\n                tableDecode[position].symbol = (FSE_FUNCTION_TYPE)s;\n                position = (position + step) & tableMask;\n                while (position > highThreshold) position = (position + step) & tableMask;    \n        }   }\n        if (position!=0) return ERROR(GENERIC);    \n    }\n\n     \n    {   U32 u;\n        for (u=0; u<tableSize; u++) {\n            FSE_FUNCTION_TYPE const symbol = (FSE_FUNCTION_TYPE)(tableDecode[u].symbol);\n            U32 const nextState = symbolNext[symbol]++;\n            tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );\n            tableDecode[u].newState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);\n    }   }\n\n    return 0;\n}\n\n\n#ifndef FSE_COMMONDEFS_ONLY\n\n \nsize_t FSE_buildDTable_rle (FSE_DTable* dt, BYTE symbolValue)\n{\n    void* ptr = dt;\n    FSE_DTableHeader* const DTableH = (FSE_DTableHeader*)ptr;\n    void* dPtr = dt + 1;\n    FSE_decode_t* const cell = (FSE_decode_t*)dPtr;\n\n    DTableH->tableLog = 0;\n    DTableH->fastMode = 0;\n\n    cell->newState = 0;\n    cell->symbol = symbolValue;\n    cell->nbBits = 0;\n\n    return 0;\n}\n\n\nsize_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits)\n{\n    void* ptr = dt;\n    FSE_DTableHeader* const DTableH = (FSE_DTableHeader*)ptr;\n    void* dPtr = dt + 1;\n    FSE_decode_t* const dinfo = (FSE_decode_t*)dPtr;\n    const unsigned tableSize = 1 << nbBits;\n    const unsigned tableMask = tableSize - 1;\n    const unsigned maxSV1 = tableMask+1;\n    unsigned s;\n\n     \n    if (nbBits < 1) return ERROR(GENERIC);          \n\n     \n    DTableH->tableLog = (U16)nbBits;\n    DTableH->fastMode = 1;\n    for (s=0; s<maxSV1; s++) {\n        dinfo[s].newState = 0;\n        dinfo[s].symbol = (BYTE)s;\n        dinfo[s].nbBits = (BYTE)nbBits;\n    }\n\n    return 0;\n}\n\nFORCE_INLINE_TEMPLATE size_t FSE_decompress_usingDTable_generic(\n          void* dst, size_t maxDstSize,\n    const void* cSrc, size_t cSrcSize,\n    const FSE_DTable* dt, const unsigned fast)\n{\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* op = ostart;\n    BYTE* const omax = op + maxDstSize;\n    BYTE* const olimit = omax-3;\n\n    BIT_DStream_t bitD;\n    FSE_DState_t state1;\n    FSE_DState_t state2;\n\n     \n    CHECK_F(BIT_initDStream(&bitD, cSrc, cSrcSize));\n\n    FSE_initDState(&state1, &bitD, dt);\n    FSE_initDState(&state2, &bitD, dt);\n\n#define FSE_GETSYMBOL(statePtr) fast ? FSE_decodeSymbolFast(statePtr, &bitD) : FSE_decodeSymbol(statePtr, &bitD)\n\n     \n    for ( ; (BIT_reloadDStream(&bitD)==BIT_DStream_unfinished) & (op<olimit) ; op+=4) {\n        op[0] = FSE_GETSYMBOL(&state1);\n\n        if (FSE_MAX_TABLELOG*2+7 > sizeof(bitD.bitContainer)*8)     \n            BIT_reloadDStream(&bitD);\n\n        op[1] = FSE_GETSYMBOL(&state2);\n\n        if (FSE_MAX_TABLELOG*4+7 > sizeof(bitD.bitContainer)*8)     \n            { if (BIT_reloadDStream(&bitD) > BIT_DStream_unfinished) { op+=2; break; } }\n\n        op[2] = FSE_GETSYMBOL(&state1);\n\n        if (FSE_MAX_TABLELOG*2+7 > sizeof(bitD.bitContainer)*8)     \n            BIT_reloadDStream(&bitD);\n\n        op[3] = FSE_GETSYMBOL(&state2);\n    }\n\n     \n     \n    while (1) {\n        if (op>(omax-2)) return ERROR(dstSize_tooSmall);\n        *op++ = FSE_GETSYMBOL(&state1);\n        if (BIT_reloadDStream(&bitD)==BIT_DStream_overflow) {\n            *op++ = FSE_GETSYMBOL(&state2);\n            break;\n        }\n\n        if (op>(omax-2)) return ERROR(dstSize_tooSmall);\n        *op++ = FSE_GETSYMBOL(&state2);\n        if (BIT_reloadDStream(&bitD)==BIT_DStream_overflow) {\n            *op++ = FSE_GETSYMBOL(&state1);\n            break;\n    }   }\n\n    return op-ostart;\n}\n\n\nsize_t FSE_decompress_usingDTable(void* dst, size_t originalSize,\n                            const void* cSrc, size_t cSrcSize,\n                            const FSE_DTable* dt)\n{\n    const void* ptr = dt;\n    const FSE_DTableHeader* DTableH = (const FSE_DTableHeader*)ptr;\n    const U32 fastMode = DTableH->fastMode;\n\n     \n    if (fastMode) return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 1);\n    return FSE_decompress_usingDTable_generic(dst, originalSize, cSrc, cSrcSize, dt, 0);\n}\n\n\nsize_t FSE_decompress_wksp(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, FSE_DTable* workSpace, unsigned maxLog)\n{\n    const BYTE* const istart = (const BYTE*)cSrc;\n    const BYTE* ip = istart;\n    short counting[FSE_MAX_SYMBOL_VALUE+1];\n    unsigned tableLog;\n    unsigned maxSymbolValue = FSE_MAX_SYMBOL_VALUE;\n\n     \n    size_t const NCountLength = FSE_readNCount (counting, &maxSymbolValue, &tableLog, istart, cSrcSize);\n    if (FSE_isError(NCountLength)) return NCountLength;\n        \n    if (tableLog > maxLog) return ERROR(tableLog_tooLarge);\n    ip += NCountLength;\n    cSrcSize -= NCountLength;\n\n    CHECK_F( FSE_buildDTable (workSpace, counting, maxSymbolValue, tableLog) );\n\n    return FSE_decompress_usingDTable (dst, dstCapacity, ip, cSrcSize, workSpace);    \n}\n\n\ntypedef FSE_DTable DTable_max_t[FSE_DTABLE_SIZE_U32(FSE_MAX_TABLELOG)];\n\nsize_t FSE_decompress(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize)\n{\n    DTable_max_t dt;    \n    return FSE_decompress_wksp(dst, dstCapacity, cSrc, cSrcSize, dt, FSE_MAX_TABLELOG);\n}\n\n\n\n#endif    \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}