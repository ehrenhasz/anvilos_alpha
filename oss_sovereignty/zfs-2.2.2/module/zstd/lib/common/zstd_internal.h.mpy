{
  "module_name": "zstd_internal.h",
  "hash_id": "a3fcfdadf2f2ace345ed1bc9073e16c3c972315b540ceb187cf3b82d9bbb44ed",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/common/zstd_internal.h",
  "human_readable_source": " \n\n#ifndef ZSTD_CCOMMON_H_MODULE\n#define ZSTD_CCOMMON_H_MODULE\n\n \n\n \n#if !defined(ZSTD_NO_INTRINSICS) && defined(__ARM_NEON)\n#include <arm_neon.h>\n#endif\n#include \"compiler.h\"\n#include \"mem.h\"\n#include \"debug.h\"                  \n#include \"error_private.h\"\n#define ZSTD_STATIC_LINKING_ONLY\n#include \"../zstd.h\"\n#define FSE_STATIC_LINKING_ONLY\n#include \"fse.h\"\n#define HUF_STATIC_LINKING_ONLY\n#include \"huf.h\"\n#ifndef XXH_STATIC_LINKING_ONLY\n#  define XXH_STATIC_LINKING_ONLY   \n#endif\n#include \"xxhash.h\"                 \n\n#if defined (__cplusplus)\nextern \"C\" {\n#endif\n\n \n#define ZSTD_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)\n#define FSE_isError  ERR_isError\n#define HUF_isError  ERR_isError\n\n\n \n#undef MIN\n#undef MAX\n#define MIN(a,b) ((a)<(b) ? (a) : (b))\n#define MAX(a,b) ((a)>(b) ? (a) : (b))\n\n \nstatic INLINE_KEYWORD UNUSED_ATTR\nvoid _force_has_format_string(const char *format, ...) {\n  (void)format;\n}\n\n \n#define _FORCE_HAS_FORMAT_STRING(...) \\\n  if (0) { \\\n    _force_has_format_string(__VA_ARGS__); \\\n  }\n\n \n#define RETURN_ERROR_IF(cond, err, ...) \\\n  if (cond) { \\\n    RAWLOG(3, \"%s:%d: ERROR!: check %s failed, returning %s\", \\\n           __FILE__, __LINE__, ZSTD_QUOTE(cond), ZSTD_QUOTE(ERROR(err))); \\\n    _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); \\\n    RAWLOG(3, \": \" __VA_ARGS__); \\\n    RAWLOG(3, \"\\n\"); \\\n    return ERROR(err); \\\n  }\n\n \n#define RETURN_ERROR(err, ...) \\\n  do { \\\n    RAWLOG(3, \"%s:%d: ERROR!: unconditional check failed, returning %s\", \\\n           __FILE__, __LINE__, ZSTD_QUOTE(ERROR(err))); \\\n    _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); \\\n    RAWLOG(3, \": \" __VA_ARGS__); \\\n    RAWLOG(3, \"\\n\"); \\\n    return ERROR(err); \\\n  } while(0);\n\n \n#define FORWARD_IF_ERROR(err, ...) \\\n  do { \\\n    size_t const err_code = (err); \\\n    if (ERR_isError(err_code)) { \\\n      RAWLOG(3, \"%s:%d: ERROR!: forwarding error in %s: %s\", \\\n             __FILE__, __LINE__, ZSTD_QUOTE(err), ERR_getErrorName(err_code)); \\\n      _FORCE_HAS_FORMAT_STRING(__VA_ARGS__); \\\n      RAWLOG(3, \": \" __VA_ARGS__); \\\n      RAWLOG(3, \"\\n\"); \\\n      return err_code; \\\n    } \\\n  } while(0);\n\n\n \n#define ZSTD_OPT_NUM    (1<<12)\n\n#define ZSTD_REP_NUM      3                  \n#define ZSTD_REP_MOVE     (ZSTD_REP_NUM-1)\nstatic const U32 repStartValue[ZSTD_REP_NUM] = { 1, 4, 8 };\n\n#define KB *(1 <<10)\n#define MB *(1 <<20)\n#define GB *(1U<<30)\n\n#define BIT7 128\n#define BIT6  64\n#define BIT5  32\n#define BIT4  16\n#define BIT1   2\n#define BIT0   1\n\n#define ZSTD_WINDOWLOG_ABSOLUTEMIN 10\nstatic const size_t ZSTD_fcs_fieldSize[4] = { 0, 2, 4, 8 };\nstatic const size_t ZSTD_did_fieldSize[4] = { 0, 1, 2, 4 };\n\n#define ZSTD_FRAMEIDSIZE 4    \n\n#define ZSTD_BLOCKHEADERSIZE 3    \nstatic const size_t ZSTD_blockHeaderSize = ZSTD_BLOCKHEADERSIZE;\ntypedef enum { bt_raw, bt_rle, bt_compressed, bt_reserved } blockType_e;\n\n#define ZSTD_FRAMECHECKSUMSIZE 4\n\n#define MIN_SEQUENCES_SIZE 1  \n#define MIN_CBLOCK_SIZE (1   + 1   + MIN_SEQUENCES_SIZE  )    \n\n#define HufLog 12\ntypedef enum { set_basic, set_rle, set_compressed, set_repeat } symbolEncodingType_e;\n\n#define LONGNBSEQ 0x7F00\n\n#define MINMATCH 3\n\n#define Litbits  8\n#define MaxLit ((1<<Litbits) - 1)\n#define MaxML   52\n#define MaxLL   35\n#define DefaultMaxOff 28\n#define MaxOff  31\n#define MaxSeq MAX(MaxLL, MaxML)    \n#define MLFSELog    9\n#define LLFSELog    9\n#define OffFSELog   8\n#define MaxFSELog  MAX(MAX(MLFSELog, LLFSELog), OffFSELog)\n\nstatic const U32 LL_bits[MaxLL+1] = { 0, 0, 0, 0, 0, 0, 0, 0,\n                                      0, 0, 0, 0, 0, 0, 0, 0,\n                                      1, 1, 1, 1, 2, 2, 3, 3,\n                                      4, 6, 7, 8, 9,10,11,12,\n                                     13,14,15,16 };\nstatic const S16 LL_defaultNorm[MaxLL+1] = { 4, 3, 2, 2, 2, 2, 2, 2,\n                                             2, 2, 2, 2, 2, 1, 1, 1,\n                                             2, 2, 2, 2, 2, 2, 2, 2,\n                                             2, 3, 2, 1, 1, 1, 1, 1,\n                                            -1,-1,-1,-1 };\n#define LL_DEFAULTNORMLOG 6   \nstatic const U32 LL_defaultNormLog = LL_DEFAULTNORMLOG;\n\nstatic const U32 ML_bits[MaxML+1] = { 0, 0, 0, 0, 0, 0, 0, 0,\n                                      0, 0, 0, 0, 0, 0, 0, 0,\n                                      0, 0, 0, 0, 0, 0, 0, 0,\n                                      0, 0, 0, 0, 0, 0, 0, 0,\n                                      1, 1, 1, 1, 2, 2, 3, 3,\n                                      4, 4, 5, 7, 8, 9,10,11,\n                                     12,13,14,15,16 };\nstatic const S16 ML_defaultNorm[MaxML+1] = { 1, 4, 3, 2, 2, 2, 2, 2,\n                                             2, 1, 1, 1, 1, 1, 1, 1,\n                                             1, 1, 1, 1, 1, 1, 1, 1,\n                                             1, 1, 1, 1, 1, 1, 1, 1,\n                                             1, 1, 1, 1, 1, 1, 1, 1,\n                                             1, 1, 1, 1, 1, 1,-1,-1,\n                                            -1,-1,-1,-1,-1 };\n#define ML_DEFAULTNORMLOG 6   \nstatic const U32 ML_defaultNormLog = ML_DEFAULTNORMLOG;\n\nstatic const S16 OF_defaultNorm[DefaultMaxOff+1] = { 1, 1, 1, 1, 1, 1, 2, 2,\n                                                     2, 1, 1, 1, 1, 1, 1, 1,\n                                                     1, 1, 1, 1, 1, 1, 1, 1,\n                                                    -1,-1,-1,-1,-1 };\n#define OF_DEFAULTNORMLOG 5   \nstatic const U32 OF_defaultNormLog = OF_DEFAULTNORMLOG;\n\n\n \nstatic void ZSTD_copy8(void* dst, const void* src) {\n#if !defined(ZSTD_NO_INTRINSICS) && defined(__ARM_NEON)\n    vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));\n#else\n    memcpy(dst, src, 8);\n#endif\n}\n\n#define COPY8(d,s) { ZSTD_copy8(d,s); d+=8; s+=8; }\nstatic void ZSTD_copy16(void* dst, const void* src) {\n#if !defined(ZSTD_NO_INTRINSICS) && defined(__ARM_NEON)\n    vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));\n#else\n    memcpy(dst, src, 16);\n#endif\n}\n#define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }\n\n#define WILDCOPY_OVERLENGTH 32\n#define WILDCOPY_VECLEN 16\n\ntypedef enum {\n    ZSTD_no_overlap,\n    ZSTD_overlap_src_before_dst\n     \n} ZSTD_overlap_e;\n\n \nMEM_STATIC FORCE_INLINE_ATTR \nvoid ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)\n{\n    ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;\n    const BYTE* ip = (const BYTE*)src;\n    BYTE* op = (BYTE*)dst;\n    BYTE* const oend = op + length;\n\n    assert(diff >= 8 || (ovtype == ZSTD_no_overlap && diff <= -WILDCOPY_VECLEN));\n\n    if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {\n         \n        do {\n            COPY8(op, ip)\n        } while (op < oend);\n    } else {\n        assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);\n         \n#ifndef __aarch64__\n        do {\n            COPY16(op, ip);\n        }\n        while (op < oend);\n#else\n        COPY16(op, ip);\n        if (op >= oend) return;\n        do {\n            COPY16(op, ip);\n            COPY16(op, ip);\n        }\n        while (op < oend);\n#endif\n    }\n}\n\nMEM_STATIC size_t ZSTD_limitCopy(void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    size_t const length = MIN(dstCapacity, srcSize);\n    if (length > 0) {\n        memcpy(dst, src, length);\n    }\n    return length;\n}\n\n \n#define ZSTD_WORKSPACETOOLARGE_FACTOR 3\n\n \n#define ZSTD_WORKSPACETOOLARGE_MAXDURATION 128\n\n\n \ntypedef struct seqDef_s {\n    U32 offset;\n    U16 litLength;\n    U16 matchLength;\n} seqDef;\n\ntypedef struct {\n    seqDef* sequencesStart;\n    seqDef* sequences;\n    BYTE* litStart;\n    BYTE* lit;\n    BYTE* llCode;\n    BYTE* mlCode;\n    BYTE* ofCode;\n    size_t maxNbSeq;\n    size_t maxNbLit;\n    U32   longLengthID;    \n    U32   longLengthPos;\n} seqStore_t;\n\ntypedef struct {\n    U32 litLength;\n    U32 matchLength;\n} ZSTD_sequenceLength;\n\n \nMEM_STATIC ZSTD_sequenceLength ZSTD_getSequenceLength(seqStore_t const* seqStore, seqDef const* seq)\n{\n    ZSTD_sequenceLength seqLen;\n    seqLen.litLength = seq->litLength;\n    seqLen.matchLength = seq->matchLength + MINMATCH;\n    if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {\n        if (seqStore->longLengthID == 1) {\n            seqLen.litLength += 0xFFFF;\n        }\n        if (seqStore->longLengthID == 2) {\n            seqLen.matchLength += 0xFFFF;\n        }\n    }\n    return seqLen;\n}\n\n \ntypedef struct {\n    size_t compressedSize;\n    unsigned long long decompressedBound;\n} ZSTD_frameSizeInfo;    \n\nconst seqStore_t* ZSTD_getSeqStore(const ZSTD_CCtx* ctx);    \nvoid ZSTD_seqToCodes(const seqStore_t* seqStorePtr);    \n\n \nvoid* ZSTD_malloc(size_t size, ZSTD_customMem customMem);\nvoid* ZSTD_calloc(size_t size, ZSTD_customMem customMem);\nvoid ZSTD_free(void* ptr, ZSTD_customMem customMem);\n\n\nMEM_STATIC U32 ZSTD_highbit32(U32 val)    \n{\n    assert(val != 0);\n    {\n#   if defined(_MSC_VER)    \n        unsigned long r=0;\n        return _BitScanReverse(&r, val) ? (unsigned)r : 0;\n#   elif defined(__GNUC__) && (__GNUC__ >= 3)    \n        return __builtin_clz (val) ^ 31;\n#   elif defined(__ICCARM__)     \n        return 31 - __CLZ(val);\n#   else    \n        static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };\n        U32 v = val;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];\n#   endif\n    }\n}\n\n\n \nvoid ZSTD_invalidateRepCodes(ZSTD_CCtx* cctx);    \n\n\ntypedef struct {\n    blockType_e blockType;\n    U32 lastBlock;\n    U32 origSize;\n} blockProperties_t;    \n\n \n \nsize_t ZSTD_getcBlockSize(const void* src, size_t srcSize,\n                          blockProperties_t* bpPtr);\n\n \n \nsize_t ZSTD_decodeSeqHeaders(ZSTD_DCtx* dctx, int* nbSeqPtr,\n                       const void* src, size_t srcSize);\n\n\n#if defined (__cplusplus)\n}\n#endif\n\n#endif    \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}