{
  "module_name": "fse.h",
  "hash_id": "065b38384795030573649cd6a4f4880d70d61cef3dd8fd83257808d80da5197d",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/common/fse.h",
  "human_readable_source": " \n\n#if defined (__cplusplus)\nextern \"C\" {\n#endif\n\n#ifndef FSE_H\n#define FSE_H\n\n\n \n#include <stddef.h>     \n\n\n \n#if defined(FSE_DLL_EXPORT) && (FSE_DLL_EXPORT==1) && defined(__GNUC__) && (__GNUC__ >= 4)\n#  define FSE_PUBLIC_API __attribute__ ((visibility (\"default\")))\n#elif defined(FSE_DLL_EXPORT) && (FSE_DLL_EXPORT==1)    \n#  define FSE_PUBLIC_API __declspec(dllexport)\n#elif defined(FSE_DLL_IMPORT) && (FSE_DLL_IMPORT==1)\n#  define FSE_PUBLIC_API __declspec(dllimport)  \n#else\n#  define FSE_PUBLIC_API\n#endif\n\n \n#define FSE_VERSION_MAJOR    0\n#define FSE_VERSION_MINOR    9\n#define FSE_VERSION_RELEASE  0\n\n#define FSE_LIB_VERSION FSE_VERSION_MAJOR.FSE_VERSION_MINOR.FSE_VERSION_RELEASE\n#define FSE_QUOTE(str) #str\n#define FSE_EXPAND_AND_QUOTE(str) FSE_QUOTE(str)\n#define FSE_VERSION_STRING FSE_EXPAND_AND_QUOTE(FSE_LIB_VERSION)\n\n#define FSE_VERSION_NUMBER  (FSE_VERSION_MAJOR *100*100 + FSE_VERSION_MINOR *100 + FSE_VERSION_RELEASE)\nFSE_PUBLIC_API unsigned FSE_versionNumber(void);    \n\n\n \n \nFSE_PUBLIC_API size_t FSE_compress(void* dst, size_t dstCapacity,\n                             const void* src, size_t srcSize);\n\n \nFSE_PUBLIC_API size_t FSE_decompress(void* dst,  size_t dstCapacity,\n                               const void* cSrc, size_t cSrcSize);\n\n\n \nFSE_PUBLIC_API size_t FSE_compressBound(size_t size);        \n\n \nFSE_PUBLIC_API unsigned    FSE_isError(size_t code);         \nFSE_PUBLIC_API const char* FSE_getErrorName(size_t code);    \n\n\n \n \nFSE_PUBLIC_API size_t FSE_compress2 (void* dst, size_t dstSize, const void* src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog);\n\n\n \n \n\n \n\n \nFSE_PUBLIC_API unsigned FSE_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue);\n\n \nFSE_PUBLIC_API size_t FSE_normalizeCount(short* normalizedCounter, unsigned tableLog,\n                    const unsigned* count, size_t srcSize, unsigned maxSymbolValue);\n\n \nFSE_PUBLIC_API size_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog);\n\n \nFSE_PUBLIC_API size_t FSE_writeNCount (void* buffer, size_t bufferSize,\n                                 const short* normalizedCounter,\n                                 unsigned maxSymbolValue, unsigned tableLog);\n\n \ntypedef unsigned FSE_CTable;    \nFSE_PUBLIC_API FSE_CTable* FSE_createCTable (unsigned maxSymbolValue, unsigned tableLog);\nFSE_PUBLIC_API void        FSE_freeCTable (FSE_CTable* ct);\n\n \nFSE_PUBLIC_API size_t FSE_buildCTable(FSE_CTable* ct, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog);\n\n \nFSE_PUBLIC_API size_t FSE_compress_usingCTable (void* dst, size_t dstCapacity, const void* src, size_t srcSize, const FSE_CTable* ct);\n\n \n\n\n \n\n \nFSE_PUBLIC_API size_t FSE_readNCount (short* normalizedCounter,\n                           unsigned* maxSymbolValuePtr, unsigned* tableLogPtr,\n                           const void* rBuffer, size_t rBuffSize);\n\n \ntypedef unsigned FSE_DTable;    \nFSE_PUBLIC_API FSE_DTable* FSE_createDTable(unsigned tableLog);\nFSE_PUBLIC_API void        FSE_freeDTable(FSE_DTable* dt);\n\n \nFSE_PUBLIC_API size_t FSE_buildDTable (FSE_DTable* dt, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog);\n\n \nFSE_PUBLIC_API size_t FSE_decompress_usingDTable(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, const FSE_DTable* dt);\n\n \n\n#endif   \n\n#if defined(FSE_STATIC_LINKING_ONLY) && !defined(FSE_H_FSE_STATIC_LINKING_ONLY)\n#define FSE_H_FSE_STATIC_LINKING_ONLY\n\n \n#include \"bitstream.h\"\n\n\n \n \n#define FSE_NCOUNTBOUND 512\n#define FSE_BLOCKBOUND(size) (size + (size>>7) + 4   + sizeof(size_t)  )\n#define FSE_COMPRESSBOUND(size) (FSE_NCOUNTBOUND + FSE_BLOCKBOUND(size))    \n\n \n#define FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue)   (1 + (1<<(maxTableLog-1)) + ((maxSymbolValue+1)*2))\n#define FSE_DTABLE_SIZE_U32(maxTableLog)                   (1 + (1<<maxTableLog))\n\n \n#define FSE_CTABLE_SIZE(maxTableLog, maxSymbolValue)   (FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(FSE_CTable))\n#define FSE_DTABLE_SIZE(maxTableLog)                   (FSE_DTABLE_SIZE_U32(maxTableLog) * sizeof(FSE_DTable))\n\n\n \n\nunsigned FSE_optimalTableLog_internal(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, unsigned minus);\n \n\n \n#define FSE_WKSP_SIZE_U32(maxTableLog, maxSymbolValue)   ( FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) + ((maxTableLog > 12) ? (1 << (maxTableLog - 2)) : 1024) )\nsize_t FSE_compress_wksp (void* dst, size_t dstSize, const void* src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize);\n\nsize_t FSE_buildCTable_raw (FSE_CTable* ct, unsigned nbBits);\n \n\nsize_t FSE_buildCTable_rle (FSE_CTable* ct, unsigned char symbolValue);\n \n\n \nsize_t FSE_buildCTable_wksp(FSE_CTable* ct, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize);\n\nsize_t FSE_buildDTable_raw (FSE_DTable* dt, unsigned nbBits);\n \n\nsize_t FSE_buildDTable_rle (FSE_DTable* dt, unsigned char symbolValue);\n \n\nsize_t FSE_decompress_wksp(void* dst, size_t dstCapacity, const void* cSrc, size_t cSrcSize, FSE_DTable* workSpace, unsigned maxLog);\n \n\ntypedef enum {\n   FSE_repeat_none,   \n   FSE_repeat_check,  \n   FSE_repeat_valid   \n } FSE_repeat;\n\n \n \ntypedef struct {\n    ptrdiff_t   value;\n    const void* stateTable;\n    const void* symbolTT;\n    unsigned    stateLog;\n} FSE_CState_t;\n\nstatic void FSE_initCState(FSE_CState_t* CStatePtr, const FSE_CTable* ct);\n\nstatic void FSE_encodeSymbol(BIT_CStream_t* bitC, FSE_CState_t* CStatePtr, unsigned symbol);\n\nstatic void FSE_flushCState(BIT_CStream_t* bitC, const FSE_CState_t* CStatePtr);\n\n \n\n\n \ntypedef struct {\n    size_t      state;\n    const void* table;    \n} FSE_DState_t;\n\n\nstatic void     FSE_initDState(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD, const FSE_DTable* dt);\n\nstatic unsigned char FSE_decodeSymbol(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD);\n\nstatic unsigned FSE_endOfDState(const FSE_DState_t* DStatePtr);\n\n \n\n\n \nstatic unsigned char FSE_decodeSymbolFast(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD);\n \n\n\n \ntypedef struct {\n    int deltaFindState;\n    U32 deltaNbBits;\n} FSE_symbolCompressionTransform;  \n\nMEM_STATIC void FSE_initCState(FSE_CState_t* statePtr, const FSE_CTable* ct)\n{\n    const void* ptr = ct;\n    const U16* u16ptr = (const U16*) ptr;\n    const U32 tableLog = MEM_read16(ptr);\n    statePtr->value = (ptrdiff_t)1<<tableLog;\n    statePtr->stateTable = u16ptr+2;\n    statePtr->symbolTT = ct + 1 + (tableLog ? (1<<(tableLog-1)) : 1);\n    statePtr->stateLog = tableLog;\n}\n\n\n \nMEM_STATIC void FSE_initCState2(FSE_CState_t* statePtr, const FSE_CTable* ct, U32 symbol)\n{\n    FSE_initCState(statePtr, ct);\n    {   const FSE_symbolCompressionTransform symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];\n        const U16* stateTable = (const U16*)(statePtr->stateTable);\n        U32 nbBitsOut  = (U32)((symbolTT.deltaNbBits + (1<<15)) >> 16);\n        statePtr->value = (nbBitsOut << 16) - symbolTT.deltaNbBits;\n        statePtr->value = stateTable[(statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];\n    }\n}\n\nMEM_STATIC void FSE_encodeSymbol(BIT_CStream_t* bitC, FSE_CState_t* statePtr, unsigned symbol)\n{\n    FSE_symbolCompressionTransform const symbolTT = ((const FSE_symbolCompressionTransform*)(statePtr->symbolTT))[symbol];\n    const U16* const stateTable = (const U16*)(statePtr->stateTable);\n    U32 const nbBitsOut  = (U32)((statePtr->value + symbolTT.deltaNbBits) >> 16);\n    BIT_addBits(bitC, statePtr->value, nbBitsOut);\n    statePtr->value = stateTable[ (statePtr->value >> nbBitsOut) + symbolTT.deltaFindState];\n}\n\nMEM_STATIC void FSE_flushCState(BIT_CStream_t* bitC, const FSE_CState_t* statePtr)\n{\n    BIT_addBits(bitC, statePtr->value, statePtr->stateLog);\n    BIT_flushBits(bitC);\n}\n\n\n \nMEM_STATIC U32 FSE_getMaxNbBits(const void* symbolTTPtr, U32 symbolValue)\n{\n    const FSE_symbolCompressionTransform* symbolTT = (const FSE_symbolCompressionTransform*) symbolTTPtr;\n    return (symbolTT[symbolValue].deltaNbBits + ((1<<16)-1)) >> 16;\n}\n\n \nMEM_STATIC U32 FSE_bitCost(const void* symbolTTPtr, U32 tableLog, U32 symbolValue, U32 accuracyLog)\n{\n    const FSE_symbolCompressionTransform* symbolTT = (const FSE_symbolCompressionTransform*) symbolTTPtr;\n    U32 const minNbBits = symbolTT[symbolValue].deltaNbBits >> 16;\n    U32 const threshold = (minNbBits+1) << 16;\n    assert(tableLog < 16);\n    assert(accuracyLog < 31-tableLog);   \n    {   U32 const tableSize = 1 << tableLog;\n        U32 const deltaFromThreshold = threshold - (symbolTT[symbolValue].deltaNbBits + tableSize);\n        U32 const normalizedDeltaFromThreshold = (deltaFromThreshold << accuracyLog) >> tableLog;    \n        U32 const bitMultiplier = 1 << accuracyLog;\n        assert(symbolTT[symbolValue].deltaNbBits + tableSize <= threshold);\n        assert(normalizedDeltaFromThreshold <= bitMultiplier);\n        return (minNbBits+1)*bitMultiplier - normalizedDeltaFromThreshold;\n    }\n}\n\n\n \n\ntypedef struct {\n    U16 tableLog;\n    U16 fastMode;\n} FSE_DTableHeader;    \n\ntypedef struct\n{\n    unsigned short newState;\n    unsigned char  symbol;\n    unsigned char  nbBits;\n} FSE_decode_t;    \n\nMEM_STATIC void FSE_initDState(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD, const FSE_DTable* dt)\n{\n    const void* ptr = dt;\n    const FSE_DTableHeader* const DTableH = (const FSE_DTableHeader*)ptr;\n    DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);\n    BIT_reloadDStream(bitD);\n    DStatePtr->table = dt + 1;\n}\n\nMEM_STATIC BYTE FSE_peekSymbol(const FSE_DState_t* DStatePtr)\n{\n    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];\n    return DInfo.symbol;\n}\n\nMEM_STATIC void FSE_updateState(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD)\n{\n    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];\n    U32 const nbBits = DInfo.nbBits;\n    size_t const lowBits = BIT_readBits(bitD, nbBits);\n    DStatePtr->state = DInfo.newState + lowBits;\n}\n\nMEM_STATIC BYTE FSE_decodeSymbol(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD)\n{\n    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];\n    U32 const nbBits = DInfo.nbBits;\n    BYTE const symbol = DInfo.symbol;\n    size_t const lowBits = BIT_readBits(bitD, nbBits);\n\n    DStatePtr->state = DInfo.newState + lowBits;\n    return symbol;\n}\n\n \nMEM_STATIC BYTE FSE_decodeSymbolFast(FSE_DState_t* DStatePtr, BIT_DStream_t* bitD)\n{\n    FSE_decode_t const DInfo = ((const FSE_decode_t*)(DStatePtr->table))[DStatePtr->state];\n    U32 const nbBits = DInfo.nbBits;\n    BYTE const symbol = DInfo.symbol;\n    size_t const lowBits = BIT_readBitsFast(bitD, nbBits);\n\n    DStatePtr->state = DInfo.newState + lowBits;\n    return symbol;\n}\n\nMEM_STATIC unsigned FSE_endOfDState(const FSE_DState_t* DStatePtr)\n{\n    return DStatePtr->state == 0;\n}\n\n\n\n#ifndef FSE_COMMONDEFS_ONLY\n\n \n \n#ifndef FSE_MAX_MEMORY_USAGE\n#  define FSE_MAX_MEMORY_USAGE 14\n#endif\n#ifndef FSE_DEFAULT_MEMORY_USAGE\n#  define FSE_DEFAULT_MEMORY_USAGE 13\n#endif\n\n \n#ifndef FSE_MAX_SYMBOL_VALUE\n#  define FSE_MAX_SYMBOL_VALUE 255\n#endif\n\n \n#define FSE_FUNCTION_TYPE BYTE\n#define FSE_FUNCTION_EXTENSION\n#define FSE_DECODE_TYPE FSE_decode_t\n\n\n#endif    \n\n\n \n#define FSE_MAX_TABLELOG  (FSE_MAX_MEMORY_USAGE-2)\n#define FSE_MAX_TABLESIZE (1U<<FSE_MAX_TABLELOG)\n#define FSE_MAXTABLESIZE_MASK (FSE_MAX_TABLESIZE-1)\n#define FSE_DEFAULT_TABLELOG (FSE_DEFAULT_MEMORY_USAGE-2)\n#define FSE_MIN_TABLELOG 5\n\n#define FSE_TABLELOG_ABSOLUTE_MAX 15\n#if FSE_MAX_TABLELOG > FSE_TABLELOG_ABSOLUTE_MAX\n#  error \"FSE_MAX_TABLELOG > FSE_TABLELOG_ABSOLUTE_MAX is not supported\"\n#endif\n\n#define FSE_TABLESTEP(tableSize) ((tableSize>>1) + (tableSize>>3) + 3)\n\n\n#endif  \n\n\n#if defined (__cplusplus)\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}