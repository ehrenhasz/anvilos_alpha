{
  "module_name": "huf_compress.c",
  "hash_id": "5debb6df369d35485078f1a1369aec9ed7e26fa4269d4ce6e5870c24cfff456c",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/huf_compress.c",
  "human_readable_source": " \n\n \n#ifdef _MSC_VER     \n#  pragma warning(disable : 4127)         \n#endif\n\n\n \n#include <string.h>      \n#include <stdio.h>       \n#include \"../common/compiler.h\"\n#include \"../common/bitstream.h\"\n#include \"hist.h\"\n#define FSE_STATIC_LINKING_ONLY    \n#include \"../common/fse.h\"         \n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include \"../common/error_private.h\"\n\n\n \n#define HUF_isError ERR_isError\n#define HUF_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)    \n\n\n \nunsigned HUF_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)\n{\n    return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 1);\n}\n\n\n \n \n#define MAX_FSE_TABLELOG_FOR_HUFF_HEADER 6\nstatic size_t HUF_compressWeights (void* dst, size_t dstSize, const void* weightTable, size_t wtSize)\n{\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* op = ostart;\n    BYTE* const oend = ostart + dstSize;\n\n    unsigned maxSymbolValue = HUF_TABLELOG_MAX;\n    U32 tableLog = MAX_FSE_TABLELOG_FOR_HUFF_HEADER;\n\n    FSE_CTable CTable[FSE_CTABLE_SIZE_U32(MAX_FSE_TABLELOG_FOR_HUFF_HEADER, HUF_TABLELOG_MAX)];\n    BYTE scratchBuffer[1<<MAX_FSE_TABLELOG_FOR_HUFF_HEADER];\n\n    unsigned count[HUF_TABLELOG_MAX+1];\n    S16 norm[HUF_TABLELOG_MAX+1];\n\n     \n    if (wtSize <= 1) return 0;   \n\n     \n    {   unsigned const maxCount = HIST_count_simple(count, &maxSymbolValue, weightTable, wtSize);    \n        if (maxCount == wtSize) return 1;    \n        if (maxCount == 1) return 0;         \n    }\n\n    tableLog = FSE_optimalTableLog(tableLog, wtSize, maxSymbolValue);\n    CHECK_F( FSE_normalizeCount(norm, tableLog, count, wtSize, maxSymbolValue) );\n\n     \n    {   CHECK_V_F(hSize, FSE_writeNCount(op, (size_t)(oend-op), norm, maxSymbolValue, tableLog) );\n        op += hSize;\n    }\n\n     \n    CHECK_F( FSE_buildCTable_wksp(CTable, norm, maxSymbolValue, tableLog, scratchBuffer, sizeof(scratchBuffer)) );\n    {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, CTable) );\n        if (cSize == 0) return 0;    \n        op += cSize;\n    }\n\n    return (size_t)(op-ostart);\n}\n\n\nstruct HUF_CElt_s {\n  U16  val;\n  BYTE nbBits;\n};    \n\n \nsize_t HUF_writeCTable (void* dst, size_t maxDstSize,\n                        const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog)\n{\n    BYTE bitsToWeight[HUF_TABLELOG_MAX + 1];    \n    BYTE huffWeight[HUF_SYMBOLVALUE_MAX];\n    BYTE* op = (BYTE*)dst;\n    U32 n;\n\n      \n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n\n     \n    bitsToWeight[0] = 0;\n    for (n=1; n<huffLog+1; n++)\n        bitsToWeight[n] = (BYTE)(huffLog + 1 - n);\n    for (n=0; n<maxSymbolValue; n++)\n        huffWeight[n] = bitsToWeight[CTable[n].nbBits];\n\n     \n    {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, huffWeight, maxSymbolValue) );\n        if ((hSize>1) & (hSize < maxSymbolValue/2)) {    \n            op[0] = (BYTE)hSize;\n            return hSize+1;\n    }   }\n\n     \n    if (maxSymbolValue > (256-128)) return ERROR(GENERIC);    \n    if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);    \n    op[0] = (BYTE)(128   + (maxSymbolValue-1));\n    huffWeight[maxSymbolValue] = 0;    \n    for (n=0; n<maxSymbolValue; n+=2)\n        op[(n/2)+1] = (BYTE)((huffWeight[n] << 4) + huffWeight[n+1]);\n    return ((maxSymbolValue+1)/2) + 1;\n}\n\n\nsize_t HUF_readCTable (HUF_CElt* CTable, unsigned* maxSymbolValuePtr, const void* src, size_t srcSize, unsigned* hasZeroWeights)\n{\n    BYTE huffWeight[HUF_SYMBOLVALUE_MAX + 1];    \n    U32 rankVal[HUF_TABLELOG_ABSOLUTEMAX + 1];    \n    U32 tableLog = 0;\n    U32 nbSymbols = 0;\n\n     \n    CHECK_V_F(readSize, HUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX+1, rankVal, &nbSymbols, &tableLog, src, srcSize));\n\n     \n    if (tableLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    if (nbSymbols > *maxSymbolValuePtr+1) return ERROR(maxSymbolValue_tooSmall);\n\n     \n    {   U32 n, nextRankStart = 0;\n        for (n=1; n<=tableLog; n++) {\n            U32 current = nextRankStart;\n            nextRankStart += (rankVal[n] << (n-1));\n            rankVal[n] = current;\n    }   }\n\n     \n    *hasZeroWeights = 0;\n    {   U32 n; for (n=0; n<nbSymbols; n++) {\n            const U32 w = huffWeight[n];\n            *hasZeroWeights |= (w == 0);\n            CTable[n].nbBits = (BYTE)(tableLog + 1 - w) & -(w != 0);\n    }   }\n\n     \n    {   U16 nbPerRank[HUF_TABLELOG_MAX+2]  = {0};   \n        U16 valPerRank[HUF_TABLELOG_MAX+2] = {0};\n        { U32 n; for (n=0; n<nbSymbols; n++) nbPerRank[CTable[n].nbBits]++; }\n         \n        valPerRank[tableLog+1] = 0;    \n        {   U16 min = 0;\n            U32 n; for (n=tableLog; n>0; n--) {   \n                valPerRank[n] = min;      \n                min += nbPerRank[n];\n                min >>= 1;\n        }   }\n         \n        { U32 n; for (n=0; n<nbSymbols; n++) CTable[n].val = valPerRank[CTable[n].nbBits]++; }\n    }\n\n    *maxSymbolValuePtr = nbSymbols - 1;\n    return readSize;\n}\n\nU32 HUF_getNbBits(const void* symbolTable, U32 symbolValue)\n{\n    const HUF_CElt* table = (const HUF_CElt*)symbolTable;\n    assert(symbolValue <= HUF_SYMBOLVALUE_MAX);\n    return table[symbolValue].nbBits;\n}\n\n\ntypedef struct nodeElt_s {\n    U32 count;\n    U16 parent;\n    BYTE byte;\n    BYTE nbBits;\n} nodeElt;\n\nstatic U32 HUF_setMaxHeight(nodeElt* huffNode, U32 lastNonNull, U32 maxNbBits)\n{\n    const U32 largestBits = huffNode[lastNonNull].nbBits;\n    if (largestBits <= maxNbBits) return largestBits;    \n\n     \n    {   int totalCost = 0;\n        const U32 baseCost = 1 << (largestBits - maxNbBits);\n        int n = (int)lastNonNull;\n\n        while (huffNode[n].nbBits > maxNbBits) {\n            totalCost += baseCost - (1 << (largestBits - huffNode[n].nbBits));\n            huffNode[n].nbBits = (BYTE)maxNbBits;\n            n --;\n        }   \n        while (huffNode[n].nbBits == maxNbBits) n--;    \n\n         \n        totalCost >>= (largestBits - maxNbBits);   \n\n         \n        {   U32 const noSymbol = 0xF0F0F0F0;\n            U32 rankLast[HUF_TABLELOG_MAX+2];\n\n             \n            memset(rankLast, 0xF0, sizeof(rankLast));\n            {   U32 currentNbBits = maxNbBits;\n                int pos;\n                for (pos=n ; pos >= 0; pos--) {\n                    if (huffNode[pos].nbBits >= currentNbBits) continue;\n                    currentNbBits = huffNode[pos].nbBits;    \n                    rankLast[maxNbBits-currentNbBits] = (U32)pos;\n            }   }\n\n            while (totalCost > 0) {\n                U32 nBitsToDecrease = BIT_highbit32((U32)totalCost) + 1;\n                for ( ; nBitsToDecrease > 1; nBitsToDecrease--) {\n                    U32 const highPos = rankLast[nBitsToDecrease];\n                    U32 const lowPos = rankLast[nBitsToDecrease-1];\n                    if (highPos == noSymbol) continue;\n                    if (lowPos == noSymbol) break;\n                    {   U32 const highTotal = huffNode[highPos].count;\n                        U32 const lowTotal = 2 * huffNode[lowPos].count;\n                        if (highTotal <= lowTotal) break;\n                }   }\n                 \n                 \n                while ((nBitsToDecrease<=HUF_TABLELOG_MAX) && (rankLast[nBitsToDecrease] == noSymbol))\n                    nBitsToDecrease ++;\n                totalCost -= 1 << (nBitsToDecrease-1);\n                if (rankLast[nBitsToDecrease-1] == noSymbol)\n                    rankLast[nBitsToDecrease-1] = rankLast[nBitsToDecrease];    \n                huffNode[rankLast[nBitsToDecrease]].nbBits ++;\n                if (rankLast[nBitsToDecrease] == 0)     \n                    rankLast[nBitsToDecrease] = noSymbol;\n                else {\n                    rankLast[nBitsToDecrease]--;\n                    if (huffNode[rankLast[nBitsToDecrease]].nbBits != maxNbBits-nBitsToDecrease)\n                        rankLast[nBitsToDecrease] = noSymbol;    \n            }   }    \n\n            while (totalCost < 0) {   \n                if (rankLast[1] == noSymbol) {   \n                    while (huffNode[n].nbBits == maxNbBits) n--;\n                    huffNode[n+1].nbBits--;\n                    assert(n >= 0);\n                    rankLast[1] = (U32)(n+1);\n                    totalCost++;\n                    continue;\n                }\n                huffNode[ rankLast[1] + 1 ].nbBits--;\n                rankLast[1]++;\n                totalCost ++;\n    }   }   }    \n\n    return maxNbBits;\n}\n\ntypedef struct {\n    U32 base;\n    U32 current;\n} rankPos;\n\ntypedef nodeElt huffNodeTable[HUF_CTABLE_WORKSPACE_SIZE_U32];\n\n#define RANK_POSITION_TABLE_SIZE 32\n\ntypedef struct {\n  huffNodeTable huffNodeTbl;\n  rankPos rankPosition[RANK_POSITION_TABLE_SIZE];\n} HUF_buildCTable_wksp_tables;\n\nstatic void HUF_sort(nodeElt* huffNode, const unsigned* count, U32 maxSymbolValue, rankPos* rankPosition)\n{\n    U32 n;\n\n    memset(rankPosition, 0, sizeof(*rankPosition) * RANK_POSITION_TABLE_SIZE);\n    for (n=0; n<=maxSymbolValue; n++) {\n        U32 r = BIT_highbit32(count[n] + 1);\n        rankPosition[r].base ++;\n    }\n    for (n=30; n>0; n--) rankPosition[n-1].base += rankPosition[n].base;\n    for (n=0; n<32; n++) rankPosition[n].current = rankPosition[n].base;\n    for (n=0; n<=maxSymbolValue; n++) {\n        U32 const c = count[n];\n        U32 const r = BIT_highbit32(c+1) + 1;\n        U32 pos = rankPosition[r].current++;\n        while ((pos > rankPosition[r].base) && (c > huffNode[pos-1].count)) {\n            huffNode[pos] = huffNode[pos-1];\n            pos--;\n        }\n        huffNode[pos].count = c;\n        huffNode[pos].byte  = (BYTE)n;\n    }\n}\n\n\n \n#define STARTNODE (HUF_SYMBOLVALUE_MAX+1)\n\nsize_t HUF_buildCTable_wksp (HUF_CElt* tree, const unsigned* count, U32 maxSymbolValue, U32 maxNbBits, void* workSpace, size_t wkspSize)\n{\n    HUF_buildCTable_wksp_tables* const wksp_tables = (HUF_buildCTable_wksp_tables*)workSpace;\n    nodeElt* const huffNode0 = wksp_tables->huffNodeTbl;\n    nodeElt* const huffNode = huffNode0+1;\n    int nonNullRank;\n    int lowS, lowN;\n    int nodeNb = STARTNODE;\n    int n, nodeRoot;\n\n     \n    if (((size_t)workSpace & 3) != 0) return ERROR(GENERIC);   \n    if (wkspSize < sizeof(HUF_buildCTable_wksp_tables))\n      return ERROR(workSpace_tooSmall);\n    if (maxNbBits == 0) maxNbBits = HUF_TABLELOG_DEFAULT;\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX)\n      return ERROR(maxSymbolValue_tooLarge);\n    memset(huffNode0, 0, sizeof(huffNodeTable));\n\n     \n    HUF_sort(huffNode, count, maxSymbolValue, wksp_tables->rankPosition);\n\n     \n    nonNullRank = (int)maxSymbolValue;\n    while(huffNode[nonNullRank].count == 0) nonNullRank--;\n    lowS = nonNullRank; nodeRoot = nodeNb + lowS - 1; lowN = nodeNb;\n    huffNode[nodeNb].count = huffNode[lowS].count + huffNode[lowS-1].count;\n    huffNode[lowS].parent = huffNode[lowS-1].parent = (U16)nodeNb;\n    nodeNb++; lowS-=2;\n    for (n=nodeNb; n<=nodeRoot; n++) huffNode[n].count = (U32)(1U<<30);\n    huffNode0[0].count = (U32)(1U<<31);   \n\n     \n    while (nodeNb <= nodeRoot) {\n        int const n1 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;\n        int const n2 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;\n        huffNode[nodeNb].count = huffNode[n1].count + huffNode[n2].count;\n        huffNode[n1].parent = huffNode[n2].parent = (U16)nodeNb;\n        nodeNb++;\n    }\n\n     \n    huffNode[nodeRoot].nbBits = 0;\n    for (n=nodeRoot-1; n>=STARTNODE; n--)\n        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;\n    for (n=0; n<=nonNullRank; n++)\n        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;\n\n     \n    maxNbBits = HUF_setMaxHeight(huffNode, (U32)nonNullRank, maxNbBits);\n\n     \n    {   U16 nbPerRank[HUF_TABLELOG_MAX+1] = {0};\n        U16 valPerRank[HUF_TABLELOG_MAX+1] = {0};\n        int const alphabetSize = (int)(maxSymbolValue + 1);\n        if (maxNbBits > HUF_TABLELOG_MAX) return ERROR(GENERIC);    \n        for (n=0; n<=nonNullRank; n++)\n            nbPerRank[huffNode[n].nbBits]++;\n         \n        {   U16 min = 0;\n            for (n=(int)maxNbBits; n>0; n--) {\n                valPerRank[n] = min;       \n                min += nbPerRank[n];\n                min >>= 1;\n        }   }\n        for (n=0; n<alphabetSize; n++)\n            tree[huffNode[n].byte].nbBits = huffNode[n].nbBits;    \n        for (n=0; n<alphabetSize; n++)\n            tree[n].val = valPerRank[tree[n].nbBits]++;    \n    }\n\n    return maxNbBits;\n}\n\n \nsize_t HUF_buildCTable (HUF_CElt* tree, const unsigned* count, unsigned maxSymbolValue, unsigned maxNbBits)\n{\n    HUF_buildCTable_wksp_tables workspace;\n    return HUF_buildCTable_wksp(tree, count, maxSymbolValue, maxNbBits, &workspace, sizeof(workspace));\n}\n\nsize_t HUF_estimateCompressedSize(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue)\n{\n    size_t nbBits = 0;\n    int s;\n    for (s = 0; s <= (int)maxSymbolValue; ++s) {\n        nbBits += CTable[s].nbBits * count[s];\n    }\n    return nbBits >> 3;\n}\n\nint HUF_validateCTable(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue) {\n  int bad = 0;\n  int s;\n  for (s = 0; s <= (int)maxSymbolValue; ++s) {\n    bad |= (count[s] != 0) & (CTable[s].nbBits == 0);\n  }\n  return !bad;\n}\n\nsize_t HUF_compressBound(size_t size) { return HUF_COMPRESSBOUND(size); }\n\nFORCE_INLINE_TEMPLATE void\nHUF_encodeSymbol(BIT_CStream_t* bitCPtr, U32 symbol, const HUF_CElt* CTable)\n{\n    BIT_addBitsFast(bitCPtr, CTable[symbol].val, CTable[symbol].nbBits);\n}\n\n#define HUF_FLUSHBITS(s)  BIT_flushBits(s)\n\n#define HUF_FLUSHBITS_1(stream) \\\n    if (sizeof((stream)->bitContainer)*8 < HUF_TABLELOG_MAX*2+7) HUF_FLUSHBITS(stream)\n\n#define HUF_FLUSHBITS_2(stream) \\\n    if (sizeof((stream)->bitContainer)*8 < HUF_TABLELOG_MAX*4+7) HUF_FLUSHBITS(stream)\n\nFORCE_INLINE_TEMPLATE size_t\nHUF_compress1X_usingCTable_internal_body(void* dst, size_t dstSize,\n                                   const void* src, size_t srcSize,\n                                   const HUF_CElt* CTable)\n{\n    const BYTE* ip = (const BYTE*) src;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n    size_t n;\n    BIT_CStream_t bitC;\n\n     \n    if (dstSize < 8) return 0;    \n    { size_t const initErr = BIT_initCStream(&bitC, op, (size_t)(oend-op));\n      if (HUF_isError(initErr)) return 0; }\n\n    n = srcSize & ~3;   \n    switch (srcSize & 3)\n    {\n        case 3 : HUF_encodeSymbol(&bitC, ip[n+ 2], CTable);\n                 HUF_FLUSHBITS_2(&bitC);\n\t\t  \n        case 2 : HUF_encodeSymbol(&bitC, ip[n+ 1], CTable);\n                 HUF_FLUSHBITS_1(&bitC);\n\t\t  \n        case 1 : HUF_encodeSymbol(&bitC, ip[n+ 0], CTable);\n                 HUF_FLUSHBITS(&bitC);\n\t\t  \n        case 0 :  \n        default: break;\n    }\n\n    for (; n>0; n-=4) {   \n        HUF_encodeSymbol(&bitC, ip[n- 1], CTable);\n        HUF_FLUSHBITS_1(&bitC);\n        HUF_encodeSymbol(&bitC, ip[n- 2], CTable);\n        HUF_FLUSHBITS_2(&bitC);\n        HUF_encodeSymbol(&bitC, ip[n- 3], CTable);\n        HUF_FLUSHBITS_1(&bitC);\n        HUF_encodeSymbol(&bitC, ip[n- 4], CTable);\n        HUF_FLUSHBITS(&bitC);\n    }\n\n    return BIT_closeCStream(&bitC);\n}\n\n#if DYNAMIC_BMI2\n\nstatic TARGET_ATTRIBUTE(\"bmi2\") size_t\nHUF_compress1X_usingCTable_internal_bmi2(void* dst, size_t dstSize,\n                                   const void* src, size_t srcSize,\n                                   const HUF_CElt* CTable)\n{\n    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);\n}\n\nstatic size_t\nHUF_compress1X_usingCTable_internal_default(void* dst, size_t dstSize,\n                                      const void* src, size_t srcSize,\n                                      const HUF_CElt* CTable)\n{\n    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);\n}\n\nstatic size_t\nHUF_compress1X_usingCTable_internal(void* dst, size_t dstSize,\n                              const void* src, size_t srcSize,\n                              const HUF_CElt* CTable, const int bmi2)\n{\n    if (bmi2) {\n        return HUF_compress1X_usingCTable_internal_bmi2(dst, dstSize, src, srcSize, CTable);\n    }\n    return HUF_compress1X_usingCTable_internal_default(dst, dstSize, src, srcSize, CTable);\n}\n\n#else\n\nstatic size_t\nHUF_compress1X_usingCTable_internal(void* dst, size_t dstSize,\n                              const void* src, size_t srcSize,\n                              const HUF_CElt* CTable, const int bmi2)\n{\n    (void)bmi2;\n    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);\n}\n\n#endif\n\nsize_t HUF_compress1X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable)\n{\n    return HUF_compress1X_usingCTable_internal(dst, dstSize, src, srcSize, CTable,   0);\n}\n\n\nstatic size_t\nHUF_compress4X_usingCTable_internal(void* dst, size_t dstSize,\n                              const void* src, size_t srcSize,\n                              const HUF_CElt* CTable, int bmi2)\n{\n    size_t const segmentSize = (srcSize+3)/4;    \n    const BYTE* ip = (const BYTE*) src;\n    const BYTE* const iend = ip + srcSize;\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n\n    if (dstSize < 6 + 1 + 1 + 1 + 8) return 0;    \n    if (srcSize < 12) return 0;    \n    op += 6;    \n\n    assert(op <= oend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );\n        if (cSize==0) return 0;\n        assert(cSize <= 65535);\n        MEM_writeLE16(ostart, (U16)cSize);\n        op += cSize;\n    }\n\n    ip += segmentSize;\n    assert(op <= oend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );\n        if (cSize==0) return 0;\n        assert(cSize <= 65535);\n        MEM_writeLE16(ostart+2, (U16)cSize);\n        op += cSize;\n    }\n\n    ip += segmentSize;\n    assert(op <= oend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );\n        if (cSize==0) return 0;\n        assert(cSize <= 65535);\n        MEM_writeLE16(ostart+4, (U16)cSize);\n        op += cSize;\n    }\n\n    ip += segmentSize;\n    assert(op <= oend);\n    assert(ip <= iend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, (size_t)(iend-ip), CTable, bmi2) );\n        if (cSize==0) return 0;\n        op += cSize;\n    }\n\n    return (size_t)(op-ostart);\n}\n\nsize_t HUF_compress4X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable)\n{\n    return HUF_compress4X_usingCTable_internal(dst, dstSize, src, srcSize, CTable,   0);\n}\n\ntypedef enum { HUF_singleStream, HUF_fourStreams } HUF_nbStreams_e;\n\nstatic size_t HUF_compressCTable_internal(\n                BYTE* const ostart, BYTE* op, BYTE* const oend,\n                const void* src, size_t srcSize,\n                HUF_nbStreams_e nbStreams, const HUF_CElt* CTable, const int bmi2)\n{\n    size_t const cSize = (nbStreams==HUF_singleStream) ?\n                         HUF_compress1X_usingCTable_internal(op, (size_t)(oend - op), src, srcSize, CTable, bmi2) :\n                         HUF_compress4X_usingCTable_internal(op, (size_t)(oend - op), src, srcSize, CTable, bmi2);\n    if (HUF_isError(cSize)) { return cSize; }\n    if (cSize==0) { return 0; }    \n    op += cSize;\n     \n    assert(op >= ostart);\n    if ((size_t)(op-ostart) >= srcSize-1) { return 0; }\n    return (size_t)(op-ostart);\n}\n\ntypedef struct {\n    unsigned count[HUF_SYMBOLVALUE_MAX + 1];\n    HUF_CElt CTable[HUF_SYMBOLVALUE_MAX + 1];\n    HUF_buildCTable_wksp_tables buildCTable_wksp;\n} HUF_compress_tables_t;\n\n \nstatic size_t\nHUF_compress_internal (void* dst, size_t dstSize,\n                 const void* src, size_t srcSize,\n                       unsigned maxSymbolValue, unsigned huffLog,\n                       HUF_nbStreams_e nbStreams,\n                       void* workSpace, size_t wkspSize,\n                       HUF_CElt* oldHufTable, HUF_repeat* repeat, int preferRepeat,\n                 const int bmi2)\n{\n    HUF_compress_tables_t* const table = (HUF_compress_tables_t*)workSpace;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n\n    HUF_STATIC_ASSERT(sizeof(*table) <= HUF_WORKSPACE_SIZE);\n\n     \n    if (((size_t)workSpace & 3) != 0) return ERROR(GENERIC);   \n    if (wkspSize < HUF_WORKSPACE_SIZE) return ERROR(workSpace_tooSmall);\n    if (!srcSize) return 0;   \n    if (!dstSize) return 0;   \n    if (srcSize > HUF_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);    \n    if (huffLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n    if (!maxSymbolValue) maxSymbolValue = HUF_SYMBOLVALUE_MAX;\n    if (!huffLog) huffLog = HUF_TABLELOG_DEFAULT;\n\n     \n    if (preferRepeat && repeat && *repeat == HUF_repeat_valid) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n     \n    {   CHECK_V_F(largest, HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, workSpace, wkspSize) );\n        if (largest == srcSize) { *ostart = ((const BYTE*)src)[0]; return 1; }    \n        if (largest <= (srcSize >> 7)+4) return 0;    \n    }\n\n     \n    if ( repeat\n      && *repeat == HUF_repeat_check\n      && !HUF_validateCTable(oldHufTable, table->count, maxSymbolValue)) {\n        *repeat = HUF_repeat_none;\n    }\n     \n    if (preferRepeat && repeat && *repeat != HUF_repeat_none) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n     \n    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n    {   size_t const maxBits = HUF_buildCTable_wksp(table->CTable, table->count,\n                                            maxSymbolValue, huffLog,\n                                            &table->buildCTable_wksp, sizeof(table->buildCTable_wksp));\n        CHECK_F(maxBits);\n        huffLog = (U32)maxBits;\n         \n        memset(table->CTable + (maxSymbolValue + 1), 0,\n               sizeof(table->CTable) - ((maxSymbolValue + 1) * sizeof(HUF_CElt)));\n    }\n\n     \n    {   CHECK_V_F(hSize, HUF_writeCTable (op, dstSize, table->CTable, maxSymbolValue, huffLog) );\n         \n        if (repeat && *repeat != HUF_repeat_none) {\n            size_t const oldSize = HUF_estimateCompressedSize(oldHufTable, table->count, maxSymbolValue);\n            size_t const newSize = HUF_estimateCompressedSize(table->CTable, table->count, maxSymbolValue);\n            if (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {\n                return HUF_compressCTable_internal(ostart, op, oend,\n                                                   src, srcSize,\n                                                   nbStreams, oldHufTable, bmi2);\n        }   }\n\n         \n        if (hSize + 12ul >= srcSize) { return 0; }\n        op += hSize;\n        if (repeat) { *repeat = HUF_repeat_none; }\n        if (oldHufTable)\n            memcpy(oldHufTable, table->CTable, sizeof(table->CTable));   \n    }\n    return HUF_compressCTable_internal(ostart, op, oend,\n                                       src, srcSize,\n                                       nbStreams, table->CTable, bmi2);\n}\n\n\nsize_t HUF_compress1X_wksp (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_singleStream,\n                                 workSpace, wkspSize,\n                                 NULL, NULL, 0, 0  );\n}\n\nsize_t HUF_compress1X_repeat (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize,\n                      HUF_CElt* hufTable, HUF_repeat* repeat, int preferRepeat, int bmi2)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_singleStream,\n                                 workSpace, wkspSize, hufTable,\n                                 repeat, preferRepeat, bmi2);\n}\n\nsize_t HUF_compress1X (void* dst, size_t dstSize,\n                 const void* src, size_t srcSize,\n                 unsigned maxSymbolValue, unsigned huffLog)\n{\n    unsigned workSpace[HUF_WORKSPACE_SIZE_U32];\n    return HUF_compress1X_wksp(dst, dstSize, src, srcSize, maxSymbolValue, huffLog, workSpace, sizeof(workSpace));\n}\n\n \nsize_t HUF_compress4X_wksp (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_fourStreams,\n                                 workSpace, wkspSize,\n                                 NULL, NULL, 0, 0  );\n}\n\n \nsize_t HUF_compress4X_repeat (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize,\n                      HUF_CElt* hufTable, HUF_repeat* repeat, int preferRepeat, int bmi2)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_fourStreams,\n                                 workSpace, wkspSize,\n                                 hufTable, repeat, preferRepeat, bmi2);\n}\n\nsize_t HUF_compress2 (void* dst, size_t dstSize,\n                const void* src, size_t srcSize,\n                unsigned maxSymbolValue, unsigned huffLog)\n{\n    unsigned workSpace[HUF_WORKSPACE_SIZE_U32];\n    return HUF_compress4X_wksp(dst, dstSize, src, srcSize, maxSymbolValue, huffLog, workSpace, sizeof(workSpace));\n}\n\nsize_t HUF_compress (void* dst, size_t maxDstSize, const void* src, size_t srcSize)\n{\n    return HUF_compress2(dst, maxDstSize, src, srcSize, 255, HUF_TABLELOG_DEFAULT);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}