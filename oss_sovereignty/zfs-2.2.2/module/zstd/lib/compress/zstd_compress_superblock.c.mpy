{
  "module_name": "zstd_compress_superblock.c",
  "hash_id": "09959ba665e2bf36b5b411a9363fe481b9ec2146bcd3c216c7f37bcb33c6a0ac",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/zstd_compress_superblock.c",
  "human_readable_source": " \n\n  \n#include \"zstd_compress_superblock.h\"\n\n#include \"../common/zstd_internal.h\"   \n#include \"hist.h\"                      \n#include \"zstd_compress_internal.h\"\n#include \"zstd_compress_sequences.h\"\n#include \"zstd_compress_literals.h\"\n\n \n \ntypedef struct {\n    symbolEncodingType_e hType;\n    BYTE hufDesBuffer[500];  \n    size_t hufDesSize;\n} ZSTD_hufCTablesMetadata_t;\n\n \ntypedef struct {\n    symbolEncodingType_e llType;\n    symbolEncodingType_e ofType;\n    symbolEncodingType_e mlType;\n    BYTE fseTablesBuffer[500];  \n    size_t fseTablesSize;\n    size_t lastCountSize;  \n} ZSTD_fseCTablesMetadata_t;\n\ntypedef struct {\n    ZSTD_hufCTablesMetadata_t hufMetadata;\n    ZSTD_fseCTablesMetadata_t fseMetadata;\n} ZSTD_entropyCTablesMetadata_t;\n\n\n \nstatic size_t ZSTD_buildSuperBlockEntropy_literal(void* const src, size_t srcSize,\n                                            const ZSTD_hufCTables_t* prevHuf,\n                                                  ZSTD_hufCTables_t* nextHuf,\n                                                  ZSTD_hufCTablesMetadata_t* hufMetadata,\n                                                  const int disableLiteralsCompression,\n                                                  void* workspace, size_t wkspSize)\n{\n    BYTE* const wkspStart = (BYTE*)workspace;\n    BYTE* const wkspEnd = wkspStart + wkspSize;\n    BYTE* const countWkspStart = wkspStart;\n    unsigned* const countWksp = (unsigned*)workspace;\n    const size_t countWkspSize = (HUF_SYMBOLVALUE_MAX + 1) * sizeof(unsigned);\n    BYTE* const nodeWksp = countWkspStart + countWkspSize;\n    const size_t nodeWkspSize = wkspEnd-nodeWksp;\n    unsigned maxSymbolValue = 255;\n    unsigned huffLog = HUF_TABLELOG_DEFAULT;\n    HUF_repeat repeat = prevHuf->repeatMode;\n\n    DEBUGLOG(5, \"ZSTD_buildSuperBlockEntropy_literal (srcSize=%zu)\", srcSize);\n\n     \n    memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralsCompression) {\n        DEBUGLOG(5, \"set_basic - disabled\");\n        hufMetadata->hType = set_basic;\n        return 0;\n    }\n\n     \n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) {\n            DEBUGLOG(5, \"set_basic - too small\");\n            hufMetadata->hType = set_basic;\n            return 0;\n        }\n    }\n\n     \n    {   size_t const largest = HIST_count_wksp (countWksp, &maxSymbolValue, (const BYTE*)src, srcSize, workspace, wkspSize);\n        FORWARD_IF_ERROR(largest, \"HIST_count_wksp failed\");\n        if (largest == srcSize) {\n            DEBUGLOG(5, \"set_rle\");\n            hufMetadata->hType = set_rle;\n            return 0;\n        }\n        if (largest <= (srcSize >> 7)+4) {\n            DEBUGLOG(5, \"set_basic - no gain\");\n            hufMetadata->hType = set_basic;\n            return 0;\n        }\n    }\n\n     \n    if (repeat == HUF_repeat_check && !HUF_validateCTable((HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue)) {\n        repeat = HUF_repeat_none;\n    }\n\n     \n    memset(nextHuf->CTable, 0, sizeof(nextHuf->CTable));\n    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n    {   size_t const maxBits = HUF_buildCTable_wksp((HUF_CElt*)nextHuf->CTable, countWksp,\n                                                    maxSymbolValue, huffLog,\n                                                    nodeWksp, nodeWkspSize);\n        FORWARD_IF_ERROR(maxBits, \"HUF_buildCTable_wksp\");\n        huffLog = (U32)maxBits;\n        {    \n            size_t const newCSize = HUF_estimateCompressedSize(\n                    (HUF_CElt*)nextHuf->CTable, countWksp, maxSymbolValue);\n            size_t const hSize = HUF_writeCTable(\n                    hufMetadata->hufDesBuffer, sizeof(hufMetadata->hufDesBuffer),\n                    (HUF_CElt*)nextHuf->CTable, maxSymbolValue, huffLog);\n             \n            if (repeat != HUF_repeat_none) {\n                size_t const oldCSize = HUF_estimateCompressedSize(\n                        (HUF_CElt const*)prevHuf->CTable, countWksp, maxSymbolValue);\n                if (oldCSize < srcSize && (oldCSize <= hSize + newCSize || hSize + 12 >= srcSize)) {\n                    DEBUGLOG(5, \"set_repeat - smaller\");\n                    memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n                    hufMetadata->hType = set_repeat;\n                    return 0;\n                }\n            }\n            if (newCSize + hSize >= srcSize) {\n                DEBUGLOG(5, \"set_basic - no gains\");\n                memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n                hufMetadata->hType = set_basic;\n                return 0;\n            }\n            DEBUGLOG(5, \"set_compressed (hSize=%u)\", (U32)hSize);\n            hufMetadata->hType = set_compressed;\n            nextHuf->repeatMode = HUF_repeat_check;\n            return hSize;\n        }\n    }\n}\n\n \nstatic size_t ZSTD_buildSuperBlockEntropy_sequences(seqStore_t* seqStorePtr,\n                                              const ZSTD_fseCTables_t* prevEntropy,\n                                                    ZSTD_fseCTables_t* nextEntropy,\n                                              const ZSTD_CCtx_params* cctxParams,\n                                                    ZSTD_fseCTablesMetadata_t* fseMetadata,\n                                                    void* workspace, size_t wkspSize)\n{\n    BYTE* const wkspStart = (BYTE*)workspace;\n    BYTE* const wkspEnd = wkspStart + wkspSize;\n    BYTE* const countWkspStart = wkspStart;\n    unsigned* const countWksp = (unsigned*)workspace;\n    const size_t countWkspSize = (MaxSeq + 1) * sizeof(unsigned);\n    BYTE* const cTableWksp = countWkspStart + countWkspSize;\n    const size_t cTableWkspSize = wkspEnd-cTableWksp;\n    ZSTD_strategy const strategy = cctxParams->cParams.strategy;\n    FSE_CTable* CTable_LitLength = nextEntropy->litlengthCTable;\n    FSE_CTable* CTable_OffsetBits = nextEntropy->offcodeCTable;\n    FSE_CTable* CTable_MatchLength = nextEntropy->matchlengthCTable;\n    const BYTE* const ofCodeTable = seqStorePtr->ofCode;\n    const BYTE* const llCodeTable = seqStorePtr->llCode;\n    const BYTE* const mlCodeTable = seqStorePtr->mlCode;\n    size_t const nbSeq = seqStorePtr->sequences - seqStorePtr->sequencesStart;\n    BYTE* const ostart = fseMetadata->fseTablesBuffer;\n    BYTE* const oend = ostart + sizeof(fseMetadata->fseTablesBuffer);\n    BYTE* op = ostart;\n\n    assert(cTableWkspSize >= (1 << MaxFSELog) * sizeof(FSE_FUNCTION_TYPE));\n    DEBUGLOG(5, \"ZSTD_buildSuperBlockEntropy_sequences (nbSeq=%zu)\", nbSeq);\n    memset(workspace, 0, wkspSize);\n\n    fseMetadata->lastCountSize = 0;\n     \n    ZSTD_seqToCodes(seqStorePtr);\n     \n    {   U32 LLtype;\n        unsigned max = MaxLL;\n        size_t const mostFrequent = HIST_countFast_wksp(countWksp, &max, llCodeTable, nbSeq, workspace, wkspSize);   \n        DEBUGLOG(5, \"Building LL table\");\n        nextEntropy->litlength_repeatMode = prevEntropy->litlength_repeatMode;\n        LLtype = ZSTD_selectEncodingType(&nextEntropy->litlength_repeatMode,\n                                        countWksp, max, mostFrequent, nbSeq,\n                                        LLFSELog, prevEntropy->litlengthCTable,\n                                        LL_defaultNorm, LL_defaultNormLog,\n                                        ZSTD_defaultAllowed, strategy);\n        assert(set_basic < set_compressed && set_rle < set_compressed);\n        assert(!(LLtype < set_compressed && nextEntropy->litlength_repeatMode != FSE_repeat_none));  \n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_LitLength, LLFSELog, (symbolEncodingType_e)LLtype,\n                                                    countWksp, max, llCodeTable, nbSeq, LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                                                    prevEntropy->litlengthCTable, sizeof(prevEntropy->litlengthCTable),\n                                                    cTableWksp, cTableWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for LitLens failed\");\n            if (LLtype == set_compressed)\n                fseMetadata->lastCountSize = countSize;\n            op += countSize;\n            fseMetadata->llType = (symbolEncodingType_e) LLtype;\n    }   }\n     \n    {   U32 Offtype;\n        unsigned max = MaxOff;\n        size_t const mostFrequent = HIST_countFast_wksp(countWksp, &max, ofCodeTable, nbSeq, workspace, wkspSize);   \n         \n        ZSTD_defaultPolicy_e const defaultPolicy = (max <= DefaultMaxOff) ? ZSTD_defaultAllowed : ZSTD_defaultDisallowed;\n        DEBUGLOG(5, \"Building OF table\");\n        nextEntropy->offcode_repeatMode = prevEntropy->offcode_repeatMode;\n        Offtype = ZSTD_selectEncodingType(&nextEntropy->offcode_repeatMode,\n                                        countWksp, max, mostFrequent, nbSeq,\n                                        OffFSELog, prevEntropy->offcodeCTable,\n                                        OF_defaultNorm, OF_defaultNormLog,\n                                        defaultPolicy, strategy);\n        assert(!(Offtype < set_compressed && nextEntropy->offcode_repeatMode != FSE_repeat_none));  \n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_OffsetBits, OffFSELog, (symbolEncodingType_e)Offtype,\n                                                    countWksp, max, ofCodeTable, nbSeq, OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                                                    prevEntropy->offcodeCTable, sizeof(prevEntropy->offcodeCTable),\n                                                    cTableWksp, cTableWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for Offsets failed\");\n            if (Offtype == set_compressed)\n                fseMetadata->lastCountSize = countSize;\n            op += countSize;\n            fseMetadata->ofType = (symbolEncodingType_e) Offtype;\n    }   }\n     \n    {   U32 MLtype;\n        unsigned max = MaxML;\n        size_t const mostFrequent = HIST_countFast_wksp(countWksp, &max, mlCodeTable, nbSeq, workspace, wkspSize);    \n        DEBUGLOG(5, \"Building ML table (remaining space : %i)\", (int)(oend-op));\n        nextEntropy->matchlength_repeatMode = prevEntropy->matchlength_repeatMode;\n        MLtype = ZSTD_selectEncodingType(&nextEntropy->matchlength_repeatMode,\n                                        countWksp, max, mostFrequent, nbSeq,\n                                        MLFSELog, prevEntropy->matchlengthCTable,\n                                        ML_defaultNorm, ML_defaultNormLog,\n                                        ZSTD_defaultAllowed, strategy);\n        assert(!(MLtype < set_compressed && nextEntropy->matchlength_repeatMode != FSE_repeat_none));  \n        {   size_t const countSize = ZSTD_buildCTable(op, oend - op, CTable_MatchLength, MLFSELog, (symbolEncodingType_e)MLtype,\n                                                    countWksp, max, mlCodeTable, nbSeq, ML_defaultNorm, ML_defaultNormLog, MaxML,\n                                                    prevEntropy->matchlengthCTable, sizeof(prevEntropy->matchlengthCTable),\n                                                    cTableWksp, cTableWkspSize);\n            FORWARD_IF_ERROR(countSize, \"ZSTD_buildCTable for MatchLengths failed\");\n            if (MLtype == set_compressed)\n                fseMetadata->lastCountSize = countSize;\n            op += countSize;\n            fseMetadata->mlType = (symbolEncodingType_e) MLtype;\n    }   }\n    assert((size_t) (op-ostart) <= sizeof(fseMetadata->fseTablesBuffer));\n    return op-ostart;\n}\n\n\n \nstatic size_t\nZSTD_buildSuperBlockEntropy(seqStore_t* seqStorePtr,\n                      const ZSTD_entropyCTables_t* prevEntropy,\n                            ZSTD_entropyCTables_t* nextEntropy,\n                      const ZSTD_CCtx_params* cctxParams,\n                            ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                            void* workspace, size_t wkspSize)\n{\n    size_t const litSize = seqStorePtr->lit - seqStorePtr->litStart;\n    DEBUGLOG(5, \"ZSTD_buildSuperBlockEntropy\");\n    entropyMetadata->hufMetadata.hufDesSize =\n        ZSTD_buildSuperBlockEntropy_literal(seqStorePtr->litStart, litSize,\n                                            &prevEntropy->huf, &nextEntropy->huf,\n                                            &entropyMetadata->hufMetadata,\n                                            ZSTD_disableLiteralsCompression(cctxParams),\n                                            workspace, wkspSize);\n    FORWARD_IF_ERROR(entropyMetadata->hufMetadata.hufDesSize, \"ZSTD_buildSuperBlockEntropy_literal failed\");\n    entropyMetadata->fseMetadata.fseTablesSize =\n        ZSTD_buildSuperBlockEntropy_sequences(seqStorePtr,\n                                              &prevEntropy->fse, &nextEntropy->fse,\n                                              cctxParams,\n                                              &entropyMetadata->fseMetadata,\n                                              workspace, wkspSize);\n    FORWARD_IF_ERROR(entropyMetadata->fseMetadata.fseTablesSize, \"ZSTD_buildSuperBlockEntropy_sequences failed\");\n    return 0;\n}\n\n \nstatic size_t ZSTD_compressSubBlock_literal(const HUF_CElt* hufTable,\n                                    const ZSTD_hufCTablesMetadata_t* hufMetadata,\n                                    const BYTE* literals, size_t litSize,\n                                    void* dst, size_t dstSize,\n                                    const int bmi2, int writeEntropy, int* entropyWritten)\n{\n    size_t const header = writeEntropy ? 200 : 0;\n    size_t const lhSize = 3 + (litSize >= (1 KB - header)) + (litSize >= (16 KB - header));\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart + lhSize;\n    U32 const singleStream = lhSize == 3;\n    symbolEncodingType_e hType = writeEntropy ? hufMetadata->hType : set_repeat;\n    size_t cLitSize = 0;\n\n    (void)bmi2;  \n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_literal (litSize=%zu, lhSize=%zu, writeEntropy=%d)\", litSize, lhSize, writeEntropy);\n\n    *entropyWritten = 0;\n    if (litSize == 0 || hufMetadata->hType == set_basic) {\n      DEBUGLOG(5, \"ZSTD_compressSubBlock_literal using raw literal\");\n      return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);\n    } else if (hufMetadata->hType == set_rle) {\n      DEBUGLOG(5, \"ZSTD_compressSubBlock_literal using rle literal\");\n      return ZSTD_compressRleLiteralsBlock(dst, dstSize, literals, litSize);\n    }\n\n    assert(litSize > 0);\n    assert(hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat);\n\n    if (writeEntropy && hufMetadata->hType == set_compressed) {\n        memcpy(op, hufMetadata->hufDesBuffer, hufMetadata->hufDesSize);\n        op += hufMetadata->hufDesSize;\n        cLitSize += hufMetadata->hufDesSize;\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_literal (hSize=%zu)\", hufMetadata->hufDesSize);\n    }\n\n     \n    {   const size_t cSize = singleStream ? HUF_compress1X_usingCTable(op, oend-op, literals, litSize, hufTable)\n                                          : HUF_compress4X_usingCTable(op, oend-op, literals, litSize, hufTable);\n        op += cSize;\n        cLitSize += cSize;\n        if (cSize == 0 || ERR_isError(cSize)) {\n            DEBUGLOG(5, \"Failed to write entropy tables %s\", ZSTD_getErrorName(cSize));\n            return 0;\n        }\n         \n        if (!writeEntropy && cLitSize >= litSize) {\n            DEBUGLOG(5, \"ZSTD_compressSubBlock_literal using raw literal because uncompressible\");\n            return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);\n        }\n         \n        if (lhSize < (size_t)(3 + (cLitSize >= 1 KB) + (cLitSize >= 16 KB))) {\n            assert(cLitSize > litSize);\n            DEBUGLOG(5, \"Literals expanded beyond allowed header size\");\n            return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);\n        }\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_literal (cSize=%zu)\", cSize);\n    }\n\n     \n    switch(lhSize)\n    {\n    case 3:  \n        {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4:  \n        {   U32 const lhc = hType + (2 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5:  \n        {   U32 const lhc = hType + (3 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:   \n        assert(0);\n    }\n    *entropyWritten = 1;\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)litSize, (U32)(op-ostart));\n    return op-ostart;\n}\n\nstatic size_t ZSTD_seqDecompressedSize(seqStore_t const* seqStore, const seqDef* sequences, size_t nbSeq, size_t litSize, int lastSequence) {\n    const seqDef* const sstart = sequences;\n    const seqDef* const send = sequences + nbSeq;\n    const seqDef* sp = sstart;\n    size_t matchLengthSum = 0;\n    size_t litLengthSum __attribute__ ((unused)) = 0;\n    while (send-sp > 0) {\n        ZSTD_sequenceLength const seqLen = ZSTD_getSequenceLength(seqStore, sp);\n        litLengthSum += seqLen.litLength;\n        matchLengthSum += seqLen.matchLength;\n        sp++;\n    }\n    assert(litLengthSum <= litSize);\n    if (!lastSequence) {\n        assert(litLengthSum == litSize);\n    }\n    return matchLengthSum + litSize;\n}\n\n \nstatic size_t ZSTD_compressSubBlock_sequences(const ZSTD_fseCTables_t* fseTables,\n                                              const ZSTD_fseCTablesMetadata_t* fseMetadata,\n                                              const seqDef* sequences, size_t nbSeq,\n                                              const BYTE* llCode, const BYTE* mlCode, const BYTE* ofCode,\n                                              const ZSTD_CCtx_params* cctxParams,\n                                              void* dst, size_t dstCapacity,\n                                              const int bmi2, int writeEntropy, int* entropyWritten)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    BYTE* seqHead;\n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (nbSeq=%zu, writeEntropy=%d, longOffsets=%d)\", nbSeq, writeEntropy, longOffsets);\n\n    *entropyWritten = 0;\n     \n    RETURN_ERROR_IF((oend-op) < 3   + 1  ,\n                    dstSize_tooSmall, \"\");\n    if (nbSeq < 0x7F)\n        *op++ = (BYTE)nbSeq;\n    else if (nbSeq < LONGNBSEQ)\n        op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;\n    else\n        op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;\n    if (nbSeq==0) {\n        return op - ostart;\n    }\n\n     \n    seqHead = op++;\n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (seqHeadSize=%u)\", (unsigned)(op-ostart));\n\n    if (writeEntropy) {\n        const U32 LLtype = fseMetadata->llType;\n        const U32 Offtype = fseMetadata->ofType;\n        const U32 MLtype = fseMetadata->mlType;\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (fseTablesSize=%zu)\", fseMetadata->fseTablesSize);\n        *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));\n        memcpy(op, fseMetadata->fseTablesBuffer, fseMetadata->fseTablesSize);\n        op += fseMetadata->fseTablesSize;\n    } else {\n        const U32 repeat = set_repeat;\n        *seqHead = (BYTE)((repeat<<6) + (repeat<<4) + (repeat<<2));\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, oend - op,\n                                        fseTables->matchlengthCTable, mlCode,\n                                        fseTables->offcodeCTable, ofCode,\n                                        fseTables->litlengthCTable, llCode,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n         \n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n        if (writeEntropy && fseMetadata->lastCountSize && fseMetadata->lastCountSize + bitstreamSize < 4) {\n             \n            assert(fseMetadata->lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n#endif\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (bitstreamSize=%zu)\", bitstreamSize);\n    }\n\n     \n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    if (op-seqHead < 4) {\n        DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.4.0 by emitting \"\n                    \"an uncompressed block when sequences are < 4 bytes\");\n        return 0;\n    }\n#endif\n\n    *entropyWritten = 1;\n    return op - ostart;\n}\n\n \nstatic size_t ZSTD_compressSubBlock(const ZSTD_entropyCTables_t* entropy,\n                                    const ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                                    const seqDef* sequences, size_t nbSeq,\n                                    const BYTE* literals, size_t litSize,\n                                    const BYTE* llCode, const BYTE* mlCode, const BYTE* ofCode,\n                                    const ZSTD_CCtx_params* cctxParams,\n                                    void* dst, size_t dstCapacity,\n                                    const int bmi2,\n                                    int writeLitEntropy, int writeSeqEntropy,\n                                    int* litEntropyWritten, int* seqEntropyWritten,\n                                    U32 lastBlock)\n{\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart + ZSTD_blockHeaderSize;\n    DEBUGLOG(5, \"ZSTD_compressSubBlock (litSize=%zu, nbSeq=%zu, writeLitEntropy=%d, writeSeqEntropy=%d, lastBlock=%d)\",\n                litSize, nbSeq, writeLitEntropy, writeSeqEntropy, lastBlock);\n    {   size_t cLitSize = ZSTD_compressSubBlock_literal((const HUF_CElt*)entropy->huf.CTable,\n                                                        &entropyMetadata->hufMetadata, literals, litSize,\n                                                        op, oend-op, bmi2, writeLitEntropy, litEntropyWritten);\n        FORWARD_IF_ERROR(cLitSize, \"ZSTD_compressSubBlock_literal failed\");\n        if (cLitSize == 0) return 0;\n        op += cLitSize;\n    }\n    {   size_t cSeqSize = ZSTD_compressSubBlock_sequences(&entropy->fse,\n                                                  &entropyMetadata->fseMetadata,\n                                                  sequences, nbSeq,\n                                                  llCode, mlCode, ofCode,\n                                                  cctxParams,\n                                                  op, oend-op,\n                                                  bmi2, writeSeqEntropy, seqEntropyWritten);\n        FORWARD_IF_ERROR(cSeqSize, \"ZSTD_compressSubBlock_sequences failed\");\n        if (cSeqSize == 0) return 0;\n        op += cSeqSize;\n    }\n     \n    {   size_t cSize = (op-ostart)-ZSTD_blockHeaderSize;\n        U32 const cBlockHeader24 = lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);\n        MEM_writeLE24(ostart, cBlockHeader24);\n    }\n    return op-ostart;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize_literal(const BYTE* literals, size_t litSize,\n                                                const ZSTD_hufCTables_t* huf,\n                                                const ZSTD_hufCTablesMetadata_t* hufMetadata,\n                                                void* workspace, size_t wkspSize,\n                                                int writeEntropy)\n{\n    unsigned* const countWksp = (unsigned*)workspace;\n    unsigned maxSymbolValue = 255;\n    size_t literalSectionHeaderSize = 3;  \n\n    if (hufMetadata->hType == set_basic) return litSize;\n    else if (hufMetadata->hType == set_rle) return 1;\n    else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {\n        size_t const largest = HIST_count_wksp (countWksp, &maxSymbolValue, (const BYTE*)literals, litSize, workspace, wkspSize);\n        if (ZSTD_isError(largest)) return litSize;\n        {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);\n            if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;\n            return cLitSizeEstimate + literalSectionHeaderSize;\n    }   }\n    assert(0);  \n    return 0;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize_symbolType(symbolEncodingType_e type,\n                        const BYTE* codeTable, unsigned maxCode,\n                        size_t nbSeq, const FSE_CTable* fseCTable,\n                        const U32* additionalBits,\n                        short const* defaultNorm, U32 defaultNormLog, U32 defaultMax,\n                        void* workspace, size_t wkspSize)\n{\n    unsigned* const countWksp = (unsigned*)workspace;\n    const BYTE* ctp = codeTable;\n    const BYTE* const ctStart = ctp;\n    const BYTE* const ctEnd = ctStart + nbSeq;\n    size_t cSymbolTypeSizeEstimateInBits = 0;\n    unsigned max = maxCode;\n\n    HIST_countFast_wksp(countWksp, &max, codeTable, nbSeq, workspace, wkspSize);   \n    if (type == set_basic) {\n         \n        assert(max <= defaultMax);\n        cSymbolTypeSizeEstimateInBits = max <= defaultMax\n                ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max)\n                : ERROR(GENERIC);\n    } else if (type == set_rle) {\n        cSymbolTypeSizeEstimateInBits = 0;\n    } else if (type == set_compressed || type == set_repeat) {\n        cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);\n    }\n    if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;\n    while (ctp < ctEnd) {\n        if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];\n        else cSymbolTypeSizeEstimateInBits += *ctp;  \n        ctp++;\n    }\n    return cSymbolTypeSizeEstimateInBits / 8;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize_sequences(const BYTE* ofCodeTable,\n                                                  const BYTE* llCodeTable,\n                                                  const BYTE* mlCodeTable,\n                                                  size_t nbSeq,\n                                                  const ZSTD_fseCTables_t* fseTables,\n                                                  const ZSTD_fseCTablesMetadata_t* fseMetadata,\n                                                  void* workspace, size_t wkspSize,\n                                                  int writeEntropy)\n{\n    size_t sequencesSectionHeaderSize = 3;  \n    size_t cSeqSizeEstimate = 0;\n    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->ofType, ofCodeTable, MaxOff,\n                                         nbSeq, fseTables->offcodeCTable, NULL,\n                                         OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                                         workspace, wkspSize);\n    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,\n                                         nbSeq, fseTables->litlengthCTable, LL_bits,\n                                         LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                                         workspace, wkspSize);\n    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,\n                                         nbSeq, fseTables->matchlengthCTable, ML_bits,\n                                         ML_defaultNorm, ML_defaultNormLog, MaxML,\n                                         workspace, wkspSize);\n    if (writeEntropy) cSeqSizeEstimate += fseMetadata->fseTablesSize;\n    return cSeqSizeEstimate + sequencesSectionHeaderSize;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize(const BYTE* literals, size_t litSize,\n                                        const BYTE* ofCodeTable,\n                                        const BYTE* llCodeTable,\n                                        const BYTE* mlCodeTable,\n                                        size_t nbSeq,\n                                        const ZSTD_entropyCTables_t* entropy,\n                                        const ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                                        void* workspace, size_t wkspSize,\n                                        int writeLitEntropy, int writeSeqEntropy) {\n    size_t cSizeEstimate = 0;\n    cSizeEstimate += ZSTD_estimateSubBlockSize_literal(literals, litSize,\n                                                         &entropy->huf, &entropyMetadata->hufMetadata,\n                                                         workspace, wkspSize, writeLitEntropy);\n    cSizeEstimate += ZSTD_estimateSubBlockSize_sequences(ofCodeTable, llCodeTable, mlCodeTable,\n                                                         nbSeq, &entropy->fse, &entropyMetadata->fseMetadata,\n                                                         workspace, wkspSize, writeSeqEntropy);\n    return cSizeEstimate + ZSTD_blockHeaderSize;\n}\n\nstatic int ZSTD_needSequenceEntropyTables(ZSTD_fseCTablesMetadata_t const* fseMetadata)\n{\n    if (fseMetadata->llType == set_compressed || fseMetadata->llType == set_rle)\n        return 1;\n    if (fseMetadata->mlType == set_compressed || fseMetadata->mlType == set_rle)\n        return 1;\n    if (fseMetadata->ofType == set_compressed || fseMetadata->ofType == set_rle)\n        return 1;\n    return 0;\n}\n\n \nstatic size_t ZSTD_compressSubBlock_multi(const seqStore_t* seqStorePtr,\n                            const ZSTD_compressedBlockState_t* prevCBlock,\n                            ZSTD_compressedBlockState_t* nextCBlock,\n                            const ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                            const ZSTD_CCtx_params* cctxParams,\n                                  void* dst, size_t dstCapacity,\n                            const void* src, size_t srcSize,\n                            const int bmi2, U32 lastBlock,\n                            void* workspace, size_t wkspSize)\n{\n    const seqDef* const sstart = seqStorePtr->sequencesStart;\n    const seqDef* const send = seqStorePtr->sequences;\n    const seqDef* sp = sstart;\n    const BYTE* const lstart = seqStorePtr->litStart;\n    const BYTE* const lend = seqStorePtr->lit;\n    const BYTE* lp = lstart;\n    BYTE const* ip = (BYTE const*)src;\n    BYTE const* const iend = ip + srcSize;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    const BYTE* llCodePtr = seqStorePtr->llCode;\n    const BYTE* mlCodePtr = seqStorePtr->mlCode;\n    const BYTE* ofCodePtr = seqStorePtr->ofCode;\n    size_t targetCBlockSize = cctxParams->targetCBlockSize;\n    size_t litSize, seqCount;\n    int writeLitEntropy = entropyMetadata->hufMetadata.hType == set_compressed;\n    int writeSeqEntropy = 1;\n    int lastSequence = 0;\n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_multi (litSize=%u, nbSeq=%u)\",\n                (unsigned)(lend-lp), (unsigned)(send-sstart));\n\n    litSize = 0;\n    seqCount = 0;\n    do {\n        size_t cBlockSizeEstimate = 0;\n        if (sstart == send) {\n            lastSequence = 1;\n        } else {\n            const seqDef* const sequence = sp + seqCount;\n            lastSequence = sequence == send - 1;\n            litSize += ZSTD_getSequenceLength(seqStorePtr, sequence).litLength;\n            seqCount++;\n        }\n        if (lastSequence) {\n            assert(lp <= lend);\n            assert(litSize <= (size_t)(lend - lp));\n            litSize = (size_t)(lend - lp);\n        }\n         \n        cBlockSizeEstimate = ZSTD_estimateSubBlockSize(lp, litSize, ofCodePtr, llCodePtr, mlCodePtr, seqCount,\n                                                       &nextCBlock->entropy, entropyMetadata,\n                                                       workspace, wkspSize, writeLitEntropy, writeSeqEntropy);\n        if (cBlockSizeEstimate > targetCBlockSize || lastSequence) {\n            int litEntropyWritten = 0;\n            int seqEntropyWritten = 0;\n            const size_t decompressedSize = ZSTD_seqDecompressedSize(seqStorePtr, sp, seqCount, litSize, lastSequence);\n            const size_t cSize = ZSTD_compressSubBlock(&nextCBlock->entropy, entropyMetadata,\n                                                       sp, seqCount,\n                                                       lp, litSize,\n                                                       llCodePtr, mlCodePtr, ofCodePtr,\n                                                       cctxParams,\n                                                       op, oend-op,\n                                                       bmi2, writeLitEntropy, writeSeqEntropy,\n                                                       &litEntropyWritten, &seqEntropyWritten,\n                                                       lastBlock && lastSequence);\n            FORWARD_IF_ERROR(cSize, \"ZSTD_compressSubBlock failed\");\n            if (cSize > 0 && cSize < decompressedSize) {\n                DEBUGLOG(5, \"Committed the sub-block\");\n                assert(ip + decompressedSize <= iend);\n                ip += decompressedSize;\n                sp += seqCount;\n                lp += litSize;\n                op += cSize;\n                llCodePtr += seqCount;\n                mlCodePtr += seqCount;\n                ofCodePtr += seqCount;\n                litSize = 0;\n                seqCount = 0;\n                 \n                if (litEntropyWritten) {\n                    writeLitEntropy = 0;\n                }\n                if (seqEntropyWritten) {\n                    writeSeqEntropy = 0;\n                }\n            }\n        }\n    } while (!lastSequence);\n    if (writeLitEntropy) {\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_multi has literal entropy tables unwritten\");\n        memcpy(&nextCBlock->entropy.huf, &prevCBlock->entropy.huf, sizeof(prevCBlock->entropy.huf));\n    }\n    if (writeSeqEntropy && ZSTD_needSequenceEntropyTables(&entropyMetadata->fseMetadata)) {\n         \n        DEBUGLOG(5, \"ZSTD_compressSubBlock_multi has sequence entropy tables unwritten\");\n        return 0;\n    }\n    if (ip < iend) {\n        size_t const cSize = ZSTD_noCompressBlock(op, oend - op, ip, iend - ip, lastBlock);\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_multi last sub-block uncompressed, %zu bytes\", (size_t)(iend - ip));\n        FORWARD_IF_ERROR(cSize, \"ZSTD_noCompressBlock failed\");\n        assert(cSize != 0);\n        op += cSize;\n         \n        if (sp < send) {\n            seqDef const* seq;\n            repcodes_t rep;\n            memcpy(&rep, prevCBlock->rep, sizeof(rep));\n            for (seq = sstart; seq < sp; ++seq) {\n                rep = ZSTD_updateRep(rep.rep, seq->offset - 1, ZSTD_getSequenceLength(seqStorePtr, seq).litLength == 0);\n            }\n            memcpy(nextCBlock->rep, &rep, sizeof(rep));\n        }\n    }\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_multi compressed\");\n    return op-ostart;\n}\n\nsize_t ZSTD_compressSuperBlock(ZSTD_CCtx* zc,\n                               void* dst, size_t dstCapacity,\n                               void const* src, size_t srcSize,\n                               unsigned lastBlock) {\n    ZSTD_entropyCTablesMetadata_t entropyMetadata;\n\n    FORWARD_IF_ERROR(ZSTD_buildSuperBlockEntropy(&zc->seqStore,\n          &zc->blockState.prevCBlock->entropy,\n          &zc->blockState.nextCBlock->entropy,\n          &zc->appliedParams,\n          &entropyMetadata,\n          zc->entropyWorkspace, HUF_WORKSPACE_SIZE  ), \"\");\n\n    return ZSTD_compressSubBlock_multi(&zc->seqStore,\n            zc->blockState.prevCBlock,\n            zc->blockState.nextCBlock,\n            &entropyMetadata,\n            &zc->appliedParams,\n            dst, dstCapacity,\n            src, srcSize,\n            zc->bmi2, lastBlock,\n            zc->entropyWorkspace, HUF_WORKSPACE_SIZE  );\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}