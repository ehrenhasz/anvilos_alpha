{
  "module_name": "zstd_compress_literals.c",
  "hash_id": "9d87df9155bfeb8e4b1bdbead3f7fae61f27ef071e2f7b9e232455e71f0efac4",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/zstd_compress_literals.c",
  "human_readable_source": " \n\n  \n#include \"zstd_compress_literals.h\"\n\nsize_t ZSTD_noCompressLiterals (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    BYTE* const ostart = (BYTE* const)dst;\n    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);\n\n    RETURN_ERROR_IF(srcSize + flSize > dstCapacity, dstSize_tooSmall, \"\");\n\n    switch(flSize)\n    {\n        case 1:  \n            ostart[0] = (BYTE)((U32)set_basic + (srcSize<<3));\n            break;\n        case 2:  \n            MEM_writeLE16(ostart, (U16)((U32)set_basic + (1<<2) + (srcSize<<4)));\n            break;\n        case 3:  \n            MEM_writeLE32(ostart, (U32)((U32)set_basic + (3<<2) + (srcSize<<4)));\n            break;\n        default:    \n            assert(0);\n    }\n\n    memcpy(ostart + flSize, src, srcSize);\n    DEBUGLOG(5, \"Raw literals: %u -> %u\", (U32)srcSize, (U32)(srcSize + flSize));\n    return srcSize + flSize;\n}\n\nsize_t ZSTD_compressRleLiteralsBlock (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    BYTE* const ostart = (BYTE* const)dst;\n    U32   const flSize = 1 + (srcSize>31) + (srcSize>4095);\n\n    (void)dstCapacity;   \n\n    switch(flSize)\n    {\n        case 1:  \n            ostart[0] = (BYTE)((U32)set_rle + (srcSize<<3));\n            break;\n        case 2:  \n            MEM_writeLE16(ostart, (U16)((U32)set_rle + (1<<2) + (srcSize<<4)));\n            break;\n        case 3:  \n            MEM_writeLE32(ostart, (U32)((U32)set_rle + (3<<2) + (srcSize<<4)));\n            break;\n        default:    \n            assert(0);\n    }\n\n    ostart[flSize] = *(const BYTE*)src;\n    DEBUGLOG(5, \"RLE literals: %u -> %u\", (U32)srcSize, (U32)flSize + 1);\n    return flSize+1;\n}\n\nsize_t ZSTD_compressLiterals (ZSTD_hufCTables_t const* prevHuf,\n                              ZSTD_hufCTables_t* nextHuf,\n                              ZSTD_strategy strategy, int disableLiteralCompression,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize,\n                              void* entropyWorkspace, size_t entropyWorkspaceSize,\n                        const int bmi2)\n{\n    size_t const minGain = ZSTD_minGain(srcSize, strategy);\n    size_t const lhSize = 3 + (srcSize >= 1 KB) + (srcSize >= 16 KB);\n    BYTE*  const ostart = (BYTE*)dst;\n    U32 singleStream = srcSize < 256;\n    symbolEncodingType_e hType = set_compressed;\n    size_t cLitSize;\n\n    DEBUGLOG(5,\"ZSTD_compressLiterals (disableLiteralCompression=%i srcSize=%u)\",\n                disableLiteralCompression, (U32)srcSize);\n\n     \n    memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n\n    if (disableLiteralCompression)\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n\n     \n#   define COMPRESS_LITERALS_SIZE_MIN 63\n    {   size_t const minLitSize = (prevHuf->repeatMode == HUF_repeat_valid) ? 6 : COMPRESS_LITERALS_SIZE_MIN;\n        if (srcSize <= minLitSize) return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n\n    RETURN_ERROR_IF(dstCapacity < lhSize+1, dstSize_tooSmall, \"not enough space for compression\");\n    {   HUF_repeat repeat = prevHuf->repeatMode;\n        int const preferRepeat = strategy < ZSTD_lazy ? srcSize <= 1024 : 0;\n        if (repeat == HUF_repeat_valid && lhSize == 3) singleStream = 1;\n        cLitSize = singleStream ?\n            HUF_compress1X_repeat(\n                ostart+lhSize, dstCapacity-lhSize, src, srcSize,\n                HUF_SYMBOLVALUE_MAX, HUF_TABLELOG_DEFAULT, entropyWorkspace, entropyWorkspaceSize,\n                (HUF_CElt*)nextHuf->CTable, &repeat, preferRepeat, bmi2) :\n            HUF_compress4X_repeat(\n                ostart+lhSize, dstCapacity-lhSize, src, srcSize,\n                HUF_SYMBOLVALUE_MAX, HUF_TABLELOG_DEFAULT, entropyWorkspace, entropyWorkspaceSize,\n                (HUF_CElt*)nextHuf->CTable, &repeat, preferRepeat, bmi2);\n        if (repeat != HUF_repeat_none) {\n             \n            DEBUGLOG(5, \"Reusing previous huffman table\");\n            hType = set_repeat;\n        }\n    }\n\n    if ((cLitSize==0) | (cLitSize >= srcSize - minGain) | ERR_isError(cLitSize)) {\n        memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_noCompressLiterals(dst, dstCapacity, src, srcSize);\n    }\n    if (cLitSize==1) {\n        memcpy(nextHuf, prevHuf, sizeof(*prevHuf));\n        return ZSTD_compressRleLiteralsBlock(dst, dstCapacity, src, srcSize);\n    }\n\n    if (hType == set_compressed) {\n         \n        nextHuf->repeatMode = HUF_repeat_check;\n    }\n\n     \n    switch(lhSize)\n    {\n    case 3:  \n        {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4:  \n        {   U32 const lhc = hType + (2 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5:  \n        {   U32 const lhc = hType + (3 << 2) + ((U32)srcSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:   \n        assert(0);\n    }\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)srcSize, (U32)(lhSize+cLitSize));\n    return lhSize+cLitSize;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}