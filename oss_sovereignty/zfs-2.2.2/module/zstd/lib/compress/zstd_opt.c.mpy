{
  "module_name": "zstd_opt.c",
  "hash_id": "0e734fb78e28cdb24b403ea13985256f135f6d31a81075dedf08eb0da618baff",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/zstd_opt.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"\n#include \"hist.h\"\n#include \"zstd_opt.h\"\n\n\n#define ZSTD_LITFREQ_ADD    2    \n#define ZSTD_FREQ_DIV       4    \n#define ZSTD_MAX_PRICE     (1<<30)\n\n#define ZSTD_PREDEF_THRESHOLD 1024    \n\n\n \n\n#if 0     \n#  define BITCOST_ACCURACY 0\n#  define BITCOST_MULTIPLIER (1 << BITCOST_ACCURACY)\n#  define WEIGHT(stat)  ((void)opt, ZSTD_bitWeight(stat))\n#elif 0   \n#  define BITCOST_ACCURACY 8\n#  define BITCOST_MULTIPLIER (1 << BITCOST_ACCURACY)\n#  define WEIGHT(stat,opt) ((void)opt, ZSTD_fracWeight(stat))\n#else     \n#  define BITCOST_ACCURACY 8\n#  define BITCOST_MULTIPLIER (1 << BITCOST_ACCURACY)\n#  define WEIGHT(stat,opt) (opt ? ZSTD_fracWeight(stat) : ZSTD_bitWeight(stat))\n#endif\n\nMEM_STATIC U32 ZSTD_bitWeight(U32 stat)\n{\n    return (ZSTD_highbit32(stat+1) * BITCOST_MULTIPLIER);\n}\n\nMEM_STATIC U32 ZSTD_fracWeight(U32 rawStat)\n{\n    U32 const stat = rawStat + 1;\n    U32 const hb = ZSTD_highbit32(stat);\n    U32 const BWeight = hb * BITCOST_MULTIPLIER;\n    U32 const FWeight = (stat << BITCOST_ACCURACY) >> hb;\n    U32 const weight = BWeight + FWeight;\n    assert(hb + BITCOST_ACCURACY < 31);\n    return weight;\n}\n\n#if (DEBUGLEVEL>=2)\n \nMEM_STATIC double ZSTD_fCost(U32 price)\n{\n    return (double)price / (BITCOST_MULTIPLIER*8);\n}\n#endif\n\nstatic int ZSTD_compressedLiterals(optState_t const* const optPtr)\n{\n    return optPtr->literalCompressionMode != ZSTD_lcm_uncompressed;\n}\n\nstatic void ZSTD_setBasePrices(optState_t* optPtr, int optLevel)\n{\n    if (ZSTD_compressedLiterals(optPtr))\n        optPtr->litSumBasePrice = WEIGHT(optPtr->litSum, optLevel);\n    optPtr->litLengthSumBasePrice = WEIGHT(optPtr->litLengthSum, optLevel);\n    optPtr->matchLengthSumBasePrice = WEIGHT(optPtr->matchLengthSum, optLevel);\n    optPtr->offCodeSumBasePrice = WEIGHT(optPtr->offCodeSum, optLevel);\n}\n\n\n \nstatic U32 ZSTD_downscaleStat(unsigned* table, U32 lastEltIndex, int malus)\n{\n    U32 s, sum=0;\n    DEBUGLOG(5, \"ZSTD_downscaleStat (nbElts=%u)\", (unsigned)lastEltIndex+1);\n    assert(ZSTD_FREQ_DIV+malus > 0 && ZSTD_FREQ_DIV+malus < 31);\n    for (s=0; s<lastEltIndex+1; s++) {\n        table[s] = 1 + (table[s] >> (ZSTD_FREQ_DIV+malus));\n        sum += table[s];\n    }\n    return sum;\n}\n\n \nstatic void\nZSTD_rescaleFreqs(optState_t* const optPtr,\n            const BYTE* const src, size_t const srcSize,\n                  int const optLevel)\n{\n    int const compressedLiterals = ZSTD_compressedLiterals(optPtr);\n    DEBUGLOG(5, \"ZSTD_rescaleFreqs (srcSize=%u)\", (unsigned)srcSize);\n    optPtr->priceType = zop_dynamic;\n\n    if (optPtr->litLengthSum == 0) {   \n        if (srcSize <= ZSTD_PREDEF_THRESHOLD) {   \n            DEBUGLOG(5, \"(srcSize <= ZSTD_PREDEF_THRESHOLD) => zop_predef\");\n            optPtr->priceType = zop_predef;\n        }\n\n        assert(optPtr->symbolCosts != NULL);\n        if (optPtr->symbolCosts->huf.repeatMode == HUF_repeat_valid) {\n             \n            optPtr->priceType = zop_dynamic;\n\n            if (compressedLiterals) {\n                unsigned lit;\n                assert(optPtr->litFreq != NULL);\n                optPtr->litSum = 0;\n                for (lit=0; lit<=MaxLit; lit++) {\n                    U32 const scaleLog = 11;    \n                    U32 const bitCost = HUF_getNbBits(optPtr->symbolCosts->huf.CTable, lit);\n                    assert(bitCost <= scaleLog);\n                    optPtr->litFreq[lit] = bitCost ? 1 << (scaleLog-bitCost) : 1  ;\n                    optPtr->litSum += optPtr->litFreq[lit];\n            }   }\n\n            {   unsigned ll;\n                FSE_CState_t llstate;\n                FSE_initCState(&llstate, optPtr->symbolCosts->fse.litlengthCTable);\n                optPtr->litLengthSum = 0;\n                for (ll=0; ll<=MaxLL; ll++) {\n                    U32 const scaleLog = 10;    \n                    U32 const bitCost = FSE_getMaxNbBits(llstate.symbolTT, ll);\n                    assert(bitCost < scaleLog);\n                    optPtr->litLengthFreq[ll] = bitCost ? 1 << (scaleLog-bitCost) : 1  ;\n                    optPtr->litLengthSum += optPtr->litLengthFreq[ll];\n            }   }\n\n            {   unsigned ml;\n                FSE_CState_t mlstate;\n                FSE_initCState(&mlstate, optPtr->symbolCosts->fse.matchlengthCTable);\n                optPtr->matchLengthSum = 0;\n                for (ml=0; ml<=MaxML; ml++) {\n                    U32 const scaleLog = 10;\n                    U32 const bitCost = FSE_getMaxNbBits(mlstate.symbolTT, ml);\n                    assert(bitCost < scaleLog);\n                    optPtr->matchLengthFreq[ml] = bitCost ? 1 << (scaleLog-bitCost) : 1  ;\n                    optPtr->matchLengthSum += optPtr->matchLengthFreq[ml];\n            }   }\n\n            {   unsigned of;\n                FSE_CState_t ofstate;\n                FSE_initCState(&ofstate, optPtr->symbolCosts->fse.offcodeCTable);\n                optPtr->offCodeSum = 0;\n                for (of=0; of<=MaxOff; of++) {\n                    U32 const scaleLog = 10;\n                    U32 const bitCost = FSE_getMaxNbBits(ofstate.symbolTT, of);\n                    assert(bitCost < scaleLog);\n                    optPtr->offCodeFreq[of] = bitCost ? 1 << (scaleLog-bitCost) : 1  ;\n                    optPtr->offCodeSum += optPtr->offCodeFreq[of];\n            }   }\n\n        } else {   \n\n            assert(optPtr->litFreq != NULL);\n            if (compressedLiterals) {\n                unsigned lit = MaxLit;\n                HIST_count_simple(optPtr->litFreq, &lit, src, srcSize);    \n                optPtr->litSum = ZSTD_downscaleStat(optPtr->litFreq, MaxLit, 1);\n            }\n\n            {   unsigned ll;\n                for (ll=0; ll<=MaxLL; ll++)\n                    optPtr->litLengthFreq[ll] = 1;\n            }\n            optPtr->litLengthSum = MaxLL+1;\n\n            {   unsigned ml;\n                for (ml=0; ml<=MaxML; ml++)\n                    optPtr->matchLengthFreq[ml] = 1;\n            }\n            optPtr->matchLengthSum = MaxML+1;\n\n            {   unsigned of;\n                for (of=0; of<=MaxOff; of++)\n                    optPtr->offCodeFreq[of] = 1;\n            }\n            optPtr->offCodeSum = MaxOff+1;\n\n        }\n\n    } else {    \n\n        if (compressedLiterals)\n            optPtr->litSum = ZSTD_downscaleStat(optPtr->litFreq, MaxLit, 1);\n        optPtr->litLengthSum = ZSTD_downscaleStat(optPtr->litLengthFreq, MaxLL, 0);\n        optPtr->matchLengthSum = ZSTD_downscaleStat(optPtr->matchLengthFreq, MaxML, 0);\n        optPtr->offCodeSum = ZSTD_downscaleStat(optPtr->offCodeFreq, MaxOff, 0);\n    }\n\n    ZSTD_setBasePrices(optPtr, optLevel);\n}\n\n \nstatic U32 ZSTD_rawLiteralsCost(const BYTE* const literals, U32 const litLength,\n                                const optState_t* const optPtr,\n                                int optLevel)\n{\n    if (litLength == 0) return 0;\n\n    if (!ZSTD_compressedLiterals(optPtr))\n        return (litLength << 3) * BITCOST_MULTIPLIER;   \n\n    if (optPtr->priceType == zop_predef)\n        return (litLength*6) * BITCOST_MULTIPLIER;   \n\n     \n    {   U32 price = litLength * optPtr->litSumBasePrice;\n        U32 u;\n        for (u=0; u < litLength; u++) {\n            assert(WEIGHT(optPtr->litFreq[literals[u]], optLevel) <= optPtr->litSumBasePrice);    \n            price -= WEIGHT(optPtr->litFreq[literals[u]], optLevel);\n        }\n        return price;\n    }\n}\n\n \nstatic U32 ZSTD_litLengthPrice(U32 const litLength, const optState_t* const optPtr, int optLevel)\n{\n    if (optPtr->priceType == zop_predef) return WEIGHT(litLength, optLevel);\n\n     \n    {   U32 const llCode = ZSTD_LLcode(litLength);\n        return (LL_bits[llCode] * BITCOST_MULTIPLIER)\n             + optPtr->litLengthSumBasePrice\n             - WEIGHT(optPtr->litLengthFreq[llCode], optLevel);\n    }\n}\n\n \nFORCE_INLINE_TEMPLATE U32\nZSTD_getMatchPrice(U32 const offset,\n                   U32 const matchLength,\n             const optState_t* const optPtr,\n                   int const optLevel)\n{\n    U32 price;\n    U32 const offCode = ZSTD_highbit32(offset+1);\n    U32 const mlBase = matchLength - MINMATCH;\n    assert(matchLength >= MINMATCH);\n\n    if (optPtr->priceType == zop_predef)   \n        return WEIGHT(mlBase, optLevel) + ((16 + offCode) * BITCOST_MULTIPLIER);\n\n     \n    price = (offCode * BITCOST_MULTIPLIER) + (optPtr->offCodeSumBasePrice - WEIGHT(optPtr->offCodeFreq[offCode], optLevel));\n    if ((optLevel<2)   && offCode >= 20)\n        price += (offCode-19)*2 * BITCOST_MULTIPLIER;  \n\n     \n    {   U32 const mlCode = ZSTD_MLcode(mlBase);\n        price += (ML_bits[mlCode] * BITCOST_MULTIPLIER) + (optPtr->matchLengthSumBasePrice - WEIGHT(optPtr->matchLengthFreq[mlCode], optLevel));\n    }\n\n    price += BITCOST_MULTIPLIER / 5;    \n\n    DEBUGLOG(8, \"ZSTD_getMatchPrice(ml:%u) = %u\", matchLength, price);\n    return price;\n}\n\n \nstatic void ZSTD_updateStats(optState_t* const optPtr,\n                             U32 litLength, const BYTE* literals,\n                             U32 offsetCode, U32 matchLength)\n{\n     \n    if (ZSTD_compressedLiterals(optPtr)) {\n        U32 u;\n        for (u=0; u < litLength; u++)\n            optPtr->litFreq[literals[u]] += ZSTD_LITFREQ_ADD;\n        optPtr->litSum += litLength*ZSTD_LITFREQ_ADD;\n    }\n\n     \n    {   U32 const llCode = ZSTD_LLcode(litLength);\n        optPtr->litLengthFreq[llCode]++;\n        optPtr->litLengthSum++;\n    }\n\n     \n    {   U32 const offCode = ZSTD_highbit32(offsetCode+1);\n        assert(offCode <= MaxOff);\n        optPtr->offCodeFreq[offCode]++;\n        optPtr->offCodeSum++;\n    }\n\n     \n    {   U32 const mlBase = matchLength - MINMATCH;\n        U32 const mlCode = ZSTD_MLcode(mlBase);\n        optPtr->matchLengthFreq[mlCode]++;\n        optPtr->matchLengthSum++;\n    }\n}\n\n\n \nMEM_STATIC U32 ZSTD_readMINMATCH(const void* memPtr, U32 length)\n{\n    switch (length)\n    {\n    default :\n    case 4 : return MEM_read32(memPtr);\n    case 3 : if (MEM_isLittleEndian())\n                return MEM_read32(memPtr)<<8;\n             else\n                return MEM_read32(memPtr)>>8;\n    }\n}\n\n\n \nstatic U32 ZSTD_insertAndFindFirstIndexHash3 (ZSTD_matchState_t* ms,\n                                              U32* nextToUpdate3,\n                                              const BYTE* const ip)\n{\n    U32* const hashTable3 = ms->hashTable3;\n    U32 const hashLog3 = ms->hashLog3;\n    const BYTE* const base = ms->window.base;\n    U32 idx = *nextToUpdate3;\n    U32 const target = (U32)(ip - base);\n    size_t const hash3 = ZSTD_hash3Ptr(ip, hashLog3);\n    assert(hashLog3 > 0);\n\n    while(idx < target) {\n        hashTable3[ZSTD_hash3Ptr(base+idx, hashLog3)] = idx;\n        idx++;\n    }\n\n    *nextToUpdate3 = target;\n    return hashTable3[hash3];\n}\n\n\n \n \nstatic U32 ZSTD_insertBt1(\n                ZSTD_matchState_t* ms,\n                const BYTE* const ip, const BYTE* const iend,\n                U32 const mls, const int extDict)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32*   const hashTable = ms->hashTable;\n    U32    const hashLog = cParams->hashLog;\n    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32*   const bt = ms->chainTable;\n    U32    const btLog  = cParams->chainLog - 1;\n    U32    const btMask = (1 << btLog) - 1;\n    U32 matchIndex = hashTable[h];\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* match;\n    const U32 current = (U32)(ip-base);\n    const U32 btLow = btMask >= current ? 0 : current - btMask;\n    U32* smallerPtr = bt + 2*(current&btMask);\n    U32* largerPtr  = smallerPtr + 1;\n    U32 dummy32;    \n    U32 const windowLow = ms->window.lowLimit;\n    U32 matchEndIdx = current+8+1;\n    size_t bestLength = 8;\n    U32 nbCompares = 1U << cParams->searchLog;\n#ifdef ZSTD_C_PREDICT\n    U32 predictedSmall = *(bt + 2*((current-1)&btMask) + 0);\n    U32 predictedLarge = *(bt + 2*((current-1)&btMask) + 1);\n    predictedSmall += (predictedSmall>0);\n    predictedLarge += (predictedLarge>0);\n#endif  \n\n    DEBUGLOG(8, \"ZSTD_insertBt1 (%u)\", current);\n\n    assert(ip <= iend-8);    \n    hashTable[h] = current;    \n\n    assert(windowLow > 0);\n    while (nbCompares-- && (matchIndex >= windowLow)) {\n        U32* const nextPtr = bt + 2*(matchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n        assert(matchIndex < current);\n\n#ifdef ZSTD_C_PREDICT    \n        const U32* predictPtr = bt + 2*((matchIndex-1) & btMask);    \n        if (matchIndex == predictedSmall) {\n             \n            *smallerPtr = matchIndex;\n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n            smallerPtr = nextPtr+1;                \n            matchIndex = nextPtr[1];               \n            predictedSmall = predictPtr[1] + (predictPtr[1]>0);\n            continue;\n        }\n        if (matchIndex == predictedLarge) {\n            *largerPtr = matchIndex;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n            predictedLarge = predictPtr[0] + (predictPtr[0]>0);\n            continue;\n        }\n#endif\n\n        if (!extDict || (matchIndex+matchLength >= dictLimit)) {\n            assert(matchIndex+matchLength >= dictLimit);    \n            match = base + matchIndex;\n            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);\n        } else {\n            match = dictBase + matchIndex;\n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n            if (matchIndex+matchLength >= dictLimit)\n                match = base + matchIndex;    \n        }\n\n        if (matchLength > bestLength) {\n            bestLength = matchLength;\n            if (matchLength > matchEndIdx - matchIndex)\n                matchEndIdx = matchIndex + (U32)matchLength;\n        }\n\n        if (ip+matchLength == iend) {    \n            break;    \n        }\n\n        if (match[matchLength] < ip[matchLength]) {   \n             \n            *smallerPtr = matchIndex;              \n            commonLengthSmaller = matchLength;     \n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n            smallerPtr = nextPtr+1;                \n            matchIndex = nextPtr[1];               \n        } else {\n             \n            *largerPtr = matchIndex;\n            commonLengthLarger = matchLength;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n    }   }\n\n    *smallerPtr = *largerPtr = 0;\n    {   U32 positions = 0;\n        if (bestLength > 384) positions = MIN(192, (U32)(bestLength - 384));    \n        assert(matchEndIdx > current + 8);\n        return MAX(positions, matchEndIdx - (current + 8));\n    }\n}\n\nFORCE_INLINE_TEMPLATE\nvoid ZSTD_updateTree_internal(\n                ZSTD_matchState_t* ms,\n                const BYTE* const ip, const BYTE* const iend,\n                const U32 mls, const ZSTD_dictMode_e dictMode)\n{\n    const BYTE* const base = ms->window.base;\n    U32 const target = (U32)(ip - base);\n    U32 idx = ms->nextToUpdate;\n    DEBUGLOG(6, \"ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)\",\n                idx, target, dictMode);\n\n    while(idx < target) {\n        U32 const forward = ZSTD_insertBt1(ms, base+idx, iend, mls, dictMode == ZSTD_extDict);\n        assert(idx < (U32)(idx + forward));\n        idx += forward;\n    }\n    assert((size_t)(ip - base) <= (size_t)(U32)(-1));\n    assert((size_t)(iend - base) <= (size_t)(U32)(-1));\n    ms->nextToUpdate = target;\n}\n\nvoid ZSTD_updateTree(ZSTD_matchState_t* ms, const BYTE* ip, const BYTE* iend) {\n    ZSTD_updateTree_internal(ms, ip, iend, ms->cParams.minMatch, ZSTD_noDict);\n}\n\nFORCE_INLINE_TEMPLATE\nU32 ZSTD_insertBtAndGetAllMatches (\n                    ZSTD_match_t* matches,    \n                    ZSTD_matchState_t* ms,\n                    U32* nextToUpdate3,\n                    const BYTE* const ip, const BYTE* const iLimit, const ZSTD_dictMode_e dictMode,\n                    const U32 rep[ZSTD_REP_NUM],\n                    U32 const ll0,    \n                    const U32 lengthToBeat,\n                    U32 const mls  )\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);\n    const BYTE* const base = ms->window.base;\n    U32 const current = (U32)(ip-base);\n    U32 const hashLog = cParams->hashLog;\n    U32 const minMatch = (mls==3) ? 3 : 4;\n    U32* const hashTable = ms->hashTable;\n    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32 matchIndex  = hashTable[h];\n    U32* const bt   = ms->chainTable;\n    U32 const btLog = cParams->chainLog - 1;\n    U32 const btMask= (1U << btLog) - 1;\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n    const BYTE* const dictBase = ms->window.dictBase;\n    U32 const dictLimit = ms->window.dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    U32 const btLow = (btMask >= current) ? 0 : current - btMask;\n    U32 const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);\n    U32 const matchLow = windowLow ? windowLow : 1;\n    U32* smallerPtr = bt + 2*(current&btMask);\n    U32* largerPtr  = bt + 2*(current&btMask) + 1;\n    U32 matchEndIdx = current+8+1;    \n    U32 dummy32;    \n    U32 mnum = 0;\n    U32 nbCompares = 1U << cParams->searchLog;\n\n    const ZSTD_matchState_t* dms    = dictMode == ZSTD_dictMatchState ? ms->dictMatchState : NULL;\n    const ZSTD_compressionParameters* const dmsCParams =\n                                      dictMode == ZSTD_dictMatchState ? &dms->cParams : NULL;\n    const BYTE* const dmsBase       = dictMode == ZSTD_dictMatchState ? dms->window.base : NULL;\n    const BYTE* const dmsEnd        = dictMode == ZSTD_dictMatchState ? dms->window.nextSrc : NULL;\n    U32         const dmsHighLimit  = dictMode == ZSTD_dictMatchState ? (U32)(dmsEnd - dmsBase) : 0;\n    U32         const dmsLowLimit   = dictMode == ZSTD_dictMatchState ? dms->window.lowLimit : 0;\n    U32         const dmsIndexDelta = dictMode == ZSTD_dictMatchState ? windowLow - dmsHighLimit : 0;\n    U32         const dmsHashLog    = dictMode == ZSTD_dictMatchState ? dmsCParams->hashLog : hashLog;\n    U32         const dmsBtLog      = dictMode == ZSTD_dictMatchState ? dmsCParams->chainLog - 1 : btLog;\n    U32         const dmsBtMask     = dictMode == ZSTD_dictMatchState ? (1U << dmsBtLog) - 1 : 0;\n    U32         const dmsBtLow      = dictMode == ZSTD_dictMatchState && dmsBtMask < dmsHighLimit - dmsLowLimit ? dmsHighLimit - dmsBtMask : dmsLowLimit;\n\n    size_t bestLength = lengthToBeat-1;\n    DEBUGLOG(8, \"ZSTD_insertBtAndGetAllMatches: current=%u\", current);\n\n     \n    assert(ll0 <= 1);    \n    {   U32 const lastR = ZSTD_REP_NUM + ll0;\n        U32 repCode;\n        for (repCode = ll0; repCode < lastR; repCode++) {\n            U32 const repOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];\n            U32 const repIndex = current - repOffset;\n            U32 repLen = 0;\n            assert(current >= dictLimit);\n            if (repOffset-1   < current-dictLimit) {   \n                 \n                if ((repIndex >= windowLow) & (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(ip - repOffset, minMatch))) {\n                    repLen = (U32)ZSTD_count(ip+minMatch, ip+minMatch-repOffset, iLimit) + minMatch;\n                }\n            } else {   \n                const BYTE* const repMatch = dictMode == ZSTD_dictMatchState ?\n                                             dmsBase + repIndex - dmsIndexDelta :\n                                             dictBase + repIndex;\n                assert(current >= windowLow);\n                if ( dictMode == ZSTD_extDict\n                  && ( ((repOffset-1)   < current - windowLow)   \n                     & (((U32)((dictLimit-1) - repIndex) >= 3) )  )\n                  && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {\n                    repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dictEnd, prefixStart) + minMatch;\n                }\n                if (dictMode == ZSTD_dictMatchState\n                  && ( ((repOffset-1)   < current - (dmsLowLimit + dmsIndexDelta))   \n                     & ((U32)((dictLimit-1) - repIndex) >= 3) )  \n                  && (ZSTD_readMINMATCH(ip, minMatch) == ZSTD_readMINMATCH(repMatch, minMatch)) ) {\n                    repLen = (U32)ZSTD_count_2segments(ip+minMatch, repMatch+minMatch, iLimit, dmsEnd, prefixStart) + minMatch;\n            }   }\n             \n            if (repLen > bestLength) {\n                DEBUGLOG(8, \"found repCode %u (ll0:%u, offset:%u) of length %u\",\n                            repCode, ll0, repOffset, repLen);\n                bestLength = repLen;\n                matches[mnum].off = repCode - ll0;\n                matches[mnum].len = (U32)repLen;\n                mnum++;\n                if ( (repLen > sufficient_len)\n                   | (ip+repLen == iLimit) ) {   \n                    return mnum;\n    }   }   }   }\n\n     \n    if ((mls == 3)   && (bestLength < mls)) {\n        U32 const matchIndex3 = ZSTD_insertAndFindFirstIndexHash3(ms, nextToUpdate3, ip);\n        if ((matchIndex3 >= matchLow)\n          & (current - matchIndex3 < (1<<18))   ) {\n            size_t mlen;\n            if ((dictMode == ZSTD_noDict)   || (dictMode == ZSTD_dictMatchState)   || (matchIndex3 >= dictLimit)) {\n                const BYTE* const match = base + matchIndex3;\n                mlen = ZSTD_count(ip, match, iLimit);\n            } else {\n                const BYTE* const match = dictBase + matchIndex3;\n                mlen = ZSTD_count_2segments(ip, match, iLimit, dictEnd, prefixStart);\n            }\n\n             \n            if (mlen >= mls  ) {\n                DEBUGLOG(8, \"found small match with hlog3, of length %u\",\n                            (U32)mlen);\n                bestLength = mlen;\n                assert(current > matchIndex3);\n                assert(mnum==0);   \n                matches[0].off = (current - matchIndex3) + ZSTD_REP_MOVE;\n                matches[0].len = (U32)mlen;\n                mnum = 1;\n                if ( (mlen > sufficient_len) |\n                     (ip+mlen == iLimit) ) {   \n                    ms->nextToUpdate = current+1;   \n                    return 1;\n        }   }   }\n         \n    }\n\n    hashTable[h] = current;    \n\n    while (nbCompares-- && (matchIndex >= matchLow)) {\n        U32* const nextPtr = bt + 2*(matchIndex & btMask);\n        const BYTE* match;\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n        assert(current > matchIndex);\n\n        if ((dictMode == ZSTD_noDict) || (dictMode == ZSTD_dictMatchState) || (matchIndex+matchLength >= dictLimit)) {\n            assert(matchIndex+matchLength >= dictLimit);   \n            match = base + matchIndex;\n            if (matchIndex >= dictLimit) assert(memcmp(match, ip, matchLength) == 0);   \n            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iLimit);\n        } else {\n            match = dictBase + matchIndex;\n            assert(memcmp(match, ip, matchLength) == 0);   \n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dictEnd, prefixStart);\n            if (matchIndex+matchLength >= dictLimit)\n                match = base + matchIndex;    \n        }\n\n        if (matchLength > bestLength) {\n            DEBUGLOG(8, \"found match of length %u at distance %u (offCode=%u)\",\n                    (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);\n            assert(matchEndIdx > matchIndex);\n            if (matchLength > matchEndIdx - matchIndex)\n                matchEndIdx = matchIndex + (U32)matchLength;\n            bestLength = matchLength;\n            matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;\n            matches[mnum].len = (U32)matchLength;\n            mnum++;\n            if ( (matchLength > ZSTD_OPT_NUM)\n               | (ip+matchLength == iLimit)  ) {\n                if (dictMode == ZSTD_dictMatchState) nbCompares = 0;  \n                break;  \n            }\n        }\n\n        if (match[matchLength] < ip[matchLength]) {\n             \n            *smallerPtr = matchIndex;              \n            commonLengthSmaller = matchLength;     \n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n            smallerPtr = nextPtr+1;                \n            matchIndex = nextPtr[1];               \n        } else {\n            *largerPtr = matchIndex;\n            commonLengthLarger = matchLength;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n    }   }\n\n    *smallerPtr = *largerPtr = 0;\n\n    if (dictMode == ZSTD_dictMatchState && nbCompares) {\n        size_t const dmsH = ZSTD_hashPtr(ip, dmsHashLog, mls);\n        U32 dictMatchIndex = dms->hashTable[dmsH];\n        const U32* const dmsBt = dms->chainTable;\n        commonLengthSmaller = commonLengthLarger = 0;\n        while (nbCompares-- && (dictMatchIndex > dmsLowLimit)) {\n            const U32* const nextPtr = dmsBt + 2*(dictMatchIndex & dmsBtMask);\n            size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n            const BYTE* match = dmsBase + dictMatchIndex;\n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iLimit, dmsEnd, prefixStart);\n            if (dictMatchIndex+matchLength >= dmsHighLimit)\n                match = base + dictMatchIndex + dmsIndexDelta;    \n\n            if (matchLength > bestLength) {\n                matchIndex = dictMatchIndex + dmsIndexDelta;\n                DEBUGLOG(8, \"found dms match of length %u at distance %u (offCode=%u)\",\n                        (U32)matchLength, current - matchIndex, current - matchIndex + ZSTD_REP_MOVE);\n                if (matchLength > matchEndIdx - matchIndex)\n                    matchEndIdx = matchIndex + (U32)matchLength;\n                bestLength = matchLength;\n                matches[mnum].off = (current - matchIndex) + ZSTD_REP_MOVE;\n                matches[mnum].len = (U32)matchLength;\n                mnum++;\n                if ( (matchLength > ZSTD_OPT_NUM)\n                   | (ip+matchLength == iLimit)  ) {\n                    break;    \n                }\n            }\n\n            if (dictMatchIndex <= dmsBtLow) { break; }    \n            if (match[matchLength] < ip[matchLength]) {\n                commonLengthSmaller = matchLength;     \n                dictMatchIndex = nextPtr[1];               \n            } else {\n                 \n                commonLengthLarger = matchLength;\n                dictMatchIndex = nextPtr[0];\n            }\n        }\n    }\n\n    assert(matchEndIdx > current+8);\n    ms->nextToUpdate = matchEndIdx - 8;   \n    return mnum;\n}\n\n\nFORCE_INLINE_TEMPLATE U32 ZSTD_BtGetAllMatches (\n                        ZSTD_match_t* matches,    \n                        ZSTD_matchState_t* ms,\n                        U32* nextToUpdate3,\n                        const BYTE* ip, const BYTE* const iHighLimit, const ZSTD_dictMode_e dictMode,\n                        const U32 rep[ZSTD_REP_NUM],\n                        U32 const ll0,\n                        U32 const lengthToBeat)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32 const matchLengthSearch = cParams->minMatch;\n    DEBUGLOG(8, \"ZSTD_BtGetAllMatches\");\n    if (ip < ms->window.base + ms->nextToUpdate) return 0;    \n    ZSTD_updateTree_internal(ms, ip, iHighLimit, matchLengthSearch, dictMode);\n    switch(matchLengthSearch)\n    {\n    case 3 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 3);\n    default :\n    case 4 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 4);\n    case 5 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 5);\n    case 7 :\n    case 6 : return ZSTD_insertBtAndGetAllMatches(matches, ms, nextToUpdate3, ip, iHighLimit, dictMode, rep, ll0, lengthToBeat, 6);\n    }\n}\n\n\n \n\n\nstatic U32 ZSTD_totalLen(ZSTD_optimal_t sol)\n{\n    return sol.litlen + sol.mlen;\n}\n\n#if 0  \n\nstatic void\nlistStats(const U32* table, int lastEltID)\n{\n    int const nbElts = lastEltID + 1;\n    int enb;\n    for (enb=0; enb < nbElts; enb++) {\n        (void)table;\n         \n        RAWLOG(2, \"%4i,\", table[enb]);\n    }\n    RAWLOG(2, \" \\n\");\n}\n\n#endif\n\nFORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_opt_generic(ZSTD_matchState_t* ms,\n                               seqStore_t* seqStore,\n                               U32 rep[ZSTD_REP_NUM],\n                         const void* src, size_t srcSize,\n                         const int optLevel,\n                         const ZSTD_dictMode_e dictMode)\n{\n    optState_t* const optStatePtr = &ms->opt;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const prefixStart = base + ms->window.dictLimit;\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n\n    U32 const sufficient_len = MIN(cParams->targetLength, ZSTD_OPT_NUM -1);\n    U32 const minMatch = (cParams->minMatch == 3) ? 3 : 4;\n    U32 nextToUpdate3 = ms->nextToUpdate;\n\n    ZSTD_optimal_t* const opt = optStatePtr->priceTable;\n    ZSTD_match_t* const matches = optStatePtr->matchTable;\n    ZSTD_optimal_t lastSequence;\n\n     \n    DEBUGLOG(5, \"ZSTD_compressBlock_opt_generic: current=%u, prefix=%u, nextToUpdate=%u\",\n                (U32)(ip - base), ms->window.dictLimit, ms->nextToUpdate);\n    assert(optLevel <= 2);\n    ZSTD_rescaleFreqs(optStatePtr, (const BYTE*)src, srcSize, optLevel);\n    ip += (ip==prefixStart);\n\n     \n    while (ip < ilimit) {\n        U32 cur, last_pos = 0;\n\n         \n        {   U32 const litlen = (U32)(ip - anchor);\n            U32 const ll0 = !litlen;\n            U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, ip, iend, dictMode, rep, ll0, minMatch);\n            if (!nbMatches) { ip++; continue; }\n\n             \n            { U32 i ; for (i=0; i<ZSTD_REP_NUM; i++) opt[0].rep[i] = rep[i]; }\n            opt[0].mlen = 0;   \n            opt[0].litlen = litlen;\n             \n            opt[0].price = ZSTD_litLengthPrice(litlen, optStatePtr, optLevel);\n\n             \n            {   U32 const maxML = matches[nbMatches-1].len;\n                U32 const maxOffset = matches[nbMatches-1].off;\n                DEBUGLOG(6, \"found %u matches of maxLength=%u and maxOffCode=%u at cPos=%u => start new series\",\n                            nbMatches, maxML, maxOffset, (U32)(ip-prefixStart));\n\n                if (maxML > sufficient_len) {\n                    lastSequence.litlen = litlen;\n                    lastSequence.mlen = maxML;\n                    lastSequence.off = maxOffset;\n                    DEBUGLOG(6, \"large match (%u>%u), immediate encoding\",\n                                maxML, sufficient_len);\n                    cur = 0;\n                    last_pos = ZSTD_totalLen(lastSequence);\n                    goto _shortestPath;\n            }   }\n\n             \n            {   U32 const literalsPrice = opt[0].price + ZSTD_litLengthPrice(0, optStatePtr, optLevel);\n                U32 pos;\n                U32 matchNb;\n                for (pos = 1; pos < minMatch; pos++) {\n                    opt[pos].price = ZSTD_MAX_PRICE;    \n                }\n                for (matchNb = 0; matchNb < nbMatches; matchNb++) {\n                    U32 const offset = matches[matchNb].off;\n                    U32 const end = matches[matchNb].len;\n                    for ( ; pos <= end ; pos++ ) {\n                        U32 const matchPrice = ZSTD_getMatchPrice(offset, pos, optStatePtr, optLevel);\n                        U32 const sequencePrice = literalsPrice + matchPrice;\n                        DEBUGLOG(7, \"rPos:%u => set initial price : %.2f\",\n                                    pos, ZSTD_fCost(sequencePrice));\n                        opt[pos].mlen = pos;\n                        opt[pos].off = offset;\n                        opt[pos].litlen = litlen;\n                        opt[pos].price = sequencePrice;\n                }   }\n                last_pos = pos-1;\n            }\n        }\n\n         \n        for (cur = 1; cur <= last_pos; cur++) {\n            const BYTE* const inr = ip + cur;\n            assert(cur < ZSTD_OPT_NUM);\n            DEBUGLOG(7, \"cPos:%zi==rPos:%u\", inr-istart, cur)\n\n             \n            {   U32 const litlen = (opt[cur-1].mlen == 0) ? opt[cur-1].litlen + 1 : 1;\n                int const price = opt[cur-1].price\n                                + ZSTD_rawLiteralsCost(ip+cur-1, 1, optStatePtr, optLevel)\n                                + ZSTD_litLengthPrice(litlen, optStatePtr, optLevel)\n                                - ZSTD_litLengthPrice(litlen-1, optStatePtr, optLevel);\n                assert(price < 1000000000);  \n                if (price <= opt[cur].price) {\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u : better price (%.2f<=%.2f) using literal (ll==%u) (hist:%u,%u,%u)\",\n                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price), litlen,\n                                opt[cur-1].rep[0], opt[cur-1].rep[1], opt[cur-1].rep[2]);\n                    opt[cur].mlen = 0;\n                    opt[cur].off = 0;\n                    opt[cur].litlen = litlen;\n                    opt[cur].price = price;\n                } else {\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u : literal would cost more (%.2f>%.2f) (hist:%u,%u,%u)\",\n                                inr-istart, cur, ZSTD_fCost(price), ZSTD_fCost(opt[cur].price),\n                                opt[cur].rep[0], opt[cur].rep[1], opt[cur].rep[2]);\n                }\n            }\n\n             \n            ZSTD_STATIC_ASSERT(sizeof(opt[cur].rep) == sizeof(repcodes_t));\n            assert(cur >= opt[cur].mlen);\n            if (opt[cur].mlen != 0) {\n                U32 const prev = cur - opt[cur].mlen;\n                repcodes_t newReps = ZSTD_updateRep(opt[prev].rep, opt[cur].off, opt[cur].litlen==0);\n                memcpy(opt[cur].rep, &newReps, sizeof(repcodes_t));\n            } else {\n                memcpy(opt[cur].rep, opt[cur - 1].rep, sizeof(repcodes_t));\n            }\n\n             \n            if (inr > ilimit) continue;\n\n            if (cur == last_pos) break;\n\n            if ( (optLevel==0)  \n              && (opt[cur+1].price <= opt[cur].price + (BITCOST_MULTIPLIER/2)) ) {\n                DEBUGLOG(7, \"move to next rPos:%u : price is <=\", cur+1);\n                continue;   \n            }\n\n            {   U32 const ll0 = (opt[cur].mlen != 0);\n                U32 const litlen = (opt[cur].mlen == 0) ? opt[cur].litlen : 0;\n                U32 const previousPrice = opt[cur].price;\n                U32 const basePrice = previousPrice + ZSTD_litLengthPrice(0, optStatePtr, optLevel);\n                U32 const nbMatches = ZSTD_BtGetAllMatches(matches, ms, &nextToUpdate3, inr, iend, dictMode, opt[cur].rep, ll0, minMatch);\n                U32 matchNb;\n                if (!nbMatches) {\n                    DEBUGLOG(7, \"rPos:%u : no match found\", cur);\n                    continue;\n                }\n\n                {   U32 const maxML = matches[nbMatches-1].len;\n                    DEBUGLOG(7, \"cPos:%zi==rPos:%u, found %u matches, of maxLength=%u\",\n                                inr-istart, cur, nbMatches, maxML);\n\n                    if ( (maxML > sufficient_len)\n                      || (cur + maxML >= ZSTD_OPT_NUM) ) {\n                        lastSequence.mlen = maxML;\n                        lastSequence.off = matches[nbMatches-1].off;\n                        lastSequence.litlen = litlen;\n                        cur -= (opt[cur].mlen==0) ? opt[cur].litlen : 0;   \n                        last_pos = cur + ZSTD_totalLen(lastSequence);\n                        if (cur > ZSTD_OPT_NUM) cur = 0;    \n                        goto _shortestPath;\n                }   }\n\n                 \n                for (matchNb = 0; matchNb < nbMatches; matchNb++) {\n                    U32 const offset = matches[matchNb].off;\n                    U32 const lastML = matches[matchNb].len;\n                    U32 const startML = (matchNb>0) ? matches[matchNb-1].len+1 : minMatch;\n                    U32 mlen;\n\n                    DEBUGLOG(7, \"testing match %u => offCode=%4u, mlen=%2u, llen=%2u\",\n                                matchNb, matches[matchNb].off, lastML, litlen);\n\n                    for (mlen = lastML; mlen >= startML; mlen--) {   \n                        U32 const pos = cur + mlen;\n                        int const price = basePrice + ZSTD_getMatchPrice(offset, mlen, optStatePtr, optLevel);\n\n                        if ((pos > last_pos) || (price < opt[pos].price)) {\n                            DEBUGLOG(7, \"rPos:%u (ml=%2u) => new better price (%.2f<%.2f)\",\n                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));\n                            while (last_pos < pos) { opt[last_pos+1].price = ZSTD_MAX_PRICE; last_pos++; }    \n                            opt[pos].mlen = mlen;\n                            opt[pos].off = offset;\n                            opt[pos].litlen = litlen;\n                            opt[pos].price = price;\n                        } else {\n                            DEBUGLOG(7, \"rPos:%u (ml=%2u) => new price is worse (%.2f>=%.2f)\",\n                                        pos, mlen, ZSTD_fCost(price), ZSTD_fCost(opt[pos].price));\n                            if (optLevel==0) break;   \n                        }\n            }   }   }\n        }   \n\n        lastSequence = opt[last_pos];\n        cur = last_pos > ZSTD_totalLen(lastSequence) ? last_pos - ZSTD_totalLen(lastSequence) : 0;   \n        assert(cur < ZSTD_OPT_NUM);   \n\n_shortestPath:    \n        assert(opt[0].mlen == 0);\n\n         \n        if (lastSequence.mlen != 0) {\n            repcodes_t reps = ZSTD_updateRep(opt[cur].rep, lastSequence.off, lastSequence.litlen==0);\n            memcpy(rep, &reps, sizeof(reps));\n        } else {\n            memcpy(rep, opt[cur].rep, sizeof(repcodes_t));\n        }\n\n        {   U32 const storeEnd = cur + 1;\n            U32 storeStart = storeEnd;\n            U32 seqPos = cur;\n\n            DEBUGLOG(6, \"start reverse traversal (last_pos:%u, cur:%u)\",\n                        last_pos, cur); (void)last_pos;\n            assert(storeEnd < ZSTD_OPT_NUM);\n            DEBUGLOG(6, \"last sequence copied into pos=%u (llen=%u,mlen=%u,ofc=%u)\",\n                        storeEnd, lastSequence.litlen, lastSequence.mlen, lastSequence.off);\n            opt[storeEnd] = lastSequence;\n            while (seqPos > 0) {\n                U32 const backDist = ZSTD_totalLen(opt[seqPos]);\n                storeStart--;\n                DEBUGLOG(6, \"sequence from rPos=%u copied into pos=%u (llen=%u,mlen=%u,ofc=%u)\",\n                            seqPos, storeStart, opt[seqPos].litlen, opt[seqPos].mlen, opt[seqPos].off);\n                opt[storeStart] = opt[seqPos];\n                seqPos = (seqPos > backDist) ? seqPos - backDist : 0;\n            }\n\n             \n            DEBUGLOG(6, \"sending selected sequences into seqStore\")\n            {   U32 storePos;\n                for (storePos=storeStart; storePos <= storeEnd; storePos++) {\n                    U32 const llen = opt[storePos].litlen;\n                    U32 const mlen = opt[storePos].mlen;\n                    U32 const offCode = opt[storePos].off;\n                    U32 const advance = llen + mlen;\n                    DEBUGLOG(6, \"considering seq starting at %zi, llen=%u, mlen=%u\",\n                                anchor - istart, (unsigned)llen, (unsigned)mlen);\n\n                    if (mlen==0) {   \n                        assert(storePos == storeEnd);    \n                        ip = anchor + llen;      \n                        continue;    \n                    }\n\n                    assert(anchor + llen <= iend);\n                    ZSTD_updateStats(optStatePtr, llen, anchor, offCode, mlen);\n                    ZSTD_storeSeq(seqStore, llen, anchor, iend, offCode, mlen-MINMATCH);\n                    anchor += advance;\n                    ip = anchor;\n            }   }\n            ZSTD_setBasePrices(optStatePtr, optLevel);\n        }\n    }    \n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_btopt(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    DEBUGLOG(5, \"ZSTD_compressBlock_btopt\");\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0  , ZSTD_noDict);\n}\n\n\n \nstatic U32 ZSTD_upscaleStat(unsigned* table, U32 lastEltIndex, int bonus)\n{\n    U32 s, sum=0;\n    assert(ZSTD_FREQ_DIV+bonus >= 0);\n    for (s=0; s<lastEltIndex+1; s++) {\n        table[s] <<= ZSTD_FREQ_DIV+bonus;\n        table[s]--;\n        sum += table[s];\n    }\n    return sum;\n}\n\n \nMEM_STATIC void ZSTD_upscaleStats(optState_t* optPtr)\n{\n    if (ZSTD_compressedLiterals(optPtr))\n        optPtr->litSum = ZSTD_upscaleStat(optPtr->litFreq, MaxLit, 0);\n    optPtr->litLengthSum = ZSTD_upscaleStat(optPtr->litLengthFreq, MaxLL, 0);\n    optPtr->matchLengthSum = ZSTD_upscaleStat(optPtr->matchLengthFreq, MaxML, 0);\n    optPtr->offCodeSum = ZSTD_upscaleStat(optPtr->offCodeFreq, MaxOff, 0);\n}\n\n \nstatic void\nZSTD_initStats_ultra(ZSTD_matchState_t* ms,\n                     seqStore_t* seqStore,\n                     U32 rep[ZSTD_REP_NUM],\n               const void* src, size_t srcSize)\n{\n    U32 tmpRep[ZSTD_REP_NUM];   \n    memcpy(tmpRep, rep, sizeof(tmpRep));\n\n    DEBUGLOG(4, \"ZSTD_initStats_ultra (srcSize=%zu)\", srcSize);\n    assert(ms->opt.litLengthSum == 0);     \n    assert(seqStore->sequences == seqStore->sequencesStart);    \n    assert(ms->window.dictLimit == ms->window.lowLimit);    \n    assert(ms->window.dictLimit - ms->nextToUpdate <= 1);   \n\n    ZSTD_compressBlock_opt_generic(ms, seqStore, tmpRep, src, srcSize, 2  , ZSTD_noDict);    \n\n     \n    ZSTD_resetSeqStore(seqStore);\n    ms->window.base -= srcSize;\n    ms->window.dictLimit += (U32)srcSize;\n    ms->window.lowLimit = ms->window.dictLimit;\n    ms->nextToUpdate = ms->window.dictLimit;\n\n     \n    ZSTD_upscaleStats(&ms->opt);\n}\n\nsize_t ZSTD_compressBlock_btultra(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    DEBUGLOG(5, \"ZSTD_compressBlock_btultra (srcSize=%zu)\", srcSize);\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2  , ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_btultra2(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    U32 const current = (U32)((const BYTE*)src - ms->window.base);\n    DEBUGLOG(5, \"ZSTD_compressBlock_btultra2 (srcSize=%zu)\", srcSize);\n\n     \n    assert(srcSize <= ZSTD_BLOCKSIZE_MAX);\n    if ( (ms->opt.litLengthSum==0)    \n      && (seqStore->sequences == seqStore->sequencesStart)   \n      && (ms->window.dictLimit == ms->window.lowLimit)    \n      && (current == ms->window.dictLimit)    \n      && (srcSize > ZSTD_PREDEF_THRESHOLD)\n      ) {\n        ZSTD_initStats_ultra(ms, seqStore, rep, src, srcSize);\n    }\n\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2  , ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_btopt_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0  , ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_btultra_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2  , ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_btopt_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 0  , ZSTD_extDict);\n}\n\nsize_t ZSTD_compressBlock_btultra_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        const void* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_opt_generic(ms, seqStore, rep, src, srcSize, 2  , ZSTD_extDict);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}