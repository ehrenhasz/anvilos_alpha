{
  "module_name": "zstd_double_fast.c",
  "hash_id": "09ba96b2ccdaa2cd98d1e43952efedf88173a7d0c8af728fd2ca453d82faebfe",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/zstd_double_fast.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"\n#include \"zstd_double_fast.h\"\n\n\nvoid ZSTD_fillDoubleHashTable(ZSTD_matchState_t* ms,\n                              void const* end, ZSTD_dictTableLoadMethod_e dtlm)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashLarge = ms->hashTable;\n    U32  const hBitsL = cParams->hashLog;\n    U32  const mls = cParams->minMatch;\n    U32* const hashSmall = ms->chainTable;\n    U32  const hBitsS = cParams->chainLog;\n    const BYTE* const base = ms->window.base;\n    const BYTE* ip = base + ms->nextToUpdate;\n    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;\n    const U32 fastHashFillStep = 3;\n\n     \n    for (; ip + fastHashFillStep - 1 <= iend; ip += fastHashFillStep) {\n        U32 const current = (U32)(ip - base);\n        U32 i;\n        for (i = 0; i < fastHashFillStep; ++i) {\n            size_t const smHash = ZSTD_hashPtr(ip + i, hBitsS, mls);\n            size_t const lgHash = ZSTD_hashPtr(ip + i, hBitsL, 8);\n            if (i == 0)\n                hashSmall[smHash] = current + i;\n            if (i == 0 || hashLarge[lgHash] == 0)\n                hashLarge[lgHash] = current + i;\n             \n            if (dtlm == ZSTD_dtlm_fast)\n                break;\n    }   }\n}\n\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_doubleFast_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize,\n        U32 const mls  , ZSTD_dictMode_e const dictMode)\n{\n    ZSTD_compressionParameters const* cParams = &ms->cParams;\n    U32* const hashLong = ms->hashTable;\n    const U32 hBitsL = cParams->hashLog;\n    U32* const hashSmall = ms->chainTable;\n    const U32 hBitsS = cParams->chainLog;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const U32 endIndex = (U32)((size_t)(istart - base) + srcSize);\n     \n    const U32 prefixLowestIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);\n    const BYTE* const prefixLowest = base + prefixLowestIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n    U32 offset_1=rep[0], offset_2=rep[1];\n    U32 offsetSaved = 0;\n\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const ZSTD_compressionParameters* const dictCParams =\n                                     dictMode == ZSTD_dictMatchState ?\n                                     &dms->cParams : NULL;\n    const U32* const dictHashLong  = dictMode == ZSTD_dictMatchState ?\n                                     dms->hashTable : NULL;\n    const U32* const dictHashSmall = dictMode == ZSTD_dictMatchState ?\n                                     dms->chainTable : NULL;\n    const U32 dictStartIndex       = dictMode == ZSTD_dictMatchState ?\n                                     dms->window.dictLimit : 0;\n    const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?\n                                     dms->window.base : NULL;\n    const BYTE* const dictStart    = dictMode == ZSTD_dictMatchState ?\n                                     dictBase + dictStartIndex : NULL;\n    const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?\n                                     dms->window.nextSrc : NULL;\n    const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?\n                                     prefixLowestIndex - (U32)(dictEnd - dictBase) :\n                                     0;\n    const U32 dictHBitsL           = dictMode == ZSTD_dictMatchState ?\n                                     dictCParams->hashLog : hBitsL;\n    const U32 dictHBitsS           = dictMode == ZSTD_dictMatchState ?\n                                     dictCParams->chainLog : hBitsS;\n    const U32 dictAndPrefixLength  = (U32)((ip - prefixLowest) + (dictEnd - dictStart));\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_doubleFast_generic\");\n\n    assert(dictMode == ZSTD_noDict || dictMode == ZSTD_dictMatchState);\n\n     \n    if (dictMode == ZSTD_dictMatchState) {\n        assert(ms->window.dictLimit + (1U << cParams->windowLog) >= endIndex);\n    }\n\n     \n    ip += (dictAndPrefixLength == 0);\n    if (dictMode == ZSTD_noDict) {\n        U32 const current = (U32)(ip - base);\n        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, cParams->windowLog);\n        U32 const maxRep = current - windowLow;\n        if (offset_2 > maxRep) offsetSaved = offset_2, offset_2 = 0;\n        if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;\n    }\n    if (dictMode == ZSTD_dictMatchState) {\n         \n        assert(offset_1 <= dictAndPrefixLength);\n        assert(offset_2 <= dictAndPrefixLength);\n    }\n\n     \n    while (ip < ilimit) {    \n        size_t mLength;\n        U32 offset;\n        size_t const h2 = ZSTD_hashPtr(ip, hBitsL, 8);\n        size_t const h = ZSTD_hashPtr(ip, hBitsS, mls);\n        size_t const dictHL = ZSTD_hashPtr(ip, dictHBitsL, 8);\n        size_t const dictHS = ZSTD_hashPtr(ip, dictHBitsS, mls);\n        U32 const current = (U32)(ip-base);\n        U32 const matchIndexL = hashLong[h2];\n        U32 matchIndexS = hashSmall[h];\n        const BYTE* matchLong = base + matchIndexL;\n        const BYTE* match = base + matchIndexS;\n        const U32 repIndex = current + 1 - offset_1;\n        const BYTE* repMatch = (dictMode == ZSTD_dictMatchState\n                            && repIndex < prefixLowestIndex) ?\n                               dictBase + (repIndex - dictIndexDelta) :\n                               base + repIndex;\n        hashLong[h2] = hashSmall[h] = current;    \n\n         \n        if (dictMode == ZSTD_dictMatchState\n            && ((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n            && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);\n            goto _match_stored;\n        }\n\n         \n        if ( dictMode == ZSTD_noDict\n          && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {\n            mLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);\n            goto _match_stored;\n        }\n\n        if (matchIndexL > prefixLowestIndex) {\n             \n            if (MEM_read64(matchLong) == MEM_read64(ip)) {\n                mLength = ZSTD_count(ip+8, matchLong+8, iend) + 8;\n                offset = (U32)(ip-matchLong);\n                while (((ip>anchor) & (matchLong>prefixLowest)) && (ip[-1] == matchLong[-1])) { ip--; matchLong--; mLength++; }  \n                goto _match_found;\n            }\n        } else if (dictMode == ZSTD_dictMatchState) {\n             \n            U32 const dictMatchIndexL = dictHashLong[dictHL];\n            const BYTE* dictMatchL = dictBase + dictMatchIndexL;\n            assert(dictMatchL < dictEnd);\n\n            if (dictMatchL > dictStart && MEM_read64(dictMatchL) == MEM_read64(ip)) {\n                mLength = ZSTD_count_2segments(ip+8, dictMatchL+8, iend, dictEnd, prefixLowest) + 8;\n                offset = (U32)(current - dictMatchIndexL - dictIndexDelta);\n                while (((ip>anchor) & (dictMatchL>dictStart)) && (ip[-1] == dictMatchL[-1])) { ip--; dictMatchL--; mLength++; }  \n                goto _match_found;\n        }   }\n\n        if (matchIndexS > prefixLowestIndex) {\n             \n            if (MEM_read32(match) == MEM_read32(ip)) {\n                goto _search_next_long;\n            }\n        } else if (dictMode == ZSTD_dictMatchState) {\n             \n            U32 const dictMatchIndexS = dictHashSmall[dictHS];\n            match = dictBase + dictMatchIndexS;\n            matchIndexS = dictMatchIndexS + dictIndexDelta;\n\n            if (match > dictStart && MEM_read32(match) == MEM_read32(ip)) {\n                goto _search_next_long;\n        }   }\n\n        ip += ((ip-anchor) >> kSearchStrength) + 1;\n#if defined(__aarch64__)\n        PREFETCH_L1(ip+256);\n#endif\n        continue;\n\n_search_next_long:\n\n        {   size_t const hl3 = ZSTD_hashPtr(ip+1, hBitsL, 8);\n            size_t const dictHLNext = ZSTD_hashPtr(ip+1, dictHBitsL, 8);\n            U32 const matchIndexL3 = hashLong[hl3];\n            const BYTE* matchL3 = base + matchIndexL3;\n            hashLong[hl3] = current + 1;\n\n             \n            if (matchIndexL3 > prefixLowestIndex) {\n                if (MEM_read64(matchL3) == MEM_read64(ip+1)) {\n                    mLength = ZSTD_count(ip+9, matchL3+8, iend) + 8;\n                    ip++;\n                    offset = (U32)(ip-matchL3);\n                    while (((ip>anchor) & (matchL3>prefixLowest)) && (ip[-1] == matchL3[-1])) { ip--; matchL3--; mLength++; }  \n                    goto _match_found;\n                }\n            } else if (dictMode == ZSTD_dictMatchState) {\n                 \n                U32 const dictMatchIndexL3 = dictHashLong[dictHLNext];\n                const BYTE* dictMatchL3 = dictBase + dictMatchIndexL3;\n                assert(dictMatchL3 < dictEnd);\n                if (dictMatchL3 > dictStart && MEM_read64(dictMatchL3) == MEM_read64(ip+1)) {\n                    mLength = ZSTD_count_2segments(ip+1+8, dictMatchL3+8, iend, dictEnd, prefixLowest) + 8;\n                    ip++;\n                    offset = (U32)(current + 1 - dictMatchIndexL3 - dictIndexDelta);\n                    while (((ip>anchor) & (dictMatchL3>dictStart)) && (ip[-1] == dictMatchL3[-1])) { ip--; dictMatchL3--; mLength++; }  \n                    goto _match_found;\n        }   }   }\n\n         \n        if (dictMode == ZSTD_dictMatchState && matchIndexS < prefixLowestIndex) {\n            mLength = ZSTD_count_2segments(ip+4, match+4, iend, dictEnd, prefixLowest) + 4;\n            offset = (U32)(current - matchIndexS);\n            while (((ip>anchor) & (match>dictStart)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }  \n        } else {\n            mLength = ZSTD_count(ip+4, match+4, iend) + 4;\n            offset = (U32)(ip - match);\n            while (((ip>anchor) & (match>prefixLowest)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }  \n        }\n\n         \n\n_match_found:\n        offset_2 = offset_1;\n        offset_1 = offset;\n\n        ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);\n\n_match_stored:\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n             \n            {   U32 const indexToInsert = current+2;\n                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;\n                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);\n                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;\n                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);\n            }\n\n             \n            if (dictMode == ZSTD_dictMatchState) {\n                while (ip <= ilimit) {\n                    U32 const current2 = (U32)(ip-base);\n                    U32 const repIndex2 = current2 - offset_2;\n                    const BYTE* repMatch2 = dictMode == ZSTD_dictMatchState\n                        && repIndex2 < prefixLowestIndex ?\n                            dictBase + repIndex2 - dictIndexDelta :\n                            base + repIndex2;\n                    if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex2) >= 3  )\n                       && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                        const BYTE* const repEnd2 = repIndex2 < prefixLowestIndex ? dictEnd : iend;\n                        size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixLowest) + 4;\n                        U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;    \n                        ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);\n                        hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = current2;\n                        hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = current2;\n                        ip += repLength2;\n                        anchor = ip;\n                        continue;\n                    }\n                    break;\n            }   }\n\n            if (dictMode == ZSTD_noDict) {\n                while ( (ip <= ilimit)\n                     && ( (offset_2>0)\n                        & (MEM_read32(ip) == MEM_read32(ip - offset_2)) )) {\n                     \n                    size_t const rLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;\n                    U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff;   \n                    hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = (U32)(ip-base);\n                    hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = (U32)(ip-base);\n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, rLength-MINMATCH);\n                    ip += rLength;\n                    anchor = ip;\n                    continue;    \n        }   }   }\n    }    \n\n     \n    rep[0] = offset_1 ? offset_1 : offsetSaved;\n    rep[1] = offset_2 ? offset_2 : offsetSaved;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_doubleFast(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    const U32 mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 4, ZSTD_noDict);\n    case 5 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 5, ZSTD_noDict);\n    case 6 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 6, ZSTD_noDict);\n    case 7 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 7, ZSTD_noDict);\n    }\n}\n\n\nsize_t ZSTD_compressBlock_doubleFast_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    const U32 mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 4, ZSTD_dictMatchState);\n    case 5 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 5, ZSTD_dictMatchState);\n    case 6 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 6, ZSTD_dictMatchState);\n    case 7 :\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, 7, ZSTD_dictMatchState);\n    }\n}\n\n\nstatic size_t ZSTD_compressBlock_doubleFast_extDict_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize,\n        U32 const mls  )\n{\n    ZSTD_compressionParameters const* cParams = &ms->cParams;\n    U32* const hashLong = ms->hashTable;\n    U32  const hBitsL = cParams->hashLog;\n    U32* const hashSmall = ms->chainTable;\n    U32  const hBitsS = cParams->chainLog;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms->window.base;\n    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);\n    const U32   lowLimit = ZSTD_getLowestMatchIndex(ms, endIndex, cParams->windowLog);\n    const U32   dictStartIndex = lowLimit;\n    const U32   dictLimit = ms->window.dictLimit;\n    const U32   prefixStartIndex = (dictLimit > lowLimit) ? dictLimit : lowLimit;\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const BYTE* const dictStart = dictBase + dictStartIndex;\n    const BYTE* const dictEnd = dictBase + prefixStartIndex;\n    U32 offset_1=rep[0], offset_2=rep[1];\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_doubleFast_extDict_generic (srcSize=%zu)\", srcSize);\n\n     \n    if (prefixStartIndex == dictStartIndex)\n        return ZSTD_compressBlock_doubleFast_generic(ms, seqStore, rep, src, srcSize, mls, ZSTD_noDict);\n\n     \n    while (ip < ilimit) {   \n        const size_t hSmall = ZSTD_hashPtr(ip, hBitsS, mls);\n        const U32 matchIndex = hashSmall[hSmall];\n        const BYTE* const matchBase = matchIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* match = matchBase + matchIndex;\n\n        const size_t hLong = ZSTD_hashPtr(ip, hBitsL, 8);\n        const U32 matchLongIndex = hashLong[hLong];\n        const BYTE* const matchLongBase = matchLongIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* matchLong = matchLongBase + matchLongIndex;\n\n        const U32 current = (U32)(ip-base);\n        const U32 repIndex = current + 1 - offset_1;    \n        const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* const repMatch = repBase + repIndex;\n        size_t mLength;\n        hashSmall[hSmall] = hashLong[hLong] = current;    \n\n        if ((((U32)((prefixStartIndex-1) - repIndex) >= 3)  \n            & (offset_1 < current+1 - dictStartIndex))  \n          && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;\n            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);\n        } else {\n            if ((matchLongIndex > dictStartIndex) && (MEM_read64(matchLong) == MEM_read64(ip))) {\n                const BYTE* const matchEnd = matchLongIndex < prefixStartIndex ? dictEnd : iend;\n                const BYTE* const lowMatchPtr = matchLongIndex < prefixStartIndex ? dictStart : prefixStart;\n                U32 offset;\n                mLength = ZSTD_count_2segments(ip+8, matchLong+8, iend, matchEnd, prefixStart) + 8;\n                offset = current - matchLongIndex;\n                while (((ip>anchor) & (matchLong>lowMatchPtr)) && (ip[-1] == matchLong[-1])) { ip--; matchLong--; mLength++; }    \n                offset_2 = offset_1;\n                offset_1 = offset;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);\n\n            } else if ((matchIndex > dictStartIndex) && (MEM_read32(match) == MEM_read32(ip))) {\n                size_t const h3 = ZSTD_hashPtr(ip+1, hBitsL, 8);\n                U32 const matchIndex3 = hashLong[h3];\n                const BYTE* const match3Base = matchIndex3 < prefixStartIndex ? dictBase : base;\n                const BYTE* match3 = match3Base + matchIndex3;\n                U32 offset;\n                hashLong[h3] = current + 1;\n                if ( (matchIndex3 > dictStartIndex) && (MEM_read64(match3) == MEM_read64(ip+1)) ) {\n                    const BYTE* const matchEnd = matchIndex3 < prefixStartIndex ? dictEnd : iend;\n                    const BYTE* const lowMatchPtr = matchIndex3 < prefixStartIndex ? dictStart : prefixStart;\n                    mLength = ZSTD_count_2segments(ip+9, match3+8, iend, matchEnd, prefixStart) + 8;\n                    ip++;\n                    offset = current+1 - matchIndex3;\n                    while (((ip>anchor) & (match3>lowMatchPtr)) && (ip[-1] == match3[-1])) { ip--; match3--; mLength++; }  \n                } else {\n                    const BYTE* const matchEnd = matchIndex < prefixStartIndex ? dictEnd : iend;\n                    const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;\n                    mLength = ZSTD_count_2segments(ip+4, match+4, iend, matchEnd, prefixStart) + 4;\n                    offset = current - matchIndex;\n                    while (((ip>anchor) & (match>lowMatchPtr)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }    \n                }\n                offset_2 = offset_1;\n                offset_1 = offset;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);\n\n            } else {\n                ip += ((ip-anchor) >> kSearchStrength) + 1;\n                continue;\n        }   }\n\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n             \n            {   U32 const indexToInsert = current+2;\n                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;\n                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);\n                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;\n                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);\n            }\n\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;\n                if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3)    \n                    & (offset_2 < current2 - dictStartIndex))\n                  && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;\n                    U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);\n                    hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = current2;\n                    hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n    }   }   }\n\n     \n    rep[0] = offset_1;\n    rep[1] = offset_2;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_doubleFast_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_doubleFast_extDict_generic(ms, seqStore, rep, src, srcSize, 4);\n    case 5 :\n        return ZSTD_compressBlock_doubleFast_extDict_generic(ms, seqStore, rep, src, srcSize, 5);\n    case 6 :\n        return ZSTD_compressBlock_doubleFast_extDict_generic(ms, seqStore, rep, src, srcSize, 6);\n    case 7 :\n        return ZSTD_compressBlock_doubleFast_extDict_generic(ms, seqStore, rep, src, srcSize, 7);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}