{
  "module_name": "zstd_lazy.c",
  "hash_id": "83bf6ee1e1cf4b653784642f8b917338bf84aa10b7e704a221d4c4183f3bd8da",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/zstd_lazy.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"\n#include \"zstd_lazy.h\"\n\n\n \n\nstatic void\nZSTD_updateDUBT(ZSTD_matchState_t* ms,\n                const BYTE* ip, const BYTE* iend,\n                U32 mls)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32  const hashLog = cParams->hashLog;\n\n    U32* const bt = ms->chainTable;\n    U32  const btLog  = cParams->chainLog - 1;\n    U32  const btMask = (1 << btLog) - 1;\n\n    const BYTE* const base = ms->window.base;\n    U32 const target = (U32)(ip - base);\n    U32 idx = ms->nextToUpdate;\n\n    if (idx != target)\n        DEBUGLOG(7, \"ZSTD_updateDUBT, from %u to %u (dictLimit:%u)\",\n                    idx, target, ms->window.dictLimit);\n    assert(ip + 8 <= iend);    \n    (void)iend;\n\n    assert(idx >= ms->window.dictLimit);    \n    for ( ; idx < target ; idx++) {\n        size_t const h  = ZSTD_hashPtr(base + idx, hashLog, mls);    \n        U32    const matchIndex = hashTable[h];\n\n        U32*   const nextCandidatePtr = bt + 2*(idx&btMask);\n        U32*   const sortMarkPtr  = nextCandidatePtr + 1;\n\n        DEBUGLOG(8, \"ZSTD_updateDUBT: insert %u\", idx);\n        hashTable[h] = idx;    \n        *nextCandidatePtr = matchIndex;    \n        *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;\n    }\n    ms->nextToUpdate = target;\n}\n\n\n \nstatic void\nZSTD_insertDUBT1(ZSTD_matchState_t* ms,\n                 U32 current, const BYTE* inputEnd,\n                 U32 nbCompares, U32 btLow,\n                 const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const bt = ms->chainTable;\n    U32  const btLog  = cParams->chainLog - 1;\n    U32  const btMask = (1 << btLog) - 1;\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const ip = (current>=dictLimit) ? base + current : dictBase + current;\n    const BYTE* const iend = (current>=dictLimit) ? inputEnd : dictBase + dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* match;\n    U32* smallerPtr = bt + 2*(current&btMask);\n    U32* largerPtr  = smallerPtr + 1;\n    U32 matchIndex = *smallerPtr;    \n    U32 dummy32;    \n    U32 const windowValid = ms->window.lowLimit;\n    U32 const maxDistance = 1U << cParams->windowLog;\n    U32 const windowLow = (current - windowValid > maxDistance) ? current - maxDistance : windowValid;\n\n\n    DEBUGLOG(8, \"ZSTD_insertDUBT1(%u) (dictLimit=%u, lowLimit=%u)\",\n                current, dictLimit, windowLow);\n    assert(current >= btLow);\n    assert(ip < iend);    \n\n    while (nbCompares-- && (matchIndex > windowLow)) {\n        U32* const nextPtr = bt + 2*(matchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n        assert(matchIndex < current);\n         \n\n        if ( (dictMode != ZSTD_extDict)\n          || (matchIndex+matchLength >= dictLimit)   \n          || (current < dictLimit)  ) {\n            const BYTE* const mBase = ( (dictMode != ZSTD_extDict)\n                                     || (matchIndex+matchLength >= dictLimit)) ?\n                                        base : dictBase;\n            assert( (matchIndex+matchLength >= dictLimit)    \n                 || (current < dictLimit) );\n            match = mBase + matchIndex;\n            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);\n        } else {\n            match = dictBase + matchIndex;\n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n            if (matchIndex+matchLength >= dictLimit)\n                match = base + matchIndex;    \n        }\n\n        DEBUGLOG(8, \"ZSTD_insertDUBT1: comparing %u with %u : found %u common bytes \",\n                    current, matchIndex, (U32)matchLength);\n\n        if (ip+matchLength == iend) {    \n            break;    \n        }\n\n        if (match[matchLength] < ip[matchLength]) {   \n             \n            *smallerPtr = matchIndex;              \n            commonLengthSmaller = matchLength;     \n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n            DEBUGLOG(8, \"ZSTD_insertDUBT1: %u (>btLow=%u) is smaller : next => %u\",\n                        matchIndex, btLow, nextPtr[1]);\n            smallerPtr = nextPtr+1;                \n            matchIndex = nextPtr[1];               \n        } else {\n             \n            *largerPtr = matchIndex;\n            commonLengthLarger = matchLength;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n            DEBUGLOG(8, \"ZSTD_insertDUBT1: %u (>btLow=%u) is larger => %u\",\n                        matchIndex, btLow, nextPtr[0]);\n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n    }   }\n\n    *smallerPtr = *largerPtr = 0;\n}\n\n\nstatic size_t\nZSTD_DUBT_findBetterDictMatch (\n        ZSTD_matchState_t* ms,\n        const BYTE* const ip, const BYTE* const iend,\n        size_t* offsetPtr,\n        size_t bestLength,\n        U32 nbCompares,\n        U32 const mls,\n        const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_matchState_t * const dms = ms->dictMatchState;\n    const ZSTD_compressionParameters* const dmsCParams = &dms->cParams;\n    const U32 * const dictHashTable = dms->hashTable;\n    U32         const hashLog = dmsCParams->hashLog;\n    size_t      const h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32               dictMatchIndex = dictHashTable[h];\n\n    const BYTE* const base = ms->window.base;\n    const BYTE* const prefixStart = base + ms->window.dictLimit;\n    U32         const current = (U32)(ip-base);\n    const BYTE* const dictBase = dms->window.base;\n    const BYTE* const dictEnd = dms->window.nextSrc;\n    U32         const dictHighLimit = (U32)(dms->window.nextSrc - dms->window.base);\n    U32         const dictLowLimit = dms->window.lowLimit;\n    U32         const dictIndexDelta = ms->window.lowLimit - dictHighLimit;\n\n    U32*        const dictBt = dms->chainTable;\n    U32         const btLog  = dmsCParams->chainLog - 1;\n    U32         const btMask = (1 << btLog) - 1;\n    U32         const btLow = (btMask >= dictHighLimit - dictLowLimit) ? dictLowLimit : dictHighLimit - btMask;\n\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n\n    (void)dictMode;\n    assert(dictMode == ZSTD_dictMatchState);\n\n    while (nbCompares-- && (dictMatchIndex > dictLowLimit)) {\n        U32* const nextPtr = dictBt + 2*(dictMatchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n        const BYTE* match = dictBase + dictMatchIndex;\n        matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n        if (dictMatchIndex+matchLength >= dictHighLimit)\n            match = base + dictMatchIndex + dictIndexDelta;    \n\n        if (matchLength > bestLength) {\n            U32 matchIndex = dictMatchIndex + dictIndexDelta;\n            if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {\n                DEBUGLOG(9, \"ZSTD_DUBT_findBetterDictMatch(%u) : found better match length %u -> %u and offsetCode %u -> %u (dictMatchIndex %u, matchIndex %u)\",\n                    current, (U32)bestLength, (U32)matchLength, (U32)*offsetPtr, ZSTD_REP_MOVE + current - matchIndex, dictMatchIndex, matchIndex);\n                bestLength = matchLength, *offsetPtr = ZSTD_REP_MOVE + current - matchIndex;\n            }\n            if (ip+matchLength == iend) {    \n                break;    \n            }\n        }\n\n        if (match[matchLength] < ip[matchLength]) {\n            if (dictMatchIndex <= btLow) { break; }    \n            commonLengthSmaller = matchLength;     \n            dictMatchIndex = nextPtr[1];               \n        } else {\n             \n            if (dictMatchIndex <= btLow) { break; }    \n            commonLengthLarger = matchLength;\n            dictMatchIndex = nextPtr[0];\n        }\n    }\n\n    if (bestLength >= MINMATCH) {\n        U32 const mIndex = current - ((U32)*offsetPtr - ZSTD_REP_MOVE); (void)mIndex;\n        DEBUGLOG(8, \"ZSTD_DUBT_findBetterDictMatch(%u) : found match of length %u and offsetCode %u (pos %u)\",\n                    current, (U32)bestLength, (U32)*offsetPtr, mIndex);\n    }\n    return bestLength;\n\n}\n\n\nstatic size_t\nZSTD_DUBT_findBestMatch(ZSTD_matchState_t* ms,\n                        const BYTE* const ip, const BYTE* const iend,\n                        size_t* offsetPtr,\n                        U32 const mls,\n                        const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32*   const hashTable = ms->hashTable;\n    U32    const hashLog = cParams->hashLog;\n    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32          matchIndex  = hashTable[h];\n\n    const BYTE* const base = ms->window.base;\n    U32    const current = (U32)(ip-base);\n    U32    const windowLow = ZSTD_getLowestMatchIndex(ms, current, cParams->windowLog);\n\n    U32*   const bt = ms->chainTable;\n    U32    const btLog  = cParams->chainLog - 1;\n    U32    const btMask = (1 << btLog) - 1;\n    U32    const btLow = (btMask >= current) ? 0 : current - btMask;\n    U32    const unsortLimit = MAX(btLow, windowLow);\n\n    U32*         nextCandidate = bt + 2*(matchIndex&btMask);\n    U32*         unsortedMark = bt + 2*(matchIndex&btMask) + 1;\n    U32          nbCompares = 1U << cParams->searchLog;\n    U32          nbCandidates = nbCompares;\n    U32          previousCandidate = 0;\n\n    DEBUGLOG(7, \"ZSTD_DUBT_findBestMatch (%u) \", current);\n    assert(ip <= iend-8);    \n\n     \n    while ( (matchIndex > unsortLimit)\n         && (*unsortedMark == ZSTD_DUBT_UNSORTED_MARK)\n         && (nbCandidates > 1) ) {\n        DEBUGLOG(8, \"ZSTD_DUBT_findBestMatch: candidate %u is unsorted\",\n                    matchIndex);\n        *unsortedMark = previousCandidate;   \n        previousCandidate = matchIndex;\n        matchIndex = *nextCandidate;\n        nextCandidate = bt + 2*(matchIndex&btMask);\n        unsortedMark = bt + 2*(matchIndex&btMask) + 1;\n        nbCandidates --;\n    }\n\n     \n    if ( (matchIndex > unsortLimit)\n      && (*unsortedMark==ZSTD_DUBT_UNSORTED_MARK) ) {\n        DEBUGLOG(7, \"ZSTD_DUBT_findBestMatch: nullify last unsorted candidate %u\",\n                    matchIndex);\n        *nextCandidate = *unsortedMark = 0;\n    }\n\n     \n    matchIndex = previousCandidate;\n    while (matchIndex) {   \n        U32* const nextCandidateIdxPtr = bt + 2*(matchIndex&btMask) + 1;\n        U32 const nextCandidateIdx = *nextCandidateIdxPtr;\n        ZSTD_insertDUBT1(ms, matchIndex, iend,\n                         nbCandidates, unsortLimit, dictMode);\n        matchIndex = nextCandidateIdx;\n        nbCandidates++;\n    }\n\n     \n    {   size_t commonLengthSmaller = 0, commonLengthLarger = 0;\n        const BYTE* const dictBase = ms->window.dictBase;\n        const U32 dictLimit = ms->window.dictLimit;\n        const BYTE* const dictEnd = dictBase + dictLimit;\n        const BYTE* const prefixStart = base + dictLimit;\n        U32* smallerPtr = bt + 2*(current&btMask);\n        U32* largerPtr  = bt + 2*(current&btMask) + 1;\n        U32 matchEndIdx = current + 8 + 1;\n        U32 dummy32;    \n        size_t bestLength = 0;\n\n        matchIndex  = hashTable[h];\n        hashTable[h] = current;    \n\n        while (nbCompares-- && (matchIndex > windowLow)) {\n            U32* const nextPtr = bt + 2*(matchIndex & btMask);\n            size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n            const BYTE* match;\n\n            if ((dictMode != ZSTD_extDict) || (matchIndex+matchLength >= dictLimit)) {\n                match = base + matchIndex;\n                matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);\n            } else {\n                match = dictBase + matchIndex;\n                matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n                if (matchIndex+matchLength >= dictLimit)\n                    match = base + matchIndex;    \n            }\n\n            if (matchLength > bestLength) {\n                if (matchLength > matchEndIdx - matchIndex)\n                    matchEndIdx = matchIndex + (U32)matchLength;\n                if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(current-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )\n                    bestLength = matchLength, *offsetPtr = ZSTD_REP_MOVE + current - matchIndex;\n                if (ip+matchLength == iend) {    \n                    if (dictMode == ZSTD_dictMatchState) {\n                        nbCompares = 0;  \n                    }\n                    break;    \n                }\n            }\n\n            if (match[matchLength] < ip[matchLength]) {\n                 \n                *smallerPtr = matchIndex;              \n                commonLengthSmaller = matchLength;     \n                if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n                smallerPtr = nextPtr+1;                \n                matchIndex = nextPtr[1];               \n            } else {\n                 \n                *largerPtr = matchIndex;\n                commonLengthLarger = matchLength;\n                if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n                largerPtr = nextPtr;\n                matchIndex = nextPtr[0];\n        }   }\n\n        *smallerPtr = *largerPtr = 0;\n\n        if (dictMode == ZSTD_dictMatchState && nbCompares) {\n            bestLength = ZSTD_DUBT_findBetterDictMatch(\n                    ms, ip, iend,\n                    offsetPtr, bestLength, nbCompares,\n                    mls, dictMode);\n        }\n\n        assert(matchEndIdx > current+8);  \n        ms->nextToUpdate = matchEndIdx - 8;    \n        if (bestLength >= MINMATCH) {\n            U32 const mIndex = current - ((U32)*offsetPtr - ZSTD_REP_MOVE); (void)mIndex;\n            DEBUGLOG(8, \"ZSTD_DUBT_findBestMatch(%u) : found match of length %u and offsetCode %u (pos %u)\",\n                        current, (U32)bestLength, (U32)*offsetPtr, mIndex);\n        }\n        return bestLength;\n    }\n}\n\n\n \nFORCE_INLINE_TEMPLATE size_t\nZSTD_BtFindBestMatch( ZSTD_matchState_t* ms,\n                const BYTE* const ip, const BYTE* const iLimit,\n                      size_t* offsetPtr,\n                const U32 mls  ,\n                const ZSTD_dictMode_e dictMode)\n{\n    DEBUGLOG(7, \"ZSTD_BtFindBestMatch\");\n    if (ip < ms->window.base + ms->nextToUpdate) return 0;    \n    ZSTD_updateDUBT(ms, ip, iLimit, mls);\n    return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);\n}\n\n\nstatic size_t\nZSTD_BtFindBestMatch_selectMLS (  ZSTD_matchState_t* ms,\n                            const BYTE* ip, const BYTE* const iLimit,\n                                  size_t* offsetPtr)\n{\n    switch(ms->cParams.minMatch)\n    {\n    default :  \n    case 4 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 4, ZSTD_noDict);\n    case 5 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 5, ZSTD_noDict);\n    case 7 :\n    case 6 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 6, ZSTD_noDict);\n    }\n}\n\n\nstatic size_t ZSTD_BtFindBestMatch_dictMatchState_selectMLS (\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* const iLimit,\n                        size_t* offsetPtr)\n{\n    switch(ms->cParams.minMatch)\n    {\n    default :  \n    case 4 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 4, ZSTD_dictMatchState);\n    case 5 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 5, ZSTD_dictMatchState);\n    case 7 :\n    case 6 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 6, ZSTD_dictMatchState);\n    }\n}\n\n\nstatic size_t ZSTD_BtFindBestMatch_extDict_selectMLS (\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* const iLimit,\n                        size_t* offsetPtr)\n{\n    switch(ms->cParams.minMatch)\n    {\n    default :  \n    case 4 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 4, ZSTD_extDict);\n    case 5 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 5, ZSTD_extDict);\n    case 7 :\n    case 6 : return ZSTD_BtFindBestMatch(ms, ip, iLimit, offsetPtr, 6, ZSTD_extDict);\n    }\n}\n\n\n\n \n#define NEXT_IN_CHAIN(d, mask)   chainTable[(d) & (mask)]\n\n \nstatic U32 ZSTD_insertAndFindFirstIndex_internal(\n                        ZSTD_matchState_t* ms,\n                        const ZSTD_compressionParameters* const cParams,\n                        const BYTE* ip, U32 const mls)\n{\n    U32* const hashTable  = ms->hashTable;\n    const U32 hashLog = cParams->hashLog;\n    U32* const chainTable = ms->chainTable;\n    const U32 chainMask = (1 << cParams->chainLog) - 1;\n    const BYTE* const base = ms->window.base;\n    const U32 target = (U32)(ip - base);\n    U32 idx = ms->nextToUpdate;\n\n    while(idx < target) {  \n        size_t const h = ZSTD_hashPtr(base+idx, hashLog, mls);\n        NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];\n        hashTable[h] = idx;\n        idx++;\n    }\n\n    ms->nextToUpdate = target;\n    return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];\n}\n\nU32 ZSTD_insertAndFindFirstIndex(ZSTD_matchState_t* ms, const BYTE* ip) {\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    return ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, ms->cParams.minMatch);\n}\n\n\n \nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_HcFindBestMatch_generic (\n                        ZSTD_matchState_t* ms,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        size_t* offsetPtr,\n                        const U32 mls, const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const chainTable = ms->chainTable;\n    const U32 chainSize = (1 << cParams->chainLog);\n    const U32 chainMask = chainSize-1;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const U32 current = (U32)(ip-base);\n    const U32 maxDistance = 1U << cParams->windowLog;\n    const U32 lowestValid = ms->window.lowLimit;\n    const U32 withinMaxDistance = (current - lowestValid > maxDistance) ? current - maxDistance : lowestValid;\n    const U32 isDictionary = (ms->loadedDictEnd != 0);\n    const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;\n    const U32 minChain = current > chainSize ? current - chainSize : 0;\n    U32 nbAttempts = 1U << cParams->searchLog;\n    size_t ml=4-1;\n\n     \n    U32 matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls);\n\n    for ( ; (matchIndex>lowLimit) & (nbAttempts>0) ; nbAttempts--) {\n        size_t currentMl=0;\n        if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {\n            const BYTE* const match = base + matchIndex;\n            assert(matchIndex >= dictLimit);    \n            if (match[ml] == ip[ml])    \n                currentMl = ZSTD_count(ip, match, iLimit);\n        } else {\n            const BYTE* const match = dictBase + matchIndex;\n            assert(match+4 <= dictEnd);\n            if (MEM_read32(match) == MEM_read32(ip))    \n                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;\n        }\n\n         \n        if (currentMl > ml) {\n            ml = currentMl;\n            *offsetPtr = current - matchIndex + ZSTD_REP_MOVE;\n            if (ip+currentMl == iLimit) break;  \n        }\n\n        if (matchIndex <= minChain) break;\n        matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);\n    }\n\n    if (dictMode == ZSTD_dictMatchState) {\n        const ZSTD_matchState_t* const dms = ms->dictMatchState;\n        const U32* const dmsChainTable = dms->chainTable;\n        const U32 dmsChainSize         = (1 << dms->cParams.chainLog);\n        const U32 dmsChainMask         = dmsChainSize - 1;\n        const U32 dmsLowestIndex       = dms->window.dictLimit;\n        const BYTE* const dmsBase      = dms->window.base;\n        const BYTE* const dmsEnd       = dms->window.nextSrc;\n        const U32 dmsSize              = (U32)(dmsEnd - dmsBase);\n        const U32 dmsIndexDelta        = dictLimit - dmsSize;\n        const U32 dmsMinChain = dmsSize > dmsChainSize ? dmsSize - dmsChainSize : 0;\n\n        matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];\n\n        for ( ; (matchIndex>dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {\n            size_t currentMl=0;\n            const BYTE* const match = dmsBase + matchIndex;\n            assert(match+4 <= dmsEnd);\n            if (MEM_read32(match) == MEM_read32(ip))    \n                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;\n\n             \n            if (currentMl > ml) {\n                ml = currentMl;\n                *offsetPtr = current - (matchIndex + dmsIndexDelta) + ZSTD_REP_MOVE;\n                if (ip+currentMl == iLimit) break;  \n            }\n\n            if (matchIndex <= dmsMinChain) break;\n            matchIndex = dmsChainTable[matchIndex & dmsChainMask];\n        }\n    }\n\n    return ml;\n}\n\n\nFORCE_INLINE_TEMPLATE size_t ZSTD_HcFindBestMatch_selectMLS (\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* const iLimit,\n                        size_t* offsetPtr)\n{\n    switch(ms->cParams.minMatch)\n    {\n    default :  \n    case 4 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 4, ZSTD_noDict);\n    case 5 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 5, ZSTD_noDict);\n    case 7 :\n    case 6 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 6, ZSTD_noDict);\n    }\n}\n\n\nstatic size_t ZSTD_HcFindBestMatch_dictMatchState_selectMLS (\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* const iLimit,\n                        size_t* offsetPtr)\n{\n    switch(ms->cParams.minMatch)\n    {\n    default :  \n    case 4 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 4, ZSTD_dictMatchState);\n    case 5 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 5, ZSTD_dictMatchState);\n    case 7 :\n    case 6 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 6, ZSTD_dictMatchState);\n    }\n}\n\n\nFORCE_INLINE_TEMPLATE size_t ZSTD_HcFindBestMatch_extDict_selectMLS (\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* const iLimit,\n                        size_t* offsetPtr)\n{\n    switch(ms->cParams.minMatch)\n    {\n    default :  \n    case 4 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 4, ZSTD_extDict);\n    case 5 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 5, ZSTD_extDict);\n    case 7 :\n    case 6 : return ZSTD_HcFindBestMatch_generic(ms, ip, iLimit, offsetPtr, 6, ZSTD_extDict);\n    }\n}\n\n\n \ntypedef enum { search_hashChain, search_binaryTree } searchMethod_e;\n\nFORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_lazy_generic(\n                        ZSTD_matchState_t* ms, seqStore_t* seqStore,\n                        U32 rep[ZSTD_REP_NUM],\n                        const void* src, size_t srcSize,\n                        const searchMethod_e searchMethod, const U32 depth,\n                        ZSTD_dictMode_e const dictMode)\n{\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms->window.base;\n    const U32 prefixLowestIndex = ms->window.dictLimit;\n    const BYTE* const prefixLowest = base + prefixLowestIndex;\n\n    typedef size_t (*searchMax_f)(\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);\n    searchMax_f const searchMax = dictMode == ZSTD_dictMatchState ?\n        (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_dictMatchState_selectMLS\n                                         : ZSTD_HcFindBestMatch_dictMatchState_selectMLS) :\n        (searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_selectMLS\n                                         : ZSTD_HcFindBestMatch_selectMLS);\n    U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;\n\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const U32 dictLowestIndex      = dictMode == ZSTD_dictMatchState ?\n                                     dms->window.dictLimit : 0;\n    const BYTE* const dictBase     = dictMode == ZSTD_dictMatchState ?\n                                     dms->window.base : NULL;\n    const BYTE* const dictLowest   = dictMode == ZSTD_dictMatchState ?\n                                     dictBase + dictLowestIndex : NULL;\n    const BYTE* const dictEnd      = dictMode == ZSTD_dictMatchState ?\n                                     dms->window.nextSrc : NULL;\n    const U32 dictIndexDelta       = dictMode == ZSTD_dictMatchState ?\n                                     prefixLowestIndex - (U32)(dictEnd - dictBase) :\n                                     0;\n    const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_lazy_generic (dictMode=%u)\", (U32)dictMode);\n\n     \n    ip += (dictAndPrefixLength == 0);\n    if (dictMode == ZSTD_noDict) {\n        U32 const current = (U32)(ip - base);\n        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, ms->cParams.windowLog);\n        U32 const maxRep = current - windowLow;\n        if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;\n        if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;\n    }\n    if (dictMode == ZSTD_dictMatchState) {\n         \n        assert(offset_1 <= dictAndPrefixLength);\n        assert(offset_2 <= dictAndPrefixLength);\n    }\n\n     \n#if defined(__GNUC__) && defined(__x86_64__)\n     \n    __asm__(\".p2align 5\");\n#endif\n    while (ip < ilimit) {\n        size_t matchLength=0;\n        size_t offset=0;\n        const BYTE* start=ip+1;\n\n         \n        if (dictMode == ZSTD_dictMatchState) {\n            const U32 repIndex = (U32)(ip - base) + 1 - offset_1;\n            const BYTE* repMatch = (dictMode == ZSTD_dictMatchState\n                                && repIndex < prefixLowestIndex) ?\n                                   dictBase + (repIndex - dictIndexDelta) :\n                                   base + repIndex;\n            if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n                && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n                const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n                matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n                if (depth==0) goto _storeSequence;\n            }\n        }\n        if ( dictMode == ZSTD_noDict\n          && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {\n            matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;\n            if (depth==0) goto _storeSequence;\n        }\n\n         \n        {   size_t offsetFound = 999999999;\n            size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);\n            if (ml2 > matchLength)\n                matchLength = ml2, start = ip, offset=offsetFound;\n        }\n\n        if (matchLength < 4) {\n            ip += ((ip-anchor) >> kSearchStrength) + 1;    \n            continue;\n        }\n\n         \n        if (depth>=1)\n        while (ip<ilimit) {\n            ip ++;\n            if ( (dictMode == ZSTD_noDict)\n              && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {\n                size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;\n                int const gain2 = (int)(mlRep * 3);\n                int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);\n                if ((mlRep >= 4) && (gain2 > gain1))\n                    matchLength = mlRep, offset = 0, start = ip;\n            }\n            if (dictMode == ZSTD_dictMatchState) {\n                const U32 repIndex = (U32)(ip - base) - offset_1;\n                const BYTE* repMatch = repIndex < prefixLowestIndex ?\n                               dictBase + (repIndex - dictIndexDelta) :\n                               base + repIndex;\n                if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {\n                    const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n                    size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n                    int const gain2 = (int)(mlRep * 3);\n                    int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);\n                    if ((mlRep >= 4) && (gain2 > gain1))\n                        matchLength = mlRep, offset = 0, start = ip;\n                }\n            }\n            {   size_t offset2=999999999;\n                size_t const ml2 = searchMax(ms, ip, iend, &offset2);\n                int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));    \n                int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);\n                if ((ml2 >= 4) && (gain2 > gain1)) {\n                    matchLength = ml2, offset = offset2, start = ip;\n                    continue;    \n            }   }\n\n             \n            if ((depth==2) && (ip<ilimit)) {\n                ip ++;\n                if ( (dictMode == ZSTD_noDict)\n                  && (offset) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {\n                    size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;\n                    int const gain2 = (int)(mlRep * 4);\n                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);\n                    if ((mlRep >= 4) && (gain2 > gain1))\n                        matchLength = mlRep, offset = 0, start = ip;\n                }\n                if (dictMode == ZSTD_dictMatchState) {\n                    const U32 repIndex = (U32)(ip - base) - offset_1;\n                    const BYTE* repMatch = repIndex < prefixLowestIndex ?\n                                   dictBase + (repIndex - dictIndexDelta) :\n                                   base + repIndex;\n                    if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n                        && (MEM_read32(repMatch) == MEM_read32(ip)) ) {\n                        const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n                        size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n                        int const gain2 = (int)(mlRep * 4);\n                        int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);\n                        if ((mlRep >= 4) && (gain2 > gain1))\n                            matchLength = mlRep, offset = 0, start = ip;\n                    }\n                }\n                {   size_t offset2=999999999;\n                    size_t const ml2 = searchMax(ms, ip, iend, &offset2);\n                    int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));    \n                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);\n                    if ((ml2 >= 4) && (gain2 > gain1)) {\n                        matchLength = ml2, offset = offset2, start = ip;\n                        continue;\n            }   }   }\n            break;   \n        }\n\n         \n         \n        if (offset) {\n            if (dictMode == ZSTD_noDict) {\n                while ( ((start > anchor) & (start - (offset-ZSTD_REP_MOVE) > prefixLowest))\n                     && (start[-1] == (start-(offset-ZSTD_REP_MOVE))[-1]) )   \n                    { start--; matchLength++; }\n            }\n            if (dictMode == ZSTD_dictMatchState) {\n                U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));\n                const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;\n                const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;\n                while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }   \n            }\n            offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);\n        }\n         \n_storeSequence:\n        {   size_t const litLength = start - anchor;\n            ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);\n            anchor = ip = start + matchLength;\n        }\n\n         \n        if (dictMode == ZSTD_dictMatchState) {\n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex = current2 - offset_2;\n                const BYTE* repMatch = dictMode == ZSTD_dictMatchState\n                    && repIndex < prefixLowestIndex ?\n                        dictBase - dictIndexDelta + repIndex :\n                        base + repIndex;\n                if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3  )\n                   && (MEM_read32(repMatch) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;\n                    matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;\n                    offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);\n                    ip += matchLength;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n            }\n        }\n\n        if (dictMode == ZSTD_noDict) {\n            while ( ((ip <= ilimit) & (offset_2>0))\n                 && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {\n                 \n                matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;\n                offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;  \n                ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);\n                ip += matchLength;\n                anchor = ip;\n                continue;    \n    }   }   }\n\n     \n    rep[0] = offset_1 ? offset_1 : savedOffset;\n    rep[1] = offset_2 ? offset_2 : savedOffset;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_btlazy2(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_lazy2(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_lazy(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_greedy(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_btlazy2_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_lazy2_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_lazy_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_greedy_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_dictMatchState);\n}\n\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_lazy_extDict_generic(\n                        ZSTD_matchState_t* ms, seqStore_t* seqStore,\n                        U32 rep[ZSTD_REP_NUM],\n                        const void* src, size_t srcSize,\n                        const searchMethod_e searchMethod, const U32 depth)\n{\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms->window.base;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n    const BYTE* const dictStart  = dictBase + ms->window.lowLimit;\n    const U32 windowLog = ms->cParams.windowLog;\n\n    typedef size_t (*searchMax_f)(\n                        ZSTD_matchState_t* ms,\n                        const BYTE* ip, const BYTE* iLimit, size_t* offsetPtr);\n    searchMax_f searchMax = searchMethod==search_binaryTree ? ZSTD_BtFindBestMatch_extDict_selectMLS : ZSTD_HcFindBestMatch_extDict_selectMLS;\n\n    U32 offset_1 = rep[0], offset_2 = rep[1];\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_lazy_extDict_generic\");\n\n     \n    ip += (ip == prefixStart);\n\n     \n#if defined(__GNUC__) && defined(__x86_64__)\n     \n    __asm__(\".p2align 5\");\n#endif\n    while (ip < ilimit) {\n        size_t matchLength=0;\n        size_t offset=0;\n        const BYTE* start=ip+1;\n        U32 current = (U32)(ip-base);\n\n         \n        {   const U32 windowLow = ZSTD_getLowestMatchIndex(ms, current+1, windowLog);\n            const U32 repIndex = (U32)(current+1 - offset_1);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n               & (offset_1 < current+1 - windowLow) )  \n            if (MEM_read32(ip+1) == MEM_read32(repMatch)) {\n                 \n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                if (depth==0) goto _storeSequence;\n        }   }\n\n         \n        {   size_t offsetFound = 999999999;\n            size_t const ml2 = searchMax(ms, ip, iend, &offsetFound);\n            if (ml2 > matchLength)\n                matchLength = ml2, start = ip, offset=offsetFound;\n        }\n\n         if (matchLength < 4) {\n            ip += ((ip-anchor) >> kSearchStrength) + 1;    \n            continue;\n        }\n\n         \n        if (depth>=1)\n        while (ip<ilimit) {\n            ip ++;\n            current++;\n             \n            if (offset) {\n                const U32 windowLow = ZSTD_getLowestMatchIndex(ms, current, windowLog);\n                const U32 repIndex = (U32)(current - offset_1);\n                const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                const BYTE* const repMatch = repBase + repIndex;\n                    if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n                       & (offset_1 < current - windowLow) )  \n                if (MEM_read32(ip) == MEM_read32(repMatch)) {\n                     \n                    const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                    size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                    int const gain2 = (int)(repLength * 3);\n                    int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)offset+1) + 1);\n                    if ((repLength >= 4) && (gain2 > gain1))\n                        matchLength = repLength, offset = 0, start = ip;\n            }   }\n\n             \n            {   size_t offset2=999999999;\n                size_t const ml2 = searchMax(ms, ip, iend, &offset2);\n                int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));    \n                int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 4);\n                if ((ml2 >= 4) && (gain2 > gain1)) {\n                    matchLength = ml2, offset = offset2, start = ip;\n                    continue;    \n            }   }\n\n             \n            if ((depth==2) && (ip<ilimit)) {\n                ip ++;\n                current++;\n                 \n                if (offset) {\n                    const U32 windowLow = ZSTD_getLowestMatchIndex(ms, current, windowLog);\n                    const U32 repIndex = (U32)(current - offset_1);\n                    const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                    const BYTE* const repMatch = repBase + repIndex;\n                if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n                   & (offset_1 < current - windowLow) )  \n                    if (MEM_read32(ip) == MEM_read32(repMatch)) {\n                         \n                        const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                        size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                        int const gain2 = (int)(repLength * 4);\n                        int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 1);\n                        if ((repLength >= 4) && (gain2 > gain1))\n                            matchLength = repLength, offset = 0, start = ip;\n                }   }\n\n                 \n                {   size_t offset2=999999999;\n                    size_t const ml2 = searchMax(ms, ip, iend, &offset2);\n                    int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)offset2+1));    \n                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)offset+1) + 7);\n                    if ((ml2 >= 4) && (gain2 > gain1)) {\n                        matchLength = ml2, offset = offset2, start = ip;\n                        continue;\n            }   }   }\n            break;   \n        }\n\n         \n        if (offset) {\n            U32 const matchIndex = (U32)((start-base) - (offset - ZSTD_REP_MOVE));\n            const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;\n            const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;\n            while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }   \n            offset_2 = offset_1; offset_1 = (U32)(offset - ZSTD_REP_MOVE);\n        }\n\n         \n_storeSequence:\n        {   size_t const litLength = start - anchor;\n            ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offset, matchLength-MINMATCH);\n            anchor = ip = start + matchLength;\n        }\n\n         \n        while (ip <= ilimit) {\n            const U32 repCurrent = (U32)(ip-base);\n            const U32 windowLow = ZSTD_getLowestMatchIndex(ms, repCurrent, windowLog);\n            const U32 repIndex = repCurrent - offset_2;\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n               & (offset_2 < repCurrent - windowLow) )  \n            if (MEM_read32(ip) == MEM_read32(repMatch)) {\n                 \n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                offset = offset_2; offset_2 = offset_1; offset_1 = (U32)offset;    \n                ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, matchLength-MINMATCH);\n                ip += matchLength;\n                anchor = ip;\n                continue;    \n            }\n            break;\n    }   }\n\n     \n    rep[0] = offset_1;\n    rep[1] = offset_2;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_greedy_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0);\n}\n\nsize_t ZSTD_compressBlock_lazy_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1);\n}\n\nsize_t ZSTD_compressBlock_lazy2_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2);\n}\n\nsize_t ZSTD_compressBlock_btlazy2_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}