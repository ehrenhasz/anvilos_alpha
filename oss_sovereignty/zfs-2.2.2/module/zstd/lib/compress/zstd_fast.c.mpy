{
  "module_name": "zstd_fast.c",
  "hash_id": "bc8055c1d62c1bb4602fcc107f9eaec8c67f791a2413287b4d6b65d8d5e69b45",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/zstd_fast.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"   \n#include \"zstd_fast.h\"\n\n\nvoid ZSTD_fillHashTable(ZSTD_matchState_t* ms,\n                        const void* const end,\n                        ZSTD_dictTableLoadMethod_e dtlm)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32  const hBits = cParams->hashLog;\n    U32  const mls = cParams->minMatch;\n    const BYTE* const base = ms->window.base;\n    const BYTE* ip = base + ms->nextToUpdate;\n    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;\n    const U32 fastHashFillStep = 3;\n\n     \n    for ( ; ip + fastHashFillStep < iend + 2; ip += fastHashFillStep) {\n        U32 const current = (U32)(ip - base);\n        size_t const hash0 = ZSTD_hashPtr(ip, hBits, mls);\n        hashTable[hash0] = current;\n        if (dtlm == ZSTD_dtlm_fast) continue;\n         \n        {   U32 p;\n            for (p = 1; p < fastHashFillStep; ++p) {\n                size_t const hash = ZSTD_hashPtr(ip + p, hBits, mls);\n                if (hashTable[hash] == 0) {   \n                    hashTable[hash] = current + p;\n    }   }   }   }\n}\n\n\nFORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_fast_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize,\n        U32 const mls)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32 const hlog = cParams->hashLog;\n     \n    size_t const stepSize = cParams->targetLength + !(cParams->targetLength) + 1;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n     \n    const BYTE* ip0 = istart;\n    const BYTE* ip1;\n    const BYTE* anchor = istart;\n    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);\n    const U32   prefixStartIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n    U32 offset_1=rep[0], offset_2=rep[1];\n    U32 offsetSaved = 0;\n\n     \n    DEBUGLOG(5, \"ZSTD_compressBlock_fast_generic\");\n    ip0 += (ip0 == prefixStart);\n    ip1 = ip0 + 1;\n    {   U32 const current = (U32)(ip0 - base);\n        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, cParams->windowLog);\n        U32 const maxRep = current - windowLow;\n        if (offset_2 > maxRep) offsetSaved = offset_2, offset_2 = 0;\n        if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;\n    }\n\n     \n#ifdef __INTEL_COMPILER\n     \n    #pragma vector always\n#endif\n    while (ip1 < ilimit) {    \n        size_t mLength;\n        BYTE const* ip2 = ip0 + 2;\n        size_t const h0 = ZSTD_hashPtr(ip0, hlog, mls);\n        U32 const val0 = MEM_read32(ip0);\n        size_t const h1 = ZSTD_hashPtr(ip1, hlog, mls);\n        U32 const val1 = MEM_read32(ip1);\n        U32 const current0 = (U32)(ip0-base);\n        U32 const current1 = (U32)(ip1-base);\n        U32 const matchIndex0 = hashTable[h0];\n        U32 const matchIndex1 = hashTable[h1];\n        BYTE const* repMatch = ip2 - offset_1;\n        const BYTE* match0 = base + matchIndex0;\n        const BYTE* match1 = base + matchIndex1;\n        U32 offcode;\n\n#if defined(__aarch64__)\n        PREFETCH_L1(ip0+256);\n#endif\n\n        hashTable[h0] = current0;    \n        hashTable[h1] = current1;    \n\n        assert(ip0 + 1 == ip1);\n\n        if ((offset_1 > 0) & (MEM_read32(repMatch) == MEM_read32(ip2))) {\n            mLength = (ip2[-1] == repMatch[-1]) ? 1 : 0;\n            ip0 = ip2 - mLength;\n            match0 = repMatch - mLength;\n            mLength += 4;\n            offcode = 0;\n            goto _match;\n        }\n        if ((matchIndex0 > prefixStartIndex) && MEM_read32(match0) == val0) {\n             \n            goto _offset;\n        }\n        if ((matchIndex1 > prefixStartIndex) && MEM_read32(match1) == val1) {\n             \n            ip0 = ip1;\n            match0 = match1;\n            goto _offset;\n        }\n        {   size_t const step = ((size_t)(ip0-anchor) >> (kSearchStrength - 1)) + stepSize;\n            assert(step >= 2);\n            ip0 += step;\n            ip1 += step;\n            continue;\n        }\n_offset:  \n         \n        offset_2 = offset_1;\n        offset_1 = (U32)(ip0-match0);\n        offcode = offset_1 + ZSTD_REP_MOVE;\n        mLength = 4;\n         \n        while (((ip0>anchor) & (match0>prefixStart))\n             && (ip0[-1] == match0[-1])) { ip0--; match0--; mLength++; }  \n\n_match:  \n         \n        mLength += ZSTD_count(ip0+mLength, match0+mLength, iend);\n        ZSTD_storeSeq(seqStore, (size_t)(ip0-anchor), anchor, iend, offcode, mLength-MINMATCH);\n         \n        ip0 += mLength;\n        anchor = ip0;\n\n        if (ip0 <= ilimit) {\n             \n            assert(base+current0+2 > istart);   \n            hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;   \n            hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);\n\n            if (offset_2 > 0) {  \n                while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - offset_2)) ) {\n                     \n                    size_t const rLength = ZSTD_count(ip0+4, ip0+4-offset_2, iend) + 4;\n                    { U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff; }  \n                    hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);\n                    ip0 += rLength;\n                    ZSTD_storeSeq(seqStore, 0  , anchor, iend, 0  , rLength-MINMATCH);\n                    anchor = ip0;\n                    continue;    \n        }   }   }\n        ip1 = ip0 + 1;\n    }\n\n     \n    rep[0] = offset_1 ? offset_1 : offsetSaved;\n    rep[1] = offset_2 ? offset_2 : offsetSaved;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_fast(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    assert(ms->dictMatchState == NULL);\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 4);\n    case 5 :\n        return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 5);\n    case 6 :\n        return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 6);\n    case 7 :\n        return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, 7);\n    }\n}\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_fast_dictMatchState_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize, U32 const mls)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32 const hlog = cParams->hashLog;\n     \n    U32 const stepSize = cParams->targetLength + !(cParams->targetLength);\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const U32   prefixStartIndex = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n    U32 offset_1=rep[0], offset_2=rep[1];\n    U32 offsetSaved = 0;\n\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const ZSTD_compressionParameters* const dictCParams = &dms->cParams ;\n    const U32* const dictHashTable = dms->hashTable;\n    const U32 dictStartIndex       = dms->window.dictLimit;\n    const BYTE* const dictBase     = dms->window.base;\n    const BYTE* const dictStart    = dictBase + dictStartIndex;\n    const BYTE* const dictEnd      = dms->window.nextSrc;\n    const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);\n    const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);\n    const U32 dictHLog             = dictCParams->hashLog;\n\n     \n    const U32 maxDistance = 1U << cParams->windowLog;\n    const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);\n    assert(endIndex - prefixStartIndex <= maxDistance);\n    (void)maxDistance; (void)endIndex;    \n\n     \n    assert(prefixStartIndex >= (U32)(dictEnd - dictBase));\n\n     \n    DEBUGLOG(5, \"ZSTD_compressBlock_fast_dictMatchState_generic\");\n    ip += (dictAndPrefixLength == 0);\n     \n    assert(offset_1 <= dictAndPrefixLength);\n    assert(offset_2 <= dictAndPrefixLength);\n\n     \n    while (ip < ilimit) {    \n        size_t mLength;\n        size_t const h = ZSTD_hashPtr(ip, hlog, mls);\n        U32 const current = (U32)(ip-base);\n        U32 const matchIndex = hashTable[h];\n        const BYTE* match = base + matchIndex;\n        const U32 repIndex = current + 1 - offset_1;\n        const BYTE* repMatch = (repIndex < prefixStartIndex) ?\n                               dictBase + (repIndex - dictIndexDelta) :\n                               base + repIndex;\n        hashTable[h] = current;    \n\n        if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3)  \n          && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;\n            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, mLength-MINMATCH);\n        } else if ( (matchIndex <= prefixStartIndex) ) {\n            size_t const dictHash = ZSTD_hashPtr(ip, dictHLog, mls);\n            U32 const dictMatchIndex = dictHashTable[dictHash];\n            const BYTE* dictMatch = dictBase + dictMatchIndex;\n            if (dictMatchIndex <= dictStartIndex ||\n                MEM_read32(dictMatch) != MEM_read32(ip)) {\n                assert(stepSize >= 1);\n                ip += ((ip-anchor) >> kSearchStrength) + stepSize;\n                continue;\n            } else {\n                 \n                U32 const offset = (U32)(current-dictMatchIndex-dictIndexDelta);\n                mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;\n                while (((ip>anchor) & (dictMatch>dictStart))\n                     && (ip[-1] == dictMatch[-1])) {\n                    ip--; dictMatch--; mLength++;\n                }  \n                offset_2 = offset_1;\n                offset_1 = offset;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);\n            }\n        } else if (MEM_read32(match) != MEM_read32(ip)) {\n             \n            assert(stepSize >= 1);\n            ip += ((ip-anchor) >> kSearchStrength) + stepSize;\n            continue;\n        } else {\n             \n            U32 const offset = (U32)(ip-match);\n            mLength = ZSTD_count(ip+4, match+4, iend) + 4;\n            while (((ip>anchor) & (match>prefixStart))\n                 && (ip[-1] == match[-1])) { ip--; match--; mLength++; }  \n            offset_2 = offset_1;\n            offset_1 = offset;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);\n        }\n\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n            assert(base+current+2 > istart);   \n            hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;   \n            hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);\n\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?\n                        dictBase - dictIndexDelta + repIndex2 :\n                        base + repIndex2;\n                if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3  )\n                   && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;\n                    U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, 0, repLength2-MINMATCH);\n                    hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n            }\n        }\n    }\n\n     \n    rep[0] = offset_1 ? offset_1 : offsetSaved;\n    rep[1] = offset_2 ? offset_2 : offsetSaved;\n\n     \n    return (size_t)(iend - anchor);\n}\n\nsize_t ZSTD_compressBlock_fast_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    assert(ms->dictMatchState != NULL);\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 4);\n    case 5 :\n        return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 5);\n    case 6 :\n        return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 6);\n    case 7 :\n        return ZSTD_compressBlock_fast_dictMatchState_generic(ms, seqStore, rep, src, srcSize, 7);\n    }\n}\n\n\nstatic size_t ZSTD_compressBlock_fast_extDict_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize, U32 const mls)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32 const hlog = cParams->hashLog;\n     \n    U32 const stepSize = cParams->targetLength + !(cParams->targetLength);\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);\n    const U32   lowLimit = ZSTD_getLowestMatchIndex(ms, endIndex, cParams->windowLog);\n    const U32   dictStartIndex = lowLimit;\n    const BYTE* const dictStart = dictBase + dictStartIndex;\n    const U32   dictLimit = ms->window.dictLimit;\n    const U32   prefixStartIndex = dictLimit < lowLimit ? lowLimit : dictLimit;\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const dictEnd = dictBase + prefixStartIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    U32 offset_1=rep[0], offset_2=rep[1];\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_fast_extDict_generic (offset_1=%u)\", offset_1);\n\n     \n    if (prefixStartIndex == dictStartIndex)\n        return ZSTD_compressBlock_fast_generic(ms, seqStore, rep, src, srcSize, mls);\n\n     \n    while (ip < ilimit) {   \n        const size_t h = ZSTD_hashPtr(ip, hlog, mls);\n        const U32    matchIndex = hashTable[h];\n        const BYTE* const matchBase = matchIndex < prefixStartIndex ? dictBase : base;\n        const BYTE*  match = matchBase + matchIndex;\n        const U32    current = (U32)(ip-base);\n        const U32    repIndex = current + 1 - offset_1;\n        const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* const repMatch = repBase + repIndex;\n        hashTable[h] = current;    \n        DEBUGLOG(7, \"offset_1 = %u , current = %u\", offset_1, current);\n\n        if ( ( ((U32)((prefixStartIndex-1) - repIndex) >= 3)  \n             & (offset_1 < current+1 - dictStartIndex) )  \n           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;\n            size_t const rLength = ZSTD_count_2segments(ip+1 +4, repMatch +4, iend, repMatchEnd, prefixStart) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, 0, rLength-MINMATCH);\n            ip += rLength;\n            anchor = ip;\n        } else {\n            if ( (matchIndex < dictStartIndex) ||\n                 (MEM_read32(match) != MEM_read32(ip)) ) {\n                assert(stepSize >= 1);\n                ip += ((ip-anchor) >> kSearchStrength) + stepSize;\n                continue;\n            }\n            {   const BYTE* const matchEnd = matchIndex < prefixStartIndex ? dictEnd : iend;\n                const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;\n                U32 const offset = current - matchIndex;\n                size_t mLength = ZSTD_count_2segments(ip+4, match+4, iend, matchEnd, prefixStart) + 4;\n                while (((ip>anchor) & (match>lowMatchPtr)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }    \n                offset_2 = offset_1; offset_1 = offset;   \n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, offset + ZSTD_REP_MOVE, mLength-MINMATCH);\n                ip += mLength;\n                anchor = ip;\n        }   }\n\n        if (ip <= ilimit) {\n             \n            hashTable[ZSTD_hashPtr(base+current+2, hlog, mls)] = current+2;\n            hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* const repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;\n                if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3) & (offset_2 < current - dictStartIndex))   \n                   && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;\n                    { U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset; }   \n                    ZSTD_storeSeq(seqStore, 0  , anchor, iend, 0  , repLength2-MINMATCH);\n                    hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n    }   }   }\n\n     \n    rep[0] = offset_1;\n    rep[1] = offset_2;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_fast_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 4);\n    case 5 :\n        return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 5);\n    case 6 :\n        return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 6);\n    case 7 :\n        return ZSTD_compressBlock_fast_extDict_generic(ms, seqStore, rep, src, srcSize, 7);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}