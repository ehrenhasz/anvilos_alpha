{
  "module_name": "hist.c",
  "hash_id": "2e7a6424744d6b2076faf026909f397f98d7f6e4883536f3028afc3b6a75abf9",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/hist.c",
  "human_readable_source": " \n\n \n#include \"../common/mem.h\"              \n#include \"../common/debug.h\"            \n#include \"../common/error_private.h\"    \n#include \"hist.h\"\n\n\n \nunsigned HIST_isError(size_t code) { return ERR_isError(code); }\n\n \nunsigned HIST_count_simple(unsigned* count, unsigned* maxSymbolValuePtr,\n                           const void* src, size_t srcSize)\n{\n    const BYTE* ip = (const BYTE*)src;\n    const BYTE* const end = ip + srcSize;\n    unsigned maxSymbolValue = *maxSymbolValuePtr;\n    unsigned largestCount=0;\n\n    memset(count, 0, (maxSymbolValue+1) * sizeof(*count));\n    if (srcSize==0) { *maxSymbolValuePtr = 0; return 0; }\n\n    while (ip<end) {\n        assert(*ip <= maxSymbolValue);\n        count[*ip++]++;\n    }\n\n    while (!count[maxSymbolValue]) maxSymbolValue--;\n    *maxSymbolValuePtr = maxSymbolValue;\n\n    {   U32 s;\n        for (s=0; s<=maxSymbolValue; s++)\n            if (count[s] > largestCount) largestCount = count[s];\n    }\n\n    return largestCount;\n}\n\ntypedef enum { trustInput, checkMaxSymbolValue } HIST_checkInput_e;\n\n \nstatic size_t HIST_count_parallel_wksp(\n                                unsigned* count, unsigned* maxSymbolValuePtr,\n                                const void* source, size_t sourceSize,\n                                HIST_checkInput_e check,\n                                U32* const workSpace)\n{\n    const BYTE* ip = (const BYTE*)source;\n    const BYTE* const iend = ip+sourceSize;\n    unsigned maxSymbolValue = *maxSymbolValuePtr;\n    unsigned max=0;\n    U32* const Counting1 = workSpace;\n    U32* const Counting2 = Counting1 + 256;\n    U32* const Counting3 = Counting2 + 256;\n    U32* const Counting4 = Counting3 + 256;\n\n    memset(workSpace, 0, 4*256*sizeof(unsigned));\n\n     \n    if (!sourceSize) {\n        memset(count, 0, maxSymbolValue + 1);\n        *maxSymbolValuePtr = 0;\n        return 0;\n    }\n    if (!maxSymbolValue) maxSymbolValue = 255;             \n\n     \n    {   U32 cached = MEM_read32(ip); ip += 4;\n        while (ip < iend-15) {\n            U32 c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n            c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n            c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n            c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n        }\n        ip-=4;\n    }\n\n     \n    while (ip<iend) Counting1[*ip++]++;\n\n    if (check) {    \n        U32 s; for (s=255; s>maxSymbolValue; s--) {\n            Counting1[s] += Counting2[s] + Counting3[s] + Counting4[s];\n            if (Counting1[s]) return ERROR(maxSymbolValue_tooSmall);\n    }   }\n\n    {   U32 s;\n        if (maxSymbolValue > 255) maxSymbolValue = 255;\n        for (s=0; s<=maxSymbolValue; s++) {\n            count[s] = Counting1[s] + Counting2[s] + Counting3[s] + Counting4[s];\n            if (count[s] > max) max = count[s];\n    }   }\n\n    while (!count[maxSymbolValue]) maxSymbolValue--;\n    *maxSymbolValuePtr = maxSymbolValue;\n    return (size_t)max;\n}\n\n \nsize_t HIST_countFast_wksp(unsigned* count, unsigned* maxSymbolValuePtr,\n                          const void* source, size_t sourceSize,\n                          void* workSpace, size_t workSpaceSize)\n{\n    if (sourceSize < 1500)  \n        return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);\n    if ((size_t)workSpace & 3) return ERROR(GENERIC);   \n    if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);\n    return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);\n}\n\n \nsize_t HIST_countFast(unsigned* count, unsigned* maxSymbolValuePtr,\n                     const void* source, size_t sourceSize)\n{\n    unsigned tmpCounters[HIST_WKSP_SIZE_U32];\n    return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, tmpCounters, sizeof(tmpCounters));\n}\n\n \nsize_t HIST_count_wksp(unsigned* count, unsigned* maxSymbolValuePtr,\n                       const void* source, size_t sourceSize,\n                       void* workSpace, size_t workSpaceSize)\n{\n    if ((size_t)workSpace & 3) return ERROR(GENERIC);   \n    if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);\n    if (*maxSymbolValuePtr < 255)\n        return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, checkMaxSymbolValue, (U32*)workSpace);\n    *maxSymbolValuePtr = 255;\n    return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);\n}\n\nsize_t HIST_count(unsigned* count, unsigned* maxSymbolValuePtr,\n                 const void* src, size_t srcSize)\n{\n    unsigned tmpCounters[HIST_WKSP_SIZE_U32];\n    return HIST_count_wksp(count, maxSymbolValuePtr, src, srcSize, tmpCounters, sizeof(tmpCounters));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}