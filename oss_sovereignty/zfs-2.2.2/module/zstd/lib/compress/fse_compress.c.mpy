{
  "module_name": "fse_compress.c",
  "hash_id": "fde0cc72c33970e66d6177546b26b29584f2192e5c8e40123d66f3404cfba11e",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/compress/fse_compress.c",
  "human_readable_source": " \n\n \n#include <stdlib.h>      \n#include <string.h>      \n#include \"../common/compiler.h\"\n#include \"../common/mem.h\"         \n#include \"../common/debug.h\"       \n#include \"hist.h\"        \n#include \"../common/bitstream.h\"\n#define FSE_STATIC_LINKING_ONLY\n#include \"../common/fse.h\"\n#include \"../common/error_private.h\"\n\n\n \n#define FSE_isError ERR_isError\n\n\n \n \n\n \n#ifndef FSE_FUNCTION_EXTENSION\n#  error \"FSE_FUNCTION_EXTENSION must be defined\"\n#endif\n#ifndef FSE_FUNCTION_TYPE\n#  error \"FSE_FUNCTION_TYPE must be defined\"\n#endif\n\n \n#define FSE_CAT(X,Y) X##Y\n#define FSE_FUNCTION_NAME(X,Y) FSE_CAT(X,Y)\n#define FSE_TYPE_NAME(X,Y) FSE_CAT(X,Y)\n\n\n \n\n \nsize_t FSE_buildCTable_wksp(FSE_CTable* ct,\n                      const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,\n                            void* workSpace, size_t wkspSize)\n{\n    U32 const tableSize = 1 << tableLog;\n    U32 const tableMask = tableSize - 1;\n    void* const ptr = ct;\n    U16* const tableU16 = ( (U16*) ptr) + 2;\n    void* const FSCT = ((U32*)ptr) + 1   + (tableLog ? tableSize>>1 : 1) ;\n    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);\n    U32 const step = FSE_TABLESTEP(tableSize);\n    U32 cumul[FSE_MAX_SYMBOL_VALUE+2];\n\n    FSE_FUNCTION_TYPE* const tableSymbol = (FSE_FUNCTION_TYPE*)workSpace;\n    U32 highThreshold = tableSize-1;\n\n     \n    if (((size_t)1 << tableLog) * sizeof(FSE_FUNCTION_TYPE) > wkspSize) return ERROR(tableLog_tooLarge);\n    tableU16[-2] = (U16) tableLog;\n    tableU16[-1] = (U16) maxSymbolValue;\n    assert(tableLog < 16);    \n\n     \n     #endif\n\n     \n    {   U32 u;\n        cumul[0] = 0;\n        for (u=1; u <= maxSymbolValue+1; u++) {\n            if (normalizedCounter[u-1]==-1) {   \n                cumul[u] = cumul[u-1] + 1;\n                tableSymbol[highThreshold--] = (FSE_FUNCTION_TYPE)(u-1);\n            } else {\n                cumul[u] = cumul[u-1] + normalizedCounter[u-1];\n        }   }\n        cumul[maxSymbolValue+1] = tableSize+1;\n    }\n\n     \n    {   U32 position = 0;\n        U32 symbol;\n        for (symbol=0; symbol<=maxSymbolValue; symbol++) {\n            int nbOccurrences;\n            int const freq = normalizedCounter[symbol];\n            for (nbOccurrences=0; nbOccurrences<freq; nbOccurrences++) {\n                tableSymbol[position] = (FSE_FUNCTION_TYPE)symbol;\n                position = (position + step) & tableMask;\n                while (position > highThreshold)\n                    position = (position + step) & tableMask;    \n        }   }\n\n        assert(position==0);   \n    }\n\n     \n    {   U32 u; for (u=0; u<tableSize; u++) {\n        FSE_FUNCTION_TYPE s = tableSymbol[u];    \n        tableU16[cumul[s]++] = (U16) (tableSize+u);    \n    }   }\n\n     \n    {   unsigned total = 0;\n        unsigned s;\n        for (s=0; s<=maxSymbolValue; s++) {\n            switch (normalizedCounter[s])\n            {\n            case  0:\n                 \n                symbolTT[s].deltaNbBits = ((tableLog+1) << 16) - (1<<tableLog);\n                break;\n\n            case -1:\n            case  1:\n                symbolTT[s].deltaNbBits = (tableLog << 16) - (1<<tableLog);\n                symbolTT[s].deltaFindState = total - 1;\n                total ++;\n                break;\n            default :\n                {\n                    U32 const maxBitsOut = tableLog - BIT_highbit32 (normalizedCounter[s]-1);\n                    U32 const minStatePlus = normalizedCounter[s] << maxBitsOut;\n                    symbolTT[s].deltaNbBits = (maxBitsOut << 16) - minStatePlus;\n                    symbolTT[s].deltaFindState = total - normalizedCounter[s];\n                    total +=  normalizedCounter[s];\n    }   }   }   }\n\n#if 0   \n    DEBUGLOG(5, \"\\n --- table statistics : \");\n    {   U32 symbol;\n        for (symbol=0; symbol<=maxSymbolValue; symbol++) {\n            DEBUGLOG(5, \"%3u: w=%3i,   maxBits=%u, fracBits=%.2f\",\n                symbol, normalizedCounter[symbol],\n                FSE_getMaxNbBits(symbolTT, symbol),\n                (double)FSE_bitCost(symbolTT, tableLog, symbol, 8) / 256);\n        }\n    }\n#endif\n\n    return 0;\n}\n\n\nsize_t FSE_buildCTable(FSE_CTable* ct, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)\n{\n    FSE_FUNCTION_TYPE tableSymbol[FSE_MAX_TABLESIZE];    \n    return FSE_buildCTable_wksp(ct, normalizedCounter, maxSymbolValue, tableLog, tableSymbol, sizeof(tableSymbol));\n}\n\n\n\n#ifndef FSE_COMMONDEFS_ONLY\n\n\n \nsize_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog)\n{\n    size_t const maxHeaderSize = (((maxSymbolValue+1) * tableLog) >> 3) + 3;\n    return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;   \n}\n\nstatic size_t\nFSE_writeNCount_generic (void* header, size_t headerBufferSize,\n                   const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,\n                         unsigned writeIsSafe)\n{\n    BYTE* const ostart = (BYTE*) header;\n    BYTE* out = ostart;\n    BYTE* const oend = ostart + headerBufferSize;\n    int nbBits;\n    const int tableSize = 1 << tableLog;\n    int remaining;\n    int threshold;\n    U32 bitStream = 0;\n    int bitCount = 0;\n    unsigned symbol = 0;\n    unsigned const alphabetSize = maxSymbolValue + 1;\n    int previousIs0 = 0;\n\n     \n    bitStream += (tableLog-FSE_MIN_TABLELOG) << bitCount;\n    bitCount  += 4;\n\n     \n    remaining = tableSize+1;    \n    threshold = tableSize;\n    nbBits = tableLog+1;\n\n    while ((symbol < alphabetSize) && (remaining>1)) {   \n        if (previousIs0) {\n            unsigned start = symbol;\n            while ((symbol < alphabetSize) && !normalizedCounter[symbol]) symbol++;\n            if (symbol == alphabetSize) break;    \n            while (symbol >= start+24) {\n                start+=24;\n                bitStream += 0xFFFFU << bitCount;\n                if ((!writeIsSafe) && (out > oend-2))\n                    return ERROR(dstSize_tooSmall);    \n                out[0] = (BYTE) bitStream;\n                out[1] = (BYTE)(bitStream>>8);\n                out+=2;\n                bitStream>>=16;\n            }\n            while (symbol >= start+3) {\n                start+=3;\n                bitStream += 3 << bitCount;\n                bitCount += 2;\n            }\n            bitStream += (symbol-start) << bitCount;\n            bitCount += 2;\n            if (bitCount>16) {\n                if ((!writeIsSafe) && (out > oend - 2))\n                    return ERROR(dstSize_tooSmall);    \n                out[0] = (BYTE)bitStream;\n                out[1] = (BYTE)(bitStream>>8);\n                out += 2;\n                bitStream >>= 16;\n                bitCount -= 16;\n        }   }\n        {   int count = normalizedCounter[symbol++];\n            int const max = (2*threshold-1) - remaining;\n            remaining -= count < 0 ? -count : count;\n            count++;    \n            if (count>=threshold)\n                count += max;    \n            bitStream += count << bitCount;\n            bitCount  += nbBits;\n            bitCount  -= (count<max);\n            previousIs0  = (count==1);\n            if (remaining<1) return ERROR(GENERIC);\n            while (remaining<threshold) { nbBits--; threshold>>=1; }\n        }\n        if (bitCount>16) {\n            if ((!writeIsSafe) && (out > oend - 2))\n                return ERROR(dstSize_tooSmall);    \n            out[0] = (BYTE)bitStream;\n            out[1] = (BYTE)(bitStream>>8);\n            out += 2;\n            bitStream >>= 16;\n            bitCount -= 16;\n    }   }\n\n    if (remaining != 1)\n        return ERROR(GENERIC);   \n    assert(symbol <= alphabetSize);\n\n     \n    if ((!writeIsSafe) && (out > oend - 2))\n        return ERROR(dstSize_tooSmall);    \n    out[0] = (BYTE)bitStream;\n    out[1] = (BYTE)(bitStream>>8);\n    out+= (bitCount+7) /8;\n\n    return (out-ostart);\n}\n\n\nsize_t FSE_writeNCount (void* buffer, size_t bufferSize,\n                  const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)\n{\n    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);    \n    if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);    \n\n    if (bufferSize < FSE_NCountWriteBound(maxSymbolValue, tableLog))\n        return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);\n\n    return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 1  );\n}\n\n\n \n\nFSE_CTable* FSE_createCTable (unsigned maxSymbolValue, unsigned tableLog)\n{\n    size_t size __attribute__ ((unused));\n    if (tableLog > FSE_TABLELOG_ABSOLUTE_MAX) tableLog = FSE_TABLELOG_ABSOLUTE_MAX;\n    size = FSE_CTABLE_SIZE_U32 (tableLog, maxSymbolValue) * sizeof(U32);\n    return (FSE_CTable*)malloc(size);\n}\n\nvoid FSE_freeCTable (FSE_CTable* ct) { free(ct); }\n\n \nstatic unsigned FSE_minTableLog(size_t srcSize, unsigned maxSymbolValue)\n{\n    U32 minBitsSrc = BIT_highbit32((U32)(srcSize)) + 1;\n    U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;\n    U32 minBits = minBitsSrc < minBitsSymbols ? minBitsSrc : minBitsSymbols;\n    assert(srcSize > 1);  \n    return minBits;\n}\n\nunsigned FSE_optimalTableLog_internal(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, unsigned minus)\n{\n    U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;\n    U32 tableLog = maxTableLog;\n    U32 minBits = FSE_minTableLog(srcSize, maxSymbolValue);\n    assert(srcSize > 1);  \n    if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;\n    if (maxBitsSrc < tableLog) tableLog = maxBitsSrc;    \n    if (minBits > tableLog) tableLog = minBits;    \n    if (tableLog < FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;\n    if (tableLog > FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;\n    return tableLog;\n}\n\nunsigned FSE_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)\n{\n    return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 2);\n}\n\n\n \n\nstatic size_t FSE_normalizeM2(short* norm, U32 tableLog, const unsigned* count, size_t total, U32 maxSymbolValue)\n{\n    short const NOT_YET_ASSIGNED = -2;\n    U32 s;\n    U32 distributed = 0;\n    U32 ToDistribute;\n\n     \n    U32 const lowThreshold = (U32)(total >> tableLog);\n    U32 lowOne = (U32)((total * 3) >> (tableLog + 1));\n\n    for (s=0; s<=maxSymbolValue; s++) {\n        if (count[s] == 0) {\n            norm[s]=0;\n            continue;\n        }\n        if (count[s] <= lowThreshold) {\n            norm[s] = -1;\n            distributed++;\n            total -= count[s];\n            continue;\n        }\n        if (count[s] <= lowOne) {\n            norm[s] = 1;\n            distributed++;\n            total -= count[s];\n            continue;\n        }\n\n        norm[s]=NOT_YET_ASSIGNED;\n    }\n    ToDistribute = (1 << tableLog) - distributed;\n\n    if (ToDistribute == 0)\n        return 0;\n\n    if ((total / ToDistribute) > lowOne) {\n         \n        lowOne = (U32)((total * 3) / (ToDistribute * 2));\n        for (s=0; s<=maxSymbolValue; s++) {\n            if ((norm[s] == NOT_YET_ASSIGNED) && (count[s] <= lowOne)) {\n                norm[s] = 1;\n                distributed++;\n                total -= count[s];\n                continue;\n        }   }\n        ToDistribute = (1 << tableLog) - distributed;\n    }\n\n    if (distributed == maxSymbolValue+1) {\n         \n        U32 maxV = 0, maxC = 0;\n        for (s=0; s<=maxSymbolValue; s++)\n            if (count[s] > maxC) { maxV=s; maxC=count[s]; }\n        norm[maxV] += (short)ToDistribute;\n        return 0;\n    }\n\n    if (total == 0) {\n         \n        for (s=0; ToDistribute > 0; s = (s+1)%(maxSymbolValue+1))\n            if (norm[s] > 0) { ToDistribute--; norm[s]++; }\n        return 0;\n    }\n\n    {   U64 const vStepLog = 62 - tableLog;\n        U64 const mid = (1ULL << (vStepLog-1)) - 1;\n        U64 const rStep = ((((U64)1<<vStepLog) * ToDistribute) + mid) / total;    \n        U64 tmpTotal = mid;\n        for (s=0; s<=maxSymbolValue; s++) {\n            if (norm[s]==NOT_YET_ASSIGNED) {\n                U64 const end = tmpTotal + (count[s] * rStep);\n                U32 const sStart = (U32)(tmpTotal >> vStepLog);\n                U32 const sEnd = (U32)(end >> vStepLog);\n                U32 const weight = sEnd - sStart;\n                if (weight < 1)\n                    return ERROR(GENERIC);\n                norm[s] = (short)weight;\n                tmpTotal = end;\n    }   }   }\n\n    return 0;\n}\n\n\nsize_t FSE_normalizeCount (short* normalizedCounter, unsigned tableLog,\n                           const unsigned* count, size_t total,\n                           unsigned maxSymbolValue)\n{\n     \n    if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;\n    if (tableLog < FSE_MIN_TABLELOG) return ERROR(GENERIC);    \n    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);    \n    if (tableLog < FSE_minTableLog(total, maxSymbolValue)) return ERROR(GENERIC);    \n\n    {   static U32 const rtbTable[] = {     0, 473195, 504333, 520860, 550000, 700000, 750000, 830000 };\n        U64 const scale = 62 - tableLog;\n        U64 const step = ((U64)1<<62) / total;    \n        U64 const vStep = 1ULL<<(scale-20);\n        int stillToDistribute = 1<<tableLog;\n        unsigned s;\n        unsigned largest=0;\n        short largestP=0;\n        U32 lowThreshold = (U32)(total >> tableLog);\n\n        for (s=0; s<=maxSymbolValue; s++) {\n            if (count[s] == total) return 0;    \n            if (count[s] == 0) { normalizedCounter[s]=0; continue; }\n            if (count[s] <= lowThreshold) {\n                normalizedCounter[s] = -1;\n                stillToDistribute--;\n            } else {\n                short proba = (short)((count[s]*step) >> scale);\n                if (proba<8) {\n                    U64 restToBeat = vStep * rtbTable[proba];\n                    proba += (count[s]*step) - ((U64)proba<<scale) > restToBeat;\n                }\n                if (proba > largestP) { largestP=proba; largest=s; }\n                normalizedCounter[s] = proba;\n                stillToDistribute -= proba;\n        }   }\n        if (-stillToDistribute >= (normalizedCounter[largest] >> 1)) {\n             \n            size_t const errorCode = FSE_normalizeM2(normalizedCounter, tableLog, count, total, maxSymbolValue);\n            if (FSE_isError(errorCode)) return errorCode;\n        }\n        else normalizedCounter[largest] += (short)stillToDistribute;\n    }\n\n#if 0\n    {    \n        U32 s;\n        U32 nTotal = 0;\n        for (s=0; s<=maxSymbolValue; s++)\n            RAWLOG(2, \"%3i: %4i \\n\", s, normalizedCounter[s]);\n        for (s=0; s<=maxSymbolValue; s++)\n            nTotal += abs(normalizedCounter[s]);\n        if (nTotal != (1U<<tableLog))\n            RAWLOG(2, \"Warning !!! Total == %u != %u !!!\", nTotal, 1U<<tableLog);\n        getchar();\n    }\n#endif\n\n    return tableLog;\n}\n\n\n \nsize_t FSE_buildCTable_raw (FSE_CTable* ct, unsigned nbBits)\n{\n    const unsigned tableSize = 1 << nbBits;\n    const unsigned tableMask = tableSize - 1;\n    const unsigned maxSymbolValue = tableMask;\n    void* const ptr = ct;\n    U16* const tableU16 = ( (U16*) ptr) + 2;\n    void* const FSCT = ((U32*)ptr) + 1   + (tableSize>>1);    \n    FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);\n    unsigned s;\n\n     \n    if (nbBits < 1) return ERROR(GENERIC);              \n\n     \n    tableU16[-2] = (U16) nbBits;\n    tableU16[-1] = (U16) maxSymbolValue;\n\n     \n    for (s=0; s<tableSize; s++)\n        tableU16[s] = (U16)(tableSize + s);\n\n     \n    {   const U32 deltaNbBits = (nbBits << 16) - (1 << nbBits);\n        for (s=0; s<=maxSymbolValue; s++) {\n            symbolTT[s].deltaNbBits = deltaNbBits;\n            symbolTT[s].deltaFindState = s-1;\n    }   }\n\n    return 0;\n}\n\n \nsize_t FSE_buildCTable_rle (FSE_CTable* ct, BYTE symbolValue)\n{\n    void* ptr = ct;\n    U16* tableU16 = ( (U16*) ptr) + 2;\n    void* FSCTptr = (U32*)ptr + 2;\n    FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) FSCTptr;\n\n     \n    tableU16[-2] = (U16) 0;\n    tableU16[-1] = (U16) symbolValue;\n\n     \n    tableU16[0] = 0;\n    tableU16[1] = 0;    \n\n     \n    symbolTT[symbolValue].deltaNbBits = 0;\n    symbolTT[symbolValue].deltaFindState = 0;\n\n    return 0;\n}\n\n\nstatic size_t FSE_compress_usingCTable_generic (void* dst, size_t dstSize,\n                           const void* src, size_t srcSize,\n                           const FSE_CTable* ct, const unsigned fast)\n{\n    const BYTE* const istart = (const BYTE*) src;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* ip=iend;\n\n    BIT_CStream_t bitC;\n    FSE_CState_t CState1, CState2;\n\n     \n    if (srcSize <= 2) return 0;\n    { size_t const initError = BIT_initCStream(&bitC, dst, dstSize);\n      if (FSE_isError(initError)) return 0;   }\n\n#define FSE_FLUSHBITS(s)  (fast ? BIT_flushBitsFast(s) : BIT_flushBits(s))\n\n    if (srcSize & 1) {\n        FSE_initCState2(&CState1, ct, *--ip);\n        FSE_initCState2(&CState2, ct, *--ip);\n        FSE_encodeSymbol(&bitC, &CState1, *--ip);\n        FSE_FLUSHBITS(&bitC);\n    } else {\n        FSE_initCState2(&CState2, ct, *--ip);\n        FSE_initCState2(&CState1, ct, *--ip);\n    }\n\n     \n    srcSize -= 2;\n    if ((sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 ) && (srcSize & 2)) {   \n        FSE_encodeSymbol(&bitC, &CState2, *--ip);\n        FSE_encodeSymbol(&bitC, &CState1, *--ip);\n        FSE_FLUSHBITS(&bitC);\n    }\n\n     \n    while ( ip>istart ) {\n\n        FSE_encodeSymbol(&bitC, &CState2, *--ip);\n\n        if (sizeof(bitC.bitContainer)*8 < FSE_MAX_TABLELOG*2+7 )    \n            FSE_FLUSHBITS(&bitC);\n\n        FSE_encodeSymbol(&bitC, &CState1, *--ip);\n\n        if (sizeof(bitC.bitContainer)*8 > FSE_MAX_TABLELOG*4+7 ) {   \n            FSE_encodeSymbol(&bitC, &CState2, *--ip);\n            FSE_encodeSymbol(&bitC, &CState1, *--ip);\n        }\n\n        FSE_FLUSHBITS(&bitC);\n    }\n\n    FSE_flushCState(&bitC, &CState2);\n    FSE_flushCState(&bitC, &CState1);\n    return BIT_closeCStream(&bitC);\n}\n\nsize_t FSE_compress_usingCTable (void* dst, size_t dstSize,\n                           const void* src, size_t srcSize,\n                           const FSE_CTable* ct)\n{\n    unsigned const fast = (dstSize >= FSE_BLOCKBOUND(srcSize));\n\n    if (fast)\n        return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 1);\n    else\n        return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 0);\n}\n\n\nsize_t FSE_compressBound(size_t size) { return FSE_COMPRESSBOUND(size); }\n\n \nsize_t FSE_compress_wksp (void* dst, size_t dstSize, const void* src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog, void* workSpace, size_t wkspSize)\n{\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* op = ostart;\n    BYTE* const oend = ostart + dstSize;\n\n    unsigned count[FSE_MAX_SYMBOL_VALUE+1];\n    S16   norm[FSE_MAX_SYMBOL_VALUE+1];\n    FSE_CTable* CTable = (FSE_CTable*)workSpace;\n    size_t const CTableSize = FSE_CTABLE_SIZE_U32(tableLog, maxSymbolValue);\n    void* scratchBuffer = (void*)(CTable + CTableSize);\n    size_t const scratchBufferSize = wkspSize - (CTableSize * sizeof(FSE_CTable));\n\n     \n    if (wkspSize < FSE_WKSP_SIZE_U32(tableLog, maxSymbolValue)) return ERROR(tableLog_tooLarge);\n    if (srcSize <= 1) return 0;   \n    if (!maxSymbolValue) maxSymbolValue = FSE_MAX_SYMBOL_VALUE;\n    if (!tableLog) tableLog = FSE_DEFAULT_TABLELOG;\n\n     \n    {   CHECK_V_F(maxCount, HIST_count_wksp(count, &maxSymbolValue, src, srcSize, scratchBuffer, scratchBufferSize) );\n        if (maxCount == srcSize) return 1;    \n        if (maxCount == 1) return 0;          \n        if (maxCount < (srcSize >> 7)) return 0;    \n    }\n\n    tableLog = FSE_optimalTableLog(tableLog, srcSize, maxSymbolValue);\n    CHECK_F( FSE_normalizeCount(norm, tableLog, count, srcSize, maxSymbolValue) );\n\n     \n    {   CHECK_V_F(nc_err, FSE_writeNCount(op, oend-op, norm, maxSymbolValue, tableLog) );\n        op += nc_err;\n    }\n\n     \n    CHECK_F( FSE_buildCTable_wksp(CTable, norm, maxSymbolValue, tableLog, scratchBuffer, scratchBufferSize) );\n    {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, oend - op, src, srcSize, CTable) );\n        if (cSize == 0) return 0;    \n        op += cSize;\n    }\n\n     \n    if ( (size_t)(op-ostart) >= srcSize-1 ) return 0;\n\n    return op-ostart;\n}\n\ntypedef struct {\n    FSE_CTable CTable_max[FSE_CTABLE_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)];\n    BYTE scratchBuffer[1 << FSE_MAX_TABLELOG];\n} fseWkspMax_t;\n\nsize_t FSE_compress2 (void* dst, size_t dstCapacity, const void* src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog)\n{\n    fseWkspMax_t scratchBuffer;\n    DEBUG_STATIC_ASSERT(sizeof(scratchBuffer) >= FSE_WKSP_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE));    \n    if (tableLog > FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);\n    return FSE_compress_wksp(dst, dstCapacity, src, srcSize, maxSymbolValue, tableLog, &scratchBuffer, sizeof(scratchBuffer));\n}\n\nsize_t FSE_compress (void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    return FSE_compress2(dst, dstCapacity, src, srcSize, FSE_MAX_SYMBOL_VALUE, FSE_DEFAULT_TABLELOG);\n}\n\n\n#endif    \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}