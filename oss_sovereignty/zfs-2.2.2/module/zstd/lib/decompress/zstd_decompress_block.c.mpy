{
  "module_name": "zstd_decompress_block.c",
  "hash_id": "3efd785b27b24b0be81e291f344d2ca78e4e0d2b8b28abf7daee6ade943d074c",
  "original_prompt": "Ingested from zfs-2.2.2/module/zstd/lib/decompress/zstd_decompress_block.c",
  "human_readable_source": " \n\n \n\n \n#include <string.h>       \n#include \"../common/compiler.h\"     \n#include \"../common/cpu.h\"          \n#include \"../common/mem.h\"          \n#define FSE_STATIC_LINKING_ONLY\n#include \"../common/fse.h\"\n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include \"../common/zstd_internal.h\"\n#include \"zstd_decompress_internal.h\"    \n#include \"zstd_ddict.h\"   \n#include \"zstd_decompress_block.h\"\n\n \n\n \n#if defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n#error \"Cannot force the use of the short and the long ZSTD_decompressSequences variants!\"\n#endif\n\n\n \nstatic void ZSTD_copy4(void* dst, const void* src) { memcpy(dst, src, 4); }\n\n\n \n\n \nsize_t ZSTD_getcBlockSize(const void* src, size_t srcSize,\n                          blockProperties_t* bpPtr)\n{\n    RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, \"\");\n\n    {   U32 const cBlockHeader = MEM_readLE24(src);\n        U32 const cSize = cBlockHeader >> 3;\n        bpPtr->lastBlock = cBlockHeader & 1;\n        bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);\n        bpPtr->origSize = cSize;    \n        if (bpPtr->blockType == bt_rle) return 1;\n        RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, \"\");\n        return cSize;\n    }\n}\n\n\n \nsize_t ZSTD_decodeLiteralsBlock(ZSTD_DCtx* dctx,\n                          const void* src, size_t srcSize);\n \nsize_t ZSTD_decodeLiteralsBlock(ZSTD_DCtx* dctx,\n                          const void* src, size_t srcSize)    \n{\n    DEBUGLOG(5, \"ZSTD_decodeLiteralsBlock\");\n    RETURN_ERROR_IF(srcSize < MIN_CBLOCK_SIZE, corruption_detected, \"\");\n\n    {   const BYTE* const istart = (const BYTE*) src;\n        symbolEncodingType_e const litEncType = (symbolEncodingType_e)(istart[0] & 3);\n\n        switch(litEncType)\n        {\n        case set_repeat:\n            DEBUGLOG(5, \"set_repeat flag : re-using stats from previous compressed literals block\");\n            RETURN_ERROR_IF(dctx->litEntropy==0, dictionary_corrupted, \"\");\n             \n\n        case set_compressed:\n            RETURN_ERROR_IF(srcSize < 5, corruption_detected, \"srcSize >= MIN_CBLOCK_SIZE == 3; here we need up to 5 for case 3\");\n            {   size_t lhSize, litSize, litCSize;\n                U32 singleStream=0;\n                U32 const lhlCode = (istart[0] >> 2) & 3;\n                U32 const lhc = MEM_readLE32(istart);\n                size_t hufSuccess;\n                switch(lhlCode)\n                {\n                case 0: case 1: default:    \n                     \n                    singleStream = !lhlCode;\n                    lhSize = 3;\n                    litSize  = (lhc >> 4) & 0x3FF;\n                    litCSize = (lhc >> 14) & 0x3FF;\n                    break;\n                case 2:\n                     \n                    lhSize = 4;\n                    litSize  = (lhc >> 4) & 0x3FFF;\n                    litCSize = lhc >> 18;\n                    break;\n                case 3:\n                     \n                    lhSize = 5;\n                    litSize  = (lhc >> 4) & 0x3FFFF;\n                    litCSize = (lhc >> 22) + ((size_t)istart[4] << 10);\n                    break;\n                }\n                RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, \"\");\n                RETURN_ERROR_IF(litCSize + lhSize > srcSize, corruption_detected, \"\");\n\n                 \n                if (dctx->ddictIsCold && (litSize > 768  )) {\n                    PREFETCH_AREA(dctx->HUFptr, sizeof(dctx->entropy.hufTable));\n                }\n\n                if (litEncType==set_repeat) {\n                    if (singleStream) {\n                        hufSuccess = HUF_decompress1X_usingDTable_bmi2(\n                            dctx->litBuffer, litSize, istart+lhSize, litCSize,\n                            dctx->HUFptr, dctx->bmi2);\n                    } else {\n                        hufSuccess = HUF_decompress4X_usingDTable_bmi2(\n                            dctx->litBuffer, litSize, istart+lhSize, litCSize,\n                            dctx->HUFptr, dctx->bmi2);\n                    }\n                } else {\n                    if (singleStream) {\n#if defined(HUF_FORCE_DECOMPRESS_X2)\n                        hufSuccess = HUF_decompress1X_DCtx_wksp(\n                            dctx->entropy.hufTable, dctx->litBuffer, litSize,\n                            istart+lhSize, litCSize, dctx->workspace,\n                            sizeof(dctx->workspace));\n#else\n                        hufSuccess = HUF_decompress1X1_DCtx_wksp_bmi2(\n                            dctx->entropy.hufTable, dctx->litBuffer, litSize,\n                            istart+lhSize, litCSize, dctx->workspace,\n                            sizeof(dctx->workspace), dctx->bmi2);\n#endif\n                    } else {\n                        hufSuccess = HUF_decompress4X_hufOnly_wksp_bmi2(\n                            dctx->entropy.hufTable, dctx->litBuffer, litSize,\n                            istart+lhSize, litCSize, dctx->workspace,\n                            sizeof(dctx->workspace), dctx->bmi2);\n                    }\n                }\n\n                RETURN_ERROR_IF(HUF_isError(hufSuccess), corruption_detected, \"\");\n\n                dctx->litPtr = dctx->litBuffer;\n                dctx->litSize = litSize;\n                dctx->litEntropy = 1;\n                if (litEncType==set_compressed) dctx->HUFptr = dctx->entropy.hufTable;\n                memset(dctx->litBuffer + dctx->litSize, 0, WILDCOPY_OVERLENGTH);\n                return litCSize + lhSize;\n            }\n\n        case set_basic:\n            {   size_t litSize, lhSize;\n                U32 const lhlCode = ((istart[0]) >> 2) & 3;\n                switch(lhlCode)\n                {\n                case 0: case 2: default:    \n                    lhSize = 1;\n                    litSize = istart[0] >> 3;\n                    break;\n                case 1:\n                    lhSize = 2;\n                    litSize = MEM_readLE16(istart) >> 4;\n                    break;\n                case 3:\n                    lhSize = 3;\n                    litSize = MEM_readLE24(istart) >> 4;\n                    break;\n                }\n\n                if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {   \n                    RETURN_ERROR_IF(litSize+lhSize > srcSize, corruption_detected, \"\");\n                    memcpy(dctx->litBuffer, istart+lhSize, litSize);\n                    dctx->litPtr = dctx->litBuffer;\n                    dctx->litSize = litSize;\n                    memset(dctx->litBuffer + dctx->litSize, 0, WILDCOPY_OVERLENGTH);\n                    return lhSize+litSize;\n                }\n                 \n                dctx->litPtr = istart+lhSize;\n                dctx->litSize = litSize;\n                return lhSize+litSize;\n            }\n\n        case set_rle:\n            {   U32 const lhlCode = ((istart[0]) >> 2) & 3;\n                size_t litSize, lhSize;\n                switch(lhlCode)\n                {\n                case 0: case 2: default:    \n                    lhSize = 1;\n                    litSize = istart[0] >> 3;\n                    break;\n                case 1:\n                    lhSize = 2;\n                    litSize = MEM_readLE16(istart) >> 4;\n                    break;\n                case 3:\n                    lhSize = 3;\n                    litSize = MEM_readLE24(istart) >> 4;\n                    RETURN_ERROR_IF(srcSize<4, corruption_detected, \"srcSize >= MIN_CBLOCK_SIZE == 3; here we need lhSize+1 = 4\");\n                    break;\n                }\n                RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, \"\");\n                memset(dctx->litBuffer, istart[lhSize], litSize + WILDCOPY_OVERLENGTH);\n                dctx->litPtr = dctx->litBuffer;\n                dctx->litSize = litSize;\n                return lhSize+1;\n            }\n        default:\n            RETURN_ERROR(corruption_detected, \"impossible\");\n        }\n    }\n}\n\n \n\n \nstatic const ZSTD_seqSymbol LL_defaultDTable[(1<<LL_DEFAULTNORMLOG)+1] = {\n     {  1,  1,  1, LL_DEFAULTNORMLOG},   \n      \n     {  0,  0,  4,    0},  { 16,  0,  4,    0},\n     { 32,  0,  5,    1},  {  0,  0,  5,    3},\n     {  0,  0,  5,    4},  {  0,  0,  5,    6},\n     {  0,  0,  5,    7},  {  0,  0,  5,    9},\n     {  0,  0,  5,   10},  {  0,  0,  5,   12},\n     {  0,  0,  6,   14},  {  0,  1,  5,   16},\n     {  0,  1,  5,   20},  {  0,  1,  5,   22},\n     {  0,  2,  5,   28},  {  0,  3,  5,   32},\n     {  0,  4,  5,   48},  { 32,  6,  5,   64},\n     {  0,  7,  5,  128},  {  0,  8,  6,  256},\n     {  0, 10,  6, 1024},  {  0, 12,  6, 4096},\n     { 32,  0,  4,    0},  {  0,  0,  4,    1},\n     {  0,  0,  5,    2},  { 32,  0,  5,    4},\n     {  0,  0,  5,    5},  { 32,  0,  5,    7},\n     {  0,  0,  5,    8},  { 32,  0,  5,   10},\n     {  0,  0,  5,   11},  {  0,  0,  6,   13},\n     { 32,  1,  5,   16},  {  0,  1,  5,   18},\n     { 32,  1,  5,   22},  {  0,  2,  5,   24},\n     { 32,  3,  5,   32},  {  0,  3,  5,   40},\n     {  0,  6,  4,   64},  { 16,  6,  4,   64},\n     { 32,  7,  5,  128},  {  0,  9,  6,  512},\n     {  0, 11,  6, 2048},  { 48,  0,  4,    0},\n     { 16,  0,  4,    1},  { 32,  0,  5,    2},\n     { 32,  0,  5,    3},  { 32,  0,  5,    5},\n     { 32,  0,  5,    6},  { 32,  0,  5,    8},\n     { 32,  0,  5,    9},  { 32,  0,  5,   11},\n     { 32,  0,  5,   12},  {  0,  0,  6,   15},\n     { 32,  1,  5,   18},  { 32,  1,  5,   20},\n     { 32,  2,  5,   24},  { 32,  2,  5,   28},\n     { 32,  3,  5,   40},  { 32,  4,  5,   48},\n     {  0, 16,  6,65536},  {  0, 15,  6,32768},\n     {  0, 14,  6,16384},  {  0, 13,  6, 8192},\n};    \n\n \nstatic const ZSTD_seqSymbol OF_defaultDTable[(1<<OF_DEFAULTNORMLOG)+1] = {\n    {  1,  1,  1, OF_DEFAULTNORMLOG},   \n     \n    {  0,  0,  5,    0},     {  0,  6,  4,   61},\n    {  0,  9,  5,  509},     {  0, 15,  5,32765},\n    {  0, 21,  5,2097149},   {  0,  3,  5,    5},\n    {  0,  7,  4,  125},     {  0, 12,  5, 4093},\n    {  0, 18,  5,262141},    {  0, 23,  5,8388605},\n    {  0,  5,  5,   29},     {  0,  8,  4,  253},\n    {  0, 14,  5,16381},     {  0, 20,  5,1048573},\n    {  0,  2,  5,    1},     { 16,  7,  4,  125},\n    {  0, 11,  5, 2045},     {  0, 17,  5,131069},\n    {  0, 22,  5,4194301},   {  0,  4,  5,   13},\n    { 16,  8,  4,  253},     {  0, 13,  5, 8189},\n    {  0, 19,  5,524285},    {  0,  1,  5,    1},\n    { 16,  6,  4,   61},     {  0, 10,  5, 1021},\n    {  0, 16,  5,65533},     {  0, 28,  5,268435453},\n    {  0, 27,  5,134217725}, {  0, 26,  5,67108861},\n    {  0, 25,  5,33554429},  {  0, 24,  5,16777213},\n};    \n\n\n \nstatic const ZSTD_seqSymbol ML_defaultDTable[(1<<ML_DEFAULTNORMLOG)+1] = {\n    {  1,  1,  1, ML_DEFAULTNORMLOG},   \n     \n    {  0,  0,  6,    3},  {  0,  0,  4,    4},\n    { 32,  0,  5,    5},  {  0,  0,  5,    6},\n    {  0,  0,  5,    8},  {  0,  0,  5,    9},\n    {  0,  0,  5,   11},  {  0,  0,  6,   13},\n    {  0,  0,  6,   16},  {  0,  0,  6,   19},\n    {  0,  0,  6,   22},  {  0,  0,  6,   25},\n    {  0,  0,  6,   28},  {  0,  0,  6,   31},\n    {  0,  0,  6,   34},  {  0,  1,  6,   37},\n    {  0,  1,  6,   41},  {  0,  2,  6,   47},\n    {  0,  3,  6,   59},  {  0,  4,  6,   83},\n    {  0,  7,  6,  131},  {  0,  9,  6,  515},\n    { 16,  0,  4,    4},  {  0,  0,  4,    5},\n    { 32,  0,  5,    6},  {  0,  0,  5,    7},\n    { 32,  0,  5,    9},  {  0,  0,  5,   10},\n    {  0,  0,  6,   12},  {  0,  0,  6,   15},\n    {  0,  0,  6,   18},  {  0,  0,  6,   21},\n    {  0,  0,  6,   24},  {  0,  0,  6,   27},\n    {  0,  0,  6,   30},  {  0,  0,  6,   33},\n    {  0,  1,  6,   35},  {  0,  1,  6,   39},\n    {  0,  2,  6,   43},  {  0,  3,  6,   51},\n    {  0,  4,  6,   67},  {  0,  5,  6,   99},\n    {  0,  8,  6,  259},  { 32,  0,  4,    4},\n    { 48,  0,  4,    4},  { 16,  0,  4,    5},\n    { 32,  0,  5,    7},  { 32,  0,  5,    8},\n    { 32,  0,  5,   10},  { 32,  0,  5,   11},\n    {  0,  0,  6,   14},  {  0,  0,  6,   17},\n    {  0,  0,  6,   20},  {  0,  0,  6,   23},\n    {  0,  0,  6,   26},  {  0,  0,  6,   29},\n    {  0,  0,  6,   32},  {  0, 16,  6,65539},\n    {  0, 15,  6,32771},  {  0, 14,  6,16387},\n    {  0, 13,  6, 8195},  {  0, 12,  6, 4099},\n    {  0, 11,  6, 2051},  {  0, 10,  6, 1027},\n};    \n\n\nstatic void ZSTD_buildSeqTable_rle(ZSTD_seqSymbol* dt, U32 baseValue, U32 nbAddBits)\n{\n    void* ptr = dt;\n    ZSTD_seqSymbol_header* const DTableH = (ZSTD_seqSymbol_header*)ptr;\n    ZSTD_seqSymbol* const cell = dt + 1;\n\n    DTableH->tableLog = 0;\n    DTableH->fastMode = 0;\n\n    cell->nbBits = 0;\n    cell->nextState = 0;\n    assert(nbAddBits < 255);\n    cell->nbAdditionalBits = (BYTE)nbAddBits;\n    cell->baseValue = baseValue;\n}\n\n\n \nvoid\nZSTD_buildFSETable(ZSTD_seqSymbol* dt,\n            const short* normalizedCounter, unsigned maxSymbolValue,\n            const U32* baseValue, const U32* nbAdditionalBits,\n            unsigned tableLog)\n{\n    ZSTD_seqSymbol* const tableDecode = dt+1;\n    U16 symbolNext[MaxSeq+1];\n\n    U32 const maxSV1 = maxSymbolValue + 1;\n    U32 const tableSize = 1 << tableLog;\n    U32 highThreshold = tableSize-1;\n\n     \n    assert(maxSymbolValue <= MaxSeq);\n    assert(tableLog <= MaxFSELog);\n\n     \n    {   ZSTD_seqSymbol_header DTableH;\n        DTableH.tableLog = tableLog;\n        DTableH.fastMode = 1;\n        {   S16 const largeLimit= (S16)(1 << (tableLog-1));\n            U32 s;\n            for (s=0; s<maxSV1; s++) {\n                if (normalizedCounter[s]==-1) {\n                    tableDecode[highThreshold--].baseValue = s;\n                    symbolNext[s] = 1;\n                } else {\n                    if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;\n                    assert(normalizedCounter[s]>=0);\n                    symbolNext[s] = (U16)normalizedCounter[s];\n        }   }   }\n        memcpy(dt, &DTableH, sizeof(DTableH));\n    }\n\n     \n    {   U32 const tableMask = tableSize-1;\n        U32 const step = FSE_TABLESTEP(tableSize);\n        U32 s, position = 0;\n        for (s=0; s<maxSV1; s++) {\n            int i;\n            for (i=0; i<normalizedCounter[s]; i++) {\n                tableDecode[position].baseValue = s;\n                position = (position + step) & tableMask;\n                while (position > highThreshold) position = (position + step) & tableMask;    \n        }   }\n        assert(position == 0);  \n    }\n\n     \n    {   U32 u;\n        for (u=0; u<tableSize; u++) {\n            U32 const symbol = tableDecode[u].baseValue;\n            U32 const nextState = symbolNext[symbol]++;\n            tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );\n            tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);\n            assert(nbAdditionalBits[symbol] < 255);\n            tableDecode[u].nbAdditionalBits = (BYTE)nbAdditionalBits[symbol];\n            tableDecode[u].baseValue = baseValue[symbol];\n    }   }\n}\n\n\n \nstatic size_t ZSTD_buildSeqTable(ZSTD_seqSymbol* DTableSpace, const ZSTD_seqSymbol** DTablePtr,\n                                 symbolEncodingType_e type, unsigned max, U32 maxLog,\n                                 const void* src, size_t srcSize,\n                                 const U32* baseValue, const U32* nbAdditionalBits,\n                                 const ZSTD_seqSymbol* defaultTable, U32 flagRepeatTable,\n                                 int ddictIsCold, int nbSeq)\n{\n    switch(type)\n    {\n    case set_rle :\n        RETURN_ERROR_IF(!srcSize, srcSize_wrong, \"\");\n        RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, \"\");\n        {   U32 const symbol = *(const BYTE*)src;\n            U32 const baseline = baseValue[symbol];\n            U32 const nbBits = nbAdditionalBits[symbol];\n            ZSTD_buildSeqTable_rle(DTableSpace, baseline, nbBits);\n        }\n        *DTablePtr = DTableSpace;\n        return 1;\n    case set_basic :\n        *DTablePtr = defaultTable;\n        return 0;\n    case set_repeat:\n        RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, \"\");\n         \n        if (ddictIsCold && (nbSeq > 24  )) {\n            const void* const pStart = *DTablePtr;\n            size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));\n            PREFETCH_AREA(pStart, pSize);\n        }\n        return 0;\n    case set_compressed :\n        {   unsigned tableLog;\n            S16 norm[MaxSeq+1];\n            size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);\n            RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, \"\");\n            RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, \"\");\n            ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog);\n            *DTablePtr = DTableSpace;\n            return headerSize;\n        }\n    default :\n        assert(0);\n        RETURN_ERROR(GENERIC, \"impossible\");\n    }\n}\n\nsize_t ZSTD_decodeSeqHeaders(ZSTD_DCtx* dctx, int* nbSeqPtr,\n                             const void* src, size_t srcSize)\n{\n    const BYTE* const istart = (const BYTE* const)src;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* ip = istart;\n    int nbSeq;\n    DEBUGLOG(5, \"ZSTD_decodeSeqHeaders\");\n\n     \n    RETURN_ERROR_IF(srcSize < MIN_SEQUENCES_SIZE, srcSize_wrong, \"\");\n\n     \n    nbSeq = *ip++;\n    if (!nbSeq) {\n        *nbSeqPtr=0;\n        RETURN_ERROR_IF(srcSize != 1, srcSize_wrong, \"\");\n        return 1;\n    }\n    if (nbSeq > 0x7F) {\n        if (nbSeq == 0xFF) {\n            RETURN_ERROR_IF(ip+2 > iend, srcSize_wrong, \"\");\n            nbSeq = MEM_readLE16(ip) + LONGNBSEQ, ip+=2;\n        } else {\n            RETURN_ERROR_IF(ip >= iend, srcSize_wrong, \"\");\n            nbSeq = ((nbSeq-0x80)<<8) + *ip++;\n        }\n    }\n    *nbSeqPtr = nbSeq;\n\n     \n    RETURN_ERROR_IF(ip+1 > iend, srcSize_wrong, \"\");  \n    {   symbolEncodingType_e const LLtype = (symbolEncodingType_e)(*ip >> 6);\n        symbolEncodingType_e const OFtype = (symbolEncodingType_e)((*ip >> 4) & 3);\n        symbolEncodingType_e const MLtype = (symbolEncodingType_e)((*ip >> 2) & 3);\n        ip++;\n\n         \n        {   size_t const llhSize = ZSTD_buildSeqTable(dctx->entropy.LLTable, &dctx->LLTptr,\n                                                      LLtype, MaxLL, LLFSELog,\n                                                      ip, iend-ip,\n                                                      LL_base, LL_bits,\n                                                      LL_defaultDTable, dctx->fseEntropy,\n                                                      dctx->ddictIsCold, nbSeq);\n            RETURN_ERROR_IF(ZSTD_isError(llhSize), corruption_detected, \"ZSTD_buildSeqTable failed\");\n            ip += llhSize;\n        }\n\n        {   size_t const ofhSize = ZSTD_buildSeqTable(dctx->entropy.OFTable, &dctx->OFTptr,\n                                                      OFtype, MaxOff, OffFSELog,\n                                                      ip, iend-ip,\n                                                      OF_base, OF_bits,\n                                                      OF_defaultDTable, dctx->fseEntropy,\n                                                      dctx->ddictIsCold, nbSeq);\n            RETURN_ERROR_IF(ZSTD_isError(ofhSize), corruption_detected, \"ZSTD_buildSeqTable failed\");\n            ip += ofhSize;\n        }\n\n        {   size_t const mlhSize = ZSTD_buildSeqTable(dctx->entropy.MLTable, &dctx->MLTptr,\n                                                      MLtype, MaxML, MLFSELog,\n                                                      ip, iend-ip,\n                                                      ML_base, ML_bits,\n                                                      ML_defaultDTable, dctx->fseEntropy,\n                                                      dctx->ddictIsCold, nbSeq);\n            RETURN_ERROR_IF(ZSTD_isError(mlhSize), corruption_detected, \"ZSTD_buildSeqTable failed\");\n            ip += mlhSize;\n        }\n    }\n\n    return ip-istart;\n}\n\n\ntypedef struct {\n    size_t litLength;\n    size_t matchLength;\n    size_t offset;\n} seq_t;\n\ntypedef struct {\n    size_t state;\n    const ZSTD_seqSymbol* table;\n} ZSTD_fseState;\n\ntypedef struct {\n    BIT_DStream_t DStream;\n    ZSTD_fseState stateLL;\n    ZSTD_fseState stateOffb;\n    ZSTD_fseState stateML;\n    size_t prevOffset[ZSTD_REP_NUM];\n} seqState_t;\n\n \nHINT_INLINE void ZSTD_overlapCopy8(BYTE** op, BYTE const** ip, size_t offset) {\n    assert(*ip <= *op);\n    if (offset < 8) {\n         \n        static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };    \n        static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };    \n        int const sub2 = dec64table[offset];\n        (*op)[0] = (*ip)[0];\n        (*op)[1] = (*ip)[1];\n        (*op)[2] = (*ip)[2];\n        (*op)[3] = (*ip)[3];\n        *ip += dec32table[offset];\n        ZSTD_copy4(*op+4, *ip);\n        *ip -= sub2;\n    } else {\n        ZSTD_copy8(*op, *ip);\n    }\n    *ip += 8;\n    *op += 8;\n    assert(*op - *ip >= 8);\n}\n\n \nstatic void ZSTD_safecopy(BYTE* op, BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype) {\n    ptrdiff_t const diff = op - ip;\n    BYTE* const oend = op + length;\n\n    assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||\n           (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));\n\n    if (length < 8) {\n         \n        while (op < oend) *op++ = *ip++;\n        return;\n    }\n    if (ovtype == ZSTD_overlap_src_before_dst) {\n         \n        assert(length >= 8);\n        ZSTD_overlapCopy8(&op, &ip, diff);\n        assert(op - ip >= 8);\n        assert(op <= oend);\n    }\n\n    if (oend <= oend_w) {\n         \n        ZSTD_wildcopy(op, ip, length, ovtype);\n        return;\n    }\n    if (op <= oend_w) {\n         \n        assert(oend > oend_w);\n        ZSTD_wildcopy(op, ip, oend_w - op, ovtype);\n        ip += oend_w - op;\n        op = oend_w;\n    }\n     \n    while (op < oend) *op++ = *ip++;\n}\n\n \nFORCE_NOINLINE\nsize_t ZSTD_execSequenceEnd(BYTE* op,\n                            BYTE* const oend, seq_t sequence,\n                            const BYTE** litPtr, const BYTE* const litLimit,\n                            const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)\n{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;\n\n     \n    RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, \"last match must fit within dstBuffer\");\n    RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, \"try to read beyond literal buffer\");\n    assert(op < op + sequenceLength);\n    assert(oLitEnd < op + sequenceLength);\n\n     \n    ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);\n    op = oLitEnd;\n    *litPtr = iLitEnd;\n\n     \n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n         \n        RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, \"\");\n        match = dictEnd - (prefixStart-match);\n        if (match + sequence.matchLength <= dictEnd) {\n            memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n         \n        {   size_t const length1 = dictEnd - match;\n            memmove(oLitEnd, match, length1);\n            op = oLitEnd + length1;\n            sequence.matchLength -= length1;\n            match = prefixStart;\n    }   }\n    ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);\n    return sequenceLength;\n}\n\nHINT_INLINE\nsize_t ZSTD_execSequence(BYTE* op,\n                         BYTE* const oend, seq_t sequence,\n                         const BYTE** litPtr, const BYTE* const litLimit,\n                         const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)\n{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    BYTE* const oMatchEnd = op + sequenceLength;    \n    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;    \n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n\n    assert(op != NULL  );\n    assert(oend_w < oend  );\n     \n    if (UNLIKELY(\n            iLitEnd > litLimit ||\n            oMatchEnd > oend_w ||\n            (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))\n        return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);\n\n     \n    assert(op <= oLitEnd  );\n    assert(oLitEnd < oMatchEnd  );\n    assert(oMatchEnd <= oend  );\n    assert(iLitEnd <= litLimit  );\n    assert(oLitEnd <= oend_w  );\n    assert(oMatchEnd <= oend_w  );\n\n     \n    assert(WILDCOPY_OVERLENGTH >= 16);\n    ZSTD_copy16(op, (*litPtr));\n    if (UNLIKELY(sequence.litLength > 16)) {\n        ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);\n    }\n    op = oLitEnd;\n    *litPtr = iLitEnd;    \n\n     \n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n         \n        RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, \"\");\n        match = dictEnd + (match - prefixStart);\n        if (match + sequence.matchLength <= dictEnd) {\n            memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n         \n        {   size_t const length1 = dictEnd - match;\n            memmove(oLitEnd, match, length1);\n            op = oLitEnd + length1;\n            sequence.matchLength -= length1;\n            match = prefixStart;\n    }   }\n     \n    assert(op <= oMatchEnd);\n    assert(oMatchEnd <= oend_w);\n    assert(match >= prefixStart);\n    assert(sequence.matchLength >= 1);\n\n     \n    if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {\n         \n        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength, ZSTD_no_overlap);\n        return sequenceLength;\n    }\n    assert(sequence.offset < WILDCOPY_VECLEN);\n\n     \n    ZSTD_overlapCopy8(&op, &match, sequence.offset);\n\n     \n    if (sequence.matchLength > 8) {\n        assert(op < oMatchEnd);\n        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength-8, ZSTD_overlap_src_before_dst);\n    }\n    return sequenceLength;\n}\n\nstatic void\nZSTD_initFseState(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD, const ZSTD_seqSymbol* dt)\n{\n    const void* ptr = dt;\n    const ZSTD_seqSymbol_header* const DTableH = (const ZSTD_seqSymbol_header*)ptr;\n    DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);\n    DEBUGLOG(6, \"ZSTD_initFseState : val=%u using %u bits\",\n                (U32)DStatePtr->state, DTableH->tableLog);\n    BIT_reloadDStream(bitD);\n    DStatePtr->table = dt + 1;\n}\n\nFORCE_INLINE_TEMPLATE void\nZSTD_updateFseState(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD)\n{\n    ZSTD_seqSymbol const DInfo = DStatePtr->table[DStatePtr->state];\n    U32 const nbBits = DInfo.nbBits;\n    size_t const lowBits = BIT_readBits(bitD, nbBits);\n    DStatePtr->state = DInfo.nextState + lowBits;\n}\n\nFORCE_INLINE_TEMPLATE void\nZSTD_updateFseStateWithDInfo(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD, ZSTD_seqSymbol const DInfo)\n{\n    U32 const nbBits = DInfo.nbBits;\n    size_t const lowBits = BIT_readBits(bitD, nbBits);\n    DStatePtr->state = DInfo.nextState + lowBits;\n}\n\n \n#define LONG_OFFSETS_MAX_EXTRA_BITS_32                       \\\n    (ZSTD_WINDOWLOG_MAX_32 > STREAM_ACCUMULATOR_MIN_32       \\\n        ? ZSTD_WINDOWLOG_MAX_32 - STREAM_ACCUMULATOR_MIN_32  \\\n        : 0)\n\ntypedef enum { ZSTD_lo_isRegularOffset, ZSTD_lo_isLongOffset=1 } ZSTD_longOffset_e;\n\nFORCE_INLINE_TEMPLATE seq_t\nZSTD_decodeSequence(seqState_t* seqState, const ZSTD_longOffset_e longOffsets)\n{\n    seq_t seq;\n    ZSTD_seqSymbol const llDInfo = seqState->stateLL.table[seqState->stateLL.state];\n    ZSTD_seqSymbol const mlDInfo = seqState->stateML.table[seqState->stateML.state];\n    ZSTD_seqSymbol const ofDInfo = seqState->stateOffb.table[seqState->stateOffb.state];\n    U32 const llBase = llDInfo.baseValue;\n    U32 const mlBase = mlDInfo.baseValue;\n    U32 const ofBase = ofDInfo.baseValue;\n    BYTE const llBits = llDInfo.nbAdditionalBits;\n    BYTE const mlBits = mlDInfo.nbAdditionalBits;\n    BYTE const ofBits = ofDInfo.nbAdditionalBits;\n    BYTE const totalBits = llBits+mlBits+ofBits;\n\n     \n    {   size_t offset;\n        if (ofBits > 1) {\n            ZSTD_STATIC_ASSERT(ZSTD_lo_isLongOffset == 1);\n            ZSTD_STATIC_ASSERT(LONG_OFFSETS_MAX_EXTRA_BITS_32 == 5);\n            assert(ofBits <= MaxOff);\n            if (MEM_32bits() && longOffsets && (ofBits >= STREAM_ACCUMULATOR_MIN_32)) {\n                U32 const extraBits = ofBits - MIN(ofBits, 32 - seqState->DStream.bitsConsumed);\n                offset = ofBase + (BIT_readBitsFast(&seqState->DStream, ofBits - extraBits) << extraBits);\n                BIT_reloadDStream(&seqState->DStream);\n                if (extraBits) offset += BIT_readBitsFast(&seqState->DStream, extraBits);\n                assert(extraBits <= LONG_OFFSETS_MAX_EXTRA_BITS_32);    \n            } else {\n                offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits );    \n                if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);\n            }\n            seqState->prevOffset[2] = seqState->prevOffset[1];\n            seqState->prevOffset[1] = seqState->prevOffset[0];\n            seqState->prevOffset[0] = offset;\n        } else {\n            U32 const ll0 = (llBase == 0);\n            if (LIKELY((ofBits == 0))) {\n                if (LIKELY(!ll0))\n                    offset = seqState->prevOffset[0];\n                else {\n                    offset = seqState->prevOffset[1];\n                    seqState->prevOffset[1] = seqState->prevOffset[0];\n                    seqState->prevOffset[0] = offset;\n                }\n            } else {\n                offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);\n                {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];\n                    temp += !temp;    \n                    if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];\n                    seqState->prevOffset[1] = seqState->prevOffset[0];\n                    seqState->prevOffset[0] = offset = temp;\n        }   }   }\n        seq.offset = offset;\n    }\n\n    seq.matchLength = mlBase;\n    if (mlBits > 0)\n        seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits );\n\n    if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))\n        BIT_reloadDStream(&seqState->DStream);\n    if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))\n        BIT_reloadDStream(&seqState->DStream);\n     \n    ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);\n\n    seq.litLength = llBase;\n    if (llBits > 0)\n        seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits );\n\n    if (MEM_32bits())\n        BIT_reloadDStream(&seqState->DStream);\n\n    DEBUGLOG(6, \"seq: litL=%u, matchL=%u, offset=%u\",\n                (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);\n\n     \n    {\n#if defined(__GNUC__) && !defined(__clang__)\n        const int kUseUpdateFseState = 1;\n#else\n        const int kUseUpdateFseState = 0;\n#endif\n        if (kUseUpdateFseState) {\n            ZSTD_updateFseState(&seqState->stateLL, &seqState->DStream);     \n            ZSTD_updateFseState(&seqState->stateML, &seqState->DStream);     \n            if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);     \n            ZSTD_updateFseState(&seqState->stateOffb, &seqState->DStream);   \n        } else {\n            ZSTD_updateFseStateWithDInfo(&seqState->stateLL, &seqState->DStream, llDInfo);     \n            ZSTD_updateFseStateWithDInfo(&seqState->stateML, &seqState->DStream, mlDInfo);     \n            if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);     \n            ZSTD_updateFseStateWithDInfo(&seqState->stateOffb, &seqState->DStream, ofDInfo);   \n        }\n    }\n\n    return seq;\n}\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\nstatic int ZSTD_dictionaryIsActive(ZSTD_DCtx const* dctx, BYTE const* prefixStart, BYTE const* oLitEnd)\n{\n    size_t const windowSize = dctx->fParams.windowSize;\n     \n    if (dctx->dictContentEndForFuzzing == NULL) return 0;\n     \n    if (prefixStart == dctx->dictContentBeginForFuzzing) return 1;\n     \n    if (dctx->dictEnd != dctx->dictContentEndForFuzzing) return 0;\n     \n    if ((size_t)(oLitEnd - prefixStart) >= windowSize) return 0;\n     \n    return 1;\n}\n\nMEM_STATIC void ZSTD_assertValidSequence(\n        ZSTD_DCtx const* dctx,\n        BYTE const* op, BYTE const* oend,\n        seq_t const seq,\n        BYTE const* prefixStart, BYTE const* virtualStart)\n{\n    size_t const windowSize = dctx->fParams.windowSize;\n    size_t const sequenceSize = seq.litLength + seq.matchLength;\n    BYTE const* const oLitEnd = op + seq.litLength;\n    DEBUGLOG(6, \"Checking sequence: litL=%u matchL=%u offset=%u\",\n            (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);\n    assert(op <= oend);\n    assert((size_t)(oend - op) >= sequenceSize);\n    assert(sequenceSize <= ZSTD_BLOCKSIZE_MAX);\n    if (ZSTD_dictionaryIsActive(dctx, prefixStart, oLitEnd)) {\n        size_t const dictSize = (size_t)((char const*)dctx->dictContentEndForFuzzing - (char const*)dctx->dictContentBeginForFuzzing);\n         \n        assert(seq.offset <= (size_t)(oLitEnd - virtualStart));\n        assert(seq.offset <= windowSize + dictSize);\n    } else {\n         \n        assert(seq.offset <= windowSize);\n    }\n}\n#endif\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\nFORCE_INLINE_TEMPLATE size_t\nDONT_VECTORIZE\nZSTD_decompressSequences_body( ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize, int nbSeq,\n                         const ZSTD_longOffset_e isLongOffset,\n                         const int frame)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);\n    const BYTE* const vBase = (const BYTE*) (dctx->virtualStart);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n    DEBUGLOG(5, \"ZSTD_decompressSequences_body\");\n    (void)frame;\n\n     \n    if (nbSeq) {\n        seqState_t seqState;\n        size_t error = 0;\n        dctx->fseEntropy = 1;\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        RETURN_ERROR_IF(\n            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),\n            corruption_detected, \"\");\n        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n        assert(dst != NULL);\n\n        ZSTD_STATIC_ASSERT(\n                BIT_DStream_unfinished < BIT_DStream_completed &&\n                BIT_DStream_endOfBuffer < BIT_DStream_completed &&\n                BIT_DStream_completed < BIT_DStream_overflow);\n\n#if defined(__GNUC__) && defined(__x86_64__)\n         \n        __asm__(\".p2align 5\");\n        __asm__(\"nop\");\n        __asm__(\".p2align 4\");\n#endif\n        for ( ; ; ) {\n            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n            assert(!ZSTD_isError(oneSeqSize));\n            if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);\n#endif\n            DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n            BIT_reloadDStream(&(seqState.DStream));\n             \n            if (UNLIKELY(ZSTD_isError(oneSeqSize))) error = oneSeqSize;\n            else op += oneSeqSize;\n            if (UNLIKELY(!--nbSeq)) break;\n        }\n\n         \n        DEBUGLOG(5, \"ZSTD_decompressSequences_body: after decode loop, remaining nbSeq : %i\", nbSeq);\n        if (ZSTD_isError(error)) return error;\n        RETURN_ERROR_IF(nbSeq, corruption_detected, \"\");\n        RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, \"\");\n         \n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n     \n    {   size_t const lastLLSize = litEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            memcpy(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n    }\n\n    return op-ostart;\n}\n\nstatic size_t\nZSTD_decompressSequences_default(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n\nFORCE_INLINE_TEMPLATE size_t\nZSTD_prefetchMatch(size_t prefixPos, seq_t const sequence,\n                   const BYTE* const prefixStart, const BYTE* const dictEnd)\n{\n    prefixPos += sequence.litLength;\n    {   const BYTE* const matchBase = (sequence.offset > prefixPos) ? dictEnd : prefixStart;\n        const BYTE* const match = matchBase + prefixPos - sequence.offset;   \n        PREFETCH_L1(match); PREFETCH_L1(match + sequence.matchLength - 1);  \n    }\n    return prefixPos + sequence.matchLength;\n}\n\n \nFORCE_INLINE_TEMPLATE size_t\nZSTD_decompressSequencesLong_body(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize, int nbSeq,\n                         const ZSTD_longOffset_e isLongOffset,\n                         const int frame)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE* const)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);\n    const BYTE* const dictStart = (const BYTE*) (dctx->virtualStart);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n    (void)frame;\n\n     \n    if (nbSeq) {\n#define STORED_SEQS 4\n#define STORED_SEQS_MASK (STORED_SEQS-1)\n#define ADVANCED_SEQS 4\n        seq_t sequences[STORED_SEQS];\n        int const seqAdvance = MIN(nbSeq, ADVANCED_SEQS);\n        seqState_t seqState;\n        int seqNb;\n        size_t prefixPos = (size_t)(op-prefixStart);  \n\n        dctx->fseEntropy = 1;\n        { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        assert(dst != NULL);\n        assert(iend >= ip);\n        RETURN_ERROR_IF(\n            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),\n            corruption_detected, \"\");\n        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n\n         \n        for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {\n            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            prefixPos = ZSTD_prefetchMatch(prefixPos, sequence, prefixStart, dictEnd);\n            sequences[seqNb] = sequence;\n        }\n        RETURN_ERROR_IF(seqNb<seqAdvance, corruption_detected, \"\");\n\n         \n        for ( ; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb<nbSeq) ; seqNb++) {\n            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n            assert(!ZSTD_isError(oneSeqSize));\n            if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[(seqNb-ADVANCED_SEQS) & STORED_SEQS_MASK], prefixStart, dictStart);\n#endif\n            if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n\n            prefixPos = ZSTD_prefetchMatch(prefixPos, sequence, prefixStart, dictEnd);\n            sequences[seqNb & STORED_SEQS_MASK] = sequence;\n            op += oneSeqSize;\n        }\n        RETURN_ERROR_IF(seqNb<nbSeq, corruption_detected, \"\");\n\n         \n        seqNb -= seqAdvance;\n        for ( ; seqNb<nbSeq ; seqNb++) {\n            size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequences[seqNb&STORED_SEQS_MASK], &litPtr, litEnd, prefixStart, dictStart, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n            assert(!ZSTD_isError(oneSeqSize));\n            if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[seqNb&STORED_SEQS_MASK], prefixStart, dictStart);\n#endif\n            if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n            op += oneSeqSize;\n        }\n\n         \n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n     \n    {   size_t const lastLLSize = litEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            memcpy(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n    }\n\n    return op-ostart;\n}\n\nstatic size_t\nZSTD_decompressSequencesLong_default(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n\n\n#if DYNAMIC_BMI2\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\nstatic TARGET_ATTRIBUTE(\"bmi2\") size_t\nDONT_VECTORIZE\nZSTD_decompressSequences_bmi2(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\nstatic TARGET_ATTRIBUTE(\"bmi2\") size_t\nZSTD_decompressSequencesLong_bmi2(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n#endif  \n\ntypedef size_t (*ZSTD_decompressSequences_t)(\n                            ZSTD_DCtx* dctx,\n                            void* dst, size_t maxDstSize,\n                            const void* seqStart, size_t seqSize, int nbSeq,\n                            const ZSTD_longOffset_e isLongOffset,\n                            const int frame);\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\nstatic size_t\nZSTD_decompressSequences(ZSTD_DCtx* dctx, void* dst, size_t maxDstSize,\n                   const void* seqStart, size_t seqSize, int nbSeq,\n                   const ZSTD_longOffset_e isLongOffset,\n                   const int frame)\n{\n    DEBUGLOG(5, \"ZSTD_decompressSequences\");\n#if DYNAMIC_BMI2\n    if (dctx->bmi2) {\n        return ZSTD_decompressSequences_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n    }\n#endif\n  return ZSTD_decompressSequences_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n \nstatic size_t\nZSTD_decompressSequencesLong(ZSTD_DCtx* dctx,\n                             void* dst, size_t maxDstSize,\n                             const void* seqStart, size_t seqSize, int nbSeq,\n                             const ZSTD_longOffset_e isLongOffset,\n                             const int frame)\n{\n    DEBUGLOG(5, \"ZSTD_decompressSequencesLong\");\n#if DYNAMIC_BMI2\n    if (dctx->bmi2) {\n        return ZSTD_decompressSequencesLong_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n    }\n#endif\n  return ZSTD_decompressSequencesLong_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n\n\n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n \nstatic unsigned\nZSTD_getLongOffsetsShare(const ZSTD_seqSymbol* offTable)\n{\n    const void* ptr = offTable;\n    U32 const tableLog = ((const ZSTD_seqSymbol_header*)ptr)[0].tableLog;\n    const ZSTD_seqSymbol* table = offTable + 1;\n    U32 const max = 1 << tableLog;\n    U32 u, total = 0;\n    DEBUGLOG(5, \"ZSTD_getLongOffsetsShare: (tableLog=%u)\", tableLog);\n\n    assert(max <= (1 << OffFSELog));   \n    for (u=0; u<max; u++) {\n        if (table[u].nbAdditionalBits > 22) total += 1;\n    }\n\n    assert(tableLog <= OffFSELog);\n    total <<= (OffFSELog - tableLog);   \n\n    return total;\n}\n#endif\n\nsize_t\nZSTD_decompressBlock_internal(ZSTD_DCtx* dctx,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize, const int frame)\n{    \n    const BYTE* ip = (const BYTE*)src;\n     \n    ZSTD_longOffset_e const isLongOffset = (ZSTD_longOffset_e)(MEM_32bits() && (!frame || (dctx->fParams.windowSize > (1ULL << STREAM_ACCUMULATOR_MIN))));\n    DEBUGLOG(5, \"ZSTD_decompressBlock_internal (size : %u)\", (U32)srcSize);\n\n    RETURN_ERROR_IF(srcSize >= ZSTD_BLOCKSIZE_MAX, srcSize_wrong, \"\");\n\n     \n    {   size_t const litCSize = ZSTD_decodeLiteralsBlock(dctx, src, srcSize);\n        DEBUGLOG(5, \"ZSTD_decodeLiteralsBlock : %u\", (U32)litCSize);\n        if (ZSTD_isError(litCSize)) return litCSize;\n        ip += litCSize;\n        srcSize -= litCSize;\n    }\n\n     \n    {\n         \n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n        int usePrefetchDecoder = dctx->ddictIsCold;\n#endif\n        int nbSeq;\n        size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, srcSize);\n        if (ZSTD_isError(seqHSize)) return seqHSize;\n        ip += seqHSize;\n        srcSize -= seqHSize;\n\n        RETURN_ERROR_IF(dst == NULL && nbSeq > 0, dstSize_tooSmall, \"NULL not handled\");\n\n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n        if ( !usePrefetchDecoder\n          && (!frame || (dctx->fParams.windowSize > (1<<24)))\n          && (nbSeq>ADVANCED_SEQS) ) {   \n            U32 const shareLongOffsets = ZSTD_getLongOffsetsShare(dctx->OFTptr);\n            U32 const minShare = MEM_64bits() ? 7 : 20;  \n            usePrefetchDecoder = (shareLongOffsets >= minShare);\n        }\n#endif\n\n        dctx->ddictIsCold = 0;\n\n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n        if (usePrefetchDecoder)\n#endif\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n            return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n#endif\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\n         \n        return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n#endif\n    }\n}\n\n\nvoid ZSTD_checkContinuity(ZSTD_DCtx* dctx, const void* dst)\n{\n    if (dst != dctx->previousDstEnd) {    \n        dctx->dictEnd = dctx->previousDstEnd;\n        dctx->virtualStart = (const char*)dst - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));\n        dctx->prefixStart = dst;\n        dctx->previousDstEnd = dst;\n    }\n}\n\n\nsize_t ZSTD_decompressBlock(ZSTD_DCtx* dctx,\n                            void* dst, size_t dstCapacity,\n                      const void* src, size_t srcSize)\n{\n    size_t dSize;\n    ZSTD_checkContinuity(dctx, dst);\n    dSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize,   0);\n    dctx->previousDstEnd = (char*)dst + dSize;\n    return dSize;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}