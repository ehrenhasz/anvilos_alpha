{
  "module_name": "spl.4",
  "hash_id": "fc67d0855bf64adc02ff7e860c70cf5045d0be0ddf79ab5e9bf9b65ede11b8a1",
  "original_prompt": "Ingested from zfs-2.2.2/man/man4/spl.4",
  "human_readable_source": ".\\\"\n.\\\" The contents of this file are subject to the terms of the Common Development\n.\\\" and Distribution License (the \"License\").  You may not use this file except\n.\\\" in compliance with the License. You can obtain a copy of the license at\n.\\\" usr/src/OPENSOLARIS.LICENSE or https://opensource.org/licenses/CDDL-1.0.\n.\\\"\n.\\\" See the License for the specific language governing permissions and\n.\\\" limitations under the License. When distributing Covered Code, include this\n.\\\" CDDL HEADER in each file and include the License file at\n.\\\" usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this\n.\\\" CDDL HEADER, with the fields enclosed by brackets \"[]\" replaced with your\n.\\\" own identifying information:\n.\\\" Portions Copyright [yyyy] [name of copyright owner]\n.\\\"\n.\\\" Copyright 2013 Turbo Fredriksson <turbo@bayour.com>. All rights reserved.\n.\\\"\n.Dd August 24, 2020\n.Dt SPL 4\n.Os\n.\n.Sh NAME\n.Nm spl\n.Nd parameters of the SPL kernel module\n.\n.Sh DESCRIPTION\n.Bl -tag -width Ds\n.It Sy spl_kmem_cache_kmem_threads Ns = Ns Sy 4 Pq uint\nThe number of threads created for the spl_kmem_cache task queue.\nThis task queue is responsible for allocating new slabs\nfor use by the kmem caches.\nFor the majority of systems and workloads only a small number of threads are\nrequired.\n.\n.It Sy spl_kmem_cache_reclaim Ns = Ns Sy 0 Pq uint\nWhen this is set it prevents Linux from being able to rapidly reclaim all the\nmemory held by the kmem caches.\nThis may be useful in circumstances where it's preferable that Linux\nreclaim memory from some other subsystem first.\nSetting this will increase the likelihood out of memory events on a memory\nconstrained system.\n.\n.It Sy spl_kmem_cache_obj_per_slab Ns = Ns Sy 8 Pq uint\nThe preferred number of objects per slab in the cache.\nIn general, a larger value will increase the caches memory footprint\nwhile decreasing the time required to perform an allocation.\nConversely, a smaller value will minimize the footprint\nand improve cache reclaim time but individual allocations may take longer.\n.\n.It Sy spl_kmem_cache_max_size Ns = Ns Sy 32 Po 64-bit Pc or Sy 4 Po 32-bit Pc Pq uint\nThe maximum size of a kmem cache slab in MiB.\nThis effectively limits the maximum cache object size to\n.Sy spl_kmem_cache_max_size Ns / Ns Sy spl_kmem_cache_obj_per_slab .\n.Pp\nCaches may not be created with\nobject sized larger than this limit.\n.\n.It Sy spl_kmem_cache_slab_limit Ns = Ns Sy 16384 Pq uint\nFor small objects the Linux slab allocator should be used to make the most\nefficient use of the memory.\nHowever, large objects are not supported by\nthe Linux slab and therefore the SPL implementation is preferred.\nThis value is used to determine the cutoff between a small and large object.\n.Pp\nObjects of size\n.Sy spl_kmem_cache_slab_limit\nor smaller will be allocated using the Linux slab allocator,\nlarge objects use the SPL allocator.\nA cutoff of 16K was determined to be optimal for architectures using 4K pages.\n.\n.It Sy spl_kmem_alloc_warn Ns = Ns Sy 32768 Pq uint\nAs a general rule\n.Fn kmem_alloc\nallocations should be small,\npreferably just a few pages, since they must by physically contiguous.\nTherefore, a rate limited warning will be printed to the console for any\n.Fn kmem_alloc\nwhich exceeds a reasonable threshold.\n.Pp\nThe default warning threshold is set to eight pages but capped at 32K to\naccommodate systems using large pages.\nThis value was selected to be small enough to ensure\nthe largest allocations are quickly noticed and fixed.\nBut large enough to avoid logging any warnings when a allocation size is\nlarger than optimal but not a serious concern.\nSince this value is tunable, developers are encouraged to set it lower\nwhen testing so any new largish allocations are quickly caught.\nThese warnings may be disabled by setting the threshold to zero.\n.\n.It Sy spl_kmem_alloc_max Ns = Ns Sy KMALLOC_MAX_SIZE Ns / Ns Sy 4 Pq uint\nLarge\n.Fn kmem_alloc\nallocations will fail if they exceed\n.Sy KMALLOC_MAX_SIZE .\nAllocations which are marginally smaller than this limit may succeed but\nshould still be avoided due to the expense of locating a contiguous range\nof free pages.\nTherefore, a maximum kmem size with reasonable safely margin of 4x is set.\n.Fn kmem_alloc\nallocations larger than this maximum will quickly fail.\n.Fn vmem_alloc\nallocations less than or equal to this value will use\n.Fn kmalloc ,\nbut shift to\n.Fn vmalloc\nwhen exceeding this value.\n.\n.It Sy spl_kmem_cache_magazine_size Ns = Ns Sy 0 Pq uint\nCache magazines are an optimization designed to minimize the cost of\nallocating memory.\nThey do this by keeping a per-cpu cache of recently\nfreed objects, which can then be reallocated without taking a lock.\nThis can improve performance on highly contended caches.\nHowever, because objects in magazines will prevent otherwise empty slabs\nfrom being immediately released this may not be ideal for low memory machines.\n.Pp\nFor this reason,\n.Sy spl_kmem_cache_magazine_size\ncan be used to set a maximum magazine size.\nWhen this value is set to 0 the magazine size will\nbe automatically determined based on the object size.\nOtherwise magazines will be limited to 2-256 objects per magazine (i.e per cpu).\nMagazines may never be entirely disabled in this implementation.\n.\n.It Sy spl_hostid Ns = Ns Sy 0 Pq ulong\nThe system hostid, when set this can be used to uniquely identify a system.\nBy default this value is set to zero which indicates the hostid is disabled.\nIt can be explicitly enabled by placing a unique non-zero value in\n.Pa /etc/hostid .\n.\n.It Sy spl_hostid_path Ns = Ns Pa /etc/hostid Pq charp\nThe expected path to locate the system hostid when specified.\nThis value may be overridden for non-standard configurations.\n.\n.It Sy spl_panic_halt Ns = Ns Sy 0 Pq uint\nCause a kernel panic on assertion failures.\nWhen not enabled, the thread is halted to facilitate further debugging.\n.Pp\nSet to a non-zero value to enable.\n.\n.It Sy spl_taskq_kick Ns = Ns Sy 0 Pq uint\nKick stuck taskq to spawn threads.\nWhen writing a non-zero value to it, it will scan all the taskqs.\nIf any of them have a pending task more than 5 seconds old,\nit will kick it to spawn more threads.\nThis can be used if you find a rare\ndeadlock occurs because one or more taskqs didn't spawn a thread when it should.\n.\n.It Sy spl_taskq_thread_bind Ns = Ns Sy 0 Pq int\nBind taskq threads to specific CPUs.\nWhen enabled all taskq threads will be distributed evenly\nacross the available CPUs.\nBy default, this behavior is disabled to allow the Linux scheduler\nthe maximum flexibility to determine where a thread should run.\n.\n.It Sy spl_taskq_thread_dynamic Ns = Ns Sy 1 Pq int\nAllow dynamic taskqs.\nWhen enabled taskqs which set the\n.Sy TASKQ_DYNAMIC\nflag will by default create only a single thread.\nNew threads will be created on demand up to a maximum allowed number\nto facilitate the completion of outstanding tasks.\nThreads which are no longer needed will be promptly destroyed.\nBy default this behavior is enabled but it can be disabled to\naid performance analysis or troubleshooting.\n.\n.It Sy spl_taskq_thread_priority Ns = Ns Sy 1 Pq int\nAllow newly created taskq threads to set a non-default scheduler priority.\nWhen enabled, the priority specified when a taskq is created will be applied\nto all threads created by that taskq.\nWhen disabled all threads will use the default Linux kernel thread priority.\nBy default, this behavior is enabled.\n.\n.It Sy spl_taskq_thread_sequential Ns = Ns Sy 4 Pq int\nThe number of items a taskq worker thread must handle without interruption\nbefore requesting a new worker thread be spawned.\nThis is used to control\nhow quickly taskqs ramp up the number of threads processing the queue.\nBecause Linux thread creation and destruction are relatively inexpensive a\nsmall default value has been selected.\nThis means that normally threads will be created aggressively which is\ndesirable.\nIncreasing this value will\nresult in a slower thread creation rate which may be preferable for some\nconfigurations.\n.\n.It Sy spl_max_show_tasks Ns = Ns Sy 512 Pq uint\nThe maximum number of tasks per pending list in each taskq shown in\n.Pa /proc/spl/taskq{,-all} .\nWrite\n.Sy 0\nto turn off the limit.\nThe proc file will walk the lists with lock held,\nreading it could cause a lock-up if the list grow too large\nwithout limiting the output.\n\"(truncated)\" will be shown if the list is larger than the limit.\n.\n.It Sy spl_taskq_thread_timeout_ms Ns = Ns Sy 10000 Pq uint\n(Linux-only)\nHow long a taskq has to have had no work before we tear it down.\nPreviously, we would tear down a dynamic taskq worker as soon\nas we noticed it had no work, but it was observed that this led\nto a lot of churn in tearing down things we then immediately\nspawned anew.\nIn practice, it seems any nonzero value will remove the vast\nmajority of this churn, while the nontrivially larger value\nwas chosen to help filter out the little remaining churn on\na mostly idle system.\nSetting this value to\n.Sy 0\nwill revert to the previous behavior.\n.El\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}