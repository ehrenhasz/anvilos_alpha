{
  "module_name": "zfs.4",
  "hash_id": "71cb200ac3d8ac4b7c1b5f0502b2303252c6eefe4eb9524528daa7ecb63f697b",
  "original_prompt": "Ingested from zfs-2.2.2/man/man4/zfs.4",
  "human_readable_source": ".\\\"\n.\\\" Copyright (c) 2013 by Turbo Fredriksson <turbo@bayour.com>. All rights reserved.\n.\\\" Copyright (c) 2019, 2021 by Delphix. All rights reserved.\n.\\\" Copyright (c) 2019 Datto Inc.\n.\\\" The contents of this file are subject to the terms of the Common Development\n.\\\" and Distribution License (the \"License\").  You may not use this file except\n.\\\" in compliance with the License. You can obtain a copy of the license at\n.\\\" usr/src/OPENSOLARIS.LICENSE or https://opensource.org/licenses/CDDL-1.0.\n.\\\"\n.\\\" See the License for the specific language governing permissions and\n.\\\" limitations under the License. When distributing Covered Code, include this\n.\\\" CDDL HEADER in each file and include the License file at\n.\\\" usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this\n.\\\" CDDL HEADER, with the fields enclosed by brackets \"[]\" replaced with your\n.\\\" own identifying information:\n.\\\" Portions Copyright [yyyy] [name of copyright owner]\n.\\\"\n.Dd July 21, 2023\n.Dt ZFS 4\n.Os\n.\n.Sh NAME\n.Nm zfs\n.Nd tuning of the ZFS kernel module\n.\n.Sh DESCRIPTION\nThe ZFS module supports these parameters:\n.Bl -tag -width Ds\n.It Sy dbuf_cache_max_bytes Ns = Ns Sy UINT64_MAX Ns B Pq u64\nMaximum size in bytes of the dbuf cache.\nThe target size is determined by the MIN versus\n.No 1/2^ Ns Sy dbuf_cache_shift Pq 1/32nd\nof the target ARC size.\nThe behavior of the dbuf cache and its associated settings\ncan be observed via the\n.Pa /proc/spl/kstat/zfs/dbufstats\nkstat.\n.\n.It Sy dbuf_metadata_cache_max_bytes Ns = Ns Sy UINT64_MAX Ns B Pq u64\nMaximum size in bytes of the metadata dbuf cache.\nThe target size is determined by the MIN versus\n.No 1/2^ Ns Sy dbuf_metadata_cache_shift Pq 1/64th\nof the target ARC size.\nThe behavior of the metadata dbuf cache and its associated settings\ncan be observed via the\n.Pa /proc/spl/kstat/zfs/dbufstats\nkstat.\n.\n.It Sy dbuf_cache_hiwater_pct Ns = Ns Sy 10 Ns % Pq uint\nThe percentage over\n.Sy dbuf_cache_max_bytes\nwhen dbufs must be evicted directly.\n.\n.It Sy dbuf_cache_lowater_pct Ns = Ns Sy 10 Ns % Pq uint\nThe percentage below\n.Sy dbuf_cache_max_bytes\nwhen the evict thread stops evicting dbufs.\n.\n.It Sy dbuf_cache_shift Ns = Ns Sy 5 Pq uint\nSet the size of the dbuf cache\n.Pq Sy dbuf_cache_max_bytes\nto a log2 fraction of the target ARC size.\n.\n.It Sy dbuf_metadata_cache_shift Ns = Ns Sy 6 Pq uint\nSet the size of the dbuf metadata cache\n.Pq Sy dbuf_metadata_cache_max_bytes\nto a log2 fraction of the target ARC size.\n.\n.It Sy dbuf_mutex_cache_shift Ns = Ns Sy 0 Pq uint\nSet the size of the mutex array for the dbuf cache.\nWhen set to\n.Sy 0\nthe array is dynamically sized based on total system memory.\n.\n.It Sy dmu_object_alloc_chunk_shift Ns = Ns Sy 7 Po 128 Pc Pq uint\ndnode slots allocated in a single operation as a power of 2.\nThe default value minimizes lock contention for the bulk operation performed.\n.\n.It Sy dmu_prefetch_max Ns = Ns Sy 134217728 Ns B Po 128 MiB Pc Pq uint\nLimit the amount we can prefetch with one call to this amount in bytes.\nThis helps to limit the amount of memory that can be used by prefetching.\n.\n.It Sy ignore_hole_birth Pq int\nAlias for\n.Sy send_holes_without_birth_time .\n.\n.It Sy l2arc_feed_again Ns = Ns Sy 1 Ns | Ns 0 Pq int\nTurbo L2ARC warm-up.\nWhen the L2ARC is cold the fill interval will be set as fast as possible.\n.\n.It Sy l2arc_feed_min_ms Ns = Ns Sy 200 Pq u64\nMin feed interval in milliseconds.\nRequires\n.Sy l2arc_feed_again Ns = Ns Ar 1\nand only applicable in related situations.\n.\n.It Sy l2arc_feed_secs Ns = Ns Sy 1 Pq u64\nSeconds between L2ARC writing.\n.\n.It Sy l2arc_headroom Ns = Ns Sy 2 Pq u64\nHow far through the ARC lists to search for L2ARC cacheable content,\nexpressed as a multiplier of\n.Sy l2arc_write_max .\nARC persistence across reboots can be achieved with persistent L2ARC\nby setting this parameter to\n.Sy 0 ,\nallowing the full length of ARC lists to be searched for cacheable content.\n.\n.It Sy l2arc_headroom_boost Ns = Ns Sy 200 Ns % Pq u64\nScales\n.Sy l2arc_headroom\nby this percentage when L2ARC contents are being successfully compressed\nbefore writing.\nA value of\n.Sy 100\ndisables this feature.\n.\n.It Sy l2arc_exclude_special Ns = Ns Sy 0 Ns | Ns 1 Pq int\nControls whether buffers present on special vdevs are eligible for caching\ninto L2ARC.\nIf set to 1, exclude dbufs on special vdevs from being cached to L2ARC.\n.\n.It Sy l2arc_mfuonly Ns = Ns Sy 0 Ns | Ns 1 Pq  int\nControls whether only MFU metadata and data are cached from ARC into L2ARC.\nThis may be desired to avoid wasting space on L2ARC when reading/writing large\namounts of data that are not expected to be accessed more than once.\n.Pp\nThe default is off,\nmeaning both MRU and MFU data and metadata are cached.\nWhen turning off this feature, some MRU buffers will still be present\nin ARC and eventually cached on L2ARC.\n.No If Sy l2arc_noprefetch Ns = Ns Sy 0 ,\nsome prefetched buffers will be cached to L2ARC, and those might later\ntransition to MRU, in which case the\n.Sy l2arc_mru_asize No arcstat will not be Sy 0 .\n.Pp\nRegardless of\n.Sy l2arc_noprefetch ,\nsome MFU buffers might be evicted from ARC,\naccessed later on as prefetches and transition to MRU as prefetches.\nIf accessed again they are counted as MRU and the\n.Sy l2arc_mru_asize No arcstat will not be Sy 0 .\n.Pp\nThe ARC status of L2ARC buffers when they were first cached in\nL2ARC can be seen in the\n.Sy l2arc_mru_asize , Sy l2arc_mfu_asize , No and Sy l2arc_prefetch_asize\narcstats when importing the pool or onlining a cache\ndevice if persistent L2ARC is enabled.\n.Pp\nThe\n.Sy evict_l2_eligible_mru\narcstat does not take into account if this option is enabled as the information\nprovided by the\n.Sy evict_l2_eligible_m[rf]u\narcstats can be used to decide if toggling this option is appropriate\nfor the current workload.\n.\n.It Sy l2arc_meta_percent Ns = Ns Sy 33 Ns % Pq uint\nPercent of ARC size allowed for L2ARC-only headers.\nSince L2ARC buffers are not evicted on memory pressure,\ntoo many headers on a system with an irrationally large L2ARC\ncan render it slow or unusable.\nThis parameter limits L2ARC writes and rebuilds to achieve the target.\n.\n.It Sy l2arc_trim_ahead Ns = Ns Sy 0 Ns % Pq u64\nTrims ahead of the current write size\n.Pq Sy l2arc_write_max\non L2ARC devices by this percentage of write size if we have filled the device.\nIf set to\n.Sy 100\nwe TRIM twice the space required to accommodate upcoming writes.\nA minimum of\n.Sy 64 MiB\nwill be trimmed.\nIt also enables TRIM of the whole L2ARC device upon creation\nor addition to an existing pool or if the header of the device is\ninvalid upon importing a pool or onlining a cache device.\nA value of\n.Sy 0\ndisables TRIM on L2ARC altogether and is the default as it can put significant\nstress on the underlying storage devices.\nThis will vary depending of how well the specific device handles these commands.\n.\n.It Sy l2arc_noprefetch Ns = Ns Sy 1 Ns | Ns 0 Pq int\nDo not write buffers to L2ARC if they were prefetched but not used by\napplications.\nIn case there are prefetched buffers in L2ARC and this option\nis later set, we do not read the prefetched buffers from L2ARC.\nUnsetting this option is useful for caching sequential reads from the\ndisks to L2ARC and serve those reads from L2ARC later on.\nThis may be beneficial in case the L2ARC device is significantly faster\nin sequential reads than the disks of the pool.\n.Pp\nUse\n.Sy 1\nto disable and\n.Sy 0\nto enable caching/reading prefetches to/from L2ARC.\n.\n.It Sy l2arc_norw Ns = Ns Sy 0 Ns | Ns 1 Pq int\nNo reads during writes.\n.\n.It Sy l2arc_write_boost Ns = Ns Sy 8388608 Ns B Po 8 MiB Pc Pq u64\nCold L2ARC devices will have\n.Sy l2arc_write_max\nincreased by this amount while they remain cold.\n.\n.It Sy l2arc_write_max Ns = Ns Sy 8388608 Ns B Po 8 MiB Pc Pq u64\nMax write bytes per interval.\n.\n.It Sy l2arc_rebuild_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nRebuild the L2ARC when importing a pool (persistent L2ARC).\nThis can be disabled if there are problems importing a pool\nor attaching an L2ARC device (e.g. the L2ARC device is slow\nin reading stored log metadata, or the metadata\nhas become somehow fragmented/unusable).\n.\n.It Sy l2arc_rebuild_blocks_min_l2size Ns = Ns Sy 1073741824 Ns B Po 1 GiB Pc Pq u64\nMininum size of an L2ARC device required in order to write log blocks in it.\nThe log blocks are used upon importing the pool to rebuild the persistent L2ARC.\n.Pp\nFor L2ARC devices less than 1 GiB, the amount of data\n.Fn l2arc_evict\nevicts is significant compared to the amount of restored L2ARC data.\nIn this case, do not write log blocks in L2ARC in order not to waste space.\n.\n.It Sy metaslab_aliquot Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq u64\nMetaslab granularity, in bytes.\nThis is roughly similar to what would be referred to as the \"stripe size\"\nin traditional RAID arrays.\nIn normal operation, ZFS will try to write this amount of data to each disk\nbefore moving on to the next top-level vdev.\n.\n.It Sy metaslab_bias_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable metaslab group biasing based on their vdevs' over- or under-utilization\nrelative to the pool.\n.\n.It Sy metaslab_force_ganging Ns = Ns Sy 16777217 Ns B Po 16 MiB + 1 B Pc Pq u64\nMake some blocks above a certain size be gang blocks.\nThis option is used by the test suite to facilitate testing.\n.\n.It Sy metaslab_force_ganging_pct Ns = Ns Sy 3 Ns % Pq uint\nFor blocks that could be forced to be a gang block (due to\n.Sy metaslab_force_ganging ) ,\nforce this many of them to be gang blocks.\n.\n.It Sy zfs_ddt_zap_default_bs Ns = Ns Sy 15 Po 32 KiB Pc Pq int\nDefault DDT ZAP data block size as a power of 2. Note that changing this after\ncreating a DDT on the pool will not affect existing DDTs, only newly created\nones.\n.\n.It Sy zfs_ddt_zap_default_ibs Ns = Ns Sy 15 Po 32 KiB Pc Pq int\nDefault DDT ZAP indirect block size as a power of 2. Note that changing this\nafter creating a DDT on the pool will not affect existing DDTs, only newly\ncreated ones.\n.\n.It Sy zfs_default_bs Ns = Ns Sy 9 Po 512 B Pc Pq int\nDefault dnode block size as a power of 2.\n.\n.It Sy zfs_default_ibs Ns = Ns Sy 17 Po 128 KiB Pc Pq int\nDefault dnode indirect block size as a power of 2.\n.\n.It Sy zfs_history_output_max Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq u64\nWhen attempting to log an output nvlist of an ioctl in the on-disk history,\nthe output will not be stored if it is larger than this size (in bytes).\nThis must be less than\n.Sy DMU_MAX_ACCESS Pq 64 MiB .\nThis applies primarily to\n.Fn zfs_ioc_channel_program Pq cf. Xr zfs-program 8 .\n.\n.It Sy zfs_keep_log_spacemaps_at_export Ns = Ns Sy 0 Ns | Ns 1 Pq int\nPrevent log spacemaps from being destroyed during pool exports and destroys.\n.\n.It Sy zfs_metaslab_segment_weight_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable/disable segment-based metaslab selection.\n.\n.It Sy zfs_metaslab_switch_threshold Ns = Ns Sy 2 Pq int\nWhen using segment-based metaslab selection, continue allocating\nfrom the active metaslab until this option's\nworth of buckets have been exhausted.\n.\n.It Sy metaslab_debug_load Ns = Ns Sy 0 Ns | Ns 1 Pq int\nLoad all metaslabs during pool import.\n.\n.It Sy metaslab_debug_unload Ns = Ns Sy 0 Ns | Ns 1 Pq int\nPrevent metaslabs from being unloaded.\n.\n.It Sy metaslab_fragmentation_factor_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable use of the fragmentation metric in computing metaslab weights.\n.\n.It Sy metaslab_df_max_search Ns = Ns Sy 16777216 Ns B Po 16 MiB Pc Pq uint\nMaximum distance to search forward from the last offset.\nWithout this limit, fragmented pools can see\n.Em >100`000\niterations and\n.Fn metaslab_block_picker\nbecomes the performance limiting factor on high-performance storage.\n.Pp\nWith the default setting of\n.Sy 16 MiB ,\nwe typically see less than\n.Em 500\niterations, even with very fragmented\n.Sy ashift Ns = Ns Sy 9\npools.\nThe maximum number of iterations possible is\n.Sy metaslab_df_max_search / 2^(ashift+1) .\nWith the default setting of\n.Sy 16 MiB\nthis is\n.Em 16*1024 Pq with Sy ashift Ns = Ns Sy 9\nor\n.Em 2*1024 Pq with Sy ashift Ns = Ns Sy 12 .\n.\n.It Sy metaslab_df_use_largest_segment Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIf not searching forward (due to\n.Sy metaslab_df_max_search , metaslab_df_free_pct ,\n.No or Sy metaslab_df_alloc_threshold ) ,\nthis tunable controls which segment is used.\nIf set, we will use the largest free segment.\nIf unset, we will use a segment of at least the requested size.\n.\n.It Sy zfs_metaslab_max_size_cache_sec Ns = Ns Sy 3600 Ns s Po 1 hour Pc Pq u64\nWhen we unload a metaslab, we cache the size of the largest free chunk.\nWe use that cached size to determine whether or not to load a metaslab\nfor a given allocation.\nAs more frees accumulate in that metaslab while it's unloaded,\nthe cached max size becomes less and less accurate.\nAfter a number of seconds controlled by this tunable,\nwe stop considering the cached max size and start\nconsidering only the histogram instead.\n.\n.It Sy zfs_metaslab_mem_limit Ns = Ns Sy 25 Ns % Pq uint\nWhen we are loading a new metaslab, we check the amount of memory being used\nto store metaslab range trees.\nIf it is over a threshold, we attempt to unload the least recently used metaslab\nto prevent the system from clogging all of its memory with range trees.\nThis tunable sets the percentage of total system memory that is the threshold.\n.\n.It Sy zfs_metaslab_try_hard_before_gang Ns = Ns Sy 0 Ns | Ns 1 Pq int\n.Bl -item -compact\n.It\nIf unset, we will first try normal allocation.\n.It\nIf that fails then we will do a gang allocation.\n.It\nIf that fails then we will do a \"try hard\" gang allocation.\n.It\nIf that fails then we will have a multi-layer gang block.\n.El\n.Pp\n.Bl -item -compact\n.It\nIf set, we will first try normal allocation.\n.It\nIf that fails then we will do a \"try hard\" allocation.\n.It\nIf that fails we will do a gang allocation.\n.It\nIf that fails we will do a \"try hard\" gang allocation.\n.It\nIf that fails then we will have a multi-layer gang block.\n.El\n.\n.It Sy zfs_metaslab_find_max_tries Ns = Ns Sy 100 Pq uint\nWhen not trying hard, we only consider this number of the best metaslabs.\nThis improves performance, especially when there are many metaslabs per vdev\nand the allocation can't actually be satisfied\n(so we would otherwise iterate all metaslabs).\n.\n.It Sy zfs_vdev_default_ms_count Ns = Ns Sy 200 Pq uint\nWhen a vdev is added, target this number of metaslabs per top-level vdev.\n.\n.It Sy zfs_vdev_default_ms_shift Ns = Ns Sy 29 Po 512 MiB Pc Pq uint\nDefault lower limit for metaslab size.\n.\n.It Sy zfs_vdev_max_ms_shift Ns = Ns Sy 34 Po 16 GiB Pc Pq uint\nDefault upper limit for metaslab size.\n.\n.It Sy zfs_vdev_max_auto_ashift Ns = Ns Sy 14 Pq uint\nMaximum ashift used when optimizing for logical \\[->] physical sector size on\nnew\ntop-level vdevs.\nMay be increased up to\n.Sy ASHIFT_MAX Po 16 Pc ,\nbut this may negatively impact pool space efficiency.\n.\n.It Sy zfs_vdev_min_auto_ashift Ns = Ns Sy ASHIFT_MIN Po 9 Pc Pq uint\nMinimum ashift used when creating new top-level vdevs.\n.\n.It Sy zfs_vdev_min_ms_count Ns = Ns Sy 16 Pq uint\nMinimum number of metaslabs to create in a top-level vdev.\n.\n.It Sy vdev_validate_skip Ns = Ns Sy 0 Ns | Ns 1 Pq int\nSkip label validation steps during pool import.\nChanging is not recommended unless you know what you're doing\nand are recovering a damaged label.\n.\n.It Sy zfs_vdev_ms_count_limit Ns = Ns Sy 131072 Po 128k Pc Pq uint\nPractical upper limit of total metaslabs per top-level vdev.\n.\n.It Sy metaslab_preload_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable metaslab group preloading.\n.\n.It Sy metaslab_preload_limit Ns = Ns Sy 10 Pq uint\nMaximum number of metaslabs per group to preload\n.\n.It Sy metaslab_preload_pct Ns = Ns Sy 50 Pq uint\nPercentage of CPUs to run a metaslab preload taskq\n.\n.It Sy metaslab_lba_weighting_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nGive more weight to metaslabs with lower LBAs,\nassuming they have greater bandwidth,\nas is typically the case on a modern constant angular velocity disk drive.\n.\n.It Sy metaslab_unload_delay Ns = Ns Sy 32 Pq uint\nAfter a metaslab is used, we keep it loaded for this many TXGs, to attempt to\nreduce unnecessary reloading.\nNote that both this many TXGs and\n.Sy metaslab_unload_delay_ms\nmilliseconds must pass before unloading will occur.\n.\n.It Sy metaslab_unload_delay_ms Ns = Ns Sy 600000 Ns ms Po 10 min Pc Pq uint\nAfter a metaslab is used, we keep it loaded for this many milliseconds,\nto attempt to reduce unnecessary reloading.\nNote, that both this many milliseconds and\n.Sy metaslab_unload_delay\nTXGs must pass before unloading will occur.\n.\n.It Sy reference_history Ns = Ns Sy 3 Pq uint\nMaximum reference holders being tracked when reference_tracking_enable is\nactive.\n.\n.It Sy reference_tracking_enable Ns = Ns Sy 0 Ns | Ns 1 Pq int\nTrack reference holders to\n.Sy refcount_t\nobjects (debug builds only).\n.\n.It Sy send_holes_without_birth_time Ns = Ns Sy 1 Ns | Ns 0 Pq int\nWhen set, the\n.Sy hole_birth\noptimization will not be used, and all holes will always be sent during a\n.Nm zfs Cm send .\nThis is useful if you suspect your datasets are affected by a bug in\n.Sy hole_birth .\n.\n.It Sy spa_config_path Ns = Ns Pa /etc/zfs/zpool.cache Pq charp\nSPA config file.\n.\n.It Sy spa_asize_inflation Ns = Ns Sy 24 Pq uint\nMultiplication factor used to estimate actual disk consumption from the\nsize of data being written.\nThe default value is a worst case estimate,\nbut lower values may be valid for a given pool depending on its configuration.\nPool administrators who understand the factors involved\nmay wish to specify a more realistic inflation factor,\nparticularly if they operate close to quota or capacity limits.\n.\n.It Sy spa_load_print_vdev_tree Ns = Ns Sy 0 Ns | Ns 1 Pq int\nWhether to print the vdev tree in the debugging message buffer during pool\nimport.\n.\n.It Sy spa_load_verify_data Ns = Ns Sy 1 Ns | Ns 0 Pq int\nWhether to traverse data blocks during an \"extreme rewind\"\n.Pq Fl X\nimport.\n.Pp\nAn extreme rewind import normally performs a full traversal of all\nblocks in the pool for verification.\nIf this parameter is unset, the traversal skips non-metadata blocks.\nIt can be toggled once the\nimport has started to stop or start the traversal of non-metadata blocks.\n.\n.It Sy spa_load_verify_metadata  Ns = Ns Sy 1 Ns | Ns 0 Pq int\nWhether to traverse blocks during an \"extreme rewind\"\n.Pq Fl X\npool import.\n.Pp\nAn extreme rewind import normally performs a full traversal of all\nblocks in the pool for verification.\nIf this parameter is unset, the traversal is not performed.\nIt can be toggled once the import has started to stop or start the traversal.\n.\n.It Sy spa_load_verify_shift Ns = Ns Sy 4 Po 1/16th Pc Pq uint\nSets the maximum number of bytes to consume during pool import to the log2\nfraction of the target ARC size.\n.\n.It Sy spa_slop_shift Ns = Ns Sy 5 Po 1/32nd Pc Pq int\nNormally, we don't allow the last\n.Sy 3.2% Pq Sy 1/2^spa_slop_shift\nof space in the pool to be consumed.\nThis ensures that we don't run the pool completely out of space,\ndue to unaccounted changes (e.g. to the MOS).\nIt also limits the worst-case time to allocate space.\nIf we have less than this amount of free space,\nmost ZPL operations (e.g. write, create) will return\n.Sy ENOSPC .\n.\n.It Sy spa_upgrade_errlog_limit Ns = Ns Sy 0 Pq uint\nLimits the number of on-disk error log entries that will be converted to the\nnew format when enabling the\n.Sy head_errlog\nfeature.\nThe default is to convert all log entries.\n.\n.It Sy vdev_removal_max_span Ns = Ns Sy 32768 Ns B Po 32 KiB Pc Pq uint\nDuring top-level vdev removal, chunks of data are copied from the vdev\nwhich may include free space in order to trade bandwidth for IOPS.\nThis parameter determines the maximum span of free space, in bytes,\nwhich will be included as \"unnecessary\" data in a chunk of copied data.\n.Pp\nThe default value here was chosen to align with\n.Sy zfs_vdev_read_gap_limit ,\nwhich is a similar concept when doing\nregular reads (but there's no reason it has to be the same).\n.\n.It Sy vdev_file_logical_ashift Ns = Ns Sy 9 Po 512 B Pc Pq u64\nLogical ashift for file-based devices.\n.\n.It Sy vdev_file_physical_ashift Ns = Ns Sy 9 Po 512 B Pc Pq u64\nPhysical ashift for file-based devices.\n.\n.It Sy zap_iterate_prefetch Ns = Ns Sy 1 Ns | Ns 0 Pq int\nIf set, when we start iterating over a ZAP object,\nprefetch the entire object (all leaf blocks).\nHowever, this is limited by\n.Sy dmu_prefetch_max .\n.\n.It Sy zap_micro_max_size Ns = Ns Sy 131072 Ns B Po 128 KiB Pc Pq int\nMaximum micro ZAP size.\nA micro ZAP is upgraded to a fat ZAP, once it grows beyond the specified size.\n.\n.It Sy zfetch_min_distance Ns = Ns Sy 4194304 Ns B Po 4 MiB Pc Pq uint\nMin bytes to prefetch per stream.\nPrefetch distance starts from the demand access size and quickly grows to\nthis value, doubling on each hit.\nAfter that it may grow further by 1/8 per hit, but only if some prefetch\nsince last time haven't completed in time to satisfy demand request, i.e.\nprefetch depth didn't cover the read latency or the pool got saturated.\n.\n.It Sy zfetch_max_distance Ns = Ns Sy 67108864 Ns B Po 64 MiB Pc Pq uint\nMax bytes to prefetch per stream.\n.\n.It Sy zfetch_max_idistance Ns = Ns Sy 67108864 Ns B Po 64 MiB Pc Pq uint\nMax bytes to prefetch indirects for per stream.\n.\n.It Sy zfetch_max_streams Ns = Ns Sy 8 Pq uint\nMax number of streams per zfetch (prefetch streams per file).\n.\n.It Sy zfetch_min_sec_reap Ns = Ns Sy 1 Pq uint\nMin time before inactive prefetch stream can be reclaimed\n.\n.It Sy zfetch_max_sec_reap Ns = Ns Sy 2 Pq uint\nMax time before inactive prefetch stream can be deleted\n.\n.It Sy zfs_abd_scatter_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnables ARC from using scatter/gather lists and forces all allocations to be\nlinear in kernel memory.\nDisabling can improve performance in some code paths\nat the expense of fragmented kernel memory.\n.\n.It Sy zfs_abd_scatter_max_order Ns = Ns Sy MAX_ORDER\\-1 Pq uint\nMaximum number of consecutive memory pages allocated in a single block for\nscatter/gather lists.\n.Pp\nThe value of\n.Sy MAX_ORDER\ndepends on kernel configuration.\n.\n.It Sy zfs_abd_scatter_min_size Ns = Ns Sy 1536 Ns B Po 1.5 KiB Pc Pq uint\nThis is the minimum allocation size that will use scatter (page-based) ABDs.\nSmaller allocations will use linear ABDs.\n.\n.It Sy zfs_arc_dnode_limit Ns = Ns Sy 0 Ns B Pq u64\nWhen the number of bytes consumed by dnodes in the ARC exceeds this number of\nbytes, try to unpin some of it in response to demand for non-metadata.\nThis value acts as a ceiling to the amount of dnode metadata, and defaults to\n.Sy 0 ,\nwhich indicates that a percent which is based on\n.Sy zfs_arc_dnode_limit_percent\nof the ARC meta buffers that may be used for dnodes.\n.It Sy zfs_arc_dnode_limit_percent Ns = Ns Sy 10 Ns % Pq u64\nPercentage that can be consumed by dnodes of ARC meta buffers.\n.Pp\nSee also\n.Sy zfs_arc_dnode_limit ,\nwhich serves a similar purpose but has a higher priority if nonzero.\n.\n.It Sy zfs_arc_dnode_reduce_percent Ns = Ns Sy 10 Ns % Pq u64\nPercentage of ARC dnodes to try to scan in response to demand for non-metadata\nwhen the number of bytes consumed by dnodes exceeds\n.Sy zfs_arc_dnode_limit .\n.\n.It Sy zfs_arc_average_blocksize Ns = Ns Sy 8192 Ns B Po 8 KiB Pc Pq uint\nThe ARC's buffer hash table is sized based on the assumption of an average\nblock size of this value.\nThis works out to roughly 1 MiB of hash table per 1 GiB of physical memory\nwith 8-byte pointers.\nFor configurations with a known larger average block size,\nthis value can be increased to reduce the memory footprint.\n.\n.It Sy zfs_arc_eviction_pct Ns = Ns Sy 200 Ns % Pq uint\nWhen\n.Fn arc_is_overflowing ,\n.Fn arc_get_data_impl\nwaits for this percent of the requested amount of data to be evicted.\nFor example, by default, for every\n.Em 2 KiB\nthat's evicted,\n.Em 1 KiB\nof it may be \"reused\" by a new allocation.\nSince this is above\n.Sy 100 Ns % ,\nit ensures that progress is made towards getting\n.Sy arc_size No under Sy arc_c .\nSince this is finite, it ensures that allocations can still happen,\neven during the potentially long time that\n.Sy arc_size No is more than Sy arc_c .\n.\n.It Sy zfs_arc_evict_batch_limit Ns = Ns Sy 10 Pq uint\nNumber ARC headers to evict per sub-list before proceeding to another sub-list.\nThis batch-style operation prevents entire sub-lists from being evicted at once\nbut comes at a cost of additional unlocking and locking.\n.\n.It Sy zfs_arc_grow_retry Ns = Ns Sy 0 Ns s Pq uint\nIf set to a non zero value, it will replace the\n.Sy arc_grow_retry\nvalue with this value.\nThe\n.Sy arc_grow_retry\n.No value Pq default Sy 5 Ns s\nis the number of seconds the ARC will wait before\ntrying to resume growth after a memory pressure event.\n.\n.It Sy zfs_arc_lotsfree_percent Ns = Ns Sy 10 Ns % Pq int\nThrottle I/O when free system memory drops below this percentage of total\nsystem memory.\nSetting this value to\n.Sy 0\nwill disable the throttle.\n.\n.It Sy zfs_arc_max Ns = Ns Sy 0 Ns B Pq u64\nMax size of ARC in bytes.\nIf\n.Sy 0 ,\nthen the max size of ARC is determined by the amount of system memory installed.\nUnder Linux, half of system memory will be used as the limit.\nUnder\n.Fx ,\nthe larger of\n.Sy all_system_memory No \\- Sy 1 GiB\nand\n.Sy 5/8 No \\(mu Sy all_system_memory\nwill be used as the limit.\nThis value must be at least\n.Sy 67108864 Ns B Pq 64 MiB .\n.Pp\nThis value can be changed dynamically, with some caveats.\nIt cannot be set back to\n.Sy 0\nwhile running, and reducing it below the current ARC size will not cause\nthe ARC to shrink without memory pressure to induce shrinking.\n.\n.It Sy zfs_arc_meta_balance Ns = Ns Sy 500 Pq uint\nBalance between metadata and data on ghost hits.\nValues above 100 increase metadata caching by proportionally reducing effect\nof ghost data hits on target data/metadata rate.\n.\n.It Sy zfs_arc_min Ns = Ns Sy 0 Ns B Pq u64\nMin size of ARC in bytes.\n.No If set to Sy 0 , arc_c_min\nwill default to consuming the larger of\n.Sy 32 MiB\nand\n.Sy all_system_memory No / Sy 32 .\n.\n.It Sy zfs_arc_min_prefetch_ms Ns = Ns Sy 0 Ns ms Ns Po Ns \u2261 Ns 1s Pc Pq uint\nMinimum time prefetched blocks are locked in the ARC.\n.\n.It Sy zfs_arc_min_prescient_prefetch_ms Ns = Ns Sy 0 Ns ms Ns Po Ns \u2261 Ns 6s Pc Pq uint\nMinimum time \"prescient prefetched\" blocks are locked in the ARC.\nThese blocks are meant to be prefetched fairly aggressively ahead of\nthe code that may use them.\n.\n.It Sy zfs_arc_prune_task_threads Ns = Ns Sy 1 Pq int\nNumber of arc_prune threads.\n.Fx\ndoes not need more than one.\nLinux may theoretically use one per mount point up to number of CPUs,\nbut that was not proven to be useful.\n.\n.It Sy zfs_max_missing_tvds Ns = Ns Sy 0 Pq int\nNumber of missing top-level vdevs which will be allowed during\npool import (only in read-only mode).\n.\n.It Sy zfs_max_nvlist_src_size Ns = Sy 0 Pq u64\nMaximum size in bytes allowed to be passed as\n.Sy zc_nvlist_src_size\nfor ioctls on\n.Pa /dev/zfs .\nThis prevents a user from causing the kernel to allocate\nan excessive amount of memory.\nWhen the limit is exceeded, the ioctl fails with\n.Sy EINVAL\nand a description of the error is sent to the\n.Pa zfs-dbgmsg\nlog.\nThis parameter should not need to be touched under normal circumstances.\nIf\n.Sy 0 ,\nequivalent to a quarter of the user-wired memory limit under\n.Fx\nand to\n.Sy 134217728 Ns B Pq 128 MiB\nunder Linux.\n.\n.It Sy zfs_multilist_num_sublists Ns = Ns Sy 0 Pq uint\nTo allow more fine-grained locking, each ARC state contains a series\nof lists for both data and metadata objects.\nLocking is performed at the level of these \"sub-lists\".\nThis parameters controls the number of sub-lists per ARC state,\nand also applies to other uses of the multilist data structure.\n.Pp\nIf\n.Sy 0 ,\nequivalent to the greater of the number of online CPUs and\n.Sy 4 .\n.\n.It Sy zfs_arc_overflow_shift Ns = Ns Sy 8 Pq int\nThe ARC size is considered to be overflowing if it exceeds the current\nARC target size\n.Pq Sy arc_c\nby thresholds determined by this parameter.\nExceeding by\n.Sy ( arc_c No >> Sy zfs_arc_overflow_shift ) No / Sy 2\nstarts ARC reclamation process.\nIf that appears insufficient, exceeding by\n.Sy ( arc_c No >> Sy zfs_arc_overflow_shift ) No \\(mu Sy 1.5\nblocks new buffer allocation until the reclaim thread catches up.\nStarted reclamation process continues till ARC size returns below the\ntarget size.\n.Pp\nThe default value of\n.Sy 8\ncauses the ARC to start reclamation if it exceeds the target size by\n.Em 0.2%\nof the target size, and block allocations by\n.Em 0.6% .\n.\n.It Sy zfs_arc_shrink_shift Ns = Ns Sy 0 Pq uint\nIf nonzero, this will update\n.Sy arc_shrink_shift Pq default Sy 7\nwith the new value.\n.\n.It Sy zfs_arc_pc_percent Ns = Ns Sy 0 Ns % Po off Pc Pq uint\nPercent of pagecache to reclaim ARC to.\n.Pp\nThis tunable allows the ZFS ARC to play more nicely\nwith the kernel's LRU pagecache.\nIt can guarantee that the ARC size won't collapse under scanning\npressure on the pagecache, yet still allows the ARC to be reclaimed down to\n.Sy zfs_arc_min\nif necessary.\nThis value is specified as percent of pagecache size (as measured by\n.Sy NR_FILE_PAGES ) ,\nwhere that percent may exceed\n.Sy 100 .\nThis\nonly operates during memory pressure/reclaim.\n.\n.It Sy zfs_arc_shrinker_limit Ns = Ns Sy 10000 Pq int\nThis is a limit on how many pages the ARC shrinker makes available for\neviction in response to one page allocation attempt.\nNote that in practice, the kernel's shrinker can ask us to evict\nup to about four times this for one allocation attempt.\n.Pp\nThe default limit of\n.Sy 10000 Pq in practice, Em 160 MiB No per allocation attempt with 4 KiB pages\nlimits the amount of time spent attempting to reclaim ARC memory to\nless than 100 ms per allocation attempt,\neven with a small average compressed block size of ~8 KiB.\n.Pp\nThe parameter can be set to 0 (zero) to disable the limit,\nand only applies on Linux.\n.\n.It Sy zfs_arc_sys_free Ns = Ns Sy 0 Ns B Pq u64\nThe target number of bytes the ARC should leave as free memory on the system.\nIf zero, equivalent to the bigger of\n.Sy 512 KiB No and Sy all_system_memory/64 .\n.\n.It Sy zfs_autoimport_disable Ns = Ns Sy 1 Ns | Ns 0 Pq int\nDisable pool import at module load by ignoring the cache file\n.Pq Sy spa_config_path .\n.\n.It Sy zfs_checksum_events_per_second Ns = Ns Sy 20 Ns /s Pq uint\nRate limit checksum events to this many per second.\nNote that this should not be set below the ZED thresholds\n(currently 10 checksums over 10 seconds)\nor else the daemon may not trigger any action.\n.\n.It Sy zfs_commit_timeout_pct Ns = Ns Sy 5 Ns % Pq uint\nThis controls the amount of time that a ZIL block (lwb) will remain \"open\"\nwhen it isn't \"full\", and it has a thread waiting for it to be committed to\nstable storage.\nThe timeout is scaled based on a percentage of the last lwb\nlatency to avoid significantly impacting the latency of each individual\ntransaction record (itx).\n.\n.It Sy zfs_condense_indirect_commit_entry_delay_ms Ns = Ns Sy 0 Ns ms Pq int\nVdev indirection layer (used for device removal) sleeps for this many\nmilliseconds during mapping generation.\nIntended for use with the test suite to throttle vdev removal speed.\n.\n.It Sy zfs_condense_indirect_obsolete_pct Ns = Ns Sy 25 Ns % Pq uint\nMinimum percent of obsolete bytes in vdev mapping required to attempt to\ncondense\n.Pq see Sy zfs_condense_indirect_vdevs_enable .\nIntended for use with the test suite\nto facilitate triggering condensing as needed.\n.\n.It Sy zfs_condense_indirect_vdevs_enable Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable condensing indirect vdev mappings.\nWhen set, attempt to condense indirect vdev mappings\nif the mapping uses more than\n.Sy zfs_condense_min_mapping_bytes\nbytes of memory and if the obsolete space map object uses more than\n.Sy zfs_condense_max_obsolete_bytes\nbytes on-disk.\nThe condensing process is an attempt to save memory by removing obsolete\nmappings.\n.\n.It Sy zfs_condense_max_obsolete_bytes Ns = Ns Sy 1073741824 Ns B Po 1 GiB Pc Pq u64\nOnly attempt to condense indirect vdev mappings if the on-disk size\nof the obsolete space map object is greater than this number of bytes\n.Pq see Sy zfs_condense_indirect_vdevs_enable .\n.\n.It Sy zfs_condense_min_mapping_bytes Ns = Ns Sy 131072 Ns B Po 128 KiB Pc Pq u64\nMinimum size vdev mapping to attempt to condense\n.Pq see Sy zfs_condense_indirect_vdevs_enable .\n.\n.It Sy zfs_dbgmsg_enable Ns = Ns Sy 1 Ns | Ns 0 Pq int\nInternally ZFS keeps a small log to facilitate debugging.\nThe log is enabled by default, and can be disabled by unsetting this option.\nThe contents of the log can be accessed by reading\n.Pa /proc/spl/kstat/zfs/dbgmsg .\nWriting\n.Sy 0\nto the file clears the log.\n.Pp\nThis setting does not influence debug prints due to\n.Sy zfs_flags .\n.\n.It Sy zfs_dbgmsg_maxsize Ns = Ns Sy 4194304 Ns B Po 4 MiB Pc Pq uint\nMaximum size of the internal ZFS debug log.\n.\n.It Sy zfs_dbuf_state_index Ns = Ns Sy 0 Pq int\nHistorically used for controlling what reporting was available under\n.Pa /proc/spl/kstat/zfs .\nNo effect.\n.\n.It Sy zfs_deadman_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nWhen a pool sync operation takes longer than\n.Sy zfs_deadman_synctime_ms ,\nor when an individual I/O operation takes longer than\n.Sy zfs_deadman_ziotime_ms ,\nthen the operation is considered to be \"hung\".\nIf\n.Sy zfs_deadman_enabled\nis set, then the deadman behavior is invoked as described by\n.Sy zfs_deadman_failmode .\nBy default, the deadman is enabled and set to\n.Sy wait\nwhich results in \"hung\" I/O operations only being logged.\nThe deadman is automatically disabled when a pool gets suspended.\n.\n.It Sy zfs_deadman_failmode Ns = Ns Sy wait Pq charp\nControls the failure behavior when the deadman detects a \"hung\" I/O operation.\nValid values are:\n.Bl -tag -compact -offset 4n -width \"continue\"\n.It Sy wait\nWait for a \"hung\" operation to complete.\nFor each \"hung\" operation a \"deadman\" event will be posted\ndescribing that operation.\n.It Sy continue\nAttempt to recover from a \"hung\" operation by re-dispatching it\nto the I/O pipeline if possible.\n.It Sy panic\nPanic the system.\nThis can be used to facilitate automatic fail-over\nto a properly configured fail-over partner.\n.El\n.\n.It Sy zfs_deadman_checktime_ms Ns = Ns Sy 60000 Ns ms Po 1 min Pc Pq u64\nCheck time in milliseconds.\nThis defines the frequency at which we check for hung I/O requests\nand potentially invoke the\n.Sy zfs_deadman_failmode\nbehavior.\n.\n.It Sy zfs_deadman_synctime_ms Ns = Ns Sy 600000 Ns ms Po 10 min Pc Pq u64\nInterval in milliseconds after which the deadman is triggered and also\nthe interval after which a pool sync operation is considered to be \"hung\".\nOnce this limit is exceeded the deadman will be invoked every\n.Sy zfs_deadman_checktime_ms\nmilliseconds until the pool sync completes.\n.\n.It Sy zfs_deadman_ziotime_ms Ns = Ns Sy 300000 Ns ms Po 5 min Pc Pq u64\nInterval in milliseconds after which the deadman is triggered and an\nindividual I/O operation is considered to be \"hung\".\nAs long as the operation remains \"hung\",\nthe deadman will be invoked every\n.Sy zfs_deadman_checktime_ms\nmilliseconds until the operation completes.\n.\n.It Sy zfs_dedup_prefetch Ns = Ns Sy 0 Ns | Ns 1 Pq int\nEnable prefetching dedup-ed blocks which are going to be freed.\n.\n.It Sy zfs_delay_min_dirty_percent Ns = Ns Sy 60 Ns % Pq uint\nStart to delay each transaction once there is this amount of dirty data,\nexpressed as a percentage of\n.Sy zfs_dirty_data_max .\nThis value should be at least\n.Sy zfs_vdev_async_write_active_max_dirty_percent .\n.No See Sx ZFS TRANSACTION DELAY .\n.\n.It Sy zfs_delay_scale Ns = Ns Sy 500000 Pq int\nThis controls how quickly the transaction delay approaches infinity.\nLarger values cause longer delays for a given amount of dirty data.\n.Pp\nFor the smoothest delay, this value should be about 1 billion divided\nby the maximum number of operations per second.\nThis will smoothly handle between ten times and a tenth of this number.\n.No See Sx ZFS TRANSACTION DELAY .\n.Pp\n.Sy zfs_delay_scale No \\(mu Sy zfs_dirty_data_max Em must No be smaller than Sy 2^64 .\n.\n.It Sy zfs_disable_ivset_guid_check Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisables requirement for IVset GUIDs to be present and match when doing a raw\nreceive of encrypted datasets.\nIntended for users whose pools were created with\nOpenZFS pre-release versions and now have compatibility issues.\n.\n.It Sy zfs_key_max_salt_uses Ns = Ns Sy 400000000 Po 4*10^8 Pc Pq ulong\nMaximum number of uses of a single salt value before generating a new one for\nencrypted datasets.\nThe default value is also the maximum.\n.\n.It Sy zfs_object_mutex_size Ns = Ns Sy 64 Pq uint\nSize of the znode hashtable used for holds.\n.Pp\nDue to the need to hold locks on objects that may not exist yet, kernel mutexes\nare not created per-object and instead a hashtable is used where collisions\nwill result in objects waiting when there is not actually contention on the\nsame object.\n.\n.It Sy zfs_slow_io_events_per_second Ns = Ns Sy 20 Ns /s Pq int\nRate limit delay and deadman zevents (which report slow I/O operations) to this\nmany per\nsecond.\n.\n.It Sy zfs_unflushed_max_mem_amt Ns = Ns Sy 1073741824 Ns B Po 1 GiB Pc Pq u64\nUpper-bound limit for unflushed metadata changes to be held by the\nlog spacemap in memory, in bytes.\n.\n.It Sy zfs_unflushed_max_mem_ppm Ns = Ns Sy 1000 Ns ppm Po 0.1% Pc Pq u64\nPart of overall system memory that ZFS allows to be used\nfor unflushed metadata changes by the log spacemap, in millionths.\n.\n.It Sy zfs_unflushed_log_block_max Ns = Ns Sy 131072 Po 128k Pc Pq u64\nDescribes the maximum number of log spacemap blocks allowed for each pool.\nThe default value means that the space in all the log spacemaps\ncan add up to no more than\n.Sy 131072\nblocks (which means\n.Em 16 GiB\nof logical space before compression and ditto blocks,\nassuming that blocksize is\n.Em 128 KiB ) .\n.Pp\nThis tunable is important because it involves a trade-off between import\ntime after an unclean export and the frequency of flushing metaslabs.\nThe higher this number is, the more log blocks we allow when the pool is\nactive which means that we flush metaslabs less often and thus decrease\nthe number of I/O operations for spacemap updates per TXG.\nAt the same time though, that means that in the event of an unclean export,\nthere will be more log spacemap blocks for us to read, inducing overhead\nin the import time of the pool.\nThe lower the number, the amount of flushing increases, destroying log\nblocks quicker as they become obsolete faster, which leaves less blocks\nto be read during import time after a crash.\n.Pp\nEach log spacemap block existing during pool import leads to approximately\none extra logical I/O issued.\nThis is the reason why this tunable is exposed in terms of blocks rather\nthan space used.\n.\n.It Sy zfs_unflushed_log_block_min Ns = Ns Sy 1000 Pq u64\nIf the number of metaslabs is small and our incoming rate is high,\nwe could get into a situation that we are flushing all our metaslabs every TXG.\nThus we always allow at least this many log blocks.\n.\n.It Sy zfs_unflushed_log_block_pct Ns = Ns Sy 400 Ns % Pq u64\nTunable used to determine the number of blocks that can be used for\nthe spacemap log, expressed as a percentage of the total number of\nunflushed metaslabs in the pool.\n.\n.It Sy zfs_unflushed_log_txg_max Ns = Ns Sy 1000 Pq u64\nTunable limiting maximum time in TXGs any metaslab may remain unflushed.\nIt effectively limits maximum number of unflushed per-TXG spacemap logs\nthat need to be read after unclean pool export.\n.\n.It Sy zfs_unlink_suspend_progress Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nWhen enabled, files will not be asynchronously removed from the list of pending\nunlinks and the space they consume will be leaked.\nOnce this option has been disabled and the dataset is remounted,\nthe pending unlinks will be processed and the freed space returned to the pool.\nThis option is used by the test suite.\n.\n.It Sy zfs_delete_blocks Ns = Ns Sy 20480 Pq ulong\nThis is the used to define a large file for the purposes of deletion.\nFiles containing more than\n.Sy zfs_delete_blocks\nwill be deleted asynchronously, while smaller files are deleted synchronously.\nDecreasing this value will reduce the time spent in an\n.Xr unlink 2\nsystem call, at the expense of a longer delay before the freed space is\navailable.\nThis only applies on Linux.\n.\n.It Sy zfs_dirty_data_max Ns = Pq int\nDetermines the dirty space limit in bytes.\nOnce this limit is exceeded, new writes are halted until space frees up.\nThis parameter takes precedence over\n.Sy zfs_dirty_data_max_percent .\n.No See Sx ZFS TRANSACTION DELAY .\n.Pp\nDefaults to\n.Sy physical_ram/10 ,\ncapped at\n.Sy zfs_dirty_data_max_max .\n.\n.It Sy zfs_dirty_data_max_max Ns = Pq int\nMaximum allowable value of\n.Sy zfs_dirty_data_max ,\nexpressed in bytes.\nThis limit is only enforced at module load time, and will be ignored if\n.Sy zfs_dirty_data_max\nis later changed.\nThis parameter takes precedence over\n.Sy zfs_dirty_data_max_max_percent .\n.No See Sx ZFS TRANSACTION DELAY .\n.Pp\nDefaults to\n.Sy min(physical_ram/4, 4GiB) ,\nor\n.Sy min(physical_ram/4, 1GiB)\nfor 32-bit systems.\n.\n.It Sy zfs_dirty_data_max_max_percent Ns = Ns Sy 25 Ns % Pq uint\nMaximum allowable value of\n.Sy zfs_dirty_data_max ,\nexpressed as a percentage of physical RAM.\nThis limit is only enforced at module load time, and will be ignored if\n.Sy zfs_dirty_data_max\nis later changed.\nThe parameter\n.Sy zfs_dirty_data_max_max\ntakes precedence over this one.\n.No See Sx ZFS TRANSACTION DELAY .\n.\n.It Sy zfs_dirty_data_max_percent Ns = Ns Sy 10 Ns % Pq uint\nDetermines the dirty space limit, expressed as a percentage of all memory.\nOnce this limit is exceeded, new writes are halted until space frees up.\nThe parameter\n.Sy zfs_dirty_data_max\ntakes precedence over this one.\n.No See Sx ZFS TRANSACTION DELAY .\n.Pp\nSubject to\n.Sy zfs_dirty_data_max_max .\n.\n.It Sy zfs_dirty_data_sync_percent Ns = Ns Sy 20 Ns % Pq uint\nStart syncing out a transaction group if there's at least this much dirty data\n.Pq as a percentage of Sy zfs_dirty_data_max .\nThis should be less than\n.Sy zfs_vdev_async_write_active_min_dirty_percent .\n.\n.It Sy zfs_wrlog_data_max Ns = Pq int\nThe upper limit of write-transaction zil log data size in bytes.\nWrite operations are throttled when approaching the limit until log data is\ncleared out after transaction group sync.\nBecause of some overhead, it should be set at least 2 times the size of\n.Sy zfs_dirty_data_max\n.No to prevent harming normal write throughput .\nIt also should be smaller than the size of the slog device if slog is present.\n.Pp\nDefaults to\n.Sy zfs_dirty_data_max*2\n.\n.It Sy zfs_fallocate_reserve_percent Ns = Ns Sy 110 Ns % Pq uint\nSince ZFS is a copy-on-write filesystem with snapshots, blocks cannot be\npreallocated for a file in order to guarantee that later writes will not\nrun out of space.\nInstead,\n.Xr fallocate 2\nspace preallocation only checks that sufficient space is currently available\nin the pool or the user's project quota allocation,\nand then creates a sparse file of the requested size.\nThe requested space is multiplied by\n.Sy zfs_fallocate_reserve_percent\nto allow additional space for indirect blocks and other internal metadata.\nSetting this to\n.Sy 0\ndisables support for\n.Xr fallocate 2\nand causes it to return\n.Sy EOPNOTSUPP .\n.\n.It Sy zfs_fletcher_4_impl Ns = Ns Sy fastest Pq string\nSelect a fletcher 4 implementation.\n.Pp\nSupported selectors are:\n.Sy fastest , scalar , sse2 , ssse3 , avx2 , avx512f , avx512bw ,\n.No and Sy aarch64_neon .\nAll except\n.Sy fastest No and Sy scalar\nrequire instruction set extensions to be available,\nand will only appear if ZFS detects that they are present at runtime.\nIf multiple implementations of fletcher 4 are available, the\n.Sy fastest\nwill be chosen using a micro benchmark.\nSelecting\n.Sy scalar\nresults in the original CPU-based calculation being used.\nSelecting any option other than\n.Sy fastest No or Sy scalar\nresults in vector instructions\nfrom the respective CPU instruction set being used.\n.\n.It Sy zfs_bclone_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable the experimental block cloning feature.\nIf this setting is 0, then even if feature@block_cloning is enabled,\nattempts to clone blocks will act as though the feature is disabled.\n.\n.It Sy zfs_blake3_impl Ns = Ns Sy fastest Pq string\nSelect a BLAKE3 implementation.\n.Pp\nSupported selectors are:\n.Sy cycle , fastest , generic , sse2 , sse41 , avx2 , avx512 .\nAll except\n.Sy cycle , fastest No and Sy generic\nrequire instruction set extensions to be available,\nand will only appear if ZFS detects that they are present at runtime.\nIf multiple implementations of BLAKE3 are available, the\n.Sy fastest will be chosen using a micro benchmark. You can see the\nbenchmark results by reading this kstat file:\n.Pa /proc/spl/kstat/zfs/chksum_bench .\n.\n.It Sy zfs_free_bpobj_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable/disable the processing of the free_bpobj object.\n.\n.It Sy zfs_async_block_max_blocks Ns = Ns Sy UINT64_MAX Po unlimited Pc Pq u64\nMaximum number of blocks freed in a single TXG.\n.\n.It Sy zfs_max_async_dedup_frees Ns = Ns Sy 100000 Po 10^5 Pc Pq u64\nMaximum number of dedup blocks freed in a single TXG.\n.\n.It Sy zfs_vdev_async_read_max_active Ns = Ns Sy 3 Pq uint\nMaximum asynchronous read I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_async_read_min_active Ns = Ns Sy 1 Pq uint\nMinimum asynchronous read I/O operation active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_async_write_active_max_dirty_percent Ns = Ns Sy 60 Ns % Pq uint\nWhen the pool has more than this much dirty data, use\n.Sy zfs_vdev_async_write_max_active\nto limit active async writes.\nIf the dirty data is between the minimum and maximum,\nthe active I/O limit is linearly interpolated.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_async_write_active_min_dirty_percent Ns = Ns Sy 30 Ns % Pq uint\nWhen the pool has less than this much dirty data, use\n.Sy zfs_vdev_async_write_min_active\nto limit active async writes.\nIf the dirty data is between the minimum and maximum,\nthe active I/O limit is linearly\ninterpolated.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_async_write_max_active Ns = Ns Sy 10 Pq uint\nMaximum asynchronous write I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_async_write_min_active Ns = Ns Sy 2 Pq uint\nMinimum asynchronous write I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.Pp\nLower values are associated with better latency on rotational media but poorer\nresilver performance.\nThe default value of\n.Sy 2\nwas chosen as a compromise.\nA value of\n.Sy 3\nhas been shown to improve resilver performance further at a cost of\nfurther increasing latency.\n.\n.It Sy zfs_vdev_initializing_max_active Ns = Ns Sy 1 Pq uint\nMaximum initializing I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_initializing_min_active Ns = Ns Sy 1 Pq uint\nMinimum initializing I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_max_active Ns = Ns Sy 1000 Pq uint\nThe maximum number of I/O operations active to each device.\nIdeally, this will be at least the sum of each queue's\n.Sy max_active .\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_open_timeout_ms Ns = Ns Sy 1000 Pq uint\nTimeout value to wait before determining a device is missing\nduring import.\nThis is helpful for transient missing paths due\nto links being briefly removed and recreated in response to\nudev events.\n.\n.It Sy zfs_vdev_rebuild_max_active Ns = Ns Sy 3 Pq uint\nMaximum sequential resilver I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_rebuild_min_active Ns = Ns Sy 1 Pq uint\nMinimum sequential resilver I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_removal_max_active Ns = Ns Sy 2 Pq uint\nMaximum removal I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_removal_min_active Ns = Ns Sy 1 Pq uint\nMinimum removal I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_scrub_max_active Ns = Ns Sy 2 Pq uint\nMaximum scrub I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_scrub_min_active Ns = Ns Sy 1 Pq uint\nMinimum scrub I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_sync_read_max_active Ns = Ns Sy 10 Pq uint\nMaximum synchronous read I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_sync_read_min_active Ns = Ns Sy 10 Pq uint\nMinimum synchronous read I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_sync_write_max_active Ns = Ns Sy 10 Pq uint\nMaximum synchronous write I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_sync_write_min_active Ns = Ns Sy 10 Pq uint\nMinimum synchronous write I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_trim_max_active Ns = Ns Sy 2 Pq uint\nMaximum trim/discard I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_trim_min_active Ns = Ns Sy 1 Pq uint\nMinimum trim/discard I/O operations active to each device.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_nia_delay Ns = Ns Sy 5 Pq uint\nFor non-interactive I/O (scrub, resilver, removal, initialize and rebuild),\nthe number of concurrently-active I/O operations is limited to\n.Sy zfs_*_min_active ,\nunless the vdev is \"idle\".\nWhen there are no interactive I/O operations active (synchronous or otherwise),\nand\n.Sy zfs_vdev_nia_delay\noperations have completed since the last interactive operation,\nthen the vdev is considered to be \"idle\",\nand the number of concurrently-active non-interactive operations is increased to\n.Sy zfs_*_max_active .\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_nia_credit Ns = Ns Sy 5 Pq uint\nSome HDDs tend to prioritize sequential I/O so strongly, that concurrent\nrandom I/O latency reaches several seconds.\nOn some HDDs this happens even if sequential I/O operations\nare submitted one at a time, and so setting\n.Sy zfs_*_max_active Ns = Sy 1\ndoes not help.\nTo prevent non-interactive I/O, like scrub,\nfrom monopolizing the device, no more than\n.Sy zfs_vdev_nia_credit operations can be sent\nwhile there are outstanding incomplete interactive operations.\nThis enforced wait ensures the HDD services the interactive I/O\nwithin a reasonable amount of time.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_queue_depth_pct Ns = Ns Sy 1000 Ns % Pq uint\nMaximum number of queued allocations per top-level vdev expressed as\na percentage of\n.Sy zfs_vdev_async_write_max_active ,\nwhich allows the system to detect devices that are more capable\nof handling allocations and to allocate more blocks to those devices.\nThis allows for dynamic allocation distribution when devices are imbalanced,\nas fuller devices will tend to be slower than empty devices.\n.Pp\nAlso see\n.Sy zio_dva_throttle_enabled .\n.\n.It Sy zfs_vdev_def_queue_depth Ns = Ns Sy 32 Pq uint\nDefault queue depth for each vdev IO allocator.\nHigher values allow for better coalescing of sequential writes before sending\nthem to the disk, but can increase transaction commit times.\n.\n.It Sy zfs_vdev_failfast_mask Ns = Ns Sy 1 Pq uint\nDefines if the driver should retire on a given error type.\nThe following options may be bitwise-ored together:\n.TS\nbox;\nlbz r l l .\n\tValue\tName\tDescription\n_\n\t1\tDevice\tNo driver retries on device errors\n\t2\tTransport\tNo driver retries on transport errors.\n\t4\tDriver\tNo driver retries on driver errors.\n.TE\n.\n.It Sy zfs_expire_snapshot Ns = Ns Sy 300 Ns s Pq int\nTime before expiring\n.Pa .zfs/snapshot .\n.\n.It Sy zfs_admin_snapshot Ns = Ns Sy 0 Ns | Ns 1 Pq int\nAllow the creation, removal, or renaming of entries in the\n.Sy .zfs/snapshot\ndirectory to cause the creation, destruction, or renaming of snapshots.\nWhen enabled, this functionality works both locally and over NFS exports\nwhich have the\n.Em no_root_squash\noption set.\n.\n.It Sy zfs_flags Ns = Ns Sy 0 Pq int\nSet additional debugging flags.\nThe following flags may be bitwise-ored together:\n.TS\nbox;\nlbz r l l .\n\tValue\tName\tDescription\n_\n\t1\tZFS_DEBUG_DPRINTF\tEnable dprintf entries in the debug log.\n*\t2\tZFS_DEBUG_DBUF_VERIFY\tEnable extra dbuf verifications.\n*\t4\tZFS_DEBUG_DNODE_VERIFY\tEnable extra dnode verifications.\n\t8\tZFS_DEBUG_SNAPNAMES\tEnable snapshot name verification.\n*\t16\tZFS_DEBUG_MODIFY\tCheck for illegally modified ARC buffers.\n\t64\tZFS_DEBUG_ZIO_FREE\tEnable verification of block frees.\n\t128\tZFS_DEBUG_HISTOGRAM_VERIFY\tEnable extra spacemap histogram verifications.\n\t256\tZFS_DEBUG_METASLAB_VERIFY\tVerify space accounting on disk matches in-memory \\fBrange_trees\\fP.\n\t512\tZFS_DEBUG_SET_ERROR\tEnable \\fBSET_ERROR\\fP and dprintf entries in the debug log.\n\t1024\tZFS_DEBUG_INDIRECT_REMAP\tVerify split blocks created by device removal.\n\t2048\tZFS_DEBUG_TRIM\tVerify TRIM ranges are always within the allocatable range tree.\n\t4096\tZFS_DEBUG_LOG_SPACEMAP\tVerify that the log summary is consistent with the spacemap log\n\t\t\t       and enable \\fBzfs_dbgmsgs\\fP for metaslab loading and flushing.\n.TE\n.Sy \\& * No Requires debug build .\n.\n.It Sy zfs_btree_verify_intensity Ns = Ns Sy 0 Pq uint\nEnables btree verification.\nThe following settings are culminative:\n.TS\nbox;\nlbz r l l .\n\tValue\tDescription\n\n\t1\tVerify height.\n\t2\tVerify pointers from children to parent.\n\t3\tVerify element counts.\n\t4\tVerify element order. (expensive)\n*\t5\tVerify unused memory is poisoned. (expensive)\n.TE\n.Sy \\& * No Requires debug build .\n.\n.It Sy zfs_free_leak_on_eio Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIf destroy encounters an\n.Sy EIO\nwhile reading metadata (e.g. indirect blocks),\nspace referenced by the missing metadata can not be freed.\nNormally this causes the background destroy to become \"stalled\",\nas it is unable to make forward progress.\nWhile in this stalled state, all remaining space to free\nfrom the error-encountering filesystem is \"temporarily leaked\".\nSet this flag to cause it to ignore the\n.Sy EIO ,\npermanently leak the space from indirect blocks that can not be read,\nand continue to free everything else that it can.\n.Pp\nThe default \"stalling\" behavior is useful if the storage partially\nfails (i.e. some but not all I/O operations fail), and then later recovers.\nIn this case, we will be able to continue pool operations while it is\npartially failed, and when it recovers, we can continue to free the\nspace, with no leaks.\nNote, however, that this case is actually fairly rare.\n.Pp\nTypically pools either\n.Bl -enum -compact -offset 4n -width \"1.\"\n.It\nfail completely (but perhaps temporarily,\ne.g. due to a top-level vdev going offline), or\n.It\nhave localized, permanent errors (e.g. disk returns the wrong data\ndue to bit flip or firmware bug).\n.El\nIn the former case, this setting does not matter because the\npool will be suspended and the sync thread will not be able to make\nforward progress regardless.\nIn the latter, because the error is permanent, the best we can do\nis leak the minimum amount of space,\nwhich is what setting this flag will do.\nIt is therefore reasonable for this flag to normally be set,\nbut we chose the more conservative approach of not setting it,\nso that there is no possibility of\nleaking space in the \"partial temporary\" failure case.\n.\n.It Sy zfs_free_min_time_ms Ns = Ns Sy 1000 Ns ms Po 1s Pc Pq uint\nDuring a\n.Nm zfs Cm destroy\noperation using the\n.Sy async_destroy\nfeature,\na minimum of this much time will be spent working on freeing blocks per TXG.\n.\n.It Sy zfs_obsolete_min_time_ms Ns = Ns Sy 500 Ns ms Pq uint\nSimilar to\n.Sy zfs_free_min_time_ms ,\nbut for cleanup of old indirection records for removed vdevs.\n.\n.It Sy zfs_immediate_write_sz Ns = Ns Sy 32768 Ns B Po 32 KiB Pc Pq s64\nLargest data block to write to the ZIL.\nLarger blocks will be treated as if the dataset being written to had the\n.Sy logbias Ns = Ns Sy throughput\nproperty set.\n.\n.It Sy zfs_initialize_value Ns = Ns Sy 16045690984833335022 Po 0xDEADBEEFDEADBEEE Pc Pq u64\nPattern written to vdev free space by\n.Xr zpool-initialize 8 .\n.\n.It Sy zfs_initialize_chunk_size Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq u64\nSize of writes used by\n.Xr zpool-initialize 8 .\nThis option is used by the test suite.\n.\n.It Sy zfs_livelist_max_entries Ns = Ns Sy 500000 Po 5*10^5 Pc Pq u64\nThe threshold size (in block pointers) at which we create a new sub-livelist.\nLarger sublists are more costly from a memory perspective but the fewer\nsublists there are, the lower the cost of insertion.\n.\n.It Sy zfs_livelist_min_percent_shared Ns = Ns Sy 75 Ns % Pq int\nIf the amount of shared space between a snapshot and its clone drops below\nthis threshold, the clone turns off the livelist and reverts to the old\ndeletion method.\nThis is in place because livelists no long give us a benefit\nonce a clone has been overwritten enough.\n.\n.It Sy zfs_livelist_condense_new_alloc Ns = Ns Sy 0 Pq int\nIncremented each time an extra ALLOC blkptr is added to a livelist entry while\nit is being condensed.\nThis option is used by the test suite to track race conditions.\n.\n.It Sy zfs_livelist_condense_sync_cancel Ns = Ns Sy 0 Pq int\nIncremented each time livelist condensing is canceled while in\n.Fn spa_livelist_condense_sync .\nThis option is used by the test suite to track race conditions.\n.\n.It Sy zfs_livelist_condense_sync_pause Ns = Ns Sy 0 Ns | Ns 1 Pq int\nWhen set, the livelist condense process pauses indefinitely before\nexecuting the synctask \\(em\n.Fn spa_livelist_condense_sync .\nThis option is used by the test suite to trigger race conditions.\n.\n.It Sy zfs_livelist_condense_zthr_cancel Ns = Ns Sy 0 Pq int\nIncremented each time livelist condensing is canceled while in\n.Fn spa_livelist_condense_cb .\nThis option is used by the test suite to track race conditions.\n.\n.It Sy zfs_livelist_condense_zthr_pause Ns = Ns Sy 0 Ns | Ns 1 Pq int\nWhen set, the livelist condense process pauses indefinitely before\nexecuting the open context condensing work in\n.Fn spa_livelist_condense_cb .\nThis option is used by the test suite to trigger race conditions.\n.\n.It Sy zfs_lua_max_instrlimit Ns = Ns Sy 100000000 Po 10^8 Pc Pq u64\nThe maximum execution time limit that can be set for a ZFS channel program,\nspecified as a number of Lua instructions.\n.\n.It Sy zfs_lua_max_memlimit Ns = Ns Sy 104857600 Po 100 MiB Pc Pq u64\nThe maximum memory limit that can be set for a ZFS channel program, specified\nin bytes.\n.\n.It Sy zfs_max_dataset_nesting Ns = Ns Sy 50 Pq int\nThe maximum depth of nested datasets.\nThis value can be tuned temporarily to\nfix existing datasets that exceed the predefined limit.\n.\n.It Sy zfs_max_log_walking Ns = Ns Sy 5 Pq u64\nThe number of past TXGs that the flushing algorithm of the log spacemap\nfeature uses to estimate incoming log blocks.\n.\n.It Sy zfs_max_logsm_summary_length Ns = Ns Sy 10 Pq u64\nMaximum number of rows allowed in the summary of the spacemap log.\n.\n.It Sy zfs_max_recordsize Ns = Ns Sy 16777216 Po 16 MiB Pc Pq uint\nWe currently support block sizes from\n.Em 512 Po 512 B Pc No to Em 16777216 Po 16 MiB Pc .\nThe benefits of larger blocks, and thus larger I/O,\nneed to be weighed against the cost of COWing a giant block to modify one byte.\nAdditionally, very large blocks can have an impact on I/O latency,\nand also potentially on the memory allocator.\nTherefore, we formerly forbade creating blocks larger than 1M.\nLarger blocks could be created by changing it,\nand pools with larger blocks can always be imported and used,\nregardless of this setting.\n.\n.It Sy zfs_allow_redacted_dataset_mount Ns = Ns Sy 0 Ns | Ns 1 Pq int\nAllow datasets received with redacted send/receive to be mounted.\nNormally disabled because these datasets may be missing key data.\n.\n.It Sy zfs_min_metaslabs_to_flush Ns = Ns Sy 1 Pq u64\nMinimum number of metaslabs to flush per dirty TXG.\n.\n.It Sy zfs_metaslab_fragmentation_threshold Ns = Ns Sy 70 Ns % Pq uint\nAllow metaslabs to keep their active state as long as their fragmentation\npercentage is no more than this value.\nAn active metaslab that exceeds this threshold\nwill no longer keep its active status allowing better metaslabs to be selected.\n.\n.It Sy zfs_mg_fragmentation_threshold Ns = Ns Sy 95 Ns % Pq uint\nMetaslab groups are considered eligible for allocations if their\nfragmentation metric (measured as a percentage) is less than or equal to\nthis value.\nIf a metaslab group exceeds this threshold then it will be\nskipped unless all metaslab groups within the metaslab class have also\ncrossed this threshold.\n.\n.It Sy zfs_mg_noalloc_threshold Ns = Ns Sy 0 Ns % Pq uint\nDefines a threshold at which metaslab groups should be eligible for allocations.\nThe value is expressed as a percentage of free space\nbeyond which a metaslab group is always eligible for allocations.\nIf a metaslab group's free space is less than or equal to the\nthreshold, the allocator will avoid allocating to that group\nunless all groups in the pool have reached the threshold.\nOnce all groups have reached the threshold, all groups are allowed to accept\nallocations.\nThe default value of\n.Sy 0\ndisables the feature and causes all metaslab groups to be eligible for\nallocations.\n.Pp\nThis parameter allows one to deal with pools having heavily imbalanced\nvdevs such as would be the case when a new vdev has been added.\nSetting the threshold to a non-zero percentage will stop allocations\nfrom being made to vdevs that aren't filled to the specified percentage\nand allow lesser filled vdevs to acquire more allocations than they\notherwise would under the old\n.Sy zfs_mg_alloc_failures\nfacility.\n.\n.It Sy zfs_ddt_data_is_special Ns = Ns Sy 1 Ns | Ns 0 Pq int\nIf enabled, ZFS will place DDT data into the special allocation class.\n.\n.It Sy zfs_user_indirect_is_special Ns = Ns Sy 1 Ns | Ns 0 Pq int\nIf enabled, ZFS will place user data indirect blocks\ninto the special allocation class.\n.\n.It Sy zfs_multihost_history Ns = Ns Sy 0 Pq uint\nHistorical statistics for this many latest multihost updates will be available\nin\n.Pa /proc/spl/kstat/zfs/ Ns Ao Ar pool Ac Ns Pa /multihost .\n.\n.It Sy zfs_multihost_interval Ns = Ns Sy 1000 Ns ms Po 1 s Pc Pq u64\nUsed to control the frequency of multihost writes which are performed when the\n.Sy multihost\npool property is on.\nThis is one of the factors used to determine the\nlength of the activity check during import.\n.Pp\nThe multihost write period is\n.Sy zfs_multihost_interval No / Sy leaf-vdevs .\nOn average a multihost write will be issued for each leaf vdev\nevery\n.Sy zfs_multihost_interval\nmilliseconds.\nIn practice, the observed period can vary with the I/O load\nand this observed value is the delay which is stored in the uberblock.\n.\n.It Sy zfs_multihost_import_intervals Ns = Ns Sy 20 Pq uint\nUsed to control the duration of the activity test on import.\nSmaller values of\n.Sy zfs_multihost_import_intervals\nwill reduce the import time but increase\nthe risk of failing to detect an active pool.\nThe total activity check time is never allowed to drop below one second.\n.Pp\nOn import the activity check waits a minimum amount of time determined by\n.Sy zfs_multihost_interval No \\(mu Sy zfs_multihost_import_intervals ,\nor the same product computed on the host which last had the pool imported,\nwhichever is greater.\nThe activity check time may be further extended if the value of MMP\ndelay found in the best uberblock indicates actual multihost updates happened\nat longer intervals than\n.Sy zfs_multihost_interval .\nA minimum of\n.Em 100 ms\nis enforced.\n.Pp\n.Sy 0 No is equivalent to Sy 1 .\n.\n.It Sy zfs_multihost_fail_intervals Ns = Ns Sy 10 Pq uint\nControls the behavior of the pool when multihost write failures or delays are\ndetected.\n.Pp\nWhen\n.Sy 0 ,\nmultihost write failures or delays are ignored.\nThe failures will still be reported to the ZED which depending on\nits configuration may take action such as suspending the pool or offlining a\ndevice.\n.Pp\nOtherwise, the pool will be suspended if\n.Sy zfs_multihost_fail_intervals No \\(mu Sy zfs_multihost_interval\nmilliseconds pass without a successful MMP write.\nThis guarantees the activity test will see MMP writes if the pool is imported.\n.Sy 1 No is equivalent to Sy 2 ;\nthis is necessary to prevent the pool from being suspended\ndue to normal, small I/O latency variations.\n.\n.It Sy zfs_no_scrub_io Ns = Ns Sy 0 Ns | Ns 1 Pq int\nSet to disable scrub I/O.\nThis results in scrubs not actually scrubbing data and\nsimply doing a metadata crawl of the pool instead.\n.\n.It Sy zfs_no_scrub_prefetch Ns = Ns Sy 0 Ns | Ns 1 Pq int\nSet to disable block prefetching for scrubs.\n.\n.It Sy zfs_nocacheflush Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable cache flush operations on disks when writing.\nSetting this will cause pool corruption on power loss\nif a volatile out-of-order write cache is enabled.\n.\n.It Sy zfs_nopwrite_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nAllow no-operation writes.\nThe occurrence of nopwrites will further depend on other pool properties\n.Pq i.a. the checksumming and compression algorithms .\n.\n.It Sy zfs_dmu_offset_next_sync Ns = Ns Sy 1 Ns | Ns 0 Pq int\nEnable forcing TXG sync to find holes.\nWhen enabled forces ZFS to sync data when\n.Sy SEEK_HOLE No or Sy SEEK_DATA\nflags are used allowing holes in a file to be accurately reported.\nWhen disabled holes will not be reported in recently dirtied files.\n.\n.It Sy zfs_pd_bytes_max Ns = Ns Sy 52428800 Ns B Po 50 MiB Pc Pq int\nThe number of bytes which should be prefetched during a pool traversal, like\n.Nm zfs Cm send\nor other data crawling operations.\n.\n.It Sy zfs_traverse_indirect_prefetch_limit Ns = Ns Sy 32 Pq uint\nThe number of blocks pointed by indirect (non-L0) block which should be\nprefetched during a pool traversal, like\n.Nm zfs Cm send\nor other data crawling operations.\n.\n.It Sy zfs_per_txg_dirty_frees_percent Ns = Ns Sy 30 Ns % Pq u64\nControl percentage of dirtied indirect blocks from frees allowed into one TXG.\nAfter this threshold is crossed, additional frees will wait until the next TXG.\n.Sy 0 No disables this throttle .\n.\n.It Sy zfs_prefetch_disable Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable predictive prefetch.\nNote that it leaves \"prescient\" prefetch\n.Pq for, e.g., Nm zfs Cm send\nintact.\nUnlike predictive prefetch, prescient prefetch never issues I/O\nthat ends up not being needed, so it can't hurt performance.\n.\n.It Sy zfs_qat_checksum_disable Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable QAT hardware acceleration for SHA256 checksums.\nMay be unset after the ZFS modules have been loaded to initialize the QAT\nhardware as long as support is compiled in and the QAT driver is present.\n.\n.It Sy zfs_qat_compress_disable Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable QAT hardware acceleration for gzip compression.\nMay be unset after the ZFS modules have been loaded to initialize the QAT\nhardware as long as support is compiled in and the QAT driver is present.\n.\n.It Sy zfs_qat_encrypt_disable Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable QAT hardware acceleration for AES-GCM encryption.\nMay be unset after the ZFS modules have been loaded to initialize the QAT\nhardware as long as support is compiled in and the QAT driver is present.\n.\n.It Sy zfs_vnops_read_chunk_size Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq u64\nBytes to read per chunk.\n.\n.It Sy zfs_read_history Ns = Ns Sy 0 Pq uint\nHistorical statistics for this many latest reads will be available in\n.Pa /proc/spl/kstat/zfs/ Ns Ao Ar pool Ac Ns Pa /reads .\n.\n.It Sy zfs_read_history_hits Ns = Ns Sy 0 Ns | Ns 1 Pq int\nInclude cache hits in read history\n.\n.It Sy zfs_rebuild_max_segment Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq u64\nMaximum read segment size to issue when sequentially resilvering a\ntop-level vdev.\n.\n.It Sy zfs_rebuild_scrub_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nAutomatically start a pool scrub when the last active sequential resilver\ncompletes in order to verify the checksums of all blocks which have been\nresilvered.\nThis is enabled by default and strongly recommended.\n.\n.It Sy zfs_rebuild_vdev_limit Ns = Ns Sy 67108864 Ns B Po 64 MiB Pc Pq u64\nMaximum amount of I/O that can be concurrently issued for a sequential\nresilver per leaf device, given in bytes.\n.\n.It Sy zfs_reconstruct_indirect_combinations_max Ns = Ns Sy 4096 Pq int\nIf an indirect split block contains more than this many possible unique\ncombinations when being reconstructed, consider it too computationally\nexpensive to check them all.\nInstead, try at most this many randomly selected\ncombinations each time the block is accessed.\nThis allows all segment copies to participate fairly\nin the reconstruction when all combinations\ncannot be checked and prevents repeated use of one bad copy.\n.\n.It Sy zfs_recover Ns = Ns Sy 0 Ns | Ns 1 Pq int\nSet to attempt to recover from fatal errors.\nThis should only be used as a last resort,\nas it typically results in leaked space, or worse.\n.\n.It Sy zfs_removal_ignore_errors Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIgnore hard I/O errors during device removal.\nWhen set, if a device encounters a hard I/O error during the removal process\nthe removal will not be cancelled.\nThis can result in a normally recoverable block becoming permanently damaged\nand is hence not recommended.\nThis should only be used as a last resort when the\npool cannot be returned to a healthy state prior to removing the device.\n.\n.It Sy zfs_removal_suspend_progress Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nThis is used by the test suite so that it can ensure that certain actions\nhappen while in the middle of a removal.\n.\n.It Sy zfs_remove_max_segment Ns = Ns Sy 16777216 Ns B Po 16 MiB Pc Pq uint\nThe largest contiguous segment that we will attempt to allocate when removing\na device.\nIf there is a performance problem with attempting to allocate large blocks,\nconsider decreasing this.\nThe default value is also the maximum.\n.\n.It Sy zfs_resilver_disable_defer Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIgnore the\n.Sy resilver_defer\nfeature, causing an operation that would start a resilver to\nimmediately restart the one in progress.\n.\n.It Sy zfs_resilver_min_time_ms Ns = Ns Sy 3000 Ns ms Po 3 s Pc Pq uint\nResilvers are processed by the sync thread.\nWhile resilvering, it will spend at least this much time\nworking on a resilver between TXG flushes.\n.\n.It Sy zfs_scan_ignore_errors Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIf set, remove the DTL (dirty time list) upon completion of a pool scan (scrub),\neven if there were unrepairable errors.\nIntended to be used during pool repair or recovery to\nstop resilvering when the pool is next imported.\n.\n.It Sy zfs_scrub_min_time_ms Ns = Ns Sy 1000 Ns ms Po 1 s Pc Pq uint\nScrubs are processed by the sync thread.\nWhile scrubbing, it will spend at least this much time\nworking on a scrub between TXG flushes.\n.\n.It Sy zfs_scrub_error_blocks_per_txg Ns = Ns Sy 4096 Pq uint\nError blocks to be scrubbed in one txg.\n.\n.It Sy zfs_scan_checkpoint_intval Ns = Ns Sy 7200 Ns s Po 2 hour Pc Pq uint\nTo preserve progress across reboots, the sequential scan algorithm periodically\nneeds to stop metadata scanning and issue all the verification I/O to disk.\nThe frequency of this flushing is determined by this tunable.\n.\n.It Sy zfs_scan_fill_weight Ns = Ns Sy 3 Pq uint\nThis tunable affects how scrub and resilver I/O segments are ordered.\nA higher number indicates that we care more about how filled in a segment is,\nwhile a lower number indicates we care more about the size of the extent without\nconsidering the gaps within a segment.\nThis value is only tunable upon module insertion.\nChanging the value afterwards will have no effect on scrub or resilver\nperformance.\n.\n.It Sy zfs_scan_issue_strategy Ns = Ns Sy 0 Pq uint\nDetermines the order that data will be verified while scrubbing or resilvering:\n.Bl -tag -compact -offset 4n -width \"a\"\n.It Sy 1\nData will be verified as sequentially as possible, given the\namount of memory reserved for scrubbing\n.Pq see Sy zfs_scan_mem_lim_fact .\nThis may improve scrub performance if the pool's data is very fragmented.\n.It Sy 2\nThe largest mostly-contiguous chunk of found data will be verified first.\nBy deferring scrubbing of small segments, we may later find adjacent data\nto coalesce and increase the segment size.\n.It Sy 0\n.No Use strategy Sy 1 No during normal verification\n.No and strategy Sy 2 No while taking a checkpoint .\n.El\n.\n.It Sy zfs_scan_legacy Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIf unset, indicates that scrubs and resilvers will gather metadata in\nmemory before issuing sequential I/O.\nOtherwise indicates that the legacy algorithm will be used,\nwhere I/O is initiated as soon as it is discovered.\nUnsetting will not affect scrubs or resilvers that are already in progress.\n.\n.It Sy zfs_scan_max_ext_gap Ns = Ns Sy 2097152 Ns B Po 2 MiB Pc Pq int\nSets the largest gap in bytes between scrub/resilver I/O operations\nthat will still be considered sequential for sorting purposes.\nChanging this value will not\naffect scrubs or resilvers that are already in progress.\n.\n.It Sy zfs_scan_mem_lim_fact Ns = Ns Sy 20 Ns ^-1 Pq uint\nMaximum fraction of RAM used for I/O sorting by sequential scan algorithm.\nThis tunable determines the hard limit for I/O sorting memory usage.\nWhen the hard limit is reached we stop scanning metadata and start issuing\ndata verification I/O.\nThis is done until we get below the soft limit.\n.\n.It Sy zfs_scan_mem_lim_soft_fact Ns = Ns Sy 20 Ns ^-1 Pq uint\nThe fraction of the hard limit used to determined the soft limit for I/O sorting\nby the sequential scan algorithm.\nWhen we cross this limit from below no action is taken.\nWhen we cross this limit from above it is because we are issuing verification\nI/O.\nIn this case (unless the metadata scan is done) we stop issuing verification I/O\nand start scanning metadata again until we get to the hard limit.\n.\n.It Sy zfs_scan_report_txgs Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nWhen reporting resilver throughput and estimated completion time use the\nperformance observed over roughly the last\n.Sy zfs_scan_report_txgs\nTXGs.\nWhen set to zero performance is calculated over the time between checkpoints.\n.\n.It Sy zfs_scan_strict_mem_lim Ns = Ns Sy 0 Ns | Ns 1 Pq int\nEnforce tight memory limits on pool scans when a sequential scan is in progress.\nWhen disabled, the memory limit may be exceeded by fast disks.\n.\n.It Sy zfs_scan_suspend_progress Ns = Ns Sy 0 Ns | Ns 1 Pq int\nFreezes a scrub/resilver in progress without actually pausing it.\nIntended for testing/debugging.\n.\n.It Sy zfs_scan_vdev_limit Ns = Ns Sy 16777216 Ns B Po 16 MiB Pc Pq int\nMaximum amount of data that can be concurrently issued at once for scrubs and\nresilvers per leaf device, given in bytes.\n.\n.It Sy zfs_send_corrupt_data Ns = Ns Sy 0 Ns | Ns 1 Pq int\nAllow sending of corrupt data (ignore read/checksum errors when sending).\n.\n.It Sy zfs_send_unmodified_spill_blocks Ns = Ns Sy 1 Ns | Ns 0 Pq int\nInclude unmodified spill blocks in the send stream.\nUnder certain circumstances, previous versions of ZFS could incorrectly\nremove the spill block from an existing object.\nIncluding unmodified copies of the spill blocks creates a backwards-compatible\nstream which will recreate a spill block if it was incorrectly removed.\n.\n.It Sy zfs_send_no_prefetch_queue_ff Ns = Ns Sy 20 Ns ^\\-1 Pq uint\nThe fill fraction of the\n.Nm zfs Cm send\ninternal queues.\nThe fill fraction controls the timing with which internal threads are woken up.\n.\n.It Sy zfs_send_no_prefetch_queue_length Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq uint\nThe maximum number of bytes allowed in\n.Nm zfs Cm send Ns 's\ninternal queues.\n.\n.It Sy zfs_send_queue_ff Ns = Ns Sy 20 Ns ^\\-1 Pq uint\nThe fill fraction of the\n.Nm zfs Cm send\nprefetch queue.\nThe fill fraction controls the timing with which internal threads are woken up.\n.\n.It Sy zfs_send_queue_length Ns = Ns Sy 16777216 Ns B Po 16 MiB Pc Pq uint\nThe maximum number of bytes allowed that will be prefetched by\n.Nm zfs Cm send .\nThis value must be at least twice the maximum block size in use.\n.\n.It Sy zfs_recv_queue_ff Ns = Ns Sy 20 Ns ^\\-1 Pq uint\nThe fill fraction of the\n.Nm zfs Cm receive\nqueue.\nThe fill fraction controls the timing with which internal threads are woken up.\n.\n.It Sy zfs_recv_queue_length Ns = Ns Sy 16777216 Ns B Po 16 MiB Pc Pq uint\nThe maximum number of bytes allowed in the\n.Nm zfs Cm receive\nqueue.\nThis value must be at least twice the maximum block size in use.\n.\n.It Sy zfs_recv_write_batch_size Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq uint\nThe maximum amount of data, in bytes, that\n.Nm zfs Cm receive\nwill write in one DMU transaction.\nThis is the uncompressed size, even when receiving a compressed send stream.\nThis setting will not reduce the write size below a single block.\nCapped at a maximum of\n.Sy 32 MiB .\n.\n.It Sy zfs_recv_best_effort_corrective Ns = Ns Sy 0 Pq int\nWhen this variable is set to non-zero a corrective receive:\n.Bl -enum -compact -offset 4n -width \"1.\"\n.It\nDoes not enforce the restriction of source & destination snapshot GUIDs\nmatching.\n.It\nIf there is an error during healing, the healing receive is not\nterminated instead it moves on to the next record.\n.El\n.\n.It Sy zfs_override_estimate_recordsize Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nSetting this variable overrides the default logic for estimating block\nsizes when doing a\n.Nm zfs Cm send .\nThe default heuristic is that the average block size\nwill be the current recordsize.\nOverride this value if most data in your dataset is not of that size\nand you require accurate zfs send size estimates.\n.\n.It Sy zfs_sync_pass_deferred_free Ns = Ns Sy 2 Pq uint\nFlushing of data to disk is done in passes.\nDefer frees starting in this pass.\n.\n.It Sy zfs_spa_discard_memory_limit Ns = Ns Sy 16777216 Ns B Po 16 MiB Pc Pq int\nMaximum memory used for prefetching a checkpoint's space map on each\nvdev while discarding the checkpoint.\n.\n.It Sy zfs_special_class_metadata_reserve_pct Ns = Ns Sy 25 Ns % Pq uint\nOnly allow small data blocks to be allocated on the special and dedup vdev\ntypes when the available free space percentage on these vdevs exceeds this\nvalue.\nThis ensures reserved space is available for pool metadata as the\nspecial vdevs approach capacity.\n.\n.It Sy zfs_sync_pass_dont_compress Ns = Ns Sy 8 Pq uint\nStarting in this sync pass, disable compression (including of metadata).\nWith the default setting, in practice, we don't have this many sync passes,\nso this has no effect.\n.Pp\nThe original intent was that disabling compression would help the sync passes\nto converge.\nHowever, in practice, disabling compression increases\nthe average number of sync passes; because when we turn compression off,\nmany blocks' size will change, and thus we have to re-allocate\n(not overwrite) them.\nIt also increases the number of\n.Em 128 KiB\nallocations (e.g. for indirect blocks and spacemaps)\nbecause these will not be compressed.\nThe\n.Em 128 KiB\nallocations are especially detrimental to performance\non highly fragmented systems, which may have very few free segments of this\nsize,\nand may need to load new metaslabs to satisfy these allocations.\n.\n.It Sy zfs_sync_pass_rewrite Ns = Ns Sy 2 Pq uint\nRewrite new block pointers starting in this pass.\n.\n.It Sy zfs_sync_taskq_batch_pct Ns = Ns Sy 75 Ns % Pq int\nThis controls the number of threads used by\n.Sy dp_sync_taskq .\nThe default value of\n.Sy 75%\nwill create a maximum of one thread per CPU.\n.\n.It Sy zfs_trim_extent_bytes_max Ns = Ns Sy 134217728 Ns B Po 128 MiB Pc Pq uint\nMaximum size of TRIM command.\nLarger ranges will be split into chunks no larger than this value before\nissuing.\n.\n.It Sy zfs_trim_extent_bytes_min Ns = Ns Sy 32768 Ns B Po 32 KiB Pc Pq uint\nMinimum size of TRIM commands.\nTRIM ranges smaller than this will be skipped,\nunless they're part of a larger range which was chunked.\nThis is done because it's common for these small TRIMs\nto negatively impact overall performance.\n.\n.It Sy zfs_trim_metaslab_skip Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nSkip uninitialized metaslabs during the TRIM process.\nThis option is useful for pools constructed from large thinly-provisioned\ndevices\nwhere TRIM operations are slow.\nAs a pool ages, an increasing fraction of the pool's metaslabs\nwill be initialized, progressively degrading the usefulness of this option.\nThis setting is stored when starting a manual TRIM and will\npersist for the duration of the requested TRIM.\n.\n.It Sy zfs_trim_queue_limit Ns = Ns Sy 10 Pq uint\nMaximum number of queued TRIMs outstanding per leaf vdev.\nThe number of concurrent TRIM commands issued to the device is controlled by\n.Sy zfs_vdev_trim_min_active No and Sy zfs_vdev_trim_max_active .\n.\n.It Sy zfs_trim_txg_batch Ns = Ns Sy 32 Pq uint\nThe number of transaction groups' worth of frees which should be aggregated\nbefore TRIM operations are issued to the device.\nThis setting represents a trade-off between issuing larger,\nmore efficient TRIM operations and the delay\nbefore the recently trimmed space is available for use by the device.\n.Pp\nIncreasing this value will allow frees to be aggregated for a longer time.\nThis will result is larger TRIM operations and potentially increased memory\nusage.\nDecreasing this value will have the opposite effect.\nThe default of\n.Sy 32\nwas determined to be a reasonable compromise.\n.\n.It Sy zfs_txg_history Ns = Ns Sy 0 Pq uint\nHistorical statistics for this many latest TXGs will be available in\n.Pa /proc/spl/kstat/zfs/ Ns Ao Ar pool Ac Ns Pa /TXGs .\n.\n.It Sy zfs_txg_timeout Ns = Ns Sy 5 Ns s Pq uint\nFlush dirty data to disk at least every this many seconds (maximum TXG\nduration).\n.\n.It Sy zfs_vdev_aggregation_limit Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq uint\nMax vdev I/O aggregation size.\n.\n.It Sy zfs_vdev_aggregation_limit_non_rotating Ns = Ns Sy 131072 Ns B Po 128 KiB Pc Pq uint\nMax vdev I/O aggregation size for non-rotating media.\n.\n.It Sy zfs_vdev_mirror_rotating_inc Ns = Ns Sy 0 Pq int\nA number by which the balancing algorithm increments the load calculation for\nthe purpose of selecting the least busy mirror member when an I/O operation\nimmediately follows its predecessor on rotational vdevs\nfor the purpose of making decisions based on load.\n.\n.It Sy zfs_vdev_mirror_rotating_seek_inc Ns = Ns Sy 5 Pq int\nA number by which the balancing algorithm increments the load calculation for\nthe purpose of selecting the least busy mirror member when an I/O operation\nlacks locality as defined by\n.Sy zfs_vdev_mirror_rotating_seek_offset .\nOperations within this that are not immediately following the previous operation\nare incremented by half.\n.\n.It Sy zfs_vdev_mirror_rotating_seek_offset Ns = Ns Sy 1048576 Ns B Po 1 MiB Pc Pq int\nThe maximum distance for the last queued I/O operation in which\nthe balancing algorithm considers an operation to have locality.\n.No See Sx ZFS I/O SCHEDULER .\n.\n.It Sy zfs_vdev_mirror_non_rotating_inc Ns = Ns Sy 0 Pq int\nA number by which the balancing algorithm increments the load calculation for\nthe purpose of selecting the least busy mirror member on non-rotational vdevs\nwhen I/O operations do not immediately follow one another.\n.\n.It Sy zfs_vdev_mirror_non_rotating_seek_inc Ns = Ns Sy 1 Pq int\nA number by which the balancing algorithm increments the load calculation for\nthe purpose of selecting the least busy mirror member when an I/O operation\nlacks\nlocality as defined by the\n.Sy zfs_vdev_mirror_rotating_seek_offset .\nOperations within this that are not immediately following the previous operation\nare incremented by half.\n.\n.It Sy zfs_vdev_read_gap_limit Ns = Ns Sy 32768 Ns B Po 32 KiB Pc Pq uint\nAggregate read I/O operations if the on-disk gap between them is within this\nthreshold.\n.\n.It Sy zfs_vdev_write_gap_limit Ns = Ns Sy 4096 Ns B Po 4 KiB Pc Pq uint\nAggregate write I/O operations if the on-disk gap between them is within this\nthreshold.\n.\n.It Sy zfs_vdev_raidz_impl Ns = Ns Sy fastest Pq string\nSelect the raidz parity implementation to use.\n.Pp\nVariants that don't depend on CPU-specific features\nmay be selected on module load, as they are supported on all systems.\nThe remaining options may only be set after the module is loaded,\nas they are available only if the implementations are compiled in\nand supported on the running system.\n.Pp\nOnce the module is loaded,\n.Pa /sys/module/zfs/parameters/zfs_vdev_raidz_impl\nwill show the available options,\nwith the currently selected one enclosed in square brackets.\n.Pp\n.TS\nlb l l .\nfastest\tselected by built-in benchmark\noriginal\toriginal implementation\nscalar\tscalar implementation\nsse2\tSSE2 instruction set\t64-bit x86\nssse3\tSSSE3 instruction set\t64-bit x86\navx2\tAVX2 instruction set\t64-bit x86\navx512f\tAVX512F instruction set\t64-bit x86\navx512bw\tAVX512F & AVX512BW instruction sets\t64-bit x86\naarch64_neon\tNEON\tAarch64/64-bit ARMv8\naarch64_neonx2\tNEON with more unrolling\tAarch64/64-bit ARMv8\npowerpc_altivec\tAltivec\tPowerPC\n.TE\n.\n.It Sy zfs_vdev_scheduler Pq charp\n.Sy DEPRECATED .\nPrints warning to kernel log for compatibility.\n.\n.It Sy zfs_zevent_len_max Ns = Ns Sy 512 Pq uint\nMax event queue length.\nEvents in the queue can be viewed with\n.Xr zpool-events 8 .\n.\n.It Sy zfs_zevent_retain_max Ns = Ns Sy 2000 Pq int\nMaximum recent zevent records to retain for duplicate checking.\nSetting this to\n.Sy 0\ndisables duplicate detection.\n.\n.It Sy zfs_zevent_retain_expire_secs Ns = Ns Sy 900 Ns s Po 15 min Pc Pq int\nLifespan for a recent ereport that was retained for duplicate checking.\n.\n.It Sy zfs_zil_clean_taskq_maxalloc Ns = Ns Sy 1048576 Pq int\nThe maximum number of taskq entries that are allowed to be cached.\nWhen this limit is exceeded transaction records (itxs)\nwill be cleaned synchronously.\n.\n.It Sy zfs_zil_clean_taskq_minalloc Ns = Ns Sy 1024 Pq int\nThe number of taskq entries that are pre-populated when the taskq is first\ncreated and are immediately available for use.\n.\n.It Sy zfs_zil_clean_taskq_nthr_pct Ns = Ns Sy 100 Ns % Pq int\nThis controls the number of threads used by\n.Sy dp_zil_clean_taskq .\nThe default value of\n.Sy 100%\nwill create a maximum of one thread per cpu.\n.\n.It Sy zil_maxblocksize Ns = Ns Sy 131072 Ns B Po 128 KiB Pc Pq uint\nThis sets the maximum block size used by the ZIL.\nOn very fragmented pools, lowering this\n.Pq typically to Sy 36 KiB\ncan improve performance.\n.\n.It Sy zil_maxcopied Ns = Ns Sy 7680 Ns B Po 7.5 KiB Pc Pq uint\nThis sets the maximum number of write bytes logged via WR_COPIED.\nIt tunes a tradeoff between additional memory copy and possibly worse log\nspace efficiency vs additional range lock/unlock.\n.\n.It Sy zil_min_commit_timeout Ns = Ns Sy 5000 Pq u64\nThis sets the minimum delay in nanoseconds ZIL care to delay block commit,\nwaiting for more records.\nIf ZIL writes are too fast, kernel may not be able sleep for so short interval,\nincreasing log latency above allowed by\n.Sy zfs_commit_timeout_pct .\n.\n.It Sy zil_nocacheflush Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable the cache flush commands that are normally sent to disk by\nthe ZIL after an LWB write has completed.\nSetting this will cause ZIL corruption on power loss\nif a volatile out-of-order write cache is enabled.\n.\n.It Sy zil_replay_disable Ns = Ns Sy 0 Ns | Ns 1 Pq int\nDisable intent logging replay.\nCan be disabled for recovery from corrupted ZIL.\n.\n.It Sy zil_slog_bulk Ns = Ns Sy 67108864 Ns B Po 64 MiB Pc Pq u64\nLimit SLOG write size per commit executed with synchronous priority.\nAny writes above that will be executed with lower (asynchronous) priority\nto limit potential SLOG device abuse by single active ZIL writer.\n.\n.It Sy zfs_zil_saxattr Ns = Ns Sy 1 Ns | Ns 0 Pq int\nSetting this tunable to zero disables ZIL logging of new\n.Sy xattr Ns = Ns Sy sa\nrecords if the\n.Sy org.openzfs:zilsaxattr\nfeature is enabled on the pool.\nThis would only be necessary to work around bugs in the ZIL logging or replay\ncode for this record type.\nThe tunable has no effect if the feature is disabled.\n.\n.It Sy zfs_embedded_slog_min_ms Ns = Ns Sy 64 Pq uint\nUsually, one metaslab from each normal-class vdev is dedicated for use by\nthe ZIL to log synchronous writes.\nHowever, if there are fewer than\n.Sy zfs_embedded_slog_min_ms\nmetaslabs in the vdev, this functionality is disabled.\nThis ensures that we don't set aside an unreasonable amount of space for the\nZIL.\n.\n.It Sy zstd_earlyabort_pass Ns = Ns Sy 1 Pq uint\nWhether heuristic for detection of incompressible data with zstd levels >= 3\nusing LZ4 and zstd-1 passes is enabled.\n.\n.It Sy zstd_abort_size Ns = Ns Sy 131072 Pq uint\nMinimal uncompressed size (inclusive) of a record before the early abort\nheuristic will be attempted.\n.\n.It Sy zio_deadman_log_all Ns = Ns Sy 0 Ns | Ns 1 Pq int\nIf non-zero, the zio deadman will produce debugging messages\n.Pq see Sy zfs_dbgmsg_enable\nfor all zios, rather than only for leaf zios possessing a vdev.\nThis is meant to be used by developers to gain\ndiagnostic information for hang conditions which don't involve a mutex\nor other locking primitive: typically conditions in which a thread in\nthe zio pipeline is looping indefinitely.\n.\n.It Sy zio_slow_io_ms Ns = Ns Sy 30000 Ns ms Po 30 s Pc Pq int\nWhen an I/O operation takes more than this much time to complete,\nit's marked as slow.\nEach slow operation causes a delay zevent.\nSlow I/O counters can be seen with\n.Nm zpool Cm status Fl s .\n.\n.It Sy zio_dva_throttle_enabled Ns = Ns Sy 1 Ns | Ns 0 Pq int\nThrottle block allocations in the I/O pipeline.\nThis allows for dynamic allocation distribution when devices are imbalanced.\nWhen enabled, the maximum number of pending allocations per top-level vdev\nis limited by\n.Sy zfs_vdev_queue_depth_pct .\n.\n.It Sy zfs_xattr_compat Ns = Ns 0 Ns | Ns 1 Pq int\nControl the naming scheme used when setting new xattrs in the user namespace.\nIf\n.Sy 0\n.Pq the default on Linux ,\nuser namespace xattr names are prefixed with the namespace, to be backwards\ncompatible with previous versions of ZFS on Linux.\nIf\n.Sy 1\n.Pq the default on Fx ,\nuser namespace xattr names are not prefixed, to be backwards compatible with\nprevious versions of ZFS on illumos and\n.Fx .\n.Pp\nEither naming scheme can be read on this and future versions of ZFS, regardless\nof this tunable, but legacy ZFS on illumos or\n.Fx\nare unable to read user namespace xattrs written in the Linux format, and\nlegacy versions of ZFS on Linux are unable to read user namespace xattrs written\nin the legacy ZFS format.\n.Pp\nAn existing xattr with the alternate naming scheme is removed when overwriting\nthe xattr so as to not accumulate duplicates.\n.\n.It Sy zio_requeue_io_start_cut_in_line Ns = Ns Sy 0 Ns | Ns 1 Pq int\nPrioritize requeued I/O.\n.\n.It Sy zio_taskq_batch_pct Ns = Ns Sy 80 Ns % Pq uint\nPercentage of online CPUs which will run a worker thread for I/O.\nThese workers are responsible for I/O work such as compression and\nchecksum calculations.\nFractional number of CPUs will be rounded down.\n.Pp\nThe default value of\n.Sy 80%\nwas chosen to avoid using all CPUs which can result in\nlatency issues and inconsistent application performance,\nespecially when slower compression and/or checksumming is enabled.\n.\n.It Sy zio_taskq_batch_tpq Ns = Ns Sy 0 Pq uint\nNumber of worker threads per taskq.\nLower values improve I/O ordering and CPU utilization,\nwhile higher reduces lock contention.\n.Pp\nIf\n.Sy 0 ,\ngenerate a system-dependent value close to 6 threads per taskq.\n.\n.It Sy zvol_inhibit_dev Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nDo not create zvol device nodes.\nThis may slightly improve startup time on\nsystems with a very large number of zvols.\n.\n.It Sy zvol_major Ns = Ns Sy 230 Pq uint\nMajor number for zvol block devices.\n.\n.It Sy zvol_max_discard_blocks Ns = Ns Sy 16384 Pq long\nDiscard (TRIM) operations done on zvols will be done in batches of this\nmany blocks, where block size is determined by the\n.Sy volblocksize\nproperty of a zvol.\n.\n.It Sy zvol_prefetch_bytes Ns = Ns Sy 131072 Ns B Po 128 KiB Pc Pq uint\nWhen adding a zvol to the system, prefetch this many bytes\nfrom the start and end of the volume.\nPrefetching these regions of the volume is desirable,\nbecause they are likely to be accessed immediately by\n.Xr blkid 8\nor the kernel partitioner.\n.\n.It Sy zvol_request_sync Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nWhen processing I/O requests for a zvol, submit them synchronously.\nThis effectively limits the queue depth to\n.Em 1\nfor each I/O submitter.\nWhen unset, requests are handled asynchronously by a thread pool.\nThe number of requests which can be handled concurrently is controlled by\n.Sy zvol_threads .\n.Sy zvol_request_sync\nis ignored when running on a kernel that supports block multiqueue\n.Pq Li blk-mq .\n.\n.It Sy zvol_threads Ns = Ns Sy 0 Pq uint\nThe number of system wide threads to use for processing zvol block IOs.\nIf\n.Sy 0\n(the default) then internally set\n.Sy zvol_threads\nto the number of CPUs present or 32 (whichever is greater).\n.\n.It Sy zvol_blk_mq_threads Ns = Ns Sy 0 Pq uint\nThe number of threads per zvol to use for queuing IO requests.\nThis parameter will only appear if your kernel supports\n.Li blk-mq\nand is only read and assigned to a zvol at zvol load time.\nIf\n.Sy 0\n(the default) then internally set\n.Sy zvol_blk_mq_threads\nto the number of CPUs present.\n.\n.It Sy zvol_use_blk_mq Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nSet to\n.Sy 1\nto use the\n.Li blk-mq\nAPI for zvols.\nSet to\n.Sy 0\n(the default) to use the legacy zvol APIs.\nThis setting can give better or worse zvol performance depending on\nthe workload.\nThis parameter will only appear if your kernel supports\n.Li blk-mq\nand is only read and assigned to a zvol at zvol load time.\n.\n.It Sy zvol_blk_mq_blocks_per_thread Ns = Ns Sy 8 Pq uint\nIf\n.Sy zvol_use_blk_mq\nis enabled, then process this number of\n.Sy volblocksize Ns -sized blocks per zvol thread.\nThis tunable can be use to favor better performance for zvol reads (lower\nvalues) or writes (higher values).\nIf set to\n.Sy 0 ,\nthen the zvol layer will process the maximum number of blocks\nper thread that it can.\nThis parameter will only appear if your kernel supports\n.Li blk-mq\nand is only applied at each zvol's load time.\n.\n.It Sy zvol_blk_mq_queue_depth Ns = Ns Sy 0 Pq uint\nThe queue_depth value for the zvol\n.Li blk-mq\ninterface.\nThis parameter will only appear if your kernel supports\n.Li blk-mq\nand is only applied at each zvol's load time.\nIf\n.Sy 0\n(the default) then use the kernel's default queue depth.\nValues are clamped to the kernel's\n.Dv BLKDEV_MIN_RQ\nand\n.Dv BLKDEV_MAX_RQ Ns / Ns Dv BLKDEV_DEFAULT_RQ\nlimits.\n.\n.It Sy zvol_volmode Ns = Ns Sy 1 Pq uint\nDefines zvol block devices behaviour when\n.Sy volmode Ns = Ns Sy default :\n.Bl -tag -compact -offset 4n -width \"a\"\n.It Sy 1\n.No equivalent to Sy full\n.It Sy 2\n.No equivalent to Sy dev\n.It Sy 3\n.No equivalent to Sy none\n.El\n.\n.It Sy zvol_enforce_quotas Ns = Ns Sy 0 Ns | Ns 1 Pq uint\nEnable strict ZVOL quota enforcement.\nThe strict quota enforcement may have a performance impact.\n.El\n.\n.Sh ZFS I/O SCHEDULER\nZFS issues I/O operations to leaf vdevs to satisfy and complete I/O operations.\nThe scheduler determines when and in what order those operations are issued.\nThe scheduler divides operations into five I/O classes,\nprioritized in the following order: sync read, sync write, async read,\nasync write, and scrub/resilver.\nEach queue defines the minimum and maximum number of concurrent operations\nthat may be issued to the device.\nIn addition, the device has an aggregate maximum,\n.Sy zfs_vdev_max_active .\nNote that the sum of the per-queue minima must not exceed the aggregate maximum.\nIf the sum of the per-queue maxima exceeds the aggregate maximum,\nthen the number of active operations may reach\n.Sy zfs_vdev_max_active ,\nin which case no further operations will be issued,\nregardless of whether all per-queue minima have been met.\n.Pp\nFor many physical devices, throughput increases with the number of\nconcurrent operations, but latency typically suffers.\nFurthermore, physical devices typically have a limit\nat which more concurrent operations have no\neffect on throughput or can actually cause it to decrease.\n.Pp\nThe scheduler selects the next operation to issue by first looking for an\nI/O class whose minimum has not been satisfied.\nOnce all are satisfied and the aggregate maximum has not been hit,\nthe scheduler looks for classes whose maximum has not been satisfied.\nIteration through the I/O classes is done in the order specified above.\nNo further operations are issued\nif the aggregate maximum number of concurrent operations has been hit,\nor if there are no operations queued for an I/O class that has not hit its\nmaximum.\nEvery time an I/O operation is queued or an operation completes,\nthe scheduler looks for new operations to issue.\n.Pp\nIn general, smaller\n.Sy max_active Ns s\nwill lead to lower latency of synchronous operations.\nLarger\n.Sy max_active Ns s\nmay lead to higher overall throughput, depending on underlying storage.\n.Pp\nThe ratio of the queues'\n.Sy max_active Ns s\ndetermines the balance of performance between reads, writes, and scrubs.\nFor example, increasing\n.Sy zfs_vdev_scrub_max_active\nwill cause the scrub or resilver to complete more quickly,\nbut reads and writes to have higher latency and lower throughput.\n.Pp\nAll I/O classes have a fixed maximum number of outstanding operations,\nexcept for the async write class.\nAsynchronous writes represent the data that is committed to stable storage\nduring the syncing stage for transaction groups.\nTransaction groups enter the syncing state periodically,\nso the number of queued async writes will quickly burst up\nand then bleed down to zero.\nRather than servicing them as quickly as possible,\nthe I/O scheduler changes the maximum number of active async write operations\naccording to the amount of dirty data in the pool.\nSince both throughput and latency typically increase with the number of\nconcurrent operations issued to physical devices, reducing the\nburstiness in the number of simultaneous operations also stabilizes the\nresponse time of operations from other queues, in particular synchronous ones.\nIn broad strokes, the I/O scheduler will issue more concurrent operations\nfrom the async write queue as there is more dirty data in the pool.\n.\n.Ss Async Writes\nThe number of concurrent operations issued for the async write I/O class\nfollows a piece-wise linear function defined by a few adjustable points:\n.Bd -literal\n       |              o---------| <-- \\fBzfs_vdev_async_write_max_active\\fP\n  ^    |             /^         |\n  |    |            / |         |\nactive |           /  |         |\n I/O   |          /   |         |\ncount  |         /    |         |\n       |        /     |         |\n       |-------o      |         | <-- \\fBzfs_vdev_async_write_min_active\\fP\n      0|_______^______|_________|\n       0%      |      |       100% of \\fBzfs_dirty_data_max\\fP\n               |      |\n               |      `-- \\fBzfs_vdev_async_write_active_max_dirty_percent\\fP\n               `--------- \\fBzfs_vdev_async_write_active_min_dirty_percent\\fP\n.Ed\n.Pp\nUntil the amount of dirty data exceeds a minimum percentage of the dirty\ndata allowed in the pool, the I/O scheduler will limit the number of\nconcurrent operations to the minimum.\nAs that threshold is crossed, the number of concurrent operations issued\nincreases linearly to the maximum at the specified maximum percentage\nof the dirty data allowed in the pool.\n.Pp\nIdeally, the amount of dirty data on a busy pool will stay in the sloped\npart of the function between\n.Sy zfs_vdev_async_write_active_min_dirty_percent\nand\n.Sy zfs_vdev_async_write_active_max_dirty_percent .\nIf it exceeds the maximum percentage,\nthis indicates that the rate of incoming data is\ngreater than the rate that the backend storage can handle.\nIn this case, we must further throttle incoming writes,\nas described in the next section.\n.\n.Sh ZFS TRANSACTION DELAY\nWe delay transactions when we've determined that the backend storage\nisn't able to accommodate the rate of incoming writes.\n.Pp\nIf there is already a transaction waiting, we delay relative to when\nthat transaction will finish waiting.\nThis way the calculated delay time\nis independent of the number of threads concurrently executing transactions.\n.Pp\nIf we are the only waiter, wait relative to when the transaction started,\nrather than the current time.\nThis credits the transaction for \"time already served\",\ne.g. reading indirect blocks.\n.Pp\nThe minimum time for a transaction to take is calculated as\n.D1 min_time = min( Ns Sy zfs_delay_scale No \\(mu Po Sy dirty No \\- Sy min Pc / Po Sy max No \\- Sy dirty Pc , 100ms)\n.Pp\nThe delay has two degrees of freedom that can be adjusted via tunables.\nThe percentage of dirty data at which we start to delay is defined by\n.Sy zfs_delay_min_dirty_percent .\nThis should typically be at or above\n.Sy zfs_vdev_async_write_active_max_dirty_percent ,\nso that we only start to delay after writing at full speed\nhas failed to keep up with the incoming write rate.\nThe scale of the curve is defined by\n.Sy zfs_delay_scale .\nRoughly speaking, this variable determines the amount of delay at the midpoint\nof the curve.\n.Bd -literal\ndelay\n 10ms +-------------------------------------------------------------*+\n      |                                                             *|\n  9ms +                                                             *+\n      |                                                             *|\n  8ms +                                                             *+\n      |                                                            * |\n  7ms +                                                            * +\n      |                                                            * |\n  6ms +                                                            * +\n      |                                                            * |\n  5ms +                                                           *  +\n      |                                                           *  |\n  4ms +                                                           *  +\n      |                                                           *  |\n  3ms +                                                          *   +\n      |                                                          *   |\n  2ms +                                              (midpoint) *    +\n      |                                                  |    **     |\n  1ms +                                                  v ***       +\n      |             \\fBzfs_delay_scale\\fP ---------->     ********         |\n    0 +-------------------------------------*********----------------+\n      0%                    <- \\fBzfs_dirty_data_max\\fP ->               100%\n.Ed\n.Pp\nNote, that since the delay is added to the outstanding time remaining on the\nmost recent transaction it's effectively the inverse of IOPS.\nHere, the midpoint of\n.Em 500 us\ntranslates to\n.Em 2000 IOPS .\nThe shape of the curve\nwas chosen such that small changes in the amount of accumulated dirty data\nin the first three quarters of the curve yield relatively small differences\nin the amount of delay.\n.Pp\nThe effects can be easier to understand when the amount of delay is\nrepresented on a logarithmic scale:\n.Bd -literal\ndelay\n100ms +-------------------------------------------------------------++\n      +                                                              +\n      |                                                              |\n      +                                                             *+\n 10ms +                                                             *+\n      +                                                           ** +\n      |                                              (midpoint)  **  |\n      +                                                  |     **    +\n  1ms +                                                  v ****      +\n      +             \\fBzfs_delay_scale\\fP ---------->        *****         +\n      |                                             ****             |\n      +                                          ****                +\n100us +                                        **                    +\n      +                                       *                      +\n      |                                      *                       |\n      +                                     *                        +\n 10us +                                     *                        +\n      +                                                              +\n      |                                                              |\n      +                                                              +\n      +--------------------------------------------------------------+\n      0%                    <- \\fBzfs_dirty_data_max\\fP ->               100%\n.Ed\n.Pp\nNote here that only as the amount of dirty data approaches its limit does\nthe delay start to increase rapidly.\nThe goal of a properly tuned system should be to keep the amount of dirty data\nout of that range by first ensuring that the appropriate limits are set\nfor the I/O scheduler to reach optimal throughput on the back-end storage,\nand then by changing the value of\n.Sy zfs_delay_scale\nto increase the steepness of the curve.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}