{
  "module_name": "zfs-program.8",
  "hash_id": "6260dee9fb72674781870f0fdc14805856bc7f3da4181ebac4b665bc4ab34782",
  "original_prompt": "Ingested from zfs-2.2.2/man/man8/zfs-program.8",
  "human_readable_source": ".\\\"\n.\\\" This file and its contents are supplied under the terms of the\n.\\\" Common Development and Distribution License (\"CDDL\"), version 1.0.\n.\\\" You may only use this file in accordance with the terms of version\n.\\\" 1.0 of the CDDL.\n.\\\"\n.\\\" A full copy of the text of the CDDL should have accompanied this\n.\\\" source.  A copy of the CDDL is also available via the Internet at\n.\\\" http://www.illumos.org/license/CDDL.\n.\\\"\n.\\\" Copyright (c) 2016, 2019 by Delphix. All Rights Reserved.\n.\\\" Copyright (c) 2019, 2020 by Christian Schwarz. All Rights Reserved.\n.\\\" Copyright 2020 Joyent, Inc.\n.\\\"\n.Dd May 27, 2021\n.Dt ZFS-PROGRAM 8\n.Os\n.\n.Sh NAME\n.Nm zfs-program\n.Nd execute ZFS channel programs\n.Sh SYNOPSIS\n.Nm zfs\n.Cm program\n.Op Fl jn\n.Op Fl t Ar instruction-limit\n.Op Fl m Ar memory-limit\n.Ar pool\n.Ar script\n.Op Ar script arguments\n.\n.Sh DESCRIPTION\nThe ZFS channel program interface allows ZFS administrative operations to be\nrun programmatically as a Lua script.\nThe entire script is executed atomically, with no other administrative\noperations taking effect concurrently.\nA library of ZFS calls is made available to channel program scripts.\nChannel programs may only be run with root privileges.\n.Pp\nA modified version of the Lua 5.2 interpreter is used to run channel program\nscripts.\nThe Lua 5.2 manual can be found at\n.Lk http://www.lua.org/manual/5.2/\n.Pp\nThe channel program given by\n.Ar script\nwill be run on\n.Ar pool ,\nand any attempts to access or modify other pools will cause an error.\n.\n.Sh OPTIONS\n.Bl -tag -width \"-t\"\n.It Fl j\nDisplay channel program output in JSON format.\nWhen this flag is specified and standard output is empty -\nchannel program encountered an error.\nThe details of such an error will be printed to standard error in plain text.\n.It Fl n\nExecutes a read-only channel program, which runs faster.\nThe program cannot change on-disk state by calling functions from the\nzfs.sync submodule.\nThe program can be used to gather information such as properties and\ndetermining if changes would succeed (zfs.check.*).\nWithout this flag, all pending changes must be synced to disk before a\nchannel program can complete.\n.It Fl t Ar instruction-limit\nLimit the number of Lua instructions to execute.\nIf a channel program executes more than the specified number of instructions,\nit will be stopped and an error will be returned.\nThe default limit is 10 million instructions, and it can be set to a maximum of\n100 million instructions.\n.It Fl m Ar memory-limit\nMemory limit, in bytes.\nIf a channel program attempts to allocate more memory than the given limit, it\nwill be stopped and an error returned.\nThe default memory limit is 10 MiB, and can be set to a maximum of 100 MiB.\n.El\n.Pp\nAll remaining argument strings will be passed directly to the Lua script as\ndescribed in the\n.Sx LUA INTERFACE\nsection below.\n.\n.Sh LUA INTERFACE\nA channel program can be invoked either from the command line, or via a library\ncall to\n.Fn lzc_channel_program .\n.\n.Ss Arguments\nArguments passed to the channel program are converted to a Lua table.\nIf invoked from the command line, extra arguments to the Lua script will be\naccessible as an array stored in the argument table with the key 'argv':\n.Bd -literal -compact -offset indent\nargs = ...\nargv = args[\"argv\"]\n-- argv == {1=\"arg1\", 2=\"arg2\", ...}\n.Ed\n.Pp\nIf invoked from the libzfs interface, an arbitrary argument list can be\npassed to the channel program, which is accessible via the same\n.Qq Li ...\nsyntax in Lua:\n.Bd -literal -compact -offset indent\nargs = ...\n-- args == {\"foo\"=\"bar\", \"baz\"={...}, ...}\n.Ed\n.Pp\nNote that because Lua arrays are 1-indexed, arrays passed to Lua from the\nlibzfs interface will have their indices incremented by 1.\nThat is, the element\nin\n.Va arr[0]\nin a C array passed to a channel program will be stored in\n.Va arr[1]\nwhen accessed from Lua.\n.\n.Ss Return Values\nLua return statements take the form:\n.Dl return ret0, ret1, ret2, ...\n.Pp\nReturn statements returning multiple values are permitted internally in a\nchannel program script, but attempting to return more than one value from the\ntop level of the channel program is not permitted and will throw an error.\nHowever, tables containing multiple values can still be returned.\nIf invoked from the command line, a return statement:\n.Bd -literal -compact -offset indent\na = {foo=\"bar\", baz=2}\nreturn a\n.Ed\n.Pp\nWill be output formatted as:\n.Bd -literal -compact -offset indent\nChannel program fully executed with return value:\n    return:\n        baz: 2\n        foo: 'bar'\n.Ed\n.\n.Ss Fatal Errors\nIf the channel program encounters a fatal error while running, a non-zero exit\nstatus will be returned.\nIf more information about the error is available, a singleton list will be\nreturned detailing the error:\n.Dl error: \\&\"error string, including Lua stack trace\"\n.Pp\nIf a fatal error is returned, the channel program may have not executed at all,\nmay have partially executed, or may have fully executed but failed to pass a\nreturn value back to userland.\n.Pp\nIf the channel program exhausts an instruction or memory limit, a fatal error\nwill be generated and the program will be stopped, leaving the program partially\nexecuted.\nNo attempt is made to reverse or undo any operations already performed.\nNote that because both the instruction count and amount of memory used by a\nchannel program are deterministic when run against the same inputs and\nfilesystem state, as long as a channel program has run successfully once, you\ncan guarantee that it will finish successfully against a similar size system.\n.Pp\nIf a channel program attempts to return too large a value, the program will\nfully execute but exit with a nonzero status code and no return value.\n.Pp\n.Em Note :\nZFS API functions do not generate Fatal Errors when correctly invoked, they\nreturn an error code and the channel program continues executing.\nSee the\n.Sx ZFS API\nsection below for function-specific details on error return codes.\n.\n.Ss Lua to C Value Conversion\nWhen invoking a channel program via the libzfs interface, it is necessary to\ntranslate arguments and return values from Lua values to their C equivalents,\nand vice-versa.\n.Pp\nThere is a correspondence between nvlist values in C and Lua tables.\nA Lua table which is returned from the channel program will be recursively\nconverted to an nvlist, with table values converted to their natural\nequivalents:\n.TS\ncw3 l c l .\n\tstring\t->\tstring\n\tnumber\t->\tint64\n\tboolean\t->\tboolean_value\n\tnil\t->\tboolean (no value)\n\ttable\t->\tnvlist\n.TE\n.Pp\nLikewise, table keys are replaced by string equivalents as follows:\n.TS\ncw3 l c l .\n\tstring\t->\tno change\n\tnumber\t->\tsigned decimal string (\"%lld\")\n\tboolean\t->\t\"true\" | \"false\"\n.TE\n.Pp\nAny collision of table key strings (for example, the string \"true\" and a\ntrue boolean value) will cause a fatal error.\n.Pp\nLua numbers are represented internally as signed 64-bit integers.\n.\n.Sh LUA STANDARD LIBRARY\nThe following Lua built-in base library functions are available:\n.TS\ncw3 l l l l .\n\tassert\trawlen\tcollectgarbage\trawget\n\terror\trawset\tgetmetatable\tselect\n\tipairs\tsetmetatable\tnext\ttonumber\n\tpairs\ttostring\trawequal\ttype\n.TE\n.Pp\nAll functions in the\n.Em coroutine ,\n.Em string ,\nand\n.Em table\nbuilt-in submodules are also available.\nA complete list and documentation of these modules is available in the Lua\nmanual.\n.Pp\nThe following functions base library functions have been disabled and are\nnot available for use in channel programs:\n.TS\ncw3 l l l l l l .\n\tdofile\tloadfile\tload\tpcall\tprint\txpcall\n.TE\n.\n.Sh ZFS API\n.\n.Ss Function Arguments\nEach API function takes a fixed set of required positional arguments and\noptional keyword arguments.\nFor example, the destroy function takes a single positional string argument\n(the name of the dataset to destroy) and an optional \"defer\" keyword boolean\nargument.\nWhen using parentheses to specify the arguments to a Lua function, only\npositional arguments can be used:\n.Dl Sy zfs.sync.destroy Ns Pq \\&\"rpool@snap\"\n.Pp\nTo use keyword arguments, functions must be called with a single argument that\nis a Lua table containing entries mapping integers to positional arguments and\nstrings to keyword arguments:\n.Dl Sy zfs.sync.destroy Ns Pq {1=\"rpool@snap\", defer=true}\n.Pp\nThe Lua language allows curly braces to be used in place of parenthesis as\nsyntactic sugar for this calling convention:\n.Dl Sy zfs.sync.snapshot Ns {\"rpool@snap\", defer=true}\n.\n.Ss Function Return Values\nIf an API function succeeds, it returns 0.\nIf it fails, it returns an error code and the channel program continues\nexecuting.\nAPI functions do not generate Fatal Errors except in the case of an\nunrecoverable internal file system error.\n.Pp\nIn addition to returning an error code, some functions also return extra\ndetails describing what caused the error.\nThis extra description is given as a second return value, and will always be a\nLua table, or Nil if no error details were returned.\nDifferent keys will exist in the error details table depending on the function\nand error case.\nAny such function may be called expecting a single return value:\n.Dl errno = Sy zfs.sync.promote Ns Pq dataset\n.Pp\nOr, the error details can be retrieved:\n.Bd -literal -compact -offset indent\n.No errno, details = Sy zfs.sync.promote Ns Pq dataset\nif (errno == EEXIST) then\n    assert(details ~= Nil)\n    list_of_conflicting_snapshots = details\nend\n.Ed\n.Pp\nThe following global aliases for API function error return codes are defined\nfor use in channel programs:\n.TS\ncw3 l l l l l l l .\n\tEPERM\tECHILD\tENODEV\tENOSPC\tENOENT\tEAGAIN\tENOTDIR\n\tESPIPE\tESRCH\tENOMEM\tEISDIR\tEROFS\tEINTR\tEACCES\n\tEINVAL\tEMLINK\tEIO\tEFAULT\tENFILE\tEPIPE\tENXIO\n\tENOTBLK\tEMFILE\tEDOM\tE2BIG\tEBUSY\tENOTTY\tERANGE\n\tENOEXEC\tEEXIST\tETXTBSY\tEDQUOT\tEBADF\tEXDEV\tEFBIG\n.TE\n.\n.Ss API Functions\nFor detailed descriptions of the exact behavior of any ZFS administrative\noperations, see the main\n.Xr zfs 8\nmanual page.\n.Bl -tag -width \"xx\"\n.It Fn zfs.debug msg\nRecord a debug message in the zfs_dbgmsg log.\nA log of these messages can be printed via mdb's \"::zfs_dbgmsg\" command, or\ncan be monitored live by running\n.Dl dtrace -n 'zfs-dbgmsg{trace(stringof(arg0))}'\n.Pp\n.Bl -tag -compact -width \"property (string)\"\n.It Ar msg Pq string\nDebug message to be printed.\n.El\n.It Fn zfs.exists dataset\nReturns true if the given dataset exists, or false if it doesn't.\nA fatal error will be thrown if the dataset is not in the target pool.\nThat is, in a channel program running on rpool,\n.Sy zfs.exists Ns Pq \\&\"rpool/nonexistent_fs\"\nreturns false, but\n.Sy zfs.exists Ns Pq \\&\"somepool/fs_that_may_exist\"\nwill error.\n.Pp\n.Bl -tag -compact -width \"property (string)\"\n.It Ar dataset Pq string\nDataset to check for existence.\nMust be in the target pool.\n.El\n.It Fn zfs.get_prop dataset property\nReturns two values.\nFirst, a string, number or table containing the property value for the given\ndataset.\nSecond, a string containing the source of the property (i.e. the name of the\ndataset in which it was set or nil if it is readonly).\nThrows a Lua error if the dataset is invalid or the property doesn't exist.\nNote that Lua only supports int64 number types whereas ZFS number properties\nare uint64.\nThis means very large values (like GUIDs) may wrap around and appear negative.\n.Pp\n.Bl -tag -compact -width \"property (string)\"\n.It Ar dataset Pq string\nFilesystem or snapshot path to retrieve properties from.\n.It Ar property Pq string\nName of property to retrieve.\nAll filesystem, snapshot and volume properties are supported except for\n.Sy mounted\nand\n.Sy iscsioptions .\nAlso supports the\n.Sy written@ Ns Ar snap\nand\n.Sy written# Ns Ar bookmark\nproperties and the\n.Ao Sy user Ns | Ns Sy group Ac Ns Ao Sy quota Ns | Ns Sy used Ac Ns Sy @ Ns Ar id\nproperties, though the id must be in numeric form.\n.El\n.El\n.Bl -tag -width \"xx\"\n.It Sy zfs.sync submodule\nThe sync submodule contains functions that modify the on-disk state.\nThey are executed in \"syncing context\".\n.Pp\nThe available sync submodule functions are as follows:\n.Bl -tag -width \"xx\"\n.It Sy zfs.sync.destroy Ns Pq Ar dataset , Op Ar defer Ns = Ns Sy true Ns | Ns Sy false\nDestroy the given dataset.\nReturns 0 on successful destroy, or a nonzero error code if the dataset could\nnot be destroyed (for example, if the dataset has any active children or\nclones).\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar dataset Pq string\nFilesystem or snapshot to be destroyed.\n.It Op Ar defer Pq boolean\nValid only for destroying snapshots.\nIf set to true, and the snapshot has holds or clones, allows the snapshot to be\nmarked for deferred deletion rather than failing.\n.El\n.It Fn zfs.sync.inherit dataset property\nClears the specified property in the given dataset, causing it to be inherited\nfrom an ancestor, or restored to the default if no ancestor property is set.\nThe\n.Nm zfs Cm inherit Fl S\noption has not been implemented.\nReturns 0 on success, or a nonzero error code if the property could not be\ncleared.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar dataset Pq string\nFilesystem or snapshot containing the property to clear.\n.It Ar property Pq string\nThe property to clear.\nAllowed properties are the same as those for the\n.Nm zfs Cm inherit\ncommand.\n.El\n.It Fn zfs.sync.promote dataset\nPromote the given clone to a filesystem.\nReturns 0 on successful promotion, or a nonzero error code otherwise.\nIf EEXIST is returned, the second return value will be an array of the clone's\nsnapshots whose names collide with snapshots of the parent filesystem.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar dataset Pq string\nClone to be promoted.\n.El\n.It Fn zfs.sync.rollback filesystem\nRollback to the previous snapshot for a dataset.\nReturns 0 on successful rollback, or a nonzero error code otherwise.\nRollbacks can be performed on filesystems or zvols, but not on snapshots\nor mounted datasets.\nEBUSY is returned in the case where the filesystem is mounted.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar filesystem Pq string\nFilesystem to rollback.\n.El\n.It Fn zfs.sync.set_prop dataset property value\nSets the given property on a dataset.\nCurrently only user properties are supported.\nReturns 0 if the property was set, or a nonzero error code otherwise.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar dataset Pq string\nThe dataset where the property will be set.\n.It Ar property Pq string\nThe property to set.\n.It Ar value Pq string\nThe value of the property to be set.\n.El\n.It Fn zfs.sync.snapshot dataset\nCreate a snapshot of a filesystem.\nReturns 0 if the snapshot was successfully created,\nand a nonzero error code otherwise.\n.Pp\nNote: Taking a snapshot will fail on any pool older than legacy version 27.\nTo enable taking snapshots from ZCP scripts, the pool must be upgraded.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar dataset Pq string\nName of snapshot to create.\n.El\n.It Fn zfs.sync.rename_snapshot dataset oldsnapname newsnapname\nRename a snapshot of a filesystem or a volume.\nReturns 0 if the snapshot was successfully renamed,\nand a nonzero error code otherwise.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar dataset Pq string\nName of the snapshot's parent dataset.\n.It Ar oldsnapname Pq string\nOriginal name of the snapshot.\n.It Ar newsnapname Pq string\nNew name of the snapshot.\n.El\n.It Fn zfs.sync.bookmark source newbookmark\nCreate a bookmark of an existing source snapshot or bookmark.\nReturns 0 if the new bookmark was successfully created,\nand a nonzero error code otherwise.\n.Pp\nNote: Bookmarking requires the corresponding pool feature to be enabled.\n.Pp\n.Bl -tag -compact -width \"newbookmark (string)\"\n.It Ar source Pq string\nFull name of the existing snapshot or bookmark.\n.It Ar newbookmark Pq string\nFull name of the new bookmark.\n.El\n.El\n.It Sy zfs.check submodule\nFor each function in the\n.Sy zfs.sync\nsubmodule, there is a corresponding\n.Sy zfs.check\nfunction which performs a \"dry run\" of the same operation.\nEach takes the same arguments as its\n.Sy zfs.sync\ncounterpart and returns 0 if the operation would succeed,\nor a non-zero error code if it would fail, along with any other error details.\nThat is, each has the same behavior as the corresponding sync function except\nfor actually executing the requested change.\nFor example,\n.Fn zfs.check.destroy \\&\"fs\"\nreturns 0 if\n.Fn zfs.sync.destroy \\&\"fs\"\nwould successfully destroy the dataset.\n.Pp\nThe available\n.Sy zfs.check\nfunctions are:\n.Bl -tag -compact -width \"xx\"\n.It Sy zfs.check.destroy Ns Pq Ar dataset , Op Ar defer Ns = Ns Sy true Ns | Ns Sy false\n.It Fn zfs.check.promote dataset\n.It Fn zfs.check.rollback filesystem\n.It Fn zfs.check.set_property dataset property value\n.It Fn zfs.check.snapshot dataset\n.El\n.It Sy zfs.list submodule\nThe zfs.list submodule provides functions for iterating over datasets and\nproperties.\nRather than returning tables, these functions act as Lua iterators, and are\ngenerally used as follows:\n.Bd -literal -compact -offset indent\n.No for child in Fn zfs.list.children \\&\"rpool\" No do\n    ...\nend\n.Ed\n.Pp\nThe available\n.Sy zfs.list\nfunctions are:\n.Bl -tag -width \"xx\"\n.It Fn zfs.list.clones snapshot\nIterate through all clones of the given snapshot.\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar snapshot Pq string\nMust be a valid snapshot path in the current pool.\n.El\n.It Fn zfs.list.snapshots dataset\nIterate through all snapshots of the given dataset.\nEach snapshot is returned as a string containing the full dataset name,\ne.g. \"pool/fs@snap\".\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar dataset Pq string\nMust be a valid filesystem or volume.\n.El\n.It Fn zfs.list.children dataset\nIterate through all direct children of the given dataset.\nEach child is returned as a string containing the full dataset name,\ne.g. \"pool/fs/child\".\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar dataset Pq string\nMust be a valid filesystem or volume.\n.El\n.It Fn zfs.list.bookmarks dataset\nIterate through all bookmarks of the given dataset.\nEach bookmark is returned as a string containing the full dataset name,\ne.g. \"pool/fs#bookmark\".\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar dataset Pq string\nMust be a valid filesystem or volume.\n.El\n.It Fn zfs.list.holds snapshot\nIterate through all user holds on the given snapshot.\nEach hold is returned\nas a pair of the hold's tag and the timestamp (in seconds since the epoch) at\nwhich it was created.\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar snapshot Pq string\nMust be a valid snapshot.\n.El\n.It Fn zfs.list.properties dataset\nAn alias for zfs.list.user_properties (see relevant entry).\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar dataset Pq string\nMust be a valid filesystem, snapshot, or volume.\n.El\n.It Fn zfs.list.user_properties dataset\nIterate through all user properties for the given dataset.\nFor each step of the iteration, output the property name, its value,\nand its source.\nThrows a Lua error if the dataset is invalid.\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar dataset Pq string\nMust be a valid filesystem, snapshot, or volume.\n.El\n.It Fn zfs.list.system_properties dataset\nReturns an array of strings, the names of the valid system (non-user defined)\nproperties for the given dataset.\nThrows a Lua error if the dataset is invalid.\n.Pp\n.Bl -tag -compact -width \"snapshot (string)\"\n.It Ar dataset Pq string\nMust be a valid filesystem, snapshot or volume.\n.El\n.El\n.El\n.\n.Sh EXAMPLES\n.\n.Ss Example 1\nThe following channel program recursively destroys a filesystem and all its\nsnapshots and children in a naive manner.\nNote that this does not involve any error handling or reporting.\n.Bd -literal -offset indent\nfunction destroy_recursive(root)\n    for child in zfs.list.children(root) do\n        destroy_recursive(child)\n    end\n    for snap in zfs.list.snapshots(root) do\n        zfs.sync.destroy(snap)\n    end\n    zfs.sync.destroy(root)\nend\ndestroy_recursive(\"pool/somefs\")\n.Ed\n.\n.Ss Example 2\nA more verbose and robust version of the same channel program, which\nproperly detects and reports errors, and also takes the dataset to destroy\nas a command line argument, would be as follows:\n.Bd -literal -offset indent\nsucceeded = {}\nfailed = {}\n\nfunction destroy_recursive(root)\n    for child in zfs.list.children(root) do\n        destroy_recursive(child)\n    end\n    for snap in zfs.list.snapshots(root) do\n        err = zfs.sync.destroy(snap)\n        if (err ~= 0) then\n            failed[snap] = err\n        else\n            succeeded[snap] = err\n        end\n    end\n    err = zfs.sync.destroy(root)\n    if (err ~= 0) then\n        failed[root] = err\n    else\n        succeeded[root] = err\n    end\nend\n\nargs = ...\nargv = args[\"argv\"]\n\ndestroy_recursive(argv[1])\n\nresults = {}\nresults[\"succeeded\"] = succeeded\nresults[\"failed\"] = failed\nreturn results\n.Ed\n.\n.Ss Example 3\nThe following function performs a forced promote operation by attempting to\npromote the given clone and destroying any conflicting snapshots.\n.Bd -literal -offset indent\nfunction force_promote(ds)\n   errno, details = zfs.check.promote(ds)\n   if (errno == EEXIST) then\n       assert(details ~= Nil)\n       for i, snap in ipairs(details) do\n           zfs.sync.destroy(ds .. \"@\" .. snap)\n       end\n   elseif (errno ~= 0) then\n       return errno\n   end\n   return zfs.sync.promote(ds)\nend\n.Ed\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}