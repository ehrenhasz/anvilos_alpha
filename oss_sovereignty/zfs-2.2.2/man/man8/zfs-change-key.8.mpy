{
  "module_name": "zfs-change-key.8",
  "hash_id": "30561f8e0963669ecb3684c9b8f81962335082bac2ab20f2b095e2e7c6e33a78",
  "original_prompt": "Ingested from zfs-2.2.2/man/man8/zfs-change-key.8",
  "human_readable_source": ".\\\"\n.\\\" CDDL HEADER START\n.\\\"\n.\\\" The contents of this file are subject to the terms of the\n.\\\" Common Development and Distribution License (the \"License\").\n.\\\" You may not use this file except in compliance with the License.\n.\\\"\n.\\\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n.\\\" or https://opensource.org/licenses/CDDL-1.0.\n.\\\" See the License for the specific language governing permissions\n.\\\" and limitations under the License.\n.\\\"\n.\\\" When distributing Covered Code, include this CDDL HEADER in each\n.\\\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n.\\\" If applicable, add the following below this CDDL HEADER, with the\n.\\\" fields enclosed by brackets \"[]\" replaced with your own identifying\n.\\\" information: Portions Copyright [yyyy] [name of copyright owner]\n.\\\"\n.\\\" CDDL HEADER END\n.\\\"\n.\\\" Copyright (c) 2009 Sun Microsystems, Inc. All Rights Reserved.\n.\\\" Copyright 2011 Joshua M. Clulow <josh@sysmgr.org>\n.\\\" Copyright (c) 2011, 2019 by Delphix. All rights reserved.\n.\\\" Copyright (c) 2013 by Saso Kiselkov. All rights reserved.\n.\\\" Copyright (c) 2014, Joyent, Inc. All rights reserved.\n.\\\" Copyright (c) 2014 by Adam Stevko. All rights reserved.\n.\\\" Copyright (c) 2014 Integros [integros.com]\n.\\\" Copyright 2019 Richard Laager. All rights reserved.\n.\\\" Copyright 2018 Nexenta Systems, Inc.\n.\\\" Copyright 2019 Joyent, Inc.\n.\\\"\n.Dd January 13, 2020\n.Dt ZFS-LOAD-KEY 8\n.Os\n.\n.Sh NAME\n.Nm zfs-load-key\n.Nd load, unload, or change encryption key of ZFS dataset\n.Sh SYNOPSIS\n.Nm zfs\n.Cm load-key\n.Op Fl nr\n.Op Fl L Ar keylocation\n.Fl a Ns | Ns Ar filesystem\n.Nm zfs\n.Cm unload-key\n.Op Fl r\n.Fl a Ns | Ns Ar filesystem\n.Nm zfs\n.Cm change-key\n.Op Fl l\n.Op Fl o Ar keylocation Ns = Ns Ar value\n.Op Fl o Ar keyformat Ns = Ns Ar value\n.Op Fl o Ar pbkdf2iters Ns = Ns Ar value\n.Ar filesystem\n.Nm zfs\n.Cm change-key\n.Fl i\n.Op Fl l\n.Ar filesystem\n.\n.Sh DESCRIPTION\n.Bl -tag -width \"\"\n.It Xo\n.Nm zfs\n.Cm load-key\n.Op Fl nr\n.Op Fl L Ar keylocation\n.Fl a Ns | Ns Ar filesystem\n.Xc\nLoad the key for\n.Ar filesystem ,\nallowing it and all children that inherit the\n.Sy keylocation\nproperty to be accessed.\nThe key will be expected in the format specified by the\n.Sy keyformat\nand location specified by the\n.Sy keylocation\nproperty.\nNote that if the\n.Sy keylocation\nis set to\n.Sy prompt\nthe terminal will interactively wait for the key to be entered.\nLoading a key will not automatically mount the dataset.\nIf that functionality is desired,\n.Nm zfs Cm mount Fl l\nwill ask for the key and mount the dataset\n.Po\nsee\n.Xr zfs-mount 8\n.Pc .\nOnce the key is loaded the\n.Sy keystatus\nproperty will become\n.Sy available .\n.Bl -tag -width \"-r\"\n.It Fl r\nRecursively loads the keys for the specified filesystem and all descendent\nencryption roots.\n.It Fl a\nLoads the keys for all encryption roots in all imported pools.\n.It Fl n\nDo a dry-run\n.Pq Qq No-op\n.Cm load-key .\nThis will cause\n.Nm zfs\nto simply check that the provided key is correct.\nThis command may be run even if the key is already loaded.\n.It Fl L Ar keylocation\nUse\n.Ar keylocation\ninstead of the\n.Sy keylocation\nproperty.\nThis will not change the value of the property on the dataset.\nNote that if used with either\n.Fl r\nor\n.Fl a ,\n.Ar keylocation\nmay only be given as\n.Sy prompt .\n.El\n.It Xo\n.Nm zfs\n.Cm unload-key\n.Op Fl r\n.Fl a Ns | Ns Ar filesystem\n.Xc\nUnloads a key from ZFS, removing the ability to access the dataset and all of\nits children that inherit the\n.Sy keylocation\nproperty.\nThis requires that the dataset is not currently open or mounted.\nOnce the key is unloaded the\n.Sy keystatus\nproperty will become\n.Sy unavailable .\n.Bl -tag -width \"-r\"\n.It Fl r\nRecursively unloads the keys for the specified filesystem and all descendent\nencryption roots.\n.It Fl a\nUnloads the keys for all encryption roots in all imported pools.\n.El\n.It Xo\n.Nm zfs\n.Cm change-key\n.Op Fl l\n.Op Fl o Ar keylocation Ns = Ns Ar value\n.Op Fl o Ar keyformat Ns = Ns Ar value\n.Op Fl o Ar pbkdf2iters Ns = Ns Ar value\n.Ar filesystem\n.Xc\n.It Xo\n.Nm zfs\n.Cm change-key\n.Fl i\n.Op Fl l\n.Ar filesystem\n.Xc\nChanges the user's key (e.g. a passphrase) used to access a dataset.\nThis command requires that the existing key for the dataset is already loaded.\nThis command may also be used to change the\n.Sy keylocation ,\n.Sy keyformat ,\nand\n.Sy pbkdf2iters\nproperties as needed.\nIf the dataset was not previously an encryption root it will become one.\nAlternatively, the\n.Fl i\nflag may be provided to cause an encryption root to inherit the parent's key\ninstead.\n.Pp\nIf the user's key is compromised,\n.Nm zfs Cm change-key\ndoes not necessarily protect existing or newly-written data from attack.\nNewly-written data will continue to be encrypted with the same master key as\nthe existing data.\nThe master key is compromised if an attacker obtains a\nuser key and the corresponding wrapped master key.\nCurrently,\n.Nm zfs Cm change-key\ndoes not overwrite the previous wrapped master key on disk, so it is\naccessible via forensic analysis for an indeterminate length of time.\n.Pp\nIn the event of a master key compromise, ideally the drives should be securely\nerased to remove all the old data (which is readable using the compromised\nmaster key), a new pool created, and the data copied back.\nThis can be approximated in place by creating new datasets, copying the data\n.Pq e.g. using Nm zfs Cm send | Nm zfs Cm recv ,\nand then clearing the free space with\n.Nm zpool Cm trim Fl -secure\nif supported by your hardware, otherwise\n.Nm zpool Cm initialize .\n.Bl -tag -width \"-r\"\n.It Fl l\nEnsures the key is loaded before attempting to change the key.\nThis is effectively equivalent to running\n.Nm zfs Cm load-key Ar filesystem ; Nm zfs Cm change-key Ar filesystem\n.It Fl o Ar property Ns = Ns Ar value\nAllows the user to set encryption key properties\n.Pq Sy keyformat , keylocation , No and Sy pbkdf2iters\nwhile changing the key.\nThis is the only way to alter\n.Sy keyformat\nand\n.Sy pbkdf2iters\nafter the dataset has been created.\n.It Fl i\nIndicates that zfs should make\n.Ar filesystem\ninherit the key of its parent.\nNote that this command can only be run on an encryption root\nthat has an encrypted parent.\n.El\n.El\n.Ss Encryption\nEnabling the\n.Sy encryption\nfeature allows for the creation of encrypted filesystems and volumes.\nZFS will encrypt file and volume data, file attributes, ACLs, permission bits,\ndirectory listings, FUID mappings, and\n.Sy userused Ns / Ns Sy groupused\ndata.\nZFS will not encrypt metadata related to the pool structure, including\ndataset and snapshot names, dataset hierarchy, properties, file size, file\nholes, and deduplication tables (though the deduplicated data itself is\nencrypted).\n.Pp\nKey rotation is managed by ZFS.\nChanging the user's key (e.g. a passphrase)\ndoes not require re-encrypting the entire dataset.\nDatasets can be scrubbed,\nresilvered, renamed, and deleted without the encryption keys being loaded (see\nthe\n.Cm load-key\nsubcommand for more info on key loading).\n.Pp\nCreating an encrypted dataset requires specifying the\n.Sy encryption No and Sy keyformat\nproperties at creation time, along with an optional\n.Sy keylocation No and Sy pbkdf2iters .\nAfter entering an encryption key, the\ncreated dataset will become an encryption root.\nAny descendant datasets will\ninherit their encryption key from the encryption root by default, meaning that\nloading, unloading, or changing the key for the encryption root will implicitly\ndo the same for all inheriting datasets.\nIf this inheritance is not desired, simply supply a\n.Sy keyformat\nwhen creating the child dataset or use\n.Nm zfs Cm change-key\nto break an existing relationship, creating a new encryption root on the child.\nNote that the child's\n.Sy keyformat\nmay match that of the parent while still creating a new encryption root, and\nthat changing the\n.Sy encryption\nproperty alone does not create a new encryption root; this would simply use a\ndifferent cipher suite with the same key as its encryption root.\nThe one exception is that clones will always use their origin's encryption key.\nAs a result of this exception, some encryption-related properties\n.Pq namely Sy keystatus , keyformat ,  keylocation , No and Sy pbkdf2iters\ndo not inherit like other ZFS properties and instead use the value determined\nby their encryption root.\nEncryption root inheritance can be tracked via the read-only\n.Sy encryptionroot\nproperty.\n.Pp\nEncryption changes the behavior of a few ZFS\noperations.\nEncryption is applied after compression so compression ratios are preserved.\nNormally checksums in ZFS are 256 bits long, but for encrypted data\nthe checksum is 128 bits of the user-chosen checksum and 128 bits of MAC from\nthe encryption suite, which provides additional protection against maliciously\naltered data.\nDeduplication is still possible with encryption enabled but for security,\ndatasets will only deduplicate against themselves, their snapshots,\nand their clones.\n.Pp\nThere are a few limitations on encrypted datasets.\nEncrypted data cannot be embedded via the\n.Sy embedded_data\nfeature.\nEncrypted datasets may not have\n.Sy copies Ns = Ns Em 3\nsince the implementation stores some encryption metadata where the third copy\nwould normally be.\nSince compression is applied before encryption, datasets may\nbe vulnerable to a CRIME-like attack if applications accessing the data allow\nfor it.\nDeduplication with encryption will leak information about which blocks\nare equivalent in a dataset and will incur an extra CPU cost for each block\nwritten.\n.\n.Sh SEE ALSO\n.Xr zfsprops 7 ,\n.Xr zfs-create 8 ,\n.Xr zfs-set 8\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}