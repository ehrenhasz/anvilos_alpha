{
  "module_name": "cstyle.pl",
  "hash_id": "6e0983e2b8f68757682f648d3ec77c79c53edbb00d21e896a21c36b32ed3cb63",
  "original_prompt": "Ingested from zfs-2.2.2/scripts/cstyle.pl",
  "human_readable_source": "#!/usr/bin/env perl\n#\n# CDDL HEADER START\n#\n# The contents of this file are subject to the terms of the\n# Common Development and Distribution License (the \"License\").\n# You may not use this file except in compliance with the License.\n#\n# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n# or https://opensource.org/licenses/CDDL-1.0.\n# See the License for the specific language governing permissions\n# and limitations under the License.\n#\n# When distributing Covered Code, include this CDDL HEADER in each\n# file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n# If applicable, add the following below this CDDL HEADER, with the\n# fields enclosed by brackets \"[]\" replaced with your own identifying\n# information: Portions Copyright [yyyy] [name of copyright owner]\n#\n# CDDL HEADER END\n#\n# Copyright 2016 Nexenta Systems, Inc.\n#\n# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.\n# Use is subject to license terms.\n#\n# @(#)cstyle 1.58 98/09/09 (from shannon)\n#ident\t\"%Z%%M%\t%I%\t%E% SMI\"\n#\n# cstyle - check for some common stylistic errors.\n#\n#\tcstyle is a sort of \"lint\" for C coding style.\n#\tIt attempts to check for the style used in the\n#\tkernel, sometimes known as \"Bill Joy Normal Form\".\n#\n#\tThere's a lot this can't check for, like proper indentation\n#\tof code blocks.  There's also a lot more this could check for.\n#\n#\tA note to the non perl literate:\n#\n#\t\tperl regular expressions are pretty much like egrep\n#\t\tregular expressions, with the following special symbols\n#\n#\t\t\\s\tany space character\n#\t\t\\S\tany non-space character\n#\t\t\\w\tany \"word\" character [a-zA-Z0-9_]\n#\t\t\\W\tany non-word character\n#\t\t\\d\ta digit [0-9]\n#\t\t\\D\ta non-digit\n#\t\t\\b\tword boundary (between \\w and \\W)\n#\t\t\\B\tnon-word boundary\n#\n\nrequire 5.0;\nuse warnings;\nuse IO::File;\nuse Getopt::Std;\nuse strict;\n\nmy $usage =\n\"usage: cstyle [-cgpvP] file...\n\t-c\tcheck continuation indentation inside functions\n\t-g\tprint github actions' workflow commands\n\t-p\tperform some of the more picky checks\n\t-v\tverbose\n\t-P\tcheck for use of non-POSIX types\n\";\n\nmy %opts;\n\nif (!getopts(\"cghpvCP\", \\%opts)) {\n\tprint $usage;\n\texit 2;\n}\n\nmy $check_continuation = $opts{'c'};\nmy $github_workflow = $opts{'g'} || $ENV{'CI'};\nmy $picky = $opts{'p'};\nmy $verbose = $opts{'v'};\nmy $check_posix_types = $opts{'P'};\n\nmy ($filename, $line, $prev);\t\t# shared globals\n\nmy $fmt;\nmy $hdr_comment_start;\n\nif ($verbose) {\n\t$fmt = \"%s: %d: %s\\n%s\\n\";\n} else {\n\t$fmt = \"%s: %d: %s\\n\";\n}\n\n$hdr_comment_start = qr/^\\s*\\/\\*$/;\n\n# Note, following must be in single quotes so that \\s and \\w work right.\nmy $typename = '(int|char|short|long|unsigned|float|double' .\n    '|\\w+_t|struct\\s+\\w+|union\\s+\\w+|FILE)';\n\n# mapping of old types to POSIX compatible types\nmy %old2posix = (\n\t'unchar' => 'uchar_t',\n\t'ushort' => 'ushort_t',\n\t'uint' => 'uint_t',\n\t'ulong' => 'ulong_t',\n\t'u_int' => 'uint_t',\n\t'u_short' => 'ushort_t',\n\t'u_long' => 'ulong_t',\n\t'u_char' => 'uchar_t',\n\t'quad' => 'quad_t'\n);\n\nmy $lint_re = qr/\\/\\*(?:\n\tNOTREACHED|LINTLIBRARY|VARARGS[0-9]*|\n\tCONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY|\n\tFALLTHRU|FALLTHROUGH|LINTED.*?|PRINTFLIKE[0-9]*|\n\tPROTOLIB[0-9]*|SCANFLIKE[0-9]*|CSTYLED.*?\n    )\\*\\//x;\n\nmy $warlock_re = qr/\\/\\*\\s*(?:\n\tVARIABLES\\ PROTECTED\\ BY|\n\tMEMBERS\\ PROTECTED\\ BY|\n\tALL\\ MEMBERS\\ PROTECTED\\ BY|\n\tREAD-ONLY\\ VARIABLES:|\n\tREAD-ONLY\\ MEMBERS:|\n\tVARIABLES\\ READABLE\\ WITHOUT\\ LOCK:|\n\tMEMBERS\\ READABLE\\ WITHOUT\\ LOCK:|\n\tLOCKS\\ COVERED\\ BY|\n\tLOCK\\ UNNEEDED\\ BECAUSE|\n\tLOCK\\ NEEDED:|\n\tLOCK\\ HELD\\ ON\\ ENTRY:|\n\tREAD\\ LOCK\\ HELD\\ ON\\ ENTRY:|\n\tWRITE\\ LOCK\\ HELD\\ ON\\ ENTRY:|\n\tLOCK\\ ACQUIRED\\ AS\\ SIDE\\ EFFECT:|\n\tREAD\\ LOCK\\ ACQUIRED\\ AS\\ SIDE\\ EFFECT:|\n\tWRITE\\ LOCK\\ ACQUIRED\\ AS\\ SIDE\\ EFFECT:|\n\tLOCK\\ RELEASED\\ AS\\ SIDE\\ EFFECT:|\n\tLOCK\\ UPGRADED\\ AS\\ SIDE\\ EFFECT:|\n\tLOCK\\ DOWNGRADED\\ AS\\ SIDE\\ EFFECT:|\n\tFUNCTIONS\\ CALLED\\ THROUGH\\ POINTER|\n\tFUNCTIONS\\ CALLED\\ THROUGH\\ MEMBER|\n\tLOCK\\ ORDER:\n    )/x;\n\nmy $err_stat = 0;\t\t# exit status\n\nif ($#ARGV >= 0) {\n\tforeach my $arg (@ARGV) {\n\t\tmy $fh = new IO::File $arg, \"r\";\n\t\tif (!defined($fh)) {\n\t\t\tprintf \"%s: can not open\\n\", $arg;\n\t\t} else {\n\t\t\t&cstyle($arg, $fh);\n\t\t\tclose $fh;\n\t\t}\n\t}\n} else {\n\t&cstyle(\"<stdin>\", *STDIN);\n}\nexit $err_stat;\n\nmy $no_errs = 0;\t\t# set for CSTYLED-protected lines\n\nsub err($) {\n\tmy ($error) = @_;\n\tunless ($no_errs) {\n\t\tif ($verbose) {\n\t\t\tprintf $fmt, $filename, $., $error, $line;\n\t\t} else {\n\t\t\tprintf $fmt, $filename, $., $error;\n\t\t}\n\t\tif ($github_workflow) {\n\t\t\tprintf \"::error file=%s,line=%s::%s\\n\", $filename, $., $error;\n\t\t}\n\t\t$err_stat = 1;\n\t}\n}\n\nsub err_prefix($$) {\n\tmy ($prevline, $error) = @_;\n\tmy $out = $prevline.\"\\n\".$line;\n\tunless ($no_errs) {\n\t\tif ($verbose) {\n\t\t\tprintf $fmt, $filename, $., $error, $out;\n\t\t} else {\n\t\t\tprintf $fmt, $filename, $., $error;\n\t\t}\n\t\t$err_stat = 1;\n\t}\n}\n\nsub err_prev($) {\n\tmy ($error) = @_;\n\tunless ($no_errs) {\n\t\tif ($verbose) {\n\t\t\tprintf $fmt, $filename, $. - 1, $error, $prev;\n\t\t} else {\n\t\t\tprintf $fmt, $filename, $. - 1, $error;\n\t\t}\n\t\t$err_stat = 1;\n\t}\n}\n\nsub cstyle($$) {\n\nmy ($fn, $filehandle) = @_;\n$filename = $fn;\t\t\t# share it globally\n\nmy $in_cpp = 0;\nmy $next_in_cpp = 0;\n\nmy $in_comment = 0;\nmy $comment_done = 0;\nmy $in_warlock_comment = 0;\nmy $in_function = 0;\nmy $in_function_header = 0;\nmy $function_header_full_indent = 0;\nmy $in_declaration = 0;\nmy $note_level = 0;\nmy $nextok = 0;\nmy $nocheck = 0;\n\nmy $in_string = 0;\n\nmy ($okmsg, $comment_prefix);\n\n$line = '';\n$prev = '';\nreset_indent();\n\nline: while (<$filehandle>) {\n\ts/\\r?\\n$//;\t# strip return and newline\n\n\t# save the original line, then remove all text from within\n\t# double or single quotes, we do not want to check such text.\n\n\t$line = $_;\n\n\t#\n\t# C allows strings to be continued with a backslash at the end of\n\t# the line.  We translate that into a quoted string on the previous\n\t# line followed by an initial quote on the next line.\n\t#\n\t# (we assume that no-one will use backslash-continuation with character\n\t# constants)\n\t#\n\t$_ = '\"' . $_\t\tif ($in_string && !$nocheck && !$in_comment);\n\n\t#\n\t# normal strings and characters\n\t#\n\ts/'([^\\\\']|\\\\[^xX0]|\\\\0[0-9]*|\\\\[xX][0-9a-fA-F]*)'/''/g;\n\ts/\"([^\\\\\"]|\\\\.)*\"/\\\"\\\"/g;\n\n\t#\n\t# detect string continuation\n\t#\n\tif ($nocheck || $in_comment) {\n\t\t$in_string = 0;\n\t} else {\n\t\t#\n\t\t# Now that all full strings are replaced with \"\", we check\n\t\t# for unfinished strings continuing onto the next line.\n\t\t#\n\t\t$in_string =\n\t\t    (s/([^\"](?:\"\")*)\"([^\\\\\"]|\\\\.)*\\\\$/$1\"\"/ ||\n\t\t    s/^(\"\")*\"([^\\\\\"]|\\\\.)*\\\\$/\"\"/);\n\t}\n\n\t#\n\t# figure out if we are in a cpp directive\n\t#\n\t$in_cpp = $next_in_cpp || /^\\s*#/;\t# continued or started\n\t$next_in_cpp = $in_cpp && /\\\\$/;\t# only if continued\n\n\t# strip off trailing backslashes, which appear in long macros\n\ts/\\s*\\\\$//;\n\n\t# an /* END CSTYLED */ comment ends a no-check block.\n\tif ($nocheck) {\n\t\tif (/\\/\\* *END *CSTYLED *\\*\\//) {\n\t\t\t$nocheck = 0;\n\t\t} else {\n\t\t\treset_indent();\n\t\t\tnext line;\n\t\t}\n\t}\n\n\t# a /*CSTYLED*/ comment indicates that the next line is ok.\n\tif ($nextok) {\n\t\tif ($okmsg) {\n\t\t\terr($okmsg);\n\t\t}\n\t\t$nextok = 0;\n\t\t$okmsg = 0;\n\t\tif (/\\/\\* *CSTYLED.*\\*\\//) {\n\t\t\t/^.*\\/\\* *CSTYLED *(.*) *\\*\\/.*$/;\n\t\t\t$okmsg = $1;\n\t\t\t$nextok = 1;\n\t\t}\n\t\t$no_errs = 1;\n\t} elsif ($no_errs) {\n\t\t$no_errs = 0;\n\t}\n\n\t# check length of line.\n\t# first, a quick check to see if there is any chance of being too long.\n\tif (($line =~ tr/\\t/\\t/) * 7 + length($line) > 80) {\n\t\t# yes, there is a chance.\n\t\t# replace tabs with spaces and check again.\n\t\tmy $eline = $line;\n\t\t1 while $eline =~\n\t\t    s/\\t+/' ' x (length($&) * 8 - length($`) % 8)/e;\n\t\tif (length($eline) > 80) {\n\t\t\terr(\"line > 80 characters\");\n\t\t}\n\t}\n\n\t# ignore NOTE(...) annotations (assumes NOTE is on lines by itself).\n\tif ($note_level || /\\b_?NOTE\\s*\\(/) { # if in NOTE or this is NOTE\n\t\ts/[^()]//g;\t\t\t  # eliminate all non-parens\n\t\t$note_level += s/\\(//g - length;  # update paren nest level\n\t\tnext;\n\t}\n\n\t# a /* BEGIN CSTYLED */ comment starts a no-check block.\n\tif (/\\/\\* *BEGIN *CSTYLED *\\*\\//) {\n\t\t$nocheck = 1;\n\t}\n\n\t# a /*CSTYLED*/ comment indicates that the next line is ok.\n\tif (/\\/\\* *CSTYLED.*\\*\\//) {\n\t\t/^.*\\/\\* *CSTYLED *(.*) *\\*\\/.*$/;\n\t\t$okmsg = $1;\n\t\t$nextok = 1;\n\t}\n\tif (/\\/\\/ *CSTYLED/) {\n\t\t/^.*\\/\\/ *CSTYLED *(.*)$/;\n\t\t$okmsg = $1;\n\t\t$nextok = 1;\n\t}\n\n\t# universal checks; apply to everything\n\tif (/\\t +\\t/) {\n\t\terr(\"spaces between tabs\");\n\t}\n\tif (/ \\t+ /) {\n\t\terr(\"tabs between spaces\");\n\t}\n\tif (/\\s$/) {\n\t\terr(\"space or tab at end of line\");\n\t}\n\tif (/[^ \\t(]\\/\\*/ && !/\\w\\(\\/\\*.*\\*\\/\\);/) {\n\t\terr(\"comment preceded by non-blank\");\n\t}\n\tif (/ARGSUSED/) {\n\t\terr(\"ARGSUSED directive\");\n\t}\n\n\t# is this the beginning or ending of a function?\n\t# (not if \"struct foo\\n{\\n\")\n\tif (/^\\{$/ && $prev =~ /\\)\\s*(const\\s*)?(\\/\\*.*\\*\\/\\s*)?\\\\?$/) {\n\t\t$in_function = 1;\n\t\t$in_declaration = 1;\n\t\t$in_function_header = 0;\n\t\t$function_header_full_indent = 0;\n\t\t$prev = $line;\n\t\tnext line;\n\t}\n\tif (/^\\}\\s*(\\/\\*.*\\*\\/\\s*)*$/) {\n\t\tif ($prev =~ /^\\s*return\\s*;/) {\n\t\t\terr_prev(\"unneeded return at end of function\");\n\t\t}\n\t\t$in_function = 0;\n\t\treset_indent();\t\t# we don't check between functions\n\t\t$prev = $line;\n\t\tnext line;\n\t}\n\tif ($in_function_header && ! /^    (\\w|\\.)/ ) {\n\t\tif (/^\\{\\}$/ # empty functions\n\t\t|| /;/ #run function with multiline arguments\n\t\t|| /#/ #preprocessor commands\n\t\t|| /^[^\\s\\\\]*\\(.*\\)$/ #functions without ; at the end\n\t\t|| /^$/ #function declaration can't have empty line\n\t\t) {\n\t\t\t$in_function_header = 0;\n\t\t\t$function_header_full_indent = 0;\n\t\t} elsif ($prev =~ /^__attribute__/) { #__attribute__((*))\n\t\t\t$in_function_header = 0;\n\t\t\t$function_header_full_indent = 0;\n\t\t\t$prev = $line;\n\t\t\tnext line;\n\t\t} elsif ($picky\t&& ! (/^\\t/ && $function_header_full_indent != 0)) {\n\n\t\t\terr(\"continuation line should be indented by 4 spaces\");\n\t\t}\n\t}\n\n\t#\n\t# If this matches something of form \"foo(\", it's probably a function\n\t# definition, unless it ends with \") bar;\", in which case it's a declaration\n\t# that uses a macro to generate the type.\n\t#\n\tif (/^\\w+\\(/ && !/\\) \\w+;/) {\n\t\t$in_function_header = 1;\n\t\tif (/\\($/) {\n\t\t\t$function_header_full_indent = 1;\n\t\t}\n\t}\n\tif ($in_function_header && /^\\{$/) {\n\t\t$in_function_header = 0;\n\t\t$function_header_full_indent = 0;\n\t\t$in_function = 1;\n\t}\n\tif ($in_function_header && /\\);$/) {\n\t\t$in_function_header = 0;\n\t\t$function_header_full_indent = 0;\n\t}\n\tif ($in_function_header && /\\{$/ ) {\n\t\tif ($picky) {\n\t\t\terr(\"opening brace on same line as function header\");\n\t\t}\n\t\t$in_function_header = 0;\n\t\t$function_header_full_indent = 0;\n\t\t$in_function = 1;\n\t\tnext line;\n\t}\n\n\tif ($in_warlock_comment && /\\*\\//) {\n\t\t$in_warlock_comment = 0;\n\t\t$prev = $line;\n\t\tnext line;\n\t}\n\n\t# a blank line terminates the declarations within a function.\n\t# XXX - but still a problem in sub-blocks.\n\tif ($in_declaration && /^$/) {\n\t\t$in_declaration = 0;\n\t}\n\n\tif ($comment_done) {\n\t\t$in_comment = 0;\n\t\t$comment_done = 0;\n\t}\n\t# does this looks like the start of a block comment?\n\tif (/$hdr_comment_start/) {\n\t\tif (!/^\\t*\\/\\*/) {\n\t\t\terr(\"block comment not indented by tabs\");\n\t\t}\n\t\t$in_comment = 1;\n\t\t/^(\\s*)\\//;\n\t\t$comment_prefix = $1;\n\t\t$prev = $line;\n\t\tnext line;\n\t}\n\t# are we still in the block comment?\n\tif ($in_comment) {\n\t\tif (/^$comment_prefix \\*\\/$/) {\n\t\t\t$comment_done = 1;\n\t\t} elsif (/\\*\\//) {\n\t\t\t$comment_done = 1;\n\t\t\terr(\"improper block comment close\");\n\t\t} elsif (!/^$comment_prefix \\*[ \\t]/ &&\n\t\t    !/^$comment_prefix \\*$/) {\n\t\t\terr(\"improper block comment\");\n\t\t}\n\t}\n\n\t# check for errors that might occur in comments and in code.\n\n\t# allow spaces to be used to draw pictures in all comments.\n\tif (/[^ ]     / && !/\".*     .*\"/ && !$in_comment) {\n\t\terr(\"spaces instead of tabs\");\n\t}\n\tif (/^ / && !/^ \\*[ \\t\\/]/ && !/^ \\*$/ &&\n\t    (!/^    (\\w|\\.)/ || $in_function != 0)) {\n\t\terr(\"indent by spaces instead of tabs\");\n\t}\n\tif (/^\\t+ [^ \\t\\*]/ || /^\\t+  \\S/ || /^\\t+   \\S/) {\n\t\terr(\"continuation line not indented by 4 spaces\");\n\t}\n\tif (/$warlock_re/ && !/\\*\\//) {\n\t\t$in_warlock_comment = 1;\n\t\t$prev = $line;\n\t\tnext line;\n\t}\n\tif (/^\\s*\\/\\*./ && !/^\\s*\\/\\*.*\\*\\// && !/$hdr_comment_start/) {\n\t\terr(\"improper first line of block comment\");\n\t}\n\n\tif ($in_comment) {\t# still in comment, don't do further checks\n\t\t$prev = $line;\n\t\tnext line;\n\t}\n\n\tif ((/[^(]\\/\\*\\S/ || /^\\/\\*\\S/) && !/$lint_re/) {\n\t\terr(\"missing blank after open comment\");\n\t}\n\tif (/\\S\\*\\/[^)]|\\S\\*\\/$/ && !/$lint_re/) {\n\t\terr(\"missing blank before close comment\");\n\t}\n\t# check for unterminated single line comments, but allow them when\n\t# they are used to comment out the argument list of a function\n\t# declaration.\n\tif (/\\S.*\\/\\*/ && !/\\S.*\\/\\*.*\\*\\// && !/\\(\\/\\*/) {\n\t\terr(\"unterminated single line comment\");\n\t}\n\n\tif (/^(#else|#endif|#include)(.*)$/) {\n\t\t$prev = $line;\n\t\tif ($picky) {\n\t\t\tmy $directive = $1;\n\t\t\tmy $clause = $2;\n\t\t\t# Enforce ANSI rules for #else and #endif: no noncomment\n\t\t\t# identifiers are allowed after #endif or #else.  Allow\n\t\t\t# C++ comments since they seem to be a fact of life.\n\t\t\tif ((($1 eq \"#endif\") || ($1 eq \"#else\")) &&\n\t\t\t    ($clause ne \"\") &&\n\t\t\t    (!($clause =~ /^\\s+\\/\\*.*\\*\\/$/)) &&\n\t\t\t    (!($clause =~ /^\\s+\\/\\/.*$/))) {\n\t\t\t\terr(\"non-comment text following \" .\n\t\t\t\t    \"$directive (or malformed $directive \" .\n\t\t\t\t    \"directive)\");\n\t\t\t}\n\t\t}\n\t\tnext line;\n\t}\n\n\t#\n\t# delete any comments and check everything else.  Note that\n\t# \".*?\" is a non-greedy match, so that we don't get confused by\n\t# multiple comments on the same line.\n\t#\n\ts/\\/\\*.*?\\*\\//\u0001/g;\n\ts/\\/\\/(?:\\s.*)?$/\u0001/;\t# Valid C++ comments\n\n\t# After stripping correctly spaced comments, check for (and strip) comments\n\t# without a blank.  By checking this after clearing out C++ comments that\n\t# correctly have a blank, we guarantee URIs in a C++ comment will not cause\n\t# an error.\n\tif (s!//.*$!\u0001!) {\t\t# C++ comments\n\t\terr(\"missing blank after start comment\");\n\t}\n\n\t# delete any trailing whitespace; we have already checked for that.\n\ts/\\s*$//;\n\n\t# following checks do not apply to text in comments.\n\n\tif (/[^<>\\s][!<>=]=/ || /[^<>][!<>=]=[^\\s,]/ ||\n\t    (/[^->]>[^,=>\\s]/ && !/[^->]>$/) ||\n\t    (/[^<]<[^,=<\\s]/ && !/[^<]<$/) ||\n\t    /[^<\\s]<[^<]/ || /[^->\\s]>[^>]/) {\n\t\terr(\"missing space around relational operator\");\n\t}\n\tif (/\\S>>=/ || /\\S<<=/ || />>=\\S/ || /<<=\\S/ || /\\S[-+*\\/&|^%]=/ ||\n\t    (/[^-+*\\/&|^%!<>=\\s]=[^=]/ && !/[^-+*\\/&|^%!<>=\\s]=$/) ||\n\t    (/[^!<>=]=[^=\\s]/ && !/[^!<>=]=$/)) {\n\t\t# XXX - should only check this for C++ code\n\t\t# XXX - there are probably other forms that should be allowed\n\t\tif (!/\\soperator=/) {\n\t\t\terr(\"missing space around assignment operator\");\n\t\t}\n\t}\n\tif (/[,;]\\S/ && !/\\bfor \\(;;\\)/) {\n\t\terr(\"comma or semicolon followed by non-blank\");\n\t}\n\t# allow \"for\" statements to have empty \"while\" clauses\n\tif (/\\s[,;]/ && !/^[\\t]+;$/ && !/^\\s*for \\([^;]*; ;[^;]*\\)/) {\n\t\terr(\"comma or semicolon preceded by blank\");\n\t}\n\tif (/^\\s*(&&|\\|\\|)/) {\n\t\terr(\"improper boolean continuation\");\n\t}\n\tif (/\\S   *(&&|\\|\\|)/ || /(&&|\\|\\|)   *\\S/) {\n\t\terr(\"more than one space around boolean operator\");\n\t}\n\tif (/\\b(for|if|while|switch|sizeof|return|case)\\(/) {\n\t\terr(\"missing space between keyword and paren\");\n\t}\n\tif (/(\\b(for|if|while|switch|return)\\b.*){2,}/ && !/^#define/) {\n\t\t# multiple \"case\" and \"sizeof\" allowed\n\t\terr(\"more than one keyword on line\");\n\t}\n\tif (/\\b(for|if|while|switch|sizeof|return|case)\\s\\s+\\(/ &&\n\t    !/^#if\\s+\\(/) {\n\t\terr(\"extra space between keyword and paren\");\n\t}\n\t# try to detect \"func (x)\" but not \"if (x)\" or\n\t# \"#define foo (x)\" or \"int (*func)();\"\n\tif (/\\w\\s\\(/) {\n\t\tmy $s = $_;\n\t\t# strip off all keywords on the line\n\t\ts/\\b(for|if|while|switch|return|case|sizeof)\\s\\(/XXX(/g;\n\t\ts/#elif\\s\\(/XXX(/g;\n\t\ts/^#define\\s+\\w+\\s+\\(/XXX(/;\n\t\t# do not match things like \"void (*f)();\"\n\t\t# or \"typedef void (func_t)();\"\n\t\ts/\\w\\s\\(+\\*/XXX(*/g;\n\t\ts/\\b($typename|void)\\s+\\(+/XXX(/og;\n\t\tif (/\\w\\s\\(/) {\n\t\t\terr(\"extra space between function name and left paren\");\n\t\t}\n\t\t$_ = $s;\n\t}\n\t# try to detect \"int foo(x)\", but not \"extern int foo(x);\"\n\t# XXX - this still trips over too many legitimate things,\n\t# like \"int foo(x,\\n\\ty);\"\n#\t\tif (/^(\\w+(\\s|\\*)+)+\\w+\\(/ && !/\\)[;,](\\s|\u0001)*$/ &&\n#\t\t    !/^(extern|static)\\b/) {\n#\t\t\terr(\"return type of function not on separate line\");\n#\t\t}\n\t# this is a close approximation\n\tif (/^(\\w+(\\s|\\*)+)+\\w+\\(.*\\)(\\s|\u0001)*$/ &&\n\t    !/^(extern|static)\\b/) {\n\t\terr(\"return type of function not on separate line\");\n\t}\n\tif (/^#define /) {\n\t\terr(\"#define followed by space instead of tab\");\n\t}\n\tif (/^\\s*return\\W[^;]*;/ && !/^\\s*return\\s*\\(.*\\);/) {\n\t\terr(\"unparenthesized return expression\");\n\t}\n\tif (/\\bsizeof\\b/ && !/\\bsizeof\\s*\\(.*\\)/) {\n\t\terr(\"unparenthesized sizeof expression\");\n\t}\n\tif (/\\(\\s/) {\n\t\terr(\"whitespace after left paren\");\n\t}\n\t# Allow \"for\" statements to have empty \"continue\" clauses.\n\t# Allow right paren on its own line unless we're being picky (-p).\n\tif (/\\s\\)/ && !/^\\s*for \\([^;]*;[^;]*; \\)/ && ($picky || !/^\\s*\\)/)) {\n\t\terr(\"whitespace before right paren\");\n\t}\n\tif (/^\\s*\\(void\\)[^ ]/) {\n\t\terr(\"missing space after (void) cast\");\n\t}\n\tif (/\\S\\{/ && !/\\{\\{/) {\n\t\terr(\"missing space before left brace\");\n\t}\n\tif ($in_function && /^\\s+\\{/ &&\n\t    ($prev =~ /\\)\\s*$/ || $prev =~ /\\bstruct\\s+\\w+$/)) {\n\t\terr(\"left brace starting a line\");\n\t}\n\tif (/\\}(else|while)/) {\n\t\terr(\"missing space after right brace\");\n\t}\n\tif (/\\}\\s\\s+(else|while)/) {\n\t\terr(\"extra space after right brace\");\n\t}\n\tif (/\\b_VOID\\b|\\bVOID\\b|\\bSTATIC\\b/) {\n\t\terr(\"obsolete use of VOID or STATIC\");\n\t}\n\tif (/\\b$typename\\*/o) {\n\t\terr(\"missing space between type name and *\");\n\t}\n\tif (/^\\s+#/) {\n\t\terr(\"preprocessor statement not in column 1\");\n\t}\n\tif (/^#\\s/) {\n\t\terr(\"blank after preprocessor #\");\n\t}\n\tif (/!\\s*(strcmp|strncmp|bcmp)\\s*\\(/) {\n\t\terr(\"don't use boolean ! with comparison functions\");\n\t}\n\n\t#\n\t# We completely ignore, for purposes of indentation:\n\t#  * lines outside of functions\n\t#  * preprocessor lines\n\t#\n\tif ($check_continuation && $in_function && !$in_cpp) {\n\t\tprocess_indent($_);\n\t}\n\tif ($picky) {\n\t\t# try to detect spaces after casts, but allow (e.g.)\n\t\t# \"sizeof (int) + 1\", \"void (*funcptr)(int) = foo;\", and\n\t\t# \"int foo(int) __NORETURN;\"\n\t\tif ((/^\\($typename( \\*+)?\\)\\s/o ||\n\t\t    /\\W\\($typename( \\*+)?\\)\\s/o) &&\n\t\t    !/sizeof\\s*\\($typename( \\*)?\\)\\s/o &&\n\t\t    !/\\($typename( \\*+)?\\)\\s+=[^=]/o) {\n\t\t\terr(\"space after cast\");\n\t\t}\n\t\tif (/\\b$typename\\s*\\*\\s/o &&\n\t\t    !/\\b$typename\\s*\\*\\s+const\\b/o) {\n\t\t\terr(\"unary * followed by space\");\n\t\t}\n\t}\n\tif ($check_posix_types) {\n\t\t# try to detect old non-POSIX types.\n\t\t# POSIX requires all non-standard typedefs to end in _t,\n\t\t# but historically these have been used.\n\t\tif (/\\b(unchar|ushort|uint|ulong|u_int|u_short|u_long|u_char|quad)\\b/) {\n\t\t\terr(\"non-POSIX typedef $1 used: use $old2posix{$1} instead\");\n\t\t}\n\t}\n\tif (/^\\s*else\\W/) {\n\t\tif ($prev =~ /^\\s*\\}$/) {\n\t\t\terr_prefix($prev,\n\t\t\t    \"else and right brace should be on same line\");\n\t\t}\n\t}\n\t$prev = $line;\n}\n\nif ($prev eq \"\") {\n\terr(\"last line in file is blank\");\n}\n\n}\n\n#\n# Continuation-line checking\n#\n# The rest of this file contains the code for the continuation checking\n# engine.  It's a pretty simple state machine which tracks the expression\n# depth (unmatched '('s and '['s).\n#\n# Keep in mind that the argument to process_indent() has already been heavily\n# processed; all comments have been replaced by control-A, and the contents of\n# strings and character constants have been elided.\n#\n\nmy $cont_in;\t\t# currently inside of a continuation\nmy $cont_off;\t\t# skipping an initializer or definition\nmy $cont_noerr;\t\t# suppress cascading errors\nmy $cont_start;\t\t# the line being continued\nmy $cont_base;\t\t# the base indentation\nmy $cont_first;\t\t# this is the first line of a statement\nmy $cont_multiseg;\t# this continuation has multiple segments\n\nmy $cont_special;\t# this is a C statement (if, for, etc.)\nmy $cont_macro;\t\t# this is a macro\nmy $cont_case;\t\t# this is a multi-line case\n\nmy @cont_paren;\t\t# the stack of unmatched ( and [s we've seen\n\nsub\nreset_indent()\n{\n\t$cont_in = 0;\n\t$cont_off = 0;\n}\n\nsub\ndelabel($)\n{\n\t#\n\t# replace labels with tabs.  Note that there may be multiple\n\t# labels on a line.\n\t#\n\tlocal $_ = $_[0];\n\n\twhile (/^(\\t*)( *(?:(?:\\w+\\s*)|(?:case\\b[^:]*)): *)(.*)$/) {\n\t\tmy ($pre_tabs, $label, $rest) = ($1, $2, $3);\n\t\t$_ = $pre_tabs;\n\t\twhile ($label =~ s/^([^\\t]*)(\\t+)//) {\n\t\t\t$_ .= \"\\t\" x (length($2) + length($1) / 8);\n\t\t}\n\t\t$_ .= (\"\\t\" x (length($label) / 8)).$rest;\n\t}\n\n\treturn ($_);\n}\n\nsub\nprocess_indent($)\n{\n\trequire strict;\n\tlocal $_ = $_[0];\t\t\t# preserve the global $_\n\n\ts/\u0001//g;\t# No comments\n\ts/\\s+$//;\t# Strip trailing whitespace\n\n\treturn\t\t\tif (/^$/);\t# skip empty lines\n\n\t# regexps used below; keywords taking (), macros, and continued cases\n\tmy $special = '(?:(?:\\}\\s*)?else\\s+)?(?:if|for|while|switch)\\b';\n\tmy $macro = '[A-Z_][A-Z_0-9]*\\(';\n\tmy $case = 'case\\b[^:]*$';\n\n\t# skip over enumerations, array definitions, initializers, etc.\n\tif ($cont_off <= 0 && !/^\\s*$special/ &&\n\t    (/(?:(?:\\b(?:enum|struct|union)\\s*[^\\{]*)|(?:\\s+=\\s*))\\{/ ||\n\t    (/^\\s*\\{/ && $prev =~ /=\\s*(?:\\/\\*.*\\*\\/\\s*)*$/))) {\n\t\t$cont_in = 0;\n\t\t$cont_off = tr/{/{/ - tr/}/}/;\n\t\treturn;\n\t}\n\tif ($cont_off) {\n\t\t$cont_off += tr/{/{/ - tr/}/}/;\n\t\treturn;\n\t}\n\n\tif (!$cont_in) {\n\t\t$cont_start = $line;\n\n\t\tif (/^\\t* /) {\n\t\t\terr(\"non-continuation indented 4 spaces\");\n\t\t\t$cont_noerr = 1;\t\t# stop reporting\n\t\t}\n\t\t$_ = delabel($_);\t# replace labels with tabs\n\n\t\t# check if the statement is complete\n\t\treturn\t\tif (/^\\s*\\}?$/);\n\t\treturn\t\tif (/^\\s*\\}?\\s*else\\s*\\{?$/);\n\t\treturn\t\tif (/^\\s*do\\s*\\{?$/);\n\t\treturn\t\tif (/\\{$/);\n\t\treturn\t\tif (/\\}[,;]?$/);\n\n\t\t# Allow macros on their own lines\n\t\treturn\t\tif (/^\\s*[A-Z_][A-Z_0-9]*$/);\n\n\t\t# cases we don't deal with, generally non-kosher\n\t\tif (/\\{/) {\n\t\t\terr(\"stuff after {\");\n\t\t\treturn;\n\t\t}\n\n\t\t# Get the base line, and set up the state machine\n\t\t/^(\\t*)/;\n\t\t$cont_base = $1;\n\t\t$cont_in = 1;\n\t\t@cont_paren = ();\n\t\t$cont_first = 1;\n\t\t$cont_multiseg = 0;\n\n\t\t# certain things need special processing\n\t\t$cont_special = /^\\s*$special/? 1 : 0;\n\t\t$cont_macro = /^\\s*$macro/? 1 : 0;\n\t\t$cont_case = /^\\s*$case/? 1 : 0;\n\t} else {\n\t\t$cont_first = 0;\n\n\t\t# Strings may be pulled back to an earlier (half-)tabstop\n\t\tunless ($cont_noerr || /^$cont_base    / ||\n\t\t    (/^\\t*(?:    )?(?:gettext\\()?\\\"/ && !/^$cont_base\\t/)) {\n\t\t\terr_prefix($cont_start,\n\t\t\t    \"continuation should be indented 4 spaces\");\n\t\t}\n\t}\n\n\tmy $rest = $_;\t\t\t# keeps the remainder of the line\n\n\t#\n\t# The split matches 0 characters, so that each 'special' character\n\t# is processed separately.  Parens and brackets are pushed and\n\t# popped off the @cont_paren stack.  For normal processing, we wait\n\t# until a ; or { terminates the statement.  \"special\" processing\n\t# (if/for/while/switch) is allowed to stop when the stack empties,\n\t# as is macro processing.  Case statements are terminated with a :\n\t# and an empty paren stack.\n\t#\n\tforeach $_ (split /[^\\(\\)\\[\\]\\{\\}\\;\\:]*/) {\n\t\tnext\t\tif (length($_) == 0);\n\n\t\t# rest contains the remainder of the line\n\t\tmy $rxp = \"[^\\Q$_\\E]*\\Q$_\\E\";\n\t\t$rest =~ s/^$rxp//;\n\n\t\tif (/\\(/ || /\\[/) {\n\t\t\tpush @cont_paren, $_;\n\t\t} elsif (/\\)/ || /\\]/) {\n\t\t\tmy $cur = $_;\n\t\t\ttr/\\)\\]/\\(\\[/;\n\n\t\t\tmy $old = (pop @cont_paren);\n\t\t\tif (!defined($old)) {\n\t\t\t\terr(\"unexpected '$cur'\");\n\t\t\t\t$cont_in = 0;\n\t\t\t\tlast;\n\t\t\t} elsif ($old ne $_) {\n\t\t\t\terr(\"'$cur' mismatched with '$old'\");\n\t\t\t\t$cont_in = 0;\n\t\t\t\tlast;\n\t\t\t}\n\n\t\t\t#\n\t\t\t# If the stack is now empty, do special processing\n\t\t\t# for if/for/while/switch and macro statements.\n\t\t\t#\n\t\t\tnext\t\tif (@cont_paren != 0);\n\t\t\tif ($cont_special) {\n\t\t\t\tif ($rest =~ /^\\s*\\{?$/) {\n\t\t\t\t\t$cont_in = 0;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\tif ($rest =~ /^\\s*;$/) {\n\t\t\t\t\terr(\"empty if/for/while body \".\n\t\t\t\t\t    \"not on its own line\");\n\t\t\t\t\t$cont_in = 0;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\tif (!$cont_first && $cont_multiseg == 1) {\n\t\t\t\t\terr_prefix($cont_start,\n\t\t\t\t\t    \"multiple statements continued \".\n\t\t\t\t\t    \"over multiple lines\");\n\t\t\t\t\t$cont_multiseg = 2;\n\t\t\t\t} elsif ($cont_multiseg == 0) {\n\t\t\t\t\t$cont_multiseg = 1;\n\t\t\t\t}\n\t\t\t\t# We've finished this section, start\n\t\t\t\t# processing the next.\n\t\t\t\tgoto section_ended;\n\t\t\t}\n\t\t\tif ($cont_macro) {\n\t\t\t\tif ($rest =~ /^$/) {\n\t\t\t\t\t$cont_in = 0;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t} elsif (/\\;/) {\n\t\t\tif ($cont_case) {\n\t\t\t\terr(\"unexpected ;\");\n\t\t\t} elsif (!$cont_special) {\n\t\t\t\terr(\"unexpected ;\")\tif (@cont_paren != 0);\n\t\t\t\tif (!$cont_first && $cont_multiseg == 1) {\n\t\t\t\t\terr_prefix($cont_start,\n\t\t\t\t\t    \"multiple statements continued \".\n\t\t\t\t\t    \"over multiple lines\");\n\t\t\t\t\t$cont_multiseg = 2;\n\t\t\t\t} elsif ($cont_multiseg == 0) {\n\t\t\t\t\t$cont_multiseg = 1;\n\t\t\t\t}\n\t\t\t\tif ($rest =~ /^$/) {\n\t\t\t\t\t$cont_in = 0;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\tif ($rest =~ /^\\s*special/) {\n\t\t\t\t\terr(\"if/for/while/switch not started \".\n\t\t\t\t\t    \"on its own line\");\n\t\t\t\t}\n\t\t\t\tgoto section_ended;\n\t\t\t}\n\t\t} elsif (/\\{/) {\n\t\t\terr(\"{ while in parens/brackets\") if (@cont_paren != 0);\n\t\t\terr(\"stuff after {\")\t\tif ($rest =~ /[^\\s}]/);\n\t\t\t$cont_in = 0;\n\t\t\tlast;\n\t\t} elsif (/\\}/) {\n\t\t\terr(\"} while in parens/brackets\") if (@cont_paren != 0);\n\t\t\tif (!$cont_special && $rest !~ /^\\s*(while|else)\\b/) {\n\t\t\t\tif ($rest =~ /^$/) {\n\t\t\t\t\terr(\"unexpected }\");\n\t\t\t\t} else {\n\t\t\t\t\terr(\"stuff after }\");\n\t\t\t\t}\n\t\t\t\t$cont_in = 0;\n\t\t\t\tlast;\n\t\t\t}\n\t\t} elsif (/\\:/ && $cont_case && @cont_paren == 0) {\n\t\t\terr(\"stuff after multi-line case\") if ($rest !~ /$^/);\n\t\t\t$cont_in = 0;\n\t\t\tlast;\n\t\t}\n\t\tnext;\nsection_ended:\n\t\t# End of a statement or if/while/for loop.  Reset\n\t\t# cont_special and cont_macro based on the rest of the\n\t\t# line.\n\t\t$cont_special = ($rest =~ /^\\s*$special/)? 1 : 0;\n\t\t$cont_macro = ($rest =~ /^\\s*$macro/)? 1 : 0;\n\t\t$cont_case = 0;\n\t\tnext;\n\t}\n\t$cont_noerr = 0\t\t\tif (!$cont_in);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}