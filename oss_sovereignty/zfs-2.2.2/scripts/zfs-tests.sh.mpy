{
  "module_name": "zfs-tests.sh",
  "hash_id": "4089d49b1e0b5ccba8e9ebfcaf5f638f0444db4e13180253e02966c8eee11ee7",
  "original_prompt": "Ingested from zfs-2.2.2/scripts/zfs-tests.sh",
  "human_readable_source": "#!/bin/sh\n# shellcheck disable=SC2154\n#\n# CDDL HEADER START\n#\n# The contents of this file are subject to the terms of the\n# Common Development and Distribution License, Version 1.0 only\n# (the \"License\").  You may not use this file except in compliance\n# with the License.\n#\n# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n# or https://opensource.org/licenses/CDDL-1.0.\n# See the License for the specific language governing permissions\n# and limitations under the License.\n#\n# When distributing Covered Code, include this CDDL HEADER in each\n# file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n# If applicable, add the following below this CDDL HEADER, with the\n# fields enclosed by brackets \"[]\" replaced with your own identifying\n# information: Portions Copyright [yyyy] [name of copyright owner]\n#\n# CDDL HEADER END\n#\n\n#\n# Copyright 2020 OmniOS Community Edition (OmniOSce) Association.\n#\n\nSCRIPT_COMMON=${SCRIPT_COMMON:-${0%/*}/common.sh}\n. \"${SCRIPT_COMMON}\" || exit\n\nPROG=zfs-tests.sh\nVERBOSE=\"no\"\nQUIET=\"\"\nCLEANUP=\"yes\"\nCLEANUPALL=\"no\"\nKMSG=\"\"\nLOOPBACK=\"yes\"\nSTACK_TRACER=\"no\"\nFILESIZE=\"4G\"\nDEFAULT_RUNFILES=\"common.run,$(uname | tr '[:upper:]' '[:lower:]').run\"\nRUNFILES=${RUNFILES:-$DEFAULT_RUNFILES}\nFILEDIR=${FILEDIR:-/var/tmp}\nDISKS=${DISKS:-\"\"}\nSINGLETEST=\"\"\nSINGLETESTUSER=\"root\"\nTAGS=\"\"\nITERATIONS=1\nZFS_DBGMSG=\"$STF_SUITE/callbacks/zfs_dbgmsg.ksh\"\nZFS_DMESG=\"$STF_SUITE/callbacks/zfs_dmesg.ksh\"\nUNAME=$(uname)\nRERUN=\"\"\nKMEMLEAK=\"\"\n\n# Override some defaults if on FreeBSD\nif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\tTESTFAIL_CALLBACKS=${TESTFAIL_CALLBACKS:-\"$ZFS_DMESG\"}\n\tLOSETUP=/sbin/mdconfig\n\tDMSETUP=/sbin/gpart\nelse\n\tZFS_MMP=\"$STF_SUITE/callbacks/zfs_mmp.ksh\"\n\tTESTFAIL_CALLBACKS=${TESTFAIL_CALLBACKS:-\"$ZFS_DBGMSG:$ZFS_DMESG:$ZFS_MMP\"}\n\tLOSETUP=${LOSETUP:-/sbin/losetup}\n\tDMSETUP=${DMSETUP:-/sbin/dmsetup}\nfi\n\n#\n# Log an informational message when additional verbosity is enabled.\n#\nmsg() {\n\tif [ \"$VERBOSE\" = \"yes\" ]; then\n\t\techo \"$@\"\n\tfi\n}\n\n#\n# Log a failure message, cleanup, and return an error.\n#\nfail() {\n\techo \"$PROG: $1\" >&2\n\tcleanup\n\texit 1\n}\n\ncleanup_freebsd_loopback() {\n\tfor TEST_LOOPBACK in ${LOOPBACKS}; do\n\t\tif [ -c \"/dev/${TEST_LOOPBACK}\" ]; then\n\t\t\tsudo \"${LOSETUP}\" -d -u \"${TEST_LOOPBACK}\" ||\n\t\t\t    echo \"Failed to destroy: ${TEST_LOOPBACK}\"\n\t\tfi\n\tdone\n}\n\ncleanup_linux_loopback() {\n\tfor TEST_LOOPBACK in ${LOOPBACKS}; do\n\t\tLOOP_DEV=\"${TEST_LOOPBACK##*/}\"\n\t\tDM_DEV=$(sudo \"${DMSETUP}\" ls 2>/dev/null | \\\n\t\t    awk -v l=\"${LOOP_DEV}\" '$0 ~ l {print $1}')\n\n\t\tif [ -n \"$DM_DEV\" ]; then\n\t\t\tsudo \"${DMSETUP}\" remove \"${DM_DEV}\" ||\n\t\t\t    echo \"Failed to remove: ${DM_DEV}\"\n\t\tfi\n\n\t\tif [ -n \"${TEST_LOOPBACK}\" ]; then\n\t\t\tsudo \"${LOSETUP}\" -d \"${TEST_LOOPBACK}\" ||\n\t\t\t    echo \"Failed to remove: ${TEST_LOOPBACK}\"\n\t\tfi\n\tdone\n}\n\n#\n# Attempt to remove loopback devices and files which where created earlier\n# by this script to run the test framework.  The '-k' option may be passed\n# to the script to suppress cleanup for debugging purposes.\n#\ncleanup() {\n\tif [ \"$CLEANUP\" = \"no\" ]; then\n\t\treturn 0\n\tfi\n\n\n\tif [ \"$LOOPBACK\" = \"yes\" ]; then\n\t\tif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\t\t\tcleanup_freebsd_loopback\n\t\telse\n\t\t\tcleanup_linux_loopback\n\t\tfi\n\tfi\n\n\t# shellcheck disable=SC2086\n\trm -f ${FILES} >/dev/null 2>&1\n\n\tif [ \"$STF_PATH_REMOVE\" = \"yes\" ] && [ -d \"$STF_PATH\" ]; then\n\t\trm -Rf \"$STF_PATH\"\n\tfi\n}\ntrap cleanup EXIT\n\n#\n# Attempt to remove all testpools (testpool.XXX), unopened dm devices,\n# loopback devices, and files.  This is a useful way to cleanup a previous\n# test run failure which has left the system in an unknown state.  This can\n# be dangerous and should only be used in a dedicated test environment.\n#\ncleanup_all() {\n\tTEST_POOLS=$(ASAN_OPTIONS=detect_leaks=false \"$ZPOOL\" list -Ho name | grep testpool)\n\tif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\t\tTEST_LOOPBACKS=$(sudo \"${LOSETUP}\" -l)\n\telse\n\t\tTEST_LOOPBACKS=$(\"${LOSETUP}\" -a | awk -F: '/file-vdev/ {print $1}')\n\tfi\n\tTEST_FILES=$(ls \"${FILEDIR}\"/file-vdev* /var/tmp/file-vdev* 2>/dev/null)\n\n\tmsg\n\tmsg \"--- Cleanup ---\"\n\t# shellcheck disable=2116,2086\n\tmsg \"Removing pool(s):     $(echo ${TEST_POOLS})\"\n\tfor TEST_POOL in $TEST_POOLS; do\n\t\tsudo env ASAN_OPTIONS=detect_leaks=false \"$ZPOOL\" destroy \"${TEST_POOL}\"\n\tdone\n\n\tif [ \"$UNAME\" != \"FreeBSD\" ] ; then\n\t\tmsg \"Removing all dm(s):   $(sudo \"${DMSETUP}\" ls |\n\t\t    grep loop | tr '\\n' ' ')\"\n\t\tsudo \"${DMSETUP}\" remove_all\n\tfi\n\n\t# shellcheck disable=2116,2086\n\tmsg \"Removing loopback(s): $(echo ${TEST_LOOPBACKS})\"\n\tfor TEST_LOOPBACK in $TEST_LOOPBACKS; do\n\t\tif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\t\t\tsudo \"${LOSETUP}\" -d -u \"${TEST_LOOPBACK}\"\n\t\telse\n\t\t\tsudo \"${LOSETUP}\" -d \"${TEST_LOOPBACK}\"\n\t\tfi\n\tdone\n\n\t# shellcheck disable=2116,2086\n\tmsg \"Removing files(s):    $(echo ${TEST_FILES})\"\n\t# shellcheck disable=2086\n\tsudo rm -f ${TEST_FILES}\n}\n\n#\n# Takes a name as the only arguments and looks for the following variations\n# on that name.  If one is found it is returned.\n#\n# $RUNFILE_DIR/<name>\n# $RUNFILE_DIR/<name>.run\n# <name>\n# <name>.run\n#\nfind_runfile() {\n\tNAME=$1\n\n\tif [ -f \"$RUNFILE_DIR/$NAME\" ]; then\n\t\techo \"$RUNFILE_DIR/$NAME\"\n\telif [ -f \"$RUNFILE_DIR/$NAME.run\" ]; then\n\t\techo \"$RUNFILE_DIR/$NAME.run\"\n\telif [ -f \"$NAME\" ]; then\n\t\techo \"$NAME\"\n\telif [ -f \"$NAME.run\" ]; then\n\t\techo \"$NAME.run\"\n\telse\n\t\treturn 1\n\tfi\n}\n\n#\n# Symlink file if it appears under any of the given paths.\n#\ncreate_links() {\n\tdir_list=\"$1\"\n\tfile_list=\"$2\"\n\n\t[ -n \"$STF_PATH\" ] || fail \"STF_PATH wasn't correctly set\"\n\n\tfor i in $file_list; do\n\t\tfor j in $dir_list; do\n\t\t\t[ ! -e \"$STF_PATH/$i\" ] || continue\n\n\t\t\tif [ ! -d \"$j/$i\" ] && [ -e \"$j/$i\" ]; then\n\t\t\t\tln -sf \"$j/$i\" \"$STF_PATH/$i\" || \\\n\t\t\t\t    fail \"Couldn't link $i\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tdone\n\n\t\t[ ! -e \"$STF_PATH/$i\" ] && \\\n\t\t    STF_MISSING_BIN=\"$STF_MISSING_BIN $i\"\n\tdone\n\tSTF_MISSING_BIN=${STF_MISSING_BIN# }\n}\n\n#\n# Constrain the path to limit the available binaries to a known set.\n# When running in-tree a top level ./bin/ directory is created for\n# convenience, otherwise a temporary directory is used.\n#\nconstrain_path() {\n\t. \"$STF_SUITE/include/commands.cfg\"\n\n\t# On FreeBSD, base system zfs utils are in /sbin and OpenZFS utils\n\t# install to /usr/local/sbin. To avoid testing the wrong utils we\n\t# need /usr/local to come before / in the path search order.\n\tSYSTEM_DIRS=\"/usr/local/bin /usr/local/sbin\"\n\tSYSTEM_DIRS=\"$SYSTEM_DIRS /usr/bin /usr/sbin /bin /sbin $LIBEXEC_DIR\"\n\n\tif [ \"$INTREE\" = \"yes\" ]; then\n\t\t# Constrained path set to $(top_builddir)/tests/zfs-tests/bin\n\t\tSTF_PATH=\"$BIN_DIR\"\n\t\tSTF_PATH_REMOVE=\"no\"\n\t\tSTF_MISSING_BIN=\"\"\n\t\tif [ ! -d \"$STF_PATH\" ]; then\n\t\t\tmkdir \"$STF_PATH\"\n\t\t\tchmod 755 \"$STF_PATH\" || fail \"Couldn't chmod $STF_PATH\"\n\t\tfi\n\n\t\t# Special case links for standard zfs utilities\n\t\tcreate_links \"$CMD_DIR\" \"$ZFS_FILES\"\n\n\t\t# Special case links for zfs test suite utilities\n\t\tcreate_links \"$CMD_DIR/tests/zfs-tests/cmd\" \"$ZFSTEST_FILES\"\n\telse\n\t\t# Constrained path set to /var/tmp/constrained_path.*\n\t\tSYSTEMDIR=${SYSTEMDIR:-/var/tmp/constrained_path.XXXXXX}\n\t\tSTF_PATH=$(mktemp -d \"$SYSTEMDIR\")\n\t\tSTF_PATH_REMOVE=\"yes\"\n\t\tSTF_MISSING_BIN=\"\"\n\n\t\tchmod 755 \"$STF_PATH\" || fail \"Couldn't chmod $STF_PATH\"\n\n\t\t# Special case links for standard zfs utilities\n\t\tcreate_links \"$SYSTEM_DIRS\" \"$ZFS_FILES\"\n\n\t\t# Special case links for zfs test suite utilities\n\t\tcreate_links \"$STF_SUITE/bin\" \"$ZFSTEST_FILES\"\n\tfi\n\n\t# Standard system utilities\n\tSYSTEM_FILES=\"$SYSTEM_FILES_COMMON\"\n\tif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\t\tSYSTEM_FILES=\"$SYSTEM_FILES $SYSTEM_FILES_FREEBSD\"\n\telse\n\t\tSYSTEM_FILES=\"$SYSTEM_FILES $SYSTEM_FILES_LINUX\"\n\tfi\n\tcreate_links \"$SYSTEM_DIRS\" \"$SYSTEM_FILES\"\n\n\t# Exceptions\n\tif [ \"$UNAME\" = \"Linux\" ] ; then\n\t\tln -fs /sbin/fsck.ext4 \"$STF_PATH/fsck\"\n\t\tln -fs /sbin/mkfs.ext4 \"$STF_PATH/newfs\"\n\t\tln -fs \"$STF_PATH/gzip\" \"$STF_PATH/compress\"\n\t\tln -fs \"$STF_PATH/gunzip\" \"$STF_PATH/uncompress\"\n\telif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\t\tln -fs /usr/local/bin/ksh93 \"$STF_PATH/ksh\"\n\tfi\n}\n\n#\n# Output a useful usage message.\n#\nusage() {\ncat << EOF\nUSAGE:\n$0 [-hvqxkfS] [-s SIZE] [-r RUNFILES] [-t PATH] [-u USER]\n\nDESCRIPTION:\n\tZFS Test Suite launch script\n\nOPTIONS:\n\t-h          Show this message\n\t-v          Verbose zfs-tests.sh output\n\t-q          Quiet test-runner output\n\t-x          Remove all testpools, dm, lo, and files (unsafe)\n\t-k          Disable cleanup after test failure\n\t-K          Log test names to /dev/kmsg\n\t-f          Use files only, disables block device tests\n\t-S          Enable stack tracer (negative performance impact)\n\t-c          Only create and populate constrained path\n\t-R          Automatically rerun failing tests\n\t-m          Enable kmemleak reporting (Linux only)\n\t-n NFSFILE  Use the nfsfile to determine the NFS configuration\n\t-I NUM      Number of iterations\n\t-d DIR      Use world-writable DIR for files and loopback devices\n\t-s SIZE     Use vdevs of SIZE (default: 4G)\n\t-r RUNFILES Run tests in RUNFILES (default: ${DEFAULT_RUNFILES})\n\t-t PATH     Run single test at PATH relative to test suite\n\t-T TAGS     Comma separated list of tags (default: 'functional')\n\t-u USER     Run single test as USER (default: root)\n\nEXAMPLES:\n# Run the default ($(echo \"${DEFAULT_RUNFILES}\" | sed 's/\\.run//')) suite of tests and output the configuration used.\n$0 -v\n\n# Run a smaller suite of tests designed to run more quickly.\n$0 -r linux-fast\n\n# Run a single test\n$0 -t tests/functional/cli_root/zfs_bookmark/zfs_bookmark_cliargs.ksh\n\n# Cleanup a previous run of the test suite prior to testing, run the\n# default ($(echo \"${DEFAULT_RUNFILES}\" | sed 's/\\.run//')) suite of tests and perform no cleanup on exit.\n$0 -x\n\nEOF\n}\n\nwhile getopts 'hvqxkKfScRmn:d:s:r:?t:T:u:I:' OPTION; do\n\tcase $OPTION in\n\th)\n\t\tusage\n\t\texit 1\n\t\t;;\n\tv)\n\t\tVERBOSE=\"yes\"\n\t\t;;\n\tq)\n\t\tQUIET=\"yes\"\n\t\t;;\n\tx)\n\t\tCLEANUPALL=\"yes\"\n\t\t;;\n\tk)\n\t\tCLEANUP=\"no\"\n\t\t;;\n\tK)\n\t\tKMSG=\"yes\"\n\t\t;;\n\tf)\n\t\tLOOPBACK=\"no\"\n\t\t;;\n\tS)\n\t\tSTACK_TRACER=\"yes\"\n\t\t;;\n\tc)\n\t\tconstrain_path\n\t\texit\n\t\t;;\n\tR)\n\t\tRERUN=\"yes\"\n\t\t;;\n\tm)\n\t\tKMEMLEAK=\"yes\"\n\t\t;;\n\tn)\n\t\tnfsfile=$OPTARG\n\t\t[ -f \"$nfsfile\" ] || fail \"Cannot read file: $nfsfile\"\n\t\texport NFS=1\n\t\t. \"$nfsfile\"\n\t\t;;\n\td)\n\t\tFILEDIR=\"$OPTARG\"\n\t\t;;\n\tI)\n\t\tITERATIONS=\"$OPTARG\"\n\t\tif [ \"$ITERATIONS\" -le 0 ]; then\n\t\t\tfail \"Iterations must be greater than 0.\"\n\t\tfi\n\t\t;;\n\ts)\n\t\tFILESIZE=\"$OPTARG\"\n\t\t;;\n\tr)\n\t\tRUNFILES=\"$OPTARG\"\n\t\t;;\n\tt)\n\t\tif [ -n \"$SINGLETEST\" ]; then\n\t\t\tfail \"-t can only be provided once.\"\n\t\tfi\n\t\tSINGLETEST=\"$OPTARG\"\n\t\t;;\n\tT)\n\t\tTAGS=\"$OPTARG\"\n\t\t;;\n\tu)\n\t\tSINGLETESTUSER=\"$OPTARG\"\n\t\t;;\n\t?)\n\t\tusage\n\t\texit\n\t\t;;\n\t*)\n\t\t;;\n\tesac\ndone\n\nshift $((OPTIND-1))\n\nFILES=${FILES:-\"$FILEDIR/file-vdev0 $FILEDIR/file-vdev1 $FILEDIR/file-vdev2\"}\nLOOPBACKS=${LOOPBACKS:-\"\"}\n\nif [ -n \"$SINGLETEST\" ]; then\n\tif [ -n \"$TAGS\" ]; then\n\t\tfail \"-t and -T are mutually exclusive.\"\n\tfi\n\tRUNFILE_DIR=\"/var/tmp\"\n\tRUNFILES=\"zfs-tests.$$.run\"\n\t[ -n \"$QUIET\" ] && SINGLEQUIET=\"True\" || SINGLEQUIET=\"False\"\n\n\tcat >\"${RUNFILE_DIR}/${RUNFILES}\" << EOF\n[DEFAULT]\npre =\nquiet = $SINGLEQUIET\npre_user = root\nuser = $SINGLETESTUSER\ntimeout = 600\npost_user = root\npost =\noutputdir = /var/tmp/test_results\nEOF\n\tSINGLETESTDIR=\"${SINGLETEST%/*}\"\n\n\tSETUPDIR=\"$SINGLETESTDIR\"\n\t[ \"${SETUPDIR#/}\" = \"$SETUPDIR\" ] && SETUPDIR=\"$STF_SUITE/$SINGLETESTDIR\"\n\t[ -x \"$SETUPDIR/setup.ksh\"   ] && SETUPSCRIPT=\"setup\"     || SETUPSCRIPT=\n\t[ -x \"$SETUPDIR/cleanup.ksh\" ] && CLEANUPSCRIPT=\"cleanup\" || CLEANUPSCRIPT=\n\n\tSINGLETESTFILE=\"${SINGLETEST##*/}\"\n\tcat >>\"${RUNFILE_DIR}/${RUNFILES}\" << EOF\n\n[$SINGLETESTDIR]\ntests = ['$SINGLETESTFILE']\npre = $SETUPSCRIPT\npost = $CLEANUPSCRIPT\ntags = ['functional']\nEOF\nfi\n\n#\n# Use default tag if none was specified\n#\nTAGS=${TAGS:='functional'}\n\n#\n# Attempt to locate the runfiles describing the test workload.\n#\nR=\"\"\nIFS=,\nfor RUNFILE in $RUNFILES; do\n\tif [ -n \"$RUNFILE\" ]; then\n\t\tSAVED_RUNFILE=\"$RUNFILE\"\n\t\tRUNFILE=$(find_runfile \"$RUNFILE\") ||\n\t\t\tfail \"Cannot find runfile: $SAVED_RUNFILE\"\n\t\tR=\"$R,$RUNFILE\"\n\tfi\n\n\tif [ ! -r \"$RUNFILE\" ]; then\n\t\tfail \"Cannot read runfile: $RUNFILE\"\n\tfi\ndone\nunset IFS\nRUNFILES=${R#,}\n\n#\n# This script should not be run as root.  Instead the test user, which may\n# be a normal user account, needs to be configured such that it can\n# run commands via sudo passwordlessly.\n#\nif [ \"$(id -u)\" = \"0\" ]; then\n\tfail \"This script must not be run as root.\"\nfi\n\nif [ \"$(sudo id -un)\" != \"root\" ]; then\n\tfail \"Passwordless sudo access required.\"\nfi\n\n#\n# Constrain the available binaries to a known set.\n#\nconstrain_path\n\n#\n# Check if ksh exists\n#\nif [ \"$UNAME\" = \"FreeBSD\" ]; then\n\tsudo ln -fs /usr/local/bin/ksh93 /bin/ksh\nfi\n[ -e \"$STF_PATH/ksh\" ] || fail \"This test suite requires ksh.\"\n[ -e \"$STF_SUITE/include/default.cfg\" ] || fail \\\n    \"Missing $STF_SUITE/include/default.cfg file.\"\n\n#\n# Verify the ZFS module stack is loaded.\n#\nif [ \"$STACK_TRACER\" = \"yes\" ]; then\n\tsudo \"${ZFS_SH}\" -S >/dev/null 2>&1\nelse\n\tsudo \"${ZFS_SH}\" >/dev/null 2>&1\nfi\n\n#\n# Attempt to cleanup all previous state for a new test run.\n#\nif [ \"$CLEANUPALL\" = \"yes\" ]; then\n\tcleanup_all\nfi\n\n#\n# By default preserve any existing pools\n#\nif [ -z \"${KEEP}\" ]; then\n\tKEEP=\"$(ASAN_OPTIONS=detect_leaks=false \"$ZPOOL\" list -Ho name | tr -s '[:space:]' ' ')\"\n\tif [ -z \"${KEEP}\" ]; then\n\t\tKEEP=\"rpool\"\n\tfi\nelse\n\tKEEP=\"$(echo \"$KEEP\" | tr -s '[:space:]' ' ')\"\nfi\n\n#\n# NOTE: The following environment variables are undocumented\n# and should be used for testing purposes only:\n#\n# __ZFS_POOL_EXCLUDE - don't iterate over the pools it lists\n# __ZFS_POOL_RESTRICT - iterate only over the pools it lists\n#\n# See libzfs/libzfs_config.c for more information.\n#\n__ZFS_POOL_EXCLUDE=\"$KEEP\"\n\n. \"$STF_SUITE/include/default.cfg\"\n\n#\n# No DISKS have been provided so a basic file or loopback based devices\n# must be created for the test suite to use.\n#\nif [ -z \"${DISKS}\" ]; then\n\t#\n\t# If this is a performance run, prevent accidental use of\n\t# loopback devices.\n\t#\n\t[ \"$TAGS\" = \"perf\" ] && fail \"Running perf tests without disks.\"\n\n\t#\n\t# Create sparse files for the test suite.  These may be used\n\t# directory or have loopback devices layered on them.\n\t#\n\tfor TEST_FILE in ${FILES}; do\n\t\t[ -f \"$TEST_FILE\" ] && fail \"Failed file exists: ${TEST_FILE}\"\n\t\ttruncate -s \"${FILESIZE}\" \"${TEST_FILE}\" ||\n\t\t    fail \"Failed creating: ${TEST_FILE} ($?)\"\n\tdone\n\n\t#\n\t# If requested setup loopback devices backed by the sparse files.\n\t#\n\tif [ \"$LOOPBACK\" = \"yes\" ]; then\n\t\ttest -x \"$LOSETUP\" || fail \"$LOSETUP utility must be installed\"\n\n\t\tfor TEST_FILE in ${FILES}; do\n\t\t\tif [ \"$UNAME\" = \"FreeBSD\" ] ; then\n\t\t\t\tMDDEVICE=$(sudo \"${LOSETUP}\" -a -t vnode -f \"${TEST_FILE}\")\n\t\t\t\tif [ -z \"$MDDEVICE\" ] ; then\n\t\t\t\t\tfail \"Failed: ${TEST_FILE} -> loopback\"\n\t\t\t\tfi\n\t\t\t\tDISKS=\"$DISKS $MDDEVICE\"\n\t\t\t\tLOOPBACKS=\"$LOOPBACKS $MDDEVICE\"\n\t\t\telse\n\t\t\t\tTEST_LOOPBACK=$(sudo \"${LOSETUP}\" --show -f \"${TEST_FILE}\") ||\n\t\t\t\t    fail \"Failed: ${TEST_FILE} -> ${TEST_LOOPBACK}\"\n\t\t\t\tBASELOOPBACK=\"${TEST_LOOPBACK##*/}\"\n\t\t\t\tDISKS=\"$DISKS $BASELOOPBACK\"\n\t\t\t\tLOOPBACKS=\"$LOOPBACKS $TEST_LOOPBACK\"\n\t\t\tfi\n\t\tdone\n\t\tDISKS=${DISKS# }\n\t\tLOOPBACKS=${LOOPBACKS# }\n\telse\n\t\tDISKS=\"$FILES\"\n\tfi\nfi\n\n#\n# It may be desirable to test with fewer disks than the default when running\n# the performance tests, but the functional tests require at least three.\n#\nNUM_DISKS=$(echo \"${DISKS}\" | awk '{print NF}')\nif [ \"$TAGS\" != \"perf\" ]; then\n\t[ \"$NUM_DISKS\" -lt 3 ] && fail \"Not enough disks ($NUM_DISKS/3 minimum)\"\nfi\n\n#\n# Disable SELinux until the ZFS Test Suite has been updated accordingly.\n#\nif command -v setenforce >/dev/null; then\n\tsudo setenforce permissive >/dev/null 2>&1\nfi\n\n#\n# Enable internal ZFS debug log and clear it.\n#\nif [ -e /sys/module/zfs/parameters/zfs_dbgmsg_enable ]; then\n\tsudo sh -c \"echo 1 >/sys/module/zfs/parameters/zfs_dbgmsg_enable\"\n\tsudo sh -c \"echo 0 >/proc/spl/kstat/zfs/dbgmsg\"\nfi\n\nmsg\nmsg \"--- Configuration ---\"\nmsg \"Runfiles:        $RUNFILES\"\nmsg \"STF_TOOLS:       $STF_TOOLS\"\nmsg \"STF_SUITE:       $STF_SUITE\"\nmsg \"STF_PATH:        $STF_PATH\"\nmsg \"FILEDIR:         $FILEDIR\"\nmsg \"FILES:           $FILES\"\nmsg \"LOOPBACKS:       $LOOPBACKS\"\nmsg \"DISKS:           $DISKS\"\nmsg \"NUM_DISKS:       $NUM_DISKS\"\nmsg \"FILESIZE:        $FILESIZE\"\nmsg \"ITERATIONS:      $ITERATIONS\"\nmsg \"TAGS:            $TAGS\"\nmsg \"STACK_TRACER:    $STACK_TRACER\"\nmsg \"Keep pool(s):    $KEEP\"\nmsg \"Missing util(s): $STF_MISSING_BIN\"\nmsg \"\"\n\nexport STF_TOOLS\nexport STF_SUITE\nexport STF_PATH\nexport DISKS\nexport FILEDIR\nexport KEEP\nexport __ZFS_POOL_EXCLUDE\nexport TESTFAIL_CALLBACKS\n\nmktemp_file() {\n\tif [ \"$UNAME\" = \"FreeBSD\" ]; then\n\t\tmktemp -u \"${FILEDIR}/$1.XXXXXX\"\n\telse\n\t\tmktemp -ut \"$1.XXXXXX\" -p \"$FILEDIR\"\n\tfi\n}\nmkdir -p \"$FILEDIR\" || :\nRESULTS_FILE=$(mktemp_file zts-results)\nREPORT_FILE=$(mktemp_file zts-report)\n\n#\n# Run all the tests as specified.\n#\nmsg \"${TEST_RUNNER}\" \\\n    \"${QUIET:+-q}\" \\\n    \"${KMEMLEAK:+-m}\" \\\n    \"${KMSG:+-K}\" \\\n    \"-c \\\"${RUNFILES}\\\"\" \\\n    \"-T \\\"${TAGS}\\\"\" \\\n    \"-i \\\"${STF_SUITE}\\\"\" \\\n    \"-I \\\"${ITERATIONS}\\\"\"\n{ PATH=$STF_PATH \\\n    ${TEST_RUNNER} \\\n    ${QUIET:+-q} \\\n    ${KMEMLEAK:+-m} \\\n    ${KMSG:+-K} \\\n    -c \"${RUNFILES}\" \\\n    -T \"${TAGS}\" \\\n    -i \"${STF_SUITE}\" \\\n    -I \"${ITERATIONS}\" \\\n    2>&1; echo $? >\"$REPORT_FILE\"; } | tee \"$RESULTS_FILE\"\nread -r RUNRESULT <\"$REPORT_FILE\"\n\n#\n# Analyze the results.\n#\n${ZTS_REPORT} ${RERUN:+--no-maybes} \"$RESULTS_FILE\" >\"$REPORT_FILE\"\nRESULT=$?\n\nif [ \"$RESULT\" -eq \"2\" ] && [ -n \"$RERUN\" ]; then\n\tMAYBES=\"$($ZTS_REPORT --list-maybes)\"\n\tTEMP_RESULTS_FILE=$(mktemp_file zts-results-tmp)\n\tTEST_LIST=$(mktemp_file test-list)\n\tgrep \"^Test:.*\\[FAIL\\]\" \"$RESULTS_FILE\" >\"$TEMP_RESULTS_FILE\"\n\tfor test_name in $MAYBES; do\n\t\tgrep \"$test_name \" \"$TEMP_RESULTS_FILE\" >>\"$TEST_LIST\"\n\tdone\n\t{ PATH=$STF_PATH \\\n\t    ${TEST_RUNNER} \\\n\t        ${QUIET:+-q} \\\n\t        ${KMEMLEAK:+-m} \\\n\t    -c \"${RUNFILES}\" \\\n\t    -T \"${TAGS}\" \\\n\t    -i \"${STF_SUITE}\" \\\n\t    -I \"${ITERATIONS}\" \\\n\t    -l \"${TEST_LIST}\" \\\n\t    2>&1; echo $? >\"$REPORT_FILE\"; } | tee \"$RESULTS_FILE\"\n\tread -r RUNRESULT <\"$REPORT_FILE\"\n\t#\n\t# Analyze the results.\n\t#\n\t${ZTS_REPORT} --no-maybes \"$RESULTS_FILE\" >\"$REPORT_FILE\"\n\tRESULT=$?\nfi\n\n\ncat \"$REPORT_FILE\"\n\nRESULTS_DIR=$(awk '/^Log directory/ { print $3 }' \"$RESULTS_FILE\")\nif [ -d \"$RESULTS_DIR\" ]; then\n\tcat \"$RESULTS_FILE\" \"$REPORT_FILE\" >\"$RESULTS_DIR/results\"\nfi\n\nrm -f \"$RESULTS_FILE\" \"$REPORT_FILE\" \"$TEST_LIST\" \"$TEMP_RESULTS_FILE\"\n\nif [ -n \"$SINGLETEST\" ]; then\n\trm -f \"$RUNFILES\" >/dev/null 2>&1\nfi\n\n[ \"$RUNRESULT\" -gt 3 ] && exit \"$RUNRESULT\" || exit \"$RESULT\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}