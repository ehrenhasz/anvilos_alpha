{
  "module_name": "zimport.sh",
  "hash_id": "8db2b4fd883c984c6abf337db2982aa2a05f77efdf222ee77c300870c900a3ac",
  "original_prompt": "Ingested from zfs-2.2.2/scripts/zimport.sh",
  "human_readable_source": "#!/usr/bin/env bash\n#\n# Verify that an assortment of known good reference pools can be imported\n# using different versions of OpenZFS code.\n#\n# By default references pools for the major ZFS implementation will be\n# checked against the most recent OpenZFS tags and the master development branch.\n# Alternate tags or branches may be verified with the '-s <src-tag> option.\n# Passing the keyword \"installed\" will instruct the script to test whatever\n# version is installed.\n#\n# Preferentially a reference pool is used for all tests.  However, if one\n# does not exist and the pool-tag matches one of the src-tags then a new\n# reference pool will be created using binaries from that source build.\n# This is particularly useful when you need to test your changes before\n# opening a pull request.  The keyword 'all' can be used as short hand\n# refer to all available reference pools.\n#\n# New reference pools may be added by placing a bzip2 compressed tarball\n# of the pool in the scripts/zfs-images directory and then passing\n# the -p <pool-tag> option.  To increase the test coverage reference pools\n# should be collected for all the major ZFS implementations.  Having these\n# pools easily available is also helpful to the developers.\n#\n# Care should be taken to run these tests with a kernel supported by all\n# the listed tags.  Otherwise build failure will cause false positives.\n#\n#\n# EXAMPLES:\n#\n# The following example will verify the zfs-0.6.2 tag, the master branch,\n# and the installed zfs version can correctly import the listed pools.\n# Note there is no reference pool available for master and installed but\n# because binaries are available one is automatically constructed.  The\n# working directory is also preserved between runs (-k) preventing the\n# need to rebuild from source for multiple runs.\n#\n#  zimport.sh -k -f /var/tmp/zimport \\\n#      -s \"zfs-0.6.2 master installed\" \\\n#      -p \"zevo-1.1.1 zol-0.6.2 zol-0.6.2-173 master installed\"\n#\n# ------------------------ OpenZFS Source Versions ----------------\n#                 zfs-0.6.2       master          0.6.2-175_g36eb554\n# -----------------------------------------------------------------\n# Clone ZFS       Local\t\tLocal\t\tSkip\n# Build ZFS       Pass\t\tPass\t\tSkip\n# -----------------------------------------------------------------\n# zevo-1.1.1      Pass\t\tPass\t\tPass\n# zol-0.6.2       Pass\t\tPass\t\tPass\n# zol-0.6.2-173   Fail\t\tPass\t\tPass\n# master          Pass\t\tPass\t\tPass\n# installed       Pass\t\tPass\t\tPass\n#\n\nBASE_DIR=$(dirname \"$0\")\nSCRIPT_COMMON=common.sh\nif [[ -f \"${BASE_DIR}/${SCRIPT_COMMON}\" ]]; then\n\t. \"${BASE_DIR}/${SCRIPT_COMMON}\"\nelse\n\techo \"Missing helper script ${SCRIPT_COMMON}\" && exit 1\nfi\n\nPROG=zimport.sh\nSRC_TAGS=\"zfs-0.6.5.11 master\"\nPOOL_TAGS=\"all master\"\nPOOL_CREATE_OPTIONS=\nTEST_DIR=$(mktemp -u -d -p /var/tmp zimport.XXXXXXXX)\nKEEP=\"no\"\nVERBOSE=\"no\"\nCOLOR=\"yes\"\nREPO=\"https://github.com/openzfs\"\nIMAGES_DIR=\"${BASE_DIR}/zfs-images/\"\nIMAGES_TAR=\"https://github.com/openzfs/zfs-images/tarball/master\"\nERROR=0\n\nCONFIG_LOG=\"configure.log\"\nCONFIG_OPTIONS=${CONFIG_OPTIONS:-\"\"}\nMAKE_LOG=\"make.log\"\nMAKE_OPTIONS=${MAKE_OPTIONS:-\"-s -j$(nproc)\"}\n\nCOLOR_GREEN=\"\\033[0;32m\"\nCOLOR_RED=\"\\033[0;31m\"\nCOLOR_BROWN=\"\\033[0;33m\"\nCOLOR_RESET=\"\\033[0m\"\n\nusage() {\ncat << EOF\nUSAGE:\nzimport.sh [hvl] [-r repo] [-s src-tag] [-i pool-dir] [-p pool-tag]\n    [-f path] [-o options]\n\nDESCRIPTION:\n\tZPOOL import verification tests\n\nOPTIONS:\n\t-h                Show this message\n\t-v                Verbose\n\t-c                No color\n\t-k                Keep temporary directory\n\t-r <repo>         Source repository ($REPO)\n\t-s <src-tag>...   Verify OpenZFS versions with the listed tags\n\t-i <pool-dir>     Pool image directory\n\t-p <pool-tag>...  Verify pools created with the listed tags\n\t-f <path>         Temporary directory to use\n\t-o <options>      Additional options to pass to 'zpool create'\n\nEOF\n}\n\nwhile getopts 'hvckr:s:i:p:f:o:?' OPTION; do\n\tcase $OPTION in\n\th)\n\t\tusage\n\t\texit 1\n\t\t;;\n\tv)\n\t\tVERBOSE=\"yes\"\n\t\t;;\n\tc)\n\t\tCOLOR=\"no\"\n\t\t;;\n\tk)\n\t\tKEEP=\"yes\"\n\t\t;;\n\tr)\n\t\tREPO=\"$OPTARG\"\n\t\t;;\n\ts)\n\t\tSRC_TAGS=\"$OPTARG\"\n\t\t;;\n\ti)\n\t\tIMAGES_DIR=\"$OPTARG\"\n\t\t;;\n\tp)\n\t\tPOOL_TAGS=\"$OPTARG\"\n\t\t;;\n\tf)\n\t\tTEST_DIR=\"$OPTARG\"\n\t\t;;\n\to)\n\t\tPOOL_CREATE_OPTIONS=\"$OPTARG\"\n\t\t;;\n\t*)\n\t\tusage\n\t\texit 1\n\t\t;;\n\tesac\ndone\n\n#\n# Verify the module start is not loaded\n#\nif lsmod | grep zfs >/dev/null; then\n\techo \"ZFS modules must be unloaded\"\n\texit 1\nfi\n\n#\n# Create a random directory tree of files and sub-directories to\n# to act as a copy source for the various regression tests.\n#\npopulate() {\n\tlocal ROOT=$1\n\tlocal MAX_DIR_SIZE=$2\n\tlocal MAX_FILE_SIZE=$3\n\n\tmkdir -p \"$ROOT\"/{a,b,c,d,e,f,g}/{h,i}\n\tDIRS=$(find \"$ROOT\")\n\n\tfor DIR in $DIRS; do\n\t\tCOUNT=$((RANDOM % MAX_DIR_SIZE))\n\n\t\tfor _ in $(seq \"$COUNT\"); do\n\t\t\tFILE=$(mktemp -p \"$DIR\")\n\t\t\tSIZE=$((RANDOM % MAX_FILE_SIZE))\n\t\t\tdd if=/dev/urandom of=\"$FILE\" bs=1k \\\n\t\t\t    count=\"$SIZE\" &>/dev/null\n\t\tdone\n\tdone\n\n\treturn 0\n}\n\nSRC_DIR=$(mktemp -d -p /var/tmp/ zfs.src.XXXXXXXX)\ntrap 'rm -Rf \"$SRC_DIR\"' INT TERM EXIT\npopulate \"$SRC_DIR\" 10 100\n\nSRC_DIR=\"$TEST_DIR/src\"\nSRC_DIR_ZFS=\"$SRC_DIR/zfs\"\n\nif [[ \"$COLOR\" = \"no\" ]]; then\n\tCOLOR_GREEN=\"\"\n\tCOLOR_BROWN=\"\"\n\tCOLOR_RED=\"\"\n\tCOLOR_RESET=\"\"\nfi\n\npass_nonewline() {\n\techo -n -e \"${COLOR_GREEN}Pass${COLOR_RESET}\\t\\t\"\n}\n\nskip_nonewline() {\n\techo -n -e \"${COLOR_BROWN}Skip${COLOR_RESET}\\t\\t\"\n}\n\nfail_nonewline() {\n\techo -n -e \"${COLOR_RED}Fail${COLOR_RESET}\\t\\t\"\n}\n\n#\n# Log a failure message, cleanup, and return an error.\n#\nfail() {\n\techo -e \"$PROG: $1\" >&2\n\t$ZFS_SH -u >/dev/null 2>&1\n\texit 1\n}\n\n#\n# Set several helper variables which are derived from a source tag.\n#\n# ZFS_TAG - The passed zfs-x.y.z tag\n# ZFS_DIR - The zfs directory name\n# ZFS_URL - The zfs github URL to fetch the tarball\n#\nsrc_set_vars() {\n\tlocal TAG=$1\n\n\tZFS_TAG=\"$TAG\"\n\tZFS_DIR=\"$SRC_DIR_ZFS/$ZFS_TAG\"\n\tZFS_URL=\"$REPO/zfs/tarball/$ZFS_TAG\"\n\n\tif [[ \"$TAG\" = \"installed\" ]]; then\n\t\tZPOOL_CMD=$(command -v zpool)\n\t\tZFS_CMD=$(command -v zfs)\n\t\tZFS_SH=\"/usr/share/zfs/zfs.sh\"\n\telse\n\t\tZPOOL_CMD=\"./zpool\"\n\t\tZFS_CMD=\"./zfs\"\n\t\tZFS_SH=\"./scripts/zfs.sh\"\n\tfi\n}\n\n#\n# Set several helper variables which are derived from a pool name such\n# as zol-0.6.x, zevo-1.1.1, etc.  These refer to example pools from various\n# ZFS implementations which are used to verify compatibility.\n#\n# POOL_TAG          - The example pools name in scripts/zfs-images/.\n# POOL_BZIP         - The full path to the example bzip2 compressed pool.\n# POOL_DIR          - The top level test path for this pool.\n# POOL_DIR_PRISTINE - The directory containing a pristine version of the pool.\n# POOL_DIR_COPY     - The directory containing a working copy of the pool.\n# POOL_DIR_SRC      - Location of a source build if it exists for this pool.\n#\npool_set_vars() {\n\tlocal TAG=$1\n\n\tPOOL_TAG=$TAG\n\tPOOL_BZIP=$IMAGES_DIR/$POOL_TAG.tar.bz2\n\tPOOL_DIR=$TEST_DIR/pools/$POOL_TAG\n\tPOOL_DIR_PRISTINE=$POOL_DIR/pristine\n\tPOOL_DIR_COPY=$POOL_DIR/copy\n\tPOOL_DIR_SRC=\"$SRC_DIR_ZFS/${POOL_TAG//zol/zfs}\"\n}\n\n#\n# Construct a non-trivial pool given a specific version of the source.  More\n# interesting pools provide better test coverage so this function should\n# extended as needed to create more realistic pools.\n#\npool_create() {\n\tpool_set_vars \"$1\"\n\tsrc_set_vars \"$1\"\n\n\tif [[ \"$POOL_TAG\" != \"installed\" ]]; then\n\t\tcd \"$POOL_DIR_SRC\" || fail \"Failed 'cd $POOL_DIR_SRC'\"\n\tfi\n\n\t$ZFS_SH zfs=\"spa_config_path=$POOL_DIR_PRISTINE\" || \\\n\t    fail \"Failed to load kmods\"\n\n\t# Create a file vdev RAIDZ pool.\n\ttruncate -s 1G \\\n\t    \"$POOL_DIR_PRISTINE/vdev1\" \"$POOL_DIR_PRISTINE/vdev2\" \\\n\t    \"$POOL_DIR_PRISTINE/vdev3\" \"$POOL_DIR_PRISTINE/vdev4\" || \\\n\t    fail \"Failed 'truncate -s 1G ...'\"\n\t# shellcheck disable=SC2086\n\t$ZPOOL_CMD create $POOL_CREATE_OPTIONS \"$POOL_TAG\" raidz \\\n\t    \"$POOL_DIR_PRISTINE/vdev1\" \"$POOL_DIR_PRISTINE/vdev2\" \\\n\t    \"$POOL_DIR_PRISTINE/vdev3\" \"$POOL_DIR_PRISTINE/vdev4\" || \\\n\t    fail \"Failed '$ZPOOL_CMD create $POOL_CREATE_OPTIONS $POOL_TAG ...'\"\n\n\t# Create a pool/fs filesystem with some random contents.\n\t$ZFS_CMD create \"$POOL_TAG/fs\" || \\\n\t    fail \"Failed '$ZFS_CMD create $POOL_TAG/fs'\"\n\tpopulate \"/$POOL_TAG/fs/\" 10 100\n\n\t# Snapshot that filesystem, clone it, remove the files/dirs,\n\t# replace them with new files/dirs.\n\t$ZFS_CMD snap \"$POOL_TAG/fs@snap\" || \\\n\t    fail \"Failed '$ZFS_CMD snap $POOL_TAG/fs@snap'\"\n\t$ZFS_CMD clone \"$POOL_TAG/fs@snap\" \"$POOL_TAG/clone\" || \\\n\t    fail \"Failed '$ZFS_CMD clone $POOL_TAG/fs@snap $POOL_TAG/clone'\"\n\t# shellcheck disable=SC2086\n\trm -Rf /$POOL_TAG/clone/*\n\tpopulate \"/$POOL_TAG/clone/\" 10 100\n\n\t# Scrub the pool, delay slightly, then export it.  It is now\n\t# somewhat interesting for testing purposes.\n\t$ZPOOL_CMD scrub \"$POOL_TAG\" || \\\n\t    fail \"Failed '$ZPOOL_CMD scrub $POOL_TAG'\"\n\tsleep 10\n\t$ZPOOL_CMD export \"$POOL_TAG\" || \\\n\t    fail \"Failed '$ZPOOL_CMD export $POOL_TAG'\"\n\n\t$ZFS_SH -u || fail \"Failed to unload kmods\"\n}\n\n# If the zfs-images directory doesn't exist fetch a copy from Github then\n# cache it in the $TEST_DIR and update $IMAGES_DIR.\nif [[ ! -d \"$IMAGES_DIR\" ]]; then\n\tIMAGES_DIR=\"$TEST_DIR/zfs-images\"\n\tmkdir -p \"$IMAGES_DIR\"\n\tcurl -sL \"$IMAGES_TAR\" | \\\n\t    tar -xz -C \"$IMAGES_DIR\" --strip-components=1 || \\\n\t    fail \"Failed to download pool images\"\nfi\n\n# Given the available images in the zfs-images directory substitute the\n# list of available images for the reserved keyword 'all'.\nfor TAG in $POOL_TAGS; do\n\n\tif  [[ \"$TAG\" = \"all\" ]]; then\n\t\tALL_TAGS=$(echo \"$IMAGES_DIR\"/*.tar.bz2 | \\\n\t\t    sed \"s|$IMAGES_DIR/||g;s|.tar.bz2||g\")\n\t\tNEW_TAGS=\"$NEW_TAGS $ALL_TAGS\"\n\telse\n\t\tNEW_TAGS=\"$NEW_TAGS $TAG\"\n\tfi\ndone\nPOOL_TAGS=\"$NEW_TAGS\"\n\nif [[ \"$VERBOSE\" = \"yes\" ]]; then\n\techo \"---------------------------- Options ----------------------------\"\n\techo \"VERBOSE=$VERBOSE\"\n\techo \"KEEP=$KEEP\"\n\techo \"REPO=$REPO\"\n\techo \"SRC_TAGS=$SRC_TAGS\"\n\techo \"POOL_TAGS=$POOL_TAGS\"\n\techo \"PATH=$TEST_DIR\"\n\techo \"POOL_CREATE_OPTIONS=$POOL_CREATE_OPTIONS\"\n\techo\nfi\n\nif [[ ! -d \"$TEST_DIR\" ]]; then\n\tmkdir -p \"$TEST_DIR\"\nfi\n\nif [[ ! -d \"$SRC_DIR\" ]]; then\n\tmkdir -p \"$SRC_DIR\"\nfi\n\n# Print a header for all tags which are being tested.\necho \"------------------------ OpenZFS Source Versions ----------------\"\nprintf \"%-16s\" \" \"\nfor TAG in $SRC_TAGS; do\n\tsrc_set_vars \"$TAG\"\n\n\tif [[ \"$TAG\" = \"installed\" ]]; then\n\t\tZFS_VERSION=$(modinfo zfs | awk '/version:/ { print $2; exit }')\n\t\tif [[ -n \"$ZFS_VERSION\" ]]; then\n\t\t\tprintf \"%-16s\" \"$ZFS_VERSION\"\n\t\telse\n\t\t\tfail \"ZFS is not installed\"\n\t\tfi\n\telse\n\t\tprintf \"%-16s\" \"$TAG\"\n\tfi\ndone\necho -e \"\\n-----------------------------------------------------------------\"\n\n#\n# Attempt to generate the tarball from your local git repository, if that\n# fails then attempt to download the tarball from Github.\n#\nprintf \"%-16s\" \"Clone ZFS\"\nfor TAG in $SRC_TAGS; do\n\tsrc_set_vars \"$TAG\"\n\n\tif [[ -d \"$ZFS_DIR\" ]]; then\n\t\tskip_nonewline\n\telif  [[ \"$ZFS_TAG\" = \"installed\" ]]; then\n\t\tskip_nonewline\n\telse\n\t\tcd \"$SRC_DIR\" || fail \"Failed 'cd $SRC_DIR'\"\n\n\t\tif [[ ! -d \"$SRC_DIR_ZFS\" ]]; then\n\t\t\tmkdir -p \"$SRC_DIR_ZFS\"\n\t\tfi\n\n\t\tgit archive --format=tar --prefix=\"$ZFS_TAG/ $ZFS_TAG\" \\\n\t\t    -o \"$SRC_DIR_ZFS/$ZFS_TAG.tar\" &>/dev/null || \\\n\t\t    rm \"$SRC_DIR_ZFS/$ZFS_TAG.tar\"\n\t\tif [[ -s \"$SRC_DIR_ZFS/$ZFS_TAG.tar\" ]]; then\n\t\t\ttar -xf \"$SRC_DIR_ZFS/$ZFS_TAG.tar\" -C \"$SRC_DIR_ZFS\"\n\t\t\trm \"$SRC_DIR_ZFS/$ZFS_TAG.tar\"\n\t\t\techo -n -e \"${COLOR_GREEN}Local${COLOR_RESET}\\t\\t\"\n\t\telse\n\t\t\tmkdir -p \"$ZFS_DIR\" || fail \"Failed to create $ZFS_DIR\"\n\t\t\tcurl -sL \"$ZFS_URL\" | tar -xz -C \"$ZFS_DIR\" \\\n\t\t\t    --strip-components=1 || \\\n\t\t\t    fail \"Failed to download $ZFS_URL\"\n\t\t\techo -n -e \"${COLOR_GREEN}Remote${COLOR_RESET}\\t\\t\"\n\t\tfi\n\tfi\ndone\nprintf \"\\n\"\n\n# Build the listed tags\nprintf \"%-16s\" \"Build ZFS\"\nfor TAG in $SRC_TAGS; do\n\tsrc_set_vars \"$TAG\"\n\n\tif [[ -f \"$ZFS_DIR/module/zfs/zfs.ko\" ]]; then\n\t\tskip_nonewline\n\telif  [[ \"$ZFS_TAG\" = \"installed\" ]]; then\n\t\tskip_nonewline\n\telse\n\t\tcd \"$ZFS_DIR\" || fail \"Failed 'cd $ZFS_DIR'\"\n\t\tmake distclean &>/dev/null\n\t\t./autogen.sh >>\"$CONFIG_LOG\" 2>&1 || \\\n\t\t    fail \"Failed ZFS 'autogen.sh'\"\n\t\t# shellcheck disable=SC2086\n\t\t./configure $CONFIG_OPTIONS >>\"$CONFIG_LOG\" 2>&1 || \\\n\t\t    fail \"Failed ZFS 'configure $CONFIG_OPTIONS'\"\n\t\t# shellcheck disable=SC2086\n\t\tmake $MAKE_OPTIONS >>\"$MAKE_LOG\" 2>&1 || \\\n\t\t    fail \"Failed ZFS 'make $MAKE_OPTIONS'\"\n\t\tpass_nonewline\n\tfi\ndone\nprintf \"\\n\"\necho \"-----------------------------------------------------------------\"\n\n# Either create a new pool using 'zpool create', or alternately restore an\n# existing pool from another ZFS implementation for compatibility testing.\nfor TAG in $POOL_TAGS; do\n\tpool_set_vars \"$TAG\"\n\tSKIP=0\n\n\tprintf \"%-16s\" \"$POOL_TAG\"\n\trm -Rf \"$POOL_DIR\"\n\tmkdir -p \"$POOL_DIR_PRISTINE\"\n\n\t# Use the existing compressed image if available.\n\tif [[ -f \"$POOL_BZIP\" ]]; then\n\t\ttar -xjf \"$POOL_BZIP\" -C \"$POOL_DIR_PRISTINE\" \\\n\t\t    --strip-components=1 || \\\n\t\t    fail \"Failed 'tar -xjf $POOL_BZIP\"\n\t# Use the installed version to create the pool.\n\telif  [[ \"$TAG\" = \"installed\" ]]; then\n\t\tpool_create \"$TAG\"\n\t# A source build is available to create the pool.\n\telif [[ -d \"$POOL_DIR_SRC\" ]]; then\n\t\tpool_create \"$TAG\"\n\telse\n\t\tSKIP=1\n\tfi\n\n\t# Verify 'zpool import' works for all listed source versions.\n\tfor SRC_TAG in $SRC_TAGS; do\n\n\t\tif [[ \"$SKIP\" -eq 1 ]]; then\n\t\t\tskip_nonewline\n\t\t\tcontinue\n\t\tfi\n\n\t\tsrc_set_vars \"$SRC_TAG\"\n\t\tif [[ \"$SRC_TAG\" != \"installed\" ]]; then\n\t\t\tcd \"$ZFS_DIR\" || fail \"Failed 'cd $ZFS_DIR'\"\n\t\tfi\n\t\t$ZFS_SH zfs=\"spa_config_path=$POOL_DIR_COPY\"\n\n\t\tcp -a --sparse=always \"$POOL_DIR_PRISTINE\" \\\n\t\t    \"$POOL_DIR_COPY\" || \\\n\t\t    fail \"Failed to copy $POOL_DIR_PRISTINE to $POOL_DIR_COPY\"\n\t\tPOOL_NAME=$($ZPOOL_CMD import -d \"$POOL_DIR_COPY\" | \\\n\t\t    awk '/pool:/ { print $2; exit }')\n\n\t\tif ! $ZPOOL_CMD import -N -d \"$POOL_DIR_COPY\"\n\t\t    \"$POOL_NAME\" &>/dev/null; then\n\t\t\tfail_nonewline\n\t\t\tERROR=1\n\t\telse\n\t\t\t$ZPOOL_CMD export \"$POOL_NAME\" || \\\n\t\t\t    fail \"Failed to export pool\"\n\t\t\tpass_nonewline\n\t\tfi\n\n\t\trm -Rf \"$POOL_DIR_COPY\"\n\n\t\t$ZFS_SH -u || fail \"Failed to unload kmods\"\n\tdone\n\tprintf \"\\n\"\ndone\n\nif [[ \"$KEEP\" = \"no\" ]]; then\n\trm -Rf \"$TEST_DIR\"\nfi\n\nexit \"$ERROR\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}