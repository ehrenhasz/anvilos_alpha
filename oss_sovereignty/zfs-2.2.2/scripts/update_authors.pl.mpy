{
  "module_name": "update_authors.pl",
  "hash_id": "7b3d4a6ea82372d037f330d50916a32411039c281565dc3ea0a5976ac8204548",
  "original_prompt": "Ingested from zfs-2.2.2/scripts/update_authors.pl",
  "human_readable_source": "#!/usr/bin/env perl\n\n# SPDX-License-Identifier: MIT\n#\n# Copyright (c) 2023, Rob Norris <robn@despairlabs.com>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to\n# deal in the Software without restriction, including without limitation the\n# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n# sell copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\n\n# This program will update the AUTHORS file to include commit authors that are\n# in the git history but are not yet credited.\n#\n# The CONTRIBUTORS section of the AUTHORS file attempts to be a list of\n# individual contributors to OpenZFS, with one name, address and line per\n# person. This is good for readability, but does not really leave room for the\n# that names and emails on commits from the same individual can be different,\n# for all kinds of reasons, not limited to:\n#\n# - a person might change organisations, and so their email address changes\n#\n# - a person might be paid to work on OpenZFS for their employer, and then hack\n#   on personal projects in the evening, so commits legitimately come from\n#   different addresses\n#\n# - names change for all kinds of reasons\n#\n# To try and account for this, this program will try to find all the possible\n# names and emails for a single contributor, and then select the \"best\" one to\n# add to the AUTHORS file.\n#\n# The CONTRIBUTORS section of the AUTHORS file is considered the source of\n# truth. Once an individual committer is listed in there, that line will not be\n# removed regardless of what is discovered in the commit history. However, it\n# can't just be _anything_. The name or email still has to match something seen\n# in the commit history, so that we're able to undertand that its the same\n# contributor.\n#\n# The bulk of the work is in running `git log` to fetch commit author names and\n# emails. For each value, we generate a \"slug\" to use as an internal id for\n# that value, which is mostly just the lowercase of the value with whitespace\n# and punctuation removed. Two values with subtle differences can produce the\n# same slug, so at this point we also try to keep the \"best\" pre-slug value as\n# the display version. We use this slug to update two maps, one of email->name,\n# the other of name->email.\n#\n# Once collected, we then walk all the emails we've seen and get all the names\n# associated with every instance. Then for each of those names, we get all the\n# emails associated, and so on until we've seen all the connected names and\n# emails. This collection is every possible name and email for an individual\n# contributor.\n#\n# Finaly, we consider these groups, and select the \"best\" name and email for\n# the contributor, and add them to the author tables if they aren't there\n# already. Once we've done everyone, we write out a new AUTHORS file, and\n# that's the whole job.\n#\n# This is imperfect! Its necessary for the user to examine the diff and make\n# sure its sensible. If it hasn't hooked up right, it may necessary to adjust\n# the input data (via .mailmap) or improve the heuristics in this program. It\n# took a long time to get into good shape when first written (355 new names\n# added to AUTHORS!) but hopefully in the future we'll be running this\n# regularly so it doesn't fall so far behind.\n\n\nuse 5.010;\nuse warnings;\nuse strict;\n\n# Storage for the \"best looking\" version of name or email, keyed on slug.\nmy %display_name;\nmy %display_email;\n\n# First, we load the existing AUTHORS file. We save everything before\n# CONTRIBUTORS: line as-is so we can write it back out to the new file. Then\n# we extract name,email pairs from the remainder and store them in a pair of\n# hashtables, keyed on slug.\nmy %authors_name;\nmy %authors_email;\n\nmy @authors_header;\n\nfor my $line (do { local (@ARGV) = ('AUTHORS'); <> }) {\n\tchomp $line;\n\tstate $in_header = 1;\n\tif ($in_header) {\n\t\tpush @authors_header, $line;\n\t\t$in_header = 0 if $line =~ m/^CONTRIBUTORS:/;\n\t} else {\n\t\tmy ($name, $email) = $line =~ m/^\\s+(.+)(?= <) <([^>]+)/;\n\t\tnext unless $name;\n\n\t\tmy $semail = email_slug($email);\n\t\tmy $sname = name_slug($name);\n\n\t\t$authors_name{$semail} = $sname;\n\t\t$authors_email{$sname} = $semail;\n\n\t\t# The name/email in AUTHORS is already the \"best looking\"\n\t\t# version, by definition.\n\t\t$display_name{$sname} = $name;\n\t\t$display_email{$semail} = $email;\n\t}\n}\n\n# Next, we load all the commit authors. and form name<->email mappings, keyed\n# on slug. Note that this format is getting the .mailmap-converted form. This\n# lets us control the input to some extent by making changes there.\nmy %git_names;\nmy %git_emails;\n\nfor my $line (reverse qx(git log --pretty=tformat:'%aN:::%aE')) {\n\tchomp $line;\n\tmy ($name, $email) = $line =~ m/^(.*):::(.*)/;\n\tnext unless $name && $email;\n\n\tmy $semail = email_slug($email);\n\tmy $sname = name_slug($name);\n\n\t$git_names{$semail}{$sname} = 1;\n\t$git_emails{$sname}{$semail} = 1;\n\n\t# Update the \"best looking\" display value, but only if we don't already\n\t# have something from the AUTHORS file. If we do, we must not change it.\n\tif (!$authors_name{email_slug($email)}) {\n\t\tupdate_display_email($email);\n\t}\n\n\tif (!$authors_email{name_slug($name)}) {\n\t\tupdate_display_name($name);\n\t}\n}\n\n# Now collect unique committers by all names+emails we've ever seen for them.\n# We start with emails and resolve all possible names, then we resolve the\n# emails for those names, and round and round until there's nothing left.\nmy @committers;\nfor my $start_email (sort keys %git_names) {\n\t# it might have been deleted already through a cross-reference\n\tnext unless $git_names{$start_email};\n\n\tmy %emails;\n\tmy %names;\n\n\tmy @check_emails = ($start_email);\n\tmy @check_names;\n\twhile (@check_emails || @check_names) {\n\t\twhile (my $email = shift @check_emails) {\n\t\t\tnext if $emails{$email}++;\n\t\t\tpush @check_names,\n\t\t\t    sort keys %{delete $git_names{$email}};\n\t\t}\n\t\twhile (my $name = shift @check_names) {\n\t\t\tnext if $names{$name}++;\n\t\t\tpush @check_emails,\n\t\t\t    sort keys %{delete $git_emails{$name}};\n\t\t}\n\t}\n\n\t# A \"committer\" is the collection of connected names and emails.\n\tpush @committers, [[sort keys %emails], [sort keys %names]];\n}\n\n# Now we have our committers, we can work out what to add to AUTHORS.\nfor my $committer (@committers) {\n\tmy ($emails, $names) = @$committer;\n\n\t# If this commiter is already in AUTHORS, we must not touch.\n\tnext if grep { $authors_name{$_} } @$emails;\n\tnext if grep { $authors_email{$_} } @$names;\n\n\t# Decide on the \"best\" name and email to use\n\tmy $email = best_email(@$emails);\n\tmy $name = best_name(@$names);\n\n\t$authors_email{$name} = $email;\n\t$authors_name{$email} = $name;\n}\n\n# Now output the new AUTHORS file\nopen my $fh, '>', 'AUTHORS' or die \"E: couldn't open AUTHORS for write: $!\\n\";\n#my $fh = \\*STDOUT;\nsay $fh join(\"\\n\", @authors_header, \"\");\nfor my $name (sort keys %authors_email) {\n\tmy $cname = $display_name{$name};\n\tmy $cemail = $display_email{email_slug($authors_email{$name})};\n\tsay $fh \"    $cname <$cemail>\";\n}\n\nexit 0;\n\n# \"Slugs\" are used at the hashtable key for names and emails. They are used to\n# making two variants of a value be the \"same\" for matching. Mostly this is\n# to make upper and lower-case versions of a name or email compare the same,\n# but we do a little bit of munging to handle some common cases.\n#\n# Note that these are only used for matching internally; for display, the\n# slug will be used to look up the display form.\nsub name_slug {\n\tmy ($name) = @_;\n\n\t# Remove spaces and dots, to handle differences in initials.\n\t$name =~ s/[\\s\\.]//g;\n\n\treturn lc $name;\n}\nsub email_slug {\n\tmy ($email) = @_;\n\n\t# Remove everything up to and including the first space, and the last\n\t# space and everything after it.\n\t$email =~ s/^(.*\\s+)|(\\s+.*)$//g;\n\n\t# Remove the leading userid+ on Github noreply addresses. They're\n\t# optional and we want to treat them as the same thing.\n\t$email =~ s/^[^\\+]*\\+//g if $email =~ m/\\.noreply\\.github\\.com$/;\n\n\treturn lc $email;\n}\n\nsub update_display_name {\n\tmy ($name) = @_;\n\tmy $sname = name_slug($name);\n\n\t# For names, \"more specific\" means \"has more non-lower-case characters\"\n\t# (in ASCII), guessing that if a person has gone to some effort to\n\t# specialise their name in a later commit, they presumably care more\n\t# about it. If this is wrong, its probably better to add a .mailmap\n\t# entry.\n\n\tmy $cname = $display_name{$sname};\n\tif (!$cname ||\n\t    ($name =~ tr/a-z //) < ($cname =~ tr/a-z //)) {\n\t\t$display_name{$sname} = $name;\n\t}\n}\nsub update_display_email {\n\tmy ($email) = @_;\n\tmy $semail = email_slug($email);\n\n\t# Like names, we prefer uppercase when possible. We also remove any\n\t# leading \"plus address\" for Github noreply addresses.\n\t$email =~ s/^[^\\+]*\\+//g if $email =~ m/\\.noreply\\.github\\.com$/;\n\n\tmy $cemail = $display_email{$semail};\n\tif (!$cemail ||\n\t    ($email =~ tr/a-z //) < ($cemail =~ tr/a-z //)) {\n\t\t$display_email{$semail} = $email;\n\t}\n}\n\nsub best_name {\n\tmy @names = sort {\n\t\tmy $cmp;\n\t\tmy ($aa) = $display_name{$a};\n\t\tmy ($bb) = $display_name{$b};\n\n\t\t# The \"best\" name is very subjective, and a simple sort\n\t\t# produced good-enough results, so I didn't try harder. Use of\n\t\t# accented characters, punctuation and caps are probably an\n\t\t# indicator of \"better\", but possibly we should also take into\n\t\t# account the most recent name we saw, in case the committer\n\t\t# has changed their name or nickname or similar.\n\t\t#\n\t\t# Really, .mailmap is the place to control this.\n\n\t\treturn ($aa cmp $bb);\n\t} @_;\n\n\treturn shift @names;\n}\nsub best_email {\n\tstate $internal_re = qr/\\.(?:internal|local|\\(none\\))$/;\n\tstate $noreply_re  = qr/\\.noreply\\.github\\.com$/;\n\tstate $freemail_re = qr/\\@(?:gmail|hotmail)\\.com$/;\n\n\tmy @emails = sort {\n\t\tmy $cmp;\n\n\t\t# prefer address with a single @ over those without\n\t\t$cmp = (($b =~ tr/@//) == 1) <=> (($a =~ tr/@//) == 1);\n\t\treturn $cmp unless $cmp == 0;\n\n\t\t# prefer any address over internal/local addresses\n\t\t$cmp = (($a =~ $internal_re) <=> ($b =~ $internal_re));\n\t\treturn $cmp unless $cmp == 0;\n\n\t\t# prefer any address over github noreply aliases\n\t\t$cmp = (($a =~ $noreply_re) <=> ($b =~ $noreply_re));\n\t\treturn $cmp unless $cmp == 0;\n\n\t\t# prefer any address over freemail providers\n\t\t$cmp = (($a =~ $freemail_re) <=> ($b =~ $freemail_re));\n\t\treturn $cmp unless $cmp == 0;\n\n\t\t# alphabetical by domain\n\t\tmy ($alocal, $adom) = split /\\@/, $a;\n\t\tmy ($blocal, $bdom) = split /\\@/, $b;\n\t\t$cmp = ($adom cmp $bdom);\n\t\treturn $cmp unless $cmp == 0;\n\n\t\t# alphabetical by local part\n\t\treturn ($alocal cmp $blocal);\n\t} @_;\n\n\treturn shift @emails;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}