{
  "module_name": "krl.c",
  "hash_id": "40492a45b76fcdf7301220661420acc4f4ae8e4c90a5767ea1eb408299336e9a",
  "original_prompt": "Ingested from openssh-9.6p1/krl.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <openbsd-compat/sys-tree.h>\n#include <openbsd-compat/sys-queue.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"digest.h\"\n#include \"bitmap.h\"\n#include \"utf8.h\"\n\n#include \"krl.h\"\n\n \n#ifdef DEBUG_KRL\n# define KRL_DBG(x) debug3_f x\n#else\n# define KRL_DBG(x)\n#endif\n\n \n\n \nstruct revoked_serial {\n\tu_int64_t lo, hi;\n\tRB_ENTRY(revoked_serial) tree_entry;\n};\nstatic int serial_cmp(struct revoked_serial *a, struct revoked_serial *b);\nRB_HEAD(revoked_serial_tree, revoked_serial);\nRB_GENERATE_STATIC(revoked_serial_tree, revoked_serial, tree_entry, serial_cmp)\n\n \nstruct revoked_key_id {\n\tchar *key_id;\n\tRB_ENTRY(revoked_key_id) tree_entry;\n};\nstatic int key_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b);\nRB_HEAD(revoked_key_id_tree, revoked_key_id);\nRB_GENERATE_STATIC(revoked_key_id_tree, revoked_key_id, tree_entry, key_id_cmp)\n\n \nstruct revoked_blob {\n\tu_char *blob;\n\tsize_t len;\n\tRB_ENTRY(revoked_blob) tree_entry;\n};\nstatic int blob_cmp(struct revoked_blob *a, struct revoked_blob *b);\nRB_HEAD(revoked_blob_tree, revoked_blob);\nRB_GENERATE_STATIC(revoked_blob_tree, revoked_blob, tree_entry, blob_cmp)\n\n \nstruct revoked_certs {\n\tstruct sshkey *ca_key;\n\tstruct revoked_serial_tree revoked_serials;\n\tstruct revoked_key_id_tree revoked_key_ids;\n\tTAILQ_ENTRY(revoked_certs) entry;\n};\nTAILQ_HEAD(revoked_certs_list, revoked_certs);\n\nstruct ssh_krl {\n\tu_int64_t krl_version;\n\tu_int64_t generated_date;\n\tu_int64_t flags;\n\tchar *comment;\n\tstruct revoked_blob_tree revoked_keys;\n\tstruct revoked_blob_tree revoked_sha1s;\n\tstruct revoked_blob_tree revoked_sha256s;\n\tstruct revoked_certs_list revoked_certs;\n};\n\n \nstatic int\nserial_cmp(struct revoked_serial *a, struct revoked_serial *b)\n{\n\tif (a->hi >= b->lo && a->lo <= b->hi)\n\t\treturn 0;\n\treturn a->lo < b->lo ? -1 : 1;\n}\n\nstatic int\nkey_id_cmp(struct revoked_key_id *a, struct revoked_key_id *b)\n{\n\treturn strcmp(a->key_id, b->key_id);\n}\n\nstatic int\nblob_cmp(struct revoked_blob *a, struct revoked_blob *b)\n{\n\tint r;\n\n\tif (a->len != b->len) {\n\t\tif ((r = memcmp(a->blob, b->blob, MINIMUM(a->len, b->len))) != 0)\n\t\t\treturn r;\n\t\treturn a->len > b->len ? 1 : -1;\n\t} else\n\t\treturn memcmp(a->blob, b->blob, a->len);\n}\n\nstruct ssh_krl *\nssh_krl_init(void)\n{\n\tstruct ssh_krl *krl;\n\n\tif ((krl = calloc(1, sizeof(*krl))) == NULL)\n\t\treturn NULL;\n\tRB_INIT(&krl->revoked_keys);\n\tRB_INIT(&krl->revoked_sha1s);\n\tRB_INIT(&krl->revoked_sha256s);\n\tTAILQ_INIT(&krl->revoked_certs);\n\treturn krl;\n}\n\nstatic void\nrevoked_certs_free(struct revoked_certs *rc)\n{\n\tstruct revoked_serial *rs, *trs;\n\tstruct revoked_key_id *rki, *trki;\n\n\tRB_FOREACH_SAFE(rs, revoked_serial_tree, &rc->revoked_serials, trs) {\n\t\tRB_REMOVE(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfree(rs);\n\t}\n\tRB_FOREACH_SAFE(rki, revoked_key_id_tree, &rc->revoked_key_ids, trki) {\n\t\tRB_REMOVE(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\tsshkey_free(rc->ca_key);\n}\n\nvoid\nssh_krl_free(struct ssh_krl *krl)\n{\n\tstruct revoked_blob *rb, *trb;\n\tstruct revoked_certs *rc, *trc;\n\n\tif (krl == NULL)\n\t\treturn;\n\n\tfree(krl->comment);\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_keys, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_keys, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha1s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha1s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tRB_FOREACH_SAFE(rb, revoked_blob_tree, &krl->revoked_sha256s, trb) {\n\t\tRB_REMOVE(revoked_blob_tree, &krl->revoked_sha256s, rb);\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\tTAILQ_FOREACH_SAFE(rc, &krl->revoked_certs, entry, trc) {\n\t\tTAILQ_REMOVE(&krl->revoked_certs, rc, entry);\n\t\trevoked_certs_free(rc);\n\t}\n\tfree(krl);\n}\n\nvoid\nssh_krl_set_version(struct ssh_krl *krl, u_int64_t version)\n{\n\tkrl->krl_version = version;\n}\n\nint\nssh_krl_set_comment(struct ssh_krl *krl, const char *comment)\n{\n\tfree(krl->comment);\n\tif ((krl->comment = strdup(comment)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}\n\n \nstatic int\nrevoked_certs_for_ca_key(struct ssh_krl *krl, const struct sshkey *ca_key,\n    struct revoked_certs **rcp, int allow_create)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t*rcp = NULL;\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tif ((ca_key == NULL && rc->ca_key == NULL) ||\n\t\t    sshkey_equal(rc->ca_key, ca_key)) {\n\t\t\t*rcp = rc;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!allow_create)\n\t\treturn 0;\n\t \n\tif ((rc = calloc(1, sizeof(*rc))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (ca_key == NULL)\n\t\trc->ca_key = NULL;\n\telse if ((r = sshkey_from_private(ca_key, &rc->ca_key)) != 0) {\n\t\tfree(rc);\n\t\treturn r;\n\t}\n\tRB_INIT(&rc->revoked_serials);\n\tRB_INIT(&rc->revoked_key_ids);\n\tTAILQ_INSERT_TAIL(&krl->revoked_certs, rc, entry);\n\tKRL_DBG((\"new CA %s\", ca_key == NULL ? \"*\" : sshkey_type(ca_key)));\n\t*rcp = rc;\n\treturn 0;\n}\n\nstatic int\ninsert_serial_range(struct revoked_serial_tree *rt, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_serial rs, *ers, *crs, *irs;\n\n\tKRL_DBG((\"insert %llu:%llu\", lo, hi));\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = lo;\n\trs.hi = hi;\n\ters = RB_NFIND(revoked_serial_tree, rt, &rs);\n\tif (ers == NULL || serial_cmp(ers, &rs) != 0) {\n\t\t \n\t\tif ((irs = malloc(sizeof(rs))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tmemcpy(irs, &rs, sizeof(*irs));\n\t\ters = RB_INSERT(revoked_serial_tree, rt, irs);\n\t\tif (ers != NULL) {\n\t\t\tKRL_DBG((\"bad: ers != NULL\"));\n\t\t\t \n\t\t\tfree(irs);\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t\ters = irs;\n\t} else {\n\t\tKRL_DBG((\"overlap found %llu:%llu\", ers->lo, ers->hi));\n\t\t \n\t\tif (ers->lo > lo)\n\t\t\ters->lo = lo;\n\t\tif (ers->hi < hi)\n\t\t\ters->hi = hi;\n\t}\n\n\t \n\n\t \n\twhile ((crs = RB_PREV(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"pred %llu:%llu\", crs->lo, crs->hi));\n\t\tif (ers->lo != 0 && crs->hi < ers->lo - 1)\n\t\t\tbreak;\n\t\t \n\t\tif (crs->lo < ers->lo) {\n\t\t\ters->lo = crs->lo;\n\t\t\tKRL_DBG((\"pred extend %llu:%llu\", ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\t \n\twhile ((crs = RB_NEXT(revoked_serial_tree, rt, ers)) != NULL) {\n\t\tKRL_DBG((\"succ %llu:%llu\", crs->lo, crs->hi));\n\t\tif (ers->hi != (u_int64_t)-1 && crs->lo > ers->hi + 1)\n\t\t\tbreak;\n\t\t \n\t\tif (crs->hi > ers->hi) {\n\t\t\ters->hi = crs->hi;\n\t\t\tKRL_DBG((\"succ extend %llu:%llu\", ers->lo, ers->hi));\n\t\t}\n\t\tRB_REMOVE(revoked_serial_tree, rt, crs);\n\t\tfree(crs);\n\t}\n\tKRL_DBG((\"done, final %llu:%llu\", ers->lo, ers->hi));\n\treturn 0;\n}\n\nint\nssh_krl_revoke_cert_by_serial(struct ssh_krl *krl, const struct sshkey *ca_key,\n    u_int64_t serial)\n{\n\treturn ssh_krl_revoke_cert_by_serial_range(krl, ca_key, serial, serial);\n}\n\nint\nssh_krl_revoke_cert_by_serial_range(struct ssh_krl *krl,\n    const struct sshkey *ca_key, u_int64_t lo, u_int64_t hi)\n{\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif (lo > hi || lo == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\treturn insert_serial_range(&rc->revoked_serials, lo, hi);\n}\n\nint\nssh_krl_revoke_cert_by_key_id(struct ssh_krl *krl, const struct sshkey *ca_key,\n    const char *key_id)\n{\n\tstruct revoked_key_id *rki, *erki;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\tif ((r = revoked_certs_for_ca_key(krl, ca_key, &rc, 1)) != 0)\n\t\treturn r;\n\n\tKRL_DBG((\"revoke %s\", key_id));\n\tif ((rki = calloc(1, sizeof(*rki))) == NULL ||\n\t    (rki->key_id = strdup(key_id)) == NULL) {\n\t\tfree(rki);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\terki = RB_INSERT(revoked_key_id_tree, &rc->revoked_key_ids, rki);\n\tif (erki != NULL) {\n\t\tfree(rki->key_id);\n\t\tfree(rki);\n\t}\n\treturn 0;\n}\n\n \nstatic int\nplain_key_blob(const struct sshkey *key, u_char **blob, size_t *blen)\n{\n\tstruct sshkey *kcopy;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &kcopy)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(kcopy)) {\n\t\tif ((r = sshkey_drop_cert(kcopy)) != 0) {\n\t\t\tsshkey_free(kcopy);\n\t\t\treturn r;\n\t\t}\n\t}\n\tr = sshkey_to_blob(kcopy, blob, blen);\n\tsshkey_free(kcopy);\n\treturn r;\n}\n\n \nstatic int\nrevoke_blob(struct revoked_blob_tree *rbt, u_char *blob, size_t len)\n{\n\tstruct revoked_blob *rb, *erb;\n\n\tif ((rb = calloc(1, sizeof(*rb))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\trb->blob = blob;\n\trb->len = len;\n\terb = RB_INSERT(revoked_blob_tree, rbt, rb);\n\tif (erb != NULL) {\n\t\tfree(rb->blob);\n\t\tfree(rb);\n\t}\n\treturn 0;\n}\n\nint\nssh_krl_revoke_key_explicit(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tu_char *blob;\n\tsize_t len;\n\tint r;\n\n\tdebug3_f(\"revoke type %s\", sshkey_type(key));\n\tif ((r = plain_key_blob(key, &blob, &len)) != 0)\n\t\treturn r;\n\treturn revoke_blob(&krl->revoked_keys, blob, len);\n}\n\nstatic int\nrevoke_by_hash(struct revoked_blob_tree *target, const u_char *p, size_t len)\n{\n\tu_char *blob;\n\tint r;\n\n\t \n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tmemcpy(blob, p, len);\n\tif ((r = revoke_blob(target, blob, len)) != 0) {\n\t\tfree(blob);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nint\nssh_krl_revoke_key_sha1(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3_f(\"revoke by sha1\");\n\tif (len != 20)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha1s, p, len);\n}\n\nint\nssh_krl_revoke_key_sha256(struct ssh_krl *krl, const u_char *p, size_t len)\n{\n\tdebug3_f(\"revoke by sha256\");\n\tif (len != 32)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn revoke_by_hash(&krl->revoked_sha256s, p, len);\n}\n\nint\nssh_krl_revoke_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\t \n\tif (!sshkey_is_cert(key))\n\t\treturn ssh_krl_revoke_key_explicit(krl, key);\n\n\tif (key->cert->serial == 0) {\n\t\treturn ssh_krl_revoke_cert_by_key_id(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->key_id);\n\t} else {\n\t\treturn ssh_krl_revoke_cert_by_serial(krl,\n\t\t    key->cert->signature_key,\n\t\t    key->cert->serial);\n\t}\n}\n\n \nstatic int\nchoose_next_state(int current_state, u_int64_t contig, int final,\n    u_int64_t last_gap, u_int64_t next_gap, int *force_new_section)\n{\n\tint new_state;\n\tu_int64_t cost, cost_list, cost_range, cost_bitmap, cost_bitmap_restart;\n\n\t \n\tcontig = MINIMUM(contig, 1ULL<<31);\n\tlast_gap = MINIMUM(last_gap, 1ULL<<31);\n\tnext_gap = MINIMUM(next_gap, 1ULL<<31);\n\n\t \n\tcost_list = cost_bitmap = cost_bitmap_restart = 0;\n\tcost_range = 8;\n\tswitch (current_state) {\n\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\tcost_list = 8;\n\t\tcost_bitmap_restart = 8 + 64;\n\t\tbreak;\n\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\tcase 0:\n\t\tcost_bitmap_restart = cost_bitmap = 8 + 64;\n\t\tcost_list = 8;\n\t}\n\n\t \n\tcost_list += 64 * contig + (final ? 0 : 8+64);\n\tcost_range += (2 * 64) + (final ? 0 : 8+64);\n\tcost_bitmap += last_gap + contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\tcost_bitmap_restart += contig + (final ? 0 : MINIMUM(next_gap, 8+64));\n\n\t \n\tcost_list = (cost_list + 7) / 8;\n\tcost_bitmap = (cost_bitmap + 7) / 8;\n\tcost_bitmap_restart = (cost_bitmap_restart + 7) / 8;\n\tcost_range = (cost_range + 7) / 8;\n\n\t \n\t*force_new_section = 0;\n\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\tcost = cost_bitmap;\n\tif (cost_range < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_RANGE;\n\t\tcost = cost_range;\n\t}\n\tif (cost_list < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_LIST;\n\t\tcost = cost_list;\n\t}\n\tif (cost_bitmap_restart < cost) {\n\t\tnew_state = KRL_SECTION_CERT_SERIAL_BITMAP;\n\t\t*force_new_section = 1;\n\t\tcost = cost_bitmap_restart;\n\t}\n\tKRL_DBG((\"contig %llu last_gap %llu next_gap %llu final %d, costs:\"\n\t    \"list %llu range %llu bitmap %llu new bitmap %llu, \"\n\t    \"selected 0x%02x%s\", (long long unsigned)contig,\n\t    (long long unsigned)last_gap, (long long unsigned)next_gap, final,\n\t    (long long unsigned)cost_list, (long long unsigned)cost_range,\n\t    (long long unsigned)cost_bitmap,\n\t    (long long unsigned)cost_bitmap_restart, new_state,\n\t    *force_new_section ? \" restart\" : \"\"));\n\treturn new_state;\n}\n\nstatic int\nput_bitmap(struct sshbuf *buf, struct bitmap *bitmap)\n{\n\tsize_t len;\n\tu_char *blob;\n\tint r;\n\n\tlen = bitmap_nbytes(bitmap);\n\tif ((blob = malloc(len)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (bitmap_to_string(bitmap, blob, len) != 0) {\n\t\tfree(blob);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tr = sshbuf_put_bignum2_bytes(buf, blob, len);\n\tfree(blob);\n\treturn r;\n}\n\n \nstatic int\nrevoked_certs_generate(struct revoked_certs *rc, struct sshbuf *buf)\n{\n\tint final, force_new_sect, r = SSH_ERR_INTERNAL_ERROR;\n\tu_int64_t i, contig, gap, last = 0, bitmap_start = 0;\n\tstruct revoked_serial *rs, *nrs;\n\tstruct revoked_key_id *rki;\n\tint next_state, state = 0;\n\tstruct sshbuf *sect;\n\tstruct bitmap *bitmap = NULL;\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t \n\tif (rc->ca_key == NULL) {\n\t\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tif ((r = sshkey_puts(rc->ca_key, buf)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(buf, NULL, 0)) != 0)\n\t\tgoto out;\n\n\t \n\tfor (rs = RB_MIN(revoked_serial_tree, &rc->revoked_serials);\n\t     rs != NULL;\n\t     rs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs)) {\n\t\tKRL_DBG((\"serial %llu:%llu state 0x%02x\",\n\t\t    (long long unsigned)rs->lo, (long long unsigned)rs->hi,\n\t\t    state));\n\n\t\t \n\t\tnrs = RB_NEXT(revoked_serial_tree, &rc->revoked_serials, rs);\n\t\tfinal = nrs == NULL;\n\t\tgap = nrs == NULL ? 0 : nrs->lo - rs->hi;\n\t\tcontig = 1 + (rs->hi - rs->lo);\n\n\t\t \n\t\tnext_state = choose_next_state(state, contig, final,\n\t\t    state == 0 ? 0 : rs->lo - last, gap, &force_new_sect);\n\n\t\t \n\t\tif (state != 0 && (force_new_sect || next_state != state ||\n\t\t    state == KRL_SECTION_CERT_SERIAL_RANGE)) {\n\t\t\tKRL_DBG((\"finish state 0x%02x\", state));\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbitmap_free(bitmap);\n\t\t\t\tbitmap = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\t\tgoto out;\n\t\t\tsshbuf_reset(sect);\n\t\t}\n\n\t\t \n\t\tif (next_state != state || force_new_sect) {\n\t\t\tKRL_DBG((\"start state 0x%02x\",\n\t\t\t    next_state));\n\t\t\tstate = next_state;\n\t\t\tsshbuf_reset(sect);\n\t\t\tswitch (state) {\n\t\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\t\tbreak;\n\t\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbitmap_start = rs->lo;\n\t\t\t\tif ((r = sshbuf_put_u64(sect,\n\t\t\t\t    bitmap_start)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo + i)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_put_u64(sect, rs->lo)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(sect, rs->hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif (rs->lo - bitmap_start > INT_MAX) {\n\t\t\t\terror_f(\"insane bitmap gap\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfor (i = 0; i < contig; i++) {\n\t\t\t\tif (bitmap_set_bit(bitmap,\n\t\t\t\t    rs->lo + i - bitmap_start) != 0) {\n\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlast = rs->hi;\n\t}\n\t \n\tif (state != 0) {\n\t\tKRL_DBG((\"serial final flush for state 0x%02x\", state));\n\t\tswitch (state) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((r = put_bitmap(sect, bitmap)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif ((r = sshbuf_put_u8(buf, state)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tKRL_DBG((\"serial done \"));\n\n\t \n\tsshbuf_reset(sect);\n\tRB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {\n\t\tKRL_DBG((\"key ID %s\", rki->key_id));\n\t\tif ((r = sshbuf_put_cstring(sect, rki->key_id)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERT_KEY_ID)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tbitmap_free(bitmap);\n\tsshbuf_free(sect);\n\treturn r;\n}\n\nint\nssh_krl_to_blob(struct ssh_krl *krl, struct sshbuf *buf)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct revoked_certs *rc;\n\tstruct revoked_blob *rb;\n\tstruct sshbuf *sect;\n\tu_char *sblob = NULL;\n\n\tif (krl->generated_date == 0)\n\t\tkrl->generated_date = time(NULL);\n\n\tif ((sect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t \n\tif ((r = sshbuf_put(buf, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0 ||\n\t    (r = sshbuf_put_u32(buf, KRL_FORMAT_VERSION)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->krl_version)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->generated_date)) != 0 ||\n\t    (r = sshbuf_put_u64(buf, krl->flags)) != 0 ||\n\t    (r = sshbuf_put_string(buf, NULL, 0)) != 0 ||\n\t    (r = sshbuf_put_cstring(buf, krl->comment)) != 0)\n\t\tgoto out;\n\n\t \n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tsshbuf_reset(sect);\n\t\tif ((r = revoked_certs_generate(rc, sect)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_CERTIFICATES)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {\n\t\tKRL_DBG((\"key len %zu \", rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf, KRL_SECTION_EXPLICIT_KEY)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {\n\t\tKRL_DBG((\"hash len %zu \", rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA1)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\tsshbuf_reset(sect);\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha256s) {\n\t\tKRL_DBG((\"hash len %zu \", rb->len));\n\t\tif ((r = sshbuf_put_string(sect, rb->blob, rb->len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\tif ((r = sshbuf_put_u8(buf,\n\t\t    KRL_SECTION_FINGERPRINT_SHA256)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(buf, sect)) != 0)\n\t\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tfree(sblob);\n\tsshbuf_free(sect);\n\treturn r;\n}\n\nstatic void\nformat_timestamp(u_int64_t timestamp, char *ts, size_t nts)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\n\tt = timestamp;\n\ttm = localtime(&t);\n\tif (tm == NULL)\n\t\tstrlcpy(ts, \"<INVALID>\", nts);\n\telse {\n\t\t*ts = '\\0';\n\t\tstrftime(ts, nts, \"%Y%m%dT%H%M%S\", tm);\n\t}\n}\n\nstatic int\ncert_extension_subsection(struct sshbuf *subsect, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char critical = 1;\n\tstruct sshbuf *value = NULL;\n\tchar *name = NULL;\n\n\tif ((r = sshbuf_get_cstring(subsect, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u8(subsect, &critical)) != 0 ||\n\t    (r = sshbuf_froms(subsect, &value)) != 0) {\n\t\tdebug_fr(r, \"parse\");\n\t\terror(\"KRL has invalid certificate extension subsection\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(subsect) != 0) {\n\t\terror(\"KRL has invalid certificate extension subsection: \"\n\t\t    \"trailing data\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tdebug_f(\"cert extension %s critical %u len %zu\",\n\t    name, critical, sshbuf_len(value));\n\t \n\tif (critical) {\n\t\terror(\"KRL contains unsupported critical certificate \"\n\t\t    \"subsection \\\"%s\\\"\", name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tfree(name);\n\tsshbuf_free(value);\n\treturn r;\n}\n\nstatic int\nparse_revoked_certs(struct sshbuf *buf, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char type;\n\tconst u_char *blob;\n\tsize_t blen, nbits;\n\tstruct sshbuf *subsect = NULL;\n\tu_int64_t serial, serial_lo, serial_hi;\n\tstruct bitmap *bitmap = NULL;\n\tchar *key_id = NULL;\n\tstruct sshkey *ca_key = NULL;\n\n\tif ((subsect = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t \n\tif ((r = sshbuf_get_string_direct(buf, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_skip_string(buf)) != 0)\n\t\tgoto out;\n\tif (blen != 0 && (r = sshkey_from_blob(blob, blen, &ca_key)) != 0)\n\t\tgoto out;\n\n\twhile (sshbuf_len(buf) > 0) {\n\t\tsshbuf_free(subsect);\n\t\tsubsect = NULL;\n\t\tif ((r = sshbuf_get_u8(buf, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(buf, &subsect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"subsection type 0x%02x\", type));\n\t\t \n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERT_SERIAL_LIST:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_u64(subsect, &serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_RANGE:\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_u64(subsect, &serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((r = ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca_key, serial_lo, serial_hi)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_SERIAL_BITMAP:\n\t\t\tif ((bitmap = bitmap_new()) == NULL) {\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u64(subsect, &serial_lo)) != 0 ||\n\t\t\t    (r = sshbuf_get_bignum2_bytes_direct(subsect,\n\t\t\t    &blob, &blen)) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (bitmap_from_string(bitmap, blob, blen) != 0) {\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnbits = bitmap_nbits(bitmap);\n\t\t\tfor (serial = 0; serial < (u_int64_t)nbits; serial++) {\n\t\t\t\tif (serial > 0 && serial_lo + serial == 0) {\n\t\t\t\t\terror_f(\"bitmap wraps u64\");\n\t\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!bitmap_test_bit(bitmap, serial))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_serial(krl,\n\t\t\t\t    ca_key, serial_lo + serial)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbitmap_free(bitmap);\n\t\t\tbitmap = NULL;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_KEY_ID:\n\t\t\twhile (sshbuf_len(subsect) > 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(subsect,\n\t\t\t\t    &key_id, NULL)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif ((r = ssh_krl_revoke_cert_by_key_id(krl,\n\t\t\t\t    ca_key, key_id)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tfree(key_id);\n\t\t\t\tkey_id = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase KRL_SECTION_CERT_EXTENSION:\n\t\t\tif ((r = cert_extension_subsection(subsect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL certificate section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_len(subsect) > 0) {\n\t\t\terror(\"KRL certificate section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = 0;\n out:\n\tif (bitmap != NULL)\n\t\tbitmap_free(bitmap);\n\tfree(key_id);\n\tsshkey_free(ca_key);\n\tsshbuf_free(subsect);\n\treturn r;\n}\n\nstatic int\nblob_section(struct sshbuf *sect, struct revoked_blob_tree *target_tree,\n    size_t expected_len)\n{\n\tu_char *rdata = NULL;\n\tsize_t rlen = 0;\n\tint r;\n\n\twhile (sshbuf_len(sect) > 0) {\n\t\tif ((r = sshbuf_get_string(sect, &rdata, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (expected_len != 0 && rlen != expected_len) {\n\t\t\terror_f(\"bad length\");\n\t\t\tfree(rdata);\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t\tif ((r = revoke_blob(target_tree, rdata, rlen)) != 0) {\n\t\t\tfree(rdata);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nextension_section(struct sshbuf *sect, struct ssh_krl *krl)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char critical = 1;\n\tstruct sshbuf *value = NULL;\n\tchar *name = NULL;\n\n\tif ((r = sshbuf_get_cstring(sect, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u8(sect, &critical)) != 0 ||\n\t    (r = sshbuf_froms(sect, &value)) != 0) {\n\t\tdebug_fr(r, \"parse\");\n\t\terror(\"KRL has invalid extension section\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(sect) != 0) {\n\t\terror(\"KRL has invalid extension section: trailing data\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tdebug_f(\"extension %s critical %u len %zu\",\n\t    name, critical, sshbuf_len(value));\n\t \n\tif (critical) {\n\t\terror(\"KRL contains unsupported critical section \\\"%s\\\"\", name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tfree(name);\n\tsshbuf_free(value);\n\treturn r;\n}\n\n \nint\nssh_krl_from_blob(struct sshbuf *buf, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *copy = NULL, *sect = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tchar timestamp[64];\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char type;\n\tu_int format_version;\n\n\t*krlp = NULL;\n\n\t \n\tif ((r = sshbuf_cmp(buf, 0, KRL_MAGIC, sizeof(KRL_MAGIC) - 1)) != 0) {\n\t\tdebug2_f(\"bad KRL magic header\");\n\t\treturn SSH_ERR_KRL_BAD_MAGIC;\n\t}\n\n\tif ((krl = ssh_krl_init()) == NULL) {\n\t\terror_f(\"alloc failed\");\n\t\tgoto out;\n\t}\n\t \n\tif ((copy = sshbuf_fromb(buf)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(copy, sizeof(KRL_MAGIC) - 1)) != 0 ||\n\t    (r = sshbuf_get_u32(copy, &format_version)) != 0)\n\t\tgoto out;\n\tif (format_version != KRL_FORMAT_VERSION) {\n\t\terror_f(\"unsupported KRL format version %u\", format_version);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u64(copy, &krl->krl_version)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->generated_date)) != 0 ||\n\t    (r = sshbuf_get_u64(copy, &krl->flags)) != 0 ||\n\t    (r = sshbuf_skip_string(copy)) != 0 ||\n\t    (r = sshbuf_get_cstring(copy, &krl->comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse KRL header\");\n\t\tgoto out;\n\t}\n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tdebug(\"KRL version %llu generated at %s%s%s\",\n\t    (long long unsigned)krl->krl_version, timestamp,\n\t    *krl->comment ? \": \" : \"\", krl->comment);\n\n\t \n\twhile (sshbuf_len(copy) > 0) {\n\t\tsshbuf_free(sect);\n\t\tsect = NULL;\n\t\tif ((r = sshbuf_get_u8(copy, &type)) != 0 ||\n\t\t    (r = sshbuf_froms(copy, &sect)) != 0)\n\t\t\tgoto out;\n\t\tKRL_DBG((\"section 0x%02x\", type));\n\n\t\tswitch (type) {\n\t\tcase KRL_SECTION_CERTIFICATES:\n\t\t\tif ((r = parse_revoked_certs(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXPLICIT_KEY:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_keys, 0)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA1:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha1s, 20)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_FINGERPRINT_SHA256:\n\t\t\tif ((r = blob_section(sect,\n\t\t\t    &krl->revoked_sha256s, 32)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_EXTENSION:\n\t\t\tif ((r = extension_section(sect, krl)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase KRL_SECTION_SIGNATURE:\n\t\t\t \n\t\t\tsshbuf_free(sect);\n\t\t\tsect = NULL;\n\t\t\tif ((r = sshbuf_skip_string(copy)) != 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"Unsupported KRL section %u\", type);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sect != NULL && sshbuf_len(sect) > 0) {\n\t\t\terror(\"KRL section contains unparsed data\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\t*krlp = krl;\n\tr = 0;\n out:\n\tif (r != 0)\n\t\tssh_krl_free(krl);\n\tsshbuf_free(copy);\n\tsshbuf_free(sect);\n\treturn r;\n}\n\n \nstatic int\nis_cert_revoked(const struct sshkey *key, struct revoked_certs *rc)\n{\n\tstruct revoked_serial rs, *ers;\n\tstruct revoked_key_id rki, *erki;\n\n\t \n\tmemset(&rki, 0, sizeof(rki));\n\trki.key_id = key->cert->key_id;\n\terki = RB_FIND(revoked_key_id_tree, &rc->revoked_key_ids, &rki);\n\tif (erki != NULL) {\n\t\tKRL_DBG((\"revoked by key ID\"));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t \n\tif (key->cert->serial == 0)\n\t\treturn 0;\n\n\tmemset(&rs, 0, sizeof(rs));\n\trs.lo = rs.hi = key->cert->serial;\n\ters = RB_FIND(revoked_serial_tree, &rc->revoked_serials, &rs);\n\tif (ers != NULL) {\n\t\tKRL_DBG((\"revoked serial %llu matched %llu:%llu\",\n\t\t    key->cert->serial, ers->lo, ers->hi));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nis_key_revoked(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tstruct revoked_blob rb, *erb;\n\tstruct revoked_certs *rc;\n\tint r;\n\n\t \n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA1,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha1s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"revoked by key SHA1\"));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = sshkey_fingerprint_raw(key, SSH_DIGEST_SHA256,\n\t    &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_sha256s, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"revoked by key SHA256\"));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\t \n\tmemset(&rb, 0, sizeof(rb));\n\tif ((r = plain_key_blob(key, &rb.blob, &rb.len)) != 0)\n\t\treturn r;\n\terb = RB_FIND(revoked_blob_tree, &krl->revoked_keys, &rb);\n\tfree(rb.blob);\n\tif (erb != NULL) {\n\t\tKRL_DBG((\"revoked by explicit key\"));\n\t\treturn SSH_ERR_KEY_REVOKED;\n\t}\n\n\tif (!sshkey_is_cert(key))\n\t\treturn 0;\n\n\t \n\tif ((r = revoked_certs_for_ca_key(krl, key->cert->signature_key,\n\t    &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\t \n\tif ((r = revoked_certs_for_ca_key(krl, NULL, &rc, 0)) != 0)\n\t\treturn r;\n\tif (rc != NULL) {\n\t\tif ((r = is_cert_revoked(key, rc)) != 0)\n\t\t\treturn r;\n\t}\n\n\tKRL_DBG((\"%llu no match\", key->cert->serial));\n\treturn 0;\n}\n\nint\nssh_krl_check_key(struct ssh_krl *krl, const struct sshkey *key)\n{\n\tint r;\n\n\tKRL_DBG((\"checking key\"));\n\tif ((r = is_key_revoked(krl, key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_cert(key)) {\n\t\tdebug2_f(\"checking CA key\");\n\t\tif ((r = is_key_revoked(krl, key->cert->signature_key)) != 0)\n\t\t\treturn r;\n\t}\n\tKRL_DBG((\"key okay\"));\n\treturn 0;\n}\n\nint\nssh_krl_file_contains_key(const char *path, const struct sshkey *key)\n{\n\tstruct sshbuf *krlbuf = NULL;\n\tstruct ssh_krl *krl = NULL;\n\tint oerrno = 0, r;\n\n\tif (path == NULL)\n\t\treturn 0;\n\tif ((r = sshbuf_load_file(path, &krlbuf)) != 0) {\n\t\toerrno = errno;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_krl_from_blob(krlbuf, &krl)) != 0)\n\t\tgoto out;\n\tdebug2_f(\"checking KRL %s\", path);\n\tr = ssh_krl_check_key(krl, key);\n out:\n\tsshbuf_free(krlbuf);\n\tssh_krl_free(krl);\n\tif (r != 0)\n\t\terrno = oerrno;\n\treturn r;\n}\n\nint\nkrl_dump(struct ssh_krl *krl, FILE *f)\n{\n\tstruct sshkey *key = NULL;\n\tstruct revoked_blob *rb;\n\tstruct revoked_certs *rc;\n\tstruct revoked_serial *rs;\n\tstruct revoked_key_id *rki;\n\tint r, ret = 0;\n\tchar *fp, timestamp[64];\n\n\t \n\tformat_timestamp(krl->generated_date, timestamp, sizeof(timestamp));\n\tfprintf(f, \"# KRL version %llu\\n\",\n\t    (unsigned long long)krl->krl_version);\n\tfprintf(f, \"# Generated at %s\\n\", timestamp);\n\tif (krl->comment != NULL && *krl->comment != '\\0') {\n\t\tr = INT_MAX;\n\t\tasmprintf(&fp, INT_MAX, &r, \"%s\", krl->comment);\n\t\tfprintf(f, \"# Comment: %s\\n\", fp);\n\t\tfree(fp);\n\t}\n\tfputc('\\n', f);\n\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_keys) {\n\t\tif ((r = sshkey_from_blob(rb->blob, rb->len, &key)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\terror_r(r, \"parse KRL key\");\n\t\t\tcontinue;\n\t\t}\n\t\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\terror(\"sshkey_fingerprint failed\");\n\t\t\tcontinue;\n\t\t}\n\t\tfprintf(f, \"hash: %s # %s\\n\", fp, sshkey_ssh_name(key));\n\t\tfree(fp);\n\t\tfree(key);\n\t}\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha256s) {\n\t\tfp = tohex(rb->blob, rb->len);\n\t\tfprintf(f, \"hash: SHA256:%s\\n\", fp);\n\t\tfree(fp);\n\t}\n\tRB_FOREACH(rb, revoked_blob_tree, &krl->revoked_sha1s) {\n\t\t \n\t\tfp = tohex(rb->blob, rb->len);\n\t\tfprintf(f, \"# hash SHA1:%s\\n\", fp);\n\t\tfree(fp);\n\t}\n\n\tTAILQ_FOREACH(rc, &krl->revoked_certs, entry) {\n\t\tfputc('\\n', f);\n\t\tif (rc->ca_key == NULL)\n\t\t\tfprintf(f, \"# Wildcard CA\\n\");\n\t\telse {\n\t\t\tif ((fp = sshkey_fingerprint(rc->ca_key,\n\t\t\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL) {\n\t\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\t\terror(\"sshkey_fingerprint failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfprintf(f, \"# CA key %s %s\\n\",\n\t\t\t    sshkey_ssh_name(rc->ca_key), fp);\n\t\t\tfree(fp);\n\t\t}\n\t\tRB_FOREACH(rs, revoked_serial_tree, &rc->revoked_serials) {\n\t\t\tif (rs->lo == rs->hi) {\n\t\t\t\tfprintf(f, \"serial: %llu\\n\",\n\t\t\t\t    (unsigned long long)rs->lo);\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"serial: %llu-%llu\\n\",\n\t\t\t\t    (unsigned long long)rs->lo,\n\t\t\t\t    (unsigned long long)rs->hi);\n\t\t\t}\n\t\t}\n\t\tRB_FOREACH(rki, revoked_key_id_tree, &rc->revoked_key_ids) {\n\t\t\t \n\t\t\tr = INT_MAX;\n\t\t\tasmprintf(&fp, INT_MAX, &r, \"%s\", rki->key_id);\n\t\t\tfprintf(f, \"id: %s\\n\", fp);\n\t\t\tfree(fp);\n\t\t}\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}