{
  "module_name": "scp.c",
  "hash_id": "05799b077391241f28edf6b28dd3bba70c2937b50c87e44b64bd759ff0a87afd",
  "original_prompt": "Ingested from openssh-9.6p1/scp.c",
  "human_readable_source": " \n \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/wait.h>\n#include <sys/uio.h>\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_FNMATCH_H\n#include <fnmatch.h>\n#endif\n#ifdef USE_SYSTEM_GLOB\n# include <glob.h>\n#else\n# include \"openbsd-compat/glob.h\"\n#endif\n#ifdef HAVE_LIBGEN_H\n#include <libgen.h>\n#endif\n#include <limits.h>\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n#include <locale.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n#include <vis.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"atomicio.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"progressmeter.h\"\n#include \"utf8.h\"\n#include \"sftp.h\"\n\n#include \"sftp-common.h\"\n#include \"sftp-client.h\"\n\nextern char *__progname;\n\n#define COPY_BUFLEN\t16384\n\nint do_cmd(char *, char *, char *, int, int, char *, int *, int *, pid_t *);\nint do_cmd2(char *, char *, int, char *, int, int);\n\n \narglist args;\narglist remote_remote_args;\n\n \nlong long limit_kbps = 0;\nstruct bwlimit bwlimit;\n\n \nchar *curfile;\n\n \nint verbose_mode = 0;\nLogLevel log_level = SYSLOG_LEVEL_INFO;\n\n \nint showprogress = 1;\n\n \nint throughlocal = 1;\n\n \nint sshport = -1;\n\n \nchar *ssh_program = _PATH_SSH_PROGRAM;\n\n \npid_t do_cmd_pid = -1;\npid_t do_cmd_pid2 = -1;\n\n \nsize_t sftp_copy_buflen;\nsize_t sftp_nrequests;\n\n \nvolatile sig_atomic_t interrupted = 0;\n\nint sftp_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);  \n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\t(void)waitpid(do_cmd_pid, NULL, 0);\n\t}\n\tif (do_cmd_pid2 > 1) {\n\t\tkill(do_cmd_pid2, signo ? signo : SIGTERM);\n\t\t(void)waitpid(do_cmd_pid2, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic void\nsuspone(int pid, int signo)\n{\n\tint status;\n\n\tif (pid > 1) {\n\t\tkill(pid, signo);\n\t\twhile (waitpid(pid, &status, WUNTRACED) == -1 &&\n\t\t    errno == EINTR)\n\t\t\t;\n\t}\n}\n\nstatic void\nsuspchild(int signo)\n{\n\tsuspone(do_cmd_pid, signo);\n\tsuspone(do_cmd_pid2, signo);\n\tkill(getpid(), SIGSTOP);\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfmprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n\t\texit(1);\n\t}\n\n\tdo_cmd_pid = pid;\n\tssh_signal(SIGTERM, killchild);\n\tssh_signal(SIGINT, killchild);\n\tssh_signal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n \n\nint\ndo_cmd(char *program, char *host, char *remuser, int port, int subsystem,\n    char *cmd, int *fdin, int *fdout, pid_t *pid)\n{\n#ifdef USE_PIPES\n\tint pin[2], pout[2];\n#else\n\tint sv[2];\n#endif\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n#ifdef USE_PIPES\n\tif (pipe(pin) == -1 || pipe(pout) == -1)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n#else\n\t \n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1)\n\t\tfatal(\"socketpair: %s\", strerror(errno));\n#endif\n\n\tssh_signal(SIGTSTP, suspchild);\n\tssh_signal(SIGTTIN, suspchild);\n\tssh_signal(SIGTTOU, suspchild);\n\n\t \n\t*pid = fork();\n\tswitch (*pid) {\n\tcase -1:\n\t\tfatal(\"fork: %s\", strerror(errno));\n\tcase 0:\n\t\t \n#ifdef USE_PIPES\n\t\tif (dup2(pin[0], STDIN_FILENO) == -1 ||\n\t\t    dup2(pout[1], STDOUT_FILENO) == -1) {\n\t\t\terror(\"dup2: %s\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n#else\n\t\tif (dup2(sv[0], STDIN_FILENO) == -1 ||\n\t\t    dup2(sv[0], STDOUT_FILENO) == -1) {\n\t\t\terror(\"dup2: %s\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(sv[0]);\n\t\tclose(sv[1]);\n#endif\n\t\treplacearg(&args, 0, \"%s\", program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\tif (subsystem)\n\t\t\taddargs(&args, \"-s\");\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(program, args.list);\n\t\tperror(program);\n\t\t_exit(1);\n\tdefault:\n\t\t \n#ifdef USE_PIPES\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\t\t*fdout = pin[1];\n\t\t*fdin = pout[0];\n#else\n\t\tclose(sv[0]);\n\t\t*fdin = sv[1];\n\t\t*fdout = sv[1];\n#endif\n\t\tssh_signal(SIGTERM, killchild);\n\t\tssh_signal(SIGINT, killchild);\n\t\tssh_signal(SIGHUP, killchild);\n\t\treturn 0;\n\t}\n}\n\n \nint\ndo_cmd2(char *host, char *remuser, int port, char *cmd,\n    int fdin, int fdout)\n{\n\tint status;\n\tpid_t pid;\n\n\tif (verbose_mode)\n\t\tfmprintf(stderr,\n\t\t    \"Executing: 2nd program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\tif (port == -1)\n\t\tport = sshport;\n\n\t \n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (dup2(fdin, 0) == -1)\n\t\t\tperror(\"dup2\");\n\t\tif (dup2(fdout, 1) == -1)\n\t\t\tperror(\"dup2\");\n\n\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\tif (port != -1) {\n\t\t\taddargs(&args, \"-p\");\n\t\t\taddargs(&args, \"%d\", port);\n\t\t}\n\t\tif (remuser != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", remuser);\n\t\t}\n\t\taddargs(&args, \"-oBatchMode=yes\");\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", cmd);\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n\t\texit(1);\n\t} else if (pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_cmd2: waitpid: %s\", strerror(errno));\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nint okname(char *);\nvoid run_err(const char *,...)\n    __attribute__((__format__ (printf, 1, 2)))\n    __attribute__((__nonnull__ (1)));\nint note_err(const char *,...)\n    __attribute__((__format__ (printf, 1, 2)));\nvoid verifydir(char *);\n\nstruct passwd *pwd;\nuid_t userid;\nint errs, remin, remout, remin2, remout2;\nint Tflag, pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t \n\nenum scp_mode_e {\n\tMODE_SCP,\n\tMODE_SFTP\n};\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[], const char *);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[], enum scp_mode_e, char *sftp_direct);\nvoid toremote(int, char *[], enum scp_mode_e, char *sftp_direct);\nvoid usage(void);\n\nvoid source_sftp(int, char *, char *, struct sftp_conn *);\nvoid sink_sftp(int, char *, const char *, struct sftp_conn *);\nvoid throughlocal_sftp(struct sftp_conn *, struct sftp_conn *,\n    char *, char *);\n\nint\nmain(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, r, n;\n\tchar **newargv, *argv0;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\tenum scp_mode_e mode = MODE_SFTP;\n\tchar *sftp_direct = NULL;\n\tlong long llv;\n\n\t \n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t \n\targv0 = argv[0];\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tlog_init(argv0, log_level, SYSLOG_FACILITY_USER, 2);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = Tflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv,\n\t    \"12346ABCTdfOpqRrstvD:F:J:M:P:S:c:i:l:o:X:\")) != -1) {\n\t\tswitch (ch) {\n\t\t \n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'A':\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tsftp_direct = optarg;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tthroughlocal = 0;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\tcase 'J':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tmode = MODE_SCP;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmode = MODE_SFTP;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024;  \n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tif (verbose_mode == 0)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse if (log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\tlog_level++;\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\t \n\t\t\tif (strncmp(optarg, \"buffer=\", 7) == 0) {\n\t\t\t\tr = scan_scaled(optarg + 7, &llv);\n\t\t\t\tif (r == 0 && (llv <= 0 || llv > 256 * 1024)) {\n\t\t\t\t\tr = -1;\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t}\n\t\t\t\tif (r == -1) {\n\t\t\t\t\tfatal(\"Invalid buffer size \\\"%s\\\": %s\",\n\t\t\t\t\t     optarg + 7, strerror(errno));\n\t\t\t\t}\n\t\t\t\tsftp_copy_buflen = (size_t)llv;\n\t\t\t} else if (strncmp(optarg, \"nrequests=\", 10) == 0) {\n\t\t\t\tllv = strtonum(optarg + 10, 1, 256 * 1024,\n\t\t\t\t    &errstr);\n\t\t\t\tif (errstr != NULL) {\n\t\t\t\t\tfatal(\"Invalid number of requests \"\n\t\t\t\t\t    \"\\\"%s\\\": %s\", optarg + 10, errstr);\n\t\t\t\t}\n\t\t\t\tsftp_nrequests = (size_t)llv;\n\t\t\t} else {\n\t\t\t\tfatal(\"Invalid -X option\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t \n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t \n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tTflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tlog_init(argv0, log_level, SYSLOG_FACILITY_USER, 2);\n\n\t \n\taddargs(&args, \"-oForwardAgent=no\");\n\n\tif (iamremote)\n\t\tmode = MODE_SCP;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t \n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t \n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t \n\t\tsink(argc, argv, NULL);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t \n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) ssh_signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t \n\t\ttoremote(argc, argv, mode, sftp_direct);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv, mode, sftp_direct);\t \n\t}\n\t \n\tif (do_cmd_pid != -1 && (mode == MODE_SFTP || errs == 0)) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n\n \nstatic int\nscpio(void *_cnt, size_t s)\n{\n\toff_t *cnt = (off_t *)_cnt;\n\n\t*cnt += s;\n\trefresh_progress_meter(0);\n\tif (limit_kbps > 0)\n\t\tbandwidth_limit(&bwlimit, s);\n\treturn 0;\n}\n\nstatic int\ndo_times(int fd, int verb, const struct stat *sb)\n{\n\t \n\tchar buf[(20 + 7 + 2) * 2 + 2];\n\n\t(void)snprintf(buf, sizeof(buf), \"T%llu 0 %llu 0\\n\",\n\t    (unsigned long long) (sb->st_mtime < 0 ? 0 : sb->st_mtime),\n\t    (unsigned long long) (sb->st_atime < 0 ? 0 : sb->st_atime));\n\tif (verb) {\n\t\tfprintf(stderr, \"File mtime %lld atime %lld\\n\",\n\t\t    (long long)sb->st_mtime, (long long)sb->st_atime);\n\t\tfprintf(stderr, \"Sending file timestamps: %s\", buf);\n\t}\n\t(void) atomicio(vwrite, fd, buf, strlen(buf));\n\treturn (response());\n}\n\nstatic int\nparse_scp_uri(const char *uri, char **userp, char **hostp, int *portp,\n    char **pathp)\n{\n\tint r;\n\n\tr = parse_uri(\"scp\", uri, userp, hostp, portp, pathp);\n\tif (r == 0 && *pathp == NULL)\n\t\t*pathp = xstrdup(\".\");\n\treturn r;\n}\n\n \nstatic int\nappend(char *cp, char ***ap, size_t *np)\n{\n\tchar **tmp;\n\n\tif ((tmp = reallocarray(*ap, *np + 1, sizeof(*tmp))) == NULL)\n\t\treturn -1;\n\ttmp[(*np)] = cp;\n\t(*np)++;\n\t*ap = tmp;\n\treturn 0;\n}\n\n \nstatic int\nfind_brace(const char *pattern, int *startp, int *endp)\n{\n\tint i;\n\tint in_bracket, brace_level;\n\n\t*startp = *endp = -1;\n\tin_bracket = brace_level = 0;\n\tfor (i = 0; i < INT_MAX && *endp < 0 && pattern[i] != '\\0'; i++) {\n\t\tswitch (pattern[i]) {\n\t\tcase '\\\\':\n\t\t\t \n\t\t\tif (pattern[i + 1] != '\\0')\n\t\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tin_bracket = 1;\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tin_bracket = 0;\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tif (pattern[i + 1] == '}') {\n\t\t\t\t \n\t\t\t\ti++;  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*startp == -1)\n\t\t\t\t*startp = i;\n\t\t\tbrace_level++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tif (*startp < 0) {\n\t\t\t\t \n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (--brace_level <= 0)\n\t\t\t\t*endp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (*endp < 0 && (*startp >= 0 || in_bracket))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic int\nemit_expansion(const char *pattern, int brace_start, int brace_end,\n    int sel_start, int sel_end, char ***patternsp, size_t *npatternsp)\n{\n\tchar *cp;\n\tsize_t pattern_len;\n\tint o = 0, tail_len;\n\n\tif ((pattern_len = strlen(pattern)) == 0 || pattern_len >= INT_MAX)\n\t\treturn -1;\n\n\ttail_len = strlen(pattern + brace_end + 1);\n\tif ((cp = malloc(brace_start + (sel_end - sel_start) +\n\t    tail_len + 1)) == NULL)\n\t\treturn -1;\n\n\t \n\tif (brace_start > 0) {\n\t\tmemcpy(cp, pattern, brace_start);\n\t\to = brace_start;\n\t}\n\t \n\tif (sel_end - sel_start > 0) {\n\t\tmemcpy(cp + o, pattern + sel_start,\n\t\t    sel_end - sel_start);\n\t\to += sel_end - sel_start;\n\t}\n\t \n\tif (tail_len > 0) {\n\t\tmemcpy(cp + o, pattern + brace_end + 1, tail_len);\n\t\to += tail_len;\n\t}\n\tcp[o] = '\\0';\n\tif (append(cp, patternsp, npatternsp) != 0) {\n\t\tfree(cp);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nbrace_expand_one(const char *pattern, char ***patternsp, size_t *npatternsp,\n    int *expanded, int *invalid)\n{\n\tint i;\n\tint in_bracket, brace_start, brace_end, brace_level;\n\tint sel_start, sel_end;\n\n\t*invalid = *expanded = 0;\n\n\tif (find_brace(pattern, &brace_start, &brace_end) != 0) {\n\t\t*invalid = 1;\n\t\treturn 0;\n\t} else if (brace_start == -1)\n\t\treturn 0;\n\n\tin_bracket = brace_level = 0;\n\tfor (i = sel_start = brace_start + 1; i < brace_end; i++) {\n\t\tswitch (pattern[i]) {\n\t\tcase '{':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tbrace_level++;\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tif (in_bracket)\n\t\t\t\tbreak;\n\t\t\tbrace_level--;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tin_bracket = 1;\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tin_bracket = 0;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif (i < brace_end - 1)\n\t\t\t\ti++;  \n\t\t\tbreak;\n\t\t}\n\t\tif (pattern[i] == ',' || i == brace_end - 1) {\n\t\t\tif (in_bracket || brace_level > 0)\n\t\t\t\tcontinue;\n\t\t\t \n\n\t\t\t \n\t\t\tsel_end = (i == brace_end - 1) ? brace_end : i;\n\t\t\tif (emit_expansion(pattern, brace_start, brace_end,\n\t\t\t    sel_start, sel_end, patternsp, npatternsp) != 0)\n\t\t\t\treturn -1;\n\t\t\t \n\t\t\tsel_start = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (in_bracket || brace_level > 0) {\n\t\t*invalid = 1;\n\t\treturn 0;\n\t}\n\t \n\t*expanded = 1;\n\treturn 0;\n}\n\n \nstatic int\nbrace_expand(const char *pattern, char ***patternsp, size_t *npatternsp)\n{\n\tchar *cp, *cp2, **active = NULL, **done = NULL;\n\tsize_t i, nactive = 0, ndone = 0;\n\tint ret = -1, invalid = 0, expanded = 0;\n\n\t*patternsp = NULL;\n\t*npatternsp = 0;\n\n\t \n\tif ((cp = strdup(pattern)) == NULL)\n\t\treturn -1;\n\tif (append(cp, &active, &nactive) != 0) {\n\t\tfree(cp);\n\t\treturn -1;\n\t}\n\twhile (nactive > 0) {\n\t\tcp = active[nactive - 1];\n\t\tnactive--;\n\t\tif (brace_expand_one(cp, &active, &nactive,\n\t\t    &expanded, &invalid) == -1) {\n\t\t\tfree(cp);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (invalid)\n\t\t\tfatal_f(\"invalid brace pattern \\\"%s\\\"\", cp);\n\t\tif (expanded) {\n\t\t\t \n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif ((cp2 = strrchr(cp, '/')) != NULL)\n\t\t\t*cp2++ = '\\0';\n\t\telse\n\t\t\tcp2 = cp;\n\t\tif (append(xstrdup(cp2), &done, &ndone) != 0) {\n\t\t\tfree(cp);\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(cp);\n\t}\n\t \n\t*patternsp = done;\n\t*npatternsp = ndone;\n\tdone = NULL;\n\tndone = 0;\n\tret = 0;\n fail:\n\tfor (i = 0; i < nactive; i++)\n\t\tfree(active[i]);\n\tfree(active);\n\tfor (i = 0; i < ndone; i++)\n\t\tfree(done[i]);\n\tfree(done);\n\treturn ret;\n}\n\nstatic struct sftp_conn *\ndo_sftp_connect(char *host, char *user, int port, char *sftp_direct,\n   int *reminp, int *remoutp, int *pidp)\n{\n\tif (sftp_direct == NULL) {\n\t\tif (do_cmd(ssh_program, host, user, port, 1, \"sftp\",\n\t\t    reminp, remoutp, pidp) < 0)\n\t\t\treturn NULL;\n\n\t} else {\n\t\tfreeargs(&args);\n\t\taddargs(&args, \"sftp-server\");\n\t\tif (do_cmd(sftp_direct, host, NULL, -1, 0, \"sftp\",\n\t\t    reminp, remoutp, pidp) < 0)\n\t\t\treturn NULL;\n\t}\n\treturn sftp_init(*reminp, *remoutp,\n\t    sftp_copy_buflen, sftp_nrequests, limit_kbps);\n}\n\nvoid\ntoremote(int argc, char **argv, enum scp_mode_e mode, char *sftp_direct)\n{\n\tchar *suser = NULL, *host = NULL, *src = NULL;\n\tchar *bp, *tuser, *thost, *targ;\n\tint sport = -1, tport = -1;\n\tstruct sftp_conn *conn = NULL, *conn2 = NULL;\n\targlist alist;\n\tint i, r, status;\n\tstruct stat sb;\n\tu_int j;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t \n\tr = parse_scp_uri(argv[argc - 1], &tuser, &thost, &tport, &targ);\n\tif (r == -1) {\n\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[argc - 1]);\n\t\t++errs;\n\t\tgoto out;\n\t}\n\tif (r != 0) {\n\t\tif (parse_user_host_path(argv[argc - 1], &tuser, &thost,\n\t\t    &targ) == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid target\\n\", argv[argc - 1]);\n\t\t\t++errs;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0) {\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\t}\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (host && throughlocal) {\t \n\t\t\tif (mode == MODE_SFTP) {\n\t\t\t\tif (remin == -1) {\n\t\t\t\t\t \n\t\t\t\t\tconn = do_sftp_connect(thost, tuser,\n\t\t\t\t\t    tport, sftp_direct,\n\t\t\t\t\t    &remin, &remout, &do_cmd_pid);\n\t\t\t\t\tif (conn == NULL) {\n\t\t\t\t\t\tfatal(\"Unable to open \"\n\t\t\t\t\t\t    \"destination connection\");\n\t\t\t\t\t}\n\t\t\t\t\tdebug3_f(\"origin in %d out %d pid %ld\",\n\t\t\t\t\t    remin, remout, (long)do_cmd_pid);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tconn2 = do_sftp_connect(host, suser,\n\t\t\t\t    sport, sftp_direct,\n\t\t\t\t    &remin2, &remout2, &do_cmd_pid2);\n\t\t\t\tif (conn2 == NULL) {\n\t\t\t\t\tfatal(\"Unable to open \"\n\t\t\t\t\t    \"source connection\");\n\t\t\t\t}\n\t\t\t\tdebug3_f(\"destination in %d out %d pid %ld\",\n\t\t\t\t    remin2, remout2, (long)do_cmd_pid2);\n\t\t\t\tthroughlocal_sftp(conn2, conn, src, targ);\n\t\t\t\t(void) close(remin2);\n\t\t\t\t(void) close(remout2);\n\t\t\t\tremin2 = remout2 = -1;\n\t\t\t\tif (waitpid(do_cmd_pid2, &status, 0) == -1)\n\t\t\t\t\t++errs;\n\t\t\t\telse if (!WIFEXITED(status) ||\n\t\t\t\t    WEXITSTATUS(status) != 0)\n\t\t\t\t\t++errs;\n\t\t\t\tdo_cmd_pid2 = -1;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\txasprintf(&bp, \"%s -f %s%s\", cmd,\n\t\t\t\t    *src == '-' ? \"-- \" : \"\", src);\n\t\t\t\tif (do_cmd(ssh_program, host, suser, sport, 0,\n\t\t\t\t    bp, &remin, &remout, &do_cmd_pid) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd2(thost, tuser, tport, bp,\n\t\t\t\t    remin, remout) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t\t(void) close(remin);\n\t\t\t\t(void) close(remout);\n\t\t\t\tremin = remout = -1;\n\t\t\t}\n\t\t} else if (host) {\t \n\t\t\t \n\t\t\tif (tuser != NULL && !okname(tuser)) {\n\t\t\t\t++errs;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tport != -1 && tport != SSH_DEFAULT_PORT) {\n\t\t\t\t \n\t\t\t\tfatal(\"target port not supported with two \"\n\t\t\t\t    \"remote hosts and the -R option\");\n\t\t\t}\n\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings=yes\");\n\t\t\taddargs(&alist, \"-n\");\n\t\t\tfor (j = 0; j < remote_remote_args.num; j++) {\n\t\t\t\taddargs(&alist, \"%s\",\n\t\t\t\t    remote_remote_args.list[j]);\n\t\t\t}\n\n\t\t\tif (sport != -1) {\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\t\taddargs(&alist, \"%d\", sport);\n\t\t\t}\n\t\t\tif (suser) {\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t}\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t \n\t\t\tif (mode == MODE_SFTP) {\n\t\t\t\t \n\t\t\t\tif (stat(argv[i], &sb) != 0) {\n\t\t\t\t\tfatal(\"stat local \\\"%s\\\": %s\", argv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\tif (remin == -1) {\n\t\t\t\t\t \n\t\t\t\t\tconn = do_sftp_connect(thost, tuser,\n\t\t\t\t\t    tport, sftp_direct,\n\t\t\t\t\t    &remin, &remout, &do_cmd_pid);\n\t\t\t\t\tif (conn == NULL) {\n\t\t\t\t\t\tfatal(\"Unable to open sftp \"\n\t\t\t\t\t\t    \"connection\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tsource_sftp(1, argv[i], targ, conn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (remin == -1) {\n\t\t\t\txasprintf(&bp, \"%s -t %s%s\", cmd,\n\t\t\t\t    *targ == '-' ? \"-- \" : \"\", targ);\n\t\t\t\tif (do_cmd(ssh_program, thost, tuser, tport, 0,\n\t\t\t\t    bp, &remin, &remout, &do_cmd_pid) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\nout:\n\tif (mode == MODE_SFTP)\n\t\tfree(conn);\n\tfree(tuser);\n\tfree(thost);\n\tfree(targ);\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\nvoid\ntolocal(int argc, char **argv, enum scp_mode_e mode, char *sftp_direct)\n{\n\tchar *bp, *host = NULL, *src = NULL, *suser = NULL;\n\targlist alist;\n\tstruct sftp_conn *conn = NULL;\n\tint i, r, sport = -1;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tfree(suser);\n\t\tfree(host);\n\t\tfree(src);\n\t\tr = parse_scp_uri(argv[i], &suser, &host, &sport, &src);\n\t\tif (r == -1) {\n\t\t\tfmprintf(stderr, \"%s: invalid uri\\n\", argv[i]);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (r != 0)\n\t\t\tparse_user_host_path(argv[i], &suser, &host, &src);\n\t\tif (suser != NULL && !okname(suser)) {\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!host) {\t \n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"--\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (mode == MODE_SFTP) {\n\t\t\tconn = do_sftp_connect(host, suser, sport,\n\t\t\t    sftp_direct, &remin, &remout, &do_cmd_pid);\n\t\t\tif (conn == NULL) {\n\t\t\t\terror(\"sftp connection failed\");\n\t\t\t\t++errs;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tsink_sftp(1, argv[argc - 1], src, conn);\n\n\t\t\tfree(conn);\n\t\t\t(void) close(remin);\n\t\t\t(void) close(remout);\n\t\t\tremin = remout = -1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\txasprintf(&bp, \"%s -f %s%s\",\n\t\t    cmd, *src == '-' ? \"-- \" : \"\", src);\n\t\tif (do_cmd(ssh_program, host, suser, sport, 0, bp,\n\t\t    &remin, &remout, &do_cmd_pid) < 0) {\n\t\t\tfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tfree(bp);\n\t\tsink(1, argv + argc - 1, src);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n\tfree(suser);\n\tfree(host);\n\tfree(src);\n}\n\n \nstatic char *\nprepare_remote_path(struct sftp_conn *conn, const char *path)\n{\n\tsize_t nslash;\n\n\t \n\tif (*path == '\\0' || strcmp(path, \"~\") == 0)\n\t\treturn xstrdup(\".\");\n\tif (*path != '~')\n\t\treturn xstrdup(path);\n\tif (strncmp(path, \"~/\", 2) == 0) {\n\t\tif ((nslash = strspn(path + 2, \"/\")) == strlen(path + 2))\n\t\t\treturn xstrdup(\".\");\n\t\treturn xstrdup(path + 2 + nslash);\n\t}\n\tif (sftp_can_expand_path(conn))\n\t\treturn sftp_expand_path(conn, path);\n\t \n\terror(\"server expand-path extension is required \"\n\t    \"for ~user paths in SFTP mode\");\n\treturn NULL;\n}\n\nvoid\nsource_sftp(int argc, char *src, char *targ, struct sftp_conn *conn)\n{\n\tchar *target = NULL, *filename = NULL, *abs_dst = NULL;\n\tint src_is_dir, target_is_dir;\n\tAttrib a;\n\tstruct stat st;\n\n\tmemset(&a, '\\0', sizeof(a));\n\tif (stat(src, &st) != 0)\n\t\tfatal(\"stat local \\\"%s\\\": %s\", src, strerror(errno));\n\tsrc_is_dir = S_ISDIR(st.st_mode);\n\tif ((filename = basename(src)) == NULL)\n\t\tfatal(\"basename \\\"%s\\\": %s\", src, strerror(errno));\n\n\t \n\tif ((target = prepare_remote_path(conn, targ)) == NULL)\n\t\tcleanup_exit(255);\n\ttarget_is_dir = sftp_remote_is_dir(conn, target);\n\tif (targetshouldbedirectory && !target_is_dir) {\n\t\tdebug(\"target directory \\\"%s\\\" does not exist\", target);\n\t\ta.flags = SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = st.st_mode | 0700;  \n\t\tif (sftp_mkdir(conn, target, &a, 1) != 0)\n\t\t\tcleanup_exit(255);  \n\t\ttarget_is_dir = 1;\n\t}\n\tif (target_is_dir)\n\t\tabs_dst = sftp_path_append(target, filename);\n\telse {\n\t\tabs_dst = target;\n\t\ttarget = NULL;\n\t}\n\tdebug3_f(\"copying local %s to remote %s\", src, abs_dst);\n\n\tif (src_is_dir && iamrecursive) {\n\t\tif (sftp_upload_dir(conn, src, abs_dst, pflag,\n\t\t    SFTP_PROGRESS_ONLY, 0, 0, 1, 1) != 0) {\n\t\t\terror(\"failed to upload directory %s to %s\", src, targ);\n\t\t\terrs = 1;\n\t\t}\n\t} else if (sftp_upload(conn, src, abs_dst, pflag, 0, 0, 1) != 0) {\n\t\terror(\"failed to upload file %s to %s\", src, targ);\n\t\terrs = 1;\n\t}\n\n\tfree(abs_dst);\n\tfree(target);\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, statbytes;\n\tsize_t amt, nr;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[PATH_MAX + 128], encname[PATH_MAX];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif ((fd = open(name, O_RDONLY|O_NONBLOCK)) == -1)\n\t\t\tgoto syserr;\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\tstrnvis(encname, name, sizeof(encname), VIS_NL);\n\t\t\tname = encname;\n\t\t}\n\t\tif (fstat(fd, &stb) == -1) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tif (stb.st_size < 0) {\n\t\t\trun_err(\"%s: %s\", name, \"Negative file size\");\n\t\t\tgoto next;\n\t\t}\n\t\tunset_nonblock(fd);\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t \n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\tif (do_times(remout, verbose_mode, &stb) < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n\t\tset_nonblock(remout);\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + (off_t)amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tif ((nr = atomicio(read, fd,\n\t\t\t\t    bp->buf, amt)) != amt) {\n\t\t\t\t\thaderr = errno;\n\t\t\t\t\tmemset(bp->buf + nr, 0, amt - nr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (haderr) {\n\t\t\t\t(void)atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tmemset(bp->buf, 0, amt);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (atomicio6(vwrite, remout, bp->buf, amt, scpio,\n\t\t\t    &statbytes) != amt)\n\t\t\t\thaderr = errno;\n\t\t}\n\t\tunset_nonblock(remout);\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) == -1 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[PATH_MAX];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == NULL)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\tif (do_times(remout, verbose_mode, statp) < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfmprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\nvoid\nsink_sftp(int argc, char *dst, const char *src, struct sftp_conn *conn)\n{\n\tchar *abs_src = NULL;\n\tchar *abs_dst = NULL;\n\tglob_t g;\n\tchar *filename, *tmp = NULL;\n\tint i, r, err = 0, dst_is_dir;\n\tstruct stat st;\n\n\tmemset(&g, 0, sizeof(g));\n\n\t \n\tif ((abs_src = prepare_remote_path(conn, src)) == NULL) {\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tdebug3_f(\"copying remote %s to local %s\", abs_src, dst);\n\tif ((r = sftp_glob(conn, abs_src, GLOB_NOCHECK|GLOB_MARK,\n\t    NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE)\n\t\t\terror(\"%s: too many glob matches\", src);\n\t\telse\n\t\t\terror(\"%s: %s\", src, strerror(ENOENT));\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (g.gl_matchc == 0 && g.gl_pathc == 1 && g.gl_pathv[0] != 0) {\n\t\t \n\t\tif (sftp_stat(conn, g.gl_pathv[0], 1, NULL) != 0) {\n\t\t\terror(\"%s: %s\", src, strerror(ENOENT));\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((r = stat(dst, &st)) != 0)\n\t\tdebug2_f(\"stat local \\\"%s\\\": %s\", dst, strerror(errno));\n\tdst_is_dir = r == 0 && S_ISDIR(st.st_mode);\n\n\tif (g.gl_matchc > 1 && !dst_is_dir) {\n\t\tif (r == 0) {\n\t\t\terror(\"Multiple files match pattern, but destination \"\n\t\t\t    \"\\\"%s\\\" is not a directory\", dst);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2_f(\"creating destination \\\"%s\\\"\", dst);\n\t\tif (mkdir(dst, 0777) != 0) {\n\t\t\terror(\"local mkdir \\\"%s\\\": %s\", dst, strerror(errno));\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdst_is_dir = 1;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (dst_is_dir)\n\t\t\tabs_dst = sftp_path_append(dst, filename);\n\t\telse\n\t\t\tabs_dst = xstrdup(dst);\n\n\t\tdebug(\"Fetching %s to %s\\n\", g.gl_pathv[i], abs_dst);\n\t\tif (sftp_globpath_is_dir(g.gl_pathv[i]) && iamrecursive) {\n\t\t\tif (sftp_download_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    NULL, pflag, SFTP_PROGRESS_ONLY, 0, 0, 1, 1) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (sftp_download(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag, 0, 0, 1) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tfree(tmp);\n\tglobfree(&g);\n\tif (err == -1)\n\t\terrs = 1;\n}\n\n\n#define TYPE_OVERFLOW(type, val) \\\n\t((sizeof(type) == 4 && (val) > INT32_MAX) || \\\n\t (sizeof(type) == 8 && (val) > INT64_MAX) || \\\n\t (sizeof(type) != 4 && sizeof(type) != 8))\n\nvoid\nsink(int argc, char **argv, const char *src)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, ofd;\n\tmode_t mode, omode, mask;\n\toff_t size, statbytes;\n\tunsigned long long ull;\n\tint setimes, targisdir, wrerr;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048], visbuf[2048];\n\tchar **patterns = NULL;\n\tsize_t n, npatterns = 0;\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\t{ why = str; goto screwup; }\n\n\tif (TYPE_OVERFLOW(time_t, 0) || TYPE_OVERFLOW(off_t, 0))\n\t\tSCREWUP(\"Unexpected off_t/time_t size\");\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tif (src != NULL && !iamrecursive && !Tflag) {\n\t\t \n\t\tif (brace_expand(src, &patterns, &npatterns) != 0)\n\t\t\tfatal_f(\"could not expand pattern\");\n\t}\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\tgoto done;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfmprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0) {\n\t\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t\t    NULL, \"%s\", buf + 1);\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    visbuf, strlen(visbuf));\n\t\t\t}\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tgoto done;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"mtime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t \n\t\t\tmtime.tv_sec = ull;\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ' || mtime.tv_usec < 0 ||\n\t\t\t    mtime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tif (!isdigit((unsigned char)*cp))\n\t\t\t\tSCREWUP(\"atime.sec not present\");\n\t\t\tull = strtoull(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tif (TYPE_OVERFLOW(time_t, ull))\n\t\t\t\tsetimes = 0;\t \n\t\t\tatime.tv_sec = ull;\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0' || atime.tv_usec < 0 ||\n\t\t\t    atime.tv_usec > 999999)\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t \n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (!pflag)\n\t\t\tmode &= ~mask;\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tif (!isdigit((unsigned char)*cp))\n\t\t\tSCREWUP(\"size not present\");\n\t\tull = strtoull(cp, &cp, 10);\n\t\tif (!cp || *cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif (TYPE_OVERFLOW(off_t, ull))\n\t\t\tSCREWUP(\"size out of range\");\n\t\tsize = (off_t)ull;\n\n\t\tif (*cp == '\\0' || strchr(cp, '/') != NULL ||\n\t\t    strcmp(cp, \".\") == 0 || strcmp(cp, \"..\") == 0) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (npatterns > 0) {\n\t\t\tfor (n = 0; n < npatterns; n++) {\n\t\t\t\tif (strcmp(patterns[n], cp) == 0 ||\n\t\t\t\t    fnmatch(patterns[n], cp, 0) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= npatterns) {\n\t\t\t\tdebug2_f(\"incoming filename \\\"%s\\\" does not \"\n\t\t\t\t    \"match any of %zu expected patterns\", cp,\n\t\t\t\t    npatterns);\n\t\t\t\tfor (n = 0; n < npatterns; n++) {\n\t\t\t\t\tdebug3_f(\"expected pattern %zu: \\\"%s\\\"\",\n\t\t\t\t\t    n, patterns[n]);\n\t\t\t\t}\n\t\t\t\tSCREWUP(\"filename does not match request\");\n\t\t\t}\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf;\n\t\t\tstatic size_t cursize;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) == -1)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect, src);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\t(void) utimes(vect[0], tv);\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) == -1) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = 0;\n\n\t\t \n\t\tstatbytes = 0;\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n\t\tset_nonblock(remin);\n\t\tfor (count = i = 0; i < size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio6(read, remin, cp, amt,\n\t\t\t\t    scpio, &statbytes);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j != EPIPE ?\n\t\t\t\t\t    strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t \n\t\t\t\tif (!wrerr) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\tnote_err(\"%s: %s\", np,\n\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t\twrerr = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n\t\tunset_nonblock(remin);\n\t\tif (count != 0 && !wrerr &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\tnote_err(\"%s: %s\", np, strerror(errno));\n\t\t\twrerr = 1;\n\t\t}\n\t\tif (!wrerr && (!exists || S_ISREG(stb.st_mode)) &&\n\t\t    ftruncate(ofd, size) != 0)\n\t\t\tnote_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else  \n\t\t\t\tif (chmod(np, omode)) {\n#endif  \n\t\t\t\t\tnote_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else  \n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif  \n\t\t\t\t\tnote_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1)\n\t\t\tnote_err(\"%s: close: %s\", np, strerror(errno));\n\t\t(void) response();\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n\t\tif (setimes && !wrerr) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) == -1) {\n\t\t\t\tnote_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (note_err(NULL) == 0)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t}\ndone:\n\tfor (n = 0; n < npatterns; n++)\n\t\tfree(patterns[n]);\n\tfree(patterns);\n\treturn;\nscrewup:\n\tfor (n = 0; n < npatterns; n++)\n\t\tfree(patterns[n]);\n\tfree(patterns);\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nvoid\nthroughlocal_sftp(struct sftp_conn *from, struct sftp_conn *to,\n    char *src, char *targ)\n{\n\tchar *target = NULL, *filename = NULL, *abs_dst = NULL;\n\tchar *abs_src = NULL, *tmp = NULL;\n\tglob_t g;\n\tint i, r, targetisdir, err = 0;\n\n\tif ((filename = basename(src)) == NULL)\n\t\tfatal(\"basename %s: %s\", src, strerror(errno));\n\n\tif ((abs_src = prepare_remote_path(from, src)) == NULL ||\n\t    (target = prepare_remote_path(to, targ)) == NULL)\n\t\tcleanup_exit(255);\n\tmemset(&g, 0, sizeof(g));\n\n\ttargetisdir = sftp_remote_is_dir(to, target);\n\tif (!targetisdir && targetshouldbedirectory) {\n\t\terror(\"%s: destination is not a directory\", targ);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tdebug3_f(\"copying remote %s to remote %s\", abs_src, target);\n\tif ((r = sftp_glob(from, abs_src, GLOB_NOCHECK|GLOB_MARK,\n\t    NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE)\n\t\t\terror(\"%s: too many glob matches\", src);\n\t\telse\n\t\t\terror(\"%s: %s\", src, strerror(ENOENT));\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (g.gl_matchc == 0 && g.gl_pathc == 1 && g.gl_pathv[0] != 0) {\n\t\t \n\t\tif (sftp_stat(from, g.gl_pathv[0], 1, NULL) != 0) {\n\t\t\terror(\"%s: %s\", src, strerror(ENOENT));\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (targetisdir)\n\t\t\tabs_dst = sftp_path_append(target, filename);\n\t\telse\n\t\t\tabs_dst = xstrdup(target);\n\n\t\tdebug(\"Fetching %s to %s\\n\", g.gl_pathv[i], abs_dst);\n\t\tif (sftp_globpath_is_dir(g.gl_pathv[i]) && iamrecursive) {\n\t\t\tif (sftp_crossload_dir(from, to, g.gl_pathv[i], abs_dst,\n\t\t\t    NULL, pflag, SFTP_PROGRESS_ONLY, 1) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (sftp_crossload(from, to, g.gl_pathv[i], abs_dst,\n\t\t\t    NULL, pflag) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t\tfree(tmp);\n\t\ttmp = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tfree(abs_dst);\n\tfree(target);\n\tfree(tmp);\n\tglobfree(&g);\n\tif (err == -1)\n\t\terrs = 1;\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048], visbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t \n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t \n\tcase 1:\t\t \n\tcase 2:\t\t \n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote) {\n\t\t\tcp[-1] = '\\0';\n\t\t\t(void) snmprintf(visbuf, sizeof(visbuf),\n\t\t\t    NULL, \"%s\\n\", rbuf);\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t    visbuf, strlen(visbuf));\n\t\t}\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t \n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-346ABCOpqRrsTv] [-c cipher] [-D sftp_server_path] [-F ssh_config]\\n\"\n\t    \"           [-i identity_file] [-J destination] [-l limit] [-o ssh_option]\\n\"\n\t    \"           [-P port] [-S program] [-X sftp_option] source ... target\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp;\n\tva_list ap;\n\n\t++errs;\n\tif (fp != NULL || (remout != -1 && (fp = fdopen(remout, \"w\")))) {\n\t\t(void) fprintf(fp, \"%c\", 0x01);\n\t\t(void) fprintf(fp, \"scp: \");\n\t\tva_start(ap, fmt);\n\t\t(void) vfprintf(fp, fmt, ap);\n\t\tva_end(ap);\n\t\t(void) fprintf(fp, \"\\n\");\n\t\t(void) fflush(fp);\n\t}\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfmprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\n \nint\nnote_err(const char *fmt, ...)\n{\n\tstatic char *emsg;\n\tva_list ap;\n\n\t \n\tif (fmt == NULL) {\n\t\tif (emsg == NULL)\n\t\t\treturn 0;\n\t\trun_err(\"%s\", emsg);\n\t\tfree(emsg);\n\t\temsg = NULL;\n\t\treturn -1;\n\t}\n\n\terrs++;\n\t \n\tif (emsg != NULL)\n\t\treturn -1;\n\n\tva_start(ap, fmt);\n\tvasnmprintf(&emsg, INT_MAX, NULL, fmt, ap);\n\tva_end(ap);\n\treturn -1;\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit((unsigned char)c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfmprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) == -1) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = ROUNDUP(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else  \n\tsize = blksize;\n#endif  \n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tbp->buf = xrecallocarray(bp->buf, bp->cnt, size, 1);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\t(void)write(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tif (remin > 0)\n\t\tclose(remin);\n\tif (remout > 0)\n\t\tclose(remout);\n\tif (remin2 > 0)\n\t\tclose(remin2);\n\tif (remout2 > 0)\n\t\tclose(remout2);\n\tif (do_cmd_pid > 0)\n\t\t(void)waitpid(do_cmd_pid, NULL, 0);\n\tif (do_cmd_pid2 > 0)\n\t\t(void)waitpid(do_cmd_pid2, NULL, 0);\n\texit(i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}