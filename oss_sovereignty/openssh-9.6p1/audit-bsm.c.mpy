{
  "module_name": "audit-bsm.c",
  "hash_id": "63580c38c20b3bb2cffa850cb278e90424b730cfc227ed8e0a12cb8cf2d62853",
  "original_prompt": "Ingested from openssh-9.6p1/audit-bsm.c",
  "human_readable_source": " \n\n \n \n\n#include \"includes.h\"\n#if defined(USE_BSM_AUDIT)\n\n#include <sys/types.h>\n\n#include <errno.h>\n#include <netdb.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef BROKEN_BSM_API\n#include <libscf.h>\n#endif\n\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"xmalloc.h\"\n\n#ifndef AUE_openssh\n# define AUE_openssh     32800\n#endif\n#include <bsm/audit.h>\n#include <bsm/libbsm.h>\n#include <bsm/audit_uevents.h>\n#include <bsm/audit_record.h>\n#include <locale.h>\n\n#if defined(HAVE_GETAUDIT_ADDR)\n#define\tAuditInfoStruct\t\tauditinfo_addr\n#define AuditInfoTermID\t\tau_tid_addr_t\n#define SetAuditFunc(a,b)\tsetaudit_addr((a),(b))\n#define SetAuditFuncText\t\"setaudit_addr\"\n#define AUToSubjectFunc\t\tau_to_subject_ex\n#define AUToReturnFunc(a,b)\tau_to_return32((a), (int32_t)(b))\n#else\n#define\tAuditInfoStruct\t\tauditinfo\n#define AuditInfoTermID\t\tau_tid_t\n#define SetAuditFunc(a,b)\tsetaudit(a)\n#define SetAuditFuncText\t\"setaudit\"\n#define AUToSubjectFunc\t\tau_to_subject\n#define AUToReturnFunc(a,b)\tau_to_return((a), (u_int)(b))\n#endif\n\n#ifndef cannot_audit\nextern int\tcannot_audit(int);\n#endif\nextern void\taug_init(void);\nextern void\taug_save_auid(au_id_t);\nextern void\taug_save_uid(uid_t);\nextern void\taug_save_euid(uid_t);\nextern void\taug_save_gid(gid_t);\nextern void\taug_save_egid(gid_t);\nextern void\taug_save_pid(pid_t);\nextern void\taug_save_asid(au_asid_t);\nextern void\taug_save_tid(dev_t, unsigned int);\nextern void\taug_save_tid_ex(dev_t, u_int32_t *, u_int32_t);\nextern int\taug_save_me(void);\nextern int\taug_save_namask(void);\nextern void\taug_save_event(au_event_t);\nextern void\taug_save_sorf(int);\nextern void\taug_save_text(char *);\nextern void\taug_save_text1(char *);\nextern void\taug_save_text2(char *);\nextern void\taug_save_na(int);\nextern void\taug_save_user(char *);\nextern void\taug_save_path(char *);\nextern int\taug_save_policy(void);\nextern void\taug_save_afunc(int (*)(int));\nextern int\taug_audit(void);\nextern int\taug_na_selected(void);\nextern int\taug_selected(void);\nextern int\taug_daemon_session(void);\n\n#ifndef HAVE_GETTEXT\n# define gettext(a)\t(a)\n#endif\n\nextern Authctxt *the_authctxt;\nstatic AuditInfoTermID ssh_bsm_tid;\n\n#ifdef BROKEN_BSM_API\n \n#define BSM_TEXTBUFSZ 256\n#endif\n\n \n\n \n#if defined(HAVE_AUG_GET_MACHINE) || !defined(HAVE_GETAUDIT_ADDR)\nextern int aug_get_machine(char *, u_int32_t *, u_int32_t *);\n#else\nstatic int\naug_get_machine(char *host, u_int32_t *addr, u_int32_t *type)\n{\n\tstruct addrinfo *ai; \n\tstruct sockaddr_in *in4;\n\tstruct sockaddr_in6 *in6;\n\tint ret = 0, r;\n\n\tif ((r = getaddrinfo(host, NULL, NULL, &ai)) != 0) {\n\t\terror(\"BSM audit: getaddrinfo failed for %.100s: %.100s\", host,\n\t\t    r == EAI_SYSTEM ? strerror(errno) : gai_strerror(r));\n\t\treturn -1;\n\t}\n\t\n\tswitch (ai->ai_family) {\n\tcase AF_INET:\n\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t*type = AU_IPv4;\n\t\tmemcpy(addr, &in4->sin_addr, sizeof(struct in_addr));\n\t\tbreak;\n#ifdef AU_IPv6\n\tcase AF_INET6: \n\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t*type = AU_IPv6;\n\t\tmemcpy(addr, &in6->sin6_addr, sizeof(struct in6_addr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror(\"BSM audit: unknown address family for %.100s: %d\",\n\t\t    host, ai->ai_family);\n\t\tret = -1;\n\t}\n\tfreeaddrinfo(ai);\n\treturn ret;\n}\n#endif\n\n#ifdef BROKEN_BSM_API\n \nint\ngetacna(char *auditstring, int len)\n{\n\tscf_handle_t *handle = NULL;\n\tscf_property_t *property = NULL;\n\tscf_value_t *value = NULL;\n\tint ret = 0;\n\n\t \n\thandle = scf_handle_create(SCF_VERSION);\n\tif (handle == NULL) \n\t\treturn -2;\n\n\tret = scf_handle_bind(handle);\n\tif (ret == -1) \n\t\treturn -2;\n\n\tproperty = scf_property_create(handle);\n\tif (property == NULL) \n\t\treturn -2;\n\n\tret = scf_handle_decode_fmri(handle, \n\t    \"svc:/system/auditd:default/:properties/preselection/naflags\",\n\t    NULL, NULL, NULL, NULL, property, 0);\n\tif (ret == -1) \n\t\treturn -2;\n\n\tvalue = scf_value_create(handle);\n\tif (value == NULL) \n\t\treturn -2;\n\n\tret = scf_property_get_value(property, value);\n\tif (ret == -1) \n\t\treturn -2;\n\n\tret = scf_value_get_astring(value, auditstring, len);\n\tif (ret == -1) \n\t\treturn -2;\n\n\tscf_value_destroy(value);\n\tscf_property_destroy(property);\n\tscf_handle_destroy(handle);\n\n\treturn 0;\n}\n#endif\n\n \nstatic int\nselected(char *username, uid_t uid, au_event_t event, int sf)\n{\n\tint rc, sorf;\n\tchar naflags[512];\n\tstruct au_mask mask;\n\n\tmask.am_success = mask.am_failure = 0;\n\tif (uid < 0) {\n\t\t \n\t\trc = getacna(naflags, sizeof(naflags));\n\t\tif (rc == 0)\n\t\t\t(void) getauditflagsbin(naflags, &mask);\n\t} else\n\t\trc = au_user_mask(username, &mask);\n\n\tsorf = (sf == 0) ? AU_PRS_SUCCESS : AU_PRS_FAILURE;\n\treturn(au_preselect(event, &mask, sorf, AU_PRS_REREAD));\n}\n\nstatic void\nbsm_audit_record(int typ, char *string, au_event_t event_no)\n{\n\tint\t\tad, rc, sel;\n\tuid_t\t\tuid = -1;\n\tgid_t\t\tgid = -1;\n\tpid_t\t\tpid = getpid();\n\tAuditInfoTermID\ttid = ssh_bsm_tid;\n\n\tif (the_authctxt != NULL && the_authctxt->valid) {\n\t\tuid = the_authctxt->pw->pw_uid;\n\t\tgid = the_authctxt->pw->pw_gid;\n\t}\n\n\trc = (typ == 0) ? 0 : -1;\n\tsel = selected(the_authctxt->user, uid, event_no, rc);\n\tdebug3(\"BSM audit: typ %d rc %d \\\"%s\\\"\", typ, rc, string);\n\tif (!sel)\n\t\treturn;\t \n\n\tdebug3(\"BSM audit: writing audit new record\");\n\tad = au_open();\n\n\t(void) au_write(ad, AUToSubjectFunc(uid, uid, gid, uid, gid,\n\t    pid, pid, &tid));\n\t(void) au_write(ad, au_to_text(string));\n\t(void) au_write(ad, AUToReturnFunc(typ, rc));\n\n#ifdef BROKEN_BSM_API\n\t \n\trc = au_close(ad, AU_TO_WRITE, event_no, 0);\n#else\n\trc = au_close(ad, AU_TO_WRITE, event_no);\n#endif\n\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s failed to write \\\"%s\\\" record: %s\",\n\t\t    __func__, string, strerror(errno));\n}\n\nstatic void\nbsm_audit_session_setup(void)\n{\n\tint rc;\n\tstruct AuditInfoStruct info;\n\tau_mask_t mask;\n\n\tif (the_authctxt == NULL) {\n\t\terror(\"BSM audit: session setup internal error (NULL ctxt)\");\n\t\treturn;\n\t}\n\n\tif (the_authctxt->valid)\n\t\tinfo.ai_auid = the_authctxt->pw->pw_uid;\n\telse\n\t\tinfo.ai_auid = -1;\n\tinfo.ai_asid = getpid();\n\tmask.am_success = 0;\n\tmask.am_failure = 0;\n\n\t(void) au_user_mask(the_authctxt->user, &mask);\n\n\tinfo.ai_mask.am_success  = mask.am_success;\n\tinfo.ai_mask.am_failure  = mask.am_failure;\n\n\tinfo.ai_termid = ssh_bsm_tid;\n\n\trc = SetAuditFunc(&info, sizeof(info));\n\tif (rc < 0)\n\t\terror(\"BSM audit: %s: %s failed: %s\", __func__,\n\t\t    SetAuditFuncText, strerror(errno));\n}\n\nstatic void\nbsm_audit_bad_login(const char *what)\n{\n\tchar textbuf[BSM_TEXTBUFSZ];\n\n\tif (the_authctxt->valid) {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid %s for user %s\"),\n\t\t\t    what, the_authctxt->user);\n\t\tbsm_audit_record(4, textbuf, AUE_openssh);\n\t} else {\n\t\t(void) snprintf(textbuf, sizeof (textbuf),\n\t\t\tgettext(\"invalid user name \\\"%s\\\"\"),\n\t\t\t    the_authctxt->user);\n\t\tbsm_audit_record(3, textbuf, AUE_openssh);\n\t}\n}\n\n \n\nvoid\naudit_connection_from(const char *host, int port)\n{\n\tAuditInfoTermID *tid = &ssh_bsm_tid;\n\tchar buf[1024];\n\n\tif (cannot_audit(0))\n\t\treturn;\n\tdebug3(\"BSM audit: connection from %.100s port %d\", host, port);\n\n\t \n#if defined(HAVE_GETAUDIT_ADDR)\n\ttid->at_port = (dev_t)port;\n\taug_get_machine((char *)host, &(tid->at_addr[0]), &(tid->at_type));\n\tsnprintf(buf, sizeof(buf), \"%08x %08x %08x %08x\", tid->at_addr[0],\n\t    tid->at_addr[1], tid->at_addr[2], tid->at_addr[3]);\n\tdebug3(\"BSM audit: iptype %d machine ID %s\", (int)tid->at_type, buf);\n#else\n\t \n\ttid->port = (dev_t)port;\n\ttid->machine = inet_addr(host);\n\tsnprintf(buf, sizeof(buf), \"%08x\", tid->machine);\n\tdebug3(\"BSM audit: machine ID %s\", buf);\n#endif\n}\n\nvoid\naudit_run_command(const char *command)\n{\n\t \n}\n\nvoid\naudit_session_open(struct logininfo *li)\n{\n\t \n}\n\nvoid\naudit_session_close(struct logininfo *li)\n{\n\t \n}\n\nvoid\naudit_event(struct ssh *ssh, ssh_audit_event_t event)\n{\n\tchar    textbuf[BSM_TEXTBUFSZ];\n\tstatic int logged_in = 0;\n\tconst char *user = the_authctxt ? the_authctxt->user : \"(unknown user)\";\n\n\tif (cannot_audit(0))\n\t\treturn;\n\n\tswitch(event) {\n\tcase SSH_AUTH_SUCCESS:\n\t\tlogged_in = 1;\n\t\tbsm_audit_session_setup();\n\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t    gettext(\"successful login %s\"), user);\n\t\tbsm_audit_record(0, textbuf, AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_CONNECTION_CLOSE:\n\t\t \n\t\tif (logged_in) {\n\t\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t\t    gettext(\"sshd logout %s\"), the_authctxt->user);\n\t\t\tbsm_audit_record(0, textbuf, AUE_logout);\n\t\t} else {\n\t\t\tdebug(\"%s: connection closed without authentication\",\n\t\t\t    __func__);\n\t\t}\n\t\tbreak;\n\n\tcase SSH_NOLOGIN:\n\t\tbsm_audit_record(1,\n\t\t    gettext(\"logins disabled by /etc/nologin\"), AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_LOGIN_EXCEED_MAXTRIES:\n\t\tsnprintf(textbuf, sizeof(textbuf),\n\t\t    gettext(\"too many tries for user %s\"), the_authctxt->user);\n\t\tbsm_audit_record(1, textbuf, AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_LOGIN_ROOT_DENIED:\n\t\tbsm_audit_record(2, gettext(\"not_console\"), AUE_openssh);\n\t\tbreak;\n\n\tcase SSH_AUTH_FAIL_PASSWD:\n\t\tbsm_audit_bad_login(\"password\");\n\t\tbreak;\n\n\tcase SSH_AUTH_FAIL_KBDINT:\n\t\tbsm_audit_bad_login(\"interactive password entry\");\n\t\tbreak;\n\n\tdefault:\n\t\tdebug(\"%s: unhandled event %d\", __func__, event);\n\t}\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}