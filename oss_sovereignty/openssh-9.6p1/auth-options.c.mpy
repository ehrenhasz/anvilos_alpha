{
  "module_name": "auth-options.c",
  "hash_id": "7a7cd556a8df07ddf0e61e08e64bc68b64b80ca34eecdd3704aae2a9255684ae",
  "original_prompt": "Ingested from openssh-9.6p1/auth-options.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdarg.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n\n#include \"xmalloc.h\"\n#include \"ssherr.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"ssh2.h\"\n#include \"auth-options.h\"\n\nstatic int\ndup_strings(char ***dstp, size_t *ndstp, char **src, size_t nsrc)\n{\n\tchar **dst;\n\tsize_t i, j;\n\n\t*dstp = NULL;\n\t*ndstp = 0;\n\n\tif (nsrc == 0)\n\t\treturn 0;\n\tif (nsrc >= SIZE_MAX / sizeof(*src) ||\n\t    (dst = calloc(nsrc, sizeof(*src))) == NULL)\n\t\treturn -1;\n\tfor (i = 0; i < nsrc; i++) {\n\t\tif ((dst[i] = strdup(src[i])) == NULL) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(dst[j]);\n\t\t\tfree(dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\t*dstp = dst;\n\t*ndstp = nsrc;\n\treturn 0;\n}\n\n#define OPTIONS_CRITICAL\t1\n#define OPTIONS_EXTENSIONS\t2\nstatic int\ncert_option_list(struct sshauthopt *opts, struct sshbuf *oblob,\n    u_int which, int crit)\n{\n\tchar *command, *allowed;\n\tchar *name = NULL;\n\tstruct sshbuf *c = NULL, *data = NULL;\n\tint r, ret = -1, found;\n\n\tif ((c = sshbuf_fromb(oblob)) == NULL) {\n\t\terror_f(\"sshbuf_fromb failed\");\n\t\tgoto out;\n\t}\n\n\twhile (sshbuf_len(c) > 0) {\n\t\tsshbuf_free(data);\n\t\tdata = NULL;\n\t\tif ((r = sshbuf_get_cstring(c, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(c, &data)) != 0) {\n\t\t\terror_r(r, \"Unable to parse certificate options\");\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"found certificate option \\\"%.100s\\\" len %zu\",\n\t\t    name, sshbuf_len(data));\n\t\tfound = 0;\n\t\tif ((which & OPTIONS_EXTENSIONS) != 0) {\n\t\t\tif (strcmp(name, \"no-touch-required\") == 0) {\n\t\t\t\topts->no_require_user_presence = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-X11-forwarding\") == 0) {\n\t\t\t\topts->permit_x11_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-agent-forwarding\") == 0) {\n\t\t\t\topts->permit_agent_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name,\n\t\t\t    \"permit-port-forwarding\") == 0) {\n\t\t\t\topts->permit_port_forwarding_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-pty\") == 0) {\n\t\t\t\topts->permit_pty_flag = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"permit-user-rc\") == 0) {\n\t\t\t\topts->permit_user_rc = 1;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\tif (!found && (which & OPTIONS_CRITICAL) != 0) {\n\t\t\tif (strcmp(name, \"verify-required\") == 0) {\n\t\t\t\topts->require_verify = 1;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"force-command\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &command,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror_r(r, \"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section\", name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->force_command != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"force-command options\");\n\t\t\t\t\tfree(command);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->force_command = command;\n\t\t\t\tfound = 1;\n\t\t\t} else if (strcmp(name, \"source-address\") == 0) {\n\t\t\t\tif ((r = sshbuf_get_cstring(data, &allowed,\n\t\t\t\t    NULL)) != 0) {\n\t\t\t\t\terror_r(r, \"Unable to parse \\\"%s\\\" \"\n\t\t\t\t\t    \"section\", name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (opts->required_from_host_cert != NULL) {\n\t\t\t\t\terror(\"Certificate has multiple \"\n\t\t\t\t\t    \"source-address options\");\n\t\t\t\t\tfree(allowed);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (addr_match_cidr_list(NULL, allowed) == -1) {\n\t\t\t\t\terror(\"Certificate source-address \"\n\t\t\t\t\t    \"contents invalid\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\topts->required_from_host_cert = allowed;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (crit) {\n\t\t\t\terror(\"Certificate critical option \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlogit(\"Certificate extension \\\"%s\\\" \"\n\t\t\t\t    \"is not supported\", name);\n\t\t\t}\n\t\t} else if (sshbuf_len(data) != 0) {\n\t\t\terror(\"Certificate option \\\"%s\\\" corrupt \"\n\t\t\t    \"(extra data)\", name);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\t \n\tret = 0;\n\n out:\n\tfree(name);\n\tsshbuf_free(data);\n\tsshbuf_free(c);\n\treturn ret;\n}\n\nstruct sshauthopt *\nsshauthopt_new(void)\n{\n\tstruct sshauthopt *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tret->force_tun_device = -1;\n\treturn ret;\n}\n\nvoid\nsshauthopt_free(struct sshauthopt *opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\n\tfree(opts->cert_principals);\n\tfree(opts->force_command);\n\tfree(opts->required_from_host_cert);\n\tfree(opts->required_from_host_keys);\n\n\tfor (i = 0; i < opts->nenv; i++)\n\t\tfree(opts->env[i]);\n\tfree(opts->env);\n\n\tfor (i = 0; i < opts->npermitopen; i++)\n\t\tfree(opts->permitopen[i]);\n\tfree(opts->permitopen);\n\n\tfor (i = 0; i < opts->npermitlisten; i++)\n\t\tfree(opts->permitlisten[i]);\n\tfree(opts->permitlisten);\n\n\tfreezero(opts, sizeof(*opts));\n}\n\nstruct sshauthopt *\nsshauthopt_new_with_keys_defaults(void)\n{\n\tstruct sshauthopt *ret = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t \n\tret->permit_port_forwarding_flag = 1;\n\tret->permit_agent_forwarding_flag = 1;\n\tret->permit_x11_forwarding_flag = 1;\n\tret->permit_pty_flag = 1;\n\tret->permit_user_rc = 1;\n\treturn ret;\n}\n\n \nstatic int\nhandle_permit(const char **optsp, int allow_bare_port,\n    char ***permitsp, size_t *npermitsp, const char **errstrp)\n{\n\tchar *opt, *tmp, *cp, *host, **permits = *permitsp;\n\tsize_t npermits = *npermitsp;\n\tconst char *errstr = \"unknown error\";\n\n\tif (npermits > SSH_AUTHOPT_PERMIT_MAX) {\n\t\t*errstrp = \"too many permission directives\";\n\t\treturn -1;\n\t}\n\tif ((opt = opt_dequote(optsp, &errstr)) == NULL) {\n\t\treturn -1;\n\t}\n\tif (allow_bare_port && strchr(opt, ':') == NULL) {\n\t\t \n\t\tif (asprintf(&tmp, \"*:%s\", opt) == -1) {\n\t\t\tfree(opt);\n\t\t\t*errstrp = \"memory allocation failed\";\n\t\t\treturn -1;\n\t\t}\n\t\tfree(opt);\n\t\topt = tmp;\n\t}\n\tif ((tmp = strdup(opt)) == NULL) {\n\t\tfree(opt);\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tcp = tmp;\n\t \n\thost = hpdelim2(&cp, NULL);\n\tif (host == NULL || strlen(host) >= NI_MAXHOST) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission hostname\";\n\t\treturn -1;\n\t}\n\t \n\tif (cp == NULL ||\n\t    (strcmp(cp, \"*\") != 0 && a2port(cp) <= 0)) {\n\t\tfree(tmp);\n\t\tfree(opt);\n\t\t*errstrp = \"invalid permission port\";\n\t\treturn -1;\n\t}\n\t \n\tfree(tmp);\n\t \n\tif ((permits = recallocarray(permits, npermits, npermits + 1,\n\t    sizeof(*permits))) == NULL) {\n\t\tfree(opt);\n\t\t \n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn -1;\n\t}\n\tpermits[npermits++] = opt;\n\t*permitsp = permits;\n\t*npermitsp = npermits;\n\treturn 0;\n}\n\nstruct sshauthopt *\nsshauthopt_parse(const char *opts, const char **errstrp)\n{\n\tchar **oarray, *opt, *cp, *tmp;\n\tint r;\n\tstruct sshauthopt *ret = NULL;\n\tconst char *errstr = \"unknown error\";\n\tuint64_t valid_before;\n\tsize_t i, l;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\tif ((ret = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tgoto alloc_fail;\n\n\tif (opts == NULL)\n\t\treturn ret;\n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t \n\t\tif ((r = opt_flag(\"restrict\", 0, &opts)) != -1) {\n\t\t\tret->restricted = 1;\n\t\t\tret->permit_port_forwarding_flag = 0;\n\t\t\tret->permit_agent_forwarding_flag = 0;\n\t\t\tret->permit_x11_forwarding_flag = 0;\n\t\t\tret->permit_pty_flag = 0;\n\t\t\tret->permit_user_rc = 0;\n\t\t} else if ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->cert_authority = r;\n\t\t} else if ((r = opt_flag(\"port-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_port_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"agent-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_agent_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"x11-forwarding\", 1, &opts)) != -1) {\n\t\t\tret->permit_x11_forwarding_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"touch-required\", 1, &opts)) != -1) {\n\t\t\tret->no_require_user_presence = r != 1;  \n\t\t} else if ((r = opt_flag(\"verify-required\", 1, &opts)) != -1) {\n\t\t\tret->require_verify = r == 1;\n\t\t} else if ((r = opt_flag(\"pty\", 1, &opts)) != -1) {\n\t\t\tret->permit_pty_flag = r == 1;\n\t\t} else if ((r = opt_flag(\"user-rc\", 1, &opts)) != -1) {\n\t\t\tret->permit_user_rc = r == 1;\n\t\t} else if (opt_match(&opts, \"command\")) {\n\t\t\tif (ret->force_command != NULL) {\n\t\t\t\terrstr = \"multiple \\\"command\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->force_command = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"principals\")) {\n\t\t\tif (ret->cert_principals != NULL) {\n\t\t\t\terrstr = \"multiple \\\"principals\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->cert_principals = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->cert_principals == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"from\")) {\n\t\t\tif (ret->required_from_host_keys != NULL) {\n\t\t\t\terrstr = \"multiple \\\"from\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->required_from_host_keys = opt_dequote(&opts,\n\t\t\t    &errstr);\n\t\t\tif (ret->required_from_host_keys == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"expiry-time\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &valid_before) != 0 ||\n\t\t\t    valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid expires time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t\tif (ret->valid_before == 0 ||\n\t\t\t    valid_before < ret->valid_before)\n\t\t\t\tret->valid_before = valid_before;\n\t\t} else if (opt_match(&opts, \"environment\")) {\n\t\t\tif (ret->nenv > SSH_AUTHOPT_ENV_MAX) {\n\t\t\t\terrstr = \"too many environment strings\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\t \n\t\t\tif ((tmp = strchr(opt, '=')) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((cp = strdup(opt)) == NULL) {\n\t\t\t\tfree(opt);\n\t\t\t\tgoto alloc_fail;\n\t\t\t}\n\t\t\tl = (size_t)(tmp - opt);\n\t\t\tcp[l] = '\\0';  \n\t\t\tif (!valid_env_name(cp)) {\n\t\t\t\tfree(cp);\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid environment string\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t \n\t\t\tfor (i = 0; i < ret->nenv; i++) {\n\t\t\t\tif (strncmp(ret->env[i], cp, l) == 0 &&\n\t\t\t\t    ret->env[i][l] == '=')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\t \n\t\t\tif (i >= ret->nenv) {\n\t\t\t\t \n\t\t\t\toarray = ret->env;\n\t\t\t\tif ((ret->env = recallocarray(ret->env,\n\t\t\t\t    ret->nenv, ret->nenv + 1,\n\t\t\t\t    sizeof(*ret->env))) == NULL) {\n\t\t\t\t\tfree(opt);\n\t\t\t\t\t \n\t\t\t\t\tret->env = oarray;\n\t\t\t\t\tgoto alloc_fail;\n\t\t\t\t}\n\t\t\t\tret->env[ret->nenv++] = opt;\n\t\t\t\topt = NULL;  \n\t\t\t}\n\t\t\tfree(opt);\n\t\t} else if (opt_match(&opts, \"permitopen\")) {\n\t\t\tif (handle_permit(&opts, 0, &ret->permitopen,\n\t\t\t    &ret->npermitopen, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"permitlisten\")) {\n\t\t\tif (handle_permit(&opts, 1, &ret->permitlisten,\n\t\t\t    &ret->npermitlisten, &errstr) != 0)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"tunnel\")) {\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tret->force_tun_device = a2tun(opt, NULL);\n\t\t\tfree(opt);\n\t\t\tif (ret->force_tun_device == SSH_TUNID_ERR) {\n\t\t\t\terrstr = \"invalid tun device\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t \n\t\t \n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\nalloc_fail:\n\terrstr = \"memory allocation failed\";\nfail:\n\tsshauthopt_free(ret);\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\treturn NULL;\n}\n\nstruct sshauthopt *\nsshauthopt_from_cert(struct sshkey *k)\n{\n\tstruct sshauthopt *ret;\n\n\tif (k == NULL || !sshkey_type_is_cert(k->type) || k->cert == NULL ||\n\t    k->cert->type != SSH2_CERT_TYPE_USER)\n\t\treturn NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n\t \n\tif (cert_option_list(ret, k->cert->critical,\n\t    OPTIONS_CRITICAL, 1) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\tif (cert_option_list(ret, k->cert->extensions,\n\t    OPTIONS_EXTENSIONS, 0) == -1) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\t \n\treturn ret;\n}\n\n \nstruct sshauthopt *\nsshauthopt_merge(const struct sshauthopt *primary,\n    const struct sshauthopt *additional, const char **errstrp)\n{\n\tstruct sshauthopt *ret;\n\tconst char *errstr = \"internal error\";\n\tconst char *tmp;\n\n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\tgoto alloc_fail;\n\n\t \n\n\t \n\t \n\ttmp = primary->required_from_host_cert;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_cert;\n\tif (tmp != NULL && (ret->required_from_host_cert = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\ttmp = primary->required_from_host_keys;\n\tif (tmp == NULL)\n\t\ttmp = additional->required_from_host_keys;\n\tif (tmp != NULL && (ret->required_from_host_keys = strdup(tmp)) == NULL)\n\t\tgoto alloc_fail;\n\n\t \n\tret->force_tun_device = primary->force_tun_device;\n\tif (ret->force_tun_device == -1)\n\t\tret->force_tun_device = additional->force_tun_device;\n\tif (primary->nenv > 0) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    primary->env, primary->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->nenv) {\n\t\tif (dup_strings(&ret->env, &ret->nenv,\n\t\t    additional->env, additional->nenv) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\tif (primary->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    primary->permitopen, primary->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitopen > 0) {\n\t\tif (dup_strings(&ret->permitopen, &ret->npermitopen,\n\t\t    additional->permitopen, additional->npermitopen) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n\tif (primary->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    primary->permitlisten, primary->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->npermitlisten > 0) {\n\t\tif (dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t\t    additional->permitlisten, additional->npermitlisten) != 0)\n\t\t\tgoto alloc_fail;\n\t}\n\n#define OPTFLAG_AND(x) ret->x = (primary->x == 1) && (additional->x == 1)\n#define OPTFLAG_OR(x) ret->x = (primary->x == 1) || (additional->x == 1)\n\t \n\tOPTFLAG_AND(permit_port_forwarding_flag);\n\tOPTFLAG_AND(permit_agent_forwarding_flag);\n\tOPTFLAG_AND(permit_x11_forwarding_flag);\n\tOPTFLAG_AND(permit_pty_flag);\n\tOPTFLAG_AND(permit_user_rc);\n\tOPTFLAG_AND(no_require_user_presence);\n\t \n\tOPTFLAG_OR(require_verify);\n#undef OPTFLAG_AND\n\n\t \n\tif (primary->valid_before != 0)\n\t\tret->valid_before = primary->valid_before;\n\tif (additional->valid_before != 0 &&\n\t    additional->valid_before < ret->valid_before)\n\t\tret->valid_before = additional->valid_before;\n\n\t \n\tif (primary->force_command != NULL &&\n\t    additional->force_command != NULL) {\n\t\tif (strcmp(primary->force_command,\n\t\t    additional->force_command) == 0) {\n\t\t\t \n\t\t\tret->force_command = strdup(primary->force_command);\n\t\t\tif (ret->force_command == NULL)\n\t\t\t\tgoto alloc_fail;\n\t\t} else {\n\t\t\terrstr = \"forced command options do not match\";\n\t\t\tgoto fail;\n\t\t}\n\t} else if (primary->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    primary->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t} else if (additional->force_command != NULL) {\n\t\tif ((ret->force_command = strdup(\n\t\t    additional->force_command)) == NULL)\n\t\t\tgoto alloc_fail;\n\t}\n\t \n\tif (errstrp != NULL)\n\t\t*errstrp = NULL;\n\treturn ret;\n\n alloc_fail:\n\terrstr = \"memory allocation failed\";\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshauthopt_free(ret);\n\treturn NULL;\n}\n\n \nstruct sshauthopt *\nsshauthopt_copy(const struct sshauthopt *orig)\n{\n\tstruct sshauthopt *ret;\n\n\tif ((ret = sshauthopt_new()) == NULL)\n\t\treturn NULL;\n\n#define OPTSCALAR(x) ret->x = orig->x\n\tOPTSCALAR(permit_port_forwarding_flag);\n\tOPTSCALAR(permit_agent_forwarding_flag);\n\tOPTSCALAR(permit_x11_forwarding_flag);\n\tOPTSCALAR(permit_pty_flag);\n\tOPTSCALAR(permit_user_rc);\n\tOPTSCALAR(restricted);\n\tOPTSCALAR(cert_authority);\n\tOPTSCALAR(force_tun_device);\n\tOPTSCALAR(valid_before);\n\tOPTSCALAR(no_require_user_presence);\n\tOPTSCALAR(require_verify);\n#undef OPTSCALAR\n#define OPTSTRING(x) \\\n\tdo { \\\n\t\tif (orig->x != NULL && (ret->x = strdup(orig->x)) == NULL) { \\\n\t\t\tsshauthopt_free(ret); \\\n\t\t\treturn NULL; \\\n\t\t} \\\n\t} while (0)\n\tOPTSTRING(cert_principals);\n\tOPTSTRING(force_command);\n\tOPTSTRING(required_from_host_cert);\n\tOPTSTRING(required_from_host_keys);\n#undef OPTSTRING\n\n\tif (dup_strings(&ret->env, &ret->nenv, orig->env, orig->nenv) != 0 ||\n\t    dup_strings(&ret->permitopen, &ret->npermitopen,\n\t    orig->permitopen, orig->npermitopen) != 0 ||\n\t    dup_strings(&ret->permitlisten, &ret->npermitlisten,\n\t    orig->permitlisten, orig->npermitlisten) != 0) {\n\t\tsshauthopt_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic int\nserialise_array(struct sshbuf *m, char **a, size_t n)\n{\n\tstruct sshbuf *b;\n\tsize_t i;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (n > INT_MAX)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, a[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(m, n)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, b)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\nstatic int\ndeserialise_array(struct sshbuf *m, char ***ap, size_t *np)\n{\n\tchar **a = NULL;\n\tsize_t i, n = 0;\n\tstruct sshbuf *b = NULL;\n\tu_int tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((r = sshbuf_get_u32(m, &tmp)) != 0 ||\n\t    (r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif (tmp > INT_MAX) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tn = tmp;\n\tif (n > 0 && (a = calloc(n, sizeof(*a))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &a[i], NULL)) != 0)\n\t\t\tgoto out;\n\t}\n\t \n\tr = 0;\n\t*ap = a;\n\ta = NULL;\n\t*np = n;\n\tn = 0;\n out:\n\tif (a != NULL) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tfree(a[i]);\n\t\tfree(a);\n\t}\n\tsshbuf_free(b);\n\treturn r;\n}\n\nstatic int\nserialise_nullable_string(struct sshbuf *m, const char *s)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u8(m, s == NULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, s)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int\ndeserialise_nullable_string(struct sshbuf *m, char **sp)\n{\n\tint r;\n\tu_char flag;\n\n\t*sp = NULL;\n\tif ((r = sshbuf_get_u8(m, &flag)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, flag ? NULL : sp, NULL)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nint\nsshauthopt_serialise(const struct sshauthopt *opts, struct sshbuf *m,\n    int untrusted)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif ((r = sshbuf_put_u8(m, opts->permit_port_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_agent_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_x11_forwarding_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_pty_flag)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->permit_user_rc)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->restricted)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->cert_authority)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->no_require_user_presence)) != 0 ||\n\t    (r = sshbuf_put_u8(m, opts->require_verify)) != 0)\n\t\treturn r;\n\n\t \n\tif ((r = sshbuf_put_u64(m, opts->valid_before)) != 0)\n\t\treturn r;\n\n\t \n\tif ((r = sshbuf_put_u8(m, opts->force_tun_device == -1)) != 0 ||\n\t    (r = sshbuf_put_u32(m, (opts->force_tun_device < 0) ?\n\t    0 : (u_int)opts->force_tun_device)) != 0)\n\t\treturn r;\n\n\t \n\tif ((r = serialise_nullable_string(m,\n\t    untrusted ? \"yes\" : opts->cert_principals)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? \"true\" : opts->force_command)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? NULL : opts->required_from_host_cert)) != 0 ||\n\t    (r = serialise_nullable_string(m,\n\t    untrusted ? NULL : opts->required_from_host_keys)) != 0)\n\t\treturn r;\n\n\t \n\tif ((r = serialise_array(m, opts->env,\n\t    untrusted ? 0 : opts->nenv)) != 0 ||\n\t    (r = serialise_array(m, opts->permitopen,\n\t    untrusted ? 0 : opts->npermitopen)) != 0 ||\n\t    (r = serialise_array(m, opts->permitlisten,\n\t    untrusted ? 0 : opts->npermitlisten)) != 0)\n\t\treturn r;\n\n\t \n\treturn 0;\n}\n\nint\nsshauthopt_deserialise(struct sshbuf *m, struct sshauthopt **optsp)\n{\n\tstruct sshauthopt *opts = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char f;\n\tu_int tmp;\n\n\tif ((opts = calloc(1, sizeof(*opts))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t \n#define OPT_FLAG(x) \\\n\tdo { \\\n\t\tif ((r = sshbuf_get_u8(m, &f)) != 0) \\\n\t\t\tgoto out; \\\n\t\topts->x = f; \\\n\t} while (0)\n\tOPT_FLAG(permit_port_forwarding_flag);\n\tOPT_FLAG(permit_agent_forwarding_flag);\n\tOPT_FLAG(permit_x11_forwarding_flag);\n\tOPT_FLAG(permit_pty_flag);\n\tOPT_FLAG(permit_user_rc);\n\tOPT_FLAG(restricted);\n\tOPT_FLAG(cert_authority);\n\tOPT_FLAG(no_require_user_presence);\n\tOPT_FLAG(require_verify);\n#undef OPT_FLAG\n\n\t \n\tif ((r = sshbuf_get_u64(m, &opts->valid_before)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshbuf_get_u8(m, &f)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &tmp)) != 0)\n\t\tgoto out;\n\topts->force_tun_device = f ? -1 : (int)tmp;\n\n\t \n\tif ((r = deserialise_nullable_string(m, &opts->cert_principals)) != 0 ||\n\t    (r = deserialise_nullable_string(m, &opts->force_command)) != 0 ||\n\t    (r = deserialise_nullable_string(m,\n\t    &opts->required_from_host_cert)) != 0 ||\n\t    (r = deserialise_nullable_string(m,\n\t    &opts->required_from_host_keys)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = deserialise_array(m, &opts->env, &opts->nenv)) != 0 ||\n\t    (r = deserialise_array(m,\n\t    &opts->permitopen, &opts->npermitopen)) != 0 ||\n\t    (r = deserialise_array(m,\n\t    &opts->permitlisten, &opts->npermitlisten)) != 0)\n\t\tgoto out;\n\n\t \n\tr = 0;\n\t*optsp = opts;\n\topts = NULL;\n out:\n\tsshauthopt_free(opts);\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}