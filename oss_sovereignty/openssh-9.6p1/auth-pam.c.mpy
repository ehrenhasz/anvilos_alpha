{
  "module_name": "auth-pam.c",
  "hash_id": "d84db29fd293e183faf260445b14f2f2d878a4c3dd04a5f3d6cb342d701c2985",
  "original_prompt": "Ingested from openssh-9.6p1/auth-pam.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef USE_PAM\n#if defined(HAVE_SECURITY_PAM_APPL_H)\n#include <security/pam_appl.h>\n#elif defined (HAVE_PAM_PAM_APPL_H)\n#include <pam/pam_appl.h>\n#endif\n\n#if !defined(SSHD_PAM_SERVICE)\nextern char *__progname;\n# define SSHD_PAM_SERVICE\t\t__progname\n#endif\n\n \n#ifdef PAM_SUN_CODEBASE\n# define sshpam_const\t\t \n#else\n# define sshpam_const\tconst\t \n#endif\n\n \n#ifdef PAM_SUN_CODEBASE\n# define PAM_MSG_MEMBER(msg, n, member) ((*(msg))[(n)].member)\n#else\n# define PAM_MSG_MEMBER(msg, n, member) ((msg)[(n)]->member)\n#endif\n\n#include \"xmalloc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-pam.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"msg.h\"\n#include \"packet.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"ssh2.h\"\n#include \"auth-options.h\"\n#include \"misc.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n\nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\nextern u_int utmp_len;\n\n \n#ifdef USE_POSIX_THREADS\n# error \"USE_POSIX_THREADS replaced by UNSUPPORTED_POSIX_THREADS_HACK\"\n#endif\n\n \n#ifdef UNSUPPORTED_POSIX_THREADS_HACK\n#include <pthread.h>\n \ntypedef pthread_t sp_pthread_t;\n#else\ntypedef pid_t sp_pthread_t;\n#define pthread_exit\tfake_pthread_exit\n#define pthread_create\tfake_pthread_create\n#define pthread_cancel\tfake_pthread_cancel\n#define pthread_join\tfake_pthread_join\n#endif\n\nstruct pam_ctxt {\n\tsp_pthread_t\t pam_thread;\n\tint\t\t pam_psock;\n\tint\t\t pam_csock;\n\tint\t\t pam_done;\n};\n\nstatic void sshpam_free_ctx(void *);\nstatic struct pam_ctxt *cleanup_ctxt;\n\n#ifndef UNSUPPORTED_POSIX_THREADS_HACK\n \n\nstatic int sshpam_thread_status = -1;\nstatic sshsig_t sshpam_oldsig;\n\nstatic void\nsshpam_sigchld_handler(int sig)\n{\n\tssh_signal(SIGCHLD, SIG_DFL);\n\tif (cleanup_ctxt == NULL)\n\t\treturn;\t \n\tif (waitpid(cleanup_ctxt->pam_thread, &sshpam_thread_status, WNOHANG)\n\t    <= 0) {\n\t\t \n\t\tkill(cleanup_ctxt->pam_thread, SIGTERM);\n\t\twhile (waitpid(cleanup_ctxt->pam_thread,\n\t\t    &sshpam_thread_status, 0) == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (WIFSIGNALED(sshpam_thread_status) &&\n\t    WTERMSIG(sshpam_thread_status) == SIGTERM)\n\t\treturn;\t \n\tif (!WIFEXITED(sshpam_thread_status))\n\t\tsigdie(\"PAM: authentication thread exited unexpectedly\");\n\tif (WEXITSTATUS(sshpam_thread_status) != 0)\n\t\tsigdie(\"PAM: authentication thread exited uncleanly\");\n}\n\n \nstatic void\npthread_exit(void *value)\n{\n\t_exit(0);\n}\n\n \nstatic int\npthread_create(sp_pthread_t *thread, const void *attr,\n    void *(*thread_start)(void *), void *arg)\n{\n\tpid_t pid;\n\tstruct pam_ctxt *ctx = arg;\n\n\tsshpam_thread_status = -1;\n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror(\"fork(): %s\", strerror(errno));\n\t\treturn errno;\n\tcase 0:\n\t\tclose(ctx->pam_psock);\n\t\tctx->pam_psock = -1;\n\t\tthread_start(arg);\n\t\t_exit(1);\n\tdefault:\n\t\t*thread = pid;\n\t\tclose(ctx->pam_csock);\n\t\tctx->pam_csock = -1;\n\t\tsshpam_oldsig = ssh_signal(SIGCHLD, sshpam_sigchld_handler);\n\t\treturn (0);\n\t}\n}\n\nstatic int\npthread_cancel(sp_pthread_t thread)\n{\n\tssh_signal(SIGCHLD, sshpam_oldsig);\n\treturn (kill(thread, SIGTERM));\n}\n\n \nstatic int\npthread_join(sp_pthread_t thread, void **value)\n{\n\tint status;\n\n\tif (sshpam_thread_status != -1)\n\t\treturn (sshpam_thread_status);\n\tssh_signal(SIGCHLD, sshpam_oldsig);\n\twhile (waitpid(thread, &status, 0) == -1) {\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t}\n\treturn (status);\n}\n#endif\n\n\nstatic pam_handle_t *sshpam_handle = NULL;\nstatic int sshpam_err = 0;\nstatic int sshpam_authenticated = 0;\nstatic int sshpam_session_open = 0;\nstatic int sshpam_cred_established = 0;\nstatic int sshpam_account_status = -1;\nstatic int sshpam_maxtries_reached = 0;\nstatic char **sshpam_env = NULL;\nstatic Authctxt *sshpam_authctxt = NULL;\nstatic const char *sshpam_password = NULL;\nstatic char *sshpam_rhost = NULL;\nstatic char *sshpam_laddr = NULL;\n\n \n#ifndef HAVE_PAM_GETENVLIST\nstatic char **\npam_getenvlist(pam_handle_t *pamh)\n{\n\t \n\t return NULL;\n}\n#endif\n\n#ifndef HAVE_PAM_PUTENV\nstatic int\npam_putenv(pam_handle_t *pamh, const char *name_value)\n{\n\treturn PAM_SUCCESS;\n}\n#endif  \n\n \n#ifdef SSHPAM_CHAUTHTOK_NEEDS_RUID\nstatic int\nsshpam_chauthtok_ruid(pam_handle_t *pamh, int flags)\n{\n\tint result;\n\n\tif (sshpam_authctxt == NULL)\n\t\tfatal(\"PAM: sshpam_authctxt not initialized\");\n\tif (setreuid(sshpam_authctxt->pw->pw_uid, -1) == -1)\n\t\tfatal(\"%s: setreuid failed: %s\", __func__, strerror(errno));\n\tresult = pam_chauthtok(pamh, flags);\n\tif (setreuid(0, -1) == -1)\n\t\tfatal(\"%s: setreuid failed: %s\", __func__, strerror(errno));\n\treturn result;\n}\n# define pam_chauthtok(a,b)\t(sshpam_chauthtok_ruid((a), (b)))\n#endif\n\nstatic void\nsshpam_password_change_required(int reqd)\n{\n\textern struct sshauthopt *auth_opts;\n\tstatic int saved_port, saved_agent, saved_x11;\n\n\tdebug3(\"%s %d\", __func__, reqd);\n\tif (sshpam_authctxt == NULL)\n\t\tfatal(\"%s: PAM authctxt not initialized\", __func__);\n\tsshpam_authctxt->force_pwchange = reqd;\n\tif (reqd) {\n\t\tsaved_port = auth_opts->permit_port_forwarding_flag;\n\t\tsaved_agent = auth_opts->permit_agent_forwarding_flag;\n\t\tsaved_x11 = auth_opts->permit_x11_forwarding_flag;\n\t\tauth_opts->permit_port_forwarding_flag = 0;\n\t\tauth_opts->permit_agent_forwarding_flag = 0;\n\t\tauth_opts->permit_x11_forwarding_flag = 0;\n\t} else {\n\t\tif (saved_port)\n\t\t\tauth_opts->permit_port_forwarding_flag = saved_port;\n\t\tif (saved_agent)\n\t\t\tauth_opts->permit_agent_forwarding_flag = saved_agent;\n\t\tif (saved_x11)\n\t\t\tauth_opts->permit_x11_forwarding_flag = saved_x11;\n\t}\n}\n\n \nstatic void\nimport_environments(struct sshbuf *b)\n{\n\tchar *env;\n\tu_int n, i, num_env;\n\tint r;\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\n#ifndef UNSUPPORTED_POSIX_THREADS_HACK\n\t \n\tif ((r = sshbuf_get_u32(b, &n)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (n > INT_MAX)\n\t\tfatal(\"%s: invalid PAM account status %u\", __func__, n);\n\tsshpam_account_status = (int)n;\n\tif ((r = sshbuf_get_u32(b, &n)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshpam_password_change_required(n != 0);\n\n\t \n\tif ((r = sshbuf_get_u32(b, &num_env)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (num_env > 1024) {\n\t\tfatal_f(\"received %u environment variables, expected <= 1024\",\n\t\t    num_env);\n\t}\n\tsshpam_env = xcalloc(num_env + 1, sizeof(*sshpam_env));\n\tdebug3(\"PAM: num env strings %u\", num_env);\n\tfor(i = 0; i < num_env; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &(sshpam_env[i]), NULL)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tsshpam_env[num_env] = NULL;\n\n\t \n\tif ((r = sshbuf_get_u32(b, &num_env)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (num_env > 1024) {\n\t\tfatal_f(\"received %u PAM env variables, expected <= 1024\",\n\t\t    num_env);\n\t}\n\tdebug(\"PAM: num PAM env strings %u\", num_env);\n\tfor (i = 0; i < num_env; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &env, NULL)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t \n\t\tif ((r = pam_putenv(sshpam_handle, env)) != PAM_SUCCESS) {\n\t\t\terror(\"PAM: pam_putenv: %s\",\n\t\t\t    pam_strerror(sshpam_handle, r));\n\t\t}\n\t\t \n\t}\n#endif\n}\n\n \nstatic int\nsshpam_thread_conv(int n, sshpam_const struct pam_message **msg,\n    struct pam_response **resp, void *data)\n{\n\tstruct sshbuf *buffer;\n\tstruct pam_ctxt *ctxt;\n\tstruct pam_response *reply;\n\tint r, i;\n\tu_char status;\n\n\tdebug3(\"PAM: %s entering, %d messages\", __func__, n);\n\t*resp = NULL;\n\n\tif (data == NULL) {\n\t\terror(\"PAM: conversation function passed a null context\");\n\t\treturn (PAM_CONV_ERR);\n\t}\n\tctxt = data;\n\tif (n <= 0 || n > PAM_MAX_NUM_MSG)\n\t\treturn (PAM_CONV_ERR);\n\n\tif ((reply = calloc(n, sizeof(*reply))) == NULL)\n\t\treturn PAM_CONV_ERR;\n\tif ((buffer = sshbuf_new()) == NULL) {\n\t\tfree(reply);\n\t\treturn PAM_CONV_ERR;\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\tswitch (PAM_MSG_MEMBER(msg, i, msg_style)) {\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\tif ((r = sshbuf_put_cstring(buffer,\n\t\t\t    PAM_MSG_MEMBER(msg, i, msg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (ssh_msg_send(ctxt->pam_csock,\n\t\t\t    PAM_MSG_MEMBER(msg, i, msg_style), buffer) == -1)\n\t\t\t\tgoto fail;\n\n\t\t\tif (ssh_msg_recv(ctxt->pam_csock, buffer) == -1)\n\t\t\t\tgoto fail;\n\t\t\tif ((r = sshbuf_get_u8(buffer, &status)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (status != PAM_AUTHTOK)\n\t\t\t\tgoto fail;\n\t\t\tif ((r = sshbuf_get_cstring(buffer,\n\t\t\t    &reply[i].resp, NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tbreak;\n\t\tcase PAM_ERROR_MSG:\n\t\tcase PAM_TEXT_INFO:\n\t\t\tif ((r = sshbuf_put_cstring(buffer,\n\t\t\t    PAM_MSG_MEMBER(msg, i, msg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tif (ssh_msg_send(ctxt->pam_csock,\n\t\t\t    PAM_MSG_MEMBER(msg, i, msg_style), buffer) == -1)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\tsshbuf_reset(buffer);\n\t}\n\tsshbuf_free(buffer);\n\t*resp = reply;\n\treturn (PAM_SUCCESS);\n\n fail:\n\tfor(i = 0; i < n; i++) {\n\t\tfree(reply[i].resp);\n\t}\n\tfree(reply);\n\tsshbuf_free(buffer);\n\treturn (PAM_CONV_ERR);\n}\n\n \nstatic void *\nsshpam_thread(void *ctxtp)\n{\n\tstruct pam_ctxt *ctxt = ctxtp;\n\tstruct sshbuf *buffer = NULL;\n\tstruct pam_conv sshpam_conv;\n\tint r, flags = (options.permit_empty_passwd == 0 ?\n\t    PAM_DISALLOW_NULL_AUTHTOK : 0);\n#ifndef UNSUPPORTED_POSIX_THREADS_HACK\n\textern char **environ;\n\tchar **env_from_pam;\n\tu_int i;\n\tconst char *pam_user;\n\tconst char **ptr_pam_user = &pam_user;\n\tchar *tz = getenv(\"TZ\");\n\n\tsshpam_err = pam_get_item(sshpam_handle, PAM_USER,\n\t    (sshpam_const void **)ptr_pam_user);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tgoto auth_fail;\n\n\tenviron[0] = NULL;\n\tif (tz != NULL)\n\t\tif (setenv(\"TZ\", tz, 1) == -1)\n\t\t\terror(\"PAM: could not set TZ environment: %s\",\n\t\t\t    strerror(errno));\n\n\tif (sshpam_authctxt != NULL) {\n\t\tsetproctitle(\"%s [pam]\",\n\t\t    sshpam_authctxt->valid ? pam_user : \"unknown\");\n\t}\n#endif\n\n\tsshpam_conv.conv = sshpam_thread_conv;\n\tsshpam_conv.appdata_ptr = ctxt;\n\n\tif (sshpam_authctxt == NULL)\n\t\tfatal(\"%s: PAM authctxt not initialized\", __func__);\n\n\tif ((buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&sshpam_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tgoto auth_fail;\n\tsshpam_err = pam_authenticate(sshpam_handle, flags);\n\tif (sshpam_err == PAM_MAXTRIES)\n\t\tsshpam_set_maxtries_reached(1);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tgoto auth_fail;\n\n\tif (!do_pam_account()) {\n\t\tsshpam_err = PAM_ACCT_EXPIRED;\n\t\tgoto auth_fail;\n\t}\n\tif (sshpam_authctxt->force_pwchange) {\n\t\tsshpam_err = pam_chauthtok(sshpam_handle,\n\t\t    PAM_CHANGE_EXPIRED_AUTHTOK);\n\t\tif (sshpam_err != PAM_SUCCESS)\n\t\t\tgoto auth_fail;\n\t\tsshpam_password_change_required(0);\n\t}\n\n\tif ((r = sshbuf_put_cstring(buffer, \"OK\")) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n#ifndef UNSUPPORTED_POSIX_THREADS_HACK\n\t \n\tif ((r = sshbuf_put_u32(buffer, sshpam_account_status)) != 0 ||\n\t    (r = sshbuf_put_u32(buffer, sshpam_authctxt->force_pwchange)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t \n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t \n\t\tif (i > INT_MAX)\n\t\t\tfatal(\"%s: too many environment strings\", __func__);\n\t}\n\tif ((r = sshbuf_put_u32(buffer, i)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\tif ((r = sshbuf_put_cstring(buffer, environ[i])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\t \n\tenv_from_pam = pam_getenvlist(sshpam_handle);\n\tfor (i = 0; env_from_pam != NULL && env_from_pam[i] != NULL; i++) {\n\t\t \n\t\tif (i > INT_MAX)\n\t\t\tfatal(\"%s: too many PAM environment strings\", __func__);\n\t}\n\tif ((r = sshbuf_put_u32(buffer, i)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfor (i = 0; env_from_pam != NULL && env_from_pam[i] != NULL; i++) {\n\t\tif ((r = sshbuf_put_cstring(buffer, env_from_pam[i])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n#endif  \n\n\t \n\tssh_msg_send(ctxt->pam_csock, sshpam_err, buffer);\n\tsshbuf_free(buffer);\n\tpthread_exit(NULL);\n\n auth_fail:\n\tif ((r = sshbuf_put_cstring(buffer,\n\t    pam_strerror(sshpam_handle, sshpam_err))) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t \n\tif (sshpam_err == PAM_ACCT_EXPIRED)\n\t\tssh_msg_send(ctxt->pam_csock, PAM_ACCT_EXPIRED, buffer);\n\telse if (sshpam_maxtries_reached)\n\t\tssh_msg_send(ctxt->pam_csock, PAM_MAXTRIES, buffer);\n\telse\n\t\tssh_msg_send(ctxt->pam_csock, PAM_AUTH_ERR, buffer);\n\tsshbuf_free(buffer);\n\tpthread_exit(NULL);\n\n\treturn (NULL);  \n}\n\nvoid\nsshpam_thread_cleanup(void)\n{\n\tstruct pam_ctxt *ctxt = cleanup_ctxt;\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\tif (ctxt != NULL && ctxt->pam_thread != 0) {\n\t\tpthread_cancel(ctxt->pam_thread);\n\t\tpthread_join(ctxt->pam_thread, NULL);\n\t\tclose(ctxt->pam_psock);\n\t\tclose(ctxt->pam_csock);\n\t\tmemset(ctxt, 0, sizeof(*ctxt));\n\t\tcleanup_ctxt = NULL;\n\t}\n}\n\nstatic int\nsshpam_null_conv(int n, sshpam_const struct pam_message **msg,\n    struct pam_response **resp, void *data)\n{\n\tdebug3(\"PAM: %s entering, %d messages\", __func__, n);\n\treturn (PAM_CONV_ERR);\n}\n\nstatic struct pam_conv null_conv = { sshpam_null_conv, NULL };\n\nstatic int\nsshpam_store_conv(int n, sshpam_const struct pam_message **msg,\n    struct pam_response **resp, void *data)\n{\n\tstruct pam_response *reply;\n\tint r, i;\n\n\tdebug3(\"PAM: %s called with %d messages\", __func__, n);\n\t*resp = NULL;\n\n\tif (n <= 0 || n > PAM_MAX_NUM_MSG)\n\t\treturn (PAM_CONV_ERR);\n\n\tif ((reply = calloc(n, sizeof(*reply))) == NULL)\n\t\treturn (PAM_CONV_ERR);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tswitch (PAM_MSG_MEMBER(msg, i, msg_style)) {\n\t\tcase PAM_ERROR_MSG:\n\t\tcase PAM_TEXT_INFO:\n\t\t\tif ((r = sshbuf_putf(loginmsg, \"%s\\n\",\n\t\t\t    PAM_MSG_MEMBER(msg, i, msg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\treply[i].resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*resp = reply;\n\treturn (PAM_SUCCESS);\n\n fail:\n\tfor(i = 0; i < n; i++) {\n\t\tfree(reply[i].resp);\n\t}\n\tfree(reply);\n\treturn (PAM_CONV_ERR);\n}\n\nstatic struct pam_conv store_conv = { sshpam_store_conv, NULL };\n\nvoid\nsshpam_cleanup(void)\n{\n\tif (sshpam_handle == NULL || (use_privsep && !mm_is_monitor()))\n\t\treturn;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_session_open) {\n\t\tdebug(\"PAM: closing session\");\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tif (sshpam_cred_established) {\n\t\tdebug(\"PAM: deleting credentials\");\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tsshpam_authenticated = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}\n\nstatic int\nsshpam_init(struct ssh *ssh, Authctxt *authctxt)\n{\n\tconst char *pam_user, *user = authctxt->user;\n\tconst char **ptr_pam_user = &pam_user;\n\tint r;\n\n#if defined(PAM_SUN_CODEBASE) && defined(PAM_MAX_RESP_SIZE)\n\t \n\tif (strlen(user) >= PAM_MAX_RESP_SIZE)\n\t\tfatal(\"Username too long from %s port %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#endif\n\tif (sshpam_handle == NULL) {\n\t\tif (ssh == NULL) {\n\t\t\tfatal(\"%s: called initially with no \"\n\t\t\t    \"packet context\", __func__);\n\t\t}\n\t} if (sshpam_handle != NULL) {\n\t\t \n\t\tsshpam_err = pam_get_item(sshpam_handle,\n\t\t    PAM_USER, (sshpam_const void **)ptr_pam_user);\n\t\tif (sshpam_err == PAM_SUCCESS && strcmp(user, pam_user) == 0)\n\t\t\treturn (0);\n\t\tpam_end(sshpam_handle, sshpam_err);\n\t\tsshpam_handle = NULL;\n\t}\n\tdebug(\"PAM: initializing for \\\"%s\\\"\", user);\n\tsshpam_err =\n\t    pam_start(SSHD_PAM_SERVICE, user, &store_conv, &sshpam_handle);\n\tsshpam_authctxt = authctxt;\n\n\tif (sshpam_err != PAM_SUCCESS) {\n\t\tpam_end(sshpam_handle, sshpam_err);\n\t\tsshpam_handle = NULL;\n\t\treturn (-1);\n\t}\n\n\tif (ssh != NULL && sshpam_rhost == NULL) {\n\t\t \n\t\tsshpam_rhost = xstrdup(auth_get_canonical_hostname(ssh,\n\t\t    options.use_dns));\n\t\tsshpam_laddr = get_local_ipaddr(\n\t\t    ssh_packet_get_connection_in(ssh));\n\t}\n\tif (sshpam_rhost != NULL) {\n\t\tdebug(\"PAM: setting PAM_RHOST to \\\"%s\\\"\", sshpam_rhost);\n\t\tsshpam_err = pam_set_item(sshpam_handle, PAM_RHOST,\n\t\t    sshpam_rhost);\n\t\tif (sshpam_err != PAM_SUCCESS) {\n\t\t\tpam_end(sshpam_handle, sshpam_err);\n\t\t\tsshpam_handle = NULL;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tif (ssh != NULL && sshpam_laddr != NULL) {\n\t\tchar *conninfo;\n\n\t\t \n\t\txasprintf(&conninfo, \"SSH_CONNECTION=%.50s %d %.50s %d\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    sshpam_laddr, ssh_local_port(ssh));\n\t\tif ((r = pam_putenv(sshpam_handle, conninfo)) != PAM_SUCCESS)\n\t\t\tlogit(\"pam_putenv: %s\", pam_strerror(sshpam_handle, r));\n\t\tfree(conninfo);\n\t}\n\n#ifdef PAM_TTY_KLUDGE\n\t \n\tdebug(\"PAM: setting PAM_TTY to \\\"ssh\\\"\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_TTY, \"ssh\");\n\tif (sshpam_err != PAM_SUCCESS) {\n\t\tpam_end(sshpam_handle, sshpam_err);\n\t\tsshpam_handle = NULL;\n\t\treturn (-1);\n\t}\n#endif\n\treturn (0);\n}\n\nstatic void\nexpose_authinfo(const char *caller)\n{\n\tchar *auth_info;\n\n\t \n\tif (sshpam_authctxt->session_info == NULL)\n\t\tauth_info = xstrdup(\"\");\n\telse if ((auth_info = sshbuf_dup_string(\n\t    sshpam_authctxt->session_info)) == NULL)\n\t\tfatal(\"%s: sshbuf_dup_string failed\", __func__);\n\n\tdebug2(\"%s: auth information in SSH_AUTH_INFO_0\", caller);\n\tdo_pam_putenv(\"SSH_AUTH_INFO_0\", auth_info);\n\tfree(auth_info);\n}\n\nstatic void *\nsshpam_init_ctx(Authctxt *authctxt)\n{\n\tstruct pam_ctxt *ctxt;\n\tint result, socks[2];\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\t \n\tif (!options.use_pam || sshpam_account_status == 0)\n\t\treturn NULL;\n\n\t \n\tif (sshpam_init(NULL, authctxt) == -1) {\n\t\terror(\"PAM: initialization failed\");\n\t\treturn (NULL);\n\t}\n\n\texpose_authinfo(__func__);\n\tctxt = xcalloc(1, sizeof *ctxt);\n\n\t \n\tif (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, socks) == -1) {\n\t\terror(\"PAM: failed create sockets: %s\", strerror(errno));\n\t\tfree(ctxt);\n\t\treturn (NULL);\n\t}\n\tctxt->pam_psock = socks[0];\n\tctxt->pam_csock = socks[1];\n\tresult = pthread_create(&ctxt->pam_thread, NULL, sshpam_thread, ctxt);\n\tif (result != 0) {\n\t\terror(\"PAM: failed to start authentication thread: %s\",\n\t\t    strerror(result));\n\t\tclose(socks[0]);\n\t\tclose(socks[1]);\n\t\tfree(ctxt);\n\t\treturn (NULL);\n\t}\n\tcleanup_ctxt = ctxt;\n\treturn (ctxt);\n}\n\nstatic int\nsshpam_query(void *ctx, char **name, char **info,\n    u_int *num, char ***prompts, u_int **echo_on)\n{\n\tstruct sshbuf *buffer;\n\tstruct pam_ctxt *ctxt = ctx;\n\tsize_t plen;\n\tu_char type;\n\tchar *msg;\n\tsize_t len, mlen, nmesg = 0;\n\tint r;\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\tif ((buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t*name = xstrdup(\"\");\n\t*info = xstrdup(\"\");\n\t*prompts = xmalloc(sizeof(char *));\n\t**prompts = NULL;\n\tplen = 0;\n\t*echo_on = xmalloc(sizeof(u_int));\n\twhile (ssh_msg_recv(ctxt->pam_psock, buffer) == 0) {\n\t\tif (++nmesg > PAM_MAX_NUM_MSG)\n\t\t\tfatal_f(\"too many query messages\");\n\t\tif ((r = sshbuf_get_u8(buffer, &type)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(buffer, &msg, &mlen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\t\t*num = 1;\n\t\t\tlen = plen + mlen + 1;\n\t\t\t**prompts = xreallocarray(**prompts, 1, len);\n\t\t\tstrlcpy(**prompts + plen, msg, len - plen);\n\t\t\tplen += mlen;\n\t\t\t**echo_on = (type == PAM_PROMPT_ECHO_ON);\n\t\t\tfree(msg);\n\t\t\tsshbuf_free(buffer);\n\t\t\treturn (0);\n\t\tcase PAM_ERROR_MSG:\n\t\tcase PAM_TEXT_INFO:\n\t\t\t \n\t\t\tlen = plen + mlen + 2;\n\t\t\t**prompts = xreallocarray(**prompts, 1, len);\n\t\t\tstrlcpy(**prompts + plen, msg, len - plen);\n\t\t\tplen += mlen;\n\t\t\tstrlcat(**prompts + plen, \"\\n\", len - plen);\n\t\t\tplen++;\n\t\t\tfree(msg);\n\t\t\tbreak;\n\t\tcase PAM_ACCT_EXPIRED:\n\t\tcase PAM_MAXTRIES:\n\t\t\tif (type == PAM_ACCT_EXPIRED)\n\t\t\t\tsshpam_account_status = 0;\n\t\t\tif (type == PAM_MAXTRIES)\n\t\t\t\tsshpam_set_maxtries_reached(1);\n\t\t\t \n\t\tcase PAM_AUTH_ERR:\n\t\t\tdebug3(\"PAM: %s\", pam_strerror(sshpam_handle, type));\n\t\t\tif (**prompts != NULL && strlen(**prompts) != 0) {\n\t\t\t\tfree(*info);\n\t\t\t\t*info = **prompts;\n\t\t\t\t**prompts = NULL;\n\t\t\t\t*num = 0;\n\t\t\t\t**echo_on = 0;\n\t\t\t\tctxt->pam_done = -1;\n\t\t\t\tfree(msg);\n\t\t\t\tsshbuf_free(buffer);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\tcase PAM_SUCCESS:\n\t\t\tif (**prompts != NULL) {\n\t\t\t\t \n\t\t\t\tdebug(\"PAM: %s\", **prompts);\n\t\t\t\tif ((r = sshbuf_put(loginmsg, **prompts,\n\t\t\t\t    strlen(**prompts))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tfree(**prompts);\n\t\t\t\t**prompts = NULL;\n\t\t\t}\n\t\t\tif (type == PAM_SUCCESS) {\n\t\t\t\tif (!sshpam_authctxt->valid ||\n\t\t\t\t    (sshpam_authctxt->pw->pw_uid == 0 &&\n\t\t\t\t    options.permit_root_login != PERMIT_YES))\n\t\t\t\t\tfatal(\"Internal error: PAM auth \"\n\t\t\t\t\t    \"succeeded when it should have \"\n\t\t\t\t\t    \"failed\");\n\t\t\t\timport_environments(buffer);\n\t\t\t\t*num = 0;\n\t\t\t\t**echo_on = 0;\n\t\t\t\tctxt->pam_done = 1;\n\t\t\t\tfree(msg);\n\t\t\t\tsshbuf_free(buffer);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\terror(\"PAM: %s for %s%.100s from %.100s\", msg,\n\t\t\t    sshpam_authctxt->valid ? \"\" : \"illegal user \",\n\t\t\t    sshpam_authctxt->user, sshpam_rhost);\n\t\t\t \n\t\tdefault:\n\t\t\t*num = 0;\n\t\t\t**echo_on = 0;\n\t\t\tfree(msg);\n\t\t\tctxt->pam_done = -1;\n\t\t\tsshbuf_free(buffer);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tsshbuf_free(buffer);\n\treturn (-1);\n}\n\n \nstatic char *\nfake_password(const char *wire_password)\n{\n\tconst char junk[] = \"\\b\\n\\r\\177INCORRECT\";\n\tchar *ret = NULL;\n\tsize_t i, l = wire_password != NULL ? strlen(wire_password) : 0;\n\n\tif (l >= INT_MAX)\n\t\tfatal(\"%s: password length too long: %zu\", __func__, l);\n\n\tret = malloc(l + 1);\n\tif (ret == NULL)\n\t\treturn NULL;\n\tfor (i = 0; i < l; i++)\n\t\tret[i] = junk[i % (sizeof(junk) - 1)];\n\tret[i] = '\\0';\n\treturn ret;\n}\n\n \nstatic int\nsshpam_respond(void *ctx, u_int num, char **resp)\n{\n\tstruct sshbuf *buffer;\n\tstruct pam_ctxt *ctxt = ctx;\n\tchar *fake;\n\tint r;\n\n\tdebug2(\"PAM: %s entering, %u responses\", __func__, num);\n\tswitch (ctxt->pam_done) {\n\tcase 1:\n\t\tsshpam_authenticated = 1;\n\t\treturn (0);\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn (-1);\n\t}\n\tif (num != 1) {\n\t\terror(\"PAM: expected one response, got %u\", num);\n\t\treturn (-1);\n\t}\n\tif ((buffer = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif (sshpam_authctxt->valid &&\n\t    (sshpam_authctxt->pw->pw_uid != 0 ||\n\t    options.permit_root_login == PERMIT_YES)) {\n\t\tif ((r = sshbuf_put_cstring(buffer, *resp)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else {\n\t\tfake = fake_password(*resp);\n\t\tif ((r = sshbuf_put_cstring(buffer, fake)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfree(fake);\n\t}\n\tif (ssh_msg_send(ctxt->pam_psock, PAM_AUTHTOK, buffer) == -1) {\n\t\tsshbuf_free(buffer);\n\t\treturn (-1);\n\t}\n\tsshbuf_free(buffer);\n\treturn (1);\n}\n\nstatic void\nsshpam_free_ctx(void *ctxtp)\n{\n\tstruct pam_ctxt *ctxt = ctxtp;\n\n\tdebug3(\"PAM: %s entering\", __func__);\n\tsshpam_thread_cleanup();\n\tfree(ctxt);\n\t \n}\n\nKbdintDevice sshpam_device = {\n\t\"pam\",\n\tsshpam_init_ctx,\n\tsshpam_query,\n\tsshpam_respond,\n\tsshpam_free_ctx\n};\n\nKbdintDevice mm_sshpam_device = {\n\t\"pam\",\n\tmm_sshpam_init_ctx,\n\tmm_sshpam_query,\n\tmm_sshpam_respond,\n\tmm_sshpam_free_ctx\n};\n\n \nvoid\nstart_pam(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\n\tif (!options.use_pam)\n\t\tfatal(\"PAM: initialisation requested when UsePAM=no\");\n\n\tif (sshpam_init(ssh, authctxt) == -1)\n\t\tfatal(\"PAM: initialisation failed\");\n}\n\nvoid\nfinish_pam(void)\n{\n\tsshpam_cleanup();\n}\n\n\nu_int\ndo_pam_account(void)\n{\n\tdebug(\"%s: called\", __func__);\n\tif (sshpam_account_status != -1)\n\t\treturn (sshpam_account_status);\n\n\texpose_authinfo(__func__);\n\n\tsshpam_err = pam_acct_mgmt(sshpam_handle, 0);\n\tdebug3(\"PAM: %s pam_acct_mgmt = %d (%s)\", __func__, sshpam_err,\n\t    pam_strerror(sshpam_handle, sshpam_err));\n\n\tif (sshpam_err != PAM_SUCCESS && sshpam_err != PAM_NEW_AUTHTOK_REQD) {\n\t\tsshpam_account_status = 0;\n\t\treturn (sshpam_account_status);\n\t}\n\n\tif (sshpam_err == PAM_NEW_AUTHTOK_REQD)\n\t\tsshpam_password_change_required(1);\n\n\tsshpam_account_status = 1;\n\treturn (sshpam_account_status);\n}\n\nvoid\ndo_pam_setcred(int init)\n{\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tif (init) {\n\t\tdebug(\"PAM: establishing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_ESTABLISH_CRED);\n\t} else {\n\t\tdebug(\"PAM: reinitializing credentials\");\n\t\tsshpam_err = pam_setcred(sshpam_handle, PAM_REINITIALIZE_CRED);\n\t}\n\tif (sshpam_err == PAM_SUCCESS) {\n\t\tsshpam_cred_established = 1;\n\t\treturn;\n\t}\n\tif (sshpam_authenticated)\n\t\tfatal(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\telse\n\t\tdebug(\"PAM: pam_setcred(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}\n\nstatic int\nsshpam_tty_conv(int n, sshpam_const struct pam_message **msg,\n    struct pam_response **resp, void *data)\n{\n\tchar input[PAM_MAX_MSG_SIZE];\n\tstruct pam_response *reply;\n\tint i;\n\n\tdebug3(\"PAM: %s called with %d messages\", __func__, n);\n\n\t*resp = NULL;\n\n\tif (n <= 0 || n > PAM_MAX_NUM_MSG || !isatty(STDIN_FILENO))\n\t\treturn (PAM_CONV_ERR);\n\n\tif ((reply = calloc(n, sizeof(*reply))) == NULL)\n\t\treturn (PAM_CONV_ERR);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tswitch (PAM_MSG_MEMBER(msg, i, msg_style)) {\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\t\treply[i].resp =\n\t\t\t    read_passphrase(PAM_MSG_MEMBER(msg, i, msg),\n\t\t\t    RP_ALLOW_STDIN);\n\t\t\treply[i].resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\tfprintf(stderr, \"%s\\n\", PAM_MSG_MEMBER(msg, i, msg));\n\t\t\tif (fgets(input, sizeof input, stdin) == NULL)\n\t\t\t\tinput[0] = '\\0';\n\t\t\tif ((reply[i].resp = strdup(input)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\treply[i].resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tcase PAM_ERROR_MSG:\n\t\tcase PAM_TEXT_INFO:\n\t\t\tfprintf(stderr, \"%s\\n\", PAM_MSG_MEMBER(msg, i, msg));\n\t\t\treply[i].resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*resp = reply;\n\treturn (PAM_SUCCESS);\n\n fail:\n\tfor(i = 0; i < n; i++) {\n\t\tfree(reply[i].resp);\n\t}\n\tfree(reply);\n\treturn (PAM_CONV_ERR);\n}\n\nstatic struct pam_conv tty_conv = { sshpam_tty_conv, NULL };\n\n \nvoid\ndo_pam_chauthtok(void)\n{\n\tif (use_privsep)\n\t\tfatal(\"Password expired (unable to change with privsep)\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&tty_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tdebug(\"PAM: changing password\");\n\tsshpam_err = pam_chauthtok(sshpam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: pam_chauthtok(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}\n\nvoid\ndo_pam_session(struct ssh *ssh)\n{\n\tdebug3(\"PAM: opening session\");\n\n\texpose_authinfo(__func__);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&store_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tsshpam_err = pam_open_session(sshpam_handle, 0);\n\tif (sshpam_err == PAM_SUCCESS)\n\t\tsshpam_session_open = 1;\n\telse {\n\t\tsshpam_session_open = 0;\n\t\tauth_restrict_session(ssh);\n\t\terror(\"PAM: pam_open_session(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\t}\n\n}\n\nint\nis_pam_session_open(void)\n{\n\treturn sshpam_session_open;\n}\n\n \nint\ndo_pam_putenv(char *name, char *value)\n{\n\tint ret = 1;\n\tchar *compound;\n\tsize_t len;\n\n\tlen = strlen(name) + strlen(value) + 2;\n\tcompound = xmalloc(len);\n\n\tsnprintf(compound, len, \"%s=%s\", name, value);\n\tret = pam_putenv(sshpam_handle, compound);\n\tfree(compound);\n\n\treturn (ret);\n}\n\nchar **\nfetch_pam_child_environment(void)\n{\n\treturn sshpam_env;\n}\n\nchar **\nfetch_pam_environment(void)\n{\n\treturn (pam_getenvlist(sshpam_handle));\n}\n\nvoid\nfree_pam_environment(char **env)\n{\n\tchar **envp;\n\n\tif (env == NULL)\n\t\treturn;\n\n\tfor (envp = env; *envp; envp++)\n\t\tfree(*envp);\n\tfree(env);\n}\n\n \nstatic int\nsshpam_passwd_conv(int n, sshpam_const struct pam_message **msg,\n    struct pam_response **resp, void *data)\n{\n\tstruct pam_response *reply;\n\tint r, i;\n\tsize_t len;\n\n\tdebug3(\"PAM: %s called with %d messages\", __func__, n);\n\n\t*resp = NULL;\n\n\tif (n <= 0 || n > PAM_MAX_NUM_MSG)\n\t\treturn (PAM_CONV_ERR);\n\n\tif ((reply = calloc(n, sizeof(*reply))) == NULL)\n\t\treturn (PAM_CONV_ERR);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tswitch (PAM_MSG_MEMBER(msg, i, msg_style)) {\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\t\tif (sshpam_password == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif ((reply[i].resp = strdup(sshpam_password)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\treply[i].resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tcase PAM_ERROR_MSG:\n\t\tcase PAM_TEXT_INFO:\n\t\t\tlen = strlen(PAM_MSG_MEMBER(msg, i, msg));\n\t\t\tif (len > 0) {\n\t\t\t\tif ((r = sshbuf_putf(loginmsg, \"%s\\n\",\n\t\t\t\t    PAM_MSG_MEMBER(msg, i, msg))) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tif ((reply[i].resp = strdup(\"\")) == NULL)\n\t\t\t\tgoto fail;\n\t\t\treply[i].resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*resp = reply;\n\treturn (PAM_SUCCESS);\n\n fail:\n\tfor(i = 0; i < n; i++) {\n\t\tfree(reply[i].resp);\n\t}\n\tfree(reply);\n\treturn (PAM_CONV_ERR);\n}\n\nstatic struct pam_conv passwd_conv = { sshpam_passwd_conv, NULL };\n\n \nint\nsshpam_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tint flags = (options.permit_empty_passwd == 0 ?\n\t    PAM_DISALLOW_NULL_AUTHTOK : 0);\n\tchar *fake = NULL;\n\n\tif (!options.use_pam || sshpam_handle == NULL)\n\t\tfatal(\"PAM: %s called when PAM disabled or failed to \"\n\t\t    \"initialise.\", __func__);\n\n\tsshpam_password = password;\n\tsshpam_authctxt = authctxt;\n\n\t \n\tif (!authctxt->valid || (authctxt->pw->pw_uid == 0 &&\n\t    options.permit_root_login != PERMIT_YES))\n\t\tsshpam_password = fake = fake_password(password);\n\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&passwd_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: %s: failed to set PAM_CONV: %s\", __func__,\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\n\tsshpam_err = pam_authenticate(sshpam_handle, flags);\n\tsshpam_password = NULL;\n\tfree(fake);\n\tif (sshpam_err == PAM_MAXTRIES)\n\t\tsshpam_set_maxtries_reached(1);\n\tif (sshpam_err == PAM_SUCCESS && authctxt->valid) {\n\t\tdebug(\"PAM: password authentication accepted for %.100s\",\n\t\t    authctxt->user);\n\t\treturn 1;\n\t} else {\n\t\tdebug(\"PAM: password authentication failed for %.100s: %s\",\n\t\t    authctxt->valid ? authctxt->user : \"an illegal user\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\t\treturn 0;\n\t}\n}\n\nint\nsshpam_get_maxtries_reached(void)\n{\n\treturn sshpam_maxtries_reached;\n}\n\nvoid\nsshpam_set_maxtries_reached(int reached)\n{\n\tif (reached == 0 || sshpam_maxtries_reached)\n\t\treturn;\n\tsshpam_maxtries_reached = 1;\n\toptions.password_authentication = 0;\n\toptions.kbd_interactive_authentication = 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}