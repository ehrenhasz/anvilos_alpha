{
  "module_name": "misc.c",
  "hash_id": "e4f36a54ef0a6637bfc618fb56f1aca1bea3f5b65232a8dc51c24a446ddc12a9",
  "original_prompt": "Ingested from openssh-9.6p1/misc.c",
  "human_readable_source": " \n \n\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n\n#include <limits.h>\n#ifdef HAVE_LIBGEN_H\n# include <libgen.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#ifdef HAVE_NLIST_H\n#include <nlist.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <netinet/in.h>\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#include <pwd.h>\n#include <grp.h>\n#endif\n#ifdef SSH_TUN_OPENBSD\n#include <net/if.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"platform.h\"\n\n \nchar *\nchop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n\n}\n\n \nvoid\nrtrim(char *s)\n{\n\tsize_t i;\n\n\tif ((i = strlen(s)) == 0)\n\t\treturn;\n\tfor (i--; i > 0; i--) {\n\t\tif (isspace((unsigned char)s[i]))\n\t\t\ts[i] = '\\0';\n\t}\n}\n\n \nint\nset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val == -1) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (val & O_NONBLOCK) {\n\t\tdebug3(\"fd %d is O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug2(\"fd %d setting O_NONBLOCK\", fd);\n\tval |= O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, O_NONBLOCK): %s\", fd,\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nint\nunset_nonblock(int fd)\n{\n\tint val;\n\n\tval = fcntl(fd, F_GETFL);\n\tif (val == -1) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\nconst char *\nssh_gai_strerror(int gaierr)\n{\n\tif (gaierr == EAI_SYSTEM && errno != 0)\n\t\treturn strerror(errno);\n\treturn gai_strerror(gaierr);\n}\n\n \nvoid\nset_nodelay(int fd)\n{\n\tint opt;\n\tsocklen_t optlen;\n\n\toptlen = sizeof opt;\n\tif (getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, &optlen) == -1) {\n\t\tdebug(\"getsockopt TCP_NODELAY: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\tif (opt == 1) {\n\t\tdebug2(\"fd %d is TCP_NODELAY\", fd);\n\t\treturn;\n\t}\n\topt = 1;\n\tdebug2(\"fd %d setting TCP_NODELAY\", fd);\n\tif (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof opt) == -1)\n\t\terror(\"setsockopt TCP_NODELAY: %.100s\", strerror(errno));\n}\n\n \nint\nset_reuseaddr(int fd)\n{\n\tint on = 1;\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n\t\terror(\"setsockopt SO_REUSEADDR fd %d: %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nchar *\nget_rdomain(int fd)\n{\n#if defined(HAVE_SYS_GET_RDOMAIN)\n\treturn sys_get_rdomain(fd);\n#elif defined(__OpenBSD__)\n\tint rtable;\n\tchar *ret;\n\tsocklen_t len = sizeof(rtable);\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_RTABLE, &rtable, &len) == -1) {\n\t\terror(\"Failed to get routing domain for fd %d: %s\",\n\t\t    fd, strerror(errno));\n\t\treturn NULL;\n\t}\n\txasprintf(&ret, \"%d\", rtable);\n\treturn ret;\n#else  \n\treturn NULL;\n#endif\n}\n\nint\nset_rdomain(int fd, const char *name)\n{\n#if defined(HAVE_SYS_SET_RDOMAIN)\n\treturn sys_set_rdomain(fd, name);\n#elif defined(__OpenBSD__)\n\tint rtable;\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn 0;  \n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL) {\n\t\t \n\t\terror(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\t\treturn -1;\n\t}\n\tif (setsockopt(fd, SOL_SOCKET, SO_RTABLE,\n\t    &rtable, sizeof(rtable)) == -1) {\n\t\terror(\"Failed to set routing domain %d on fd %d: %s\",\n\t\t    rtable, fd, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n#else  \n\terror(\"Setting routing domain is not supported on this platform\");\n\treturn -1;\n#endif\n}\n\nint\nget_sock_af(int fd)\n{\n\tstruct sockaddr_storage to;\n\tsocklen_t tolen = sizeof(to);\n\n\tmemset(&to, 0, sizeof(to));\n\tif (getsockname(fd, (struct sockaddr *)&to, &tolen) == -1)\n\t\treturn -1;\n#ifdef IPV4_IN_IPV6\n\tif (to.ss_family == AF_INET6 &&\n\t    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)&to)->sin6_addr))\n\t\treturn AF_INET;\n#endif\n\treturn to.ss_family;\n}\n\nvoid\nset_sock_tos(int fd, int tos)\n{\n#ifndef IP_TOS_IS_BROKEN\n\tint af;\n\n\tswitch ((af = get_sock_af(fd))) {\n\tcase -1:\n\t\t \n\t\tbreak;\n\tcase AF_INET:\n# ifdef IP_TOS\n\t\tdebug3_f(\"set socket %d IP_TOS 0x%02x\", fd, tos);\n\t\tif (setsockopt(fd, IPPROTO_IP, IP_TOS,\n\t\t    &tos, sizeof(tos)) == -1) {\n\t\t\terror(\"setsockopt socket %d IP_TOS %d: %s\",\n\t\t\t    fd, tos, strerror(errno));\n\t\t}\n# endif  \n\t\tbreak;\n\tcase AF_INET6:\n# ifdef IPV6_TCLASS\n\t\tdebug3_f(\"set socket %d IPV6_TCLASS 0x%02x\", fd, tos);\n\t\tif (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS,\n\t\t    &tos, sizeof(tos)) == -1) {\n\t\t\terror(\"setsockopt socket %d IPV6_TCLASS %d: %s\",\n\t\t\t    fd, tos, strerror(errno));\n\t\t}\n# endif  \n\t\tbreak;\n\tdefault:\n\t\tdebug2_f(\"unsupported socket family %d\", af);\n\t\tbreak;\n\t}\n#endif  \n}\n\n \nstatic int\nwaitfd(int fd, int *timeoutp, short events, volatile sig_atomic_t *stop)\n{\n\tstruct pollfd pfd;\n\tstruct timespec timeout;\n\tint oerrno, r;\n\tsigset_t nsigset, osigset;\n\n\tif (timeoutp && *timeoutp == -1)\n\t\ttimeoutp = NULL;\n\tpfd.fd = fd;\n\tpfd.events = events;\n\tptimeout_init(&timeout);\n\tif (timeoutp != NULL)\n\t\tptimeout_deadline_ms(&timeout, *timeoutp);\n\tif (stop != NULL)\n\t\tsigfillset(&nsigset);\n\tfor (; timeoutp == NULL || *timeoutp >= 0;) {\n\t\tif (stop != NULL) {\n\t\t\tsigprocmask(SIG_BLOCK, &nsigset, &osigset);\n\t\t\tif (*stop) {\n\t\t\t\tsigprocmask(SIG_SETMASK, &osigset, NULL);\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tr = ppoll(&pfd, 1, ptimeout_get_tsp(&timeout),\n\t\t    stop != NULL ? &osigset : NULL);\n\t\toerrno = errno;\n\t\tif (stop != NULL)\n\t\t\tsigprocmask(SIG_SETMASK, &osigset, NULL);\n\t\tif (timeoutp)\n\t\t\t*timeoutp = ptimeout_get_ms(&timeout);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN && errno != EINTR)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\t \n\terrno = ETIMEDOUT;\n\treturn -1;\n}\n\n \nint\nwaitrfd(int fd, int *timeoutp, volatile sig_atomic_t *stop) {\n\treturn waitfd(fd, timeoutp, POLLIN, stop);\n}\n\n \nint\ntimeout_connect(int sockfd, const struct sockaddr *serv_addr,\n    socklen_t addrlen, int *timeoutp)\n{\n\tint optval = 0;\n\tsocklen_t optlen = sizeof(optval);\n\n\t \n\tif (timeoutp == NULL || *timeoutp <= 0)\n\t\treturn connect(sockfd, serv_addr, addrlen);\n\n\tset_nonblock(sockfd);\n\tfor (;;) {\n\t\tif (connect(sockfd, serv_addr, addrlen) == 0) {\n\t\t\t \n\t\t\tunset_nonblock(sockfd);\n\t\t\treturn 0;\n\t\t} else if (errno == EINTR)\n\t\t\tcontinue;\n\t\telse if (errno != EINPROGRESS)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\n\tif (waitfd(sockfd, timeoutp, POLLIN | POLLOUT, NULL) == -1)\n\t\treturn -1;\n\n\t \n\tif (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &optval, &optlen) == -1) {\n\t\tdebug(\"getsockopt: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (optval != 0) {\n\t\terrno = optval;\n\t\treturn -1;\n\t}\n\tunset_nonblock(sockfd);\n\treturn 0;\n}\n\n \n#define WHITESPACE \" \\t\\r\\n\"\n#define QUOTE\t\"\\\"\"\n\n \nstatic char *\nstrdelim_internal(char **s, int split_equals)\n{\n\tchar *old;\n\tint wspace = 0;\n\n\tif (*s == NULL)\n\t\treturn NULL;\n\n\told = *s;\n\n\t*s = strpbrk(*s,\n\t    split_equals ? WHITESPACE QUOTE \"=\" : WHITESPACE QUOTE);\n\tif (*s == NULL)\n\t\treturn (old);\n\n\tif (*s[0] == '\\\"') {\n\t\tmemmove(*s, *s + 1, strlen(*s));  \n\t\t \n\t\tif ((*s = strpbrk(*s, QUOTE)) == NULL) {\n\t\t\treturn (NULL);\t\t \n\t\t} else {\n\t\t\t*s[0] = '\\0';\n\t\t\t*s += strspn(*s + 1, WHITESPACE) + 1;\n\t\t\treturn (old);\n\t\t}\n\t}\n\n\t \n\tif (split_equals && *s[0] == '=')\n\t\twspace = 1;\n\t*s[0] = '\\0';\n\n\t \n\t*s += strspn(*s + 1, WHITESPACE) + 1;\n\tif (split_equals && *s[0] == '=' && !wspace)\n\t\t*s += strspn(*s + 1, WHITESPACE) + 1;\n\n\treturn (old);\n}\n\n \nchar *\nstrdelim(char **s)\n{\n\treturn strdelim_internal(s, 1);\n}\n\n \nchar *\nstrdelimw(char **s)\n{\n\treturn strdelim_internal(s, 0);\n}\n\nstruct passwd *\npwcopy(struct passwd *pw)\n{\n\tstruct passwd *copy = xcalloc(1, sizeof(*copy));\n\n\tcopy->pw_name = xstrdup(pw->pw_name);\n\tcopy->pw_passwd = xstrdup(pw->pw_passwd == NULL ? \"*\" : pw->pw_passwd);\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tcopy->pw_gecos = xstrdup(pw->pw_gecos);\n#endif\n\tcopy->pw_uid = pw->pw_uid;\n\tcopy->pw_gid = pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tcopy->pw_expire = pw->pw_expire;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tcopy->pw_change = pw->pw_change;\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tcopy->pw_class = xstrdup(pw->pw_class);\n#endif\n\tcopy->pw_dir = xstrdup(pw->pw_dir);\n\tcopy->pw_shell = xstrdup(pw->pw_shell);\n\treturn copy;\n}\n\n \nint\na2port(const char *s)\n{\n\tstruct servent *se;\n\tlong long port;\n\tconst char *errstr;\n\n\tport = strtonum(s, 0, 65535, &errstr);\n\tif (errstr == NULL)\n\t\treturn (int)port;\n\tif ((se = getservbyname(s, \"tcp\")) != NULL)\n\t\treturn ntohs(se->s_port);\n\treturn -1;\n}\n\nint\na2tun(const char *s, int *remote)\n{\n\tconst char *errstr = NULL;\n\tchar *sp, *ep;\n\tint tun;\n\n\tif (remote != NULL) {\n\t\t*remote = SSH_TUNID_ANY;\n\t\tsp = xstrdup(s);\n\t\tif ((ep = strchr(sp, ':')) == NULL) {\n\t\t\tfree(sp);\n\t\t\treturn (a2tun(s, NULL));\n\t\t}\n\t\tep[0] = '\\0'; ep++;\n\t\t*remote = a2tun(ep, NULL);\n\t\ttun = a2tun(sp, NULL);\n\t\tfree(sp);\n\t\treturn (*remote == SSH_TUNID_ERR ? *remote : tun);\n\t}\n\n\tif (strcasecmp(s, \"any\") == 0)\n\t\treturn (SSH_TUNID_ANY);\n\n\ttun = strtonum(s, 0, SSH_TUNID_MAX, &errstr);\n\tif (errstr != NULL)\n\t\treturn (SSH_TUNID_ERR);\n\n\treturn (tun);\n}\n\n#define SECONDS\t\t1\n#define MINUTES\t\t(SECONDS * 60)\n#define HOURS\t\t(MINUTES * 60)\n#define DAYS\t\t(HOURS * 24)\n#define WEEKS\t\t(DAYS * 7)\n\n \nint\nconvtime(const char *s)\n{\n\tlong total, secs, multiplier;\n\tconst char *p;\n\tchar *endp;\n\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == INT_MIN || secs == INT_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\n\t\tmultiplier = 1;\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs > INT_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total > INT_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\n\treturn total;\n}\n\n#define TF_BUFS\t8\n#define TF_LEN\t9\n\nconst char *\nfmt_timeframe(time_t t)\n{\n\tchar\t\t*buf;\n\tstatic char\t tfbuf[TF_BUFS][TF_LEN];\t \n\tstatic int\t idx = 0;\n\tunsigned int\t sec, min, hrs, day;\n\tunsigned long long\tweek;\n\n\tbuf = tfbuf[idx++];\n\tif (idx == TF_BUFS)\n\t\tidx = 0;\n\n\tweek = t;\n\n\tsec = week % 60;\n\tweek /= 60;\n\tmin = week % 60;\n\tweek /= 60;\n\thrs = week % 24;\n\tweek /= 24;\n\tday = week % 7;\n\tweek /= 7;\n\n\tif (week > 0)\n\t\tsnprintf(buf, TF_LEN, \"%02lluw%01ud%02uh\", week, day, hrs);\n\telse if (day > 0)\n\t\tsnprintf(buf, TF_LEN, \"%01ud%02uh%02um\", day, hrs, min);\n\telse\n\t\tsnprintf(buf, TF_LEN, \"%02u:%02u:%02u\", hrs, min, sec);\n\n\treturn (buf);\n}\n\n \nchar *\nput_host_port(const char *host, u_short port)\n{\n\tchar *hoststr;\n\n\tif (port == 0 || port == SSH_DEFAULT_PORT)\n\t\treturn(xstrdup(host));\n\tif (asprintf(&hoststr, \"[%s]:%d\", host, (int)port) == -1)\n\t\tfatal(\"put_host_port: asprintf: %s\", strerror(errno));\n\tdebug3(\"put_host_port: %s\", hoststr);\n\treturn hoststr;\n}\n\n \nchar *\nhpdelim2(char **cp, char *delim)\n{\n\tchar *s, *old;\n\n\tif (cp == NULL || *cp == NULL)\n\t\treturn NULL;\n\n\told = s = *cp;\n\tif (*s == '[') {\n\t\tif ((s = strchr(s, ']')) == NULL)\n\t\t\treturn NULL;\n\t\telse\n\t\t\ts++;\n\t} else if ((s = strpbrk(s, \":/\")) == NULL)\n\t\ts = *cp + strlen(*cp);  \n\n\tswitch (*s) {\n\tcase '\\0':\n\t\t*cp = NULL;\t \n\t\tbreak;\n\n\tcase ':':\n\tcase '/':\n\t\tif (delim != NULL)\n\t\t\t*delim = *s;\n\t\t*s = '\\0';\t \n\t\t*cp = s + 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn old;\n}\n\n \nchar *\nhpdelim(char **cp)\n{\n\tchar *r, delim = '\\0';\n\n\tr =  hpdelim2(cp, &delim);\n\tif (delim == '/')\n\t\treturn NULL;\n\treturn r;\n}\n\nchar *\ncleanhostname(char *host)\n{\n\tif (*host == '[' && host[strlen(host) - 1] == ']') {\n\t\thost[strlen(host) - 1] = '\\0';\n\t\treturn (host + 1);\n\t} else\n\t\treturn host;\n}\n\nchar *\ncolon(char *cp)\n{\n\tint flag = 0;\n\n\tif (*cp == ':')\t\t \n\t\treturn NULL;\n\tif (*cp == '[')\n\t\tflag = 1;\n\n\tfor (; *cp; ++cp) {\n\t\tif (*cp == '@' && *(cp+1) == '[')\n\t\t\tflag = 1;\n\t\tif (*cp == ']' && *(cp+1) == ':' && flag)\n\t\t\treturn (cp+1);\n\t\tif (*cp == ':' && !flag)\n\t\t\treturn (cp);\n\t\tif (*cp == '/')\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\n \nint\nparse_user_host_path(const char *s, char **userp, char **hostp, char **pathp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tchar *sdup, *tmp;\n\tint ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\tsdup = xstrdup(s);\n\n\t \n\tif ((tmp = colon(sdup)) == NULL)\n\t\tgoto out;\n\n\t \n\t*tmp++ = '\\0';\n\tif (*tmp == '\\0')\n\t\ttmp = \".\";\n\tpath = xstrdup(tmp);\n\n\t \n\ttmp = strrchr(sdup, '@');\n\tif (tmp != NULL) {\n\t\t*tmp++ = '\\0';\n\t\thost = xstrdup(cleanhostname(tmp));\n\t\tif (*sdup != '\\0')\n\t\t\tuser = xstrdup(sdup);\n\t} else {\n\t\thost = xstrdup(cleanhostname(sdup));\n\t\tuser = NULL;\n\t}\n\n\t \n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\nout:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}\n\n \nint\nparse_user_host_port(const char *s, char **userp, char **hostp, int *portp)\n{\n\tchar *sdup, *cp, *tmp;\n\tchar *user = NULL, *host = NULL;\n\tint port = -1, ret = -1;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\n\tif ((sdup = tmp = strdup(s)) == NULL)\n\t\treturn -1;\n\t \n\tif ((cp = strrchr(tmp, '@')) != NULL) {\n\t\t*cp = '\\0';\n\t\tif (*tmp == '\\0')\n\t\t\tgoto out;\n\t\tif ((user = strdup(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\t \n\tif ((cp = hpdelim(&tmp)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\t \n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\tgoto out;\n\t}\n\t \n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tret = 0;\n out:\n\tfree(sdup);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}\n\n \nstatic int\nhexchar(const char *s)\n{\n\tunsigned char result[2];\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (s[i] >= '0' && s[i] <= '9')\n\t\t\tresult[i] = (unsigned char)(s[i] - '0');\n\t\telse if (s[i] >= 'a' && s[i] <= 'f')\n\t\t\tresult[i] = (unsigned char)(s[i] - 'a') + 10;\n\t\telse if (s[i] >= 'A' && s[i] <= 'F')\n\t\t\tresult[i] = (unsigned char)(s[i] - 'A') + 10;\n\t\telse\n\t\t\treturn -1;\n\t}\n\treturn (result[0] << 4) | result[1];\n}\n\n \nstatic char *\nurldecode(const char *src)\n{\n\tchar *ret, *dst;\n\tint ch;\n\tsize_t srclen;\n\n\tif ((srclen = strlen(src)) >= SIZE_MAX)\n\t\tfatal_f(\"input too large\");\n\tret = xmalloc(srclen + 1);\n\tfor (dst = ret; *src != '\\0'; src++) {\n\t\tswitch (*src) {\n\t\tcase '+':\n\t\t\t*dst++ = ' ';\n\t\t\tbreak;\n\t\tcase '%':\n\t\t\tif (!isxdigit((unsigned char)src[1]) ||\n\t\t\t    !isxdigit((unsigned char)src[2]) ||\n\t\t\t    (ch = hexchar(src + 1)) == -1) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*dst++ = ch;\n\t\t\tsrc += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*dst++ = *src;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*dst = '\\0';\n\n\treturn ret;\n}\n\n \nint\nparse_uri(const char *scheme, const char *uri, char **userp, char **hostp,\n    int *portp, char **pathp)\n{\n\tchar *uridup, *cp, *tmp, ch;\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint port = -1, ret = -1;\n\tsize_t len;\n\n\tlen = strlen(scheme);\n\tif (strncmp(uri, scheme, len) != 0 || strncmp(uri + len, \":\n\t\treturn 1;\n\turi += len + 3;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (hostp != NULL)\n\t\t*hostp = NULL;\n\tif (portp != NULL)\n\t\t*portp = -1;\n\tif (pathp != NULL)\n\t\t*pathp = NULL;\n\n\turidup = tmp = xstrdup(uri);\n\n\t/* Extract optional ssh-info (username + connection params) */\n\tif ((cp = strchr(tmp, '@')) != NULL) {\n\t\tchar *delim;\n\n\t\t*cp = '\\0';\n\t\t/* Extract username and connection params */\n\t\tif ((delim = strchr(tmp, ';')) != NULL) {\n\t\t\t/* Just ignore connection params for now */\n\t\t\t*delim = '\\0';\n\t\t}\n\t\tif (*tmp == '\\0') {\n\t\t\t/* Empty username */\n\t\t\tgoto out;\n\t\t}\n\t\tif ((user = urldecode(tmp)) == NULL)\n\t\t\tgoto out;\n\t\ttmp = cp + 1;\n\t}\n\n\t/* Extract mandatory hostname */\n\tif ((cp = hpdelim2(&tmp, &ch)) == NULL || *cp == '\\0')\n\t\tgoto out;\n\thost = xstrdup(cleanhostname(cp));\n\tif (!valid_domain(host, 0, NULL))\n\t\tgoto out;\n\n\tif (tmp != NULL && *tmp != '\\0') {\n\t\tif (ch == ':') {\n\t\t\t/* Convert and verify port. */\n\t\t\tif ((cp = strchr(tmp, '/')) != NULL)\n\t\t\t\t*cp = '\\0';\n\t\t\tif ((port = a2port(tmp)) <= 0)\n\t\t\t\tgoto out;\n\t\t\ttmp = cp ? cp + 1 : NULL;\n\t\t}\n\t\tif (tmp != NULL && *tmp != '\\0') {\n\t\t\t/* Extract optional path */\n\t\t\tif ((path = urldecode(tmp)) == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Success */\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (hostp != NULL) {\n\t\t*hostp = host;\n\t\thost = NULL;\n\t}\n\tif (portp != NULL)\n\t\t*portp = port;\n\tif (pathp != NULL) {\n\t\t*pathp = path;\n\t\tpath = NULL;\n\t}\n\tret = 0;\n out:\n\tfree(uridup);\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn ret;\n}\n\n/* function to assist building execv() arguments */\nvoid\naddargs(arglist *args, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tu_int nalloc;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal_f(\"argument too long\");\n\n\tnalloc = args->nalloc;\n\tif (args->list == NULL) {\n\t\tnalloc = 32;\n\t\targs->num = 0;\n\t} else if (args->num > (256 * 1024))\n\t\tfatal_f(\"too many arguments\");\n\telse if (args->num >= args->nalloc)\n\t\tfatal_f(\"arglist corrupt\");\n\telse if (args->num+2 >= nalloc)\n\t\tnalloc *= 2;\n\n\targs->list = xrecallocarray(args->list, args->nalloc,\n\t    nalloc, sizeof(char *));\n\targs->nalloc = nalloc;\n\targs->list[args->num++] = cp;\n\targs->list[args->num] = NULL;\n}\n\nvoid\nreplacearg(arglist *args, u_int which, char *fmt, ...)\n{\n\tva_list ap;\n\tchar *cp;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vasprintf(&cp, fmt, ap);\n\tva_end(ap);\n\tif (r == -1)\n\t\tfatal_f(\"argument too long\");\n\tif (args->list == NULL || args->num >= args->nalloc)\n\t\tfatal_f(\"arglist corrupt\");\n\n\tif (which >= args->num)\n\t\tfatal_f(\"tried to replace invalid arg %d >= %d\",\n\t\t    which, args->num);\n\tfree(args->list[which]);\n\targs->list[which] = cp;\n}\n\nvoid\nfreeargs(arglist *args)\n{\n\tu_int i;\n\n\tif (args == NULL)\n\t\treturn;\n\tif (args->list != NULL && args->num < args->nalloc) {\n\t\tfor (i = 0; i < args->num; i++)\n\t\t\tfree(args->list[i]);\n\t\tfree(args->list);\n\t}\n\targs->nalloc = args->num = 0;\n\targs->list = NULL;\n}\n\n/*\n * Expands tildes in the file name.  Returns data allocated by xmalloc.\n * Warning: this calls getpw*.\n */\nint\ntilde_expand(const char *filename, uid_t uid, char **retp)\n{\n\tchar *ocopy = NULL, *copy, *s = NULL;\n\tconst char *path = NULL, *user = NULL;\n\tstruct passwd *pw;\n\tsize_t len;\n\tint ret = -1, r, slash;\n\n\t*retp = NULL;\n\tif (*filename != '~') {\n\t\t*retp = xstrdup(filename);\n\t\treturn 0;\n\t}\n\tocopy = copy = xstrdup(filename + 1);\n\n\tif (*copy == '\\0')\t\t\t\t/* ~ */\n\t\tpath = NULL;\n\telse if (*copy == '/') {\n\t\tcopy += strspn(copy, \"/\");\n\t\tif (*copy == '\\0')\n\t\t\tpath = NULL;\t\t\t/* ~/ */\n\t\telse\n\t\t\tpath = copy;\t\t\t/* ~/path */\n\t} else {\n\t\tuser = copy;\n\t\tif ((path = strchr(copy, '/')) != NULL) {\n\t\t\tcopy[path - copy] = '\\0';\n\t\t\tpath++;\n\t\t\tpath += strspn(path, \"/\");\n\t\t\tif (*path == '\\0')\t\t/* ~user/ */\n\t\t\t\tpath = NULL;\n\t\t\t/* else\t\t\t\t ~user/path */\n\t\t}\n\t\t/* else\t\t\t\t\t~user */\n\t}\n\tif (user != NULL) {\n\t\tif ((pw = getpwnam(user)) == NULL) {\n\t\t\terror_f(\"No such user %s\", user);\n\t\t\tgoto out;\n\t\t}\n\t} else if ((pw = getpwuid(uid)) == NULL) {\n\t\terror_f(\"No such uid %ld\", (long)uid);\n\t\tgoto out;\n\t}\n\n\t/* Make sure directory has a trailing '/' */\n\tslash = (len = strlen(pw->pw_dir)) == 0 || pw->pw_dir[len - 1] != '/';\n\n\tif ((r = xasprintf(&s, \"%s%s%s\", pw->pw_dir,\n\t    slash ? \"/\" : \"\", path != NULL ? path : \"\")) <= 0) {\n\t\terror_f(\"xasprintf failed\");\n\t\tgoto out;\n\t}\n\tif (r >= PATH_MAX) {\n\t\terror_f(\"Path too long\");\n\t\tgoto out;\n\t}\n\t/* success */\n\tret = 0;\n\t*retp = s;\n\ts = NULL;\n out:\n\tfree(s);\n\tfree(ocopy);\n\treturn ret;\n}\n\nchar *\ntilde_expand_filename(const char *filename, uid_t uid)\n{\n\tchar *ret;\n\n\tif (tilde_expand(filename, uid, &ret) != 0)\n\t\tcleanup_exit(255);\n\treturn ret;\n}\n\n/*\n * Expand a string with a set of %[char] escapes and/or ${ENVIRONMENT}\n * substitutions.  A number of escapes may be specified as\n * (char *escape_chars, char *replacement) pairs. The list must be terminated\n * by a NULL escape_char. Returns replaced string in memory allocated by\n * xmalloc which the caller must free.\n */\nstatic char *\nvdollar_percent_expand(int *parseerror, int dollar, int percent,\n    const char *string, va_list ap)\n{\n#define EXPAND_MAX_KEYS\t64\n\tu_int num_keys = 0, i;\n\tstruct {\n\t\tconst char *key;\n\t\tconst char *repl;\n\t} keys[EXPAND_MAX_KEYS];\n\tstruct sshbuf *buf;\n\tint r, missingvar = 0;\n\tchar *ret = NULL, *var, *varend, *val;\n\tsize_t len;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif (parseerror == NULL)\n\t\tfatal_f(\"null parseerror arg\");\n\t*parseerror = 1;\n\n\t/* Gather keys if we're doing percent expansion. */\n\tif (percent) {\n\t\tfor (num_keys = 0; num_keys < EXPAND_MAX_KEYS; num_keys++) {\n\t\t\tkeys[num_keys].key = va_arg(ap, char *);\n\t\t\tif (keys[num_keys].key == NULL)\n\t\t\t\tbreak;\n\t\t\tkeys[num_keys].repl = va_arg(ap, char *);\n\t\t\tif (keys[num_keys].repl == NULL) {\n\t\t\t\tfatal_f(\"NULL replacement for token %s\",\n\t\t\t\t    keys[num_keys].key);\n\t\t\t}\n\t\t}\n\t\tif (num_keys == EXPAND_MAX_KEYS && va_arg(ap, char *) != NULL)\n\t\t\tfatal_f(\"too many keys\");\n\t\tif (num_keys == 0)\n\t\t\tfatal_f(\"percent expansion without token list\");\n\t}\n\n\t/* Expand string */\n\tfor (i = 0; *string != '\\0'; string++) {\n\t\t/* Optionally process ${ENVIRONMENT} expansions. */\n\t\tif (dollar && string[0] == '$' && string[1] == '{') {\n\t\t\tstring += 2;  /* skip over '${' */\n\t\t\tif ((varend = strchr(string, '}')) == NULL) {\n\t\t\t\terror_f(\"environment variable '%s' missing \"\n\t\t\t\t    \"closing '}'\", string);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlen = varend - string;\n\t\t\tif (len == 0) {\n\t\t\t\terror_f(\"zero-length environment variable\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvar = xmalloc(len + 1);\n\t\t\t(void)strlcpy(var, string, len + 1);\n\t\t\tif ((val = getenv(var)) == NULL) {\n\t\t\t\terror_f(\"env var ${%s} has no value\", var);\n\t\t\t\tmissingvar = 1;\n\t\t\t} else {\n\t\t\t\tdebug3_f(\"expand ${%s} -> '%s'\", var, val);\n\t\t\t\tif ((r = sshbuf_put(buf, val, strlen(val))) !=0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_put ${}\");\n\t\t\t}\n\t\t\tfree(var);\n\t\t\tstring += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Process percent expansions if we have a list of TOKENs.\n\t\t * If we're not doing percent expansion everything just gets\n\t\t * appended here.\n\t\t */\n\t\tif (*string != '%' || !percent) {\n append:\n\t\t\tif ((r = sshbuf_put_u8(buf, *string)) != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_put_u8 %%\");\n\t\t\tcontinue;\n\t\t}\n\t\tstring++;\n\t\t/* %% case */\n\t\tif (*string == '%')\n\t\t\tgoto append;\n\t\tif (*string == '\\0') {\n\t\t\terror_f(\"invalid format\");\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < num_keys; i++) {\n\t\t\tif (strchr(keys[i].key, *string) != NULL) {\n\t\t\t\tif ((r = sshbuf_put(buf, keys[i].repl,\n\t\t\t\t    strlen(keys[i].repl))) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_put %%-repl\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i >= num_keys) {\n\t\t\terror_f(\"unknown key %%%c\", *string);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (!missingvar && (ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal_f(\"sshbuf_dup_string failed\");\n\t*parseerror = 0;\n out:\n\tsshbuf_free(buf);\n\treturn *parseerror ? NULL : ret;\n#undef EXPAND_MAX_KEYS\n}\n\n/*\n * Expand only environment variables.\n * Note that although this function is variadic like the other similar\n * functions, any such arguments will be unused.\n */\n\nchar *\ndollar_expand(int *parseerr, const char *string, ...)\n{\n\tchar *ret;\n\tint err;\n\tva_list ap;\n\n\tva_start(ap, string);\n\tret = vdollar_percent_expand(&err, 1, 0, string, ap);\n\tva_end(ap);\n\tif (parseerr != NULL)\n\t\t*parseerr = err;\n\treturn ret;\n}\n\n/*\n * Returns expanded string or NULL if a specified environment variable is\n * not defined, or calls fatal if the string is invalid.\n */\nchar *\npercent_expand(const char *string, ...)\n{\n\tchar *ret;\n\tint err;\n\tva_list ap;\n\n\tva_start(ap, string);\n\tret = vdollar_percent_expand(&err, 0, 1, string, ap);\n\tva_end(ap);\n\tif (err)\n\t\tfatal_f(\"failed\");\n\treturn ret;\n}\n\n/*\n * Returns expanded string or NULL if a specified environment variable is\n * not defined, or calls fatal if the string is invalid.\n */\nchar *\npercent_dollar_expand(const char *string, ...)\n{\n\tchar *ret;\n\tint err;\n\tva_list ap;\n\n\tva_start(ap, string);\n\tret = vdollar_percent_expand(&err, 1, 1, string, ap);\n\tva_end(ap);\n\tif (err)\n\t\tfatal_f(\"failed\");\n\treturn ret;\n}\n\nint\ntun_open(int tun, int mode, char **ifname)\n{\n#if defined(CUSTOM_SYS_TUN_OPEN)\n\treturn (sys_tun_open(tun, mode, ifname));\n#elif defined(SSH_TUN_OPENBSD)\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET)\n\t\ttunbase = \"tap\";\n\n\t/* Open the tunnel device */\n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug_f(\"invalid tunnel %u\", tun);\n\t\treturn -1;\n\t}\n\n\tif (fd == -1) {\n\t\tdebug_f(\"%s open: %s\", name, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug_f(\"%s mode %d fd %d\", name, mode, fd);\n\n\t/* Bring interface up if it is not already */\n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tdebug_f(\"get interface %s flags: %s\", ifr.ifr_name,\n\t\t    strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (!(ifr.ifr_flags & IFF_UP)) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tdebug_f(\"activate interface %s: %s\", ifr.ifr_name,\n\t\t\t    strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (ifname != NULL)\n\t\t*ifname = xstrdup(ifr.ifr_name);\n\n\tclose(sock);\n\treturn fd;\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\treturn -1;\n#else\n\terror(\"Tunnel interfaces are not supported on this platform\");\n\treturn (-1);\n#endif\n}\n\nvoid\nsanitise_stdfd(void)\n{\n\tint nullfd, dupfd;\n\n\tif ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open /dev/null: %s\\n\",\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\twhile (++dupfd <= STDERR_FILENO) {\n\t\t/* Only populate closed fds. */\n\t\tif (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {\n\t\t\tif (dup2(nullfd, dupfd) == -1) {\n\t\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (nullfd > STDERR_FILENO)\n\t\tclose(nullfd);\n}\n\nchar *\ntohex(const void *vp, size_t l)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tchar b[3], *r;\n\tsize_t i, hl;\n\n\tif (l > 65536)\n\t\treturn xstrdup(\"tohex: length > 65536\");\n\n\thl = l * 2 + 1;\n\tr = xcalloc(1, hl);\n\tfor (i = 0; i < l; i++) {\n\t\tsnprintf(b, sizeof(b), \"%02x\", p[i]);\n\t\tstrlcat(r, b, hl);\n\t}\n\treturn (r);\n}\n\n/*\n * Extend string *sp by the specified format. If *sp is not NULL (or empty),\n * then the separator 'sep' will be prepended before the formatted arguments.\n * Extended strings are heap allocated.\n */\nvoid\nxextendf(char **sp, const char *sep, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *tmp1, *tmp2;\n\n\tva_start(ap, fmt);\n\txvasprintf(&tmp1, fmt, ap);\n\tva_end(ap);\n\n\tif (*sp == NULL || **sp == '\\0') {\n\t\tfree(*sp);\n\t\t*sp = tmp1;\n\t\treturn;\n\t}\n\txasprintf(&tmp2, \"%s%s%s\", *sp, sep == NULL ? \"\" : sep, tmp1);\n\tfree(tmp1);\n\tfree(*sp);\n\t*sp = tmp2;\n}\n\n\nu_int64_t\nget_u64(const void *vp)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tu_int64_t v;\n\n\tv  = (u_int64_t)p[0] << 56;\n\tv |= (u_int64_t)p[1] << 48;\n\tv |= (u_int64_t)p[2] << 40;\n\tv |= (u_int64_t)p[3] << 32;\n\tv |= (u_int64_t)p[4] << 24;\n\tv |= (u_int64_t)p[5] << 16;\n\tv |= (u_int64_t)p[6] << 8;\n\tv |= (u_int64_t)p[7];\n\n\treturn (v);\n}\n\nu_int32_t\nget_u32(const void *vp)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tu_int32_t v;\n\n\tv  = (u_int32_t)p[0] << 24;\n\tv |= (u_int32_t)p[1] << 16;\n\tv |= (u_int32_t)p[2] << 8;\n\tv |= (u_int32_t)p[3];\n\n\treturn (v);\n}\n\nu_int32_t\nget_u32_le(const void *vp)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tu_int32_t v;\n\n\tv  = (u_int32_t)p[0];\n\tv |= (u_int32_t)p[1] << 8;\n\tv |= (u_int32_t)p[2] << 16;\n\tv |= (u_int32_t)p[3] << 24;\n\n\treturn (v);\n}\n\nu_int16_t\nget_u16(const void *vp)\n{\n\tconst u_char *p = (const u_char *)vp;\n\tu_int16_t v;\n\n\tv  = (u_int16_t)p[0] << 8;\n\tv |= (u_int16_t)p[1];\n\n\treturn (v);\n}\n\nvoid\nput_u64(void *vp, u_int64_t v)\n{\n\tu_char *p = (u_char *)vp;\n\n\tp[0] = (u_char)(v >> 56) & 0xff;\n\tp[1] = (u_char)(v >> 48) & 0xff;\n\tp[2] = (u_char)(v >> 40) & 0xff;\n\tp[3] = (u_char)(v >> 32) & 0xff;\n\tp[4] = (u_char)(v >> 24) & 0xff;\n\tp[5] = (u_char)(v >> 16) & 0xff;\n\tp[6] = (u_char)(v >> 8) & 0xff;\n\tp[7] = (u_char)v & 0xff;\n}\n\nvoid\nput_u32(void *vp, u_int32_t v)\n{\n\tu_char *p = (u_char *)vp;\n\n\tp[0] = (u_char)(v >> 24) & 0xff;\n\tp[1] = (u_char)(v >> 16) & 0xff;\n\tp[2] = (u_char)(v >> 8) & 0xff;\n\tp[3] = (u_char)v & 0xff;\n}\n\nvoid\nput_u32_le(void *vp, u_int32_t v)\n{\n\tu_char *p = (u_char *)vp;\n\n\tp[0] = (u_char)v & 0xff;\n\tp[1] = (u_char)(v >> 8) & 0xff;\n\tp[2] = (u_char)(v >> 16) & 0xff;\n\tp[3] = (u_char)(v >> 24) & 0xff;\n}\n\nvoid\nput_u16(void *vp, u_int16_t v)\n{\n\tu_char *p = (u_char *)vp;\n\n\tp[0] = (u_char)(v >> 8) & 0xff;\n\tp[1] = (u_char)v & 0xff;\n}\n\nvoid\nms_subtract_diff(struct timeval *start, int *ms)\n{\n\tstruct timeval diff, finish;\n\n\tmonotime_tv(&finish);\n\ttimersub(&finish, start, &diff);\n\t*ms -= (diff.tv_sec * 1000) + (diff.tv_usec / 1000);\n}\n\nvoid\nms_to_timespec(struct timespec *ts, int ms)\n{\n\tif (ms < 0)\n\t\tms = 0;\n\tts->tv_sec = ms / 1000;\n\tts->tv_nsec = (ms % 1000) * 1000 * 1000;\n}\n\nvoid\nmonotime_ts(struct timespec *ts)\n{\n\tstruct timeval tv;\n#if defined(HAVE_CLOCK_GETTIME) && (defined(CLOCK_BOOTTIME) || \\\n    defined(CLOCK_MONOTONIC) || defined(CLOCK_REALTIME))\n\tstatic int gettime_failed = 0;\n\n\tif (!gettime_failed) {\n# ifdef CLOCK_BOOTTIME\n\t\tif (clock_gettime(CLOCK_BOOTTIME, ts) == 0)\n\t\t\treturn;\n# endif  \n# ifdef CLOCK_MONOTONIC\n\t\tif (clock_gettime(CLOCK_MONOTONIC, ts) == 0)\n\t\t\treturn;\n# endif  \n# ifdef CLOCK_REALTIME\n\t\t \n\t\tif (clock_gettime(CLOCK_REALTIME, ts) == 0)\n\t\t\treturn;\n# endif  \n\t\tdebug3(\"clock_gettime: %s\", strerror(errno));\n\t\tgettime_failed = 1;\n\t}\n#endif  \n\tgettimeofday(&tv, NULL);\n\tts->tv_sec = tv.tv_sec;\n\tts->tv_nsec = (long)tv.tv_usec * 1000;\n}\n\nvoid\nmonotime_tv(struct timeval *tv)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\ttv->tv_sec = ts.tv_sec;\n\ttv->tv_usec = ts.tv_nsec / 1000;\n}\n\ntime_t\nmonotime(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec;\n}\n\ndouble\nmonotime_double(void)\n{\n\tstruct timespec ts;\n\n\tmonotime_ts(&ts);\n\treturn ts.tv_sec + ((double)ts.tv_nsec / 1000000000);\n}\n\nvoid\nbandwidth_limit_init(struct bwlimit *bw, u_int64_t kbps, size_t buflen)\n{\n\tbw->buflen = buflen;\n\tbw->rate = kbps;\n\tbw->thresh = buflen;\n\tbw->lamt = 0;\n\ttimerclear(&bw->bwstart);\n\ttimerclear(&bw->bwend);\n}\n\n \nvoid\nbandwidth_limit(struct bwlimit *bw, size_t read_len)\n{\n\tu_int64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tbw->lamt += read_len;\n\tif (!timerisset(&bw->bwstart)) {\n\t\tmonotime_tv(&bw->bwstart);\n\t\treturn;\n\t}\n\tif (bw->lamt < bw->thresh)\n\t\treturn;\n\n\tmonotime_tv(&bw->bwend);\n\ttimersub(&bw->bwend, &bw->bwstart, &bw->bwend);\n\tif (!timerisset(&bw->bwend))\n\t\treturn;\n\n\tbw->lamt *= 8;\n\twaitlen = (double)1000000L * bw->lamt / bw->rate;\n\n\tbw->bwstart.tv_sec = waitlen / 1000000L;\n\tbw->bwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bw->bwstart, &bw->bwend, >)) {\n\t\ttimersub(&bw->bwstart, &bw->bwend, &bw->bwend);\n\n\t\t \n\t\tif (bw->bwend.tv_sec) {\n\t\t\tbw->thresh /= 2;\n\t\t\tif (bw->thresh < bw->buflen / 4)\n\t\t\t\tbw->thresh = bw->buflen / 4;\n\t\t} else if (bw->bwend.tv_usec < 10000) {\n\t\t\tbw->thresh *= 2;\n\t\t\tif (bw->thresh > bw->buflen * 8)\n\t\t\t\tbw->thresh = bw->buflen * 8;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bw->bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tbw->lamt = 0;\n\tmonotime_tv(&bw->bwstart);\n}\n\n \nvoid\nmktemp_proto(char *s, size_t len)\n{\n\tconst char *tmpdir;\n\tint r;\n\n\tif ((tmpdir = getenv(\"TMPDIR\")) != NULL) {\n\t\tr = snprintf(s, len, \"%s/ssh-XXXXXXXXXXXX\", tmpdir);\n\t\tif (r > 0 && (size_t)r < len)\n\t\t\treturn;\n\t}\n\tr = snprintf(s, len, \"/tmp/ssh-XXXXXXXXXXXX\");\n\tif (r < 0 || (size_t)r >= len)\n\t\tfatal_f(\"template string too short\");\n}\n\nstatic const struct {\n\tconst char *name;\n\tint value;\n} ipqos[] = {\n\t{ \"none\", INT_MAX },\t\t \n\t{ \"af11\", IPTOS_DSCP_AF11 },\n\t{ \"af12\", IPTOS_DSCP_AF12 },\n\t{ \"af13\", IPTOS_DSCP_AF13 },\n\t{ \"af21\", IPTOS_DSCP_AF21 },\n\t{ \"af22\", IPTOS_DSCP_AF22 },\n\t{ \"af23\", IPTOS_DSCP_AF23 },\n\t{ \"af31\", IPTOS_DSCP_AF31 },\n\t{ \"af32\", IPTOS_DSCP_AF32 },\n\t{ \"af33\", IPTOS_DSCP_AF33 },\n\t{ \"af41\", IPTOS_DSCP_AF41 },\n\t{ \"af42\", IPTOS_DSCP_AF42 },\n\t{ \"af43\", IPTOS_DSCP_AF43 },\n\t{ \"cs0\", IPTOS_DSCP_CS0 },\n\t{ \"cs1\", IPTOS_DSCP_CS1 },\n\t{ \"cs2\", IPTOS_DSCP_CS2 },\n\t{ \"cs3\", IPTOS_DSCP_CS3 },\n\t{ \"cs4\", IPTOS_DSCP_CS4 },\n\t{ \"cs5\", IPTOS_DSCP_CS5 },\n\t{ \"cs6\", IPTOS_DSCP_CS6 },\n\t{ \"cs7\", IPTOS_DSCP_CS7 },\n\t{ \"ef\", IPTOS_DSCP_EF },\n\t{ \"le\", IPTOS_DSCP_LE },\n\t{ \"lowdelay\", IPTOS_LOWDELAY },\n\t{ \"throughput\", IPTOS_THROUGHPUT },\n\t{ \"reliability\", IPTOS_RELIABILITY },\n\t{ NULL, -1 }\n};\n\nint\nparse_ipqos(const char *cp)\n{\n\tu_int i;\n\tchar *ep;\n\tlong val;\n\n\tif (cp == NULL)\n\t\treturn -1;\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (strcasecmp(cp, ipqos[i].name) == 0)\n\t\t\treturn ipqos[i].value;\n\t}\n\t \n\tval = strtol(cp, &ep, 0);\n\tif (*cp == '\\0' || *ep != '\\0' || val < 0 || val > 255)\n\t\treturn -1;\n\treturn val;\n}\n\nconst char *\niptos2str(int iptos)\n{\n\tint i;\n\tstatic char iptos_str[sizeof \"0xff\"];\n\n\tfor (i = 0; ipqos[i].name != NULL; i++) {\n\t\tif (ipqos[i].value == iptos)\n\t\t\treturn ipqos[i].name;\n\t}\n\tsnprintf(iptos_str, sizeof iptos_str, \"0x%02x\", iptos);\n\treturn iptos_str;\n}\n\nvoid\nlowercase(char *s)\n{\n\tfor (; *s; s++)\n\t\t*s = tolower((u_char)*s);\n}\n\nint\nunix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror_f(\"path \\\"%s\\\" too long for Unix domain socket\", path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"socket: %.100s\", strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot bind to path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot listen on path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}\n\nvoid\nsock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}\n\n \nstatic int\nstrcmp_maybe_null(const char *a, const char *b)\n{\n\tif ((a == NULL && b != NULL) || (a != NULL && b == NULL))\n\t\treturn 0;\n\tif (a != NULL && strcmp(a, b) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint\nforward_equals(const struct Forward *a, const struct Forward *b)\n{\n\tif (strcmp_maybe_null(a->listen_host, b->listen_host) == 0)\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->listen_path, b->listen_path) == 0)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_host, b->connect_host) == 0)\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\tif (strcmp_maybe_null(a->connect_path, b->connect_path) == 0)\n\t\treturn 0;\n\t \n\treturn 1;\n}\n\n \nint\ndaemonized(void)\n{\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDONLY | O_NOCTTY)) >= 0) {\n\t\tclose(fd);\n\t\treturn 0;\t \n\t}\n\tif (getppid() != 1)\n\t\treturn 0;\t \n\tif (getsid(0) != getpid())\n\t\treturn 0;\t \n\tdebug3(\"already daemonized\");\n\treturn 1;\n}\n\n \nint\nargv_split(const char *s, int *argcp, char ***argvp, int terminate_on_comment)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint argc = 0, quote, i, j;\n\tchar *arg, **argv = xcalloc(1, sizeof(*argv));\n\n\t*argvp = NULL;\n\t*argcp = 0;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\t \n\t\tif (s[i] == ' ' || s[i] == '\\t')\n\t\t\tcontinue;\n\t\tif (terminate_on_comment && s[i] == '#')\n\t\t\tbreak;\n\t\t \n\t\tquote = 0;\n\n\t\targv = xreallocarray(argv, (argc + 2), sizeof(*argv));\n\t\targ = argv[argc++] = xcalloc(1, strlen(s + i) + 1);\n\t\targv[argc] = NULL;\n\n\t\t \n\t\tfor (j = 0; s[i] != '\\0'; i++) {\n\t\t\tif (s[i] == '\\\\') {\n\t\t\t\tif (s[i + 1] == '\\'' ||\n\t\t\t\t    s[i + 1] == '\\\"' ||\n\t\t\t\t    s[i + 1] == '\\\\' ||\n\t\t\t\t    (quote == 0 && s[i + 1] == ' ')) {\n\t\t\t\t\ti++;  \n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\targ[j++] = s[i];\n\t\t\t\t}\n\t\t\t} else if (quote == 0 && (s[i] == ' ' || s[i] == '\\t'))\n\t\t\t\tbreak;  \n\t\t\telse if (quote == 0 && (s[i] == '\\\"' || s[i] == '\\''))\n\t\t\t\tquote = s[i];  \n\t\t\telse if (quote != 0 && s[i] == quote)\n\t\t\t\tquote = 0;  \n\t\t\telse\n\t\t\t\targ[j++] = s[i];\n\t\t}\n\t\tif (s[i] == '\\0') {\n\t\t\tif (quote != 0) {\n\t\t\t\t \n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\t*argcp = argc;\n\t*argvp = argv;\n\targc = 0;\n\targv = NULL;\n\tr = 0;\n out:\n\tif (argc != 0 && argv != NULL) {\n\t\tfor (i = 0; i < argc; i++)\n\t\t\tfree(argv[i]);\n\t\tfree(argv);\n\t}\n\treturn r;\n}\n\n \nchar *\nargv_assemble(int argc, char **argv)\n{\n\tint i, j, ws, r;\n\tchar c, *ret;\n\tstruct sshbuf *buf, *arg;\n\n\tif ((buf = sshbuf_new()) == NULL || (arg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tfor (i = 0; i < argc; i++) {\n\t\tws = 0;\n\t\tsshbuf_reset(arg);\n\t\tfor (j = 0; argv[i][j] != '\\0'; j++) {\n\t\t\tr = 0;\n\t\t\tc = argv[i][j];\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tws = 1;\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tif ((r = sshbuf_put_u8(arg, '\\\\')) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\tdefault:\n\t\t\t\tr = sshbuf_put_u8(arg, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_put_u8\");\n\t\t}\n\t\tif ((i != 0 && (r = sshbuf_put_u8(buf, ' ')) != 0) ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0) ||\n\t\t    (r = sshbuf_putb(buf, arg)) != 0 ||\n\t\t    (ws != 0 && (r = sshbuf_put_u8(buf, '\"')) != 0))\n\t\t\tfatal_fr(r, \"assemble\");\n\t}\n\tif ((ret = malloc(sshbuf_len(buf) + 1)) == NULL)\n\t\tfatal_f(\"malloc failed\");\n\tmemcpy(ret, sshbuf_ptr(buf), sshbuf_len(buf));\n\tret[sshbuf_len(buf)] = '\\0';\n\tsshbuf_free(buf);\n\tsshbuf_free(arg);\n\treturn ret;\n}\n\nchar *\nargv_next(int *argcp, char ***argvp)\n{\n\tchar *ret = (*argvp)[0];\n\n\tif (*argcp > 0 && ret != NULL) {\n\t\t(*argcp)--;\n\t\t(*argvp)++;\n\t}\n\treturn ret;\n}\n\nvoid\nargv_consume(int *argcp)\n{\n\t*argcp = 0;\n}\n\nvoid\nargv_free(char **av, int ac)\n{\n\tint i;\n\n\tif (av == NULL)\n\t\treturn;\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n}\n\n \nint\nexited_cleanly(pid_t pid, const char *tag, const char *cmd, int quiet)\n{\n\tint status;\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR) {\n\t\t\terror(\"%s waitpid: %s\", tag, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (WIFSIGNALED(status)) {\n\t\terror(\"%s %s exited on signal %d\", tag, cmd, WTERMSIG(status));\n\t\treturn -1;\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\tdo_log2(quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s %s failed, status %d\", tag, cmd, WEXITSTATUS(status));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint\nsafe_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t \n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) == -1 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint\nsafe_path_fd(int fd, const char *file, struct passwd *pw,\n    char *err, size_t errlen)\n{\n\tstruct stat st;\n\n\t \n\tif (fstat(fd, &st) == -1) {\n\t\tsnprintf(err, errlen, \"cannot stat file %s: %s\",\n\t\t    file, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn safe_path(file, &st, pw->pw_dir, pw->pw_uid, err, errlen);\n}\n\n \nvoid\nchild_set_env(char ***envp, u_int *envsizep, const char *name,\n\tconst char *value)\n{\n\tchar **env;\n\tu_int envsize;\n\tu_int i, namelen;\n\n\tif (strchr(name, '=') != NULL) {\n\t\terror(\"Invalid environment variable \\\"%.100s\\\"\", name);\n\t\treturn;\n\t}\n\n\t \n\tif ((*envp == NULL) != (*envsizep == 0))\n\t\tfatal_f(\"environment size mismatch\");\n\tif (*envp == NULL && *envsizep == 0) {\n\t\t*envp = xmalloc(sizeof(char *));\n\t\t*envp[0] = NULL;\n\t\t*envsizep = 1;\n\t}\n\n\t \n\tenv = *envp;\n\tnamelen = strlen(name);\n\tfor (i = 0; env[i]; i++)\n\t\tif (strncmp(env[i], name, namelen) == 0 && env[i][namelen] == '=')\n\t\t\tbreak;\n\tif (env[i]) {\n\t\t \n\t\tfree(env[i]);\n\t} else {\n\t\t \n\t\tenvsize = *envsizep;\n\t\tif (i >= envsize - 1) {\n\t\t\tif (envsize >= 1000)\n\t\t\t\tfatal(\"child_set_env: too many env vars\");\n\t\t\tenvsize += 50;\n\t\t\tenv = (*envp) = xreallocarray(env, envsize, sizeof(char *));\n\t\t\t*envsizep = envsize;\n\t\t}\n\t\t \n\t\tenv[i + 1] = NULL;\n\t}\n\n\t \n\t \n\tenv[i] = xmalloc(strlen(name) + 1 + strlen(value) + 1);\n\tsnprintf(env[i], strlen(name) + 1 + strlen(value) + 1, \"%s=%s\", name, value);\n}\n\n \nint\nvalid_domain(char *name, int makelower, const char **errstr)\n{\n\tsize_t i, l = strlen(name);\n\tu_char c, last = '\\0';\n\tstatic char errbuf[256];\n\n\tif (l == 0) {\n\t\tstrlcpy(errbuf, \"empty domain name\", sizeof(errbuf));\n\t\tgoto bad;\n\t}\n\tif (!isalpha((u_char)name[0]) && !isdigit((u_char)name[0])) {\n\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \\\"%.100s\\\" \"\n\t\t    \"starts with invalid character\", name);\n\t\tgoto bad;\n\t}\n\tfor (i = 0; i < l; i++) {\n\t\tc = tolower((u_char)name[i]);\n\t\tif (makelower)\n\t\t\tname[i] = (char)c;\n\t\tif (last == '.' && c == '.') {\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \"\n\t\t\t    \"\\\"%.100s\\\" contains consecutive separators\", name);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (c != '.' && c != '-' && !isalnum(c) &&\n\t\t    c != '_')   {\n\t\t\tsnprintf(errbuf, sizeof(errbuf), \"domain name \"\n\t\t\t    \"\\\"%.100s\\\" contains invalid characters\", name);\n\t\t\tgoto bad;\n\t\t}\n\t\tlast = c;\n\t}\n\tif (name[l - 1] == '.')\n\t\tname[l - 1] = '\\0';\n\tif (errstr != NULL)\n\t\t*errstr = NULL;\n\treturn 1;\nbad:\n\tif (errstr != NULL)\n\t\t*errstr = errbuf;\n\treturn 0;\n}\n\n \nint\nvalid_env_name(const char *name)\n{\n\tconst char *cp;\n\n\tif (name[0] == '\\0')\n\t\treturn 0;\n\tfor (cp = name; *cp != '\\0'; cp++) {\n\t\tif (!isalnum((u_char)*cp) && *cp != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nconst char *\natoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}\n\nint\nparse_absolute_time(const char *s, uint64_t *tp)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tchar buf[32], *fmt;\n\tconst char *cp;\n\tsize_t l;\n\tint is_utc = 0;\n\n\t*tp = 0;\n\n\tl = strlen(s);\n\tif (l > 1 && strcasecmp(s + l - 1, \"Z\") == 0) {\n\t\tis_utc = 1;\n\t\tl--;\n\t} else if (l > 3 && strcasecmp(s + l - 3, \"UTC\") == 0) {\n\t\tis_utc = 1;\n\t\tl -= 3;\n\t}\n\t \n\tswitch (l) {\n\tcase 8:  \n\t\tfmt = \"%Y-%m-%d\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2s\", s, s + 4, s + 6);\n\t\tbreak;\n\tcase 12:  \n\t\tfmt = \"%Y-%m-%dT%H:%M\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10);\n\t\tbreak;\n\tcase 14:  \n\t\tfmt = \"%Y-%m-%dT%H:%M:%S\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10, s + 12);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif ((cp = strptime(buf, fmt, &tm)) == NULL || *cp != '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (is_utc) {\n\t\tif ((tt = timegm(&tm)) < 0)\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t} else {\n\t\tif ((tt = mktime(&tm)) < 0)\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\t \n\t*tp = (uint64_t)tt;\n\treturn 0;\n}\n\nvoid\nformat_absolute_time(uint64_t t, char *buf, size_t len)\n{\n\ttime_t tt = t > SSH_TIME_T_MAX ? SSH_TIME_T_MAX : t;\n\tstruct tm tm;\n\n\tlocaltime_r(&tt, &tm);\n\tstrftime(buf, len, \"%Y-%m-%dT%H:%M:%S\", &tm);\n}\n\n \nint\nparse_pattern_interval(const char *s, char **typep, int *secsp)\n{\n\tchar *cp, *sdup;\n\tint secs;\n\n\tif (typep != NULL)\n\t\t*typep = NULL;\n\tif (secsp != NULL)\n\t\t*secsp = 0;\n\tif (s == NULL)\n\t\treturn -1;\n\tsdup = xstrdup(s);\n\n\tif ((cp = strchr(sdup, '=')) == NULL || cp == sdup) {\n\t\tfree(sdup);\n\t\treturn -1;\n\t}\n\t*cp++ = '\\0';\n\tif ((secs = convtime(cp)) < 0) {\n\t\tfree(sdup);\n\t\treturn -1;\n\t}\n\t \n\tif (typep != NULL)\n\t\t*typep = xstrdup(sdup);\n\tif (secsp != NULL)\n\t\t*secsp = secs;\n\tfree(sdup);\n\treturn 0;\n}\n\n \nint\npath_absolute(const char *path)\n{\n\treturn (*path == '/') ? 1 : 0;\n}\n\nvoid\nskip_space(char **cpp)\n{\n\tchar *cp;\n\n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\t*cpp = cp;\n}\n\n \n\n \nint\nopt_flag(const char *opt, int allow_negate, const char **optsp)\n{\n\tsize_t opt_len = strlen(opt);\n\tconst char *opts = *optsp;\n\tint negate = 0;\n\n\tif (allow_negate && strncasecmp(opts, \"no-\", 3) == 0) {\n\t\topts += 3;\n\t\tnegate = 1;\n\t}\n\tif (strncasecmp(opts, opt, opt_len) == 0) {\n\t\t*optsp = opts + opt_len;\n\t\treturn negate ? 0 : 1;\n\t}\n\treturn -1;\n}\n\nchar *\nopt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}\n\nint\nopt_match(const char **opts, const char *term)\n{\n\tif (strncasecmp((*opts), term, strlen(term)) == 0 &&\n\t    (*opts)[strlen(term)] == '=') {\n\t\t*opts += strlen(term) + 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid\nopt_array_append2(const char *file, const int line, const char *directive,\n    char ***array, int **iarray, u_int *lp, const char *s, int i)\n{\n\n\tif (*lp >= INT_MAX)\n\t\tfatal(\"%s line %d: Too many %s entries\", file, line, directive);\n\n\tif (iarray != NULL) {\n\t\t*iarray = xrecallocarray(*iarray, *lp, *lp + 1,\n\t\t    sizeof(**iarray));\n\t\t(*iarray)[*lp] = i;\n\t}\n\n\t*array = xrecallocarray(*array, *lp, *lp + 1, sizeof(**array));\n\t(*array)[*lp] = xstrdup(s);\n\t(*lp)++;\n}\n\nvoid\nopt_array_append(const char *file, const int line, const char *directive,\n    char ***array, u_int *lp, const char *s)\n{\n\topt_array_append2(file, line, directive, array, NULL, lp, s, 0);\n}\n\nsshsig_t\nssh_signal(int signum, sshsig_t handler)\n{\n\tstruct sigaction sa, osa;\n\n\t \n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sa_handler = handler;\n\tsigfillset(&sa.sa_mask);\n#if defined(SA_RESTART) && !defined(NO_SA_RESTART)\n\tif (signum != SIGALRM)\n\t\tsa.sa_flags = SA_RESTART;\n#endif\n\tif (sigaction(signum, &sa, &osa) == -1) {\n\t\tdebug3(\"sigaction(%s): %s\", strsignal(signum), strerror(errno));\n\t\treturn SIG_ERR;\n\t}\n\treturn osa.sa_handler;\n}\n\nint\nstdfd_devnull(int do_stdin, int do_stdout, int do_stderr)\n{\n\tint devnull, ret = 0;\n\n\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\terror_f(\"open %s: %s\", _PATH_DEVNULL,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((do_stdin && dup2(devnull, STDIN_FILENO) == -1) ||\n\t    (do_stdout && dup2(devnull, STDOUT_FILENO) == -1) ||\n\t    (do_stderr && dup2(devnull, STDERR_FILENO) == -1)) {\n\t\terror_f(\"dup2: %s\", strerror(errno));\n\t\tret = -1;\n\t}\n\tif (devnull > STDERR_FILENO)\n\t\tclose(devnull);\n\treturn ret;\n}\n\n \npid_t\nsubprocess(const char *tag, const char *command,\n    int ac, char **av, FILE **child, u_int flags,\n    struct passwd *pw, privdrop_fn *drop_privs, privrestore_fn *restore_privs)\n{\n\tFILE *f = NULL;\n\tstruct stat st;\n\tint fd, devnull, p[2], i;\n\tpid_t pid;\n\tchar *cp, errmsg[512];\n\tu_int nenv = 0;\n\tchar **env = NULL;\n\n\t \n\tif (drop_privs != NULL && (pw == NULL || restore_privs == NULL)) {\n\t\terror(\"%s: inconsistent arguments\", tag);  \n\t\treturn 0;\n\t}\n\tif (pw == NULL && (pw = getpwuid(getuid())) == NULL) {\n\t\terror(\"%s: no user for current uid\", tag);\n\t\treturn 0;\n\t}\n\tif (child != NULL)\n\t\t*child = NULL;\n\n\tdebug3_f(\"%s command \\\"%s\\\" running as %s (flags 0x%x)\",\n\t    tag, command, pw->pw_name, flags);\n\n\t \n\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t    (flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0) {\n\t\terror_f(\"inconsistent flags\");\n\t\treturn 0;\n\t}\n\tif (((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0) != (child == NULL)) {\n\t\terror_f(\"inconsistent flags/output\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!path_absolute(av[0])) {\n\t\terror(\"%s path is not absolute\", tag);\n\t\treturn 0;\n\t}\n\tif (drop_privs != NULL)\n\t\tdrop_privs(pw);\n\tif (stat(av[0], &st) == -1) {\n\t\terror(\"Could not stat %s \\\"%s\\\": %s\", tag,\n\t\t    av[0], strerror(errno));\n\t\tgoto restore_return;\n\t}\n\tif ((flags & SSH_SUBPROCESS_UNSAFE_PATH) == 0 &&\n\t    safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {\n\t\terror(\"Unsafe %s \\\"%s\\\": %s\", tag, av[0], errmsg);\n\t\tgoto restore_return;\n\t}\n\t \n\tif (pipe(p) == -1) {\n\t\terror(\"%s: pipe: %s\", tag, strerror(errno));\n restore_return:\n\t\tif (restore_privs != NULL)\n\t\t\trestore_privs();\n\t\treturn 0;\n\t}\n\tif (restore_privs != NULL)\n\t\trestore_privs();\n\n\tswitch ((pid = fork())) {\n\tcase -1:  \n\t\terror(\"%s: fork: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\tclose(p[1]);\n\t\treturn 0;\n\tcase 0:  \n\t\t \n\t\tif ((flags & SSH_SUBPROCESS_PRESERVE_ENV) == 0) {\n\t\t\tnenv = 5;\n\t\t\tenv = xcalloc(sizeof(*env), nenv);\n\t\t\tchild_set_env(&env, &nenv, \"PATH\", _PATH_STDPATH);\n\t\t\tchild_set_env(&env, &nenv, \"USER\", pw->pw_name);\n\t\t\tchild_set_env(&env, &nenv, \"LOGNAME\", pw->pw_name);\n\t\t\tchild_set_env(&env, &nenv, \"HOME\", pw->pw_dir);\n\t\t\tif ((cp = getenv(\"LANG\")) != NULL)\n\t\t\t\tchild_set_env(&env, &nenv, \"LANG\", cp);\n\t\t}\n\n\t\tfor (i = 1; i < NSIG; i++)\n\t\t\tssh_signal(i, SIG_DFL);\n\n\t\tif ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {\n\t\t\terror(\"%s: open %s: %s\", tag, _PATH_DEVNULL,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (dup2(devnull, STDIN_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\n\t\t \n\t\tfd = -1;\n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) != 0)\n\t\t\tfd = p[1];\n\t\telse if ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0)\n\t\t\tfd = devnull;\n\t\tif (fd != -1 && dup2(fd, STDOUT_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\tif (geteuid() == 0 &&\n\t\t    initgroups(pw->pw_name, pw->pw_gid) == -1) {\n\t\t\terror(\"%s: initgroups(%s, %u): %s\", tag,\n\t\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1) {\n\t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1) {\n\t\t\terror(\"%s: setresuid %u: %s\", tag, (u_int)pw->pw_uid,\n\t\t\t    strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\t \n\t\tif ((flags & SSH_SUBPROCESS_STDOUT_DISCARD) != 0 &&\n\t\t    dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n\t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tif (env != NULL)\n\t\t\texecve(av[0], av, env);\n\t\telse\n\t\t\texecv(av[0], av);\n\t\terror(\"%s %s \\\"%s\\\": %s\", tag, env == NULL ? \"execv\" : \"execve\",\n\t\t    command, strerror(errno));\n\t\t_exit(127);\n\tdefault:  \n\t\tbreak;\n\t}\n\n\tclose(p[1]);\n\tif ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)\n\t\tclose(p[0]);\n\telse if ((f = fdopen(p[0], \"r\")) == NULL) {\n\t\terror(\"%s: fdopen: %s\", tag, strerror(errno));\n\t\tclose(p[0]);\n\t\t \n\t\tkill(pid, SIGTERM);\n\t\twhile (waitpid(pid, NULL, 0) == -1 && errno == EINTR)\n\t\t\t;\n\t\treturn 0;\n\t}\n\t \n\tdebug3_f(\"%s pid %ld\", tag, (long)pid);\n\tif (child != NULL)\n\t\t*child = f;\n\treturn pid;\n}\n\nconst char *\nlookup_env_in_list(const char *env, char * const *envs, size_t nenvs)\n{\n\tsize_t i, envlen;\n\n\tenvlen = strlen(env);\n\tfor (i = 0; i < nenvs; i++) {\n\t\tif (strncmp(envs[i], env, envlen) == 0 &&\n\t\t    envs[i][envlen] == '=') {\n\t\t\treturn envs[i] + envlen + 1;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nconst char *\nlookup_setenv_in_list(const char *env, char * const *envs, size_t nenvs)\n{\n\tchar *name, *cp;\n\tconst char *ret;\n\n\tname = xstrdup(env);\n\tif ((cp = strchr(name, '=')) == NULL) {\n\t\tfree(name);\n\t\treturn NULL;  \n\t}\n\t*cp = '\\0';\n\tret = lookup_env_in_list(name, envs, nenvs);\n\tfree(name);\n\treturn ret;\n}\n\n \n\n \nvoid\nptimeout_init(struct timespec *pt)\n{\n\t \n\tpt->tv_sec = -1;\n\tpt->tv_nsec = 0;\n}\n\n \nvoid\nptimeout_deadline_sec(struct timespec *pt, long sec)\n{\n\tif (pt->tv_sec == -1 || pt->tv_sec >= sec) {\n\t\tpt->tv_sec = sec;\n\t\tpt->tv_nsec = 0;\n\t}\n}\n\n \nstatic void\nptimeout_deadline_tsp(struct timespec *pt, struct timespec *p)\n{\n\tif (pt->tv_sec == -1 || timespeccmp(pt, p, >=))\n\t\t*pt = *p;\n}\n\n \nvoid\nptimeout_deadline_ms(struct timespec *pt, long ms)\n{\n\tstruct timespec p;\n\n\tp.tv_sec = ms / 1000;\n\tp.tv_nsec = (ms % 1000) * 1000000;\n\tptimeout_deadline_tsp(pt, &p);\n}\n\n \nvoid\nptimeout_deadline_monotime_tsp(struct timespec *pt, struct timespec *when)\n{\n\tstruct timespec now, t;\n\n\tmonotime_ts(&now);\n\n\tif (timespeccmp(&now, when, >=)) {\n\t\t \n\t\tpt->tv_sec = 0;\n\t\tpt->tv_nsec = 0;\n\t} else {\n\t\ttimespecsub(when, &now, &t);\n\t\tptimeout_deadline_tsp(pt, &t);\n\t}\n}\n\n \nvoid\nptimeout_deadline_monotime(struct timespec *pt, time_t when)\n{\n\tstruct timespec t;\n\n\tt.tv_sec = when;\n\tt.tv_nsec = 0;\n\tptimeout_deadline_monotime_tsp(pt, &t);\n}\n\n \nint\nptimeout_get_ms(struct timespec *pt)\n{\n\tif (pt->tv_sec == -1)\n\t\treturn -1;\n\tif (pt->tv_sec >= (INT_MAX - (pt->tv_nsec / 1000000)) / 1000)\n\t\treturn INT_MAX;\n\treturn (pt->tv_sec * 1000) + (pt->tv_nsec / 1000000);\n}\n\n \nstruct timespec *\nptimeout_get_tsp(struct timespec *pt)\n{\n\treturn pt->tv_sec == -1 ? NULL : pt;\n}\n\n \nint\nptimeout_isset(struct timespec *pt)\n{\n\treturn pt->tv_sec != -1;\n}\n\n \nint\nlib_contains_symbol(const char *path, const char *s)\n{\n#ifdef HAVE_NLIST_H\n\tstruct nlist nl[2];\n\tint ret = -1, r;\n\n\tmemset(nl, 0, sizeof(nl));\n\tnl[0].n_name = xstrdup(s);\n\tnl[1].n_name = NULL;\n\tif ((r = nlist(path, nl)) == -1) {\n\t\terror_f(\"nlist failed for %s\", path);\n\t\tgoto out;\n\t}\n\tif (r != 0 || nl[0].n_value == 0 || nl[0].n_type == 0) {\n\t\terror_f(\"library %s does not contain symbol %s\", path, s);\n\t\tgoto out;\n\t}\n\t \n\tret = 0;\n out:\n\tfree(nl[0].n_name);\n\treturn ret;\n#else  \n\tint fd, ret = -1;\n\tstruct stat st;\n\tvoid *m = NULL;\n\tsize_t sz = 0;\n\n\tmemset(&st, 0, sizeof(st));\n\tif ((fd = open(path, O_RDONLY)) < 0) {\n\t\terror_f(\"open %s: %s\", path, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fstat(fd, &st) != 0) {\n\t\terror_f(\"fstat %s: %s\", path, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\terror_f(\"%s is not a regular file\", path);\n\t\tgoto out;\n\t}\n\tif (st.st_size < 0 ||\n\t    (size_t)st.st_size < strlen(s) ||\n\t    st.st_size >= INT_MAX/2) {\n\t\terror_f(\"%s bad size %lld\", path, (long long)st.st_size);\n\t\tgoto out;\n\t}\n\tsz = (size_t)st.st_size;\n\tif ((m = mmap(NULL, sz, PROT_READ, MAP_PRIVATE, fd, 0)) == MAP_FAILED ||\n\t    m == NULL) {\n\t\terror_f(\"mmap %s: %s\", path, strerror(errno));\n\t\tgoto out;\n\t}\n\tif (memmem(m, sz, s, strlen(s)) == NULL) {\n\t\terror_f(\"%s does not contain expected string %s\", path, s);\n\t\tgoto out;\n\t}\n\t \n\tret = 0;\n out:\n\tif (m != NULL && m != MAP_FAILED)\n\t\tmunmap(m, sz);\n\tclose(fd);\n\treturn ret;\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}