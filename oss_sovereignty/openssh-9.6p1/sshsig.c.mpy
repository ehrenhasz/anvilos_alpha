{
  "module_name": "sshsig.c",
  "hash_id": "2ac72845471c9bb4ee55c3f0bfc775d2a29500e4306f3f87d7b075d567525f8b",
  "original_prompt": "Ingested from openssh-9.6p1/sshsig.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"authfd.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"sshsig.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"digest.h\"\n\n#define SIG_VERSION\t\t0x01\n#define MAGIC_PREAMBLE\t\t\"SSHSIG\"\n#define MAGIC_PREAMBLE_LEN\t(sizeof(MAGIC_PREAMBLE) - 1)\n#define BEGIN_SIGNATURE\t\t\"-----BEGIN SSH SIGNATURE-----\"\n#define END_SIGNATURE\t\t\"-----END SSH SIGNATURE-----\"\n#define RSA_SIGN_ALG\t\t\"rsa-sha2-512\"  \n#define RSA_SIGN_ALLOWED\t\"rsa-sha2-512,rsa-sha2-256\"\n#define HASHALG_DEFAULT\t\t\"sha512\"  \n#define HASHALG_ALLOWED\t\t\"sha256,sha512\"\n\nint\nsshsig_armor(const struct sshbuf *blob, struct sshbuf **out)\n{\n\tstruct sshbuf *buf = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*out = NULL;\n\n\tif ((buf = sshbuf_new()) == NULL) {\n\t\terror_f(\"sshbuf_new failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_putf(buf, \"%s\\n\", BEGIN_SIGNATURE)) != 0) {\n\t\terror_fr(r, \"sshbuf_putf\");\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_dtob64(blob, buf, 1)) != 0) {\n\t\terror_fr(r, \"base64 encode signature\");\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_put(buf, END_SIGNATURE,\n\t    sizeof(END_SIGNATURE)-1)) != 0 ||\n\t    (r = sshbuf_put_u8(buf, '\\n')) != 0) {\n\t\terror_fr(r, \"sshbuf_put\");\n\t\tgoto out;\n\t}\n\t \n\t*out = buf;\n\tbuf = NULL;  \n\tr = 0;\n out:\n\tsshbuf_free(buf);\n\treturn r;\n}\n\nint\nsshsig_dearmor(struct sshbuf *sig, struct sshbuf **out)\n{\n\tint r;\n\tsize_t eoffset = 0;\n\tstruct sshbuf *buf = NULL;\n\tstruct sshbuf *sbuf = NULL;\n\tchar *b64 = NULL;\n\n\tif ((sbuf = sshbuf_fromb(sig)) == NULL) {\n\t\terror_f(\"sshbuf_fromb failed\");\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\n\t \n\tif ((r = sshbuf_cmp(sbuf, 0,\n\t    BEGIN_SIGNATURE, sizeof(BEGIN_SIGNATURE)-1)) != 0) {\n\t\terror(\"Couldn't parse signature: missing header\");\n\t\tgoto done;\n\t}\n\tif ((r = sshbuf_consume(sbuf, sizeof(BEGIN_SIGNATURE)-1)) != 0) {\n\t\terror_fr(r, \"consume\");\n\t\tgoto done;\n\t}\n\tif ((r = sshbuf_cmp(sbuf, 0, \"\\r\\n\", 2)) == 0)\n\t\teoffset = 2;\n\telse if ((r = sshbuf_cmp(sbuf, 0, \"\\n\", 1)) == 0)\n\t\teoffset = 1;\n\telse {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\terror_f(\"no header eol\");\n\t\tgoto done;\n\t}\n\tif ((r = sshbuf_consume(sbuf, eoffset)) != 0) {\n\t\terror_fr(r, \"consume eol\");\n\t\tgoto done;\n\t}\n\t \n\tif ((r = sshbuf_find(sbuf, 0, \"\\n\" END_SIGNATURE,\n\t    sizeof(END_SIGNATURE), &eoffset)) != 0) {\n\t\terror(\"Couldn't parse signature: missing footer\");\n\t\tgoto done;\n\t}\n\tif ((r = sshbuf_consume_end(sbuf, sshbuf_len(sbuf)-eoffset)) != 0) {\n\t\terror_fr(r, \"consume\");\n\t\tgoto done;\n\t}\n\n\tif ((b64 = sshbuf_dup_string(sbuf)) == NULL) {\n\t\terror_f(\"sshbuf_dup_string failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\n\tif ((buf = sshbuf_new()) == NULL) {\n\t\terror_f(\"sshbuf_new() failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\n\tif ((r = sshbuf_b64tod(buf, b64)) != 0) {\n\t\terror_fr(r, \"decode base64\");\n\t\tgoto done;\n\t}\n\n\t \n\t*out = buf;\n\tr = 0;\n\tbuf = NULL;  \ndone:\n\tsshbuf_free(buf);\n\tsshbuf_free(sbuf);\n\tfree(b64);\n\treturn r;\n}\n\nstatic int\nsshsig_wrap_sign(struct sshkey *key, const char *hashalg,\n    const char *sk_provider, const char *sk_pin, const struct sshbuf *h_message,\n    const char *sig_namespace, struct sshbuf **out,\n    sshsig_signer *signer, void *signer_ctx)\n{\n\tint r;\n\tsize_t slen = 0;\n\tu_char *sig = NULL;\n\tstruct sshbuf *blob = NULL;\n\tstruct sshbuf *tosign = NULL;\n\tconst char *sign_alg = NULL;\n\n\tif ((tosign = sshbuf_new()) == NULL ||\n\t    (blob = sshbuf_new()) == NULL) {\n\t\terror_f(\"sshbuf_new failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\n\tif ((r = sshbuf_put(tosign, MAGIC_PREAMBLE, MAGIC_PREAMBLE_LEN)) != 0 ||\n\t    (r = sshbuf_put_cstring(tosign, sig_namespace)) != 0 ||\n\t    (r = sshbuf_put_string(tosign, NULL, 0)) != 0 ||  \n\t    (r = sshbuf_put_cstring(tosign, hashalg)) != 0 ||\n\t    (r = sshbuf_put_stringb(tosign, h_message)) != 0) {\n\t\terror_fr(r, \"assemble message to sign\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (sshkey_type_plain(key->type) == KEY_RSA)\n\t\tsign_alg = RSA_SIGN_ALG;\n\n\tif (signer != NULL) {\n\t\tif ((r = signer(key, &sig, &slen,\n\t\t    sshbuf_ptr(tosign), sshbuf_len(tosign),\n\t\t    sign_alg, sk_provider, sk_pin, 0, signer_ctx)) != 0) {\n\t\t\terror_r(r, \"Couldn't sign message (signer)\");\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tif ((r = sshkey_sign(key, &sig, &slen,\n\t\t    sshbuf_ptr(tosign), sshbuf_len(tosign),\n\t\t    sign_alg, sk_provider, sk_pin, 0)) != 0) {\n\t\t\terror_r(r, \"Couldn't sign message\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif ((r = sshbuf_put(blob, MAGIC_PREAMBLE, MAGIC_PREAMBLE_LEN)) != 0 ||\n\t    (r = sshbuf_put_u32(blob, SIG_VERSION)) != 0 ||\n\t    (r = sshkey_puts(key, blob)) != 0 ||\n\t    (r = sshbuf_put_cstring(blob, sig_namespace)) != 0 ||\n\t    (r = sshbuf_put_string(blob, NULL, 0)) != 0 ||  \n\t    (r = sshbuf_put_cstring(blob, hashalg)) != 0 ||\n\t    (r = sshbuf_put_string(blob, sig, slen)) != 0) {\n\t\terror_fr(r, \"assemble signature object\");\n\t\tgoto done;\n\t}\n\n\tif (out != NULL) {\n\t\t*out = blob;\n\t\tblob = NULL;\n\t}\n\tr = 0;\ndone:\n\tfree(sig);\n\tsshbuf_free(blob);\n\tsshbuf_free(tosign);\n\treturn r;\n}\n\n \nstatic int\nsshsig_parse_preamble(struct sshbuf *buf)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tuint32_t sversion;\n\n\tif ((r = sshbuf_cmp(buf, 0, MAGIC_PREAMBLE, MAGIC_PREAMBLE_LEN)) != 0 ||\n\t    (r = sshbuf_consume(buf, (sizeof(MAGIC_PREAMBLE)-1))) != 0 ||\n\t    (r = sshbuf_get_u32(buf, &sversion)) != 0) {\n\t\terror(\"Couldn't verify signature: invalid format\");\n\t\treturn r;\n\t}\n\n\tif (sversion > SIG_VERSION) {\n\t\terror(\"Signature version %lu is larger than supported \"\n\t\t    \"version %u\", (unsigned long)sversion, SIG_VERSION);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\treturn 0;\n}\n\nstatic int\nsshsig_check_hashalg(const char *hashalg)\n{\n\tif (hashalg == NULL ||\n\t    match_pattern_list(hashalg, HASHALG_ALLOWED, 0) == 1)\n\t\treturn 0;\n\terror_f(\"unsupported hash algorithm \\\"%.100s\\\"\", hashalg);\n\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}\n\nstatic int\nsshsig_peek_hashalg(struct sshbuf *signature, char **hashalgp)\n{\n\tstruct sshbuf *buf = NULL;\n\tchar *hashalg = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (hashalgp != NULL)\n\t\t*hashalgp = NULL;\n\tif ((buf = sshbuf_fromb(signature)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshsig_parse_preamble(buf)) != 0)\n\t\tgoto done;\n\tif ((r = sshbuf_get_string_direct(buf, NULL, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(buf, NULL, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(buf, NULL, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(buf, &hashalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(buf, NULL, NULL)) != 0) {\n\t\terror_fr(r, \"parse signature object\");\n\t\tgoto done;\n\t}\n\n\t \n\tr = 0;\n\t*hashalgp = hashalg;\n\thashalg = NULL;\n done:\n\tfree(hashalg);\n\tsshbuf_free(buf);\n\treturn r;\n}\n\nstatic int\nsshsig_wrap_verify(struct sshbuf *signature, const char *hashalg,\n    const struct sshbuf *h_message, const char *expect_namespace,\n    struct sshkey **sign_keyp, struct sshkey_sig_details **sig_details)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *buf = NULL, *toverify = NULL;\n\tstruct sshkey *key = NULL;\n\tconst u_char *sig;\n\tchar *got_namespace = NULL, *sigtype = NULL, *sig_hashalg = NULL;\n\tsize_t siglen;\n\n\tdebug_f(\"verify message length %zu\", sshbuf_len(h_message));\n\tif (sig_details != NULL)\n\t\t*sig_details = NULL;\n\tif (sign_keyp != NULL)\n\t\t*sign_keyp = NULL;\n\n\tif ((toverify = sshbuf_new()) == NULL) {\n\t\terror_f(\"sshbuf_new failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((r = sshbuf_put(toverify, MAGIC_PREAMBLE,\n\t    MAGIC_PREAMBLE_LEN)) != 0 ||\n\t    (r = sshbuf_put_cstring(toverify, expect_namespace)) != 0 ||\n\t    (r = sshbuf_put_string(toverify, NULL, 0)) != 0 ||  \n\t    (r = sshbuf_put_cstring(toverify, hashalg)) != 0 ||\n\t    (r = sshbuf_put_stringb(toverify, h_message)) != 0) {\n\t\terror_fr(r, \"assemble message to verify\");\n\t\tgoto done;\n\t}\n\n\tif ((r = sshsig_parse_preamble(signature)) != 0)\n\t\tgoto done;\n\n\tif ((r = sshkey_froms(signature, &key)) != 0 ||\n\t    (r = sshbuf_get_cstring(signature, &got_namespace, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(signature, NULL, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(signature, &sig_hashalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(signature, &sig, &siglen)) != 0) {\n\t\terror_fr(r, \"parse signature object\");\n\t\tgoto done;\n\t}\n\n\tif (sshbuf_len(signature) != 0) {\n\t\terror(\"Signature contains trailing data\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto done;\n\t}\n\n\tif (strcmp(expect_namespace, got_namespace) != 0) {\n\t\terror(\"Couldn't verify signature: namespace does not match\");\n\t\tdebug_f(\"expected namespace \\\"%s\\\" received \\\"%s\\\"\",\n\t\t    expect_namespace, got_namespace);\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto done;\n\t}\n\tif (strcmp(hashalg, sig_hashalg) != 0) {\n\t\terror(\"Couldn't verify signature: hash algorithm mismatch\");\n\t\tdebug_f(\"expected algorithm \\\"%s\\\" received \\\"%s\\\"\",\n\t\t    hashalg, sig_hashalg);\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto done;\n\t}\n\t \n\tif (sshkey_type_plain(key->type) == KEY_RSA) {\n\t\tif ((r = sshkey_get_sigtype(sig, siglen, &sigtype)) != 0) {\n\t\t\terror_r(r, \"Couldn't verify signature: unable to get \"\n\t\t\t    \"signature type\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (match_pattern_list(sigtype, RSA_SIGN_ALLOWED, 0) != 1) {\n\t\t\terror(\"Couldn't verify signature: unsupported RSA \"\n\t\t\t    \"signature algorithm %s\", sigtype);\n\t\t\tr = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif ((r = sshkey_verify(key, sig, siglen, sshbuf_ptr(toverify),\n\t    sshbuf_len(toverify), NULL, 0, sig_details)) != 0) {\n\t\terror_r(r, \"Signature verification failed\");\n\t\tgoto done;\n\t}\n\n\t \n\tr = 0;\n\tif (sign_keyp != NULL) {\n\t\t*sign_keyp = key;\n\t\tkey = NULL;  \n\t}\ndone:\n\tfree(got_namespace);\n\tfree(sigtype);\n\tfree(sig_hashalg);\n\tsshbuf_free(buf);\n\tsshbuf_free(toverify);\n\tsshkey_free(key);\n\treturn r;\n}\n\nstatic int\nhash_buffer(const struct sshbuf *m, const char *hashalg, struct sshbuf **bp)\n{\n\tchar *hex, hash[SSH_DIGEST_MAX_LENGTH];\n\tint alg, r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\n\t*bp = NULL;\n\tmemset(hash, 0, sizeof(hash));\n\n\tif ((r = sshsig_check_hashalg(hashalg)) != 0)\n\t\treturn r;\n\tif ((alg = ssh_digest_alg_by_name(hashalg)) == -1) {\n\t\terror_f(\"can't look up hash algorithm %s\", hashalg);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif ((r = ssh_digest_buffer(alg, m, hash, sizeof(hash))) != 0) {\n\t\terror_fr(r, \"ssh_digest_buffer\");\n\t\treturn r;\n\t}\n\tif ((hex = tohex(hash, ssh_digest_bytes(alg))) != NULL) {\n\t\tdebug3_f(\"final hash: %s\", hex);\n\t\tfreezero(hex, strlen(hex));\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(b, hash, ssh_digest_bytes(alg))) != 0) {\n\t\terror_fr(r, \"sshbuf_put\");\n\t\tgoto out;\n\t}\n\t*bp = b;\n\tb = NULL;  \n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\texplicit_bzero(hash, sizeof(hash));\n\treturn r;\n}\n\nint\nsshsig_signb(struct sshkey *key, const char *hashalg,\n    const char *sk_provider, const char *sk_pin,\n    const struct sshbuf *message, const char *sig_namespace,\n    struct sshbuf **out, sshsig_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (hashalg == NULL)\n\t\thashalg = HASHALG_DEFAULT;\n\tif (out != NULL)\n\t\t*out = NULL;\n\tif ((r = hash_buffer(message, hashalg, &b)) != 0) {\n\t\terror_fr(r, \"hash buffer\");\n\t\tgoto out;\n\t}\n\tif ((r = sshsig_wrap_sign(key, hashalg, sk_provider, sk_pin, b,\n\t    sig_namespace, out, signer, signer_ctx)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\nint\nsshsig_verifyb(struct sshbuf *signature, const struct sshbuf *message,\n    const char *expect_namespace, struct sshkey **sign_keyp,\n    struct sshkey_sig_details **sig_details)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *hashalg = NULL;\n\n\tif (sig_details != NULL)\n\t\t*sig_details = NULL;\n\tif (sign_keyp != NULL)\n\t\t*sign_keyp = NULL;\n\tif ((r = sshsig_peek_hashalg(signature, &hashalg)) != 0)\n\t\treturn r;\n\tdebug_f(\"signature made with hash \\\"%s\\\"\", hashalg);\n\tif ((r = hash_buffer(message, hashalg, &b)) != 0) {\n\t\terror_fr(r, \"hash buffer\");\n\t\tgoto out;\n\t}\n\tif ((r = sshsig_wrap_verify(signature, hashalg, b, expect_namespace,\n\t    sign_keyp, sig_details)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(hashalg);\n\treturn r;\n}\n\nstatic int\nhash_file(int fd, const char *hashalg, struct sshbuf **bp)\n{\n\tchar *hex, rbuf[8192], hash[SSH_DIGEST_MAX_LENGTH];\n\tssize_t n, total = 0;\n\tstruct ssh_digest_ctx *ctx = NULL;\n\tint alg, oerrno, r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\n\t*bp = NULL;\n\tmemset(hash, 0, sizeof(hash));\n\n\tif ((r = sshsig_check_hashalg(hashalg)) != 0)\n\t\treturn r;\n\tif ((alg = ssh_digest_alg_by_name(hashalg)) == -1) {\n\t\terror_f(\"can't look up hash algorithm %s\", hashalg);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif ((ctx = ssh_digest_start(alg)) == NULL) {\n\t\terror_f(\"ssh_digest_start failed\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tfor (;;) {\n\t\tif ((n = read(fd, rbuf, sizeof(rbuf))) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\toerrno = errno;\n\t\t\terror_f(\"read: %s\", strerror(errno));\n\t\t\terrno = oerrno;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t} else if (n == 0) {\n\t\t\tdebug2_f(\"hashed %zu bytes\", total);\n\t\t\tbreak;  \n\t\t}\n\t\ttotal += (size_t)n;\n\t\tif ((r = ssh_digest_update(ctx, rbuf, (size_t)n)) != 0) {\n\t\t\terror_fr(r, \"ssh_digest_update\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = ssh_digest_final(ctx, hash, sizeof(hash))) != 0) {\n\t\terror_fr(r, \"ssh_digest_final\");\n\t\tgoto out;\n\t}\n\tif ((hex = tohex(hash, ssh_digest_bytes(alg))) != NULL) {\n\t\tdebug3_f(\"final hash: %s\", hex);\n\t\tfreezero(hex, strlen(hex));\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(b, hash, ssh_digest_bytes(alg))) != 0) {\n\t\terror_fr(r, \"sshbuf_put\");\n\t\tgoto out;\n\t}\n\t*bp = b;\n\tb = NULL;  \n\t \n\tr = 0;\n out:\n\toerrno = errno;\n\tsshbuf_free(b);\n\tssh_digest_free(ctx);\n\texplicit_bzero(hash, sizeof(hash));\n\terrno = oerrno;\n\treturn r;\n}\n\nint\nsshsig_sign_fd(struct sshkey *key, const char *hashalg,\n    const char *sk_provider, const char *sk_pin,\n    int fd, const char *sig_namespace, struct sshbuf **out,\n    sshsig_signer *signer, void *signer_ctx)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (hashalg == NULL)\n\t\thashalg = HASHALG_DEFAULT;\n\tif (out != NULL)\n\t\t*out = NULL;\n\tif ((r = hash_file(fd, hashalg, &b)) != 0) {\n\t\terror_fr(r, \"hash_file\");\n\t\treturn r;\n\t}\n\tif ((r = sshsig_wrap_sign(key, hashalg, sk_provider, sk_pin, b,\n\t    sig_namespace, out, signer, signer_ctx)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\nint\nsshsig_verify_fd(struct sshbuf *signature, int fd,\n    const char *expect_namespace, struct sshkey **sign_keyp,\n    struct sshkey_sig_details **sig_details)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *hashalg = NULL;\n\n\tif (sig_details != NULL)\n\t\t*sig_details = NULL;\n\tif (sign_keyp != NULL)\n\t\t*sign_keyp = NULL;\n\tif ((r = sshsig_peek_hashalg(signature, &hashalg)) != 0)\n\t\treturn r;\n\tdebug_f(\"signature made with hash \\\"%s\\\"\", hashalg);\n\tif ((r = hash_file(fd, hashalg, &b)) != 0) {\n\t\terror_fr(r, \"hash_file\");\n\t\tgoto out;\n\t}\n\tif ((r = sshsig_wrap_verify(signature, hashalg, b, expect_namespace,\n\t    sign_keyp, sig_details)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(hashalg);\n\treturn r;\n}\n\nstruct sshsigopt {\n\tint ca;\n\tchar *namespaces;\n\tuint64_t valid_after, valid_before;\n};\n\nstruct sshsigopt *\nsshsigopt_parse(const char *opts, const char *path, u_long linenum,\n    const char **errstrp)\n{\n\tstruct sshsigopt *ret;\n\tint r;\n\tchar *opt;\n\tconst char *errstr = NULL;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif (opts == NULL || *opts == '\\0')\n\t\treturn ret;  \n\n\twhile (*opts && *opts != ' ' && *opts != '\\t') {\n\t\t \n\t\tif ((r = opt_flag(\"cert-authority\", 0, &opts)) != -1) {\n\t\t\tret->ca = 1;\n\t\t} else if (opt_match(&opts, \"namespaces\")) {\n\t\t\tif (ret->namespaces != NULL) {\n\t\t\t\terrstr = \"multiple \\\"namespaces\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tret->namespaces = opt_dequote(&opts, &errstr);\n\t\t\tif (ret->namespaces == NULL)\n\t\t\t\tgoto fail;\n\t\t} else if (opt_match(&opts, \"valid-after\")) {\n\t\t\tif (ret->valid_after != 0) {\n\t\t\t\terrstr = \"multiple \\\"valid-after\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &ret->valid_after) != 0 ||\n\t\t\t    ret->valid_after == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid \\\"valid-after\\\" time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t} else if (opt_match(&opts, \"valid-before\")) {\n\t\t\tif (ret->valid_before != 0) {\n\t\t\t\terrstr = \"multiple \\\"valid-before\\\" clauses\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif ((opt = opt_dequote(&opts, &errstr)) == NULL)\n\t\t\t\tgoto fail;\n\t\t\tif (parse_absolute_time(opt, &ret->valid_before) != 0 ||\n\t\t\t    ret->valid_before == 0) {\n\t\t\t\tfree(opt);\n\t\t\t\terrstr = \"invalid \\\"valid-before\\\" time\";\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(opt);\n\t\t}\n\t\t \n\t\tif (*opts == '\\0' || *opts == ' ' || *opts == '\\t')\n\t\t\tbreak;\t\t \n\t\t \n\t\tif (*opts != ',') {\n\t\t\terrstr = \"unknown key option\";\n\t\t\tgoto fail;\n\t\t}\n\t\topts++;\n\t\tif (*opts == '\\0') {\n\t\t\terrstr = \"unexpected end-of-options\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t \n\tif (ret->valid_after != 0 && ret->valid_before != 0 &&\n\t    ret->valid_before <= ret->valid_after) {\n\t\terrstr = \"\\\"valid-before\\\" time is before \\\"valid-after\\\"\";\n\t\tgoto fail;\n\t}\n\t \n\treturn ret;\n fail:\n\tif (errstrp != NULL)\n\t\t*errstrp = errstr;\n\tsshsigopt_free(ret);\n\treturn NULL;\n}\n\nvoid\nsshsigopt_free(struct sshsigopt *opts)\n{\n\tif (opts == NULL)\n\t\treturn;\n\tfree(opts->namespaces);\n\tfree(opts);\n}\n\nstatic int\nparse_principals_key_and_options(const char *path, u_long linenum, char *line,\n    const char *required_principal, char **principalsp, struct sshkey **keyp,\n    struct sshsigopt **sigoptsp)\n{\n\tchar *opts = NULL, *tmp, *cp, *principals = NULL;\n\tconst char *reason = NULL;\n\tstruct sshsigopt *sigopts = NULL;\n\tstruct sshkey *key = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (principalsp != NULL)\n\t\t*principalsp = NULL;\n\tif (sigoptsp != NULL)\n\t\t*sigoptsp = NULL;\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tcp = line;\n\tcp = cp + strspn(cp, \" \\t\");  \n\tif (*cp == '#' || *cp == '\\0')\n\t\treturn SSH_ERR_KEY_NOT_FOUND;  \n\n\t \n\tif ((tmp = strdelimw(&cp)) == NULL || cp == NULL) {\n\t\terror(\"%s:%lu: invalid line\", path, linenum);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((principals = strdup(tmp)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t \n\tif (required_principal != NULL) {\n\t\tif (match_pattern_list(required_principal,\n\t\t    principals, 0) != 1) {\n\t\t\t \n\t\t\tr = SSH_ERR_KEY_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug_f(\"%s:%lu: matched principal \\\"%s\\\"\",\n\t\t    path, linenum, required_principal);\n\t}\n\n\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\terror_f(\"sshkey_new failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshkey_read(key, &cp) != 0) {\n\t\t \n\t\topts = cp;\n\t\tif (sshkey_advance_past_options(&cp) != 0) {\n\t\t\terror(\"%s:%lu: invalid options\", path, linenum);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cp == NULL || *cp == '\\0') {\n\t\t\terror(\"%s:%lu: missing key\", path, linenum);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t*cp++ = '\\0';\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(key, &cp) != 0) {\n\t\t\terror(\"%s:%lu: invalid key\", path, linenum);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdebug3(\"%s:%lu: options %s\", path, linenum, opts == NULL ? \"\" : opts);\n\tif ((sigopts = sshsigopt_parse(opts, path, linenum, &reason)) == NULL) {\n\t\terror(\"%s:%lu: bad options: %s\", path, linenum, reason);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tif (principalsp != NULL) {\n\t\t*principalsp = principals;\n\t\tprincipals = NULL;  \n\t}\n\tif (sigoptsp != NULL) {\n\t\t*sigoptsp = sigopts;\n\t\tsigopts = NULL;  \n\t}\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;  \n\t}\n\tr = 0;\n out:\n\tfree(principals);\n\tsshsigopt_free(sigopts);\n\tsshkey_free(key);\n\treturn r;\n}\n\nstatic int\ncert_filter_principals(const char *path, u_long linenum,\n    char **principalsp, const struct sshkey *cert, uint64_t verify_time)\n{\n\tchar *cp, *oprincipals, *principals;\n\tconst char *reason;\n\tstruct sshbuf *nprincipals;\n\tint r = SSH_ERR_INTERNAL_ERROR, success = 0;\n\tu_int i;\n\n\toprincipals = principals = *principalsp;\n\t*principalsp = NULL;\n\n\tif ((nprincipals = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\twhile ((cp = strsep(&principals, \",\")) != NULL && *cp != '\\0') {\n\t\t \n\t\tif ((r = sshkey_cert_check_authority(cert, 0, 1, 0,\n\t\t    verify_time, NULL, &reason)) != 0) {\n\t\t\tdebug(\"%s:%lu: principal \\\"%s\\\" not authorized: %s\",\n\t\t\t    path, linenum, cp, reason);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < cert->cert->nprincipals; i++) {\n\t\t\tif (match_pattern(cert->cert->principals[i], cp)) {\n\t\t\t\tif ((r = sshbuf_putf(nprincipals, \"%s%s\",\n\t\t\t\t\tsshbuf_len(nprincipals) != 0 ? \",\" : \"\",\n\t\t\t\t\t\tcert->cert->principals[i])) != 0) {\n\t\t\t\t\terror_f(\"buffer error\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (sshbuf_len(nprincipals) == 0) {\n\t\terror(\"%s:%lu: no valid principals found\", path, linenum);\n\t\tr = SSH_ERR_KEY_CERT_INVALID;\n\t\tgoto out;\n\t}\n\tif ((principals = sshbuf_dup_string(nprincipals)) == NULL) {\n\t\terror_f(\"buffer error\");\n\t\tgoto out;\n\t}\n\t \n\tsuccess = 1;\n\t*principalsp = principals;\n out:\n\tsshbuf_free(nprincipals);\n\tfree(oprincipals);\n\treturn success ? 0 : r;\n}\n\nstatic int\ncheck_allowed_keys_line(const char *path, u_long linenum, char *line,\n    const struct sshkey *sign_key, const char *principal,\n    const char *sig_namespace, uint64_t verify_time, char **principalsp)\n{\n\tstruct sshkey *found_key = NULL;\n\tchar *principals = NULL;\n\tint r, success = 0;\n\tconst char *reason = NULL;\n\tstruct sshsigopt *sigopts = NULL;\n\tchar tvalid[64], tverify[64];\n\n\tif (principalsp != NULL)\n\t\t*principalsp = NULL;\n\n\t \n\tif ((r = parse_principals_key_and_options(path, linenum, line,\n\t    principal, &principals, &found_key, &sigopts)) != 0) {\n\t\t \n\t\tgoto done;\n\t}\n\n\tif (!sigopts->ca && sshkey_equal(found_key, sign_key)) {\n\t\t \n\t\tdebug(\"%s:%lu: matched key\", path, linenum);\n\t} else if (sigopts->ca && sshkey_is_cert(sign_key) &&\n\t    sshkey_equal_public(sign_key->cert->signature_key, found_key)) {\n\t\tif (principal) {\n\t\t\t \n\t\t\tif ((r = sshkey_cert_check_authority(sign_key, 0, 1, 0,\n\t\t\t    verify_time, principal, &reason)) != 0) {\n\t\t\t\terror(\"%s:%lu: certificate not authorized: %s\",\n\t\t\t\t    path, linenum, reason);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdebug(\"%s:%lu: matched certificate CA key\",\n\t\t\t    path, linenum);\n\t\t} else {\n\t\t\t \n\t\t\tif ((r = cert_filter_principals(path, linenum,\n\t\t\t    &principals, sign_key, verify_time)) != 0) {\n\t\t\t\t \n\t\t\t\tdebug_r(r, \"%s:%lu: cert_filter_principals\",\n\t\t\t\t    path, linenum);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdebug(\"%s:%lu: matched certificate CA key\",\n\t\t\t    path, linenum);\n\t\t}\n\t} else {\n\t\t \n\t\tgoto done;\n\t}\n\n\t \n\tif (sigopts->namespaces != NULL && sig_namespace != NULL &&\n\t    match_pattern_list(sig_namespace, sigopts->namespaces, 0) != 1) {\n\t\terror(\"%s:%lu: key is not permitted for use in signature \"\n\t\t    \"namespace \\\"%s\\\"\", path, linenum, sig_namespace);\n\t\tgoto done;\n\t}\n\n\t \n\tformat_absolute_time((uint64_t)verify_time, tverify, sizeof(tverify));\n\tif (sigopts->valid_after != 0 &&\n\t    (uint64_t)verify_time < sigopts->valid_after) {\n\t\tformat_absolute_time(sigopts->valid_after,\n\t\t    tvalid, sizeof(tvalid));\n\t\terror(\"%s:%lu: key is not yet valid: \"\n\t\t    \"verify time %s < valid-after %s\", path, linenum,\n\t\t    tverify, tvalid);\n\t\tgoto done;\n\t}\n\tif (sigopts->valid_before != 0 &&\n\t    (uint64_t)verify_time > sigopts->valid_before) {\n\t\tformat_absolute_time(sigopts->valid_before,\n\t\t    tvalid, sizeof(tvalid));\n\t\terror(\"%s:%lu: key has expired: \"\n\t\t    \"verify time %s > valid-before %s\", path, linenum,\n\t\t    tverify, tvalid);\n\t\tgoto done;\n\t}\n\tsuccess = 1;\n\n done:\n\tif (success && principalsp != NULL) {\n\t\t*principalsp = principals;\n\t\tprincipals = NULL;  \n\t}\n\tfree(principals);\n\tsshkey_free(found_key);\n\tsshsigopt_free(sigopts);\n\treturn success ? 0 : SSH_ERR_KEY_NOT_FOUND;\n}\n\nint\nsshsig_check_allowed_keys(const char *path, const struct sshkey *sign_key,\n    const char *principal, const char *sig_namespace, uint64_t verify_time)\n{\n\tFILE *f = NULL;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tint r = SSH_ERR_KEY_NOT_FOUND, oerrno;\n\n\t \n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\toerrno = errno;\n\t\terror(\"Unable to open allowed keys file \\\"%s\\\": %s\",\n\t\t    path, strerror(errno));\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tr = check_allowed_keys_line(path, linenum, line, sign_key,\n\t\t    principal, sig_namespace, verify_time, NULL);\n\t\tfree(line);\n\t\tline = NULL;\n\t\tlinesize = 0;\n\t\tif (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tcontinue;\n\t\telse if (r == 0) {\n\t\t\t \n\t\t\tfclose(f);\n\t\t\treturn 0;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t \n\tfclose(f);\n\tfree(line);\n\treturn r;\n}\n\nint\nsshsig_find_principals(const char *path, const struct sshkey *sign_key,\n    uint64_t verify_time, char **principals)\n{\n\tFILE *f = NULL;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tu_long linenum = 0;\n\tint r = SSH_ERR_KEY_NOT_FOUND, oerrno;\n\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\toerrno = errno;\n\t\terror(\"Unable to open allowed keys file \\\"%s\\\": %s\",\n\t\t    path, strerror(errno));\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tr = check_allowed_keys_line(path, linenum, line,\n\t\t    sign_key, NULL, NULL, verify_time, principals);\n\t\tfree(line);\n\t\tline = NULL;\n\t\tlinesize = 0;\n\t\tif (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tcontinue;\n\t\telse if (r == 0) {\n\t\t\t \n\t\t\tfclose(f);\n\t\t\treturn 0;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tfree(line);\n\t \n\tif (ferror(f) != 0) {\n\t\toerrno = errno;\n\t\tfclose(f);\n\t\terror(\"Unable to read allowed keys file \\\"%s\\\": %s\",\n\t\t    path, strerror(errno));\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tfclose(f);\n\treturn r;\n}\n\nint\nsshsig_match_principals(const char *path, const char *principal,\n    char ***principalsp, size_t *nprincipalsp)\n{\n\tFILE *f = NULL;\n\tchar *found, *line = NULL, **principals = NULL, **tmp;\n\tsize_t i, nprincipals = 0, linesize = 0;\n\tu_long linenum = 0;\n\tint oerrno = 0, r, ret = 0;\n\n\tif (principalsp != NULL)\n\t\t*principalsp = NULL;\n\tif (nprincipalsp != NULL)\n\t\t*nprincipalsp = 0;\n\n\t \n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\toerrno = errno;\n\t\terror(\"Unable to open allowed keys file \\\"%s\\\": %s\",\n\t\t    path, strerror(errno));\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t \n\t\tif ((r = parse_principals_key_and_options(path, linenum, line,\n\t\t    principal, &found, NULL, NULL)) != 0) {\n\t\t\tif (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\t\tcontinue;\n\t\t\tret = r;\n\t\t\toerrno = errno;\n\t\t\tbreak;  \n\t\t}\n\t\tif ((tmp = recallocarray(principals, nprincipals,\n\t\t    nprincipals + 1, sizeof(*principals))) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tfree(found);\n\t\t\tbreak;\n\t\t}\n\t\tprincipals = tmp;\n\t\tprincipals[nprincipals++] = found;  \n\t\tfree(line);\n\t\tline = NULL;\n\t\tlinesize = 0;\n\t}\n\tfclose(f);\n\n\tif (ret == 0) {\n\t\tif (nprincipals == 0)\n\t\t\tret = SSH_ERR_KEY_NOT_FOUND;\n\t\tif (nprincipalsp != 0)\n\t\t\t*nprincipalsp = nprincipals;\n\t\tif (principalsp != NULL) {\n\t\t\t*principalsp = principals;\n\t\t\tprincipals = NULL;  \n\t\t\tnprincipals = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nprincipals; i++)\n\t\tfree(principals[i]);\n\tfree(principals);\n\n\terrno = oerrno;\n\treturn ret;\n}\n\nint\nsshsig_get_pubkey(struct sshbuf *signature, struct sshkey **pubkey)\n{\n\tstruct sshkey *pk = NULL;\n\tint r = SSH_ERR_SIGNATURE_INVALID;\n\n\tif (pubkey == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((r = sshsig_parse_preamble(signature)) != 0)\n\t\treturn r;\n\tif ((r = sshkey_froms(signature, &pk)) != 0)\n\t\treturn r;\n\n\t*pubkey = pk;\n\tpk = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}