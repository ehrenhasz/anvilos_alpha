{
  "module_name": "readpass.c",
  "hash_id": "5877102200b315e1182a5c31d0e4cbd95f2cdeb51f6577c88487140fbd76d147",
  "original_prompt": "Ingested from openssh-9.6p1/readpass.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"uidswap.h\"\n\nstatic char *\nssh_askpass(char *askpass, const char *msg, const char *env_hint)\n{\n\tpid_t pid, ret;\n\tsize_t len;\n\tchar *pass;\n\tint p[2], status;\n\tchar buf[1024];\n\tvoid (*osigchld)(int);\n\n\tif (fflush(stdout) != 0)\n\t\terror_f(\"fflush: %s\", strerror(errno));\n\tif (askpass == NULL)\n\t\tfatal(\"internal error: askpass undefined\");\n\tif (pipe(p) == -1) {\n\t\terror_f(\"pipe: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\tif ((pid = fork()) == -1) {\n\t\terror_f(\"fork: %s\", strerror(errno));\n\t\tssh_signal(SIGCHLD, osigchld);\n\t\treturn NULL;\n\t}\n\tif (pid == 0) {\n\t\tclose(p[0]);\n\t\tif (dup2(p[1], STDOUT_FILENO) == -1)\n\t\t\tfatal_f(\"dup2: %s\", strerror(errno));\n\t\tif (env_hint != NULL)\n\t\t\tsetenv(\"SSH_ASKPASS_PROMPT\", env_hint, 1);\n\t\texeclp(askpass, askpass, msg, (char *)NULL);\n\t\tfatal_f(\"exec(%s): %s\", askpass, strerror(errno));\n\t}\n\tclose(p[1]);\n\n\tlen = 0;\n\tdo {\n\t\tssize_t r = read(p[0], buf + len, sizeof(buf) - 1 - len);\n\n\t\tif (r == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tlen += r;\n\t} while (sizeof(buf) - 1 - len > 0);\n\tbuf[len] = '\\0';\n\n\tclose(p[0]);\n\twhile ((ret = waitpid(pid, &status, 0)) == -1)\n\t\tif (errno != EINTR)\n\t\t\tbreak;\n\tssh_signal(SIGCHLD, osigchld);\n\tif (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n\t\texplicit_bzero(buf, sizeof(buf));\n\t\treturn NULL;\n\t}\n\n\tbuf[strcspn(buf, \"\\r\\n\")] = '\\0';\n\tpass = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn pass;\n}\n\n \n#define RP_ASK_PERMISSION\t0x8000  \n\n \nchar *\nread_passphrase(const char *prompt, int flags)\n{\n\tchar cr = '\\r', *askpass = NULL, *ret, buf[1024];\n\tint rppflags, ttyfd, use_askpass = 0, allow_askpass = 0;\n\tconst char *askpass_hint = NULL;\n\tconst char *s;\n\n\tif ((s = getenv(\"DISPLAY\")) != NULL)\n\t\tallow_askpass = *s != '\\0';\n\tif ((s = getenv(SSH_ASKPASS_REQUIRE_ENV)) != NULL) {\n\t\tif (strcasecmp(s, \"force\") == 0) {\n\t\t\tuse_askpass = 1;\n\t\t\tallow_askpass = 1;\n\t\t} else if (strcasecmp(s, \"prefer\") == 0)\n\t\t\tuse_askpass = allow_askpass;\n\t\telse if (strcasecmp(s, \"never\") == 0)\n\t\t\tallow_askpass = 0;\n\t}\n\n\trppflags = (flags & RP_ECHO) ? RPP_ECHO_ON : RPP_ECHO_OFF;\n\tif (use_askpass)\n\t\tdebug_f(\"requested to askpass\");\n\telse if (flags & RP_USE_ASKPASS)\n\t\tuse_askpass = 1;\n\telse if (flags & RP_ALLOW_STDIN) {\n\t\tif (!isatty(STDIN_FILENO)) {\n\t\t\tdebug_f(\"stdin is not a tty\");\n\t\t\tuse_askpass = 1;\n\t\t}\n\t} else {\n\t\trppflags |= RPP_REQUIRE_TTY;\n\t\tttyfd = open(_PATH_TTY, O_RDWR);\n\t\tif (ttyfd >= 0) {\n\t\t\t \n\t\t\t(void)write(ttyfd, &cr, 1);\n\t\t\tclose(ttyfd);\n\t\t} else {\n\t\t\tdebug_f(\"can't open %s: %s\", _PATH_TTY,\n\t\t\t    strerror(errno));\n\t\t\tuse_askpass = 1;\n\t\t}\n\t}\n\n\tif ((flags & RP_USE_ASKPASS) && !allow_askpass)\n\t\treturn (flags & RP_ALLOW_EOF) ? NULL : xstrdup(\"\");\n\n\tif (use_askpass && allow_askpass) {\n\t\tif (getenv(SSH_ASKPASS_ENV))\n\t\t\taskpass = getenv(SSH_ASKPASS_ENV);\n\t\telse\n\t\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\t\tif ((flags & RP_ASK_PERMISSION) != 0)\n\t\t\taskpass_hint = \"confirm\";\n\t\tif ((ret = ssh_askpass(askpass, prompt, askpass_hint)) == NULL)\n\t\t\tif (!(flags & RP_ALLOW_EOF))\n\t\t\t\treturn xstrdup(\"\");\n\t\treturn ret;\n\t}\n\n\tif (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {\n\t\tif (flags & RP_ALLOW_EOF)\n\t\t\treturn NULL;\n\t\treturn xstrdup(\"\");\n\t}\n\n\tret = xstrdup(buf);\n\texplicit_bzero(buf, sizeof(buf));\n\treturn ret;\n}\n\nint\nask_permission(const char *fmt, ...)\n{\n\tva_list args;\n\tchar *p, prompt[1024];\n\tint allowed = 0;\n\n\tva_start(args, fmt);\n\tvsnprintf(prompt, sizeof(prompt), fmt, args);\n\tva_end(args);\n\n\tp = read_passphrase(prompt,\n\t    RP_USE_ASKPASS|RP_ALLOW_EOF|RP_ASK_PERMISSION);\n\tif (p != NULL) {\n\t\t \n\t\tif (*p == '\\0' || *p == '\\n' ||\n\t\t    strcasecmp(p, \"yes\") == 0)\n\t\t\tallowed = 1;\n\t\tfree(p);\n\t}\n\n\treturn (allowed);\n}\n\nstatic void\nwritemsg(const char *msg)\n{\n\t(void)write(STDERR_FILENO, \"\\r\", 1);\n\t(void)write(STDERR_FILENO, msg, strlen(msg));\n\t(void)write(STDERR_FILENO, \"\\r\\n\", 2);\n}\n\nstruct notifier_ctx {\n\tpid_t pid;\n\tvoid (*osigchld)(int);\n};\n\nstruct notifier_ctx *\nnotify_start(int force_askpass, const char *fmt, ...)\n{\n\tva_list args;\n\tchar *prompt = NULL;\n\tpid_t pid = -1;\n\tvoid (*osigchld)(int) = NULL;\n\tconst char *askpass, *s;\n\tstruct notifier_ctx *ret = NULL;\n\n\tva_start(args, fmt);\n\txvasprintf(&prompt, fmt, args);\n\tva_end(args);\n\n\tif (fflush(NULL) != 0)\n\t\terror_f(\"fflush: %s\", strerror(errno));\n\tif (!force_askpass && isatty(STDERR_FILENO)) {\n\t\twritemsg(prompt);\n\t\tgoto out_ctx;\n\t}\n\tif ((askpass = getenv(\"SSH_ASKPASS\")) == NULL)\n\t\taskpass = _PATH_SSH_ASKPASS_DEFAULT;\n\tif (*askpass == '\\0') {\n\t\tdebug3_f(\"cannot notify: no askpass\");\n\t\tgoto out;\n\t}\n\tif (getenv(\"DISPLAY\") == NULL &&\n\t    ((s = getenv(SSH_ASKPASS_REQUIRE_ENV)) == NULL ||\n\t    strcmp(s, \"force\") != 0)) {\n\t\tdebug3_f(\"cannot notify: no display\");\n\t\tgoto out;\n\t}\n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\tif ((pid = fork()) == -1) {\n\t\terror_f(\"fork: %s\", strerror(errno));\n\t\tssh_signal(SIGCHLD, osigchld);\n\t\tfree(prompt);\n\t\treturn NULL;\n\t}\n\tif (pid == 0) {\n\t\tif (stdfd_devnull(1, 1, 0) == -1)\n\t\t\tfatal_f(\"stdfd_devnull failed\");\n\t\tclosefrom(STDERR_FILENO + 1);\n\t\tsetenv(\"SSH_ASKPASS_PROMPT\", \"none\", 1);  \n\t\texeclp(askpass, askpass, prompt, (char *)NULL);\n\t\terror_f(\"exec(%s): %s\", askpass, strerror(errno));\n\t\t_exit(1);\n\t\t \n\t}\n out_ctx:\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\tif (pid != -1)\n\t\t\tkill(pid, SIGTERM);\n\t\tfatal_f(\"calloc failed\");\n\t}\n\tret->pid = pid;\n\tret->osigchld = osigchld;\n out:\n\tfree(prompt);\n\treturn ret;\n}\n\nvoid\nnotify_complete(struct notifier_ctx *ctx, const char *fmt, ...)\n{\n\tint ret;\n\tchar *msg = NULL;\n\tva_list args;\n\n\tif (ctx != NULL && fmt != NULL && ctx->pid == -1) {\n\t\t \n\t\tva_start(args, fmt);\n\t\txvasprintf(&msg, fmt, args);\n\t\tva_end(args);\n\t\twritemsg(msg);\n\t\tfree(msg);\n\t}\n\n\tif (ctx == NULL || ctx->pid <= 0) {\n\t\tfree(ctx);\n\t\treturn;\n\t}\n\tkill(ctx->pid, SIGTERM);\n\twhile ((ret = waitpid(ctx->pid, NULL, 0)) == -1) {\n\t\tif (errno != EINTR)\n\t\t\tbreak;\n\t}\n\tif (ret == -1)\n\t\tfatal_f(\"waitpid: %s\", strerror(errno));\n\tssh_signal(SIGCHLD, ctx->osigchld);\n\tfree(ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}