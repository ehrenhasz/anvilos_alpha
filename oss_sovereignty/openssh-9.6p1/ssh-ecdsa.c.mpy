{
  "module_name": "ssh-ecdsa.c",
  "hash_id": "450c4bce6bf8818761aa341fd4217b6045cd598144a6cf4886e933454a33433e",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-ecdsa.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#if defined(WITH_OPENSSL) && defined(OPENSSL_HAS_ECC)\n\n#include <sys/types.h>\n\n#include <openssl/bn.h>\n#include <openssl/ec.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n\n#include <string.h>\n\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#define SSHKEY_INTERNAL\n#include \"sshkey.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\nstatic u_int\nssh_ecdsa_size(const struct sshkey *key)\n{\n\tswitch (key->ecdsa_nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n#ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void\nssh_ecdsa_cleanup(struct sshkey *k)\n{\n\tEC_KEY_free(k->ecdsa);\n\tk->ecdsa = NULL;\n}\n\nstatic int\nssh_ecdsa_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tconst EC_GROUP *grp_a, *grp_b;\n\tconst EC_POINT *pub_a, *pub_b;\n\n\tif (a->ecdsa == NULL || b->ecdsa == NULL)\n\t\treturn 0;\n\tif ((grp_a = EC_KEY_get0_group(a->ecdsa)) == NULL ||\n\t    (grp_b = EC_KEY_get0_group(b->ecdsa)) == NULL)\n\t\treturn 0;\n\tif ((pub_a = EC_KEY_get0_public_key(a->ecdsa)) == NULL ||\n\t    (pub_b = EC_KEY_get0_public_key(b->ecdsa)) == NULL)\n\t\treturn 0;\n\tif (EC_GROUP_cmp(grp_a, grp_b, NULL) != 0)\n\t\treturn 0;\n\tif (EC_POINT_cmp(grp_a, pub_a, pub_b, NULL) != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int\nssh_ecdsa_serialize_public(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\n\tif (key->ecdsa == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b,\n\t    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||\n\t    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_serialize_private(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = ssh_ecdsa_serialize_public(key, b, opts)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_bignum2(b,\n\t    EC_KEY_get0_private_key(key->ecdsa))) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_generate(struct sshkey *k, int bits)\n{\n\tEC_KEY *private;\n\n\tif ((k->ecdsa_nid = sshkey_ecdsa_bits_to_nid(bits)) == -1)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = EC_KEY_new_by_curve_name(k->ecdsa_nid)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (EC_KEY_generate_key(private) != 1) {\n\t\tEC_KEY_free(private);\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tEC_KEY_set_asn1_flag(private, OPENSSL_EC_NAMED_CURVE);\n\tk->ecdsa = private;\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_copy_public(const struct sshkey *from, struct sshkey *to)\n{\n\tto->ecdsa_nid = from->ecdsa_nid;\n\tif ((to->ecdsa = EC_KEY_new_by_curve_name(from->ecdsa_nid)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (EC_KEY_set_public_key(to->ecdsa,\n\t    EC_KEY_get0_public_key(from->ecdsa)) != 1)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;  \n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_deserialize_public(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\tchar *curve = NULL;\n\n\tif ((key->ecdsa_nid = sshkey_ecdsa_nid_from_name(ktype)) == -1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_cstring(b, &curve, NULL)) != 0)\n\t\tgoto out;\n\tif (key->ecdsa_nid != sshkey_curve_name_to_nid(curve)) {\n\t\tr = SSH_ERR_EC_CURVE_MISMATCH;\n\t\tgoto out;\n\t}\n\tEC_KEY_free(key->ecdsa);\n\tkey->ecdsa = NULL;\n\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid)) == NULL) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_eckey(b, key->ecdsa)) != 0)\n\t\tgoto out;\n\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa),\n\t    EC_KEY_get0_public_key(key->ecdsa)) != 0) {\n\t\tr = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n#ifdef DEBUG_PK\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key->ecdsa),\n\t    EC_KEY_get0_public_key(key->ecdsa));\n#endif\n out:\n\tfree(curve);\n\tif (r != 0) {\n\t\tEC_KEY_free(key->ecdsa);\n\t\tkey->ecdsa = NULL;\n\t}\n\treturn r;\n}\n\nstatic int\nssh_ecdsa_deserialize_private(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\tBIGNUM *exponent = NULL;\n\n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = ssh_ecdsa_deserialize_public(ktype, b, key)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_get_bignum2(b, &exponent)) != 0)\n\t\tgoto out;\n\tif (EC_KEY_set_private_key(key->ecdsa, exponent) != 1) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_ec_validate_private(key->ecdsa)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tBN_clear_free(exponent);\n\treturn r;\n}\n\nstatic int\nssh_ecdsa_sign(struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t dlen,\n    const char *alg, const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\tECDSA_SIG *esig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tint hash_alg;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH];\n\tsize_t len, hlen;\n\tstruct sshbuf *b = NULL, *bb = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||\n\t    (hlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((ret = ssh_digest_memory(hash_alg, data, dlen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((esig = ECDSA_do_sign(digest, hlen, key->ecdsa)) == NULL) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tif ((bb = sshbuf_new()) == NULL || (b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tECDSA_SIG_get0(esig, &sig_r, &sig_s);\n\tif ((ret = sshbuf_put_bignum2(bb, sig_r)) != 0 ||\n\t    (ret = sshbuf_put_bignum2(bb, sig_s)) != 0)\n\t\tgoto out;\n\tif ((ret = sshbuf_put_cstring(b, sshkey_ssh_name_plain(key))) != 0 ||\n\t    (ret = sshbuf_put_stringb(b, bb)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tsshbuf_free(b);\n\tsshbuf_free(bb);\n\tECDSA_SIG_free(esig);\n\treturn ret;\n}\n\nstatic int\nssh_ecdsa_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\tECDSA_SIG *esig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tint hash_alg;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH];\n\tsize_t hlen;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL, *sigbuf = NULL;\n\tchar *ktype = NULL;\n\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||\n\t    (hlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||\n\t    sshbuf_froms(b, &sigbuf) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(sshkey_ssh_name_plain(key), ktype) != 0) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sshbuf_get_bignum2(sigbuf, &sig_r) != 0 ||\n\t    sshbuf_get_bignum2(sigbuf, &sig_s) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((esig = ECDSA_SIG_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!ECDSA_SIG_set0(esig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL;  \n\n\tif (sshbuf_len(sigbuf) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif ((ret = ssh_digest_memory(hash_alg, data, dlen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tswitch (ECDSA_do_verify(digest, hlen, esig, key->ecdsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tsshbuf_free(sigbuf);\n\tsshbuf_free(b);\n\tECDSA_SIG_free(esig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tfree(ktype);\n\treturn ret;\n}\n\n \nconst struct sshkey_impl_funcs sshkey_ecdsa_funcs = {\n\t \t\tssh_ecdsa_size,\n\t \t\tNULL,\n\t \tssh_ecdsa_cleanup,\n\t \t\tssh_ecdsa_equal,\n\t  ssh_ecdsa_serialize_public,\n\t  ssh_ecdsa_deserialize_public,\n\t  ssh_ecdsa_serialize_private,\n\t  ssh_ecdsa_deserialize_private,\n\t \tssh_ecdsa_generate,\n\t \tssh_ecdsa_copy_public,\n\t \t\tssh_ecdsa_sign,\n\t \t\tssh_ecdsa_verify,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_nistp256_impl = {\n\t \t\t\"ecdsa-sha2-nistp256\",\n\t \t\"ECDSA\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA,\n\t \t\tNID_X9_62_prime256v1,\n\t \t\t0,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_ecdsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_nistp256_cert_impl = {\n\t \t\t\"ecdsa-sha2-nistp256-cert-v01@openssh.com\",\n\t \t\"ECDSA-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA_CERT,\n\t \t\tNID_X9_62_prime256v1,\n\t \t\t1,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_ecdsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_nistp384_impl = {\n\t \t\t\"ecdsa-sha2-nistp384\",\n\t \t\"ECDSA\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA,\n\t \t\tNID_secp384r1,\n\t \t\t0,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_ecdsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_nistp384_cert_impl = {\n\t \t\t\"ecdsa-sha2-nistp384-cert-v01@openssh.com\",\n\t \t\"ECDSA-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA_CERT,\n\t \t\tNID_secp384r1,\n\t \t\t1,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_ecdsa_funcs,\n};\n\n#ifdef OPENSSL_HAS_NISTP521\nconst struct sshkey_impl sshkey_ecdsa_nistp521_impl = {\n\t \t\t\"ecdsa-sha2-nistp521\",\n\t \t\"ECDSA\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA,\n\t \t\tNID_secp521r1,\n\t \t\t0,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_ecdsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_nistp521_cert_impl = {\n\t \t\t\"ecdsa-sha2-nistp521-cert-v01@openssh.com\",\n\t \t\"ECDSA-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA_CERT,\n\t \t\tNID_secp521r1,\n\t \t\t1,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_ecdsa_funcs,\n};\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}