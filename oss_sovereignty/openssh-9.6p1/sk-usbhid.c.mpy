{
  "module_name": "sk-usbhid.c",
  "hash_id": "4a49d62f160246ad3ed546f08b2e6c9195881d1025d6908eeefb751837de0257",
  "original_prompt": "Ingested from openssh-9.6p1/sk-usbhid.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef ENABLE_SK_INTERNAL\n\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <time.h>\n#ifdef HAVE_SHA2_H\n#include <sha2.h>\n#endif\n\n \n#ifndef OPENSSL_HAS_ECC\n# undef WITH_OPENSSL\n#endif\n\n#ifdef WITH_OPENSSL\n#include <openssl/opensslv.h>\n#include <openssl/crypto.h>\n#include <openssl/bn.h>\n#include <openssl/ec.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#endif  \n\n#include <fido.h>\n#include <fido/credman.h>\n\n \n#ifndef HAVE_FIDO_CRED_PROT\n#define fido_cred_prot(x) (0)\n#endif\n#ifndef HAVE_FIDO_CRED_SET_PROT\n#define fido_cred_set_prot(x, y) (FIDO_ERR_UNSUPPORTED_OPTION)\n#endif\n#ifndef HAVE_FIDO_DEV_SUPPORTS_CRED_PROT\n#define fido_dev_supports_cred_prot(x) (0)\n#endif\n#ifndef HAVE_FIDO_DEV_GET_TOUCH_BEGIN\n#define fido_dev_get_touch_begin(x) (FIDO_ERR_UNSUPPORTED_OPTION)\n#endif\n#ifndef HAVE_FIDO_DEV_GET_TOUCH_STATUS\n#define fido_dev_get_touch_status(x, y, z) (FIDO_ERR_UNSUPPORTED_OPTION)\n#endif\n#ifndef FIDO_CRED_PROT_UV_REQUIRED\n#define FIDO_CRED_PROT_UV_REQUIRED 0\n#endif\n#ifndef FIDO_CRED_PROT_UV_OPTIONAL_WITH_ID\n#define FIDO_CRED_PROT_UV_OPTIONAL_WITH_ID 0\n#endif\n\n#ifndef SK_STANDALONE\n# include \"log.h\"\n# include \"xmalloc.h\"\n# include \"misc.h\"\n \n# define sk_api_version\t\tssh_sk_api_version\n# define sk_enroll\t\tssh_sk_enroll\n# define sk_sign\t\tssh_sk_sign\n# define sk_load_resident_keys\tssh_sk_load_resident_keys\n#endif  \n\n#include \"sk-api.h\"\n\n \n\n#ifdef SK_DEBUG\n#define SSH_FIDO_INIT_ARG\tFIDO_DEBUG\n#else\n#define SSH_FIDO_INIT_ARG\t0\n#endif\n\n#define MAX_FIDO_DEVICES\t8\n#define FIDO_POLL_MS\t\t50\n#define SELECT_MS\t\t15000\n#define POLL_SLEEP_NS\t\t200000000\n\n#ifndef FIDO_ERR_OPERATION_DENIED\n#define FIDO_ERR_OPERATION_DENIED 0x27\n#endif\n\nstruct sk_usbhid {\n\tfido_dev_t *dev;\n\tchar *path;\n};\n\n \nuint32_t sk_api_version(void);\n\n \nint sk_enroll(uint32_t alg, const uint8_t *challenge, size_t challenge_len,\n    const char *application, uint8_t flags, const char *pin,\n    struct sk_option **options, struct sk_enroll_response **enroll_response);\n\n \nint sk_sign(uint32_t alg, const uint8_t *data, size_t data_len,\n    const char *application, const uint8_t *key_handle, size_t key_handle_len,\n    uint8_t flags, const char *pin, struct sk_option **options,\n    struct sk_sign_response **sign_response);\n\n \nint sk_load_resident_keys(const char *pin, struct sk_option **options,\n    struct sk_resident_key ***rks, size_t *nrks);\n\nstatic void skdebug(const char *func, const char *fmt, ...)\n    __attribute__((__format__ (printf, 2, 3)));\n\nstatic void\nskdebug(const char *func, const char *fmt, ...)\n{\n#if !defined(SK_STANDALONE)\n\tchar *msg;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\tdebug(\"%s: %s\", func, msg);\n\tfree(msg);\n#elif defined(SK_DEBUG)\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"%s: \", func);\n\tvfprintf(stderr, fmt, ap);\n\tfputc('\\n', stderr);\n\tva_end(ap);\n#else\n\t(void)func;  \n\t(void)fmt;  \n#endif\n}\n\nuint32_t\nsk_api_version(void)\n{\n\treturn SSH_SK_VERSION_MAJOR;\n}\n\nstatic struct sk_usbhid *\nsk_open(const char *path)\n{\n\tstruct sk_usbhid *sk;\n\tint r;\n\n\tif (path == NULL) {\n\t\tskdebug(__func__, \"path == NULL\");\n\t\treturn NULL;\n\t}\n\tif ((sk = calloc(1, sizeof(*sk))) == NULL) {\n\t\tskdebug(__func__, \"calloc sk failed\");\n\t\treturn NULL;\n\t}\n\tif ((sk->path = strdup(path)) == NULL) {\n\t\tskdebug(__func__, \"strdup path failed\");\n\t\tfree(sk);\n\t\treturn NULL;\n\t}\n\tif ((sk->dev = fido_dev_new()) == NULL) {\n\t\tskdebug(__func__, \"fido_dev_new failed\");\n\t\tfree(sk->path);\n\t\tfree(sk);\n\t\treturn NULL;\n\t}\n\tif ((r = fido_dev_open(sk->dev, sk->path)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_dev_open %s failed: %s\", sk->path,\n\t\t    fido_strerr(r));\n\t\tfido_dev_free(&sk->dev);\n\t\tfree(sk->path);\n\t\tfree(sk);\n\t\treturn NULL;\n\t}\n\treturn sk;\n}\n\nstatic void\nsk_close(struct sk_usbhid *sk)\n{\n\tif (sk == NULL)\n\t\treturn;\n\tfido_dev_cancel(sk->dev);  \n\tfido_dev_close(sk->dev);\n\tfido_dev_free(&sk->dev);\n\tfree(sk->path);\n\tfree(sk);\n}\n\nstatic struct sk_usbhid **\nsk_openv(const fido_dev_info_t *devlist, size_t ndevs, size_t *nopen)\n{\n\tconst fido_dev_info_t *di;\n\tstruct sk_usbhid **skv;\n\tsize_t i;\n\n\t*nopen = 0;\n\tif ((skv = calloc(ndevs, sizeof(*skv))) == NULL) {\n\t\tskdebug(__func__, \"calloc skv failed\");\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < ndevs; i++) {\n\t\tif ((di = fido_dev_info_ptr(devlist, i)) == NULL)\n\t\t\tskdebug(__func__, \"fido_dev_info_ptr failed\");\n\t\telse if ((skv[*nopen] = sk_open(fido_dev_info_path(di))) == NULL)\n\t\t\tskdebug(__func__, \"sk_open failed\");\n\t\telse\n\t\t\t(*nopen)++;\n\t}\n\tif (*nopen == 0) {\n\t\tfor (i = 0; i < ndevs; i++)\n\t\t\tsk_close(skv[i]);\n\t\tfree(skv);\n\t\tskv = NULL;\n\t}\n\n\treturn skv;\n}\n\nstatic void\nsk_closev(struct sk_usbhid **skv, size_t nsk)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nsk; i++)\n\t\tsk_close(skv[i]);\n\tfree(skv);\n}\n\nstatic int\nsk_touch_begin(struct sk_usbhid **skv, size_t nsk)\n{\n\tsize_t i, ok = 0;\n\tint r;\n\n\tfor (i = 0; i < nsk; i++)\n\t\tif ((r = fido_dev_get_touch_begin(skv[i]->dev)) != FIDO_OK)\n\t\t\tskdebug(__func__, \"fido_dev_get_touch_begin %s failed:\"\n\t\t\t    \" %s\", skv[i]->path, fido_strerr(r));\n\t\telse\n\t\t\tok++;\n\n\treturn ok ? 0 : -1;\n}\n\nstatic int\nsk_touch_poll(struct sk_usbhid **skv, size_t nsk, int *touch, size_t *idx)\n{\n\tstruct timespec ts_pause;\n\tsize_t npoll, i;\n\tint r;\n\n\tts_pause.tv_sec = 0;\n\tts_pause.tv_nsec = POLL_SLEEP_NS;\n\tnanosleep(&ts_pause, NULL);\n\tnpoll = nsk;\n\tfor (i = 0; i < nsk; i++) {\n\t\tif (skv[i] == NULL)\n\t\t\tcontinue;  \n\t\tskdebug(__func__, \"polling %s\", skv[i]->path);\n\t\tif ((r = fido_dev_get_touch_status(skv[i]->dev, touch,\n\t\t    FIDO_POLL_MS)) != FIDO_OK) {\n\t\t\tskdebug(__func__, \"fido_dev_get_touch_status %s: %s\",\n\t\t\t    skv[i]->path, fido_strerr(r));\n\t\t\tsk_close(skv[i]);  \n\t\t\tskv[i] = NULL;\n\t\t\tif (--npoll == 0) {\n\t\t\t\tskdebug(__func__, \"no device left to poll\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (*touch) {\n\t\t\t*idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*touch = 0;\n\treturn 0;\n}\n\n#if !defined(HAVE_FIDO_ASSERT_SET_CLIENTDATA) || \\\n    !defined(HAVE_FIDO_CRED_SET_CLIENTDATA)\n \nstatic int\nsha256_mem(const void *m, size_t mlen, u_char *d, size_t dlen)\n{\n#ifdef WITH_OPENSSL\n\tu_int mdlen;\n#else\n\tSHA2_CTX ctx;\n#endif\n\n\tif (dlen != 32)\n\t\treturn -1;\n#ifdef WITH_OPENSSL\n\tmdlen = dlen;\n\tif (!EVP_Digest(m, mlen, d, &mdlen, EVP_sha256(), NULL))\n\t\treturn -1;\n#else\n\tSHA256Init(&ctx);\n\tSHA256Update(&ctx, (const uint8_t *)m, mlen);\n\tSHA256Final(d, &ctx);\n#endif\n\treturn 0;\n}\n#endif  \n\n#ifndef HAVE_FIDO_CRED_SET_CLIENTDATA\nstatic int\nfido_cred_set_clientdata(fido_cred_t *cred, const u_char *ptr, size_t len)\n{\n\tuint8_t d[32];\n\tint r;\n\n\tif (sha256_mem(ptr, len, d, sizeof(d)) != 0) {\n\t\tskdebug(__func__, \"hash challenge failed\");\n\t\treturn FIDO_ERR_INTERNAL;\n\t}\n\tr = fido_cred_set_clientdata_hash(cred, d, sizeof(d));\n\texplicit_bzero(d, sizeof(d));\n\tif (r != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_cred_set_clientdata_hash failed: %s\",\n\t\t    fido_strerr(r));\n\t}\n\treturn r;\n}\n#endif  \n\n#ifndef HAVE_FIDO_ASSERT_SET_CLIENTDATA\nstatic int\nfido_assert_set_clientdata(fido_assert_t *assert, const u_char *ptr, size_t len)\n{\n\tuint8_t d[32];\n\tint r;\n\n\tif (sha256_mem(ptr, len, d, sizeof(d)) != 0) {\n\t\tskdebug(__func__, \"hash challenge failed\");\n\t\treturn FIDO_ERR_INTERNAL;\n\t}\n\tr = fido_assert_set_clientdata_hash(assert, d, sizeof(d));\n\texplicit_bzero(d, sizeof(d));\n\tif (r != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_clientdata_hash failed: %s\",\n\t\t    fido_strerr(r));\n\t}\n\treturn r;\n}\n#endif  \n\n#ifndef HAVE_FIDO_DEV_IS_WINHELLO\nstatic bool\nfido_dev_is_winhello(const fido_dev_t *fdev)\n{\n\treturn 0;\n}\n#endif  \n\n \nstatic int\nsk_try(const struct sk_usbhid *sk, const char *application,\n    const uint8_t *key_handle, size_t key_handle_len)\n{\n\tfido_assert_t *assert = NULL;\n\tint r = FIDO_ERR_INTERNAL;\n\tuint8_t message[32];\n\n\tmemset(message, '\\0', sizeof(message));\n\tif ((assert = fido_assert_new()) == NULL) {\n\t\tskdebug(__func__, \"fido_assert_new failed\");\n\t\tgoto out;\n\t}\n\t \n\tif ((r = fido_assert_set_clientdata(assert, message,\n\t    sizeof(message))) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_clientdata: %s\",\n\t\t    fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_rp(assert, application)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_rp: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_allow_cred(assert, key_handle,\n\t    key_handle_len)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_allow_cred: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_up(assert, FIDO_OPT_FALSE)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_up: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tr = fido_dev_get_assert(sk->dev, assert, NULL);\n\tskdebug(__func__, \"fido_dev_get_assert: %s\", fido_strerr(r));\n\tif (r == FIDO_ERR_USER_PRESENCE_REQUIRED) {\n\t\t \n\t\tr = FIDO_OK;\n\t}\n out:\n\tfido_assert_free(&assert);\n\n\treturn r != FIDO_OK ? -1 : 0;\n}\n\nstatic int\ncheck_sk_options(fido_dev_t *dev, const char *opt, int *ret)\n{\n\tfido_cbor_info_t *info;\n\tchar * const *name;\n\tconst bool *value;\n\tsize_t len, i;\n\tint r;\n\n\t*ret = -1;\n\n\tif (!fido_dev_is_fido2(dev)) {\n\t\tskdebug(__func__, \"device is not fido2\");\n\t\treturn 0;\n\t}\n\tif ((info = fido_cbor_info_new()) == NULL) {\n\t\tskdebug(__func__, \"fido_cbor_info_new failed\");\n\t\treturn -1;\n\t}\n\tif ((r = fido_dev_get_cbor_info(dev, info)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_dev_get_cbor_info: %s\", fido_strerr(r));\n\t\tfido_cbor_info_free(&info);\n\t\treturn -1;\n\t}\n\tname = fido_cbor_info_options_name_ptr(info);\n\tvalue = fido_cbor_info_options_value_ptr(info);\n\tlen = fido_cbor_info_options_len(info);\n\tfor (i = 0; i < len; i++) {\n\t\tif (!strcmp(name[i], opt)) {\n\t\t\t*ret = value[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfido_cbor_info_free(&info);\n\tif (*ret == -1)\n\t\tskdebug(__func__, \"option %s is unknown\", opt);\n\telse\n\t\tskdebug(__func__, \"option %s is %s\", opt, *ret ? \"on\" : \"off\");\n\n\treturn 0;\n}\n\nstatic struct sk_usbhid *\nsk_select_by_cred(const fido_dev_info_t *devlist, size_t ndevs,\n    const char *application, const uint8_t *key_handle, size_t key_handle_len)\n{\n\tstruct sk_usbhid **skv, *sk;\n\tsize_t skvcnt, i;\n\tint internal_uv;\n\n\tif ((skv = sk_openv(devlist, ndevs, &skvcnt)) == NULL) {\n\t\tskdebug(__func__, \"sk_openv failed\");\n\t\treturn NULL;\n\t}\n\tif (skvcnt == 1 && check_sk_options(skv[0]->dev, \"uv\",\n\t    &internal_uv) == 0 && internal_uv != -1) {\n\t\tsk = skv[0];\n\t\tskv[0] = NULL;\n\t\tgoto out;\n\t}\n\tsk = NULL;\n\tfor (i = 0; i < skvcnt; i++) {\n\t\tif (sk_try(skv[i], application, key_handle,\n\t\t    key_handle_len) == 0) {\n\t\t\tsk = skv[i];\n\t\t\tskv[i] = NULL;\n\t\t\tskdebug(__func__, \"found key in %s\", sk->path);\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\tsk_closev(skv, skvcnt);\n\treturn sk;\n}\n\nstatic struct sk_usbhid *\nsk_select_by_touch(const fido_dev_info_t *devlist, size_t ndevs)\n{\n\tstruct sk_usbhid **skv, *sk;\n\tstruct timeval tv_start, tv_now, tv_delta;\n\tsize_t skvcnt, idx;\n\tint touch, ms_remain;\n\n\tif ((skv = sk_openv(devlist, ndevs, &skvcnt)) == NULL) {\n\t\tskdebug(__func__, \"sk_openv failed\");\n\t\treturn NULL;\n\t}\n\tsk = NULL;\n\tif (skvcnt < 2) {\n\t\tif (skvcnt == 1) {\n\t\t\t \n\t\t\tsk = skv[0];\n\t\t\tskv[0] = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n#ifndef HAVE_FIDO_DEV_GET_TOUCH_STATUS\n\tskdebug(__func__, \"libfido2 version does not support a feature needed for multiple tokens. Please upgrade to >=1.5.0\");\n\tgoto out;\n#endif\n\n\tif (sk_touch_begin(skv, skvcnt) == -1) {\n\t\tskdebug(__func__, \"sk_touch_begin failed\");\n\t\tgoto out;\n\t}\n\tmonotime_tv(&tv_start);\n\tdo {\n\t\tif (sk_touch_poll(skv, skvcnt, &touch, &idx) == -1) {\n\t\t\tskdebug(__func__, \"sk_touch_poll failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (touch) {\n\t\t\tsk = skv[idx];\n\t\t\tskv[idx] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tmonotime_tv(&tv_now);\n\t\ttimersub(&tv_now, &tv_start, &tv_delta);\n\t\tms_remain = SELECT_MS - tv_delta.tv_sec * 1000 -\n\t\t    tv_delta.tv_usec / 1000;\n\t} while (ms_remain >= FIDO_POLL_MS);\n\tskdebug(__func__, \"timeout\");\nout:\n\tsk_closev(skv, skvcnt);\n\treturn sk;\n}\n\nstatic struct sk_usbhid *\nsk_probe(const char *application, const uint8_t *key_handle,\n    size_t key_handle_len, int probe_resident)\n{\n\tstruct sk_usbhid *sk;\n\tfido_dev_info_t *devlist;\n\tsize_t ndevs;\n\tint r;\n\n#ifdef HAVE_CYGWIN\n\tif (!probe_resident && (sk = sk_open(\"windows://hello\")) != NULL)\n\t\treturn sk;\n#endif  \n\tif ((devlist = fido_dev_info_new(MAX_FIDO_DEVICES)) == NULL) {\n\t\tskdebug(__func__, \"fido_dev_info_new failed\");\n\t\treturn NULL;\n\t}\n\tif ((r = fido_dev_info_manifest(devlist, MAX_FIDO_DEVICES,\n\t    &ndevs)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_dev_info_manifest failed: %s\",\n\t\t    fido_strerr(r));\n\t\tfido_dev_info_free(&devlist, MAX_FIDO_DEVICES);\n\t\treturn NULL;\n\t}\n\tskdebug(__func__, \"%zu device(s) detected\", ndevs);\n\tif (ndevs == 0) {\n\t\tsk = NULL;\n\t} else if (application != NULL && key_handle != NULL) {\n\t\tskdebug(__func__, \"selecting sk by cred\");\n\t\tsk = sk_select_by_cred(devlist, ndevs, application, key_handle,\n\t\t    key_handle_len);\n\t} else {\n\t\tskdebug(__func__, \"selecting sk by touch\");\n\t\tsk = sk_select_by_touch(devlist, ndevs);\n\t}\n\tfido_dev_info_free(&devlist, MAX_FIDO_DEVICES);\n\treturn sk;\n}\n\n#ifdef WITH_OPENSSL\n \nstatic int\npack_public_key_ecdsa(const fido_cred_t *cred,\n    struct sk_enroll_response *response)\n{\n\tconst uint8_t *ptr;\n\tBIGNUM *x = NULL, *y = NULL;\n\tEC_POINT *q = NULL;\n\tEC_GROUP *g = NULL;\n\tint ret = -1;\n\n\tresponse->public_key = NULL;\n\tresponse->public_key_len = 0;\n\n\tif ((x = BN_new()) == NULL ||\n\t    (y = BN_new()) == NULL ||\n\t    (g = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1)) == NULL ||\n\t    (q = EC_POINT_new(g)) == NULL) {\n\t\tskdebug(__func__, \"libcrypto setup failed\");\n\t\tgoto out;\n\t}\n\tif ((ptr = fido_cred_pubkey_ptr(cred)) == NULL) {\n\t\tskdebug(__func__, \"fido_cred_pubkey_ptr failed\");\n\t\tgoto out;\n\t}\n\tif (fido_cred_pubkey_len(cred) != 64) {\n\t\tskdebug(__func__, \"bad fido_cred_pubkey_len %zu\",\n\t\t    fido_cred_pubkey_len(cred));\n\t\tgoto out;\n\t}\n\n\tif (BN_bin2bn(ptr, 32, x) == NULL ||\n\t    BN_bin2bn(ptr + 32, 32, y) == NULL) {\n\t\tskdebug(__func__, \"BN_bin2bn failed\");\n\t\tgoto out;\n\t}\n\tif (EC_POINT_set_affine_coordinates_GFp(g, q, x, y, NULL) != 1) {\n\t\tskdebug(__func__, \"EC_POINT_set_affine_coordinates_GFp failed\");\n\t\tgoto out;\n\t}\n\tresponse->public_key_len = EC_POINT_point2oct(g, q,\n\t    POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);\n\tif (response->public_key_len == 0 || response->public_key_len > 2048) {\n\t\tskdebug(__func__, \"bad pubkey length %zu\",\n\t\t    response->public_key_len);\n\t\tgoto out;\n\t}\n\tif ((response->public_key = malloc(response->public_key_len)) == NULL) {\n\t\tskdebug(__func__, \"malloc pubkey failed\");\n\t\tgoto out;\n\t}\n\tif (EC_POINT_point2oct(g, q, POINT_CONVERSION_UNCOMPRESSED,\n\t    response->public_key, response->public_key_len, NULL) == 0) {\n\t\tskdebug(__func__, \"EC_POINT_point2oct failed\");\n\t\tgoto out;\n\t}\n\t \n\tret = 0;\n out:\n\tif (ret != 0 && response->public_key != NULL) {\n\t\tmemset(response->public_key, 0, response->public_key_len);\n\t\tfree(response->public_key);\n\t\tresponse->public_key = NULL;\n\t}\n\tEC_POINT_free(q);\n\tEC_GROUP_free(g);\n\tBN_clear_free(x);\n\tBN_clear_free(y);\n\treturn ret;\n}\n#endif  \n\nstatic int\npack_public_key_ed25519(const fido_cred_t *cred,\n    struct sk_enroll_response *response)\n{\n\tconst uint8_t *ptr;\n\tsize_t len;\n\tint ret = -1;\n\n\tresponse->public_key = NULL;\n\tresponse->public_key_len = 0;\n\n\tif ((len = fido_cred_pubkey_len(cred)) != 32) {\n\t\tskdebug(__func__, \"bad fido_cred_pubkey_len len %zu\", len);\n\t\tgoto out;\n\t}\n\tif ((ptr = fido_cred_pubkey_ptr(cred)) == NULL) {\n\t\tskdebug(__func__, \"fido_cred_pubkey_ptr failed\");\n\t\tgoto out;\n\t}\n\tresponse->public_key_len = len;\n\tif ((response->public_key = malloc(response->public_key_len)) == NULL) {\n\t\tskdebug(__func__, \"malloc pubkey failed\");\n\t\tgoto out;\n\t}\n\tmemcpy(response->public_key, ptr, len);\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tfree(response->public_key);\n\treturn ret;\n}\n\nstatic int\npack_public_key(uint32_t alg, const fido_cred_t *cred,\n    struct sk_enroll_response *response)\n{\n\tswitch(alg) {\n#ifdef WITH_OPENSSL\n\tcase SSH_SK_ECDSA:\n\t\treturn pack_public_key_ecdsa(cred, response);\n#endif  \n\tcase SSH_SK_ED25519:\n\t\treturn pack_public_key_ed25519(cred, response);\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic int\nfidoerr_to_skerr(int fidoerr)\n{\n\tswitch (fidoerr) {\n\tcase FIDO_ERR_UNSUPPORTED_OPTION:\n\tcase FIDO_ERR_UNSUPPORTED_ALGORITHM:\n\t\treturn SSH_SK_ERR_UNSUPPORTED;\n\tcase FIDO_ERR_PIN_REQUIRED:\n\tcase FIDO_ERR_PIN_INVALID:\n\tcase FIDO_ERR_OPERATION_DENIED:\n\t\treturn SSH_SK_ERR_PIN_REQUIRED;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic int\ncheck_enroll_options(struct sk_option **options, char **devicep,\n    uint8_t *user_id, size_t user_id_len)\n{\n\tsize_t i;\n\n\tif (options == NULL)\n\t\treturn 0;\n\tfor (i = 0; options[i] != NULL; i++) {\n\t\tif (strcmp(options[i]->name, \"device\") == 0) {\n\t\t\tif ((*devicep = strdup(options[i]->value)) == NULL) {\n\t\t\t\tskdebug(__func__, \"strdup device failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tskdebug(__func__, \"requested device %s\", *devicep);\n\t\t} else if (strcmp(options[i]->name, \"user\") == 0) {\n\t\t\tif (strlcpy(user_id, options[i]->value, user_id_len) >=\n\t\t\t    user_id_len) {\n\t\t\t\tskdebug(__func__, \"user too long\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tskdebug(__func__, \"requested user %s\",\n\t\t\t    (char *)user_id);\n\t\t} else {\n\t\t\tskdebug(__func__, \"requested unsupported option %s\",\n\t\t\t    options[i]->name);\n\t\t\tif (options[i]->required) {\n\t\t\t\tskdebug(__func__, \"unknown required option\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nkey_lookup(fido_dev_t *dev, const char *application, const uint8_t *user_id,\n    size_t user_id_len, const char *pin)\n{\n\tfido_assert_t *assert = NULL;\n\tuint8_t message[32];\n\tint r = FIDO_ERR_INTERNAL;\n\tint sk_supports_uv, uv;\n\tsize_t i;\n\n\tmemset(message, '\\0', sizeof(message));\n\tif ((assert = fido_assert_new()) == NULL) {\n\t\tskdebug(__func__, \"fido_assert_new failed\");\n\t\tgoto out;\n\t}\n\t \n\tif ((r = fido_assert_set_clientdata(assert, message,\n\t    sizeof(message))) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_clientdata: %s\",\n\t\t    fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_rp(assert, application)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_rp: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_up(assert, FIDO_OPT_FALSE)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_up: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tuv = FIDO_OPT_OMIT;\n\tif (pin == NULL && check_sk_options(dev, \"uv\", &sk_supports_uv) == 0 &&\n\t    sk_supports_uv != -1)\n\t\tuv = FIDO_OPT_TRUE;\n\tif ((r = fido_assert_set_uv(assert, uv)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_uv: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_dev_get_assert(dev, assert, pin)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_dev_get_assert: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tr = FIDO_ERR_NO_CREDENTIALS;\n\tskdebug(__func__, \"%zu signatures returned\", fido_assert_count(assert));\n\tfor (i = 0; i < fido_assert_count(assert); i++) {\n\t\tif (fido_assert_user_id_len(assert, i) == user_id_len &&\n\t\t    memcmp(fido_assert_user_id_ptr(assert, i), user_id,\n\t\t    user_id_len) == 0) {\n\t\t\tskdebug(__func__, \"credential exists\");\n\t\t\tr = FIDO_OK;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tfido_assert_free(&assert);\n\n\treturn r;\n}\n\nint\nsk_enroll(uint32_t alg, const uint8_t *challenge, size_t challenge_len,\n    const char *application, uint8_t flags, const char *pin,\n    struct sk_option **options, struct sk_enroll_response **enroll_response)\n{\n\tfido_cred_t *cred = NULL;\n\tconst uint8_t *ptr;\n\tuint8_t user_id[32];\n\tstruct sk_usbhid *sk = NULL;\n\tstruct sk_enroll_response *response = NULL;\n\tsize_t len;\n\tint credprot;\n\tint cose_alg;\n\tint ret = SSH_SK_ERR_GENERAL;\n\tint r;\n\tchar *device = NULL;\n\n\tfido_init(SSH_FIDO_INIT_ARG);\n\n\tif (enroll_response == NULL) {\n\t\tskdebug(__func__, \"enroll_response == NULL\");\n\t\tgoto out;\n\t}\n\t*enroll_response = NULL;\n\tmemset(user_id, 0, sizeof(user_id));\n\tif (check_enroll_options(options, &device, user_id,\n\t    sizeof(user_id)) != 0)\n\t\tgoto out;  \n\n\tswitch(alg) {\n#ifdef WITH_OPENSSL\n\tcase SSH_SK_ECDSA:\n\t\tcose_alg = COSE_ES256;\n\t\tbreak;\n#endif  \n\tcase SSH_SK_ED25519:\n\t\tcose_alg = COSE_EDDSA;\n\t\tbreak;\n\tdefault:\n\t\tskdebug(__func__, \"unsupported key type %d\", alg);\n\t\tgoto out;\n\t}\n\tif (device != NULL)\n\t\tsk = sk_open(device);\n\telse\n\t\tsk = sk_probe(NULL, NULL, 0, 0);\n\tif (sk == NULL) {\n\t\tret = SSH_SK_ERR_DEVICE_NOT_FOUND;\n\t\tskdebug(__func__, \"failed to find sk\");\n\t\tgoto out;\n\t}\n\tskdebug(__func__, \"using device %s\", sk->path);\n\tif ((flags & SSH_SK_RESIDENT_KEY) != 0 &&\n\t    (flags & SSH_SK_FORCE_OPERATION) == 0 &&\n\t    (r = key_lookup(sk->dev, application, user_id, sizeof(user_id),\n\t    pin)) != FIDO_ERR_NO_CREDENTIALS) {\n\t\tif (r != FIDO_OK) {\n\t\t\tret = fidoerr_to_skerr(r);\n\t\t\tskdebug(__func__, \"key_lookup failed\");\n\t\t} else {\n\t\t\tret = SSH_SK_ERR_CREDENTIAL_EXISTS;\n\t\t\tskdebug(__func__, \"key exists\");\n\t\t}\n\t\tgoto out;\n\t}\n\tif ((cred = fido_cred_new()) == NULL) {\n\t\tskdebug(__func__, \"fido_cred_new failed\");\n\t\tgoto out;\n\t}\n\tif ((r = fido_cred_set_type(cred, cose_alg)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_cred_set_type: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_cred_set_clientdata(cred,\n\t    challenge, challenge_len)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_cred_set_clientdata: %s\",\n\t\t    fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_cred_set_rk(cred, (flags & SSH_SK_RESIDENT_KEY) != 0 ?\n\t    FIDO_OPT_TRUE : FIDO_OPT_OMIT)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_cred_set_rk: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_cred_set_user(cred, user_id, sizeof(user_id),\n\t    \"openssh\", \"openssh\", NULL)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_cred_set_user: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_cred_set_rp(cred, application, NULL)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_cred_set_rp: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((flags & (SSH_SK_RESIDENT_KEY|SSH_SK_USER_VERIFICATION_REQD)) != 0) {\n#if !defined(HAVE_FIDO_DEV_SUPPORTS_CRED_PROT) || \\\n    !defined(HAVE_FIDO_CRED_SET_PROT)\n\t\tskdebug(__func__, \"libfido2 version does not support a feature required for this operation. Please upgrade to >=1.5.0\");\n\t\tret = SSH_SK_ERR_UNSUPPORTED;\n\t\tgoto out;\n\t\tcredprot = 0; (void)credprot;  \n#endif\n\t\tif (!fido_dev_supports_cred_prot(sk->dev)) {\n\t\t\tskdebug(__func__, \"%s does not support credprot, \"\n\t\t\t    \"refusing to create unprotected \"\n\t\t\t    \"resident/verify-required key\", sk->path);\n\t\t\tret = SSH_SK_ERR_UNSUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((flags & SSH_SK_USER_VERIFICATION_REQD))\n\t\t\tcredprot = FIDO_CRED_PROT_UV_REQUIRED;\n\t\telse\n\t\t\tcredprot = FIDO_CRED_PROT_UV_OPTIONAL_WITH_ID;\n\n\t\tif ((r = fido_cred_set_prot(cred, credprot)) != FIDO_OK) {\n\t\t\tskdebug(__func__, \"fido_cred_set_prot: %s\",\n\t\t\t    fido_strerr(r));\n\t\t\tret = fidoerr_to_skerr(r);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = fido_dev_make_cred(sk->dev, cred, pin)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_dev_make_cred: %s\", fido_strerr(r));\n\t\tret = fidoerr_to_skerr(r);\n\t\tgoto out;\n\t}\n\tif (fido_cred_x5c_ptr(cred) != NULL) {\n\t\tif ((r = fido_cred_verify(cred)) != FIDO_OK) {\n\t\t\tskdebug(__func__, \"fido_cred_verify: %s\",\n\t\t\t    fido_strerr(r));\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tskdebug(__func__, \"self-attested credential\");\n\t\tif ((r = fido_cred_verify_self(cred)) != FIDO_OK) {\n\t\t\tskdebug(__func__, \"fido_cred_verify_self: %s\",\n\t\t\t    fido_strerr(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((response = calloc(1, sizeof(*response))) == NULL) {\n\t\tskdebug(__func__, \"calloc response failed\");\n\t\tgoto out;\n\t}\n\tresponse->flags = flags;\n\tif (pack_public_key(alg, cred, response) != 0) {\n\t\tskdebug(__func__, \"pack_public_key failed\");\n\t\tgoto out;\n\t}\n\tif ((ptr = fido_cred_id_ptr(cred)) != NULL) {\n\t\tlen = fido_cred_id_len(cred);\n\t\tif ((response->key_handle = calloc(1, len)) == NULL) {\n\t\t\tskdebug(__func__, \"calloc key handle failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(response->key_handle, ptr, len);\n\t\tresponse->key_handle_len = len;\n\t}\n\tif ((ptr = fido_cred_sig_ptr(cred)) != NULL) {\n\t\tlen = fido_cred_sig_len(cred);\n\t\tif ((response->signature = calloc(1, len)) == NULL) {\n\t\t\tskdebug(__func__, \"calloc signature failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(response->signature, ptr, len);\n\t\tresponse->signature_len = len;\n\t}\n\tif ((ptr = fido_cred_x5c_ptr(cred)) != NULL) {\n\t\tlen = fido_cred_x5c_len(cred);\n\t\tskdebug(__func__, \"attestation cert len=%zu\", len);\n\t\tif ((response->attestation_cert = calloc(1, len)) == NULL) {\n\t\t\tskdebug(__func__, \"calloc attestation cert failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(response->attestation_cert, ptr, len);\n\t\tresponse->attestation_cert_len = len;\n\t}\n\tif ((ptr = fido_cred_authdata_ptr(cred)) != NULL) {\n\t\tlen = fido_cred_authdata_len(cred);\n\t\tskdebug(__func__, \"authdata len=%zu\", len);\n\t\tif ((response->authdata = calloc(1, len)) == NULL) {\n\t\t\tskdebug(__func__, \"calloc authdata failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(response->authdata, ptr, len);\n\t\tresponse->authdata_len = len;\n\t}\n\t*enroll_response = response;\n\tresponse = NULL;\n\tret = 0;\n out:\n\tfree(device);\n\tif (response != NULL) {\n\t\tfree(response->public_key);\n\t\tfree(response->key_handle);\n\t\tfree(response->signature);\n\t\tfree(response->attestation_cert);\n\t\tfree(response->authdata);\n\t\tfree(response);\n\t}\n\tsk_close(sk);\n\tfido_cred_free(&cred);\n\treturn ret;\n}\n\n#ifdef WITH_OPENSSL\nstatic int\npack_sig_ecdsa(fido_assert_t *assert, struct sk_sign_response *response)\n{\n\tECDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tconst unsigned char *cp;\n\tsize_t sig_len;\n\tint ret = -1;\n\n\tcp = fido_assert_sig_ptr(assert, 0);\n\tsig_len = fido_assert_sig_len(assert, 0);\n\tif ((sig = d2i_ECDSA_SIG(NULL, &cp, sig_len)) == NULL) {\n\t\tskdebug(__func__, \"d2i_ECDSA_SIG failed\");\n\t\tgoto out;\n\t}\n\tECDSA_SIG_get0(sig, &sig_r, &sig_s);\n\tresponse->sig_r_len = BN_num_bytes(sig_r);\n\tresponse->sig_s_len = BN_num_bytes(sig_s);\n\tif ((response->sig_r = calloc(1, response->sig_r_len)) == NULL ||\n\t    (response->sig_s = calloc(1, response->sig_s_len)) == NULL) {\n\t\tskdebug(__func__, \"calloc signature failed\");\n\t\tgoto out;\n\t}\n\tBN_bn2bin(sig_r, response->sig_r);\n\tBN_bn2bin(sig_s, response->sig_s);\n\tret = 0;\n out:\n\tECDSA_SIG_free(sig);\n\tif (ret != 0) {\n\t\tfree(response->sig_r);\n\t\tfree(response->sig_s);\n\t\tresponse->sig_r = NULL;\n\t\tresponse->sig_s = NULL;\n\t}\n\treturn ret;\n}\n#endif  \n\nstatic int\npack_sig_ed25519(fido_assert_t *assert, struct sk_sign_response *response)\n{\n\tconst unsigned char *ptr;\n\tsize_t len;\n\tint ret = -1;\n\n\tptr = fido_assert_sig_ptr(assert, 0);\n\tlen = fido_assert_sig_len(assert, 0);\n\tif (len != 64) {\n\t\tskdebug(__func__, \"bad length %zu\", len);\n\t\tgoto out;\n\t}\n\tresponse->sig_r_len = len;\n\tif ((response->sig_r = calloc(1, response->sig_r_len)) == NULL) {\n\t\tskdebug(__func__, \"calloc signature failed\");\n\t\tgoto out;\n\t}\n\tmemcpy(response->sig_r, ptr, len);\n\tret = 0;\n out:\n\tif (ret != 0) {\n\t\tfree(response->sig_r);\n\t\tresponse->sig_r = NULL;\n\t}\n\treturn ret;\n}\n\nstatic int\npack_sig(uint32_t  alg, fido_assert_t *assert,\n    struct sk_sign_response *response)\n{\n\tswitch(alg) {\n#ifdef WITH_OPENSSL\n\tcase SSH_SK_ECDSA:\n\t\treturn pack_sig_ecdsa(assert, response);\n#endif  \n\tcase SSH_SK_ED25519:\n\t\treturn pack_sig_ed25519(assert, response);\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nstatic int\ncheck_sign_load_resident_options(struct sk_option **options, char **devicep)\n{\n\tsize_t i;\n\n\tif (options == NULL)\n\t\treturn 0;\n\tfor (i = 0; options[i] != NULL; i++) {\n\t\tif (strcmp(options[i]->name, \"device\") == 0) {\n\t\t\tif ((*devicep = strdup(options[i]->value)) == NULL) {\n\t\t\t\tskdebug(__func__, \"strdup device failed\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tskdebug(__func__, \"requested device %s\", *devicep);\n\t\t} else {\n\t\t\tskdebug(__func__, \"requested unsupported option %s\",\n\t\t\t    options[i]->name);\n\t\t\tif (options[i]->required) {\n\t\t\t\tskdebug(__func__, \"unknown required option\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nsk_sign(uint32_t alg, const uint8_t *data, size_t datalen,\n    const char *application,\n    const uint8_t *key_handle, size_t key_handle_len,\n    uint8_t flags, const char *pin, struct sk_option **options,\n    struct sk_sign_response **sign_response)\n{\n\tfido_assert_t *assert = NULL;\n\tchar *device = NULL;\n\tstruct sk_usbhid *sk = NULL;\n\tstruct sk_sign_response *response = NULL;\n\tint ret = SSH_SK_ERR_GENERAL, internal_uv;\n\tint r;\n\n\tfido_init(SSH_FIDO_INIT_ARG);\n\n\tif (sign_response == NULL) {\n\t\tskdebug(__func__, \"sign_response == NULL\");\n\t\tgoto out;\n\t}\n\t*sign_response = NULL;\n\tif (check_sign_load_resident_options(options, &device) != 0)\n\t\tgoto out;  \n\tif (device != NULL)\n\t\tsk = sk_open(device);\n\telse if (pin != NULL || (flags & SSH_SK_USER_VERIFICATION_REQD))\n\t\tsk = sk_probe(NULL, NULL, 0, 0);\n\telse\n\t\tsk = sk_probe(application, key_handle, key_handle_len, 0);\n\tif (sk == NULL) {\n\t\tret = SSH_SK_ERR_DEVICE_NOT_FOUND;\n\t\tskdebug(__func__, \"failed to find sk\");\n\t\tgoto out;\n\t}\n\tif ((assert = fido_assert_new()) == NULL) {\n\t\tskdebug(__func__, \"fido_assert_new failed\");\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_clientdata(assert,\n\t    data, datalen)) != FIDO_OK)  {\n\t\tskdebug(__func__, \"fido_assert_set_clientdata: %s\",\n\t\t    fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_rp(assert, application)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_rp: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_allow_cred(assert, key_handle,\n\t    key_handle_len)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_allow_cred: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\tif ((r = fido_assert_set_up(assert,\n\t    (flags & SSH_SK_USER_PRESENCE_REQD) ?\n\t    FIDO_OPT_TRUE : FIDO_OPT_FALSE)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_up: %s\", fido_strerr(r));\n\t\tgoto out;\n\t}\n\t \n\tif (pin == NULL && fido_dev_is_winhello (sk->dev) &&\n\t    (r = fido_assert_set_uv(assert, FIDO_OPT_FALSE)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_assert_set_uv: %s\", fido_strerr(r));\n\t}\n\tif (pin == NULL && (flags & SSH_SK_USER_VERIFICATION_REQD)) {\n\t\tif (check_sk_options(sk->dev, \"uv\", &internal_uv) < 0 ||\n\t\t    internal_uv != 1) {\n\t\t\tskdebug(__func__, \"check_sk_options uv\");\n\t\t\tret = SSH_SK_ERR_PIN_REQUIRED;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = fido_assert_set_uv(assert,\n\t\t    FIDO_OPT_TRUE)) != FIDO_OK) {\n\t\t\tskdebug(__func__, \"fido_assert_set_uv: %s\",\n\t\t\t    fido_strerr(r));\n\t\t\tret = fidoerr_to_skerr(r);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = fido_dev_get_assert(sk->dev, assert, pin)) != FIDO_OK) {\n\t\tskdebug(__func__, \"fido_dev_get_assert: %s\", fido_strerr(r));\n\t\tret = fidoerr_to_skerr(r);\n\t\tgoto out;\n\t}\n\tif ((response = calloc(1, sizeof(*response))) == NULL) {\n\t\tskdebug(__func__, \"calloc response failed\");\n\t\tgoto out;\n\t}\n\tresponse->flags = fido_assert_flags(assert, 0);\n\tresponse->counter = fido_assert_sigcount(assert, 0);\n\tif (pack_sig(alg, assert, response) != 0) {\n\t\tskdebug(__func__, \"pack_sig failed\");\n\t\tgoto out;\n\t}\n\t*sign_response = response;\n\tresponse = NULL;\n\tret = 0;\n out:\n\tfree(device);\n\tif (response != NULL) {\n\t\tfree(response->sig_r);\n\t\tfree(response->sig_s);\n\t\tfree(response);\n\t}\n\tsk_close(sk);\n\tfido_assert_free(&assert);\n\treturn ret;\n}\n\nstatic int\nread_rks(struct sk_usbhid *sk, const char *pin,\n    struct sk_resident_key ***rksp, size_t *nrksp)\n{\n\tint ret = SSH_SK_ERR_GENERAL, r = -1, internal_uv;\n\tfido_credman_metadata_t *metadata = NULL;\n\tfido_credman_rp_t *rp = NULL;\n\tfido_credman_rk_t *rk = NULL;\n\tsize_t i, j, nrp, nrk, user_id_len;\n\tconst fido_cred_t *cred;\n\tconst char *rp_id, *rp_name, *user_name;\n\tstruct sk_resident_key *srk = NULL, **tmp;\n\tconst u_char *user_id;\n\n\tif (pin == NULL) {\n\t\tskdebug(__func__, \"no PIN specified\");\n\t\tret = SSH_SK_ERR_PIN_REQUIRED;\n\t\tgoto out;\n\t}\n\tif ((metadata = fido_credman_metadata_new()) == NULL) {\n\t\tskdebug(__func__, \"alloc failed\");\n\t\tgoto out;\n\t}\n\tif (check_sk_options(sk->dev, \"uv\", &internal_uv) != 0) {\n\t\tskdebug(__func__, \"check_sk_options failed\");\n\t\tgoto out;\n\t}\n\n\tif ((r = fido_credman_get_dev_metadata(sk->dev, metadata, pin)) != 0) {\n\t\tif (r == FIDO_ERR_INVALID_COMMAND) {\n\t\t\tskdebug(__func__, \"device %s does not support \"\n\t\t\t    \"resident keys\", sk->path);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tskdebug(__func__, \"get metadata for %s failed: %s\",\n\t\t    sk->path, fido_strerr(r));\n\t\tret = fidoerr_to_skerr(r);\n\t\tgoto out;\n\t}\n\tskdebug(__func__, \"existing %llu, remaining %llu\",\n\t    (unsigned long long)fido_credman_rk_existing(metadata),\n\t    (unsigned long long)fido_credman_rk_remaining(metadata));\n\tif ((rp = fido_credman_rp_new()) == NULL) {\n\t\tskdebug(__func__, \"alloc rp failed\");\n\t\tgoto out;\n\t}\n\tif ((r = fido_credman_get_dev_rp(sk->dev, rp, pin)) != 0) {\n\t\tskdebug(__func__, \"get RPs for %s failed: %s\",\n\t\t    sk->path, fido_strerr(r));\n\t\tgoto out;\n\t}\n\tnrp = fido_credman_rp_count(rp);\n\tskdebug(__func__, \"Device %s has resident keys for %zu RPs\",\n\t    sk->path, nrp);\n\n\t \n\tfor (i = 0; i < nrp; i++) {\n\t\trp_id = fido_credman_rp_id(rp, i);\n\t\trp_name = fido_credman_rp_name(rp, i);\n\t\tskdebug(__func__, \"rp %zu: name=\\\"%s\\\" id=\\\"%s\\\" hashlen=%zu\",\n\t\t    i, rp_name == NULL ? \"(none)\" : rp_name,\n\t\t    rp_id == NULL ? \"(none)\" : rp_id,\n\t\t    fido_credman_rp_id_hash_len(rp, i));\n\n\t\t \n\t\tif (rp_id == NULL ||\n\t\t    strncasecmp(fido_credman_rp_id(rp, i), \"ssh:\", 4) != 0)\n\t\t\tcontinue;\n\n\t\tfido_credman_rk_free(&rk);\n\t\tif ((rk = fido_credman_rk_new()) == NULL) {\n\t\t\tskdebug(__func__, \"alloc rk failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = fido_credman_get_dev_rk(sk->dev,\n\t\t    fido_credman_rp_id(rp, i), rk, pin)) != 0) {\n\t\t\tskdebug(__func__, \"get RKs for %s slot %zu failed: %s\",\n\t\t\t    sk->path, i, fido_strerr(r));\n\t\t\tgoto out;\n\t\t}\n\t\tnrk = fido_credman_rk_count(rk);\n\t\tskdebug(__func__, \"RP \\\"%s\\\" has %zu resident keys\",\n\t\t    fido_credman_rp_id(rp, i), nrk);\n\n\t\t \n\t\tfor (j = 0; j < nrk; j++) {\n\t\t\tif ((cred = fido_credman_rk(rk, j)) == NULL) {\n\t\t\t\tskdebug(__func__, \"no RK in slot %zu\", j);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((user_name = fido_cred_user_name(cred)) == NULL)\n\t\t\t\tuser_name = \"\";\n\t\t\tuser_id = fido_cred_user_id_ptr(cred);\n\t\t\tuser_id_len = fido_cred_user_id_len(cred);\n\t\t\tskdebug(__func__, \"Device %s RP \\\"%s\\\" user \\\"%s\\\" \"\n\t\t\t    \"uidlen %zu slot %zu: type %d flags 0x%02x \"\n\t\t\t    \"prot 0x%02x\", sk->path, rp_id, user_name,\n\t\t\t    user_id_len, j, fido_cred_type(cred),\n\t\t\t    fido_cred_flags(cred), fido_cred_prot(cred));\n\n\t\t\t \n\t\t\tif ((srk = calloc(1, sizeof(*srk))) == NULL ||\n\t\t\t    (srk->key.key_handle = calloc(1,\n\t\t\t    fido_cred_id_len(cred))) == NULL ||\n\t\t\t    (srk->application = strdup(rp_id)) == NULL ||\n\t\t\t    (user_id_len > 0 &&\n\t\t\t     (srk->user_id = calloc(1, user_id_len)) == NULL)) {\n\t\t\t\tskdebug(__func__, \"alloc sk_resident_key\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tsrk->key.key_handle_len = fido_cred_id_len(cred);\n\t\t\tmemcpy(srk->key.key_handle, fido_cred_id_ptr(cred),\n\t\t\t    srk->key.key_handle_len);\n\t\t\tsrk->user_id_len = user_id_len;\n\t\t\tif (srk->user_id_len != 0)\n\t\t\t\tmemcpy(srk->user_id, user_id, srk->user_id_len);\n\n\t\t\tswitch (fido_cred_type(cred)) {\n\t\t\tcase COSE_ES256:\n\t\t\t\tsrk->alg = SSH_SK_ECDSA;\n\t\t\t\tbreak;\n\t\t\tcase COSE_EDDSA:\n\t\t\t\tsrk->alg = SSH_SK_ED25519;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tskdebug(__func__, \"unsupported key type %d\",\n\t\t\t\t    fido_cred_type(cred));\n\t\t\t\tgoto out;  \n\t\t\t}\n\n\t\t\tif (fido_cred_prot(cred) == FIDO_CRED_PROT_UV_REQUIRED\n\t\t\t    && internal_uv == -1)\n\t\t\t\tsrk->flags |=  SSH_SK_USER_VERIFICATION_REQD;\n\n\t\t\tif ((r = pack_public_key(srk->alg, cred,\n\t\t\t    &srk->key)) != 0) {\n\t\t\t\tskdebug(__func__, \"pack public key failed\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif ((tmp = recallocarray(*rksp, *nrksp, (*nrksp) + 1,\n\t\t\t    sizeof(**rksp))) == NULL) {\n\t\t\t\tskdebug(__func__, \"alloc rksp\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*rksp = tmp;\n\t\t\t(*rksp)[(*nrksp)++] = srk;\n\t\t\tsrk = NULL;\n\t\t}\n\t}\n\t \n\tret = 0;\n out:\n\tif (srk != NULL) {\n\t\tfree(srk->application);\n\t\tfreezero(srk->key.public_key, srk->key.public_key_len);\n\t\tfreezero(srk->key.key_handle, srk->key.key_handle_len);\n\t\tfreezero(srk->user_id, srk->user_id_len);\n\t\tfreezero(srk, sizeof(*srk));\n\t}\n\tfido_credman_rp_free(&rp);\n\tfido_credman_rk_free(&rk);\n\tfido_credman_metadata_free(&metadata);\n\treturn ret;\n}\n\nint\nsk_load_resident_keys(const char *pin, struct sk_option **options,\n    struct sk_resident_key ***rksp, size_t *nrksp)\n{\n\tint ret = SSH_SK_ERR_GENERAL, r = -1;\n\tsize_t i, nrks = 0;\n\tstruct sk_resident_key **rks = NULL;\n\tstruct sk_usbhid *sk = NULL;\n\tchar *device = NULL;\n\n\t*rksp = NULL;\n\t*nrksp = 0;\n\n\tfido_init(SSH_FIDO_INIT_ARG);\n\n\tif (check_sign_load_resident_options(options, &device) != 0)\n\t\tgoto out;  \n\tif (device != NULL)\n\t\tsk = sk_open(device);\n\telse\n\t\tsk = sk_probe(NULL, NULL, 0, 1);\n\tif (sk == NULL) {\n\t\tret = SSH_SK_ERR_DEVICE_NOT_FOUND;\n\t\tskdebug(__func__, \"failed to find sk\");\n\t\tgoto out;\n\t}\n\tskdebug(__func__, \"trying %s\", sk->path);\n\tif ((r = read_rks(sk, pin, &rks, &nrks)) != 0) {\n\t\tskdebug(__func__, \"read_rks failed for %s\", sk->path);\n\t\tret = r;\n\t\tgoto out;\n\t}\n\t \n\tif (nrks > 0 || ret == SSH_SK_ERR_GENERAL)\n\t\tret = 0;\n\t*rksp = rks;\n\t*nrksp = nrks;\n\trks = NULL;\n\tnrks = 0;\n out:\n\tsk_close(sk);\n\tfor (i = 0; i < nrks; i++) {\n\t\tfree(rks[i]->application);\n\t\tfreezero(rks[i]->key.public_key, rks[i]->key.public_key_len);\n\t\tfreezero(rks[i]->key.key_handle, rks[i]->key.key_handle_len);\n\t\tfreezero(rks[i]->user_id, rks[i]->user_id_len);\n\t\tfreezero(rks[i], sizeof(*rks[i]));\n\t}\n\tfree(device);\n\tfree(rks);\n\treturn ret;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}