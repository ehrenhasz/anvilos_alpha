{
  "module_name": "PROTOCOL.sshsig",
  "hash_id": "98b23514fa8174cbf63370900aa65814abf74483fd3138cc30bae891fb97636e",
  "original_prompt": "Ingested from openssh-9.6p1/PROTOCOL.sshsig",
  "human_readable_source": "This document describes a lightweight SSH Signature format\nthat is compatible with SSH keys and wire formats.\n\nAt present, only detached and armored signatures are supported.\n\n1. Armored format\n\nThe Armored SSH signatures consist of a header, a base64\nencoded blob, and a footer.\n\nThe header is the string \"-----BEGIN SSH SIGNATURE-----\"\nfollowed by a newline. The footer is the string\n\"-----END SSH SIGNATURE-----\" immediately after a newline.\n\nThe header MUST be present at the start of every signature.\nFiles containing the signature MUST start with the header.\nLikewise, the footer MUST be present at the end of every\nsignature.\n\nThe base64 encoded blob SHOULD be broken up by newlines\nevery 76 characters.\n\nExample:\n\n-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgJKxoLBJBivUPNTUJUSslQTt2hD\njozKvHarKeN8uYFqgAAAADZm9vAAAAAAAAAFMAAAALc3NoLWVkMjU1MTkAAABAKNC4IEbt\nTq0Fb56xhtuE1/lK9H9RZJfON4o6hE9R4ZGFX98gy0+fFJ/1d2/RxnZky0Y7GojwrZkrHT\nFgCqVWAQ==\n-----END SSH SIGNATURE-----\n\n2. Blob format\n\n#define MAGIC_PREAMBLE \"SSHSIG\"\n#define SIG_VERSION    0x01\n\n        byte[6]   MAGIC_PREAMBLE\n        uint32    SIG_VERSION\n        string    publickey\n        string    namespace\n        string    reserved\n        string    hash_algorithm\n        string    signature\n\nThe publickey field MUST contain the serialisation of the\npublic key used to make the signature using the usual SSH\nencoding rules, i.e RFC4253, RFC5656,\ndraft-ietf-curdle-ssh-ed25519-ed448, etc.\n\nVerifiers MUST reject signatures with versions greater than those\nthey support.\n\nThe purpose of the namespace value is to specify a unambiguous\ninterpretation domain for the signature, e.g. file signing.\nThis prevents cross-protocol attacks caused by signatures\nintended for one intended domain being accepted in another.\nThe namespace value MUST NOT be the empty string.\n\nThe reserved value is present to encode future information\n(e.g. tags) into the signature. Implementations should ignore\nthe reserved field if it is not empty.\n\nData to be signed is first hashed with the specified hash_algorithm.\nThis is done to limit the amount of data presented to the signature\noperation, which may be of concern if the signing key is held in limited\nor slow hardware or on a remote ssh-agent. The supported hash algorithms\nare \"sha256\" and \"sha512\".\n\nThe signature itself is made using the SSH signature algorithm and\nencoding rules for the chosen key type. For RSA signatures, the\nsignature algorithm must be \"rsa-sha2-512\" or \"rsa-sha2-256\" (i.e.\nnot the legacy RSA-SHA1 \"ssh-rsa\").\n\nThis blob is encoded as a string using the RFC4253 encoding\nrules and base64 encoded to form the middle part of the\narmored signature.\n\n\n3. Signed Data, of which the signature goes into the blob above\n\n#define MAGIC_PREAMBLE \"SSHSIG\"\n\n        byte[6]   MAGIC_PREAMBLE\n        string    namespace\n        string    reserved\n        string    hash_algorithm\n        string    H(message)\n\nThe preamble is the six-byte sequence \"SSHSIG\". It is included to\nensure that manual signatures can never be confused with any message\nsigned during SSH user or host authentication.\n\nThe reserved value is present to encode future information\n(e.g. tags) into the signature. Implementations should ignore\nthe reserved field if it is not empty.\n\nThe data is concatenated and passed to the SSH signing\nfunction.\n\n$OpenBSD: PROTOCOL.sshsig,v 1.4 2020/08/31 00:17:41 djm Exp $\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}