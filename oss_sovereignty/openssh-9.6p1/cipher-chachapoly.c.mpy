{
  "module_name": "cipher-chachapoly.c",
  "hash_id": "4d4a5d4cff67a54c8e2f8ebda919dfe94057650bd9522256bce40eab1cba31f9",
  "original_prompt": "Ingested from openssh-9.6p1/cipher-chachapoly.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n#ifdef WITH_OPENSSL\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#if !defined(HAVE_EVP_CHACHA20) || defined(HAVE_BROKEN_CHACHA20)\n\n#include <sys/types.h>\n#include <stdarg.h>  \n#include <string.h>\n#include <stdio.h>   \n\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"cipher-chachapoly.h\"\n\nstruct chachapoly_ctx {\n\tstruct chacha_ctx main_ctx, header_ctx;\n};\n\nstruct chachapoly_ctx *\nchachapoly_new(const u_char *key, u_int keylen)\n{\n\tstruct chachapoly_ctx *ctx;\n\n\tif (keylen != (32 + 32))  \n\t\treturn NULL;\n\tif ((ctx = calloc(1, sizeof(*ctx))) == NULL)\n\t\treturn NULL;\n\tchacha_keysetup(&ctx->main_ctx, key, 256);\n\tchacha_keysetup(&ctx->header_ctx, key + 32, 256);\n\treturn ctx;\n}\n\nvoid\nchachapoly_free(struct chachapoly_ctx *cpctx)\n{\n\tfreezero(cpctx, sizeof(*cpctx));\n}\n\n \nint\nchachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,\n    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)\n{\n\tu_char seqbuf[8];\n\tconst u_char one[8] = { 1, 0, 0, 0, 0, 0, 0, 0 };  \n\tu_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tmemset(poly_key, 0, sizeof(poly_key));\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->main_ctx,\n\t    poly_key, poly_key, sizeof(poly_key));\n\n\t \n\tif (!do_encrypt) {\n\t\tconst u_char *tag = src + aadlen + len;\n\n\t\tpoly1305_auth(expected_tag, src, aadlen + len, poly_key);\n\t\tif (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n\t\t\tr = SSH_ERR_MAC_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (aadlen) {\n\t\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\t\tchacha_encrypt_bytes(&ctx->header_ctx, src, dest, aadlen);\n\t}\n\n\t \n\tchacha_ivsetup(&ctx->main_ctx, seqbuf, one);\n\tchacha_encrypt_bytes(&ctx->main_ctx, src + aadlen,\n\t    dest + aadlen, len);\n\n\t \n\tif (do_encrypt) {\n\t\tpoly1305_auth(dest + aadlen + len, dest, aadlen + len,\n\t\t    poly_key);\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(expected_tag, sizeof(expected_tag));\n\texplicit_bzero(seqbuf, sizeof(seqbuf));\n\texplicit_bzero(poly_key, sizeof(poly_key));\n\treturn r;\n}\n\n \nint\nchachapoly_get_length(struct chachapoly_ctx *ctx,\n    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)\n{\n\tu_char buf[4], seqbuf[8];\n\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tPOKE_U64(seqbuf, seqnr);\n\tchacha_ivsetup(&ctx->header_ctx, seqbuf, NULL);\n\tchacha_encrypt_bytes(&ctx->header_ctx, cp, buf, 4);\n\t*plenp = PEEK_U32(buf);\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}