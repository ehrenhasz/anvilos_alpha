{
  "module_name": "sshbuf.c",
  "hash_id": "bbfe293ce805a31f13daf641a84055f911cf1d1b4f6f4818056a4ebe1f951881",
  "original_prompt": "Ingested from openssh-9.6p1/sshbuf.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"ssherr.h\"\n#define SSHBUF_INTERNAL\n#include \"sshbuf.h\"\n#include \"misc.h\"\n\n#ifdef SSHBUF_DEBUG\n# define SSHBUF_TELL(what) do { \\\n\t\tprintf(\"%s:%d %s: %s size %zu alloc %zu off %zu max %zu\\n\", \\\n\t\t    __FILE__, __LINE__, __func__, what, \\\n\t\t    buf->size, buf->alloc, buf->off, buf->max_size); \\\n\t\tfflush(stdout); \\\n\t} while (0)\n#else\n# define SSHBUF_TELL(what)\n#endif\n\nstruct sshbuf {\n\tu_char *d;\t\t \n\tconst u_char *cd;\t \n\tsize_t off;\t\t \n\tsize_t size;\t\t \n\tsize_t max_size;\t \n\tsize_t alloc;\t\t \n\tint readonly;\t\t \n\tu_int refcount;\t\t \n\tstruct sshbuf *parent;\t \n};\n\nstatic inline int\nsshbuf_check_sanity(const struct sshbuf *buf)\n{\n\tSSHBUF_TELL(\"sanity\");\n\tif (__predict_false(buf == NULL ||\n\t    (!buf->readonly && buf->d != buf->cd) ||\n\t    buf->refcount < 1 || buf->refcount > SSHBUF_REFS_MAX ||\n\t    buf->cd == NULL ||\n\t    buf->max_size > SSHBUF_SIZE_MAX ||\n\t    buf->alloc > buf->max_size ||\n\t    buf->size > buf->alloc ||\n\t    buf->off > buf->size)) {\n\t\t \n\t\tSSHBUF_DBG((\"SSH_ERR_INTERNAL_ERROR\"));\n\t\tssh_signal(SIGSEGV, SIG_DFL);\n\t\traise(SIGSEGV);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}\n\nstatic void\nsshbuf_maybe_pack(struct sshbuf *buf, int force)\n{\n\tSSHBUF_DBG((\"force %d\", force));\n\tSSHBUF_TELL(\"pre-pack\");\n\tif (buf->off == 0 || buf->readonly || buf->refcount > 1)\n\t\treturn;\n\tif (force ||\n\t    (buf->off >= SSHBUF_PACK_MIN && buf->off >= buf->size / 2)) {\n\t\tmemmove(buf->d, buf->d + buf->off, buf->size - buf->off);\n\t\tbuf->size -= buf->off;\n\t\tbuf->off = 0;\n\t\tSSHBUF_TELL(\"packed\");\n\t}\n}\n\nstruct sshbuf *\nsshbuf_new(void)\n{\n\tstruct sshbuf *ret;\n\n\tif ((ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = SSHBUF_SIZE_INIT;\n\tret->max_size = SSHBUF_SIZE_MAX;\n\tret->readonly = 0;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tif ((ret->cd = ret->d = calloc(1, ret->alloc)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstruct sshbuf *\nsshbuf_from(const void *blob, size_t len)\n{\n\tstruct sshbuf *ret;\n\n\tif (blob == NULL || len > SSHBUF_SIZE_MAX ||\n\t    (ret = calloc(sizeof(*ret), 1)) == NULL)\n\t\treturn NULL;\n\tret->alloc = ret->size = ret->max_size = len;\n\tret->readonly = 1;\n\tret->refcount = 1;\n\tret->parent = NULL;\n\tret->cd = blob;\n\tret->d = NULL;\n\treturn ret;\n}\n\nint\nsshbuf_set_parent(struct sshbuf *child, struct sshbuf *parent)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(child)) != 0 ||\n\t    (r = sshbuf_check_sanity(parent)) != 0)\n\t\treturn r;\n\tif (child->parent != NULL && child->parent != parent)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tchild->parent = parent;\n\tchild->parent->refcount++;\n\treturn 0;\n}\n\nstruct sshbuf *\nsshbuf_fromb(struct sshbuf *buf)\n{\n\tstruct sshbuf *ret;\n\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\tif ((ret = sshbuf_from(sshbuf_ptr(buf), sshbuf_len(buf))) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_set_parent(ret, buf) != 0) {\n\t\tsshbuf_free(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nvoid\nsshbuf_free(struct sshbuf *buf)\n{\n\tif (buf == NULL)\n\t\treturn;\n\t \n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\n\t \n\tbuf->refcount--;\n\tif (buf->refcount > 0)\n\t\treturn;\n\n\t \n\tsshbuf_free(buf->parent);\n\tbuf->parent = NULL;\n\n\tif (!buf->readonly) {\n\t\texplicit_bzero(buf->d, buf->alloc);\n\t\tfree(buf->d);\n\t}\n\tfreezero(buf, sizeof(*buf));\n}\n\nvoid\nsshbuf_reset(struct sshbuf *buf)\n{\n\tu_char *d;\n\n\tif (buf->readonly || buf->refcount > 1) {\n\t\t \n\t\tbuf->off = buf->size;\n\t\treturn;\n\t}\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn;\n\tbuf->off = buf->size = 0;\n\tif (buf->alloc != SSHBUF_SIZE_INIT) {\n\t\tif ((d = recallocarray(buf->d, buf->alloc, SSHBUF_SIZE_INIT,\n\t\t    1)) != NULL) {\n\t\t\tbuf->cd = buf->d = d;\n\t\t\tbuf->alloc = SSHBUF_SIZE_INIT;\n\t\t}\n\t}\n\texplicit_bzero(buf->d, buf->alloc);\n}\n\nsize_t\nsshbuf_max_size(const struct sshbuf *buf)\n{\n\treturn buf->max_size;\n}\n\nsize_t\nsshbuf_alloc(const struct sshbuf *buf)\n{\n\treturn buf->alloc;\n}\n\nconst struct sshbuf *\nsshbuf_parent(const struct sshbuf *buf)\n{\n\treturn buf->parent;\n}\n\nu_int\nsshbuf_refcount(const struct sshbuf *buf)\n{\n\treturn buf->refcount;\n}\n\nint\nsshbuf_set_max_size(struct sshbuf *buf, size_t max_size)\n{\n\tsize_t rlen;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"set max buf = %p len = %zu\", buf, max_size));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (max_size == buf->max_size)\n\t\treturn 0;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tif (max_size > SSHBUF_SIZE_MAX)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\t \n\tsshbuf_maybe_pack(buf, max_size < buf->size);\n\tif (max_size < buf->alloc && max_size > buf->size) {\n\t\tif (buf->size < SSHBUF_SIZE_INIT)\n\t\t\trlen = SSHBUF_SIZE_INIT;\n\t\telse\n\t\t\trlen = ROUNDUP(buf->size, SSHBUF_SIZE_INC);\n\t\tif (rlen > max_size)\n\t\t\trlen = max_size;\n\t\tSSHBUF_DBG((\"new alloc = %zu\", rlen));\n\t\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tbuf->cd = buf->d = dp;\n\t\tbuf->alloc = rlen;\n\t}\n\tSSHBUF_TELL(\"new-max\");\n\tif (max_size < buf->alloc)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\tbuf->max_size = max_size;\n\treturn 0;\n}\n\nsize_t\nsshbuf_len(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn 0;\n\treturn buf->size - buf->off;\n}\n\nsize_t\nsshbuf_avail(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn 0;\n\treturn buf->max_size - (buf->size - buf->off);\n}\n\nconst u_char *\nsshbuf_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0)\n\t\treturn NULL;\n\treturn buf->cd + buf->off;\n}\n\nu_char *\nsshbuf_mutable_ptr(const struct sshbuf *buf)\n{\n\tif (sshbuf_check_sanity(buf) != 0 || buf->readonly || buf->refcount > 1)\n\t\treturn NULL;\n\treturn buf->d + buf->off;\n}\n\nint\nsshbuf_check_reserve(const struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (buf->readonly || buf->refcount > 1)\n\t\treturn SSH_ERR_BUFFER_READ_ONLY;\n\tSSHBUF_TELL(\"check\");\n\t \n\tif (len > buf->max_size || buf->max_size - len < buf->size - buf->off)\n\t\treturn SSH_ERR_NO_BUFFER_SPACE;\n\treturn 0;\n}\n\nint\nsshbuf_allocate(struct sshbuf *buf, size_t len)\n{\n\tsize_t rlen, need;\n\tu_char *dp;\n\tint r;\n\n\tSSHBUF_DBG((\"allocate buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_check_reserve(buf, len)) != 0)\n\t\treturn r;\n\t \n\tsshbuf_maybe_pack(buf, buf->size + len > buf->max_size);\n\tSSHBUF_TELL(\"allocate\");\n\tif (len + buf->size <= buf->alloc)\n\t\treturn 0;  \n\n\t \n\tneed = len + buf->size - buf->alloc;\n\trlen = ROUNDUP(buf->alloc + need, SSHBUF_SIZE_INC);\n\tSSHBUF_DBG((\"need %zu initial rlen %zu\", need, rlen));\n\tif (rlen > buf->max_size)\n\t\trlen = buf->alloc + need;\n\tSSHBUF_DBG((\"adjusted rlen %zu\", rlen));\n\tif ((dp = recallocarray(buf->d, buf->alloc, rlen, 1)) == NULL) {\n\t\tSSHBUF_DBG((\"realloc fail\"));\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tbuf->alloc = rlen;\n\tbuf->cd = buf->d = dp;\n\tif ((r = sshbuf_check_reserve(buf, len)) < 0) {\n\t\t \n\t\treturn r;\n\t}\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}\n\nint\nsshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)\n{\n\tu_char *dp;\n\tint r;\n\n\tif (dpp != NULL)\n\t\t*dpp = NULL;\n\n\tSSHBUF_DBG((\"reserve buf = %p len = %zu\", buf, len));\n\tif ((r = sshbuf_allocate(buf, len)) != 0)\n\t\treturn r;\n\n\tdp = buf->d + buf->size;\n\tbuf->size += len;\n\tif (dpp != NULL)\n\t\t*dpp = dp;\n\treturn 0;\n}\n\nint\nsshbuf_consume(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->off += len;\n\t \n\tif (buf->off == buf->size)\n\t\tbuf->off = buf->size = 0;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}\n\nint\nsshbuf_consume_end(struct sshbuf *buf, size_t len)\n{\n\tint r;\n\n\tSSHBUF_DBG((\"len = %zu\", len));\n\tif ((r = sshbuf_check_sanity(buf)) != 0)\n\t\treturn r;\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > sshbuf_len(buf))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tbuf->size -= len;\n\tSSHBUF_TELL(\"done\");\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}