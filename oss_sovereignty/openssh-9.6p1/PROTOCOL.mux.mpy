{
  "module_name": "PROTOCOL.mux",
  "hash_id": "4286abecf53c8209cac2325a59af0992409a5d383c522490d189b542099dd5d6",
  "original_prompt": "Ingested from openssh-9.6p1/PROTOCOL.mux",
  "human_readable_source": "This document describes the multiplexing protocol used by ssh(1)'s\nControlMaster connection-sharing.\n\nMultiplexing starts with a ssh(1) configured to act as a multiplexing\nmaster. This will cause ssh(1) to listen on a Unix domain socket for\nrequests from clients. Clients communicate over this socket using a\nsimple packetised protocol, where each message is proceeded with\na length and message type in SSH uint32 wire format:\n\n    uint32  packet length\n    uint32  packet type\n    ...     packet body\n\nMost messages from the client to the server contain a \"request id\"\nfield. This field is returned in replies as \"client request id\" to\nfacilitate matching of responses to requests.\n\nMany multiplexing (mux) client requests yield immediate responses from\nthe mux process; requesting a forwarding, performing an alive check or\nrequesting the master terminate itself fall in to this category.\n\nThe most common use of multiplexing however is to maintain multiple\nconcurrent sessions. These are supported via two separate modes:\n\n\"Passenger\" clients start by requesting a new session with a\nMUX_C_NEW_SESSION message and passing stdio file descriptors over the\nUnix domain control socket. The passenger client then waits until it is\nsignaled or the mux server closes the session. This mode is so named as\nthe client waits around while the mux server does all the driving.\n\nStdio forwarding (requested using MUX_C_NEW_STDIO_FWD) is another\nexample of passenger mode; the client passes the stdio file descriptors\nand passively waits for something to happen.\n\n\"Proxy\" clients, requested using MUX_C_PROXY, work quite differently. In\nthis mode, the mux client/server connection socket will stop speaking\nthe multiplexing protocol and start proxying SSH connection protocol\nmessages between the client and server. The client therefore must\nspeak a significant subset of the SSH protocol, but in return is able\nto access basically the full suite of connection protocol features.\nMoreover, as no file descriptor passing is required, the connection\nsupporting a proxy client may itself be forwarded or relayed to another\nhost if necessary.\n\n1. Connection setup\n\nWhen a multiplexing connection is made to a ssh(1) operating as a\nControlMaster from a client ssh(1), the first action of each is send\na hello messages to its peer:\n\n\tuint32\tMUX_MSG_HELLO\n\tuint32  protocol version\n\tstring  extension name [optional]\n\tstring  extension value [optional]\n\t...\n\nThe current version of the mux protocol is 4. A client should refuse\nto connect to a master that speaks an unsupported protocol version.\n\nFollowing the version identifier are zero or more extensions represented\nas a name/value pair. No extensions are currently defined.\n\n2. Opening a passenger mode session\n\nTo open a new multiplexed session in passenger mode, a client sends the\nfollowing request:\n\n\tuint32\tMUX_C_NEW_SESSION\n\tuint32  request id\n\tstring\treserved\n\tbool\twant tty flag\n\tbool\twant X11 forwarding flag\n\tbool\twant agent flag\n\tbool\tsubsystem flag\n\tuint32\tescape char\n\tstring\tterminal type\n\tstring\tcommand\n\tstring\tenvironment string 0 [optional]\n\t...\n\nTo disable the use of an escape character, \"escape char\" may be set\nto 0xffffffff. \"terminal type\" is generally set to the value of\n$TERM. zero or more environment strings may follow the command.\n\nThe client then sends its standard input, output and error file\ndescriptors (in that order) using Unix domain socket control messages.\n\nThe contents of \"reserved\" are currently ignored.\n\nIf successful, the server will reply with MUX_S_SESSION_OPENED\n\n\tuint32\tMUX_S_SESSION_OPENED\n\tuint32\tclient request id\n\tuint32\tsession id\n\nOtherwise it will reply with an error: MUX_S_PERMISSION_DENIED or\nMUX_S_FAILURE.\n\nOnce the server has received the fds, it will respond with MUX_S_OK\nindicating that the session is up. The client now waits for the\nsession to end. When it does, the server will send an exit status\nmessage:\n\n\tuint32\tMUX_S_EXIT_MESSAGE\n\tuint32\tsession id\n\tuint32\texit value\n\nThe client should exit with this value to mimic the behaviour of a\nnon-multiplexed ssh(1) connection. Two additional cases that the\nclient must cope with are it receiving a signal itself and the\nserver disconnecting without sending an exit message.\n\nA master may also send a MUX_S_TTY_ALLOC_FAIL before MUX_S_EXIT_MESSAGE\nif remote TTY allocation was unsuccessful. The client may use this to\nreturn its local tty to \"cooked\" mode.\n\n\tuint32\tMUX_S_TTY_ALLOC_FAIL\n\tuint32\tsession id\n\n3. Requesting passenger-mode stdio forwarding\n\nA client may request the master to establish a stdio forwarding:\n\n\tuint32\tMUX_C_NEW_STDIO_FWD\n\tuint32\trequest id\n\tstring\treserved\n\tstring\tconnect host\n\tstring\tconnect port\n\nThe client then sends its standard input and output file descriptors\n(in that order) using Unix domain socket control messages.\n\nThe contents of \"reserved\" are currently ignored.\n\nA server may reply with a MUX_S_SESSION_OPENED, a MUX_S_PERMISSION_DENIED\nor a MUX_S_FAILURE.\n\n4. Health checks\n\nThe client may request a health check/PID report from a server:\n\n\tuint32\tMUX_C_ALIVE_CHECK\n\tuint32\trequest id\n\nThe server replies with:\n\n\tuint32\tMUX_S_ALIVE\n\tuint32\tclient request id\n\tuint32\tserver pid\n\n5. Remotely terminating a master\n\nA client may request that a master terminate immediately:\n\n\tuint32\tMUX_C_TERMINATE\n\tuint32\trequest id\n\nThe server will reply with one of MUX_S_OK or MUX_S_PERMISSION_DENIED.\n\n6. Requesting establishment of port forwards\n\nA client may request the master to establish a port forward:\n\n\tuint32\tMUX_C_OPEN_FWD\n\tuint32\trequest id\n\tuint32\tforwarding type\n\tstring\tlisten host\n\tuint32\tlisten port\n\tstring\tconnect host\n\tuint32\tconnect port\n\nforwarding type may be MUX_FWD_LOCAL, MUX_FWD_REMOTE, MUX_FWD_DYNAMIC.\n\nIf listen port is (unsigned int) -2, then the listen host is treated as\na unix socket path name.\n\nIf connect port is (unsigned int) -2, then the connect host is treated\nas a unix socket path name.\n\nA server may reply with a MUX_S_OK, a MUX_S_REMOTE_PORT, a\nMUX_S_PERMISSION_DENIED or a MUX_S_FAILURE.\n\nFor dynamically allocated listen port the server replies with\n\n\tuint32\tMUX_S_REMOTE_PORT\n\tuint32\tclient request id\n\tuint32\tallocated remote listen port\n\n7. Requesting closure of port forwards\n\nNote: currently unimplemented (server will always reply with MUX_S_FAILURE).\n\nA client may request the master to close a port forward:\n\n\tuint32\tMUX_C_CLOSE_FWD\n\tuint32\trequest id\n\tuint32\tforwarding type\n\tstring\tlisten host\n\tuint32\tlisten port\n\tstring\tconnect host\n\tuint32\tconnect port\n\nA server may reply with a MUX_S_OK, a MUX_S_PERMISSION_DENIED or a\nMUX_S_FAILURE.\n\n8. Requesting shutdown of mux listener\n\nA client may request the master to stop accepting new multiplexing requests\nand remove its listener socket.\n\n\tuint32\tMUX_C_STOP_LISTENING\n\tuint32\trequest id\n\nA server may reply with a MUX_S_OK, a MUX_S_PERMISSION_DENIED or a\nMUX_S_FAILURE.\n\n9. Requesting proxy mode\n\nA client may request that the control connection be placed in proxy\nmode:\n\n\tuint32\tMUX_C_PROXY\n\tuint32\trequest id\n\nWhen a mux master receives this message, it will reply with a\nconfirmation:\n\n\tuint32\tMUX_S_PROXY\n\tuint32\trequest id\n\nAnd go into proxy mode. All subsequent data over the connection will\nbe formatted as unencrypted, unpadded, SSH transport messages:\n\n\tuint32\tpacket length\n\tbyte\t0 (padding length)\n\tbyte\tpacket type\n\tbyte[packet length - 2] ...\n\nThe mux master will accept most connection messages and global requests,\nand will translate channel identifiers to ensure that the proxy client has\nglobally unique channel numbers (i.e. a proxy client need not worry about\ncollisions with other clients).\n\n10. Status messages\n\nThe MUX_S_OK message is empty:\n\n\tuint32\tMUX_S_OK\n\tuint32\tclient request id\n\nThe MUX_S_PERMISSION_DENIED and MUX_S_FAILURE include a reason:\n\n\tuint32\tMUX_S_PERMISSION_DENIED\n\tuint32\tclient request id\n\tstring\treason\n\n\tuint32\tMUX_S_FAILURE\n\tuint32\tclient request id\n\tstring\treason\n\n11. Protocol numbers\n\n#define MUX_MSG_HELLO\t\t0x00000001\n#define MUX_C_NEW_SESSION\t0x10000002\n#define MUX_C_ALIVE_CHECK\t0x10000004\n#define MUX_C_TERMINATE\t\t0x10000005\n#define MUX_C_OPEN_FWD\t\t0x10000006\n#define MUX_C_CLOSE_FWD\t\t0x10000007\n#define MUX_C_NEW_STDIO_FWD\t0x10000008\n#define MUX_C_STOP_LISTENING\t0x10000009\n#define MUX_S_OK\t\t0x80000001\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_EXIT_MESSAGE\t0x80000004\n#define MUX_S_ALIVE\t\t0x80000005\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_REMOTE_PORT\t0x80000007\n#define MUX_S_TTY_ALLOC_FAIL\t0x80000008\n\n#define MUX_FWD_LOCAL\t1\n#define MUX_FWD_REMOTE\t2\n#define MUX_FWD_DYNAMIC\t3\n\nXXX TODO\nXXX extended status (e.g. report open channels / forwards)\nXXX lock (maybe)\nXXX watch in/out traffic (pre/post crypto)\nXXX inject packet (what about replies)\nXXX server->client error/warning notifications\nXXX send signals via mux\nXXX ^Z support in passengers\nXXX extensions for multi-agent\nXXX extensions for multi-X11\nXXX session inspection via master\nXXX signals via mux request\nXXX list active connections via mux\n\n$OpenBSD: PROTOCOL.mux,v 1.13 2022/01/01 01:55:30 jsg Exp $\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}