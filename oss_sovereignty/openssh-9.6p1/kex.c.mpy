{
  "module_name": "kex.c",
  "hash_id": "5991e3d0fbff414ffe3c71779ca17c9de84050f72907def2070266cf0503d747",
  "original_prompt": "Ingested from openssh-9.6p1/kex.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n\n#ifdef WITH_OPENSSL\n#include <openssl/crypto.h>\n#include <openssl/dh.h>\n#endif\n\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"atomicio.h\"\n#include \"version.h\"\n#include \"packet.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"log.h\"\n#include \"mac.h\"\n#include \"match.h\"\n#include \"misc.h\"\n#include \"dispatch.h\"\n#include \"monitor.h\"\n#include \"myproposal.h\"\n\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"digest.h\"\n#include \"xmalloc.h\"\n\n \nstatic int kex_choose_conf(struct ssh *, uint32_t seq);\nstatic int kex_input_newkeys(int, u_int32_t, struct ssh *);\n\nstatic const char * const proposal_names[PROPOSAL_MAX] = {\n\t\"KEX algorithms\",\n\t\"host key algorithms\",\n\t\"ciphers ctos\",\n\t\"ciphers stoc\",\n\t\"MACs ctos\",\n\t\"MACs stoc\",\n\t\"compression ctos\",\n\t\"compression stoc\",\n\t\"languages ctos\",\n\t\"languages stoc\",\n};\n\nstruct kexalg {\n\tchar *name;\n\tu_int type;\n\tint ec_nid;\n\tint hash_alg;\n};\nstatic const struct kexalg kexalgs[] = {\n#ifdef WITH_OPENSSL\n\t{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA1, KEX_DH_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },\n\t{ KEX_DH14_SHA256, KEX_DH_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },\n\t{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },\n#ifdef HAVE_EVP_SHA256\n\t{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },\n#endif  \n#ifdef OPENSSL_HAS_ECC\n\t{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,\n\t    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },\n\t{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,\n\t    SSH_DIGEST_SHA384 },\n# ifdef OPENSSL_HAS_NISTP521\n\t{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,\n\t    SSH_DIGEST_SHA512 },\n# endif  \n#endif  \n#endif  \n#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)\n\t{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n\t{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },\n#ifdef USE_SNTRUP761X25519\n\t{ KEX_SNTRUP761X25519_SHA512, KEX_KEM_SNTRUP761X25519_SHA512, 0,\n\t    SSH_DIGEST_SHA512 },\n#endif\n#endif  \n\t{ NULL, 0, -1, -1},\n};\n\nchar *\nkex_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(k->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, k->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}\n\nstatic const struct kexalg *\nkex_alg_by_name(const char *name)\n{\n\tconst struct kexalg *k;\n\n\tfor (k = kexalgs; k->name != NULL; k++) {\n\t\tif (strcmp(k->name, name) == 0)\n\t\t\treturn k;\n\t}\n\treturn NULL;\n}\n\n \nint\nkex_names_valid(const char *names)\n{\n\tchar *s, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\tif (kex_alg_by_name(p) == NULL) {\n\t\t\terror(\"Unsupported KEX algorithm \\\"%.100s\\\"\", p);\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdebug3(\"kex names ok: [%s]\", names);\n\tfree(s);\n\treturn 1;\n}\n\n \nstatic int\nhas_any_alg(const char *proposal, const char *algs)\n{\n\tchar *cp;\n\n\tif ((cp = match_list(proposal, algs, NULL)) == NULL)\n\t\treturn 0;\n\tfree(cp);\n\treturn 1;\n}\n\n \nchar *\nkex_names_cat(const char *a, const char *b)\n{\n\tchar *ret = NULL, *tmp = NULL, *cp, *p;\n\tsize_t len;\n\n\tif (a == NULL || *a == '\\0')\n\t\treturn strdup(b);\n\tif (b == NULL || *b == '\\0')\n\t\treturn strdup(a);\n\tif (strlen(b) > 1024*1024)\n\t\treturn NULL;\n\tlen = strlen(a) + strlen(b) + 2;\n\tif ((tmp = cp = strdup(b)) == NULL ||\n\t    (ret = calloc(1, len)) == NULL) {\n\t\tfree(tmp);\n\t\treturn NULL;\n\t}\n\tstrlcpy(ret, a, len);\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0'; (p = strsep(&cp, \",\"))) {\n\t\tif (has_any_alg(ret, p))\n\t\t\tcontinue;  \n\t\tif (strlcat(ret, \",\", len) >= len ||\n\t\t    strlcat(ret, p, len) >= len) {\n\t\t\tfree(tmp);\n\t\t\tfree(ret);\n\t\t\treturn NULL;  \n\t\t}\n\t}\n\tfree(tmp);\n\treturn ret;\n}\n\n \nint\nkex_assemble_names(char **listp, const char *def, const char *all)\n{\n\tchar *cp, *tmp, *patterns;\n\tchar *list = NULL, *ret = NULL, *matching = NULL, *opatterns = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (listp == NULL || def == NULL || all == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (*listp == NULL || **listp == '\\0') {\n\t\tif ((*listp = strdup(def)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\t}\n\n\tlist = *listp;\n\t*listp = NULL;\n\tif (*list == '+') {\n\t\t \n\t\tif ((tmp = kex_names_cat(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\tlist = tmp;\n\t} else if (*list == '-') {\n\t\t \n\t\tif ((*listp = match_filter_denylist(def, list + 1)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\t \n\t\treturn 0;\n\t} else if (*list == '^') {\n\t\t \n\t\tif ((tmp = kex_names_cat(list + 1, def)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(list);\n\t\tlist = tmp;\n\t} else {\n\t\t \n\t}\n\n\t \n\tret = NULL;\n\tif ((patterns = opatterns = strdup(list)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\t \n\twhile ((cp = strsep(&patterns, \",\")) != NULL) {\n\t\tif (*cp == '!') {\n\t\t\t \n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(matching);\n\t\tif ((matching = match_filter_allowlist(all, cp)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((tmp = kex_names_cat(ret, matching)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(ret);\n\t\tret = tmp;\n\t}\n\tif (ret == NULL || *ret == '\\0') {\n\t\t \n\t\t \n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto fail;\n\t}\n\n\t \n\t*listp = ret;\n\tret = NULL;\n\tr = 0;\n\n fail:\n\tfree(matching);\n\tfree(opatterns);\n\tfree(list);\n\tfree(ret);\n\treturn r;\n}\n\n \nvoid\nkex_proposal_populate_entries(struct ssh *ssh, char *prop[PROPOSAL_MAX],\n    const char *kexalgos, const char *ciphers, const char *macs,\n    const char *comp, const char *hkalgs)\n{\n\tconst char *defpropserver[PROPOSAL_MAX] = { KEX_SERVER };\n\tconst char *defpropclient[PROPOSAL_MAX] = { KEX_CLIENT };\n\tconst char **defprop = ssh->kex->server ? defpropserver : defpropclient;\n\tu_int i;\n\tchar *cp;\n\n\tif (prop == NULL)\n\t\tfatal_f(\"proposal missing\");\n\n\t \n\tif (kexalgos == NULL)\n\t\tkexalgos = defprop[PROPOSAL_KEX_ALGS];\n\tif ((cp = kex_names_cat(kexalgos, ssh->kex->server ?\n\t    \"ext-info-s,kex-strict-s-v00@openssh.com\" :\n\t    \"ext-info-c,kex-strict-c-v00@openssh.com\")) == NULL)\n\t\tfatal_f(\"kex_names_cat\");\n\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tswitch(i) {\n\t\tcase PROPOSAL_KEX_ALGS:\n\t\t\tprop[i] = compat_kex_proposal(ssh, cp);\n\t\t\tbreak;\n\t\tcase PROPOSAL_ENC_ALGS_CTOS:\n\t\tcase PROPOSAL_ENC_ALGS_STOC:\n\t\t\tprop[i] = xstrdup(ciphers ? ciphers : defprop[i]);\n\t\t\tbreak;\n\t\tcase PROPOSAL_MAC_ALGS_CTOS:\n\t\tcase PROPOSAL_MAC_ALGS_STOC:\n\t\t\tprop[i]  = xstrdup(macs ? macs : defprop[i]);\n\t\t\tbreak;\n\t\tcase PROPOSAL_COMP_ALGS_CTOS:\n\t\tcase PROPOSAL_COMP_ALGS_STOC:\n\t\t\tprop[i] = xstrdup(comp ? comp : defprop[i]);\n\t\t\tbreak;\n\t\tcase PROPOSAL_SERVER_HOST_KEY_ALGS:\n\t\t\tprop[i] = xstrdup(hkalgs ? hkalgs : defprop[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprop[i] = xstrdup(defprop[i]);\n\t\t}\n\t}\n\tfree(cp);\n}\n\nvoid\nkex_proposal_free_entries(char *prop[PROPOSAL_MAX])\n{\n\tu_int i;\n\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(prop[i]);\n}\n\n \nint\nkex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])\n{\n\tu_int i;\n\tint r;\n\n\tsshbuf_reset(b);\n\n\t \n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0)\n\t\t\treturn r;\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_put_cstring(b, proposal[i])) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t \n\t    (r = sshbuf_put_u32(b, 0)) != 0)\t \n\t\treturn r;\n\treturn 0;\n}\n\n \nint\nkex_buf2prop(struct sshbuf *raw, int *first_kex_follows, char ***propp)\n{\n\tstruct sshbuf *b = NULL;\n\tu_char v;\n\tu_int i;\n\tchar **proposal = NULL;\n\tint r;\n\n\t*propp = NULL;\n\tif ((proposal = calloc(PROPOSAL_MAX, sizeof(char *))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((b = sshbuf_fromb(raw)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(b, KEX_COOKIE_LEN)) != 0) {  \n\t\terror_fr(r, \"consume cookie\");\n\t\tgoto out;\n\t}\n\t \n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshbuf_get_cstring(b, &(proposal[i]), NULL)) != 0) {\n\t\t\terror_fr(r, \"parse proposal %u\", i);\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2(\"%s: %s\", proposal_names[i], proposal[i]);\n\t}\n\t \n\tif ((r = sshbuf_get_u8(b, &v)) != 0 ||\t \n\t    (r = sshbuf_get_u32(b, &i)) != 0) {\t \n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (first_kex_follows != NULL)\n\t\t*first_kex_follows = v;\n\tdebug2(\"first_kex_follows %d \", v);\n\tdebug2(\"reserved %u \", i);\n\tr = 0;\n\t*propp = proposal;\n out:\n\tif (r != 0 && proposal != NULL)\n\t\tkex_prop_free(proposal);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nvoid\nkex_prop_free(char **proposal)\n{\n\tu_int i;\n\n\tif (proposal == NULL)\n\t\treturn;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(proposal[i]);\n\tfree(proposal);\n}\n\nint\nkex_protocol_error(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint r;\n\n\t \n\tif ((ssh->kex->flags & KEX_INITIAL) && ssh->kex->kex_strict) {\n\t\tssh_packet_disconnect(ssh, \"strict KEX violation: \"\n\t\t    \"unexpected packet type %u (seqnr %u)\", type, seq);\n\t}\n\terror_f(\"type %u seq %u\", type, seq);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_UNIMPLEMENTED)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, seq)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic void\nkex_reset_dispatch(struct ssh *ssh)\n{\n\tssh_dispatch_range(ssh, SSH2_MSG_TRANSPORT_MIN,\n\t    SSH2_MSG_TRANSPORT_MAX, &kex_protocol_error);\n}\n\nvoid\nkex_set_server_sig_algs(struct ssh *ssh, const char *allowed_algs)\n{\n\tchar *alg, *oalgs, *algs, *sigalgs;\n\tconst char *sigalg;\n\n\t \n\tif ((sigalgs = sshkey_alg_list(0, 1, 1, ',')) == NULL)\n\t\tfatal_f(\"sshkey_alg_list failed\");\n\toalgs = algs = xstrdup(allowed_algs);\n\tfree(ssh->kex->server_sig_algs);\n\tssh->kex->server_sig_algs = NULL;\n\tfor ((alg = strsep(&algs, \",\")); alg != NULL && *alg != '\\0';\n\t    (alg = strsep(&algs, \",\"))) {\n\t\tif ((sigalg = sshkey_sigalg_by_name(alg)) == NULL)\n\t\t\tcontinue;\n\t\tif (!has_any_alg(sigalg, sigalgs))\n\t\t\tcontinue;\n\t\t \n\t\tif (ssh->kex->server_sig_algs != NULL &&\n\t\t    has_any_alg(sigalg, ssh->kex->server_sig_algs))\n\t\t\tcontinue;\n\t\txextendf(&ssh->kex->server_sig_algs, \",\", \"%s\", sigalg);\n\t}\n\tfree(oalgs);\n\tfree(sigalgs);\n\tif (ssh->kex->server_sig_algs == NULL)\n\t\tssh->kex->server_sig_algs = xstrdup(\"\");\n}\n\nstatic int\nkex_compose_ext_info_server(struct ssh *ssh, struct sshbuf *m)\n{\n\tint r;\n\n\tif (ssh->kex->server_sig_algs == NULL &&\n\t    (ssh->kex->server_sig_algs = sshkey_alg_list(0, 1, 1, ',')) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_u32(m, 3)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"server-sig-algs\")) != 0 ||\n\t    (r = sshbuf_put_cstring(m, ssh->kex->server_sig_algs)) != 0 ||\n\t    (r = sshbuf_put_cstring(m,\n\t    \"publickey-hostbound@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"0\")) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"ping@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"0\")) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic int\nkex_compose_ext_info_client(struct ssh *ssh, struct sshbuf *m)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(m, 1)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"ext-info-in-auth@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"0\")) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\treturn r;\n}\n\nstatic int\nkex_maybe_send_ext_info(struct ssh *ssh)\n{\n\tint r;\n\tstruct sshbuf *m = NULL;\n\n\tif ((ssh->kex->flags & KEX_INITIAL) == 0)\n\t\treturn 0;\n\tif (!ssh->kex->ext_info_c && !ssh->kex->ext_info_s)\n\t\treturn 0;\n\n\t \n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif (ssh->kex->ext_info_c &&\n\t    (r = kex_compose_ext_info_server(ssh, m)) != 0)\n\t\tgoto fail;\n\tif (ssh->kex->ext_info_s &&\n\t    (r = kex_compose_ext_info_client(ssh, m)) != 0)\n\t\tgoto fail;\n\n\t \n\tdebug(\"Sending SSH2_MSG_EXT_INFO\");\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_EXT_INFO)) != 0 ||\n\t    (r = sshpkt_putb(ssh, m)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\terror_f(\"send EXT_INFO\");\n\t\tgoto fail;\n\t}\n\n\tr = 0;\n\n fail:\n\tsshbuf_free(m);\n\treturn r;\n}\n\nint\nkex_server_update_ext_info(struct ssh *ssh)\n{\n\tint r;\n\n\tif ((ssh->kex->flags & KEX_HAS_EXT_INFO_IN_AUTH) == 0)\n\t\treturn 0;\n\n\tdebug_f(\"Sending SSH2_MSG_EXT_INFO\");\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_EXT_INFO)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, 1)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"server-sig-algs\")) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, ssh->kex->server_sig_algs)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\terror_f(\"send EXT_INFO\");\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nint\nkex_send_newkeys(struct ssh *ssh)\n{\n\tint r;\n\n\tkex_reset_dispatch(ssh);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_NEWKEYS)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"SSH2_MSG_NEWKEYS sent\");\n\tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_input_newkeys);\n\tif ((r = kex_maybe_send_ext_info(ssh)) != 0)\n\t\treturn r;\n\tdebug(\"expecting SSH2_MSG_NEWKEYS\");\n\treturn 0;\n}\n\n \nstatic int\nkex_ext_info_check_ver(struct kex *kex, const char *name,\n    const u_char *val, size_t len, const char *want_ver, u_int flag)\n{\n\tif (memchr(val, '\\0', len) != NULL) {\n\t\terror(\"SSH2_MSG_EXT_INFO: %s value contains nul byte\", name);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tdebug_f(\"%s=<%s>\", name, val);\n\tif (strcmp(val, want_ver) == 0)\n\t\tkex->flags |= flag;\n\telse\n\t\tdebug_f(\"unsupported version of %s extension\", name);\n\treturn 0;\n}\n\nstatic int\nkex_ext_info_client_parse(struct ssh *ssh, const char *name,\n    const u_char *value, size_t vlen)\n{\n\tint r;\n\n\t \n\tif (strcmp(name, \"server-sig-algs\") == 0) {\n\t\t \n\t\tif (memchr(value, '\\0', vlen) != NULL) {\n\t\t\terror_f(\"nul byte in %s\", name);\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t\tdebug_f(\"%s=<%s>\", name, value);\n\t\tfree(ssh->kex->server_sig_algs);\n\t\tssh->kex->server_sig_algs = xstrdup((const char *)value);\n\t} else if (ssh->kex->ext_info_received == 1 &&\n\t    strcmp(name, \"publickey-hostbound@openssh.com\") == 0) {\n\t\tif ((r = kex_ext_info_check_ver(ssh->kex, name, value, vlen,\n\t\t    \"0\", KEX_HAS_PUBKEY_HOSTBOUND)) != 0) {\n\t\t\treturn r;\n\t\t}\n\t} else if (ssh->kex->ext_info_received == 1 &&\n\t    strcmp(name, \"ping@openssh.com\") == 0) {\n\t\tif ((r = kex_ext_info_check_ver(ssh->kex, name, value, vlen,\n\t\t    \"0\", KEX_HAS_PING)) != 0) {\n\t\t\treturn r;\n\t\t}\n\t} else\n\t\tdebug_f(\"%s (unrecognised)\", name);\n\n\treturn 0;\n}\n\nstatic int\nkex_ext_info_server_parse(struct ssh *ssh, const char *name,\n    const u_char *value, size_t vlen)\n{\n\tint r;\n\n\tif (strcmp(name, \"ext-info-in-auth@openssh.com\") == 0) {\n\t\tif ((r = kex_ext_info_check_ver(ssh->kex, name, value, vlen,\n\t\t    \"0\", KEX_HAS_EXT_INFO_IN_AUTH)) != 0) {\n\t\t\treturn r;\n\t\t}\n\t} else\n\t\tdebug_f(\"%s (unrecognised)\", name);\n\treturn 0;\n}\n\nint\nkex_input_ext_info(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tconst int max_ext_info = kex->server ? 1 : 2;\n\tu_int32_t i, ninfo;\n\tchar *name;\n\tu_char *val;\n\tsize_t vlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_EXT_INFO received\");\n\tif (++kex->ext_info_received > max_ext_info) {\n\t\terror(\"too many SSH2_MSG_EXT_INFO messages sent by peer\");\n\t\treturn dispatch_protocol_error(type, seq, ssh);\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_protocol_error);\n\tif ((r = sshpkt_get_u32(ssh, &ninfo)) != 0)\n\t\treturn r;\n\tif (ninfo >= 1024) {\n\t\terror(\"SSH2_MSG_EXT_INFO with too many entries, expected \"\n\t\t    \"<=1024, received %u\", ninfo);\n\t\treturn dispatch_protocol_error(type, seq, ssh);\n\t}\n\tfor (i = 0; i < ninfo; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshpkt_get_string(ssh, &val, &vlen)) != 0) {\n\t\t\tfree(name);\n\t\t\treturn r;\n\t\t}\n\t\tdebug3_f(\"extension %s\", name);\n\t\tif (kex->server) {\n\t\t\tif ((r = kex_ext_info_server_parse(ssh, name,\n\t\t\t    val, vlen)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\tif ((r = kex_ext_info_client_parse(ssh, name,\n\t\t\t    val, vlen)) != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tfree(name);\n\t\tfree(val);\n\t}\n\treturn sshpkt_get_end(ssh);\n}\n\nstatic int\nkex_input_newkeys(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tdebug(\"SSH2_MSG_NEWKEYS received\");\n\tif (kex->ext_info_c && (kex->flags & KEX_INITIAL) != 0)\n\t\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_input_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\treturn r;\n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)\n\t\treturn r;\n\tkex->done = 1;\n\tkex->flags &= ~KEX_INITIAL;\n\tsshbuf_reset(kex->peer);\n\t \n\tkex->flags &= ~KEX_INIT_SENT;\n\tfree(kex->name);\n\tkex->name = NULL;\n\treturn 0;\n}\n\nint\nkex_send_kexinit(struct ssh *ssh)\n{\n\tu_char *cookie;\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\tif (kex == NULL) {\n\t\terror_f(\"no kex\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif (kex->flags & KEX_INIT_SENT)\n\t\treturn 0;\n\tkex->done = 0;\n\n\t \n\tif (sshbuf_len(kex->my) < KEX_COOKIE_LEN) {\n\t\terror_f(\"bad kex length: %zu < %d\",\n\t\t    sshbuf_len(kex->my), KEX_COOKIE_LEN);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((cookie = sshbuf_mutable_ptr(kex->my)) == NULL) {\n\t\terror_f(\"buffer error\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tarc4random_buf(cookie, KEX_COOKIE_LEN);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEXINIT)) != 0 ||\n\t    (r = sshpkt_putb(ssh, kex->my)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\terror_fr(r, \"compose reply\");\n\t\treturn r;\n\t}\n\tdebug(\"SSH2_MSG_KEXINIT sent\");\n\tkex->flags |= KEX_INIT_SENT;\n\treturn 0;\n}\n\nint\nkex_input_kexinit(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL) {\n\t\terror_f(\"no kex\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_protocol_error);\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\n\t \n\tfor (i = 0; i < KEX_COOKIE_LEN; i++) {\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0) {\n\t\t\terror_fr(r, \"discard cookie\");\n\t\t\treturn r;\n\t\t}\n\t}\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0) {\n\t\t\terror_fr(r, \"discard proposal\");\n\t\t\treturn r;\n\t\t}\n\t}\n\t \n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t \n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t \n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh, seq)) != 0)\n\t\treturn r;\n\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\n\terror_f(\"unknown kex type %u\", kex->kex_type);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n\nstruct kex *\nkex_new(void)\n{\n\tstruct kex *kex;\n\n\tif ((kex = calloc(1, sizeof(*kex))) == NULL ||\n\t    (kex->peer = sshbuf_new()) == NULL ||\n\t    (kex->my = sshbuf_new()) == NULL ||\n\t    (kex->client_version = sshbuf_new()) == NULL ||\n\t    (kex->server_version = sshbuf_new()) == NULL ||\n\t    (kex->session_id = sshbuf_new()) == NULL) {\n\t\tkex_free(kex);\n\t\treturn NULL;\n\t}\n\treturn kex;\n}\n\nvoid\nkex_free_newkeys(struct newkeys *newkeys)\n{\n\tif (newkeys == NULL)\n\t\treturn;\n\tif (newkeys->enc.key) {\n\t\texplicit_bzero(newkeys->enc.key, newkeys->enc.key_len);\n\t\tfree(newkeys->enc.key);\n\t\tnewkeys->enc.key = NULL;\n\t}\n\tif (newkeys->enc.iv) {\n\t\texplicit_bzero(newkeys->enc.iv, newkeys->enc.iv_len);\n\t\tfree(newkeys->enc.iv);\n\t\tnewkeys->enc.iv = NULL;\n\t}\n\tfree(newkeys->enc.name);\n\texplicit_bzero(&newkeys->enc, sizeof(newkeys->enc));\n\tfree(newkeys->comp.name);\n\texplicit_bzero(&newkeys->comp, sizeof(newkeys->comp));\n\tmac_clear(&newkeys->mac);\n\tif (newkeys->mac.key) {\n\t\texplicit_bzero(newkeys->mac.key, newkeys->mac.key_len);\n\t\tfree(newkeys->mac.key);\n\t\tnewkeys->mac.key = NULL;\n\t}\n\tfree(newkeys->mac.name);\n\texplicit_bzero(&newkeys->mac, sizeof(newkeys->mac));\n\tfreezero(newkeys, sizeof(*newkeys));\n}\n\nvoid\nkex_free(struct kex *kex)\n{\n\tu_int mode;\n\n\tif (kex == NULL)\n\t\treturn;\n\n#ifdef WITH_OPENSSL\n\tDH_free(kex->dh);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(kex->ec_client_key);\n#endif  \n#endif  \n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(kex->newkeys[mode]);\n\t\tkex->newkeys[mode] = NULL;\n\t}\n\tsshbuf_free(kex->peer);\n\tsshbuf_free(kex->my);\n\tsshbuf_free(kex->client_version);\n\tsshbuf_free(kex->server_version);\n\tsshbuf_free(kex->client_pub);\n\tsshbuf_free(kex->session_id);\n\tsshbuf_free(kex->initial_sig);\n\tsshkey_free(kex->initial_hostkey);\n\tfree(kex->failed_choice);\n\tfree(kex->hostkey_alg);\n\tfree(kex->name);\n\tfree(kex);\n}\n\nint\nkex_ready(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_prop2buf(ssh->kex->my, proposal)) != 0)\n\t\treturn r;\n\tssh->kex->flags = KEX_INITIAL;\n\tkex_reset_dispatch(ssh);\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\treturn 0;\n}\n\nint\nkex_setup(struct ssh *ssh, char *proposal[PROPOSAL_MAX])\n{\n\tint r;\n\n\tif ((r = kex_ready(ssh, proposal)) != 0)\n\t\treturn r;\n\tif ((r = kex_send_kexinit(ssh)) != 0) {\t\t \n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nint\nkex_start_rekex(struct ssh *ssh)\n{\n\tif (ssh->kex == NULL) {\n\t\terror_f(\"no kex\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tif (ssh->kex->done == 0) {\n\t\terror_f(\"requested twice\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tssh->kex->done = 0;\n\treturn kex_send_kexinit(ssh);\n}\n\nstatic int\nchoose_enc(struct sshenc *enc, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_CIPHER_ALG_MATCH;\n\tif ((enc->cipher = cipher_by_name(name)) == NULL) {\n\t\terror_f(\"unsupported cipher %s\", name);\n\t\tfree(name);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tenc->name = name;\n\tenc->enabled = 0;\n\tenc->iv = NULL;\n\tenc->iv_len = cipher_ivlen(enc->cipher);\n\tenc->key = NULL;\n\tenc->key_len = cipher_keylen(enc->cipher);\n\tenc->block_size = cipher_blocksize(enc->cipher);\n\treturn 0;\n}\n\nstatic int\nchoose_mac(struct ssh *ssh, struct sshmac *mac, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_MAC_ALG_MATCH;\n\tif (mac_setup(mac, name) < 0) {\n\t\terror_f(\"unsupported MAC %s\", name);\n\t\tfree(name);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tmac->name = name;\n\tmac->key = NULL;\n\tmac->enabled = 0;\n\treturn 0;\n}\n\nstatic int\nchoose_comp(struct sshcomp *comp, char *client, char *server)\n{\n\tchar *name = match_list(client, server, NULL);\n\n\tif (name == NULL)\n\t\treturn SSH_ERR_NO_COMPRESS_ALG_MATCH;\n#ifdef WITH_ZLIB\n\tif (strcmp(name, \"zlib@openssh.com\") == 0) {\n\t\tcomp->type = COMP_DELAYED;\n\t} else if (strcmp(name, \"zlib\") == 0) {\n\t\tcomp->type = COMP_ZLIB;\n\t} else\n#endif\t \n\tif (strcmp(name, \"none\") == 0) {\n\t\tcomp->type = COMP_NONE;\n\t} else {\n\t\terror_f(\"unsupported compression scheme %s\", name);\n\t\tfree(name);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tcomp->name = name;\n\treturn 0;\n}\n\nstatic int\nchoose_kex(struct kex *k, char *client, char *server)\n{\n\tconst struct kexalg *kexalg;\n\n\tk->name = match_list(client, server, NULL);\n\n\tdebug(\"kex: algorithm: %s\", k->name ? k->name : \"(no match)\");\n\tif (k->name == NULL)\n\t\treturn SSH_ERR_NO_KEX_ALG_MATCH;\n\tif ((kexalg = kex_alg_by_name(k->name)) == NULL) {\n\t\terror_f(\"unsupported KEX method %s\", k->name);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tk->kex_type = kexalg->type;\n\tk->hash_alg = kexalg->hash_alg;\n\tk->ec_nid = kexalg->ec_nid;\n\treturn 0;\n}\n\nstatic int\nchoose_hostkeyalg(struct kex *k, char *client, char *server)\n{\n\tfree(k->hostkey_alg);\n\tk->hostkey_alg = match_list(client, server, NULL);\n\n\tdebug(\"kex: host key algorithm: %s\",\n\t    k->hostkey_alg ? k->hostkey_alg : \"(no match)\");\n\tif (k->hostkey_alg == NULL)\n\t\treturn SSH_ERR_NO_HOSTKEY_ALG_MATCH;\n\tk->hostkey_type = sshkey_type_from_name(k->hostkey_alg);\n\tif (k->hostkey_type == KEY_UNSPEC) {\n\t\terror_f(\"unsupported hostkey algorithm %s\", k->hostkey_alg);\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tk->hostkey_nid = sshkey_ecdsa_nid_from_name(k->hostkey_alg);\n\treturn 0;\n}\n\nstatic int\nproposals_match(char *my[PROPOSAL_MAX], char *peer[PROPOSAL_MAX])\n{\n\tstatic int check[] = {\n\t\tPROPOSAL_KEX_ALGS, PROPOSAL_SERVER_HOST_KEY_ALGS, -1\n\t};\n\tint *idx;\n\tchar *p;\n\n\tfor (idx = &check[0]; *idx != -1; idx++) {\n\t\tif ((p = strchr(my[*idx], ',')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif ((p = strchr(peer[*idx], ',')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif (strcmp(my[*idx], peer[*idx]) != 0) {\n\t\t\tdebug2(\"proposal mismatch: my %s peer %s\",\n\t\t\t    my[*idx], peer[*idx]);\n\t\t\treturn (0);\n\t\t}\n\t}\n\tdebug2(\"proposals match\");\n\treturn (1);\n}\n\nstatic int\nkexalgs_contains(char **peer, const char *ext)\n{\n\treturn has_any_alg(peer[PROPOSAL_KEX_ALGS], ext);\n}\n\nstatic int\nkex_choose_conf(struct ssh *ssh, uint32_t seq)\n{\n\tstruct kex *kex = ssh->kex;\n\tstruct newkeys *newkeys;\n\tchar **my = NULL, **peer = NULL;\n\tchar **cprop, **sprop;\n\tint nenc, nmac, ncomp;\n\tu_int mode, ctos, need, dh_need, authlen;\n\tint r, first_kex_follows;\n\n\tdebug2(\"local %s KEXINIT proposal\", kex->server ? \"server\" : \"client\");\n\tif ((r = kex_buf2prop(kex->my, NULL, &my)) != 0)\n\t\tgoto out;\n\tdebug2(\"peer %s KEXINIT proposal\", kex->server ? \"client\" : \"server\");\n\tif ((r = kex_buf2prop(kex->peer, &first_kex_follows, &peer)) != 0)\n\t\tgoto out;\n\n\tif (kex->server) {\n\t\tcprop=peer;\n\t\tsprop=my;\n\t} else {\n\t\tcprop=my;\n\t\tsprop=peer;\n\t}\n\n\t \n\tif ((kex->flags & KEX_INITIAL) != 0) {\n\t\tif (kex->server) {\n\t\t\tkex->ext_info_c = kexalgs_contains(peer, \"ext-info-c\");\n\t\t\tkex->kex_strict = kexalgs_contains(peer,\n\t\t\t    \"kex-strict-c-v00@openssh.com\");\n\t\t} else {\n\t\t\tkex->ext_info_s = kexalgs_contains(peer, \"ext-info-s\");\n\t\t\tkex->kex_strict = kexalgs_contains(peer,\n\t\t\t    \"kex-strict-s-v00@openssh.com\");\n\t\t}\n\t\tif (kex->kex_strict) {\n\t\t\tdebug3_f(\"will use strict KEX ordering\");\n\t\t\tif (seq != 0)\n\t\t\t\tssh_packet_disconnect(ssh,\n\t\t\t\t    \"strict KEX violation: \"\n\t\t\t\t    \"KEXINIT was not the first packet\");\n\t\t}\n\t}\n\n\t \n\tif (kex->server && (kex->flags & KEX_INITIAL)) {\n\t\tif (has_any_alg(peer[PROPOSAL_SERVER_HOST_KEY_ALGS],\n\t\t    \"rsa-sha2-256,rsa-sha2-256-cert-v01@openssh.com\"))\n\t\t\tkex->flags |= KEX_RSA_SHA2_256_SUPPORTED;\n\t\tif (has_any_alg(peer[PROPOSAL_SERVER_HOST_KEY_ALGS],\n\t\t    \"rsa-sha2-512,rsa-sha2-512-cert-v01@openssh.com\"))\n\t\t\tkex->flags |= KEX_RSA_SHA2_512_SUPPORTED;\n\t}\n\n\t \n\tif ((r = choose_kex(kex, cprop[PROPOSAL_KEX_ALGS],\n\t    sprop[PROPOSAL_KEX_ALGS])) != 0) {\n\t\tkex->failed_choice = peer[PROPOSAL_KEX_ALGS];\n\t\tpeer[PROPOSAL_KEX_ALGS] = NULL;\n\t\tgoto out;\n\t}\n\tif ((r = choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],\n\t    sprop[PROPOSAL_SERVER_HOST_KEY_ALGS])) != 0) {\n\t\tkex->failed_choice = peer[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\t\tpeer[PROPOSAL_SERVER_HOST_KEY_ALGS] = NULL;\n\t\tgoto out;\n\t}\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif ((newkeys = calloc(1, sizeof(*newkeys))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkex->newkeys[mode] = newkeys;\n\t\tctos = (!kex->server && mode == MODE_OUT) ||\n\t\t    (kex->server && mode == MODE_IN);\n\t\tnenc  = ctos ? PROPOSAL_ENC_ALGS_CTOS  : PROPOSAL_ENC_ALGS_STOC;\n\t\tnmac  = ctos ? PROPOSAL_MAC_ALGS_CTOS  : PROPOSAL_MAC_ALGS_STOC;\n\t\tncomp = ctos ? PROPOSAL_COMP_ALGS_CTOS : PROPOSAL_COMP_ALGS_STOC;\n\t\tif ((r = choose_enc(&newkeys->enc, cprop[nenc],\n\t\t    sprop[nenc])) != 0) {\n\t\t\tkex->failed_choice = peer[nenc];\n\t\t\tpeer[nenc] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tauthlen = cipher_authlen(newkeys->enc.cipher);\n\t\t \n\t\tif (authlen == 0 &&\n\t\t    (r = choose_mac(ssh, &newkeys->mac, cprop[nmac],\n\t\t    sprop[nmac])) != 0) {\n\t\t\tkex->failed_choice = peer[nmac];\n\t\t\tpeer[nmac] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = choose_comp(&newkeys->comp, cprop[ncomp],\n\t\t    sprop[ncomp])) != 0) {\n\t\t\tkex->failed_choice = peer[ncomp];\n\t\t\tpeer[ncomp] = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug(\"kex: %s cipher: %s MAC: %s compression: %s\",\n\t\t    ctos ? \"client->server\" : \"server->client\",\n\t\t    newkeys->enc.name,\n\t\t    authlen == 0 ? newkeys->mac.name : \"<implicit>\",\n\t\t    newkeys->comp.name);\n\t}\n\tneed = dh_need = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tnewkeys = kex->newkeys[mode];\n\t\tneed = MAXIMUM(need, newkeys->enc.key_len);\n\t\tneed = MAXIMUM(need, newkeys->enc.block_size);\n\t\tneed = MAXIMUM(need, newkeys->enc.iv_len);\n\t\tneed = MAXIMUM(need, newkeys->mac.key_len);\n\t\tdh_need = MAXIMUM(dh_need, cipher_seclen(newkeys->enc.cipher));\n\t\tdh_need = MAXIMUM(dh_need, newkeys->enc.block_size);\n\t\tdh_need = MAXIMUM(dh_need, newkeys->enc.iv_len);\n\t\tdh_need = MAXIMUM(dh_need, newkeys->mac.key_len);\n\t}\n\t \n\tkex->we_need = need;\n\tkex->dh_need = dh_need;\n\n\t \n\tif (first_kex_follows && !proposals_match(my, peer))\n\t\tssh->dispatch_skip_packets = 1;\n\tr = 0;\n out:\n\tkex_prop_free(my);\n\tkex_prop_free(peer);\n\treturn r;\n}\n\nstatic int\nderive_key(struct ssh *ssh, int id, u_int need, u_char *hash, u_int hashlen,\n    const struct sshbuf *shared_secret, u_char **keyp)\n{\n\tstruct kex *kex = ssh->kex;\n\tstruct ssh_digest_ctx *hashctx = NULL;\n\tchar c = id;\n\tu_int have;\n\tsize_t mdsz;\n\tu_char *digest;\n\tint r;\n\n\tif ((mdsz = ssh_digest_bytes(kex->hash_alg)) == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((digest = calloc(1, ROUNDUP(need, mdsz))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||\n\t    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||\n\t    ssh_digest_update(hashctx, hash, hashlen) != 0 ||\n\t    ssh_digest_update(hashctx, &c, 1) != 0 ||\n\t    ssh_digest_update_buffer(hashctx, kex->session_id) != 0 ||\n\t    ssh_digest_final(hashctx, digest, mdsz) != 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\terror_f(\"KEX hash failed\");\n\t\tgoto out;\n\t}\n\tssh_digest_free(hashctx);\n\thashctx = NULL;\n\n\t \n\tfor (have = mdsz; need > have; have += mdsz) {\n\t\tif ((hashctx = ssh_digest_start(kex->hash_alg)) == NULL ||\n\t\t    ssh_digest_update_buffer(hashctx, shared_secret) != 0 ||\n\t\t    ssh_digest_update(hashctx, hash, hashlen) != 0 ||\n\t\t    ssh_digest_update(hashctx, digest, have) != 0 ||\n\t\t    ssh_digest_final(hashctx, digest + have, mdsz) != 0) {\n\t\t\terror_f(\"KDF failed\");\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tssh_digest_free(hashctx);\n\t\thashctx = NULL;\n\t}\n#ifdef DEBUG_KEX\n\tfprintf(stderr, \"key '%c'== \", c);\n\tdump_digest(\"key\", digest, need);\n#endif\n\t*keyp = digest;\n\tdigest = NULL;\n\tr = 0;\n out:\n\tfree(digest);\n\tssh_digest_free(hashctx);\n\treturn r;\n}\n\n#define NKEYS\t6\nint\nkex_derive_keys(struct ssh *ssh, u_char *hash, u_int hashlen,\n    const struct sshbuf *shared_secret)\n{\n\tstruct kex *kex = ssh->kex;\n\tu_char *keys[NKEYS];\n\tu_int i, j, mode, ctos;\n\tint r;\n\n\t \n\tif ((kex->flags & KEX_INITIAL) != 0) {\n\t\tif (sshbuf_len(kex->session_id) != 0) {\n\t\t\terror_f(\"already have session ID at kex\");\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t\tif ((r = sshbuf_put(kex->session_id, hash, hashlen)) != 0)\n\t\t\treturn r;\n\t} else if (sshbuf_len(kex->session_id) == 0) {\n\t\terror_f(\"no session ID in rekex\");\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\tfor (i = 0; i < NKEYS; i++) {\n\t\tif ((r = derive_key(ssh, 'A'+i, kex->we_need, hash, hashlen,\n\t\t    shared_secret, &keys[i])) != 0) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree(keys[j]);\n\t\t\treturn r;\n\t\t}\n\t}\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tctos = (!kex->server && mode == MODE_OUT) ||\n\t\t    (kex->server && mode == MODE_IN);\n\t\tkex->newkeys[mode]->enc.iv  = keys[ctos ? 0 : 1];\n\t\tkex->newkeys[mode]->enc.key = keys[ctos ? 2 : 3];\n\t\tkex->newkeys[mode]->mac.key = keys[ctos ? 4 : 5];\n\t}\n\treturn 0;\n}\n\nint\nkex_load_hostkey(struct ssh *ssh, struct sshkey **prvp, struct sshkey **pubp)\n{\n\tstruct kex *kex = ssh->kex;\n\n\t*pubp = NULL;\n\t*prvp = NULL;\n\tif (kex->load_host_public_key == NULL ||\n\t    kex->load_host_private_key == NULL) {\n\t\terror_f(\"missing hostkey loader\");\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\t*pubp = kex->load_host_public_key(kex->hostkey_type,\n\t    kex->hostkey_nid, ssh);\n\t*prvp = kex->load_host_private_key(kex->hostkey_type,\n\t    kex->hostkey_nid, ssh);\n\tif (*pubp == NULL)\n\t\treturn SSH_ERR_NO_HOSTKEY_LOADED;\n\treturn 0;\n}\n\nint\nkex_verify_host_key(struct ssh *ssh, struct sshkey *server_host_key)\n{\n\tstruct kex *kex = ssh->kex;\n\n\tif (kex->verify_host_key == NULL) {\n\t\terror_f(\"missing hostkey verifier\");\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (server_host_key->type != kex->hostkey_type ||\n\t    (kex->hostkey_type == KEY_ECDSA &&\n\t    server_host_key->ecdsa_nid != kex->hostkey_nid))\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif (kex->verify_host_key(server_host_key, ssh) == -1)\n\t\treturn  SSH_ERR_SIGNATURE_INVALID;\n\treturn 0;\n}\n\n#if defined(DEBUG_KEX) || defined(DEBUG_KEXDH) || defined(DEBUG_KEXECDH)\nvoid\ndump_digest(const char *msg, const u_char *digest, int len)\n{\n\tfprintf(stderr, \"%s\\n\", msg);\n\tsshbuf_dump_data(digest, len, stderr);\n}\n#endif\n\n \nstatic void\nsend_error(struct ssh *ssh, char *msg)\n{\n\tchar *crnl = \"\\r\\n\";\n\n\tif (!ssh->kex->server)\n\t\treturn;\n\n\tif (atomicio(vwrite, ssh_packet_get_connection_out(ssh),\n\t    msg, strlen(msg)) != strlen(msg) ||\n\t    atomicio(vwrite, ssh_packet_get_connection_out(ssh),\n\t    crnl, strlen(crnl)) != strlen(crnl))\n\t\terror_f(\"write: %.100s\", strerror(errno));\n}\n\n \nint\nkex_exchange_identification(struct ssh *ssh, int timeout_ms,\n    const char *version_addendum)\n{\n\tint remote_major, remote_minor, mismatch, oerrno = 0;\n\tsize_t len, n;\n\tint r, expect_nl;\n\tu_char c;\n\tstruct sshbuf *our_version = ssh->kex->server ?\n\t    ssh->kex->server_version : ssh->kex->client_version;\n\tstruct sshbuf *peer_version = ssh->kex->server ?\n\t    ssh->kex->client_version : ssh->kex->server_version;\n\tchar *our_version_string = NULL, *peer_version_string = NULL;\n\tchar *cp, *remote_version = NULL;\n\n\t \n\tsshbuf_reset(our_version);\n\tif (version_addendum != NULL && *version_addendum == '\\0')\n\t\tversion_addendum = NULL;\n\tif ((r = sshbuf_putf(our_version, \"SSH-%d.%d-%s%s%s\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION,\n\t    version_addendum == NULL ? \"\" : \" \",\n\t    version_addendum == NULL ? \"\" : version_addendum)) != 0) {\n\t\toerrno = errno;\n\t\terror_fr(r, \"sshbuf_putf\");\n\t\tgoto out;\n\t}\n\n\tif (atomicio(vwrite, ssh_packet_get_connection_out(ssh),\n\t    sshbuf_mutable_ptr(our_version),\n\t    sshbuf_len(our_version)) != sshbuf_len(our_version)) {\n\t\toerrno = errno;\n\t\tdebug_f(\"write: %.100s\", strerror(errno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume_end(our_version, 2)) != 0) {  \n\t\toerrno = errno;\n\t\terror_fr(r, \"sshbuf_consume_end\");\n\t\tgoto out;\n\t}\n\tour_version_string = sshbuf_dup_string(our_version);\n\tif (our_version_string == NULL) {\n\t\terror_f(\"sshbuf_dup_string failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tdebug(\"Local version string %.100s\", our_version_string);\n\n\t \n\tfor (n = 0; ; n++) {\n\t\tif (n >= SSH_MAX_PRE_BANNER_LINES) {\n\t\t\tsend_error(ssh, \"No SSH identification string \"\n\t\t\t    \"received.\");\n\t\t\terror_f(\"No SSH version received in first %u lines \"\n\t\t\t    \"from server\", SSH_MAX_PRE_BANNER_LINES);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(peer_version);\n\t\texpect_nl = 0;\n\t\tfor (;;) {\n\t\t\tif (timeout_ms > 0) {\n\t\t\t\tr = waitrfd(ssh_packet_get_connection_in(ssh),\n\t\t\t\t    &timeout_ms, NULL);\n\t\t\t\tif (r == -1 && errno == ETIMEDOUT) {\n\t\t\t\t\tsend_error(ssh, \"Timed out waiting \"\n\t\t\t\t\t    \"for SSH identification string.\");\n\t\t\t\t\terror(\"Connection timed out during \"\n\t\t\t\t\t    \"banner exchange\");\n\t\t\t\t\tr = SSH_ERR_CONN_TIMEOUT;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (r == -1) {\n\t\t\t\t\toerrno = errno;\n\t\t\t\t\terror_f(\"%s\", strerror(errno));\n\t\t\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen = atomicio(read, ssh_packet_get_connection_in(ssh),\n\t\t\t    &c, 1);\n\t\t\tif (len != 1 && errno == EPIPE) {\n\t\t\t\tverbose_f(\"Connection closed by remote host\");\n\t\t\t\tr = SSH_ERR_CONN_CLOSED;\n\t\t\t\tgoto out;\n\t\t\t} else if (len != 1) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror_f(\"read: %.100s\", strerror(errno));\n\t\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (c == '\\r') {\n\t\t\t\texpect_nl = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (c == '\\0' || expect_nl) {\n\t\t\t\tverbose_f(\"banner line contains invalid \"\n\t\t\t\t    \"characters\");\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_u8(peer_version, c)) != 0) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror_fr(r, \"sshbuf_put\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sshbuf_len(peer_version) > SSH_MAX_BANNER_LEN) {\n\t\t\t\tverbose_f(\"banner line too long\");\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (sshbuf_len(peer_version) > 4 &&\n\t\t    memcmp(sshbuf_ptr(peer_version), \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\t \n\t\tif ((cp = sshbuf_dup_string(peer_version)) == NULL) {\n\t\t\terror_f(\"sshbuf_dup_string failed\");\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (ssh->kex->server) {\n\t\t\tverbose_f(\"client sent invalid protocol identifier \"\n\t\t\t    \"\\\"%.256s\\\"\", cp);\n\t\t\tfree(cp);\n\t\t\tgoto invalid;\n\t\t}\n\t\tdebug_f(\"banner line %zu: %s\", n, cp);\n\t\tfree(cp);\n\t}\n\tpeer_version_string = sshbuf_dup_string(peer_version);\n\tif (peer_version_string == NULL)\n\t\tfatal_f(\"sshbuf_dup_string failed\");\n\t \n\tif ((remote_version = calloc(1, sshbuf_len(peer_version))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sscanf(peer_version_string, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\terror(\"Bad remote protocol version identification: '%.100s'\",\n\t\t    peer_version_string);\n invalid:\n\t\tsend_error(ssh, \"Invalid SSH identification string.\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\tcompat_banner(ssh, remote_version);\n\n\tmismatch = 0;\n\tswitch (remote_major) {\n\tcase 2:\n\t\tbreak;\n\tcase 1:\n\t\tif (remote_minor != 99)\n\t\t\tmismatch = 1;\n\t\tbreak;\n\tdefault:\n\t\tmismatch = 1;\n\t\tbreak;\n\t}\n\tif (mismatch) {\n\t\terror(\"Protocol major versions differ: %d vs. %d\",\n\t\t    PROTOCOL_MAJOR_2, remote_major);\n\t\tsend_error(ssh, \"Protocol major versions differ.\");\n\t\tr = SSH_ERR_NO_PROTOCOL_VERSION;\n\t\tgoto out;\n\t}\n\n\tif (ssh->kex->server && (ssh->compat & SSH_BUG_PROBE) != 0) {\n\t\tlogit(\"probed from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    peer_version_string);\n\t\tr = SSH_ERR_CONN_CLOSED;  \n\t\tgoto out;\n\t}\n\tif (ssh->kex->server && (ssh->compat & SSH_BUG_SCANNER) != 0) {\n\t\tlogit(\"scanned from %s port %d with %s.  Don't panic.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    peer_version_string);\n\t\tr = SSH_ERR_CONN_CLOSED;  \n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tfree(our_version_string);\n\tfree(peer_version_string);\n\tfree(remote_version);\n\tif (r == SSH_ERR_SYSTEM_ERROR)\n\t\terrno = oerrno;\n\treturn r;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}