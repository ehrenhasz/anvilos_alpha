{
  "module_name": "cipher.c",
  "hash_id": "43e607aa3f06814e898bf6b671e19a8e4a6f6c8c2eb24a6e76b3b92149b2d597",
  "original_prompt": "Ingested from openssh-9.6p1/cipher.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"cipher.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#ifndef WITH_OPENSSL\n#define EVP_CIPHER_CTX void\n#endif\n\nstruct sshcipher_ctx {\n\tint\tplaintext;\n\tint\tencrypt;\n\tEVP_CIPHER_CTX *evp;\n\tstruct chachapoly_ctx *cp_ctx;\n\tstruct aesctr_ctx ac_ctx;  \n\tconst struct sshcipher *cipher;\n};\n\nstruct sshcipher {\n\tchar\t*name;\n\tu_int\tblock_size;\n\tu_int\tkey_len;\n\tu_int\tiv_len;\t\t \n\tu_int\tauth_len;\n\tu_int\tflags;\n#define CFLAG_CBC\t\t(1<<0)\n#define CFLAG_CHACHAPOLY\t(1<<1)\n#define CFLAG_AESCTR\t\t(1<<2)\n#define CFLAG_NONE\t\t(1<<3)\n#define CFLAG_INTERNAL\t\tCFLAG_NONE  \n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER\t*(*evptype)(void);\n#else\n\tvoid\t*ignored;\n#endif\n};\n\nstatic const struct sshcipher ciphers[] = {\n#ifdef WITH_OPENSSL\n#ifndef OPENSSL_NO_DES\n\t{ \"3des-cbc\",\t\t8, 24, 0, 0, CFLAG_CBC, EVP_des_ede3_cbc },\n#endif\n\t{ \"aes128-cbc\",\t\t16, 16, 0, 0, CFLAG_CBC, EVP_aes_128_cbc },\n\t{ \"aes192-cbc\",\t\t16, 24, 0, 0, CFLAG_CBC, EVP_aes_192_cbc },\n\t{ \"aes256-cbc\",\t\t16, 32, 0, 0, CFLAG_CBC, EVP_aes_256_cbc },\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, 0, EVP_aes_128_ctr },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, 0, EVP_aes_192_ctr },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, 0, EVP_aes_256_ctr },\n\t{ \"aes128-gcm@openssh.com\",\n\t\t\t\t16, 16, 12, 16, 0, EVP_aes_128_gcm },\n\t{ \"aes256-gcm@openssh.com\",\n\t\t\t\t16, 32, 12, 16, 0, EVP_aes_256_gcm },\n#else\n\t{ \"aes128-ctr\",\t\t16, 16, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes192-ctr\",\t\t16, 24, 0, 0, CFLAG_AESCTR, NULL },\n\t{ \"aes256-ctr\",\t\t16, 32, 0, 0, CFLAG_AESCTR, NULL },\n#endif\n\t{ \"chacha20-poly1305@openssh.com\",\n\t\t\t\t8, 64, 0, 16, CFLAG_CHACHAPOLY, NULL },\n\t{ \"none\",\t\t8, 0, 0, 0, CFLAG_NONE, NULL },\n\n\t{ NULL,\t\t\t0, 0, 0, 0, 0, NULL }\n};\n\n \n\n \nchar *\ncipher_alg_list(char sep, int auth_only)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t nlen, rlen = 0;\n\tconst struct sshcipher *c;\n\n\tfor (c = ciphers; c->name != NULL; c++) {\n\t\tif ((c->flags & CFLAG_INTERNAL) != 0)\n\t\t\tcontinue;\n\t\tif (auth_only && c->auth_len == 0)\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(c->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, c->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}\n\nconst char *\ncompression_alg_list(int compression)\n{\n#ifdef WITH_ZLIB\n\treturn compression ? \"zlib@openssh.com,zlib,none\" :\n\t    \"none,zlib@openssh.com,zlib\";\n#else\n\treturn \"none\";\n#endif\n}\n\nu_int\ncipher_blocksize(const struct sshcipher *c)\n{\n\treturn (c->block_size);\n}\n\nu_int\ncipher_keylen(const struct sshcipher *c)\n{\n\treturn (c->key_len);\n}\n\nu_int\ncipher_seclen(const struct sshcipher *c)\n{\n\tif (strcmp(\"3des-cbc\", c->name) == 0)\n\t\treturn 14;\n\treturn cipher_keylen(c);\n}\n\nu_int\ncipher_authlen(const struct sshcipher *c)\n{\n\treturn (c->auth_len);\n}\n\nu_int\ncipher_ivlen(const struct sshcipher *c)\n{\n\t \n\treturn (c->iv_len != 0 || (c->flags & CFLAG_CHACHAPOLY) != 0) ?\n\t    c->iv_len : c->block_size;\n}\n\nu_int\ncipher_is_cbc(const struct sshcipher *c)\n{\n\treturn (c->flags & CFLAG_CBC) != 0;\n}\n\nu_int\ncipher_ctx_is_plaintext(struct sshcipher_ctx *cc)\n{\n\treturn cc->plaintext;\n}\n\nconst struct sshcipher *\ncipher_by_name(const char *name)\n{\n\tconst struct sshcipher *c;\n\tfor (c = ciphers; c->name != NULL; c++)\n\t\tif (strcmp(c->name, name) == 0)\n\t\t\treturn c;\n\treturn NULL;\n}\n\n#define\tCIPHER_SEP\t\",\"\nint\nciphers_valid(const char *names)\n{\n\tconst struct sshcipher *c;\n\tchar *cipher_list, *cp;\n\tchar *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((cipher_list = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, CIPHER_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, CIPHER_SEP))) {\n\t\tc = cipher_by_name(p);\n\t\tif (c == NULL || (c->flags & CFLAG_INTERNAL) != 0) {\n\t\t\tfree(cipher_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(cipher_list);\n\treturn 1;\n}\n\nconst char *\ncipher_warning_message(const struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL || cc->cipher == NULL)\n\t\treturn NULL;\n\t \n\treturn NULL;\n}\n\nint\ncipher_init(struct sshcipher_ctx **ccp, const struct sshcipher *cipher,\n    const u_char *key, u_int keylen, const u_char *iv, u_int ivlen,\n    int do_encrypt)\n{\n\tstruct sshcipher_ctx *cc = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n#ifdef WITH_OPENSSL\n\tconst EVP_CIPHER *type;\n\tint klen;\n#endif\n\n\t*ccp = NULL;\n\tif ((cc = calloc(sizeof(*cc), 1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tcc->plaintext = (cipher->flags & CFLAG_NONE) != 0;\n\tcc->encrypt = do_encrypt;\n\n\tif (keylen < cipher->key_len ||\n\t    (iv != NULL && ivlen < cipher_ivlen(cipher))) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tcc->cipher = cipher;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tcc->cp_ctx = chachapoly_new(key, keylen);\n\t\tret = cc->cp_ctx != NULL ? 0 : SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\taesctr_keysetup(&cc->ac_ctx, key, 8 * keylen, 8 * ivlen);\n\t\taesctr_ivsetup(&cc->ac_ctx, iv);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = SSH_ERR_INVALID_ARGUMENT;\n\tgoto out;\n#else  \n\ttype = (*cipher->evptype)();\n\tif ((cc->evp = EVP_CIPHER_CTX_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,\n\t    (do_encrypt == CIPHER_ENCRYPT)) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(cipher) &&\n\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,\n\t    -1, (u_char *)iv)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tklen = EVP_CIPHER_CTX_key_length(cc->evp);\n\tif (klen > 0 && keylen != (u_int)klen) {\n\t\tif (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {\n\t\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tret = 0;\n#endif  \n out:\n\tif (ret == 0) {\n\t\t \n\t\t*ccp = cc;\n\t} else {\n\t\tif (cc != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tEVP_CIPHER_CTX_free(cc->evp);\n#endif  \n\t\t\tfreezero(cc, sizeof(*cc));\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint\ncipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,\n   const u_char *src, u_int len, u_int aadlen, u_int authlen)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\treturn chachapoly_crypt(cc->cp_ctx, seqnr, dest, src,\n\t\t    len, aadlen, authlen, cc->encrypt);\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0) {\n\t\tmemcpy(dest, src, aadlen + len);\n\t\treturn 0;\n\t}\n#ifndef WITH_OPENSSL\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (aadlen)\n\t\t\tmemcpy(dest, src, aadlen);\n\t\taesctr_encrypt_bytes(&cc->ac_ctx, src + aadlen,\n\t\t    dest + aadlen, len);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n#else\n\tif (authlen) {\n\t\tu_char lastiv[1];\n\n\t\tif (authlen != cipher_authlen(cc->cipher))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t \n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    1, lastiv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t \n\t\tif (!cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,\n\t\t    authlen, (u_char *)src + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tif (aadlen) {\n\t\tif (authlen &&\n\t\t    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tmemcpy(dest, src, aadlen);\n\t}\n\tif (len % cc->cipher->block_size)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,\n\t    len) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (authlen) {\n\t\t \n\t\tif (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)\n\t\t\treturn cc->encrypt ?\n\t\t\t    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;\n\t\tif (cc->encrypt &&\n\t\t    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,\n\t\t    authlen, dest + aadlen + len))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n#endif\n}\n\n \nint\ncipher_get_length(struct sshcipher_ctx *cc, u_int *plenp, u_int seqnr,\n    const u_char *cp, u_int len)\n{\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn chachapoly_get_length(cc->cp_ctx, plenp, seqnr,\n\t\t    cp, len);\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\t*plenp = PEEK_U32(cp);\n\treturn 0;\n}\n\nvoid\ncipher_free(struct sshcipher_ctx *cc)\n{\n\tif (cc == NULL)\n\t\treturn;\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tchachapoly_free(cc->cp_ctx);\n\t\tcc->cp_ctx = NULL;\n\t} else if ((cc->cipher->flags & CFLAG_AESCTR) != 0)\n\t\texplicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));\n#ifdef WITH_OPENSSL\n\tEVP_CIPHER_CTX_free(cc->evp);\n\tcc->evp = NULL;\n#endif\n\tfreezero(cc, sizeof(*cc));\n}\n\nint\ncipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, size_t len)\n{\n#ifdef WITH_OPENSSL\n\tconst struct sshcipher *c = cc->cipher;\n\tint evplen;\n#endif\n\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0) {\n\t\tif (len != 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\treturn 0;\n\t}\n\tif ((cc->cipher->flags & CFLAG_AESCTR) != 0) {\n\t\tif (len != sizeof(cc->ac_ctx.ctr))\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tmemcpy(iv, cc->ac_ctx.ctr, len);\n\t\treturn 0;\n\t}\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0)\n\t\treturn 0;\n\n#ifdef WITH_OPENSSL\n\tevplen = EVP_CIPHER_CTX_iv_length(cc->evp);\n\tif (evplen == 0)\n\t\treturn 0;\n\telse if (evplen < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif ((size_t)evplen != len)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (cipher_authlen(c)) {\n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,\n\t\t    len, iv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t} else if (!EVP_CIPHER_CTX_get_iv(cc->evp, iv, len))\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n#endif\n\treturn 0;\n}\n\nint\ncipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv, size_t len)\n{\n#ifdef WITH_OPENSSL\n\tconst struct sshcipher *c = cc->cipher;\n\tint evplen = 0;\n#endif\n\n\tif ((cc->cipher->flags & CFLAG_CHACHAPOLY) != 0)\n\t\treturn 0;\n\tif ((cc->cipher->flags & CFLAG_NONE) != 0)\n\t\treturn 0;\n\n#ifdef WITH_OPENSSL\n\tevplen = EVP_CIPHER_CTX_iv_length(cc->evp);\n\tif (evplen <= 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif ((size_t)evplen != len)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (cipher_authlen(c)) {\n\t\t \n\t\tif (!EVP_CIPHER_CTX_ctrl(cc->evp,\n\t\t    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t} else if (!EVP_CIPHER_CTX_set_iv(cc->evp, iv, evplen))\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}