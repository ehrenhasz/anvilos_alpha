{
  "module_name": "srclimit.c",
  "hash_id": "a994c0b1cc45f1f154169b15714d043643d53dd35ef8f57fa126c8645c8dd102",
  "original_prompt": "Ingested from openssh-9.6p1/srclimit.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n#include <sys/socket.h>\n#include <sys/types.h>\n\n#include <limits.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"addr.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"srclimit.h\"\n#include \"xmalloc.h\"\n\nstatic int max_children, max_persource, ipv4_masklen, ipv6_masklen;\n\n \nstatic struct child_info {\n\tint id;\n\tstruct xaddr addr;\n} *child;\n\nvoid\nsrclimit_init(int max, int persource, int ipv4len, int ipv6len)\n{\n\tint i;\n\n\tmax_children = max;\n\tipv4_masklen = ipv4len;\n\tipv6_masklen = ipv6len;\n\tmax_persource = persource;\n\tif (max_persource == INT_MAX)\t \n\t\treturn;\n\tdebug(\"%s: max connections %d, per source %d, masks %d,%d\", __func__,\n\t    max, persource, ipv4len, ipv6len);\n\tif (max <= 0)\n\t\tfatal(\"%s: invalid number of sockets: %d\", __func__, max);\n\tchild = xcalloc(max_children, sizeof(*child));\n\tfor (i = 0; i < max_children; i++)\n\t\tchild[i].id = -1;\n}\n\n \nint\nsrclimit_check_allow(int sock, int id)\n{\n\tstruct xaddr xa, xb, xmask;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen = sizeof(addr);\n\tstruct sockaddr *sa = (struct sockaddr *)&addr;\n\tint i, bits, first_unused, count = 0;\n\tchar xas[NI_MAXHOST];\n\n\tif (max_persource == INT_MAX)\t \n\t\treturn 1;\n\n\tdebug(\"%s: sock %d id %d limit %d\", __func__, sock, id, max_persource);\n\tif (getpeername(sock, sa, &addrlen) != 0)\n\t\treturn 1;\t \n\tif (addr_sa_to_xaddr(sa, addrlen, &xa) != 0)\n\t\treturn 1;\t \n\n\t \n\tbits = xa.af == AF_INET ? ipv4_masklen : ipv6_masklen;\n\tif (addr_netmask(xa.af, bits, &xmask) != 0 ||\n\t    addr_and(&xb, &xa, &xmask) != 0) {\n\t\tdebug3(\"%s: invalid mask %d bits\", __func__, bits);\n\t\treturn 1;\n\t}\n\n\tfirst_unused = max_children;\n\t \n\tfor (i = 0; i < max_children; i++) {\n\t\tif (child[i].id == -1) {\n\t\t\tif (i < first_unused)\n\t\t\t\tfirst_unused = i;\n\t\t} else if (addr_cmp(&child[i].addr, &xb) == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (addr_ntop(&xa, xas, sizeof(xas)) != 0) {\n\t\tdebug3(\"%s: addr ntop failed\", __func__);\n\t\treturn 1;\n\t}\n\tdebug3(\"%s: new unauthenticated connection from %s/%d, at %d of %d\",\n\t    __func__, xas, bits, count, max_persource);\n\n\tif (first_unused == max_children) {  \n\t\tdebug3(\"%s: no free slot\", __func__);\n\t\treturn 0;\n\t}\n\tif (first_unused < 0 || first_unused >= max_children)\n\t\tfatal(\"%s: internal error: first_unused out of range\",\n\t\t    __func__);\n\n\tif (count >= max_persource)\n\t\treturn 0;\n\n\t \n\tchild[first_unused].id = id;\n\tmemcpy(&child[first_unused].addr, &xb, sizeof(xb));\n\treturn 1;\n}\n\nvoid\nsrclimit_done(int id)\n{\n\tint i;\n\n\tif (max_persource == INT_MAX)\t \n\t\treturn;\n\n\tdebug(\"%s: id %d\", __func__, id);\n\t \n\tfor (i = 0; i < max_children; i++) {\n\t\tif (child[i].id == id) {\n\t\t\tchild[i].id = -1;\n\t\t\treturn;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}