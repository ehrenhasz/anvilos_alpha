{
  "module_name": "gss-genr.c",
  "hash_id": "10806012e3f32f7607d553df8b457dccd113fe86cf815bd21a33900bf2ee0730",
  "original_prompt": "Ingested from openssh-9.6p1/gss-genr.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#ifdef GSSAPI\n\n#include <sys/types.h>\n\n#include <limits.h>\n#include <stdarg.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"ssh2.h\"\n\n#include \"ssh-gss.h\"\n\n \nint\nssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)\n{\n\tint r;\n\tu_char *p;\n\tsize_t len;\n\n\tif ((r = sshbuf_get_string(b, &p, &len)) != 0)\n\t\treturn r;\n\tg->value = p;\n\tg->length = len;\n\treturn 0;\n}\n\n \nint\nssh_gssapi_check_oid(Gssctxt *ctx, void *data, size_t len)\n{\n\treturn (ctx != NULL && ctx->oid != GSS_C_NO_OID &&\n\t    ctx->oid->length == len &&\n\t    memcmp(ctx->oid->elements, data, len) == 0);\n}\n\n \nvoid\nssh_gssapi_set_oid_data(Gssctxt *ctx, void *data, size_t len)\n{\n\tif (ctx->oid != GSS_C_NO_OID) {\n\t\tfree(ctx->oid->elements);\n\t\tfree(ctx->oid);\n\t}\n\tctx->oid = xcalloc(1, sizeof(gss_OID_desc));\n\tctx->oid->length = len;\n\tctx->oid->elements = xmalloc(len);\n\tmemcpy(ctx->oid->elements, data, len);\n}\n\n \nvoid\nssh_gssapi_set_oid(Gssctxt *ctx, gss_OID oid)\n{\n\tssh_gssapi_set_oid_data(ctx, oid->elements, oid->length);\n}\n\n \nvoid\nssh_gssapi_error(Gssctxt *ctxt)\n{\n\tchar *s;\n\n\ts = ssh_gssapi_last_error(ctxt, NULL, NULL);\n\tdebug(\"%s\", s);\n\tfree(s);\n}\n\nchar *\nssh_gssapi_last_error(Gssctxt *ctxt, OM_uint32 *major_status,\n    OM_uint32 *minor_status)\n{\n\tOM_uint32 lmin;\n\tgss_buffer_desc msg = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 ctx;\n\tstruct sshbuf *b;\n\tchar *ret;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tif (major_status != NULL)\n\t\t*major_status = ctxt->major;\n\tif (minor_status != NULL)\n\t\t*minor_status = ctxt->minor;\n\n\tctx = 0;\n\t \n\tdo {\n\t\tgss_display_status(&lmin, ctxt->major,\n\t\t    GSS_C_GSS_CODE, ctxt->oid, &ctx, &msg);\n\n\t\tif ((r = sshbuf_put(b, msg.value, msg.length)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, '\\n')) != 0)\n\t\t\tfatal_fr(r, \"assemble GSS_CODE\");\n\n\t\tgss_release_buffer(&lmin, &msg);\n\t} while (ctx != 0);\n\n\t \n\tdo {\n\t\tgss_display_status(&lmin, ctxt->minor,\n\t\t    GSS_C_MECH_CODE, ctxt->oid, &ctx, &msg);\n\n\t\tif ((r = sshbuf_put(b, msg.value, msg.length)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, '\\n')) != 0)\n\t\t\tfatal_fr(r, \"assemble MECH_CODE\");\n\n\t\tgss_release_buffer(&lmin, &msg);\n\t} while (ctx != 0);\n\n\tif ((r = sshbuf_put_u8(b, '\\n')) != 0)\n\t\tfatal_fr(r, \"assemble newline\");\n\tret = xstrdup((const char *)sshbuf_ptr(b));\n\tsshbuf_free(b);\n\treturn (ret);\n}\n\n \nvoid\nssh_gssapi_build_ctx(Gssctxt **ctx)\n{\n\t*ctx = xcalloc(1, sizeof (Gssctxt));\n\t(*ctx)->context = GSS_C_NO_CONTEXT;\n\t(*ctx)->name = GSS_C_NO_NAME;\n\t(*ctx)->oid = GSS_C_NO_OID;\n\t(*ctx)->creds = GSS_C_NO_CREDENTIAL;\n\t(*ctx)->client = GSS_C_NO_NAME;\n\t(*ctx)->client_creds = GSS_C_NO_CREDENTIAL;\n}\n\n \nvoid\nssh_gssapi_delete_ctx(Gssctxt **ctx)\n{\n\tOM_uint32 ms;\n\n\tif ((*ctx) == NULL)\n\t\treturn;\n\tif ((*ctx)->context != GSS_C_NO_CONTEXT)\n\t\tgss_delete_sec_context(&ms, &(*ctx)->context, GSS_C_NO_BUFFER);\n\tif ((*ctx)->name != GSS_C_NO_NAME)\n\t\tgss_release_name(&ms, &(*ctx)->name);\n\tif ((*ctx)->oid != GSS_C_NO_OID) {\n\t\tfree((*ctx)->oid->elements);\n\t\tfree((*ctx)->oid);\n\t\t(*ctx)->oid = GSS_C_NO_OID;\n\t}\n\tif ((*ctx)->creds != GSS_C_NO_CREDENTIAL)\n\t\tgss_release_cred(&ms, &(*ctx)->creds);\n\tif ((*ctx)->client != GSS_C_NO_NAME)\n\t\tgss_release_name(&ms, &(*ctx)->client);\n\tif ((*ctx)->client_creds != GSS_C_NO_CREDENTIAL)\n\t\tgss_release_cred(&ms, &(*ctx)->client_creds);\n\n\tfree(*ctx);\n\t*ctx = NULL;\n}\n\n \nOM_uint32\nssh_gssapi_init_ctx(Gssctxt *ctx, int deleg_creds, gss_buffer_desc *recv_tok,\n    gss_buffer_desc* send_tok, OM_uint32 *flags)\n{\n\tint deleg_flag = 0;\n\n\tif (deleg_creds) {\n\t\tdeleg_flag = GSS_C_DELEG_FLAG;\n\t\tdebug(\"Delegating credentials\");\n\t}\n\n\tctx->major = gss_init_sec_context(&ctx->minor,\n\t    GSS_C_NO_CREDENTIAL, &ctx->context, ctx->name, ctx->oid,\n\t    GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG | deleg_flag,\n\t    0, NULL, recv_tok, NULL, send_tok, flags, NULL);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}\n\n \nOM_uint32\nssh_gssapi_import_name(Gssctxt *ctx, const char *host)\n{\n\tgss_buffer_desc gssbuf;\n\tchar *val;\n\n\txasprintf(&val, \"host@%s\", host);\n\tgssbuf.value = val;\n\tgssbuf.length = strlen(gssbuf.value);\n\n\tif ((ctx->major = gss_import_name(&ctx->minor,\n\t    &gssbuf, GSS_C_NT_HOSTBASED_SERVICE, &ctx->name)))\n\t\tssh_gssapi_error(ctx);\n\n\tfree(gssbuf.value);\n\treturn (ctx->major);\n}\n\nOM_uint32\nssh_gssapi_sign(Gssctxt *ctx, gss_buffer_t buffer, gss_buffer_t hash)\n{\n\tif ((ctx->major = gss_get_mic(&ctx->minor, ctx->context,\n\t    GSS_C_QOP_DEFAULT, buffer, hash)))\n\t\tssh_gssapi_error(ctx);\n\n\treturn (ctx->major);\n}\n\nvoid\nssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,\n    const char *context, const struct sshbuf *session_id)\n{\n\tint r;\n\n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_stringb(b, session_id)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, context)) != 0)\n\t\tfatal_fr(r, \"assemble buildmic\");\n}\n\nint\nssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host)\n{\n\tgss_buffer_desc token = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 major, minor;\n\tgss_OID_desc spnego_oid = {6, (void *)\"\\x2B\\x06\\x01\\x05\\x05\\x02\"};\n\n\t \n\tif (oid->length == spnego_oid.length && \n\t    (memcmp(oid->elements, spnego_oid.elements, oid->length) == 0))\n\t\treturn 0;  \n\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\tmajor = ssh_gssapi_import_name(*ctx, host);\n\tif (!GSS_ERROR(major)) {\n\t\tmajor = ssh_gssapi_init_ctx(*ctx, 0, GSS_C_NO_BUFFER, &token, \n\t\t    NULL);\n\t\tgss_release_buffer(&minor, &token);\n\t\tif ((*ctx)->context != GSS_C_NO_CONTEXT)\n\t\t\tgss_delete_sec_context(&minor, &(*ctx)->context,\n\t\t\t    GSS_C_NO_BUFFER);\n\t}\n\n\tif (GSS_ERROR(major)) \n\t\tssh_gssapi_delete_ctx(ctx);\n\n\treturn (!GSS_ERROR(major));\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}