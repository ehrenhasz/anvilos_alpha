{
  "module_name": "match.c",
  "hash_id": "b8fe518f01d903589e43b7136006a81e09465b93fe459110793cbc087f5bf687",
  "original_prompt": "Ingested from openssh-9.6p1/match.c",
  "human_readable_source": " \n \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"xmalloc.h\"\n#include \"match.h\"\n#include \"misc.h\"\n\n \nint\nmatch_pattern(const char *s, const char *pattern)\n{\n\tfor (;;) {\n\t\t \n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t \n\t\t\twhile (*pattern == '*')\n\t\t\t\tpattern++;\n\n\t\t\t \n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t \n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t \n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tfor (; *s; s++)\n\t\t\t\tif (match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (*pattern != '?' && *pattern != *s)\n\t\t\treturn 0;\n\n\t\t \n\t\ts++;\n\t\tpattern++;\n\t}\n\t \n}\n\n \nint\nmatch_pattern_list(const char *string, const char *pattern, int dolower)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t \n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t \n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = dolower && isupper((u_char)pattern[i]) ?\n\t\t\t    tolower((u_char)pattern[i]) : pattern[i];\n\t\t \n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t \n\t\tsub[subi] = '\\0';\n\n\t\t \n\t\tif (match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t \n\t\t\telse\n\t\t\t\tgot_positive = 1;\t \n\t\t}\n\t}\n\n\t \n\treturn got_positive;\n}\n\n \nint\nmatch_usergroup_pattern_list(const char *string, const char *pattern)\n{\n#ifdef HAVE_CYGWIN\n\t \n\treturn cygwin_ug_match_pattern_list(string, pattern);\n#else\n\t \n\treturn match_pattern_list(string, pattern, 0);\n#endif\n}\n\n \nint\nmatch_hostname(const char *host, const char *pattern)\n{\n\tchar *hostcopy = xstrdup(host);\n\tint r;\n\n\tlowercase(hostcopy);\n\tr = match_pattern_list(hostcopy, pattern, 1);\n\tfree(hostcopy);\n\treturn r;\n}\n\n \nint\nmatch_host_and_ip(const char *host, const char *ipaddr,\n    const char *patterns)\n{\n\tint mhost, mip;\n\n\tif ((mip = addr_match_list(ipaddr, patterns)) == -2)\n\t\treturn -1;  \n\telse if (host == NULL || ipaddr == NULL || mip == -1)\n\t\treturn 0;  \n\n\t \n\tif ((mhost = match_hostname(host, patterns)) == -1)\n\t\treturn 0;\n\t \n\tif (mhost == 0 && mip == 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint\nmatch_user(const char *user, const char *host, const char *ipaddr,\n    const char *pattern)\n{\n\tchar *p, *pat;\n\tint ret;\n\n\t \n\tif (user == NULL && host == NULL && ipaddr == NULL) {\n\t\tif ((p = strchr(pattern, '@')) != NULL &&\n\t\t    match_host_and_ip(NULL, NULL, p + 1) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif (user == NULL)\n\t\treturn 0;  \n\n\tif ((p = strchr(pattern, '@')) == NULL)\n\t\treturn match_pattern(user, pattern);\n\n\tpat = xstrdup(pattern);\n\tp = strchr(pat, '@');\n\t*p++ = '\\0';\n\n\tif ((ret = match_pattern(user, pat)) == 1)\n\t\tret = match_host_and_ip(host, ipaddr, p);\n\tfree(pat);\n\n\treturn ret;\n}\n\n \n#define\tMAX_PROP\t40\n#define\tSEP\t\",\"\nchar *\nmatch_list(const char *client, const char *server, u_int *next)\n{\n\tchar *sproposals[MAX_PROP];\n\tchar *c, *s, *p, *ret, *cp, *sp;\n\tint i, j, nproposals;\n\n\tc = cp = xstrdup(client);\n\ts = sp = xstrdup(server);\n\n\tfor ((p = strsep(&sp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&sp, SEP)), i++) {\n\t\tif (i < MAX_PROP)\n\t\t\tsproposals[i] = p;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnproposals = i;\n\n\tfor ((p = strsep(&cp, SEP)), i=0; p && *p != '\\0';\n\t    (p = strsep(&cp, SEP)), i++) {\n\t\tfor (j = 0; j < nproposals; j++) {\n\t\t\tif (strcmp(p, sproposals[j]) == 0) {\n\t\t\t\tret = xstrdup(p);\n\t\t\t\tif (next != NULL)\n\t\t\t\t\t*next = (cp == NULL) ?\n\t\t\t\t\t    strlen(c) : (u_int)(cp - c);\n\t\t\t\tfree(c);\n\t\t\t\tfree(s);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tif (next != NULL)\n\t\t*next = strlen(c);\n\tfree(c);\n\tfree(s);\n\treturn NULL;\n}\n\n \nstatic char *\nfilter_list(const char *proposal, const char *filter, int denylist)\n{\n\tsize_t len = strlen(proposal) + 1;\n\tchar *fix_prop = malloc(len);\n\tchar *orig_prop = strdup(proposal);\n\tchar *cp, *tmp;\n\tint r;\n\n\tif (fix_prop == NULL || orig_prop == NULL) {\n\t\tfree(orig_prop);\n\t\tfree(fix_prop);\n\t\treturn NULL;\n\t}\n\n\ttmp = orig_prop;\n\t*fix_prop = '\\0';\n\twhile ((cp = strsep(&tmp, \",\")) != NULL) {\n\t\tr = match_pattern_list(cp, filter, 0);\n\t\tif ((denylist && r != 1) || (!denylist && r == 1)) {\n\t\t\tif (*fix_prop != '\\0')\n\t\t\t\tstrlcat(fix_prop, \",\", len);\n\t\t\tstrlcat(fix_prop, cp, len);\n\t\t}\n\t}\n\tfree(orig_prop);\n\treturn fix_prop;\n}\n\n \nchar *\nmatch_filter_denylist(const char *proposal, const char *filter)\n{\n\treturn filter_list(proposal, filter, 1);\n}\n\n \nchar *\nmatch_filter_allowlist(const char *proposal, const char *filter)\n{\n\treturn filter_list(proposal, filter, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}