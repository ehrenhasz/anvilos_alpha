{
  "module_name": "channels.c",
  "hash_id": "fd4d5ce0c54184b31d77de473d08869ebc92ac77f0fc3860b992b9b37f875760",
  "original_prompt": "Ingested from openssh-9.6p1/channels.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <netdb.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"canohost.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"pathnames.h\"\n#include \"match.h\"\n\n \n \n\n \n#define\tNUM_SOCKS\t10\n\n \n \n#define FWD_PERMIT_ANY_PORT\t0\n\n \n#define FWD_PERMIT_ANY_HOST\t\"*\"\n\n \n \n#define MAX_DISPLAYS  1000\n\n \ntypedef void chan_fn(struct ssh *, Channel *c);\n\n \n \n \n \nstruct permission {\n\tchar *host_to_connect;\t\t \n\tint port_to_connect;\t\t \n\tchar *listen_host;\t\t \n\tchar *listen_path;\t\t \n\tint listen_port;\t\t \n\tChannel *downstream;\t\t \n};\n\n \nstruct permission_set {\n\t \n\tu_int num_permitted_user;\n\tstruct permission *permitted_user;\n\n\t \n\tu_int num_permitted_admin;\n\tstruct permission *permitted_admin;\n\n\t \n\tint all_permitted;\n};\n\n \nstruct ssh_channel_timeout {\n\tchar *type_pattern;\n\tint timeout_secs;\n};\n\n \nstruct ssh_channels {\n\t \n\tChannel **channels;\n\n\t \n\tu_int channels_alloc;\n\n\t \n\tchan_fn **channel_pre;\n\tchan_fn **channel_post;\n\n\t \n\tstruct permission_set local_perms;\n\tstruct permission_set remote_perms;\n\n\t \n\n\t \n\tchar *x11_saved_display;\n\n\t \n\tchar *x11_saved_proto;\n\n\t \n\tchar *x11_saved_data;\n\tu_int x11_saved_data_len;\n\n\t \n\ttime_t x11_refuse_time;\n\n\t \n\tu_char *x11_fake_data;\n\tu_int x11_fake_data_len;\n\n\t \n\tint IPv4or6;\n\n\t \n\tstruct ssh_channel_timeout *timeouts;\n\tsize_t ntimeouts;\n};\n\n \nstatic void port_open_helper(struct ssh *ssh, Channel *c, char *rtype);\nstatic const char *channel_rfwd_bind_host(const char *listen_host);\n\n \nstatic int connect_next(struct channel_connect *);\nstatic void channel_connect_ctx_free(struct channel_connect *);\nstatic Channel *rdynamic_connect_prepare(struct ssh *, char *, char *);\nstatic int rdynamic_connect_finish(struct ssh *, Channel *);\n\n \nstatic void channel_handler_init(struct ssh_channels *sc);\n\n \n\nvoid\nchannel_init_channels(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc;\n\n\tif ((sc = calloc(1, sizeof(*sc))) == NULL)\n\t\tfatal_f(\"allocation failed\");\n\tsc->channels_alloc = 10;\n\tsc->channels = xcalloc(sc->channels_alloc, sizeof(*sc->channels));\n\tsc->IPv4or6 = AF_UNSPEC;\n\tchannel_handler_init(sc);\n\n\tssh->chanctxt = sc;\n}\n\nChannel *\nchannel_by_id(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif (id < 0 || (u_int)id >= ssh->chanctxt->channels_alloc) {\n\t\tlogit_f(\"%d: bad id\", id);\n\t\treturn NULL;\n\t}\n\tc = ssh->chanctxt->channels[id];\n\tif (c == NULL) {\n\t\tlogit_f(\"%d: bad id: channel free\", id);\n\t\treturn NULL;\n\t}\n\treturn c;\n}\n\nChannel *\nchannel_by_remote_id(struct ssh *ssh, u_int remote_id)\n{\n\tChannel *c;\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL && c->have_remote_id && c->remote_id == remote_id)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\n \nChannel *\nchannel_lookup(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\treturn NULL;\n\n\tswitch (c->type) {\n\tcase SSH_CHANNEL_X11_OPEN:\n\tcase SSH_CHANNEL_LARVAL:\n\tcase SSH_CHANNEL_CONNECTING:\n\tcase SSH_CHANNEL_DYNAMIC:\n\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\tcase SSH_CHANNEL_OPENING:\n\tcase SSH_CHANNEL_OPEN:\n\tcase SSH_CHANNEL_ABANDONED:\n\tcase SSH_CHANNEL_MUX_PROXY:\n\t\treturn c;\n\t}\n\tlogit(\"Non-public channel %d, type %d.\", id, c->type);\n\treturn NULL;\n}\n\n \nvoid\nchannel_add_timeout(struct ssh *ssh, const char *type_pattern,\n    int timeout_secs)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tdebug2_f(\"channel type \\\"%s\\\" timeout %d seconds\",\n\t    type_pattern, timeout_secs);\n\tsc->timeouts = xrecallocarray(sc->timeouts, sc->ntimeouts,\n\t    sc->ntimeouts + 1, sizeof(*sc->timeouts));\n\tsc->timeouts[sc->ntimeouts].type_pattern = xstrdup(type_pattern);\n\tsc->timeouts[sc->ntimeouts].timeout_secs = timeout_secs;\n\tsc->ntimeouts++;\n}\n\n \nvoid\nchannel_clear_timeouts(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tsize_t i;\n\n\tdebug3_f(\"clearing\");\n\tfor (i = 0; i < sc->ntimeouts; i++)\n\t\tfree(sc->timeouts[i].type_pattern);\n\tfree(sc->timeouts);\n\tsc->timeouts = NULL;\n\tsc->ntimeouts = 0;\n}\n\nstatic int\nlookup_timeout(struct ssh *ssh, const char *type)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tsize_t i;\n\n\tfor (i = 0; i < sc->ntimeouts; i++) {\n\t\tif (match_pattern(type, sc->timeouts[i].type_pattern))\n\t\t\treturn sc->timeouts[i].timeout_secs;\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nchannel_set_xtype(struct ssh *ssh, int id, const char *xctype)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal_f(\"missing channel %d\", id);\n\tif (c->xctype != NULL)\n\t\tfree(c->xctype);\n\tc->xctype = xstrdup(xctype);\n\t \n\tc->inactive_deadline = lookup_timeout(ssh, c->xctype);\n\tdebug2_f(\"labeled channel %d as %s (inactive timeout %u)\", id, xctype,\n\t    c->inactive_deadline);\n}\n\n \nstatic void\nchannel_register_fds(struct ssh *ssh, Channel *c, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty)\n{\n\tint val;\n\n\tif (rfd != -1)\n\t\t(void)fcntl(rfd, F_SETFD, FD_CLOEXEC);\n\tif (wfd != -1 && wfd != rfd)\n\t\t(void)fcntl(wfd, F_SETFD, FD_CLOEXEC);\n\tif (efd != -1 && efd != rfd && efd != wfd)\n\t\t(void)fcntl(efd, F_SETFD, FD_CLOEXEC);\n\n\tc->rfd = rfd;\n\tc->wfd = wfd;\n\tc->sock = (rfd == wfd) ? rfd : -1;\n\tc->efd = efd;\n\tc->extended_usage = extusage;\n\n\tif ((c->isatty = is_tty) != 0)\n\t\tdebug2(\"channel %d: rfd %d isatty\", c->self, c->rfd);\n#ifdef _AIX\n\t \n\tc->wfd_isatty = is_tty || isatty(c->wfd);\n#endif\n\n\t \n\tc->restore_block = 0;\n\tif (nonblock == CHANNEL_NONBLOCK_STDIO) {\n\t\t \n\t\tif (rfd != -1 && !isatty(rfd) &&\n\t\t    (val = fcntl(rfd, F_GETFL)) != -1 && !(val & O_NONBLOCK)) {\n\t\t\tc->restore_flags[0] = val;\n\t\t\tc->restore_block |= CHANNEL_RESTORE_RFD;\n\t\t\tset_nonblock(rfd);\n\t\t}\n\t\tif (wfd != -1 && !isatty(wfd) &&\n\t\t    (val = fcntl(wfd, F_GETFL)) != -1 && !(val & O_NONBLOCK)) {\n\t\t\tc->restore_flags[1] = val;\n\t\t\tc->restore_block |= CHANNEL_RESTORE_WFD;\n\t\t\tset_nonblock(wfd);\n\t\t}\n\t\tif (efd != -1 && !isatty(efd) &&\n\t\t    (val = fcntl(efd, F_GETFL)) != -1 && !(val & O_NONBLOCK)) {\n\t\t\tc->restore_flags[2] = val;\n\t\t\tc->restore_block |= CHANNEL_RESTORE_EFD;\n\t\t\tset_nonblock(efd);\n\t\t}\n\t} else if (nonblock) {\n\t\tif (rfd != -1)\n\t\t\tset_nonblock(rfd);\n\t\tif (wfd != -1)\n\t\t\tset_nonblock(wfd);\n\t\tif (efd != -1)\n\t\t\tset_nonblock(efd);\n\t}\n}\n\n \nChannel *\nchannel_new(struct ssh *ssh, char *ctype, int type, int rfd, int wfd, int efd,\n    u_int window, u_int maxpack, int extusage, const char *remote_name,\n    int nonblock)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, found = 0;\n\tChannel *c;\n\tint r;\n\n\t \n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL) {\n\t\t\t \n\t\t\tfound = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= sc->channels_alloc) {\n\t\t \n\t\tfound = sc->channels_alloc;\n\t\tif (sc->channels_alloc > CHANNELS_MAX_CHANNELS)\n\t\t\tfatal_f(\"internal error: channels_alloc %d too big\",\n\t\t\t    sc->channels_alloc);\n\t\tsc->channels = xrecallocarray(sc->channels, sc->channels_alloc,\n\t\t    sc->channels_alloc + 10, sizeof(*sc->channels));\n\t\tsc->channels_alloc += 10;\n\t\tdebug2(\"channel: expanding %d\", sc->channels_alloc);\n\t}\n\t \n\tc = sc->channels[found] = xcalloc(1, sizeof(Channel));\n\tif ((c->input = sshbuf_new()) == NULL ||\n\t    (c->output = sshbuf_new()) == NULL ||\n\t    (c->extended = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_set_max_size(c->input, CHAN_INPUT_MAX)) != 0)\n\t\tfatal_fr(r, \"sshbuf_set_max_size\");\n\tc->ostate = CHAN_OUTPUT_OPEN;\n\tc->istate = CHAN_INPUT_OPEN;\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, 0);\n\tc->self = found;\n\tc->type = type;\n\tc->ctype = ctype;\n\tc->local_window = window;\n\tc->local_window_max = window;\n\tc->local_maxpacket = maxpack;\n\tc->remote_name = xstrdup(remote_name);\n\tc->ctl_chan = -1;\n\tc->delayed = 1;\t\t \n\tc->inactive_deadline = lookup_timeout(ssh, c->ctype);\n\tTAILQ_INIT(&c->status_confirms);\n\tdebug(\"channel %d: new %s [%s] (inactive timeout: %u)\",\n\t    found, c->ctype, remote_name, c->inactive_deadline);\n\treturn c;\n}\n\nint\nchannel_close_fd(struct ssh *ssh, Channel *c, int *fdp)\n{\n\tint ret, fd = *fdp;\n\n\tif (fd == -1)\n\t\treturn 0;\n\n\t \n\tif (*fdp == c->rfd &&\n\t    (c->restore_block & CHANNEL_RESTORE_RFD) != 0)\n\t\t(void)fcntl(*fdp, F_SETFL, c->restore_flags[0]);\n\telse if (*fdp == c->wfd &&\n\t    (c->restore_block & CHANNEL_RESTORE_WFD) != 0)\n\t\t(void)fcntl(*fdp, F_SETFL, c->restore_flags[1]);\n\telse if (*fdp == c->efd &&\n\t    (c->restore_block & CHANNEL_RESTORE_EFD) != 0)\n\t\t(void)fcntl(*fdp, F_SETFL, c->restore_flags[2]);\n\n\tif (*fdp == c->rfd) {\n\t\tc->io_want &= ~SSH_CHAN_IO_RFD;\n\t\tc->io_ready &= ~SSH_CHAN_IO_RFD;\n\t\tc->rfd = -1;\n\t\tc->pfds[0] = -1;\n\t}\n\tif (*fdp == c->wfd) {\n\t\tc->io_want &= ~SSH_CHAN_IO_WFD;\n\t\tc->io_ready &= ~SSH_CHAN_IO_WFD;\n\t\tc->wfd = -1;\n\t\tc->pfds[1] = -1;\n\t}\n\tif (*fdp == c->efd) {\n\t\tc->io_want &= ~SSH_CHAN_IO_EFD;\n\t\tc->io_ready &= ~SSH_CHAN_IO_EFD;\n\t\tc->efd = -1;\n\t\tc->pfds[2] = -1;\n\t}\n\tif (*fdp == c->sock) {\n\t\tc->io_want &= ~SSH_CHAN_IO_SOCK;\n\t\tc->io_ready &= ~SSH_CHAN_IO_SOCK;\n\t\tc->sock = -1;\n\t\tc->pfds[3] = -1;\n\t}\n\n\tret = close(fd);\n\t*fdp = -1;  \n\treturn ret;\n}\n\n \nstatic void\nchannel_close_fds(struct ssh *ssh, Channel *c)\n{\n\tint sock = c->sock, rfd = c->rfd, wfd = c->wfd, efd = c->efd;\n\n\tchannel_close_fd(ssh, c, &c->sock);\n\tif (rfd != sock)\n\t\tchannel_close_fd(ssh, c, &c->rfd);\n\tif (wfd != sock && wfd != rfd)\n\t\tchannel_close_fd(ssh, c, &c->wfd);\n\tif (efd != sock && efd != rfd && efd != wfd)\n\t\tchannel_close_fd(ssh, c, &c->efd);\n}\n\nstatic void\nfwd_perm_clear(struct permission *perm)\n{\n\tfree(perm->host_to_connect);\n\tfree(perm->listen_host);\n\tfree(perm->listen_path);\n\tmemset(perm, 0, sizeof(*perm));\n}\n\n \nstatic const char *\nfwd_ident(int who, int where)\n{\n\tif (who == FORWARD_ADM) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"admin local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"admin remote\";\n\t} else if (who == FORWARD_USER) {\n\t\tif (where == FORWARD_LOCAL)\n\t\t\treturn \"user local\";\n\t\telse if (where == FORWARD_REMOTE)\n\t\t\treturn \"user remote\";\n\t}\n\tfatal(\"Unknown forward permission list %d/%d\", who, where);\n}\n\n \nstatic struct permission_set *\npermission_set_get(struct ssh *ssh, int where)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tswitch (where) {\n\tcase FORWARD_LOCAL:\n\t\treturn &sc->local_perms;\n\t\tbreak;\n\tcase FORWARD_REMOTE:\n\t\treturn &sc->remote_perms;\n\t\tbreak;\n\tdefault:\n\t\tfatal_f(\"invalid forwarding direction %d\", where);\n\t}\n}\n\n \nstatic void\npermission_set_get_array(struct ssh *ssh, int who, int where,\n    struct permission ***permpp, u_int **npermpp)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tswitch (who) {\n\tcase FORWARD_USER:\n\t\t*permpp = &pset->permitted_user;\n\t\t*npermpp = &pset->num_permitted_user;\n\t\tbreak;\n\tcase FORWARD_ADM:\n\t\t*permpp = &pset->permitted_admin;\n\t\t*npermpp = &pset->num_permitted_admin;\n\t\tbreak;\n\tdefault:\n\t\tfatal_f(\"invalid forwarding client %d\", who);\n\t}\n}\n\n \nstatic int\npermission_set_add(struct ssh *ssh, int who, int where,\n    const char *host_to_connect, int port_to_connect,\n    const char *listen_host, const char *listen_path, int listen_port,\n    Channel *downstream)\n{\n\tstruct permission **permp;\n\tu_int n, *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\n\tif (*npermp >= INT_MAX)\n\t\tfatal_f(\"%s overflow\", fwd_ident(who, where));\n\n\t*permp = xrecallocarray(*permp, *npermp, *npermp + 1, sizeof(**permp));\n\tn = (*npermp)++;\n#define MAYBE_DUP(s) ((s == NULL) ? NULL : xstrdup(s))\n\t(*permp)[n].host_to_connect = MAYBE_DUP(host_to_connect);\n\t(*permp)[n].port_to_connect = port_to_connect;\n\t(*permp)[n].listen_host = MAYBE_DUP(listen_host);\n\t(*permp)[n].listen_path = MAYBE_DUP(listen_path);\n\t(*permp)[n].listen_port = listen_port;\n\t(*permp)[n].downstream = downstream;\n#undef MAYBE_DUP\n\treturn (int)n;\n}\n\nstatic void\nmux_remove_remote_forwardings(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct permission *perm;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (perm->downstream != c)\n\t\t\tcontinue;\n\n\t\t \n\t\tdebug(\"channel %d: cleanup remote forward for %s:%u\",\n\t\t    c->self, perm->listen_host, perm->listen_port);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"cancel-tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(perm->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, perm->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal_fr(r, \"channel %i\", c->self);\n\t\t}\n\t\tfwd_perm_clear(perm);  \n\t}\n}\n\n \nvoid\nchannel_free(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchar *s;\n\tu_int i, n;\n\tChannel *other;\n\tstruct channel_confirm *cc;\n\n\tfor (n = 0, i = 0; i < sc->channels_alloc; i++) {\n\t\tif ((other = sc->channels[i]) == NULL)\n\t\t\tcontinue;\n\t\tn++;\n\t\t \n\t\tif (c->type == SSH_CHANNEL_MUX_CLIENT &&\n\t\t    other->type == SSH_CHANNEL_MUX_PROXY &&\n\t\t    other->mux_ctx == c) {\n\t\t\tother->mux_ctx = NULL;\n\t\t\tother->type = SSH_CHANNEL_OPEN;\n\t\t\tother->istate = CHAN_INPUT_CLOSED;\n\t\t\tother->ostate = CHAN_OUTPUT_CLOSED;\n\t\t}\n\t}\n\tdebug(\"channel %d: free: %s, nchannels %u\", c->self,\n\t    c->remote_name ? c->remote_name : \"???\", n);\n\n\tif (c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tmux_remove_remote_forwardings(ssh, c);\n\t\tfree(c->mux_ctx);\n\t\tc->mux_ctx = NULL;\n\t} else if (c->type == SSH_CHANNEL_MUX_LISTENER) {\n\t\tfree(c->mux_ctx);\n\t\tc->mux_ctx = NULL;\n\t}\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG3) {\n\t\ts = channel_open_message(ssh);\n\t\tdebug3(\"channel %d: status: %s\", c->self, s);\n\t\tfree(s);\n\t}\n\n\tchannel_close_fds(ssh, c);\n\tsshbuf_free(c->input);\n\tsshbuf_free(c->output);\n\tsshbuf_free(c->extended);\n\tc->input = c->output = c->extended = NULL;\n\tfree(c->remote_name);\n\tc->remote_name = NULL;\n\tfree(c->path);\n\tc->path = NULL;\n\tfree(c->listening_addr);\n\tc->listening_addr = NULL;\n\tfree(c->xctype);\n\tc->xctype = NULL;\n\twhile ((cc = TAILQ_FIRST(&c->status_confirms)) != NULL) {\n\t\tif (cc->abandon_cb != NULL)\n\t\t\tcc->abandon_cb(ssh, c, cc->ctx);\n\t\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\t\tfreezero(cc, sizeof(*cc));\n\t}\n\tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n\t\tc->filter_cleanup(ssh, c->self, c->filter_ctx);\n\tsc->channels[c->self] = NULL;\n\tfreezero(c, sizeof(*c));\n}\n\nvoid\nchannel_free_all(struct ssh *ssh)\n{\n\tu_int i;\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\n\tfor (i = 0; i < sc->channels_alloc; i++)\n\t\tif (sc->channels[i] != NULL)\n\t\t\tchannel_free(ssh, sc->channels[i]);\n\n\tfree(sc->channels);\n\tsc->channels = NULL;\n\tsc->channels_alloc = 0;\n\n\tfree(sc->x11_saved_display);\n\tsc->x11_saved_display = NULL;\n\n\tfree(sc->x11_saved_proto);\n\tsc->x11_saved_proto = NULL;\n\n\tfree(sc->x11_saved_data);\n\tsc->x11_saved_data = NULL;\n\tsc->x11_saved_data_len = 0;\n\n\tfree(sc->x11_fake_data);\n\tsc->x11_fake_data = NULL;\n\tsc->x11_fake_data_len = 0;\n}\n\n \nvoid\nchannel_close_all(struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++)\n\t\tif (ssh->chanctxt->channels[i] != NULL)\n\t\t\tchannel_close_fds(ssh, ssh->chanctxt->channels[i]);\n}\n\n \nvoid\nchannel_stop_listening(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c != NULL) {\n\t\t\tswitch (c->type) {\n\t\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\t\tchannel_close_fd(ssh, c, &c->sock);\n\t\t\t\tchannel_free(ssh, c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint\nchannel_not_very_much_buffered_data(struct ssh *ssh)\n{\n\tu_int i;\n\tu_int maxsize = ssh_packet_get_maxsize(ssh);\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (sshbuf_len(c->output) > maxsize) {\n\t\t\tdebug2(\"channel %d: big output buffer %zu > %u\",\n\t\t\t    c->self, sshbuf_len(c->output), maxsize);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nint\nchannel_still_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tfatal_f(\"bad channel type %d\", c->type);\n\t\t\t \n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint\nchannel_tty_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (c->client_tty)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint\nchannel_find_open(struct ssh *ssh)\n{\n\tu_int i;\n\tChannel *c;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || !c->have_remote_id)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\t\treturn i;\n\t\tdefault:\n\t\t\tfatal_f(\"bad channel type %d\", c->type);\n\t\t\t \n\t\t}\n\t}\n\treturn -1;\n}\n\n \nconst char *\nchannel_format_extended_usage(const Channel *c)\n{\n\tif (c->efd == -1)\n\t\treturn \"closed\";\n\n\tswitch (c->extended_usage) {\n\tcase CHAN_EXTENDED_WRITE:\n\t\treturn \"write\";\n\tcase CHAN_EXTENDED_READ:\n\t\treturn \"read\";\n\tcase CHAN_EXTENDED_IGNORE:\n\t\treturn \"ignore\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic char *\nchannel_format_status(const Channel *c)\n{\n\tchar *ret = NULL;\n\n\txasprintf(&ret, \"t%d [%s] %s%u i%u/%zu o%u/%zu e[%s]/%zu \"\n\t    \"fd %d/%d/%d sock %d cc %d io 0x%02x/0x%02x\",\n\t    c->type, c->xctype != NULL ? c->xctype : c->ctype,\n\t    c->have_remote_id ? \"r\" : \"nr\", c->remote_id,\n\t    c->istate, sshbuf_len(c->input),\n\t    c->ostate, sshbuf_len(c->output),\n\t    channel_format_extended_usage(c), sshbuf_len(c->extended),\n\t    c->rfd, c->wfd, c->efd, c->sock, c->ctl_chan,\n\t    c->io_want, c->io_ready);\n\treturn ret;\n}\n\n \nchar *\nchannel_open_message(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tChannel *c;\n\tu_int i;\n\tint r;\n\tchar *cp, *ret;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_putf(buf,\n\t    \"The following connections are open:\\r\\n\")) != 0)\n\t\tfatal_fr(r, \"sshbuf_putf\");\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tc = ssh->chanctxt->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tswitch (c->type) {\n\t\tcase SSH_CHANNEL_X11_LISTENER:\n\t\tcase SSH_CHANNEL_PORT_LISTENER:\n\t\tcase SSH_CHANNEL_RPORT_LISTENER:\n\t\tcase SSH_CHANNEL_CLOSED:\n\t\tcase SSH_CHANNEL_AUTH_SOCKET:\n\t\tcase SSH_CHANNEL_ZOMBIE:\n\t\tcase SSH_CHANNEL_ABANDONED:\n\t\tcase SSH_CHANNEL_MUX_LISTENER:\n\t\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\t\tcontinue;\n\t\tcase SSH_CHANNEL_LARVAL:\n\t\tcase SSH_CHANNEL_OPENING:\n\t\tcase SSH_CHANNEL_CONNECTING:\n\t\tcase SSH_CHANNEL_DYNAMIC:\n\t\tcase SSH_CHANNEL_RDYNAMIC_OPEN:\n\t\tcase SSH_CHANNEL_RDYNAMIC_FINISH:\n\t\tcase SSH_CHANNEL_OPEN:\n\t\tcase SSH_CHANNEL_X11_OPEN:\n\t\tcase SSH_CHANNEL_MUX_PROXY:\n\t\tcase SSH_CHANNEL_MUX_CLIENT:\n\t\t\tcp = channel_format_status(c);\n\t\t\tif ((r = sshbuf_putf(buf, \"  #%d %.300s (%s)\\r\\n\",\n\t\t\t    c->self, c->remote_name, cp)) != 0) {\n\t\t\t\tfree(cp);\n\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t}\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tfatal_f(\"bad channel type %d\", c->type);\n\t\t\t \n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(buf)) == NULL)\n\t\tfatal_f(\"sshbuf_dup_string\");\n\tsshbuf_free(buf);\n\treturn ret;\n}\n\nstatic void\nopen_preamble(struct ssh *ssh, const char *where, Channel *c, const char *type)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, type)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0) {\n\t\tfatal_r(r, \"%s: channel %i: open\", where, c->self);\n\t}\n}\n\nvoid\nchannel_send_open(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit(\"channel_send_open: %d: bad id\", id);\n\t\treturn;\n\t}\n\tdebug2(\"channel %d: send open\", id);\n\topen_preamble(ssh, __func__, c, c->ctype);\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i\", c->self);\n}\n\nvoid\nchannel_request_start(struct ssh *ssh, int id, char *service, int wantconfirm)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL) {\n\t\tlogit_f(\"%d: unknown channel id\", id);\n\t\treturn;\n\t}\n\tif (!c->have_remote_id)\n\t\tfatal_f(\"channel %d: no remote id\", c->self);\n\n\tdebug2(\"channel %d: request %s confirm %d\", id, service, wantconfirm);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, wantconfirm)) != 0) {\n\t\tfatal_fr(r, \"channel %i\", c->self);\n\t}\n}\n\nvoid\nchannel_register_status_confirm(struct ssh *ssh, int id,\n    channel_confirm_cb *cb, channel_confirm_abandon_cb *abandon_cb, void *ctx)\n{\n\tstruct channel_confirm *cc;\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal_f(\"%d: bad id\", id);\n\n\tcc = xcalloc(1, sizeof(*cc));\n\tcc->cb = cb;\n\tcc->abandon_cb = abandon_cb;\n\tcc->ctx = ctx;\n\tTAILQ_INSERT_TAIL(&c->status_confirms, cc, entry);\n}\n\nvoid\nchannel_register_open_confirm(struct ssh *ssh, int id,\n    channel_open_fn *fn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit_f(\"%d: bad id\", id);\n\t\treturn;\n\t}\n\tc->open_confirm = fn;\n\tc->open_confirm_ctx = ctx;\n}\n\nvoid\nchannel_register_cleanup(struct ssh *ssh, int id,\n    channel_callback_fn *fn, int do_close)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit_f(\"%d: bad id\", id);\n\t\treturn;\n\t}\n\tc->detach_user = fn;\n\tc->detach_close = do_close;\n}\n\nvoid\nchannel_cancel_cleanup(struct ssh *ssh, int id)\n{\n\tChannel *c = channel_by_id(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit_f(\"%d: bad id\", id);\n\t\treturn;\n\t}\n\tc->detach_user = NULL;\n\tc->detach_close = 0;\n}\n\nvoid\nchannel_register_filter(struct ssh *ssh, int id, channel_infilter_fn *ifn,\n    channel_outfilter_fn *ofn, channel_filter_cleanup_fn *cfn, void *ctx)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\n\tif (c == NULL) {\n\t\tlogit_f(\"%d: bad id\", id);\n\t\treturn;\n\t}\n\tc->input_filter = ifn;\n\tc->output_filter = ofn;\n\tc->filter_ctx = ctx;\n\tc->filter_cleanup = cfn;\n}\n\nvoid\nchannel_set_fds(struct ssh *ssh, int id, int rfd, int wfd, int efd,\n    int extusage, int nonblock, int is_tty, u_int window_max)\n{\n\tChannel *c = channel_lookup(ssh, id);\n\tint r;\n\n\tif (c == NULL || c->type != SSH_CHANNEL_LARVAL)\n\t\tfatal(\"channel_activate for non-larval channel %d.\", id);\n\tif (!c->have_remote_id)\n\t\tfatal_f(\"channel %d: no remote id\", c->self);\n\n\tchannel_register_fds(ssh, c, rfd, wfd, efd, extusage, nonblock, is_tty);\n\tc->type = SSH_CHANNEL_OPEN;\n\tc->lastused = monotime();\n\tc->local_window = c->local_window_max = window_max;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i\", c->self);\n}\n\nstatic void\nchannel_pre_listener(struct ssh *ssh, Channel *c)\n{\n\tc->io_want = SSH_CHAN_IO_SOCK_R;\n}\n\nstatic void\nchannel_pre_connecting(struct ssh *ssh, Channel *c)\n{\n\tdebug3(\"channel %d: waiting for connection\", c->self);\n\tc->io_want = SSH_CHAN_IO_SOCK_W;\n}\n\nstatic void\nchannel_pre_open(struct ssh *ssh, Channel *c)\n{\n\tc->io_want = 0;\n\tif (c->istate == CHAN_INPUT_OPEN &&\n\t    c->remote_window > 0 &&\n\t    sshbuf_len(c->input) < c->remote_window &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tc->io_want |= SSH_CHAN_IO_RFD;\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0) {\n\t\t\tc->io_want |= SSH_CHAN_IO_WFD;\n\t\t} else if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\t\tif (CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"obuf_empty delayed efd %d/(%zu)\", c->self,\n\t\t\t\t    c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_obuf_empty(ssh, c);\n\t\t}\n\t}\n\t \n\tif (c->efd != -1 && !(c->istate == CHAN_INPUT_CLOSED &&\n\t    c->ostate == CHAN_OUTPUT_CLOSED)) {\n\t\tif (c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t\t    sshbuf_len(c->extended) > 0)\n\t\t\tc->io_want |= SSH_CHAN_IO_EFD_W;\n\t\telse if (c->efd != -1 && !(c->flags & CHAN_EOF_SENT) &&\n\t\t    (c->extended_usage == CHAN_EXTENDED_READ ||\n\t\t    c->extended_usage == CHAN_EXTENDED_IGNORE) &&\n\t\t    sshbuf_len(c->extended) < c->remote_window)\n\t\t\tc->io_want |= SSH_CHAN_IO_EFD_R;\n\t}\n\t \n}\n\n \nstatic int\nx11_open_helper(struct ssh *ssh, struct sshbuf *b)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n\n\t \n\tif (sc->x11_refuse_time != 0 &&\n\t    monotime() >= sc->x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (sshbuf_len(b) < 12)\n\t\treturn 0;\n\n\t \n\tucp = sshbuf_mutable_ptr(b);\n\tif (ucp[0] == 0x42) {\t \n\t\tproto_len = 256 * ucp[6] + ucp[7];\n\t\tdata_len = 256 * ucp[8] + ucp[9];\n\t} else if (ucp[0] == 0x6c) {\t \n\t\tproto_len = ucp[6] + 256 * ucp[7];\n\t\tdata_len = ucp[8] + 256 * ucp[9];\n\t} else {\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}\n\n\t \n\tif (sshbuf_len(b) <\n\t    12 + ((proto_len + 3) & ~3) + ((data_len + 3) & ~3))\n\t\treturn 0;\n\n\t \n\tif (proto_len != strlen(sc->x11_saved_proto) ||\n\t    memcmp(ucp + 12, sc->x11_saved_proto, proto_len) != 0) {\n\t\tdebug2(\"X11 connection uses different authentication protocol.\");\n\t\treturn -1;\n\t}\n\t \n\tif (data_len != sc->x11_fake_data_len ||\n\t    timingsafe_bcmp(ucp + 12 + ((proto_len + 3) & ~3),\n\t\tsc->x11_fake_data, sc->x11_fake_data_len) != 0) {\n\t\tdebug2(\"X11 auth data does not match fake data.\");\n\t\treturn -1;\n\t}\n\t \n\tif (sc->x11_fake_data_len != sc->x11_saved_data_len) {\n\t\terror(\"X11 fake_data_len %d != saved_data_len %d\",\n\t\t    sc->x11_fake_data_len, sc->x11_saved_data_len);\n\t\treturn -1;\n\t}\n\t \n\tmemcpy(ucp + 12 + ((proto_len + 3) & ~3),\n\t    sc->x11_saved_data, sc->x11_saved_data_len);\n\treturn 1;\n}\n\nvoid\nchannel_force_close(struct ssh *ssh, Channel *c, int abandon)\n{\n\tdebug3_f(\"channel %d: forcibly closing\", c->self);\n\tif (c->istate == CHAN_INPUT_OPEN)\n\t\tchan_read_failed(ssh, c);\n\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\tsshbuf_reset(c->input);\n\t\tchan_ibuf_empty(ssh, c);\n\t}\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tsshbuf_reset(c->output);\n\t\tchan_write_failed(ssh, c);\n\t}\n\tif (c->detach_user)\n\t\tc->detach_user(ssh, c->self, 1, NULL);\n\tif (c->efd != -1)\n\t\tchannel_close_fd(ssh, c, &c->efd);\n\tif (abandon)\n\t\tc->type = SSH_CHANNEL_ABANDONED;\n\t \n\tc->inactive_deadline = 0;\n\tc->lastused = 0;\n}\n\nstatic void\nchannel_pre_x11_open(struct ssh *ssh, Channel *c)\n{\n\tint ret = x11_open_helper(ssh, c->output);\n\n\t \n\n\tif (ret == 1) {\n\t\tc->type = SSH_CHANNEL_OPEN;\n\t\tc->lastused = monotime();\n\t\tchannel_pre_open(ssh, c);\n\t} else if (ret == -1) {\n\t\tlogit(\"X11 connection rejected because of wrong \"\n\t\t    \"authentication.\");\n\t\tdebug2(\"X11 rejected %d i%d/o%d\",\n\t\t    c->self, c->istate, c->ostate);\n\t\tchannel_force_close(ssh, c, 0);\n\t}\n}\n\nstatic void\nchannel_pre_mux_client(struct ssh *ssh, Channel *c)\n{\n\tc->io_want = 0;\n\tif (c->istate == CHAN_INPUT_OPEN && !c->mux_pause &&\n\t    sshbuf_check_reserve(c->input, CHAN_RBUF) == 0)\n\t\tc->io_want |= SSH_CHAN_IO_RFD;\n\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t \n\t\tsshbuf_reset(c->input);\n\t\tchan_ibuf_empty(ssh, c);\n\t\t \n\t\tchan_rcvd_oclose(ssh, c);\n\t}\n\tif (c->ostate == CHAN_OUTPUT_OPEN ||\n\t    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {\n\t\tif (sshbuf_len(c->output) > 0)\n\t\t\tc->io_want |= SSH_CHAN_IO_WFD;\n\t\telse if (c->ostate == CHAN_OUTPUT_WAIT_DRAIN)\n\t\t\tchan_obuf_empty(ssh, c);\n\t}\n}\n\n \nstatic int\nchannel_decode_socks4(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\tconst u_char *p;\n\tchar *host;\n\tu_int len, have, i, found, need;\n\tchar username[256];\n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int16_t dest_port;\n\t\tstruct in_addr dest_addr;\n\t} s4_req, s4_rsp;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks4\", c->self);\n\n\thave = sshbuf_len(input);\n\tlen = sizeof(s4_req);\n\tif (have < len)\n\t\treturn 0;\n\tp = sshbuf_ptr(input);\n\n\tneed = 1;\n\t \n\tif (p[4] == 0 && p[5] == 0 && p[6] == 0 && p[7] != 0) {\n\t\tdebug2(\"channel %d: socks4a request\", c->self);\n\t\t \n\t\tneed = 2;\n\t}\n\t \n\tfor (found = 0, i = len; i < have; i++) {\n\t\tif (p[i] == '\\0') {\n\t\t\tfound++;\n\t\t\tif (found == need)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 1024) {\n\t\t\t \n\t\t\tdebug(\"channel %d: decode socks4: too long\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (found < need)\n\t\treturn 0;\n\tif ((r = sshbuf_get(input, &s4_req.version, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.command, 1)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_port, 2)) != 0 ||\n\t    (r = sshbuf_get(input, &s4_req.dest_addr, 4)) != 0) {\n\t\tdebug_r(r, \"channels %d: decode socks4\", c->self);\n\t\treturn -1;\n\t}\n\thave = sshbuf_len(input);\n\tp = sshbuf_ptr(input);\n\tif (memchr(p, '\\0', have) == NULL) {\n\t\terror(\"channel %d: decode socks4: unterminated user\", c->self);\n\t\treturn -1;\n\t}\n\tlen = strlen(p);\n\tdebug2(\"channel %d: decode socks4: user %s/%d\", c->self, p, len);\n\tlen++;  \n\tstrlcpy(username, p, sizeof(username));\n\tif ((r = sshbuf_consume(input, len)) != 0)\n\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\tfree(c->path);\n\tc->path = NULL;\n\tif (need == 1) {\t\t\t \n\t\thost = inet_ntoa(s4_req.dest_addr);\n\t\tc->path = xstrdup(host);\n\t} else {\t\t\t\t \n\t\thave = sshbuf_len(input);\n\t\tp = sshbuf_ptr(input);\n\t\tif (memchr(p, '\\0', have) == NULL) {\n\t\t\terror(\"channel %d: decode socks4a: host not nul \"\n\t\t\t    \"terminated\", c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(p);\n\t\tdebug2(\"channel %d: decode socks4a: host %s/%d\",\n\t\t    c->self, p, len);\n\t\tlen++;\t\t\t\t \n\t\tif (len > NI_MAXHOST) {\n\t\t\terror(\"channel %d: hostname \\\"%.100s\\\" too long\",\n\t\t\t    c->self, p);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(p);\n\t\tif ((r = sshbuf_consume(input, len)) != 0)\n\t\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\t}\n\tc->host_port = ntohs(s4_req.dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks4 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s4_req.command);\n\n\tif (s4_req.command != 1) {\n\t\tdebug(\"channel %d: cannot handle: %s cn %d\",\n\t\t    c->self, need == 1 ? \"SOCKS4\" : \"SOCKS4A\", s4_req.command);\n\t\treturn -1;\n\t}\n\ts4_rsp.version = 0;\t\t\t \n\ts4_rsp.command = 90;\t\t\t \n\ts4_rsp.dest_port = 0;\t\t\t \n\ts4_rsp.dest_addr.s_addr = INADDR_ANY;\t \n\tif ((r = sshbuf_put(output, &s4_rsp, sizeof(s4_rsp))) != 0)\n\t\tfatal_fr(r, \"channel %d: append reply\", c->self);\n\treturn 1;\n}\n\n \n#define SSH_SOCKS5_AUTHDONE\t0x1000\n#define SSH_SOCKS5_NOAUTH\t0x00\n#define SSH_SOCKS5_IPV4\t\t0x01\n#define SSH_SOCKS5_DOMAIN\t0x03\n#define SSH_SOCKS5_IPV6\t\t0x04\n#define SSH_SOCKS5_CONNECT\t0x01\n#define SSH_SOCKS5_SUCCESS\t0x00\n\nstatic int\nchannel_decode_socks5(Channel *c, struct sshbuf *input, struct sshbuf *output)\n{\n\t \n\tstruct {\n\t\tu_int8_t version;\n\t\tu_int8_t command;\n\t\tu_int8_t reserved;\n\t\tu_int8_t atyp;\n\t} s5_req, s5_rsp;\n\tu_int16_t dest_port;\n\tchar dest_addr[255+1], ntop[INET6_ADDRSTRLEN];\n\tconst u_char *p;\n\tu_int have, need, i, found, nmethods, addrlen, af;\n\tint r;\n\n\tdebug2(\"channel %d: decode socks5\", c->self);\n\tp = sshbuf_ptr(input);\n\tif (p[0] != 0x05)\n\t\treturn -1;\n\thave = sshbuf_len(input);\n\tif (!(c->flags & SSH_SOCKS5_AUTHDONE)) {\n\t\t \n\t\tif (have < 2)\n\t\t\treturn 0;\n\t\tnmethods = p[1];\n\t\tif (have < nmethods + 2)\n\t\t\treturn 0;\n\t\t \n\t\tfor (found = 0, i = 2; i < nmethods + 2; i++) {\n\t\t\tif (p[i] == SSH_SOCKS5_NOAUTH) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tdebug(\"channel %d: method SSH_SOCKS5_NOAUTH not found\",\n\t\t\t    c->self);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((r = sshbuf_consume(input, nmethods + 2)) != 0)\n\t\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\t\t \n\t\tif ((r = sshbuf_put_u8(output, 0x05)) != 0 ||\n\t\t    (r = sshbuf_put_u8(output, SSH_SOCKS5_NOAUTH)) != 0)\n\t\t\tfatal_fr(r, \"channel %d: append reply\", c->self);\n\t\tc->flags |= SSH_SOCKS5_AUTHDONE;\n\t\tdebug2(\"channel %d: socks5 auth done\", c->self);\n\t\treturn 0;\t\t\t\t \n\t}\n\tdebug2(\"channel %d: socks5 post auth\", c->self);\n\tif (have < sizeof(s5_req)+1)\n\t\treturn 0;\t\t\t \n\tmemcpy(&s5_req, p, sizeof(s5_req));\n\tif (s5_req.version != 0x05 ||\n\t    s5_req.command != SSH_SOCKS5_CONNECT ||\n\t    s5_req.reserved != 0x00) {\n\t\tdebug2(\"channel %d: only socks5 connect supported\", c->self);\n\t\treturn -1;\n\t}\n\tswitch (s5_req.atyp){\n\tcase SSH_SOCKS5_IPV4:\n\t\taddrlen = 4;\n\t\taf = AF_INET;\n\t\tbreak;\n\tcase SSH_SOCKS5_DOMAIN:\n\t\taddrlen = p[sizeof(s5_req)];\n\t\taf = -1;\n\t\tbreak;\n\tcase SSH_SOCKS5_IPV6:\n\t\taddrlen = 16;\n\t\taf = AF_INET6;\n\t\tbreak;\n\tdefault:\n\t\tdebug2(\"channel %d: bad socks5 atyp %d\", c->self, s5_req.atyp);\n\t\treturn -1;\n\t}\n\tneed = sizeof(s5_req) + addrlen + 2;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN)\n\t\tneed++;\n\tif (have < need)\n\t\treturn 0;\n\tif ((r = sshbuf_consume(input, sizeof(s5_req))) != 0)\n\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\t \n\t\tif ((r = sshbuf_consume(input, 1)) != 0)\n\t\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\t}\n\tif ((r = sshbuf_get(input, &dest_addr, addrlen)) != 0 ||\n\t    (r = sshbuf_get(input, &dest_port, 2)) != 0) {\n\t\tdebug_r(r, \"channel %d: parse addr/port\", c->self);\n\t\treturn -1;\n\t}\n\tdest_addr[addrlen] = '\\0';\n\tfree(c->path);\n\tc->path = NULL;\n\tif (s5_req.atyp == SSH_SOCKS5_DOMAIN) {\n\t\tif (addrlen >= NI_MAXHOST) {\n\t\t\terror(\"channel %d: dynamic request: socks5 hostname \"\n\t\t\t    \"\\\"%.100s\\\" too long\", c->self, dest_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tc->path = xstrdup(dest_addr);\n\t} else {\n\t\tif (inet_ntop(af, dest_addr, ntop, sizeof(ntop)) == NULL)\n\t\t\treturn -1;\n\t\tc->path = xstrdup(ntop);\n\t}\n\tc->host_port = ntohs(dest_port);\n\n\tdebug2(\"channel %d: dynamic request: socks5 host %s port %u command %u\",\n\t    c->self, c->path, c->host_port, s5_req.command);\n\n\ts5_rsp.version = 0x05;\n\ts5_rsp.command = SSH_SOCKS5_SUCCESS;\n\ts5_rsp.reserved = 0;\t\t\t \n\ts5_rsp.atyp = SSH_SOCKS5_IPV4;\n\tdest_port = 0;\t\t\t\t \n\n\tif ((r = sshbuf_put(output, &s5_rsp, sizeof(s5_rsp))) != 0 ||\n\t    (r = sshbuf_put_u32(output, ntohl(INADDR_ANY))) != 0 ||\n\t    (r = sshbuf_put(output, &dest_port, sizeof(dest_port))) != 0)\n\t\tfatal_fr(r, \"channel %d: append reply\", c->self);\n\treturn 1;\n}\n\nChannel *\nchannel_connect_stdio_fwd(struct ssh *ssh,\n    const char *host_to_connect, int port_to_connect,\n    int in, int out, int nonblock)\n{\n\tChannel *c;\n\n\tdebug_f(\"%s:%d\", host_to_connect, port_to_connect);\n\n\tc = channel_new(ssh, \"stdio-forward\", SSH_CHANNEL_OPENING, in, out,\n\t    -1, CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"stdio-forward\", nonblock);\n\n\tc->path = xstrdup(host_to_connect);\n\tc->host_port = port_to_connect;\n\tc->listening_port = 0;\n\tc->force_drain = 1;\n\n\tchannel_register_fds(ssh, c, in, out, -1, 0, 1, 0);\n\tport_open_helper(ssh, c, port_to_connect == PORT_STREAMLOCAL ?\n\t    \"direct-streamlocal@openssh.com\" : \"direct-tcpip\");\n\n\treturn c;\n}\n\n \nstatic void\nchannel_pre_dynamic(struct ssh *ssh, Channel *c)\n{\n\tconst u_char *p;\n\tu_int have;\n\tint ret;\n\n\tc->io_want = 0;\n\thave = sshbuf_len(c->input);\n\tdebug2(\"channel %d: pre_dynamic: have %d\", c->self, have);\n\t \n\t \n\tif (have < 3) {\n\t\t \n\t\tc->io_want |= SSH_CHAN_IO_RFD;\n\t\treturn;\n\t}\n\t \n\tp = sshbuf_ptr(c->input);\n\t \n\tswitch (p[0]) {\n\tcase 0x04:\n\t\tret = channel_decode_socks4(c, c->input, c->output);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->input, c->output);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\tchan_mark_dead(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_dynamic: need more\", c->self);\n\t\t \n\t\tc->io_want |= SSH_CHAN_IO_RFD;\n\t\tif (sshbuf_len(c->output))\n\t\t\tc->io_want |= SSH_CHAN_IO_WFD;\n\t} else {\n\t\t \n\t\tc->type = SSH_CHANNEL_OPENING;\n\t\tport_open_helper(ssh, c, \"direct-tcpip\");\n\t}\n}\n\n \nstatic void\nrdynamic_close(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_OPEN;\n\tchannel_force_close(ssh, c, 0);\n}\n\n \nstatic void\nchannel_before_prepare_io_rdynamic(struct ssh *ssh, Channel *c)\n{\n\tconst u_char *p;\n\tu_int have, len;\n\tint r, ret;\n\n\thave = sshbuf_len(c->output);\n\tdebug2(\"channel %d: pre_rdynamic: have %d\", c->self, have);\n\t \n\t \n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif ((r = sshbuf_consume(c->output, have)) != 0)\n\t\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\t\trdynamic_close(ssh, c);\n\t\treturn;\n\t}\n\t \n\tif (have < 3)\n\t\treturn;\n\t \n\tp = sshbuf_ptr(c->output);\n\tswitch (p[0]) {\n\tcase 0x04:\n\t\t \n\t\tret = channel_decode_socks4(c, c->output, c->input);\n\t\tbreak;\n\tcase 0x05:\n\t\tret = channel_decode_socks5(c, c->output, c->input);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\trdynamic_close(ssh, c);\n\t} else if (ret == 0) {\n\t\tdebug2(\"channel %d: pre_rdynamic: need more\", c->self);\n\t\t \n\t\tlen = sshbuf_len(c->input);\n\t\tif (len > 0 && len < c->remote_window) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_stringb(ssh, c->input)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\t\tfatal_fr(r, \"channel %i: rdynamic\", c->self);\n\t\t\t}\n\t\t\tif ((r = sshbuf_consume(c->input, len)) != 0)\n\t\t\t\tfatal_fr(r, \"channel %d: consume\", c->self);\n\t\t\tc->remote_window -= len;\n\t\t}\n\t} else if (rdynamic_connect_finish(ssh, c) < 0) {\n\t\t \n\t\trdynamic_close(ssh, c);\n\t}\n}\n\n \nstatic void\nchannel_post_x11_listener(struct ssh *ssh, Channel *c)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tint r, newsock, oerrno, remote_port;\n\tsocklen_t addrlen;\n\tchar buf[16384], *remote_ipaddr;\n\n\tif ((c->io_ready & SSH_CHAN_IO_SOCK_R) == 0)\n\t\treturn;\n\n\tdebug(\"X11 connection requested.\");\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (c->single_connection) {\n\t\toerrno = errno;\n\t\tdebug2(\"single_connection: closing X11 listener.\");\n\t\tchannel_close_fd(ssh, c, &c->sock);\n\t\tchan_mark_dead(ssh, c);\n\t\terrno = oerrno;\n\t}\n\tif (newsock == -1) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t    errno != ECONNABORTED)\n\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tset_nodelay(newsock);\n\tremote_ipaddr = get_peer_ipaddr(newsock);\n\tremote_port = get_peer_port(newsock);\n\tsnprintf(buf, sizeof buf, \"X11 connection from %.200s port %d\",\n\t    remote_ipaddr, remote_port);\n\n\tnc = channel_new(ssh, \"x11-connection\",\n\t    SSH_CHANNEL_OPENING, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket, 0, buf, 1);\n\topen_preamble(ssh, __func__, nc, \"x11\");\n\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, remote_port)) != 0) {\n\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i: send\", c->self);\n\tfree(remote_ipaddr);\n}\n\nstatic void\nport_open_helper(struct ssh *ssh, Channel *c, char *rtype)\n{\n\tchar *local_ipaddr = get_local_ipaddr(c->sock);\n\tint local_port = c->sock == -1 ? 65536 : get_local_port(c->sock);\n\tchar *remote_ipaddr = get_peer_ipaddr(c->sock);\n\tint remote_port = get_peer_port(c->sock);\n\tint r;\n\n\tif (remote_port == -1) {\n\t\t \n\t\tfree(remote_ipaddr);\n\t\tremote_ipaddr = xstrdup(\"127.0.0.1\");\n\t\tremote_port = 65535;\n\t}\n\n\tfree(c->remote_name);\n\txasprintf(&c->remote_name,\n\t    \"%s: listening port %d for %.100s port %d, \"\n\t    \"connect from %.200s port %d to %.100s port %d\",\n\t    rtype, c->listening_port, c->path, c->host_port,\n\t    remote_ipaddr, remote_port, local_ipaddr, local_port);\n\n\topen_preamble(ssh, __func__, c, rtype);\n\tif (strcmp(rtype, \"direct-tcpip\") == 0) {\n\t\t \n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->host_port)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t} else if (strcmp(rtype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\t \n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t} else if (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t \n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t} else {\n\t\t \n\t\tif ((r = sshpkt_put_cstring(ssh, c->path)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, local_port)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t}\n\tif (strcmp(rtype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\t \n\t\tif ((r = sshpkt_put_cstring(ssh, \"\")) != 0)\n\t\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t} else {\n\t\t \n\t\tif ((r = sshpkt_put_cstring(ssh, remote_ipaddr)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)remote_port)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: reply\", c->self);\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i: send\", c->self);\n\tfree(remote_ipaddr);\n\tfree(local_ipaddr);\n}\n\nvoid\nchannel_set_x11_refuse_time(struct ssh *ssh, time_t refuse_time)\n{\n\tssh->chanctxt->x11_refuse_time = refuse_time;\n}\n\n \nstatic void\nchannel_post_port_listener(struct ssh *ssh, Channel *c)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tint newsock, nextstate;\n\tsocklen_t addrlen;\n\tchar *rtype;\n\n\tif ((c->io_ready & SSH_CHAN_IO_SOCK_R) == 0)\n\t\treturn;\n\n\tdebug(\"Connection to port %d forwarding to %.100s port %d requested.\",\n\t    c->listening_port, c->path, c->host_port);\n\n\tif (c->type == SSH_CHANNEL_RPORT_LISTENER) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"forwarded-tcpip\";\n\t} else if (c->type == SSH_CHANNEL_RUNIX_LISTENER) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"forwarded-streamlocal@openssh.com\";\n\t} else if (c->host_port == PORT_STREAMLOCAL) {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"direct-streamlocal@openssh.com\";\n\t} else if (c->host_port == 0) {\n\t\tnextstate = SSH_CHANNEL_DYNAMIC;\n\t\trtype = \"dynamic-tcpip\";\n\t} else {\n\t\tnextstate = SSH_CHANNEL_OPENING;\n\t\trtype = \"direct-tcpip\";\n\t}\n\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (newsock == -1) {\n\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t    errno != ECONNABORTED)\n\t\t\terror(\"accept: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tif (c->host_port != PORT_STREAMLOCAL)\n\t\tset_nodelay(newsock);\n\tnc = channel_new(ssh, rtype, nextstate, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket, 0, rtype, 1);\n\tnc->listening_port = c->listening_port;\n\tnc->host_port = c->host_port;\n\tif (c->path != NULL)\n\t\tnc->path = xstrdup(c->path);\n\n\tif (nextstate != SSH_CHANNEL_DYNAMIC)\n\t\tport_open_helper(ssh, nc, rtype);\n}\n\n \nstatic void\nchannel_post_auth_listener(struct ssh *ssh, Channel *c)\n{\n\tChannel *nc;\n\tint r, newsock;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\n\tif ((c->io_ready & SSH_CHAN_IO_SOCK_R) == 0)\n\t\treturn;\n\n\taddrlen = sizeof(addr);\n\tnewsock = accept(c->sock, (struct sockaddr *)&addr, &addrlen);\n\tif (newsock == -1) {\n\t\terror(\"accept from auth socket: %.100s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\tnc = channel_new(ssh, \"agent-connection\",\n\t    SSH_CHANNEL_OPENING, newsock, newsock, -1,\n\t    c->local_window_max, c->local_maxpacket,\n\t    0, \"accepted auth socket\", 1);\n\topen_preamble(ssh, __func__, nc, \"auth-agent@openssh.com\");\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i\", c->self);\n}\n\nstatic void\nchannel_post_connecting(struct ssh *ssh, Channel *c)\n{\n\tint err = 0, sock, isopen, r;\n\tsocklen_t sz = sizeof(err);\n\n\tif ((c->io_ready & SSH_CHAN_IO_SOCK_W) == 0)\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal_f(\"channel %d: no remote id\", c->self);\n\t \n\tisopen = (c->type == SSH_CHANNEL_RDYNAMIC_FINISH);\n\n\tif (getsockopt(c->sock, SOL_SOCKET, SO_ERROR, &err, &sz) == -1) {\n\t\terr = errno;\n\t\terror(\"getsockopt SO_ERROR failed\");\n\t}\n\n\tif (err == 0) {\n\t\t \n\t\tdebug(\"channel %d: connected to %s port %d\",\n\t\t    c->self, c->connect_ctx.host, c->connect_ctx.port);\n\t\tchannel_connect_ctx_free(&c->connect_ctx);\n\t\tc->type = SSH_CHANNEL_OPEN;\n\t\tc->lastused = monotime();\n\t\tif (isopen) {\n\t\t\t \n\t\t} else {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"channel %i open confirm\", c->self);\n\t\t}\n\t\treturn;\n\t}\n\tif (err == EINTR || err == EAGAIN || err == EINPROGRESS)\n\t\treturn;\n\n\t \n\tdebug(\"channel %d: connection failed: %s\", c->self, strerror(err));\n\n\t \n\tif ((sock = connect_next(&c->connect_ctx)) == -1) {\n\t\t \n\t\terror(\"connect_to %.100s port %d: failed.\",\n\t\t    c->connect_ctx.host, c->connect_ctx.port);\n\t\tchannel_connect_ctx_free(&c->connect_ctx);\n\t\tif (isopen) {\n\t\t\trdynamic_close(ssh, c);\n\t\t} else {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh,\n\t\t\t    SSH2_OPEN_CONNECT_FAILED)) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, strerror(err))) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"channel %i: failure\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t}\n\t}\n\n\t \n\tclose(c->sock);\n\tc->sock = c->rfd = c->wfd = sock;\n}\n\nstatic int\nchannel_handle_rfd(struct ssh *ssh, Channel *c)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tint r, force;\n\tsize_t nr = 0, have, avail, maxlen = CHANNEL_MAX_READ;\n\tint pty_zeroread = 0;\n\n#ifdef PTY_ZEROREAD\n\t \n\tpty_zeroread = c->isatty;\n#endif\n\n\tforce = c->isatty && c->detach_close && c->istate != CHAN_INPUT_CLOSED;\n\n\tif (!force && (c->io_ready & SSH_CHAN_IO_RFD) == 0)\n\t\treturn 1;\n\tif ((avail = sshbuf_avail(c->input)) == 0)\n\t\treturn 1;  \n\n\t \n\tif (!pty_zeroread && c->input_filter == NULL && !c->datagram) {\n\t\t \n\t\tif (c->type == SSH_CHANNEL_OPEN) {\n\t\t\tif ((have = sshbuf_len(c->input)) >= c->remote_window)\n\t\t\t\treturn 1;  \n\t\t\tif (maxlen > c->remote_window - have)\n\t\t\t\tmaxlen = c->remote_window - have;\n\t\t}\n\t\tif (maxlen > avail)\n\t\t\tmaxlen = avail;\n\t\tif ((r = sshbuf_read(c->rfd, c->input, maxlen, &nr)) != 0) {\n\t\t\tif (errno == EINTR || (!force &&\n\t\t\t    (errno == EAGAIN || errno == EWOULDBLOCK)))\n\t\t\t\treturn 1;\n\t\t\tdebug2(\"channel %d: read failed rfd %d maxlen %zu: %s\",\n\t\t\t    c->self, c->rfd, maxlen, ssh_err(r));\n\t\t\tgoto rfail;\n\t\t}\n\t\tif (nr != 0)\n\t\t\tc->lastused = monotime();\n\t\treturn 1;\n\t}\n\n\terrno = 0;\n\tlen = read(c->rfd, buf, sizeof(buf));\n\t \n\tif (pty_zeroread && len == 0 && errno != 0)\n\t\tlen = -1;\n\tif (len == -1 && (errno == EINTR ||\n\t    ((errno == EAGAIN || errno == EWOULDBLOCK) && !force)))\n\t\treturn 1;\n\tif (len < 0 || (!pty_zeroread && len == 0)) {\n\t\tdebug2(\"channel %d: read<=0 rfd %d len %zd: %s\",\n\t\t    c->self, c->rfd, len,\n\t\t    len == 0 ? \"closed\" : strerror(errno));\n rfail:\n\t\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\t\tdebug2(\"channel %d: not open\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tchan_read_failed(ssh, c);\n\t\t}\n\t\treturn -1;\n\t}\n\tc->lastused = monotime();\n\tif (c->input_filter != NULL) {\n\t\tif (c->input_filter(ssh, c, buf, len) == -1) {\n\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n\t\t\tchan_read_failed(ssh, c);\n\t\t}\n\t} else if (c->datagram) {\n\t\tif ((r = sshbuf_put_string(c->input, buf, len)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: put datagram\", c->self);\n\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0)\n\t\tfatal_fr(r, \"channel %i: put data\", c->self);\n\n\treturn 1;\n}\n\nstatic int\nchannel_handle_wfd(struct ssh *ssh, Channel *c)\n{\n\tstruct termios tio;\n\tu_char *data = NULL, *buf;  \n\tsize_t dlen, olen = 0;\n\tint r, len;\n\n\tif ((c->io_ready & SSH_CHAN_IO_WFD) == 0)\n\t\treturn 1;\n\tif (sshbuf_len(c->output) == 0)\n\t\treturn 1;\n\n\t \n\tolen = sshbuf_len(c->output);\n\tif (c->output_filter != NULL) {\n\t\tif ((buf = c->output_filter(ssh, c, &data, &dlen)) == NULL) {\n\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n\t\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\t\tchan_mark_dead(ssh, c);\n\t\t\telse\n\t\t\t\tchan_write_failed(ssh, c);\n\t\t\treturn -1;\n\t\t}\n\t} else if (c->datagram) {\n\t\tif ((r = sshbuf_get_string(c->output, &data, &dlen)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: get datagram\", c->self);\n\t\tbuf = data;\n\t} else {\n\t\tbuf = data = sshbuf_mutable_ptr(c->output);\n\t\tdlen = sshbuf_len(c->output);\n\t}\n\n\tif (c->datagram) {\n\t\t \n\t\tlen = write(c->wfd, buf, dlen);\n\t\tfree(data);\n\t\tif (len == -1 && (errno == EINTR || errno == EAGAIN ||\n\t\t    errno == EWOULDBLOCK))\n\t\t\treturn 1;\n\t\tif (len <= 0)\n\t\t\tgoto write_fail;\n\t\tgoto out;\n\t}\n\n#ifdef _AIX\n\t \n\tif (c->wfd_isatty)\n\t\tdlen = MINIMUM(dlen, 8*1024);\n#endif\n\n\tlen = write(c->wfd, buf, dlen);\n\tif (len == -1 &&\n\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n write_fail:\n\t\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\t\tdebug2(\"channel %d: not open\", c->self);\n\t\t\tchan_mark_dead(ssh, c);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t\treturn -1;\n\t}\n\tc->lastused = monotime();\n#ifndef BROKEN_TCGETATTR_ICANON\n\tif (c->isatty && dlen >= 1 && buf[0] != '\\r') {\n\t\tif (tcgetattr(c->wfd, &tio) == 0 &&\n\t\t    !(tio.c_lflag & ECHO) && (tio.c_lflag & ICANON)) {\n\t\t\t \n\t\t\tif ((r = sshpkt_msg_ignore(ssh, 4+len)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"channel %i: ignore\", c->self);\n\t\t}\n\t}\n#endif  \n\tif ((r = sshbuf_consume(c->output, len)) != 0)\n\t\tfatal_fr(r, \"channel %i: consume\", c->self);\n out:\n\tc->local_consumed += olen - sshbuf_len(c->output);\n\n\treturn 1;\n}\n\nstatic int\nchannel_handle_efd_write(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\tssize_t len;\n\n\tif ((c->io_ready & SSH_CHAN_IO_EFD_W) == 0)\n\t\treturn 1;\n\tif (sshbuf_len(c->extended) == 0)\n\t\treturn 1;\n\n\tlen = write(c->efd, sshbuf_ptr(c->extended),\n\t    sshbuf_len(c->extended));\n\tdebug2(\"channel %d: written %zd to efd %d\", c->self, len, c->efd);\n\tif (len == -1 && (errno == EINTR || errno == EAGAIN ||\n\t    errno == EWOULDBLOCK))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing write-efd %d\", c->self, c->efd);\n\t\tchannel_close_fd(ssh, c, &c->efd);\n\t} else {\n\t\tif ((r = sshbuf_consume(c->extended, len)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: consume\", c->self);\n\t\tc->local_consumed += len;\n\t\tc->lastused = monotime();\n\t}\n\treturn 1;\n}\n\nstatic int\nchannel_handle_efd_read(struct ssh *ssh, Channel *c)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tint r, force;\n\n\tforce = c->isatty && c->detach_close && c->istate != CHAN_INPUT_CLOSED;\n\n\tif (!force && (c->io_ready & SSH_CHAN_IO_EFD_R) == 0)\n\t\treturn 1;\n\n\tlen = read(c->efd, buf, sizeof(buf));\n\tdebug2(\"channel %d: read %zd from efd %d\", c->self, len, c->efd);\n\tif (len == -1 && (errno == EINTR || ((errno == EAGAIN ||\n\t    errno == EWOULDBLOCK) && !force)))\n\t\treturn 1;\n\tif (len <= 0) {\n\t\tdebug2(\"channel %d: closing read-efd %d\", c->self, c->efd);\n\t\tchannel_close_fd(ssh, c, &c->efd);\n\t\treturn 1;\n\t}\n\tc->lastused = monotime();\n\tif (c->extended_usage == CHAN_EXTENDED_IGNORE)\n\t\tdebug3(\"channel %d: discard efd\", c->self);\n\telse if ((r = sshbuf_put(c->extended, buf, len)) != 0)\n\t\tfatal_fr(r, \"channel %i: append\", c->self);\n\treturn 1;\n}\n\nstatic int\nchannel_handle_efd(struct ssh *ssh, Channel *c)\n{\n\tif (c->efd == -1)\n\t\treturn 1;\n\n\t \n\n\tif (c->extended_usage == CHAN_EXTENDED_WRITE)\n\t\treturn channel_handle_efd_write(ssh, c);\n\telse if (c->extended_usage == CHAN_EXTENDED_READ ||\n\t    c->extended_usage == CHAN_EXTENDED_IGNORE)\n\t\treturn channel_handle_efd_read(ssh, c);\n\n\treturn 1;\n}\n\nstatic int\nchannel_check_window(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tif (c->type == SSH_CHANNEL_OPEN &&\n\t    !(c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD)) &&\n\t    ((c->local_window_max - c->local_window >\n\t    c->local_maxpacket*3) ||\n\t    c->local_window < c->local_window_max/2) &&\n\t    c->local_consumed > 0) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal_f(\"channel %d: no remote id\", c->self);\n\t\tif ((r = sshpkt_start(ssh,\n\t\t    SSH2_MSG_CHANNEL_WINDOW_ADJUST)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->local_consumed)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tfatal_fr(r, \"channel %i\", c->self);\n\t\t}\n\t\tdebug2(\"channel %d: window %d sent adjust %d\", c->self,\n\t\t    c->local_window, c->local_consumed);\n\t\tc->local_window += c->local_consumed;\n\t\tc->local_consumed = 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nchannel_post_open(struct ssh *ssh, Channel *c)\n{\n\tchannel_handle_rfd(ssh, c);\n\tchannel_handle_wfd(ssh, c);\n\tchannel_handle_efd(ssh, c);\n\tchannel_check_window(ssh, c);\n}\n\nstatic u_int\nread_mux(struct ssh *ssh, Channel *c, u_int need)\n{\n\tchar buf[CHAN_RBUF];\n\tssize_t len;\n\tu_int rlen;\n\tint r;\n\n\tif (sshbuf_len(c->input) < need) {\n\t\trlen = need - sshbuf_len(c->input);\n\t\tlen = read(c->rfd, buf, MINIMUM(rlen, CHAN_RBUF));\n\t\tif (len == -1 && (errno == EINTR || errno == EAGAIN))\n\t\t\treturn sshbuf_len(c->input);\n\t\tif (len <= 0) {\n\t\t\tdebug2(\"channel %d: ctl read<=0 rfd %d len %zd\",\n\t\t\t    c->self, c->rfd, len);\n\t\t\tchan_read_failed(ssh, c);\n\t\t\treturn 0;\n\t\t} else if ((r = sshbuf_put(c->input, buf, len)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: append\", c->self);\n\t}\n\treturn sshbuf_len(c->input);\n}\n\nstatic void\nchannel_post_mux_client_read(struct ssh *ssh, Channel *c)\n{\n\tu_int need;\n\n\tif ((c->io_ready & SSH_CHAN_IO_RFD) == 0)\n\t\treturn;\n\tif (c->istate != CHAN_INPUT_OPEN && c->istate != CHAN_INPUT_WAIT_DRAIN)\n\t\treturn;\n\tif (c->mux_pause)\n\t\treturn;\n\n\t \n\tif (read_mux(ssh, c, 4) < 4)  \n\t\treturn;\n\t \n\tneed = PEEK_U32(sshbuf_ptr(c->input));\n#define CHANNEL_MUX_MAX_PACKET\t(256 * 1024)\n\tif (need > CHANNEL_MUX_MAX_PACKET) {\n\t\tdebug2(\"channel %d: packet too big %u > %u\",\n\t\t    c->self, CHANNEL_MUX_MAX_PACKET, need);\n\t\tchan_rcvd_oclose(ssh, c);\n\t\treturn;\n\t}\n\tif (read_mux(ssh, c, need + 4) < need + 4)  \n\t\treturn;\n\tif (c->mux_rcb(ssh, c) != 0) {\n\t\tdebug(\"channel %d: mux_rcb failed\", c->self);\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n}\n\nstatic void\nchannel_post_mux_client_write(struct ssh *ssh, Channel *c)\n{\n\tssize_t len;\n\tint r;\n\n\tif ((c->io_ready & SSH_CHAN_IO_WFD) == 0)\n\t\treturn;\n\tif (sshbuf_len(c->output) == 0)\n\t\treturn;\n\n\tlen = write(c->wfd, sshbuf_ptr(c->output), sshbuf_len(c->output));\n\tif (len == -1 && (errno == EINTR || errno == EAGAIN))\n\t\treturn;\n\tif (len <= 0) {\n\t\tchan_mark_dead(ssh, c);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_consume(c->output, len)) != 0)\n\t\tfatal_fr(r, \"channel %i: consume\", c->self);\n}\n\nstatic void\nchannel_post_mux_client(struct ssh *ssh, Channel *c)\n{\n\tchannel_post_mux_client_read(ssh, c);\n\tchannel_post_mux_client_write(ssh, c);\n}\n\nstatic void\nchannel_post_mux_listener(struct ssh *ssh, Channel *c)\n{\n\tChannel *nc;\n\tstruct sockaddr_storage addr;\n\tsocklen_t addrlen;\n\tint newsock;\n\tuid_t euid;\n\tgid_t egid;\n\n\tif ((c->io_ready & SSH_CHAN_IO_SOCK_R) == 0)\n\t\treturn;\n\n\tdebug(\"multiplexing control connection\");\n\n\t \n\tmemset(&addr, 0, sizeof(addr));\n\taddrlen = sizeof(addr);\n\tif ((newsock = accept(c->sock, (struct sockaddr*)&addr,\n\t    &addrlen)) == -1) {\n\t\terror_f(\"accept: %s\", strerror(errno));\n\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\tc->notbefore = monotime() + 1;\n\t\treturn;\n\t}\n\n\tif (getpeereid(newsock, &euid, &egid) == -1) {\n\t\terror_f(\"getpeereid failed: %s\", strerror(errno));\n\t\tclose(newsock);\n\t\treturn;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"multiplex uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int)euid, (u_int)getuid());\n\t\tclose(newsock);\n\t\treturn;\n\t}\n\tnc = channel_new(ssh, \"mux-control\", SSH_CHANNEL_MUX_CLIENT,\n\t    newsock, newsock, -1, c->local_window_max,\n\t    c->local_maxpacket, 0, \"mux-control\", 1);\n\tnc->mux_rcb = c->mux_rcb;\n\tdebug3_f(\"new mux channel %d fd %d\", nc->self, nc->sock);\n\t \n\tnc->mux_rcb(ssh, nc);\n\t \n\tnc->flags |= CHAN_LOCAL;\n}\n\nstatic void\nchannel_handler_init(struct ssh_channels *sc)\n{\n\tchan_fn **pre, **post;\n\n\tif ((pre = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*pre))) == NULL ||\n\t    (post = calloc(SSH_CHANNEL_MAX_TYPE, sizeof(*post))) == NULL)\n\t\tfatal_f(\"allocation failed\");\n\n\tpre[SSH_CHANNEL_OPEN] =\t\t\t&channel_pre_open;\n\tpre[SSH_CHANNEL_X11_OPEN] =\t\t&channel_pre_x11_open;\n\tpre[SSH_CHANNEL_PORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_X11_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_CONNECTING] =\t\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_DYNAMIC] =\t\t&channel_pre_dynamic;\n\tpre[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_pre_connecting;\n\tpre[SSH_CHANNEL_MUX_LISTENER] =\t\t&channel_pre_listener;\n\tpre[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_pre_mux_client;\n\n\tpost[SSH_CHANNEL_OPEN] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_PORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RPORT_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_UNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_RUNIX_LISTENER] =\t&channel_post_port_listener;\n\tpost[SSH_CHANNEL_X11_LISTENER] =\t&channel_post_x11_listener;\n\tpost[SSH_CHANNEL_AUTH_SOCKET] =\t\t&channel_post_auth_listener;\n\tpost[SSH_CHANNEL_CONNECTING] =\t\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_DYNAMIC] =\t\t&channel_post_open;\n\tpost[SSH_CHANNEL_RDYNAMIC_FINISH] =\t&channel_post_connecting;\n\tpost[SSH_CHANNEL_MUX_LISTENER] =\t&channel_post_mux_listener;\n\tpost[SSH_CHANNEL_MUX_CLIENT] =\t\t&channel_post_mux_client;\n\n\tsc->channel_pre = pre;\n\tsc->channel_post = post;\n}\n\n \nstatic void\nchannel_garbage_collect(struct ssh *ssh, Channel *c)\n{\n\tif (c == NULL)\n\t\treturn;\n\tif (c->detach_user != NULL) {\n\t\tif (!chan_is_dead(ssh, c, c->detach_close))\n\t\t\treturn;\n\n\t\tdebug2(\"channel %d: gc: notify user\", c->self);\n\t\tc->detach_user(ssh, c->self, 0, NULL);\n\t\t \n\t\tif (c->detach_user != NULL)\n\t\t\treturn;\n\t\tdebug2(\"channel %d: gc: user detached\", c->self);\n\t}\n\tif (!chan_is_dead(ssh, c, 1))\n\t\treturn;\n\tdebug2(\"channel %d: garbage collecting\", c->self);\n\tchannel_free(ssh, c);\n}\n\nenum channel_table { CHAN_PRE, CHAN_POST };\n\nstatic void\nchannel_handler(struct ssh *ssh, int table, struct timespec *timeout)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tchan_fn **ftab = table == CHAN_PRE ? sc->channel_pre : sc->channel_post;\n\tu_int i, oalloc;\n\tChannel *c;\n\ttime_t now;\n\n\tnow = monotime();\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\t \n\t\tif (ssh_packet_is_rekeying(ssh) && c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (c->delayed) {\n\t\t\tif (table == CHAN_PRE)\n\t\t\t\tc->delayed = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (ftab[c->type] != NULL) {\n\t\t\tif (table == CHAN_PRE &&\n\t\t\t    c->type == SSH_CHANNEL_OPEN &&\n\t\t\t    c->inactive_deadline != 0 && c->lastused != 0 &&\n\t\t\t    now >= c->lastused + c->inactive_deadline) {\n\t\t\t\t \n\t\t\t\tverbose(\"channel %d: closing after %u seconds \"\n\t\t\t\t    \"of inactivity\", c->self,\n\t\t\t\t    c->inactive_deadline);\n\t\t\t\tchannel_force_close(ssh, c, 1);\n\t\t\t} else if (c->notbefore <= now) {\n\t\t\t\t \n\t\t\t\t(*ftab[c->type])(ssh, c);\n\t\t\t\t \n\t\t\t\tif (timeout != NULL &&\n\t\t\t\t    c->type == SSH_CHANNEL_OPEN &&\n\t\t\t\t    c->lastused != 0 &&\n\t\t\t\t    c->inactive_deadline != 0) {\n\t\t\t\t\tptimeout_deadline_monotime(timeout,\n\t\t\t\t\t    c->lastused + c->inactive_deadline);\n\t\t\t\t}\n\t\t\t} else if (timeout != NULL) {\n\t\t\t\t \n\t\t\t\tptimeout_deadline_monotime(timeout,\n\t\t\t\t    c->notbefore);\n\t\t\t}\n\t\t}\n\t\tchannel_garbage_collect(ssh, c);\n\t}\n}\n\n \nstatic void\nchannel_before_prepare_io(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i, oalloc;\n\n\tfor (i = 0, oalloc = sc->channels_alloc; i < oalloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\tif (c->type == SSH_CHANNEL_RDYNAMIC_OPEN)\n\t\t\tchannel_before_prepare_io_rdynamic(ssh, c);\n\t}\n}\n\nstatic void\ndump_channel_poll(const char *func, const char *what, Channel *c,\n    u_int pollfd_offset, struct pollfd *pfd)\n{\n#ifdef DEBUG_CHANNEL_POLL\n\tdebug3(\"%s: channel %d: %s r%d w%d e%d s%d c->pfds [ %d %d %d %d ] \"\n\t    \"io_want 0x%02x io_ready 0x%02x pfd[%u].fd=%d \"\n\t    \"pfd.ev 0x%02x pfd.rev 0x%02x\", func, c->self, what,\n\t    c->rfd, c->wfd, c->efd, c->sock,\n\t    c->pfds[0], c->pfds[1], c->pfds[2], c->pfds[3],\n\t    c->io_want, c->io_ready,\n\t    pollfd_offset, pfd->fd, pfd->events, pfd->revents);\n#endif\n}\n\n \nstatic void\nchannel_prepare_pollfd(Channel *c, u_int *next_pollfd,\n    struct pollfd *pfd, u_int npfd)\n{\n\tu_int ev, p = *next_pollfd;\n\n\tif (c == NULL)\n\t\treturn;\n\tif (p + 4 > npfd) {\n\t\t \n\t\tfatal_f(\"channel %d: bad pfd offset %u (max %u)\",\n\t\t    c->self, p, npfd);\n\t}\n\tc->pfds[0] = c->pfds[1] = c->pfds[2] = c->pfds[3] = -1;\n\t \n\tif (c->rfd != -1) {\n\t\tev = 0;\n\t\tif ((c->io_want & SSH_CHAN_IO_RFD) != 0)\n\t\t\tev |= POLLIN;\n\t\t \n\t\tif (c->wfd == c->rfd) {\n\t\t\tif ((c->io_want & SSH_CHAN_IO_WFD) != 0)\n\t\t\t\tev |= POLLOUT;\n\t\t}\n\t\t \n\t\tif (c->efd == c->rfd) {\n\t\t\tif ((c->io_want & SSH_CHAN_IO_EFD_R) != 0)\n\t\t\t\tev |= POLLIN;\n\t\t\tif ((c->io_want & SSH_CHAN_IO_EFD_W) != 0)\n\t\t\t\tev |= POLLOUT;\n\t\t}\n\t\t \n\t\tif (c->sock == c->rfd) {\n\t\t\tif ((c->io_want & SSH_CHAN_IO_SOCK_R) != 0)\n\t\t\t\tev |= POLLIN;\n\t\t\tif ((c->io_want & SSH_CHAN_IO_SOCK_W) != 0)\n\t\t\t\tev |= POLLOUT;\n\t\t}\n\t\t \n\t\tif (ev != 0) {\n\t\t\tc->pfds[0] = p;\n\t\t\tpfd[p].fd = c->rfd;\n\t\t\tpfd[p].events = ev;\n\t\t\tdump_channel_poll(__func__, \"rfd\", c, p, &pfd[p]);\n\t\t\tp++;\n\t\t}\n\t}\n\t \n\tif (c->wfd != -1 && c->rfd != c->wfd) {\n\t\tev = 0;\n\t\tif ((c->io_want & SSH_CHAN_IO_WFD))\n\t\t\tev |= POLLOUT;\n\t\t \n\t\tif (ev != 0) {\n\t\t\tc->pfds[1] = p;\n\t\t\tpfd[p].fd = c->wfd;\n\t\t\tpfd[p].events = ev;\n\t\t\tdump_channel_poll(__func__, \"wfd\", c, p, &pfd[p]);\n\t\t\tp++;\n\t\t}\n\t}\n\t \n\tif (c->efd != -1 && c->rfd != c->efd) {\n\t\tev = 0;\n\t\tif ((c->io_want & SSH_CHAN_IO_EFD_R) != 0)\n\t\t\tev |= POLLIN;\n\t\tif ((c->io_want & SSH_CHAN_IO_EFD_W) != 0)\n\t\t\tev |= POLLOUT;\n\t\t \n\t\tif (ev != 0) {\n\t\t\tc->pfds[2] = p;\n\t\t\tpfd[p].fd = c->efd;\n\t\t\tpfd[p].events = ev;\n\t\t\tdump_channel_poll(__func__, \"efd\", c, p, &pfd[p]);\n\t\t\tp++;\n\t\t}\n\t}\n\t \n\tif (c->sock != -1 && c->rfd != c->sock) {\n\t\tev = 0;\n\t\tif ((c->io_want & SSH_CHAN_IO_SOCK_R) != 0)\n\t\t\tev |= POLLIN;\n\t\tif ((c->io_want & SSH_CHAN_IO_SOCK_W) != 0)\n\t\t\tev |= POLLOUT;\n\t\t \n\t\tif (ev != 0) {\n\t\t\tc->pfds[3] = p;\n\t\t\tpfd[p].fd = c->sock;\n\t\t\tpfd[p].events = 0;\n\t\t\tdump_channel_poll(__func__, \"sock\", c, p, &pfd[p]);\n\t\t\tp++;\n\t\t}\n\t}\n\t*next_pollfd = p;\n}\n\n \nvoid\nchannel_prepare_poll(struct ssh *ssh, struct pollfd **pfdp, u_int *npfd_allocp,\n    u_int *npfd_activep, u_int npfd_reserved, struct timespec *timeout)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i, oalloc, p, npfd = npfd_reserved;\n\n\tchannel_before_prepare_io(ssh);  \n\t \n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL)\n\t\t\tcontinue;\n\t\tsc->channels[i]->io_want = sc->channels[i]->io_ready = 0;\n\t}\n\t \n\tif (sc->channels_alloc >= (INT_MAX / 4) - npfd_reserved)\n\t\tfatal_f(\"too many channels\");  \n\tnpfd += sc->channels_alloc * 4;\n\tif (npfd > *npfd_allocp) {\n\t\t*pfdp = xrecallocarray(*pfdp, *npfd_allocp,\n\t\t    npfd, sizeof(**pfdp));\n\t\t*npfd_allocp = npfd;\n\t}\n\t*npfd_activep = npfd_reserved;\n\toalloc = sc->channels_alloc;\n\n\tchannel_handler(ssh, CHAN_PRE, timeout);\n\n\tif (oalloc != sc->channels_alloc) {\n\t\t \n\t\tfatal_f(\"channels_alloc changed during CHAN_PRE \"\n\t\t    \"(was %u, now %u)\", oalloc, sc->channels_alloc);\n\t}\n\n\t \n\tp = npfd_reserved;\n\tfor (i = 0; i < sc->channels_alloc; i++)\n\t\tchannel_prepare_pollfd(sc->channels[i], &p, *pfdp, npfd);\n\t*npfd_activep = p;\n}\n\nstatic void\nfd_ready(Channel *c, int p, struct pollfd *pfds, u_int npfd, int fd,\n    const char *what, u_int revents_mask, u_int ready)\n{\n\tstruct pollfd *pfd = &pfds[p];\n\n\tif (fd == -1)\n\t\treturn;\n\tif (p == -1 || (u_int)p >= npfd)\n\t\tfatal_f(\"channel %d: bad pfd %d (max %u)\", c->self, p, npfd);\n\tdump_channel_poll(__func__, what, c, p, pfd);\n\tif (pfd->fd != fd) {\n\t\tfatal(\"channel %d: inconsistent %s fd=%d pollfd[%u].fd %d \"\n\t\t    \"r%d w%d e%d s%d\", c->self, what, fd, p, pfd->fd,\n\t\t    c->rfd, c->wfd, c->efd, c->sock);\n\t}\n\tif ((pfd->revents & POLLNVAL) != 0) {\n\t\tfatal(\"channel %d: invalid %s pollfd[%u].fd %d r%d w%d e%d s%d\",\n\t\t    c->self, what, p, pfd->fd, c->rfd, c->wfd, c->efd, c->sock);\n\t}\n\tif ((pfd->revents & (revents_mask|POLLHUP|POLLERR)) != 0)\n\t\tc->io_ready |= ready & c->io_want;\n}\n\n \nvoid\nchannel_after_poll(struct ssh *ssh, struct pollfd *pfd, u_int npfd)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int i;\n\tint p;\n\tChannel *c;\n\n#ifdef DEBUG_CHANNEL_POLL\n\tfor (p = 0; p < (int)npfd; p++) {\n\t\tif (pfd[p].revents == 0)\n\t\t\tcontinue;\n\t\tdebug_f(\"pfd[%u].fd %d rev 0x%04x\",\n\t\t    p, pfd[p].fd, pfd[p].revents);\n\t}\n#endif\n\n\t \n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\t\t \n\t\tif (c->rfd != -1 && c->wfd != -1 && c->rfd != c->wfd &&\n\t\t    (c->rfd == c->efd || c->rfd == c->sock)) {\n\t\t\t \n\t\t\tfatal_f(\"channel %d: unexpected fds r%d w%d e%d s%d\",\n\t\t\t    c->self, c->rfd, c->wfd, c->efd, c->sock);\n\t\t}\n\t\tc->io_ready = 0;\n\t\t \n\t\tif (c->rfd != -1 && (p = c->pfds[0]) != -1) {\n\t\t\tfd_ready(c, p, pfd, npfd, c->rfd,\n\t\t\t    \"rfd\", POLLIN, SSH_CHAN_IO_RFD);\n\t\t\tif (c->rfd == c->wfd) {\n\t\t\t\tfd_ready(c, p, pfd, npfd, c->wfd,\n\t\t\t\t    \"wfd/r\", POLLOUT, SSH_CHAN_IO_WFD);\n\t\t\t}\n\t\t\tif (c->rfd == c->efd) {\n\t\t\t\tfd_ready(c, p, pfd, npfd, c->efd,\n\t\t\t\t    \"efdr/r\", POLLIN, SSH_CHAN_IO_EFD_R);\n\t\t\t\tfd_ready(c, p, pfd, npfd, c->efd,\n\t\t\t\t    \"efdw/r\", POLLOUT, SSH_CHAN_IO_EFD_W);\n\t\t\t}\n\t\t\tif (c->rfd == c->sock) {\n\t\t\t\tfd_ready(c, p, pfd, npfd, c->sock,\n\t\t\t\t    \"sockr/r\", POLLIN, SSH_CHAN_IO_SOCK_R);\n\t\t\t\tfd_ready(c, p, pfd, npfd, c->sock,\n\t\t\t\t    \"sockw/r\", POLLOUT, SSH_CHAN_IO_SOCK_W);\n\t\t\t}\n\t\t\tdump_channel_poll(__func__, \"rfd\", c, p, pfd);\n\t\t}\n\t\t \n\t\tif (c->wfd != -1 && c->wfd != c->rfd &&\n\t\t    (p = c->pfds[1]) != -1) {\n\t\t\tfd_ready(c, p, pfd, npfd, c->wfd,\n\t\t\t    \"wfd\", POLLOUT, SSH_CHAN_IO_WFD);\n\t\t\tdump_channel_poll(__func__, \"wfd\", c, p, pfd);\n\t\t}\n\t\t \n\t\tif (c->efd != -1 && c->efd != c->rfd &&\n\t\t    (p = c->pfds[2]) != -1) {\n\t\t\tfd_ready(c, p, pfd, npfd, c->efd,\n\t\t\t    \"efdr\", POLLIN, SSH_CHAN_IO_EFD_R);\n\t\t\tfd_ready(c, p, pfd, npfd, c->efd,\n\t\t\t    \"efdw\", POLLOUT, SSH_CHAN_IO_EFD_W);\n\t\t\tdump_channel_poll(__func__, \"efd\", c, p, pfd);\n\t\t}\n\t\t \n\t\tif (c->sock != -1 && c->sock != c->rfd &&\n\t\t    (p = c->pfds[3]) != -1) {\n\t\t\tfd_ready(c, p, pfd, npfd, c->sock,\n\t\t\t    \"sockr\", POLLIN, SSH_CHAN_IO_SOCK_R);\n\t\t\tfd_ready(c, p, pfd, npfd, c->sock,\n\t\t\t    \"sockw\", POLLOUT, SSH_CHAN_IO_SOCK_W);\n\t\t\tdump_channel_poll(__func__, \"sock\", c, p, pfd);\n\t\t}\n\t}\n\tchannel_handler(ssh, CHAN_POST, NULL);\n}\n\n \nstatic int\nchannel_output_poll_input_open(struct ssh *ssh, Channel *c)\n{\n\tsize_t len, plen;\n\tconst u_char *pkt;\n\tint r;\n\n\tif ((len = sshbuf_len(c->input)) == 0) {\n\t\tif (c->istate == CHAN_INPUT_WAIT_DRAIN) {\n\t\t\t \n\t\t\tif (CHANNEL_EFD_INPUT_ACTIVE(c))\n\t\t\t\tdebug2(\"channel %d: \"\n\t\t\t\t    \"ibuf_empty delayed efd %d/(%zu)\",\n\t\t\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\t\telse\n\t\t\t\tchan_ibuf_empty(ssh, c);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!c->have_remote_id)\n\t\tfatal_f(\"channel %d: no remote id\", c->self);\n\n\tif (c->datagram) {\n\t\t \n\t\tif ((r = sshbuf_get_string_direct(c->input, &pkt, &plen)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: get datagram\", c->self);\n\t\t \n\t\tif (plen > c->remote_window || plen > c->remote_maxpacket) {\n\t\t\tdebug(\"channel %d: datagram too big\", c->self);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, pkt, plen)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: send datagram\", c->self);\n\t\tc->remote_window -= plen;\n\t\treturn 1;\n\t}\n\n\t \n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn 0;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->input), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i: send data\", c->self);\n\tif ((r = sshbuf_consume(c->input, len)) != 0)\n\t\tfatal_fr(r, \"channel %i: consume\", c->self);\n\tc->remote_window -= len;\n\treturn 1;\n}\n\n \nstatic int\nchannel_output_poll_extended_read(struct ssh *ssh, Channel *c)\n{\n\tsize_t len;\n\tint r;\n\n\tif ((len = sshbuf_len(c->extended)) == 0)\n\t\treturn 0;\n\n\tdebug2(\"channel %d: rwin %u elen %zu euse %d\", c->self,\n\t    c->remote_window, sshbuf_len(c->extended), c->extended_usage);\n\tif (len > c->remote_window)\n\t\tlen = c->remote_window;\n\tif (len > c->remote_maxpacket)\n\t\tlen = c->remote_maxpacket;\n\tif (len == 0)\n\t\treturn 0;\n\tif (!c->have_remote_id)\n\t\tfatal_f(\"channel %d: no remote id\", c->self);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_EXTENDED_DATA_STDERR)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sshbuf_ptr(c->extended), len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i: data\", c->self);\n\tif ((r = sshbuf_consume(c->extended, len)) != 0)\n\t\tfatal_fr(r, \"channel %i: consume\", c->self);\n\tc->remote_window -= len;\n\tdebug2(\"channel %d: sent ext data %zu\", c->self, len);\n\treturn 1;\n}\n\n \nint\nchannel_output_poll(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tChannel *c;\n\tu_int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tc = sc->channels[i];\n\t\tif (c == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (c->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif ((c->flags & (CHAN_CLOSE_SENT|CHAN_CLOSE_RCVD))) {\n\t\t\t \n\t\t\tdebug3(\"channel %d: will not send data after close\",\n\t\t\t    c->self);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (c->istate == CHAN_INPUT_OPEN ||\n\t\t    c->istate == CHAN_INPUT_WAIT_DRAIN)\n\t\t\tret |= channel_output_poll_input_open(ssh, c);\n\t\t \n\t\tif (!(c->flags & CHAN_EOF_SENT) &&\n\t\t    c->extended_usage == CHAN_EXTENDED_READ)\n\t\t\tret |= channel_output_poll_extended_read(ssh, c);\n\t}\n\treturn ret;\n}\n\n \n\n \n\n \nint\nchannel_proxy_downstream(struct ssh *ssh, Channel *downstream)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *original = NULL, *modified = NULL;\n\tconst u_char *cp;\n\tchar *ctype = NULL, *listen_host = NULL;\n\tu_char type;\n\tsize_t have;\n\tint ret = -1, r;\n\tu_int id, remote_id, listen_port;\n\n\t \n\tif ((r = sshbuf_get_string_direct(downstream->input, &cp, &have))\n\t    != 0) {\n\t\terror_fr(r, \"parse\");\n\t\treturn -1;\n\t}\n\tif (have < 2) {\n\t\terror_f(\"short message\");\n\t\treturn -1;\n\t}\n\ttype = cp[1];\n\t \n\tcp += 2;\n\thave -= 2;\n\tif (ssh_packet_log_type(type))\n\t\tdebug3_f(\"channel %u: down->up: type %u\",\n\t\t    downstream->self, type);\n\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN:\n\t\tif ((original = sshbuf_from(cp, have)) == NULL ||\n\t\t    (modified = sshbuf_new()) == NULL) {\n\t\t\terror_f(\"alloc\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &id)) != 0) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\tgoto out;\n\t\t}\n\t\tc = channel_new(ssh, \"mux-proxy\", SSH_CHANNEL_MUX_PROXY,\n\t\t    -1, -1, -1, 0, 0, 0, ctype, 1);\n\t\tc->mux_ctx = downstream;\t \n\t\tc->mux_downstream_id = id;\t \n\t\tif ((r = sshbuf_put_cstring(modified, ctype)) != 0 ||\n\t\t    (r = sshbuf_put_u32(modified, c->self)) != 0 ||\n\t\t    (r = sshbuf_putb(modified, original)) != 0) {\n\t\t\terror_fr(r, \"compose\");\n\t\t\tchannel_free(ssh, c);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t \n\t\tif ((original = sshbuf_from(cp, have)) == NULL ||\n\t\t    (modified = sshbuf_new()) == NULL) {\n\t\t\terror_f(\"alloc\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(original, &remote_id)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &id)) != 0) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\tgoto out;\n\t\t}\n\t\tc = channel_new(ssh, \"mux-proxy\", SSH_CHANNEL_MUX_PROXY,\n\t\t    -1, -1, -1, 0, 0, 0, \"mux-down-connect\", 1);\n\t\tc->mux_ctx = downstream;\t \n\t\tc->mux_downstream_id = id;\n\t\tc->remote_id = remote_id;\n\t\tc->have_remote_id = 1;\n\t\tif ((r = sshbuf_put_u32(modified, remote_id)) != 0 ||\n\t\t    (r = sshbuf_put_u32(modified, c->self)) != 0 ||\n\t\t    (r = sshbuf_putb(modified, original)) != 0) {\n\t\t\terror_fr(r, \"compose\");\n\t\t\tchannel_free(ssh, c);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_GLOBAL_REQUEST:\n\t\tif ((original = sshbuf_from(cp, have)) == NULL) {\n\t\t\terror_f(\"alloc\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(original, &ctype, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(ctype, \"tcpip-forward\") != 0) {\n\t\t\terror_f(\"unsupported request %s\", ctype);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u8(original, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(original, &listen_host, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(original, &listen_port)) != 0) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (listen_port > 65535) {\n\t\t\terror_f(\"tcpip-forward for %s: bad port %u\",\n\t\t\t    listen_host, listen_port);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tpermission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL, \"<mux>\", -1,\n\t\t    listen_host, NULL, (int)listen_port, downstream);\n\t\tlisten_host = NULL;\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (have < 4)\n\t\t\tbreak;\n\t\tremote_id = PEEK_U32(cp);\n\t\tif ((c = channel_by_remote_id(ssh, remote_id)) != NULL) {\n\t\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\t\tchannel_free(ssh, c);\n\t\t\telse\n\t\t\t\tc->flags |= CHAN_CLOSE_SENT;\n\t\t}\n\t\tbreak;\n\t}\n\tif (modified) {\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_putb(ssh, modified)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\terror_fr(r, \"send\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put(ssh, cp, have)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\terror_fr(r, \"send\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(ctype);\n\tfree(listen_host);\n\tsshbuf_free(original);\n\tsshbuf_free(modified);\n\treturn ret;\n}\n\n \nint\nchannel_proxy_upstream(Channel *c, int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct sshbuf *b = NULL;\n\tChannel *downstream;\n\tconst u_char *cp = NULL;\n\tsize_t len;\n\tint r;\n\n\t \n\tif (c == NULL || c->type != SSH_CHANNEL_MUX_PROXY)\n\t\treturn 0;\n\tif ((downstream = c->mux_ctx) == NULL)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EOF:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\tcase SSH2_MSG_CHANNEL_OPEN_FAILURE:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\tcase SSH2_MSG_CHANNEL_SUCCESS:\n\tcase SSH2_MSG_CHANNEL_FAILURE:\n\tcase SSH2_MSG_CHANNEL_REQUEST:\n\t\tbreak;\n\tdefault:\n\t\tdebug2_f(\"channel %u: unsupported type %u\", c->self, type);\n\t\treturn 0;\n\t}\n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror_f(\"alloc reply\");\n\t\tgoto out;\n\t}\n\t \n\tcp = sshpkt_ptr(ssh, &len);\n\tif (cp == NULL) {\n\t\terror_f(\"no packet\");\n\t\tgoto out;\n\t}\n\t \n\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t \n\t    (r = sshbuf_put_u8(b, type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, c->mux_downstream_id)) != 0 ||\n\t    (r = sshbuf_put(b, cp, len)) != 0 ||\n\t    (r = sshbuf_put_stringb(downstream->output, b)) != 0) {\n\t\terror_fr(r, \"compose muxclient\");\n\t\tgoto out;\n\t}\n\t \n\tif (ssh_packet_log_type(type))\n\t\tdebug3_f(\"channel %u: up->down: type %u\", c->self, type);\n out:\n\t \n\tswitch (type) {\n\tcase SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:\n\t\t \n\t\tif (cp && len > 4) {\n\t\t\tc->remote_id = PEEK_U32(cp);\n\t\t\tc->have_remote_id = 1;\n\t\t}\n\t\tbreak;\n\tcase SSH2_MSG_CHANNEL_CLOSE:\n\t\tif (c->flags & CHAN_CLOSE_SENT)\n\t\t\tchannel_free(ssh, c);\n\t\telse\n\t\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t\tbreak;\n\t}\n\tsshbuf_free(b);\n\treturn 1;\n}\n\n \n\n \nstatic int\nchannel_parse_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tu_int32_t id;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0) {\n\t\terror_r(r, \"%s: parse id\", where);\n\t\tssh_packet_disconnect(ssh, \"Invalid %s message\", what);\n\t}\n\tif (id > INT_MAX) {\n\t\terror_r(r, \"%s: bad channel id %u\", where, id);\n\t\tssh_packet_disconnect(ssh, \"Invalid %s channel id\", what);\n\t}\n\treturn (int)id;\n}\n\n \nstatic Channel *\nchannel_from_packet_id(struct ssh *ssh, const char *where, const char *what)\n{\n\tint id = channel_parse_id(ssh, where, what);\n\tChannel *c;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tssh_packet_disconnect(ssh,\n\t\t    \"%s packet referred to nonexistent channel %d\", what, id);\n\t}\n\treturn c;\n}\n\nint\nchannel_input_data(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tconst u_char *data;\n\tsize_t data_len, win_len;\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"data\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\n\t \n\tif (c->type != SSH_CHANNEL_OPEN &&\n\t    c->type != SSH_CHANNEL_RDYNAMIC_OPEN &&\n\t    c->type != SSH_CHANNEL_RDYNAMIC_FINISH &&\n\t    c->type != SSH_CHANNEL_X11_OPEN)\n\t\treturn 0;\n\n\t \n\tif ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0 ||\n            (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal_fr(r, \"channel %i: get data\", c->self);\n\n\twin_len = data_len;\n\tif (c->datagram)\n\t\twin_len += 4;   \n\n\t \n\tif (c->ostate != CHAN_OUTPUT_OPEN) {\n\t\tc->local_window -= win_len;\n\t\tc->local_consumed += win_len;\n\t\treturn 0;\n\t}\n\n\tif (win_len > c->local_maxpacket) {\n\t\tlogit(\"channel %d: rcvd big packet %zu, maxpack %u\",\n\t\t    c->self, win_len, c->local_maxpacket);\n\t\treturn 0;\n\t}\n\tif (win_len > c->local_window) {\n\t\tc->local_window_exceeded += win_len - c->local_window;\n\t\tlogit(\"channel %d: rcvd too much data %zu, win %u/%u \"\n\t\t    \"(excess %u)\", c->self, win_len, c->local_window,\n\t\t    c->local_window_max, c->local_window_exceeded);\n\t\tc->local_window = 0;\n\t\t \n\t\tif (c->local_window_exceeded > (c->local_window_max / 10)) {\n\t\t\tssh_packet_disconnect(ssh, \"channel %d: peer ignored \"\n\t\t\t    \"channel window\", c->self);\n\t\t}\n\t} else {\n\t\tc->local_window -= win_len;\n\t\tc->local_window_exceeded = 0;\n\t}\n\n\tif (c->datagram) {\n\t\tif ((r = sshbuf_put_string(c->output, data, data_len)) != 0)\n\t\t\tfatal_fr(r, \"channel %i: append datagram\", c->self);\n\t} else if ((r = sshbuf_put(c->output, data, data_len)) != 0)\n\t\tfatal_fr(r, \"channel %i: append data\", c->self);\n\n\treturn 0;\n}\n\nint\nchannel_input_extended_data(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tconst u_char *data;\n\tsize_t data_len;\n\tu_int32_t tcode;\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"extended data\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPEN) {\n\t\tlogit(\"channel %d: ext data for non open\", c->self);\n\t\treturn 0;\n\t}\n\tif (c->flags & CHAN_EOF_RCVD) {\n\t\tif (ssh->compat & SSH_BUG_EXTEOF)\n\t\t\tdebug(\"channel %d: accepting ext data after eof\",\n\t\t\t    c->self);\n\t\telse\n\t\t\tssh_packet_disconnect(ssh, \"Received extended_data \"\n\t\t\t    \"after EOF on channel %d.\", c->self);\n\t}\n\n\tif ((r = sshpkt_get_u32(ssh, &tcode)) != 0) {\n\t\terror_fr(r, \"parse tcode\");\n\t\tssh_packet_disconnect(ssh, \"Invalid extended_data message\");\n\t}\n\tif (c->efd == -1 ||\n\t    c->extended_usage != CHAN_EXTENDED_WRITE ||\n\t    tcode != SSH2_EXTENDED_DATA_STDERR) {\n\t\tlogit(\"channel %d: bad ext data\", c->self);\n\t\treturn 0;\n\t}\n\tif ((r = sshpkt_get_string_direct(ssh, &data, &data_len)) != 0 ||\n            (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"parse data\");\n\t\tssh_packet_disconnect(ssh, \"Invalid extended_data message\");\n\t}\n\n\tif (data_len > c->local_window) {\n\t\tlogit(\"channel %d: rcvd too much extended_data %zu, win %u\",\n\t\t    c->self, data_len, c->local_window);\n\t\treturn 0;\n\t}\n\tdebug2(\"channel %d: rcvd ext data %zu\", c->self, data_len);\n\t \n\tif ((r = sshbuf_put(c->extended, data, data_len)) != 0)\n\t\terror_fr(r, \"append\");\n\tc->local_window -= data_len;\n\treturn 0;\n}\n\nint\nchannel_input_ieof(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"ieof\");\n\tint r;\n\n        if ((r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"parse data\");\n\t\tssh_packet_disconnect(ssh, \"Invalid ieof message\");\n\t}\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tchan_rcvd_ieof(ssh, c);\n\n\t \n\tif (c->force_drain && c->istate == CHAN_INPUT_OPEN) {\n\t\tdebug(\"channel %d: FORCE input drain\", c->self);\n\t\tc->istate = CHAN_INPUT_WAIT_DRAIN;\n\t\tif (sshbuf_len(c->input) == 0)\n\t\t\tchan_ibuf_empty(ssh, c);\n\t}\n\treturn 0;\n}\n\nint\nchannel_input_oclose(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"oclose\");\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n        if ((r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"parse data\");\n\t\tssh_packet_disconnect(ssh, \"Invalid oclose message\");\n\t}\n\tchan_rcvd_oclose(ssh, c);\n\treturn 0;\n}\n\nint\nchannel_input_open_confirmation(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"open confirmation\");\n\tu_int32_t remote_window, remote_maxpacket;\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPENING)\n\t\tssh_packet_disconnect(ssh, \"Received open confirmation for \"\n\t\t    \"non-opening channel %d.\", c->self);\n\t \n\tif ((r = sshpkt_get_u32(ssh, &c->remote_id)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &remote_window)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &remote_maxpacket)) != 0 ||\n            (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"window/maxpacket\");\n\t\tssh_packet_disconnect(ssh, \"Invalid open confirmation message\");\n\t}\n\n\tc->have_remote_id = 1;\n\tc->remote_window = remote_window;\n\tc->remote_maxpacket = remote_maxpacket;\n\tc->type = SSH_CHANNEL_OPEN;\n\tif (c->open_confirm) {\n\t\tdebug2_f(\"channel %d: callback start\", c->self);\n\t\tc->open_confirm(ssh, c->self, 1, c->open_confirm_ctx);\n\t\tdebug2_f(\"channel %d: callback done\", c->self);\n\t}\n\tc->lastused = monotime();\n\tdebug2(\"channel %d: open confirm rwindow %u rmax %u\", c->self,\n\t    c->remote_window, c->remote_maxpacket);\n\treturn 0;\n}\n\nstatic char *\nreason2txt(int reason)\n{\n\tswitch (reason) {\n\tcase SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED:\n\t\treturn \"administratively prohibited\";\n\tcase SSH2_OPEN_CONNECT_FAILED:\n\t\treturn \"connect failed\";\n\tcase SSH2_OPEN_UNKNOWN_CHANNEL_TYPE:\n\t\treturn \"unknown channel type\";\n\tcase SSH2_OPEN_RESOURCE_SHORTAGE:\n\t\treturn \"resource shortage\";\n\t}\n\treturn \"unknown reason\";\n}\n\nint\nchannel_input_open_failure(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = channel_from_packet_id(ssh, __func__, \"open failure\");\n\tu_int32_t reason;\n\tchar *msg = NULL;\n\tint r;\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif (c->type != SSH_CHANNEL_OPENING)\n\t\tssh_packet_disconnect(ssh, \"Received open failure for \"\n\t\t    \"non-opening channel %d.\", c->self);\n\tif ((r = sshpkt_get_u32(ssh, &reason)) != 0) {\n\t\terror_fr(r, \"parse reason\");\n\t\tssh_packet_disconnect(ssh, \"Invalid open failure message\");\n\t}\n\t \n\tif ((r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string_direct(ssh, NULL, NULL)) != 0 ||\n            (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"parse msg/lang\");\n\t\tssh_packet_disconnect(ssh, \"Invalid open failure message\");\n\t}\n\tlogit(\"channel %d: open failed: %s%s%s\", c->self,\n\t    reason2txt(reason), msg ? \": \": \"\", msg ? msg : \"\");\n\tfree(msg);\n\tif (c->open_confirm) {\n\t\tdebug2_f(\"channel %d: callback start\", c->self);\n\t\tc->open_confirm(ssh, c->self, 0, c->open_confirm_ctx);\n\t\tdebug2_f(\"channel %d: callback done\", c->self);\n\t}\n\t \n\tchan_mark_dead(ssh, c);\n\treturn 0;\n}\n\nint\nchannel_input_window_adjust(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint id = channel_parse_id(ssh, __func__, \"window adjust\");\n\tChannel *c;\n\tu_int32_t adjust;\n\tu_int new_rwin;\n\tint r;\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tlogit(\"Received window adjust for non-open channel %d.\", id);\n\t\treturn 0;\n\t}\n\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif ((r = sshpkt_get_u32(ssh, &adjust)) != 0 ||\n            (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"parse adjust\");\n\t\tssh_packet_disconnect(ssh, \"Invalid window adjust message\");\n\t}\n\tdebug2(\"channel %d: rcvd adjust %u\", c->self, adjust);\n\tif ((new_rwin = c->remote_window + adjust) < c->remote_window) {\n\t\tfatal(\"channel %d: adjust %u overflows remote window %u\",\n\t\t    c->self, adjust, c->remote_window);\n\t}\n\tc->remote_window = new_rwin;\n\treturn 0;\n}\n\nint\nchannel_input_status_confirm(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint id = channel_parse_id(ssh, __func__, \"status confirm\");\n\tChannel *c;\n\tstruct channel_confirm *cc;\n\n\t \n\tssh_packet_set_alive_timeouts(ssh, 0);\n\n\tdebug2_f(\"type %d id %d\", type, id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL) {\n\t\tlogit_f(\"%d: unknown\", id);\n\t\treturn 0;\n\t}\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n        if (sshpkt_get_end(ssh) != 0)\n\t\tssh_packet_disconnect(ssh, \"Invalid status confirm message\");\n\tif ((cc = TAILQ_FIRST(&c->status_confirms)) == NULL)\n\t\treturn 0;\n\tcc->cb(ssh, type, c, cc->ctx);\n\tTAILQ_REMOVE(&c->status_confirms, cc, entry);\n\tfreezero(cc, sizeof(*cc));\n\treturn 0;\n}\n\n \n\nvoid\nchannel_set_af(struct ssh *ssh, int af)\n{\n\tssh->chanctxt->IPv4or6 = af;\n}\n\n\n \nstatic const char *\nchannel_fwd_bind_addr(struct ssh *ssh, const char *listen_addr, int *wildcardp,\n    int is_client, struct ForwardOptions *fwd_opts)\n{\n\tconst char *addr = NULL;\n\tint wildcard = 0;\n\n\tif (listen_addr == NULL) {\n\t\t \n\t\tif (fwd_opts->gateway_ports)\n\t\t\twildcard = 1;\n\t} else if (fwd_opts->gateway_ports || is_client) {\n\t\tif (((ssh->compat & SSH_OLD_FORWARD_ADDR) &&\n\t\t    strcmp(listen_addr, \"0.0.0.0\") == 0 && is_client == 0) ||\n\t\t    *listen_addr == '\\0' || strcmp(listen_addr, \"*\") == 0 ||\n\t\t    (!is_client && fwd_opts->gateway_ports == 1)) {\n\t\t\twildcard = 1;\n\t\t\t \n\t\t\tif (*listen_addr != '\\0' &&\n\t\t\t    strcmp(listen_addr, \"0.0.0.0\") != 0 &&\n\t\t\t    strcmp(listen_addr, \"*\") != 0) {\n\t\t\t\tssh_packet_send_debug(ssh,\n\t\t\t\t    \"Forwarding listen address \"\n\t\t\t\t    \"\\\"%s\\\" overridden by server \"\n\t\t\t\t    \"GatewayPorts\", listen_addr);\n\t\t\t}\n\t\t} else if (strcmp(listen_addr, \"localhost\") != 0 ||\n\t\t    strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t\t \n\t\t\taddr = listen_addr;\n\t\t}\n\t} else if (strcmp(listen_addr, \"127.0.0.1\") == 0 ||\n\t    strcmp(listen_addr, \"::1\") == 0) {\n\t\t \n\t\taddr = listen_addr;\n\t}\n\tif (wildcardp != NULL)\n\t\t*wildcardp = wildcard;\n\treturn addr;\n}\n\nstatic int\nchannel_setup_fwd_listener_tcpip(struct ssh *ssh, int type,\n    struct Forward *fwd, int *allocated_listen_port,\n    struct ForwardOptions *fwd_opts)\n{\n\tChannel *c;\n\tint sock, r, success = 0, wildcard = 0, is_client;\n\tstruct addrinfo hints, *ai, *aitop;\n\tconst char *host, *addr;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tin_port_t *lport_p;\n\n\tis_client = (type == SSH_CHANNEL_PORT_LISTENER);\n\n\tif (is_client && fwd->connect_path != NULL) {\n\t\thost = fwd->connect_path;\n\t} else {\n\t\thost = (type == SSH_CHANNEL_RPORT_LISTENER) ?\n\t\t    fwd->listen_host : fwd->connect_host;\n\t\tif (host == NULL) {\n\t\t\terror(\"No forward host name.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (strlen(host) >= NI_MAXHOST) {\n\t\t\terror(\"Forward host name too long.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\taddr = channel_fwd_bind_addr(ssh, fwd->listen_host, &wildcard,\n\t    is_client, fwd_opts);\n\tdebug3_f(\"type %d wildcard %d addr %s\", type, wildcard,\n\t    (addr == NULL) ? \"NULL\" : addr);\n\n\t \n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_flags = wildcard ? AI_PASSIVE : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%d\", fwd->listen_port);\n\tif ((r = getaddrinfo(addr, strport, &hints, &aitop)) != 0) {\n\t\tif (addr == NULL) {\n\t\t\t \n\t\t\tssh_packet_disconnect(ssh, \"getaddrinfo: fatal error: %s\",\n\t\t\t    ssh_gai_strerror(r));\n\t\t} else {\n\t\t\terror_f(\"getaddrinfo(%.64s): %s\", addr,\n\t\t\t    ssh_gai_strerror(r));\n\t\t}\n\t\treturn 0;\n\t}\n\tif (allocated_listen_port != NULL)\n\t\t*allocated_listen_port = 0;\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tswitch (ai->ai_family) {\n\t\tcase AF_INET:\n\t\t\tlport_p = &((struct sockaddr_in *)ai->ai_addr)->\n\t\t\t    sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlport_p = &((struct sockaddr_in6 *)ai->ai_addr)->\n\t\t\t    sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port > 0)\n\t\t\t*lport_p = htons(*allocated_listen_port);\n\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop, sizeof(ntop),\n\t\t    strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\terror_f(\"getnameinfo failed\");\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock == -1) {\n\t\t\t \n\t\t\tverbose(\"socket [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_reuseaddr(sock);\n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(sock);\n\n\t\tdebug(\"Local forwarding listening on %s port %s.\",\n\t\t    ntop, strport);\n\n\t\t \n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) == -1) {\n\t\t\t \n\t\t\tif (!ai->ai_next)\n\t\t\t\terror(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"bind [%s]:%s: %.100s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) == -1) {\n\t\t\terror(\"listen [%s]:%s: %.100s\", ntop, strport,\n\t\t\t    strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (type == SSH_CHANNEL_RPORT_LISTENER &&\n\t\t    fwd->listen_port == 0 &&\n\t\t    allocated_listen_port != NULL &&\n\t\t    *allocated_listen_port == 0) {\n\t\t\t*allocated_listen_port = get_local_port(sock);\n\t\t\tdebug(\"Allocated listen port %d\",\n\t\t\t    *allocated_listen_port);\n\t\t}\n\n\t\t \n\t\tc = channel_new(ssh, \"port-listener\", type, sock, sock, -1,\n\t\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t\t    0, \"port listener\", 1);\n\t\tc->path = xstrdup(host);\n\t\tc->host_port = fwd->connect_port;\n\t\tc->listening_addr = addr == NULL ? NULL : xstrdup(addr);\n\t\tif (fwd->listen_port == 0 && allocated_listen_port != NULL &&\n\t\t    !(ssh->compat & SSH_BUG_DYNAMIC_RPORT))\n\t\t\tc->listening_port = *allocated_listen_port;\n\t\telse\n\t\t\tc->listening_port = fwd->listen_port;\n\t\tsuccess = 1;\n\t}\n\tif (success == 0)\n\t\terror_f(\"cannot listen to port: %d\", fwd->listen_port);\n\tfreeaddrinfo(aitop);\n\treturn success;\n}\n\nstatic int\nchannel_setup_fwd_listener_streamlocal(struct ssh *ssh, int type,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tstruct sockaddr_un sunaddr;\n\tconst char *path;\n\tChannel *c;\n\tint port, sock;\n\tmode_t omask;\n\n\tswitch (type) {\n\tcase SSH_CHANNEL_UNIX_LISTENER:\n\t\tif (fwd->connect_path != NULL) {\n\t\t\tif (strlen(fwd->connect_path) > sizeof(sunaddr.sun_path)) {\n\t\t\t\terror(\"Local connecting path too long: %s\",\n\t\t\t\t    fwd->connect_path);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_path;\n\t\t\tport = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tif (fwd->connect_host == NULL) {\n\t\t\t\terror(\"No forward host name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (strlen(fwd->connect_host) >= NI_MAXHOST) {\n\t\t\t\terror(\"Forward host name too long.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpath = fwd->connect_host;\n\t\t\tport = fwd->connect_port;\n\t\t}\n\t\tbreak;\n\tcase SSH_CHANNEL_RUNIX_LISTENER:\n\t\tpath = fwd->listen_path;\n\t\tport = PORT_STREAMLOCAL;\n\t\tbreak;\n\tdefault:\n\t\terror_f(\"unexpected channel type %d\", type);\n\t\treturn 0;\n\t}\n\n\tif (fwd->listen_path == NULL) {\n\t\terror(\"No forward path name.\");\n\t\treturn 0;\n\t}\n\tif (strlen(fwd->listen_path) > sizeof(sunaddr.sun_path)) {\n\t\terror(\"Local listening path too long: %s\", fwd->listen_path);\n\t\treturn 0;\n\t}\n\n\tdebug3_f(\"type %d path %s\", type, fwd->listen_path);\n\n\t \n\tomask = umask(fwd_opts->streamlocal_bind_mask);\n\tsock = unix_listener(fwd->listen_path, SSH_LISTEN_BACKLOG,\n\t    fwd_opts->streamlocal_bind_unlink);\n\tumask(omask);\n\tif (sock < 0)\n\t\treturn 0;\n\n\tdebug(\"Local forwarding listening on path %s.\", fwd->listen_path);\n\n\t \n\tc = channel_new(ssh, \"unix-listener\", type, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, \"unix listener\", 1);\n\tc->path = xstrdup(path);\n\tc->host_port = port;\n\tc->listening_port = PORT_STREAMLOCAL;\n\tc->listening_addr = xstrdup(fwd->listen_path);\n\treturn 1;\n}\n\nstatic int\nchannel_cancel_rport_listener_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RPORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, host) == 0 && c->listening_port == port) {\n\t\t\tdebug2_f(\"close channel %d\", i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int\nchannel_cancel_rport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_RUNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->path == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->path, path) == 0) {\n\t\t\tdebug2_f(\"close channel %d\", i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nint\nchannel_cancel_rport_listener(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_rport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_rport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port);\n\t}\n}\n\nstatic int\nchannel_cancel_lport_listener_tcpip(struct ssh *ssh,\n    const char *lhost, u_short lport, int cport,\n    struct ForwardOptions *fwd_opts)\n{\n\tu_int i;\n\tint found = 0;\n\tconst char *addr = channel_fwd_bind_addr(ssh, lhost, NULL, 1, fwd_opts);\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_PORT_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_port != lport)\n\t\t\tcontinue;\n\t\tif (cport == CHANNEL_CANCEL_PORT_STATIC) {\n\t\t\t \n\t\t\tif (c->host_port == 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (c->host_port != cport)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif ((c->listening_addr == NULL && addr != NULL) ||\n\t\t    (c->listening_addr != NULL && addr == NULL))\n\t\t\tcontinue;\n\t\tif (addr == NULL || strcmp(c->listening_addr, addr) == 0) {\n\t\t\tdebug2_f(\"close channel %d\", i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int\nchannel_cancel_lport_listener_streamlocal(struct ssh *ssh, const char *path)\n{\n\tu_int i;\n\tint found = 0;\n\n\tif (path == NULL) {\n\t\terror_f(\"no path specified.\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ssh->chanctxt->channels_alloc; i++) {\n\t\tChannel *c = ssh->chanctxt->channels[i];\n\t\tif (c == NULL || c->type != SSH_CHANNEL_UNIX_LISTENER)\n\t\t\tcontinue;\n\t\tif (c->listening_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(c->listening_addr, path) == 0) {\n\t\t\tdebug2_f(\"close channel %d\", i);\n\t\t\tchannel_free(ssh, c);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nint\nchannel_cancel_lport_listener(struct ssh *ssh,\n    struct Forward *fwd, int cport, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_cancel_lport_listener_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_cancel_lport_listener_tcpip(ssh,\n\t\t    fwd->listen_host, fwd->listen_port, cport, fwd_opts);\n\t}\n}\n\n \nint\nchannel_setup_local_fwd_listener(struct ssh *ssh,\n    struct Forward *fwd, struct ForwardOptions *fwd_opts)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_UNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_PORT_LISTENER, fwd, NULL, fwd_opts);\n\t}\n}\n\n \nstatic int\nremote_open_match(struct permission *allowed_open, struct Forward *fwd)\n{\n\tint ret;\n\tchar *lhost;\n\n\t \n\tif (fwd->listen_path != NULL)\n\t\treturn 1;\n\n\tif (fwd->listen_host == NULL || allowed_open->listen_host == NULL)\n\t\treturn 0;\n\n\tif (allowed_open->listen_port != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->listen_port != fwd->listen_port)\n\t\treturn 0;\n\n\t \n\tlhost = xstrdup(fwd->listen_host);\n\tlowercase(lhost);\n\tret = match_pattern(lhost, allowed_open->listen_host);\n\tfree(lhost);\n\n\treturn ret;\n}\n\n \nstatic int\ncheck_rfwd_permission(struct ssh *ssh, struct Forward *fwd)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->remote_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\t \n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (remote_open_match(perm, fwd)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn permit && permit_adm;\n}\n\n \nint\nchannel_setup_remote_fwd_listener(struct ssh *ssh, struct Forward *fwd,\n    int *allocated_listen_port, struct ForwardOptions *fwd_opts)\n{\n\tif (!check_rfwd_permission(ssh, fwd)) {\n\t\tssh_packet_send_debug(ssh, \"port forwarding refused\");\n\t\tif (fwd->listen_path != NULL)\n\t\t\t \n\t\t\tlogit(\"Received request from %.100s port %d to \"\n\t\t\t    \"remote forward to path \\\"%.100s\\\", \"\n\t\t\t    \"but the request was denied.\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t\t    fwd->listen_path);\n\t\telse if(fwd->listen_host != NULL)\n\t\t\tlogit(\"Received request from %.100s port %d to \"\n\t\t\t    \"remote forward to host %.100s port %d, \"\n\t\t\t    \"but the request was denied.\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t\t    fwd->listen_host, fwd->listen_port );\n\t\telse\n\t\t\tlogit(\"Received request from %.100s port %d to remote \"\n\t\t\t    \"forward, but the request was denied.\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\treturn 0;\n\t}\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_setup_fwd_listener_streamlocal(ssh,\n\t\t    SSH_CHANNEL_RUNIX_LISTENER, fwd, fwd_opts);\n\t} else {\n\t\treturn channel_setup_fwd_listener_tcpip(ssh,\n\t\t    SSH_CHANNEL_RPORT_LISTENER, fwd, allocated_listen_port,\n\t\t    fwd_opts);\n\t}\n}\n\n \nstatic const char *\nchannel_rfwd_bind_host(const char *listen_host)\n{\n\tif (listen_host == NULL) {\n\t\treturn \"localhost\";\n\t} else if (*listen_host == '\\0' || strcmp(listen_host, \"*\") == 0) {\n\t\treturn \"\";\n\t} else\n\t\treturn listen_host;\n}\n\n \nint\nchannel_request_remote_forwarding(struct ssh *ssh, struct Forward *fwd)\n{\n\tint r, success = 0, idx = -1;\n\tconst char *host_to_connect, *listen_host, *listen_path;\n\tint port_to_connect, listen_port;\n\n\t \n\tif (fwd->listen_path != NULL) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"streamlocal-forward@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 ||  \n\t\t    (r = sshpkt_put_cstring(ssh, fwd->listen_path)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal_fr(r, \"request streamlocal\");\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"tcpip-forward\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0 ||  \n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    channel_rfwd_bind_host(fwd->listen_host))) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, fwd->listen_port)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal_fr(r, \"request tcpip-forward\");\n\t}\n\t \n\tsuccess = 1;\n\tif (success) {\n\t\t \n\t\thost_to_connect = listen_host = listen_path = NULL;\n\t\tport_to_connect = listen_port = 0;\n\t\tif (fwd->connect_path != NULL) {\n\t\t\thost_to_connect = fwd->connect_path;\n\t\t\tport_to_connect = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\thost_to_connect = fwd->connect_host;\n\t\t\tport_to_connect = fwd->connect_port;\n\t\t}\n\t\tif (fwd->listen_path != NULL) {\n\t\t\tlisten_path = fwd->listen_path;\n\t\t\tlisten_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tlisten_host = fwd->listen_host;\n\t\t\tlisten_port = fwd->listen_port;\n\t\t}\n\t\tidx = permission_set_add(ssh, FORWARD_USER, FORWARD_LOCAL,\n\t\t    host_to_connect, port_to_connect,\n\t\t    listen_host, listen_path, listen_port, NULL);\n\t}\n\treturn idx;\n}\n\nstatic int\nopen_match(struct permission *allowed_open, const char *requestedhost,\n    int requestedport)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->port_to_connect != FWD_PERMIT_ANY_PORT &&\n\t    allowed_open->port_to_connect != requestedport)\n\t\treturn 0;\n\tif (strcmp(allowed_open->host_to_connect, FWD_PERMIT_ANY_HOST) != 0 &&\n\t    strcmp(allowed_open->host_to_connect, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int\nopen_listen_match_tcpip(struct permission *allowed_open,\n    const char *requestedhost, u_short requestedport, int translate)\n{\n\tconst char *allowed_host;\n\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != requestedport)\n\t\treturn 0;\n\tif (!translate && allowed_open->listen_host == NULL &&\n\t    requestedhost == NULL)\n\t\treturn 1;\n\tallowed_host = translate ?\n\t    channel_rfwd_bind_host(allowed_open->listen_host) :\n\t    allowed_open->listen_host;\n\tif (allowed_host == NULL || requestedhost == NULL ||\n\t    strcmp(allowed_host, requestedhost) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nopen_listen_match_streamlocal(struct permission *allowed_open,\n    const char *requestedpath)\n{\n\tif (allowed_open->host_to_connect == NULL)\n\t\treturn 0;\n\tif (allowed_open->listen_port != PORT_STREAMLOCAL)\n\t\treturn 0;\n\tif (allowed_open->listen_path == NULL ||\n\t    strcmp(allowed_open->listen_path, requestedpath) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int\nchannel_request_rforward_cancel_tcpip(struct ssh *ssh,\n    const char *host, u_short port)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm = NULL;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm, host, port, 0))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug_f(\"requested forward not found\");\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"cancel-tcpip-forward\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||  \n\t    (r = sshpkt_put_cstring(ssh, channel_rfwd_bind_host(host))) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, port)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send cancel\");\n\n\tfwd_perm_clear(perm);  \n\n\treturn 0;\n}\n\n \nstatic int\nchannel_request_rforward_cancel_streamlocal(struct ssh *ssh, const char *path)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tint r;\n\tu_int i;\n\tstruct permission *perm = NULL;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path))\n\t\t\tbreak;\n\t\tperm = NULL;\n\t}\n\tif (perm == NULL) {\n\t\tdebug_f(\"requested forward not found\");\n\t\treturn -1;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh,\n\t    \"cancel-streamlocal-forward@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||  \n\t    (r = sshpkt_put_cstring(ssh, path)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send cancel\");\n\n\tfwd_perm_clear(perm);  \n\n\treturn 0;\n}\n\n \nint\nchannel_request_rforward_cancel(struct ssh *ssh, struct Forward *fwd)\n{\n\tif (fwd->listen_path != NULL) {\n\t\treturn channel_request_rforward_cancel_streamlocal(ssh,\n\t\t    fwd->listen_path);\n\t} else {\n\t\treturn channel_request_rforward_cancel_tcpip(ssh,\n\t\t    fwd->listen_host,\n\t\t    fwd->listen_port ? fwd->listen_port : fwd->allocated_port);\n\t}\n}\n\n \nvoid\nchannel_permit_all(struct ssh *ssh, int where)\n{\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tif (pset->num_permitted_user == 0)\n\t\tpset->all_permitted = 1;\n}\n\n \nvoid\nchannel_add_permission(struct ssh *ssh, int who, int where,\n    char *host, int port)\n{\n\tint local = where == FORWARD_LOCAL;\n\tstruct permission_set *pset = permission_set_get(ssh, where);\n\n\tdebug(\"allow %s forwarding to host %s port %d\",\n\t    fwd_ident(who, where), host, port);\n\t \n\tpermission_set_add(ssh, who, where,\n\t    local ? host : 0, local ? port : 0,\n\t    local ? NULL : host, NULL, local ? 0 : port, NULL);\n\tpset->all_permitted = 0;\n}\n\n \nvoid\nchannel_disable_admin(struct ssh *ssh, int where)\n{\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tpermission_set_add(ssh, FORWARD_ADM, where,\n\t    NULL, 0, NULL, NULL, 0, NULL);\n}\n\n \nvoid\nchannel_clear_permission(struct ssh *ssh, int who, int where)\n{\n\tstruct permission **permp;\n\tu_int *npermp;\n\n\tpermission_set_get_array(ssh, who, where, &permp, &npermp);\n\t*permp = xrecallocarray(*permp, *npermp, 0, sizeof(**permp));\n\t*npermp = 0;\n}\n\n \nvoid\nchannel_update_permission(struct ssh *ssh, int idx, int newport)\n{\n\tstruct permission_set *pset = &ssh->chanctxt->local_perms;\n\n\tif (idx < 0 || (u_int)idx >= pset->num_permitted_user) {\n\t\tdebug_f(\"index out of range: %d num_permitted_user %d\",\n\t\t    idx, pset->num_permitted_user);\n\t\treturn;\n\t}\n\tdebug(\"%s allowed port %d for forwarding to host %s port %d\",\n\t    newport > 0 ? \"Updating\" : \"Removing\",\n\t    newport,\n\t    pset->permitted_user[idx].host_to_connect,\n\t    pset->permitted_user[idx].port_to_connect);\n\tif (newport <= 0)\n\t\tfwd_perm_clear(&pset->permitted_user[idx]);\n\telse {\n\t\tpset->permitted_user[idx].listen_port =\n\t\t    (ssh->compat & SSH_BUG_DYNAMIC_RPORT) ? 0 : newport;\n\t}\n}\n\n \nint\npermitopen_port(const char *p)\n{\n\tint port;\n\n\tif (strcmp(p, \"*\") == 0)\n\t\treturn FWD_PERMIT_ANY_PORT;\n\tif ((port = a2port(p)) > 0)\n\t\treturn port;\n\treturn -1;\n}\n\n \nstatic int\nconnect_next(struct channel_connect *cctx)\n{\n\tint sock, saved_errno;\n\tstruct sockaddr_un *sunaddr;\n\tchar ntop[NI_MAXHOST];\n\tchar strport[MAXIMUM(NI_MAXSERV, sizeof(sunaddr->sun_path))];\n\n\tfor (; cctx->ai; cctx->ai = cctx->ai->ai_next) {\n\t\tswitch (cctx->ai->ai_family) {\n\t\tcase AF_UNIX:\n\t\t\t \n\t\t\tsunaddr = (struct sockaddr_un *)cctx->ai->ai_addr;\n\t\t\tstrlcpy(ntop, \"unix\", sizeof(ntop));\n\t\t\tstrlcpy(strport, sunaddr->sun_path, sizeof(strport));\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\tcase AF_INET6:\n\t\t\tif (getnameinfo(cctx->ai->ai_addr, cctx->ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\terror_f(\"getnameinfo failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tdebug_f(\"start for host %.100s ([%.100s]:%s)\",\n\t\t    cctx->host, ntop, strport);\n\t\tif ((sock = socket(cctx->ai->ai_family, cctx->ai->ai_socktype,\n\t\t    cctx->ai->ai_protocol)) == -1) {\n\t\t\tif (cctx->ai->ai_next == NULL)\n\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(sock) == -1)\n\t\t\tfatal_f(\"set_nonblock(%d)\", sock);\n\t\tif (connect(sock, cctx->ai->ai_addr,\n\t\t    cctx->ai->ai_addrlen) == -1 && errno != EINPROGRESS) {\n\t\t\tdebug_f(\"host %.100s ([%.100s]:%s): %.100s\",\n\t\t\t    cctx->host, ntop, strport, strerror(errno));\n\t\t\tsaved_errno = errno;\n\t\t\tclose(sock);\n\t\t\terrno = saved_errno;\n\t\t\tcontinue;\t \n\t\t}\n\t\tif (cctx->ai->ai_family != AF_UNIX)\n\t\t\tset_nodelay(sock);\n\t\tdebug_f(\"connect host %.100s ([%.100s]:%s) in progress, fd=%d\",\n\t\t    cctx->host, ntop, strport, sock);\n\t\tcctx->ai = cctx->ai->ai_next;\n\t\treturn sock;\n\t}\n\treturn -1;\n}\n\nstatic void\nchannel_connect_ctx_free(struct channel_connect *cctx)\n{\n\tfree(cctx->host);\n\tif (cctx->aitop) {\n\t\tif (cctx->aitop->ai_family == AF_UNIX)\n\t\t\tfree(cctx->aitop);\n\t\telse\n\t\t\tfreeaddrinfo(cctx->aitop);\n\t}\n\tmemset(cctx, 0, sizeof(*cctx));\n}\n\n \nstatic int\nconnect_to_helper(struct ssh *ssh, const char *name, int port, int socktype,\n    char *ctype, char *rname, struct channel_connect *cctx,\n    int *reason, const char **errmsg)\n{\n\tstruct addrinfo hints;\n\tint gaierr;\n\tint sock = -1;\n\tchar strport[NI_MAXSERV];\n\n\tif (port == PORT_STREAMLOCAL) {\n\t\tstruct sockaddr_un *sunaddr;\n\t\tstruct addrinfo *ai;\n\n\t\tif (strlen(name) > sizeof(sunaddr->sun_path)) {\n\t\t\terror(\"%.100s: %.100s\", name, strerror(ENAMETOOLONG));\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tai = xmalloc(sizeof(*ai) + sizeof(*sunaddr));\n\t\tmemset(ai, 0, sizeof(*ai) + sizeof(*sunaddr));\n\t\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t\tai->ai_addrlen = sizeof(*sunaddr);\n\t\tai->ai_family = AF_UNIX;\n\t\tai->ai_socktype = socktype;\n\t\tai->ai_protocol = PF_UNSPEC;\n\t\tsunaddr = (struct sockaddr_un *)ai->ai_addr;\n\t\tsunaddr->sun_family = AF_UNIX;\n\t\tstrlcpy(sunaddr->sun_path, name, sizeof(sunaddr->sun_path));\n\t\tcctx->aitop = ai;\n\t} else {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_socktype = socktype;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(name, strport, &hints, &cctx->aitop))\n\t\t    != 0) {\n\t\t\tif (errmsg != NULL)\n\t\t\t\t*errmsg = ssh_gai_strerror(gaierr);\n\t\t\tif (reason != NULL)\n\t\t\t\t*reason = SSH2_OPEN_CONNECT_FAILED;\n\t\t\terror(\"connect_to %.100s: unknown host (%s)\", name,\n\t\t\t    ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcctx->host = xstrdup(name);\n\tcctx->port = port;\n\tcctx->ai = cctx->aitop;\n\n\tif ((sock = connect_next(cctx)) == -1) {\n\t\terror(\"connect to %.100s port %d failed: %s\",\n\t\t    name, port, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}\n\n \nstatic Channel *\nconnect_to(struct ssh *ssh, const char *host, int port,\n    char *ctype, char *rname)\n{\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tint sock;\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, NULL, NULL);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}\n\n \nChannel *\nchannel_connect_by_listen_address(struct ssh *ssh, const char *listen_host,\n    u_short listen_port, char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_tcpip(perm,\n\t\t    listen_host, listen_port, 1)) {\n\t\t\tif (perm->downstream)\n\t\t\t\treturn perm->downstream;\n\t\t\tif (perm->port_to_connect == 0)\n\t\t\t\treturn rdynamic_connect_prepare(ssh,\n\t\t\t\t    ctype, rname);\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown listen_port %d\",\n\t    listen_port);\n\treturn NULL;\n}\n\nChannel *\nchannel_connect_by_listen_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i;\n\tstruct permission *perm;\n\n\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\tperm = &pset->permitted_user[i];\n\t\tif (open_listen_match_streamlocal(perm, path)) {\n\t\t\treturn connect_to(ssh,\n\t\t\t    perm->host_to_connect, perm->port_to_connect,\n\t\t\t    ctype, rname);\n\t\t}\n\t}\n\terror(\"WARNING: Server requests forwarding for unknown path %.100s\",\n\t    path);\n\treturn NULL;\n}\n\n \nChannel *\nchannel_connect_to_port(struct ssh *ssh, const char *host, u_short port,\n    char *ctype, char *rname, int *reason, const char **errmsg)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct channel_connect cctx;\n\tChannel *c;\n\tu_int i, permit, permit_adm = 1;\n\tint sock;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, host, port)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request from %.100s port %d to connect to \"\n\t\t    \"host %.100s port %d, but the request was denied.\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), host, port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\treturn NULL;\n\t}\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, host, port, SOCK_STREAM, ctype, rname,\n\t    &cctx, reason, errmsg);\n\tif (sock == -1) {\n\t\tchannel_connect_ctx_free(&cctx);\n\t\treturn NULL;\n\t}\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_CONNECTING, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = port;\n\tc->path = xstrdup(host);\n\tc->connect_ctx = cctx;\n\n\treturn c;\n}\n\n \nChannel *\nchannel_connect_to_path(struct ssh *ssh, const char *path,\n    char *ctype, char *rname)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tu_int i, permit, permit_adm = 1;\n\tstruct permission *perm;\n\n\tpermit = pset->all_permitted;\n\tif (!permit) {\n\t\tfor (i = 0; i < pset->num_permitted_user; i++) {\n\t\t\tperm = &pset->permitted_user[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, path, PORT_STREAMLOCAL)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!permit || !permit_adm) {\n\t\tlogit(\"Received request to connect to path %.100s, \"\n\t\t    \"but the request was denied.\", path);\n\t\treturn NULL;\n\t}\n\treturn connect_to(ssh, path, PORT_STREAMLOCAL, ctype, rname);\n}\n\nvoid\nchannel_send_window_changes(struct ssh *ssh)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct winsize ws;\n\tint r;\n\tu_int i;\n\n\tfor (i = 0; i < sc->channels_alloc; i++) {\n\t\tif (sc->channels[i] == NULL || !sc->channels[i]->client_tty ||\n\t\t    sc->channels[i]->type != SSH_CHANNEL_OPEN)\n\t\t\tcontinue;\n\t\tif (ioctl(sc->channels[i]->rfd, TIOCGWINSZ, &ws) == -1)\n\t\t\tcontinue;\n\t\tchannel_request_start(ssh, i, \"window-change\", 0);\n\t\tif ((r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"channel %u; send window-change\", i);\n\t}\n}\n\n \nstatic Channel *\nrdynamic_connect_prepare(struct ssh *ssh, char *ctype, char *rname)\n{\n\tChannel *c;\n\tint r;\n\n\tc = channel_new(ssh, ctype, SSH_CHANNEL_RDYNAMIC_OPEN, -1, -1, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, rname, 1);\n\tc->host_port = 0;\n\tc->path = NULL;\n\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0)\n\t\tfatal_fr(r, \"channel %i; confirm\", c->self);\n\treturn c;\n}\n\n \nstatic int\nrdynamic_connect_finish(struct ssh *ssh, Channel *c)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tstruct permission_set *pset = &sc->local_perms;\n\tstruct permission *perm;\n\tstruct channel_connect cctx;\n\tu_int i, permit_adm = 1;\n\tint sock;\n\n\tif (pset->num_permitted_admin > 0) {\n\t\tpermit_adm = 0;\n\t\tfor (i = 0; i < pset->num_permitted_admin; i++) {\n\t\t\tperm = &pset->permitted_admin[i];\n\t\t\tif (open_match(perm, c->path, c->host_port)) {\n\t\t\t\tpermit_adm = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!permit_adm) {\n\t\tdebug_f(\"requested forward not permitted\");\n\t\treturn -1;\n\t}\n\n\tmemset(&cctx, 0, sizeof(cctx));\n\tsock = connect_to_helper(ssh, c->path, c->host_port, SOCK_STREAM, NULL,\n\t    NULL, &cctx, NULL, NULL);\n\tif (sock == -1)\n\t\tchannel_connect_ctx_free(&cctx);\n\telse {\n\t\t \n\t\tc->type = SSH_CHANNEL_RDYNAMIC_FINISH;\n\t\tc->connect_ctx = cctx;\n\t\tchannel_register_fds(ssh, c, sock, sock, -1, 0, 1, 0);\n\t}\n\treturn sock;\n}\n\n \n\n \nint\nx11_create_display_inet(struct ssh *ssh, int x11_display_offset,\n    int x11_use_localhost, int single_connection,\n    u_int *display_numberp, int **chanids)\n{\n\tChannel *nc = NULL;\n\tint display_number, sock;\n\tu_short port;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, n, num_socks = 0, socks[NUM_SOCKS];\n\n\tif (chanids == NULL)\n\t\treturn -1;\n\n\tfor (display_number = x11_display_offset;\n\t    display_number < MAX_DISPLAYS;\n\t    display_number++) {\n\t\tport = 6000 + display_number;\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ssh->chanctxt->IPv4or6;\n\t\thints.ai_flags = x11_use_localhost ? 0: AI_PASSIVE;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\tsnprintf(strport, sizeof strport, \"%d\", port);\n\t\tif ((gaierr = getaddrinfo(NULL, strport,\n\t\t    &hints, &aitop)) != 0) {\n\t\t\terror(\"getaddrinfo: %.100s\", ssh_gai_strerror(gaierr));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6)\n\t\t\t\tcontinue;\n\t\t\tsock = socket(ai->ai_family, ai->ai_socktype,\n\t\t\t    ai->ai_protocol);\n\t\t\tif (sock == -1) {\n\t\t\t\tif ((errno != EINVAL) && (errno != EAFNOSUPPORT)\n#ifdef EPFNOSUPPORT\n\t\t\t\t    && (errno != EPFNOSUPPORT)\n#endif \n\t\t\t\t    ) {\n\t\t\t\t\terror(\"socket: %.100s\", strerror(errno));\n\t\t\t\t\tfreeaddrinfo(aitop);\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\tdebug(\"x11_create_display_inet: Socket family %d not supported\",\n\t\t\t\t\t\t ai->ai_family);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ai->ai_family == AF_INET6)\n\t\t\t\tsock_set_v6only(sock);\n\t\t\tif (x11_use_localhost)\n\t\t\t\tset_reuseaddr(sock);\n\t\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) == -1) {\n\t\t\t\tdebug2_f(\"bind port %d: %.100s\", port,\n\t\t\t\t    strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tfor (n = 0; n < num_socks; n++)\n\t\t\t\t\tclose(socks[n]);\n\t\t\t\tnum_socks = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsocks[num_socks++] = sock;\n\t\t\tif (num_socks == NUM_SOCKS)\n\t\t\t\tbreak;\n\t\t}\n\t\tfreeaddrinfo(aitop);\n\t\tif (num_socks > 0)\n\t\t\tbreak;\n\t}\n\tif (display_number >= MAX_DISPLAYS) {\n\t\terror(\"Failed to allocate internet-domain X11 display socket.\");\n\t\treturn -1;\n\t}\n\t \n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tif (listen(sock, SSH_LISTEN_BACKLOG) == -1) {\n\t\t\terror(\"listen: %.100s\", strerror(errno));\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\t*chanids = xcalloc(num_socks + 1, sizeof(**chanids));\n\tfor (n = 0; n < num_socks; n++) {\n\t\tsock = socks[n];\n\t\tnc = channel_new(ssh, \"x11-listener\",\n\t\t    SSH_CHANNEL_X11_LISTENER, sock, sock, -1,\n\t\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t\t    0, \"X11 inet listener\", 1);\n\t\tnc->single_connection = single_connection;\n\t\t(*chanids)[n] = nc->self;\n\t}\n\t(*chanids)[n] = -1;\n\n\t \n\t*display_numberp = display_number;\n\treturn 0;\n}\n\nstatic int\nconnect_local_xsocket_path(const char *pathname)\n{\n\tint sock;\n\tstruct sockaddr_un addr;\n\n\tsock = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\terror(\"socket: %.100s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrlcpy(addr.sun_path, pathname, sizeof addr.sun_path);\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n\t\treturn sock;\n\tclose(sock);\n\terror(\"connect %.100s: %.100s\", addr.sun_path, strerror(errno));\n\treturn -1;\n}\n\nstatic int\nconnect_local_xsocket(u_int dnr)\n{\n\tchar buf[1024];\n\tsnprintf(buf, sizeof buf, _PATH_UNIX_X, dnr);\n\treturn connect_local_xsocket_path(buf);\n}\n\n#ifdef __APPLE__\nstatic int\nis_path_to_xsocket(const char *display, char *path, size_t pathlen)\n{\n\tstruct stat sbuf;\n\n\tif (strlcpy(path, display, pathlen) >= pathlen) {\n\t\terror(\"%s: display path too long\", __func__);\n\t\treturn 0;\n\t}\n\tif (display[0] != '/')\n\t\treturn 0;\n\tif (stat(path, &sbuf) == 0) {\n\t\treturn 1;\n\t} else {\n\t\tchar *dot = strrchr(path, '.');\n\t\tif (dot != NULL) {\n\t\t\t*dot = '\\0';\n\t\t\tif (stat(path, &sbuf) == 0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nint\nx11_connect_display(struct ssh *ssh)\n{\n\tu_int display_number;\n\tconst char *display;\n\tchar buf[1024], *cp;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, sock = 0;\n\n\t \n\tdisplay = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\terror(\"DISPLAY not set.\");\n\t\treturn -1;\n\t}\n\t \n\n#ifdef __APPLE__\n\t \n\t{\n\t\tchar path[PATH_MAX];\n\n\t\tif (is_path_to_xsocket(display, path, sizeof(path))) {\n\t\t\tdebug(\"x11_connect_display: $DISPLAY is launchd\");\n\n\t\t\t \n\t\t\tsock = connect_local_xsocket_path(path);\n\t\t\tif (sock < 0)\n\t\t\t\treturn -1;\n\n\t\t\t \n\t\t\treturn sock;\n\t\t}\n\t}\n#endif\n\t \n\tif (strncmp(display, \"unix:\", 5) == 0 ||\n\t    display[0] == ':') {\n\t\t \n\t\tif (sscanf(strrchr(display, ':') + 1, \"%u\",\n\t\t    &display_number) != 1) {\n\t\t\terror(\"Could not parse display number from DISPLAY: \"\n\t\t\t    \"%.100s\", display);\n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tsock = connect_local_xsocket(display_number);\n\t\tif (sock < 0)\n\t\t\treturn -1;\n\n\t\t \n\t\treturn sock;\n\t}\n\t \n\tstrlcpy(buf, display, sizeof(buf));\n\tcp = strchr(buf, ':');\n\tif (!cp) {\n\t\terror(\"Could not find ':' in DISPLAY: %.100s\", display);\n\t\treturn -1;\n\t}\n\t*cp = 0;\n\t \n\tif (sscanf(cp + 1, \"%u\", &display_number) != 1) {\n\t\terror(\"Could not parse display number from DISPLAY: %.100s\",\n\t\t    display);\n\t\treturn -1;\n\t}\n\n\t \n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = ssh->chanctxt->IPv4or6;\n\thints.ai_socktype = SOCK_STREAM;\n\tsnprintf(strport, sizeof strport, \"%u\", 6000 + display_number);\n\tif ((gaierr = getaddrinfo(buf, strport, &hints, &aitop)) != 0) {\n\t\terror(\"%.100s: unknown host. (%s)\", buf,\n\t\tssh_gai_strerror(gaierr));\n\t\treturn -1;\n\t}\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t \n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock == -1) {\n\t\t\tdebug2(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {\n\t\t\tdebug2(\"connect %.100s port %u: %.100s\", buf,\n\t\t\t    6000 + display_number, strerror(errno));\n\t\t\tclose(sock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\tif (!ai) {\n\t\terror(\"connect %.100s port %u: %.100s\", buf,\n\t\t    6000 + display_number, strerror(errno));\n\t\treturn -1;\n\t}\n\tset_nodelay(sock);\n\treturn sock;\n}\n\n \nvoid\nx11_request_forwarding_with_spoofing(struct ssh *ssh, int client_session_id,\n    const char *disp, const char *proto, const char *data, int want_reply)\n{\n\tstruct ssh_channels *sc = ssh->chanctxt;\n\tu_int data_len = (u_int) strlen(data) / 2;\n\tu_int i, value;\n\tconst char *cp;\n\tchar *new_data;\n\tint r, screen_number;\n\n\tif (sc->x11_saved_display == NULL)\n\t\tsc->x11_saved_display = xstrdup(disp);\n\telse if (strcmp(disp, sc->x11_saved_display) != 0) {\n\t\terror(\"x11_request_forwarding_with_spoofing: different \"\n\t\t    \"$DISPLAY already forwarded\");\n\t\treturn;\n\t}\n\n\tcp = strchr(disp, ':');\n\tif (cp)\n\t\tcp = strchr(cp, '.');\n\tif (cp)\n\t\tscreen_number = (u_int)strtonum(cp + 1, 0, 400, NULL);\n\telse\n\t\tscreen_number = 0;\n\n\tif (sc->x11_saved_proto == NULL) {\n\t\t \n\t\tsc->x11_saved_proto = xstrdup(proto);\n\n\t\t \n\t\tsc->x11_saved_data = xmalloc(data_len);\n\t\tfor (i = 0; i < data_len; i++) {\n\t\t\tif (sscanf(data + 2 * i, \"%2x\", &value) != 1) {\n\t\t\t\tfatal(\"x11_request_forwarding: bad \"\n\t\t\t\t    \"authentication data: %.100s\", data);\n\t\t\t}\n\t\t\tsc->x11_saved_data[i] = value;\n\t\t}\n\t\tsc->x11_saved_data_len = data_len;\n\n\t\t \n\t\tsc->x11_fake_data = xmalloc(data_len);\n\t\tarc4random_buf(sc->x11_fake_data, data_len);\n\t\tsc->x11_fake_data_len = data_len;\n\t}\n\n\t \n\tnew_data = tohex(sc->x11_fake_data, data_len);\n\n\t \n\tchannel_request_start(ssh, client_session_id, \"x11-req\", want_reply);\n\tif ((r = sshpkt_put_u8(ssh, 0)) != 0 ||  \n\t    (r = sshpkt_put_cstring(ssh, proto)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, new_data)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, screen_number)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \"send x11-req\");\n\tfree(new_data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}