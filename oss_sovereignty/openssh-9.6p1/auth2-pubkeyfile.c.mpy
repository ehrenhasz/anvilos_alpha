{
  "module_name": "auth2-pubkeyfile.c",
  "hash_id": "878f7c248d008f547c6afe7ea8407164ec0d866760d400fe491334a272ba863c",
  "original_prompt": "Ingested from openssh-9.6p1/auth2-pubkeyfile.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n#include \"authfile.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n\nint\nauth_authorise_keyopts(struct passwd *pw, struct sshauthopt *opts,\n    int allow_cert_authority, const char *remote_ip, const char *remote_host,\n    const char *loc)\n{\n\ttime_t now = time(NULL);\n\tchar buf[64];\n\n\t \n\tif (opts->valid_before && now > 0 &&\n\t    opts->valid_before < (uint64_t)now) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: entry expired at %s\", loc, buf);\n\t\tauth_debug_add(\"%s: entry expired at %s\", loc, buf);\n\t\treturn -1;\n\t}\n\t \n\tif (opts->cert_principals != NULL && !opts->cert_authority) {\n\t\tdebug(\"%s: principals on non-CA key\", loc);\n\t\tauth_debug_add(\"%s: principals on non-CA key\", loc);\n\t\t \n\t\treturn -1;\n\t}\n\t \n\tif (!allow_cert_authority && opts->cert_authority) {\n\t\tdebug(\"%s: cert-authority flag invalid here\", loc);\n\t\tauth_debug_add(\"%s: cert-authority flag invalid here\", loc);\n\t\t \n\t\treturn -1;\n\t}\n\n\t \n\tif (opts->required_from_host_keys != NULL) {\n\t\tswitch (match_host_and_ip(remote_host, remote_ip,\n\t\t    opts->required_from_host_keys )) {\n\t\tcase 1:\n\t\t\t \n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\tdebug(\"%s: invalid from criteria\", loc);\n\t\t\tauth_debug_add(\"%s: invalid from criteria\", loc);\n\t\t\t \n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with \"\n\t\t\t    \"correct key but not from a permitted \"\n\t\t\t    \"host (host=%.200s, ip=%.200s, required=%.200s).\",\n\t\t\t    loc, pw->pw_name, remote_host, remote_ip,\n\t\t\t    opts->required_from_host_keys);\n\t\t\tauth_debug_add(\"%s: Your host '%.200s' is not \"\n\t\t\t    \"permitted to use this key for login.\",\n\t\t\t    loc, remote_host);\n\t\t\t \n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tif (opts->required_from_host_cert != NULL) {\n\t\tswitch (addr_match_cidr_list(remote_ip,\n\t\t    opts->required_from_host_cert)) {\n\t\tcase 1:\n\t\t\t \n\t\t\tbreak;\n\t\tcase -1:\n\t\tdefault:\n\t\t\t \n\t\t\terror(\"%s: Certificate source-address invalid\", loc);\n\t\t\t \n\t\tcase 0:\n\t\t\tlogit(\"%s: Authentication tried for %.100s with valid \"\n\t\t\t    \"certificate but not from a permitted source \"\n\t\t\t    \"address (%.200s).\", loc, pw->pw_name, remote_ip);\n\t\t\tauth_debug_add(\"%s: Your address '%.200s' is not \"\n\t\t\t    \"permitted to use this certificate for login.\",\n\t\t\t    loc, remote_ip);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tauth_log_authopts(loc, opts, 1);\n\n\treturn 0;\n}\n\nstatic int\nmatch_principals_option(const char *principal_list, struct sshkey_cert *cert)\n{\n\tchar *result;\n\tu_int i;\n\n\t \n\n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif ((result = match_list(cert->principals[i],\n\t\t    principal_list, NULL)) != NULL) {\n\t\t\tdebug3(\"matched principal from key options \\\"%.100s\\\"\",\n\t\t\t    result);\n\t\t\tfree(result);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint\nauth_check_principals_line(char *cp, const struct sshkey_cert *cert,\n    const char *loc, struct sshauthopt **authoptsp)\n{\n\tu_int i, found = 0;\n\tchar *ep, *line_opts;\n\tconst char *reason = NULL;\n\tstruct sshauthopt *opts = NULL;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t \n\tep = cp + strlen(cp) - 1;\n\twhile (ep > cp && (*ep == '\\n' || *ep == ' ' || *ep == '\\t'))\n\t\t*ep-- = '\\0';\n\n\t \n\tline_opts = NULL;\n\tif ((ep = strrchr(cp, ' ')) != NULL ||\n\t    (ep = strrchr(cp, '\\t')) != NULL) {\n\t\tfor (; *ep == ' ' || *ep == '\\t'; ep++)\n\t\t\t;\n\t\tline_opts = cp;\n\t\tcp = ep;\n\t}\n\tif ((opts = sshauthopt_parse(line_opts, &reason)) == NULL) {\n\t\tdebug(\"%s: bad principals options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad principals options: %s\", loc, reason);\n\t\treturn -1;\n\t}\n\t \n\tfor (i = 0; i < cert->nprincipals; i++) {\n\t\tif (strcmp(cp, cert->principals[i]) != 0)\n\t\t\tcontinue;\n\t\tdebug3(\"%s: matched principal \\\"%.100s\\\"\",\n\t\t    loc, cert->principals[i]);\n\t\tfound = 1;\n\t}\n\tif (found && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn found ? 0 : -1;\n}\n\nint\nauth_process_principals(FILE *f, const char *file,\n    const struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tchar loc[256], *line = NULL, *cp, *ep;\n\tsize_t linesize = 0;\n\tu_long linenum = 0, nonblank = 0;\n\tu_int found_principal = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t \n\t\tif (found_principal)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\t \n\t\tif ((ep = strchr(cp, '#')) != NULL)\n\t\t\t*ep = '\\0';\n\t\tif (!*cp || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tnonblank++;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (auth_check_principals_line(cp, cert, loc, authoptsp) == 0)\n\t\t\tfound_principal = 1;\n\t}\n\tdebug2_f(\"%s: processed %lu/%lu lines\", file, nonblank, linenum);\n\tfree(line);\n\treturn found_principal;\n}\n\n \nint\nauth_check_authkey_line(struct passwd *pw, struct sshkey *key,\n    char *cp, const char *remote_ip, const char *remote_host, const char *loc,\n    struct sshauthopt **authoptsp)\n{\n\tint want_keytype = sshkey_is_cert(key) ? KEY_UNSPEC : key->type;\n\tstruct sshkey *found = NULL;\n\tstruct sshauthopt *keyopts = NULL, *certopts = NULL, *finalopts = NULL;\n\tchar *key_options = NULL, *fp = NULL;\n\tconst char *reason = NULL;\n\tint ret = -1;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif ((found = sshkey_new(want_keytype)) == NULL) {\n\t\tdebug3_f(\"keytype %d failed\", want_keytype);\n\t\tgoto out;\n\t}\n\n\t \n\n\tif (sshkey_read(found, &cp) != 0) {\n\t\t \n\t\tdebug2(\"%s: check options: '%s'\", loc, cp);\n\t\tkey_options = cp;\n\t\tif (sshkey_advance_past_options(&cp) != 0) {\n\t\t\treason = \"invalid key option string\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tskip_space(&cp);\n\t\tif (sshkey_read(found, &cp) != 0) {\n\t\t\t \n\t\t\tdebug2(\"%s: advance: '%s'\", loc, cp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tif ((keyopts = sshauthopt_parse(key_options, &reason)) == NULL) {\n\t\tdebug(\"%s: bad key options: %s\", loc, reason);\n\t\tauth_debug_add(\"%s: bad key options: %s\", loc, reason);\n\t\tgoto out;\n\t}\n\t \n\tif (sshkey_is_cert(key)) {\n\t\t \n\t\tif (!sshkey_equal(found, key->cert->signature_key) ||\n\t\t    !keyopts->cert_authority)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\tif (!sshkey_equal(found, key) || keyopts->cert_authority)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif ((fp = sshkey_fingerprint(found,\n\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\n\tdebug(\"%s: matching %s found: %s %s\", loc,\n\t    sshkey_is_cert(key) ? \"CA\" : \"key\", sshkey_type(found), fp);\n\n\tif (auth_authorise_keyopts(pw, keyopts,\n\t    sshkey_is_cert(key), remote_ip, remote_host, loc) != 0) {\n\t\treason = \"Refused by key options\";\n\t\tgoto fail_reason;\n\t}\n\t \n\tif (!sshkey_is_cert(key)) {\n\t\tverbose(\"Accepted key %s %s found at %s\",\n\t\t    sshkey_type(found), fp, loc);\n\t\tfinalopts = keyopts;\n\t\tkeyopts = NULL;\n\t\tgoto success;\n\t}\n\n\t \n\n\t \n\tif ((certopts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(pw, certopts, 0,\n\t    remote_ip, remote_host, loc) != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif ((finalopts = sshauthopt_merge(keyopts, certopts, &reason)) == NULL)\n\t\tgoto fail_reason;\n\n\t \n\tif (keyopts->cert_principals != NULL &&\n\t    !match_principals_option(keyopts->cert_principals, key->cert)) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (sshkey_cert_check_authority_now(key, 0, 0, 0,\n\t    keyopts->cert_principals == NULL ? pw->pw_name : NULL,\n\t    &reason) != 0)\n\t\tgoto fail_reason;\n\n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) \"\n\t    \"signed by CA %s %s found at %s\",\n\t    key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(found), fp, loc);\n\n success:\n\tif (finalopts == NULL)\n\t\tfatal_f(\"internal error: missing options\");\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = finalopts;\n\t\tfinalopts = NULL;\n\t}\n\t \n\tret = 0;\n\tgoto out;\n\n fail_reason:\n\terror(\"%s\", reason);\n\tauth_debug_add(\"%s\", reason);\n out:\n\tfree(fp);\n\tsshauthopt_free(keyopts);\n\tsshauthopt_free(certopts);\n\tsshauthopt_free(finalopts);\n\tsshkey_free(found);\n\treturn ret;\n}\n\n \nint\nauth_check_authkeys_file(struct passwd *pw, FILE *f, char *file,\n    struct sshkey *key, const char *remote_ip,\n    const char *remote_host, struct sshauthopt **authoptsp)\n{\n\tchar *cp, *line = NULL, loc[256];\n\tsize_t linesize = 0;\n\tint found_key = 0;\n\tu_long linenum = 0, nonblank = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\t \n\t\tif (found_key)\n\t\t\tcontinue;\n\n\t\t \n\t\tcp = line;\n\t\tskip_space(&cp);\n\t\tif (!*cp || *cp == '\\n' || *cp == '#')\n\t\t\tcontinue;\n\n\t\tnonblank++;\n\t\tsnprintf(loc, sizeof(loc), \"%.200s:%lu\", file, linenum);\n\t\tif (auth_check_authkey_line(pw, key, cp,\n\t\t    remote_ip, remote_host, loc, authoptsp) == 0)\n\t\t\tfound_key = 1;\n\t}\n\tfree(line);\n\tdebug2_f(\"%s: processed %lu/%lu lines\", file, nonblank, linenum);\n\treturn found_key;\n}\n\nstatic FILE *\nauth_openfile(const char *file, struct passwd *pw, int strict_modes,\n    int log_missing, char *file_type)\n{\n\tchar line[1024];\n\tstruct stat st;\n\tint fd;\n\tFILE *f;\n\n\tif ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {\n\t\tif (errno != ENOENT) {\n\t\t\tlogit(\"Could not open user '%s' %s '%s': %s\",\n\t\t\t    pw->pw_name, file_type, file, strerror(errno));\n\t\t} else if (log_missing) {\n\t\t\tdebug(\"Could not open user '%s' %s '%s': %s\",\n\t\t\t    pw->pw_name, file_type, file, strerror(errno));\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (!S_ISREG(st.st_mode)) {\n\t\tlogit(\"User '%s' %s '%s' is not a regular file\",\n\t\t    pw->pw_name, file_type, file);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tunset_nonblock(fd);\n\tif ((f = fdopen(fd, \"r\")) == NULL) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\tif (strict_modes &&\n\t    safe_path_fd(fileno(f), file, pw, line, sizeof(line)) != 0) {\n\t\tfclose(f);\n\t\tlogit(\"Authentication refused: %s\", line);\n\t\tauth_debug_add(\"Ignored %s: %s\", file_type, line);\n\t\treturn NULL;\n\t}\n\n\treturn f;\n}\n\n\nFILE *\nauth_openkeyfile(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 1, \"authorized keys\");\n}\n\nFILE *\nauth_openprincipals(const char *file, struct passwd *pw, int strict_modes)\n{\n\treturn auth_openfile(file, pw, strict_modes, 0,\n\t    \"authorized principals\");\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}