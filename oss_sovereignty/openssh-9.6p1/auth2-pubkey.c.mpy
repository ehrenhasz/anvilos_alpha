{
  "module_name": "auth2-pubkey.c",
  "hash_id": "26c04dcfa4233b77a76b3c120e8e3d02a7ec84d20dd5f05b554d8827652f814b",
  "original_prompt": "Ingested from openssh-9.6p1/auth2-pubkey.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"kex.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"compat.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"auth-options.h\"\n#include \"canohost.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"authfile.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"channels.h\"  \n#include \"session.h\"  \n#include \"sk-api.h\"\n\n \nextern ServerOptions options;\n\nstatic char *\nformat_key(const struct sshkey *key)\n{\n\tchar *ret, *fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\n\txasprintf(&ret, \"%s %s\", sshkey_type(key), fp);\n\tfree(fp);\n\treturn ret;\n}\n\nstatic int\nuserauth_pubkey(struct ssh *ssh, const char *method)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tstruct sshbuf *b = NULL;\n\tstruct sshkey *key = NULL, *hostkey = NULL;\n\tchar *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n\tu_char *pkblob = NULL, *sig = NULL, have_sig;\n\tsize_t blen, slen;\n\tint hostbound, r, pktype;\n\tint req_presence = 0, req_verify = 0, authenticated = 0;\n\tstruct sshauthopt *authopts = NULL;\n\tstruct sshkey_sig_details *sig_details = NULL;\n\n\thostbound = strcmp(method, \"publickey-hostbound-v00@openssh.com\") == 0;\n\n\tif ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n\t\tfatal_fr(r, \"parse %s packet\", method);\n\n\t \n\tif (hostbound) {\n\t\tif ((r = sshpkt_getb_froms(ssh, &b)) != 0 ||\n\t\t    (r = sshkey_fromb(b, &hostkey)) != 0)\n\t\t\tfatal_fr(r, \"parse %s hostkey\", method);\n\t\tif (ssh->kex->initial_hostkey == NULL)\n\t\t\tfatal_f(\"internal error: initial hostkey not recorded\");\n\t\tif (!sshkey_equal(hostkey, ssh->kex->initial_hostkey))\n\t\t\tfatal_f(\"%s packet contained wrong host key\", method);\n\t\tsshbuf_free(b);\n\t\tb = NULL;\n\t}\n\n\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG2) {\n\t\tchar *keystring;\n\t\tstruct sshbuf *pkbuf;\n\n\t\tif ((pkbuf = sshbuf_from(pkblob, blen)) == NULL)\n\t\t\tfatal_f(\"sshbuf_from failed\");\n\t\tif ((keystring = sshbuf_dtob64_string(pkbuf, 0)) == NULL)\n\t\t\tfatal_f(\"sshbuf_dtob64 failed\");\n\t\tdebug2_f(\"%s user %s %s public key %s %s\",\n\t\t    authctxt->valid ? \"valid\" : \"invalid\", authctxt->user,\n\t\t    have_sig ? \"attempting\" : \"querying\", pkalg, keystring);\n\t\tsshbuf_free(pkbuf);\n\t\tfree(keystring);\n\t}\n\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t \n\t\tverbose_f(\"unsupported public key algorithm: %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror_fr(r, \"parse key\");\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror_f(\"cannot decode key: %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror_f(\"type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (auth2_key_already_used(authctxt, key)) {\n\t\tlogit(\"refusing previously-used %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.pubkey_accepted_algos, 0) != 1) {\n\t\tlogit_f(\"signature algorithm %s not in \"\n\t\t    \"PubkeyAcceptedAlgorithms\", pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit_fr(r, \"certificate signature algorithm %s\",\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_check_rsa_length(key,\n\t    options.required_rsa_size)) != 0) {\n\t\tlogit_r(r, \"refusing %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\tkey_s = format_key(key);\n\tif (sshkey_is_cert(key))\n\t\tca_s = format_key(key->cert->signature_key);\n\n\tif (have_sig) {\n\t\tdebug3_f(\"%s have %s signature for %s%s%s\",\n\t\t    method, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \", ca_s == NULL ? \"\" : ca_s);\n\t\tif ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n\t\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal_fr(r, \"parse signature packet\");\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_putb(b, ssh->kex->session_id)) != 0)\n\t\t\t\tfatal_fr(r, \"put old session id\");\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_stringb(b,\n\t\t\t    ssh->kex->session_id)) != 0)\n\t\t\t\tfatal_fr(r, \"put session id\");\n\t\t}\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2_f(\"disabled because of invalid user\");\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t\t    authctxt->style ? \":\" : \"\",\n\t\t    authctxt->style ? authctxt->style : \"\");\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, method)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, pkalg)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n\t\t\tfatal_fr(r, \"reconstruct %s packet\", method);\n\t\tif (hostbound &&\n\t\t    (r = sshkey_puts(ssh->kex->initial_hostkey, b)) != 0)\n\t\t\tfatal_fr(r, \"reconstruct %s packet\", method);\n#ifdef DEBUG_PK\n\t\tsshbuf_dump(b, stderr);\n#endif\n\t\t \n\t\tauthenticated = 0;\n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n\t\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b),\n\t\t    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n\t\t    ssh->compat, &sig_details)) == 0) {\n\t\t\tauthenticated = 1;\n\t\t}\n\t\tif (authenticated == 1 && sig_details != NULL) {\n\t\t\tauth2_record_info(authctxt, \"signature count = %u\",\n\t\t\t    sig_details->sk_counter);\n\t\t\tdebug_f(\"sk_counter = %u, sk_flags = 0x%02x\",\n\t\t\t    sig_details->sk_counter, sig_details->sk_flags);\n\t\t\treq_presence = (options.pubkey_auth_options &\n\t\t\t    PUBKEYAUTH_TOUCH_REQUIRED) ||\n\t\t\t    !authopts->no_require_user_presence;\n\t\t\tif (req_presence && (sig_details->sk_flags &\n\t\t\t    SSH_SK_USER_PRESENCE_REQD) == 0) {\n\t\t\t\terror(\"public key %s signature for %s%s from \"\n\t\t\t\t    \"%.128s port %d rejected: user presence \"\n\t\t\t\t    \"(authenticator touch) requirement \"\n\t\t\t\t    \"not met \", key_s,\n\t\t\t\t    authctxt->valid ? \"\" : \"invalid user \",\n\t\t\t\t    authctxt->user, ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh));\n\t\t\t\tauthenticated = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\treq_verify = (options.pubkey_auth_options &\n\t\t\t    PUBKEYAUTH_VERIFY_REQUIRED) ||\n\t\t\t    authopts->require_verify;\n\t\t\tif (req_verify && (sig_details->sk_flags &\n\t\t\t    SSH_SK_USER_VERIFICATION_REQD) == 0) {\n\t\t\t\terror(\"public key %s signature for %s%s from \"\n\t\t\t\t    \"%.128s port %d rejected: user \"\n\t\t\t\t    \"verification requirement not met \", key_s,\n\t\t\t\t    authctxt->valid ? \"\" : \"invalid user \",\n\t\t\t\t    authctxt->user, ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh));\n\t\t\t\tauthenticated = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tauth2_record_key(authctxt, authenticated, key);\n\t} else {\n\t\tdebug_f(\"%s test pkalg %s pkblob %s%s%s\", method, pkalg, key_s,\n\t\t    ca_s == NULL ? \"\" : \" CA \", ca_s == NULL ? \"\" : ca_s);\n\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tfatal_fr(r, \"parse packet\");\n\n\t\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\t\tdebug2_f(\"disabled because of invalid user\");\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\t \n\t\tif (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n\t\t\t    != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"send packet\");\n\t\t\tauthctxt->postponed = 1;\n\t\t}\n\t}\ndone:\n\tif (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n\t\tdebug_f(\"key options inconsistent with existing\");\n\t\tauthenticated = 0;\n\t}\n\tdebug2_f(\"authenticated %d pkalg %s\", authenticated, pkalg);\n\n\tsshbuf_free(b);\n\tsshauthopt_free(authopts);\n\tsshkey_free(key);\n\tsshkey_free(hostkey);\n\tfree(userstyle);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(key_s);\n\tfree(ca_s);\n\tfree(sig);\n\tsshkey_sig_details_free(sig_details);\n\treturn authenticated;\n}\n\nstatic int\nmatch_principals_file(struct passwd *pw, char *file,\n    struct sshkey_cert *cert, struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint success;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\ttemporarily_use_uid(pw);\n\tdebug(\"trying authorized principals file %s\", file);\n\tif ((f = auth_openprincipals(file, pw, options.strict_modes)) == NULL) {\n\t\trestore_uid();\n\t\treturn 0;\n\t}\n\tsuccess = auth_process_principals(f, file, cert, authoptsp);\n\tfclose(f);\n\trestore_uid();\n\treturn success;\n}\n\n \nstatic int\nmatch_principals_command(struct passwd *user_pw, const struct sshkey *key,\n    const char *conn_id, const char *rdomain, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tconst struct sshkey_cert *cert = key->cert;\n\tFILE *f = NULL;\n\tint r, ok, found_principal = 0;\n\tint i, ac = 0, uid_swapped = 0;\n\tpid_t pid;\n\tchar *tmp, *username = NULL, *command = NULL, **av = NULL;\n\tchar *ca_fp = NULL, *key_fp = NULL, *catext = NULL, *keytext = NULL;\n\tchar serial_s[32], uidstr[32];\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_principals_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_principals_command_user == NULL) {\n\t\terror(\"No user for AuthorizedPrincipalsCommand specified, \"\n\t\t    \"skipping\");\n\t\treturn 0;\n\t}\n\n\t \n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\n\t \n\tusername = percent_expand(options.authorized_principals_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedPrincipalsCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t \n\tif (argv_split(options.authorized_principals_command,\n\t    &ac, &av, 0) != 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" contains \"\n\t\t    \"invalid quotes\", options.authorized_principals_command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedPrincipalsCommand \\\"%s\\\" yielded no arguments\",\n\t\t    options.authorized_principals_command);\n\t\tgoto out;\n\t}\n\tif ((ca_fp = sshkey_fingerprint(cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror_f(\"sshkey_fingerprint failed\");\n\t\tgoto out;\n\t}\n\tif ((key_fp = sshkey_fingerprint(key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror_f(\"sshkey_fingerprint failed\");\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(cert->signature_key, &catext)) != 0) {\n\t\terror_fr(r, \"sshkey_to_base64 failed\");\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror_fr(r, \"sshkey_to_base64 failed\");\n\t\tgoto out;\n\t}\n\tsnprintf(serial_s, sizeof(serial_s), \"%llu\",\n\t    (unsigned long long)cert->serial);\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"C\", conn_id,\n\t\t    \"D\", rdomain,\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"T\", sshkey_ssh_name(cert->signature_key),\n\t\t    \"f\", key_fp,\n\t\t    \"F\", ca_fp,\n\t\t    \"k\", keytext,\n\t\t    \"K\", catext,\n\t\t    \"i\", cert->key_id,\n\t\t    \"s\", serial_s,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal_f(\"percent_expand failed\");\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t \n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(\"AuthorizedPrincipalsCommand\", command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD,\n\t    runas_pw, temporarily_use_uid, restore_uid)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = auth_process_principals(f, \"(command)\", cert, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedPrincipalsCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t \n\tfound_principal = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tssh_signal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(ca_fp);\n\tfree(key_fp);\n\tfree(catext);\n\tfree(keytext);\n\treturn found_principal;\n}\n\n \nstatic int\nuser_cert_trusted_ca(struct passwd *pw, struct sshkey *key,\n    const char *remote_ip, const char *remote_host,\n    const char *conn_id, const char *rdomain, struct sshauthopt **authoptsp)\n{\n\tchar *ca_fp, *principals_file = NULL;\n\tconst char *reason;\n\tstruct sshauthopt *principals_opts = NULL, *cert_opts = NULL;\n\tstruct sshauthopt *final_opts = NULL;\n\tint r, ret = 0, found_principal = 0, use_authorized_principals;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (!sshkey_is_cert(key) || options.trusted_user_ca_keys == NULL)\n\t\treturn 0;\n\n\tif ((ca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tif ((r = sshkey_in_file(key->cert->signature_key,\n\t    options.trusted_user_ca_keys, 1, 0)) != 0) {\n\t\tdebug2_fr(r, \"CA %s %s is not listed in %s\",\n\t\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t\t    options.trusted_user_ca_keys);\n\t\tgoto out;\n\t}\n\t \n\tif ((principals_file = authorized_principals_file(pw)) != NULL) {\n\t\tif (match_principals_file(pw, principals_file,\n\t\t    key->cert, &principals_opts))\n\t\t\tfound_principal = 1;\n\t}\n\t \n\tif (!found_principal && match_principals_command(pw, key,\n\t    conn_id, rdomain, &principals_opts))\n\t\tfound_principal = 1;\n\t \n\tuse_authorized_principals = principals_file != NULL ||\n\t    options.authorized_principals_command != NULL;\n\tif (!found_principal && use_authorized_principals) {\n\t\treason = \"Certificate does not contain an authorized principal\";\n\t\tgoto fail_reason;\n\t}\n\tif (use_authorized_principals && principals_opts == NULL)\n\t\tfatal_f(\"internal error: missing principals_opts\");\n\tif (sshkey_cert_check_authority_now(key, 0, 1, 0,\n\t    use_authorized_principals ? NULL : pw->pw_name, &reason) != 0)\n\t\tgoto fail_reason;\n\n\t \n\tif ((cert_opts = sshauthopt_from_cert(key)) == NULL) {\n\t\treason = \"Invalid certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (auth_authorise_keyopts(pw, cert_opts, 0,\n\t    remote_ip, remote_host, \"cert\") != 0) {\n\t\treason = \"Refused by certificate options\";\n\t\tgoto fail_reason;\n\t}\n\tif (principals_opts == NULL) {\n\t\tfinal_opts = cert_opts;\n\t\tcert_opts = NULL;\n\t} else {\n\t\tif (auth_authorise_keyopts(pw, principals_opts, 0,\n\t\t    remote_ip, remote_host, \"principals\") != 0) {\n\t\t\treason = \"Refused by certificate principals options\";\n\t\t\tgoto fail_reason;\n\t\t}\n\t\tif ((final_opts = sshauthopt_merge(principals_opts,\n\t\t    cert_opts, &reason)) == NULL) {\n fail_reason:\n\t\t\terror(\"%s\", reason);\n\t\t\tauth_debug_add(\"%s\", reason);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tverbose(\"Accepted certificate ID \\\"%s\\\" (serial %llu) signed by \"\n\t    \"%s CA %s via %s\", key->cert->key_id,\n\t    (unsigned long long)key->cert->serial,\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    options.trusted_user_ca_keys);\n\tif (authoptsp != NULL) {\n\t\t*authoptsp = final_opts;\n\t\tfinal_opts = NULL;\n\t}\n\tret = 1;\n out:\n\tsshauthopt_free(principals_opts);\n\tsshauthopt_free(cert_opts);\n\tsshauthopt_free(final_opts);\n\tfree(principals_file);\n\tfree(ca_fp);\n\treturn ret;\n}\n\n \nstatic int\nuser_key_allowed2(struct passwd *pw, struct sshkey *key,\n    char *file, const char *remote_ip, const char *remote_host,\n    struct sshauthopt **authoptsp)\n{\n\tFILE *f;\n\tint found_key = 0;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\t \n\ttemporarily_use_uid(pw);\n\n\tdebug(\"trying public key file %s\", file);\n\tif ((f = auth_openkeyfile(file, pw, options.strict_modes)) != NULL) {\n\t\tfound_key = auth_check_authkeys_file(pw, f, file,\n\t\t    key, remote_ip, remote_host, authoptsp);\n\t\tfclose(f);\n\t}\n\n\trestore_uid();\n\treturn found_key;\n}\n\n \nstatic int\nuser_key_command_allowed2(struct passwd *user_pw, struct sshkey *key,\n    const char *remote_ip, const char *remote_host,\n    const char *conn_id, const char *rdomain, struct sshauthopt **authoptsp)\n{\n\tstruct passwd *runas_pw = NULL;\n\tFILE *f = NULL;\n\tint r, ok, found_key = 0;\n\tint i, uid_swapped = 0, ac = 0;\n\tpid_t pid;\n\tchar *username = NULL, *key_fp = NULL, *keytext = NULL;\n\tchar uidstr[32], *tmp, *command = NULL, **av = NULL;\n\tvoid (*osigchld)(int);\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\tif (options.authorized_keys_command == NULL)\n\t\treturn 0;\n\tif (options.authorized_keys_command_user == NULL) {\n\t\terror(\"No user for AuthorizedKeysCommand specified, skipping\");\n\t\treturn 0;\n\t}\n\n\t \n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\n\t \n\tusername = percent_expand(options.authorized_keys_command_user,\n\t    \"u\", user_pw->pw_name, (char *)NULL);\n\trunas_pw = getpwnam(username);\n\tif (runas_pw == NULL) {\n\t\terror(\"AuthorizedKeysCommandUser \\\"%s\\\" not found: %s\",\n\t\t    username, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t \n\tif ((key_fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror_f(\"sshkey_fingerprint failed\");\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_base64(key, &keytext)) != 0) {\n\t\terror_fr(r, \"sshkey_to_base64 failed\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (argv_split(options.authorized_keys_command, &ac, &av, 0) != 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" contains invalid quotes\",\n\t\t    options.authorized_keys_command);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"AuthorizedKeysCommand \\\"%s\\\" yielded no arguments\",\n\t\t    options.authorized_keys_command);\n\t\tgoto out;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)user_pw->pw_uid);\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_expand(av[i],\n\t\t    \"C\", conn_id,\n\t\t    \"D\", rdomain,\n\t\t    \"U\", uidstr,\n\t\t    \"u\", user_pw->pw_name,\n\t\t    \"h\", user_pw->pw_dir,\n\t\t    \"t\", sshkey_ssh_name(key),\n\t\t    \"f\", key_fp,\n\t\t    \"k\", keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal_f(\"percent_expand failed\");\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t \n\tcommand = argv_assemble(ac, av);\n\n\t \n\tif (ac == 1) {\n\t\tav = xreallocarray(av, ac + 2, sizeof(*av));\n\t\tav[1] = xstrdup(user_pw->pw_name);\n\t\tav[2] = NULL;\n\t\t \n\t\tfree(command);\n\t\txasprintf(&command, \"%s %s\", av[0], av[1]);\n\t}\n\n\tif ((pid = subprocess(\"AuthorizedKeysCommand\", command,\n\t    ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_STDERR_DISCARD,\n\t    runas_pw, temporarily_use_uid, restore_uid)) == 0)\n\t\tgoto out;\n\n\tuid_swapped = 1;\n\ttemporarily_use_uid(runas_pw);\n\n\tok = auth_check_authkeys_file(user_pw, f,\n\t    options.authorized_keys_command, key, remote_ip,\n\t    remote_host, authoptsp);\n\n\tfclose(f);\n\tf = NULL;\n\n\tif (exited_cleanly(pid, \"AuthorizedKeysCommand\", command, 0) != 0)\n\t\tgoto out;\n\n\t \n\tfound_key = ok;\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tssh_signal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tif (uid_swapped)\n\t\trestore_uid();\n\tfree(command);\n\tfree(username);\n\tfree(key_fp);\n\tfree(keytext);\n\treturn found_key;\n}\n\n \nint\nuser_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success = 0, i;\n\tchar *file, *conn_id;\n\tstruct sshauthopt *opts = NULL;\n\tconst char *rdomain, *remote_ip, *remote_host;\n\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((rdomain = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\trdomain = \"\";\n\tremote_ip = ssh_remote_ipaddr(ssh);\n\tremote_host = auth_get_canonical_hostname(ssh, options.use_dns);\n\txasprintf(&conn_id, \"%s %d %s %d\",\n\t    ssh_local_ipaddr(ssh), ssh_local_port(ssh),\n\t    remote_ip, ssh_remote_port(ssh));\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(pw, key, file,\n\t\t    remote_ip, remote_host, &opts);\n\t\tfree(file);\n\t\tif (!success) {\n\t\t\tsshauthopt_free(opts);\n\t\t\topts = NULL;\n\t\t}\n\t}\n\tif (success)\n\t\tgoto out;\n\n\tif ((success = user_cert_trusted_ca(pw, key, remote_ip, remote_host,\n\t    conn_id, rdomain, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(pw, key, remote_ip,\n\t    remote_host, conn_id, rdomain, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n out:\n\tfree(conn_id);\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}\n\nAuthmethod method_pubkey = {\n\t\"publickey\",\n\t\"publickey-hostbound-v00@openssh.com\",\n\tuserauth_pubkey,\n\t&options.pubkey_authentication\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}