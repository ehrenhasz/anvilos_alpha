{
  "module_name": "ssh-sk-client.c",
  "hash_id": "885253fa1cb1cc77c8a7460e715130e5cf4a4edf95c698378e46b3f74486c433",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-sk-client.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#include <fcntl.h>\n#include <limits.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"log.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"msg.h\"\n#include \"digest.h\"\n#include \"pathnames.h\"\n#include \"ssh-sk.h\"\n#include \"misc.h\"\n\n \n\nstatic int\nstart_helper(int *fdp, pid_t *pidp, void (**osigchldp)(int))\n{\n\tvoid (*osigchld)(int);\n\tint oerrno, pair[2];\n\tpid_t pid;\n\tchar *helper, *verbosity = NULL;\n\n\t*fdp = -1;\n\t*pidp = 0;\n\t*osigchldp = SIG_DFL;\n\n\thelper = getenv(\"SSH_SK_HELPER\");\n\tif (helper == NULL || strlen(helper) == 0)\n\t\thelper = _PATH_SSH_SK_HELPER;\n\tif (access(helper, X_OK) != 0) {\n\t\toerrno = errno;\n\t\terror_f(\"helper \\\"%s\\\" unusable: %s\", helper, strerror(errno));\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n#ifdef DEBUG_SK\n\tverbosity = \"-vvv\";\n#endif\n\n\t \n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {\n\t\terror(\"socketpair: %s\", strerror(errno));\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\tif ((pid = fork()) == -1) {\n\t\toerrno = errno;\n\t\terror(\"fork: %s\", strerror(errno));\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\tssh_signal(SIGCHLD, osigchld);\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (pid == 0) {\n\t\tif ((dup2(pair[1], STDIN_FILENO) == -1) ||\n\t\t    (dup2(pair[1], STDOUT_FILENO) == -1)) {\n\t\t\terror_f(\"dup2: %s\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\tclosefrom(STDERR_FILENO + 1);\n\t\tdebug_f(\"starting %s %s\", helper,\n\t\t    verbosity == NULL ? \"\" : verbosity);\n\t\texeclp(helper, helper, verbosity, (char *)NULL);\n\t\terror_f(\"execlp: %s\", strerror(errno));\n\t\t_exit(1);\n\t}\n\tclose(pair[1]);\n\n\t \n\tdebug3_f(\"started pid=%ld\", (long)pid);\n\t*fdp = pair[0];\n\t*pidp = pid;\n\t*osigchldp = osigchld;\n\treturn 0;\n}\n\nstatic int\nreap_helper(pid_t pid)\n{\n\tint status, oerrno;\n\n\tdebug3_f(\"pid=%ld\", (long)pid);\n\n\terrno = 0;\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno == EINTR) {\n\t\t\terrno = 0;\n\t\t\tcontinue;\n\t\t}\n\t\toerrno = errno;\n\t\terror_f(\"waitpid: %s\", strerror(errno));\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror_f(\"helper exited abnormally\");\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\t} else if (WEXITSTATUS(status) != 0) {\n\t\terror_f(\"helper exited with non-zero exit status\");\n\t\treturn SSH_ERR_AGENT_FAILURE;\n\t}\n\treturn 0;\n}\n\nstatic int\nclient_converse(struct sshbuf *msg, struct sshbuf **respp, u_int type)\n{\n\tint oerrno, fd, r2, ll, r = SSH_ERR_INTERNAL_ERROR;\n\tu_int rtype, rerr;\n\tpid_t pid;\n\tu_char version;\n\tvoid (*osigchld)(int);\n\tstruct sshbuf *req = NULL, *resp = NULL;\n\t*respp = NULL;\n\n\tif ((r = start_helper(&fd, &pid, &osigchld)) != 0)\n\t\treturn r;\n\n\tif ((req = sshbuf_new()) == NULL || (resp = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t \n\tll = log_level_get();\n\tif ((r = sshbuf_put_u32(req, type)) != 0 ||\n\t    (r = sshbuf_put_u8(req, log_is_on_stderr() != 0)) != 0 ||\n\t    (r = sshbuf_put_u32(req, ll < 0 ? 0 : ll)) != 0 ||\n\t    (r = sshbuf_putb(req, msg)) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n\tif ((r = ssh_msg_send(fd, SSH_SK_HELPER_VERSION, req)) != 0) {\n\t\terror_fr(r, \"send\");\n\t\tgoto out;\n\t}\n\tif ((r = ssh_msg_recv(fd, resp)) != 0) {\n\t\terror_fr(r, \"receive\");\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u8(resp, &version)) != 0) {\n\t\terror_fr(r, \"parse version\");\n\t\tgoto out;\n\t}\n\tif (version != SSH_SK_HELPER_VERSION) {\n\t\terror_f(\"unsupported version: got %u, expected %u\",\n\t\t    version, SSH_SK_HELPER_VERSION);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u32(resp, &rtype)) != 0) {\n\t\terror_fr(r, \"parse message type\");\n\t\tgoto out;\n\t}\n\tif (rtype == SSH_SK_HELPER_ERROR) {\n\t\tif ((r = sshbuf_get_u32(resp, &rerr)) != 0) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\tgoto out;\n\t\t}\n\t\tdebug_f(\"helper returned error -%u\", rerr);\n\t\t \n\t\tif (rerr == 0 || rerr >= INT_MAX)\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\telse\n\t\t\tr = -(int)rerr;\n\t\tgoto out;\n\t} else if (rtype != type) {\n\t\terror_f(\"helper returned incorrect message type %u, \"\n\t\t    \"expecting %u\", rtype, type);\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\toerrno = errno;\n\tclose(fd);\n\tif ((r2 = reap_helper(pid)) != 0) {\n\t\tif (r == 0) {\n\t\t\tr = r2;\n\t\t\toerrno = errno;\n\t\t}\n\t}\n\tif (r == 0) {\n\t\t*respp = resp;\n\t\tresp = NULL;\n\t}\n\tsshbuf_free(req);\n\tsshbuf_free(resp);\n\tssh_signal(SIGCHLD, osigchld);\n\terrno = oerrno;\n\treturn r;\n\n}\n\nint\nsshsk_sign(const char *provider, struct sshkey *key,\n    u_char **sigp, size_t *lenp, const u_char *data, size_t datalen,\n    u_int compat, const char *pin)\n{\n\tint oerrno, r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *kbuf = NULL, *req = NULL, *resp = NULL;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n#ifndef ENABLE_SK\n\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n#endif\n\n\tif ((kbuf = sshbuf_new()) == NULL ||\n\t    (req = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_private_serialize(key, kbuf)) != 0) {\n\t\terror_fr(r, \"encode key\");\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_stringb(req, kbuf)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, provider)) != 0 ||\n\t    (r = sshbuf_put_string(req, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, NULL)) != 0 ||  \n\t    (r = sshbuf_put_u32(req, compat)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, pin)) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n\n\tif ((r = client_converse(req, &resp, SSH_SK_HELPER_SIGN)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_get_string(resp, sigp, lenp)) != 0) {\n\t\terror_fr(r, \"parse signature\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(resp) != 0) {\n\t\terror_f(\"trailing data in response\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\toerrno = errno;\n\tif (r != 0) {\n\t\tfreezero(*sigp, *lenp);\n\t\t*sigp = NULL;\n\t\t*lenp = 0;\n\t}\n\tsshbuf_free(kbuf);\n\tsshbuf_free(req);\n\tsshbuf_free(resp);\n\terrno = oerrno;\n\treturn r;\n}\n\nint\nsshsk_enroll(int type, const char *provider_path, const char *device,\n    const char *application, const char *userid, uint8_t flags,\n    const char *pin, struct sshbuf *challenge_buf,\n    struct sshkey **keyp, struct sshbuf *attest)\n{\n\tint oerrno, r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *kbuf = NULL, *abuf = NULL, *req = NULL, *resp = NULL;\n\tstruct sshkey *key = NULL;\n\n\t*keyp = NULL;\n\tif (attest != NULL)\n\t\tsshbuf_reset(attest);\n\n#ifndef ENABLE_SK\n\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n#endif\n\n\tif (type < 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((abuf = sshbuf_new()) == NULL ||\n\t    (kbuf = sshbuf_new()) == NULL ||\n\t    (req = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_put_u32(req, (u_int)type)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, provider_path)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, device)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, application)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, userid)) != 0 ||\n\t    (r = sshbuf_put_u8(req, flags)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, pin)) != 0 ||\n\t    (r = sshbuf_put_stringb(req, challenge_buf)) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n\n\tif ((r = client_converse(req, &resp, SSH_SK_HELPER_ENROLL)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_get_stringb(resp, kbuf)) != 0 ||\n\t    (r = sshbuf_get_stringb(resp, abuf)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(resp) != 0) {\n\t\terror_f(\"trailing data in response\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_private_deserialize(kbuf, &key)) != 0) {\n\t\terror_fr(r, \"encode\");\n\t\tgoto out;\n\t}\n\tif (attest != NULL && (r = sshbuf_putb(attest, abuf)) != 0) {\n\t\terror_fr(r, \"encode attestation information\");\n\t\tgoto out;\n\t}\n\n\t \n\tr = 0;\n\t*keyp = key;\n\tkey = NULL;\n out:\n\toerrno = errno;\n\tsshkey_free(key);\n\tsshbuf_free(kbuf);\n\tsshbuf_free(abuf);\n\tsshbuf_free(req);\n\tsshbuf_free(resp);\n\terrno = oerrno;\n\treturn r;\n}\n\nstatic void\nsshsk_free_resident_key(struct sshsk_resident_key *srk)\n{\n\tif (srk == NULL)\n\t\treturn;\n\tsshkey_free(srk->key);\n\tfreezero(srk->user_id, srk->user_id_len);\n\tfree(srk);\n}\n\n\nvoid\nsshsk_free_resident_keys(struct sshsk_resident_key **srks, size_t nsrks)\n{\n\tsize_t i;\n\n\tif (srks == NULL || nsrks == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nsrks; i++)\n\t\tsshsk_free_resident_key(srks[i]);\n\tfree(srks);\n}\n\nint\nsshsk_load_resident(const char *provider_path, const char *device,\n    const char *pin, u_int flags, struct sshsk_resident_key ***srksp,\n    size_t *nsrksp)\n{\n\tint oerrno, r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *kbuf = NULL, *req = NULL, *resp = NULL;\n\tstruct sshkey *key = NULL;\n\tstruct sshsk_resident_key *srk = NULL, **srks = NULL, **tmp;\n\tu_char *userid = NULL;\n\tsize_t userid_len = 0, nsrks = 0;\n\n\t*srksp = NULL;\n\t*nsrksp = 0;\n\n\tif ((kbuf = sshbuf_new()) == NULL ||\n\t    (req = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_put_cstring(req, provider_path)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, device)) != 0 ||\n\t    (r = sshbuf_put_cstring(req, pin)) != 0 ||\n\t    (r = sshbuf_put_u32(req, flags)) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n\n\tif ((r = client_converse(req, &resp, SSH_SK_HELPER_LOAD_RESIDENT)) != 0)\n\t\tgoto out;\n\n\twhile (sshbuf_len(resp) != 0) {\n\t\t \n\t\tif ((r = sshbuf_get_stringb(resp, kbuf)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(resp, NULL, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(resp, &userid, &userid_len)) != 0) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_private_deserialize(kbuf, &key)) != 0) {\n\t\t\terror_fr(r, \"decode key\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((srk = calloc(1, sizeof(*srk))) == NULL) {\n\t\t\terror_f(\"calloc failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tsrk->key = key;\n\t\tkey = NULL;\n\t\tsrk->user_id = userid;\n\t\tsrk->user_id_len = userid_len;\n\t\tuserid = NULL;\n\t\tuserid_len = 0;\n\t\tif ((tmp = recallocarray(srks, nsrks, nsrks + 1,\n\t\t    sizeof(*srks))) == NULL) {\n\t\t\terror_f(\"recallocarray keys failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tdebug_f(\"srks[%zu]: %s %s uidlen %zu\", nsrks,\n\t\t    sshkey_type(srk->key), srk->key->sk_application,\n\t\t    srk->user_id_len);\n\t\tsrks = tmp;\n\t\tsrks[nsrks++] = srk;\n\t\tsrk = NULL;\n\t}\n\n\t \n\tr = 0;\n\t*srksp = srks;\n\t*nsrksp = nsrks;\n\tsrks = NULL;\n\tnsrks = 0;\n out:\n\toerrno = errno;\n\tsshsk_free_resident_key(srk);\n\tsshsk_free_resident_keys(srks, nsrks);\n\tfreezero(userid, userid_len);\n\tsshkey_free(key);\n\tsshbuf_free(kbuf);\n\tsshbuf_free(req);\n\tsshbuf_free(resp);\n\terrno = oerrno;\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}