{
  "module_name": "servconf.c",
  "hash_id": "f204d9ccbc980983f512a1169b25f39c438b06eeaa0721c2e99b0f29c076e07f",
  "original_prompt": "Ingested from openssh-9.6p1/servconf.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#ifdef __OpenBSD__\n#include <sys/sysctl.h>\n#endif\n\n#include <netinet/in.h>\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#ifdef HAVE_NET_ROUTE_H\n#include <net/route.h>\n#endif\n\n#include <ctype.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <errno.h>\n#ifdef HAVE_UTIL_H\n#include <util.h>\n#endif\n#ifdef USE_SYSTEM_GLOB\n# include <glob.h>\n#else\n# include \"openbsd-compat/glob.h\"\n#endif\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"pathnames.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"mac.h\"\n#include \"match.h\"\n#include \"channels.h\"\n#include \"groupaccess.h\"\n#include \"canohost.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"myproposal.h\"\n#include \"digest.h\"\n\nstatic void add_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void add_one_listen_addr(ServerOptions *, const char *,\n    const char *, int);\nstatic void parse_server_config_depth(ServerOptions *options,\n    const char *filename, struct sshbuf *conf, struct include_list *includes,\n    struct connection_info *connectinfo, int flags, int *activep, int depth);\n\n \nextern int use_privsep;\nextern struct sshbuf *cfg;\n\n \n\nvoid\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\n\t \n\toptions->use_pam = -1;\n\n\t \n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->num_listen_addrs = 0;\n\toptions->address_family = -1;\n\toptions->routing_domain = NULL;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->num_log_verbose = 0;\n\toptions->log_verbose = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_accepted_algos = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_auth_options = -1;\n\toptions->pubkey_accepted_algos = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->permit_user_env_allowlist = NULL;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->per_source_max_startups = -1;\n\toptions->per_source_masklen_ipv4 = -1;\n\toptions->per_source_masklen_ipv6 = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->num_setenv = 0;\n\toptions->permit_tun = -1;\n\toptions->permitted_opens = NULL;\n\toptions->permitted_listens = NULL;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->sk_provider = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->disable_forwarding = -1;\n\toptions->expose_userauth_info = -1;\n\toptions->required_rsa_size = -1;\n\toptions->channel_timeouts = NULL;\n\toptions->num_channel_timeouts = 0;\n\toptions->unused_connection_timeout = -1;\n}\n\n \nstatic int\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}\n\nstatic void\nassemble_algorithms(ServerOptions *o)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tchar *def_cipher, *def_mac, *def_kex, *def_key, *def_sig;\n\tint r;\n\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n\t \n\tdef_cipher = match_filter_allowlist(KEX_SERVER_ENCRYPT, all_cipher);\n\tdef_mac = match_filter_allowlist(KEX_SERVER_MAC, all_mac);\n\tdef_kex = match_filter_allowlist(KEX_SERVER_KEX, all_kex);\n\tdef_key = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\tdef_sig = match_filter_allowlist(SSH_ALLOWED_CA_SIGALGS, all_sig);\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&o->what, defaults, all)) != 0) \\\n\t\t\tfatal_fr(r, \"%s\", #what); \\\n\t} while (0)\n\tASSEMBLE(ciphers, def_cipher, all_cipher);\n\tASSEMBLE(macs, def_mac, all_mac);\n\tASSEMBLE(kex_algorithms, def_kex, all_kex);\n\tASSEMBLE(hostkeyalgorithms, def_key, all_key);\n\tASSEMBLE(hostbased_accepted_algos, def_key, all_key);\n\tASSEMBLE(pubkey_accepted_algos, def_key, all_key);\n\tASSEMBLE(ca_sign_algorithms, def_sig, all_sig);\n#undef ASSEMBLE\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\tfree(def_cipher);\n\tfree(def_mac);\n\tfree(def_kex);\n\tfree(def_key);\n\tfree(def_sig);\n}\n\nvoid\nservconf_add_hostkey(const char *file, const int line,\n    ServerOptions *options, const char *path, int userprovided)\n{\n\tchar *apath = derelativise_path(path);\n\n\topt_array_append2(file, line, \"HostKey\",\n\t    &options->host_key_files, &options->host_key_file_userprovided,\n\t    &options->num_host_key_files, apath, userprovided);\n\tfree(apath);\n}\n\nvoid\nservconf_add_hostcert(const char *file, const int line,\n    ServerOptions *options, const char *path)\n{\n\tchar *apath = derelativise_path(path);\n\n\topt_array_append(file, line, \"HostCertificate\",\n\t    &options->host_cert_files, &options->num_host_cert_files, apath);\n\tfree(apath);\n}\n\nvoid\nfill_default_server_options(ServerOptions *options)\n{\n\tu_int i;\n\n\t \n\tif (options->use_pam == -1)\n\t\toptions->use_pam = 0;\n\n\t \n\tif (options->num_host_key_files == 0) {\n\t\t \n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_RSA_KEY_FILE, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ECDSA_KEY_FILE, 0);\n#endif\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_ED25519_KEY_FILE, 0);\n#ifdef WITH_XMSS\n\t\tservconf_add_hostkey(\"[default]\", 0, options,\n\t\t    _PATH_HOST_XMSS_KEY_FILE, 0);\n#endif  \n\t}\n\t \n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->listen_addrs == NULL)\n\t\tadd_listen_addr(options, NULL, NULL, 0);\n\tif (options->pid_file == NULL)\n\t\toptions->pid_file = xstrdup(_PATH_SSH_DAEMON_PID_FILE);\n\tif (options->moduli_file == NULL)\n\t\toptions->moduli_file = xstrdup(_PATH_DH_MODULI);\n\tif (options->login_grace_time == -1)\n\t\toptions->login_grace_time = 120;\n\tif (options->permit_root_login == PERMIT_NOT_SET)\n\t\toptions->permit_root_login = PERMIT_NO_PASSWD;\n\tif (options->ignore_rhosts == -1)\n\t\toptions->ignore_rhosts = 1;\n\tif (options->ignore_user_known_hosts == -1)\n\t\toptions->ignore_user_known_hosts = 0;\n\tif (options->print_motd == -1)\n\t\toptions->print_motd = 1;\n\tif (options->print_lastlog == -1)\n\t\toptions->print_lastlog = 1;\n\tif (options->x11_forwarding == -1)\n\t\toptions->x11_forwarding = 0;\n\tif (options->x11_display_offset == -1)\n\t\toptions->x11_display_offset = 10;\n\tif (options->x11_use_localhost == -1)\n\t\toptions->x11_use_localhost = 1;\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->permit_tty == -1)\n\t\toptions->permit_tty = 1;\n\tif (options->permit_user_rc == -1)\n\t\toptions->permit_user_rc = 1;\n\tif (options->strict_modes == -1)\n\t\toptions->strict_modes = 1;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_AUTH;\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->hostbased_uses_name_from_packet_only == -1)\n\t\toptions->hostbased_uses_name_from_packet_only = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->pubkey_auth_options == -1)\n\t\toptions->pubkey_auth_options = 0;\n\tif (options->kerberos_authentication == -1)\n\t\toptions->kerberos_authentication = 0;\n\tif (options->kerberos_or_local_passwd == -1)\n\t\toptions->kerberos_or_local_passwd = 1;\n\tif (options->kerberos_ticket_cleanup == -1)\n\t\toptions->kerberos_ticket_cleanup = 1;\n\tif (options->kerberos_get_afs_token == -1)\n\t\toptions->kerberos_get_afs_token = 0;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_cleanup_creds == -1)\n\t\toptions->gss_cleanup_creds = 1;\n\tif (options->gss_strict_acceptor == -1)\n\t\toptions->gss_strict_acceptor = 1;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->permit_empty_passwd == -1)\n\t\toptions->permit_empty_passwd = 0;\n\tif (options->permit_user_env == -1) {\n\t\toptions->permit_user_env = 0;\n\t\toptions->permit_user_env_allowlist = NULL;\n\t}\n\tif (options->compression == -1)\n#ifdef WITH_ZLIB\n\t\toptions->compression = COMP_DELAYED;\n#else\n\t\toptions->compression = COMP_NONE;\n#endif\n\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->allow_tcp_forwarding == -1)\n\t\toptions->allow_tcp_forwarding = FORWARD_ALLOW;\n\tif (options->allow_streamlocal_forwarding == -1)\n\t\toptions->allow_streamlocal_forwarding = FORWARD_ALLOW;\n\tif (options->allow_agent_forwarding == -1)\n\t\toptions->allow_agent_forwarding = 1;\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->max_startups == -1)\n\t\toptions->max_startups = 100;\n\tif (options->max_startups_rate == -1)\n\t\toptions->max_startups_rate = 30;\t\t \n\tif (options->max_startups_begin == -1)\n\t\toptions->max_startups_begin = 10;\n\tif (options->per_source_max_startups == -1)\n\t\toptions->per_source_max_startups = INT_MAX;\n\tif (options->per_source_masklen_ipv4 == -1)\n\t\toptions->per_source_masklen_ipv4 = 32;\n\tif (options->per_source_masklen_ipv6 == -1)\n\t\toptions->per_source_masklen_ipv6 = 128;\n\tif (options->max_authtries == -1)\n\t\toptions->max_authtries = DEFAULT_AUTH_FAIL_MAX;\n\tif (options->max_sessions == -1)\n\t\toptions->max_sessions = DEFAULT_SESSIONS_MAX;\n\tif (options->use_dns == -1)\n\t\toptions->use_dns = 0;\n\tif (options->client_alive_interval == -1)\n\t\toptions->client_alive_interval = 0;\n\tif (options->client_alive_count_max == -1)\n\t\toptions->client_alive_count_max = 3;\n\tif (options->num_authkeys_files == 0) {\n\t\topt_array_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS);\n\t\topt_array_append(\"[default]\", 0, \"AuthorizedKeysFiles\",\n\t\t    &options->authorized_keys_files,\n\t\t    &options->num_authkeys_files,\n\t\t    _PATH_SSH_USER_PERMITTED_KEYS2);\n\t}\n\tif (options->permit_tun == -1)\n\t\toptions->permit_tun = SSH_TUNMODE_NO;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->version_addendum == NULL)\n\t\toptions->version_addendum = xstrdup(\"\");\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\tif (options->disable_forwarding == -1)\n\t\toptions->disable_forwarding = 0;\n\tif (options->expose_userauth_info == -1)\n\t\toptions->expose_userauth_info = 0;\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"internal\");\n\tif (options->required_rsa_size == -1)\n\t\toptions->required_rsa_size = SSH_RSA_MINIMUM_MODULUS_SIZE;\n\tif (options->unused_connection_timeout == -1)\n\t\toptions->unused_connection_timeout = 0;\n\n\tassemble_algorithms(options);\n\n\t \n\tif (use_privsep == -1)\n\t\tuse_privsep = PRIVSEP_ON;\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n#define CLEAR_ON_NONE_ARRAY(v, nv, none) \\\n\tdo { \\\n\t\tif (options->nv == 1 && \\\n\t\t    strcasecmp(options->v[0], none) == 0) { \\\n\t\t\tfree(options->v[0]); \\\n\t\t\tfree(options->v); \\\n\t\t\toptions->v = NULL; \\\n\t\t\toptions->nv = 0; \\\n\t\t} \\\n\t} while (0)\n\tCLEAR_ON_NONE(options->pid_file);\n\tCLEAR_ON_NONE(options->xauth_location);\n\tCLEAR_ON_NONE(options->banner);\n\tCLEAR_ON_NONE(options->trusted_user_ca_keys);\n\tCLEAR_ON_NONE(options->revoked_keys_file);\n\tCLEAR_ON_NONE(options->sk_provider);\n\tCLEAR_ON_NONE(options->authorized_principals_file);\n\tCLEAR_ON_NONE(options->adm_forced_command);\n\tCLEAR_ON_NONE(options->chroot_directory);\n\tCLEAR_ON_NONE(options->routing_domain);\n\tCLEAR_ON_NONE(options->host_key_agent);\n\n\tfor (i = 0; i < options->num_host_key_files; i++)\n\t\tCLEAR_ON_NONE(options->host_key_files[i]);\n\tfor (i = 0; i < options->num_host_cert_files; i++)\n\t\tCLEAR_ON_NONE(options->host_cert_files[i]);\n\n\tCLEAR_ON_NONE_ARRAY(channel_timeouts, num_channel_timeouts, \"none\");\n\tCLEAR_ON_NONE_ARRAY(auth_methods, num_auth_methods, \"any\");\n#undef CLEAR_ON_NONE\n#undef CLEAR_ON_NONE_ARRAY\n}\n\n \ntypedef enum {\n\tsBadOption,\t\t \n\t \n\tsUsePAM,\n\t \n\tsPort, sHostKeyFile, sLoginGraceTime,\n\tsPermitRootLogin, sLogFacility, sLogLevel, sLogVerbose,\n\tsKerberosAuthentication, sKerberosOrLocalPasswd, sKerberosTicketCleanup,\n\tsKerberosGetAFSToken, sPasswordAuthentication,\n\tsKbdInteractiveAuthentication, sListenAddress, sAddressFamily,\n\tsPrintMotd, sPrintLastLog, sIgnoreRhosts,\n\tsX11Forwarding, sX11DisplayOffset, sX11UseLocalhost,\n\tsPermitTTY, sStrictModes, sEmptyPasswd, sTCPKeepAlive,\n\tsPermitUserEnvironment, sAllowTcpForwarding, sCompression,\n\tsRekeyLimit, sAllowUsers, sDenyUsers, sAllowGroups, sDenyGroups,\n\tsIgnoreUserKnownHosts, sCiphers, sMacs, sPidFile, sModuliFile,\n\tsGatewayPorts, sPubkeyAuthentication, sPubkeyAcceptedAlgorithms,\n\tsXAuthLocation, sSubsystem, sMaxStartups, sMaxAuthTries, sMaxSessions,\n\tsBanner, sUseDNS, sHostbasedAuthentication,\n\tsHostbasedUsesNameFromPacketOnly, sHostbasedAcceptedAlgorithms,\n\tsHostKeyAlgorithms, sPerSourceMaxStartups, sPerSourceNetBlockSize,\n\tsClientAliveInterval, sClientAliveCountMax, sAuthorizedKeysFile,\n\tsGssAuthentication, sGssCleanupCreds, sGssStrictAcceptor,\n\tsAcceptEnv, sSetEnv, sPermitTunnel,\n\tsMatch, sPermitOpen, sPermitListen, sForceCommand, sChrootDirectory,\n\tsUsePrivilegeSeparation, sAllowAgentForwarding,\n\tsHostCertificate, sInclude,\n\tsRevokedKeys, sTrustedUserCAKeys, sAuthorizedPrincipalsFile,\n\tsAuthorizedPrincipalsCommand, sAuthorizedPrincipalsCommandUser,\n\tsKexAlgorithms, sCASignatureAlgorithms, sIPQoS, sVersionAddendum,\n\tsAuthorizedKeysCommand, sAuthorizedKeysCommandUser,\n\tsAuthenticationMethods, sHostKeyAgent, sPermitUserRC,\n\tsStreamLocalBindMask, sStreamLocalBindUnlink,\n\tsAllowStreamLocalForwarding, sFingerprintHash, sDisableForwarding,\n\tsExposeAuthInfo, sRDomain, sPubkeyAuthOptions, sSecurityKeyProvider,\n\tsRequiredRSASize, sChannelTimeout, sUnusedConnectionTimeout,\n\tsDeprecated, sIgnore, sUnsupported\n} ServerOpCodes;\n\n#define SSHCFG_GLOBAL\t\t0x01\t \n#define SSHCFG_MATCH\t\t0x02\t \n#define SSHCFG_ALL\t\t(SSHCFG_GLOBAL|SSHCFG_MATCH)\n#define SSHCFG_NEVERMATCH\t0x04   \n#define SSHCFG_MATCH_ONLY\t0x08   \n\n \nstatic struct {\n\tconst char *name;\n\tServerOpCodes opcode;\n\tu_int flags;\n} keywords[] = {\n\t \n#ifdef USE_PAM\n\t{ \"usepam\", sUsePAM, SSHCFG_GLOBAL },\n#else\n\t{ \"usepam\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"pamauthenticationviakbdint\", sDeprecated, SSHCFG_GLOBAL },\n\t \n\t{ \"port\", sPort, SSHCFG_GLOBAL },\n\t{ \"hostkey\", sHostKeyFile, SSHCFG_GLOBAL },\n\t{ \"hostdsakey\", sHostKeyFile, SSHCFG_GLOBAL },\t\t \n\t{ \"hostkeyagent\", sHostKeyAgent, SSHCFG_GLOBAL },\n\t{ \"pidfile\", sPidFile, SSHCFG_GLOBAL },\n\t{ \"modulifile\", sModuliFile, SSHCFG_GLOBAL },\n\t{ \"serverkeybits\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"logingracetime\", sLoginGraceTime, SSHCFG_GLOBAL },\n\t{ \"keyregenerationinterval\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"permitrootlogin\", sPermitRootLogin, SSHCFG_ALL },\n\t{ \"syslogfacility\", sLogFacility, SSHCFG_GLOBAL },\n\t{ \"loglevel\", sLogLevel, SSHCFG_ALL },\n\t{ \"logverbose\", sLogVerbose, SSHCFG_ALL },\n\t{ \"rhostsauthentication\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"rhostsrsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"hostbasedauthentication\", sHostbasedAuthentication, SSHCFG_ALL },\n\t{ \"hostbasedusesnamefrompacketonly\", sHostbasedUsesNameFromPacketOnly, SSHCFG_ALL },\n\t{ \"hostbasedacceptedalgorithms\", sHostbasedAcceptedAlgorithms, SSHCFG_ALL },\n\t{ \"hostbasedacceptedkeytypes\", sHostbasedAcceptedAlgorithms, SSHCFG_ALL },  \n\t{ \"hostkeyalgorithms\", sHostKeyAlgorithms, SSHCFG_GLOBAL },\n\t{ \"rsaauthentication\", sDeprecated, SSHCFG_ALL },\n\t{ \"pubkeyauthentication\", sPubkeyAuthentication, SSHCFG_ALL },\n\t{ \"pubkeyacceptedalgorithms\", sPubkeyAcceptedAlgorithms, SSHCFG_ALL },\n\t{ \"pubkeyacceptedkeytypes\", sPubkeyAcceptedAlgorithms, SSHCFG_ALL },  \n\t{ \"pubkeyauthoptions\", sPubkeyAuthOptions, SSHCFG_ALL },\n\t{ \"dsaauthentication\", sPubkeyAuthentication, SSHCFG_GLOBAL },  \n#ifdef KRB5\n\t{ \"kerberosauthentication\", sKerberosAuthentication, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sKerberosOrLocalPasswd, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sKerberosTicketCleanup, SSHCFG_GLOBAL },\n#ifdef USE_AFS\n\t{ \"kerberosgetafstoken\", sKerberosGetAFSToken, SSHCFG_GLOBAL },\n#else\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n#else\n\t{ \"kerberosauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"kerberosorlocalpasswd\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosticketcleanup\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"kerberosgetafstoken\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"kerberostgtpassing\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"afstokenpassing\", sUnsupported, SSHCFG_GLOBAL },\n#ifdef GSSAPI\n\t{ \"gssapiauthentication\", sGssAuthentication, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sGssCleanupCreds, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sGssStrictAcceptor, SSHCFG_GLOBAL },\n#else\n\t{ \"gssapiauthentication\", sUnsupported, SSHCFG_ALL },\n\t{ \"gssapicleanupcredentials\", sUnsupported, SSHCFG_GLOBAL },\n\t{ \"gssapistrictacceptorcheck\", sUnsupported, SSHCFG_GLOBAL },\n#endif\n\t{ \"passwordauthentication\", sPasswordAuthentication, SSHCFG_ALL },\n\t{ \"kbdinteractiveauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },\n\t{ \"challengeresponseauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },  \n\t{ \"skeyauthentication\", sKbdInteractiveAuthentication, SSHCFG_ALL },  \n\t{ \"checkmail\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"listenaddress\", sListenAddress, SSHCFG_GLOBAL },\n\t{ \"addressfamily\", sAddressFamily, SSHCFG_GLOBAL },\n\t{ \"printmotd\", sPrintMotd, SSHCFG_GLOBAL },\n#ifdef DISABLE_LASTLOG\n\t{ \"printlastlog\", sUnsupported, SSHCFG_GLOBAL },\n#else\n\t{ \"printlastlog\", sPrintLastLog, SSHCFG_GLOBAL },\n#endif\n\t{ \"ignorerhosts\", sIgnoreRhosts, SSHCFG_ALL },\n\t{ \"ignoreuserknownhosts\", sIgnoreUserKnownHosts, SSHCFG_GLOBAL },\n\t{ \"x11forwarding\", sX11Forwarding, SSHCFG_ALL },\n\t{ \"x11displayoffset\", sX11DisplayOffset, SSHCFG_ALL },\n\t{ \"x11uselocalhost\", sX11UseLocalhost, SSHCFG_ALL },\n\t{ \"xauthlocation\", sXAuthLocation, SSHCFG_GLOBAL },\n\t{ \"strictmodes\", sStrictModes, SSHCFG_GLOBAL },\n\t{ \"permitemptypasswords\", sEmptyPasswd, SSHCFG_ALL },\n\t{ \"permituserenvironment\", sPermitUserEnvironment, SSHCFG_GLOBAL },\n\t{ \"uselogin\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"compression\", sCompression, SSHCFG_GLOBAL },\n\t{ \"rekeylimit\", sRekeyLimit, SSHCFG_ALL },\n\t{ \"tcpkeepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\n\t{ \"keepalive\", sTCPKeepAlive, SSHCFG_GLOBAL },\t \n\t{ \"allowtcpforwarding\", sAllowTcpForwarding, SSHCFG_ALL },\n\t{ \"allowagentforwarding\", sAllowAgentForwarding, SSHCFG_ALL },\n\t{ \"allowusers\", sAllowUsers, SSHCFG_ALL },\n\t{ \"denyusers\", sDenyUsers, SSHCFG_ALL },\n\t{ \"allowgroups\", sAllowGroups, SSHCFG_ALL },\n\t{ \"denygroups\", sDenyGroups, SSHCFG_ALL },\n\t{ \"ciphers\", sCiphers, SSHCFG_GLOBAL },\n\t{ \"macs\", sMacs, SSHCFG_GLOBAL },\n\t{ \"protocol\", sIgnore, SSHCFG_GLOBAL },\n\t{ \"gatewayports\", sGatewayPorts, SSHCFG_ALL },\n\t{ \"subsystem\", sSubsystem, SSHCFG_ALL },\n\t{ \"maxstartups\", sMaxStartups, SSHCFG_GLOBAL },\n\t{ \"persourcemaxstartups\", sPerSourceMaxStartups, SSHCFG_GLOBAL },\n\t{ \"persourcenetblocksize\", sPerSourceNetBlockSize, SSHCFG_GLOBAL },\n\t{ \"maxauthtries\", sMaxAuthTries, SSHCFG_ALL },\n\t{ \"maxsessions\", sMaxSessions, SSHCFG_ALL },\n\t{ \"banner\", sBanner, SSHCFG_ALL },\n\t{ \"usedns\", sUseDNS, SSHCFG_GLOBAL },\n\t{ \"verifyreversemapping\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"reversemappingcheck\", sDeprecated, SSHCFG_GLOBAL },\n\t{ \"clientaliveinterval\", sClientAliveInterval, SSHCFG_ALL },\n\t{ \"clientalivecountmax\", sClientAliveCountMax, SSHCFG_ALL },\n\t{ \"authorizedkeysfile\", sAuthorizedKeysFile, SSHCFG_ALL },\n\t{ \"authorizedkeysfile2\", sDeprecated, SSHCFG_ALL },\n\t{ \"useprivilegeseparation\", sDeprecated, SSHCFG_GLOBAL},\n\t{ \"acceptenv\", sAcceptEnv, SSHCFG_ALL },\n\t{ \"setenv\", sSetEnv, SSHCFG_ALL },\n\t{ \"permittunnel\", sPermitTunnel, SSHCFG_ALL },\n\t{ \"permittty\", sPermitTTY, SSHCFG_ALL },\n\t{ \"permituserrc\", sPermitUserRC, SSHCFG_ALL },\n\t{ \"match\", sMatch, SSHCFG_ALL },\n\t{ \"permitopen\", sPermitOpen, SSHCFG_ALL },\n\t{ \"permitlisten\", sPermitListen, SSHCFG_ALL },\n\t{ \"forcecommand\", sForceCommand, SSHCFG_ALL },\n\t{ \"chrootdirectory\", sChrootDirectory, SSHCFG_ALL },\n\t{ \"hostcertificate\", sHostCertificate, SSHCFG_GLOBAL },\n\t{ \"revokedkeys\", sRevokedKeys, SSHCFG_ALL },\n\t{ \"trustedusercakeys\", sTrustedUserCAKeys, SSHCFG_ALL },\n\t{ \"authorizedprincipalsfile\", sAuthorizedPrincipalsFile, SSHCFG_ALL },\n\t{ \"kexalgorithms\", sKexAlgorithms, SSHCFG_GLOBAL },\n\t{ \"include\", sInclude, SSHCFG_ALL },\n\t{ \"ipqos\", sIPQoS, SSHCFG_ALL },\n\t{ \"authorizedkeyscommand\", sAuthorizedKeysCommand, SSHCFG_ALL },\n\t{ \"authorizedkeyscommanduser\", sAuthorizedKeysCommandUser, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommand\", sAuthorizedPrincipalsCommand, SSHCFG_ALL },\n\t{ \"authorizedprincipalscommanduser\", sAuthorizedPrincipalsCommandUser, SSHCFG_ALL },\n\t{ \"versionaddendum\", sVersionAddendum, SSHCFG_GLOBAL },\n\t{ \"authenticationmethods\", sAuthenticationMethods, SSHCFG_ALL },\n\t{ \"streamlocalbindmask\", sStreamLocalBindMask, SSHCFG_ALL },\n\t{ \"streamlocalbindunlink\", sStreamLocalBindUnlink, SSHCFG_ALL },\n\t{ \"allowstreamlocalforwarding\", sAllowStreamLocalForwarding, SSHCFG_ALL },\n\t{ \"fingerprinthash\", sFingerprintHash, SSHCFG_GLOBAL },\n\t{ \"disableforwarding\", sDisableForwarding, SSHCFG_ALL },\n\t{ \"exposeauthinfo\", sExposeAuthInfo, SSHCFG_ALL },\n\t{ \"rdomain\", sRDomain, SSHCFG_ALL },\n\t{ \"casignaturealgorithms\", sCASignatureAlgorithms, SSHCFG_ALL },\n\t{ \"securitykeyprovider\", sSecurityKeyProvider, SSHCFG_GLOBAL },\n\t{ \"requiredrsasize\", sRequiredRSASize, SSHCFG_ALL },\n\t{ \"channeltimeout\", sChannelTimeout, SSHCFG_ALL },\n\t{ \"unusedconnectiontimeout\", sUnusedConnectionTimeout, SSHCFG_ALL },\n\t{ NULL, sBadOption, 0 }\n};\n\nstatic struct {\n\tint val;\n\tchar *text;\n} tunmode_desc[] = {\n\t{ SSH_TUNMODE_NO, \"no\" },\n\t{ SSH_TUNMODE_POINTOPOINT, \"point-to-point\" },\n\t{ SSH_TUNMODE_ETHERNET, \"ethernet\" },\n\t{ SSH_TUNMODE_YES, \"yes\" },\n\t{ -1, NULL }\n};\n\n \n\nstatic const char *\nlookup_opcode_name(ServerOpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}\n\n\n \n\nstatic ServerOpCodes\nparse_token(const char *cp, const char *filename,\n\t    int linenum, u_int *flags)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcasecmp(cp, keywords[i].name) == 0) {\n\t\t\t*flags = keywords[i].flags;\n\t\t\treturn keywords[i].opcode;\n\t\t}\n\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn sBadOption;\n}\n\nchar *\nderelativise_path(const char *path)\n{\n\tchar *expanded, *ret, cwd[PATH_MAX];\n\n\tif (strcasecmp(path, \"none\") == 0)\n\t\treturn xstrdup(\"none\");\n\texpanded = tilde_expand_filename(path, getuid());\n\tif (path_absolute(expanded))\n\t\treturn expanded;\n\tif (getcwd(cwd, sizeof(cwd)) == NULL)\n\t\tfatal_f(\"getcwd: %s\", strerror(errno));\n\txasprintf(&ret, \"%s/%s\", cwd, expanded);\n\tfree(expanded);\n\treturn ret;\n}\n\nstatic void\nadd_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tu_int i;\n\n\tif (port > 0)\n\t\tadd_one_listen_addr(options, addr, rdomain, port);\n\telse {\n\t\tfor (i = 0; i < options->num_ports; i++) {\n\t\t\tadd_one_listen_addr(options, addr, rdomain,\n\t\t\t    options->ports[i]);\n\t\t}\n\t}\n}\n\nstatic void\nadd_one_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr;\n\tu_int i;\n\n\t \n\tfor (i = 0; i < options->num_listen_addrs; i++) {\n\t\tif (rdomain == NULL && options->listen_addrs[i].rdomain == NULL)\n\t\t\tbreak;\n\t\tif (rdomain == NULL || options->listen_addrs[i].rdomain == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(rdomain, options->listen_addrs[i].rdomain) == 0)\n\t\t\tbreak;\n\t}\n\tif (i >= options->num_listen_addrs) {\n\t\t \n\t\tif (i >= INT_MAX)\n\t\t\tfatal_f(\"too many listen addresses\");\n\t\toptions->listen_addrs = xrecallocarray(options->listen_addrs,\n\t\t    options->num_listen_addrs, options->num_listen_addrs + 1,\n\t\t    sizeof(*options->listen_addrs));\n\t\ti = options->num_listen_addrs++;\n\t\tif (rdomain != NULL)\n\t\t\toptions->listen_addrs[i].rdomain = xstrdup(rdomain);\n\t}\n\t \n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options->address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = (addr == NULL) ? AI_PASSIVE : 0;\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tif ((gaierr = getaddrinfo(addr, strport, &hints, &aitop)) != 0)\n\t\tfatal(\"bad addr or host: %s (%s)\",\n\t\t    addr ? addr : \"<NULL>\",\n\t\t    ssh_gai_strerror(gaierr));\n\tfor (ai = aitop; ai->ai_next; ai = ai->ai_next)\n\t\t;\n\tai->ai_next = options->listen_addrs[i].addrs;\n\toptions->listen_addrs[i].addrs = aitop;\n}\n\n \nstatic int\nvalid_rdomain(const char *name)\n{\n#if defined(HAVE_SYS_VALID_RDOMAIN)\n\treturn sys_valid_rdomain(name);\n#elif defined(__OpenBSD__)\n\tconst char *errstr;\n\tlong long num;\n\tstruct rt_tableinfo info;\n\tint mib[6];\n\tsize_t miblen = sizeof(mib);\n\n\tif (name == NULL)\n\t\treturn 1;\n\n\tnum = strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL)\n\t\treturn 0;\n\n\t \n\tmemset(mib, 0, sizeof(mib));\n\tmib[0] = CTL_NET;\n\tmib[1] = PF_ROUTE;\n\tmib[4] = NET_RT_TABLE;\n\tmib[5] = (int)num;\n\tif (sysctl(mib, 6, &info, &miblen, NULL, 0) == -1)\n\t\treturn 0;\n\n\treturn 1;\n#else  \n\terror(\"Routing domains are not supported on this platform\");\n\treturn 0;\n#endif\n}\n\n \nstatic void\nqueue_listen_addr(ServerOptions *options, const char *addr,\n    const char *rdomain, int port)\n{\n\tstruct queued_listenaddr *qla;\n\n\toptions->queued_listen_addrs = xrecallocarray(\n\t    options->queued_listen_addrs,\n\t    options->num_queued_listens, options->num_queued_listens + 1,\n\t    sizeof(*options->queued_listen_addrs));\n\tqla = &options->queued_listen_addrs[options->num_queued_listens++];\n\tqla->addr = xstrdup(addr);\n\tqla->port = port;\n\tqla->rdomain = rdomain == NULL ? NULL : xstrdup(rdomain);\n}\n\n \nstatic void\nprocess_queued_listen_addrs(ServerOptions *options)\n{\n\tu_int i;\n\tstruct queued_listenaddr *qla;\n\n\tif (options->num_ports == 0)\n\t\toptions->ports[options->num_ports++] = SSH_DEFAULT_PORT;\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\n\tfor (i = 0; i < options->num_queued_listens; i++) {\n\t\tqla = &options->queued_listen_addrs[i];\n\t\tadd_listen_addr(options, qla->addr, qla->rdomain, qla->port);\n\t\tfree(qla->addr);\n\t\tfree(qla->rdomain);\n\t}\n\tfree(options->queued_listen_addrs);\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n}\n\n \nstatic void\nprocess_permitopen_list(struct ssh *ssh, ServerOpCodes opcode,\n    char **opens, u_int num_opens)\n{\n\tu_int i;\n\tint port;\n\tchar *host, *arg, *oarg;\n\tint where = opcode == sPermitOpen ? FORWARD_LOCAL : FORWARD_REMOTE;\n\tconst char *what = lookup_opcode_name(opcode);\n\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tif (num_opens == 0)\n\t\treturn;  \n\n\t \n\tif (num_opens == 1 && strcmp(opens[0], \"any\") == 0)\n\t\treturn;\n\tif (num_opens == 1 && strcmp(opens[0], \"none\") == 0) {\n\t\tchannel_disable_admin(ssh, where);\n\t\treturn;\n\t}\n\t \n\tfor (i = 0; i < num_opens; i++) {\n\t\toarg = arg = xstrdup(opens[i]);\n\t\thost = hpdelim(&arg);\n\t\tif (host == NULL)\n\t\t\tfatal_f(\"missing host in %s\", what);\n\t\thost = cleanhostname(host);\n\t\tif (arg == NULL || ((port = permitopen_port(arg)) < 0))\n\t\t\tfatal_f(\"bad port number in %s\", what);\n\t\t \n\t\tchannel_add_permission(ssh, FORWARD_ADM,\n\t\t    where, host, port);\n\t\tfree(oarg);\n\t}\n}\n\n \nvoid\nprocess_permitopen(struct ssh *ssh, ServerOptions *options)\n{\n\tprocess_permitopen_list(ssh, sPermitOpen,\n\t    options->permitted_opens, options->num_permitted_opens);\n\tprocess_permitopen_list(ssh, sPermitListen,\n\t    options->permitted_listens,\n\t    options->num_permitted_listens);\n}\n\nvoid\nprocess_channel_timeouts(struct ssh *ssh, ServerOptions *options)\n{\n\tint secs;\n\tu_int i;\n\tchar *type;\n\n\tdebug3_f(\"setting %u timeouts\", options->num_channel_timeouts);\n\tchannel_clear_timeouts(ssh);\n\tfor (i = 0; i < options->num_channel_timeouts; i++) {\n\t\tif (parse_pattern_interval(options->channel_timeouts[i],\n\t\t    &type, &secs) != 0) {\n\t\t\tfatal_f(\"internal error: bad timeout %s\",\n\t\t\t    options->channel_timeouts[i]);\n\t\t}\n\t\tchannel_add_timeout(ssh, type, secs);\n\t\tfree(type);\n\t}\n}\n\nstruct connection_info *\nget_connection_info(struct ssh *ssh, int populate, int use_dns)\n{\n\tstatic struct connection_info ci;\n\n\tif (ssh == NULL || !populate)\n\t\treturn &ci;\n\tci.host = auth_get_canonical_hostname(ssh, use_dns);\n\tci.address = ssh_remote_ipaddr(ssh);\n\tci.laddress = ssh_local_ipaddr(ssh);\n\tci.lport = ssh_local_port(ssh);\n\tci.rdomain = ssh_packet_rdomain_in(ssh);\n\treturn &ci;\n}\n\n \n\nstatic int\nmatch_cfg_line_group(const char *grps, int line, const char *user)\n{\n\tint result = 0;\n\tstruct passwd *pw;\n\n\tif (user == NULL)\n\t\tgoto out;\n\n\tif ((pw = getpwnam(user)) == NULL) {\n\t\tdebug(\"Can't match group at line %d because user %.100s does \"\n\t\t    \"not exist\", line, user);\n\t} else if (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\tdebug(\"Can't Match group because user %.100s not in any group \"\n\t\t    \"at line %d\", user, line);\n\t} else if (ga_match_pattern_list(grps) != 1) {\n\t\tdebug(\"user %.100s does not match group list %.100s at line %d\",\n\t\t    user, grps, line);\n\t} else {\n\t\tdebug(\"user %.100s matched group list %.100s at line %d\", user,\n\t\t    grps, line);\n\t\tresult = 1;\n\t}\nout:\n\tga_free();\n\treturn result;\n}\n\nstatic void\nmatch_test_missing_fatal(const char *criteria, const char *attrib)\n{\n\tfatal(\"'Match %s' in configuration but '%s' not in connection \"\n\t    \"test specification.\", criteria, attrib);\n}\n\n \nstatic int\nmatch_cfg_line(char **condition, int line, struct connection_info *ci)\n{\n\tint result = 1, attributes = 0, port;\n\tchar *arg, *attrib, *cp = *condition;\n\n\tif (ci == NULL)\n\t\tdebug3(\"checking syntax for 'Match %s'\", cp);\n\telse\n\t\tdebug3(\"checking match for '%s' user %s host %s addr %s \"\n\t\t    \"laddr %s lport %d\", cp, ci->user ? ci->user : \"(null)\",\n\t\t    ci->host ? ci->host : \"(null)\",\n\t\t    ci->address ? ci->address : \"(null)\",\n\t\t    ci->laddress ? ci->laddress : \"(null)\", ci->lport);\n\n\twhile ((attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\t \n\t\tif (*attrib == '#') {\n\t\t\tcp = NULL;  \n\t\t\tbreak;\n\t\t}\n\t\targ = NULL;\n\t\tattributes++;\n\t\t \n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes > 1 || ((arg = strdelim(&cp)) != NULL &&\n\t\t\t    *arg != '\\0' && *arg != '#')) {\n\t\t\t\terror(\"'all' cannot be combined with other \"\n\t\t\t\t    \"Match attributes\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (arg != NULL && *arg == '#')\n\t\t\t\tcp = NULL;  \n\t\t\t*condition = cp;\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\tif ((arg = strdelim(&cp)) == NULL ||\n\t\t    *arg == '\\0' || *arg == '#') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tif (ci == NULL || (ci->test && ci->user == NULL)) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"User\", \"user\");\n\t\t\tif (match_usergroup_pattern_list(ci->user, arg) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'User %.100s' at \"\n\t\t\t\t    \"line %d\", ci->user, arg, line);\n\t\t} else if (strcasecmp(attrib, \"group\") == 0) {\n\t\t\tif (ci == NULL || (ci->test && ci->user == NULL)) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->user == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Group\", \"user\");\n\t\t\tswitch (match_cfg_line_group(arg, line, ci->user)) {\n\t\t\tcase -1:\n\t\t\t\treturn -1;\n\t\t\tcase 0:\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tif (ci == NULL || (ci->test && ci->host == NULL)) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->host == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Host\", \"host\");\n\t\t\tif (match_hostname(ci->host, arg) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"connection from %.100s matched 'Host \"\n\t\t\t\t    \"%.100s' at line %d\", ci->host, arg, line);\n\t\t} else if (strcasecmp(attrib, \"address\") == 0) {\n\t\t\tif (ci == NULL || (ci->test && ci->address == NULL)) {\n\t\t\t\tif (addr_match_list(NULL, arg) != 0)\n\t\t\t\t\tfatal(\"Invalid Match address argument \"\n\t\t\t\t\t    \"'%s' at line %d\", arg, line);\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->address == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"Address\", \"addr\");\n\t\t\tswitch (addr_match_list(ci->address, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched 'Address \"\n\t\t\t\t    \"%.100s' at line %d\", ci->address, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localaddress\") == 0){\n\t\t\tif (ci == NULL || (ci->test && ci->laddress == NULL)) {\n\t\t\t\tif (addr_match_list(NULL, arg) != 0)\n\t\t\t\t\tfatal(\"Invalid Match localaddress \"\n\t\t\t\t\t    \"argument '%s' at line %d\", arg,\n\t\t\t\t\t    line);\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->laddress == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"LocalAddress\",\n\t\t\t\t    \"laddr\");\n\t\t\tswitch (addr_match_list(ci->laddress, arg)) {\n\t\t\tcase 1:\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalAddress %.100s' at line %d\",\n\t\t\t\t    ci->laddress, arg, line);\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\tcase -1:\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (strcasecmp(attrib, \"localport\") == 0) {\n\t\t\tif ((port = a2port(arg)) == -1) {\n\t\t\t\terror(\"Invalid LocalPort '%s' on Match line\",\n\t\t\t\t    arg);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ci == NULL || (ci->test && ci->lport == -1)) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->lport == 0)\n\t\t\t\tmatch_test_missing_fatal(\"LocalPort\", \"lport\");\n\t\t\t \n\t\t\tif (port == ci->lport)\n\t\t\t\tdebug(\"connection from %.100s matched \"\n\t\t\t\t    \"'LocalPort %d' at line %d\",\n\t\t\t\t    ci->laddress, port, line);\n\t\t\telse\n\t\t\t\tresult = 0;\n\t\t} else if (strcasecmp(attrib, \"rdomain\") == 0) {\n\t\t\tif (ci == NULL || (ci->test && ci->rdomain == NULL)) {\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ci->rdomain == NULL)\n\t\t\t\tmatch_test_missing_fatal(\"RDomain\", \"rdomain\");\n\t\t\tif (match_pattern_list(ci->rdomain, arg, 0) != 1)\n\t\t\t\tresult = 0;\n\t\t\telse\n\t\t\t\tdebug(\"user %.100s matched 'RDomain %.100s' at \"\n\t\t\t\t    \"line %d\", ci->rdomain, arg, line);\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\treturn -1;\n\t}\n\tif (ci != NULL)\n\t\tdebug3(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\treturn result;\n}\n\n#define WHITESPACE \" \\t\\r\\n\"\n\n \nstruct multistate {\n\tchar *key;\n\tint value;\n};\nstatic const struct multistate multistate_flag[] = {\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_ignore_rhosts[] = {\n\t{ \"yes\",\t\t\tIGNORE_RHOSTS_YES },\n\t{ \"no\",\t\t\t\tIGNORE_RHOSTS_NO },\n\t{ \"shosts-only\",\t\tIGNORE_RHOSTS_SHOSTS },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_permitrootlogin[] = {\n\t{ \"without-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"prohibit-password\",\t\tPERMIT_NO_PASSWD },\n\t{ \"forced-commands-only\",\tPERMIT_FORCED_ONLY },\n\t{ \"yes\",\t\t\tPERMIT_YES },\n\t{ \"no\",\t\t\t\tPERMIT_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n#ifdef WITH_ZLIB\n\t{ \"yes\",\t\t\tCOMP_DELAYED },\n\t{ \"delayed\",\t\t\tCOMP_DELAYED },\n#endif\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_gatewayports[] = {\n\t{ \"clientspecified\",\t\t2 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tcpfwd[] = {\n\t{ \"yes\",\t\t\tFORWARD_ALLOW },\n\t{ \"all\",\t\t\tFORWARD_ALLOW },\n\t{ \"no\",\t\t\t\tFORWARD_DENY },\n\t{ \"remote\",\t\t\tFORWARD_REMOTE },\n\t{ \"local\",\t\t\tFORWARD_LOCAL },\n\t{ NULL, -1 }\n};\n\nstatic int\nprocess_server_config_line_depth(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo, int *inc_flags, int depth,\n    struct include_list *includes)\n{\n\tchar *str, ***chararrayptr, **charptr, *arg, *arg2, *p, *keyword;\n\tint cmdline = 0, *intptr, value, value2, n, port, oactive, r, found;\n\tint ca_only = 0;\n\tSyslogFacility *log_facility_ptr;\n\tLogLevel *log_level_ptr;\n\tServerOpCodes opcode;\n\tu_int i, *uintptr, uvalue, flags = 0;\n\tsize_t len;\n\tlong long val64;\n\tconst struct multistate *multistate_ptr;\n\tconst char *errstr;\n\tstruct include_item *item;\n\tglob_t gbuf;\n\tchar **oav = NULL, **av;\n\tint oac = 0, ac;\n\tint ret = -1;\n\n\t \n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tstr = line;\n\tif ((keyword = strdelim(&str)) == NULL)\n\t\treturn 0;\n\t \n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&str);\n\tif (!keyword || !*keyword || *keyword == '#')\n\t\treturn 0;\n\tif (str == NULL || *str == '\\0') {\n\t\terror(\"%s line %d: no argument after keyword \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn -1;\n\t}\n\tintptr = NULL;\n\tcharptr = NULL;\n\topcode = parse_token(keyword, filename, linenum, &flags);\n\n\tif (argv_split(str, &oac, &oav, 1) != 0) {\n\t\terror(\"%s line %d: invalid quotes\", filename, linenum);\n\t\treturn -1;\n\t}\n\tac = oac;\n\tav = oav;\n\n\tif (activep == NULL) {  \n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\tif (*activep && opcode != sMatch && opcode != sInclude)\n\t\tdebug3(\"%s:%d setting %s %s\", filename, linenum, keyword, str);\n\tif (*activep == 0 && !(flags & SSHCFG_MATCH)) {\n\t\tif (connectinfo == NULL) {\n\t\t\tfatal(\"%s line %d: Directive '%s' is not allowed \"\n\t\t\t    \"within a Match block\", filename, linenum, keyword);\n\t\t} else {  \n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (opcode) {\n\t \n\tcase sUsePAM:\n\t\tintptr = &options->use_pam;\n\t\tgoto parse_flag;\n\n\t \n\tcase sBadOption:\n\t\tgoto out;\n\tcase sPort:\n\t\t \n\t\tif (options->ports_from_cmdline) {\n\t\t\targv_consume(&ac);\n\t\t\tbreak;\n\t\t}\n\t\tif (options->num_ports >= MAX_PORTS)\n\t\t\tfatal(\"%s line %d: too many ports.\",\n\t\t\t    filename, linenum);\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing port number.\",\n\t\t\t    filename, linenum);\n\t\toptions->ports[options->num_ports++] = a2port(arg);\n\t\tif (options->ports[options->num_ports-1] <= 0)\n\t\t\tfatal(\"%s line %d: Badly formatted port number.\",\n\t\t\t    filename, linenum);\n\t\tbreak;\n\n\tcase sLoginGraceTime:\n\t\tintptr = &options->login_grace_time;\n parse_time:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\tif ((value = convtime(arg)) == -1)\n\t\t\tfatal(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sListenAddress:\n\t\targ = argv_next(&ac, &av);\n\t\tif (arg == NULL || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing address\",\n\t\t\t    filename, linenum);\n\t\t \n\t\tif (strchr(arg, '[') == NULL && (p = strchr(arg, ':')) != NULL\n\t\t    && strchr(p+1, ':') != NULL) {\n\t\t\tport = 0;\n\t\t\tp = arg;\n\t\t} else {\n\t\t\targ2 = NULL;\n\t\t\tp = hpdelim(&arg);\n\t\t\tif (p == NULL)\n\t\t\t\tfatal(\"%s line %d: bad address:port usage\",\n\t\t\t\t    filename, linenum);\n\t\t\tp = cleanhostname(p);\n\t\t\tif (arg == NULL)\n\t\t\t\tport = 0;\n\t\t\telse if ((port = a2port(arg)) <= 0)\n\t\t\t\tfatal(\"%s line %d: bad port number\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\t \n\t\targ2 = NULL;\n\t\tif ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (strcmp(arg, \"rdomain\") != 0 ||\n\t\t\t    (arg2 = argv_next(&ac, &av)) == NULL)\n\t\t\t\tfatal(\"%s line %d: bad ListenAddress syntax\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!valid_rdomain(arg2))\n\t\t\t\tfatal(\"%s line %d: bad routing domain\",\n\t\t\t\t    filename, linenum);\n\t\t}\n\t\tqueue_listen_addr(options, p, arg2, port);\n\n\t\tbreak;\n\n\tcase sAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n parse_multistate:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\tvalue = -1;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sHostKeyFile:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep) {\n\t\t\tservconf_add_hostkey(filename, linenum,\n\t\t\t    options, arg, 1);\n\t\t}\n\t\tbreak;\n\n\tcase sHostKeyAgent:\n\t\tcharptr = &options->host_key_agent;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing socket name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = !strcmp(arg, SSH_AUTHSOCKET_ENV_NAME) ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\tbreak;\n\n\tcase sHostCertificate:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep)\n\t\t\tservconf_add_hostcert(filename, linenum, options, arg);\n\t\tbreak;\n\n\tcase sPidFile:\n\t\tcharptr = &options->pid_file;\n parse_filename:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: missing file name.\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = derelativise_path(arg);\n\t\t\t \n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sModuliFile:\n\t\tcharptr = &options->moduli_file;\n\t\tgoto parse_filename;\n\n\tcase sPermitRootLogin:\n\t\tintptr = &options->permit_root_login;\n\t\tmultistate_ptr = multistate_permitrootlogin;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreRhosts:\n\t\tintptr = &options->ignore_rhosts;\n\t\tmultistate_ptr = multistate_ignore_rhosts;\n\t\tgoto parse_multistate;\n\n\tcase sIgnoreUserKnownHosts:\n\t\tintptr = &options->ignore_user_known_hosts;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n\t\tgoto parse_multistate;\n\n\tcase sHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedUsesNameFromPacketOnly:\n\t\tintptr = &options->hostbased_uses_name_from_packet_only;\n\t\tgoto parse_flag;\n\n\tcase sHostbasedAcceptedAlgorithms:\n\t\tcharptr = &options->hostbased_accepted_algos;\n\t\tca_only = 0;\n parse_pubkey_algos:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' || *arg == '^' ?\n\t\t    arg + 1 : arg, 1, ca_only))\n\t\t\tfatal(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tca_only = 0;\n\t\tgoto parse_pubkey_algos;\n\n\tcase sCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tca_only = 1;\n\t\tgoto parse_pubkey_algos;\n\n\tcase sPubkeyAuthentication:\n\t\tintptr = &options->pubkey_authentication;\n\t\tca_only = 0;\n\t\tgoto parse_flag;\n\n\tcase sPubkeyAcceptedAlgorithms:\n\t\tcharptr = &options->pubkey_accepted_algos;\n\t\tca_only = 0;\n\t\tgoto parse_pubkey_algos;\n\n\tcase sPubkeyAuthOptions:\n\t\tintptr = &options->pubkey_auth_options;\n\t\tvalue = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (strcasecmp(arg, \"none\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcasecmp(arg, \"touch-required\") == 0)\n\t\t\t\tvalue |= PUBKEYAUTH_TOUCH_REQUIRED;\n\t\t\telse if (strcasecmp(arg, \"verify-required\") == 0)\n\t\t\t\tvalue |= PUBKEYAUTH_VERIFY_REQUIRED;\n\t\t\telse {\n\t\t\t\terror(\"%s line %d: unsupported %s option %s\",\n\t\t\t\t    filename, linenum, keyword, arg);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sKerberosAuthentication:\n\t\tintptr = &options->kerberos_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKerberosOrLocalPasswd:\n\t\tintptr = &options->kerberos_or_local_passwd;\n\t\tgoto parse_flag;\n\n\tcase sKerberosTicketCleanup:\n\t\tintptr = &options->kerberos_ticket_cleanup;\n\t\tgoto parse_flag;\n\n\tcase sKerberosGetAFSToken:\n\t\tintptr = &options->kerberos_get_afs_token;\n\t\tgoto parse_flag;\n\n\tcase sGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase sGssCleanupCreds:\n\t\tintptr = &options->gss_cleanup_creds;\n\t\tgoto parse_flag;\n\n\tcase sGssStrictAcceptor:\n\t\tintptr = &options->gss_strict_acceptor;\n\t\tgoto parse_flag;\n\n\tcase sPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase sKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase sPrintMotd:\n\t\tintptr = &options->print_motd;\n\t\tgoto parse_flag;\n\n\tcase sPrintLastLog:\n\t\tintptr = &options->print_lastlog;\n\t\tgoto parse_flag;\n\n\tcase sX11Forwarding:\n\t\tintptr = &options->x11_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sX11DisplayOffset:\n\t\tintptr = &options->x11_display_offset;\n parse_int:\n\t\targ = argv_next(&ac, &av);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\tfatal(\"%s line %d: %s integer value %s.\",\n\t\t\t    filename, linenum, keyword, errstr);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sX11UseLocalhost:\n\t\tintptr = &options->x11_use_localhost;\n\t\tgoto parse_flag;\n\n\tcase sXAuthLocation:\n\t\tcharptr = &options->xauth_location;\n\t\tgoto parse_filename;\n\n\tcase sPermitTTY:\n\t\tintptr = &options->permit_tty;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserRC:\n\t\tintptr = &options->permit_user_rc;\n\t\tgoto parse_flag;\n\n\tcase sStrictModes:\n\t\tintptr = &options->strict_modes;\n\t\tgoto parse_flag;\n\n\tcase sTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase sEmptyPasswd:\n\t\tintptr = &options->permit_empty_passwd;\n\t\tgoto parse_flag;\n\n\tcase sPermitUserEnvironment:\n\t\tintptr = &options->permit_user_env;\n\t\tcharptr = &options->permit_user_env_allowlist;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tvalue = 0;\n\t\tp = NULL;\n\t\tif (strcmp(arg, \"yes\") == 0)\n\t\t\tvalue = 1;\n\t\telse if (strcmp(arg, \"no\") == 0)\n\t\t\tvalue = 0;\n\t\telse {\n\t\t\t \n\t\t\tvalue = 1;\n\t\t\tp = xstrdup(arg);\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\t*charptr = p;\n\t\t\tp = NULL;\n\t\t}\n\t\tfree(p);\n\t\tbreak;\n\n\tcase sCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase sRekeyLimit:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1)\n\t\t\t\tfatal(\"%.200s line %d: Bad %s number '%s': %s\",\n\t\t\t\t    filename, linenum, keyword,\n\t\t\t\t    arg, strerror(errno));\n\t\t\tif (val64 != 0 && val64 < 16)\n\t\t\t\tfatal(\"%.200s line %d: %s too small\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (ac != 0) {  \n\t\t\tif (strcmp(av[0], \"none\") == 0) {\n\t\t\t\t(void)argv_next(&ac, &av);\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase sGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tmultistate_ptr = multistate_gatewayports;\n\t\tgoto parse_multistate;\n\n\tcase sUseDNS:\n\t\tintptr = &options->use_dns;\n\t\tgoto parse_flag;\n\n\tcase sLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = argv_next(&ac, &av);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase sLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = argv_next(&ac, &av);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET)\n\t\t\tfatal(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (*activep && *log_level_ptr == -1)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase sLogVerbose:\n\t\tfound = options->num_log_verbose == 0;\n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!found || !*activep)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    &options->log_verbose, &options->num_log_verbose,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sAllowTcpForwarding:\n\t\tintptr = &options->allow_tcp_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowStreamLocalForwarding:\n\t\tintptr = &options->allow_streamlocal_forwarding;\n\t\tmultistate_ptr = multistate_tcpfwd;\n\t\tgoto parse_multistate;\n\n\tcase sAllowAgentForwarding:\n\t\tintptr = &options->allow_agent_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sDisableForwarding:\n\t\tintptr = &options->disable_forwarding;\n\t\tgoto parse_flag;\n\n\tcase sAllowUsers:\n\t\tchararrayptr = &options->allow_users;\n\t\tuintptr = &options->num_allow_users;\n parse_allowdenyusers:\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0' ||\n\t\t\t    match_user(NULL, NULL, NULL, arg) == -1)\n\t\t\t\tfatal(\"%s line %d: invalid %s pattern: \\\"%s\\\"\",\n\t\t\t\t    filename, linenum, keyword, arg);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    chararrayptr, uintptr, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyUsers:\n\t\tchararrayptr = &options->deny_users;\n\t\tuintptr = &options->num_deny_users;\n\t\tgoto parse_allowdenyusers;\n\n\tcase sAllowGroups:\n\t\tchararrayptr = &options->allow_groups;\n\t\tuintptr = &options->num_allow_groups;\n parse_allowdenygroups:\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0')\n\t\t\t\tfatal(\"%s line %d: empty %s pattern\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    chararrayptr, uintptr, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sDenyGroups:\n\t\tchararrayptr = &options->deny_groups;\n\t\tuintptr = &options->num_deny_groups;\n\t\tgoto parse_allowdenygroups;\n\n\tcase sCiphers:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*arg != '-' &&\n\t\t    !ciphers_valid(*arg == '+' || *arg == '^' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase sMacs:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*arg != '-' &&\n\t\t    !mac_valid(*arg == '+' || *arg == '^' ? arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 mac spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase sKexAlgorithms:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' || *arg == '^' ?\n\t\t    arg + 1 : arg))\n\t\t\tfatal(\"%s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\tif (options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase sSubsystem:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (!*activep) {\n\t\t\targv_consume(&ac);\n\t\t\tbreak;\n\t\t}\n\t\tfound = 0;\n\t\tfor (i = 0; i < options->num_subsystems; i++) {\n\t\t\tif (strcmp(arg, options->subsystem_name[i]) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tdebug(\"%s line %d: Subsystem '%s' already defined.\",\n\t\t\t    filename, linenum, arg);\n\t\t\targv_consume(&ac);\n\t\t\tbreak;\n\t\t}\n\t\toptions->subsystem_name = xrecallocarray(\n\t\t    options->subsystem_name, options->num_subsystems,\n\t\t    options->num_subsystems + 1,\n\t\t    sizeof(*options->subsystem_name));\n\t\toptions->subsystem_command = xrecallocarray(\n\t\t    options->subsystem_command, options->num_subsystems,\n\t\t    options->num_subsystems + 1,\n\t\t    sizeof(*options->subsystem_command));\n\t\toptions->subsystem_args = xrecallocarray(\n\t\t    options->subsystem_args, options->num_subsystems,\n\t\t    options->num_subsystems + 1,\n\t\t    sizeof(*options->subsystem_args));\n\t\toptions->subsystem_name[options->num_subsystems] = xstrdup(arg);\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\tfatal(\"%s line %d: Missing subsystem command.\",\n\t\t\t    filename, linenum);\n\t\t}\n\t\toptions->subsystem_command[options->num_subsystems] =\n\t\t    xstrdup(arg);\n\t\t \n\t\targ = argv_assemble(1, &arg);  \n\t\targ2 = argv_assemble(ac, av);  \n\t\txasprintf(&options->subsystem_args[options->num_subsystems],\n\t\t    \"%s %s\", arg, arg2);\n\t\tfree(arg2);\n\t\targv_consume(&ac);\n\t\toptions->num_subsystems++;\n\t\tbreak;\n\n\tcase sMaxStartups:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif ((n = sscanf(arg, \"%d:%d:%d\",\n\t\t    &options->max_startups_begin,\n\t\t    &options->max_startups_rate,\n\t\t    &options->max_startups)) == 3) {\n\t\t\tif (options->max_startups_begin >\n\t\t\t    options->max_startups ||\n\t\t\t    options->max_startups_rate > 100 ||\n\t\t\t    options->max_startups_rate < 1)\n\t\t\t\tfatal(\"%s line %d: Invalid %s spec.\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t} else if (n != 1)\n\t\t\tfatal(\"%s line %d: Invalid %s spec.\",\n\t\t\t    filename, linenum, keyword);\n\t\telse\n\t\t\toptions->max_startups = options->max_startups_begin;\n\t\tif (options->max_startups <= 0 ||\n\t\t    options->max_startups_begin <= 0)\n\t\t\tfatal(\"%s line %d: Invalid %s spec.\",\n\t\t\t    filename, linenum, keyword);\n\t\tbreak;\n\n\tcase sPerSourceNetBlockSize:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tswitch (n = sscanf(arg, \"%d:%d\", &value, &value2)) {\n\t\tcase 2:\n\t\t\tif (value2 < 0 || value2 > 128)\n\t\t\t\tn = -1;\n\t\t\t \n\t\tcase 1:\n\t\t\tif (value < 0 || value > 32)\n\t\t\t\tn = -1;\n\t\t}\n\t\tif (n != 1 && n != 2)\n\t\t\tfatal(\"%s line %d: Invalid %s spec.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*activep) {\n\t\t\toptions->per_source_masklen_ipv4 = value;\n\t\t\toptions->per_source_masklen_ipv6 = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sPerSourceMaxStartups:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (strcmp(arg, \"none\") == 0) {  \n\t\t\tvalue = INT_MAX;\n\t\t} else {\n\t\t\tif ((errstr = atoi_err(arg, &value)) != NULL)\n\t\t\t\tfatal(\"%s line %d: %s integer value %s.\",\n\t\t\t\t    filename, linenum, keyword, errstr);\n\t\t}\n\t\tif (*activep && options->per_source_max_startups == -1)\n\t\t\toptions->per_source_max_startups = value;\n\t\tbreak;\n\n\tcase sMaxAuthTries:\n\t\tintptr = &options->max_authtries;\n\t\tgoto parse_int;\n\n\tcase sMaxSessions:\n\t\tintptr = &options->max_sessions;\n\t\tgoto parse_int;\n\n\tcase sBanner:\n\t\tcharptr = &options->banner;\n\t\tgoto parse_filename;\n\n\t \n\tcase sAuthorizedKeysFile:\n\t\tuvalue = options->num_authkeys_files;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\targ2 = tilde_expand_filename(arg, getuid());\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t\t    &options->authorized_keys_files,\n\t\t\t\t    &options->num_authkeys_files, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsFile:\n\t\tcharptr = &options->authorized_principals_file;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = tilde_expand_filename(arg, getuid());\n\t\t\t \n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sClientAliveInterval:\n\t\tintptr = &options->client_alive_interval;\n\t\tgoto parse_time;\n\n\tcase sClientAliveCountMax:\n\t\tintptr = &options->client_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase sAcceptEnv:\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0' || strchr(arg, '=') != NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    &options->accept_env, &options->num_accept_env,\n\t\t\t    arg);\n\t\t}\n\t\tbreak;\n\n\tcase sSetEnv:\n\t\tuvalue = options->num_setenv;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0' || strchr(arg, '=') == NULL)\n\t\t\t\tfatal(\"%s line %d: Invalid environment.\",\n\t\t\t\t    filename, linenum);\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\tif (lookup_setenv_in_list(arg, options->setenv,\n\t\t\t    options->num_setenv) != NULL) {\n\t\t\t\tdebug2(\"%s line %d: ignoring duplicate env \"\n\t\t\t\t    \"name \\\"%.64s\\\"\", filename, linenum, arg);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sPermitTunnel:\n\t\tintptr = &options->permit_tun;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tvalue = -1;\n\t\tfor (i = 0; tunmode_desc[i].val != -1; i++)\n\t\t\tif (strcmp(tunmode_desc[i].text, arg) == 0) {\n\t\t\t\tvalue = tunmode_desc[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (value == -1)\n\t\t\tfatal(\"%s line %d: bad %s argument %s\",\n\t\t\t    filename, linenum, keyword, arg);\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase sInclude:\n\t\tif (cmdline) {\n\t\t\tfatal(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\t}\n\t\tvalue = 0;\n\t\twhile ((arg2 = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg2 == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvalue++;\n\t\t\tfound = 0;\n\t\t\tif (*arg2 != '/' && *arg2 != '~') {\n\t\t\t\txasprintf(&arg, \"%s/%s\", SSHDIR, arg2);\n\t\t\t} else\n\t\t\t\targ = xstrdup(arg2);\n\n\t\t\t \n\t\t\toactive = *activep;\n\n\t\t\t \n\t\t\tTAILQ_FOREACH(item, includes, entry) {\n\t\t\t\tif (strcmp(item->selector, arg) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (item->filename != NULL) {\n\t\t\t\t\tparse_server_config_depth(options,\n\t\t\t\t\t    item->filename, item->contents,\n\t\t\t\t\t    includes, connectinfo,\n\t\t\t\t\t    (*inc_flags & SSHCFG_MATCH_ONLY\n\t\t\t\t\t        ? SSHCFG_MATCH_ONLY : (oactive\n\t\t\t\t\t            ? 0 : SSHCFG_NEVERMATCH)),\n\t\t\t\t\t    activep, depth + 1);\n\t\t\t\t}\n\t\t\t\tfound = 1;\n\t\t\t\t*activep = oactive;\n\t\t\t}\n\t\t\tif (found != 0) {\n\t\t\t\tfree(arg);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tdebug2(\"%s line %d: new include %s\",\n\t\t\t    filename, linenum, arg);\n\t\t\tif ((r = glob(arg, 0, NULL, &gbuf)) != 0) {\n\t\t\t\tif (r != GLOB_NOMATCH) {\n\t\t\t\t\tfatal(\"%s line %d: include \\\"%s\\\" glob \"\n\t\t\t\t\t    \"failed\", filename, linenum, arg);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdebug2(\"%s line %d: no match for %s\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\t\titem = xcalloc(1, sizeof(*item));\n\t\t\t\titem->selector = strdup(arg);\n\t\t\t\tTAILQ_INSERT_TAIL(includes,\n\t\t\t\t    item, entry);\n\t\t\t}\n\t\t\tif (gbuf.gl_pathc > INT_MAX)\n\t\t\t\tfatal_f(\"too many glob results\");\n\t\t\tfor (n = 0; n < (int)gbuf.gl_pathc; n++) {\n\t\t\t\tdebug2(\"%s line %d: including %s\",\n\t\t\t\t    filename, linenum, gbuf.gl_pathv[n]);\n\t\t\t\titem = xcalloc(1, sizeof(*item));\n\t\t\t\titem->selector = strdup(arg);\n\t\t\t\titem->filename = strdup(gbuf.gl_pathv[n]);\n\t\t\t\tif ((item->contents = sshbuf_new()) == NULL)\n\t\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\t\tload_server_config(item->filename,\n\t\t\t\t    item->contents);\n\t\t\t\tparse_server_config_depth(options,\n\t\t\t\t    item->filename, item->contents,\n\t\t\t\t    includes, connectinfo,\n\t\t\t\t    (*inc_flags & SSHCFG_MATCH_ONLY\n\t\t\t\t        ? SSHCFG_MATCH_ONLY : (oactive\n\t\t\t\t            ? 0 : SSHCFG_NEVERMATCH)),\n\t\t\t\t    activep, depth + 1);\n\t\t\t\t*activep = oactive;\n\t\t\t\tTAILQ_INSERT_TAIL(includes, item, entry);\n\t\t\t}\n\t\t\tglobfree(&gbuf);\n\t\t\tfree(arg);\n\t\t}\n\t\tif (value == 0) {\n\t\t\tfatal(\"%s line %d: %s missing filename argument\",\n\t\t\t    filename, linenum, keyword);\n\t\t}\n\t\tbreak;\n\n\tcase sMatch:\n\t\tif (cmdline)\n\t\t\tfatal(\"Match directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\tvalue = match_cfg_line(&str, linenum,\n\t\t    (*inc_flags & SSHCFG_NEVERMATCH ? NULL : connectinfo));\n\t\tif (value < 0)\n\t\t\tfatal(\"%s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t*activep = (*inc_flags & SSHCFG_NEVERMATCH) ? 0 : value;\n\t\t \n\t\t*inc_flags &= ~SSHCFG_MATCH_ONLY;\n\t\t \n\t\tif (str == NULL || *str == '\\0')\n\t\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase sPermitListen:\n\tcase sPermitOpen:\n\t\tif (opcode == sPermitListen) {\n\t\t\tuintptr = &options->num_permitted_listens;\n\t\t\tchararrayptr = &options->permitted_listens;\n\t\t} else {\n\t\t\tuintptr = &options->num_permitted_opens;\n\t\t\tchararrayptr = &options->permitted_opens;\n\t\t}\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tuvalue = *uintptr;\t \n\t\tif (strcmp(arg, \"any\") == 0 || strcmp(arg, \"none\") == 0) {\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\t*uintptr = 1;\n\t\t\t\t*chararrayptr = xcalloc(1,\n\t\t\t\t    sizeof(**chararrayptr));\n\t\t\t\t(*chararrayptr)[0] = xstrdup(arg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfor (; arg != NULL && *arg != '\\0'; arg = argv_next(&ac, &av)) {\n\t\t\tif (opcode == sPermitListen &&\n\t\t\t    strchr(arg, ':') == NULL) {\n\t\t\t\t \n\t\t\t\txasprintf(&arg2, \"*:%s\", arg);\n\t\t\t} else {\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: %s missing host\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t}\n\t\t\tif (arg == NULL ||\n\t\t\t    ((port = permitopen_port(arg)) < 0)) {\n\t\t\t\tfatal(\"%s line %d: %s bad port number\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t\t    chararrayptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase sForceCommand:\n\t\tif (str == NULL || *str == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tlen = strspn(str, WHITESPACE);\n\t\tif (*activep && options->adm_forced_command == NULL)\n\t\t\toptions->adm_forced_command = xstrdup(str + len);\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase sChrootDirectory:\n\t\tcharptr = &options->chroot_directory;\n\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sTrustedUserCAKeys:\n\t\tcharptr = &options->trusted_user_ca_keys;\n\t\tgoto parse_filename;\n\n\tcase sRevokedKeys:\n\t\tcharptr = &options->revoked_keys_file;\n\t\tgoto parse_filename;\n\n\tcase sSecurityKeyProvider:\n\t\tcharptr = &options->sk_provider;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*activep && *charptr == NULL) {\n\t\t\t*charptr = strcasecmp(arg, \"internal\") == 0 ?\n\t\t\t    xstrdup(arg) : derelativise_path(arg);\n\t\t\t \n\t\t\tif (intptr != NULL)\n\t\t\t\t*intptr = *intptr + 1;\n\t\t}\n\t\tbreak;\n\n\tcase sIPQoS:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif ((value = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad %s value: %s\",\n\t\t\t    filename, linenum, keyword, arg);\n\t\targ = argv_next(&ac, &av);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1)\n\t\t\tfatal(\"%s line %d: Bad %s value: %s\",\n\t\t\t    filename, linenum, keyword, arg);\n\t\tif (*activep) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase sVersionAddendum:\n\t\tif (str == NULL || *str == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tlen = strspn(str, WHITESPACE);\n\t\tif (strchr(str + len, '\\r') != NULL) {\n\t\t\tfatal(\"%.200s line %d: Invalid %s argument\",\n\t\t\t    filename, linenum, keyword);\n\t\t}\n\t\tif ((arg = strchr(line, '#')) != NULL) {\n\t\t\t*arg = '\\0';\n\t\t\trtrim(line);\n\t\t}\n\t\tif (*activep && options->version_addendum == NULL) {\n\t\t\tif (strcasecmp(str + len, \"none\") == 0)\n\t\t\t\toptions->version_addendum = xstrdup(\"\");\n\t\t\telse\n\t\t\t\toptions->version_addendum = xstrdup(str + len);\n\t\t}\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase sAuthorizedKeysCommand:\n\t\tcharptr = &options->authorized_keys_command;\n parse_command:\n\t\tlen = strspn(str, WHITESPACE);\n\t\tif (str[len] != '/' && strcasecmp(str + len, \"none\") != 0) {\n\t\t\tfatal(\"%.200s line %d: %s must be an absolute path\",\n\t\t\t    filename, linenum, keyword);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(str + len);\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase sAuthorizedKeysCommandUser:\n\t\tcharptr = &options->authorized_keys_command_user;\n parse_localuser:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\tfatal(\"%s line %d: missing %s argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sAuthorizedPrincipalsCommand:\n\t\tcharptr = &options->authorized_principals_command;\n\t\tgoto parse_command;\n\n\tcase sAuthorizedPrincipalsCommandUser:\n\t\tcharptr = &options->authorized_principals_command_user;\n\t\tgoto parse_localuser;\n\n\tcase sAuthenticationMethods:\n\t\tfound = options->num_auth_methods == 0;\n\t\tvalue = 0;  \n\t\tvalue2 = 0;  \n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (strcmp(arg, \"any\") == 0) {\n\t\t\t\tif (options->num_auth_methods > 0) {\n\t\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must \"\n\t\t\t\t\t    \"appear alone in %s\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t}\n\t\t\t\tvalue = 1;\n\t\t\t} else if (value) {\n\t\t\t\tfatal(\"%s line %d: \\\"any\\\" must appear \"\n\t\t\t\t    \"alone in %s\", filename, linenum, keyword);\n\t\t\t} else if (auth2_methods_valid(arg, 0) != 0) {\n\t\t\t\tfatal(\"%s line %d: invalid %s method list.\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t}\n\t\t\tvalue2 = 1;\n\t\t\tif (!found || !*activep)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    &options->auth_methods,\n\t\t\t    &options->num_auth_methods, arg);\n\t\t}\n\t\tif (value2 == 0) {\n\t\t\tfatal(\"%s line %d: no %s specified\",\n\t\t\t    filename, linenum, keyword);\n\t\t}\n\t\tbreak;\n\n\tcase sStreamLocalBindMask:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\t \n\t\tvalue = strtol(arg, &p, 8);\n\t\tif (arg == p || value < 0 || value > 0777)\n\t\t\tfatal(\"%s line %d: Invalid %s.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (*activep)\n\t\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase sStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase sFingerprintHash:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1)\n\t\t\tfatal(\"%.200s line %d: Invalid %s algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, keyword, arg);\n\t\tif (*activep)\n\t\t\toptions->fingerprint_hash = value;\n\t\tbreak;\n\n\tcase sExposeAuthInfo:\n\t\tintptr = &options->expose_userauth_info;\n\t\tgoto parse_flag;\n\n\tcase sRDomain:\n#if !defined(__OpenBSD__) && !defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\t\tfatal(\"%s line %d: setting RDomain not supported on this \"\n\t\t    \"platform.\", filename, linenum);\n#endif\n\t\tcharptr = &options->routing_domain;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0')\n\t\t\tfatal(\"%s line %d: %s missing argument.\",\n\t\t\t    filename, linenum, keyword);\n\t\tif (strcasecmp(arg, \"none\") != 0 && strcmp(arg, \"%D\") != 0 &&\n\t\t    !valid_rdomain(arg))\n\t\t\tfatal(\"%s line %d: invalid routing domain\",\n\t\t\t    filename, linenum);\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase sRequiredRSASize:\n\t\tintptr = &options->required_rsa_size;\n\t\tgoto parse_int;\n\n\tcase sChannelTimeout:\n\t\tuvalue = options->num_channel_timeouts;\n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (parse_pattern_interval(arg,\n\t\t\t    NULL, NULL) != 0) {\n\t\t\t\tfatal(\"%s line %d: invalid channel timeout %s\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\t}\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    &options->channel_timeouts,\n\t\t\t    &options->num_channel_timeouts, arg);\n\t\t}\n\t\tbreak;\n\n\tcase sUnusedConnectionTimeout:\n\t\tintptr = &options->unused_connection_timeout;\n\t\t \n\t\tif (av[0] != NULL && strcasecmp(av[0], \"none\") == 0) {\n\t\t\t(void)argv_next(&ac, &av);  \n\t\t\tif (*activep)\n\t\t\t\t*intptr = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto parse_time;\n\n\tcase sDeprecated:\n\tcase sIgnore:\n\tcase sUnsupported:\n\t\tdo_log2(opcode == sIgnore ?\n\t\t    SYSLOG_LEVEL_DEBUG2 : SYSLOG_LEVEL_INFO,\n\t\t    \"%s line %d: %s option %s\", filename, linenum,\n\t\t    opcode == sUnsupported ? \"Unsupported\" : \"Deprecated\",\n\t\t    keyword);\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tdefault:\n\t\tfatal(\"%s line %d: Missing handler for opcode %s (%d)\",\n\t\t    filename, linenum, keyword, opcode);\n\t}\n\t \n\tif (ac > 0) {\n\t\terror(\"%.200s line %d: keyword %s extra arguments \"\n\t\t    \"at end of line\", filename, linenum, keyword);\n\t\tgoto out;\n\t}\n\n\t \n\tret = 0;\n out:\n\targv_free(oav, oac);\n\treturn ret;\n}\n\nint\nprocess_server_config_line(ServerOptions *options, char *line,\n    const char *filename, int linenum, int *activep,\n    struct connection_info *connectinfo, struct include_list *includes)\n{\n\tint inc_flags = 0;\n\n\treturn process_server_config_line_depth(options, line, filename,\n\t    linenum, activep, connectinfo, &inc_flags, 0, includes);\n}\n\n\n \n\nvoid\nload_server_config(const char *filename, struct sshbuf *conf)\n{\n\tstruct stat st;\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tFILE *f;\n\tint r;\n\n\tdebug2_f(\"filename %s\", filename);\n\tif ((f = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\texit(1);\n\t}\n\tsshbuf_reset(conf);\n\t \n\tif (fstat(fileno(f), &st) == 0 && st.st_size > 0 &&\n\t    (r = sshbuf_allocate(conf, st.st_size)) != 0)\n\t\tfatal_fr(r, \"allocate\");\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t \n\t\tcp = line + strspn(line, \" \\t\\r\");\n\t\tif ((r = sshbuf_put(conf, cp, strlen(cp))) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_put\");\n\t}\n\tfree(line);\n\tif ((r = sshbuf_put_u8(conf, 0)) != 0)\n\t\tfatal_fr(r, \"sshbuf_put_u8\");\n\tfclose(f);\n\tdebug2_f(\"done config len = %zu\", sshbuf_len(conf));\n}\n\nvoid\nparse_server_match_config(ServerOptions *options,\n   struct include_list *includes, struct connection_info *connectinfo)\n{\n\tServerOptions mo;\n\n\tinitialize_server_options(&mo);\n\tparse_server_config(&mo, \"reprocess config\", cfg, includes,\n\t    connectinfo, 0);\n\tcopy_set_server_options(options, &mo, 0);\n}\n\nint parse_server_match_testspec(struct connection_info *ci, char *spec)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&spec, \",\")) && *p != '\\0') {\n\t\tif (strncmp(p, \"addr=\", 5) == 0) {\n\t\t\tci->address = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"host=\", 5) == 0) {\n\t\t\tci->host = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"user=\", 5) == 0) {\n\t\t\tci->user = xstrdup(p + 5);\n\t\t} else if (strncmp(p, \"laddr=\", 6) == 0) {\n\t\t\tci->laddress = xstrdup(p + 6);\n\t\t} else if (strncmp(p, \"rdomain=\", 8) == 0) {\n\t\t\tci->rdomain = xstrdup(p + 8);\n\t\t} else if (strncmp(p, \"lport=\", 6) == 0) {\n\t\t\tci->lport = a2port(p + 6);\n\t\t\tif (ci->lport == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid port '%s' in test mode\"\n\t\t\t\t    \" specification %s\\n\", p+6, p);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"Invalid test mode specification %s\\n\",\n\t\t\t    p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nservconf_merge_subsystems(ServerOptions *dst, ServerOptions *src)\n{\n\tu_int i, j, found;\n\n\tfor (i = 0; i < src->num_subsystems; i++) {\n\t\tfound = 0;\n\t\tfor (j = 0; j < dst->num_subsystems; j++) {\n\t\t\tif (strcmp(src->subsystem_name[i],\n\t\t\t    dst->subsystem_name[j]) == 0) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tdebug_f(\"override \\\"%s\\\"\", dst->subsystem_name[j]);\n\t\t\tfree(dst->subsystem_command[j]);\n\t\t\tfree(dst->subsystem_args[j]);\n\t\t\tdst->subsystem_command[j] =\n\t\t\t    xstrdup(src->subsystem_command[i]);\n\t\t\tdst->subsystem_args[j] =\n\t\t\t    xstrdup(src->subsystem_args[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug_f(\"add \\\"%s\\\"\", src->subsystem_name[i]);\n\t\tdst->subsystem_name = xrecallocarray(\n\t\t    dst->subsystem_name, dst->num_subsystems,\n\t\t    dst->num_subsystems + 1, sizeof(*dst->subsystem_name));\n\t\tdst->subsystem_command = xrecallocarray(\n\t\t    dst->subsystem_command, dst->num_subsystems,\n\t\t    dst->num_subsystems + 1, sizeof(*dst->subsystem_command));\n\t\tdst->subsystem_args = xrecallocarray(\n\t\t    dst->subsystem_args, dst->num_subsystems,\n\t\t    dst->num_subsystems + 1, sizeof(*dst->subsystem_args));\n\t\tj = dst->num_subsystems++;\n\t\tdst->subsystem_name[j] = xstrdup(src->subsystem_name[i]);\n\t\tdst->subsystem_command[j] = xstrdup(src->subsystem_command[i]);\n\t\tdst->subsystem_args[j] = xstrdup(src->subsystem_args[i]);\n\t}\n}\n\n \nvoid\ncopy_set_server_options(ServerOptions *dst, ServerOptions *src, int preauth)\n{\n#define M_CP_INTOPT(n) do {\\\n\tif (src->n != -1) \\\n\t\tdst->n = src->n; \\\n} while (0)\n\n\tM_CP_INTOPT(password_authentication);\n\tM_CP_INTOPT(gss_authentication);\n\tM_CP_INTOPT(pubkey_authentication);\n\tM_CP_INTOPT(pubkey_auth_options);\n\tM_CP_INTOPT(kerberos_authentication);\n\tM_CP_INTOPT(hostbased_authentication);\n\tM_CP_INTOPT(hostbased_uses_name_from_packet_only);\n\tM_CP_INTOPT(kbd_interactive_authentication);\n\tM_CP_INTOPT(permit_root_login);\n\tM_CP_INTOPT(permit_empty_passwd);\n\tM_CP_INTOPT(ignore_rhosts);\n\n\tM_CP_INTOPT(allow_tcp_forwarding);\n\tM_CP_INTOPT(allow_streamlocal_forwarding);\n\tM_CP_INTOPT(allow_agent_forwarding);\n\tM_CP_INTOPT(disable_forwarding);\n\tM_CP_INTOPT(expose_userauth_info);\n\tM_CP_INTOPT(permit_tun);\n\tM_CP_INTOPT(fwd_opts.gateway_ports);\n\tM_CP_INTOPT(fwd_opts.streamlocal_bind_unlink);\n\tM_CP_INTOPT(x11_display_offset);\n\tM_CP_INTOPT(x11_forwarding);\n\tM_CP_INTOPT(x11_use_localhost);\n\tM_CP_INTOPT(permit_tty);\n\tM_CP_INTOPT(permit_user_rc);\n\tM_CP_INTOPT(max_sessions);\n\tM_CP_INTOPT(max_authtries);\n\tM_CP_INTOPT(client_alive_count_max);\n\tM_CP_INTOPT(client_alive_interval);\n\tM_CP_INTOPT(ip_qos_interactive);\n\tM_CP_INTOPT(ip_qos_bulk);\n\tM_CP_INTOPT(rekey_limit);\n\tM_CP_INTOPT(rekey_interval);\n\tM_CP_INTOPT(log_level);\n\tM_CP_INTOPT(required_rsa_size);\n\tM_CP_INTOPT(unused_connection_timeout);\n\n\t \n\tif (src->fwd_opts.streamlocal_bind_mask != (mode_t)-1) {\n\t\tdst->fwd_opts.streamlocal_bind_mask =\n\t\t    src->fwd_opts.streamlocal_bind_mask;\n\t}\n\n\t \n#define M_CP_STROPT(n) do {\\\n\tif (src->n != NULL && dst->n != src->n) { \\\n\t\tfree(dst->n); \\\n\t\tdst->n = src->n; \\\n\t} \\\n} while(0)\n#define M_CP_STRARRAYOPT(s, num_s) do {\\\n\tu_int i; \\\n\tif (src->num_s != 0) { \\\n\t\tfor (i = 0; i < dst->num_s; i++) \\\n\t\t\tfree(dst->s[i]); \\\n\t\tfree(dst->s); \\\n\t\tdst->s = xcalloc(src->num_s, sizeof(*dst->s)); \\\n\t\tfor (i = 0; i < src->num_s; i++) \\\n\t\t\tdst->s[i] = xstrdup(src->s[i]); \\\n\t\tdst->num_s = src->num_s; \\\n\t} \\\n} while(0)\n\n\t \n\tCOPY_MATCH_STRING_OPTS();\n\n\t \n\tassemble_algorithms(dst);\n\n\t \n\tif (preauth)\n\t\treturn;\n\n\t \n\tM_CP_STROPT(adm_forced_command);\n\tif (option_clear_or_none(dst->adm_forced_command)) {\n\t\tfree(dst->adm_forced_command);\n\t\tdst->adm_forced_command = NULL;\n\t}\n\tM_CP_STROPT(chroot_directory);\n\tif (option_clear_or_none(dst->chroot_directory)) {\n\t\tfree(dst->chroot_directory);\n\t\tdst->chroot_directory = NULL;\n\t}\n\n\t \n\tservconf_merge_subsystems(dst, src);\n}\n\n#undef M_CP_INTOPT\n#undef M_CP_STROPT\n#undef M_CP_STRARRAYOPT\n\n#define SERVCONF_MAX_DEPTH\t16\nstatic void\nparse_server_config_depth(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct include_list *includes,\n    struct connection_info *connectinfo, int flags, int *activep, int depth)\n{\n\tint linenum, bad_options = 0;\n\tchar *cp, *obuf, *cbuf;\n\n\tif (depth < 0 || depth > SERVCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tdebug2_f(\"config %s len %zu%s\", filename, sshbuf_len(conf),\n\t    (flags & SSHCFG_NEVERMATCH ? \" [checking syntax only]\" : \"\"));\n\n\tif ((obuf = cbuf = sshbuf_dup_string(conf)) == NULL)\n\t\tfatal_f(\"sshbuf_dup_string failed\");\n\tlinenum = 1;\n\twhile ((cp = strsep(&cbuf, \"\\n\")) != NULL) {\n\t\tif (process_server_config_line_depth(options, cp,\n\t\t    filename, linenum++, activep, connectinfo, &flags,\n\t\t    depth, includes) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(obuf);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n}\n\nvoid\nparse_server_config(ServerOptions *options, const char *filename,\n    struct sshbuf *conf, struct include_list *includes,\n    struct connection_info *connectinfo, int reexec)\n{\n\tint active = connectinfo ? 0 : 1;\n\tparse_server_config_depth(options, filename, conf, includes,\n\t    connectinfo, (connectinfo ? SSHCFG_MATCH_ONLY : 0), &active, 0);\n\tif (!reexec)\n\t\tprocess_queued_listen_addrs(options);\n}\n\nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}\n\nstatic const char *\nfmt_intarg(ServerOpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase sAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase sPermitRootLogin:\n\t\treturn fmt_multistate_int(val, multistate_permitrootlogin);\n\tcase sGatewayPorts:\n\t\treturn fmt_multistate_int(val, multistate_gatewayports);\n\tcase sCompression:\n\t\treturn fmt_multistate_int(val, multistate_compression);\n\tcase sAllowTcpForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sAllowStreamLocalForwarding:\n\t\treturn fmt_multistate_int(val, multistate_tcpfwd);\n\tcase sIgnoreRhosts:\n\t\treturn fmt_multistate_int(val, multistate_ignore_rhosts);\n\tcase sFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}\n\nstatic void\ndump_cfg_int(ServerOpCodes code, int val)\n{\n\tif (code == sUnusedConnectionTimeout && val == 0) {\n\t\tprintf(\"%s none\\n\", lookup_opcode_name(code));\n\t\treturn;\n\t}\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}\n\nstatic void\ndump_cfg_oct(ServerOpCodes code, int val)\n{\n\tprintf(\"%s 0%o\\n\", lookup_opcode_name(code), val);\n}\n\nstatic void\ndump_cfg_fmtint(ServerOpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}\n\nstatic void\ndump_cfg_string(ServerOpCodes code, const char *val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code),\n\t    val == NULL ? \"none\" : val);\n}\n\nstatic void\ndump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}\n\nstatic void\ndump_cfg_strarray_oneline(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tswitch (code) {\n\tcase sAuthenticationMethods:\n\tcase sChannelTimeout:\n\t\tbreak;\n\tdefault:\n\t\tif (count <= 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tif (code == sAuthenticationMethods && count == 0)\n\t\tprintf(\" any\");\n\telse if (code == sChannelTimeout && count == 0)\n\t\tprintf(\" none\");\n\tprintf(\"\\n\");\n}\n\nstatic char *\nformat_listen_addrs(struct listenaddr *la)\n{\n\tint r;\n\tstruct addrinfo *ai;\n\tchar addr[NI_MAXHOST], port[NI_MAXSERV];\n\tchar *laddr1 = xstrdup(\"\"), *laddr2 = NULL;\n\n\t \n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif ((r = getnameinfo(ai->ai_addr, ai->ai_addrlen, addr,\n\t\t    sizeof(addr), port, sizeof(port),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo: %.100s\", ssh_gai_strerror(r));\n\t\t\tcontinue;\n\t\t}\n\t\tladdr2 = laddr1;\n\t\tif (ai->ai_family == AF_INET6) {\n\t\t\txasprintf(&laddr1, \"listenaddress [%s]:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t} else {\n\t\t\txasprintf(&laddr1, \"listenaddress %s:%s%s%s\\n%s\",\n\t\t\t    addr, port,\n\t\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t\t    la->rdomain == NULL ? \"\" : la->rdomain,\n\t\t\t    laddr2);\n\t\t}\n\t\tfree(laddr2);\n\t}\n\treturn laddr1;\n}\n\nvoid\ndump_config(ServerOptions *o)\n{\n\tchar *s;\n\tu_int i;\n\n\t \n\tfor (i = 0; i < o->num_ports; i++)\n\t\tprintf(\"port %d\\n\", o->ports[i]);\n\tdump_cfg_fmtint(sAddressFamily, o->address_family);\n\n\tfor (i = 0; i < o->num_listen_addrs; i++) {\n\t\ts = format_listen_addrs(&o->listen_addrs[i]);\n\t\tprintf(\"%s\", s);\n\t\tfree(s);\n\t}\n\n\t \n#ifdef USE_PAM\n\tdump_cfg_fmtint(sUsePAM, o->use_pam);\n#endif\n\tdump_cfg_int(sLoginGraceTime, o->login_grace_time);\n\tdump_cfg_int(sX11DisplayOffset, o->x11_display_offset);\n\tdump_cfg_int(sMaxAuthTries, o->max_authtries);\n\tdump_cfg_int(sMaxSessions, o->max_sessions);\n\tdump_cfg_int(sClientAliveInterval, o->client_alive_interval);\n\tdump_cfg_int(sClientAliveCountMax, o->client_alive_count_max);\n\tdump_cfg_int(sRequiredRSASize, o->required_rsa_size);\n\tdump_cfg_oct(sStreamLocalBindMask, o->fwd_opts.streamlocal_bind_mask);\n\tdump_cfg_int(sUnusedConnectionTimeout, o->unused_connection_timeout);\n\n\t \n\tdump_cfg_fmtint(sPermitRootLogin, o->permit_root_login);\n\tdump_cfg_fmtint(sIgnoreRhosts, o->ignore_rhosts);\n\tdump_cfg_fmtint(sIgnoreUserKnownHosts, o->ignore_user_known_hosts);\n\tdump_cfg_fmtint(sHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(sHostbasedUsesNameFromPacketOnly,\n\t    o->hostbased_uses_name_from_packet_only);\n\tdump_cfg_fmtint(sPubkeyAuthentication, o->pubkey_authentication);\n#ifdef KRB5\n\tdump_cfg_fmtint(sKerberosAuthentication, o->kerberos_authentication);\n\tdump_cfg_fmtint(sKerberosOrLocalPasswd, o->kerberos_or_local_passwd);\n\tdump_cfg_fmtint(sKerberosTicketCleanup, o->kerberos_ticket_cleanup);\n# ifdef USE_AFS\n\tdump_cfg_fmtint(sKerberosGetAFSToken, o->kerberos_get_afs_token);\n# endif\n#endif\n#ifdef GSSAPI\n\tdump_cfg_fmtint(sGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);\n#endif\n\tdump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(sKbdInteractiveAuthentication,\n\t    o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(sPrintMotd, o->print_motd);\n#ifndef DISABLE_LASTLOG\n\tdump_cfg_fmtint(sPrintLastLog, o->print_lastlog);\n#endif\n\tdump_cfg_fmtint(sX11Forwarding, o->x11_forwarding);\n\tdump_cfg_fmtint(sX11UseLocalhost, o->x11_use_localhost);\n\tdump_cfg_fmtint(sPermitTTY, o->permit_tty);\n\tdump_cfg_fmtint(sPermitUserRC, o->permit_user_rc);\n\tdump_cfg_fmtint(sStrictModes, o->strict_modes);\n\tdump_cfg_fmtint(sTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(sEmptyPasswd, o->permit_empty_passwd);\n\tdump_cfg_fmtint(sCompression, o->compression);\n\tdump_cfg_fmtint(sGatewayPorts, o->fwd_opts.gateway_ports);\n\tdump_cfg_fmtint(sUseDNS, o->use_dns);\n\tdump_cfg_fmtint(sAllowTcpForwarding, o->allow_tcp_forwarding);\n\tdump_cfg_fmtint(sAllowAgentForwarding, o->allow_agent_forwarding);\n\tdump_cfg_fmtint(sDisableForwarding, o->disable_forwarding);\n\tdump_cfg_fmtint(sAllowStreamLocalForwarding, o->allow_streamlocal_forwarding);\n\tdump_cfg_fmtint(sStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(sFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(sExposeAuthInfo, o->expose_userauth_info);\n\n\t \n\tdump_cfg_string(sPidFile, o->pid_file);\n\tdump_cfg_string(sModuliFile, o->moduli_file);\n\tdump_cfg_string(sXAuthLocation, o->xauth_location);\n\tdump_cfg_string(sCiphers, o->ciphers);\n\tdump_cfg_string(sMacs, o->macs);\n\tdump_cfg_string(sBanner, o->banner);\n\tdump_cfg_string(sForceCommand, o->adm_forced_command);\n\tdump_cfg_string(sChrootDirectory, o->chroot_directory);\n\tdump_cfg_string(sTrustedUserCAKeys, o->trusted_user_ca_keys);\n\tdump_cfg_string(sRevokedKeys, o->revoked_keys_file);\n\tdump_cfg_string(sSecurityKeyProvider, o->sk_provider);\n\tdump_cfg_string(sAuthorizedPrincipalsFile,\n\t    o->authorized_principals_file);\n\tdump_cfg_string(sVersionAddendum, *o->version_addendum == '\\0'\n\t    ? \"none\" : o->version_addendum);\n\tdump_cfg_string(sAuthorizedKeysCommand, o->authorized_keys_command);\n\tdump_cfg_string(sAuthorizedKeysCommandUser, o->authorized_keys_command_user);\n\tdump_cfg_string(sAuthorizedPrincipalsCommand, o->authorized_principals_command);\n\tdump_cfg_string(sAuthorizedPrincipalsCommandUser, o->authorized_principals_command_user);\n\tdump_cfg_string(sHostKeyAgent, o->host_key_agent);\n\tdump_cfg_string(sKexAlgorithms, o->kex_algorithms);\n\tdump_cfg_string(sCASignatureAlgorithms, o->ca_sign_algorithms);\n\tdump_cfg_string(sHostbasedAcceptedAlgorithms, o->hostbased_accepted_algos);\n\tdump_cfg_string(sHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(sPubkeyAcceptedAlgorithms, o->pubkey_accepted_algos);\n#if defined(__OpenBSD__) || defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\tdump_cfg_string(sRDomain, o->routing_domain);\n#endif\n\n\t \n\tdump_cfg_string(sLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(sLogFacility, log_facility_name(o->log_facility));\n\n\t \n\tdump_cfg_strarray_oneline(sAuthorizedKeysFile, o->num_authkeys_files,\n\t    o->authorized_keys_files);\n\tdump_cfg_strarray(sHostKeyFile, o->num_host_key_files,\n\t    o->host_key_files);\n\tdump_cfg_strarray(sHostCertificate, o->num_host_cert_files,\n\t    o->host_cert_files);\n\tdump_cfg_strarray(sAllowUsers, o->num_allow_users, o->allow_users);\n\tdump_cfg_strarray(sDenyUsers, o->num_deny_users, o->deny_users);\n\tdump_cfg_strarray(sAllowGroups, o->num_allow_groups, o->allow_groups);\n\tdump_cfg_strarray(sDenyGroups, o->num_deny_groups, o->deny_groups);\n\tdump_cfg_strarray(sAcceptEnv, o->num_accept_env, o->accept_env);\n\tdump_cfg_strarray(sSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(sAuthenticationMethods,\n\t    o->num_auth_methods, o->auth_methods);\n\tdump_cfg_strarray_oneline(sLogVerbose,\n\t    o->num_log_verbose, o->log_verbose);\n\tdump_cfg_strarray_oneline(sChannelTimeout,\n\t    o->num_channel_timeouts, o->channel_timeouts);\n\n\t \n\tfor (i = 0; i < o->num_subsystems; i++)\n\t\tprintf(\"subsystem %s %s\\n\", o->subsystem_name[i],\n\t\t    o->subsystem_args[i]);\n\n\tprintf(\"maxstartups %d:%d:%d\\n\", o->max_startups_begin,\n\t    o->max_startups_rate, o->max_startups);\n\tprintf(\"persourcemaxstartups \");\n\tif (o->per_source_max_startups == INT_MAX)\n\t\tprintf(\"none\\n\");\n\telse\n\t\tprintf(\"%d\\n\", o->per_source_max_startups);\n\tprintf(\"persourcenetblocksize %d:%d\\n\", o->per_source_masklen_ipv4,\n\t    o->per_source_masklen_ipv6);\n\n\ts = NULL;\n\tfor (i = 0; tunmode_desc[i].val != -1; i++) {\n\t\tif (tunmode_desc[i].val == o->permit_tun) {\n\t\t\ts = tunmode_desc[i].text;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdump_cfg_string(sPermitTunnel, s);\n\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\tprintf(\"rekeylimit %llu %d\\n\", (unsigned long long)o->rekey_limit,\n\t    o->rekey_interval);\n\n\tprintf(\"permitopen\");\n\tif (o->num_permitted_opens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_opens; i++)\n\t\t\tprintf(\" %s\", o->permitted_opens[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"permitlisten\");\n\tif (o->num_permitted_listens == 0)\n\t\tprintf(\" any\");\n\telse {\n\t\tfor (i = 0; i < o->num_permitted_listens; i++)\n\t\t\tprintf(\" %s\", o->permitted_listens[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tif (o->permit_user_env_allowlist == NULL) {\n\t\tdump_cfg_fmtint(sPermitUserEnvironment, o->permit_user_env);\n\t} else {\n\t\tprintf(\"permituserenvironment %s\\n\",\n\t\t    o->permit_user_env_allowlist);\n\t}\n\n\tprintf(\"pubkeyauthoptions\");\n\tif (o->pubkey_auth_options == 0)\n\t\tprintf(\" none\");\n\tif (o->pubkey_auth_options & PUBKEYAUTH_TOUCH_REQUIRED)\n\t\tprintf(\" touch-required\");\n\tif (o->pubkey_auth_options & PUBKEYAUTH_VERIFY_REQUIRED)\n\t\tprintf(\" verify-required\");\n\tprintf(\"\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}