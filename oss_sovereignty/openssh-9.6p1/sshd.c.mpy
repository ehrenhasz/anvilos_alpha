{
  "module_name": "sshd.c",
  "hash_id": "403315b9a0b7c2286a736244680a63dd4468310905cd363bb377209b5afbee88",
  "original_prompt": "Ingested from openssh-9.6p1/sshd.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include \"openbsd-compat/sys-tree.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#include <grp.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/dh.h>\n#include <openssl/bn.h>\n#include <openssl/rand.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#ifdef HAVE_SECUREWARE\n#include <sys/security.h>\n#include <prot.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshpty.h\"\n#include \"packet.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"servconf.h\"\n#include \"uidswap.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"digest.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"authfile.h\"\n#include \"pathnames.h\"\n#include \"atomicio.h\"\n#include \"canohost.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"authfd.h\"\n#include \"msg.h\"\n#include \"dispatch.h\"\n#include \"channels.h\"\n#include \"session.h\"\n#include \"monitor.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"ssh-sandbox.h\"\n#include \"auth-options.h\"\n#include \"version.h\"\n#include \"ssherr.h\"\n#include \"sk-api.h\"\n#include \"srclimit.h\"\n#include \"dh.h\"\n\n \n#define REEXEC_DEVCRYPTO_RESERVED_FD\t(STDERR_FILENO + 1)\n#define REEXEC_STARTUP_PIPE_FD\t\t(STDERR_FILENO + 2)\n#define REEXEC_CONFIG_PASS_FD\t\t(STDERR_FILENO + 3)\n#define REEXEC_MIN_FREE_FD\t\t(STDERR_FILENO + 4)\n\nextern char *__progname;\n\n \nServerOptions options;\n\n \nchar *config_file_name = _PATH_SERVER_CONFIG_FILE;\n\n \nint debug_flag = 0;\n\n \nstatic int test_flag = 0;\n\n \nstatic int inetd_flag = 0;\n\n \nstatic int no_daemon_flag = 0;\n\n \nstatic int log_stderr = 0;\n\n \nstatic char **saved_argv;\nstatic int saved_argc;\n\n \nstatic int rexeced_flag = 0;\nstatic int rexec_flag = 1;\nstatic int rexec_argc = 0;\nstatic char **rexec_argv;\n\n \n#define\tMAX_LISTEN_SOCKS\t16\nstatic int listen_socks[MAX_LISTEN_SOCKS];\nstatic int num_listen_socks = 0;\n\n \nint auth_sock = -1;\nstatic int have_agent = 0;\n\n \nstruct {\n\tstruct sshkey\t**host_keys;\t\t \n\tstruct sshkey\t**host_pubkeys;\t\t \n\tstruct sshkey\t**host_certificates;\t \n\tint\t\thave_ssh2_key;\n} sensitive_data;\n\n \nstatic volatile sig_atomic_t received_sighup = 0;\nstatic volatile sig_atomic_t received_sigterm = 0;\n\n \nu_int utmp_len = HOST_NAME_MAX+1;\n\n \nstatic int *startup_pipes = NULL;\nstatic int *startup_flags = NULL;\t \nstatic int startup_pipe = -1;\t\t \n\n \nint use_privsep = -1;\nstruct monitor *pmonitor = NULL;\nint privsep_is_preauth = 1;\nstatic int privsep_chroot = 1;\n\n \nAuthctxt *the_authctxt = NULL;\nstruct ssh *the_active_state;\n\n \nstruct sshauthopt *auth_opts = NULL;\n\n \nstruct sshbuf *cfg;\n\n \nstruct include_list includes = TAILQ_HEAD_INITIALIZER(includes);\n\n \nstruct sshbuf *loginmsg;\n\n \nstruct passwd *privsep_pw = NULL;\n\n \nvoid destroy_sensitive_data(void);\nvoid demote_sensitive_data(void);\nstatic void do_ssh2_kex(struct ssh *);\n\nstatic char *listener_proctitle;\n\n \nstatic void\nclose_listen_socks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < num_listen_socks; i++)\n\t\tclose(listen_socks[i]);\n\tnum_listen_socks = 0;\n}\n\nstatic void\nclose_startup_pipes(void)\n{\n\tint i;\n\n\tif (startup_pipes)\n\t\tfor (i = 0; i < options.max_startups; i++)\n\t\t\tif (startup_pipes[i] != -1)\n\t\t\t\tclose(startup_pipes[i]);\n}\n\n \n\nstatic void\nsighup_handler(int sig)\n{\n\treceived_sighup = 1;\n}\n\n \nstatic void\nsighup_restart(void)\n{\n\tlogit(\"Received SIGHUP; restarting.\");\n\tif (options.pid_file != NULL)\n\t\tunlink(options.pid_file);\n\tplatform_pre_restart();\n\tclose_listen_socks();\n\tclose_startup_pipes();\n\tssh_signal(SIGHUP, SIG_IGN);  \n\texecv(saved_argv[0], saved_argv);\n\tlogit(\"RESTART FAILED: av[0]='%.100s', error: %.100s.\", saved_argv[0],\n\t    strerror(errno));\n\texit(1);\n}\n\n \nstatic void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}\n\n \nstatic void\nmain_sigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tint status;\n\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t    (pid == -1 && errno == EINTR))\n\t\t;\n\terrno = save_errno;\n}\n\n \nstatic void\ngrace_alarm_handler(int sig)\n{\n\t \n\tif (getpgid(0) == getpid()) {\n\t\tssh_signal(SIGTERM, SIG_IGN);\n\t\tkill(0, SIGTERM);\n\t}\n\n\t \n\tsigdie(\"Timeout before authentication for %s port %d\",\n\t    ssh_remote_ipaddr(the_active_state),\n\t    ssh_remote_port(the_active_state));\n}\n\n \nvoid\ndestroy_sensitive_data(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t}\n\t\tif (sensitive_data.host_certificates[i]) {\n\t\t\tsshkey_free(sensitive_data.host_certificates[i]);\n\t\t\tsensitive_data.host_certificates[i] = NULL;\n\t\t}\n\t}\n}\n\n \nvoid\ndemote_sensitive_data(void)\n{\n\tstruct sshkey *tmp;\n\tu_int i;\n\tint r;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sensitive_data.host_keys[i]) {\n\t\t\tif ((r = sshkey_from_private(\n\t\t\t    sensitive_data.host_keys[i], &tmp)) != 0)\n\t\t\t\tfatal_r(r, \"could not demote host %s key\",\n\t\t\t\t    sshkey_type(sensitive_data.host_keys[i]));\n\t\t\tsshkey_free(sensitive_data.host_keys[i]);\n\t\t\tsensitive_data.host_keys[i] = tmp;\n\t\t}\n\t\t \n\t}\n}\n\nstatic void\nreseed_prngs(void)\n{\n\tu_int32_t rnd[256];\n\n#ifdef WITH_OPENSSL\n\tRAND_poll();\n#endif\n\tarc4random_stir();  \n\tarc4random_buf(rnd, sizeof(rnd));  \n\n#ifdef WITH_OPENSSL\n\tRAND_seed(rnd, sizeof(rnd));\n\t \n\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\n\texplicit_bzero(rnd, sizeof(rnd));\n}\n\nstatic void\nprivsep_preauth_child(void)\n{\n\tgid_t gidset[1];\n\n\t \n\tprivsep_challenge_enable();\n\n#ifdef GSSAPI\n\t \n\tssh_gssapi_prepare_supported_oids();\n#endif\n\n\treseed_prngs();\n\n\t \n\tdemote_sensitive_data();\n\n\t \n\tif (privsep_chroot) {\n\t\t \n\t\tif (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)\n\t\t\tfatal(\"chroot(\\\"%s\\\"): %s\", _PATH_PRIVSEP_CHROOT_DIR,\n\t\t\t    strerror(errno));\n\t\tif (chdir(\"/\") == -1)\n\t\t\tfatal(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t\t \n\t\tdebug3(\"privsep user:group %u:%u\", (u_int)privsep_pw->pw_uid,\n\t\t    (u_int)privsep_pw->pw_gid);\n\t\tgidset[0] = privsep_pw->pw_gid;\n\t\tif (setgroups(1, gidset) == -1)\n\t\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\t\tpermanently_set_uid(privsep_pw);\n\t}\n}\n\nstatic int\nprivsep_preauth(struct ssh *ssh)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\n\t \n\tpmonitor = monitor_init();\n\t \n\tpmonitor->m_pkex = &ssh->kex;\n\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init(pmonitor);\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror_r(r, \"Could not get agent socket\");\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(ssh, pmonitor);\n\n\t\t \n\t\twhile (waitpid(pid, &status, 0) == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal_f(\"waitpid: %s\", strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal_f(\"preauth child exited with status %d\",\n\t\t\t\t    WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal_f(\"preauth child terminated by signal %d\",\n\t\t\t    WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\t \n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\n\t\t \n\t\tset_log_handler(mm_log_handler, pmonitor);\n\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\n\t\treturn 0;\n\t}\n}\n\nstatic void\nprivsep_postauth(struct ssh *ssh, Authctxt *authctxt)\n{\n#ifdef DISABLE_FD_PASSING\n\tif (1) {\n#else\n\tif (authctxt->pw->pw_uid == 0) {\n#endif\n\t\t \n\t\tuse_privsep = 0;\n\t\tgoto skip;\n\t}\n\n\t \n\tmonitor_reinit(pmonitor);\n\n\tpmonitor->m_pid = fork();\n\tif (pmonitor->m_pid == -1)\n\t\tfatal(\"fork of unprivileged child failed\");\n\telse if (pmonitor->m_pid != 0) {\n\t\tverbose(\"User child is on pid %ld\", (long)pmonitor->m_pid);\n\t\tsshbuf_reset(loginmsg);\n\t\tmonitor_clear_keystate(ssh, pmonitor);\n\t\tmonitor_child_postauth(ssh, pmonitor);\n\n\t\t \n\t\texit(0);\n\t}\n\n\t \n\n\tclose(pmonitor->m_sendfd);\n\tpmonitor->m_sendfd = -1;\n\n\t \n\tdemote_sensitive_data();\n\n\treseed_prngs();\n\n\t \n\tdo_setusercontext(authctxt->pw);\n\n skip:\n\t \n\tmonitor_apply_keystate(ssh, pmonitor);\n\n\t \n\tssh_packet_set_authenticated(ssh);\n}\n\nstatic void\nappend_hostkey_type(struct sshbuf *b, const char *s)\n{\n\tint r;\n\n\tif (match_pattern_list(s, options.hostkeyalgorithms, 0) != 1) {\n\t\tdebug3_f(\"%s key not permitted by HostkeyAlgorithms\", s);\n\t\treturn;\n\t}\n\tif ((r = sshbuf_putf(b, \"%s%s\", sshbuf_len(b) > 0 ? \",\" : \"\", s)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putf\");\n}\n\nstatic char *\nlist_hostkey_types(void)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key;\n\tchar *ret;\n\tu_int i;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tkey = sensitive_data.host_keys[i];\n\t\tif (key == NULL)\n\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA:\n\t\t\t \n\t\t\tappend_hostkey_type(b, \"rsa-sha2-512\");\n\t\t\tappend_hostkey_type(b, \"rsa-sha2-256\");\n\t\t\t \n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ECDSA_SK:\n\t\tcase KEY_ED25519_SK:\n\t\tcase KEY_XMSS:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tkey = sensitive_data.host_certificates[i];\n\t\tif (key == NULL)\n\t\t\tcontinue;\n\t\tswitch (key->type) {\n\t\tcase KEY_RSA_CERT:\n\t\t\t \n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-512-cert-v01@openssh.com\");\n\t\t\tappend_hostkey_type(b,\n\t\t\t    \"rsa-sha2-256-cert-v01@openssh.com\");\n\t\t\t \n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_ECDSA_SK_CERT:\n\t\tcase KEY_ED25519_SK_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tappend_hostkey_type(b, sshkey_ssh_name(key));\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((ret = sshbuf_dup_string(b)) == NULL)\n\t\tfatal_f(\"sshbuf_dup_string failed\");\n\tsshbuf_free(b);\n\tdebug_f(\"%s\", ret);\n\treturn ret;\n}\n\nstatic struct sshkey *\nget_hostkey_by_type(int type, int nid, int need_private, struct ssh *ssh)\n{\n\tu_int i;\n\tstruct sshkey *key;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tswitch (type) {\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ED25519_CERT:\n\t\tcase KEY_ECDSA_SK_CERT:\n\t\tcase KEY_ED25519_SK_CERT:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tkey = sensitive_data.host_certificates[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkey = sensitive_data.host_keys[i];\n\t\t\tif (key == NULL && !need_private)\n\t\t\t\tkey = sensitive_data.host_pubkeys[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (key == NULL || key->type != type)\n\t\t\tcontinue;\n\t\tswitch (type) {\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ECDSA_SK:\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA_SK_CERT:\n\t\t\tif (key->ecdsa_nid != nid)\n\t\t\t\tcontinue;\n\t\t\t \n\t\tdefault:\n\t\t\treturn need_private ?\n\t\t\t    sensitive_data.host_keys[i] : key;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct sshkey *\nget_hostkey_public_by_type(int type, int nid, struct ssh *ssh)\n{\n\treturn get_hostkey_by_type(type, nid, 0, ssh);\n}\n\nstruct sshkey *\nget_hostkey_private_by_type(int type, int nid, struct ssh *ssh)\n{\n\treturn get_hostkey_by_type(type, nid, 1, ssh);\n}\n\nstruct sshkey *\nget_hostkey_by_index(int ind)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_keys[ind]);\n}\n\nstruct sshkey *\nget_hostkey_public_by_index(int ind, struct ssh *ssh)\n{\n\tif (ind < 0 || (u_int)ind >= options.num_host_key_files)\n\t\treturn (NULL);\n\treturn (sensitive_data.host_pubkeys[ind]);\n}\n\nint\nget_hostkey_index(struct sshkey *key, int compare, struct ssh *ssh)\n{\n\tu_int i;\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif (key == sensitive_data.host_certificates[i] ||\n\t\t\t    (compare && sensitive_data.host_certificates[i] &&\n\t\t\t    sshkey_equal(key,\n\t\t\t    sensitive_data.host_certificates[i])))\n\t\t\t\treturn (i);\n\t\t} else {\n\t\t\tif (key == sensitive_data.host_keys[i] ||\n\t\t\t    (compare && sensitive_data.host_keys[i] &&\n\t\t\t    sshkey_equal(key, sensitive_data.host_keys[i])))\n\t\t\t\treturn (i);\n\t\t\tif (key == sensitive_data.host_pubkeys[i] ||\n\t\t\t    (compare && sensitive_data.host_pubkeys[i] &&\n\t\t\t    sshkey_equal(key, sensitive_data.host_pubkeys[i])))\n\t\t\t\treturn (i);\n\t\t}\n\t}\n\treturn (-1);\n}\n\n \nstatic void\nnotify_hostkeys(struct ssh *ssh)\n{\n\tstruct sshbuf *buf;\n\tstruct sshkey *key;\n\tu_int i, nkeys;\n\tint r;\n\tchar *fp;\n\n\t \n\tif (ssh->compat & SSH_BUG_HOSTKEYS)\n\t\treturn;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tfor (i = nkeys = 0; i < options.num_host_key_files; i++) {\n\t\tkey = get_hostkey_public_by_index(i, ssh);\n\t\tif (key == NULL || key->type == KEY_UNSPEC ||\n\t\t    sshkey_is_cert(key))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3_f(\"key %d: %s %s\", i, sshkey_ssh_name(key), fp);\n\t\tfree(fp);\n\t\tif (nkeys == 0) {\n\t\t\t \n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t\t    (r = sshpkt_put_cstring(ssh, \"hostkeys-00@openssh.com\")) != 0 ||\n\t\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0)  \n\t\t\t\tsshpkt_fatal(ssh, r, \"%s: start request\", __func__);\n\t\t}\n\t\t \n\t\tsshbuf_reset(buf);\n\t\tif ((r = sshkey_putb(key, buf)) != 0)\n\t\t\tfatal_fr(r, \"couldn't put hostkey %d\", i);\n\t\tif ((r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: append key\", __func__);\n\t\tnkeys++;\n\t}\n\tdebug3_f(\"sent %u hostkeys\", nkeys);\n\tif (nkeys == 0)\n\t\tfatal_f(\"no hostkeys\");\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: send\", __func__);\n\tsshbuf_free(buf);\n}\n\n \nstatic int\nshould_drop_connection(int startups)\n{\n\tint p, r;\n\n\tif (startups < options.max_startups_begin)\n\t\treturn 0;\n\tif (startups >= options.max_startups)\n\t\treturn 1;\n\tif (options.max_startups_rate == 100)\n\t\treturn 1;\n\n\tp  = 100 - options.max_startups_rate;\n\tp *= startups - options.max_startups_begin;\n\tp /= options.max_startups - options.max_startups_begin;\n\tp += options.max_startups_rate;\n\tr = arc4random_uniform(100);\n\n\tdebug_f(\"p %d, r %d\", p, r);\n\treturn (r < p) ? 1 : 0;\n}\n\n \nstatic int\ndrop_connection(int sock, int startups, int notify_pipe)\n{\n\tchar *laddr, *raddr;\n\tconst char msg[] = \"Exceeded MaxStartups\\r\\n\";\n\tstatic time_t last_drop, first_drop;\n\tstatic u_int ndropped;\n\tLogLevel drop_level = SYSLOG_LEVEL_VERBOSE;\n\ttime_t now;\n\n\tnow = monotime();\n\tif (!should_drop_connection(startups) &&\n\t    srclimit_check_allow(sock, notify_pipe) == 1) {\n\t\tif (last_drop != 0 &&\n\t\t    startups < options.max_startups_begin - 1) {\n\t\t\t \n\t\t\tlogit(\"exited MaxStartups throttling after %s, \"\n\t\t\t    \"%u connections dropped\",\n\t\t\t    fmt_timeframe(now - first_drop), ndropped);\n\t\t\tlast_drop = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n#define SSHD_MAXSTARTUPS_LOG_INTERVAL\t(5 * 60)\n\tif (last_drop == 0) {\n\t\terror(\"beginning MaxStartups throttling\");\n\t\tdrop_level = SYSLOG_LEVEL_INFO;\n\t\tfirst_drop = now;\n\t\tndropped = 0;\n\t} else if (last_drop + SSHD_MAXSTARTUPS_LOG_INTERVAL < now) {\n\t\t \n\t\terror(\"in MaxStartups throttling for %s, \"\n\t\t    \"%u connections dropped\",\n\t\t    fmt_timeframe(now - first_drop), ndropped + 1);\n\t\tdrop_level = SYSLOG_LEVEL_INFO;\n\t}\n\tlast_drop = now;\n\tndropped++;\n\n\tladdr = get_local_ipaddr(sock);\n\traddr = get_peer_ipaddr(sock);\n\tdo_log2(drop_level, \"drop connection #%d from [%s]:%d on [%s]:%d \"\n\t    \"past MaxStartups\", startups, raddr, get_peer_port(sock),\n\t    laddr, get_local_port(sock));\n\tfree(laddr);\n\tfree(raddr);\n\t \n\t(void)write(sock, msg, sizeof(msg) - 1);\n\treturn 1;\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"%s, %s\\n\", SSH_RELEASE, SSH_OPENSSL_VERSION);\n\tfprintf(stderr,\n\"usage: sshd [-46DdeGiqTtV] [-C connection_spec] [-c host_cert_file]\\n\"\n\"            [-E log_file] [-f config_file] [-g login_grace_time]\\n\"\n\"            [-h host_key_file] [-o option] [-p port] [-u len]\\n\"\n\t);\n\texit(1);\n}\n\nstatic void\nsend_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m = NULL, *inc = NULL;\n\tstruct include_item *item = NULL;\n\tint r;\n\n\tdebug3_f(\"entering fd = %d config len %zu\", fd,\n\t    sshbuf_len(conf));\n\n\tif ((m = sshbuf_new()) == NULL || (inc = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\t \n\tTAILQ_FOREACH(item, &includes, entry) {\n\t\tif ((r = sshbuf_put_cstring(inc, item->selector)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(inc, item->filename)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(inc, item->contents)) != 0)\n\t\t\tfatal_fr(r, \"compose includes\");\n\t}\n\n\t \n\tif ((r = sshbuf_put_stringb(m, conf)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, inc)) != 0)\n\t\tfatal_fr(r, \"compose config\");\n\tif (ssh_msg_send(fd, 0, m) == -1)\n\t\terror_f(\"ssh_msg_send failed\");\n\n\tsshbuf_free(m);\n\tsshbuf_free(inc);\n\n\tdebug3_f(\"done\");\n}\n\nstatic void\nrecv_rexec_state(int fd, struct sshbuf *conf)\n{\n\tstruct sshbuf *m, *inc;\n\tu_char *cp, ver;\n\tsize_t len;\n\tint r;\n\tstruct include_item *item;\n\n\tdebug3_f(\"entering fd = %d\", fd);\n\n\tif ((m = sshbuf_new()) == NULL || (inc = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif (ssh_msg_recv(fd, m) == -1)\n\t\tfatal_f(\"ssh_msg_recv failed\");\n\tif ((r = sshbuf_get_u8(m, &ver)) != 0)\n\t\tfatal_fr(r, \"parse version\");\n\tif (ver != 0)\n\t\tfatal_f(\"rexec version mismatch\");\n\tif ((r = sshbuf_get_string(m, &cp, &len)) != 0 ||\n\t    (r = sshbuf_get_stringb(m, inc)) != 0)\n\t\tfatal_fr(r, \"parse config\");\n\n\tif (conf != NULL && (r = sshbuf_put(conf, cp, len)))\n\t\tfatal_fr(r, \"sshbuf_put\");\n\n\twhile (sshbuf_len(inc) != 0) {\n\t\titem = xcalloc(1, sizeof(*item));\n\t\tif ((item->contents = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\tif ((r = sshbuf_get_cstring(inc, &item->selector, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(inc, &item->filename, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_stringb(inc, item->contents)) != 0)\n\t\t\tfatal_fr(r, \"parse includes\");\n\t\tTAILQ_INSERT_TAIL(&includes, item, entry);\n\t}\n\n\tfree(cp);\n\tsshbuf_free(m);\n\n\tdebug3_f(\"done\");\n}\n\n \nstatic void\nserver_accept_inetd(int *sock_in, int *sock_out)\n{\n\tif (rexeced_flag) {\n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\t*sock_in = *sock_out = dup(STDIN_FILENO);\n\t} else {\n\t\t*sock_in = dup(STDIN_FILENO);\n\t\t*sock_out = dup(STDOUT_FILENO);\n\t}\n\t \n\tif (stdfd_devnull(1, 1, !log_stderr) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\tdebug(\"inetd sockets after dupping: %d, %d\", *sock_in, *sock_out);\n}\n\n \nstatic void\nlisten_on_addrs(struct listenaddr *la)\n{\n\tint ret, listen_sock;\n\tstruct addrinfo *ai;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\n\tfor (ai = la->addrs; ai; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\t\tif (num_listen_socks >= MAX_LISTEN_SOCKS)\n\t\t\tfatal(\"Too many listen sockets. \"\n\t\t\t    \"Enlarge MAX_LISTEN_SOCKS\");\n\t\tif ((ret = getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV)) != 0) {\n\t\t\terror(\"getnameinfo failed: %.100s\",\n\t\t\t    ssh_gai_strerror(ret));\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tlisten_sock = socket(ai->ai_family, ai->ai_socktype,\n\t\t    ai->ai_protocol);\n\t\tif (listen_sock == -1) {\n\t\t\t \n\t\t\tverbose(\"socket: %.100s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(listen_sock) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (fcntl(listen_sock, F_SETFD, FD_CLOEXEC) == -1) {\n\t\t\tverbose(\"socket: CLOEXEC: %s\", strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tset_reuseaddr(listen_sock);\n\t\tif (la->rdomain != NULL &&\n\t\t    set_rdomain(listen_sock, la->rdomain) == -1) {\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (ai->ai_family == AF_INET6)\n\t\t\tsock_set_v6only(listen_sock);\n\n\t\tdebug(\"Bind to port %s on %s.\", strport, ntop);\n\n\t\t \n\t\tif (bind(listen_sock, ai->ai_addr, ai->ai_addrlen) == -1) {\n\t\t\terror(\"Bind to port %s on %s failed: %.200s.\",\n\t\t\t    strport, ntop, strerror(errno));\n\t\t\tclose(listen_sock);\n\t\t\tcontinue;\n\t\t}\n\t\tlisten_socks[num_listen_socks] = listen_sock;\n\t\tnum_listen_socks++;\n\n\t\t \n\t\tif (listen(listen_sock, SSH_LISTEN_BACKLOG) == -1)\n\t\t\tfatal(\"listen on [%s]:%s: %.100s\",\n\t\t\t    ntop, strport, strerror(errno));\n\t\tlogit(\"Server listening on %s port %s%s%s.\",\n\t\t    ntop, strport,\n\t\t    la->rdomain == NULL ? \"\" : \" rdomain \",\n\t\t    la->rdomain == NULL ? \"\" : la->rdomain);\n\t}\n}\n\nstatic void\nserver_listen(void)\n{\n\tu_int i;\n\n\t \n\tsrclimit_init(options.max_startups, options.per_source_max_startups,\n\t    options.per_source_masklen_ipv4, options.per_source_masklen_ipv6);\n\n\tfor (i = 0; i < options.num_listen_addrs; i++) {\n\t\tlisten_on_addrs(&options.listen_addrs[i]);\n\t\tfreeaddrinfo(options.listen_addrs[i].addrs);\n\t\tfree(options.listen_addrs[i].rdomain);\n\t\tmemset(&options.listen_addrs[i], 0,\n\t\t    sizeof(options.listen_addrs[i]));\n\t}\n\tfree(options.listen_addrs);\n\toptions.listen_addrs = NULL;\n\toptions.num_listen_addrs = 0;\n\n\tif (!num_listen_socks)\n\t\tfatal(\"Cannot bind any address.\");\n}\n\n \nstatic void\nserver_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)\n{\n\tstruct pollfd *pfd = NULL;\n\tint i, j, ret, npfd;\n\tint ostartups = -1, startups = 0, listening = 0, lameduck = 0;\n\tint startup_p[2] = { -1 , -1 }, *startup_pollfd;\n\tchar c = 0;\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tpid_t pid;\n\tu_char rnd[256];\n\tsigset_t nsigset, osigset;\n\n\t \n\tstartup_pipes = xcalloc(options.max_startups, sizeof(int));\n\tstartup_flags = xcalloc(options.max_startups, sizeof(int));\n\tstartup_pollfd = xcalloc(options.max_startups, sizeof(int));\n\tfor (i = 0; i < options.max_startups; i++)\n\t\tstartup_pipes[i] = -1;\n\n\t \n\tsigemptyset(&nsigset);\n\tsigaddset(&nsigset, SIGHUP);\n\tsigaddset(&nsigset, SIGCHLD);\n\tsigaddset(&nsigset, SIGTERM);\n\tsigaddset(&nsigset, SIGQUIT);\n\n\t \n\tpfd = xcalloc(num_listen_socks + options.max_startups,\n\t    sizeof(struct pollfd));\n\n\t \n\tfor (;;) {\n\t\tsigprocmask(SIG_BLOCK, &nsigset, &osigset);\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Received signal %d; terminating.\",\n\t\t\t    (int) received_sigterm);\n\t\t\tclose_listen_socks();\n\t\t\tif (options.pid_file != NULL)\n\t\t\t\tunlink(options.pid_file);\n\t\t\texit(received_sigterm == SIGTERM ? 0 : 255);\n\t\t}\n\t\tif (ostartups != startups) {\n\t\t\tsetproctitle(\"%s [listener] %d of %d-%d startups\",\n\t\t\t    listener_proctitle, startups,\n\t\t\t    options.max_startups_begin, options.max_startups);\n\t\t\tostartups = startups;\n\t\t}\n\t\tif (received_sighup) {\n\t\t\tif (!lameduck) {\n\t\t\t\tdebug(\"Received SIGHUP; waiting for children\");\n\t\t\t\tclose_listen_socks();\n\t\t\t\tlameduck = 1;\n\t\t\t}\n\t\t\tif (listening <= 0) {\n\t\t\t\tsigprocmask(SIG_SETMASK, &osigset, NULL);\n\t\t\t\tsighup_restart();\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\tpfd[i].fd = listen_socks[i];\n\t\t\tpfd[i].events = POLLIN;\n\t\t}\n\t\tnpfd = num_listen_socks;\n\t\tfor (i = 0; i < options.max_startups; i++) {\n\t\t\tstartup_pollfd[i] = -1;\n\t\t\tif (startup_pipes[i] != -1) {\n\t\t\t\tpfd[npfd].fd = startup_pipes[i];\n\t\t\t\tpfd[npfd].events = POLLIN;\n\t\t\t\tstartup_pollfd[i] = npfd++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = ppoll(pfd, npfd, NULL, &osigset);\n\t\tif (ret == -1 && errno != EINTR) {\n\t\t\terror(\"ppoll: %.100s\", strerror(errno));\n\t\t\tif (errno == EINVAL)\n\t\t\t\tcleanup_exit(1);  \n\t\t}\n\t\tsigprocmask(SIG_SETMASK, &osigset, NULL);\n\t\tif (ret == -1)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < options.max_startups; i++) {\n\t\t\tif (startup_pipes[i] == -1 ||\n\t\t\t    startup_pollfd[i] == -1 ||\n\t\t\t    !(pfd[startup_pollfd[i]].revents & (POLLIN|POLLHUP)))\n\t\t\t\tcontinue;\n\t\t\tswitch (read(startup_pipes[i], &c, sizeof(c))) {\n\t\t\tcase -1:\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (errno != EPIPE) {\n\t\t\t\t\terror_f(\"startup pipe %d (fd=%d): \"\n\t\t\t\t\t    \"read %s\", i, startup_pipes[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t}\n\t\t\t\t \n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tclose(startup_pipes[i]);\n\t\t\t\tsrclimit_done(startup_pipes[i]);\n\t\t\t\tstartup_pipes[i] = -1;\n\t\t\t\tstartups--;\n\t\t\t\tif (startup_flags[i])\n\t\t\t\t\tlistening--;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tif (startup_flags[i]) {\n\t\t\t\t\tlistening--;\n\t\t\t\t\tstartup_flags[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < num_listen_socks; i++) {\n\t\t\tif (!(pfd[i].revents & POLLIN))\n\t\t\t\tcontinue;\n\t\t\tfromlen = sizeof(from);\n\t\t\t*newsock = accept(listen_socks[i],\n\t\t\t    (struct sockaddr *)&from, &fromlen);\n\t\t\tif (*newsock == -1) {\n\t\t\t\tif (errno != EINTR && errno != EWOULDBLOCK &&\n\t\t\t\t    errno != ECONNABORTED && errno != EAGAIN)\n\t\t\t\t\terror(\"accept: %.100s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (unset_nonblock(*newsock) == -1) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pipe(startup_p) == -1) {\n\t\t\t\terror_f(\"pipe(startup_p): %s\", strerror(errno));\n\t\t\t\tclose(*newsock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (drop_connection(*newsock, startups, startup_p[0])) {\n\t\t\t\tclose(*newsock);\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rexec_flag && socketpair(AF_UNIX,\n\t\t\t    SOCK_STREAM, 0, config_s) == -1) {\n\t\t\t\terror(\"reexec socketpair: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t\tclose(*newsock);\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < options.max_startups; j++)\n\t\t\t\tif (startup_pipes[j] == -1) {\n\t\t\t\t\tstartup_pipes[j] = startup_p[0];\n\t\t\t\t\tstartups++;\n\t\t\t\t\tstartup_flags[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t \n\t\t\tif (debug_flag) {\n\t\t\t\t \n\t\t\t\tdebug(\"Server will not fork when running in debugging mode.\");\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tclose(startup_p[0]);\n\t\t\t\tclose(startup_p[1]);\n\t\t\t\tstartup_pipe = -1;\n\t\t\t\tpid = getpid();\n\t\t\t\tif (rexec_flag) {\n\t\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\t}\n\t\t\t\tfree(pfd);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tplatform_pre_fork();\n\t\t\tlistening++;\n\t\t\tif ((pid = fork()) == 0) {\n\t\t\t\t \n\t\t\t\tplatform_post_fork_child();\n\t\t\t\tstartup_pipe = startup_p[1];\n\t\t\t\tclose_startup_pipes();\n\t\t\t\tclose_listen_socks();\n\t\t\t\t*sock_in = *newsock;\n\t\t\t\t*sock_out = *newsock;\n\t\t\t\tlog_init(__progname,\n\t\t\t\t    options.log_level,\n\t\t\t\t    options.log_facility,\n\t\t\t\t    log_stderr);\n\t\t\t\tif (rexec_flag)\n\t\t\t\t\tclose(config_s[0]);\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\t(void)atomicio(vwrite, startup_pipe,\n\t\t\t\t\t    \"\\0\", 1);\n\t\t\t\t}\n\t\t\t\tfree(pfd);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tplatform_post_fork_parent(pid);\n\t\t\tif (pid == -1)\n\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\telse\n\t\t\t\tdebug(\"Forked child %ld.\", (long)pid);\n\n\t\t\tclose(startup_p[1]);\n\n\t\t\tif (rexec_flag) {\n\t\t\t\tclose(config_s[1]);\n\t\t\t\tsend_rexec_state(config_s[0], cfg);\n\t\t\t\tclose(config_s[0]);\n\t\t\t}\n\t\t\tclose(*newsock);\n\n\t\t\t \n\t\t\tarc4random_stir();\n\t\t\tarc4random_buf(rnd, sizeof(rnd));\n#ifdef WITH_OPENSSL\n\t\t\tRAND_seed(rnd, sizeof(rnd));\n\t\t\tif ((RAND_bytes((u_char *)rnd, 1)) != 1)\n\t\t\t\tfatal(\"%s: RAND_bytes failed\", __func__);\n#endif\n\t\t\texplicit_bzero(rnd, sizeof(rnd));\n\t\t}\n\t}\n}\n\n \nstatic void\ncheck_ip_options(struct ssh *ssh)\n{\n#ifdef IP_OPTIONS\n\tint sock_in = ssh_packet_get_connection_in(ssh);\n\tstruct sockaddr_storage from;\n\tu_char opts[200];\n\tsocklen_t i, option_size = sizeof(opts), fromlen = sizeof(from);\n\tchar text[sizeof(opts) * 3 + 1];\n\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(sock_in, (struct sockaddr *)&from,\n\t    &fromlen) == -1)\n\t\treturn;\n\tif (from.ss_family != AF_INET)\n\t\treturn;\n\t \n\n\tif (getsockopt(sock_in, IPPROTO_IP, IP_OPTIONS, opts,\n\t    &option_size) >= 0 && option_size != 0) {\n\t\ttext[0] = '\\0';\n\t\tfor (i = 0; i < option_size; i++)\n\t\t\tsnprintf(text + i*3, sizeof(text) - i*3,\n\t\t\t    \" %2.2x\", opts[i]);\n\t\tfatal(\"Connection from %.100s port %d with IP opts: %.800s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh), text);\n\t}\n\treturn;\n#endif  \n}\n\n \nstatic void\nset_process_rdomain(struct ssh *ssh, const char *name)\n{\n#if defined(HAVE_SYS_SET_PROCESS_RDOMAIN)\n\tif (name == NULL)\n\t\treturn;  \n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t \n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\t \n\treturn sys_set_process_rdomain(name);\n#elif defined(__OpenBSD__)\n\tint rtable, ortable = getrtable();\n\tconst char *errstr;\n\n\tif (name == NULL)\n\t\treturn;  \n\n\tif (strcmp(name, \"%D\") == 0) {\n\t\t \n\t\tif ((name = ssh_packet_rdomain_in(ssh)) == NULL)\n\t\t\treturn;\n\t}\n\n\trtable = (int)strtonum(name, 0, 255, &errstr);\n\tif (errstr != NULL)  \n\t\tfatal(\"Invalid routing domain \\\"%s\\\": %s\", name, errstr);\n\tif (rtable != ortable && setrtable(rtable) != 0)\n\t\tfatal(\"Unable to set routing domain %d: %s\",\n\t\t    rtable, strerror(errno));\n\tdebug_f(\"set routing domain %d (was %d)\", rtable, ortable);\n#else  \n\tfatal(\"Unable to set routing domain: not supported in this platform\");\n#endif\n}\n\nstatic void\naccumulate_host_timing_secret(struct sshbuf *server_cfg,\n    struct sshkey *key)\n{\n\tstatic struct ssh_digest_ctx *ctx;\n\tu_char *hash;\n\tsize_t len;\n\tstruct sshbuf *buf;\n\tint r;\n\n\tif (ctx == NULL && (ctx = ssh_digest_start(SSH_DIGEST_SHA512)) == NULL)\n\t\tfatal_f(\"ssh_digest_start\");\n\tif (key == NULL) {  \n\t\t \n\t\tif (ssh_digest_update(ctx, sshbuf_ptr(server_cfg),\n\t\t    sshbuf_len(server_cfg)) != 0)\n\t\t\tfatal_f(\"ssh_digest_update\");\n\t\tlen = ssh_digest_bytes(SSH_DIGEST_SHA512);\n\t\thash = xmalloc(len);\n\t\tif (ssh_digest_final(ctx, hash, len) != 0)\n\t\t\tfatal_f(\"ssh_digest_final\");\n\t\toptions.timing_secret = PEEK_U64(hash);\n\t\tfreezero(hash, len);\n\t\tssh_digest_free(ctx);\n\t\tctx = NULL;\n\t\treturn;\n\t}\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"could not allocate buffer\");\n\tif ((r = sshkey_private_serialize(key, buf)) != 0)\n\t\tfatal_fr(r, \"encode %s key\", sshkey_ssh_name(key));\n\tif (ssh_digest_update(ctx, sshbuf_ptr(buf), sshbuf_len(buf)) != 0)\n\t\tfatal_f(\"ssh_digest_update\");\n\tsshbuf_reset(buf);\n\tsshbuf_free(buf);\n}\n\nstatic char *\nprepare_proctitle(int ac, char **av)\n{\n\tchar *ret = NULL;\n\tint i;\n\n\tfor (i = 0; i < ac; i++)\n\t\txextendf(&ret, \" \", \"%s\", av[i]);\n\treturn ret;\n}\n\nstatic void\nprint_config(struct ssh *ssh, struct connection_info *connection_info)\n{\n\t \n\tif (connection_info == NULL)\n\t\tconnection_info = get_connection_info(ssh, 0, 0);\n\tconnection_info->test = 1;\n\tparse_server_match_config(&options, &includes, connection_info);\n\tdump_config(&options);\n\texit(0);\n}\n\n \nint\nmain(int ac, char **av)\n{\n\tstruct ssh *ssh = NULL;\n\textern char *optarg;\n\textern int optind;\n\tint r, opt, on = 1, do_dump_cfg = 0, already_daemon, remote_port;\n\tint sock_in = -1, sock_out = -1, newsock = -1;\n\tconst char *remote_ip, *rdomain;\n\tchar *fp, *line, *laddr, *logfile = NULL;\n\tint config_s[2] = { -1 , -1 };\n\tu_int i, j;\n\tu_int64_t ibytes, obytes;\n\tmode_t new_umask;\n\tstruct sshkey *key;\n\tstruct sshkey *pubkey;\n\tint keytype;\n\tAuthctxt *authctxt;\n\tstruct connection_info *connection_info = NULL;\n\tsigset_t sigmask;\n\n#ifdef HAVE_SECUREWARE\n\t(void)set_auth_parameters(ac, av);\n#endif\n\t__progname = ssh_get_progname(av[0]);\n\n\tsigemptyset(&sigmask);\n\tsigprocmask(SIG_SETMASK, &sigmask, NULL);\n\n\t \n\tsaved_argc = ac;\n\trexec_argc = ac;\n\tsaved_argv = xcalloc(ac + 1, sizeof(*saved_argv));\n\tfor (i = 0; (int)i < ac; i++)\n\t\tsaved_argv[i] = xstrdup(av[i]);\n\tsaved_argv[i] = NULL;\n\n#ifndef HAVE_SETPROCTITLE\n\t \n\tcompat_init_setproctitle(ac, av);\n\tav = saved_argv;\n#endif\n\n\tif (geteuid() == 0 && setgroups(0, NULL) == -1)\n\t\tdebug(\"setgroups(): %.200s\", strerror(errno));\n\n\t \n\tsanitise_stdfd();\n\n\t \n\tinitialize_server_options(&options);\n\n\t \n\twhile ((opt = getopt(ac, av,\n\t    \"C:E:b:c:f:g:h:k:o:p:u:46DGQRTdeiqrtV\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase '4':\n\t\t\toptions.address_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\toptions.address_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconfig_file_name = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tservconf_add_hostcert(\"[command-line]\", 0,\n\t\t\t    &options, optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (debug_flag == 0) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else if (options.log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\toptions.log_level++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tno_daemon_flag = 1;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tdo_dump_cfg = 1;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tlogfile = optarg;\n\t\t\t \n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trexec_flag = 0;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trexeced_flag = 1;\n\t\t\tinetd_flag = 1;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\toptions.ports_from_cmdline = 1;\n\t\t\tif (options.num_ports >= MAX_PORTS) {\n\t\t\t\tfprintf(stderr, \"too many ports.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\toptions.ports[options.num_ports++] = a2port(optarg);\n\t\t\tif (options.ports[options.num_ports-1] <= 0) {\n\t\t\t\tfprintf(stderr, \"Bad port number.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif ((options.login_grace_time = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid login grace time.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tservconf_add_hostkey(\"[command-line]\", 0,\n\t\t\t    &options, optarg, 1);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttest_flag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttest_flag = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tconnection_info = get_connection_info(ssh, 0, 0);\n\t\t\tif (parse_server_match_testspec(connection_info,\n\t\t\t    optarg) == -1)\n\t\t\t\texit(1);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tutmp_len = (u_int)strtonum(optarg, 0, HOST_NAME_MAX+1+1, NULL);\n\t\t\tif (utmp_len > HOST_NAME_MAX+1) {\n\t\t\t\tfprintf(stderr, \"Invalid utmp length.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tline = xstrdup(optarg);\n\t\t\tif (process_server_config_line(&options, line,\n\t\t\t    \"command-line\", 0, NULL, NULL, &includes) != 0)\n\t\t\t\texit(1);\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tfprintf(stderr, \"%s, %s\\n\",\n\t\t\t    SSH_RELEASE, SSH_OPENSSL_VERSION);\n\t\t\texit(0);\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rexeced_flag || inetd_flag)\n\t\trexec_flag = 0;\n\tif (!test_flag && !do_dump_cfg && rexec_flag && !path_absolute(av[0]))\n\t\tfatal(\"sshd re-exec requires execution with an absolute path\");\n\tif (rexeced_flag)\n\t\tclosefrom(REEXEC_MIN_FREE_FD);\n\telse\n\t\tclosefrom(REEXEC_DEVCRYPTO_RESERVED_FD);\n\n\tseed_rng();\n\n\t \n\tif (logfile != NULL)\n\t\tlog_redirect_stderr_to(logfile);\n\t \n\tlog_init(__progname,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_AUTH : options.log_facility,\n\t    log_stderr || !inetd_flag || debug_flag);\n\n\t \n\tif (getenv(\"KRB5CCNAME\") != NULL)\n\t\t(void) unsetenv(\"KRB5CCNAME\");\n\n\tsensitive_data.have_ssh2_key = 0;\n\n\t \n\tif (test_flag < 2 && connection_info != NULL)\n\t\tfatal(\"Config test connection parameter (-C) provided without \"\n\t\t    \"test mode (-T)\");\n\n\t \n\tif ((cfg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif (rexeced_flag) {\n\t\tsetproctitle(\"%s\", \"[rexeced]\");\n\t\trecv_rexec_state(REEXEC_CONFIG_PASS_FD, cfg);\n\t\tif (!debug_flag) {\n\t\t\tstartup_pipe = dup(REEXEC_STARTUP_PIPE_FD);\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\t\t \n\t\t\t(void)atomicio(vwrite, startup_pipe, \"\\0\", 1);\n\t\t}\n\t} else if (strcasecmp(config_file_name, \"none\") != 0)\n\t\tload_server_config(config_file_name, cfg);\n\n\tparse_server_config(&options, rexeced_flag ? \"rexec\" : config_file_name,\n\t    cfg, &includes, NULL, rexeced_flag);\n\n#ifdef WITH_OPENSSL\n\tif (options.moduli_file != NULL)\n\t\tdh_set_moduli_file(options.moduli_file);\n#endif\n\n\t \n\tfill_default_server_options(&options);\n\n\t \n\tif (options.authorized_keys_command_user == NULL &&\n\t    (options.authorized_keys_command != NULL &&\n\t    strcasecmp(options.authorized_keys_command, \"none\") != 0))\n\t\tfatal(\"AuthorizedKeysCommand set without \"\n\t\t    \"AuthorizedKeysCommandUser\");\n\tif (options.authorized_principals_command_user == NULL &&\n\t    (options.authorized_principals_command != NULL &&\n\t    strcasecmp(options.authorized_principals_command, \"none\") != 0))\n\t\tfatal(\"AuthorizedPrincipalsCommand set without \"\n\t\t    \"AuthorizedPrincipalsCommandUser\");\n\n\t \n\tif (options.num_auth_methods != 0) {\n\t\tfor (i = 0; i < options.num_auth_methods; i++) {\n\t\t\tif (auth2_methods_valid(options.auth_methods[i],\n\t\t\t    1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= options.num_auth_methods)\n\t\t\tfatal(\"AuthenticationMethods cannot be satisfied by \"\n\t\t\t    \"enabled authentication methods\");\n\t}\n\n\t \n\tif (optind < ac) {\n\t\tfprintf(stderr, \"Extra argument %s.\\n\", av[optind]);\n\t\texit(1);\n\t}\n\n\tdebug(\"sshd version %s, %s\", SSH_VERSION, SSH_OPENSSL_VERSION);\n\n\tif (do_dump_cfg)\n\t\tprint_config(ssh, connection_info);\n\n\t \n\tprivsep_chroot = use_privsep && (getuid() == 0 || geteuid() == 0);\n\tif ((privsep_pw = getpwnam(SSH_PRIVSEP_USER)) == NULL) {\n\t\tif (privsep_chroot || options.kerberos_authentication)\n\t\t\tfatal(\"Privilege separation user %s does not exist\",\n\t\t\t    SSH_PRIVSEP_USER);\n\t} else {\n\t\tprivsep_pw = pwcopy(privsep_pw);\n\t\tfreezero(privsep_pw->pw_passwd, strlen(privsep_pw->pw_passwd));\n\t\tprivsep_pw->pw_passwd = xstrdup(\"*\");\n\t}\n\tendpwent();\n\n\t \n\tsensitive_data.host_keys = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\tsensitive_data.host_pubkeys = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\n\tif (options.host_key_agent) {\n\t\tif (strcmp(options.host_key_agent, SSH_AUTHSOCKET_ENV_NAME))\n\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME,\n\t\t\t    options.host_key_agent, 1);\n\t\tif ((r = ssh_get_authentication_socket(NULL)) == 0)\n\t\t\thave_agent = 1;\n\t\telse\n\t\t\terror_r(r, \"Could not connect to agent \\\"%s\\\"\",\n\t\t\t    options.host_key_agent);\n\t}\n\n\tfor (i = 0; i < options.num_host_key_files; i++) {\n\t\tint ll = options.host_key_file_userprovided[i] ?\n\t\t    SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_DEBUG1;\n\n\t\tif (options.host_key_files[i] == NULL)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_load_private(options.host_key_files[i], \"\",\n\t\t    &key, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)\n\t\t\tdo_log2_r(r, ll, \"Unable to load host key \\\"%s\\\"\",\n\t\t\t    options.host_key_files[i]);\n\t\tif (sshkey_is_sk(key) &&\n\t\t    key->sk_flags & SSH_SK_USER_PRESENCE_REQD) {\n\t\t\tdebug(\"host key %s requires user presence, ignoring\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tkey->sk_flags &= ~SSH_SK_USER_PRESENCE_REQD;\n\t\t}\n\t\tif (r == 0 && key != NULL &&\n\t\t    (r = sshkey_shield_private(key)) != 0) {\n\t\t\tdo_log2_r(r, ll, \"Unable to shield host key \\\"%s\\\"\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tkey = NULL;\n\t\t}\n\t\tif ((r = sshkey_load_public(options.host_key_files[i],\n\t\t    &pubkey, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)\n\t\t\tdo_log2_r(r, ll, \"Unable to load host key \\\"%s\\\"\",\n\t\t\t    options.host_key_files[i]);\n\t\tif (pubkey != NULL && key != NULL) {\n\t\t\tif (!sshkey_equal(pubkey, key)) {\n\t\t\t\terror(\"Public key for %s does not match \"\n\t\t\t\t    \"private key\", options.host_key_files[i]);\n\t\t\t\tsshkey_free(pubkey);\n\t\t\t\tpubkey = NULL;\n\t\t\t}\n\t\t}\n\t\tif (pubkey == NULL && key != NULL) {\n\t\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\t\tfatal_r(r, \"Could not demote key: \\\"%s\\\"\",\n\t\t\t\t    options.host_key_files[i]);\n\t\t}\n\t\tif (pubkey != NULL && (r = sshkey_check_rsa_length(pubkey,\n\t\t    options.required_rsa_size)) != 0) {\n\t\t\terror_fr(r, \"Host key %s\", options.host_key_files[i]);\n\t\t\tsshkey_free(pubkey);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\tsensitive_data.host_keys[i] = key;\n\t\tsensitive_data.host_pubkeys[i] = pubkey;\n\n\t\tif (key == NULL && pubkey != NULL && have_agent) {\n\t\t\tdebug(\"will rely on agent for hostkey %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tkeytype = pubkey->type;\n\t\t} else if (key != NULL) {\n\t\t\tkeytype = key->type;\n\t\t\taccumulate_host_timing_secret(cfg, key);\n\t\t} else {\n\t\t\tdo_log2(ll, \"Unable to load host key: %s\",\n\t\t\t    options.host_key_files[i]);\n\t\t\tsensitive_data.host_keys[i] = NULL;\n\t\t\tsensitive_data.host_pubkeys[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (keytype) {\n\t\tcase KEY_RSA:\n\t\tcase KEY_DSA:\n\t\tcase KEY_ECDSA:\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ECDSA_SK:\n\t\tcase KEY_ED25519_SK:\n\t\tcase KEY_XMSS:\n\t\t\tif (have_agent || key != NULL)\n\t\t\t\tsensitive_data.have_ssh2_key = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif ((fp = sshkey_fingerprint(pubkey, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"sshkey_fingerprint failed\");\n\t\tdebug(\"%s host key #%d: %s %s\",\n\t\t    key ? \"private\" : \"agent\", i, sshkey_ssh_name(pubkey), fp);\n\t\tfree(fp);\n\t}\n\taccumulate_host_timing_secret(cfg, NULL);\n\tif (!sensitive_data.have_ssh2_key) {\n\t\tlogit(\"sshd: no hostkeys available -- exiting.\");\n\t\texit(1);\n\t}\n\n\t \n\tsensitive_data.host_certificates = xcalloc(options.num_host_key_files,\n\t    sizeof(struct sshkey *));\n\tfor (i = 0; i < options.num_host_key_files; i++)\n\t\tsensitive_data.host_certificates[i] = NULL;\n\n\tfor (i = 0; i < options.num_host_cert_files; i++) {\n\t\tif (options.host_cert_files[i] == NULL)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_load_public(options.host_cert_files[i],\n\t\t    &key, NULL)) != 0) {\n\t\t\terror_r(r, \"Could not load host certificate \\\"%s\\\"\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"Certificate file is not a certificate: %s\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (j = 0; j < options.num_host_key_files; j++) {\n\t\t\tif (sshkey_equal_public(key,\n\t\t\t    sensitive_data.host_pubkeys[j])) {\n\t\t\t\tsensitive_data.host_certificates[j] = key;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j >= options.num_host_key_files) {\n\t\t\terror(\"No matching private key for certificate: %s\",\n\t\t\t    options.host_cert_files[i]);\n\t\t\tsshkey_free(key);\n\t\t\tcontinue;\n\t\t}\n\t\tsensitive_data.host_certificates[j] = key;\n\t\tdebug(\"host certificate: #%u type %d %s\", j, key->type,\n\t\t    sshkey_type(key));\n\t}\n\n\tif (privsep_chroot) {\n\t\tstruct stat st;\n\n\t\tif ((stat(_PATH_PRIVSEP_CHROOT_DIR, &st) == -1) ||\n\t\t    (S_ISDIR(st.st_mode) == 0))\n\t\t\tfatal(\"Missing privilege separation directory: %s\",\n\t\t\t    _PATH_PRIVSEP_CHROOT_DIR);\n\n#ifdef HAVE_CYGWIN\n\t\tif (check_ntsec(_PATH_PRIVSEP_CHROOT_DIR) &&\n\t\t    (st.st_uid != getuid () ||\n\t\t    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))\n#else\n\t\tif (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n#endif\n\t\t\tfatal(\"%s must be owned by root and not group or \"\n\t\t\t    \"world-writable.\", _PATH_PRIVSEP_CHROOT_DIR);\n\t}\n\n\tif (test_flag > 1)\n\t\tprint_config(ssh, connection_info);\n\n\t \n\tif (test_flag)\n\t\texit(0);\n\n\t \n\tif (setgroups(0, NULL) < 0)\n\t\tdebug(\"setgroups() failed: %.200s\", strerror(errno));\n\n\tif (rexec_flag) {\n\t\tif (rexec_argc < 0)\n\t\t\tfatal(\"rexec_argc %d < 0\", rexec_argc);\n\t\trexec_argv = xcalloc(rexec_argc + 2, sizeof(char *));\n\t\tfor (i = 0; i < (u_int)rexec_argc; i++) {\n\t\t\tdebug(\"rexec_argv[%d]='%s'\", i, saved_argv[i]);\n\t\t\trexec_argv[i] = saved_argv[i];\n\t\t}\n\t\trexec_argv[rexec_argc] = \"-R\";\n\t\trexec_argv[rexec_argc + 1] = NULL;\n\t}\n\tlistener_proctitle = prepare_proctitle(ac, av);\n\n\t \n\tnew_umask = umask(0077) | 0022;\n\t(void) umask(new_umask);\n\n\t \n\tif (debug_flag && (!inetd_flag || rexeced_flag))\n\t\tlog_stderr = 1;\n\tlog_init(__progname, options.log_level,\n\t    options.log_facility, log_stderr);\n\tfor (i = 0; i < options.num_log_verbose; i++)\n\t\tlog_verbose_add(options.log_verbose[i]);\n\n\t \n\talready_daemon = daemonized();\n\tif (!(debug_flag || inetd_flag || no_daemon_flag || already_daemon)) {\n\n\t\tif (daemon(0, 0) == -1)\n\t\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n\n\t\tdisconnect_controlling_tty();\n\t}\n\t \n\tlog_init(__progname, options.log_level, options.log_facility, log_stderr);\n\n\t \n\tif (chdir(\"/\") == -1)\n\t\terror(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n\n\t \n\tssh_signal(SIGPIPE, SIG_IGN);\n\n\t \n\tif (inetd_flag) {\n\t\tserver_accept_inetd(&sock_in, &sock_out);\n\t} else {\n\t\tplatform_pre_listen();\n\t\tserver_listen();\n\n\t\tssh_signal(SIGHUP, sighup_handler);\n\t\tssh_signal(SIGCHLD, main_sigchld_handler);\n\t\tssh_signal(SIGTERM, sigterm_handler);\n\t\tssh_signal(SIGQUIT, sigterm_handler);\n\n\t\t \n\t\tif (options.pid_file != NULL && !debug_flag) {\n\t\t\tFILE *f = fopen(options.pid_file, \"w\");\n\n\t\t\tif (f == NULL) {\n\t\t\t\terror(\"Couldn't create pid file \\\"%s\\\": %s\",\n\t\t\t\t    options.pid_file, strerror(errno));\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%ld\\n\", (long) getpid());\n\t\t\t\tfclose(f);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tserver_accept_loop(&sock_in, &sock_out,\n\t\t    &newsock, config_s);\n\t}\n\n\t \n\tsetproctitle(\"%s\", \"[accepted]\");\n\n\t \n\tif (!debug_flag && !inetd_flag && setsid() == -1)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n\n\tif (rexec_flag) {\n\t\tdebug(\"rexec start in %d out %d newsock %d pipe %d sock %d\",\n\t\t    sock_in, sock_out, newsock, startup_pipe, config_s[0]);\n\t\tif (dup2(newsock, STDIN_FILENO) == -1)\n\t\t\tdebug3_f(\"dup2 stdin: %s\", strerror(errno));\n\t\tif (dup2(STDIN_FILENO, STDOUT_FILENO) == -1)\n\t\t\tdebug3_f(\"dup2 stdout: %s\", strerror(errno));\n\t\tif (startup_pipe == -1)\n\t\t\tclose(REEXEC_STARTUP_PIPE_FD);\n\t\telse if (startup_pipe != REEXEC_STARTUP_PIPE_FD) {\n\t\t\tif (dup2(startup_pipe, REEXEC_STARTUP_PIPE_FD) == -1)\n\t\t\t\tdebug3_f(\"dup2 startup_p: %s\", strerror(errno));\n\t\t\tclose(startup_pipe);\n\t\t\tstartup_pipe = REEXEC_STARTUP_PIPE_FD;\n\t\t}\n\n\t\tif (dup2(config_s[1], REEXEC_CONFIG_PASS_FD) == -1)\n\t\t\tdebug3_f(\"dup2 config_s: %s\", strerror(errno));\n\t\tclose(config_s[1]);\n\n\t\tssh_signal(SIGHUP, SIG_IGN);  \n\t\texecv(rexec_argv[0], rexec_argv);\n\n\t\t \n\t\terror(\"rexec of %s failed: %s\", rexec_argv[0], strerror(errno));\n\t\trecv_rexec_state(REEXEC_CONFIG_PASS_FD, NULL);\n\t\tlog_init(__progname, options.log_level,\n\t\t    options.log_facility, log_stderr);\n\n\t\t \n\t\tclose(REEXEC_CONFIG_PASS_FD);\n\t\tnewsock = sock_out = sock_in = dup(STDIN_FILENO);\n\t\tif (stdfd_devnull(1, 1, 0) == -1)\n\t\t\terror_f(\"stdfd_devnull failed\");\n\t\tdebug(\"rexec cleanup in %d out %d newsock %d pipe %d sock %d\",\n\t\t    sock_in, sock_out, newsock, startup_pipe, config_s[0]);\n\t}\n\n\t \n\tfcntl(sock_out, F_SETFD, FD_CLOEXEC);\n\tfcntl(sock_in, F_SETFD, FD_CLOEXEC);\n\n\t \n\tssh_signal(SIGALRM, SIG_DFL);\n\tssh_signal(SIGHUP, SIG_DFL);\n\tssh_signal(SIGTERM, SIG_DFL);\n\tssh_signal(SIGQUIT, SIG_DFL);\n\tssh_signal(SIGCHLD, SIG_DFL);\n\tssh_signal(SIGINT, SIG_DFL);\n\n\t \n\tif ((ssh = ssh_packet_set_connection(NULL, sock_in, sock_out)) == NULL)\n\t\tfatal(\"Unable to create connection\");\n\tthe_active_state = ssh;\n\tssh_packet_set_server(ssh);\n\n\tcheck_ip_options(ssh);\n\n\t \n\tchannel_init_channels(ssh);\n\tchannel_set_af(ssh, options.address_family);\n\tprocess_channel_timeouts(ssh, &options);\n\tprocess_permitopen(ssh, &options);\n\n\t \n\tif (options.tcp_keep_alive && ssh_packet_connection_is_on_socket(ssh) &&\n\t    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\tif ((remote_port = ssh_remote_port(ssh)) < 0) {\n\t\tdebug(\"ssh_remote_port failed\");\n\t\tcleanup_exit(255);\n\t}\n\n\tif (options.routing_domain != NULL)\n\t\tset_process_rdomain(ssh, options.routing_domain);\n\n\t \n\tremote_ip = ssh_remote_ipaddr(ssh);\n\n#ifdef SSH_AUDIT_EVENTS\n\taudit_connection_from(remote_ip, remote_port);\n#endif\n\n\trdomain = ssh_packet_rdomain_in(ssh);\n\n\t \n\tladdr = get_local_ipaddr(sock_in);\n\tverbose(\"Connection from %s port %d on %s port %d%s%s%s\",\n\t    remote_ip, remote_port, laddr,  ssh_local_port(ssh),\n\t    rdomain == NULL ? \"\" : \" rdomain \\\"\",\n\t    rdomain == NULL ? \"\" : rdomain,\n\t    rdomain == NULL ? \"\" : \"\\\"\");\n\tfree(laddr);\n\n\t \n\tssh_signal(SIGALRM, grace_alarm_handler);\n\tif (!debug_flag)\n\t\talarm(options.login_grace_time);\n\n\tif ((r = kex_exchange_identification(ssh, -1,\n\t    options.version_addendum)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"banner exchange\");\n\n\tssh_packet_set_nonblocking(ssh);\n\n\t \n\tauthctxt = xcalloc(1, sizeof(*authctxt));\n\tssh->authctxt = authctxt;\n\n\tauthctxt->loginmsg = loginmsg;\n\n\t \n\tthe_authctxt = authctxt;\n\n\t \n\tif ((auth_opts = sshauthopt_new_with_keys_defaults()) == NULL)\n\t\tfatal(\"allocation failed\");\n\n\t \n\tif ((loginmsg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tauth_debug_reset();\n\n\tif (use_privsep) {\n\t\tif (privsep_preauth(ssh) == 1)\n\t\t\tgoto authenticated;\n\t} else if (have_agent) {\n\t\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\t\terror_r(r, \"Unable to get agent socket\");\n\t\t\thave_agent = 0;\n\t\t}\n\t}\n\n\t \n\t \n\tdo_ssh2_kex(ssh);\n\tdo_authentication2(ssh);\n\n\t \n\tif (use_privsep) {\n\t\tmm_send_keystate(ssh, pmonitor);\n\t\tssh_packet_clear_keys(ssh);\n\t\texit(0);\n\t}\n\n authenticated:\n\t \n\talarm(0);\n\tssh_signal(SIGALRM, SIG_DFL);\n\tauthctxt->authenticated = 1;\n\tif (startup_pipe != -1) {\n\t\tclose(startup_pipe);\n\t\tstartup_pipe = -1;\n\t}\n\n#ifdef SSH_AUDIT_EVENTS\n\taudit_event(ssh, SSH_AUTH_SUCCESS);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_authentication) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tssh_gssapi_storecreds();\n\t\trestore_uid();\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tdo_pam_setcred(1);\n\t\tdo_pam_session(ssh);\n\t}\n#endif\n\n\t \n\tif (use_privsep) {\n\t\tprivsep_postauth(ssh, authctxt);\n\t\t \n\t}\n\n\tssh_packet_set_timeout(ssh, options.client_alive_interval,\n\t    options.client_alive_count_max);\n\n\t \n\tnotify_hostkeys(ssh);\n\n\t \n\tdo_authenticated(ssh, authctxt);\n\n\t \n\tssh_packet_get_bytes(ssh, &ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes);\n\n\tverbose(\"Closing connection to %.500s port %d\", remote_ip, remote_port);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tfinish_pam();\n#endif  \n\n#ifdef SSH_AUDIT_EVENTS\n\tPRIVSEP(audit_event(ssh, SSH_CONNECTION_CLOSE));\n#endif\n\n\tssh_packet_close(ssh);\n\n\tif (use_privsep)\n\t\tmm_terminate();\n\n\texit(0);\n}\n\nint\nsshd_hostkey_sign(struct ssh *ssh, struct sshkey *privkey,\n    struct sshkey *pubkey, u_char **signature, size_t *slenp,\n    const u_char *data, size_t dlen, const char *alg)\n{\n\tint r;\n\n\tif (use_privsep) {\n\t\tif (privkey) {\n\t\t\tif (mm_sshkey_sign(ssh, privkey, signature, slenp,\n\t\t\t    data, dlen, alg, options.sk_provider, NULL,\n\t\t\t    ssh->compat) < 0)\n\t\t\t\tfatal_f(\"privkey sign failed\");\n\t\t} else {\n\t\t\tif (mm_sshkey_sign(ssh, pubkey, signature, slenp,\n\t\t\t    data, dlen, alg, options.sk_provider, NULL,\n\t\t\t    ssh->compat) < 0)\n\t\t\t\tfatal_f(\"pubkey sign failed\");\n\t\t}\n\t} else {\n\t\tif (privkey) {\n\t\t\tif (sshkey_sign(privkey, signature, slenp, data, dlen,\n\t\t\t    alg, options.sk_provider, NULL, ssh->compat) < 0)\n\t\t\t\tfatal_f(\"privkey sign failed\");\n\t\t} else {\n\t\t\tif ((r = ssh_agent_sign(auth_sock, pubkey,\n\t\t\t    signature, slenp, data, dlen, alg,\n\t\t\t    ssh->compat)) != 0) {\n\t\t\t\tfatal_fr(r, \"agent sign failed\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void\ndo_ssh2_kex(struct ssh *ssh)\n{\n\tchar *hkalgs = NULL, *myproposal[PROPOSAL_MAX];\n\tconst char *compression = NULL;\n\tstruct kex *kex;\n\tint r;\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\tif (options.compression == COMP_NONE)\n\t\tcompression = \"none\";\n\thkalgs = list_hostkey_types();\n\n\tkex_proposal_populate_entries(ssh, myproposal, options.kex_algorithms,\n\t    options.ciphers, options.macs, compression, hkalgs);\n\n\tfree(hkalgs);\n\n\t \n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \"kex_setup\");\n\tkex_set_server_sig_algs(ssh, options.pubkey_accepted_algos);\n\tkex = ssh->kex;\n\n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif\n\tkex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tkex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &kex->done);\n\n#ifdef DEBUG_KEXDH\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"markus\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \"send test\");\n#endif\n\tkex_proposal_free_entries(myproposal);\n\tdebug(\"KEX done\");\n}\n\n \nvoid\ncleanup_exit(int i)\n{\n\tif (the_active_state != NULL && the_authctxt != NULL) {\n\t\tdo_cleanup(the_active_state, the_authctxt);\n\t\tif (use_privsep && privsep_is_preauth &&\n\t\t    pmonitor != NULL && pmonitor->m_pid > 1) {\n\t\t\tdebug(\"Killing privsep child %d\", pmonitor->m_pid);\n\t\t\tif (kill(pmonitor->m_pid, SIGKILL) != 0 &&\n\t\t\t    errno != ESRCH) {\n\t\t\t\terror_f(\"kill(%d): %s\", pmonitor->m_pid,\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n#ifdef SSH_AUDIT_EVENTS\n\t \n\tif (the_active_state != NULL && (!use_privsep || mm_is_monitor()))\n\t\taudit_event(the_active_state, SSH_CONNECTION_ABANDON);\n#endif\n\t_exit(i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}