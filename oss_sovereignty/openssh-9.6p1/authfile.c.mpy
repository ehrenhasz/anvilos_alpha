{
  "module_name": "authfile.c",
  "hash_id": "56d3400d6bd2690652f204364e3210c6cf01452d43a3df09266e443eb4d389d1",
  "original_prompt": "Ingested from openssh-9.6p1/authfile.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"cipher.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"authfile.h\"\n#include \"misc.h\"\n#include \"atomicio.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"krl.h\"\n\n#define MAX_KEY_FILE_SIZE\t(1024 * 1024)\n\n \nstatic int\nsshkey_save_private_blob(struct sshbuf *keybuf, const char *filename)\n{\n\tint r;\n\tmode_t omask;\n\n\tomask = umask(077);\n\tr = sshbuf_write_file(filename, keybuf);\n\tumask(omask);\n\treturn r;\n}\n\nint\nsshkey_save_private(struct sshkey *key, const char *filename,\n    const char *passphrase, const char *comment,\n    int format, const char *openssh_format_cipher, int openssh_format_rounds)\n{\n\tstruct sshbuf *keyblob = NULL;\n\tint r;\n\n\tif ((keyblob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_private_to_fileblob(key, keyblob, passphrase, comment,\n\t    format, openssh_format_cipher, openssh_format_rounds)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_save_private_blob(keyblob, filename)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tsshbuf_free(keyblob);\n\treturn r;\n}\n\n \nint\nsshkey_perm_ok(int fd, const char *filename)\n{\n\tstruct stat st;\n\n\tif (fstat(fd, &st) == -1)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t \n#ifdef HAVE_CYGWIN\n\tif (check_ntsec(filename))\n#endif\n\tif ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"Permissions 0%3.3o for '%s' are too open.\",\n\t\t    (u_int)st.st_mode & 0777, filename);\n\t\terror(\"It is required that your private key files are NOT accessible by others.\");\n\t\terror(\"This private key will be ignored.\");\n\t\treturn SSH_ERR_KEY_BAD_PERMISSIONS;\n\t}\n\treturn 0;\n}\n\nint\nsshkey_load_private_type(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tint fd, r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) == -1)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tr = sshkey_perm_ok(fd, filename);\n\tif (r != 0)\n\t\tgoto out;\n\n\tr = sshkey_load_private_type_fd(fd, type, passphrase, keyp, commentp);\n\tif (r == 0 && keyp && *keyp)\n\t\tr = sshkey_set_filename(*keyp, filename);\n out:\n\tclose(fd);\n\treturn r;\n}\n\nint\nsshkey_load_private(const char *filename, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\treturn sshkey_load_private_type(KEY_UNSPEC, filename, passphrase,\n\t    keyp, commentp);\n}\n\nint\nsshkey_load_private_type_fd(int fd, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((r = sshbuf_load_fd(fd, &buffer)) != 0 ||\n\t    (r = sshkey_parse_private_fileblob_type(buffer, type,\n\t    passphrase, keyp, commentp)) != 0)\n\t\tgoto out;\n\n\t \n\tr = 0;\n out:\n\tsshbuf_free(buffer);\n\treturn r;\n}\n\n \nstatic int\nsshkey_load_pubkey_from_private(const char *filename, struct sshkey **pubkeyp)\n{\n\tstruct sshbuf *buffer = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tint r, fd;\n\n\tif (pubkeyp != NULL)\n\t\t*pubkeyp = NULL;\n\n\tif ((fd = open(filename, O_RDONLY)) == -1)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((r = sshbuf_load_fd(fd, &buffer)) != 0 ||\n\t    (r = sshkey_parse_pubkey_from_private_fileblob_type(buffer,\n\t    KEY_UNSPEC, &pubkey)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_set_filename(pubkey, filename)) != 0)\n\t\tgoto out;\n\t \n\tif (pubkeyp != NULL) {\n\t\t*pubkeyp = pubkey;\n\t\tpubkey = NULL;\n\t}\n\tr = 0;\n out:\n\tclose(fd);\n\tsshbuf_free(buffer);\n\tsshkey_free(pubkey);\n\treturn r;\n}\n\nstatic int\nsshkey_try_load_public(struct sshkey **kp, const char *filename,\n    char **commentp)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tint r;\n\tstruct sshkey *k = NULL;\n\n\tif (kp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*kp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\tfclose(f);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tcp = line;\n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (strncmp(cp, \"-----BEGIN\", 10) == 0 ||\n\t\t    strcmp(cp, \"SSH PRIVATE KEY FILE\") == 0)\n\t\t\tbreak;\n\t\t \n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\t\tif (*cp) {\n\t\t\tif ((r = sshkey_read(k, &cp)) == 0) {\n\t\t\t\tcp[strcspn(cp, \"\\r\\n\")] = '\\0';\n\t\t\t\tif (commentp) {\n\t\t\t\t\t*commentp = strdup(*cp ?\n\t\t\t\t\t    cp : filename);\n\t\t\t\t\tif (*commentp == NULL)\n\t\t\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t*kp = k;\n\t\t\t\tfree(line);\n\t\t\t\tfclose(f);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\tfree(k);\n\tfree(line);\n\tfclose(f);\n\treturn SSH_ERR_INVALID_FORMAT;\n}\n\n \nint\nsshkey_load_public(const char *filename, struct sshkey **keyp, char **commentp)\n{\n\tchar *pubfile = NULL;\n\tint r, oerrno;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tif ((r = sshkey_try_load_public(keyp, filename, commentp)) == 0)\n\t\tgoto out;\n\n\t \n\tif (asprintf(&pubfile, \"%s.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_try_load_public(keyp, pubfile, commentp)) == 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshkey_load_pubkey_from_private(filename, keyp)) == 0)\n\t\tgoto out;\n\n\t \n\tr = SSH_ERR_SYSTEM_ERROR;\n\terrno = ENOENT;\n\n out:\n\toerrno = errno;\n\tfree(pubfile);\n\terrno = oerrno;\n\treturn r;\n}\n\n \nint\nsshkey_load_cert(const char *filename, struct sshkey **keyp)\n{\n\tstruct sshkey *pub = NULL;\n\tchar *file = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (asprintf(&file, \"%s-cert.pub\", filename) == -1)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tr = sshkey_try_load_public(keyp, file, NULL);\n\tfree(file);\n\tsshkey_free(pub);\n\treturn r;\n}\n\n \nint\nsshkey_load_private_cert(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL, *cert = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n#endif  \n\tcase KEY_ED25519:\n\tcase KEY_XMSS:\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\n\tif ((r = sshkey_load_private_type(type, filename,\n\t    passphrase, &key, NULL)) != 0 ||\n\t    (r = sshkey_load_cert(filename, &cert)) != 0)\n\t\tgoto out;\n\n\t \n\tif (sshkey_equal_public(key, cert) == 0) {\n\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_certified(key)) != 0 ||\n\t    (r = sshkey_cert_copy(cert, key)) != 0)\n\t\tgoto out;\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshkey_free(key);\n\tsshkey_free(cert);\n\treturn r;\n}\n\n \nint\nsshkey_in_file(struct sshkey *key, const char *filename, int strict_type,\n    int check_ca)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tint r = 0;\n\tstruct sshkey *pub = NULL;\n\n\tint (*sshkey_compare)(const struct sshkey *, const struct sshkey *) =\n\t    strict_type ?  sshkey_equal : sshkey_equal_public;\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tsshkey_free(pub);\n\t\tpub = NULL;\n\t\tcp = line;\n\n\t\t \n\t\tfor (; *cp && (*cp == ' ' || *cp == '\\t'); cp++)\n\t\t\t;\n\n\t\t \n\t\tswitch (*cp) {\n\t\tcase '#':\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((pub = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (r = sshkey_read(pub, &cp)) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_LENGTH:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshkey_compare(key, pub) ||\n\t\t    (check_ca && sshkey_is_cert(key) &&\n\t\t    sshkey_compare(key->cert->signature_key, pub))) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tr = SSH_ERR_KEY_NOT_FOUND;\n out:\n\tfree(line);\n\tsshkey_free(pub);\n\tfclose(f);\n\treturn r;\n}\n\n \nint\nsshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file)\n{\n\tint r;\n\n\tr = ssh_krl_file_contains_key(revoked_keys_file, key);\n\t \n\tif (r != SSH_ERR_KRL_BAD_MAGIC)\n\t\treturn r;\n\n\t \n\tswitch ((r = sshkey_in_file(key, revoked_keys_file, 0, 1))) {\n\tcase 0:\n\t\t \n\t\treturn SSH_ERR_KEY_REVOKED;\n\tcase SSH_ERR_KEY_NOT_FOUND:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn r;\n\t}\n}\n\n \nint\nsshkey_advance_past_options(char **cpp)\n{\n\tchar *cp = *cpp;\n\tint quoted = 0;\n\n\tfor (; *cp && (quoted || (*cp != ' ' && *cp != '\\t')); cp++) {\n\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\tcp++;\t \n\t\telse if (*cp == '\"')\n\t\t\tquoted = !quoted;\n\t}\n\t*cpp = cp;\n\t \n\treturn (*cp == '\\0' && quoted) ? -1 : 0;\n}\n\n \nint\nsshkey_save_public(const struct sshkey *key, const char *path,\n    const char *comment)\n{\n\tint fd, oerrno;\n\tFILE *f = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((f = fdopen(fd, \"w\")) == NULL) {\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tclose(fd);\n\t\tgoto fail;\n\t}\n\tif ((r = sshkey_write(key, f)) != 0)\n\t\tgoto fail;\n\tfprintf(f, \" %s\\n\", comment);\n\tif (ferror(f)) {\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\tif (fclose(f) != 0) {\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tf = NULL;\n fail:\n\t\tif (f != NULL) {\n\t\t\toerrno = errno;\n\t\t\tfclose(f);\n\t\t\terrno = oerrno;\n\t\t}\n\t\treturn r;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}