{
  "module_name": "mux.c",
  "hash_id": "5dbc01cb414f6ffd6eb6dab1f2910f955c186142ebd1654518adce2fed0e2b92",
  "original_prompt": "Ingested from openssh-9.6p1/mux.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"sshbuf.h\"\n#include \"channels.h\"\n#include \"msg.h\"\n#include \"packet.h\"\n#include \"monitor_fdpass.h\"\n#include \"sshpty.h\"\n#include \"sshkey.h\"\n#include \"readconf.h\"\n#include \"clientloop.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n\n \nextern int tty_flag;\nextern Options options;\nextern char *host;\nextern struct sshbuf *command;\nextern volatile sig_atomic_t quit_pending;\n\n \nstruct mux_session_confirm_ctx {\n\tu_int want_tty;\n\tu_int want_subsys;\n\tu_int want_x_fwd;\n\tu_int want_agent_fwd;\n\tstruct sshbuf *cmd;\n\tchar *term;\n\tstruct termios tio;\n\tchar **env;\n\tu_int rid;\n};\n\n \nstruct mux_stdio_confirm_ctx {\n\tu_int rid;\n};\n\n \nstruct mux_channel_confirm_ctx {\n\tu_int cid;\t \n\tu_int rid;\t \n\tint fid;\t \n};\n\n \nint muxserver_sock = -1;\n\n \nu_int muxclient_request_id = 0;\n\n \nu_int muxclient_command = 0;\n\n \nstatic volatile sig_atomic_t muxclient_terminate = 0;\n\n \nstatic u_int muxserver_pid = 0;\n\nstatic Channel *mux_listener_channel = NULL;\n\nstruct mux_master_state {\n\tint hello_rcvd;\n};\n\n \n#define MUX_MSG_HELLO\t\t0x00000001\n#define MUX_C_NEW_SESSION\t0x10000002\n#define MUX_C_ALIVE_CHECK\t0x10000004\n#define MUX_C_TERMINATE\t\t0x10000005\n#define MUX_C_OPEN_FWD\t\t0x10000006\n#define MUX_C_CLOSE_FWD\t\t0x10000007\n#define MUX_C_NEW_STDIO_FWD\t0x10000008\n#define MUX_C_STOP_LISTENING\t0x10000009\n#define MUX_C_PROXY\t\t0x1000000f\n#define MUX_S_OK\t\t0x80000001\n#define MUX_S_PERMISSION_DENIED\t0x80000002\n#define MUX_S_FAILURE\t\t0x80000003\n#define MUX_S_EXIT_MESSAGE\t0x80000004\n#define MUX_S_ALIVE\t\t0x80000005\n#define MUX_S_SESSION_OPENED\t0x80000006\n#define MUX_S_REMOTE_PORT\t0x80000007\n#define MUX_S_TTY_ALLOC_FAIL\t0x80000008\n#define MUX_S_PROXY\t\t0x8000000f\n\n \n#define MUX_FWD_LOCAL   1\n#define MUX_FWD_REMOTE  2\n#define MUX_FWD_DYNAMIC 3\n\nstatic void mux_session_confirm(struct ssh *, int, int, void *);\nstatic void mux_stdio_confirm(struct ssh *, int, int, void *);\n\nstatic int mux_master_process_hello(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_new_session(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_alive_check(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_terminate(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_open_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_close_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stdio_fwd(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_stop_listening(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\nstatic int mux_master_process_proxy(struct ssh *, u_int,\n\t    Channel *, struct sshbuf *, struct sshbuf *);\n\nstatic const struct {\n\tu_int type;\n\tint (*handler)(struct ssh *, u_int, Channel *,\n\t    struct sshbuf *, struct sshbuf *);\n} mux_master_handlers[] = {\n\t{ MUX_MSG_HELLO, mux_master_process_hello },\n\t{ MUX_C_NEW_SESSION, mux_master_process_new_session },\n\t{ MUX_C_ALIVE_CHECK, mux_master_process_alive_check },\n\t{ MUX_C_TERMINATE, mux_master_process_terminate },\n\t{ MUX_C_OPEN_FWD, mux_master_process_open_fwd },\n\t{ MUX_C_CLOSE_FWD, mux_master_process_close_fwd },\n\t{ MUX_C_NEW_STDIO_FWD, mux_master_process_stdio_fwd },\n\t{ MUX_C_STOP_LISTENING, mux_master_process_stop_listening },\n\t{ MUX_C_PROXY, mux_master_process_proxy },\n\t{ 0, NULL }\n};\n\n \nstatic void\nmux_master_session_cleanup_cb(struct ssh *ssh, int cid, int force, void *unused)\n{\n\tChannel *cc, *c = channel_by_id(ssh, cid);\n\n\tdebug3_f(\"entering for channel %d\", cid);\n\tif (c == NULL)\n\t\tfatal_f(\"channel_by_id(%i) == NULL\", cid);\n\tif (c->ctl_chan != -1) {\n\t\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\t\tfatal_f(\"channel %d missing control channel %d\",\n\t\t\t    c->self, c->ctl_chan);\n\t\tc->ctl_chan = -1;\n\t\tcc->remote_id = 0;\n\t\tcc->have_remote_id = 0;\n\t\tchan_rcvd_oclose(ssh, cc);\n\t}\n\tchannel_cancel_cleanup(ssh, c->self);\n}\n\n \nstatic void\nmux_master_control_cleanup_cb(struct ssh *ssh, int cid, int force, void *unused)\n{\n\tChannel *sc, *c = channel_by_id(ssh, cid);\n\n\tdebug3_f(\"entering for channel %d\", cid);\n\tif (c == NULL)\n\t\tfatal_f(\"channel_by_id(%i) == NULL\", cid);\n\tif (c->have_remote_id) {\n\t\tif ((sc = channel_by_id(ssh, c->remote_id)) == NULL)\n\t\t\tfatal_f(\"channel %d missing session channel %u\",\n\t\t\t    c->self, c->remote_id);\n\t\tc->remote_id = 0;\n\t\tc->have_remote_id = 0;\n\t\tsc->ctl_chan = -1;\n\t\tif (sc->type != SSH_CHANNEL_OPEN &&\n\t\t    sc->type != SSH_CHANNEL_OPENING) {\n\t\t\tdebug2_f(\"channel %d: not open\", sc->self);\n\t\t\tchan_mark_dead(ssh, sc);\n\t\t} else {\n\t\t\tif (sc->istate == CHAN_INPUT_OPEN)\n\t\t\t\tchan_read_failed(ssh, sc);\n\t\t\tif (sc->ostate == CHAN_OUTPUT_OPEN)\n\t\t\t\tchan_write_failed(ssh, sc);\n\t\t}\n\t}\n\tchannel_cancel_cleanup(ssh, c->self);\n}\n\n \nstatic int\nenv_permitted(const char *env)\n{\n\tu_int i;\n\tint ret;\n\tchar name[1024], *cp;\n\n\tif ((cp = strchr(env, '=')) == NULL || cp == env)\n\t\treturn 0;\n\tret = snprintf(name, sizeof(name), \"%.*s\", (int)(cp - env), env);\n\tif (ret <= 0 || (size_t)ret >= sizeof(name)) {\n\t\terror_f(\"name '%.100s...' too long\", env);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < options.num_send_env; i++)\n\t\tif (match_pattern(name, options.send_env[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\nstatic int\nmux_master_process_hello(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tu_int ver;\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tint r;\n\n\tif (state == NULL)\n\t\tfatal_f(\"channel %d: c->mux_ctx == NULL\", c->self);\n\tif (state->hello_rcvd) {\n\t\terror_f(\"HELLO received twice\");\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\treturn -1;\n\t}\n\tif (ver != SSHMUX_VER) {\n\t\terror_f(\"unsupported multiplexing protocol version %u \"\n\t\t    \"(expected %u)\", ver, SSHMUX_VER);\n\t\treturn -1;\n\t}\n\tdebug2_f(\"channel %d client version %u\", c->self, ver);\n\n\t \n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\t\tsize_t value_len = 0;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, NULL, &value_len)) != 0) {\n\t\t\terror_fr(r, \"parse extension\");\n\t\t\treturn -1;\n\t\t}\n\t\tdebug2_f(\"Unrecognised extension \\\"%s\\\" length %zu\",\n\t\t    name, value_len);\n\t\tfree(name);\n\t}\n\tstate->hello_rcvd = 1;\n\treturn 0;\n}\n\n \nstatic void\nreply_ok(struct sshbuf *reply, u_int rid)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, MUX_S_OK)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal_fr(r, \"reply\");\n}\n\n \nstatic void\nreply_error(struct sshbuf *reply, u_int type, u_int rid, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(reply, type)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_cstring(reply, msg)) != 0)\n\t\tfatal_fr(r, \"reply\");\n}\n\nstatic int\nmux_master_process_new_session(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tChannel *nc;\n\tstruct mux_session_confirm_ctx *cctx;\n\tchar *cmd, *cp;\n\tu_int i, j, env_len, escape_char, window, packetmax;\n\tint r, new_fd[3];\n\n\t \n\tcctx = xcalloc(1, sizeof(*cctx));\n\tcctx->term = NULL;\n\tcctx->rid = rid;\n\tcmd = NULL;\n\tcctx->env = NULL;\n\tenv_len = 0;\n\tif ((r = sshbuf_skip_string(m)) != 0 ||  \n\t    (r = sshbuf_get_u32(m, &cctx->want_tty)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_x_fwd)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_agent_fwd)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cctx->want_subsys)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &escape_char)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cctx->term, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cmd, NULL)) != 0) {\n malf:\n\t\tfree(cmd);\n\t\tfor (j = 0; j < env_len; j++)\n\t\t\tfree(cctx->env[j]);\n\t\tfree(cctx->env);\n\t\tfree(cctx->term);\n\t\tfree(cctx);\n\t\terror_f(\"malformed message\");\n\t\treturn -1;\n\t}\n\n#define MUX_MAX_ENV_VARS\t4096\n\twhile (sshbuf_len(m) > 0) {\n\t\tif ((r = sshbuf_get_cstring(m, &cp, NULL)) != 0)\n\t\t\tgoto malf;\n\t\tif (!env_permitted(cp)) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tcctx->env = xreallocarray(cctx->env, env_len + 2,\n\t\t    sizeof(*cctx->env));\n\t\tcctx->env[env_len++] = cp;\n\t\tcctx->env[env_len] = NULL;\n\t\tif (env_len > MUX_MAX_ENV_VARS) {\n\t\t\terror_f(\">%d environment variables received, \"\n\t\t\t    \"ignoring additional\", MUX_MAX_ENV_VARS);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdebug2_f(\"channel %d: request tty %d, X %d, agent %d, subsys %d, \"\n\t    \"term \\\"%s\\\", cmd \\\"%s\\\", env %u\", c->self,\n\t    cctx->want_tty, cctx->want_x_fwd, cctx->want_agent_fwd,\n\t    cctx->want_subsys, cctx->term, cmd, env_len);\n\n\tif ((cctx->cmd = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put(cctx->cmd, cmd, strlen(cmd))) != 0)\n\t\tfatal_fr(r, \"sshbuf_put\");\n\tfree(cmd);\n\tcmd = NULL;\n\n\t \n\tfor(i = 0; i < 3; i++) {\n\t\tif ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {\n\t\t\terror_f(\"failed to receive fd %d from client\", i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(new_fd[j]);\n\t\t\tfor (j = 0; j < env_len; j++)\n\t\t\t\tfree(cctx->env[j]);\n\t\t\tfree(cctx->env);\n\t\t\tfree(cctx->term);\n\t\t\tsshbuf_free(cctx->cmd);\n\t\t\tfree(cctx);\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"did not receive file descriptors\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdebug3_f(\"got fds stdin %d, stdout %d, stderr %d\",\n\t    new_fd[0], new_fd[1], new_fd[2]);\n\n\t \n\tif (c->have_remote_id) {\n\t\tdebug2_f(\"session already open\");\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Multiple sessions not supported\");\n cleanup:\n\t\tclose(new_fd[0]);\n\t\tclose(new_fd[1]);\n\t\tclose(new_fd[2]);\n\t\tfree(cctx->term);\n\t\tif (env_len != 0) {\n\t\t\tfor (i = 0; i < env_len; i++)\n\t\t\t\tfree(cctx->env[i]);\n\t\t\tfree(cctx->env);\n\t\t}\n\t\tsshbuf_free(cctx->cmd);\n\t\tfree(cctx);\n\t\treturn 0;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Allow shared connection to %s? \", host)) {\n\t\t\tdebug2_f(\"session refused by user\");\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tif (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)\n\t\terror_f(\"tcgetattr: %s\", strerror(errno));\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (cctx->want_tty) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\n\tnc = channel_new(ssh, \"session\", SSH_CHANNEL_OPENING,\n\t    new_fd[0], new_fd[1], new_fd[2], window, packetmax,\n\t    CHAN_EXTENDED_WRITE, \"client-session\", CHANNEL_NONBLOCK_STDIO);\n\n\tnc->ctl_chan = c->self;\t\t \n\tc->remote_id = nc->self;\t \n\tc->have_remote_id = 1;\n\n\tif (cctx->want_tty && escape_char != 0xffffffff) {\n\t\tchannel_register_filter(ssh, nc->self,\n\t\t    client_simple_escape_filter, NULL,\n\t\t    client_filter_cleanup,\n\t\t    client_new_escape_filter_ctx((int)escape_char));\n\t}\n\n\tdebug2_f(\"channel_new: %d linked to control channel %d\",\n\t    nc->self, nc->ctl_chan);\n\n\tchannel_send_open(ssh, nc->self);\n\tchannel_register_open_confirm(ssh, nc->self, mux_session_confirm, cctx);\n\tc->mux_pause = 1;  \n\tchannel_register_cleanup(ssh, nc->self,\n\t    mux_master_session_cleanup_cb, 1);\n\n\t \n\treturn 0;\n}\n\nstatic int\nmux_master_process_alive_check(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tint r;\n\n\tdebug2_f(\"channel %d: alive check\", c->self);\n\n\t \n\tif ((r = sshbuf_put_u32(reply, MUX_S_ALIVE)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, (u_int)getpid())) != 0)\n\t\tfatal_fr(r, \"reply\");\n\n\treturn 0;\n}\n\nstatic int\nmux_master_process_terminate(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tdebug2_f(\"channel %d: terminate request\", c->self);\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Terminate shared connection to %s? \",\n\t\t    host)) {\n\t\t\tdebug2_f(\"termination refused by user\");\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tquit_pending = 1;\n\treply_ok(reply, rid);\n\t \n\treturn 0;\n}\n\nstatic char *\nformat_forward(u_int ftype, struct Forward *fwd)\n{\n\tchar *ret;\n\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\t\txasprintf(&ret, \"local forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tcase MUX_FWD_DYNAMIC:\n\t\txasprintf(&ret, \"dynamic forward %.200s:%d -> *\",\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    fwd->listen_host, fwd->listen_port);\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\txasprintf(&ret, \"remote forward %.200s:%d -> %.200s:%d\",\n\t\t    (fwd->listen_path != NULL) ? fwd->listen_path :\n\t\t    (fwd->listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : fwd->listen_host,\n\t\t    fwd->listen_port,\n\t\t    (fwd->connect_path != NULL) ? fwd->connect_path :\n\t\t    fwd->connect_host, fwd->connect_port);\n\t\tbreak;\n\tdefault:\n\t\tfatal_f(\"unknown forward type %u\", ftype);\n\t}\n\treturn ret;\n}\n\nstatic int\ncompare_host(const char *a, const char *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\treturn strcmp(a, b) == 0;\n}\n\nstatic int\ncompare_forward(struct Forward *a, struct Forward *b)\n{\n\tif (!compare_host(a->listen_host, b->listen_host))\n\t\treturn 0;\n\tif (!compare_host(a->listen_path, b->listen_path))\n\t\treturn 0;\n\tif (a->listen_port != b->listen_port)\n\t\treturn 0;\n\tif (!compare_host(a->connect_host, b->connect_host))\n\t\treturn 0;\n\tif (!compare_host(a->connect_path, b->connect_path))\n\t\treturn 0;\n\tif (a->connect_port != b->connect_port)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void\nmux_confirm_remote_forward(struct ssh *ssh, int type, u_int32_t seq, void *ctxt)\n{\n\tstruct mux_channel_confirm_ctx *fctx = ctxt;\n\tchar *failmsg = NULL;\n\tstruct Forward *rfwd;\n\tChannel *c;\n\tstruct sshbuf *out;\n\tu_int port;\n\tint r;\n\n\tif ((c = channel_by_id(ssh, fctx->cid)) == NULL) {\n\t\t \n\t\terror_f(\"unknown channel\");\n\t\treturn;\n\t}\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif (fctx->fid >= options.num_remote_forwards ||\n\t    (options.remote_forwards[fctx->fid].connect_path == NULL &&\n\t    options.remote_forwards[fctx->fid].connect_host == NULL)) {\n\t\txasprintf(&failmsg, \"unknown forwarding id %d\", fctx->fid);\n\t\tgoto fail;\n\t}\n\trfwd = &options.remote_forwards[fctx->fid];\n\tdebug_f(\"%s for: listen %d, connect %s:%d\",\n\t    type == SSH2_MSG_REQUEST_SUCCESS ? \"success\" : \"failure\",\n\t    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :\n\t    rfwd->connect_host, rfwd->connect_port);\n\tif (type == SSH2_MSG_REQUEST_SUCCESS) {\n\t\tif (rfwd->listen_port == 0) {\n\t\t\tif ((r = sshpkt_get_u32(ssh, &port)) != 0)\n\t\t\t\tfatal_fr(r, \"parse port\");\n\t\t\tif (port > 65535) {\n\t\t\t\tfatal(\"Invalid allocated port %u for \"\n\t\t\t\t    \"mux remote forward to %s:%d\", port,\n\t\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\t}\n\t\t\trfwd->allocated_port = (int)port;\n\t\t\tdebug(\"Allocated port %u for mux remote forward\"\n\t\t\t    \" to %s:%d\", rfwd->allocated_port,\n\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\tif ((r = sshbuf_put_u32(out,\n\t\t\t    MUX_S_REMOTE_PORT)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(out, fctx->rid)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(out,\n\t\t\t    rfwd->allocated_port)) != 0)\n\t\t\t\tfatal_fr(r, \"reply\");\n\t\t\tchannel_update_permission(ssh, rfwd->handle,\n\t\t\t    rfwd->allocated_port);\n\t\t} else {\n\t\t\treply_ok(out, fctx->rid);\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\tif (rfwd->listen_port == 0)\n\t\t\tchannel_update_permission(ssh, rfwd->handle, -1);\n\t\tif (rfwd->listen_path != NULL)\n\t\t\txasprintf(&failmsg, \"remote port forwarding failed for \"\n\t\t\t    \"listen path %s\", rfwd->listen_path);\n\t\telse\n\t\t\txasprintf(&failmsg, \"remote port forwarding failed for \"\n\t\t\t    \"listen port %d\", rfwd->listen_port);\n\n\t\tdebug2_f(\"clearing registered forwarding for listen %d, \"\n\t\t    \"connect %s:%d\", rfwd->listen_port,\n\t\t    rfwd->connect_path ? rfwd->connect_path :\n\t\t    rfwd->connect_host, rfwd->connect_port);\n\n\t\tfree(rfwd->listen_host);\n\t\tfree(rfwd->listen_path);\n\t\tfree(rfwd->connect_host);\n\t\tfree(rfwd->connect_path);\n\t\tmemset(rfwd, 0, sizeof(*rfwd));\n\t}\n fail:\n\terror_f(\"%s\", failmsg);\n\treply_error(out, MUX_S_FAILURE, fctx->rid, failmsg);\n\tfree(failmsg);\n out:\n\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(out);\n\tif (c->mux_pause <= 0)\n\t\tfatal_f(\"mux_pause %d\", c->mux_pause);\n\tc->mux_pause = 0;  \n}\n\nstatic int\nmux_master_process_open_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tstruct Forward fwd;\n\tchar *fwd_desc = NULL;\n\tchar *listen_addr, *connect_addr;\n\tu_int ftype;\n\tu_int lport, cport;\n\tint r, i, ret = 0, freefwd = 1;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\t \n\tif ((r = sshbuf_get_u32(m, &ftype)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &listen_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &lport)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &connect_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0 ||\n\t    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||\n\t    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {\n\t\terror_f(\"malformed message\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tif (*listen_addr == '\\0') {\n\t\tfree(listen_addr);\n\t\tlisten_addr = NULL;\n\t}\n\tif (*connect_addr == '\\0') {\n\t\tfree(connect_addr);\n\t\tconnect_addr = NULL;\n\t}\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tfwd.listen_port = lport;\n\tif (fwd.listen_port == PORT_STREAMLOCAL)\n\t\tfwd.listen_path = listen_addr;\n\telse\n\t\tfwd.listen_host = listen_addr;\n\tfwd.connect_port = cport;\n\tif (fwd.connect_port == PORT_STREAMLOCAL)\n\t\tfwd.connect_path = connect_addr;\n\telse\n\t\tfwd.connect_host = connect_addr;\n\n\tdebug2_f(\"channel %d: request %s\", c->self,\n\t    (fwd_desc = format_forward(ftype, &fwd)));\n\n\tif (ftype != MUX_FWD_LOCAL && ftype != MUX_FWD_REMOTE &&\n\t    ftype != MUX_FWD_DYNAMIC) {\n\t\tlogit_f(\"invalid forwarding type %u\", ftype);\n invalid:\n\t\tfree(listen_addr);\n\t\tfree(connect_addr);\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Invalid forwarding request\");\n\t\treturn 0;\n\t}\n\tif (ftype == MUX_FWD_DYNAMIC && fwd.listen_path) {\n\t\tlogit_f(\"streamlocal and dynamic forwards \"\n\t\t    \"are mutually exclusive\");\n\t\tgoto invalid;\n\t}\n\tif (fwd.listen_port != PORT_STREAMLOCAL && fwd.listen_port >= 65536) {\n\t\tlogit_f(\"invalid listen port %u\", fwd.listen_port);\n\t\tgoto invalid;\n\t}\n\tif ((fwd.connect_port != PORT_STREAMLOCAL &&\n\t    fwd.connect_port >= 65536) ||\n\t    (ftype != MUX_FWD_DYNAMIC && ftype != MUX_FWD_REMOTE &&\n\t    fwd.connect_port == 0)) {\n\t\tlogit_f(\"invalid connect port %u\",\n\t\t    fwd.connect_port);\n\t\tgoto invalid;\n\t}\n\tif (ftype != MUX_FWD_DYNAMIC && fwd.connect_host == NULL &&\n\t    fwd.connect_path == NULL) {\n\t\tlogit_f(\"missing connect host\");\n\t\tgoto invalid;\n\t}\n\n\t \n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\tcase MUX_FWD_DYNAMIC:\n\t\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.local_forwards + i)) {\n exists:\n\t\t\t\tdebug2_f(\"found existing forwarding\");\n\t\t\t\treply_ok(reply, rid);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\t\tif (!compare_forward(&fwd, options.remote_forwards + i))\n\t\t\t\tcontinue;\n\t\t\tif (fwd.listen_port != 0)\n\t\t\t\tgoto exists;\n\t\t\tdebug2_f(\"found allocated port\");\n\t\t\tif ((r = sshbuf_put_u32(reply,\n\t\t\t    MUX_S_REMOTE_PORT)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(reply, rid)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(reply,\n\t\t\t    options.remote_forwards[i].allocated_port)) != 0)\n\t\t\t\tfatal_fr(r, \"reply FWD_REMOTE\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Open %s on %s?\", fwd_desc, host)) {\n\t\t\tdebug2_f(\"forwarding refused by user\");\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ftype == MUX_FWD_LOCAL || ftype == MUX_FWD_DYNAMIC) {\n\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t    &options.fwd_opts)) {\n fail:\n\t\t\tlogit_f(\"requested %s failed\", fwd_desc);\n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"Port forwarding failed\");\n\t\t\tgoto out;\n\t\t}\n\t\tadd_local_forward(&options, &fwd);\n\t\tfreefwd = 0;\n\t} else {\n\t\tstruct mux_channel_confirm_ctx *fctx;\n\n\t\tfwd.handle = channel_request_remote_forwarding(ssh, &fwd);\n\t\tif (fwd.handle < 0)\n\t\t\tgoto fail;\n\t\tadd_remote_forward(&options, &fwd);\n\t\tfctx = xcalloc(1, sizeof(*fctx));\n\t\tfctx->cid = c->self;\n\t\tfctx->rid = rid;\n\t\tfctx->fid = options.num_remote_forwards - 1;\n\t\tclient_register_global_confirm(mux_confirm_remote_forward,\n\t\t    fctx);\n\t\tfreefwd = 0;\n\t\tc->mux_pause = 1;  \n\t\t \n\t\tgoto out;\n\t}\n\treply_ok(reply, rid);\n out:\n\tfree(fwd_desc);\n\tif (freefwd) {\n\t\tfree(fwd.listen_host);\n\t\tfree(fwd.listen_path);\n\t\tfree(fwd.connect_host);\n\t\tfree(fwd.connect_path);\n\t}\n\treturn ret;\n}\n\nstatic int\nmux_master_process_close_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tstruct Forward fwd, *found_fwd;\n\tchar *fwd_desc = NULL;\n\tconst char *error_reason = NULL;\n\tchar *listen_addr = NULL, *connect_addr = NULL;\n\tu_int ftype;\n\tint r, i, ret = 0;\n\tu_int lport, cport;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tif ((r = sshbuf_get_u32(m, &ftype)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &listen_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &lport)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &connect_addr, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &cport)) != 0 ||\n\t    (lport != (u_int)PORT_STREAMLOCAL && lport > 65535) ||\n\t    (cport != (u_int)PORT_STREAMLOCAL && cport > 65535)) {\n\t\terror_f(\"malformed message\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (*listen_addr == '\\0') {\n\t\tfree(listen_addr);\n\t\tlisten_addr = NULL;\n\t}\n\tif (*connect_addr == '\\0') {\n\t\tfree(connect_addr);\n\t\tconnect_addr = NULL;\n\t}\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tfwd.listen_port = lport;\n\tif (fwd.listen_port == PORT_STREAMLOCAL)\n\t\tfwd.listen_path = listen_addr;\n\telse\n\t\tfwd.listen_host = listen_addr;\n\tfwd.connect_port = cport;\n\tif (fwd.connect_port == PORT_STREAMLOCAL)\n\t\tfwd.connect_path = connect_addr;\n\telse\n\t\tfwd.connect_host = connect_addr;\n\n\tdebug2_f(\"channel %d: request cancel %s\", c->self,\n\t    (fwd_desc = format_forward(ftype, &fwd)));\n\n\t \n\tfound_fwd = NULL;\n\tswitch (ftype) {\n\tcase MUX_FWD_LOCAL:\n\tcase MUX_FWD_DYNAMIC:\n\t\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.local_forwards + i)) {\n\t\t\t\tfound_fwd = options.local_forwards + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MUX_FWD_REMOTE:\n\t\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\t\tif (compare_forward(&fwd,\n\t\t\t    options.remote_forwards + i)) {\n\t\t\t\tfound_fwd = options.remote_forwards + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (found_fwd == NULL)\n\t\terror_reason = \"port not forwarded\";\n\telse if (ftype == MUX_FWD_REMOTE) {\n\t\t \n\t\tif (channel_request_rforward_cancel(ssh, found_fwd) == -1)\n\t\t\terror_reason = \"port not in permitted opens\";\n\t} else {\t \n\t\t \n\t\tif (channel_cancel_lport_listener(ssh, &fwd, fwd.connect_port,\n\t\t    &options.fwd_opts) == -1)\n\t\t\terror_reason = \"port not found\";\n\t}\n\n\tif (error_reason != NULL)\n\t\treply_error(reply, MUX_S_FAILURE, rid, error_reason);\n\telse {\n\t\treply_ok(reply, rid);\n\t\tfree(found_fwd->listen_host);\n\t\tfree(found_fwd->listen_path);\n\t\tfree(found_fwd->connect_host);\n\t\tfree(found_fwd->connect_path);\n\t\tfound_fwd->listen_host = found_fwd->connect_host = NULL;\n\t\tfound_fwd->listen_path = found_fwd->connect_path = NULL;\n\t\tfound_fwd->listen_port = found_fwd->connect_port = 0;\n\t}\n out:\n\tfree(fwd_desc);\n\tfree(listen_addr);\n\tfree(connect_addr);\n\n\treturn ret;\n}\n\nstatic int\nmux_master_process_stdio_fwd(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tChannel *nc;\n\tchar *chost = NULL;\n\tu_int _cport, i, j;\n\tint ok = 0, cport, r, new_fd[2];\n\tstruct mux_stdio_confirm_ctx *cctx;\n\n\tif ((r = sshbuf_skip_string(m)) != 0 ||  \n\t    (r = sshbuf_get_cstring(m, &chost, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &_cport)) != 0) {\n\t\tfree(chost);\n\t\terror_f(\"malformed message\");\n\t\treturn -1;\n\t}\n\tif (_cport == (u_int)PORT_STREAMLOCAL)\n\t\tcport = PORT_STREAMLOCAL;\n\telse if (_cport <= INT_MAX)\n\t\tcport = (int)_cport;\n\telse {\n\t\tfree(chost);\n\t\terror_f(\"invalid port 0x%x\", _cport);\n\t\treturn -1;\n\t}\n\n\tdebug2_f(\"channel %d: stdio fwd to %s:%d\", c->self, chost, cport);\n\n\t \n\tfor(i = 0; i < 2; i++) {\n\t\tif ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {\n\t\t\terror_f(\"failed to receive fd %d from client\", i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tclose(new_fd[j]);\n\t\t\tfree(chost);\n\n\t\t\t \n\t\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t\t    \"did not receive file descriptors\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdebug3_f(\"got fds stdin %d, stdout %d\", new_fd[0], new_fd[1]);\n\n\t \n\tif (c->have_remote_id) {\n\t\tdebug2_f(\"session already open\");\n\t\treply_error(reply, MUX_S_FAILURE, rid,\n\t\t    \"Multiple sessions not supported\");\n cleanup:\n\t\tclose(new_fd[0]);\n\t\tclose(new_fd[1]);\n\t\tfree(chost);\n\t\treturn 0;\n\t}\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (cport == PORT_STREAMLOCAL) {\n\t\t\tok = ask_permission(\"Allow forward to path %s\", chost);\n\t\t} else {\n\t\t\tok = ask_permission(\"Allow forward to [%s]:%d? \",\n\t\t\t    chost, cport);\n\t\t}\n\t\tif (!ok) {\n\t\t\tdebug2_f(\"stdio fwd refused by user\");\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tnc = channel_connect_stdio_fwd(ssh, chost, cport, new_fd[0], new_fd[1],\n\t    CHANNEL_NONBLOCK_STDIO);\n\tfree(chost);\n\n\tnc->ctl_chan = c->self;\t\t \n\tc->remote_id = nc->self;\t \n\tc->have_remote_id = 1;\n\n\tdebug2_f(\"channel_new: %d control %d\", nc->self, nc->ctl_chan);\n\n\tchannel_register_cleanup(ssh, nc->self,\n\t    mux_master_session_cleanup_cb, 1);\n\n\tcctx = xcalloc(1, sizeof(*cctx));\n\tcctx->rid = rid;\n\tchannel_register_open_confirm(ssh, nc->self, mux_stdio_confirm, cctx);\n\tc->mux_pause = 1;  \n\n\t \n\treturn 0;\n}\n\n \nstatic void\nmux_stdio_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tstruct mux_stdio_confirm_ctx *cctx = arg;\n\tChannel *c, *cc;\n\tstruct sshbuf *reply;\n\tint r;\n\n\tif (cctx == NULL)\n\t\tfatal_f(\"cctx == NULL\");\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal_f(\"no channel for id %d\", id);\n\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal_f(\"channel %d lacks control channel %d\",\n\t\t    id, c->ctl_chan);\n\tif ((reply = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\n\tif (!success) {\n\t\tdebug3_f(\"sending failure reply\");\n\t\treply_error(reply, MUX_S_FAILURE, cctx->rid,\n\t\t    \"Session open refused by peer\");\n\t\t \n\t\tgoto done;\n\t}\n\n\tdebug3_f(\"sending success reply\");\n\t \n\tif ((r = sshbuf_put_u32(reply, MUX_S_SESSION_OPENED)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, cctx->rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, c->self)) != 0)\n\t\tfatal_fr(r, \"reply\");\n\n done:\n\t \n\tif ((r = sshbuf_put_stringb(cc->output, reply)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(reply);\n\n\tif (cc->mux_pause <= 0)\n\t\tfatal_f(\"mux_pause %d\", cc->mux_pause);\n\tcc->mux_pause = 0;  \n\tc->open_confirm_ctx = NULL;\n\tfree(cctx);\n}\n\nstatic int\nmux_master_process_stop_listening(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tdebug_f(\"channel %d: stop listening\", c->self);\n\n\tif (options.control_master == SSHCTL_MASTER_ASK ||\n\t    options.control_master == SSHCTL_MASTER_AUTO_ASK) {\n\t\tif (!ask_permission(\"Disable further multiplexing on shared \"\n\t\t    \"connection to %s? \", host)) {\n\t\t\tdebug2_f(\"stop listen refused by user\");\n\t\t\treply_error(reply, MUX_S_PERMISSION_DENIED, rid,\n\t\t\t    \"Permission denied\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (mux_listener_channel != NULL) {\n\t\tchannel_free(ssh, mux_listener_channel);\n\t\tclient_stop_mux();\n\t\tfree(options.control_path);\n\t\toptions.control_path = NULL;\n\t\tmux_listener_channel = NULL;\n\t\tmuxserver_sock = -1;\n\t}\n\n\treply_ok(reply, rid);\n\treturn 0;\n}\n\nstatic int\nmux_master_process_proxy(struct ssh *ssh, u_int rid,\n    Channel *c, struct sshbuf *m, struct sshbuf *reply)\n{\n\tint r;\n\n\tdebug_f(\"channel %d: proxy request\", c->self);\n\n\tc->mux_rcb = channel_proxy_downstream;\n\tif ((r = sshbuf_put_u32(reply, MUX_S_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, rid)) != 0)\n\t\tfatal_fr(r, \"reply\");\n\n\treturn 0;\n}\n\n \nstatic int\nmux_master_read_cb(struct ssh *ssh, Channel *c)\n{\n\tstruct mux_master_state *state = (struct mux_master_state *)c->mux_ctx;\n\tstruct sshbuf *in = NULL, *out = NULL;\n\tu_int type, rid, i;\n\tint r, ret = -1;\n\n\tif ((out = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\n\t \n\tif (c->mux_ctx == NULL) {\n\t\tstate = xcalloc(1, sizeof(*state));\n\t\tc->mux_ctx = state;\n\t\tchannel_register_cleanup(ssh, c->self,\n\t\t    mux_master_control_cleanup_cb, 0);\n\n\t\t \n\t\tif ((r = sshbuf_put_u32(out, MUX_MSG_HELLO)) != 0 ||\n\t\t    (r = sshbuf_put_u32(out, SSHMUX_VER)) != 0)\n\t\t\tfatal_fr(r, \"reply\");\n\t\t \n\t\tif ((r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\t\tfatal_fr(r, \"enqueue\");\n\t\tdebug3_f(\"channel %d: hello sent\", c->self);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_froms(c->input, &in)) != 0) {\n malf:\n\t\terror_f(\"malformed message\");\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(in, &type)) != 0)\n\t\tgoto malf;\n\tdebug3_f(\"channel %d packet type 0x%08x len %zu\", c->self,\n\t    type, sshbuf_len(in));\n\n\tif (type == MUX_MSG_HELLO)\n\t\trid = 0;\n\telse {\n\t\tif (!state->hello_rcvd) {\n\t\t\terror_f(\"expected MUX_MSG_HELLO(0x%08x), \"\n\t\t\t    \"received 0x%08x\", MUX_MSG_HELLO, type);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(in, &rid)) != 0)\n\t\t\tgoto malf;\n\t}\n\n\tfor (i = 0; mux_master_handlers[i].handler != NULL; i++) {\n\t\tif (type == mux_master_handlers[i].type) {\n\t\t\tret = mux_master_handlers[i].handler(ssh, rid,\n\t\t\t    c, in, out);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mux_master_handlers[i].handler == NULL) {\n\t\terror_f(\"unsupported mux message 0x%08x\", type);\n\t\treply_error(out, MUX_S_FAILURE, rid, \"unsupported request\");\n\t\tret = 0;\n\t}\n\t \n\tif (sshbuf_len(out) != 0 &&\n\t    (r = sshbuf_put_stringb(c->output, out)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n out:\n\tsshbuf_free(in);\n\tsshbuf_free(out);\n\treturn ret;\n}\n\nvoid\nmux_exit_message(struct ssh *ssh, Channel *c, int exitval)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3_f(\"channel %d: exit message, exitval %d\", c->self, exitval);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal_f(\"channel %d missing mux %d\", c->self, c->ctl_chan);\n\n\t \n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_S_EXIT_MESSAGE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_u32(m, exitval)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal_fr(r, \"reply\");\n\tsshbuf_free(m);\n}\n\nvoid\nmux_tty_alloc_failed(struct ssh *ssh, Channel *c)\n{\n\tstruct sshbuf *m;\n\tChannel *mux_chan;\n\tint r;\n\n\tdebug3_f(\"channel %d: TTY alloc failed\", c->self);\n\n\tif ((mux_chan = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal_f(\"channel %d missing mux %d\", c->self, c->ctl_chan);\n\n\t \n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_S_TTY_ALLOC_FAIL)) != 0 ||\n\t    (r = sshbuf_put_u32(m, c->self)) != 0 ||\n\t    (r = sshbuf_put_stringb(mux_chan->output, m)) != 0)\n\t\tfatal_fr(r, \"reply\");\n\tsshbuf_free(m);\n}\n\n \nvoid\nmuxserver_listen(struct ssh *ssh)\n{\n\tmode_t old_umask;\n\tchar *orig_control_path = options.control_path;\n\tchar rbuf[16+1];\n\tu_int i, r;\n\tint oerrno;\n\n\tif (options.control_path == NULL ||\n\t    options.control_master == SSHCTL_MASTER_NO)\n\t\treturn;\n\n\tdebug(\"setting up multiplex master socket\");\n\n\t \n\tfor (i = 0; i < sizeof(rbuf) - 1; i++) {\n\t\tr = arc4random_uniform(26+26+10);\n\t\trbuf[i] = (r < 26) ? 'a' + r :\n\t\t    (r < 26*2) ? 'A' + r - 26 :\n\t\t    '0' + r - 26 - 26;\n\t}\n\trbuf[sizeof(rbuf) - 1] = '\\0';\n\toptions.control_path = NULL;\n\txasprintf(&options.control_path, \"%s.%s\", orig_control_path, rbuf);\n\tdebug3_f(\"temporary control path %s\", options.control_path);\n\n\told_umask = umask(0177);\n\tmuxserver_sock = unix_listener(options.control_path, 64, 0);\n\toerrno = errno;\n\tumask(old_umask);\n\tif (muxserver_sock < 0) {\n\t\tif (oerrno == EINVAL || oerrno == EADDRINUSE) {\n\t\t\terror(\"ControlSocket %s already exists, \"\n\t\t\t    \"disabling multiplexing\", options.control_path);\n disable_mux_master:\n\t\t\tif (muxserver_sock != -1) {\n\t\t\t\tclose(muxserver_sock);\n\t\t\t\tmuxserver_sock = -1;\n\t\t\t}\n\t\t\tfree(orig_control_path);\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = NULL;\n\t\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t \n\tif (link(options.control_path, orig_control_path) != 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tfatal_f(\"link mux listener %s => %s: %s\",\n\t\t\t    options.control_path, orig_control_path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\terror(\"ControlSocket %s already exists, disabling multiplexing\",\n\t\t    orig_control_path);\n\t\tunlink(options.control_path);\n\t\tgoto disable_mux_master;\n\t}\n\tunlink(options.control_path);\n\tfree(options.control_path);\n\toptions.control_path = orig_control_path;\n\n\tset_nonblock(muxserver_sock);\n\n\tmux_listener_channel = channel_new(ssh, \"mux listener\",\n\t    SSH_CHANNEL_MUX_LISTENER, muxserver_sock, muxserver_sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT,\n\t    0, options.control_path, 1);\n\tmux_listener_channel->mux_rcb = mux_master_read_cb;\n\tdebug3_f(\"mux listener channel %d fd %d\",\n\t    mux_listener_channel->self, mux_listener_channel->sock);\n}\n\n \nstatic void\nmux_session_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tstruct mux_session_confirm_ctx *cctx = arg;\n\tconst char *display;\n\tChannel *c, *cc;\n\tint i, r;\n\tstruct sshbuf *reply;\n\n\tif (cctx == NULL)\n\t\tfatal_f(\"cctx == NULL\");\n\tif ((c = channel_by_id(ssh, id)) == NULL)\n\t\tfatal_f(\"no channel for id %d\", id);\n\tif ((cc = channel_by_id(ssh, c->ctl_chan)) == NULL)\n\t\tfatal_f(\"channel %d lacks control channel %d\",\n\t\t    id, c->ctl_chan);\n\tif ((reply = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\n\tif (!success) {\n\t\tdebug3_f(\"sending failure reply\");\n\t\treply_error(reply, MUX_S_FAILURE, cctx->rid,\n\t\t    \"Session open refused by peer\");\n\t\tgoto done;\n\t}\n\n\tdisplay = getenv(\"DISPLAY\");\n\tif (cctx->want_x_fwd && options.forward_x11 && display != NULL) {\n\t\tchar *proto, *data;\n\n\t\t \n\t\tif (client_x11_get_proto(ssh, display, options.xauth_location,\n\t\t    options.forward_x11_trusted, options.forward_x11_timeout,\n\t\t    &proto, &data) == 0) {\n\t\t\t \n\t\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t\t    \"spoofing.\");\n\t\t\tx11_request_forwarding_with_spoofing(ssh, id,\n\t\t\t    display, proto, data, 1);\n\t\t\t \n\t\t\tclient_expect_confirm(ssh, id, \"X11 forwarding\",\n\t\t\t    CONFIRM_WARN);\n\t\t}\n\t}\n\n\tif (cctx->want_agent_fwd && options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tchannel_request_start(ssh, id, \"auth-agent-req@openssh.com\", 0);\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send\");\n\t}\n\n\tclient_session2_setup(ssh, id, cctx->want_tty, cctx->want_subsys,\n\t    cctx->term, &cctx->tio, c->rfd, cctx->cmd, cctx->env);\n\n\tdebug3_f(\"sending success reply\");\n\t \n\tif ((r = sshbuf_put_u32(reply, MUX_S_SESSION_OPENED)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, cctx->rid)) != 0 ||\n\t    (r = sshbuf_put_u32(reply, c->self)) != 0)\n\t\tfatal_fr(r, \"reply\");\n\n done:\n\t \n\tif ((r = sshbuf_put_stringb(cc->output, reply)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(reply);\n\n\tif (cc->mux_pause <= 0)\n\t\tfatal_f(\"mux_pause %d\", cc->mux_pause);\n\tcc->mux_pause = 0;  \n\tc->open_confirm_ctx = NULL;\n\tsshbuf_free(cctx->cmd);\n\tfree(cctx->term);\n\tif (cctx->env != NULL) {\n\t\tfor (i = 0; cctx->env[i] != NULL; i++)\n\t\t\tfree(cctx->env[i]);\n\t\tfree(cctx->env);\n\t}\n\tfree(cctx);\n}\n\n \n\n \nstatic void\ncontrol_client_sighandler(int signo)\n{\n\tmuxclient_terminate = signo;\n}\n\n \nstatic void\ncontrol_client_sigrelay(int signo)\n{\n\tint save_errno = errno;\n\n\tif (muxserver_pid > 1)\n\t\tkill(muxserver_pid, signo);\n\n\terrno = save_errno;\n}\n\nstatic int\nmux_client_read(int fd, struct sshbuf *b, size_t need, int timeout_ms)\n{\n\tsize_t have;\n\tssize_t len;\n\tu_char *p;\n\tint r;\n\n\tif ((r = sshbuf_reserve(b, need, &p)) != 0)\n\t\tfatal_fr(r, \"reserve\");\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = read(fd, p + have, need - have);\n\t\tif (len == -1) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\tif (waitrfd(fd, &timeout_ms,\n\t\t\t\t    &muxclient_terminate) == -1 &&\n\t\t\t\t    errno != EINTR)\n\t\t\t\t\treturn -1;\t \n\t\t\t\t \n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (size_t)len;\n\t}\n\treturn 0;\n}\n\nstatic int\nmux_client_write_packet(int fd, struct sshbuf *m)\n{\n\tstruct sshbuf *queue;\n\tu_int have, need;\n\tint r, oerrno, len;\n\tconst u_char *ptr;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n\tpfd.events = POLLOUT;\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_stringb(queue, m)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\n\tneed = sshbuf_len(queue);\n\tptr = sshbuf_ptr(queue);\n\n\tfor (have = 0; have < need; ) {\n\t\tif (muxclient_terminate) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EINTR;\n\t\t\treturn -1;\n\t\t}\n\t\tlen = write(fd, ptr + have, need - have);\n\t\tif (len == -1) {\n\t\t\tswitch (errno) {\n#if defined(EWOULDBLOCK) && (EWOULDBLOCK != EAGAIN)\n\t\t\tcase EWOULDBLOCK:\n#endif\n\t\t\tcase EAGAIN:\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\t \n\t\t\tcase EINTR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\toerrno = errno;\n\t\t\t\tsshbuf_free(queue);\n\t\t\t\terrno = oerrno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (len == 0) {\n\t\t\tsshbuf_free(queue);\n\t\t\terrno = EPIPE;\n\t\t\treturn -1;\n\t\t}\n\t\thave += (u_int)len;\n\t}\n\tsshbuf_free(queue);\n\treturn 0;\n}\n\nstatic int\nmux_client_read_packet_timeout(int fd, struct sshbuf *m, int timeout_ms)\n{\n\tstruct sshbuf *queue;\n\tsize_t need, have;\n\tconst u_char *ptr;\n\tint r, oerrno;\n\n\tif ((queue = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif (mux_client_read(fd, queue, 4, timeout_ms) != 0) {\n\t\tif ((oerrno = errno) == EPIPE)\n\t\t\tdebug3_f(\"read header failed: %s\",\n\t\t\t    strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tneed = PEEK_U32(sshbuf_ptr(queue));\n\tif (mux_client_read(fd, queue, need, timeout_ms) != 0) {\n\t\toerrno = errno;\n\t\tdebug3_f(\"read body failed: %s\", strerror(errno));\n\t\tsshbuf_free(queue);\n\t\terrno = oerrno;\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_get_string_direct(queue, &ptr, &have)) != 0 ||\n\t    (r = sshbuf_put(m, ptr, have)) != 0)\n\t\tfatal_fr(r, \"dequeue\");\n\tsshbuf_free(queue);\n\treturn 0;\n}\n\nstatic int\nmux_client_read_packet(int fd, struct sshbuf *m)\n{\n\treturn mux_client_read_packet_timeout(fd, m, -1);\n}\n\nstatic int\nmux_client_hello_exchange(int fd, int timeout_ms)\n{\n\tstruct sshbuf *m;\n\tu_int type, ver;\n\tint r, ret = -1;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_MSG_HELLO)) != 0 ||\n\t    (r = sshbuf_put_u32(m, SSHMUX_VER)) != 0)\n\t\tfatal_fr(r, \"assemble hello\");\n\t \n\n\tif (mux_client_write_packet(fd, m) != 0) {\n\t\tdebug_f(\"write packet: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\n\tsshbuf_reset(m);\n\n\t \n\tif (mux_client_read_packet_timeout(fd, m, timeout_ms) != 0) {\n\t\tdebug_f(\"read packet failed\");\n\t\tgoto out;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\tif (type != MUX_MSG_HELLO) {\n\t\terror_f(\"expected HELLO (%u) got %u\", MUX_MSG_HELLO, type);\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u32(m, &ver)) != 0)\n\t\tfatal_fr(r, \"parse version\");\n\tif (ver != SSHMUX_VER) {\n\t\terror(\"Unsupported multiplexing protocol version %d \"\n\t\t    \"(expected %d)\", ver, SSHMUX_VER);\n\t\tgoto out;\n\t}\n\tdebug2_f(\"master version %u\", ver);\n\t \n\twhile (sshbuf_len(m) > 0) {\n\t\tchar *name = NULL;\n\n\t\tif ((r = sshbuf_get_cstring(m, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_skip_string(m)) != 0) {  \n\t\t\terror_fr(r, \"parse extension\");\n\t\t\tgoto out;\n\t\t}\n\t\tdebug2(\"Unrecognised master extension \\\"%s\\\"\", name);\n\t\tfree(name);\n\t}\n\t \n\tret = 0;\n out:\n\tsshbuf_free(m);\n\treturn ret;\n}\n\nstatic u_int\nmux_client_request_alive(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int pid, type, rid;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_C_ALIVE_CHECK)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t \n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\tif (type != MUX_S_ALIVE) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tfatal_f(\"master returned error: %s\", e);\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse remote ID\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\tif ((r = sshbuf_get_u32(m, &pid)) != 0)\n\t\tfatal_fr(r, \"parse PID\");\n\tsshbuf_free(m);\n\n\tdebug3_f(\"done pid = %u\", pid);\n\n\tmuxclient_request_id++;\n\n\treturn pid;\n}\n\nstatic void\nmux_client_request_terminate(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_C_TERMINATE)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal_fr(r, \"request\");\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t \n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\t \n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(m);\n\t\t\treturn;\n\t\t}\n\t\tfatal_f(\"read from master failed: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tfatal(\"Master refused termination request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tfatal_f(\"termination request failed: %s\", e);\n\tdefault:\n\t\tfatal_f(\"unexpected response from master 0x%08x\", type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}\n\nstatic int\nmux_client_forward(int fd, int cancel_flag, u_int ftype, struct Forward *fwd)\n{\n\tstruct sshbuf *m;\n\tchar *e, *fwd_desc;\n\tconst char *lhost, *chost;\n\tu_int type, rid;\n\tint r;\n\n\tfwd_desc = format_forward(ftype, fwd);\n\tdebug(\"Requesting %s %s\",\n\t    cancel_flag ? \"cancellation of\" : \"forwarding of\", fwd_desc);\n\tfree(fwd_desc);\n\n\ttype = cancel_flag ? MUX_C_CLOSE_FWD : MUX_C_OPEN_FWD;\n\tif (fwd->listen_path != NULL)\n\t\tlhost = fwd->listen_path;\n\telse if (fwd->listen_host == NULL)\n\t\tlhost = \"\";\n\telse if (*fwd->listen_host == '\\0')\n\t\tlhost = \"*\";\n\telse\n\t\tlhost = fwd->listen_host;\n\n\tif (fwd->connect_path != NULL)\n\t\tchost = fwd->connect_path;\n\telse if (fwd->connect_host == NULL)\n\t\tchost = \"\";\n\telse\n\t\tchost = fwd->connect_host;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_u32(m, ftype)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, lhost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->listen_port)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, chost)) != 0 ||\n\t    (r = sshbuf_put_u32(m, fwd->connect_port)) != 0)\n\t\tfatal_fr(r, \"request\");\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t \n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_REMOTE_PORT:\n\t\tif (cancel_flag)\n\t\t\tfatal_f(\"got MUX_S_REMOTE_PORT for cancel\");\n\t\tif ((r = sshbuf_get_u32(m, &fwd->allocated_port)) != 0)\n\t\t\tfatal_fr(r, \"parse port\");\n\t\tverbose(\"Allocated port %u for remote forward to %s:%d\",\n\t\t    fwd->allocated_port,\n\t\t    fwd->connect_host ? fwd->connect_host : \"\",\n\t\t    fwd->connect_port);\n\t\tif (muxclient_command == SSHMUX_COMMAND_FORWARD)\n\t\t\tfprintf(stdout, \"%i\\n\", fwd->allocated_port);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tsshbuf_free(m);\n\t\terror(\"Master refused forwarding request: %s\", e);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tsshbuf_free(m);\n\t\terror_f(\"forwarding request failed: %s\", e);\n\t\treturn -1;\n\tdefault:\n\t\tfatal_f(\"unexpected response from master 0x%08x\", type);\n\t}\n\tsshbuf_free(m);\n\n\tmuxclient_request_id++;\n\treturn 0;\n}\n\nstatic int\nmux_client_forwards(int fd, int cancel_flag)\n{\n\tint i, ret = 0;\n\n\tdebug3_f(\"%s forwardings: %d local, %d remote\",\n\t    cancel_flag ? \"cancel\" : \"request\",\n\t    options.num_local_forwards, options.num_remote_forwards);\n\n\t \n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag,\n\t\t    options.local_forwards[i].connect_port == 0 ?\n\t\t    MUX_FWD_DYNAMIC : MUX_FWD_LOCAL,\n\t\t    options.local_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tif (mux_client_forward(fd, cancel_flag, MUX_FWD_REMOTE,\n\t\t    options.remote_forwards + i) != 0)\n\t\t\tret = -1;\n\t}\n\treturn ret;\n}\n\nstatic int\nmux_client_request_session(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tconst char *term = NULL;\n\tu_int i, echar, rid, sid, esid, exitval, type, exitval_seen;\n\textern char **environ;\n\tint r, rawmode = 0;\n\n\tdebug3_f(\"entering\");\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror_f(\"master alive request failed\");\n\t\treturn -1;\n\t}\n\n\tssh_signal(SIGPIPE, SIG_IGN);\n\n\tif (options.stdin_null && stdfd_devnull(1, 0, 0) == -1)\n\t\tfatal_f(\"stdfd_devnull failed\");\n\n\tif ((term = lookup_env_in_list(\"TERM\", options.setenv,\n\t    options.num_setenv)) == NULL || *term == '\\0')\n\t\tterm = getenv(\"TERM\");\n\n\techar = 0xffffffff;\n\tif (options.escape_char != SSH_ESCAPECHAR_NONE)\n\t    echar = (u_int)options.escape_char;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_SESSION)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 ||  \n\t    (r = sshbuf_put_u32(m, tty_flag)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_x11)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.forward_agent)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.session_type == SESSION_TYPE_SUBSYSTEM)) != 0 ||\n\t    (r = sshbuf_put_u32(m, echar)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, term == NULL ? \"\" : term)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, command)) != 0)\n\t\tfatal_fr(r, \"request\");\n\n\t \n\tif (options.num_send_env > 0 && environ != NULL) {\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tif (!env_permitted(environ[i]))\n\t\t\t\tcontinue;\n\t\t\tif ((r = sshbuf_put_cstring(m, environ[i])) != 0)\n\t\t\t\tfatal_fr(r, \"request sendenv\");\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tif ((r = sshbuf_put_cstring(m, options.setenv[i])) != 0)\n\t\t\tfatal_fr(r, \"request setenv\");\n\t}\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\t \n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDERR_FILENO) == -1)\n\t\tfatal_f(\"send fds failed\");\n\n\tdebug3_f(\"session request sent\");\n\n\t \n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror_f(\"read from master failed: %s\", strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal_fr(r, \"parse session ID\");\n\t\tdebug_f(\"master session id: %u\", sid);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\terror(\"Master refused session request: %s\", e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\terror_f(\"session request failed: %s\", e);\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror_f(\"unexpected response from master 0x%08x\", type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\tplatform_pledge_mux();\n\n\tssh_signal(SIGHUP, control_client_sighandler);\n\tssh_signal(SIGINT, control_client_sighandler);\n\tssh_signal(SIGTERM, control_client_sighandler);\n\tssh_signal(SIGWINCH, control_client_sigrelay);\n\n\tif (options.fork_after_authentication)\n\t\tdaemon(1, 1);\n\telse {\n\t\trawmode = tty_flag;\n\t\tif (tty_flag) {\n\t\t\tenter_raw_mode(\n\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\t\t}\n\t}\n\n\t \n\tfor (exitval = 255, exitval_seen = 0;;) {\n\t\tsshbuf_reset(m);\n\t\tif (mux_client_read_packet(fd, m) != 0)\n\t\t\tbreak;\n\t\tif ((r = sshbuf_get_u32(m, &type)) != 0)\n\t\t\tfatal_fr(r, \"parse type\");\n\t\tswitch (type) {\n\t\tcase MUX_S_TTY_ALLOC_FAIL:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal_fr(r, \"parse session ID\");\n\t\t\tif (esid != sid)\n\t\t\t\tfatal_f(\"tty alloc fail on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\", sid, esid);\n\t\t\tleave_raw_mode(options.request_tty ==\n\t\t\t    REQUEST_TTY_FORCE);\n\t\t\trawmode = 0;\n\t\t\tcontinue;\n\t\tcase MUX_S_EXIT_MESSAGE:\n\t\t\tif ((r = sshbuf_get_u32(m, &esid)) != 0)\n\t\t\t\tfatal_fr(r, \"parse session ID\");\n\t\t\tif (esid != sid)\n\t\t\t\tfatal_f(\"exit on unknown session: \"\n\t\t\t\t    \"my id %u theirs %u\", sid, esid);\n\t\t\tif (exitval_seen)\n\t\t\t\tfatal_f(\"exitval sent twice\");\n\t\t\tif ((r = sshbuf_get_u32(m, &exitval)) != 0)\n\t\t\t\tfatal_fr(r, \"parse exitval\");\n\t\t\texitval_seen = 1;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse error message\");\n\t\t\tfatal_f(\"master returned error: %s\", e);\n\t\t}\n\t}\n\n\tclose(fd);\n\tif (rawmode)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (muxclient_terminate) {\n\t\tdebug2(\"Exiting on signal: %s\", strsignal(muxclient_terminate));\n\t\texitval = 255;\n\t} else if (!exitval_seen) {\n\t\tdebug2(\"Control master terminated unexpectedly\");\n\t\texitval = 255;\n\t} else\n\t\tdebug2(\"Received exit status from master %d\", exitval);\n\n\tif (tty_flag && options.log_level >= SYSLOG_LEVEL_INFO)\n\t\tfprintf(stderr, \"Shared connection to %s closed.\\r\\n\", host);\n\n\texit(exitval);\n}\n\nstatic int\nmux_client_proxy(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_C_PROXY)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal_fr(r, \"request\");\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t \n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tsshbuf_free(m);\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\tif (type != MUX_S_PROXY) {\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tfatal_f(\"master returned error: %s\", e);\n\t}\n\tsshbuf_free(m);\n\n\tdebug3_f(\"done\");\n\tmuxclient_request_id++;\n\treturn 0;\n}\n\nstatic int\nmux_client_request_stdio_fwd(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid, sid;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((muxserver_pid = mux_client_request_alive(fd)) == 0) {\n\t\terror_f(\"master alive request failed\");\n\t\treturn -1;\n\t}\n\n\tssh_signal(SIGPIPE, SIG_IGN);\n\n\tif (options.stdin_null && stdfd_devnull(1, 0, 0) == -1)\n\t\tfatal_f(\"stdfd_devnull failed\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_C_NEW_STDIO_FWD)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0 ||\n\t    (r = sshbuf_put_string(m, NULL, 0)) != 0 ||  \n\t    (r = sshbuf_put_cstring(m, options.stdio_forward_host)) != 0 ||\n\t    (r = sshbuf_put_u32(m, options.stdio_forward_port)) != 0)\n\t\tfatal_fr(r, \"request\");\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\t \n\tif (mm_send_fd(fd, STDIN_FILENO) == -1 ||\n\t    mm_send_fd(fd, STDOUT_FILENO) == -1)\n\t\tfatal_f(\"send fds failed\");\n\n\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\tplatform_pledge_mux();\n\n\tdebug3_f(\"stdio forward request sent\");\n\n\t \n\tsshbuf_reset(m);\n\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\terror_f(\"read from master failed: %s\", strerror(errno));\n\t\tsshbuf_free(m);\n\t\treturn -1;\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\tswitch (type) {\n\tcase MUX_S_SESSION_OPENED:\n\t\tif ((r = sshbuf_get_u32(m, &sid)) != 0)\n\t\t\tfatal_fr(r, \"parse session ID\");\n\t\tdebug_f(\"master session id: %u\", sid);\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tsshbuf_free(m);\n\t\tfatal(\"Master refused stdio forwarding request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tsshbuf_free(m);\n\t\tfatal(\"Stdio forwarding request failed: %s\", e);\n\tdefault:\n\t\tsshbuf_free(m);\n\t\terror_f(\"unexpected response from master 0x%08x\", type);\n\t\treturn -1;\n\t}\n\tmuxclient_request_id++;\n\n\tssh_signal(SIGHUP, control_client_sighandler);\n\tssh_signal(SIGINT, control_client_sighandler);\n\tssh_signal(SIGTERM, control_client_sighandler);\n\tssh_signal(SIGWINCH, control_client_sigrelay);\n\n\t \n\tsshbuf_reset(m);\n\tif (mux_client_read_packet(fd, m) != 0) {\n\t\tif (errno == EPIPE ||\n\t\t    (errno == EINTR && muxclient_terminate != 0))\n\t\t\treturn 0;\n\t\tfatal_f(\"mux_client_read_packet: %s\", strerror(errno));\n\t}\n\tfatal_f(\"master returned unexpected message %u\", type);\n}\n\nstatic void\nmux_client_request_stop_listening(int fd)\n{\n\tstruct sshbuf *m;\n\tchar *e;\n\tu_int type, rid;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_put_u32(m, MUX_C_STOP_LISTENING)) != 0 ||\n\t    (r = sshbuf_put_u32(m, muxclient_request_id)) != 0)\n\t\tfatal_fr(r, \"request\");\n\n\tif (mux_client_write_packet(fd, m) != 0)\n\t\tfatal_f(\"write packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n\n\t \n\tif (mux_client_read_packet(fd, m) != 0)\n\t\tfatal_f(\"read from master failed: %s\", strerror(errno));\n\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &rid)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rid != muxclient_request_id)\n\t\tfatal_f(\"out of sequence reply: my id %u theirs %u\",\n\t\t    muxclient_request_id, rid);\n\n\tswitch (type) {\n\tcase MUX_S_OK:\n\t\tbreak;\n\tcase MUX_S_PERMISSION_DENIED:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tfatal(\"Master refused stop listening request: %s\", e);\n\tcase MUX_S_FAILURE:\n\t\tif ((r = sshbuf_get_cstring(m, &e, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse error message\");\n\t\tfatal_f(\"stop listening request failed: %s\", e);\n\tdefault:\n\t\tfatal_f(\"unexpected response from master 0x%08x\", type);\n\t}\n\tsshbuf_free(m);\n\tmuxclient_request_id++;\n}\n\n \nint\nmuxclient(const char *path)\n{\n\tstruct sockaddr_un addr;\n\tint sock, timeout = options.connection_timeout, timeout_ms = -1;\n\tu_int pid;\n\n\tif (muxclient_command == 0) {\n\t\tif (options.stdio_forward_host != NULL)\n\t\t\tmuxclient_command = SSHMUX_COMMAND_STDIO_FWD;\n\t\telse\n\t\t\tmuxclient_command = SSHMUX_COMMAND_OPEN;\n\t}\n\n\tswitch (options.control_master) {\n\tcase SSHCTL_MASTER_AUTO:\n\tcase SSHCTL_MASTER_AUTO_ASK:\n\t\tdebug(\"auto-mux: Trying existing master at '%s'\", path);\n\t\t \n\tcase SSHCTL_MASTER_NO:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\n\tif (strlcpy(addr.sun_path, path,\n\t    sizeof(addr.sun_path)) >= sizeof(addr.sun_path))\n\t\tfatal(\"ControlPath too long ('%s' >= %u bytes)\", path,\n\t\t    (unsigned int)sizeof(addr.sun_path));\n\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tfatal_f(\"socket(): %s\", strerror(errno));\n\n\tif (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n\t\tswitch (muxclient_command) {\n\t\tcase SSHMUX_COMMAND_OPEN:\n\t\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (errno == ECONNREFUSED &&\n\t\t    options.control_master != SSHCTL_MASTER_NO) {\n\t\t\tdebug(\"Stale control socket %.100s, unlinking\", path);\n\t\t\tunlink(path);\n\t\t} else if (errno == ENOENT) {\n\t\t\tdebug(\"Control socket \\\"%.100s\\\" does not exist\", path);\n\t\t} else {\n\t\t\terror(\"Control socket connect(%.100s): %s\", path,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\tset_nonblock(sock);\n\n\t \n\tif (timeout > 0 && timeout < INT_MAX / 1000)\n\t\ttimeout_ms = timeout * 1000;\n\n\tif (mux_client_hello_exchange(sock, timeout_ms) != 0) {\n\t\terror_f(\"master hello exchange failed\");\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tswitch (muxclient_command) {\n\tcase SSHMUX_COMMAND_ALIVE_CHECK:\n\t\tif ((pid = mux_client_request_alive(sock)) == 0)\n\t\t\tfatal_f(\"master alive check failed\");\n\t\tfprintf(stderr, \"Master running (pid=%u)\\r\\n\", pid);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_TERMINATE:\n\t\tmux_client_request_terminate(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Exit request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_FORWARD:\n\t\tif (mux_client_forwards(sock, 0) != 0)\n\t\t\tfatal_f(\"master forward request failed\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_OPEN:\n\t\tif (mux_client_forwards(sock, 0) != 0) {\n\t\t\terror_f(\"master forward request failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tmux_client_request_session(sock);\n\t\treturn -1;\n\tcase SSHMUX_COMMAND_STDIO_FWD:\n\t\tmux_client_request_stdio_fwd(sock);\n\t\texit(0);\n\tcase SSHMUX_COMMAND_STOP:\n\t\tmux_client_request_stop_listening(sock);\n\t\tif (options.log_level != SYSLOG_LEVEL_QUIET)\n\t\t\tfprintf(stderr, \"Stop listening request sent.\\r\\n\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_CANCEL_FWD:\n\t\tif (mux_client_forwards(sock, 1) != 0)\n\t\t\terror_f(\"master cancel forward request failed\");\n\t\texit(0);\n\tcase SSHMUX_COMMAND_PROXY:\n\t\tmux_client_proxy(sock);\n\t\treturn (sock);\n\tdefault:\n\t\tfatal(\"unrecognised muxclient_command %d\", muxclient_command);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}