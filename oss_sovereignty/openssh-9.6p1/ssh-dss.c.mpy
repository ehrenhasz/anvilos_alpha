{
  "module_name": "ssh-dss.c",
  "hash_id": "b699cb4970e9884212697864d4f952ef9a77fc0d586e6c8eff9f6f48d0ad0e8b",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-dss.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef WITH_OPENSSL\n\n#include <sys/types.h>\n\n#include <openssl/bn.h>\n#include <openssl/dsa.h>\n#include <openssl/evp.h>\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#define SSHKEY_INTERNAL\n#include \"sshkey.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#define INTBLOB_LEN\t20\n#define SIGBLOB_LEN\t(2*INTBLOB_LEN)\n\nstatic u_int\nssh_dss_size(const struct sshkey *key)\n{\n\tconst BIGNUM *dsa_p;\n\n\tif (key->dsa == NULL)\n\t\treturn 0;\n\tDSA_get0_pqg(key->dsa, &dsa_p, NULL, NULL);\n\treturn BN_num_bits(dsa_p);\n}\n\nstatic int\nssh_dss_alloc(struct sshkey *k)\n{\n\tif ((k->dsa = DSA_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}\n\nstatic void\nssh_dss_cleanup(struct sshkey *k)\n{\n\tDSA_free(k->dsa);\n\tk->dsa = NULL;\n}\n\nstatic int\nssh_dss_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tconst BIGNUM *dsa_p_a, *dsa_q_a, *dsa_g_a, *dsa_pub_key_a;\n\tconst BIGNUM *dsa_p_b, *dsa_q_b, *dsa_g_b, *dsa_pub_key_b;\n\n\tif (a->dsa == NULL || b->dsa == NULL)\n\t\treturn 0;\n\tDSA_get0_pqg(a->dsa, &dsa_p_a, &dsa_q_a, &dsa_g_a);\n\tDSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);\n\tDSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);\n\tDSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);\n\tif (dsa_p_a == NULL || dsa_p_b == NULL ||\n\t    dsa_q_a == NULL || dsa_q_b == NULL ||\n\t    dsa_g_a == NULL || dsa_g_b == NULL ||\n\t    dsa_pub_key_a == NULL || dsa_pub_key_b == NULL)\n\t\treturn 0;\n\tif (BN_cmp(dsa_p_a, dsa_p_b) != 0)\n\t\treturn 0;\n\tif (BN_cmp(dsa_q_a, dsa_q_b) != 0)\n\t\treturn 0;\n\tif (BN_cmp(dsa_g_a, dsa_g_b) != 0)\n\t\treturn 0;\n\tif (BN_cmp(dsa_pub_key_a, dsa_pub_key_b) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nssh_dss_serialize_public(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\n\tif (key->dsa == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tDSA_get0_pqg(key->dsa, &dsa_p, &dsa_q, &dsa_g);\n\tDSA_get0_key(key->dsa, &dsa_pub_key, NULL);\n\tif (dsa_p == NULL || dsa_q == NULL ||\n\t    dsa_g == NULL || dsa_pub_key == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((r = sshbuf_put_bignum2(b, dsa_p)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, dsa_q)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, dsa_g)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, dsa_pub_key)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_dss_serialize_private(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\tconst BIGNUM *dsa_priv_key;\n\n\tDSA_get0_key(key->dsa, NULL, &dsa_priv_key);\n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = ssh_dss_serialize_public(key, b, opts)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_bignum2(b, dsa_priv_key)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_dss_generate(struct sshkey *k, int bits)\n{\n\tDSA *private;\n\n\tif (bits != 1024)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = DSA_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (!DSA_generate_parameters_ex(private, bits, NULL, 0, NULL,\n\t    NULL, NULL) || !DSA_generate_key(private)) {\n\t\tDSA_free(private);\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\tk->dsa = private;\n\treturn 0;\n}\n\nstatic int\nssh_dss_copy_public(const struct sshkey *from, struct sshkey *to)\n{\n\tconst BIGNUM *dsa_p, *dsa_q, *dsa_g, *dsa_pub_key;\n\tBIGNUM *dsa_p_dup = NULL, *dsa_q_dup = NULL, *dsa_g_dup = NULL;\n\tBIGNUM *dsa_pub_key_dup = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tDSA_get0_pqg(from->dsa, &dsa_p, &dsa_q, &dsa_g);\n\tDSA_get0_key(from->dsa, &dsa_pub_key, NULL);\n\tif ((dsa_p_dup = BN_dup(dsa_p)) == NULL ||\n\t    (dsa_q_dup = BN_dup(dsa_q)) == NULL ||\n\t    (dsa_g_dup = BN_dup(dsa_g)) == NULL ||\n\t    (dsa_pub_key_dup = BN_dup(dsa_pub_key)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!DSA_set0_pqg(to->dsa, dsa_p_dup, dsa_q_dup, dsa_g_dup)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tdsa_p_dup = dsa_q_dup = dsa_g_dup = NULL;  \n\tif (!DSA_set0_key(to->dsa, dsa_pub_key_dup, NULL)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tdsa_pub_key_dup = NULL;  \n\t \n\tr = 0;\n out:\n\tBN_clear_free(dsa_p_dup);\n\tBN_clear_free(dsa_q_dup);\n\tBN_clear_free(dsa_g_dup);\n\tBN_clear_free(dsa_pub_key_dup);\n\treturn r;\n}\n\nstatic int\nssh_dss_deserialize_public(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL, *dsa_pub_key = NULL;\n\n\tif (sshbuf_get_bignum2(b, &dsa_p) != 0 ||\n\t    sshbuf_get_bignum2(b, &dsa_q) != 0 ||\n\t    sshbuf_get_bignum2(b, &dsa_g) != 0 ||\n\t    sshbuf_get_bignum2(b, &dsa_pub_key) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tdsa_p = dsa_q = dsa_g = NULL;  \n\tif (!DSA_set0_key(key->dsa, dsa_pub_key, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tdsa_pub_key = NULL;  \n#ifdef DEBUG_PK\n\tDSA_print_fp(stderr, key->dsa, 8);\n#endif\n\t \n\tret = 0;\n out:\n\tBN_clear_free(dsa_p);\n\tBN_clear_free(dsa_q);\n\tBN_clear_free(dsa_g);\n\tBN_clear_free(dsa_pub_key);\n\treturn ret;\n}\n\nstatic int\nssh_dss_deserialize_private(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\tBIGNUM *dsa_priv_key = NULL;\n\n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = ssh_dss_deserialize_public(ktype, b, key)) != 0)\n\t\t\treturn r;\n\t}\n\n\tif ((r = sshbuf_get_bignum2(b, &dsa_priv_key)) != 0)\n\t\treturn r;\n\tif (!DSA_set0_key(key->dsa, NULL, dsa_priv_key)) {\n\t\tBN_clear_free(dsa_priv_key);\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t}\n\treturn 0;\n}\n\nstatic int\nssh_dss_sign(struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\tDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];\n\tsize_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\tstruct sshbuf *b = NULL;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL || key->dsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_DSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (dlen == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = DSA_do_sign(digest, dlen, key->dsa)) == NULL) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tDSA_SIG_get0(sig, &sig_r, &sig_s);\n\trlen = BN_num_bytes(sig_r);\n\tslen = BN_num_bytes(sig_s);\n\tif (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\texplicit_bzero(sigblob, SIGBLOB_LEN);\n\tBN_bn2bin(sig_r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);\n\tBN_bn2bin(sig_s, sigblob + SIGBLOB_LEN - slen);\n\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_cstring(b, \"ssh-dss\")) != 0 ||\n\t    (ret = sshbuf_put_string(b, sigblob, SIGBLOB_LEN)) != 0)\n\t\tgoto out;\n\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tDSA_SIG_free(sig);\n\tsshbuf_free(b);\n\treturn ret;\n}\n\nstatic int\nssh_dss_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\tDSA_SIG *dsig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;\n\tsize_t len, hlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\n\tif (key == NULL || key->dsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_DSA ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (hlen == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0 ||\n\t    sshbuf_get_string(b, &sigblob, &len) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(\"ssh-dss\", ktype) != 0) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\tif (len != SIGBLOB_LEN) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((dsig = DSA_SIG_new()) == NULL ||\n\t    (sig_r = BN_new()) == NULL ||\n\t    (sig_s = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((BN_bin2bn(sigblob, INTBLOB_LEN, sig_r) == NULL) ||\n\t    (BN_bin2bn(sigblob + INTBLOB_LEN, INTBLOB_LEN, sig_s) == NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!DSA_SIG_set0(dsig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL;  \n\n\t \n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA1, data, dlen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tswitch (DSA_do_verify(digest, hlen, dsig, key->dsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tDSA_SIG_free(dsig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tsshbuf_free(b);\n\tfree(ktype);\n\tif (sigblob != NULL)\n\t\tfreezero(sigblob, len);\n\treturn ret;\n}\n\nstatic const struct sshkey_impl_funcs sshkey_dss_funcs = {\n\t \t\tssh_dss_size,\n\t \t\tssh_dss_alloc,\n\t \tssh_dss_cleanup,\n\t \t\tssh_dss_equal,\n\t  ssh_dss_serialize_public,\n\t  ssh_dss_deserialize_public,\n\t  ssh_dss_serialize_private,\n\t  ssh_dss_deserialize_private,\n\t \tssh_dss_generate,\n\t \tssh_dss_copy_public,\n\t \t\tssh_dss_sign,\n\t \t\tssh_dss_verify,\n};\n\nconst struct sshkey_impl sshkey_dss_impl = {\n\t \t\t\"ssh-dss\",\n\t \t\"DSA\",\n\t \t\tNULL,\n\t \t\tKEY_DSA,\n\t \t\t0,\n\t \t\t0,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_dss_funcs,\n};\n\nconst struct sshkey_impl sshkey_dsa_cert_impl = {\n\t \t\t\"ssh-dss-cert-v01@openssh.com\",\n\t \t\"DSA-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_DSA_CERT,\n\t \t\t0,\n\t \t\t1,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_dss_funcs,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}