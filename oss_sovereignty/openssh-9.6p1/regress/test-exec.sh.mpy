{
  "module_name": "test-exec.sh",
  "hash_id": "fa5b5f0da42c9d616a4d909a0dc79bc7a978e3fea869d3cee3c2688ae5d37bc4",
  "original_prompt": "Ingested from openssh-9.6p1/regress/test-exec.sh",
  "human_readable_source": "#\t$OpenBSD: test-exec.sh,v 1.105 2023/10/31 04:15:40 dtucker Exp $\n#\tPlaced in the Public Domain.\n\n#SUDO=sudo\n\nif [ ! -z \"$TEST_SSH_ELAPSED_TIMES\" ]; then\n\tSTARTTIME=`date '+%s'`\nfi\n\nif [ ! -z \"$TEST_SSH_PORT\" ]; then\n\tPORT=\"$TEST_SSH_PORT\"\nelse\n\tPORT=4242\nfi\n\nOBJ=$1\nif [ \"x$OBJ\" = \"x\" ]; then\n\techo '$OBJ not defined'\n\texit 2\nfi\nif [ ! -d $OBJ ]; then\n\techo \"not a directory: $OBJ\"\n\texit 2\nfi\nSCRIPT=$2\nif [ \"x$SCRIPT\" = \"x\" ]; then\n\techo '$SCRIPT not defined'\n\texit 2\nfi\nif [ ! -f $SCRIPT ]; then\n\techo \"not a file: $SCRIPT\"\n\texit 2\nfi\nif $TEST_SHELL -n $SCRIPT; then\n\ttrue\nelse\n\techo \"syntax error in $SCRIPT\"\n\texit 2\nfi\nunset SSH_AUTH_SOCK\n\n# Portable-specific settings.\n\nif [ -x /usr/ucb/whoami ]; then\n\tUSER=`/usr/ucb/whoami`\nelif whoami >/dev/null 2>&1; then\n\tUSER=`whoami`\nelif logname >/dev/null 2>&1; then\n\tUSER=`logname`\nelse\n\tUSER=`id -un`\nfi\nif test -z \"$LOGNAME\"; then\n\tLOGNAME=\"${USER}\"\n\texport LOGNAME\nfi\n\n# Unbreak GNU head(1)\n_POSIX2_VERSION=199209\nexport _POSIX2_VERSION\n\ncase `uname -s 2>/dev/null` in\nOSF1*)\n\tBIN_SH=xpg4\n\texport BIN_SH\n\t;;\nCYGWIN*)\n\tos=cygwin\n\t;;\nesac\n\n# If configure tells us to use a different egrep, create a wrapper function\n# to call it.  This means we don't need to change all the tests that depend\n# on a good implementation.\nif test \"x${EGREP}\" != \"x\"; then\n\tegrep ()\n{\n\t ${EGREP} \"$@\"\n}\nfi\n\nSRC=`dirname ${SCRIPT}`\n\n# defaults\nSSH=ssh\nSSHD=sshd\nSSHAGENT=ssh-agent\nSSHADD=ssh-add\nSSHKEYGEN=ssh-keygen\nSSHKEYSCAN=ssh-keyscan\nSFTP=sftp\nSFTPSERVER=/usr/libexec/openssh/sftp-server\nSCP=scp\n\n# Set by make_tmpdir() on demand (below).\nSSH_REGRESS_TMP=\n\n# Interop testing\nPLINK=/usr/local/bin/plink\nPUTTYGEN=/usr/local/bin/puttygen\nCONCH=/usr/local/bin/conch\nDROPBEAR=/usr/local/bin/dropbear\nDBCLIENT=/usr/local/bin/dbclient\nDROPBEARKEY=/usr/local/bin/dropbearkey\nDROPBEARCONVERT=/usr/local/bin/dropbearconvert\n\n# Tools used by multiple tests\nNC=$OBJ/netcat\n# Always use the one configure tells us to, even if that's empty.\n#OPENSSL_BIN=\"${OPENSSL_BIN:-openssl}\"\n\nif [ \"x$TEST_SSH_SSH\" != \"x\" ]; then\n\tSSH=\"${TEST_SSH_SSH}\"\nfi\nif [ \"x$TEST_SSH_SSHD\" != \"x\" ]; then\n\tSSHD=\"${TEST_SSH_SSHD}\"\nfi\nif [ \"x$TEST_SSH_SSHAGENT\" != \"x\" ]; then\n\tSSHAGENT=\"${TEST_SSH_SSHAGENT}\"\nfi\nif [ \"x$TEST_SSH_SSHADD\" != \"x\" ]; then\n\tSSHADD=\"${TEST_SSH_SSHADD}\"\nfi\nif [ \"x$TEST_SSH_SSHKEYGEN\" != \"x\" ]; then\n\tSSHKEYGEN=\"${TEST_SSH_SSHKEYGEN}\"\nfi\nif [ \"x$TEST_SSH_SSHKEYSCAN\" != \"x\" ]; then\n\tSSHKEYSCAN=\"${TEST_SSH_SSHKEYSCAN}\"\nfi\nif [ \"x$TEST_SSH_SFTP\" != \"x\" ]; then\n\tSFTP=\"${TEST_SSH_SFTP}\"\nfi\nif [ \"x$TEST_SSH_SFTPSERVER\" != \"x\" ]; then\n\tSFTPSERVER=\"${TEST_SSH_SFTPSERVER}\"\nfi\nif [ \"x$TEST_SSH_SCP\" != \"x\" ]; then\n\tSCP=\"${TEST_SSH_SCP}\"\nfi\nif [ \"x$TEST_SSH_PLINK\" != \"x\" ]; then\n\tPLINK=\"${TEST_SSH_PLINK}\"\nfi\nif [ \"x$TEST_SSH_PUTTYGEN\" != \"x\" ]; then\n\tPUTTYGEN=\"${TEST_SSH_PUTTYGEN}\"\nfi\nif [ \"x$TEST_SSH_CONCH\" != \"x\" ]; then\n\tCONCH=\"${TEST_SSH_CONCH}\"\nfi\nif [ \"x$TEST_SSH_DROPBEAR\" != \"x\" ]; then\n\tDROPBEAR=\"${TEST_SSH_DROPBEAR}\"\nfi\nif [ \"x$TEST_SSH_DBCLIENT\" != \"x\" ]; then\n\tDBCLIENT=\"${TEST_SSH_DBCLIENT}\"\nfi\nif [ \"x$TEST_SSH_DROPBEARKEY\" != \"x\" ]; then\n\tDROPBEARKEY=\"${TEST_SSH_DROPBEARKEY}\"\nfi\nif [ \"x$TEST_SSH_DROPBEARCONVERT\" != \"x\" ]; then\n\tDROPBEARCONVERT=\"${TEST_SSH_DROPBEARCONVERT}\"\nfi\nif [ \"x$TEST_SSH_PKCS11_HELPER\" != \"x\" ]; then\n\tSSH_PKCS11_HELPER=\"${TEST_SSH_PKCS11_HELPER}\"\nfi\nif [ \"x$TEST_SSH_SK_HELPER\" != \"x\" ]; then\n\tSSH_SK_HELPER=\"${TEST_SSH_SK_HELPER}\"\nfi\nif [ \"x$TEST_SSH_OPENSSL\" != \"x\" ]; then\n\tOPENSSL_BIN=\"${TEST_SSH_OPENSSL}\"\nfi\n\n# Path to sshd must be absolute for rexec\ncase \"$SSHD\" in\n/*) ;;\n*) SSHD=`which $SSHD` ;;\nesac\n\ncase \"$SSHAGENT\" in\n/*) ;;\n*) SSHAGENT=`which $SSHAGENT` ;;\nesac\n\n# Record the actual binaries used.\nSSH_BIN=${SSH}\nSSHD_BIN=${SSHD}\nSSHAGENT_BIN=${SSHAGENT}\nSSHADD_BIN=${SSHADD}\nSSHKEYGEN_BIN=${SSHKEYGEN}\nSSHKEYSCAN_BIN=${SSHKEYSCAN}\nSFTP_BIN=${SFTP}\nSFTPSERVER_BIN=${SFTPSERVER}\nSCP_BIN=${SCP}\n\nif [ \"x$USE_VALGRIND\" != \"x\" ]; then\n\trm -rf $OBJ/valgrind-out $OBJ/valgrind-vgdb\n\tmkdir -p $OBJ/valgrind-out $OBJ/valgrind-vgdb\n\t# When using sudo ensure low-priv tests can write pipes and logs.\n\tif [ \"x$SUDO\" != \"x\" ]; then\n\t\tchmod 777 $OBJ/valgrind-out $OBJ/valgrind-vgdb\n\tfi\n\tVG_TEST=`basename $SCRIPT .sh`\n\n\t# Some tests are difficult to fix.\n\tcase \"$VG_TEST\" in\n\treexec)\n\t\tVG_SKIP=1 ;;\n\tsftp-chroot)\n\t\tif [ \"x${SUDO}\" != \"x\" ]; then\n\t\t\tVG_SKIP=1\n\t\tfi ;;\n\tesac\n\n\tif [ x\"$VG_SKIP\" = \"x\" ]; then\n\t\tVG_LEAK=\"--leak-check=no\"\n\t\tif [ x\"$VALGRIND_CHECK_LEAKS\" != \"x\" ]; then\n\t\t\tVG_LEAK=\"--leak-check=full\"\n\t\tfi\n\t\tVG_IGNORE=\"/bin/*,/sbin/*,/usr/*,/var/*\"\n\t\tVG_LOG=\"$OBJ/valgrind-out/${VG_TEST}.\"\n\t\tVG_OPTS=\"--track-origins=yes $VG_LEAK\"\n\t\tVG_OPTS=\"$VG_OPTS --trace-children=yes\"\n\t\tVG_OPTS=\"$VG_OPTS --trace-children-skip=${VG_IGNORE}\"\n\t\tVG_OPTS=\"$VG_OPTS --vgdb-prefix=$OBJ/valgrind-vgdb/\"\n\t\tVG_PATH=\"valgrind\"\n\t\tif [ \"x$VALGRIND_PATH\" != \"x\" ]; then\n\t\t\tVG_PATH=\"$VALGRIND_PATH\"\n\t\tfi\n\t\tVG=\"$VG_PATH $VG_OPTS\"\n\t\tSSH=\"$VG --log-file=${VG_LOG}ssh.%p $SSH\"\n\t\tSSHD=\"$VG --log-file=${VG_LOG}sshd.%p $SSHD\"\n\t\tSSHAGENT=\"$VG --log-file=${VG_LOG}ssh-agent.%p $SSHAGENT\"\n\t\tSSHADD=\"$VG --log-file=${VG_LOG}ssh-add.%p $SSHADD\"\n\t\tSSHKEYGEN=\"$VG --log-file=${VG_LOG}ssh-keygen.%p $SSHKEYGEN\"\n\t\tSSHKEYSCAN=\"$VG --log-file=${VG_LOG}ssh-keyscan.%p $SSHKEYSCAN\"\n\t\tSFTP=\"$VG --log-file=${VG_LOG}sftp.%p ${SFTP}\"\n\t\tSCP=\"$VG --log-file=${VG_LOG}scp.%p $SCP\"\n\t\tcat > $OBJ/valgrind-sftp-server.sh << EOF\n#!/bin/sh\nexec $VG --log-file=${VG_LOG}sftp-server.%p $SFTPSERVER \"\\$@\"\nEOF\n\t\tchmod a+rx $OBJ/valgrind-sftp-server.sh\n\t\tSFTPSERVER=\"$OBJ/valgrind-sftp-server.sh\"\n\tfi\nfi\n\n# Logfiles.\n# SSH_LOGFILE should be the debug output of ssh(1) only\n# SSHD_LOGFILE should be the debug output of sshd(8) only\n# REGRESS_LOGFILE is the log of progress of the regress test itself.\n# TEST_SSH_LOGDIR will contain datestamped logs of all binaries run in\n# chronological order.\nif [ \"x$TEST_SSH_LOGDIR\" = \"x\" ]; then\n\tTEST_SSH_LOGDIR=$OBJ/log\n\tmkdir -p $TEST_SSH_LOGDIR\nfi\nif [ \"x$TEST_SSH_LOGFILE\" = \"x\" ]; then\n\tTEST_SSH_LOGFILE=$OBJ/ssh.log\nfi\nif [ \"x$TEST_SSHD_LOGFILE\" = \"x\" ]; then\n\tTEST_SSHD_LOGFILE=$OBJ/sshd.log\nfi\nif [ \"x$TEST_REGRESS_LOGFILE\" = \"x\" ]; then\n\tTEST_REGRESS_LOGFILE=$OBJ/regress.log\nfi\n\n# If set, keep track of successful tests and skip them them if we've\n# previously completed that test.\nif [ \"x$TEST_REGRESS_CACHE_DIR\" != \"x\" ]; then\n\tif [ ! -d \"$TEST_REGRESS_CACHE_DIR\" ]; then\n\t\tmkdir -p \"$TEST_REGRESS_CACHE_DIR\"\n\tfi\n\tTEST=\"`basename $SCRIPT .sh`\"\n\tCACHE=\"${TEST_REGRESS_CACHE_DIR}/${TEST}.cache\"\n\tfor i in ${SSH} ${SSHD} ${SSHAGENT} ${SSHADD} ${SSHKEYGEN} ${SCP} \\\n\t    ${SFTP} ${SFTPSERVER} ${SSHKEYSCAN}; do\n\t\tcase $i in\n\t\t/*)\tbin=\"$i\" ;;\n\t\t*)\tbin=\"`which $i`\" ;;\n\t\tesac\n\t\tif [ \"$bin\" -nt \"$CACHE\" ]; then\n\t\t\trm -f \"$CACHE\"\n\t\tfi\n\tdone\n\tif [ -f \"$CACHE\" ]; then\n\t\techo ok cached $CACHE\n\t\texit 0\n\tfi\nfi\n\n# truncate logfiles\n>$TEST_REGRESS_LOGFILE\n\n# Create ssh and sshd wrappers with logging.  These create a datestamped\n# unique file for every invocation so that we can retain all logs from a\n# given test no matter how many times it's invoked.  It also leaves a\n# symlink with the original name for tests (and people) who look for that.\n\n# For ssh, e can't just specify \"SSH=ssh -E...\" because sftp and scp don't\n# handle spaces in arguments.  scp and sftp like to use -q so we remove those\n# to preserve our debug logging.  In the rare instance where -q is desirable\n# -qq is equivalent and is not removed.\nSSHLOGWRAP=$OBJ/ssh-log-wrapper.sh\ncat >$SSHLOGWRAP <<EOD\n#!/bin/sh\ntimestamp=\"\\`$OBJ/timestamp\\`\"\nlogfile=\"${TEST_SSH_LOGDIR}/\\${timestamp}.ssh.\\$\\$.log\"\necho \"Executing: ${SSH} \\$@\" log \\${logfile} >>$TEST_REGRESS_LOGFILE\necho \"Executing: ${SSH} \\$@\" >>\\${logfile}\nfor i in \"\\$@\";do shift;case \"\\$i\" in -q):;; *) set -- \"\\$@\" \"\\$i\";;esac;done\nrm -f $TEST_SSH_LOGFILE\nln -f -s \\${logfile} $TEST_SSH_LOGFILE\nexec ${SSH} -E\\${logfile} \"\\$@\"\nEOD\n\nchmod a+rx $OBJ/ssh-log-wrapper.sh\nREAL_SSH=\"$SSH\"\nREAL_SSHD=\"$SSHD\"\nSSH=\"$SSHLOGWRAP\"\n\nSSHDLOGWRAP=$OBJ/sshd-log-wrapper.sh\ncat >$SSHDLOGWRAP <<EOD\n#!/bin/sh\ntimestamp=\"\\`$OBJ/timestamp\\`\"\nlogfile=\"${TEST_SSH_LOGDIR}/\\${timestamp}.sshd.\\$\\$.log\"\nrm -f $TEST_SSHD_LOGFILE\ntouch \\$logfile\ntest -z \"$SUDO\" || chown $USER \\$logfile\nln -f -s \\${logfile} $TEST_SSHD_LOGFILE\necho \"Executing: ${SSHD} \\$@\" log \\${logfile} >>$TEST_REGRESS_LOGFILE\necho \"Executing: ${SSHD} \\$@\" >>\\${logfile}\nexec ${SSHD} -E\\${logfile} \"\\$@\"\nEOD\nchmod a+rx $OBJ/sshd-log-wrapper.sh\n\nssh_logfile ()\n{\n\ttool=\"$1\"\n\ttimestamp=\"`$OBJ/timestamp`\"\n\tlogfile=\"${TEST_SSH_LOGDIR}/${timestamp}.$tool.$$.log\"\n\techo \"Logging $tool to log \\${logfile}\" >>$TEST_REGRESS_LOGFILE\n\techo $logfile\n}\n\n# Some test data.  We make a copy because some tests will overwrite it.\n# The tests may assume that $DATA exists and is writable and $COPY does\n# not exist.  Tests requiring larger data files can call increase_datafile_size\n# [kbytes] to ensure the file is at least that large.\nDATANAME=data\nDATA=$OBJ/${DATANAME}\ncat ${SSHAGENT_BIN} >${DATA}\nchmod u+w ${DATA}\nCOPY=$OBJ/copy\nrm -f ${COPY}\n\nincrease_datafile_size()\n{\n\twhile [ `du -k ${DATA} | cut -f1` -lt $1 ]; do\n\t\tcat ${SSHAGENT_BIN} >>${DATA}\n\tdone\n}\n\n# these should be used in tests\nexport SSH SSHD SSHAGENT SSHADD SSHKEYGEN SSHKEYSCAN SFTP SFTPSERVER SCP\nexport SSH_PKCS11_HELPER SSH_SK_HELPER\n#echo $SSH $SSHD $SSHAGENT $SSHADD $SSHKEYGEN $SSHKEYSCAN $SFTP $SFTPSERVER $SCP\n\n# Portable specific functions\nwhich()\n{\n\tsaved_IFS=\"$IFS\"\n\tIFS=\":\"\n\tfor i in $PATH\n\tdo\n\t\tif [ -x $i/$1 ]; then\n\t\t\tIFS=\"$saved_IFS\"\n\t\t\techo \"$i/$1\"\n\t\t\treturn 0\n\t\tfi\n\tdone\n\tIFS=\"$saved_IFS\"\n\techo \"$i/$1\"\n\treturn 1\n}\n\nhave_prog()\n{\n\twhich \"$1\" >/dev/null 2>&1\n\treturn $?\n}\n\njot() {\n\tawk \"BEGIN { for (i = $2; i < $2 + $1; i++) { printf \\\"%d\\n\\\", i } exit }\"\n}\nif [ ! -x \"`which rev`\" ]; then\nrev()\n{\n\tawk '{for (i=length; i>0; i--) printf \"%s\", substr($0, i, 1); print \"\"}'\n}\nfi\n\n# Check whether preprocessor symbols are defined in config.h.\nconfig_defined ()\n{\n\tstr=$1\n\twhile test \"x$2\" != \"x\" ; do\n\t\tstr=\"$str|$2\"\n\t\tshift\n\tdone\n\tegrep \"^#define.*($str)\" ${BUILDDIR}/config.h >/dev/null 2>&1\n}\n\nmd5 () {\n\tif have_prog md5sum; then\n\t\tmd5sum\n\telif have_prog openssl; then\n\t\topenssl md5\n\telif have_prog cksum; then\n\t\tcksum\n\telif have_prog sum; then\n\t\tsum\n\telif [ -x ${OPENSSL_BIN} ]; then\n\t\t${OPENSSL_BIN} md5\n\telse\n\t\twc -c\n\tfi\n}\n\n# Some platforms don't have hostname at all, but on others uname -n doesn't\n# provide the fully qualified name we need, so in the former case we create\n# our own hostname function.\nif ! have_prog hostname; then\n\thostname() {\n\t\tuname -n\n\t}\nfi\n\nmake_tmpdir ()\n{\n\tSSH_REGRESS_TMP=\"$($OBJ/mkdtemp openssh-XXXXXXXX)\" || \\\n\t    fatal \"failed to create temporary directory\"\n}\n# End of portable specific functions\n\nstop_sshd ()\n{\n\tif [ -f $PIDFILE ]; then\n\t\tpid=`$SUDO cat $PIDFILE`\n\t\tif [ \"X$pid\" = \"X\" ]; then\n\t\t\techo no sshd running\n\t\telse\n\t\t\tif [ $pid -lt 2 ]; then\n\t\t\t\techo bad pid for sshd: $pid\n\t\t\telse\n\t\t\t\t$SUDO kill $pid\n\t\t\t\ttrace \"wait for sshd to exit\"\n\t\t\t\ti=0;\n\t\t\t\twhile [ -f $PIDFILE -a $i -lt 5 ]; do\n\t\t\t\t\ti=`expr $i + 1`\n\t\t\t\t\tsleep $i\n\t\t\t\tdone\n\t\t\t\tif test -f $PIDFILE; then\n\t\t\t\t\tif $SUDO kill -0 $pid; then\n\t\t\t\t\t\techo \"sshd didn't exit \" \\\n\t\t\t\t\t\t    \"port $PORT pid $pid\"\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"sshd died without cleanup\"\n\t\t\t\t\tfi\n\t\t\t\t\texit 1\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tfi\n}\n\n# helper\ncleanup ()\n{\n\tif [ \"x$SSH_PID\" != \"x\" ]; then\n\t\tif [ $SSH_PID -lt 2 ]; then\n\t\t\techo bad pid for ssh: $SSH_PID\n\t\telse\n\t\t\tkill $SSH_PID\n\t\tfi\n\tfi\n\tif [ \"x$SSH_REGRESS_TMP\" != \"x\" ]; then\n\t\trm -rf \"$SSH_REGRESS_TMP\"\n\tfi\n\tstop_sshd\n\tif [ ! -z \"$TEST_SSH_ELAPSED_TIMES\" ]; then\n\t\tnow=`date '+%s'`\n\t\telapsed=$(($now - $STARTTIME))\n\t\techo elapsed $elapsed `basename $SCRIPT .sh`\n\tfi\n}\n\nstart_debug_log ()\n{\n\techo \"trace: $@\" >>$TEST_REGRESS_LOGFILE\n\tif [ -d \"$TEST_SSH_LOGDIR\" ]; then\n\t\trm -f $TEST_SSH_LOGDIR/*\n\tfi\n}\n\nsave_debug_log ()\n{\n\ttestname=`echo $tid | tr ' ' _`\n\ttarname=\"$OBJ/failed-$testname-logs.tar\"\n\n\tfor logfile in $TEST_SSH_LOGDIR $TEST_REGRESS_LOGFILE \\\n\t    $TEST_SSH_LOGFILE $TEST_SSHD_LOGFILE; do\n\t\tif [ ! -z \"$SUDO\" ] && [ -f \"$logfile\" ]; then\n\t\t\t$SUDO chown -R $USER $logfile\n\t\tfi\n\tdone\n\techo $@ >>$TEST_REGRESS_LOGFILE\n\techo $@ >>$TEST_SSH_LOGFILE\n\techo $@ >>$TEST_SSHD_LOGFILE\n\techo \"Saving debug logs to $tarname\" >>$TEST_REGRESS_LOGFILE\n\t(cat $TEST_REGRESS_LOGFILE; echo) >>$OBJ/failed-regress.log\n\t(cat $TEST_SSH_LOGFILE; echo) >>$OBJ/failed-ssh.log\n\t(cat $TEST_SSHD_LOGFILE; echo) >>$OBJ/failed-sshd.log\n\n\t# Save all logfiles in a tarball.\n\t(cd $OBJ &&\n\t  logfiles=\"\"\n\t  for i in $TEST_REGRESS_LOGFILE $TEST_SSH_LOGFILE $TEST_SSHD_LOGFILE \\\n\t    $TEST_SSH_LOGDIR; do\n\t\tif [ -e \"`basename $i`\" ]; then\n\t\t\tlogfiles=\"$logfiles `basename $i`\"\n\t\telse\n\t\t\tlogfiles=\"$logfiles $i\"\n\t\tfi\n\t  done\n\t  tar cf \"$tarname\" $logfiles)\n}\n\ntrace ()\n{\n\tstart_debug_log $@\n\tif [ \"X$TEST_SSH_TRACE\" = \"Xyes\" ]; then\n\t\techo \"$@\"\n\tfi\n}\n\nverbose ()\n{\n\tstart_debug_log $@\n\tif [ \"X$TEST_SSH_QUIET\" != \"Xyes\" ]; then\n\t\techo \"$@\"\n\tfi\n}\n\nfail ()\n{\n\tsave_debug_log \"FAIL: $@\"\n\tRESULT=1\n\techo \"$@\"\n\tif test \"x$TEST_SSH_FAIL_FATAL\" != \"x\" ; then\n\t\tcleanup\n\t\texit $RESULT\n\tfi\n}\n\nfatal ()\n{\n\tsave_debug_log \"FATAL: $@\"\n\tprintf \"FATAL: \"\n\tfail \"$@\"\n\tcleanup\n\texit $RESULT\n}\n\n# Skip remaining tests in script.\nskip ()\n{\n\techo \"SKIPPED: $@\"\n\tcleanup\n\texit $RESULT\n}\n\nmaybe_add_scp_path_to_sshd ()\n{\n\t# If we're testing a non-installed scp, add its directory to sshd's\n\t# PATH so we can test it.  We don't do this for all tests as it\n\t# breaks the SetEnv tests.\n\tcase \"$SCP\" in\n\t/*)\tPATH_WITH_SCP=\"`dirname $SCP`:$PATH\"\n\t\techo \"\tSetEnv PATH='$PATH_WITH_SCP'\" >>$OBJ/sshd_config\n\t\techo \"\tSetEnv PATH='$PATH_WITH_SCP'\" >>$OBJ/sshd_proxy ;;\n\tesac\n}\n\nRESULT=0\nPIDFILE=$OBJ/pidfile\n\ntrap fatal 3 2\n\n# create server config\ncat << EOF > $OBJ/sshd_config\n\tStrictModes\t\tno\n\tPort\t\t\t$PORT\n\tAddressFamily\t\tinet\n\tListenAddress\t\t127.0.0.1\n\t#ListenAddress\t\t::1\n\tPidFile\t\t\t$PIDFILE\n\tAuthorizedKeysFile\t$OBJ/authorized_keys_%u\n\tLogLevel\t\tDEBUG3\n\tAcceptEnv\t\t_XXX_TEST_*\n\tAcceptEnv\t\t_XXX_TEST\n\tSubsystem\tsftp\t$SFTPSERVER\nEOF\n\n# This may be necessary if /usr/src and/or /usr/obj are group-writable,\n# but if you aren't careful with permissions then the unit tests could\n# be abused to locally escalate privileges.\nif [ ! -z \"$TEST_SSH_UNSAFE_PERMISSIONS\" ]; then\n\techo \"\tStrictModes no\" >> $OBJ/sshd_config\nelse\n\t# check and warn if excessive permissions are likely to cause failures.\n\tunsafe=\"\"\n\tdir=\"${OBJ}\"\n\twhile test ${dir} != \"/\"; do\n\t\tif test -d \"${dir}\" && ! test -h \"${dir}\"; then\n\t\t\tperms=`ls -ld ${dir}`\n\t\t\tcase \"${perms}\" in\n\t\t\t?????w????*|????????w?*) unsafe=\"${unsafe} ${dir}\" ;;\n\t\t\tesac\n\t\tfi\n\t\tdir=`dirname ${dir}`\n\tdone\n\tif ! test  -z \"${unsafe}\"; then\n\t\tcat <<EOD\n\nWARNING: Unsafe (group or world writable) directory permissions found:\n${unsafe}\n\nThese could be abused to locally escalate privileges.  If you are\nsure that this is not a risk (eg there are no other users), you can\nbypass this check by setting TEST_SSH_UNSAFE_PERMISSIONS=1\n\nEOD\n\tfi\nfi\n\nif [ ! -z \"$TEST_SSH_MODULI_FILE\" ]; then\n\ttrace \"adding modulifile='$TEST_SSH_MODULI_FILE' to sshd_config\"\n\techo \"\tModuliFile '$TEST_SSH_MODULI_FILE'\" >> $OBJ/sshd_config\nfi\n\nif [ ! -z \"$TEST_SSH_SSHD_CONFOPTS\" ]; then\n\ttrace \"adding sshd_config option $TEST_SSH_SSHD_CONFOPTS\"\n\techo \"$TEST_SSH_SSHD_CONFOPTS\" >> $OBJ/sshd_config\nfi\n\n# server config for proxy connects\ncp $OBJ/sshd_config $OBJ/sshd_proxy\n\n# allow group-writable directories in proxy-mode\necho 'StrictModes no' >> $OBJ/sshd_proxy\n\n# create client config\ncat << EOF > $OBJ/ssh_config\nHost *\n\tHostname\t\t127.0.0.1\n\tHostKeyAlias\t\tlocalhost-with-alias\n\tPort\t\t\t$PORT\n\tUser\t\t\t$USER\n\tGlobalKnownHostsFile\t$OBJ/known_hosts\n\tUserKnownHostsFile\t$OBJ/known_hosts\n\tPubkeyAuthentication\tyes\n\tChallengeResponseAuthentication\tno\n\tPasswordAuthentication\tno\n\tBatchMode\t\tyes\n\tStrictHostKeyChecking\tyes\n\tLogLevel\t\tDEBUG3\nEOF\n\nif [ ! -z \"$TEST_SSH_SSH_CONFOPTS\" ]; then\n\ttrace \"adding ssh_config option $TEST_SSH_SSH_CONFOPTS\"\n\techo \"$TEST_SSH_SSH_CONFOPTS\" >> $OBJ/ssh_config\nfi\n\nrm -f $OBJ/known_hosts $OBJ/authorized_keys_$USER\n\nSSH_SK_PROVIDER=\nif ! config_defined ENABLE_SK; then\n\ttrace skipping sk-dummy\nelif [ -f \"${SRC}/misc/sk-dummy/obj/sk-dummy.so\" ] ; then\n\tSSH_SK_PROVIDER=\"${SRC}/misc/sk-dummy/obj/sk-dummy.so\"\nelif [ -f \"${OBJ}/misc/sk-dummy/sk-dummy.so\" ] ; then\n\tSSH_SK_PROVIDER=\"${OBJ}/misc/sk-dummy/sk-dummy.so\"\nelif [ -f \"${SRC}/misc/sk-dummy/sk-dummy.so\" ] ; then\n\tSSH_SK_PROVIDER=\"${SRC}/misc/sk-dummy/sk-dummy.so\"\nfi\nexport SSH_SK_PROVIDER\n\nif ! test -z \"$SSH_SK_PROVIDER\"; then\n\tEXTRA_AGENT_ARGS='-P/*' # XXX want realpath(1)...\n\techo \"SecurityKeyProvider $SSH_SK_PROVIDER\" >> $OBJ/ssh_config\n\techo \"SecurityKeyProvider $SSH_SK_PROVIDER\" >> $OBJ/sshd_config\n\techo \"SecurityKeyProvider $SSH_SK_PROVIDER\" >> $OBJ/sshd_proxy\nfi\nexport EXTRA_AGENT_ARGS\n\nmaybe_filter_sk() {\n\tif test -z \"$SSH_SK_PROVIDER\" ; then\n\t\tgrep -v ^sk\n\telse\n\t\tcat\n\tfi\n}\n\nSSH_KEYTYPES=`$SSH -Q key-plain | maybe_filter_sk`\nSSH_HOSTKEY_TYPES=`$SSH -Q key-plain | maybe_filter_sk`\n\nfor t in ${SSH_KEYTYPES}; do\n\t# generate user key\n\tif [ ! -f $OBJ/$t ] || [ ${SSHKEYGEN_BIN} -nt $OBJ/$t ]; then\n\t\ttrace \"generating key type $t\"\n\t\trm -f $OBJ/$t\n\t\t${SSHKEYGEN} -q -N '' -t $t  -f $OBJ/$t ||\\\n\t\t\tfail \"ssh-keygen for $t failed\"\n\telse\n\t\ttrace \"using cached key type $t\"\n\tfi\n\n\t# setup authorized keys\n\tcat $OBJ/$t.pub >> $OBJ/authorized_keys_$USER\n\techo IdentityFile $OBJ/$t >> $OBJ/ssh_config\ndone\n\nfor t in ${SSH_HOSTKEY_TYPES}; do\n\t# known hosts file for client\n\t(\n\t\tprintf 'localhost-with-alias,127.0.0.1,::1 '\n\t\tcat $OBJ/$t.pub\n\t) >> $OBJ/known_hosts\n\n\t# use key as host key, too\n\t(umask 077; $SUDO cp $OBJ/$t $OBJ/host.$t)\n\techo HostKey $OBJ/host.$t >> $OBJ/sshd_config\n\n\t# don't use SUDO for proxy connect\n\techo HostKey $OBJ/$t >> $OBJ/sshd_proxy\ndone\nchmod 644 $OBJ/authorized_keys_$USER\n\n# Activate Twisted Conch tests if the binary is present\nREGRESS_INTEROP_CONCH=no\nif test -x \"$CONCH\" ; then\n\tREGRESS_INTEROP_CONCH=yes\nfi\n\n# If PuTTY is present, new enough and we are running a PuTTY test, prepare\n# keys and configuration.\nREGRESS_INTEROP_PUTTY=no\nif test -x \"$PUTTYGEN\" -a -x \"$PLINK\" &&\n    \"$PUTTYGEN\" --help 2>&1 | grep -- --new-passphrase >/dev/null; then\n\tREGRESS_INTEROP_PUTTY=yes\nfi\ncase \"$SCRIPT\" in\n*putty*)\t;;\n*)\t\tREGRESS_INTEROP_PUTTY=no ;;\nesac\n\nif test \"$REGRESS_INTEROP_PUTTY\" = \"yes\" ; then\n\tmkdir -p ${OBJ}/.putty\n\n\t# Add a PuTTY key to authorized_keys\n\trm -f ${OBJ}/putty.rsa2\n\tif ! \"$PUTTYGEN\" -t rsa -o ${OBJ}/putty.rsa2 \\\n\t    --random-device=/dev/urandom \\\n\t    --new-passphrase /dev/null < /dev/null > /dev/null; then\n\t\techo \"Your installed version of PuTTY is too old to support --new-passphrase, skipping test\" >&2\n\t\texit 1\n\tfi\n\t\"$PUTTYGEN\" -O public-openssh ${OBJ}/putty.rsa2 \\\n\t    >> $OBJ/authorized_keys_$USER\n\n\t# Convert rsa2 host key to PuTTY format\n\tcp $OBJ/ssh-rsa $OBJ/ssh-rsa_oldfmt\n\t${SSHKEYGEN} -p -N '' -m PEM -f $OBJ/ssh-rsa_oldfmt >/dev/null\n\t${SRC}/ssh2putty.sh 127.0.0.1 $PORT $OBJ/ssh-rsa_oldfmt > \\\n\t    ${OBJ}/.putty/sshhostkeys\n\t${SRC}/ssh2putty.sh 127.0.0.1 22 $OBJ/ssh-rsa_oldfmt >> \\\n\t    ${OBJ}/.putty/sshhostkeys\n\trm -f $OBJ/ssh-rsa_oldfmt\n\n\t# Setup proxied session\n\tmkdir -p ${OBJ}/.putty/sessions\n\trm -f ${OBJ}/.putty/sessions/localhost_proxy\n\techo \"Protocol=ssh\" >> ${OBJ}/.putty/sessions/localhost_proxy\n\techo \"HostName=127.0.0.1\" >> ${OBJ}/.putty/sessions/localhost_proxy\n\techo \"PortNumber=$PORT\" >> ${OBJ}/.putty/sessions/localhost_proxy\n\techo \"ProxyMethod=5\" >> ${OBJ}/.putty/sessions/localhost_proxy\n\techo \"ProxyTelnetCommand=${OBJ}/sshd-log-wrapper.sh -i -f $OBJ/sshd_proxy\" >> ${OBJ}/.putty/sessions/localhost_proxy\n\techo \"ProxyLocalhost=1\" >> ${OBJ}/.putty/sessions/localhost_proxy\n\n\tPUTTYDIR=${OBJ}/.putty\n\texport PUTTYDIR\nfi\n\nREGRESS_INTEROP_DROPBEAR=no\nif test -x \"$DROPBEARKEY\" -a -x \"$DBCLIENT\" -a -x \"$DROPBEARCONVERT\"; then\n\tREGRESS_INTEROP_DROPBEAR=yes\nfi\ncase \"$SCRIPT\" in\n*dropbear*)\t;;\n*)\t\tREGRESS_INTEROP_DROPBEAR=no ;;\nesac\n\nif test \"$REGRESS_INTEROP_DROPBEAR\" = \"yes\" ; then\n\ttrace Create dropbear keys and add to authorized_keys\n\tmkdir -p $OBJ/.dropbear\n\tfor i in rsa ecdsa ed25519 dss; do\n\t\tif [ ! -f \"$OBJ/.dropbear/id_$i\" ]; then\n\t\t\t($DROPBEARKEY -t $i -f $OBJ/.dropbear/id_$i\n\t\t\t$DROPBEARCONVERT dropbear openssh \\\n\t\t\t    $OBJ/.dropbear/id_$i $OBJ/.dropbear/ossh.id_$i\n\t\t\t) > /dev/null 2>&1\n\t\tfi\n\t\t$SSHKEYGEN -y -f $OBJ/.dropbear/ossh.id_$i \\\n\t\t   >>$OBJ/authorized_keys_$USER\n\tdone\nfi\n\n# create a proxy version of the client config\n(\n\tcat $OBJ/ssh_config\n\techo proxycommand ${SUDO} env SSH_SK_HELPER=\\\"$SSH_SK_HELPER\\\" ${OBJ}/sshd-log-wrapper.sh -i -f $OBJ/sshd_proxy\n) > $OBJ/ssh_proxy\n\n# check proxy config\n${SSHD} -t -f $OBJ/sshd_proxy\t|| fatal \"sshd_proxy broken\"\n\n# extract proxycommand into separate shell script for use by Dropbear.\necho '#!/bin/sh' >$OBJ/ssh_proxy.sh\nawk '/^proxycommand/' $OBJ/ssh_proxy | sed 's/^proxycommand//' \\\n   >>$OBJ/ssh_proxy.sh\nchmod a+x $OBJ/ssh_proxy.sh\n\nstart_sshd ()\n{\n\t# start sshd\n\tlogfile=\"${TEST_SSH_LOGDIR}/sshd.`$OBJ/timestamp`.$$.log\"\n\t$SUDO ${SSHD} -f $OBJ/sshd_config \"$@\" -t || fatal \"sshd_config broken\"\n\t$SUDO env SSH_SK_HELPER=\"$SSH_SK_HELPER\" \\\n\t    ${SSHD} -f $OBJ/sshd_config \"$@\" -E$TEST_SSHD_LOGFILE\n\n\ttrace \"wait for sshd\"\n\ti=0;\n\twhile [ ! -f $PIDFILE -a $i -lt 10 ]; do\n\t\ti=`expr $i + 1`\n\t\tsleep $i\n\tdone\n\n\ttest -f $PIDFILE || fatal \"no sshd running on port $PORT\"\n}\n\n# Find a PKCS#11 library.\np11_find_lib() {\n\tTEST_SSH_PKCS11=\"\"\n\tfor _lib in \"$@\" ; do\n\t\tif test -f \"$_lib\" ; then\n\t\t\tTEST_SSH_PKCS11=\"$_lib\"\n\t\t\treturn\n\t\tfi\n\tdone\n}\n\n# Perform PKCS#11 setup: prepares a softhsm2 token configuration, generated\n# keys and loads them into the virtual token.\nPKCS11_OK=\nexport PKCS11_OK\np11_setup() {\n\tp11_find_lib \\\n\t\t/usr/local/lib/softhsm/libsofthsm2.so \\\n\t\t/usr/lib64/pkcs11/libsofthsm2.so \\\n\t\t/usr/lib/x86_64-linux-gnu/softhsm/libsofthsm2.so\n\ttest -z \"$TEST_SSH_PKCS11\" && return 1\n\tverbose \"using token library $TEST_SSH_PKCS11\"\n\tTEST_SSH_PIN=1234\n\tTEST_SSH_SOPIN=12345678\n\tif [ \"x$TEST_SSH_SSHPKCS11HELPER\" != \"x\" ]; then\n\t\tSSH_PKCS11_HELPER=\"${TEST_SSH_SSHPKCS11HELPER}\"\n\t\texport SSH_PKCS11_HELPER\n\tfi\n\n\t# setup environment for softhsm2 token\n\tSSH_SOFTHSM_DIR=$OBJ/SOFTHSM\n\texport SSH_SOFTHSM_DIR\n\trm -rf $SSH_SOFTHSM_DIR\n\tTOKEN=$SSH_SOFTHSM_DIR/tokendir\n\tmkdir -p $TOKEN\n\tSOFTHSM2_CONF=$SSH_SOFTHSM_DIR/softhsm2.conf\n\texport SOFTHSM2_CONF\n\tcat > $SOFTHSM2_CONF << EOF\n# SoftHSM v2 configuration file\ndirectories.tokendir = ${TOKEN}\nobjectstore.backend = file\n# ERROR, WARNING, INFO, DEBUG\nlog.level = DEBUG\n# If CKF_REMOVABLE_DEVICE flag should be set\nslots.removable = false\nEOF\n\tout=$(softhsm2-util --init-token --free --label token-slot-0 --pin \"$TEST_SSH_PIN\" --so-pin \"$TEST_SSH_SOPIN\")\n\tslot=$(echo -- $out | sed 's/.* //')\n\ttrace \"generating keys\"\n\t# RSA key\n\tRSA=${SSH_SOFTHSM_DIR}/RSA\n\tRSAP8=${SSH_SOFTHSM_DIR}/RSAP8\n\t$OPENSSL_BIN genpkey -algorithm rsa > $RSA 2>/dev/null || \\\n\t    fatal \"genpkey RSA fail\"\n\t$OPENSSL_BIN pkcs8 -nocrypt -in $RSA > $RSAP8 || fatal \"pkcs8 RSA fail\"\n\tsofthsm2-util --slot \"$slot\" --label 01 --id 01 --pin \"$TEST_SSH_PIN\" \\\n\t    --import $RSAP8 >/dev/null || fatal \"softhsm import RSA fail\"\n\tchmod 600 $RSA\n\tssh-keygen -y -f $RSA > ${RSA}.pub\n\t# ECDSA key\n\tECPARAM=${SSH_SOFTHSM_DIR}/ECPARAM\n\tEC=${SSH_SOFTHSM_DIR}/EC\n\tECP8=${SSH_SOFTHSM_DIR}/ECP8\n\t$OPENSSL_BIN genpkey -genparam -algorithm ec \\\n\t    -pkeyopt ec_paramgen_curve:prime256v1 > $ECPARAM || \\\n\t    fatal \"param EC fail\"\n\t$OPENSSL_BIN genpkey -paramfile $ECPARAM > $EC || \\\n\t    fatal \"genpkey EC fail\"\n\t$OPENSSL_BIN pkcs8 -nocrypt -in $EC > $ECP8 || fatal \"pkcs8 EC fail\"\n\tsofthsm2-util --slot \"$slot\" --label 02 --id 02 --pin \"$TEST_SSH_PIN\" \\\n\t    --import $ECP8 >/dev/null || fatal \"softhsm import EC fail\"\n\tchmod 600 $EC\n\tssh-keygen -y -f $EC > ${EC}.pub\n\t# Prepare askpass script to load PIN.\n\tPIN_SH=$SSH_SOFTHSM_DIR/pin.sh\n\tcat > $PIN_SH << EOF\n#!/bin/sh\necho \"${TEST_SSH_PIN}\"\nEOF\n\tchmod 0700 \"$PIN_SH\"\n\tPKCS11_OK=yes\n\treturn 0\n}\n\n# Peforms ssh-add with the right token PIN.\np11_ssh_add() {\n\tenv SSH_ASKPASS=\"$PIN_SH\" SSH_ASKPASS_REQUIRE=force ${SSHADD} \"$@\"\n}\n\n# source test body\n. $SCRIPT\n\n# kill sshd\ncleanup\n\nif [ \"x$USE_VALGRIND\" != \"x\" ]; then\n\t# If there is an EXIT trap handler, invoke it now.\n\t# Some tests set these to clean up processes such as ssh-agent.  We\n\t# need to wait for all valgrind processes to complete so we can check\n\t# their logs, but since the EXIT traps are not invoked until\n\t# test-exec.sh exits, waiting here will deadlock.\n\t# This is not very portable but then neither is valgrind itself.\n\t# As a bonus, dash (as used on the runners) has a \"trap\" that doesn't\n\t# work in a pipeline (hence the temp file) or a subshell.\n\texithandler=\"\"\n\ttrap >/tmp/trap.$$ && exithandler=$(cat /tmp/trap.$$ | \\\n\t    awk -F \"'\" '/EXIT$/{print $2}')\n\trm -f /tmp/trap.$$\n\tif [ \"x${exithandler}\" != \"x\" ]; then\n\t\tverbose invoking EXIT trap handler early: ${exithandler}\n\t\teval \"${exithandler}\"\n\t\ttrap '' EXIT\n\tfi\n\n\t# wait for any running process to complete\n\twait; sleep 1\n\tVG_RESULTS=$(find $OBJ/valgrind-out -type f -print)\n\tVG_RESULT_COUNT=0\n\tVG_FAIL_COUNT=0\n\tfor i in $VG_RESULTS; do\n\t\tif grep \"ERROR SUMMARY\" $i >/dev/null; then\n\t\t\tVG_RESULT_COUNT=$(($VG_RESULT_COUNT + 1))\n\t\t\tif ! grep \"ERROR SUMMARY: 0 errors\" $i >/dev/null; then\n\t\t\t\tVG_FAIL_COUNT=$(($VG_FAIL_COUNT + 1))\n\t\t\t\tRESULT=1\n\t\t\t\tverbose valgrind failure $i\n\t\t\t\tcat $i\n\t\t\tfi\n\t\tfi\n\tdone\n\tif [ x\"$VG_SKIP\" != \"x\" ]; then\n\t\tverbose valgrind skipped\n\telse\n\t\tverbose valgrind results $VG_RESULT_COUNT failures $VG_FAIL_COUNT\n\tfi\nfi\n\nif [ $RESULT -eq 0 ]; then\n\tverbose ok $tid\n\tif [ \"x$CACHE\" != \"x\" ]; then\n\t\ttouch \"$CACHE\"\n\tfi\nelse\n\techo failed $tid\nfi\nexit $RESULT\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}