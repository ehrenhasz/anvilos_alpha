{
  "module_name": "integrity.sh",
  "hash_id": "195c8b380f082843ce5ce30675ed38c514be0f6ebb12c46d00bb05700665716a",
  "original_prompt": "Ingested from openssh-9.6p1/regress/integrity.sh",
  "human_readable_source": "#\t$OpenBSD: integrity.sh,v 1.25 2023/03/01 09:29:32 dtucker Exp $\n#\tPlaced in the Public Domain.\n\ntid=\"integrity\"\ncp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak\n\n# start at byte 2900 (i.e. after kex) and corrupt at different offsets\ntries=10\nstartoffset=2900\nmacs=`${SSH} -Q mac`\n# The following are not MACs, but ciphers with integrated integrity. They are\n# handled specially below.\nmacs=\"$macs `${SSH} -Q cipher-auth`\"\n\n# avoid DH group exchange as the extra traffic makes it harder to get the\n# offset into the stream right.\n#echo \"KexAlgorithms -diffie-hellman-group*\" \\\n#\t>> $OBJ/ssh_proxy\n\n# sshd-command for proxy (see test-exec.sh)\ncmd=\"$SUDO env SSH_SK_HELPER=\"$SSH_SK_HELPER\" sh ${OBJ}/sshd-log-wrapper.sh -i -f $OBJ/sshd_proxy\"\n\nfor m in $macs; do\n\ttrace \"test $tid: mac $m\"\n\telen=0\n\tepad=0\n\temac=0\n\tetmo=0\n\tecnt=0\n\tskip=0\n\tfor off in `jot $tries $startoffset`; do\n\t\tskip=`expr $skip - 1`\n\t\tif [ $skip -gt 0 ]; then\n\t\t\t# avoid modifying the high bytes of the length\n\t\t\tcontinue\n\t\tfi\n\t\tcp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy\n\t\t# modify output from sshd at offset $off\n\t\tpxy=\"proxycommand=$cmd | $OBJ/modpipe -wm xor:$off:1\"\n\t\tif ${SSH} -Q cipher-auth | grep \"^${m}\\$\" >/dev/null 2>&1 ; then\n\t\t\techo \"Ciphers=$m\" >> $OBJ/sshd_proxy\n\t\t\tmacopt=\"-c $m\"\n\t\telse\n\t\t\techo \"Ciphers=aes128-ctr\" >> $OBJ/sshd_proxy\n\t\t\techo \"MACs=$m\" >> $OBJ/sshd_proxy\n\t\t\tmacopt=\"-m $m -c aes128-ctr\"\n\t\tfi\n\t\tverbose \"test $tid: $m @$off\"\n\t\t${SSH} $macopt -F $OBJ/ssh_proxy -o \"$pxy\" \\\n\t\t    -oServerAliveInterval=1 -oServerAliveCountMax=30 \\\n\t\t    999.999.999.999 'printf \"%4096s\" \" \"' >/dev/null\n\t\tif [ $? -eq 0 ]; then\n\t\t\tfail \"ssh -m $m succeeds with bit-flip at $off\"\n\t\tfi\n\t\tecnt=`expr $ecnt + 1`\n\t\tout=$(egrep -v \"^debug\" $TEST_SSH_LOGFILE | tail -2 | \\\n\t\t     tr -s '\\r\\n' '.')\n\t\tcase \"$out\" in\n\t\tBad?packet*)\telen=`expr $elen + 1`; skip=3;;\n\t\tCorrupted?MAC* | *message?authentication?code?incorrect*)\n\t\t\t\temac=`expr $emac + 1`; skip=0;;\n\t\tpadding*)\tepad=`expr $epad + 1`; skip=0;;\n\t\t*Timeout,?server*)\n\t\t\t\tetmo=`expr $etmo + 1`; skip=0;;\n\t\t*)\t\tfail \"unexpected error mac $m at $off: $out\";;\n\t\tesac\n\tdone\n\tverbose \"test $tid: $ecnt errors: mac $emac padding $epad length $elen timeout $etmo\"\n\tif [ $emac -eq 0 ]; then\n\t\tfail \"$m: no mac errors\"\n\tfi\n\texpect=`expr $ecnt - $epad - $elen - $etmo`\n\tif [ $emac -ne $expect ]; then\n\t\tfail \"$m: expected $expect mac errors, got $emac\"\n\tfi\ndone\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}