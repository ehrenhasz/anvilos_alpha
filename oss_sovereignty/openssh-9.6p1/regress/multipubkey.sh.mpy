{
  "module_name": "multipubkey.sh",
  "hash_id": "e68e6f7a258012221a10b9560043306876a271e0511a3495f2ed2d057d40549e",
  "original_prompt": "Ingested from openssh-9.6p1/regress/multipubkey.sh",
  "human_readable_source": "#\t$OpenBSD: multipubkey.sh,v 1.4 2021/06/07 01:16:34 djm Exp $\n#\tPlaced in the Public Domain.\n\ntid=\"multiple pubkey\"\n\nrm -f $OBJ/authorized_keys_$USER $OBJ/user_ca_key* $OBJ/user_key*\nrm -f $OBJ/authorized_principals_$USER $OBJ/cert_user_key*\n\nmv $OBJ/sshd_proxy $OBJ/sshd_proxy.orig\nmv $OBJ/ssh_proxy $OBJ/ssh_proxy.orig\n\n# Create a CA key\n${SSHKEYGEN} -q -N '' -t ed25519  -f $OBJ/user_ca_key ||\\\n\tfatal \"ssh-keygen failed\"\n\n# Make some keys and a certificate.\n${SSHKEYGEN} -q -N '' -t ed25519 -f $OBJ/user_key1 || \\\n\tfatal \"ssh-keygen failed\"\n${SSHKEYGEN} -q -N '' -t ed25519 -f $OBJ/user_key2 || \\\n\tfatal \"ssh-keygen failed\"\n${SSHKEYGEN} -q -s $OBJ/user_ca_key -I \"regress user key for $USER\" \\\n\t-z $$ -n ${USER},mekmitasdigoat $OBJ/user_key1 ||\n\t\tfail \"couldn't sign user_key1\"\n# Copy the private key alongside the cert to allow better control of when\n# it is offered.\nmv $OBJ/user_key1-cert.pub $OBJ/cert_user_key1.pub\ncp -p $OBJ/user_key1 $OBJ/cert_user_key1\n\ngrep -v IdentityFile $OBJ/ssh_proxy.orig > $OBJ/ssh_proxy\n\nopts=\"-oProtocol=2 -F $OBJ/ssh_proxy -oIdentitiesOnly=yes\"\nopts=\"$opts -i $OBJ/cert_user_key1 -i $OBJ/user_key1 -i $OBJ/user_key2\"\n\nfor match in no yes ; do\n\t(\n\t\tcat  $OBJ/sshd_proxy.orig\n\t\techo \"Protocol 2\"\n\t\techo \"TrustedUserCAKeys $OBJ/user_ca_key.pub\"\n\t\techo \"AuthorizedPrincipalsFile $OBJ/authorized_principals_%u\"\n \t) > $OBJ/sshd_proxy\n\tif test \"$match\" = \"yes\" ; then\n\t\techo \"AuthenticationMethods none\" >> $OBJ/sshd_proxy\n\t\techo \"PubkeyAuthentication no\" >> $OBJ/sshd_proxy\n\t\techo \"Match all\" >> $OBJ/sshd_proxy\n\t\techo \"PubkeyAuthentication yes\" >> $OBJ/sshd_proxy\n\tfi\n\techo \"AuthenticationMethods publickey,publickey\" >> $OBJ/sshd_proxy\n\n\t# Single key should fail.\n\ttrace \"match $match single key\"\n\trm -f $OBJ/authorized_principals_$USER\n\tcat $OBJ/user_key1.pub > $OBJ/authorized_keys_$USER\n\t${SSH} $opts proxy true && fail \"ssh succeeded with key\"\n\n\t# Single key with same-public cert should fail.\n\ttrace \"match $match pubkey + identical cert\"\n\techo mekmitasdigoat > $OBJ/authorized_principals_$USER\n\tcat $OBJ/user_key1.pub > $OBJ/authorized_keys_$USER\n\t${SSH} $opts proxy true && fail \"ssh succeeded with key+cert\"\n\n\t# Multiple plain keys should succeed.\n\ttrace \"match $match multiple public\"\n\trm -f $OBJ/authorized_principals_$USER\n\tcat $OBJ/user_key1.pub $OBJ/user_key2.pub > \\\n\t    $OBJ/authorized_keys_$USER\n\t${SSH} $opts proxy true || fail \"ssh failed with multiple keys\"\n\t# Cert and different key should succeed\n\n\t# Key and different-public cert should succeed.\n\ttrace \"match $match pubkey + different cert\"\n\techo mekmitasdigoat > $OBJ/authorized_principals_$USER\n\tcat $OBJ/user_key2.pub > $OBJ/authorized_keys_$USER\n\t${SSH} $opts proxy true || fail \"ssh failed with key/cert\"\ndone\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}