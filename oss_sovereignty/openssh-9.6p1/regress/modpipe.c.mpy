{
  "module_name": "modpipe.c",
  "hash_id": "417e85870bee16e3e9d7191ecef199c6095b0a2cdb701bb6ae679cdbab3fd52c",
  "original_prompt": "Ingested from openssh-9.6p1/regress/modpipe.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n#ifdef HAVE_ERR_H\n# include <err.h>\n#endif\n#include \"openbsd-compat/getopt_long.c\"\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"Usage: modpipe -w [-m modspec ...] < in > out\\n\");\n\tfprintf(stderr, \"modspec is one of:\\n\");\n\tfprintf(stderr, \"    xor:offset:value       - XOR \\\"value\\\" at \\\"offset\\\"\\n\");\n\tfprintf(stderr, \"    andor:offset:val1:val2 - AND \\\"val1\\\" then OR \\\"val2\\\" at \\\"offset\\\"\\n\");\n\texit(1);\n}\n\n#define MAX_MODIFICATIONS 256\nstruct modification {\n\tenum { MOD_XOR, MOD_AND_OR } what;\n\tunsigned long long offset;\n\tu_int8_t m1, m2;\n};\n\nstatic void\nparse_modification(const char *s, struct modification *m)\n{\n\tchar what[16+1];\n\tint n, m1, m2;\n\n\tbzero(m, sizeof(*m));\n\tif ((n = sscanf(s, \"%16[^:]%*[:]%llu%*[:]%i%*[:]%i\",\n\t    what, &m->offset, &m1, &m2)) < 3)\n\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\tif (strcasecmp(what, \"xor\") == 0) {\n\t\tif (n > 3)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid XOR modification value\");\n\t\tm->what = MOD_XOR;\n\t\tm->m1 = m1;\n\t} else if (strcasecmp(what, \"andor\") == 0) {\n\t\tif (n != 4)\n\t\t\terrx(1, \"Invalid modification spec \\\"%s\\\"\", s);\n\t\tif (m1 < 0 || m1 > 0xff)\n\t\t\terrx(1, \"Invalid AND modification value\");\n\t\tif (m2 < 0 || m2 > 0xff)\n\t\t\terrx(1, \"Invalid OR modification value\");\n\t\tm->what = MOD_AND_OR;\n\t\tm->m1 = m1;\n\t\tm->m2 = m2;\n\t} else\n\t\terrx(1, \"Invalid modification type \\\"%s\\\"\", what);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint ch;\n\tu_char buf[8192];\n\tsize_t total;\n\tssize_t r, s, o;\n\tstruct modification mods[MAX_MODIFICATIONS];\n\tu_int i, wflag = 0, num_mods = 0;\n\n\twhile ((ch = getopt(argc, argv, \"wm:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t\tif (num_mods >= MAX_MODIFICATIONS)\n\t\t\t\terrx(1, \"Too many modifications\");\n\t\t\tparse_modification(optarg, &(mods[num_mods++]));\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\t \n\t\t}\n\t}\n\tfor (total = 0;;) {\n\t\tr = s = read(STDIN_FILENO, buf, sizeof(buf));\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (r < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terr(1, \"read\");\n\t\t}\n\t\tfor (i = 0; i < num_mods; i++) {\n\t\t\tif (mods[i].offset < total ||\n\t\t\t    mods[i].offset >= total + s)\n\t\t\t\tcontinue;\n\t\t\tswitch (mods[i].what) {\n\t\t\tcase MOD_XOR:\n\t\t\t\tbuf[mods[i].offset - total] ^= mods[i].m1;\n\t\t\t\tbreak;\n\t\t\tcase MOD_AND_OR:\n\t\t\t\tbuf[mods[i].offset - total] &= mods[i].m1;\n\t\t\t\tbuf[mods[i].offset - total] |= mods[i].m2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (o = 0; o < s; o += r) {\n\t\t\tr = write(STDOUT_FILENO, buf, s - o);\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tif (r < 0) {\n\t\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\terr(1, \"write\");\n\t\t\t}\n\t\t}\n\t\ttotal += s;\n\t}\n\t \n\tr = 0;\n\tfor (i = 0; wflag && i < num_mods; i++) {\n\t\tif (mods[i].offset < total)\n\t\t\tcontinue;\n\t\tr = 1;\n\t\tfprintf(stderr, \"modpipe: warning - mod %u not reached\\n\", i);\n\t}\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}