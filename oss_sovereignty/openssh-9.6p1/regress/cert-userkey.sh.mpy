{
  "module_name": "cert-userkey.sh",
  "hash_id": "1c9c86e882638117961a0f378e577c7a6f28a5db5ec13ea75f5e84c480904676",
  "original_prompt": "Ingested from openssh-9.6p1/regress/cert-userkey.sh",
  "human_readable_source": "#\t$OpenBSD: cert-userkey.sh,v 1.28 2021/09/30 05:26:26 dtucker Exp $\n#\tPlaced in the Public Domain.\n\ntid=\"certified user keys\"\n\nrm -f $OBJ/authorized_keys_$USER $OBJ/user_ca_key* $OBJ/cert_user_key*\ncp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak\ncp $OBJ/ssh_proxy $OBJ/ssh_proxy_bak\n\nPLAIN_TYPES=`$SSH -Q key-plain | maybe_filter_sk | sed 's/^ssh-dss/ssh-dsa/;s/^ssh-//'`\nEXTRA_TYPES=\"\"\nrsa=\"\"\n\nif echo \"$PLAIN_TYPES\" | grep '^rsa$' >/dev/null 2>&1 ; then\n\trsa=rsa\n\tPLAIN_TYPES=\"$PLAIN_TYPES rsa-sha2-256 rsa-sha2-512\"\nfi\n\nkname() {\n\tcase $1 in\n\trsa-sha2-*) n=\"$1\" ;;\n\tsk-ecdsa-*) n=\"sk-ecdsa\" ;;\n\tsk-ssh-ed25519*) n=\"sk-ssh-ed25519\" ;;\n\t# subshell because some seds will add a newline\n\t*) n=$(echo $1 | sed 's/^dsa/ssh-dss/;s/^rsa/ssh-rsa/;s/^ed/ssh-ed/') ;;\n\tesac\n\tif [ -z \"$rsa\" ]; then\n\t\techo \"$n*,ssh-ed25519*\"\n\telse\n\t\techo \"$n*,ssh-rsa*,ssh-ed25519*\"\n\tfi\n}\n\n# Create a CA key\nif [ ! -z \"$rsa\" ]; then\n\tcatype=rsa\nelse\n\tcatype=ed25519\nfi\n${SSHKEYGEN} -q -N '' -t $catype  -f $OBJ/user_ca_key ||\\\n\tfail \"ssh-keygen of user_ca_key failed\"\n\n# Generate and sign user keys\nfor ktype in $PLAIN_TYPES $EXTRA_TYPES ; do\n\tverbose \"$tid: sign user ${ktype} cert\"\n\t${SSHKEYGEN} -q -N '' -t ${ktype} \\\n\t    -f $OBJ/cert_user_key_${ktype} || \\\n\t\tfatal \"ssh-keygen of cert_user_key_${ktype} failed\"\n\t# Generate RSA/SHA2 certs for rsa-sha2* keys.\n\tcase $ktype in\n\trsa-sha2-*)\ttflag=\"-t $ktype\" ;;\n\t*)\t\ttflag=\"\" ;;\n\tesac\n\t${SSHKEYGEN} -q -s $OBJ/user_ca_key -z $$ \\\n\t    -I \"regress user key for $USER\" \\\n\t    -n ${USER},mekmitasdigoat $tflag $OBJ/cert_user_key_${ktype} || \\\n\t\tfatal \"couldn't sign cert_user_key_${ktype}\"\ndone\n\n# Test explicitly-specified principals\nfor ktype in $EXTRA_TYPES $PLAIN_TYPES ; do\n\tt=$(kname $ktype)\n\t_prefix=\"${ktype}\"\n\n\t# Setup for AuthorizedPrincipalsFile\n\trm -f $OBJ/authorized_keys_$USER\n\t(\n\t\tcat $OBJ/sshd_proxy_bak\n\t\techo \"AuthorizedPrincipalsFile \" \\\n\t\t    \"$OBJ/authorized_principals_%u\"\n\t\techo \"TrustedUserCAKeys $OBJ/user_ca_key.pub\"\n\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t) > $OBJ/sshd_proxy\n\t(\n\t\tcat $OBJ/ssh_proxy_bak\n\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t) > $OBJ/ssh_proxy\n\n\t# Missing authorized_principals\n\tverbose \"$tid: ${_prefix} missing authorized_principals\"\n\trm -f $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpectedly\"\n\tfi\n\n\t# Empty authorized_principals\n\tverbose \"$tid: ${_prefix} empty authorized_principals\"\n\techo > $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpectedly\"\n\tfi\n\n\t# Wrong authorized_principals\n\tverbose \"$tid: ${_prefix} wrong authorized_principals\"\n\techo gregorsamsa > $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpectedly\"\n\tfi\n\n\t# Correct authorized_principals\n\tverbose \"$tid: ${_prefix} correct authorized_principals\"\n\techo mekmitasdigoat > $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -ne 0 ]; then\n\t\tfail \"ssh cert connect failed\"\n\tfi\n\n\t# authorized_principals with bad key option\n\tverbose \"$tid: ${_prefix} authorized_principals bad key opt\"\n\techo 'blah mekmitasdigoat' > $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpectedly\"\n\tfi\n\n\t# authorized_principals with command=false\n\tverbose \"$tid: ${_prefix} authorized_principals command=false\"\n\techo 'command=\"false\" mekmitasdigoat' > \\\n\t    $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpectedly\"\n\tfi\n\n\n\t# authorized_principals with command=true\n\tverbose \"$tid: ${_prefix} authorized_principals command=true\"\n\techo 'command=\"true\" mekmitasdigoat' > \\\n\t    $OBJ/authorized_principals_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost false >/dev/null 2>&1\n\tif [ $? -ne 0 ]; then\n\t\tfail \"ssh cert connect failed\"\n\tfi\n\n\t# Setup for principals= key option\n\trm -f $OBJ/authorized_principals_$USER\n\t(\n\t\tcat $OBJ/sshd_proxy_bak\n\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t) > $OBJ/sshd_proxy\n\t(\n\t\tcat $OBJ/ssh_proxy_bak\n\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t) > $OBJ/ssh_proxy\n\n\t# Wrong principals list\n\tverbose \"$tid: ${_prefix} wrong principals key option\"\n\t(\n\t\tprintf 'cert-authority,principals=\"gregorsamsa\" '\n\t\tcat $OBJ/user_ca_key.pub\n\t) > $OBJ/authorized_keys_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpectedly\"\n\tfi\n\n\t# Correct principals list\n\tverbose \"$tid: ${_prefix} correct principals key option\"\n\t(\n\t\tprintf 'cert-authority,principals=\"mekmitasdigoat\" '\n\t\tcat $OBJ/user_ca_key.pub\n\t) > $OBJ/authorized_keys_$USER\n\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -ne 0 ]; then\n\t\tfail \"ssh cert connect failed\"\n\tfi\ndone\n\nbasic_tests() {\n\tauth=$1\n\tif test \"x$auth\" = \"xauthorized_keys\" ; then\n\t\t# Add CA to authorized_keys\n\t\t(\n\t\t\tprintf 'cert-authority '\n\t\t\tcat $OBJ/user_ca_key.pub\n\t\t) > $OBJ/authorized_keys_$USER\n\telse\n\t\techo > $OBJ/authorized_keys_$USER\n\t\textra_sshd=\"TrustedUserCAKeys $OBJ/user_ca_key.pub\"\n\tfi\n\n\tfor ktype in $PLAIN_TYPES ; do\n\t\tt=$(kname $ktype)\n\t\t_prefix=\"${ktype} $auth\"\n\t\t# Simple connect\n\t\tverbose \"$tid: ${_prefix} connect\"\n\t\t(\n\t\t\tcat $OBJ/sshd_proxy_bak\n\t\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t\t\techo \"$extra_sshd\"\n\t\t) > $OBJ/sshd_proxy\n\t\t(\n\t\t\tcat $OBJ/ssh_proxy_bak\n\t\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t\t) > $OBJ/ssh_proxy\n\n\t\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t\t    -F $OBJ/ssh_proxy somehost true\n\t\tif [ $? -ne 0 ]; then\n\t\t\tfail \"ssh cert connect failed\"\n\t\tfi\n\n\t\t# Revoked keys\n\t\tverbose \"$tid: ${_prefix} revoked key\"\n\t\t(\n\t\t\tcat $OBJ/sshd_proxy_bak\n\t\t\techo \"RevokedKeys $OBJ/cert_user_key_revoked\"\n\t\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t\t\techo \"$extra_sshd\"\n\t\t) > $OBJ/sshd_proxy\n\t\tcp $OBJ/cert_user_key_${ktype}.pub \\\n\t\t    $OBJ/cert_user_key_revoked\n\t\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\t\tif [ $? -eq 0 ]; then\n\t\t\tfail \"ssh cert connect succeeded unexpecedly\"\n\t\tfi\n\t\tverbose \"$tid: ${_prefix} revoked via KRL\"\n\t\trm $OBJ/cert_user_key_revoked\n\t\t${SSHKEYGEN} -kqf $OBJ/cert_user_key_revoked \\\n\t\t    $OBJ/cert_user_key_${ktype}.pub\n\t\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\t\tif [ $? -eq 0 ]; then\n\t\t\tfail \"ssh cert connect succeeded unexpecedly\"\n\t\tfi\n\t\tverbose \"$tid: ${_prefix} empty KRL\"\n\t\t${SSHKEYGEN} -kqf $OBJ/cert_user_key_revoked\n\t\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\t\tif [ $? -ne 0 ]; then\n\t\t\tfail \"ssh cert connect failed\"\n\t\tfi\n\tdone\n\n\t# Revoked CA\n\tverbose \"$tid: ${ktype} $auth revoked CA key\"\n\t(\n\t\tcat $OBJ/sshd_proxy_bak\n\t\techo \"RevokedKeys $OBJ/user_ca_key.pub\"\n\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t\techo \"$extra_sshd\"\n\t) > $OBJ/sshd_proxy\n\t${SSH} -i $OBJ/cert_user_key_${ktype} -F $OBJ/ssh_proxy \\\n\t    somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect succeeded unexpecedly\"\n\tfi\n\n\tverbose \"$tid: $auth CA does not authenticate\"\n\t(\n\t\tcat $OBJ/sshd_proxy_bak\n\t\techo \"PubkeyAcceptedAlgorithms ${t}\"\n\t\techo \"$extra_sshd\"\n\t) > $OBJ/sshd_proxy\n\tverbose \"$tid: ensure CA key does not authenticate user\"\n\t${SSH} -i $OBJ/user_ca_key \\\n\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect with CA key succeeded unexpectedly\"\n\tfi\n}\n\nbasic_tests authorized_keys\nbasic_tests TrustedUserCAKeys\n\ntest_one() {\n\tident=$1\n\tresult=$2\n\tsign_opts=$3\n\tauth_choice=$4\n\tauth_opt=$5\n\n\tif test \"x$auth_choice\" = \"x\" ; then\n\t\tauth_choice=\"authorized_keys TrustedUserCAKeys\"\n\tfi\n\n\tfor auth in $auth_choice ; do\n\t\tfor ktype in $rsa ed25519 ; do\n\t\t\tcat $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy\n\t\t\tif test \"x$auth\" = \"xauthorized_keys\" ; then\n\t\t\t\t# Add CA to authorized_keys\n\t\t\t\t(\n\t\t\t\t\tprintf \"cert-authority${auth_opt} \"\n\t\t\t\t\tcat $OBJ/user_ca_key.pub\n\t\t\t\t) > $OBJ/authorized_keys_$USER\n\t\t\telse\n\t\t\t\techo > $OBJ/authorized_keys_$USER\n\t\t\t\techo \"TrustedUserCAKeys $OBJ/user_ca_key.pub\" \\\n\t\t\t\t    >> $OBJ/sshd_proxy\n\t\t\t\techo \"PubkeyAcceptedAlgorithms ${t}*\" \\\n\t\t\t\t    >> $OBJ/sshd_proxy\n\t\t\t\tif test \"x$auth_opt\" != \"x\" ; then\n\t\t\t\t\techo $auth_opt >> $OBJ/sshd_proxy\n\t\t\t\tfi\n\t\t\tfi\n\n\t\t\tverbose \"$tid: $ident auth $auth expect $result $ktype\"\n\t\t\t${SSHKEYGEN} -q -s $OBJ/user_ca_key \\\n\t\t\t    -I \"regress user key for $USER\" \\\n\t\t\t    $sign_opts $OBJ/cert_user_key_${ktype} ||\n\t\t\t\tfail \"couldn't sign cert_user_key_${ktype}\"\n\n\t\t\t${SSH} -i $OBJ/cert_user_key_${ktype} \\\n\t\t\t    -F $OBJ/ssh_proxy somehost true >/dev/null 2>&1\n\t\t\trc=$?\n\t\t\tif [ \"x$result\" = \"xsuccess\" ] ; then\n\t\t\t\tif [ $rc -ne 0 ]; then\n\t\t\t\t\tfail \"$ident failed unexpectedly\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ $rc -eq 0 ]; then\n\t\t\t\t\tfail \"$ident succeeded unexpectedly\"\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tdone\n}\n\ntest_one \"correct principal\"\tsuccess \"-n ${USER}\"\ntest_one \"host-certificate\"\tfailure \"-n ${USER} -h\"\ntest_one \"wrong principals\"\tfailure \"-n foo\"\ntest_one \"cert not yet valid\"\tfailure \"-n ${USER} -V20300101:20320101\"\ntest_one \"cert expired\"\t\tfailure \"-n ${USER} -V19800101:19900101\"\ntest_one \"cert valid interval\"\tsuccess \"-n ${USER} -V-1w:+2w\"\ntest_one \"wrong source-address\"\tfailure \"-n ${USER} -Osource-address=10.0.0.0/8\"\ntest_one \"force-command\"\tfailure \"-n ${USER} -Oforce-command=false\"\n\n# Behaviour is different here: TrustedUserCAKeys doesn't allow empty principals\ntest_one \"empty principals\"\tsuccess \"\" authorized_keys\ntest_one \"empty principals\"\tfailure \"\" TrustedUserCAKeys\n\n# Check explicitly-specified principals: an empty principals list in the cert\n# should always be refused.\n\n# AuthorizedPrincipalsFile\nrm -f $OBJ/authorized_keys_$USER\necho mekmitasdigoat > $OBJ/authorized_principals_$USER\ntest_one \"AuthorizedPrincipalsFile principals\" success \"-n mekmitasdigoat\" \\\n    TrustedUserCAKeys \"AuthorizedPrincipalsFile $OBJ/authorized_principals_%u\"\ntest_one \"AuthorizedPrincipalsFile no principals\" failure \"\" \\\n    TrustedUserCAKeys \"AuthorizedPrincipalsFile $OBJ/authorized_principals_%u\"\n\n# principals= key option\nrm -f $OBJ/authorized_principals_$USER\ntest_one \"principals key option principals\" success \"-n mekmitasdigoat\" \\\n    authorized_keys ',principals=\"mekmitasdigoat\"'\ntest_one \"principals key option no principals\" failure \"\" \\\n    authorized_keys ',principals=\"mekmitasdigoat\"'\n\n# command= options vs. force-command in key\ntest_one \"force-command match true\" success \\\n    \"-n ${USER} -Oforce-command=true\" \\\n    authorized_keys ',command=\"true\"'\ntest_one \"force-command match true\" failure \\\n    \"-n ${USER} -Oforce-command=false\" \\\n    authorized_keys ',command=\"false\"'\ntest_one \"force-command mismatch 1\" failure \\\n    \"-n ${USER} -Oforce-command=false\" \\\n    authorized_keys ',command=\"true\"'\ntest_one \"force-command mismatch 2\" failure \\\n    \"-n ${USER} -Oforce-command=true\" \\\n    authorized_keys ',command=\"false\"'\n\n# Wrong certificate\ncat $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy\nfor ktype in $PLAIN_TYPES ; do\n\tt=$(kname $ktype)\n\t# Self-sign\n\t${SSHKEYGEN} -q -s $OBJ/cert_user_key_${ktype} -I \\\n\t    \"regress user key for $USER\" \\\n\t    -n $USER $OBJ/cert_user_key_${ktype} ||\n\t\tfatal \"couldn't sign cert_user_key_${ktype}\"\n\tverbose \"$tid: user ${ktype} connect wrong cert\"\n\t${SSH} -i $OBJ/cert_user_key_${ktype} -F $OBJ/ssh_proxy \\\n\t    somehost true >/dev/null 2>&1\n\tif [ $? -eq 0 ]; then\n\t\tfail \"ssh cert connect $ident succeeded unexpectedly\"\n\tfi\ndone\n\nrm -f $OBJ/authorized_keys_$USER $OBJ/user_ca_key* $OBJ/cert_user_key*\nrm -f $OBJ/authorized_principals_$USER\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}