{
  "module_name": "netcat.c",
  "hash_id": "667ba6453314791bb43d746798079457dbad77603602d3b82cbc9ade520cce04",
  "original_prompt": "Ingested from openssh-9.6p1/regress/netcat.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <netinet/ip.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <netdb.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"atomicio.h\"\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#ifdef HAVE_ERR_H\n# include <err.h>\n#endif\n#ifdef HAVE_SYS_BYTEORDER_H\n# include <sys/byteorder.h>\n#endif\n\n \n#define timeout_connect netcat_timeout_connect\n\n \n#define IAC\t255\n#define DONT\t254\n#define DO\t253\n#define WONT\t252\n#define WILL\t251\n\n#ifndef SUN_LEN\n#define SUN_LEN(su) \\\n\t(sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))\n#endif\n\n#define PORT_MAX\t65535\n#define PORT_MAX_LEN\t6\n#define UNIX_DG_TMP_SOCKET_SIZE\t19\n\n#define POLL_STDIN 0\n#define POLL_NETOUT 1\n#define POLL_NETIN 2\n#define POLL_STDOUT 3\n#define BUFSIZE 16384\n\n \nint\tdflag;\t\t\t\t\t \nint\tFflag;\t\t\t\t\t \nunsigned int iflag;\t\t\t\t \nint\tkflag;\t\t\t\t\t \nint\tlflag;\t\t\t\t\t \nint\tNflag;\t\t\t\t\t \nint\tnflag;\t\t\t\t\t \nchar   *Pflag;\t\t\t\t\t \nchar   *pflag;\t\t\t\t\t \nint\trflag;\t\t\t\t\t \nchar   *sflag;\t\t\t\t\t \nint\ttflag;\t\t\t\t\t \nint\tuflag;\t\t\t\t\t \nint\tvflag;\t\t\t\t\t \nint\txflag;\t\t\t\t\t \nint\tzflag;\t\t\t\t\t \nint\tDflag;\t\t\t\t\t \nint\tIflag;\t\t\t\t\t \nint\tOflag;\t\t\t\t\t \nint\tSflag;\t\t\t\t\t \nint\tTflag = -1;\t\t\t\t \nint\trtableid = -1;\n\nint timeout = -1;\nint family = AF_UNSPEC;\nchar *portlist[PORT_MAX+1];\nchar *unix_dg_tmp_socket;\n\nvoid\tatelnet(int, unsigned char *, unsigned int);\nvoid\tbuild_ports(char *);\nvoid\thelp(void);\nint\tlocal_listen(char *, char *, struct addrinfo);\nvoid\treadwrite(int);\nvoid\tfdpass(int nfd) __attribute__((noreturn));\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\ttimeout_connect(int, const struct sockaddr *, socklen_t);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int, const char *);\nint\tudptest(int);\nint\tunix_bind(char *);\nint\tunix_connect(char *);\nint\tunix_listen(char *);\nvoid\tset_common_sockopts(int, int);\nint\tmap_tos(char *, int *);\nvoid\treport_connect(const struct sockaddr *, socklen_t);\nvoid\tusage(int);\nssize_t drainbuf(int, unsigned char *, size_t *);\nssize_t fillbuf(int, unsigned char *, size_t *);\n\n\nint\nmain(int argc, char *argv[])\n{\n\tint ch, s, ret, socksv;\n\tchar *host, *uport;\n\tstruct addrinfo hints;\n\tstruct servent *sv;\n\tsocklen_t len;\n\tstruct sockaddr_storage cliaddr;\n\tchar *proxy = NULL;\n\tconst char *errstr, *proxyhost = \"\", *proxyport = NULL;\n\tstruct addrinfo proxyhints;\n\tchar unix_dg_tmp_socket_buf[UNIX_DG_TMP_SOCKET_SIZE];\n\n\tret = 1;\n\ts = 0;\n\tsocksv = 5;\n\thost = NULL;\n\tuport = NULL;\n\tsv = NULL;\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\twhile ((ch = getopt(argc, argv,\n\t    \"46DdFhI:i:klNnO:P:p:rSs:tT:UuV:vw:X:x:z\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '4':\n\t\t\tfamily = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tfamily = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tfamily = AF_UNIX;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tif (strcasecmp(optarg, \"connect\") == 0)\n\t\t\t\tsocksv = -1;  \n\t\t\telse if (strcmp(optarg, \"4\") == 0)\n\t\t\t\tsocksv = 4;  \n\t\t\telse if (strcmp(optarg, \"5\") == 0)\n\t\t\t\tsocksv = 5;  \n\t\t\telse\n\t\t\t\terrx(1, \"unsupported proxy protocol\");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdflag = 1;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tFflag = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tiflag = strtonum(optarg, 0, UINT_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"interval %s: %s\", errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkflag = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlflag = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tNflag = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tPflag = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttflag = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tuflag = 1;\n\t\t\tbreak;\n#ifdef SO_RTABLE\n\t\tcase 'V':\n\t\t\trtableid = (int)strtonum(optarg, 0,\n\t\t\t    RT_TABLEID_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"rtable %s: %s\", errstr, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtonum(optarg, 0, INT_MAX / 1000, &errstr);\n\t\t\tif (errstr)\n\t\t\t\terrx(1, \"timeout %s: %s\", errstr, optarg);\n\t\t\ttimeout *= 1000;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txflag = 1;\n\t\t\tif ((proxy = strdup(optarg)) == NULL)\n\t\t\t\terrx(1, \"strdup\");\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tzflag = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tDflag = 1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tIflag = strtonum(optarg, 1, 65536 << 14, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\terrx(1, \"TCP receive window %s: %s\",\n\t\t\t\t    errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tOflag = strtonum(optarg, 1, 65536 << 14, &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\terrx(1, \"TCP send window %s: %s\",\n\t\t\t\t    errstr, optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tSflag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\terrstr = NULL;\n\t\t\terrno = 0;\n\t\t\tif (map_tos(optarg, &Tflag))\n\t\t\t\tbreak;\n\t\t\tif (strlen(optarg) > 1 && optarg[0] == '0' &&\n\t\t\t    optarg[1] == 'x')\n\t\t\t\tTflag = (int)strtol(optarg, NULL, 16);\n\t\t\telse\n\t\t\t\tTflag = (int)strtonum(optarg, 0, 255,\n\t\t\t\t    &errstr);\n\t\t\tif (Tflag < 0 || Tflag > 255 || errstr || errno)\n\t\t\t\terrx(1, \"illegal tos value %s\", optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(1);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\t \n\tif (argv[0] && !argv[1] && family == AF_UNIX) {\n\t\thost = argv[0];\n\t\tuport = NULL;\n\t} else if (argv[0] && !argv[1]) {\n\t\tif  (!lflag)\n\t\t\tusage(1);\n\t\tuport = argv[0];\n\t\thost = NULL;\n\t} else if (argv[0] && argv[1]) {\n\t\thost = argv[0];\n\t\tuport = argv[1];\n\t} else\n\t\tusage(1);\n\n\tif (lflag && sflag)\n\t\terrx(1, \"cannot use -s and -l\");\n\tif (lflag && pflag)\n\t\terrx(1, \"cannot use -p and -l\");\n\tif (lflag && zflag)\n\t\terrx(1, \"cannot use -z and -l\");\n\tif (!lflag && kflag)\n\t\terrx(1, \"must use -l with -k\");\n\n\t \n\tif ((family == AF_UNIX) && uflag && !lflag) {\n\t\tif (sflag) {\n\t\t\tunix_dg_tmp_socket = sflag;\n\t\t} else {\n\t\t\tstrlcpy(unix_dg_tmp_socket_buf, \"/tmp/nc.XXXXXXXXXX\",\n\t\t\t\tUNIX_DG_TMP_SOCKET_SIZE);\n\t\t\tif (mktemp(unix_dg_tmp_socket_buf) == NULL)\n\t\t\t\terr(1, \"mktemp\");\n\t\t\tunix_dg_tmp_socket = unix_dg_tmp_socket_buf;\n\t\t}\n\t}\n\n\t \n\tif (family != AF_UNIX) {\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = family;\n\t\thints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\thints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\tif (nflag)\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t}\n\n\tif (xflag) {\n\t\tif (uflag)\n\t\t\terrx(1, \"no proxy support for UDP mode\");\n\n\t\tif (lflag)\n\t\t\terrx(1, \"no proxy support for listen\");\n\n\t\tif (family == AF_UNIX)\n\t\t\terrx(1, \"no proxy support for unix sockets\");\n\n\t\t \n\t\tif (family == AF_INET6)\n\t\t\terrx(1, \"no proxy support for IPv6\");\n\n\t\tif (sflag)\n\t\t\terrx(1, \"no proxy support for local source address\");\n\n\t\tproxyhost = strsep(&proxy, \":\");\n\t\tproxyport = proxy;\n\n\t\tmemset(&proxyhints, 0, sizeof(struct addrinfo));\n\t\tproxyhints.ai_family = family;\n\t\tproxyhints.ai_socktype = SOCK_STREAM;\n\t\tproxyhints.ai_protocol = IPPROTO_TCP;\n\t\tif (nflag)\n\t\t\tproxyhints.ai_flags |= AI_NUMERICHOST;\n\t}\n\n\tif (lflag) {\n\t\tint connfd;\n\t\tret = 0;\n\n\t\tif (family == AF_UNIX) {\n\t\t\tif (uflag)\n\t\t\t\ts = unix_bind(host);\n\t\t\telse\n\t\t\t\ts = unix_listen(host);\n\t\t}\n\n\t\t \n\t\tfor (;;) {\n\t\t\tif (family != AF_UNIX)\n\t\t\t\ts = local_listen(host, uport, hints);\n\t\t\tif (s < 0)\n\t\t\t\terr(1, \"local_listen\");\n\t\t\t \n\t\t\tif (uflag && kflag)\n\t\t\t\treadwrite(s);\n\t\t\t \n\t\t\telse if (uflag && !kflag) {\n\t\t\t\tint rv, plen;\n\t\t\t\tchar buf[16384];\n\t\t\t\tstruct sockaddr_storage z;\n\n\t\t\t\tlen = sizeof(z);\n\t\t\t\tplen = 2048;\n\t\t\t\trv = recvfrom(s, buf, plen, MSG_PEEK,\n\t\t\t\t    (struct sockaddr *)&z, &len);\n\t\t\t\tif (rv < 0)\n\t\t\t\t\terr(1, \"recvfrom\");\n\n\t\t\t\trv = connect(s, (struct sockaddr *)&z, len);\n\t\t\t\tif (rv < 0)\n\t\t\t\t\terr(1, \"connect\");\n\n\t\t\t\tif (vflag)\n\t\t\t\t\treport_connect((struct sockaddr *)&z, len);\n\n\t\t\t\treadwrite(s);\n\t\t\t} else {\n\t\t\t\tlen = sizeof(cliaddr);\n\t\t\t\tconnfd = accept(s, (struct sockaddr *)&cliaddr,\n\t\t\t\t    &len);\n\t\t\t\tif (connfd == -1) {\n\t\t\t\t\t \n\t\t\t\t\terr(1, \"accept\");\n\t\t\t\t}\n\t\t\t\tif (vflag)\n\t\t\t\t\treport_connect((struct sockaddr *)&cliaddr, len);\n\n\t\t\t\treadwrite(connfd);\n\t\t\t\tclose(connfd);\n\t\t\t}\n\n\t\t\tif (family != AF_UNIX)\n\t\t\t\tclose(s);\n\t\t\telse if (uflag) {\n\t\t\t\tif (connect(s, NULL, 0) < 0)\n\t\t\t\t\terr(1, \"connect\");\n\t\t\t}\n\n\t\t\tif (!kflag)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (family == AF_UNIX) {\n\t\tret = 0;\n\n\t\tif ((s = unix_connect(host)) > 0 && !zflag) {\n\t\t\treadwrite(s);\n\t\t\tclose(s);\n\t\t} else\n\t\t\tret = 1;\n\n\t\tif (uflag)\n\t\t\tunlink(unix_dg_tmp_socket);\n\t\texit(ret);\n\n\t} else {\n\t\tint i = 0;\n\n\t\t \n\t\tbuild_ports(uport);\n\n\t\t \n\t\tfor (i = 0; portlist[i] != NULL; i++) {\n\t\t\tif (s)\n\t\t\t\tclose(s);\n\n\t\t\tif (xflag)\n\t\t\t\ts = socks_connect(host, portlist[i], hints,\n\t\t\t\t    proxyhost, proxyport, proxyhints, socksv,\n\t\t\t\t    Pflag);\n\t\t\telse\n\t\t\t\ts = remote_connect(host, portlist[i], hints);\n\n\t\t\tif (s < 0)\n\t\t\t\tcontinue;\n\n\t\t\tret = 0;\n\t\t\tif (vflag || zflag) {\n\t\t\t\t \n\t\t\t\tif (uflag) {\n\t\t\t\t\tif (udptest(s) == -1) {\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (nflag)\n\t\t\t\t\tsv = NULL;\n\t\t\t\telse {\n\t\t\t\t\tsv = getservbyport(\n\t\t\t\t\t    ntohs(atoi(portlist[i])),\n\t\t\t\t\t    uflag ? \"udp\" : \"tcp\");\n\t\t\t\t}\n\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Connection to %s %s port [%s/%s] \"\n\t\t\t\t    \"succeeded!\\n\", host, portlist[i],\n\t\t\t\t    uflag ? \"udp\" : \"tcp\",\n\t\t\t\t    sv ? sv->s_name : \"*\");\n\t\t\t}\n\t\t\tif (Fflag)\n\t\t\t\tfdpass(s);\n\t\t\telse if (!zflag)\n\t\t\t\treadwrite(s);\n\t\t}\n\t}\n\n\tif (s)\n\t\tclose(s);\n\n\texit(ret);\n}\n\n \nint\nunix_bind(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\t \n\tif ((s = socket(AF_UNIX, uflag ? SOCK_DGRAM : SOCK_STREAM,\n\t     0)) < 0)\n\t\treturn (-1);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\n\tif (bind(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}\n\n \nint\nunix_connect(char *path)\n{\n\tstruct sockaddr_un sun_sa;\n\tint s;\n\n\tif (uflag) {\n\t\tif ((s = unix_bind(unix_dg_tmp_socket)) < 0)\n\t\t\treturn (-1);\n\t} else {\n\t\tif ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\t\treturn (-1);\n\t}\n\t(void)fcntl(s, F_SETFD, FD_CLOEXEC);\n\n\tmemset(&sun_sa, 0, sizeof(struct sockaddr_un));\n\tsun_sa.sun_family = AF_UNIX;\n\n\tif (strlcpy(sun_sa.sun_path, path, sizeof(sun_sa.sun_path)) >=\n\t    sizeof(sun_sa.sun_path)) {\n\t\tclose(s);\n\t\terrno = ENAMETOOLONG;\n\t\treturn (-1);\n\t}\n\tif (connect(s, (struct sockaddr *)&sun_sa, SUN_LEN(&sun_sa)) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n\n}\n\n \nint\nunix_listen(char *path)\n{\n\tint s;\n\tif ((s = unix_bind(path)) < 0)\n\t\treturn (-1);\n\n\tif (listen(s, 5) < 0) {\n\t\tclose(s);\n\t\treturn (-1);\n\t}\n\treturn (s);\n}\n\n \nint\nremote_connect(const char *host, const char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, error;\n#if defined(SO_RTABLE) || defined(SO_BINDANY)\n\tint on = 1;\n#endif\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n\t\t \n\t\tif (sflag || pflag) {\n\t\t\tstruct addrinfo ahints, *ares;\n\n#ifdef SO_BINDANY\n\t\t\t \n\t\t\tsetsockopt(s, SOL_SOCKET, SO_BINDANY, &on, sizeof(on));\n#endif\n\t\t\tmemset(&ahints, 0, sizeof(struct addrinfo));\n\t\t\tahints.ai_family = res0->ai_family;\n\t\t\tahints.ai_socktype = uflag ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tahints.ai_protocol = uflag ? IPPROTO_UDP : IPPROTO_TCP;\n\t\t\tahints.ai_flags = AI_PASSIVE;\n\t\t\tif ((error = getaddrinfo(sflag, pflag, &ahints, &ares)))\n\t\t\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\t\t\tif (bind(s, (struct sockaddr *)ares->ai_addr,\n\t\t\t    ares->ai_addrlen) < 0)\n\t\t\t\terr(1, \"bind failed\");\n\t\t\tfreeaddrinfo(ares);\n\t\t}\n\n\t\tset_common_sockopts(s, res0->ai_family);\n\n\t\tif (timeout_connect(s, res0->ai_addr, res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\t\telse if (vflag)\n\t\t\twarn(\"connect to %s port %s (%s) failed\", host, port,\n\t\t\t    uflag ? \"udp\" : \"tcp\");\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}\n\nint\ntimeout_connect(int s, const struct sockaddr *name, socklen_t namelen)\n{\n\tstruct pollfd pfd;\n\tsocklen_t optlen;\n\tint flags = 0, optval;\n\tint ret;\n\n\tif (timeout != -1) {\n\t\tflags = fcntl(s, F_GETFL, 0);\n\t\tif (fcntl(s, F_SETFL, flags | O_NONBLOCK) == -1)\n\t\t\terr(1, \"set non-blocking mode\");\n\t}\n\n\tif ((ret = connect(s, name, namelen)) != 0 && errno == EINPROGRESS) {\n\t\tpfd.fd = s;\n\t\tpfd.events = POLLOUT;\n\t\tif ((ret = poll(&pfd, 1, timeout)) == 1) {\n\t\t\toptlen = sizeof(optval);\n\t\t\tif ((ret = getsockopt(s, SOL_SOCKET, SO_ERROR,\n\t\t\t    &optval, &optlen)) == 0) {\n\t\t\t\terrno = optval;\n\t\t\t\tret = optval == 0 ? 0 : -1;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t\tret = -1;\n\t\t} else\n\t\t\terr(1, \"poll failed\");\n\t}\n\n\tif (timeout != -1 && fcntl(s, F_SETFL, flags) == -1)\n\t\terr(1, \"restoring flags\");\n\n\treturn (ret);\n}\n\n \nint\nlocal_listen(char *host, char *port, struct addrinfo hints)\n{\n\tstruct addrinfo *res, *res0;\n\tint s, ret, x = 1;\n\tint error;\n\n\t \n\thints.ai_flags |= AI_PASSIVE;\n\n\t \n\tif (host == NULL && hints.ai_family == AF_UNSPEC)\n\t\thints.ai_family = AF_INET;\n\n\tif ((error = getaddrinfo(host, port, &hints, &res)))\n\t\terrx(1, \"getaddrinfo: %s\", gai_strerror(error));\n\n\tres0 = res;\n\tdo {\n\t\tif ((s = socket(res0->ai_family, res0->ai_socktype,\n\t\t    res0->ai_protocol)) < 0)\n\t\t\tcontinue;\n\n#ifdef SO_RTABLE\n\t\tif (rtableid >= 0 && (setsockopt(s, SOL_SOCKET, SO_RTABLE,\n\t\t    &rtableid, sizeof(rtableid)) == -1))\n\t\t\terr(1, \"setsockopt SO_RTABLE\");\n#endif\n#ifdef SO_REUSEPORT\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEPORT\");\n#endif\n#ifdef SO_REUSEADDR\n\t\tret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &x, sizeof(x));\n\t\tif (ret == -1)\n\t\t\terr(1, \"setsockopt SO_REUSEADDR\");\n#endif\n\t\tset_common_sockopts(s, res0->ai_family);\n\n\t\tif (bind(s, (struct sockaddr *)res0->ai_addr,\n\t\t    res0->ai_addrlen) == 0)\n\t\t\tbreak;\n\n\t\tclose(s);\n\t\ts = -1;\n\t} while ((res0 = res0->ai_next) != NULL);\n\n\tif (!uflag && s != -1) {\n\t\tif (listen(s, 1) < 0)\n\t\t\terr(1, \"listen\");\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn (s);\n}\n\n \nvoid\nreadwrite(int net_fd)\n{\n\tstruct pollfd pfd[4];\n\tint stdin_fd = STDIN_FILENO;\n\tint stdout_fd = STDOUT_FILENO;\n\tunsigned char netinbuf[BUFSIZE];\n\tsize_t netinbufpos = 0;\n\tunsigned char stdinbuf[BUFSIZE];\n\tsize_t stdinbufpos = 0;\n\tint n, num_fds;\n\tssize_t ret;\n\n\t \n\tif (dflag)\n\t\tstdin_fd = -1;\n\n\t \n\tpfd[POLL_STDIN].fd = stdin_fd;\n\tpfd[POLL_STDIN].events = POLLIN;\n\n\t \n\tpfd[POLL_NETOUT].fd = net_fd;\n\tpfd[POLL_NETOUT].events = 0;\n\n\t \n\tpfd[POLL_NETIN].fd = net_fd;\n\tpfd[POLL_NETIN].events = POLLIN;\n\n\t \n\tpfd[POLL_STDOUT].fd = stdout_fd;\n\tpfd[POLL_STDOUT].events = 0;\n\n\twhile (1) {\n\t\t \n\t\tif (pfd[POLL_STDIN].fd == -1 && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (pfd[POLL_NETOUT].fd == -1 && pfd[POLL_STDOUT].fd == -1) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (lflag && pfd[POLL_NETIN].fd == -1\n\t\t    && stdinbufpos == 0 && netinbufpos == 0) {\n\t\t\tclose(net_fd);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (iflag)\n\t\t\tsleep(iflag);\n\n\t\t \n\t\tnum_fds = poll(pfd, 4, timeout);\n\n\t\t \n\t\tif (num_fds == -1) {\n\t\t\tclose(net_fd);\n\t\t\terr(1, \"polling error\");\n\t\t}\n\n\t\t \n\t\tif (num_fds == 0)\n\t\t\treturn;\n\n\t\t \n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tif (pfd[n].revents & (POLLERR|POLLNVAL)) {\n\t\t\t\tpfd[n].fd = -1;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (pfd[POLL_STDIN].events & POLLIN &&\n\t\t    pfd[POLL_STDIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_STDIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\n\t\tif (pfd[POLL_NETIN].events & POLLIN &&\n\t\t    pfd[POLL_NETIN].revents & POLLHUP &&\n\t\t    ! (pfd[POLL_NETIN].revents & POLLIN))\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\n\t\tif (pfd[POLL_NETOUT].revents & POLLHUP) {\n\t\t\tif (Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t \n\t\tif (pfd[POLL_STDOUT].revents & POLLHUP)\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t \n\t\tif (pfd[POLL_NETOUT].fd == -1)\n\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t \n\t\tif (pfd[POLL_STDOUT].fd == -1) {\n\t\t\tif (pfd[POLL_NETIN].fd != -1)\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t}\n\n\t\t \n\t\tif (pfd[POLL_STDIN].revents & POLLIN && stdinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_STDIN].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\t \n\t\t\tif (ret == 0 || ret == -1)\n\t\t\t\tpfd[POLL_STDIN].fd = -1;\n\t\t\t \n\t\t\tif (stdinbufpos > 0)\n\t\t\t\tpfd[POLL_NETOUT].events = POLLOUT;\n\t\t\t \n\t\t\tif (stdinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = 0;\n\t\t}\n\t\t \n\t\tif (pfd[POLL_NETOUT].revents & POLLOUT && stdinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_NETOUT].fd, stdinbuf,\n\t\t\t    &stdinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t\t \n\t\t\tif (stdinbufpos == 0)\n\t\t\t\tpfd[POLL_NETOUT].events = 0;\n\t\t\t \n\t\t\tif (stdinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_STDIN].events = POLLIN;\n\t\t}\n\t\t \n\t\tif (pfd[POLL_NETIN].revents & POLLIN && netinbufpos < BUFSIZE) {\n\t\t\tret = fillbuf(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t \n\t\t\tif (ret == 0) {\n\t\t\t\tshutdown(pfd[POLL_NETIN].fd, SHUT_RD);\n\t\t\t\tpfd[POLL_NETIN].fd = -1;\n\t\t\t}\n\t\t\t \n\t\t\tif (netinbufpos > 0)\n\t\t\t\tpfd[POLL_STDOUT].events = POLLOUT;\n\t\t\t \n\t\t\tif (netinbufpos == BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = 0;\n\t\t\t \n\t\t\tif (tflag)\n\t\t\t\tatelnet(pfd[POLL_NETIN].fd, netinbuf,\n\t\t\t\t    netinbufpos);\n\t\t}\n\t\t \n\t\tif (pfd[POLL_STDOUT].revents & POLLOUT && netinbufpos > 0) {\n\t\t\tret = drainbuf(pfd[POLL_STDOUT].fd, netinbuf,\n\t\t\t    &netinbufpos);\n\t\t\tif (ret == -1)\n\t\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t\t \n\t\t\tif (netinbufpos == 0)\n\t\t\t\tpfd[POLL_STDOUT].events = 0;\n\t\t\t \n\t\t\tif (netinbufpos < BUFSIZE)\n\t\t\t\tpfd[POLL_NETIN].events = POLLIN;\n\t\t}\n\n\t\t \n\t\tif (pfd[POLL_STDIN].fd == -1 && stdinbufpos == 0) {\n\t\t\tif (pfd[POLL_NETOUT].fd != -1 && Nflag)\n\t\t\t\tshutdown(pfd[POLL_NETOUT].fd, SHUT_WR);\n\t\t\tpfd[POLL_NETOUT].fd = -1;\n\t\t}\n\t\t \n\t\tif (pfd[POLL_NETIN].fd == -1 && netinbufpos == 0) {\n\t\t\tpfd[POLL_STDOUT].fd = -1;\n\t\t}\n\t}\n}\n\nssize_t\ndrainbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tssize_t n;\n\tssize_t adjust;\n\n\tn = write(fd, buf, *bufpos);\n\t \n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t \n\tadjust = *bufpos - n;\n\tif (adjust > 0)\n\t\tmemmove(buf, buf + n, adjust);\n\t*bufpos -= n;\n\treturn n;\n}\n\n\nssize_t\nfillbuf(int fd, unsigned char *buf, size_t *bufpos)\n{\n\tsize_t num = BUFSIZE - *bufpos;\n\tssize_t n;\n\n\tn = read(fd, buf + *bufpos, num);\n\t \n\tif (n == -1 && (errno == EAGAIN || errno == EINTR))\n\t\tn = -2;\n\tif (n <= 0)\n\t\treturn n;\n\t*bufpos += n;\n\treturn n;\n}\n\n \nvoid\nfdpass(int nfd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tstruct pollfd pfd;\n\tssize_t r;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&nfd;\n\tmsg.msg_accrightslen = sizeof(nfd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = nfd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tbzero(&pfd, sizeof(pfd));\n\tpfd.fd = STDOUT_FILENO;\n\tpfd.events = POLLOUT;\n\tfor (;;) {\n\t\tr = sendmsg(STDOUT_FILENO, &msg, 0);\n\t\tif (r == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tif (poll(&pfd, 1, -1) == -1)\n\t\t\t\t\terr(1, \"poll\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr(1, \"sendmsg\");\n\t\t} else if (r != 1)\n\t\t\terrx(1, \"sendmsg: unexpected return value %zd\", r);\n\t\telse\n\t\t\tbreak;\n\t}\n\texit(0);\n#else\n\terrx(1, \"%s: file descriptor passing not supported\", __func__);\n#endif\n}\n\n \nvoid\natelnet(int nfd, unsigned char *buf, unsigned int size)\n{\n\tunsigned char *p, *end;\n\tunsigned char obuf[4];\n\n\tif (size < 3)\n\t\treturn;\n\tend = buf + size - 2;\n\n\tfor (p = buf; p < end; p++) {\n\t\tif (*p != IAC)\n\t\t\tcontinue;\n\n\t\tobuf[0] = IAC;\n\t\tp++;\n\t\tif ((*p == WILL) || (*p == WONT))\n\t\t\tobuf[1] = DONT;\n\t\telse if ((*p == DO) || (*p == DONT))\n\t\t\tobuf[1] = WONT;\n\t\telse\n\t\t\tcontinue;\n\n\t\tp++;\n\t\tobuf[2] = *p;\n\t\tif (atomicio(vwrite, nfd, obuf, 3) != 3)\n\t\t\twarn(\"Write Error!\");\n\t}\n}\n\n \nvoid\nbuild_ports(char *p)\n{\n\tconst char *errstr;\n\tchar *n;\n\tint hi, lo, cp;\n\tint x = 0;\n\n\tif ((n = strchr(p, '-')) != NULL) {\n\t\t*n = '\\0';\n\t\tn++;\n\n\t\t \n\t\thi = strtonum(n, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, n);\n\t\tlo = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\n\t\tif (lo > hi) {\n\t\t\tcp = hi;\n\t\t\thi = lo;\n\t\t\tlo = cp;\n\t\t}\n\n\t\t \n\t\tfor (cp = lo; cp <= hi; cp++) {\n\t\t\tportlist[x] = calloc(1, PORT_MAX_LEN);\n\t\t\tif (portlist[x] == NULL)\n\t\t\t\terrx(1, \"calloc\");\n\t\t\tsnprintf(portlist[x], PORT_MAX_LEN, \"%d\", cp);\n\t\t\tx++;\n\t\t}\n\n\t\t \n\t\tif (rflag) {\n\t\t\tint y;\n\t\t\tchar *c;\n\n\t\t\tfor (x = 0; x <= (hi - lo); x++) {\n\t\t\t\ty = (arc4random() & 0xFFFF) % (hi - lo);\n\t\t\t\tc = portlist[x];\n\t\t\t\tportlist[x] = portlist[y];\n\t\t\t\tportlist[y] = c;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thi = strtonum(p, 1, PORT_MAX, &errstr);\n\t\tif (errstr)\n\t\t\terrx(1, \"port number %s: %s\", errstr, p);\n\t\tportlist[0] = strdup(p);\n\t\tif (portlist[0] == NULL)\n\t\t\terrx(1, \"strdup\");\n\t}\n}\n\n \nint\nudptest(int s)\n{\n\tint i, ret;\n\n\tfor (i = 0; i <= 3; i++) {\n\t\tif (write(s, \"X\", 1) == 1)\n\t\t\tret = 1;\n\t\telse\n\t\t\tret = -1;\n\t}\n\treturn (ret);\n}\n\nvoid\nset_common_sockopts(int s, int af)\n{\n\tint x = 1;\n\n#ifdef TCP_MD5SIG\n\tif (Sflag) {\n\t\tif (setsockopt(s, IPPROTO_TCP, TCP_MD5SIG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#endif\n\tif (Dflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_DEBUG,\n\t\t\t&x, sizeof(x)) == -1)\n\t\t\terr(1, \"setsockopt\");\n\t}\n#if defined(IP_TOS) && defined(IPV6_TCLASS)\n\tif (Tflag != -1) {\n\t\tint proto, option;\n\n\t\tif (af == AF_INET6) {\n\t\t\tproto = IPPROTO_IPV6;\n\t\t\toption = IPV6_TCLASS;\n\t\t} else {\n\t\t\tproto = IPPROTO_IP;\n\t\t\toption = IP_TOS;\n\t\t}\n\n\t\tif (setsockopt(s, proto, option, &Tflag, sizeof(Tflag)) == -1)\n\t\t\terr(1, \"set IP ToS\");\n\t}\n#endif\n\tif (Iflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n\t\t    &Iflag, sizeof(Iflag)) == -1)\n\t\t\terr(1, \"set TCP receive buffer size\");\n\t}\n\tif (Oflag) {\n\t\tif (setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n\t\t    &Oflag, sizeof(Oflag)) == -1)\n\t\t\terr(1, \"set TCP send buffer size\");\n\t}\n}\n\nint\nmap_tos(char *s, int *val)\n{\n#ifdef IP_TOS\n\t \n\tconst struct toskeywords {\n\t\tconst char\t*keyword;\n\t\tint\t\t val;\n\t} *t, toskeywords[] = {\n\t\t{ \"af11\",\t\tIPTOS_DSCP_AF11 },\n\t\t{ \"af12\",\t\tIPTOS_DSCP_AF12 },\n\t\t{ \"af13\",\t\tIPTOS_DSCP_AF13 },\n\t\t{ \"af21\",\t\tIPTOS_DSCP_AF21 },\n\t\t{ \"af22\",\t\tIPTOS_DSCP_AF22 },\n\t\t{ \"af23\",\t\tIPTOS_DSCP_AF23 },\n\t\t{ \"af31\",\t\tIPTOS_DSCP_AF31 },\n\t\t{ \"af32\",\t\tIPTOS_DSCP_AF32 },\n\t\t{ \"af33\",\t\tIPTOS_DSCP_AF33 },\n\t\t{ \"af41\",\t\tIPTOS_DSCP_AF41 },\n\t\t{ \"af42\",\t\tIPTOS_DSCP_AF42 },\n\t\t{ \"af43\",\t\tIPTOS_DSCP_AF43 },\n\t\t{ \"critical\",\t\tIPTOS_PREC_CRITIC_ECP },\n\t\t{ \"cs0\",\t\tIPTOS_DSCP_CS0 },\n\t\t{ \"cs1\",\t\tIPTOS_DSCP_CS1 },\n\t\t{ \"cs2\",\t\tIPTOS_DSCP_CS2 },\n\t\t{ \"cs3\",\t\tIPTOS_DSCP_CS3 },\n\t\t{ \"cs4\",\t\tIPTOS_DSCP_CS4 },\n\t\t{ \"cs5\",\t\tIPTOS_DSCP_CS5 },\n\t\t{ \"cs6\",\t\tIPTOS_DSCP_CS6 },\n\t\t{ \"cs7\",\t\tIPTOS_DSCP_CS7 },\n\t\t{ \"ef\",\t\t\tIPTOS_DSCP_EF },\n\t\t{ \"inetcontrol\",\tIPTOS_PREC_INTERNETCONTROL },\n\t\t{ \"lowdelay\",\t\tIPTOS_LOWDELAY },\n\t\t{ \"netcontrol\",\t\tIPTOS_PREC_NETCONTROL },\n\t\t{ \"reliability\",\tIPTOS_RELIABILITY },\n\t\t{ \"throughput\",\t\tIPTOS_THROUGHPUT },\n\t\t{ NULL, \t\t-1 },\n\t};\n\n\tfor (t = toskeywords; t->keyword != NULL; t++) {\n\t\tif (strcmp(s, t->keyword) == 0) {\n\t\t\t*val = t->val;\n\t\t\treturn (1);\n\t\t}\n\t}\n#endif\n\n\treturn (0);\n}\n\nvoid\nreport_connect(const struct sockaddr *sa, socklen_t salen)\n{\n\tchar remote_host[NI_MAXHOST];\n\tchar remote_port[NI_MAXSERV];\n\tint herr;\n\tint flags = NI_NUMERICSERV;\n\t\n\tif (nflag)\n\t\tflags |= NI_NUMERICHOST;\n\t\n\tif ((herr = getnameinfo(sa, salen,\n\t    remote_host, sizeof(remote_host),\n\t    remote_port, sizeof(remote_port),\n\t    flags)) != 0) {\n\t\tif (herr == EAI_SYSTEM)\n\t\t\terr(1, \"getnameinfo\");\n\t\telse\n\t\t\terrx(1, \"getnameinfo: %s\", gai_strerror(herr));\n\t}\n\t\n\tfprintf(stderr,\n\t    \"Connection from %s %s \"\n\t    \"received!\\n\", remote_host, remote_port);\n}\n\nvoid\nhelp(void)\n{\n\tusage(0);\n\tfprintf(stderr, \"\\tCommand Summary:\\n\\\n\t\\t-4\t\tUse IPv4\\n\\\n\t\\t-6\t\tUse IPv6\\n\\\n\t\\t-D\t\tEnable the debug socket option\\n\\\n\t\\t-d\t\tDetach from stdin\\n\\\n\t\\t-F\t\tPass socket fd\\n\\\n\t\\t-h\t\tThis help text\\n\\\n\t\\t-I length\tTCP receive buffer length\\n\\\n\t\\t-i secs\\t\tDelay interval for lines sent, ports scanned\\n\\\n\t\\t-k\t\tKeep inbound sockets open for multiple connects\\n\\\n\t\\t-l\t\tListen mode, for inbound connects\\n\\\n\t\\t-N\t\tShutdown the network socket after EOF on stdin\\n\\\n\t\\t-n\t\tSuppress name/port resolutions\\n\\\n\t\\t-O length\tTCP send buffer length\\n\\\n\t\\t-P proxyuser\\tUsername for proxy authentication\\n\\\n\t\\t-p port\\t\tSpecify local port for remote connects\\n\\\n\t\\t-r\t\tRandomize remote ports\\n\\\n\t\\t-S\t\tEnable the TCP MD5 signature option\\n\\\n\t\\t-s addr\\t\tLocal source address\\n\\\n\t\\t-T toskeyword\\tSet IP Type of Service\\n\\\n\t\\t-t\t\tAnswer TELNET negotiation\\n\\\n\t\\t-U\t\tUse UNIX domain socket\\n\\\n\t\\t-u\t\tUDP mode\\n\\\n\t\\t-V rtable\tSpecify alternate routing table\\n\\\n\t\\t-v\t\tVerbose\\n\\\n\t\\t-w secs\\t\tTimeout for connects and final net reads\\n\\\n\t\\t-X proto\tProxy protocol: \\\"4\\\", \\\"5\\\" (SOCKS) or \\\"connect\\\"\\n\\\n\t\\t-x addr[:port]\\tSpecify proxy address and port\\n\\\n\t\\t-z\t\tZero-I/O mode [used for scanning]\\n\\\n\tPort numbers can be individual or ranges: lo-hi [inclusive]\\n\");\n\texit(1);\n}\n\nvoid\nusage(int ret)\n{\n\tfprintf(stderr,\n\t    \"usage: nc [-46DdFhklNnrStUuvz] [-I length] [-i interval] [-O length]\\n\"\n\t    \"\\t  [-P proxy_username] [-p source_port] [-s source] [-T toskeyword]\\n\"\n\t    \"\\t  [-V rtable] [-w timeout] [-X proxy_protocol]\\n\"\n\t    \"\\t  [-x proxy_address[:port]] [destination] [port]\\n\");\n\tif (ret)\n\t\texit(1);\n}\n\n/* *** src/usr.bin/nc/socks.c *** */\n\n\n/*\t$OpenBSD: socks.c,v 1.20 2012/03/08 09:56:28 espie Exp $\t*/\n\n/*\n * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.\n * Copyright (c) 2004, 2005 Damien Miller.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <resolv.h>\n\n#define SOCKS_PORT\t\"1080\"\n#define HTTP_PROXY_PORT\t\"3128\"\n#define HTTP_MAXHDRS\t64\n#define SOCKS_V5\t5\n#define SOCKS_V4\t4\n#define SOCKS_NOAUTH\t0\n#define SOCKS_NOMETHOD\t0xff\n#define SOCKS_CONNECT\t1\n#define SOCKS_IPV4\t1\n#define SOCKS_DOMAIN\t3\n#define SOCKS_IPV6\t4\n\nint\tremote_connect(const char *, const char *, struct addrinfo);\nint\tsocks_connect(const char *, const char *, struct addrinfo,\n\t    const char *, const char *, struct addrinfo, int,\n\t    const char *);\n\nstatic int\ndecode_addrport(const char *h, const char *p, struct sockaddr *addr,\n    socklen_t addrlen, int v4only, int numeric)\n{\n\tint r;\n\tstruct addrinfo hints, *res;\n\n\tbzero(&hints, sizeof(hints));\n\thints.ai_family = v4only ? PF_INET : PF_UNSPEC;\n\thints.ai_flags = numeric ? AI_NUMERICHOST : 0;\n\thints.ai_socktype = SOCK_STREAM;\n\tr = getaddrinfo(h, p, &hints, &res);\n\t/* Don't fatal when attempting to convert a numeric address */\n\tif (r != 0) {\n\t\tif (!numeric) {\n\t\t\terrx(1, \"getaddrinfo(\\\"%.64s\\\", \\\"%.64s\\\"): %s\", h, p,\n\t\t\t    gai_strerror(r));\n\t\t}\n\t\treturn (-1);\n\t}\n\tif (addrlen < res->ai_addrlen) {\n\t\tfreeaddrinfo(res);\n\t\terrx(1, \"internal error: addrlen < res->ai_addrlen\");\n\t}\n\tmemcpy(addr, res->ai_addr, res->ai_addrlen);\n\tfreeaddrinfo(res);\n\treturn (0);\n}\n\nstatic int\nproxy_read_line(int fd, char *buf, size_t bufsz)\n{\n\tsize_t off;\n\n\tfor(off = 0;;) {\n\t\tif (off >= bufsz)\n\t\t\terrx(1, \"proxy read too long\");\n\t\tif (atomicio(read, fd, buf + off, 1) != 1)\n\t\t\terr(1, \"proxy read\");\n\t\t \n\t\tif (buf[off] == '\\r')\n\t\t\tcontinue;\n\t\tif (buf[off] == '\\n') {\n\t\t\tbuf[off] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t}\n\treturn (off);\n}\n\nstatic const char *\ngetproxypass(const char *proxyuser, const char *proxyhost)\n{\n\tchar prompt[512];\n\tstatic char pw[256];\n\n\tsnprintf(prompt, sizeof(prompt), \"Proxy password for %s@%s: \",\n\t   proxyuser, proxyhost);\n\tif (readpassphrase(prompt, pw, sizeof(pw), RPP_REQUIRE_TTY) == NULL)\n\t\terrx(1, \"Unable to read proxy passphrase\");\n\treturn (pw);\n}\n\nint\nsocks_connect(const char *host, const char *port,\n    struct addrinfo hints __attribute__ ((__unused__)),\n    const char *proxyhost, const char *proxyport, struct addrinfo proxyhints,\n    int socksv, const char *proxyuser)\n{\n\tint proxyfd, r, authretry = 0;\n\tsize_t hlen, wlen = 0;\n\tunsigned char buf[1024];\n\tsize_t cnt;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)&addr;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&addr;\n\tin_port_t serverport;\n\tconst char *proxypass = NULL;\n\n\tif (proxyport == NULL)\n\t\tproxyport = (socksv == -1) ? HTTP_PROXY_PORT : SOCKS_PORT;\n\n\t \n\tif (decode_addrport(\"0.0.0.0\", port, (struct sockaddr *)&addr,\n\t    sizeof(addr), 1, 1) == -1)\n\t\terrx(1, \"unknown port \\\"%.64s\\\"\", port);\n\tserverport = in4->sin_port;\n\n again:\n\tif (authretry++ > 3)\n\t\terrx(1, \"Too many authentication failures\");\n\n\tproxyfd = remote_connect(proxyhost, proxyport, proxyhints);\n\n\tif (proxyfd < 0)\n\t\treturn (-1);\n\n\tif (socksv == 5) {\n\t\tif (decode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 0, 1) == -1)\n\t\t\taddr.ss_family = 0;  \n\n\t\t \n\t\tbuf[0] = SOCKS_V5;\n\t\tbuf[1] = 1;\n\t\tbuf[2] = SOCKS_NOAUTH;\n\t\tcnt = atomicio(vwrite, proxyfd, buf, 3);\n\t\tif (cnt != 3)\n\t\t\terr(1, \"write failed (%zu/3)\", cnt);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 2);\n\t\tif (cnt != 2)\n\t\t\terr(1, \"read failed (%zu/3)\", cnt);\n\n\t\tif (buf[1] == SOCKS_NOMETHOD)\n\t\t\terrx(1, \"authentication method negotiation failed\");\n\n\t\tswitch (addr.ss_family) {\n\t\tcase 0:\n\t\t\t \n\n\t\t\t \n\t\t\thlen = strlen(host);\n\t\t\tif (hlen > 255)\n\t\t\t\terrx(1, \"host name too long for SOCKS5\");\n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_DOMAIN;\n\t\t\tbuf[4] = hlen;\n\t\t\tmemcpy(buf + 5, host, hlen);\t\t\t\n\t\t\tmemcpy(buf + 5 + hlen, &serverport, sizeof serverport);\n\t\t\twlen = 7 + hlen;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\t \n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV4;\n\t\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\t\tmemcpy(buf + 8, &in4->sin_port, sizeof in4->sin_port);\n\t\t\twlen = 10;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t \n\t\t\tbuf[0] = SOCKS_V5;\n\t\t\tbuf[1] = SOCKS_CONNECT;\n\t\t\tbuf[2] = 0;\n\t\t\tbuf[3] = SOCKS_IPV6;\n\t\t\tmemcpy(buf + 4, &in6->sin6_addr, sizeof in6->sin6_addr);\n\t\t\tmemcpy(buf + 20, &in6->sin6_port,\n\t\t\t    sizeof in6->sin6_port);\n\t\t\twlen = 22;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"internal error: silly AF\");\n\t\t}\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 4);\n\t\tif (cnt != 4)\n\t\t\terr(1, \"read failed (%zu/4)\", cnt);\n\t\tif (buf[1] != 0)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t\tswitch (buf[3]) {\n\t\tcase SOCKS_IPV4:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 6);\n\t\t\tif (cnt != 6)\n\t\t\t\terr(1, \"read failed (%zu/6)\", cnt);\n\t\t\tbreak;\n\t\tcase SOCKS_IPV6:\n\t\t\tcnt = atomicio(read, proxyfd, buf + 4, 18);\n\t\t\tif (cnt != 18)\n\t\t\t\terr(1, \"read failed (%zu/18)\", cnt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrx(1, \"connection failed, unsupported address type\");\n\t\t}\n\t} else if (socksv == 4) {\n\t\t \n\t\tdecode_addrport(host, port, (struct sockaddr *)&addr,\n\t\t    sizeof(addr), 1, 0);\n\n\t\t \n\t\tbuf[0] = SOCKS_V4;\n\t\tbuf[1] = SOCKS_CONNECT;\t \n\t\tmemcpy(buf + 2, &in4->sin_port, sizeof in4->sin_port);\n\t\tmemcpy(buf + 4, &in4->sin_addr, sizeof in4->sin_addr);\n\t\tbuf[8] = 0;\t \n\t\twlen = 9;\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, wlen);\n\t\tif (cnt != wlen)\n\t\t\terr(1, \"write failed (%zu/%zu)\", cnt, wlen);\n\n\t\tcnt = atomicio(read, proxyfd, buf, 8);\n\t\tif (cnt != 8)\n\t\t\terr(1, \"read failed (%zu/8)\", cnt);\n\t\tif (buf[1] != 90)\n\t\t\terrx(1, \"connection failed, SOCKS error %d\", buf[1]);\n\t} else if (socksv == -1) {\n\t\t \n\n\t\t \n\t\tif (strcspn(host, \"\\r\\n\\t []:\") != strlen(host))\n\t\t\terrx(1, \"Invalid hostname\");\n\n\t\t \n\t\tif (strchr(host, ':') != NULL) {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT [%s]:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t} else {\n\t\t\tr = snprintf(buf, sizeof(buf),\n\t\t\t    \"CONNECT %s:%d HTTP/1.0\\r\\n\",\n\t\t\t    host, ntohs(serverport));\n\t\t}\n\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\terrx(1, \"hostname too long\");\n\t\tr = strlen(buf);\n\n\t\tcnt = atomicio(vwrite, proxyfd, buf, r);\n\t\tif (cnt != (size_t)r)\n\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\n\t\tif (authretry > 1) {\n\t\t\tchar resp[1024];\n\n\t\t\tproxypass = getproxypass(proxyuser, proxyhost);\n\t\t\tr = snprintf(buf, sizeof(buf), \"%s:%s\",\n\t\t\t    proxyuser, proxypass);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf) ||\n\t\t\t    b64_ntop(buf, strlen(buf), resp,\n\t\t\t    sizeof(resp)) == -1)\n\t\t\t\terrx(1, \"Proxy username/password too long\");\n\t\t\tr = snprintf(buf, sizeof(buf), \"Proxy-Authorization: \"\n\t\t\t    \"Basic %s\\r\\n\", resp);\n\t\t\tif (r == -1 || (size_t)r >= sizeof(buf))\n\t\t\t\terrx(1, \"Proxy auth response too long\");\n\t\t\tr = strlen(buf);\n\t\t\tif ((cnt = atomicio(vwrite, proxyfd, buf, r)) != (size_t)r)\n\t\t\t\terr(1, \"write failed (%zu/%d)\", cnt, r);\n\t\t}\n\n\t\t \n\t\tif ((r = atomicio(vwrite, proxyfd, \"\\r\\n\", 2)) != 2)\n\t\t\terr(1, \"write failed (2/%d)\", r);\n\n\t\t \n\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\tif (proxyuser != NULL &&\n\t\t    strncmp(buf, \"HTTP/1.0 407 \", 12) == 0) {\n\t\t\tif (authretry > 1) {\n\t\t\t\tfprintf(stderr, \"Proxy authentication \"\n\t\t\t\t    \"failed\\n\");\n\t\t\t}\n\t\t\tclose(proxyfd);\n\t\t\tgoto again;\n\t\t} else if (strncmp(buf, \"HTTP/1.0 200 \", 12) != 0 &&\n\t\t    strncmp(buf, \"HTTP/1.1 200 \", 12) != 0)\n\t\t\terrx(1, \"Proxy error: \\\"%s\\\"\", buf);\n\n\t\t \n\t\tfor (r = 0; r < HTTP_MAXHDRS; r++) {\n\t\t\tproxy_read_line(proxyfd, buf, sizeof(buf));\n\t\t\tif (*buf == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*buf != '\\0')\n\t\t\terrx(1, \"Too many proxy headers received\");\n\t} else\n\t\terrx(1, \"Unknown proxy protocol %d\", socksv);\n\n\treturn (proxyfd);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}