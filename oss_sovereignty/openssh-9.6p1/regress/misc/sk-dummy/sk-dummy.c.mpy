{
  "module_name": "sk-dummy.c",
  "hash_id": "40b4882056e33f6131b232437754ef732a55397f6b94cd38c89501189af5c67d",
  "original_prompt": "Ingested from openssh-9.6p1/regress/misc/sk-dummy/sk-dummy.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n\n#include \"crypto_api.h\"\n#include \"sk-api.h\"\n\n#ifdef WITH_OPENSSL\n#include <openssl/opensslv.h>\n#include <openssl/sha.h>\n#include <openssl/crypto.h>\n#include <openssl/evp.h>\n#include <openssl/bn.h>\n#include <openssl/ec.h>\n#include <openssl/ecdsa.h>\n#include <openssl/pem.h>\n\n \n#define SHA256Init(x)\t\tSHA256_Init(x)\n#define SHA256Update(x, y, z)\tSHA256_Update(x, y, z)\n#define SHA256Final(x, y)\tSHA256_Final(x, y)\n#define SHA2_CTX\t\tSHA256_CTX\n\n#elif defined(HAVE_SHA2_H)\n#include <sha2.h>\n#endif  \n\n \n\n#if SSH_SK_VERSION_MAJOR != 0x000a0000\n# error SK API has changed, sk-dummy.c needs an update\n#endif\n\n#ifdef SK_DUMMY_INTEGRATE\n# define sk_api_version\t\tssh_sk_api_version\n# define sk_enroll\t\tssh_sk_enroll\n# define sk_sign\t\tssh_sk_sign\n# define sk_load_resident_keys\tssh_sk_load_resident_keys\n#endif  \n\nstatic void skdebug(const char *func, const char *fmt, ...)\n    __attribute__((__format__ (printf, 2, 3)));\n\nstatic void\nskdebug(const char *func, const char *fmt, ...)\n{\n#if defined(SK_DEBUG)\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tfprintf(stderr, \"sk-dummy %s: \", func);\n\tvfprintf(stderr, fmt, ap);\n\tfputc('\\n', stderr);\n\tva_end(ap);\n#else\n\t(void)func;  \n\t(void)fmt;  \n#endif\n}\n\nuint32_t\nsk_api_version(void)\n{\n\treturn SSH_SK_VERSION_MAJOR;\n}\n\nstatic int\npack_key_ecdsa(struct sk_enroll_response *response)\n{\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY *key = NULL;\n\tconst EC_GROUP *g;\n\tconst EC_POINT *q;\n\tint ret = -1;\n\tlong privlen;\n\tBIO *bio = NULL;\n\tchar *privptr;\n\n\tresponse->public_key = NULL;\n\tresponse->public_key_len = 0;\n\tresponse->key_handle = NULL;\n\tresponse->key_handle_len = 0;\n\n\tif ((key = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1)) == NULL) {\n\t\tskdebug(__func__, \"EC_KEY_new_by_curve_name\");\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(key) != 1) {\n\t\tskdebug(__func__, \"EC_KEY_generate_key\");\n\t\tgoto out;\n\t}\n\tEC_KEY_set_asn1_flag(key, OPENSSL_EC_NAMED_CURVE);\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL ||\n\t    (g = EC_KEY_get0_group(key)) == NULL ||\n\t    (q = EC_KEY_get0_public_key(key)) == NULL) {\n\t\tskdebug(__func__, \"couldn't get key parameters\");\n\t\tgoto out;\n\t}\n\tresponse->public_key_len = EC_POINT_point2oct(g, q,\n\t    POINT_CONVERSION_UNCOMPRESSED, NULL, 0, NULL);\n\tif (response->public_key_len == 0 || response->public_key_len > 2048) {\n\t\tskdebug(__func__, \"bad pubkey length %zu\",\n\t\t    response->public_key_len);\n\t\tgoto out;\n\t}\n\tif ((response->public_key = malloc(response->public_key_len)) == NULL) {\n\t\tskdebug(__func__, \"malloc pubkey failed\");\n\t\tgoto out;\n\t}\n\tif (EC_POINT_point2oct(g, q, POINT_CONVERSION_UNCOMPRESSED,\n\t    response->public_key, response->public_key_len, NULL) == 0) {\n\t\tskdebug(__func__, \"EC_POINT_point2oct failed\");\n\t\tgoto out;\n\t}\n\t \n\tif (!PEM_write_bio_ECPrivateKey(bio, key, NULL, NULL, 0, NULL, NULL)) {\n\t\tskdebug(__func__, \"PEM_write_bio_ECPrivateKey failed\");\n\t\tgoto out;\n\t}\n\tif ((privlen = BIO_get_mem_data(bio, &privptr)) <= 0) {\n\t\tskdebug(__func__, \"BIO_get_mem_data failed\");\n\t\tgoto out;\n\t}\n\tif ((response->key_handle = malloc(privlen)) == NULL) {\n\t\tskdebug(__func__, \"malloc key_handle failed\");\n\t\tgoto out;\n\t}\n\tresponse->key_handle_len = (size_t)privlen;\n\tmemcpy(response->key_handle, privptr, response->key_handle_len);\n\t \n\tret = 0;\n out:\n\tif (ret != 0) {\n\t\tif (response->public_key != NULL) {\n\t\t\tmemset(response->public_key, 0,\n\t\t\t    response->public_key_len);\n\t\t\tfree(response->public_key);\n\t\t\tresponse->public_key = NULL;\n\t\t}\n\t\tif (response->key_handle != NULL) {\n\t\t\tmemset(response->key_handle, 0,\n\t\t\t    response->key_handle_len);\n\t\t\tfree(response->key_handle);\n\t\t\tresponse->key_handle = NULL;\n\t\t}\n\t}\n\tBIO_free(bio);\n\tEC_KEY_free(key);\n\treturn ret;\n#else\n\treturn -1;\n#endif\n}\n\nstatic int\npack_key_ed25519(struct sk_enroll_response *response)\n{\n\tint ret = -1;\n\tu_char pk[crypto_sign_ed25519_PUBLICKEYBYTES];\n\tu_char sk[crypto_sign_ed25519_SECRETKEYBYTES];\n\n\tresponse->public_key = NULL;\n\tresponse->public_key_len = 0;\n\tresponse->key_handle = NULL;\n\tresponse->key_handle_len = 0;\n\n\tmemset(pk, 0, sizeof(pk));\n\tmemset(sk, 0, sizeof(sk));\n\tcrypto_sign_ed25519_keypair(pk, sk);\n\n\tresponse->public_key_len = sizeof(pk);\n\tif ((response->public_key = malloc(response->public_key_len)) == NULL) {\n\t\tskdebug(__func__, \"malloc pubkey failed\");\n\t\tgoto out;\n\t}\n\tmemcpy(response->public_key, pk, sizeof(pk));\n\t \n\tresponse->key_handle_len = sizeof(sk);\n\tif ((response->key_handle = malloc(response->key_handle_len)) == NULL) {\n\t\tskdebug(__func__, \"malloc key_handle failed\");\n\t\tgoto out;\n\t}\n\tmemcpy(response->key_handle, sk, sizeof(sk));\n\t \n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tfree(response->public_key);\n\treturn ret;\n}\n\nstatic int\ncheck_options(struct sk_option **options)\n{\n\tsize_t i;\n\n\tif (options == NULL)\n\t\treturn 0;\n\tfor (i = 0; options[i] != NULL; i++) {\n\t\tskdebug(__func__, \"requested unsupported option %s\",\n\t\t    options[i]->name);\n\t\tif (options[i]->required) {\n\t\t\tskdebug(__func__, \"unknown required option\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nsk_enroll(uint32_t alg, const uint8_t *challenge, size_t challenge_len,\n    const char *application, uint8_t flags, const char *pin,\n    struct sk_option **options, struct sk_enroll_response **enroll_response)\n{\n\tstruct sk_enroll_response *response = NULL;\n\tint ret = SSH_SK_ERR_GENERAL;\n\n\t(void)flags;  \n\n\tif (enroll_response == NULL) {\n\t\tskdebug(__func__, \"enroll_response == NULL\");\n\t\tgoto out;\n\t}\n\t*enroll_response = NULL;\n\tif (check_options(options) != 0)\n\t\tgoto out;  \n\tif ((response = calloc(1, sizeof(*response))) == NULL) {\n\t\tskdebug(__func__, \"calloc response failed\");\n\t\tgoto out;\n\t}\n\tresponse->flags = flags;\n\tswitch(alg) {\n\tcase SSH_SK_ECDSA:\n\t\tif (pack_key_ecdsa(response) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SSH_SK_ED25519:\n\t\tif (pack_key_ed25519(response) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tskdebug(__func__, \"unsupported key type %d\", alg);\n\t\treturn -1;\n\t}\n\t \n\tif ((response->signature = calloc(1, 1)) == NULL) {\n\t\tskdebug(__func__, \"calloc signature failed\");\n\t\tgoto out;\n\t}\n\tresponse->signature_len = 0;\n\n\t*enroll_response = response;\n\tresponse = NULL;\n\tret = 0;\n out:\n\tif (response != NULL) {\n\t\tfree(response->public_key);\n\t\tfree(response->key_handle);\n\t\tfree(response->signature);\n\t\tfree(response->attestation_cert);\n\t\tfree(response);\n\t}\n\treturn ret;\n}\n\nstatic void\ndump(const char *preamble, const void *sv, size_t l)\n{\n#ifdef SK_DEBUG\n\tconst u_char *s = (const u_char *)sv;\n\tsize_t i;\n\n\tfprintf(stderr, \"%s (len %zu):\\n\", preamble, l);\n\tfor (i = 0; i < l; i++) {\n\t\tif (i % 16 == 0)\n\t\t\tfprintf(stderr, \"%04zu: \", i);\n\t\tfprintf(stderr, \"%02x\", s[i]);\n\t\tif (i % 16 == 15 || i == l - 1)\n\t\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}\n\nstatic int\nsig_ecdsa(const uint8_t *message, size_t message_len,\n    const char *application, uint32_t counter, uint8_t flags,\n    const uint8_t *key_handle, size_t key_handle_len,\n    struct sk_sign_response *response)\n{\n#ifdef OPENSSL_HAS_ECC\n\tECDSA_SIG *sig = NULL;\n\tconst BIGNUM *sig_r, *sig_s;\n\tint ret = -1;\n\tBIO *bio = NULL;\n\tEVP_PKEY *pk = NULL;\n\tEC_KEY *ec = NULL;\n\tSHA2_CTX ctx;\n\tuint8_t\tapphash[SHA256_DIGEST_LENGTH];\n\tuint8_t\tsighash[SHA256_DIGEST_LENGTH];\n\tuint8_t countbuf[4];\n\n\t \n\tif ((bio = BIO_new(BIO_s_mem())) == NULL ||\n\t    BIO_write(bio, key_handle, key_handle_len) != (int)key_handle_len) {\n\t\tskdebug(__func__, \"BIO setup failed\");\n\t\tgoto out;\n\t}\n\tif ((pk = PEM_read_bio_PrivateKey(bio, NULL, NULL, \"\")) == NULL) {\n\t\tskdebug(__func__, \"PEM_read_bio_PrivateKey failed\");\n\t\tgoto out;\n\t}\n\tif (EVP_PKEY_base_id(pk) != EVP_PKEY_EC) {\n\t\tskdebug(__func__, \"Not an EC key: %d\", EVP_PKEY_base_id(pk));\n\t\tgoto out;\n\t}\n\tif ((ec = EVP_PKEY_get1_EC_KEY(pk)) == NULL) {\n\t\tskdebug(__func__, \"EVP_PKEY_get1_EC_KEY failed\");\n\t\tgoto out;\n\t}\n\t \n\tif (message_len != SHA256_DIGEST_LENGTH) {\n\t\tskdebug(__func__, \"bad message len %zu\", message_len);\n\t\tgoto out;\n\t}\n\t \n\tdump(\"message\", message, message_len);\n\tSHA256Init(&ctx);\n\tSHA256Update(&ctx, (const u_char *)application, strlen(application));\n\tSHA256Final(apphash, &ctx);\n\tdump(\"apphash\", apphash, sizeof(apphash));\n\tcountbuf[0] = (counter >> 24) & 0xff;\n\tcountbuf[1] = (counter >> 16) & 0xff;\n\tcountbuf[2] = (counter >> 8) & 0xff;\n\tcountbuf[3] = counter & 0xff;\n\tdump(\"countbuf\", countbuf, sizeof(countbuf));\n\tdump(\"flags\", &flags, sizeof(flags));\n\tSHA256Init(&ctx);\n\tSHA256Update(&ctx, apphash, sizeof(apphash));\n\tSHA256Update(&ctx, &flags, sizeof(flags));\n\tSHA256Update(&ctx, countbuf, sizeof(countbuf));\n\tSHA256Update(&ctx, message, message_len);\n\tSHA256Final(sighash, &ctx);\n\tdump(\"sighash\", sighash, sizeof(sighash));\n\t \n\tif ((sig = ECDSA_do_sign(sighash, sizeof(sighash), ec)) == NULL) {\n\t\tskdebug(__func__, \"ECDSA_do_sign failed\");\n\t\tgoto out;\n\t}\n\tECDSA_SIG_get0(sig, &sig_r, &sig_s);\n\tresponse->sig_r_len = BN_num_bytes(sig_r);\n\tresponse->sig_s_len = BN_num_bytes(sig_s);\n\tif ((response->sig_r = calloc(1, response->sig_r_len)) == NULL ||\n\t    (response->sig_s = calloc(1, response->sig_s_len)) == NULL) {\n\t\tskdebug(__func__, \"calloc signature failed\");\n\t\tgoto out;\n\t}\n\tBN_bn2bin(sig_r, response->sig_r);\n\tBN_bn2bin(sig_s, response->sig_s);\n\tret = 0;\n out:\n\texplicit_bzero(&ctx, sizeof(ctx));\n\texplicit_bzero(&apphash, sizeof(apphash));\n\texplicit_bzero(&sighash, sizeof(sighash));\n\tECDSA_SIG_free(sig);\n\tif (ret != 0) {\n\t\tfree(response->sig_r);\n\t\tfree(response->sig_s);\n\t\tresponse->sig_r = NULL;\n\t\tresponse->sig_s = NULL;\n\t}\n\tBIO_free(bio);\n\tEC_KEY_free(ec);\n\tEVP_PKEY_free(pk);\n\treturn ret;\n#else\n\treturn -1;\n#endif\n}\n\nstatic int\nsig_ed25519(const uint8_t *message, size_t message_len,\n    const char *application, uint32_t counter, uint8_t flags,\n    const uint8_t *key_handle, size_t key_handle_len,\n    struct sk_sign_response *response)\n{\n\tsize_t o;\n\tint ret = -1;\n\tSHA2_CTX ctx;\n\tuint8_t\tapphash[SHA256_DIGEST_LENGTH];\n\tuint8_t signbuf[sizeof(apphash) + sizeof(flags) +\n\t    sizeof(counter) + SHA256_DIGEST_LENGTH];\n\tuint8_t sig[crypto_sign_ed25519_BYTES + sizeof(signbuf)];\n\tunsigned long long smlen;\n\n\tif (key_handle_len != crypto_sign_ed25519_SECRETKEYBYTES) {\n\t\tskdebug(__func__, \"bad key handle length %zu\", key_handle_len);\n\t\tgoto out;\n\t}\n\t \n\tif (message_len != SHA256_DIGEST_LENGTH) {\n\t\tskdebug(__func__, \"bad message len %zu\", message_len);\n\t\tgoto out;\n\t}\n\t \n\tdump(\"message\", message, message_len);\n\tSHA256Init(&ctx);\n\tSHA256Update(&ctx, (const u_char *)application, strlen(application));\n\tSHA256Final(apphash, &ctx);\n\tdump(\"apphash\", apphash, sizeof(apphash));\n\n\tmemcpy(signbuf, apphash, sizeof(apphash));\n\to = sizeof(apphash);\n\tsignbuf[o++] = flags;\n\tsignbuf[o++] = (counter >> 24) & 0xff;\n\tsignbuf[o++] = (counter >> 16) & 0xff;\n\tsignbuf[o++] = (counter >> 8) & 0xff;\n\tsignbuf[o++] = counter & 0xff;\n\tmemcpy(signbuf + o, message, message_len);\n\to += message_len;\n\tif (o != sizeof(signbuf)) {\n\t\tskdebug(__func__, \"bad sign buf len %zu, expected %zu\",\n\t\t    o, sizeof(signbuf));\n\t\tgoto out;\n\t}\n\tdump(\"signbuf\", signbuf, sizeof(signbuf));\n\t \n\tsmlen = sizeof(signbuf);\n\tif (crypto_sign_ed25519(sig, &smlen, signbuf, sizeof(signbuf),\n\t    key_handle) != 0) {\n\t\tskdebug(__func__, \"crypto_sign_ed25519 failed\");\n\t\tgoto out;\n\t}\n\tif (smlen <= sizeof(signbuf)) {\n\t\tskdebug(__func__, \"bad sign smlen %llu, expected min %zu\",\n\t\t    smlen, sizeof(signbuf) + 1);\n\t\tgoto out;\n\t}\n\tresponse->sig_r_len = (size_t)(smlen - sizeof(signbuf));\n\tif ((response->sig_r = calloc(1, response->sig_r_len)) == NULL) {\n\t\tskdebug(__func__, \"calloc signature failed\");\n\t\tgoto out;\n\t}\n\tmemcpy(response->sig_r, sig, response->sig_r_len);\n\tdump(\"sig_r\", response->sig_r, response->sig_r_len);\n\tret = 0;\n out:\n\texplicit_bzero(&ctx, sizeof(ctx));\n\texplicit_bzero(&apphash, sizeof(apphash));\n\texplicit_bzero(&signbuf, sizeof(signbuf));\n\texplicit_bzero(&sig, sizeof(sig));\n\tif (ret != 0) {\n\t\tfree(response->sig_r);\n\t\tresponse->sig_r = NULL;\n\t}\n\treturn ret;\n}\n\nint\nsk_sign(uint32_t alg, const uint8_t *data, size_t datalen,\n    const char *application, const uint8_t *key_handle, size_t key_handle_len,\n    uint8_t flags, const char *pin, struct sk_option **options,\n    struct sk_sign_response **sign_response)\n{\n\tstruct sk_sign_response *response = NULL;\n\tint ret = SSH_SK_ERR_GENERAL;\n\tSHA2_CTX ctx;\n\tuint8_t message[32];\n\n\tif (sign_response == NULL) {\n\t\tskdebug(__func__, \"sign_response == NULL\");\n\t\tgoto out;\n\t}\n\t*sign_response = NULL;\n\tif (check_options(options) != 0)\n\t\tgoto out;  \n\tif ((response = calloc(1, sizeof(*response))) == NULL) {\n\t\tskdebug(__func__, \"calloc response failed\");\n\t\tgoto out;\n\t}\n\tSHA256Init(&ctx);\n\tSHA256Update(&ctx, data, datalen);\n\tSHA256Final(message, &ctx);\n\tresponse->flags = flags;\n\tresponse->counter = 0x12345678;\n\tswitch(alg) {\n\tcase SSH_SK_ECDSA:\n\t\tif (sig_ecdsa(message, sizeof(message), application,\n\t\t    response->counter, flags, key_handle, key_handle_len,\n\t\t    response) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SSH_SK_ED25519:\n\t\tif (sig_ed25519(message, sizeof(message), application,\n\t\t    response->counter, flags, key_handle, key_handle_len,\n\t\t    response) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tskdebug(__func__, \"unsupported key type %d\", alg);\n\t\treturn -1;\n\t}\n\t*sign_response = response;\n\tresponse = NULL;\n\tret = 0;\n out:\n\texplicit_bzero(message, sizeof(message));\n\tif (response != NULL) {\n\t\tfree(response->sig_r);\n\t\tfree(response->sig_s);\n\t\tfree(response);\n\t}\n\treturn ret;\n}\n\nint\nsk_load_resident_keys(const char *pin, struct sk_option **options,\n    struct sk_resident_key ***rks, size_t *nrks)\n{\n\treturn SSH_SK_ERR_UNSUPPORTED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}