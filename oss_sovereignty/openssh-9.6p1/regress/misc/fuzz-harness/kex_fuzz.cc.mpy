{
  "module_name": "kex_fuzz.cc",
  "hash_id": "58b3e714b845fd5b729f059ae727c0f89544f30aeb41dd25f5d9d3d0ca6ef439",
  "original_prompt": "Ingested from openssh-9.6p1/regress/misc/fuzz-harness/kex_fuzz.cc",
  "human_readable_source": "\n\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nextern \"C\" {\n\n#include \"includes.h\"\n#include \"ssherr.h\"\n#include \"ssh_api.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n#include \"xmalloc.h\"\n#include \"authfile.h\"\n#include \"log.h\"\n\n#include \"fixed-keys.h\"\n\n\n \n\nstatic int prepare_key(struct shared_state *st, int keytype, int bits);\n\nstruct shared_state {\n\tsize_t nkeys;\n\tstruct sshkey **privkeys, **pubkeys;\n};\n\nstruct test_state {\n\tstruct sshbuf *smsgs, *cmsgs;  \n\tstruct sshbuf *sin, *cin;  \n\tstruct sshbuf *s_template, *c_template;  \n};\n\nstatic int\ndo_send_and_receive(struct ssh *from, struct ssh *to,\n    struct sshbuf *store, int clobber, size_t *n)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (*n = 0;; (*n)++) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tdebug_fr(r, \"ssh_packet_next\");\n\t\t\treturn r;\n\t\t}\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tdebug_f(\"%zu%s\", len, clobber ? \" ignore\" : \"\");\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_output_consume(from, len)) != 0) {\n\t\t\tdebug_fr(r, \"ssh_output_consume\");\n\t\t\treturn r;\n\t\t}\n\t\tif (store != NULL && (r = sshbuf_put(store, buf, len)) != 0) {\n\t\t\tdebug_fr(r, \"sshbuf_put\");\n\t\t\treturn r;\n\t\t}\n\t\tif (!clobber && (r = ssh_input_append(to, buf, len)) != 0) {\n\t\t\tdebug_fr(r, \"ssh_input_append\");\n\t\t\treturn r;\n\t\t}\n\t}\n}\n\nstatic int\nrun_kex(struct test_state *ts, struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\tsize_t cn, sn;\n\n\t \n\tif (ts->sin != NULL) {\n\t\tif ((r = ssh_input_append(server, sshbuf_ptr(ts->sin),\n\t\t    sshbuf_len(ts->sin))) != 0) {\n\t\t\terror_fr(r, \"ssh_input_append\");\n\t\t\treturn r;\n\t\t}\n\t\tsshbuf_reset(ts->sin);\n\t}\n\tif (ts->cin != NULL) {\n\t\tif ((r = ssh_input_append(client, sshbuf_ptr(ts->cin),\n\t\t    sshbuf_len(ts->cin))) != 0) {\n\t\t\terror_fr(r, \"ssh_input_append\");\n\t\t\treturn r;\n\t\t}\n\t\tsshbuf_reset(ts->cin);\n\t}\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tcn = sn = 0;\n\t\tdebug_f(\"S:\");\n\t\tif ((r = do_send_and_receive(server, client,\n\t\t    ts->smsgs, ts->cin != NULL, &sn)) != 0) {\n\t\t\tdebug_fr(r, \"S->C\");\n\t\t\tbreak;\n\t\t}\n\t\tdebug_f(\"C:\");\n\t\tif ((r = do_send_and_receive(client, server,\n\t\t    ts->cmsgs, ts->sin != NULL, &cn)) != 0) {\n\t\t\tdebug_fr(r, \"C->S\");\n\t\t\tbreak;\n\t\t}\n\t\tif (cn == 0 && sn == 0) {\n\t\t\tdebug_f(\"kex stalled\");\n\t\t\tr = SSH_ERR_PROTOCOL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdebug_fr(r, \"done\");\n\treturn r;\n}\n\nstatic void\nstore_key(struct shared_state *st, struct sshkey *pubkey,\n    struct sshkey *privkey)\n{\n\tif (st == NULL || pubkey->type < 0 || pubkey->type > INT_MAX ||\n\t    privkey->type != pubkey->type ||\n\t    ((size_t)pubkey->type < st->nkeys &&\n\t     st->pubkeys[pubkey->type] != NULL))\n\t\tabort();\n\tif ((size_t)pubkey->type >= st->nkeys) {\n\t\tst->pubkeys = (struct sshkey **)xrecallocarray(st->pubkeys,\n\t\t    st->nkeys, pubkey->type + 1, sizeof(*st->pubkeys));\n\t\tst->privkeys = (struct sshkey **)xrecallocarray(st->privkeys,\n\t\t    st->nkeys, privkey->type + 1, sizeof(*st->privkeys));\n\t\tst->nkeys = privkey->type + 1;\n\t}\n\tdebug_f(\"store %s at %d\", sshkey_ssh_name(pubkey), pubkey->type);\n\tst->pubkeys[pubkey->type] = pubkey;\n\tst->privkeys[privkey->type] = privkey;\n}\n\nstatic int\nprepare_keys(struct shared_state *st)\n{\n\tif (prepare_key(st, KEY_RSA, 2048) != 0 ||\n\t    prepare_key(st, KEY_DSA, 1024) != 0 ||\n\t    prepare_key(st, KEY_ECDSA, 256) != 0 ||\n\t    prepare_key(st, KEY_ED25519, 256) != 0) {\n\t\terror_f(\"key prepare failed\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic struct sshkey *\nget_pubkey(struct shared_state *st, int keytype)\n{\n\tif (st == NULL || keytype < 0 || (size_t)keytype >= st->nkeys ||\n\t    st->pubkeys == NULL || st->pubkeys[keytype] == NULL)\n\t\tabort();\n\treturn st->pubkeys[keytype];\n}\n\nstatic struct sshkey *\nget_privkey(struct shared_state *st, int keytype)\n{\n\tif (st == NULL || keytype < 0 || (size_t)keytype >= st->nkeys ||\n\t    st->privkeys == NULL || st->privkeys[keytype] == NULL)\n\t\tabort();\n\treturn st->privkeys[keytype];\n}\n\nstatic int\ndo_kex_with_key(struct shared_state *st, struct test_state *ts,\n    const char *kex, int keytype)\n{\n\tstruct ssh *client = NULL, *server = NULL;\n\tstruct sshkey *privkey = NULL, *pubkey = NULL;\n\tstruct sshbuf *state = NULL;\n\tstruct kex_params kex_params;\n\tconst char *ccp, *proposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *myproposal[PROPOSAL_MAX] = {0}, *keyname = NULL;\n\tint i, r;\n\n\tts->cin = ts->sin = NULL;\n\tif (ts->c_template != NULL &&\n\t    (ts->cin = sshbuf_fromb(ts->c_template)) == NULL)\n\t\tabort();\n\tif (ts->s_template != NULL &&\n\t    (ts->sin = sshbuf_fromb(ts->s_template)) == NULL)\n\t\tabort();\n\n\tpubkey = get_pubkey(st, keytype);\n\tprivkey = get_privkey(st, keytype);\n\tkeyname = xstrdup(sshkey_ssh_name(privkey));\n\tif (ts->cin != NULL) {\n\t\tdebug_f(\"%s %s clobber client %zu\", kex, keyname,\n\t\t    sshbuf_len(ts->cin));\n\t} else if (ts->sin != NULL) {\n\t\tdebug_f(\"%s %s clobber server %zu\", kex, keyname,\n\t\t    sshbuf_len(ts->sin));\n\t} else\n\t\tdebug_f(\"%s %s noclobber\", kex, keyname);\n\n\tfor (i = 0; i < PROPOSAL_MAX; i++) {\n\t\tccp = proposal[i];\n#ifdef CIPHER_NONE_AVAIL\n\t\tif (i == PROPOSAL_ENC_ALGS_CTOS || i == PROPOSAL_ENC_ALGS_STOC)\n\t\t\tccp = \"none\";\n#endif\n\t\tif (i == PROPOSAL_SERVER_HOST_KEY_ALGS)\n\t\t\tccp = keyname;\n\t\telse if (i == PROPOSAL_KEX_ALGS && kex != NULL)\n\t\t\tccp = kex;\n\t\tif ((myproposal[i] = strdup(ccp)) == NULL) {\n\t\t\terror_f(\"strdup prop %d\", i);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif ((r = ssh_init(&client, 0, &kex_params)) != 0) {\n\t\terror_fr(r, \"init client\");\n\t\tgoto fail;\n\t}\n\tif ((r = ssh_init(&server, 1, &kex_params)) != 0) {\n\t\terror_fr(r, \"init server\");\n\t\tgoto fail;\n\t}\n\tif ((r = ssh_add_hostkey(server, privkey)) != 0 ||\n\t    (r = ssh_add_hostkey(client, pubkey)) != 0) {\n\t\terror_fr(r, \"add hostkeys\");\n\t\tgoto fail;\n\t}\n\tif ((r = run_kex(ts, client, server)) != 0) {\n\t\terror_fr(r, \"kex\");\n\t\tgoto fail;\n\t}\n\t \n fail:\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tfree(myproposal[i]);\n\tsshbuf_free(ts->sin);\n\tsshbuf_free(ts->cin);\n\tsshbuf_free(state);\n\tssh_free(client);\n\tssh_free(server);\n\tfree(keyname);\n\treturn r;\n}\n\nstatic int\nprepare_key(struct shared_state *st, int kt, int bits)\n{\n\tconst char *pubstr = NULL;\n\tconst char *privstr = NULL;\n\tchar *tmp, *cp;\n\tstruct sshkey *privkey = NULL, *pubkey = NULL;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\n\tswitch (kt) {\n\tcase KEY_RSA:\n\t\tpubstr = PUB_RSA;\n\t\tprivstr = PRIV_RSA;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tpubstr = PUB_DSA;\n\t\tprivstr = PRIV_DSA;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tpubstr = PUB_ECDSA;\n\t\tprivstr = PRIV_ECDSA;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\tpubstr = PUB_ED25519;\n\t\tprivstr = PRIV_ED25519;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\tif ((b = sshbuf_from(privstr, strlen(privstr))) == NULL)\n\t\tabort();\n\tif ((r = sshkey_parse_private_fileblob(b, \"\", &privkey, NULL)) != 0) {\n\t\terror_fr(r, \"priv %d\", kt);\n\t\tabort();\n\t}\n\tsshbuf_free(b);\n\ttmp = cp = xstrdup(pubstr);\n\tif ((pubkey = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tabort();\n\tif ((r = sshkey_read(pubkey, &cp)) != 0) {\n\t\terror_fr(r, \"pub %d\", kt);\n\t\tabort();\n\t}\n\tfree(tmp);\n\n\tstore_key(st, pubkey, privkey);\n\treturn 0;\n}\n\n#if defined(STANDALONE)\n\n#if 0  \nstatic int\nprepare_key(struct shared_state *st, int keytype, int bits)\n{\n\tstruct sshkey *privkey = NULL, *pubkey = NULL;\n\tint r;\n\n\tif ((r = sshkey_generate(keytype, bits, &privkey)) != 0) {\n\t\terror_fr(r, \"generate\");\n\t\tabort();\n\t}\n\tif ((r = sshkey_from_private(privkey, &pubkey)) != 0) {\n\t\terror_fr(r, \"make pubkey\");\n\t\tabort();\n\t}\n\tstore_key(st, pubkey, privkey);\n\treturn 0;\n}\n#endif\n\nint main(void)\n{\n\tstatic struct shared_state *st;\n\tstruct test_state *ts;\n\tconst int keytypes[] = { KEY_RSA, KEY_DSA, KEY_ECDSA, KEY_ED25519, -1 };\n\tstatic const char * const kextypes[] = {\n\t\t\"sntrup761x25519-sha512@openssh.com\",\n\t\t\"curve25519-sha256@libssh.org\",\n\t\t\"ecdh-sha2-nistp256\",\n\t\t\"diffie-hellman-group1-sha1\",\n\t\t\"diffie-hellman-group-exchange-sha1\",\n\t\tNULL,\n\t};\n\tint i, j;\n\tchar *path;\n\tFILE *f;\n\n\tlog_init(\"kex_fuzz\", SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTH, 1);\n\n\tif (st == NULL) {\n\t\tst = (struct shared_state *)xcalloc(1, sizeof(*st));\n\t\tprepare_keys(st);\n\t}\n\t \n\tfor (i = 0; keytypes[i] != -1; i++) {\n\t\tfor (j = 0; kextypes[j] != NULL; j++) {\n\t\t\tts = (struct test_state *)xcalloc(1, sizeof(*ts));\n\t\t\tts->smsgs = sshbuf_new();\n\t\t\tts->cmsgs = sshbuf_new();\n\t\t\tdo_kex_with_key(st, ts, kextypes[j], keytypes[i]);\n\t\t\txasprintf(&path, \"S2C-%s-%s\",\n\t\t\t    kextypes[j], sshkey_type(st->pubkeys[keytypes[i]]));\n\t\t\tdebug_f(\"%s\", path);\n\t\t\tif ((f = fopen(path, \"wb+\")) == NULL)\n\t\t\t\tabort();\n\t\t\tif (fwrite(sshbuf_ptr(ts->smsgs), 1,\n\t\t\t    sshbuf_len(ts->smsgs), f) != sshbuf_len(ts->smsgs))\n\t\t\t\tabort();\n\t\t\tfclose(f);\n\t\t\tfree(path);\n\t\t\t\n\t\t\txasprintf(&path, \"C2S-%s-%s\",\n\t\t\t    kextypes[j], sshkey_type(st->pubkeys[keytypes[i]]));\n\t\t\tdebug_f(\"%s\", path);\n\t\t\tif ((f = fopen(path, \"wb+\")) == NULL)\n\t\t\t\tabort();\n\t\t\tif (fwrite(sshbuf_ptr(ts->cmsgs), 1,\n\t\t\t    sshbuf_len(ts->cmsgs), f) != sshbuf_len(ts->cmsgs))\n\t\t\t\tabort();\n\t\t\tfclose(f);\n\t\t\tfree(path);\n\t\t\t\n\t\t\tsshbuf_free(ts->smsgs);\n\t\t\tsshbuf_free(ts->cmsgs);\n\t\t\tfree(ts);\n\t\t}\n\t}\n\tfor (i = 0; keytypes[i] != -1; i++) {\n\t\txasprintf(&path, \"%s.priv\",\n\t\t    sshkey_type(st->privkeys[keytypes[i]]));\n\t\tdebug_f(\"%s\", path);\n\t\tif (sshkey_save_private(st->privkeys[keytypes[i]], path,\n\t\t    \"\", \"\", SSHKEY_PRIVATE_OPENSSH, NULL, 0) != 0)\n\t\t\tabort();\n\t\tfree(path);\n\t\txasprintf(&path, \"%s.pub\",\n\t\t    sshkey_type(st->pubkeys[keytypes[i]]));\n\t\tdebug_f(\"%s\", path);\n\t\tif (sshkey_save_public(st->pubkeys[keytypes[i]], path, \"\") != 0)\n\t\t\tabort();\n\t\tfree(path);\n\t}\n}\n#else  \nstatic void\ndo_kex(struct shared_state *st, struct test_state *ts, const char *kex)\n{\n\tdo_kex_with_key(st, ts, kex, KEY_RSA);\n\tdo_kex_with_key(st, ts, kex, KEY_DSA);\n\tdo_kex_with_key(st, ts, kex, KEY_ECDSA);\n\tdo_kex_with_key(st, ts, kex, KEY_ED25519);\n}\n\nstatic void\nkex_tests(struct shared_state *st, struct test_state *ts)\n{\n\tdo_kex(st, ts, \"sntrup761x25519-sha512@openssh.com\");\n\tdo_kex(st, ts, \"curve25519-sha256@libssh.org\");\n\tdo_kex(st, ts, \"ecdh-sha2-nistp256\");\n\tdo_kex(st, ts, \"diffie-hellman-group1-sha1\");\n\tdo_kex(st, ts, \"diffie-hellman-group-exchange-sha1\");\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)\n{\n\tstatic struct shared_state *st;\n\tstruct test_state *ts;\n\tu_char crbuf[SSH_MAX_PRE_BANNER_LINES * 4];\n\tu_char zbuf[4096] = {0};\n\tstatic LogLevel loglevel = SYSLOG_LEVEL_INFO;\n\n\tif (st == NULL) {\n\t\tif (getenv(\"DEBUG\") != NULL || getenv(\"KEX_FUZZ_DEBUG\") != NULL)\n\t\t\tloglevel = SYSLOG_LEVEL_DEBUG3;\n\t\tlog_init(\"kex_fuzz\",\n\t\t    loglevel, SYSLOG_FACILITY_AUTH, 1);\n\t\tst = (struct shared_state *)xcalloc(1, sizeof(*st));\n\t\tprepare_keys(st);\n\t}\n\n\t \n\tmemset(crbuf, '\\n', sizeof(crbuf));\n\n\tts = (struct test_state *)xcalloc(1, sizeof(*ts));\n\tif ((ts->s_template = sshbuf_new()) == NULL ||\n\t    sshbuf_put(ts->s_template, data, size) != 0 ||\n\t    sshbuf_put(ts->s_template, crbuf, sizeof(crbuf)) != 0 ||\n\t    sshbuf_put(ts->s_template, zbuf, sizeof(zbuf)) != 0)\n\t\tabort();\n\tkex_tests(st, ts);\n\tsshbuf_free(ts->s_template);\n\tfree(ts);\n\n\tts = (struct test_state *)xcalloc(1, sizeof(*ts));\n\tif ((ts->c_template = sshbuf_new()) == NULL ||\n\t    sshbuf_put(ts->c_template, data, size) != 0 ||\n\t    sshbuf_put(ts->c_template, crbuf, sizeof(crbuf)) != 0 ||\n\t    sshbuf_put(ts->c_template, zbuf, sizeof(zbuf)) != 0)\n\t\tabort();\n\tkex_tests(st, ts);\n\tsshbuf_free(ts->c_template);\n\tfree(ts);\n\n\treturn 0;\n}\n#endif  \n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}