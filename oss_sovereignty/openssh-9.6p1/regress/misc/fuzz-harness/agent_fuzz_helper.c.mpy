{
  "module_name": "agent_fuzz_helper.c",
  "hash_id": "e804e782943ea0dd00c46e1bb1e02d1046816e882db146fb6035c9decd9ec41c",
  "original_prompt": "Ingested from openssh-9.6p1/regress/misc/fuzz-harness/agent_fuzz_helper.c",
  "human_readable_source": "#include \"fixed-keys.h\"\n#include <assert.h>\n\n#define main(ac, av) xxxmain(ac, av)\n#include \"../../../ssh-agent.c\"\n\nvoid test_one(const uint8_t* s, size_t slen);\n\nstatic int\ndevnull_or_die(void)\n{\n\tint fd;\n\n\tif ((fd = open(\"/dev/null\", O_RDWR)) == -1) {\n\t\terror_f(\"open /dev/null: %s\", strerror(errno));\n\t\tabort();\n\t}\n\treturn fd;\n}\n\nstatic struct sshkey *\npubkey_or_die(const char *s)\n{\n\tchar *tmp, *cp;\n\tstruct sshkey *pubkey;\n\tint r;\n\n\ttmp = cp = xstrdup(s);\n\tif ((pubkey = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tabort();\n\tif ((r = sshkey_read(pubkey, &cp)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tabort();\n\t}\n\tfree(tmp);\n\treturn pubkey;\n}\n\nstatic struct sshkey *\nprivkey_or_die(const char *s)\n{\n\tint r;\n\tstruct sshbuf *b;\n\tstruct sshkey *privkey;\n\n\tif ((b = sshbuf_from(s, strlen(s))) == NULL) {\n\t\terror_f(\"sshbuf_from failed\");\n\t\tabort();\n\t}\n\tif ((r = sshkey_parse_private_fileblob(b, \"\", &privkey, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tabort();\n\t}\n\tsshbuf_free(b);\n\treturn privkey;\n}\n\nstatic void\nadd_key(const char *privkey, const char *certpath)\n{\n\tIdentity *id;\n\tint r;\n\tstruct sshkey *cert;\n\n\tid = xcalloc(1, sizeof(Identity));\n\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\tidtab->nentries++;\n\tid->key = privkey_or_die(privkey);\n\tid->comment = xstrdup(\"rhododaktulos Eos\");\n\tif (sshkey_is_sk(id->key))\n\t\tid->sk_provider = xstrdup(\"internal\");\n\n\t \n\tid = xcalloc(1, sizeof(Identity));\n\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\tidtab->nentries++;\n\tid->key = privkey_or_die(privkey);\n\tcert = pubkey_or_die(certpath);\n\tif ((r = sshkey_to_certified(id->key)) != 0) {\n\t\terror_fr(r, \"sshkey_to_certified\");\n\t\tabort();\n\t}\n\tif ((r = sshkey_cert_copy(cert, id->key)) != 0) {\n\t\terror_fr(r, \"sshkey_cert_copy\");\n\t\tabort();\n\t}\n\tsshkey_free(cert);\n\tid->comment = xstrdup(\"outis\");\n\tif (sshkey_is_sk(id->key))\n\t\tid->sk_provider = xstrdup(\"internal\");\n}\n\nstatic void\ncleanup_idtab(void)\n{\n\tIdentity *id;\n\n\tif (idtab == NULL) return;\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\tfree(idtab);\n\tidtab = NULL;\n}\n\nstatic void\nreset_idtab(void)\n{\n\tcleanup_idtab();\n\tidtab_init();\n\t\n\tadd_key(PRIV_RSA, CERT_RSA);\n\tadd_key(PRIV_DSA, CERT_DSA);\n\tadd_key(PRIV_ECDSA, CERT_ECDSA);\n\tadd_key(PRIV_ED25519, CERT_ED25519);\n\tadd_key(PRIV_ECDSA_SK, CERT_ECDSA_SK);\n\tadd_key(PRIV_ED25519_SK, CERT_ED25519_SK);\n}\n\nstatic void\ncleanup_sockettab(void)\n{\n\tu_int i;\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tif (sockets[i].type != AUTH_UNUSED)\n\t\t\tclose_socket(sockets + i);\n\t}\n\tfree(sockets);\n\tsockets = NULL;\n\tsockets_alloc = 0;\n}\n\nstatic void\nreset_sockettab(int devnull)\n{\n\tint fd;\n\n\tcleanup_sockettab();\n\tif ((fd = dup(devnull)) == -1) {\n\t\terror_f(\"dup: %s\", strerror(errno));\n\t\tabort();\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\tassert(sockets[0].type == AUTH_CONNECTION);\n\tassert(sockets[0].fd == fd);\n}\n\n#define MAX_MESSAGES 256\nvoid\ntest_one(const uint8_t* s, size_t slen)\n{\n\tstatic int devnull = -1;\n\tsize_t i, olen, nlen;\n\n\tif (devnull == -1) {\n\t\tlog_init(__progname, SYSLOG_LEVEL_DEBUG3,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tdevnull = devnull_or_die();\n\t\tallowed_providers = xstrdup(\"\");\n\t\tsetenv(\"DISPLAY\", \"\", 1);  \n\t}\n\n\treset_idtab();\n\treset_sockettab(devnull);\n\t(void)sshbuf_put(sockets[0].input, s, slen);\n\tfor (i = 0; i < MAX_MESSAGES; i++) {\n\t\tolen = sshbuf_len(sockets[0].input);\n\t\tprocess_message(0);\n\t\tnlen = sshbuf_len(sockets[0].input);\n\t\tif (nlen == 0 || nlen == olen)\n\t\t\tbreak;\n\t}\n\tcleanup_idtab();\n\tcleanup_sockettab();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}