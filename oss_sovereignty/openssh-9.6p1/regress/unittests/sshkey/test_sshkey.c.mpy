{
  "module_name": "test_sshkey.c",
  "hash_id": "d37e4c6fc3b6334da720fe6dc79a3ffa750f69e61a85a64ce6d8c6b20964c3f8",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/sshkey/test_sshkey.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/dsa.h>\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n# include <openssl/ec.h>\n#endif\n#endif\n\n#include \"../test_helper/test_helper.h\"\n\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#define SSHBUF_INTERNAL 1\t \n#include \"sshkey.h\"\n\n#include \"authfile.h\"\n#include \"common.h\"\n#include \"ssh2.h\"\n\nvoid sshkey_tests(void);\n\nstatic void\nput_opt(struct sshbuf *b, const char *name, const char *value)\n{\n\tstruct sshbuf *sect;\n\n\tsect = sshbuf_new();\n\tASSERT_PTR_NE(sect, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, name), 0);\n\tif (value != NULL)\n\t\tASSERT_INT_EQ(sshbuf_put_cstring(sect, value), 0);\n\tASSERT_INT_EQ(sshbuf_put_stringb(b, sect), 0);\n\tsshbuf_free(sect);\n}\n\n#ifdef WITH_OPENSSL\nstatic void\nbuild_cert(struct sshbuf *b, struct sshkey *k, const char *type,\n    struct sshkey *sign_key, struct sshkey *ca_key,\n    const char *sig_alg)\n{\n\tstruct sshbuf *ca_buf, *pk, *principals, *critopts, *exts;\n\tu_char *sigblob;\n\tsize_t siglen;\n\n\tca_buf = sshbuf_new();\n\tASSERT_PTR_NE(ca_buf, NULL);\n\tASSERT_INT_EQ(sshkey_putb(ca_key, ca_buf), 0);\n\n\t \n\tpk = sshbuf_new();\n\tASSERT_PTR_NE(pk, NULL);\n\tASSERT_INT_EQ(sshkey_putb_plain(k, pk), 0);\n\tASSERT_INT_EQ(sshbuf_skip_string(pk), 0);\n\n\tprincipals = sshbuf_new();\n\tASSERT_PTR_NE(principals, NULL);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gsamsa\"), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(principals, \"gregor\"), 0);\n\n\tcritopts = sshbuf_new();\n\tASSERT_PTR_NE(critopts, NULL);\n\tput_opt(critopts, \"force-command\", \"/usr/local/bin/nethack\");\n\tput_opt(critopts, \"source-address\", \"192.168.0.0/24,127.0.0.1,::1\");\n\n\texts = sshbuf_new();\n\tASSERT_PTR_NE(exts, NULL);\n\tput_opt(critopts, \"permit-X11-forwarding\", NULL);\n\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, type), 0);\n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"noncenoncenonce!\"), 0);  \n\tASSERT_INT_EQ(sshbuf_putb(b, pk), 0);  \n\tASSERT_INT_EQ(sshbuf_put_u64(b, 1234), 0);  \n\tASSERT_INT_EQ(sshbuf_put_u32(b, SSH2_CERT_TYPE_USER), 0);  \n\tASSERT_INT_EQ(sshbuf_put_cstring(b, \"gregor\"), 0);  \n\tASSERT_INT_EQ(sshbuf_put_stringb(b, principals), 0);  \n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0), 0);  \n\tASSERT_INT_EQ(sshbuf_put_u64(b, 0xffffffffffffffffULL), 0);  \n\tASSERT_INT_EQ(sshbuf_put_stringb(b, critopts), 0);  \n\tASSERT_INT_EQ(sshbuf_put_stringb(b, exts), 0);  \n\tASSERT_INT_EQ(sshbuf_put_string(b, NULL, 0), 0);  \n\tASSERT_INT_EQ(sshbuf_put_stringb(b, ca_buf), 0);  \n\tASSERT_INT_EQ(sshkey_sign(sign_key, &sigblob, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b), sig_alg, NULL, NULL, 0), 0);\n\tASSERT_INT_EQ(sshbuf_put_string(b, sigblob, siglen), 0);  \n\n\tfree(sigblob);\n\tsshbuf_free(ca_buf);\n\tsshbuf_free(exts);\n\tsshbuf_free(critopts);\n\tsshbuf_free(principals);\n\tsshbuf_free(pk);\n}\n#endif  \n\nstatic void\nsignature_test(struct sshkey *k, struct sshkey *bad, const char *sig_alg,\n    const u_char *d, size_t l)\n{\n\tsize_t len;\n\tu_char *sig;\n\n\tASSERT_INT_EQ(sshkey_sign(k, &sig, &len, d, l, sig_alg,\n\t    NULL, NULL, 0), 0);\n\tASSERT_SIZE_T_GT(len, 8);\n\tASSERT_PTR_NE(sig, NULL);\n\tASSERT_INT_EQ(sshkey_verify(k, sig, len, d, l, NULL, 0, NULL), 0);\n\tASSERT_INT_NE(sshkey_verify(bad, sig, len, d, l, NULL, 0, NULL), 0);\n\t \n\tsig[len - 5] ^= 0x10;\n\tASSERT_INT_NE(sshkey_verify(k, sig, len, d, l, NULL, 0, NULL), 0);\n\tfree(sig);\n}\n\nstatic void\nbanana(u_char *s, size_t l)\n{\n\tsize_t o;\n\tconst u_char the_banana[] = { 'b', 'a', 'n', 'a', 'n', 'a' };\n\n\tfor (o = 0; o < l; o += sizeof(the_banana)) {\n\t\tif (l - o < sizeof(the_banana)) {\n\t\t\tmemcpy(s + o, \"nanananana\", l - o);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(s + o, the_banana, sizeof(the_banana));\n\t}\n}\n\nstatic void\nsignature_tests(struct sshkey *k, struct sshkey *bad, const char *sig_alg)\n{\n\tu_char i, buf[2049];\n\tsize_t lens[] = {\n\t\t1, 2, 7, 8, 9, 15, 16, 17, 31, 32, 33, 127, 128, 129,\n\t\t255, 256, 257, 1023, 1024, 1025, 2047, 2048, 2049\n\t};\n\n\tfor (i = 0; i < (sizeof(lens)/sizeof(lens[0])); i++) {\n\t\ttest_subtest_info(\"%s key, banana length %zu\",\n\t\t    sshkey_type(k), lens[i]);\n\t\tbanana(buf, lens[i]);\n\t\tsignature_test(k, bad, sig_alg, buf, lens[i]);\n\t}\n}\n\nstatic struct sshkey *\nget_private(const char *n)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *ret;\n\n\tb = load_file(n);\n\tASSERT_INT_EQ(sshkey_parse_private_fileblob(b, \"\", &ret, NULL), 0);\n\tsshbuf_free(b);\n\treturn ret;\n}\n\nvoid\nsshkey_tests(void)\n{\n\tstruct sshkey *k1, *k2, *k3, *kf;\n#ifdef WITH_OPENSSL\n\tstruct sshkey *k4, *kr, *kd;\n#ifdef OPENSSL_HAS_ECC\n\tstruct sshkey *ke;\n#endif  \n#endif  \n\tstruct sshbuf *b;\n\n\tTEST_START(\"new invalid\");\n\tk1 = sshkey_new(-42);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_UNSPEC\");\n\tk1 = sshkey_new(KEY_UNSPEC);\n\tASSERT_PTR_NE(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef WITH_OPENSSL\n\tTEST_START(\"new/free KEY_RSA\");\n\tk1 = sshkey_new(KEY_RSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(k1->rsa, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"new/free KEY_DSA\");\n\tk1 = sshkey_new(KEY_DSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(k1->dsa, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"new/free KEY_ECDSA\");\n\tk1 = sshkey_new(KEY_ECDSA);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_EQ(k1->ecdsa, NULL);   \n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"new/free KEY_ED25519\");\n\tk1 = sshkey_new(KEY_ED25519);\n\tASSERT_PTR_NE(k1, NULL);\n\t \n\tASSERT_PTR_EQ(k1->ed25519_sk, NULL);\n\tASSERT_PTR_EQ(k1->ed25519_pk, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_RSA too small modulus\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 128, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_RSA too large modulus\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1 << 20, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_DSA wrong bits\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 2048, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"generate KEY_ECDSA wrong bits\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 42, &k1),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_PTR_EQ(k1, NULL);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif\n\n\tTEST_START(\"generate KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 767, &kr),\n\t    SSH_ERR_KEY_LENGTH);\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &kr), 0);\n\tASSERT_PTR_NE(kr, NULL);\n\tASSERT_PTR_NE(kr->rsa, NULL);\n\tASSERT_PTR_NE(rsa_n(kr), NULL);\n\tASSERT_PTR_NE(rsa_e(kr), NULL);\n\tASSERT_PTR_NE(rsa_p(kr), NULL);\n\tASSERT_INT_EQ(BN_num_bits(rsa_n(kr)), 1024);\n\tTEST_DONE();\n\n\tTEST_START(\"generate KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &kd), 0);\n\tASSERT_PTR_NE(kd, NULL);\n\tASSERT_PTR_NE(kd->dsa, NULL);\n\tASSERT_PTR_NE(dsa_g(kd), NULL);\n\tASSERT_PTR_NE(dsa_priv_key(kd), NULL);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"generate KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &ke), 0);\n\tASSERT_PTR_NE(ke, NULL);\n\tASSERT_PTR_NE(ke->ecdsa, NULL);\n\tASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);\n\tASSERT_PTR_NE(EC_KEY_get0_private_key(ke->ecdsa), NULL);\n\tTEST_DONE();\n#endif  \n#endif  \n\n\tTEST_START(\"generate KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_generate(KEY_ED25519, 256, &kf), 0);\n\tASSERT_PTR_NE(kf, NULL);\n\tASSERT_INT_EQ(kf->type, KEY_ED25519);\n\tASSERT_PTR_NE(kf->ed25519_pk, NULL);\n\tASSERT_PTR_NE(kf->ed25519_sk, NULL);\n\tTEST_DONE();\n\n#ifdef WITH_OPENSSL\n\tTEST_START(\"demote KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_from_private(kr, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kr, k1);\n\tASSERT_INT_EQ(k1->type, KEY_RSA);\n\tASSERT_PTR_NE(k1->rsa, NULL);\n\tASSERT_PTR_NE(rsa_n(k1), NULL);\n\tASSERT_PTR_NE(rsa_e(k1), NULL);\n\tASSERT_PTR_EQ(rsa_p(k1), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_RSA/demoted KEY_RSA\");\n\tASSERT_INT_EQ(sshkey_equal(kr, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n\tTEST_START(\"demote KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_from_private(kd, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kd, k1);\n\tASSERT_INT_EQ(k1->type, KEY_DSA);\n\tASSERT_PTR_NE(k1->dsa, NULL);\n\tASSERT_PTR_NE(dsa_g(k1), NULL);\n\tASSERT_PTR_EQ(dsa_priv_key(k1), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_DSA/demoted KEY_DSA\");\n\tASSERT_INT_EQ(sshkey_equal(kd, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"demote KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_from_private(ke, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(ke, k1);\n\tASSERT_INT_EQ(k1->type, KEY_ECDSA);\n\tASSERT_PTR_NE(k1->ecdsa, NULL);\n\tASSERT_INT_EQ(k1->ecdsa_nid, ke->ecdsa_nid);\n\tASSERT_PTR_NE(EC_KEY_get0_public_key(ke->ecdsa), NULL);\n\tASSERT_PTR_EQ(EC_KEY_get0_private_key(k1->ecdsa), NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_ECDSA/demoted KEY_ECDSA\");\n\tASSERT_INT_EQ(sshkey_equal(ke, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n#endif  \n#endif  \n\n\tTEST_START(\"demote KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_from_private(kf, &k1), 0);\n\tASSERT_PTR_NE(k1, NULL);\n\tASSERT_PTR_NE(kf, k1);\n\tASSERT_INT_EQ(k1->type, KEY_ED25519);\n\tASSERT_PTR_NE(k1->ed25519_pk, NULL);\n\tASSERT_PTR_EQ(k1->ed25519_sk, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"equal KEY_ED25519/demoted KEY_ED25519\");\n\tASSERT_INT_EQ(sshkey_equal(kf, k1), 1);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef WITH_OPENSSL\n\tTEST_START(\"equal mismatched key types\");\n\tASSERT_INT_EQ(sshkey_equal(kd, kr), 0);\n#ifdef OPENSSL_HAS_ECC\n\tASSERT_INT_EQ(sshkey_equal(kd, ke), 0);\n\tASSERT_INT_EQ(sshkey_equal(kr, ke), 0);\n\tASSERT_INT_EQ(sshkey_equal(ke, kf), 0);\n#endif  \n\tASSERT_INT_EQ(sshkey_equal(kd, kf), 0);\n\tTEST_DONE();\n#endif  \n\n\tTEST_START(\"equal different keys\");\n#ifdef WITH_OPENSSL\n\tASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kr, k1), 0);\n\tsshkey_free(k1);\n\tASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kd, k1), 0);\n\tsshkey_free(k1);\n#ifdef OPENSSL_HAS_ECC\n\tASSERT_INT_EQ(sshkey_generate(KEY_ECDSA, 256, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(ke, k1), 0);\n\tsshkey_free(k1);\n#endif  \n#endif  \n\tASSERT_INT_EQ(sshkey_generate(KEY_ED25519, 256, &k1), 0);\n\tASSERT_INT_EQ(sshkey_equal(kf, k1), 0);\n\tsshkey_free(k1);\n\tTEST_DONE();\n\n#ifdef WITH_OPENSSL\n\tsshkey_free(kr);\n\tsshkey_free(kd);\n#ifdef OPENSSL_HAS_ECC\n\tsshkey_free(ke);\n#endif  \n#endif  \n\tsshkey_free(kf);\n\n\tTEST_START(\"certify key\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_1.pub\"),\n\t    &k1, NULL), 0);\n\tk2 = get_private(\"ed25519_2\");\n\tASSERT_INT_EQ(sshkey_to_certified(k1), 0);\n\tASSERT_PTR_NE(k1->cert, NULL);\n\tk1->cert->type = SSH2_CERT_TYPE_USER;\n\tk1->cert->serial = 1234;\n\tk1->cert->key_id = strdup(\"estragon\");\n\tASSERT_PTR_NE(k1->cert->key_id, NULL);\n\tk1->cert->principals = calloc(4, sizeof(*k1->cert->principals));\n\tASSERT_PTR_NE(k1->cert->principals, NULL);\n\tk1->cert->principals[0] = strdup(\"estragon\");\n\tk1->cert->principals[1] = strdup(\"vladimir\");\n\tk1->cert->principals[2] = strdup(\"pozzo\");\n\tk1->cert->principals[3] = strdup(\"lucky\");\n\tASSERT_PTR_NE(k1->cert->principals[0], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[1], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[2], NULL);\n\tASSERT_PTR_NE(k1->cert->principals[3], NULL);\n\tk1->cert->nprincipals = 4;\n\tk1->cert->valid_after = 0;\n\tk1->cert->valid_before = (u_int64_t)-1;\n\tsshbuf_free(k1->cert->critical);\n\tk1->cert->critical = sshbuf_new();\n\tASSERT_PTR_NE(k1->cert->critical, NULL);\n\tsshbuf_free(k1->cert->extensions);\n\tk1->cert->extensions = sshbuf_new();\n\tASSERT_PTR_NE(k1->cert->extensions, NULL);\n\tput_opt(k1->cert->critical, \"force-command\", \"/usr/bin/true\");\n\tput_opt(k1->cert->critical, \"source-address\", \"127.0.0.1\");\n\tput_opt(k1->cert->extensions, \"permit-X11-forwarding\", NULL);\n\tput_opt(k1->cert->extensions, \"permit-agent-forwarding\", NULL);\n\tASSERT_INT_EQ(sshkey_from_private(k2, &k1->cert->signature_key), 0);\n\tASSERT_INT_EQ(sshkey_certify(k1, k2, NULL, NULL, NULL), 0);\n\tb = sshbuf_new();\n\tASSERT_PTR_NE(b, NULL);\n\tASSERT_INT_EQ(sshkey_putb(k1, b), 0);\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k3), 0);\n\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tsshkey_free(k3);\n\tsshbuf_reset(b);\n\tTEST_DONE();\n\n#ifdef WITH_OPENSSL\n\tTEST_START(\"sign and verify RSA\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"ssh-rsa\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA-SHA256\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"rsa-sha2-256\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify RSA-SHA512\");\n\tk1 = get_private(\"rsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, \"rsa-sha2-512\");\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n\tTEST_START(\"sign and verify DSA\");\n\tk1 = get_private(\"dsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"dsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n#ifdef OPENSSL_HAS_ECC\n\tTEST_START(\"sign and verify ECDSA\");\n\tk1 = get_private(\"ecdsa_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ecdsa_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n#endif  \n#endif  \n\n\tTEST_START(\"sign and verify ED25519\");\n\tk1 = get_private(\"ed25519_1\");\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"ed25519_2.pub\"), &k2,\n\t    NULL), 0);\n\tsignature_tests(k1, k2, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tTEST_DONE();\n\n#ifdef WITH_OPENSSL\n\tTEST_START(\"nested certificate\");\n\tASSERT_INT_EQ(sshkey_load_cert(test_data_file(\"rsa_1\"), &k1), 0);\n\tASSERT_INT_EQ(sshkey_load_public(test_data_file(\"rsa_1.pub\"), &k2,\n\t    NULL), 0);\n\tk3 = get_private(\"rsa_1\");\n\tbuild_cert(b, k2, \"ssh-rsa-cert-v01@openssh.com\", k3, k1, NULL);\n\tASSERT_INT_EQ(sshkey_from_blob(sshbuf_ptr(b), sshbuf_len(b), &k4),\n\t    SSH_ERR_KEY_CERT_INVALID_SIGN_KEY);\n\tASSERT_PTR_EQ(k4, NULL);\n\tsshkey_free(k1);\n\tsshkey_free(k2);\n\tsshkey_free(k3);\n\tsshbuf_free(b);\n\tTEST_DONE();\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}