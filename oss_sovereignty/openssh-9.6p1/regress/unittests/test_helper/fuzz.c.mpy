{
  "module_name": "fuzz.c",
  "hash_id": "4ff5fb4963eb58972a3a6bb4f1ec2ad7471906bf9a7d29f70f6d6316d4cc742c",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/test_helper/fuzz.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n\n#include \"test_helper.h\"\n#include \"atomicio.h\"\n\n \n\n#ifdef FUZZ_DEBUG\n# define FUZZ_DBG(x) do { \\\n\t\tprintf(\"%s:%d %s: \", __FILE__, __LINE__, __func__); \\\n\t\tprintf x; \\\n\t\tprintf(\"\\n\"); \\\n\t\tfflush(stdout); \\\n\t} while (0)\n#else\n# define FUZZ_DBG(x)\n#endif\n\n \ntypedef unsigned long long fuzz_ullong;\n\n \nstatic const char fuzz_b64chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstruct fuzz {\n\t \n\tint strategy;\n\n\t \n\tint strategies;\n\n\t \n\tvoid *seed;\n\tsize_t slen;\n\n\t \n\tu_char *fuzzed;\n\n\t \n\tsize_t o1, o2;\n};\n\nstatic const char *\nfuzz_ntop(u_int n)\n{\n\tswitch (n) {\n\tcase 0:\n\t\treturn \"NONE\";\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn \"FUZZ_1_BIT_FLIP\";\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn \"FUZZ_2_BIT_FLIP\";\n\tcase FUZZ_1_BYTE_FLIP:\n\t\treturn \"FUZZ_1_BYTE_FLIP\";\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn \"FUZZ_2_BYTE_FLIP\";\n\tcase FUZZ_TRUNCATE_START:\n\t\treturn \"FUZZ_TRUNCATE_START\";\n\tcase FUZZ_TRUNCATE_END:\n\t\treturn \"FUZZ_TRUNCATE_END\";\n\tcase FUZZ_BASE64:\n\t\treturn \"FUZZ_BASE64\";\n\tdefault:\n\t\tabort();\n\t}\n}\n\nstatic int\nfuzz_fmt(struct fuzz *fuzz, char *s, size_t n)\n{\n\tif (fuzz == NULL)\n\t\treturn -1;\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (bit: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen * 8, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bits: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen * 8) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen * 8) * fuzz->slen * 8,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (byte: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tsnprintf(s, n, \"%s case %llu of %llu (bytes: %zu, %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (((fuzz_ullong)fuzz->o2) * fuzz->slen) + fuzz->o1,\n\t\t    ((fuzz_ullong)fuzz->slen) * fuzz->slen,\n\t\t    fuzz->o1, fuzz->o2);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_START:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_TRUNCATE_END:\n\t\tsnprintf(s, n, \"%s case %zu of %zu (offset: %zu)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    fuzz->o1, fuzz->slen, fuzz->o1);\n\t\treturn 0;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tsnprintf(s, n, \"%s case %llu of %llu (offset: %zu char: %c)\\n\",\n\t\t    fuzz_ntop(fuzz->strategy),\n\t\t    (fuzz->o1 * (fuzz_ullong)64) + fuzz->o2,\n\t\t    fuzz->slen * (fuzz_ullong)64, fuzz->o1,\n\t\t    fuzz_b64chars[fuzz->o2]);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t\tabort();\n\t}\n}\n\nstatic void\ndump(u_char *p, size_t len)\n{\n\tsize_t i, j;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(stderr, \"%.4zd: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(stderr, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"   \");\n\t\t}\n\t\tfprintf(stderr, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(stderr, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\nfuzz_dump(struct fuzz *fuzz)\n{\n\tchar buf[256];\n\n\tif (fuzz_fmt(fuzz, buf, sizeof(buf)) != 0) {\n\t\tfprintf(stderr, \"%s: fuzz invalid\\n\", __func__);\n\t\tabort();\n\t}\n\tfputs(buf, stderr);\n\tfprintf(stderr, \"fuzz original %p len = %zu\\n\", fuzz->seed, fuzz->slen);\n\tdump(fuzz->seed, fuzz->slen);\n\tfprintf(stderr, \"fuzz context %p len = %zu\\n\", fuzz, fuzz_len(fuzz));\n\tdump(fuzz_ptr(fuzz), fuzz_len(fuzz));\n}\n\nstatic struct fuzz *last_fuzz;\n\nstatic void\nsiginfo(int unused __attribute__((__unused__)))\n{\n\tchar buf[256];\n\n\ttest_info(buf, sizeof(buf));\n\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n\tif (last_fuzz != NULL) {\n\t\tfuzz_fmt(last_fuzz, buf, sizeof(buf));\n\t\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n\t}\n}\n\nstruct fuzz *\nfuzz_begin(u_int strategies, const void *p, size_t l)\n{\n\tstruct fuzz *ret = calloc(sizeof(*ret), 1);\n\n\tassert(p != NULL);\n\tassert(ret != NULL);\n\tret->seed = malloc(l);\n\tassert(ret->seed != NULL);\n\tmemcpy(ret->seed, p, l);\n\tret->slen = l;\n\tret->strategies = strategies;\n\n\tassert(ret->slen < SIZE_MAX / 8);\n\tassert(ret->strategies <= (FUZZ_MAX|(FUZZ_MAX-1)));\n\n\tFUZZ_DBG((\"begin, ret = %p\", ret));\n\n\tfuzz_next(ret);\n\n\tlast_fuzz = ret;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n\n\treturn ret;\n}\n\nvoid\nfuzz_cleanup(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"cleanup, fuzz = %p\", fuzz));\n\tlast_fuzz = NULL;\n#ifdef SIGINFO\n\tsignal(SIGINFO, SIG_DFL);\n#endif\n\tsignal(SIGUSR1, SIG_DFL);\n\tassert(fuzz != NULL);\n\tassert(fuzz->seed != NULL);\n\tassert(fuzz->fuzzed != NULL);\n\tfree(fuzz->seed);\n\tfree(fuzz->fuzzed);\n\tfree(fuzz);\n}\n\nstatic int\nfuzz_strategy_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategy = %s, o1 = %zu, o2 = %zu, slen = %zu\",\n\t    fuzz, fuzz_ntop(fuzz->strategy), fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\treturn fuzz->o1 >= fuzz->slen * 8;\n\tcase FUZZ_2_BIT_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen * 8;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\treturn fuzz->o2 >= fuzz->slen;\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->o1 >= fuzz->slen;\n\tdefault:\n\t\tabort();\n\t}\n}\n\nvoid\nfuzz_next(struct fuzz *fuzz)\n{\n\tu_int i;\n\n\tFUZZ_DBG((\"start, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n\n\tif (fuzz->strategy == 0 || fuzz_strategy_done(fuzz)) {\n\t\t \n\t\tif (fuzz->fuzzed == NULL) {\n\t\t\tFUZZ_DBG((\"alloc\"));\n\t\t\tfuzz->fuzzed = calloc(fuzz->slen, 1);\n\t\t}\n\t\t \n\t\tFUZZ_DBG((\"advance\"));\n\t\tfor (i = 1; i <= FUZZ_MAX; i <<= 1) {\n\t\t\tif ((fuzz->strategies & i) != 0) {\n\t\t\t\tfuzz->strategy = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFUZZ_DBG((\"selected = %u\", fuzz->strategy));\n\t\tif (fuzz->strategy == 0) {\n\t\t\tFUZZ_DBG((\"done, no more strategies\"));\n\t\t\treturn;\n\t\t}\n\t\tfuzz->strategies &= ~(fuzz->strategy);\n\t\tfuzz->o1 = fuzz->o2 = 0;\n\t}\n\n\tassert(fuzz->fuzzed != NULL);\n\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BIT_FLIP:\n\t\tassert(fuzz->o1 / 8 < fuzz->slen);\n\t\tassert(fuzz->o2 / 8 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1 / 8] ^= 1 << (fuzz->o1 % 8);\n\t\tfuzz->fuzzed[fuzz->o2 / 8] ^= 1 << (fuzz->o2 % 8);\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen * 8) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_1_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_2_BYTE_FLIP:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] ^= 0xff;\n\t\tfuzz->fuzzed[fuzz->o2] ^= 0xff;\n\t\tfuzz->o1++;\n\t\tif (fuzz->o1 >= fuzz->slen) {\n\t\t\tfuzz->o1 = 0;\n\t\t\tfuzz->o2++;\n\t\t}\n\t\tbreak;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->o1++;\n\t\tbreak;\n\tcase FUZZ_BASE64:\n\t\tassert(fuzz->o1 < fuzz->slen);\n\t\tassert(fuzz->o2 < sizeof(fuzz_b64chars) - 1);\n\t\tmemcpy(fuzz->fuzzed, fuzz->seed, fuzz->slen);\n\t\tfuzz->fuzzed[fuzz->o1] = fuzz_b64chars[fuzz->o2];\n\t\tfuzz->o2++;\n\t\tif (fuzz->o2 >= sizeof(fuzz_b64chars) - 1) {\n\t\t\tfuzz->o2 = 0;\n\t\t\tfuzz->o1++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tFUZZ_DBG((\"done, fuzz = %p, strategy = %s, strategies = 0x%lx, \"\n\t    \"o1 = %zu, o2 = %zu, slen = %zu\", fuzz, fuzz_ntop(fuzz->strategy),\n\t    (u_long)fuzz->strategies, fuzz->o1, fuzz->o2, fuzz->slen));\n}\n\nint\nfuzz_matches_original(struct fuzz *fuzz)\n{\n\tif (fuzz_len(fuzz) != fuzz->slen)\n\t\treturn 0;\n\treturn memcmp(fuzz_ptr(fuzz), fuzz->seed, fuzz->slen) == 0;\n}\n\nint\nfuzz_done(struct fuzz *fuzz)\n{\n\tFUZZ_DBG((\"fuzz = %p, strategies = 0x%lx\", fuzz,\n\t    (u_long)fuzz->strategies));\n\n\treturn fuzz_strategy_done(fuzz) && fuzz->strategies == 0;\n}\n\nsize_t\nfuzz_len(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->slen;\n\tcase FUZZ_TRUNCATE_START:\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->slen - fuzz->o1;\n\tdefault:\n\t\tabort();\n\t}\n}\n\nu_char *\nfuzz_ptr(struct fuzz *fuzz)\n{\n\tassert(fuzz->fuzzed != NULL);\n\tswitch (fuzz->strategy) {\n\tcase FUZZ_1_BIT_FLIP:\n\tcase FUZZ_2_BIT_FLIP:\n\tcase FUZZ_1_BYTE_FLIP:\n\tcase FUZZ_2_BYTE_FLIP:\n\tcase FUZZ_BASE64:\n\t\treturn fuzz->fuzzed;\n\tcase FUZZ_TRUNCATE_START:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed + fuzz->o1;\n\tcase FUZZ_TRUNCATE_END:\n\t\tassert(fuzz->o1 <= fuzz->slen);\n\t\treturn fuzz->fuzzed;\n\tdefault:\n\t\tabort();\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}