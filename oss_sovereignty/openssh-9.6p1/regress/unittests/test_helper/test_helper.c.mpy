{
  "module_name": "test_helper.c",
  "hash_id": "4d18087a66ba9a2a731727d03d5e8978a0a408d197ba47bf06003f6a41b098f4",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/test_helper/test_helper.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <stdarg.h>\n#include <fcntl.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <unistd.h>\n#include <signal.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#endif\n\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n# include <vis.h>\n#endif\n\n#define MINIMUM(a, b)    (((a) < (b)) ? (a) : (b))\n\n#include \"entropy.h\"\n#include \"test_helper.h\"\n#include \"atomicio.h\"\n\n#define TEST_CHECK_INT(r, pred) do {\t\t\\\n\t\tswitch (pred) {\t\t\t\\\n\t\tcase TEST_EQ:\t\t\t\\\n\t\t\tif (r == 0)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_NE:\t\t\t\\\n\t\t\tif (r != 0)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_LT:\t\t\t\\\n\t\t\tif (r < 0)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_LE:\t\t\t\\\n\t\t\tif (r <= 0)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_GT:\t\t\t\\\n\t\t\tif (r > 0)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_GE:\t\t\t\\\n\t\t\tif (r >= 0)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tdefault:\t\t\t\\\n\t\t\tabort();\t\t\\\n\t\t}\t\t\t\t\\\n\t} while (0)\n\n#define TEST_CHECK(x1, x2, pred) do {\t\t\\\n\t\tswitch (pred) {\t\t\t\\\n\t\tcase TEST_EQ:\t\t\t\\\n\t\t\tif (x1 == x2)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_NE:\t\t\t\\\n\t\t\tif (x1 != x2)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_LT:\t\t\t\\\n\t\t\tif (x1 < x2)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_LE:\t\t\t\\\n\t\t\tif (x1 <= x2)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_GT:\t\t\t\\\n\t\t\tif (x1 > x2)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tcase TEST_GE:\t\t\t\\\n\t\t\tif (x1 >= x2)\t\t\\\n\t\t\t\treturn;\t\t\\\n\t\t\tbreak;\t\t\t\\\n\t\tdefault:\t\t\t\\\n\t\t\tabort();\t\t\\\n\t\t}\t\t\t\t\\\n\t} while (0)\n\nextern char *__progname;\n\nstatic int verbose_mode = 0;\nstatic int quiet_mode = 0;\nstatic char *active_test_name = NULL;\nstatic u_int test_number = 0;\nstatic test_onerror_func_t *test_onerror = NULL;\nstatic void *onerror_ctx = NULL;\nstatic const char *data_dir = NULL;\nstatic char subtest_info[512];\nstatic int fast = 0;\nstatic int slow = 0;\n\nint\nmain(int argc, char **argv)\n{\n\tint ch;\n\n\tseed_rng();\n#ifdef WITH_OPENSSL\n\tERR_load_crypto_strings();\n#endif\n\n\t \n\tif (__progname == NULL) {\n\t\t__progname = strrchr(argv[0], '/');\n\t\tif (__progname == NULL || __progname[1] == '\\0')\n\t\t\t__progname = argv[0];\t\n\t\telse\n\t\t\t__progname++;\n\t\tif ((__progname = strdup(__progname)) == NULL) {\n\t\t\tfprintf(stderr, \"strdup failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\twhile ((ch = getopt(argc, argv, \"Ffvqd:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'F':\n\t\t\tslow = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfast = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdata_dir = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tverbose_mode = 0;\n\t\t\tquiet_mode = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose_mode = 1;\n\t\t\tquiet_mode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unrecognised command line option\\n\");\n\t\t\tfprintf(stderr, \"Usage: %s [-v]\\n\", __progname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\tif (!quiet_mode)\n\t\tprintf(\"%s: \", __progname);\n\tif (verbose_mode)\n\t\tprintf(\"\\n\");\n\n\ttests();\n\n\tif (!quiet_mode)\n\t\tprintf(\" %u tests ok\\n\", test_number);\n\treturn 0;\n}\n\nint\ntest_is_verbose(void)\n{\n\treturn verbose_mode;\n}\n\nint\ntest_is_quiet(void)\n{\n\treturn quiet_mode;\n}\n\nint\ntest_is_fast(void)\n{\n\treturn fast;\n}\n\nint\ntest_is_slow(void)\n{\n\treturn slow;\n}\n\nconst char *\ntest_data_file(const char *name)\n{\n\tstatic char ret[PATH_MAX];\n\n\tif (data_dir != NULL)\n\t\tsnprintf(ret, sizeof(ret), \"%s/%s\", data_dir, name);\n\telse\n\t\tstrlcpy(ret, name, sizeof(ret));\n\tif (access(ret, F_OK) != 0) {\n\t\tfprintf(stderr, \"Cannot access data file %s: %s\\n\",\n\t\t    ret, strerror(errno));\n\t\texit(1);\n\t}\n\treturn ret;\n}\n\nvoid\ntest_info(char *s, size_t len)\n{\n\tsnprintf(s, len, \"In test %u: \\\"%s\\\"%s%s\\n\", test_number,\n\t    active_test_name == NULL ? \"<none>\" : active_test_name,\n\t    *subtest_info != '\\0' ? \" - \" : \"\", subtest_info);\n}\n\nstatic void\nsiginfo(int unused __attribute__((__unused__)))\n{\n\tchar buf[256];\n\n\ttest_info(buf, sizeof(buf));\n\tatomicio(vwrite, STDERR_FILENO, buf, strlen(buf));\n}\n\nvoid\ntest_start(const char *n)\n{\n\tassert(active_test_name == NULL);\n\tassert((active_test_name = strdup(n)) != NULL);\n\t*subtest_info = '\\0';\n\tif (verbose_mode)\n\t\tprintf(\"test %u - \\\"%s\\\": \", test_number, active_test_name);\n\ttest_number++;\n#ifdef SIGINFO\n\tsignal(SIGINFO, siginfo);\n#endif\n\tsignal(SIGUSR1, siginfo);\n}\n\nvoid\nset_onerror_func(test_onerror_func_t *f, void *ctx)\n{\n\ttest_onerror = f;\n\tonerror_ctx = ctx;\n}\n\nvoid\ntest_done(void)\n{\n\t*subtest_info = '\\0';\n\tassert(active_test_name != NULL);\n\tfree(active_test_name);\n\tactive_test_name = NULL;\n\tif (verbose_mode)\n\t\tprintf(\"OK\\n\");\n\telse if (!quiet_mode) {\n\t\tprintf(\".\");\n\t\tfflush(stdout);\n\t}\n}\n\nvoid\ntest_subtest_info(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvsnprintf(subtest_info, sizeof(subtest_info), fmt, ap);\n\tva_end(ap);\n}\n\nvoid\nssl_err_check(const char *file, int line)\n{\n#ifdef WITH_OPENSSL\n\tlong openssl_error = ERR_get_error();\n\n\tif (openssl_error == 0)\n\t\treturn;\n\n\tfprintf(stderr, \"\\n%s:%d: uncaught OpenSSL error: %s\",\n\t    file, line, ERR_error_string(openssl_error, NULL));\n#else  \n\tfprintf(stderr, \"\\n%s:%d: uncaught OpenSSL error \",\n\t    file, line);\n#endif  \n\tabort();\n}\n\nstatic const char *\npred_name(enum test_predicate p)\n{\n\tswitch (p) {\n\tcase TEST_EQ:\n\t\treturn \"EQ\";\n\tcase TEST_NE:\n\t\treturn \"NE\";\n\tcase TEST_LT:\n\t\treturn \"LT\";\n\tcase TEST_LE:\n\t\treturn \"LE\";\n\tcase TEST_GT:\n\t\treturn \"GT\";\n\tcase TEST_GE:\n\t\treturn \"GE\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic void\ntest_die(void)\n{\n\tif (test_onerror != NULL)\n\t\ttest_onerror(onerror_ctx);\n\tabort();\n}\n\nstatic void\ntest_header(const char *file, int line, const char *a1, const char *a2,\n    const char *name, enum test_predicate pred)\n{\n\tfprintf(stderr, \"\\n%s:%d test #%u \\\"%s\\\"%s%s\\n\", \n\t    file, line, test_number, active_test_name,\n\t    *subtest_info != '\\0' ? \" - \" : \"\", subtest_info);\n\tfprintf(stderr, \"ASSERT_%s_%s(%s%s%s) failed:\\n\",\n\t    name, pred_name(pred), a1,\n\t    a2 != NULL ? \", \" : \"\", a2 != NULL ? a2 : \"\");\n}\n\n#ifdef WITH_OPENSSL\nvoid\nassert_bignum(const char *file, int line, const char *a1, const char *a2,\n    const BIGNUM *aa1, const BIGNUM *aa2, enum test_predicate pred)\n{\n\tint r = BN_cmp(aa1, aa2);\n\n\tTEST_CHECK_INT(r, pred);\n\ttest_header(file, line, a1, a2, \"BIGNUM\", pred);\n\tfprintf(stderr, \"%12s = 0x%s\\n\", a1, BN_bn2hex(aa1));\n\tfprintf(stderr, \"%12s = 0x%s\\n\", a2, BN_bn2hex(aa2));\n\ttest_die();\n}\n#endif\n\nvoid\nassert_string(const char *file, int line, const char *a1, const char *a2,\n    const char *aa1, const char *aa2, enum test_predicate pred)\n{\n\tint r;\n\n\t \n\tassert_ptr(file, line, a1, \"NULL\", aa1, NULL, TEST_NE);\n\tassert_ptr(file, line, a2, \"NULL\", aa2, NULL, TEST_NE);\n\n\tr = strcmp(aa1, aa2);\n\tTEST_CHECK_INT(r, pred);\n\ttest_header(file, line, a1, a2, \"STRING\", pred);\n\tfprintf(stderr, \"%12s = %s (len %zu)\\n\", a1, aa1, strlen(aa1));\n\tfprintf(stderr, \"%12s = %s (len %zu)\\n\", a2, aa2, strlen(aa2));\n\ttest_die();\n}\n\nstatic char *\ntohex(const void *_s, size_t l)\n{\n\tu_int8_t *s = (u_int8_t *)_s;\n\tsize_t i, j;\n\tconst char *hex = \"0123456789abcdef\";\n\tchar *r = malloc((l * 2) + 1);\n\n\tassert(r != NULL);\n\tfor (i = j = 0; i < l; i++) {\n\t\tr[j++] = hex[(s[i] >> 4) & 0xf];\n\t\tr[j++] = hex[s[i] & 0xf];\n\t}\n\tr[j] = '\\0';\n\treturn r;\n}\n\nvoid\nassert_mem(const char *file, int line, const char *a1, const char *a2,\n    const void *aa1, const void *aa2, size_t l, enum test_predicate pred)\n{\n\tint r;\n\tchar *aa1_tohex = NULL;\n\tchar *aa2_tohex = NULL;\n\n\tif (l == 0)\n\t\treturn;\n\t \n\tassert_ptr(file, line, a1, \"NULL\", aa1, NULL, TEST_NE);\n\tassert_ptr(file, line, a2, \"NULL\", aa2, NULL, TEST_NE);\n\n\tr = memcmp(aa1, aa2, l);\n\tTEST_CHECK_INT(r, pred);\n\ttest_header(file, line, a1, a2, \"STRING\", pred);\n\taa1_tohex = tohex(aa1, MINIMUM(l, 256));\n\taa2_tohex = tohex(aa2, MINIMUM(l, 256));\n\tfprintf(stderr, \"%12s = %s (len %zu)\\n\", a1, aa1_tohex, l);\n\tfprintf(stderr, \"%12s = %s (len %zu)\\n\", a2, aa2_tohex, l);\n\tfree(aa1_tohex);\n\tfree(aa2_tohex);\n\ttest_die();\n}\n\nstatic int\nmemvalcmp(const u_int8_t *s, u_char v, size_t l, size_t *where)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < l; i++) {\n\t\tif (s[i] != v) {\n\t\t\t*where = i;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nassert_mem_filled(const char *file, int line, const char *a1,\n    const void *aa1, u_char v, size_t l, enum test_predicate pred)\n{\n\tsize_t where = -1;\n\tint r;\n\tchar tmp[64];\n\tchar *aa1_tohex = NULL;\n\n\tif (l == 0)\n\t\treturn;\n\t \n\tassert_ptr(file, line, a1, \"NULL\", aa1, NULL, TEST_NE);\n\n\tr = memvalcmp(aa1, v, l, &where);\n\tTEST_CHECK_INT(r, pred);\n\ttest_header(file, line, a1, NULL, \"MEM_ZERO\", pred);\n\taa1_tohex = tohex(aa1, MINIMUM(l, 20));\n\tfprintf(stderr, \"%20s = %s%s (len %zu)\\n\", a1,\n\t    aa1_tohex, l > 20 ? \"...\" : \"\", l);\n\tfree(aa1_tohex);\n\tsnprintf(tmp, sizeof(tmp), \"(%s)[%zu]\", a1, where);\n\tfprintf(stderr, \"%20s = 0x%02x (expected 0x%02x)\\n\", tmp,\n\t    ((u_char *)aa1)[where], v);\n\ttest_die();\n}\n\nvoid\nassert_int(const char *file, int line, const char *a1, const char *a2,\n    int aa1, int aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"INT\", pred);\n\tfprintf(stderr, \"%12s = %d\\n\", a1, aa1);\n\tfprintf(stderr, \"%12s = %d\\n\", a2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_size_t(const char *file, int line, const char *a1, const char *a2,\n    size_t aa1, size_t aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"SIZE_T\", pred);\n\tfprintf(stderr, \"%12s = %zu\\n\", a1, aa1);\n\tfprintf(stderr, \"%12s = %zu\\n\", a2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_u_int(const char *file, int line, const char *a1, const char *a2,\n    u_int aa1, u_int aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"U_INT\", pred);\n\tfprintf(stderr, \"%12s = %u / 0x%x\\n\", a1, aa1, aa1);\n\tfprintf(stderr, \"%12s = %u / 0x%x\\n\", a2, aa2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_long(const char *file, int line, const char *a1, const char *a2,\n    long aa1, long aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"LONG\", pred);\n\tfprintf(stderr, \"%12s = %ld / 0x%lx\\n\", a1, aa1, aa1);\n\tfprintf(stderr, \"%12s = %ld / 0x%lx\\n\", a2, aa2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_long_long(const char *file, int line, const char *a1, const char *a2,\n    long long aa1, long long aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"LONG LONG\", pred);\n\tfprintf(stderr, \"%12s = %lld / 0x%llx\\n\", a1, aa1, aa1);\n\tfprintf(stderr, \"%12s = %lld / 0x%llx\\n\", a2, aa2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_char(const char *file, int line, const char *a1, const char *a2,\n    char aa1, char aa2, enum test_predicate pred)\n{\n\tchar buf[8];\n\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"CHAR\", pred);\n\tfprintf(stderr, \"%12s = '%s' / 0x02%x\\n\", a1,\n\t    vis(buf, aa1, VIS_SAFE|VIS_NL|VIS_TAB|VIS_OCTAL, 0), aa1);\n\tfprintf(stderr, \"%12s = '%s' / 0x02%x\\n\", a1,\n\t    vis(buf, aa2, VIS_SAFE|VIS_NL|VIS_TAB|VIS_OCTAL, 0), aa2);\n\ttest_die();\n}\n\nvoid\nassert_u8(const char *file, int line, const char *a1, const char *a2,\n    u_int8_t aa1, u_int8_t aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"U8\", pred);\n\tfprintf(stderr, \"%12s = 0x%02x %u\\n\", a1, aa1, aa1);\n\tfprintf(stderr, \"%12s = 0x%02x %u\\n\", a2, aa2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_u16(const char *file, int line, const char *a1, const char *a2,\n    u_int16_t aa1, u_int16_t aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"U16\", pred);\n\tfprintf(stderr, \"%12s = 0x%04x %u\\n\", a1, aa1, aa1);\n\tfprintf(stderr, \"%12s = 0x%04x %u\\n\", a2, aa2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_u32(const char *file, int line, const char *a1, const char *a2,\n    u_int32_t aa1, u_int32_t aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"U32\", pred);\n\tfprintf(stderr, \"%12s = 0x%08x %u\\n\", a1, aa1, aa1);\n\tfprintf(stderr, \"%12s = 0x%08x %u\\n\", a2, aa2, aa2);\n\ttest_die();\n}\n\nvoid\nassert_u64(const char *file, int line, const char *a1, const char *a2,\n    u_int64_t aa1, u_int64_t aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"U64\", pred);\n\tfprintf(stderr, \"%12s = 0x%016llx %llu\\n\", a1,\n\t    (unsigned long long)aa1, (unsigned long long)aa1);\n\tfprintf(stderr, \"%12s = 0x%016llx %llu\\n\", a2,\n\t    (unsigned long long)aa2, (unsigned long long)aa2);\n\ttest_die();\n}\n\nvoid\nassert_ptr(const char *file, int line, const char *a1, const char *a2,\n    const void *aa1, const void *aa2, enum test_predicate pred)\n{\n\tTEST_CHECK(aa1, aa2, pred);\n\ttest_header(file, line, a1, a2, \"PTR\", pred);\n\tfprintf(stderr, \"%12s = %p\\n\", a1, aa1);\n\tfprintf(stderr, \"%12s = %p\\n\", a2, aa2);\n\ttest_die();\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}