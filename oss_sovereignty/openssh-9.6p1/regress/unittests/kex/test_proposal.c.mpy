{
  "module_name": "test_proposal.c",
  "hash_id": "f3f8da0149fd914ee82444ababedd22b905ad017e8ab15a3b4e1c9cbf7f45bf0",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/kex/test_proposal.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <signal.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n#include \"../test_helper/test_helper.h\"\n\n#include \"cipher.h\"\n#include \"compat.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"kex.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"xmalloc.h\"\n\nvoid kex_proposal_tests(void);\nvoid kex_proposal_populate_tests(void);\n\n#define CURVE25519 \"curve25519-sha256@libssh.org\"\n#define DHGEX1 \"diffie-hellman-group-exchange-sha1\"\n#define DHGEX256 \"diffie-hellman-group-exchange-sha256\"\n#define KEXALGOS CURVE25519\",\"DHGEX256\",\"DHGEX1\nvoid\nkex_proposal_tests(void)\n{\n\tsize_t i;\n\tstruct ssh ssh;\n\tchar *result, *out, *in;\n\tstruct {\n\t\tchar *in;\t \n\t\tchar *out;\n\t\tint compat;\n\t} tests[] = {\n\t\t{ KEXALGOS, KEXALGOS, 0},\n\t\t{ KEXALGOS, DHGEX256\",\"DHGEX1, SSH_BUG_CURVE25519PAD },\n\t\t{ KEXALGOS, CURVE25519, SSH_OLD_DHGEX },\n\t\t{ \"a,\"KEXALGOS, \"a\", SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX },\n\t\t \n\t\t \n\t};\n\n\tTEST_START(\"compat_kex_proposal\");\n\tfor (i = 0; i < sizeof(tests) / sizeof(*tests); i++) {\n\t\tssh.compat = tests[i].compat;\n\t\t \n\t\tresult = compat_kex_proposal(&ssh, tests[i].in);\n\t\tASSERT_STRING_EQ(result, tests[i].out);\n\t\tfree(result);\n\t\t \n\t\tin = kex_names_cat(\"a\", tests[i].in);\n\t\tout = kex_names_cat(\"a\", tests[i].out);\n\t\tresult = compat_kex_proposal(&ssh, in);\n\t\tASSERT_STRING_EQ(result, out);\n\t\tfree(result); free(in); free(out);\n\t\t \n\t\tin = kex_names_cat(tests[i].in, \"a\");\n\t\tout = kex_names_cat(tests[i].out, \"a\");\n\t\tresult = compat_kex_proposal(&ssh, in);\n\t\tASSERT_STRING_EQ(result, out);\n\t\tfree(result); free(in); free(out);\n\t\t \n\t\txasprintf(&in, \"a,%s,b\", tests[i].in);\n\t\tif (*(tests[i].out) == '\\0')\n\t\t\tout = xstrdup(\"a,b\");\n\t\telse\n\t\t\txasprintf(&out, \"a,%s,b\", tests[i].out);\n\t\tresult = compat_kex_proposal(&ssh, in);\n\t\tASSERT_STRING_EQ(result, out);\n\t\tfree(result); free(in); free(out);\n\t}\n\tTEST_DONE();\n}\n\nvoid\nkex_proposal_populate_tests(void)\n{\n\tchar *prop[PROPOSAL_MAX], *kexalgs, *ciphers, *macs, *hkalgs;\n\tconst char *comp = compression_alg_list(0);\n\tint i;\n\tstruct ssh ssh;\n\tstruct kex kex;\n\n\tkexalgs = kex_alg_list(',');\n\tciphers = cipher_alg_list(',', 0);\n\tmacs = mac_alg_list(',');\n\thkalgs = kex_alg_list(',');\n\n\tssh.kex = &kex;\n\tTEST_START(\"compat_kex_proposal_populate\");\n\tfor (i = 0; i <= 1; i++) {\n\t\tkex.server = i;\n\t\tfor (ssh.compat = 0; ssh.compat < 0x40000000; ) {\n\t\t\tkex_proposal_populate_entries(&ssh, prop, NULL, NULL,\n\t\t\t    NULL, NULL, NULL);\n\t\t\tkex_proposal_free_entries(prop);\n\t\t\tkex_proposal_populate_entries(&ssh, prop, kexalgs,\n\t\t\t    ciphers, macs, hkalgs, comp);\n\t\t\tkex_proposal_free_entries(prop);\n\t\t\tif (ssh.compat == 0)\n\t\t\t\tssh.compat = 1;\n\t\t\telse\n\t\t\t\tssh.compat <<= 1;\n\t\t}\n\t}\n\n\tfree(kexalgs);\n\tfree(ciphers);\n\tfree(macs);\n\tfree(hkalgs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}