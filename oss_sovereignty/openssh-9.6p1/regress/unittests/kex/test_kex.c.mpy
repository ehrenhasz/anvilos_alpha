{
  "module_name": "test_kex.c",
  "hash_id": "338570c1f43abd2a0454e14b2b5f119b3ee6a78537a127828250479d7aeb97a4",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/kex/test_kex.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n#include \"../test_helper/test_helper.h\"\n\n#include \"ssherr.h\"\n#include \"ssh_api.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"myproposal.h\"\n\nvoid kex_tests(void);\nstatic int do_debug = 0;\n\nstatic int\ndo_send_and_receive(struct ssh *from, struct ssh *to)\n{\n\tu_char type;\n\tsize_t len;\n\tconst u_char *buf;\n\tint r;\n\n\tfor (;;) {\n\t\tif ((r = ssh_packet_next(from, &type)) != 0) {\n\t\t\tfprintf(stderr, \"ssh_packet_next: %s\\n\", ssh_err(r));\n\t\t\treturn r;\n\t\t}\n\t\tif (type != 0)\n\t\t\treturn 0;\n\t\tbuf = ssh_output_ptr(from, &len);\n\t\tif (do_debug)\n\t\t\tprintf(\"%zu\", len);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tif ((r = ssh_output_consume(from, len)) != 0 ||\n\t\t    (r = ssh_input_append(to, buf, len)) != 0)\n\t\t\treturn r;\n\t}\n}\n\nstatic void\nrun_kex(struct ssh *client, struct ssh *server)\n{\n\tint r = 0;\n\n\twhile (!server->kex->done || !client->kex->done) {\n\t\tif (do_debug)\n\t\t\tprintf(\" S:\");\n\t\tif ((r = do_send_and_receive(server, client)))\n\t\t\tbreak;\n\t\tif (do_debug)\n\t\t\tprintf(\" C:\");\n\t\tif ((r = do_send_and_receive(client, server)))\n\t\t\tbreak;\n\t}\n\tif (do_debug)\n\t\tprintf(\"done: %s\\n\", ssh_err(r));\n\tASSERT_INT_EQ(r, 0);\n\tASSERT_INT_EQ(server->kex->done, 1);\n\tASSERT_INT_EQ(client->kex->done, 1);\n}\n\nstatic void\ndo_kex_with_key(char *kex, int keytype, int bits)\n{\n\tstruct ssh *client = NULL, *server = NULL, *server2 = NULL;\n\tstruct sshkey *private, *public;\n\tstruct sshbuf *state;\n\tstruct kex_params kex_params;\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tchar *keyname = NULL;\n\n\tTEST_START(\"sshkey_generate\");\n\tASSERT_INT_EQ(sshkey_generate(keytype, bits, &private), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"sshkey_from_private\");\n\tASSERT_INT_EQ(sshkey_from_private(private, &public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_init\");\n\tmemcpy(kex_params.proposal, myproposal, sizeof(myproposal));\n\tif (kex != NULL)\n\t\tkex_params.proposal[PROPOSAL_KEX_ALGS] = kex;\n\tkeyname = strdup(sshkey_ssh_name(private));\n\tASSERT_PTR_NE(keyname, NULL);\n\tkex_params.proposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = keyname;\n\tASSERT_INT_EQ(ssh_init(&client, 0, &kex_params), 0);\n\tASSERT_INT_EQ(ssh_init(&server, 1, &kex_params), 0);\n\tASSERT_PTR_NE(client, NULL);\n\tASSERT_PTR_NE(server, NULL);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_add_hostkey\");\n\tASSERT_INT_EQ(ssh_add_hostkey(server, private), 0);\n\tASSERT_INT_EQ(ssh_add_hostkey(client, public), 0);\n\tTEST_DONE();\n\n\tTEST_START(\"kex\");\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying client\");\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server\");\n\tASSERT_INT_EQ(kex_send_kexinit(server), 0);\n\trun_kex(client, server);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_get_state\");\n\tstate = sshbuf_new();\n\tASSERT_PTR_NE(state, NULL);\n\tASSERT_INT_EQ(ssh_packet_get_state(server, state), 0);\n\tASSERT_INT_GE(sshbuf_len(state), 1);\n\tTEST_DONE();\n\n\tTEST_START(\"ssh_packet_set_state\");\n\tserver2 = NULL;\n\tASSERT_INT_EQ(ssh_init(&server2, 1, NULL), 0);\n\tASSERT_PTR_NE(server2, NULL);\n\tASSERT_INT_EQ(ssh_add_hostkey(server2, private), 0);\n\tASSERT_INT_EQ(ssh_packet_set_state(server2, state), 0);\n\tASSERT_INT_EQ(sshbuf_len(state), 0);\n\tsshbuf_free(state);\n\tASSERT_PTR_NE(server2->kex, NULL);\n\t \n#ifdef WITH_OPENSSL\n\tserver2->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tserver2->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tserver2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n#ifdef OPENSSL_HAS_ECC\n\tserver2->kex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n#endif  \n#endif  \n\tserver2->kex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tserver2->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tserver2->kex->load_host_public_key = server->kex->load_host_public_key;\n\tserver2->kex->load_host_private_key = server->kex->load_host_private_key;\n\tserver2->kex->sign = server->kex->sign;\n\tTEST_DONE();\n\n\tTEST_START(\"rekeying server2\");\n\tASSERT_INT_EQ(kex_send_kexinit(server2), 0);\n\trun_kex(client, server2);\n\tASSERT_INT_EQ(kex_send_kexinit(client), 0);\n\trun_kex(client, server2);\n\tTEST_DONE();\n\n\tTEST_START(\"cleanup\");\n\tsshkey_free(private);\n\tsshkey_free(public);\n\tssh_free(client);\n\tssh_free(server);\n\tssh_free(server2);\n\tfree(keyname);\n\tTEST_DONE();\n}\n\nstatic void\ndo_kex(char *kex)\n{\n#ifdef WITH_OPENSSL\n\tdo_kex_with_key(kex, KEY_RSA, 2048);\n\tdo_kex_with_key(kex, KEY_DSA, 1024);\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex_with_key(kex, KEY_ECDSA, 256);\n#endif  \n#endif  \n\tdo_kex_with_key(kex, KEY_ED25519, 256);\n}\n\nvoid\nkex_tests(void)\n{\n\tdo_kex(\"curve25519-sha256@libssh.org\");\n#ifdef WITH_OPENSSL\n#ifdef OPENSSL_HAS_ECC\n\tdo_kex(\"ecdh-sha2-nistp256\");\n\tdo_kex(\"ecdh-sha2-nistp384\");\n\tdo_kex(\"ecdh-sha2-nistp521\");\n#endif  \n\tdo_kex(\"diffie-hellman-group-exchange-sha256\");\n\tdo_kex(\"diffie-hellman-group-exchange-sha1\");\n\tdo_kex(\"diffie-hellman-group14-sha1\");\n\tdo_kex(\"diffie-hellman-group1-sha1\");\n# ifdef USE_SNTRUP761X25519\n\tdo_kex(\"sntrup761x25519-sha512@openssh.com\");\n# endif  \n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}