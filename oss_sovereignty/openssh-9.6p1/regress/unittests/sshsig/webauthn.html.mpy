{
  "module_name": "webauthn.html",
  "hash_id": "fbbe52ea2f6f5a334627ae4e1064289c2d951472ac3d48233660b530a829ab93",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/sshsig/webauthn.html",
  "human_readable_source": "<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>\n<title>webauthn test</title>\n</head>\n<body onload=\"init()\">\n<h1>webauthn test</h1>\n<p>\nThis is a demo/test page for generating FIDO keys and signatures in SSH\nformats. The page initially displays a form to generate a FIDO key and\nconvert it to a SSH public key.\n</p>\n<p>\nOnce a key has been generated, an additional form will be displayed to\nallow signing of data using the just-generated key. The data may be signed\nas either a raw SSH signature or wrapped in a sshsig message (the latter is\neasier to test using command-line tools.\n</p>\n<p>\nLots of debugging is printed along the way.\n</p>\n<h2>Enroll</h2>\n<span id=\"error\" style=\"color: #800; font-weight: bold; font-size: 150%;\"></span>\n<form id=\"enrollform\">\n<table>\n<tr>\n<td><b>Username:</b></td>\n<td><input id=\"username\" type=\"text\" size=\"20\" name=\"user\" value=\"test\" /></td>\n</tr>\n<tr><td></td><td><input id=\"assertsubmit\" type=\"submit\" value=\"submit\" /></td></tr>\n</table>\n</form>\n<span id=\"enrollresult\" style=\"visibility: hidden;\">\n<h2>clientData</h2>\n<pre id=\"enrollresultjson\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>attestationObject raw</h2>\n<pre id=\"enrollresultraw\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>attestationObject</h2>\n<pre id=\"enrollresultattestobj\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>key handle</h2>\n<pre id=\"keyhandle\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>authData raw</h2>\n<pre id=\"enrollresultauthdataraw\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>authData</h2>\n<pre id=\"enrollresultauthdata\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>SSH pubkey blob</h2>\n<pre id=\"enrollresultpkblob\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>SSH pubkey string</h2>\n<pre id=\"enrollresultpk\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>SSH private key string</h2>\n<pre id=\"enrollresultprivkey\" style=\"color: #008; font-family: monospace;\"></pre>\n</span>\n<span id=\"assertsection\" style=\"visibility: hidden;\">\n<h2>Assert</h2>\n<form id=\"assertform\">\n<span id=\"asserterror\" style=\"color: #800; font-weight: bold;\"></span>\n<table>\n<tr>\n<td><b>Data to sign:</b></td>\n<td><input id=\"message\" type=\"text\" size=\"20\" name=\"message\" value=\"test\" /></td>\n</tr>\n<tr>\n<td><input id=\"message_sshsig\" type=\"checkbox\" checked /> use sshsig format</td>\n</tr>\n<tr>\n<td><b>Signature namespace:</b></td>\n<td><input id=\"message_namespace\" type=\"text\" size=\"20\" name=\"namespace\" value=\"test\" /></td>\n</tr>\n<tr><td></td><td><input type=\"submit\" value=\"submit\" /></td></tr>\n</table>\n</form>\n</span>\n<span id=\"assertresult\" style=\"visibility: hidden;\">\n<h2>clientData</h2>\n<pre id=\"assertresultjson\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>signature raw</h2>\n<pre id=\"assertresultsigraw\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>authenticatorData raw</h2>\n<pre id=\"assertresultauthdataraw\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>authenticatorData</h2>\n<pre id=\"assertresultauthdata\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>signature in SSH format</h2>\n<pre id=\"assertresultsshsigraw\" style=\"color: #008; font-family: monospace;\"></pre>\n<h2>signature in SSH format (base64 encoded)</h2>\n<pre id=\"assertresultsshsigb64\" style=\"color: #008; font-family: monospace;\"></pre>\n</span>\n</body>\n<script>\n// ------------------------------------------------------------------\n// a crappy CBOR decoder - 20200401 djm@openbsd.org\n\nvar CBORDecode = function(buffer) {\n\tthis.buf = buffer\n\tthis.v = new DataView(buffer)\n\tthis.offset = 0\n}\n\nCBORDecode.prototype.empty = function() {\n\treturn this.offset >= this.buf.byteLength\n}\n\nCBORDecode.prototype.getU8 = function() {\n\tlet r = this.v.getUint8(this.offset)\n\tthis.offset += 1\n\treturn r\n}\n\nCBORDecode.prototype.getU16 = function() {\n\tlet r = this.v.getUint16(this.offset)\n\tthis.offset += 2\n\treturn r\n}\n\nCBORDecode.prototype.getU32 = function() {\n\tlet r = this.v.getUint32(this.offset)\n\tthis.offset += 4\n\treturn r\n}\n\nCBORDecode.prototype.getU64 = function() {\n\tlet r = this.v.getUint64(this.offset)\n\tthis.offset += 8\n\treturn r\n}\n\nCBORDecode.prototype.getCBORTypeLen = function() {\n\tlet tl, t, l\n\ttl = this.getU8()\n\tt = (tl & 0xe0) >> 5\n\tl = tl & 0x1f\n\treturn [t, this.decodeInteger(l)]\n}\n\nCBORDecode.prototype.decodeInteger = function(len) {\n\tswitch (len) {\n\tcase 0x18: return this.getU8()\n\tcase 0x19: return this.getU16()\n\tcase 0x20: return this.getU32()\n\tcase 0x21: return this.getU64()\n\tdefault:\n\t\tif (len <= 23) {\n\t\t\treturn len\n\t\t}\n\t\tthrow new Error(\"Unsupported int type 0x\" + len.toString(16))\n\t}\n}\n\nCBORDecode.prototype.decodeNegint = function(len) {\n\tlet r = -(this.decodeInteger(len) + 1)\n\treturn r\n}\n\nCBORDecode.prototype.decodeByteString = function(len) {\n\tlet r = this.buf.slice(this.offset, this.offset + len)\n\tthis.offset += len\n\treturn r\n}\n\nCBORDecode.prototype.decodeTextString = function(len) {\n\tlet u8dec = new TextDecoder('utf-8')\n\tr = u8dec.decode(this.decodeByteString(len))\n\treturn r\n}\n\nCBORDecode.prototype.decodeArray = function(len, level) {\n\tlet r = []\n\tfor (let i = 0; i < len; i++) {\n\t\tlet v = this.decodeInternal(level)\n\t\tr.push(v)\n\t\t// console.log(\"decodeArray level \" + level.toString() + \" index \" + i.toString() + \" value \" + JSON.stringify(v))\n\t}\n\treturn r\n}\n\nCBORDecode.prototype.decodeMap = function(len, level) {\n\tlet r = {}\n\tfor (let i = 0; i < len; i++) {\n\t\tlet k = this.decodeInternal(level)\n\t\tlet v = this.decodeInternal(level)\n\t\tr[k] = v\n\t\t// console.log(\"decodeMap level \" + level.toString() + \" key \" + k.toString() + \" value \" + JSON.stringify(v))\n\t\t// XXX check string keys, duplicates\n\t}\n\treturn r\n}\n\nCBORDecode.prototype.decodePrimitive = function(t) {\n\tswitch (t) {\n\tcase 20: return false\n\tcase 21: return true\n\tcase 22: return null\n\tcase 23: return undefined\n\tdefault:\n\t\tthrow new Error(\"Unsupported primitive 0x\" + t.toString(2))\n\t}\n}\n\nCBORDecode.prototype.decodeInternal = function(level) {\n\tif (level > 256) {\n\t\tthrow new Error(\"CBOR nesting too deep\")\n\t}\n\tlet t, l, r\n\t[t, l] = this.getCBORTypeLen()\n\t// console.log(\"decode level \" + level.toString() + \" type \" + t.toString() + \" len \" + l.toString())\n\tswitch (t) {\n\t\tcase 0:\n\t\t\tr = this.decodeInteger(l)\n\t\t\tbreak\n\t\tcase 1:\n\t\t\tr = this.decodeNegint(l)\n\t\t\tbreak\n\t\tcase 2:\n\t\t\tr = this.decodeByteString(l)\n\t\t\tbreak\n\t\tcase 3:\n\t\t\tr = this.decodeTextString(l)\n\t\t\tbreak\n\t\tcase 4:\n\t\t\tr = this.decodeArray(l, level + 1)\n\t\t\tbreak\n\t\tcase 5:\n\t\t\tr = this.decodeMap(l, level + 1)\n\t\t\tbreak\n\t\tcase 6:\n\t\t\tconsole.log(\"XXX ignored semantic tag \" + this.decodeInteger(l).toString())\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tr = this.decodePrimitive(l)\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthrow new Error(\"Unsupported type 0x\" + t.toString(2) + \" len \" + l.toString())\n\t}\n\t// console.log(\"decode level \" + level.toString() + \" value \" + JSON.stringify(r))\n\treturn r\n}\n\nCBORDecode.prototype.decode = function() {\n\treturn this.decodeInternal(0)\n}\n\n// ------------------------------------------------------------------\n// a crappy SSH message packer - 20200401 djm@openbsd.org\n\nvar SSHMSG = function() {\n\tthis.r = []\n}\n\nSSHMSG.prototype.length = function() {\n\tlet len = 0\n\tfor (buf of this.r) {\n\t\tlen += buf.length\n\t}\n\treturn len\n}\n\nSSHMSG.prototype.serialise = function() {\n\tlet r = new ArrayBuffer(this.length())\n\tlet v = new Uint8Array(r)\n\tlet offset = 0\n\tfor (buf of this.r) {\n\t\tv.set(buf, offset)\n\t\toffset += buf.length\n\t}\n\tif (offset != r.byteLength) {\n\t\tthrow new Error(\"djm can't count\")\n\t}\n\treturn r\n}\n\nSSHMSG.prototype.serialiseBase64 = function(v) {\n\tlet b = this.serialise()\n\treturn btoa(String.fromCharCode(...new Uint8Array(b)));\n}\n\nSSHMSG.prototype.putU8 = function(v) {\n\tthis.r.push(new Uint8Array([v]))\n}\n\nSSHMSG.prototype.putU32 = function(v) {\n\tthis.r.push(new Uint8Array([\n\t\t(v >> 24) & 0xff,\n\t\t(v >> 16) & 0xff,\n\t\t(v >> 8) & 0xff,\n\t\t(v & 0xff)\n\t]))\n}\n\nSSHMSG.prototype.put = function(v) {\n\tthis.r.push(new Uint8Array(v))\n}\n\nSSHMSG.prototype.putStringRaw = function(v) {\n\tlet enc = new TextEncoder();\n\tlet venc = enc.encode(v)\n\tthis.put(venc)\n}\n\nSSHMSG.prototype.putString = function(v) {\n\tlet enc = new TextEncoder();\n\tlet venc = enc.encode(v)\n\tthis.putU32(venc.length)\n\tthis.put(venc)\n}\n\nSSHMSG.prototype.putSSHMSG = function(v) {\n\tlet msg = v.serialise()\n\tthis.putU32(msg.byteLength)\n\tthis.put(msg)\n}\n\nSSHMSG.prototype.putBytes = function(v) {\n\tthis.putU32(v.byteLength)\n\tthis.put(v)\n}\n\nSSHMSG.prototype.putECPoint = function(x, y) {\n\tlet x8 = new Uint8Array(x)\n\tlet y8 = new Uint8Array(y)\n\tthis.putU32(1 + x8.length + y8.length)\n\tthis.putU8(0x04) // Uncompressed point format.\n\tthis.put(x8)\n\tthis.put(y8)\n}\n\n// ------------------------------------------------------------------\n// webauthn to SSH glue - djm@openbsd.org 20200408\n\nfunction error(msg, ...args) {\n\tdocument.getElementById(\"error\").innerText = msg\n\tconsole.log(msg)\n\tfor (const arg of args) {\n\t\tconsole.dir(arg)\n\t}\n}\nfunction hexdump(buf) {\n\tconst hex = Array.from(new Uint8Array(buf)).map(\n\t\tb => b.toString(16).padStart(2, \"0\"))\n\tconst fmt = new Array()\n\tfor (let i = 0; i < hex.length; i++) {\n\t\tif ((i % 16) == 0) {\n\t\t\t// Prepend length every 16 bytes.\n\t\t\tfmt.push(i.toString(16).padStart(4, \"0\"))\n\t\t\tfmt.push(\"  \")\n\t\t}\n\t\tfmt.push(hex[i])\n\t\tfmt.push(\" \")\n\t\tif ((i % 16) == 15) {\n\t\t\tfmt.push(\"\\n\")\n\t\t}\n\t}\n\treturn fmt.join(\"\")\n}\nfunction enrollform_submit(event) {\n\tevent.preventDefault();\n\tconsole.log(\"submitted\")\n\tusername = event.target.elements.username.value\n\tif (username === \"\") {\n\t\terror(\"no username specified\")\n\t\treturn false\n\t}\n\tenrollStart(username)\n}\nfunction enrollStart(username) {\n\tlet challenge = new Uint8Array(32)\n\twindow.crypto.getRandomValues(challenge)\n\tlet userid = new Uint8Array(8)\n\twindow.crypto.getRandomValues(userid)\n\n\tconsole.log(\"challenge:\" + btoa(challenge))\n\tconsole.log(\"userid:\" + btoa(userid))\n\n\tlet pkopts = {\n\t\tchallenge: challenge,\n\t\trp: {\n\t\t\tname: window.location.host,\n\t\t\tid: window.location.host,\n\t\t},\n\t\tuser: {\n\t\t\tid: userid,\n\t\t\tname: username,\n\t\t\tdisplayName: username,\n\t\t},\n\t\tauthenticatorSelection: {\n\t\t\tauthenticatorAttachment: \"cross-platform\",\n\t\t\tuserVerification: \"discouraged\",\n\t\t},\n\t\tpubKeyCredParams: [{alg: -7, type: \"public-key\"}], // ES256\n\t\ttimeout: 30 * 1000,\n\t};\n\tconsole.dir(pkopts)\n\twindow.enrollOpts = pkopts\n\tlet credpromise = navigator.credentials.create({ publicKey: pkopts });\n\tcredpromise.then(enrollSuccess, enrollFailure)\n}\nfunction enrollFailure(result) {\n\terror(\"Enroll failed\", result)\n}\nfunction enrollSuccess(result) {\n\tconsole.log(\"Enroll succeeded\")\n\tconsole.dir(result)\n\twindow.enrollResult = result\n\tdocument.getElementById(\"enrollresult\").style.visibility = \"visible\"\n\n\t// Show the clientData\n\tlet u8dec = new TextDecoder('utf-8')\n\tclientData = u8dec.decode(result.response.clientDataJSON)\n\tdocument.getElementById(\"enrollresultjson\").innerText = clientData\n\n\t// Show the raw key handle.\n\tdocument.getElementById(\"keyhandle\").innerText = hexdump(result.rawId)\n\n\t// Decode and show the attestationObject\n\tdocument.getElementById(\"enrollresultraw\").innerText = hexdump(result.response.attestationObject)\n\tlet aod = new CBORDecode(result.response.attestationObject)\n\tlet attestationObject = aod.decode()\n\tconsole.log(\"attestationObject\")\n\tconsole.dir(attestationObject)\n\tdocument.getElementById(\"enrollresultattestobj\").innerText = JSON.stringify(attestationObject)\n\n\t// Decode and show the authData\n\tdocument.getElementById(\"enrollresultauthdataraw\").innerText = hexdump(attestationObject.authData)\n\tlet authData = decodeAuthenticatorData(attestationObject.authData, true)\n\tconsole.log(\"authData\")\n\tconsole.dir(authData)\n\twindow.enrollAuthData = authData\n\tdocument.getElementById(\"enrollresultauthdata\").innerText = JSON.stringify(authData)\n\n\t// Reformat the pubkey as a SSH key for easy verification\n\twindow.rawKey = reformatPubkey(authData.attestedCredentialData.credentialPublicKey, window.enrollOpts.rp.id)\n\tconsole.log(\"SSH pubkey blob\")\n\tconsole.dir(window.rawKey)\n\tdocument.getElementById(\"enrollresultpkblob\").innerText = hexdump(window.rawKey)\n\tlet pk64 = btoa(String.fromCharCode(...new Uint8Array(window.rawKey)));\n\tlet pk = \"sk-ecdsa-sha2-nistp256@openssh.com \" + pk64\n\tdocument.getElementById(\"enrollresultpk\").innerText = pk\n\n\t// Format a private key too.\n\tflags = 0x01 // SSH_SK_USER_PRESENCE_REQD\n\twindow.rawPrivkey = reformatPrivkey(authData.attestedCredentialData.credentialPublicKey, window.enrollOpts.rp.id, result.rawId, flags)\n\tlet privkeyFileBlob = privkeyFile(window.rawKey, window.rawPrivkey, window.enrollOpts.user.name, window.enrollOpts.rp.id)\n\tlet privk64 = btoa(String.fromCharCode(...new Uint8Array(privkeyFileBlob)));\n\tlet privkey = \"-----BEGIN OPENSSH PRIVATE KEY-----\\n\" + wrapString(privk64, 70) + \"-----END OPENSSH PRIVATE KEY-----\\n\"\n\tdocument.getElementById(\"enrollresultprivkey\").innerText = privkey\n\n\t// Success: show the assertion form.\n\tdocument.getElementById(\"assertsection\").style.visibility = \"visible\"\n}\n\nfunction decodeAuthenticatorData(authData, expectCred) {\n\tlet r = new Object()\n\tlet v = new DataView(authData)\n\n\tr.rpIdHash = authData.slice(0, 32)\n\tr.flags = v.getUint8(32)\n\tr.signCount = v.getUint32(33)\n\n\t// Decode attestedCredentialData if present.\n\tlet offset = 37\n\tlet acd = new Object()\n\tif (expectCred) {\n\t\tacd.aaguid = authData.slice(offset, offset+16)\n\t\toffset += 16\n\t\tlet credentialIdLength = v.getUint16(offset)     \n\t\toffset += 2\n\t\tacd.credentialIdLength = credentialIdLength\n\t\tacd.credentialId = authData.slice(offset, offset+credentialIdLength)\n\t\toffset += credentialIdLength\n\t\tr.attestedCredentialData = acd\n\t}\n\tconsole.log(\"XXXXX \" + offset.toString())\n\tlet pubkeyrest = authData.slice(offset, authData.byteLength)\n\tlet pkdecode = new CBORDecode(pubkeyrest)\n\tif (expectCred) {\n\t\t// XXX unsafe: doesn't mandate COSE canonical format.\n\t\tacd.credentialPublicKey = pkdecode.decode()\n\t}\n\tif (!pkdecode.empty()) {\n\t\t// Decode extensions if present.\n\t\tr.extensions = pkdecode.decode()\n\t}\n\treturn r\n}\n\nfunction wrapString(s, l) {\n\tret = \"\"\n\tfor (i = 0; i < s.length; i += l) {\n\t\tret += s.slice(i, i + l) + \"\\n\"\n\t}\n\treturn ret\n}\n\nfunction checkPubkey(pk) {\n\t// pk is in COSE format. We only care about a tiny subset.\n\tif (pk[1] != 2) {\n\t\tconsole.dir(pk)\n\t\tthrow new Error(\"pubkey is not EC\")\n\t}\n\tif (pk[-1] != 1) {\n\t\tthrow new Error(\"pubkey is not in P256\")\n\t}\n\tif (pk[3] != -7) {\n\t\tthrow new Error(\"pubkey is not ES256\")\n\t}\n\tif (pk[-2].byteLength != 32 || pk[-3].byteLength != 32) {\n\t\tthrow new Error(\"pubkey EC coords have bad length\")\n\t}\n}\n\nfunction reformatPubkey(pk, rpid) {\n\tcheckPubkey(pk)\n\tlet msg = new SSHMSG()\n\tmsg.putString(\"sk-ecdsa-sha2-nistp256@openssh.com\")\t// Key type\n\tmsg.putString(\"nistp256\")\t\t\t\t// Key curve\n\tmsg.putECPoint(pk[-2], pk[-3])\t\t\t\t// EC key\n\tmsg.putString(rpid)\t\t\t\t\t// RP ID\n\treturn msg.serialise()\n}\n\nfunction reformatPrivkey(pk, rpid, kh, flags) {\n\tcheckPubkey(pk)\n\tlet msg = new SSHMSG()\n\tmsg.putString(\"sk-ecdsa-sha2-nistp256@openssh.com\")\t// Key type\n\tmsg.putString(\"nistp256\")\t\t\t\t// Key curve\n\tmsg.putECPoint(pk[-2], pk[-3])\t\t\t\t// EC key\n\tmsg.putString(rpid)\t\t\t\t\t// RP ID\n\tmsg.putU8(flags)\t\t\t\t\t// flags\n\tmsg.putBytes(kh)\t\t\t\t\t// handle\n\tmsg.putString(\"\")\t\t\t\t\t// reserved\n\treturn msg.serialise()\n}\n\nfunction privkeyFile(pub, priv, user, rp) {\n\tlet innerMsg = new SSHMSG()\n\tinnerMsg.putU32(0xdeadbeef)\t\t\t\t// check byte\n\tinnerMsg.putU32(0xdeadbeef)\t\t\t\t// check byte\n\tinnerMsg.put(priv)\t\t\t\t\t// privkey\n\tinnerMsg.putString(\"webauthn.html \" + user + \"@\" + rp)\t// comment\n\t// Pad to cipher blocksize (8).\n\tp = 1\n\twhile (innerMsg.length() % 8 != 0) {\n\t\tinnerMsg.putU8(p++)\n\t}\n\tlet msg = new SSHMSG()\n\tmsg.putStringRaw(\"openssh-key-v1\")\t\t\t// Magic\n\tmsg.putU8(0)\t\t\t\t\t\t// \\0 terminate\n\tmsg.putString(\"none\")\t\t\t\t\t// cipher\n\tmsg.putString(\"none\")\t\t\t\t\t// KDF\n\tmsg.putString(\"\")\t\t\t\t\t// KDF options\n\tmsg.putU32(1)\t\t\t\t\t\t// nkeys\n\tmsg.putBytes(pub)\t\t\t\t\t// pubkey\n\tmsg.putSSHMSG(innerMsg)\t\t\t\t\t// inner\n\t//msg.put(innerMsg.serialise())\t\t\t\t// inner\n\treturn msg.serialise()\n}\n\nasync function assertform_submit(event) {\n\tevent.preventDefault();\n\tconsole.log(\"submitted\")\n\tmessage = event.target.elements.message.value\n\tif (message === \"\") {\n\t\terror(\"no message specified\")\n\t\treturn false\n\t}\n\tlet enc = new TextEncoder()\n\tlet encmsg = enc.encode(message)\n\twindow.assertSignRaw = !event.target.elements.message_sshsig.checked\n\tconsole.log(\"using sshsig \", !window.assertSignRaw)\n\tif (window.assertSignRaw) {\n\t\tassertStart(encmsg)\n\t\treturn\n\t}\n\t// Format a sshsig-style message.\n\twindow.sigHashAlg = \"sha512\"\n\tlet msghash = await crypto.subtle.digest(\"SHA-512\", encmsg);\n\tconsole.log(\"raw message hash\")\n\tconsole.dir(msghash)\n\twindow.sigNamespace = event.target.elements.message_namespace.value\n\tlet sigbuf = new SSHMSG()\n\tsigbuf.put(enc.encode(\"SSHSIG\"))\n\tsigbuf.putString(window.sigNamespace)\n\tsigbuf.putU32(0) // Reserved string\n\tsigbuf.putString(window.sigHashAlg)\n\tsigbuf.putBytes(msghash)\n\tlet msg = sigbuf.serialise()\n\tconsole.log(\"sigbuf\")\n\tconsole.dir(msg)\n\tassertStart(msg)\n}\n\nfunction assertStart(message) {\n\tlet assertReqOpts = {\n\t\tchallenge: message,\n\t\trpId: window.location.host,\n\t\tallowCredentials: [{\n\t\t\ttype: 'public-key',\n\t\t\tid: window.enrollResult.rawId,\n\t\t}],\n\t\tuserVerification: \"discouraged\",\n\t\ttimeout: (30 * 1000),\n\t}\n\tconsole.log(\"assertReqOpts\")\n\tconsole.dir(assertReqOpts)\n\twindow.assertReqOpts = assertReqOpts\n\tlet assertpromise = navigator.credentials.get({\n\t\tpublicKey: assertReqOpts\n\t});\n\tassertpromise.then(assertSuccess, assertFailure)\n}\nfunction assertFailure(result) {\n\terror(\"Assertion failed\", result)\n}\nfunction linewrap(s) {\n\tconst linelen = 70\n\tlet ret = \"\"\n\tfor (let i = 0; i < s.length; i += linelen) {\n\t\tend = i + linelen\n\t\tif (end > s.length) {\n\t\t\tend = s.length\n\t\t}\n\t\tif (i > 0) {\n\t\t\tret += \"\\n\"\n\t\t}\n\t\tret += s.slice(i, end)\n\t}\n\treturn ret + \"\\n\"\n}\nfunction assertSuccess(result) {\n\tconsole.log(\"Assertion succeeded\")\n\tconsole.dir(result)\n\twindow.assertResult = result\n\tdocument.getElementById(\"assertresult\").style.visibility = \"visible\"\n\n\t// show the clientData.\n\tlet u8dec = new TextDecoder('utf-8')\n\tclientData = u8dec.decode(result.response.clientDataJSON)\n\tdocument.getElementById(\"assertresultjson\").innerText = clientData\n\n\t// show the signature.\n\tdocument.getElementById(\"assertresultsigraw\").innerText = hexdump(result.response.signature)\n\t\n\t// decode and show the authData.\n\tdocument.getElementById(\"assertresultauthdataraw\").innerText = hexdump(result.response.authenticatorData)\n\tauthData = decodeAuthenticatorData(result.response.authenticatorData, false)\n\tdocument.getElementById(\"assertresultauthdata\").innerText = JSON.stringify(authData)\n\n\t// Parse and reformat the signature to an SSH style signature.\n\tlet sshsig = reformatSignature(result.response.signature, clientData, authData)\n\tdocument.getElementById(\"assertresultsshsigraw\").innerText = hexdump(sshsig)\n\tlet sig64 = btoa(String.fromCharCode(...new Uint8Array(sshsig)));\n\tif (window.assertSignRaw) {\n\t\tdocument.getElementById(\"assertresultsshsigb64\").innerText = sig64\n\t} else {\n\t\tdocument.getElementById(\"assertresultsshsigb64\").innerText =\n\t\t    \"-----BEGIN SSH SIGNATURE-----\\n\" + linewrap(sig64) +\n\t\t    \"-----END SSH SIGNATURE-----\\n\";\n\t}\n}\n\nfunction reformatSignature(sig, clientData, authData) {\n\tif (sig.byteLength < 2) {\n\t\tthrow new Error(\"signature is too short\")\n\t}\n\tlet offset = 0\n\tlet v = new DataView(sig)\n\t// Expect an ASN.1 SEQUENCE that exactly spans the signature.\n\tif (v.getUint8(offset) != 0x30) {\n\t\tthrow new Error(\"signature not an ASN.1 sequence\")\n\t}\n\toffset++\n\tlet seqlen = v.getUint8(offset)\n\toffset++\n\tif ((seqlen & 0x80) != 0 || seqlen != sig.byteLength - offset) {\n\t\tthrow new Error(\"signature has unexpected length \" + seqlen.toString() + \" vs expected \" + (sig.byteLength - offset).toString())\n\t}\n\n\t// Parse 'r' INTEGER value.\n\tif (v.getUint8(offset) != 0x02) {\n\t\tthrow new Error(\"signature r not an ASN.1 integer\")\n\t}\n\toffset++\n\tlet rlen = v.getUint8(offset)\n\toffset++\n\tif ((rlen & 0x80) != 0 || rlen > sig.byteLength - offset) {\n\t\tthrow new Error(\"signature r has unexpected length \" + rlen.toString() + \" vs buffer \" + (sig.byteLength - offset).toString())\n\t}\n\tlet r = sig.slice(offset, offset + rlen)\n\toffset += rlen\n\tconsole.log(\"sig_r\")\n\tconsole.dir(r)\n\n\t// Parse 's' INTEGER value.\n\tif (v.getUint8(offset) != 0x02) {\n\t\tthrow new Error(\"signature r not an ASN.1 integer\")\n\t}\n\toffset++\n\tlet slen = v.getUint8(offset)\n\toffset++\n\tif ((slen & 0x80) != 0 || slen > sig.byteLength - offset) {\n\t\tthrow new Error(\"signature s has unexpected length \" + slen.toString() + \" vs buffer \" + (sig.byteLength - offset).toString())\n\t}\n\tlet s = sig.slice(offset, offset + slen)\n\tconsole.log(\"sig_s\")\n\tconsole.dir(s)\n\toffset += slen\n\n\tif (offset != sig.byteLength) {\n\t\tthrow new Error(\"unexpected final offset during signature parsing \" + offset.toString() + \" expected \" + sig.byteLength.toString())\n\t}\n\t\n\t// Reformat as an SSH signature.\n\tlet clientDataParsed = JSON.parse(clientData)\n\tlet innersig = new SSHMSG()\n\tinnersig.putBytes(r)\n\tinnersig.putBytes(s)\n\n\tlet rawsshsig = new SSHMSG()\n\trawsshsig.putString(\"webauthn-sk-ecdsa-sha2-nistp256@openssh.com\")\n\trawsshsig.putSSHMSG(innersig)\n\trawsshsig.putU8(authData.flags)\n\trawsshsig.putU32(authData.signCount)\n\trawsshsig.putString(clientDataParsed.origin)\n\trawsshsig.putString(clientData)\n\tif (authData.extensions == undefined) {\n\t\trawsshsig.putU32(0)\n\t} else {\n\t\trawsshsig.putBytes(authData.extensions)\n\t}\n\n\tif (window.assertSignRaw) {\n\t\treturn rawsshsig.serialise()\n\t}\n\t// Format as SSHSIG.\n\tlet enc = new TextEncoder()\n\tlet sshsig = new SSHMSG()\n\tsshsig.put(enc.encode(\"SSHSIG\"))\n\tsshsig.putU32(0x01) // Signature version.\n\tsshsig.putBytes(window.rawKey)\n\tsshsig.putString(window.sigNamespace)\n\tsshsig.putU32(0) // Reserved string\n\tsshsig.putString(window.sigHashAlg)\n\tsshsig.putBytes(rawsshsig.serialise())\n\treturn sshsig.serialise()\n}\n\nfunction toggleNamespaceVisibility() {\n\tconst assertsigtype = document.getElementById('message_sshsig');\n\tconst assertsignamespace = document.getElementById('message_namespace');\n\tassertsignamespace.disabled = !assertsigtype.checked;\n}\n\nfunction init() {\n\tif (document.location.protocol != \"https:\") {\n\t\terror(\"This page must be loaded via https\")\n\t\tconst assertsubmit = document.getElementById('assertsubmit')\n\t\tassertsubmit.disabled = true\n\t}\n\tconst enrollform = document.getElementById('enrollform');\n\tenrollform.addEventListener('submit', enrollform_submit);\n\tconst assertform = document.getElementById('assertform');\n\tassertform.addEventListener('submit', assertform_submit);\n\tconst assertsigtype = document.getElementById('message_sshsig');\n\tassertsigtype.onclick = toggleNamespaceVisibility;\n}\n</script>\n\n</html>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}