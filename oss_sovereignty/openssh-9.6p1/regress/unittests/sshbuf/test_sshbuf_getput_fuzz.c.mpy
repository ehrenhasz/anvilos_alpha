{
  "module_name": "test_sshbuf_getput_fuzz.c",
  "hash_id": "e35265e880a180d2979853fb0ceac3e45420b6dc9cb274f67eb88cf301b6e9d5",
  "original_prompt": "Ingested from openssh-9.6p1/regress/unittests/sshbuf/test_sshbuf_getput_fuzz.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <stdio.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/bn.h>\n#include <openssl/objects.h>\n#ifdef OPENSSL_HAS_NISTP256\n# include <openssl/ec.h>\n#endif\n#endif\n\n#include \"../test_helper/test_helper.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n\nvoid sshbuf_getput_fuzz_tests(void);\n\nstatic void\nattempt_parse_blob(u_char *blob, size_t len)\n{\n\tstruct sshbuf *p1;\n#ifdef WITH_OPENSSL\n\tBIGNUM *bn;\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\tEC_KEY *eck;\n#endif  \n#endif  \n\tu_char *s;\n\tsize_t l;\n\tu_int8_t u8;\n\tu_int16_t u16;\n\tu_int32_t u32;\n\tu_int64_t u64;\n\n\tp1 = sshbuf_new();\n\tASSERT_PTR_NE(p1, NULL);\n\tASSERT_INT_EQ(sshbuf_put(p1, blob, len), 0);\n\tsshbuf_get_u8(p1, &u8);\n\tsshbuf_get_u16(p1, &u16);\n\tsshbuf_get_u32(p1, &u32);\n\tsshbuf_get_u64(p1, &u64);\n\tif (sshbuf_get_string(p1, &s, &l) == 0) {\n\t\tbzero(s, l);\n\t\tfree(s);\n\t}\n#ifdef WITH_OPENSSL\n\tbn = NULL;\n\tsshbuf_get_bignum2(p1, &bn);\n\tBN_clear_free(bn);\n#if defined(OPENSSL_HAS_ECC) && defined(OPENSSL_HAS_NISTP256)\n\teck = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\tASSERT_PTR_NE(eck, NULL);\n\tsshbuf_get_eckey(p1, eck);\n\tEC_KEY_free(eck);\n#endif  \n#endif  \n\tsshbuf_free(p1);\n}\n\n\nstatic void\nonerror(void *fuzz)\n{\n\tfprintf(stderr, \"Failed during fuzz:\\n\");\n\tfuzz_dump((struct fuzz *)fuzz);\n}\n\nvoid\nsshbuf_getput_fuzz_tests(void)\n{\n\tu_char blob[] = {\n\t\t \n\t\t0xd0,\n\t\t \n\t\t0xc0, 0xde,\n\t\t \n\t\t0xfa, 0xce, 0xde, 0xad,\n\t\t \n\t\t0xfe, 0xed, 0xac, 0x1d, 0x1f, 0x1c, 0xbe, 0xef,\n\t\t \n\t\t0x00, 0x00, 0x00, 0x09,\n\t\t'O', ' ', 'G', 'o', 'r', 'g', 'o', 'n', '!',\n\t\t \n\t\t0x00, 0x00, 0x00, 0x14,\n\t\t0x00,\n\t\t0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0x90, 0x80,\n\t\t0x70, 0x60, 0x50, 0x40, 0x30, 0x20, 0x10, 0x00,\n\t\t0x7f, 0xff, 0x11,\n\t\t \n\t\t0x00, 0x00, 0x00, 0x41,\n\t\t0x04,\n\t\t0x0c, 0x82, 0x80, 0x04, 0x83, 0x9d, 0x01, 0x06,\n\t\t0xaa, 0x59, 0x57, 0x52, 0x16, 0x19, 0x13, 0x57,\n\t\t0x34, 0xb4, 0x51, 0x45, 0x9d, 0xad, 0xb5, 0x86,\n\t\t0x67, 0x7e, 0xf9, 0xdf, 0x55, 0x78, 0x49, 0x99,\n\t\t0x4d, 0x19, 0x6b, 0x50, 0xf0, 0xb4, 0xe9, 0x4b,\n\t\t0x3c, 0x73, 0xe3, 0xa9, 0xd4, 0xcd, 0x9d, 0xf2,\n\t\t0xc8, 0xf9, 0xa3, 0x5e, 0x42, 0xbd, 0xd0, 0x47,\n\t\t0x55, 0x0f, 0x69, 0xd8, 0x0e, 0xc2, 0x3c, 0xd4,\n\t};\n\tstruct fuzz *fuzz;\n\tu_int fuzzers = FUZZ_1_BIT_FLIP | FUZZ_2_BIT_FLIP |\n\t    FUZZ_1_BYTE_FLIP | FUZZ_2_BYTE_FLIP |\n\t    FUZZ_TRUNCATE_START | FUZZ_TRUNCATE_END;\n\n\tif (test_is_fast())\n\t\tfuzzers &= ~(FUZZ_2_BYTE_FLIP|FUZZ_2_BIT_FLIP);\n\n\tTEST_START(\"fuzz blob parsing\");\n\tfuzz = fuzz_begin(fuzzers, blob, sizeof(blob));\n\tTEST_ONERROR(onerror, fuzz);\n\tfor(; !fuzz_done(fuzz); fuzz_next(fuzz))\n\t\tattempt_parse_blob(blob, sizeof(blob));\n\tfuzz_cleanup(fuzz);\n\tTEST_DONE();\n\tTEST_ONERROR(NULL, NULL);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}