{
  "module_name": "check-perm.c",
  "hash_id": "f1633a95d37e3c116354eedc4d00e9152e83340f3e6630f71eefac93409d2e33",
  "original_prompt": "Ingested from openssh-9.6p1/regress/check-perm.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <pwd.h>\n#ifdef HAVE_LIBGEN_H\n#include <libgen.h>\n#endif\n\nstatic void\nfatal(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfputc('\\n', stderr);\n\tva_end(args);\n\texit(1);\n}\n \nstatic void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (*path != '/')\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t \n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\n\t\t \n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal(\"%s: stat(\\\"%s\\\"): %s\", __func__,\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n}\n\n \nint\nplatform_sys_dir_uid(uid_t uid)\n{\n\tif (uid == 0)\n\t\treturn 1;\n#ifdef PLATFORM_SYS_DIR_UID\n\tif (uid == PLATFORM_SYS_DIR_UID)\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n \nint\nauth_secure_path(const char *name, struct stat *stp, const char *pw_dir,\n    uid_t uid, char *err, size_t errlen)\n{\n\tchar buf[PATH_MAX], homedir[PATH_MAX];\n\tchar *cp;\n\tint comparehome = 0;\n\tstruct stat st;\n\n\tif (realpath(name, buf) == NULL) {\n\t\tsnprintf(err, errlen, \"realpath %s failed: %s\", name,\n\t\t    strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pw_dir != NULL && realpath(pw_dir, homedir) != NULL)\n\t\tcomparehome = 1;\n\n\tif (!S_ISREG(stp->st_mode)) {\n\t\tsnprintf(err, errlen, \"%s is not a regular file\", buf);\n\t\treturn -1;\n\t}\n\tif ((!platform_sys_dir_uid(stp->st_uid) && stp->st_uid != uid) ||\n\t    (stp->st_mode & 022) != 0) {\n\t\tsnprintf(err, errlen, \"bad ownership or modes for file %s\",\n\t\t    buf);\n\t\treturn -1;\n\t}\n\n\t \n\tfor (;;) {\n\t\tif ((cp = dirname(buf)) == NULL) {\n\t\t\tsnprintf(err, errlen, \"dirname() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tstrlcpy(buf, cp, sizeof(buf));\n\n\t\tif (stat(buf, &st) < 0 ||\n\t\t    (!platform_sys_dir_uid(st.st_uid) && st.st_uid != uid) ||\n\t\t    (st.st_mode & 022) != 0) {\n\t\t\tsnprintf(err, errlen,\n\t\t\t    \"bad ownership or modes for directory %s\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (comparehome && strcmp(homedir, buf) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((strcmp(\"/\", buf) == 0) || (strcmp(\".\", buf) == 0))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"check-perm -m [chroot | keys-command] [path]\\n\");\n\texit(1);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tconst char *path = \".\";\n\tchar errmsg[256];\n\tint ch, mode = -1;\n\textern char *optarg;\n\textern int optind;\n\tstruct stat st;\n\n\twhile ((ch = getopt(argc, argv, \"hm:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t\tif (strcasecmp(optarg, \"chroot\") == 0)\n\t\t\t\tmode = 1;\n\t\t\telse if (strcasecmp(optarg, \"keys-command\") == 0)\n\t\t\t\tmode = 2;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Invalid -m option\\n\"),\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc > 1)\n\t\tusage();\n\telse if (argc == 1)\n\t\tpath = argv[0];\n\n\tif (mode == 1)\n\t\tsafely_chroot(path, getuid());\n\telse if (mode == 2) {\n\t\tif (stat(path, &st) < 0)\n\t\t\tfatal(\"Could not stat %s: %s\", path, strerror(errno));\n\t\tif (auth_secure_path(path, &st, NULL, 0,\n\t\t    errmsg, sizeof(errmsg)) != 0)\n\t\t\tfatal(\"Unsafe %s: %s\", path, errmsg);\n\t} else {\n\t\tfprintf(stderr, \"Invalid mode\\n\");\n\t\tusage();\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}