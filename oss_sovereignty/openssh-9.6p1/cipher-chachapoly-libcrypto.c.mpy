{
  "module_name": "cipher-chachapoly-libcrypto.c",
  "hash_id": "8086808d1f21d207cb0a5814a3bfb6051a7d4efb70f32c681f0b9f038b5e450b",
  "original_prompt": "Ingested from openssh-9.6p1/cipher-chachapoly-libcrypto.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n#ifdef WITH_OPENSSL\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#if defined(HAVE_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20)\n\n#include <sys/types.h>\n#include <stdarg.h>  \n#include <string.h>\n#include <stdio.h>   \n\n#include <openssl/evp.h>\n\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"cipher-chachapoly.h\"\n\nstruct chachapoly_ctx {\n\tEVP_CIPHER_CTX *main_evp, *header_evp;\n};\n\nstruct chachapoly_ctx *\nchachapoly_new(const u_char *key, u_int keylen)\n{\n\tstruct chachapoly_ctx *ctx;\n\n\tif (keylen != (32 + 32))  \n\t\treturn NULL;\n\tif ((ctx = calloc(1, sizeof(*ctx))) == NULL)\n\t\treturn NULL;\n\tif ((ctx->main_evp = EVP_CIPHER_CTX_new()) == NULL ||\n\t    (ctx->header_evp = EVP_CIPHER_CTX_new()) == NULL)\n\t\tgoto fail;\n\tif (!EVP_CipherInit(ctx->main_evp, EVP_chacha20(), key, NULL, 1))\n\t\tgoto fail;\n\tif (!EVP_CipherInit(ctx->header_evp, EVP_chacha20(), key + 32, NULL, 1))\n\t\tgoto fail;\n\tif (EVP_CIPHER_CTX_iv_length(ctx->header_evp) != 16)\n\t\tgoto fail;\n\treturn ctx;\n fail:\n\tchachapoly_free(ctx);\n\treturn NULL;\n}\n\nvoid\nchachapoly_free(struct chachapoly_ctx *cpctx)\n{\n\tif (cpctx == NULL)\n\t\treturn;\n\tEVP_CIPHER_CTX_free(cpctx->main_evp);\n\tEVP_CIPHER_CTX_free(cpctx->header_evp);\n\tfreezero(cpctx, sizeof(*cpctx));\n}\n\n \nint\nchachapoly_crypt(struct chachapoly_ctx *ctx, u_int seqnr, u_char *dest,\n    const u_char *src, u_int len, u_int aadlen, u_int authlen, int do_encrypt)\n{\n\tu_char seqbuf[16];  \n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n\n\t \n\tmemset(seqbuf, 0, sizeof(seqbuf));\n\tPOKE_U64(seqbuf + 8, seqnr);\n\tmemset(poly_key, 0, sizeof(poly_key));\n\tif (!EVP_CipherInit(ctx->main_evp, NULL, NULL, seqbuf, 1) ||\n\t    EVP_Cipher(ctx->main_evp, poly_key,\n\t    poly_key, sizeof(poly_key)) < 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!do_encrypt) {\n\t\tconst u_char *tag = src + aadlen + len;\n\n\t\tpoly1305_auth(expected_tag, src, aadlen + len, poly_key);\n\t\tif (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n\t\t\tr = SSH_ERR_MAC_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (aadlen) {\n\t\tif (!EVP_CipherInit(ctx->header_evp, NULL, NULL, seqbuf, 1) ||\n\t\t    EVP_Cipher(ctx->header_evp, dest, src, aadlen) < 0) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tseqbuf[0] = 1;\n\tif (!EVP_CipherInit(ctx->main_evp, NULL, NULL, seqbuf, 1) ||\n\t    EVP_Cipher(ctx->main_evp, dest + aadlen, src + aadlen, len) < 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (do_encrypt) {\n\t\tpoly1305_auth(dest + aadlen + len, dest, aadlen + len,\n\t\t    poly_key);\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(expected_tag, sizeof(expected_tag));\n\texplicit_bzero(seqbuf, sizeof(seqbuf));\n\texplicit_bzero(poly_key, sizeof(poly_key));\n\treturn r;\n}\n\n \nint\nchachapoly_get_length(struct chachapoly_ctx *ctx,\n    u_int *plenp, u_int seqnr, const u_char *cp, u_int len)\n{\n\tu_char buf[4], seqbuf[16];\n\n\tif (len < 4)\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tmemset(seqbuf, 0, sizeof(seqbuf));\n\tPOKE_U64(seqbuf + 8, seqnr);\n\tif (!EVP_CipherInit(ctx->header_evp, NULL, NULL, seqbuf, 0))\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\tif (EVP_Cipher(ctx->header_evp, buf, (u_char *)cp, sizeof(buf)) < 0)\n\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t*plenp = PEEK_U32(buf);\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}