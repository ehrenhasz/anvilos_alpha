{
  "module_name": "sshkey-xmss.c",
  "hash_id": "0a0b6289f9f68568e979b27c647d3160e5689ca754905843ceeb349a8e675f05",
  "original_prompt": "Ingested from openssh-9.6p1/sshkey-xmss.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n#ifdef WITH_XMSS\n\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#ifdef HAVE_SYS_FILE_H\n# include <sys/file.h>\n#endif\n\n#include \"ssh2.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"sshkey-xmss.h\"\n#include \"atomicio.h\"\n#include \"log.h\"\n\n#include \"xmss_fast.h\"\n\n \n#define XMSS_MAGIC\t\t\"xmss-state-v1\"\n#define XMSS_CIPHERNAME\t\t\"aes256-gcm@openssh.com\"\nstruct ssh_xmss_state {\n\txmss_params\tparams;\n\tu_int32_t\tn, w, h, k;\n\n\tbds_state\tbds;\n\tu_char\t\t*stack;\n\tu_int32_t\tstackoffset;\n\tu_char\t\t*stacklevels;\n\tu_char\t\t*auth;\n\tu_char\t\t*keep;\n\tu_char\t\t*th_nodes;\n\tu_char\t\t*retain;\n\ttreehash_inst\t*treehash;\n\n\tu_int32_t\tidx;\t\t \n\tu_int32_t\tmaxidx;\t\t \n\tint\t\thave_state;\t \n\tint\t\tlockfd;\t\t \n\tu_char\t\tallow_update;\t \n\tchar\t\t*enc_ciphername; \n\tu_char\t\t*enc_keyiv;\t \n\tu_int32_t\tenc_keyiv_len;\t \n};\n\nint\t sshkey_xmss_init_bds_state(struct sshkey *);\nint\t sshkey_xmss_init_enc_key(struct sshkey *, const char *);\nvoid\t sshkey_xmss_free_bds(struct sshkey *);\nint\t sshkey_xmss_get_state_from_file(struct sshkey *, const char *,\n\t    int *, int);\nint\t sshkey_xmss_encrypt_state(const struct sshkey *, struct sshbuf *,\n\t    struct sshbuf **);\nint\t sshkey_xmss_decrypt_state(const struct sshkey *, struct sshbuf *,\n\t    struct sshbuf **);\nint\t sshkey_xmss_serialize_enc_key(const struct sshkey *, struct sshbuf *);\nint\t sshkey_xmss_deserialize_enc_key(struct sshkey *, struct sshbuf *);\n\n#define PRINT(...) do { if (printerror) sshlog(__FILE__, __func__, __LINE__, \\\n    0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__); } while (0)\n\nint\nsshkey_xmss_init(struct sshkey *key, const char *name)\n{\n\tstruct ssh_xmss_state *state;\n\n\tif (key->xmss_state != NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (name == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tstate = calloc(sizeof(struct ssh_xmss_state), 1);\n\tif (state == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (strcmp(name, XMSS_SHA2_256_W16_H10_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 10;\n\t} else if (strcmp(name, XMSS_SHA2_256_W16_H16_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 16;\n\t} else if (strcmp(name, XMSS_SHA2_256_W16_H20_NAME) == 0) {\n\t\tstate->n = 32;\n\t\tstate->w = 16;\n\t\tstate->h = 20;\n\t} else {\n\t\tfree(state);\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\tif ((key->xmss_name = strdup(name)) == NULL) {\n\t\tfree(state);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tstate->k = 2;\t \n\tstate->lockfd = -1;\n\tif (xmss_set_params(&state->params, state->n, state->h, state->w,\n\t    state->k) != 0) {\n\t\tfree(state);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tkey->xmss_state = state;\n\treturn 0;\n}\n\nvoid\nsshkey_xmss_free_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tsshkey_xmss_free_bds(key);\n\tif (state) {\n\t\tif (state->enc_keyiv) {\n\t\t\texplicit_bzero(state->enc_keyiv, state->enc_keyiv_len);\n\t\t\tfree(state->enc_keyiv);\n\t\t}\n\t\tfree(state->enc_ciphername);\n\t\tfree(state);\n\t}\n\tkey->xmss_state = NULL;\n}\n\n#define SSH_XMSS_K2_MAGIC\t\"k=2\"\n#define num_stack(x)\t\t((x->h+1)*(x->n))\n#define num_stacklevels(x)\t(x->h+1)\n#define num_auth(x)\t\t((x->h)*(x->n))\n#define num_keep(x)\t\t((x->h >> 1)*(x->n))\n#define num_th_nodes(x)\t\t((x->h - x->k)*(x->n))\n#define num_retain(x)\t\t(((1ULL << x->k) - x->k - 1) * (x->n))\n#define num_treehash(x)\t\t((x->h) - (x->k))\n\nint\nsshkey_xmss_init_bds_state(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\tu_int32_t i;\n\n\tstate->stackoffset = 0;\n\tif ((state->stack = calloc(num_stack(state), 1)) == NULL ||\n\t    (state->stacklevels = calloc(num_stacklevels(state), 1))== NULL ||\n\t    (state->auth = calloc(num_auth(state), 1)) == NULL ||\n\t    (state->keep = calloc(num_keep(state), 1)) == NULL ||\n\t    (state->th_nodes = calloc(num_th_nodes(state), 1)) == NULL ||\n\t    (state->retain = calloc(num_retain(state), 1)) == NULL ||\n\t    (state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL) {\n\t\tsshkey_xmss_free_bds(key);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tfor (i = 0; i < state->h - state->k; i++)\n\t\tstate->treehash[i].node = &state->th_nodes[state->n*i];\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\treturn 0;\n}\n\nvoid\nsshkey_xmss_free_bds(struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn;\n\tfree(state->stack);\n\tfree(state->stacklevels);\n\tfree(state->auth);\n\tfree(state->keep);\n\tfree(state->th_nodes);\n\tfree(state->retain);\n\tfree(state->treehash);\n\tstate->stack = NULL;\n\tstate->stacklevels = NULL;\n\tstate->auth = NULL;\n\tstate->keep = NULL;\n\tstate->th_nodes = NULL;\n\tstate->retain = NULL;\n\tstate->treehash = NULL;\n}\n\nvoid *\nsshkey_xmss_params(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->params;\n}\n\nvoid *\nsshkey_xmss_bds_state(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn NULL;\n\treturn &state->bds;\n}\n\nint\nsshkey_xmss_siglen(const struct sshkey *key, size_t *lenp)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (lenp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*lenp = 4 + state->n +\n\t    state->params.wots_par.keysize +\n\t    state->h * state->n;\n\treturn 0;\n}\n\nsize_t\nsshkey_xmss_pklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 2;\n}\n\nsize_t\nsshkey_xmss_sklen(const struct sshkey *key)\n{\n\tstruct ssh_xmss_state *state = key->xmss_state;\n\n\tif (state == NULL)\n\t\treturn 0;\n\treturn state->n * 4 + 4;\n}\n\nint\nsshkey_xmss_init_enc_key(struct sshkey *k, const char *ciphername)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tconst struct sshcipher *cipher;\n\tsize_t keylen = 0, ivlen = 0;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((state->enc_ciphername = strdup(ciphername)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tstate->enc_keyiv_len = keylen + ivlen;\n\tif ((state->enc_keyiv = calloc(state->enc_keyiv_len, 1)) == NULL) {\n\t\tfree(state->enc_ciphername);\n\t\tstate->enc_ciphername = NULL;\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tarc4random_buf(state->enc_keyiv, state->enc_keyiv_len);\n\treturn 0;\n}\n\nint\nsshkey_xmss_serialize_enc_key(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r;\n\n\tif (state == NULL || state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b, state->enc_ciphername)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->enc_keyiv,\n\t    state->enc_keyiv_len)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nint\nsshkey_xmss_deserialize_enc_key(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tsize_t len;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_cstring(b, &state->enc_ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->enc_keyiv, &len)) != 0)\n\t\treturn r;\n\tstate->enc_keyiv_len = len;\n\treturn 0;\n}\n\nint\nsshkey_xmss_serialize_pk_info(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info = 1;\n\tu_int32_t idx;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (opts != SSHKEY_SERIALIZE_INFO)\n\t\treturn 0;\n\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\tif ((r = sshbuf_put_u8(b, have_info)) != 0 ||\n\t    (r = sshbuf_put_u32(b, idx)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nint\nsshkey_xmss_deserialize_pk_info(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char have_info;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t \n\tif (sshbuf_len(b) == 0)\n\t\treturn 0;\n\tif ((r = sshbuf_get_u8(b, &have_info)) != 0)\n\t\treturn r;\n\tif (have_info != 1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->maxidx)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nint\nsshkey_xmss_generate_private_key(struct sshkey *k, int bits)\n{\n\tint r;\n\tconst char *name;\n\n\tif (bits == 10) {\n\t\tname = XMSS_SHA2_256_W16_H10_NAME;\n\t} else if (bits == 16) {\n\t\tname = XMSS_SHA2_256_W16_H16_NAME;\n\t} else if (bits == 20) {\n\t\tname = XMSS_SHA2_256_W16_H20_NAME;\n\t} else {\n\t\tname = XMSS_DEFAULT_NAME;\n\t}\n\tif ((r = sshkey_xmss_init(k, name)) != 0 ||\n\t    (r = sshkey_xmss_init_bds_state(k)) != 0 ||\n\t    (r = sshkey_xmss_init_enc_key(k, XMSS_CIPHERNAME)) != 0)\n\t\treturn r;\n\tif ((k->xmss_pk = malloc(sshkey_xmss_pklen(k))) == NULL ||\n\t    (k->xmss_sk = malloc(sshkey_xmss_sklen(k))) == NULL) {\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\txmss_keypair(k->xmss_pk, k->xmss_sk, sshkey_xmss_bds_state(k),\n\t    sshkey_xmss_params(k));\n\treturn 0;\n}\n\nint\nsshkey_xmss_get_state_from_file(struct sshkey *k, const char *filename,\n    int *have_file, int printerror)\n{\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tint ret = SSH_ERR_SYSTEM_ERROR, r, fd = -1;\n\tu_int32_t len;\n\tunsigned char buf[4], *data = NULL;\n\n\t*have_file = 0;\n\tif ((fd = open(filename, O_RDONLY)) >= 0) {\n\t\t*have_file = 1;\n\t\tif (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\t\tPRINT(\"corrupt state file: %s\", filename);\n\t\t\tgoto done;\n\t\t}\n\t\tlen = PEEK_U32(buf);\n\t\tif ((data = calloc(len, 1)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (atomicio(read, fd, data, len) != len) {\n\t\t\tPRINT(\"cannot read blob: %s\", filename);\n\t\t\tgoto done;\n\t\t}\n\t\tif ((enc = sshbuf_from(data, len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t\tsshkey_xmss_free_bds(k);\n\t\tif ((r = sshkey_xmss_decrypt_state(k, enc, &b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0) {\n\t\t\tret = r;\n\t\t\tgoto done;\n\t\t}\n\t\tret = 0;\n\t}\ndone:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(data);\n\tsshbuf_free(enc);\n\tsshbuf_free(b);\n\treturn ret;\n}\n\nint\nsshkey_xmss_get_state(const struct sshkey *k, int printerror)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx = 0;\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *lockfile = NULL;\n\tint lockfd = -1, have_state = 0, have_ostate, tries = 0;\n\tint ret = SSH_ERR_INVALID_ARGUMENT, r;\n\n\tif (state == NULL)\n\t\tgoto done;\n\t \n\tif (state->maxidx) {\n\t\t \n\t\tidx = PEEK_U32(k->xmss_sk);\n\t\tif (idx < state->maxidx) {\n\t\t\tstate->allow_update = 1;\n\t\t\treturn 0;\n\t\t}\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&lockfile, \"%s.lock\", filename) == -1 ||\n\t    asprintf(&statefile, \"%s.state\", filename) == -1 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) == -1) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((lockfd = open(lockfile, O_CREAT|O_RDONLY, 0600)) == -1) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"cannot open/create: %s\", lockfile);\n\t\tgoto done;\n\t}\n\twhile (flock(lockfd, LOCK_EX|LOCK_NB) == -1) {\n\t\tif (errno != EWOULDBLOCK) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"cannot lock: %s\", lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tif (++tries > 10) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"giving up on: %s\", lockfile);\n\t\t\tgoto done;\n\t\t}\n\t\tusleep(1000*100*tries);\n\t}\n\t \n\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t    statefile, &have_state, printerror)) != 0) {\n\t\tif ((r = sshkey_xmss_get_state_from_file((struct sshkey *)k,\n\t\t    ostatefile, &have_ostate, printerror)) == 0) {\n\t\t\tstate->allow_update = 1;\n\t\t\tr = sshkey_xmss_forward_state(k, 1);\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\t\tstate->allow_update = 0;\n\t\t}\n\t}\n\tif (!have_state && !have_ostate) {\n\t\t \n\t\tif (state->bds.auth == NULL)\n\t\t\tgoto done;\n\t\tPRINT(\"start from scratch idx 0: %u\", state->idx);\n\t} else if (r != 0) {\n\t\tret = r;\n\t\tgoto done;\n\t}\n\tif (state->idx + 1 < state->idx) {\n\t\tPRINT(\"state wrap: %u\", state->idx);\n\t\tgoto done;\n\t}\n\tstate->have_state = have_state;\n\tstate->lockfd = lockfd;\n\tstate->allow_update = 1;\n\tlockfd = -1;\n\tret = 0;\ndone:\n\tif (lockfd != -1)\n\t\tclose(lockfd);\n\tfree(lockfile);\n\tfree(statefile);\n\tfree(ostatefile);\n\treturn ret;\n}\n\nint\nsshkey_xmss_forward_state(const struct sshkey *k, u_int32_t reserve)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_char *sig = NULL;\n\tsize_t required_siglen;\n\tunsigned long long smlen;\n\tu_char data;\n\tint ret, r;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (reserve == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->idx + reserve <= state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(k, &required_siglen)) != 0)\n\t\treturn r;\n\tif ((sig = malloc(required_siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\twhile (reserve-- > 0) {\n\t\tstate->idx = PEEK_U32(k->xmss_sk);\n\t\tsmlen = required_siglen;\n\t\tif ((ret = xmss_sign(k->xmss_sk, sshkey_xmss_bds_state(k),\n\t\t    sig, &smlen, &data, 0, sshkey_xmss_params(k))) != 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(sig);\n\treturn r;\n}\n\nint\nsshkey_xmss_update_state(const struct sshkey *k, int printerror)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *b = NULL, *enc = NULL;\n\tu_int32_t idx = 0;\n\tunsigned char buf[4];\n\tchar *filename = NULL;\n\tchar *statefile = NULL, *ostatefile = NULL, *nstatefile = NULL;\n\tint fd = -1;\n\tint ret = SSH_ERR_INVALID_ARGUMENT;\n\n\tif (state == NULL || !state->allow_update)\n\t\treturn ret;\n\tif (state->maxidx) {\n\t\t \n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tidx = PEEK_U32(k->xmss_sk);\n\tif (idx == state->idx) {\n\t\t \n\t\tret = 0;\n\t\tgoto done;\n\t} else if (idx != state->idx + 1) {\n\t\tPRINT(\"more than one signature happened: idx %u state %u\",\n\t\t    idx, state->idx);\n\t\tgoto done;\n\t}\n\tstate->idx = idx;\n\tif ((filename = k->xmss_filename) == NULL)\n\t\tgoto done;\n\tif (asprintf(&statefile, \"%s.state\", filename) == -1 ||\n\t    asprintf(&ostatefile, \"%s.ostate\", filename) == -1 ||\n\t    asprintf(&nstatefile, \"%s.nstate\", filename) == -1) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tunlink(nstatefile);\n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_serialize_state(k, b)) != 0) {\n\t\tPRINT(\"SERLIALIZE FAILED: %d\", ret);\n\t\tgoto done;\n\t}\n\tif ((ret = sshkey_xmss_encrypt_state(k, b, &enc)) != 0) {\n\t\tPRINT(\"ENCRYPT FAILED: %d\", ret);\n\t\tgoto done;\n\t}\n\tif ((fd = open(nstatefile, O_CREAT|O_WRONLY|O_EXCL, 0600)) == -1) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"open new state file: %s\", nstatefile);\n\t\tgoto done;\n\t}\n\tPOKE_U32(buf, sshbuf_len(enc));\n\tif (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"write new state file hdr: %s\", nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(enc), sshbuf_len(enc)) !=\n\t    sshbuf_len(enc)) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"write new state file data: %s\", nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (fsync(fd) == -1) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"sync new state file: %s\", nstatefile);\n\t\tclose(fd);\n\t\tgoto done;\n\t}\n\tif (close(fd) == -1) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"close new state file: %s\", nstatefile);\n\t\tgoto done;\n\t}\n\tif (state->have_state) {\n\t\tunlink(ostatefile);\n\t\tif (link(statefile, ostatefile)) {\n\t\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\t\tPRINT(\"backup state %s to %s\", statefile, ostatefile);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tif (rename(nstatefile, statefile) == -1) {\n\t\tret = SSH_ERR_SYSTEM_ERROR;\n\t\tPRINT(\"rename %s to %s\", nstatefile, statefile);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (state->lockfd != -1) {\n\t\tclose(state->lockfd);\n\t\tstate->lockfd = -1;\n\t}\n\tif (nstatefile)\n\t\tunlink(nstatefile);\n\tfree(statefile);\n\tfree(ostatefile);\n\tfree(nstatefile);\n\tsshbuf_free(b);\n\tsshbuf_free(enc);\n\treturn ret;\n}\n\nint\nsshkey_xmss_serialize_state(const struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, node;\n\tint r;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (state->stack == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->stackoffset = state->bds.stackoffset;\t \n\tif ((r = sshbuf_put_cstring(b, SSH_XMSS_K2_MAGIC)) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->idx)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stack, num_stack(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, state->stackoffset)) != 0 ||\n\t    (r = sshbuf_put_string(b, state->stacklevels, num_stacklevels(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->auth, num_auth(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->keep, num_keep(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->th_nodes, num_th_nodes(state))) != 0 ||\n\t    (r = sshbuf_put_string(b, state->retain, num_retain(state))) != 0 ||\n\t    (r = sshbuf_put_u32(b, num_treehash(state))) != 0)\n\t\treturn r;\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tnode = th->node - state->th_nodes;\n\t\tif ((r = sshbuf_put_u32(b, th->h)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, th->completed)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, node)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nint\nsshkey_xmss_serialize_state_opt(const struct sshkey *k, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tint r = SSH_ERR_INVALID_ARGUMENT;\n\tu_char have_stack, have_filename, have_enc;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_u8(b, opts)) != 0)\n\t\treturn r;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_serialize_enc_key(k, b)) != 0)\n\t\t\treturn r;\n\t\tr = sshkey_xmss_serialize_state(k, b);\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_SHIELD:\n\t\t \n\t\thave_stack = state->stack != NULL;\n\t\tif ((r = sshbuf_put_u8(b, have_stack)) != 0)\n\t\t\treturn r;\n\t\tif (have_stack) {\n\t\t\tstate->idx = PEEK_U32(k->xmss_sk);\t \n\t\t\tif ((r = sshkey_xmss_serialize_state(k, b)) != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\thave_filename = k->xmss_filename != NULL;\n\t\tif ((r = sshbuf_put_u8(b, have_filename)) != 0)\n\t\t\treturn r;\n\t\tif (have_filename &&\n\t\t    (r = sshbuf_put_cstring(b, k->xmss_filename)) != 0)\n\t\t\treturn r;\n\t\thave_enc = state->enc_keyiv != NULL;\n\t\tif ((r = sshbuf_put_u8(b, have_enc)) != 0)\n\t\t\treturn r;\n\t\tif (have_enc &&\n\t\t    (r = sshkey_xmss_serialize_enc_key(k, b)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshbuf_put_u32(b, state->maxidx)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, state->allow_update)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nint\nsshkey_xmss_deserialize_state(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\ttreehash_inst *th;\n\tu_int32_t i, lh, node;\n\tsize_t ls, lsl, la, lk, ln, lr;\n\tchar *magic;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (state == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (k->xmss_sk == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((state->treehash = calloc(num_treehash(state),\n\t    sizeof(treehash_inst))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &magic, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->idx)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->stack, &ls)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &state->stackoffset)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->stacklevels, &lsl)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->auth, &la)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->keep, &lk)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->th_nodes, &ln)) != 0 ||\n\t    (r = sshbuf_get_string(b, &state->retain, &lr)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &lh)) != 0)\n\t\tgoto out;\n\tif (strcmp(magic, SSH_XMSS_K2_MAGIC) != 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\t \n\tif (ls != num_stack(state) ||\n\t    lsl != num_stacklevels(state) ||\n\t    la != num_auth(state) ||\n\t    lk != num_keep(state) ||\n\t    ln != num_th_nodes(state) ||\n\t    lr != num_retain(state) ||\n\t    lh != num_treehash(state)) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < num_treehash(state); i++) {\n\t\tth = &state->treehash[i];\n\t\tif ((r = sshbuf_get_u32(b, &th->h)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &th->next_idx)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &th->stackusage)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &th->completed)) != 0 ||\n\t\t    (r = sshbuf_get_u32(b, &node)) != 0)\n\t\t\tgoto out;\n\t\tif (node < num_th_nodes(state))\n\t\t\tth->node = &state->th_nodes[node];\n\t}\n\tPOKE_U32(k->xmss_sk, state->idx);\n\txmss_set_bds_state(&state->bds, state->stack, state->stackoffset,\n\t    state->stacklevels, state->auth, state->keep, state->treehash,\n\t    state->retain, 0);\n\t \n\tr = 0;\n out:\n\tfree(magic);\n\treturn r;\n}\n\nint\nsshkey_xmss_deserialize_state_opt(struct sshkey *k, struct sshbuf *b)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tenum sshkey_serialize_rep opts;\n\tu_char have_state, have_stack, have_filename, have_enc;\n\tint r;\n\n\tif ((r = sshbuf_get_u8(b, &have_state)) != 0)\n\t\treturn r;\n\n\topts = have_state;\n\tswitch (opts) {\n\tcase SSHKEY_SERIALIZE_DEFAULT:\n\t\tr = 0;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_SHIELD:\n\t\tif ((r = sshbuf_get_u8(b, &have_stack)) != 0)\n\t\t\treturn r;\n\t\tif (have_stack &&\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshbuf_get_u8(b, &have_filename)) != 0)\n\t\t\treturn r;\n\t\tif (have_filename &&\n\t\t    (r = sshbuf_get_cstring(b, &k->xmss_filename, NULL)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshbuf_get_u8(b, &have_enc)) != 0)\n\t\t\treturn r;\n\t\tif (have_enc &&\n\t\t    (r = sshkey_xmss_deserialize_enc_key(k, b)) != 0)\n\t\t\treturn r;\n\t\tif ((r = sshbuf_get_u32(b, &state->maxidx)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &state->allow_update)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_STATE:\n\t\tif ((r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tcase SSHKEY_SERIALIZE_FULL:\n\t\tif ((r = sshkey_xmss_deserialize_enc_key(k, b)) != 0 ||\n\t\t    (r = sshkey_xmss_deserialize_state(k, b)) != 0)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nint\nsshkey_xmss_encrypt_state(const struct sshkey *k, struct sshbuf *b,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *encrypted = NULL, *encoded = NULL, *padded = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tu_char *cp, *key, *iv = NULL;\n\tsize_t i, keylen, ivlen, blocksize, authlen, encrypted_len, aadlen;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\tif ((encrypted = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (padded = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, state->idx);\n\n\tif ((r = sshbuf_put(encoded, XMSS_MAGIC, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, state->idx)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshbuf_putb(padded, b)) != 0)\n\t\tgoto out;\n\ti = 0;\n\twhile (sshbuf_len(padded) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(padded, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\tencrypted_len = sshbuf_len(padded);\n\n\t \n\tif ((r = sshbuf_put_u32(encoded, encrypted_len)) != 0)\n\t\tgoto out;\n\taadlen = sshbuf_len(encoded);\n\n\t \n\tif ((r = sshbuf_putb(encoded, padded)) != 0)\n\t\tgoto out;\n\n\t \n\t \n\tif ((r = sshbuf_reserve(encrypted,\n\t    encrypted_len + aadlen + authlen, &cp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 1)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, cp, sshbuf_ptr(encoded),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t \n\tr = 0;\n out:\n\tif (retp != NULL) {\n\t\t*retp = encrypted;\n\t\tencrypted = NULL;\n\t}\n\tsshbuf_free(padded);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\tfree(iv);\n\treturn r;\n}\n\nint\nsshkey_xmss_decrypt_state(const struct sshkey *k, struct sshbuf *encoded,\n   struct sshbuf **retp)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tstruct sshbuf *copy = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tu_char *key, *iv = NULL, *dp;\n\tsize_t keylen, ivlen, authlen, aadlen;\n\tu_int blocksize, encrypted_len, index;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (state == NULL ||\n\t    state->enc_keyiv == NULL ||\n\t    state->enc_ciphername == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((cipher = cipher_by_name(state->enc_ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif (state->enc_keyiv_len != keylen + ivlen) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tkey = state->enc_keyiv;\n\n\tif ((copy = sshbuf_fromb(encoded)) == NULL ||\n\t    (decrypted = sshbuf_new()) == NULL ||\n\t    (iv = malloc(ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sshbuf_len(encoded) < sizeof(XMSS_MAGIC) ||\n\t    memcmp(sshbuf_ptr(encoded), XMSS_MAGIC, sizeof(XMSS_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tif ((r = sshbuf_consume(encoded, sizeof(XMSS_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &index)) != 0 ||\n\t    (r = sshbuf_get_u32(encoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\t \n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tif (sshbuf_len(encoded) < authlen ||\n\t    sshbuf_len(encoded) - authlen < encrypted_len) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\taadlen = sshbuf_len(copy) - sshbuf_len(encoded);\n\n\t \n\tmemcpy(iv, key + keylen, ivlen);\n\tPOKE_U32(iv, index);\n\n\t \n\tif ((r = sshbuf_reserve(decrypted, aadlen + encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    iv, ivlen, 0)) != 0 ||\n\t    (r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(copy),\n\t    encrypted_len, aadlen, authlen)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshbuf_consume(encoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(encoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_consume(decrypted, aadlen)) != 0)\n\t\tgoto out;\n\t \n\n\t \n\tr = 0;\n\tif (retp != NULL) {\n\t\t*retp = decrypted;\n\t\tdecrypted = NULL;\n\t}\n out:\n\tcipher_free(ciphercontext);\n\tsshbuf_free(copy);\n\tsshbuf_free(decrypted);\n\tfree(iv);\n\treturn r;\n}\n\nu_int32_t\nsshkey_xmss_signatures_left(const struct sshkey *k)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\tu_int32_t idx;\n\n\tif (sshkey_type_plain(k->type) == KEY_XMSS && state &&\n\t    state->maxidx) {\n\t\tidx = k->xmss_sk ? PEEK_U32(k->xmss_sk) : state->idx;\n\t\tif (idx < state->maxidx)\n\t\t\treturn state->maxidx - idx;\n\t}\n\treturn 0;\n}\n\nint\nsshkey_xmss_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tstruct ssh_xmss_state *state = k->xmss_state;\n\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (maxsign == 0)\n\t\treturn 0;\n\tif (state->idx + maxsign < state->idx)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tstate->maxidx = state->idx + maxsign;\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}