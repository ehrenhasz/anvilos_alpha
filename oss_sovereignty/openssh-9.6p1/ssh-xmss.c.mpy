{
  "module_name": "ssh-xmss.c",
  "hash_id": "af112a1f7f0f89961260e434707f3830d3d001a5990a1aed871e2dcbc5739f68",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-xmss.c",
  "human_readable_source": " \n \n#include \"includes.h\"\n#ifdef WITH_XMSS\n\n#define SSHKEY_INTERNAL\n#include <sys/types.h>\n#include <limits.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <unistd.h>\n\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"sshkey-xmss.h\"\n#include \"ssherr.h\"\n#include \"ssh.h\"\n\n#include \"xmss_fast.h\"\n\nstatic void\nssh_xmss_cleanup(struct sshkey *k)\n{\n\tfreezero(k->xmss_pk, sshkey_xmss_pklen(k));\n\tfreezero(k->xmss_sk, sshkey_xmss_sklen(k));\n\tsshkey_xmss_free_state(k);\n\tfree(k->xmss_name);\n\tfree(k->xmss_filename);\n\tk->xmss_pk = NULL;\n\tk->xmss_sk = NULL;\n\tk->xmss_name = NULL;\n\tk->xmss_filename = NULL;\n}\n\nstatic int\nssh_xmss_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a->xmss_pk == NULL || b->xmss_pk == NULL)\n\t\treturn 0;\n\tif (sshkey_xmss_pklen(a) != sshkey_xmss_pklen(b))\n\t\treturn 0;\n\tif (memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nssh_xmss_serialize_public(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\n\tif (key->xmss_name == NULL || key->xmss_pk == NULL ||\n\t    sshkey_xmss_pklen(key) == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t    sshkey_xmss_pklen(key))) != 0 ||\n\t    (r = sshkey_xmss_serialize_pk_info(key, b, opts)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_xmss_serialize_private(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\n\tif (key->xmss_name == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t \n\tif ((r = sshbuf_put_cstring(b, key->xmss_name)) != 0 ||\n\t    (r = sshbuf_put_string(b, key->xmss_pk,\n\t    sshkey_xmss_pklen(key))) != 0 ||\n\t    (r = sshbuf_put_string(b, key->xmss_sk,\n\t    sshkey_xmss_sklen(key))) != 0 ||\n\t    (r = sshkey_xmss_serialize_state_opt(key, b, opts)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_xmss_copy_public(const struct sshkey *from, struct sshkey *to)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_int32_t left;\n\tsize_t pklen;\n\n\tif ((r = sshkey_xmss_init(to, from->xmss_name)) != 0)\n\t\treturn r;\n\tif (from->xmss_pk == NULL)\n\t\treturn 0;  \n\n\tif ((pklen = sshkey_xmss_pklen(from)) == 0 ||\n\t    sshkey_xmss_pklen(to) != pklen)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((to->xmss_pk = malloc(pklen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tmemcpy(to->xmss_pk, from->xmss_pk, pklen);\n\t \n\tleft = sshkey_xmss_signatures_left(from);\n\tif (left)\n\t\tsshkey_xmss_enable_maxsign(to, left);\n\treturn 0;\n}\n\nstatic int\nssh_xmss_deserialize_public(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tsize_t len = 0;\n\tchar *xmss_name = NULL;\n\tu_char *pk = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((ret = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0)\n\t\tgoto out;\n\tif ((ret = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\tgoto out;\n\tif ((ret = sshbuf_get_string(b, &pk, &len)) != 0)\n\t\tgoto out;\n\tif (len == 0 || len != sshkey_xmss_pklen(key)) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey->xmss_pk = pk;\n\tpk = NULL;\n\tif (!sshkey_is_cert(key) &&\n\t    (ret = sshkey_xmss_deserialize_pk_info(key, b)) != 0)\n\t\tgoto out;\n\t \n\tret = 0;\n out:\n\tfree(xmss_name);\n\tfreezero(pk, len);\n\treturn ret;\n}\n\nstatic int\nssh_xmss_deserialize_private(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\tchar *xmss_name = NULL;\n\tsize_t pklen = 0, sklen = 0;\n\tu_char *xmss_pk = NULL, *xmss_sk = NULL;\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &xmss_name, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &xmss_pk, &pklen)) != 0 ||\n\t    (r = sshbuf_get_string(b, &xmss_sk, &sklen)) != 0)\n\t\tgoto out;\n\tif (!sshkey_is_cert(key) &&\n\t    (r = sshkey_xmss_init(key, xmss_name)) != 0)\n\t\tgoto out;\n\tif (pklen != sshkey_xmss_pklen(key) ||\n\t    sklen != sshkey_xmss_sklen(key)) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tkey->xmss_pk = xmss_pk;\n\tkey->xmss_sk = xmss_sk;\n\txmss_pk = xmss_sk = NULL;\n\t \n\tif ((r = sshkey_xmss_deserialize_state_opt(key, b)) != 0)\n\t\tgoto out;\n\t \n\tr = 0;\n out:\n\tfree(xmss_name);\n\tfreezero(xmss_pk, pklen);\n\tfreezero(xmss_sk, sklen);\n\treturn r;\n}\n\nstatic int\nssh_xmss_sign(struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\tu_char *sig = NULL;\n\tsize_t slen = 0, len = 0, required_siglen;\n\tunsigned long long smlen;\n\tint r, ret;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_sk == NULL ||\n\t    sshkey_xmss_params(key) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (datalen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tsmlen = slen = datalen + required_siglen;\n\tif ((sig = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_xmss_get_state(key, 1)) != 0)\n\t\tgoto out;\n\tif ((ret = xmss_sign(key->xmss_sk, sshkey_xmss_bds_state(key), sig, &smlen,\n\t    data, datalen, sshkey_xmss_params(key))) != 0 || smlen <= datalen) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;  \n\t\tgoto out;\n\t}\n\t \n\tif ((b = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(b, \"ssh-xmss@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(b, sig, smlen - datalen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\t \n\tr = 0;\n out:\n\tif ((ret = sshkey_xmss_update_state(key, 1)) != 0) {\n\t\t \n\t\tif (r == 0 && sigp != NULL && *sigp != NULL) {\n\t\t\texplicit_bzero(*sigp, len);\n\t\t\tfree(*sigp);\n\t\t}\n\t\tif (sigp != NULL)\n\t\t\t*sigp = NULL;\n\t\tif (lenp != NULL)\n\t\t\t*lenp = 0;\n\t\tr = ret;\n\t}\n\tsshbuf_free(b);\n\tif (sig != NULL)\n\t\tfreezero(sig, slen);\n\n\treturn r;\n}\n\nstatic int\nssh_xmss_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\tstruct sshbuf *b = NULL;\n\tchar *ktype = NULL;\n\tconst u_char *sigblob;\n\tu_char *sm = NULL, *m = NULL;\n\tsize_t len, required_siglen;\n\tunsigned long long smlen = 0, mlen = 0;\n\tint r, ret;\n\n\tif (key == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_XMSS ||\n\t    key->xmss_pk == NULL ||\n\t    sshkey_xmss_params(key) == NULL ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_xmss_siglen(key, &required_siglen)) != 0)\n\t\treturn r;\n\tif (dlen >= INT_MAX - required_siglen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &sigblob, &len)) != 0)\n\t\tgoto out;\n\tif (strcmp(\"ssh-xmss@openssh.com\", ktype) != 0) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\tif (len != required_siglen) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (dlen >= SIZE_MAX - len) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tsmlen = len + dlen;\n\tmlen = smlen;\n\tif ((sm = malloc(smlen)) == NULL || (m = malloc(mlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(sm, sigblob, len);\n\tmemcpy(sm+len, data, dlen);\n\tif ((ret = xmss_sign_open(m, &mlen, sm, smlen,\n\t    key->xmss_pk, sshkey_xmss_params(key))) != 0) {\n\t\tdebug2_f(\"xmss_sign_open failed: %d\", ret);\n\t}\n\tif (ret != 0 || mlen != dlen) {\n\t\tr = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\t}\n\t \n\t \n\tr = 0;\n out:\n\tif (sm != NULL)\n\t\tfreezero(sm, smlen);\n\tif (m != NULL)\n\t\tfreezero(m, smlen);\n\tsshbuf_free(b);\n\tfree(ktype);\n\treturn r;\n}\n\nstatic const struct sshkey_impl_funcs sshkey_xmss_funcs = {\n\t \t\tNULL,\n\t \t\tNULL,\n\t \tssh_xmss_cleanup,\n\t \t\tssh_xmss_equal,\n\t  ssh_xmss_serialize_public,\n\t  ssh_xmss_deserialize_public,\n\t  ssh_xmss_serialize_private,\n\t  ssh_xmss_deserialize_private,\n\t \tsshkey_xmss_generate_private_key,\n\t \tssh_xmss_copy_public,\n\t \t\tssh_xmss_sign,\n\t \t\tssh_xmss_verify,\n};\n\nconst struct sshkey_impl sshkey_xmss_impl = {\n\t \t\t\"ssh-xmss@openssh.com\",\n\t \t\"XMSS\",\n\t \t\tNULL,\n\t \t\tKEY_XMSS,\n\t \t\t0,\n\t \t\t0,\n\t \t0,\n\t \t256,\n\t \t\t&sshkey_xmss_funcs,\n};\n\nconst struct sshkey_impl sshkey_xmss_cert_impl = {\n\t \t\t\"ssh-xmss-cert-v01@openssh.com\",\n\t \t\"XMSS-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_XMSS_CERT,\n\t \t\t0,\n\t \t\t1,\n\t \t0,\n\t \t256,\n\t \t\t&sshkey_xmss_funcs,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}