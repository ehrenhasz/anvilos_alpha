{
  "module_name": "PROTOCOL.u2f",
  "hash_id": "ae8540bf6158991dab27ab40d726e071ca746c2c6a33e65217550b24cae6ae47",
  "original_prompt": "Ingested from openssh-9.6p1/PROTOCOL.u2f",
  "human_readable_source": "This document describes OpenSSH's support for U2F/FIDO security keys.\n\nBackground\n----------\n\nU2F is an open standard for two-factor authentication hardware, widely\nused for user authentication to websites. U2F tokens are ubiquitous,\navailable from a number of manufacturers and are currently by far the\ncheapest way for users to achieve hardware-backed credential storage.\n\nThe U2F protocol however cannot be trivially used as an SSH protocol key\ntype as both the inputs to the signature operation and the resultant\nsignature differ from those specified for SSH. For similar reasons,\nintegration of U2F devices cannot be achieved via the PKCS#11 API.\n\nU2F also offers a number of features that are attractive in the context\nof SSH authentication. They can be configured to require indication\nof \"user presence\" for each signature operation (typically achieved\nby requiring the user touch the key). They also offer an attestation\nmechanism at key enrollment time that can be used to prove that a\ngiven key is backed by hardware. Finally the signature format includes\na monotonic signature counter that can be used (at scale) to detect\nconcurrent use of a private key, should it be extracted from hardware.\n\nU2F private keys are generated through an enrollment operation,\nwhich takes an application ID - a URL-like string, typically \"ssh:\"\nin this case, but a HTTP origin for the case of web authentication,\nand a challenge string (typically randomly generated). The enrollment\noperation returns a public key, a key handle that must be used to invoke\nthe hardware-backed private key, some flags and signed attestation\ninformation that may be used to verify that a private key is hosted on a\nparticular hardware instance.\n\nIt is common for U2F hardware to derive private keys from the key handle\nin conjunction with a small per-device secret that is unique to the\nhardware, thus requiring little on-device storage for an effectively\nunlimited number of supported keys. This drives the requirement that\nthe key handle be supplied for each signature operation. U2F tokens\nprimarily use ECDSA signatures in the NIST-P256 field, though the FIDO2\nstandard specifies additional key types, including one based on Ed25519.\n\nUse of U2F security keys does not automatically imply multi-factor\nauthentication. From sshd's perspective, a security key constitutes a\nsingle factor of authentication, even if protected by a PIN or biometric\nauthentication.  To enable multi-factor authentication in ssh, please\nrefer to the AuthenticationMethods option in sshd_config(5).\n\n\nSSH U2F Key formats\n-------------------\n\nOpenSSH integrates U2F as new key and corresponding certificate types:\n\n\tsk-ecdsa-sha2-nistp256@openssh.com\n\tsk-ecdsa-sha2-nistp256-cert-v01@openssh.com\n\tsk-ssh-ed25519@openssh.com\n\tsk-ssh-ed25519-cert-v01@openssh.com\n\nWhile each uses ecdsa-sha256-nistp256 as the underlying signature primitive,\nkeys require extra information in the public and private keys, and in\nthe signature object itself. As such they cannot be made compatible with\nthe existing ecdsa-sha2-nistp* key types.\n\nThe format of a sk-ecdsa-sha2-nistp256@openssh.com public key is:\n\n\tstring\t\t\"sk-ecdsa-sha2-nistp256@openssh.com\"\n\tstring\t\tcurve name\n\tec_point\tQ\n\tstring\t\tapplication (user-specified, but typically \"ssh:\")\n\nThe corresponding private key contains:\n\n\tstring\t\t\"sk-ecdsa-sha2-nistp256@openssh.com\"\n\tstring\t\tcurve name\n\tec_point\tQ\n\tstring\t\tapplication (user-specified, but typically \"ssh:\")\n\tuint8\t\tflags\n\tstring\t\tkey_handle\n\tstring\t\treserved\n\nThe format of a sk-ssh-ed25519@openssh.com public key is:\n\n\tstring\t\t\"sk-ssh-ed25519@openssh.com\"\n\tstring\t\tpublic key\n\tstring\t\tapplication (user-specified, but typically \"ssh:\")\n\nWith a private half consisting of:\n\n\tstring\t\t\"sk-ssh-ed25519@openssh.com\"\n\tstring\t\tpublic key\n\tstring\t\tapplication (user-specified, but typically \"ssh:\")\n\tuint8\t\tflags\n\tstring\t\tkey_handle\n\tstring\t\treserved\n\nThe certificate form for SSH U2F keys appends the usual certificate\ninformation to the public key:\n\n\tstring\t\t\"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com\"\n\tstring\t\tnonce\n\tstring\t\tcurve name\n\tec_point\tQ\n\tstring\t\tapplication\n\tuint64\t\tserial\n\tuint32\t\ttype\n\tstring\t\tkey id\n\tstring\t\tvalid principals\n\tuint64\t\tvalid after\n\tuint64\t\tvalid before\n\tstring\t\tcritical options\n\tstring\t\textensions\n\tstring\t\treserved\n\tstring\t\tsignature key\n\tstring\t\tsignature\n\nand for security key ed25519 certificates:\n\n\tstring\t\t\"sk-ssh-ed25519-cert-v01@openssh.com\"\n\tstring\t\tnonce\n\tstring\t\tpublic key\n\tstring\t\tapplication\n\tuint64\t\tserial\n\tuint32\t\ttype\n\tstring\t\tkey id\n\tstring\t\tvalid principals\n\tuint64\t\tvalid after\n\tuint64\t\tvalid before\n\tstring\t\tcritical options\n\tstring\t\textensions\n\tstring\t\treserved\n\tstring\t\tsignature key\n\tstring\t\tsignature\n\nBoth security key certificates use the following encoding for private keys:\n\n\tstring\t\ttype (e.g. \"sk-ssh-ed25519-cert-v01@openssh.com\")\n\tstring\t\tpubkey (the above key/cert structure)\n\tstring\t\tapplication\n\tuint8\t\tflags\n\tstring\t\tkey_handle\n\tstring\t\treserved\n\nDuring key generation, the hardware also returns attestation information\nthat may be used to cryptographically prove that a given key is\nhardware-backed. Unfortunately, the protocol required for this proof is\nnot privacy-preserving and may be used to identify U2F tokens with at\nleast manufacturer and batch number granularity. For this reason, we\nchoose not to include this information in the public key or save it by\ndefault.\n\nAttestation information is useful for out-of-band key and certificate\nregistration workflows, e.g. proving to a CA that a key is backed\nby trusted hardware before it will issue a certificate. To support this\ncase, OpenSSH optionally allows retaining the attestation information\nat the time of key generation. It will take the following format:\n\n\tstring\t\t\"ssh-sk-attest-v01\"\n\tstring\t\tattestation certificate\n\tstring\t\tenrollment signature\n\tstring\t\tauthenticator data (CBOR encoded)\n\tuint32\t\treserved flags\n\tstring\t\treserved string\n\nA previous version of this format, emitted prior to OpenSSH 8.4 omitted\nthe authenticator data.\n\n\tstring\t\t\"ssh-sk-attest-v00\"\n\tstring\t\tattestation certificate\n\tstring\t\tenrollment signature\n\tuint32\t\treserved flags\n\tstring\t\treserved string\n\nOpenSSH treats the attestation certificate and enrollment signatures as\nopaque objects and does no interpretation of them itself.\n\nSSH U2F signatures\n------------------\n\nIn addition to the message to be signed, the U2F signature operation\nrequires the key handle and a few additional parameters. The signature\nis signed over a blob that consists of:\n\n\tbyte[32]\tSHA256(application)\n\tbyte\t\tflags (including \"user present\", extensions present)\n\tuint32\t\tcounter\n\tbyte[]\t\textensions\n\tbyte[32]\tSHA256(message)\n\nNo extensions are yet defined for SSH use. If any are defined in the future,\nit will be possible to infer their presence from the contents of the \"flags\"\nvalue.\n\nThe signature returned from U2F hardware takes the following format:\n\n\tbyte\t\tflags (including \"user present\")\n\tuint32\t\tcounter\n\tbyte[]\t\tecdsa_signature (in X9.62 format).\n\nFor use in the SSH protocol, we wish to avoid server-side parsing of ASN.1\nformat data in the pre-authentication attack surface. Therefore, the\nsignature format used on the wire in SSH2_USERAUTH_REQUEST packets will\nbe reformatted to better match the existing signature encoding:\n\n\tstring\t\t\"sk-ecdsa-sha2-nistp256@openssh.com\"\n\tstring\t\tecdsa_signature\n\tbyte\t\tflags\n\tuint32\t\tcounter\n\nWhere the \"ecdsa_signature\" field follows the RFC5656 ECDSA signature\nencoding:\n\n\tmpint\t\tr\n\tmpint\t\ts\n\nFor Ed25519 keys the signature is encoded as:\n\n\tstring\t\t\"sk-ssh-ed25519@openssh.com\"\n\tstring\t\tsignature\n\tbyte\t\tflags\n\tuint32\t\tcounter\n\nwebauthn signatures\n-------------------\n\nThe W3C/FIDO webauthn[1] standard defines a mechanism for a web browser to\ninteract with FIDO authentication tokens. This standard builds upon the\nFIDO standards, but requires different signature contents to raw FIDO\nmessages. OpenSSH supports ECDSA/p256 webauthn signatures through the\n\"webauthn-sk-ecdsa-sha2-nistp256@openssh.com\" signature algorithm.\n\nThe wire encoding for a webauthn-sk-ecdsa-sha2-nistp256@openssh.com\nsignature is similar to the sk-ecdsa-sha2-nistp256@openssh.com format:\n\n\tstring\t\t\"webauthn-sk-ecdsa-sha2-nistp256@openssh.com\"\n\tstring\t\tecdsa_signature\n\tbyte\t\tflags\n\tuint32\t\tcounter\n\tstring\t\torigin\n\tstring\t\tclientData\n\tstring\t\textensions\n\nWhere \"origin\" is the HTTP origin making the signature, \"clientData\" is\nthe JSON-like structure signed by the browser and \"extensions\" are any\nextensions used in making the signature.\n\n[1] https://www.w3.org/TR/webauthn-2/\n\nssh-agent protocol extensions\n-----------------------------\n\nssh-agent requires a protocol extension to support U2F keys. At\npresent the closest analogue to Security Keys in ssh-agent are PKCS#11\ntokens, insofar as they require a middleware library to communicate with\nthe device that holds the keys. Unfortunately, the protocol message used\nto add PKCS#11 keys to ssh-agent does not include any way to send the\nkey handle to the agent as U2F keys require.\n\nTo avoid this, without having to add wholly new messages to the agent\nprotocol, we will use the existing SSH2_AGENTC_ADD_ID_CONSTRAINED message\nwith a new key constraint extension to encode a path to the middleware\nlibrary for the key. The format of this constraint extension would be:\n\n\tbyte\t\tSSH_AGENT_CONSTRAIN_EXTENSION\n\tstring\t\tsk-provider@openssh.com\n\tstring\t\tmiddleware path\n\nThis constraint-based approach does not present any compatibility\nproblems.\n\nOpenSSH integration\n-------------------\n\nU2F tokens may be attached via a number of means, including USB and NFC.\nThe USB interface is standardised around a HID protocol, but we want to\nbe able to support other transports as well as dummy implementations for\nregress testing. For this reason, OpenSSH shall support a dynamically-\nloaded middleware libraries to communicate with security keys, but offer\nsupport for the common case of USB HID security keys internally.\n\nThe middleware library need only expose a handful of functions and\nnumbers listed in sk-api.h. Included in the defined numbers is a\nSSH_SK_VERSION_MAJOR that should be incremented for each incompatible\nAPI change.\n\nmiscellaneous options may be passed to the middleware as a NULL-\nterminated array of pointers to struct sk_option. The middleware may\nignore unsupported or unknown options unless the \"required\" flag is set,\nin which case it should return failure if an unsupported option is\nrequested.\n\nAt present the following options names are supported:\n\n\t\"device\"\n\n\tSpecifies a specific FIDO device on which to perform the\n\toperation. The value in this field is interpreted by the\n\tmiddleware but it would be typical to specify a path to\n\ta /dev node for the device in question.\n\n\t\"user\"\n\n\tSpecifies the FIDO2 username used when enrolling a key,\n\toverriding OpenSSH's default of using an all-zero username.\n\nIn OpenSSH, the middleware will be invoked by using a similar mechanism to\nssh-pkcs11-helper to provide address-space containment of the\nmiddleware from ssh-agent.\n\n$OpenBSD: PROTOCOL.u2f,v 1.26 2020/09/09 03:08:01 djm Exp $\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}