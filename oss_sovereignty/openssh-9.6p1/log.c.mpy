{
  "module_name": "log.c",
  "hash_id": "05e661c3a4784846bf99dde9121f2e15076631da1925134372f031e4960c82bc",
  "original_prompt": "Ingested from openssh-9.6p1/log.c",
  "human_readable_source": " \n \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <errno.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n# include <vis.h>\n#endif\n\n#include \"log.h\"\n#include \"match.h\"\n\nstatic LogLevel log_level = SYSLOG_LEVEL_INFO;\nstatic int log_on_stderr = 1;\nstatic int log_stderr_fd = STDERR_FILENO;\nstatic int log_facility = LOG_AUTH;\nstatic const char *argv0;\nstatic log_handler_fn *log_handler;\nstatic void *log_handler_ctx;\nstatic char **log_verbose;\nstatic size_t nlog_verbose;\n\nextern char *__progname;\n\n#define LOG_SYSLOG_VIS\t(VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL)\n#define LOG_STDERR_VIS\t(VIS_SAFE|VIS_OCTAL)\n\n \n\nstatic struct {\n\tconst char *name;\n\tSyslogFacility val;\n} log_facilities[] = {\n\t{ \"DAEMON\",\tSYSLOG_FACILITY_DAEMON },\n\t{ \"USER\",\tSYSLOG_FACILITY_USER },\n\t{ \"AUTH\",\tSYSLOG_FACILITY_AUTH },\n#ifdef LOG_AUTHPRIV\n\t{ \"AUTHPRIV\",\tSYSLOG_FACILITY_AUTHPRIV },\n#endif\n\t{ \"LOCAL0\",\tSYSLOG_FACILITY_LOCAL0 },\n\t{ \"LOCAL1\",\tSYSLOG_FACILITY_LOCAL1 },\n\t{ \"LOCAL2\",\tSYSLOG_FACILITY_LOCAL2 },\n\t{ \"LOCAL3\",\tSYSLOG_FACILITY_LOCAL3 },\n\t{ \"LOCAL4\",\tSYSLOG_FACILITY_LOCAL4 },\n\t{ \"LOCAL5\",\tSYSLOG_FACILITY_LOCAL5 },\n\t{ \"LOCAL6\",\tSYSLOG_FACILITY_LOCAL6 },\n\t{ \"LOCAL7\",\tSYSLOG_FACILITY_LOCAL7 },\n\t{ NULL,\t\tSYSLOG_FACILITY_NOT_SET }\n};\n\nstatic struct {\n\tconst char *name;\n\tLogLevel val;\n} log_levels[] =\n{\n\t{ \"QUIET\",\tSYSLOG_LEVEL_QUIET },\n\t{ \"FATAL\",\tSYSLOG_LEVEL_FATAL },\n\t{ \"ERROR\",\tSYSLOG_LEVEL_ERROR },\n\t{ \"INFO\",\tSYSLOG_LEVEL_INFO },\n\t{ \"VERBOSE\",\tSYSLOG_LEVEL_VERBOSE },\n\t{ \"DEBUG\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG1\",\tSYSLOG_LEVEL_DEBUG1 },\n\t{ \"DEBUG2\",\tSYSLOG_LEVEL_DEBUG2 },\n\t{ \"DEBUG3\",\tSYSLOG_LEVEL_DEBUG3 },\n\t{ NULL,\t\tSYSLOG_LEVEL_NOT_SET }\n};\n\nLogLevel\nlog_level_get(void)\n{\n\treturn log_level;\n}\n\nSyslogFacility\nlog_facility_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_facilities[i].name; i++)\n\t\t\tif (strcasecmp(log_facilities[i].name, name) == 0)\n\t\t\t\treturn log_facilities[i].val;\n\treturn SYSLOG_FACILITY_NOT_SET;\n}\n\nconst char *\nlog_facility_name(SyslogFacility facility)\n{\n\tu_int i;\n\n\tfor (i = 0;  log_facilities[i].name; i++)\n\t\tif (log_facilities[i].val == facility)\n\t\t\treturn log_facilities[i].name;\n\treturn NULL;\n}\n\nLogLevel\nlog_level_number(char *name)\n{\n\tint i;\n\n\tif (name != NULL)\n\t\tfor (i = 0; log_levels[i].name; i++)\n\t\t\tif (strcasecmp(log_levels[i].name, name) == 0)\n\t\t\t\treturn log_levels[i].val;\n\treturn SYSLOG_LEVEL_NOT_SET;\n}\n\nconst char *\nlog_level_name(LogLevel level)\n{\n\tu_int i;\n\n\tfor (i = 0; log_levels[i].name != NULL; i++)\n\t\tif (log_levels[i].val == level)\n\t\t\treturn log_levels[i].name;\n\treturn NULL;\n}\n\nvoid\nlog_verbose_add(const char *s)\n{\n\tchar **tmp;\n\n\t \n\tif ((tmp = recallocarray(log_verbose, nlog_verbose, nlog_verbose + 1,\n\t    sizeof(*log_verbose))) != NULL) {\n\t\tlog_verbose = tmp;\n\t\tif ((log_verbose[nlog_verbose] = strdup(s)) != NULL)\n\t\t\tnlog_verbose++;\n\t}\n}\n\nvoid\nlog_verbose_reset(void)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nlog_verbose; i++)\n\t\tfree(log_verbose[i]);\n\tfree(log_verbose);\n\tlog_verbose = NULL;\n\tnlog_verbose = 0;\n}\n\n \n\nvoid\nlog_init(const char *av0, LogLevel level, SyslogFacility facility,\n    int on_stderr)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\n\targv0 = av0;\n\n\tif (log_change_level(level) != 0) {\n\t\tfprintf(stderr, \"Unrecognized internal syslog level code %d\\n\",\n\t\t    (int) level);\n\t\texit(1);\n\t}\n\n\tlog_handler = NULL;\n\tlog_handler_ctx = NULL;\n\n\tlog_on_stderr = on_stderr;\n\tif (on_stderr)\n\t\treturn;\n\n\tswitch (facility) {\n\tcase SYSLOG_FACILITY_DAEMON:\n\t\tlog_facility = LOG_DAEMON;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_USER:\n\t\tlog_facility = LOG_USER;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_AUTH:\n\t\tlog_facility = LOG_AUTH;\n\t\tbreak;\n#ifdef LOG_AUTHPRIV\n\tcase SYSLOG_FACILITY_AUTHPRIV:\n\t\tlog_facility = LOG_AUTHPRIV;\n\t\tbreak;\n#endif\n\tcase SYSLOG_FACILITY_LOCAL0:\n\t\tlog_facility = LOG_LOCAL0;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL1:\n\t\tlog_facility = LOG_LOCAL1;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL2:\n\t\tlog_facility = LOG_LOCAL2;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL3:\n\t\tlog_facility = LOG_LOCAL3;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL4:\n\t\tlog_facility = LOG_LOCAL4;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL5:\n\t\tlog_facility = LOG_LOCAL5;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL6:\n\t\tlog_facility = LOG_LOCAL6;\n\t\tbreak;\n\tcase SYSLOG_FACILITY_LOCAL7:\n\t\tlog_facility = LOG_LOCAL7;\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t    \"Unrecognized internal syslog facility code %d\\n\",\n\t\t    (int) facility);\n\t\texit(1);\n\t}\n\n\t \n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\topenlog_r(argv0 ? argv0 : __progname, LOG_PID, log_facility, &sdata);\n\tcloselog_r(&sdata);\n#else\n\topenlog(argv0 ? argv0 : __progname, LOG_PID, log_facility);\n\tcloselog();\n#endif\n}\n\nint\nlog_change_level(LogLevel new_log_level)\n{\n\t \n\tif (argv0 == NULL)\n\t\treturn 0;\n\n\tswitch (new_log_level) {\n\tcase SYSLOG_LEVEL_QUIET:\n\tcase SYSLOG_LEVEL_FATAL:\n\tcase SYSLOG_LEVEL_ERROR:\n\tcase SYSLOG_LEVEL_INFO:\n\tcase SYSLOG_LEVEL_VERBOSE:\n\tcase SYSLOG_LEVEL_DEBUG1:\n\tcase SYSLOG_LEVEL_DEBUG2:\n\tcase SYSLOG_LEVEL_DEBUG3:\n\t\tlog_level = new_log_level;\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nint\nlog_is_on_stderr(void)\n{\n\treturn log_on_stderr && log_stderr_fd == STDERR_FILENO;\n}\n\n \nvoid\nlog_redirect_stderr_to(const char *logfile)\n{\n\tint fd;\n\n\tif (logfile == NULL) {\n\t\tif (log_stderr_fd != STDERR_FILENO) {\n\t\t\tclose(log_stderr_fd);\n\t\t\tlog_stderr_fd = STDERR_FILENO;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0600)) == -1) {\n\t\tfprintf(stderr, \"Couldn't open logfile %s: %s\\n\", logfile,\n\t\t    strerror(errno));\n\t\texit(1);\n\t}\n\tlog_stderr_fd = fd;\n}\n\n#define MSGBUFSIZ 1024\n\nvoid\nset_log_handler(log_handler_fn *handler, void *ctx)\n{\n\tlog_handler = handler;\n\tlog_handler_ctx = ctx;\n}\n\nstatic void\ndo_log(LogLevel level, int force, const char *suffix, const char *fmt,\n    va_list args)\n{\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\tstruct syslog_data sdata = SYSLOG_DATA_INIT;\n#endif\n\tchar msgbuf[MSGBUFSIZ];\n\tchar fmtbuf[MSGBUFSIZ];\n\tchar *txt = NULL;\n\tint pri = LOG_INFO;\n\tint saved_errno = errno;\n\tlog_handler_fn *tmp_handler;\n\tconst char *progname = argv0 != NULL ? argv0 : __progname;\n\n\tif (!force && level > log_level)\n\t\treturn;\n\n\tswitch (level) {\n\tcase SYSLOG_LEVEL_FATAL:\n\t\tif (!log_on_stderr)\n\t\t\ttxt = \"fatal\";\n\t\tpri = LOG_CRIT;\n\t\tbreak;\n\tcase SYSLOG_LEVEL_ERROR:\n\t\tif (!log_on_stderr)\n\t\t\ttxt = \"error\";\n\t\tpri = LOG_ERR;\n\t\tbreak;\n\tcase SYSLOG_LEVEL_INFO:\n\t\tpri = LOG_INFO;\n\t\tbreak;\n\tcase SYSLOG_LEVEL_VERBOSE:\n\t\tpri = LOG_INFO;\n\t\tbreak;\n\tcase SYSLOG_LEVEL_DEBUG1:\n\t\ttxt = \"debug1\";\n\t\tpri = LOG_DEBUG;\n\t\tbreak;\n\tcase SYSLOG_LEVEL_DEBUG2:\n\t\ttxt = \"debug2\";\n\t\tpri = LOG_DEBUG;\n\t\tbreak;\n\tcase SYSLOG_LEVEL_DEBUG3:\n\t\ttxt = \"debug3\";\n\t\tpri = LOG_DEBUG;\n\t\tbreak;\n\tdefault:\n\t\ttxt = \"internal error\";\n\t\tpri = LOG_ERR;\n\t\tbreak;\n\t}\n\tif (txt != NULL && log_handler == NULL) {\n\t\tsnprintf(fmtbuf, sizeof(fmtbuf), \"%s: %s\", txt, fmt);\n\t\tvsnprintf(msgbuf, sizeof(msgbuf), fmtbuf, args);\n\t} else {\n\t\tvsnprintf(msgbuf, sizeof(msgbuf), fmt, args);\n\t}\n\tif (suffix != NULL) {\n\t\tsnprintf(fmtbuf, sizeof(fmtbuf), \"%s: %s\", msgbuf, suffix);\n\t\tstrlcpy(msgbuf, fmtbuf, sizeof(msgbuf));\n\t}\n\tstrnvis(fmtbuf, msgbuf, sizeof(fmtbuf),\n\t    log_on_stderr ? LOG_STDERR_VIS : LOG_SYSLOG_VIS);\n\tif (log_handler != NULL) {\n\t\t \n\t\ttmp_handler = log_handler;\n\t\tlog_handler = NULL;\n\t\ttmp_handler(level, force, fmtbuf, log_handler_ctx);\n\t\tlog_handler = tmp_handler;\n\t} else if (log_on_stderr) {\n\t\tsnprintf(msgbuf, sizeof msgbuf, \"%s%s%.*s\\r\\n\",\n\t\t    (log_on_stderr > 1) ? progname : \"\",\n\t\t    (log_on_stderr > 1) ? \": \" : \"\",\n\t\t    (int)sizeof msgbuf - 3, fmtbuf);\n\t\t(void)write(log_stderr_fd, msgbuf, strlen(msgbuf));\n\t} else {\n#if defined(HAVE_OPENLOG_R) && defined(SYSLOG_DATA_INIT)\n\t\topenlog_r(progname, LOG_PID, log_facility, &sdata);\n\t\tsyslog_r(pri, &sdata, \"%.500s\", fmtbuf);\n\t\tcloselog_r(&sdata);\n#else\n\t\topenlog(progname, LOG_PID, log_facility);\n\t\tsyslog(pri, \"%.500s\", fmtbuf);\n\t\tcloselog();\n#endif\n\t}\n\terrno = saved_errno;\n}\n\nvoid\nsshlog(const char *file, const char *func, int line, int showfunc,\n    LogLevel level, const char *suffix, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tsshlogv(file, func, line, showfunc, level, suffix, fmt, args);\n\tva_end(args);\n}\n\nvoid\nsshlogdie(const char *file, const char *func, int line, int showfunc,\n    LogLevel level, const char *suffix, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tsshlogv(file, func, line, showfunc, SYSLOG_LEVEL_INFO,\n\t    suffix, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}\n\nvoid\nsshsigdie(const char *file, const char *func, int line, int showfunc,\n    LogLevel level, const char *suffix, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tsshlogv(file, func, line, showfunc, SYSLOG_LEVEL_FATAL,\n\t    suffix, fmt, args);\n\tva_end(args);\n\t_exit(1);\n}\n\nvoid\nsshlogv(const char *file, const char *func, int line, int showfunc,\n    LogLevel level, const char *suffix, const char *fmt, va_list args)\n{\n\tchar tag[128], fmt2[MSGBUFSIZ + 128];\n\tint forced = 0;\n\tconst char *cp;\n\tsize_t i;\n\n\t \n\tif (nlog_verbose == 0 && level > log_level)\n\t\treturn;\n\n\tsnprintf(tag, sizeof(tag), \"%.48s:%.48s():%d (pid=%ld)\",\n\t    (cp = strrchr(file, '/')) == NULL ? file : cp + 1, func, line,\n\t    (long)getpid());\n\tfor (i = 0; i < nlog_verbose; i++) {\n\t\tif (match_pattern_list(tag, log_verbose[i], 0) == 1) {\n\t\t\tforced = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (forced)\n\t\tsnprintf(fmt2, sizeof(fmt2), \"%s: %s\", tag, fmt);\n\telse if (showfunc)\n\t\tsnprintf(fmt2, sizeof(fmt2), \"%s: %s\", func, fmt);\n\telse\n\t\tstrlcpy(fmt2, fmt, sizeof(fmt2));\n\n\tdo_log(level, forced, suffix, fmt2, args);\n}\n\nvoid\nsshlogdirect(LogLevel level, int forced, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tdo_log(level, forced, NULL, fmt, args);\n\tva_end(args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}