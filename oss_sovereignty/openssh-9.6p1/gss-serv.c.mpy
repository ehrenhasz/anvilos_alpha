{
  "module_name": "gss-serv.c",
  "hash_id": "7bed07a15f44a7ab77b4c88888f678ec7e320e7191451eada04c073c51ebe947",
  "original_prompt": "Ingested from openssh-9.6p1/gss-serv.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#ifdef GSSAPI\n\n#include <sys/types.h>\n\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"log.h\"\n#include \"channels.h\"\n#include \"session.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n\n#include \"ssh-gss.h\"\n\nextern ServerOptions options;\n\nstatic ssh_gssapi_client gssapi_client =\n    { GSS_C_EMPTY_BUFFER, GSS_C_EMPTY_BUFFER,\n    GSS_C_NO_CREDENTIAL, NULL, {NULL, NULL, NULL, NULL}};\n\nssh_gssapi_mech gssapi_null_mech =\n    { NULL, NULL, {0, NULL}, NULL, NULL, NULL, NULL};\n\n#ifdef KRB5\nextern ssh_gssapi_mech gssapi_kerberos_mech;\n#endif\n\nssh_gssapi_mech* supported_mechs[]= {\n#ifdef KRB5\n\t&gssapi_kerberos_mech,\n#endif\n\t&gssapi_null_mech,\n};\n\n \nstatic gss_OID_set supported_oids;\n\nvoid\nssh_gssapi_prepare_supported_oids(void)\n{\n\tssh_gssapi_supported_oids(&supported_oids);\n}\n\nOM_uint32\nssh_gssapi_test_oid_supported(OM_uint32 *ms, gss_OID member, int *present)\n{\n\tif (supported_oids == NULL)\n\t\tssh_gssapi_prepare_supported_oids();\n\treturn gss_test_oid_set_member(ms, member, supported_oids, present);\n}\n\n \n\n \n \nstatic OM_uint32\nssh_gssapi_acquire_cred(Gssctxt *ctx)\n{\n\tOM_uint32 status;\n\tchar lname[NI_MAXHOST];\n\tgss_OID_set oidset;\n\n\tif (options.gss_strict_acceptor) {\n\t\tgss_create_empty_oid_set(&status, &oidset);\n\t\tgss_add_oid_set_member(&status, ctx->oid, &oidset);\n\n\t\tif (gethostname(lname, HOST_NAME_MAX)) {\n\t\t\tgss_release_oid_set(&status, &oidset);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (GSS_ERROR(ssh_gssapi_import_name(ctx, lname))) {\n\t\t\tgss_release_oid_set(&status, &oidset);\n\t\t\treturn (ctx->major);\n\t\t}\n\n\t\tif ((ctx->major = gss_acquire_cred(&ctx->minor,\n\t\t    ctx->name, 0, oidset, GSS_C_ACCEPT, &ctx->creds,\n\t\t    NULL, NULL)))\n\t\t\tssh_gssapi_error(ctx);\n\n\t\tgss_release_oid_set(&status, &oidset);\n\t\treturn (ctx->major);\n\t} else {\n\t\tctx->name = GSS_C_NO_NAME;\n\t\tctx->creds = GSS_C_NO_CREDENTIAL;\n\t}\n\treturn GSS_S_COMPLETE;\n}\n\n \nOM_uint32\nssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)\n{\n\tif (*ctx)\n\t\tssh_gssapi_delete_ctx(ctx);\n\tssh_gssapi_build_ctx(ctx);\n\tssh_gssapi_set_oid(*ctx, oid);\n\treturn (ssh_gssapi_acquire_cred(*ctx));\n}\n\n \nvoid\nssh_gssapi_supported_oids(gss_OID_set *oidset)\n{\n\tint i = 0;\n\tOM_uint32 min_status;\n\tint present;\n\tgss_OID_set supported;\n\n\tgss_create_empty_oid_set(&min_status, oidset);\n\tgss_indicate_mechs(&min_status, &supported);\n\n\twhile (supported_mechs[i]->name != NULL) {\n\t\tif (GSS_ERROR(gss_test_oid_set_member(&min_status,\n\t\t    &supported_mechs[i]->oid, supported, &present)))\n\t\t\tpresent = 0;\n\t\tif (present)\n\t\t\tgss_add_oid_set_member(&min_status,\n\t\t\t    &supported_mechs[i]->oid, oidset);\n\t\ti++;\n\t}\n\n\tgss_release_oid_set(&min_status, &supported);\n}\n\n\n \n \nOM_uint32\nssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *recv_tok,\n    gss_buffer_desc *send_tok, OM_uint32 *flags)\n{\n\tOM_uint32 status;\n\tgss_OID mech;\n\n\tctx->major = gss_accept_sec_context(&ctx->minor,\n\t    &ctx->context, ctx->creds, recv_tok,\n\t    GSS_C_NO_CHANNEL_BINDINGS, &ctx->client, &mech,\n\t    send_tok, flags, NULL, &ctx->client_creds);\n\n\tif (GSS_ERROR(ctx->major))\n\t\tssh_gssapi_error(ctx);\n\n\tif (ctx->client_creds)\n\t\tdebug(\"Received some client credentials\");\n\telse\n\t\tdebug(\"Got no client credentials\");\n\n\tstatus = ctx->major;\n\n\t \n\n\tif (((flags == NULL) || ((*flags & GSS_C_MUTUAL_FLAG) &&\n\t    (*flags & GSS_C_INTEG_FLAG))) && (ctx->major == GSS_S_COMPLETE)) {\n\t\tif (ssh_gssapi_getclient(ctx, &gssapi_client))\n\t\t\tfatal(\"Couldn't convert client name\");\n\t}\n\n\treturn (status);\n}\n\n \nstatic OM_uint32\nssh_gssapi_parse_ename(Gssctxt *ctx, gss_buffer_t ename, gss_buffer_t name)\n{\n\tu_char *tok;\n\tOM_uint32 offset;\n\tOM_uint32 oidl;\n\n\ttok = ename->value;\n\n\t \n\n\tif (ename->length < 6 || memcmp(tok, \"\\x04\\x01\", 2) != 0)\n\t\treturn GSS_S_FAILURE;\n\n\t \n\n\toidl = get_u16(tok+2);  \n\toidl = oidl-2;  \n\n\t \n\tif (tok[4] != 0x06 || tok[5] != oidl ||\n\t    ename->length < oidl+6 ||\n\t    !ssh_gssapi_check_oid(ctx, tok+6, oidl))\n\t\treturn GSS_S_FAILURE;\n\n\toffset = oidl+6;\n\n\tif (ename->length < offset+4)\n\t\treturn GSS_S_FAILURE;\n\n\tname->length = get_u32(tok+offset);\n\toffset += 4;\n\n\tif (UINT_MAX - offset < name->length)\n\t\treturn GSS_S_FAILURE;\n\tif (ename->length < offset+name->length)\n\t\treturn GSS_S_FAILURE;\n\n\tname->value = xmalloc(name->length+1);\n\tmemcpy(name->value, tok+offset, name->length);\n\t((char *)name->value)[name->length] = 0;\n\n\treturn GSS_S_COMPLETE;\n}\n\n \n\n \nOM_uint32\nssh_gssapi_getclient(Gssctxt *ctx, ssh_gssapi_client *client)\n{\n\tint i = 0;\n\n\tgss_buffer_desc ename;\n\n\tclient->mech = NULL;\n\n\twhile (supported_mechs[i]->name != NULL) {\n\t\tif (supported_mechs[i]->oid.length == ctx->oid->length &&\n\t\t    (memcmp(supported_mechs[i]->oid.elements,\n\t\t    ctx->oid->elements, ctx->oid->length) == 0))\n\t\t\tclient->mech = supported_mechs[i];\n\t\ti++;\n\t}\n\n\tif (client->mech == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\tif ((ctx->major = gss_display_name(&ctx->minor, ctx->client,\n\t    &client->displayname, NULL))) {\n\t\tssh_gssapi_error(ctx);\n\t\treturn (ctx->major);\n\t}\n\n\tif ((ctx->major = gss_export_name(&ctx->minor, ctx->client,\n\t    &ename))) {\n\t\tssh_gssapi_error(ctx);\n\t\treturn (ctx->major);\n\t}\n\n\tif ((ctx->major = ssh_gssapi_parse_ename(ctx,&ename,\n\t    &client->exportedname))) {\n\t\treturn (ctx->major);\n\t}\n\n\t \n\tclient->creds = ctx->client_creds;\n\tctx->client_creds = GSS_C_NO_CREDENTIAL;\n\treturn (ctx->major);\n}\n\n \nvoid\nssh_gssapi_cleanup_creds(void)\n{\n\tif (gssapi_client.store.filename != NULL) {\n\t\t \n\t\tdebug(\"removing gssapi cred file\\\"%s\\\"\",\n\t\t    gssapi_client.store.filename);\n\t\tunlink(gssapi_client.store.filename);\n\t}\n}\n\n \nvoid\nssh_gssapi_storecreds(void)\n{\n\tif (gssapi_client.mech && gssapi_client.mech->storecreds) {\n\t\t(*gssapi_client.mech->storecreds)(&gssapi_client);\n\t} else\n\t\tdebug(\"ssh_gssapi_storecreds: Not a GSSAPI mechanism\");\n}\n\n \n \nvoid\nssh_gssapi_do_child(char ***envp, u_int *envsizep)\n{\n\n\tif (gssapi_client.store.envvar != NULL &&\n\t    gssapi_client.store.envval != NULL) {\n\t\tdebug(\"Setting %s to %s\", gssapi_client.store.envvar,\n\t\t    gssapi_client.store.envval);\n\t\tchild_set_env(envp, envsizep, gssapi_client.store.envvar,\n\t\t    gssapi_client.store.envval);\n\t}\n}\n\n \nint\nssh_gssapi_userok(char *user)\n{\n\tOM_uint32 lmin;\n\n\tif (gssapi_client.exportedname.length == 0 ||\n\t    gssapi_client.exportedname.value == NULL) {\n\t\tdebug(\"No suitable client data\");\n\t\treturn 0;\n\t}\n\tif (gssapi_client.mech && gssapi_client.mech->userok)\n\t\tif ((*gssapi_client.mech->userok)(&gssapi_client, user))\n\t\t\treturn 1;\n\t\telse {\n\t\t\t \n\t\t\tgss_release_buffer(&lmin, &gssapi_client.displayname);\n\t\t\tgss_release_buffer(&lmin, &gssapi_client.exportedname);\n\t\t\tgss_release_cred(&lmin, &gssapi_client.creds);\n\t\t\texplicit_bzero(&gssapi_client,\n\t\t\t    sizeof(ssh_gssapi_client));\n\t\t\treturn 0;\n\t\t}\n\telse\n\t\tdebug(\"ssh_gssapi_userok: Unknown GSSAPI mechanism\");\n\treturn (0);\n}\n\n \nOM_uint32\nssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)\n{\n\tctx->major = gss_verify_mic(&ctx->minor, ctx->context,\n\t    gssbuf, gssmic, NULL);\n\n\treturn (ctx->major);\n}\n\n \nconst char *ssh_gssapi_displayname(void)\n{\n\tif (gssapi_client.displayname.length == 0 ||\n\t    gssapi_client.displayname.value == NULL)\n\t\treturn NULL;\n\treturn (char *)gssapi_client.displayname.value;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}