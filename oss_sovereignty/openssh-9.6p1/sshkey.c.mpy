{
  "module_name": "sshkey.c",
  "hash_id": "13eb1c7f617daf29470fba77b4287aa5bf8854a7ba6ef3e907753bc03092ee1f",
  "original_prompt": "Ingested from openssh-9.6p1/sshkey.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <netinet/in.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <openssl/pem.h>\n#endif\n\n#include \"crypto_api.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <resolv.h>\n#include <time.h>\n#ifdef HAVE_UTIL_H\n#include <util.h>\n#endif  \n\n#include \"ssh2.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"cipher.h\"\n#include \"digest.h\"\n#define SSHKEY_INTERNAL\n#include \"sshkey.h\"\n#include \"match.h\"\n#include \"ssh-sk.h\"\n\n#ifdef WITH_XMSS\n#include \"sshkey-xmss.h\"\n#include \"xmss_fast.h\"\n#endif\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n \n#define MARK_BEGIN\t\t\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\"\n#define MARK_END\t\t\"-----END OPENSSH PRIVATE KEY-----\\n\"\n#define MARK_BEGIN_LEN\t\t(sizeof(MARK_BEGIN) - 1)\n#define MARK_END_LEN\t\t(sizeof(MARK_END) - 1)\n#define KDFNAME\t\t\t\"bcrypt\"\n#define AUTH_MAGIC\t\t\"openssh-key-v1\"\n#define SALT_LEN\t\t16\n#define DEFAULT_CIPHERNAME\t\"aes256-ctr\"\n#define\tDEFAULT_ROUNDS\t\t24\n\n \n#define LEGACY_BEGIN\t\t\"SSH PRIVATE KEY FILE FORMAT 1.1\\n\"\n\n \n#define SSHKEY_SHIELD_PREKEY_LEN\t(16 * 1024)\n#define SSHKEY_SHIELD_CIPHER\t\t\"aes256-ctr\"  \n#define SSHKEY_SHIELD_PREKEY_HASH\tSSH_DIGEST_SHA512\n\nint\tsshkey_private_serialize_opt(struct sshkey *key,\n    struct sshbuf *buf, enum sshkey_serialize_rep);\nstatic int sshkey_from_blob_internal(struct sshbuf *buf,\n    struct sshkey **keyp, int allow_cert);\n\n \nextern const struct sshkey_impl sshkey_ed25519_impl;\nextern const struct sshkey_impl sshkey_ed25519_cert_impl;\nextern const struct sshkey_impl sshkey_ed25519_sk_impl;\nextern const struct sshkey_impl sshkey_ed25519_sk_cert_impl;\n#ifdef WITH_OPENSSL\n# ifdef OPENSSL_HAS_ECC\n#  ifdef ENABLE_SK\nextern const struct sshkey_impl sshkey_ecdsa_sk_impl;\nextern const struct sshkey_impl sshkey_ecdsa_sk_cert_impl;\nextern const struct sshkey_impl sshkey_ecdsa_sk_webauthn_impl;\n#  endif  \nextern const struct sshkey_impl sshkey_ecdsa_nistp256_impl;\nextern const struct sshkey_impl sshkey_ecdsa_nistp256_cert_impl;\nextern const struct sshkey_impl sshkey_ecdsa_nistp384_impl;\nextern const struct sshkey_impl sshkey_ecdsa_nistp384_cert_impl;\n#  ifdef OPENSSL_HAS_NISTP521\nextern const struct sshkey_impl sshkey_ecdsa_nistp521_impl;\nextern const struct sshkey_impl sshkey_ecdsa_nistp521_cert_impl;\n#  endif  \n# endif  \nextern const struct sshkey_impl sshkey_rsa_impl;\nextern const struct sshkey_impl sshkey_rsa_cert_impl;\nextern const struct sshkey_impl sshkey_rsa_sha256_impl;\nextern const struct sshkey_impl sshkey_rsa_sha256_cert_impl;\nextern const struct sshkey_impl sshkey_rsa_sha512_impl;\nextern const struct sshkey_impl sshkey_rsa_sha512_cert_impl;\nextern const struct sshkey_impl sshkey_dss_impl;\nextern const struct sshkey_impl sshkey_dsa_cert_impl;\n#endif  \n#ifdef WITH_XMSS\nextern const struct sshkey_impl sshkey_xmss_impl;\nextern const struct sshkey_impl sshkey_xmss_cert_impl;\n#endif\n\nconst struct sshkey_impl * const keyimpls[] = {\n\t&sshkey_ed25519_impl,\n\t&sshkey_ed25519_cert_impl,\n#ifdef ENABLE_SK\n\t&sshkey_ed25519_sk_impl,\n\t&sshkey_ed25519_sk_cert_impl,\n#endif\n#ifdef WITH_OPENSSL\n# ifdef OPENSSL_HAS_ECC\n\t&sshkey_ecdsa_nistp256_impl,\n\t&sshkey_ecdsa_nistp256_cert_impl,\n\t&sshkey_ecdsa_nistp384_impl,\n\t&sshkey_ecdsa_nistp384_cert_impl,\n#  ifdef OPENSSL_HAS_NISTP521\n\t&sshkey_ecdsa_nistp521_impl,\n\t&sshkey_ecdsa_nistp521_cert_impl,\n#  endif  \n#  ifdef ENABLE_SK\n\t&sshkey_ecdsa_sk_impl,\n\t&sshkey_ecdsa_sk_cert_impl,\n\t&sshkey_ecdsa_sk_webauthn_impl,\n#  endif  \n# endif  \n\t&sshkey_dss_impl,\n\t&sshkey_dsa_cert_impl,\n\t&sshkey_rsa_impl,\n\t&sshkey_rsa_cert_impl,\n\t&sshkey_rsa_sha256_impl,\n\t&sshkey_rsa_sha256_cert_impl,\n\t&sshkey_rsa_sha512_impl,\n\t&sshkey_rsa_sha512_cert_impl,\n#endif  \n#ifdef WITH_XMSS\n\t&sshkey_xmss_impl,\n\t&sshkey_xmss_cert_impl,\n#endif\n\tNULL\n};\n\nstatic const struct sshkey_impl *\nsshkey_impl_from_type(int type)\n{\n\tint i;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\tif (keyimpls[i]->type == type)\n\t\t\treturn keyimpls[i];\n\t}\n\treturn NULL;\n}\n\nstatic const struct sshkey_impl *\nsshkey_impl_from_type_nid(int type, int nid)\n{\n\tint i;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\tif (keyimpls[i]->type == type &&\n\t\t    (keyimpls[i]->nid == 0 || keyimpls[i]->nid == nid))\n\t\t\treturn keyimpls[i];\n\t}\n\treturn NULL;\n}\n\nstatic const struct sshkey_impl *\nsshkey_impl_from_key(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn NULL;\n\treturn sshkey_impl_from_type_nid(k->type, k->ecdsa_nid);\n}\n\nconst char *\nsshkey_type(const struct sshkey *k)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif ((impl = sshkey_impl_from_key(k)) == NULL)\n\t\treturn \"unknown\";\n\treturn impl->shortname;\n}\n\nstatic const char *\nsshkey_ssh_name_from_type_nid(int type, int nid)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif ((impl = sshkey_impl_from_type_nid(type, nid)) == NULL)\n\t\treturn \"ssh-unknown\";\n\treturn impl->name;\n}\n\nint\nsshkey_type_is_cert(int type)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif ((impl = sshkey_impl_from_type(type)) == NULL)\n\t\treturn 0;\n\treturn impl->cert;\n}\n\nconst char *\nsshkey_ssh_name(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(k->type, k->ecdsa_nid);\n}\n\nconst char *\nsshkey_ssh_name_plain(const struct sshkey *k)\n{\n\treturn sshkey_ssh_name_from_type_nid(sshkey_type_plain(k->type),\n\t    k->ecdsa_nid);\n}\n\nint\nsshkey_type_from_name(const char *name)\n{\n\tint i;\n\tconst struct sshkey_impl *impl;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\timpl = keyimpls[i];\n\t\t \n\t\tif ((impl->name != NULL && strcmp(name, impl->name) == 0) ||\n\t\t    (!impl->cert && strcasecmp(impl->shortname, name) == 0))\n\t\t\treturn impl->type;\n\t}\n\treturn KEY_UNSPEC;\n}\n\nstatic int\nkey_type_is_ecdsa_variant(int type)\n{\n\tswitch (type) {\n\tcase KEY_ECDSA:\n\tcase KEY_ECDSA_CERT:\n\tcase KEY_ECDSA_SK:\n\tcase KEY_ECDSA_SK_CERT:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint\nsshkey_ecdsa_nid_from_name(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\tif (!key_type_is_ecdsa_variant(keyimpls[i]->type))\n\t\t\tcontinue;\n\t\tif (keyimpls[i]->name != NULL &&\n\t\t    strcmp(name, keyimpls[i]->name) == 0)\n\t\t\treturn keyimpls[i]->nid;\n\t}\n\treturn -1;\n}\n\nint\nsshkey_match_keyname_to_sigalgs(const char *keyname, const char *sigalgs)\n{\n\tint ktype;\n\n\tif (sigalgs == NULL || *sigalgs == '\\0' ||\n\t    (ktype = sshkey_type_from_name(keyname)) == KEY_UNSPEC)\n\t\treturn 0;\n\telse if (ktype == KEY_RSA) {\n\t\treturn match_pattern_list(\"ssh-rsa\", sigalgs, 0) == 1 ||\n\t\t    match_pattern_list(\"rsa-sha2-256\", sigalgs, 0) == 1 ||\n\t\t    match_pattern_list(\"rsa-sha2-512\", sigalgs, 0) == 1;\n\t} else if (ktype == KEY_RSA_CERT) {\n\t\treturn match_pattern_list(\"ssh-rsa-cert-v01@openssh.com\",\n\t\t    sigalgs, 0) == 1 ||\n\t\t    match_pattern_list(\"rsa-sha2-256-cert-v01@openssh.com\",\n\t\t    sigalgs, 0) == 1 ||\n\t\t    match_pattern_list(\"rsa-sha2-512-cert-v01@openssh.com\",\n\t\t    sigalgs, 0) == 1;\n\t} else\n\t\treturn match_pattern_list(keyname, sigalgs, 0) == 1;\n}\n\nchar *\nsshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)\n{\n\tchar *tmp, *ret = NULL;\n\tsize_t i, nlen, rlen = 0;\n\tconst struct sshkey_impl *impl;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\timpl = keyimpls[i];\n\t\tif (impl->name == NULL)\n\t\t\tcontinue;\n\t\tif (!include_sigonly && impl->sigonly)\n\t\t\tcontinue;\n\t\tif ((certs_only && !impl->cert) || (plain_only && impl->cert))\n\t\t\tcontinue;\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(impl->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, impl->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}\n\nint\nsshkey_names_valid2(const char *names, int allow_wildcard, int plain_only)\n{\n\tchar *s, *cp, *p;\n\tconst struct sshkey_impl *impl;\n\tint i, type;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((s = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, \",\")); p && *p != '\\0';\n\t    (p = strsep(&cp, \",\"))) {\n\t\ttype = sshkey_type_from_name(p);\n\t\tif (type == KEY_UNSPEC) {\n\t\t\tif (allow_wildcard) {\n\t\t\t\t \n\t\t\t\timpl = NULL;\n\t\t\t\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\t\t\t\tif (match_pattern_list(\n\t\t\t\t\t    keyimpls[i]->name, p, 0) != 0) {\n\t\t\t\t\t\timpl = keyimpls[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (impl != NULL)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t} else if (plain_only && sshkey_type_is_cert(type)) {\n\t\t\tfree(s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(s);\n\treturn 1;\n}\n\nu_int\nsshkey_size(const struct sshkey *k)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif ((impl = sshkey_impl_from_key(k)) == NULL)\n\t\treturn 0;\n\tif (impl->funcs->size != NULL)\n\t\treturn impl->funcs->size(k);\n\treturn impl->keybits;\n}\n\nstatic int\nsshkey_type_is_valid_ca(int type)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif ((impl = sshkey_impl_from_type(type)) == NULL)\n\t\treturn 0;\n\t \n\treturn !impl->cert;\n}\n\nint\nsshkey_is_cert(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\treturn sshkey_type_is_cert(k->type);\n}\n\nint\nsshkey_is_sk(const struct sshkey *k)\n{\n\tif (k == NULL)\n\t\treturn 0;\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_ECDSA_SK:\n\tcase KEY_ED25519_SK:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nint\nsshkey_type_plain(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA_CERT:\n\t\treturn KEY_RSA;\n\tcase KEY_DSA_CERT:\n\t\treturn KEY_DSA;\n\tcase KEY_ECDSA_CERT:\n\t\treturn KEY_ECDSA;\n\tcase KEY_ECDSA_SK_CERT:\n\t\treturn KEY_ECDSA_SK;\n\tcase KEY_ED25519_CERT:\n\t\treturn KEY_ED25519;\n\tcase KEY_ED25519_SK_CERT:\n\t\treturn KEY_ED25519_SK;\n\tcase KEY_XMSS_CERT:\n\t\treturn KEY_XMSS;\n\tdefault:\n\t\treturn type;\n\t}\n}\n\n \nstatic int\nsshkey_type_certified(int type)\n{\n\tswitch (type) {\n\tcase KEY_RSA:\n\t\treturn KEY_RSA_CERT;\n\tcase KEY_DSA:\n\t\treturn KEY_DSA_CERT;\n\tcase KEY_ECDSA:\n\t\treturn KEY_ECDSA_CERT;\n\tcase KEY_ECDSA_SK:\n\t\treturn KEY_ECDSA_SK_CERT;\n\tcase KEY_ED25519:\n\t\treturn KEY_ED25519_CERT;\n\tcase KEY_ED25519_SK:\n\t\treturn KEY_ED25519_SK_CERT;\n\tcase KEY_XMSS:\n\t\treturn KEY_XMSS_CERT;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n#ifdef WITH_OPENSSL\n \nint\nsshkey_curve_name_to_nid(const char *name)\n{\n\tif (strcmp(name, \"nistp256\") == 0)\n\t\treturn NID_X9_62_prime256v1;\n\telse if (strcmp(name, \"nistp384\") == 0)\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\telse if (strcmp(name, \"nistp521\") == 0)\n\t\treturn NID_secp521r1;\n# endif  \n\telse\n\t\treturn -1;\n}\n\nu_int\nsshkey_curve_nid_to_bits(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn 256;\n\tcase NID_secp384r1:\n\t\treturn 384;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn 521;\n# endif  \n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint\nsshkey_ecdsa_bits_to_nid(int bits)\n{\n\tswitch (bits) {\n\tcase 256:\n\t\treturn NID_X9_62_prime256v1;\n\tcase 384:\n\t\treturn NID_secp384r1;\n# ifdef OPENSSL_HAS_NISTP521\n\tcase 521:\n\t\treturn NID_secp521r1;\n# endif  \n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nconst char *\nsshkey_curve_nid_to_name(int nid)\n{\n\tswitch (nid) {\n\tcase NID_X9_62_prime256v1:\n\t\treturn \"nistp256\";\n\tcase NID_secp384r1:\n\t\treturn \"nistp384\";\n# ifdef OPENSSL_HAS_NISTP521\n\tcase NID_secp521r1:\n\t\treturn \"nistp521\";\n# endif  \n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nint\nsshkey_ec_nid_to_hash_alg(int nid)\n{\n\tint kbits = sshkey_curve_nid_to_bits(nid);\n\n\tif (kbits <= 0)\n\t\treturn -1;\n\n\t \n\tif (kbits <= 256)\n\t\treturn SSH_DIGEST_SHA256;\n\telse if (kbits <= 384)\n\t\treturn SSH_DIGEST_SHA384;\n\telse\n\t\treturn SSH_DIGEST_SHA512;\n}\n#endif  \n\nstatic void\ncert_free(struct sshkey_cert *cert)\n{\n\tu_int i;\n\n\tif (cert == NULL)\n\t\treturn;\n\tsshbuf_free(cert->certblob);\n\tsshbuf_free(cert->critical);\n\tsshbuf_free(cert->extensions);\n\tfree(cert->key_id);\n\tfor (i = 0; i < cert->nprincipals; i++)\n\t\tfree(cert->principals[i]);\n\tfree(cert->principals);\n\tsshkey_free(cert->signature_key);\n\tfree(cert->signature_type);\n\tfreezero(cert, sizeof(*cert));\n}\n\nstatic struct sshkey_cert *\ncert_new(void)\n{\n\tstruct sshkey_cert *cert;\n\n\tif ((cert = calloc(1, sizeof(*cert))) == NULL)\n\t\treturn NULL;\n\tif ((cert->certblob = sshbuf_new()) == NULL ||\n\t    (cert->critical = sshbuf_new()) == NULL ||\n\t    (cert->extensions = sshbuf_new()) == NULL) {\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\tcert->key_id = NULL;\n\tcert->principals = NULL;\n\tcert->signature_key = NULL;\n\tcert->signature_type = NULL;\n\treturn cert;\n}\n\nstruct sshkey *\nsshkey_new(int type)\n{\n\tstruct sshkey *k;\n\tconst struct sshkey_impl *impl = NULL;\n\n\tif (type != KEY_UNSPEC &&\n\t    (impl = sshkey_impl_from_type(type)) == NULL)\n\t\treturn NULL;\n\n\t \n\tif ((k = calloc(1, sizeof(*k))) == NULL)\n\t\treturn NULL;\n\tk->type = type;\n\tk->ecdsa_nid = -1;\n\tif (impl != NULL && impl->funcs->alloc != NULL) {\n\t\tif (impl->funcs->alloc(k) != 0) {\n\t\t\tfree(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (sshkey_is_cert(k)) {\n\t\tif ((k->cert = cert_new()) == NULL) {\n\t\t\tsshkey_free(k);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn k;\n}\n\n \nvoid\nsshkey_sk_cleanup(struct sshkey *k)\n{\n\tfree(k->sk_application);\n\tsshbuf_free(k->sk_key_handle);\n\tsshbuf_free(k->sk_reserved);\n\tk->sk_application = NULL;\n\tk->sk_key_handle = k->sk_reserved = NULL;\n}\n\nstatic void\nsshkey_free_contents(struct sshkey *k)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif (k == NULL)\n\t\treturn;\n\tif ((impl = sshkey_impl_from_type(k->type)) != NULL &&\n\t    impl->funcs->cleanup != NULL)\n\t\timpl->funcs->cleanup(k);\n\tif (sshkey_is_cert(k))\n\t\tcert_free(k->cert);\n\tfreezero(k->shielded_private, k->shielded_len);\n\tfreezero(k->shield_prekey, k->shield_prekey_len);\n}\n\nvoid\nsshkey_free(struct sshkey *k)\n{\n\tsshkey_free_contents(k);\n\tfreezero(k, sizeof(*k));\n}\n\nstatic int\ncert_compare(struct sshkey_cert *a, struct sshkey_cert *b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn 1;\n\tif (a == NULL || b == NULL)\n\t\treturn 0;\n\tif (sshbuf_len(a->certblob) != sshbuf_len(b->certblob))\n\t\treturn 0;\n\tif (timingsafe_bcmp(sshbuf_ptr(a->certblob), sshbuf_ptr(b->certblob),\n\t    sshbuf_len(a->certblob)) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint\nsshkey_sk_fields_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a->sk_application == NULL || b->sk_application == NULL)\n\t\treturn 0;\n\tif (strcmp(a->sk_application, b->sk_application) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint\nsshkey_equal_public(const struct sshkey *a, const struct sshkey *b)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif (a == NULL || b == NULL ||\n\t    sshkey_type_plain(a->type) != sshkey_type_plain(b->type))\n\t\treturn 0;\n\tif ((impl = sshkey_impl_from_type(a->type)) == NULL)\n\t\treturn 0;\n\treturn impl->funcs->equal(a, b);\n}\n\nint\nsshkey_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (a == NULL || b == NULL || a->type != b->type)\n\t\treturn 0;\n\tif (sshkey_is_cert(a)) {\n\t\tif (!cert_compare(a->cert, b->cert))\n\t\t\treturn 0;\n\t}\n\treturn sshkey_equal_public(a, b);\n}\n\n\n \nint\nsshkey_serialize_sk(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_cstring(b, key->sk_application)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nto_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain,\n  enum sshkey_serialize_rep opts)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tconst char *typename;\n\tconst struct sshkey_impl *impl;\n\n\tif (key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\ttype = force_plain ? sshkey_type_plain(key->type) : key->type;\n\n\tif (sshkey_type_is_cert(type)) {\n\t\tif (key->cert == NULL)\n\t\t\treturn SSH_ERR_EXPECTED_CERT;\n\t\tif (sshbuf_len(key->cert->certblob) == 0)\n\t\t\treturn SSH_ERR_KEY_LACKS_CERTBLOB;\n\t\t \n\t\tif ((ret = sshbuf_putb(b, key->cert->certblob)) != 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\tif ((impl = sshkey_impl_from_type(type)) == NULL)\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\n\ttypename = sshkey_ssh_name_from_type_nid(type, key->ecdsa_nid);\n\tif ((ret = sshbuf_put_cstring(b, typename)) != 0)\n\t\treturn ret;\n\treturn impl->funcs->serialize_public(key, b, opts);\n}\n\nint\nsshkey_putb(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 0, SSHKEY_SERIALIZE_DEFAULT);\n}\n\nint\nsshkey_puts_opts(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tstruct sshbuf *tmp;\n\tint r;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = to_blob_buf(key, tmp, 0, opts);\n\tif (r == 0)\n\t\tr = sshbuf_put_stringb(b, tmp);\n\tsshbuf_free(tmp);\n\treturn r;\n}\n\nint\nsshkey_puts(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_puts_opts(key, b, SSHKEY_SERIALIZE_DEFAULT);\n}\n\nint\nsshkey_putb_plain(const struct sshkey *key, struct sshbuf *b)\n{\n\treturn to_blob_buf(key, b, 1, SSHKEY_SERIALIZE_DEFAULT);\n}\n\nstatic int\nto_blob(const struct sshkey *key, u_char **blobp, size_t *lenp, int force_plain,\n    enum sshkey_serialize_rep opts)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (blobp != NULL)\n\t\t*blobp = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((ret = to_blob_buf(key, b, force_plain, opts)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tif (blobp != NULL) {\n\t\tif ((*blobp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*blobp, sshbuf_ptr(b), len);\n\t}\n\tret = 0;\n out:\n\tsshbuf_free(b);\n\treturn ret;\n}\n\nint\nsshkey_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 0, SSHKEY_SERIALIZE_DEFAULT);\n}\n\nint\nsshkey_plain_to_blob(const struct sshkey *key, u_char **blobp, size_t *lenp)\n{\n\treturn to_blob(key, blobp, lenp, 1, SSHKEY_SERIALIZE_DEFAULT);\n}\n\nint\nsshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,\n    u_char **retp, size_t *lenp)\n{\n\tu_char *blob = NULL, *ret = NULL;\n\tsize_t blob_len = 0;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (retp != NULL)\n\t\t*retp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (ssh_digest_bytes(dgst_alg) == 0) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((r = to_blob(k, &blob, &blob_len, 1, SSHKEY_SERIALIZE_DEFAULT))\n\t    != 0)\n\t\tgoto out;\n\tif ((ret = calloc(1, SSH_DIGEST_MAX_LENGTH)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = ssh_digest_memory(dgst_alg, blob, blob_len,\n\t    ret, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\t \n\tif (retp != NULL) {\n\t\t*retp = ret;\n\t\tret = NULL;\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = ssh_digest_bytes(dgst_alg);\n\tr = 0;\n out:\n\tfree(ret);\n\tif (blob != NULL)\n\t\tfreezero(blob, blob_len);\n\treturn r;\n}\n\nstatic char *\nfingerprint_b64(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *ret;\n\tsize_t plen = strlen(alg) + 1;\n\tsize_t rlen = ((dgst_raw_len + 2) / 3) * 4 + plen + 1;\n\n\tif (dgst_raw_len > 65536 || (ret = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(ret, alg, rlen);\n\tstrlcat(ret, \":\", rlen);\n\tif (dgst_raw_len == 0)\n\t\treturn ret;\n\tif (b64_ntop(dgst_raw, dgst_raw_len, ret + plen, rlen - plen) == -1) {\n\t\tfreezero(ret, rlen);\n\t\treturn NULL;\n\t}\n\t \n\tret[strcspn(ret, \"=\")] = '\\0';\n\treturn ret;\n}\n\nstatic char *\nfingerprint_hex(const char *alg, u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar *retval, hex[5];\n\tsize_t i, rlen = dgst_raw_len * 3 + strlen(alg) + 2;\n\n\tif (dgst_raw_len > 65536 || (retval = calloc(1, rlen)) == NULL)\n\t\treturn NULL;\n\tstrlcpy(retval, alg, rlen);\n\tstrlcat(retval, \":\", rlen);\n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tsnprintf(hex, sizeof(hex), \"%s%02x\",\n\t\t    i > 0 ? \":\" : \"\", dgst_raw[i]);\n\t\tstrlcat(retval, hex, rlen);\n\t}\n\treturn retval;\n}\n\nstatic char *\nfingerprint_bubblebabble(u_char *dgst_raw, size_t dgst_raw_len)\n{\n\tchar vowels[] = { 'a', 'e', 'i', 'o', 'u', 'y' };\n\tchar consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm',\n\t    'n', 'p', 'r', 's', 't', 'v', 'z', 'x' };\n\tu_int i, j = 0, rounds, seed = 1;\n\tchar *retval;\n\n\trounds = (dgst_raw_len / 2) + 1;\n\tif ((retval = calloc(rounds, 6)) == NULL)\n\t\treturn NULL;\n\tretval[j++] = 'x';\n\tfor (i = 0; i < rounds; i++) {\n\t\tu_int idx0, idx1, idx2, idx3, idx4;\n\t\tif ((i + 1 < rounds) || (dgst_raw_len % 2 != 0)) {\n\t\t\tidx0 = (((((u_int)(dgst_raw[2 * i])) >> 6) & 3) +\n\t\t\t    seed) % 6;\n\t\t\tidx1 = (((u_int)(dgst_raw[2 * i])) >> 2) & 15;\n\t\t\tidx2 = ((((u_int)(dgst_raw[2 * i])) & 3) +\n\t\t\t    (seed / 6)) % 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t\tif ((i + 1) < rounds) {\n\t\t\t\tidx3 = (((u_int)(dgst_raw[(2 * i) + 1])) >> 4) & 15;\n\t\t\t\tidx4 = (((u_int)(dgst_raw[(2 * i) + 1]))) & 15;\n\t\t\t\tretval[j++] = consonants[idx3];\n\t\t\t\tretval[j++] = '-';\n\t\t\t\tretval[j++] = consonants[idx4];\n\t\t\t\tseed = ((seed * 5) +\n\t\t\t\t    ((((u_int)(dgst_raw[2 * i])) * 7) +\n\t\t\t\t    ((u_int)(dgst_raw[(2 * i) + 1])))) % 36;\n\t\t\t}\n\t\t} else {\n\t\t\tidx0 = seed % 6;\n\t\t\tidx1 = 16;\n\t\t\tidx2 = seed / 6;\n\t\t\tretval[j++] = vowels[idx0];\n\t\t\tretval[j++] = consonants[idx1];\n\t\t\tretval[j++] = vowels[idx2];\n\t\t}\n\t}\n\tretval[j++] = 'x';\n\tretval[j++] = '\\0';\n\treturn retval;\n}\n\n \n\n \n#define\tFLDBASE\t\t8\n#define\tFLDSIZE_Y\t(FLDBASE + 1)\n#define\tFLDSIZE_X\t(FLDBASE * 2 + 1)\nstatic char *\nfingerprint_randomart(const char *alg, u_char *dgst_raw, size_t dgst_raw_len,\n    const struct sshkey *k)\n{\n\t \n\tchar\t*augmentation_string = \" .o+=*BOX@%&#/^SE\";\n\tchar\t*retval, *p, title[FLDSIZE_X], hash[FLDSIZE_X];\n\tu_char\t field[FLDSIZE_X][FLDSIZE_Y];\n\tsize_t\t i, tlen, hlen;\n\tu_int\t b;\n\tint\t x, y, r;\n\tsize_t\t len = strlen(augmentation_string) - 1;\n\n\tif ((retval = calloc((FLDSIZE_X + 3), (FLDSIZE_Y + 2))) == NULL)\n\t\treturn NULL;\n\n\t \n\tmemset(field, 0, FLDSIZE_X * FLDSIZE_Y * sizeof(char));\n\tx = FLDSIZE_X / 2;\n\ty = FLDSIZE_Y / 2;\n\n\t \n\tfor (i = 0; i < dgst_raw_len; i++) {\n\t\tint input;\n\t\t \n\t\tinput = dgst_raw[i];\n\t\tfor (b = 0; b < 4; b++) {\n\t\t\t \n\t\t\tx += (input & 0x1) ? 1 : -1;\n\t\t\ty += (input & 0x2) ? 1 : -1;\n\n\t\t\t \n\t\t\tx = MAXIMUM(x, 0);\n\t\t\ty = MAXIMUM(y, 0);\n\t\t\tx = MINIMUM(x, FLDSIZE_X - 1);\n\t\t\ty = MINIMUM(y, FLDSIZE_Y - 1);\n\n\t\t\t \n\t\t\tif (field[x][y] < len - 2)\n\t\t\t\tfield[x][y]++;\n\t\t\tinput = input >> 2;\n\t\t}\n\t}\n\n\t \n\tfield[FLDSIZE_X / 2][FLDSIZE_Y / 2] = len - 1;\n\tfield[x][y] = len;\n\n\t \n\tr = snprintf(title, sizeof(title), \"[%s %u]\",\n\t\tsshkey_type(k), sshkey_size(k));\n\t \n\tif (r < 0 || r > (int)sizeof(title))\n\t\tr = snprintf(title, sizeof(title), \"[%s]\", sshkey_type(k));\n\ttlen = (r <= 0) ? 0 : strlen(title);\n\n\t \n\tr = snprintf(hash, sizeof(hash), \"[%s]\", alg);\n\thlen = (r <= 0) ? 0 : strlen(hash);\n\n\t \n\tp = retval;\n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - tlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, title, tlen);\n\tp += tlen;\n\tfor (i += tlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\t*p++ = '\\n';\n\n\t \n\tfor (y = 0; y < FLDSIZE_Y; y++) {\n\t\t*p++ = '|';\n\t\tfor (x = 0; x < FLDSIZE_X; x++)\n\t\t\t*p++ = augmentation_string[MINIMUM(field[x][y], len)];\n\t\t*p++ = '|';\n\t\t*p++ = '\\n';\n\t}\n\n\t \n\t*p++ = '+';\n\tfor (i = 0; i < (FLDSIZE_X - hlen) / 2; i++)\n\t\t*p++ = '-';\n\tmemcpy(p, hash, hlen);\n\tp += hlen;\n\tfor (i += hlen; i < FLDSIZE_X; i++)\n\t\t*p++ = '-';\n\t*p++ = '+';\n\n\treturn retval;\n}\n\nchar *\nsshkey_fingerprint(const struct sshkey *k, int dgst_alg,\n    enum sshkey_fp_rep dgst_rep)\n{\n\tchar *retval = NULL;\n\tu_char *dgst_raw;\n\tsize_t dgst_raw_len;\n\n\tif (sshkey_fingerprint_raw(k, dgst_alg, &dgst_raw, &dgst_raw_len) != 0)\n\t\treturn NULL;\n\tswitch (dgst_rep) {\n\tcase SSH_FP_DEFAULT:\n\t\tif (dgst_alg == SSH_DIGEST_MD5) {\n\t\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t} else {\n\t\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t\t    dgst_raw, dgst_raw_len);\n\t\t}\n\t\tbreak;\n\tcase SSH_FP_HEX:\n\t\tretval = fingerprint_hex(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BASE64:\n\t\tretval = fingerprint_b64(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_BUBBLEBABBLE:\n\t\tretval = fingerprint_bubblebabble(dgst_raw, dgst_raw_len);\n\t\tbreak;\n\tcase SSH_FP_RANDOMART:\n\t\tretval = fingerprint_randomart(ssh_digest_alg_name(dgst_alg),\n\t\t    dgst_raw, dgst_raw_len, k);\n\t\tbreak;\n\tdefault:\n\t\tfreezero(dgst_raw, dgst_raw_len);\n\t\treturn NULL;\n\t}\n\tfreezero(dgst_raw, dgst_raw_len);\n\treturn retval;\n}\n\nstatic int\npeek_type_nid(const char *s, size_t l, int *nid)\n{\n\tconst struct sshkey_impl *impl;\n\tint i;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\timpl = keyimpls[i];\n\t\tif (impl->name == NULL || strlen(impl->name) != l)\n\t\t\tcontinue;\n\t\tif (memcmp(s, impl->name, l) == 0) {\n\t\t\t*nid = -1;\n\t\t\tif (key_type_is_ecdsa_variant(impl->type))\n\t\t\t\t*nid = impl->nid;\n\t\t\treturn impl->type;\n\t\t}\n\t}\n\treturn KEY_UNSPEC;\n}\n\n \nint\nsshkey_read(struct sshkey *ret, char **cpp)\n{\n\tstruct sshkey *k;\n\tchar *cp, *blobcopy;\n\tsize_t space;\n\tint r, type, curve_nid = -1;\n\tstruct sshbuf *blob;\n\n\tif (ret == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (ret->type != KEY_UNSPEC && sshkey_impl_from_type(ret->type) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t \n\tcp = *cpp;\n\tspace = strcspn(cp, \" \\t\");\n\tif (space == strlen(cp))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((type = peek_type_nid(cp, space, &curve_nid)) == KEY_UNSPEC)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\n\t \n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\tif (*cp == '\\0')\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (ret->type != KEY_UNSPEC && ret->type != type)\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\t \n\tspace = strcspn(cp, \" \\t\");\n\tif ((blobcopy = strndup(cp, space)) == NULL) {\n\t\tsshbuf_free(blob);\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((r = sshbuf_b64tod(blob, blobcopy)) != 0) {\n\t\tfree(blobcopy);\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tfree(blobcopy);\n\tif ((r = sshkey_fromb(blob, &k)) != 0) {\n\t\tsshbuf_free(blob);\n\t\treturn r;\n\t}\n\tsshbuf_free(blob);\n\n\t \n\tfor (cp += space; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t \n\tif (k->type != type) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_KEY_TYPE_MISMATCH;\n\t}\n\tif (key_type_is_ecdsa_variant(type) && curve_nid != k->ecdsa_nid) {\n\t\tsshkey_free(k);\n\t\treturn SSH_ERR_EC_CURVE_MISMATCH;\n\t}\n\n\t \n\tsshkey_free_contents(ret);\n\t*ret = *k;\n\tfreezero(k, sizeof(*k));\n\n\t \n\t*cpp = cp;\n\treturn 0;\n}\n\nint\nsshkey_to_base64(const struct sshkey *key, char **b64p)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\tchar *uu = NULL;\n\n\tif (b64p != NULL)\n\t\t*b64p = NULL;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_putb(key, b)) != 0)\n\t\tgoto out;\n\tif ((uu = sshbuf_dtob64_string(b, 0)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t \n\tif (b64p != NULL) {\n\t\t*b64p = uu;\n\t\tuu = NULL;\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tfree(uu);\n\treturn r;\n}\n\nint\nsshkey_format_text(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tchar *uu = NULL;\n\n\tif ((r = sshkey_to_base64(key, &uu)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_putf(b, \"%s %s\",\n\t    sshkey_ssh_name(key), uu)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tfree(uu);\n\treturn r;\n}\n\nint\nsshkey_write(const struct sshkey *key, FILE *f)\n{\n\tstruct sshbuf *b = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshkey_format_text(key, b)) != 0)\n\t\tgoto out;\n\tif (fwrite(sshbuf_ptr(b), sshbuf_len(b), 1, f) != 1) {\n\t\tif (feof(f))\n\t\t\terrno = EPIPE;\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\nconst char *\nsshkey_cert_type(const struct sshkey *k)\n{\n\tswitch (k->cert->type) {\n\tcase SSH2_CERT_TYPE_USER:\n\t\treturn \"user\";\n\tcase SSH2_CERT_TYPE_HOST:\n\t\treturn \"host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nint\nsshkey_check_rsa_length(const struct sshkey *k, int min_size)\n{\n#ifdef WITH_OPENSSL\n\tconst BIGNUM *rsa_n;\n\tint nbits;\n\n\tif (k == NULL || k->rsa == NULL ||\n\t    (k->type != KEY_RSA && k->type != KEY_RSA_CERT))\n\t\treturn 0;\n\tRSA_get0_key(k->rsa, &rsa_n, NULL, NULL);\n\tnbits = BN_num_bits(rsa_n);\n\tif (nbits < SSH_RSA_MINIMUM_MODULUS_SIZE ||\n\t    (min_size > 0 && nbits < min_size))\n\t\treturn SSH_ERR_KEY_LENGTH;\n#endif  \n\treturn 0;\n}\n\n#ifdef WITH_OPENSSL\n# ifdef OPENSSL_HAS_ECC\nint\nsshkey_ecdsa_key_to_nid(EC_KEY *k)\n{\n\tEC_GROUP *eg;\n\tint nids[] = {\n\t\tNID_X9_62_prime256v1,\n\t\tNID_secp384r1,\n#  ifdef OPENSSL_HAS_NISTP521\n\t\tNID_secp521r1,\n#  endif  \n\t\t-1\n\t};\n\tint nid;\n\tu_int i;\n\tconst EC_GROUP *g = EC_KEY_get0_group(k);\n\n\t \n\tif ((nid = EC_GROUP_get_curve_name(g)) > 0)\n\t\treturn nid;\n\tfor (i = 0; nids[i] != -1; i++) {\n\t\tif ((eg = EC_GROUP_new_by_curve_name(nids[i])) == NULL)\n\t\t\treturn -1;\n\t\tif (EC_GROUP_cmp(g, eg, NULL) == 0)\n\t\t\tbreak;\n\t\tEC_GROUP_free(eg);\n\t}\n\tif (nids[i] != -1) {\n\t\t \n\t\tEC_GROUP_set_asn1_flag(eg, OPENSSL_EC_NAMED_CURVE);\n\t\tif (EC_KEY_set_group(k, eg) != 1) {\n\t\t\tEC_GROUP_free(eg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn nids[i];\n}\n# endif  \n#endif  \n\nint\nsshkey_generate(int type, u_int bits, struct sshkey **keyp)\n{\n\tstruct sshkey *k;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tconst struct sshkey_impl *impl;\n\n\tif (keyp == NULL || sshkey_type_is_cert(type))\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*keyp = NULL;\n\tif ((impl = sshkey_impl_from_type(type)) == NULL)\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (impl->funcs->generate == NULL)\n\t\treturn SSH_ERR_FEATURE_UNSUPPORTED;\n\tif ((k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = type;\n\tif ((ret = impl->funcs->generate(k, bits)) != 0) {\n\t\tsshkey_free(k);\n\t\treturn ret;\n\t}\n\t \n\t*keyp = k;\n\treturn 0;\n}\n\nint\nsshkey_cert_copy(const struct sshkey *from_key, struct sshkey *to_key)\n{\n\tu_int i;\n\tconst struct sshkey_cert *from;\n\tstruct sshkey_cert *to;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (to_key == NULL || (from = from_key->cert) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif ((to = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_putb(to->certblob, from->certblob)) != 0 ||\n\t    (r = sshbuf_putb(to->critical, from->critical)) != 0 ||\n\t    (r = sshbuf_putb(to->extensions, from->extensions)) != 0)\n\t\tgoto out;\n\n\tto->serial = from->serial;\n\tto->type = from->type;\n\tif (from->key_id == NULL)\n\t\tto->key_id = NULL;\n\telse if ((to->key_id = strdup(from->key_id)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tto->valid_after = from->valid_after;\n\tto->valid_before = from->valid_before;\n\tif (from->signature_key == NULL)\n\t\tto->signature_key = NULL;\n\telse if ((r = sshkey_from_private(from->signature_key,\n\t    &to->signature_key)) != 0)\n\t\tgoto out;\n\tif (from->signature_type != NULL &&\n\t    (to->signature_type = strdup(from->signature_type)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (from->nprincipals > 0) {\n\t\tif ((to->principals = calloc(from->nprincipals,\n\t\t    sizeof(*to->principals))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < from->nprincipals; i++) {\n\t\t\tto->principals[i] = strdup(from->principals[i]);\n\t\t\tif (to->principals[i] == NULL) {\n\t\t\t\tto->nprincipals = i;\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tto->nprincipals = from->nprincipals;\n\n\t \n\tcert_free(to_key->cert);\n\tto_key->cert = to;\n\tto = NULL;\n\tr = 0;\n out:\n\tcert_free(to);\n\treturn r;\n}\n\nint\nsshkey_copy_public_sk(const struct sshkey *from, struct sshkey *to)\n{\n\t \n\tif ((to->sk_application = strdup(from->sk_application)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}\n\nint\nsshkey_from_private(const struct sshkey *k, struct sshkey **pkp)\n{\n\tstruct sshkey *n = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tconst struct sshkey_impl *impl;\n\n\t*pkp = NULL;\n\tif ((impl = sshkey_impl_from_key(k)) == NULL)\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif ((n = sshkey_new(k->type)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = impl->funcs->copy_public(k, n)) != 0)\n\t\tgoto out;\n\tif (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)\n\t\tgoto out;\n\t \n\t*pkp = n;\n\tn = NULL;\n\tr = 0;\n out:\n\tsshkey_free(n);\n\treturn r;\n}\n\nint\nsshkey_is_shielded(struct sshkey *k)\n{\n\treturn k != NULL && k->shielded_private != NULL;\n}\n\nint\nsshkey_shield_private(struct sshkey *k)\n{\n\tstruct sshbuf *prvbuf = NULL;\n\tu_char *prekey = NULL, *enc = NULL, keyiv[SSH_DIGEST_MAX_LENGTH];\n\tstruct sshcipher_ctx *cctx = NULL;\n\tconst struct sshcipher *cipher;\n\tsize_t i, enclen = 0;\n\tstruct sshkey *kswap = NULL, tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: entering for %s\\n\", __func__, sshkey_ssh_name(k));\n#endif\n\tif ((cipher = cipher_by_name(SSHKEY_SHIELD_CIPHER)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (cipher_keylen(cipher) + cipher_ivlen(cipher) >\n\t    ssh_digest_bytes(SSHKEY_SHIELD_PREKEY_HASH)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((prekey = malloc(SSHKEY_SHIELD_PREKEY_LEN)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tarc4random_buf(prekey, SSHKEY_SHIELD_PREKEY_LEN);\n\tif ((r = ssh_digest_memory(SSHKEY_SHIELD_PREKEY_HASH,\n\t    prekey, SSHKEY_SHIELD_PREKEY_LEN,\n\t    keyiv, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: key+iv\\n\", __func__);\n\tsshbuf_dump_data(keyiv, ssh_digest_bytes(SSHKEY_SHIELD_PREKEY_HASH),\n\t    stderr);\n#endif\n\tif ((r = cipher_init(&cctx, cipher, keyiv, cipher_keylen(cipher),\n\t    keyiv + cipher_keylen(cipher), cipher_ivlen(cipher), 1)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((prvbuf = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshkey_is_shielded(k) && (r = sshkey_unshield_private(k)) != 0)\n\t\tgoto out;\n\tif ((r = sshkey_private_serialize_opt(k, prvbuf,\n\t    SSHKEY_SERIALIZE_SHIELD)) != 0)\n\t\tgoto out;\n\t \n\ti = 0;\n\twhile (sshbuf_len(prvbuf) % cipher_blocksize(cipher)) {\n\t\tif ((r = sshbuf_put_u8(prvbuf, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: serialised\\n\", __func__);\n\tsshbuf_dump(prvbuf, stderr);\n#endif\n\t \n\tenclen = sshbuf_len(prvbuf);\n\tif ((enc = malloc(enclen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = cipher_crypt(cctx, 0, enc,\n\t    sshbuf_ptr(prvbuf), sshbuf_len(prvbuf), 0, 0)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: encrypted\\n\", __func__);\n\tsshbuf_dump_data(enc, enclen, stderr);\n#endif\n\n\t \n\tif ((r = sshkey_from_private(k, &kswap)) != 0)\n\t\tgoto out;\n\n\t \n\ttmp = *kswap;\n\t*kswap = *k;\n\t*k = tmp;\n\n\t \n\tk->shielded_private = enc;\n\tk->shielded_len = enclen;\n\tk->shield_prekey = prekey;\n\tk->shield_prekey_len = SSHKEY_SHIELD_PREKEY_LEN;\n\tenc = prekey = NULL;  \n\tenclen = 0;\n\n\t \n\tk->sk_flags = kswap->sk_flags;\n\n\t \n\tr = 0;\n\n out:\n\t \n\tcipher_free(cctx);\n\texplicit_bzero(keyiv, sizeof(keyiv));\n\texplicit_bzero(&tmp, sizeof(tmp));\n\tfreezero(enc, enclen);\n\tfreezero(prekey, SSHKEY_SHIELD_PREKEY_LEN);\n\tsshkey_free(kswap);\n\tsshbuf_free(prvbuf);\n\treturn r;\n}\n\n \nstatic int\nprivate2_check_padding(struct sshbuf *decrypted)\n{\n\tu_char pad;\n\tsize_t i;\n\tint r;\n\n\ti = 0;\n\twhile (sshbuf_len(decrypted)) {\n\t\tif ((r = sshbuf_get_u8(decrypted, &pad)) != 0)\n\t\t\tgoto out;\n\t\tif (pad != (++i & 0xff)) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tr = 0;\n out:\n\texplicit_bzero(&pad, sizeof(pad));\n\texplicit_bzero(&i, sizeof(i));\n\treturn r;\n}\n\nint\nsshkey_unshield_private(struct sshkey *k)\n{\n\tstruct sshbuf *prvbuf = NULL;\n\tu_char *cp, keyiv[SSH_DIGEST_MAX_LENGTH];\n\tstruct sshcipher_ctx *cctx = NULL;\n\tconst struct sshcipher *cipher;\n\tstruct sshkey *kswap = NULL, tmp;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: entering for %s\\n\", __func__, sshkey_ssh_name(k));\n#endif\n\tif (!sshkey_is_shielded(k))\n\t\treturn 0;  \n\n\tif ((cipher = cipher_by_name(SSHKEY_SHIELD_CIPHER)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (cipher_keylen(cipher) + cipher_ivlen(cipher) >\n\t    ssh_digest_bytes(SSHKEY_SHIELD_PREKEY_HASH)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tif (k->shielded_len < cipher_blocksize(cipher) ||\n\t    (k->shielded_len % cipher_blocksize(cipher)) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = ssh_digest_memory(SSHKEY_SHIELD_PREKEY_HASH,\n\t    k->shield_prekey, k->shield_prekey_len,\n\t    keyiv, SSH_DIGEST_MAX_LENGTH)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_init(&cctx, cipher, keyiv, cipher_keylen(cipher),\n\t    keyiv + cipher_keylen(cipher), cipher_ivlen(cipher), 0)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: key+iv\\n\", __func__);\n\tsshbuf_dump_data(keyiv, ssh_digest_bytes(SSHKEY_SHIELD_PREKEY_HASH),\n\t    stderr);\n#endif\n\n\t \n\tif ((prvbuf = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_reserve(prvbuf, k->shielded_len, &cp)) != 0)\n\t\tgoto out;\n\t \n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: encrypted\\n\", __func__);\n\tsshbuf_dump_data(k->shielded_private, k->shielded_len, stderr);\n#endif\n\tif ((r = cipher_crypt(cctx, 0, cp,\n\t    k->shielded_private, k->shielded_len, 0, 0)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tfprintf(stderr, \"%s: serialised\\n\", __func__);\n\tsshbuf_dump(prvbuf, stderr);\n#endif\n\t \n\tif ((r = sshkey_private_deserialize(prvbuf, &kswap)) != 0)\n\t\tgoto out;\n\n\tif ((r = private2_check_padding(prvbuf)) != 0)\n\t\tgoto out;\n\n\t \n\ttmp = *kswap;\n\t*kswap = *k;\n\t*k = tmp;\n\n\t \n\tr = 0;\n\n out:\n\tcipher_free(cctx);\n\texplicit_bzero(keyiv, sizeof(keyiv));\n\texplicit_bzero(&tmp, sizeof(tmp));\n\tsshkey_free(kswap);\n\tsshbuf_free(prvbuf);\n\treturn r;\n}\n\nstatic int\ncert_parse(struct sshbuf *b, struct sshkey *key, struct sshbuf *certbuf)\n{\n\tstruct sshbuf *principals = NULL, *crit = NULL;\n\tstruct sshbuf *exts = NULL, *ca = NULL;\n\tu_char *sig = NULL;\n\tsize_t signed_len = 0, slen = 0, kidlen = 0;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif ((ret = sshbuf_putb(key->cert->certblob, certbuf)) != 0)\n\t\treturn ret;\n\n\t \n\tif ((ret = sshbuf_get_u64(b, &key->cert->serial)) != 0 ||\n\t    (ret = sshbuf_get_u32(b, &key->cert->type)) != 0 ||\n\t    (ret = sshbuf_get_cstring(b, &key->cert->key_id, &kidlen)) != 0 ||\n\t    (ret = sshbuf_froms(b, &principals)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_get_u64(b, &key->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_froms(b, &crit)) != 0 ||\n\t    (ret = sshbuf_froms(b, &exts)) != 0 ||\n\t    (ret = sshbuf_get_string_direct(b, NULL, NULL)) != 0 ||\n\t    (ret = sshbuf_froms(b, &ca)) != 0) {\n\t\t \n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tsigned_len = sshbuf_len(key->cert->certblob) - sshbuf_len(b);\n\n\tif ((ret = sshbuf_get_string(b, &sig, &slen)) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\tif (key->cert->type != SSH2_CERT_TYPE_USER &&\n\t    key->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\tret = SSH_ERR_KEY_CERT_UNKNOWN_TYPE;\n\t\tgoto out;\n\t}\n\n\t \n\twhile (sshbuf_len(principals) > 0) {\n\t\tchar *principal = NULL;\n\t\tchar **oprincipals = NULL;\n\n\t\tif (key->cert->nprincipals >= SSHKEY_CERT_MAX_PRINCIPALS) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ret = sshbuf_get_cstring(principals, &principal,\n\t\t    NULL)) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\toprincipals = key->cert->principals;\n\t\tkey->cert->principals = recallocarray(key->cert->principals,\n\t\t    key->cert->nprincipals, key->cert->nprincipals + 1,\n\t\t    sizeof(*key->cert->principals));\n\t\tif (key->cert->principals == NULL) {\n\t\t\tfree(principal);\n\t\t\tkey->cert->principals = oprincipals;\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->cert->principals[key->cert->nprincipals++] = principal;\n\t}\n\n\t \n\tif ((ret = sshbuf_putb(key->cert->critical, crit)) != 0 ||\n\t    (exts != NULL &&\n\t    (ret = sshbuf_putb(key->cert->extensions, exts)) != 0))\n\t\tgoto out;\n\n\t \n\twhile (sshbuf_len(crit) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(crit, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->critical);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\twhile (exts != NULL && sshbuf_len(exts) != 0) {\n\t\tif ((ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0 ||\n\t\t    (ret = sshbuf_get_string_direct(exts, NULL, NULL)) != 0) {\n\t\t\tsshbuf_reset(key->cert->extensions);\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (sshkey_from_blob_internal(ca, &key->cert->signature_key, 0) != 0) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif (!sshkey_type_is_valid_ca(key->cert->signature_key->type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif ((ret = sshkey_verify(key->cert->signature_key, sig, slen,\n\t    sshbuf_ptr(key->cert->certblob), signed_len, NULL, 0, NULL)) != 0)\n\t\tgoto out;\n\tif ((ret = sshkey_get_sigtype(sig, slen,\n\t    &key->cert->signature_type)) != 0)\n\t\tgoto out;\n\n\t \n\tret = 0;\n out:\n\tsshbuf_free(ca);\n\tsshbuf_free(crit);\n\tsshbuf_free(exts);\n\tsshbuf_free(principals);\n\tfree(sig);\n\treturn ret;\n}\n\nint\nsshkey_deserialize_sk(struct sshbuf *b, struct sshkey *key)\n{\n\t \n\tif (sshbuf_get_cstring(b, &key->sk_application, NULL) != 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn 0;\n}\n\nstatic int\nsshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,\n    int allow_cert)\n{\n\tint type, ret = SSH_ERR_INTERNAL_ERROR;\n\tchar *ktype = NULL;\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *copy;\n\tconst struct sshkey_impl *impl;\n\n#ifdef DEBUG_PK  \n\tsshbuf_dump(b, stderr);\n#endif\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif ((copy = sshbuf_fromb(b)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\ttype = sshkey_type_from_name(ktype);\n\tif (!allow_cert && sshkey_type_is_cert(type)) {\n\t\tret = SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\t\tgoto out;\n\t}\n\tif ((impl = sshkey_impl_from_type(type)) == NULL) {\n\t\tret = SSH_ERR_KEY_TYPE_UNKNOWN;\n\t\tgoto out;\n\t}\n\tif ((key = sshkey_new(type)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshkey_type_is_cert(type)) {\n\t\t \n\t\tif (sshbuf_get_string_direct(b, NULL, NULL) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((ret = impl->funcs->deserialize_public(ktype, b, key)) != 0)\n\t\tgoto out;\n\n\t \n\tif (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)\n\t\tgoto out;\n\n\tif (key != NULL && sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshbuf_free(copy);\n\tsshkey_free(key);\n\tfree(ktype);\n\treturn ret;\n}\n\nint\nsshkey_from_blob(const u_char *blob, size_t blen, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_from(blob, blen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nint\nsshkey_fromb(struct sshbuf *b, struct sshkey **keyp)\n{\n\treturn sshkey_from_blob_internal(b, keyp, 1);\n}\n\nint\nsshkey_froms(struct sshbuf *buf, struct sshkey **keyp)\n{\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((r = sshbuf_froms(buf, &b)) != 0)\n\t\treturn r;\n\tr = sshkey_from_blob_internal(b, keyp, 1);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nint\nsshkey_get_sigtype(const u_char *sig, size_t siglen, char **sigtypep)\n{\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tchar *sigtype = NULL;\n\n\tif (sigtypep != NULL)\n\t\t*sigtypep = NULL;\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(b, &sigtype, NULL)) != 0)\n\t\tgoto out;\n\t \n\tif (sigtypep != NULL) {\n\t\t*sigtypep = sigtype;\n\t\tsigtype = NULL;\n\t}\n\tr = 0;\n out:\n\tfree(sigtype);\n\tsshbuf_free(b);\n\treturn r;\n}\n\n \nint\nsshkey_check_cert_sigtype(const struct sshkey *key, const char *allowed)\n{\n\tif (key == NULL || allowed == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_type_is_cert(key->type))\n\t\treturn 0;\n\tif (key->cert == NULL || key->cert->signature_type == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (match_pattern_list(key->cert->signature_type, allowed, 0) != 1)\n\t\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\treturn 0;\n}\n\n \nconst char *\nsshkey_sigalg_by_name(const char *name)\n{\n\tconst struct sshkey_impl *impl;\n\tint i;\n\n\tfor (i = 0; keyimpls[i] != NULL; i++) {\n\t\timpl = keyimpls[i];\n\t\tif (strcmp(impl->name, name) != 0)\n\t\t\tcontinue;\n\t\tif (impl->sigalg != NULL)\n\t\t\treturn impl->sigalg;\n\t\tif (!impl->cert)\n\t\t\treturn impl->name;\n\t\treturn sshkey_ssh_name_from_type_nid(\n\t\t    sshkey_type_plain(impl->type), impl->nid);\n\t}\n\treturn NULL;\n}\n\n \nint\nsshkey_check_sigtype(const u_char *sig, size_t siglen,\n    const char *requested_alg)\n{\n\tconst char *expected_alg;\n\tchar *sigtype = NULL;\n\tint r;\n\n\tif (requested_alg == NULL)\n\t\treturn 0;\n\tif ((expected_alg = sshkey_sigalg_by_name(requested_alg)) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = sshkey_get_sigtype(sig, siglen, &sigtype)) != 0)\n\t\treturn r;\n\tr = strcmp(expected_alg, sigtype) == 0;\n\tfree(sigtype);\n\treturn r ? 0 : SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}\n\nint\nsshkey_sign(struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\tint was_shielded = sshkey_is_shielded(key);\n\tint r2, r = SSH_ERR_INTERNAL_ERROR;\n\tconst struct sshkey_impl *impl;\n\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (datalen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((impl = sshkey_impl_from_key(key)) == NULL)\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif ((r = sshkey_unshield_private(key)) != 0)\n\t\treturn r;\n\tif (sshkey_is_sk(key)) {\n\t\tr = sshsk_sign(sk_provider, key, sigp, lenp, data,\n\t\t    datalen, compat, sk_pin);\n\t} else {\n\t\tif (impl->funcs->sign == NULL)\n\t\t\tr = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\telse {\n\t\t\tr = impl->funcs->sign(key, sigp, lenp, data, datalen,\n\t\t\t    alg, sk_provider, sk_pin, compat);\n\t\t }\n\t}\n\tif (was_shielded && (r2 = sshkey_shield_private(key)) != 0)\n\t\treturn r2;\n\treturn r;\n}\n\n \nint\nsshkey_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\tconst struct sshkey_impl *impl;\n\n\tif (detailsp != NULL)\n\t\t*detailsp = NULL;\n\tif (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((impl = sshkey_impl_from_key(key)) == NULL)\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\treturn impl->funcs->verify(key, sig, siglen, data, dlen,\n\t    alg, compat, detailsp);\n}\n\n \nint\nsshkey_to_certified(struct sshkey *k)\n{\n\tint newtype;\n\n\tif ((newtype = sshkey_type_certified(k->type)) == -1)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((k->cert = cert_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tk->type = newtype;\n\treturn 0;\n}\n\n \nint\nsshkey_drop_cert(struct sshkey *k)\n{\n\tif (!sshkey_type_is_cert(k->type))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tcert_free(k->cert);\n\tk->cert = NULL;\n\tk->type = sshkey_type_plain(k->type);\n\treturn 0;\n}\n\n \nint\nsshkey_certify_custom(struct sshkey *k, struct sshkey *ca, const char *alg,\n    const char *sk_provider, const char *sk_pin,\n    sshkey_certify_signer *signer, void *signer_ctx)\n{\n\tconst struct sshkey_impl *impl;\n\tstruct sshbuf *principals = NULL;\n\tu_char *ca_blob = NULL, *sig_blob = NULL, nonce[32];\n\tsize_t i, ca_len, sig_len;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *cert = NULL;\n\tchar *sigtype = NULL;\n\n\tif (k == NULL || k->cert == NULL ||\n\t    k->cert->certblob == NULL || ca == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k))\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\tif (!sshkey_type_is_valid_ca(ca->type))\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\tif ((impl = sshkey_impl_from_key(k)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif (alg == NULL)\n\t\talg = k->cert->signature_type;\n\telse if (k->cert->signature_type != NULL &&\n\t    strcmp(alg, k->cert->signature_type) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t \n\tif (alg == NULL && ca->type == KEY_RSA)\n\t\talg = \"rsa-sha2-512\";\n\n\tif ((ret = sshkey_to_blob(ca, &ca_blob, &ca_len)) != 0)\n\t\treturn SSH_ERR_KEY_CERT_INVALID_SIGN_KEY;\n\n\tcert = k->cert->certblob;  \n\tsshbuf_reset(cert);\n\tif ((ret = sshbuf_put_cstring(cert, sshkey_ssh_name(k))) != 0)\n\t\tgoto out;\n\n\t \n\tarc4random_buf(&nonce, sizeof(nonce));\n\tif ((ret = sshbuf_put_string(cert, nonce, sizeof(nonce))) != 0)\n\t\tgoto out;\n\n\t \n\tif ((ret = impl->funcs->serialize_public(k, cert,\n\t    SSHKEY_SERIALIZE_DEFAULT)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((ret = sshbuf_put_u64(cert, k->cert->serial)) != 0 ||\n\t    (ret = sshbuf_put_u32(cert, k->cert->type)) != 0 ||\n\t    (ret = sshbuf_put_cstring(cert, k->cert->key_id)) != 0)\n\t\tgoto out;\n\n\tif ((principals = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\tif ((ret = sshbuf_put_cstring(principals,\n\t\t    k->cert->principals[i])) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_stringb(cert, principals)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_after)) != 0 ||\n\t    (ret = sshbuf_put_u64(cert, k->cert->valid_before)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->critical)) != 0 ||\n\t    (ret = sshbuf_put_stringb(cert, k->cert->extensions)) != 0 ||\n\t    (ret = sshbuf_put_string(cert, NULL, 0)) != 0 ||  \n\t    (ret = sshbuf_put_string(cert, ca_blob, ca_len)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((ret = signer(ca, &sig_blob, &sig_len, sshbuf_ptr(cert),\n\t    sshbuf_len(cert), alg, sk_provider, sk_pin, 0, signer_ctx)) != 0)\n\t\tgoto out;\n\t \n\tif ((ret = sshkey_get_sigtype(sig_blob, sig_len, &sigtype)) != 0)\n\t\tgoto out;\n\tif (alg != NULL && strcmp(alg, sigtype) != 0) {\n\t\tret = SSH_ERR_SIGN_ALG_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (k->cert->signature_type == NULL) {\n\t\tk->cert->signature_type = sigtype;\n\t\tsigtype = NULL;\n\t}\n\t \n\tif ((ret = sshbuf_put_string(cert, sig_blob, sig_len)) != 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tif (ret != 0)\n\t\tsshbuf_reset(cert);\n\tfree(sig_blob);\n\tfree(ca_blob);\n\tfree(sigtype);\n\tsshbuf_free(principals);\n\treturn ret;\n}\n\nstatic int\ndefault_key_sign(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, const char *sk_provider, const char *sk_pin,\n    u_int compat, void *ctx)\n{\n\tif (ctx != NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn sshkey_sign(key, sigp, lenp, data, datalen, alg,\n\t    sk_provider, sk_pin, compat);\n}\n\nint\nsshkey_certify(struct sshkey *k, struct sshkey *ca, const char *alg,\n    const char *sk_provider, const char *sk_pin)\n{\n\treturn sshkey_certify_custom(k, ca, alg, sk_provider, sk_pin,\n\t    default_key_sign, NULL);\n}\n\nint\nsshkey_cert_check_authority(const struct sshkey *k,\n    int want_host, int require_principal, int wildcard_pattern,\n    uint64_t verify_time, const char *name, const char **reason)\n{\n\tu_int i, principal_matches;\n\n\tif (reason == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (!sshkey_is_cert(k)) {\n\t\t*reason = \"Key is not a certificate\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (want_host) {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_HOST) {\n\t\t\t*reason = \"Certificate invalid: not a host certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else {\n\t\tif (k->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\t*reason = \"Certificate invalid: not a user certificate\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\tif (verify_time < k->cert->valid_after) {\n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (verify_time >= k->cert->valid_before) {\n\t\t*reason = \"Certificate invalid: expired\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (k->cert->nprincipals == 0) {\n\t\tif (require_principal) {\n\t\t\t*reason = \"Certificate lacks principal list\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t} else if (name != NULL) {\n\t\tprincipal_matches = 0;\n\t\tfor (i = 0; i < k->cert->nprincipals; i++) {\n\t\t\tif (wildcard_pattern) {\n\t\t\t\tif (match_pattern(k->cert->principals[i],\n\t\t\t\t    name)) {\n\t\t\t\t\tprincipal_matches = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (strcmp(name, k->cert->principals[i]) == 0) {\n\t\t\t\tprincipal_matches = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!principal_matches) {\n\t\t\t*reason = \"Certificate invalid: name is not a listed \"\n\t\t\t    \"principal\";\n\t\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nsshkey_cert_check_authority_now(const struct sshkey *k,\n    int want_host, int require_principal, int wildcard_pattern,\n    const char *name, const char **reason)\n{\n\ttime_t now;\n\n\tif ((now = time(NULL)) < 0) {\n\t\t \n\t\t*reason = \"Certificate invalid: not yet valid\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\treturn sshkey_cert_check_authority(k, want_host, require_principal,\n\t    wildcard_pattern, (uint64_t)now, name, reason);\n}\n\nint\nsshkey_cert_check_host(const struct sshkey *key, const char *host,\n    int wildcard_principals, const char *ca_sign_algorithms,\n    const char **reason)\n{\n\tint r;\n\n\tif ((r = sshkey_cert_check_authority_now(key, 1, 0, wildcard_principals,\n\t    host, reason)) != 0)\n\t\treturn r;\n\tif (sshbuf_len(key->cert->critical) != 0) {\n\t\t*reason = \"Certificate contains unsupported critical options\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\tif (ca_sign_algorithms != NULL &&\n\t    (r = sshkey_check_cert_sigtype(key, ca_sign_algorithms)) != 0) {\n\t\t*reason = \"Certificate signed with disallowed algorithm\";\n\t\treturn SSH_ERR_KEY_CERT_INVALID;\n\t}\n\treturn 0;\n}\n\nsize_t\nsshkey_format_cert_validity(const struct sshkey_cert *cert, char *s, size_t l)\n{\n\tchar from[32], to[32], ret[128];\n\n\t*from = *to = '\\0';\n\tif (cert->valid_after == 0 &&\n\t    cert->valid_before == 0xffffffffffffffffULL)\n\t\treturn strlcpy(s, \"forever\", l);\n\n\tif (cert->valid_after != 0)\n\t\tformat_absolute_time(cert->valid_after, from, sizeof(from));\n\tif (cert->valid_before != 0xffffffffffffffffULL)\n\t\tformat_absolute_time(cert->valid_before, to, sizeof(to));\n\n\tif (cert->valid_after == 0)\n\t\tsnprintf(ret, sizeof(ret), \"before %s\", to);\n\telse if (cert->valid_before == 0xffffffffffffffffULL)\n\t\tsnprintf(ret, sizeof(ret), \"after %s\", from);\n\telse\n\t\tsnprintf(ret, sizeof(ret), \"from %s to %s\", from, to);\n\n\treturn strlcpy(s, ret, l);\n}\n\n \nint\nsshkey_serialize_private_sk(const struct sshkey *key, struct sshbuf *b)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_cstring(b, key->sk_application)) != 0 ||\n\t    (r = sshbuf_put_u8(b, key->sk_flags)) != 0 ||\n\t    (r = sshbuf_put_stringb(b, key->sk_key_handle)) != 0 ||\n\t    (r = sshbuf_put_stringb(b, key->sk_reserved)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint\nsshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,\n    enum sshkey_serialize_rep opts)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint was_shielded = sshkey_is_shielded(key);\n\tstruct sshbuf *b = NULL;\n\tconst struct sshkey_impl *impl;\n\n\tif ((impl = sshkey_impl_from_key(key)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((r = sshkey_unshield_private(key)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)\n\t\tgoto out;\n\tif (sshkey_is_cert(key)) {\n\t\tif (key->cert == NULL ||\n\t\t    sshbuf_len(key->cert->certblob) == 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = impl->funcs->serialize_private(key, b, opts)) != 0)\n\t\tgoto out;\n\n\t \n\tr = 0;\n out:\n\tif (was_shielded)\n\t\tr = sshkey_shield_private(key);\n\tif (r == 0)\n\t\tr = sshbuf_putb(buf, b);\n\tsshbuf_free(b);\n\n\treturn r;\n}\n\nint\nsshkey_private_serialize(struct sshkey *key, struct sshbuf *b)\n{\n\treturn sshkey_private_serialize_opt(key, b,\n\t    SSHKEY_SERIALIZE_DEFAULT);\n}\n\n \nint\nsshkey_private_deserialize_sk(struct sshbuf *buf, struct sshkey *k)\n{\n\tint r;\n\n\tif ((k->sk_key_handle = sshbuf_new()) == NULL ||\n\t    (k->sk_reserved = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_cstring(buf, &k->sk_application, NULL)) != 0 ||\n\t    (r = sshbuf_get_u8(buf, &k->sk_flags)) != 0 ||\n\t    (r = sshbuf_get_stringb(buf, k->sk_key_handle)) != 0 ||\n\t    (r = sshbuf_get_stringb(buf, k->sk_reserved)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint\nsshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)\n{\n\tconst struct sshkey_impl *impl;\n\tchar *tname = NULL;\n\tchar *expect_sk_application = NULL;\n\tu_char *expect_ed25519_pk = NULL;\n\tstruct sshkey *k = NULL;\n\tint type, r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (kp != NULL)\n\t\t*kp = NULL;\n\tif ((r = sshbuf_get_cstring(buf, &tname, NULL)) != 0)\n\t\tgoto out;\n\ttype = sshkey_type_from_name(tname);\n\tif (sshkey_type_is_cert(type)) {\n\t\t \n\t\tif ((r = sshkey_froms(buf, &k)) != 0)\n\t\t\tgoto out;\n\t\tif (k->type != type) {\n\t\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (k->type == KEY_ECDSA &&\n\t\t    k->ecdsa_nid != sshkey_ecdsa_nid_from_name(tname)) {\n\t\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\texpect_sk_application = k->sk_application;\n\t\texpect_ed25519_pk = k->ed25519_pk;\n\t\tk->sk_application = NULL;\n\t\tk->ed25519_pk = NULL;\n\t\t \n\t} else {\n\t\tif ((k = sshkey_new(type)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((impl = sshkey_impl_from_type(type)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = impl->funcs->deserialize_private(tname, buf, k)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((expect_sk_application != NULL && (k->sk_application == NULL ||\n\t    strcmp(expect_sk_application, k->sk_application) != 0)) ||\n\t    (expect_ed25519_pk != NULL && (k->ed25519_pk == NULL ||\n\t    memcmp(expect_ed25519_pk, k->ed25519_pk, ED25519_PK_SZ) != 0))) {\n\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n\tif (kp != NULL) {\n\t\t*kp = k;\n\t\tk = NULL;\n\t}\n out:\n\tfree(tname);\n\tsshkey_free(k);\n\tfree(expect_sk_application);\n\tfree(expect_ed25519_pk);\n\treturn r;\n}\n\n#if defined(WITH_OPENSSL) && defined(OPENSSL_HAS_ECC)\nint\nsshkey_ec_validate_public(const EC_GROUP *group, const EC_POINT *public)\n{\n\tEC_POINT *nq = NULL;\n\tBIGNUM *order = NULL, *x = NULL, *y = NULL, *tmp = NULL;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\t \n\n\t \n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field)\n\t\tgoto out;\n\n\t \n\tif (EC_POINT_is_at_infinity(group, public))\n\t\tgoto out;\n\n\tif ((x = BN_new()) == NULL ||\n\t    (y = BN_new()) == NULL ||\n\t    (order = BN_new()) == NULL ||\n\t    (tmp = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (EC_GROUP_get_order(group, order, NULL) != 1 ||\n\t    EC_POINT_get_affine_coordinates_GFp(group, public,\n\t    x, y, NULL) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(x) <= BN_num_bits(order) / 2 ||\n\t    BN_num_bits(y) <= BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t \n\tif ((nq = EC_POINT_new(group)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_mul(group, nq, NULL, public, order, NULL) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (EC_POINT_is_at_infinity(group, nq) != 1)\n\t\tgoto out;\n\n\t \n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(x, tmp) >= 0 || BN_cmp(y, tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_clear_free(x);\n\tBN_clear_free(y);\n\tBN_clear_free(order);\n\tBN_clear_free(tmp);\n\tEC_POINT_free(nq);\n\treturn ret;\n}\n\nint\nsshkey_ec_validate_private(const EC_KEY *key)\n{\n\tBIGNUM *order = NULL, *tmp = NULL;\n\tint ret = SSH_ERR_KEY_INVALID_EC_VALUE;\n\n\tif ((order = BN_new()) == NULL || (tmp = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (EC_GROUP_get_order(EC_KEY_get0_group(key), order, NULL) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_num_bits(EC_KEY_get0_private_key(key)) <=\n\t    BN_num_bits(order) / 2)\n\t\tgoto out;\n\n\t \n\tif (!BN_sub(tmp, order, BN_value_one())) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (BN_cmp(EC_KEY_get0_private_key(key), tmp) >= 0)\n\t\tgoto out;\n\tret = 0;\n out:\n\tBN_clear_free(order);\n\tBN_clear_free(tmp);\n\treturn ret;\n}\n\nvoid\nsshkey_dump_ec_point(const EC_GROUP *group, const EC_POINT *point)\n{\n\tBIGNUM *x = NULL, *y = NULL;\n\n\tif (point == NULL) {\n\t\tfputs(\"point=(NULL)\\n\", stderr);\n\t\treturn;\n\t}\n\tif ((x = BN_new()) == NULL || (y = BN_new()) == NULL) {\n\t\tfprintf(stderr, \"%s: BN_new failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n\t    NID_X9_62_prime_field) {\n\t\tfprintf(stderr, \"%s: group is not a prime field\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (EC_POINT_get_affine_coordinates_GFp(group, point,\n\t    x, y, NULL) != 1) {\n\t\tfprintf(stderr, \"%s: EC_POINT_get_affine_coordinates_GFp\\n\",\n\t\t    __func__);\n\t\tgoto out;\n\t}\n\tfputs(\"x=\", stderr);\n\tBN_print_fp(stderr, x);\n\tfputs(\"\\ny=\", stderr);\n\tBN_print_fp(stderr, y);\n\tfputs(\"\\n\", stderr);\n out:\n\tBN_clear_free(x);\n\tBN_clear_free(y);\n}\n\nvoid\nsshkey_dump_ec_key(const EC_KEY *key)\n{\n\tconst BIGNUM *exponent;\n\n\tsshkey_dump_ec_point(EC_KEY_get0_group(key),\n\t    EC_KEY_get0_public_key(key));\n\tfputs(\"exponent=\", stderr);\n\tif ((exponent = EC_KEY_get0_private_key(key)) == NULL)\n\t\tfputs(\"(NULL)\", stderr);\n\telse\n\t\tBN_print_fp(stderr, EC_KEY_get0_private_key(key));\n\tfputs(\"\\n\", stderr);\n}\n#endif  \n\nstatic int\nsshkey_private_to_blob2(struct sshkey *prv, struct sshbuf *blob,\n    const char *passphrase, const char *comment, const char *ciphername,\n    int rounds)\n{\n\tu_char *cp, *key = NULL, *pubkeyblob = NULL;\n\tu_char salt[SALT_LEN];\n\tsize_t i, pubkeylen, keylen, ivlen, blocksize, authlen;\n\tu_int check;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tconst struct sshcipher *cipher;\n\tconst char *kdfname = KDFNAME;\n\tstruct sshbuf *encoded = NULL, *encrypted = NULL, *kdf = NULL;\n\n\tif (rounds <= 0)\n\t\trounds = DEFAULT_ROUNDS;\n\tif (passphrase == NULL || !strlen(passphrase)) {\n\t\tciphername = \"none\";\n\t\tkdfname = \"none\";\n\t} else if (ciphername == NULL)\n\t\tciphername = DEFAULT_CIPHERNAME;\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\n\tif ((kdf = sshbuf_new()) == NULL ||\n\t    (encoded = sshbuf_new()) == NULL ||\n\t    (encrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tblocksize = cipher_blocksize(cipher);\n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tarc4random_buf(salt, SALT_LEN);\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase),\n\t\t    salt, SALT_LEN, key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put_string(kdf, salt, SALT_LEN)) != 0 ||\n\t\t    (r = sshbuf_put_u32(kdf, rounds)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(kdfname, \"none\") != 0) {\n\t\t \n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif ((r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 1)) != 0)\n\t\tgoto out;\n\n\tif ((r = sshbuf_put(encoded, AUTH_MAGIC, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, ciphername)) != 0 ||\n\t    (r = sshbuf_put_cstring(encoded, kdfname)) != 0 ||\n\t    (r = sshbuf_put_stringb(encoded, kdf)) != 0 ||\n\t    (r = sshbuf_put_u32(encoded, 1)) != 0 ||\t \n\t    (r = sshkey_to_blob(prv, &pubkeyblob, &pubkeylen)) != 0 ||\n\t    (r = sshbuf_put_string(encoded, pubkeyblob, pubkeylen)) != 0)\n\t\tgoto out;\n\n\t \n\n\t \n\tcheck = arc4random();\n\tif ((r = sshbuf_put_u32(encrypted, check)) != 0 ||\n\t    (r = sshbuf_put_u32(encrypted, check)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshkey_private_serialize_opt(prv, encrypted,\n\t    SSHKEY_SERIALIZE_FULL)) != 0 ||\n\t    (r = sshbuf_put_cstring(encrypted, comment)) != 0)\n\t\tgoto out;\n\n\t \n\ti = 0;\n\twhile (sshbuf_len(encrypted) % blocksize) {\n\t\tif ((r = sshbuf_put_u8(encrypted, ++i & 0xff)) != 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_put_u32(encoded, sshbuf_len(encrypted))) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshbuf_reserve(encoded,\n\t    sshbuf_len(encrypted) + authlen, &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, cp,\n\t    sshbuf_ptr(encrypted), sshbuf_len(encrypted), 0, authlen)) != 0)\n\t\tgoto out;\n\n\tsshbuf_reset(blob);\n\n\t \n\tif ((r = sshbuf_put(blob, MARK_BEGIN, MARK_BEGIN_LEN)) != 0 ||\n\t    (r = sshbuf_dtob64(encoded, blob, 1)) != 0 ||\n\t    (r = sshbuf_put(blob, MARK_END, MARK_END_LEN)) != 0)\n\t\tgoto out;\n\n\t \n\tr = 0;\n\n out:\n\tsshbuf_free(kdf);\n\tsshbuf_free(encoded);\n\tsshbuf_free(encrypted);\n\tcipher_free(ciphercontext);\n\texplicit_bzero(salt, sizeof(salt));\n\tif (key != NULL)\n\t\tfreezero(key, keylen + ivlen);\n\tif (pubkeyblob != NULL)\n\t\tfreezero(pubkeyblob, pubkeylen);\n\treturn r;\n}\n\nstatic int\nprivate2_uudecode(struct sshbuf *blob, struct sshbuf **decodedp)\n{\n\tconst u_char *cp;\n\tsize_t encoded_len;\n\tint r;\n\tu_char last;\n\tstruct sshbuf *encoded = NULL, *decoded = NULL;\n\n\tif (blob == NULL || decodedp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t*decodedp = NULL;\n\n\tif ((encoded = sshbuf_new()) == NULL ||\n\t    (decoded = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tcp = sshbuf_ptr(blob);\n\tencoded_len = sshbuf_len(blob);\n\tif (encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||\n\t    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tcp += MARK_BEGIN_LEN;\n\tencoded_len -= MARK_BEGIN_LEN;\n\n\t \n\twhile (encoded_len > 0) {\n\t\tif (*cp != '\\n' && *cp != '\\r') {\n\t\t\tif ((r = sshbuf_put_u8(encoded, *cp)) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tlast = *cp;\n\t\tencoded_len--;\n\t\tcp++;\n\t\tif (last == '\\n') {\n\t\t\tif (encoded_len >= MARK_END_LEN &&\n\t\t\t    memcmp(cp, MARK_END, MARK_END_LEN) == 0) {\n\t\t\t\t \n\t\t\t\tif ((r = sshbuf_put_u8(encoded, 0)) != 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (encoded_len == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_b64tod(decoded, (char *)sshbuf_ptr(encoded))) != 0)\n\t\tgoto out;\n\n\t \n\tif (sshbuf_len(decoded) < sizeof(AUTH_MAGIC) ||\n\t    memcmp(sshbuf_ptr(decoded), AUTH_MAGIC, sizeof(AUTH_MAGIC))) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\t*decodedp = decoded;\n\tdecoded = NULL;\n\tr = 0;\n out:\n\tsshbuf_free(encoded);\n\tsshbuf_free(decoded);\n\treturn r;\n}\n\nstatic int\nprivate2_decrypt(struct sshbuf *decoded, const char *passphrase,\n    struct sshbuf **decryptedp, struct sshkey **pubkeyp)\n{\n\tchar *ciphername = NULL, *kdfname = NULL;\n\tconst struct sshcipher *cipher = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tsize_t keylen = 0, ivlen = 0, authlen = 0, slen = 0;\n\tstruct sshbuf *kdf = NULL, *decrypted = NULL;\n\tstruct sshcipher_ctx *ciphercontext = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tu_char *key = NULL, *salt = NULL, *dp;\n\tu_int blocksize, rounds, nkeys, encrypted_len, check1, check2;\n\n\tif (decoded == NULL || decryptedp == NULL || pubkeyp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t*decryptedp = NULL;\n\t*pubkeyp = NULL;\n\n\tif ((decrypted = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_consume(decoded, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &ciphername, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(decoded, &kdfname, NULL)) != 0 ||\n\t    (r = sshbuf_froms(decoded, &kdf)) != 0 ||\n\t    (r = sshbuf_get_u32(decoded, &nkeys)) != 0)\n\t\tgoto out;\n\n\tif (nkeys != 1) {\n\t\t \n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_froms(decoded, &pubkey)) != 0 ||\n\t    (r = sshbuf_get_u32(decoded, &encrypted_len)) != 0)\n\t\tgoto out;\n\n\tif ((cipher = cipher_by_name(ciphername)) == NULL) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"none\") != 0 && strcmp(kdfname, \"bcrypt\") != 0) {\n\t\tr = SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"none\") == 0 && strcmp(ciphername, \"none\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((passphrase == NULL || strlen(passphrase) == 0) &&\n\t    strcmp(kdfname, \"none\") != 0) {\n\t\t \n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\n\t \n\tblocksize = cipher_blocksize(cipher);\n\tif (encrypted_len < blocksize || (encrypted_len % blocksize) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tkeylen = cipher_keylen(cipher);\n\tivlen = cipher_ivlen(cipher);\n\tauthlen = cipher_authlen(cipher);\n\tif ((key = calloc(1, keylen + ivlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (strcmp(kdfname, \"bcrypt\") == 0) {\n\t\tif ((r = sshbuf_get_string(kdf, &salt, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_u32(kdf, &rounds)) != 0)\n\t\t\tgoto out;\n\t\tif (bcrypt_pbkdf(passphrase, strlen(passphrase), salt, slen,\n\t\t    key, keylen + ivlen, rounds) < 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (sshbuf_len(decoded) < authlen ||\n\t    sshbuf_len(decoded) - authlen < encrypted_len) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_reserve(decrypted, encrypted_len, &dp)) != 0 ||\n\t    (r = cipher_init(&ciphercontext, cipher, key, keylen,\n\t    key + keylen, ivlen, 0)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(ciphercontext, 0, dp, sshbuf_ptr(decoded),\n\t    encrypted_len, 0, authlen)) != 0) {\n\t\t \n\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_consume(decoded, encrypted_len + authlen)) != 0)\n\t\tgoto out;\n\t \n\tif (sshbuf_len(decoded) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshbuf_get_u32(decrypted, &check1)) != 0 ||\n\t    (r = sshbuf_get_u32(decrypted, &check2)) != 0)\n\t\tgoto out;\n\tif (check1 != check2) {\n\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tgoto out;\n\t}\n\t \n\t*decryptedp = decrypted;\n\tdecrypted = NULL;\n\t*pubkeyp = pubkey;\n\tpubkey = NULL;\n\tr = 0;\n out:\n\tcipher_free(ciphercontext);\n\tfree(ciphername);\n\tfree(kdfname);\n\tsshkey_free(pubkey);\n\tif (salt != NULL) {\n\t\texplicit_bzero(salt, slen);\n\t\tfree(salt);\n\t}\n\tif (key != NULL) {\n\t\texplicit_bzero(key, keylen + ivlen);\n\t\tfree(key);\n\t}\n\tsshbuf_free(kdf);\n\tsshbuf_free(decrypted);\n\treturn r;\n}\n\nstatic int\nsshkey_parse_private2(struct sshbuf *blob, int type, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tchar *comment = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *decoded = NULL, *decrypted = NULL;\n\tstruct sshkey *k = NULL, *pubkey = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\t \n\tif ((r = private2_uudecode(blob, &decoded)) != 0 ||\n\t    (r = private2_decrypt(decoded, passphrase,\n\t    &decrypted, &pubkey)) != 0)\n\t\tgoto out;\n\n\tif (type != KEY_UNSPEC &&\n\t    sshkey_type_plain(type) != sshkey_type_plain(pubkey->type)) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshkey_private_deserialize(decrypted, &k)) != 0 ||\n\t    (r = sshbuf_get_cstring(decrypted, &comment, NULL)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = private2_check_padding(decrypted)) != 0)\n\t\tgoto out;\n\n\t \n\tif (!sshkey_equal(pubkey, k)) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = k;\n\t\tk = NULL;\n\t}\n\tif (commentp != NULL) {\n\t\t*commentp = comment;\n\t\tcomment = NULL;\n\t}\n out:\n\tfree(comment);\n\tsshbuf_free(decoded);\n\tsshbuf_free(decrypted);\n\tsshkey_free(k);\n\tsshkey_free(pubkey);\n\treturn r;\n}\n\nstatic int\nsshkey_parse_private2_pubkey(struct sshbuf *blob, int type,\n    struct sshkey **keyp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *decoded = NULL;\n\tstruct sshkey *pubkey = NULL;\n\tu_int nkeys = 0;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif ((r = private2_uudecode(blob, &decoded)) != 0)\n\t\tgoto out;\n\t \n\tif ((r = sshbuf_consume(decoded, sizeof(AUTH_MAGIC))) != 0 ||\n\t    (r = sshbuf_skip_string(decoded)) != 0 ||  \n\t    (r = sshbuf_skip_string(decoded)) != 0 ||  \n\t    (r = sshbuf_skip_string(decoded)) != 0 ||  \n\t    (r = sshbuf_get_u32(decoded, &nkeys)) != 0)\n\t\tgoto out;\n\n\tif (nkeys != 1) {\n\t\t \n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshkey_froms(decoded, &pubkey)) != 0)\n\t\tgoto out;\n\n\tif (type != KEY_UNSPEC &&\n\t    sshkey_type_plain(type) != sshkey_type_plain(pubkey->type)) {\n\t\tr = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\n\t \n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = pubkey;\n\t\tpubkey = NULL;\n\t}\n out:\n\tsshbuf_free(decoded);\n\tsshkey_free(pubkey);\n\treturn r;\n}\n\n#ifdef WITH_OPENSSL\n \nstatic int\nsshkey_private_to_blob_pem_pkcs8(struct sshkey *key, struct sshbuf *buf,\n    int format, const char *_passphrase, const char *comment)\n{\n\tint was_shielded = sshkey_is_shielded(key);\n\tint success, r;\n\tint blen, len = strlen(_passphrase);\n\tu_char *passphrase = (len > 0) ? (u_char *)_passphrase : NULL;\n\tconst EVP_CIPHER *cipher = (len > 0) ? EVP_aes_128_cbc() : NULL;\n\tchar *bptr;\n\tBIO *bio = NULL;\n\tstruct sshbuf *blob;\n\tEVP_PKEY *pkey = NULL;\n\n\tif (len > 0 && len <= 4)\n\t\treturn SSH_ERR_PASSPHRASE_TOO_SHORT;\n\tif ((blob = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (format == SSHKEY_PRIVATE_PKCS8 && (pkey = EVP_PKEY_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_unshield_private(key)) != 0)\n\t\tgoto out;\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tif (format == SSHKEY_PRIVATE_PEM) {\n\t\t\tsuccess = PEM_write_bio_DSAPrivateKey(bio, key->dsa,\n\t\t\t    cipher, passphrase, len, NULL, NULL);\n\t\t} else {\n\t\t\tsuccess = EVP_PKEY_set1_DSA(pkey, key->dsa);\n\t\t}\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (format == SSHKEY_PRIVATE_PEM) {\n\t\t\tsuccess = PEM_write_bio_ECPrivateKey(bio, key->ecdsa,\n\t\t\t    cipher, passphrase, len, NULL, NULL);\n\t\t} else {\n\t\t\tsuccess = EVP_PKEY_set1_EC_KEY(pkey, key->ecdsa);\n\t\t}\n\t\tbreak;\n#endif\n\tcase KEY_RSA:\n\t\tif (format == SSHKEY_PRIVATE_PEM) {\n\t\t\tsuccess = PEM_write_bio_RSAPrivateKey(bio, key->rsa,\n\t\t\t    cipher, passphrase, len, NULL, NULL);\n\t\t} else {\n\t\t\tsuccess = EVP_PKEY_set1_RSA(pkey, key->rsa);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsuccess = 0;\n\t\tbreak;\n\t}\n\tif (success == 0) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (format == SSHKEY_PRIVATE_PKCS8) {\n\t\tif ((success = PEM_write_bio_PrivateKey(bio, pkey, cipher,\n\t\t    passphrase, len, NULL, NULL)) == 0) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((blen = BIO_get_mem_data(bio, &bptr)) <= 0) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(blob, bptr, blen)) != 0)\n\t\tgoto out;\n\tr = 0;\n out:\n\tif (was_shielded)\n\t\tr = sshkey_shield_private(key);\n\tif (r == 0)\n\t\tr = sshbuf_putb(buf, blob);\n\n\tEVP_PKEY_free(pkey);\n\tsshbuf_free(blob);\n\tBIO_free(bio);\n\treturn r;\n}\n#endif  \n\n \nint\nsshkey_private_to_fileblob(struct sshkey *key, struct sshbuf *blob,\n    const char *passphrase, const char *comment,\n    int format, const char *openssh_format_cipher, int openssh_format_rounds)\n{\n\tswitch (key->type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n\tcase KEY_RSA:\n\t\tbreak;  \n#endif  \n\tcase KEY_ED25519:\n\tcase KEY_ED25519_SK:\n#ifdef WITH_XMSS\n\tcase KEY_XMSS:\n#endif  \n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n#endif  \n\t\treturn sshkey_private_to_blob2(key, blob, passphrase,\n\t\t    comment, openssh_format_cipher, openssh_format_rounds);\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\n#ifdef WITH_OPENSSL\n\tswitch (format) {\n\tcase SSHKEY_PRIVATE_OPENSSH:\n\t\treturn sshkey_private_to_blob2(key, blob, passphrase,\n\t\t    comment, openssh_format_cipher, openssh_format_rounds);\n\tcase SSHKEY_PRIVATE_PEM:\n\tcase SSHKEY_PRIVATE_PKCS8:\n\t\treturn sshkey_private_to_blob_pem_pkcs8(key, blob,\n\t\t    format, passphrase, comment);\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n#endif  \n}\n\n#ifdef WITH_OPENSSL\nstatic int\ntranslate_libcrypto_error(unsigned long pem_err)\n{\n\tint pem_reason = ERR_GET_REASON(pem_err);\n\n\tswitch (ERR_GET_LIB(pem_err)) {\n\tcase ERR_LIB_PEM:\n\t\tswitch (pem_reason) {\n\t\tcase PEM_R_BAD_PASSWORD_READ:\n#ifdef PEM_R_PROBLEMS_GETTING_PASSWORD\n\t\tcase PEM_R_PROBLEMS_GETTING_PASSWORD:\n#endif\n#ifdef PEM_R_BAD_DECRYPT\n\t\tcase PEM_R_BAD_DECRYPT:\n#endif\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\tdefault:\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\tcase ERR_LIB_EVP:\n\t\tswitch (pem_reason) {\n#ifdef EVP_R_BAD_DECRYPT\n\t\tcase EVP_R_BAD_DECRYPT:\n\t\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n#endif\n#ifdef EVP_R_BN_DECODE_ERROR\n\t\tcase EVP_R_BN_DECODE_ERROR:\n#endif\n\t\tcase EVP_R_DECODE_ERROR:\n#ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR\n\t\tcase EVP_R_PRIVATE_KEY_DECODE_ERROR:\n#endif\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tdefault:\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\t}\n\tcase ERR_LIB_ASN1:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\treturn SSH_ERR_LIBCRYPTO_ERROR;\n}\n\nstatic void\nclear_libcrypto_errors(void)\n{\n\twhile (ERR_get_error() != 0)\n\t\t;\n}\n\n \nstatic int\nconvert_libcrypto_error(void)\n{\n\t \n\tif (translate_libcrypto_error(ERR_peek_error()) ==\n\t    SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\treturn translate_libcrypto_error(ERR_peek_last_error());\n}\n\nstatic int\npem_passphrase_cb(char *buf, int size, int rwflag, void *u)\n{\n\tchar *p = (char *)u;\n\tsize_t len;\n\n\tif (p == NULL || (len = strlen(p)) == 0)\n\t\treturn -1;\n\tif (size < 0 || len > (size_t)size)\n\t\treturn -1;\n\tmemcpy(buf, p, len);\n\treturn (int)len;\n}\n\nstatic int\nsshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp)\n{\n\tEVP_PKEY *pk = NULL;\n\tstruct sshkey *prv = NULL;\n\tBIO *bio = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif ((bio = BIO_new(BIO_s_mem())) == NULL || sshbuf_len(blob) > INT_MAX)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (BIO_write(bio, sshbuf_ptr(blob), sshbuf_len(blob)) !=\n\t    (int)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tclear_libcrypto_errors();\n\tif ((pk = PEM_read_bio_PrivateKey(bio, NULL, pem_passphrase_cb,\n\t    (char *)passphrase)) == NULL) {\n\t\t \n\t\tif (passphrase != NULL && *passphrase != '\\0')\n\t\t\tr = SSH_ERR_KEY_WRONG_PASSPHRASE;\n\t\telse\n\t\t\tr = convert_libcrypto_error();\n\t\tgoto out;\n\t}\n\tif (EVP_PKEY_base_id(pk) == EVP_PKEY_RSA &&\n\t    (type == KEY_UNSPEC || type == KEY_RSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->rsa = EVP_PKEY_get1_RSA(pk);\n\t\tprv->type = KEY_RSA;\n#ifdef DEBUG_PK\n\t\tRSA_print_fp(stderr, prv->rsa, 8);\n#endif\n\t\tif (RSA_blinding_on(prv->rsa, NULL) != 1) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_check_rsa_length(prv, 0)) != 0)\n\t\t\tgoto out;\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_DSA &&\n\t    (type == KEY_UNSPEC || type == KEY_DSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->dsa = EVP_PKEY_get1_DSA(pk);\n\t\tprv->type = KEY_DSA;\n#ifdef DEBUG_PK\n\t\tDSA_print_fp(stderr, prv->dsa, 8);\n#endif\n#ifdef OPENSSL_HAS_ECC\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_EC &&\n\t    (type == KEY_UNSPEC || type == KEY_ECDSA)) {\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->ecdsa = EVP_PKEY_get1_EC_KEY(pk);\n\t\tprv->type = KEY_ECDSA;\n\t\tprv->ecdsa_nid = sshkey_ecdsa_key_to_nid(prv->ecdsa);\n\t\tif (prv->ecdsa_nid == -1 ||\n\t\t    sshkey_curve_nid_to_name(prv->ecdsa_nid) == NULL ||\n\t\t    sshkey_ec_validate_public(EC_KEY_get0_group(prv->ecdsa),\n\t\t    EC_KEY_get0_public_key(prv->ecdsa)) != 0 ||\n\t\t    sshkey_ec_validate_private(prv->ecdsa) != 0) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n# ifdef DEBUG_PK\n\t\tif (prv != NULL && prv->ecdsa != NULL)\n\t\t\tsshkey_dump_ec_key(prv->ecdsa);\n# endif\n#endif  \n#ifdef OPENSSL_HAS_ED25519\n\t} else if (EVP_PKEY_base_id(pk) == EVP_PKEY_ED25519 &&\n\t    (type == KEY_UNSPEC || type == KEY_ED25519)) {\n\t\tsize_t len;\n\n\t\tif ((prv = sshkey_new(KEY_UNSPEC)) == NULL ||\n\t\t    (prv->ed25519_sk = calloc(1, ED25519_SK_SZ)) == NULL ||\n\t\t    (prv->ed25519_pk = calloc(1, ED25519_PK_SZ)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tprv->type = KEY_ED25519;\n\t\tlen = ED25519_PK_SZ;\n\t\tif (!EVP_PKEY_get_raw_public_key(pk, prv->ed25519_pk, &len)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len != ED25519_PK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = ED25519_SK_SZ - ED25519_PK_SZ;\n\t\tif (!EVP_PKEY_get_raw_private_key(pk, prv->ed25519_sk, &len)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len != ED25519_SK_SZ - ED25519_PK_SZ) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tmemcpy(prv->ed25519_sk + (ED25519_SK_SZ - ED25519_PK_SZ),\n\t\t    prv->ed25519_pk, ED25519_PK_SZ);\n# ifdef DEBUG_PK\n\t\tsshbuf_dump_data(prv->ed25519_sk, ED25519_SK_SZ, stderr);\n# endif\n#endif  \n\t} else {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = prv;\n\t\tprv = NULL;\n\t}\n out:\n\tBIO_free(bio);\n\tEVP_PKEY_free(pk);\n\tsshkey_free(prv);\n\treturn r;\n}\n#endif  \n\nint\nsshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,\n    const char *passphrase, struct sshkey **keyp, char **commentp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\tswitch (type) {\n\tcase KEY_XMSS:\n\t\t \n\t\treturn sshkey_parse_private2(blob, type, passphrase,\n\t\t    keyp, commentp);\n\tdefault:\n\t\tr = sshkey_parse_private2(blob, type, passphrase, keyp,\n\t\t    commentp);\n\t\t \n\t\tif (r != SSH_ERR_INVALID_FORMAT)\n\t\t\treturn r;\n#ifdef WITH_OPENSSL\n\t\treturn sshkey_parse_private_pem_fileblob(blob, type,\n\t\t    passphrase, keyp);\n#else\n\t\treturn SSH_ERR_INVALID_FORMAT;\n#endif  \n\t}\n}\n\nint\nsshkey_parse_private_fileblob(struct sshbuf *buffer, const char *passphrase,\n    struct sshkey **keyp, char **commentp)\n{\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\n\treturn sshkey_parse_private_fileblob_type(buffer, KEY_UNSPEC,\n\t    passphrase, keyp, commentp);\n}\n\nvoid\nsshkey_sig_details_free(struct sshkey_sig_details *details)\n{\n\tfreezero(details, sizeof(*details));\n}\n\nint\nsshkey_parse_pubkey_from_private_fileblob_type(struct sshbuf *blob, int type,\n    struct sshkey **pubkeyp)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tif (pubkeyp != NULL)\n\t\t*pubkeyp = NULL;\n\t \n\tif ((r = sshkey_parse_private2_pubkey(blob, type, pubkeyp)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\n#ifdef WITH_XMSS\n \nint\nsshkey_private_serialize_maxsign(struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, int printerror)\n{\n\tint r, rupdate;\n\n\tif (maxsign == 0 ||\n\t    sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn sshkey_private_serialize_opt(k, b,\n\t\t    SSHKEY_SERIALIZE_DEFAULT);\n\tif ((r = sshkey_xmss_get_state(k, printerror)) != 0 ||\n\t    (r = sshkey_private_serialize_opt(k, b,\n\t    SSHKEY_SERIALIZE_STATE)) != 0 ||\n\t    (r = sshkey_xmss_forward_state(k, maxsign)) != 0)\n\t\tgoto out;\n\tr = 0;\nout:\n\tif ((rupdate = sshkey_xmss_update_state(k, printerror)) != 0) {\n\t\tif (r == 0)\n\t\t\tr = rupdate;\n\t}\n\treturn r;\n}\n\nu_int32_t\nsshkey_signatures_left(const struct sshkey *k)\n{\n\tif (sshkey_type_plain(k->type) == KEY_XMSS)\n\t\treturn sshkey_xmss_signatures_left(k);\n\treturn 0;\n}\n\nint\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn sshkey_xmss_enable_maxsign(k, maxsign);\n}\n\nint\nsshkey_set_filename(struct sshkey *k, const char *filename)\n{\n\tif (k == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshkey_type_plain(k->type) != KEY_XMSS)\n\t\treturn 0;\n\tif (filename == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((k->xmss_filename = strdup(filename)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}\n#else\nint\nsshkey_private_serialize_maxsign(struct sshkey *k, struct sshbuf *b,\n    u_int32_t maxsign, int printerror)\n{\n\treturn sshkey_private_serialize_opt(k, b, SSHKEY_SERIALIZE_DEFAULT);\n}\n\nu_int32_t\nsshkey_signatures_left(const struct sshkey *k)\n{\n\treturn 0;\n}\n\nint\nsshkey_enable_maxsign(struct sshkey *k, u_int32_t maxsign)\n{\n\treturn SSH_ERR_INVALID_ARGUMENT;\n}\n\nint\nsshkey_set_filename(struct sshkey *k, const char *filename)\n{\n\tif (k == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}