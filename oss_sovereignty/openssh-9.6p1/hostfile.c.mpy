{
  "module_name": "hostfile.c",
  "hash_id": "46e30e9b5e33bfeb0a5737edba8c517b353fa22092af26ea8fe3bd0bb8271a45",
  "original_prompt": "Ingested from openssh-9.6p1/hostfile.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <resolv.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"match.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"pathnames.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"hmac.h\"\n#include \"sshbuf.h\"\n\n \n\nstatic int\nextract_salt(const char *s, u_int l, u_char *salt, size_t salt_len)\n{\n\tchar *p, *b64salt;\n\tu_int b64len;\n\tint ret;\n\n\tif (l < sizeof(HASH_MAGIC) - 1) {\n\t\tdebug2(\"extract_salt: string too short\");\n\t\treturn (-1);\n\t}\n\tif (strncmp(s, HASH_MAGIC, sizeof(HASH_MAGIC) - 1) != 0) {\n\t\tdebug2(\"extract_salt: invalid magic identifier\");\n\t\treturn (-1);\n\t}\n\ts += sizeof(HASH_MAGIC) - 1;\n\tl -= sizeof(HASH_MAGIC) - 1;\n\tif ((p = memchr(s, HASH_DELIM, l)) == NULL) {\n\t\tdebug2(\"extract_salt: missing salt termination character\");\n\t\treturn (-1);\n\t}\n\n\tb64len = p - s;\n\t \n\tif (b64len == 0 || b64len > 1024) {\n\t\tdebug2(\"extract_salt: bad encoded salt length %u\", b64len);\n\t\treturn (-1);\n\t}\n\tb64salt = xmalloc(1 + b64len);\n\tmemcpy(b64salt, s, b64len);\n\tb64salt[b64len] = '\\0';\n\n\tret = __b64_pton(b64salt, salt, salt_len);\n\tfree(b64salt);\n\tif (ret == -1) {\n\t\tdebug2(\"extract_salt: salt decode error\");\n\t\treturn (-1);\n\t}\n\tif (ret != (int)ssh_hmac_bytes(SSH_DIGEST_SHA1)) {\n\t\tdebug2(\"extract_salt: expected salt len %zd, got %d\",\n\t\t    ssh_hmac_bytes(SSH_DIGEST_SHA1), ret);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}\n\nchar *\nhost_hash(const char *host, const char *name_from_hostfile, u_int src_len)\n{\n\tstruct ssh_hmac_ctx *ctx;\n\tu_char salt[256], result[256];\n\tchar uu_salt[512], uu_result[512];\n\tchar *encoded = NULL;\n\tu_int len;\n\n\tlen = ssh_digest_bytes(SSH_DIGEST_SHA1);\n\n\tif (name_from_hostfile == NULL) {\n\t\t \n\t\tarc4random_buf(salt, len);\n\t} else {\n\t\t \n\t\tif (extract_salt(name_from_hostfile, src_len, salt,\n\t\t    sizeof(salt)) == -1)\n\t\t\treturn (NULL);\n\t}\n\n\tif ((ctx = ssh_hmac_start(SSH_DIGEST_SHA1)) == NULL ||\n\t    ssh_hmac_init(ctx, salt, len) < 0 ||\n\t    ssh_hmac_update(ctx, host, strlen(host)) < 0 ||\n\t    ssh_hmac_final(ctx, result, sizeof(result)))\n\t\tfatal_f(\"ssh_hmac failed\");\n\tssh_hmac_free(ctx);\n\n\tif (__b64_ntop(salt, len, uu_salt, sizeof(uu_salt)) == -1 ||\n\t    __b64_ntop(result, len, uu_result, sizeof(uu_result)) == -1)\n\t\tfatal_f(\"__b64_ntop failed\");\n\txasprintf(&encoded, \"%s%s%c%s\", HASH_MAGIC, uu_salt, HASH_DELIM,\n\t    uu_result);\n\n\treturn (encoded);\n}\n\n \n\nint\nhostfile_read_key(char **cpp, u_int *bitsp, struct sshkey *ret)\n{\n\tchar *cp;\n\n\t \n\tfor (cp = *cpp; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\tif (sshkey_read(ret, &cp) != 0)\n\t\treturn 0;\n\n\t \n\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t;\n\n\t \n\t*cpp = cp;\n\tif (bitsp != NULL)\n\t\t*bitsp = sshkey_size(ret);\n\treturn 1;\n}\n\nstatic HostkeyMarker\ncheck_markers(char **cpp)\n{\n\tchar marker[32], *sp, *cp = *cpp;\n\tint ret = MRK_NONE;\n\n\twhile (*cp == '@') {\n\t\t \n\t\tif (ret != MRK_NONE)\n\t\t\treturn MRK_ERROR;\n\t\t \n\t\tif ((sp = strchr(cp, ' ')) == NULL &&\n\t\t    (sp = strchr(cp, '\\t')) == NULL)\n\t\t\treturn MRK_ERROR;\n\t\t \n\t\tif (sp <= cp + 1 || sp >= cp + sizeof(marker))\n\t\t\treturn MRK_ERROR;\n\t\tmemcpy(marker, cp, sp - cp);\n\t\tmarker[sp - cp] = '\\0';\n\t\tif (strcmp(marker, CA_MARKER) == 0)\n\t\t\tret = MRK_CA;\n\t\telse if (strcmp(marker, REVOKE_MARKER) == 0)\n\t\t\tret = MRK_REVOKE;\n\t\telse\n\t\t\treturn MRK_ERROR;\n\n\t\t \n\t\tcp = sp;\n\t\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t}\n\t*cpp = cp;\n\treturn ret;\n}\n\nstruct hostkeys *\ninit_hostkeys(void)\n{\n\tstruct hostkeys *ret = xcalloc(1, sizeof(*ret));\n\n\tret->entries = NULL;\n\treturn ret;\n}\n\nstruct load_callback_ctx {\n\tconst char *host;\n\tu_long num_loaded;\n\tstruct hostkeys *hostkeys;\n};\n\nstatic int\nrecord_hostkey(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct load_callback_ctx *ctx = (struct load_callback_ctx *)_ctx;\n\tstruct hostkeys *hostkeys = ctx->hostkeys;\n\tstruct hostkey_entry *tmp;\n\n\tif (l->status == HKF_STATUS_INVALID) {\n\t\t \n\t\tdebug(\"%s:%ld: parse error in hostkeys file\",\n\t\t    l->path, l->linenum);\n\t\treturn 0;\n\t}\n\n\tdebug3_f(\"found %skey type %s in file %s:%lu\",\n\t    l->marker == MRK_NONE ? \"\" :\n\t    (l->marker == MRK_CA ? \"ca \" : \"revoked \"),\n\t    sshkey_type(l->key), l->path, l->linenum);\n\tif ((tmp = recallocarray(hostkeys->entries, hostkeys->num_entries,\n\t    hostkeys->num_entries + 1, sizeof(*hostkeys->entries))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\thostkeys->entries = tmp;\n\thostkeys->entries[hostkeys->num_entries].host = xstrdup(ctx->host);\n\thostkeys->entries[hostkeys->num_entries].file = xstrdup(l->path);\n\thostkeys->entries[hostkeys->num_entries].line = l->linenum;\n\thostkeys->entries[hostkeys->num_entries].key = l->key;\n\tl->key = NULL;  \n\thostkeys->entries[hostkeys->num_entries].marker = l->marker;\n\thostkeys->entries[hostkeys->num_entries].note = l->note;\n\thostkeys->num_entries++;\n\tctx->num_loaded++;\n\n\treturn 0;\n}\n\nvoid\nload_hostkeys_file(struct hostkeys *hostkeys, const char *host,\n    const char *path, FILE *f, u_int note)\n{\n\tint r;\n\tstruct load_callback_ctx ctx;\n\n\tctx.host = host;\n\tctx.num_loaded = 0;\n\tctx.hostkeys = hostkeys;\n\n\tif ((r = hostkeys_foreach_file(path, f, record_hostkey, &ctx, host,\n\t    NULL, HKF_WANT_MATCH|HKF_WANT_PARSE_KEY, note)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR && errno != ENOENT)\n\t\t\tdebug_fr(r, \"hostkeys_foreach failed for %s\", path);\n\t}\n\tif (ctx.num_loaded != 0)\n\t\tdebug3_f(\"loaded %lu keys from %s\", ctx.num_loaded, host);\n}\n\nvoid\nload_hostkeys(struct hostkeys *hostkeys, const char *host, const char *path,\n    u_int note)\n{\n\tFILE *f;\n\n\tif ((f = fopen(path, \"r\")) == NULL) {\n\t\tdebug_f(\"fopen %s: %s\", path, strerror(errno));\n\t\treturn;\n\t}\n\n\tload_hostkeys_file(hostkeys, host, path, f, note);\n\tfclose(f);\n}\n\nvoid\nfree_hostkeys(struct hostkeys *hostkeys)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tfree(hostkeys->entries[i].host);\n\t\tfree(hostkeys->entries[i].file);\n\t\tsshkey_free(hostkeys->entries[i].key);\n\t\texplicit_bzero(hostkeys->entries + i, sizeof(*hostkeys->entries));\n\t}\n\tfree(hostkeys->entries);\n\tfreezero(hostkeys, sizeof(*hostkeys));\n}\n\nstatic int\ncheck_key_not_revoked(struct hostkeys *hostkeys, struct sshkey *k)\n{\n\tint is_cert = sshkey_is_cert(k);\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tif (hostkeys->entries[i].marker != MRK_REVOKE)\n\t\t\tcontinue;\n\t\tif (sshkey_equal_public(k, hostkeys->entries[i].key))\n\t\t\treturn -1;\n\t\tif (is_cert && k != NULL &&\n\t\t    sshkey_equal_public(k->cert->signature_key,\n\t\t    hostkeys->entries[i].key))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic HostStatus\ncheck_hostkeys_by_key_or_type(struct hostkeys *hostkeys,\n    struct sshkey *k, int keytype, int nid, const struct hostkey_entry **found)\n{\n\tu_int i;\n\tHostStatus end_return = HOST_NEW;\n\tint want_cert = sshkey_is_cert(k);\n\tHostkeyMarker want_marker = want_cert ? MRK_CA : MRK_NONE;\n\n\tif (found != NULL)\n\t\t*found = NULL;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tif (hostkeys->entries[i].marker != want_marker)\n\t\t\tcontinue;\n\t\tif (k == NULL) {\n\t\t\tif (hostkeys->entries[i].key->type != keytype)\n\t\t\t\tcontinue;\n\t\t\tif (nid != -1 &&\n\t\t\t    sshkey_type_plain(keytype) == KEY_ECDSA &&\n\t\t\t    hostkeys->entries[i].key->ecdsa_nid != nid)\n\t\t\t\tcontinue;\n\t\t\tend_return = HOST_FOUND;\n\t\t\tif (found != NULL)\n\t\t\t\t*found = hostkeys->entries + i;\n\t\t\tk = hostkeys->entries[i].key;\n\t\t\tbreak;\n\t\t}\n\t\tif (want_cert) {\n\t\t\tif (sshkey_equal_public(k->cert->signature_key,\n\t\t\t    hostkeys->entries[i].key)) {\n\t\t\t\t \n\t\t\t\tend_return = HOST_OK;\n\t\t\t\tif (found != NULL)\n\t\t\t\t\t*found = hostkeys->entries + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sshkey_equal(k, hostkeys->entries[i].key)) {\n\t\t\t\tend_return = HOST_OK;\n\t\t\t\tif (found != NULL)\n\t\t\t\t\t*found = hostkeys->entries + i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tend_return = HOST_CHANGED;\n\t\t\tif (found != NULL)\n\t\t\t\t*found = hostkeys->entries + i;\n\t\t}\n\t}\n\tif (check_key_not_revoked(hostkeys, k) != 0) {\n\t\tend_return = HOST_REVOKED;\n\t\tif (found != NULL)\n\t\t\t*found = NULL;\n\t}\n\treturn end_return;\n}\n\nHostStatus\ncheck_key_in_hostkeys(struct hostkeys *hostkeys, struct sshkey *key,\n    const struct hostkey_entry **found)\n{\n\tif (key == NULL)\n\t\tfatal(\"no key to look up\");\n\treturn check_hostkeys_by_key_or_type(hostkeys, key, 0, -1, found);\n}\n\nint\nlookup_key_in_hostkeys_by_type(struct hostkeys *hostkeys, int keytype, int nid,\n    const struct hostkey_entry **found)\n{\n\treturn (check_hostkeys_by_key_or_type(hostkeys, NULL, keytype, nid,\n\t    found) == HOST_FOUND);\n}\n\nint\nlookup_marker_in_hostkeys(struct hostkeys *hostkeys, int want_marker)\n{\n\tu_int i;\n\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\tif (hostkeys->entries[i].marker == (HostkeyMarker)want_marker)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nwrite_host_entry(FILE *f, const char *host, const char *ip,\n    const struct sshkey *key, int store_hash)\n{\n\tint r, success = 0;\n\tchar *hashed_host = NULL, *lhost;\n\n\tlhost = xstrdup(host);\n\tlowercase(lhost);\n\n\tif (store_hash) {\n\t\tif ((hashed_host = host_hash(lhost, NULL, 0)) == NULL) {\n\t\t\terror_f(\"host_hash failed\");\n\t\t\tfree(lhost);\n\t\t\treturn 0;\n\t\t}\n\t\tfprintf(f, \"%s \", hashed_host);\n\t} else if (ip != NULL)\n\t\tfprintf(f, \"%s,%s \", lhost, ip);\n\telse {\n\t\tfprintf(f, \"%s \", lhost);\n\t}\n\tfree(hashed_host);\n\tfree(lhost);\n\tif ((r = sshkey_write(key, f)) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror_fr(r, \"sshkey_write\");\n\tfputc('\\n', f);\n\t \n\tif (success && store_hash && ip != NULL)\n\t\tsuccess = write_host_entry(f, ip, NULL, key, 1);\n\treturn success;\n}\n\n \nvoid\nhostfile_create_user_ssh_dir(const char *filename, int notify)\n{\n\tchar *dotsshdir = NULL, *p;\n\tsize_t len;\n\tstruct stat st;\n\n\tif ((p = strrchr(filename, '/')) == NULL)\n\t\treturn;\n\tlen = p - filename;\n\tdotsshdir = tilde_expand_filename(\"~/\" _PATH_SSH_USER_DIR, getuid());\n\tif (strlen(dotsshdir) > len || strncmp(filename, dotsshdir, len) != 0)\n\t\tgoto out;  \n\tif (stat(dotsshdir, &st) == 0)\n\t\tgoto out;  \n\telse if (errno != ENOENT)\n\t\terror(\"Could not stat %s: %s\", dotsshdir, strerror(errno));\n\telse {\n#ifdef WITH_SELINUX\n\t\tssh_selinux_setfscreatecon(dotsshdir);\n#endif\n\t\tif (mkdir(dotsshdir, 0700) == -1)\n\t\t\terror(\"Could not create directory '%.200s' (%s).\",\n\t\t\t    dotsshdir, strerror(errno));\n\t\telse if (notify)\n\t\t\tlogit(\"Created directory '%s'.\", dotsshdir);\n#ifdef WITH_SELINUX\n\t\tssh_selinux_setfscreatecon(NULL);\n#endif\n\t}\n out:\n\tfree(dotsshdir);\n}\n\n \nint\nadd_host_to_hostfile(const char *filename, const char *host,\n    const struct sshkey *key, int store_hash)\n{\n\tFILE *f;\n\tint success, addnl = 0;\n\n\tif (key == NULL)\n\t\treturn 1;\t \n\thostfile_create_user_ssh_dir(filename, 0);\n\tf = fopen(filename, \"a+\");\n\tif (!f)\n\t\treturn 0;\n\t \n\tif (fseek(f, -1L, SEEK_END) == 0 && fgetc(f) != '\\n')\n\t\taddnl = 1;\n\tif (fseek(f, 0L, SEEK_END) != 0 || (addnl && fputc('\\n', f) != '\\n')) {\n\t\terror(\"Failed to add terminating newline to %s: %s\",\n\t\t   filename, strerror(errno));\n\t\tfclose(f);\n\t\treturn 0;\n\t}\n\tsuccess = write_host_entry(f, host, NULL, key, store_hash);\n\tfclose(f);\n\treturn success;\n}\n\nstruct host_delete_ctx {\n\tFILE *out;\n\tint quiet;\n\tconst char *host, *ip;\n\tu_int *match_keys;\t \n\tstruct sshkey * const *keys;\n\tsize_t nkeys;\n\tint modified;\n};\n\nstatic int\nhost_delete(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct host_delete_ctx *ctx = (struct host_delete_ctx *)_ctx;\n\tint loglevel = ctx->quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_VERBOSE;\n\tsize_t i;\n\n\t \n\tif (l->status == HKF_STATUS_MATCHED && l->marker == MRK_NONE) {\n\t\t \n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (!sshkey_equal(ctx->keys[i], l->key))\n\t\t\t\tcontinue;\n\t\t\tctx->match_keys[i] |= l->match;\n\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\tdebug3_f(\"%s key already at %s:%ld\",\n\t\t\t    sshkey_type(l->key), l->path, l->linenum);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tdo_log2(loglevel, \"%s%s%s:%ld: Removed %s key for host %s\",\n\t\t    ctx->quiet ? __func__ : \"\", ctx->quiet ? \": \" : \"\",\n\t\t    l->path, l->linenum, sshkey_type(l->key), ctx->host);\n\t\tctx->modified = 1;\n\t\treturn 0;\n\t}\n\t \n\tif (l->status == HKF_STATUS_INVALID) {\n\t\tdo_log2(loglevel, \"%s%s%s:%ld: invalid known_hosts entry\",\n\t\t    ctx->quiet ? __func__ : \"\", ctx->quiet ? \": \" : \"\",\n\t\t    l->path, l->linenum);\n\t}\n\tfprintf(ctx->out, \"%s\\n\", l->line);\n\treturn 0;\n}\n\nint\nhostfile_replace_entries(const char *filename, const char *host, const char *ip,\n    struct sshkey **keys, size_t nkeys, int store_hash, int quiet, int hash_alg)\n{\n\tint r, fd, oerrno = 0;\n\tint loglevel = quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_VERBOSE;\n\tstruct host_delete_ctx ctx;\n\tchar *fp, *temp = NULL, *back = NULL;\n\tconst char *what;\n\tmode_t omask;\n\tsize_t i;\n\tu_int want;\n\n\tomask = umask(077);\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.host = host;\n\tctx.ip = ip;\n\tctx.quiet = quiet;\n\n\tif ((ctx.match_keys = calloc(nkeys, sizeof(*ctx.match_keys))) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tctx.keys = keys;\n\tctx.nkeys = nkeys;\n\tctx.modified = 0;\n\n\t \n\tif ((r = asprintf(&temp, \"%s.XXXXXXXXXXX\", filename)) == -1 ||\n\t    (r = asprintf(&back, \"%s.old\", filename)) == -1) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif ((fd = mkstemp(temp)) == -1) {\n\t\toerrno = errno;\n\t\terror_f(\"mkstemp: %s\", strerror(oerrno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\toerrno = errno;\n\t\tclose(fd);\n\t\terror_f(\"fdopen: %s\", strerror(oerrno));\n\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\tgoto fail;\n\t}\n\n\t \n\tif ((r = hostkeys_foreach(filename, host_delete, &ctx, host, ip,\n\t    HKF_WANT_PARSE_KEY, 0)) != 0) {\n\t\toerrno = errno;\n\t\terror_fr(r, \"hostkeys_foreach\");\n\t\tgoto fail;\n\t}\n\n\t \n\twant = HKF_MATCH_HOST | (ip == NULL ? 0 : HKF_MATCH_IP);\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (keys[i] == NULL || (want & ctx.match_keys[i]) == want)\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(keys[i], hash_alg,\n\t\t    SSH_FP_DEFAULT)) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t\t \n\t\twhat = \"\";\n\t\tif (ctx.match_keys[i] == 0) {\n\t\t\twhat = \"Adding new key\";\n\t\t\tif (!write_host_entry(ctx.out, host, ip,\n\t\t\t    keys[i], store_hash)) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if ((want & ~ctx.match_keys[i]) == HKF_MATCH_HOST) {\n\t\t\twhat = \"Fixing match (hostname)\";\n\t\t\tif (!write_host_entry(ctx.out, host, NULL,\n\t\t\t    keys[i], store_hash)) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if ((want & ~ctx.match_keys[i]) == HKF_MATCH_IP) {\n\t\t\twhat = \"Fixing match (address)\";\n\t\t\tif (!write_host_entry(ctx.out, ip, NULL,\n\t\t\t    keys[i], store_hash)) {\n\t\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tdo_log2(loglevel, \"%s%s%s for %s%s%s to %s: %s %s\",\n\t\t    quiet ? __func__ : \"\", quiet ? \": \" : \"\", what,\n\t\t    host, ip == NULL ? \"\" : \",\", ip == NULL ? \"\" : ip, filename,\n\t\t    sshkey_ssh_name(keys[i]), fp);\n\t\tfree(fp);\n\t\tctx.modified = 1;\n\t}\n\tfclose(ctx.out);\n\tctx.out = NULL;\n\n\tif (ctx.modified) {\n\t\t \n\t\tif (unlink(back) == -1 && errno != ENOENT) {\n\t\t\toerrno = errno;\n\t\t\terror_f(\"unlink %.100s: %s\", back, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (link(filename, back) == -1) {\n\t\t\toerrno = errno;\n\t\t\terror_f(\"link %.100s to %.100s: %s\", filename,\n\t\t\t    back, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rename(temp, filename) == -1) {\n\t\t\toerrno = errno;\n\t\t\terror_f(\"rename \\\"%s\\\" to \\\"%s\\\": %s\", temp,\n\t\t\t    filename, strerror(errno));\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t \n\t\tif (unlink(temp) != 0)\n\t\t\terror_f(\"unlink \\\"%s\\\": %s\", temp, strerror(errno));\n\t}\n\n\t \n\tr = 0;\n fail:\n\tif (temp != NULL && r != 0)\n\t\tunlink(temp);\n\tfree(temp);\n\tfree(back);\n\tif (ctx.out != NULL)\n\t\tfclose(ctx.out);\n\tfree(ctx.match_keys);\n\tumask(omask);\n\tif (r == SSH_ERR_SYSTEM_ERROR)\n\t\terrno = oerrno;\n\treturn r;\n}\n\nstatic int\nmatch_maybe_hashed(const char *host, const char *names, int *was_hashed)\n{\n\tint hashed = *names == HASH_DELIM, ret;\n\tchar *hashed_host = NULL;\n\tsize_t nlen = strlen(names);\n\n\tif (was_hashed != NULL)\n\t\t*was_hashed = hashed;\n\tif (hashed) {\n\t\tif ((hashed_host = host_hash(host, names, nlen)) == NULL)\n\t\t\treturn -1;\n\t\tret = (nlen == strlen(hashed_host) &&\n\t\t    strncmp(hashed_host, names, nlen) == 0);\n\t\tfree(hashed_host);\n\t\treturn ret;\n\t}\n\treturn match_hostname(host, names) == 1;\n}\n\nint\nhostkeys_foreach_file(const char *path, FILE *f, hostkeys_foreach_fn *callback,\n    void *ctx, const char *host, const char *ip, u_int options, u_int note)\n{\n\tchar *line = NULL, ktype[128];\n\tu_long linenum = 0;\n\tchar *cp, *cp2;\n\tu_int kbits;\n\tint hashed;\n\tint s, r = 0;\n\tstruct hostkey_foreach_line lineinfo;\n\tsize_t linesize = 0, l;\n\n\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\tif (host == NULL && (options & HKF_WANT_MATCH) != 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlinenum++;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\n\t\tfree(lineinfo.line);\n\t\tsshkey_free(lineinfo.key);\n\t\tmemset(&lineinfo, 0, sizeof(lineinfo));\n\t\tlineinfo.path = path;\n\t\tlineinfo.linenum = linenum;\n\t\tlineinfo.line = xstrdup(line);\n\t\tlineinfo.marker = MRK_NONE;\n\t\tlineinfo.status = HKF_STATUS_OK;\n\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\tlineinfo.note = note;\n\n\t\t \n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n') {\n\t\t\tif ((options & HKF_WANT_MATCH) == 0) {\n\t\t\t\tlineinfo.status = HKF_STATUS_COMMENT;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((lineinfo.marker = check_markers(&cp)) == MRK_ERROR) {\n\t\t\tverbose_f(\"invalid marker at %s:%lu\", path, linenum);\n\t\t\tif ((options & HKF_WANT_MATCH) == 0)\n\t\t\t\tgoto bad;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (cp2 = cp; *cp2 && *cp2 != ' ' && *cp2 != '\\t'; cp2++)\n\t\t\t;\n\t\tlineinfo.hosts = cp;\n\t\t*cp2++ = '\\0';\n\n\t\t \n\t\tif (host != NULL) {\n\t\t\tif ((s = match_maybe_hashed(host, lineinfo.hosts,\n\t\t\t    &hashed)) == -1) {\n\t\t\t\tdebug2_f(\"%s:%ld: bad host hash \\\"%.32s\\\"\",\n\t\t\t\t    path, linenum, lineinfo.hosts);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (s == 1) {\n\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\tlineinfo.match |= HKF_MATCH_HOST |\n\t\t\t\t    (hashed ? HKF_MATCH_HOST_HASHED : 0);\n\t\t\t}\n\t\t\t \n\t\t\tif (ip != NULL) {\n\t\t\t\tif ((s = match_maybe_hashed(ip, lineinfo.hosts,\n\t\t\t\t    &hashed)) == -1) {\n\t\t\t\t\tdebug2_f(\"%s:%ld: bad ip hash \"\n\t\t\t\t\t    \"\\\"%.32s\\\"\", path, linenum,\n\t\t\t\t\t    lineinfo.hosts);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (s == 1) {\n\t\t\t\t\tlineinfo.status = HKF_STATUS_MATCHED;\n\t\t\t\t\tlineinfo.match |= HKF_MATCH_IP |\n\t\t\t\t\t    (hashed ? HKF_MATCH_IP_HASHED : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif ((options & HKF_WANT_MATCH) != 0 &&\n\t\t\t    lineinfo.status != HKF_STATUS_MATCHED)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t;\n\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\tdebug2(\"%s:%ld: truncated before key type\",\n\t\t\t    path, linenum);\n\t\t\tgoto bad;\n\t\t}\n\t\tlineinfo.rawkey = cp = cp2;\n\n\t\tif ((options & HKF_WANT_PARSE_KEY) != 0) {\n\t\t\t \n\t\t\tif ((lineinfo.key = sshkey_new(KEY_UNSPEC)) == NULL) {\n\t\t\t\terror_f(\"sshkey_new failed\");\n\t\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!hostfile_read_key(&cp, &kbits, lineinfo.key)) {\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tlineinfo.keytype = lineinfo.key->type;\n\t\t\tlineinfo.comment = cp;\n\t\t} else {\n\t\t\t \n\t\t\tl = strcspn(lineinfo.rawkey, \" \\t\");\n\t\t\tif (l <= 1 || l >= sizeof(ktype) ||\n\t\t\t    lineinfo.rawkey[l] == '\\0')\n\t\t\t\tgoto bad;\n\t\t\tmemcpy(ktype, lineinfo.rawkey, l);\n\t\t\tktype[l] = '\\0';\n\t\t\tlineinfo.keytype = sshkey_type_from_name(ktype);\n\n\t\t\t \n\t\t\tif (lineinfo.keytype == KEY_UNSPEC && l < 8 &&\n\t\t\t    strspn(ktype, \"0123456789\") == l)\n\t\t\t\tgoto bad;\n\n\t\t\t \n\t\t\tcp2 += l;  \n\t\t\tfor (; *cp2 == ' ' || *cp2 == '\\t'; cp2++)\n\t\t\t\t;\n\t\t\tif (*cp2 == '\\0' || *cp2 == '#') {\n\t\t\t\tdebug2(\"%s:%ld: truncated after key type\",\n\t\t\t\t    path, linenum);\n\t\t\t\tlineinfo.keytype = KEY_UNSPEC;\n\t\t\t}\n\t\t\tif (lineinfo.keytype == KEY_UNSPEC) {\n bad:\n\t\t\t\tsshkey_free(lineinfo.key);\n\t\t\t\tlineinfo.key = NULL;\n\t\t\t\tlineinfo.status = HKF_STATUS_INVALID;\n\t\t\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((r = callback(&lineinfo, ctx)) != 0)\n\t\t\tbreak;\n\t}\n\tsshkey_free(lineinfo.key);\n\tfree(lineinfo.line);\n\tfree(line);\n\treturn r;\n}\n\nint\nhostkeys_foreach(const char *path, hostkeys_foreach_fn *callback, void *ctx,\n    const char *host, const char *ip, u_int options, u_int note)\n{\n\tFILE *f;\n\tint r, oerrno;\n\n\tif ((f = fopen(path, \"r\")) == NULL)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\n\tdebug3_f(\"reading file \\\"%s\\\"\", path);\n\tr = hostkeys_foreach_file(path, f, callback, ctx, host, ip,\n\t    options, note);\n\toerrno = errno;\n\tfclose(f);\n\terrno = oerrno;\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}