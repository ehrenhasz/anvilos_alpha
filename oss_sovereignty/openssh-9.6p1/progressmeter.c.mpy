{
  "module_name": "progressmeter.c",
  "hash_id": "8a0060707ac1a3f2267f5314b59e1777fa760a4735a65193725440931cf7c005",
  "original_prompt": "Ingested from openssh-9.6p1/progressmeter.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"progressmeter.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"utf8.h\"\n\n#define DEFAULT_WINSIZE 80\n#define MAX_WINSIZE 512\n#define PADDING 1\t\t \n#define UPDATE_INTERVAL 1\t \n#define STALL_TIME 5\t\t \n\n \nstatic int can_output(void);\n\n \nstatic void sig_winch(int);\nstatic void setscreensize(void);\n\n \nstatic void sig_alarm(int);\n\nstatic double start;\t\t \nstatic double last_update;\t \nstatic const char *file;\t \nstatic off_t start_pos;\t\t \nstatic off_t end_pos;\t\t \nstatic off_t cur_pos;\t\t \nstatic volatile off_t *counter;\t \nstatic long stalled;\t\t \nstatic int bytes_per_second;\t \nstatic int win_size;\t\t \nstatic volatile sig_atomic_t win_resized;  \nstatic volatile sig_atomic_t alarm_fired;\n\n \nstatic const char unit[] = \" KMGT\";\n\nstatic int\ncan_output(void)\n{\n\treturn (getpgrp() == tcgetpgrp(STDOUT_FILENO));\n}\n\n \n#define STRING_SIZE(v) (((sizeof(v) * 8 * 4) / 10) + 1)\n\nstatic const char *\nformat_rate(off_t bytes)\n{\n\tint i;\n\tstatic char buf[STRING_SIZE(bytes) * 2 + 16];\n\n\tbytes *= 100;\n\tfor (i = 0; bytes >= 100*1000 && unit[i] != 'T'; i++)\n\t\tbytes = (bytes + 512) / 1024;\n\tif (i == 0) {\n\t\ti++;\n\t\tbytes = (bytes + 512) / 1024;\n\t}\n\tsnprintf(buf, sizeof(buf), \"%3lld.%1lld%c%s\",\n\t    (long long) (bytes + 5) / 100,\n\t    (long long) (bytes + 5) / 10 % 10,\n\t    unit[i],\n\t    i ? \"B\" : \" \");\n\treturn buf;\n}\n\nstatic const char *\nformat_size(off_t bytes)\n{\n\tint i;\n\tstatic char buf[STRING_SIZE(bytes) + 16];\n\n\tfor (i = 0; bytes >= 10000 && unit[i] != 'T'; i++)\n\t\tbytes = (bytes + 512) / 1024;\n\tsnprintf(buf, sizeof(buf), \"%4lld%c%s\",\n\t    (long long) bytes,\n\t    unit[i],\n\t    i ? \"B\" : \" \");\n\treturn buf;\n}\n\nvoid\nrefresh_progress_meter(int force_update)\n{\n\tchar *buf = NULL, *obuf = NULL;\n\toff_t transferred;\n\tdouble elapsed, now;\n\tint percent;\n\toff_t bytes_left;\n\tint cur_speed;\n\tint hours, minutes, seconds;\n\tint file_len, cols;\n\n\tif ((!force_update && !alarm_fired && !win_resized) || !can_output())\n\t\treturn;\n\talarm_fired = 0;\n\n\tif (win_resized) {\n\t\tsetscreensize();\n\t\twin_resized = 0;\n\t}\n\n\ttransferred = *counter - (cur_pos ? cur_pos : start_pos);\n\tcur_pos = *counter;\n\tnow = monotime_double();\n\tbytes_left = end_pos - cur_pos;\n\n\tif (bytes_left > 0)\n\t\telapsed = now - last_update;\n\telse {\n\t\telapsed = now - start;\n\t\t \n\t\ttransferred = end_pos - start_pos;\n\t\tbytes_per_second = 0;\n\t}\n\n\t \n\tif (elapsed != 0)\n\t\tcur_speed = (transferred / elapsed);\n\telse\n\t\tcur_speed = transferred;\n\n#define AGE_FACTOR 0.9\n\tif (bytes_per_second != 0) {\n\t\tbytes_per_second = (bytes_per_second * AGE_FACTOR) +\n\t\t    (cur_speed * (1.0 - AGE_FACTOR));\n\t} else\n\t\tbytes_per_second = cur_speed;\n\n\tlast_update = now;\n\n\t \n\tif (win_size < 4)\n\t\treturn;\n\n\t \n\tfile_len = cols = win_size - 36;\n\tif (file_len > 0) {\n\t\tasmprintf(&buf, INT_MAX, &cols, \"%-*s\", file_len, file);\n\t\t \n\t\tif (cols < file_len)\n\t\t\txextendf(&buf, NULL, \"%*s\", file_len - cols, \"\");\n\t}\n\t \n\tif (end_pos == 0 || cur_pos == end_pos)\n\t\tpercent = 100;\n\telse\n\t\tpercent = ((float)cur_pos / end_pos) * 100;\n\n\t \n\txextendf(&buf, NULL, \" %3d%% %s %s/s \", percent, format_size(cur_pos),\n\t    format_rate((off_t)bytes_per_second));\n\n\t \n\tif (!transferred)\n\t\tstalled += elapsed;\n\telse\n\t\tstalled = 0;\n\n\tif (stalled >= STALL_TIME)\n\t\txextendf(&buf, NULL, \"- stalled -\");\n\telse if (bytes_per_second == 0 && bytes_left)\n\t\txextendf(&buf, NULL, \"  --:-- ETA\");\n\telse {\n\t\tif (bytes_left > 0)\n\t\t\tseconds = bytes_left / bytes_per_second;\n\t\telse\n\t\t\tseconds = elapsed;\n\n\t\thours = seconds / 3600;\n\t\tseconds -= hours * 3600;\n\t\tminutes = seconds / 60;\n\t\tseconds -= minutes * 60;\n\n\t\tif (hours != 0) {\n\t\t\txextendf(&buf, NULL, \"%d:%02d:%02d\",\n\t\t\t    hours, minutes, seconds);\n\t\t} else\n\t\t\txextendf(&buf, NULL, \"  %02d:%02d\", minutes, seconds);\n\n\t\tif (bytes_left > 0)\n\t\t\txextendf(&buf, NULL, \" ETA\");\n\t\telse\n\t\t\txextendf(&buf, NULL, \"    \");\n\t}\n\n\t \n\tcols = win_size - 1;\n\tasmprintf(&obuf, INT_MAX, &cols, \" %s\", buf);\n\tif (obuf != NULL) {\n\t\t*obuf = '\\r';  \n\t\tatomicio(vwrite, STDOUT_FILENO, obuf, strlen(obuf));\n\t}\n\tfree(buf);\n\tfree(obuf);\n}\n\nstatic void\nsig_alarm(int ignore)\n{\n\talarm_fired = 1;\n\talarm(UPDATE_INTERVAL);\n}\n\nvoid\nstart_progress_meter(const char *f, off_t filesize, off_t *ctr)\n{\n\tstart = last_update = monotime_double();\n\tfile = f;\n\tstart_pos = *ctr;\n\tend_pos = filesize;\n\tcur_pos = 0;\n\tcounter = ctr;\n\tstalled = 0;\n\tbytes_per_second = 0;\n\n\tsetscreensize();\n\trefresh_progress_meter(1);\n\n\tssh_signal(SIGALRM, sig_alarm);\n\tssh_signal(SIGWINCH, sig_winch);\n\talarm(UPDATE_INTERVAL);\n}\n\nvoid\nstop_progress_meter(void)\n{\n\talarm(0);\n\n\tif (!can_output())\n\t\treturn;\n\n\t \n\tif (cur_pos != end_pos)\n\t\trefresh_progress_meter(1);\n\n\tatomicio(vwrite, STDOUT_FILENO, \"\\n\", 1);\n}\n\nstatic void\nsig_winch(int sig)\n{\n\twin_resized = 1;\n}\n\nstatic void\nsetscreensize(void)\n{\n\tstruct winsize winsize;\n\n\tif (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize) != -1 &&\n\t    winsize.ws_col != 0) {\n\t\tif (winsize.ws_col > MAX_WINSIZE)\n\t\t\twin_size = MAX_WINSIZE;\n\t\telse\n\t\t\twin_size = winsize.ws_col;\n\t} else\n\t\twin_size = DEFAULT_WINSIZE;\n\twin_size += 1;\t\t\t\t\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}