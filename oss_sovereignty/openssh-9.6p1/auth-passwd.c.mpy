{
  "module_name": "auth-passwd.c",
  "hash_id": "90b91e9c60f83609044613fa80e6d37cb9793563258bbc0f2dd01e83305bdf69",
  "original_prompt": "Ingested from openssh-9.6p1/auth-passwd.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n\nextern struct sshbuf *loginmsg;\nextern ServerOptions options;\n\n#ifdef HAVE_LOGIN_CAP\nextern login_cap_t *lc;\n#endif\n\n\n#define DAY\t\t(24L * 60 * 60)  \n#define TWO_WEEKS\t(2L * 7 * DAY)\t \n\n#define MAX_PASSWORD_LEN\t1024\n\n \nint\nauth_password(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t \n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(ssh, password);\n\tif (authctxt->force_pwchange)\n\t\tauth_restrict_session(ssh);\n\treturn (result && ok);\n}\n\n#ifdef BSD_AUTH\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tint r;\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal_fr(r, \"buffer error\");\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tif ((r = sshbuf_putf(loginmsg,\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\")) != 0)\n\t\t\tfatal_fr(r, \"buffer error\");\n\t}\n}\n\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(authctxt->pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tauth_restrict_session(ssh);\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}\n#elif !defined(CUSTOM_SYS_AUTH_PASSWD)\nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t \n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\tif (pw_password == NULL)\n\t\treturn 0;\n\n\t \n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t \n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t \n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}