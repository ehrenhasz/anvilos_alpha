{
  "module_name": "auth.c",
  "hash_id": "b8530ba5c18141a9a3f182834b1585c7cd6521487b36850113d9d33346a243a3",
  "original_prompt": "Ingested from openssh-9.6p1/auth.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#include <netinet/in.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <pwd.h>\n#ifdef HAVE_LOGIN_H\n#include <login.h>\n#endif\n#ifdef USE_SHADOW\n#include <shadow.h>\n#endif\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <netdb.h>\n#include <time.h>\n\n#include \"xmalloc.h\"\n#include \"match.h\"\n#include \"groupaccess.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n#include \"canohost.h\"\n#include \"uidswap.h\"\n#include \"packet.h\"\n#include \"loginrec.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"authfile.h\"\n#include \"monitor_wrap.h\"\n#include \"ssherr.h\"\n#include \"channels.h\"\n\n \nextern ServerOptions options;\nextern struct include_list includes;\nextern int use_privsep;\nextern struct sshbuf *loginmsg;\nextern struct passwd *privsep_pw;\nextern struct sshauthopt *auth_opts;\n\n \nstatic struct sshbuf *auth_debug;\n\n \nint\nallowed_user(struct ssh *ssh, struct passwd * pw)\n{\n\tstruct stat st;\n\tconst char *hostname = NULL, *ipaddr = NULL;\n\tu_int i;\n\tint r;\n\n\t \n\tif (!pw || !pw->pw_name)\n\t\treturn 0;\n\n\tif (!options.use_pam && platform_locked_account(pw)) {\n\t\tlogit(\"User %.100s not allowed because account is locked\",\n\t\t    pw->pw_name);\n\t\treturn 0;\n\t}\n\n\t \n\tif (options.chroot_directory == NULL ||\n\t    strcasecmp(options.chroot_directory, \"none\") == 0) {\n\t\tchar *shell = xstrdup((pw->pw_shell[0] == '\\0') ?\n\t\t    _PATH_BSHELL : pw->pw_shell);  \n\n\t\tif (stat(shell, &st) == -1) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"does not exist\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tif (S_ISREG(st.st_mode) == 0 ||\n\t\t    (st.st_mode & (S_IXOTH|S_IXUSR|S_IXGRP)) == 0) {\n\t\t\tlogit(\"User %.100s not allowed because shell %.100s \"\n\t\t\t    \"is not executable\", pw->pw_name, shell);\n\t\t\tfree(shell);\n\t\t\treturn 0;\n\t\t}\n\t\tfree(shell);\n\t}\n\n\tif (options.num_deny_users > 0 || options.num_allow_users > 0 ||\n\t    options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\thostname = auth_get_canonical_hostname(ssh, options.use_dns);\n\t\tipaddr = ssh_remote_ipaddr(ssh);\n\t}\n\n\t \n\tif (options.num_deny_users > 0) {\n\t\tfor (i = 0; i < options.num_deny_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.deny_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid DenyUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.deny_users[i]);\n\t\t\t} else if (r != 0) {\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because listed in DenyUsers\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (options.num_allow_users > 0) {\n\t\tfor (i = 0; i < options.num_allow_users; i++) {\n\t\t\tr = match_user(pw->pw_name, hostname, ipaddr,\n\t\t\t    options.allow_users[i]);\n\t\t\tif (r < 0) {\n\t\t\t\tfatal(\"Invalid AllowUsers pattern \\\"%.100s\\\"\",\n\t\t\t\t    options.allow_users[i]);\n\t\t\t} else if (r == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (i >= options.num_allow_users) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not listed in AllowUsers\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (options.num_deny_groups > 0 || options.num_allow_groups > 0) {\n\t\t \n\t\tif (ga_init(pw->pw_name, pw->pw_gid) == 0) {\n\t\t\tlogit(\"User %.100s from %.100s not allowed because \"\n\t\t\t    \"not in any group\", pw->pw_name, hostname);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (options.num_deny_groups > 0)\n\t\t\tif (ga_match(options.deny_groups,\n\t\t\t    options.num_deny_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because a group is listed in DenyGroups\",\n\t\t\t\t    pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t \n\t\tif (options.num_allow_groups > 0)\n\t\t\tif (!ga_match(options.allow_groups,\n\t\t\t    options.num_allow_groups)) {\n\t\t\t\tga_free();\n\t\t\t\tlogit(\"User %.100s from %.100s not allowed \"\n\t\t\t\t    \"because none of user's groups are listed \"\n\t\t\t\t    \"in AllowGroups\", pw->pw_name, hostname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tga_free();\n\t}\n\n#ifdef CUSTOM_SYS_AUTH_ALLOWED_USER\n\tif (!sys_auth_allowed_user(pw, loginmsg))\n\t\treturn 0;\n#endif\n\n\t \n\treturn 1;\n}\n\n \nstatic char *\nformat_method_key(Authctxt *authctxt)\n{\n\tconst struct sshkey *key = authctxt->auth_method_key;\n\tconst char *methinfo = authctxt->auth_method_info;\n\tchar *fp, *cafp, *ret = NULL;\n\n\tif (key == NULL)\n\t\treturn NULL;\n\n\tif (sshkey_is_cert(key)) {\n\t\tfp = sshkey_fingerprint(key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tcafp = sshkey_fingerprint(key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s ID %s (serial %llu) CA %s %s%s%s\",\n\t\t    sshkey_type(key), fp == NULL ? \"(null)\" : fp,\n\t\t    key->cert->key_id,\n\t\t    (unsigned long long)key->cert->serial,\n\t\t    sshkey_type(key->cert->signature_key),\n\t\t    cafp == NULL ? \"(null)\" : cafp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t\tfree(cafp);\n\t} else {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\txasprintf(&ret, \"%s %s%s%s\", sshkey_type(key),\n\t\t    fp == NULL ? \"(null)\" : fp,\n\t\t    methinfo == NULL ? \"\" : \", \",\n\t\t    methinfo == NULL ? \"\" : methinfo);\n\t\tfree(fp);\n\t}\n\treturn ret;\n}\n\nvoid\nauth_log(struct ssh *ssh, int authenticated, int partial,\n    const char *method, const char *submethod)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tint level = SYSLOG_LEVEL_VERBOSE;\n\tconst char *authmsg;\n\tchar *extra = NULL;\n\n\tif (use_privsep && !mm_is_monitor() && !authctxt->postponed)\n\t\treturn;\n\n\t \n\tif (authenticated == 1 ||\n\t    !authctxt->valid ||\n\t    authctxt->failures >= options.max_authtries / 2 ||\n\t    strcmp(method, \"password\") == 0)\n\t\tlevel = SYSLOG_LEVEL_INFO;\n\n\tif (authctxt->postponed)\n\t\tauthmsg = \"Postponed\";\n\telse if (partial)\n\t\tauthmsg = \"Partial\";\n\telse\n\t\tauthmsg = authenticated ? \"Accepted\" : \"Failed\";\n\n\tif ((extra = format_method_key(authctxt)) == NULL) {\n\t\tif (authctxt->auth_method_info != NULL)\n\t\t\textra = xstrdup(authctxt->auth_method_info);\n\t}\n\n\tdo_log2(level, \"%s %s%s%s for %s%.100s from %.200s port %d ssh2%s%s\",\n\t    authmsg,\n\t    method,\n\t    submethod != NULL ? \"/\" : \"\", submethod == NULL ? \"\" : submethod,\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    extra != NULL ? \": \" : \"\",\n\t    extra != NULL ? extra : \"\");\n\n\tfree(extra);\n\n#if defined(CUSTOM_FAILED_LOGIN) || defined(SSH_AUDIT_EVENTS)\n\tif (authenticated == 0 && !(authctxt->postponed || partial)) {\n\t\t \n# ifdef CUSTOM_FAILED_LOGIN\n\t\tif (strcmp(method, \"password\") == 0 ||\n\t\t    strncmp(method, \"keyboard-interactive\", 20) == 0 ||\n\t\t    strcmp(method, \"challenge-response\") == 0)\n\t\t\trecord_failed_login(ssh, authctxt->user,\n\t\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n# endif\n# ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(ssh, audit_classify_auth(method));\n# endif\n\t}\n#endif\n#if defined(CUSTOM_FAILED_LOGIN) && defined(WITH_AIXAUTHENTICATE)\n\tif (authenticated)\n\t\tsys_auth_record_login(authctxt->user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\",\n\t\t    loginmsg);\n#endif\n}\n\nvoid\nauth_maxtries_exceeded(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\n\terror(\"maximum authentication attempts exceeded for \"\n\t    \"%s%.100s from %.200s port %d ssh2\",\n\t    authctxt->valid ? \"\" : \"invalid user \",\n\t    authctxt->user,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh));\n\tssh_packet_disconnect(ssh, \"Too many authentication failures\");\n\t \n}\n\n \nint\nauth_root_allowed(struct ssh *ssh, const char *method)\n{\n\tswitch (options.permit_root_login) {\n\tcase PERMIT_YES:\n\t\treturn 1;\n\tcase PERMIT_NO_PASSWD:\n\t\tif (strcmp(method, \"publickey\") == 0 ||\n\t\t    strcmp(method, \"hostbased\") == 0 ||\n\t\t    strcmp(method, \"gssapi-with-mic\") == 0)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase PERMIT_FORCED_ONLY:\n\t\tif (auth_opts->force_command != NULL) {\n\t\t\tlogit(\"Root login accepted for forced command.\");\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\tlogit(\"ROOT LOGIN REFUSED FROM %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn 0;\n}\n\n\n \nchar *\nexpand_authorized_keys(const char *filename, struct passwd *pw)\n{\n\tchar *file, uidstr[32], ret[PATH_MAX];\n\tint i;\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tfile = percent_expand(filename, \"h\", pw->pw_dir,\n\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\n\t \n\tif (path_absolute(file))\n\t\treturn (file);\n\n\ti = snprintf(ret, sizeof(ret), \"%s/%s\", pw->pw_dir, file);\n\tif (i < 0 || (size_t)i >= sizeof(ret))\n\t\tfatal(\"expand_authorized_keys: path too long\");\n\tfree(file);\n\treturn (xstrdup(ret));\n}\n\nchar *\nauthorized_principals_file(struct passwd *pw)\n{\n\tif (options.authorized_principals_file == NULL)\n\t\treturn NULL;\n\treturn expand_authorized_keys(options.authorized_principals_file, pw);\n}\n\n \nHostStatus\ncheck_key_in_hostfiles(struct passwd *pw, struct sshkey *key, const char *host,\n    const char *sysfile, const char *userfile)\n{\n\tchar *user_hostfile;\n\tstruct stat st;\n\tHostStatus host_status;\n\tstruct hostkeys *hostkeys;\n\tconst struct hostkey_entry *found;\n\n\thostkeys = init_hostkeys();\n\tload_hostkeys(hostkeys, host, sysfile, 0);\n\tif (userfile != NULL) {\n\t\tuser_hostfile = tilde_expand_filename(userfile, pw->pw_uid);\n\t\tif (options.strict_modes &&\n\t\t    (stat(user_hostfile, &st) == 0) &&\n\t\t    ((st.st_uid != 0 && st.st_uid != pw->pw_uid) ||\n\t\t    (st.st_mode & 022) != 0)) {\n\t\t\tlogit(\"Authentication refused for %.100s: \"\n\t\t\t    \"bad owner or modes for %.200s\",\n\t\t\t    pw->pw_name, user_hostfile);\n\t\t\tauth_debug_add(\"Ignored %.200s: bad ownership or modes\",\n\t\t\t    user_hostfile);\n\t\t} else {\n\t\t\ttemporarily_use_uid(pw);\n\t\t\tload_hostkeys(hostkeys, host, user_hostfile, 0);\n\t\t\trestore_uid();\n\t\t}\n\t\tfree(user_hostfile);\n\t}\n\thost_status = check_key_in_hostkeys(hostkeys, key, &found);\n\tif (host_status == HOST_REVOKED)\n\t\terror(\"WARNING: revoked key for %s attempted authentication\",\n\t\t    host);\n\telse if (host_status == HOST_OK)\n\t\tdebug_f(\"key for %s found at %s:%ld\",\n\t\t    found->host, found->file, found->line);\n\telse\n\t\tdebug_f(\"key for host %s not found\", host);\n\n\tfree_hostkeys(hostkeys);\n\n\treturn host_status;\n}\n\nstruct passwd *\ngetpwnamallow(struct ssh *ssh, const char *user)\n{\n#ifdef HAVE_LOGIN_CAP\n\textern login_cap_t *lc;\n#ifdef BSD_AUTH\n\tauth_session_t *as;\n#endif\n#endif\n\tstruct passwd *pw;\n\tstruct connection_info *ci;\n\tu_int i;\n\n\tci = get_connection_info(ssh, 1, options.use_dns);\n\tci->user = user;\n\tparse_server_match_config(&options, &includes, ci);\n\tlog_change_level(options.log_level);\n\tlog_verbose_reset();\n\tfor (i = 0; i < options.num_log_verbose; i++)\n\t\tlog_verbose_add(options.log_verbose[i]);\n\tprocess_permitopen(ssh, &options);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_setauthdb(user);\n#endif\n\n\tpw = getpwnam(user);\n\n#if defined(_AIX) && defined(HAVE_SETAUTHDB)\n\taix_restoreauthdb();\n#endif\n\tif (pw == NULL) {\n\t\tlogit(\"Invalid user %.100s from %.100s port %d\",\n\t\t    user, ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n#ifdef CUSTOM_FAILED_LOGIN\n\t\trecord_failed_login(ssh, user,\n\t\t    auth_get_canonical_hostname(ssh, options.use_dns), \"ssh\");\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\t\taudit_event(ssh, SSH_INVALID_USER);\n#endif  \n\t\treturn (NULL);\n\t}\n\tif (!allowed_user(ssh, pw))\n\t\treturn (NULL);\n#ifdef HAVE_LOGIN_CAP\n\tif ((lc = login_getpwclass(pw)) == NULL) {\n\t\tdebug(\"unable to get login class: %s\", user);\n\t\treturn (NULL);\n\t}\n#ifdef BSD_AUTH\n\tif ((as = auth_open()) == NULL || auth_setpwd(as, pw) != 0 ||\n\t    auth_approval(as, lc, pw->pw_name, \"ssh\") <= 0) {\n\t\tdebug(\"Approval failure for %s\", user);\n\t\tpw = NULL;\n\t}\n\tif (as != NULL)\n\t\tauth_close(as);\n#endif\n#endif\n\tif (pw != NULL)\n\t\treturn (pwcopy(pw));\n\treturn (NULL);\n}\n\n \nint\nauth_key_is_revoked(struct sshkey *key)\n{\n\tchar *fp = NULL;\n\tint r;\n\n\tif (options.revoked_keys_file == NULL)\n\t\treturn 0;\n\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\terror_fr(r, \"fingerprint key\");\n\t\tgoto out;\n\t}\n\n\tr = sshkey_check_revoked(key, options.revoked_keys_file);\n\tswitch (r) {\n\tcase 0:\n\t\tbreak;  \n\tcase SSH_ERR_KEY_REVOKED:\n\t\terror(\"Authentication key %s %s revoked by file %s\",\n\t\t    sshkey_type(key), fp, options.revoked_keys_file);\n\t\tgoto out;\n\tdefault:\n\t\terror_r(r, \"Error checking authentication key %s %s in \"\n\t\t    \"revoked keys file %s\", sshkey_type(key), fp,\n\t\t    options.revoked_keys_file);\n\t\tgoto out;\n\t}\n\n\t \n\tr = 0;\n\n out:\n\tfree(fp);\n\treturn r == 0 ? 0 : 1;\n}\n\nvoid\nauth_debug_add(const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tdebug3(\"%s\", buf);\n\tif (auth_debug != NULL)\n\t\tif ((r = sshbuf_put_cstring(auth_debug, buf)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_put_cstring\");\n}\n\nvoid\nauth_debug_send(struct ssh *ssh)\n{\n\tchar *msg;\n\tint r;\n\n\tif (auth_debug == NULL)\n\t\treturn;\n\twhile (sshbuf_len(auth_debug) != 0) {\n\t\tif ((r = sshbuf_get_cstring(auth_debug, &msg, NULL)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_get_cstring\");\n\t\tssh_packet_send_debug(ssh, \"%s\", msg);\n\t\tfree(msg);\n\t}\n}\n\nvoid\nauth_debug_reset(void)\n{\n\tif (auth_debug != NULL)\n\t\tsshbuf_reset(auth_debug);\n\telse if ((auth_debug = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n}\n\nstruct passwd *\nfakepw(void)\n{\n\tstatic int done = 0;\n\tstatic struct passwd fake;\n\tconst char hashchars[] = \"./ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t    \"abcdefghijklmnopqrstuvwxyz0123456789\";  \n\tchar *cp;\n\n\tif (done)\n\t\treturn (&fake);\n\n\tmemset(&fake, 0, sizeof(fake));\n\tfake.pw_name = \"NOUSER\";\n\tfake.pw_passwd = xstrdup(\"$2a$10$\"\n\t    \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n\tfor (cp = fake.pw_passwd + 7; *cp != '\\0'; cp++)\n\t\t*cp = hashchars[arc4random_uniform(sizeof(hashchars) - 1)];\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\tfake.pw_gecos = \"NOUSER\";\n#endif\n\tfake.pw_uid = privsep_pw == NULL ? (uid_t)-1 : privsep_pw->pw_uid;\n\tfake.pw_gid = privsep_pw == NULL ? (gid_t)-1 : privsep_pw->pw_gid;\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\tfake.pw_class = \"\";\n#endif\n\tfake.pw_dir = \"/nonexist\";\n\tfake.pw_shell = \"/nonexist\";\n\tdone = 1;\n\n\treturn (&fake);\n}\n\n \n\nstatic char *\nremote_hostname(struct ssh *ssh)\n{\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen;\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar name[NI_MAXHOST], ntop2[NI_MAXHOST];\n\tconst char *ntop = ssh_remote_ipaddr(ssh);\n\n\t \n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t    (struct sockaddr *)&from, &fromlen) == -1) {\n\t\tdebug(\"getpeername failed: %.100s\", strerror(errno));\n\t\treturn xstrdup(ntop);\n\t}\n\n\tipv64_normalise_mapped(&from, &fromlen);\n\tif (from.ss_family == AF_INET6)\n\t\tfromlen = sizeof(struct sockaddr_in6);\n\n\tdebug3(\"Trying to reverse map address %.100s.\", ntop);\n\t \n\tif (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),\n\t    NULL, 0, NI_NAMEREQD) != 0) {\n\t\t \n\t\treturn xstrdup(ntop);\n\t}\n\n\t \n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\t \n\thints.ai_flags = AI_NUMERICHOST;\n\tif (getaddrinfo(name, NULL, &hints, &ai) == 0) {\n\t\tlogit(\"Nasty PTR record \\\"%s\\\" is set up for %s, ignoring\",\n\t\t    name, ntop);\n\t\tfreeaddrinfo(ai);\n\t\treturn xstrdup(ntop);\n\t}\n\n\t \n\tlowercase(name);\n\n\t \n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = from.ss_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (getaddrinfo(name, NULL, &hints, &aitop) != 0) {\n\t\tlogit(\"reverse mapping checking getaddrinfo for %.700s \"\n\t\t    \"[%s] failed.\", name, ntop);\n\t\treturn xstrdup(ntop);\n\t}\n\t \n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,\n\t\t    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&\n\t\t    (strcmp(ntop, ntop2) == 0))\n\t\t\t\tbreak;\n\t}\n\tfreeaddrinfo(aitop);\n\t \n\tif (ai == NULL) {\n\t\t \n\t\tlogit(\"Address %.100s maps to %.600s, but this does not \"\n\t\t    \"map back to the address.\", ntop, name);\n\t\treturn xstrdup(ntop);\n\t}\n\treturn xstrdup(name);\n}\n\n \n\nconst char *\nauth_get_canonical_hostname(struct ssh *ssh, int use_dns)\n{\n\tstatic char *dnsname;\n\n\tif (!use_dns)\n\t\treturn ssh_remote_ipaddr(ssh);\n\telse if (dnsname != NULL)\n\t\treturn dnsname;\n\telse {\n\t\tdnsname = remote_hostname(ssh);\n\t\treturn dnsname;\n\t}\n}\n\n \n\n \nvoid\nauth_log_authopts(const char *loc, const struct sshauthopt *opts, int do_remote)\n{\n\tint do_env = options.permit_user_env && opts->nenv > 0;\n\tint do_permitopen = opts->npermitopen > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_LOCAL) != 0;\n\tint do_permitlisten = opts->npermitlisten > 0 &&\n\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) != 0;\n\tsize_t i;\n\tchar msg[1024], buf[64];\n\n\tsnprintf(buf, sizeof(buf), \"%d\", opts->force_tun_device);\n\t \n\tsnprintf(msg, sizeof(msg), \"key options:%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n\t    opts->permit_agent_forwarding_flag ? \" agent-forwarding\" : \"\",\n\t    opts->force_command == NULL ? \"\" : \" command\",\n\t    do_env ?  \" environment\" : \"\",\n\t    opts->valid_before == 0 ? \"\" : \"expires\",\n\t    opts->no_require_user_presence ? \" no-touch-required\" : \"\",\n\t    do_permitopen ?  \" permitopen\" : \"\",\n\t    do_permitlisten ?  \" permitlisten\" : \"\",\n\t    opts->permit_port_forwarding_flag ? \" port-forwarding\" : \"\",\n\t    opts->cert_principals == NULL ? \"\" : \" principals\",\n\t    opts->permit_pty_flag ? \" pty\" : \"\",\n\t    opts->require_verify ? \" uv\" : \"\",\n\t    opts->force_tun_device == -1 ? \"\" : \" tun=\",\n\t    opts->force_tun_device == -1 ? \"\" : buf,\n\t    opts->permit_user_rc ? \" user-rc\" : \"\",\n\t    opts->permit_x11_forwarding_flag ? \" x11-forwarding\" : \"\");\n\n\tdebug(\"%s: %s\", loc, msg);\n\tif (do_remote)\n\t\tauth_debug_add(\"%s: %s\", loc, msg);\n\n\tif (options.permit_user_env) {\n\t\tfor (i = 0; i < opts->nenv; i++) {\n\t\t\tdebug(\"%s: environment: %s\", loc, opts->env[i]);\n\t\t\tif (do_remote) {\n\t\t\t\tauth_debug_add(\"%s: environment: %s\",\n\t\t\t\t    loc, opts->env[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (opts->valid_before != 0) {\n\t\tformat_absolute_time(opts->valid_before, buf, sizeof(buf));\n\t\tdebug(\"%s: expires at %s\", loc, buf);\n\t}\n\tif (opts->cert_principals != NULL) {\n\t\tdebug(\"%s: authorized principals: \\\"%s\\\"\",\n\t\t    loc, opts->cert_principals);\n\t}\n\tif (opts->force_command != NULL)\n\t\tdebug(\"%s: forced command: \\\"%s\\\"\", loc, opts->force_command);\n\tif (do_permitopen) {\n\t\tfor (i = 0; i < opts->npermitopen; i++) {\n\t\t\tdebug(\"%s: permitted open: %s\",\n\t\t\t    loc, opts->permitopen[i]);\n\t\t}\n\t}\n\tif (do_permitlisten) {\n\t\tfor (i = 0; i < opts->npermitlisten; i++) {\n\t\t\tdebug(\"%s: permitted listen: %s\",\n\t\t\t    loc, opts->permitlisten[i]);\n\t\t}\n\t}\n}\n\n \nint\nauth_activate_options(struct ssh *ssh, struct sshauthopt *opts)\n{\n\tstruct sshauthopt *old = auth_opts;\n\tconst char *emsg = NULL;\n\n\tdebug_f(\"setting new authentication options\");\n\tif ((auth_opts = sshauthopt_merge(old, opts, &emsg)) == NULL) {\n\t\terror(\"Inconsistent authentication options: %s\", emsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nvoid\nauth_restrict_session(struct ssh *ssh)\n{\n\tstruct sshauthopt *restricted;\n\n\tdebug_f(\"restricting session\");\n\n\t \n\tif ((restricted = sshauthopt_new()) == NULL)\n\t\tfatal_f(\"sshauthopt_new failed\");\n\trestricted->permit_pty_flag = 1;\n\trestricted->restricted = 1;\n\n\tif (auth_activate_options(ssh, restricted) != 0)\n\t\tfatal_f(\"failed to restrict session\");\n\tsshauthopt_free(restricted);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}