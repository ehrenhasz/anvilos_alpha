{
  "module_name": "ssh-rsa.c",
  "hash_id": "c12b5fffeabd8b82cc509f703739ec9fd8384172c07f619a3332c671489b06bc",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-rsa.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef WITH_OPENSSL\n\n#include <sys/types.h>\n\n#include <openssl/evp.h>\n#include <openssl/err.h>\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#define SSHKEY_INTERNAL\n#include \"sshkey.h\"\n#include \"digest.h\"\n#include \"log.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\nstatic int openssh_RSA_verify(int, u_char *, size_t, u_char *, size_t, RSA *);\n\nstatic u_int\nssh_rsa_size(const struct sshkey *key)\n{\n\tconst BIGNUM *rsa_n;\n\n\tif (key->rsa == NULL)\n\t\treturn 0;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\treturn BN_num_bits(rsa_n);\n}\n\nstatic int\nssh_rsa_alloc(struct sshkey *k)\n{\n\tif ((k->rsa = RSA_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}\n\nstatic void\nssh_rsa_cleanup(struct sshkey *k)\n{\n\tRSA_free(k->rsa);\n\tk->rsa = NULL;\n}\n\nstatic int\nssh_rsa_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tconst BIGNUM *rsa_e_a, *rsa_n_a;\n\tconst BIGNUM *rsa_e_b, *rsa_n_b;\n\n\tif (a->rsa == NULL || b->rsa == NULL)\n\t\treturn 0;\n\tRSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);\n\tRSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);\n\tif (rsa_e_a == NULL || rsa_e_b == NULL)\n\t\treturn 0;\n\tif (rsa_n_a == NULL || rsa_n_b == NULL)\n\t\treturn 0;\n\tif (BN_cmp(rsa_e_a, rsa_e_b) != 0)\n\t\treturn 0;\n\tif (BN_cmp(rsa_n_a, rsa_n_b) != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nssh_rsa_serialize_public(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\tconst BIGNUM *rsa_n, *rsa_e;\n\n\tif (key->rsa == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);\n\tif ((r = sshbuf_put_bignum2(b, rsa_e)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, rsa_n)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_rsa_serialize_private(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\tconst BIGNUM *rsa_n, *rsa_e, *rsa_d, *rsa_iqmp, *rsa_p, *rsa_q;\n\n\tRSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);\n\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\tRSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);\n\n\tif (!sshkey_is_cert(key)) {\n\t\t \n\t\tif ((r = sshbuf_put_bignum2(b, rsa_n)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(b, rsa_e)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_put_bignum2(b, rsa_d)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, rsa_iqmp)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, rsa_p)) != 0 ||\n\t    (r = sshbuf_put_bignum2(b, rsa_q)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_rsa_generate(struct sshkey *k, int bits)\n{\n\tRSA *private = NULL;\n\tBIGNUM *f4 = NULL;\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (bits < SSH_RSA_MINIMUM_MODULUS_SIZE ||\n\t    bits > SSHBUF_MAX_BIGNUM * 8)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tif ((private = RSA_new()) == NULL || (f4 = BN_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!BN_set_word(f4, RSA_F4) ||\n\t    !RSA_generate_key_ex(private, bits, f4, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tk->rsa = private;\n\tprivate = NULL;\n\tret = 0;\n out:\n\tRSA_free(private);\n\tBN_free(f4);\n\treturn ret;\n}\n\nstatic int\nssh_rsa_copy_public(const struct sshkey *from, struct sshkey *to)\n{\n\tconst BIGNUM *rsa_n, *rsa_e;\n\tBIGNUM *rsa_n_dup = NULL, *rsa_e_dup = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tRSA_get0_key(from->rsa, &rsa_n, &rsa_e, NULL);\n\tif ((rsa_n_dup = BN_dup(rsa_n)) == NULL ||\n\t    (rsa_e_dup = BN_dup(rsa_e)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_key(to->rsa, rsa_n_dup, rsa_e_dup, NULL)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_n_dup = rsa_e_dup = NULL;  \n\t \n\tr = 0;\n out:\n\tBN_clear_free(rsa_n_dup);\n\tBN_clear_free(rsa_e_dup);\n\treturn r;\n}\n\nstatic int\nssh_rsa_deserialize_public(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint ret = SSH_ERR_INTERNAL_ERROR;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL;\n\n\tif (sshbuf_get_bignum2(b, &rsa_e) != 0 ||\n\t    sshbuf_get_bignum2(b, &rsa_n) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_n = rsa_e = NULL;  \n\tif ((ret = sshkey_check_rsa_length(key, 0)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tRSA_print_fp(stderr, key->rsa, 8);\n#endif\n\t \n\tret = 0;\n out:\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\treturn ret;\n}\n\nstatic int\nssh_rsa_deserialize_private(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_iqmp = NULL, *rsa_p = NULL, *rsa_q = NULL;\n\n\t \n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = sshbuf_get_bignum2(b, &rsa_n)) != 0 ||\n\t\t    (r = sshbuf_get_bignum2(b, &rsa_e)) != 0)\n\t\t\tgoto out;\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, NULL)) {\n\t\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\trsa_n = rsa_e = NULL;  \n\t}\n\tif ((r = sshbuf_get_bignum2(b, &rsa_d)) != 0 ||\n\t    (r = sshbuf_get_bignum2(b, &rsa_iqmp)) != 0 ||\n\t    (r = sshbuf_get_bignum2(b, &rsa_p)) != 0 ||\n\t    (r = sshbuf_get_bignum2(b, &rsa_q)) != 0)\n\t\tgoto out;\n\tif (!RSA_set0_key(key->rsa, NULL, NULL, rsa_d)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_d = NULL;  \n\tif (!RSA_set0_factors(key->rsa, rsa_p, rsa_q)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_p = rsa_q = NULL;  \n\tif ((r = sshkey_check_rsa_length(key, 0)) != 0)\n\t\tgoto out;\n\tif ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)\n\t\tgoto out;\n\tif (RSA_blinding_on(key->rsa, NULL) != 1) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tBN_clear_free(rsa_n);\n\tBN_clear_free(rsa_e);\n\tBN_clear_free(rsa_d);\n\tBN_clear_free(rsa_p);\n\tBN_clear_free(rsa_q);\n\tBN_clear_free(rsa_iqmp);\n\treturn r;\n}\n\nstatic const char *\nrsa_hash_alg_ident(int hash_alg)\n{\n\tswitch (hash_alg) {\n\tcase SSH_DIGEST_SHA1:\n\t\treturn \"ssh-rsa\";\n\tcase SSH_DIGEST_SHA256:\n\t\treturn \"rsa-sha2-256\";\n\tcase SSH_DIGEST_SHA512:\n\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}\n\n \nstatic int\nrsa_hash_id_from_ident(const char *ident)\n{\n\tif (strcmp(ident, \"ssh-rsa\") == 0)\n\t\treturn SSH_DIGEST_SHA1;\n\tif (strcmp(ident, \"rsa-sha2-256\") == 0)\n\t\treturn SSH_DIGEST_SHA256;\n\tif (strcmp(ident, \"rsa-sha2-512\") == 0)\n\t\treturn SSH_DIGEST_SHA512;\n\treturn -1;\n}\n\n \nstatic int\nrsa_hash_id_from_keyname(const char *alg)\n{\n\tint r;\n\n\tif ((r = rsa_hash_id_from_ident(alg)) != -1)\n\t\treturn r;\n\tif (strcmp(alg, \"ssh-rsa-cert-v01@openssh.com\") == 0)\n\t\treturn SSH_DIGEST_SHA1;\n\tif (strcmp(alg, \"rsa-sha2-256-cert-v01@openssh.com\") == 0)\n\t\treturn SSH_DIGEST_SHA256;\n\tif (strcmp(alg, \"rsa-sha2-512-cert-v01@openssh.com\") == 0)\n\t\treturn SSH_DIGEST_SHA512;\n\treturn -1;\n}\n\nstatic int\nrsa_hash_alg_nid(int type)\n{\n\tswitch (type) {\n\tcase SSH_DIGEST_SHA1:\n\t\treturn NID_sha1;\n\tcase SSH_DIGEST_SHA256:\n\t\treturn NID_sha256;\n\tcase SSH_DIGEST_SHA512:\n\t\treturn NID_sha512;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nint\nssh_rsa_complete_crt_parameters(struct sshkey *key, const BIGNUM *iqmp)\n{\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_d;\n\tBIGNUM *aux = NULL, *d_consttime = NULL;\n\tBIGNUM *rsa_dmq1 = NULL, *rsa_dmp1 = NULL, *rsa_iqmp = NULL;\n\tBN_CTX *ctx = NULL;\n\tint r;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tRSA_get0_key(key->rsa, NULL, NULL, &rsa_d);\n\tRSA_get0_factors(key->rsa, &rsa_p, &rsa_q);\n\n\tif ((ctx = BN_CTX_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((aux = BN_new()) == NULL ||\n\t    (rsa_dmq1 = BN_new()) == NULL ||\n\t    (rsa_dmp1 = BN_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((d_consttime = BN_dup(rsa_d)) == NULL ||\n\t    (rsa_iqmp = BN_dup(iqmp)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tBN_set_flags(aux, BN_FLG_CONSTTIME);\n\tBN_set_flags(d_consttime, BN_FLG_CONSTTIME);\n\n\tif ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmq1, d_consttime, aux, ctx) == 0) ||\n\t    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||\n\t    (BN_mod(rsa_dmp1, d_consttime, aux, ctx) == 0)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (!RSA_set0_crt_params(key->rsa, rsa_dmp1, rsa_dmq1, rsa_iqmp)) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\trsa_dmp1 = rsa_dmq1 = rsa_iqmp = NULL;  \n\t \n\tr = 0;\n out:\n\tBN_clear_free(aux);\n\tBN_clear_free(d_consttime);\n\tBN_clear_free(rsa_dmp1);\n\tBN_clear_free(rsa_dmq1);\n\tBN_clear_free(rsa_iqmp);\n\tBN_CTX_free(ctx);\n\treturn r;\n}\n\n \nstatic int\nssh_rsa_sign(struct sshkey *key,\n    u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\tconst BIGNUM *rsa_n;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *sig = NULL;\n\tsize_t slen = 0;\n\tu_int hlen, len;\n\tint nid, hash_alg, ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL;\n\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\n\tif (alg == NULL || strlen(alg) == 0)\n\t\thash_alg = SSH_DIGEST_SHA1;\n\telse\n\t\thash_alg = rsa_hash_id_from_keyname(alg);\n\tif (key == NULL || key->rsa == NULL || hash_alg == -1 ||\n\t    sshkey_type_plain(key->type) != KEY_RSA)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\tslen = RSA_size(key->rsa);\n\tif (slen <= 0 || slen > SSHBUF_MAX_BIGNUM)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\t \n\tnid = rsa_hash_alg_nid(hash_alg);\n\tif ((hlen = ssh_digest_bytes(hash_alg)) == 0)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif ((ret = ssh_digest_memory(hash_alg, data, datalen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tif ((sig = malloc(slen)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (RSA_sign(nid, digest, hlen, sig, &len, key->rsa) != 1) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tif (len < slen) {\n\t\tsize_t diff = slen - len;\n\t\tmemmove(sig + diff, sig, len);\n\t\texplicit_bzero(sig, diff);\n\t} else if (len > slen) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tif ((b = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((ret = sshbuf_put_cstring(b, rsa_hash_alg_ident(hash_alg))) != 0 ||\n\t    (ret = sshbuf_put_string(b, sig, slen)) != 0)\n\t\tgoto out;\n\tlen = sshbuf_len(b);\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(len)) == NULL) {\n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(b), len);\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = len;\n\tret = 0;\n out:\n\texplicit_bzero(digest, sizeof(digest));\n\tfreezero(sig, slen);\n\tsshbuf_free(b);\n\treturn ret;\n}\n\nstatic int\nssh_rsa_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\tconst BIGNUM *rsa_n;\n\tchar *sigtype = NULL;\n\tint hash_alg, want_alg, ret = SSH_ERR_INTERNAL_ERROR;\n\tsize_t len = 0, diff, modlen, hlen;\n\tstruct sshbuf *b = NULL;\n\tu_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;\n\n\tif (key == NULL || key->rsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_RSA ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tRSA_get0_key(key->rsa, &rsa_n, NULL, NULL);\n\tif (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\treturn SSH_ERR_KEY_LENGTH;\n\n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (sshbuf_get_cstring(b, &sigtype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((hash_alg = rsa_hash_id_from_ident(sigtype)) == -1) {\n\t\tret = SSH_ERR_KEY_TYPE_MISMATCH;\n\t\tgoto out;\n\t}\n\t \n\tif (alg != NULL && strcmp(alg, \"ssh-rsa-cert-v01@openssh.com\") != 0) {\n\t\tif ((want_alg = rsa_hash_id_from_keyname(alg)) == -1) {\n\t\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (hash_alg != want_alg) {\n\t\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sshbuf_get_string(b, &sigblob, &len) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\t \n\tmodlen = RSA_size(key->rsa);\n\tif (len > modlen) {\n\t\tret = SSH_ERR_KEY_BITS_MISMATCH;\n\t\tgoto out;\n\t} else if (len < modlen) {\n\t\tdiff = modlen - len;\n\t\tosigblob = sigblob;\n\t\tif ((sigblob = realloc(sigblob, modlen)) == NULL) {\n\t\t\tsigblob = osigblob;  \n\t\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemmove(sigblob + diff, sigblob, len);\n\t\texplicit_bzero(sigblob, diff);\n\t\tlen = modlen;\n\t}\n\tif ((hlen = ssh_digest_bytes(hash_alg)) == 0) {\n\t\tret = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tif ((ret = ssh_digest_memory(hash_alg, data, dlen,\n\t    digest, sizeof(digest))) != 0)\n\t\tgoto out;\n\n\tret = openssh_RSA_verify(hash_alg, digest, hlen, sigblob, len,\n\t    key->rsa);\n out:\n\tfreezero(sigblob, len);\n\tfree(sigtype);\n\tsshbuf_free(b);\n\texplicit_bzero(digest, sizeof(digest));\n\treturn ret;\n}\n\n \n\n \nstatic const u_char id_sha1[] = {\n\t0x30, 0x21,  \n\t0x30, 0x09,  \n\t0x06, 0x05,  \n\t0x2b, 0x0e, 0x03, 0x02, 0x1a,  \n\t0x05, 0x00,  \n\t0x04, 0x14   \n};\n\n \nstatic const u_char id_sha256[] = {\n\t0x30, 0x31,  \n\t0x30, 0x0d,  \n\t0x06, 0x09,  \n\t0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,  \n\t0x05, 0x00,  \n\t0x04, 0x20   \n};\n\n \nstatic const u_char id_sha512[] = {\n\t0x30, 0x51,  \n\t0x30, 0x0d,  \n\t0x06, 0x09,  \n\t0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03,  \n\t0x05, 0x00,  \n\t0x04, 0x40   \n};\n\nstatic int\nrsa_hash_alg_oid(int hash_alg, const u_char **oidp, size_t *oidlenp)\n{\n\tswitch (hash_alg) {\n\tcase SSH_DIGEST_SHA1:\n\t\t*oidp = id_sha1;\n\t\t*oidlenp = sizeof(id_sha1);\n\t\tbreak;\n\tcase SSH_DIGEST_SHA256:\n\t\t*oidp = id_sha256;\n\t\t*oidlenp = sizeof(id_sha256);\n\t\tbreak;\n\tcase SSH_DIGEST_SHA512:\n\t\t*oidp = id_sha512;\n\t\t*oidlenp = sizeof(id_sha512);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\treturn 0;\n}\n\nstatic int\nopenssh_RSA_verify(int hash_alg, u_char *hash, size_t hashlen,\n    u_char *sigbuf, size_t siglen, RSA *rsa)\n{\n\tsize_t rsasize = 0, oidlen = 0, hlen = 0;\n\tint ret, len, oidmatch, hashmatch;\n\tconst u_char *oid = NULL;\n\tu_char *decrypted = NULL;\n\n\tif ((ret = rsa_hash_alg_oid(hash_alg, &oid, &oidlen)) != 0)\n\t\treturn ret;\n\tret = SSH_ERR_INTERNAL_ERROR;\n\thlen = ssh_digest_bytes(hash_alg);\n\tif (hashlen != hlen) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto done;\n\t}\n\trsasize = RSA_size(rsa);\n\tif (rsasize <= 0 || rsasize > SSHBUF_MAX_BIGNUM ||\n\t    siglen == 0 || siglen > rsasize) {\n\t\tret = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto done;\n\t}\n\tif ((decrypted = malloc(rsasize)) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto done;\n\t}\n\tif ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,\n\t    RSA_PKCS1_PADDING)) < 0) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto done;\n\t}\n\tif (len < 0 || (size_t)len != hlen + oidlen) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto done;\n\t}\n\toidmatch = timingsafe_bcmp(decrypted, oid, oidlen) == 0;\n\thashmatch = timingsafe_bcmp(decrypted + oidlen, hash, hlen) == 0;\n\tif (!oidmatch || !hashmatch) {\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tfreezero(decrypted, rsasize);\n\treturn ret;\n}\n\nstatic const struct sshkey_impl_funcs sshkey_rsa_funcs = {\n\t \t\tssh_rsa_size,\n\t \t\tssh_rsa_alloc,\n\t \tssh_rsa_cleanup,\n\t \t\tssh_rsa_equal,\n\t  ssh_rsa_serialize_public,\n\t  ssh_rsa_deserialize_public,\n\t  ssh_rsa_serialize_private,\n\t  ssh_rsa_deserialize_private,\n\t \tssh_rsa_generate,\n\t \tssh_rsa_copy_public,\n\t \t\tssh_rsa_sign,\n\t \t\tssh_rsa_verify,\n};\n\nconst struct sshkey_impl sshkey_rsa_impl = {\n\t \t\t\"ssh-rsa\",\n\t \t\"RSA\",\n\t \t\tNULL,\n\t \t\tKEY_RSA,\n\t \t\t0,\n\t \t\t0,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_rsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_rsa_cert_impl = {\n\t \t\t\"ssh-rsa-cert-v01@openssh.com\",\n\t \t\"RSA-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_RSA_CERT,\n\t \t\t0,\n\t \t\t1,\n\t \t0,\n\t \t0,\n\t \t\t&sshkey_rsa_funcs,\n};\n\n \n\nconst struct sshkey_impl sshkey_rsa_sha256_impl = {\n\t \t\t\"rsa-sha2-256\",\n\t \t\"RSA\",\n\t \t\tNULL,\n\t \t\tKEY_RSA,\n\t \t\t0,\n\t \t\t0,\n\t \t1,\n\t \t0,\n\t \t\t&sshkey_rsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_rsa_sha512_impl = {\n\t \t\t\"rsa-sha2-512\",\n\t \t\"RSA\",\n\t \t\tNULL,\n\t \t\tKEY_RSA,\n\t \t\t0,\n\t \t\t0,\n\t \t1,\n\t \t0,\n\t \t\t&sshkey_rsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_rsa_sha256_cert_impl = {\n\t \t\t\"rsa-sha2-256-cert-v01@openssh.com\",\n\t \t\"RSA-CERT\",\n\t \t\t\"rsa-sha2-256\",\n\t \t\tKEY_RSA_CERT,\n\t \t\t0,\n\t \t\t1,\n\t \t1,\n\t \t0,\n\t \t\t&sshkey_rsa_funcs,\n};\n\nconst struct sshkey_impl sshkey_rsa_sha512_cert_impl = {\n\t \t\t\"rsa-sha2-512-cert-v01@openssh.com\",\n\t \t\"RSA-CERT\",\n\t \t\t\"rsa-sha2-512\",\n\t \t\tKEY_RSA_CERT,\n\t \t\t0,\n\t \t\t1,\n\t \t1,\n\t \t0,\n\t \t\t&sshkey_rsa_funcs,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}