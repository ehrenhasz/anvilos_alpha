{
  "module_name": "addr.c",
  "hash_id": "a5a3dca694b290e064fa0c10fc97e8bfaad15e27f551952d0db0f2a634f9ad29",
  "original_prompt": "Ingested from openssh-9.6p1/addr.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <netdb.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"addr.h\"\n\n#define _SA(x)\t((struct sockaddr *)(x))\n\nint\naddr_unicast_masklen(int af)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn 32;\n\tcase AF_INET6:\n\t\treturn 128;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nstatic inline int\nmasklen_valid(int af, u_int masklen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn masklen <= 32 ? 0 : -1;\n\tcase AF_INET6:\n\t\treturn masklen <= 128 ? 0 : -1;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nint\naddr_xaddr_to_sa(const struct xaddr *xa, struct sockaddr *sa, socklen_t *len,\n    u_int16_t port)\n{\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)sa;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;\n\n\tif (xa == NULL || sa == NULL || len == NULL)\n\t\treturn -1;\n\n\tswitch (xa->af) {\n\tcase AF_INET:\n\t\tif (*len < sizeof(*in4))\n\t\t\treturn -1;\n\t\tmemset(sa, '\\0', sizeof(*in4));\n\t\t*len = sizeof(*in4);\n#ifdef SOCK_HAS_LEN\n\t\tin4->sin_len = sizeof(*in4);\n#endif\n\t\tin4->sin_family = AF_INET;\n\t\tin4->sin_port = htons(port);\n\t\tmemcpy(&in4->sin_addr, &xa->v4, sizeof(in4->sin_addr));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (*len < sizeof(*in6))\n\t\t\treturn -1;\n\t\tmemset(sa, '\\0', sizeof(*in6));\n\t\t*len = sizeof(*in6);\n#ifdef SOCK_HAS_LEN\n\t\tin6->sin6_len = sizeof(*in6);\n#endif\n\t\tin6->sin6_family = AF_INET6;\n\t\tin6->sin6_port = htons(port);\n\t\tmemcpy(&in6->sin6_addr, &xa->v6, sizeof(in6->sin6_addr));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\t\tin6->sin6_scope_id = xa->scope_id;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint\naddr_sa_to_xaddr(struct sockaddr *sa, socklen_t slen, struct xaddr *xa)\n{\n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)sa;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)sa;\n\n\tmemset(xa, '\\0', sizeof(*xa));\n\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tif (slen < (socklen_t)sizeof(*in4))\n\t\t\treturn -1;\n\t\txa->af = AF_INET;\n\t\tmemcpy(&xa->v4, &in4->sin_addr, sizeof(xa->v4));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (slen < (socklen_t)sizeof(*in6))\n\t\t\treturn -1;\n\t\txa->af = AF_INET6;\n\t\tmemcpy(&xa->v6, &in6->sin6_addr, sizeof(xa->v6));\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\t\txa->scope_id = in6->sin6_scope_id;\n#endif\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint\naddr_invert(struct xaddr *n)\n{\n\tint i;\n\n\tif (n == NULL)\n\t\treturn -1;\n\n\tswitch (n->af) {\n\tcase AF_INET:\n\t\tn->v4.s_addr = ~n->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tn->addr32[i] = ~n->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nint\naddr_netmask(int af, u_int l, struct xaddr *n)\n{\n\tint i;\n\n\tif (masklen_valid(af, l) != 0 || n == NULL)\n\t\treturn -1;\n\n\tmemset(n, '\\0', sizeof(*n));\n\tswitch (af) {\n\tcase AF_INET:\n\t\tn->af = AF_INET;\n\t\tif (l == 0)\n\t\t\treturn 0;\n\t\tn->v4.s_addr = htonl((0xffffffff << (32 - l)) & 0xffffffff);\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tn->af = AF_INET6;\n\t\tfor (i = 0; i < 4 && l >= 32; i++, l -= 32)\n\t\t\tn->addr32[i] = 0xffffffffU;\n\t\tif (i < 4 && l != 0)\n\t\t\tn->addr32[i] = htonl((0xffffffff << (32 - l)) &\n\t\t\t    0xffffffff);\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nint\naddr_hostmask(int af, u_int l, struct xaddr *n)\n{\n\tif (addr_netmask(af, l, n) == -1 || addr_invert(n) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nint\naddr_and(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn -1;\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr &= b->v4.s_addr;\n\t\treturn 0;\n\tcase AF_INET6:\n\t\tdst->scope_id = a->scope_id;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] &= b->addr32[i];\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\nint\naddr_or(struct xaddr *dst, const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (dst == NULL || a == NULL || b == NULL || a->af != b->af)\n\t\treturn (-1);\n\n\tmemcpy(dst, a, sizeof(*dst));\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\tdst->v4.s_addr |= b->v4.s_addr;\n\t\treturn (0);\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdst->addr32[i] |= b->addr32[i];\n\t\treturn (0);\n\tdefault:\n\t\treturn (-1);\n\t}\n}\n\nint\naddr_cmp(const struct xaddr *a, const struct xaddr *b)\n{\n\tint i;\n\n\tif (a->af != b->af)\n\t\treturn (a->af == AF_INET6 ? 1 : -1);\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\t \n\t\tif (a->v4.s_addr == b->v4.s_addr)\n\t\t\treturn 0;\n\t\treturn (ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr) ? 1 : -1);\n\tcase AF_INET6:\n\t\t \n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (a->addr8[i] - b->addr8[i] != 0)\n\t\t\t\treturn (a->addr8[i] - b->addr8[i]);\n\t\tif (a->scope_id == b->scope_id)\n\t\t\treturn (0);\n\t\treturn (a->scope_id > b->scope_id ? 1 : -1);\n\tdefault:\n\t\treturn (-1);\n\t}\n}\n\nint\naddr_is_all0s(const struct xaddr *a)\n{\n\tint i;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\treturn (a->v4.s_addr == 0 ? 0 : -1);\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (a->addr32[i] != 0)\n\t\t\t\treturn -1;\n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nvoid\naddr_increment(struct xaddr *a)\n{\n\tint i;\n\tuint32_t n;\n\n\tswitch (a->af) {\n\tcase AF_INET:\n\t\ta->v4.s_addr = htonl(ntohl(a->v4.s_addr) + 1);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t \n\t\t\tn = ntohl(a->addr32[3 - i]) + 1;\n\t\t\ta->addr32[3 - i] = htonl(n);\n\t\t\tif (n != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nint\naddr_host_is_all0s(const struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_addr, tmp_mask, tmp_result;\n\n\tmemcpy(&tmp_addr, a, sizeof(tmp_addr));\n\tif (addr_hostmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, &tmp_addr, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_is_all0s(&tmp_result);\n}\n\n#if 0\nint\naddr_host_to_all0s(struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_mask;\n\n\tif (addr_netmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn (-1);\n\tif (addr_and(a, a, &tmp_mask) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n#endif\n\nint\naddr_host_to_all1s(struct xaddr *a, u_int masklen)\n{\n\tstruct xaddr tmp_mask;\n\n\tif (addr_hostmask(a->af, masklen, &tmp_mask) == -1)\n\t\treturn (-1);\n\tif (addr_or(a, a, &tmp_mask) == -1)\n\t\treturn (-1);\n\treturn (0);\n}\n\n \nint\naddr_pton(const char *p, struct xaddr *n)\n{\n\tstruct addrinfo hints, *ai;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (p == NULL || getaddrinfo(p, NULL, &hints, &ai) != 0)\n\t\treturn -1;\n\n\tif (ai == NULL)\n\t\treturn -1;\n\n\tif (ai->ai_addr == NULL) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\tif (n != NULL && addr_sa_to_xaddr(ai->ai_addr, ai->ai_addrlen,\n\t    n) == -1) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\tfreeaddrinfo(ai);\n\treturn 0;\n}\n\nint\naddr_sa_pton(const char *h, const char *s, struct sockaddr *sa, socklen_t slen)\n{\n\tstruct addrinfo hints, *ai;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (h == NULL || getaddrinfo(h, s, &hints, &ai) != 0)\n\t\treturn -1;\n\n\tif (ai == NULL)\n\t\treturn -1;\n\n\tif (ai->ai_addr == NULL) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\tif (sa != NULL) {\n\t\tif (slen < ai->ai_addrlen) {\n\t\t\tfreeaddrinfo(ai);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(sa, &ai->ai_addr, ai->ai_addrlen);\n\t}\n\n\tfreeaddrinfo(ai);\n\treturn 0;\n}\n\nint\naddr_ntop(const struct xaddr *n, char *p, size_t len)\n{\n\tstruct sockaddr_storage ss;\n\tsocklen_t slen = sizeof(ss);\n\n\tif (addr_xaddr_to_sa(n, _SA(&ss), &slen, 0) == -1)\n\t\treturn -1;\n\tif (p == NULL || len == 0)\n\t\treturn -1;\n\tif (getnameinfo(_SA(&ss), slen, p, len, NULL, 0,\n\t    NI_NUMERICHOST) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nint\naddr_pton_cidr(const char *p, struct xaddr *n, u_int *l)\n{\n\tstruct xaddr tmp;\n\tlong unsigned int masklen = 999;\n\tchar addrbuf[64], *mp, *cp;\n\n\t \n\tif (p == NULL || strlcpy(addrbuf, p, sizeof(addrbuf)) >= sizeof(addrbuf))\n\t\treturn -1;\n\n\tif ((mp = strchr(addrbuf, '/')) != NULL) {\n\t\t*mp = '\\0';\n\t\tmp++;\n\t\tmasklen = strtoul(mp, &cp, 10);\n\t\tif (*mp < '0' || *mp > '9' || *cp != '\\0' || masklen > 128)\n\t\t\treturn -1;\n\t}\n\n\tif (addr_pton(addrbuf, &tmp) == -1)\n\t\treturn -1;\n\n\tif (mp == NULL)\n\t\tmasklen = addr_unicast_masklen(tmp.af);\n\tif (masklen_valid(tmp.af, masklen) == -1)\n\t\treturn -2;\n\tif (addr_host_is_all0s(&tmp, masklen) != 0)\n\t\treturn -2;\n\n\tif (n != NULL)\n\t\tmemcpy(n, &tmp, sizeof(*n));\n\tif (l != NULL)\n\t\t*l = masklen;\n\n\treturn 0;\n}\n\nint\naddr_netmatch(const struct xaddr *host, const struct xaddr *net, u_int masklen)\n{\n\tstruct xaddr tmp_mask, tmp_result;\n\n\tif (host->af != net->af)\n\t\treturn -1;\n\n\tif (addr_netmask(host->af, masklen, &tmp_mask) == -1)\n\t\treturn -1;\n\tif (addr_and(&tmp_result, host, &tmp_mask) == -1)\n\t\treturn -1;\n\treturn addr_cmp(&tmp_result, net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}