{
  "module_name": "ssh-keysign.c",
  "hash_id": "b6b9b2049a3a11d48ddfbfd0a3f833800dac5337c433bb86b0c79ede7fd2c296",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-keysign.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <fcntl.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#include <pwd.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"sshkey.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"authfile.h\"\n#include \"msg.h\"\n#include \"canohost.h\"\n#include \"pathnames.h\"\n#include \"readconf.h\"\n#include \"uidswap.h\"\n#include \"ssherr.h\"\n\nextern char *__progname;\n\nstatic int\nvalid_request(struct passwd *pw, char *host, struct sshkey **ret, char **pkalgp,\n    u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tu_char type, *pkblob;\n\tchar *p;\n\tsize_t blen, len;\n\tchar *pkalg, *luser;\n\tint r, pktype, fail;\n\n\tif (ret != NULL)\n\t\t*ret = NULL;\n\tif (pkalgp != NULL)\n\t\t*pkalgp = NULL;\n\tfail = 0;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal_f(\"sshbuf_from failed\");\n\n\t \n\tif ((r = sshbuf_get_string(b, NULL, &len)) != 0)\n\t\tfatal_fr(r, \"parse session ID\");\n\tif (len != 20 &&  \n\t    len != 32 &&  \n\t    len != 48 &&  \n\t    len != 64)    \n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\n\t \n\tif ((r = sshbuf_skip_string(b)) != 0)\n\t\tfatal_fr(r, \"parse user\");\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal_fr(r, \"parse service\");\n\tif (strcmp(\"ssh-connection\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &p, NULL)) != 0)\n\t\tfatal_fr(r, \"parse method\");\n\tif (strcmp(\"hostbased\", p) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||\n\t    (r = sshbuf_get_string(b, &pkblob, &blen)) != 0)\n\t\tfatal_fr(r, \"parse pk\");\n\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC)\n\t\tfail++;\n\telse if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror_fr(r, \"decode key\");\n\t\tfail++;\n\t} else if (key->type != pktype)\n\t\tfail++;\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &p, &len)) != 0)\n\t\tfatal_fr(r, \"parse hostname\");\n\tdebug2_f(\"check expect chost %s got %s\", host, p);\n\tif (strlen(host) != len - 1)\n\t\tfail++;\n\telse if (p[len - 1] != '.')\n\t\tfail++;\n\telse if (strncasecmp(host, p, len - 1) != 0)\n\t\tfail++;\n\tfree(p);\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &luser, NULL)) != 0)\n\t\tfatal_fr(r, \"parse luser\");\n\n\tif (strcmp(pw->pw_name, luser) != 0)\n\t\tfail++;\n\tfree(luser);\n\n\t \n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\n\tdebug3_f(\"fail %d\", fail);\n\n\tif (!fail) {\n\t\tif (ret != NULL) {\n\t\t\t*ret = key;\n\t\t\tkey = NULL;\n\t\t}\n\t\tif (pkalgp != NULL) {\n\t\t\t*pkalgp = pkalg;\n\t\t\tpkalg = NULL;\n\t\t}\n\t}\n\tsshkey_free(key);\n\tfree(pkalg);\n\tfree(pkblob);\n\n\treturn (fail ? -1 : 0);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tstruct sshbuf *b;\n\tOptions options;\n#define NUM_KEYTYPES 5\n\tstruct sshkey *keys[NUM_KEYTYPES], *key = NULL;\n\tstruct passwd *pw;\n\tint r, key_fd[NUM_KEYTYPES], i, found, version = 2, fd;\n\tu_char *signature, *data, rver;\n\tchar *host, *fp, *pkalg;\n\tsize_t slen, dlen;\n\n\tif (pledge(\"stdio rpath getpw dns id\", NULL) != 0)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\t \n\tif ((fd = open(_PATH_DEVNULL, O_RDWR)) < 2)\n\t\texit(1);\n\t \n\tif (fd > 2)\n\t\tclose(fd);\n\n\ti = 0;\n\t \n\tkey_fd[i++] = open(_PATH_HOST_DSA_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_ECDSA_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_ED25519_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_XMSS_KEY_FILE, O_RDONLY);\n\tkey_fd[i++] = open(_PATH_HOST_RSA_KEY_FILE, O_RDONLY);\n\n\tif ((pw = getpwuid(getuid())) == NULL)\n\t\tfatal(\"getpwuid failed\");\n\tpw = pwcopy(pw);\n\n\tpermanently_set_uid(pw);\n\n\tseed_rng();\n\n#ifdef DEBUG_SSH_KEYSIGN\n\tlog_init(\"ssh-keysign\", SYSLOG_LEVEL_DEBUG3, SYSLOG_FACILITY_AUTH, 0);\n#endif\n\n\t \n\tinitialize_options(&options);\n\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw, \"\", \"\",\n\t    &options, 0, NULL);\n\t(void)fill_default_options(&options);\n\tif (options.enable_ssh_keysign != 1)\n\t\tfatal(\"ssh-keysign not enabled in %s\",\n\t\t    _PATH_HOST_CONFIG_FILE);\n\n\tif (pledge(\"stdio dns\", NULL) != 0)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\tfor (i = found = 0; i < NUM_KEYTYPES; i++) {\n\t\tif (key_fd[i] != -1)\n\t\t\tfound = 1;\n\t}\n\tif (found == 0)\n\t\tfatal(\"could not open any host key\");\n\n\tfound = 0;\n\tfor (i = 0; i < NUM_KEYTYPES; i++) {\n\t\tkeys[i] = NULL;\n\t\tif (key_fd[i] == -1)\n\t\t\tcontinue;\n\t\tr = sshkey_load_private_type_fd(key_fd[i], KEY_UNSPEC,\n\t\t    NULL, &key, NULL);\n\t\tclose(key_fd[i]);\n\t\tif (r != 0)\n\t\t\tdebug_r(r, \"parse key %d\", i);\n\t\telse if (key != NULL) {\n\t\t\tkeys[i] = key;\n\t\t\tfound = 1;\n\t\t}\n\t}\n\tif (!found)\n\t\tfatal(\"no hostkey found\");\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\tif (ssh_msg_recv(STDIN_FILENO, b) < 0)\n\t\tfatal(\"%s: ssh_msg_recv failed\", __progname);\n\tif ((r = sshbuf_get_u8(b, &rver)) != 0)\n\t\tfatal_r(r, \"%s: buffer error\", __progname);\n\tif (rver != version)\n\t\tfatal(\"%s: bad version: received %d, expected %d\",\n\t\t    __progname, rver, version);\n\tif ((r = sshbuf_get_u32(b, (u_int *)&fd)) != 0)\n\t\tfatal_r(r, \"%s: buffer error\", __progname);\n\tif (fd < 0 || fd == STDIN_FILENO || fd == STDOUT_FILENO)\n\t\tfatal(\"%s: bad fd = %d\", __progname, fd);\n\tif ((host = get_local_name(fd)) == NULL)\n\t\tfatal(\"%s: cannot get local name for fd\", __progname);\n\n\tif ((r = sshbuf_get_string(b, &data, &dlen)) != 0)\n\t\tfatal_r(r, \"%s: buffer error\", __progname);\n\tif (valid_request(pw, host, &key, &pkalg, data, dlen) < 0)\n\t\tfatal(\"%s: not a valid request\", __progname);\n\tfree(host);\n\n\tfound = 0;\n\tfor (i = 0; i < NUM_KEYTYPES; i++) {\n\t\tif (keys[i] != NULL &&\n\t\t    sshkey_equal_public(key, keys[i])) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal(\"%s: sshkey_fingerprint failed\", __progname);\n\t\tfatal(\"%s: no matching hostkey found for key %s %s\", __progname,\n\t\t    sshkey_type(key), fp ? fp : \"\");\n\t}\n\n\tif ((r = sshkey_sign(keys[i], &signature, &slen, data, dlen,\n\t    pkalg, NULL, NULL, 0)) != 0)\n\t\tfatal_r(r, \"%s: sshkey_sign failed\", __progname);\n\tfree(data);\n\n\t \n\tsshbuf_reset(b);\n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal_r(r, \"%s: buffer error\", __progname);\n\tif (ssh_msg_send(STDOUT_FILENO, version, b) == -1)\n\t\tfatal(\"%s: ssh_msg_send failed\", __progname);\n\n\treturn (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}