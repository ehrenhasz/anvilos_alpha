{
  "module_name": "xmss_fast.c",
  "hash_id": "f872e6202b765c37ac32aef923ba22979949b771f3e7151093c8e9a1383dbc61",
  "original_prompt": "Ingested from openssh-9.6p1/xmss_fast.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n#ifdef WITH_XMSS\n\n#include <stdlib.h>\n#include <string.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n\n#include \"xmss_fast.h\"\n#include \"crypto_api.h\"\n#include \"xmss_wots.h\"\n#include \"xmss_hash.h\"\n\n#include \"xmss_commons.h\"\n#include \"xmss_hash_address.h\"\n\n#include \"stdio.h\"\n\n\n\n \nstatic void get_seed(unsigned char *seed, const unsigned char *sk_seed, int n, uint32_t addr[8])\n{\n  unsigned char bytes[32];\n  \n  setChainADRS(addr,0);\n  setHashADRS(addr,0);\n  setKeyAndMask(addr,0);\n  \n  addr_to_byte(bytes, addr);\n  prf(seed, bytes, sk_seed, n);\n}\n\n \nint xmss_set_params(xmss_params *params, int n, int h, int w, int k)\n{\n  if (k >= h || k < 2 || (h - k) % 2) {\n    fprintf(stderr, \"For BDS traversal, H - K must be even, with H > K >= 2!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->n = n;\n  params->k = k;\n  wots_params wots_par;\n  wots_set_params(&wots_par, n, w);\n  params->wots_par = wots_par;\n  return 0;\n}\n\n \nvoid xmss_set_bds_state(bds_state *state, unsigned char *stack, int stackoffset, unsigned char *stacklevels, unsigned char *auth, unsigned char *keep, treehash_inst *treehash, unsigned char *retain, int next_leaf)\n{\n  state->stack = stack;\n  state->stackoffset = stackoffset;\n  state->stacklevels = stacklevels;\n  state->auth = auth;\n  state->keep = keep;\n  state->treehash = treehash;\n  state->retain = retain;\n  state->next_leaf = next_leaf;\n}\n\n \nint xmssmt_set_params(xmssmt_params *params, int n, int h, int d, int w, int k)\n{\n  if (h % d) {\n    fprintf(stderr, \"d must divide h without remainder!\\n\");\n    return 1;\n  }\n  params->h = h;\n  params->d = d;\n  params->n = n;\n  params->index_len = (h + 7) / 8;\n  xmss_params xmss_par;\n  if (xmss_set_params(&xmss_par, n, (h/d), w, k)) {\n    return 1;\n  }\n  params->xmss_par = xmss_par;\n  return 0;\n}\n\n \nstatic void l_tree(unsigned char *leaf, unsigned char *wots_pk, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int l = params->wots_par.len;\n  unsigned int n = params->n;\n  uint32_t i = 0;\n  uint32_t height = 0;\n  uint32_t bound;\n\n  \n  setTreeHeight(addr, height);\n  \n  while (l > 1) {\n     bound = l >> 1; \n     for (i = 0; i < bound; i++) {\n       \n       setTreeIndex(addr, i);\n       \n       hash_h(wots_pk+i*n, wots_pk+i*2*n, pub_seed, addr, n);\n     }\n     \n     if (l & 1) {\n       \n       memcpy(wots_pk+(l>>1)*n, wots_pk+(l-1)*n, n);\n       \n       l=(l>>1)+1;\n     }\n     else {\n       \n       l=(l>>1);\n     }\n     \n     height++;\n     setTreeHeight(addr, height);\n   }\n   \n   memcpy(leaf, wots_pk, n);\n}\n\n \nstatic void gen_leaf_wots(unsigned char *leaf, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, uint32_t ltree_addr[8], uint32_t ots_addr[8])\n{\n  unsigned char seed[params->n];\n  unsigned char pk[params->wots_par.keysize];\n\n  get_seed(seed, sk_seed, params->n, ots_addr);\n  wots_pkgen(pk, seed, &(params->wots_par), pub_seed, ots_addr);\n\n  l_tree(leaf, pk, params, pub_seed, ltree_addr);\n}\n\nstatic int treehash_minheight_on_stack(bds_state* state, const xmss_params *params, const treehash_inst *treehash) {\n  unsigned int r = params->h, i;\n  for (i = 0; i < treehash->stackusage; i++) {\n    if (state->stacklevels[state->stackoffset - i - 1] < r) {\n      r = state->stacklevels[state->stackoffset - i - 1];\n    }\n  }\n  return r;\n}\n\n \nstatic void treehash_setup(unsigned char *node, int height, int index, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8])\n{\n  unsigned int idx = index;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n   \n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n   \n  memcpy(ots_addr, addr, 12);\n   \n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  uint32_t lastnode, i;\n  unsigned char stack[(height+1)*n];\n  unsigned int stacklevels[height+1];\n  unsigned int stackoffset=0;\n  unsigned int nodeh;\n\n  lastnode = idx+(1<<height);\n\n  for (i = 0; i < h-k; i++) {\n    state->treehash[i].h = i;\n    state->treehash[i].completed = 1;\n    state->treehash[i].stackusage = 0;\n  }\n\n  i = 0;\n  for (; idx < lastnode; idx++) {\n    setLtreeADRS(ltree_addr, idx);\n    setOTSADRS(ots_addr, idx);\n    gen_leaf_wots(stack+stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n    stacklevels[stackoffset] = 0;\n    stackoffset++;\n    if (h - k > 0 && i == 3) {\n      memcpy(state->treehash[0].node, stack+stackoffset*n, n);\n    }\n    while (stackoffset>1 && stacklevels[stackoffset-1] == stacklevels[stackoffset-2])\n    {\n      nodeh = stacklevels[stackoffset-1];\n      if (i >> nodeh == 1) {\n        memcpy(state->auth + nodeh*n, stack+(stackoffset-1)*n, n);\n      }\n      else {\n        if (nodeh < h - k && i >> nodeh == 3) {\n          memcpy(state->treehash[nodeh].node, stack+(stackoffset-1)*n, n);\n        }\n        else if (nodeh >= h - k) {\n          memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((i >> nodeh) - 3) >> 1)) * n, stack+(stackoffset-1)*n, n);\n        }\n      }\n      setTreeHeight(node_addr, stacklevels[stackoffset-1]);\n      setTreeIndex(node_addr, (idx >> (stacklevels[stackoffset-1]+1)));\n      hash_h(stack+(stackoffset-2)*n, stack+(stackoffset-2)*n, pub_seed,\n          node_addr, n);\n      stacklevels[stackoffset-2]++;\n      stackoffset--;\n    }\n    i++;\n  }\n\n  for (i = 0; i < n; i++)\n    node[i] = stack[i];\n}\n\nstatic void treehash_update(treehash_inst *treehash, bds_state *state, const unsigned char *sk_seed, const xmss_params *params, const unsigned char *pub_seed, const uint32_t addr[8]) {\n  int n = params->n;\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n   \n  memcpy(ots_addr, addr, 12);\n   \n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  setLtreeADRS(ltree_addr, treehash->next_idx);\n  setOTSADRS(ots_addr, treehash->next_idx);\n\n  unsigned char nodebuffer[2 * n];\n  unsigned int nodeheight = 0;\n  gen_leaf_wots(nodebuffer, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  while (treehash->stackusage > 0 && state->stacklevels[state->stackoffset-1] == nodeheight) {\n    memcpy(nodebuffer + n, nodebuffer, n);\n    memcpy(nodebuffer, state->stack + (state->stackoffset-1)*n, n);\n    setTreeHeight(node_addr, nodeheight);\n    setTreeIndex(node_addr, (treehash->next_idx >> (nodeheight+1)));\n    hash_h(nodebuffer, nodebuffer, pub_seed, node_addr, n);\n    nodeheight++;\n    treehash->stackusage--;\n    state->stackoffset--;\n  }\n  if (nodeheight == treehash->h) {  \n    memcpy(treehash->node, nodebuffer, n);\n    treehash->completed = 1;\n  }\n  else {\n    memcpy(state->stack + state->stackoffset*n, nodebuffer, n);\n    treehash->stackusage++;\n    state->stacklevels[state->stackoffset] = nodeheight;\n    state->stackoffset++;\n    treehash->next_idx++;\n  }\n}\n\n \nstatic void validate_authpath(unsigned char *root, const unsigned char *leaf, unsigned long leafidx, const unsigned char *authpath, const xmss_params *params, const unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int n = params->n;\n\n  uint32_t i, j;\n  unsigned char buffer[2*n];\n\n   \n   \n  if (leafidx & 1) {\n    for (j = 0; j < n; j++)\n      buffer[n+j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[j] = authpath[j];\n  }\n  else {\n    for (j = 0; j < n; j++)\n      buffer[j] = leaf[j];\n    for (j = 0; j < n; j++)\n      buffer[n+j] = authpath[j];\n  }\n  authpath += n;\n\n  for (i=0; i < params->h-1; i++) {\n    setTreeHeight(addr, i);\n    leafidx >>= 1;\n    setTreeIndex(addr, leafidx);\n    if (leafidx&1) {\n      hash_h(buffer+n, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j] = authpath[j];\n    }\n    else {\n      hash_h(buffer, buffer, pub_seed, addr, n);\n      for (j = 0; j < n; j++)\n        buffer[j+n] = authpath[j];\n    }\n    authpath += n;\n  }\n  setTreeHeight(addr, (params->h-1));\n  leafidx >>= 1;\n  setTreeIndex(addr, leafidx);\n  hash_h(root, buffer, pub_seed, addr, n);\n}\n\n \nstatic char bds_treehash_update(bds_state *state, unsigned int updates, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t i, j;\n  unsigned int level, l_min, low;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n  unsigned int used = 0;\n\n  for (j = 0; j < updates; j++) {\n    l_min = h;\n    level = h - k;\n    for (i = 0; i < h - k; i++) {\n      if (state->treehash[i].completed) {\n        low = h;\n      }\n      else if (state->treehash[i].stackusage == 0) {\n        low = i;\n      }\n      else {\n        low = treehash_minheight_on_stack(state, params, &(state->treehash[i]));\n      }\n      if (low < l_min) {\n        level = i;\n        l_min = low;\n      }\n    }\n    if (level == h - k) {\n      break;\n    }\n    treehash_update(&(state->treehash[level]), state, sk_seed, params, pub_seed, addr);\n    used++;\n  }\n  return updates - used;\n}\n\n \nstatic char bds_state_update(bds_state *state, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, const uint32_t addr[8]) {\n  uint32_t ltree_addr[8];\n  uint32_t node_addr[8];\n  uint32_t ots_addr[8];\n\n  int n = params->n;\n  int h = params->h;\n  int k = params->k;\n\n  int nodeh;\n  int idx = state->next_leaf;\n  if (idx == 1 << h) {\n    return 1;\n  }\n\n   \n  memcpy(ots_addr, addr, 12);\n   \n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx);\n  setLtreeADRS(ltree_addr, idx);\n\n  gen_leaf_wots(state->stack+state->stackoffset*n, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n\n  state->stacklevels[state->stackoffset] = 0;\n  state->stackoffset++;\n  if (h - k > 0 && idx == 3) {\n    memcpy(state->treehash[0].node, state->stack+state->stackoffset*n, n);\n  }\n  while (state->stackoffset>1 && state->stacklevels[state->stackoffset-1] == state->stacklevels[state->stackoffset-2]) {\n    nodeh = state->stacklevels[state->stackoffset-1];\n    if (idx >> nodeh == 1) {\n      memcpy(state->auth + nodeh*n, state->stack+(state->stackoffset-1)*n, n);\n    }\n    else {\n      if (nodeh < h - k && idx >> nodeh == 3) {\n        memcpy(state->treehash[nodeh].node, state->stack+(state->stackoffset-1)*n, n);\n      }\n      else if (nodeh >= h - k) {\n        memcpy(state->retain + ((1 << (h - 1 - nodeh)) + nodeh - h + (((idx >> nodeh) - 3) >> 1)) * n, state->stack+(state->stackoffset-1)*n, n);\n      }\n    }\n    setTreeHeight(node_addr, state->stacklevels[state->stackoffset-1]);\n    setTreeIndex(node_addr, (idx >> (state->stacklevels[state->stackoffset-1]+1)));\n    hash_h(state->stack+(state->stackoffset-2)*n, state->stack+(state->stackoffset-2)*n, pub_seed, node_addr, n);\n\n    state->stacklevels[state->stackoffset-2]++;\n    state->stackoffset--;\n  }\n  state->next_leaf++;\n  return 0;\n}\n\n \nstatic void bds_round(bds_state *state, const unsigned long leaf_idx, const unsigned char *sk_seed, const xmss_params *params, unsigned char *pub_seed, uint32_t addr[8])\n{\n  unsigned int i;\n  unsigned int n = params->n;\n  unsigned int h = params->h;\n  unsigned int k = params->k;\n\n  unsigned int tau = h;\n  unsigned int startidx;\n  unsigned int offset, rowidx;\n  unsigned char buf[2 * n];\n\n  uint32_t ots_addr[8];\n  uint32_t ltree_addr[8];\n  uint32_t  node_addr[8];\n   \n  memcpy(ots_addr, addr, 12);\n   \n  setType(ots_addr, 0);\n  memcpy(ltree_addr, addr, 12);\n  setType(ltree_addr, 1);\n  memcpy(node_addr, addr, 12);\n  setType(node_addr, 2);\n\n  for (i = 0; i < h; i++) {\n    if (! ((leaf_idx >> i) & 1)) {\n      tau = i;\n      break;\n    }\n  }\n\n  if (tau > 0) {\n    memcpy(buf,     state->auth + (tau-1) * n, n);\n     \n    memcpy(buf + n, state->keep + ((tau-1) >> 1) * n, n);\n  }\n  if (!((leaf_idx >> (tau + 1)) & 1) && (tau < h - 1)) {\n    memcpy(state->keep + (tau >> 1)*n, state->auth + tau*n, n);\n  }\n  if (tau == 0) {\n    setLtreeADRS(ltree_addr, leaf_idx);\n    setOTSADRS(ots_addr, leaf_idx);\n    gen_leaf_wots(state->auth, sk_seed, params, pub_seed, ltree_addr, ots_addr);\n  }\n  else {\n    setTreeHeight(node_addr, (tau-1));\n    setTreeIndex(node_addr, leaf_idx >> tau);\n    hash_h(state->auth + tau * n, buf, pub_seed, node_addr, n);\n    for (i = 0; i < tau; i++) {\n      if (i < h - k) {\n        memcpy(state->auth + i * n, state->treehash[i].node, n);\n      }\n      else {\n        offset = (1 << (h - 1 - i)) + i - h;\n        rowidx = ((leaf_idx >> i) - 1) >> 1;\n        memcpy(state->auth + i * n, state->retain + (offset + rowidx) * n, n);\n      }\n    }\n\n    for (i = 0; i < ((tau < h - k) ? tau : (h - k)); i++) {\n      startidx = leaf_idx + 1 + 3 * (1 << i);\n      if (startidx < 1U << h) {\n        state->treehash[i].h = i;\n        state->treehash[i].next_idx = startidx;\n        state->treehash[i].completed = 0;\n        state->treehash[i].stackusage = 0;\n      }\n    }\n  }\n}\n\n \nint xmss_keypair(unsigned char *pk, unsigned char *sk, bds_state *state, xmss_params *params)\n{\n  unsigned int n = params->n;\n   \n  sk[0] = 0;\n  sk[1] = 0;\n  sk[2] = 0;\n  sk[3] = 0;\n   \n  randombytes(sk+4, 3*n);\n   \n  memcpy(pk+n, sk+4+2*n, n);\n\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n   \n  treehash_setup(pk, params->h, 0, state, sk+4, params, sk+4+2*n, addr);\n   \n  memcpy(sk+4+3*n, pk, n);\n  return 0;\n}\n\n \nint xmss_sign(unsigned char *sk, bds_state *state, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmss_params *params)\n{\n  unsigned int h = params->h;\n  unsigned int n = params->n;\n  unsigned int k = params->k;\n  uint16_t i = 0;\n\n   \n  unsigned long idx = ((unsigned long)sk[0] << 24) | ((unsigned long)sk[1] << 16) | ((unsigned long)sk[2] << 8) | sk[3];\n  unsigned char sk_seed[n];\n  memcpy(sk_seed, sk+4, n);\n  unsigned char sk_prf[n];\n  memcpy(sk_prf, sk+4+n, n);\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, sk+4+2*n, n);\n  \n   \n  unsigned char idx_bytes_32[32];\n  to_byte(idx_bytes_32, idx, 32);\n  \n  unsigned char hash_key[3*n]; \n  \n   \n  sk[0] = ((idx + 1) >> 24) & 255;\n  sk[1] = ((idx + 1) >> 16) & 255;\n  sk[2] = ((idx + 1) >> 8) & 255;\n  sk[3] = (idx + 1) & 255;\n   \n   \n\n   \n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char ots_seed[n];\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n   \n   \n   \n\n   \n   \n  prf(R, idx_bytes_32, sk_prf, n);\n   \n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+4+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n   \n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n   \n  *sig_msg_len = 0;\n\n   \n  sig_msg[0] = (idx >> 24) & 255;\n  sig_msg[1] = (idx >> 16) & 255;\n  sig_msg[2] = (idx >> 8) & 255;\n  sig_msg[3] = idx & 255;\n\n  sig_msg += 4;\n  *sig_msg_len += 4;\n\n   \n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n   \n   \n   \n\n   \n  setType(ots_addr, 0);\n  setOTSADRS(ots_addr, idx);\n\n   \n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n   \n  wots_sign(sig_msg, msg_h, ots_seed, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  *sig_msg_len += params->wots_par.keysize;\n\n   \n  memcpy(sig_msg, state->auth, h*n);\n\n  if (idx < (1U << h) - 1) {\n    bds_round(state, idx, sk_seed, params, pub_seed, ots_addr);\n    bds_treehash_update(state, (h - k) >> 1, sk_seed, params, pub_seed, ots_addr);\n  }\n\n \n\n  sig_msg += params->h*n;\n  *sig_msg_len += params->h*n;\n\n   \n   \n\n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}\n\n \nint xmss_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmss_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned long long i, m_len;\n  unsigned long idx=0;\n  unsigned char wots_pk[params->wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n   \n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  setType(ots_addr, 0);\n  setType(ltree_addr, 1);\n  setType(node_addr, 2);\n\n   \n  idx = ((unsigned long)sig_msg[0] << 24) | ((unsigned long)sig_msg[1] << 16) | ((unsigned long)sig_msg[2] << 8) | sig_msg[3];\n  printf(\"verify:: idx = %lu\\n\", idx);\n  \n   \n  memcpy(hash_key, sig_msg+4,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n  sig_msg += (n+4);\n  sig_msg_len -= (n+4);\n\n   \n  unsigned long long tmp_sig_len = params->wots_par.keysize+params->h*n;\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n   \n   \n   \n\n   \n  setOTSADRS(ots_addr, idx);\n   \n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->wots_par.keysize;\n  sig_msg_len -= params->wots_par.keysize;\n\n   \n  setLtreeADRS(ltree_addr, idx);\n  l_tree(pkhash, wots_pk, params, pub_seed, ltree_addr);\n\n   \n  validate_authpath(root, pkhash, idx, sig_msg, params, pub_seed, node_addr);\n\n  sig_msg += params->h*n;\n  sig_msg_len -= params->h*n;\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}\n\n \nint xmssmt_keypair(unsigned char *pk, unsigned char *sk, bds_state *states, unsigned char *wots_sigs, xmssmt_params *params)\n{\n  unsigned int n = params->n;\n  unsigned int i;\n  unsigned char ots_seed[params->n];\n   \n  for (i = 0; i < params->index_len; i++) {\n    sk[i] = 0;\n  }\n   \n  randombytes(sk+params->index_len, 3*n);\n   \n  memcpy(pk+n, sk+params->index_len+2*n, n);\n\n   \n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  setLayerADRS(addr, (params->d-1));\n   \n  for (i = 0; i < params->d - 1; i++) {\n     \n    treehash_setup(pk, params->xmss_par.h, 0, states + i, sk+params->index_len, &(params->xmss_par), pk+n, addr);\n    setLayerADRS(addr, (i+1));\n    get_seed(ots_seed, sk+params->index_len, n, addr);\n    wots_sign(wots_sigs + i*params->xmss_par.wots_par.keysize, pk, ots_seed, &(params->xmss_par.wots_par), pk+n, addr);\n  }\n  treehash_setup(pk, params->xmss_par.h, 0, states + i, sk+params->index_len, &(params->xmss_par), pk+n, addr);\n  memcpy(sk+params->index_len+3*n, pk, n);\n  return 0;\n}\n\n \nint xmssmt_sign(unsigned char *sk, bds_state *states, unsigned char *wots_sigs, unsigned char *sig_msg, unsigned long long *sig_msg_len, const unsigned char *msg, unsigned long long msglen, const xmssmt_params *params)\n{\n  unsigned int n = params->n;\n  \n  unsigned int tree_h = params->xmss_par.h;\n  unsigned int h = params->h;\n  unsigned int k = params->xmss_par.k;\n  unsigned int idx_len = params->index_len;\n  uint64_t idx_tree;\n  uint32_t idx_leaf;\n  uint64_t i, j;\n  int needswap_upto = -1;\n  unsigned int updates;\n\n  unsigned char sk_seed[n];\n  unsigned char sk_prf[n];\n  unsigned char pub_seed[n];\n   \n  unsigned char R[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n  unsigned char ots_seed[n];\n  uint32_t addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  unsigned char idx_bytes_32[32];\n  bds_state tmp;\n\n   \n  unsigned long long idx = 0;\n  for (i = 0; i < idx_len; i++) {\n    idx |= ((unsigned long long)sk[i]) << 8*(idx_len - 1 - i);\n  }\n\n  memcpy(sk_seed, sk+idx_len, n);\n  memcpy(sk_prf, sk+idx_len+n, n);\n  memcpy(pub_seed, sk+idx_len+2*n, n);\n\n   \n  for (i = 0; i < idx_len; i++) {\n    sk[i] = ((idx + 1) >> 8*(idx_len - 1 - i)) & 255;\n  }\n   \n   \n\n\n   \n   \n   \n\n   \n   \n  to_byte(idx_bytes_32, idx, 32);\n  prf(R, idx_bytes_32, sk_prf, n);\n   \n  memcpy(hash_key, R, n);\n  memcpy(hash_key+n, sk+idx_len+3*n, n);\n  to_byte(hash_key+2*n, idx, n);\n  \n   \n  h_msg(msg_h, msg, msglen, hash_key, 3*n, n);\n\n   \n  *sig_msg_len = 0;\n\n   \n  for (i = 0; i < idx_len; i++) {\n    sig_msg[i] = (idx >> 8*(idx_len - 1 - i)) & 255;\n  }\n\n  sig_msg += idx_len;\n  *sig_msg_len += idx_len;\n\n   \n  for (i = 0; i < n; i++)\n    sig_msg[i] = R[i];\n\n  sig_msg += n;\n  *sig_msg_len += n;\n\n   \n   \n   \n\n   \n\n   \n  setType(ots_addr, 0);\n  idx_tree = idx >> tree_h;\n  idx_leaf = (idx & ((1 << tree_h)-1));\n  setLayerADRS(ots_addr, 0);\n  setTreeADRS(ots_addr, idx_tree);\n  setOTSADRS(ots_addr, idx_leaf);\n\n   \n  get_seed(ots_seed, sk_seed, n, ots_addr);\n\n   \n  wots_sign(sig_msg, msg_h, ots_seed, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->xmss_par.wots_par.keysize;\n  *sig_msg_len += params->xmss_par.wots_par.keysize;\n\n  memcpy(sig_msg, states[0].auth, tree_h*n);\n  sig_msg += tree_h*n;\n  *sig_msg_len += tree_h*n;\n\n   \n  for (i = 1; i < params->d; i++) {\n     \n    memcpy(sig_msg, wots_sigs + (i-1)*params->xmss_par.wots_par.keysize, params->xmss_par.wots_par.keysize);\n\n    sig_msg += params->xmss_par.wots_par.keysize;\n    *sig_msg_len += params->xmss_par.wots_par.keysize;\n\n     \n    memcpy(sig_msg, states[i].auth, tree_h*n);\n    sig_msg += tree_h*n;\n    *sig_msg_len += tree_h*n;\n  }\n\n  updates = (tree_h - k) >> 1;\n\n  setTreeADRS(addr, (idx_tree + 1));\n   \n  if ((1 + idx_tree) * (1 << tree_h) + idx_leaf < (1ULL << h)) {\n    bds_state_update(&states[params->d], sk_seed, &(params->xmss_par), pub_seed, addr);\n  }\n\n  for (i = 0; i < params->d; i++) {\n     \n    if (! (((idx + 1) & ((1ULL << ((i+1)*tree_h)) - 1)) == 0)) {\n      idx_leaf = (idx >> (tree_h * i)) & ((1 << tree_h)-1);\n      idx_tree = (idx >> (tree_h * (i+1)));\n      setLayerADRS(addr, i);\n      setTreeADRS(addr, idx_tree);\n      if (i == (unsigned int) (needswap_upto + 1)) {\n        bds_round(&states[i], idx_leaf, sk_seed, &(params->xmss_par), pub_seed, addr);\n      }\n      updates = bds_treehash_update(&states[i], updates, sk_seed, &(params->xmss_par), pub_seed, addr);\n      setTreeADRS(addr, (idx_tree + 1));\n      \n      if ((1 + idx_tree) * (1 << tree_h) + idx_leaf < (1ULL << (h - tree_h * i))) {\n        if (i > 0 && updates > 0 && states[params->d + i].next_leaf < (1ULL << h)) {\n          bds_state_update(&states[params->d + i], sk_seed, &(params->xmss_par), pub_seed, addr);\n          updates--;\n        }\n      }\n    }\n    else if (idx < (1ULL << h) - 1) {\n      memcpy(&tmp, states+params->d + i, sizeof(bds_state));\n      memcpy(states+params->d + i, states + i, sizeof(bds_state));\n      memcpy(states + i, &tmp, sizeof(bds_state));\n\n      setLayerADRS(ots_addr, (i+1));\n      setTreeADRS(ots_addr, ((idx + 1) >> ((i+2) * tree_h)));\n      setOTSADRS(ots_addr, (((idx >> ((i+1) * tree_h)) + 1) & ((1 << tree_h)-1)));\n\n      get_seed(ots_seed, sk+params->index_len, n, ots_addr);\n      wots_sign(wots_sigs + i*params->xmss_par.wots_par.keysize, states[i].stack, ots_seed, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n      states[params->d + i].stackoffset = 0;\n      states[params->d + i].next_leaf = 0;\n\n      updates--; \n      needswap_upto = i;\n      for (j = 0; j < tree_h-k; j++) {\n        states[i].treehash[j].completed = 1;\n      }\n    }\n  }\n\n  \n  \n\n  memcpy(sig_msg, msg, msglen);\n  *sig_msg_len += msglen;\n\n  return 0;\n}\n\n \nint xmssmt_sign_open(unsigned char *msg, unsigned long long *msglen, const unsigned char *sig_msg, unsigned long long sig_msg_len, const unsigned char *pk, const xmssmt_params *params)\n{\n  unsigned int n = params->n;\n\n  unsigned int tree_h = params->xmss_par.h;\n  unsigned int idx_len = params->index_len;\n  uint64_t idx_tree;\n  uint32_t idx_leaf;\n\n  unsigned long long i, m_len;\n  unsigned long long idx=0;\n  unsigned char wots_pk[params->xmss_par.wots_par.keysize];\n  unsigned char pkhash[n];\n  unsigned char root[n];\n  unsigned char msg_h[n];\n  unsigned char hash_key[3*n];\n\n  unsigned char pub_seed[n];\n  memcpy(pub_seed, pk+n, n);\n\n  \n  uint32_t ots_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t ltree_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n  uint32_t node_addr[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n\n  \n  for (i = 0; i < idx_len; i++) {\n    idx |= ((unsigned long long)sig_msg[i]) << (8*(idx_len - 1 - i));\n  }\n  printf(\"verify:: idx = %llu\\n\", idx);\n  sig_msg += idx_len;\n  sig_msg_len -= idx_len;\n  \n  \n  memcpy(hash_key, sig_msg,n);\n  memcpy(hash_key+n, pk, n);\n  to_byte(hash_key+2*n, idx, n);\n\n  sig_msg += n;\n  sig_msg_len -= n;\n  \n\n  \n  unsigned long long tmp_sig_len = (params->d * params->xmss_par.wots_par.keysize) + (params->h * n);\n  m_len = sig_msg_len - tmp_sig_len;\n  h_msg(msg_h, sig_msg + tmp_sig_len, m_len, hash_key, 3*n, n);\n\n  \n  \n  \n  \n\n  \n  idx_tree = idx >> tree_h;\n  idx_leaf = (idx & ((1 << tree_h)-1));\n  setLayerADRS(ots_addr, 0);\n  setTreeADRS(ots_addr, idx_tree);\n  setType(ots_addr, 0);\n\n  memcpy(ltree_addr, ots_addr, 12);\n  setType(ltree_addr, 1);\n\n  memcpy(node_addr, ltree_addr, 12);\n  setType(node_addr, 2);\n  \n  setOTSADRS(ots_addr, idx_leaf);\n\n  \n  wots_pkFromSig(wots_pk, sig_msg, msg_h, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n  sig_msg += params->xmss_par.wots_par.keysize;\n  sig_msg_len -= params->xmss_par.wots_par.keysize;\n\n  \n  setLtreeADRS(ltree_addr, idx_leaf);\n  l_tree(pkhash, wots_pk, &(params->xmss_par), pub_seed, ltree_addr);\n\n  \n  validate_authpath(root, pkhash, idx_leaf, sig_msg, &(params->xmss_par), pub_seed, node_addr);\n\n  sig_msg += tree_h*n;\n  sig_msg_len -= tree_h*n;\n\n  for (i = 1; i < params->d; i++) {\n    \n    idx_leaf = (idx_tree & ((1 << tree_h)-1));\n    idx_tree = idx_tree >> tree_h;\n\n    setLayerADRS(ots_addr, i);\n    setTreeADRS(ots_addr, idx_tree);\n    setType(ots_addr, 0);\n\n    memcpy(ltree_addr, ots_addr, 12);\n    setType(ltree_addr, 1);\n\n    memcpy(node_addr, ltree_addr, 12);\n    setType(node_addr, 2);\n\n    setOTSADRS(ots_addr, idx_leaf);\n\n    \n    wots_pkFromSig(wots_pk, sig_msg, root, &(params->xmss_par.wots_par), pub_seed, ots_addr);\n\n    sig_msg += params->xmss_par.wots_par.keysize;\n    sig_msg_len -= params->xmss_par.wots_par.keysize;\n\n    \n    setLtreeADRS(ltree_addr, idx_leaf);\n    l_tree(pkhash, wots_pk, &(params->xmss_par), pub_seed, ltree_addr);\n\n    \n    validate_authpath(root, pkhash, idx_leaf, sig_msg, &(params->xmss_par), pub_seed, node_addr);\n\n    sig_msg += tree_h*n;\n    sig_msg_len -= tree_h*n;\n\n  }\n\n  for (i = 0; i < n; i++)\n    if (root[i] != pk[i])\n      goto fail;\n\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = sig_msg[i];\n\n  return 0;\n\n\nfail:\n  *msglen = sig_msg_len;\n  for (i = 0; i < *msglen; i++)\n    msg[i] = 0;\n  *msglen = -1;\n  return -1;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}