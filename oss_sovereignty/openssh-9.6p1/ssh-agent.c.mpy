{
  "module_name": "ssh-agent.c",
  "hash_id": "eccd8cfb5dd4f87c85c90b881fae8285c2c6287540db670d6fb82f5dc8f89180",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-agent.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_UN_H\n# include <sys/un.h>\n#endif\n#include \"openbsd-compat/sys-queue.h\"\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#ifdef HAVE_POLL_H\n# include <poll.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"pathnames.h\"\n#include \"ssh-pkcs11.h\"\n#include \"sk-api.h\"\n#include \"myproposal.h\"\n\n#ifndef DEFAULT_ALLOWED_PROVIDERS\n# define DEFAULT_ALLOWED_PROVIDERS \"/usr/lib*/*,/usr/local/lib*/*\"\n#endif\n\n \n#define AGENT_MAX_LEN\t\t(256*1024)\n \n#define AGENT_RBUF_LEN\t\t(4096)\n \n#define AGENT_MAX_SESSION_IDS\t\t16\n \n#define AGENT_MAX_SID_LEN\t\t128\n \n#define AGENT_MAX_DEST_CONSTRAINTS\t1024\n \n#define AGENT_MAX_EXT_CERTS\t\t1024\n\n \n\ntypedef enum {\n\tAUTH_UNUSED = 0,\n\tAUTH_SOCKET = 1,\n\tAUTH_CONNECTION = 2,\n} sock_type;\n\nstruct hostkey_sid {\n\tstruct sshkey *key;\n\tstruct sshbuf *sid;\n\tint forwarded;\n};\n\ntypedef struct socket_entry {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n\tsize_t nsession_ids;\n\tstruct hostkey_sid *session_ids;\n\tint session_bind_attempted;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n\tchar *sk_provider;\n\tstruct dest_constraint *dest_constraints;\n\tsize_t ndest_constraints;\n} Identity;\n\nstruct idtable {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n};\n\n \nstruct idtable *idtab;\n\nint max_fd = 0;\n\n \npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n \npid_t cleanup_pid = 0;\n\n \nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n \nstatic char *allowed_providers;\n\n \nstatic int remote_add_provider;\n\n \n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n \nstatic int lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n \nstatic int restrict_websafe = 1;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tsize_t i;\n\n\tclose(e->fd);\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\tsshkey_free(e->session_ids[i].key);\n\t\tsshbuf_free(e->session_ids[i].sid);\n\t}\n\tfree(e->session_ids);\n\tmemset(e, '\\0', sizeof(*e));\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n}\n\nstatic void\nidtab_init(void)\n{\n\tidtab = xcalloc(1, sizeof(*idtab));\n\tTAILQ_INIT(&idtab->idlist);\n\tidtab->nentries = 0;\n}\n\nstatic void\nfree_dest_constraint_hop(struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\n\tif (dch == NULL)\n\t\treturn;\n\tfree(dch->user);\n\tfree(dch->hostname);\n\tfor (i = 0; i < dch->nkeys; i++)\n\t\tsshkey_free(dch->keys[i]);\n\tfree(dch->keys);\n\tfree(dch->key_is_ca);\n}\n\nstatic void\nfree_dest_constraints(struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ndcs; i++) {\n\t\tfree_dest_constraint_hop(&dcs[i].from);\n\t\tfree_dest_constraint_hop(&dcs[i].to);\n\t}\n\tfree(dcs);\n}\n\nstatic void\ndup_dest_constraint_hop(const struct dest_constraint_hop *dch,\n    struct dest_constraint_hop *out)\n{\n\tu_int i;\n\tint r;\n\n\tout->user = dch->user == NULL ? NULL : xstrdup(dch->user);\n\tout->hostname = dch->hostname == NULL ? NULL : xstrdup(dch->hostname);\n\tout->is_ca = dch->is_ca;\n\tout->nkeys = dch->nkeys;\n\tout->keys = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->keys));\n\tout->key_is_ca = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->key_is_ca));\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (r = sshkey_from_private(dch->keys[i],\n\t\t    &(out->keys[i]))) != 0)\n\t\t\tfatal_fr(r, \"copy key\");\n\t\tout->key_is_ca[i] = dch->key_is_ca[i];\n\t}\n}\n\nstatic struct dest_constraint *\ndup_dest_constraints(const struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\tstruct dest_constraint *ret;\n\n\tif (ndcs == 0)\n\t\treturn NULL;\n\tret = xcalloc(ndcs, sizeof(*ret));\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdup_dest_constraint_hop(&dcs[i].from, &ret[i].from);\n\t\tdup_dest_constraint_hop(&dcs[i].to, &ret[i].to);\n\t}\n\treturn ret;\n}\n\n#ifdef DEBUG_CONSTRAINTS\nstatic void\ndump_dest_constraint_hop(const struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\tchar *fp;\n\n\tdebug_f(\"user %s hostname %s is_ca %d nkeys %u\",\n\t    dch->user == NULL ? \"(null)\" : dch->user,\n\t    dch->hostname == NULL ? \"(null)\" : dch->hostname,\n\t    dch->is_ca, dch->nkeys);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tfp = NULL;\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (fp = sshkey_fingerprint(dch->keys[i],\n\t\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug_f(\"key %u/%u: %s%s%s key_is_ca %d\", i, dch->nkeys,\n\t\t    dch->keys[i] == NULL ? \"\" : sshkey_ssh_name(dch->keys[i]),\n\t\t    dch->keys[i] == NULL ? \"\" : \" \",\n\t\t    dch->keys[i] == NULL ? \"none\" : fp,\n\t\t    dch->key_is_ca[i]);\n\t\tfree(fp);\n\t}\n}\n#endif  \n\nstatic void\ndump_dest_constraints(const char *context,\n    const struct dest_constraint *dcs, size_t ndcs)\n{\n#ifdef DEBUG_CONSTRAINTS\n\tsize_t i;\n\n\tdebug_f(\"%s: %zu constraints\", context, ndcs);\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdebug_f(\"constraint %zu / %zu: from: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].from);\n\t\tdebug_f(\"constraint %zu / %zu: to: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].to);\n\t}\n\tdebug_f(\"done for %s\", context);\n#endif  \n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id->sk_provider);\n\tfree_dest_constraints(id->dest_constraints, id->ndest_constraints);\n\tfree(id);\n}\n\n \nstatic int\nmatch_key_hop(const char *tag, const struct sshkey *key,\n    const struct dest_constraint_hop *dch)\n{\n\tconst char *reason = NULL;\n\tconst char *hostname = dch->hostname ? dch->hostname : \"(ORIGIN)\";\n\tu_int i;\n\tchar *fp;\n\n\tif (key == NULL)\n\t\treturn -1;\n\t \n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\tdebug3_f(\"%s: entering hostname %s, requested key %s %s, %u keys avail\",\n\t    tag, hostname, sshkey_type(key), fp, dch->nkeys);\n\tfree(fp);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] == NULL)\n\t\t\treturn -1;\n\t\t \n\t\tif ((fp = sshkey_fingerprint(dch->keys[i], SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"%s: key %u: %s%s %s\", tag, i,\n\t\t    dch->key_is_ca[i] ? \"CA \" : \"\",\n\t\t    sshkey_type(dch->keys[i]), fp);\n\t\tfree(fp);\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\t \n\t\t\tif (dch->key_is_ca[i] ||\n\t\t\t    !sshkey_equal(key, dch->keys[i]))\n\t\t\t\tcontinue;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (!dch->key_is_ca[i])\n\t\t\tcontinue;\n\t\tif (key->cert == NULL || key->cert->signature_key == NULL)\n\t\t\treturn -1;  \n\t\tif (!sshkey_equal(key->cert->signature_key, dch->keys[i]))\n\t\t\tcontinue;\n\t\tif (sshkey_cert_check_host(key, hostname, 1,\n\t\t    SSH_ALLOWED_CA_SIGALGS, &reason) != 0) {\n\t\t\tdebug_f(\"cert %s / hostname %s rejected: %s\",\n\t\t\t    key->cert->key_id, hostname, reason);\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\n \nstatic int\npermitted_by_dest_constraints(const struct sshkey *fromkey,\n    const struct sshkey *tokey, Identity *id, const char *user,\n    const char **hostnamep)\n{\n\tsize_t i;\n\tstruct dest_constraint *d;\n\n\tif (hostnamep != NULL)\n\t\t*hostnamep = NULL;\n\tfor (i = 0; i < id->ndest_constraints; i++) {\n\t\td = id->dest_constraints + i;\n\t\t \n\t\tdebug2_f(\"constraint %zu %s%s%s (%u keys) > %s%s%s (%u keys)\",\n\t\t    i, d->from.user ? d->from.user : \"\",\n\t\t    d->from.user ? \"@\" : \"\",\n\t\t    d->from.hostname ? d->from.hostname : \"(ORIGIN)\",\n\t\t    d->from.nkeys,\n\t\t    d->to.user ? d->to.user : \"\", d->to.user ? \"@\" : \"\",\n\t\t    d->to.hostname ? d->to.hostname : \"(ANY)\", d->to.nkeys);\n\n\t\t \n\t\tif (fromkey == NULL) {\n\t\t\t \n\t\t\tif (d->from.hostname != NULL || d->from.nkeys != 0)\n\t\t\t\tcontinue;\n\t\t} else if (match_key_hop(\"from\", fromkey, &d->from) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tokey != NULL && match_key_hop(\"to\", tokey, &d->to) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (d->to.user != NULL && user != NULL &&\n\t\t    !match_pattern(user, d->to.user))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (hostnamep != NULL)\n\t\t\t*hostnamep = d->to.hostname;\n\t\tdebug2_f(\"allowed for hostname %s\",\n\t\t    d->to.hostname == NULL ? \"*\" : d->to.hostname);\n\t\treturn 0;\n\t}\n\t \n\tdebug2_f(\"%s identity \\\"%s\\\" not permitted for this destination\",\n\t    sshkey_type(id->key), id->comment);\n\treturn -1;\n}\n\n \nstatic int\nidentity_permitted(Identity *id, SocketEntry *e, char *user,\n    const char **forward_hostnamep, const char **last_hostnamep)\n{\n\tsize_t i;\n\tconst char **hp;\n\tstruct hostkey_sid *hks;\n\tconst struct sshkey *fromkey = NULL;\n\tconst char *test_user;\n\tchar *fp1, *fp2;\n\n\t \n\tdebug3_f(\"entering: key %s comment \\\"%s\\\", %zu socket bindings, \"\n\t    \"%zu constraints\", sshkey_type(id->key), id->comment,\n\t    e->nsession_ids, id->ndest_constraints);\n\tif (id->ndest_constraints == 0)\n\t\treturn 0;  \n\tif (e->session_bind_attempted && e->nsession_ids == 0) {\n\t\terror_f(\"previous session bind failed on socket\");\n\t\treturn -1;\n\t}\n\tif (e->nsession_ids == 0)\n\t\treturn 0;  \n\t \n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\thks = e->session_ids + i;\n\t\tif (hks->key == NULL)\n\t\t\tfatal_f(\"internal error: no bound key\");\n\t\t \n\t\tfp1 = fp2 = NULL;\n\t\tif (fromkey != NULL &&\n\t\t    (fp1 = sshkey_fingerprint(fromkey, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tif ((fp2 = sshkey_fingerprint(hks->key, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"socketentry fd=%d, entry %zu %s, \"\n\t\t    \"from hostkey %s %s to user %s hostkey %s %s\",\n\t\t    e->fd, i, hks->forwarded ? \"FORWARD\" : \"AUTH\",\n\t\t    fromkey ? sshkey_type(fromkey) : \"(ORIGIN)\",\n\t\t    fromkey ? fp1 : \"\", user ? user : \"(ANY)\",\n\t\t    sshkey_type(hks->key), fp2);\n\t\tfree(fp1);\n\t\tfree(fp2);\n\t\t \n\t\thp = NULL;\n\t\tif (i == e->nsession_ids - 1)\n\t\t\thp = last_hostnamep;\n\t\telse if (i == 0)\n\t\t\thp = forward_hostnamep;\n\t\t \n\t\ttest_user = NULL;\n\t\tif (i == e->nsession_ids - 1) {\n\t\t\t \n\t\t\ttest_user = user;\n\t\t\t \n\t\t\tif (hks->forwarded && user != NULL) {\n\t\t\t\terror_f(\"tried to sign on forwarding hop\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!hks->forwarded) {\n\t\t\terror_f(\"tried to forward though signing bind\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (permitted_by_dest_constraints(fromkey, hks->key, id,\n\t\t    test_user, hp) != 0)\n\t\t\treturn -1;\n\t\tfromkey = hks->key;\n\t}\n\t \n\thks = &e->session_ids[e->nsession_ids - 1];\n\tif (hks->forwarded && user == NULL &&\n\t    permitted_by_dest_constraints(hks->key, NULL, id,\n\t    NULL, NULL) != 0) {\n\t\tdebug3_f(\"key permitted at host but not after\");\n\t\treturn -1;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int\nsocket_is_remote(SocketEntry *e)\n{\n\treturn e->session_bind_attempted || (e->nsession_ids != 0);\n}\n\n \nstatic Identity *\nlookup_identity(struct sshkey *key)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n \nstatic int\nconfirm_key(Identity *id, const char *extra)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.%s%s\",\n\t    id->comment, p,\n\t    extra == NULL ? \"\" : \"\\n\", extra == NULL ? \"\" : extra))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose\");\n}\n\n \nstatic void\nprocess_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int i = 0, nentries = 0;\n\tchar *fp;\n\n\tdebug2_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif ((fp = sshkey_fingerprint(id->key, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug_f(\"key %u / %u: %s %s\", i++, idtab->nentries,\n\t\t    sshkey_ssh_name(id->key), fp);\n\t\tdump_dest_constraints(__func__,\n\t\t    id->dest_constraints, id->ndest_constraints);\n\t\tfree(fp);\n\t\t \n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}\n\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t} else if (key->type == KEY_RSA_CERT) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256-cert-v01@openssh.com\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512-cert-v01@openssh.com\";\n\t}\n\treturn NULL;\n}\n\n \nstatic int\nparse_userauth_request(struct sshbuf *msg, const struct sshkey *expected_key,\n    char **userp, struct sshbuf **sess_idp, struct sshkey **hostkeyp)\n{\n\tstruct sshbuf *b = NULL, *sess_id = NULL;\n\tchar *user = NULL, *service = NULL, *method = NULL, *pkalg = NULL;\n\tint r;\n\tu_char t, sig_follows;\n\tstruct sshkey *mkey = NULL, *hostkey = NULL;\n\n\tif (userp != NULL)\n\t\t*userp = NULL;\n\tif (sess_idp != NULL)\n\t\t*sess_idp = NULL;\n\tif (hostkeyp != NULL)\n\t\t*hostkeyp = NULL;\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\t \n\tif ((r = sshbuf_froms(b, &sess_id)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(sess_id) == 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_u8(b, &t)) != 0 ||  \n\t    (r = sshbuf_get_cstring(b, &user, NULL)) != 0 ||  \n\t    (r = sshbuf_get_cstring(b, &service, NULL)) != 0 ||  \n\t    (r = sshbuf_get_cstring(b, &method, NULL)) != 0 ||  \n\t    (r = sshbuf_get_u8(b, &sig_follows)) != 0 ||  \n\t    (r = sshbuf_get_cstring(b, &pkalg, NULL)) != 0 ||  \n\t    (r = sshkey_froms(b, &mkey)) != 0)  \n\t\tgoto out;\n\tif (t != SSH2_MSG_USERAUTH_REQUEST ||\n\t    sig_follows != 1 ||\n\t    strcmp(service, \"ssh-connection\") != 0 ||\n\t    !sshkey_equal(expected_key, mkey) ||\n\t    sshkey_type_from_name(pkalg) != expected_key->type) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(method, \"publickey-hostbound-v00@openssh.com\") == 0) {\n\t\tif ((r = sshkey_froms(b, &hostkey)) != 0)\n\t\t\tgoto out;\n\t} else if (strcmp(method, \"publickey\") != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n\tdebug3_f(\"well formed userauth\");\n\tif (userp != NULL) {\n\t\t*userp = user;\n\t\tuser = NULL;\n\t}\n\tif (sess_idp != NULL) {\n\t\t*sess_idp = sess_id;\n\t\tsess_id = NULL;\n\t}\n\tif (hostkeyp != NULL) {\n\t\t*hostkeyp = hostkey;\n\t\thostkey = NULL;\n\t}\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(sess_id);\n\tfree(user);\n\tfree(service);\n\tfree(method);\n\tfree(pkalg);\n\tsshkey_free(mkey);\n\tsshkey_free(hostkey);\n\treturn r;\n}\n\n \nstatic int\nparse_sshsig_request(struct sshbuf *msg)\n{\n\tint r;\n\tstruct sshbuf *b;\n\n\tif ((b = sshbuf_fromb(msg)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb\");\n\n\tif ((r = sshbuf_cmp(b, 0, \"SSHSIG\", 6)) != 0 ||\n\t    (r = sshbuf_consume(b, 6)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 ||  \n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0 ||  \n\t    (r = sshbuf_get_cstring(b, NULL, NULL)) != 0 ||  \n\t    (r = sshbuf_get_string_direct(b, NULL, NULL)) != 0)  \n\t\tgoto out;\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\n \nstatic int\ncheck_websafe_message_contents(struct sshkey *key, struct sshbuf *data)\n{\n\tif (parse_userauth_request(data, key, NULL, NULL, NULL) == 0) {\n\t\tdebug_f(\"signed data matches public key userauth request\");\n\t\treturn 1;\n\t}\n\tif (parse_sshsig_request(data) == 0) {\n\t\tdebug_f(\"signed data matches SSHSIG signature request\");\n\t\treturn 1;\n\t}\n\n\t \n\n\terror(\"web-origin key attempting to sign non-SSH message\");\n\treturn 0;\n}\n\nstatic int\nbuf_equal(const struct sshbuf *a, const struct sshbuf *b)\n{\n\tif (sshbuf_ptr(a) == NULL || sshbuf_ptr(b) == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshbuf_len(a) != sshbuf_len(b))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (timingsafe_bcmp(sshbuf_ptr(a), sshbuf_ptr(b), sshbuf_len(a)) != 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn 0;\n}\n\n \nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *signature = NULL;\n\tsize_t slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1, retried = 0;\n\tchar *fp = NULL, *pin = NULL, *prompt = NULL;\n\tchar *user = NULL, *sig_dest = NULL;\n\tconst char *fwd_host = NULL, *dest_host = NULL;\n\tstruct sshbuf *msg = NULL, *data = NULL, *sid = NULL;\n\tstruct sshkey *key = NULL, *hostkey = NULL;\n\tstruct identity *id;\n\tstruct notifier_ctx *notifier = NULL;\n\n\tdebug_f(\"entering\");\n\n\tif ((msg = sshbuf_new()) == NULL || (data = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_get_stringb(e->request, data)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tverbose_f(\"%s key not found\", sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\n\tif (id->ndest_constraints != 0) {\n\t\tif (e->nsession_ids == 0) {\n\t\t\tlogit_f(\"refusing use of destination-constrained key \"\n\t\t\t    \"to sign on unbound connection\");\n\t\t\tgoto send;\n\t\t}\n\t\tif (parse_userauth_request(data, key, &user, &sid,\n\t\t    &hostkey) != 0) {\n\t\t\tlogit_f(\"refusing use of destination-constrained key \"\n\t\t\t   \"to sign an unidentified signature\");\n\t\t\tgoto send;\n\t\t}\n\t\t \n\t\tdebug_f(\"user=%s\", user);\n\t\tif (identity_permitted(id, e, user, &fwd_host, &dest_host) != 0)\n\t\t\tgoto send;\n\t\t \n\t\t \n\t\tif (buf_equal(sid,\n\t\t    e->session_ids[e->nsession_ids - 1].sid) != 0) {\n\t\t\terror_f(\"unexpected session ID (%zu listed) on \"\n\t\t\t    \"signature request for target user %s with \"\n\t\t\t    \"key %s %s\", e->nsession_ids, user,\n\t\t\t    sshkey_type(id->key), fp);\n\t\t\tgoto send;\n\t\t}\n\t\t \n\t\tif (e->nsession_ids > 1 && hostkey == NULL) {\n\t\t\terror_f(\"refusing use of destination-constrained key: \"\n\t\t\t    \"no hostkey recorded in signature for forwarded \"\n\t\t\t    \"connection\");\n\t\t\tgoto send;\n\t\t}\n\t\tif (hostkey != NULL && !sshkey_equal(hostkey,\n\t\t    e->session_ids[e->nsession_ids - 1].key)) {\n\t\t\terror_f(\"refusing use of destination-constrained key: \"\n\t\t\t    \"mismatch between hostkey in request and most \"\n\t\t\t    \"recently bound session\");\n\t\t\tgoto send;\n\t\t}\n\t\txasprintf(&sig_dest, \"public key authentication request for \"\n\t\t    \"user \\\"%s\\\" to listed host\", user);\n\t}\n\tif (id->confirm && confirm_key(id, sig_dest) != 0) {\n\t\tverbose_f(\"user refused key\");\n\t\tgoto send;\n\t}\n\tif (sshkey_is_sk(id->key)) {\n\t\tif (restrict_websafe &&\n\t\t    strncmp(id->key->sk_application, \"ssh:\", 4) != 0 &&\n\t\t    !check_websafe_message_contents(key, data)) {\n\t\t\t \n\t\t\tgoto send;\n\t\t}\n\t\tif (id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD) {\n\t\t\tnotifier = notify_start(0,\n\t\t\t    \"Confirm user presence for key %s %s%s%s\",\n\t\t\t    sshkey_type(id->key), fp,\n\t\t\t    sig_dest == NULL ? \"\" : \"\\n\",\n\t\t\t    sig_dest == NULL ? \"\" : sig_dest);\n\t\t}\n\t}\n retry_pin:\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    sshbuf_ptr(data), sshbuf_len(data), agent_decode_alg(key, flags),\n\t    id->sk_provider, pin, compat)) != 0) {\n\t\tdebug_fr(r, \"sshkey_sign\");\n\t\tif (pin == NULL && !retried && sshkey_is_sk(id->key) &&\n\t\t    r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\t\tnotify_complete(notifier, NULL);\n\t\t\tnotifier = NULL;\n\t\t\t \n\t\t\txasprintf(&prompt, \"Enter PIN%sfor %s key %s: \",\n\t\t\t    (id->key->sk_flags & SSH_SK_USER_PRESENCE_REQD) ?\n\t\t\t    \" and confirm user presence \" : \" \",\n\t\t\t    sshkey_type(id->key), fp);\n\t\t\tpin = read_passphrase(prompt, RP_USE_ASKPASS);\n\t\t\tretried = 1;\n\t\t\tgoto retry_pin;\n\t\t}\n\t\terror_fr(r, \"sshkey_sign\");\n\t\tgoto send;\n\t}\n\t \n\tok = 0;\n\tdebug_f(\"good signature\");\n send:\n\tnotify_complete(notifier, \"User presence confirmed\");\n\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal_fr(r, \"compose\");\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose failure\");\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\n\tsshbuf_free(sid);\n\tsshbuf_free(data);\n\tsshbuf_free(msg);\n\tsshkey_free(key);\n\tsshkey_free(hostkey);\n\tfree(fp);\n\tfree(signature);\n\tfree(sig_dest);\n\tfree(user);\n\tfree(prompt);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n}\n\n \nstatic void\nprocess_remove_identity(SocketEntry *e)\n{\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_froms(e->request, &key)) != 0) {\n\t\terror_fr(r, \"parse key\");\n\t\tgoto done;\n\t}\n\tif ((id = lookup_identity(key)) == NULL) {\n\t\tdebug_f(\"key not found\");\n\t\tgoto done;\n\t}\n\t \n\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\tgoto done;  \n\t \n\tif (idtab->nentries < 1)\n\t\tfatal_f(\"internal error: nentries %d\", idtab->nentries);\n\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\tfree_identity(id);\n\tidtab->nentries--;\n\tsuccess = 1;\n done:\n\tsshkey_free(key);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\n\tdebug2_f(\"entering\");\n\t \n\tfor (id = TAILQ_FIRST(&idtab->idlist); id;\n\t    id = TAILQ_FIRST(&idtab->idlist)) {\n\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t \n\tidtab->nentries = 0;\n\n\t \n\tsend_status(e, 1);\n}\n\n \nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\tif (id->death == 0)\n\t\t\tcontinue;\n\t\tif (now >= id->death) {\n\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t} else\n\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t    MINIMUM(deadline, id->death);\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\nstatic int\nparse_dest_constraint_hop(struct sshbuf *b, struct dest_constraint_hop *dch)\n{\n\tu_char key_is_ca;\n\tsize_t elen = 0;\n\tint r;\n\tstruct sshkey *k = NULL;\n\tchar *fp;\n\n\tmemset(dch, '\\0', sizeof(*dch));\n\tif ((r = sshbuf_get_cstring(b, &dch->user, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &dch->hostname, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, NULL, &elen)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (elen != 0) {\n\t\terror_f(\"unsupported extensions (len %zu)\", elen);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tif (*dch->hostname == '\\0') {\n\t\tfree(dch->hostname);\n\t\tdch->hostname = NULL;\n\t}\n\tif (*dch->user == '\\0') {\n\t\tfree(dch->user);\n\t\tdch->user = NULL;\n\t}\n\twhile (sshbuf_len(b) != 0) {\n\t\tdch->keys = xrecallocarray(dch->keys, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->keys));\n\t\tdch->key_is_ca = xrecallocarray(dch->key_is_ca, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->key_is_ca));\n\t\tif ((r = sshkey_froms(b, &k)) != 0 ||\n\t\t    (r = sshbuf_get_u8(b, &key_is_ca)) != 0)\n\t\t\tgoto out;\n\t\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug3_f(\"%s%s%s: adding %skey %s %s\",\n\t\t    dch->user == NULL ? \"\" : dch->user,\n\t\t    dch->user == NULL ? \"\" : \"@\",\n\t\t    dch->hostname, key_is_ca ? \"CA \" : \"\", sshkey_type(k), fp);\n\t\tfree(fp);\n\t\tdch->keys[dch->nkeys] = k;\n\t\tdch->key_is_ca[dch->nkeys] = key_is_ca != 0;\n\t\tdch->nkeys++;\n\t\tk = NULL;  \n\t}\n\t \n\tr = 0;\n out:\n\tsshkey_free(k);\n\treturn r;\n}\n\nstatic int\nparse_dest_constraint(struct sshbuf *m, struct dest_constraint *dc)\n{\n\tstruct sshbuf *b = NULL, *frombuf = NULL, *tobuf = NULL;\n\tint r;\n\tsize_t elen = 0;\n\n\tdebug3_f(\"entering\");\n\n\tmemset(dc, '\\0', sizeof(*dc));\n\tif ((r = sshbuf_froms(m, &b)) != 0 ||\n\t    (r = sshbuf_froms(b, &frombuf)) != 0 ||\n\t    (r = sshbuf_froms(b, &tobuf)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, NULL, &elen)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((r = parse_dest_constraint_hop(frombuf, &dc->from)) != 0 ||\n\t    (r = parse_dest_constraint_hop(tobuf, &dc->to)) != 0)\n\t\tgoto out;  \n\tif (elen != 0) {\n\t\terror_f(\"unsupported extensions (len %zu)\", elen);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tdebug2_f(\"parsed %s (%u keys) > %s%s%s (%u keys)\",\n\t    dc->from.hostname ? dc->from.hostname : \"(ORIGIN)\", dc->from.nkeys,\n\t    dc->to.user ? dc->to.user : \"\", dc->to.user ? \"@\" : \"\",\n\t    dc->to.hostname ? dc->to.hostname : \"(ANY)\", dc->to.nkeys);\n\t \n\tif ((dc->from.hostname == NULL) != (dc->from.nkeys == 0) ||\n\t    dc->from.user != NULL) {\n\t\terror_f(\"inconsistent \\\"from\\\" specification\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (dc->to.hostname == NULL || dc->to.nkeys == 0) {\n\t\terror_f(\"incomplete \\\"to\\\" specification\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tsshbuf_free(b);\n\tsshbuf_free(frombuf);\n\tsshbuf_free(tobuf);\n\treturn r;\n}\n\nstatic int\nparse_key_constraint_extension(struct sshbuf *m, char **sk_providerp,\n    struct dest_constraint **dcsp, size_t *ndcsp, int *cert_onlyp,\n    struct sshkey ***certs, size_t *ncerts)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\tstruct sshbuf *b = NULL;\n\tu_char v;\n\tstruct sshkey *k;\n\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else if (strcmp(ext_name,\n\t    \"restrict-destination-v00@openssh.com\") == 0) {\n\t\tif (*dcsp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_froms(m, &b)) != 0) {\n\t\t\terror_fr(r, \"parse %s outer\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (sshbuf_len(b) != 0) {\n\t\t\tif (*ndcsp >= AGENT_MAX_DEST_CONSTRAINTS) {\n\t\t\t\terror_f(\"too many %s constraints\", ext_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*dcsp = xrecallocarray(*dcsp, *ndcsp, *ndcsp + 1,\n\t\t\t    sizeof(**dcsp));\n\t\t\tif ((r = parse_dest_constraint(b,\n\t\t\t    *dcsp + (*ndcsp)++)) != 0)\n\t\t\t\tgoto out;  \n\t\t}\n\t} else if (strcmp(ext_name,\n\t    \"associated-certs-v00@openssh.com\") == 0) {\n\t\tif (certs == NULL || ncerts == NULL || cert_onlyp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*certs != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_u8(m, &v)) != 0 ||\n\t\t    (r = sshbuf_froms(m, &b)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t\t*cert_onlyp = v != 0;\n\t\twhile (sshbuf_len(b) != 0) {\n\t\t\tif (*ncerts >= AGENT_MAX_EXT_CERTS) {\n\t\t\t\terror_f(\"too many %s constraints\", ext_name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*certs = xrecallocarray(*certs, *ncerts, *ncerts + 1,\n\t\t\t    sizeof(**certs));\n\t\t\tif ((r = sshkey_froms(b, &k)) != 0) {\n\t\t\t\terror_fr(r, \"parse key\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t(*certs)[(*ncerts)++] = k;\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tfree(ext_name);\n\tsshbuf_free(b);\n\treturn r;\n}\n\nstatic int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp,\n    struct dest_constraint **dcsp, size_t *ndcsp,\n    int *cert_onlyp, size_t *ncerts, struct sshkey ***certs)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = parse_key_constraint_extension(m,\n\t\t\t    sk_providerp, dcsp, ndcsp,\n\t\t\t    cert_onlyp, certs, ncerts)) != 0)\n\t\t\t\tgoto out;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\tr = 0;\n out:\n\treturn r;\n}\n\nstatic void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider, &dest_constraints, &ndest_constraints,\n\t    NULL, NULL, NULL) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\tdump_dest_constraints(__func__, dest_constraints, ndest_constraints);\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (socket_is_remote(e) && !remote_add_provider) {\n\t\t\t\tverbose(\"failed add of SK provider \\\"%.100s\\\": \"\n\t\t\t\t    \"remote addition of providers is disabled\",\n\t\t\t\t    sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t \n\t\tidtab->nentries++;\n\t} else {\n\t\t \n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tgoto out;  \n\t\t \n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t\tfree_dest_constraints(id->dest_constraints,\n\t\t    id->ndest_constraints);\n\t}\n\t \n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\tid->dest_constraints = dest_constraints;\n\tid->ndest_constraints = ndest_constraints;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s) (destination constraints: %zu)\",\n\t    sshkey_ssh_name(k), fp, comment, seconds, confirm,\n\t    sk_provider == NULL ? \"none\" : sk_provider, ndest_constraints);\n\tfree(fp);\n\t \n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tdest_constraints = NULL;\n\tndest_constraints = 0;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}\n\n \nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tdebug2_f(\"entering\");\n\t \n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t \n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\tfreezero(passwd, pwlen);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsshbuf_free(msg);\n}\n\n \nstatic void\nadd_p11_identity(struct sshkey *key, char *comment, const char *provider,\n    time_t death, int confirm, struct dest_constraint *dest_constraints,\n    size_t ndest_constraints)\n{\n\tIdentity *id;\n\n\tif (lookup_identity(key) != NULL) {\n\t\tsshkey_free(key);\n\t\tfree(comment);\n\t\treturn;\n\t}\n\tid = xcalloc(1, sizeof(Identity));\n\tid->key = key;\n\tid->comment = comment;\n\tid->provider = xstrdup(provider);\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->dest_constraints = dup_dest_constraints(dest_constraints,\n\t    ndest_constraints);\n\tid->ndest_constraints = ndest_constraints;\n\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\tidtab->nentries++;\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t j, ndest_constraints = 0, ncerts = 0;\n\tstruct sshkey **certs = NULL;\n\tint cert_only = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints, &cert_only,\n\t    &ncerts, &certs) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tdump_dest_constraints(__func__, dest_constraints, ndest_constraints);\n\tif (socket_is_remote(e) && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tif (comments[i] == NULL || comments[i][0] == '\\0') {\n\t\t\tfree(comments[i]);\n\t\t\tcomments[i] = xstrdup(canonical_provider);\n\t\t}\n\t\tfor (j = 0; j < ncerts; j++) {\n\t\t\tif (!sshkey_is_cert(certs[j]))\n\t\t\t\tcontinue;\n\t\t\tif (!sshkey_equal_public(keys[i], certs[j]))\n\t\t\t\tcontinue;\n\t\t\tif (pkcs11_make_cert(keys[i], certs[j], &k) != 0)\n\t\t\t\tcontinue;\n\t\t\tadd_p11_identity(k, xstrdup(comments[i]),\n\t\t\t    canonical_provider, death, confirm,\n\t\t\t    dest_constraints, ndest_constraints);\n\t\t\tsuccess = 1;\n\t\t}\n\t\tif (!cert_only && lookup_identity(keys[i]) == NULL) {\n\t\t\tadd_p11_identity(keys[i], comments[i],\n\t\t\t    canonical_provider, death, confirm,\n\t\t\t    dest_constraints, ndest_constraints);\n\t\t\tkeys[i] = NULL;\t\t \n\t\t\tcomments[i] = NULL;\t \n\t\t\tsuccess = 1;\n\t\t}\n\t\t \n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tfor (j = 0; j < ncerts; j++)\n\t\tsshkey_free(certs[j]);\n\tfree(certs);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tint r, success = 0;\n\tIdentity *id, *nxt;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tfree(pin);\n\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\n\tdebug_f(\"remove %.100s\", canonical_provider);\n\tfor (id = TAILQ_FIRST(&idtab->idlist); id; id = nxt) {\n\t\tnxt = TAILQ_NEXT(id, next);\n\t\t \n\t\tif (id->provider == NULL)\n\t\t\tcontinue;\n\t\tif (!strcmp(canonical_provider, id->provider)) {\n\t\t\tTAILQ_REMOVE(&idtab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\tidtab->nentries--;\n\t\t}\n\t}\n\tif (pkcs11_del_provider(canonical_provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror_f(\"pkcs11_del_provider failed\");\nsend:\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif  \n\nstatic int\nprocess_ext_session_bind(SocketEntry *e)\n{\n\tint r, sid_match, key_match;\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *sid = NULL, *sig = NULL;\n\tchar *fp = NULL;\n\tsize_t i;\n\tu_char fwd = 0;\n\n\tdebug2_f(\"entering\");\n\te->session_bind_attempted = 1;\n\tif ((r = sshkey_froms(e->request, &key)) != 0 ||\n\t    (r = sshbuf_froms(e->request, &sid)) != 0 ||\n\t    (r = sshbuf_froms(e->request, &sig)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &fwd)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"fingerprint failed\");\n\t \n\tif ((r = sshkey_verify(key, sshbuf_ptr(sig), sshbuf_len(sig),\n\t    sshbuf_ptr(sid), sshbuf_len(sid), NULL, 0, NULL)) != 0) {\n\t\terror_fr(r, \"sshkey_verify for %s %s\", sshkey_type(key), fp);\n\t\tgoto out;\n\t}\n\t \n\tfor (i = 0; i < e->nsession_ids; i++) {\n\t\tif (!e->session_ids[i].forwarded) {\n\t\t\terror_f(\"attempt to bind session ID to socket \"\n\t\t\t    \"previously bound for authentication attempt\");\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsid_match = buf_equal(sid, e->session_ids[i].sid) == 0;\n\t\tkey_match = sshkey_equal(key, e->session_ids[i].key);\n\t\tif (sid_match && key_match) {\n\t\t\tdebug_f(\"session ID already recorded for %s %s\",\n\t\t\t    sshkey_type(key), fp);\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t} else if (sid_match) {\n\t\t\terror_f(\"session ID recorded against different key \"\n\t\t\t    \"for %s %s\", sshkey_type(key), fp);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t}\n\t \n\tif (e->nsession_ids >= AGENT_MAX_SESSION_IDS) {\n\t\terror_f(\"too many session IDs recorded\");\n\t\tgoto out;\n\t}\n\te->session_ids = xrecallocarray(e->session_ids, e->nsession_ids,\n\t    e->nsession_ids + 1, sizeof(*e->session_ids));\n\ti = e->nsession_ids++;\n\tdebug_f(\"recorded %s %s (slot %zu of %d)\", sshkey_type(key), fp, i,\n\t    AGENT_MAX_SESSION_IDS);\n\te->session_ids[i].key = key;\n\te->session_ids[i].forwarded = fwd != 0;\n\tkey = NULL;  \n\t \n\tif ((e->session_ids[i].sid = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_putb(e->session_ids[i].sid, sid)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putb session ID\");\n\t \n\tr = 0;\n out:\n\tfree(fp);\n\tsshkey_free(key);\n\tsshbuf_free(sid);\n\tsshbuf_free(sig);\n\treturn r == 0 ? 1 : 0;\n}\n\nstatic void\nprocess_extension(SocketEntry *e)\n{\n\tint r, success = 0;\n\tchar *name;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &name, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (strcmp(name, \"session-bind@openssh.com\") == 0)\n\t\tsuccess = process_ext_session_bind(e);\n\telse\n\t\tdebug_f(\"unsupported extension \\\"%s\\\"\", name);\n\tfree(name);\nsend:\n\tsend_status(e, success);\n}\n \nstatic int\nprocess_message(u_int socknum)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\tSocketEntry *e;\n\n\tif (socknum >= sockets_alloc)\n\t\tfatal_f(\"sock %u >= allocated %u\", socknum, sockets_alloc);\n\te = &sockets[socknum];\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn 0;\t\t \n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > AGENT_MAX_LEN) {\n\t\tdebug_f(\"socket %u (fd=%d) message too long %u > %u\",\n\t\t    socknum, e->fd, msg_len, AGENT_MAX_LEN);\n\t\treturn -1;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn 0;\t\t \n\n\t \n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0) {\n\t\tif (r == SSH_ERR_MESSAGE_INCOMPLETE ||\n\t\t    r == SSH_ERR_STRING_TOO_LARGE) {\n\t\t\terror_fr(r, \"parse\");\n\t\t\treturn -1;\n\t\t}\n\t\tfatal_fr(r, \"parse\");\n\t}\n\n\tdebug_f(\"socket %u (fd=%d) type %d\", socknum, e->fd, type);\n\n\t \n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t \n\t\t\tno_identities(e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e);  \n\t\tbreak;\n\t \n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif  \n\tcase SSH_AGENTC_EXTENSION:\n\t\tprocess_extension(e);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tdebug_f(\"type = %s\", type == AUTH_CONNECTION ? \"CONNECTION\" :\n\t    (type == AUTH_SOCKET ? \"SOCKET\" : \"UNKNOWN\"));\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].output = sshbuf_new()) == NULL ||\n\t\t\t    (sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xrecallocarray(sockets, old_alloc, new_alloc,\n\t    sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].output = sshbuf_new()) == NULL ||\n\t    (sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nhandle_socket_read(u_int socknum)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tuid_t euid;\n\tgid_t egid;\n\tint fd;\n\n\tslen = sizeof(sunaddr);\n\tfd = accept(sockets[socknum].fd, (struct sockaddr *)&sunaddr, &slen);\n\tif (fd == -1) {\n\t\terror(\"accept from AUTH_SOCKET: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getpeereid(fd, &euid, &egid) == -1) {\n\t\terror(\"getpeereid %d failed: %s\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif ((euid != 0) && (getuid() != euid)) {\n\t\terror(\"uid mismatch: peer euid %u != uid %u\",\n\t\t    (u_int) euid, (u_int) getuid());\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tnew_socket(AUTH_CONNECTION, fd);\n\treturn 0;\n}\n\nstatic int\nhandle_conn_read(u_int socknum)\n{\n\tchar buf[AGENT_RBUF_LEN];\n\tssize_t len;\n\tint r;\n\n\tif ((len = read(sockets[socknum].fd, buf, sizeof(buf))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_put(sockets[socknum].input, buf, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\texplicit_bzero(buf, sizeof(buf));\n\tfor (;;) {\n\t\tif ((r = process_message(socknum)) == -1)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int\nhandle_conn_write(u_int socknum)\n{\n\tssize_t len;\n\tint r;\n\n\tif (sshbuf_len(sockets[socknum].output) == 0)\n\t\treturn 0;  \n\tif ((len = write(sockets[socknum].fd,\n\t    sshbuf_ptr(sockets[socknum].output),\n\t    sshbuf_len(sockets[socknum].output))) <= 0) {\n\t\tif (len == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\treturn 0;\n\t\t\terror_f(\"read error on socket %u (fd %d): %s\",\n\t\t\t    socknum, sockets[socknum].fd, strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\tif ((r = sshbuf_consume(sockets[socknum].output, len)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\treturn 0;\n}\n\nstatic void\nafter_poll(struct pollfd *pfd, size_t npfd, u_int maxfds)\n{\n\tsize_t i;\n\tu_int socknum, activefds = npfd;\n\n\tfor (i = 0; i < npfd; i++) {\n\t\tif (pfd[i].revents == 0)\n\t\t\tcontinue;\n\t\t \n\t\tfor (socknum = 0; socknum < sockets_alloc; socknum++) {\n\t\t\tif (sockets[socknum].type != AUTH_SOCKET &&\n\t\t\t    sockets[socknum].type != AUTH_CONNECTION)\n\t\t\t\tcontinue;\n\t\t\tif (pfd[i].fd == sockets[socknum].fd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (socknum >= sockets_alloc) {\n\t\t\terror_f(\"no socket for fd %d\", pfd[i].fd);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tswitch (sockets[socknum].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLERR)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %u >= limit %u); \"\n\t\t\t\t    \"skipping accept\", activefds, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (handle_socket_read(socknum) == 0)\n\t\t\t\tactivefds++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif ((pfd[i].revents & (POLLIN|POLLHUP|POLLERR)) != 0 &&\n\t\t\t    handle_conn_read(socknum) != 0)\n\t\t\t\tgoto close_sock;\n\t\t\tif ((pfd[i].revents & (POLLOUT|POLLHUP)) != 0 &&\n\t\t\t    handle_conn_write(socknum) != 0) {\n close_sock:\n\t\t\t\tif (activefds == 0)\n\t\t\t\t\tfatal(\"activefds == 0 at close_sock\");\n\t\t\t\tclose_socket(&sockets[socknum]);\n\t\t\t\tactivefds--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int\nprepare_poll(struct pollfd **pfdp, size_t *npfdp, int *timeoutp, u_int maxfds)\n{\n\tstruct pollfd *pfd = *pfdp;\n\tsize_t i, j, npfd = 0;\n\ttime_t deadline;\n\tint r;\n\n\t \n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tnpfd++;\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (npfd != *npfdp &&\n\t    (pfd = recallocarray(pfd, *npfdp, npfd, sizeof(*pfd))) == NULL)\n\t\tfatal_f(\"recallocarray failed\");\n\t*pfdp = pfd;\n\t*npfdp = npfd;\n\n\tfor (i = j = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\t\tif (npfd > maxfds) {\n\t\t\t\tdebug3(\"out of fds (active %zu >= limit %u); \"\n\t\t\t\t    \"skipping arming listener\", npfd, maxfds);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\tpfd[j].events = POLLIN;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tpfd[j].fd = sockets[i].fd;\n\t\t\tpfd[j].revents = 0;\n\t\t\t \n\t\t\tif ((r = sshbuf_check_reserve(sockets[i].input,\n\t\t\t    AGENT_RBUF_LEN)) == 0 &&\n\t\t\t    (r = sshbuf_check_reserve(sockets[i].output,\n\t\t\t    AGENT_MAX_LEN)) == 0)\n\t\t\t\tpfd[j].events = POLLIN;\n\t\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\t\tfatal_fr(r, \"reserve\");\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tpfd[j].events |= POLLOUT;\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*timeoutp = -1;  \n\t} else {\n\t\tif (deadline > INT_MAX / 1000)\n\t\t\t*timeoutp = INT_MAX / 1000;\n\t\telse\n\t\t\t*timeoutp = deadline * 1000;\n\t}\n\treturn (1);\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug_f(\"cleanup\");\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t \n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t \n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-O option] [-P allowed_providers] [-t life]\\n\"\n\t    \"       ssh-agent [-a bind_address] [-E fingerprint_hash] [-O option]\\n\"\n\t    \"                 [-P allowed_providers] [-t life] command [arg ...]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n#ifdef HAVE_SETRLIMIT\n\tstruct rlimit rlim;\n#endif\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1;  \n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t \n\tsanitise_stdfd();\n\n\t \n\t(void)setegid(getgid());\n\t(void)setgid(getgid());\n\n\tplatform_disable_tracing(0);\t \n\n#ifdef RLIMIT_NOFILE\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n#endif\n\n\t__progname = ssh_get_progname(av[0]);\n\tseed_rng();\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe = 0;\n\t\t\telse if (strcmp(optarg, \"allow-remote-pkcs11\") == 0)\n\t\t\t\tremote_add_provider = 1;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t \n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t \n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t \n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t \n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t \n\t\t*socket_name = '\\0';  \n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t \n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t \n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t \n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n#ifdef HAVE_SETRLIMIT\n\t \n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n#endif\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\tplatform_pledge_agent();\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t \n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}