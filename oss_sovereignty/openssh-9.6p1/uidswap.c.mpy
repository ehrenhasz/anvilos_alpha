{
  "module_name": "uidswap.c",
  "hash_id": "c526bc52e89c95f38c5702d8256673e0ef2ee9b8b449bba8eb0f9676a10a37b4",
  "original_prompt": "Ingested from openssh-9.6p1/uidswap.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <errno.h>\n#include <pwd.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n\n#include <grp.h>\n\n#include \"log.h\"\n#include \"uidswap.h\"\n#include \"xmalloc.h\"\n\n \n\n#if defined(_POSIX_SAVED_IDS) && !defined(BROKEN_SAVED_UIDS)\n \n#define SAVED_IDS_WORK_WITH_SETEUID\n \nstatic uid_t\tsaved_euid = 0;\nstatic gid_t\tsaved_egid = 0;\n#endif\n\n \nstatic int\tprivileged = 0;\nstatic int\ttemporarily_use_uid_effective = 0;\nstatic uid_t\tuser_groups_uid;\nstatic gid_t\t*saved_egroups = NULL, *user_groups = NULL;\nstatic int\tsaved_egroupslen = -1, user_groupslen = -1;\n\n \nvoid\ntemporarily_use_uid(struct passwd *pw)\n{\n\t \n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tsaved_euid = geteuid();\n\tsaved_egid = getegid();\n\tdebug(\"temporarily_use_uid: %u/%u (e=%u/%u)\",\n\t    (u_int)pw->pw_uid, (u_int)pw->pw_gid,\n\t    (u_int)saved_euid, (u_int)saved_egid);\n#ifndef HAVE_CYGWIN\n\tif (saved_euid != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif\n#else\n\tif (geteuid() != 0) {\n\t\tprivileged = 0;\n\t\treturn;\n\t}\n#endif  \n\n\tprivileged = 1;\n\ttemporarily_use_uid_effective = 1;\n\n\tsaved_egroupslen = getgroups(0, NULL);\n\tif (saved_egroupslen == -1)\n\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\tif (saved_egroupslen > 0) {\n\t\tsaved_egroups = xreallocarray(saved_egroups,\n\t\t    saved_egroupslen, sizeof(gid_t));\n\t\tif (getgroups(saved_egroupslen, saved_egroups) == -1)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t} else {  \n\t\tfree(saved_egroups);\n\t\tsaved_egroups = NULL;\n\t}\n\n\t \n\tif (user_groupslen == -1 || user_groups_uid != pw->pw_uid) {\n\t\tif (initgroups(pw->pw_name, pw->pw_gid) == -1)\n\t\t\tfatal(\"initgroups: %s: %.100s\", pw->pw_name,\n\t\t\t    strerror(errno));\n\n\t\tuser_groupslen = getgroups(0, NULL);\n\t\tif (user_groupslen == -1)\n\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\tif (user_groupslen > 0) {\n\t\t\tuser_groups = xreallocarray(user_groups,\n\t\t\t    user_groupslen, sizeof(gid_t));\n\t\t\tif (getgroups(user_groupslen, user_groups) == -1)\n\t\t\t\tfatal(\"getgroups: %.100s\", strerror(errno));\n\t\t} else {  \n\t\t\tfree(user_groups);\n\t\t\tuser_groups = NULL;\n\t\t}\n\t\tuser_groups_uid = pw->pw_uid;\n\t}\n\t \n\tif (setgroups(user_groupslen, user_groups) == -1)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n#ifndef SAVED_IDS_WORK_WITH_SETEUID\n\t \n\tif (setgid(getegid()) == -1)\n\t\tdebug(\"setgid %u: %.100s\", (u_int) getegid(), strerror(errno));\n\t \n\tif (setuid(geteuid()) == -1)\n\t\tdebug(\"setuid %u: %.100s\", (u_int) geteuid(), strerror(errno));\n#endif  \n\tif (setegid(pw->pw_gid) == -1)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)pw->pw_gid,\n\t\t    strerror(errno));\n\tif (seteuid(pw->pw_uid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)pw->pw_uid,\n\t\t    strerror(errno));\n}\n\n \nvoid\nrestore_uid(void)\n{\n\t \n\tif (!privileged) {\n\t\tdebug(\"restore_uid: (unprivileged)\");\n\t\treturn;\n\t}\n\tif (!temporarily_use_uid_effective)\n\t\tfatal(\"restore_uid: temporarily_use_uid not effective\");\n\n#ifdef SAVED_IDS_WORK_WITH_SETEUID\n\tdebug(\"restore_uid: %u/%u\", (u_int)saved_euid, (u_int)saved_egid);\n\t \n\tif (seteuid(saved_euid) == -1)\n\t\tfatal(\"seteuid %u: %.100s\", (u_int)saved_euid, strerror(errno));\n\tif (setegid(saved_egid) == -1)\n\t\tfatal(\"setegid %u: %.100s\", (u_int)saved_egid, strerror(errno));\n#else  \n\t \n\tif (setuid(getuid()) == -1)\n\t\tfatal(\"%s: setuid failed: %s\", __func__, strerror(errno));\n\tif (setgid(getgid()) == -1)\n\t\tfatal(\"%s: setgid failed: %s\", __func__, strerror(errno));\n#endif  \n\n\tif (setgroups(saved_egroupslen, saved_egroups) == -1)\n\t\tfatal(\"setgroups: %.100s\", strerror(errno));\n\ttemporarily_use_uid_effective = 0;\n}\n\n \nvoid\npermanently_set_uid(struct passwd *pw)\n{\n#ifndef NO_UID_RESTORATION_TEST\n\tuid_t old_uid = getuid();\n\tgid_t old_gid = getgid();\n#endif\n\n\tif (pw == NULL)\n\t\tfatal(\"permanently_set_uid: no user given\");\n\tif (temporarily_use_uid_effective)\n\t\tfatal(\"permanently_set_uid: temporarily_use_uid effective\");\n\tdebug(\"permanently_set_uid: %u/%u\", (u_int)pw->pw_uid,\n\t    (u_int)pw->pw_gid);\n\n\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)\n\t\tfatal(\"setresgid %u: %.100s\", (u_int)pw->pw_gid, strerror(errno));\n\n#ifdef __APPLE__\n\t \n\tif (initgroups(pw->pw_name, pw->pw_gid) == -1)\n\t\tfatal(\"initgroups %.100s %u: %.100s\",\n\t\t    pw->pw_name, (u_int)pw->pw_gid, strerror(errno));\n#endif\n\n\tif (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)\n\t\tfatal(\"setresuid %u: %.100s\", (u_int)pw->pw_uid, strerror(errno));\n\n#ifndef NO_UID_RESTORATION_TEST\n\t \n\tif (old_gid != pw->pw_gid && pw->pw_uid != 0 &&\n\t    (setgid(old_gid) != -1 || setegid(old_gid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]gid\", __func__);\n#endif\n\n\t \n\tif (getgid() != pw->pw_gid || getegid() != pw->pw_gid) {\n\t\tfatal(\"%s: egid incorrect gid:%u egid:%u (should be %u)\",\n\t\t    __func__, (u_int)getgid(), (u_int)getegid(),\n\t\t    (u_int)pw->pw_gid);\n\t}\n\n#ifndef NO_UID_RESTORATION_TEST\n\t \n\tif (old_uid != pw->pw_uid &&\n\t    (setuid(old_uid) != -1 || seteuid(old_uid) != -1))\n\t\tfatal(\"%s: was able to restore old [e]uid\", __func__);\n#endif\n\n\t \n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid) {\n\t\tfatal(\"%s: euid incorrect uid:%u euid:%u (should be %u)\",\n\t\t    __func__, (u_int)getuid(), (u_int)geteuid(),\n\t\t    (u_int)pw->pw_uid);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}