{
  "module_name": "sntrup761.c",
  "hash_id": "6c0212590ff27d6a763a7aebce599fe339c991db96c68b5a90e0b438d619cec3",
  "original_prompt": "Ingested from openssh-9.6p1/sntrup761.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#ifdef USE_SNTRUP761X25519\n\n#include <string.h>\n#include \"crypto_api.h\"\n\n#define int8 crypto_int8\n#define uint8 crypto_uint8\n#define int16 crypto_int16\n#define uint16 crypto_uint16\n#define int32 crypto_int32\n#define uint32 crypto_uint32\n#define int64 crypto_int64\n#define uint64 crypto_uint64\n\n \n#define int32_MINMAX(a,b) \\\ndo { \\\n  int64_t ab = (int64_t)b ^ (int64_t)a; \\\n  int64_t c = (int64_t)b - (int64_t)a; \\\n  c ^= ab & (c ^ b); \\\n  c >>= 31; \\\n  c &= ab; \\\n  a ^= c; \\\n  b ^= c; \\\n} while(0)\n\n \n\n\nstatic void crypto_sort_int32(void *array,long long n)\n{\n  long long top,p,q,r,i,j;\n  int32 *x = array;\n\n  if (n < 2) return;\n  top = 1;\n  while (top < n - top) top += top;\n\n  for (p = top;p >= 1;p >>= 1) {\n    i = 0;\n    while (i + 2 * p <= n) {\n      for (j = i;j < i + p;++j)\n        int32_MINMAX(x[j],x[j+p]);\n      i += 2 * p;\n    }\n    for (j = i;j < n - p;++j)\n      int32_MINMAX(x[j],x[j+p]);\n\n    i = 0;\n    j = 0;\n    for (q = top;q > p;q >>= 1) {\n      if (j != i) for (;;) {\n        if (j == n - q) goto done;\n        int32 a = x[j + p];\n        for (r = q;r > p;r >>= 1)\n          int32_MINMAX(a,x[j + r]);\n        x[j + p] = a;\n        ++j;\n        if (j == i + p) {\n          i += 2 * p;\n          break;\n        }\n      }\n      while (i + p <= n - q) {\n        for (j = i;j < i + p;++j) {\n          int32 a = x[j + p];\n          for (r = q;r > p;r >>= 1)\n            int32_MINMAX(a,x[j+r]);\n          x[j + p] = a;\n        }\n        i += 2 * p;\n      }\n       \n      j = i;\n      while (j < n - q) {\n        int32 a = x[j + p];\n        for (r = q;r > p;r >>= 1)\n          int32_MINMAX(a,x[j+r]);\n        x[j + p] = a;\n        ++j;\n      }\n\n      done: ;\n    }\n  }\n}\n\n \n\n \n \n\nstatic void crypto_sort_uint32(void *array,long long n)\n{\n  crypto_uint32 *x = array;\n  long long j;\n  for (j = 0;j < n;++j) x[j] ^= 0x80000000;\n  crypto_sort_int32(array,n);\n  for (j = 0;j < n;++j) x[j] ^= 0x80000000;\n}\n\n \n\n \n\nstatic void uint32_divmod_uint14(uint32 *q,uint16 *r,uint32 x,uint16 m)\n{\n  uint32 v = 0x80000000;\n  uint32 qpart;\n  uint32 mask;\n\n  v /= m;\n\n   \n   \n   \n   \n\n  *q = 0;\n\n  qpart = (x*(uint64)v)>>31;\n   \n   \n   \n   \n   \n   \n\n  x -= qpart*m; *q += qpart;\n   \n\n  qpart = (x*(uint64)v)>>31;\n   \n   \n   \n   \n\n  x -= qpart*m; *q += qpart;\n   \n\n  x -= m; *q += 1;\n  mask = -(x>>31);\n  x += mask&(uint32)m; *q += mask;\n   \n\n  *r = x;\n}\n\n\nstatic uint16 uint32_mod_uint14(uint32 x,uint16 m)\n{\n  uint32 q;\n  uint16 r;\n  uint32_divmod_uint14(&q,&r,x,m);\n  return r;\n}\n\n \n\nstatic void int32_divmod_uint14(int32 *q,uint16 *r,int32 x,uint16 m)\n{\n  uint32 uq,uq2;\n  uint16 ur,ur2;\n  uint32 mask;\n\n  uint32_divmod_uint14(&uq,&ur,0x80000000+(uint32)x,m);\n  uint32_divmod_uint14(&uq2,&ur2,0x80000000,m);\n  ur -= ur2; uq -= uq2;\n  mask = -(uint32)(ur>>15);\n  ur += mask&m; uq += mask;\n  *r = ur; *q = uq;\n}\n\n\nstatic uint16 int32_mod_uint14(int32 x,uint16 m)\n{\n  int32 q;\n  uint16 r;\n  int32_divmod_uint14(&q,&r,x,m);\n  return r;\n}\n\n \n \n#define SIZE761\n#undef SIZE653\n#undef SIZE857\n\n \n#define SNTRUP  \n#undef LPR  \n\n \n#ifndef params_H\n#define params_H\n\n \n\n\n \n\n#if defined(SIZE761)\n#define p 761\n#define q 4591\n#define Rounded_bytes 1007\n#ifndef LPR\n#define Rq_bytes 1158\n#define w 286\n#else\n#define w 250\n#define tau0 2156\n#define tau1 114\n#define tau2 2007\n#define tau3 287\n#endif\n\n#elif defined(SIZE653)\n#define p 653\n#define q 4621\n#define Rounded_bytes 865\n#ifndef LPR\n#define Rq_bytes 994\n#define w 288\n#else\n#define w 252\n#define tau0 2175\n#define tau1 113\n#define tau2 2031\n#define tau3 290\n#endif\n\n#elif defined(SIZE857)\n#define p 857\n#define q 5167\n#define Rounded_bytes 1152\n#ifndef LPR\n#define Rq_bytes 1322\n#define w 322\n#else\n#define w 281\n#define tau0 2433\n#define tau1 101\n#define tau2 2265\n#define tau3 324\n#endif\n\n#else\n#error \"no parameter set defined\"\n#endif\n\n#ifdef LPR\n#define I 256\n#endif\n\n#endif\n\n \n#ifndef Decode_H\n#define Decode_H\n\n\n \n \n \n\n#endif\n\n \n\nstatic void Decode(uint16 *out,const unsigned char *S,const uint16 *M,long long len)\n{\n  if (len == 1) {\n    if (M[0] == 1)\n      *out = 0;\n    else if (M[0] <= 256)\n      *out = uint32_mod_uint14(S[0],M[0]);\n    else\n      *out = uint32_mod_uint14(S[0]+(((uint16)S[1])<<8),M[0]);\n  }\n  if (len > 1) {\n    uint16 R2[(len+1)/2];\n    uint16 M2[(len+1)/2];\n    uint16 bottomr[len/2];\n    uint32 bottomt[len/2];\n    long long i;\n    for (i = 0;i < len-1;i += 2) {\n      uint32 m = M[i]*(uint32) M[i+1];\n      if (m > 256*16383) {\n        bottomt[i/2] = 256*256;\n        bottomr[i/2] = S[0]+256*S[1];\n        S += 2;\n        M2[i/2] = (((m+255)>>8)+255)>>8;\n      } else if (m >= 16384) {\n        bottomt[i/2] = 256;\n        bottomr[i/2] = S[0];\n        S += 1;\n        M2[i/2] = (m+255)>>8;\n      } else {\n        bottomt[i/2] = 1;\n        bottomr[i/2] = 0;\n        M2[i/2] = m;\n      }\n    }\n    if (i < len)\n      M2[i/2] = M[i];\n    Decode(R2,S,M2,(len+1)/2);\n    for (i = 0;i < len-1;i += 2) {\n      uint32 r = bottomr[i/2];\n      uint32 r1;\n      uint16 r0;\n      r += bottomt[i/2]*R2[i/2];\n      uint32_divmod_uint14(&r1,&r0,r,M[i]);\n      r1 = uint32_mod_uint14(r1,M[i+1]);  \n      *out++ = r0;\n      *out++ = r1;\n    }\n    if (i < len)\n      *out++ = R2[i/2];\n  }\n}\n\n \n#ifndef Encode_H\n#define Encode_H\n\n\n \n \n\n#endif\n\n \n\n \nstatic void Encode(unsigned char *out,const uint16 *R,const uint16 *M,long long len)\n{\n  if (len == 1) {\n    uint16 r = R[0];\n    uint16 m = M[0];\n    while (m > 1) {\n      *out++ = r;\n      r >>= 8;\n      m = (m+255)>>8;\n    }\n  }\n  if (len > 1) {\n    uint16 R2[(len+1)/2];\n    uint16 M2[(len+1)/2];\n    long long i;\n    for (i = 0;i < len-1;i += 2) {\n      uint32 m0 = M[i];\n      uint32 r = R[i]+R[i+1]*m0;\n      uint32 m = M[i+1]*m0;\n      while (m >= 16384) {\n        *out++ = r;\n        r >>= 8;\n        m = (m+255)>>8;\n      }\n      R2[i/2] = r;\n      M2[i/2] = m;\n    }\n    if (i < len) {\n      R2[i/2] = R[i];\n      M2[i/2] = M[i];\n    }\n    Encode(out,R2,M2,(len+1)/2);\n  }\n}\n\n \n\n#ifdef LPR\n#endif\n\n\n \n\n#ifndef LPR\n\n \nstatic int int16_nonzero_mask(int16 x)\n{\n  uint16 u = x;  \n  uint32 v = u;  \n  v = -v;  \n  v >>= 31;  \n  return -v;  \n}\n\n#endif\n\n \nstatic int int16_negative_mask(int16 x)\n{\n  uint16 u = x;\n  u >>= 15;\n  return -(int) u;\n   \n   \n}\n\n \n\ntypedef int8 small;\n\n \n \n\n \nstatic small F3_freeze(int16 x)\n{\n  return int32_mod_uint14(x+1,3)-1;\n}\n\n \n\n#define q12 ((q-1)/2)\ntypedef int16 Fq;\n \n \n\n \nstatic Fq Fq_freeze(int32 x)\n{\n  return int32_mod_uint14(x+q12,q)-q12;\n}\n\n#ifndef LPR\n\nstatic Fq Fq_recip(Fq a1)\n{\n  int i = 1;\n  Fq ai = a1;\n\n  while (i < q-2) {\n    ai = Fq_freeze(a1*(int32)ai);\n    i += 1;\n  }\n  return ai;\n}\n\n#endif\n\n \n\n#ifdef LPR\n#define tau 16\n\nstatic int8 Top(Fq C)\n{\n  return (tau1*(int32)(C+tau0)+16384)>>15;\n}\n\nstatic Fq Right(int8 T)\n{\n  return Fq_freeze(tau3*(int32)T-tau2);\n}\n#endif\n\n \n\n#ifndef LPR\n\n \nstatic int Weightw_mask(small *r)\n{\n  int weight = 0;\n  int i;\n\n  for (i = 0;i < p;++i) weight += r[i]&1;\n  return int16_nonzero_mask(weight-w);\n}\n\n \nstatic void R3_fromRq(small *out,const Fq *r)\n{\n  int i;\n  for (i = 0;i < p;++i) out[i] = F3_freeze(r[i]);\n}\n\n \nstatic void R3_mult(small *h,const small *f,const small *g)\n{\n  small fg[p+p-1];\n  small result;\n  int i,j;\n\n  for (i = 0;i < p;++i) {\n    result = 0;\n    for (j = 0;j <= i;++j) result = F3_freeze(result+f[j]*g[i-j]);\n    fg[i] = result;\n  }\n  for (i = p;i < p+p-1;++i) {\n    result = 0;\n    for (j = i-p+1;j < p;++j) result = F3_freeze(result+f[j]*g[i-j]);\n    fg[i] = result;\n  }\n\n  for (i = p+p-2;i >= p;--i) {\n    fg[i-p] = F3_freeze(fg[i-p]+fg[i]);\n    fg[i-p+1] = F3_freeze(fg[i-p+1]+fg[i]);\n  }\n\n  for (i = 0;i < p;++i) h[i] = fg[i];\n}\n\n \nstatic int R3_recip(small *out,const small *in)\n{\n  small f[p+1],g[p+1],v[p+1],r[p+1];\n  int i,loop,delta;\n  int sign,swap,t;\n\n  for (i = 0;i < p+1;++i) v[i] = 0;\n  for (i = 0;i < p+1;++i) r[i] = 0;\n  r[0] = 1;\n  for (i = 0;i < p;++i) f[i] = 0;\n  f[0] = 1; f[p-1] = f[p] = -1;\n  for (i = 0;i < p;++i) g[p-1-i] = in[i];\n  g[p] = 0;\n\n  delta = 1;\n\n  for (loop = 0;loop < 2*p-1;++loop) {\n    for (i = p;i > 0;--i) v[i] = v[i-1];\n    v[0] = 0;\n\n    sign = -g[0]*f[0];\n    swap = int16_negative_mask(-delta) & int16_nonzero_mask(g[0]);\n    delta ^= swap&(delta^-delta);\n    delta += 1;\n\n    for (i = 0;i < p+1;++i) {\n      t = swap&(f[i]^g[i]); f[i] ^= t; g[i] ^= t;\n      t = swap&(v[i]^r[i]); v[i] ^= t; r[i] ^= t;\n    }\n\n    for (i = 0;i < p+1;++i) g[i] = F3_freeze(g[i]+sign*f[i]);\n    for (i = 0;i < p+1;++i) r[i] = F3_freeze(r[i]+sign*v[i]);\n\n    for (i = 0;i < p;++i) g[i] = g[i+1];\n    g[p] = 0;\n  }\n\n  sign = f[0];\n  for (i = 0;i < p;++i) out[i] = sign*v[p-1-i];\n\n  return int16_nonzero_mask(delta);\n}\n\n#endif\n\n \n\n \nstatic void Rq_mult_small(Fq *h,const Fq *f,const small *g)\n{\n  Fq fg[p+p-1];\n  Fq result;\n  int i,j;\n\n  for (i = 0;i < p;++i) {\n    result = 0;\n    for (j = 0;j <= i;++j) result = Fq_freeze(result+f[j]*(int32)g[i-j]);\n    fg[i] = result;\n  }\n  for (i = p;i < p+p-1;++i) {\n    result = 0;\n    for (j = i-p+1;j < p;++j) result = Fq_freeze(result+f[j]*(int32)g[i-j]);\n    fg[i] = result;\n  }\n\n  for (i = p+p-2;i >= p;--i) {\n    fg[i-p] = Fq_freeze(fg[i-p]+fg[i]);\n    fg[i-p+1] = Fq_freeze(fg[i-p+1]+fg[i]);\n  }\n\n  for (i = 0;i < p;++i) h[i] = fg[i];\n}\n\n#ifndef LPR\n\n \nstatic void Rq_mult3(Fq *h,const Fq *f)\n{\n  int i;\n\n  for (i = 0;i < p;++i) h[i] = Fq_freeze(3*f[i]);\n}\n\n \n \nstatic int Rq_recip3(Fq *out,const small *in)\n{\n  Fq f[p+1],g[p+1],v[p+1],r[p+1];\n  int i,loop,delta;\n  int swap,t;\n  int32 f0,g0;\n  Fq scale;\n\n  for (i = 0;i < p+1;++i) v[i] = 0;\n  for (i = 0;i < p+1;++i) r[i] = 0;\n  r[0] = Fq_recip(3);\n  for (i = 0;i < p;++i) f[i] = 0;\n  f[0] = 1; f[p-1] = f[p] = -1;\n  for (i = 0;i < p;++i) g[p-1-i] = in[i];\n  g[p] = 0;\n\n  delta = 1;\n\n  for (loop = 0;loop < 2*p-1;++loop) {\n    for (i = p;i > 0;--i) v[i] = v[i-1];\n    v[0] = 0;\n\n    swap = int16_negative_mask(-delta) & int16_nonzero_mask(g[0]);\n    delta ^= swap&(delta^-delta);\n    delta += 1;\n\n    for (i = 0;i < p+1;++i) {\n      t = swap&(f[i]^g[i]); f[i] ^= t; g[i] ^= t;\n      t = swap&(v[i]^r[i]); v[i] ^= t; r[i] ^= t;\n    }\n\n    f0 = f[0];\n    g0 = g[0];\n    for (i = 0;i < p+1;++i) g[i] = Fq_freeze(f0*g[i]-g0*f[i]);\n    for (i = 0;i < p+1;++i) r[i] = Fq_freeze(f0*r[i]-g0*v[i]);\n\n    for (i = 0;i < p;++i) g[i] = g[i+1];\n    g[p] = 0;\n  }\n\n  scale = Fq_recip(f[0]);\n  for (i = 0;i < p;++i) out[i] = Fq_freeze(scale*(int32)v[p-1-i]);\n\n  return int16_nonzero_mask(delta);\n}\n\n#endif\n\n \n\nstatic void Round(Fq *out,const Fq *a)\n{\n  int i;\n  for (i = 0;i < p;++i) out[i] = a[i]-F3_freeze(a[i]);\n}\n\n \n\nstatic void Short_fromlist(small *out,const uint32 *in)\n{\n  uint32 L[p];\n  int i;\n\n  for (i = 0;i < w;++i) L[i] = in[i]&(uint32)-2;\n  for (i = w;i < p;++i) L[i] = (in[i]&(uint32)-3)|1;\n  crypto_sort_uint32(L,p);\n  for (i = 0;i < p;++i) out[i] = (L[i]&3)-1;\n}\n\n \n\n#define Hash_bytes 32\n\n \nstatic void Hash_prefix(unsigned char *out,int b,const unsigned char *in,int inlen)\n{\n  unsigned char x[inlen+1];\n  unsigned char h[64];\n  int i;\n\n  x[0] = b;\n  for (i = 0;i < inlen;++i) x[i+1] = in[i];\n  crypto_hash_sha512(h,x,inlen+1);\n  for (i = 0;i < 32;++i) out[i] = h[i];\n}\n\n \n\nstatic uint32 urandom32(void)\n{\n  unsigned char c[4];\n  uint32 out[4];\n\n  randombytes(c,4);\n  out[0] = (uint32)c[0];\n  out[1] = ((uint32)c[1])<<8;\n  out[2] = ((uint32)c[2])<<16;\n  out[3] = ((uint32)c[3])<<24;\n  return out[0]+out[1]+out[2]+out[3];\n}\n\nstatic void Short_random(small *out)\n{\n  uint32 L[p];\n  int i;\n\n  for (i = 0;i < p;++i) L[i] = urandom32();\n  Short_fromlist(out,L);\n}\n\n#ifndef LPR\n\nstatic void Small_random(small *out)\n{\n  int i;\n\n  for (i = 0;i < p;++i) out[i] = (((urandom32()&0x3fffffff)*3)>>30)-1;\n}\n\n#endif\n\n \n\n#ifndef LPR\n\n \nstatic void KeyGen(Fq *h,small *f,small *ginv)\n{\n  small g[p];\n  Fq finv[p];\n\n  for (;;) {\n    Small_random(g);\n    if (R3_recip(ginv,g) == 0) break;\n  }\n  Short_random(f);\n  Rq_recip3(finv,f);  \n  Rq_mult_small(h,finv,g);\n}\n\n \nstatic void Encrypt(Fq *c,const small *r,const Fq *h)\n{\n  Fq hr[p];\n\n  Rq_mult_small(hr,h,r);\n  Round(c,hr);\n}\n\n \nstatic void Decrypt(small *r,const Fq *c,const small *f,const small *ginv)\n{\n  Fq cf[p];\n  Fq cf3[p];\n  small e[p];\n  small ev[p];\n  int mask;\n  int i;\n\n  Rq_mult_small(cf,c,f);\n  Rq_mult3(cf3,cf);\n  R3_fromRq(e,cf3);\n  R3_mult(ev,e,ginv);\n\n  mask = Weightw_mask(ev);  \n  for (i = 0;i < w;++i) r[i] = ((ev[i]^1)&~mask)^1;\n  for (i = w;i < p;++i) r[i] = ev[i]&~mask;\n}\n\n#endif\n\n \n\n#ifdef LPR\n\n \nstatic void KeyGen(Fq *A,small *a,const Fq *G)\n{\n  Fq aG[p];\n\n  Short_random(a);\n  Rq_mult_small(aG,G,a);\n  Round(A,aG);\n}\n\n \nstatic void Encrypt(Fq *B,int8 *T,const int8 *r,const Fq *G,const Fq *A,const small *b)\n{\n  Fq bG[p];\n  Fq bA[p];\n  int i;\n\n  Rq_mult_small(bG,G,b);\n  Round(B,bG);\n  Rq_mult_small(bA,A,b);\n  for (i = 0;i < I;++i) T[i] = Top(Fq_freeze(bA[i]+r[i]*q12));\n}\n\n \nstatic void Decrypt(int8 *r,const Fq *B,const int8 *T,const small *a)\n{\n  Fq aB[p];\n  int i;\n\n  Rq_mult_small(aB,B,a);\n  for (i = 0;i < I;++i)\n    r[i] = -int16_negative_mask(Fq_freeze(Right(T[i])-aB[i]+4*w+1));\n}\n\n#endif\n\n \n\n#ifdef LPR\n\n#define Inputs_bytes (I/8)\ntypedef int8 Inputs[I];  \n\nstatic void Inputs_encode(unsigned char *s,const Inputs r)\n{\n  int i;\n  for (i = 0;i < Inputs_bytes;++i) s[i] = 0;\n  for (i = 0;i < I;++i) s[i>>3] |= r[i]<<(i&7);\n}\n\n#endif\n\n \n\n#ifdef LPR\n\nstatic const unsigned char aes_nonce[16] = {0};\n\nstatic void Expand(uint32 *L,const unsigned char *k)\n{\n  int i;\n  crypto_stream_aes256ctr((unsigned char *) L,4*p,aes_nonce,k);\n  for (i = 0;i < p;++i) {\n    uint32 L0 = ((unsigned char *) L)[4*i];\n    uint32 L1 = ((unsigned char *) L)[4*i+1];\n    uint32 L2 = ((unsigned char *) L)[4*i+2];\n    uint32 L3 = ((unsigned char *) L)[4*i+3];\n    L[i] = L0+(L1<<8)+(L2<<16)+(L3<<24);\n  }\n}\n\n#endif\n\n \n\n#ifdef LPR\n\n#define Seeds_bytes 32\n\nstatic void Seeds_random(unsigned char *s)\n{\n  randombytes(s,Seeds_bytes);\n}\n\n#endif\n\n \n\n#ifdef LPR\n\n \nstatic void Generator(Fq *G,const unsigned char *k)\n{\n  uint32 L[p];\n  int i;\n\n  Expand(L,k);\n  for (i = 0;i < p;++i) G[i] = uint32_mod_uint14(L[i],q)-q12;\n}\n\n \nstatic void HashShort(small *out,const Inputs r)\n{\n  unsigned char s[Inputs_bytes];\n  unsigned char h[Hash_bytes];\n  uint32 L[p];\n\n  Inputs_encode(s,r);\n  Hash_prefix(h,5,s,sizeof s);\n  Expand(L,h);\n  Short_fromlist(out,L);\n}\n\n#endif\n\n \n\n#ifdef LPR\n\n \nstatic void XKeyGen(unsigned char *S,Fq *A,small *a)\n{\n  Fq G[p];\n\n  Seeds_random(S);\n  Generator(G,S);\n  KeyGen(A,a,G);\n}\n\n \nstatic void XEncrypt(Fq *B,int8 *T,const int8 *r,const unsigned char *S,const Fq *A)\n{\n  Fq G[p];\n  small b[p];\n\n  Generator(G,S);\n  HashShort(b,r);\n  Encrypt(B,T,r,G,A,b);\n}\n\n#define XDecrypt Decrypt\n\n#endif\n\n \n\n#define Small_bytes ((p+3)/4)\n\n \n\nstatic void Small_encode(unsigned char *s,const small *f)\n{\n  small x;\n  int i;\n\n  for (i = 0;i < p/4;++i) {\n    x = *f++ + 1;\n    x += (*f++ + 1)<<2;\n    x += (*f++ + 1)<<4;\n    x += (*f++ + 1)<<6;\n    *s++ = x;\n  }\n  x = *f++ + 1;\n  *s++ = x;\n}\n\nstatic void Small_decode(small *f,const unsigned char *s)\n{\n  unsigned char x;\n  int i;\n\n  for (i = 0;i < p/4;++i) {\n    x = *s++;\n    *f++ = ((small)(x&3))-1; x >>= 2;\n    *f++ = ((small)(x&3))-1; x >>= 2;\n    *f++ = ((small)(x&3))-1; x >>= 2;\n    *f++ = ((small)(x&3))-1;\n  }\n  x = *s++;\n  *f++ = ((small)(x&3))-1;\n}\n\n \n\n#ifndef LPR\n\nstatic void Rq_encode(unsigned char *s,const Fq *r)\n{\n  uint16 R[p],M[p];\n  int i;\n\n  for (i = 0;i < p;++i) R[i] = r[i]+q12;\n  for (i = 0;i < p;++i) M[i] = q;\n  Encode(s,R,M,p);\n}\n\nstatic void Rq_decode(Fq *r,const unsigned char *s)\n{\n  uint16 R[p],M[p];\n  int i;\n\n  for (i = 0;i < p;++i) M[i] = q;\n  Decode(R,s,M,p);\n  for (i = 0;i < p;++i) r[i] = ((Fq)R[i])-q12;\n}\n\n#endif\n\n \n\nstatic void Rounded_encode(unsigned char *s,const Fq *r)\n{\n  uint16 R[p],M[p];\n  int i;\n\n  for (i = 0;i < p;++i) R[i] = ((r[i]+q12)*10923)>>15;\n  for (i = 0;i < p;++i) M[i] = (q+2)/3;\n  Encode(s,R,M,p);\n}\n\nstatic void Rounded_decode(Fq *r,const unsigned char *s)\n{\n  uint16 R[p],M[p];\n  int i;\n\n  for (i = 0;i < p;++i) M[i] = (q+2)/3;\n  Decode(R,s,M,p);\n  for (i = 0;i < p;++i) r[i] = R[i]*3-q12;\n}\n\n \n\n#ifdef LPR\n\n#define Top_bytes (I/2)\n\nstatic void Top_encode(unsigned char *s,const int8 *T)\n{\n  int i;\n  for (i = 0;i < Top_bytes;++i)\n    s[i] = T[2*i]+(T[2*i+1]<<4);\n}\n\nstatic void Top_decode(int8 *T,const unsigned char *s)\n{\n  int i;\n  for (i = 0;i < Top_bytes;++i) {\n    T[2*i] = s[i]&15;\n    T[2*i+1] = s[i]>>4;\n  }\n}\n\n#endif\n\n \n\n#ifndef LPR\n\ntypedef small Inputs[p];  \n#define Inputs_random Short_random\n#define Inputs_encode Small_encode\n#define Inputs_bytes Small_bytes\n\n#define Ciphertexts_bytes Rounded_bytes\n#define SecretKeys_bytes (2*Small_bytes)\n#define PublicKeys_bytes Rq_bytes\n\n \nstatic void ZKeyGen(unsigned char *pk,unsigned char *sk)\n{\n  Fq h[p];\n  small f[p],v[p];\n\n  KeyGen(h,f,v);\n  Rq_encode(pk,h);\n  Small_encode(sk,f); sk += Small_bytes;\n  Small_encode(sk,v);\n}\n\n \nstatic void ZEncrypt(unsigned char *C,const Inputs r,const unsigned char *pk)\n{\n  Fq h[p];\n  Fq c[p];\n  Rq_decode(h,pk);\n  Encrypt(c,r,h);\n  Rounded_encode(C,c);\n}\n\n \nstatic void ZDecrypt(Inputs r,const unsigned char *C,const unsigned char *sk)\n{\n  small f[p],v[p];\n  Fq c[p];\n\n  Small_decode(f,sk); sk += Small_bytes;\n  Small_decode(v,sk);\n  Rounded_decode(c,C);\n  Decrypt(r,c,f,v);\n}\n\n#endif\n\n \n\n#ifdef LPR\n\n#define Ciphertexts_bytes (Rounded_bytes+Top_bytes)\n#define SecretKeys_bytes Small_bytes\n#define PublicKeys_bytes (Seeds_bytes+Rounded_bytes)\n\nstatic void Inputs_random(Inputs r)\n{\n  unsigned char s[Inputs_bytes];\n  int i;\n\n  randombytes(s,sizeof s);\n  for (i = 0;i < I;++i) r[i] = 1&(s[i>>3]>>(i&7));\n}\n\n \nstatic void ZKeyGen(unsigned char *pk,unsigned char *sk)\n{\n  Fq A[p];\n  small a[p];\n\n  XKeyGen(pk,A,a); pk += Seeds_bytes;\n  Rounded_encode(pk,A);\n  Small_encode(sk,a);\n}\n\n \nstatic void ZEncrypt(unsigned char *c,const Inputs r,const unsigned char *pk)\n{\n  Fq A[p];\n  Fq B[p];\n  int8 T[I];\n\n  Rounded_decode(A,pk+Seeds_bytes);\n  XEncrypt(B,T,r,pk,A);\n  Rounded_encode(c,B); c += Rounded_bytes;\n  Top_encode(c,T);\n}\n\n \nstatic void ZDecrypt(Inputs r,const unsigned char *c,const unsigned char *sk)\n{\n  small a[p];\n  Fq B[p];\n  int8 T[I];\n\n  Small_decode(a,sk);\n  Rounded_decode(B,c);\n  Top_decode(T,c+Rounded_bytes);\n  XDecrypt(r,B,T,a);\n}\n\n#endif\n\n \n\n#define Confirm_bytes 32\n\n \nstatic void HashConfirm(unsigned char *h,const unsigned char *r,const unsigned char *pk,const unsigned char *cache)\n{\n#ifndef LPR\n  unsigned char x[Hash_bytes*2];\n  int i;\n\n  Hash_prefix(x,3,r,Inputs_bytes);\n  for (i = 0;i < Hash_bytes;++i) x[Hash_bytes+i] = cache[i];\n#else\n  unsigned char x[Inputs_bytes+Hash_bytes];\n  int i;\n\n  for (i = 0;i < Inputs_bytes;++i) x[i] = r[i];\n  for (i = 0;i < Hash_bytes;++i) x[Inputs_bytes+i] = cache[i];\n#endif\n  Hash_prefix(h,2,x,sizeof x);\n}\n\n \n\n \nstatic void HashSession(unsigned char *k,int b,const unsigned char *y,const unsigned char *z)\n{\n#ifndef LPR\n  unsigned char x[Hash_bytes+Ciphertexts_bytes+Confirm_bytes];\n  int i;\n\n  Hash_prefix(x,3,y,Inputs_bytes);\n  for (i = 0;i < Ciphertexts_bytes+Confirm_bytes;++i) x[Hash_bytes+i] = z[i];\n#else\n  unsigned char x[Inputs_bytes+Ciphertexts_bytes+Confirm_bytes];\n  int i;\n\n  for (i = 0;i < Inputs_bytes;++i) x[i] = y[i];\n  for (i = 0;i < Ciphertexts_bytes+Confirm_bytes;++i) x[Inputs_bytes+i] = z[i];\n#endif\n  Hash_prefix(k,b,x,sizeof x);\n}\n\n \n\n \nstatic void KEM_KeyGen(unsigned char *pk,unsigned char *sk)\n{\n  int i;\n\n  ZKeyGen(pk,sk); sk += SecretKeys_bytes;\n  for (i = 0;i < PublicKeys_bytes;++i) *sk++ = pk[i];\n  randombytes(sk,Inputs_bytes); sk += Inputs_bytes;\n  Hash_prefix(sk,4,pk,PublicKeys_bytes);\n}\n\n \nstatic void Hide(unsigned char *c,unsigned char *r_enc,const Inputs r,const unsigned char *pk,const unsigned char *cache)\n{\n  Inputs_encode(r_enc,r);\n  ZEncrypt(c,r,pk); c += Ciphertexts_bytes;\n  HashConfirm(c,r_enc,pk,cache);\n}\n\n \nstatic void Encap(unsigned char *c,unsigned char *k,const unsigned char *pk)\n{\n  Inputs r;\n  unsigned char r_enc[Inputs_bytes];\n  unsigned char cache[Hash_bytes];\n\n  Hash_prefix(cache,4,pk,PublicKeys_bytes);\n  Inputs_random(r);\n  Hide(c,r_enc,r,pk,cache);\n  HashSession(k,1,r_enc,c);\n}\n\n \nstatic int Ciphertexts_diff_mask(const unsigned char *c,const unsigned char *c2)\n{\n  uint16 differentbits = 0;\n  int len = Ciphertexts_bytes+Confirm_bytes;\n\n  while (len-- > 0) differentbits |= (*c++)^(*c2++);\n  return (1&((differentbits-1)>>8))-1;\n}\n\n \nstatic void Decap(unsigned char *k,const unsigned char *c,const unsigned char *sk)\n{\n  const unsigned char *pk = sk + SecretKeys_bytes;\n  const unsigned char *rho = pk + PublicKeys_bytes;\n  const unsigned char *cache = rho + Inputs_bytes;\n  Inputs r;\n  unsigned char r_enc[Inputs_bytes];\n  unsigned char cnew[Ciphertexts_bytes+Confirm_bytes];\n  int mask;\n  int i;\n\n  ZDecrypt(r,c,sk);\n  Hide(cnew,r_enc,r,pk,cache);\n  mask = Ciphertexts_diff_mask(c,cnew);\n  for (i = 0;i < Inputs_bytes;++i) r_enc[i] ^= mask&(r_enc[i]^rho[i]);\n  HashSession(k,1+mask,r_enc,c);\n}\n\n \n\n\nint crypto_kem_sntrup761_keypair(unsigned char *pk,unsigned char *sk)\n{\n  KEM_KeyGen(pk,sk);\n  return 0;\n}\n\nint crypto_kem_sntrup761_enc(unsigned char *c,unsigned char *k,const unsigned char *pk)\n{\n  Encap(c,k,pk);\n  return 0;\n}\n\nint crypto_kem_sntrup761_dec(unsigned char *k,const unsigned char *c,const unsigned char *sk)\n{\n  Decap(k,c,sk);\n  return 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}