{
  "module_name": "sftp-client.c",
  "hash_id": "1694e70c49ba78c0d583742c92eb032df89e57cdbd7a0126e9e414aa9a12e8e8",
  "original_prompt": "Ingested from openssh-9.6p1/sftp-client.c",
  "human_readable_source": " \n \n\n \n \n \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n#include \"openbsd-compat/sys-queue.h\"\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/uio.h>\n\n#include <dirent.h>\n#include <errno.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#include <fcntl.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"atomicio.h\"\n#include \"progressmeter.h\"\n#include \"misc.h\"\n#include \"utf8.h\"\n\n#include \"sftp.h\"\n#include \"sftp-common.h\"\n#include \"sftp-client.h\"\n\nextern volatile sig_atomic_t interrupted;\nextern int showprogress;\n\n \n#define DEFAULT_COPY_BUFLEN\t32768\n\n \n#define DEFAULT_NUM_REQUESTS\t64\n\n \n#define MIN_READ_SIZE\t512\n\n \n#define MAX_DIR_DEPTH 64\n\n \n#ifdef HAVE_CYGWIN\n# define SFTP_DIRECTORY_CHARS      \"/\\\\\"\n#else  \n# define SFTP_DIRECTORY_CHARS      \"/\"\n#endif  \n\nstruct sftp_conn {\n\tint fd_in;\n\tint fd_out;\n\tu_int download_buflen;\n\tu_int upload_buflen;\n\tu_int num_requests;\n\tu_int version;\n\tu_int msg_id;\n#define SFTP_EXT_POSIX_RENAME\t\t0x00000001\n#define SFTP_EXT_STATVFS\t\t0x00000002\n#define SFTP_EXT_FSTATVFS\t\t0x00000004\n#define SFTP_EXT_HARDLINK\t\t0x00000008\n#define SFTP_EXT_FSYNC\t\t\t0x00000010\n#define SFTP_EXT_LSETSTAT\t\t0x00000020\n#define SFTP_EXT_LIMITS\t\t\t0x00000040\n#define SFTP_EXT_PATH_EXPAND\t\t0x00000080\n#define SFTP_EXT_COPY_DATA\t\t0x00000100\n#define SFTP_EXT_GETUSERSGROUPS_BY_ID\t0x00000200\n\tu_int exts;\n\tu_int64_t limit_kbps;\n\tstruct bwlimit bwlimit_in, bwlimit_out;\n};\n\n \nstruct request {\n\tu_int id;\n\tsize_t len;\n\tu_int64_t offset;\n\tTAILQ_ENTRY(request) tq;\n};\nTAILQ_HEAD(requests, request);\n\nstatic u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...) __attribute__((format(printf, 4, 5)));\n\nstatic struct request *\nrequest_enqueue(struct requests *requests, u_int id, size_t len,\n    uint64_t offset)\n{\n\tstruct request *req;\n\n\treq = xcalloc(1, sizeof(*req));\n\treq->id = id;\n\treq->len = len;\n\treq->offset = offset;\n\tTAILQ_INSERT_TAIL(requests, req, tq);\n\treturn req;\n}\n\nstatic struct request *\nrequest_find(struct requests *requests, u_int id)\n{\n\tstruct request *req;\n\n\tfor (req = TAILQ_FIRST(requests);\n\t    req != NULL && req->id != id;\n\t    req = TAILQ_NEXT(req, tq))\n\t\t;\n\treturn req;\n}\n\nstatic int\nsftpio(void *_bwlimit, size_t amount)\n{\n\tstruct bwlimit *bwlimit = (struct bwlimit *)_bwlimit;\n\n\trefresh_progress_meter(0);\n\tif (bwlimit != NULL)\n\t\tbandwidth_limit(bwlimit, amount);\n\treturn 0;\n}\n\nstatic void\nsend_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tu_char mlen[4];\n\tstruct iovec iov[2];\n\n\tif (sshbuf_len(m) > SFTP_MAX_MSG_LENGTH)\n\t\tfatal(\"Outbound message too long %zu\", sshbuf_len(m));\n\n\t \n\tput_u32(mlen, sshbuf_len(m));\n\tiov[0].iov_base = mlen;\n\tiov[0].iov_len = sizeof(mlen);\n\tiov[1].iov_base = (u_char *)sshbuf_ptr(m);\n\tiov[1].iov_len = sshbuf_len(m);\n\n\tif (atomiciov6(writev, conn->fd_out, iov, 2, sftpio,\n\t    conn->limit_kbps > 0 ? &conn->bwlimit_out : NULL) !=\n\t    sshbuf_len(m) + sizeof(mlen))\n\t\tfatal(\"Couldn't send packet: %s\", strerror(errno));\n\n\tsshbuf_reset(m);\n}\n\nstatic void\nget_msg_extended(struct sftp_conn *conn, struct sshbuf *m, int initial)\n{\n\tu_int msg_len;\n\tu_char *p;\n\tint r;\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, 4, &p)) != 0)\n\t\tfatal_fr(r, \"reserve\");\n\tif (atomicio6(read, conn->fd_in, p, 4, sftpio,\n\t    conn->limit_kbps > 0 ? &conn->bwlimit_in : NULL) != 4) {\n\t\tif (errno == EPIPE || errno == ECONNRESET)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Couldn't read packet: %s\", strerror(errno));\n\t}\n\n\tif ((r = sshbuf_get_u32(m, &msg_len)) != 0)\n\t\tfatal_fr(r, \"sshbuf_get_u32\");\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\tdo_log2(initial ? SYSLOG_LEVEL_ERROR : SYSLOG_LEVEL_FATAL,\n\t\t    \"Received message too long %u\", msg_len);\n\t\tfatal(\"Ensure the remote shell produces no output \"\n\t\t    \"for non-interactive sessions.\");\n\t}\n\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal_fr(r, \"reserve\");\n\tif (atomicio6(read, conn->fd_in, p, msg_len, sftpio,\n\t    conn->limit_kbps > 0 ? &conn->bwlimit_in : NULL)\n\t    != msg_len) {\n\t\tif (errno == EPIPE)\n\t\t\tfatal(\"Connection closed\");\n\t\telse\n\t\t\tfatal(\"Read packet: %s\", strerror(errno));\n\t}\n}\n\nstatic void\nget_msg(struct sftp_conn *conn, struct sshbuf *m)\n{\n\tget_msg_extended(conn, m, 0);\n}\n\nstatic void\nsend_string_request(struct sftp_conn *conn, u_int id, u_int code, const char *s,\n    u_int len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u\", conn->fd_out, code, id);\n\tsshbuf_free(msg);\n}\n\nstatic void\nsend_string_attrs_request(struct sftp_conn *conn, u_int id, u_int code,\n    const void *s, u_int len, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, code)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, s, len)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fd %d T:%u I:%u F:0x%04x M:%05o\",\n\t    conn->fd_out, code, id, a->flags, a->perm);\n\tsshbuf_free(msg);\n}\n\nstatic u_int\nget_status(struct sftp_conn *conn, u_int expected_id)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type != SSH2_FXP_STATUS)\n\t\tfatal(\"Expected SSH2_FXP_STATUS(%u) packet, got %u\",\n\t\t    SSH2_FXP_STATUS, type);\n\n\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsshbuf_free(msg);\n\n\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\treturn status;\n}\n\nstatic u_char *\nget_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n    const char *errfmt, ...)\n{\n\tstruct sshbuf *msg;\n\tu_int id, status;\n\tu_char type;\n\tu_char *handle;\n\tchar errmsg[256];\n\tva_list args;\n\tint r;\n\n\tva_start(args, errfmt);\n\tif (errfmt != NULL)\n\t\tvsnprintf(errmsg, sizeof(errmsg), errfmt, args);\n\tva_end(args);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (id != expected_id)\n\t\tfatal(\"%s: ID mismatch (%u != %u)\",\n\t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal_fr(r, \"parse status\");\n\t\tif (errfmt != NULL)\n\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_HANDLE)\n\t\tfatal(\"%s: Expected SSH2_FXP_HANDLE(%u) packet, got %u\",\n\t\t    errfmt == NULL ? __func__ : errmsg, SSH2_FXP_HANDLE, type);\n\n\tif ((r = sshbuf_get_string(msg, &handle, len)) != 0)\n\t\tfatal_fr(r, \"parse handle\");\n\tsshbuf_free(msg);\n\n\treturn handle;\n}\n\nstatic int\nget_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tu_char type;\n\tint r;\n\tAttrib attr;\n\n\tif (a != NULL)\n\t\tmemset(a, '\\0', sizeof(*a));\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal_fr(r, \"parse status\");\n\t\tif (quiet)\n\t\t\tdebug(\"stat remote: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"stat remote: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_ATTRS) {\n\t\tfatal(\"Expected SSH2_FXP_ATTRS(%u) packet, got %u\",\n\t\t    SSH2_FXP_ATTRS, type);\n\t}\n\tif ((r = decode_attrib(msg, &attr)) != 0) {\n\t\terror_fr(r, \"decode_attrib\");\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\t \n\tif (a != NULL)\n\t\t*a = attr;\n\tdebug3(\"Received stat reply T:%u I:%u F:0x%04x M:%05o\",\n\t    type, id, attr.flags, attr.perm);\n\tsshbuf_free(msg);\n\n\treturn 0;\n}\n\nstatic int\nget_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n    u_int expected_id, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id;\n\tu_int64_t flag;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"Received statvfs reply T:%u I:%u\", type, id);\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal_fr(r, \"parse status\");\n\t\tif (quiet)\n\t\t\tdebug(\"remote statvfs: %s\", fx2txt(status));\n\t\telse\n\t\t\terror(\"remote statvfs: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t}\n\n\tmemset(st, 0, sizeof(*st));\n\tif ((r = sshbuf_get_u64(msg, &st->f_bsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_frsize)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_blocks)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bfree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_bavail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_files)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_ffree)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_favail)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_fsid)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &flag)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &st->f_namemax)) != 0)\n\t\tfatal_fr(r, \"parse statvfs\");\n\n\tst->f_flag = (flag & SSH2_FXE_STATVFS_ST_RDONLY) ? ST_RDONLY : 0;\n\tst->f_flag |= (flag & SSH2_FXE_STATVFS_ST_NOSUID) ? ST_NOSUID : 0;\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}\n\nstruct sftp_conn *\nsftp_init(int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests,\n    u_int64_t limit_kbps)\n{\n\tu_char type;\n\tstruct sshbuf *msg;\n\tstruct sftp_conn *ret;\n\tint r;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->msg_id = 1;\n\tret->fd_in = fd_in;\n\tret->fd_out = fd_out;\n\tret->download_buflen = ret->upload_buflen =\n\t    transfer_buflen ? transfer_buflen : DEFAULT_COPY_BUFLEN;\n\tret->num_requests =\n\t    num_requests ? num_requests : DEFAULT_NUM_REQUESTS;\n\tret->exts = 0;\n\tret->limit_kbps = 0;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_INIT)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tsend_msg(ret, msg);\n\n\tget_msg_extended(ret, msg, 1);\n\n\t \n\tif ((r = sshbuf_get_u8(msg, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\tif (type != SSH2_FXP_VERSION) {\n\t\terror(\"Invalid packet back from SSH2_FXP_INIT (type %u)\",\n\t\t    type);\n\t\tsshbuf_free(msg);\n\t\tfree(ret);\n\t\treturn(NULL);\n\t}\n\tif ((r = sshbuf_get_u32(msg, &ret->version)) != 0)\n\t\tfatal_fr(r, \"parse version\");\n\n\tdebug2(\"Remote version: %u\", ret->version);\n\n\t \n\twhile (sshbuf_len(msg) > 0) {\n\t\tchar *name;\n\t\tu_char *value;\n\t\tsize_t vlen;\n\t\tint known = 0;\n\n\t\tif ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_get_string(msg, &value, &vlen)) != 0)\n\t\t\tfatal_fr(r, \"parse extension\");\n\t\tif (strcmp(name, \"posix-rename@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_POSIX_RENAME;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"statvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_STATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fstatvfs@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"2\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSTATVFS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"hardlink@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_HARDLINK;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"fsync@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_FSYNC;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"lsetstat@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_LSETSTAT;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"limits@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_LIMITS;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"expand-path@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_PATH_EXPAND;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name, \"copy-data\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_COPY_DATA;\n\t\t\tknown = 1;\n\t\t} else if (strcmp(name,\n\t\t    \"users-groups-by-id@openssh.com\") == 0 &&\n\t\t    strcmp((char *)value, \"1\") == 0) {\n\t\t\tret->exts |= SFTP_EXT_GETUSERSGROUPS_BY_ID;\n\t\t\tknown = 1;\n\t\t}\n\t\tif (known) {\n\t\t\tdebug2(\"Server supports extension \\\"%s\\\" revision %s\",\n\t\t\t    name, value);\n\t\t} else {\n\t\t\tdebug2(\"Unrecognised server extension \\\"%s\\\"\", name);\n\t\t}\n\t\tfree(name);\n\t\tfree(value);\n\t}\n\n\tsshbuf_free(msg);\n\n\t \n\tif (ret->exts & SFTP_EXT_LIMITS) {\n\t\tstruct sftp_limits limits;\n\t\tif (sftp_get_limits(ret, &limits) != 0)\n\t\t\tfatal_f(\"limits failed\");\n\n\t\t \n\t\tif (transfer_buflen == 0) {\n\t\t\tret->download_buflen = MINIMUM(limits.read_length,\n\t\t\t    SFTP_MAX_MSG_LENGTH - 1024);\n\t\t\tret->upload_buflen = MINIMUM(limits.write_length,\n\t\t\t    SFTP_MAX_MSG_LENGTH - 1024);\n\t\t\tret->download_buflen = MAXIMUM(ret->download_buflen, 64);\n\t\t\tret->upload_buflen = MAXIMUM(ret->upload_buflen, 64);\n\t\t\tdebug3(\"server upload/download buffer sizes \"\n\t\t\t    \"%llu / %llu; using %u / %u\",\n\t\t\t    (unsigned long long)limits.write_length,\n\t\t\t    (unsigned long long)limits.read_length,\n\t\t\t    ret->upload_buflen, ret->download_buflen);\n\t\t}\n\n\t\t \n\t\tif (num_requests == 0 && limits.open_handles) {\n\t\t\tret->num_requests =\n\t\t\t    MINIMUM(DEFAULT_NUM_REQUESTS, limits.open_handles);\n\t\t\tif (ret->num_requests == 0)\n\t\t\t\tret->num_requests = 1;\n\t\t\tdebug3(\"server handle limit %llu; using %u\",\n\t\t\t    (unsigned long long)limits.open_handles,\n\t\t\t    ret->num_requests);\n\t\t}\n\t}\n\n\t \n\tif (ret->version == 0) {\n\t\tret->download_buflen = MINIMUM(ret->download_buflen, 20480);\n\t\tret->upload_buflen = MINIMUM(ret->upload_buflen, 20480);\n\t}\n\n\tret->limit_kbps = limit_kbps;\n\tif (ret->limit_kbps > 0) {\n\t\tbandwidth_limit_init(&ret->bwlimit_in, ret->limit_kbps,\n\t\t    ret->download_buflen);\n\t\tbandwidth_limit_init(&ret->bwlimit_out, ret->limit_kbps,\n\t\t    ret->upload_buflen);\n\t}\n\n\treturn ret;\n}\n\nu_int\nsftp_proto_version(struct sftp_conn *conn)\n{\n\treturn conn->version;\n}\n\nint\nsftp_get_limits(struct sftp_conn *conn, struct sftp_limits *limits)\n{\n\tu_int id, msg_id;\n\tu_char type;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_LIMITS) == 0) {\n\t\terror(\"Server does not support limits@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"limits@openssh.com\")) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message limits@openssh.com I:%u\", id);\n\n\tget_msg(conn, msg);\n\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &msg_id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"Received limits reply T:%u I:%u\", type, msg_id);\n\tif (id != msg_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", msg_id, id);\n\tif (type != SSH2_FXP_EXTENDED_REPLY) {\n\t\tdebug_f(\"expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\t\t \n\t\tconn->exts &= ~SFTP_EXT_LIMITS;\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tmemset(limits, 0, sizeof(*limits));\n\tif ((r = sshbuf_get_u64(msg, &limits->packet_length)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &limits->read_length)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &limits->write_length)) != 0 ||\n\t    (r = sshbuf_get_u64(msg, &limits->open_handles)) != 0)\n\t\tfatal_fr(r, \"parse limits\");\n\n\tsshbuf_free(msg);\n\n\treturn 0;\n}\n\nint\nsftp_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n{\n\tu_int id, status;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"close remote: %s\", fx2txt(status));\n\n\tsshbuf_free(msg);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\n\nstatic int\nsftp_lsreaddir(struct sftp_conn *conn, const char *path, int print_flag,\n    SFTP_DIRENT ***dir)\n{\n\tstruct sshbuf *msg;\n\tu_int count, id, i, expected_id, ents = 0;\n\tsize_t handle_len;\n\tu_char type, *handle;\n\tint status = SSH2_FX_FAILURE;\n\tint r;\n\n\tif (dir)\n\t\t*dir = NULL;\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal_fr(r, \"compose OPENDIR\");\n\tsend_msg(conn, msg);\n\n\thandle = get_handle(conn, id, &handle_len,\n\t    \"remote readdir(\\\"%s\\\")\", path);\n\tif (handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\tif (dir) {\n\t\tents = 0;\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t(*dir)[0] = NULL;\n\t}\n\n\tfor (; !interrupted;) {\n\t\tid = expected_id = conn->msg_id++;\n\n\t\tdebug3(\"Sending SSH2_FXP_READDIR I:%u\", id);\n\n\t\tsshbuf_reset(msg);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\t\tfatal_fr(r, \"compose READDIR\");\n\t\tsend_msg(conn, msg);\n\n\t\tsshbuf_reset(msg);\n\n\t\tget_msg(conn, msg);\n\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal_fr(r, \"parse\");\n\n\t\tdebug3(\"Received reply T:%u I:%u\", type, id);\n\n\t\tif (id != expected_id)\n\t\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\t\tif (type == SSH2_FXP_STATUS) {\n\t\t\tu_int rstatus;\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &rstatus)) != 0)\n\t\t\t\tfatal_fr(r, \"parse status\");\n\t\t\tdebug3(\"Received SSH2_FXP_STATUS %d\", rstatus);\n\t\t\tif (rstatus == SSH2_FX_EOF)\n\t\t\t\tbreak;\n\t\t\terror(\"Couldn't read directory: %s\", fx2txt(rstatus));\n\t\t\tgoto out;\n\t\t} else if (type != SSH2_FXP_NAME)\n\t\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_NAME, type);\n\n\t\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\t\tfatal_fr(r, \"parse count\");\n\t\tif (count > SSHBUF_SIZE_MAX)\n\t\t\tfatal_f(\"nonsensical number of entries\");\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\tdebug3(\"Received %d SSH2_FXP_NAME responses\", count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tchar *filename, *longname;\n\t\t\tAttrib a;\n\n\t\t\tif ((r = sshbuf_get_cstring(msg, &filename,\n\t\t\t    NULL)) != 0 ||\n\t\t\t    (r = sshbuf_get_cstring(msg, &longname,\n\t\t\t    NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse filenames\");\n\t\t\tif ((r = decode_attrib(msg, &a)) != 0) {\n\t\t\t\terror_fr(r, \"couldn't decode attrib\");\n\t\t\t\tfree(filename);\n\t\t\t\tfree(longname);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (print_flag)\n\t\t\t\tmprintf(\"%s\\n\", longname);\n\n\t\t\t \n\t\t\tif (strpbrk(filename, SFTP_DIRECTORY_CHARS) != NULL) {\n\t\t\t\terror(\"Server sent suspect path \\\"%s\\\" \"\n\t\t\t\t    \"during readdir of \\\"%s\\\"\", filename, path);\n\t\t\t} else if (dir) {\n\t\t\t\t*dir = xreallocarray(*dir, ents + 2, sizeof(**dir));\n\t\t\t\t(*dir)[ents] = xcalloc(1, sizeof(***dir));\n\t\t\t\t(*dir)[ents]->filename = xstrdup(filename);\n\t\t\t\t(*dir)[ents]->longname = xstrdup(longname);\n\t\t\t\tmemcpy(&(*dir)[ents]->a, &a, sizeof(a));\n\t\t\t\t(*dir)[++ents] = NULL;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tfree(longname);\n\t\t}\n\t}\n\tstatus = 0;\n\n out:\n\tsshbuf_free(msg);\n\tsftp_close(conn, handle, handle_len);\n\tfree(handle);\n\n\tif (status != 0 && dir != NULL) {\n\t\t \n\t\tsftp_free_dirents(*dir);\n\t\t*dir = NULL;\n\t} else if (interrupted && dir != NULL && *dir != NULL) {\n\t\t \n\t\tsftp_free_dirents(*dir);\n\t\t*dir = xcalloc(1, sizeof(**dir));\n\t\t**dir = NULL;\n\t}\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_readdir(struct sftp_conn *conn, const char *path, SFTP_DIRENT ***dir)\n{\n\treturn sftp_lsreaddir(conn, path, 0, dir);\n}\n\nvoid sftp_free_dirents(SFTP_DIRENT **s)\n{\n\tint i;\n\n\tif (s == NULL)\n\t\treturn;\n\tfor (i = 0; s[i]; i++) {\n\t\tfree(s[i]->filename);\n\t\tfree(s[i]->longname);\n\t\tfree(s[i]);\n\t}\n\tfree(s);\n}\n\nint\nsftp_rm(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_REMOVE \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote delete %s: %s\", path, fx2txt(status));\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_mkdir(struct sftp_conn *conn, const char *path, Attrib *a, int print_flag)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_MKDIR \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK && print_flag)\n\t\terror(\"remote mkdir \\\"%s\\\": %s\", path, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_rmdir(struct sftp_conn *conn, const char *path)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_RMDIR \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_RMDIR, path,\n\t    strlen(path));\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote rmdir \\\"%s\\\": %s\", path, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_stat(struct sftp_conn *conn, const char *path, int quiet, Attrib *a)\n{\n\tu_int id;\n\n\tdebug2(\"Sending SSH2_FXP_STAT \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\n\tsend_string_request(conn, id,\n\t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n\t    path, strlen(path));\n\n\treturn get_decode_stat(conn, id, quiet, a);\n}\n\nint\nsftp_lstat(struct sftp_conn *conn, const char *path, int quiet, Attrib *a)\n{\n\tu_int id;\n\n\tif (conn->version == 0) {\n\t\tdo_log2(quiet ? SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_INFO,\n\t\t    \"Server version does not support lstat operation\");\n\t\treturn sftp_stat(conn, path, quiet, a);\n\t}\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_LSTAT, path,\n\t    strlen(path));\n\n\treturn get_decode_stat(conn, id, quiet, a);\n}\n\n#ifdef notyet\nint\nsftp_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    int quiet, Attrib *a)\n{\n\tu_int id;\n\n\tdebug2(\"Sending SSH2_FXP_FSTAT \\\"%s\\\"\");\n\n\tid = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_FSTAT, handle,\n\t    handle_len);\n\n\treturn get_decode_stat(conn, id, quiet, a);\n}\n#endif\n\nint\nsftp_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_SETSTAT \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path,\n\t    strlen(path), a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote setstat \\\"%s\\\": %s\", path, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    Attrib *a)\n{\n\tu_int status, id;\n\n\tdebug2(\"Sending SSH2_FXP_FSETSTAT\");\n\n\tid = conn->msg_id++;\n\tsend_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle,\n\t    handle_len, a);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote fsetstat: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\n \nstatic char *\nsftp_realpath_expand(struct sftp_conn *conn, const char *path, int expand)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\tconst char *what = \"SSH2_FXP_REALPATH\";\n\n\tif (expand)\n\t\twhat = \"expand-path@openssh.com\";\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\texpected_id = id = conn->msg_id++;\n\tif (expand) {\n\t\tdebug2(\"Sending SSH2_FXP_EXTENDED(expand-path@openssh.com) \"\n\t\t    \"\\\"%s\\\"\", path);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg,\n\t\t    \"expand-path@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\t\tfatal_fr(r, \"compose %s\", what);\n\t\tsend_msg(conn, msg);\n\t} else {\n\t\tdebug2(\"Sending SSH2_FXP_REALPATH \\\"%s\\\"\", path);\n\t\tsend_string_request(conn, id, SSH2_FXP_REALPATH,\n\t\t    path, strlen(path));\n\t}\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\t\tchar *errmsg;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(msg, &errmsg, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse status\");\n\t\terror(\"%s %s: %s\", expand ? \"expand\" : \"realpath\",\n\t\t    path, *errmsg == '\\0' ? fx2txt(status) : errmsg);\n\t\tfree(errmsg);\n\t\tsshbuf_free(msg);\n\t\treturn NULL;\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal_fr(r, \"parse count\");\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from %s\", count, what);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal_fr(r, \"parse filename/attrib\");\n\n\tdebug3(\"%s %s -> %s\", what, path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn(filename);\n}\n\nchar *\nsftp_realpath(struct sftp_conn *conn, const char *path)\n{\n\treturn sftp_realpath_expand(conn, path, 0);\n}\n\nint\nsftp_can_expand_path(struct sftp_conn *conn)\n{\n\treturn (conn->exts & SFTP_EXT_PATH_EXPAND) != 0;\n}\n\nchar *\nsftp_expand_path(struct sftp_conn *conn, const char *path)\n{\n\tif (!sftp_can_expand_path(conn)) {\n\t\tdebug3_f(\"no server support, fallback to realpath\");\n\t\treturn sftp_realpath_expand(conn, path, 0);\n\t}\n\treturn sftp_realpath_expand(conn, path, 1);\n}\n\nint\nsftp_copy(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tAttrib junk, attr;\n\tstruct sshbuf *msg;\n\tu_char *old_handle, *new_handle;\n\tu_int mode, status, id;\n\tsize_t old_handle_len, new_handle_len;\n\tint r;\n\n\t \n\tif ((conn->exts & SFTP_EXT_COPY_DATA) == 0) {\n\t\terror(\"Server does not support copy-data extension\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (sftp_stat(conn, oldpath, 0, &attr) != 0)\n\t\treturn -1;\n\n\t \n\tif (attr.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tmode = attr.perm & 0777;\n\n\t\tif (!S_ISREG(attr.perm)) {\n\t\t\terror(\"Cannot copy non-regular file: %s\", oldpath);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t \n\t\tmode = 0666;\n\t}\n\n\t \n\tattrib_clear(&attr);\n\tattr.perm = mode;\n\tattr.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\n\tattrib_clear(&junk);  \n\n\t \n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_READ)) != 0 ||\n\t    (r = encode_attrib(msg, &junk)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, oldpath);\n\n\tsshbuf_reset(msg);\n\n\told_handle = get_handle(conn, id, &old_handle_len,\n\t    \"remote open(\\\"%s\\\")\", oldpath);\n\tif (old_handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\treturn -1;\n\t}\n\n\t \n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FXF_WRITE|SSH2_FXF_CREAT|\n\t    SSH2_FXF_TRUNC)) != 0 ||\n\t    (r = encode_attrib(msg, &attr)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, newpath);\n\n\tsshbuf_reset(msg);\n\n\tnew_handle = get_handle(conn, id, &new_handle_len,\n\t    \"remote open(\\\"%s\\\")\", newpath);\n\tif (new_handle == NULL) {\n\t\tsshbuf_free(msg);\n\t\tfree(old_handle);\n\t\treturn -1;\n\t}\n\n\t \n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"copy-data\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, old_handle, old_handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_string(msg, new_handle, new_handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, 0)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message copy-data \\\"%s\\\" 0 0 -> \\\"%s\\\" 0\",\n\t       oldpath, newpath);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"Couldn't copy file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\t \n\tsshbuf_free(msg);\n\tsftp_close(conn, old_handle, old_handle_len);\n\tsftp_close(conn, new_handle, new_handle_len);\n\tfree(old_handle);\n\tfree(new_handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath,\n    int force_legacy)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\t \n\tid = conn->msg_id++;\n\tif (use_ext) {\n\t\tdebug2(\"Sending SSH2_FXP_EXTENDED(posix-rename@openssh.com) \"\n\t\t    \"\\\"%s\\\" to \\\"%s\\\"\", oldpath, newpath);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg,\n\t\t    \"posix-rename@openssh.com\")) != 0)\n\t\t\tfatal_fr(r, \"compose posix-rename\");\n\t} else {\n\t\tdebug2(\"Sending SSH2_FXP_RENAME \\\"%s\\\" to \\\"%s\\\"\",\n\t\t    oldpath, newpath);\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, id)) != 0)\n\t\t\tfatal_fr(r, \"compose rename\");\n\t}\n\tif ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal_fr(r, \"compose paths\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\",\n\t    use_ext ? \"posix-rename@openssh.com\" :\n\t    \"SSH2_FXP_RENAME\", oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote rename \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_HARDLINK) == 0) {\n\t\terror(\"Server does not support hardlink@openssh.com extension\");\n\t\treturn -1;\n\t}\n\tdebug2(\"Sending SSH2_FXP_EXTENDED(hardlink@openssh.com) \"\n\t    \"\\\"%s\\\" to \\\"%s\\\"\", oldpath, newpath);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\t \n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"hardlink@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message hardlink@openssh.com \\\"%s\\\" -> \\\"%s\\\"\",\n\t    oldpath, newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote link \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif (conn->version < 3) {\n\t\terror(\"This server does not support the symlink operation\");\n\t\treturn(SSH2_FX_OP_UNSUPPORTED);\n\t}\n\tdebug2(\"Sending SSH2_FXP_SYMLINK \\\"%s\\\" to \\\"%s\\\"\", oldpath, newpath);\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\t \n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message SSH2_FXP_SYMLINK \\\"%s\\\" -> \\\"%s\\\"\", oldpath,\n\t    newpath);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote symlink file \\\"%s\\\" to \\\"%s\\\": %s\", oldpath,\n\t\t    newpath, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nint\nsftp_fsync(struct sftp_conn *conn, u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\t \n\tif ((conn->exts & SFTP_EXT_FSYNC) == 0)\n\t\treturn -1;\n\tdebug2(\"Sending SSH2_FXP_EXTENDED(fsync@openssh.com)\");\n\n\t \n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fsync@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tdebug3(\"Sent message fsync@openssh.com I:%u\", id);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote fsync: %s\", fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\n#ifdef notyet\nchar *\nsftp_readlink(struct sftp_conn *conn, const char *path)\n{\n\tstruct sshbuf *msg;\n\tu_int expected_id, count, id;\n\tchar *filename, *longname;\n\tAttrib a;\n\tu_char type;\n\tint r;\n\n\tdebug2(\"Sending SSH2_FXP_READLINK \\\"%s\\\"\", path);\n\n\texpected_id = id = conn->msg_id++;\n\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal_fr(r, \"parse status\");\n\t\terror(\"Couldn't readlink: %s\", fx2txt(status));\n\t\tsshbuf_free(msg);\n\t\treturn(NULL);\n\t} else if (type != SSH2_FXP_NAME)\n\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n\t\t    SSH2_FXP_NAME, type);\n\n\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n\t\tfatal_fr(r, \"parse count\");\n\tif (count != 1)\n\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n\n\tif ((r = sshbuf_get_cstring(msg, &filename, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(msg, &longname, NULL)) != 0 ||\n\t    (r = decode_attrib(msg, &a)) != 0)\n\t\tfatal_fr(r, \"parse filenames/attrib\");\n\n\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, filename);\n\n\tfree(longname);\n\n\tsshbuf_free(msg);\n\n\treturn filename;\n}\n#endif\n\nint\nsftp_statvfs(struct sftp_conn *conn, const char *path, struct sftp_statvfs *st,\n    int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_STATVFS) == 0) {\n\t\terror(\"Server does not support statvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tdebug2(\"Sending SSH2_FXP_EXTENDED(statvfs@openssh.com) \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"statvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}\n\n#ifdef notyet\nint\nsftp_fstatvfs(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n    struct sftp_statvfs *st, int quiet)\n{\n\tstruct sshbuf *msg;\n\tu_int id;\n\n\tif ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {\n\t\terror(\"Server does not support fstatvfs@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tdebug2(\"Sending SSH2_FXP_EXTENDED(fstatvfs@openssh.com)\");\n\n\tid = conn->msg_id++;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"fstatvfs@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\treturn get_decode_statvfs(conn, st, id, quiet);\n}\n#endif\n\nint\nsftp_lsetstat(struct sftp_conn *conn, const char *path, Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tu_int status, id;\n\tint r;\n\n\tif ((conn->exts & SFTP_EXT_LSETSTAT) == 0) {\n\t\terror(\"Server does not support lsetstat@openssh.com extension\");\n\t\treturn -1;\n\t}\n\n\tdebug2(\"Sending SSH2_FXP_EXTENDED(lsetstat@openssh.com) \\\"%s\\\"\", path);\n\n\tid = conn->msg_id++;\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, \"lsetstat@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\n\tstatus = get_status(conn, id);\n\tif (status != SSH2_FX_OK)\n\t\terror(\"remote lsetstat \\\"%s\\\": %s\", path, fx2txt(status));\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nstatic void\nsend_read_request(struct sftp_conn *conn, u_int id, u_int64_t offset,\n    u_int len, const u_char *handle, u_int handle_len)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, len)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n}\n\nstatic int\nsend_open(struct sftp_conn *conn, const char *path, const char *tag,\n    u_int openmode, Attrib *a, u_char **handlep, size_t *handle_lenp)\n{\n\tAttrib junk;\n\tu_char *handle;\n\tsize_t handle_len;\n\tstruct sshbuf *msg;\n\tint r;\n\tu_int id;\n\n\tdebug2(\"Sending SSH2_FXP_OPEN \\\"%s\\\"\", path);\n\n\t*handlep = NULL;\n\t*handle_lenp = 0;\n\n\tif (a == NULL) {\n\t\tattrib_clear(&junk);  \n\t\ta = &junk;\n\t}\n\t \n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tid = conn->msg_id++;\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, path)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, openmode)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal_fr(r, \"compose %s open\", tag);\n\tsend_msg(conn, msg);\n\tsshbuf_free(msg);\n\tdebug3(\"Sent %s message SSH2_FXP_OPEN I:%u P:%s M:0x%04x\",\n\t    tag, id, path, openmode);\n\tif ((handle = get_handle(conn, id, &handle_len,\n\t    \"%s open \\\"%s\\\"\", tag, path)) == NULL)\n\t\treturn -1;\n\t \n\t*handlep = handle;\n\t*handle_lenp = handle_len;\n\treturn 0;\n}\n\nstatic const char *\nprogress_meter_path(const char *path)\n{\n\tconst char *progresspath;\n\n\tif ((progresspath = strrchr(path, '/')) == NULL)\n\t\treturn path;\n\tprogresspath++;\n\tif (*progresspath == '\\0')\n\t\treturn path;\n\treturn progresspath;\n}\n\nint\nsftp_download(struct sftp_conn *conn, const char *remote_path,\n    const char *local_path, Attrib *a, int preserve_flag, int resume_flag,\n    int fsync_flag, int inplace_flag)\n{\n\tstruct sshbuf *msg;\n\tu_char *handle;\n\tint local_fd = -1, write_error;\n\tint read_error, write_errno, lmodified = 0, reordered = 0, r;\n\tu_int64_t offset = 0, size, highwater = 0, maxack = 0;\n\tu_int mode, id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\toff_t progress_counter;\n\tsize_t handle_len;\n\tstruct stat st;\n\tstruct requests requests;\n\tstruct request *req;\n\tu_char type;\n\tAttrib attr;\n\n\tdebug2_f(\"download remote \\\"%s\\\" to local \\\"%s\\\"\",\n\t    remote_path, local_path);\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL) {\n\t\tif (sftp_stat(conn, remote_path, 0, &attr) != 0)\n\t\t\treturn -1;\n\t\ta = &attr;\n\t}\n\n\t \n\tif (a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS)\n\t\tmode = a->perm & 0777;\n\telse\n\t\tmode = 0666;\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"download %s: not a regular file\", remote_path);\n\t\treturn(-1);\n\t}\n\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = conn->download_buflen;\n\n\t \n\tif (send_open(conn, remote_path, \"remote\", SSH2_FXF_READ, NULL,\n\t    &handle, &handle_len) != 0)\n\t\treturn -1;\n\n\tlocal_fd = open(local_path, O_WRONLY | O_CREAT |\n\t((resume_flag || inplace_flag) ? 0 : O_TRUNC), mode | S_IWUSR);\n\tif (local_fd == -1) {\n\t\terror(\"open local \\\"%s\\\": %s\", local_path, strerror(errno));\n\t\tgoto fail;\n\t}\n\tif (resume_flag) {\n\t\tif (fstat(local_fd, &st) == -1) {\n\t\t\terror(\"stat local \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (st.st_size < 0) {\n\t\t\terror(\"\\\"%s\\\" has negative size\", local_path);\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((u_int64_t)st.st_size > size) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"local file is larger than remote\", local_path);\n fail:\n\t\t\tsftp_close(conn, handle, handle_len);\n\t\t\tfree(handle);\n\t\t\tif (local_fd != -1)\n\t\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = highwater = maxack = st.st_size;\n\t}\n\n\t \n\twrite_error = read_error = write_errno = num_req = 0;\n\tmax_req = 1;\n\tprogress_counter = offset;\n\n\tif (showprogress && size != 0) {\n\t\tstart_progress_meter(progress_meter_path(remote_path),\n\t\t    size, &progress_counter);\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t \n\t\tif (interrupted) {\n\t\t\tif (num_req == 0)  \n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t \n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = request_enqueue(&requests, conn->msg_id++,\n\t\t\t    buflen, offset);\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tsend_read_request(conn, req->id, req->offset,\n\t\t\t    req->len, handle, handle_len);\n\t\t}\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(conn, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal_fr(r, \"parse\");\n\t\tdebug3(\"Received reply T:%u I:%u R:%d\", type, id, max_req);\n\n\t\t \n\t\tif ((req = request_find(&requests, id)) == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal_fr(r, \"parse status\");\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal_fr(r, \"parse data\");\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\t\t\tlmodified = 1;\n\t\t\tif ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||\n\t\t\t    atomicio(vwrite, local_fd, data, len) != len) &&\n\t\t\t    !write_error) {\n\t\t\t\twrite_errno = errno;\n\t\t\t\twrite_error = 1;\n\t\t\t\tmax_req = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (maxack < req->offset + len)\n\t\t\t\t\tmaxack = req->offset + len;\n\t\t\t\tif (!reordered && req->offset <= highwater)\n\t\t\t\t\thighwater = maxack;\n\t\t\t\telse if (!reordered && req->offset > highwater)\n\t\t\t\t\treordered = 1;\n\t\t\t}\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = conn->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(conn, req->id,\n\t\t\t\t    req->offset, req->len, handle, handle_len);\n\t\t\t\t \n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) {  \n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t \n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req < conn->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t \n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\n\tif (!read_error && !write_error && !interrupted) {\n\t\t \n\t\thighwater = maxack;\n\t}\n\n\t \n\tif (inplace_flag || read_error || write_error || interrupted) {\n\t\tif (reordered && resume_flag &&\n\t\t    (read_error || write_error || interrupted)) {\n\t\t\terror(\"Unable to resume download of \\\"%s\\\": \"\n\t\t\t    \"server reordered requests\", local_path);\n\t\t}\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tif (ftruncate(local_fd, highwater) == -1)\n\t\t\terror(\"local ftruncate \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t}\n\tif (read_error) {\n\t\terror(\"read remote \\\"%s\\\" : %s\", remote_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tsftp_close(conn, handle, handle_len);\n\t} else if (write_error) {\n\t\terror(\"write local \\\"%s\\\": %s\", local_path,\n\t\t    strerror(write_errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tsftp_close(conn, handle, handle_len);\n\t} else {\n\t\tif (sftp_close(conn, handle, handle_len) != 0 || interrupted)\n\t\t\tstatus = SSH2_FX_FAILURE;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\t \n#ifdef HAVE_FCHMOD\n\t\tif (preserve_flag && fchmod(local_fd, mode) == -1)\n#else\n\t\tif (preserve_flag && chmod(local_path, mode) == -1)\n#endif  \n\t\t\terror(\"local chmod \\\"%s\\\": %s\", local_path,\n\t\t\t    strerror(errno));\n\t\tif (preserve_flag &&\n\t\t    (a->flags & SSH2_FILEXFER_ATTR_ACMODTIME)) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = a->atime;\n\t\t\ttv[1].tv_sec = a->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(local_path, tv) == -1)\n\t\t\t\terror(\"local set times \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t\tif (resume_flag && !lmodified)\n\t\t\tlogit(\"File \\\"%s\\\" was not modified\", local_path);\n\t\telse if (fsync_flag) {\n\t\t\tdebug(\"syncing \\\"%s\\\"\", local_path);\n\t\t\tif (fsync(local_fd) == -1)\n\t\t\t\terror(\"local sync \\\"%s\\\": %s\",\n\t\t\t\t    local_path, strerror(errno));\n\t\t}\n\t}\n\tclose(local_fd);\n\tsshbuf_free(msg);\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nstatic int\ndownload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int resume_flag, int fsync_flag, int follow_link_flag, int inplace_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tmode_t mode = 0777, tmpmode = mode;\n\tAttrib *a, ldirattrib, lsym;\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tdebug2_f(\"download dir remote \\\"%s\\\" to local \\\"%s\\\"\", src, dst);\n\n\tif (dirattrib == NULL) {\n\t\tif (sftp_stat(conn, src, 1, &ldirattrib) != 0) {\n\t\t\terror(\"stat remote \\\"%s\\\" directory failed\", src);\n\t\t\treturn -1;\n\t\t}\n\t\tdirattrib = &ldirattrib;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag && print_flag != SFTP_PROGRESS_ONLY)\n\t\tmprintf(\"Retrieving %s\\n\", src);\n\n\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tmode = dirattrib->perm & 01777;\n\t\ttmpmode = mode | (S_IWUSR|S_IXUSR);\n\t} else {\n\t\tdebug(\"download remote \\\"%s\\\": server \"\n\t\t    \"did not send permissions\", dst);\n\t}\n\n\tif (mkdir(dst, tmpmode) == -1 && errno != EEXIST) {\n\t\terror(\"mkdir %s: %s\", dst, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (sftp_readdir(conn, src, &dir_entries) == -1) {\n\t\terror(\"remote readdir \\\"%s\\\" failed\", src);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_dst = sftp_path_append(dst, filename);\n\t\tnew_src = sftp_path_append(src, filename);\n\n\t\ta = &dir_entries[i]->a;\n\t\tif (S_ISLNK(a->perm)) {\n\t\t\tif (!follow_link_flag) {\n\t\t\t\tlogit(\"download \\\"%s\\\": not a regular file\",\n\t\t\t\t    new_src);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (sftp_stat(conn, new_src, 1, &lsym) != 0) {\n\t\t\t\tlogit(\"remote stat \\\"%s\\\" failed\", new_src);\n\t\t\t\tret = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta = &lsym;\n\t\t}\n\n\t\tif (S_ISDIR(a->perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (download_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, a, preserve_flag,\n\t\t\t    print_flag, resume_flag,\n\t\t\t    fsync_flag, follow_link_flag, inplace_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(a->perm)) {\n\t\t\tif (sftp_download(conn, new_src, new_dst, a,\n\t\t\t    preserve_flag, resume_flag, fsync_flag,\n\t\t\t    inplace_flag) == -1) {\n\t\t\t\terror(\"Download of file %s to %s failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"download \\\"%s\\\": not a regular file\", new_src);\n\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tif (preserve_flag) {\n\t\tif (dirattrib->flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tstruct timeval tv[2];\n\t\t\ttv[0].tv_sec = dirattrib->atime;\n\t\t\ttv[1].tv_sec = dirattrib->mtime;\n\t\t\ttv[0].tv_usec = tv[1].tv_usec = 0;\n\t\t\tif (utimes(dst, tv) == -1)\n\t\t\t\terror(\"local set times on \\\"%s\\\": %s\",\n\t\t\t\t    dst, strerror(errno));\n\t\t} else\n\t\t\tdebug(\"Server did not send times for directory \"\n\t\t\t    \"\\\"%s\\\"\", dst);\n\t}\n\n\tif (mode != tmpmode && chmod(dst, mode) == -1)\n\t\terror(\"local chmod directory \\\"%s\\\": %s\", dst,\n\t\t    strerror(errno));\n\n\tsftp_free_dirents(dir_entries);\n\n\treturn ret;\n}\n\nint\nsftp_download_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    Attrib *dirattrib, int preserve_flag, int print_flag, int resume_flag,\n    int fsync_flag, int follow_link_flag, int inplace_flag)\n{\n\tchar *src_canon;\n\tint ret;\n\n\tif ((src_canon = sftp_realpath(conn, src)) == NULL) {\n\t\terror(\"download \\\"%s\\\": path canonicalization failed\", src);\n\t\treturn -1;\n\t}\n\n\tret = download_dir_internal(conn, src_canon, dst, 0,\n\t    dirattrib, preserve_flag, print_flag, resume_flag, fsync_flag,\n\t    follow_link_flag, inplace_flag);\n\tfree(src_canon);\n\treturn ret;\n}\n\nint\nsftp_upload(struct sftp_conn *conn, const char *local_path,\n    const char *remote_path, int preserve_flag, int resume,\n    int fsync_flag, int inplace_flag)\n{\n\tint r, local_fd;\n\tu_int openmode, id, status = SSH2_FX_OK, reordered = 0;\n\toff_t offset, progress_counter;\n\tu_char type, *handle, *data;\n\tstruct sshbuf *msg;\n\tstruct stat sb;\n\tAttrib a, t, c;\n\tu_int32_t startid, ackid;\n\tu_int64_t highwater = 0, maxack = 0;\n\tstruct request *ack = NULL;\n\tstruct requests acks;\n\tsize_t handle_len;\n\n\tdebug2_f(\"upload local \\\"%s\\\" to remote \\\"%s\\\"\",\n\t    local_path, remote_path);\n\n\tTAILQ_INIT(&acks);\n\n\tif ((local_fd = open(local_path, O_RDONLY)) == -1) {\n\t\terror(\"open local \\\"%s\\\": %s\", local_path, strerror(errno));\n\t\treturn(-1);\n\t}\n\tif (fstat(local_fd, &sb) == -1) {\n\t\terror(\"fstat local \\\"%s\\\": %s\", local_path, strerror(errno));\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tif (!S_ISREG(sb.st_mode)) {\n\t\terror(\"local \\\"%s\\\" is not a regular file\", local_path);\n\t\tclose(local_fd);\n\t\treturn(-1);\n\t}\n\tstat_to_attrib(&sb, &a);\n\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 0777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\tif (resume) {\n\t\t \n\t\tif (sftp_stat(conn, remote_path, 0, &c) != 0) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((off_t)c.size >= sb.st_size) {\n\t\t\terror(\"resume \\\"%s\\\": destination file \"\n\t\t\t    \"same size or larger\", local_path);\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (lseek(local_fd, (off_t)c.size, SEEK_SET) == -1) {\n\t\t\tclose(local_fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\topenmode = SSH2_FXF_WRITE|SSH2_FXF_CREAT;\n\tif (resume)\n\t\topenmode |= SSH2_FXF_APPEND;\n\telse if (!inplace_flag)\n\t\topenmode |= SSH2_FXF_TRUNC;\n\n\t \n\tif (send_open(conn, remote_path, \"dest\", openmode, &a,\n\t    &handle, &handle_len) != 0) {\n\t\tclose(local_fd);\n\t\treturn -1;\n\t}\n\n\tid = conn->msg_id;\n\tstartid = ackid = id + 1;\n\tdata = xmalloc(conn->upload_buflen);\n\n\t \n\toffset = progress_counter = (resume ? c.size : 0);\n\tif (showprogress) {\n\t\tstart_progress_meter(progress_meter_path(local_path),\n\t\t    sb.st_size, &progress_counter);\n\t}\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tfor (;;) {\n\t\tint len;\n\n\t\t \n\t\tif (interrupted || status != SSH2_FX_OK)\n\t\t\tlen = 0;\n\t\telse do\n\t\t\tlen = read(local_fd, data, conn->upload_buflen);\n\t\twhile ((len == -1) &&\n\t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK));\n\n\t\tif (len == -1) {\n\t\t\tfatal(\"read local \\\"%s\\\": %s\",\n\t\t\t    local_path, strerror(errno));\n\t\t} else if (len != 0) {\n\t\t\tack = request_enqueue(&acks, ++id, len, offset);\n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, ack->id)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, handle,\n\t\t\t    handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal_fr(r, \"compose\");\n\t\t\tsend_msg(conn, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%u\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t} else if (TAILQ_FIRST(&acks) == NULL)\n\t\t\tbreak;\n\n\t\tif (ack == NULL)\n\t\t\tfatal(\"Unexpected ACK %u\", id);\n\n\t\tif (id == startid || len == 0 ||\n\t\t    id - ackid >= conn->num_requests) {\n\t\t\tu_int rid;\n\n\t\t\tsshbuf_reset(msg);\n\t\t\tget_msg(conn, msg);\n\t\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t\t    (r = sshbuf_get_u32(msg, &rid)) != 0)\n\t\t\t\tfatal_fr(r, \"parse\");\n\n\t\t\tif (type != SSH2_FXP_STATUS)\n\t\t\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, \"\n\t\t\t\t    \"got %d\", SSH2_FXP_STATUS, type);\n\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal_fr(r, \"parse status\");\n\t\t\tdebug3(\"SSH2_FXP_STATUS %u\", status);\n\n\t\t\t \n\t\t\tif ((ack = request_find(&acks, rid)) == NULL)\n\t\t\t\tfatal(\"Can't find request for ID %u\", rid);\n\t\t\tTAILQ_REMOVE(&acks, ack, tq);\n\t\t\tdebug3(\"In write loop, ack for %u %zu bytes at %lld\",\n\t\t\t    ack->id, ack->len, (unsigned long long)ack->offset);\n\t\t\t++ackid;\n\t\t\tprogress_counter += ack->len;\n\t\t\t \n\t\t\tif (maxack < ack->offset + ack->len)\n\t\t\t\tmaxack = ack->offset + ack->len;\n\t\t\tif (!reordered && ack->offset <= highwater)\n\t\t\t\thighwater = maxack;\n\t\t\telse if (!reordered && ack->offset > highwater) {\n\t\t\t\tdebug3_f(\"server reordered ACKs\");\n\t\t\t\treordered = 1;\n\t\t\t}\n\t\t\tfree(ack);\n\t\t}\n\t\toffset += len;\n\t\tif (offset < 0)\n\t\t\tfatal_f(\"offset < 0\");\n\t}\n\tsshbuf_free(msg);\n\n\tif (showprogress)\n\t\tstop_progress_meter();\n\tfree(data);\n\n\tif (status == SSH2_FX_OK && !interrupted) {\n\t\t \n\t\thighwater = maxack;\n\t}\n\tif (status != SSH2_FX_OK) {\n\t\terror(\"write remote \\\"%s\\\": %s\", remote_path, fx2txt(status));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\tif (inplace_flag || (resume && (status != SSH2_FX_OK || interrupted))) {\n\t\tdebug(\"truncating at %llu\", (unsigned long long)highwater);\n\t\tattrib_clear(&t);\n\t\tt.flags = SSH2_FILEXFER_ATTR_SIZE;\n\t\tt.size = highwater;\n\t\tsftp_fsetstat(conn, handle, handle_len, &t);\n\t}\n\n\tif (close(local_fd) == -1) {\n\t\terror(\"close local \\\"%s\\\": %s\", local_path, strerror(errno));\n\t\tstatus = SSH2_FX_FAILURE;\n\t}\n\n\t \n\tif (preserve_flag)\n\t\tsftp_fsetstat(conn, handle, handle_len, &a);\n\n\tif (fsync_flag)\n\t\t(void)sftp_fsync(conn, handle, handle_len);\n\n\tif (sftp_close(conn, handle, handle_len) != 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\n\tfree(handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nstatic int\nupload_dir_internal(struct sftp_conn *conn, const char *src, const char *dst,\n    int depth, int preserve_flag, int print_flag, int resume, int fsync_flag,\n    int follow_link_flag, int inplace_flag)\n{\n\tint ret = 0;\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *filename, *new_src = NULL, *new_dst = NULL;\n\tstruct stat sb;\n\tAttrib a, dirattrib;\n\tu_int32_t saved_perm;\n\n\tdebug2_f(\"upload local dir \\\"%s\\\" to remote \\\"%s\\\"\", src, dst);\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (stat(src, &sb) == -1) {\n\t\terror(\"stat local \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!S_ISDIR(sb.st_mode)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", src);\n\t\treturn -1;\n\t}\n\tif (print_flag && print_flag != SFTP_PROGRESS_ONLY)\n\t\tmprintf(\"Entering %s\\n\", src);\n\n\tstat_to_attrib(&sb, &a);\n\ta.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta.perm &= 01777;\n\tif (!preserve_flag)\n\t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\n\t \n\tsaved_perm = a.perm;\n\ta.perm |= (S_IWUSR|S_IXUSR);\n\tif (sftp_mkdir(conn, dst, &a, 0) != 0) {\n\t\tif (sftp_stat(conn, dst, 0, &dirattrib) != 0)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(dirattrib.perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n\t\t\treturn -1;\n\t\t}\n\t}\n\ta.perm = saved_perm;\n\n\tif ((dirp = opendir(src)) == NULL) {\n\t\terror(\"local opendir \\\"%s\\\": %s\", src, strerror(errno));\n\t\treturn -1;\n\t}\n\n\twhile (((dp = readdir(dirp)) != NULL) && !interrupted) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tfree(new_dst);\n\t\tfree(new_src);\n\t\tfilename = dp->d_name;\n\t\tnew_dst = sftp_path_append(dst, filename);\n\t\tnew_src = sftp_path_append(src, filename);\n\n\t\tif (strcmp(filename, \".\") == 0 || strcmp(filename, \"..\") == 0)\n\t\t\tcontinue;\n\t\tif (lstat(new_src, &sb) == -1) {\n\t\t\tlogit(\"local lstat \\\"%s\\\": %s\", filename,\n\t\t\t    strerror(errno));\n\t\t\tret = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISLNK(sb.st_mode)) {\n\t\t\tif (!follow_link_flag) {\n\t\t\t\tlogit(\"%s: not a regular file\", filename);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (stat(new_src, &sb) == -1) {\n\t\t\t\tlogit(\"local stat \\\"%s\\\": %s\", filename,\n\t\t\t\t    strerror(errno));\n\t\t\t\tret = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (S_ISDIR(sb.st_mode)) {\n\t\t\tif (upload_dir_internal(conn, new_src, new_dst,\n\t\t\t    depth + 1, preserve_flag, print_flag, resume,\n\t\t\t    fsync_flag, follow_link_flag, inplace_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(sb.st_mode)) {\n\t\t\tif (sftp_upload(conn, new_src, new_dst,\n\t\t\t    preserve_flag, resume, fsync_flag,\n\t\t\t    inplace_flag) == -1) {\n\t\t\t\terror(\"upload \\\"%s\\\" to \\\"%s\\\" failed\",\n\t\t\t\t    new_src, new_dst);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else\n\t\t\tlogit(\"%s: not a regular file\", filename);\n\t}\n\tfree(new_dst);\n\tfree(new_src);\n\n\tsftp_setstat(conn, dst, &a);\n\n\t(void) closedir(dirp);\n\treturn ret;\n}\n\nint\nsftp_upload_dir(struct sftp_conn *conn, const char *src, const char *dst,\n    int preserve_flag, int print_flag, int resume, int fsync_flag,\n    int follow_link_flag, int inplace_flag)\n{\n\tchar *dst_canon;\n\tint ret;\n\n\tif ((dst_canon = sftp_realpath(conn, dst)) == NULL) {\n\t\terror(\"upload \\\"%s\\\": path canonicalization failed\", dst);\n\t\treturn -1;\n\t}\n\n\tret = upload_dir_internal(conn, src, dst_canon, 0, preserve_flag,\n\t    print_flag, resume, fsync_flag, follow_link_flag, inplace_flag);\n\n\tfree(dst_canon);\n\treturn ret;\n}\n\nstatic void\nhandle_dest_replies(struct sftp_conn *to, const char *to_path, int synchronous,\n    u_int *nreqsp, u_int *write_errorp)\n{\n\tstruct sshbuf *msg;\n\tu_char type;\n\tu_int id, status;\n\tint r;\n\tstruct pollfd pfd;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\t \n\twhile (*nreqsp > 0) {\n\t\tdebug3_f(\"%u outstanding replies\", *nreqsp);\n\t\tif (!synchronous) {\n\t\t\t \n\t\t\tpfd.fd = to->fd_in;\n\t\t\tpfd.events = POLLIN;\n\t\t\tif ((r = poll(&pfd, 1, 0)) == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tbreak;\n\t\t\t\tfatal_f(\"poll: %s\", strerror(errno));\n\t\t\t} else if (r == 0)\n\t\t\t\tbreak;  \n\t\t}\n\t\tsshbuf_reset(msg);\n\t\tget_msg(to, msg);\n\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal_fr(r, \"dest parse\");\n\t\tdebug3(\"Received dest reply T:%u I:%u R:%u\", type, id, *nreqsp);\n\t\tif (type != SSH2_FXP_STATUS) {\n\t\t\tfatal_f(\"Expected SSH2_FXP_STATUS(%d) packet, got %d\",\n\t\t\t    SSH2_FXP_STATUS, type);\n\t\t}\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\tfatal_fr(r, \"parse dest status\");\n\t\tdebug3(\"dest SSH2_FXP_STATUS %u\", status);\n\t\tif (status != SSH2_FX_OK) {\n\t\t\t \n\t\t\tif (*write_errorp == 0)\n\t\t\t\t*write_errorp = status;\n\t\t}\n\t\t \n\t\t(*nreqsp)--;\n\t}\n\tdebug3_f(\"done: %u outstanding replies\", *nreqsp);\n\tsshbuf_free(msg);\n}\n\nint\nsftp_crossload(struct sftp_conn *from, struct sftp_conn *to,\n    const char *from_path, const char *to_path,\n    Attrib *a, int preserve_flag)\n{\n\tstruct sshbuf *msg;\n\tint write_error, read_error, r;\n\tu_int64_t offset = 0, size;\n\tu_int id, buflen, num_req, max_req, status = SSH2_FX_OK;\n\tu_int num_upload_req;\n\toff_t progress_counter;\n\tu_char *from_handle, *to_handle;\n\tsize_t from_handle_len, to_handle_len;\n\tstruct requests requests;\n\tstruct request *req;\n\tu_char type;\n\tAttrib attr;\n\n\tdebug2_f(\"crossload src \\\"%s\\\" to dst \\\"%s\\\"\", from_path, to_path);\n\n\tTAILQ_INIT(&requests);\n\n\tif (a == NULL) {\n\t\tif (sftp_stat(from, from_path, 0, &attr) != 0)\n\t\t\treturn -1;\n\t\ta = &attr;\n\t}\n\n\tif ((a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS) &&\n\t    (!S_ISREG(a->perm))) {\n\t\terror(\"download \\\"%s\\\": not a regular file\", from_path);\n\t\treturn(-1);\n\t}\n\tif (a->flags & SSH2_FILEXFER_ATTR_SIZE)\n\t\tsize = a->size;\n\telse\n\t\tsize = 0;\n\n\tbuflen = from->download_buflen;\n\tif (buflen > to->upload_buflen)\n\t\tbuflen = to->upload_buflen;\n\n\t \n\tif (send_open(from, from_path, \"origin\", SSH2_FXF_READ, NULL,\n\t    &from_handle, &from_handle_len) != 0)\n\t\treturn -1;\n\n\t \n\ta->flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\ta->flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\ta->perm &= 0777;\n\tif (!preserve_flag)\n\t\ta->flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n\tif (send_open(to, to_path, \"dest\",\n\t    SSH2_FXF_WRITE|SSH2_FXF_CREAT|SSH2_FXF_TRUNC, a,\n\t    &to_handle, &to_handle_len) != 0) {\n\t\tsftp_close(from, from_handle, from_handle_len);\n\t\treturn -1;\n\t}\n\n\t \n\toffset = 0;\n\twrite_error = read_error = num_req = num_upload_req = 0;\n\tmax_req = 1;\n\tprogress_counter = 0;\n\n\tif (showprogress && size != 0) {\n\t\tstart_progress_meter(progress_meter_path(from_path),\n\t\t    size, &progress_counter);\n\t}\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\twhile (num_req > 0 || max_req > 0) {\n\t\tu_char *data;\n\t\tsize_t len;\n\n\t\t \n\t\tif (interrupted) {\n\t\t\tif (num_req == 0)  \n\t\t\t\tbreak;\n\t\t\tmax_req = 0;\n\t\t}\n\n\t\t \n\t\twhile (num_req < max_req) {\n\t\t\tdebug3(\"Request range %llu -> %llu (%d/%d)\",\n\t\t\t    (unsigned long long)offset,\n\t\t\t    (unsigned long long)offset + buflen - 1,\n\t\t\t    num_req, max_req);\n\t\t\treq = request_enqueue(&requests, from->msg_id++,\n\t\t\t    buflen, offset);\n\t\t\toffset += buflen;\n\t\t\tnum_req++;\n\t\t\tsend_read_request(from, req->id, req->offset,\n\t\t\t    req->len, from_handle, from_handle_len);\n\t\t}\n\n\t\t \n\t\thandle_dest_replies(to, to_path, 0,\n\t\t    &num_upload_req, &write_error);\n\n\t\tsshbuf_reset(msg);\n\t\tget_msg(from, msg);\n\t\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\t\tfatal_fr(r, \"parse\");\n\t\tdebug3(\"Received origin reply T:%u I:%u R:%d\",\n\t\t    type, id, max_req);\n\n\t\t \n\t\tif ((req = request_find(&requests, id)) == NULL)\n\t\t\tfatal(\"Unexpected reply %u\", id);\n\n\t\tswitch (type) {\n\t\tcase SSH2_FXP_STATUS:\n\t\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n\t\t\t\tfatal_fr(r, \"parse status\");\n\t\t\tif (status != SSH2_FX_EOF)\n\t\t\t\tread_error = 1;\n\t\t\tmax_req = 0;\n\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\tfree(req);\n\t\t\tnum_req--;\n\t\t\tbreak;\n\t\tcase SSH2_FXP_DATA:\n\t\t\tif ((r = sshbuf_get_string(msg, &data, &len)) != 0)\n\t\t\t\tfatal_fr(r, \"parse data\");\n\t\t\tdebug3(\"Received data %llu -> %llu\",\n\t\t\t    (unsigned long long)req->offset,\n\t\t\t    (unsigned long long)req->offset + len - 1);\n\t\t\tif (len > req->len)\n\t\t\t\tfatal(\"Received more data than asked for \"\n\t\t\t\t    \"%zu > %zu\", len, req->len);\n\n\t\t\t \n\t\t\tsshbuf_reset(msg);\n\t\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n\t\t\t    (r = sshbuf_put_u32(msg, to->msg_id++)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, to_handle,\n\t\t\t    to_handle_len)) != 0 ||\n\t\t\t    (r = sshbuf_put_u64(msg, req->offset)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(msg, data, len)) != 0)\n\t\t\t\tfatal_fr(r, \"compose write\");\n\t\t\tsend_msg(to, msg);\n\t\t\tdebug3(\"Sent message SSH2_FXP_WRITE I:%u O:%llu S:%zu\",\n\t\t\t    id, (unsigned long long)offset, len);\n\t\t\tnum_upload_req++;\n\t\t\tprogress_counter += len;\n\t\t\tfree(data);\n\n\t\t\tif (len == req->len) {\n\t\t\t\tTAILQ_REMOVE(&requests, req, tq);\n\t\t\t\tfree(req);\n\t\t\t\tnum_req--;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdebug3(\"Short data block, re-requesting \"\n\t\t\t\t    \"%llu -> %llu (%2d)\",\n\t\t\t\t    (unsigned long long)req->offset + len,\n\t\t\t\t    (unsigned long long)req->offset +\n\t\t\t\t    req->len - 1, num_req);\n\t\t\t\treq->id = from->msg_id++;\n\t\t\t\treq->len -= len;\n\t\t\t\treq->offset += len;\n\t\t\t\tsend_read_request(from, req->id,\n\t\t\t\t    req->offset, req->len,\n\t\t\t\t    from_handle, from_handle_len);\n\t\t\t\t \n\t\t\t\tif (len < buflen)\n\t\t\t\t\tbuflen = MAXIMUM(MIN_READ_SIZE, len);\n\t\t\t}\n\t\t\tif (max_req > 0) {  \n\t\t\t\tif (size > 0 && offset > size) {\n\t\t\t\t\t \n\t\t\t\t\tdebug3(\"Finish at %llu (%2d)\",\n\t\t\t\t\t    (unsigned long long)offset,\n\t\t\t\t\t    num_req);\n\t\t\t\t\tmax_req = 1;\n\t\t\t\t} else if (max_req < from->num_requests) {\n\t\t\t\t\t++max_req;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Expected SSH2_FXP_DATA(%u) packet, got %u\",\n\t\t\t    SSH2_FXP_DATA, type);\n\t\t}\n\t}\n\n\tif (showprogress && size)\n\t\tstop_progress_meter();\n\n\t \n\tdebug3_f(\"waiting for %u replies from destination\", num_upload_req);\n\thandle_dest_replies(to, to_path, 1, &num_upload_req, &write_error);\n\n\t \n\tif (TAILQ_FIRST(&requests) != NULL)\n\t\tfatal(\"Transfer complete, but requests still in queue\");\n\t \n\tif (read_error || write_error || interrupted) {\n\t\tdebug(\"truncating \\\"%s\\\" at 0\", to_path);\n\t\tsftp_close(to, to_handle, to_handle_len);\n\t\tfree(to_handle);\n\t\tif (send_open(to, to_path, \"dest\",\n\t\t    SSH2_FXF_WRITE|SSH2_FXF_CREAT|SSH2_FXF_TRUNC, a,\n\t\t    &to_handle, &to_handle_len) != 0) {\n\t\t\terror(\"dest truncate \\\"%s\\\" failed\", to_path);\n\t\t\tto_handle = NULL;\n\t\t}\n\t}\n\tif (read_error) {\n\t\terror(\"read origin \\\"%s\\\": %s\", from_path, fx2txt(status));\n\t\tstatus = -1;\n\t\tsftp_close(from, from_handle, from_handle_len);\n\t\tif (to_handle != NULL)\n\t\t\tsftp_close(to, to_handle, to_handle_len);\n\t} else if (write_error) {\n\t\terror(\"write dest \\\"%s\\\": %s\", to_path, fx2txt(write_error));\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tsftp_close(from, from_handle, from_handle_len);\n\t\tif (to_handle != NULL)\n\t\t\tsftp_close(to, to_handle, to_handle_len);\n\t} else {\n\t\tif (sftp_close(from, from_handle, from_handle_len) != 0 ||\n\t\t    interrupted)\n\t\t\tstatus = -1;\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t\tif (to_handle != NULL) {\n\t\t\t \n\t\t\tif (preserve_flag)\n\t\t\t\tsftp_fsetstat(to, to_handle, to_handle_len, a);\n\t\t\tsftp_close(to, to_handle, to_handle_len);\n\t\t}\n\t}\n\tsshbuf_free(msg);\n\tfree(from_handle);\n\tfree(to_handle);\n\n\treturn status == SSH2_FX_OK ? 0 : -1;\n}\n\nstatic int\ncrossload_dir_internal(struct sftp_conn *from, struct sftp_conn *to,\n    const char *from_path, const char *to_path,\n    int depth, Attrib *dirattrib, int preserve_flag, int print_flag,\n    int follow_link_flag)\n{\n\tint i, ret = 0;\n\tSFTP_DIRENT **dir_entries;\n\tchar *filename, *new_from_path = NULL, *new_to_path = NULL;\n\tmode_t mode = 0777;\n\tAttrib *a, curdir, ldirattrib, newdir, lsym;\n\n\tdebug2_f(\"crossload dir src \\\"%s\\\" to dst \\\"%s\\\"\", from_path, to_path);\n\n\tif (depth >= MAX_DIR_DEPTH) {\n\t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n\t\treturn -1;\n\t}\n\n\tif (dirattrib == NULL) {\n\t\tif (sftp_stat(from, from_path, 1, &ldirattrib) != 0) {\n\t\t\terror(\"stat remote \\\"%s\\\" failed\", from_path);\n\t\t\treturn -1;\n\t\t}\n\t\tdirattrib = &ldirattrib;\n\t}\n\tif (!S_ISDIR(dirattrib->perm)) {\n\t\terror(\"\\\"%s\\\" is not a directory\", from_path);\n\t\treturn -1;\n\t}\n\tif (print_flag && print_flag != SFTP_PROGRESS_ONLY)\n\t\tmprintf(\"Retrieving %s\\n\", from_path);\n\n\tcurdir = *dirattrib;  \n\tcurdir.flags &= ~SSH2_FILEXFER_ATTR_SIZE;\n\tcurdir.flags &= ~SSH2_FILEXFER_ATTR_UIDGID;\n\tif ((curdir.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) == 0) {\n\t\tdebug(\"Origin did not send permissions for \"\n\t\t    \"directory \\\"%s\\\"\", to_path);\n\t\tcurdir.perm = S_IWUSR|S_IXUSR;\n\t\tcurdir.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t}\n\t \n\tmode = curdir.perm & 01777;\n\tcurdir.perm = mode | (S_IWUSR|S_IXUSR);\n\n\t \n\tif (sftp_mkdir(to, to_path, &curdir, 0) != 0) {\n\t\tif (sftp_stat(to, to_path, 0, &newdir) != 0)\n\t\t\treturn -1;\n\t\tif (!S_ISDIR(newdir.perm)) {\n\t\t\terror(\"\\\"%s\\\" exists but is not a directory\", to_path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tcurdir.perm = mode;\n\n\tif (sftp_readdir(from, from_path, &dir_entries) == -1) {\n\t\terror(\"origin readdir \\\"%s\\\" failed\", from_path);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; dir_entries[i] != NULL && !interrupted; i++) {\n\t\tfree(new_from_path);\n\t\tfree(new_to_path);\n\n\t\tfilename = dir_entries[i]->filename;\n\t\tnew_from_path = sftp_path_append(from_path, filename);\n\t\tnew_to_path = sftp_path_append(to_path, filename);\n\n\t\ta = &dir_entries[i]->a;\n\t\tif (S_ISLNK(a->perm)) {\n\t\t\tif (!follow_link_flag) {\n\t\t\t\tlogit(\"%s: not a regular file\", filename);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (sftp_stat(from, new_from_path, 1, &lsym) != 0) {\n\t\t\t\tlogit(\"remote stat \\\"%s\\\" failed\",\n\t\t\t\t    new_from_path);\n\t\t\t\tret = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta = &lsym;\n\t\t}\n\t\tif (S_ISDIR(a->perm)) {\n\t\t\tif (strcmp(filename, \".\") == 0 ||\n\t\t\t    strcmp(filename, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (crossload_dir_internal(from, to,\n\t\t\t    new_from_path, new_to_path,\n\t\t\t    depth + 1, a, preserve_flag,\n\t\t\t    print_flag, follow_link_flag) == -1)\n\t\t\t\tret = -1;\n\t\t} else if (S_ISREG(a->perm)) {\n\t\t\tif (sftp_crossload(from, to, new_from_path,\n\t\t\t    new_to_path, a, preserve_flag) == -1) {\n\t\t\t\terror(\"crossload \\\"%s\\\" to \\\"%s\\\" failed\",\n\t\t\t\t    new_from_path, new_to_path);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tlogit(\"origin \\\"%s\\\": not a regular file\",\n\t\t\t    new_from_path);\n\t\t}\n\t}\n\tfree(new_to_path);\n\tfree(new_from_path);\n\n\tsftp_setstat(to, to_path, &curdir);\n\n\tsftp_free_dirents(dir_entries);\n\n\treturn ret;\n}\n\nint\nsftp_crossload_dir(struct sftp_conn *from, struct sftp_conn *to,\n    const char *from_path, const char *to_path,\n    Attrib *dirattrib, int preserve_flag, int print_flag, int follow_link_flag)\n{\n\tchar *from_path_canon;\n\tint ret;\n\n\tif ((from_path_canon = sftp_realpath(from, from_path)) == NULL) {\n\t\terror(\"crossload \\\"%s\\\": path canonicalization failed\",\n\t\t    from_path);\n\t\treturn -1;\n\t}\n\n\tret = crossload_dir_internal(from, to, from_path_canon, to_path, 0,\n\t    dirattrib, preserve_flag, print_flag, follow_link_flag);\n\tfree(from_path_canon);\n\treturn ret;\n}\n\nint\nsftp_can_get_users_groups_by_id(struct sftp_conn *conn)\n{\n\treturn (conn->exts & SFTP_EXT_GETUSERSGROUPS_BY_ID) != 0;\n}\n\nint\nsftp_get_users_groups_by_id(struct sftp_conn *conn,\n    const u_int *uids, u_int nuids,\n    const u_int *gids, u_int ngids,\n    char ***usernamesp, char ***groupnamesp)\n{\n\tstruct sshbuf *msg, *uidbuf, *gidbuf;\n\tu_int i, expected_id, id;\n\tchar *name, **usernames = NULL, **groupnames = NULL;\n\tu_char type;\n\tint r;\n\n\t*usernamesp = *groupnamesp = NULL;\n\tif (!sftp_can_get_users_groups_by_id(conn))\n\t\treturn SSH_ERR_FEATURE_UNSUPPORTED;\n\n\tif ((msg = sshbuf_new()) == NULL ||\n\t    (uidbuf = sshbuf_new()) == NULL ||\n\t    (gidbuf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\texpected_id = id = conn->msg_id++;\n\tdebug2(\"Sending SSH2_FXP_EXTENDED(users-groups-by-id@openssh.com)\");\n\tfor (i = 0; i < nuids; i++) {\n\t\tif ((r = sshbuf_put_u32(uidbuf, uids[i])) != 0)\n\t\t\tfatal_fr(r, \"compose uids\");\n\t}\n\tfor (i = 0; i < ngids; i++) {\n\t\tif ((r = sshbuf_put_u32(gidbuf, gids[i])) != 0)\n\t\t\tfatal_fr(r, \"compose gids\");\n\t}\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg,\n\t    \"users-groups-by-id@openssh.com\")) != 0 ||\n\t    (r = sshbuf_put_stringb(msg, uidbuf)) != 0 ||\n\t    (r = sshbuf_put_stringb(msg, gidbuf)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(conn, msg);\n\tget_msg(conn, msg);\n\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (id != expected_id)\n\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n\tif (type == SSH2_FXP_STATUS) {\n\t\tu_int status;\n\t\tchar *errmsg;\n\n\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0 ||\n\t\t    (r = sshbuf_get_cstring(msg, &errmsg, NULL)) != 0)\n\t\t\tfatal_fr(r, \"parse status\");\n\t\terror(\"users-groups-by-id %s\",\n\t\t    *errmsg == '\\0' ? fx2txt(status) : errmsg);\n\t\tfree(errmsg);\n\t\tsshbuf_free(msg);\n\t\tsshbuf_free(uidbuf);\n\t\tsshbuf_free(gidbuf);\n\t\treturn -1;\n\t} else if (type != SSH2_FXP_EXTENDED_REPLY)\n\t\tfatal(\"Expected SSH2_FXP_EXTENDED_REPLY(%u) packet, got %u\",\n\t\t    SSH2_FXP_EXTENDED_REPLY, type);\n\n\t \n\tsshbuf_free(uidbuf);\n\tsshbuf_free(gidbuf);\n\tuidbuf = gidbuf = NULL;\n\tif ((r = sshbuf_froms(msg, &uidbuf)) != 0 ||\n\t    (r = sshbuf_froms(msg, &gidbuf)) != 0)\n\t\tfatal_fr(r, \"parse response\");\n\tif (nuids > 0) {\n\t\tusernames = xcalloc(nuids, sizeof(*usernames));\n\t\tfor (i = 0; i < nuids; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(uidbuf, &name, NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse user name\");\n\t\t\t \n\t\t\tif (*name == '\\0') {\n\t\t\t\tfree(name);\n\t\t\t\tname = NULL;\n\t\t\t}\n\t\t\tusernames[i] = name;\n\t\t}\n\t}\n\tif (ngids > 0) {\n\t\tgroupnames = xcalloc(ngids, sizeof(*groupnames));\n\t\tfor (i = 0; i < ngids; i++) {\n\t\t\tif ((r = sshbuf_get_cstring(gidbuf, &name, NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse user name\");\n\t\t\t \n\t\t\tif (*name == '\\0') {\n\t\t\t\tfree(name);\n\t\t\t\tname = NULL;\n\t\t\t}\n\t\t\tgroupnames[i] = name;\n\t\t}\n\t}\n\tif (sshbuf_len(uidbuf) != 0)\n\t\tfatal_f(\"unexpected extra username data\");\n\tif (sshbuf_len(gidbuf) != 0)\n\t\tfatal_f(\"unexpected extra groupname data\");\n\tsshbuf_free(uidbuf);\n\tsshbuf_free(gidbuf);\n\tsshbuf_free(msg);\n\t \n\t*usernamesp = usernames;\n\t*groupnamesp = groupnames;\n\treturn 0;\n}\n\nchar *\nsftp_path_append(const char *p1, const char *p2)\n{\n\tchar *ret;\n\tsize_t len = strlen(p1) + strlen(p2) + 2;\n\n\tret = xmalloc(len);\n\tstrlcpy(ret, p1, len);\n\tif (p1[0] != '\\0' && p1[strlen(p1) - 1] != '/')\n\t\tstrlcat(ret, \"/\", len);\n\tstrlcat(ret, p2, len);\n\n\treturn(ret);\n}\n\n \nchar *\nsftp_make_absolute(char *p, const char *pwd)\n{\n\tchar *abs_str;\n\n\t \n\tif (p && !path_absolute(p)) {\n\t\tabs_str = sftp_path_append(pwd, p);\n\t\tfree(p);\n\t\treturn(abs_str);\n\t} else\n\t\treturn(p);\n}\n\nint\nsftp_remote_is_dir(struct sftp_conn *conn, const char *path)\n{\n\tAttrib a;\n\n\t \n\tif (sftp_stat(conn, path, 1, &a) != 0)\n\t\treturn(0);\n\tif (!(a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n\t\treturn(0);\n\treturn S_ISDIR(a.perm);\n}\n\n\n \nint\nsftp_globpath_is_dir(const char *pathname)\n{\n\tsize_t l = strlen(pathname);\n\n\treturn l > 0 && pathname[l - 1] == '/';\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}