{
  "module_name": "ssh-pkcs11.c",
  "hash_id": "1dc6201188df0ed35603fc0be96c18cc48b81601d7ccbabf2d5d2a3e677dcd0c",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-pkcs11.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef ENABLE_PKCS11\n\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include <ctype.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include <openssl/ecdsa.h>\n#include <openssl/x509.h>\n#include <openssl/err.h>\n\n#define CRYPTOKI_COMPAT\n#include \"pkcs11.h\"\n\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"ssh-pkcs11.h\"\n#include \"digest.h\"\n#include \"xmalloc.h\"\n\nstruct pkcs11_slotinfo {\n\tCK_TOKEN_INFO\t\ttoken;\n\tCK_SESSION_HANDLE\tsession;\n\tint\t\t\tlogged_in;\n};\n\nstruct pkcs11_provider {\n\tchar\t\t\t*name;\n\tvoid\t\t\t*handle;\n\tCK_FUNCTION_LIST\t*function_list;\n\tCK_INFO\t\t\tinfo;\n\tCK_ULONG\t\tnslots;\n\tCK_SLOT_ID\t\t*slotlist;\n\tstruct pkcs11_slotinfo\t*slotinfo;\n\tint\t\t\tvalid;\n\tint\t\t\trefcount;\n\tTAILQ_ENTRY(pkcs11_provider) next;\n};\n\nTAILQ_HEAD(, pkcs11_provider) pkcs11_providers;\n\nstruct pkcs11_key {\n\tstruct pkcs11_provider\t*provider;\n\tCK_ULONG\t\tslotidx;\n\tchar\t\t\t*keyid;\n\tint\t\t\tkeyid_len;\n};\n\nint pkcs11_interactive = 0;\n\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\nstatic void\nossl_error(const char *msg)\n{\n\tunsigned long    e;\n\n\terror_f(\"%s\", msg);\n\twhile ((e = ERR_get_error()) != 0)\n\t\terror_f(\"libcrypto error: %s\", ERR_error_string(e, NULL));\n}\n#endif  \n\nint\npkcs11_init(int interactive)\n{\n\tpkcs11_interactive = interactive;\n\tTAILQ_INIT(&pkcs11_providers);\n\treturn (0);\n}\n\n \nstatic void\npkcs11_provider_finalize(struct pkcs11_provider *p)\n{\n\tCK_RV rv;\n\tCK_ULONG i;\n\n\tdebug_f(\"provider \\\"%s\\\" refcount %d valid %d\",\n\t    p->name, p->refcount, p->valid);\n\tif (!p->valid)\n\t\treturn;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\tif (p->slotinfo[i].session &&\n\t\t    (rv = p->function_list->C_CloseSession(\n\t\t    p->slotinfo[i].session)) != CKR_OK)\n\t\t\terror(\"C_CloseSession failed: %lu\", rv);\n\t}\n\tif ((rv = p->function_list->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize failed: %lu\", rv);\n\tp->valid = 0;\n\tp->function_list = NULL;\n\tdlclose(p->handle);\n}\n\n \nstatic void\npkcs11_provider_unref(struct pkcs11_provider *p)\n{\n\tdebug_f(\"provider \\\"%s\\\" refcount %d\", p->name, p->refcount);\n\tif (--p->refcount <= 0) {\n\t\tif (p->valid)\n\t\t\terror_f(\"provider \\\"%s\\\" still valid\", p->name);\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n}\n\n \nvoid\npkcs11_terminate(void)\n{\n\tstruct pkcs11_provider *p;\n\n\twhile ((p = TAILQ_FIRST(&pkcs11_providers)) != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t}\n}\n\n \nstatic struct pkcs11_provider *\npkcs11_provider_lookup(char *provider_id)\n{\n\tstruct pkcs11_provider *p;\n\n\tTAILQ_FOREACH(p, &pkcs11_providers, next) {\n\t\tdebug(\"check provider \\\"%s\\\"\", p->name);\n\t\tif (!strcmp(provider_id, p->name))\n\t\t\treturn (p);\n\t}\n\treturn (NULL);\n}\n\n \nint\npkcs11_del_provider(char *provider_id)\n{\n\tstruct pkcs11_provider *p;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t\treturn (0);\n\t}\n\treturn (-1);\n}\n\nstatic RSA_METHOD *rsa_method;\nstatic int rsa_idx = 0;\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\nstatic EC_KEY_METHOD *ec_key_method;\nstatic int ec_key_idx = 0;\n#endif  \n\n \nstatic void\npkcs11_k11_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx,\n    long argl, void *argp)\n{\n\tstruct pkcs11_key\t*k11 = ptr;\n\n\tdebug_f(\"parent %p ptr %p idx %d\", parent, ptr, idx);\n\tif (k11 == NULL)\n\t\treturn;\n\tif (k11->provider)\n\t\tpkcs11_provider_unref(k11->provider);\n\tfree(k11->keyid);\n\tfree(k11);\n}\n\n \nstatic int\npkcs11_find(struct pkcs11_provider *p, CK_ULONG slotidx, CK_ATTRIBUTE *attr,\n    CK_ULONG nattr, CK_OBJECT_HANDLE *obj)\n{\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\tsession;\n\tCK_ULONG\t\tnfound = 0;\n\tCK_RV\t\t\trv;\n\tint\t\t\tret = -1;\n\n\tf = p->function_list;\n\tsession = p->slotinfo[slotidx].session;\n\tif ((rv = f->C_FindObjectsInit(session, attr, nattr)) != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed (nattr %lu): %lu\", nattr, rv);\n\t\treturn (-1);\n\t}\n\tif ((rv = f->C_FindObjects(session, obj, 1, &nfound)) != CKR_OK ||\n\t    nfound != 1) {\n\t\tdebug(\"C_FindObjects failed (nfound %lu nattr %lu): %lu\",\n\t\t    nfound, nattr, rv);\n\t} else\n\t\tret = 0;\n\tif ((rv = f->C_FindObjectsFinal(session)) != CKR_OK)\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\treturn (ret);\n}\n\nstatic int\npkcs11_login_slot(struct pkcs11_provider *provider, struct pkcs11_slotinfo *si,\n    CK_USER_TYPE type)\n{\n\tchar\t\t\t*pin = NULL, prompt[1024];\n\tCK_RV\t\t\t rv;\n\n\tif (provider == NULL || si == NULL || !provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tif (!pkcs11_interactive) {\n\t\terror(\"need pin entry%s\",\n\t\t    (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH) ?\n\t\t    \" on reader keypad\" : \"\");\n\t\treturn (-1);\n\t}\n\tif (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH)\n\t\tverbose(\"Deferring PIN entry to reader keypad.\");\n\telse {\n\t\tsnprintf(prompt, sizeof(prompt), \"Enter PIN for '%s': \",\n\t\t    si->token.label);\n\t\tif ((pin = read_passphrase(prompt, RP_ALLOW_EOF)) == NULL) {\n\t\t\tdebug_f(\"no pin specified\");\n\t\t\treturn (-1);\t \n\t\t}\n\t}\n\trv = provider->function_list->C_Login(si->session, type, (u_char *)pin,\n\t    (pin != NULL) ? strlen(pin) : 0);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\n\tswitch (rv) {\n\tcase CKR_OK:\n\tcase CKR_USER_ALREADY_LOGGED_IN:\n\t\t \n\t\tbreak;\n\tcase CKR_PIN_LEN_RANGE:\n\t\terror(\"PKCS#11 login failed: PIN length out of range\");\n\t\treturn -1;\n\tcase CKR_PIN_INCORRECT:\n\t\terror(\"PKCS#11 login failed: PIN incorrect\");\n\t\treturn -1;\n\tcase CKR_PIN_LOCKED:\n\t\terror(\"PKCS#11 login failed: PIN locked\");\n\t\treturn -1;\n\tdefault:\n\t\terror(\"PKCS#11 login failed: error %lu\", rv);\n\t\treturn -1;\n\t}\n\tsi->logged_in = 1;\n\treturn (0);\n}\n\nstatic int\npkcs11_login(struct pkcs11_key *k11, CK_USER_TYPE type)\n{\n\tif (k11 == NULL || k11->provider == NULL || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\treturn pkcs11_login_slot(k11->provider,\n\t    &k11->provider->slotinfo[k11->slotidx], type);\n}\n\n\nstatic int\npkcs11_check_obj_bool_attrib(struct pkcs11_key *k11, CK_OBJECT_HANDLE obj,\n    CK_ATTRIBUTE_TYPE type, int *val)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_BBOOL\t\tflag = 0;\n\tCK_ATTRIBUTE\t\tattr;\n\tCK_RV\t\t\t rv;\n\n\t*val = 0;\n\n\tif (!k11->provider || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tattr.type = type;\n\tattr.pValue = &flag;\n\tattr.ulValueLen = sizeof(flag);\n\n\trv = f->C_GetAttributeValue(si->session, obj, &attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\t*val = flag != 0;\n\tdebug_f(\"provider \\\"%s\\\" slot %lu object %lu: attrib %lu = %d\",\n\t    k11->provider->name, k11->slotidx, obj, type, *val);\n\treturn (0);\n}\n\nstatic int\npkcs11_get_key(struct pkcs11_key *k11, CK_MECHANISM_TYPE mech_type)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_CLASS\t\t private_key_class;\n\tCK_BBOOL\t\t true_val;\n\tCK_MECHANISM\t\t mech;\n\tCK_ATTRIBUTE\t\t key_filter[3];\n\tint\t\t\t always_auth = 0;\n\tint\t\t\t did_login = 0;\n\n\tif (!k11->provider || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tif ((si->token.flags & CKF_LOGIN_REQUIRED) && !si->logged_in) {\n\t\tif (pkcs11_login(k11, CKU_USER) < 0) {\n\t\t\terror(\"login failed\");\n\t\t\treturn (-1);\n\t\t}\n\t\tdid_login = 1;\n\t}\n\n\tmemset(&key_filter, 0, sizeof(key_filter));\n\tprivate_key_class = CKO_PRIVATE_KEY;\n\tkey_filter[0].type = CKA_CLASS;\n\tkey_filter[0].pValue = &private_key_class;\n\tkey_filter[0].ulValueLen = sizeof(private_key_class);\n\n\tkey_filter[1].type = CKA_ID;\n\tkey_filter[1].pValue = k11->keyid;\n\tkey_filter[1].ulValueLen = k11->keyid_len;\n\n\ttrue_val = CK_TRUE;\n\tkey_filter[2].type = CKA_SIGN;\n\tkey_filter[2].pValue = &true_val;\n\tkey_filter[2].ulValueLen = sizeof(true_val);\n\n\t \n\tif (pkcs11_find(k11->provider, k11->slotidx, key_filter, 3, &obj) < 0 &&\n\t    pkcs11_find(k11->provider, k11->slotidx, key_filter, 2, &obj) < 0) {\n\t\terror(\"cannot find private key\");\n\t\treturn (-1);\n\t}\n\n\tmemset(&mech, 0, sizeof(mech));\n\tmech.mechanism = mech_type;\n\tmech.pParameter = NULL_PTR;\n\tmech.ulParameterLen = 0;\n\n\tif ((rv = f->C_SignInit(si->session, &mech, obj)) != CKR_OK) {\n\t\terror(\"C_SignInit failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\n\tpkcs11_check_obj_bool_attrib(k11, obj, CKA_ALWAYS_AUTHENTICATE,\n\t    &always_auth);  \n\tif (always_auth && !did_login) {\n\t\tdebug_f(\"always-auth key\");\n\t\tif (pkcs11_login(k11, CKU_CONTEXT_SPECIFIC) < 0) {\n\t\t\terror(\"login failed for always-auth key\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\npkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\tstruct pkcs11_key\t*k11;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_ULONG\t\ttlen = 0;\n\tCK_RV\t\t\trv;\n\tint\t\t\trval = -1;\n\n\tif ((k11 = RSA_get_ex_data(rsa, rsa_idx)) == NULL) {\n\t\terror(\"RSA_get_ex_data failed\");\n\t\treturn (-1);\n\t}\n\n\tif (pkcs11_get_key(k11, CKM_RSA_PKCS) == -1) {\n\t\terror(\"pkcs11_get_key failed\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\ttlen = RSA_size(rsa);\n\n\t \n\trv = f->C_Sign(si->session, (CK_BYTE *)from, flen, to, &tlen);\n\tif (rv == CKR_OK)\n\t\trval = tlen;\n\telse\n\t\terror(\"C_Sign failed: %lu\", rv);\n\n\treturn (rval);\n}\n\nstatic int\npkcs11_rsa_private_decrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\treturn (-1);\n}\n\nstatic int\npkcs11_rsa_start_wrapper(void)\n{\n\tif (rsa_method != NULL)\n\t\treturn (0);\n\trsa_method = RSA_meth_dup(RSA_get_default_method());\n\tif (rsa_method == NULL)\n\t\treturn (-1);\n\trsa_idx = RSA_get_ex_new_index(0, \"ssh-pkcs11-rsa\",\n\t    NULL, NULL, pkcs11_k11_free);\n\tif (rsa_idx == -1)\n\t\treturn (-1);\n\tif (!RSA_meth_set1_name(rsa_method, \"pkcs11\") ||\n\t    !RSA_meth_set_priv_enc(rsa_method, pkcs11_rsa_private_encrypt) ||\n\t    !RSA_meth_set_priv_dec(rsa_method, pkcs11_rsa_private_decrypt)) {\n\t\terror_f(\"setup pkcs11 method failed\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n \nstatic int\npkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,\n    CK_ATTRIBUTE *keyid_attrib, RSA *rsa)\n{\n\tstruct pkcs11_key\t*k11;\n\n\tif (pkcs11_rsa_start_wrapper() == -1)\n\t\treturn (-1);\n\n\tk11 = xcalloc(1, sizeof(*k11));\n\tk11->provider = provider;\n\tprovider->refcount++;\t \n\tk11->slotidx = slotidx;\n\t \n\tk11->keyid_len = keyid_attrib->ulValueLen;\n\tif (k11->keyid_len > 0) {\n\t\tk11->keyid = xmalloc(k11->keyid_len);\n\t\tmemcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);\n\t}\n\n\tRSA_set_method(rsa, rsa_method);\n\tRSA_set_ex_data(rsa, rsa_idx, k11);\n\treturn (0);\n}\n\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n \nstatic ECDSA_SIG *\necdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,\n    const BIGNUM *rp, EC_KEY *ec)\n{\n\tstruct pkcs11_key\t*k11;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_ULONG\t\tsiglen = 0, bnlen;\n\tCK_RV\t\t\trv;\n\tECDSA_SIG\t\t*ret = NULL;\n\tu_char\t\t\t*sig;\n\tBIGNUM\t\t\t*r = NULL, *s = NULL;\n\n\tif ((k11 = EC_KEY_get_ex_data(ec, ec_key_idx)) == NULL) {\n\t\tossl_error(\"EC_KEY_get_ex_data failed for ec\");\n\t\treturn (NULL);\n\t}\n\n\tif (pkcs11_get_key(k11, CKM_ECDSA) == -1) {\n\t\terror(\"pkcs11_get_key failed\");\n\t\treturn (NULL);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tsiglen = ECDSA_size(ec);\n\tsig = xmalloc(siglen);\n\n\t \n\trv = f->C_Sign(si->session, (CK_BYTE *)dgst, dgst_len, sig, &siglen);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_Sign failed: %lu\", rv);\n\t\tgoto done;\n\t}\n\tif (siglen < 64 || siglen > 132 || siglen % 2) {\n\t\terror_f(\"bad signature length: %lu\", (u_long)siglen);\n\t\tgoto done;\n\t}\n\tbnlen = siglen/2;\n\tif ((ret = ECDSA_SIG_new()) == NULL) {\n\t\terror(\"ECDSA_SIG_new failed\");\n\t\tgoto done;\n\t}\n\tif ((r = BN_bin2bn(sig, bnlen, NULL)) == NULL ||\n\t    (s = BN_bin2bn(sig+bnlen, bnlen, NULL)) == NULL) {\n\t\tossl_error(\"BN_bin2bn failed\");\n\t\tECDSA_SIG_free(ret);\n\t\tret = NULL;\n\t\tgoto done;\n\t}\n\tif (!ECDSA_SIG_set0(ret, r, s)) {\n\t\terror_f(\"ECDSA_SIG_set0 failed\");\n\t\tECDSA_SIG_free(ret);\n\t\tret = NULL;\n\t\tgoto done;\n\t}\n\tr = s = NULL;  \n\t \n done:\n\tBN_free(r);\n\tBN_free(s);\n\tfree(sig);\n\n\treturn (ret);\n}\n\nstatic int\npkcs11_ecdsa_start_wrapper(void)\n{\n\tint (*orig_sign)(int, const unsigned char *, int, unsigned char *,\n\t    unsigned int *, const BIGNUM *, const BIGNUM *, EC_KEY *) = NULL;\n\n\tif (ec_key_method != NULL)\n\t\treturn (0);\n\tec_key_idx = EC_KEY_get_ex_new_index(0, \"ssh-pkcs11-ecdsa\",\n\t    NULL, NULL, pkcs11_k11_free);\n\tif (ec_key_idx == -1)\n\t\treturn (-1);\n\tec_key_method = EC_KEY_METHOD_new(EC_KEY_OpenSSL());\n\tif (ec_key_method == NULL)\n\t\treturn (-1);\n\tEC_KEY_METHOD_get_sign(ec_key_method, &orig_sign, NULL, NULL);\n\tEC_KEY_METHOD_set_sign(ec_key_method, orig_sign, NULL, ecdsa_do_sign);\n\treturn (0);\n}\n\nstatic int\npkcs11_ecdsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,\n    CK_ATTRIBUTE *keyid_attrib, EC_KEY *ec)\n{\n\tstruct pkcs11_key\t*k11;\n\n\tif (pkcs11_ecdsa_start_wrapper() == -1)\n\t\treturn (-1);\n\n\tk11 = xcalloc(1, sizeof(*k11));\n\tk11->provider = provider;\n\tprovider->refcount++;\t \n\tk11->slotidx = slotidx;\n\t \n\tk11->keyid_len = keyid_attrib->ulValueLen;\n\tif (k11->keyid_len > 0) {\n\t\tk11->keyid = xmalloc(k11->keyid_len);\n\t\tmemcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);\n\t}\n\tEC_KEY_set_method(ec, ec_key_method);\n\tEC_KEY_set_ex_data(ec, ec_key_idx, k11);\n\n\treturn (0);\n}\n#endif  \n\n \nstatic char *\nrmspace(u_char *buf, size_t len)\n{\n\tsize_t i;\n\n\tif (len == 0)\n\t\treturn buf;\n\tfor (i = len - 1; i > 0; i--)\n\t\tif (buf[i] == ' ')\n\t\t\tbuf[i] = '\\0';\n\t\telse\n\t\t\tbreak;\n\treturn buf;\n}\n \n#define RMSPACE(s) (int)sizeof(s), rmspace(s, sizeof(s))\n\n \nstatic int\npkcs11_open_session(struct pkcs11_provider *p, CK_ULONG slotidx, char *pin,\n    CK_ULONG user)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_RV\t\t\trv;\n\tCK_SESSION_HANDLE\tsession;\n\tint\t\t\tlogin_required, ret;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\n\tlogin_required = si->token.flags & CKF_LOGIN_REQUIRED;\n\n\t \n\tif (login_required && !pkcs11_interactive &&\n\t    (pin == NULL || strlen(pin) == 0)) {\n\t\terror(\"pin required\");\n\t\treturn (-SSH_PKCS11_ERR_PIN_REQUIRED);\n\t}\n\tif ((rv = f->C_OpenSession(p->slotlist[slotidx], CKF_RW_SESSION|\n\t    CKF_SERIAL_SESSION, NULL, NULL, &session)) != CKR_OK) {\n\t\terror(\"C_OpenSession failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\tif (login_required && pin != NULL && strlen(pin) != 0) {\n\t\trv = f->C_Login(session, user, (u_char *)pin, strlen(pin));\n\t\tif (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN) {\n\t\t\terror(\"C_Login failed: %lu\", rv);\n\t\t\tret = (rv == CKR_PIN_LOCKED) ?\n\t\t\t    -SSH_PKCS11_ERR_PIN_LOCKED :\n\t\t\t    -SSH_PKCS11_ERR_LOGIN_FAIL;\n\t\t\tif ((rv = f->C_CloseSession(session)) != CKR_OK)\n\t\t\t\terror(\"C_CloseSession failed: %lu\", rv);\n\t\t\treturn (ret);\n\t\t}\n\t\tsi->logged_in = 1;\n\t}\n\tsi->session = session;\n\treturn (0);\n}\n\nstatic int\npkcs11_key_included(struct sshkey ***keysp, int *nkeys, struct sshkey *key)\n{\n\tint i;\n\n\tfor (i = 0; i < *nkeys; i++)\n\t\tif (sshkey_equal(key, (*keysp)[i]))\n\t\t\treturn (1);\n\treturn (0);\n}\n\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\nstatic struct sshkey *\npkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t key_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tASN1_OCTET_STRING\t*octet = NULL;\n\tEC_KEY\t\t\t*ec = NULL;\n\tEC_GROUP\t\t*group = NULL;\n\tstruct sshkey\t\t*key = NULL;\n\tconst unsigned char\t*attrp = NULL;\n\tint\t\t\t i;\n\tint\t\t\t nid;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tkey_attr[0].type = CKA_ID;\n\tkey_attr[1].type = CKA_EC_POINT;\n\tkey_attr[2].type = CKA_EC_PARAMS;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t \n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (key_attr[1].ulValueLen == 0 ||\n\t    key_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (key_attr[i].ulValueLen > 0)\n\t\t\tkey_attr[i].pValue = xcalloc(1, key_attr[i].ulValueLen);\n\n\t \n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\tec = EC_KEY_new();\n\tif (ec == NULL) {\n\t\terror(\"EC_KEY_new failed\");\n\t\tgoto fail;\n\t}\n\n\tattrp = key_attr[2].pValue;\n\tgroup = d2i_ECPKParameters(NULL, &attrp, key_attr[2].ulValueLen);\n\tif (group == NULL) {\n\t\tossl_error(\"d2i_ECPKParameters failed\");\n\t\tgoto fail;\n\t}\n\n\tif (EC_KEY_set_group(ec, group) == 0) {\n\t\tossl_error(\"EC_KEY_set_group failed\");\n\t\tgoto fail;\n\t}\n\n\tif (key_attr[1].ulValueLen <= 2) {\n\t\terror(\"CKA_EC_POINT too small\");\n\t\tgoto fail;\n\t}\n\n\tattrp = key_attr[1].pValue;\n\toctet = d2i_ASN1_OCTET_STRING(NULL, &attrp, key_attr[1].ulValueLen);\n\tif (octet == NULL) {\n\t\tossl_error(\"d2i_ASN1_OCTET_STRING failed\");\n\t\tgoto fail;\n\t}\n\tattrp = octet->data;\n\tif (o2i_ECPublicKey(&ec, &attrp, octet->length) == NULL) {\n\t\tossl_error(\"o2i_ECPublicKey failed\");\n\t\tgoto fail;\n\t}\n\n\tnid = sshkey_ecdsa_key_to_nid(ec);\n\tif (nid < 0) {\n\t\terror(\"couldn't get curve nid\");\n\t\tgoto fail;\n\t}\n\n\tif (pkcs11_ecdsa_wrap(p, slotidx, &key_attr[0], ec))\n\t\tgoto fail;\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\n\tkey->ecdsa = ec;\n\tkey->ecdsa_nid = nid;\n\tkey->type = KEY_ECDSA;\n\tkey->flags |= SSHKEY_FLAG_EXT;\n\tec = NULL;\t \n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(key_attr[i].pValue);\n\tif (ec)\n\t\tEC_KEY_free(ec);\n\tif (group)\n\t\tEC_GROUP_free(group);\n\tif (octet)\n\t\tASN1_OCTET_STRING_free(octet);\n\n\treturn (key);\n}\n#endif  \n\nstatic struct sshkey *\npkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t key_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tRSA\t\t\t*rsa = NULL;\n\tBIGNUM\t\t\t*rsa_n, *rsa_e;\n\tstruct sshkey\t\t*key = NULL;\n\tint\t\t\t i;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tkey_attr[0].type = CKA_ID;\n\tkey_attr[1].type = CKA_MODULUS;\n\tkey_attr[2].type = CKA_PUBLIC_EXPONENT;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t \n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t \n\tif (key_attr[1].ulValueLen == 0 ||\n\t    key_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (key_attr[i].ulValueLen > 0)\n\t\t\tkey_attr[i].pValue = xcalloc(1, key_attr[i].ulValueLen);\n\n\t \n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\trsa = RSA_new();\n\tif (rsa == NULL) {\n\t\terror(\"RSA_new failed\");\n\t\tgoto fail;\n\t}\n\n\trsa_n = BN_bin2bn(key_attr[1].pValue, key_attr[1].ulValueLen, NULL);\n\trsa_e = BN_bin2bn(key_attr[2].pValue, key_attr[2].ulValueLen, NULL);\n\tif (rsa_n == NULL || rsa_e == NULL) {\n\t\terror(\"BN_bin2bn failed\");\n\t\tgoto fail;\n\t}\n\tif (!RSA_set0_key(rsa, rsa_n, rsa_e, NULL))\n\t\tfatal_f(\"set key\");\n\trsa_n = rsa_e = NULL;  \n\n\tif (pkcs11_rsa_wrap(p, slotidx, &key_attr[0], rsa))\n\t\tgoto fail;\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\n\tkey->rsa = rsa;\n\tkey->type = KEY_RSA;\n\tkey->flags |= SSHKEY_FLAG_EXT;\n\trsa = NULL;\t \n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(key_attr[i].pValue);\n\tRSA_free(rsa);\n\n\treturn (key);\n}\n\nstatic int\npkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj, struct sshkey **keyp, char **labelp)\n{\n\tCK_ATTRIBUTE\t\t cert_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tX509\t\t\t*x509 = NULL;\n\tX509_NAME\t\t*x509_name = NULL;\n\tEVP_PKEY\t\t*evp;\n\tRSA\t\t\t*rsa = NULL;\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY\t\t\t*ec = NULL;\n#endif\n\tstruct sshkey\t\t*key = NULL;\n\tint\t\t\t i;\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\tint\t\t\t nid;\n#endif\n\tconst u_char\t\t*cp;\n\tchar\t\t\t*subject = NULL;\n\n\t*keyp = NULL;\n\t*labelp = NULL;\n\n\tmemset(&cert_attr, 0, sizeof(cert_attr));\n\tcert_attr[0].type = CKA_ID;\n\tcert_attr[1].type = CKA_SUBJECT;\n\tcert_attr[2].type = CKA_VALUE;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t \n\trv = f->C_GetAttributeValue(session, *obj, cert_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn -1;\n\t}\n\n\t \n\tif (cert_attr[1].ulValueLen == 0 ||\n\t    cert_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tif (cert_attr[i].ulValueLen > 0)\n\t\t\tcert_attr[i].pValue = xcalloc(1, cert_attr[i].ulValueLen);\n\n\t \n\trv = f->C_GetAttributeValue(session, *obj, cert_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto out;\n\t}\n\n\t \n\tcp = cert_attr[1].pValue;\n\tif ((x509_name = d2i_X509_NAME(NULL, &cp,\n\t    cert_attr[1].ulValueLen)) == NULL ||\n\t    (subject = X509_NAME_oneline(x509_name, NULL, 0)) == NULL)\n\t\tsubject = xstrdup(\"invalid subject\");\n\tX509_NAME_free(x509_name);\n\n\tcp = cert_attr[2].pValue;\n\tif ((x509 = d2i_X509(NULL, &cp, cert_attr[2].ulValueLen)) == NULL) {\n\t\terror(\"d2i_x509 failed\");\n\t\tgoto out;\n\t}\n\n\tif ((evp = X509_get_pubkey(x509)) == NULL) {\n\t\terror(\"X509_get_pubkey failed\");\n\t\tgoto out;\n\t}\n\n\tif (EVP_PKEY_base_id(evp) == EVP_PKEY_RSA) {\n\t\tif (EVP_PKEY_get0_RSA(evp) == NULL) {\n\t\t\terror(\"invalid x509; no rsa key\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(evp))) == NULL) {\n\t\t\terror(\"RSAPublicKey_dup failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pkcs11_rsa_wrap(p, slotidx, &cert_attr[0], rsa))\n\t\t\tgoto out;\n\n\t\tkey = sshkey_new(KEY_UNSPEC);\n\t\tif (key == NULL) {\n\t\t\terror(\"sshkey_new failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->rsa = rsa;\n\t\tkey->type = KEY_RSA;\n\t\tkey->flags |= SSHKEY_FLAG_EXT;\n\t\trsa = NULL;\t \n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\t} else if (EVP_PKEY_base_id(evp) == EVP_PKEY_EC) {\n\t\tif (EVP_PKEY_get0_EC_KEY(evp) == NULL) {\n\t\t\terror(\"invalid x509; no ec key\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((ec = EC_KEY_dup(EVP_PKEY_get0_EC_KEY(evp))) == NULL) {\n\t\t\terror(\"EC_KEY_dup failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tnid = sshkey_ecdsa_key_to_nid(ec);\n\t\tif (nid < 0) {\n\t\t\terror(\"couldn't get curve nid\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (pkcs11_ecdsa_wrap(p, slotidx, &cert_attr[0], ec))\n\t\t\tgoto out;\n\n\t\tkey = sshkey_new(KEY_UNSPEC);\n\t\tif (key == NULL) {\n\t\t\terror(\"sshkey_new failed\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->ecdsa = ec;\n\t\tkey->ecdsa_nid = nid;\n\t\tkey->type = KEY_ECDSA;\n\t\tkey->flags |= SSHKEY_FLAG_EXT;\n\t\tec = NULL;\t \n#endif  \n\t} else {\n\t\terror(\"unknown certificate key type\");\n\t\tgoto out;\n\t}\n out:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(cert_attr[i].pValue);\n\tX509_free(x509);\n\tRSA_free(rsa);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(ec);\n#endif\n\tif (key == NULL) {\n\t\tfree(subject);\n\t\treturn -1;\n\t}\n\t \n\t*keyp = key;\n\t*labelp = subject;\n\treturn 0;\n}\n\n#if 0\nstatic int\nhave_rsa_key(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n, *rsa_e;\n\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, NULL);\n\treturn rsa_n != NULL && rsa_e != NULL;\n}\n#endif\n\nstatic void\nnote_key(struct pkcs11_provider *p, CK_ULONG slotidx, const char *context,\n    struct sshkey *key)\n{\n\tchar *fp;\n\n\tif ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror_f(\"sshkey_fingerprint failed\");\n\t\treturn;\n\t}\n\tdebug2(\"%s: provider %s slot %lu: %s %s\", context, p->name,\n\t    (u_long)slotidx, sshkey_type(key), fp);\n\tfree(fp);\n}\n\n \nstatic int\npkcs11_fetch_certs(struct pkcs11_provider *p, CK_ULONG slotidx,\n    struct sshkey ***keysp, char ***labelsp, int *nkeys)\n{\n\tstruct sshkey\t\t*key = NULL;\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_ATTRIBUTE\t\t key_attr[1];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_ULONG\t\t n = 0;\n\tint\t\t\t ret = -1;\n\tchar\t\t\t*label;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tmemset(&obj, 0, sizeof(obj));\n\n\tkey_class = CKO_CERTIFICATE;\n\tkey_attr[0].type = CKA_CLASS;\n\tkey_attr[0].pValue = &key_class;\n\tkey_attr[0].ulValueLen = sizeof(key_class);\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\trv = f->C_FindObjectsInit(session, key_attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\twhile (1) {\n\t\tCK_CERTIFICATE_TYPE\tck_cert_type;\n\n\t\trv = f->C_FindObjects(session, &obj, 1, &n);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_FindObjects failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tmemset(&ck_cert_type, 0, sizeof(ck_cert_type));\n\t\tmemset(&key_attr, 0, sizeof(key_attr));\n\t\tkey_attr[0].type = CKA_CERTIFICATE_TYPE;\n\t\tkey_attr[0].pValue = &ck_cert_type;\n\t\tkey_attr[0].ulValueLen = sizeof(ck_cert_type);\n\n\t\trv = f->C_GetAttributeValue(session, obj, key_attr, 1);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tkey = NULL;\n\t\tlabel = NULL;\n\t\tswitch (ck_cert_type) {\n\t\tcase CKC_X_509:\n\t\t\tif (pkcs11_fetch_x509_pubkey(p, slotidx, &obj,\n\t\t\t    &key, &label) != 0) {\n\t\t\t\terror(\"failed to fetch key\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"skipping unsupported certificate type %lu\",\n\t\t\t    ck_cert_type);\n\t\t\tcontinue;\n\t\t}\n\t\tnote_key(p, slotidx, __func__, key);\n\t\tif (pkcs11_key_included(keysp, nkeys, key)) {\n\t\t\tdebug2_f(\"key already included\");;\n\t\t\tsshkey_free(key);\n\t\t} else {\n\t\t\t \n\t\t\t*keysp = xrecallocarray(*keysp, *nkeys,\n\t\t\t    *nkeys + 1, sizeof(struct sshkey *));\n\t\t\t(*keysp)[*nkeys] = key;\n\t\t\tif (labelsp != NULL) {\n\t\t\t\t*labelsp = xrecallocarray(*labelsp, *nkeys,\n\t\t\t\t    *nkeys + 1, sizeof(char *));\n\t\t\t\t(*labelsp)[*nkeys] = xstrdup((char *)label);\n\t\t\t}\n\t\t\t*nkeys = *nkeys + 1;\n\t\t\tdebug(\"have %d keys\", *nkeys);\n\t\t}\n\t}\n\n\tret = 0;\nfail:\n\trv = f->C_FindObjectsFinal(session);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\t\tret = -1;\n\t}\n\n\treturn (ret);\n}\n\n \nstatic int\npkcs11_fetch_keys(struct pkcs11_provider *p, CK_ULONG slotidx,\n    struct sshkey ***keysp, char ***labelsp, int *nkeys)\n{\n\tstruct sshkey\t\t*key = NULL;\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_ATTRIBUTE\t\t key_attr[2];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_ULONG\t\t n = 0;\n\tint\t\t\t ret = -1;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tmemset(&obj, 0, sizeof(obj));\n\n\tkey_class = CKO_PUBLIC_KEY;\n\tkey_attr[0].type = CKA_CLASS;\n\tkey_attr[0].pValue = &key_class;\n\tkey_attr[0].ulValueLen = sizeof(key_class);\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\trv = f->C_FindObjectsInit(session, key_attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\twhile (1) {\n\t\tCK_KEY_TYPE\tck_key_type;\n\t\tCK_UTF8CHAR\tlabel[256];\n\n\t\trv = f->C_FindObjects(session, &obj, 1, &n);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_FindObjects failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tmemset(&ck_key_type, 0, sizeof(ck_key_type));\n\t\tmemset(&key_attr, 0, sizeof(key_attr));\n\t\tkey_attr[0].type = CKA_KEY_TYPE;\n\t\tkey_attr[0].pValue = &ck_key_type;\n\t\tkey_attr[0].ulValueLen = sizeof(ck_key_type);\n\t\tkey_attr[1].type = CKA_LABEL;\n\t\tkey_attr[1].pValue = &label;\n\t\tkey_attr[1].ulValueLen = sizeof(label) - 1;\n\n\t\trv = f->C_GetAttributeValue(session, obj, key_attr, 2);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlabel[key_attr[1].ulValueLen] = '\\0';\n\n\t\tswitch (ck_key_type) {\n\t\tcase CKK_RSA:\n\t\t\tkey = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\t\tcase CKK_ECDSA:\n\t\t\tkey = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n#endif  \n\t\tdefault:\n\t\t\t \n\t\t\tkey = NULL;\n\t\t\terror(\"skipping unsupported key type\");\n\t\t}\n\n\t\tif (key == NULL) {\n\t\t\terror(\"failed to fetch key\");\n\t\t\tcontinue;\n\t\t}\n\t\tnote_key(p, slotidx, __func__, key);\n\t\tif (pkcs11_key_included(keysp, nkeys, key)) {\n\t\t\tdebug2_f(\"key already included\");;\n\t\t\tsshkey_free(key);\n\t\t} else {\n\t\t\t \n\t\t\t*keysp = xrecallocarray(*keysp, *nkeys,\n\t\t\t    *nkeys + 1, sizeof(struct sshkey *));\n\t\t\t(*keysp)[*nkeys] = key;\n\t\t\tif (labelsp != NULL) {\n\t\t\t\t*labelsp = xrecallocarray(*labelsp, *nkeys,\n\t\t\t\t    *nkeys + 1, sizeof(char *));\n\t\t\t\t(*labelsp)[*nkeys] = xstrdup((char *)label);\n\t\t\t}\n\t\t\t*nkeys = *nkeys + 1;\n\t\t\tdebug(\"have %d keys\", *nkeys);\n\t\t}\n\t}\n\n\tret = 0;\nfail:\n\trv = f->C_FindObjectsFinal(session);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\t\tret = -1;\n\t}\n\n\treturn (ret);\n}\n\n#ifdef WITH_PKCS11_KEYGEN\n#define FILL_ATTR(attr, idx, typ, val, len) \\\n\t{ (attr[idx]).type=(typ); (attr[idx]).pValue=(val); (attr[idx]).ulValueLen=len; idx++; }\n\nstatic struct sshkey *\npkcs11_rsa_generate_private_key(struct pkcs11_provider *p, CK_ULONG slotidx,\n    char *label, CK_ULONG bits, CK_BYTE keyid, u_int32_t *err)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tchar\t\t\t*plabel = label ? label : \"\";\n\tint\t\t\t npub = 0, npriv = 0;\n\tCK_RV\t\t\t rv;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_BBOOL\t\t true_val = CK_TRUE, false_val = CK_FALSE;\n\tCK_OBJECT_HANDLE\t pubKey, privKey;\n\tCK_ATTRIBUTE\t\t tpub[16], tpriv[16];\n\tCK_MECHANISM\t\t mech = {\n\t    CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0\n\t};\n\tCK_BYTE\t\t\t pubExponent[] = {\n\t    0x01, 0x00, 0x01  \n\t};\n\tpubkey_filter[0].pValue = &pubkey_class;\n\tcert_filter[0].pValue = &cert_class;\n\n\t*err = 0;\n\n\tFILL_ATTR(tpub, npub, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpub, npub, CKA_ENCRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_WRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_MODULUS_BITS, &bits, sizeof(bits));\n\tFILL_ATTR(tpub, npub, CKA_PUBLIC_EXPONENT, pubExponent,\n\t    sizeof(pubExponent));\n\tFILL_ATTR(tpub, npub, CKA_ID, &keyid, sizeof(keyid));\n\n\tFILL_ATTR(tpriv, npriv, CKA_TOKEN,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_LABEL,  plabel, strlen(plabel));\n\tFILL_ATTR(tpriv, npriv, CKA_PRIVATE,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SENSITIVE,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DECRYPT,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN_RECOVER,  &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_UNWRAP,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DERIVE,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_ID, &keyid, sizeof(keyid));\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_GenerateKeyPair(session, &mech, tpub, npub, tpriv, npriv,\n\t    &pubKey, &privKey)) != CKR_OK) {\n\t\terror_f(\"key generation failed: error 0x%lx\", rv);\n\t\t*err = rv;\n\t\treturn NULL;\n\t}\n\n\treturn pkcs11_fetch_rsa_pubkey(p, slotidx, &pubKey);\n}\n\nstatic int\npkcs11_decode_hex(const char *hex, unsigned char **dest, size_t *rlen)\n{\n\tsize_t\ti, len;\n\tchar\tptr[3];\n\n\tif (dest)\n\t\t*dest = NULL;\n\tif (rlen)\n\t\t*rlen = 0;\n\n\tif ((len = strlen(hex)) % 2)\n\t\treturn -1;\n\tlen /= 2;\n\n\t*dest = xmalloc(len);\n\n\tptr[2] = '\\0';\n\tfor (i = 0; i < len; i++) {\n\t\tptr[0] = hex[2 * i];\n\t\tptr[1] = hex[(2 * i) + 1];\n\t\tif (!isxdigit(ptr[0]) || !isxdigit(ptr[1]))\n\t\t\treturn -1;\n\t\t(*dest)[i] = (unsigned char)strtoul(ptr, NULL, 16);\n\t}\n\n\tif (rlen)\n\t\t*rlen = len;\n\n\treturn 0;\n}\n\nstatic struct ec_curve_info {\n\tconst char\t*name;\n\tconst char\t*oid;\n\tconst char\t*oid_encoded;\n\tsize_t\t\t size;\n} ec_curve_infos[] = {\n\t{\"prime256v1\",\t\"1.2.840.10045.3.1.7\",\t\"06082A8648CE3D030107\", 256},\n\t{\"secp384r1\",\t\"1.3.132.0.34\",\t\t\"06052B81040022\",\t384},\n\t{\"secp521r1\",\t\"1.3.132.0.35\",\t\t\"06052B81040023\",\t521},\n\t{NULL,\t\tNULL,\t\t\tNULL,\t\t\t0},\n};\n\nstatic struct sshkey *\npkcs11_ecdsa_generate_private_key(struct pkcs11_provider *p, CK_ULONG slotidx,\n    char *label, CK_ULONG bits, CK_BYTE keyid, u_int32_t *err)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tchar\t\t\t*plabel = label ? label : \"\";\n\tint\t\t\t i;\n\tsize_t\t\t\t ecparams_size;\n\tunsigned char\t\t*ecparams = NULL;\n\tint\t\t\t npub = 0, npriv = 0;\n\tCK_RV\t\t\t rv;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_BBOOL\t\t true_val = CK_TRUE, false_val = CK_FALSE;\n\tCK_OBJECT_HANDLE\t pubKey, privKey;\n\tCK_MECHANISM\t\t mech = {\n\t    CKM_EC_KEY_PAIR_GEN, NULL_PTR, 0\n\t};\n\tCK_ATTRIBUTE\t\t tpub[16], tpriv[16];\n\n\t*err = 0;\n\n\tfor (i = 0; ec_curve_infos[i].name; i++) {\n\t\tif (ec_curve_infos[i].size == bits)\n\t\t\tbreak;\n\t}\n\tif (!ec_curve_infos[i].name) {\n\t\terror_f(\"invalid key size %lu\", bits);\n\t\treturn NULL;\n\t}\n\tif (pkcs11_decode_hex(ec_curve_infos[i].oid_encoded, &ecparams,\n\t    &ecparams_size) == -1) {\n\t\terror_f(\"invalid oid\");\n\t\treturn NULL;\n\t}\n\n\tFILL_ATTR(tpub, npub, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpub, npub, CKA_ENCRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_WRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_EC_PARAMS, ecparams, ecparams_size);\n\tFILL_ATTR(tpub, npub, CKA_ID, &keyid, sizeof(keyid));\n\n\tFILL_ATTR(tpriv, npriv, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpriv, npriv, CKA_PRIVATE, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SENSITIVE, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DECRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_UNWRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_ID, &keyid, sizeof(keyid));\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_GenerateKeyPair(session, &mech, tpub, npub, tpriv, npriv,\n\t    &pubKey, &privKey)) != CKR_OK) {\n\t\terror_f(\"key generation failed: error 0x%lx\", rv);\n\t\t*err = rv;\n\t\treturn NULL;\n\t}\n\n\treturn pkcs11_fetch_ecdsa_pubkey(p, slotidx, &pubKey);\n}\n#endif  \n\n \nstatic int\npkcs11_register_provider(char *provider_id, char *pin,\n    struct sshkey ***keyp, char ***labelsp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (labelsp != NULL)\n\t\t*labelsp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug_f(\"provider already registered: %s\", provider_id);\n\t\tgoto fail;\n\t}\n\tif (lib_contains_symbol(provider_id, \"C_GetFunctionList\") != 0) {\n\t\terror(\"provider %s is not a PKCS11 library\", provider_id);\n\t\tgoto fail;\n\t}\n\t \n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL)\n\t\tfatal(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t \n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tdebug(\"provider %s: manufacturerID <%.*s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%.*s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    RMSPACE(p->info.manufacturerID),\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    RMSPACE(p->info.libraryDescription),\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug_f(\"provider %s returned no slots\", provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (u_long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2_f(\"ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", provider_id, (u_long)i);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"provider %s slot %lu: label <%.*s> \"\n\t\t    \"manufacturerID <%.*s> model <%.*s> serial <%.*s> \"\n\t\t    \"flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    RMSPACE(token->label), RMSPACE(token->manufacturerID),\n\t\t    RMSPACE(token->model), RMSPACE(token->serialNumber),\n\t\t    token->flags);\n\t\t \n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t \n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\t}\n\t}\n\n\t \n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t \n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn (ret);\n}\n\n \nint\npkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp,\n    char ***labelsp)\n{\n\tstruct pkcs11_provider *p = NULL;\n\tint nkeys;\n\n\tnkeys = pkcs11_register_provider(provider_id, pin, keyp, labelsp,\n\t    &p, CKU_USER);\n\n\t \n\tif (nkeys <= 0 && p != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t}\n\tif (nkeys == 0)\n\t\tdebug_f(\"provider %s returned no keys\", provider_id);\n\n\treturn (nkeys);\n}\n\n#ifdef WITH_PKCS11_KEYGEN\nstruct sshkey *\npkcs11_gakp(char *provider_id, char *pin, unsigned int slotidx, char *label,\n    unsigned int type, unsigned int bits, unsigned char keyid, u_int32_t *err)\n{\n\tstruct pkcs11_provider\t*p = NULL;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tstruct sshkey\t\t*k = NULL;\n\tint\t\t\t ret = -1, reset_pin = 0, reset_provider = 0;\n\tCK_RV\t\t\t rv;\n\n\t*err = 0;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL)\n\t\tdebug_f(\"provider \\\"%s\\\" available\", provider_id);\n\telse if ((ret = pkcs11_register_provider(provider_id, pin, NULL, NULL,\n\t    &p, CKU_SO)) < 0) {\n\t\tdebug_f(\"could not register provider %s\", provider_id);\n\t\tgoto out;\n\t} else\n\t\treset_provider = 1;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_SetOperationState(session , pin, strlen(pin),\n\t    CK_INVALID_HANDLE, CK_INVALID_HANDLE)) != CKR_OK) {\n\t\tdebug_f(\"could not supply SO pin: %lu\", rv);\n\t\treset_pin = 0;\n\t} else\n\t\treset_pin = 1;\n\n\tswitch (type) {\n\tcase KEY_RSA:\n\t\tif ((k = pkcs11_rsa_generate_private_key(p, slotidx, label,\n\t\t    bits, keyid, err)) == NULL) {\n\t\t\tdebug_f(\"failed to generate RSA key\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif ((k = pkcs11_ecdsa_generate_private_key(p, slotidx, label,\n\t\t    bits, keyid, err)) == NULL) {\n\t\t\tdebug_f(\"failed to generate ECDSA key\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*err = SSH_PKCS11_ERR_GENERIC;\n\t\tdebug_f(\"unknown type %d\", type);\n\t\tgoto out;\n\t}\n\nout:\n\tif (reset_pin)\n\t\tf->C_SetOperationState(session , NULL, 0, CK_INVALID_HANDLE,\n\t\t    CK_INVALID_HANDLE);\n\n\tif (reset_provider)\n\t\tpkcs11_del_provider(provider_id);\n\n\treturn (k);\n}\n\nstruct sshkey *\npkcs11_destroy_keypair(char *provider_id, char *pin, unsigned long slotidx,\n    unsigned char keyid, u_int32_t *err)\n{\n\tstruct pkcs11_provider\t*p = NULL;\n\tstruct pkcs11_slotinfo\t*si;\n\tstruct sshkey\t\t*k = NULL;\n\tint\t\t\t reset_pin = 0, reset_provider = 0;\n\tCK_ULONG\t\t nattrs;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_ATTRIBUTE\t\t attrs[16];\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_KEY_TYPE\t\t key_type;\n\tCK_OBJECT_HANDLE\t obj = CK_INVALID_HANDLE;\n\tCK_RV\t\t\t rv;\n\n\t*err = 0;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL) {\n\t\tdebug_f(\"using provider \\\"%s\\\"\", provider_id);\n\t} else if (pkcs11_register_provider(provider_id, pin, NULL, NULL, &p,\n\t    CKU_SO) < 0) {\n\t\tdebug_f(\"could not register provider %s\",\n\t\t    provider_id);\n\t\tgoto out;\n\t} else\n\t\treset_provider = 1;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_SetOperationState(session , pin, strlen(pin),\n\t    CK_INVALID_HANDLE, CK_INVALID_HANDLE)) != CKR_OK) {\n\t\tdebug_f(\"could not supply SO pin: %lu\", rv);\n\t\treset_pin = 0;\n\t} else\n\t\treset_pin = 1;\n\n\t \n\tnattrs = 0;\n\tkey_class = CKO_PRIVATE_KEY;\n\tFILL_ATTR(attrs, nattrs, CKA_CLASS, &key_class, sizeof(key_class));\n\tFILL_ATTR(attrs, nattrs, CKA_ID, &keyid, sizeof(keyid));\n\n\tif (pkcs11_find(p, slotidx, attrs, nattrs, &obj) == 0 &&\n\t    obj != CK_INVALID_HANDLE) {\n\t\tif ((rv = f->C_DestroyObject(session, obj)) != CKR_OK) {\n\t\t\tdebug_f(\"could not destroy private key 0x%hhx\",\n\t\t\t    keyid);\n\t\t\t*err = rv;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tnattrs = 0;\n\tkey_class = CKO_PUBLIC_KEY;\n\tFILL_ATTR(attrs, nattrs, CKA_CLASS, &key_class, sizeof(key_class));\n\tFILL_ATTR(attrs, nattrs, CKA_ID, &keyid, sizeof(keyid));\n\n\tif (pkcs11_find(p, slotidx, attrs, nattrs, &obj) == 0 &&\n\t    obj != CK_INVALID_HANDLE) {\n\n\t\t \n\t\tnattrs = 0;\n\t\tFILL_ATTR(attrs, nattrs, CKA_KEY_TYPE, &key_type,\n\t\t    sizeof(key_type));\n\t\trv = f->C_GetAttributeValue(session, obj, attrs, nattrs);\n\t\tif (rv != CKR_OK) {\n\t\t\tdebug_f(\"could not get key type of public key 0x%hhx\",\n\t\t\t    keyid);\n\t\t\t*err = rv;\n\t\t\tkey_type = -1;\n\t\t}\n\t\tif (key_type == CKK_RSA)\n\t\t\tk = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);\n\t\telse if (key_type == CKK_ECDSA)\n\t\t\tk = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);\n\n\t\tif ((rv = f->C_DestroyObject(session, obj)) != CKR_OK) {\n\t\t\tdebug_f(\"could not destroy public key 0x%hhx\", keyid);\n\t\t\t*err = rv;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (reset_pin)\n\t\tf->C_SetOperationState(session , NULL, 0, CK_INVALID_HANDLE,\n\t\t    CK_INVALID_HANDLE);\n\n\tif (reset_provider)\n\t\tpkcs11_del_provider(provider_id);\n\n\treturn (k);\n}\n#endif  \n#else  \n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"log.h\"\n#include \"sshkey.h\"\n\nint\npkcs11_init(int interactive)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n\treturn (-1);\n}\n\nint\npkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp,\n    char ***labelsp)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n\treturn (-1);\n}\n\nvoid\npkcs11_terminate(void)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}