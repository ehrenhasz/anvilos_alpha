{
  "module_name": "nchan.c",
  "hash_id": "c6bb5688dd7a0a4b5c81833cb37335a90bc61979e0271090eeb69e2f2e8030ff",
  "original_prompt": "Ingested from openssh-9.6p1/nchan.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <errno.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"packet.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"log.h\"\n\n \n\n \n \n \nstatic void\tchan_send_eof2(struct ssh *, Channel *);\nstatic void\tchan_send_eow2(struct ssh *, Channel *);\n\n \nstatic void\tchan_shutdown_write(struct ssh *, Channel *);\nstatic void\tchan_shutdown_read(struct ssh *, Channel *);\nstatic void\tchan_shutdown_extended_read(struct ssh *, Channel *);\n\nstatic const char * const ostates[] = {\n\t\"open\", \"drain\", \"wait_ieof\", \"closed\",\n};\nstatic const char * const istates[] = {\n\t\"open\", \"drain\", \"wait_oclose\", \"closed\",\n};\n\nstatic void\nchan_set_istate(Channel *c, u_int next)\n{\n\tif (c->istate > CHAN_INPUT_CLOSED || next > CHAN_INPUT_CLOSED)\n\t\tfatal(\"chan_set_istate: bad state %d -> %d\", c->istate, next);\n\tdebug2(\"channel %d: input %s -> %s\", c->self, istates[c->istate],\n\t    istates[next]);\n\tc->istate = next;\n}\n\nstatic void\nchan_set_ostate(Channel *c, u_int next)\n{\n\tif (c->ostate > CHAN_OUTPUT_CLOSED || next > CHAN_OUTPUT_CLOSED)\n\t\tfatal(\"chan_set_ostate: bad state %d -> %d\", c->ostate, next);\n\tdebug2(\"channel %d: output %s -> %s\", c->self, ostates[c->ostate],\n\t    ostates[next]);\n\tc->ostate = next;\n}\n\nvoid\nchan_read_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: read failed\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_WAIT_DRAIN);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_read_failed for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}\n\nvoid\nchan_ibuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: ibuf empty\", c->self);\n\tif (sshbuf_len(c->input)) {\n\t\terror(\"channel %d: chan_ibuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & (CHAN_CLOSE_SENT|CHAN_LOCAL)))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_ibuf_empty for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}\n\nvoid\nchan_obuf_empty(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: obuf empty\", c->self);\n\tif (sshbuf_len(c->output)) {\n\t\terror(\"channel %d: chan_obuf_empty for non empty buffer\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: internal error: obuf_empty for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}\n\nvoid\nchan_rcvd_eow(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eow\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}\n\nstatic void\nchan_send_eof2(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tdebug2(\"channel %d: send eof\", c->self);\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!c->have_remote_id)\n\t\t\tfatal_f(\"channel %d: no remote_id\", c->self);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_EOF)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send CHANNEL_EOF\");\n\t\tc->flags |= CHAN_EOF_SENT;\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: cannot send eof for istate %d\",\n\t\t    c->self, c->istate);\n\t\tbreak;\n\t}\n}\n\nstatic void\nchan_send_close2(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tdebug2(\"channel %d: send close\", c->self);\n\tif (c->ostate != CHAN_OUTPUT_CLOSED ||\n\t    c->istate != CHAN_INPUT_CLOSED) {\n\t\terror(\"channel %d: cannot send close for istate/ostate %d/%d\",\n\t\t    c->self, c->istate, c->ostate);\n\t} else if (c->flags & CHAN_CLOSE_SENT) {\n\t\terror(\"channel %d: already sent close\", c->self);\n\t} else {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal_f(\"channel %d: no remote_id\", c->self);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_CLOSE)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send CHANNEL_EOF\");\n\t\tc->flags |= CHAN_CLOSE_SENT;\n\t}\n}\n\nstatic void\nchan_send_eow2(struct ssh *ssh, Channel *c)\n{\n\tint r;\n\n\tdebug2(\"channel %d: send eow\", c->self);\n\tif (c->ostate == CHAN_OUTPUT_CLOSED) {\n\t\terror(\"channel %d: must not sent eow on closed output\",\n\t\t    c->self);\n\t\treturn;\n\t}\n\tif (!(ssh->compat & SSH_NEW_OPENSSH))\n\t\treturn;\n\tif (!c->have_remote_id)\n\t\tfatal_f(\"channel %d: no remote_id\", c->self);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"eow@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send CHANNEL_EOF\");\n}\n\n \n\nvoid\nchan_rcvd_ieof(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd eof\", c->self);\n\tc->flags |= CHAN_EOF_RCVD;\n\tif (c->ostate == CHAN_OUTPUT_OPEN)\n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\tif (c->ostate == CHAN_OUTPUT_WAIT_DRAIN &&\n\t    sshbuf_len(c->output) == 0 &&\n\t    !CHANNEL_EFD_OUTPUT_ACTIVE(c))\n\t\tchan_obuf_empty(ssh, c);\n}\n\nvoid\nchan_rcvd_oclose(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: rcvd close\", c->self);\n\tif (!(c->flags & CHAN_LOCAL)) {\n\t\tif (c->flags & CHAN_CLOSE_RCVD)\n\t\t\terror(\"channel %d: protocol error: close rcvd twice\",\n\t\t\t    c->self);\n\t\tc->flags |= CHAN_CLOSE_RCVD;\n\t}\n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\t \n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\treturn;\n\t}\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\t\t \n\t\tchan_set_ostate(c, CHAN_OUTPUT_WAIT_DRAIN);\n\t\tbreak;\n\t}\n\tswitch (c->istate) {\n\tcase CHAN_INPUT_OPEN:\n\t\tchan_shutdown_read(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\tcase CHAN_INPUT_WAIT_DRAIN:\n\t\tif (!(c->flags & CHAN_LOCAL))\n\t\t\tchan_send_eof2(ssh, c);\n\t\tchan_shutdown_extended_read(ssh, c);\n\t\tchan_set_istate(c, CHAN_INPUT_CLOSED);\n\t\tbreak;\n\t}\n}\n\nvoid\nchan_write_failed(struct ssh *ssh, Channel *c)\n{\n\tdebug2(\"channel %d: write failed\", c->self);\n\tswitch (c->ostate) {\n\tcase CHAN_OUTPUT_OPEN:\n\tcase CHAN_OUTPUT_WAIT_DRAIN:\n\t\tchan_shutdown_write(ssh, c);\n\t\tif (strcmp(c->ctype, \"session\") == 0)\n\t\t\tchan_send_eow2(ssh, c);\n\t\tchan_set_ostate(c, CHAN_OUTPUT_CLOSED);\n\t\tbreak;\n\tdefault:\n\t\terror(\"channel %d: chan_write_failed for ostate %d\",\n\t\t    c->self, c->ostate);\n\t\tbreak;\n\t}\n}\n\nvoid\nchan_mark_dead(struct ssh *ssh, Channel *c)\n{\n\tc->type = SSH_CHANNEL_ZOMBIE;\n}\n\nint\nchan_is_dead(struct ssh *ssh, Channel *c, int do_send)\n{\n\tif (c->type == SSH_CHANNEL_ZOMBIE) {\n\t\tdebug2(\"channel %d: zombie\", c->self);\n\t\treturn 1;\n\t}\n\tif (c->istate != CHAN_INPUT_CLOSED || c->ostate != CHAN_OUTPUT_CLOSED)\n\t\treturn 0;\n\tif ((ssh->compat & SSH_BUG_EXTEOF) &&\n\t    c->extended_usage == CHAN_EXTENDED_WRITE &&\n\t    c->efd != -1 &&\n\t    sshbuf_len(c->extended) > 0) {\n\t\tdebug2(\"channel %d: active efd: %d len %zu\",\n\t\t    c->self, c->efd, sshbuf_len(c->extended));\n\t\treturn 0;\n\t}\n\tif (c->flags & CHAN_LOCAL) {\n\t\tdebug2(\"channel %d: is dead (local)\", c->self);\n\t\treturn 1;\n\t}\t\t\n\tif (!(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (do_send) {\n\t\t\tchan_send_close2(ssh, c);\n\t\t} else {\n\t\t\t \n\t\t\tif (c->flags & CHAN_CLOSE_RCVD) {\n\t\t\t\tdebug2(\"channel %d: almost dead\",\n\t\t\t\t    c->self);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif ((c->flags & CHAN_CLOSE_SENT) &&\n\t    (c->flags & CHAN_CLOSE_RCVD)) {\n\t\tdebug2(\"channel %d: is dead\", c->self);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nchan_shutdown_write(struct ssh *ssh, Channel *c)\n{\n\tsshbuf_reset(c->output);\n\tif (c->type == SSH_CHANNEL_LARVAL)\n\t\treturn;\n\t \n\tdebug2_f(\"channel %d: (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, c->istate, c->ostate, c->sock, c->wfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (c->sock != -1) {\n\t\tif (shutdown(c->sock, SHUT_WR) == -1) {\n\t\t\tdebug2_f(\"channel %d: shutdown() failed for \"\n\t\t\t    \"fd %d [i%d o%d]: %.100s\", c->self, c->sock,\n\t\t\t    c->istate, c->ostate, strerror(errno));\n\t\t}\n\t} else {\n\t\tif (channel_close_fd(ssh, c, &c->wfd) < 0) {\n\t\t\tlogit_f(\"channel %d: close() failed for \"\n\t\t\t    \"fd %d [i%d o%d]: %.100s\", c->self, c->wfd,\n\t\t\t    c->istate, c->ostate, strerror(errno));\n\t\t}\n\t}\n}\n\nstatic void\nchan_shutdown_read(struct ssh *ssh, Channel *c)\n{\n\tif (c->type == SSH_CHANNEL_LARVAL)\n\t\treturn;\n\tdebug2_f(\"channel %d: (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, c->istate, c->ostate, c->sock, c->rfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (c->sock != -1) {\n\t\t \n\t\tif (shutdown(c->sock, SHUT_RD) == -1 && errno != ENOTCONN) {\n\t\t\terror_f(\"channel %d: shutdown() failed for \"\n\t\t\t    \"fd %d [i%d o%d]: %.100s\", c->self, c->sock,\n\t\t\t    c->istate, c->ostate, strerror(errno));\n\t\t}\n\t} else {\n\t\tif (channel_close_fd(ssh, c, &c->rfd) < 0) {\n\t\t\tlogit_f(\"channel %d: close() failed for \"\n\t\t\t    \"fd %d [i%d o%d]: %.100s\", c->self, c->rfd,\n\t\t\t    c->istate, c->ostate, strerror(errno));\n\t\t}\n\t}\n}\n\nstatic void\nchan_shutdown_extended_read(struct ssh *ssh, Channel *c)\n{\n\tif (c->type == SSH_CHANNEL_LARVAL || c->efd == -1)\n\t\treturn;\n\tif (c->extended_usage != CHAN_EXTENDED_READ &&\n\t    c->extended_usage != CHAN_EXTENDED_IGNORE)\n\t\treturn;\n\tdebug_f(\"channel %d: (i%d o%d sock %d wfd %d efd %d [%s])\",\n\t    c->self, c->istate, c->ostate, c->sock, c->rfd, c->efd,\n\t    channel_format_extended_usage(c));\n\tif (channel_close_fd(ssh, c, &c->efd) < 0) {\n\t\tlogit_f(\"channel %d: close() failed for \"\n\t\t    \"extended fd %d [i%d o%d]: %.100s\", c->self, c->efd,\n\t\t    c->istate, c->ostate, strerror(errno));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}