{
  "module_name": "ssh-keyscan.c",
  "hash_id": "4a7f0d82c306ccae78c3ba220f42c685f911d0ddfbf766ca46a763f65dfb48c6",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-keyscan.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n \n#include <sys/types.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/resource.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/bn.h>\n#endif\n\n#include <limits.h>\n#include <netdb.h>\n#include <errno.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"compat.h\"\n#include \"myproposal.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"log.h\"\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"ssh_api.h\"\n#include \"dns.h\"\n#include \"addr.h\"\n\n \nint IPv4or6 = AF_UNSPEC;\n\nint ssh_port = SSH_DEFAULT_PORT;\n\n#define KT_DSA\t\t(1)\n#define KT_RSA\t\t(1<<1)\n#define KT_ECDSA\t(1<<2)\n#define KT_ED25519\t(1<<3)\n#define KT_XMSS\t\t(1<<4)\n#define KT_ECDSA_SK\t(1<<5)\n#define KT_ED25519_SK\t(1<<6)\n\n#define KT_MIN\t\tKT_DSA\n#define KT_MAX\t\tKT_ED25519_SK\n\nint get_cert = 0;\nint get_keytypes = KT_RSA|KT_ECDSA|KT_ED25519|KT_ECDSA_SK|KT_ED25519_SK;\n\nint hash_hosts = 0;\t\t \n\nint print_sshfp = 0;\t\t \n\nint found_one = 0;\t\t \n\nint hashalg = -1;\t\t \n\n#define MAXMAXFD 256\n\n \nint timeout = 5;\n\nint maxfd;\n#define MAXCON (maxfd - 10)\n\nextern char *__progname;\nstruct pollfd *read_wait;\nint ncon;\n\n \ntypedef struct Connection {\n\tu_char c_status;\t \n#define CS_UNUSED 0\t\t \n#define CS_CON 1\t\t \n#define CS_SIZE 2\t\t \n#define CS_KEYS 3\t\t \n\tint c_fd;\t\t \n\tint c_plen;\t\t \n\tint c_len;\t\t \n\tint c_off;\t\t \n\tint c_keytype;\t\t \n\tsig_atomic_t c_done;\t \n\tchar *c_namebase;\t \n\tchar *c_name;\t\t \n\tchar *c_namelist;\t \n\tchar *c_output_name;\t \n\tchar *c_data;\t\t \n\tstruct ssh *c_ssh;\t \n\tstruct timespec c_ts;\t \n\tTAILQ_ENTRY(Connection) c_link;\t \n} con;\n\nTAILQ_HEAD(conlist, Connection) tq;\t \ncon *fdcon;\n\nstatic void keyprint(con *c, struct sshkey *key);\n\nstatic int\nfdlim_get(int hard)\n{\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_NOFILE)\n\tstruct rlimit rlfd;\n\trlim_t lim;\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlfd) == -1)\n\t\treturn -1;\n\tlim = hard ? rlfd.rlim_max : rlfd.rlim_cur;\n\tif (lim <= 0)\n\t\treturn -1;\n\tif (lim == RLIM_INFINITY)\n\t\tlim = SSH_SYSFDMAX;\n\tif (lim >= INT_MAX)\n\t\tlim = INT_MAX;\n\treturn lim;\n#else\n\treturn (SSH_SYSFDMAX <= 0) ? -1 :\n\t    ((SSH_SYSFDMAX >= INT_MAX) ? INT_MAX : SSH_SYSFDMAX);\n#endif\n}\n\nstatic int\nfdlim_set(int lim)\n{\n#if defined(HAVE_SETRLIMIT) && defined(RLIMIT_NOFILE)\n\tstruct rlimit rlfd;\n#endif\n\n\tif (lim <= 0)\n\t\treturn (-1);\n#if defined(HAVE_SETRLIMIT) && defined(RLIMIT_NOFILE)\n\tif (getrlimit(RLIMIT_NOFILE, &rlfd) == -1)\n\t\treturn (-1);\n\trlfd.rlim_cur = lim;\n\tif (setrlimit(RLIMIT_NOFILE, &rlfd) == -1)\n\t\treturn (-1);\n#elif defined (HAVE_SETDTABLESIZE)\n\tsetdtablesize(lim);\n#endif\n\treturn (0);\n}\n\n \nstatic char *\nxstrsep(char **str, const char *delim)\n{\n\tchar *s, *e;\n\n\tif (!**str)\n\t\treturn (NULL);\n\n\ts = *str;\n\te = s + strcspn(s, delim);\n\n\tif (*e != '\\0')\n\t\t*e++ = '\\0';\n\t*str = e;\n\n\treturn (s);\n}\n\n \nstatic char *\nstrnnsep(char **stringp, char *delim)\n{\n\tchar *tok;\n\n\tdo {\n\t\ttok = xstrsep(stringp, delim);\n\t} while (tok && *tok == '\\0');\n\treturn (tok);\n}\n\n\nstatic int\nkey_print_wrapper(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tcon *c;\n\n\tif ((c = ssh_get_app_data(ssh)) != NULL)\n\t\tkeyprint(c, hostkey);\n\t \n\treturn -1;\n}\n\nstatic int\nssh2_capable(int remote_major, int remote_minor)\n{\n\tswitch (remote_major) {\n\tcase 1:\n\t\tif (remote_minor == 99)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void\nkeygrab_ssh2(con *c)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tint r;\n\n\tswitch (c->c_keytype) {\n\tcase KT_DSA:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"ssh-dss-cert-v01@openssh.com\" : \"ssh-dss\";\n\t\tbreak;\n\tcase KT_RSA:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"rsa-sha2-512-cert-v01@openssh.com,\"\n\t\t    \"rsa-sha2-256-cert-v01@openssh.com,\"\n\t\t    \"ssh-rsa-cert-v01@openssh.com\" :\n\t\t    \"rsa-sha2-512,\"\n\t\t    \"rsa-sha2-256,\"\n\t\t    \"ssh-rsa\";\n\t\tbreak;\n\tcase KT_ED25519:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"ssh-ed25519-cert-v01@openssh.com\" : \"ssh-ed25519\";\n\t\tbreak;\n\tcase KT_XMSS:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"ssh-xmss-cert-v01@openssh.com\" : \"ssh-xmss@openssh.com\";\n\t\tbreak;\n\tcase KT_ECDSA:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"ecdsa-sha2-nistp256-cert-v01@openssh.com,\"\n\t\t    \"ecdsa-sha2-nistp384-cert-v01@openssh.com,\"\n\t\t    \"ecdsa-sha2-nistp521-cert-v01@openssh.com\" :\n\t\t    \"ecdsa-sha2-nistp256,\"\n\t\t    \"ecdsa-sha2-nistp384,\"\n\t\t    \"ecdsa-sha2-nistp521\";\n\t\tbreak;\n\tcase KT_ECDSA_SK:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com\" :\n\t\t    \"sk-ecdsa-sha2-nistp256@openssh.com\";\n\t\tbreak;\n\tcase KT_ED25519_SK:\n\t\tmyproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = get_cert ?\n\t\t    \"sk-ssh-ed25519-cert-v01@openssh.com\" :\n\t\t    \"sk-ssh-ed25519@openssh.com\";\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"unknown key type %d\", c->c_keytype);\n\t\tbreak;\n\t}\n\tif ((r = kex_setup(c->c_ssh, myproposal)) != 0) {\n\t\tfree(c->c_ssh);\n\t\tfprintf(stderr, \"kex_setup: %s\\n\", ssh_err(r));\n\t\texit(1);\n\t}\n#ifdef WITH_OPENSSL\n\tc->c_ssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tc->c_ssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tc->c_ssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tc->c_ssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tc->c_ssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tc->c_ssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tc->c_ssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tc->c_ssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tc->c_ssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tc->c_ssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh_set_verify_host_key_callback(c->c_ssh, key_print_wrapper);\n\t \n\tssh_dispatch_run(c->c_ssh, DISPATCH_BLOCK, &c->c_done);\n}\n\nstatic void\nkeyprint_one(const char *host, struct sshkey *key)\n{\n\tchar *hostport = NULL, *hashed = NULL;\n\tconst char *known_host;\n\tint r = 0;\n\n\tfound_one = 1;\n\n\tif (print_sshfp) {\n\t\texport_dns_rr(host, key, stdout, 0, hashalg);\n\t\treturn;\n\t}\n\n\thostport = put_host_port(host, ssh_port);\n\tlowercase(hostport);\n\tif (hash_hosts && (hashed = host_hash(hostport, NULL, 0)) == NULL)\n\t\tfatal(\"host_hash failed\");\n\tknown_host = hash_hosts ? hashed : hostport;\n\tif (!get_cert)\n\t\tr = fprintf(stdout, \"%s \", known_host);\n\tif (r >= 0 && sshkey_write(key, stdout) == 0)\n\t\t(void)fputs(\"\\n\", stdout);\n\tfree(hashed);\n\tfree(hostport);\n}\n\nstatic void\nkeyprint(con *c, struct sshkey *key)\n{\n\tchar *hosts = c->c_output_name ? c->c_output_name : c->c_name;\n\tchar *host, *ohosts;\n\n\tif (key == NULL)\n\t\treturn;\n\tif (get_cert || (!hash_hosts && ssh_port == SSH_DEFAULT_PORT)) {\n\t\tkeyprint_one(hosts, key);\n\t\treturn;\n\t}\n\tohosts = hosts = xstrdup(hosts);\n\twhile ((host = strsep(&hosts, \",\")) != NULL)\n\t\tkeyprint_one(host, key);\n\tfree(ohosts);\n}\n\nstatic int\ntcpconnect(char *host)\n{\n\tstruct addrinfo hints, *ai, *aitop;\n\tchar strport[NI_MAXSERV];\n\tint gaierr, s = -1;\n\n\tsnprintf(strport, sizeof strport, \"%d\", ssh_port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = IPv4or6;\n\thints.ai_socktype = SOCK_STREAM;\n\tif ((gaierr = getaddrinfo(host, strport, &hints, &aitop)) != 0) {\n\t\terror(\"getaddrinfo %s: %s\", host, ssh_gai_strerror(gaierr));\n\t\treturn -1;\n\t}\n\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\ts = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (s == -1) {\n\t\t\terror(\"socket: %s\", strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\tif (set_nonblock(s) == -1)\n\t\t\tfatal_f(\"set_nonblock(%d)\", s);\n\t\tif (connect(s, ai->ai_addr, ai->ai_addrlen) == -1 &&\n\t\t    errno != EINPROGRESS)\n\t\t\terror(\"connect (`%s'): %s\", host, strerror(errno));\n\t\telse\n\t\t\tbreak;\n\t\tclose(s);\n\t\ts = -1;\n\t}\n\tfreeaddrinfo(aitop);\n\treturn s;\n}\n\nstatic int\nconalloc(const char *iname, const char *oname, int keytype)\n{\n\tchar *namebase, *name, *namelist;\n\tint s;\n\n\tnamebase = namelist = xstrdup(iname);\n\n\tdo {\n\t\tname = xstrsep(&namelist, \",\");\n\t\tif (!name) {\n\t\t\tfree(namebase);\n\t\t\treturn (-1);\n\t\t}\n\t} while ((s = tcpconnect(name)) < 0);\n\n\tif (s >= maxfd)\n\t\tfatal(\"conalloc: fdno %d too high\", s);\n\tif (fdcon[s].c_status)\n\t\tfatal(\"conalloc: attempt to reuse fdno %d\", s);\n\n\tdebug3_f(\"oname %s kt %d\", oname, keytype);\n\tfdcon[s].c_fd = s;\n\tfdcon[s].c_status = CS_CON;\n\tfdcon[s].c_namebase = namebase;\n\tfdcon[s].c_name = name;\n\tfdcon[s].c_namelist = namelist;\n\tfdcon[s].c_output_name = xstrdup(oname);\n\tfdcon[s].c_data = (char *) &fdcon[s].c_plen;\n\tfdcon[s].c_len = 4;\n\tfdcon[s].c_off = 0;\n\tfdcon[s].c_keytype = keytype;\n\tmonotime_ts(&fdcon[s].c_ts);\n\tfdcon[s].c_ts.tv_sec += timeout;\n\tTAILQ_INSERT_TAIL(&tq, &fdcon[s], c_link);\n\tread_wait[s].fd = s;\n\tread_wait[s].events = POLLIN;\n\tncon++;\n\treturn (s);\n}\n\nstatic void\nconfree(int s)\n{\n\tif (s >= maxfd || fdcon[s].c_status == CS_UNUSED)\n\t\tfatal(\"confree: attempt to free bad fdno %d\", s);\n\tfree(fdcon[s].c_namebase);\n\tfree(fdcon[s].c_output_name);\n\tif (fdcon[s].c_status == CS_KEYS)\n\t\tfree(fdcon[s].c_data);\n\tfdcon[s].c_status = CS_UNUSED;\n\tfdcon[s].c_keytype = 0;\n\tif (fdcon[s].c_ssh) {\n\t\tssh_packet_close(fdcon[s].c_ssh);\n\t\tfree(fdcon[s].c_ssh);\n\t\tfdcon[s].c_ssh = NULL;\n\t} else\n\t\tclose(s);\n\tTAILQ_REMOVE(&tq, &fdcon[s], c_link);\n\tread_wait[s].fd = -1;\n\tread_wait[s].events = 0;\n\tncon--;\n}\n\nstatic void\ncontouch(int s)\n{\n\tTAILQ_REMOVE(&tq, &fdcon[s], c_link);\n\tmonotime_ts(&fdcon[s].c_ts);\n\tfdcon[s].c_ts.tv_sec += timeout;\n\tTAILQ_INSERT_TAIL(&tq, &fdcon[s], c_link);\n}\n\nstatic int\nconrecycle(int s)\n{\n\tcon *c = &fdcon[s];\n\tint ret;\n\n\tret = conalloc(c->c_namelist, c->c_output_name, c->c_keytype);\n\tconfree(s);\n\treturn (ret);\n}\n\nstatic void\ncongreet(int s)\n{\n\tint n = 0, remote_major = 0, remote_minor = 0;\n\tchar buf[256], *cp;\n\tchar remote_version[sizeof buf];\n\tsize_t bufsiz;\n\tcon *c = &fdcon[s];\n\n\t \n\tn = snprintf(buf, sizeof buf, \"SSH-%d.%d-OpenSSH-keyscan\\r\\n\",\n\t    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2);\n\tif (n < 0 || (size_t)n >= sizeof(buf)) {\n\t\terror(\"snprintf: buffer too small\");\n\t\tconfree(s);\n\t\treturn;\n\t}\n\tif (atomicio(vwrite, s, buf, n) != (size_t)n) {\n\t\terror(\"write (%s): %s\", c->c_name, strerror(errno));\n\t\tconfree(s);\n\t\treturn;\n\t}\n\n\t \n\tfor (;;) {\n\t\tmemset(buf, '\\0', sizeof(buf));\n\t\tbufsiz = sizeof(buf);\n\t\tcp = buf;\n\t\twhile (bufsiz-- &&\n\t\t    (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\\n') {\n\t\t\tif (*cp == '\\r')\n\t\t\t\t*cp = '\\n';\n\t\t\tcp++;\n\t\t}\n\t\tif (n != 1 || strncmp(buf, \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t}\n\tif (n == 0) {\n\t\tswitch (errno) {\n\t\tcase EPIPE:\n\t\t\terror(\"%s: Connection closed by remote host\", c->c_name);\n\t\t\tbreak;\n\t\tcase ECONNREFUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"read (%s): %s\", c->c_name, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\tconrecycle(s);\n\t\treturn;\n\t}\n\tif (cp >= buf + sizeof(buf)) {\n\t\terror(\"%s: greeting exceeds allowable length\", c->c_name);\n\t\tconfree(s);\n\t\treturn;\n\t}\n\tif (*cp != '\\n' && *cp != '\\r') {\n\t\terror(\"%s: bad greeting\", c->c_name);\n\t\tconfree(s);\n\t\treturn;\n\t}\n\t*cp = '\\0';\n\tif ((c->c_ssh = ssh_packet_set_connection(NULL, s, s)) == NULL)\n\t\tfatal(\"ssh_packet_set_connection failed\");\n\tssh_packet_set_timeout(c->c_ssh, timeout, 1);\n\tssh_set_app_data(c->c_ssh, c);\t \n\tc->c_ssh->compat = 0;\n\tif (sscanf(buf, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) == 3)\n\t\tcompat_banner(c->c_ssh, remote_version);\n\tif (!ssh2_capable(remote_major, remote_minor)) {\n\t\tdebug(\"%s doesn't support ssh2\", c->c_name);\n\t\tconfree(s);\n\t\treturn;\n\t}\n\tfprintf(stderr, \"%c %s:%d %s\\n\", print_sshfp ? ';' : '#',\n\t    c->c_name, ssh_port, chop(buf));\n\tkeygrab_ssh2(c);\n\tconfree(s);\n}\n\nstatic void\nconread(int s)\n{\n\tcon *c = &fdcon[s];\n\tsize_t n;\n\n\tif (c->c_status == CS_CON) {\n\t\tcongreet(s);\n\t\treturn;\n\t}\n\tn = atomicio(read, s, c->c_data + c->c_off, c->c_len - c->c_off);\n\tif (n == 0) {\n\t\terror(\"read (%s): %s\", c->c_name, strerror(errno));\n\t\tconfree(s);\n\t\treturn;\n\t}\n\tc->c_off += n;\n\n\tif (c->c_off == c->c_len)\n\t\tswitch (c->c_status) {\n\t\tcase CS_SIZE:\n\t\t\tc->c_plen = htonl(c->c_plen);\n\t\t\tc->c_len = c->c_plen + 8 - (c->c_plen & 7);\n\t\t\tc->c_off = 0;\n\t\t\tc->c_data = xmalloc(c->c_len);\n\t\t\tc->c_status = CS_KEYS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"conread: invalid status %d\", c->c_status);\n\t\t\tbreak;\n\t\t}\n\n\tcontouch(s);\n}\n\nstatic void\nconloop(void)\n{\n\tstruct timespec seltime, now;\n\tcon *c;\n\tint i;\n\n\tmonotime_ts(&now);\n\tc = TAILQ_FIRST(&tq);\n\n\tif (c && timespeccmp(&c->c_ts, &now, >))\n\t\ttimespecsub(&c->c_ts, &now, &seltime);\n\telse\n\t\ttimespecclear(&seltime);\n\n\twhile (ppoll(read_wait, maxfd, &seltime, NULL) == -1) {\n\t\tif (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK)\n\t\t\tcontinue;\n\t\terror(\"poll error\");\n\t}\n\n\tfor (i = 0; i < maxfd; i++) {\n\t\tif (read_wait[i].revents & (POLLHUP|POLLERR|POLLNVAL))\n\t\t\tconfree(i);\n\t\telse if (read_wait[i].revents & (POLLIN|POLLHUP))\n\t\t\tconread(i);\n\t}\n\n\tc = TAILQ_FIRST(&tq);\n\twhile (c && timespeccmp(&c->c_ts, &now, <)) {\n\t\tint s = c->c_fd;\n\n\t\tc = TAILQ_NEXT(c, c_link);\n\t\tconrecycle(s);\n\t}\n}\n\nstatic void\ndo_one_host(char *host)\n{\n\tchar *name = strnnsep(&host, \" \\t\\n\");\n\tint j;\n\n\tif (name == NULL)\n\t\treturn;\n\tfor (j = KT_MIN; j <= KT_MAX; j *= 2) {\n\t\tif (get_keytypes & j) {\n\t\t\twhile (ncon >= MAXCON)\n\t\t\t\tconloop();\n\t\t\tconalloc(name, *host ? host : name, j);\n\t\t}\n\t}\n}\n\nstatic void\ndo_host(char *host)\n{\n\tchar daddr[128];\n\tstruct xaddr addr, end_addr;\n\tu_int masklen;\n\n\tif (host == NULL)\n\t\treturn;\n\tif (addr_pton_cidr(host, &addr, &masklen) != 0) {\n\t\t \n\t\tdo_one_host(host);\n\t} else {\n\t\t \n\t\tdebug(\"CIDR range %s\", host);\n\t\tend_addr = addr;\n\t\tif (addr_host_to_all1s(&end_addr, masklen) != 0)\n\t\t\tgoto badaddr;\n\t\t \n\t\tfor (;;) {\n\t\t\tif (addr_ntop(&addr, daddr, sizeof(daddr)) != 0) {\n badaddr:\n\t\t\t\terror(\"Invalid address %s\", host);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdebug(\"CIDR expand: address %s\", daddr);\n\t\t\tdo_one_host(daddr);\n\t\t\tif (addr_cmp(&addr, &end_addr) == 0)\n\t\t\t\tbreak;\n\t\t\taddr_increment(&addr);\n\t\t};\n\t}\n}\n\nvoid\nsshfatal(const char *file, const char *func, int line, int showfunc,\n    LogLevel level, const char *suffix, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tsshlogv(file, func, line, showfunc, level, suffix, fmt, args);\n\tva_end(args);\n\tcleanup_exit(255);\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-keyscan [-46cDHv] [-f file] [-O option] [-p port] [-T timeout]\\n\"\n\t    \"                   [-t type] [host | addrlist namelist]\\n\");\n\texit(1);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint debug_flag = 0, log_level = SYSLOG_LEVEL_INFO;\n\tint opt, fopt_count = 0, j;\n\tchar *tname, *cp, *line = NULL;\n\tsize_t linesize = 0;\n\tFILE *fp;\n\n\textern int optind;\n\textern char *optarg;\n\n\t__progname = ssh_get_progname(argv[0]);\n\tseed_rng();\n\tTAILQ_INIT(&tq);\n\n\t \n\tsanitise_stdfd();\n\n\tif (argc <= 1)\n\t\tusage();\n\n\twhile ((opt = getopt(argc, argv, \"cDHv46O:p:T:t:f:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'H':\n\t\t\thash_hosts = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tget_cert = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tprint_sshfp = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tssh_port = a2port(optarg);\n\t\t\tif (ssh_port <= 0) {\n\t\t\t\tfprintf(stderr, \"Bad port '%s'\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttimeout = convtime(optarg);\n\t\t\tif (timeout == -1 || timeout == 0) {\n\t\t\t\tfprintf(stderr, \"Bad timeout '%s'\\n\", optarg);\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (!debug_flag) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t}\n\t\t\telse if (log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\tlog_level++;\n\t\t\telse\n\t\t\t\tfatal(\"Too high debugging level.\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (strcmp(optarg, \"-\") == 0)\n\t\t\t\toptarg = NULL;\n\t\t\targv[fopt_count++] = optarg;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\t \n\t\t\tif (strncmp(optarg, \"hashalg=\", 8) != 0)\n\t\t\t\tfatal(\"Unsupported -O option\");\n\t\t\tif ((hashalg = ssh_digest_alg_by_name(\n\t\t\t    optarg + 8)) == -1)\n\t\t\t\tfatal(\"Unsupported hash algorithm\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tget_keytypes = 0;\n\t\t\ttname = strtok(optarg, \",\");\n\t\t\twhile (tname) {\n\t\t\t\tint type = sshkey_type_from_name(tname);\n\n\t\t\t\tswitch (type) {\n\t\t\t\tcase KEY_DSA:\n\t\t\t\t\tget_keytypes |= KT_DSA;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_ECDSA:\n\t\t\t\t\tget_keytypes |= KT_ECDSA;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_RSA:\n\t\t\t\t\tget_keytypes |= KT_RSA;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_ED25519:\n\t\t\t\t\tget_keytypes |= KT_ED25519;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_XMSS:\n\t\t\t\t\tget_keytypes |= KT_XMSS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_ED25519_SK:\n\t\t\t\t\tget_keytypes |= KT_ED25519_SK;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_ECDSA_SK:\n\t\t\t\t\tget_keytypes |= KT_ECDSA_SK;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KEY_UNSPEC:\n\t\t\t\tdefault:\n\t\t\t\t\tfatal(\"Unknown key type \\\"%s\\\"\", tname);\n\t\t\t\t}\n\t\t\t\ttname = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\tIPv4or6 = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tIPv4or6 = AF_INET6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tif (optind == argc && !fopt_count)\n\t\tusage();\n\n\tlog_init(\"ssh-keyscan\", log_level, SYSLOG_FACILITY_USER, 1);\n\n\tmaxfd = fdlim_get(1);\n\tif (maxfd < 0)\n\t\tfatal(\"%s: fdlim_get: bad value\", __progname);\n\tif (maxfd > MAXMAXFD)\n\t\tmaxfd = MAXMAXFD;\n\tif (MAXCON <= 0)\n\t\tfatal(\"%s: not enough file descriptors\", __progname);\n\tif (maxfd > fdlim_get(0))\n\t\tfdlim_set(maxfd);\n\tfdcon = xcalloc(maxfd, sizeof(con));\n\tread_wait = xcalloc(maxfd, sizeof(struct pollfd));\n\tfor (j = 0; j < maxfd; j++)\n\t\tread_wait[j].fd = -1;\n\n\tfor (j = 0; j < fopt_count; j++) {\n\t\tif (argv[j] == NULL)\n\t\t\tfp = stdin;\n\t\telse if ((fp = fopen(argv[j], \"r\")) == NULL)\n\t\t\tfatal(\"%s: %s: %s\", __progname, argv[j], strerror(errno));\n\n\t\twhile (getline(&line, &linesize, fp) != -1) {\n\t\t\t \n\t\t\tif ((cp = strchr(line, '#')) == NULL)\n\t\t\t\tcp = line + strlen(line) - 1;\n\t\t\twhile (cp >= line) {\n\t\t\t\tif (*cp == ' ' || *cp == '\\t' ||\n\t\t\t\t    *cp == '\\n' || *cp == '#')\n\t\t\t\t\t*cp-- = '\\0';\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (*line == '\\0')\n\t\t\t\tcontinue;\n\n\t\t\tdo_host(line);\n\t\t}\n\n\t\tif (ferror(fp))\n\t\t\tfatal(\"%s: %s: %s\", __progname, argv[j], strerror(errno));\n\n\t\tfclose(fp);\n\t}\n\tfree(line);\n\n\twhile (optind < argc)\n\t\tdo_host(argv[optind++]);\n\n\twhile (ncon > 0)\n\t\tconloop();\n\n\treturn found_one ? 0 : 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}