{
  "module_name": "atomicio.c",
  "hash_id": "a4c722d2c313182321f815ef2f90d8d2f9b18536db9867094fdb740747930957",
  "original_prompt": "Ingested from openssh-9.6p1/atomicio.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/uio.h>\n\n#include <errno.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"atomicio.h\"\n\n \nsize_t\natomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tchar *s = _s;\n\tsize_t pos = 0;\n\tssize_t res;\n\tstruct pollfd pfd;\n\n\tpfd.fd = fd;\n#ifndef BROKEN_READ_COMPARISON\n\tpfd.events = f == read ? POLLIN : POLLOUT;\n#else\n\tpfd.events = POLLIN|POLLOUT;\n#endif\n\twhile (n > pos) {\n\t\tres = (f) (fd, s + pos, n - pos);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR) {\n\t\t\t\t \n\t\t\t\tif (cb != NULL && cb(cb_arg, 0) == -1) {\n\t\t\t\t\terrno = EINTR;\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\tpos += (size_t)res;\n\t\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\t\terrno = EINTR;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}\n\nsize_t\natomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)\n{\n\treturn atomicio6(f, fd, _s, n, NULL, NULL);\n}\n\n \nsize_t\natomiciov6(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt,\n    int (*cb)(void *, size_t), void *cb_arg)\n{\n\tsize_t pos = 0, rem;\n\tssize_t res;\n\tstruct iovec iov_array[IOV_MAX], *iov = iov_array;\n\tstruct pollfd pfd;\n\n\tif (iovcnt < 0 || iovcnt > IOV_MAX) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t \n\tmemcpy(iov, _iov, (size_t)iovcnt * sizeof(*_iov));\n\n\tpfd.fd = fd;\n#ifndef BROKEN_READV_COMPARISON\n\tpfd.events = f == readv ? POLLIN : POLLOUT;\n#else\n\tpfd.events = POLLIN|POLLOUT;\n#endif\n\tfor (; iovcnt > 0 && iov[0].iov_len > 0;) {\n\t\tres = (f) (fd, iov, iovcnt);\n\t\tswitch (res) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR) {\n\t\t\t\t \n\t\t\t\tif (cb != NULL && cb(cb_arg, 0) == -1) {\n\t\t\t\t\terrno = EINTR;\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t\t\t(void)poll(&pfd, 1, -1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 0:\n\t\t\terrno = EPIPE;\n\t\t\treturn pos;\n\t\tdefault:\n\t\t\trem = (size_t)res;\n\t\t\tpos += rem;\n\t\t\t \n\t\t\twhile (iovcnt > 0 && rem >= iov[0].iov_len) {\n\t\t\t\trem -= iov[0].iov_len;\n\t\t\t\tiov++;\n\t\t\t\tiovcnt--;\n\t\t\t}\n\t\t\t \n\t\t\tif (rem > 0 && (iovcnt <= 0 || rem > iov[0].iov_len)) {\n\t\t\t\terrno = EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (iovcnt == 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tiov[0].iov_base = ((char *)iov[0].iov_base) + rem;\n\t\t\tiov[0].iov_len -= rem;\n\t\t}\n\t\tif (cb != NULL && cb(cb_arg, (size_t)res) == -1) {\n\t\t\terrno = EINTR;\n\t\t\treturn pos;\n\t\t}\n\t}\n\treturn pos;\n}\n\nsize_t\natomiciov(ssize_t (*f) (int, const struct iovec *, int), int fd,\n    const struct iovec *_iov, int iovcnt)\n{\n\treturn atomiciov6(f, fd, _iov, iovcnt, NULL, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}