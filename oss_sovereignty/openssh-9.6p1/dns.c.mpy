{
  "module_name": "dns.c",
  "hash_id": "b88300d2ab3a1f19c65df4569108f4ed91033919c4c19ea2f9142da617e7fac4",
  "original_prompt": "Ingested from openssh-9.6p1/dns.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <netdb.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"xmalloc.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"dns.h\"\n#include \"log.h\"\n#include \"digest.h\"\n\nstatic const char * const errset_text[] = {\n\t\"success\",\t\t \n\t\"out of memory\",\t \n\t\"general failure\",\t \n\t\"invalid parameter\",\t \n\t\"name does not exist\",\t \n\t\"data does not exist\",\t \n};\n\nstatic const char *\ndns_result_totext(unsigned int res)\n{\n\tswitch (res) {\n\tcase ERRSET_SUCCESS:\n\t\treturn errset_text[ERRSET_SUCCESS];\n\tcase ERRSET_NOMEMORY:\n\t\treturn errset_text[ERRSET_NOMEMORY];\n\tcase ERRSET_FAIL:\n\t\treturn errset_text[ERRSET_FAIL];\n\tcase ERRSET_INVAL:\n\t\treturn errset_text[ERRSET_INVAL];\n\tcase ERRSET_NONAME:\n\t\treturn errset_text[ERRSET_NONAME];\n\tcase ERRSET_NODATA:\n\t\treturn errset_text[ERRSET_NODATA];\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}\n\n \nstatic int\ndns_read_key(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, struct sshkey *key)\n{\n\tint r, success = 0;\n\tint fp_alg = -1;\n\n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\t*algorithm = SSHFP_KEY_RSA;\n\t\tbreak;\n\tcase KEY_DSA:\n\t\t*algorithm = SSHFP_KEY_DSA;\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\t*algorithm = SSHFP_KEY_ECDSA;\n\t\tbreak;\n\tcase KEY_ED25519:\n\t\t*algorithm = SSHFP_KEY_ED25519;\n\t\tbreak;\n\tcase KEY_XMSS:\n\t\t*algorithm = SSHFP_KEY_XMSS;\n\t\tbreak;\n\tdefault:\n\t\t*algorithm = SSHFP_KEY_RESERVED;  \n\t}\n\n\tswitch (*digest_type) {\n\tcase SSHFP_HASH_SHA1:\n\t\tfp_alg = SSH_DIGEST_SHA1;\n\t\tbreak;\n\tcase SSHFP_HASH_SHA256:\n\t\tfp_alg = SSH_DIGEST_SHA256;\n\t\tbreak;\n\tdefault:\n\t\t*digest_type = SSHFP_HASH_RESERVED;  \n\t}\n\n\tif (*algorithm && *digest_type) {\n\t\tif ((r = sshkey_fingerprint_raw(key, fp_alg, digest,\n\t\t    digest_len)) != 0)\n\t\t\tfatal_fr(r, \"sshkey_fingerprint_raw\");\n\t\tsuccess = 1;\n\t} else {\n\t\t*digest = NULL;\n\t\t*digest_len = 0;\n\t}\n\n\treturn success;\n}\n\n \nstatic int\ndns_read_rdata(u_int8_t *algorithm, u_int8_t *digest_type,\n    u_char **digest, size_t *digest_len, u_char *rdata, int rdata_len)\n{\n\tint success = 0;\n\n\t*algorithm = SSHFP_KEY_RESERVED;\n\t*digest_type = SSHFP_HASH_RESERVED;\n\n\tif (rdata_len >= 2) {\n\t\t*algorithm = rdata[0];\n\t\t*digest_type = rdata[1];\n\t\t*digest_len = rdata_len - 2;\n\n\t\tif (*digest_len > 0) {\n\t\t\t*digest = xmalloc(*digest_len);\n\t\t\tmemcpy(*digest, rdata + 2, *digest_len);\n\t\t} else {\n\t\t\t*digest = (u_char *)xstrdup(\"\");\n\t\t}\n\n\t\tsuccess = 1;\n\t}\n\n\treturn success;\n}\n\n \nstatic int\nis_numeric_hostname(const char *hostname)\n{\n\tstruct addrinfo hints, *ai;\n\n\t \n\tif (hostname == NULL) {\n\t\terror(\"is_numeric_hostname called with NULL hostname\");\n\t\treturn -1;\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_flags = AI_NUMERICHOST;\n\n\tif (getaddrinfo(hostname, NULL, &hints, &ai) == 0) {\n\t\tfreeaddrinfo(ai);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nint\nverify_host_key_dns(const char *hostname, struct sockaddr *address,\n    struct sshkey *hostkey, int *flags)\n{\n\tu_int counter;\n\tint result;\n\tstruct rrsetinfo *fingerprints = NULL;\n\n\tu_int8_t hostkey_algorithm;\n\tu_char *hostkey_digest;\n\tsize_t hostkey_digest_len;\n\n\tu_int8_t dnskey_algorithm;\n\tu_int8_t dnskey_digest_type;\n\tu_char *dnskey_digest;\n\tsize_t dnskey_digest_len;\n\n\t*flags = 0;\n\n\tdebug3(\"verify_host_key_dns\");\n\tif (hostkey == NULL)\n\t\tfatal(\"No key to look up!\");\n\n\tif (is_numeric_hostname(hostname)) {\n\t\tdebug(\"skipped DNS lookup for numerical hostname\");\n\t\treturn -1;\n\t}\n\n\tresult = getrrsetbyname(hostname, DNS_RDATACLASS_IN,\n\t    DNS_RDATATYPE_SSHFP, 0, &fingerprints);\n\tif (result) {\n\t\tverbose(\"DNS lookup error: %s\", dns_result_totext(result));\n\t\treturn -1;\n\t}\n\n\tif (fingerprints->rri_flags & RRSET_VALIDATED) {\n\t\t*flags |= DNS_VERIFY_SECURE;\n\t\tdebug(\"found %d secure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t} else {\n\t\tdebug(\"found %d insecure fingerprints in DNS\",\n\t\t    fingerprints->rri_nrdatas);\n\t}\n\n\tif (fingerprints->rri_nrdatas)\n\t\t*flags |= DNS_VERIFY_FOUND;\n\n\tfor (counter = 0; counter < fingerprints->rri_nrdatas; counter++) {\n\t\t \n\t\tif (!dns_read_rdata(&dnskey_algorithm, &dnskey_digest_type,\n\t\t    &dnskey_digest, &dnskey_digest_len,\n\t\t    fingerprints->rri_rdatas[counter].rdi_data,\n\t\t    fingerprints->rri_rdatas[counter].rdi_length)) {\n\t\t\tverbose(\"Error parsing fingerprint from DNS.\");\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3_f(\"checking SSHFP type %d fptype %d\", dnskey_algorithm,\n\t\t    dnskey_digest_type);\n\n\t\t \n\t\tif (!dns_read_key(&hostkey_algorithm, &dnskey_digest_type,\n\t\t    &hostkey_digest, &hostkey_digest_len, hostkey)) {\n\t\t\terror(\"Error calculating key fingerprint.\");\n\t\t\tfree(dnskey_digest);\n\t\t\tfreerrset(fingerprints);\n\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif (hostkey_algorithm == dnskey_algorithm &&\n\t\t    hostkey_digest_len == dnskey_digest_len) {\n\t\t\tif (timingsafe_bcmp(hostkey_digest, dnskey_digest,\n\t\t\t    hostkey_digest_len) == 0) {\n\t\t\t\tdebug_f(\"matched SSHFP type %d fptype %d\",\n\t\t\t\t    dnskey_algorithm, dnskey_digest_type);\n\t\t\t\t*flags |= DNS_VERIFY_MATCH;\n\t\t\t} else {\n\t\t\t\tdebug_f(\"failed SSHFP type %d fptype %d\",\n\t\t\t\t    dnskey_algorithm, dnskey_digest_type);\n\t\t\t\t*flags |= DNS_VERIFY_FAILED;\n\t\t\t}\n\t\t}\n\t\tfree(dnskey_digest);\n\t\tfree(hostkey_digest);  \n\t}\n\n\tfreerrset(fingerprints);\n\n\t \n\tif (*flags & DNS_VERIFY_FAILED)\n\t\t*flags &= ~DNS_VERIFY_MATCH;\n\n\tif (*flags & DNS_VERIFY_FOUND)\n\t\tif (*flags & DNS_VERIFY_MATCH)\n\t\t\tdebug(\"matching host key fingerprint found in DNS\");\n\t\telse\n\t\t\tdebug(\"mismatching host key fingerprint found in DNS\");\n\telse\n\t\tdebug(\"no host key fingerprint found in DNS\");\n\n\treturn 0;\n}\n\n \nint\nexport_dns_rr(const char *hostname, struct sshkey *key, FILE *f, int generic,\n    int alg)\n{\n\tu_int8_t rdata_pubkey_algorithm = 0;\n\tu_int8_t rdata_digest_type = SSHFP_HASH_RESERVED;\n\tu_int8_t dtype;\n\tu_char *rdata_digest;\n\tsize_t i, rdata_digest_len;\n\tint success = 0;\n\n\tfor (dtype = SSHFP_HASH_SHA1; dtype < SSHFP_HASH_MAX; dtype++) {\n\t\tif (alg != -1 && dtype != alg)\n\t\t\tcontinue;\n\t\trdata_digest_type = dtype;\n\t\tif (dns_read_key(&rdata_pubkey_algorithm, &rdata_digest_type,\n\t\t    &rdata_digest, &rdata_digest_len, key)) {\n\t\t\tif (generic) {\n\t\t\t\tfprintf(f, \"%s IN TYPE%d \\\\# %zu %02x %02x \",\n\t\t\t\t    hostname, DNS_RDATATYPE_SSHFP,\n\t\t\t\t    2 + rdata_digest_len,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t} else {\n\t\t\t\tfprintf(f, \"%s IN SSHFP %d %d \", hostname,\n\t\t\t\t    rdata_pubkey_algorithm, rdata_digest_type);\n\t\t\t}\n\t\t\tfor (i = 0; i < rdata_digest_len; i++)\n\t\t\t\tfprintf(f, \"%02x\", rdata_digest[i]);\n\t\t\tfprintf(f, \"\\n\");\n\t\t\tfree(rdata_digest);  \n\t\t\tsuccess = 1;\n\t\t}\n\t}\n\n\t \n\tif (success == 0) {\n\t\terror_f(\"unsupported algorithm and/or digest_type\");\n\t}\n\n\treturn success;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}