{
  "module_name": "ssh-keygen.c",
  "hash_id": "ddc208c5437a56f404ea1eb42b4caa34e9357c0707c6fce73a4b4266b338b40e",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-keygen.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include <openssl/pem.h>\n#include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <pwd.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#include <locale.h>\n#include <time.h>\n\n#include \"xmalloc.h\"\n#include \"sshkey.h\"\n#include \"authfile.h\"\n#include \"sshbuf.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"hostfile.h\"\n#include \"dns.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"ssherr.h\"\n#include \"ssh-pkcs11.h\"\n#include \"atomicio.h\"\n#include \"krl.h\"\n#include \"digest.h\"\n#include \"utf8.h\"\n#include \"authfd.h\"\n#include \"sshsig.h\"\n#include \"ssh-sk.h\"\n#include \"sk-api.h\"  \n#include \"cipher.h\"\n\n#define DEFAULT_KEY_TYPE_NAME \"ed25519\"\n\n \n#define DEFAULT_BITS\t\t3072\n#define DEFAULT_BITS_DSA\t1024\n#define DEFAULT_BITS_ECDSA\t256\n\nstatic int quiet = 0;\n\n \nstatic int print_fingerprint = 0;\nstatic int print_bubblebabble = 0;\n\n \nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n \nstatic char identity_file[PATH_MAX];\nstatic int have_identity = 0;\n\n \nstatic char *identity_passphrase = NULL;\n\n \nstatic char *identity_new_passphrase = NULL;\n\n \nstatic u_int cert_key_type = SSH2_CERT_TYPE_USER;\n\n \nstatic char *cert_key_id = NULL;\n\n \nstatic char *cert_principals = NULL;\n\n \nstatic u_int64_t cert_valid_from = 0;\nstatic u_int64_t cert_valid_to = ~0ULL;\n\n \n#define CERTOPT_X_FWD\t\t\t\t(1)\n#define CERTOPT_AGENT_FWD\t\t\t(1<<1)\n#define CERTOPT_PORT_FWD\t\t\t(1<<2)\n#define CERTOPT_PTY\t\t\t\t(1<<3)\n#define CERTOPT_USER_RC\t\t\t\t(1<<4)\n#define CERTOPT_NO_REQUIRE_USER_PRESENCE\t(1<<5)\n#define CERTOPT_REQUIRE_VERIFY\t\t\t(1<<6)\n#define CERTOPT_DEFAULT\t(CERTOPT_X_FWD|CERTOPT_AGENT_FWD| \\\n\t\t\t CERTOPT_PORT_FWD|CERTOPT_PTY|CERTOPT_USER_RC)\nstatic u_int32_t certflags_flags = CERTOPT_DEFAULT;\nstatic char *certflags_command = NULL;\nstatic char *certflags_src_addr = NULL;\n\n \nstruct cert_ext {\n\tchar *key;\n\tchar *val;\n\tint crit;\n};\nstatic struct cert_ext *cert_ext;\nstatic size_t ncert_ext;\n\n \nenum {\n\tFMT_RFC4716,\n\tFMT_PKCS8,\n\tFMT_PEM\n} convert_format = FMT_RFC4716;\n\nstatic char *key_type_name = NULL;\n\n \nstatic char *pkcs11provider = NULL;\n\n \nstatic char *sk_provider = NULL;\n\n \nstatic int private_key_format = SSHKEY_PRIVATE_OPENSSH;\n\n \nstatic char *openssh_format_cipher = NULL;\n\n \nstatic int rounds = 0;\n\n \nextern char *__progname;\n\nstatic char hostname[NI_MAXHOST];\n\n#ifdef WITH_OPENSSL\n \nint gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);\nint prime_test(FILE *, FILE *, u_int32_t, u_int32_t, char *, unsigned long,\n    unsigned long);\n#endif\n\nstatic void\ntype_bits_valid(int type, const char *name, u_int32_t *bitsp)\n{\n\tif (type == KEY_UNSPEC)\n\t\tfatal(\"unknown key type %s\", key_type_name);\n\tif (*bitsp == 0) {\n#ifdef WITH_OPENSSL\n\t\tint nid;\n\n\t\tswitch(type) {\n\t\tcase KEY_DSA:\n\t\t\t*bitsp = DEFAULT_BITS_DSA;\n\t\t\tbreak;\n\t\tcase KEY_ECDSA:\n\t\t\tif (name != NULL &&\n\t\t\t    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)\n\t\t\t\t*bitsp = sshkey_curve_nid_to_bits(nid);\n\t\t\tif (*bitsp == 0)\n\t\t\t\t*bitsp = DEFAULT_BITS_ECDSA;\n\t\t\tbreak;\n\t\tcase KEY_RSA:\n\t\t\t*bitsp = DEFAULT_BITS;\n\t\t\tbreak;\n\t\t}\n#endif\n\t}\n#ifdef WITH_OPENSSL\n\tswitch (type) {\n\tcase KEY_DSA:\n\t\tif (*bitsp != 1024)\n\t\t\tfatal(\"Invalid DSA key length: must be 1024 bits\");\n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif (*bitsp < SSH_RSA_MINIMUM_MODULUS_SIZE)\n\t\t\tfatal(\"Invalid RSA key length: minimum is %d bits\",\n\t\t\t    SSH_RSA_MINIMUM_MODULUS_SIZE);\n\t\telse if (*bitsp > OPENSSL_RSA_MAX_MODULUS_BITS)\n\t\t\tfatal(\"Invalid RSA key length: maximum is %d bits\",\n\t\t\t    OPENSSL_RSA_MAX_MODULUS_BITS);\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)\n#ifdef OPENSSL_HAS_NISTP521\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n\t\t\t    \"256, 384 or 521 bits\");\n#else\n\t\t\tfatal(\"Invalid ECDSA key length: valid lengths are \"\n\t\t\t    \"256 or 384 bits\");\n#endif\n\t}\n#endif\n}\n\n \nstatic int\nconfirm_overwrite(const char *filename)\n{\n\tchar yesno[3];\n\tstruct stat st;\n\n\tif (stat(filename, &st) != 0)\n\t\treturn 1;\n\tprintf(\"%s already exists.\\n\", filename);\n\tprintf(\"Overwrite (y/n)? \");\n\tfflush(stdout);\n\tif (fgets(yesno, sizeof(yesno), stdin) == NULL)\n\t\treturn 0;\n\tif (yesno[0] != 'y' && yesno[0] != 'Y')\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nask_filename(struct passwd *pw, const char *prompt)\n{\n\tchar buf[1024];\n\tchar *name = NULL;\n\n\tif (key_type_name == NULL)\n\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\telse {\n\t\tswitch (sshkey_type_from_name(key_type_name)) {\n\t\tcase KEY_DSA_CERT:\n\t\tcase KEY_DSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_DSA;\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA_CERT:\n\t\tcase KEY_ECDSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA;\n\t\t\tbreak;\n\t\tcase KEY_ECDSA_SK_CERT:\n\t\tcase KEY_ECDSA_SK:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ECDSA_SK;\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA_CERT:\n\t\tcase KEY_RSA:\n\t\t\tname = _PATH_SSH_CLIENT_ID_RSA;\n\t\t\tbreak;\n\t\tcase KEY_ED25519:\n\t\tcase KEY_ED25519_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519;\n\t\t\tbreak;\n\t\tcase KEY_ED25519_SK:\n\t\tcase KEY_ED25519_SK_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_ED25519_SK;\n\t\t\tbreak;\n\t\tcase KEY_XMSS:\n\t\tcase KEY_XMSS_CERT:\n\t\t\tname = _PATH_SSH_CLIENT_ID_XMSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"bad key type\");\n\t\t}\n\t}\n\tsnprintf(identity_file, sizeof(identity_file),\n\t    \"%s/%s\", pw->pw_dir, name);\n\tprintf(\"%s (%s): \", prompt, identity_file);\n\tfflush(stdout);\n\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\texit(1);\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tif (strcmp(buf, \"\") != 0)\n\t\tstrlcpy(identity_file, buf, sizeof(identity_file));\n\thave_identity = 1;\n}\n\nstatic struct sshkey *\nload_identity(const char *filename, char **commentp)\n{\n\tchar *pass;\n\tstruct sshkey *prv;\n\tint r;\n\n\tif (commentp != NULL)\n\t\t*commentp = NULL;\n\tif ((r = sshkey_load_private(filename, \"\", &prv, commentp)) == 0)\n\t\treturn prv;\n\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal_r(r, \"Load key \\\"%s\\\"\", filename);\n\tif (identity_passphrase)\n\t\tpass = xstrdup(identity_passphrase);\n\telse\n\t\tpass = read_passphrase(\"Enter passphrase: \", RP_ALLOW_STDIN);\n\tr = sshkey_load_private(filename, pass, &prv, commentp);\n\tfreezero(pass, strlen(pass));\n\tif (r != 0)\n\t\tfatal_r(r, \"Load key \\\"%s\\\"\", filename);\n\treturn prv;\n}\n\n#define SSH_COM_PUBLIC_BEGIN\t\t\"---- BEGIN SSH2 PUBLIC KEY ----\"\n#define SSH_COM_PUBLIC_END\t\t\"---- END SSH2 PUBLIC KEY ----\"\n#define SSH_COM_PRIVATE_BEGIN\t\t\"---- BEGIN SSH2 ENCRYPTED PRIVATE KEY ----\"\n#define\tSSH_COM_PRIVATE_KEY_MAGIC\t0x3f6ff9eb\n\n#ifdef WITH_OPENSSL\nstatic void\ndo_convert_to_ssh2(struct passwd *pw, struct sshkey *k)\n{\n\tstruct sshbuf *b;\n\tchar comment[61], *b64;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_putb(k, b)) != 0)\n\t\tfatal_fr(r, \"put key\");\n\tif ((b64 = sshbuf_dtob64_string(b, 1)) == NULL)\n\t\tfatal_f(\"sshbuf_dtob64_string failed\");\n\n\t \n\tsnprintf(comment, sizeof(comment),\n\t    \"%u-bit %s, converted by %s@%s from OpenSSH\",\n\t    sshkey_size(k), sshkey_type(k),\n\t    pw->pw_name, hostname);\n\n\tsshkey_free(k);\n\tsshbuf_free(b);\n\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_BEGIN);\n\tfprintf(stdout, \"Comment: \\\"%s\\\"\\n%s\", comment, b64);\n\tfprintf(stdout, \"%s\\n\", SSH_COM_PUBLIC_END);\n\tfree(b64);\n\texit(0);\n}\n\nstatic void\ndo_convert_to_pkcs8(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSA_PUBKEY(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSA_PUBKEY failed\");\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tif (!PEM_write_DSA_PUBKEY(stdout, k->dsa))\n\t\t\tfatal(\"PEM_write_DSA_PUBKEY failed\");\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))\n\t\t\tfatal(\"PEM_write_EC_PUBKEY failed\");\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal_f(\"unsupported key type %s\", sshkey_type(k));\n\t}\n\texit(0);\n}\n\nstatic void\ndo_convert_to_pem(struct sshkey *k)\n{\n\tswitch (sshkey_type_plain(k->type)) {\n\tcase KEY_RSA:\n\t\tif (!PEM_write_RSAPublicKey(stdout, k->rsa))\n\t\t\tfatal(\"PEM_write_RSAPublicKey failed\");\n\t\tbreak;\n\tcase KEY_DSA:\n\t\tif (!PEM_write_DSA_PUBKEY(stdout, k->dsa))\n\t\t\tfatal(\"PEM_write_DSA_PUBKEY failed\");\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase KEY_ECDSA:\n\t\tif (!PEM_write_EC_PUBKEY(stdout, k->ecdsa))\n\t\t\tfatal(\"PEM_write_EC_PUBKEY failed\");\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal_f(\"unsupported key type %s\", sshkey_type(k));\n\t}\n\texit(0);\n}\n\nstatic void\ndo_convert_to(struct passwd *pw)\n{\n\tstruct sshkey *k;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((r = sshkey_load_public(identity_file, &k, NULL)) != 0)\n\t\tk = load_identity(identity_file, NULL);\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_to_ssh2(pw, k);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_to_pkcs8(k);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_to_pem(k);\n\t\tbreak;\n\tdefault:\n\t\tfatal_f(\"unknown key format %d\", convert_format);\n\t}\n\texit(0);\n}\n\n \nstatic void\nbuffer_get_bignum_bits(struct sshbuf *b, BIGNUM *value)\n{\n\tu_int bytes, bignum_bits;\n\tint r;\n\n\tif ((r = sshbuf_get_u32(b, &bignum_bits)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tbytes = (bignum_bits + 7) / 8;\n\tif (sshbuf_len(b) < bytes)\n\t\tfatal_f(\"input buffer too small: need %d have %zu\",\n\t\t    bytes, sshbuf_len(b));\n\tif (BN_bin2bn(sshbuf_ptr(b), bytes, value) == NULL)\n\t\tfatal_f(\"BN_bin2bn failed\");\n\tif ((r = sshbuf_consume(b, bytes)) != 0)\n\t\tfatal_fr(r, \"consume\");\n}\n\nstatic struct sshkey *\ndo_convert_private_ssh2(struct sshbuf *b)\n{\n\tstruct sshkey *key = NULL;\n\tchar *type, *cipher;\n\tconst char *alg = NULL;\n\tu_char e1, e2, e3, *sig = NULL, data[] = \"abcde12345\";\n\tint r, rlen, ktype;\n\tu_int magic, i1, i2, i3, i4;\n\tsize_t slen;\n\tu_long e;\n\tBIGNUM *dsa_p = NULL, *dsa_q = NULL, *dsa_g = NULL;\n\tBIGNUM *dsa_pub_key = NULL, *dsa_priv_key = NULL;\n\tBIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n\tBIGNUM *rsa_p = NULL, *rsa_q = NULL, *rsa_iqmp = NULL;\n\n\tif ((r = sshbuf_get_u32(b, &magic)) != 0)\n\t\tfatal_fr(r, \"parse magic\");\n\n\tif (magic != SSH_COM_PRIVATE_KEY_MAGIC) {\n\t\terror(\"bad magic 0x%x != 0x%x\", magic,\n\t\t    SSH_COM_PRIVATE_KEY_MAGIC);\n\t\treturn NULL;\n\t}\n\tif ((r = sshbuf_get_u32(b, &i1)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &type, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &cipher, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i2)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i3)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &i4)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug(\"ignore (%d %d %d %d)\", i1, i2, i3, i4);\n\tif (strcmp(cipher, \"none\") != 0) {\n\t\terror(\"unsupported cipher %s\", cipher);\n\t\tfree(cipher);\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tfree(cipher);\n\n\tif (strstr(type, \"dsa\")) {\n\t\tktype = KEY_DSA;\n\t} else if (strstr(type, \"rsa\")) {\n\t\tktype = KEY_RSA;\n\t} else {\n\t\tfree(type);\n\t\treturn NULL;\n\t}\n\tif ((key = sshkey_new(ktype)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tfree(type);\n\n\tswitch (key->type) {\n\tcase KEY_DSA:\n\t\tif ((dsa_p = BN_new()) == NULL ||\n\t\t    (dsa_q = BN_new()) == NULL ||\n\t\t    (dsa_g = BN_new()) == NULL ||\n\t\t    (dsa_pub_key = BN_new()) == NULL ||\n\t\t    (dsa_priv_key = BN_new()) == NULL)\n\t\t\tfatal_f(\"BN_new\");\n\t\tbuffer_get_bignum_bits(b, dsa_p);\n\t\tbuffer_get_bignum_bits(b, dsa_g);\n\t\tbuffer_get_bignum_bits(b, dsa_q);\n\t\tbuffer_get_bignum_bits(b, dsa_pub_key);\n\t\tbuffer_get_bignum_bits(b, dsa_priv_key);\n\t\tif (!DSA_set0_pqg(key->dsa, dsa_p, dsa_q, dsa_g))\n\t\t\tfatal_f(\"DSA_set0_pqg failed\");\n\t\tdsa_p = dsa_q = dsa_g = NULL;  \n\t\tif (!DSA_set0_key(key->dsa, dsa_pub_key, dsa_priv_key))\n\t\t\tfatal_f(\"DSA_set0_key failed\");\n\t\tdsa_pub_key = dsa_priv_key = NULL;  \n\t\tbreak;\n\tcase KEY_RSA:\n\t\tif ((r = sshbuf_get_u8(b, &e1)) != 0 ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e2)) != 0) ||\n\t\t    (e1 < 30 && (r = sshbuf_get_u8(b, &e3)) != 0))\n\t\t\tfatal_fr(r, \"parse RSA\");\n\t\te = e1;\n\t\tdebug(\"e %lx\", e);\n\t\tif (e < 30) {\n\t\t\te <<= 8;\n\t\t\te += e2;\n\t\t\tdebug(\"e %lx\", e);\n\t\t\te <<= 8;\n\t\t\te += e3;\n\t\t\tdebug(\"e %lx\", e);\n\t\t}\n\t\tif ((rsa_e = BN_new()) == NULL)\n\t\t\tfatal_f(\"BN_new\");\n\t\tif (!BN_set_word(rsa_e, e)) {\n\t\t\tBN_clear_free(rsa_e);\n\t\t\tsshkey_free(key);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((rsa_n = BN_new()) == NULL ||\n\t\t    (rsa_d = BN_new()) == NULL ||\n\t\t    (rsa_p = BN_new()) == NULL ||\n\t\t    (rsa_q = BN_new()) == NULL ||\n\t\t    (rsa_iqmp = BN_new()) == NULL)\n\t\t\tfatal_f(\"BN_new\");\n\t\tbuffer_get_bignum_bits(b, rsa_d);\n\t\tbuffer_get_bignum_bits(b, rsa_n);\n\t\tbuffer_get_bignum_bits(b, rsa_iqmp);\n\t\tbuffer_get_bignum_bits(b, rsa_q);\n\t\tbuffer_get_bignum_bits(b, rsa_p);\n\t\tif (!RSA_set0_key(key->rsa, rsa_n, rsa_e, rsa_d))\n\t\t\tfatal_f(\"RSA_set0_key failed\");\n\t\trsa_n = rsa_e = rsa_d = NULL;  \n\t\tif (!RSA_set0_factors(key->rsa, rsa_p, rsa_q))\n\t\t\tfatal_f(\"RSA_set0_factors failed\");\n\t\trsa_p = rsa_q = NULL;  \n\t\tif ((r = ssh_rsa_complete_crt_parameters(key, rsa_iqmp)) != 0)\n\t\t\tfatal_fr(r, \"generate RSA parameters\");\n\t\tBN_clear_free(rsa_iqmp);\n\t\talg = \"rsa-sha2-256\";\n\t\tbreak;\n\t}\n\trlen = sshbuf_len(b);\n\tif (rlen != 0)\n\t\terror_f(\"remaining bytes in key blob %d\", rlen);\n\n\t \n\tif ((r = sshkey_sign(key, &sig, &slen, data, sizeof(data),\n\t    alg, NULL, NULL, 0)) != 0)\n\t\terror_fr(r, \"signing with converted key failed\");\n\telse if ((r = sshkey_verify(key, sig, slen, data, sizeof(data),\n\t    alg, 0, NULL)) != 0)\n\t\terror_fr(r, \"verification with converted key failed\");\n\tif (r != 0) {\n\t\tsshkey_free(key);\n\t\tfree(sig);\n\t\treturn NULL;\n\t}\n\tfree(sig);\n\treturn key;\n}\n\nstatic int\nget_line(FILE *fp, char *line, size_t len)\n{\n\tint c;\n\tsize_t pos = 0;\n\n\tline[0] = '\\0';\n\twhile ((c = fgetc(fp)) != EOF) {\n\t\tif (pos >= len - 1)\n\t\t\tfatal(\"input line too long.\");\n\t\tswitch (c) {\n\t\tcase '\\r':\n\t\t\tc = fgetc(fp);\n\t\t\tif (c != EOF && c != '\\n' && ungetc(c, fp) == EOF)\n\t\t\t\tfatal(\"unget: %s\", strerror(errno));\n\t\t\treturn pos;\n\t\tcase '\\n':\n\t\t\treturn pos;\n\t\t}\n\t\tline[pos++] = c;\n\t\tline[pos] = '\\0';\n\t}\n\t \n\treturn -1;\n}\n\nstatic void\ndo_convert_from_ssh2(struct passwd *pw, struct sshkey **k, int *private)\n{\n\tint r, blen, escaped = 0;\n\tu_int len;\n\tchar line[1024];\n\tstruct sshbuf *buf;\n\tchar encoded[8096];\n\tFILE *fp;\n\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tencoded[0] = '\\0';\n\twhile ((blen = get_line(fp, line, sizeof(line))) != -1) {\n\t\tif (blen > 0 && line[blen - 1] == '\\\\')\n\t\t\tescaped++;\n\t\tif (strncmp(line, \"----\", 4) == 0 ||\n\t\t    strstr(line, \": \") != NULL) {\n\t\t\tif (strstr(line, SSH_COM_PRIVATE_BEGIN) != NULL)\n\t\t\t\t*private = 1;\n\t\t\tif (strstr(line, \" END \") != NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (escaped) {\n\t\t\tescaped--;\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tstrlcat(encoded, line, sizeof(encoded));\n\t}\n\tlen = strlen(encoded);\n\tif (((len % 4) == 3) &&\n\t    (encoded[len-1] == '=') &&\n\t    (encoded[len-2] == '=') &&\n\t    (encoded[len-3] == '='))\n\t\tencoded[len-3] = '\\0';\n\tif ((r = sshbuf_b64tod(buf, encoded)) != 0)\n\t\tfatal_fr(r, \"base64 decode\");\n\tif (*private) {\n\t\tif ((*k = do_convert_private_ssh2(buf)) == NULL)\n\t\t\tfatal_f(\"private key conversion failed\");\n\t} else if ((r = sshkey_fromb(buf, k)) != 0)\n\t\tfatal_fr(r, \"parse key\");\n\tsshbuf_free(buf);\n\tfclose(fp);\n}\n\nstatic void\ndo_convert_from_pkcs8(struct sshkey **k, int *private)\n{\n\tEVP_PKEY *pubkey;\n\tFILE *fp;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((pubkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {\n\t\tfatal_f(\"%s is not a recognised public key format\",\n\t\t    identity_file);\n\t}\n\tfclose(fp);\n\tswitch (EVP_PKEY_base_id(pubkey)) {\n\tcase EVP_PKEY_RSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = EVP_PKEY_get1_RSA(pubkey);\n\t\tbreak;\n\tcase EVP_PKEY_DSA:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_DSA;\n\t\t(*k)->dsa = EVP_PKEY_get1_DSA(pubkey);\n\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\tcase EVP_PKEY_EC:\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_ECDSA;\n\t\t(*k)->ecdsa = EVP_PKEY_get1_EC_KEY(pubkey);\n\t\t(*k)->ecdsa_nid = sshkey_ecdsa_key_to_nid((*k)->ecdsa);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tfatal_f(\"unsupported pubkey type %d\",\n\t\t    EVP_PKEY_base_id(pubkey));\n\t}\n\tEVP_PKEY_free(pubkey);\n\treturn;\n}\n\nstatic void\ndo_convert_from_pem(struct sshkey **k, int *private)\n{\n\tFILE *fp;\n\tRSA *rsa;\n\n\tif ((fp = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\tif ((rsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL)) != NULL) {\n\t\tif ((*k = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new failed\");\n\t\t(*k)->type = KEY_RSA;\n\t\t(*k)->rsa = rsa;\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfatal_f(\"unrecognised raw private key format\");\n}\n\nstatic void\ndo_convert_from(struct passwd *pw)\n{\n\tstruct sshkey *k = NULL;\n\tint r, private = 0, ok = 0;\n\tstruct stat st;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tswitch (convert_format) {\n\tcase FMT_RFC4716:\n\t\tdo_convert_from_ssh2(pw, &k, &private);\n\t\tbreak;\n\tcase FMT_PKCS8:\n\t\tdo_convert_from_pkcs8(&k, &private);\n\t\tbreak;\n\tcase FMT_PEM:\n\t\tdo_convert_from_pem(&k, &private);\n\t\tbreak;\n\tdefault:\n\t\tfatal_f(\"unknown key format %d\", convert_format);\n\t}\n\n\tif (!private) {\n\t\tif ((r = sshkey_write(k, stdout)) == 0)\n\t\t\tok = 1;\n\t\tif (ok)\n\t\t\tfprintf(stdout, \"\\n\");\n\t} else {\n\t\tswitch (k->type) {\n\t\tcase KEY_DSA:\n\t\t\tok = PEM_write_DSAPrivateKey(stdout, k->dsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#ifdef OPENSSL_HAS_ECC\n\t\tcase KEY_ECDSA:\n\t\t\tok = PEM_write_ECPrivateKey(stdout, k->ecdsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n#endif\n\t\tcase KEY_RSA:\n\t\t\tok = PEM_write_RSAPrivateKey(stdout, k->rsa, NULL,\n\t\t\t    NULL, 0, NULL, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal_f(\"unsupported key type %s\", sshkey_type(k));\n\t\t}\n\t}\n\n\tif (!ok)\n\t\tfatal(\"key write failed\");\n\tsshkey_free(k);\n\texit(0);\n}\n#endif\n\nstatic void\ndo_print_public(struct passwd *pw)\n{\n\tstruct sshkey *prv;\n\tstruct stat st;\n\tint r;\n\tchar *comment = NULL;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tprv = load_identity(identity_file, &comment);\n\tif ((r = sshkey_write(prv, stdout)) != 0)\n\t\tfatal_fr(r, \"write key\");\n\tif (comment != NULL && *comment != '\\0')\n\t\tfprintf(stdout, \" %s\", comment);\n\tfprintf(stdout, \"\\n\");\n\tif (sshkey_is_sk(prv)) {\n\t\tdebug(\"sk_application: \\\"%s\\\", sk_flags 0x%02x\",\n\t\t\tprv->sk_application, prv->sk_flags);\n\t}\n\tsshkey_free(prv);\n\tfree(comment);\n\texit(0);\n}\n\nstatic void\ndo_download(struct passwd *pw)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL;\n\tint i, nkeys;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp, *ra, **comments = NULL;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tpkcs11_init(1);\n\tnkeys = pkcs11_add_provider(pkcs11provider, NULL, &keys, &comments);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (print_fingerprint) {\n\t\t\tfp = sshkey_fingerprint(keys[i], fptype, rep);\n\t\t\tra = sshkey_fingerprint(keys[i], fingerprint_hash,\n\t\t\t    SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal_f(\"sshkey_fingerprint fail\");\n\t\t\tprintf(\"%u %s %s (PKCS11 key)\\n\", sshkey_size(keys[i]),\n\t\t\t    fp, sshkey_type(keys[i]));\n\t\t\tif (log_level_get() >= SYSLOG_LEVEL_VERBOSE)\n\t\t\t\tprintf(\"%s\\n\", ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t} else {\n\t\t\t(void) sshkey_write(keys[i], stdout);  \n\t\t\tfprintf(stdout, \"%s%s\\n\",\n\t\t\t    *(comments[i]) == '\\0' ? \"\" : \" \", comments[i]);\n\t\t}\n\t\tfree(comments[i]);\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(comments);\n\tfree(keys);\n\tpkcs11_terminate();\n\texit(0);\n#else\n\tfatal(\"no pkcs11 support\");\n#endif  \n}\n\nstatic struct sshkey *\ntry_read_key(char **cpp)\n{\n\tstruct sshkey *ret;\n\tint r;\n\n\tif ((ret = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\tfatal(\"sshkey_new failed\");\n\tif ((r = sshkey_read(ret, cpp)) == 0)\n\t\treturn ret;\n\t \n\tsshkey_free(ret);\n\treturn NULL;\n}\n\nstatic void\nfingerprint_one_key(const struct sshkey *public, const char *comment)\n{\n\tchar *fp = NULL, *ra = NULL;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\tfp = sshkey_fingerprint(public, fptype, rep);\n\tra = sshkey_fingerprint(public, fingerprint_hash, SSH_FP_RANDOMART);\n\tif (fp == NULL || ra == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tmprintf(\"%u %s %s (%s)\\n\", sshkey_size(public), fp,\n\t    comment ? comment : \"no comment\", sshkey_type(public));\n\tif (log_level_get() >= SYSLOG_LEVEL_VERBOSE)\n\t\tprintf(\"%s\\n\", ra);\n\tfree(ra);\n\tfree(fp);\n}\n\nstatic void\nfingerprint_private(const char *path)\n{\n\tstruct stat st;\n\tchar *comment = NULL;\n\tstruct sshkey *privkey = NULL, *pubkey = NULL;\n\tint r;\n\n\tif (stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s\", path, strerror(errno));\n\tif ((r = sshkey_load_public(path, &pubkey, &comment)) != 0)\n\t\tdebug_r(r, \"load public \\\"%s\\\"\", path);\n\tif (pubkey == NULL || comment == NULL || *comment == '\\0') {\n\t\tfree(comment);\n\t\tif ((r = sshkey_load_private(path, NULL,\n\t\t    &privkey, &comment)) != 0)\n\t\t\tdebug_r(r, \"load private \\\"%s\\\"\", path);\n\t}\n\tif (pubkey == NULL && privkey == NULL)\n\t\tfatal(\"%s is not a key file.\", path);\n\n\tfingerprint_one_key(pubkey == NULL ? privkey : pubkey, comment);\n\tsshkey_free(pubkey);\n\tsshkey_free(privkey);\n\tfree(comment);\n}\n\nstatic void\ndo_fingerprint(struct passwd *pw)\n{\n\tFILE *f;\n\tstruct sshkey *public = NULL;\n\tchar *comment = NULL, *cp, *ep, *line = NULL;\n\tsize_t linesize = 0;\n\tint i, invalid = 1;\n\tconst char *path;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tpath = identity_file;\n\n\tif (strcmp(identity_file, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t} else if ((f = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"%s: %s: %s\", __progname, path, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tcp = line;\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\t\t \n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\n\t\t \n\n\t\t \n\t\tif (lnum == 1 && strcmp(identity_file, \"-\") != 0 &&\n\t\t    strstr(cp, \"PRIVATE KEY\") != NULL) {\n\t\t\tfree(line);\n\t\t\tfclose(f);\n\t\t\tfingerprint_private(path);\n\t\t\texit(0);\n\t\t}\n\n\t\t \n\t\tcomment = NULL;\n\t\tif ((public = try_read_key(&cp)) == NULL) {\n\t\t\ti = strtol(cp, &ep, 10);\n\t\t\tif (i == 0 || ep == NULL ||\n\t\t\t    (*ep != ' ' && *ep != '\\t')) {\n\t\t\t\tint quoted = 0;\n\n\t\t\t\tcomment = cp;\n\t\t\t\tfor (; *cp && (quoted || (*cp != ' ' &&\n\t\t\t\t    *cp != '\\t')); cp++) {\n\t\t\t\t\tif (*cp == '\\\\' && cp[1] == '\"')\n\t\t\t\t\t\tcp++;\t \n\t\t\t\t\telse if (*cp == '\"')\n\t\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tif (!*cp)\n\t\t\t\t\tcontinue;\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (public == NULL && (public = try_read_key(&cp)) == NULL) {\n\t\t\tdebug(\"%s:%lu: not a public key\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (*cp != '\\0' && *cp != '#')\n\t\t\tcomment = cp;\n\n\t\tfingerprint_one_key(public, comment);\n\t\tsshkey_free(public);\n\t\tinvalid = 0;  \n\t}\n\tfclose(f);\n\tfree(line);\n\n\tif (invalid)\n\t\tfatal(\"%s is not a public key file.\", path);\n\texit(0);\n}\n\nstatic void\ndo_gen_all_hostkeys(struct passwd *pw)\n{\n\tstruct {\n\t\tchar *key_type;\n\t\tchar *key_type_display;\n\t\tchar *path;\n\t} key_types[] = {\n#ifdef WITH_OPENSSL\n\t\t{ \"rsa\", \"RSA\" ,_PATH_HOST_RSA_KEY_FILE },\n#ifdef OPENSSL_HAS_ECC\n\t\t{ \"ecdsa\", \"ECDSA\",_PATH_HOST_ECDSA_KEY_FILE },\n#endif  \n#endif  \n\t\t{ \"ed25519\", \"ED25519\",_PATH_HOST_ED25519_KEY_FILE },\n#ifdef WITH_XMSS\n\t\t{ \"xmss\", \"XMSS\",_PATH_HOST_XMSS_KEY_FILE },\n#endif  \n\t\t{ NULL, NULL, NULL }\n\t};\n\n\tu_int32_t bits = 0;\n\tint first = 0;\n\tstruct stat st;\n\tstruct sshkey *private, *public;\n\tchar comment[1024], *prv_tmp, *pub_tmp, *prv_file, *pub_file;\n\tint i, type, fd, r;\n\n\tfor (i = 0; key_types[i].key_type; i++) {\n\t\tpublic = private = NULL;\n\t\tprv_tmp = pub_tmp = prv_file = pub_file = NULL;\n\n\t\txasprintf(&prv_file, \"%s%s\",\n\t\t    identity_file, key_types[i].path);\n\n\t\t \n\t\tif (stat(prv_file, &st) == 0) {\n\t\t\tif (st.st_size != 0)\n\t\t\t\tgoto next;\n\t\t} else if (errno != ENOENT) {\n\t\t\terror(\"Could not stat %s: %s\", key_types[i].path,\n\t\t\t    strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t \n\t\txasprintf(&prv_tmp, \"%s%s.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_tmp, \"%s%s.pub.XXXXXXXXXX\",\n\t\t    identity_file, key_types[i].path);\n\t\txasprintf(&pub_file, \"%s%s.pub\",\n\t\t    identity_file, key_types[i].path);\n\n\t\tif (first == 0) {\n\t\t\tfirst = 1;\n\t\t\tprintf(\"%s: generating new host keys: \", __progname);\n\t\t}\n\t\tprintf(\"%s \", key_types[i].key_type_display);\n\t\tfflush(stdout);\n\t\ttype = sshkey_type_from_name(key_types[i].key_type);\n\t\tif ((fd = mkstemp(prv_tmp)) == -1) {\n\t\t\terror(\"Could not save your private key in %s: %s\",\n\t\t\t    prv_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\t(void)close(fd);  \n\t\tbits = 0;\n\t\ttype_bits_valid(type, NULL, &bits);\n\t\tif ((r = sshkey_generate(type, bits, &private)) != 0) {\n\t\t\terror_r(r, \"sshkey_generate failed\");\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\t\tfatal_fr(r, \"sshkey_from_private\");\n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name,\n\t\t    hostname);\n\t\tif ((r = sshkey_save_private(private, prv_tmp, \"\",\n\t\t    comment, private_key_format, openssh_format_cipher,\n\t\t    rounds)) != 0) {\n\t\t\terror_r(r, \"Saving key \\\"%s\\\" failed\", prv_tmp);\n\t\t\tgoto failnext;\n\t\t}\n\t\tif ((fd = mkstemp(pub_tmp)) == -1) {\n\t\t\terror(\"Could not save your public key in %s: %s\",\n\t\t\t    pub_tmp, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\t(void)fchmod(fd, 0644);\n\t\t(void)close(fd);\n\t\tif ((r = sshkey_save_public(public, pub_tmp, comment)) != 0) {\n\t\t\terror_r(r, \"Unable to save public key to %s\",\n\t\t\t    identity_file);\n\t\t\tgoto failnext;\n\t\t}\n\n\t\t \n\t\tif (rename(pub_tmp, pub_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    pub_file, strerror(errno));\n\t\t\tgoto failnext;\n\t\t}\n\t\tif (rename(prv_tmp, prv_file) != 0) {\n\t\t\terror(\"Unable to move %s into position: %s\",\n\t\t\t    key_types[i].path, strerror(errno));\n failnext:\n\t\t\tfirst = 0;\n\t\t\tgoto next;\n\t\t}\n next:\n\t\tsshkey_free(private);\n\t\tsshkey_free(public);\n\t\tfree(prv_tmp);\n\t\tfree(pub_tmp);\n\t\tfree(prv_file);\n\t\tfree(pub_file);\n\t}\n\tif (first != 0)\n\t\tprintf(\"\\n\");\n}\n\nstruct known_hosts_ctx {\n\tconst char *host;\t \n\tFILE *out;\t\t \n\tint has_unhashed;\t \n\tint found_key;\t\t \n\tint invalid;\t\t \n\tint hash_hosts;\t\t \n\tint find_host;\t\t \n\tint delete_host;\t \n};\n\nstatic int\nknown_hosts_hash(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tchar *hashed, *cp, *hosts, *ohosts;\n\tint has_wild = l->hosts && strcspn(l->hosts, \"*?!\") != strlen(l->hosts);\n\tint was_hashed = l->hosts && l->hosts[0] == HASH_DELIM;\n\n\tswitch (l->status) {\n\tcase HKF_STATUS_OK:\n\tcase HKF_STATUS_MATCHED:\n\t\t \n\t\tif (was_hashed || has_wild || l->marker != MRK_NONE) {\n\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\tif (has_wild && !ctx->find_host) {\n\t\t\t\tlogit(\"%s:%lu: ignoring host name \"\n\t\t\t\t    \"with wildcard: %.64s\", l->path,\n\t\t\t\t    l->linenum, l->hosts);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tohosts = hosts = xstrdup(l->hosts);\n\t\twhile ((cp = strsep(&hosts, \",\")) != NULL && *cp != '\\0') {\n\t\t\tlowercase(cp);\n\t\t\tif ((hashed = host_hash(cp, NULL, 0)) == NULL)\n\t\t\t\tfatal(\"hash_host failed\");\n\t\t\tfprintf(ctx->out, \"%s %s\\n\", hashed, l->rawkey);\n\t\t\tfree(hashed);\n\t\t\tctx->has_unhashed = 1;\n\t\t}\n\t\tfree(ohosts);\n\t\treturn 0;\n\tcase HKF_STATUS_INVALID:\n\t\t \n\t\tctx->invalid = 1;\n\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t \n\tdefault:\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\treturn 0;\n\t}\n\t \n\treturn -1;\n}\n\nstatic int\nknown_hosts_find_delete(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct known_hosts_ctx *ctx = (struct known_hosts_ctx *)_ctx;\n\tenum sshkey_fp_rep rep;\n\tint fptype;\n\tchar *fp = NULL, *ra = NULL;\n\n\tfptype = print_bubblebabble ? SSH_DIGEST_SHA1 : fingerprint_hash;\n\trep =    print_bubblebabble ? SSH_FP_BUBBLEBABBLE : SSH_FP_DEFAULT;\n\n\tif (l->status == HKF_STATUS_MATCHED) {\n\t\tif (ctx->delete_host) {\n\t\t\tif (l->marker != MRK_NONE) {\n\t\t\t\t \n\t\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tctx->found_key = 1;\n\t\t\t\tif (!quiet)\n\t\t\t\t\tprintf(\"# Host %s found: line %lu\\n\",\n\t\t\t\t\t    ctx->host, l->linenum);\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (ctx->find_host) {\n\t\t\tctx->found_key = 1;\n\t\t\tif (!quiet) {\n\t\t\t\tprintf(\"# Host %s found: line %lu %s\\n\",\n\t\t\t\t    ctx->host,\n\t\t\t\t    l->linenum, l->marker == MRK_CA ? \"CA\" :\n\t\t\t\t    (l->marker == MRK_REVOKE ? \"REVOKED\" : \"\"));\n\t\t\t}\n\t\t\tif (ctx->hash_hosts)\n\t\t\t\tknown_hosts_hash(l, ctx);\n\t\t\telse if (print_fingerprint) {\n\t\t\t\tfp = sshkey_fingerprint(l->key, fptype, rep);\n\t\t\t\tra = sshkey_fingerprint(l->key,\n\t\t\t\t    fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\t\t\tmprintf(\"%s %s %s%s%s\\n\", ctx->host,\n\t\t\t\t    sshkey_type(l->key), fp,\n\t\t\t\t    l->comment[0] ? \" \" : \"\",\n\t\t\t\t    l->comment);\n\t\t\t\tif (log_level_get() >= SYSLOG_LEVEL_VERBOSE)\n\t\t\t\t\tprintf(\"%s\\n\", ra);\n\t\t\t\tfree(ra);\n\t\t\t\tfree(fp);\n\t\t\t} else\n\t\t\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t\t\treturn 0;\n\t\t}\n\t} else if (ctx->delete_host) {\n\t\t \n\t\tif (l->status == HKF_STATUS_INVALID) {\n\t\t\tctx->invalid = 1;\n\t\t\tlogit(\"%s:%lu: invalid line\", l->path, l->linenum);\n\t\t}\n\t\tfprintf(ctx->out, \"%s\\n\", l->line);\n\t}\n\treturn 0;\n}\n\nstatic void\ndo_known_hosts(struct passwd *pw, const char *name, int find_host,\n    int delete_host, int hash_hosts)\n{\n\tchar *cp, tmp[PATH_MAX], old[PATH_MAX];\n\tint r, fd, oerrno, inplace = 0;\n\tstruct known_hosts_ctx ctx;\n\tu_int foreach_options;\n\tstruct stat sb;\n\n\tif (!have_identity) {\n\t\tcp = tilde_expand_filename(_PATH_SSH_USER_HOSTFILE, pw->pw_uid);\n\t\tif (strlcpy(identity_file, cp, sizeof(identity_file)) >=\n\t\t    sizeof(identity_file))\n\t\t\tfatal(\"Specified known hosts path too long\");\n\t\tfree(cp);\n\t\thave_identity = 1;\n\t}\n\tif (stat(identity_file, &sb) != 0)\n\t\tfatal(\"Cannot stat %s: %s\", identity_file, strerror(errno));\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.out = stdout;\n\tctx.host = name;\n\tctx.hash_hosts = hash_hosts;\n\tctx.find_host = find_host;\n\tctx.delete_host = delete_host;\n\n\t \n\tif (!find_host && (hash_hosts || delete_host)) {\n\t\tif (strlcpy(tmp, identity_file, sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcat(tmp, \".XXXXXXXXXX\", sizeof(tmp)) >= sizeof(tmp) ||\n\t\t    strlcpy(old, identity_file, sizeof(old)) >= sizeof(old) ||\n\t\t    strlcat(old, \".old\", sizeof(old)) >= sizeof(old))\n\t\t\tfatal(\"known_hosts path too long\");\n\t\tumask(077);\n\t\tif ((fd = mkstemp(tmp)) == -1)\n\t\t\tfatal(\"mkstemp: %s\", strerror(errno));\n\t\tif ((ctx.out = fdopen(fd, \"w\")) == NULL) {\n\t\t\toerrno = errno;\n\t\t\tunlink(tmp);\n\t\t\tfatal(\"fdopen: %s\", strerror(oerrno));\n\t\t}\n\t\t(void)fchmod(fd, sb.st_mode & 0644);\n\t\tinplace = 1;\n\t}\n\t \n\tforeach_options = find_host ? HKF_WANT_MATCH : 0;\n\tforeach_options |= print_fingerprint ? HKF_WANT_PARSE_KEY : 0;\n\tif ((r = hostkeys_foreach(identity_file, (find_host || !hash_hosts) ?\n\t    known_hosts_find_delete : known_hosts_hash, &ctx, name, NULL,\n\t    foreach_options, 0)) != 0) {\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t\tfatal_fr(r, \"hostkeys_foreach\");\n\t}\n\n\tif (inplace)\n\t\tfclose(ctx.out);\n\n\tif (ctx.invalid) {\n\t\terror(\"%s is not a valid known_hosts file.\", identity_file);\n\t\tif (inplace) {\n\t\t\terror(\"Not replacing existing known_hosts \"\n\t\t\t    \"file because of errors\");\n\t\t\tunlink(tmp);\n\t\t}\n\t\texit(1);\n\t} else if (delete_host && !ctx.found_key) {\n\t\tlogit(\"Host %s not found in %s\", name, identity_file);\n\t\tif (inplace)\n\t\t\tunlink(tmp);\n\t} else if (inplace) {\n\t\t \n\t\tif (unlink(old) == -1 && errno != ENOENT)\n\t\t\tfatal(\"unlink %.100s: %s\", old, strerror(errno));\n\t\tif (link(identity_file, old) == -1)\n\t\t\tfatal(\"link %.100s to %.100s: %s\", identity_file, old,\n\t\t\t    strerror(errno));\n\t\t \n\t\tif (rename(tmp, identity_file) == -1) {\n\t\t\terror(\"rename\\\"%s\\\" to \\\"%s\\\": %s\", tmp, identity_file,\n\t\t\t    strerror(errno));\n\t\t\tunlink(tmp);\n\t\t\tunlink(old);\n\t\t\texit(1);\n\t\t}\n\n\t\tprintf(\"%s updated.\\n\", identity_file);\n\t\tprintf(\"Original contents retained as %s\\n\", old);\n\t\tif (ctx.has_unhashed) {\n\t\t\tlogit(\"WARNING: %s contains unhashed entries\", old);\n\t\t\tlogit(\"Delete this file to ensure privacy \"\n\t\t\t    \"of hostnames\");\n\t\t}\n\t}\n\n\texit (find_host && !ctx.found_key);\n}\n\n \nstatic void\ndo_change_passphrase(struct passwd *pw)\n{\n\tchar *comment;\n\tchar *old_passphrase, *passphrase1, *passphrase2;\n\tstruct stat st;\n\tstruct sshkey *private;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t \n\tr = sshkey_load_private(identity_file, \"\", &private, &comment);\n\tif (r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\tif (identity_passphrase)\n\t\t\told_passphrase = xstrdup(identity_passphrase);\n\t\telse\n\t\t\told_passphrase =\n\t\t\t    read_passphrase(\"Enter old passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\tr = sshkey_load_private(identity_file, old_passphrase,\n\t\t    &private, &comment);\n\t\tfreezero(old_passphrase, strlen(old_passphrase));\n\t\tif (r != 0)\n\t\t\tgoto badkey;\n\t} else if (r != 0) {\n badkey:\n\t\tfatal_r(r, \"Failed to load key %s\", identity_file);\n\t}\n\tif (comment)\n\t\tmprintf(\"Key has comment '%s'\\n\", comment);\n\n\t \n\tif (identity_new_passphrase) {\n\t\tpassphrase1 = xstrdup(identity_new_passphrase);\n\t\tpassphrase2 = NULL;\n\t} else {\n\t\tpassphrase1 =\n\t\t\tread_passphrase(\"Enter new passphrase (empty for no \"\n\t\t\t    \"passphrase): \", RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(\"Enter same passphrase again: \",\n\t\t    RP_ALLOW_STDIN);\n\n\t\t \n\t\tif (strcmp(passphrase1, passphrase2) != 0) {\n\t\t\texplicit_bzero(passphrase1, strlen(passphrase1));\n\t\t\texplicit_bzero(passphrase2, strlen(passphrase2));\n\t\t\tfree(passphrase1);\n\t\t\tfree(passphrase2);\n\t\t\tprintf(\"Pass phrases do not match.  Try again.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t \n\t\tfreezero(passphrase2, strlen(passphrase2));\n\t}\n\n\t \n\tif ((r = sshkey_save_private(private, identity_file, passphrase1,\n\t    comment, private_key_format, openssh_format_cipher, rounds)) != 0) {\n\t\terror_r(r, \"Saving key \\\"%s\\\" failed\", identity_file);\n\t\tfreezero(passphrase1, strlen(passphrase1));\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\t \n\tfreezero(passphrase1, strlen(passphrase1));\n\tsshkey_free(private);\t\t  \n\tfree(comment);\n\n\tprintf(\"Your identification has been saved with the new passphrase.\\n\");\n\texit(0);\n}\n\n \nstatic int\ndo_print_resource_record(struct passwd *pw, char *fname, char *hname,\n    int print_generic, char * const *opts, size_t nopts)\n{\n\tstruct sshkey *public;\n\tchar *comment = NULL;\n\tstruct stat st;\n\tint r, hash = -1;\n\tsize_t i;\n\n\tfor (i = 0; i < nopts; i++) {\n\t\tif (strncasecmp(opts[i], \"hashalg=\", 8) == 0) {\n\t\t\tif ((hash = ssh_digest_alg_by_name(opts[i] + 8)) == -1)\n\t\t\t\tfatal(\"Unsupported hash algorithm\");\n\t\t} else {\n\t\t\terror(\"Invalid option \\\"%s\\\"\", opts[i]);\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t\tfatal_f(\"no filename\");\n\tif (stat(fname, &st) == -1) {\n\t\tif (errno == ENOENT)\n\t\t\treturn 0;\n\t\tfatal(\"%s: %s\", fname, strerror(errno));\n\t}\n\tif ((r = sshkey_load_public(fname, &public, &comment)) != 0)\n\t\tfatal_r(r, \"Failed to read v2 public key from \\\"%s\\\"\", fname);\n\texport_dns_rr(hname, public, stdout, print_generic, hash);\n\tsshkey_free(public);\n\tfree(comment);\n\treturn 1;\n}\n\n \nstatic void\ndo_change_comment(struct passwd *pw, const char *identity_comment)\n{\n\tchar new_comment[1024], *comment, *passphrase;\n\tstruct sshkey *private;\n\tstruct sshkey *public;\n\tstruct stat st;\n\tint r;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\tif ((r = sshkey_load_private(identity_file, \"\",\n\t    &private, &comment)) == 0)\n\t\tpassphrase = xstrdup(\"\");\n\telse if (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\tfatal_r(r, \"Cannot load private key \\\"%s\\\"\", identity_file);\n\telse {\n\t\tif (identity_passphrase)\n\t\t\tpassphrase = xstrdup(identity_passphrase);\n\t\telse if (identity_new_passphrase)\n\t\t\tpassphrase = xstrdup(identity_new_passphrase);\n\t\telse\n\t\t\tpassphrase = read_passphrase(\"Enter passphrase: \",\n\t\t\t    RP_ALLOW_STDIN);\n\t\t \n\t\tif ((r = sshkey_load_private(identity_file, passphrase,\n\t\t    &private, &comment)) != 0) {\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\t\tfatal_r(r, \"Cannot load private key \\\"%s\\\"\",\n\t\t\t    identity_file);\n\t\t}\n\t}\n\n\tif (private->type != KEY_ED25519 && private->type != KEY_XMSS &&\n\t    private_key_format != SSHKEY_PRIVATE_OPENSSH) {\n\t\terror(\"Comments are only supported for keys stored in \"\n\t\t    \"the new format (-o).\");\n\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\tsshkey_free(private);\n\t\texit(1);\n\t}\n\tif (comment)\n\t\tprintf(\"Old comment: %s\\n\", comment);\n\telse\n\t\tprintf(\"No existing comment\\n\");\n\n\tif (identity_comment) {\n\t\tstrlcpy(new_comment, identity_comment, sizeof(new_comment));\n\t} else {\n\t\tprintf(\"New comment: \");\n\t\tfflush(stdout);\n\t\tif (!fgets(new_comment, sizeof(new_comment), stdin)) {\n\t\t\texplicit_bzero(passphrase, strlen(passphrase));\n\t\t\tsshkey_free(private);\n\t\t\texit(1);\n\t\t}\n\t\tnew_comment[strcspn(new_comment, \"\\n\")] = '\\0';\n\t}\n\tif (comment != NULL && strcmp(comment, new_comment) == 0) {\n\t\tprintf(\"No change to comment\\n\");\n\t\tfree(passphrase);\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(0);\n\t}\n\n\t \n\tif ((r = sshkey_save_private(private, identity_file, passphrase,\n\t    new_comment, private_key_format, openssh_format_cipher,\n\t    rounds)) != 0) {\n\t\terror_r(r, \"Saving key \\\"%s\\\" failed\", identity_file);\n\t\tfreezero(passphrase, strlen(passphrase));\n\t\tsshkey_free(private);\n\t\tfree(comment);\n\t\texit(1);\n\t}\n\tfreezero(passphrase, strlen(passphrase));\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal_fr(r, \"sshkey_from_private\");\n\tsshkey_free(private);\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tif ((r = sshkey_save_public(public, identity_file, new_comment)) != 0)\n\t\tfatal_r(r, \"Unable to save public key to %s\", identity_file);\n\tsshkey_free(public);\n\tfree(comment);\n\n\tif (strlen(new_comment) > 0)\n\t\tprintf(\"Comment '%s' applied\\n\", new_comment);\n\telse\n\t\tprintf(\"Comment removed\\n\");\n\n\texit(0);\n}\n\nstatic void\ncert_ext_add(const char *key, const char *value, int iscrit)\n{\n\tcert_ext = xreallocarray(cert_ext, ncert_ext + 1, sizeof(*cert_ext));\n\tcert_ext[ncert_ext].key = xstrdup(key);\n\tcert_ext[ncert_ext].val = value == NULL ? NULL : xstrdup(value);\n\tcert_ext[ncert_ext].crit = iscrit;\n\tncert_ext++;\n}\n\n \nstatic int\ncert_ext_cmp(const void *_a, const void *_b)\n{\n\tconst struct cert_ext *a = (const struct cert_ext *)_a;\n\tconst struct cert_ext *b = (const struct cert_ext *)_b;\n\tint r;\n\n\tif (a->crit != b->crit)\n\t\treturn (a->crit < b->crit) ? -1 : 1;\n\tif ((r = strcmp(a->key, b->key)) != 0)\n\t\treturn r;\n\tif ((a->val == NULL) != (b->val == NULL))\n\t\treturn (a->val == NULL) ? -1 : 1;\n\tif (a->val != NULL && (r = strcmp(a->val, b->val)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\n#define OPTIONS_CRITICAL\t1\n#define OPTIONS_EXTENSIONS\t2\nstatic void\nprepare_options_buf(struct sshbuf *c, int which)\n{\n\tstruct sshbuf *b;\n\tsize_t i;\n\tint r;\n\tconst struct cert_ext *ext;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tsshbuf_reset(c);\n\tfor (i = 0; i < ncert_ext; i++) {\n\t\text = &cert_ext[i];\n\t\tif ((ext->crit && (which & OPTIONS_EXTENSIONS)) ||\n\t\t    (!ext->crit && (which & OPTIONS_CRITICAL)))\n\t\t\tcontinue;\n\t\tif (ext->val == NULL) {\n\t\t\t \n\t\t\tdebug3_f(\"%s\", ext->key);\n\t\t\tif ((r = sshbuf_put_cstring(c, ext->key)) != 0 ||\n\t\t\t    (r = sshbuf_put_string(c, NULL, 0)) != 0)\n\t\t\t\tfatal_fr(r, \"prepare flag\");\n\t\t} else {\n\t\t\t \n\t\t\tdebug3_f(\"%s=%s\", ext->key, ext->val);\n\t\t\tsshbuf_reset(b);\n\t\t\tif ((r = sshbuf_put_cstring(c, ext->key)) != 0 ||\n\t\t\t    (r = sshbuf_put_cstring(b, ext->val)) != 0 ||\n\t\t\t    (r = sshbuf_put_stringb(c, b)) != 0)\n\t\t\t\tfatal_fr(r, \"prepare k/v\");\n\t\t}\n\t}\n\tsshbuf_free(b);\n}\n\nstatic void\nfinalise_cert_exts(void)\n{\n\t \n\tif (certflags_command != NULL)\n\t\tcert_ext_add(\"force-command\", certflags_command, 1);\n\tif (certflags_src_addr != NULL)\n\t\tcert_ext_add(\"source-address\", certflags_src_addr, 1);\n\tif ((certflags_flags & CERTOPT_REQUIRE_VERIFY) != 0)\n\t\tcert_ext_add(\"verify-required\", NULL, 1);\n\t \n\tif ((certflags_flags & CERTOPT_X_FWD) != 0)\n\t\tcert_ext_add(\"permit-X11-forwarding\", NULL, 0);\n\tif ((certflags_flags & CERTOPT_AGENT_FWD) != 0)\n\t\tcert_ext_add(\"permit-agent-forwarding\", NULL, 0);\n\tif ((certflags_flags & CERTOPT_PORT_FWD) != 0)\n\t\tcert_ext_add(\"permit-port-forwarding\", NULL, 0);\n\tif ((certflags_flags & CERTOPT_PTY) != 0)\n\t\tcert_ext_add(\"permit-pty\", NULL, 0);\n\tif ((certflags_flags & CERTOPT_USER_RC) != 0)\n\t\tcert_ext_add(\"permit-user-rc\", NULL, 0);\n\tif ((certflags_flags & CERTOPT_NO_REQUIRE_USER_PRESENCE) != 0)\n\t\tcert_ext_add(\"no-touch-required\", NULL, 0);\n\t \n\tif (ncert_ext > 0)\n\t\tqsort(cert_ext, ncert_ext, sizeof(*cert_ext), cert_ext_cmp);\n}\n\nstatic struct sshkey *\nload_pkcs11_key(char *path)\n{\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL, *public, *private = NULL;\n\tint r, i, nkeys;\n\n\tif ((r = sshkey_load_public(path, &public, NULL)) != 0)\n\t\tfatal_r(r, \"Couldn't load CA public key \\\"%s\\\"\", path);\n\n\tnkeys = pkcs11_add_provider(pkcs11provider, identity_passphrase,\n\t    &keys, NULL);\n\tdebug3_f(\"%d keys\", nkeys);\n\tif (nkeys <= 0)\n\t\tfatal(\"cannot read public key from pkcs11\");\n\tfor (i = 0; i < nkeys; i++) {\n\t\tif (sshkey_equal_public(public, keys[i])) {\n\t\t\tprivate = keys[i];\n\t\t\tcontinue;\n\t\t}\n\t\tsshkey_free(keys[i]);\n\t}\n\tfree(keys);\n\tsshkey_free(public);\n\treturn private;\n#else\n\tfatal(\"no pkcs11 support\");\n#endif  \n}\n\n \nstatic int\nagent_signer(struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen,\n    const char *alg, const char *provider, const char *pin,\n    u_int compat, void *ctx)\n{\n\tint *agent_fdp = (int *)ctx;\n\n\treturn ssh_agent_sign(*agent_fdp, key, sigp, lenp,\n\t    data, datalen, alg, compat);\n}\n\nstatic void\ndo_ca_sign(struct passwd *pw, const char *ca_key_path, int prefer_agent,\n    unsigned long long cert_serial, int cert_serial_autoinc,\n    int argc, char **argv)\n{\n\tint r, i, found, agent_fd = -1;\n\tu_int n;\n\tstruct sshkey *ca, *public;\n\tchar valid[64], *otmp, *tmp, *cp, *out, *comment;\n\tchar *ca_fp = NULL, **plist = NULL, *pin = NULL;\n\tstruct ssh_identitylist *agent_ids;\n\tsize_t j;\n\tstruct notifier_ctx *notifier = NULL;\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(1);\n#endif\n\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\tif (pkcs11provider != NULL) {\n\t\t \n\t\tif ((ca = load_pkcs11_key(tmp)) == NULL)\n\t\t\tfatal(\"No PKCS#11 key matching %s found\", ca_key_path);\n\t} else if (prefer_agent) {\n\t\t \n\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\tfatal_r(r, \"Cannot load CA public key %s\", tmp);\n\t\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0)\n\t\t\tfatal_r(r, \"Cannot use public key for CA signature\");\n\t\tif ((r = ssh_fetch_identitylist(agent_fd, &agent_ids)) != 0)\n\t\t\tfatal_r(r, \"Retrieve agent key list\");\n\t\tfound = 0;\n\t\tfor (j = 0; j < agent_ids->nkeys; j++) {\n\t\t\tif (sshkey_equal(ca, agent_ids->keys[j])) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tfatal(\"CA key %s not found in agent\", tmp);\n\t\tssh_free_identitylist(agent_ids);\n\t\tca->flags |= SSHKEY_FLAG_EXT;\n\t} else {\n\t\t \n\t\tca = load_identity(tmp, NULL);\n\t\tif (sshkey_is_sk(ca) &&\n\t\t    (ca->sk_flags & SSH_SK_USER_VERIFICATION_REQD)) {\n\t\t\tif ((pin = read_passphrase(\"Enter PIN for CA key: \",\n\t\t\t    RP_ALLOW_STDIN)) == NULL)\n\t\t\t\tfatal_f(\"couldn't read PIN\");\n\t\t}\n\t}\n\tfree(tmp);\n\n\tif (key_type_name != NULL) {\n\t\tif (sshkey_type_from_name(key_type_name) != ca->type) {\n\t\t\tfatal(\"CA key type %s doesn't match specified %s\",\n\t\t\t    sshkey_ssh_name(ca), key_type_name);\n\t\t}\n\t} else if (ca->type == KEY_RSA) {\n\t\t \n\t\tkey_type_name = \"rsa-sha2-512\";\n\t}\n\tca_fp = sshkey_fingerprint(ca, fingerprint_hash, SSH_FP_DEFAULT);\n\n\tfinalise_cert_exts();\n\tfor (i = 0; i < argc; i++) {\n\t\t \n\t\tn = 0;\n\t\tif (cert_principals != NULL) {\n\t\t\totmp = tmp = xstrdup(cert_principals);\n\t\t\tplist = NULL;\n\t\t\tfor (; (cp = strsep(&tmp, \",\")) != NULL; n++) {\n\t\t\t\tplist = xreallocarray(plist, n + 1, sizeof(*plist));\n\t\t\t\tif (*(plist[n] = xstrdup(cp)) == '\\0')\n\t\t\t\t\tfatal(\"Empty principal name\");\n\t\t\t}\n\t\t\tfree(otmp);\n\t\t}\n\t\tif (n > SSHKEY_CERT_MAX_PRINCIPALS)\n\t\t\tfatal(\"Too many certificate principals specified\");\n\n\t\ttmp = tilde_expand_filename(argv[i], pw->pw_uid);\n\t\tif ((r = sshkey_load_public(tmp, &public, &comment)) != 0)\n\t\t\tfatal_r(r, \"load pubkey \\\"%s\\\"\", tmp);\n\t\tif (sshkey_is_cert(public))\n\t\t\tfatal_f(\"key \\\"%s\\\" type %s cannot be certified\",\n\t\t\t    tmp, sshkey_type(public));\n\n\t\t \n\t\tif ((r = sshkey_to_certified(public)) != 0)\n\t\t\tfatal_r(r, \"Could not upgrade key %s to certificate\", tmp);\n\t\tpublic->cert->type = cert_key_type;\n\t\tpublic->cert->serial = (u_int64_t)cert_serial;\n\t\tpublic->cert->key_id = xstrdup(cert_key_id);\n\t\tpublic->cert->nprincipals = n;\n\t\tpublic->cert->principals = plist;\n\t\tpublic->cert->valid_after = cert_valid_from;\n\t\tpublic->cert->valid_before = cert_valid_to;\n\t\tprepare_options_buf(public->cert->critical, OPTIONS_CRITICAL);\n\t\tprepare_options_buf(public->cert->extensions,\n\t\t    OPTIONS_EXTENSIONS);\n\t\tif ((r = sshkey_from_private(ca,\n\t\t    &public->cert->signature_key)) != 0)\n\t\t\tfatal_r(r, \"sshkey_from_private (ca key)\");\n\n\t\tif (agent_fd != -1 && (ca->flags & SSHKEY_FLAG_EXT) != 0) {\n\t\t\tif ((r = sshkey_certify_custom(public, ca,\n\t\t\t    key_type_name, sk_provider, NULL, agent_signer,\n\t\t\t    &agent_fd)) != 0)\n\t\t\t\tfatal_r(r, \"Couldn't certify %s via agent\", tmp);\n\t\t} else {\n\t\t\tif (sshkey_is_sk(ca) &&\n\t\t\t    (ca->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {\n\t\t\t\tnotifier = notify_start(0,\n\t\t\t\t    \"Confirm user presence for key %s %s\",\n\t\t\t\t    sshkey_type(ca), ca_fp);\n\t\t\t}\n\t\t\tr = sshkey_certify(public, ca, key_type_name,\n\t\t\t    sk_provider, pin);\n\t\t\tnotify_complete(notifier, \"User presence confirmed\");\n\t\t\tif (r != 0)\n\t\t\t\tfatal_r(r, \"Couldn't certify key %s\", tmp);\n\t\t}\n\n\t\tif ((cp = strrchr(tmp, '.')) != NULL && strcmp(cp, \".pub\") == 0)\n\t\t\t*cp = '\\0';\n\t\txasprintf(&out, \"%s-cert.pub\", tmp);\n\t\tfree(tmp);\n\n\t\tif ((r = sshkey_save_public(public, out, comment)) != 0) {\n\t\t\tfatal_r(r, \"Unable to save public key to %s\",\n\t\t\t    identity_file);\n\t\t}\n\n\t\tif (!quiet) {\n\t\t\tsshkey_format_cert_validity(public->cert,\n\t\t\t    valid, sizeof(valid));\n\t\t\tlogit(\"Signed %s key %s: id \\\"%s\\\" serial %llu%s%s \"\n\t\t\t    \"valid %s\", sshkey_cert_type(public),\n\t\t\t    out, public->cert->key_id,\n\t\t\t    (unsigned long long)public->cert->serial,\n\t\t\t    cert_principals != NULL ? \" for \" : \"\",\n\t\t\t    cert_principals != NULL ? cert_principals : \"\",\n\t\t\t    valid);\n\t\t}\n\n\t\tsshkey_free(public);\n\t\tfree(out);\n\t\tif (cert_serial_autoinc)\n\t\t\tcert_serial++;\n\t}\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\tfree(ca_fp);\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\texit(0);\n}\n\nstatic u_int64_t\nparse_relative_time(const char *s, time_t now)\n{\n\tint64_t mul, secs;\n\n\tmul = *s == '-' ? -1 : 1;\n\n\tif ((secs = convtime(s + 1)) == -1)\n\t\tfatal(\"Invalid relative certificate time %s\", s);\n\tif (mul == -1 && secs > now)\n\t\tfatal(\"Certificate time %s cannot be represented\", s);\n\treturn now + (u_int64_t)(secs * mul);\n}\n\nstatic void\nparse_hex_u64(const char *s, uint64_t *up)\n{\n\tchar *ep;\n\tunsigned long long ull;\n\n\terrno = 0;\n\tull = strtoull(s, &ep, 16);\n\tif (*s == '\\0' || *ep != '\\0')\n\t\tfatal(\"Invalid certificate time: not a number\");\n\tif (errno == ERANGE && ull == ULONG_MAX)\n\t\tfatal_fr(SSH_ERR_SYSTEM_ERROR, \"Invalid certificate time\");\n\t*up = (uint64_t)ull;\n}\n\nstatic void\nparse_cert_times(char *timespec)\n{\n\tchar *from, *to;\n\ttime_t now = time(NULL);\n\tint64_t secs;\n\n\t \n\tif (*timespec == '+' && strchr(timespec, ':') == NULL) {\n\t\tif ((secs = convtime(timespec + 1)) == -1)\n\t\t\tfatal(\"Invalid relative certificate life %s\", timespec);\n\t\tcert_valid_to = now + secs;\n\t\t \n\t\tcert_valid_from = ((now - 59)/ 60) * 60;\n\t\treturn;\n\t}\n\n\t \n\tfrom = xstrdup(timespec);\n\tto = strchr(from, ':');\n\tif (to == NULL || from == to || *(to + 1) == '\\0')\n\t\tfatal(\"Invalid certificate life specification %s\", timespec);\n\t*to++ = '\\0';\n\n\tif (*from == '-' || *from == '+')\n\t\tcert_valid_from = parse_relative_time(from, now);\n\telse if (strcmp(from, \"always\") == 0)\n\t\tcert_valid_from = 0;\n\telse if (strncmp(from, \"0x\", 2) == 0)\n\t\tparse_hex_u64(from, &cert_valid_from);\n\telse if (parse_absolute_time(from, &cert_valid_from) != 0)\n\t\tfatal(\"Invalid from time \\\"%s\\\"\", from);\n\n\tif (*to == '-' || *to == '+')\n\t\tcert_valid_to = parse_relative_time(to, now);\n\telse if (strcmp(to, \"forever\") == 0)\n\t\tcert_valid_to = ~(u_int64_t)0;\n\telse if (strncmp(to, \"0x\", 2) == 0)\n\t\tparse_hex_u64(to, &cert_valid_to);\n\telse if (parse_absolute_time(to, &cert_valid_to) != 0)\n\t\tfatal(\"Invalid to time \\\"%s\\\"\", to);\n\n\tif (cert_valid_to <= cert_valid_from)\n\t\tfatal(\"Empty certificate validity interval\");\n\tfree(from);\n}\n\nstatic void\nadd_cert_option(char *opt)\n{\n\tchar *val, *cp;\n\tint iscrit = 0;\n\n\tif (strcasecmp(opt, \"clear\") == 0)\n\t\tcertflags_flags = 0;\n\telse if (strcasecmp(opt, \"no-x11-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"permit-x11-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_X_FWD;\n\telse if (strcasecmp(opt, \"no-agent-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"permit-agent-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_AGENT_FWD;\n\telse if (strcasecmp(opt, \"no-port-forwarding\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"permit-port-forwarding\") == 0)\n\t\tcertflags_flags |= CERTOPT_PORT_FWD;\n\telse if (strcasecmp(opt, \"no-pty\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"permit-pty\") == 0)\n\t\tcertflags_flags |= CERTOPT_PTY;\n\telse if (strcasecmp(opt, \"no-user-rc\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_USER_RC;\n\telse if (strcasecmp(opt, \"permit-user-rc\") == 0)\n\t\tcertflags_flags |= CERTOPT_USER_RC;\n\telse if (strcasecmp(opt, \"touch-required\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_NO_REQUIRE_USER_PRESENCE;\n\telse if (strcasecmp(opt, \"no-touch-required\") == 0)\n\t\tcertflags_flags |= CERTOPT_NO_REQUIRE_USER_PRESENCE;\n\telse if (strcasecmp(opt, \"no-verify-required\") == 0)\n\t\tcertflags_flags &= ~CERTOPT_REQUIRE_VERIFY;\n\telse if (strcasecmp(opt, \"verify-required\") == 0)\n\t\tcertflags_flags |= CERTOPT_REQUIRE_VERIFY;\n\telse if (strncasecmp(opt, \"force-command=\", 14) == 0) {\n\t\tval = opt + 14;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty force-command option\");\n\t\tif (certflags_command != NULL)\n\t\t\tfatal(\"force-command already specified\");\n\t\tcertflags_command = xstrdup(val);\n\t} else if (strncasecmp(opt, \"source-address=\", 15) == 0) {\n\t\tval = opt + 15;\n\t\tif (*val == '\\0')\n\t\t\tfatal(\"Empty source-address option\");\n\t\tif (certflags_src_addr != NULL)\n\t\t\tfatal(\"source-address already specified\");\n\t\tif (addr_match_cidr_list(NULL, val) != 0)\n\t\t\tfatal(\"Invalid source-address list\");\n\t\tcertflags_src_addr = xstrdup(val);\n\t} else if (strncasecmp(opt, \"extension:\", 10) == 0 ||\n\t\t    (iscrit = (strncasecmp(opt, \"critical:\", 9) == 0))) {\n\t\tval = xstrdup(strchr(opt, ':') + 1);\n\t\tif ((cp = strchr(val, '=')) != NULL)\n\t\t\t*cp++ = '\\0';\n\t\tcert_ext_add(val, cp, iscrit);\n\t\tfree(val);\n\t} else\n\t\tfatal(\"Unsupported certificate option \\\"%s\\\"\", opt);\n}\n\nstatic void\nshow_options(struct sshbuf *optbuf, int in_critical)\n{\n\tchar *name, *arg, *hex;\n\tstruct sshbuf *options, *option = NULL;\n\tint r;\n\n\tif ((options = sshbuf_fromb(optbuf)) == NULL)\n\t\tfatal_f(\"sshbuf_fromb failed\");\n\twhile (sshbuf_len(options) != 0) {\n\t\tsshbuf_free(option);\n\t\toption = NULL;\n\t\tif ((r = sshbuf_get_cstring(options, &name, NULL)) != 0 ||\n\t\t    (r = sshbuf_froms(options, &option)) != 0)\n\t\t\tfatal_fr(r, \"parse option\");\n\t\tprintf(\"                %s\", name);\n\t\tif (!in_critical &&\n\t\t    (strcmp(name, \"permit-X11-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-agent-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-port-forwarding\") == 0 ||\n\t\t    strcmp(name, \"permit-pty\") == 0 ||\n\t\t    strcmp(name, \"permit-user-rc\") == 0 ||\n\t\t    strcmp(name, \"no-touch-required\") == 0)) {\n\t\t\tprintf(\"\\n\");\n\t\t} else if (in_critical &&\n\t\t    (strcmp(name, \"force-command\") == 0 ||\n\t\t    strcmp(name, \"source-address\") == 0)) {\n\t\t\tif ((r = sshbuf_get_cstring(option, &arg, NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse critical\");\n\t\t\tprintf(\" %s\\n\", arg);\n\t\t\tfree(arg);\n\t\t} else if (in_critical &&\n\t\t    strcmp(name, \"verify-required\") == 0) {\n\t\t\tprintf(\"\\n\");\n\t\t} else if (sshbuf_len(option) > 0) {\n\t\t\thex = sshbuf_dtob16(option);\n\t\t\tprintf(\" UNKNOWN OPTION: %s (len %zu)\\n\",\n\t\t\t    hex, sshbuf_len(option));\n\t\t\tsshbuf_reset(option);\n\t\t\tfree(hex);\n\t\t} else\n\t\t\tprintf(\" UNKNOWN FLAG OPTION\\n\");\n\t\tfree(name);\n\t\tif (sshbuf_len(option) != 0)\n\t\t\tfatal(\"Option corrupt: extra data at end\");\n\t}\n\tsshbuf_free(option);\n\tsshbuf_free(options);\n}\n\nstatic void\nprint_cert(struct sshkey *key)\n{\n\tchar valid[64], *key_fp, *ca_fp;\n\tu_int i;\n\n\tkey_fp = sshkey_fingerprint(key, fingerprint_hash, SSH_FP_DEFAULT);\n\tca_fp = sshkey_fingerprint(key->cert->signature_key,\n\t    fingerprint_hash, SSH_FP_DEFAULT);\n\tif (key_fp == NULL || ca_fp == NULL)\n\t\tfatal_f(\"sshkey_fingerprint fail\");\n\tsshkey_format_cert_validity(key->cert, valid, sizeof(valid));\n\n\tprintf(\"        Type: %s %s certificate\\n\", sshkey_ssh_name(key),\n\t    sshkey_cert_type(key));\n\tprintf(\"        Public key: %s %s\\n\", sshkey_type(key), key_fp);\n\tprintf(\"        Signing CA: %s %s (using %s)\\n\",\n\t    sshkey_type(key->cert->signature_key), ca_fp,\n\t    key->cert->signature_type);\n\tprintf(\"        Key ID: \\\"%s\\\"\\n\", key->cert->key_id);\n\tprintf(\"        Serial: %llu\\n\", (unsigned long long)key->cert->serial);\n\tprintf(\"        Valid: %s\\n\", valid);\n\tprintf(\"        Principals: \");\n\tif (key->cert->nprincipals == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tfor (i = 0; i < key->cert->nprincipals; i++)\n\t\t\tprintf(\"\\n                %s\",\n\t\t\t    key->cert->principals[i]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"        Critical Options: \");\n\tif (sshbuf_len(key->cert->critical) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->critical, 1);\n\t}\n\tprintf(\"        Extensions: \");\n\tif (sshbuf_len(key->cert->extensions) == 0)\n\t\tprintf(\"(none)\\n\");\n\telse {\n\t\tprintf(\"\\n\");\n\t\tshow_options(key->cert->extensions, 0);\n\t}\n}\n\nstatic void\ndo_show_cert(struct passwd *pw)\n{\n\tstruct sshkey *key = NULL;\n\tstruct stat st;\n\tint r, is_stdin = 0, ok = 0;\n\tFILE *f;\n\tchar *cp, *line = NULL;\n\tconst char *path;\n\tsize_t linesize = 0;\n\tu_long lnum = 0;\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which the key is\");\n\tif (strcmp(identity_file, \"-\") != 0 && stat(identity_file, &st) == -1)\n\t\tfatal(\"%s: %s: %s\", __progname, identity_file, strerror(errno));\n\n\tpath = identity_file;\n\tif (strcmp(path, \"-\") == 0) {\n\t\tf = stdin;\n\t\tpath = \"(stdin)\";\n\t\tis_stdin = 1;\n\t} else if ((f = fopen(identity_file, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", identity_file, strerror(errno));\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tlnum++;\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\t \n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal(\"sshkey_new\");\n\t\tif ((r = sshkey_read(key, &cp)) != 0) {\n\t\t\terror_r(r, \"%s:%lu: invalid key\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(key)) {\n\t\t\terror(\"%s:%lu is not a certificate\", path, lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tok = 1;\n\t\tif (!is_stdin && lnum == 1)\n\t\t\tprintf(\"%s:\\n\", path);\n\t\telse\n\t\t\tprintf(\"%s:%lu:\\n\", path, lnum);\n\t\tprint_cert(key);\n\t}\n\tfree(line);\n\tsshkey_free(key);\n\tfclose(f);\n\texit(ok ? 0 : 1);\n}\n\nstatic void\nload_krl(const char *path, struct ssh_krl **krlp)\n{\n\tstruct sshbuf *krlbuf;\n\tint r;\n\n\tif ((r = sshbuf_load_file(path, &krlbuf)) != 0)\n\t\tfatal_r(r, \"Unable to load KRL %s\", path);\n\t \n\tif ((r = ssh_krl_from_blob(krlbuf, krlp)) != 0 ||\n\t    *krlp == NULL)\n\t\tfatal_r(r, \"Invalid KRL file %s\", path);\n\tsshbuf_free(krlbuf);\n}\n\nstatic void\nhash_to_blob(const char *cp, u_char **blobp, size_t *lenp,\n    const char *file, u_long lnum)\n{\n\tchar *tmp;\n\tsize_t tlen;\n\tstruct sshbuf *b;\n\tint r;\n\n\tif (strncmp(cp, \"SHA256:\", 7) != 0)\n\t\tfatal(\"%s:%lu: unsupported hash algorithm\", file, lnum);\n\tcp += 7;\n\n\t \n\tif ((tlen = strlen(cp)) >= SIZE_MAX - 5)\n\t\tfatal_f(\"hash too long: %zu bytes\", tlen);\n\ttmp = xmalloc(tlen + 4 + 1);\n\tstrlcpy(tmp, cp, tlen + 1);\n\twhile ((tlen % 4) != 0) {\n\t\ttmp[tlen++] = '=';\n\t\ttmp[tlen] = '\\0';\n\t}\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_b64tod(b, tmp)) != 0)\n\t\tfatal_r(r, \"%s:%lu: decode hash failed\", file, lnum);\n\tfree(tmp);\n\t*lenp = sshbuf_len(b);\n\t*blobp = xmalloc(*lenp);\n\tmemcpy(*blobp, sshbuf_ptr(b), *lenp);\n\tsshbuf_free(b);\n}\n\nstatic void\nupdate_krl_from_file(struct passwd *pw, const char *file, int wild_ca,\n    const struct sshkey *ca, struct ssh_krl *krl)\n{\n\tstruct sshkey *key = NULL;\n\tu_long lnum = 0;\n\tchar *path, *cp, *ep, *line = NULL;\n\tu_char *blob = NULL;\n\tsize_t blen = 0, linesize = 0;\n\tunsigned long long serial, serial2;\n\tint i, was_explicit_key, was_sha1, was_sha256, was_hash, r;\n\tFILE *krl_spec;\n\n\tpath = tilde_expand_filename(file, pw->pw_uid);\n\tif (strcmp(path, \"-\") == 0) {\n\t\tkrl_spec = stdin;\n\t\tfree(path);\n\t\tpath = xstrdup(\"(standard input)\");\n\t} else if ((krl_spec = fopen(path, \"r\")) == NULL)\n\t\tfatal(\"fopen %s: %s\", path, strerror(errno));\n\n\tif (!quiet)\n\t\tprintf(\"Revoking from %s\\n\", path);\n\twhile (getline(&line, &linesize, krl_spec) != -1) {\n\t\tif (linesize >= INT_MAX) {\n\t\t\tfatal_f(\"%s contains unparsable line, len=%zu\",\n\t\t\t    path, linesize);\n\t\t}\n\t\tlnum++;\n\t\twas_explicit_key = was_sha1 = was_sha256 = was_hash = 0;\n\t\tcp = line + strspn(line, \" \\t\");\n\t\t \n\t\tfor (i = 0, r = -1; cp[i] != '\\0'; i++) {\n\t\t\tif (cp[i] == '#' || cp[i] == '\\n') {\n\t\t\t\tcp[i] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cp[i] == ' ' || cp[i] == '\\t') {\n\t\t\t\t \n\t\t\t\tif (r == -1)\n\t\t\t\t\tr = i;\n\t\t\t} else\n\t\t\t\tr = -1;\n\t\t}\n\t\tif (r != -1)\n\t\t\tcp[r] = '\\0';\n\t\tif (*cp == '\\0')\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"serial:\", 7) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by serial number \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 7;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\terrno = 0;\n\t\t\tserial = strtoull(cp, &ep, 0);\n\t\t\tif (*cp == '\\0' || (*ep != '\\0' && *ep != '-'))\n\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t    path, lnum, cp);\n\t\t\tif (errno == ERANGE && serial == ULLONG_MAX)\n\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t    path, lnum);\n\t\t\tserial2 = serial;\n\t\t\tif (*ep == '-') {\n\t\t\t\tcp = ep + 1;\n\t\t\t\terrno = 0;\n\t\t\t\tserial2 = strtoull(cp, &ep, 0);\n\t\t\t\tif (*cp == '\\0' || *ep != '\\0')\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial \\\"%s\\\"\",\n\t\t\t\t\t    path, lnum, cp);\n\t\t\t\tif (errno == ERANGE && serial2 == ULLONG_MAX)\n\t\t\t\t\tfatal(\"%s:%lu: serial out of range\",\n\t\t\t\t\t    path, lnum);\n\t\t\t\tif (serial2 <= serial)\n\t\t\t\t\tfatal(\"%s:%lu: invalid serial range \"\n\t\t\t\t\t    \"%llu:%llu\", path, lnum,\n\t\t\t\t\t    (unsigned long long)serial,\n\t\t\t\t\t    (unsigned long long)serial2);\n\t\t\t}\n\t\t\tif (ssh_krl_revoke_cert_by_serial_range(krl,\n\t\t\t    ca, serial, serial2) != 0) {\n\t\t\t\tfatal_f(\"revoke serial failed\");\n\t\t\t}\n\t\t} else if (strncasecmp(cp, \"id:\", 3) == 0) {\n\t\t\tif (ca == NULL && !wild_ca) {\n\t\t\t\tfatal(\"revoking certificates by key ID \"\n\t\t\t\t    \"requires specification of a CA key\");\n\t\t\t}\n\t\t\tcp += 3;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\tif (ssh_krl_revoke_cert_by_key_id(krl, ca, cp) != 0)\n\t\t\t\tfatal_f(\"revoke key ID failed\");\n\t\t} else if (strncasecmp(cp, \"hash:\", 5) == 0) {\n\t\t\tcp += 5;\n\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\thash_to_blob(cp, &blob, &blen, file, lnum);\n\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t\tif (r != 0)\n\t\t\t\tfatal_fr(r, \"revoke key failed\");\n\t\t} else {\n\t\t\tif (strncasecmp(cp, \"key:\", 4) == 0) {\n\t\t\t\tcp += 4;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_explicit_key = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha1:\", 5) == 0) {\n\t\t\t\tcp += 5;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha1 = 1;\n\t\t\t} else if (strncasecmp(cp, \"sha256:\", 7) == 0) {\n\t\t\t\tcp += 7;\n\t\t\t\tcp = cp + strspn(cp, \" \\t\");\n\t\t\t\twas_sha256 = 1;\n\t\t\t\t \n\t\t\t}\n\t\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\t\tfatal(\"sshkey_new\");\n\t\t\tif ((r = sshkey_read(key, &cp)) != 0)\n\t\t\t\tfatal_r(r, \"%s:%lu: invalid key\", path, lnum);\n\t\t\tif (was_explicit_key)\n\t\t\t\tr = ssh_krl_revoke_key_explicit(krl, key);\n\t\t\telse if (was_sha1) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA1, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha1(krl, blob, blen);\n\t\t\t} else if (was_sha256) {\n\t\t\t\tif (sshkey_fingerprint_raw(key,\n\t\t\t\t    SSH_DIGEST_SHA256, &blob, &blen) != 0) {\n\t\t\t\t\tfatal(\"%s:%lu: fingerprint failed\",\n\t\t\t\t\t    file, lnum);\n\t\t\t\t}\n\t\t\t\tr = ssh_krl_revoke_key_sha256(krl, blob, blen);\n\t\t\t} else\n\t\t\t\tr = ssh_krl_revoke_key(krl, key);\n\t\t\tif (r != 0)\n\t\t\t\tfatal_fr(r, \"revoke key failed\");\n\t\t\tfreezero(blob, blen);\n\t\t\tblob = NULL;\n\t\t\tblen = 0;\n\t\t\tsshkey_free(key);\n\t\t}\n\t}\n\tif (strcmp(path, \"-\") != 0)\n\t\tfclose(krl_spec);\n\tfree(line);\n\tfree(path);\n}\n\nstatic void\ndo_gen_krl(struct passwd *pw, int updating, const char *ca_key_path,\n    unsigned long long krl_version, const char *krl_comment,\n    int argc, char **argv)\n{\n\tstruct ssh_krl *krl;\n\tstruct stat sb;\n\tstruct sshkey *ca = NULL;\n\tint i, r, wild_ca = 0;\n\tchar *tmp;\n\tstruct sshbuf *kbuf;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL generation requires an output file\");\n\tif (stat(identity_file, &sb) == -1) {\n\t\tif (errno != ENOENT)\n\t\t\tfatal(\"Cannot access KRL \\\"%s\\\": %s\",\n\t\t\t    identity_file, strerror(errno));\n\t\tif (updating)\n\t\t\tfatal(\"KRL \\\"%s\\\" does not exist\", identity_file);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (strcasecmp(ca_key_path, \"none\") == 0)\n\t\t\twild_ca = 1;\n\t\telse {\n\t\t\ttmp = tilde_expand_filename(ca_key_path, pw->pw_uid);\n\t\t\tif ((r = sshkey_load_public(tmp, &ca, NULL)) != 0)\n\t\t\t\tfatal_r(r, \"Cannot load CA public key %s\", tmp);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\n\tif (updating)\n\t\tload_krl(identity_file, &krl);\n\telse if ((krl = ssh_krl_init()) == NULL)\n\t\tfatal(\"couldn't create KRL\");\n\n\tif (krl_version != 0)\n\t\tssh_krl_set_version(krl, krl_version);\n\tif (krl_comment != NULL)\n\t\tssh_krl_set_comment(krl, krl_comment);\n\n\tfor (i = 0; i < argc; i++)\n\t\tupdate_krl_from_file(pw, argv[i], wild_ca, ca, krl);\n\n\tif ((kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\tif (ssh_krl_to_blob(krl, kbuf) != 0)\n\t\tfatal(\"Couldn't generate KRL\");\n\tif ((r = sshbuf_write_file(identity_file, kbuf)) != 0)\n\t\tfatal(\"write %s: %s\", identity_file, strerror(errno));\n\tsshbuf_free(kbuf);\n\tssh_krl_free(krl);\n\tsshkey_free(ca);\n}\n\nstatic void\ndo_check_krl(struct passwd *pw, int print_krl, int argc, char **argv)\n{\n\tint i, r, ret = 0;\n\tchar *comment;\n\tstruct ssh_krl *krl;\n\tstruct sshkey *k;\n\n\tif (*identity_file == '\\0')\n\t\tfatal(\"KRL checking requires an input file\");\n\tload_krl(identity_file, &krl);\n\tif (print_krl)\n\t\tkrl_dump(krl, stdout);\n\tfor (i = 0; i < argc; i++) {\n\t\tif ((r = sshkey_load_public(argv[i], &k, &comment)) != 0)\n\t\t\tfatal_r(r, \"Cannot load public key %s\", argv[i]);\n\t\tr = ssh_krl_check_key(krl, k);\n\t\tprintf(\"%s%s%s%s: %s\\n\", argv[i],\n\t\t    *comment ? \" (\" : \"\", comment, *comment ? \")\" : \"\",\n\t\t    r == 0 ? \"ok\" : \"REVOKED\");\n\t\tif (r != 0)\n\t\t\tret = 1;\n\t\tsshkey_free(k);\n\t\tfree(comment);\n\t}\n\tssh_krl_free(krl);\n\texit(ret);\n}\n\nstatic struct sshkey *\nload_sign_key(const char *keypath, const struct sshkey *pubkey)\n{\n\tsize_t i, slen, plen = strlen(keypath);\n\tchar *privpath = xstrdup(keypath);\n\tstatic const char * const suffixes[] = { \"-cert.pub\", \".pub\", NULL };\n\tstruct sshkey *ret = NULL, *privkey = NULL;\n\tint r, waspub = 0;\n\tstruct stat st;\n\n\t \n\tfor (i = 0; suffixes[i]; i++) {\n\t\tslen = strlen(suffixes[i]);\n\t\tif (plen <= slen ||\n\t\t    strcmp(privpath + plen - slen, suffixes[i]) != 0)\n\t\t\tcontinue;\n\t\tprivpath[plen - slen] = '\\0';\n\t\tdebug_f(\"%s looks like a public key, using private key \"\n\t\t    \"path %s instead\", keypath, privpath);\n\t\twaspub = 1;\n\t}\n\tif (waspub && stat(privpath, &st) != 0 && errno == ENOENT)\n\t\tfatal(\"No private key found for public key \\\"%s\\\"\", keypath);\n\tif ((r = sshkey_load_private(privpath, \"\", &privkey, NULL)) != 0 &&\n\t    (r != SSH_ERR_KEY_WRONG_PASSPHRASE)) {\n\t\tdebug_fr(r, \"load private key \\\"%s\\\"\", privpath);\n\t\tfatal(\"No private key found for \\\"%s\\\"\", privpath);\n\t} else if (privkey == NULL)\n\t\tprivkey = load_identity(privpath, NULL);\n\n\tif (!sshkey_equal_public(pubkey, privkey)) {\n\t\terror(\"Public key %s doesn't match private %s\",\n\t\t    keypath, privpath);\n\t\tgoto done;\n\t}\n\tif (sshkey_is_cert(pubkey) && !sshkey_is_cert(privkey)) {\n\t\t \n\t\tif ((r = sshkey_to_certified(privkey)) != 0) {\n\t\t\terror_fr(r, \"sshkey_to_certified\");\n\t\t\tgoto done;\n\t\t}\n\t\tif ((r = sshkey_cert_copy(pubkey, privkey)) != 0) {\n\t\t\terror_fr(r, \"sshkey_cert_copy\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\t \n\tret = privkey;\n\tprivkey = NULL;\n done:\n\tsshkey_free(privkey);\n\tfree(privpath);\n\treturn ret;\n}\n\nstatic int\nsign_one(struct sshkey *signkey, const char *filename, int fd,\n    const char *sig_namespace, const char *hashalg, sshsig_signer *signer,\n    void *signer_ctx)\n{\n\tstruct sshbuf *sigbuf = NULL, *abuf = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR, wfd = -1, oerrno;\n\tchar *wfile = NULL, *asig = NULL, *fp = NULL;\n\tchar *pin = NULL, *prompt = NULL;\n\n\tif (!quiet) {\n\t\tif (fd == STDIN_FILENO)\n\t\t\tfprintf(stderr, \"Signing data on standard input\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Signing file %s\\n\", filename);\n\t}\n\tif (signer == NULL && sshkey_is_sk(signkey)) {\n\t\tif ((signkey->sk_flags & SSH_SK_USER_VERIFICATION_REQD)) {\n\t\t\txasprintf(&prompt, \"Enter PIN for %s key: \",\n\t\t\t    sshkey_type(signkey));\n\t\t\tif ((pin = read_passphrase(prompt,\n\t\t\t    RP_ALLOW_STDIN)) == NULL)\n\t\t\t\tfatal_f(\"couldn't read PIN\");\n\t\t}\n\t\tif ((signkey->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {\n\t\t\tif ((fp = sshkey_fingerprint(signkey, fingerprint_hash,\n\t\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal_f(\"fingerprint failed\");\n\t\t\tfprintf(stderr, \"Confirm user presence for key %s %s\\n\",\n\t\t\t    sshkey_type(signkey), fp);\n\t\t\tfree(fp);\n\t\t}\n\t}\n\tif ((r = sshsig_sign_fd(signkey, hashalg, sk_provider, pin,\n\t    fd, sig_namespace, &sigbuf, signer, signer_ctx)) != 0) {\n\t\terror_r(r, \"Signing %s failed\", filename);\n\t\tgoto out;\n\t}\n\tif ((r = sshsig_armor(sigbuf, &abuf)) != 0) {\n\t\terror_fr(r, \"sshsig_armor\");\n\t\tgoto out;\n\t}\n\tif ((asig = sshbuf_dup_string(abuf)) == NULL) {\n\t\terror_f(\"buffer error\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (fd == STDIN_FILENO) {\n\t\tfputs(asig, stdout);\n\t\tfflush(stdout);\n\t} else {\n\t\txasprintf(&wfile, \"%s.sig\", filename);\n\t\tif (confirm_overwrite(wfile)) {\n\t\t\tif ((wfd = open(wfile, O_WRONLY|O_CREAT|O_TRUNC,\n\t\t\t    0666)) == -1) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror(\"Cannot open %s: %s\",\n\t\t\t\t    wfile, strerror(errno));\n\t\t\t\terrno = oerrno;\n\t\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (atomicio(vwrite, wfd, asig,\n\t\t\t    strlen(asig)) != strlen(asig)) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror(\"Cannot write to %s: %s\",\n\t\t\t\t    wfile, strerror(errno));\n\t\t\t\terrno = oerrno;\n\t\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!quiet) {\n\t\t\t\tfprintf(stderr, \"Write signature to %s\\n\",\n\t\t\t\t    wfile);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tr = 0;\n out:\n\tfree(wfile);\n\tfree(prompt);\n\tfree(asig);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\tsshbuf_free(abuf);\n\tsshbuf_free(sigbuf);\n\tif (wfd != -1)\n\t\tclose(wfd);\n\treturn r;\n}\n\nstatic int\nsig_process_opts(char * const *opts, size_t nopts, char **hashalgp,\n    uint64_t *verify_timep, int *print_pubkey)\n{\n\tsize_t i;\n\ttime_t now;\n\n\tif (verify_timep != NULL)\n\t\t*verify_timep = 0;\n\tif (print_pubkey != NULL)\n\t\t*print_pubkey = 0;\n\tif (hashalgp != NULL)\n\t\t*hashalgp = NULL;\n\tfor (i = 0; i < nopts; i++) {\n\t\tif (hashalgp != NULL &&\n\t\t    strncasecmp(opts[i], \"hashalg=\", 8) == 0) {\n\t\t\t*hashalgp = xstrdup(opts[i] + 8);\n\t\t} else if (verify_timep &&\n\t\t    strncasecmp(opts[i], \"verify-time=\", 12) == 0) {\n\t\t\tif (parse_absolute_time(opts[i] + 12,\n\t\t\t    verify_timep) != 0 || *verify_timep == 0) {\n\t\t\t\terror(\"Invalid \\\"verify-time\\\" option\");\n\t\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t\t}\n\t\t} else if (print_pubkey &&\n\t\t    strcasecmp(opts[i], \"print-pubkey\") == 0) {\n\t\t\t*print_pubkey = 1;\n\t\t} else {\n\t\t\terror(\"Invalid option \\\"%s\\\"\", opts[i]);\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t}\n\t}\n\tif (verify_timep && *verify_timep == 0) {\n\t\tif ((now = time(NULL)) < 0) {\n\t\t\terror(\"Time is before epoch\");\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\t}\n\t\t*verify_timep = (uint64_t)now;\n\t}\n\treturn 0;\n}\n\n\nstatic int\nsig_sign(const char *keypath, const char *sig_namespace, int require_agent,\n    int argc, char **argv, char * const *opts, size_t nopts)\n{\n\tint i, fd = -1, r, ret = -1;\n\tint agent_fd = -1;\n\tstruct sshkey *pubkey = NULL, *privkey = NULL, *signkey = NULL;\n\tsshsig_signer *signer = NULL;\n\tchar *hashalg = NULL;\n\n\t \n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-\") != 0)\n\t\t\tcontinue;\n\t\tif (i > 0 || argc > 1)\n\t\t\tfatal(\"Cannot sign mix of paths and standard input\");\n\t}\n\n\tif (sig_process_opts(opts, nopts, &hashalg, NULL, NULL) != 0)\n\t\tgoto done;  \n\n\tif ((r = sshkey_load_public(keypath, &pubkey, NULL)) != 0) {\n\t\terror_r(r, \"Couldn't load public key %s\", keypath);\n\t\tgoto done;\n\t}\n\n\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {\n\t\tif (require_agent)\n\t\t\tfatal(\"Couldn't get agent socket\");\n\t\tdebug_r(r, \"Couldn't get agent socket\");\n\t} else {\n\t\tif ((r = ssh_agent_has_key(agent_fd, pubkey)) == 0)\n\t\t\tsigner = agent_signer;\n\t\telse {\n\t\t\tif (require_agent)\n\t\t\t\tfatal(\"Couldn't find key in agent\");\n\t\t\tdebug_r(r, \"Couldn't find key in agent\");\n\t\t}\n\t}\n\n\tif (signer == NULL) {\n\t\t \n\t\tif ((privkey = load_sign_key(keypath, pubkey)) == NULL)\n\t\t\tgoto done;\n\t\tsignkey = privkey;\n\t} else {\n\t\t \n\t\tsignkey = pubkey;\n\t}\n\n\tif (argc == 0) {\n\t\tif ((r = sign_one(signkey, \"(stdin)\", STDIN_FILENO,\n\t\t    sig_namespace, hashalg, signer, &agent_fd)) != 0)\n\t\t\tgoto done;\n\t} else {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (strcmp(argv[i], \"-\") == 0)\n\t\t\t\tfd = STDIN_FILENO;\n\t\t\telse if ((fd = open(argv[i], O_RDONLY)) == -1) {\n\t\t\t\terror(\"Cannot open %s for signing: %s\",\n\t\t\t\t    argv[i], strerror(errno));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif ((r = sign_one(signkey, argv[i], fd, sig_namespace,\n\t\t\t    hashalg, signer, &agent_fd)) != 0)\n\t\t\t\tgoto done;\n\t\t\tif (fd != STDIN_FILENO)\n\t\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\t}\n\n\tret = 0;\ndone:\n\tif (fd != -1 && fd != STDIN_FILENO)\n\t\tclose(fd);\n\tsshkey_free(pubkey);\n\tsshkey_free(privkey);\n\tfree(hashalg);\n\treturn ret;\n}\n\nstatic int\nsig_verify(const char *signature, const char *sig_namespace,\n    const char *principal, const char *allowed_keys, const char *revoked_keys,\n    char * const *opts, size_t nopts)\n{\n\tint r, ret = -1;\n\tint print_pubkey = 0;\n\tstruct sshbuf *sigbuf = NULL, *abuf = NULL;\n\tstruct sshkey *sign_key = NULL;\n\tchar *fp = NULL;\n\tstruct sshkey_sig_details *sig_details = NULL;\n\tuint64_t verify_time = 0;\n\n\tif (sig_process_opts(opts, nopts, NULL, &verify_time,\n\t    &print_pubkey) != 0)\n\t\tgoto done;  \n\n\tmemset(&sig_details, 0, sizeof(sig_details));\n\tif ((r = sshbuf_load_file(signature, &abuf)) != 0) {\n\t\terror_r(r, \"Couldn't read signature file\");\n\t\tgoto done;\n\t}\n\n\tif ((r = sshsig_dearmor(abuf, &sigbuf)) != 0) {\n\t\terror_fr(r, \"sshsig_armor\");\n\t\tgoto done;\n\t}\n\tif ((r = sshsig_verify_fd(sigbuf, STDIN_FILENO, sig_namespace,\n\t    &sign_key, &sig_details)) != 0)\n\t\tgoto done;  \n\n\tif ((fp = sshkey_fingerprint(sign_key, fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug(\"Valid (unverified) signature from key %s\", fp);\n\tif (sig_details != NULL) {\n\t\tdebug2_f(\"signature details: counter = %u, flags = 0x%02x\",\n\t\t    sig_details->sk_counter, sig_details->sk_flags);\n\t}\n\tfree(fp);\n\tfp = NULL;\n\n\tif (revoked_keys != NULL) {\n\t\tif ((r = sshkey_check_revoked(sign_key, revoked_keys)) != 0) {\n\t\t\tdebug3_fr(r, \"sshkey_check_revoked\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (allowed_keys != NULL && (r = sshsig_check_allowed_keys(allowed_keys,\n\t    sign_key, principal, sig_namespace, verify_time)) != 0) {\n\t\tdebug3_fr(r, \"sshsig_check_allowed_keys\");\n\t\tgoto done;\n\t}\n\t \n\tret = 0;\ndone:\n\tif (!quiet) {\n\t\tif (ret == 0) {\n\t\t\tif ((fp = sshkey_fingerprint(sign_key, fingerprint_hash,\n\t\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\t\tif (principal == NULL) {\n\t\t\t\tprintf(\"Good \\\"%s\\\" signature with %s key %s\\n\",\n\t\t\t\t    sig_namespace, sshkey_type(sign_key), fp);\n\n\t\t\t} else {\n\t\t\t\tprintf(\"Good \\\"%s\\\" signature for %s with %s key %s\\n\",\n\t\t\t\t    sig_namespace, principal,\n\t\t\t\t    sshkey_type(sign_key), fp);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Could not verify signature.\\n\");\n\t\t}\n\t}\n\t \n\tif (ret == 0 && print_pubkey && sign_key != NULL) {\n\t\tif ((r = sshkey_write(sign_key, stdout)) == 0)\n\t\t\tfputc('\\n', stdout);\n\t\telse {\n\t\t\terror_r(r, \"Could not print public key.\\n\");\n\t\t\tret = -1;\n\t\t}\n\t}\n\tsshbuf_free(sigbuf);\n\tsshbuf_free(abuf);\n\tsshkey_free(sign_key);\n\tsshkey_sig_details_free(sig_details);\n\tfree(fp);\n\treturn ret;\n}\n\nstatic int\nsig_find_principals(const char *signature, const char *allowed_keys,\n    char * const *opts, size_t nopts)\n{\n\tint r, ret = -1;\n\tstruct sshbuf *sigbuf = NULL, *abuf = NULL;\n\tstruct sshkey *sign_key = NULL;\n\tchar *principals = NULL, *cp, *tmp;\n\tuint64_t verify_time = 0;\n\n\tif (sig_process_opts(opts, nopts, NULL, &verify_time, NULL) != 0)\n\t\tgoto done;  \n\n\tif ((r = sshbuf_load_file(signature, &abuf)) != 0) {\n\t\terror_r(r, \"Couldn't read signature file\");\n\t\tgoto done;\n\t}\n\tif ((r = sshsig_dearmor(abuf, &sigbuf)) != 0) {\n\t\terror_fr(r, \"sshsig_armor\");\n\t\tgoto done;\n\t}\n\tif ((r = sshsig_get_pubkey(sigbuf, &sign_key)) != 0) {\n\t\terror_fr(r, \"sshsig_get_pubkey\");\n\t\tgoto done;\n\t}\n\tif ((r = sshsig_find_principals(allowed_keys, sign_key,\n\t    verify_time, &principals)) != 0) {\n\t\tif (r != SSH_ERR_KEY_NOT_FOUND)\n\t\t\terror_fr(r, \"sshsig_find_principal\");\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tif (ret == 0 ) {\n\t\t \n\t\ttmp = principals;\n\t\twhile ((cp = strsep(&tmp, \",\")) != NULL && *cp != '\\0')\n\t\t\tputs(cp);\n\t} else {\n\t\tfprintf(stderr, \"No principal matched.\\n\");\n\t}\n\tsshbuf_free(sigbuf);\n\tsshbuf_free(abuf);\n\tsshkey_free(sign_key);\n\tfree(principals);\n\treturn ret;\n}\n\nstatic int\nsig_match_principals(const char *allowed_keys, char *principal,\n\tchar * const *opts, size_t nopts)\n{\n\tint r;\n\tchar **principals = NULL;\n\tsize_t i, nprincipals = 0;\n\n\tif ((r = sig_process_opts(opts, nopts, NULL, NULL, NULL)) != 0)\n\t\treturn r;  \n\n\tif ((r = sshsig_match_principals(allowed_keys, principal,\n\t    &principals, &nprincipals)) != 0) {\n\t\tdebug_f(\"match: %s\", ssh_err(r));\n\t\tfprintf(stderr, \"No principal matched.\\n\");\n\t\treturn r;\n\t}\n\tfor (i = 0; i < nprincipals; i++) {\n\t\tprintf(\"%s\\n\", principals[i]);\n\t\tfree(principals[i]);\n\t}\n\tfree(principals);\n\n\treturn 0;\n}\n\nstatic void\ndo_moduli_gen(const char *out_file, char **opts, size_t nopts)\n{\n#ifdef WITH_OPENSSL\n\t \n\tu_int32_t memory = 0;\n\tBIGNUM *start = NULL;\n\tint moduli_bits = 0;\n\tFILE *out;\n\tsize_t i;\n\tconst char *errstr;\n\n\t \n\tfor (i = 0; i < nopts; i++) {\n\t\tif (strncmp(opts[i], \"memory=\", 7) == 0) {\n\t\t\tmemory = (u_int32_t)strtonum(opts[i]+7, 1,\n\t\t\t    UINT_MAX, &errstr);\n\t\t\tif (errstr) {\n\t\t\t\tfatal(\"Memory limit is %s: %s\",\n\t\t\t\t    errstr, opts[i]+7);\n\t\t\t}\n\t\t} else if (strncmp(opts[i], \"start=\", 6) == 0) {\n\t\t\t \n\t\t\tif (BN_hex2bn(&start, opts[i]+6) == 0)\n\t\t\t\tfatal(\"Invalid start point.\");\n\t\t} else if (strncmp(opts[i], \"bits=\", 5) == 0) {\n\t\t\tmoduli_bits = (int)strtonum(opts[i]+5, 1,\n\t\t\t    INT_MAX, &errstr);\n\t\t\tif (errstr) {\n\t\t\t\tfatal(\"Invalid number: %s (%s)\",\n\t\t\t\t\topts[i]+12, errstr);\n\t\t\t}\n\t\t} else {\n\t\t\tfatal(\"Option \\\"%s\\\" is unsupported for moduli \"\n\t\t\t    \"generation\", opts[i]);\n\t\t}\n\t}\n\n\tif ((out = fopen(out_file, \"w\")) == NULL) {\n\t\tfatal(\"Couldn't open modulus candidate file \\\"%s\\\": %s\",\n\t\t    out_file, strerror(errno));\n\t}\n\tsetvbuf(out, NULL, _IOLBF, 0);\n\n\tif (moduli_bits == 0)\n\t\tmoduli_bits = DEFAULT_BITS;\n\tif (gen_candidates(out, memory, moduli_bits, start) != 0)\n\t\tfatal(\"modulus candidate generation failed\");\n#else  \n\tfatal(\"Moduli generation is not supported\");\n#endif  \n}\n\nstatic void\ndo_moduli_screen(const char *out_file, char **opts, size_t nopts)\n{\n#ifdef WITH_OPENSSL\n\t \n\tchar *checkpoint = NULL;\n\tu_int32_t generator_wanted = 0;\n\tunsigned long start_lineno = 0, lines_to_process = 0;\n\tint prime_tests = 0;\n\tFILE *out, *in = stdin;\n\tsize_t i;\n\tconst char *errstr;\n\n\t \n\tfor (i = 0; i < nopts; i++) {\n\t\tif (strncmp(opts[i], \"lines=\", 6) == 0) {\n\t\t\tlines_to_process = strtoul(opts[i]+6, NULL, 10);\n\t\t} else if (strncmp(opts[i], \"start-line=\", 11) == 0) {\n\t\t\tstart_lineno = strtoul(opts[i]+11, NULL, 10);\n\t\t} else if (strncmp(opts[i], \"checkpoint=\", 11) == 0) {\n\t\t\tfree(checkpoint);\n\t\t\tcheckpoint = xstrdup(opts[i]+11);\n\t\t} else if (strncmp(opts[i], \"generator=\", 10) == 0) {\n\t\t\tgenerator_wanted = (u_int32_t)strtonum(\n\t\t\t    opts[i]+10, 1, UINT_MAX, &errstr);\n\t\t\tif (errstr != NULL) {\n\t\t\t\tfatal(\"Generator invalid: %s (%s)\",\n\t\t\t\t    opts[i]+10, errstr);\n\t\t\t}\n\t\t} else if (strncmp(opts[i], \"prime-tests=\", 12) == 0) {\n\t\t\tprime_tests = (int)strtonum(opts[i]+12, 1,\n\t\t\t    INT_MAX, &errstr);\n\t\t\tif (errstr) {\n\t\t\t\tfatal(\"Invalid number: %s (%s)\",\n\t\t\t\t\topts[i]+12, errstr);\n\t\t\t}\n\t\t} else {\n\t\t\tfatal(\"Option \\\"%s\\\" is unsupported for moduli \"\n\t\t\t    \"screening\", opts[i]);\n\t\t}\n\t}\n\n\tif (have_identity && strcmp(identity_file, \"-\") != 0) {\n\t\tif ((in = fopen(identity_file, \"r\")) == NULL) {\n\t\t\tfatal(\"Couldn't open modulus candidate \"\n\t\t\t    \"file \\\"%s\\\": %s\", identity_file,\n\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((out = fopen(out_file, \"a\")) == NULL) {\n\t\tfatal(\"Couldn't open moduli file \\\"%s\\\": %s\",\n\t\t    out_file, strerror(errno));\n\t}\n\tsetvbuf(out, NULL, _IOLBF, 0);\n\tif (prime_test(in, out, prime_tests == 0 ? 100 : prime_tests,\n\t    generator_wanted, checkpoint,\n\t    start_lineno, lines_to_process) != 0)\n\t\tfatal(\"modulus screening failed\");\n\tif (in != stdin)\n\t\t(void)fclose(in);\n\tfree(checkpoint);\n#else  \n\tfatal(\"Moduli screening is not supported\");\n#endif  \n}\n\n \nstatic char *\nread_check_passphrase(const char *prompt1, const char *prompt2,\n    const char *retry_prompt)\n{\n\tchar *passphrase1, *passphrase2;\n\n\tfor (;;) {\n\t\tpassphrase1 = read_passphrase(prompt1, RP_ALLOW_STDIN);\n\t\tpassphrase2 = read_passphrase(prompt2, RP_ALLOW_STDIN);\n\t\tif (strcmp(passphrase1, passphrase2) == 0) {\n\t\t\tfreezero(passphrase2, strlen(passphrase2));\n\t\t\treturn passphrase1;\n\t\t}\n\t\t \n\t\tfreezero(passphrase1, strlen(passphrase1));\n\t\tfreezero(passphrase2, strlen(passphrase2));\n\t\tfputs(retry_prompt, stdout);\n\t\tfputc('\\n', stdout);\n\t\tfflush(stdout);\n\t}\n\t \n\treturn NULL;\n}\n\nstatic char *\nprivate_key_passphrase(void)\n{\n\tif (identity_passphrase)\n\t\treturn xstrdup(identity_passphrase);\n\tif (identity_new_passphrase)\n\t\treturn xstrdup(identity_new_passphrase);\n\n\treturn read_check_passphrase(\n\t    \"Enter passphrase (empty for no passphrase): \",\n\t    \"Enter same passphrase again: \",\n\t    \"Passphrases do not match.  Try again.\");\n}\n\nstatic char *\nsk_suffix(const char *application, const uint8_t *user, size_t userlen)\n{\n\tchar *ret, *cp;\n\tsize_t slen, i;\n\n\t \n\tif (strncmp(application, \"ssh://\", 6) == 0)\n\t\tret =  xstrdup(application + 6);\n\telse if (strncmp(application, \"ssh:\", 4) == 0)\n\t\tret =  xstrdup(application + 4);\n\telse\n\t\tret = xstrdup(application);\n\n\t \n\tfor (i = 0; i < userlen; i++) {\n\t\tif (user[userlen - i - 1] != 0)\n\t\t\tbreak;\n\t}\n\tif (i >= userlen)\n\t\treturn ret;  \n\n\t \n\tslen = userlen - i;\n\tif (asmprintf(&cp, INT_MAX, NULL, \"%.*s\", (int)slen, user) == -1)\n\t\tfatal_f(\"asmprintf failed\");\n\t \n\tif (strchr(cp, '/') != NULL || strstr(cp, \"..\") != NULL ||\n\t    strchr(cp, '\\\\') != NULL) {\n\t\tfree(cp);\n\t\tcp = tohex(user, slen);\n\t}\n\txextendf(&ret, \"_\", \"%s\", cp);\n\tfree(cp);\n\treturn ret;\n}\n\nstatic int\ndo_download_sk(const char *skprovider, const char *device)\n{\n\tstruct sshsk_resident_key **srks;\n\tsize_t nsrks, i;\n\tint r, ret = -1;\n\tchar *fp, *pin = NULL, *pass = NULL, *path, *pubpath;\n\tconst char *ext;\n\tstruct sshkey *key;\n\n\tif (skprovider == NULL)\n\t\tfatal(\"Cannot download keys without provider\");\n\n\tpin = read_passphrase(\"Enter PIN for authenticator: \", RP_ALLOW_STDIN);\n\tif (!quiet) {\n\t\tprintf(\"You may need to touch your authenticator \"\n\t\t    \"to authorize key download.\\n\");\n\t}\n\tif ((r = sshsk_load_resident(skprovider, device, pin, 0,\n\t    &srks, &nsrks)) != 0) {\n\t\tif (pin != NULL)\n\t\t\tfreezero(pin, strlen(pin));\n\t\terror_r(r, \"Unable to load resident keys\");\n\t\treturn -1;\n\t}\n\tif (nsrks == 0)\n\t\tlogit(\"No keys to download\");\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\n\tfor (i = 0; i < nsrks; i++) {\n\t\tkey = srks[i]->key;\n\t\tif (key->type != KEY_ECDSA_SK && key->type != KEY_ED25519_SK) {\n\t\t\terror(\"Unsupported key type %s (%d)\",\n\t\t\t    sshkey_type(key), key->type);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((fp = sshkey_fingerprint(key, fingerprint_hash,\n\t\t    SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\tdebug_f(\"key %zu: %s %s %s (flags 0x%02x)\", i,\n\t\t    sshkey_type(key), fp, key->sk_application, key->sk_flags);\n\t\text = sk_suffix(key->sk_application,\n\t\t    srks[i]->user_id, srks[i]->user_id_len);\n\t\txasprintf(&path, \"id_%s_rk%s%s\",\n\t\t    key->type == KEY_ECDSA_SK ? \"ecdsa_sk\" : \"ed25519_sk\",\n\t\t    *ext == '\\0' ? \"\" : \"_\", ext);\n\n\t\t \n\t\tif (!confirm_overwrite(path)) {\n\t\t\tfree(path);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (pass == NULL)\n\t\t\tpass = private_key_passphrase();\n\t\tif ((r = sshkey_save_private(key, path, pass,\n\t\t    key->sk_application, private_key_format,\n\t\t    openssh_format_cipher, rounds)) != 0) {\n\t\t\terror_r(r, \"Saving key \\\"%s\\\" failed\", path);\n\t\t\tfree(path);\n\t\t\tbreak;\n\t\t}\n\t\tif (!quiet) {\n\t\t\tprintf(\"Saved %s key%s%s to %s\\n\", sshkey_type(key),\n\t\t\t    *ext != '\\0' ? \" \" : \"\",\n\t\t\t    *ext != '\\0' ? key->sk_application : \"\",\n\t\t\t    path);\n\t\t}\n\n\t\t \n\t\txasprintf(&pubpath, \"%s.pub\", path);\n\t\tfree(path);\n\t\tif ((r = sshkey_save_public(key, pubpath,\n\t\t    key->sk_application)) != 0) {\n\t\t\terror_r(r, \"Saving public key \\\"%s\\\" failed\", pubpath);\n\t\t\tfree(pubpath);\n\t\t\tbreak;\n\t\t}\n\t\tfree(pubpath);\n\t}\n\n\tif (i >= nsrks)\n\t\tret = 0;  \n\tif (pass != NULL)\n\t\tfreezero(pass, strlen(pass));\n\tsshsk_free_resident_keys(srks, nsrks);\n\treturn ret;\n}\n\nstatic void\nsave_attestation(struct sshbuf *attest, const char *path)\n{\n\tmode_t omask;\n\tint r;\n\n\tif (path == NULL)\n\t\treturn;  \n\tif (attest == NULL || sshbuf_len(attest) == 0)\n\t\tfatal(\"Enrollment did not return attestation data\");\n\tomask = umask(077);\n\tr = sshbuf_write_file(path, attest);\n\tumask(omask);\n\tif (r != 0)\n\t\tfatal_r(r, \"Unable to write attestation data \\\"%s\\\"\", path);\n\tif (!quiet)\n\t\tprintf(\"Your FIDO attestation certificate has been saved in \"\n\t\t    \"%s\\n\", path);\n}\n\nstatic int\nconfirm_sk_overwrite(const char *application, const char *user)\n{\n\tchar yesno[3];\n\n\tprintf(\"A resident key scoped to '%s' with user id '%s' already \"\n\t    \"exists.\\n\", application == NULL ? \"ssh:\" : application,\n\t    user == NULL ? \"null\" : user);\n\tprintf(\"Overwrite key in token (y/n)? \");\n\tfflush(stdout);\n\tif (fgets(yesno, sizeof(yesno), stdin) == NULL)\n\t\treturn 0;\n\tif (yesno[0] != 'y' && yesno[0] != 'Y')\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-keygen [-q] [-a rounds] [-b bits] [-C comment] [-f output_keyfile]\\n\"\n\t    \"                  [-m format] [-N new_passphrase] [-O option]\\n\"\n\t    \"                  [-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]\\n\"\n\t    \"                  [-w provider] [-Z cipher]\\n\"\n\t    \"       ssh-keygen -p [-a rounds] [-f keyfile] [-m format] [-N new_passphrase]\\n\"\n\t    \"                   [-P old_passphrase] [-Z cipher]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -i [-f input_keyfile] [-m key_format]\\n\"\n\t    \"       ssh-keygen -e [-f input_keyfile] [-m key_format]\\n\"\n#endif\n\t    \"       ssh-keygen -y [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -c [-a rounds] [-C comment] [-f keyfile] [-P passphrase]\\n\"\n\t    \"       ssh-keygen -l [-v] [-E fingerprint_hash] [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -B [-f input_keyfile]\\n\");\n#ifdef ENABLE_PKCS11\n\tfprintf(stderr,\n\t    \"       ssh-keygen -D pkcs11\\n\");\n#endif\n\tfprintf(stderr,\n\t    \"       ssh-keygen -F hostname [-lv] [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -H [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -K [-a rounds] [-w provider]\\n\"\n\t    \"       ssh-keygen -R hostname [-f known_hosts_file]\\n\"\n\t    \"       ssh-keygen -r hostname [-g] [-f input_keyfile]\\n\"\n#ifdef WITH_OPENSSL\n\t    \"       ssh-keygen -M generate [-O option] output_file\\n\"\n\t    \"       ssh-keygen -M screen [-f input_file] [-O option] output_file\\n\"\n#endif\n\t    \"       ssh-keygen -I certificate_identity -s ca_key [-hU] [-D pkcs11_provider]\\n\"\n\t    \"                  [-n principals] [-O option] [-V validity_interval]\\n\"\n\t    \"                  [-z serial_number] file ...\\n\"\n\t    \"       ssh-keygen -L [-f input_keyfile]\\n\"\n\t    \"       ssh-keygen -A [-a rounds] [-f prefix_path]\\n\"\n\t    \"       ssh-keygen -k -f krl_file [-u] [-s ca_public] [-z version_number]\\n\"\n\t    \"                  file ...\\n\"\n\t    \"       ssh-keygen -Q [-l] -f krl_file [file ...]\\n\"\n\t    \"       ssh-keygen -Y find-principals -s signature_file -f allowed_signers_file\\n\"\n\t    \"       ssh-keygen -Y match-principals -I signer_identity -f allowed_signers_file\\n\"\n\t    \"       ssh-keygen -Y check-novalidate -n namespace -s signature_file\\n\"\n\t    \"       ssh-keygen -Y sign -f key_file -n namespace file [-O option] ...\\n\"\n\t    \"       ssh-keygen -Y verify -f allowed_signers_file -I signer_identity\\n\"\n\t    \"                  -n namespace -s signature_file [-r krl_file] [-O option]\\n\");\n\texit(1);\n}\n\n \nint\nmain(int argc, char **argv)\n{\n\tchar comment[1024], *passphrase = NULL;\n\tchar *rr_hostname = NULL, *ep, *fp, *ra;\n\tstruct sshkey *private, *public;\n\tstruct passwd *pw;\n\tint r, opt, type;\n\tint change_passphrase = 0, change_comment = 0, show_cert = 0;\n\tint find_host = 0, delete_host = 0, hash_hosts = 0;\n\tint gen_all_hostkeys = 0, gen_krl = 0, update_krl = 0, check_krl = 0;\n\tint prefer_agent = 0, convert_to = 0, convert_from = 0;\n\tint print_public = 0, print_generic = 0, cert_serial_autoinc = 0;\n\tint do_gen_candidates = 0, do_screen_candidates = 0, download_sk = 0;\n\tunsigned long long cert_serial = 0;\n\tchar *identity_comment = NULL, *ca_key_path = NULL, **opts = NULL;\n\tchar *sk_application = NULL, *sk_device = NULL, *sk_user = NULL;\n\tchar *sk_attestation_path = NULL;\n\tstruct sshbuf *challenge = NULL, *attest = NULL;\n\tsize_t i, nopts = 0;\n\tu_int32_t bits = 0;\n\tuint8_t sk_flags = SSH_SK_USER_PRESENCE_REQD;\n\tconst char *errstr;\n\tint log_level = SYSLOG_LEVEL_INFO;\n\tchar *sign_op = NULL;\n\n\textern int optind;\n\textern char *optarg;\n\n\t \n\tsanitise_stdfd();\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tseed_rng();\n\n\tlog_init(argv[0], SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_USER, 1);\n\n\tmsetlocale();\n\n\t \n\tpw = getpwuid(getuid());\n\tif (!pw)\n\t\tfatal(\"No user exists for uid %lu\", (u_long)getuid());\n\tpw = pwcopy(pw);\n\tif (gethostname(hostname, sizeof(hostname)) == -1)\n\t\tfatal(\"gethostname: %s\", strerror(errno));\n\n\tsk_provider = getenv(\"SSH_SK_PROVIDER\");\n\n\t \n\twhile ((opt = getopt(argc, argv, \"ABHKLQUXceghiklopquvy\"\n\t    \"C:D:E:F:I:M:N:O:P:R:V:Y:Z:\"\n\t    \"a:b:f:g:m:n:r:s:t:w:z:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'A':\n\t\t\tgen_all_hostkeys = 1;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tbits = (u_int32_t)strtonum(optarg, 1, UINT32_MAX,\n\t\t\t    &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Bits has bad value %s (%s)\",\n\t\t\t\t\toptarg, errstr);\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tfind_host = 1;\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\thash_hosts = 1;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tcert_key_id = optarg;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdelete_host = 1;\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tshow_cert = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tprint_fingerprint = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tprint_bubblebabble = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (strcasecmp(optarg, \"RFC4716\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"ssh2\") == 0) {\n\t\t\t\tconvert_format = FMT_RFC4716;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcasecmp(optarg, \"PKCS8\") == 0) {\n\t\t\t\tconvert_format = FMT_PKCS8;\n\t\t\t\tprivate_key_format = SSHKEY_PRIVATE_PKCS8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcasecmp(optarg, \"PEM\") == 0) {\n\t\t\t\tconvert_format = FMT_PEM;\n\t\t\t\tprivate_key_format = SSHKEY_PRIVATE_PEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfatal(\"Unsupported conversion format \\\"%s\\\"\", optarg);\n\t\tcase 'n':\n\t\t\tcert_principals = optarg;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tchange_passphrase = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tchange_comment = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tif (strlcpy(identity_file, optarg,\n\t\t\t    sizeof(identity_file)) >= sizeof(identity_file))\n\t\t\t\tfatal(\"Identity filename too long\");\n\t\t\thave_identity = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tprint_generic = 1;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tdownload_sk = 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tidentity_passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tidentity_new_passphrase = optarg;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tcheck_krl = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\topts = xrecallocarray(opts, nopts, nopts + 1,\n\t\t\t    sizeof(*opts));\n\t\t\topts[nopts++] = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\topenssh_format_cipher = optarg;\n\t\t\tif (cipher_by_name(openssh_format_cipher) == NULL)\n\t\t\t\tfatal(\"Invalid OpenSSH-format cipher '%s'\",\n\t\t\t\t    openssh_format_cipher);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tidentity_comment = optarg;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tquiet = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\t \n\t\t\tconvert_to = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tcert_key_type = SSH2_CERT_TYPE_HOST;\n\t\t\tcertflags_flags = 0;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tgen_krl = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\tcase 'X':\n\t\t\t \n\t\t\tconvert_from = 1;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tprint_public = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tca_key_path = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tkey_type_name = optarg;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tpkcs11provider = optarg;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tprefer_agent = 1;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tupdate_krl = 1;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (log_level == SYSLOG_LEVEL_INFO)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse {\n\t\t\t\tif (log_level >= SYSLOG_LEVEL_DEBUG1 &&\n\t\t\t\t    log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_level++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trr_hostname = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\trounds = (int)strtonum(optarg, 1, INT_MAX, &errstr);\n\t\t\tif (errstr)\n\t\t\t\tfatal(\"Invalid number: %s (%s)\",\n\t\t\t\t\toptarg, errstr);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tparse_cert_times(optarg);\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\tsign_op = optarg;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tsk_provider = optarg;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\terrno = 0;\n\t\t\tif (*optarg == '+') {\n\t\t\t\tcert_serial_autoinc = 1;\n\t\t\t\toptarg++;\n\t\t\t}\n\t\t\tcert_serial = strtoull(optarg, &ep, 10);\n\t\t\tif (*optarg < '0' || *optarg > '9' || *ep != '\\0' ||\n\t\t\t    (errno == ERANGE && cert_serial == ULLONG_MAX))\n\t\t\t\tfatal(\"Invalid serial number \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif (strcmp(optarg, \"generate\") == 0)\n\t\t\t\tdo_gen_candidates = 1;\n\t\t\telse if (strcmp(optarg, \"screen\") == 0)\n\t\t\t\tdo_screen_candidates = 1;\n\t\t\telse\n\t\t\t\tfatal(\"Unsupported moduli option %s\", optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n#ifdef ENABLE_SK_INTERNAL\n\tif (sk_provider == NULL)\n\t\tsk_provider = \"internal\";\n#endif\n\n\t \n\tlog_init(argv[0], log_level, SYSLOG_FACILITY_USER, 1);\n\n\targv += optind;\n\targc -= optind;\n\n\tif (sign_op != NULL) {\n\t\tif (strncmp(sign_op, \"find-principals\", 15) == 0) {\n\t\t\tif (ca_key_path == NULL) {\n\t\t\t\terror(\"Too few arguments for find-principals:\"\n\t\t\t\t    \"missing signature file\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (!have_identity) {\n\t\t\t\terror(\"Too few arguments for find-principals:\"\n\t\t\t\t    \"missing allowed keys file\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn sig_find_principals(ca_key_path, identity_file,\n\t\t\t    opts, nopts);\n\t\t} else if (strncmp(sign_op, \"match-principals\", 16) == 0) {\n\t\t\tif (!have_identity) {\n\t\t\t\terror(\"Too few arguments for match-principals:\"\n\t\t\t\t    \"missing allowed keys file\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cert_key_id == NULL) {\n\t\t\t\terror(\"Too few arguments for match-principals: \"\n\t\t\t\t    \"missing principal ID\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn sig_match_principals(identity_file, cert_key_id,\n\t\t\t    opts, nopts);\n\t\t} else if (strncmp(sign_op, \"sign\", 4) == 0) {\n\t\t\t \n\t\t\tif (cert_principals == NULL ||\n\t\t\t    *cert_principals == '\\0') {\n\t\t\t\terror(\"Too few arguments for sign: \"\n\t\t\t\t    \"missing namespace\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (!have_identity) {\n\t\t\t\terror(\"Too few arguments for sign: \"\n\t\t\t\t    \"missing key\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn sig_sign(identity_file, cert_principals,\n\t\t\t    prefer_agent, argc, argv, opts, nopts);\n\t\t} else if (strncmp(sign_op, \"check-novalidate\", 16) == 0) {\n\t\t\t \n\t\t\tif (cert_principals == NULL ||\n\t\t\t    *cert_principals == '\\0') {\n\t\t\t\terror(\"Too few arguments for check-novalidate: \"\n\t\t\t\t    \"missing namespace\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ca_key_path == NULL) {\n\t\t\t\terror(\"Too few arguments for check-novalidate: \"\n\t\t\t\t    \"missing signature file\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn sig_verify(ca_key_path, cert_principals,\n\t\t\t    NULL, NULL, NULL, opts, nopts);\n\t\t} else if (strncmp(sign_op, \"verify\", 6) == 0) {\n\t\t\t \n\t\t\tif (cert_principals == NULL ||\n\t\t\t    *cert_principals == '\\0') {\n\t\t\t\terror(\"Too few arguments for verify: \"\n\t\t\t\t    \"missing namespace\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ca_key_path == NULL) {\n\t\t\t\terror(\"Too few arguments for verify: \"\n\t\t\t\t    \"missing signature file\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (!have_identity) {\n\t\t\t\terror(\"Too few arguments for sign: \"\n\t\t\t\t    \"missing allowed keys file\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cert_key_id == NULL) {\n\t\t\t\terror(\"Too few arguments for verify: \"\n\t\t\t\t    \"missing principal identity\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\treturn sig_verify(ca_key_path, cert_principals,\n\t\t\t    cert_key_id, identity_file, rr_hostname,\n\t\t\t    opts, nopts);\n\t\t}\n\t\terror(\"Unsupported operation for -Y: \\\"%s\\\"\", sign_op);\n\t\tusage();\n\t\t \n\t}\n\n\tif (ca_key_path != NULL) {\n\t\tif (argc < 1 && !gen_krl) {\n\t\t\terror(\"Too few arguments.\");\n\t\t\tusage();\n\t\t}\n\t} else if (argc > 0 && !gen_krl && !check_krl &&\n\t    !do_gen_candidates && !do_screen_candidates) {\n\t\terror(\"Too many arguments.\");\n\t\tusage();\n\t}\n\tif (change_passphrase && change_comment) {\n\t\terror(\"Can only have one of -p and -c.\");\n\t\tusage();\n\t}\n\tif (print_fingerprint && (delete_host || hash_hosts)) {\n\t\terror(\"Cannot use -l with -H or -R.\");\n\t\tusage();\n\t}\n\tif (gen_krl) {\n\t\tdo_gen_krl(pw, update_krl, ca_key_path,\n\t\t    cert_serial, identity_comment, argc, argv);\n\t\treturn (0);\n\t}\n\tif (check_krl) {\n\t\tdo_check_krl(pw, print_fingerprint, argc, argv);\n\t\treturn (0);\n\t}\n\tif (ca_key_path != NULL) {\n\t\tif (cert_key_id == NULL)\n\t\t\tfatal(\"Must specify key id (-I) when certifying\");\n\t\tfor (i = 0; i < nopts; i++)\n\t\t\tadd_cert_option(opts[i]);\n\t\tdo_ca_sign(pw, ca_key_path, prefer_agent,\n\t\t    cert_serial, cert_serial_autoinc, argc, argv);\n\t}\n\tif (show_cert)\n\t\tdo_show_cert(pw);\n\tif (delete_host || hash_hosts || find_host) {\n\t\tdo_known_hosts(pw, rr_hostname, find_host,\n\t\t    delete_host, hash_hosts);\n\t}\n\tif (pkcs11provider != NULL)\n\t\tdo_download(pw);\n\tif (download_sk) {\n\t\tfor (i = 0; i < nopts; i++) {\n\t\t\tif (strncasecmp(opts[i], \"device=\", 7) == 0) {\n\t\t\t\tsk_device = xstrdup(opts[i] + 7);\n\t\t\t} else {\n\t\t\t\tfatal(\"Option \\\"%s\\\" is unsupported for \"\n\t\t\t\t    \"FIDO authenticator download\", opts[i]);\n\t\t\t}\n\t\t}\n\t\treturn do_download_sk(sk_provider, sk_device);\n\t}\n\tif (print_fingerprint || print_bubblebabble)\n\t\tdo_fingerprint(pw);\n\tif (change_passphrase)\n\t\tdo_change_passphrase(pw);\n\tif (change_comment)\n\t\tdo_change_comment(pw, identity_comment);\n#ifdef WITH_OPENSSL\n\tif (convert_to)\n\t\tdo_convert_to(pw);\n\tif (convert_from)\n\t\tdo_convert_from(pw);\n#else  \n\tif (convert_to || convert_from)\n\t\tfatal(\"key conversion disabled at compile time\");\n#endif  \n\tif (print_public)\n\t\tdo_print_public(pw);\n\tif (rr_hostname != NULL) {\n\t\tunsigned int n = 0;\n\n\t\tif (have_identity) {\n\t\t\tn = do_print_resource_record(pw, identity_file,\n\t\t\t    rr_hostname, print_generic, opts, nopts);\n\t\t\tif (n == 0)\n\t\t\t\tfatal(\"%s: %s\", identity_file, strerror(errno));\n\t\t\texit(0);\n\t\t} else {\n\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_RSA_KEY_FILE, rr_hostname,\n\t\t\t    print_generic, opts, nopts);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_DSA_KEY_FILE, rr_hostname,\n\t\t\t    print_generic, opts, nopts);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_ECDSA_KEY_FILE, rr_hostname,\n\t\t\t    print_generic, opts, nopts);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_ED25519_KEY_FILE, rr_hostname,\n\t\t\t    print_generic, opts, nopts);\n\t\t\tn += do_print_resource_record(pw,\n\t\t\t    _PATH_HOST_XMSS_KEY_FILE, rr_hostname,\n\t\t\t    print_generic, opts, nopts);\n\t\t\tif (n == 0)\n\t\t\t\tfatal(\"no keys found.\");\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif (do_gen_candidates || do_screen_candidates) {\n\t\tif (argc <= 0)\n\t\t\tfatal(\"No output file specified\");\n\t\telse if (argc > 1)\n\t\t\tfatal(\"Too many output files specified\");\n\t}\n\tif (do_gen_candidates) {\n\t\tdo_moduli_gen(argv[0], opts, nopts);\n\t\treturn 0;\n\t}\n\tif (do_screen_candidates) {\n\t\tdo_moduli_screen(argv[0], opts, nopts);\n\t\treturn 0;\n\t}\n\n\tif (gen_all_hostkeys) {\n\t\tdo_gen_all_hostkeys(pw);\n\t\treturn (0);\n\t}\n\n\tif (key_type_name == NULL)\n\t\tkey_type_name = DEFAULT_KEY_TYPE_NAME;\n\n\ttype = sshkey_type_from_name(key_type_name);\n\ttype_bits_valid(type, key_type_name, &bits);\n\n\tif (!quiet)\n\t\tprintf(\"Generating public/private %s key pair.\\n\",\n\t\t    key_type_name);\n\tswitch (type) {\n\tcase KEY_ECDSA_SK:\n\tcase KEY_ED25519_SK:\n\t\tfor (i = 0; i < nopts; i++) {\n\t\t\tif (strcasecmp(opts[i], \"no-touch-required\") == 0) {\n\t\t\t\tsk_flags &= ~SSH_SK_USER_PRESENCE_REQD;\n\t\t\t} else if (strcasecmp(opts[i], \"verify-required\") == 0) {\n\t\t\t\tsk_flags |= SSH_SK_USER_VERIFICATION_REQD;\n\t\t\t} else if (strcasecmp(opts[i], \"resident\") == 0) {\n\t\t\t\tsk_flags |= SSH_SK_RESIDENT_KEY;\n\t\t\t} else if (strncasecmp(opts[i], \"device=\", 7) == 0) {\n\t\t\t\tsk_device = xstrdup(opts[i] + 7);\n\t\t\t} else if (strncasecmp(opts[i], \"user=\", 5) == 0) {\n\t\t\t\tsk_user = xstrdup(opts[i] + 5);\n\t\t\t} else if (strncasecmp(opts[i], \"challenge=\", 10) == 0) {\n\t\t\t\tif ((r = sshbuf_load_file(opts[i] + 10,\n\t\t\t\t    &challenge)) != 0) {\n\t\t\t\t\tfatal_r(r, \"Unable to load FIDO \"\n\t\t\t\t\t    \"enrollment challenge \\\"%s\\\"\",\n\t\t\t\t\t    opts[i] + 10);\n\t\t\t\t}\n\t\t\t} else if (strncasecmp(opts[i],\n\t\t\t    \"write-attestation=\", 18) == 0) {\n\t\t\t\tsk_attestation_path = opts[i] + 18;\n\t\t\t} else if (strncasecmp(opts[i],\n\t\t\t    \"application=\", 12) == 0) {\n\t\t\t\tsk_application = xstrdup(opts[i] + 12);\n\t\t\t\tif (strncmp(sk_application, \"ssh:\", 4) != 0) {\n\t\t\t\t\tfatal(\"FIDO application string must \"\n\t\t\t\t\t    \"begin with \\\"ssh:\\\"\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfatal(\"Option \\\"%s\\\" is unsupported for \"\n\t\t\t\t    \"FIDO authenticator enrollment\", opts[i]);\n\t\t\t}\n\t\t}\n\t\tif ((attest = sshbuf_new()) == NULL)\n\t\t\tfatal(\"sshbuf_new failed\");\n\t\tr = 0;\n\t\tfor (i = 0 ;;) {\n\t\t\tif (!quiet) {\n\t\t\t\tprintf(\"You may need to touch your \"\n\t\t\t\t    \"authenticator%s to authorize key \"\n\t\t\t\t    \"generation.\\n\",\n\t\t\t\t    r == 0 ? \"\" : \" again\");\n\t\t\t}\n\t\t\tfflush(stdout);\n\t\t\tr = sshsk_enroll(type, sk_provider, sk_device,\n\t\t\t    sk_application == NULL ? \"ssh:\" : sk_application,\n\t\t\t    sk_user, sk_flags, passphrase, challenge,\n\t\t\t    &private, attest);\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tif (r == SSH_ERR_KEY_BAD_PERMISSIONS &&\n\t\t\t    (sk_flags & SSH_SK_RESIDENT_KEY) != 0 &&\n\t\t\t    (sk_flags & SSH_SK_FORCE_OPERATION) == 0 &&\n\t\t\t    confirm_sk_overwrite(sk_application, sk_user)) {\n\t\t\t\tsk_flags |= SSH_SK_FORCE_OPERATION;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r != SSH_ERR_KEY_WRONG_PASSPHRASE)\n\t\t\t\tfatal_r(r, \"Key enrollment failed\");\n\t\t\telse if (passphrase != NULL) {\n\t\t\t\terror(\"PIN incorrect\");\n\t\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\t\t\tpassphrase = NULL;\n\t\t\t}\n\t\t\tif (++i >= 3)\n\t\t\t\tfatal(\"Too many incorrect PINs\");\n\t\t\tpassphrase = read_passphrase(\"Enter PIN for \"\n\t\t\t    \"authenticator: \", RP_ALLOW_STDIN);\n\t\t}\n\t\tif (passphrase != NULL) {\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\t\tpassphrase = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((r = sshkey_generate(type, bits, &private)) != 0)\n\t\t\tfatal(\"sshkey_generate failed\");\n\t\tbreak;\n\t}\n\tif ((r = sshkey_from_private(private, &public)) != 0)\n\t\tfatal_r(r, \"sshkey_from_private\");\n\n\tif (!have_identity)\n\t\task_filename(pw, \"Enter file in which to save the key\");\n\n\t \n\thostfile_create_user_ssh_dir(identity_file, !quiet);\n\n\t \n\tif (!confirm_overwrite(identity_file))\n\t\texit(1);\n\n\t \n\tpassphrase = private_key_passphrase();\n\tif (identity_comment) {\n\t\tstrlcpy(comment, identity_comment, sizeof(comment));\n\t} else {\n\t\t \n\t\tsnprintf(comment, sizeof comment, \"%s@%s\", pw->pw_name, hostname);\n\t}\n\n\t \n\tif ((r = sshkey_save_private(private, identity_file, passphrase,\n\t    comment, private_key_format, openssh_format_cipher, rounds)) != 0) {\n\t\terror_r(r, \"Saving key \\\"%s\\\" failed\", identity_file);\n\t\tfreezero(passphrase, strlen(passphrase));\n\t\texit(1);\n\t}\n\tfreezero(passphrase, strlen(passphrase));\n\tsshkey_free(private);\n\n\tif (!quiet) {\n\t\tprintf(\"Your identification has been saved in %s\\n\",\n\t\t    identity_file);\n\t}\n\n\tstrlcat(identity_file, \".pub\", sizeof(identity_file));\n\tif ((r = sshkey_save_public(public, identity_file, comment)) != 0)\n\t\tfatal_r(r, \"Unable to save public key to %s\", identity_file);\n\n\tif (!quiet) {\n\t\tfp = sshkey_fingerprint(public, fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(public, fingerprint_hash,\n\t\t    SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal(\"sshkey_fingerprint failed\");\n\t\tprintf(\"Your public key has been saved in %s\\n\",\n\t\t    identity_file);\n\t\tprintf(\"The key fingerprint is:\\n\");\n\t\tprintf(\"%s %s\\n\", fp, comment);\n\t\tprintf(\"The key's randomart image is:\\n\");\n\t\tprintf(\"%s\\n\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t}\n\n\tif (sk_attestation_path != NULL)\n\t\tsave_attestation(attest, sk_attestation_path);\n\n\tsshbuf_free(attest);\n\tsshkey_free(public);\n\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}