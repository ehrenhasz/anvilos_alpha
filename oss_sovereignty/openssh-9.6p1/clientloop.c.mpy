{
  "module_name": "clientloop.c",
  "hash_id": "77d2135c37d5acb636353f0154ab12b16363b67201982ed5a26f5c19ece4333d",
  "original_prompt": "Ingested from openssh-9.6p1/clientloop.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/socket.h>\n\n#include <ctype.h>\n#include <errno.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <termios.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"compat.h\"\n#include \"channels.h\"\n#include \"dispatch.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"kex.h\"\n#include \"myproposal.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"readconf.h\"\n#include \"clientloop.h\"\n#include \"sshconnect.h\"\n#include \"authfd.h\"\n#include \"atomicio.h\"\n#include \"sshpty.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"ssherr.h\"\n#include \"hostfile.h\"\n\n \n#define HOSTKEY_PROOF_RSA_ALGS\t\"rsa-sha2-512,rsa-sha2-256\"\n\n \n#define SSH_KEYSTROKE_TIMING_FUZZ 10\n\n \nextern Options options;\n\n \nextern int muxserver_sock;  \n\n \nextern char *host;\n\n \nextern char *forward_agent_sock_path;\n\n \nstatic volatile sig_atomic_t received_window_change_signal = 0;\nstatic volatile sig_atomic_t received_signal = 0;\n\n \nstatic time_t control_persist_exit_time = 0;\n\n \nvolatile sig_atomic_t quit_pending;  \nstatic int last_was_cr;\t\t \nstatic int exit_status;\t\t \nstatic struct sshbuf *stderr_buffer;\t \nstatic int connection_in;\t \nstatic int connection_out;\t \nstatic int need_rekeying;\t \nstatic int session_closed;\t \nstatic time_t x11_refuse_time;\t \nstatic time_t server_alive_time;\t \nstatic int hostkeys_update_complete;\nstatic int session_setup_complete;\n\nstatic void client_init_dispatch(struct ssh *ssh);\nint\tsession_ident = -1;\n\n \nstruct escape_filter_ctx {\n\tint escape_pending;\n\tint escape_char;\n};\n\n \nstruct channel_reply_ctx {\n\tconst char *request_type;\n\tint id;\n\tenum confirm_action action;\n};\n\n \n \nstruct global_confirm {\n\tTAILQ_ENTRY(global_confirm) entry;\n\tglobal_confirm_cb *cb;\n\tvoid *ctx;\n\tint ref_count;\n};\nTAILQ_HEAD(global_confirms, global_confirm);\nstatic struct global_confirms global_confirms =\n    TAILQ_HEAD_INITIALIZER(global_confirms);\n\nvoid ssh_process_session2_setup(int, int, int, struct sshbuf *);\nstatic void quit_message(const char *fmt, ...)\n    __attribute__((__format__ (printf, 1, 2)));\n\nstatic void\nquit_message(const char *fmt, ...)\n{\n\tchar *msg;\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\txvasprintf(&msg, fmt, args);\n\tva_end(args);\n\n\tif ((r = sshbuf_putf(stderr_buffer, \"%s\\r\\n\", msg)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putf\");\n\tfree(msg);\n\tquit_pending = 1;\n}\n\n \nstatic void\nwindow_change_handler(int sig)\n{\n\treceived_window_change_signal = 1;\n}\n\n \nstatic void\nsignal_handler(int sig)\n{\n\treceived_signal = sig;\n\tquit_pending = 1;\n}\n\n \nstatic void\nset_control_persist_exit_time(struct ssh *ssh)\n{\n\tif (muxserver_sock == -1 || !options.control_persist\n\t    || options.control_persist_timeout == 0) {\n\t\t \n\t\tcontrol_persist_exit_time = 0;\n\t} else if (channel_still_open(ssh)) {\n\t\t \n\t\tif (control_persist_exit_time > 0)\n\t\t\tdebug2_f(\"cancel scheduled exit\");\n\t\tcontrol_persist_exit_time = 0;\n\t} else if (control_persist_exit_time <= 0) {\n\t\t \n\t\tcontrol_persist_exit_time = monotime() +\n\t\t\t(time_t)options.control_persist_timeout;\n\t\tdebug2_f(\"schedule exit in %d seconds\",\n\t\t    options.control_persist_timeout);\n\t}\n\t \n}\n\n#define SSH_X11_VALID_DISPLAY_CHARS \":/.-_\"\nstatic int\nclient_x11_display_valid(const char *display)\n{\n\tsize_t i, dlen;\n\n\tif (display == NULL)\n\t\treturn 0;\n\n\tdlen = strlen(display);\n\tfor (i = 0; i < dlen; i++) {\n\t\tif (!isalnum((u_char)display[i]) &&\n\t\t    strchr(SSH_X11_VALID_DISPLAY_CHARS, display[i]) == NULL) {\n\t\t\tdebug(\"Invalid character '%c' in DISPLAY\", display[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n#define SSH_X11_PROTO\t\t\"MIT-MAGIC-COOKIE-1\"\n#define X11_TIMEOUT_SLACK\t60\nint\nclient_x11_get_proto(struct ssh *ssh, const char *display,\n    const char *xauth_path, u_int trusted, u_int timeout,\n    char **_proto, char **_data)\n{\n\tchar *cmd, line[512], xdisplay[512];\n\tchar xauthfile[PATH_MAX], xauthdir[PATH_MAX];\n\tstatic char proto[512], data[512];\n\tFILE *f;\n\tint got_data = 0, generated = 0, do_unlink = 0, r;\n\tstruct stat st;\n\tu_int now, x11_timeout_real;\n\n\t*_proto = proto;\n\t*_data = data;\n\tproto[0] = data[0] = xauthfile[0] = xauthdir[0] = '\\0';\n\n\tif (!client_x11_display_valid(display)) {\n\t\tif (display != NULL)\n\t\t\tlogit(\"DISPLAY \\\"%s\\\" invalid; disabling X11 forwarding\",\n\t\t\t    display);\n\t\treturn -1;\n\t}\n\tif (xauth_path != NULL && stat(xauth_path, &st) == -1) {\n\t\tdebug(\"No xauth program.\");\n\t\txauth_path = NULL;\n\t}\n\n\tif (xauth_path != NULL) {\n\t\t \n\t\tif (strncmp(display, \"localhost:\", 10) == 0) {\n\t\t\tif ((r = snprintf(xdisplay, sizeof(xdisplay), \"unix:%s\",\n\t\t\t    display + 10)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xdisplay)) {\n\t\t\t\terror_f(\"display name too long\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdisplay = xdisplay;\n\t\t}\n\t\tif (trusted == 0) {\n\t\t\t \n\t\t\tmktemp_proto(xauthdir, sizeof(xauthdir));\n\t\t\tif (mkdtemp(xauthdir) == NULL) {\n\t\t\t\terror_f(\"mkdtemp: %s\", strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdo_unlink = 1;\n\t\t\tif ((r = snprintf(xauthfile, sizeof(xauthfile),\n\t\t\t    \"%s/xauthfile\", xauthdir)) < 0 ||\n\t\t\t    (size_t)r >= sizeof(xauthfile)) {\n\t\t\t\terror_f(\"xauthfile path too long\");\n\t\t\t\trmdir(xauthdir);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (timeout == 0) {\n\t\t\t\t \n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, _PATH_DEVNULL);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (timeout < UINT_MAX - X11_TIMEOUT_SLACK)\n\t\t\t\t\tx11_timeout_real = timeout +\n\t\t\t\t\t    X11_TIMEOUT_SLACK;\n\t\t\t\telse {\n\t\t\t\t\t \n\t\t\t\t\tx11_timeout_real = UINT_MAX;\n\t\t\t\t}\n\t\t\t\txasprintf(&cmd, \"%s -f %s generate %s %s \"\n\t\t\t\t    \"untrusted timeout %u 2>%s\",\n\t\t\t\t    xauth_path, xauthfile, display,\n\t\t\t\t    SSH_X11_PROTO, x11_timeout_real,\n\t\t\t\t    _PATH_DEVNULL);\n\t\t\t}\n\t\t\tdebug2_f(\"xauth command: %s\", cmd);\n\n\t\t\tif (timeout != 0 && x11_refuse_time == 0) {\n\t\t\t\tnow = monotime() + 1;\n\t\t\t\tif (SSH_TIME_T_MAX - timeout < now)\n\t\t\t\t\tx11_refuse_time = SSH_TIME_T_MAX;\n\t\t\t\telse\n\t\t\t\t\tx11_refuse_time = now + timeout;\n\t\t\t\tchannel_set_x11_refuse_time(ssh,\n\t\t\t\t    x11_refuse_time);\n\t\t\t}\n\t\t\tif (system(cmd) == 0)\n\t\t\t\tgenerated = 1;\n\t\t\tfree(cmd);\n\t\t}\n\n\t\t \n\t\tif (trusted || generated) {\n\t\t\txasprintf(&cmd,\n\t\t\t    \"%s %s%s list %s 2>\" _PATH_DEVNULL,\n\t\t\t    xauth_path,\n\t\t\t    generated ? \"-f \" : \"\" ,\n\t\t\t    generated ? xauthfile : \"\",\n\t\t\t    display);\n\t\t\tdebug2(\"x11_get_proto: %s\", cmd);\n\t\t\tf = popen(cmd, \"r\");\n\t\t\tif (f && fgets(line, sizeof(line), f) &&\n\t\t\t    sscanf(line, \"%*s %511s %511s\", proto, data) == 2)\n\t\t\t\tgot_data = 1;\n\t\t\tif (f)\n\t\t\t\tpclose(f);\n\t\t\tfree(cmd);\n\t\t}\n\t}\n\n\tif (do_unlink) {\n\t\tunlink(xauthfile);\n\t\trmdir(xauthdir);\n\t}\n\n\t \n\tif (!trusted && !got_data) {\n\t\terror(\"Warning: untrusted X11 forwarding setup failed: \"\n\t\t    \"xauth key data not generated\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (!got_data) {\n\t\tu_int8_t rnd[16];\n\t\tu_int i;\n\n\t\tlogit(\"Warning: No xauth data; \"\n\t\t    \"using fake authentication data for X11 forwarding.\");\n\t\tstrlcpy(proto, SSH_X11_PROTO, sizeof proto);\n\t\tarc4random_buf(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < sizeof(rnd); i++) {\n\t\t\tsnprintf(data + 2 * i, sizeof data - 2 * i, \"%02x\",\n\t\t\t    rnd[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void\nclient_check_window_change(struct ssh *ssh)\n{\n\tif (!received_window_change_signal)\n\t\treturn;\n\treceived_window_change_signal = 0;\n\tdebug2_f(\"changed\");\n\tchannel_send_window_changes(ssh);\n}\n\nstatic int\nclient_global_request_reply(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct global_confirm *gc;\n\n\tif ((gc = TAILQ_FIRST(&global_confirms)) == NULL)\n\t\treturn 0;\n\tif (gc->cb != NULL)\n\t\tgc->cb(ssh, type, seq, gc->ctx);\n\tif (--gc->ref_count <= 0) {\n\t\tTAILQ_REMOVE(&global_confirms, gc, entry);\n\t\tfreezero(gc, sizeof(*gc));\n\t}\n\n\tssh_packet_set_alive_timeouts(ssh, 0);\n\treturn 0;\n}\n\nstatic void\nschedule_server_alive_check(void)\n{\n\tif (options.server_alive_interval > 0)\n\t\tserver_alive_time = monotime() + options.server_alive_interval;\n}\n\nstatic void\nserver_alive_check(struct ssh *ssh)\n{\n\tint r;\n\n\tif (ssh_packet_inc_alive_timeouts(ssh) > options.server_alive_count_max) {\n\t\tlogit(\"Timeout, server %s not responding.\", host);\n\t\tcleanup_exit(255);\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"keepalive@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 1)) != 0 ||\t\t \n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\t \n\tclient_register_global_confirm(NULL, NULL);\n\tschedule_server_alive_check();\n}\n\n \nstatic int\nsend_chaff(struct ssh *ssh)\n{\n\tint r;\n\n\tif ((ssh->kex->flags & KEX_HAS_PING) == 0)\n\t\treturn 0;\n\t \n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_PING)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"PING!\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\treturn 1;\n}\n\n \nstatic void\nset_next_interval(const struct timespec *now, struct timespec *next_interval,\n    u_int interval_ms, int starting)\n{\n\tstruct timespec tmp;\n\tlong long interval_ns, fuzz_ns;\n\tstatic long long rate_fuzz;\n\n\tinterval_ns = interval_ms * (1000LL * 1000);\n\tfuzz_ns = (interval_ns * SSH_KEYSTROKE_TIMING_FUZZ) / 100;\n\t \n\tif (fuzz_ns > INT_MAX)\n\t\tfuzz_ns = INT_MAX;\n\tif (fuzz_ns > interval_ns) {\n\t\t \n\t\tfatal_f(\"internal error: fuzz %u%% %lldns > interval %lldns\",\n\t\t    SSH_KEYSTROKE_TIMING_FUZZ, fuzz_ns, interval_ns);\n\t}\n\t \n\tif (starting)\n\t\trate_fuzz = arc4random_uniform(fuzz_ns);\n\tinterval_ns -= fuzz_ns;\n\tinterval_ns += arc4random_uniform(fuzz_ns) + rate_fuzz;\n\n\ttmp.tv_sec = interval_ns / (1000 * 1000 * 1000);\n\ttmp.tv_nsec = interval_ns % (1000 * 1000 * 1000);\n\n\ttimespecadd(now, &tmp, next_interval);\n}\n\n \nstatic int\nobfuscate_keystroke_timing(struct ssh *ssh, struct timespec *timeout,\n    int channel_did_enqueue)\n{\n\tstatic int active;\n\tstatic struct timespec next_interval, chaff_until;\n\tstruct timespec now, tmp;\n\tint just_started = 0, had_keystroke = 0;\n\tstatic unsigned long long nchaff;\n\tchar *stop_reason = NULL;\n\tlong long n;\n\n\tmonotime_ts(&now);\n\n\tif (options.obscure_keystroke_timing_interval <= 0)\n\t\treturn 1;\t \n\n\tif (!channel_tty_open(ssh) || quit_pending) {\n\t\t \n\t\tstop_reason = \"no active channels\";\n\t} else if (ssh_packet_is_rekeying(ssh)) {\n\t\t \n\t\tstop_reason = \"rekeying started\";\n\t} else if (!ssh_packet_interactive_data_to_write(ssh) &&\n\t    ssh_packet_have_data_to_write(ssh)) {\n\t\t \n\t\tstop_reason = \"output buffer filling\";\n\t} else if (active && channel_did_enqueue &&\n\t    ssh_packet_have_data_to_write(ssh)) {\n\t\t \n\t\thad_keystroke = 1;\n\t} else if (active) {\n\t\tif (timespeccmp(&now, &chaff_until, >=)) {\n\t\t\t \n\t\t\tstop_reason = \"chaff time expired\";\n\t\t} else if (timespeccmp(&now, &next_interval, >=)) {\n\t\t\t \n\t\t\tif (send_chaff(ssh))\n\t\t\t\tnchaff++;\n\t\t}\n\t}\n\n\tif (stop_reason != NULL) {\n\t\tif (active) {\n\t\t\tdebug3_f(\"stopping: %s (%llu chaff packets sent)\",\n\t\t\t    stop_reason, nchaff);\n\t\t\tactive = 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tif (!active && ssh_packet_interactive_data_to_write(ssh) &&\n\t    channel_did_enqueue && ssh_packet_have_data_to_write(ssh)) {\n\t\tdebug3_f(\"starting: interval ~%dms\",\n\t\t    options.obscure_keystroke_timing_interval);\n\t\tjust_started = had_keystroke = active = 1;\n\t\tnchaff = 0;\n\t\tset_next_interval(&now, &next_interval,\n\t\t    options.obscure_keystroke_timing_interval, 1);\n\t}\n\n\t \n\tif (!active)\n\t\treturn 1;\n\n\tif (had_keystroke) {\n\t\t \n\t\tms_to_timespec(&tmp, SSH_KEYSTROKE_CHAFF_MIN_MS +\n\t\t    arc4random_uniform(SSH_KEYSTROKE_CHAFF_RNG_MS));\n\t\ttimespecadd(&now, &tmp, &chaff_until);\n\t}\n\n\tptimeout_deadline_monotime_tsp(timeout, &next_interval);\n\n\tif (just_started)\n\t\treturn 1;\n\n\t \n\tif (timespeccmp(&now, &next_interval, <))\n\t\treturn 0;\n\n\t \n\tn = (now.tv_sec - next_interval.tv_sec) * 1000LL * 1000 * 1000;\n\tn += now.tv_nsec - next_interval.tv_nsec;\n\tn /= options.obscure_keystroke_timing_interval * 1000LL * 1000;\n\tn = (n < 0) ? 1 : n + 1;\n\n\t \n\tset_next_interval(&now, &next_interval,\n\t    options.obscure_keystroke_timing_interval * n, 0);\n\treturn 1;\n}\n\n \nstatic void\nclient_wait_until_can_do_something(struct ssh *ssh, struct pollfd **pfdp,\n    u_int *npfd_allocp, u_int *npfd_activep, int channel_did_enqueue,\n    sigset_t *sigsetp, int *conn_in_readyp, int *conn_out_readyp)\n{\n\tstruct timespec timeout;\n\tint ret, oready;\n\tu_int p;\n\n\t*conn_in_readyp = *conn_out_readyp = 0;\n\n\t \n\tptimeout_init(&timeout);\n\tchannel_prepare_poll(ssh, pfdp, npfd_allocp, npfd_activep, 2, &timeout);\n\tif (*npfd_activep < 2)\n\t\tfatal_f(\"bad npfd %u\", *npfd_activep);  \n\n\t \n\tif (session_closed && !channel_still_open(ssh) &&\n\t    !ssh_packet_have_data_to_write(ssh)) {\n\t\t \n\t\tfor (p = 0; p < *npfd_activep; p++)\n\t\t\t(*pfdp)[p].revents = 0;\n\t\treturn;\n\t}\n\n\toready = obfuscate_keystroke_timing(ssh, &timeout, channel_did_enqueue);\n\n\t \n\t(*pfdp)[0].fd = connection_in;\n\t(*pfdp)[0].events = POLLIN;\n\t(*pfdp)[1].fd = connection_out;\n\t(*pfdp)[1].events = (oready && ssh_packet_have_data_to_write(ssh)) ?\n\t    POLLOUT : 0;\n\n\t \n\tset_control_persist_exit_time(ssh);\n\tif (control_persist_exit_time > 0)\n\t\tptimeout_deadline_monotime(&timeout, control_persist_exit_time);\n\tif (options.server_alive_interval > 0)\n\t\tptimeout_deadline_monotime(&timeout, server_alive_time);\n\tif (options.rekey_interval > 0 && !ssh_packet_is_rekeying(ssh)) {\n\t\tptimeout_deadline_sec(&timeout,\n\t\t    ssh_packet_get_rekey_timeout(ssh));\n\t}\n\n\tret = ppoll(*pfdp, *npfd_activep, ptimeout_get_tsp(&timeout), sigsetp);\n\n\tif (ret == -1) {\n\t\t \n\t\tfor (p = 0; p < *npfd_activep; p++)\n\t\t\t(*pfdp)[p].revents = 0;\n\t\tif (errno == EINTR)\n\t\t\treturn;\n\t\t \n\t\tquit_message(\"poll: %s\", strerror(errno));\n\t\treturn;\n\t}\n\n\t*conn_in_readyp = (*pfdp)[0].revents != 0;\n\t*conn_out_readyp = (*pfdp)[1].revents != 0;\n\n\tif (options.server_alive_interval > 0 && !*conn_in_readyp &&\n\t    monotime() >= server_alive_time) {\n\t\t \n\t\tserver_alive_check(ssh);\n\t}\n}\n\nstatic void\nclient_suspend_self(struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr)\n{\n\t \n\tif (sshbuf_len(bout) > 0)\n\t\tatomicio(vwrite, fileno(stdout), sshbuf_mutable_ptr(bout),\n\t\t    sshbuf_len(bout));\n\tif (sshbuf_len(berr) > 0)\n\t\tatomicio(vwrite, fileno(stderr), sshbuf_mutable_ptr(berr),\n\t\t    sshbuf_len(berr));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tsshbuf_reset(bin);\n\tsshbuf_reset(bout);\n\tsshbuf_reset(berr);\n\n\t \n\tkill(getpid(), SIGTSTP);\n\n\t \n\treceived_window_change_signal = 1;\n\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}\n\nstatic void\nclient_process_net_input(struct ssh *ssh)\n{\n\tint r;\n\n\t \n\tschedule_server_alive_check();\n\tif ((r = ssh_packet_process_read(ssh, connection_in)) == 0)\n\t\treturn;  \n\tif (r == SSH_ERR_SYSTEM_ERROR) {\n\t\tif (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK)\n\t\t\treturn;\n\t\tif (errno == EPIPE) {\n\t\t\tquit_message(\"Connection to %s closed by remote host.\",\n\t\t\t    host);\n\t\t\treturn;\n\t\t}\n\t}\n\tquit_message(\"Read from remote host %s: %s\", host, ssh_err(r));\n}\n\nstatic void\nclient_status_confirm(struct ssh *ssh, int type, Channel *c, void *ctx)\n{\n\tstruct channel_reply_ctx *cr = (struct channel_reply_ctx *)ctx;\n\tchar errmsg[256];\n\tint r, tochan;\n\n\t \n\tif (cr->action == CONFIRM_TTY &&\n\t    (options.request_tty == REQUEST_TTY_FORCE ||\n\t    options.request_tty == REQUEST_TTY_YES))\n\t\tcr->action = CONFIRM_CLOSE;\n\n\t \n\ttochan = options.log_level >= SYSLOG_LEVEL_ERROR &&\n\t    c->ctl_chan != -1 && c->extended_usage == CHAN_EXTENDED_WRITE;\n\n\tif (type == SSH2_MSG_CHANNEL_SUCCESS) {\n\t\tdebug2(\"%s request accepted on channel %d\",\n\t\t    cr->request_type, c->self);\n\t} else if (type == SSH2_MSG_CHANNEL_FAILURE) {\n\t\tif (tochan) {\n\t\t\tsnprintf(errmsg, sizeof(errmsg),\n\t\t\t    \"%s request failed\\r\\n\", cr->request_type);\n\t\t} else {\n\t\t\tsnprintf(errmsg, sizeof(errmsg),\n\t\t\t    \"%s request failed on channel %d\",\n\t\t\t    cr->request_type, c->self);\n\t\t}\n\t\t \n\t\tif (cr->action == CONFIRM_CLOSE && c->self == session_ident)\n\t\t\tfatal(\"%s\", errmsg);\n\t\t \n\t\tif (tochan) {\n\t\t\tdebug3_f(\"channel %d: mux request: %s\", c->self,\n\t\t\t    cr->request_type);\n\t\t\tif ((r = sshbuf_put(c->extended, errmsg,\n\t\t\t    strlen(errmsg))) != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_put\");\n\t\t} else\n\t\t\terror(\"%s\", errmsg);\n\t\tif (cr->action == CONFIRM_TTY) {\n\t\t\t \n\t\t\tif (c->self == session_ident)\n\t\t\t\tleave_raw_mode(0);\n\t\t\telse\n\t\t\t\tmux_tty_alloc_failed(ssh, c);\n\t\t} else if (cr->action == CONFIRM_CLOSE) {\n\t\t\tchan_read_failed(ssh, c);\n\t\t\tchan_write_failed(ssh, c);\n\t\t}\n\t}\n\tfree(cr);\n}\n\nstatic void\nclient_abandon_status_confirm(struct ssh *ssh, Channel *c, void *ctx)\n{\n\tfree(ctx);\n}\n\nvoid\nclient_expect_confirm(struct ssh *ssh, int id, const char *request,\n    enum confirm_action action)\n{\n\tstruct channel_reply_ctx *cr = xcalloc(1, sizeof(*cr));\n\n\tcr->request_type = request;\n\tcr->action = action;\n\n\tchannel_register_status_confirm(ssh, id, client_status_confirm,\n\t    client_abandon_status_confirm, cr);\n}\n\nvoid\nclient_register_global_confirm(global_confirm_cb *cb, void *ctx)\n{\n\tstruct global_confirm *gc, *last_gc;\n\n\t \n\tlast_gc = TAILQ_LAST(&global_confirms, global_confirms);\n\tif (last_gc && last_gc->cb == cb && last_gc->ctx == ctx) {\n\t\tif (++last_gc->ref_count >= INT_MAX)\n\t\t\tfatal_f(\"last_gc->ref_count = %d\",\n\t\t\t    last_gc->ref_count);\n\t\treturn;\n\t}\n\n\tgc = xcalloc(1, sizeof(*gc));\n\tgc->cb = cb;\n\tgc->ctx = ctx;\n\tgc->ref_count = 1;\n\tTAILQ_INSERT_TAIL(&global_confirms, gc, entry);\n}\n\n \nstatic int\ncan_update_hostkeys(void)\n{\n\tif (hostkeys_update_complete)\n\t\treturn 0;\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK &&\n\t    options.batch_mode)\n\t\treturn 0;  \n\tif (!options.update_hostkeys || options.num_user_hostfiles <= 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nclient_repledge(void)\n{\n\tdebug3_f(\"enter\");\n\n\t \n\tif (options.control_master || options.control_path != NULL ||\n\t    options.forward_x11 || options.fork_after_authentication ||\n\t    can_update_hostkeys() ||\n\t    (session_ident != -1 && !session_setup_complete)) {\n\t\t \n\t\treturn;\n\t}\n\t \n\tif (options.num_local_forwards != 0 ||\n\t    options.num_remote_forwards != 0 ||\n\t    options.num_permitted_remote_opens != 0 ||\n\t    options.enable_escape_commandline != 0) {\n\t\t \n\t\tdebug(\"pledge: network\");\n\t\tif (pledge(\"stdio unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\t} else if (options.forward_agent != 0) {\n\t\t \n\t\tdebug(\"pledge: agent\");\n\t\tif (pledge(\"stdio unix proc tty\", NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\t} else {\n\t\tdebug(\"pledge: fork\");\n\t\tif (pledge(\"stdio proc tty\", NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\t}\n\t \n}\n\nstatic void\nprocess_cmdline(struct ssh *ssh)\n{\n\tvoid (*handler)(int);\n\tchar *s, *cmd;\n\tint ok, delete = 0, local = 0, remote = 0, dynamic = 0;\n\tstruct Forward fwd;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\thandler = ssh_signal(SIGINT, SIG_IGN);\n\tcmd = s = read_passphrase(\"\\r\\nssh> \", RP_ECHO);\n\tif (s == NULL)\n\t\tgoto out;\n\twhile (isspace((u_char)*s))\n\t\ts++;\n\tif (*s == '-')\n\t\ts++;\t \n\tif (*s == '\\0')\n\t\tgoto out;\n\n\tif (*s == 'h' || *s == 'H' || *s == '?') {\n\t\tlogit(\"Commands:\");\n\t\tlogit(\"      -L[bind_address:]port:host:hostport    \"\n\t\t    \"Request local forward\");\n\t\tlogit(\"      -R[bind_address:]port:host:hostport    \"\n\t\t    \"Request remote forward\");\n\t\tlogit(\"      -D[bind_address:]port                  \"\n\t\t    \"Request dynamic forward\");\n\t\tlogit(\"      -KL[bind_address:]port                 \"\n\t\t    \"Cancel local forward\");\n\t\tlogit(\"      -KR[bind_address:]port                 \"\n\t\t    \"Cancel remote forward\");\n\t\tlogit(\"      -KD[bind_address:]port                 \"\n\t\t    \"Cancel dynamic forward\");\n\t\tif (!options.permit_local_command)\n\t\t\tgoto out;\n\t\tlogit(\"      !args                                  \"\n\t\t    \"Execute local command\");\n\t\tgoto out;\n\t}\n\n\tif (*s == '!' && options.permit_local_command) {\n\t\ts++;\n\t\tssh_local_cmd(s);\n\t\tgoto out;\n\t}\n\n\tif (*s == 'K') {\n\t\tdelete = 1;\n\t\ts++;\n\t}\n\tif (*s == 'L')\n\t\tlocal = 1;\n\telse if (*s == 'R')\n\t\tremote = 1;\n\telse if (*s == 'D')\n\t\tdynamic = 1;\n\telse {\n\t\tlogit(\"Invalid command.\");\n\t\tgoto out;\n\t}\n\n\twhile (isspace((u_char)*++s))\n\t\t;\n\n\t \n\tif (delete) {\n\t\t \n\t\tif (!parse_forward(&fwd, s, 1, 0)) {\n\t\t\tlogit(\"Bad forwarding close specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (remote)\n\t\t\tok = channel_request_rforward_cancel(ssh, &fwd) == 0;\n\t\telse if (dynamic)\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    0, &options.fwd_opts) > 0;\n\t\telse\n\t\t\tok = channel_cancel_lport_listener(ssh, &fwd,\n\t\t\t    CHANNEL_CANCEL_PORT_STATIC,\n\t\t\t    &options.fwd_opts) > 0;\n\t\tif (!ok) {\n\t\t\tlogit(\"Unknown port forwarding.\");\n\t\t\tgoto out;\n\t\t}\n\t\tlogit(\"Canceled forwarding.\");\n\t} else {\n\t\t \n\t\tif (remote) {\n\t\t\tif (!parse_forward(&fwd, s, 0, remote) &&\n\t\t\t    !parse_forward(&fwd, s, 1, remote)) {\n\t\t\t\tlogit(\"Bad remote forwarding specification.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!parse_forward(&fwd, s, dynamic, remote)) {\n\t\t\tlogit(\"Bad local forwarding specification.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (local || dynamic) {\n\t\t\tif (!channel_setup_local_fwd_listener(ssh, &fwd,\n\t\t\t    &options.fwd_opts)) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (channel_request_remote_forwarding(ssh, &fwd) < 0) {\n\t\t\t\tlogit(\"Port forwarding failed.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tlogit(\"Forwarding port.\");\n\t}\n\nout:\n\tssh_signal(SIGINT, handler);\n\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tfree(cmd);\n\tfree(fwd.listen_host);\n\tfree(fwd.listen_path);\n\tfree(fwd.connect_host);\n\tfree(fwd.connect_path);\n}\n\n \n#define SUPPRESS_NEVER\t\t0\t \n#define SUPPRESS_MUXCLIENT\t1\t \n#define SUPPRESS_MUXMASTER\t2\t \n#define SUPPRESS_SYSLOG\t\t4\t \n#define SUPPRESS_NOCMDLINE\t8\t \nstruct escape_help_text {\n\tconst char *cmd;\n\tconst char *text;\n\tunsigned int flags;\n};\nstatic struct escape_help_text esc_txt[] = {\n    {\".\",  \"terminate session\", SUPPRESS_MUXMASTER},\n    {\".\",  \"terminate connection (and any multiplexed sessions)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"B\",  \"send a BREAK to the remote system\", SUPPRESS_NEVER},\n    {\"C\",  \"open a command line\", SUPPRESS_MUXCLIENT|SUPPRESS_NOCMDLINE},\n    {\"R\",  \"request rekey\", SUPPRESS_NEVER},\n    {\"V/v\",  \"decrease/increase verbosity (LogLevel)\", SUPPRESS_MUXCLIENT},\n    {\"^Z\", \"suspend ssh\", SUPPRESS_MUXCLIENT},\n    {\"#\",  \"list forwarded connections\", SUPPRESS_NEVER},\n    {\"&\",  \"background ssh (when waiting for connections to terminate)\",\n\tSUPPRESS_MUXCLIENT},\n    {\"?\", \"this message\", SUPPRESS_NEVER},\n};\n\nstatic void\nprint_escape_help(struct sshbuf *b, int escape_char, int mux_client,\n    int using_stderr)\n{\n\tunsigned int i, suppress_flags;\n\tint r;\n\n\tif ((r = sshbuf_putf(b,\n\t    \"%c?\\r\\nSupported escape sequences:\\r\\n\", escape_char)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putf\");\n\n\tsuppress_flags =\n\t    (mux_client ? SUPPRESS_MUXCLIENT : 0) |\n\t    (mux_client ? 0 : SUPPRESS_MUXMASTER) |\n\t    (using_stderr ? 0 : SUPPRESS_SYSLOG) |\n\t    (options.enable_escape_commandline == 0 ? SUPPRESS_NOCMDLINE : 0);\n\n\tfor (i = 0; i < sizeof(esc_txt)/sizeof(esc_txt[0]); i++) {\n\t\tif (esc_txt[i].flags & suppress_flags)\n\t\t\tcontinue;\n\t\tif ((r = sshbuf_putf(b, \" %c%-3s - %s\\r\\n\",\n\t\t    escape_char, esc_txt[i].cmd, esc_txt[i].text)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t}\n\n\tif ((r = sshbuf_putf(b,\n\t    \" %c%c   - send the escape character by typing it twice\\r\\n\"\n\t    \"(Note that escapes are only recognized immediately after \"\n\t    \"newline.)\\r\\n\", escape_char, escape_char)) != 0)\n\t\tfatal_fr(r, \"sshbuf_putf\");\n}\n\n \nstatic int\nprocess_escapes(struct ssh *ssh, Channel *c,\n    struct sshbuf *bin, struct sshbuf *bout, struct sshbuf *berr,\n    char *buf, int len)\n{\n\tpid_t pid;\n\tint r, bytes = 0;\n\tu_int i;\n\tu_char ch;\n\tchar *s;\n\tstruct escape_filter_ctx *efc;\n\n\tif (c == NULL || c->filter_ctx == NULL || len <= 0)\n\t\treturn 0;\n\n\tefc = (struct escape_filter_ctx *)c->filter_ctx;\n\n\tfor (i = 0; i < (u_int)len; i++) {\n\t\t \n\t\tch = buf[i];\n\n\t\tif (efc->escape_pending) {\n\t\t\t \n\t\t\t \n\t\t\tefc->escape_pending = 0;\n\n\t\t\t \n\t\t\tswitch (ch) {\n\t\t\tcase '.':\n\t\t\t\t \n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c.\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchannel_force_close(ssh, c, 1);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else\n\t\t\t\t\tquit_pending = 1;\n\t\t\t\treturn -1;\n\n\t\t\tcase 'Z' - 64:\n\t\t\t\t \n\t\t\t\tif (c && c->ctl_chan != -1) {\n\t\t\t\t\tchar b[16];\n noescape:\n\t\t\t\t\tif (ch == 'Z' - 64)\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"^Z\");\n\t\t\t\t\telse\n\t\t\t\t\t\tsnprintf(b, sizeof b, \"%c\", ch);\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%s escape not available to \"\n\t\t\t\t\t    \"multiplexed sessions\\r\\n\",\n\t\t\t\t\t    efc->escape_char, b)) != 0)\n\t\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c^Z [suspend ssh]\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\n\t\t\t\t \n\t\t\t\tclient_suspend_self(bin, bout, berr);\n\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\tcase 'B':\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%cB\\r\\n\", efc->escape_char)) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\tchannel_request_start(ssh, c->self, \"break\", 0);\n\t\t\t\tif ((r = sshpkt_put_u32(ssh, 1000)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal_fr(r, \"send packet\");\n\t\t\t\tcontinue;\n\n\t\t\tcase 'R':\n\t\t\t\tif (ssh->compat & SSH_BUG_NOREKEY)\n\t\t\t\t\tlogit(\"Server does not \"\n\t\t\t\t\t    \"support re-keying\");\n\t\t\t\telse\n\t\t\t\t\tneed_rekeying = 1;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'V':\n\t\t\t\t \n\t\t\tcase 'v':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tif (!log_is_on_stderr()) {\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"%c%c [Logging to syslog]\\r\\n\",\n\t\t\t\t\t    efc->escape_char, ch)) != 0)\n\t\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ch == 'V' && options.log_level >\n\t\t\t\t    SYSLOG_LEVEL_QUIET)\n\t\t\t\t\tlog_change_level(--options.log_level);\n\t\t\t\tif (ch == 'v' && options.log_level <\n\t\t\t\t    SYSLOG_LEVEL_DEBUG3)\n\t\t\t\t\tlog_change_level(++options.log_level);\n\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t    \"%c%c [LogLevel %s]\\r\\n\",\n\t\t\t\t    efc->escape_char, ch,\n\t\t\t\t    log_level_name(options.log_level))) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\tcontinue;\n\n\t\t\tcase '&':\n\t\t\t\tif (c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tleave_raw_mode(\n\t\t\t\t    options.request_tty == REQUEST_TTY_FORCE);\n\n\t\t\t\t \n\t\t\t\tchannel_stop_listening(ssh);\n\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c& \"\n\t\t\t\t    \"[backgrounded]\\n\", efc->escape_char)) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\n\t\t\t\t \n\t\t\t\tpid = fork();\n\t\t\t\tif (pid == -1) {\n\t\t\t\t\terror(\"fork: %.100s\", strerror(errno));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (pid != 0) {\t \n\t\t\t\t\t \n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif ((r = sshbuf_put_u8(bin, 4)) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_put_u8\");\n\t\t\t\treturn -1;\n\t\t\tcase '?':\n\t\t\t\tprint_escape_help(berr, efc->escape_char,\n\t\t\t\t    (c && c->ctl_chan != -1),\n\t\t\t\t    log_is_on_stderr());\n\t\t\t\tcontinue;\n\n\t\t\tcase '#':\n\t\t\t\tif ((r = sshbuf_putf(berr, \"%c#\\r\\n\",\n\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\ts = channel_open_message(ssh);\n\t\t\t\tif ((r = sshbuf_put(berr, s, strlen(s))) != 0)\n\t\t\t\t\tfatal_fr(r, \"sshbuf_put\");\n\t\t\t\tfree(s);\n\t\t\t\tcontinue;\n\n\t\t\tcase 'C':\n\t\t\t\tif (c && c->ctl_chan != -1)\n\t\t\t\t\tgoto noescape;\n\t\t\t\tif (options.enable_escape_commandline == 0) {\n\t\t\t\t\tif ((r = sshbuf_putf(berr,\n\t\t\t\t\t    \"commandline disabled\\r\\n\")) != 0)\n\t\t\t\t\t\tfatal_fr(r, \"sshbuf_putf\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprocess_cmdline(ssh);\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tif (ch != efc->escape_char) {\n\t\t\t\t\tif ((r = sshbuf_put_u8(bin,\n\t\t\t\t\t    efc->escape_char)) != 0)\n\t\t\t\t\t\tfatal_fr(r, \"sshbuf_put_u8\");\n\t\t\t\t\tbytes++;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (last_was_cr && ch == efc->escape_char) {\n\t\t\t\t \n\t\t\t\tefc->escape_pending = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlast_was_cr = (ch == '\\r' || ch == '\\n');\n\t\tif ((r = sshbuf_put_u8(bin, ch)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_put_u8\");\n\t\tbytes++;\n\t}\n\treturn bytes;\n}\n\n \n\nstatic void\nclient_process_buffered_input_packets(struct ssh *ssh)\n{\n\tssh_dispatch_run_fatal(ssh, DISPATCH_NONBLOCK, &quit_pending);\n}\n\n \n\n \nvoid *\nclient_new_escape_filter_ctx(int escape_char)\n{\n\tstruct escape_filter_ctx *ret;\n\n\tret = xcalloc(1, sizeof(*ret));\n\tret->escape_pending = 0;\n\tret->escape_char = escape_char;\n\treturn (void *)ret;\n}\n\n \nvoid\nclient_filter_cleanup(struct ssh *ssh, int cid, void *ctx)\n{\n\tfree(ctx);\n}\n\nint\nclient_simple_escape_filter(struct ssh *ssh, Channel *c, char *buf, int len)\n{\n\tif (c->extended_usage != CHAN_EXTENDED_WRITE)\n\t\treturn 0;\n\n\treturn process_escapes(ssh, c, c->input, c->output, c->extended,\n\t    buf, len);\n}\n\nstatic void\nclient_channel_closed(struct ssh *ssh, int id, int force, void *arg)\n{\n\tchannel_cancel_cleanup(ssh, id);\n\tsession_closed = 1;\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n}\n\n \nint\nclient_loop(struct ssh *ssh, int have_pty, int escape_char_arg,\n    int ssh2_chan_id)\n{\n\tstruct pollfd *pfd = NULL;\n\tu_int npfd_alloc = 0, npfd_active = 0;\n\tdouble start_time, total_time;\n\tint channel_did_enqueue = 0, r, len;\n\tu_int64_t ibytes, obytes;\n\tint conn_in_ready, conn_out_ready;\n\tsigset_t bsigset, osigset;\n\n\tdebug(\"Entering interactive session.\");\n\tsession_ident = ssh2_chan_id;\n\n\tif (options.control_master &&\n\t    !option_clear_or_none(options.control_path)) {\n\t\tdebug(\"pledge: id\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns recvfd sendfd proc exec id tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\n\t} else if (options.forward_x11 || options.permit_local_command) {\n\t\tdebug(\"pledge: exec\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc exec tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\n\t} else if (options.update_hostkeys) {\n\t\tdebug(\"pledge: filesystem\");\n\t\tif (pledge(\"stdio rpath wpath cpath unix inet dns proc tty\",\n\t\t    NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\n\t} else if (!option_clear_or_none(options.proxy_command) ||\n\t    options.fork_after_authentication) {\n\t\tdebug(\"pledge: proc\");\n\t\tif (pledge(\"stdio cpath unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\n\t} else {\n\t\tdebug(\"pledge: network\");\n\t\tif (pledge(\"stdio unix inet dns proc tty\", NULL) == -1)\n\t\t\tfatal_f(\"pledge(): %s\", strerror(errno));\n\t}\n\n\t \n\tclient_repledge();\n\n\tstart_time = monotime_double();\n\n\t \n\tlast_was_cr = 1;\n\texit_status = -1;\n\tconnection_in = ssh_packet_get_connection_in(ssh);\n\tconnection_out = ssh_packet_get_connection_out(ssh);\n\n\tquit_pending = 0;\n\n\t \n\tif ((stderr_buffer = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tclient_init_dispatch(ssh);\n\n\t \n\tif (ssh_signal(SIGHUP, SIG_IGN) != SIG_IGN)\n\t\tssh_signal(SIGHUP, signal_handler);\n\tif (ssh_signal(SIGINT, SIG_IGN) != SIG_IGN)\n\t\tssh_signal(SIGINT, signal_handler);\n\tif (ssh_signal(SIGQUIT, SIG_IGN) != SIG_IGN)\n\t\tssh_signal(SIGQUIT, signal_handler);\n\tif (ssh_signal(SIGTERM, SIG_IGN) != SIG_IGN)\n\t\tssh_signal(SIGTERM, signal_handler);\n\tssh_signal(SIGWINCH, window_change_handler);\n\n\tif (have_pty)\n\t\tenter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\tif (session_ident != -1) {\n\t\tif (escape_char_arg != SSH_ESCAPECHAR_NONE) {\n\t\t\tchannel_register_filter(ssh, session_ident,\n\t\t\t    client_simple_escape_filter, NULL,\n\t\t\t    client_filter_cleanup,\n\t\t\t    client_new_escape_filter_ctx(\n\t\t\t    escape_char_arg));\n\t\t}\n\t\tchannel_register_cleanup(ssh, session_ident,\n\t\t    client_channel_closed, 0);\n\t}\n\n\tschedule_server_alive_check();\n\n\tif (sigemptyset(&bsigset) == -1 ||\n\t    sigaddset(&bsigset, SIGHUP) == -1 ||\n\t    sigaddset(&bsigset, SIGINT) == -1 ||\n\t    sigaddset(&bsigset, SIGQUIT) == -1 ||\n\t    sigaddset(&bsigset, SIGTERM) == -1)\n\t\terror_f(\"bsigset setup: %s\", strerror(errno));\n\n\t \n\twhile (!quit_pending) {\n\t\tchannel_did_enqueue = 0;\n\n\t\t \n\t\tclient_process_buffered_input_packets(ssh);\n\n\t\tif (session_closed && !channel_still_open(ssh))\n\t\t\tbreak;\n\n\t\tif (ssh_packet_is_rekeying(ssh)) {\n\t\t\tdebug(\"rekeying in progress\");\n\t\t} else if (need_rekeying) {\n\t\t\t \n\t\t\tdebug(\"need rekeying\");\n\t\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"kex_start_rekex\");\n\t\t\tneed_rekeying = 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (ssh_packet_not_very_much_data_to_write(ssh))\n\t\t\t\tchannel_did_enqueue = channel_output_poll(ssh);\n\n\t\t\t \n\t\t\tclient_check_window_change(ssh);\n\t\t}\n\t\t \n\t\tif (sigprocmask(SIG_BLOCK, &bsigset, &osigset) == -1)\n\t\t\terror_f(\"bsigset sigprocmask: %s\", strerror(errno));\n\t\tif (quit_pending)\n\t\t\tbreak;\n\t\tclient_wait_until_can_do_something(ssh, &pfd, &npfd_alloc,\n\t\t    &npfd_active, channel_did_enqueue, &osigset,\n\t\t    &conn_in_ready, &conn_out_ready);\n\t\tif (sigprocmask(SIG_UNBLOCK, &bsigset, &osigset) == -1)\n\t\t\terror_f(\"osigset sigprocmask: %s\", strerror(errno));\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t \n\t\tchannel_after_poll(ssh, pfd, npfd_active);\n\n\t\t \n\t\tif (conn_in_ready)\n\t\t\tclient_process_net_input(ssh);\n\n\t\tif (quit_pending)\n\t\t\tbreak;\n\n\t\t \n\t\tif ((r = ssh_packet_check_rekey(ssh)) != 0)\n\t\t\tfatal_fr(r, \"cannot start rekeying\");\n\n\t\t \n\t\tif (conn_out_ready) {\n\t\t\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\t\t\tsshpkt_fatal(ssh, r,\n\t\t\t\t    \"%s: ssh_packet_write_poll\", __func__);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (control_persist_exit_time > 0) {\n\t\t\tif (monotime() >= control_persist_exit_time) {\n\t\t\t\tdebug(\"ControlPersist timeout expired\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(pfd);\n\n\t \n\n\t \n\tssh_signal(SIGWINCH, SIG_DFL);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_BY_APPLICATION)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"disconnected by user\")) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t \n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \"send disconnect\");\n\n\tchannel_free_all(ssh);\n\n\tif (have_pty)\n\t\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\n\t \n\tif (options.session_type == SESSION_TYPE_NONE &&\n\t    received_signal == SIGTERM) {\n\t\treceived_signal = 0;\n\t\texit_status = 0;\n\t}\n\n\tif (received_signal) {\n\t\tverbose(\"Killed by signal %d.\", (int) received_signal);\n\t\tcleanup_exit(255);\n\t}\n\n\t \n\tif (have_pty && options.log_level >= SYSLOG_LEVEL_INFO)\n\t\tquit_message(\"Connection to %s closed.\", host);\n\n\t \n\tif (sshbuf_len(stderr_buffer) > 0) {\n\t\tlen = atomicio(vwrite, fileno(stderr),\n\t\t    (u_char *)sshbuf_ptr(stderr_buffer),\n\t\t    sshbuf_len(stderr_buffer));\n\t\tif (len < 0 || (u_int)len != sshbuf_len(stderr_buffer))\n\t\t\terror(\"Write failed flushing stderr buffer.\");\n\t\telse if ((r = sshbuf_consume(stderr_buffer, len)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_consume\");\n\t}\n\n\t \n\tsshbuf_free(stderr_buffer);\n\n\t \n\ttotal_time = monotime_double() - start_time;\n\tssh_packet_get_bytes(ssh, &ibytes, &obytes);\n\tverbose(\"Transferred: sent %llu, received %llu bytes, in %.1f seconds\",\n\t    (unsigned long long)obytes, (unsigned long long)ibytes, total_time);\n\tif (total_time > 0)\n\t\tverbose(\"Bytes per second: sent %.1f, received %.1f\",\n\t\t    obytes / total_time, ibytes / total_time);\n\t \n\tdebug(\"Exit status %d\", exit_status);\n\treturn exit_status;\n}\n\n \n\nstatic Channel *\nclient_request_forwarded_tcpip(struct ssh *ssh, const char *request_type,\n    int rchan, u_int rwindow, u_int rmaxpack)\n{\n\tChannel *c = NULL;\n\tstruct sshbuf *b = NULL;\n\tchar *listen_address, *originator_address;\n\tu_int listen_port, originator_port;\n\tint r;\n\n\t \n\tif ((r = sshpkt_get_cstring(ssh, &listen_address, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &listen_port)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &originator_address, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &originator_port)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal_fr(r, \"parse packet\");\n\n\tdebug_f(\"listen %s port %d, originator %s port %d\",\n\t    listen_address, listen_port, originator_address, originator_port);\n\n\tif (listen_port > 0xffff)\n\t\terror_f(\"invalid listen port\");\n\telse if (originator_port > 0xffff)\n\t\terror_f(\"invalid originator port\");\n\telse {\n\t\tc = channel_connect_by_listen_address(ssh,\n\t\t    listen_address, listen_port, \"forwarded-tcpip\",\n\t\t    originator_address);\n\t}\n\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tif ((b = sshbuf_new()) == NULL) {\n\t\t\terror_f(\"alloc reply\");\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif ((r = sshbuf_put_u8(b, 0)) != 0 ||\t \n\t\t    (r = sshbuf_put_u8(b, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, request_type)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rchan)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rwindow)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, rmaxpack)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, listen_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, listen_port)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, originator_address)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, originator_port)) != 0 ||\n\t\t    (r = sshbuf_put_stringb(c->output, b)) != 0) {\n\t\t\terror_fr(r, \"compose for muxclient\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tsshbuf_free(b);\n\tfree(originator_address);\n\tfree(listen_address);\n\treturn c;\n}\n\nstatic Channel *\nclient_request_forwarded_streamlocal(struct ssh *ssh,\n    const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *listen_path;\n\tint r;\n\n\t \n\tif ((r = sshpkt_get_cstring(ssh, &listen_path, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0 ||\t \n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal_fr(r, \"parse packet\");\n\n\tdebug_f(\"request: %s\", listen_path);\n\n\tc = channel_connect_by_listen_path(ssh, listen_path,\n\t    \"forwarded-streamlocal@openssh.com\", \"forwarded-streamlocal\");\n\tfree(listen_path);\n\treturn c;\n}\n\nstatic Channel *\nclient_request_x11(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tchar *originator;\n\tu_int originator_port;\n\tint r, sock;\n\n\tif (!options.forward_x11) {\n\t\terror(\"Warning: ssh server tried X11 forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif (x11_refuse_time != 0 && monotime() >= x11_refuse_time) {\n\t\tverbose(\"Rejected X11 connection after ForwardX11Timeout \"\n\t\t    \"expired\");\n\t\treturn NULL;\n\t}\n\tif ((r = sshpkt_get_cstring(ssh, &originator, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &originator_port)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal_fr(r, \"parse packet\");\n\t \n\t \n\tdebug(\"client_request_x11: request from %s %u\", originator,\n\t    originator_port);\n\tfree(originator);\n\tsock = x11_connect_display(ssh);\n\tif (sock < 0)\n\t\treturn NULL;\n\tc = channel_new(ssh, \"x11-connection\",\n\t    SSH_CHANNEL_X11_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT, 0, \"x11\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}\n\nstatic Channel *\nclient_request_agent(struct ssh *ssh, const char *request_type, int rchan)\n{\n\tChannel *c = NULL;\n\tint r, sock;\n\n\tif (!options.forward_agent) {\n\t\terror(\"Warning: ssh server tried agent forwarding.\");\n\t\terror(\"Warning: this is probably a break-in attempt by a \"\n\t\t    \"malicious server.\");\n\t\treturn NULL;\n\t}\n\tif (forward_agent_sock_path == NULL) {\n\t\tr = ssh_get_authentication_socket(&sock);\n\t} else {\n\t\tr = ssh_get_authentication_socket_path(forward_agent_sock_path, &sock);\n\t}\n\tif (r != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug_fr(r, \"ssh_get_authentication_socket\");\n\t\treturn NULL;\n\t}\n\tif ((r = ssh_agent_bind_hostkey(sock, ssh->kex->initial_hostkey,\n\t    ssh->kex->session_id, ssh->kex->initial_sig, 1)) == 0)\n\t\tdebug_f(\"bound agent to hostkey\");\n\telse\n\t\tdebug2_fr(r, \"ssh_agent_bind_hostkey\");\n\n\tc = channel_new(ssh, \"agent-connection\",\n\t    SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0,\n\t    \"authentication agent connection\", 1);\n\tc->force_drain = 1;\n\treturn c;\n}\n\nchar *\nclient_request_tun_fwd(struct ssh *ssh, int tun_mode,\n    int local_tun, int remote_tun, channel_open_fn *cb, void *cbctx)\n{\n\tChannel *c;\n\tint r, fd;\n\tchar *ifname = NULL;\n\n\tif (tun_mode == SSH_TUNMODE_NO)\n\t\treturn 0;\n\n\tdebug(\"Requesting tun unit %d in mode %d\", local_tun, tun_mode);\n\n\t \n\tif ((fd = tun_open(local_tun, tun_mode, &ifname)) == -1) {\n\t\terror(\"Tunnel device open failed.\");\n\t\treturn NULL;\n\t}\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun-connection\", SSH_CHANNEL_OPENING, fd, fd, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n#if defined(SSH_TUN_FILTER)\n\tif (options.tun_open == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\tif (cb != NULL)\n\t\tchannel_register_open_confirm(ssh, c->self, cb, cbctx);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"tun@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_window_max)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, tun_mode)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, remote_tun)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: send reply\", __func__);\n\n\treturn ifname;\n}\n\n \nstatic int\nclient_input_channel_open(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *ctype = NULL;\n\tint r;\n\tu_int rchan;\n\tsize_t len;\n\tu_int rmaxpack, rwindow;\n\n\tif ((r = sshpkt_get_cstring(ssh, &ctype, &len)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &rchan)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &rwindow)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &rmaxpack)) != 0)\n\t\tgoto out;\n\n\tdebug(\"client_input_channel_open: ctype %s rchan %d win %d max %d\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"forwarded-tcpip\") == 0) {\n\t\tc = client_request_forwarded_tcpip(ssh, ctype, rchan, rwindow,\n\t\t    rmaxpack);\n\t} else if (strcmp(ctype, \"forwarded-streamlocal@openssh.com\") == 0) {\n\t\tc = client_request_forwarded_streamlocal(ssh, ctype, rchan);\n\t} else if (strcmp(ctype, \"x11\") == 0) {\n\t\tc = client_request_x11(ssh, ctype, rchan);\n\t} else if (strcmp(ctype, \"auth-agent@openssh.com\") == 0) {\n\t\tc = client_request_agent(ssh, ctype, rchan);\n\t}\n\tif (c != NULL && c->type == SSH_CHANNEL_MUX_CLIENT) {\n\t\tdebug3(\"proxied to downstream: %s\", ctype);\n\t} else if (c != NULL) {\n\t\tdebug(\"confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->have_remote_id = 1;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tsshpkt_fatal(ssh, r, \"%s: send reply\", __func__);\n\t\t}\n\t} else {\n\t\tdebug(\"failure %s\", ctype);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, rchan)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"open failed\")) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: send failure\", __func__);\n\t}\n\tr = 0;\n out:\n\tfree(ctype);\n\treturn r;\n}\n\nstatic int\nclient_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *rtype = NULL;\n\tu_char reply;\n\tu_int id, exitval;\n\tint r, success = 0;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0)\n\t\treturn r;\n\tif (id <= INT_MAX)\n\t\tc = channel_lookup(ssh, id);\n\tif (channel_proxy_upstream(c, type, seq, ssh))\n\t\treturn 0;\n\tif ((r = sshpkt_get_cstring(ssh, &rtype, NULL)) != 0 ||\n\t    (r = sshpkt_get_u8(ssh, &reply)) != 0)\n\t\tgoto out;\n\n\tdebug(\"client_input_channel_req: channel %u rtype %s reply %d\",\n\t    id, rtype, reply);\n\n\tif (c == NULL) {\n\t\terror(\"client_input_channel_req: channel %d: \"\n\t\t    \"unknown channel\", id);\n\t} else if (strcmp(rtype, \"eow@openssh.com\") == 0) {\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tgoto out;\n\t\tchan_rcvd_eow(ssh, c);\n\t} else if (strcmp(rtype, \"exit-status\") == 0) {\n\t\tif ((r = sshpkt_get_u32(ssh, &exitval)) != 0)\n\t\t\tgoto out;\n\t\tif (c->ctl_chan != -1) {\n\t\t\tmux_exit_message(ssh, c, exitval);\n\t\t\tsuccess = 1;\n\t\t} else if ((int)id == session_ident) {\n\t\t\t \n\t\t\tsuccess = 1;\n\t\t\texit_status = exitval;\n\t\t} else {\n\t\t\t \n\t\t\tdebug_f(\"no sink for exit-status on channel %d\",\n\t\t\t    id);\n\t\t}\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (reply && c != NULL && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal_f(\"channel %d: no remote_id\", c->self);\n\t\tif ((r = sshpkt_start(ssh, success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: send failure\", __func__);\n\t}\n\tr = 0;\n out:\n\tfree(rtype);\n\treturn r;\n}\n\nstruct hostkeys_update_ctx {\n\t \n\tchar *host_str, *ip_str;\n\n\t \n\tstruct sshkey **keys;\n\tu_int *keys_match;\t \n\tint *keys_verified;\t \n\tsize_t nkeys, nnew, nincomplete;  \n\n\t \n\tstruct sshkey **old_keys;\n\tsize_t nold;\n\n\t \n\tint complex_hostspec;\t \n\tint ca_available;\t \n\tint old_key_seen;\t \n\tint other_name_seen;\t \n};\n\nstatic void\nhostkeys_update_ctx_free(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\n\tif (ctx == NULL)\n\t\treturn;\n\tfor (i = 0; i < ctx->nkeys; i++)\n\t\tsshkey_free(ctx->keys[i]);\n\tfree(ctx->keys);\n\tfree(ctx->keys_match);\n\tfree(ctx->keys_verified);\n\tfor (i = 0; i < ctx->nold; i++)\n\t\tsshkey_free(ctx->old_keys[i]);\n\tfree(ctx->old_keys);\n\tfree(ctx->host_str);\n\tfree(ctx->ip_str);\n\tfree(ctx);\n}\n\n \nstatic int\nhostspec_is_complex(const char *hosts)\n{\n\tchar *cp;\n\n\t \n\tif (strchr(hosts, '*') != NULL || strchr(hosts, '?') != NULL)\n\t\treturn 1;\n\t \n\tif ((cp = strchr(hosts, ',')) == NULL)\n\t\treturn 0;\n\t \n\tif (strchr(cp + 1, ',') != NULL)\n\t\treturn 1;\n\t \n\treturn 0;\n}\n\n \nstatic int\nhostkeys_find(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i;\n\tstruct sshkey **tmp;\n\n\tif (l->key == NULL)\n\t\treturn 0;\n\tif (l->status != HKF_STATUS_MATCHED) {\n\t\t \n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (sshkey_equal(l->key, ctx->keys[i])) {\n\t\t\t\tctx->other_name_seen = 1;\n\t\t\t\tdebug3_f(\"found %s key under different \"\n\t\t\t\t    \"name/addr at %s:%ld\",\n\t\t\t\t    sshkey_ssh_name(ctx->keys[i]),\n\t\t\t\t    l->path, l->linenum);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t \n\t \n\tif (l->marker != MRK_NONE) {\n\t\tdebug3_f(\"hostkeys file %s:%ld has CA/revocation marker\",\n\t\t    l->path, l->linenum);\n\t\tctx->complex_hostspec = 1;\n\t\treturn 0;\n\t}\n\n\t \n\tif (ctx->ip_str != NULL && strchr(l->hosts, ',') != NULL) {\n\t\tif ((l->match & HKF_MATCH_HOST) == 0) {\n\t\t\t \n\t\t\tctx->other_name_seen = 1;\n\t\t\tdebug3_f(\"found address %s against different hostname \"\n\t\t\t    \"at %s:%ld\", ctx->ip_str, l->path, l->linenum);\n\t\t\treturn 0;\n\t\t} else if ((l->match & HKF_MATCH_IP) == 0) {\n\t\t\t \n\t\t\tctx->other_name_seen = 1;\n\t\t\tdebug3_f(\"found hostname %s against different address \"\n\t\t\t    \"at %s:%ld\", ctx->host_str, l->path, l->linenum);\n\t\t}\n\t}\n\n\t \n\tif (hostspec_is_complex(l->hosts)) {\n\t\tdebug3_f(\"hostkeys file %s:%ld complex host specification\",\n\t\t    l->path, l->linenum);\n\t\tctx->complex_hostspec = 1;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (!sshkey_equal(l->key, ctx->keys[i]))\n\t\t\tcontinue;\n\t\tdebug3_f(\"found %s key at %s:%ld\",\n\t\t    sshkey_ssh_name(ctx->keys[i]), l->path, l->linenum);\n\t\tctx->keys_match[i] |= l->match;\n\t\treturn 0;\n\t}\n\t \n\tdebug3_f(\"deprecated %s key at %s:%ld\", sshkey_ssh_name(l->key),\n\t    l->path, l->linenum);\n\tif ((tmp = recallocarray(ctx->old_keys, ctx->nold, ctx->nold + 1,\n\t    sizeof(*ctx->old_keys))) == NULL)\n\t\tfatal_f(\"recallocarray failed nold = %zu\", ctx->nold);\n\tctx->old_keys = tmp;\n\tctx->old_keys[ctx->nold++] = l->key;\n\tl->key = NULL;\n\n\treturn 0;\n}\n\n \nstatic int\nhostkeys_check_old(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i;\n\tint hashed;\n\n\t \n\tif (l->status == HKF_STATUS_MATCHED || l->key == NULL)\n\t\treturn 0;\n\n\thashed = l->match & (HKF_MATCH_HOST_HASHED|HKF_MATCH_IP_HASHED);\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif (!sshkey_equal(l->key, ctx->old_keys[i]))\n\t\t\tcontinue;\n\t\tdebug3_f(\"found deprecated %s key at %s:%ld as %s\",\n\t\t    sshkey_ssh_name(ctx->old_keys[i]), l->path, l->linenum,\n\t\t    hashed ? \"[HASHED]\" : l->hosts);\n\t\tctx->old_key_seen = 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ncheck_old_keys_othernames(struct hostkeys_update_ctx *ctx)\n{\n\tsize_t i;\n\tint r;\n\n\tdebug2_f(\"checking for %zu deprecated keys\", ctx->nold);\n\tfor (i = 0; i < options.num_user_hostfiles; i++) {\n\t\tdebug3_f(\"searching %s for %s / %s\",\n\t\t    options.user_hostfiles[i], ctx->host_str,\n\t\t    ctx->ip_str ? ctx->ip_str : \"(none)\");\n\t\tif ((r = hostkeys_foreach(options.user_hostfiles[i],\n\t\t    hostkeys_check_old, ctx, ctx->host_str, ctx->ip_str,\n\t\t    HKF_WANT_PARSE_KEY, 0)) != 0) {\n\t\t\tif (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT) {\n\t\t\t\tdebug_f(\"hostkeys file %s does not exist\",\n\t\t\t\t    options.user_hostfiles[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror_fr(r, \"hostkeys_foreach failed for %s\",\n\t\t\t    options.user_hostfiles[i]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\nhostkey_change_preamble(LogLevel loglevel)\n{\n\tdo_log2(loglevel, \"The server has updated its host keys.\");\n\tdo_log2(loglevel, \"These changes were verified by the server's \"\n\t    \"existing trusted key.\");\n}\n\nstatic void\nupdate_known_hosts(struct hostkeys_update_ctx *ctx)\n{\n\tint r, was_raw = 0, first = 1;\n\tint asking = options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK;\n\tLogLevel loglevel = asking ?  SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_VERBOSE;\n\tchar *fp, *response;\n\tsize_t i;\n\tstruct stat sb;\n\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (!ctx->keys_verified[i])\n\t\t\tcontinue;\n\t\tif ((fp = sshkey_fingerprint(ctx->keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\tif (first && asking)\n\t\t\thostkey_change_preamble(loglevel);\n\t\tdo_log2(loglevel, \"Learned new hostkey: %s %s\",\n\t\t    sshkey_type(ctx->keys[i]), fp);\n\t\tfirst = 0;\n\t\tfree(fp);\n\t}\n\tfor (i = 0; i < ctx->nold; i++) {\n\t\tif ((fp = sshkey_fingerprint(ctx->old_keys[i],\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\tif (first && asking)\n\t\t\thostkey_change_preamble(loglevel);\n\t\tdo_log2(loglevel, \"Deprecating obsolete hostkey: %s %s\",\n\t\t    sshkey_type(ctx->old_keys[i]), fp);\n\t\tfirst = 0;\n\t\tfree(fp);\n\t}\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (get_saved_tio() != NULL) {\n\t\t\tleave_raw_mode(1);\n\t\t\twas_raw = 1;\n\t\t}\n\t\tresponse = NULL;\n\t\tfor (i = 0; !quit_pending && i < 3; i++) {\n\t\t\tfree(response);\n\t\t\tresponse = read_passphrase(\"Accept updated hostkeys? \"\n\t\t\t    \"(yes/no): \", RP_ECHO);\n\t\t\tif (response != NULL && strcasecmp(response, \"yes\") == 0)\n\t\t\t\tbreak;\n\t\t\telse if (quit_pending || response == NULL ||\n\t\t\t    strcasecmp(response, \"no\") == 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdo_log2(loglevel, \"Please enter \"\n\t\t\t\t    \"\\\"yes\\\" or \\\"no\\\"\");\n\t\t\t}\n\t\t}\n\t\tif (quit_pending || i >= 3 || response == NULL)\n\t\t\toptions.update_hostkeys = 0;\n\t\tfree(response);\n\t\tif (was_raw)\n\t\t\tenter_raw_mode(1);\n\t}\n\tif (options.update_hostkeys == 0)\n\t\treturn;\n\t \n\tfor (i = 0; i < options.num_user_hostfiles; i++) {\n\t\t \n\t\tif (stat(options.user_hostfiles[i], &sb) != 0) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug_f(\"known hosts file %s does not \"\n\t\t\t\t    \"exist\", options.user_hostfiles[i]);\n\t\t\t} else {\n\t\t\t\terror_f(\"known hosts file %s \"\n\t\t\t\t    \"inaccessible: %s\",\n\t\t\t\t    options.user_hostfiles[i], strerror(errno));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ((r = hostfile_replace_entries(options.user_hostfiles[i],\n\t\t    ctx->host_str, ctx->ip_str,\n\t\t    i == 0 ? ctx->keys : NULL, i == 0 ? ctx->nkeys : 0,\n\t\t    options.hash_known_hosts, 0,\n\t\t    options.fingerprint_hash)) != 0) {\n\t\t\terror_fr(r, \"hostfile_replace_entries failed for %s\",\n\t\t\t    options.user_hostfiles[i]);\n\t\t}\n\t}\n}\n\nstatic void\nclient_global_hostkeys_prove_confirm(struct ssh *ssh, int type,\n    u_int32_t seq, void *_ctx)\n{\n\tstruct hostkeys_update_ctx *ctx = (struct hostkeys_update_ctx *)_ctx;\n\tsize_t i, ndone;\n\tstruct sshbuf *signdata;\n\tint r, plaintype;\n\tconst u_char *sig;\n\tconst char *rsa_kexalg = NULL;\n\tchar *alg = NULL;\n\tsize_t siglen;\n\n\tif (ctx->nnew == 0)\n\t\tfatal_f(\"ctx->nnew == 0\");  \n\tif (type != SSH2_MSG_REQUEST_SUCCESS) {\n\t\terror(\"Server failed to confirm ownership of \"\n\t\t    \"private host keys\");\n\t\thostkeys_update_ctx_free(ctx);\n\t\treturn;\n\t}\n\tif (sshkey_type_plain(sshkey_type_from_name(\n\t    ssh->kex->hostkey_alg)) == KEY_RSA)\n\t\trsa_kexalg = ssh->kex->hostkey_alg;\n\tif ((signdata = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\t \n\tfor (ndone = i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_match[i])\n\t\t\tcontinue;\n\t\tplaintype = sshkey_type_plain(ctx->keys[i]->type);\n\t\t \n\t\tsshbuf_reset(signdata);\n\t\tif ( (r = sshbuf_put_cstring(signdata,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_stringb(signdata,\n\t\t    ssh->kex->session_id)) != 0 ||\n\t\t    (r = sshkey_puts(ctx->keys[i], signdata)) != 0)\n\t\t\tfatal_fr(r, \"compose signdata\");\n\t\t \n\t\tif ((r = sshpkt_get_string_direct(ssh, &sig, &siglen)) != 0) {\n\t\t\terror_fr(r, \"parse sig\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_get_sigtype(sig, siglen, &alg)) != 0) {\n\t\t\terror_fr(r, \"server gave unintelligible signature \"\n\t\t\t    \"for %s key %zu\", sshkey_type(ctx->keys[i]), i);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (plaintype == KEY_RSA && rsa_kexalg == NULL &&\n\t\t    match_pattern_list(alg, HOSTKEY_PROOF_RSA_ALGS, 0) != 1) {\n\t\t\tdebug_f(\"server used untrusted RSA signature algorithm \"\n\t\t\t    \"%s for key %zu, disregarding\", alg, i);\n\t\t\tfree(alg);\n\t\t\t \n\t\t\tsshkey_free(ctx->keys[i]);\n\t\t\tctx->keys[i] = NULL;\n\t\t\tndone++;\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3_f(\"verify %s key %zu using sigalg %s\",\n\t\t    sshkey_type(ctx->keys[i]), i, alg);\n\t\tfree(alg);\n\t\tif ((r = sshkey_verify(ctx->keys[i], sig, siglen,\n\t\t    sshbuf_ptr(signdata), sshbuf_len(signdata),\n\t\t    plaintype == KEY_RSA ? rsa_kexalg : NULL, 0, NULL)) != 0) {\n\t\t\terror_fr(r, \"server gave bad signature for %s key %zu\",\n\t\t\t    sshkey_type(ctx->keys[i]), i);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tctx->keys_verified[i] = 1;\n\t\tndone++;\n\t}\n\t \n\tif (ndone != ctx->nnew)\n\t\tfatal_f(\"ndone != ctx->nnew (%zu / %zu)\", ndone, ctx->nnew);\n\tif ((r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_f(\"protocol error\");\n\t\tgoto out;\n\t}\n\n\t \n\tupdate_known_hosts(ctx);\n out:\n\thostkeys_update_ctx_free(ctx);\n\thostkeys_update_complete = 1;\n\tclient_repledge();\n}\n\n \nstatic int\nkey_accepted_by_hostkeyalgs(const struct sshkey *key)\n{\n\tconst char *ktype = sshkey_ssh_name(key);\n\tconst char *hostkeyalgs = options.hostkeyalgorithms;\n\n\tif (key->type == KEY_UNSPEC)\n\t\treturn 0;\n\tif (key->type == KEY_RSA &&\n\t    (match_pattern_list(\"rsa-sha2-256\", hostkeyalgs, 0) == 1 ||\n\t    match_pattern_list(\"rsa-sha2-512\", hostkeyalgs, 0) == 1))\n\t\treturn 1;\n\treturn match_pattern_list(ktype, hostkeyalgs, 0) == 1;\n}\n\n \nstatic int\nclient_input_hostkeys(struct ssh *ssh)\n{\n\tconst u_char *blob = NULL;\n\tsize_t i, len = 0;\n\tstruct sshbuf *buf = NULL;\n\tstruct sshkey *key = NULL, **tmp;\n\tint r, prove_sent = 0;\n\tchar *fp;\n\tstatic int hostkeys_seen = 0;  \n\textern struct sockaddr_storage hostaddr;  \n\tstruct hostkeys_update_ctx *ctx = NULL;\n\tu_int want;\n\n\tif (hostkeys_seen)\n\t\tfatal_f(\"server already sent hostkeys\");\n\tif (!can_update_hostkeys())\n\t\treturn 1;\n\thostkeys_seen = 1;\n\n\tctx = xcalloc(1, sizeof(*ctx));\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &len)) != 0) {\n\t\t\terror_fr(r, \"parse key\");\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshkey_from_blob(blob, len, &key)) != 0) {\n\t\t\tdo_log2_fr(r, r == SSH_ERR_KEY_TYPE_UNKNOWN ?\n\t\t\t    SYSLOG_LEVEL_DEBUG1 : SYSLOG_LEVEL_ERROR,\n\t\t\t    \"convert key\");\n\t\t\tcontinue;\n\t\t}\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\tdebug3_f(\"received %s key %s\", sshkey_type(key), fp);\n\t\tfree(fp);\n\n\t\tif (!key_accepted_by_hostkeyalgs(key)) {\n\t\t\tdebug3_f(\"%s key not permitted by \"\n\t\t\t    \"HostkeyAlgorithms\", sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (sshkey_is_cert(key)) {\n\t\t\tdebug3_f(\"%s key is a certificate; skipping\",\n\t\t\t    sshkey_ssh_name(key));\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\t\tif (sshkey_equal(key, ctx->keys[i])) {\n\t\t\t\terror_f(\"received duplicated %s host key\",\n\t\t\t\t    sshkey_ssh_name(key));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif ((tmp = recallocarray(ctx->keys, ctx->nkeys, ctx->nkeys + 1,\n\t\t    sizeof(*ctx->keys))) == NULL)\n\t\t\tfatal_f(\"recallocarray failed nkeys = %zu\",\n\t\t\t    ctx->nkeys);\n\t\tctx->keys = tmp;\n\t\tctx->keys[ctx->nkeys++] = key;\n\t\tkey = NULL;\n\t}\n\n\tif (ctx->nkeys == 0) {\n\t\tdebug_f(\"server sent no hostkeys\");\n\t\tgoto out;\n\t}\n\n\tif ((ctx->keys_match = calloc(ctx->nkeys,\n\t    sizeof(*ctx->keys_match))) == NULL ||\n\t    (ctx->keys_verified = calloc(ctx->nkeys,\n\t    sizeof(*ctx->keys_verified))) == NULL)\n\t\tfatal_f(\"calloc failed\");\n\n\tget_hostfile_hostname_ipaddr(host,\n\t    options.check_host_ip ? (struct sockaddr *)&hostaddr : NULL,\n\t    options.port, &ctx->host_str,\n\t    options.check_host_ip ? &ctx->ip_str : NULL);\n\n\t \n\tfor (i = 0; i < options.num_user_hostfiles; i++) {\n\t\tdebug_f(\"searching %s for %s / %s\",\n\t\t    options.user_hostfiles[i], ctx->host_str,\n\t\t    ctx->ip_str ? ctx->ip_str : \"(none)\");\n\t\tif ((r = hostkeys_foreach(options.user_hostfiles[i],\n\t\t    hostkeys_find, ctx, ctx->host_str, ctx->ip_str,\n\t\t    HKF_WANT_PARSE_KEY, 0)) != 0) {\n\t\t\tif (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT) {\n\t\t\t\tdebug_f(\"hostkeys file %s does not exist\",\n\t\t\t\t    options.user_hostfiles[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terror_fr(r, \"hostkeys_foreach failed for %s\",\n\t\t\t    options.user_hostfiles[i]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tctx->nnew = ctx->nincomplete = 0;\n\twant = HKF_MATCH_HOST | ( options.check_host_ip ? HKF_MATCH_IP : 0);\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_match[i] == 0)\n\t\t\tctx->nnew++;\n\t\tif ((ctx->keys_match[i] & want) != want)\n\t\t\tctx->nincomplete++;\n\t}\n\n\tdebug3_f(\"%zu server keys: %zu new, %zu retained, \"\n\t    \"%zu incomplete match. %zu to remove\", ctx->nkeys, ctx->nnew,\n\t    ctx->nkeys - ctx->nnew - ctx->nincomplete,\n\t    ctx->nincomplete, ctx->nold);\n\n\tif (ctx->nnew == 0 && ctx->nold == 0) {\n\t\tdebug_f(\"no new or deprecated keys from server\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (ctx->complex_hostspec) {\n\t\tdebug_f(\"CA/revocation marker, manual host list or wildcard \"\n\t\t    \"host pattern found, skipping UserKnownHostsFile update\");\n\t\tgoto out;\n\t}\n\tif (ctx->other_name_seen) {\n\t\tdebug_f(\"host key found matching a different name/address, \"\n\t\t    \"skipping UserKnownHostsFile update\");\n\t\tgoto out;\n\t}\n\t \n\tif (ctx->nold != 0) {\n\t\tif (check_old_keys_othernames(ctx) != 0)\n\t\t\tgoto out;  \n\t\tif (ctx->old_key_seen) {\n\t\t\tdebug_f(\"key(s) for %s%s%s exist under other names; \"\n\t\t\t    \"skipping UserKnownHostsFile update\",\n\t\t\t    ctx->host_str, ctx->ip_str == NULL ? \"\" : \",\",\n\t\t\t    ctx->ip_str == NULL ? \"\" : ctx->ip_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ctx->nnew == 0) {\n\t\t \n\t\tupdate_known_hosts(ctx);\n\t\tgoto out;\n\t}\n\t \n\tdebug3_f(\"asking server to prove ownership for %zu keys\", ctx->nnew);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh,\n\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 1)) != 0)  \n\t\tfatal_fr(r, \"prepare hostkeys-prove\");\n\tif ((buf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tfor (i = 0; i < ctx->nkeys; i++) {\n\t\tif (ctx->keys_match[i])\n\t\t\tcontinue;\n\t\tsshbuf_reset(buf);\n\t\tif ((r = sshkey_putb(ctx->keys[i], buf)) != 0 ||\n\t\t    (r = sshpkt_put_stringb(ssh, buf)) != 0)\n\t\t\tfatal_fr(r, \"assemble hostkeys-prove\");\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send hostkeys-prove\");\n\tclient_register_global_confirm(\n\t    client_global_hostkeys_prove_confirm, ctx);\n\tctx = NULL;   \n\tprove_sent = 1;\n\n\t \n out:\n\thostkeys_update_ctx_free(ctx);\n\tsshkey_free(key);\n\tsshbuf_free(buf);\n\tif (!prove_sent) {\n\t\t \n\t\thostkeys_update_complete = 1;\n\t\tclient_repledge();\n\t}\n\t \n\treturn 1;\n}\n\nstatic int\nclient_input_global_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *rtype;\n\tu_char want_reply;\n\tint r, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &rtype, NULL)) != 0 ||\n\t    (r = sshpkt_get_u8(ssh, &want_reply)) != 0)\n\t\tgoto out;\n\tdebug(\"client_input_global_request: rtype %s want_reply %d\",\n\t    rtype, want_reply);\n\tif (strcmp(rtype, \"hostkeys-00@openssh.com\") == 0)\n\t\tsuccess = client_input_hostkeys(ssh);\n\tif (want_reply) {\n\t\tif ((r = sshpkt_start(ssh, success ? SSH2_MSG_REQUEST_SUCCESS :\n\t\t    SSH2_MSG_REQUEST_FAILURE)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tfree(rtype);\n\treturn r;\n}\n\nstatic void\nclient_send_env(struct ssh *ssh, int id, const char *name, const char *val)\n{\n\tint r;\n\n\tdebug(\"channel %d: setting env %s = \\\"%s\\\"\", id, name, val);\n\tchannel_request_start(ssh, id, \"env\", 0);\n\tif ((r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, val)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send setenv\");\n}\n\nvoid\nclient_session2_setup(struct ssh *ssh, int id, int want_tty, int want_subsystem,\n    const char *term, struct termios *tiop, int in_fd, struct sshbuf *cmd,\n    char **env)\n{\n\tsize_t i, j, len;\n\tint matched, r;\n\tchar *name, *val;\n\tChannel *c = NULL;\n\n\tdebug2_f(\"id %d\", id);\n\n\tif ((c = channel_lookup(ssh, id)) == NULL)\n\t\tfatal_f(\"channel %d: unknown channel\", id);\n\n\tssh_packet_set_interactive(ssh, want_tty,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif (want_tty) {\n\t\tstruct winsize ws;\n\n\t\t \n\t\tif (ioctl(in_fd, TIOCGWINSZ, &ws) == -1)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\n\t\tchannel_request_start(ssh, id, \"pty-req\", 1);\n\t\tclient_expect_confirm(ssh, id, \"PTY allocation\", CONFIRM_TTY);\n\t\tif ((r = sshpkt_put_cstring(ssh, term != NULL ? term : \"\"))\n\t\t    != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_col)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_row)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_xpixel)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, (u_int)ws.ws_ypixel)) != 0)\n\t\t\tfatal_fr(r, \"build pty-req\");\n\t\tif (tiop == NULL)\n\t\t\ttiop = get_saved_tio();\n\t\tssh_tty_make_modes(ssh, -1, tiop);\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send pty-req\");\n\t\t \n\t\tc->client_tty = 1;\n\t}\n\n\t \n\tif (options.num_send_env != 0 && env != NULL) {\n\t\tdebug(\"Sending environment.\");\n\t\tfor (i = 0; env[i] != NULL; i++) {\n\t\t\t \n\t\t\tname = xstrdup(env[i]);\n\t\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*val++ = '\\0';\n\n\t\t\tmatched = 0;\n\t\t\tfor (j = 0; j < options.num_send_env; j++) {\n\t\t\t\tif (match_pattern(name, options.send_env[j])) {\n\t\t\t\t\tmatched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!matched) {\n\t\t\t\tdebug3(\"Ignored env %s\", name);\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclient_send_env(ssh, id, name, val);\n\t\t\tfree(name);\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\t \n\t\tname = xstrdup(options.setenv[i]);\n\t\tif ((val = strchr(name, '=')) == NULL) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\t*val++ = '\\0';\n\t\tclient_send_env(ssh, id, name, val);\n\t\tfree(name);\n\t}\n\n\tlen = sshbuf_len(cmd);\n\tif (len > 0) {\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tif (want_subsystem) {\n\t\t\tdebug(\"Sending subsystem: %.*s\",\n\t\t\t    (int)len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"subsystem\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"subsystem\",\n\t\t\t    CONFIRM_CLOSE);\n\t\t} else {\n\t\t\tdebug(\"Sending command: %.*s\",\n\t\t\t    (int)len, (const u_char*)sshbuf_ptr(cmd));\n\t\t\tchannel_request_start(ssh, id, \"exec\", 1);\n\t\t\tclient_expect_confirm(ssh, id, \"exec\", CONFIRM_CLOSE);\n\t\t}\n\t\tif ((r = sshpkt_put_stringb(ssh, cmd)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send command\");\n\t} else {\n\t\tchannel_request_start(ssh, id, \"shell\", 1);\n\t\tclient_expect_confirm(ssh, id, \"shell\", CONFIRM_CLOSE);\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send shell\");\n\t}\n\n\tsession_setup_complete = 1;\n\tclient_repledge();\n}\n\nstatic void\nclient_init_dispatch(struct ssh *ssh)\n{\n\tssh_dispatch_init(ssh, &dispatch_protocol_error);\n\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_OPEN, &client_input_channel_open);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_REQUEST, &client_input_channel_req);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_SUCCESS, &channel_input_status_confirm);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_FAILURE, &channel_input_status_confirm);\n\tssh_dispatch_set(ssh, SSH2_MSG_GLOBAL_REQUEST, &client_input_global_request);\n\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_REQUEST_FAILURE, &client_global_request_reply);\n\tssh_dispatch_set(ssh, SSH2_MSG_REQUEST_SUCCESS, &client_global_request_reply);\n}\n\nvoid\nclient_stop_mux(void)\n{\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\t \n\tif (options.control_persist || options.session_type == SESSION_TYPE_NONE) {\n\t\tsession_closed = 1;\n\t\tsetproctitle(\"[stopped mux]\");\n\t}\n}\n\n \nvoid\ncleanup_exit(int i)\n{\n\tleave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\tssh_kill_proxy_command();\n\t_exit(i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}