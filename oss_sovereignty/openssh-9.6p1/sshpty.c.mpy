{
  "module_name": "sshpty.c",
  "hash_id": "70da2d4e540783b5259198a4dde8c60d5c687e3e7196692e4dcdbec680da59f2",
  "original_prompt": "Ingested from openssh-9.6p1/sshpty.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <signal.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <pwd.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <termios.h>\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n#include <unistd.h>\n\n#include \"sshpty.h\"\n#include \"log.h\"\n#include \"misc.h\"\n\n#ifdef HAVE_PTY_H\n# include <pty.h>\n#endif\n\n#ifndef O_NOCTTY\n#define O_NOCTTY 0\n#endif\n\n#ifdef __APPLE__\n# include <AvailabilityMacros.h>\n# if (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)\n#  define __APPLE_PRIVPTY__\n# endif\n#endif\n\n \n\nint\npty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\t \n\tchar *name;\n\tint i;\n\n\ti = openpty(ptyfd, ttyfd, NULL, NULL, NULL);\n\tif (i == -1) {\n\t\terror(\"openpty: %.100s\", strerror(errno));\n\t\treturn 0;\n\t}\n\tname = ttyname(*ttyfd);\n\tif (!name)\n\t\tfatal(\"openpty returns device for which ttyname fails.\");\n\n\tstrlcpy(namebuf, name, namebuflen);\t \n\treturn 1;\n}\n\n \n\nvoid\npty_release(const char *tty)\n{\n#if !defined(__APPLE_PRIVPTY__) && !defined(HAVE_OPENPTY)\n\tif (chown(tty, (uid_t) 0, (gid_t) 0) == -1)\n\t\terror(\"chown %.100s 0 0 failed: %.100s\", tty, strerror(errno));\n\tif (chmod(tty, (mode_t) 0666) == -1)\n\t\terror(\"chmod %.100s 0666 failed: %.100s\", tty, strerror(errno));\n#endif  \n}\n\n \n\nvoid\npty_make_controlling_tty(int *ttyfd, const char *tty)\n{\n\tint fd;\n\n\t \n#ifdef TIOCNOTTY\n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif  \n\tif (setsid() == -1)\n\t\terror(\"setsid: %.100s\", strerror(errno));\n\n\t \n\tfd = open(_PATH_TTY, O_RDWR | O_NOCTTY);\n\tif (fd >= 0) {\n\t\terror(\"Failed to disconnect from controlling tty.\");\n\t\tclose(fd);\n\t}\n\t \n#ifdef TIOCSCTTY\n\tdebug(\"Setting controlling tty using TIOCSCTTY.\");\n\tif (ioctl(*ttyfd, TIOCSCTTY, NULL) < 0)\n\t\terror(\"ioctl(TIOCSCTTY): %.100s\", strerror(errno));\n#endif  \n#ifdef NEED_SETPGRP\n\tif (setpgrp(0,0) < 0)\n\t\terror(\"SETPGRP %s\",strerror(errno));\n#endif  \n\tfd = open(tty, O_RDWR);\n\tif (fd == -1)\n\t\terror(\"%.100s: %.100s\", tty, strerror(errno));\n\telse\n\t\tclose(fd);\n\n\t \n\tfd = open(_PATH_TTY, O_WRONLY);\n\tif (fd == -1)\n\t\terror(\"open /dev/tty failed - could not set controlling tty: %.100s\",\n\t\t    strerror(errno));\n\telse\n\t\tclose(fd);\n}\n\n \n\nvoid\npty_change_window_size(int ptyfd, u_int row, u_int col,\n\tu_int xpixel, u_int ypixel)\n{\n\tstruct winsize w;\n\n\t \n\tw.ws_row = row;\n\tw.ws_col = col;\n\tw.ws_xpixel = xpixel;\n\tw.ws_ypixel = ypixel;\n\t(void) ioctl(ptyfd, TIOCSWINSZ, &w);\n}\n\nvoid\npty_setowner(struct passwd *pw, const char *tty)\n{\n\tstruct group *grp;\n\tgid_t gid;\n\tmode_t mode;\n\tstruct stat st;\n\n\t \n\tgrp = getgrnam(\"tty\");\n\tif (grp == NULL)\n\t\tdebug(\"%s: no tty group\", __func__);\n\tgid = (grp != NULL) ? grp->gr_gid : pw->pw_gid;\n\tmode = (grp != NULL) ? 0620 : 0600;\n\n\t \n\tif (stat(tty, &st) == -1)\n\t\tfatal(\"stat(%.100s) failed: %.100s\", tty,\n\t\t    strerror(errno));\n\n#ifdef WITH_SELINUX\n\tssh_selinux_setup_pty(pw->pw_name, tty);\n#endif\n\n\tif (st.st_uid != pw->pw_uid || st.st_gid != gid) {\n\t\tif (chown(tty, pw->pw_uid, gid) == -1) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_uid == pw->pw_uid || st.st_uid == 0))\n\t\t\t\tdebug(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chown(%.100s, %u, %u) failed: %.100s\",\n\t\t\t\t    tty, (u_int)pw->pw_uid, (u_int)gid,\n\t\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tif ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {\n\t\tif (chmod(tty, mode) == -1) {\n\t\t\tif (errno == EROFS &&\n\t\t\t    (st.st_mode & (S_IRGRP | S_IROTH)) == 0)\n\t\t\t\tdebug(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t\telse\n\t\t\t\tfatal(\"chmod(%.100s, 0%o) failed: %.100s\",\n\t\t\t\t    tty, (u_int)mode, strerror(errno));\n\t\t}\n\t}\n}\n\n \nvoid\ndisconnect_controlling_tty(void)\n{\n#ifdef TIOCNOTTY\n\tint fd;\n\n\tif ((fd = open(_PATH_TTY, O_RDWR | O_NOCTTY)) >= 0) {\n\t\t(void) ioctl(fd, TIOCNOTTY, NULL);\n\t\tclose(fd);\n\t}\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}