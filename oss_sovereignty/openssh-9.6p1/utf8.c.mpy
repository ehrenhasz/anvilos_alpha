{
  "module_name": "utf8.c",
  "hash_id": "6ae372868fbaa08685873e48d35b60f5de3a0723f1276674d82115636c7c83da",
  "original_prompt": "Ingested from openssh-9.6p1/utf8.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_LANGINFO_H\n# include <langinfo.h>\n#endif\n#include <limits.h>\n#include <locale.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n# include <vis.h>\n#endif\n#ifdef HAVE_WCHAR_H\n# include <wchar.h>\n#endif\n\n#include \"utf8.h\"\n\nstatic int\t dangerous_locale(void);\nstatic int\t grow_dst(char **, size_t *, size_t, char **, size_t);\n\n\n \n\nstatic int\ndangerous_locale(void) {\n\tchar\t*loc;\n\n\tloc = nl_langinfo(CODESET);\n\treturn strcmp(loc, \"UTF-8\") != 0 &&\n\t    strcmp(loc, \"US-ASCII\") != 0 &&\t\t \n\t    strcmp(loc, \"ANSI_X3.4-1968\") != 0 &&\t \n\t    strcmp(loc, \"ISO8859-1\") != 0 &&\t\t \n\t    strcmp(loc, \"646\") != 0 &&\t\t\t \n\t    strcmp(loc, \"\") != 0;\t\t\t \n}\n\nstatic int\ngrow_dst(char **dst, size_t *sz, size_t maxsz, char **dp, size_t need)\n{\n\tchar\t*tp;\n\tsize_t\t tsz;\n\n\tif (*dp + need < *dst + *sz)\n\t\treturn 0;\n\ttsz = *sz + 128;\n\tif (tsz > maxsz)\n\t\ttsz = maxsz;\n\tif ((tp = recallocarray(*dst, *sz, tsz, 1)) == NULL)\n\t\treturn -1;\n\t*dp = tp + (*dp - *dst);\n\t*dst = tp;\n\t*sz = tsz;\n\treturn 0;\n}\n\n \n\nint\nvasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)\n{\n\tchar\t*src;\t \n\tchar\t*sp;\t \n\tchar\t*dst;\t \n\tchar\t*dp;\t \n\tchar\t*tp;\t \n\tsize_t\t sz;\t \n\twchar_t\t wc;\t \n\tint\t len;\t \n\tint\t ret;\t \n\tint\t width;\t \n\tint\t total_width, max_width, print;\n\n\tsrc = NULL;\n\tif ((ret = vasprintf(&src, fmt, ap)) <= 0)\n\t\tgoto fail;\n\n\tsz = strlen(src) + 1;\n\tif ((dst = malloc(sz)) == NULL) {\n\t\tfree(src);\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\tif (maxsz > INT_MAX)\n\t\tmaxsz = INT_MAX;\n\n\tsp = src;\n\tdp = dst;\n\tret = 0;\n\tprint = 1;\n\ttotal_width = 0;\n\tmax_width = wp == NULL ? INT_MAX : *wp;\n\twhile (*sp != '\\0') {\n\t\tif ((len = mbtowc(&wc, sp, MB_CUR_MAX)) == -1) {\n\t\t\t(void)mbtowc(NULL, NULL, MB_CUR_MAX);\n\t\t\tif (dangerous_locale()) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = 1;\n\t\t\twidth = -1;\n\t\t} else if (wp == NULL &&\n\t\t    (wc == L'\\n' || wc == L'\\r' || wc == L'\\t')) {\n\t\t\t \n\t\t\twidth = 0;\n\t\t} else if ((width = wcwidth(wc)) == -1 &&\n\t\t    dangerous_locale()) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (width >= 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - len ||\n\t\t\t    total_width > max_width - width))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, len) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttotal_width += width;\n\t\t\t\tmemcpy(dp, sp, len);\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tsp += len;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\twhile (len > 0) {\n\t\t\tif (print && (dp - dst >= (int)maxsz - 4 ||\n\t\t\t    total_width > max_width - 4))\n\t\t\t\tprint = 0;\n\t\t\tif (print) {\n\t\t\t\tif (grow_dst(&dst, &sz, maxsz,\n\t\t\t\t    &dp, 4) == -1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp = vis(dp, *sp, VIS_OCTAL | VIS_ALL, 0);\n\t\t\t\twidth = tp - dp;\n\t\t\t\ttotal_width += width;\n\t\t\t\tdp = tp;\n\t\t\t} else\n\t\t\t\twidth = 4;\n\t\t\tlen--;\n\t\t\tsp++;\n\t\t\tif (ret >= 0)\n\t\t\t\tret += width;\n\t\t}\n\t\tif (len > 0)\n\t\t\tbreak;\n\t}\n\tfree(src);\n\t*dp = '\\0';\n\t*str = dst;\n\tif (wp != NULL)\n\t\t*wp = total_width;\n\n\t \n\n\tif (ret < (int)maxsz && !print)\n\t\tret = -1;\n\treturn ret;\n\nfail:\n\tif (wp != NULL)\n\t\t*wp = 0;\n\tif (ret == 0) {\n\t\t*str = src;\n\t\treturn 0;\n\t} else {\n\t\t*str = NULL;\n\t\treturn -1;\n\t}\n}\n\nint\nsnmprintf(char *str, size_t sz, int *wp, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tchar\t*cp = NULL;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vasnmprintf(&cp, sz, wp, fmt, ap);\n\tva_end(ap);\n\tif (cp != NULL) {\n\t\t(void)strlcpy(str, cp, sz);\n\t\tfree(cp);\n\t} else\n\t\t*str = '\\0';\n\treturn ret;\n}\n\nint\nasmprintf(char **outp, size_t sz, int *wp, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\t*outp = NULL;\n\tva_start(ap, fmt);\n\tret = vasnmprintf(outp, sz, wp, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\n\n \n\nint\nvfmprintf(FILE *stream, const char *fmt, va_list ap)\n{\n\tchar\t*str = NULL;\n\tint\t ret;\n\n\tif ((ret = vasnmprintf(&str, INT_MAX, NULL, fmt, ap)) < 0) {\n\t\tfree(str);\n\t\treturn -1;\n\t}\n\tif (fputs(str, stream) == EOF)\n\t\tret = -1;\n\tfree(str);\n\treturn ret;\n}\n\nint\nfmprintf(FILE *stream, const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stream, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nint\nmprintf(const char *fmt, ...)\n{\n\tva_list\t ap;\n\tint\t ret;\n\n\tva_start(ap, fmt);\n\tret = vfmprintf(stdout, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\n \nvoid\nmsetlocale(void)\n{\n\tconst char *vars[] = { \"LC_ALL\", \"LC_CTYPE\", \"LANG\", NULL };\n\tchar *cp;\n\tint i;\n\n\t \n\tfor (i = 0; vars[i] != NULL; i++) {\n\t\tif ((cp = getenv(vars[i])) == NULL)\n\t\t\tcontinue;\n\t\tif (strncasecmp(cp, \"TR\", 2) != 0)\n\t\t\tbreak;\n\t\t \n\t\tif ((strcasestr(cp, \"UTF-8\") != NULL ||\n\t\t    strcasestr(cp, \"UTF8\") != NULL) &&\n\t\t    (setlocale(LC_CTYPE, \"C.UTF-8\") != NULL ||\n\t\t    setlocale(LC_CTYPE, \"POSIX.UTF-8\") != NULL))\n\t\t\treturn;\n\t\tsetlocale(LC_CTYPE, \"C\");\n\t\treturn;\n\t}\n\t \n\tsetlocale(LC_CTYPE, \"\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}