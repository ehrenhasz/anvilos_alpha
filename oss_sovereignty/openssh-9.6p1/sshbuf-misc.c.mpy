{
  "module_name": "sshbuf-misc.c",
  "hash_id": "549184b6740fb20ceffff528e244322ffc5c24e1e37b30852111b7fe7c0f81cf",
  "original_prompt": "Ingested from openssh-9.6p1/sshbuf-misc.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <errno.h>\n#include <stdlib.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#include <resolv.h>\n#include <ctype.h>\n#include <unistd.h>\n\n#include \"ssherr.h\"\n#define SSHBUF_INTERNAL\n#include \"sshbuf.h\"\n\nvoid\nsshbuf_dump_data(const void *s, size_t len, FILE *f)\n{\n\tsize_t i, j;\n\tconst u_char *p = (const u_char *)s;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(f, \"%.4zu: \", i);\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len)\n\t\t\t\tfprintf(f, \"%02x \", p[j]);\n\t\t\telse\n\t\t\t\tfprintf(f, \"   \");\n\t\t}\n\t\tfprintf(f, \" \");\n\t\tfor (j = i; j < i + 16; j++) {\n\t\t\tif (j < len) {\n\t\t\t\tif  (isascii(p[j]) && isprint(p[j]))\n\t\t\t\t\tfprintf(f, \"%c\", p[j]);\n\t\t\t\telse\n\t\t\t\t\tfprintf(f, \".\");\n\t\t\t}\n\t\t}\n\t\tfprintf(f, \"\\n\");\n\t}\n}\n\nvoid\nsshbuf_dump(const struct sshbuf *buf, FILE *f)\n{\n\tfprintf(f, \"buffer len = %zu\\n\", sshbuf_len(buf));\n\tsshbuf_dump_data(sshbuf_ptr(buf), sshbuf_len(buf), f);\n}\n\nchar *\nsshbuf_dtob16(struct sshbuf *buf)\n{\n\tsize_t i, j, len = sshbuf_len(buf);\n\tconst u_char *p = sshbuf_ptr(buf);\n\tchar *ret;\n\tconst char hex[] = \"0123456789abcdef\";\n\n\tif (len == 0)\n\t\treturn strdup(\"\");\n\tif (SIZE_MAX / 2 <= len || (ret = malloc(len * 2 + 1)) == NULL)\n\t\treturn NULL;\n\tfor (i = j = 0; i < len; i++) {\n\t\tret[j++] = hex[(p[i] >> 4) & 0xf];\n\t\tret[j++] = hex[p[i] & 0xf];\n\t}\n\tret[j] = '\\0';\n\treturn ret;\n}\n\nint\nsshbuf_dtob64(const struct sshbuf *d, struct sshbuf *b64, int wrap)\n{\n\tsize_t i, slen = 0;\n\tchar *s = NULL;\n\tint r;\n\n\tif (d == NULL || b64 == NULL || sshbuf_len(d) >= SIZE_MAX / 2)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (sshbuf_len(d) == 0)\n\t\treturn 0;\n\tslen = ((sshbuf_len(d) + 2) / 3) * 4 + 1;\n\tif ((s = malloc(slen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (b64_ntop(sshbuf_ptr(d), sshbuf_len(d), s, slen) == -1) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto fail;\n\t}\n\tif (wrap) {\n\t\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\t\tif ((r = sshbuf_put_u8(b64, s[i])) != 0)\n\t\t\t\tgoto fail;\n\t\t\tif (i % 70 == 69 && (r = sshbuf_put_u8(b64, '\\n')) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif ((i - 1) % 70 != 69 && (r = sshbuf_put_u8(b64, '\\n')) != 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tif ((r = sshbuf_put(b64, s, strlen(s))) != 0)\n\t\t\tgoto fail;\n\t}\n\t \n\tr = 0;\n fail:\n\tfreezero(s, slen);\n\treturn r;\n}\n\nchar *\nsshbuf_dtob64_string(const struct sshbuf *buf, int wrap)\n{\n\tstruct sshbuf *tmp;\n\tchar *ret;\n\n\tif ((tmp = sshbuf_new()) == NULL)\n\t\treturn NULL;\n\tif (sshbuf_dtob64(buf, tmp, wrap) != 0) {\n\t\tsshbuf_free(tmp);\n\t\treturn NULL;\n\t}\n\tret = sshbuf_dup_string(tmp);\n\tsshbuf_free(tmp);\n\treturn ret;\n}\n\nint\nsshbuf_b64tod(struct sshbuf *buf, const char *b64)\n{\n\tsize_t plen = strlen(b64);\n\tint nlen, r;\n\tu_char *p;\n\n\tif (plen == 0)\n\t\treturn 0;\n\tif ((p = malloc(plen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((nlen = b64_pton(b64, p, plen)) < 0) {\n\t\tfreezero(p, plen);\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tif ((r = sshbuf_put(buf, p, nlen)) < 0) {\n\t\tfreezero(p, plen);\n\t\treturn r;\n\t}\n\tfreezero(p, plen);\n\treturn 0;\n}\n\nint\nsshbuf_dtourlb64(const struct sshbuf *d, struct sshbuf *b64, int wrap)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tu_char *p;\n\tstruct sshbuf *b = NULL;\n\tsize_t i, l;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t \n\tif ((r = sshbuf_dtob64(d, b, wrap)) != 0)\n\t\tgoto out;\n\t \n\tfor (;;) {\n\t\tl = sshbuf_len(b);\n\t\tif (l <= 1 || sshbuf_ptr(b) == NULL) {\n\t\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sshbuf_ptr(b)[l - 1] != '=')\n\t\t\tbreak;\n\t\tif ((r = sshbuf_consume_end(b, 1)) != 0)\n\t\t\tgoto out;\n\t}\n\t \n\tl = sshbuf_len(b);\n\tif ((p = sshbuf_mutable_ptr(b)) == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < l; i++) {\n\t\tif (p[i] == '+')\n\t\t\tp[i] = '-';\n\t\telse if (p[i] == '/')\n\t\t\tp[i] = '_';\n\t}\n\tr = sshbuf_putb(b64, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\nchar *\nsshbuf_dup_string(struct sshbuf *buf)\n{\n\tconst u_char *p = NULL, *s = sshbuf_ptr(buf);\n\tsize_t l = sshbuf_len(buf);\n\tchar *r;\n\n\tif (s == NULL || l > SIZE_MAX)\n\t\treturn NULL;\n\t \n\tif (l > 0 && (p = memchr(s, '\\0', l)) != NULL) {\n\t\tif (p != s + l - 1)\n\t\t\treturn NULL;\n\t\tl--;  \n\t}\n\tif ((r = malloc(l + 1)) == NULL)\n\t\treturn NULL;\n\tif (l > 0)\n\t\tmemcpy(r, s, l);\n\tr[l] = '\\0';\n\treturn r;\n}\n\nint\nsshbuf_cmp(const struct sshbuf *b, size_t offset,\n    const void *s, size_t len)\n{\n\tif (sshbuf_ptr(b) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (offset > SSHBUF_SIZE_MAX || len > SSHBUF_SIZE_MAX || len == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (offset + len > sshbuf_len(b))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tif (timingsafe_bcmp(sshbuf_ptr(b) + offset, s, len) != 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\treturn 0;\n}\n\nint\nsshbuf_find(const struct sshbuf *b, size_t start_offset,\n    const void *s, size_t len, size_t *offsetp)\n{\n\tvoid *p;\n\n\tif (offsetp != NULL)\n\t\t*offsetp = 0;\n\tif (sshbuf_ptr(b) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tif (start_offset > SSHBUF_SIZE_MAX || len > SSHBUF_SIZE_MAX || len == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif (start_offset > sshbuf_len(b) || start_offset + len > sshbuf_len(b))\n\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\tif ((p = memmem(sshbuf_ptr(b) + start_offset,\n\t    sshbuf_len(b) - start_offset, s, len)) == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif (offsetp != NULL)\n\t\t*offsetp = (const u_char *)p - sshbuf_ptr(b);\n\treturn 0;\n}\n\nint\nsshbuf_read(int fd, struct sshbuf *buf, size_t maxlen, size_t *rlen)\n{\n\tint r, oerrno;\n\tsize_t adjust;\n\tssize_t rr;\n\tu_char *d;\n\n\tif (rlen != NULL)\n\t\t*rlen = 0;\n\tif ((r = sshbuf_reserve(buf, maxlen, &d)) != 0)\n\t\treturn r;\n\trr = read(fd, d, maxlen);\n\toerrno = errno;\n\n\t \n\tif ((adjust = maxlen - (rr > 0 ? rr : 0)) != 0) {\n\t\tif ((r = sshbuf_consume_end(buf, adjust)) != 0) {\n\t\t\t \n\t\t\tmemset(d + rr, '\\0', adjust);\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;  \n\t\t}\n\t}\n\tif (rr < 0) {\n\t\terrno = oerrno;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t} else if (rr == 0) {\n\t\terrno = EPIPE;\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t}\n\t \n\tif (rlen != NULL)\n\t\t*rlen = (size_t)rr;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}