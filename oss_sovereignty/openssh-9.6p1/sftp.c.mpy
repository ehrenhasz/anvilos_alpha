{
  "module_name": "sftp.c",
  "hash_id": "9813431027be792ae65082e46bd50700bfaa651fae8a70211a5959efc2e2f572",
  "original_prompt": "Ingested from openssh-9.6p1/sftp.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#include <sys/socket.h>\n#include <sys/wait.h>\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n\n#include <ctype.h>\n#include <errno.h>\n\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#ifdef HAVE_LIBGEN_H\n#include <libgen.h>\n#endif\n#ifdef HAVE_LOCALE_H\n# include <locale.h>\n#endif\n#ifdef USE_LIBEDIT\n#include <histedit.h>\n#else\ntypedef void EditLine;\n#endif\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"utf8.h\"\n\n#include \"sftp.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"sftp-common.h\"\n#include \"sftp-client.h\"\n#include \"sftp-usergroup.h\"\n\n \nFILE* infile;\n\n \nint batchmode = 0;\n\n \nstatic volatile pid_t sshpid = -1;\n\n \nint quiet = 0;\n\n \nint showprogress = 1;\n\n \nint global_rflag = 0;\n\n \nint global_aflag = 0;\n\n \nint global_pflag = 0;\n\n \nint global_fflag = 0;\n\n \nvolatile sig_atomic_t interrupted = 0;\n\n \nint sort_flag;\nglob_t *sort_glob;\n\n \nstruct complete_ctx {\n\tstruct sftp_conn *conn;\n\tchar **remote_pathp;\n};\n\nint sftp_glob(struct sftp_conn *, const char *, int,\n    int (*)(const char *, int), glob_t *);  \n\nextern char *__progname;\n\n \n#define WHITESPACE \" \\t\\r\\n\"\n\n \n#define LS_LONG_VIEW\t0x0001\t \n#define LS_SHORT_VIEW\t0x0002\t \n#define LS_NUMERIC_VIEW\t0x0004\t \n#define LS_NAME_SORT\t0x0008\t \n#define LS_TIME_SORT\t0x0010\t \n#define LS_SIZE_SORT\t0x0020\t \n#define LS_REVERSE_SORT\t0x0040\t \n#define LS_SHOW_ALL\t0x0080\t \n#define LS_SI_UNITS\t0x0100\t \n\n#define VIEW_FLAGS\t(LS_LONG_VIEW|LS_SHORT_VIEW|LS_NUMERIC_VIEW|LS_SI_UNITS)\n#define SORT_FLAGS\t(LS_NAME_SORT|LS_TIME_SORT|LS_SIZE_SORT)\n\n \nenum sftp_command {\n\tI_CHDIR = 1,\n\tI_CHGRP,\n\tI_CHMOD,\n\tI_CHOWN,\n\tI_COPY,\n\tI_DF,\n\tI_GET,\n\tI_HELP,\n\tI_LCHDIR,\n\tI_LINK,\n\tI_LLS,\n\tI_LMKDIR,\n\tI_LPWD,\n\tI_LS,\n\tI_LUMASK,\n\tI_MKDIR,\n\tI_PUT,\n\tI_PWD,\n\tI_QUIT,\n\tI_REGET,\n\tI_RENAME,\n\tI_REPUT,\n\tI_RM,\n\tI_RMDIR,\n\tI_SHELL,\n\tI_SYMLINK,\n\tI_VERSION,\n\tI_PROGRESS,\n};\n\nstruct CMD {\n\tconst char *c;\n\tconst int n;\n\tconst int t;\t \n\tconst int t2;\t \n};\n\n \n#define NOARGS\t0\n#define REMOTE\t1\n#define LOCAL\t2\n\nstatic const struct CMD cmds[] = {\n\t{ \"bye\",\tI_QUIT,\t\tNOARGS, \tNOARGS\t},\n\t{ \"cd\",\t\tI_CHDIR,\tREMOTE, \tNOARGS\t},\n\t{ \"chdir\",\tI_CHDIR,\tREMOTE, \tNOARGS\t},\n\t{ \"chgrp\",\tI_CHGRP,\tREMOTE, \tNOARGS\t},\n\t{ \"chmod\",\tI_CHMOD,\tREMOTE, \tNOARGS\t},\n\t{ \"chown\",\tI_CHOWN,\tREMOTE, \tNOARGS\t},\n\t{ \"copy\",\tI_COPY,\t\tREMOTE, \tLOCAL\t},\n\t{ \"cp\",\t\tI_COPY,\t\tREMOTE, \tLOCAL\t},\n\t{ \"df\",\t\tI_DF,\t\tREMOTE, \tNOARGS\t},\n\t{ \"dir\",\tI_LS,\t\tREMOTE, \tNOARGS\t},\n\t{ \"exit\",\tI_QUIT,\t\tNOARGS, \tNOARGS\t},\n\t{ \"get\",\tI_GET,\t\tREMOTE, \tLOCAL\t},\n\t{ \"help\",\tI_HELP,\t\tNOARGS, \tNOARGS\t},\n\t{ \"lcd\",\tI_LCHDIR,\tLOCAL,\t\tNOARGS\t},\n\t{ \"lchdir\",\tI_LCHDIR,\tLOCAL,\t\tNOARGS\t},\n\t{ \"lls\",\tI_LLS,\t\tLOCAL,\t\tNOARGS\t},\n\t{ \"lmkdir\",\tI_LMKDIR,\tLOCAL,\t\tNOARGS\t},\n\t{ \"ln\",\t\tI_LINK,\t\tREMOTE, \tREMOTE\t},\n\t{ \"lpwd\",\tI_LPWD,\t\tLOCAL,\t\tNOARGS\t},\n\t{ \"ls\",\t\tI_LS,\t\tREMOTE,\t\tNOARGS\t},\n\t{ \"lumask\",\tI_LUMASK,\tNOARGS,\t\tNOARGS\t},\n\t{ \"mkdir\",\tI_MKDIR,\tREMOTE,\t\tNOARGS\t},\n\t{ \"mget\",\tI_GET,\t\tREMOTE,\t\tLOCAL\t},\n\t{ \"mput\",\tI_PUT,\t\tLOCAL,\t\tREMOTE\t},\n\t{ \"progress\",\tI_PROGRESS,\tNOARGS,\t\tNOARGS\t},\n\t{ \"put\",\tI_PUT,\t\tLOCAL,\t\tREMOTE\t},\n\t{ \"pwd\",\tI_PWD,\t\tREMOTE, \tNOARGS\t},\n\t{ \"quit\",\tI_QUIT,\t\tNOARGS, \tNOARGS\t},\n\t{ \"reget\",\tI_REGET,\tREMOTE, \tLOCAL\t},\n\t{ \"rename\",\tI_RENAME,\tREMOTE, \tREMOTE\t},\n\t{ \"reput\",\tI_REPUT,\tLOCAL,\t\tREMOTE\t},\n\t{ \"rm\",\t\tI_RM,\t\tREMOTE,\t\tNOARGS\t},\n\t{ \"rmdir\",\tI_RMDIR,\tREMOTE,\t\tNOARGS\t},\n\t{ \"symlink\",\tI_SYMLINK,\tREMOTE,\t\tREMOTE\t},\n\t{ \"version\",\tI_VERSION,\tNOARGS, \tNOARGS\t},\n\t{ \"!\",\t\tI_SHELL,\tNOARGS, \tNOARGS\t},\n\t{ \"?\",\t\tI_HELP,\t\tNOARGS, \tNOARGS\t},\n\t{ NULL,\t\t-1,\t\t-1,\t\t-1\t}\n};\n\nstatic void\nkillchild(int signo)\n{\n\tpid_t pid;\n\n\tpid = sshpid;\n\tif (pid > 1) {\n\t\tkill(pid, SIGTERM);\n\t\t(void)waitpid(pid, NULL, 0);\n\t}\n\n\t_exit(1);\n}\n\nstatic void\nsuspchild(int signo)\n{\n\tif (sshpid > 1) {\n\t\tkill(sshpid, signo);\n\t\twhile (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t}\n\tkill(getpid(), SIGSTOP);\n}\n\nstatic void\ncmd_interrupt(int signo)\n{\n\tconst char msg[] = \"\\rInterrupt  \\n\";\n\tint olderrno = errno;\n\n\t(void)write(STDERR_FILENO, msg, sizeof(msg) - 1);\n\tinterrupted = 1;\n\terrno = olderrno;\n}\n\nstatic void\nread_interrupt(int signo)\n{\n\tinterrupted = 1;\n}\n\nstatic void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tconst char msg[] = \"\\rConnection closed.  \\n\";\n\n\t \n\twhile ((pid = waitpid(sshpid, NULL, WNOHANG)) == -1 && errno == EINTR)\n\t\tcontinue;\n\tif (pid == sshpid) {\n\t\tif (!quiet)\n\t\t    (void)write(STDERR_FILENO, msg, sizeof(msg) - 1);\n\t\tsshpid = -1;\n\t}\n\n\terrno = save_errno;\n}\n\nstatic void\nhelp(void)\n{\n\tprintf(\"Available commands:\\n\"\n\t    \"bye                                Quit sftp\\n\"\n\t    \"cd path                            Change remote directory to 'path'\\n\"\n\t    \"chgrp [-h] grp path                Change group of file 'path' to 'grp'\\n\"\n\t    \"chmod [-h] mode path               Change permissions of file 'path' to 'mode'\\n\"\n\t    \"chown [-h] own path                Change owner of file 'path' to 'own'\\n\"\n\t    \"copy oldpath newpath               Copy remote file\\n\"\n\t    \"cp oldpath newpath                 Copy remote file\\n\"\n\t    \"df [-hi] [path]                    Display statistics for current directory or\\n\"\n\t    \"                                   filesystem containing 'path'\\n\"\n\t    \"exit                               Quit sftp\\n\"\n\t    \"get [-afpR] remote [local]         Download file\\n\"\n\t    \"help                               Display this help text\\n\"\n\t    \"lcd path                           Change local directory to 'path'\\n\"\n\t    \"lls [ls-options [path]]            Display local directory listing\\n\"\n\t    \"lmkdir path                        Create local directory\\n\"\n\t    \"ln [-s] oldpath newpath            Link remote file (-s for symlink)\\n\"\n\t    \"lpwd                               Print local working directory\\n\"\n\t    \"ls [-1afhlnrSt] [path]             Display remote directory listing\\n\"\n\t    \"lumask umask                       Set local umask to 'umask'\\n\"\n\t    \"mkdir path                         Create remote directory\\n\"\n\t    \"progress                           Toggle display of progress meter\\n\"\n\t    \"put [-afpR] local [remote]         Upload file\\n\"\n\t    \"pwd                                Display remote working directory\\n\"\n\t    \"quit                               Quit sftp\\n\"\n\t    \"reget [-fpR] remote [local]        Resume download file\\n\"\n\t    \"rename oldpath newpath             Rename remote file\\n\"\n\t    \"reput [-fpR] local [remote]        Resume upload file\\n\"\n\t    \"rm path                            Delete remote file\\n\"\n\t    \"rmdir path                         Remove remote directory\\n\"\n\t    \"symlink oldpath newpath            Symlink remote file\\n\"\n\t    \"version                            Show SFTP version\\n\"\n\t    \"!command                           Execute 'command' in local shell\\n\"\n\t    \"!                                  Escape to local shell\\n\"\n\t    \"?                                  Synonym for help\\n\");\n}\n\nstatic void\nlocal_do_shell(const char *args)\n{\n\tint status;\n\tchar *shell;\n\tpid_t pid;\n\n\tif (!*args)\n\t\targs = NULL;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tif ((pid = fork()) == -1)\n\t\tfatal(\"Couldn't fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\t \n\t\tif (args) {\n\t\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\t} else {\n\t\t\tdebug3(\"Executing %s\", shell);\n\t\t\texecl(shell, shell, (char *)NULL);\n\t\t}\n\t\tfprintf(stderr, \"Couldn't execute \\\"%s\\\": %s\\n\", shell,\n\t\t    strerror(errno));\n\t\t_exit(1);\n\t}\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tif (!WIFEXITED(status))\n\t\terror(\"Shell exited abnormally\");\n\telse if (WEXITSTATUS(status))\n\t\terror(\"Shell exited with status %d\", WEXITSTATUS(status));\n}\n\nstatic void\nlocal_do_ls(const char *args)\n{\n\tif (!args || !*args)\n\t\tlocal_do_shell(_PATH_LS);\n\telse {\n\t\tint len = strlen(_PATH_LS \" \") + strlen(args) + 1;\n\t\tchar *buf = xmalloc(len);\n\n\t\t \n\t\tsnprintf(buf, len, _PATH_LS \" %s\", args);\n\t\tlocal_do_shell(buf);\n\t\tfree(buf);\n\t}\n}\n\n \nstatic char *\npath_strip(const char *path, const char *strip)\n{\n\tsize_t len;\n\n\tif (strip == NULL)\n\t\treturn (xstrdup(path));\n\n\tlen = strlen(strip);\n\tif (strncmp(path, strip, len) == 0) {\n\t\tif (strip[len - 1] != '/' && path[len] == '/')\n\t\t\tlen++;\n\t\treturn (xstrdup(path + len));\n\t}\n\n\treturn (xstrdup(path));\n}\n\nstatic int\nparse_getput_flags(const char *cmd, char **argv, int argc,\n    int *aflag, int *fflag, int *pflag, int *rflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*aflag = *fflag = *rflag = *pflag = 0;\n\twhile ((ch = getopt(argc, argv, \"afPpRr\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\t*aflag = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*fflag = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\t*pflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\t*rflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic int\nparse_link_flags(const char *cmd, char **argv, int argc, int *sflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*sflag = 0;\n\twhile ((ch = getopt(argc, argv, \"s\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 's':\n\t\t\t*sflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic int\nparse_rename_flags(const char *cmd, char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = 0;\n\twhile ((ch = getopt(argc, argv, \"l\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'l':\n\t\t\t*lflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic int\nparse_ls_flags(char **argv, int argc, int *lflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*lflag = LS_NAME_SORT;\n\twhile ((ch = getopt(argc, argv, \"1Safhlnrt\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase '1':\n\t\t\t*lflag &= ~VIEW_FLAGS;\n\t\t\t*lflag |= LS_SHORT_VIEW;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_SIZE_SORT;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t*lflag |= LS_SHOW_ALL;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t*lflag |= LS_SI_UNITS;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t*lflag &= ~LS_SHORT_VIEW;\n\t\t\t*lflag |= LS_NUMERIC_VIEW|LS_LONG_VIEW;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t*lflag |= LS_REVERSE_SORT;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t*lflag &= ~SORT_FLAGS;\n\t\t\t*lflag |= LS_TIME_SORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"ls: Invalid flag -%c\", optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic int\nparse_df_flags(const char *cmd, char **argv, int argc, int *hflag, int *iflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*hflag = *iflag = 0;\n\twhile ((ch = getopt(argc, argv, \"hi\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\t*hflag = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\t*iflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic int\nparse_ch_flags(const char *cmd, char **argv, int argc, int *hflag)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\t*hflag = 0;\n\twhile ((ch = getopt(argc, argv, \"h\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\t*hflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic int\nparse_no_flags(const char *cmd, char **argv, int argc)\n{\n\textern int opterr, optind, optopt, optreset;\n\tint ch;\n\n\toptind = optreset = 1;\n\topterr = 0;\n\n\twhile ((ch = getopt(argc, argv, \"\")) != -1) {\n\t\tswitch (ch) {\n\t\tdefault:\n\t\t\terror(\"%s: Invalid flag -%c\", cmd, optopt);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn optind;\n}\n\nstatic char *\nescape_glob(const char *s)\n{\n\tsize_t i, o, len;\n\tchar *ret;\n\n\tlen = strlen(s);\n\tret = xcalloc(2, len + 1);\n\tfor (i = o = 0; i < len; i++) {\n\t\tif (strchr(\"[]?*\\\\\", s[i]) != NULL)\n\t\t\tret[o++] = '\\\\';\n\t\tret[o++] = s[i];\n\t}\n\tret[o++] = '\\0';\n\treturn ret;\n}\n\n \nstatic char *\nmake_absolute_pwd_glob(char *p, const char *pwd)\n{\n\tchar *ret, *escpwd;\n\n\tescpwd = escape_glob(pwd);\n\tif (p == NULL)\n\t\treturn escpwd;\n\tret = sftp_make_absolute(p, escpwd);\n\tfree(escpwd);\n\treturn ret;\n}\n\nstatic int\nlocal_is_dir(const char *path)\n{\n\tstruct stat sb;\n\n\tif (stat(path, &sb) == -1)\n\t\treturn 0;\n\treturn S_ISDIR(sb.st_mode);\n}\n\nstatic int\nprocess_get(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *filename, *abs_src = NULL, *abs_dst = NULL, *tmp = NULL;\n\tglob_t g;\n\tint i, r, err = 0;\n\n\tabs_src = make_absolute_pwd_glob(xstrdup(src), pwd);\n\tmemset(&g, 0, sizeof(g));\n\n\tdebug3(\"Looking up %s\", abs_src);\n\tif ((r = sftp_glob(conn, abs_src, GLOB_MARK, NULL, &g)) != 0) {\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Too many matches for \\\"%s\\\".\", abs_src);\n\t\t} else {\n\t\t\terror(\"File \\\"%s\\\" not found.\", abs_src);\n\t\t}\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (g.gl_matchc > 1 && dst != NULL && !local_is_dir(dst)) {\n\t\terror(\"Multiple source paths, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (g.gl_matchc == 1 && dst) {\n\t\t\tif (local_is_dir(dst)) {\n\t\t\t\tabs_dst = sftp_path_append(dst, filename);\n\t\t\t} else {\n\t\t\t\tabs_dst = xstrdup(dst);\n\t\t\t}\n\t\t} else if (dst) {\n\t\t\tabs_dst = sftp_path_append(dst, filename);\n\t\t} else {\n\t\t\tabs_dst = xstrdup(filename);\n\t\t}\n\t\tfree(tmp);\n\n\t\tresume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Fetching %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\t \n\t\tif (sftp_globpath_is_dir(g.gl_pathv[i]) &&\n\t\t    (rflag || global_rflag)) {\n\t\t\tif (sftp_download_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    NULL, pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag, 0, 0) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (sftp_download(conn, g.gl_pathv[i], abs_dst, NULL,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag, 0) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t}\n\nout:\n\tfree(abs_src);\n\tglobfree(&g);\n\treturn(err);\n}\n\nstatic int\nprocess_put(struct sftp_conn *conn, const char *src, const char *dst,\n    const char *pwd, int pflag, int rflag, int resume, int fflag)\n{\n\tchar *tmp_dst = NULL;\n\tchar *abs_dst = NULL;\n\tchar *tmp = NULL, *filename = NULL;\n\tglob_t g;\n\tint err = 0;\n\tint i, dst_is_dir = 1;\n\tstruct stat sb;\n\n\tif (dst) {\n\t\ttmp_dst = xstrdup(dst);\n\t\ttmp_dst = sftp_make_absolute(tmp_dst, pwd);\n\t}\n\n\tmemset(&g, 0, sizeof(g));\n\tdebug3(\"Looking up %s\", src);\n\tif (glob(src, GLOB_NOCHECK | GLOB_MARK, NULL, &g)) {\n\t\terror(\"File \\\"%s\\\" not found.\", src);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tmp_dst != NULL)\n\t\tdst_is_dir = sftp_remote_is_dir(conn, tmp_dst);\n\n\t \n\tif (g.gl_matchc > 1 && tmp_dst && !dst_is_dir) {\n\t\terror(\"Multiple paths match, but destination \"\n\t\t    \"\\\"%s\\\" is not a directory\", tmp_dst);\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\tif (stat(g.gl_pathv[i], &sb) == -1) {\n\t\t\terr = -1;\n\t\t\terror(\"stat %s: %s\", g.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = xstrdup(g.gl_pathv[i]);\n\t\tif ((filename = basename(tmp)) == NULL) {\n\t\t\terror(\"basename %s: %s\", tmp, strerror(errno));\n\t\t\tfree(tmp);\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree(abs_dst);\n\t\tabs_dst = NULL;\n\t\tif (g.gl_matchc == 1 && tmp_dst) {\n\t\t\t \n\t\t\tif (dst_is_dir)\n\t\t\t\tabs_dst = sftp_path_append(tmp_dst, filename);\n\t\t\telse\n\t\t\t\tabs_dst = xstrdup(tmp_dst);\n\t\t} else if (tmp_dst) {\n\t\t\tabs_dst = sftp_path_append(tmp_dst, filename);\n\t\t} else {\n\t\t\tabs_dst = sftp_make_absolute(xstrdup(filename), pwd);\n\t\t}\n\t\tfree(tmp);\n\n\t\tresume |= global_aflag;\n\t\tif (!quiet && resume)\n\t\t\tmprintf(\"Resuming upload of %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\telse if (!quiet && !resume)\n\t\t\tmprintf(\"Uploading %s to %s\\n\",\n\t\t\t    g.gl_pathv[i], abs_dst);\n\t\t \n\t\tif (sftp_globpath_is_dir(g.gl_pathv[i]) &&\n\t\t    (rflag || global_rflag)) {\n\t\t\tif (sftp_upload_dir(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, 1, resume,\n\t\t\t    fflag || global_fflag, 0, 0) == -1)\n\t\t\t\terr = -1;\n\t\t} else {\n\t\t\tif (sftp_upload(conn, g.gl_pathv[i], abs_dst,\n\t\t\t    pflag || global_pflag, resume,\n\t\t\t    fflag || global_fflag, 0) == -1)\n\t\t\t\terr = -1;\n\t\t}\n\t}\n\nout:\n\tfree(abs_dst);\n\tfree(tmp_dst);\n\tglobfree(&g);\n\treturn(err);\n}\n\nstatic int\nsdirent_comp(const void *aa, const void *bb)\n{\n\tSFTP_DIRENT *a = *(SFTP_DIRENT **)aa;\n\tSFTP_DIRENT *b = *(SFTP_DIRENT **)bb;\n\tint rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;\n\n#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))\n\tif (sort_flag & LS_NAME_SORT)\n\t\treturn (rmul * strcmp(a->filename, b->filename));\n\telse if (sort_flag & LS_TIME_SORT)\n\t\treturn (rmul * NCMP(a->a.mtime, b->a.mtime));\n\telse if (sort_flag & LS_SIZE_SORT)\n\t\treturn (rmul * NCMP(a->a.size, b->a.size));\n\n\tfatal(\"Unknown ls sort type\");\n}\n\n \nstatic int\ndo_ls_dir(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tint n;\n\tu_int c = 1, colspace = 0, columns = 1;\n\tSFTP_DIRENT **d;\n\n\tif ((n = sftp_readdir(conn, path, &d)) != 0)\n\t\treturn (n);\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\tu_int m = 0, width = 80;\n\t\tstruct winsize ws;\n\t\tchar *tmp;\n\n\t\t \n\t\tfor (n = 0; d[n] != NULL; n++) {\n\t\t\tif (d[n]->filename[0] != '.' || (lflag & LS_SHOW_ALL))\n\t\t\t\tm = MAXIMUM(m, strlen(d[n]->filename));\n\t\t}\n\n\t\t \n\t\ttmp = path_strip(path, strip_path);\n\t\tm += strlen(tmp);\n\t\tfree(tmp);\n\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\t\twidth = ws.ws_col;\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t\tcolspace = MINIMUM(colspace, width);\n\t}\n\n\tif (lflag & SORT_FLAGS) {\n\t\tfor (n = 0; d[n] != NULL; n++)\n\t\t\t;\t \n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(d, n, sizeof(*d), sdirent_comp);\n\t}\n\n\tget_remote_user_groups_from_dirents(conn, d);\n\tfor (n = 0; d[n] != NULL && !interrupted; n++) {\n\t\tchar *tmp, *fname;\n\n\t\tif (d[n]->filename[0] == '.' && !(lflag & LS_SHOW_ALL))\n\t\t\tcontinue;\n\n\t\ttmp = sftp_path_append(path, d[n]->filename);\n\t\tfname = path_strip(tmp, strip_path);\n\t\tfree(tmp);\n\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif ((lflag & (LS_NUMERIC_VIEW|LS_SI_UNITS)) != 0 ||\n\t\t\t    sftp_can_get_users_groups_by_id(conn)) {\n\t\t\t\tchar *lname;\n\t\t\t\tstruct stat sb;\n\n\t\t\t\tmemset(&sb, 0, sizeof(sb));\n\t\t\t\tattrib_to_stat(&d[n]->a, &sb);\n\t\t\t\tlname = ls_file(fname, &sb, 1,\n\t\t\t\t    (lflag & LS_SI_UNITS),\n\t\t\t\t    ruser_name(sb.st_uid),\n\t\t\t\t    rgroup_name(sb.st_gid));\n\t\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\t\tfree(lname);\n\t\t\t} else\n\t\t\t\tmprintf(\"%s\\n\", d[n]->longname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n\tsftp_free_dirents(d);\n\treturn (0);\n}\n\nstatic int\nsglob_comp(const void *aa, const void *bb)\n{\n\tu_int a = *(const u_int *)aa;\n\tu_int b = *(const u_int *)bb;\n\tconst char *ap = sort_glob->gl_pathv[a];\n\tconst char *bp = sort_glob->gl_pathv[b];\n\tconst struct stat *as = sort_glob->gl_statv[a];\n\tconst struct stat *bs = sort_glob->gl_statv[b];\n\tint rmul = sort_flag & LS_REVERSE_SORT ? -1 : 1;\n\n#define NCMP(a,b) (a == b ? 0 : (a < b ? 1 : -1))\n\tif (sort_flag & LS_NAME_SORT)\n\t\treturn (rmul * strcmp(ap, bp));\n\telse if (sort_flag & LS_TIME_SORT) {\n#if defined(HAVE_STRUCT_STAT_ST_MTIM)\n\t\tif (timespeccmp(&as->st_mtim, &bs->st_mtim, ==))\n\t\t\treturn 0;\n\t\treturn timespeccmp(&as->st_mtim, &bs->st_mtim, <) ?\n\t\t    rmul : -rmul;\n#elif defined(HAVE_STRUCT_STAT_ST_MTIME)\n\t\treturn (rmul * NCMP(as->st_mtime, bs->st_mtime));\n#else\n\treturn rmul * 1;\n#endif\n\t} else if (sort_flag & LS_SIZE_SORT)\n\t\treturn (rmul * NCMP(as->st_size, bs->st_size));\n\n\tfatal(\"Unknown ls sort type\");\n}\n\n \nstatic int\ndo_globbed_ls(struct sftp_conn *conn, const char *path,\n    const char *strip_path, int lflag)\n{\n\tchar *fname, *lname;\n\tglob_t g;\n\tint err, r;\n\tstruct winsize ws;\n\tu_int i, j, nentries, *indices = NULL, c = 1;\n\tu_int colspace = 0, columns = 1, m = 0, width = 80;\n\n\tmemset(&g, 0, sizeof(g));\n\n\tif ((r = sftp_glob(conn, path,\n\t    GLOB_MARK|GLOB_NOCHECK|GLOB_BRACE|GLOB_KEEPSTAT|GLOB_NOSORT,\n\t    NULL, &g)) != 0 ||\n\t    (g.gl_pathc && !g.gl_matchc)) {\n\t\tif (g.gl_pathc)\n\t\t\tglobfree(&g);\n\t\tif (r == GLOB_NOSPACE) {\n\t\t\terror(\"Can't ls: Too many matches for \\\"%s\\\"\", path);\n\t\t} else {\n\t\t\terror(\"Can't ls: \\\"%s\\\" not found\", path);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (interrupted)\n\t\tgoto out;\n\n\t \n\tif (g.gl_matchc == 1 && g.gl_statv[0] != NULL &&\n\t    S_ISDIR(g.gl_statv[0]->st_mode)) {\n\t\terr = do_ls_dir(conn, g.gl_pathv[0], strip_path, lflag);\n\t\tglobfree(&g);\n\t\treturn err;\n\t}\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tif (!(lflag & LS_SHORT_VIEW)) {\n\t\t \n\t\tfor (i = 0; g.gl_pathv[i]; i++)\n\t\t\tm = MAXIMUM(m, strlen(g.gl_pathv[i]));\n\n\t\tcolumns = width / (m + 2);\n\t\tcolumns = MAXIMUM(columns, 1);\n\t\tcolspace = width / columns;\n\t}\n\n\t \n\tfor (nentries = 0; g.gl_pathv[nentries] != NULL; nentries++)\n\t\t;\t \n\tindices = xcalloc(nentries, sizeof(*indices));\n\tfor (i = 0; i < nentries; i++)\n\t\tindices[i] = i;\n\n\tif (lflag & SORT_FLAGS) {\n\t\tsort_glob = &g;\n\t\tsort_flag = lflag & (SORT_FLAGS|LS_REVERSE_SORT);\n\t\tqsort(indices, nentries, sizeof(*indices), sglob_comp);\n\t\tsort_glob = NULL;\n\t}\n\n\tget_remote_user_groups_from_glob(conn, &g);\n\tfor (j = 0; j < nentries && !interrupted; j++) {\n\t\ti = indices[j];\n\t\tfname = path_strip(g.gl_pathv[i], strip_path);\n\t\tif (lflag & LS_LONG_VIEW) {\n\t\t\tif (g.gl_statv[i] == NULL) {\n\t\t\t\terror(\"no stat information for %s\", fname);\n\t\t\t\tfree(fname);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlname = ls_file(fname, g.gl_statv[i], 1,\n\t\t\t    (lflag & LS_SI_UNITS),\n\t\t\t    ruser_name(g.gl_statv[i]->st_uid),\n\t\t\t    rgroup_name(g.gl_statv[i]->st_gid));\n\t\t\tmprintf(\"%s\\n\", lname);\n\t\t\tfree(lname);\n\t\t} else {\n\t\t\tmprintf(\"%-*s\", colspace, fname);\n\t\t\tif (c >= columns) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tc = 1;\n\t\t\t} else\n\t\t\t\tc++;\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (!(lflag & LS_LONG_VIEW) && (c != 1))\n\t\tprintf(\"\\n\");\n\n out:\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(indices);\n\n\treturn 0;\n}\n\nstatic int\ndo_df(struct sftp_conn *conn, const char *path, int hflag, int iflag)\n{\n\tstruct sftp_statvfs st;\n\tchar s_used[FMT_SCALED_STRSIZE], s_avail[FMT_SCALED_STRSIZE];\n\tchar s_root[FMT_SCALED_STRSIZE], s_total[FMT_SCALED_STRSIZE];\n\tchar s_icapacity[16], s_dcapacity[16];\n\n\tif (sftp_statvfs(conn, path, &st, 1) == -1)\n\t\treturn -1;\n\tif (st.f_files == 0)\n\t\tstrlcpy(s_icapacity, \"ERR\", sizeof(s_icapacity));\n\telse {\n\t\tsnprintf(s_icapacity, sizeof(s_icapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_files - st.f_ffree) /\n\t\t    st.f_files));\n\t}\n\tif (st.f_blocks == 0)\n\t\tstrlcpy(s_dcapacity, \"ERR\", sizeof(s_dcapacity));\n\telse {\n\t\tsnprintf(s_dcapacity, sizeof(s_dcapacity), \"%3llu%%\",\n\t\t    (unsigned long long)(100 * (st.f_blocks - st.f_bfree) /\n\t\t    st.f_blocks));\n\t}\n\tif (iflag) {\n\t\tprintf(\"     Inodes        Used       Avail      \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%11llu %11llu %11llu %11llu         %s\\n\",\n\t\t    (unsigned long long)st.f_files,\n\t\t    (unsigned long long)(st.f_files - st.f_ffree),\n\t\t    (unsigned long long)st.f_favail,\n\t\t    (unsigned long long)st.f_ffree, s_icapacity);\n\t} else if (hflag) {\n\t\tstrlcpy(s_used, \"error\", sizeof(s_used));\n\t\tstrlcpy(s_avail, \"error\", sizeof(s_avail));\n\t\tstrlcpy(s_root, \"error\", sizeof(s_root));\n\t\tstrlcpy(s_total, \"error\", sizeof(s_total));\n\t\tfmt_scaled((st.f_blocks - st.f_bfree) * st.f_frsize, s_used);\n\t\tfmt_scaled(st.f_bavail * st.f_frsize, s_avail);\n\t\tfmt_scaled(st.f_bfree * st.f_frsize, s_root);\n\t\tfmt_scaled(st.f_blocks * st.f_frsize, s_total);\n\t\tprintf(\"    Size     Used    Avail   (root)    %%Capacity\\n\");\n\t\tprintf(\"%7sB %7sB %7sB %7sB         %s\\n\",\n\t\t    s_total, s_used, s_avail, s_root, s_dcapacity);\n\t} else {\n\t\tprintf(\"        Size         Used        Avail       \"\n\t\t    \"(root)    %%Capacity\\n\");\n\t\tprintf(\"%12llu %12llu %12llu %12llu         %s\\n\",\n\t\t    (unsigned long long)(st.f_frsize * st.f_blocks / 1024),\n\t\t    (unsigned long long)(st.f_frsize *\n\t\t    (st.f_blocks - st.f_bfree) / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bavail / 1024),\n\t\t    (unsigned long long)(st.f_frsize * st.f_bfree / 1024),\n\t\t    s_dcapacity);\n\t}\n\treturn 0;\n}\n\n \nstatic void\nundo_glob_escape(char *s)\n{\n\tsize_t i, j;\n\n\tfor (i = j = 0;;) {\n\t\tif (s[i] == '\\0') {\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\t}\n\t\tif (s[i] != '\\\\') {\n\t\t\ts[j++] = s[i++];\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\t++i;\n\t\tswitch (s[i]) {\n\t\tcase '?':\n\t\tcase '[':\n\t\tcase '*':\n\t\tcase '\\\\':\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j] = '\\0';\n\t\t\treturn;\n\t\tdefault:\n\t\t\ts[j++] = '\\\\';\n\t\t\ts[j++] = s[i++];\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n#define MAXARGS\t\t128\n#define MAXARGLEN\t8192\nstatic char **\nmakeargv(const char *arg, int *argcp, int sloppy, char *lastquote,\n    u_int *terminated)\n{\n\tint argc, quot;\n\tsize_t i, j;\n\tstatic char argvs[MAXARGLEN];\n\tstatic char *argv[MAXARGS + 1];\n\tenum { MA_START, MA_SQUOTE, MA_DQUOTE, MA_UNQUOTED } state, q;\n\n\t*argcp = argc = 0;\n\tif (strlen(arg) > sizeof(argvs) - 1) {\n args_too_longs:\n\t\terror(\"string too long\");\n\t\treturn NULL;\n\t}\n\tif (terminated != NULL)\n\t\t*terminated = 1;\n\tif (lastquote != NULL)\n\t\t*lastquote = '\\0';\n\tstate = MA_START;\n\ti = j = 0;\n\tfor (;;) {\n\t\tif ((size_t)argc >= sizeof(argv) / sizeof(*argv)){\n\t\t\terror(\"Too many arguments.\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (isspace((unsigned char)arg[i])) {\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\t \n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t\tstate = MA_START;\n\t\t\t} else if (state != MA_START)\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\"' || arg[i] == '\\'') {\n\t\t\tq = arg[i] == '\"' ? MA_DQUOTE : MA_SQUOTE;\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = q;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = arg[i];\n\t\t\t} else if (state == MA_UNQUOTED)\n\t\t\t\tstate = q;\n\t\t\telse if (state == q)\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\telse\n\t\t\t\targvs[j++] = arg[i];\n\t\t} else if (arg[i] == '\\\\') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tquot = state == MA_SQUOTE ? '\\'' : '\"';\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (arg[i + 1] == quot) {\n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else if (arg[i + 1] == '?' ||\n\t\t\t\t    arg[i + 1] == '[' || arg[i + 1] == '*') {\n\t\t\t\t\t \n\t\t\t\t\tif (j >= sizeof(argvs) - 5)\n\t\t\t\t\t\tgoto args_too_longs;\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (state == MA_START) {\n\t\t\t\t\targv[argc] = argvs + j;\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t\t*lastquote = '\\0';\n\t\t\t\t}\n\t\t\t\tif (arg[i + 1] == '?' || arg[i + 1] == '[' ||\n\t\t\t\t    arg[i + 1] == '*' || arg[i + 1] == '\\\\') {\n\t\t\t\t\t \n\t\t\t\t\targvs[j++] = arg[i++];\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\ti++;\n\t\t\t\t\targvs[j++] = arg[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arg[i] == '#') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE)\n\t\t\t\targvs[j++] = arg[i];\n\t\t\telse\n\t\t\t\tgoto string_done;\n\t\t} else if (arg[i] == '\\0') {\n\t\t\tif (state == MA_SQUOTE || state == MA_DQUOTE) {\n\t\t\t\tif (sloppy) {\n\t\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\t\tif (terminated != NULL)\n\t\t\t\t\t\t*terminated = 0;\n\t\t\t\t\tgoto string_done;\n\t\t\t\t}\n\t\t\t\terror(\"Unterminated quoted argument\");\n\t\t\t\treturn NULL;\n\t\t\t}\n string_done:\n\t\t\tif (state == MA_UNQUOTED) {\n\t\t\t\targvs[j++] = '\\0';\n\t\t\t\targc++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (state == MA_START) {\n\t\t\t\targv[argc] = argvs + j;\n\t\t\t\tstate = MA_UNQUOTED;\n\t\t\t\tif (lastquote != NULL)\n\t\t\t\t\t*lastquote = '\\0';\n\t\t\t}\n\t\t\tif ((state == MA_SQUOTE || state == MA_DQUOTE) &&\n\t\t\t    (arg[i] == '?' || arg[i] == '[' || arg[i] == '*')) {\n\t\t\t\t \n\t\t\t\tif (j >= sizeof(argvs) - 3)\n\t\t\t\t\tgoto args_too_longs;\n\t\t\t\targvs[j++] = '\\\\';\n\t\t\t\targvs[j++] = arg[i];\n\t\t\t} else\n\t\t\t\targvs[j++] = arg[i];\n\t\t}\n\t\ti++;\n\t}\n\t*argcp = argc;\n\treturn argv;\n}\n\nstatic int\nparse_args(const char **cpp, int *ignore_errors, int *disable_echo, int *aflag,\n\t  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,\n\t  int *rflag, int *sflag,\n    unsigned long *n_arg, char **path1, char **path2)\n{\n\tconst char *cmd, *cp = *cpp;\n\tchar *cp2, **argv;\n\tint base = 0;\n\tlong long ll;\n\tint path1_mandatory = 0, i, cmdnum, optidx, argc;\n\n\t \n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t \n\t*ignore_errors = 0;\n\t*disable_echo = 0;\n\tfor (;*cp != '\\0'; cp++) {\n\t\tif (*cp == '-') {\n\t\t\t*ignore_errors = 1;\n\t\t} else if (*cp == '@') {\n\t\t\t*disable_echo = 1;\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tcp = cp + strspn(cp, WHITESPACE);\n\n\t \n\tif (*cp == '\\0' || *cp == '#')\n\t\treturn (0);\n\n\tif ((argv = makeargv(cp, &argc, 0, NULL, NULL)) == NULL)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; cmds[i].c != NULL; i++) {\n\t\tif (argv[0] != NULL && strcasecmp(cmds[i].c, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tcmdnum = cmds[i].n;\n\tcmd = cmds[i].c;\n\n\t \n\tif (*cp == '!') {\n\t\tcp++;\n\t\tcmdnum = I_SHELL;\n\t} else if (cmdnum == -1) {\n\t\terror(\"Invalid command.\");\n\t\treturn -1;\n\t}\n\n\t \n\t*aflag = *fflag = *hflag = *iflag = *lflag = *pflag = 0;\n\t*rflag = *sflag = 0;\n\t*path1 = *path2 = NULL;\n\toptidx = 1;\n\tswitch (cmdnum) {\n\tcase I_GET:\n\tcase I_REGET:\n\tcase I_REPUT:\n\tcase I_PUT:\n\t\tif ((optidx = parse_getput_flags(cmd, argv, argc,\n\t\t    aflag, fflag, pflag, rflag)) == -1)\n\t\t\treturn -1;\n\t\t \n\t\tif (argc - optidx < 1) {\n\t\t\terror(\"You must specify at least one path after a \"\n\t\t\t    \"%s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t \n\t\tif (argc - optidx > 1) {\n\t\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t\t \n\t\t\tundo_glob_escape(*path2);\n\t\t}\n\t\tbreak;\n\tcase I_LINK:\n\t\tif ((optidx = parse_link_flags(cmd, argv, argc, sflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_COPY:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_RENAME:\n\t\tif ((optidx = parse_rename_flags(cmd, argv, argc, lflag)) == -1)\n\t\t\treturn -1;\n\t\tgoto parse_two_paths;\n\tcase I_SYMLINK:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n parse_two_paths:\n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify two paths after a %s \"\n\t\t\t    \"command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t*path2 = xstrdup(argv[optidx + 1]);\n\t\t \n\t\tundo_glob_escape(*path1);\n\t\tundo_glob_escape(*path2);\n\t\tbreak;\n\tcase I_RM:\n\tcase I_MKDIR:\n\tcase I_RMDIR:\n\tcase I_LMKDIR:\n\t\tpath1_mandatory = 1;\n\t\t \n\tcase I_CHDIR:\n\tcase I_LCHDIR:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\t \n\t\tif (argc - optidx < 1) {\n\t\t\tif (!path1_mandatory)\n\t\t\t\tbreak;  \n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx]);\n\t\t \n\t\tif (cmdnum != I_RM)\n\t\t\tundo_glob_escape(*path1);\n\t\tbreak;\n\tcase I_DF:\n\t\tif ((optidx = parse_df_flags(cmd, argv, argc, hflag,\n\t\t    iflag)) == -1)\n\t\t\treturn -1;\n\t\t \n\t\tif (argc - optidx < 1)\n\t\t\t*path1 = NULL;\n\t\telse {\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\t\tundo_glob_escape(*path1);\n\t\t}\n\t\tbreak;\n\tcase I_LS:\n\t\tif ((optidx = parse_ls_flags(argv, argc, lflag)) == -1)\n\t\t\treturn(-1);\n\t\t \n\t\tif (argc - optidx > 0)\n\t\t\t*path1 = xstrdup(argv[optidx]);\n\t\tbreak;\n\tcase I_LLS:\n\t\t \n\t\tcp = cp + strlen(cmd) + strspn(cp, WHITESPACE);\n\tcase I_SHELL:\n\t\t \n\t\tbreak;\n\tcase I_LUMASK:\n\tcase I_CHMOD:\n\t\tbase = 8;\n\t\t \n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tif ((optidx = parse_ch_flags(cmd, argv, argc, hflag)) == -1)\n\t\t\treturn -1;\n\t\t \n\t\tif (argc - optidx < 1)\n\t\t\tgoto need_num_arg;\n\t\terrno = 0;\n\t\tll = strtoll(argv[optidx], &cp2, base);\n\t\tif (cp2 == argv[optidx] || *cp2 != '\\0' ||\n\t\t    ((ll == LLONG_MIN || ll == LLONG_MAX) && errno == ERANGE) ||\n\t\t    ll < 0 || ll > UINT32_MAX) {\n need_num_arg:\n\t\t\terror(\"You must supply a numeric argument \"\n\t\t\t    \"to the %s command.\", cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*n_arg = ll;\n\t\tif (cmdnum == I_LUMASK)\n\t\t\tbreak;\n\t\t \n\t\tif (argc - optidx < 2) {\n\t\t\terror(\"You must specify a path after a %s command.\",\n\t\t\t    cmd);\n\t\t\treturn -1;\n\t\t}\n\t\t*path1 = xstrdup(argv[optidx + 1]);\n\t\tbreak;\n\tcase I_QUIT:\n\tcase I_PWD:\n\tcase I_LPWD:\n\tcase I_HELP:\n\tcase I_VERSION:\n\tcase I_PROGRESS:\n\t\tif ((optidx = parse_no_flags(cmd, argv, argc)) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Command not implemented\");\n\t}\n\n\t*cpp = cp;\n\treturn(cmdnum);\n}\n\nstatic int\nparse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,\n    const char *startdir, int err_abort, int echo_command)\n{\n\tconst char *ocmd = cmd;\n\tchar *path1, *path2, *tmp;\n\tint ignore_errors = 0, disable_echo = 1;\n\tint aflag = 0, fflag = 0, hflag = 0, iflag = 0;\n\tint lflag = 0, pflag = 0, rflag = 0, sflag = 0;\n\tint cmdnum, i;\n\tunsigned long n_arg = 0;\n\tAttrib a, aa;\n\tchar path_buf[PATH_MAX];\n\tint err = 0;\n\tglob_t g;\n\n\tpath1 = path2 = NULL;\n\tcmdnum = parse_args(&cmd, &ignore_errors, &disable_echo, &aflag, &fflag,\n\t    &hflag, &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg,\n\t    &path1, &path2);\n\tif (ignore_errors != 0)\n\t\terr_abort = 0;\n\n\tif (echo_command && !disable_echo)\n\t\tmprintf(\"sftp> %s\\n\", ocmd);\n\n\tmemset(&g, 0, sizeof(g));\n\n\t \n\tswitch (cmdnum) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -1:\n\t\t \n\t\terr = -1;\n\t\tbreak;\n\tcase I_REGET:\n\t\taflag = 1;\n\t\t \n\tcase I_GET:\n\t\terr = process_get(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_REPUT:\n\t\taflag = 1;\n\t\t \n\tcase I_PUT:\n\t\terr = process_put(conn, path1, path2, *pwd, pflag,\n\t\t    rflag, aflag, fflag);\n\t\tbreak;\n\tcase I_COPY:\n\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\tpath2 = sftp_make_absolute(path2, *pwd);\n\t\terr = sftp_copy(conn, path1, path2);\n\t\tbreak;\n\tcase I_RENAME:\n\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\tpath2 = sftp_make_absolute(path2, *pwd);\n\t\terr = sftp_rename(conn, path1, path2, lflag);\n\t\tbreak;\n\tcase I_SYMLINK:\n\t\tsflag = 1;\n\t\t \n\tcase I_LINK:\n\t\tif (!sflag)\n\t\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\tpath2 = sftp_make_absolute(path2, *pwd);\n\t\terr = (sflag ? sftp_symlink : sftp_hardlink)(conn,\n\t\t    path1, path2);\n\t\tbreak;\n\tcase I_RM:\n\t\tpath1 = make_absolute_pwd_glob(path1, *pwd);\n\t\tsftp_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Removing %s\\n\", g.gl_pathv[i]);\n\t\t\terr = sftp_rm(conn, g.gl_pathv[i]);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_MKDIR:\n\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = 0777;\n\t\terr = sftp_mkdir(conn, path1, &a, 1);\n\t\tbreak;\n\tcase I_RMDIR:\n\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\terr = sftp_rmdir(conn, path1);\n\t\tbreak;\n\tcase I_CHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(startdir);\n\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\tif ((tmp = sftp_realpath(conn, path1)) == NULL) {\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (sftp_stat(conn, tmp, 0, &aa) != 0) {\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!(aa.flags & SSH2_FILEXFER_ATTR_PERMISSIONS)) {\n\t\t\terror(\"Can't change directory: Can't check target\");\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!S_ISDIR(aa.perm)) {\n\t\t\terror(\"Can't change directory: \\\"%s\\\" is not \"\n\t\t\t    \"a directory\", tmp);\n\t\t\tfree(tmp);\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfree(*pwd);\n\t\t*pwd = tmp;\n\t\tbreak;\n\tcase I_LS:\n\t\tif (!path1) {\n\t\t\tdo_ls_dir(conn, *pwd, *pwd, lflag);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttmp = NULL;\n\t\tif (!path_absolute(path1))\n\t\t\ttmp = *pwd;\n\n\t\tpath1 = make_absolute_pwd_glob(path1, *pwd);\n\t\terr = do_globbed_ls(conn, path1, tmp, lflag);\n\t\tbreak;\n\tcase I_DF:\n\t\t \n\t\tif (path1 == NULL)\n\t\t\tpath1 = xstrdup(*pwd);\n\t\tpath1 = sftp_make_absolute(path1, *pwd);\n\t\terr = do_df(conn, path1, hflag, iflag);\n\t\tbreak;\n\tcase I_LCHDIR:\n\t\tif (path1 == NULL || *path1 == '\\0')\n\t\t\tpath1 = xstrdup(\"~\");\n\t\ttmp = tilde_expand_filename(path1, getuid());\n\t\tfree(path1);\n\t\tpath1 = tmp;\n\t\tif (chdir(path1) == -1) {\n\t\t\terror(\"Couldn't change local directory to \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LMKDIR:\n\t\tif (mkdir(path1, 0777) == -1) {\n\t\t\terror(\"Couldn't create local directory \"\n\t\t\t    \"\\\"%s\\\": %s\", path1, strerror(errno));\n\t\t\terr = 1;\n\t\t}\n\t\tbreak;\n\tcase I_LLS:\n\t\tlocal_do_ls(cmd);\n\t\tbreak;\n\tcase I_SHELL:\n\t\tlocal_do_shell(cmd);\n\t\tbreak;\n\tcase I_LUMASK:\n\t\tumask(n_arg);\n\t\tprintf(\"Local umask: %03lo\\n\", n_arg);\n\t\tbreak;\n\tcase I_CHMOD:\n\t\tpath1 = make_absolute_pwd_glob(path1, *pwd);\n\t\tattrib_clear(&a);\n\t\ta.flags |= SSH2_FILEXFER_ATTR_PERMISSIONS;\n\t\ta.perm = n_arg;\n\t\tsftp_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing mode on %s\\n\",\n\t\t\t\t    g.gl_pathv[i]);\n\t\t\terr = (hflag ? sftp_lsetstat : sftp_setstat)(conn,\n\t\t\t    g.gl_pathv[i], &a);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_CHOWN:\n\tcase I_CHGRP:\n\t\tpath1 = make_absolute_pwd_glob(path1, *pwd);\n\t\tsftp_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n\t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n\t\t\tif ((hflag ? sftp_lstat : sftp_stat)(conn,\n\t\t\t    g.gl_pathv[i], 0, &aa) != 0) {\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(aa.flags & SSH2_FILEXFER_ATTR_UIDGID)) {\n\t\t\t\terror(\"Can't get current ownership of \"\n\t\t\t\t    \"remote file \\\"%s\\\"\", g.gl_pathv[i]);\n\t\t\t\tif (err_abort) {\n\t\t\t\t\terr = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taa.flags &= SSH2_FILEXFER_ATTR_UIDGID;\n\t\t\tif (cmdnum == I_CHOWN) {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing owner on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa.uid = n_arg;\n\t\t\t} else {\n\t\t\t\tif (!quiet)\n\t\t\t\t\tmprintf(\"Changing group on %s\\n\",\n\t\t\t\t\t    g.gl_pathv[i]);\n\t\t\t\taa.gid = n_arg;\n\t\t\t}\n\t\t\terr = (hflag ? sftp_lsetstat : sftp_setstat)(conn,\n\t\t\t    g.gl_pathv[i], &aa);\n\t\t\tif (err != 0 && err_abort)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase I_PWD:\n\t\tmprintf(\"Remote working directory: %s\\n\", *pwd);\n\t\tbreak;\n\tcase I_LPWD:\n\t\tif (!getcwd(path_buf, sizeof(path_buf))) {\n\t\t\terror(\"Couldn't get local cwd: %s\", strerror(errno));\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmprintf(\"Local working directory: %s\\n\", path_buf);\n\t\tbreak;\n\tcase I_QUIT:\n\t\t \n\t\tbreak;\n\tcase I_HELP:\n\t\thelp();\n\t\tbreak;\n\tcase I_VERSION:\n\t\tprintf(\"SFTP protocol version %u\\n\", sftp_proto_version(conn));\n\t\tbreak;\n\tcase I_PROGRESS:\n\t\tshowprogress = !showprogress;\n\t\tif (showprogress)\n\t\t\tprintf(\"Progress meter enabled\\n\");\n\t\telse\n\t\t\tprintf(\"Progress meter disabled\\n\");\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%d is not implemented\", cmdnum);\n\t}\n\n\tif (g.gl_pathc)\n\t\tglobfree(&g);\n\tfree(path1);\n\tfree(path2);\n\n\t \n\tif (err_abort && err != 0)\n\t\treturn (-1);\n\telse if (cmdnum == I_QUIT)\n\t\treturn (1);\n\n\treturn (0);\n}\n\n#ifdef USE_LIBEDIT\nstatic char *\nprompt(EditLine *el)\n{\n\treturn (\"sftp> \");\n}\n\n \nstatic void\ncomplete_display(char **list, u_int len)\n{\n\tu_int y, m = 0, width = 80, columns = 1, colspace = 0, llen;\n\tstruct winsize ws;\n\tchar *tmp;\n\n\t \n\tfor (y = 0; list[y]; y++)\n\t\tm = MAXIMUM(m, strlen(list[y]));\n\n\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) != -1)\n\t\twidth = ws.ws_col;\n\n\tm = m > len ? m - len : 0;\n\tcolumns = width / (m + 2);\n\tcolumns = MAXIMUM(columns, 1);\n\tcolspace = width / columns;\n\tcolspace = MINIMUM(colspace, width);\n\n\tprintf(\"\\n\");\n\tm = 1;\n\tfor (y = 0; list[y]; y++) {\n\t\tllen = strlen(list[y]);\n\t\ttmp = llen > len ? list[y] + len : \"\";\n\t\tmprintf(\"%-*s\", colspace, tmp);\n\t\tif (m >= columns) {\n\t\t\tprintf(\"\\n\");\n\t\t\tm = 1;\n\t\t} else\n\t\t\tm++;\n\t}\n\tprintf(\"\\n\");\n}\n\n \nstatic char *\ncomplete_ambiguous(const char *word, char **list, size_t count)\n{\n\tif (word == NULL)\n\t\treturn NULL;\n\n\tif (count > 0) {\n\t\tu_int y, matchlen = strlen(list[0]);\n\n\t\t \n\t\tfor (y = 1; list[y]; y++) {\n\t\t\tu_int x;\n\n\t\t\tfor (x = 0; x < matchlen; x++)\n\t\t\t\tif (list[0][x] != list[y][x])\n\t\t\t\t\tbreak;\n\n\t\t\tmatchlen = x;\n\t\t}\n\n\t\tif (matchlen > strlen(word)) {\n\t\t\tchar *tmp = xstrdup(list[0]);\n\n\t\t\ttmp[matchlen] = '\\0';\n\t\t\treturn tmp;\n\t\t}\n\t}\n\n\treturn xstrdup(word);\n}\n\n \nstatic int\ncomplete_cmd_parse(EditLine *el, char *cmd, int lastarg, char quote,\n    int terminated)\n{\n\tu_int y, count = 0, cmdlen, tmplen;\n\tchar *tmp, **list, argterm[3];\n\tconst LineInfo *lf;\n\n\tlist = xcalloc((sizeof(cmds) / sizeof(*cmds)) + 1, sizeof(char *));\n\n\t \n\tif (cmd == NULL) {\n\t\tfor (y = 0; cmds[y].c; y++)\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\n\t\tlist[count] = NULL;\n\t\tcomplete_display(list, 0);\n\n\t\tfor (y = 0; list[y] != NULL; y++)\n\t\t\tfree(list[y]);\n\t\tfree(list);\n\t\treturn count;\n\t}\n\n\t \n\tcmdlen = strlen(cmd);\n\tfor (y = 0; cmds[y].c; y++)  {\n\t\tif (!strncasecmp(cmd, cmds[y].c, cmdlen))\n\t\t\tlist[count++] = xstrdup(cmds[y].c);\n\t}\n\tlist[count] = NULL;\n\n\tif (count == 0) {\n\t\tfree(list);\n\t\treturn 0;\n\t}\n\n\t \n\ttmp = complete_ambiguous(cmd, list, count);\n\tif (count > 1)\n\t\tcomplete_display(list, 0);\n\n\tfor (y = 0; list[y]; y++)\n\t\tfree(list[y]);\n\tfree(list);\n\n\tif (tmp != NULL) {\n\t\ttmplen = strlen(tmp);\n\t\tcmdlen = strlen(cmd);\n\t\t \n\t\tif (tmplen > cmdlen)\n\t\t\tif (el_insertstr(el, tmp + cmdlen) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\tlf = el_line(el);\n\t\t \n\t\tif (count == 1) {\n\t\t\ty = 0;\n\t\t\tif (!terminated)\n\t\t\t\targterm[y++] = quote;\n\t\t\tif (lastarg || *(lf->cursor) != ' ')\n\t\t\t\targterm[y++] = ' ';\n\t\t\targterm[y] = '\\0';\n\t\t\tif (y > 0 && el_insertstr(el, argterm) == -1)\n\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t}\n\t\tfree(tmp);\n\t}\n\n\treturn count;\n}\n\n \nstatic int\ncomplete_is_remote(char *cmd, int cmdarg) {\n\tint i;\n\n\tif (cmd == NULL)\n\t\treturn -1;\n\n\tfor (i = 0; cmds[i].c; i++) {\n\t\tif (!strncasecmp(cmd, cmds[i].c, strlen(cmds[i].c))) {\n\t\t\tif (cmdarg == 1)\n\t\t\t\treturn cmds[i].t;\n\t\t\telse if (cmdarg == 2)\n\t\t\t\treturn cmds[i].t2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n \nstatic int\ncomplete_match(EditLine *el, struct sftp_conn *conn, char *remote_path,\n    char *file, int remote, int lastarg, char quote, int terminated)\n{\n\tglob_t g;\n\tchar *tmp, *tmp2, ins[8];\n\tu_int i, hadglob, pwdlen, len, tmplen, filelen, cesc, isesc, isabs;\n\tint clen;\n\tconst LineInfo *lf;\n\n\t \n\tif (file == NULL)\n\t\ttmp = xstrdup(\"*\");\n\telse\n\t\txasprintf(&tmp, \"%s*\", file);\n\n\t \n\tisabs = path_absolute(tmp);\n\n\tmemset(&g, 0, sizeof(g));\n\tif (remote != LOCAL) {\n\t\ttmp = make_absolute_pwd_glob(tmp, remote_path);\n\t\tsftp_glob(conn, tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\t} else\n\t\t(void)glob(tmp, GLOB_DOOFFS|GLOB_MARK, NULL, &g);\n\n\t \n\tfor (hadglob = tmplen = pwdlen = 0; tmp[tmplen] != 0; tmplen++) {\n\t\t \n\t\tif (tmp[tmplen] == '*' || tmp[tmplen] == '?') {\n\t\t\tif (tmp[tmplen] != '*' || tmp[tmplen + 1] != '\\0')\n\t\t\t\thadglob = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (tmp[tmplen] == '\\\\' && tmp[tmplen + 1] != '\\0')\n\t\t\ttmplen++;\n\t\tif (tmp[tmplen] == '/')\n\t\t\tpwdlen = tmplen + 1;\t \n\t}\n\tfree(tmp);\n\ttmp = NULL;\n\n\tif (g.gl_matchc == 0)\n\t\tgoto out;\n\n\tif (g.gl_matchc > 1)\n\t\tcomplete_display(g.gl_pathv, pwdlen);\n\n\t \n\tif (file == NULL || hadglob)\n\t\tgoto out;\n\n\ttmp2 = complete_ambiguous(file, g.gl_pathv, g.gl_matchc);\n\ttmp = path_strip(tmp2, isabs ? NULL : remote_path);\n\tfree(tmp2);\n\n\tif (tmp == NULL)\n\t\tgoto out;\n\n\ttmplen = strlen(tmp);\n\tfilelen = strlen(file);\n\n\t \n\tcesc = isesc = 0;\n\tfor (i = 0; i < filelen; i++) {\n\t\tif (!isesc && file[i] == '\\\\' && i + 1 < filelen){\n\t\t\tisesc = 1;\n\t\t\tcesc++;\n\t\t} else\n\t\t\tisesc = 0;\n\t}\n\n\tif (tmplen > (filelen - cesc)) {\n\t\ttmp2 = tmp + filelen - cesc;\n\t\tlen = strlen(tmp2);\n\t\t \n\t\tfor (i = 0; i < len; i += clen) {\n\t\t\tif ((clen = mblen(tmp2 + i, len - i)) < 0 ||\n\t\t\t    (size_t)clen > sizeof(ins) - 2)\n\t\t\t\tfatal(\"invalid multibyte character\");\n\t\t\tins[0] = '\\\\';\n\t\t\tmemcpy(ins + 1, tmp2 + i, clen);\n\t\t\tins[clen + 1] = '\\0';\n\t\t\tswitch (tmp2[i]) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\t':\n\t\t\tcase '[':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\tcase '*':\n\t\t\t\tif (quote == '\\0' || tmp2[i] == quote) {\n\t\t\t\t\tif (el_insertstr(el, ins) == -1)\n\t\t\t\t\t\tfatal(\"el_insertstr \"\n\t\t\t\t\t\t    \"failed.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\tdefault:\n\t\t\t\tif (el_insertstr(el, ins + 1) == -1)\n\t\t\t\t\tfatal(\"el_insertstr failed.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlf = el_line(el);\n\tif (g.gl_matchc == 1) {\n\t\ti = 0;\n\t\tif (!terminated && quote != '\\0')\n\t\t\tins[i++] = quote;\n\t\tif (*(lf->cursor - 1) != '/' &&\n\t\t    (lastarg || *(lf->cursor) != ' '))\n\t\t\tins[i++] = ' ';\n\t\tins[i] = '\\0';\n\t\tif (i > 0 && el_insertstr(el, ins) == -1)\n\t\t\tfatal(\"el_insertstr failed.\");\n\t}\n\tfree(tmp);\n\n out:\n\tglobfree(&g);\n\treturn g.gl_matchc;\n}\n\n \nstatic unsigned char\ncomplete(EditLine *el, int ch)\n{\n\tchar **argv, *line, quote;\n\tint argc, carg;\n\tu_int cursor, len, terminated, ret = CC_ERROR;\n\tconst LineInfo *lf;\n\tstruct complete_ctx *complete_ctx;\n\n\tlf = el_line(el);\n\tif (el_get(el, EL_CLIENTDATA, (void**)&complete_ctx) != 0)\n\t\tfatal_f(\"el_get failed\");\n\n\t \n\tcursor = lf->cursor - lf->buffer;\n\tline = xmalloc(cursor + 1);\n\tmemcpy(line, lf->buffer, cursor);\n\tline[cursor] = '\\0';\n\targv = makeargv(line, &carg, 1, &quote, &terminated);\n\tfree(line);\n\n\t \n\tlen = lf->lastchar - lf->buffer;\n\tline = xmalloc(len + 1);\n\tmemcpy(line, lf->buffer, len);\n\tline[len] = '\\0';\n\targv = makeargv(line, &argc, 1, NULL, NULL);\n\n\t \n\tif (line[cursor] != ' ' && line[cursor] != '\\0' &&\n\t    line[cursor] != '\\n') {\n\t\tfree(line);\n\t\treturn ret;\n\t}\n\n\tif (carg == 0) {\n\t\t \n\t\tcomplete_cmd_parse(el, NULL, argc == carg, '\\0', 1);\n\t\tret = CC_REDISPLAY;\n\t} else if (carg == 1 && cursor > 0 && line[cursor - 1] != ' ')  {\n\t\t \n\t\tif (complete_cmd_parse(el, argv[0], argc == carg,\n\t\t    quote, terminated) != 0)\n\t\t\tret = CC_REDISPLAY;\n\t} else if (carg >= 1) {\n\t\t \n\t\tint remote = 0;\n\t\tint i = 0, cmdarg = 0;\n\t\tchar *filematch = NULL;\n\n\t\tif (carg > 1 && line[cursor-1] != ' ')\n\t\t\tfilematch = argv[carg - 1];\n\n\t\tfor (i = 1; i < carg; i++) {\n\t\t\t \n\t\t\tif (argv[i][0] != '-')\n\t\t\t\tcmdarg++;\n\t\t}\n\n\t\t \n\t\tif (line[cursor - 1] == ' ')\n\t\t\tcmdarg++;\n\n\t\tremote = complete_is_remote(argv[0], cmdarg);\n\n\t\tif ((remote == REMOTE || remote == LOCAL) &&\n\t\t    complete_match(el, complete_ctx->conn,\n\t\t    *complete_ctx->remote_pathp, filematch,\n\t\t    remote, carg == argc, quote, terminated) != 0)\n\t\t\tret = CC_REDISPLAY;\n\t}\n\n\tfree(line);\n\treturn ret;\n}\n#endif  \n\nstatic int\ninteractive_loop(struct sftp_conn *conn, char *file1, char *file2)\n{\n\tchar *remote_path;\n\tchar *dir = NULL, *startdir = NULL;\n\tchar cmd[2048];\n\tint err, interactive;\n\tEditLine *el = NULL;\n#ifdef USE_LIBEDIT\n\tHistory *hl = NULL;\n\tHistEvent hev;\n\textern char *__progname;\n\tstruct complete_ctx complete_ctx;\n\n\tif (!batchmode && isatty(STDIN_FILENO)) {\n\t\tif ((el = el_init(__progname, stdin, stdout, stderr)) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline\");\n\t\tif ((hl = history_init()) == NULL)\n\t\t\tfatal(\"Couldn't initialise editline history\");\n\t\thistory(hl, &hev, H_SETSIZE, 100);\n\t\tel_set(el, EL_HIST, history, hl);\n\n\t\tel_set(el, EL_PROMPT, prompt);\n\t\tel_set(el, EL_EDITOR, \"emacs\");\n\t\tel_set(el, EL_TERMINAL, NULL);\n\t\tel_set(el, EL_SIGNAL, 1);\n\t\tel_source(el, NULL);\n\n\t\t \n\t\tel_set(el, EL_ADDFN, \"ftp-complete\",\n\t\t    \"Context sensitive argument completion\", complete);\n\t\tcomplete_ctx.conn = conn;\n\t\tcomplete_ctx.remote_pathp = &remote_path;\n\t\tel_set(el, EL_CLIENTDATA, (void*)&complete_ctx);\n\t\tel_set(el, EL_BIND, \"^I\", \"ftp-complete\", NULL);\n\t\t \n\t\tel_set(el, EL_BIND, \"\\\\e[1;5C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e\\\\e[C\", \"em-next-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e[1;5D\", \"ed-prev-word\", NULL);\n\t\tel_set(el, EL_BIND, \"\\\\e\\\\e[D\", \"ed-prev-word\", NULL);\n\t\t \n\t\tel_set(el, EL_BIND, \"^w\", \"ed-delete-prev-word\", NULL);\n\t}\n#endif  \n\n\tif ((remote_path = sftp_realpath(conn, \".\")) == NULL)\n\t\tfatal(\"Need cwd\");\n\tstartdir = xstrdup(remote_path);\n\n\tif (file1 != NULL) {\n\t\tdir = xstrdup(file1);\n\t\tdir = sftp_make_absolute(dir, remote_path);\n\n\t\tif (sftp_remote_is_dir(conn, dir) && file2 == NULL) {\n\t\t\tif (!quiet)\n\t\t\t\tmprintf(\"Changing to: %s\\n\", dir);\n\t\t\tsnprintf(cmd, sizeof cmd, \"cd \\\"%s\\\"\", dir);\n\t\t\tif (parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0) != 0) {\n\t\t\t\tfree(dir);\n\t\t\t\tfree(startdir);\n\t\t\t\tfree(remote_path);\n\t\t\t\tfree(conn);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tsnprintf(cmd, sizeof cmd, \"get%s %s%s%s\",\n\t\t\t    global_aflag ? \" -a\" : \"\", dir,\n\t\t\t    file2 == NULL ? \"\" : \" \",\n\t\t\t    file2 == NULL ? \"\" : file2);\n\t\t\terr = parse_dispatch_command(conn, cmd,\n\t\t\t    &remote_path, startdir, 1, 0);\n\t\t\tfree(dir);\n\t\t\tfree(startdir);\n\t\t\tfree(remote_path);\n\t\t\tfree(conn);\n\t\t\treturn (err);\n\t\t}\n\t\tfree(dir);\n\t}\n\n\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\tsetvbuf(infile, NULL, _IOLBF, 0);\n\n\tinteractive = !batchmode && isatty(STDIN_FILENO);\n\terr = 0;\n\tfor (;;) {\n\t\tstruct sigaction sa;\n\n\t\tinterrupted = 0;\n\t\tmemset(&sa, 0, sizeof(sa));\n\t\tsa.sa_handler = interactive ? read_interrupt : killchild;\n\t\tif (sigaction(SIGINT, &sa, NULL) == -1) {\n\t\t\tdebug3(\"sigaction(%s): %s\", strsignal(SIGINT),\n\t\t\t    strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\tif (el == NULL) {\n\t\t\tif (interactive)\n\t\t\t\tprintf(\"sftp> \");\n\t\t\tif (fgets(cmd, sizeof(cmd), infile) == NULL) {\n\t\t\t\tif (interactive)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\tif (interrupted)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n#ifdef USE_LIBEDIT\n\t\t\tconst char *line;\n\t\t\tint count = 0;\n\n\t\t\tif ((line = el_gets(el, &count)) == NULL ||\n\t\t\t    count <= 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tif (interrupted)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thistory(hl, &hev, H_ENTER, line);\n\t\t\tif (strlcpy(cmd, line, sizeof(cmd)) >= sizeof(cmd)) {\n\t\t\t\tfprintf(stderr, \"Error: input line too long\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#endif  \n\t\t}\n\n\t\tcmd[strcspn(cmd, \"\\n\")] = '\\0';\n\n\t\t \n\t\tinterrupted = 0;\n\t\tssh_signal(SIGINT, cmd_interrupt);\n\n\t\terr = parse_dispatch_command(conn, cmd, &remote_path,\n\t\t    startdir, batchmode, !interactive && el == NULL);\n\t\tif (err != 0)\n\t\t\tbreak;\n\t}\n\tssh_signal(SIGCHLD, SIG_DFL);\n\tfree(remote_path);\n\tfree(startdir);\n\tfree(conn);\n\n#ifdef USE_LIBEDIT\n\tif (el != NULL)\n\t\tel_end(el);\n#endif  \n\n\t \n\treturn (err >= 0 ? 0 : -1);\n}\n\nstatic void\nconnect_to_server(char *path, char **args, int *in, int *out)\n{\n\tint c_in, c_out;\n#ifdef USE_PIPES\n\tint pin[2], pout[2];\n\n\tif ((pipe(pin) == -1) || (pipe(pout) == -1))\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\t*in = pin[0];\n\t*out = pout[1];\n\tc_in = pout[0];\n\tc_out = pin[1];\n#else  \n\tint inout[2];\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)\n\t\tfatal(\"socketpair: %s\", strerror(errno));\n\t*in = *out = inout[0];\n\tc_in = c_out = inout[1];\n#endif  \n\n\tif ((sshpid = fork()) == -1)\n\t\tfatal(\"fork: %s\", strerror(errno));\n\telse if (sshpid == 0) {\n\t\tif ((dup2(c_in, STDIN_FILENO) == -1) ||\n\t\t    (dup2(c_out, STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(*in);\n\t\tclose(*out);\n\t\tclose(c_in);\n\t\tclose(c_out);\n\n\t\t \n\t\tssh_signal(SIGINT, SIG_IGN);\n\t\tssh_signal(SIGTERM, SIG_DFL);\n\t\texecvp(path, args);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", path, strerror(errno));\n\t\t_exit(1);\n\t}\n\n\tssh_signal(SIGTERM, killchild);\n\tssh_signal(SIGINT, killchild);\n\tssh_signal(SIGHUP, killchild);\n\tssh_signal(SIGTSTP, suspchild);\n\tssh_signal(SIGTTIN, suspchild);\n\tssh_signal(SIGTTOU, suspchild);\n\tssh_signal(SIGCHLD, sigchld_handler);\n\tclose(c_in);\n\tclose(c_out);\n}\n\nstatic void\nusage(void)\n{\n\textern char *__progname;\n\n\tfprintf(stderr,\n\t    \"usage: %s [-46AaCfNpqrv] [-B buffer_size] [-b batchfile] [-c cipher]\\n\"\n\t    \"          [-D sftp_server_command] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"          [-J destination] [-l limit] [-o ssh_option] [-P port]\\n\"\n\t    \"          [-R num_requests] [-S program] [-s subsystem | sftp_server]\\n\"\n\t    \"          [-X sftp_option] destination\\n\",\n\t    __progname);\n\texit(1);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint r, in, out, ch, err, tmp, port = -1, noisy = 0;\n\tchar *host = NULL, *user, *cp, **cpp, *file2 = NULL;\n\tint debug_level = 0;\n\tchar *file1 = NULL, *sftp_server = NULL;\n\tchar *ssh_program = _PATH_SSH_PROGRAM, *sftp_direct = NULL;\n\tconst char *errstr;\n\tLogLevel ll = SYSLOG_LEVEL_INFO;\n\targlist args;\n\textern int optind;\n\textern char *optarg;\n\tstruct sftp_conn *conn;\n\tsize_t copy_buffer_len = 0;\n\tsize_t num_requests = 0;\n\tlong long llv, limit_kbps = 0;\n\n\t \n\tsanitise_stdfd();\n\tmsetlocale();\n\n\t__progname = ssh_get_progname(argv[0]);\n\tmemset(&args, '\\0', sizeof(args));\n\targs.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-oForwardX11 no\");\n\taddargs(&args, \"-oPermitLocalCommand no\");\n\taddargs(&args, \"-oClearAllForwardings yes\");\n\n\tll = SYSLOG_LEVEL_INFO;\n\tinfile = stdin;\n\n\twhile ((ch = getopt(argc, argv,\n\t    \"1246AafhNpqrvCc:D:i:l:o:s:S:b:B:F:J:P:R:X:\")) != -1) {\n\t\tswitch (ch) {\n\t\t \n\t\tcase 'A':\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\t \n\t\tcase 'F':\n\t\tcase 'J':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'o':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tll = SYSLOG_LEVEL_ERROR;\n\t\t\tquiet = 1;\n\t\t\tshowprogress = 0;\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tport = a2port(optarg);\n\t\t\tif (port <= 0)\n\t\t\t\tfatal(\"Bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (debug_level < 3) {\n\t\t\t\taddargs(&args, \"-v\");\n\t\t\t\tll = SYSLOG_LEVEL_DEBUG1 + debug_level;\n\t\t\t}\n\t\t\tdebug_level++;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tglobal_aflag = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tcopy_buffer_len = strtol(optarg, &cp, 10);\n\t\t\tif (copy_buffer_len == 0 || *cp != '\\0')\n\t\t\t\tfatal(\"Invalid buffer size \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tif (batchmode)\n\t\t\t\tfatal(\"Batch file already specified.\");\n\n\t\t\t \n\t\t\tif (strcmp(optarg, \"-\") != 0 &&\n\t\t\t    (infile = fopen(optarg, \"r\")) == NULL)\n\t\t\t\tfatal(\"%s (%s).\", strerror(errno), optarg);\n\t\t\tshowprogress = 0;\n\t\t\tquiet = batchmode = 1;\n\t\t\taddargs(&args, \"-obatchmode yes\");\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tglobal_fflag = 1;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tnoisy = 1;  \n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tglobal_pflag = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tsftp_direct = optarg;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024;  \n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tglobal_rflag = 1;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tnum_requests = strtol(optarg, &cp, 10);\n\t\t\tif (num_requests == 0 || *cp != '\\0')\n\t\t\t\tfatal(\"Invalid number of requests \\\"%s\\\"\",\n\t\t\t\t    optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsftp_server = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = optarg;\n\t\t\treplacearg(&args, 0, \"%s\", ssh_program);\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\t \n\t\t\tif (strncmp(optarg, \"buffer=\", 7) == 0) {\n\t\t\t\tr = scan_scaled(optarg + 7, &llv);\n\t\t\t\tif (r == 0 && (llv <= 0 || llv > 256 * 1024)) {\n\t\t\t\t\tr = -1;\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t}\n\t\t\t\tif (r == -1) {\n\t\t\t\t\tfatal(\"Invalid buffer size \\\"%s\\\": %s\",\n\t\t\t\t\t     optarg + 7, strerror(errno));\n\t\t\t\t}\n\t\t\t\tcopy_buffer_len = (size_t)llv;\n\t\t\t} else if (strncmp(optarg, \"nrequests=\", 10) == 0) {\n\t\t\t\tllv = strtonum(optarg + 10, 1, 256 * 1024,\n\t\t\t\t    &errstr);\n\t\t\t\tif (errstr != NULL) {\n\t\t\t\t\tfatal(\"Invalid number of requests \"\n\t\t\t\t\t    \"\\\"%s\\\": %s\", optarg + 10, errstr);\n\t\t\t\t}\n\t\t\t\tnum_requests = (size_t)llv;\n\t\t\t} else {\n\t\t\t\tfatal(\"Invalid -X option\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\t \n\taddargs(&args, \"-oForwardAgent no\");\n\n\tif (!isatty(STDERR_FILENO))\n\t\tshowprogress = 0;\n\n\tif (noisy)\n\t\tquiet = 0;\n\n\tlog_init(argv[0], ll, SYSLOG_FACILITY_USER, 1);\n\n\tif (sftp_direct == NULL) {\n\t\tif (optind == argc || argc > (optind + 2))\n\t\t\tusage();\n\t\targv += optind;\n\n\t\tswitch (parse_uri(\"sftp\", *argv, &user, &host, &tmp, &file1)) {\n\t\tcase -1:\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (tmp != -1)\n\t\t\t\tport = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (parse_user_host_path(*argv, &user, &host,\n\t\t\t    &file1) == 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (parse_user_host_port(*argv, &user, &host, NULL)\n\t\t\t    == 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\thost = xstrdup(*argv);\n\t\t\thost = cleanhostname(host);\n\t\t\tbreak;\n\t\t}\n\t\tfile2 = *(argv + 1);\n\n\t\tif (!*host) {\n\t\t\tfprintf(stderr, \"Missing hostname\\n\");\n\t\t\tusage();\n\t\t}\n\n\t\tif (port != -1)\n\t\t\taddargs(&args, \"-oPort %d\", port);\n\t\tif (user != NULL) {\n\t\t\taddargs(&args, \"-l\");\n\t\t\taddargs(&args, \"%s\", user);\n\t\t}\n\n\t\t \n\t\tif (sftp_server == NULL || strchr(sftp_server, '/') == NULL)\n\t\t\taddargs(&args, \"-s\");\n\n\t\taddargs(&args, \"--\");\n\t\taddargs(&args, \"%s\", host);\n\t\taddargs(&args, \"%s\", (sftp_server != NULL ?\n\t\t    sftp_server : \"sftp\"));\n\n\t\tconnect_to_server(ssh_program, args.list, &in, &out);\n\t} else {\n\t\tif ((r = argv_split(sftp_direct, &tmp, &cpp, 1)) != 0)\n\t\t\tfatal_r(r, \"Parse -D arguments\");\n\t\tif (cpp[0] == 0)\n\t\t\tfatal(\"No sftp server specified via -D\");\n\t\tconnect_to_server(cpp[0], cpp, &in, &out);\n\t\targv_free(cpp, tmp);\n\t}\n\tfreeargs(&args);\n\n\tconn = sftp_init(in, out, copy_buffer_len, num_requests, limit_kbps);\n\tif (conn == NULL)\n\t\tfatal(\"Couldn't initialise connection to server\");\n\n\tif (!quiet) {\n\t\tif (sftp_direct == NULL)\n\t\t\tfprintf(stderr, \"Connected to %s.\\n\", host);\n\t\telse\n\t\t\tfprintf(stderr, \"Attached to %s.\\n\", sftp_direct);\n\t}\n\n\terr = interactive_loop(conn, file1, file2);\n\n#if !defined(USE_PIPES)\n\tshutdown(in, SHUT_RDWR);\n\tshutdown(out, SHUT_RDWR);\n#endif\n\n\tclose(in);\n\tclose(out);\n\tif (batchmode)\n\t\tfclose(infile);\n\n\twhile (waitpid(sshpid, NULL, 0) == -1 && sshpid > 1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for ssh process: %s\",\n\t\t\t    strerror(errno));\n\n\texit(err == 0 ? 0 : 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}