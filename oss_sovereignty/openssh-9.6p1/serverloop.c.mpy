{
  "module_name": "serverloop.c",
  "hash_id": "5da96ceb037768f33bfc2709df2cec2cad3e3652a25462a2b4d862c453ec41bc",
  "original_prompt": "Ingested from openssh-9.6p1/serverloop.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <limits.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <signal.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"canohost.h\"\n#include \"sshpty.h\"\n#include \"channels.h\"\n#include \"ssh2.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"kex.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"session.h\"\n#include \"dispatch.h\"\n#include \"auth-options.h\"\n#include \"serverloop.h\"\n#include \"ssherr.h\"\n\nextern ServerOptions options;\n\n \nextern Authctxt *the_authctxt;\nextern struct sshauthopt *auth_opts;\nextern int use_privsep;\n\nstatic int no_more_sessions = 0;  \n\nstatic volatile sig_atomic_t child_terminated = 0;\t \n\n \nstatic volatile sig_atomic_t received_sigterm = 0;\n\n \nstatic void server_init_dispatch(struct ssh *);\n\n \nchar *tun_fwd_ifnames = NULL;\n\n \nstatic int\nbind_permitted(int port, uid_t uid)\n{\n\tif (use_privsep)\n\t\treturn 1;  \n\tif (port < IPPORT_RESERVED && uid != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void\nsigchld_handler(int sig)\n{\n\tchild_terminated = 1;\n}\n\nstatic void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}\n\nstatic void\nclient_alive_check(struct ssh *ssh)\n{\n\tchar remote_id[512];\n\tint r, channel_id;\n\n\t \n\tif (options.client_alive_count_max > 0 &&\n\t    ssh_packet_inc_alive_timeouts(ssh) >\n\t    options.client_alive_count_max) {\n\t\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\t\tlogit(\"Timeout, client not responding from %s\", remote_id);\n\t\tcleanup_exit(255);\n\t}\n\n\t \n\tif ((channel_id = channel_find_open(ssh)) == -1) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"keepalive@openssh.com\"))\n\t\t    != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 1)) != 0)  \n\t\t\tfatal_fr(r, \"compose\");\n\t} else {\n\t\tchannel_request_start(ssh, channel_id,\n\t\t    \"keepalive@openssh.com\", 1);\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send\");\n}\n\n \nstatic void\nwait_until_can_do_something(struct ssh *ssh,\n    int connection_in, int connection_out, struct pollfd **pfdp,\n    u_int *npfd_allocp, u_int *npfd_activep, sigset_t *sigsetp,\n    int *conn_in_readyp, int *conn_out_readyp)\n{\n\tstruct timespec timeout;\n\tchar remote_id[512];\n\tint ret;\n\tint client_alive_scheduled = 0;\n\tu_int p;\n\ttime_t now;\n\tstatic time_t last_client_time, unused_connection_expiry;\n\n\t*conn_in_readyp = *conn_out_readyp = 0;\n\n\t \n\tptimeout_init(&timeout);\n\tchannel_prepare_poll(ssh, pfdp, npfd_allocp, npfd_activep, 2, &timeout);\n\tnow = monotime();\n\tif (*npfd_activep < 2)\n\t\tfatal_f(\"bad npfd %u\", *npfd_activep);  \n\tif (options.rekey_interval > 0 && !ssh_packet_is_rekeying(ssh)) {\n\t\tptimeout_deadline_sec(&timeout,\n\t\t    ssh_packet_get_rekey_timeout(ssh));\n\t}\n\n\t \n\tif (options.unused_connection_timeout != 0) {\n\t\tif (channel_still_open(ssh) || unused_connection_expiry == 0) {\n\t\t\tunused_connection_expiry = now +\n\t\t\t    options.unused_connection_timeout;\n\t\t}\n\t\tptimeout_deadline_monotime(&timeout, unused_connection_expiry);\n\t}\n\n\t \n\tif (options.client_alive_interval) {\n\t\t \n\t\tif (last_client_time == 0)\n\t\t\tlast_client_time = now;\n\t\tptimeout_deadline_sec(&timeout, options.client_alive_interval);\n\t\t \n\t\tclient_alive_scheduled = 1;\n\t}\n\n#if 0\n\t \n\tif (channel_not_very_much_buffered_data())\n#endif\n\t \n\t(*pfdp)[0].fd = connection_in;\n\t(*pfdp)[0].events = POLLIN;\n\t(*pfdp)[1].fd = connection_out;\n\t(*pfdp)[1].events = ssh_packet_have_data_to_write(ssh) ? POLLOUT : 0;\n\n\t \n\tif (child_terminated && ssh_packet_not_very_much_data_to_write(ssh))\n\t\tptimeout_deadline_ms(&timeout, 100);\n\n\t \n\tret = ppoll(*pfdp, *npfd_activep, ptimeout_get_tsp(&timeout), sigsetp);\n\n\tif (ret == -1) {\n\t\tfor (p = 0; p < *npfd_activep; p++)\n\t\t\t(*pfdp)[p].revents = 0;\n\t\tif (errno != EINTR)\n\t\t\tfatal_f(\"ppoll: %.100s\", strerror(errno));\n\t\treturn;\n\t}\n\n\t*conn_in_readyp = (*pfdp)[0].revents != 0;\n\t*conn_out_readyp = (*pfdp)[1].revents != 0;\n\n\tnow = monotime();  \n\t \n\tif (client_alive_scheduled) {\n\t\tif (ret == 0 &&\n\t\t    now >= last_client_time + options.client_alive_interval) {\n\t\t\t \n\t\t\tclient_alive_check(ssh);\n\t\t\tlast_client_time = now;\n\t\t} else if (ret != 0 && *conn_in_readyp) {\n\t\t\t \n\t\t\tlast_client_time = now;\n\t\t}\n\t}\n\n\t \n\tif (unused_connection_expiry != 0 &&\n\t    now > unused_connection_expiry && !channel_still_open(ssh)) {\n\t\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\t\tlogit(\"terminating inactive connection from %s\", remote_id);\n\t\tcleanup_exit(255);\n\t}\n}\n\n \nstatic int\nprocess_input(struct ssh *ssh, int connection_in)\n{\n\tint r;\n\n\tif ((r = ssh_packet_process_read(ssh, connection_in)) == 0)\n\t\treturn 0;  \n\tif (r == SSH_ERR_SYSTEM_ERROR) {\n\t\tif (errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK)\n\t\t\treturn 0;\n\t\tif (errno == EPIPE) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t}\n\t\tverbose(\"Read error from remote host %s port %d: %s\",\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    strerror(errno));\n\t\tcleanup_exit(255);\n\t}\n\treturn -1;\n}\n\n \nstatic void\nprocess_output(struct ssh *ssh, int connection_out)\n{\n\tint r;\n\n\t \n\tif ((r = ssh_packet_write_poll(ssh)) != 0) {\n\t\tsshpkt_fatal(ssh, r, \"%s: ssh_packet_write_poll\",\n\t\t    __func__);\n\t}\n}\n\nstatic void\nprocess_buffered_input_packets(struct ssh *ssh)\n{\n\tssh_dispatch_run_fatal(ssh, DISPATCH_NONBLOCK, NULL);\n}\n\nstatic void\ncollect_children(struct ssh *ssh)\n{\n\tpid_t pid;\n\tint status;\n\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid == -1 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(ssh, pid, status);\n\t\tchild_terminated = 0;\n\t}\n}\n\nvoid\nserver_loop2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstruct pollfd *pfd = NULL;\n\tu_int npfd_alloc = 0, npfd_active = 0;\n\tint r, conn_in_ready, conn_out_ready;\n\tu_int connection_in, connection_out;\n\tsigset_t bsigset, osigset;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tif (sigemptyset(&bsigset) == -1 || sigaddset(&bsigset, SIGCHLD) == -1)\n\t\terror_f(\"bsigset setup: %s\", strerror(errno));\n\tssh_signal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = ssh_packet_get_connection_in(ssh);\n\tconnection_out = ssh_packet_get_connection_out(ssh);\n\n\tif (!use_privsep) {\n\t\tssh_signal(SIGTERM, sigterm_handler);\n\t\tssh_signal(SIGINT, sigterm_handler);\n\t\tssh_signal(SIGQUIT, sigterm_handler);\n\t}\n\n\tserver_init_dispatch(ssh);\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets(ssh);\n\n\t\tif (!ssh_packet_is_rekeying(ssh) &&\n\t\t    ssh_packet_not_very_much_data_to_write(ssh))\n\t\t\tchannel_output_poll(ssh);\n\n\t\t \n\t\tif (sigprocmask(SIG_BLOCK, &bsigset, &osigset) == -1)\n\t\t\terror_f(\"bsigset sigprocmask: %s\", strerror(errno));\n\t\tcollect_children(ssh);\n\t\twait_until_can_do_something(ssh, connection_in, connection_out,\n\t\t    &pfd, &npfd_alloc, &npfd_active, &osigset,\n\t\t    &conn_in_ready, &conn_out_ready);\n\t\tif (sigprocmask(SIG_UNBLOCK, &bsigset, &osigset) == -1)\n\t\t\terror_f(\"osigset sigprocmask: %s\", strerror(errno));\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t \n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tchannel_after_poll(ssh, pfd, npfd_active);\n\t\tif (conn_in_ready &&\n\t\t    process_input(ssh, connection_in) < 0)\n\t\t\tbreak;\n\t\t \n\t\tif ((r = ssh_packet_check_rekey(ssh)) != 0)\n\t\t\tfatal_fr(r, \"cannot start rekeying\");\n\t\tif (conn_out_ready)\n\t\t\tprocess_output(ssh, connection_out);\n\t}\n\tcollect_children(ssh);\n\tfree(pfd);\n\n\t \n\tchannel_free_all(ssh);\n\n\t \n\tsession_destroy_all(ssh, NULL);\n}\n\nstatic int\nserver_input_keep_alive(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tdebug(\"Got %d/%u for keepalive\", type, seq);\n\t \n\tssh_packet_set_alive_timeouts(ssh, 0);\n\treturn 0;\n}\n\nstatic Channel *\nserver_request_direct_tcpip(struct ssh *ssh, int *reason, const char **errmsg)\n{\n\tChannel *c = NULL;\n\tchar *target = NULL, *originator = NULL;\n\tu_int target_port = 0, originator_port = 0;\n\tint r;\n\n\tif ((r = sshpkt_get_cstring(ssh, &target, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &target_port)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &originator, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &originator_port)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tif (target_port > 0xFFFF) {\n\t\terror_f(\"invalid target port\");\n\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\tgoto out;\n\t}\n\tif (originator_port > 0xFFFF) {\n\t\terror_f(\"invalid originator port\");\n\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t\tgoto out;\n\t}\n\n\tdebug_f(\"originator %s port %u, target %s port %u\",\n\t    originator, originator_port, target, target_port);\n\n\t \n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(ssh, target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\", reason, errmsg);\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t\tif (reason != NULL)\n\t\t\t*reason = SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED;\n\t}\n\n out:\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}\n\nstatic Channel *\nserver_request_direct_streamlocal(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *target = NULL, *originator = NULL;\n\tu_int originator_port = 0;\n\tstruct passwd *pw = the_authctxt->pw;\n\tint r;\n\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal_f(\"no/invalid user\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &target, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &originator, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &originator_port)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tif (originator_port > 0xFFFF) {\n\t\terror_f(\"invalid originator port\");\n\t\tgoto out;\n\t}\n\n\tdebug_f(\"originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\n\t \n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    auth_opts->permit_port_forwarding_flag &&\n\t    !options.disable_forwarding && (pw->pw_uid == 0 || use_privsep)) {\n\t\tc = channel_connect_to_path(ssh, target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\nout:\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}\n\nstatic Channel *\nserver_request_tun(struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tu_int mode, tun;\n\tint r, sock;\n\tchar *tmp, *ifname = NULL;\n\n\tif ((r = sshpkt_get_u32(ssh, &mode)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse mode\", __func__);\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tssh_packet_send_debug(ssh, \"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tssh_packet_send_debug(ssh, \"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\tif ((r = sshpkt_get_u32(ssh, &tun)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse device\", __func__);\n\tif (tun > INT_MAX) {\n\t\tdebug_f(\"invalid tun\");\n\t\tgoto done;\n\t}\n\tif (auth_opts->force_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY &&\n\t\t    auth_opts->force_tun_device != (int)tun)\n\t\t\tgoto done;\n\t\ttun = auth_opts->force_tun_device;\n\t}\n\tsock = tun_open(tun, mode, &ifname);\n\tif (sock < 0)\n\t\tgoto done;\n\tdebug(\"Tunnel forwarding using interface %s\", ifname);\n\n\tc = channel_new(ssh, \"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n#if defined(SSH_TUN_FILTER)\n\tif (mode == SSH_TUNMODE_POINTOPOINT)\n\t\tchannel_register_filter(ssh, c->self, sys_tun_infilter,\n\t\t    sys_tun_outfilter, NULL, NULL);\n#endif\n\n\t \n\ttmp = tun_fwd_ifnames;\n\txasprintf(&tun_fwd_ifnames, \"%s%s%s\",\n\t    tun_fwd_ifnames == NULL ? \"\" : tun_fwd_ifnames,\n\t    tun_fwd_ifnames == NULL ? \"\" : \",\",\n\t    ifname);\n\tfree(tmp);\n\tfree(ifname);\n\n done:\n\tif (c == NULL)\n\t\tssh_packet_send_debug(ssh, \"Failed to open the tunnel device.\");\n\treturn c;\n}\n\nstatic Channel *\nserver_request_session(struct ssh *ssh)\n{\n\tChannel *c;\n\tint r;\n\n\tdebug(\"input_session_request\");\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tif (no_more_sessions) {\n\t\tssh_packet_disconnect(ssh, \"Possible attack: attempt to open a \"\n\t\t    \"session after additional sessions disabled\");\n\t}\n\n\t \n\tc = channel_new(ssh, \"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1,  0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(ssh, c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 0);\n\treturn c;\n}\n\nstatic int\nserver_input_channel_open(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c = NULL;\n\tchar *ctype = NULL;\n\tconst char *errmsg = NULL;\n\tint r, reason = SSH2_OPEN_CONNECT_FAILED;\n\tu_int rchan = 0, rmaxpack = 0, rwindow = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &ctype, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &rchan)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &rwindow)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &rmaxpack)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tdebug_f(\"ctype %s rchan %u win %u max %u\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"session\") == 0) {\n\t\tc = server_request_session(ssh);\n\t} else if (strcmp(ctype, \"direct-tcpip\") == 0) {\n\t\tc = server_request_direct_tcpip(ssh, &reason, &errmsg);\n\t} else if (strcmp(ctype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\tc = server_request_direct_streamlocal(ssh);\n\t} else if (strcmp(ctype, \"tun@openssh.com\") == 0) {\n\t\tc = server_request_tun(ssh);\n\t}\n\tif (c != NULL) {\n\t\tdebug_f(\"confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->have_remote_id = 1;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->self)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_window)) != 0 ||\n\t\t\t    (r = sshpkt_put_u32(ssh, c->local_maxpacket)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\t\tsshpkt_fatal(ssh, r,\n\t\t\t\t    \"%s: send open confirm\", __func__);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdebug_f(\"failure %s\", ctype);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_CHANNEL_OPEN_FAILURE)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, rchan)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, reason)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, errmsg ? errmsg : \"open failed\")) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0) {\n\t\t\tsshpkt_fatal(ssh, r,\n\t\t\t    \"%s: send open failure\", __func__);\n\t\t}\n\t}\n\tfree(ctype);\n\treturn 0;\n}\n\nstatic int\nserver_input_hostkeys_prove(struct ssh *ssh, struct sshbuf **respp)\n{\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, success = 0;\n\tconst u_char *blob;\n\tconst char *sigalg, *kex_rsa_sigalg = NULL;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif (sshkey_type_plain(sshkey_type_from_name(\n\t    ssh->kex->hostkey_alg)) == KEY_RSA)\n\t\tkex_rsa_sigalg = ssh->kex->hostkey_alg;\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror_fr(r, \"parse key\");\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror_f(\"unknown host %s key\", sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror_f(\"can't retrieve hostkey %d\", ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\t \n\t\tsigalg = NULL;\n\t\tif (sshkey_type_plain(key->type) == KEY_RSA) {\n\t\t\tif (kex_rsa_sigalg != NULL)\n\t\t\t\tsigalg = kex_rsa_sigalg;\n\t\t\telse if (ssh->kex->flags & KEX_RSA_SHA2_512_SUPPORTED)\n\t\t\t\tsigalg = \"rsa-sha2-512\";\n\t\t\telse if (ssh->kex->flags & KEX_RSA_SHA2_256_SUPPORTED)\n\t\t\t\tsigalg = \"rsa-sha2-256\";\n\t\t}\n\t\tdebug3_f(\"sign %s key (index %d) using sigalg %s\",\n\t\t    sshkey_type(key), ndx, sigalg == NULL ? \"default\" : sigalg);\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_stringb(sigbuf,\n\t\t    ssh->kex->session_id)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(ssh, key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf), sigalg)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror_fr(r, \"assemble signature\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\t*respp = resp;\n\tresp = NULL;  \n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}\n\nstatic int\nserver_input_global_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *rtype = NULL;\n\tu_char want_reply = 0;\n\tint r, success = 0, allocated_listen_port = 0;\n\tu_int port = 0;\n\tstruct sshbuf *resp = NULL;\n\tstruct passwd *pw = the_authctxt->pw;\n\tstruct Forward fwd;\n\n\tmemset(&fwd, 0, sizeof(fwd));\n\tif (pw == NULL || !the_authctxt->valid)\n\t\tfatal_f(\"no/invalid user\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &rtype, NULL)) != 0 ||\n\t    (r = sshpkt_get_u8(ssh, &want_reply)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tdebug_f(\"rtype %s want_reply %d\", rtype, want_reply);\n\n\t \n\tif (strcmp(rtype, \"tcpip-forward\") == 0) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &fwd.listen_host, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u32(ssh, &port)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: parse tcpip-forward\", __func__);\n\t\tdebug_f(\"tcpip-forward listen %s port %u\",\n\t\t    fwd.listen_host, port);\n\t\tif (port <= INT_MAX)\n\t\t\tfwd.listen_port = (int)port;\n\t\t \n\t\tif (port > INT_MAX ||\n\t\t    (options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||\n\t\t    !auth_opts->permit_port_forwarding_flag ||\n\t\t    options.disable_forwarding ||\n\t\t    (!want_reply && fwd.listen_port == 0) ||\n\t\t    (fwd.listen_port != 0 &&\n\t\t    !bind_permitted(fwd.listen_port, pw->pw_uid))) {\n\t\t\tsuccess = 0;\n\t\t\tssh_packet_send_debug(ssh, \"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t \n\t\t\tsuccess = channel_setup_remote_fwd_listener(ssh, &fwd,\n\t\t\t    &allocated_listen_port, &options.fwd_opts);\n\t\t}\n\t\tif ((resp = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new\");\n\t\tif (allocated_listen_port != 0 &&\n\t\t    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_put_u32\");\n\t} else if (strcmp(rtype, \"cancel-tcpip-forward\") == 0) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &fwd.listen_host, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u32(ssh, &port)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: parse cancel-tcpip-forward\", __func__);\n\n\t\tdebug_f(\"cancel-tcpip-forward addr %s port %d\",\n\t\t    fwd.listen_host, port);\n\t\tif (port <= INT_MAX) {\n\t\t\tfwd.listen_port = (int)port;\n\t\t\tsuccess = channel_cancel_rport_listener(ssh, &fwd);\n\t\t}\n\t} else if (strcmp(rtype, \"streamlocal-forward@openssh.com\") == 0) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &fwd.listen_path, NULL)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: parse streamlocal-forward@openssh.com\", __func__);\n\t\tdebug_f(\"streamlocal-forward listen path %s\",\n\t\t    fwd.listen_path);\n\n\t\t \n\t\tif ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0\n\t\t    || !auth_opts->permit_port_forwarding_flag ||\n\t\t    options.disable_forwarding ||\n\t\t    (pw->pw_uid != 0 && !use_privsep)) {\n\t\t\tsuccess = 0;\n\t\t\tssh_packet_send_debug(ssh, \"Server has disabled \"\n\t\t\t    \"streamlocal forwarding.\");\n\t\t} else {\n\t\t\t \n\t\t\tsuccess = channel_setup_remote_fwd_listener(ssh,\n\t\t\t    &fwd, NULL, &options.fwd_opts);\n\t\t}\n\t} else if (strcmp(rtype, \"cancel-streamlocal-forward@openssh.com\") == 0) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &fwd.listen_path, NULL)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: parse cancel-streamlocal-forward@openssh.com\", __func__);\n\t\tdebug_f(\"cancel-streamlocal-forward path %s\",\n\t\t    fwd.listen_path);\n\n\t\tsuccess = channel_cancel_rport_listener(ssh, &fwd);\n\t} else if (strcmp(rtype, \"no-more-sessions@openssh.com\") == 0) {\n\t\tno_more_sessions = 1;\n\t\tsuccess = 1;\n\t} else if (strcmp(rtype, \"hostkeys-prove-00@openssh.com\") == 0) {\n\t\tsuccess = server_input_hostkeys_prove(ssh, &resp);\n\t}\n\t \n\tif (want_reply) {\n\t\tif ((r = sshpkt_start(ssh, success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE)) != 0 ||\n\t\t    (success && resp != NULL && (r = sshpkt_putb(ssh, resp)) != 0) ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: send reply\", __func__);\n\t}\n\tfree(fwd.listen_host);\n\tfree(fwd.listen_path);\n\tfree(rtype);\n\tsshbuf_free(resp);\n\treturn 0;\n}\n\nstatic int\nserver_input_channel_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tChannel *c;\n\tint r, success = 0;\n\tchar *rtype = NULL;\n\tu_char want_reply = 0;\n\tu_int id = 0;\n\n\tif ((r = sshpkt_get_u32(ssh, &id)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &rtype, NULL)) != 0 ||\n\t    (r = sshpkt_get_u8(ssh, &want_reply)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tdebug(\"server_input_channel_req: channel %u request %s reply %d\",\n\t    id, rtype, want_reply);\n\n\tif (id >= INT_MAX || (c = channel_lookup(ssh, (int)id)) == NULL) {\n\t\tssh_packet_disconnect(ssh, \"%s: unknown channel %d\",\n\t\t    __func__, id);\n\t}\n\tif (!strcmp(rtype, \"eow@openssh.com\")) {\n\t\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\t\tchan_rcvd_eow(ssh, c);\n\t} else if ((c->type == SSH_CHANNEL_LARVAL ||\n\t    c->type == SSH_CHANNEL_OPEN) && strcmp(c->ctype, \"session\") == 0)\n\t\tsuccess = session_input_channel_req(ssh, c, rtype);\n\tif (want_reply && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tif (!c->have_remote_id)\n\t\t\tfatal_f(\"channel %d: no remote_id\", c->self);\n\t\tif ((r = sshpkt_start(ssh, success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, c->remote_id)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: send reply\", __func__);\n\t}\n\tfree(rtype);\n\treturn 0;\n}\n\nstatic void\nserver_init_dispatch(struct ssh *ssh)\n{\n\tdebug(\"server_init_dispatch\");\n\tssh_dispatch_init(ssh, &dispatch_protocol_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tssh_dispatch_set(ssh, SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tssh_dispatch_set(ssh, SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tssh_dispatch_set(ssh, SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tssh_dispatch_set(ssh, SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}