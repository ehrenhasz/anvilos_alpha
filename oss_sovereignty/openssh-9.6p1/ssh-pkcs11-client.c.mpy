{
  "module_name": "ssh-pkcs11-client.c",
  "hash_id": "74b752e4703502fd3c54e7a805872b570e8a5b612aec08930281f46b7c6db4df",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-pkcs11-client.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef ENABLE_PKCS11\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/socket.h>\n\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <limits.h>\n\n#include <openssl/ecdsa.h>\n#include <openssl/rsa.h>\n\n#include \"pathnames.h\"\n#include \"xmalloc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"atomicio.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#if !defined(OPENSSL_HAS_ECC) || !defined(HAVE_EC_KEY_METHOD_NEW)\n#define EC_KEY_METHOD void\n#define EC_KEY void\n#endif\n\n \n\n \nstruct helper {\n\tchar *path;\n\tpid_t pid;\n\tint fd;\n\tRSA_METHOD *rsa_meth;\n\tEC_KEY_METHOD *ec_meth;\n\tint (*rsa_finish)(RSA *rsa);\n\tvoid (*ec_finish)(EC_KEY *key);\n\tsize_t nrsa, nec;  \n};\nstatic struct helper **helpers;\nstatic size_t nhelpers;\n\nstatic struct helper *\nhelper_by_provider(const char *path)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nhelpers; i++) {\n\t\tif (helpers[i] == NULL || helpers[i]->path == NULL ||\n\t\t    helpers[i]->fd == -1)\n\t\t\tcontinue;\n\t\tif (strcmp(helpers[i]->path, path) == 0)\n\t\t\treturn helpers[i];\n\t}\n\treturn NULL;\n}\n\nstatic struct helper *\nhelper_by_rsa(const RSA *rsa)\n{\n\tsize_t i;\n\tconst RSA_METHOD *meth;\n\n\tif ((meth = RSA_get_method(rsa)) == NULL)\n\t\treturn NULL;\n\tfor (i = 0; i < nhelpers; i++) {\n\t\tif (helpers[i] != NULL && helpers[i]->rsa_meth == meth)\n\t\t\treturn helpers[i];\n\t}\n\treturn NULL;\n\n}\n\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\nstatic struct helper *\nhelper_by_ec(const EC_KEY *ec)\n{\n\tsize_t i;\n\tconst EC_KEY_METHOD *meth;\n\n\tif ((meth = EC_KEY_get_method(ec)) == NULL)\n\t\treturn NULL;\n\tfor (i = 0; i < nhelpers; i++) {\n\t\tif (helpers[i] != NULL && helpers[i]->ec_meth == meth)\n\t\t\treturn helpers[i];\n\t}\n\treturn NULL;\n\n}\n#endif  \n\nstatic void\nhelper_free(struct helper *helper)\n{\n\tsize_t i;\n\tint found = 0;\n\n\tif (helper == NULL)\n\t\treturn;\n\tif (helper->path == NULL || helper->ec_meth == NULL ||\n\t    helper->rsa_meth == NULL)\n\t\tfatal_f(\"inconsistent helper\");\n\tdebug3_f(\"free helper for provider %s\", helper->path);\n\tfor (i = 0; i < nhelpers; i++) {\n\t\tif (helpers[i] == helper) {\n\t\t\tif (found)\n\t\t\t\tfatal_f(\"helper recorded more than once\");\n\t\t\tfound = 1;\n\t\t}\n\t\telse if (found)\n\t\t\thelpers[i - 1] = helpers[i];\n\t}\n\tif (found) {\n\t\thelpers = xrecallocarray(helpers, nhelpers,\n\t\t    nhelpers - 1, sizeof(*helpers));\n\t\tnhelpers--;\n\t}\n\tfree(helper->path);\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\tEC_KEY_METHOD_free(helper->ec_meth);\n#endif\n\tRSA_meth_free(helper->rsa_meth);\n\tfree(helper);\n}\n\nstatic void\nhelper_terminate(struct helper *helper)\n{\n\tif (helper == NULL) {\n\t\treturn;\n\t} else if (helper->fd == -1) {\n\t\tdebug3_f(\"already terminated\");\n\t} else {\n\t\tdebug3_f(\"terminating helper for %s; \"\n\t\t    \"remaining %zu RSA %zu ECDSA\",\n\t\t    helper->path, helper->nrsa, helper->nec);\n\t\tclose(helper->fd);\n\t\t \n\t\thelper->fd = -1;\n\t\thelper->pid = -1;\n\t}\n\t \n\tif (helper->nrsa == 0 && helper->nec == 0)\n\t\thelper_free(helper);\n}\n\nstatic void\nsend_msg(int fd, struct sshbuf *m)\n{\n\tu_char buf[4];\n\tsize_t mlen = sshbuf_len(m);\n\tint r;\n\n\tif (fd == -1)\n\t\treturn;\n\tPOKE_U32(buf, mlen);\n\tif (atomicio(vwrite, fd, buf, 4) != 4 ||\n\t    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),\n\t    sshbuf_len(m)) != sshbuf_len(m))\n\t\terror(\"write to helper failed\");\n\tif ((r = sshbuf_consume(m, mlen)) != 0)\n\t\tfatal_fr(r, \"consume\");\n}\n\nstatic int\nrecv_msg(int fd, struct sshbuf *m)\n{\n\tu_int l, len;\n\tu_char c, buf[1024];\n\tint r;\n\n\tsshbuf_reset(m);\n\tif (fd == -1)\n\t\treturn 0;  \n\tif ((len = atomicio(read, fd, buf, 4)) != 4) {\n\t\terror(\"read from helper failed: %u\", len);\n\t\treturn (0);  \n\t}\n\tlen = PEEK_U32(buf);\n\tif (len > 256 * 1024)\n\t\tfatal(\"response too long: %u\", len);\n\t \n\twhile (len > 0) {\n\t\tl = len;\n\t\tif (l > sizeof(buf))\n\t\t\tl = sizeof(buf);\n\t\tif (atomicio(read, fd, buf, l) != l) {\n\t\t\terror(\"response from helper failed.\");\n\t\t\treturn (0);  \n\t\t}\n\t\tif ((r = sshbuf_put(m, buf, l)) != 0)\n\t\t\tfatal_fr(r, \"sshbuf_put\");\n\t\tlen -= l;\n\t}\n\tif ((r = sshbuf_get_u8(m, &c)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\treturn c;\n}\n\nint\npkcs11_init(int interactive)\n{\n\treturn 0;\n}\n\nvoid\npkcs11_terminate(void)\n{\n\tsize_t i;\n\n\tdebug3_f(\"terminating %zu helpers\", nhelpers);\n\tfor (i = 0; i < nhelpers; i++)\n\t\thelper_terminate(helpers[i]);\n}\n\nstatic int\nrsa_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa, int padding)\n{\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *msg = NULL;\n\tu_char *blob = NULL, *signature = NULL;\n\tsize_t blen, slen = 0;\n\tint r, ret = -1;\n\tstruct helper *helper;\n\n\tif ((helper = helper_by_rsa(rsa)) == NULL || helper->fd == -1)\n\t\tfatal_f(\"no helper for PKCS11 key\");\n\tdebug3_f(\"signing with PKCS11 provider %s\", helper->path);\n\tif (padding != RSA_PKCS1_PADDING)\n\t\tgoto fail;\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror_f(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\tkey->type = KEY_RSA;\n\tRSA_up_ref(rsa);\n\tkey->rsa = rsa;\n\tif ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {\n\t\terror_fr(r, \"encode key\");\n\t\tgoto fail;\n\t}\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||\n\t    (r = sshbuf_put_string(msg, from, flen)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(helper->fd, msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(helper->fd, msg) == SSH2_AGENT_SIGN_RESPONSE) {\n\t\tif ((r = sshbuf_get_string(msg, &signature, &slen)) != 0)\n\t\t\tfatal_fr(r, \"parse\");\n\t\tif (slen <= (size_t)RSA_size(rsa)) {\n\t\t\tmemcpy(to, signature, slen);\n\t\t\tret = slen;\n\t\t}\n\t\tfree(signature);\n\t}\n fail:\n\tfree(blob);\n\tsshkey_free(key);\n\tsshbuf_free(msg);\n\treturn (ret);\n}\n\nstatic int\nrsa_finish(RSA *rsa)\n{\n\tstruct helper *helper;\n\n\tif ((helper = helper_by_rsa(rsa)) == NULL)\n\t\tfatal_f(\"no helper for PKCS11 key\");\n\tdebug3_f(\"free PKCS11 RSA key for provider %s\", helper->path);\n\tif (helper->rsa_finish != NULL)\n\t\thelper->rsa_finish(rsa);\n\tif (helper->nrsa == 0)\n\t\tfatal_f(\"RSA refcount error\");\n\thelper->nrsa--;\n\tdebug3_f(\"provider %s remaining keys: %zu RSA %zu ECDSA\",\n\t    helper->path, helper->nrsa, helper->nec);\n\tif (helper->nrsa == 0 && helper->nec == 0)\n\t\thelper_terminate(helper);\n\treturn 1;\n}\n\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\nstatic ECDSA_SIG *\necdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,\n    const BIGNUM *rp, EC_KEY *ec)\n{\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *msg = NULL;\n\tECDSA_SIG *ret = NULL;\n\tconst u_char *cp;\n\tu_char *blob = NULL, *signature = NULL;\n\tsize_t blen, slen = 0;\n\tint r, nid;\n\tstruct helper *helper;\n\n\tif ((helper = helper_by_ec(ec)) == NULL || helper->fd == -1)\n\t\tfatal_f(\"no helper for PKCS11 key\");\n\tdebug3_f(\"signing with PKCS11 provider %s\", helper->path);\n\tnid = sshkey_ecdsa_key_to_nid(ec);\n\tif (nid < 0) {\n\t\terror_f(\"couldn't get curve nid\");\n\t\tgoto fail;\n\t}\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror_f(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\tkey->ecdsa = ec;\n\tkey->ecdsa_nid = nid;\n\tkey->type = KEY_ECDSA;\n\tEC_KEY_up_ref(ec);\n\n\tif ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {\n\t\terror_fr(r, \"encode key\");\n\t\tgoto fail;\n\t}\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||\n\t    (r = sshbuf_put_string(msg, dgst, dgst_len)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(helper->fd, msg);\n\tsshbuf_reset(msg);\n\n\tif (recv_msg(helper->fd, msg) == SSH2_AGENT_SIGN_RESPONSE) {\n\t\tif ((r = sshbuf_get_string(msg, &signature, &slen)) != 0)\n\t\t\tfatal_fr(r, \"parse\");\n\t\tcp = signature;\n\t\tret = d2i_ECDSA_SIG(NULL, &cp, slen);\n\t\tfree(signature);\n\t}\n\n fail:\n\tfree(blob);\n\tsshkey_free(key);\n\tsshbuf_free(msg);\n\treturn (ret);\n}\n\nstatic void\necdsa_do_finish(EC_KEY *ec)\n{\n\tstruct helper *helper;\n\n\tif ((helper = helper_by_ec(ec)) == NULL)\n\t\tfatal_f(\"no helper for PKCS11 key\");\n\tdebug3_f(\"free PKCS11 ECDSA key for provider %s\", helper->path);\n\tif (helper->ec_finish != NULL)\n\t\thelper->ec_finish(ec);\n\tif (helper->nec == 0)\n\t\tfatal_f(\"ECDSA refcount error\");\n\thelper->nec--;\n\tdebug3_f(\"provider %s remaining keys: %zu RSA %zu ECDSA\",\n\t    helper->path, helper->nrsa, helper->nec);\n\tif (helper->nrsa == 0 && helper->nec == 0)\n\t\thelper_terminate(helper);\n}\n#endif  \n\n \nstatic void\nwrap_key(struct helper *helper, struct sshkey *k)\n{\n\tdebug3_f(\"wrap %s for provider %s\", sshkey_type(k), helper->path);\n\tif (k->type == KEY_RSA) {\n\t\tRSA_set_method(k->rsa, helper->rsa_meth);\n\t\tif (helper->nrsa++ >= INT_MAX)\n\t\t\tfatal_f(\"RSA refcount error\");\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\t} else if (k->type == KEY_ECDSA) {\n\t\tEC_KEY_set_method(k->ecdsa, helper->ec_meth);\n\t\tif (helper->nec++ >= INT_MAX)\n\t\t\tfatal_f(\"EC refcount error\");\n#endif\n\t} else\n\t\tfatal_f(\"unknown key type\");\n\tk->flags |= SSHKEY_FLAG_EXT;\n\tdebug3_f(\"provider %s remaining keys: %zu RSA %zu ECDSA\",\n\t    helper->path, helper->nrsa, helper->nec);\n}\n\n \nint\npkcs11_make_cert(const struct sshkey *priv,\n    const struct sshkey *certpub, struct sshkey **certprivp)\n{\n\tstruct helper *helper = NULL;\n\tstruct sshkey *ret;\n\tint r;\n\n\tdebug3_f(\"private key type %s cert type %s\", sshkey_type(priv),\n\t    sshkey_type(certpub));\n\t*certprivp = NULL;\n\tif (!sshkey_is_cert(certpub) || sshkey_is_cert(priv) ||\n\t    !sshkey_equal_public(priv, certpub)) {\n\t\terror_f(\"private key %s doesn't match cert %s\",\n\t\t    sshkey_type(priv), sshkey_type(certpub));\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\t*certprivp = NULL;\n\tif (priv->type == KEY_RSA) {\n\t\tif ((helper = helper_by_rsa(priv->rsa)) == NULL ||\n\t\t    helper->fd == -1)\n\t\t\tfatal_f(\"no helper for PKCS11 RSA key\");\n\t\tif ((r = sshkey_from_private(priv, &ret)) != 0)\n\t\t\tfatal_fr(r, \"copy key\");\n\t\tRSA_set_method(ret->rsa, helper->rsa_meth);\n\t\tif (helper->nrsa++ >= INT_MAX)\n\t\t\tfatal_f(\"RSA refcount error\");\n\t} else if (priv->type == KEY_ECDSA) {\n\t\tif ((helper = helper_by_ec(priv->ecdsa)) == NULL ||\n\t\t    helper->fd == -1)\n\t\t\tfatal_f(\"no helper for PKCS11 EC key\");\n\t\tif ((r = sshkey_from_private(priv, &ret)) != 0)\n\t\t\tfatal_fr(r, \"copy key\");\n\t\tEC_KEY_set_method(ret->ecdsa, helper->ec_meth);\n\t\tif (helper->nec++ >= INT_MAX)\n\t\t\tfatal_f(\"EC refcount error\");\n\t} else\n\t\tfatal_f(\"unknown key type %s\", sshkey_type(priv));\n\n\tret->flags |= SSHKEY_FLAG_EXT;\n\tif ((r = sshkey_to_certified(ret)) != 0 ||\n\t    (r = sshkey_cert_copy(certpub, ret)) != 0)\n\t\tfatal_fr(r, \"graft certificate\");\n\tdebug3_f(\"provider %s remaining keys: %zu RSA %zu ECDSA\",\n\t    helper->path, helper->nrsa, helper->nec);\n\t \n\t*certprivp = ret;\n\treturn 0;\n}\n\nstatic int\npkcs11_start_helper_methods(struct helper *helper)\n{\n\tRSA_METHOD *rsa_meth;\n\tEC_KEY_METHOD *ec_meth = NULL;\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\tint (*ec_init)(EC_KEY *key);\n\tint (*ec_copy)(EC_KEY *dest, const EC_KEY *src);\n\tint (*ec_set_group)(EC_KEY *key, const EC_GROUP *grp);\n\tint (*ec_set_private)(EC_KEY *key, const BIGNUM *priv_key);\n\tint (*ec_set_public)(EC_KEY *key, const EC_POINT *pub_key);\n\tint (*ec_sign)(int, const unsigned char *, int, unsigned char *,\n\t    unsigned int *, const BIGNUM *, const BIGNUM *, EC_KEY *) = NULL;\n\n\tif ((ec_meth = EC_KEY_METHOD_new(EC_KEY_OpenSSL())) == NULL)\n\t\treturn -1;\n\tEC_KEY_METHOD_get_sign(ec_meth, &ec_sign, NULL, NULL);\n\tEC_KEY_METHOD_set_sign(ec_meth, ec_sign, NULL, ecdsa_do_sign);\n\tEC_KEY_METHOD_get_init(ec_meth, &ec_init, &helper->ec_finish,\n\t    &ec_copy, &ec_set_group, &ec_set_private, &ec_set_public);\n\tEC_KEY_METHOD_set_init(ec_meth, ec_init, ecdsa_do_finish,\n\t    ec_copy, ec_set_group, ec_set_private, ec_set_public);\n#endif  \n\n\tif ((rsa_meth = RSA_meth_dup(RSA_get_default_method())) == NULL)\n\t\tfatal_f(\"RSA_meth_dup failed\");\n\thelper->rsa_finish = RSA_meth_get_finish(rsa_meth);\n\tif (!RSA_meth_set1_name(rsa_meth, \"ssh-pkcs11-helper\") ||\n\t    !RSA_meth_set_priv_enc(rsa_meth, rsa_encrypt) ||\n\t    !RSA_meth_set_finish(rsa_meth, rsa_finish))\n\t\tfatal_f(\"failed to prepare method\");\n\n\thelper->ec_meth = ec_meth;\n\thelper->rsa_meth = rsa_meth;\n\treturn 0;\n}\n\nstatic struct helper *\npkcs11_start_helper(const char *path)\n{\n\tint pair[2];\n\tchar *prog, *verbosity = NULL;\n\tstruct helper *helper;\n\tpid_t pid;\n\n\tif (nhelpers >= INT_MAX)\n\t\tfatal_f(\"too many helpers\");\n\tdebug3_f(\"start helper for %s\", path);\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {\n\t\terror_f(\"socketpair: %s\", strerror(errno));\n\t\treturn NULL;\n\t}\n\thelper = xcalloc(1, sizeof(*helper));\n\tif (pkcs11_start_helper_methods(helper) == -1) {\n\t\terror_f(\"pkcs11_start_helper_methods failed\");\n\t\tgoto fail;\n\t}\n\tif ((pid = fork()) == -1) {\n\t\terror_f(\"fork: %s\", strerror(errno));\n fail:\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\tRSA_meth_free(helper->rsa_meth);\n#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)\n\t\tEC_KEY_METHOD_free(helper->ec_meth);\n#endif\n\t\tfree(helper);\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tif ((dup2(pair[1], STDIN_FILENO) == -1) ||\n\t\t    (dup2(pair[1], STDOUT_FILENO) == -1)) {\n\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n\t\t\t_exit(1);\n\t\t}\n\t\tclose(pair[0]);\n\t\tclose(pair[1]);\n\t\tprog = getenv(\"SSH_PKCS11_HELPER\");\n\t\tif (prog == NULL || strlen(prog) == 0)\n\t\t\tprog = _PATH_SSH_PKCS11_HELPER;\n\t\tif (log_level_get() >= SYSLOG_LEVEL_DEBUG1)\n\t\t\tverbosity = \"-vvv\";\n\t\tdebug_f(\"starting %s %s\", prog,\n\t\t    verbosity == NULL ? \"\" : verbosity);\n\t\texeclp(prog, prog, verbosity, (char *)NULL);\n\t\tfprintf(stderr, \"exec: %s: %s\\n\", prog, strerror(errno));\n\t\t_exit(1);\n\t}\n\tclose(pair[1]);\n\thelper->fd = pair[0];\n\thelper->path = xstrdup(path);\n\thelper->pid = pid;\n\tdebug3_f(\"helper %zu for \\\"%s\\\" on fd %d pid %ld\", nhelpers,\n\t    helper->path, helper->fd, (long)helper->pid);\n\thelpers = xrecallocarray(helpers, nhelpers,\n\t    nhelpers + 1, sizeof(*helpers));\n\thelpers[nhelpers++] = helper;\n\treturn helper;\n}\n\nint\npkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp,\n    char ***labelsp)\n{\n\tstruct sshkey *k;\n\tint r, type;\n\tu_char *blob;\n\tchar *label;\n\tsize_t blen;\n\tu_int nkeys, i;\n\tstruct sshbuf *msg;\n\tstruct helper *helper;\n\n\tif ((helper = helper_by_provider(name)) == NULL &&\n\t    (helper = pkcs11_start_helper(name)) == NULL)\n\t\treturn -1;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, pin)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(helper->fd, msg);\n\tsshbuf_reset(msg);\n\n\ttype = recv_msg(helper->fd, msg);\n\tif (type == SSH2_AGENT_IDENTITIES_ANSWER) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tfatal_fr(r, \"parse nkeys\");\n\t\t*keysp = xcalloc(nkeys, sizeof(struct sshkey *));\n\t\tif (labelsp)\n\t\t\t*labelsp = xcalloc(nkeys, sizeof(char *));\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\t \n\t\t\tif ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||\n\t\t\t    (r = sshbuf_get_cstring(msg, &label, NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse key\");\n\t\t\tif ((r = sshkey_from_blob(blob, blen, &k)) != 0)\n\t\t\t\tfatal_fr(r, \"decode key\");\n\t\t\twrap_key(helper, k);\n\t\t\t(*keysp)[i] = k;\n\t\t\tif (labelsp)\n\t\t\t\t(*labelsp)[i] = label;\n\t\t\telse\n\t\t\t\tfree(label);\n\t\t\tfree(blob);\n\t\t}\n\t} else if (type == SSH2_AGENT_FAILURE) {\n\t\tif ((r = sshbuf_get_u32(msg, &nkeys)) != 0)\n\t\t\tnkeys = -1;\n\t} else {\n\t\tnkeys = -1;\n\t}\n\tsshbuf_free(msg);\n\treturn (nkeys);\n}\n\nint\npkcs11_del_provider(char *name)\n{\n\tstruct helper *helper;\n\n\t \n\tdebug3_f(\"delete %s\", name);\n\tif ((helper = helper_by_provider(name)) != NULL)\n\t\thelper_terminate(helper);\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}